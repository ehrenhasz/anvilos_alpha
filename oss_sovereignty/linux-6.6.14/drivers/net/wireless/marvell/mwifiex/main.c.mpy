{
  "module_name": "main.c",
  "hash_id": "5ce1bf6c440fb6a88f30466cda6ea83f0834d5e28e0fd5179fe2abe2e72f5d22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/main.c",
  "human_readable_source": "\n \n\n#include <linux/suspend.h>\n\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"cfg80211.h\"\n#include \"11n.h\"\n\n#define VERSION\t\"1.0\"\n#define MFG_FIRMWARE\t\"mwifiex_mfg.bin\"\n\nstatic unsigned int debug_mask = MWIFIEX_DEFAULT_DEBUG_MASK;\nmodule_param(debug_mask, uint, 0);\nMODULE_PARM_DESC(debug_mask, \"bitmap for debug flags\");\n\nconst char driver_version[] = \"mwifiex \" VERSION \" (%s) \";\nstatic char *cal_data_cfg;\nmodule_param(cal_data_cfg, charp, 0);\n\nstatic unsigned short driver_mode;\nmodule_param(driver_mode, ushort, 0);\nMODULE_PARM_DESC(driver_mode,\n\t\t \"station=0x1(default), ap-sta=0x3, station-p2p=0x5, ap-sta-p2p=0x7\");\n\nbool mfg_mode;\nmodule_param(mfg_mode, bool, 0);\nMODULE_PARM_DESC(mfg_mode, \"manufacturing mode enable:1, disable:0\");\n\nbool aggr_ctrl;\nmodule_param(aggr_ctrl, bool, 0000);\nMODULE_PARM_DESC(aggr_ctrl, \"usb tx aggregation enable:1, disable:0\");\n\nconst u16 mwifiex_1d_to_wmm_queue[8] = { 1, 0, 0, 1, 2, 2, 3, 3 };\n\n \nstatic int mwifiex_register(void *card, struct device *dev,\n\t\t\t    struct mwifiex_if_ops *if_ops, void **padapter)\n{\n\tstruct mwifiex_adapter *adapter;\n\tint i;\n\n\tadapter = kzalloc(sizeof(struct mwifiex_adapter), GFP_KERNEL);\n\tif (!adapter)\n\t\treturn -ENOMEM;\n\n\t*padapter = adapter;\n\tadapter->dev = dev;\n\tadapter->card = card;\n\n\t \n\tmemmove(&adapter->if_ops, if_ops, sizeof(struct mwifiex_if_ops));\n\tadapter->debug_mask = debug_mask;\n\n\t \n\tif (adapter->if_ops.init_if)\n\t\tif (adapter->if_ops.init_if(adapter))\n\t\t\tgoto error;\n\n\tadapter->priv_num = 0;\n\n\tfor (i = 0; i < MWIFIEX_MAX_BSS_NUM; i++) {\n\t\t \n\t\tadapter->priv[i] =\n\t\t\tkzalloc(sizeof(struct mwifiex_private), GFP_KERNEL);\n\t\tif (!adapter->priv[i])\n\t\t\tgoto error;\n\n\t\tadapter->priv[i]->adapter = adapter;\n\t\tadapter->priv_num++;\n\t}\n\tmwifiex_init_lock_list(adapter);\n\n\ttimer_setup(&adapter->cmd_timer, mwifiex_cmd_timeout_func, 0);\n\n\treturn 0;\n\nerror:\n\tmwifiex_dbg(adapter, ERROR,\n\t\t    \"info: leave mwifiex_register with error\\n\");\n\n\tfor (i = 0; i < adapter->priv_num; i++)\n\t\tkfree(adapter->priv[i]);\n\n\tkfree(adapter);\n\n\treturn -1;\n}\n\n \nstatic int mwifiex_unregister(struct mwifiex_adapter *adapter)\n{\n\ts32 i;\n\n\tif (adapter->if_ops.cleanup_if)\n\t\tadapter->if_ops.cleanup_if(adapter);\n\n\ttimer_shutdown_sync(&adapter->cmd_timer);\n\n\t \n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (adapter->priv[i]) {\n\t\t\tmwifiex_free_curr_bcn(adapter->priv[i]);\n\t\t\tkfree(adapter->priv[i]);\n\t\t}\n\t}\n\n\tif (adapter->nd_info) {\n\t\tfor (i = 0 ; i < adapter->nd_info->n_matches ; i++)\n\t\t\tkfree(adapter->nd_info->matches[i]);\n\t\tkfree(adapter->nd_info);\n\t\tadapter->nd_info = NULL;\n\t}\n\n\tkfree(adapter->regd);\n\n\tkfree(adapter);\n\treturn 0;\n}\n\nvoid mwifiex_queue_main_work(struct mwifiex_adapter *adapter)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->main_proc_lock, flags);\n\tif (adapter->mwifiex_processing) {\n\t\tadapter->more_task_flag = true;\n\t\tspin_unlock_irqrestore(&adapter->main_proc_lock, flags);\n\t} else {\n\t\tspin_unlock_irqrestore(&adapter->main_proc_lock, flags);\n\t\tqueue_work(adapter->workqueue, &adapter->main_work);\n\t}\n}\nEXPORT_SYMBOL_GPL(mwifiex_queue_main_work);\n\nstatic void mwifiex_queue_rx_work(struct mwifiex_adapter *adapter)\n{\n\tspin_lock_bh(&adapter->rx_proc_lock);\n\tif (adapter->rx_processing) {\n\t\tspin_unlock_bh(&adapter->rx_proc_lock);\n\t} else {\n\t\tspin_unlock_bh(&adapter->rx_proc_lock);\n\t\tqueue_work(adapter->rx_workqueue, &adapter->rx_work);\n\t}\n}\n\nstatic int mwifiex_process_rx(struct mwifiex_adapter *adapter)\n{\n\tstruct sk_buff *skb;\n\tstruct mwifiex_rxinfo *rx_info;\n\n\tspin_lock_bh(&adapter->rx_proc_lock);\n\tif (adapter->rx_processing || adapter->rx_locked) {\n\t\tspin_unlock_bh(&adapter->rx_proc_lock);\n\t\tgoto exit_rx_proc;\n\t} else {\n\t\tadapter->rx_processing = true;\n\t\tspin_unlock_bh(&adapter->rx_proc_lock);\n\t}\n\n\t \n\twhile ((skb = skb_dequeue(&adapter->rx_data_q))) {\n\t\tatomic_dec(&adapter->rx_pending);\n\t\tif ((adapter->delay_main_work ||\n\t\t     adapter->iface_type == MWIFIEX_USB) &&\n\t\t    (atomic_read(&adapter->rx_pending) < LOW_RX_PENDING)) {\n\t\t\tif (adapter->if_ops.submit_rem_rx_urbs)\n\t\t\t\tadapter->if_ops.submit_rem_rx_urbs(adapter);\n\t\t\tadapter->delay_main_work = false;\n\t\t\tmwifiex_queue_main_work(adapter);\n\t\t}\n\t\trx_info = MWIFIEX_SKB_RXCB(skb);\n\t\tif (rx_info->buf_type == MWIFIEX_TYPE_AGGR_DATA) {\n\t\t\tif (adapter->if_ops.deaggr_pkt)\n\t\t\t\tadapter->if_ops.deaggr_pkt(adapter, skb);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t} else {\n\t\t\tmwifiex_handle_rx_packet(adapter, skb);\n\t\t}\n\t}\n\tspin_lock_bh(&adapter->rx_proc_lock);\n\tadapter->rx_processing = false;\n\tspin_unlock_bh(&adapter->rx_proc_lock);\n\nexit_rx_proc:\n\treturn 0;\n}\n\nstatic void maybe_quirk_fw_disable_ds(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA);\n\tstruct mwifiex_ver_ext ver_ext;\n\n\tif (test_and_set_bit(MWIFIEX_IS_REQUESTING_FW_VEREXT, &adapter->work_flags))\n\t\treturn;\n\n\tmemset(&ver_ext, 0, sizeof(ver_ext));\n\tver_ext.version_str_sel = 1;\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_VERSION_EXT,\n\t\t\t     HostCmd_ACT_GEN_GET, 0, &ver_ext, false)) {\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"Checking hardware revision failed.\\n\");\n\t}\n}\n\n \nint mwifiex_main_process(struct mwifiex_adapter *adapter)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->main_proc_lock, flags);\n\n\t \n\tif (adapter->mwifiex_processing || adapter->main_locked) {\n\t\tadapter->more_task_flag = true;\n\t\tspin_unlock_irqrestore(&adapter->main_proc_lock, flags);\n\t\treturn 0;\n\t} else {\n\t\tadapter->mwifiex_processing = true;\n\t\tspin_unlock_irqrestore(&adapter->main_proc_lock, flags);\n\t}\nprocess_start:\n\tdo {\n\t\tif (adapter->hw_status == MWIFIEX_HW_STATUS_NOT_READY)\n\t\t\tbreak;\n\n\t\t \n\t\tif (atomic_read(&adapter->rx_pending) >= HIGH_RX_PENDING &&\n\t\t    adapter->iface_type != MWIFIEX_USB) {\n\t\t\tadapter->delay_main_work = true;\n\t\t\tmwifiex_queue_rx_work(adapter);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (adapter->int_status) {\n\t\t\tif (adapter->hs_activated)\n\t\t\t\tmwifiex_process_hs_config(adapter);\n\t\t\tif (adapter->if_ops.process_int_status)\n\t\t\t\tadapter->if_ops.process_int_status(adapter);\n\t\t}\n\n\t\tif (adapter->rx_work_enabled && adapter->data_received)\n\t\t\tmwifiex_queue_rx_work(adapter);\n\n\t\t \n\t\tif ((adapter->ps_state == PS_STATE_SLEEP) &&\n\t\t    (adapter->pm_wakeup_card_req &&\n\t\t     !adapter->pm_wakeup_fw_try) &&\n\t\t    (is_command_pending(adapter) ||\n\t\t     !skb_queue_empty(&adapter->tx_data_q) ||\n\t\t     !mwifiex_bypass_txlist_empty(adapter) ||\n\t\t     !mwifiex_wmm_lists_empty(adapter))) {\n\t\t\tadapter->pm_wakeup_fw_try = true;\n\t\t\tmod_timer(&adapter->wakeup_timer, jiffies + (HZ*3));\n\t\t\tadapter->if_ops.wakeup(adapter);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (IS_CARD_RX_RCVD(adapter)) {\n\t\t\tadapter->data_received = false;\n\t\t\tadapter->pm_wakeup_fw_try = false;\n\t\t\tdel_timer(&adapter->wakeup_timer);\n\t\t\tif (adapter->ps_state == PS_STATE_SLEEP)\n\t\t\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t\t} else {\n\t\t\t \n\t\t\tif (adapter->pm_wakeup_fw_try)\n\t\t\t\tbreak;\n\t\t\tif (adapter->ps_state == PS_STATE_PRE_SLEEP)\n\t\t\t\tmwifiex_check_ps_cond(adapter);\n\n\t\t\tif (adapter->ps_state != PS_STATE_AWAKE)\n\t\t\t\tbreak;\n\t\t\tif (adapter->tx_lock_flag) {\n\t\t\t\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\t\t\t\tif (!adapter->usb_mc_setup)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((!adapter->scan_chan_gap_enabled &&\n\t\t\t     adapter->scan_processing) || adapter->data_sent ||\n\t\t\t     mwifiex_is_tdls_chan_switching\n\t\t\t     (mwifiex_get_priv(adapter,\n\t\t\t\t\t       MWIFIEX_BSS_ROLE_STA)) ||\n\t\t\t    (mwifiex_wmm_lists_empty(adapter) &&\n\t\t\t     mwifiex_bypass_txlist_empty(adapter) &&\n\t\t\t     skb_queue_empty(&adapter->tx_data_q))) {\n\t\t\t\tif (adapter->cmd_sent || adapter->curr_cmd ||\n\t\t\t\t\t!mwifiex_is_send_cmd_allowed\n\t\t\t\t\t\t(mwifiex_get_priv(adapter,\n\t\t\t\t\t\tMWIFIEX_BSS_ROLE_STA)) ||\n\t\t\t\t    (!is_command_pending(adapter)))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (adapter->event_received) {\n\t\t\tadapter->event_received = false;\n\t\t\tmwifiex_process_event(adapter);\n\t\t}\n\n\t\t \n\t\tif (adapter->cmd_resp_received) {\n\t\t\tadapter->cmd_resp_received = false;\n\t\t\tmwifiex_process_cmdresp(adapter);\n\n\t\t\t \n\t\t\tif (adapter->hw_status == MWIFIEX_HW_STATUS_INIT_DONE) {\n\t\t\t\tadapter->hw_status = MWIFIEX_HW_STATUS_READY;\n\t\t\t\tmwifiex_init_fw_complete(adapter);\n\t\t\t\tmaybe_quirk_fw_disable_ds(adapter);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (adapter->ps_state == PS_STATE_PRE_SLEEP)\n\t\t\tmwifiex_check_ps_cond(adapter);\n\n\t\t \n\t\tif ((adapter->ps_state == PS_STATE_SLEEP) ||\n\t\t    (adapter->ps_state == PS_STATE_PRE_SLEEP) ||\n\t\t    (adapter->ps_state == PS_STATE_SLEEP_CFM)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (adapter->tx_lock_flag) {\n\t\t\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\t\t\tif (!adapter->usb_mc_setup)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!adapter->cmd_sent && !adapter->curr_cmd &&\n\t\t    mwifiex_is_send_cmd_allowed\n\t\t    (mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA))) {\n\t\t\tif (mwifiex_exec_next_cmd(adapter) == -1) {\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (adapter->iface_type == MWIFIEX_USB &&\n\t\t    adapter->usb_mc_setup)\n\t\t\tcontinue;\n\n\t\tif ((adapter->scan_chan_gap_enabled ||\n\t\t     !adapter->scan_processing) &&\n\t\t    !adapter->data_sent &&\n\t\t    !skb_queue_empty(&adapter->tx_data_q)) {\n\t\t\tif (adapter->hs_activated_manually) {\n\t\t\t\tmwifiex_cancel_hs(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY),\n\t\t\t\t\t\t  MWIFIEX_ASYNC_CMD);\n\t\t\t\tadapter->hs_activated_manually = false;\n\t\t\t}\n\n\t\t\tmwifiex_process_tx_queue(adapter);\n\t\t\tif (adapter->hs_activated) {\n\t\t\t\tclear_bit(MWIFIEX_IS_HS_CONFIGURED,\n\t\t\t\t\t  &adapter->work_flags);\n\t\t\t\tmwifiex_hs_activated_event\n\t\t\t\t\t(mwifiex_get_priv\n\t\t\t\t\t(adapter, MWIFIEX_BSS_ROLE_ANY),\n\t\t\t\t\tfalse);\n\t\t\t}\n\t\t}\n\n\t\tif ((adapter->scan_chan_gap_enabled ||\n\t\t     !adapter->scan_processing) &&\n\t\t    !adapter->data_sent &&\n\t\t    !mwifiex_bypass_txlist_empty(adapter) &&\n\t\t    !mwifiex_is_tdls_chan_switching\n\t\t\t(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA))) {\n\t\t\tif (adapter->hs_activated_manually) {\n\t\t\t\tmwifiex_cancel_hs(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY),\n\t\t\t\t\t\t  MWIFIEX_ASYNC_CMD);\n\t\t\t\tadapter->hs_activated_manually = false;\n\t\t\t}\n\n\t\t\tmwifiex_process_bypass_tx(adapter);\n\t\t\tif (adapter->hs_activated) {\n\t\t\t\tclear_bit(MWIFIEX_IS_HS_CONFIGURED,\n\t\t\t\t\t  &adapter->work_flags);\n\t\t\t\tmwifiex_hs_activated_event\n\t\t\t\t\t(mwifiex_get_priv\n\t\t\t\t\t (adapter, MWIFIEX_BSS_ROLE_ANY),\n\t\t\t\t\t false);\n\t\t\t}\n\t\t}\n\n\t\tif ((adapter->scan_chan_gap_enabled ||\n\t\t     !adapter->scan_processing) &&\n\t\t    !adapter->data_sent && !mwifiex_wmm_lists_empty(adapter) &&\n\t\t    !mwifiex_is_tdls_chan_switching\n\t\t\t(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA))) {\n\t\t\tif (adapter->hs_activated_manually) {\n\t\t\t\tmwifiex_cancel_hs(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY),\n\t\t\t\t\t\t  MWIFIEX_ASYNC_CMD);\n\t\t\t\tadapter->hs_activated_manually = false;\n\t\t\t}\n\n\t\t\tmwifiex_wmm_process_tx(adapter);\n\t\t\tif (adapter->hs_activated) {\n\t\t\t\tclear_bit(MWIFIEX_IS_HS_CONFIGURED,\n\t\t\t\t\t  &adapter->work_flags);\n\t\t\t\tmwifiex_hs_activated_event\n\t\t\t\t\t(mwifiex_get_priv\n\t\t\t\t\t (adapter, MWIFIEX_BSS_ROLE_ANY),\n\t\t\t\t\t false);\n\t\t\t}\n\t\t}\n\n\t\tif (adapter->delay_null_pkt && !adapter->cmd_sent &&\n\t\t    !adapter->curr_cmd && !is_command_pending(adapter) &&\n\t\t    (mwifiex_wmm_lists_empty(adapter) &&\n\t\t     mwifiex_bypass_txlist_empty(adapter) &&\n\t\t     skb_queue_empty(&adapter->tx_data_q))) {\n\t\t\tif (!mwifiex_send_null_packet\n\t\t\t    (mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA),\n\t\t\t     MWIFIEX_TxPD_POWER_MGMT_NULL_PACKET |\n\t\t\t     MWIFIEX_TxPD_POWER_MGMT_LAST_PACKET)) {\n\t\t\t\tadapter->delay_null_pkt = false;\n\t\t\t\tadapter->ps_state = PS_STATE_SLEEP;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while (true);\n\n\tspin_lock_irqsave(&adapter->main_proc_lock, flags);\n\tif (adapter->more_task_flag) {\n\t\tadapter->more_task_flag = false;\n\t\tspin_unlock_irqrestore(&adapter->main_proc_lock, flags);\n\t\tgoto process_start;\n\t}\n\tadapter->mwifiex_processing = false;\n\tspin_unlock_irqrestore(&adapter->main_proc_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mwifiex_main_process);\n\n \nstatic void mwifiex_free_adapter(struct mwifiex_adapter *adapter)\n{\n\tif (!adapter) {\n\t\tpr_err(\"%s: adapter is NULL\\n\", __func__);\n\t\treturn;\n\t}\n\n\tmwifiex_unregister(adapter);\n\tpr_debug(\"info: %s: free adapter\\n\", __func__);\n}\n\n \nstatic void mwifiex_terminate_workqueue(struct mwifiex_adapter *adapter)\n{\n\tif (adapter->workqueue) {\n\t\tdestroy_workqueue(adapter->workqueue);\n\t\tadapter->workqueue = NULL;\n\t}\n\n\tif (adapter->rx_workqueue) {\n\t\tdestroy_workqueue(adapter->rx_workqueue);\n\t\tadapter->rx_workqueue = NULL;\n\t}\n}\n\n \nstatic int _mwifiex_fw_dpc(const struct firmware *firmware, void *context)\n{\n\tint ret;\n\tchar fmt[64];\n\tstruct mwifiex_adapter *adapter = context;\n\tstruct mwifiex_fw_image fw;\n\tbool init_failed = false;\n\tstruct wireless_dev *wdev;\n\tstruct completion *fw_done = adapter->fw_done;\n\n\tif (!firmware) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to get firmware %s\\n\", adapter->fw_name);\n\t\tgoto err_dnld_fw;\n\t}\n\n\tmemset(&fw, 0, sizeof(struct mwifiex_fw_image));\n\tadapter->firmware = firmware;\n\tfw.fw_buf = (u8 *) adapter->firmware->data;\n\tfw.fw_len = adapter->firmware->size;\n\n\tif (adapter->if_ops.dnld_fw) {\n\t\tret = adapter->if_ops.dnld_fw(adapter, &fw);\n\t} else {\n\t\tret = mwifiex_dnld_fw(adapter, &fw);\n\t}\n\n\tif (ret == -1)\n\t\tgoto err_dnld_fw;\n\n\tmwifiex_dbg(adapter, MSG, \"WLAN FW is active\\n\");\n\n\tif (cal_data_cfg) {\n\t\tif ((request_firmware(&adapter->cal_data, cal_data_cfg,\n\t\t\t\t      adapter->dev)) < 0)\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Cal data request_firmware() failed\\n\");\n\t}\n\n\t \n\tif (adapter->if_ops.enable_int) {\n\t\tif (adapter->if_ops.enable_int(adapter))\n\t\t\tgoto err_dnld_fw;\n\t}\n\n\tadapter->init_wait_q_woken = false;\n\tret = mwifiex_init_fw(adapter);\n\tif (ret == -1) {\n\t\tgoto err_init_fw;\n\t} else if (!ret) {\n\t\tadapter->hw_status = MWIFIEX_HW_STATUS_READY;\n\t\tgoto done;\n\t}\n\t \n\tif (!adapter->mfg_mode) {\n\t\twait_event_interruptible(adapter->init_wait_q,\n\t\t\t\t\t adapter->init_wait_q_woken);\n\t\tif (adapter->hw_status != MWIFIEX_HW_STATUS_READY)\n\t\t\tgoto err_init_fw;\n\t}\n\n\tif (!adapter->wiphy) {\n\t\tif (mwifiex_register_cfg80211(adapter)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cannot register with cfg80211\\n\");\n\t\t\tgoto err_init_fw;\n\t\t}\n\t}\n\n\tif (mwifiex_init_channel_scan_gap(adapter)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"could not init channel stats table\\n\");\n\t\tgoto err_init_chan_scan;\n\t}\n\n\tif (driver_mode) {\n\t\tdriver_mode &= MWIFIEX_DRIVER_MODE_BITMASK;\n\t\tdriver_mode |= MWIFIEX_DRIVER_MODE_STA;\n\t}\n\n\trtnl_lock();\n\twiphy_lock(adapter->wiphy);\n\t \n\twdev = mwifiex_add_virtual_intf(adapter->wiphy, \"mlan%d\", NET_NAME_ENUM,\n\t\t\t\t\tNL80211_IFTYPE_STATION, NULL);\n\tif (IS_ERR(wdev)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"cannot create default STA interface\\n\");\n\t\twiphy_unlock(adapter->wiphy);\n\t\trtnl_unlock();\n\t\tgoto err_add_intf;\n\t}\n\n\tif (driver_mode & MWIFIEX_DRIVER_MODE_UAP) {\n\t\twdev = mwifiex_add_virtual_intf(adapter->wiphy, \"uap%d\", NET_NAME_ENUM,\n\t\t\t\t\t\tNL80211_IFTYPE_AP, NULL);\n\t\tif (IS_ERR(wdev)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cannot create AP interface\\n\");\n\t\t\twiphy_unlock(adapter->wiphy);\n\t\t\trtnl_unlock();\n\t\t\tgoto err_add_intf;\n\t\t}\n\t}\n\n\tif (driver_mode & MWIFIEX_DRIVER_MODE_P2P) {\n\t\twdev = mwifiex_add_virtual_intf(adapter->wiphy, \"p2p%d\", NET_NAME_ENUM,\n\t\t\t\t\t\tNL80211_IFTYPE_P2P_CLIENT, NULL);\n\t\tif (IS_ERR(wdev)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cannot create p2p client interface\\n\");\n\t\t\twiphy_unlock(adapter->wiphy);\n\t\t\trtnl_unlock();\n\t\t\tgoto err_add_intf;\n\t\t}\n\t}\n\twiphy_unlock(adapter->wiphy);\n\trtnl_unlock();\n\n\tmwifiex_drv_get_driver_version(adapter, fmt, sizeof(fmt) - 1);\n\tmwifiex_dbg(adapter, MSG, \"driver_version = %s\\n\", fmt);\n\tadapter->is_up = true;\n\tgoto done;\n\nerr_add_intf:\n\tvfree(adapter->chan_stats);\nerr_init_chan_scan:\n\twiphy_unregister(adapter->wiphy);\n\twiphy_free(adapter->wiphy);\nerr_init_fw:\n\tif (adapter->if_ops.disable_int)\n\t\tadapter->if_ops.disable_int(adapter);\nerr_dnld_fw:\n\tmwifiex_dbg(adapter, ERROR,\n\t\t    \"info: %s: unregister device\\n\", __func__);\n\tif (adapter->if_ops.unregister_dev)\n\t\tadapter->if_ops.unregister_dev(adapter);\n\n\tset_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags);\n\tmwifiex_terminate_workqueue(adapter);\n\n\tif (adapter->hw_status == MWIFIEX_HW_STATUS_READY) {\n\t\tpr_debug(\"info: %s: shutdown mwifiex\\n\", __func__);\n\t\tmwifiex_shutdown_drv(adapter);\n\t\tmwifiex_free_cmd_buffers(adapter);\n\t}\n\n\tinit_failed = true;\ndone:\n\tif (adapter->cal_data) {\n\t\trelease_firmware(adapter->cal_data);\n\t\tadapter->cal_data = NULL;\n\t}\n\tif (adapter->firmware) {\n\t\trelease_firmware(adapter->firmware);\n\t\tadapter->firmware = NULL;\n\t}\n\tif (init_failed) {\n\t\tif (adapter->irq_wakeup >= 0)\n\t\t\tdevice_init_wakeup(adapter->dev, false);\n\t\tmwifiex_free_adapter(adapter);\n\t}\n\t \n\tcomplete_all(fw_done);\n\n\treturn init_failed ? -EIO : 0;\n}\n\nstatic void mwifiex_fw_dpc(const struct firmware *firmware, void *context)\n{\n\t_mwifiex_fw_dpc(firmware, context);\n}\n\n \nstatic int mwifiex_init_hw_fw(struct mwifiex_adapter *adapter,\n\t\t\t      bool req_fw_nowait)\n{\n\tint ret;\n\n\t \n\tif (mfg_mode)\n\t\tstrscpy(adapter->fw_name, MFG_FIRMWARE,\n\t\t\tsizeof(adapter->fw_name));\n\n\tif (req_fw_nowait) {\n\t\tret = request_firmware_nowait(THIS_MODULE, 1, adapter->fw_name,\n\t\t\t\t\t      adapter->dev, GFP_KERNEL, adapter,\n\t\t\t\t\t      mwifiex_fw_dpc);\n\t} else {\n\t\tret = request_firmware(&adapter->firmware,\n\t\t\t\t       adapter->fw_name,\n\t\t\t\t       adapter->dev);\n\t}\n\n\tif (ret < 0)\n\t\tmwifiex_dbg(adapter, ERROR, \"request_firmware%s error %d\\n\",\n\t\t\t    req_fw_nowait ? \"_nowait\" : \"\", ret);\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_open(struct net_device *dev)\n{\n\tnetif_carrier_off(dev);\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_close(struct net_device *dev)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\tif (priv->scan_request) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = true,\n\t\t};\n\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"aborting scan on ndo_stop\\n\");\n\t\tcfg80211_scan_done(priv->scan_request, &info);\n\t\tpriv->scan_request = NULL;\n\t\tpriv->scan_aborting = true;\n\t}\n\n\tif (priv->sched_scanning) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"aborting bgscan on ndo_stop\\n\");\n\t\tmwifiex_stop_bg_scan(priv);\n\t\tcfg80211_sched_scan_stopped(priv->wdev.wiphy, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nmwifiex_bypass_tx_queue(struct mwifiex_private *priv,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct ethhdr *eth_hdr = (struct ethhdr *)skb->data;\n\n\tif (ntohs(eth_hdr->h_proto) == ETH_P_PAE ||\n\t    mwifiex_is_skb_mgmt_frame(skb) ||\n\t    (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA &&\n\t     ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t     (ntohs(eth_hdr->h_proto) == ETH_P_TDLS))) {\n\t\tmwifiex_dbg(priv->adapter, DATA,\n\t\t\t    \"bypass txqueue; eth type %#x, mgmt %d\\n\",\n\t\t\t     ntohs(eth_hdr->h_proto),\n\t\t\t     mwifiex_is_skb_mgmt_frame(skb));\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n \nint mwifiex_queue_tx_pkt(struct mwifiex_private *priv, struct sk_buff *skb)\n{\n\tstruct netdev_queue *txq;\n\tint index = mwifiex_1d_to_wmm_queue[skb->priority];\n\n\tif (atomic_inc_return(&priv->wmm_tx_pending[index]) >= MAX_TX_PENDING) {\n\t\ttxq = netdev_get_tx_queue(priv->netdev, index);\n\t\tif (!netif_tx_queue_stopped(txq)) {\n\t\t\tnetif_tx_stop_queue(txq);\n\t\t\tmwifiex_dbg(priv->adapter, DATA,\n\t\t\t\t    \"stop queue: %d\\n\", index);\n\t\t}\n\t}\n\n\tif (mwifiex_bypass_tx_queue(priv, skb)) {\n\t\tatomic_inc(&priv->adapter->tx_pending);\n\t\tatomic_inc(&priv->adapter->bypass_tx_pending);\n\t\tmwifiex_wmm_add_buf_bypass_txqueue(priv, skb);\n\t } else {\n\t\tatomic_inc(&priv->adapter->tx_pending);\n\t\tmwifiex_wmm_add_buf_txqueue(priv, skb);\n\t }\n\n\tmwifiex_queue_main_work(priv->adapter);\n\n\treturn 0;\n}\n\nstruct sk_buff *\nmwifiex_clone_skb_for_tx_status(struct mwifiex_private *priv,\n\t\t\t\tstruct sk_buff *skb, u8 flag, u64 *cookie)\n{\n\tstruct sk_buff *orig_skb = skb;\n\tstruct mwifiex_txinfo *tx_info, *orig_tx_info;\n\n\tskb = skb_clone(skb, GFP_ATOMIC);\n\tif (skb) {\n\t\tint id;\n\n\t\tspin_lock_bh(&priv->ack_status_lock);\n\t\tid = idr_alloc(&priv->ack_status_frames, orig_skb,\n\t\t\t       1, 0x10, GFP_ATOMIC);\n\t\tspin_unlock_bh(&priv->ack_status_lock);\n\n\t\tif (id >= 0) {\n\t\t\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\t\t\ttx_info->ack_frame_id = id;\n\t\t\ttx_info->flags |= flag;\n\t\t\torig_tx_info = MWIFIEX_SKB_TXCB(orig_skb);\n\t\t\torig_tx_info->ack_frame_id = id;\n\t\t\torig_tx_info->flags |= flag;\n\n\t\t\tif (flag == MWIFIEX_BUF_FLAG_ACTION_TX_STATUS && cookie)\n\t\t\t\torig_tx_info->cookie = *cookie;\n\n\t\t} else if (skb_shared(skb)) {\n\t\t\tkfree_skb(orig_skb);\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t\tskb = orig_skb;\n\t\t}\n\t} else {\n\t\t \n\t\tskb = orig_skb;\n\t}\n\n\treturn skb;\n}\n\n \nstatic netdev_tx_t\nmwifiex_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tstruct sk_buff *new_skb;\n\tstruct mwifiex_txinfo *tx_info;\n\tbool multicast;\n\n\tmwifiex_dbg(priv->adapter, DATA,\n\t\t    \"data: %lu BSS(%d-%d): Data <= kernel\\n\",\n\t\t    jiffies, priv->bss_type, priv->bss_num);\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &priv->adapter->work_flags)) {\n\t\tkfree_skb(skb);\n\t\tpriv->stats.tx_dropped++;\n\t\treturn 0;\n\t}\n\tif (!skb->len || (skb->len > ETH_FRAME_LEN)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Tx: bad skb len %d\\n\", skb->len);\n\t\tkfree_skb(skb);\n\t\tpriv->stats.tx_dropped++;\n\t\treturn 0;\n\t}\n\tif (skb_headroom(skb) < MWIFIEX_MIN_DATA_HEADER_LEN) {\n\t\tmwifiex_dbg(priv->adapter, DATA,\n\t\t\t    \"data: Tx: insufficient skb headroom %d\\n\",\n\t\t\t    skb_headroom(skb));\n\t\t \n\t\tnew_skb =\n\t\t\tskb_realloc_headroom(skb, MWIFIEX_MIN_DATA_HEADER_LEN);\n\t\tif (unlikely(!new_skb)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"Tx: cannot alloca new_skb\\n\");\n\t\t\tkfree_skb(skb);\n\t\t\tpriv->stats.tx_dropped++;\n\t\t\treturn 0;\n\t\t}\n\t\tkfree_skb(skb);\n\t\tskb = new_skb;\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: new skb headroomd %d\\n\",\n\t\t\t    skb_headroom(skb));\n\t}\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tmemset(tx_info, 0, sizeof(*tx_info));\n\ttx_info->bss_num = priv->bss_num;\n\ttx_info->bss_type = priv->bss_type;\n\ttx_info->pkt_len = skb->len;\n\n\tmulticast = is_multicast_ether_addr(skb->data);\n\n\tif (unlikely(!multicast && skb->sk &&\n\t\t     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS &&\n\t\t     priv->adapter->fw_api_ver == MWIFIEX_FW_V15))\n\t\tskb = mwifiex_clone_skb_for_tx_status(priv,\n\t\t\t\t\t\t      skb,\n\t\t\t\t\tMWIFIEX_BUF_FLAG_EAPOL_TX_STATUS, NULL);\n\n\t \n\t__net_timestamp(skb);\n\n\tif (ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->bss_type == MWIFIEX_BSS_TYPE_STA &&\n\t    !ether_addr_equal_unaligned(priv->cfg_bssid, skb->data)) {\n\t\tif (priv->adapter->auto_tdls && priv->check_tdls_tx)\n\t\t\tmwifiex_tdls_check_tx(priv, skb);\n\t}\n\n\tmwifiex_queue_tx_pkt(priv, skb);\n\n\treturn 0;\n}\n\nint mwifiex_set_mac_address(struct mwifiex_private *priv,\n\t\t\t    struct net_device *dev, bool external,\n\t\t\t    u8 *new_mac)\n{\n\tint ret;\n\tu64 mac_addr, old_mac_addr;\n\n\told_mac_addr = ether_addr_to_u64(priv->curr_addr);\n\n\tif (external) {\n\t\tmac_addr = ether_addr_to_u64(new_mac);\n\t} else {\n\t\t \n\t\tif (priv->bss_type == MWIFIEX_BSS_TYPE_ANY)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tmac_addr = old_mac_addr;\n\n\t\tif (priv->bss_type == MWIFIEX_BSS_TYPE_P2P) {\n\t\t\tmac_addr |= BIT_ULL(MWIFIEX_MAC_LOCAL_ADMIN_BIT);\n\t\t\tmac_addr += priv->bss_num;\n\t\t} else if (priv->adapter->priv[0] != priv) {\n\t\t\t \n\t\t\tmac_addr ^= BIT_ULL(priv->bss_type + 8);\n\t\t\tmac_addr += priv->bss_num;\n\t\t}\n\t}\n\n\tu64_to_ether_addr(mac_addr, priv->curr_addr);\n\n\t \n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_MAC_ADDRESS,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, NULL, true);\n\n\tif (ret) {\n\t\tu64_to_ether_addr(old_mac_addr, priv->curr_addr);\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"set mac address failed: ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\teth_hw_addr_set(dev, priv->curr_addr);\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_ndo_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tstruct sockaddr *hw_addr = addr;\n\n\treturn mwifiex_set_mac_address(priv, dev, true, hw_addr->sa_data);\n}\n\n \nstatic void mwifiex_set_multicast_list(struct net_device *dev)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tstruct mwifiex_multicast_list mcast_list;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tmcast_list.mode = MWIFIEX_PROMISC_MODE;\n\t} else if (dev->flags & IFF_ALLMULTI ||\n\t\t   netdev_mc_count(dev) > MWIFIEX_MAX_MULTICAST_LIST_SIZE) {\n\t\tmcast_list.mode = MWIFIEX_ALL_MULTI_MODE;\n\t} else {\n\t\tmcast_list.mode = MWIFIEX_MULTICAST_MODE;\n\t\tmcast_list.num_multicast_addr =\n\t\t\tmwifiex_copy_mcast_addr(&mcast_list, dev);\n\t}\n\tmwifiex_request_set_multicast_list(priv, &mcast_list);\n}\n\n \nstatic void\nmwifiex_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\tpriv->num_tx_timeout++;\n\tpriv->tx_timeout_cnt++;\n\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t    \"%lu : Tx timeout(#%d), bss_type-num = %d-%d\\n\",\n\t\t    jiffies, priv->tx_timeout_cnt, priv->bss_type,\n\t\t    priv->bss_num);\n\tmwifiex_set_trans_start(dev);\n\n\tif (priv->tx_timeout_cnt > TX_TIMEOUT_THRESHOLD &&\n\t    priv->adapter->if_ops.card_reset) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"tx_timeout_cnt exceeds threshold.\\t\"\n\t\t\t    \"Triggering card reset!\\n\");\n\t\tpriv->adapter->if_ops.card_reset(priv->adapter);\n\t}\n}\n\nvoid mwifiex_multi_chan_resync(struct mwifiex_adapter *adapter)\n{\n\tstruct usb_card_rec *card = adapter->card;\n\tstruct mwifiex_private *priv;\n\tu16 tx_buf_size;\n\tint i, ret;\n\n\tcard->mc_resync_flag = true;\n\tfor (i = 0; i < MWIFIEX_TX_DATA_PORT; i++) {\n\t\tif (atomic_read(&card->port[i].tx_data_urb_pending)) {\n\t\t\tmwifiex_dbg(adapter, WARN, \"pending data urb in sys\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcard->mc_resync_flag = false;\n\ttx_buf_size = 0xffff;\n\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_RECONFIGURE_TX_BUFF,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &tx_buf_size, false);\n\tif (ret)\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"send reconfig tx buf size cmd err\\n\");\n}\nEXPORT_SYMBOL_GPL(mwifiex_multi_chan_resync);\n\nvoid mwifiex_upload_device_dump(struct mwifiex_adapter *adapter)\n{\n\t \n\tmwifiex_dbg(adapter, MSG,\n\t\t    \"== mwifiex dump information to /sys/class/devcoredump start\\n\");\n\tdev_coredumpv(adapter->dev, adapter->devdump_data, adapter->devdump_len,\n\t\t      GFP_KERNEL);\n\tmwifiex_dbg(adapter, MSG,\n\t\t    \"== mwifiex dump information to /sys/class/devcoredump end\\n\");\n\n\t \n\tadapter->devdump_data = NULL;\n\tadapter->devdump_len = 0;\n}\nEXPORT_SYMBOL_GPL(mwifiex_upload_device_dump);\n\nvoid mwifiex_drv_info_dump(struct mwifiex_adapter *adapter)\n{\n\tchar *p;\n\tchar drv_version[64];\n\tstruct usb_card_rec *cardp;\n\tstruct sdio_mmc_card *sdio_card;\n\tstruct mwifiex_private *priv;\n\tint i, idx;\n\tstruct netdev_queue *txq;\n\tstruct mwifiex_debug_info *debug_info;\n\n\tmwifiex_dbg(adapter, MSG, \"===mwifiex driverinfo dump start===\\n\");\n\n\tp = adapter->devdump_data;\n\tstrcpy(p, \"========Start dump driverinfo========\\n\");\n\tp += strlen(\"========Start dump driverinfo========\\n\");\n\tp += sprintf(p, \"driver_name = \" \"\\\"mwifiex\\\"\\n\");\n\n\tmwifiex_drv_get_driver_version(adapter, drv_version,\n\t\t\t\t       sizeof(drv_version) - 1);\n\tp += sprintf(p, \"driver_version = %s\\n\", drv_version);\n\n\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\tcardp = (struct usb_card_rec *)adapter->card;\n\t\tp += sprintf(p, \"tx_cmd_urb_pending = %d\\n\",\n\t\t\t     atomic_read(&cardp->tx_cmd_urb_pending));\n\t\tp += sprintf(p, \"tx_data_urb_pending_port_0 = %d\\n\",\n\t\t\t     atomic_read(&cardp->port[0].tx_data_urb_pending));\n\t\tp += sprintf(p, \"tx_data_urb_pending_port_1 = %d\\n\",\n\t\t\t     atomic_read(&cardp->port[1].tx_data_urb_pending));\n\t\tp += sprintf(p, \"rx_cmd_urb_pending = %d\\n\",\n\t\t\t     atomic_read(&cardp->rx_cmd_urb_pending));\n\t\tp += sprintf(p, \"rx_data_urb_pending = %d\\n\",\n\t\t\t     atomic_read(&cardp->rx_data_urb_pending));\n\t}\n\n\tp += sprintf(p, \"tx_pending = %d\\n\",\n\t\t     atomic_read(&adapter->tx_pending));\n\tp += sprintf(p, \"rx_pending = %d\\n\",\n\t\t     atomic_read(&adapter->rx_pending));\n\n\tif (adapter->iface_type == MWIFIEX_SDIO) {\n\t\tsdio_card = (struct sdio_mmc_card *)adapter->card;\n\t\tp += sprintf(p, \"\\nmp_rd_bitmap=0x%x curr_rd_port=0x%x\\n\",\n\t\t\t     sdio_card->mp_rd_bitmap, sdio_card->curr_rd_port);\n\t\tp += sprintf(p, \"mp_wr_bitmap=0x%x curr_wr_port=0x%x\\n\",\n\t\t\t     sdio_card->mp_wr_bitmap, sdio_card->curr_wr_port);\n\t}\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (!adapter->priv[i] || !adapter->priv[i]->netdev)\n\t\t\tcontinue;\n\t\tpriv = adapter->priv[i];\n\t\tp += sprintf(p, \"\\n[interface  : \\\"%s\\\"]\\n\",\n\t\t\t     priv->netdev->name);\n\t\tp += sprintf(p, \"wmm_tx_pending[0] = %d\\n\",\n\t\t\t     atomic_read(&priv->wmm_tx_pending[0]));\n\t\tp += sprintf(p, \"wmm_tx_pending[1] = %d\\n\",\n\t\t\t     atomic_read(&priv->wmm_tx_pending[1]));\n\t\tp += sprintf(p, \"wmm_tx_pending[2] = %d\\n\",\n\t\t\t     atomic_read(&priv->wmm_tx_pending[2]));\n\t\tp += sprintf(p, \"wmm_tx_pending[3] = %d\\n\",\n\t\t\t     atomic_read(&priv->wmm_tx_pending[3]));\n\t\tp += sprintf(p, \"media_state=\\\"%s\\\"\\n\", !priv->media_connected ?\n\t\t\t     \"Disconnected\" : \"Connected\");\n\t\tp += sprintf(p, \"carrier %s\\n\", (netif_carrier_ok(priv->netdev)\n\t\t\t     ? \"on\" : \"off\"));\n\t\tfor (idx = 0; idx < priv->netdev->num_tx_queues; idx++) {\n\t\t\ttxq = netdev_get_tx_queue(priv->netdev, idx);\n\t\t\tp += sprintf(p, \"tx queue %d:%s  \", idx,\n\t\t\t\t     netif_tx_queue_stopped(txq) ?\n\t\t\t\t     \"stopped\" : \"started\");\n\t\t}\n\t\tp += sprintf(p, \"\\n%s: num_tx_timeout = %d\\n\",\n\t\t\t     priv->netdev->name, priv->num_tx_timeout);\n\t}\n\n\tif (adapter->iface_type == MWIFIEX_SDIO ||\n\t    adapter->iface_type == MWIFIEX_PCIE) {\n\t\tp += sprintf(p, \"\\n=== %s register dump===\\n\",\n\t\t\t     adapter->iface_type == MWIFIEX_SDIO ?\n\t\t\t\t\t\t\t\"SDIO\" : \"PCIE\");\n\t\tif (adapter->if_ops.reg_dump)\n\t\t\tp += adapter->if_ops.reg_dump(adapter, p);\n\t}\n\tp += sprintf(p, \"\\n=== more debug information\\n\");\n\tdebug_info = kzalloc(sizeof(*debug_info), GFP_KERNEL);\n\tif (debug_info) {\n\t\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\t\tif (!adapter->priv[i] || !adapter->priv[i]->netdev)\n\t\t\t\tcontinue;\n\t\t\tpriv = adapter->priv[i];\n\t\t\tmwifiex_get_debug_info(priv, debug_info);\n\t\t\tp += mwifiex_debug_info_to_buffer(priv, p, debug_info);\n\t\t\tbreak;\n\t\t}\n\t\tkfree(debug_info);\n\t}\n\n\tstrcpy(p, \"\\n========End dump========\\n\");\n\tp += strlen(\"\\n========End dump========\\n\");\n\tmwifiex_dbg(adapter, MSG, \"===mwifiex driverinfo dump end===\\n\");\n\tadapter->devdump_len = p - (char *)adapter->devdump_data;\n}\nEXPORT_SYMBOL_GPL(mwifiex_drv_info_dump);\n\nvoid mwifiex_prepare_fw_dump_info(struct mwifiex_adapter *adapter)\n{\n\tu8 idx;\n\tchar *fw_dump_ptr;\n\tu32 dump_len = 0;\n\n\tfor (idx = 0; idx < adapter->num_mem_types; idx++) {\n\t\tstruct memory_type_mapping *entry =\n\t\t\t\t&adapter->mem_type_mapping_tbl[idx];\n\n\t\tif (entry->mem_ptr) {\n\t\t\tdump_len += (strlen(\"========Start dump \") +\n\t\t\t\t\tstrlen(entry->mem_name) +\n\t\t\t\t\tstrlen(\"========\\n\") +\n\t\t\t\t\t(entry->mem_size + 1) +\n\t\t\t\t\tstrlen(\"\\n========End dump========\\n\"));\n\t\t}\n\t}\n\n\tif (dump_len + 1 + adapter->devdump_len > MWIFIEX_FW_DUMP_SIZE) {\n\t\t \n\t\tfw_dump_ptr = vzalloc(dump_len + 1 + adapter->devdump_len);\n\t\tmwifiex_dbg(adapter, MSG, \"Realloc device dump data.\\n\");\n\t\tif (!fw_dump_ptr) {\n\t\t\tvfree(adapter->devdump_data);\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"vzalloc devdump data failure!\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tmemmove(fw_dump_ptr, adapter->devdump_data,\n\t\t\tadapter->devdump_len);\n\t\tvfree(adapter->devdump_data);\n\t\tadapter->devdump_data = fw_dump_ptr;\n\t}\n\n\tfw_dump_ptr = (char *)adapter->devdump_data + adapter->devdump_len;\n\n\tfor (idx = 0; idx < adapter->num_mem_types; idx++) {\n\t\tstruct memory_type_mapping *entry =\n\t\t\t\t\t&adapter->mem_type_mapping_tbl[idx];\n\n\t\tif (entry->mem_ptr) {\n\t\t\tstrcpy(fw_dump_ptr, \"========Start dump \");\n\t\t\tfw_dump_ptr += strlen(\"========Start dump \");\n\n\t\t\tstrcpy(fw_dump_ptr, entry->mem_name);\n\t\t\tfw_dump_ptr += strlen(entry->mem_name);\n\n\t\t\tstrcpy(fw_dump_ptr, \"========\\n\");\n\t\t\tfw_dump_ptr += strlen(\"========\\n\");\n\n\t\t\tmemcpy(fw_dump_ptr, entry->mem_ptr, entry->mem_size);\n\t\t\tfw_dump_ptr += entry->mem_size;\n\n\t\t\tstrcpy(fw_dump_ptr, \"\\n========End dump========\\n\");\n\t\t\tfw_dump_ptr += strlen(\"\\n========End dump========\\n\");\n\t\t}\n\t}\n\n\tadapter->devdump_len = fw_dump_ptr - (char *)adapter->devdump_data;\n\n\tfor (idx = 0; idx < adapter->num_mem_types; idx++) {\n\t\tstruct memory_type_mapping *entry =\n\t\t\t&adapter->mem_type_mapping_tbl[idx];\n\n\t\tvfree(entry->mem_ptr);\n\t\tentry->mem_ptr = NULL;\n\t\tentry->mem_size = 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(mwifiex_prepare_fw_dump_info);\n\n \nstatic struct net_device_stats *mwifiex_get_stats(struct net_device *dev)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\treturn &priv->stats;\n}\n\nstatic u16\nmwifiex_netdev_select_wmm_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t\tstruct net_device *sb_dev)\n{\n\tskb->priority = cfg80211_classify8021d(skb, NULL);\n\treturn mwifiex_1d_to_wmm_queue[skb->priority];\n}\n\n \nstatic const struct net_device_ops mwifiex_netdev_ops = {\n\t.ndo_open = mwifiex_open,\n\t.ndo_stop = mwifiex_close,\n\t.ndo_start_xmit = mwifiex_hard_start_xmit,\n\t.ndo_set_mac_address = mwifiex_ndo_set_mac_address,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_tx_timeout = mwifiex_tx_timeout,\n\t.ndo_get_stats = mwifiex_get_stats,\n\t.ndo_set_rx_mode = mwifiex_set_multicast_list,\n\t.ndo_select_queue = mwifiex_netdev_select_wmm_queue,\n};\n\n \nvoid mwifiex_init_priv_params(struct mwifiex_private *priv,\n\t\t\t      struct net_device *dev)\n{\n\tdev->netdev_ops = &mwifiex_netdev_ops;\n\tdev->needs_free_netdev = true;\n\t \n\tpriv->current_key_index = 0;\n\tpriv->media_connected = false;\n\tmemset(priv->mgmt_ie, 0,\n\t       sizeof(struct mwifiex_ie) * MAX_MGMT_IE_INDEX);\n\tpriv->beacon_idx = MWIFIEX_AUTO_IDX_MASK;\n\tpriv->proberesp_idx = MWIFIEX_AUTO_IDX_MASK;\n\tpriv->assocresp_idx = MWIFIEX_AUTO_IDX_MASK;\n\tpriv->gen_idx = MWIFIEX_AUTO_IDX_MASK;\n\tpriv->num_tx_timeout = 0;\n\tif (is_valid_ether_addr(dev->dev_addr))\n\t\tether_addr_copy(priv->curr_addr, dev->dev_addr);\n\telse\n\t\tether_addr_copy(priv->curr_addr, priv->adapter->perm_addr);\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA ||\n\t    GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\n\t\tpriv->hist_data = kmalloc(sizeof(*priv->hist_data), GFP_KERNEL);\n\t\tif (priv->hist_data)\n\t\t\tmwifiex_hist_data_reset(priv);\n\t}\n}\n\n \nint is_command_pending(struct mwifiex_adapter *adapter)\n{\n\tint is_cmd_pend_q_empty;\n\n\tspin_lock_bh(&adapter->cmd_pending_q_lock);\n\tis_cmd_pend_q_empty = list_empty(&adapter->cmd_pending_q);\n\tspin_unlock_bh(&adapter->cmd_pending_q_lock);\n\n\treturn !is_cmd_pend_q_empty;\n}\n\n \nstatic void mwifiex_rx_work_queue(struct work_struct *work)\n{\n\tstruct mwifiex_adapter *adapter =\n\t\tcontainer_of(work, struct mwifiex_adapter, rx_work);\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags))\n\t\treturn;\n\tmwifiex_process_rx(adapter);\n}\n\n \nstatic void mwifiex_main_work_queue(struct work_struct *work)\n{\n\tstruct mwifiex_adapter *adapter =\n\t\tcontainer_of(work, struct mwifiex_adapter, main_work);\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags))\n\t\treturn;\n\tmwifiex_main_process(adapter);\n}\n\n \nstatic void mwifiex_uninit_sw(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\t \n\tif (adapter->if_ops.disable_int)\n\t\tadapter->if_ops.disable_int(adapter);\n\n\tset_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags);\n\tmwifiex_terminate_workqueue(adapter);\n\tadapter->int_status = 0;\n\n\t \n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tif (priv && priv->netdev) {\n\t\t\tmwifiex_stop_net_dev_queue(priv->netdev, adapter);\n\t\t\tif (netif_carrier_ok(priv->netdev))\n\t\t\t\tnetif_carrier_off(priv->netdev);\n\t\t\tnetif_device_detach(priv->netdev);\n\t\t}\n\t}\n\n\tmwifiex_dbg(adapter, CMD, \"cmd: calling mwifiex_shutdown_drv...\\n\");\n\tmwifiex_shutdown_drv(adapter);\n\tmwifiex_dbg(adapter, CMD, \"cmd: mwifiex_shutdown_drv done\\n\");\n\n\tif (atomic_read(&adapter->rx_pending) ||\n\t    atomic_read(&adapter->tx_pending) ||\n\t    atomic_read(&adapter->cmd_pending)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"rx_pending=%d, tx_pending=%d,\\t\"\n\t\t\t    \"cmd_pending=%d\\n\",\n\t\t\t    atomic_read(&adapter->rx_pending),\n\t\t\t    atomic_read(&adapter->tx_pending),\n\t\t\t    atomic_read(&adapter->cmd_pending));\n\t}\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tif (!priv)\n\t\t\tcontinue;\n\t\trtnl_lock();\n\t\tif (priv->netdev &&\n\t\t    priv->wdev.iftype != NL80211_IFTYPE_UNSPECIFIED) {\n\t\t\t \n\t\t\tdev_close(priv->wdev.netdev);\n\t\t\twiphy_lock(adapter->wiphy);\n\t\t\tmwifiex_del_virtual_intf(adapter->wiphy, &priv->wdev);\n\t\t\twiphy_unlock(adapter->wiphy);\n\t\t}\n\t\trtnl_unlock();\n\t}\n\n\twiphy_unregister(adapter->wiphy);\n\twiphy_free(adapter->wiphy);\n\tadapter->wiphy = NULL;\n\n\tvfree(adapter->chan_stats);\n\tmwifiex_free_cmd_buffers(adapter);\n}\n\n \nint mwifiex_shutdown_sw(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\n\tif (!adapter)\n\t\treturn 0;\n\n\twait_for_completion(adapter->fw_done);\n\t \n\treinit_completion(adapter->fw_done);\n\n\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\tmwifiex_deauthenticate(priv, NULL);\n\n\tmwifiex_init_shutdown_fw(priv, MWIFIEX_FUNC_SHUTDOWN);\n\n\tmwifiex_uninit_sw(adapter);\n\tadapter->is_up = false;\n\n\tif (adapter->if_ops.down_dev)\n\t\tadapter->if_ops.down_dev(adapter);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mwifiex_shutdown_sw);\n\n \nint\nmwifiex_reinit_sw(struct mwifiex_adapter *adapter)\n{\n\tint ret;\n\n\tmwifiex_init_lock_list(adapter);\n\tif (adapter->if_ops.up_dev)\n\t\tadapter->if_ops.up_dev(adapter);\n\n\tadapter->hw_status = MWIFIEX_HW_STATUS_INITIALIZING;\n\tclear_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags);\n\tinit_waitqueue_head(&adapter->init_wait_q);\n\tclear_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);\n\tadapter->hs_activated = false;\n\tclear_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags);\n\tinit_waitqueue_head(&adapter->hs_activate_wait_q);\n\tinit_waitqueue_head(&adapter->cmd_wait_q.wait);\n\tadapter->cmd_wait_q.status = 0;\n\tadapter->scan_wait_q_woken = false;\n\n\tif ((num_possible_cpus() > 1) || adapter->iface_type == MWIFIEX_USB)\n\t\tadapter->rx_work_enabled = true;\n\n\tadapter->workqueue =\n\t\talloc_workqueue(\"MWIFIEX_WORK_QUEUE\",\n\t\t\t\tWQ_HIGHPRI | WQ_MEM_RECLAIM | WQ_UNBOUND, 0);\n\tif (!adapter->workqueue)\n\t\tgoto err_kmalloc;\n\n\tINIT_WORK(&adapter->main_work, mwifiex_main_work_queue);\n\n\tif (adapter->rx_work_enabled) {\n\t\tadapter->rx_workqueue = alloc_workqueue(\"MWIFIEX_RX_WORK_QUEUE\",\n\t\t\t\t\t\t\tWQ_HIGHPRI |\n\t\t\t\t\t\t\tWQ_MEM_RECLAIM |\n\t\t\t\t\t\t\tWQ_UNBOUND, 0);\n\t\tif (!adapter->rx_workqueue)\n\t\t\tgoto err_kmalloc;\n\t\tINIT_WORK(&adapter->rx_work, mwifiex_rx_work_queue);\n\t}\n\n\t \n\tmwifiex_dbg(adapter, INFO, \"%s, mwifiex_init_hw_fw()...\\n\", __func__);\n\n\tif (mwifiex_init_hw_fw(adapter, false)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: firmware init failed\\n\", __func__);\n\t\tgoto err_init_fw;\n\t}\n\n\t \n\tret = _mwifiex_fw_dpc(adapter->firmware, adapter);\n\tif (ret) {\n\t\tpr_err(\"Failed to bring up adapter: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmwifiex_dbg(adapter, INFO, \"%s, successful\\n\", __func__);\n\n\treturn 0;\n\nerr_init_fw:\n\tmwifiex_dbg(adapter, ERROR, \"info: %s: unregister device\\n\", __func__);\n\tif (adapter->if_ops.unregister_dev)\n\t\tadapter->if_ops.unregister_dev(adapter);\n\nerr_kmalloc:\n\tset_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags);\n\tmwifiex_terminate_workqueue(adapter);\n\tif (adapter->hw_status == MWIFIEX_HW_STATUS_READY) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"info: %s: shutdown mwifiex\\n\", __func__);\n\t\tmwifiex_shutdown_drv(adapter);\n\t\tmwifiex_free_cmd_buffers(adapter);\n\t}\n\n\tcomplete_all(adapter->fw_done);\n\tmwifiex_dbg(adapter, INFO, \"%s, error\\n\", __func__);\n\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(mwifiex_reinit_sw);\n\nstatic irqreturn_t mwifiex_irq_wakeup_handler(int irq, void *priv)\n{\n\tstruct mwifiex_adapter *adapter = priv;\n\n\tdev_dbg(adapter->dev, \"%s: wake by wifi\", __func__);\n\tadapter->wake_by_wifi = true;\n\tdisable_irq_nosync(irq);\n\n\t \n\tpm_wakeup_event(adapter->dev, 0);\n\tpm_system_wakeup();\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mwifiex_probe_of(struct mwifiex_adapter *adapter)\n{\n\tint ret;\n\tstruct device *dev = adapter->dev;\n\n\tif (!dev->of_node)\n\t\tgoto err_exit;\n\n\tadapter->dt_node = dev->of_node;\n\tadapter->irq_wakeup = irq_of_parse_and_map(adapter->dt_node, 0);\n\tif (!adapter->irq_wakeup) {\n\t\tdev_dbg(dev, \"fail to parse irq_wakeup from device tree\\n\");\n\t\tgoto err_exit;\n\t}\n\n\tret = devm_request_irq(dev, adapter->irq_wakeup,\n\t\t\t       mwifiex_irq_wakeup_handler, IRQF_TRIGGER_LOW,\n\t\t\t       \"wifi_wake\", adapter);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request irq_wakeup %d (%d)\\n\",\n\t\t\tadapter->irq_wakeup, ret);\n\t\tgoto err_exit;\n\t}\n\n\tdisable_irq(adapter->irq_wakeup);\n\tif (device_init_wakeup(dev, true)) {\n\t\tdev_err(dev, \"fail to init wakeup for mwifiex\\n\");\n\t\tgoto err_exit;\n\t}\n\treturn;\n\nerr_exit:\n\tadapter->irq_wakeup = -1;\n}\n\n \nint\nmwifiex_add_card(void *card, struct completion *fw_done,\n\t\t struct mwifiex_if_ops *if_ops, u8 iface_type,\n\t\t struct device *dev)\n{\n\tstruct mwifiex_adapter *adapter;\n\n\tif (mwifiex_register(card, dev, if_ops, (void **)&adapter)) {\n\t\tpr_err(\"%s: software init failed\\n\", __func__);\n\t\tgoto err_init_sw;\n\t}\n\n\tmwifiex_probe_of(adapter);\n\n\tadapter->iface_type = iface_type;\n\tadapter->fw_done = fw_done;\n\n\tadapter->hw_status = MWIFIEX_HW_STATUS_INITIALIZING;\n\tclear_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags);\n\tinit_waitqueue_head(&adapter->init_wait_q);\n\tclear_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);\n\tadapter->hs_activated = false;\n\tinit_waitqueue_head(&adapter->hs_activate_wait_q);\n\tinit_waitqueue_head(&adapter->cmd_wait_q.wait);\n\tadapter->cmd_wait_q.status = 0;\n\tadapter->scan_wait_q_woken = false;\n\n\tif ((num_possible_cpus() > 1) || adapter->iface_type == MWIFIEX_USB)\n\t\tadapter->rx_work_enabled = true;\n\n\tadapter->workqueue =\n\t\talloc_workqueue(\"MWIFIEX_WORK_QUEUE\",\n\t\t\t\tWQ_HIGHPRI | WQ_MEM_RECLAIM | WQ_UNBOUND, 0);\n\tif (!adapter->workqueue)\n\t\tgoto err_kmalloc;\n\n\tINIT_WORK(&adapter->main_work, mwifiex_main_work_queue);\n\n\tif (adapter->rx_work_enabled) {\n\t\tadapter->rx_workqueue = alloc_workqueue(\"MWIFIEX_RX_WORK_QUEUE\",\n\t\t\t\t\t\t\tWQ_HIGHPRI |\n\t\t\t\t\t\t\tWQ_MEM_RECLAIM |\n\t\t\t\t\t\t\tWQ_UNBOUND, 0);\n\t\tif (!adapter->rx_workqueue)\n\t\t\tgoto err_kmalloc;\n\n\t\tINIT_WORK(&adapter->rx_work, mwifiex_rx_work_queue);\n\t}\n\n\t \n\tif (adapter->if_ops.register_dev(adapter)) {\n\t\tpr_err(\"%s: failed to register mwifiex device\\n\", __func__);\n\t\tgoto err_registerdev;\n\t}\n\n\tif (mwifiex_init_hw_fw(adapter, true)) {\n\t\tpr_err(\"%s: firmware init failed\\n\", __func__);\n\t\tgoto err_init_fw;\n\t}\n\n\treturn 0;\n\nerr_init_fw:\n\tpr_debug(\"info: %s: unregister device\\n\", __func__);\n\tif (adapter->if_ops.unregister_dev)\n\t\tadapter->if_ops.unregister_dev(adapter);\nerr_registerdev:\n\tset_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags);\n\tmwifiex_terminate_workqueue(adapter);\n\tif (adapter->hw_status == MWIFIEX_HW_STATUS_READY) {\n\t\tpr_debug(\"info: %s: shutdown mwifiex\\n\", __func__);\n\t\tmwifiex_shutdown_drv(adapter);\n\t\tmwifiex_free_cmd_buffers(adapter);\n\t}\nerr_kmalloc:\n\tif (adapter->irq_wakeup >= 0)\n\t\tdevice_init_wakeup(adapter->dev, false);\n\tmwifiex_free_adapter(adapter);\n\nerr_init_sw:\n\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(mwifiex_add_card);\n\n \nint mwifiex_remove_card(struct mwifiex_adapter *adapter)\n{\n\tif (!adapter)\n\t\treturn 0;\n\n\tif (adapter->is_up)\n\t\tmwifiex_uninit_sw(adapter);\n\n\tif (adapter->irq_wakeup >= 0)\n\t\tdevice_init_wakeup(adapter->dev, false);\n\n\t \n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: unregister device\\n\");\n\tif (adapter->if_ops.unregister_dev)\n\t\tadapter->if_ops.unregister_dev(adapter);\n\t \n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: free adapter\\n\");\n\tmwifiex_free_adapter(adapter);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mwifiex_remove_card);\n\nvoid _mwifiex_dbg(const struct mwifiex_adapter *adapter, int mask,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!(adapter->debug_mask & mask))\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (adapter->dev)\n\t\tdev_info(adapter->dev, \"%pV\", &vaf);\n\telse\n\t\tpr_info(\"%pV\", &vaf);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(_mwifiex_dbg);\n\n \nstatic int\nmwifiex_init_module(void)\n{\n#ifdef CONFIG_DEBUG_FS\n\tmwifiex_debugfs_init();\n#endif\n\treturn 0;\n}\n\n \nstatic void\nmwifiex_cleanup_module(void)\n{\n#ifdef CONFIG_DEBUG_FS\n\tmwifiex_debugfs_remove();\n#endif\n}\n\nmodule_init(mwifiex_init_module);\nmodule_exit(mwifiex_cleanup_module);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell WiFi-Ex Driver version \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}