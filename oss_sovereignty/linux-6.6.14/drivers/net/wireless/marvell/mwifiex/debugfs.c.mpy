{
  "module_name": "debugfs.c",
  "hash_id": "741d24ee9121e1b5f22eb084ea2bceecc28508b976d24a439b02a22a91e97965",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n\n#include \"main.h\"\n#include \"11n.h\"\n\n\nstatic struct dentry *mwifiex_dfs_dir;\n\nstatic char *bss_modes[] = {\n\t\"UNSPECIFIED\",\n\t\"ADHOC\",\n\t\"STATION\",\n\t\"AP\",\n\t\"AP_VLAN\",\n\t\"WDS\",\n\t\"MONITOR\",\n\t\"MESH_POINT\",\n\t\"P2P_CLIENT\",\n\t\"P2P_GO\",\n\t\"P2P_DEVICE\",\n};\n\n \nstatic ssize_t\nmwifiex_info_read(struct file *file, char __user *ubuf,\n\t\t  size_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv =\n\t\t(struct mwifiex_private *) file->private_data;\n\tstruct net_device *netdev = priv->netdev;\n\tstruct netdev_hw_addr *ha;\n\tstruct netdev_queue *txq;\n\tunsigned long page = get_zeroed_page(GFP_KERNEL);\n\tchar *p = (char *) page, fmt[64];\n\tstruct mwifiex_bss_info info;\n\tssize_t ret;\n\tint i = 0;\n\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tmemset(&info, 0, sizeof(info));\n\tret = mwifiex_get_bss_info(priv, &info);\n\tif (ret)\n\t\tgoto free_and_exit;\n\n\tmwifiex_drv_get_driver_version(priv->adapter, fmt, sizeof(fmt) - 1);\n\n\tmwifiex_get_ver_ext(priv, 0);\n\n\tp += sprintf(p, \"driver_name = \" \"\\\"mwifiex\\\"\\n\");\n\tp += sprintf(p, \"driver_version = %s\", fmt);\n\tp += sprintf(p, \"\\nverext = %s\", priv->version_str);\n\tp += sprintf(p, \"\\ninterface_name=\\\"%s\\\"\\n\", netdev->name);\n\n\tif (info.bss_mode >= ARRAY_SIZE(bss_modes))\n\t\tp += sprintf(p, \"bss_mode=\\\"%d\\\"\\n\", info.bss_mode);\n\telse\n\t\tp += sprintf(p, \"bss_mode=\\\"%s\\\"\\n\", bss_modes[info.bss_mode]);\n\n\tp += sprintf(p, \"media_state=\\\"%s\\\"\\n\",\n\t\t     (!priv->media_connected ? \"Disconnected\" : \"Connected\"));\n\tp += sprintf(p, \"mac_address=\\\"%pM\\\"\\n\", netdev->dev_addr);\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) {\n\t\tp += sprintf(p, \"multicast_count=\\\"%d\\\"\\n\",\n\t\t\t     netdev_mc_count(netdev));\n\t\tp += sprintf(p, \"essid=\\\"%.*s\\\"\\n\", info.ssid.ssid_len,\n\t\t\t     info.ssid.ssid);\n\t\tp += sprintf(p, \"bssid=\\\"%pM\\\"\\n\", info.bssid);\n\t\tp += sprintf(p, \"channel=\\\"%d\\\"\\n\", (int) info.bss_chan);\n\t\tp += sprintf(p, \"country_code = \\\"%s\\\"\\n\", info.country_code);\n\t\tp += sprintf(p, \"region_code=\\\"0x%x\\\"\\n\",\n\t\t\t     priv->adapter->region_code);\n\n\t\tnetdev_for_each_mc_addr(ha, netdev)\n\t\t\tp += sprintf(p, \"multicast_address[%d]=\\\"%pM\\\"\\n\",\n\t\t\t\t\ti++, ha->addr);\n\t}\n\n\tp += sprintf(p, \"num_tx_bytes = %lu\\n\", priv->stats.tx_bytes);\n\tp += sprintf(p, \"num_rx_bytes = %lu\\n\", priv->stats.rx_bytes);\n\tp += sprintf(p, \"num_tx_pkts = %lu\\n\", priv->stats.tx_packets);\n\tp += sprintf(p, \"num_rx_pkts = %lu\\n\", priv->stats.rx_packets);\n\tp += sprintf(p, \"num_tx_pkts_dropped = %lu\\n\", priv->stats.tx_dropped);\n\tp += sprintf(p, \"num_rx_pkts_dropped = %lu\\n\", priv->stats.rx_dropped);\n\tp += sprintf(p, \"num_tx_pkts_err = %lu\\n\", priv->stats.tx_errors);\n\tp += sprintf(p, \"num_rx_pkts_err = %lu\\n\", priv->stats.rx_errors);\n\tp += sprintf(p, \"carrier %s\\n\", ((netif_carrier_ok(priv->netdev))\n\t\t\t\t\t ? \"on\" : \"off\"));\n\tp += sprintf(p, \"tx queue\");\n\tfor (i = 0; i < netdev->num_tx_queues; i++) {\n\t\ttxq = netdev_get_tx_queue(netdev, i);\n\t\tp += sprintf(p, \" %d:%s\", i, netif_tx_queue_stopped(txq) ?\n\t\t\t     \"stopped\" : \"started\");\n\t}\n\tp += sprintf(p, \"\\n\");\n\n\tret = simple_read_from_buffer(ubuf, count, ppos, (char *) page,\n\t\t\t\t      (unsigned long) p - page);\n\nfree_and_exit:\n\tfree_page(page);\n\treturn ret;\n}\n\n \nstatic ssize_t\nmwifiex_getlog_read(struct file *file, char __user *ubuf,\n\t\t    size_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv =\n\t\t(struct mwifiex_private *) file->private_data;\n\tunsigned long page = get_zeroed_page(GFP_KERNEL);\n\tchar *p = (char *) page;\n\tssize_t ret;\n\tstruct mwifiex_ds_get_stats stats;\n\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tmemset(&stats, 0, sizeof(stats));\n\tret = mwifiex_get_stats_info(priv, &stats);\n\tif (ret)\n\t\tgoto free_and_exit;\n\n\tp += sprintf(p, \"\\n\"\n\t\t     \"mcasttxframe     %u\\n\"\n\t\t     \"failed           %u\\n\"\n\t\t     \"retry            %u\\n\"\n\t\t     \"multiretry       %u\\n\"\n\t\t     \"framedup         %u\\n\"\n\t\t     \"rtssuccess       %u\\n\"\n\t\t     \"rtsfailure       %u\\n\"\n\t\t     \"ackfailure       %u\\n\"\n\t\t     \"rxfrag           %u\\n\"\n\t\t     \"mcastrxframe     %u\\n\"\n\t\t     \"fcserror         %u\\n\"\n\t\t     \"txframe          %u\\n\"\n\t\t     \"wepicverrcnt-1   %u\\n\"\n\t\t     \"wepicverrcnt-2   %u\\n\"\n\t\t     \"wepicverrcnt-3   %u\\n\"\n\t\t     \"wepicverrcnt-4   %u\\n\"\n\t\t     \"bcn_rcv_cnt   %u\\n\"\n\t\t     \"bcn_miss_cnt   %u\\n\",\n\t\t     stats.mcast_tx_frame,\n\t\t     stats.failed,\n\t\t     stats.retry,\n\t\t     stats.multi_retry,\n\t\t     stats.frame_dup,\n\t\t     stats.rts_success,\n\t\t     stats.rts_failure,\n\t\t     stats.ack_failure,\n\t\t     stats.rx_frag,\n\t\t     stats.mcast_rx_frame,\n\t\t     stats.fcs_error,\n\t\t     stats.tx_frame,\n\t\t     stats.wep_icv_error[0],\n\t\t     stats.wep_icv_error[1],\n\t\t     stats.wep_icv_error[2],\n\t\t     stats.wep_icv_error[3],\n\t\t     stats.bcn_rcv_cnt,\n\t\t     stats.bcn_miss_cnt);\n\n\n\tret = simple_read_from_buffer(ubuf, count, ppos, (char *) page,\n\t\t\t\t      (unsigned long) p - page);\n\nfree_and_exit:\n\tfree_page(page);\n\treturn ret;\n}\n\n \nstatic ssize_t\nmwifiex_histogram_read(struct file *file, char __user *ubuf,\n\t\t       size_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv =\n\t\t(struct mwifiex_private *)file->private_data;\n\tssize_t ret;\n\tstruct mwifiex_histogram_data *phist_data;\n\tint i, value;\n\tunsigned long page = get_zeroed_page(GFP_KERNEL);\n\tchar *p = (char *)page;\n\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tif (!priv || !priv->hist_data) {\n\t\tret = -EFAULT;\n\t\tgoto free_and_exit;\n\t}\n\n\tphist_data = priv->hist_data;\n\n\tp += sprintf(p, \"\\n\"\n\t\t     \"total samples = %d\\n\",\n\t\t     atomic_read(&phist_data->num_samples));\n\n\tp += sprintf(p,\n\t\t     \"rx rates (in Mbps): 0=1M   1=2M 2=5.5M  3=11M   4=6M   5=9M  6=12M\\n\"\n\t\t     \"7=18M  8=24M  9=36M  10=48M  11=54M 12-27=MCS0-15(BW20) 28-43=MCS0-15(BW40)\\n\");\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info)) {\n\t\tp += sprintf(p,\n\t\t\t     \"44-53=MCS0-9(VHT:BW20) 54-63=MCS0-9(VHT:BW40) 64-73=MCS0-9(VHT:BW80)\\n\\n\");\n\t} else {\n\t\tp += sprintf(p, \"\\n\");\n\t}\n\n\tfor (i = 0; i < MWIFIEX_MAX_RX_RATES; i++) {\n\t\tvalue = atomic_read(&phist_data->rx_rate[i]);\n\t\tif (value)\n\t\t\tp += sprintf(p, \"rx_rate[%02d] = %d\\n\", i, value);\n\t}\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info)) {\n\t\tfor (i = MWIFIEX_MAX_RX_RATES; i < MWIFIEX_MAX_AC_RX_RATES;\n\t\t     i++) {\n\t\t\tvalue = atomic_read(&phist_data->rx_rate[i]);\n\t\t\tif (value)\n\t\t\t\tp += sprintf(p, \"rx_rate[%02d] = %d\\n\",\n\t\t\t\t\t   i, value);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MWIFIEX_MAX_SNR; i++) {\n\t\tvalue =  atomic_read(&phist_data->snr[i]);\n\t\tif (value)\n\t\t\tp += sprintf(p, \"snr[%02ddB] = %d\\n\", i, value);\n\t}\n\tfor (i = 0; i < MWIFIEX_MAX_NOISE_FLR; i++) {\n\t\tvalue = atomic_read(&phist_data->noise_flr[i]);\n\t\tif (value)\n\t\t\tp += sprintf(p, \"noise_flr[%02ddBm] = %d\\n\",\n\t\t\t\t(int)(i-128), value);\n\t}\n\tfor (i = 0; i < MWIFIEX_MAX_SIG_STRENGTH; i++) {\n\t\tvalue = atomic_read(&phist_data->sig_str[i]);\n\t\tif (value)\n\t\t\tp += sprintf(p, \"sig_strength[-%02ddBm] = %d\\n\",\n\t\t\t\ti, value);\n\t}\n\n\tret = simple_read_from_buffer(ubuf, count, ppos, (char *)page,\n\t\t\t\t      (unsigned long)p - page);\n\nfree_and_exit:\n\tfree_page(page);\n\treturn ret;\n}\n\nstatic ssize_t\nmwifiex_histogram_write(struct file *file, const char __user *ubuf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv = (void *)file->private_data;\n\n\tif (priv && priv->hist_data)\n\t\tmwifiex_hist_data_reset(priv);\n\treturn 0;\n}\n\nstatic struct mwifiex_debug_info info;\n\n \nstatic ssize_t\nmwifiex_debug_read(struct file *file, char __user *ubuf,\n\t\t   size_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv =\n\t\t(struct mwifiex_private *) file->private_data;\n\tunsigned long page = get_zeroed_page(GFP_KERNEL);\n\tchar *p = (char *) page;\n\tssize_t ret;\n\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = mwifiex_get_debug_info(priv, &info);\n\tif (ret)\n\t\tgoto free_and_exit;\n\n\tp += mwifiex_debug_info_to_buffer(priv, p, &info);\n\n\tret = simple_read_from_buffer(ubuf, count, ppos, (char *) page,\n\t\t\t\t      (unsigned long) p - page);\n\nfree_and_exit:\n\tfree_page(page);\n\treturn ret;\n}\n\nstatic u32 saved_reg_type, saved_reg_offset, saved_reg_value;\n\n \nstatic ssize_t\nmwifiex_regrdwr_write(struct file *file,\n\t\t      const char __user *ubuf, size_t count, loff_t *ppos)\n{\n\tchar *buf;\n\tint ret;\n\tu32 reg_type = 0, reg_offset = 0, reg_value = UINT_MAX;\n\n\tbuf = memdup_user_nul(ubuf, min(count, (size_t)(PAGE_SIZE - 1)));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tif (sscanf(buf, \"%u %x %x\", &reg_type, &reg_offset, &reg_value) != 3) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (reg_type == 0 || reg_offset == 0) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t} else {\n\t\tsaved_reg_type = reg_type;\n\t\tsaved_reg_offset = reg_offset;\n\t\tsaved_reg_value = reg_value;\n\t\tret = count;\n\t}\ndone:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic ssize_t\nmwifiex_regrdwr_read(struct file *file, char __user *ubuf,\n\t\t     size_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv =\n\t\t(struct mwifiex_private *) file->private_data;\n\tunsigned long addr = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *) addr;\n\tint pos = 0, ret = 0;\n\tu32 reg_value;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (!saved_reg_type) {\n\t\t \n\t\tpos += snprintf(buf, PAGE_SIZE, \"0\");\n\t\tgoto done;\n\t}\n\t \n\tif (saved_reg_value != UINT_MAX) {\n\t\tret = mwifiex_reg_write(priv, saved_reg_type, saved_reg_offset,\n\t\t\t\t\tsaved_reg_value);\n\n\t\tpos += snprintf(buf, PAGE_SIZE, \"%u 0x%x 0x%x\\n\",\n\t\t\t\tsaved_reg_type, saved_reg_offset,\n\t\t\t\tsaved_reg_value);\n\n\t\tret = simple_read_from_buffer(ubuf, count, ppos, buf, pos);\n\n\t\tgoto done;\n\t}\n\t \n\tret = mwifiex_reg_read(priv, saved_reg_type,\n\t\t\t       saved_reg_offset, &reg_value);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tpos += snprintf(buf, PAGE_SIZE, \"%u 0x%x 0x%x\\n\", saved_reg_type,\n\t\t\tsaved_reg_offset, reg_value);\n\n\tret = simple_read_from_buffer(ubuf, count, ppos, buf, pos);\n\ndone:\n\tfree_page(addr);\n\treturn ret;\n}\n\n \nstatic ssize_t\nmwifiex_debug_mask_read(struct file *file, char __user *ubuf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv =\n\t\t(struct mwifiex_private *)file->private_data;\n\tunsigned long page = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *)page;\n\tsize_t ret = 0;\n\tint pos = 0;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpos += snprintf(buf, PAGE_SIZE, \"debug mask=0x%08x\\n\",\n\t\t\tpriv->adapter->debug_mask);\n\tret = simple_read_from_buffer(ubuf, count, ppos, buf, pos);\n\n\tfree_page(page);\n\treturn ret;\n}\n\n \nstatic ssize_t\nmwifiex_debug_mask_write(struct file *file, const char __user *ubuf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint ret;\n\tunsigned long debug_mask;\n\tstruct mwifiex_private *priv = (void *)file->private_data;\n\tchar *buf;\n\n\tbuf = memdup_user_nul(ubuf, min(count, (size_t)(PAGE_SIZE - 1)));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tif (kstrtoul(buf, 0, &debug_mask)) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tpriv->adapter->debug_mask = debug_mask;\n\tret = count;\ndone:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic ssize_t\nmwifiex_verext_write(struct file *file, const char __user *ubuf,\n\t\t     size_t count, loff_t *ppos)\n{\n\tint ret;\n\tu32 versionstrsel;\n\tstruct mwifiex_private *priv = (void *)file->private_data;\n\tchar buf[16];\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\n\t\treturn -EFAULT;\n\n\tret = kstrtou32(buf, 10, &versionstrsel);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->versionstrsel = versionstrsel;\n\n\treturn count;\n}\n\n \nstatic ssize_t\nmwifiex_verext_read(struct file *file, char __user *ubuf,\n\t\t    size_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv =\n\t\t(struct mwifiex_private *)file->private_data;\n\tchar buf[256];\n\tint ret;\n\n\tmwifiex_get_ver_ext(priv, priv->versionstrsel);\n\tret = snprintf(buf, sizeof(buf), \"version string: %s\\n\",\n\t\t       priv->version_str);\n\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, ret);\n}\n\n \nstatic ssize_t\nmwifiex_memrw_write(struct file *file, const char __user *ubuf, size_t count,\n\t\t    loff_t *ppos)\n{\n\tint ret;\n\tchar cmd;\n\tstruct mwifiex_ds_mem_rw mem_rw;\n\tu16 cmd_action;\n\tstruct mwifiex_private *priv = (void *)file->private_data;\n\tchar *buf;\n\n\tbuf = memdup_user_nul(ubuf, min(count, (size_t)(PAGE_SIZE - 1)));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tret = sscanf(buf, \"%c %x %x\", &cmd, &mem_rw.addr, &mem_rw.value);\n\tif (ret != 3) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif ((cmd == 'r') || (cmd == 'R')) {\n\t\tcmd_action = HostCmd_ACT_GEN_GET;\n\t\tmem_rw.value = 0;\n\t} else if ((cmd == 'w') || (cmd == 'W')) {\n\t\tcmd_action = HostCmd_ACT_GEN_SET;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tmemcpy(&priv->mem_rw, &mem_rw, sizeof(mem_rw));\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MEM_ACCESS, cmd_action, 0,\n\t\t\t     &mem_rw, true))\n\t\tret = -1;\n\telse\n\t\tret = count;\n\ndone:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic ssize_t\nmwifiex_memrw_read(struct file *file, char __user *ubuf,\n\t\t   size_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv = (void *)file->private_data;\n\tunsigned long addr = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *)addr;\n\tint ret, pos = 0;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpos += snprintf(buf, PAGE_SIZE, \"0x%x 0x%x\\n\", priv->mem_rw.addr,\n\t\t\tpriv->mem_rw.value);\n\tret = simple_read_from_buffer(ubuf, count, ppos, buf, pos);\n\n\tfree_page(addr);\n\treturn ret;\n}\n\nstatic u32 saved_offset = -1, saved_bytes = -1;\n\n \nstatic ssize_t\nmwifiex_rdeeprom_write(struct file *file,\n\t\t       const char __user *ubuf, size_t count, loff_t *ppos)\n{\n\tchar *buf;\n\tint ret = 0;\n\tint offset = -1, bytes = -1;\n\n\tbuf = memdup_user_nul(ubuf, min(count, (size_t)(PAGE_SIZE - 1)));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tif (sscanf(buf, \"%d %d\", &offset, &bytes) != 2) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (offset == -1 || bytes == -1) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t} else {\n\t\tsaved_offset = offset;\n\t\tsaved_bytes = bytes;\n\t\tret = count;\n\t}\ndone:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic ssize_t\nmwifiex_rdeeprom_read(struct file *file, char __user *ubuf,\n\t\t      size_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv =\n\t\t(struct mwifiex_private *) file->private_data;\n\tunsigned long addr = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *) addr;\n\tint pos, ret, i;\n\tu8 value[MAX_EEPROM_DATA];\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (saved_offset == -1) {\n\t\t \n\t\tpos = snprintf(buf, PAGE_SIZE, \"0\");\n\t\tgoto done;\n\t}\n\n\t \n\tret = mwifiex_eeprom_read(priv, (u16) saved_offset,\n\t\t\t\t  (u16) saved_bytes, value);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tpos = snprintf(buf, PAGE_SIZE, \"%d %d \", saved_offset, saved_bytes);\n\n\tfor (i = 0; i < saved_bytes; i++)\n\t\tpos += scnprintf(buf + pos, PAGE_SIZE - pos, \"%d \", value[i]);\n\ndone:\n\tret = simple_read_from_buffer(ubuf, count, ppos, buf, pos);\nout_free:\n\tfree_page(addr);\n\treturn ret;\n}\n\n \nstatic ssize_t\nmwifiex_hscfg_write(struct file *file, const char __user *ubuf,\n\t\t    size_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv = (void *)file->private_data;\n\tchar *buf;\n\tint ret, arg_num;\n\tstruct mwifiex_ds_hs_cfg hscfg;\n\tint conditions = HS_CFG_COND_DEF;\n\tu32 gpio = HS_CFG_GPIO_DEF, gap = HS_CFG_GAP_DEF;\n\n\tbuf = memdup_user_nul(ubuf, min(count, (size_t)(PAGE_SIZE - 1)));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\targ_num = sscanf(buf, \"%d %x %x\", &conditions, &gpio, &gap);\n\n\tmemset(&hscfg, 0, sizeof(struct mwifiex_ds_hs_cfg));\n\n\tif (arg_num > 3) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Too many arguments\\n\");\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (arg_num >= 1 && arg_num < 3)\n\t\tmwifiex_set_hs_params(priv, HostCmd_ACT_GEN_GET,\n\t\t\t\t      MWIFIEX_SYNC_CMD, &hscfg);\n\n\tif (arg_num) {\n\t\tif (conditions == HS_CFG_CANCEL) {\n\t\t\tmwifiex_cancel_hs(priv, MWIFIEX_ASYNC_CMD);\n\t\t\tret = count;\n\t\t\tgoto done;\n\t\t}\n\t\thscfg.conditions = conditions;\n\t}\n\tif (arg_num >= 2)\n\t\thscfg.gpio = gpio;\n\tif (arg_num == 3)\n\t\thscfg.gap = gap;\n\n\thscfg.is_invoke_hostcmd = false;\n\tmwifiex_set_hs_params(priv, HostCmd_ACT_GEN_SET,\n\t\t\t      MWIFIEX_SYNC_CMD, &hscfg);\n\n\tmwifiex_enable_hs(priv->adapter);\n\tclear_bit(MWIFIEX_IS_HS_ENABLING, &priv->adapter->work_flags);\n\tret = count;\ndone:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic ssize_t\nmwifiex_hscfg_read(struct file *file, char __user *ubuf,\n\t\t   size_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv = (void *)file->private_data;\n\tunsigned long addr = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *)addr;\n\tint pos, ret;\n\tstruct mwifiex_ds_hs_cfg hscfg;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmwifiex_set_hs_params(priv, HostCmd_ACT_GEN_GET,\n\t\t\t      MWIFIEX_SYNC_CMD, &hscfg);\n\n\tpos = snprintf(buf, PAGE_SIZE, \"%u 0x%x 0x%x\\n\", hscfg.conditions,\n\t\t       hscfg.gpio, hscfg.gap);\n\n\tret = simple_read_from_buffer(ubuf, count, ppos, buf, pos);\n\n\tfree_page(addr);\n\treturn ret;\n}\n\nstatic ssize_t\nmwifiex_timeshare_coex_read(struct file *file, char __user *ubuf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv = file->private_data;\n\tchar buf[3];\n\tbool timeshare_coex;\n\tint ret;\n\tunsigned int len;\n\n\tif (priv->adapter->fw_api_ver != MWIFIEX_FW_V15)\n\t\treturn -EOPNOTSUPP;\n\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_ROBUST_COEX,\n\t\t\t       HostCmd_ACT_GEN_GET, 0, &timeshare_coex, true);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = sprintf(buf, \"%d\\n\", timeshare_coex);\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, len);\n}\n\nstatic ssize_t\nmwifiex_timeshare_coex_write(struct file *file, const char __user *ubuf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tbool timeshare_coex;\n\tstruct mwifiex_private *priv = file->private_data;\n\tchar kbuf[16];\n\tint ret;\n\n\tif (priv->adapter->fw_api_ver != MWIFIEX_FW_V15)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(kbuf, 0, sizeof(kbuf));\n\n\tif (copy_from_user(&kbuf, ubuf, min_t(size_t, sizeof(kbuf) - 1, count)))\n\t\treturn -EFAULT;\n\n\tif (kstrtobool(kbuf, &timeshare_coex))\n\t\treturn -EINVAL;\n\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_ROBUST_COEX,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &timeshare_coex, true);\n\tif (ret)\n\t\treturn ret;\n\telse\n\t\treturn count;\n}\n\nstatic ssize_t\nmwifiex_reset_write(struct file *file,\n\t\t    const char __user *ubuf, size_t count, loff_t *ppos)\n{\n\tstruct mwifiex_private *priv = file->private_data;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tbool result;\n\tint rc;\n\n\trc = kstrtobool_from_user(ubuf, count, &result);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!result)\n\t\treturn -EINVAL;\n\n\tif (adapter->if_ops.card_reset) {\n\t\tdev_info(adapter->dev, \"Resetting per request\\n\");\n\t\tadapter->if_ops.card_reset(adapter);\n\t}\n\n\treturn count;\n}\n\n#define MWIFIEX_DFS_ADD_FILE(name) do {                                 \\\n\tdebugfs_create_file(#name, 0644, priv->dfs_dev_dir, priv,       \\\n\t\t\t    &mwifiex_dfs_##name##_fops);                \\\n} while (0);\n\n#define MWIFIEX_DFS_FILE_OPS(name)                                      \\\nstatic const struct file_operations mwifiex_dfs_##name##_fops = {       \\\n\t.read = mwifiex_##name##_read,                                  \\\n\t.write = mwifiex_##name##_write,                                \\\n\t.open = simple_open,                                            \\\n};\n\n#define MWIFIEX_DFS_FILE_READ_OPS(name)                                 \\\nstatic const struct file_operations mwifiex_dfs_##name##_fops = {       \\\n\t.read = mwifiex_##name##_read,                                  \\\n\t.open = simple_open,                                            \\\n};\n\n#define MWIFIEX_DFS_FILE_WRITE_OPS(name)                                \\\nstatic const struct file_operations mwifiex_dfs_##name##_fops = {       \\\n\t.write = mwifiex_##name##_write,                                \\\n\t.open = simple_open,                                            \\\n};\n\n\nMWIFIEX_DFS_FILE_READ_OPS(info);\nMWIFIEX_DFS_FILE_READ_OPS(debug);\nMWIFIEX_DFS_FILE_READ_OPS(getlog);\nMWIFIEX_DFS_FILE_OPS(regrdwr);\nMWIFIEX_DFS_FILE_OPS(rdeeprom);\nMWIFIEX_DFS_FILE_OPS(memrw);\nMWIFIEX_DFS_FILE_OPS(hscfg);\nMWIFIEX_DFS_FILE_OPS(histogram);\nMWIFIEX_DFS_FILE_OPS(debug_mask);\nMWIFIEX_DFS_FILE_OPS(timeshare_coex);\nMWIFIEX_DFS_FILE_WRITE_OPS(reset);\nMWIFIEX_DFS_FILE_OPS(verext);\n\n \nvoid\nmwifiex_dev_debugfs_init(struct mwifiex_private *priv)\n{\n\tif (!mwifiex_dfs_dir || !priv)\n\t\treturn;\n\n\tpriv->dfs_dev_dir = debugfs_create_dir(priv->netdev->name,\n\t\t\t\t\t       mwifiex_dfs_dir);\n\n\tif (!priv->dfs_dev_dir)\n\t\treturn;\n\n\tMWIFIEX_DFS_ADD_FILE(info);\n\tMWIFIEX_DFS_ADD_FILE(debug);\n\tMWIFIEX_DFS_ADD_FILE(getlog);\n\tMWIFIEX_DFS_ADD_FILE(regrdwr);\n\tMWIFIEX_DFS_ADD_FILE(rdeeprom);\n\n\tMWIFIEX_DFS_ADD_FILE(memrw);\n\tMWIFIEX_DFS_ADD_FILE(hscfg);\n\tMWIFIEX_DFS_ADD_FILE(histogram);\n\tMWIFIEX_DFS_ADD_FILE(debug_mask);\n\tMWIFIEX_DFS_ADD_FILE(timeshare_coex);\n\tMWIFIEX_DFS_ADD_FILE(reset);\n\tMWIFIEX_DFS_ADD_FILE(verext);\n}\n\n \nvoid\nmwifiex_dev_debugfs_remove(struct mwifiex_private *priv)\n{\n\tif (!priv)\n\t\treturn;\n\n\tdebugfs_remove_recursive(priv->dfs_dev_dir);\n}\n\n \nvoid\nmwifiex_debugfs_init(void)\n{\n\tif (!mwifiex_dfs_dir)\n\t\tmwifiex_dfs_dir = debugfs_create_dir(\"mwifiex\", NULL);\n}\n\n \nvoid\nmwifiex_debugfs_remove(void)\n{\n\tdebugfs_remove(mwifiex_dfs_dir);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}