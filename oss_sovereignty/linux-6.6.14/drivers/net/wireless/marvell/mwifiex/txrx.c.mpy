{
  "module_name": "txrx.c",
  "hash_id": "d8ebd42d4306884e7be9c0c67f1ef10681cdd96a2fe9a56086cefd2a890a68d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/txrx.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n\n \nint mwifiex_handle_rx_packet(struct mwifiex_adapter *adapter,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct mwifiex_private *priv =\n\t\tmwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\tstruct rxpd *local_rx_pd;\n\tstruct mwifiex_rxinfo *rx_info = MWIFIEX_SKB_RXCB(skb);\n\tint ret;\n\n\tlocal_rx_pd = (struct rxpd *) (skb->data);\n\t \n\tpriv = mwifiex_get_priv_by_id(adapter, local_rx_pd->bss_num &\n\t\t\t\t      BSS_NUM_MASK, local_rx_pd->bss_type);\n\tif (!priv)\n\t\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\n\tif (!priv) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"data: priv not found. Drop RX packet\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg_dump(adapter, DAT_D, \"rx pkt:\", skb->data,\n\t\t\t min_t(size_t, skb->len, DEBUG_DUMP_DATA_MAX_LEN));\n\n\tmemset(rx_info, 0, sizeof(*rx_info));\n\trx_info->bss_num = priv->bss_num;\n\trx_info->bss_type = priv->bss_type;\n\n\tif (priv->bss_role == MWIFIEX_BSS_ROLE_UAP)\n\t\tret = mwifiex_process_uap_rx_packet(priv, skb);\n\telse\n\t\tret = mwifiex_process_sta_rx_packet(priv, skb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mwifiex_handle_rx_packet);\n\n \nint mwifiex_process_tx(struct mwifiex_private *priv, struct sk_buff *skb,\n\t\t       struct mwifiex_tx_param *tx_param)\n{\n\tint hroom, ret;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct txpd *local_tx_pd = NULL;\n\tstruct mwifiex_sta_node *dest_node;\n\tstruct ethhdr *hdr = (void *)skb->data;\n\n\tif (unlikely(!skb->len ||\n\t\t     skb_headroom(skb) < MWIFIEX_MIN_DATA_HEADER_LEN)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\throom = adapter->intf_hdr_len;\n\n\tif (priv->bss_role == MWIFIEX_BSS_ROLE_UAP) {\n\t\tdest_node = mwifiex_get_sta_entry(priv, hdr->h_dest);\n\t\tif (dest_node) {\n\t\t\tdest_node->stats.tx_bytes += skb->len;\n\t\t\tdest_node->stats.tx_packets++;\n\t\t}\n\n\t\tmwifiex_process_uap_txpd(priv, skb);\n\t} else {\n\t\tmwifiex_process_sta_txpd(priv, skb);\n\t}\n\n\tif (adapter->data_sent || adapter->tx_lock_flag) {\n\t\tskb_queue_tail(&adapter->tx_data_q, skb);\n\t\tatomic_inc(&adapter->tx_queued);\n\t\treturn 0;\n\t}\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA)\n\t\tlocal_tx_pd = (struct txpd *)(skb->data + hroom);\n\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\tret = adapter->if_ops.host_to_card(adapter,\n\t\t\t\t\t\t   priv->usb_port,\n\t\t\t\t\t\t   skb, tx_param);\n\t} else {\n\t\tret = adapter->if_ops.host_to_card(adapter,\n\t\t\t\t\t\t   MWIFIEX_TYPE_DATA,\n\t\t\t\t\t\t   skb, tx_param);\n\t}\n\tmwifiex_dbg_dump(adapter, DAT_D, \"tx pkt:\", skb->data,\n\t\t\t min_t(size_t, skb->len, DEBUG_DUMP_DATA_MAX_LEN));\nout:\n\tswitch (ret) {\n\tcase -ENOSR:\n\t\tmwifiex_dbg(adapter, DATA, \"data: -ENOSR is returned\\n\");\n\t\tbreak;\n\tcase -EBUSY:\n\t\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t\t    (adapter->pps_uapsd_mode) && (adapter->tx_lock_flag)) {\n\t\t\t\tpriv->adapter->tx_lock_flag = false;\n\t\t\t\tif (local_tx_pd)\n\t\t\t\t\tlocal_tx_pd->flags = 0;\n\t\t}\n\t\tmwifiex_dbg(adapter, ERROR, \"data: -EBUSY is returned\\n\");\n\t\tbreak;\n\tcase -1:\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"mwifiex_write_data_async failed: 0x%X\\n\",\n\t\t\t    ret);\n\t\tadapter->dbg.num_tx_host_to_card_failure++;\n\t\tmwifiex_write_data_complete(adapter, skb, 0, ret);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tbreak;\n\tcase -EINVAL:\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"malformed skb (length: %u, headroom: %u)\\n\",\n\t\t\t    skb->len, skb_headroom(skb));\n\t\tfallthrough;\n\tcase 0:\n\t\tmwifiex_write_data_complete(adapter, skb, 0, ret);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int mwifiex_host_to_card(struct mwifiex_adapter *adapter,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct mwifiex_tx_param *tx_param)\n{\n\tstruct txpd *local_tx_pd = NULL;\n\tu8 *head_ptr = skb->data;\n\tint ret = 0;\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_txinfo *tx_info;\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tpriv = mwifiex_get_priv_by_id(adapter, tx_info->bss_num,\n\t\t\t\t      tx_info->bss_type);\n\tif (!priv) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"data: priv not found. Drop TX packet\\n\");\n\t\tadapter->dbg.num_tx_host_to_card_failure++;\n\t\tmwifiex_write_data_complete(adapter, skb, 0, 0);\n\t\treturn ret;\n\t}\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA)\n\t\tlocal_tx_pd = (struct txpd *)(head_ptr + adapter->intf_hdr_len);\n\n\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\tret = adapter->if_ops.host_to_card(adapter,\n\t\t\t\t\t\t   priv->usb_port,\n\t\t\t\t\t\t   skb, tx_param);\n\t} else {\n\t\tret = adapter->if_ops.host_to_card(adapter,\n\t\t\t\t\t\t   MWIFIEX_TYPE_DATA,\n\t\t\t\t\t\t   skb, tx_param);\n\t}\n\tswitch (ret) {\n\tcase -ENOSR:\n\t\tmwifiex_dbg(adapter, ERROR, \"data: -ENOSR is returned\\n\");\n\t\tbreak;\n\tcase -EBUSY:\n\t\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t\t    (adapter->pps_uapsd_mode) &&\n\t\t    (adapter->tx_lock_flag)) {\n\t\t\tpriv->adapter->tx_lock_flag = false;\n\t\t\tif (local_tx_pd)\n\t\t\t\tlocal_tx_pd->flags = 0;\n\t\t}\n\t\tskb_queue_head(&adapter->tx_data_q, skb);\n\t\tif (tx_info->flags & MWIFIEX_BUF_FLAG_AGGR_PKT)\n\t\t\tatomic_add(tx_info->aggr_num, &adapter->tx_queued);\n\t\telse\n\t\t\tatomic_inc(&adapter->tx_queued);\n\t\tmwifiex_dbg(adapter, ERROR, \"data: -EBUSY is returned\\n\");\n\t\tbreak;\n\tcase -1:\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"mwifiex_write_data_async failed: 0x%X\\n\", ret);\n\t\tadapter->dbg.num_tx_host_to_card_failure++;\n\t\tmwifiex_write_data_complete(adapter, skb, 0, ret);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tbreak;\n\tcase 0:\n\t\tmwifiex_write_data_complete(adapter, skb, 0, ret);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nmwifiex_dequeue_tx_queue(struct mwifiex_adapter *adapter)\n{\n\tstruct sk_buff *skb, *skb_next;\n\tstruct mwifiex_txinfo *tx_info;\n\tstruct mwifiex_tx_param tx_param;\n\n\tskb = skb_dequeue(&adapter->tx_data_q);\n\tif (!skb)\n\t\treturn -1;\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tif (tx_info->flags & MWIFIEX_BUF_FLAG_AGGR_PKT)\n\t\tatomic_sub(tx_info->aggr_num, &adapter->tx_queued);\n\telse\n\t\tatomic_dec(&adapter->tx_queued);\n\n\tif (!skb_queue_empty(&adapter->tx_data_q))\n\t\tskb_next = skb_peek(&adapter->tx_data_q);\n\telse\n\t\tskb_next = NULL;\n\ttx_param.next_pkt_len = ((skb_next) ? skb_next->len : 0);\n\tif (!tx_param.next_pkt_len) {\n\t\tif (!mwifiex_wmm_lists_empty(adapter))\n\t\t\ttx_param.next_pkt_len = 1;\n\t}\n\treturn mwifiex_host_to_card(adapter, skb, &tx_param);\n}\n\nvoid\nmwifiex_process_tx_queue(struct mwifiex_adapter *adapter)\n{\n\tdo {\n\t\tif (adapter->data_sent || adapter->tx_lock_flag)\n\t\t\tbreak;\n\t\tif (mwifiex_dequeue_tx_queue(adapter))\n\t\t\tbreak;\n\t} while (!skb_queue_empty(&adapter->tx_data_q));\n}\n\n \nint mwifiex_write_data_complete(struct mwifiex_adapter *adapter,\n\t\t\t\tstruct sk_buff *skb, int aggr, int status)\n{\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_txinfo *tx_info;\n\tstruct netdev_queue *txq;\n\tint index;\n\n\tif (!skb)\n\t\treturn 0;\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tpriv = mwifiex_get_priv_by_id(adapter, tx_info->bss_num,\n\t\t\t\t      tx_info->bss_type);\n\tif (!priv)\n\t\tgoto done;\n\n\tmwifiex_set_trans_start(priv->netdev);\n\n\tif (tx_info->flags & MWIFIEX_BUF_FLAG_BRIDGED_PKT)\n\t\tatomic_dec_return(&adapter->pending_bridged_pkts);\n\n\tif (tx_info->flags & MWIFIEX_BUF_FLAG_AGGR_PKT)\n\t\tgoto done;\n\n\tif (!status) {\n\t\tpriv->stats.tx_packets++;\n\t\tpriv->stats.tx_bytes += tx_info->pkt_len;\n\t\tif (priv->tx_timeout_cnt)\n\t\t\tpriv->tx_timeout_cnt = 0;\n\t} else {\n\t\tpriv->stats.tx_errors++;\n\t}\n\n\tif (aggr)\n\t\t \n\t\tgoto done;\n\n\tatomic_dec(&adapter->tx_pending);\n\n\tindex = mwifiex_1d_to_wmm_queue[skb->priority];\n\tif (atomic_dec_return(&priv->wmm_tx_pending[index]) < LOW_TX_PENDING) {\n\t\ttxq = netdev_get_tx_queue(priv->netdev, index);\n\t\tif (netif_tx_queue_stopped(txq)) {\n\t\t\tnetif_tx_wake_queue(txq);\n\t\t\tmwifiex_dbg(adapter, DATA, \"wake queue: %d\\n\", index);\n\t\t}\n\t}\ndone:\n\tdev_kfree_skb_any(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mwifiex_write_data_complete);\n\nvoid mwifiex_parse_tx_status_event(struct mwifiex_private *priv,\n\t\t\t\t   void *event_body)\n{\n\tstruct tx_status_event *tx_status = (void *)priv->adapter->event_body;\n\tstruct sk_buff *ack_skb;\n\tstruct mwifiex_txinfo *tx_info;\n\n\tif (!tx_status->tx_token_id)\n\t\treturn;\n\n\tspin_lock_bh(&priv->ack_status_lock);\n\tack_skb = idr_remove(&priv->ack_status_frames, tx_status->tx_token_id);\n\tspin_unlock_bh(&priv->ack_status_lock);\n\n\tif (ack_skb) {\n\t\ttx_info = MWIFIEX_SKB_TXCB(ack_skb);\n\n\t\tif (tx_info->flags & MWIFIEX_BUF_FLAG_EAPOL_TX_STATUS) {\n\t\t\t \n\t\t\tskb_complete_wifi_ack(ack_skb, !tx_status->status);\n\t\t} else {\n\t\t\t \n\t\t\tmemmove(ack_skb->data +\n\t\t\t\tsizeof(struct ieee80211_hdr_3addr) +\n\t\t\t\tMWIFIEX_MGMT_FRAME_HEADER_SIZE + sizeof(u16),\n\t\t\t\tack_skb->data +\n\t\t\t\tsizeof(struct ieee80211_hdr_3addr) +\n\t\t\t\tMWIFIEX_MGMT_FRAME_HEADER_SIZE + sizeof(u16) +\n\t\t\t\tETH_ALEN, ack_skb->len -\n\t\t\t\t(sizeof(struct ieee80211_hdr_3addr) +\n\t\t\t\tMWIFIEX_MGMT_FRAME_HEADER_SIZE + sizeof(u16) +\n\t\t\t\tETH_ALEN));\n\t\t\tack_skb->len = ack_skb->len - ETH_ALEN;\n\t\t\t \n\t\t\tcfg80211_mgmt_tx_status(&priv->wdev, tx_info->cookie,\n\t\t\t\t\t\tack_skb->data +\n\t\t\t\t\t\tMWIFIEX_MGMT_FRAME_HEADER_SIZE +\n\t\t\t\t\t\tsizeof(u16), ack_skb->len -\n\t\t\t\t\t\t(MWIFIEX_MGMT_FRAME_HEADER_SIZE\n\t\t\t\t\t\t + sizeof(u16)),\n\t\t\t\t\t\t!tx_status->status, GFP_ATOMIC);\n\t\t\tdev_kfree_skb_any(ack_skb);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}