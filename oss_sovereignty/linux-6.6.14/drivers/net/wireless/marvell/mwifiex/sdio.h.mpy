{
  "module_name": "sdio.h",
  "hash_id": "e392833c214a8678f0179740a0e018f0b870bdd8376551ef96203d91a07bd62a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/sdio.h",
  "human_readable_source": " \n \n\n#ifndef\t_MWIFIEX_SDIO_H\n#define\t_MWIFIEX_SDIO_H\n\n\n#include <linux/completion.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n\n#include \"main.h\"\n\n#define SD8786_DEFAULT_FW_NAME \"mrvl/sd8786_uapsta.bin\"\n#define SD8787_DEFAULT_FW_NAME \"mrvl/sd8787_uapsta.bin\"\n#define SD8797_DEFAULT_FW_NAME \"mrvl/sd8797_uapsta.bin\"\n#define SD8897_DEFAULT_FW_NAME \"mrvl/sd8897_uapsta.bin\"\n#define SD8887_DEFAULT_FW_NAME \"mrvl/sd8887_uapsta.bin\"\n#define SD8801_DEFAULT_FW_NAME \"mrvl/sd8801_uapsta.bin\"\n#define SD8977_DEFAULT_FW_NAME \"mrvl/sdsd8977_combo_v2.bin\"\n#define SD8978_SDIOUART_FW_NAME \"mrvl/sdiouartiw416_combo_v0.bin\"\n#define SD8987_DEFAULT_FW_NAME \"mrvl/sd8987_uapsta.bin\"\n#define SD8997_DEFAULT_FW_NAME \"mrvl/sdsd8997_combo_v4.bin\"\n#define SD8997_SDIOUART_FW_NAME \"mrvl/sdiouart8997_combo_v4.bin\"\n\n#define BLOCK_MODE\t1\n#define BYTE_MODE\t0\n\n#define MWIFIEX_SDIO_IO_PORT_MASK\t\t0xfffff\n\n#define MWIFIEX_SDIO_BYTE_MODE_MASK\t0x80000000\n\n#define MWIFIEX_MAX_FUNC2_REG_NUM\t13\n#define MWIFIEX_SDIO_SCRATCH_SIZE\t10\n\n#define SDIO_MPA_ADDR_BASE\t\t0x1000\n#define CTRL_PORT\t\t\t0\n#define CTRL_PORT_MASK\t\t\t0x0001\n\n#define CMD_PORT_UPLD_INT_MASK\t\t(0x1U<<6)\n#define CMD_PORT_DNLD_INT_MASK\t\t(0x1U<<7)\n#define HOST_TERM_CMD53\t\t\t(0x1U << 2)\n#define REG_PORT\t\t\t0\n#define MEM_PORT\t\t\t0x10000\n\n#define CMD53_NEW_MODE\t\t\t(0x1U << 0)\n#define CMD_PORT_RD_LEN_EN\t\t(0x1U << 2)\n#define CMD_PORT_AUTO_EN\t\t(0x1U << 0)\n#define CMD_PORT_SLCT\t\t\t0x8000\n#define UP_LD_CMD_PORT_HOST_INT_STATUS\t(0x40U)\n#define DN_LD_CMD_PORT_HOST_INT_STATUS\t(0x80U)\n\n#define MWIFIEX_MP_AGGR_BUF_SIZE_16K\t(16384)\n#define MWIFIEX_MP_AGGR_BUF_SIZE_32K\t(32768)\n \n#define MWIFIEX_MP_AGGR_BUF_SIZE_MAX    (65280)\n\n \n#define AUTO_RE_ENABLE_INT              BIT(4)\n\n \n#define CONFIGURATION_REG\t\t0x00\n \n#define HOST_POWER_UP\t\t\t(0x1U << 1)\n\n \n#define UP_LD_HOST_INT_MASK\t\t(0x1U)\n \n#define DN_LD_HOST_INT_MASK\t\t(0x2U)\n\n \n#define UP_LD_HOST_INT_STATUS\t\t(0x1U)\n \n#define DN_LD_HOST_INT_STATUS\t\t(0x2U)\n\n \n#define CARD_INT_STATUS_REG\t\t0x28\n\n \n#define CARD_IO_READY                   (0x1U << 3)\n \n#define DN_LD_CARD_RDY                  (0x1U << 0)\n\n \n#define MAX_WRITE_IOMEM_RETRY\t\t2\n\n \n#define MP_TX_AGGR_IN_PROGRESS(a) (a->mpa_tx.pkt_cnt > 0)\n\n \n#define MP_TX_AGGR_BUF_HAS_ROOM(a, len) ((a->mpa_tx.buf_len+len)\t\\\n\t\t\t\t\t\t<= a->mpa_tx.buf_size)\n\n \n#define MP_TX_AGGR_BUF_PUT(a, payload, pkt_len, port) do {\t\t\\\n\tmemmove(&a->mpa_tx.buf[a->mpa_tx.buf_len],\t\t\t\\\n\t\t\tpayload, pkt_len);\t\t\t\t\\\n\ta->mpa_tx.buf_len += pkt_len;\t\t\t\t\t\\\n\tif (!a->mpa_tx.pkt_cnt)\t\t\t\t\t\t\\\n\t\ta->mpa_tx.start_port = port;\t\t\t\t\\\n\tif (a->mpa_tx.start_port <= port)\t\t\t\t\\\n\t\ta->mpa_tx.ports |= (1<<(a->mpa_tx.pkt_cnt));\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\ta->mpa_tx.ports |= (1<<(a->mpa_tx.pkt_cnt+1+\t\t\\\n\t\t\t\t\t\t(a->max_ports -\t\\\n\t\t\t\t\t\ta->mp_end_port)));\t\\\n\ta->mpa_tx.pkt_cnt++;\t\t\t\t\t\t\\\n} while (0)\n\n \n#define MP_TX_AGGR_PKT_LIMIT_REACHED(a)\t\t\t\t\t\\\n\t\t\t(a->mpa_tx.pkt_cnt == a->mpa_tx.pkt_aggr_limit)\n\n \n#define MP_TX_AGGR_BUF_RESET(a) do {\t\t\t\t\t\\\n\ta->mpa_tx.pkt_cnt = 0;\t\t\t\t\t\t\\\n\ta->mpa_tx.buf_len = 0;\t\t\t\t\t\t\\\n\ta->mpa_tx.ports = 0;\t\t\t\t\t\t\\\n\ta->mpa_tx.start_port = 0;\t\t\t\t\t\\\n} while (0)\n\n \n#define MP_RX_AGGR_PKT_LIMIT_REACHED(a)\t\t\t\t\t\\\n\t\t\t(a->mpa_rx.pkt_cnt == a->mpa_rx.pkt_aggr_limit)\n\n \n#define MP_RX_AGGR_IN_PROGRESS(a) (a->mpa_rx.pkt_cnt > 0)\n\n \n#define MP_RX_AGGR_BUF_HAS_ROOM(a, rx_len)\t\t\t\t\\\n\t\t\t((a->mpa_rx.buf_len+rx_len) <= a->mpa_rx.buf_size)\n\n \n#define MP_RX_AGGR_BUF_RESET(a) do {\t\t\t\t\t\\\n\ta->mpa_rx.pkt_cnt = 0;\t\t\t\t\t\t\\\n\ta->mpa_rx.buf_len = 0;\t\t\t\t\t\t\\\n\ta->mpa_rx.ports = 0;\t\t\t\t\t\t\\\n\ta->mpa_rx.start_port = 0;\t\t\t\t\t\\\n} while (0)\n\n \nstruct mwifiex_sdio_mpa_tx {\n\t \n\tu8 *buf;\n\tu32 buf_len;\n\tu32 pkt_cnt;\n\tu32 ports;\n\tu16 start_port;\n\tu8 enabled;\n\tu32 buf_size;\n\tu32 pkt_aggr_limit;\n};\n\nstruct mwifiex_sdio_mpa_rx {\n\tu8 *buf;\n\tu32 buf_len;\n\tu32 pkt_cnt;\n\tu32 ports;\n\tu16 start_port;\n\n\tstruct sk_buff **skb_arr;\n\tu32 *len_arr;\n\n\tu8 enabled;\n\tu32 buf_size;\n\tu32 pkt_aggr_limit;\n};\n\nint mwifiex_bus_register(void);\nvoid mwifiex_bus_unregister(void);\n\nstruct mwifiex_sdio_card_reg {\n\tu8 start_rd_port;\n\tu8 start_wr_port;\n\tu8 base_0_reg;\n\tu8 base_1_reg;\n\tu8 poll_reg;\n\tu8 host_int_enable;\n\tu8 host_int_rsr_reg;\n\tu8 host_int_status_reg;\n\tu8 host_int_mask_reg;\n\tu8 host_strap_reg;\n\tu8 host_strap_mask;\n\tu8 host_strap_value;\n\tu8 status_reg_0;\n\tu8 status_reg_1;\n\tu8 sdio_int_mask;\n\tu32 data_port_mask;\n\tu8 io_port_0_reg;\n\tu8 io_port_1_reg;\n\tu8 io_port_2_reg;\n\tu8 max_mp_regs;\n\tu8 rd_bitmap_l;\n\tu8 rd_bitmap_u;\n\tu8 rd_bitmap_1l;\n\tu8 rd_bitmap_1u;\n\tu8 wr_bitmap_l;\n\tu8 wr_bitmap_u;\n\tu8 wr_bitmap_1l;\n\tu8 wr_bitmap_1u;\n\tu8 rd_len_p0_l;\n\tu8 rd_len_p0_u;\n\tu8 card_misc_cfg_reg;\n\tu8 card_cfg_2_1_reg;\n\tu8 cmd_rd_len_0;\n\tu8 cmd_rd_len_1;\n\tu8 cmd_rd_len_2;\n\tu8 cmd_rd_len_3;\n\tu8 cmd_cfg_0;\n\tu8 cmd_cfg_1;\n\tu8 cmd_cfg_2;\n\tu8 cmd_cfg_3;\n\tu8 fw_dump_host_ready;\n\tu8 fw_dump_ctrl;\n\tu8 fw_dump_start;\n\tu8 fw_dump_end;\n\tu8 func1_dump_reg_start;\n\tu8 func1_dump_reg_end;\n\tu8 func1_scratch_reg;\n\tu8 func1_spec_reg_num;\n\tu8 func1_spec_reg_table[MWIFIEX_MAX_FUNC2_REG_NUM];\n};\n\nstruct sdio_mmc_card {\n\tstruct sdio_func *func;\n\tstruct mwifiex_adapter *adapter;\n\n\tstruct completion fw_done;\n\tconst char *firmware;\n\tconst char *firmware_sdiouart;\n\tconst struct mwifiex_sdio_card_reg *reg;\n\tu8 max_ports;\n\tu8 mp_agg_pkt_limit;\n\tu16 tx_buf_size;\n\tu32 mp_tx_agg_buf_size;\n\tu32 mp_rx_agg_buf_size;\n\n\tu32 mp_rd_bitmap;\n\tu32 mp_wr_bitmap;\n\n\tu16 mp_end_port;\n\tu32 mp_data_port_mask;\n\n\tu8 curr_rd_port;\n\tu8 curr_wr_port;\n\n\tu8 *mp_regs;\n\tbool supports_sdio_new_mode;\n\tbool has_control_mask;\n\tbool can_dump_fw;\n\tbool fw_dump_enh;\n\tbool can_auto_tdls;\n\tbool can_ext_scan;\n\tbool fw_ready_extra_delay;\n\n\tstruct mwifiex_sdio_mpa_tx mpa_tx;\n\tstruct mwifiex_sdio_mpa_rx mpa_rx;\n\n\tstruct work_struct work;\n\tunsigned long work_flags;\n};\n\nstruct mwifiex_sdio_device {\n\tconst char *firmware;\n\tconst char *firmware_sdiouart;\n\tconst struct mwifiex_sdio_card_reg *reg;\n\tu8 max_ports;\n\tu8 mp_agg_pkt_limit;\n\tu16 tx_buf_size;\n\tu32 mp_tx_agg_buf_size;\n\tu32 mp_rx_agg_buf_size;\n\tbool supports_sdio_new_mode;\n\tbool has_control_mask;\n\tbool can_dump_fw;\n\tbool fw_dump_enh;\n\tbool can_auto_tdls;\n\tbool can_ext_scan;\n\tbool fw_ready_extra_delay;\n};\n\n \nstatic inline int mwifiex_sdio_cmdrsp_complete(struct mwifiex_adapter *adapter,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tdev_kfree_skb_any(skb);\n\treturn 0;\n}\n\n \nstatic inline int mwifiex_sdio_event_complete(struct mwifiex_adapter *adapter,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tdev_kfree_skb_any(skb);\n\treturn 0;\n}\n\nstatic inline bool\nmp_rx_aggr_port_limit_reached(struct sdio_mmc_card *card)\n{\n\tu8 tmp;\n\n\tif (card->curr_rd_port < card->mpa_rx.start_port) {\n\t\tif (card->supports_sdio_new_mode)\n\t\t\ttmp = card->mp_end_port >> 1;\n\t\telse\n\t\t\ttmp = card->mp_agg_pkt_limit;\n\n\t\tif (((card->max_ports - card->mpa_rx.start_port) +\n\t\t    card->curr_rd_port) >= tmp)\n\t\t\treturn true;\n\t}\n\n\tif (!card->supports_sdio_new_mode)\n\t\treturn false;\n\n\tif ((card->curr_rd_port - card->mpa_rx.start_port) >=\n\t    (card->mp_end_port >> 1))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool\nmp_tx_aggr_port_limit_reached(struct sdio_mmc_card *card)\n{\n\tu16 tmp;\n\n\tif (card->curr_wr_port < card->mpa_tx.start_port) {\n\t\tif (card->supports_sdio_new_mode)\n\t\t\ttmp = card->mp_end_port >> 1;\n\t\telse\n\t\t\ttmp = card->mp_agg_pkt_limit;\n\n\t\tif (((card->max_ports - card->mpa_tx.start_port) +\n\t\t    card->curr_wr_port) >= tmp)\n\t\t\treturn true;\n\t}\n\n\tif (!card->supports_sdio_new_mode)\n\t\treturn false;\n\n\tif ((card->curr_wr_port - card->mpa_tx.start_port) >=\n\t    (card->mp_end_port >> 1))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic inline void mp_rx_aggr_setup(struct sdio_mmc_card *card,\n\t\t\t\t    u16 rx_len, u8 port)\n{\n\tcard->mpa_rx.buf_len += rx_len;\n\n\tif (!card->mpa_rx.pkt_cnt)\n\t\tcard->mpa_rx.start_port = port;\n\n\tif (card->supports_sdio_new_mode) {\n\t\tcard->mpa_rx.ports |= (1 << port);\n\t} else {\n\t\tif (card->mpa_rx.start_port <= port)\n\t\t\tcard->mpa_rx.ports |= 1 << (card->mpa_rx.pkt_cnt);\n\t\telse\n\t\t\tcard->mpa_rx.ports |= 1 << (card->mpa_rx.pkt_cnt + 1);\n\t}\n\tcard->mpa_rx.skb_arr[card->mpa_rx.pkt_cnt] = NULL;\n\tcard->mpa_rx.len_arr[card->mpa_rx.pkt_cnt] = rx_len;\n\tcard->mpa_rx.pkt_cnt++;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}