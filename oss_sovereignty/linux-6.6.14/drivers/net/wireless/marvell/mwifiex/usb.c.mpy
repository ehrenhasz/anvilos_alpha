{
  "module_name": "usb.c",
  "hash_id": "b23b133f04ed91883ad8988c009775e1f9302ed4a584a201598cb6a893741041",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/usb.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"usb.h\"\n\n#define USB_VERSION\t\"1.0\"\n\nstatic struct mwifiex_if_ops usb_ops;\n\nstatic const struct usb_device_id mwifiex_usb_table[] = {\n\t \n\t{USB_DEVICE(USB8XXX_VID, USB8766_PID_1)},\n\t{USB_DEVICE_AND_INTERFACE_INFO(USB8XXX_VID, USB8766_PID_2,\n\t\t\t\t       USB_CLASS_VENDOR_SPEC,\n\t\t\t\t       USB_SUBCLASS_VENDOR_SPEC, 0xff)},\n\t \n\t{USB_DEVICE(USB8XXX_VID, USB8797_PID_1)},\n\t{USB_DEVICE_AND_INTERFACE_INFO(USB8XXX_VID, USB8797_PID_2,\n\t\t\t\t       USB_CLASS_VENDOR_SPEC,\n\t\t\t\t       USB_SUBCLASS_VENDOR_SPEC, 0xff)},\n\t \n\t{USB_DEVICE(USB8XXX_VID, USB8801_PID_1)},\n\t{USB_DEVICE_AND_INTERFACE_INFO(USB8XXX_VID, USB8801_PID_2,\n\t\t\t\t       USB_CLASS_VENDOR_SPEC,\n\t\t\t\t       USB_SUBCLASS_VENDOR_SPEC, 0xff)},\n\t \n\t{USB_DEVICE(USB8XXX_VID, USB8997_PID_1)},\n\t{USB_DEVICE_AND_INTERFACE_INFO(USB8XXX_VID, USB8997_PID_2,\n\t\t\t\t       USB_CLASS_VENDOR_SPEC,\n\t\t\t\t       USB_SUBCLASS_VENDOR_SPEC, 0xff)},\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(usb, mwifiex_usb_table);\n\nstatic int mwifiex_usb_submit_rx_urb(struct urb_context *ctx, int size);\n\n \nstatic int mwifiex_usb_recv(struct mwifiex_adapter *adapter,\n\t\t\t    struct sk_buff *skb, u8 ep)\n{\n\tu32 recv_type;\n\t__le32 tmp;\n\tint ret;\n\n\tif (adapter->hs_activated)\n\t\tmwifiex_process_hs_config(adapter);\n\n\tif (skb->len < INTF_HEADER_LEN) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: invalid skb->len\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tswitch (ep) {\n\tcase MWIFIEX_USB_EP_CMD_EVENT:\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"%s: EP_CMD_EVENT\\n\", __func__);\n\t\tskb_copy_from_linear_data(skb, &tmp, INTF_HEADER_LEN);\n\t\trecv_type = le32_to_cpu(tmp);\n\t\tskb_pull(skb, INTF_HEADER_LEN);\n\n\t\tswitch (recv_type) {\n\t\tcase MWIFIEX_USB_TYPE_CMD:\n\t\t\tif (skb->len > MWIFIEX_SIZE_OF_CMD_BUFFER) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"CMD: skb->len too large\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto exit_restore_skb;\n\t\t\t} else if (!adapter->curr_cmd) {\n\t\t\t\tmwifiex_dbg(adapter, WARN, \"CMD: no curr_cmd\\n\");\n\t\t\t\tif (adapter->ps_state == PS_STATE_SLEEP_CFM) {\n\t\t\t\t\tmwifiex_process_sleep_confirm_resp(\n\t\t\t\t\t\t\tadapter, skb->data,\n\t\t\t\t\t\t\tskb->len);\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto exit_restore_skb;\n\t\t\t\t}\n\t\t\t\tret = -1;\n\t\t\t\tgoto exit_restore_skb;\n\t\t\t}\n\n\t\t\tadapter->curr_cmd->resp_skb = skb;\n\t\t\tadapter->cmd_resp_received = true;\n\t\t\tbreak;\n\t\tcase MWIFIEX_USB_TYPE_EVENT:\n\t\t\tif (skb->len < sizeof(u32)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"EVENT: skb->len too small\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto exit_restore_skb;\n\t\t\t}\n\t\t\tskb_copy_from_linear_data(skb, &tmp, sizeof(u32));\n\t\t\tadapter->event_cause = le32_to_cpu(tmp);\n\t\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t\t    \"event_cause %#x\\n\", adapter->event_cause);\n\n\t\t\tif (skb->len > MAX_EVENT_SIZE) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"EVENT: event body too large\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto exit_restore_skb;\n\t\t\t}\n\n\t\t\tmemcpy(adapter->event_body, skb->data +\n\t\t\t       MWIFIEX_EVENT_HEADER_LEN, skb->len);\n\n\t\t\tadapter->event_received = true;\n\t\t\tadapter->event_skb = skb;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"unknown recv_type %#x\\n\", recv_type);\n\t\t\tret = -1;\n\t\t\tgoto exit_restore_skb;\n\t\t}\n\t\tbreak;\n\tcase MWIFIEX_USB_EP_DATA:\n\t\tmwifiex_dbg(adapter, DATA, \"%s: EP_DATA\\n\", __func__);\n\t\tif (skb->len > MWIFIEX_RX_DATA_BUF_SIZE) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"DATA: skb->len too large\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tskb_queue_tail(&adapter->rx_data_q, skb);\n\t\tadapter->data_received = true;\n\t\tatomic_inc(&adapter->rx_pending);\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: unknown endport %#x\\n\", __func__, ep);\n\t\treturn -1;\n\t}\n\n\treturn -EINPROGRESS;\n\nexit_restore_skb:\n\t \n\tskb_push(skb, INTF_HEADER_LEN);\n\n\treturn ret;\n}\n\nstatic void mwifiex_usb_rx_complete(struct urb *urb)\n{\n\tstruct urb_context *context = (struct urb_context *)urb->context;\n\tstruct mwifiex_adapter *adapter = context->adapter;\n\tstruct sk_buff *skb = context->skb;\n\tstruct usb_card_rec *card;\n\tint recv_length = urb->actual_length;\n\tint size, status;\n\n\tif (!adapter || !adapter->card) {\n\t\tpr_err(\"mwifiex adapter or card structure is not valid\\n\");\n\t\treturn;\n\t}\n\n\tcard = (struct usb_card_rec *)adapter->card;\n\tif (card->rx_cmd_ep == context->ep)\n\t\tatomic_dec(&card->rx_cmd_urb_pending);\n\telse\n\t\tatomic_dec(&card->rx_data_urb_pending);\n\n\tif (recv_length) {\n\t\tif (urb->status ||\n\t\t    test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"URB status is failed: %d\\n\", urb->status);\n\t\t\t \n\t\t\tif (card->rx_cmd_ep != context->ep)\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\tgoto setup_for_next;\n\t\t}\n\t\tif (skb->len > recv_length)\n\t\t\tskb_trim(skb, recv_length);\n\t\telse\n\t\t\tskb_put(skb, recv_length - skb->len);\n\n\t\tstatus = mwifiex_usb_recv(adapter, skb, context->ep);\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: recv_length=%d, status=%d\\n\",\n\t\t\t    recv_length, status);\n\t\tif (status == -EINPROGRESS) {\n\t\t\tmwifiex_queue_main_work(adapter);\n\n\t\t\t \n\t\t\tif (card->rx_cmd_ep == context->ep)\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tif (status == -1)\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"received data processing failed!\\n\");\n\n\t\t\t \n\t\t\tif (card->rx_cmd_ep != context->ep)\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t} else if (urb->status) {\n\t\tif (!test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\n\t\t\tmwifiex_dbg(adapter, FATAL,\n\t\t\t\t    \"Card is removed: %d\\n\", urb->status);\n\t\t\tset_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags);\n\t\t}\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t} else {\n\t\t \n\t\tif (card->rx_cmd_ep != context->ep)\n\t\t\tdev_kfree_skb_any(skb);\n\n\t\t \n\t}\n\nsetup_for_next:\n\tif (card->rx_cmd_ep == context->ep)\n\t\tsize = MWIFIEX_RX_CMD_BUF_SIZE;\n\telse\n\t\tsize = MWIFIEX_RX_DATA_BUF_SIZE;\n\n\tif (card->rx_cmd_ep == context->ep) {\n\t\tmwifiex_usb_submit_rx_urb(context, size);\n\t} else {\n\t\tif (atomic_read(&adapter->rx_pending) <= HIGH_RX_PENDING) {\n\t\t\tmwifiex_usb_submit_rx_urb(context, size);\n\t\t} else {\n\t\t\tcontext->skb = NULL;\n\t\t}\n\t}\n\n\treturn;\n}\n\nstatic void mwifiex_usb_tx_complete(struct urb *urb)\n{\n\tstruct urb_context *context = (struct urb_context *)(urb->context);\n\tstruct mwifiex_adapter *adapter = context->adapter;\n\tstruct usb_card_rec *card = adapter->card;\n\tstruct usb_tx_data_port *port;\n\tint i;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"%s: status: %d\\n\", __func__, urb->status);\n\n\tif (context->ep == card->tx_cmd_ep) {\n\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t    \"%s: CMD\\n\", __func__);\n\t\tatomic_dec(&card->tx_cmd_urb_pending);\n\t\tadapter->cmd_sent = false;\n\t} else {\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"%s: DATA\\n\", __func__);\n\t\tmwifiex_write_data_complete(adapter, context->skb, 0,\n\t\t\t\t\t    urb->status ? -1 : 0);\n\t\tfor (i = 0; i < MWIFIEX_TX_DATA_PORT; i++) {\n\t\t\tport = &card->port[i];\n\t\t\tif (context->ep == port->tx_data_ep) {\n\t\t\t\tatomic_dec(&port->tx_data_urb_pending);\n\t\t\t\tport->block_status = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tadapter->data_sent = false;\n\t}\n\n\tif (card->mc_resync_flag)\n\t\tmwifiex_multi_chan_resync(adapter);\n\n\tmwifiex_queue_main_work(adapter);\n\n\treturn;\n}\n\nstatic int mwifiex_usb_submit_rx_urb(struct urb_context *ctx, int size)\n{\n\tstruct mwifiex_adapter *adapter = ctx->adapter;\n\tstruct usb_card_rec *card = (struct usb_card_rec *)adapter->card;\n\n\tif (test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\n\t\tif (card->rx_cmd_ep == ctx->ep) {\n\t\t\tmwifiex_dbg(adapter, INFO, \"%s: free rx_cmd skb\\n\",\n\t\t\t\t    __func__);\n\t\t\tdev_kfree_skb_any(ctx->skb);\n\t\t\tctx->skb = NULL;\n\t\t}\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: card removed/suspended, EP %d rx_cmd URB submit skipped\\n\",\n\t\t\t    __func__, ctx->ep);\n\t\treturn -1;\n\t}\n\n\tif (card->rx_cmd_ep != ctx->ep) {\n\t\tctx->skb = dev_alloc_skb(size);\n\t\tif (!ctx->skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"%s: dev_alloc_skb failed\\n\", __func__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (card->rx_cmd_ep == ctx->ep &&\n\t    card->rx_cmd_ep_type == USB_ENDPOINT_XFER_INT)\n\t\tusb_fill_int_urb(ctx->urb, card->udev,\n\t\t\t\t usb_rcvintpipe(card->udev, ctx->ep),\n\t\t\t\t ctx->skb->data, size, mwifiex_usb_rx_complete,\n\t\t\t\t (void *)ctx, card->rx_cmd_interval);\n\telse\n\t\tusb_fill_bulk_urb(ctx->urb, card->udev,\n\t\t\t\t  usb_rcvbulkpipe(card->udev, ctx->ep),\n\t\t\t\t  ctx->skb->data, size, mwifiex_usb_rx_complete,\n\t\t\t\t  (void *)ctx);\n\n\tif (card->rx_cmd_ep == ctx->ep)\n\t\tatomic_inc(&card->rx_cmd_urb_pending);\n\telse\n\t\tatomic_inc(&card->rx_data_urb_pending);\n\n\tif (usb_submit_urb(ctx->urb, GFP_ATOMIC)) {\n\t\tmwifiex_dbg(adapter, ERROR, \"usb_submit_urb failed\\n\");\n\t\tdev_kfree_skb_any(ctx->skb);\n\t\tctx->skb = NULL;\n\n\t\tif (card->rx_cmd_ep == ctx->ep)\n\t\t\tatomic_dec(&card->rx_cmd_urb_pending);\n\t\telse\n\t\t\tatomic_dec(&card->rx_data_urb_pending);\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void mwifiex_usb_free(struct usb_card_rec *card)\n{\n\tstruct usb_tx_data_port *port;\n\tint i, j;\n\n\tif (atomic_read(&card->rx_cmd_urb_pending) && card->rx_cmd.urb)\n\t\tusb_kill_urb(card->rx_cmd.urb);\n\n\tusb_free_urb(card->rx_cmd.urb);\n\tcard->rx_cmd.urb = NULL;\n\n\tif (atomic_read(&card->rx_data_urb_pending))\n\t\tfor (i = 0; i < MWIFIEX_RX_DATA_URB; i++)\n\t\t\tif (card->rx_data_list[i].urb)\n\t\t\t\tusb_kill_urb(card->rx_data_list[i].urb);\n\n\tfor (i = 0; i < MWIFIEX_RX_DATA_URB; i++) {\n\t\tusb_free_urb(card->rx_data_list[i].urb);\n\t\tcard->rx_data_list[i].urb = NULL;\n\t}\n\n\tfor (i = 0; i < MWIFIEX_TX_DATA_PORT; i++) {\n\t\tport = &card->port[i];\n\t\tfor (j = 0; j < MWIFIEX_TX_DATA_URB; j++) {\n\t\t\tusb_kill_urb(port->tx_data_list[j].urb);\n\t\t\tusb_free_urb(port->tx_data_list[j].urb);\n\t\t\tport->tx_data_list[j].urb = NULL;\n\t\t}\n\t}\n\n\tusb_free_urb(card->tx_cmd.urb);\n\tcard->tx_cmd.urb = NULL;\n\n\treturn;\n}\n\n \nstatic int mwifiex_usb_probe(struct usb_interface *intf,\n\t\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_host_interface *iface_desc = intf->cur_altsetting;\n\tstruct usb_endpoint_descriptor *epd;\n\tint ret, i;\n\tstruct usb_card_rec *card;\n\tu16 id_vendor, id_product, bcd_device;\n\n\tcard = devm_kzalloc(&intf->dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&card->fw_done);\n\n\tid_vendor = le16_to_cpu(udev->descriptor.idVendor);\n\tid_product = le16_to_cpu(udev->descriptor.idProduct);\n\tbcd_device = le16_to_cpu(udev->descriptor.bcdDevice);\n\tpr_debug(\"info: VID/PID = %X/%X, Boot2 version = %X\\n\",\n\t\t id_vendor, id_product, bcd_device);\n\n\t \n\tswitch (id_product) {\n\tcase USB8766_PID_1:\n\tcase USB8797_PID_1:\n\tcase USB8801_PID_1:\n\tcase USB8997_PID_1:\n\t\tcard->usb_boot_state = USB8XXX_FW_DNLD;\n\t\tbreak;\n\tcase USB8766_PID_2:\n\tcase USB8797_PID_2:\n\tcase USB8801_PID_2:\n\tcase USB8997_PID_2:\n\t\tcard->usb_boot_state = USB8XXX_FW_READY;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"unknown id_product %#x\\n\", id_product);\n\t\tcard->usb_boot_state = USB8XXX_FW_DNLD;\n\t\tbreak;\n\t}\n\n\tcard->udev = udev;\n\tcard->intf = intf;\n\n\tpr_debug(\"info: bcdUSB=%#x Device Class=%#x SubClass=%#x Protocol=%#x\\n\",\n\t\t le16_to_cpu(udev->descriptor.bcdUSB),\n\t\t udev->descriptor.bDeviceClass,\n\t\t udev->descriptor.bDeviceSubClass,\n\t\t udev->descriptor.bDeviceProtocol);\n\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tepd = &iface_desc->endpoint[i].desc;\n\t\tif (usb_endpoint_dir_in(epd) &&\n\t\t    usb_endpoint_num(epd) == MWIFIEX_USB_EP_CMD_EVENT &&\n\t\t    (usb_endpoint_xfer_bulk(epd) ||\n\t\t     usb_endpoint_xfer_int(epd))) {\n\t\t\tcard->rx_cmd_ep_type = usb_endpoint_type(epd);\n\t\t\tcard->rx_cmd_interval = epd->bInterval;\n\t\t\tpr_debug(\"info: Rx CMD/EVT:: max pkt size: %d, addr: %d, ep_type: %d\\n\",\n\t\t\t\t le16_to_cpu(epd->wMaxPacketSize),\n\t\t\t\t epd->bEndpointAddress, card->rx_cmd_ep_type);\n\t\t\tcard->rx_cmd_ep = usb_endpoint_num(epd);\n\t\t\tatomic_set(&card->rx_cmd_urb_pending, 0);\n\t\t}\n\t\tif (usb_endpoint_dir_in(epd) &&\n\t\t    usb_endpoint_num(epd) == MWIFIEX_USB_EP_DATA &&\n\t\t    usb_endpoint_xfer_bulk(epd)) {\n\t\t\tpr_debug(\"info: bulk IN: max pkt size: %d, addr: %d\\n\",\n\t\t\t\t le16_to_cpu(epd->wMaxPacketSize),\n\t\t\t\t epd->bEndpointAddress);\n\t\t\tcard->rx_data_ep = usb_endpoint_num(epd);\n\t\t\tatomic_set(&card->rx_data_urb_pending, 0);\n\t\t}\n\t\tif (usb_endpoint_dir_out(epd) &&\n\t\t    usb_endpoint_num(epd) == MWIFIEX_USB_EP_DATA &&\n\t\t    usb_endpoint_xfer_bulk(epd)) {\n\t\t\tpr_debug(\"info: bulk OUT: max pkt size: %d, addr: %d\\n\",\n\t\t\t\t le16_to_cpu(epd->wMaxPacketSize),\n\t\t\t\t epd->bEndpointAddress);\n\t\t\tcard->port[0].tx_data_ep = usb_endpoint_num(epd);\n\t\t\tatomic_set(&card->port[0].tx_data_urb_pending, 0);\n\t\t}\n\t\tif (usb_endpoint_dir_out(epd) &&\n\t\t    usb_endpoint_num(epd) == MWIFIEX_USB_EP_DATA_CH2 &&\n\t\t    usb_endpoint_xfer_bulk(epd)) {\n\t\t\tpr_debug(\"info: bulk OUT chan2:\\t\"\n\t\t\t\t \"max pkt size: %d, addr: %d\\n\",\n\t\t\t\t le16_to_cpu(epd->wMaxPacketSize),\n\t\t\t\t epd->bEndpointAddress);\n\t\t\tcard->port[1].tx_data_ep = usb_endpoint_num(epd);\n\t\t\tatomic_set(&card->port[1].tx_data_urb_pending, 0);\n\t\t}\n\t\tif (usb_endpoint_dir_out(epd) &&\n\t\t    usb_endpoint_num(epd) == MWIFIEX_USB_EP_CMD_EVENT &&\n\t\t    (usb_endpoint_xfer_bulk(epd) ||\n\t\t     usb_endpoint_xfer_int(epd))) {\n\t\t\tcard->tx_cmd_ep_type = usb_endpoint_type(epd);\n\t\t\tcard->tx_cmd_interval = epd->bInterval;\n\t\t\tpr_debug(\"info: bulk OUT: max pkt size: %d, addr: %d\\n\",\n\t\t\t\t le16_to_cpu(epd->wMaxPacketSize),\n\t\t\t\t epd->bEndpointAddress);\n\t\t\tpr_debug(\"info: Tx CMD:: max pkt size: %d, addr: %d, ep_type: %d\\n\",\n\t\t\t\t le16_to_cpu(epd->wMaxPacketSize),\n\t\t\t\t epd->bEndpointAddress, card->tx_cmd_ep_type);\n\t\t\tcard->tx_cmd_ep = usb_endpoint_num(epd);\n\t\t\tatomic_set(&card->tx_cmd_urb_pending, 0);\n\t\t\tcard->bulk_out_maxpktsize =\n\t\t\t\t\tle16_to_cpu(epd->wMaxPacketSize);\n\t\t}\n\t}\n\n\tswitch (card->usb_boot_state) {\n\tcase USB8XXX_FW_DNLD:\n\t\t \n\t\tif (!card->rx_cmd_ep || !card->tx_cmd_ep)\n\t\t\treturn -ENODEV;\n\t\tif (card->bulk_out_maxpktsize == 0)\n\t\t\treturn -ENODEV;\n\t\tbreak;\n\tcase USB8XXX_FW_READY:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENODEV;\n\t}\n\n\tusb_set_intfdata(intf, card);\n\n\tret = mwifiex_add_card(card, &card->fw_done, &usb_ops,\n\t\t\t       MWIFIEX_USB, &card->udev->dev);\n\tif (ret) {\n\t\tpr_err(\"%s: mwifiex_add_card failed: %d\\n\", __func__, ret);\n\t\tusb_reset_device(udev);\n\t\treturn ret;\n\t}\n\n\tusb_get_dev(udev);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_usb_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usb_card_rec *card = usb_get_intfdata(intf);\n\tstruct mwifiex_adapter *adapter;\n\tstruct usb_tx_data_port *port;\n\tint i, j;\n\n\t \n\twait_for_completion(&card->fw_done);\n\n\tadapter = card->adapter;\n\tif (!adapter) {\n\t\tdev_err(&intf->dev, \"card is not valid\\n\");\n\t\treturn 0;\n\t}\n\n\tif (unlikely(test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)))\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"Device already suspended\\n\");\n\n\t \n\tif (!mwifiex_enable_hs(adapter)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"cmd: failed to suspend\\n\");\n\t\tclear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);\n\t\treturn -EFAULT;\n\t}\n\n\n\t \n\tset_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);\n\tclear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);\n\n\tif (atomic_read(&card->rx_cmd_urb_pending) && card->rx_cmd.urb)\n\t\tusb_kill_urb(card->rx_cmd.urb);\n\n\tif (atomic_read(&card->rx_data_urb_pending))\n\t\tfor (i = 0; i < MWIFIEX_RX_DATA_URB; i++)\n\t\t\tif (card->rx_data_list[i].urb)\n\t\t\t\tusb_kill_urb(card->rx_data_list[i].urb);\n\n\tfor (i = 0; i < MWIFIEX_TX_DATA_PORT; i++) {\n\t\tport = &card->port[i];\n\t\tfor (j = 0; j < MWIFIEX_TX_DATA_URB; j++) {\n\t\t\tif (port->tx_data_list[j].urb)\n\t\t\t\tusb_kill_urb(port->tx_data_list[j].urb);\n\t\t}\n\t}\n\n\tif (card->tx_cmd.urb)\n\t\tusb_kill_urb(card->tx_cmd.urb);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_usb_resume(struct usb_interface *intf)\n{\n\tstruct usb_card_rec *card = usb_get_intfdata(intf);\n\tstruct mwifiex_adapter *adapter;\n\tint i;\n\n\tif (!card->adapter) {\n\t\tdev_err(&intf->dev, \"%s: card->adapter is NULL\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\tadapter = card->adapter;\n\n\tif (unlikely(!test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags))) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"Device already resumed\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tclear_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);\n\n\tif (!atomic_read(&card->rx_data_urb_pending))\n\t\tfor (i = 0; i < MWIFIEX_RX_DATA_URB; i++)\n\t\t\tmwifiex_usb_submit_rx_urb(&card->rx_data_list[i],\n\t\t\t\t\t\t  MWIFIEX_RX_DATA_BUF_SIZE);\n\n\tif (!atomic_read(&card->rx_cmd_urb_pending)) {\n\t\tcard->rx_cmd.skb = dev_alloc_skb(MWIFIEX_RX_CMD_BUF_SIZE);\n\t\tif (card->rx_cmd.skb)\n\t\t\tmwifiex_usb_submit_rx_urb(&card->rx_cmd,\n\t\t\t\t\t\t  MWIFIEX_RX_CMD_BUF_SIZE);\n\t}\n\n\t \n\tif (adapter->hs_activated)\n\t\tmwifiex_cancel_hs(mwifiex_get_priv(adapter,\n\t\t\t\t\t\t   MWIFIEX_BSS_ROLE_ANY),\n\t\t\t\t  MWIFIEX_ASYNC_CMD);\n\n\treturn 0;\n}\n\nstatic void mwifiex_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_card_rec *card = usb_get_intfdata(intf);\n\tstruct mwifiex_adapter *adapter;\n\n\twait_for_completion(&card->fw_done);\n\n\tadapter = card->adapter;\n\tif (!adapter || !adapter->priv_num)\n\t\treturn;\n\n\tif (card->udev->state != USB_STATE_NOTATTACHED && !adapter->mfg_mode) {\n\t\tmwifiex_deauthenticate_all(adapter);\n\n\t\tmwifiex_init_shutdown_fw(mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\t  MWIFIEX_BSS_ROLE_ANY),\n\t\t\t\t\t MWIFIEX_FUNC_SHUTDOWN);\n\t}\n\n\tmwifiex_dbg(adapter, FATAL,\n\t\t    \"%s: removing card\\n\", __func__);\n\tmwifiex_remove_card(adapter);\n\n\tusb_put_dev(interface_to_usbdev(intf));\n}\n\nstatic void mwifiex_usb_coredump(struct device *dev)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_card_rec *card = usb_get_intfdata(intf);\n\n\tmwifiex_fw_dump_event(mwifiex_get_priv(card->adapter,\n\t\t\t\t\t       MWIFIEX_BSS_ROLE_ANY));\n}\n\nstatic struct usb_driver mwifiex_usb_driver = {\n\t.name = \"mwifiex_usb\",\n\t.probe = mwifiex_usb_probe,\n\t.disconnect = mwifiex_usb_disconnect,\n\t.id_table = mwifiex_usb_table,\n\t.suspend = mwifiex_usb_suspend,\n\t.resume = mwifiex_usb_resume,\n\t.soft_unbind = 1,\n\t.drvwrap.driver = {\n\t\t.coredump = mwifiex_usb_coredump,\n\t},\n};\n\nstatic int mwifiex_write_data_sync(struct mwifiex_adapter *adapter, u8 *pbuf,\n\t\t\t\t   u32 *len, u8 ep, u32 timeout)\n{\n\tstruct usb_card_rec *card = adapter->card;\n\tint actual_length, ret;\n\n\tif (!(*len % card->bulk_out_maxpktsize))\n\t\t(*len)++;\n\n\t \n\tret = usb_bulk_msg(card->udev, usb_sndbulkpipe(card->udev, ep), pbuf,\n\t\t\t   *len, &actual_length, timeout);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"usb_bulk_msg for tx failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*len = actual_length;\n\n\treturn ret;\n}\n\nstatic int mwifiex_read_data_sync(struct mwifiex_adapter *adapter, u8 *pbuf,\n\t\t\t\t  u32 *len, u8 ep, u32 timeout)\n{\n\tstruct usb_card_rec *card = adapter->card;\n\tint actual_length, ret;\n\n\t \n\tret = usb_bulk_msg(card->udev, usb_rcvbulkpipe(card->udev, ep), pbuf,\n\t\t\t   *len, &actual_length, timeout);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"usb_bulk_msg for rx failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*len = actual_length;\n\n\treturn ret;\n}\n\nstatic void mwifiex_usb_port_resync(struct mwifiex_adapter *adapter)\n{\n\tstruct usb_card_rec *card = adapter->card;\n\tu8 active_port = MWIFIEX_USB_EP_DATA;\n\tstruct mwifiex_private *priv = NULL;\n\tint i;\n\n\tif (adapter->usb_mc_status) {\n\t\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\t\tpriv = adapter->priv[i];\n\t\t\tif (!priv)\n\t\t\t\tcontinue;\n\t\t\tif ((priv->bss_role == MWIFIEX_BSS_ROLE_UAP &&\n\t\t\t     !priv->bss_started) ||\n\t\t\t    (priv->bss_role == MWIFIEX_BSS_ROLE_STA &&\n\t\t\t     !priv->media_connected))\n\t\t\t\tpriv->usb_port = MWIFIEX_USB_EP_DATA;\n\t\t}\n\t\tfor (i = 0; i < MWIFIEX_TX_DATA_PORT; i++)\n\t\t\tcard->port[i].block_status = false;\n\t} else {\n\t\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\t\tpriv = adapter->priv[i];\n\t\t\tif (!priv)\n\t\t\t\tcontinue;\n\t\t\tif ((priv->bss_role == MWIFIEX_BSS_ROLE_UAP &&\n\t\t\t     priv->bss_started) ||\n\t\t\t    (priv->bss_role == MWIFIEX_BSS_ROLE_STA &&\n\t\t\t     priv->media_connected)) {\n\t\t\t\tactive_port = priv->usb_port;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\t\tpriv = adapter->priv[i];\n\t\t\tif (priv)\n\t\t\t\tpriv->usb_port = active_port;\n\t\t}\n\t\tfor (i = 0; i < MWIFIEX_TX_DATA_PORT; i++) {\n\t\t\tif (active_port == card->port[i].tx_data_ep)\n\t\t\t\tcard->port[i].block_status = false;\n\t\t\telse\n\t\t\t\tcard->port[i].block_status = true;\n\t\t}\n\t}\n}\n\nstatic bool mwifiex_usb_is_port_ready(struct mwifiex_private *priv)\n{\n\tstruct usb_card_rec *card = priv->adapter->card;\n\tint idx;\n\n\tfor (idx = 0; idx < MWIFIEX_TX_DATA_PORT; idx++) {\n\t\tif (priv->usb_port == card->port[idx].tx_data_ep)\n\t\t\treturn !card->port[idx].block_status;\n\t}\n\n\treturn false;\n}\n\nstatic inline u8 mwifiex_usb_data_sent(struct mwifiex_adapter *adapter)\n{\n\tstruct usb_card_rec *card = adapter->card;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_TX_DATA_PORT; i++)\n\t\tif (!card->port[i].block_status)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic int mwifiex_usb_construct_send_urb(struct mwifiex_adapter *adapter,\n\t\t\t\t\t  struct usb_tx_data_port *port, u8 ep,\n\t\t\t\t\t  struct urb_context *context,\n\t\t\t\t\t  struct sk_buff *skb_send)\n{\n\tstruct usb_card_rec *card = adapter->card;\n\tint ret = -EINPROGRESS;\n\tstruct urb *tx_urb;\n\n\tcontext->adapter = adapter;\n\tcontext->ep = ep;\n\tcontext->skb = skb_send;\n\ttx_urb = context->urb;\n\n\tif (ep == card->tx_cmd_ep &&\n\t    card->tx_cmd_ep_type == USB_ENDPOINT_XFER_INT)\n\t\tusb_fill_int_urb(tx_urb, card->udev,\n\t\t\t\t usb_sndintpipe(card->udev, ep), skb_send->data,\n\t\t\t\t skb_send->len, mwifiex_usb_tx_complete,\n\t\t\t\t (void *)context, card->tx_cmd_interval);\n\telse\n\t\tusb_fill_bulk_urb(tx_urb, card->udev,\n\t\t\t\t  usb_sndbulkpipe(card->udev, ep),\n\t\t\t\t  skb_send->data, skb_send->len,\n\t\t\t\t  mwifiex_usb_tx_complete, (void *)context);\n\n\ttx_urb->transfer_flags |= URB_ZERO_PACKET;\n\n\tif (ep == card->tx_cmd_ep)\n\t\tatomic_inc(&card->tx_cmd_urb_pending);\n\telse\n\t\tatomic_inc(&port->tx_data_urb_pending);\n\n\tif (ep != card->tx_cmd_ep &&\n\t    atomic_read(&port->tx_data_urb_pending) ==\n\t\t\t\t\tMWIFIEX_TX_DATA_URB) {\n\t\tport->block_status = true;\n\t\tadapter->data_sent = mwifiex_usb_data_sent(adapter);\n\t\tret = -ENOSR;\n\t}\n\n\tif (usb_submit_urb(tx_urb, GFP_ATOMIC)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: usb_submit_urb failed\\n\", __func__);\n\t\tif (ep == card->tx_cmd_ep) {\n\t\t\tatomic_dec(&card->tx_cmd_urb_pending);\n\t\t} else {\n\t\t\tatomic_dec(&port->tx_data_urb_pending);\n\t\t\tport->block_status = false;\n\t\t\tadapter->data_sent = false;\n\t\t\tif (port->tx_data_ix)\n\t\t\t\tport->tx_data_ix--;\n\t\t\telse\n\t\t\t\tport->tx_data_ix = MWIFIEX_TX_DATA_URB;\n\t\t}\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}\n\nstatic int mwifiex_usb_prepare_tx_aggr_skb(struct mwifiex_adapter *adapter,\n\t\t\t\t\t   struct usb_tx_data_port *port,\n\t\t\t\t\t   struct sk_buff **skb_send)\n{\n\tstruct sk_buff *skb_aggr, *skb_tmp;\n\tu8 *payload, pad;\n\tu16 align = adapter->bus_aggr.tx_aggr_align;\n\tstruct mwifiex_txinfo *tx_info = NULL;\n\tbool is_txinfo_set = false;\n\n\t \n\tif (port->tx_aggr.timer_cnxt.is_hold_timer_set) {\n\t\tdel_timer(&port->tx_aggr.timer_cnxt.hold_timer);\n\t\tport->tx_aggr.timer_cnxt.is_hold_timer_set = false;\n\t\tport->tx_aggr.timer_cnxt.hold_tmo_msecs = 0;\n\t}\n\n\tskb_aggr = mwifiex_alloc_dma_align_buf(port->tx_aggr.aggr_len,\n\t\t\t\t\t       GFP_ATOMIC);\n\tif (!skb_aggr) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: alloc skb_aggr failed\\n\", __func__);\n\n\t\twhile ((skb_tmp = skb_dequeue(&port->tx_aggr.aggr_list)))\n\t\t\tmwifiex_write_data_complete(adapter, skb_tmp, 0, -1);\n\n\t\tport->tx_aggr.aggr_num = 0;\n\t\tport->tx_aggr.aggr_len = 0;\n\t\treturn -EBUSY;\n\t}\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb_aggr);\n\tmemset(tx_info, 0, sizeof(*tx_info));\n\n\twhile ((skb_tmp = skb_dequeue(&port->tx_aggr.aggr_list))) {\n\t\t \n\t\tpad = (align - (skb_tmp->len & (align - 1))) % align;\n\t\tpayload = skb_put(skb_aggr, skb_tmp->len + pad);\n\t\tmemcpy(payload, skb_tmp->data, skb_tmp->len);\n\t\tif (skb_queue_empty(&port->tx_aggr.aggr_list)) {\n\t\t\t \n\t\t\t*(__le16 *)payload = cpu_to_le16(skb_tmp->len);\n\t\t\t*(__le16 *)&payload[2] =\n\t\t\t\tcpu_to_le16(MWIFIEX_TYPE_AGGR_DATA_V2 | 0x80);\n\t\t\tskb_trim(skb_aggr, skb_aggr->len - pad);\n\t\t} else {\n\t\t\t \n\t\t\t*(__le16 *)payload = cpu_to_le16(skb_tmp->len + pad);\n\t\t\t*(__le16 *)&payload[2] =\n\t\t\t\tcpu_to_le16(MWIFIEX_TYPE_AGGR_DATA_V2);\n\t\t}\n\n\t\tif (!is_txinfo_set) {\n\t\t\ttx_info->bss_num = MWIFIEX_SKB_TXCB(skb_tmp)->bss_num;\n\t\t\ttx_info->bss_type = MWIFIEX_SKB_TXCB(skb_tmp)->bss_type;\n\t\t\tis_txinfo_set = true;\n\t\t}\n\n\t\tport->tx_aggr.aggr_num--;\n\t\tport->tx_aggr.aggr_len -= (skb_tmp->len + pad);\n\t\tmwifiex_write_data_complete(adapter, skb_tmp, 0, 0);\n\t}\n\n\ttx_info->pkt_len = skb_aggr->len -\n\t\t\t(sizeof(struct txpd) + adapter->intf_hdr_len);\n\ttx_info->flags |= MWIFIEX_BUF_FLAG_AGGR_PKT;\n\n\tport->tx_aggr.aggr_num = 0;\n\tport->tx_aggr.aggr_len = 0;\n\t*skb_send = skb_aggr;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_usb_aggr_tx_data(struct mwifiex_adapter *adapter, u8 ep,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct mwifiex_tx_param *tx_param,\n\t\t\t\t    struct usb_tx_data_port *port)\n{\n\tu8 *payload, pad;\n\tu16 align = adapter->bus_aggr.tx_aggr_align;\n\tstruct sk_buff *skb_send = NULL;\n\tstruct urb_context *context = NULL;\n\tstruct txpd *local_tx_pd =\n\t\t(struct txpd *)((u8 *)skb->data + adapter->intf_hdr_len);\n\tu8 f_send_aggr_buf = 0;\n\tu8 f_send_cur_buf = 0;\n\tu8 f_precopy_cur_buf = 0;\n\tu8 f_postcopy_cur_buf = 0;\n\tu32 timeout;\n\tint ret;\n\n\t \n\tpad = (align - (skb->len & (align - 1))) % align;\n\n\tif (tx_param && tx_param->next_pkt_len) {\n\t\t \n\t\tif (port->tx_aggr.aggr_len + skb->len + pad >\n\t\t    adapter->bus_aggr.tx_aggr_max_size) {\n\t\t\tf_send_aggr_buf = 1;\n\t\t\tf_postcopy_cur_buf = 1;\n\t\t} else {\n\t\t\t \n\t\t\tf_precopy_cur_buf = 1;\n\n\t\t\tif (port->tx_aggr.aggr_len + skb->len + pad +\n\t\t\t    tx_param->next_pkt_len >\n\t\t\t    adapter->bus_aggr.tx_aggr_max_size ||\n\t\t\t    port->tx_aggr.aggr_num + 2 >\n\t\t\t    adapter->bus_aggr.tx_aggr_max_num) {\n\t\t\t     \n\t\t\t\tf_send_aggr_buf = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (port->tx_aggr.aggr_num > 0) {\n\t\t\t \n\t\t\tif (port->tx_aggr.aggr_len + skb->len + pad >\n\t\t\t    adapter->bus_aggr.tx_aggr_max_size) {\n\t\t\t\t \n\t\t\t\tf_send_cur_buf = 1;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tf_precopy_cur_buf = 1;\n\t\t\t}\n\n\t\t\tf_send_aggr_buf = 1;\n\t\t} else {\n\t\t\t \n\t\t\t f_send_cur_buf = 1;\n\t\t}\n\t}\n\n\tif (local_tx_pd->flags & MWIFIEX_TxPD_POWER_MGMT_NULL_PACKET) {\n\t\t \n\t\tif (f_precopy_cur_buf) {\n\t\t\tif (skb_queue_empty(&port->tx_aggr.aggr_list)) {\n\t\t\t\tf_precopy_cur_buf = 0;\n\t\t\t\tf_send_aggr_buf = 0;\n\t\t\t\tf_send_cur_buf = 1;\n\t\t\t} else {\n\t\t\t\tf_send_aggr_buf = 1;\n\t\t\t}\n\t\t} else if (f_postcopy_cur_buf) {\n\t\t\tf_send_cur_buf = 1;\n\t\t\tf_postcopy_cur_buf = 0;\n\t\t}\n\t}\n\n\tif (f_precopy_cur_buf) {\n\t\tskb_queue_tail(&port->tx_aggr.aggr_list, skb);\n\t\tport->tx_aggr.aggr_len += (skb->len + pad);\n\t\tport->tx_aggr.aggr_num++;\n\t\tif (f_send_aggr_buf)\n\t\t\tgoto send_aggr_buf;\n\n\t\t \n\t\tif (!port->tx_aggr.timer_cnxt.is_hold_timer_set) {\n\t\t\tport->tx_aggr.timer_cnxt.hold_tmo_msecs =\n\t\t\t\t\tMWIFIEX_USB_TX_AGGR_TMO_MIN;\n\t\t\ttimeout =\n\t\t\t\tport->tx_aggr.timer_cnxt.hold_tmo_msecs;\n\t\t\tmod_timer(&port->tx_aggr.timer_cnxt.hold_timer,\n\t\t\t\t  jiffies + msecs_to_jiffies(timeout));\n\t\t\tport->tx_aggr.timer_cnxt.is_hold_timer_set = true;\n\t\t} else {\n\t\t\tif (port->tx_aggr.timer_cnxt.hold_tmo_msecs <\n\t\t\t    MWIFIEX_USB_TX_AGGR_TMO_MAX) {\n\t\t\t\t \n\t\t\t\ttimeout =\n\t\t\t\t++port->tx_aggr.timer_cnxt.hold_tmo_msecs;\n\t\t\t\tmod_timer(&port->tx_aggr.timer_cnxt.hold_timer,\n\t\t\t\t\t  jiffies + msecs_to_jiffies(timeout));\n\t\t\t}\n\t\t}\n\t}\n\nsend_aggr_buf:\n\tif (f_send_aggr_buf) {\n\t\tret = mwifiex_usb_prepare_tx_aggr_skb(adapter, port, &skb_send);\n\t\tif (!ret) {\n\t\t\tcontext = &port->tx_data_list[port->tx_data_ix++];\n\t\t\tret = mwifiex_usb_construct_send_urb(adapter, port, ep,\n\t\t\t\t\t\t\t     context, skb_send);\n\t\t\tif (ret == -1)\n\t\t\t\tmwifiex_write_data_complete(adapter, skb_send,\n\t\t\t\t\t\t\t    0, -1);\n\t\t}\n\t}\n\n\tif (f_send_cur_buf) {\n\t\tif (f_send_aggr_buf) {\n\t\t\tif (atomic_read(&port->tx_data_urb_pending) >=\n\t\t\t    MWIFIEX_TX_DATA_URB) {\n\t\t\t\tport->block_status = true;\n\t\t\t\tadapter->data_sent =\n\t\t\t\t\tmwifiex_usb_data_sent(adapter);\n\t\t\t\t \n\t\t\t\tf_postcopy_cur_buf = 1;\n\t\t\t\tgoto postcopy_cur_buf;\n\t\t\t}\n\n\t\t\tif (port->tx_data_ix >= MWIFIEX_TX_DATA_URB)\n\t\t\t\tport->tx_data_ix = 0;\n\t\t}\n\n\t\tpayload = skb->data;\n\t\t*(__le16 *)&payload[2] =\n\t\t\tcpu_to_le16(MWIFIEX_TYPE_AGGR_DATA_V2 | 0x80);\n\t\t*(__le16 *)payload = cpu_to_le16(skb->len);\n\t\tskb_send = skb;\n\t\tcontext = &port->tx_data_list[port->tx_data_ix++];\n\t\treturn mwifiex_usb_construct_send_urb(adapter, port, ep,\n\t\t\t\t\t\t      context, skb_send);\n\t}\n\npostcopy_cur_buf:\n\tif (f_postcopy_cur_buf) {\n\t\tskb_queue_tail(&port->tx_aggr.aggr_list, skb);\n\t\tport->tx_aggr.aggr_len += (skb->len + pad);\n\t\tport->tx_aggr.aggr_num++;\n\t\t \n\t\tif (!port->tx_aggr.timer_cnxt.is_hold_timer_set) {\n\t\t\tport->tx_aggr.timer_cnxt.hold_tmo_msecs =\n\t\t\t\t\tMWIFIEX_USB_TX_AGGR_TMO_MIN;\n\t\t\ttimeout = port->tx_aggr.timer_cnxt.hold_tmo_msecs;\n\t\t\tmod_timer(&port->tx_aggr.timer_cnxt.hold_timer,\n\t\t\t\t  jiffies + msecs_to_jiffies(timeout));\n\t\t\tport->tx_aggr.timer_cnxt.is_hold_timer_set = true;\n\t\t}\n\t}\n\n\treturn -EINPROGRESS;\n}\n\nstatic void mwifiex_usb_tx_aggr_tmo(struct timer_list *t)\n{\n\tstruct urb_context *urb_cnxt = NULL;\n\tstruct sk_buff *skb_send = NULL;\n\tstruct tx_aggr_tmr_cnxt *timer_context =\n\t\tfrom_timer(timer_context, t, hold_timer);\n\tstruct mwifiex_adapter *adapter = timer_context->adapter;\n\tstruct usb_tx_data_port *port = timer_context->port;\n\tint err = 0;\n\n\tspin_lock_bh(&port->tx_aggr_lock);\n\terr = mwifiex_usb_prepare_tx_aggr_skb(adapter, port, &skb_send);\n\tif (err) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"prepare tx aggr skb failed, err=%d\\n\", err);\n\t\tgoto unlock;\n\t}\n\n\tif (atomic_read(&port->tx_data_urb_pending) >=\n\t    MWIFIEX_TX_DATA_URB) {\n\t\tport->block_status = true;\n\t\tadapter->data_sent =\n\t\t\tmwifiex_usb_data_sent(adapter);\n\t\terr = -1;\n\t\tgoto done;\n\t}\n\n\tif (port->tx_data_ix >= MWIFIEX_TX_DATA_URB)\n\t\tport->tx_data_ix = 0;\n\n\turb_cnxt = &port->tx_data_list[port->tx_data_ix++];\n\terr = mwifiex_usb_construct_send_urb(adapter, port, port->tx_data_ep,\n\t\t\t\t\t     urb_cnxt, skb_send);\ndone:\n\tif (err == -1)\n\t\tmwifiex_write_data_complete(adapter, skb_send, 0, -1);\nunlock:\n\tspin_unlock_bh(&port->tx_aggr_lock);\n}\n\n \nstatic int mwifiex_usb_host_to_card(struct mwifiex_adapter *adapter, u8 ep,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct mwifiex_tx_param *tx_param)\n{\n\tstruct usb_card_rec *card = adapter->card;\n\tstruct urb_context *context = NULL;\n\tstruct usb_tx_data_port *port = NULL;\n\tint idx, ret;\n\n\tif (test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: not allowed while suspended\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR, \"%s: device removed\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO, \"%s: ep=%d\\n\", __func__, ep);\n\n\tif (ep == card->tx_cmd_ep) {\n\t\tcontext = &card->tx_cmd;\n\t} else {\n\t\t \n\t\tfor (idx = 0; idx < MWIFIEX_TX_DATA_PORT; idx++) {\n\t\t\tif (ep == card->port[idx].tx_data_ep) {\n\t\t\t\tport = &card->port[idx];\n\t\t\t\tif (atomic_read(&port->tx_data_urb_pending)\n\t\t\t\t    >= MWIFIEX_TX_DATA_URB) {\n\t\t\t\t\tport->block_status = true;\n\t\t\t\t\tadapter->data_sent =\n\t\t\t\t\t\tmwifiex_usb_data_sent(adapter);\n\t\t\t\t\treturn -EBUSY;\n\t\t\t\t}\n\t\t\t\tif (port->tx_data_ix >= MWIFIEX_TX_DATA_URB)\n\t\t\t\t\tport->tx_data_ix = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!port) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"Wrong usb tx data port\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (adapter->bus_aggr.enable) {\n\t\t\tspin_lock_bh(&port->tx_aggr_lock);\n\t\t\tret =  mwifiex_usb_aggr_tx_data(adapter, ep, skb,\n\t\t\t\t\t\t\ttx_param, port);\n\t\t\tspin_unlock_bh(&port->tx_aggr_lock);\n\t\t\treturn ret;\n\t\t}\n\n\t\tcontext = &port->tx_data_list[port->tx_data_ix++];\n\t}\n\n\treturn mwifiex_usb_construct_send_urb(adapter, port, ep, context, skb);\n}\n\nstatic int mwifiex_usb_tx_init(struct mwifiex_adapter *adapter)\n{\n\tstruct usb_card_rec *card = (struct usb_card_rec *)adapter->card;\n\tstruct usb_tx_data_port *port;\n\tint i, j;\n\n\tcard->tx_cmd.adapter = adapter;\n\tcard->tx_cmd.ep = card->tx_cmd_ep;\n\n\tcard->tx_cmd.urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!card->tx_cmd.urb)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < MWIFIEX_TX_DATA_PORT; i++) {\n\t\tport = &card->port[i];\n\t\tif (!port->tx_data_ep)\n\t\t\tcontinue;\n\t\tport->tx_data_ix = 0;\n\t\tskb_queue_head_init(&port->tx_aggr.aggr_list);\n\t\tif (port->tx_data_ep == MWIFIEX_USB_EP_DATA)\n\t\t\tport->block_status = false;\n\t\telse\n\t\t\tport->block_status = true;\n\t\tfor (j = 0; j < MWIFIEX_TX_DATA_URB; j++) {\n\t\t\tport->tx_data_list[j].adapter = adapter;\n\t\t\tport->tx_data_list[j].ep = port->tx_data_ep;\n\t\t\tport->tx_data_list[j].urb =\n\t\t\t\t\tusb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!port->tx_data_list[j].urb)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tport->tx_aggr.timer_cnxt.adapter = adapter;\n\t\tport->tx_aggr.timer_cnxt.port = port;\n\t\tport->tx_aggr.timer_cnxt.is_hold_timer_set = false;\n\t\tport->tx_aggr.timer_cnxt.hold_tmo_msecs = 0;\n\t\ttimer_setup(&port->tx_aggr.timer_cnxt.hold_timer,\n\t\t\t    mwifiex_usb_tx_aggr_tmo, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int mwifiex_usb_rx_init(struct mwifiex_adapter *adapter)\n{\n\tstruct usb_card_rec *card = (struct usb_card_rec *)adapter->card;\n\tint i;\n\n\tcard->rx_cmd.adapter = adapter;\n\tcard->rx_cmd.ep = card->rx_cmd_ep;\n\n\tcard->rx_cmd.urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!card->rx_cmd.urb)\n\t\treturn -ENOMEM;\n\n\tcard->rx_cmd.skb = dev_alloc_skb(MWIFIEX_RX_CMD_BUF_SIZE);\n\tif (!card->rx_cmd.skb)\n\t\treturn -ENOMEM;\n\n\tif (mwifiex_usb_submit_rx_urb(&card->rx_cmd, MWIFIEX_RX_CMD_BUF_SIZE))\n\t\treturn -1;\n\n\tfor (i = 0; i < MWIFIEX_RX_DATA_URB; i++) {\n\t\tcard->rx_data_list[i].adapter = adapter;\n\t\tcard->rx_data_list[i].ep = card->rx_data_ep;\n\n\t\tcard->rx_data_list[i].urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!card->rx_data_list[i].urb)\n\t\t\treturn -1;\n\t\tif (mwifiex_usb_submit_rx_urb(&card->rx_data_list[i],\n\t\t\t\t\t      MWIFIEX_RX_DATA_BUF_SIZE))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_register_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct usb_card_rec *card = (struct usb_card_rec *)adapter->card;\n\n\tcard->adapter = adapter;\n\n\tswitch (le16_to_cpu(card->udev->descriptor.idProduct)) {\n\tcase USB8997_PID_1:\n\tcase USB8997_PID_2:\n\t\tadapter->tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_4K;\n\t\tstrcpy(adapter->fw_name, USB8997_DEFAULT_FW_NAME);\n\t\tadapter->ext_scan = true;\n\t\tbreak;\n\tcase USB8766_PID_1:\n\tcase USB8766_PID_2:\n\t\tadapter->tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K;\n\t\tstrcpy(adapter->fw_name, USB8766_DEFAULT_FW_NAME);\n\t\tadapter->ext_scan = true;\n\t\tbreak;\n\tcase USB8801_PID_1:\n\tcase USB8801_PID_2:\n\t\tadapter->tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K;\n\t\tstrcpy(adapter->fw_name, USB8801_DEFAULT_FW_NAME);\n\t\tadapter->ext_scan = false;\n\t\tbreak;\n\tcase USB8797_PID_1:\n\tcase USB8797_PID_2:\n\tdefault:\n\t\tadapter->tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K;\n\t\tstrcpy(adapter->fw_name, USB8797_DEFAULT_FW_NAME);\n\t\tbreak;\n\t}\n\n\tadapter->usb_mc_status = false;\n\tadapter->usb_mc_setup = false;\n\n\treturn 0;\n}\n\nstatic void mwifiex_usb_cleanup_tx_aggr(struct mwifiex_adapter *adapter)\n{\n\tstruct usb_card_rec *card = (struct usb_card_rec *)adapter->card;\n\tstruct usb_tx_data_port *port;\n\tstruct sk_buff *skb_tmp;\n\tint idx;\n\n\tfor (idx = 0; idx < MWIFIEX_TX_DATA_PORT; idx++) {\n\t\tport = &card->port[idx];\n\t\tif (adapter->bus_aggr.enable)\n\t\t\twhile ((skb_tmp =\n\t\t\t\tskb_dequeue(&port->tx_aggr.aggr_list)))\n\t\t\t\tmwifiex_write_data_complete(adapter, skb_tmp,\n\t\t\t\t\t\t\t    0, -1);\n\t\tif (port->tx_aggr.timer_cnxt.hold_timer.function)\n\t\t\tdel_timer_sync(&port->tx_aggr.timer_cnxt.hold_timer);\n\t\tport->tx_aggr.timer_cnxt.is_hold_timer_set = false;\n\t\tport->tx_aggr.timer_cnxt.hold_tmo_msecs = 0;\n\t}\n}\n\nstatic void mwifiex_unregister_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct usb_card_rec *card = (struct usb_card_rec *)adapter->card;\n\n\tmwifiex_usb_free(card);\n\n\tmwifiex_usb_cleanup_tx_aggr(adapter);\n\n\tcard->adapter = NULL;\n}\n\nstatic int mwifiex_prog_fw_w_helper(struct mwifiex_adapter *adapter,\n\t\t\t\t    struct mwifiex_fw_image *fw)\n{\n\tint ret = 0;\n\tu8 *firmware = fw->fw_buf, *recv_buff;\n\tu32 retries = USB8XXX_FW_MAX_RETRY + 1;\n\tu32 dlen;\n\tu32 fw_seqnum = 0, tlen = 0, dnld_cmd = 0;\n\tstruct fw_data *fwdata;\n\tstruct fw_sync_header sync_fw;\n\tu8 check_winner = 1;\n\n\tif (!firmware) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"No firmware image found! Terminating download\\n\");\n\t\tret = -1;\n\t\tgoto fw_exit;\n\t}\n\n\t \n\tfwdata = kzalloc(FW_DNLD_TX_BUF_SIZE, GFP_KERNEL);\n\tif (!fwdata) {\n\t\tret = -ENOMEM;\n\t\tgoto fw_exit;\n\t}\n\n\t \n\trecv_buff = kzalloc(FW_DNLD_RX_BUF_SIZE, GFP_KERNEL);\n\tif (!recv_buff) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tdo {\n\t\t \n\t\tif (check_winner) {\n\t\t\tmemset(&fwdata->fw_hdr, 0, sizeof(struct fw_header));\n\t\t\tdlen = 0;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(&fwdata->fw_hdr, &firmware[tlen],\n\t\t\t       sizeof(struct fw_header));\n\n\t\t\tdlen = le32_to_cpu(fwdata->fw_hdr.data_len);\n\t\t\tdnld_cmd = le32_to_cpu(fwdata->fw_hdr.dnld_cmd);\n\t\t\ttlen += sizeof(struct fw_header);\n\n\t\t\t \n\t\t\tif (dnld_cmd == FW_CMD_7)\n\t\t\t\tdlen = 0;\n\n\t\t\tmemcpy(fwdata->data, &firmware[tlen], dlen);\n\n\t\t\tfwdata->seq_num = cpu_to_le32(fw_seqnum);\n\t\t\ttlen += dlen;\n\t\t}\n\n\t\t \n\t\twhile (--retries) {\n\t\t\tu8 *buf = (u8 *)fwdata;\n\t\t\tu32 len = FW_DATA_XMIT_SIZE;\n\n\t\t\t \n\t\t\tret = mwifiex_write_data_sync(adapter, buf, &len,\n\t\t\t\t\t\tMWIFIEX_USB_EP_CMD_EVENT,\n\t\t\t\t\t\tMWIFIEX_USB_TIMEOUT);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"write_data_sync: failed: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbuf = recv_buff;\n\t\t\tlen = FW_DNLD_RX_BUF_SIZE;\n\n\t\t\t \n\t\t\tret = mwifiex_read_data_sync(adapter, buf, &len,\n\t\t\t\t\t\tMWIFIEX_USB_EP_CMD_EVENT,\n\t\t\t\t\t\tMWIFIEX_USB_TIMEOUT);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"read_data_sync: failed: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemcpy(&sync_fw, recv_buff,\n\t\t\t       sizeof(struct fw_sync_header));\n\n\t\t\t \n\t\t\tif (check_winner) {\n\t\t\t\tif (le32_to_cpu(sync_fw.cmd) & 0x80000000) {\n\t\t\t\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t\t\t\t    \"USB is not the winner %#x\\n\",\n\t\t\t\t\t\t    sync_fw.cmd);\n\n\t\t\t\t\t \n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t\t\t    \"start to download FW...\\n\");\n\n\t\t\t\tcheck_winner = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (sync_fw.cmd) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"FW received block with CRC %#x\\n\",\n\t\t\t\t\t    sync_fw.cmd);\n\t\t\t\tret = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tretries = USB8XXX_FW_MAX_RETRY + 1;\n\t\t\tbreak;\n\t\t}\n\t\tfw_seqnum++;\n\t} while ((dnld_cmd != FW_HAS_LAST_BLOCK) && retries);\n\ncleanup:\n\tmwifiex_dbg(adapter, MSG,\n\t\t    \"info: FW download over, size %d bytes\\n\", tlen);\n\n\tkfree(recv_buff);\n\tkfree(fwdata);\n\n\tif (retries)\n\t\tret = 0;\nfw_exit:\n\treturn ret;\n}\n\nstatic int mwifiex_usb_dnld_fw(struct mwifiex_adapter *adapter,\n\t\t\tstruct mwifiex_fw_image *fw)\n{\n\tint ret;\n\tstruct usb_card_rec *card = (struct usb_card_rec *)adapter->card;\n\n\tif (card->usb_boot_state == USB8XXX_FW_DNLD) {\n\t\tret = mwifiex_prog_fw_w_helper(adapter, fw);\n\t\tif (ret)\n\t\t\treturn -1;\n\n\t\t \n\t\tif (card->usb_boot_state == USB8XXX_FW_DNLD)\n\t\t\treturn -1;\n\t}\n\n\tret = mwifiex_usb_rx_init(adapter);\n\tif (!ret)\n\t\tret = mwifiex_usb_tx_init(adapter);\n\n\treturn ret;\n}\n\nstatic void mwifiex_submit_rx_urb(struct mwifiex_adapter *adapter, u8 ep)\n{\n\tstruct usb_card_rec *card = (struct usb_card_rec *)adapter->card;\n\n\tskb_push(card->rx_cmd.skb, INTF_HEADER_LEN);\n\tif ((ep == card->rx_cmd_ep) &&\n\t    (!atomic_read(&card->rx_cmd_urb_pending)))\n\t\tmwifiex_usb_submit_rx_urb(&card->rx_cmd,\n\t\t\t\t\t  MWIFIEX_RX_CMD_BUF_SIZE);\n\n\treturn;\n}\n\nstatic int mwifiex_usb_cmd_event_complete(struct mwifiex_adapter *adapter,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tmwifiex_submit_rx_urb(adapter, MWIFIEX_USB_EP_CMD_EVENT);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pm_wakeup_card(struct mwifiex_adapter *adapter)\n{\n\t \n\tadapter->pm_wakeup_fw_try = false;\n\tdel_timer(&adapter->wakeup_timer);\n\tadapter->pm_wakeup_card_req = false;\n\tadapter->ps_state = PS_STATE_AWAKE;\n\n\treturn 0;\n}\n\nstatic void mwifiex_usb_submit_rem_rx_urbs(struct mwifiex_adapter *adapter)\n{\n\tstruct usb_card_rec *card = (struct usb_card_rec *)adapter->card;\n\tint i;\n\tstruct urb_context *ctx;\n\n\tfor (i = 0; i < MWIFIEX_RX_DATA_URB; i++) {\n\t\tif (card->rx_data_list[i].skb)\n\t\t\tcontinue;\n\t\tctx = &card->rx_data_list[i];\n\t\tmwifiex_usb_submit_rx_urb(ctx, MWIFIEX_RX_DATA_BUF_SIZE);\n\t}\n}\n\n \nstatic inline int\nmwifiex_pm_wakeup_card_complete(struct mwifiex_adapter *adapter)\n{\n\treturn 0;\n}\n\nstatic struct mwifiex_if_ops usb_ops = {\n\t.register_dev =\t\tmwifiex_register_dev,\n\t.unregister_dev =\tmwifiex_unregister_dev,\n\t.wakeup =\t\tmwifiex_pm_wakeup_card,\n\t.wakeup_complete =\tmwifiex_pm_wakeup_card_complete,\n\n\t \n\t.dnld_fw =\t\tmwifiex_usb_dnld_fw,\n\t.cmdrsp_complete =\tmwifiex_usb_cmd_event_complete,\n\t.event_complete =\tmwifiex_usb_cmd_event_complete,\n\t.host_to_card =\t\tmwifiex_usb_host_to_card,\n\t.submit_rem_rx_urbs =\tmwifiex_usb_submit_rem_rx_urbs,\n\t.multi_port_resync =\tmwifiex_usb_port_resync,\n\t.is_port_ready =\tmwifiex_usb_is_port_ready,\n};\n\nmodule_usb_driver(mwifiex_usb_driver);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell WiFi-Ex USB Driver version\" USB_VERSION);\nMODULE_VERSION(USB_VERSION);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_FIRMWARE(USB8766_DEFAULT_FW_NAME);\nMODULE_FIRMWARE(USB8797_DEFAULT_FW_NAME);\nMODULE_FIRMWARE(USB8801_DEFAULT_FW_NAME);\nMODULE_FIRMWARE(USB8997_DEFAULT_FW_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}