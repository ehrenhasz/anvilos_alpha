{
  "module_name": "cmdevt.c",
  "hash_id": "9ff9388f792905173373f9ff9a0a4d52e3cecd5075350d57a93a7a24214f9cfb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/cmdevt.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n\nstatic void mwifiex_cancel_pending_ioctl(struct mwifiex_adapter *adapter);\n\n \nstatic void\nmwifiex_init_cmd_node(struct mwifiex_private *priv,\n\t\t      struct cmd_ctrl_node *cmd_node,\n\t\t      u32 cmd_no, void *data_buf, bool sync)\n{\n\tcmd_node->priv = priv;\n\tcmd_node->cmd_no = cmd_no;\n\n\tif (sync) {\n\t\tcmd_node->wait_q_enabled = true;\n\t\tcmd_node->cmd_wait_q_woken = false;\n\t\tcmd_node->condition = &cmd_node->cmd_wait_q_woken;\n\t}\n\tcmd_node->data_buf = data_buf;\n\tcmd_node->cmd_skb = cmd_node->skb;\n}\n\n \nstatic struct cmd_ctrl_node *\nmwifiex_get_cmd_node(struct mwifiex_adapter *adapter)\n{\n\tstruct cmd_ctrl_node *cmd_node;\n\n\tspin_lock_bh(&adapter->cmd_free_q_lock);\n\tif (list_empty(&adapter->cmd_free_q)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"GET_CMD_NODE: cmd node not available\\n\");\n\t\tspin_unlock_bh(&adapter->cmd_free_q_lock);\n\t\treturn NULL;\n\t}\n\tcmd_node = list_first_entry(&adapter->cmd_free_q,\n\t\t\t\t    struct cmd_ctrl_node, list);\n\tlist_del(&cmd_node->list);\n\tspin_unlock_bh(&adapter->cmd_free_q_lock);\n\n\treturn cmd_node;\n}\n\n \nstatic void\nmwifiex_clean_cmd_node(struct mwifiex_adapter *adapter,\n\t\t       struct cmd_ctrl_node *cmd_node)\n{\n\tcmd_node->cmd_no = 0;\n\tcmd_node->cmd_flag = 0;\n\tcmd_node->data_buf = NULL;\n\tcmd_node->wait_q_enabled = false;\n\n\tif (cmd_node->cmd_skb)\n\t\tskb_trim(cmd_node->cmd_skb, 0);\n\n\tif (cmd_node->resp_skb) {\n\t\tadapter->if_ops.cmdrsp_complete(adapter, cmd_node->resp_skb);\n\t\tcmd_node->resp_skb = NULL;\n\t}\n}\n\n \nstatic void\nmwifiex_insert_cmd_to_free_q(struct mwifiex_adapter *adapter,\n\t\t\t     struct cmd_ctrl_node *cmd_node)\n{\n\tif (!cmd_node)\n\t\treturn;\n\n\tif (cmd_node->wait_q_enabled)\n\t\tmwifiex_complete_cmd(adapter, cmd_node);\n\t \n\tmwifiex_clean_cmd_node(adapter, cmd_node);\n\n\t \n\tspin_lock_bh(&adapter->cmd_free_q_lock);\n\tlist_add_tail(&cmd_node->list, &adapter->cmd_free_q);\n\tspin_unlock_bh(&adapter->cmd_free_q_lock);\n}\n\n \nvoid mwifiex_recycle_cmd_node(struct mwifiex_adapter *adapter,\n\t\t\t      struct cmd_ctrl_node *cmd_node)\n{\n\tstruct host_cmd_ds_command *host_cmd = (void *)cmd_node->cmd_skb->data;\n\n\tmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\n\n\tatomic_dec(&adapter->cmd_pending);\n\tmwifiex_dbg(adapter, CMD,\n\t\t    \"cmd: FREE_CMD: cmd=%#x, cmd_pending=%d\\n\",\n\t\tle16_to_cpu(host_cmd->command),\n\t\tatomic_read(&adapter->cmd_pending));\n}\n\n \nstatic int mwifiex_cmd_host_cmd(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *cmd,\n\t\t\t\tstruct mwifiex_ds_misc_cmd *pcmd_ptr)\n{\n\t \n\tmemcpy(cmd, pcmd_ptr->cmd, pcmd_ptr->len);\n\tmwifiex_dbg(priv->adapter, CMD,\n\t\t    \"cmd: host cmd size = %d\\n\", pcmd_ptr->len);\n\treturn 0;\n}\n\n \nstatic int mwifiex_dnld_cmd_to_fw(struct mwifiex_private *priv,\n\t\t\t\t  struct cmd_ctrl_node *cmd_node)\n{\n\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret;\n\tstruct host_cmd_ds_command *host_cmd;\n\tuint16_t cmd_code;\n\tuint16_t cmd_size;\n\n\tif (!adapter || !cmd_node)\n\t\treturn -1;\n\n\thost_cmd = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\n\n\t \n\tif (host_cmd->size == 0) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"DNLD_CMD: host_cmd is null\\t\"\n\t\t\t    \"or cmd size is 0, not sending\\n\");\n\t\tif (cmd_node->wait_q_enabled)\n\t\t\tadapter->cmd_wait_q.status = -1;\n\t\tmwifiex_recycle_cmd_node(adapter, cmd_node);\n\t\treturn -1;\n\t}\n\n\tcmd_code = le16_to_cpu(host_cmd->command);\n\tcmd_node->cmd_no = cmd_code;\n\tcmd_size = le16_to_cpu(host_cmd->size);\n\n\tif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET &&\n\t    cmd_code != HostCmd_CMD_FUNC_SHUTDOWN &&\n\t    cmd_code != HostCmd_CMD_FUNC_INIT) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"DNLD_CMD: FW in reset state, ignore cmd %#x\\n\",\n\t\t\tcmd_code);\n\t\tmwifiex_recycle_cmd_node(adapter, cmd_node);\n\t\tqueue_work(adapter->workqueue, &adapter->main_work);\n\t\treturn -1;\n\t}\n\n\t \n\tadapter->seq_num++;\n\thost_cmd->seq_num = cpu_to_le16(HostCmd_SET_SEQ_NO_BSS_INFO\n\t\t\t\t\t(adapter->seq_num,\n\t\t\t\t\t cmd_node->priv->bss_num,\n\t\t\t\t\t cmd_node->priv->bss_type));\n\n\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\tadapter->curr_cmd = cmd_node;\n\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\n\t \n\tif (cmd_node->cmd_skb->len > cmd_size)\n\t\t \n\t\tskb_trim(cmd_node->cmd_skb, cmd_size);\n\telse if (cmd_node->cmd_skb->len < cmd_size)\n\t\t \n\t\tskb_put(cmd_node->cmd_skb, cmd_size - cmd_node->cmd_skb->len);\n\n\tmwifiex_dbg(adapter, CMD,\n\t\t    \"cmd: DNLD_CMD: %#x, act %#x, len %d, seqno %#x\\n\",\n\t\t    cmd_code,\n\t\t    get_unaligned_le16((u8 *)host_cmd + S_DS_GEN),\n\t\t    cmd_size, le16_to_cpu(host_cmd->seq_num));\n\tmwifiex_dbg_dump(adapter, CMD_D, \"cmd buffer:\", host_cmd, cmd_size);\n\n\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\tskb_push(cmd_node->cmd_skb, MWIFIEX_TYPE_LEN);\n\t\tput_unaligned_le32(MWIFIEX_USB_TYPE_CMD,\n\t\t\t\t   cmd_node->cmd_skb->data);\n\t\tadapter->cmd_sent = true;\n\t\tret = adapter->if_ops.host_to_card(adapter,\n\t\t\t\t\t\t   MWIFIEX_USB_EP_CMD_EVENT,\n\t\t\t\t\t\t   cmd_node->cmd_skb, NULL);\n\t\tskb_pull(cmd_node->cmd_skb, MWIFIEX_TYPE_LEN);\n\t\tif (ret == -EBUSY)\n\t\t\tcmd_node->cmd_skb = NULL;\n\t} else {\n\t\tskb_push(cmd_node->cmd_skb, adapter->intf_hdr_len);\n\t\tret = adapter->if_ops.host_to_card(adapter, MWIFIEX_TYPE_CMD,\n\t\t\t\t\t\t   cmd_node->cmd_skb, NULL);\n\t\tskb_pull(cmd_node->cmd_skb, adapter->intf_hdr_len);\n\t}\n\n\tif (ret == -1) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"DNLD_CMD: host to card failed\\n\");\n\t\tif (adapter->iface_type == MWIFIEX_USB)\n\t\t\tadapter->cmd_sent = false;\n\t\tif (cmd_node->wait_q_enabled)\n\t\t\tadapter->cmd_wait_q.status = -1;\n\t\tmwifiex_recycle_cmd_node(adapter, adapter->curr_cmd);\n\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->curr_cmd = NULL;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\n\t\tadapter->dbg.num_cmd_host_to_card_failure++;\n\t\treturn -1;\n\t}\n\n\t \n\tadapter->dbg.last_cmd_index =\n\t\t\t(adapter->dbg.last_cmd_index + 1) % DBG_CMD_NUM;\n\tadapter->dbg.last_cmd_id[adapter->dbg.last_cmd_index] = cmd_code;\n\tadapter->dbg.last_cmd_act[adapter->dbg.last_cmd_index] =\n\t\t\tget_unaligned_le16((u8 *)host_cmd + S_DS_GEN);\n\n\t \n\tif (cmd_code != HostCmd_CMD_FW_DUMP_EVENT)\n\t\tmod_timer(&adapter->cmd_timer,\n\t\t\t  jiffies + msecs_to_jiffies(MWIFIEX_TIMER_10S));\n\n\t \n\tcmd_code &= HostCmd_CMD_ID_MASK;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_dnld_sleep_confirm_cmd(struct mwifiex_adapter *adapter)\n{\n\tint ret;\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_opt_sleep_confirm *sleep_cfm_buf =\n\t\t\t\t(struct mwifiex_opt_sleep_confirm *)\n\t\t\t\t\t\tadapter->sleep_cfm->data;\n\tstruct sk_buff *sleep_cfm_tmp;\n\n\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\n\tadapter->seq_num++;\n\tsleep_cfm_buf->seq_num =\n\t\tcpu_to_le16(HostCmd_SET_SEQ_NO_BSS_INFO\n\t\t\t\t\t(adapter->seq_num, priv->bss_num,\n\t\t\t\t\t priv->bss_type));\n\n\tmwifiex_dbg(adapter, CMD,\n\t\t    \"cmd: DNLD_CMD: %#x, act %#x, len %d, seqno %#x\\n\",\n\t\tle16_to_cpu(sleep_cfm_buf->command),\n\t\tle16_to_cpu(sleep_cfm_buf->action),\n\t\tle16_to_cpu(sleep_cfm_buf->size),\n\t\tle16_to_cpu(sleep_cfm_buf->seq_num));\n\tmwifiex_dbg_dump(adapter, CMD_D, \"SLEEP_CFM buffer: \", sleep_cfm_buf,\n\t\t\t le16_to_cpu(sleep_cfm_buf->size));\n\n\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\tsleep_cfm_tmp =\n\t\t\tdev_alloc_skb(sizeof(struct mwifiex_opt_sleep_confirm)\n\t\t\t\t      + MWIFIEX_TYPE_LEN);\n\t\tif (!sleep_cfm_tmp) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"SLEEP_CFM: dev_alloc_skb failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tskb_put(sleep_cfm_tmp, sizeof(struct mwifiex_opt_sleep_confirm)\n\t\t\t+ MWIFIEX_TYPE_LEN);\n\t\tput_unaligned_le32(MWIFIEX_USB_TYPE_CMD, sleep_cfm_tmp->data);\n\t\tmemcpy(sleep_cfm_tmp->data + MWIFIEX_TYPE_LEN,\n\t\t       adapter->sleep_cfm->data,\n\t\t       sizeof(struct mwifiex_opt_sleep_confirm));\n\t\tret = adapter->if_ops.host_to_card(adapter,\n\t\t\t\t\t\t   MWIFIEX_USB_EP_CMD_EVENT,\n\t\t\t\t\t\t   sleep_cfm_tmp, NULL);\n\t\tif (ret != -EBUSY)\n\t\t\tdev_kfree_skb_any(sleep_cfm_tmp);\n\t} else {\n\t\tskb_push(adapter->sleep_cfm, adapter->intf_hdr_len);\n\t\tret = adapter->if_ops.host_to_card(adapter, MWIFIEX_TYPE_CMD,\n\t\t\t\t\t\t   adapter->sleep_cfm, NULL);\n\t\tskb_pull(adapter->sleep_cfm, adapter->intf_hdr_len);\n\t}\n\n\tif (ret == -1) {\n\t\tmwifiex_dbg(adapter, ERROR, \"SLEEP_CFM: failed\\n\");\n\t\tadapter->dbg.num_cmd_sleep_cfm_host_to_card_failure++;\n\t\treturn -1;\n\t}\n\n\tif (!le16_to_cpu(sleep_cfm_buf->resp_ctrl))\n\t\t \n\t\tadapter->ps_state = PS_STATE_SLEEP;\n\telse\n\t\tadapter->ps_state = PS_STATE_SLEEP_CFM;\n\n\tif (!le16_to_cpu(sleep_cfm_buf->resp_ctrl) &&\n\t    (test_bit(MWIFIEX_IS_HS_CONFIGURED, &adapter->work_flags) &&\n\t     !adapter->sleep_period.period)) {\n\t\tadapter->pm_wakeup_card_req = true;\n\t\tmwifiex_hs_activated_event(mwifiex_get_priv\n\t\t\t\t(adapter, MWIFIEX_BSS_ROLE_ANY), true);\n\t}\n\n\treturn ret;\n}\n\n \nint mwifiex_alloc_cmd_buffer(struct mwifiex_adapter *adapter)\n{\n\tstruct cmd_ctrl_node *cmd_array;\n\tu32 i;\n\n\t \n\tcmd_array = kcalloc(MWIFIEX_NUM_OF_CMD_BUFFER,\n\t\t\t    sizeof(struct cmd_ctrl_node), GFP_KERNEL);\n\tif (!cmd_array)\n\t\treturn -ENOMEM;\n\n\tadapter->cmd_pool = cmd_array;\n\n\t \n\tfor (i = 0; i < MWIFIEX_NUM_OF_CMD_BUFFER; i++) {\n\t\tcmd_array[i].skb = dev_alloc_skb(MWIFIEX_SIZE_OF_CMD_BUFFER);\n\t\tif (!cmd_array[i].skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"unable to allocate command buffer\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MWIFIEX_NUM_OF_CMD_BUFFER; i++)\n\t\tmwifiex_insert_cmd_to_free_q(adapter, &cmd_array[i]);\n\n\treturn 0;\n}\n\n \nvoid mwifiex_free_cmd_buffer(struct mwifiex_adapter *adapter)\n{\n\tstruct cmd_ctrl_node *cmd_array;\n\tu32 i;\n\n\t \n\tif (!adapter->cmd_pool) {\n\t\tmwifiex_dbg(adapter, FATAL,\n\t\t\t    \"info: FREE_CMD_BUF: cmd_pool is null\\n\");\n\t\treturn;\n\t}\n\n\tcmd_array = adapter->cmd_pool;\n\n\t \n\tfor (i = 0; i < MWIFIEX_NUM_OF_CMD_BUFFER; i++) {\n\t\tif (cmd_array[i].skb) {\n\t\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t\t    \"cmd: free cmd buffer %d\\n\", i);\n\t\t\tdev_kfree_skb_any(cmd_array[i].skb);\n\t\t}\n\t\tif (!cmd_array[i].resp_skb)\n\t\t\tcontinue;\n\n\t\tif (adapter->iface_type == MWIFIEX_USB)\n\t\t\tadapter->if_ops.cmdrsp_complete(adapter,\n\t\t\t\t\t\t\tcmd_array[i].resp_skb);\n\t\telse\n\t\t\tdev_kfree_skb_any(cmd_array[i].resp_skb);\n\t}\n\t \n\tif (adapter->cmd_pool) {\n\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t    \"cmd: free cmd pool\\n\");\n\t\tkfree(adapter->cmd_pool);\n\t\tadapter->cmd_pool = NULL;\n\t}\n}\n\n \nint mwifiex_process_event(struct mwifiex_adapter *adapter)\n{\n\tint ret, i;\n\tstruct mwifiex_private *priv =\n\t\tmwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\tstruct sk_buff *skb = adapter->event_skb;\n\tu32 eventcause;\n\tstruct mwifiex_rxinfo *rx_info;\n\n\tif ((adapter->event_cause & EVENT_ID_MASK) == EVENT_RADAR_DETECTED) {\n\t\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\t\tpriv = adapter->priv[i];\n\t\t\tif (priv && mwifiex_is_11h_active(priv)) {\n\t\t\t\tadapter->event_cause |=\n\t\t\t\t\t((priv->bss_num & 0xff) << 16) |\n\t\t\t\t\t((priv->bss_type & 0xff) << 24);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\teventcause = adapter->event_cause;\n\n\t \n\tadapter->dbg.last_event_index =\n\t\t\t(adapter->dbg.last_event_index + 1) % DBG_CMD_NUM;\n\tadapter->dbg.last_event[adapter->dbg.last_event_index] =\n\t\t\t\t\t\t\t(u16) eventcause;\n\n\t \n\tpriv = mwifiex_get_priv_by_id(adapter, EVENT_GET_BSS_NUM(eventcause),\n\t\t\t\t      EVENT_GET_BSS_TYPE(eventcause));\n\tif (!priv)\n\t\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\n\t \n\teventcause &= EVENT_ID_MASK;\n\tadapter->event_cause = eventcause;\n\n\tif (skb) {\n\t\trx_info = MWIFIEX_SKB_RXCB(skb);\n\t\tmemset(rx_info, 0, sizeof(*rx_info));\n\t\trx_info->bss_num = priv->bss_num;\n\t\trx_info->bss_type = priv->bss_type;\n\t\tmwifiex_dbg_dump(adapter, EVT_D, \"Event Buf:\",\n\t\t\t\t skb->data, skb->len);\n\t}\n\n\tmwifiex_dbg(adapter, EVENT, \"EVENT: cause: %#x\\n\", eventcause);\n\n\tif (priv->bss_role == MWIFIEX_BSS_ROLE_UAP)\n\t\tret = mwifiex_process_uap_event(priv);\n\telse\n\t\tret = mwifiex_process_sta_event(priv);\n\n\tadapter->event_cause = 0;\n\tadapter->event_skb = NULL;\n\tadapter->if_ops.event_complete(adapter, skb);\n\n\treturn ret;\n}\n\n \nint mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,\n\t\t     u16 cmd_action, u32 cmd_oid, void *data_buf, bool sync)\n{\n\tint ret;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct cmd_ctrl_node *cmd_node;\n\tstruct host_cmd_ds_command *cmd_ptr;\n\n\tif (!adapter) {\n\t\tpr_err(\"PREP_CMD: adapter is NULL\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: device in suspended state\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags) &&\n\t    cmd_no != HostCmd_CMD_802_11_HS_CFG_ENH) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: host entering sleep state\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: card is removed\\n\");\n\t\treturn -1;\n\t}\n\n\tif (test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: FW is in bad state\\n\");\n\t\treturn -1;\n\t}\n\n\tif (adapter->hw_status == MWIFIEX_HW_STATUS_RESET) {\n\t\tif (cmd_no != HostCmd_CMD_FUNC_INIT) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"PREP_CMD: FW in reset state\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\t \n\tif (adapter->mfg_mode && cmd_no) {\n\t\tdev_dbg(adapter->dev, \"Ignoring commands in manufacturing mode\\n\");\n\t\treturn -1;\n\t}\n\n\tif (priv->adapter->hs_activated_manually &&\n\t    cmd_no != HostCmd_CMD_802_11_HS_CFG_ENH) {\n\t\tmwifiex_cancel_hs(priv, MWIFIEX_ASYNC_CMD);\n\t\tpriv->adapter->hs_activated_manually = false;\n\t}\n\n\t \n\tcmd_node = mwifiex_get_cmd_node(adapter);\n\n\tif (!cmd_node) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: no free cmd node\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tmwifiex_init_cmd_node(priv, cmd_node, cmd_no, data_buf, sync);\n\n\tif (!cmd_node->cmd_skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: no free cmd buf\\n\");\n\t\treturn -1;\n\t}\n\n\tskb_put_zero(cmd_node->cmd_skb, sizeof(struct host_cmd_ds_command));\n\n\tcmd_ptr = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\n\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\tcmd_ptr->result = 0;\n\n\t \n\tif (cmd_no) {\n\t\tswitch (cmd_no) {\n\t\tcase HostCmd_CMD_UAP_SYS_CONFIG:\n\t\tcase HostCmd_CMD_UAP_BSS_START:\n\t\tcase HostCmd_CMD_UAP_BSS_STOP:\n\t\tcase HostCmd_CMD_UAP_STA_DEAUTH:\n\t\tcase HOST_CMD_APCMD_SYS_RESET:\n\t\tcase HOST_CMD_APCMD_STA_LIST:\n\t\t\tret = mwifiex_uap_prepare_cmd(priv, cmd_no, cmd_action,\n\t\t\t\t\t\t      cmd_oid, data_buf,\n\t\t\t\t\t\t      cmd_ptr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = mwifiex_sta_prepare_cmd(priv, cmd_no, cmd_action,\n\t\t\t\t\t\t      cmd_oid, data_buf,\n\t\t\t\t\t\t      cmd_ptr);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = mwifiex_cmd_host_cmd(priv, cmd_ptr, data_buf);\n\t\tcmd_node->cmd_flag |= CMD_F_HOSTCMD;\n\t}\n\n\t \n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PREP_CMD: cmd %#x preparation failed\\n\",\n\t\t\tcmd_no);\n\t\tmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\n\t\treturn -1;\n\t}\n\n\t \n\tif (cmd_no == HostCmd_CMD_802_11_SCAN ||\n\t    cmd_no == HostCmd_CMD_802_11_SCAN_EXT) {\n\t\tmwifiex_queue_scan_cmd(priv, cmd_node);\n\t} else {\n\t\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\n\t\tqueue_work(adapter->workqueue, &adapter->main_work);\n\t\tif (cmd_node->wait_q_enabled)\n\t\t\tret = mwifiex_wait_queue_complete(adapter, cmd_node);\n\t}\n\n\treturn ret;\n}\n\n \nvoid\nmwifiex_insert_cmd_to_pending_q(struct mwifiex_adapter *adapter,\n\t\t\t\tstruct cmd_ctrl_node *cmd_node)\n{\n\tstruct host_cmd_ds_command *host_cmd = NULL;\n\tu16 command;\n\tbool add_tail = true;\n\n\thost_cmd = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\n\tif (!host_cmd) {\n\t\tmwifiex_dbg(adapter, ERROR, \"QUEUE_CMD: host_cmd is NULL\\n\");\n\t\treturn;\n\t}\n\n\tcommand = le16_to_cpu(host_cmd->command);\n\n\t \n\tif (command == HostCmd_CMD_802_11_PS_MODE_ENH) {\n\t\tstruct host_cmd_ds_802_11_ps_mode_enh *pm =\n\t\t\t\t\t\t&host_cmd->params.psmode_enh;\n\t\tif ((le16_to_cpu(pm->action) == DIS_PS) ||\n\t\t    (le16_to_cpu(pm->action) == DIS_AUTO_PS)) {\n\t\t\tif (adapter->ps_state != PS_STATE_AWAKE)\n\t\t\t\tadd_tail = false;\n\t\t}\n\t}\n\n\t \n\tif (command == HostCmd_CMD_802_11_HS_CFG_ENH) {\n\t\tstruct host_cmd_ds_802_11_hs_cfg_enh *hs_cfg =\n\t\t\t&host_cmd->params.opt_hs_cfg;\n\n\t\tif (le16_to_cpu(hs_cfg->action) == HS_ACTIVATE)\n\t\t\t\tadd_tail = false;\n\t}\n\n\tspin_lock_bh(&adapter->cmd_pending_q_lock);\n\tif (add_tail)\n\t\tlist_add_tail(&cmd_node->list, &adapter->cmd_pending_q);\n\telse\n\t\tlist_add(&cmd_node->list, &adapter->cmd_pending_q);\n\tspin_unlock_bh(&adapter->cmd_pending_q_lock);\n\n\tatomic_inc(&adapter->cmd_pending);\n\tmwifiex_dbg(adapter, CMD,\n\t\t    \"cmd: QUEUE_CMD: cmd=%#x, cmd_pending=%d\\n\",\n\t\tcommand, atomic_read(&adapter->cmd_pending));\n}\n\n \nint mwifiex_exec_next_cmd(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\tstruct cmd_ctrl_node *cmd_node;\n\tint ret = 0;\n\tstruct host_cmd_ds_command *host_cmd;\n\n\t \n\tif (adapter->curr_cmd) {\n\t\tmwifiex_dbg(adapter, FATAL,\n\t\t\t    \"EXEC_NEXT_CMD: cmd in processing\\n\");\n\t\treturn -1;\n\t}\n\n\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t \n\tspin_lock_bh(&adapter->cmd_pending_q_lock);\n\tif (list_empty(&adapter->cmd_pending_q)) {\n\t\tspin_unlock_bh(&adapter->cmd_pending_q_lock);\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\t\treturn 0;\n\t}\n\tcmd_node = list_first_entry(&adapter->cmd_pending_q,\n\t\t\t\t    struct cmd_ctrl_node, list);\n\n\thost_cmd = (struct host_cmd_ds_command *) (cmd_node->cmd_skb->data);\n\tpriv = cmd_node->priv;\n\n\tif (adapter->ps_state != PS_STATE_AWAKE) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: cannot send cmd in sleep state,\\t\"\n\t\t\t    \"this should not happen\\n\", __func__);\n\t\tspin_unlock_bh(&adapter->cmd_pending_q_lock);\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\t\treturn ret;\n\t}\n\n\tlist_del(&cmd_node->list);\n\tspin_unlock_bh(&adapter->cmd_pending_q_lock);\n\n\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\tret = mwifiex_dnld_cmd_to_fw(priv, cmd_node);\n\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\t \n\tif (priv && (host_cmd->command !=\n\t     cpu_to_le16(HostCmd_CMD_802_11_HS_CFG_ENH))) {\n\t\tif (adapter->hs_activated) {\n\t\t\tclear_bit(MWIFIEX_IS_HS_CONFIGURED,\n\t\t\t\t  &adapter->work_flags);\n\t\t\tmwifiex_hs_activated_event(priv, false);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nint mwifiex_process_cmdresp(struct mwifiex_adapter *adapter)\n{\n\tstruct host_cmd_ds_command *resp;\n\tstruct mwifiex_private *priv =\n\t\tmwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\tint ret = 0;\n\tuint16_t orig_cmdresp_no;\n\tuint16_t cmdresp_no;\n\tuint16_t cmdresp_result;\n\n\tif (!adapter->curr_cmd || !adapter->curr_cmd->resp_skb) {\n\t\tresp = (struct host_cmd_ds_command *) adapter->upld_buf;\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"CMD_RESP: NULL curr_cmd, %#x\\n\",\n\t\t\t    le16_to_cpu(resp->command));\n\t\treturn -1;\n\t}\n\n\tresp = (struct host_cmd_ds_command *)adapter->curr_cmd->resp_skb->data;\n\torig_cmdresp_no = le16_to_cpu(resp->command);\n\tcmdresp_no = (orig_cmdresp_no & HostCmd_CMD_ID_MASK);\n\n\tif (adapter->curr_cmd->cmd_no != cmdresp_no) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"cmdresp error: cmd=0x%x cmd_resp=0x%x\\n\",\n\t\t\t    adapter->curr_cmd->cmd_no, cmdresp_no);\n\t\treturn -1;\n\t}\n\t \n\tdel_timer_sync(&adapter->cmd_timer);\n\tclear_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags);\n\n\tif (adapter->curr_cmd->cmd_flag & CMD_F_HOSTCMD) {\n\t\t \n\t\tstruct mwifiex_ds_misc_cmd *hostcmd;\n\t\tuint16_t size = le16_to_cpu(resp->size);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: host cmd resp size = %d\\n\", size);\n\t\tsize = min_t(u16, size, MWIFIEX_SIZE_OF_CMD_BUFFER);\n\t\tif (adapter->curr_cmd->data_buf) {\n\t\t\thostcmd = adapter->curr_cmd->data_buf;\n\t\t\thostcmd->len = size;\n\t\t\tmemcpy(hostcmd->cmd, resp, size);\n\t\t}\n\t}\n\n\t \n\tpriv = mwifiex_get_priv_by_id(adapter,\n\t\t\t     HostCmd_GET_BSS_NO(le16_to_cpu(resp->seq_num)),\n\t\t\t     HostCmd_GET_BSS_TYPE(le16_to_cpu(resp->seq_num)));\n\tif (!priv)\n\t\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\t \n\tresp->command = cpu_to_le16(orig_cmdresp_no & HostCmd_CMD_ID_MASK);\n\n\tcmdresp_no = le16_to_cpu(resp->command);\n\tcmdresp_result = le16_to_cpu(resp->result);\n\n\t \n\tadapter->dbg.last_cmd_resp_index =\n\t\t\t(adapter->dbg.last_cmd_resp_index + 1) % DBG_CMD_NUM;\n\tadapter->dbg.last_cmd_resp_id[adapter->dbg.last_cmd_resp_index] =\n\t\t\t\t\t\t\t\torig_cmdresp_no;\n\n\tmwifiex_dbg(adapter, CMD,\n\t\t    \"cmd: CMD_RESP: 0x%x, result %d, len %d, seqno 0x%x\\n\",\n\t\t    orig_cmdresp_no, cmdresp_result,\n\t\t    le16_to_cpu(resp->size), le16_to_cpu(resp->seq_num));\n\tmwifiex_dbg_dump(adapter, CMD_D, \"CMD_RESP buffer:\", resp,\n\t\t\t le16_to_cpu(resp->size));\n\n\tif (!(orig_cmdresp_no & HostCmd_RET_BIT)) {\n\t\tmwifiex_dbg(adapter, ERROR, \"CMD_RESP: invalid cmd resp\\n\");\n\t\tif (adapter->curr_cmd->wait_q_enabled)\n\t\t\tadapter->cmd_wait_q.status = -1;\n\n\t\tmwifiex_recycle_cmd_node(adapter, adapter->curr_cmd);\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->curr_cmd = NULL;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\t\treturn -1;\n\t}\n\n\tif (adapter->curr_cmd->cmd_flag & CMD_F_HOSTCMD) {\n\t\tadapter->curr_cmd->cmd_flag &= ~CMD_F_HOSTCMD;\n\t\tif ((cmdresp_result == HostCmd_RESULT_OK) &&\n\t\t    (cmdresp_no == HostCmd_CMD_802_11_HS_CFG_ENH))\n\t\t\tret = mwifiex_ret_802_11_hs_cfg(priv, resp);\n\t} else {\n\t\t \n\t\tret = mwifiex_process_sta_cmdresp(priv, cmdresp_no, resp);\n\t}\n\n\t \n\tif (adapter->hw_status == MWIFIEX_HW_STATUS_INITIALIZING) {\n\t\tif (ret) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"%s: cmd %#x failed during\\t\"\n\t\t\t\t    \"initialization\\n\", __func__, cmdresp_no);\n\t\t\tmwifiex_init_fw_complete(adapter);\n\t\t\treturn -1;\n\t\t} else if (adapter->last_init_cmd == cmdresp_no)\n\t\t\tadapter->hw_status = MWIFIEX_HW_STATUS_INIT_DONE;\n\t}\n\n\tif (adapter->curr_cmd) {\n\t\tif (adapter->curr_cmd->wait_q_enabled)\n\t\t\tadapter->cmd_wait_q.status = ret;\n\n\t\tmwifiex_recycle_cmd_node(adapter, adapter->curr_cmd);\n\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->curr_cmd = NULL;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\t}\n\n\treturn ret;\n}\n\n \nvoid\nmwifiex_cmd_timeout_func(struct timer_list *t)\n{\n\tstruct mwifiex_adapter *adapter = from_timer(adapter, t, cmd_timer);\n\tstruct cmd_ctrl_node *cmd_node;\n\n\tset_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags);\n\tif (!adapter->curr_cmd) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"cmd: empty curr_cmd\\n\");\n\t\treturn;\n\t}\n\tcmd_node = adapter->curr_cmd;\n\tif (cmd_node) {\n\t\tadapter->dbg.timeout_cmd_id =\n\t\t\tadapter->dbg.last_cmd_id[adapter->dbg.last_cmd_index];\n\t\tadapter->dbg.timeout_cmd_act =\n\t\t\tadapter->dbg.last_cmd_act[adapter->dbg.last_cmd_index];\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"%s: Timeout cmd id = %#x, act = %#x\\n\", __func__,\n\t\t\t    adapter->dbg.timeout_cmd_id,\n\t\t\t    adapter->dbg.timeout_cmd_act);\n\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"num_data_h2c_failure = %d\\n\",\n\t\t\t    adapter->dbg.num_tx_host_to_card_failure);\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"num_cmd_h2c_failure = %d\\n\",\n\t\t\t    adapter->dbg.num_cmd_host_to_card_failure);\n\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"is_cmd_timedout = %d\\n\",\n\t\t\t    test_bit(MWIFIEX_IS_CMD_TIMEDOUT,\n\t\t\t\t     &adapter->work_flags));\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"num_tx_timeout = %d\\n\",\n\t\t\t    adapter->dbg.num_tx_timeout);\n\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"last_cmd_index = %d\\n\",\n\t\t\t    adapter->dbg.last_cmd_index);\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"last_cmd_id: %*ph\\n\",\n\t\t\t    (int)sizeof(adapter->dbg.last_cmd_id),\n\t\t\t    adapter->dbg.last_cmd_id);\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"last_cmd_act: %*ph\\n\",\n\t\t\t    (int)sizeof(adapter->dbg.last_cmd_act),\n\t\t\t    adapter->dbg.last_cmd_act);\n\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"last_cmd_resp_index = %d\\n\",\n\t\t\t    adapter->dbg.last_cmd_resp_index);\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"last_cmd_resp_id: %*ph\\n\",\n\t\t\t    (int)sizeof(adapter->dbg.last_cmd_resp_id),\n\t\t\t    adapter->dbg.last_cmd_resp_id);\n\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"last_event_index = %d\\n\",\n\t\t\t    adapter->dbg.last_event_index);\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"last_event: %*ph\\n\",\n\t\t\t    (int)sizeof(adapter->dbg.last_event),\n\t\t\t    adapter->dbg.last_event);\n\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"data_sent=%d cmd_sent=%d\\n\",\n\t\t\t    adapter->data_sent, adapter->cmd_sent);\n\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"ps_mode=%d ps_state=%d\\n\",\n\t\t\t    adapter->ps_mode, adapter->ps_state);\n\n\t\tif (cmd_node->wait_q_enabled) {\n\t\t\tadapter->cmd_wait_q.status = -ETIMEDOUT;\n\t\t\tmwifiex_cancel_pending_ioctl(adapter);\n\t\t}\n\t}\n\tif (adapter->hw_status == MWIFIEX_HW_STATUS_INITIALIZING) {\n\t\tmwifiex_init_fw_complete(adapter);\n\t\treturn;\n\t}\n\n\tif (adapter->if_ops.device_dump)\n\t\tadapter->if_ops.device_dump(adapter);\n\n\tif (adapter->if_ops.card_reset)\n\t\tadapter->if_ops.card_reset(adapter);\n}\n\nvoid\nmwifiex_cancel_pending_scan_cmd(struct mwifiex_adapter *adapter)\n{\n\tstruct cmd_ctrl_node *cmd_node = NULL, *tmp_node;\n\n\t \n\tspin_lock_bh(&adapter->scan_pending_q_lock);\n\tlist_for_each_entry_safe(cmd_node, tmp_node,\n\t\t\t\t &adapter->scan_pending_q, list) {\n\t\tlist_del(&cmd_node->list);\n\t\tcmd_node->wait_q_enabled = false;\n\t\tmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\n\t}\n\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n}\n\n \nvoid\nmwifiex_cancel_all_pending_cmd(struct mwifiex_adapter *adapter)\n{\n\tstruct cmd_ctrl_node *cmd_node = NULL, *tmp_node;\n\n\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t \n\tif ((adapter->curr_cmd) && (adapter->curr_cmd->wait_q_enabled)) {\n\t\tadapter->cmd_wait_q.status = -1;\n\t\tmwifiex_complete_cmd(adapter, adapter->curr_cmd);\n\t\tadapter->curr_cmd->wait_q_enabled = false;\n\t\t \n\t}\n\t \n\tspin_lock_bh(&adapter->cmd_pending_q_lock);\n\tlist_for_each_entry_safe(cmd_node, tmp_node,\n\t\t\t\t &adapter->cmd_pending_q, list) {\n\t\tlist_del(&cmd_node->list);\n\n\t\tif (cmd_node->wait_q_enabled)\n\t\t\tadapter->cmd_wait_q.status = -1;\n\t\tmwifiex_recycle_cmd_node(adapter, cmd_node);\n\t}\n\tspin_unlock_bh(&adapter->cmd_pending_q_lock);\n\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\n\tmwifiex_cancel_scan(adapter);\n}\n\n \nstatic void\nmwifiex_cancel_pending_ioctl(struct mwifiex_adapter *adapter)\n{\n\tstruct cmd_ctrl_node *cmd_node = NULL;\n\n\tif ((adapter->curr_cmd) &&\n\t    (adapter->curr_cmd->wait_q_enabled)) {\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tcmd_node = adapter->curr_cmd;\n\t\t \n\t\tadapter->curr_cmd = NULL;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\n\t\tmwifiex_recycle_cmd_node(adapter, cmd_node);\n\t}\n\n\tmwifiex_cancel_scan(adapter);\n}\n\n \nvoid\nmwifiex_check_ps_cond(struct mwifiex_adapter *adapter)\n{\n\tif (!adapter->cmd_sent && !atomic_read(&adapter->tx_hw_pending) &&\n\t    !adapter->curr_cmd && !IS_CARD_RX_RCVD(adapter))\n\t\tmwifiex_dnld_sleep_confirm_cmd(adapter);\n\telse\n\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t    \"cmd: Delay Sleep Confirm (%s%s%s%s)\\n\",\n\t\t\t    (adapter->cmd_sent) ? \"D\" : \"\",\n\t\t\t    atomic_read(&adapter->tx_hw_pending) ? \"T\" : \"\",\n\t\t\t    (adapter->curr_cmd) ? \"C\" : \"\",\n\t\t\t    (IS_CARD_RX_RCVD(adapter)) ? \"R\" : \"\");\n}\n\n \nvoid\nmwifiex_hs_activated_event(struct mwifiex_private *priv, u8 activated)\n{\n\tif (activated) {\n\t\tif (test_bit(MWIFIEX_IS_HS_CONFIGURED,\n\t\t\t     &priv->adapter->work_flags)) {\n\t\t\tpriv->adapter->hs_activated = true;\n\t\t\tmwifiex_update_rxreor_flags(priv->adapter,\n\t\t\t\t\t\t    RXREOR_FORCE_NO_DROP);\n\t\t\tmwifiex_dbg(priv->adapter, EVENT,\n\t\t\t\t    \"event: hs_activated\\n\");\n\t\t\tpriv->adapter->hs_activate_wait_q_woken = true;\n\t\t\twake_up_interruptible(\n\t\t\t\t&priv->adapter->hs_activate_wait_q);\n\t\t} else {\n\t\t\tmwifiex_dbg(priv->adapter, EVENT,\n\t\t\t\t    \"event: HS not configured\\n\");\n\t\t}\n\t} else {\n\t\tmwifiex_dbg(priv->adapter, EVENT,\n\t\t\t    \"event: hs_deactivated\\n\");\n\t\tpriv->adapter->hs_activated = false;\n\t}\n}\n\n \nint mwifiex_ret_802_11_hs_cfg(struct mwifiex_private *priv,\n\t\t\t      struct host_cmd_ds_command *resp)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_hs_cfg_enh *phs_cfg =\n\t\t&resp->params.opt_hs_cfg;\n\tuint32_t conditions = le32_to_cpu(phs_cfg->params.hs_config.conditions);\n\n\tif (phs_cfg->action == cpu_to_le16(HS_ACTIVATE) &&\n\t    adapter->iface_type != MWIFIEX_USB) {\n\t\tmwifiex_hs_activated_event(priv, true);\n\t\treturn 0;\n\t} else {\n\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t    \"cmd: CMD_RESP: HS_CFG cmd reply\\t\"\n\t\t\t    \" result=%#x, conditions=0x%x gpio=0x%x gap=0x%x\\n\",\n\t\t\t    resp->result, conditions,\n\t\t\t    phs_cfg->params.hs_config.gpio,\n\t\t\t    phs_cfg->params.hs_config.gap);\n\t}\n\tif (conditions != HS_CFG_CANCEL) {\n\t\tset_bit(MWIFIEX_IS_HS_CONFIGURED, &adapter->work_flags);\n\t\tif (adapter->iface_type == MWIFIEX_USB)\n\t\t\tmwifiex_hs_activated_event(priv, true);\n\t} else {\n\t\tclear_bit(MWIFIEX_IS_HS_CONFIGURED, &adapter->work_flags);\n\t\tif (adapter->hs_activated)\n\t\t\tmwifiex_hs_activated_event(priv, false);\n\t}\n\n\treturn 0;\n}\n\n \nvoid\nmwifiex_process_hs_config(struct mwifiex_adapter *adapter)\n{\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: %s: auto cancelling host sleep\\t\"\n\t\t    \"since there is interrupt from the firmware\\n\",\n\t\t    __func__);\n\n\tadapter->if_ops.wakeup(adapter);\n\n\tif (adapter->hs_activated_manually) {\n\t\tmwifiex_cancel_hs(mwifiex_get_priv (adapter, MWIFIEX_BSS_ROLE_ANY),\n\t\t\t\t  MWIFIEX_ASYNC_CMD);\n\t\tadapter->hs_activated_manually = false;\n\t}\n\n\tadapter->hs_activated = false;\n\tclear_bit(MWIFIEX_IS_HS_CONFIGURED, &adapter->work_flags);\n\tclear_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);\n\tmwifiex_hs_activated_event(mwifiex_get_priv(adapter,\n\t\t\t\t\t\t    MWIFIEX_BSS_ROLE_ANY),\n\t\t\t\t   false);\n}\nEXPORT_SYMBOL_GPL(mwifiex_process_hs_config);\n\n \nvoid\nmwifiex_process_sleep_confirm_resp(struct mwifiex_adapter *adapter,\n\t\t\t\t   u8 *pbuf, u32 upld_len)\n{\n\tstruct host_cmd_ds_command *cmd = (struct host_cmd_ds_command *) pbuf;\n\tstruct mwifiex_private *priv =\n\t\tmwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\tuint16_t result = le16_to_cpu(cmd->result);\n\tuint16_t command = le16_to_cpu(cmd->command);\n\tuint16_t seq_num = le16_to_cpu(cmd->seq_num);\n\n\tif (!upld_len) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: cmd size is 0\\n\", __func__);\n\t\treturn;\n\t}\n\n\tmwifiex_dbg(adapter, CMD,\n\t\t    \"cmd: CMD_RESP: 0x%x, result %d, len %d, seqno 0x%x\\n\",\n\t\t    command, result, le16_to_cpu(cmd->size), seq_num);\n\n\t \n\tpriv = mwifiex_get_priv_by_id(adapter, HostCmd_GET_BSS_NO(seq_num),\n\t\t\t\t      HostCmd_GET_BSS_TYPE(seq_num));\n\tif (!priv)\n\t\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\n\t \n\tseq_num = HostCmd_GET_SEQ_NO(seq_num);\n\t \n\tcommand &= HostCmd_CMD_ID_MASK;\n\n\tif (command != HostCmd_CMD_802_11_PS_MODE_ENH) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: rcvd unexpected resp for cmd %#x, result = %x\\n\",\n\t\t\t    __func__, command, result);\n\t\treturn;\n\t}\n\n\tif (result) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: sleep confirm cmd failed\\n\",\n\t\t\t    __func__);\n\t\tadapter->pm_wakeup_card_req = false;\n\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t\treturn;\n\t}\n\tadapter->pm_wakeup_card_req = true;\n\tif (test_bit(MWIFIEX_IS_HS_CONFIGURED, &adapter->work_flags))\n\t\tmwifiex_hs_activated_event(mwifiex_get_priv\n\t\t\t\t\t\t(adapter, MWIFIEX_BSS_ROLE_ANY),\n\t\t\t\t\t   true);\n\tadapter->ps_state = PS_STATE_SLEEP;\n\tcmd->command = cpu_to_le16(command);\n\tcmd->seq_num = cpu_to_le16(seq_num);\n}\nEXPORT_SYMBOL_GPL(mwifiex_process_sleep_confirm_resp);\n\n \nint mwifiex_cmd_enh_power_mode(struct mwifiex_private *priv,\n\t\t\t       struct host_cmd_ds_command *cmd,\n\t\t\t       u16 cmd_action, uint16_t ps_bitmap,\n\t\t\t       struct mwifiex_ds_auto_ds *auto_ds)\n{\n\tstruct host_cmd_ds_802_11_ps_mode_enh *psmode_enh =\n\t\t&cmd->params.psmode_enh;\n\tu8 *tlv;\n\tu16 cmd_size = 0;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_PS_MODE_ENH);\n\tif (cmd_action == DIS_AUTO_PS) {\n\t\tpsmode_enh->action = cpu_to_le16(DIS_AUTO_PS);\n\t\tpsmode_enh->params.ps_bitmap = cpu_to_le16(ps_bitmap);\n\t\tcmd->size = cpu_to_le16(S_DS_GEN + sizeof(psmode_enh->action) +\n\t\t\t\t\tsizeof(psmode_enh->params.ps_bitmap));\n\t} else if (cmd_action == GET_PS) {\n\t\tpsmode_enh->action = cpu_to_le16(GET_PS);\n\t\tpsmode_enh->params.ps_bitmap = cpu_to_le16(ps_bitmap);\n\t\tcmd->size = cpu_to_le16(S_DS_GEN + sizeof(psmode_enh->action) +\n\t\t\t\t\tsizeof(psmode_enh->params.ps_bitmap));\n\t} else if (cmd_action == EN_AUTO_PS) {\n\t\tpsmode_enh->action = cpu_to_le16(EN_AUTO_PS);\n\t\tpsmode_enh->params.ps_bitmap = cpu_to_le16(ps_bitmap);\n\t\tcmd_size = S_DS_GEN + sizeof(psmode_enh->action) +\n\t\t\t\t\tsizeof(psmode_enh->params.ps_bitmap);\n\t\ttlv = (u8 *) cmd + cmd_size;\n\t\tif (ps_bitmap & BITMAP_STA_PS) {\n\t\t\tstruct mwifiex_adapter *adapter = priv->adapter;\n\t\t\tstruct mwifiex_ie_types_ps_param *ps_tlv =\n\t\t\t\t(struct mwifiex_ie_types_ps_param *) tlv;\n\t\t\tstruct mwifiex_ps_param *ps_mode = &ps_tlv->param;\n\t\t\tps_tlv->header.type = cpu_to_le16(TLV_TYPE_PS_PARAM);\n\t\t\tps_tlv->header.len = cpu_to_le16(sizeof(*ps_tlv) -\n\t\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\t\tcmd_size += sizeof(*ps_tlv);\n\t\t\ttlv += sizeof(*ps_tlv);\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"cmd: PS Command: Enter PS\\n\");\n\t\t\tps_mode->null_pkt_interval =\n\t\t\t\t\tcpu_to_le16(adapter->null_pkt_interval);\n\t\t\tps_mode->multiple_dtims =\n\t\t\t\t\tcpu_to_le16(adapter->multiple_dtim);\n\t\t\tps_mode->bcn_miss_timeout =\n\t\t\t\t\tcpu_to_le16(adapter->bcn_miss_time_out);\n\t\t\tps_mode->local_listen_interval =\n\t\t\t\tcpu_to_le16(adapter->local_listen_interval);\n\t\t\tps_mode->adhoc_wake_period =\n\t\t\t\tcpu_to_le16(adapter->adhoc_awake_period);\n\t\t\tps_mode->delay_to_ps =\n\t\t\t\t\tcpu_to_le16(adapter->delay_to_ps);\n\t\t\tps_mode->mode = cpu_to_le16(adapter->enhanced_ps_mode);\n\n\t\t}\n\t\tif (ps_bitmap & BITMAP_AUTO_DS) {\n\t\t\tstruct mwifiex_ie_types_auto_ds_param *auto_ds_tlv =\n\t\t\t\t(struct mwifiex_ie_types_auto_ds_param *) tlv;\n\t\t\tu16 idletime = 0;\n\n\t\t\tauto_ds_tlv->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_AUTO_DS_PARAM);\n\t\t\tauto_ds_tlv->header.len =\n\t\t\t\tcpu_to_le16(sizeof(*auto_ds_tlv) -\n\t\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\t\tcmd_size += sizeof(*auto_ds_tlv);\n\t\t\ttlv += sizeof(*auto_ds_tlv);\n\t\t\tif (auto_ds)\n\t\t\t\tidletime = auto_ds->idle_time;\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"cmd: PS Command: Enter Auto Deep Sleep\\n\");\n\t\t\tauto_ds_tlv->deep_sleep_timeout = cpu_to_le16(idletime);\n\t\t}\n\t\tcmd->size = cpu_to_le16(cmd_size);\n\t}\n\treturn 0;\n}\n\n \nint mwifiex_ret_enh_power_mode(struct mwifiex_private *priv,\n\t\t\t       struct host_cmd_ds_command *resp,\n\t\t\t       struct mwifiex_ds_pm_cfg *pm_cfg)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_ps_mode_enh *ps_mode =\n\t\t&resp->params.psmode_enh;\n\tuint16_t action = le16_to_cpu(ps_mode->action);\n\tuint16_t ps_bitmap = le16_to_cpu(ps_mode->params.ps_bitmap);\n\tuint16_t auto_ps_bitmap =\n\t\tle16_to_cpu(ps_mode->params.ps_bitmap);\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: %s: PS_MODE cmd reply result=%#x action=%#X\\n\",\n\t\t    __func__, resp->result, action);\n\tif (action == EN_AUTO_PS) {\n\t\tif (auto_ps_bitmap & BITMAP_AUTO_DS) {\n\t\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t\t    \"cmd: Enabled auto deep sleep\\n\");\n\t\t\tpriv->adapter->is_deep_sleep = true;\n\t\t}\n\t\tif (auto_ps_bitmap & BITMAP_STA_PS) {\n\t\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t\t    \"cmd: Enabled STA power save\\n\");\n\t\t\tif (adapter->sleep_period.period)\n\t\t\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t\t\t    \"cmd: set to uapsd/pps mode\\n\");\n\t\t}\n\t} else if (action == DIS_AUTO_PS) {\n\t\tif (ps_bitmap & BITMAP_AUTO_DS) {\n\t\t\tpriv->adapter->is_deep_sleep = false;\n\t\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t\t    \"cmd: Disabled auto deep sleep\\n\");\n\t\t}\n\t\tif (ps_bitmap & BITMAP_STA_PS) {\n\t\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t\t    \"cmd: Disabled STA power save\\n\");\n\t\t\tif (adapter->sleep_period.period) {\n\t\t\t\tadapter->delay_null_pkt = false;\n\t\t\t\tadapter->tx_lock_flag = false;\n\t\t\t\tadapter->pps_uapsd_mode = false;\n\t\t\t}\n\t\t}\n\t} else if (action == GET_PS) {\n\t\tif (ps_bitmap & BITMAP_STA_PS)\n\t\t\tadapter->ps_mode = MWIFIEX_802_11_POWER_MODE_PSP;\n\t\telse\n\t\t\tadapter->ps_mode = MWIFIEX_802_11_POWER_MODE_CAM;\n\n\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t    \"cmd: ps_bitmap=%#x\\n\", ps_bitmap);\n\n\t\tif (pm_cfg) {\n\t\t\t \n\t\t\tif (ps_bitmap & BITMAP_STA_PS)\n\t\t\t\tpm_cfg->param.ps_mode = 1;\n\t\t\telse\n\t\t\t\tpm_cfg->param.ps_mode = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint mwifiex_cmd_get_hw_spec(struct mwifiex_private *priv,\n\t\t\t    struct host_cmd_ds_command *cmd)\n{\n\tstruct host_cmd_ds_get_hw_spec *hw_spec = &cmd->params.hw_spec;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_GET_HW_SPEC);\n\tcmd->size =\n\t\tcpu_to_le16(sizeof(struct host_cmd_ds_get_hw_spec) + S_DS_GEN);\n\tmemcpy(hw_spec->permanent_addr, priv->curr_addr, ETH_ALEN);\n\n\treturn 0;\n}\n\n \nint mwifiex_ret_get_hw_spec(struct mwifiex_private *priv,\n\t\t\t    struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_get_hw_spec *hw_spec = &resp->params.hw_spec;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_ie_types_header *tlv;\n\tstruct hw_spec_api_rev *api_rev;\n\tstruct hw_spec_max_conn *max_conn;\n\tu16 resp_size, api_id;\n\tint i, left_len, parsed_len = 0;\n\n\tadapter->fw_cap_info = le32_to_cpu(hw_spec->fw_cap_info);\n\n\tif (IS_SUPPORT_MULTI_BANDS(adapter))\n\t\tadapter->fw_bands = (u8) GET_FW_DEFAULT_BANDS(adapter);\n\telse\n\t\tadapter->fw_bands = BAND_B;\n\n\tadapter->config_bands = adapter->fw_bands;\n\n\tif (adapter->fw_bands & BAND_A) {\n\t\tif (adapter->fw_bands & BAND_GN) {\n\t\t\tadapter->config_bands |= BAND_AN;\n\t\t\tadapter->fw_bands |= BAND_AN;\n\t\t}\n\t\tif (adapter->fw_bands & BAND_AN) {\n\t\t\tadapter->adhoc_start_band = BAND_A | BAND_AN;\n\t\t\tadapter->adhoc_11n_enabled = true;\n\t\t} else {\n\t\t\tadapter->adhoc_start_band = BAND_A;\n\t\t}\n\t\tpriv->adhoc_channel = DEFAULT_AD_HOC_CHANNEL_A;\n\t} else if (adapter->fw_bands & BAND_GN) {\n\t\tadapter->adhoc_start_band = BAND_G | BAND_B | BAND_GN;\n\t\tpriv->adhoc_channel = DEFAULT_AD_HOC_CHANNEL;\n\t\tadapter->adhoc_11n_enabled = true;\n\t} else if (adapter->fw_bands & BAND_G) {\n\t\tadapter->adhoc_start_band = BAND_G | BAND_B;\n\t\tpriv->adhoc_channel = DEFAULT_AD_HOC_CHANNEL;\n\t} else if (adapter->fw_bands & BAND_B) {\n\t\tadapter->adhoc_start_band = BAND_B;\n\t\tpriv->adhoc_channel = DEFAULT_AD_HOC_CHANNEL;\n\t}\n\n\tadapter->fw_release_number = le32_to_cpu(hw_spec->fw_release_number);\n\tadapter->fw_api_ver = (adapter->fw_release_number >> 16) & 0xff;\n\tadapter->number_of_antenna =\n\t\t\tle16_to_cpu(hw_spec->number_of_antenna) & 0xf;\n\n\tif (le32_to_cpu(hw_spec->dot_11ac_dev_cap)) {\n\t\tadapter->is_hw_11ac_capable = true;\n\n\t\t \n\t\tadapter->hw_dot_11ac_dev_cap =\n\t\t\t\t\tle32_to_cpu(hw_spec->dot_11ac_dev_cap);\n\t\tadapter->usr_dot_11ac_dev_cap_bg = adapter->hw_dot_11ac_dev_cap\n\t\t\t\t\t& ~MWIFIEX_DEF_11AC_CAP_BF_RESET_MASK;\n\t\tadapter->usr_dot_11ac_dev_cap_a = adapter->hw_dot_11ac_dev_cap\n\t\t\t\t\t& ~MWIFIEX_DEF_11AC_CAP_BF_RESET_MASK;\n\n\t\t \n\t\tadapter->hw_dot_11ac_mcs_support =\n\t\t\t\tle32_to_cpu(hw_spec->dot_11ac_mcs_support);\n\t\tadapter->usr_dot_11ac_mcs_support =\n\t\t\t\t\tadapter->hw_dot_11ac_mcs_support;\n\t} else {\n\t\tadapter->is_hw_11ac_capable = false;\n\t}\n\n\tresp_size = le16_to_cpu(resp->size) - S_DS_GEN;\n\tif (resp_size > sizeof(struct host_cmd_ds_get_hw_spec)) {\n\t\t \n\t\tleft_len = resp_size - sizeof(struct host_cmd_ds_get_hw_spec);\n\t\twhile (left_len > sizeof(struct mwifiex_ie_types_header)) {\n\t\t\ttlv = (void *)&hw_spec->tlvs + parsed_len;\n\t\t\tswitch (le16_to_cpu(tlv->type)) {\n\t\t\tcase TLV_TYPE_API_REV:\n\t\t\t\tapi_rev = (struct hw_spec_api_rev *)tlv;\n\t\t\t\tapi_id = le16_to_cpu(api_rev->api_id);\n\t\t\t\tswitch (api_id) {\n\t\t\t\tcase KEY_API_VER_ID:\n\t\t\t\t\tadapter->key_api_major_ver =\n\t\t\t\t\t\t\tapi_rev->major_ver;\n\t\t\t\t\tadapter->key_api_minor_ver =\n\t\t\t\t\t\t\tapi_rev->minor_ver;\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"key_api v%d.%d\\n\",\n\t\t\t\t\t\t    adapter->key_api_major_ver,\n\t\t\t\t\t\t    adapter->key_api_minor_ver);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FW_API_VER_ID:\n\t\t\t\t\tadapter->fw_api_ver =\n\t\t\t\t\t\t\tapi_rev->major_ver;\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"Firmware api version %d.%d\\n\",\n\t\t\t\t\t\t    adapter->fw_api_ver,\n\t\t\t\t\t\t    api_rev->minor_ver);\n\t\t\t\t\tbreak;\n\t\t\t\tcase UAP_FW_API_VER_ID:\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"uAP api version %d.%d\\n\",\n\t\t\t\t\t\t    api_rev->major_ver,\n\t\t\t\t\t\t    api_rev->minor_ver);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHANRPT_API_VER_ID:\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"channel report api version %d.%d\\n\",\n\t\t\t\t\t\t    api_rev->major_ver,\n\t\t\t\t\t\t    api_rev->minor_ver);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FW_HOTFIX_VER_ID:\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"Firmware hotfix version %d\\n\",\n\t\t\t\t\t\t    api_rev->major_ver);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmwifiex_dbg(adapter, FATAL,\n\t\t\t\t\t\t    \"Unknown api_id: %d\\n\",\n\t\t\t\t\t\t    api_id);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TLV_TYPE_MAX_CONN:\n\t\t\t\tmax_conn = (struct hw_spec_max_conn *)tlv;\n\t\t\t\tadapter->max_p2p_conn = max_conn->max_p2p_conn;\n\t\t\t\tadapter->max_sta_conn = max_conn->max_sta_conn;\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"max p2p connections: %u\\n\",\n\t\t\t\t\t    adapter->max_p2p_conn);\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"max sta connections: %u\\n\",\n\t\t\t\t\t    adapter->max_sta_conn);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmwifiex_dbg(adapter, FATAL,\n\t\t\t\t\t    \"Unknown GET_HW_SPEC TLV type: %#x\\n\",\n\t\t\t\t\t    le16_to_cpu(tlv->type));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparsed_len += le16_to_cpu(tlv->len) +\n\t\t\t\t      sizeof(struct mwifiex_ie_types_header);\n\t\t\tleft_len -= le16_to_cpu(tlv->len) +\n\t\t\t\t      sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: GET_HW_SPEC: fw_release_number- %#x\\n\",\n\t\t    adapter->fw_release_number);\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: GET_HW_SPEC: permanent addr: %pM\\n\",\n\t\t    hw_spec->permanent_addr);\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: GET_HW_SPEC: hw_if_version=%#x version=%#x\\n\",\n\t\t    le16_to_cpu(hw_spec->hw_if_version),\n\t\t    le16_to_cpu(hw_spec->version));\n\n\tether_addr_copy(priv->adapter->perm_addr, hw_spec->permanent_addr);\n\tadapter->region_code = le16_to_cpu(hw_spec->region_code);\n\n\tfor (i = 0; i < MWIFIEX_MAX_REGION_CODE; i++)\n\t\t \n\t\tif (adapter->region_code == region_code_index[i])\n\t\t\tbreak;\n\n\t \n\tif (i >= MWIFIEX_MAX_REGION_CODE) {\n\t\tadapter->region_code = 0x00;\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"cmd: unknown region code, use default (USA)\\n\");\n\t}\n\n\tadapter->hw_dot_11n_dev_cap = le32_to_cpu(hw_spec->dot_11n_dev_cap);\n\tadapter->hw_dev_mcs_support = hw_spec->dev_mcs_support;\n\tadapter->user_dev_mcs_support = adapter->hw_dev_mcs_support;\n\n\tif (adapter->if_ops.update_mp_end_port)\n\t\tadapter->if_ops.update_mp_end_port(adapter,\n\t\t\t\t\tle16_to_cpu(hw_spec->mp_end_port));\n\n\tif (adapter->fw_api_ver == MWIFIEX_FW_V15)\n\t\tadapter->scan_chan_gap_enabled = true;\n\n\treturn 0;\n}\n\n \nint mwifiex_ret_wakeup_reason(struct mwifiex_private *priv,\n\t\t\t      struct host_cmd_ds_command *resp,\n\t\t\t      struct host_cmd_ds_wakeup_reason *wakeup_reason)\n{\n\twakeup_reason->wakeup_reason =\n\t\tresp->params.hs_wakeup_reason.wakeup_reason;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}