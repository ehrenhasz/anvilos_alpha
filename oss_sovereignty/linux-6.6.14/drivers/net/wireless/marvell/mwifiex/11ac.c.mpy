{
  "module_name": "11ac.c",
  "hash_id": "369e730bade31865f2fbe1ed7218fabe00f79a86bde72154abc9d420013141b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/11ac.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"11ac.h\"\n\n \nstatic const u16 max_rate_lgi_80MHZ[8][3] = {\n\t{0x124, 0x15F, 0x186},\t \n\t{0x249, 0x2BE, 0x30C},   \n\t{0x36D, 0x41D, 0x492},   \n\t{0x492, 0x57C, 0x618},   \n\t{0x5B6, 0x6DB, 0x79E},   \n\t{0x6DB, 0x83A, 0x0},     \n\t{0x7FF, 0x999, 0xAAA},   \n\t{0x924, 0xAF8, 0xC30}    \n};\n\nstatic const u16 max_rate_lgi_160MHZ[8][3] = {\n\t{0x249, 0x2BE, 0x30C},    \n\t{0x492, 0x57C, 0x618},    \n\t{0x6DB, 0x83A, 0x0},      \n\t{0x924, 0xAF8, 0xC30},    \n\t{0xB6D, 0xDB6, 0xF3C},    \n\t{0xDB6, 0x1074, 0x1248},  \n\t{0xFFF, 0x1332, 0x1554},  \n\t{0x1248, 0x15F0, 0x1860}  \n};\n\n \nstatic u16\nmwifiex_convert_mcsmap_to_maxrate(struct mwifiex_private *priv,\n\t\t\t\t  u8 bands, u16 mcs_map)\n{\n\tu8 i, nss, mcs;\n\tu16 max_rate = 0;\n\tu32 usr_vht_cap_info = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tif (bands & BAND_AAC)\n\t\tusr_vht_cap_info = adapter->usr_dot_11ac_dev_cap_a;\n\telse\n\t\tusr_vht_cap_info = adapter->usr_dot_11ac_dev_cap_bg;\n\n\t \n\tnss = 1;\n\tfor (i = 1; i <= 8; i++) {\n\t\tmcs = GET_VHTNSSMCS(mcs_map, i);\n\t\tif (mcs < IEEE80211_VHT_MCS_NOT_SUPPORTED)\n\t\t\tnss = i;\n\t}\n\tmcs = GET_VHTNSSMCS(mcs_map, nss);\n\n\t \n\tif (mcs == IEEE80211_VHT_MCS_NOT_SUPPORTED)\n\t\tmcs = IEEE80211_VHT_MCS_SUPPORT_0_9;\n\n\tif (GET_VHTCAP_CHWDSET(usr_vht_cap_info)) {\n\t\t \n\t\tmax_rate = max_rate_lgi_160MHZ[nss - 1][mcs];\n\t\tif (!max_rate)\n\t\t\t \n\t\t\tmax_rate = max_rate_lgi_160MHZ[nss - 1][mcs - 1];\n\t} else {\n\t\tmax_rate = max_rate_lgi_80MHZ[nss - 1][mcs];\n\t\tif (!max_rate)\n\t\t\t \n\t\t\tmax_rate = max_rate_lgi_80MHZ[nss - 1][mcs - 1];\n\t}\n\n\treturn max_rate;\n}\n\nstatic void\nmwifiex_fill_vht_cap_info(struct mwifiex_private *priv,\n\t\t\t  struct ieee80211_vht_cap *vht_cap, u8 bands)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tif (bands & BAND_A)\n\t\tvht_cap->vht_cap_info =\n\t\t\t\tcpu_to_le32(adapter->usr_dot_11ac_dev_cap_a);\n\telse\n\t\tvht_cap->vht_cap_info =\n\t\t\t\tcpu_to_le32(adapter->usr_dot_11ac_dev_cap_bg);\n}\n\nvoid mwifiex_fill_vht_cap_tlv(struct mwifiex_private *priv,\n\t\t\t      struct ieee80211_vht_cap *vht_cap, u8 bands)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu16 mcs_map_user, mcs_map_resp, mcs_map_result;\n\tu16 mcs_user, mcs_resp, nss, tmp;\n\n\t \n\tmwifiex_fill_vht_cap_info(priv, vht_cap, bands);\n\n\t \n\tmcs_map_user = GET_DEVRXMCSMAP(adapter->usr_dot_11ac_mcs_support);\n\tmcs_map_resp = le16_to_cpu(vht_cap->supp_mcs.rx_mcs_map);\n\tmcs_map_result = 0;\n\n\tfor (nss = 1; nss <= 8; nss++) {\n\t\tmcs_user = GET_VHTNSSMCS(mcs_map_user, nss);\n\t\tmcs_resp = GET_VHTNSSMCS(mcs_map_resp, nss);\n\n\t\tif ((mcs_user == IEEE80211_VHT_MCS_NOT_SUPPORTED) ||\n\t\t    (mcs_resp == IEEE80211_VHT_MCS_NOT_SUPPORTED))\n\t\t\tSET_VHTNSSMCS(mcs_map_result, nss,\n\t\t\t\t      IEEE80211_VHT_MCS_NOT_SUPPORTED);\n\t\telse\n\t\t\tSET_VHTNSSMCS(mcs_map_result, nss,\n\t\t\t\t      min(mcs_user, mcs_resp));\n\t}\n\n\tvht_cap->supp_mcs.rx_mcs_map = cpu_to_le16(mcs_map_result);\n\n\ttmp = mwifiex_convert_mcsmap_to_maxrate(priv, bands, mcs_map_result);\n\tvht_cap->supp_mcs.rx_highest = cpu_to_le16(tmp);\n\n\t \n\tmcs_map_user = GET_DEVTXMCSMAP(adapter->usr_dot_11ac_mcs_support);\n\tmcs_map_resp = le16_to_cpu(vht_cap->supp_mcs.tx_mcs_map);\n\tmcs_map_result = 0;\n\n\tfor (nss = 1; nss <= 8; nss++) {\n\t\tmcs_user = GET_VHTNSSMCS(mcs_map_user, nss);\n\t\tmcs_resp = GET_VHTNSSMCS(mcs_map_resp, nss);\n\t\tif ((mcs_user == IEEE80211_VHT_MCS_NOT_SUPPORTED) ||\n\t\t    (mcs_resp == IEEE80211_VHT_MCS_NOT_SUPPORTED))\n\t\t\tSET_VHTNSSMCS(mcs_map_result, nss,\n\t\t\t\t      IEEE80211_VHT_MCS_NOT_SUPPORTED);\n\t\telse\n\t\t\tSET_VHTNSSMCS(mcs_map_result, nss,\n\t\t\t\t      min(mcs_user, mcs_resp));\n\t}\n\n\tvht_cap->supp_mcs.tx_mcs_map = cpu_to_le16(mcs_map_result);\n\n\ttmp = mwifiex_convert_mcsmap_to_maxrate(priv, bands, mcs_map_result);\n\tvht_cap->supp_mcs.tx_highest = cpu_to_le16(tmp);\n\n\treturn;\n}\n\nint mwifiex_cmd_append_11ac_tlv(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_bssdescriptor *bss_desc,\n\t\t\t     u8 **buffer)\n{\n\tstruct mwifiex_ie_types_vhtcap *vht_cap;\n\tstruct mwifiex_ie_types_oper_mode_ntf *oper_ntf;\n\tstruct ieee_types_oper_mode_ntf *ieee_oper_ntf;\n\tstruct mwifiex_ie_types_vht_oper *vht_op;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu8 supp_chwd_set;\n\tu32 usr_vht_cap_info;\n\tint ret_len = 0;\n\n\tif (bss_desc->bss_band & BAND_A)\n\t\tusr_vht_cap_info = adapter->usr_dot_11ac_dev_cap_a;\n\telse\n\t\tusr_vht_cap_info = adapter->usr_dot_11ac_dev_cap_bg;\n\n\t \n\tif (bss_desc->bcn_vht_cap) {\n\t\tvht_cap = (struct mwifiex_ie_types_vhtcap *)*buffer;\n\t\tmemset(vht_cap, 0, sizeof(*vht_cap));\n\t\tvht_cap->header.type = cpu_to_le16(WLAN_EID_VHT_CAPABILITY);\n\t\tvht_cap->header.len  =\n\t\t\t\tcpu_to_le16(sizeof(struct ieee80211_vht_cap));\n\t\tmemcpy((u8 *)vht_cap + sizeof(struct mwifiex_ie_types_header),\n\t\t       (u8 *)bss_desc->bcn_vht_cap,\n\t\t       le16_to_cpu(vht_cap->header.len));\n\n\t\tmwifiex_fill_vht_cap_tlv(priv, &vht_cap->vht_cap,\n\t\t\t\t\t bss_desc->bss_band);\n\t\t*buffer += sizeof(*vht_cap);\n\t\tret_len += sizeof(*vht_cap);\n\t}\n\n\t \n\tif (bss_desc->bcn_vht_oper) {\n\t\tif (priv->bss_mode == NL80211_IFTYPE_STATION) {\n\t\t\tvht_op = (struct mwifiex_ie_types_vht_oper *)*buffer;\n\t\t\tmemset(vht_op, 0, sizeof(*vht_op));\n\t\t\tvht_op->header.type =\n\t\t\t\t\tcpu_to_le16(WLAN_EID_VHT_OPERATION);\n\t\t\tvht_op->header.len  = cpu_to_le16(sizeof(*vht_op) -\n\t\t\t\t      sizeof(struct mwifiex_ie_types_header));\n\t\t\tmemcpy((u8 *)vht_op +\n\t\t\t\tsizeof(struct mwifiex_ie_types_header),\n\t\t\t       (u8 *)bss_desc->bcn_vht_oper,\n\t\t\t       le16_to_cpu(vht_op->header.len));\n\n\t\t\t \n\t\t\tsupp_chwd_set = GET_VHTCAP_CHWDSET(usr_vht_cap_info);\n\n\t\t\tswitch (supp_chwd_set) {\n\t\t\tcase 0:\n\t\t\t\tvht_op->chan_width =\n\t\t\t\t     min_t(u8, IEEE80211_VHT_CHANWIDTH_80MHZ,\n\t\t\t\t\t   bss_desc->bcn_vht_oper->chan_width);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tvht_op->chan_width =\n\t\t\t\t     min_t(u8, IEEE80211_VHT_CHANWIDTH_160MHZ,\n\t\t\t\t\t   bss_desc->bcn_vht_oper->chan_width);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tvht_op->chan_width =\n\t\t\t\t     min_t(u8, IEEE80211_VHT_CHANWIDTH_80P80MHZ,\n\t\t\t\t\t   bss_desc->bcn_vht_oper->chan_width);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvht_op->chan_width =\n\t\t\t\t     IEEE80211_VHT_CHANWIDTH_USE_HT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t*buffer += sizeof(*vht_op);\n\t\t\tret_len += sizeof(*vht_op);\n\t\t}\n\t}\n\n\t \n\tif (bss_desc->oper_mode) {\n\t\tieee_oper_ntf = bss_desc->oper_mode;\n\t\toper_ntf = (void *)*buffer;\n\t\tmemset(oper_ntf, 0, sizeof(*oper_ntf));\n\t\toper_ntf->header.type = cpu_to_le16(WLAN_EID_OPMODE_NOTIF);\n\t\toper_ntf->header.len = cpu_to_le16(sizeof(u8));\n\t\toper_ntf->oper_mode = ieee_oper_ntf->oper_mode;\n\t\t*buffer += sizeof(*oper_ntf);\n\t\tret_len += sizeof(*oper_ntf);\n\t}\n\n\treturn ret_len;\n}\n\nint mwifiex_cmd_11ac_cfg(struct mwifiex_private *priv,\n\t\t\t struct host_cmd_ds_command *cmd, u16 cmd_action,\n\t\t\t struct mwifiex_11ac_vht_cfg *cfg)\n{\n\tstruct host_cmd_11ac_vht_cfg *vhtcfg = &cmd->params.vht_cfg;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_11AC_CFG);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_11ac_vht_cfg) +\n\t\t\t\tS_DS_GEN);\n\tvhtcfg->action = cpu_to_le16(cmd_action);\n\tvhtcfg->band_config = cfg->band_config;\n\tvhtcfg->misc_config = cfg->misc_config;\n\tvhtcfg->cap_info = cpu_to_le32(cfg->cap_info);\n\tvhtcfg->mcs_tx_set = cpu_to_le32(cfg->mcs_tx_set);\n\tvhtcfg->mcs_rx_set = cpu_to_le32(cfg->mcs_rx_set);\n\n\treturn 0;\n}\n\n \nvoid mwifiex_set_11ac_ba_params(struct mwifiex_private *priv)\n{\n\tpriv->add_ba_param.timeout = MWIFIEX_DEFAULT_BLOCK_ACK_TIMEOUT;\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\n\t\tpriv->add_ba_param.tx_win_size =\n\t\t\t\t\t   MWIFIEX_11AC_UAP_AMPDU_DEF_TXWINSIZE;\n\t\tpriv->add_ba_param.rx_win_size =\n\t\t\t\t\t   MWIFIEX_11AC_UAP_AMPDU_DEF_RXWINSIZE;\n\t} else {\n\t\tpriv->add_ba_param.tx_win_size =\n\t\t\t\t\t   MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tpriv->add_ba_param.rx_win_size =\n\t\t\t\t\t   MWIFIEX_11AC_STA_AMPDU_DEF_RXWINSIZE;\n\t}\n\n\treturn;\n}\n\nbool mwifiex_is_bss_in_11ac_mode(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tstruct ieee80211_vht_operation *vht_oper;\n\n\tbss_desc = &priv->curr_bss_params.bss_descriptor;\n\tvht_oper = bss_desc->bcn_vht_oper;\n\n\tif (!bss_desc->bcn_vht_cap || !vht_oper)\n\t\treturn false;\n\n\tif (vht_oper->chan_width == IEEE80211_VHT_CHANWIDTH_USE_HT)\n\t\treturn false;\n\n\treturn true;\n}\n\nu8 mwifiex_get_center_freq_index(struct mwifiex_private *priv, u8 band,\n\t\t\t\t u32 pri_chan, u8 chan_bw)\n{\n\tu8 center_freq_idx = 0;\n\n\tif (band & BAND_AAC) {\n\t\tswitch (pri_chan) {\n\t\tcase 36:\n\t\tcase 40:\n\t\tcase 44:\n\t\tcase 48:\n\t\t\tif (chan_bw == IEEE80211_VHT_CHANWIDTH_80MHZ)\n\t\t\t\tcenter_freq_idx = 42;\n\t\t\tbreak;\n\t\tcase 52:\n\t\tcase 56:\n\t\tcase 60:\n\t\tcase 64:\n\t\t\tif (chan_bw == IEEE80211_VHT_CHANWIDTH_80MHZ)\n\t\t\t\tcenter_freq_idx = 58;\n\t\t\telse if (chan_bw == IEEE80211_VHT_CHANWIDTH_160MHZ)\n\t\t\t\tcenter_freq_idx = 50;\n\t\t\tbreak;\n\t\tcase 100:\n\t\tcase 104:\n\t\tcase 108:\n\t\tcase 112:\n\t\t\tif (chan_bw == IEEE80211_VHT_CHANWIDTH_80MHZ)\n\t\t\t\tcenter_freq_idx = 106;\n\t\t\tbreak;\n\t\tcase 116:\n\t\tcase 120:\n\t\tcase 124:\n\t\tcase 128:\n\t\t\tif (chan_bw == IEEE80211_VHT_CHANWIDTH_80MHZ)\n\t\t\t\tcenter_freq_idx = 122;\n\t\t\telse if (chan_bw == IEEE80211_VHT_CHANWIDTH_160MHZ)\n\t\t\t\tcenter_freq_idx = 114;\n\t\t\tbreak;\n\t\tcase 132:\n\t\tcase 136:\n\t\tcase 140:\n\t\tcase 144:\n\t\t\tif (chan_bw == IEEE80211_VHT_CHANWIDTH_80MHZ)\n\t\t\t\tcenter_freq_idx = 138;\n\t\t\tbreak;\n\t\tcase 149:\n\t\tcase 153:\n\t\tcase 157:\n\t\tcase 161:\n\t\t\tif (chan_bw == IEEE80211_VHT_CHANWIDTH_80MHZ)\n\t\t\t\tcenter_freq_idx = 155;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcenter_freq_idx = 42;\n\t\t}\n\t}\n\n\treturn center_freq_idx;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}