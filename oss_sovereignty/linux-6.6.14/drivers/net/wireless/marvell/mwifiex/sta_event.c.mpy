{
  "module_name": "sta_event.c",
  "hash_id": "1c640d46e8fbb6c3f7d84b04f32f6d20b7c30145e318b966dbac6cd8715e9807",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/sta_event.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n\n#define MWIFIEX_IBSS_CONNECT_EVT_FIX_SIZE    12\n\nstatic int mwifiex_check_ibss_peer_capabilities(struct mwifiex_private *priv,\n\t\t\t\t\t        struct mwifiex_sta_node *sta_ptr,\n\t\t\t\t\t        struct sk_buff *event)\n{\n\tint evt_len, ele_len;\n\tu8 *curr;\n\tstruct ieee_types_header *ele_hdr;\n\tstruct mwifiex_ie_types_mgmt_frame *tlv_mgmt_frame;\n\tconst struct ieee80211_ht_cap *ht_cap;\n\tconst struct ieee80211_vht_cap *vht_cap;\n\n\tskb_pull(event, MWIFIEX_IBSS_CONNECT_EVT_FIX_SIZE);\n\tevt_len = event->len;\n\tcurr = event->data;\n\n\tmwifiex_dbg_dump(priv->adapter, EVT_D, \"ibss peer capabilities:\",\n\t\t\t event->data, event->len);\n\n\tskb_push(event, MWIFIEX_IBSS_CONNECT_EVT_FIX_SIZE);\n\n\ttlv_mgmt_frame = (void *)curr;\n\tif (evt_len >= sizeof(*tlv_mgmt_frame) &&\n\t    le16_to_cpu(tlv_mgmt_frame->header.type) ==\n\t    TLV_TYPE_UAP_MGMT_FRAME) {\n\t\t \n\t\tevt_len = le16_to_cpu(tlv_mgmt_frame->header.len);\n\t\tcurr += (sizeof(*tlv_mgmt_frame) + 12);\n\t} else {\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"management frame tlv not found!\\n\");\n\t\treturn 0;\n\t}\n\n\twhile (evt_len >= sizeof(*ele_hdr)) {\n\t\tele_hdr = (struct ieee_types_header *)curr;\n\t\tele_len = ele_hdr->len;\n\n\t\tif (evt_len < ele_len + sizeof(*ele_hdr))\n\t\t\tbreak;\n\n\t\tswitch (ele_hdr->element_id) {\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\t\tsta_ptr->is_11n_enabled = true;\n\t\t\tht_cap = (void *)(ele_hdr + 2);\n\t\t\tsta_ptr->max_amsdu = le16_to_cpu(ht_cap->cap_info) &\n\t\t\t\tIEEE80211_HT_CAP_MAX_AMSDU ?\n\t\t\t\tMWIFIEX_TX_DATA_BUF_SIZE_8K :\n\t\t\t\tMWIFIEX_TX_DATA_BUF_SIZE_4K;\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"11n enabled!, max_amsdu : %d\\n\",\n\t\t\t\t    sta_ptr->max_amsdu);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\t\tsta_ptr->is_11ac_enabled = true;\n\t\t\tvht_cap = (void *)(ele_hdr + 2);\n\t\t\t \n\t\t\tswitch (le32_to_cpu(vht_cap->vht_cap_info) & 0x3) {\n\t\t\tcase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454:\n\t\t\t\tsta_ptr->max_amsdu =\n\t\t\t\t\tMWIFIEX_TX_DATA_BUF_SIZE_12K;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991:\n\t\t\t\tsta_ptr->max_amsdu =\n\t\t\t\t\tMWIFIEX_TX_DATA_BUF_SIZE_8K;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895:\n\t\t\t\tsta_ptr->max_amsdu =\n\t\t\t\t\tMWIFIEX_TX_DATA_BUF_SIZE_4K;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"11ac enabled!, max_amsdu : %d\\n\",\n\t\t\t\t    sta_ptr->max_amsdu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr += (ele_len + sizeof(*ele_hdr));\n\t\tevt_len -= (ele_len + sizeof(*ele_hdr));\n\t}\n\n\treturn 0;\n}\n\n \nvoid mwifiex_reset_connect_state(struct mwifiex_private *priv, u16 reason_code,\n\t\t\t\t bool from_ap)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tif (!priv->media_connected)\n\t\treturn;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: handles disconnect event\\n\");\n\n\tpriv->media_connected = false;\n\n\tpriv->scan_block = false;\n\tpriv->port_open = false;\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info)) {\n\t\tmwifiex_disable_all_tdls_links(priv);\n\n\t\tif (priv->adapter->auto_tdls)\n\t\t\tmwifiex_clean_auto_tdls(priv);\n\t}\n\n\t \n\tmwifiex_clean_txrx(priv);\n\n\t \n\tpriv->data_rssi_last = 0;\n\tpriv->data_nf_last = 0;\n\tpriv->data_rssi_avg = 0;\n\tpriv->data_nf_avg = 0;\n\tpriv->bcn_rssi_last = 0;\n\tpriv->bcn_nf_last = 0;\n\tpriv->bcn_rssi_avg = 0;\n\tpriv->bcn_nf_avg = 0;\n\tpriv->rxpd_rate = 0;\n\tpriv->rxpd_htinfo = 0;\n\tpriv->sec_info.wpa_enabled = false;\n\tpriv->sec_info.wpa2_enabled = false;\n\tpriv->wpa_ie_len = 0;\n\n\tpriv->sec_info.wapi_enabled = false;\n\tpriv->wapi_ie_len = 0;\n\tpriv->sec_info.wapi_key_on = false;\n\n\tpriv->sec_info.encryption_mode = 0;\n\n\t \n\tpriv->is_data_rate_auto = true;\n\tpriv->data_rate = 0;\n\n\tpriv->assoc_resp_ht_param = 0;\n\tpriv->ht_param_present = false;\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA ||\n\t     GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && priv->hist_data)\n\t\tmwifiex_hist_data_reset(priv);\n\n\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC) {\n\t\tpriv->adhoc_state = ADHOC_IDLE;\n\t\tpriv->adhoc_is_link_sensed = false;\n\t}\n\n\t \n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: previous SSID=%s, SSID len=%u\\n\",\n\t\t    priv->prev_ssid.ssid, priv->prev_ssid.ssid_len);\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: current SSID=%s, SSID len=%u\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.ssid.ssid,\n\t\t    priv->curr_bss_params.bss_descriptor.ssid.ssid_len);\n\n\tmemcpy(&priv->prev_ssid,\n\t       &priv->curr_bss_params.bss_descriptor.ssid,\n\t       sizeof(struct cfg80211_ssid));\n\n\tmemcpy(priv->prev_bssid,\n\t       priv->curr_bss_params.bss_descriptor.mac_address, ETH_ALEN);\n\n\t \n\tmemset(&priv->curr_bss_params, 0x00, sizeof(priv->curr_bss_params));\n\n\tadapter->tx_lock_flag = false;\n\tadapter->pps_uapsd_mode = false;\n\n\tif (test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags) &&\n\t    adapter->curr_cmd)\n\t\treturn;\n\tpriv->media_connected = false;\n\tmwifiex_dbg(adapter, MSG,\n\t\t    \"info: successfully disconnected from %pM: reason code %d\\n\",\n\t\t    priv->cfg_bssid, reason_code);\n\tif (priv->bss_mode == NL80211_IFTYPE_STATION ||\n\t    priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT) {\n\t\tcfg80211_disconnected(priv->netdev, reason_code, NULL, 0,\n\t\t\t\t      !from_ap, GFP_KERNEL);\n\t}\n\teth_zero_addr(priv->cfg_bssid);\n\n\tmwifiex_stop_net_dev_queue(priv->netdev, adapter);\n\tif (netif_carrier_ok(priv->netdev))\n\t\tnetif_carrier_off(priv->netdev);\n\n\tif (!ISSUPP_FIRMWARE_SUPPLICANT(priv->adapter->fw_cap_info))\n\t\treturn;\n\n\tmwifiex_send_cmd(priv, HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG,\n\t\t\t HostCmd_ACT_GEN_REMOVE, 0, NULL, false);\n}\n\nstatic int mwifiex_parse_tdls_event(struct mwifiex_private *priv,\n\t\t\t\t    struct sk_buff *event_skb)\n{\n\tint ret = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_sta_node *sta_ptr;\n\tstruct mwifiex_tdls_generic_event *tdls_evt =\n\t\t\t(void *)event_skb->data + sizeof(adapter->event_cause);\n\tu8 *mac = tdls_evt->peer_mac;\n\n\t \n\tif (event_skb->len < (sizeof(struct mwifiex_tdls_generic_event) -\n\t\t\t      sizeof(u16) - sizeof(adapter->event_cause))) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Invalid event length!\\n\");\n\t\treturn -1;\n\t}\n\n\tsta_ptr = mwifiex_get_sta_entry(priv, tdls_evt->peer_mac);\n\tif (!sta_ptr) {\n\t\tmwifiex_dbg(adapter, ERROR, \"cannot get sta entry!\\n\");\n\t\treturn -1;\n\t}\n\n\tswitch (le16_to_cpu(tdls_evt->type)) {\n\tcase TDLS_EVENT_LINK_TEAR_DOWN:\n\t\tcfg80211_tdls_oper_request(priv->netdev,\n\t\t\t\t\t   tdls_evt->peer_mac,\n\t\t\t\t\t   NL80211_TDLS_TEARDOWN,\n\t\t\t\t\t   le16_to_cpu(tdls_evt->u.reason_code),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tbreak;\n\tcase TDLS_EVENT_CHAN_SWITCH_RESULT:\n\t\tmwifiex_dbg(adapter, EVENT, \"tdls channel switch result :\\n\");\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"status=0x%x, reason=0x%x cur_chan=%d\\n\",\n\t\t\t    tdls_evt->u.switch_result.status,\n\t\t\t    tdls_evt->u.switch_result.reason,\n\t\t\t    tdls_evt->u.switch_result.cur_chan);\n\n\t\t \n\t\tif (tdls_evt->u.switch_result.status != 0) {\n\t\t\tswitch (tdls_evt->u.switch_result.cur_chan) {\n\t\t\tcase TDLS_BASE_CHANNEL:\n\t\t\t\tsta_ptr->tdls_status = TDLS_IN_BASE_CHAN;\n\t\t\t\tbreak;\n\t\t\tcase TDLS_OFF_CHANNEL:\n\t\t\t\tsta_ptr->tdls_status = TDLS_IN_OFF_CHAN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tswitch (tdls_evt->u.switch_result.cur_chan) {\n\t\tcase TDLS_BASE_CHANNEL:\n\t\t\tif (sta_ptr->tdls_status == TDLS_IN_BASE_CHAN)\n\t\t\t\tbreak;\n\t\t\tmwifiex_update_ralist_tx_pause_in_tdls_cs(priv, mac,\n\t\t\t\t\t\t\t\t  false);\n\t\t\tsta_ptr->tdls_status = TDLS_IN_BASE_CHAN;\n\t\t\tbreak;\n\t\tcase TDLS_OFF_CHANNEL:\n\t\t\tif (sta_ptr->tdls_status == TDLS_IN_OFF_CHAN)\n\t\t\t\tbreak;\n\t\t\tmwifiex_update_ralist_tx_pause_in_tdls_cs(priv, mac,\n\t\t\t\t\t\t\t\t  true);\n\t\t\tsta_ptr->tdls_status = TDLS_IN_OFF_CHAN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase TDLS_EVENT_START_CHAN_SWITCH:\n\t\tmwifiex_dbg(adapter, EVENT, \"tdls start channel switch...\\n\");\n\t\tsta_ptr->tdls_status = TDLS_CHAN_SWITCHING;\n\t\tbreak;\n\tcase TDLS_EVENT_CHAN_SWITCH_STOPPED:\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"tdls chan switch stopped, reason=%d\\n\",\n\t\t\t    tdls_evt->u.cs_stop_reason);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void mwifiex_process_uap_tx_pause(struct mwifiex_private *priv,\n\t\t\t\t\t struct mwifiex_ie_types_header *tlv)\n{\n\tstruct mwifiex_tx_pause_tlv *tp;\n\tstruct mwifiex_sta_node *sta_ptr;\n\n\ttp = (void *)tlv;\n\tmwifiex_dbg(priv->adapter, EVENT,\n\t\t    \"uap tx_pause: %pM pause=%d, pkts=%d\\n\",\n\t\t    tp->peermac, tp->tx_pause,\n\t\t    tp->pkt_cnt);\n\n\tif (ether_addr_equal(tp->peermac, priv->netdev->dev_addr)) {\n\t\tif (tp->tx_pause)\n\t\t\tpriv->port_open = false;\n\t\telse\n\t\t\tpriv->port_open = true;\n\t} else if (is_multicast_ether_addr(tp->peermac)) {\n\t\tmwifiex_update_ralist_tx_pause(priv, tp->peermac, tp->tx_pause);\n\t} else {\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, tp->peermac);\n\t\tif (sta_ptr && sta_ptr->tx_pause != tp->tx_pause) {\n\t\t\tsta_ptr->tx_pause = tp->tx_pause;\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_update_ralist_tx_pause(priv, tp->peermac,\n\t\t\t\t\t\t       tp->tx_pause);\n\t\t} else {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t}\n\t}\n}\n\nstatic void mwifiex_process_sta_tx_pause(struct mwifiex_private *priv,\n\t\t\t\t\t struct mwifiex_ie_types_header *tlv)\n{\n\tstruct mwifiex_tx_pause_tlv *tp;\n\tstruct mwifiex_sta_node *sta_ptr;\n\tint status;\n\n\ttp = (void *)tlv;\n\tmwifiex_dbg(priv->adapter, EVENT,\n\t\t    \"sta tx_pause: %pM pause=%d, pkts=%d\\n\",\n\t\t    tp->peermac, tp->tx_pause,\n\t\t    tp->pkt_cnt);\n\n\tif (ether_addr_equal(tp->peermac, priv->cfg_bssid)) {\n\t\tif (tp->tx_pause)\n\t\t\tpriv->port_open = false;\n\t\telse\n\t\t\tpriv->port_open = true;\n\t} else {\n\t\tif (!ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info))\n\t\t\treturn;\n\n\t\tstatus = mwifiex_get_tdls_link_status(priv, tp->peermac);\n\t\tif (mwifiex_is_tdls_link_setup(status)) {\n\t\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\t\tsta_ptr = mwifiex_get_sta_entry(priv, tp->peermac);\n\t\t\tif (sta_ptr && sta_ptr->tx_pause != tp->tx_pause) {\n\t\t\t\tsta_ptr->tx_pause = tp->tx_pause;\n\t\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\t\tmwifiex_update_ralist_tx_pause(priv,\n\t\t\t\t\t\t\t       tp->peermac,\n\t\t\t\t\t\t\t       tp->tx_pause);\n\t\t\t} else {\n\t\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mwifiex_process_multi_chan_event(struct mwifiex_private *priv,\n\t\t\t\t      struct sk_buff *event_skb)\n{\n\tstruct mwifiex_ie_types_multi_chan_info *chan_info;\n\tstruct mwifiex_ie_types_mc_group_info *grp_info;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_ie_types_header *tlv;\n\tu16 tlv_buf_left, tlv_type, tlv_len;\n\tint intf_num, bss_type, bss_num, i;\n\tstruct mwifiex_private *intf_priv;\n\n\ttlv_buf_left = event_skb->len - sizeof(u32);\n\tchan_info = (void *)event_skb->data + sizeof(u32);\n\n\tif (le16_to_cpu(chan_info->header.type) != TLV_TYPE_MULTI_CHAN_INFO ||\n\t    tlv_buf_left < sizeof(struct mwifiex_ie_types_multi_chan_info)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"unknown TLV in chan_info event\\n\");\n\t\treturn;\n\t}\n\n\tadapter->usb_mc_status = le16_to_cpu(chan_info->status);\n\tmwifiex_dbg(adapter, EVENT, \"multi chan operation %s\\n\",\n\t\t    adapter->usb_mc_status ? \"started\" : \"over\");\n\n\ttlv_buf_left -= sizeof(struct mwifiex_ie_types_multi_chan_info);\n\ttlv = (struct mwifiex_ie_types_header *)chan_info->tlv_buffer;\n\n\twhile (tlv_buf_left >= (int)sizeof(struct mwifiex_ie_types_header)) {\n\t\ttlv_type = le16_to_cpu(tlv->type);\n\t\ttlv_len  = le16_to_cpu(tlv->len);\n\t\tif ((sizeof(struct mwifiex_ie_types_header) + tlv_len) >\n\t\t    tlv_buf_left) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"wrong tlv: tlvLen=%d,\\t\"\n\t\t\t\t    \"tlvBufLeft=%d\\n\", tlv_len, tlv_buf_left);\n\t\t\tbreak;\n\t\t}\n\t\tif (tlv_type != TLV_TYPE_MC_GROUP_INFO) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"wrong tlv type: 0x%x\\n\",\n\t\t\t\t    tlv_type);\n\t\t\tbreak;\n\t\t}\n\n\t\tgrp_info = (struct mwifiex_ie_types_mc_group_info *)tlv;\n\t\tintf_num = grp_info->intf_num;\n\t\tfor (i = 0; i < intf_num; i++) {\n\t\t\tbss_type = grp_info->bss_type_numlist[i] >> 4;\n\t\t\tbss_num = grp_info->bss_type_numlist[i] & BSS_NUM_MASK;\n\t\t\tintf_priv = mwifiex_get_priv_by_id(adapter, bss_num,\n\t\t\t\t\t\t\t   bss_type);\n\t\t\tif (!intf_priv) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"Invalid bss_type bss_num\\t\"\n\t\t\t\t\t    \"in multi channel event\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\t\t\tu8 ep;\n\n\t\t\t\tep = grp_info->hid_num.usb_ep_num;\n\t\t\t\tif (ep == MWIFIEX_USB_EP_DATA ||\n\t\t\t\t    ep == MWIFIEX_USB_EP_DATA_CH2)\n\t\t\t\t\tintf_priv->usb_port = ep;\n\t\t\t}\n\t\t}\n\n\t\ttlv_buf_left -= sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\ttlv_len;\n\t\ttlv = (void *)((u8 *)tlv + tlv_len +\n\t\t\t       sizeof(struct mwifiex_ie_types_header));\n\t}\n\n\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\tadapter->tx_lock_flag = true;\n\t\tadapter->usb_mc_setup = true;\n\t\tmwifiex_multi_chan_resync(adapter);\n\t}\n}\n\nvoid mwifiex_process_tx_pause_event(struct mwifiex_private *priv,\n\t\t\t\t    struct sk_buff *event_skb)\n{\n\tstruct mwifiex_ie_types_header *tlv;\n\tu16 tlv_type, tlv_len;\n\tint tlv_buf_left;\n\n\tif (!priv->media_connected) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"tx_pause event while disconnected; bss_role=%d\\n\",\n\t\t\t    priv->bss_role);\n\t\treturn;\n\t}\n\n\ttlv_buf_left = event_skb->len - sizeof(u32);\n\ttlv = (void *)event_skb->data + sizeof(u32);\n\n\twhile (tlv_buf_left >= (int)sizeof(struct mwifiex_ie_types_header)) {\n\t\ttlv_type = le16_to_cpu(tlv->type);\n\t\ttlv_len  = le16_to_cpu(tlv->len);\n\t\tif ((sizeof(struct mwifiex_ie_types_header) + tlv_len) >\n\t\t    tlv_buf_left) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"wrong tlv: tlvLen=%d, tlvBufLeft=%d\\n\",\n\t\t\t\t    tlv_len, tlv_buf_left);\n\t\t\tbreak;\n\t\t}\n\t\tif (tlv_type == TLV_TYPE_TX_PAUSE) {\n\t\t\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA)\n\t\t\t\tmwifiex_process_sta_tx_pause(priv, tlv);\n\t\t\telse\n\t\t\t\tmwifiex_process_uap_tx_pause(priv, tlv);\n\t\t}\n\n\t\ttlv_buf_left -= sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\ttlv_len;\n\t\ttlv = (void *)((u8 *)tlv + tlv_len +\n\t\t\t       sizeof(struct mwifiex_ie_types_header));\n\t}\n\n}\n\n \nvoid mwifiex_bt_coex_wlan_param_update_event(struct mwifiex_private *priv,\n\t\t\t\t\t     struct sk_buff *event_skb)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_ie_types_header *tlv;\n\tstruct mwifiex_ie_types_btcoex_aggr_win_size *winsizetlv;\n\tstruct mwifiex_ie_types_btcoex_scan_time *scantlv;\n\ts32 len = event_skb->len - sizeof(u32);\n\tu8 *cur_ptr = event_skb->data + sizeof(u32);\n\tu16 tlv_type, tlv_len;\n\n\twhile (len >= sizeof(struct mwifiex_ie_types_header)) {\n\t\ttlv = (struct mwifiex_ie_types_header *)cur_ptr;\n\t\ttlv_len = le16_to_cpu(tlv->len);\n\t\ttlv_type = le16_to_cpu(tlv->type);\n\n\t\tif ((tlv_len + sizeof(struct mwifiex_ie_types_header)) > len)\n\t\t\tbreak;\n\t\tswitch (tlv_type) {\n\t\tcase TLV_BTCOEX_WL_AGGR_WINSIZE:\n\t\t\twinsizetlv =\n\t\t\t    (struct mwifiex_ie_types_btcoex_aggr_win_size *)tlv;\n\t\t\tadapter->coex_win_size = winsizetlv->coex_win_size;\n\t\t\tadapter->coex_tx_win_size =\n\t\t\t\twinsizetlv->tx_win_size;\n\t\t\tadapter->coex_rx_win_size =\n\t\t\t\twinsizetlv->rx_win_size;\n\t\t\tmwifiex_coex_ampdu_rxwinsize(adapter);\n\t\t\tmwifiex_update_ampdu_txwinsize(adapter);\n\t\t\tbreak;\n\n\t\tcase TLV_BTCOEX_WL_SCANTIME:\n\t\t\tscantlv =\n\t\t\t    (struct mwifiex_ie_types_btcoex_scan_time *)tlv;\n\t\t\tadapter->coex_scan = scantlv->coex_scan;\n\t\t\tadapter->coex_min_scan_time = le16_to_cpu(scantlv->min_scan_time);\n\t\t\tadapter->coex_max_scan_time = le16_to_cpu(scantlv->max_scan_time);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tlen -= tlv_len + sizeof(struct mwifiex_ie_types_header);\n\t\tcur_ptr += tlv_len +\n\t\t\tsizeof(struct mwifiex_ie_types_header);\n\t}\n\n\tdev_dbg(adapter->dev, \"coex_scan=%d min_scan=%d coex_win=%d, tx_win=%d rx_win=%d\\n\",\n\t\tadapter->coex_scan, adapter->coex_min_scan_time,\n\t\tadapter->coex_win_size, adapter->coex_tx_win_size,\n\t\tadapter->coex_rx_win_size);\n}\n\nstatic void\nmwifiex_fw_dump_info_event(struct mwifiex_private *priv,\n\t\t\t   struct sk_buff *event_skb)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_fw_dump_header *fw_dump_hdr =\n\t\t\t\t(void *)adapter->event_body;\n\n\tif (adapter->iface_type != MWIFIEX_USB) {\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"event is not on usb interface, ignore it\\n\");\n\t\treturn;\n\t}\n\n\tif (!adapter->devdump_data) {\n\t\t \n\t\tadapter->devdump_data = vzalloc(MWIFIEX_FW_DUMP_SIZE);\n\t\tif (!adapter->devdump_data) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"vzalloc devdump data failure!\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tmwifiex_drv_info_dump(adapter);\n\n\t\t \n\t\tschedule_delayed_work(&adapter->devdump_work,\n\t\t\t\t      msecs_to_jiffies(MWIFIEX_TIMER_10S));\n\t}\n\n\t \n\tif (adapter->devdump_len + event_skb->len >= MWIFIEX_FW_DUMP_SIZE)\n\t\tgoto upload_dump;\n\n\tmemmove(adapter->devdump_data + adapter->devdump_len,\n\t\tadapter->event_skb->data, event_skb->len);\n\tadapter->devdump_len += event_skb->len;\n\n\tif (le16_to_cpu(fw_dump_hdr->type) == FW_DUMP_INFO_ENDED) {\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"receive end of transmission flag event!\\n\");\n\t\tgoto upload_dump;\n\t}\n\treturn;\n\nupload_dump:\n\tcancel_delayed_work_sync(&adapter->devdump_work);\n\tmwifiex_upload_device_dump(adapter);\n}\n\n \nint mwifiex_process_sta_event(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret = 0, i;\n\tu32 eventcause = adapter->event_cause;\n\tu16 ctrl, reason_code;\n\tu8 ibss_sta_addr[ETH_ALEN];\n\tstruct mwifiex_sta_node *sta_ptr;\n\n\tswitch (eventcause) {\n\tcase EVENT_DUMMY_HOST_WAKEUP_SIGNAL:\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"invalid EVENT: DUMMY_HOST_WAKEUP_SIGNAL, ignore it\\n\");\n\t\tbreak;\n\tcase EVENT_LINK_SENSED:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: LINK_SENSED\\n\");\n\t\tif (!netif_carrier_ok(priv->netdev))\n\t\t\tnetif_carrier_on(priv->netdev);\n\t\tmwifiex_wake_up_net_dev_queue(priv->netdev, adapter);\n\t\tbreak;\n\n\tcase EVENT_DEAUTHENTICATED:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Deauthenticated\\n\");\n\t\tif (priv->wps.session_enable) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: receive deauth event in wps session\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tadapter->dbg.num_event_deauth++;\n\t\tif (priv->media_connected) {\n\t\t\treason_code =\n\t\t\t\tget_unaligned_le16(adapter->event_body);\n\t\t\tmwifiex_reset_connect_state(priv, reason_code, true);\n\t\t}\n\t\tbreak;\n\n\tcase EVENT_DISASSOCIATED:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Disassociated\\n\");\n\t\tif (priv->wps.session_enable) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: receive disassoc event in wps session\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tadapter->dbg.num_event_disassoc++;\n\t\tif (priv->media_connected) {\n\t\t\treason_code =\n\t\t\t\tget_unaligned_le16(adapter->event_body);\n\t\t\tmwifiex_reset_connect_state(priv, reason_code, true);\n\t\t}\n\t\tbreak;\n\n\tcase EVENT_LINK_LOST:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Link lost\\n\");\n\t\tadapter->dbg.num_event_link_lost++;\n\t\tif (priv->media_connected) {\n\t\t\treason_code =\n\t\t\t\tget_unaligned_le16(adapter->event_body);\n\t\t\tmwifiex_reset_connect_state(priv, reason_code, true);\n\t\t}\n\t\tbreak;\n\n\tcase EVENT_PS_SLEEP:\n\t\tmwifiex_dbg(adapter, EVENT, \"info: EVENT: SLEEP\\n\");\n\n\t\tadapter->ps_state = PS_STATE_PRE_SLEEP;\n\n\t\tmwifiex_check_ps_cond(adapter);\n\t\tbreak;\n\n\tcase EVENT_PS_AWAKE:\n\t\tmwifiex_dbg(adapter, EVENT, \"info: EVENT: AWAKE\\n\");\n\t\tif (!adapter->pps_uapsd_mode &&\n\t\t    (priv->port_open ||\n\t\t     (priv->bss_mode == NL80211_IFTYPE_ADHOC)) &&\n\t\t    priv->media_connected && adapter->sleep_period.period) {\n\t\t\tadapter->pps_uapsd_mode = true;\n\t\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t\t    \"event: PPS/UAPSD mode activated\\n\");\n\t\t}\n\t\tadapter->tx_lock_flag = false;\n\t\tif (adapter->pps_uapsd_mode && adapter->gen_null_pkt) {\n\t\t\tif (mwifiex_check_last_packet_indication(priv)) {\n\t\t\t\tif (adapter->data_sent ||\n\t\t\t\t    (adapter->if_ops.is_port_ready &&\n\t\t\t\t     !adapter->if_ops.is_port_ready(priv))) {\n\t\t\t\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t\t\t\t\tadapter->pm_wakeup_card_req = false;\n\t\t\t\t\tadapter->pm_wakeup_fw_try = false;\n\t\t\t\t\tdel_timer(&adapter->wakeup_timer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!mwifiex_send_null_packet\n\t\t\t\t\t(priv,\n\t\t\t\t\t MWIFIEX_TxPD_POWER_MGMT_NULL_PACKET |\n\t\t\t\t\t MWIFIEX_TxPD_POWER_MGMT_LAST_PACKET))\n\t\t\t\t\t\tadapter->ps_state =\n\t\t\t\t\t\t\tPS_STATE_SLEEP;\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t\tadapter->pm_wakeup_card_req = false;\n\t\tadapter->pm_wakeup_fw_try = false;\n\t\tdel_timer(&adapter->wakeup_timer);\n\n\t\tbreak;\n\n\tcase EVENT_DEEP_SLEEP_AWAKE:\n\t\tadapter->if_ops.wakeup_complete(adapter);\n\t\tmwifiex_dbg(adapter, EVENT, \"event: DS_AWAKE\\n\");\n\t\tif (adapter->is_deep_sleep)\n\t\t\tadapter->is_deep_sleep = false;\n\t\tbreak;\n\n\tcase EVENT_HS_ACT_REQ:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: HS_ACT_REQ\\n\");\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_HS_CFG_ENH,\n\t\t\t\t       0, 0, NULL, false);\n\t\tbreak;\n\n\tcase EVENT_MIC_ERR_UNICAST:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: UNICAST MIC ERROR\\n\");\n\t\tcfg80211_michael_mic_failure(priv->netdev, priv->cfg_bssid,\n\t\t\t\t\t     NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t\t     -1, NULL, GFP_KERNEL);\n\t\tbreak;\n\n\tcase EVENT_MIC_ERR_MULTICAST:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: MULTICAST MIC ERROR\\n\");\n\t\tcfg80211_michael_mic_failure(priv->netdev, priv->cfg_bssid,\n\t\t\t\t\t     NL80211_KEYTYPE_GROUP,\n\t\t\t\t\t     -1, NULL, GFP_KERNEL);\n\t\tbreak;\n\tcase EVENT_MIB_CHANGED:\n\tcase EVENT_INIT_DONE:\n\t\tbreak;\n\n\tcase EVENT_ADHOC_BCN_LOST:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: ADHOC_BCN_LOST\\n\");\n\t\tpriv->adhoc_is_link_sensed = false;\n\t\tmwifiex_clean_txrx(priv);\n\t\tmwifiex_stop_net_dev_queue(priv->netdev, adapter);\n\t\tif (netif_carrier_ok(priv->netdev))\n\t\t\tnetif_carrier_off(priv->netdev);\n\t\tbreak;\n\n\tcase EVENT_BG_SCAN_REPORT:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: BGS_REPORT\\n\");\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_BG_SCAN_QUERY,\n\t\t\t\t       HostCmd_ACT_GEN_GET, 0, NULL, false);\n\t\tbreak;\n\n\tcase EVENT_BG_SCAN_STOPPED:\n\t\tdev_dbg(adapter->dev, \"event: BGS_STOPPED\\n\");\n\t\tcfg80211_sched_scan_stopped(priv->wdev.wiphy, 0);\n\t\tif (priv->sched_scanning)\n\t\t\tpriv->sched_scanning = false;\n\t\tbreak;\n\n\tcase EVENT_PORT_RELEASE:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: PORT RELEASE\\n\");\n\t\tpriv->port_open = true;\n\t\tbreak;\n\n\tcase EVENT_EXT_SCAN_REPORT:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: EXT_SCAN Report\\n\");\n\t\t \n\t\tif (adapter->ext_scan && (!priv->scan_aborting ||\n\t\t\t\t\t  !netif_running(priv->netdev)))\n\t\t\tret = mwifiex_handle_event_ext_scan_report(priv,\n\t\t\t\t\t\tadapter->event_skb->data);\n\n\t\tbreak;\n\n\tcase EVENT_WMM_STATUS_CHANGE:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: WMM status changed\\n\");\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_WMM_GET_STATUS,\n\t\t\t\t       0, 0, NULL, false);\n\t\tbreak;\n\n\tcase EVENT_RSSI_LOW:\n\t\tcfg80211_cqm_rssi_notify(priv->netdev,\n\t\t\t\t\t NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,\n\t\t\t\t\t 0, GFP_KERNEL);\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_RSSI_INFO,\n\t\t\t\t HostCmd_ACT_GEN_GET, 0, NULL, false);\n\t\tpriv->subsc_evt_rssi_state = RSSI_LOW_RECVD;\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Beacon RSSI_LOW\\n\");\n\t\tbreak;\n\tcase EVENT_SNR_LOW:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Beacon SNR_LOW\\n\");\n\t\tbreak;\n\tcase EVENT_MAX_FAIL:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: MAX_FAIL\\n\");\n\t\tbreak;\n\tcase EVENT_RSSI_HIGH:\n\t\tcfg80211_cqm_rssi_notify(priv->netdev,\n\t\t\t\t\t NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,\n\t\t\t\t\t 0, GFP_KERNEL);\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_RSSI_INFO,\n\t\t\t\t HostCmd_ACT_GEN_GET, 0, NULL, false);\n\t\tpriv->subsc_evt_rssi_state = RSSI_HIGH_RECVD;\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Beacon RSSI_HIGH\\n\");\n\t\tbreak;\n\tcase EVENT_SNR_HIGH:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Beacon SNR_HIGH\\n\");\n\t\tbreak;\n\tcase EVENT_DATA_RSSI_LOW:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Data RSSI_LOW\\n\");\n\t\tbreak;\n\tcase EVENT_DATA_SNR_LOW:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Data SNR_LOW\\n\");\n\t\tbreak;\n\tcase EVENT_DATA_RSSI_HIGH:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Data RSSI_HIGH\\n\");\n\t\tbreak;\n\tcase EVENT_DATA_SNR_HIGH:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Data SNR_HIGH\\n\");\n\t\tbreak;\n\tcase EVENT_LINK_QUALITY:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Link Quality\\n\");\n\t\tbreak;\n\tcase EVENT_PRE_BEACON_LOST:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Pre-Beacon Lost\\n\");\n\t\tbreak;\n\tcase EVENT_IBSS_COALESCED:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: IBSS_COALESCED\\n\");\n\t\tret = mwifiex_send_cmd(priv,\n\t\t\t\tHostCmd_CMD_802_11_IBSS_COALESCING_STATUS,\n\t\t\t\tHostCmd_ACT_GEN_GET, 0, NULL, false);\n\t\tbreak;\n\tcase EVENT_IBSS_STA_CONNECT:\n\t\tether_addr_copy(ibss_sta_addr, adapter->event_body + 2);\n\t\tmwifiex_dbg(adapter, EVENT, \"event: IBSS_STA_CONNECT %pM\\n\",\n\t\t\t    ibss_sta_addr);\n\t\tsta_ptr = mwifiex_add_sta_entry(priv, ibss_sta_addr);\n\t\tif (sta_ptr && adapter->adhoc_11n_enabled) {\n\t\t\tmwifiex_check_ibss_peer_capabilities(priv, sta_ptr,\n\t\t\t\t\t\t\t     adapter->event_skb);\n\t\t\tif (sta_ptr->is_11n_enabled)\n\t\t\t\tfor (i = 0; i < MAX_NUM_TID; i++)\n\t\t\t\t\tsta_ptr->ampdu_sta[i] =\n\t\t\t\t\tpriv->aggr_prio_tbl[i].ampdu_user;\n\t\t\telse\n\t\t\t\tfor (i = 0; i < MAX_NUM_TID; i++)\n\t\t\t\t\tsta_ptr->ampdu_sta[i] =\n\t\t\t\t\t\tBA_STREAM_NOT_ALLOWED;\n\t\t\tmemset(sta_ptr->rx_seq, 0xff, sizeof(sta_ptr->rx_seq));\n\t\t}\n\n\t\tbreak;\n\tcase EVENT_IBSS_STA_DISCONNECT:\n\t\tether_addr_copy(ibss_sta_addr, adapter->event_body + 2);\n\t\tmwifiex_dbg(adapter, EVENT, \"event: IBSS_STA_DISCONNECT %pM\\n\",\n\t\t\t    ibss_sta_addr);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, ibss_sta_addr);\n\t\tif (sta_ptr && sta_ptr->is_11n_enabled) {\n\t\t\tmwifiex_11n_del_rx_reorder_tbl_by_ta(priv,\n\t\t\t\t\t\t\t     ibss_sta_addr);\n\t\t\tmwifiex_del_tx_ba_stream_tbl_by_ra(priv, ibss_sta_addr);\n\t\t}\n\t\tmwifiex_wmm_del_peer_ra_list(priv, ibss_sta_addr);\n\t\tmwifiex_del_sta_entry(priv, ibss_sta_addr);\n\t\tbreak;\n\tcase EVENT_ADDBA:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: ADDBA Request\\n\");\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_RSP,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t adapter->event_body, false);\n\t\tbreak;\n\tcase EVENT_DELBA:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: DELBA Request\\n\");\n\t\tmwifiex_11n_delete_ba_stream(priv, adapter->event_body);\n\t\tbreak;\n\tcase EVENT_BA_STREAM_TIEMOUT:\n\t\tmwifiex_dbg(adapter, EVENT, \"event:  BA Stream timeout\\n\");\n\t\tmwifiex_11n_ba_stream_timeout(priv,\n\t\t\t\t\t      (struct host_cmd_ds_11n_batimeout\n\t\t\t\t\t       *)\n\t\t\t\t\t      adapter->event_body);\n\t\tbreak;\n\tcase EVENT_AMSDU_AGGR_CTRL:\n\t\tctrl = get_unaligned_le16(adapter->event_body);\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"event: AMSDU_AGGR_CTRL %d\\n\", ctrl);\n\n\t\tadapter->tx_buf_size =\n\t\t\t\tmin_t(u16, adapter->curr_tx_buf_size, ctrl);\n\t\tmwifiex_dbg(adapter, EVENT, \"event: tx_buf_size %d\\n\",\n\t\t\t    adapter->tx_buf_size);\n\t\tbreak;\n\n\tcase EVENT_WEP_ICV_ERR:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: WEP ICV error\\n\");\n\t\tbreak;\n\n\tcase EVENT_BW_CHANGE:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: BW Change\\n\");\n\t\tbreak;\n\n\tcase EVENT_HOSTWAKE_STAIE:\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"event: HOSTWAKE_STAIE %d\\n\", eventcause);\n\t\tbreak;\n\n\tcase EVENT_REMAIN_ON_CHAN_EXPIRED:\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"event: Remain on channel expired\\n\");\n\t\tcfg80211_remain_on_channel_expired(&priv->wdev,\n\t\t\t\t\t\t   priv->roc_cfg.cookie,\n\t\t\t\t\t\t   &priv->roc_cfg.chan,\n\t\t\t\t\t\t   GFP_ATOMIC);\n\n\t\tmemset(&priv->roc_cfg, 0x00, sizeof(struct mwifiex_roc_cfg));\n\n\t\tbreak;\n\n\tcase EVENT_CHANNEL_SWITCH_ANN:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Channel Switch Announcement\\n\");\n\t\tpriv->csa_expire_time =\n\t\t\t\tjiffies + msecs_to_jiffies(DFS_CHAN_MOVE_TIME);\n\t\tpriv->csa_chan = priv->curr_bss_params.bss_descriptor.channel;\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_DEAUTHENTICATE,\n\t\t\tHostCmd_ACT_GEN_SET, 0,\n\t\t\tpriv->curr_bss_params.bss_descriptor.mac_address,\n\t\t\tfalse);\n\t\tbreak;\n\n\tcase EVENT_TDLS_GENERIC_EVENT:\n\t\tret = mwifiex_parse_tdls_event(priv, adapter->event_skb);\n\t\tbreak;\n\n\tcase EVENT_TX_DATA_PAUSE:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: TX DATA PAUSE\\n\");\n\t\tmwifiex_process_tx_pause_event(priv, adapter->event_skb);\n\t\tbreak;\n\n\tcase EVENT_MULTI_CHAN_INFO:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: multi-chan info\\n\");\n\t\tmwifiex_process_multi_chan_event(priv, adapter->event_skb);\n\t\tbreak;\n\n\tcase EVENT_TX_STATUS_REPORT:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: TX_STATUS Report\\n\");\n\t\tmwifiex_parse_tx_status_event(priv, adapter->event_body);\n\t\tbreak;\n\n\tcase EVENT_CHANNEL_REPORT_RDY:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Channel Report\\n\");\n\t\tret = mwifiex_11h_handle_chanrpt_ready(priv,\n\t\t\t\t\t\t       adapter->event_skb);\n\t\tbreak;\n\tcase EVENT_RADAR_DETECTED:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Radar detected\\n\");\n\t\tret = mwifiex_11h_handle_radar_detected(priv,\n\t\t\t\t\t\t\tadapter->event_skb);\n\t\tbreak;\n\tcase EVENT_BT_COEX_WLAN_PARA_CHANGE:\n\t\tdev_dbg(adapter->dev, \"EVENT: BT coex wlan param update\\n\");\n\t\tif (adapter->ignore_btcoex_events)\n\t\t\tbreak;\n\n\t\tmwifiex_bt_coex_wlan_param_update_event(priv,\n\t\t\t\t\t\t\tadapter->event_skb);\n\t\tbreak;\n\tcase EVENT_RXBA_SYNC:\n\t\tdev_dbg(adapter->dev, \"EVENT: RXBA_SYNC\\n\");\n\t\tmwifiex_11n_rxba_sync_event(priv, adapter->event_body,\n\t\t\t\t\t    adapter->event_skb->len -\n\t\t\t\t\t    sizeof(eventcause));\n\t\tbreak;\n\tcase EVENT_FW_DUMP_INFO:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: firmware debug info\\n\");\n\t\tmwifiex_fw_dump_info_event(priv, adapter->event_skb);\n\t\tbreak;\n\t \n\tcase EVENT_UNKNOWN_DEBUG:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: debug\\n\");\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(adapter, ERROR, \"event: unknown event id: %#x\\n\",\n\t\t\t    eventcause);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}