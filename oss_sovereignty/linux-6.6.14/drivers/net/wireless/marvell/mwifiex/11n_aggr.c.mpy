{
  "module_name": "11n_aggr.c",
  "hash_id": "22d5db8b94a72c33f46b6ee272559066b2b1a2aa11bf219bb8da6e940e54d0ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/11n_aggr.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"11n_aggr.h\"\n\n \nstatic int\nmwifiex_11n_form_amsdu_pkt(struct sk_buff *skb_aggr,\n\t\t\t   struct sk_buff *skb_src, int *pad)\n\n{\n\tint dt_offset;\n\tstruct rfc_1042_hdr snap = {\n\t\t0xaa,\t\t \n\t\t0xaa,\t\t \n\t\t0x03,\t\t \n\t\t{0x00, 0x00, 0x00},\t \n\t\t0x0000\t\t \n\t\t\t \n\t};\n\tstruct tx_packet_hdr *tx_header;\n\n\ttx_header = skb_put(skb_aggr, sizeof(*tx_header));\n\n\t \n\tdt_offset = 2 * ETH_ALEN;\n\tmemcpy(&tx_header->eth803_hdr, skb_src->data, dt_offset);\n\n\t \n\tsnap.snap_type = ((struct ethhdr *)skb_src->data)->h_proto;\n\n\tdt_offset += sizeof(__be16);\n\n\tmemcpy(&tx_header->rfc1042_hdr, &snap, sizeof(struct rfc_1042_hdr));\n\n\tskb_pull(skb_src, dt_offset);\n\n\t \n\ttx_header->eth803_hdr.h_proto = htons(skb_src->len + LLC_SNAP_LEN);\n\n\t \n\tskb_put_data(skb_aggr, skb_src->data, skb_src->len);\n\n\t \n\t*pad = (4 - ((unsigned long)skb_aggr->tail & 0x3)) % 4;\n\n\treturn skb_aggr->len + *pad;\n}\n\n \nstatic void\nmwifiex_11n_form_amsdu_txpd(struct mwifiex_private *priv,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct txpd *local_tx_pd;\n\tstruct mwifiex_txinfo *tx_info = MWIFIEX_SKB_TXCB(skb);\n\n\tskb_push(skb, sizeof(*local_tx_pd));\n\n\tlocal_tx_pd = (struct txpd *) skb->data;\n\tmemset(local_tx_pd, 0, sizeof(struct txpd));\n\n\t \n\tlocal_tx_pd->priority = (u8) skb->priority;\n\tlocal_tx_pd->pkt_delay_2ms =\n\t\tmwifiex_wmm_compute_drv_pkt_delay(priv, skb);\n\tlocal_tx_pd->bss_num = priv->bss_num;\n\tlocal_tx_pd->bss_type = priv->bss_type;\n\t \n\tlocal_tx_pd->tx_pkt_offset = cpu_to_le16(sizeof(struct txpd));\n\tlocal_tx_pd->tx_pkt_type = cpu_to_le16(PKT_TYPE_AMSDU);\n\tlocal_tx_pd->tx_pkt_length = cpu_to_le16(skb->len -\n\t\t\t\t\t\t sizeof(*local_tx_pd));\n\n\tif (tx_info->flags & MWIFIEX_BUF_FLAG_TDLS_PKT)\n\t\tlocal_tx_pd->flags |= MWIFIEX_TXPD_FLAGS_TDLS_PACKET;\n\n\tif (local_tx_pd->tx_control == 0)\n\t\t \n\t\tlocal_tx_pd->tx_control = cpu_to_le32(priv->pkt_tx_ctrl);\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA &&\n\t    priv->adapter->pps_uapsd_mode) {\n\t\tif (true == mwifiex_check_last_packet_indication(priv)) {\n\t\t\tpriv->adapter->tx_lock_flag = true;\n\t\t\tlocal_tx_pd->flags =\n\t\t\t\tMWIFIEX_TxPD_POWER_MGMT_LAST_PACKET;\n\t\t}\n\t}\n}\n\n \nint\nmwifiex_11n_aggregate_pkt(struct mwifiex_private *priv,\n\t\t\t  struct mwifiex_ra_list_tbl *pra_list,\n\t\t\t  int ptrindex)\n\t\t\t  __releases(&priv->wmm.ra_list_spinlock)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct sk_buff *skb_aggr, *skb_src;\n\tstruct mwifiex_txinfo *tx_info_aggr, *tx_info_src;\n\tint pad = 0, aggr_num = 0, ret;\n\tstruct mwifiex_tx_param tx_param;\n\tstruct txpd *ptx_pd = NULL;\n\tint headroom = adapter->intf_hdr_len;\n\n\tskb_src = skb_peek(&pra_list->skb_head);\n\tif (!skb_src) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\treturn 0;\n\t}\n\n\ttx_info_src = MWIFIEX_SKB_TXCB(skb_src);\n\tskb_aggr = mwifiex_alloc_dma_align_buf(adapter->tx_buf_size,\n\t\t\t\t\t       GFP_ATOMIC);\n\tif (!skb_aggr) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\treturn -1;\n\t}\n\n\t \n\tskb_reserve(skb_aggr, headroom + sizeof(struct txpd));\n\ttx_info_aggr =  MWIFIEX_SKB_TXCB(skb_aggr);\n\n\tmemset(tx_info_aggr, 0, sizeof(*tx_info_aggr));\n\ttx_info_aggr->bss_type = tx_info_src->bss_type;\n\ttx_info_aggr->bss_num = tx_info_src->bss_num;\n\n\tif (tx_info_src->flags & MWIFIEX_BUF_FLAG_TDLS_PKT)\n\t\ttx_info_aggr->flags |= MWIFIEX_BUF_FLAG_TDLS_PKT;\n\ttx_info_aggr->flags |= MWIFIEX_BUF_FLAG_AGGR_PKT;\n\tskb_aggr->priority = skb_src->priority;\n\tskb_aggr->tstamp = skb_src->tstamp;\n\n\tdo {\n\t\t \n\t\tif ((skb_aggr->len + skb_src->len + LLC_SNAP_LEN) >\n\t\t    adapter->tx_buf_size)\n\t\t\tbreak;\n\n\t\tskb_src = skb_dequeue(&pra_list->skb_head);\n\t\tpra_list->total_pkt_count--;\n\t\tatomic_dec(&priv->wmm.tx_pkts_queued);\n\t\taggr_num++;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tmwifiex_11n_form_amsdu_pkt(skb_aggr, skb_src, &pad);\n\n\t\tmwifiex_write_data_complete(adapter, skb_src, 0, 0);\n\n\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\t\tif (!mwifiex_is_ralist_valid(priv, pra_list, ptrindex)) {\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (skb_tailroom(skb_aggr) < pad) {\n\t\t\tpad = 0;\n\t\t\tbreak;\n\t\t}\n\t\tskb_put(skb_aggr, pad);\n\n\t\tskb_src = skb_peek(&pra_list->skb_head);\n\n\t} while (skb_src);\n\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\n\t \n\tskb_trim(skb_aggr, skb_aggr->len - pad);\n\n\t \n\tmwifiex_11n_form_amsdu_txpd(priv, skb_aggr);\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA)\n\t\tptx_pd = (struct txpd *)skb_aggr->data;\n\n\tskb_push(skb_aggr, headroom);\n\ttx_info_aggr->aggr_num = aggr_num * 2;\n\tif (adapter->data_sent || adapter->tx_lock_flag) {\n\t\tatomic_add(aggr_num * 2, &adapter->tx_queued);\n\t\tskb_queue_tail(&adapter->tx_data_q, skb_aggr);\n\t\treturn 0;\n\t}\n\n\tif (skb_src)\n\t\ttx_param.next_pkt_len = skb_src->len + sizeof(struct txpd);\n\telse\n\t\ttx_param.next_pkt_len = 0;\n\n\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\tret = adapter->if_ops.host_to_card(adapter, priv->usb_port,\n\t\t\t\t\t\t   skb_aggr, &tx_param);\n\t} else {\n\n\t\tret = adapter->if_ops.host_to_card(adapter, MWIFIEX_TYPE_DATA,\n\t\t\t\t\t\t   skb_aggr, &tx_param);\n\t}\n\tswitch (ret) {\n\tcase -EBUSY:\n\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\t\tif (!mwifiex_is_ralist_valid(priv, pra_list, ptrindex)) {\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\tmwifiex_write_data_complete(adapter, skb_aggr, 1, -1);\n\t\t\treturn -1;\n\t\t}\n\t\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA &&\n\t\t    adapter->pps_uapsd_mode && adapter->tx_lock_flag) {\n\t\t\t\tpriv->adapter->tx_lock_flag = false;\n\t\t\t\tif (ptx_pd)\n\t\t\t\t\tptx_pd->flags = 0;\n\t\t}\n\n\t\tskb_queue_tail(&pra_list->skb_head, skb_aggr);\n\n\t\tpra_list->total_pkt_count++;\n\n\t\tatomic_inc(&priv->wmm.tx_pkts_queued);\n\n\t\ttx_info_aggr->flags |= MWIFIEX_BUF_FLAG_REQUEUED_PKT;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tmwifiex_dbg(adapter, ERROR, \"data: -EBUSY is returned\\n\");\n\t\tbreak;\n\tcase -1:\n\t\tmwifiex_dbg(adapter, ERROR, \"%s: host_to_card failed: %#x\\n\",\n\t\t\t    __func__, ret);\n\t\tadapter->dbg.num_tx_host_to_card_failure++;\n\t\tmwifiex_write_data_complete(adapter, skb_aggr, 1, ret);\n\t\treturn 0;\n\tcase -EINPROGRESS:\n\t\tbreak;\n\tcase 0:\n\t\tmwifiex_write_data_complete(adapter, skb_aggr, 1, ret);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (ret != -EBUSY) {\n\t\tmwifiex_rotate_priolists(priv, pra_list, ptrindex);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}