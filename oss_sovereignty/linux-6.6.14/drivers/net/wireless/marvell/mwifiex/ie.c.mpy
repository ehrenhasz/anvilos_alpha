{
  "module_name": "ie.c",
  "hash_id": "3f8acdb17199b9839c545e869e63c00d2235cf5c07882f98496a26fea28bbc4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/ie.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n\n \nstatic int\nmwifiex_ie_index_used_by_other_intf(struct mwifiex_private *priv, u16 idx)\n{\n\tint i;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_ie *ie;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (adapter->priv[i] != priv) {\n\t\t\tie = &adapter->priv[i]->mgmt_ie[idx];\n\t\t\tif (ie->mgmt_subtype_mask && ie->ie_length)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_ie_get_autoidx(struct mwifiex_private *priv, u16 subtype_mask,\n\t\t       struct mwifiex_ie *ie, u16 *index)\n{\n\tu16 mask, len, i;\n\n\tfor (i = 0; i < priv->adapter->max_mgmt_ie_index; i++) {\n\t\tmask = le16_to_cpu(priv->mgmt_ie[i].mgmt_subtype_mask);\n\t\tlen = le16_to_cpu(ie->ie_length);\n\n\t\tif (mask == MWIFIEX_AUTO_IDX_MASK)\n\t\t\tcontinue;\n\n\t\tif (mask == subtype_mask) {\n\t\t\tif (len > IEEE_MAX_IE_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!priv->mgmt_ie[i].ie_length) {\n\t\t\tif (mwifiex_ie_index_used_by_other_intf(priv, i))\n\t\t\t\tcontinue;\n\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n \nstatic int\nmwifiex_update_autoindex_ies(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_ie_list *ie_list)\n{\n\tu16 travel_len, index, mask;\n\ts16 input_len, tlv_len;\n\tstruct mwifiex_ie *ie;\n\tu8 *tmp;\n\n\tinput_len = le16_to_cpu(ie_list->len);\n\ttravel_len = sizeof(struct mwifiex_ie_types_header);\n\n\tie_list->len = 0;\n\n\twhile (input_len >= sizeof(struct mwifiex_ie_types_header)) {\n\t\tie = (struct mwifiex_ie *)(((u8 *)ie_list) + travel_len);\n\t\ttlv_len = le16_to_cpu(ie->ie_length);\n\t\ttravel_len += tlv_len + MWIFIEX_IE_HDR_SIZE;\n\n\t\tif (input_len < tlv_len + MWIFIEX_IE_HDR_SIZE)\n\t\t\treturn -1;\n\t\tindex = le16_to_cpu(ie->ie_index);\n\t\tmask = le16_to_cpu(ie->mgmt_subtype_mask);\n\n\t\tif (index == MWIFIEX_AUTO_IDX_MASK) {\n\t\t\t \n\t\t\tif (mwifiex_ie_get_autoidx(priv, mask, ie, &index))\n\t\t\t\treturn -1;\n\t\t\tif (index == MWIFIEX_AUTO_IDX_MASK)\n\t\t\t\treturn -1;\n\n\t\t\ttmp = (u8 *)&priv->mgmt_ie[index].ie_buffer;\n\t\t\tmemcpy(tmp, &ie->ie_buffer, le16_to_cpu(ie->ie_length));\n\t\t\tpriv->mgmt_ie[index].ie_length = ie->ie_length;\n\t\t\tpriv->mgmt_ie[index].ie_index = cpu_to_le16(index);\n\t\t\tpriv->mgmt_ie[index].mgmt_subtype_mask =\n\t\t\t\t\t\t\tcpu_to_le16(mask);\n\n\t\t\tie->ie_index = cpu_to_le16(index);\n\t\t} else {\n\t\t\tif (mask != MWIFIEX_DELETE_MASK)\n\t\t\t\treturn -1;\n\t\t\t \n\t\t\tif (mwifiex_ie_index_used_by_other_intf(priv, index))\n\t\t\t\treturn -1;\n\n\t\t\tie->ie_length = 0;\n\t\t\tmemcpy(&priv->mgmt_ie[index], ie,\n\t\t\t       sizeof(struct mwifiex_ie));\n\t\t}\n\n\t\tle16_unaligned_add_cpu(&ie_list->len,\n\t\t\t\t       le16_to_cpu(\n\t\t\t\t\t    priv->mgmt_ie[index].ie_length) +\n\t\t\t\t       MWIFIEX_IE_HDR_SIZE);\n\t\tinput_len -= tlv_len + MWIFIEX_IE_HDR_SIZE;\n\t}\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP)\n\t\treturn mwifiex_send_cmd(priv, HostCmd_CMD_UAP_SYS_CONFIG,\n\t\t\t\t\tHostCmd_ACT_GEN_SET,\n\t\t\t\t\tUAP_CUSTOM_IE_I, ie_list, true);\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_update_uap_custom_ie(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_ie *beacon_ie, u16 *beacon_idx,\n\t\t\t     struct mwifiex_ie *pr_ie, u16 *probe_idx,\n\t\t\t     struct mwifiex_ie *ar_ie, u16 *assoc_idx)\n{\n\tstruct mwifiex_ie_list *ap_custom_ie;\n\tu8 *pos;\n\tu16 len;\n\tint ret;\n\n\tap_custom_ie = kzalloc(sizeof(*ap_custom_ie), GFP_KERNEL);\n\tif (!ap_custom_ie)\n\t\treturn -ENOMEM;\n\n\tap_custom_ie->type = cpu_to_le16(TLV_TYPE_MGMT_IE);\n\tpos = (u8 *)ap_custom_ie->ie_list;\n\n\tif (beacon_ie) {\n\t\tlen = sizeof(struct mwifiex_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(beacon_ie->ie_length);\n\t\tmemcpy(pos, beacon_ie, len);\n\t\tpos += len;\n\t\tle16_unaligned_add_cpu(&ap_custom_ie->len, len);\n\t}\n\tif (pr_ie) {\n\t\tlen = sizeof(struct mwifiex_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(pr_ie->ie_length);\n\t\tmemcpy(pos, pr_ie, len);\n\t\tpos += len;\n\t\tle16_unaligned_add_cpu(&ap_custom_ie->len, len);\n\t}\n\tif (ar_ie) {\n\t\tlen = sizeof(struct mwifiex_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(ar_ie->ie_length);\n\t\tmemcpy(pos, ar_ie, len);\n\t\tpos += len;\n\t\tle16_unaligned_add_cpu(&ap_custom_ie->len, len);\n\t}\n\n\tret = mwifiex_update_autoindex_ies(priv, ap_custom_ie);\n\n\tpos = (u8 *)(&ap_custom_ie->ie_list[0].ie_index);\n\tif (beacon_ie && *beacon_idx == MWIFIEX_AUTO_IDX_MASK) {\n\t\t \n\t\t*beacon_idx = le16_to_cpu(ap_custom_ie->ie_list[0].ie_index);\n\t\tlen = sizeof(*beacon_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(beacon_ie->ie_length);\n\t\tpos += len;\n\t}\n\tif (pr_ie && le16_to_cpu(pr_ie->ie_index) == MWIFIEX_AUTO_IDX_MASK) {\n\t\t \n\t\t*probe_idx = *((u16 *)pos);\n\t\tlen = sizeof(*pr_ie) - IEEE_MAX_IE_SIZE +\n\t\t      le16_to_cpu(pr_ie->ie_length);\n\t\tpos += len;\n\t}\n\tif (ar_ie && le16_to_cpu(ar_ie->ie_index) == MWIFIEX_AUTO_IDX_MASK)\n\t\t \n\t\t*assoc_idx = *((u16 *)pos);\n\n\tkfree(ap_custom_ie);\n\treturn ret;\n}\n\n \nstatic int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\n\t*ie_ptr = ie;\n\treturn 0;\n}\n\n \nstatic int mwifiex_set_mgmt_beacon_data_ies(struct mwifiex_private *priv,\n\t\t\t\t\t    struct cfg80211_beacon_data *data)\n{\n\tstruct mwifiex_ie *beacon_ie = NULL, *pr_ie = NULL, *ar_ie = NULL;\n\tu16 beacon_idx = MWIFIEX_AUTO_IDX_MASK, pr_idx = MWIFIEX_AUTO_IDX_MASK;\n\tu16 ar_idx = MWIFIEX_AUTO_IDX_MASK;\n\tint ret = 0;\n\n\tif (data->beacon_ies && data->beacon_ies_len) {\n\t\tmwifiex_update_vs_ie(data->beacon_ies, data->beacon_ies_len,\n\t\t\t\t     &beacon_ie, MGMT_MASK_BEACON,\n\t\t\t\t     WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->beacon_ies, data->beacon_ies_len,\n\t\t\t\t     &beacon_ie, MGMT_MASK_BEACON,\n\t\t\t\t     WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (data->proberesp_ies && data->proberesp_ies_len) {\n\t\tmwifiex_update_vs_ie(data->proberesp_ies,\n\t\t\t\t     data->proberesp_ies_len, &pr_ie,\n\t\t\t\t     MGMT_MASK_PROBE_RESP, WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->proberesp_ies,\n\t\t\t\t     data->proberesp_ies_len, &pr_ie,\n\t\t\t\t     MGMT_MASK_PROBE_RESP,\n\t\t\t\t     WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (data->assocresp_ies && data->assocresp_ies_len) {\n\t\tmwifiex_update_vs_ie(data->assocresp_ies,\n\t\t\t\t     data->assocresp_ies_len, &ar_ie,\n\t\t\t\t     MGMT_MASK_ASSOC_RESP |\n\t\t\t\t     MGMT_MASK_REASSOC_RESP,\n\t\t\t\t     WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->assocresp_ies,\n\t\t\t\t     data->assocresp_ies_len, &ar_ie,\n\t\t\t\t     MGMT_MASK_ASSOC_RESP |\n\t\t\t\t     MGMT_MASK_REASSOC_RESP, WLAN_OUI_WFA,\n\t\t\t\t     WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (beacon_ie || pr_ie || ar_ie) {\n\t\tret = mwifiex_update_uap_custom_ie(priv, beacon_ie,\n\t\t\t\t\t\t   &beacon_idx, pr_ie,\n\t\t\t\t\t\t   &pr_idx, ar_ie, &ar_idx);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tpriv->beacon_idx = beacon_idx;\n\tpriv->proberesp_idx = pr_idx;\n\tpriv->assocresp_idx = ar_idx;\n\ndone:\n\tkfree(beacon_ie);\n\tkfree(pr_ie);\n\tkfree(ar_ie);\n\n\treturn ret;\n}\n\n \nstatic int mwifiex_uap_parse_tail_ies(struct mwifiex_private *priv,\n\t\t\t\t      struct cfg80211_beacon_data *info)\n{\n\tstruct mwifiex_ie *gen_ie;\n\tstruct ieee_types_header *hdr;\n\tstruct ieee80211_vendor_ie *vendorhdr;\n\tu16 gen_idx = MWIFIEX_AUTO_IDX_MASK, ie_len = 0;\n\tint left_len, parsed_len = 0;\n\tunsigned int token_len;\n\tint err = 0;\n\n\tif (!info->tail || !info->tail_len)\n\t\treturn 0;\n\n\tgen_ie = kzalloc(sizeof(*gen_ie), GFP_KERNEL);\n\tif (!gen_ie)\n\t\treturn -ENOMEM;\n\n\tleft_len = info->tail_len;\n\n\t \n\twhile (left_len > sizeof(struct ieee_types_header)) {\n\t\thdr = (void *)(info->tail + parsed_len);\n\t\ttoken_len = hdr->len + sizeof(struct ieee_types_header);\n\t\tif (token_len > left_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (hdr->element_id) {\n\t\tcase WLAN_EID_SSID:\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\tcase WLAN_EID_COUNTRY:\n\t\tcase WLAN_EID_PWR_CONSTRAINT:\n\t\tcase WLAN_EID_ERP_INFO:\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\tcase WLAN_EID_HT_OPERATION:\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\tcase WLAN_EID_VHT_OPERATION:\n\t\t\tbreak;\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t \n\t\t\tif (cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t\t    (const u8 *)hdr,\n\t\t\t\t\t\t    token_len))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tif (ie_len + token_len > IEEE_MAX_IE_SIZE) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(gen_ie->ie_buffer + ie_len, hdr, token_len);\n\t\t\tie_len += token_len;\n\t\t\tbreak;\n\t\t}\n\t\tleft_len -= token_len;\n\t\tparsed_len += token_len;\n\t}\n\n\t \n\tvendorhdr = (void *)cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t\t    info->tail, info->tail_len);\n\tif (vendorhdr) {\n\t\ttoken_len = vendorhdr->len + sizeof(struct ieee_types_header);\n\t\tif (ie_len + token_len > IEEE_MAX_IE_SIZE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(gen_ie->ie_buffer + ie_len, vendorhdr, token_len);\n\t\tie_len += token_len;\n\t}\n\n\tif (!ie_len)\n\t\tgoto out;\n\n\tgen_ie->ie_index = cpu_to_le16(gen_idx);\n\tgen_ie->mgmt_subtype_mask = cpu_to_le16(MGMT_MASK_BEACON |\n\t\t\t\t\t\tMGMT_MASK_PROBE_RESP |\n\t\t\t\t\t\tMGMT_MASK_ASSOC_RESP);\n\tgen_ie->ie_length = cpu_to_le16(ie_len);\n\n\tif (mwifiex_update_uap_custom_ie(priv, gen_ie, &gen_idx, NULL, NULL,\n\t\t\t\t\t NULL, NULL)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->gen_idx = gen_idx;\n\n out:\n\tkfree(gen_ie);\n\treturn err;\n}\n\n \nint mwifiex_set_mgmt_ies(struct mwifiex_private *priv,\n\t\t\t struct cfg80211_beacon_data *info)\n{\n\tint ret;\n\n\tret = mwifiex_uap_parse_tail_ies(priv, info);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn mwifiex_set_mgmt_beacon_data_ies(priv, info);\n}\n\n \nint mwifiex_del_mgmt_ies(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_ie *beacon_ie = NULL, *pr_ie = NULL;\n\tstruct mwifiex_ie *ar_ie = NULL, *gen_ie = NULL;\n\tint ret = 0;\n\n\tif (priv->gen_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tgen_ie = kmalloc(sizeof(*gen_ie), GFP_KERNEL);\n\t\tif (!gen_ie)\n\t\t\treturn -ENOMEM;\n\n\t\tgen_ie->ie_index = cpu_to_le16(priv->gen_idx);\n\t\tgen_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tgen_ie->ie_length = 0;\n\t\tif (mwifiex_update_uap_custom_ie(priv, gen_ie, &priv->gen_idx,\n\t\t\t\t\t\t NULL, &priv->proberesp_idx,\n\t\t\t\t\t\t NULL, &priv->assocresp_idx)) {\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tpriv->gen_idx = MWIFIEX_AUTO_IDX_MASK;\n\t}\n\n\tif (priv->beacon_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tbeacon_ie = kmalloc(sizeof(struct mwifiex_ie), GFP_KERNEL);\n\t\tif (!beacon_ie) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tbeacon_ie->ie_index = cpu_to_le16(priv->beacon_idx);\n\t\tbeacon_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tbeacon_ie->ie_length = 0;\n\t}\n\tif (priv->proberesp_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tpr_ie = kmalloc(sizeof(struct mwifiex_ie), GFP_KERNEL);\n\t\tif (!pr_ie) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tpr_ie->ie_index = cpu_to_le16(priv->proberesp_idx);\n\t\tpr_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tpr_ie->ie_length = 0;\n\t}\n\tif (priv->assocresp_idx != MWIFIEX_AUTO_IDX_MASK) {\n\t\tar_ie = kmalloc(sizeof(struct mwifiex_ie), GFP_KERNEL);\n\t\tif (!ar_ie) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tar_ie->ie_index = cpu_to_le16(priv->assocresp_idx);\n\t\tar_ie->mgmt_subtype_mask = cpu_to_le16(MWIFIEX_DELETE_MASK);\n\t\tar_ie->ie_length = 0;\n\t}\n\n\tif (beacon_ie || pr_ie || ar_ie)\n\t\tret = mwifiex_update_uap_custom_ie(priv,\n\t\t\t\t\t\t   beacon_ie, &priv->beacon_idx,\n\t\t\t\t\t\t   pr_ie, &priv->proberesp_idx,\n\t\t\t\t\t\t   ar_ie, &priv->assocresp_idx);\n\ndone:\n\tkfree(gen_ie);\n\tkfree(beacon_ie);\n\tkfree(pr_ie);\n\tkfree(ar_ie);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}