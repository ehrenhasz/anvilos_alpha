{
  "module_name": "cfg80211.c",
  "hash_id": "d6a25031193d5e3a979257268a49049eea750ac07ab7d3da1026f088bfd5eadc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/cfg80211.c",
  "human_readable_source": "\n \n\n#include \"cfg80211.h\"\n#include \"main.h\"\n#include \"11n.h\"\n#include \"wmm.h\"\n\nstatic char *reg_alpha2;\nmodule_param(reg_alpha2, charp, 0);\n\nstatic const struct ieee80211_iface_limit mwifiex_ap_sta_limits[] = {\n\t{\n\t\t.max = MWIFIEX_MAX_BSS_NUM,\n\t\t.types = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t   BIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t\t   BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t   BIT(NL80211_IFTYPE_AP),\n\t},\n};\n\nstatic const struct ieee80211_iface_combination\nmwifiex_iface_comb_ap_sta = {\n\t.limits = mwifiex_ap_sta_limits,\n\t.num_different_channels = 1,\n\t.n_limits = ARRAY_SIZE(mwifiex_ap_sta_limits),\n\t.max_interfaces = MWIFIEX_MAX_BSS_NUM,\n\t.beacon_int_infra_match = true,\n\t.radar_detect_widths =\tBIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\tBIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\tBIT(NL80211_CHAN_WIDTH_40),\n};\n\nstatic const struct ieee80211_iface_combination\nmwifiex_iface_comb_ap_sta_vht = {\n\t.limits = mwifiex_ap_sta_limits,\n\t.num_different_channels = 1,\n\t.n_limits = ARRAY_SIZE(mwifiex_ap_sta_limits),\n\t.max_interfaces = MWIFIEX_MAX_BSS_NUM,\n\t.beacon_int_infra_match = true,\n\t.radar_detect_widths =\tBIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\tBIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\tBIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\tBIT(NL80211_CHAN_WIDTH_80),\n};\n\nstatic const struct\nieee80211_iface_combination mwifiex_iface_comb_ap_sta_drcs = {\n\t.limits = mwifiex_ap_sta_limits,\n\t.num_different_channels = 2,\n\t.n_limits = ARRAY_SIZE(mwifiex_ap_sta_limits),\n\t.max_interfaces = MWIFIEX_MAX_BSS_NUM,\n\t.beacon_int_infra_match = true,\n};\n\n \nu8 mwifiex_chan_type_to_sec_chan_offset(enum nl80211_channel_type chan_type)\n{\n\tswitch (chan_type) {\n\tcase NL80211_CHAN_NO_HT:\n\tcase NL80211_CHAN_HT20:\n\t\treturn IEEE80211_HT_PARAM_CHA_SEC_NONE;\n\tcase NL80211_CHAN_HT40PLUS:\n\t\treturn IEEE80211_HT_PARAM_CHA_SEC_ABOVE;\n\tcase NL80211_CHAN_HT40MINUS:\n\t\treturn IEEE80211_HT_PARAM_CHA_SEC_BELOW;\n\tdefault:\n\t\treturn IEEE80211_HT_PARAM_CHA_SEC_NONE;\n\t}\n}\n\n \nu8 mwifiex_get_chan_type(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_channel_band channel_band;\n\tint ret;\n\n\tret = mwifiex_get_chan_info(priv, &channel_band);\n\n\tif (!ret) {\n\t\tswitch (channel_band.band_config.chan_width) {\n\t\tcase CHAN_BW_20MHZ:\n\t\t\tif (IS_11N_ENABLED(priv))\n\t\t\t\treturn NL80211_CHAN_HT20;\n\t\t\telse\n\t\t\t\treturn NL80211_CHAN_NO_HT;\n\t\tcase CHAN_BW_40MHZ:\n\t\t\tif (channel_band.band_config.chan2_offset ==\n\t\t\t    SEC_CHAN_ABOVE)\n\t\t\t\treturn NL80211_CHAN_HT40PLUS;\n\t\t\telse\n\t\t\t\treturn NL80211_CHAN_HT40MINUS;\n\t\tdefault:\n\t\t\treturn NL80211_CHAN_HT20;\n\t\t}\n\t}\n\n\treturn NL80211_CHAN_HT20;\n}\n\n \nstatic int\nmwifiex_is_alg_wep(u32 cipher)\n{\n\tswitch (cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void *mwifiex_cfg80211_get_adapter(struct wiphy *wiphy)\n{\n\treturn (void *) (*(unsigned long *) wiphy_priv(wiphy));\n}\n\n \nstatic int\nmwifiex_cfg80211_del_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t int link_id, u8 key_index, bool pairwise,\n\t\t\t const u8 *mac_addr)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstatic const u8 bc_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tconst u8 *peer_mac = pairwise ? mac_addr : bc_mac;\n\n\tif (mwifiex_set_encode(priv, NULL, NULL, 0, key_index, peer_mac, 1)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"deleting the crypto keys\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: crypto keys deleted\\n\");\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_form_mgmt_frame(struct sk_buff *skb, const u8 *buf, size_t len)\n{\n\tu8 addr[ETH_ALEN] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};\n\tu16 pkt_len;\n\tu32 tx_control = 0, pkt_type = PKT_TYPE_MGMT;\n\n\tpkt_len = len + ETH_ALEN;\n\n\tskb_reserve(skb, MWIFIEX_MIN_DATA_HEADER_LEN +\n\t\t    MWIFIEX_MGMT_FRAME_HEADER_SIZE + sizeof(pkt_len));\n\tmemcpy(skb_push(skb, sizeof(pkt_len)), &pkt_len, sizeof(pkt_len));\n\n\tmemcpy(skb_push(skb, sizeof(tx_control)),\n\t       &tx_control, sizeof(tx_control));\n\n\tmemcpy(skb_push(skb, sizeof(pkt_type)), &pkt_type, sizeof(pkt_type));\n\n\t \n\tskb_put_data(skb, buf, sizeof(struct ieee80211_hdr_3addr));\n\tskb_put_data(skb, addr, ETH_ALEN);\n\tskb_put_data(skb, buf + sizeof(struct ieee80211_hdr_3addr),\n\t\t     len - sizeof(struct ieee80211_hdr_3addr));\n\n\tskb->priority = LOW_PRIO_TID;\n\t__net_timestamp(skb);\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t struct cfg80211_mgmt_tx_params *params, u64 *cookie)\n{\n\tconst u8 *buf = params->buf;\n\tsize_t len = params->len;\n\tstruct sk_buff *skb;\n\tu16 pkt_len;\n\tconst struct ieee80211_mgmt *mgmt;\n\tstruct mwifiex_txinfo *tx_info;\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\n\tif (!buf || !len) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"invalid buffer and length\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tmgmt = (const struct ieee80211_mgmt *)buf;\n\tif (GET_BSS_ROLE(priv) != MWIFIEX_BSS_ROLE_STA &&\n\t    ieee80211_is_probe_resp(mgmt->frame_control)) {\n\t\t \n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: skip to send probe resp in AP or GO mode\\n\");\n\t\treturn 0;\n\t}\n\n\tpkt_len = len + ETH_ALEN;\n\tskb = dev_alloc_skb(MWIFIEX_MIN_DATA_HEADER_LEN +\n\t\t\t    MWIFIEX_MGMT_FRAME_HEADER_SIZE +\n\t\t\t    pkt_len + sizeof(pkt_len));\n\n\tif (!skb) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"allocate skb failed for management frame\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tmemset(tx_info, 0, sizeof(*tx_info));\n\ttx_info->bss_num = priv->bss_num;\n\ttx_info->bss_type = priv->bss_type;\n\ttx_info->pkt_len = pkt_len;\n\n\tmwifiex_form_mgmt_frame(skb, buf, len);\n\t*cookie = get_random_u32() | 1;\n\n\tif (ieee80211_is_action(mgmt->frame_control))\n\t\tskb = mwifiex_clone_skb_for_tx_status(priv,\n\t\t\t\t\t\t      skb,\n\t\t\t\tMWIFIEX_BUF_FLAG_ACTION_TX_STATUS, cookie);\n\telse\n\t\tcfg80211_mgmt_tx_status(wdev, *cookie, buf, len, true,\n\t\t\t\t\tGFP_ATOMIC);\n\n\tmwifiex_queue_tx_pkt(priv, skb);\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: management frame transmitted\\n\");\n\treturn 0;\n}\n\n \nstatic void\nmwifiex_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t\t\t struct mgmt_frame_regs *upd)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tu32 mask = upd->interface_stypes;\n\n\tif (mask != priv->mgmt_frame_mask) {\n\t\tpriv->mgmt_frame_mask = mask;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &priv->mgmt_frame_mask, false);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: mgmt frame registered\\n\");\n\t}\n}\n\n \nstatic int\nmwifiex_cfg80211_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t   struct ieee80211_channel *chan,\n\t\t\t\t   unsigned int duration, u64 *cookie)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tint ret;\n\n\tif (!chan || !cookie) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"Invalid parameter for ROC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (priv->roc_cfg.cookie) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ongoing ROC, cookie = 0x%llx\\n\",\n\t\t\t    priv->roc_cfg.cookie);\n\t\treturn -EBUSY;\n\t}\n\n\tret = mwifiex_remain_on_chan_cfg(priv, HostCmd_ACT_GEN_SET, chan,\n\t\t\t\t\t duration);\n\n\tif (!ret) {\n\t\t*cookie = get_random_u32() | 1;\n\t\tpriv->roc_cfg.cookie = *cookie;\n\t\tpriv->roc_cfg.chan = *chan;\n\n\t\tcfg80211_ready_on_channel(wdev, *cookie, chan,\n\t\t\t\t\t  duration, GFP_ATOMIC);\n\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ROC, cookie = 0x%llx\\n\", *cookie);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t\t  struct wireless_dev *wdev, u64 cookie)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tint ret;\n\n\tif (cookie != priv->roc_cfg.cookie)\n\t\treturn -ENOENT;\n\n\tret = mwifiex_remain_on_chan_cfg(priv, HostCmd_ACT_GEN_REMOVE,\n\t\t\t\t\t &priv->roc_cfg.chan, 0);\n\n\tif (!ret) {\n\t\tcfg80211_remain_on_channel_expired(wdev, cookie,\n\t\t\t\t\t\t   &priv->roc_cfg.chan,\n\t\t\t\t\t\t   GFP_ATOMIC);\n\n\t\tmemset(&priv->roc_cfg, 0, sizeof(struct mwifiex_roc_cfg));\n\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: cancel ROC, cookie = 0x%llx\\n\", cookie);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_cfg80211_set_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      enum nl80211_tx_power_setting type,\n\t\t\t      int mbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_power_cfg power_cfg;\n\tint dbm = MBM_TO_DBM(mbm);\n\n\tswitch (type) {\n\tcase NL80211_TX_POWER_FIXED:\n\t\tpower_cfg.is_power_auto = 0;\n\t\tpower_cfg.is_power_fixed = 1;\n\t\tpower_cfg.power_level = dbm;\n\t\tbreak;\n\tcase NL80211_TX_POWER_LIMITED:\n\t\tpower_cfg.is_power_auto = 0;\n\t\tpower_cfg.is_power_fixed = 0;\n\t\tpower_cfg.power_level = dbm;\n\t\tbreak;\n\tcase NL80211_TX_POWER_AUTOMATIC:\n\t\tpower_cfg.is_power_auto = 1;\n\t\tbreak;\n\t}\n\n\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\n\treturn mwifiex_set_tx_power(priv, &power_cfg);\n}\n\n \nstatic int\nmwifiex_cfg80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      int *dbm)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tint ret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t\t   HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t*dbm = priv->tx_power_level;\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cfg80211_set_power_mgmt(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tbool enabled, int timeout)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tu32 ps_mode;\n\n\tif (timeout)\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ignore timeout value for IEEE Power Save\\n\");\n\n\tps_mode = enabled;\n\n\treturn mwifiex_drv_set_power(priv, &ps_mode);\n}\n\n \nstatic int\nmwifiex_cfg80211_set_default_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t\t int link_id, u8 key_index, bool unicast,\n\t\t\t\t bool multicast)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\n\t \n\tif (!priv->sec_info.wep_enabled)\n\t\treturn 0;\n\n\tif (priv->bss_type == MWIFIEX_BSS_TYPE_UAP) {\n\t\tpriv->wep_key_curr_index = key_index;\n\t} else if (mwifiex_set_encode(priv, NULL, NULL, 0, key_index,\n\t\t\t\t      NULL, 0)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"set default Tx key index\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t int link_id, u8 key_index, bool pairwise,\n\t\t\t const u8 *mac_addr, struct key_params *params)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_wep_key *wep_key;\n\tstatic const u8 bc_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tconst u8 *peer_mac = pairwise ? mac_addr : bc_mac;\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP &&\n\t    (params->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t     params->cipher == WLAN_CIPHER_SUITE_WEP104)) {\n\t\tif (params->key && params->key_len) {\n\t\t\twep_key = &priv->wep_key[key_index];\n\t\t\tmemset(wep_key, 0, sizeof(struct mwifiex_wep_key));\n\t\t\tmemcpy(wep_key->key_material, params->key,\n\t\t\t       params->key_len);\n\t\t\twep_key->key_index = key_index;\n\t\t\twep_key->key_length = params->key_len;\n\t\t\tpriv->sec_info.wep_enabled = 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (mwifiex_set_encode(priv, params, params->key, params->key_len,\n\t\t\t       key_index, peer_mac, 0)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"crypto keys added\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *netdev,\n\t\t\t\t      int link_id,\n\t\t\t\t      u8 key_index)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(netdev);\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\twiphy_dbg(wiphy, \"set default mgmt key, key index=%d\\n\", key_index);\n\n\tmemset(&encrypt_key, 0, sizeof(struct mwifiex_ds_encrypt_key));\n\tencrypt_key.key_len = WLAN_KEY_LEN_CCMP;\n\tencrypt_key.key_index = key_index;\n\tencrypt_key.is_igtk_def_key = true;\n\teth_broadcast_addr(encrypt_key.mac_addr);\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t     HostCmd_ACT_GEN_SET, true, &encrypt_key, true)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Sending KEY_MATERIAL command failed\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nint mwifiex_send_domain_info_cmd_fw(struct wiphy *wiphy)\n{\n\tu8 no_of_triplet = 0;\n\tstruct ieee80211_country_ie_triplet *t;\n\tu8 no_of_parsed_chan = 0;\n\tu8 first_chan = 0, next_chan = 0, max_pwr = 0;\n\tu8 i, flag = 0;\n\tenum nl80211_band band;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_802_11d_domain_reg *domain_info = &adapter->domain_reg;\n\n\t \n\tdomain_info->country_code[0] = adapter->country_code[0];\n\tdomain_info->country_code[1] = adapter->country_code[1];\n\tdomain_info->country_code[2] = ' ';\n\n\tband = mwifiex_band_to_radio_type(adapter->config_bands);\n\tif (!wiphy->bands[band]) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"11D: setting domain info in FW\\n\");\n\t\treturn -1;\n\t}\n\n\tsband = wiphy->bands[band];\n\n\tfor (i = 0; i < sband->n_channels ; i++) {\n\t\tch = &sband->channels[i];\n\t\tif (ch->flags & IEEE80211_CHAN_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (!flag) {\n\t\t\tflag = 1;\n\t\t\tfirst_chan = (u32) ch->hw_value;\n\t\t\tnext_chan = first_chan;\n\t\t\tmax_pwr = ch->max_power;\n\t\t\tno_of_parsed_chan = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ch->hw_value == next_chan + 1 &&\n\t\t    ch->max_power == max_pwr) {\n\t\t\tnext_chan++;\n\t\t\tno_of_parsed_chan++;\n\t\t} else {\n\t\t\tt = &domain_info->triplet[no_of_triplet];\n\t\t\tt->chans.first_channel = first_chan;\n\t\t\tt->chans.num_channels = no_of_parsed_chan;\n\t\t\tt->chans.max_power = max_pwr;\n\t\t\tno_of_triplet++;\n\t\t\tfirst_chan = (u32) ch->hw_value;\n\t\t\tnext_chan = first_chan;\n\t\t\tmax_pwr = ch->max_power;\n\t\t\tno_of_parsed_chan = 1;\n\t\t}\n\t}\n\n\tif (flag) {\n\t\tt = &domain_info->triplet[no_of_triplet];\n\t\tt->chans.first_channel = first_chan;\n\t\tt->chans.num_channels = no_of_parsed_chan;\n\t\tt->chans.max_power = max_pwr;\n\t\tno_of_triplet++;\n\t}\n\n\tdomain_info->no_of_triplet = no_of_triplet;\n\n\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11D_DOMAIN_INFO,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, NULL, false)) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"11D: setting domain info in FW\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void mwifiex_reg_apply_radar_flags(struct wiphy *wiphy)\n{\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *chan;\n\tunsigned int i;\n\n\tif (!wiphy->bands[NL80211_BAND_5GHZ])\n\t\treturn;\n\tsband = wiphy->bands[NL80211_BAND_5GHZ];\n\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tchan = &sband->channels[i];\n\t\tif ((!(chan->flags & IEEE80211_CHAN_DISABLED)) &&\n\t\t    (chan->flags & IEEE80211_CHAN_RADAR))\n\t\t\tchan->flags |= IEEE80211_CHAN_NO_IR;\n\t}\n}\n\n \nstatic void mwifiex_reg_notifier(struct wiphy *wiphy,\n\t\t\t\t struct regulatory_request *request)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: cfg80211 regulatory domain callback for %c%c\\n\",\n\t\t    request->alpha2[0], request->alpha2[1]);\n\tmwifiex_reg_apply_radar_flags(wiphy);\n\n\tswitch (request->initiator) {\n\tcase NL80211_REGDOM_SET_BY_DRIVER:\n\tcase NL80211_REGDOM_SET_BY_CORE:\n\tcase NL80211_REGDOM_SET_BY_USER:\n\tcase NL80211_REGDOM_SET_BY_COUNTRY_IE:\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"unknown regdom initiator: %d\\n\",\n\t\t\t    request->initiator);\n\t\treturn;\n\t}\n\n\t \n\tif (strncmp(request->alpha2, \"00\", 2) &&\n\t    strncmp(request->alpha2, adapter->country_code,\n\t\t    sizeof(request->alpha2))) {\n\t\tmemcpy(adapter->country_code, request->alpha2,\n\t\t       sizeof(request->alpha2));\n\t\tmwifiex_send_domain_info_cmd_fw(wiphy);\n\t\tmwifiex_dnld_txpwr_table(priv);\n\t}\n}\n\n \nstatic int\nmwifiex_set_frag(struct mwifiex_private *priv, u32 frag_thr)\n{\n\tif (frag_thr < MWIFIEX_FRAG_MIN_VALUE ||\n\t    frag_thr > MWIFIEX_FRAG_MAX_VALUE)\n\t\tfrag_thr = MWIFIEX_FRAG_MAX_VALUE;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, FRAG_THRESH_I,\n\t\t\t\t&frag_thr, true);\n}\n\n \nstatic int\nmwifiex_set_rts(struct mwifiex_private *priv, u32 rts_thr)\n{\n\tif (rts_thr < MWIFIEX_RTS_MIN_VALUE || rts_thr > MWIFIEX_RTS_MAX_VALUE)\n\t\trts_thr = MWIFIEX_RTS_MAX_VALUE;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, RTS_THRESH_I,\n\t\t\t\t&rts_thr, true);\n}\n\n \nstatic int\nmwifiex_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_uap_bss_param *bss_cfg;\n\tint ret;\n\n\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\n\tswitch (priv->bss_role) {\n\tcase MWIFIEX_BSS_ROLE_UAP:\n\t\tif (priv->bss_started) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cannot change wiphy params when bss started\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbss_cfg = kzalloc(sizeof(*bss_cfg), GFP_KERNEL);\n\t\tif (!bss_cfg)\n\t\t\treturn -ENOMEM;\n\n\t\tmwifiex_set_sys_config_invalid_data(bss_cfg);\n\n\t\tif (changed & WIPHY_PARAM_RTS_THRESHOLD)\n\t\t\tbss_cfg->rts_threshold = wiphy->rts_threshold;\n\t\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD)\n\t\t\tbss_cfg->frag_threshold = wiphy->frag_threshold;\n\t\tif (changed & WIPHY_PARAM_RETRY_LONG)\n\t\t\tbss_cfg->retry_limit = wiphy->retry_long;\n\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_UAP_SYS_CONFIG,\n\t\t\t\t       HostCmd_ACT_GEN_SET,\n\t\t\t\t       UAP_BSS_PARAMS_I, bss_cfg,\n\t\t\t\t       false);\n\n\t\tkfree(bss_cfg);\n\t\tif (ret) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Failed to set wiphy phy params\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase MWIFIEX_BSS_ROLE_STA:\n\t\tif (priv->media_connected) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cannot change wiphy params when connected\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (changed & WIPHY_PARAM_RTS_THRESHOLD) {\n\t\t\tret = mwifiex_set_rts(priv,\n\t\t\t\t\t      wiphy->rts_threshold);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD) {\n\t\t\tret = mwifiex_set_frag(priv,\n\t\t\t\t\t       wiphy->frag_threshold);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmwifiex_cfg80211_deinit_p2p(struct mwifiex_private *priv)\n{\n\tu16 mode = P2P_MODE_DISABLE;\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_P2P_MODE_CFG,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, &mode, true))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cfg80211_init_p2p_client(struct mwifiex_private *priv)\n{\n\tu16 mode;\n\n\tif (mwifiex_cfg80211_deinit_p2p(priv))\n\t\treturn -1;\n\n\tmode = P2P_MODE_DEVICE;\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_P2P_MODE_CFG,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, &mode, true))\n\t\treturn -1;\n\n\tmode = P2P_MODE_CLIENT;\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_P2P_MODE_CFG,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, &mode, true))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cfg80211_init_p2p_go(struct mwifiex_private *priv)\n{\n\tu16 mode;\n\n\tif (mwifiex_cfg80211_deinit_p2p(priv))\n\t\treturn -1;\n\n\tmode = P2P_MODE_DEVICE;\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_P2P_MODE_CFG,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, &mode, true))\n\t\treturn -1;\n\n\tmode = P2P_MODE_GO;\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_P2P_MODE_CFG,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, &mode, true))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int mwifiex_deinit_priv_params(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tunsigned long flags;\n\n\tpriv->mgmt_frame_mask = 0;\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MGMT_FRAME_REG,\n\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t     &priv->mgmt_frame_mask, false)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"could not unregister mgmt frame rx\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_deauthenticate(priv, NULL);\n\n\tspin_lock_irqsave(&adapter->main_proc_lock, flags);\n\tadapter->main_locked = true;\n\tif (adapter->mwifiex_processing) {\n\t\tspin_unlock_irqrestore(&adapter->main_proc_lock, flags);\n\t\tflush_workqueue(adapter->workqueue);\n\t} else {\n\t\tspin_unlock_irqrestore(&adapter->main_proc_lock, flags);\n\t}\n\n\tspin_lock_bh(&adapter->rx_proc_lock);\n\tadapter->rx_locked = true;\n\tif (adapter->rx_processing) {\n\t\tspin_unlock_bh(&adapter->rx_proc_lock);\n\t\tflush_workqueue(adapter->rx_workqueue);\n\t} else {\n\tspin_unlock_bh(&adapter->rx_proc_lock);\n\t}\n\n\tmwifiex_free_priv(priv);\n\tpriv->wdev.iftype = NL80211_IFTYPE_UNSPECIFIED;\n\tpriv->bss_mode = NL80211_IFTYPE_UNSPECIFIED;\n\tpriv->sec_info.authentication_mode = NL80211_AUTHTYPE_OPEN_SYSTEM;\n\n\treturn 0;\n}\n\nstatic int\nmwifiex_init_new_priv_params(struct mwifiex_private *priv,\n\t\t\t     struct net_device *dev,\n\t\t\t     enum nl80211_iftype type)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tunsigned long flags;\n\n\tmwifiex_init_priv(priv);\n\n\tpriv->bss_mode = type;\n\tpriv->wdev.iftype = type;\n\n\tmwifiex_init_priv_params(priv, priv->netdev);\n\tpriv->bss_started = 0;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tpriv->bss_role = MWIFIEX_BSS_ROLE_STA;\n\t\tpriv->bss_type = MWIFIEX_BSS_TYPE_STA;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tpriv->bss_role = MWIFIEX_BSS_ROLE_STA;\n\t\tpriv->bss_type = MWIFIEX_BSS_TYPE_P2P;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tpriv->bss_role = MWIFIEX_BSS_ROLE_UAP;\n\t\tpriv->bss_type = MWIFIEX_BSS_TYPE_P2P;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tpriv->bss_role = MWIFIEX_BSS_ROLE_UAP;\n\t\tpriv->bss_type = MWIFIEX_BSS_TYPE_UAP;\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: changing to %d not supported\\n\",\n\t\t\t    dev->name, type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tspin_lock_irqsave(&adapter->main_proc_lock, flags);\n\tadapter->main_locked = false;\n\tspin_unlock_irqrestore(&adapter->main_proc_lock, flags);\n\n\tspin_lock_bh(&adapter->rx_proc_lock);\n\tadapter->rx_locked = false;\n\tspin_unlock_bh(&adapter->rx_proc_lock);\n\n\tmwifiex_set_mac_address(priv, dev, false, NULL);\n\n\treturn 0;\n}\n\nstatic bool\nis_vif_type_change_allowed(struct mwifiex_adapter *adapter,\n\t\t\t   enum nl80211_iftype old_iftype,\n\t\t\t   enum nl80211_iftype new_iftype)\n{\n\tswitch (old_iftype) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tswitch (new_iftype) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\treturn true;\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\treturn adapter->curr_iface_comb.p2p_intf !=\n\t\t\t       adapter->iface_limit.p2p_intf;\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\treturn adapter->curr_iface_comb.uap_intf !=\n\t\t\t       adapter->iface_limit.uap_intf;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\n\tcase NL80211_IFTYPE_STATION:\n\t\tswitch (new_iftype) {\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\treturn true;\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\treturn adapter->curr_iface_comb.p2p_intf !=\n\t\t\t       adapter->iface_limit.p2p_intf;\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\treturn adapter->curr_iface_comb.uap_intf !=\n\t\t\t       adapter->iface_limit.uap_intf;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\n\tcase NL80211_IFTYPE_AP:\n\t\tswitch (new_iftype) {\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\treturn adapter->curr_iface_comb.sta_intf !=\n\t\t\t       adapter->iface_limit.sta_intf;\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\treturn adapter->curr_iface_comb.p2p_intf !=\n\t\t\t       adapter->iface_limit.p2p_intf;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tswitch (new_iftype) {\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\treturn true;\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\treturn true;\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\treturn adapter->curr_iface_comb.uap_intf !=\n\t\t\t       adapter->iface_limit.uap_intf;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tswitch (new_iftype) {\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\treturn true;\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t\treturn true;\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\treturn adapter->curr_iface_comb.uap_intf !=\n\t\t\t       adapter->iface_limit.uap_intf;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic void\nupdate_vif_type_counter(struct mwifiex_adapter *adapter,\n\t\t\tenum nl80211_iftype iftype,\n\t\t\tint change)\n{\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\t\tadapter->curr_iface_comb.sta_intf += change;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tadapter->curr_iface_comb.uap_intf += change;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tadapter->curr_iface_comb.p2p_intf += change;\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: Unsupported iftype passed: %d\\n\",\n\t\t\t    __func__, iftype);\n\t\tbreak;\n\t}\n}\n\nstatic int\nmwifiex_change_vif_to_p2p(struct net_device *dev,\n\t\t\t  enum nl80211_iftype curr_iftype,\n\t\t\t  enum nl80211_iftype type,\n\t\t\t  struct vif_params *params)\n{\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_adapter *adapter;\n\n\tpriv = mwifiex_netdev_get_priv(dev);\n\n\tif (!priv)\n\t\treturn -1;\n\n\tadapter = priv->adapter;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"%s: changing role to p2p\\n\", dev->name);\n\n\tif (mwifiex_deinit_priv_params(priv))\n\t\treturn -1;\n\tif (mwifiex_init_new_priv_params(priv, dev, type))\n\t\treturn -1;\n\n\tupdate_vif_type_counter(adapter, curr_iftype, -1);\n\tupdate_vif_type_counter(adapter, type, +1);\n\tdev->ieee80211_ptr->iftype = type;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (mwifiex_cfg80211_init_p2p_client(priv))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (mwifiex_cfg80211_init_p2p_go(priv))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: changing to %d not supported\\n\",\n\t\t\t    dev->name, type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_SET_BSS_MODE,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, NULL, true))\n\t\treturn -1;\n\n\tif (mwifiex_sta_init_cmd(priv, false, false))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int\nmwifiex_change_vif_to_sta_adhoc(struct net_device *dev,\n\t\t\t\tenum nl80211_iftype curr_iftype,\n\t\t\t\tenum nl80211_iftype type,\n\t\t\t\tstruct vif_params *params)\n{\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_adapter *adapter;\n\n\tpriv = mwifiex_netdev_get_priv(dev);\n\n\tif (!priv)\n\t\treturn -1;\n\n\tadapter = priv->adapter;\n\n\tif (type == NL80211_IFTYPE_STATION)\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"%s: changing role to station\\n\", dev->name);\n\telse\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"%s: changing role to adhoc\\n\", dev->name);\n\n\tif (mwifiex_deinit_priv_params(priv))\n\t\treturn -1;\n\tif (mwifiex_init_new_priv_params(priv, dev, type))\n\t\treturn -1;\n\n\tupdate_vif_type_counter(adapter, curr_iftype, -1);\n\tupdate_vif_type_counter(adapter, type, +1);\n\tdev->ieee80211_ptr->iftype = type;\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_SET_BSS_MODE,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, NULL, true))\n\t\treturn -1;\n\tif (mwifiex_sta_init_cmd(priv, false, false))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int\nmwifiex_change_vif_to_ap(struct net_device *dev,\n\t\t\t enum nl80211_iftype curr_iftype,\n\t\t\t enum nl80211_iftype type,\n\t\t\t struct vif_params *params)\n{\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_adapter *adapter;\n\n\tpriv = mwifiex_netdev_get_priv(dev);\n\n\tif (!priv)\n\t\treturn -1;\n\n\tadapter = priv->adapter;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"%s: changing role to AP\\n\", dev->name);\n\n\tif (mwifiex_deinit_priv_params(priv))\n\t\treturn -1;\n\tif (mwifiex_init_new_priv_params(priv, dev, type))\n\t\treturn -1;\n\n\tupdate_vif_type_counter(adapter, curr_iftype, -1);\n\tupdate_vif_type_counter(adapter, type, +1);\n\tdev->ieee80211_ptr->iftype = type;\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_SET_BSS_MODE,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, NULL, true))\n\t\treturn -1;\n\tif (mwifiex_sta_init_cmd(priv, false, false))\n\t\treturn -1;\n\n\treturn 0;\n}\n \nstatic int\nmwifiex_cfg80211_change_virtual_intf(struct wiphy *wiphy,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t     struct vif_params *params)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tenum nl80211_iftype curr_iftype = dev->ieee80211_ptr->iftype;\n\n\tif (priv->scan_request) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"change virtual interface: scan in process\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (type == NL80211_IFTYPE_UNSPECIFIED) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"%s: no new type specified, keeping old type %d\\n\",\n\t\t\t    dev->name, curr_iftype);\n\t\treturn 0;\n\t}\n\n\tif (curr_iftype == type) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"%s: interface already is of type %d\\n\",\n\t\t\t    dev->name, curr_iftype);\n\t\treturn 0;\n\t}\n\n\tif (!is_vif_type_change_allowed(priv->adapter, curr_iftype, type)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"%s: change from type %d to %d is not allowed\\n\",\n\t\t\t    dev->name, curr_iftype, type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (curr_iftype) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tswitch (type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tpriv->bss_mode = type;\n\t\t\tpriv->sec_info.authentication_mode =\n\t\t\t\t\t\t   NL80211_AUTHTYPE_OPEN_SYSTEM;\n\t\t\tdev->ieee80211_ptr->iftype = type;\n\t\t\tmwifiex_deauthenticate(priv, NULL);\n\t\t\treturn mwifiex_send_cmd(priv, HostCmd_CMD_SET_BSS_MODE,\n\t\t\t\t\t\tHostCmd_ACT_GEN_SET, 0, NULL,\n\t\t\t\t\t\ttrue);\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\treturn mwifiex_change_vif_to_p2p(dev, curr_iftype,\n\t\t\t\t\t\t\t type, params);\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\treturn mwifiex_change_vif_to_ap(dev, curr_iftype, type,\n\t\t\t\t\t\t\tparams);\n\t\tdefault:\n\t\t\tgoto errnotsupp;\n\t\t}\n\n\tcase NL80211_IFTYPE_STATION:\n\t\tswitch (type) {\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tpriv->bss_mode = type;\n\t\t\tpriv->sec_info.authentication_mode =\n\t\t\t\t\t\t   NL80211_AUTHTYPE_OPEN_SYSTEM;\n\t\t\tdev->ieee80211_ptr->iftype = type;\n\t\t\tmwifiex_deauthenticate(priv, NULL);\n\t\t\treturn mwifiex_send_cmd(priv, HostCmd_CMD_SET_BSS_MODE,\n\t\t\t\t\t\tHostCmd_ACT_GEN_SET, 0, NULL,\n\t\t\t\t\t\ttrue);\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\treturn mwifiex_change_vif_to_p2p(dev, curr_iftype,\n\t\t\t\t\t\t\t type, params);\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\treturn mwifiex_change_vif_to_ap(dev, curr_iftype, type,\n\t\t\t\t\t\t\tparams);\n\t\tdefault:\n\t\t\tgoto errnotsupp;\n\t\t}\n\n\tcase NL80211_IFTYPE_AP:\n\t\tswitch (type) {\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\treturn mwifiex_change_vif_to_sta_adhoc(dev, curr_iftype,\n\t\t\t\t\t\t\t       type, params);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\treturn mwifiex_change_vif_to_p2p(dev, curr_iftype,\n\t\t\t\t\t\t\t type, params);\n\t\tdefault:\n\t\t\tgoto errnotsupp;\n\t\t}\n\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (mwifiex_cfg80211_deinit_p2p(priv))\n\t\t\treturn -EFAULT;\n\n\t\tswitch (type) {\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\treturn mwifiex_change_vif_to_sta_adhoc(dev, curr_iftype,\n\t\t\t\t\t\t\t       type, params);\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\treturn mwifiex_change_vif_to_p2p(dev, curr_iftype,\n\t\t\t\t\t\t\t type, params);\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\treturn mwifiex_change_vif_to_ap(dev, curr_iftype, type,\n\t\t\t\t\t\t\tparams);\n\t\tdefault:\n\t\t\tgoto errnotsupp;\n\t\t}\n\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (mwifiex_cfg80211_deinit_p2p(priv))\n\t\t\treturn -EFAULT;\n\n\t\tswitch (type) {\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\treturn mwifiex_change_vif_to_sta_adhoc(dev, curr_iftype,\n\t\t\t\t\t\t\t       type, params);\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t\treturn mwifiex_change_vif_to_p2p(dev, curr_iftype,\n\t\t\t\t\t\t\t type, params);\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\treturn mwifiex_change_vif_to_ap(dev, curr_iftype, type,\n\t\t\t\t\t\t\tparams);\n\t\tdefault:\n\t\t\tgoto errnotsupp;\n\t\t}\n\n\tdefault:\n\t\tgoto errnotsupp;\n\t}\n\n\n\treturn 0;\n\nerrnotsupp:\n\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t    \"unsupported interface type transition: %d to %d\\n\",\n\t\t    curr_iftype, type);\n\treturn -EOPNOTSUPP;\n}\n\nstatic void\nmwifiex_parse_htinfo(struct mwifiex_private *priv, u8 rateinfo, u8 htinfo,\n\t\t     struct rate_info *rate)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tif (adapter->is_hw_11ac_capable) {\n\t\t \n\t\tif (htinfo & BIT(0)) {\n\t\t\t \n\t\t\trate->mcs = rateinfo;\n\t\t\trate->flags |= RATE_INFO_FLAGS_MCS;\n\t\t}\n\t\tif (htinfo & BIT(1)) {\n\t\t\t \n\t\t\trate->mcs = rateinfo & 0x0F;\n\t\t\trate->flags |= RATE_INFO_FLAGS_VHT_MCS;\n\t\t}\n\n\t\tif (htinfo & (BIT(1) | BIT(0))) {\n\t\t\t \n\t\t\tswitch (htinfo & (BIT(3) | BIT(2))) {\n\t\t\tcase 0:\n\t\t\t\trate->bw = RATE_INFO_BW_20;\n\t\t\t\tbreak;\n\t\t\tcase (BIT(2)):\n\t\t\t\trate->bw = RATE_INFO_BW_40;\n\t\t\t\tbreak;\n\t\t\tcase (BIT(3)):\n\t\t\t\trate->bw = RATE_INFO_BW_80;\n\t\t\t\tbreak;\n\t\t\tcase (BIT(3) | BIT(2)):\n\t\t\t\trate->bw = RATE_INFO_BW_160;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (htinfo & BIT(4))\n\t\t\t\trate->flags |= RATE_INFO_FLAGS_SHORT_GI;\n\n\t\t\tif ((rateinfo >> 4) == 1)\n\t\t\t\trate->nss = 2;\n\t\t\telse\n\t\t\t\trate->nss = 1;\n\t\t}\n\t} else {\n\t\t \n\t\tif ((htinfo & BIT(0)) && (rateinfo < 16)) {\n\t\t\trate->mcs = rateinfo;\n\t\t\trate->flags |= RATE_INFO_FLAGS_MCS;\n\t\t\trate->bw = RATE_INFO_BW_20;\n\t\t\tif (htinfo & BIT(1))\n\t\t\t\trate->bw = RATE_INFO_BW_40;\n\t\t\tif (htinfo & BIT(2))\n\t\t\t\trate->flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\t}\n\t}\n\n\t \n\tif (!(htinfo & (BIT(0) | BIT(1)))) {\n\t\t \n\t\tstatic const int legacy_rates[] = {\n\t\t\t[0] = 10,\n\t\t\t[1] = 20,\n\t\t\t[2] = 55,\n\t\t\t[3] = 110,\n\t\t\t[4] = 60,  \n\t\t\t[5] = 60,\n\t\t\t[6] = 90,\n\t\t\t[7] = 120,\n\t\t\t[8] = 180,\n\t\t\t[9] = 240,\n\t\t\t[10] = 360,\n\t\t\t[11] = 480,\n\t\t\t[12] = 540,\n\t\t};\n\t\tif (rateinfo < ARRAY_SIZE(legacy_rates))\n\t\t\trate->legacy = legacy_rates[rateinfo];\n\t}\n}\n\n \nstatic int\nmwifiex_dump_station_info(struct mwifiex_private *priv,\n\t\t\t  struct mwifiex_sta_node *node,\n\t\t\t  struct station_info *sinfo)\n{\n\tu32 rate;\n\n\tsinfo->filled = BIT_ULL(NL80211_STA_INFO_RX_BYTES) | BIT_ULL(NL80211_STA_INFO_TX_BYTES) |\n\t\t\tBIT_ULL(NL80211_STA_INFO_RX_PACKETS) | BIT_ULL(NL80211_STA_INFO_TX_PACKETS) |\n\t\t\tBIT_ULL(NL80211_STA_INFO_TX_BITRATE) |\n\t\t\tBIT_ULL(NL80211_STA_INFO_SIGNAL) | BIT_ULL(NL80211_STA_INFO_SIGNAL_AVG);\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\n\t\tif (!node)\n\t\t\treturn -ENOENT;\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_INACTIVE_TIME) |\n\t\t\t\tBIT_ULL(NL80211_STA_INFO_TX_FAILED);\n\t\tsinfo->inactive_time =\n\t\t\tjiffies_to_msecs(jiffies - node->stats.last_rx);\n\n\t\tsinfo->signal = node->stats.rssi;\n\t\tsinfo->signal_avg = node->stats.rssi;\n\t\tsinfo->rx_bytes = node->stats.rx_bytes;\n\t\tsinfo->tx_bytes = node->stats.tx_bytes;\n\t\tsinfo->rx_packets = node->stats.rx_packets;\n\t\tsinfo->tx_packets = node->stats.tx_packets;\n\t\tsinfo->tx_failed = node->stats.tx_failed;\n\n\t\tmwifiex_parse_htinfo(priv, priv->tx_rate,\n\t\t\t\t     node->stats.last_tx_htinfo,\n\t\t\t\t     &sinfo->txrate);\n\t\tsinfo->txrate.legacy = node->stats.last_tx_rate * 5;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_RSSI_INFO,\n\t\t\t     HostCmd_ACT_GEN_GET, 0, NULL, true)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"failed to get signal information\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (mwifiex_drv_get_data_rate(priv, &rate)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"getting data rate error\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tmwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t HostCmd_ACT_GEN_GET, DTIM_PERIOD_I,\n\t\t\t &priv->dtim_period, true);\n\n\tmwifiex_parse_htinfo(priv, priv->tx_rate, priv->tx_htinfo,\n\t\t\t     &sinfo->txrate);\n\n\tsinfo->signal_avg = priv->bcn_rssi_avg;\n\tsinfo->rx_bytes = priv->stats.rx_bytes;\n\tsinfo->tx_bytes = priv->stats.tx_bytes;\n\tsinfo->rx_packets = priv->stats.rx_packets;\n\tsinfo->tx_packets = priv->stats.tx_packets;\n\tsinfo->signal = priv->bcn_rssi_avg;\n\t \n\tsinfo->txrate.legacy = rate * 5;\n\n\tsinfo->filled |= BIT(NL80211_STA_INFO_RX_BITRATE);\n\tmwifiex_parse_htinfo(priv, priv->rxpd_rate, priv->rxpd_htinfo,\n\t\t\t     &sinfo->rxrate);\n\n\tif (priv->bss_mode == NL80211_IFTYPE_STATION) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_BSS_PARAM);\n\t\tsinfo->bss_param.flags = 0;\n\t\tif (priv->curr_bss_params.bss_descriptor.cap_info_bitmap &\n\t\t\t\t\t\tWLAN_CAPABILITY_SHORT_PREAMBLE)\n\t\t\tsinfo->bss_param.flags |=\n\t\t\t\t\tBSS_PARAM_FLAGS_SHORT_PREAMBLE;\n\t\tif (priv->curr_bss_params.bss_descriptor.cap_info_bitmap &\n\t\t\t\t\t\tWLAN_CAPABILITY_SHORT_SLOT_TIME)\n\t\t\tsinfo->bss_param.flags |=\n\t\t\t\t\tBSS_PARAM_FLAGS_SHORT_SLOT_TIME;\n\t\tsinfo->bss_param.dtim_period = priv->dtim_period;\n\t\tsinfo->bss_param.beacon_interval =\n\t\t\tpriv->curr_bss_params.bss_descriptor.beacon_period;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cfg80211_get_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     const u8 *mac, struct station_info *sinfo)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\tif (!priv->media_connected)\n\t\treturn -ENOENT;\n\tif (memcmp(mac, priv->cfg_bssid, ETH_ALEN))\n\t\treturn -ENOENT;\n\n\treturn mwifiex_dump_station_info(priv, NULL, sinfo);\n}\n\n \nstatic int\nmwifiex_cfg80211_dump_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      int idx, u8 *mac, struct station_info *sinfo)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tstruct mwifiex_sta_node *node;\n\tint i;\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    priv->media_connected && idx == 0) {\n\t\tether_addr_copy(mac, priv->cfg_bssid);\n\t\treturn mwifiex_dump_station_info(priv, NULL, sinfo);\n\t} else if (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\n\t\tmwifiex_send_cmd(priv, HOST_CMD_APCMD_STA_LIST,\n\t\t\t\t HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\t\ti = 0;\n\t\tlist_for_each_entry(node, &priv->sta_list, list) {\n\t\t\tif (i++ != idx)\n\t\t\t\tcontinue;\n\t\t\tether_addr_copy(mac, node->mac_addr);\n\t\t\treturn mwifiex_dump_station_info(priv, node, sinfo);\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int\nmwifiex_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     int idx, struct survey_info *survey)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tstruct mwifiex_chan_stats *pchan_stats = priv->adapter->chan_stats;\n\tenum nl80211_band band;\n\n\tmwifiex_dbg(priv->adapter, DUMP, \"dump_survey idx=%d\\n\", idx);\n\n\tmemset(survey, 0, sizeof(struct survey_info));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    priv->media_connected && idx == 0) {\n\t\t\tu8 curr_bss_band = priv->curr_bss_params.band;\n\t\t\tu32 chan = priv->curr_bss_params.bss_descriptor.channel;\n\n\t\t\tband = mwifiex_band_to_radio_type(curr_bss_band);\n\t\t\tsurvey->channel = ieee80211_get_channel(wiphy,\n\t\t\t\tieee80211_channel_to_frequency(chan, band));\n\n\t\t\tif (priv->bcn_nf_last) {\n\t\t\t\tsurvey->filled = SURVEY_INFO_NOISE_DBM;\n\t\t\t\tsurvey->noise = priv->bcn_nf_last;\n\t\t\t}\n\t\t\treturn 0;\n\t}\n\n\tif (idx >= priv->adapter->num_in_chan_stats)\n\t\treturn -ENOENT;\n\n\tif (!pchan_stats[idx].cca_scan_dur)\n\t\treturn 0;\n\n\tband = pchan_stats[idx].bandcfg;\n\tsurvey->channel = ieee80211_get_channel(wiphy,\n\t    ieee80211_channel_to_frequency(pchan_stats[idx].chan_num, band));\n\tsurvey->filled = SURVEY_INFO_NOISE_DBM |\n\t\t\t SURVEY_INFO_TIME |\n\t\t\t SURVEY_INFO_TIME_BUSY;\n\tsurvey->noise = pchan_stats[idx].noise;\n\tsurvey->time = pchan_stats[idx].cca_scan_dur;\n\tsurvey->time_busy = pchan_stats[idx].cca_busy_dur;\n\n\treturn 0;\n}\n\n \nstatic struct ieee80211_rate mwifiex_rates[] = {\n\t{.bitrate = 10, .hw_value = 2, },\n\t{.bitrate = 20, .hw_value = 4, },\n\t{.bitrate = 55, .hw_value = 11, },\n\t{.bitrate = 110, .hw_value = 22, },\n\t{.bitrate = 60, .hw_value = 12, },\n\t{.bitrate = 90, .hw_value = 18, },\n\t{.bitrate = 120, .hw_value = 24, },\n\t{.bitrate = 180, .hw_value = 36, },\n\t{.bitrate = 240, .hw_value = 48, },\n\t{.bitrate = 360, .hw_value = 72, },\n\t{.bitrate = 480, .hw_value = 96, },\n\t{.bitrate = 540, .hw_value = 108, },\n};\n\n \nstatic struct ieee80211_channel mwifiex_channels_2ghz[] = {\n\t{.center_freq = 2412, .hw_value = 1, },\n\t{.center_freq = 2417, .hw_value = 2, },\n\t{.center_freq = 2422, .hw_value = 3, },\n\t{.center_freq = 2427, .hw_value = 4, },\n\t{.center_freq = 2432, .hw_value = 5, },\n\t{.center_freq = 2437, .hw_value = 6, },\n\t{.center_freq = 2442, .hw_value = 7, },\n\t{.center_freq = 2447, .hw_value = 8, },\n\t{.center_freq = 2452, .hw_value = 9, },\n\t{.center_freq = 2457, .hw_value = 10, },\n\t{.center_freq = 2462, .hw_value = 11, },\n\t{.center_freq = 2467, .hw_value = 12, },\n\t{.center_freq = 2472, .hw_value = 13, },\n\t{.center_freq = 2484, .hw_value = 14, },\n};\n\nstatic struct ieee80211_supported_band mwifiex_band_2ghz = {\n\t.channels = mwifiex_channels_2ghz,\n\t.n_channels = ARRAY_SIZE(mwifiex_channels_2ghz),\n\t.bitrates = mwifiex_rates,\n\t.n_bitrates = ARRAY_SIZE(mwifiex_rates),\n};\n\nstatic struct ieee80211_channel mwifiex_channels_5ghz[] = {\n\t{.center_freq = 5040, .hw_value = 8, },\n\t{.center_freq = 5060, .hw_value = 12, },\n\t{.center_freq = 5080, .hw_value = 16, },\n\t{.center_freq = 5170, .hw_value = 34, },\n\t{.center_freq = 5190, .hw_value = 38, },\n\t{.center_freq = 5210, .hw_value = 42, },\n\t{.center_freq = 5230, .hw_value = 46, },\n\t{.center_freq = 5180, .hw_value = 36, },\n\t{.center_freq = 5200, .hw_value = 40, },\n\t{.center_freq = 5220, .hw_value = 44, },\n\t{.center_freq = 5240, .hw_value = 48, },\n\t{.center_freq = 5260, .hw_value = 52, },\n\t{.center_freq = 5280, .hw_value = 56, },\n\t{.center_freq = 5300, .hw_value = 60, },\n\t{.center_freq = 5320, .hw_value = 64, },\n\t{.center_freq = 5500, .hw_value = 100, },\n\t{.center_freq = 5520, .hw_value = 104, },\n\t{.center_freq = 5540, .hw_value = 108, },\n\t{.center_freq = 5560, .hw_value = 112, },\n\t{.center_freq = 5580, .hw_value = 116, },\n\t{.center_freq = 5600, .hw_value = 120, },\n\t{.center_freq = 5620, .hw_value = 124, },\n\t{.center_freq = 5640, .hw_value = 128, },\n\t{.center_freq = 5660, .hw_value = 132, },\n\t{.center_freq = 5680, .hw_value = 136, },\n\t{.center_freq = 5700, .hw_value = 140, },\n\t{.center_freq = 5745, .hw_value = 149, },\n\t{.center_freq = 5765, .hw_value = 153, },\n\t{.center_freq = 5785, .hw_value = 157, },\n\t{.center_freq = 5805, .hw_value = 161, },\n\t{.center_freq = 5825, .hw_value = 165, },\n};\n\nstatic struct ieee80211_supported_band mwifiex_band_5ghz = {\n\t.channels = mwifiex_channels_5ghz,\n\t.n_channels = ARRAY_SIZE(mwifiex_channels_5ghz),\n\t.bitrates = mwifiex_rates + 4,\n\t.n_bitrates = ARRAY_SIZE(mwifiex_rates) - 4,\n};\n\n\n \nstatic const u32 mwifiex_cipher_suites[] = {\n\tWLAN_CIPHER_SUITE_WEP40,\n\tWLAN_CIPHER_SUITE_WEP104,\n\tWLAN_CIPHER_SUITE_TKIP,\n\tWLAN_CIPHER_SUITE_CCMP,\n\tWLAN_CIPHER_SUITE_SMS4,\n\tWLAN_CIPHER_SUITE_AES_CMAC,\n};\n\n \nstatic const struct ieee80211_txrx_stypes\nmwifiex_mgmt_stypes[NUM_NL80211_IFTYPES] = {\n\t[NL80211_IFTYPE_STATION] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_RESP >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4),\n\t},\n\t[NL80211_IFTYPE_AP] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_RESP >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4),\n\t},\n\t[NL80211_IFTYPE_P2P_CLIENT] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_RESP >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4),\n\t},\n\t[NL80211_IFTYPE_P2P_GO] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_RESP >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4),\n\t},\n};\n\n \nstatic int\nmwifiex_cfg80211_set_bitrate_mask(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  unsigned int link_id,\n\t\t\t\t  const u8 *peer,\n\t\t\t\t  const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tu16 bitmap_rates[MAX_BITMAP_RATES_SIZE];\n\tenum nl80211_band band;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tif (!priv->media_connected) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Can not set Tx data rate in disconnected state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tband = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n\n\tmemset(bitmap_rates, 0, sizeof(bitmap_rates));\n\n\t \n\tif (band == NL80211_BAND_2GHZ)\n\t\tbitmap_rates[0] = mask->control[band].legacy & 0x000f;\n\n\t \n\tif (band == NL80211_BAND_2GHZ)\n\t\tbitmap_rates[1] = (mask->control[band].legacy & 0x0ff0) >> 4;\n\telse\n\t\tbitmap_rates[1] = mask->control[band].legacy;\n\n\t \n\tbitmap_rates[2] = mask->control[band].ht_mcs[0];\n\tif (adapter->hw_dev_mcs_support == HT_STREAM_2X2)\n\t\tbitmap_rates[2] |= mask->control[band].ht_mcs[1] << 8;\n\n        \n\tif (adapter->fw_api_ver == MWIFIEX_FW_V15) {\n\t\tbitmap_rates[10] = mask->control[band].vht_mcs[0];\n\t\tif (adapter->hw_dev_mcs_support == HT_STREAM_2X2)\n\t\t\tbitmap_rates[11] = mask->control[band].vht_mcs[1];\n\t}\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_TX_RATE_CFG,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, bitmap_rates, true);\n}\n\n \nstatic int mwifiex_cfg80211_set_cqm_rssi_config(struct wiphy *wiphy,\n\t\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\t\ts32 rssi_thold, u32 rssi_hyst)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tstruct mwifiex_ds_misc_subsc_evt subsc_evt;\n\n\tpriv->cqm_rssi_thold = rssi_thold;\n\tpriv->cqm_rssi_hyst = rssi_hyst;\n\n\tmemset(&subsc_evt, 0x00, sizeof(struct mwifiex_ds_misc_subsc_evt));\n\tsubsc_evt.events = BITMASK_BCN_RSSI_LOW | BITMASK_BCN_RSSI_HIGH;\n\n\t \n\tif (rssi_thold && rssi_hyst) {\n\t\tsubsc_evt.action = HostCmd_ACT_BITWISE_SET;\n\t\tsubsc_evt.bcn_l_rssi_cfg.abs_value = abs(rssi_thold);\n\t\tsubsc_evt.bcn_h_rssi_cfg.abs_value = abs(rssi_thold);\n\t\tsubsc_evt.bcn_l_rssi_cfg.evt_freq = 1;\n\t\tsubsc_evt.bcn_h_rssi_cfg.evt_freq = 1;\n\t\treturn mwifiex_send_cmd(priv,\n\t\t\t\t\tHostCmd_CMD_802_11_SUBSCRIBE_EVENT,\n\t\t\t\t\t0, 0, &subsc_evt, true);\n\t} else {\n\t\tsubsc_evt.action = HostCmd_ACT_BITWISE_CLR;\n\t\treturn mwifiex_send_cmd(priv,\n\t\t\t\t\tHostCmd_CMD_802_11_SUBSCRIBE_EVENT,\n\t\t\t\t\t0, 0, &subsc_evt, true);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cfg80211_change_beacon(struct wiphy *wiphy,\n\t\t\t\t\t  struct net_device *dev,\n\t\t\t\t\t  struct cfg80211_beacon_data *data)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tmwifiex_cancel_scan(adapter);\n\n\tif (GET_BSS_ROLE(priv) != MWIFIEX_BSS_ROLE_UAP) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"%s: bss_type mismatched\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!priv->bss_started) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"%s: bss not started\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mwifiex_set_mgmt_ies(priv, data)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"%s: setting mgmt ies failed\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cfg80211_del_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     struct station_del_parameters *params)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tstruct mwifiex_sta_node *sta_node;\n\tu8 deauth_mac[ETH_ALEN];\n\n\tif (!priv->bss_started && priv->wdev.cac_started) {\n\t\tmwifiex_dbg(priv->adapter, INFO, \"%s: abort CAC!\\n\", __func__);\n\t\tmwifiex_abort_cac(priv);\n\t}\n\n\tif (list_empty(&priv->sta_list) || !priv->bss_started)\n\t\treturn 0;\n\n\tif (!params->mac || is_broadcast_ether_addr(params->mac))\n\t\treturn 0;\n\n\tmwifiex_dbg(priv->adapter, INFO, \"%s: mac address %pM\\n\",\n\t\t    __func__, params->mac);\n\n\teth_zero_addr(deauth_mac);\n\n\tspin_lock_bh(&priv->sta_list_spinlock);\n\tsta_node = mwifiex_get_sta_entry(priv, params->mac);\n\tif (sta_node)\n\t\tether_addr_copy(deauth_mac, params->mac);\n\tspin_unlock_bh(&priv->sta_list_spinlock);\n\n\tif (is_valid_ether_addr(deauth_mac)) {\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_STA_DEAUTH,\n\t\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t     deauth_mac, true))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmwifiex_cfg80211_set_antenna(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tstruct mwifiex_ds_ant_cfg ant_cfg;\n\n\tif (!tx_ant || !rx_ant)\n\t\treturn -EOPNOTSUPP;\n\n\tif (adapter->hw_dev_mcs_support != HT_STREAM_2X2) {\n\t\t \n\t\tif (tx_ant != rx_ant)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif ((tx_ant & (tx_ant - 1)) &&\n\t\t    (tx_ant != BIT(adapter->number_of_antenna) - 1))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif ((tx_ant == BIT(adapter->number_of_antenna) - 1) &&\n\t\t    (priv->adapter->number_of_antenna > 1)) {\n\t\t\ttx_ant = RF_ANTENNA_AUTO;\n\t\t\trx_ant = RF_ANTENNA_AUTO;\n\t\t}\n\t} else {\n\t\tstruct ieee80211_sta_ht_cap *ht_info;\n\t\tint rx_mcs_supp;\n\t\tenum nl80211_band band;\n\n\t\tif ((tx_ant == 0x1 && rx_ant == 0x1)) {\n\t\t\tadapter->user_dev_mcs_support = HT_STREAM_1X1;\n\t\t\tif (adapter->is_hw_11ac_capable)\n\t\t\t\tadapter->usr_dot_11ac_mcs_support =\n\t\t\t\t\t\tMWIFIEX_11AC_MCS_MAP_1X1;\n\t\t} else {\n\t\t\tadapter->user_dev_mcs_support = HT_STREAM_2X2;\n\t\t\tif (adapter->is_hw_11ac_capable)\n\t\t\t\tadapter->usr_dot_11ac_mcs_support =\n\t\t\t\t\t\tMWIFIEX_11AC_MCS_MAP_2X2;\n\t\t}\n\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tif (!adapter->wiphy->bands[band])\n\t\t\t\tcontinue;\n\n\t\t\tht_info = &adapter->wiphy->bands[band]->ht_cap;\n\t\t\trx_mcs_supp =\n\t\t\t\tGET_RXMCSSUPP(adapter->user_dev_mcs_support);\n\t\t\tmemset(&ht_info->mcs, 0, adapter->number_of_antenna);\n\t\t\tmemset(&ht_info->mcs, 0xff, rx_mcs_supp);\n\t\t}\n\t}\n\n\tant_cfg.tx_ant = tx_ant;\n\tant_cfg.rx_ant = rx_ant;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_RF_ANTENNA,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &ant_cfg, true);\n}\n\nstatic int\nmwifiex_cfg80211_get_antenna(struct wiphy *wiphy, u32 *tx_ant, u32 *rx_ant)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv = mwifiex_get_priv(adapter,\n\t\t\t\t\t\t\tMWIFIEX_BSS_ROLE_ANY);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_RF_ANTENNA,\n\t\t\t HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\t*tx_ant = priv->tx_ant;\n\t*rx_ant = priv->rx_ant;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t    unsigned int link_id)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\tmwifiex_abort_cac(priv);\n\n\tif (mwifiex_del_mgmt_ies(priv))\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to delete mgmt IEs!\\n\");\n\n\tpriv->ap_11n_enabled = 0;\n\tmemset(&priv->bss_cfg, 0, sizeof(priv->bss_cfg));\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_STOP,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, NULL, true)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to stop the BSS\\n\");\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_send_cmd(priv, HOST_CMD_APCMD_SYS_RESET,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, NULL, true)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to reset BSS\\n\");\n\t\treturn -1;\n\t}\n\n\tif (netif_carrier_ok(priv->netdev))\n\t\tnetif_carrier_off(priv->netdev);\n\tmwifiex_stop_net_dev_queue(priv->netdev, priv->adapter);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cfg80211_start_ap(struct wiphy *wiphy,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     struct cfg80211_ap_settings *params)\n{\n\tstruct mwifiex_uap_bss_param *bss_cfg;\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\tif (GET_BSS_ROLE(priv) != MWIFIEX_BSS_ROLE_UAP)\n\t\treturn -1;\n\n\tbss_cfg = kzalloc(sizeof(struct mwifiex_uap_bss_param), GFP_KERNEL);\n\tif (!bss_cfg)\n\t\treturn -ENOMEM;\n\n\tmwifiex_set_sys_config_invalid_data(bss_cfg);\n\n\tmemcpy(bss_cfg->mac_addr, priv->curr_addr, ETH_ALEN);\n\n\tif (params->beacon_interval)\n\t\tbss_cfg->beacon_period = params->beacon_interval;\n\tif (params->dtim_period)\n\t\tbss_cfg->dtim_period = params->dtim_period;\n\n\tif (params->ssid && params->ssid_len) {\n\t\tmemcpy(bss_cfg->ssid.ssid, params->ssid, params->ssid_len);\n\t\tbss_cfg->ssid.ssid_len = params->ssid_len;\n\t}\n\tif (params->inactivity_timeout > 0) {\n\t\t \n\t\tbss_cfg->sta_ao_timer = 10 * params->inactivity_timeout;\n\t\tbss_cfg->ps_sta_ao_timer = 10 * params->inactivity_timeout;\n\t}\n\n\tswitch (params->hidden_ssid) {\n\tcase NL80211_HIDDEN_SSID_NOT_IN_USE:\n\t\tbss_cfg->bcast_ssid_ctl = 1;\n\t\tbreak;\n\tcase NL80211_HIDDEN_SSID_ZERO_LEN:\n\t\tbss_cfg->bcast_ssid_ctl = 0;\n\t\tbreak;\n\tcase NL80211_HIDDEN_SSID_ZERO_CONTENTS:\n\t\tbss_cfg->bcast_ssid_ctl = 2;\n\t\tbreak;\n\tdefault:\n\t\tkfree(bss_cfg);\n\t\treturn -EINVAL;\n\t}\n\n\tmwifiex_uap_set_channel(priv, bss_cfg, params->chandef);\n\tmwifiex_set_uap_rates(bss_cfg, params);\n\n\tif (mwifiex_set_secure_params(priv, bss_cfg, params)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to parse security parameters!\\n\");\n\t\tgoto out;\n\t}\n\n\tmwifiex_set_ht_params(priv, bss_cfg, params);\n\n\tif (priv->adapter->is_hw_11ac_capable) {\n\t\tmwifiex_set_vht_params(priv, bss_cfg, params);\n\t\tmwifiex_set_vht_width(priv, params->chandef.width,\n\t\t\t\t      priv->ap_11ac_enabled);\n\t}\n\n\tif (priv->ap_11ac_enabled)\n\t\tmwifiex_set_11ac_ba_params(priv);\n\telse\n\t\tmwifiex_set_ba_params(priv);\n\n\tmwifiex_set_wmm_params(priv, bss_cfg, params);\n\n\tif (mwifiex_is_11h_active(priv))\n\t\tmwifiex_set_tpc_params(priv, bss_cfg, params);\n\n\tif (mwifiex_is_11h_active(priv) &&\n\t    !cfg80211_chandef_dfs_required(wiphy, &params->chandef,\n\t\t\t\t\t   priv->bss_mode)) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"Disable 11h extensions in FW\\n\");\n\t\tif (mwifiex_11h_activate(priv, false)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"Failed to disable 11h extensions!!\");\n\t\t\tgoto out;\n\t\t}\n\t\tpriv->state_11h.is_11h_active = false;\n\t}\n\n\tmwifiex_config_uap_11d(priv, &params->beacon);\n\n\tif (mwifiex_config_start_uap(priv, bss_cfg)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to start AP\\n\");\n\t\tgoto out;\n\t}\n\n\tif (mwifiex_set_mgmt_ies(priv, &params->beacon))\n\t\tgoto out;\n\n\tif (!netif_carrier_ok(priv->netdev))\n\t\tnetif_carrier_on(priv->netdev);\n\tmwifiex_wake_up_net_dev_queue(priv->netdev, priv->adapter);\n\n\tmemcpy(&priv->bss_cfg, bss_cfg, sizeof(priv->bss_cfg));\n\tkfree(bss_cfg);\n\treturn 0;\n\nout:\n\tkfree(bss_cfg);\n\treturn -1;\n}\n\n \nstatic int\nmwifiex_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t    u16 reason_code)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\tif (!mwifiex_stop_bg_scan(priv))\n\t\tcfg80211_sched_scan_stopped_locked(priv->wdev.wiphy, 0);\n\n\tif (mwifiex_deauthenticate(priv, NULL))\n\t\treturn -EFAULT;\n\n\teth_zero_addr(priv->cfg_bssid);\n\tpriv->hs2_enabled = false;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cfg80211_inform_ibss_bss(struct mwifiex_private *priv)\n{\n\tstruct ieee80211_channel *chan;\n\tstruct mwifiex_bss_info bss_info;\n\tstruct cfg80211_bss *bss;\n\tint ie_len;\n\tu8 ie_buf[IEEE80211_MAX_SSID_LEN + sizeof(struct ieee_types_header)];\n\tenum nl80211_band band;\n\n\tif (mwifiex_get_bss_info(priv, &bss_info))\n\t\treturn -1;\n\n\tie_buf[0] = WLAN_EID_SSID;\n\tie_buf[1] = bss_info.ssid.ssid_len;\n\n\tmemcpy(&ie_buf[sizeof(struct ieee_types_header)],\n\t       &bss_info.ssid.ssid, bss_info.ssid.ssid_len);\n\tie_len = ie_buf[1] + sizeof(struct ieee_types_header);\n\n\tband = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n\tchan = ieee80211_get_channel(priv->wdev.wiphy,\n\t\t\tieee80211_channel_to_frequency(bss_info.bss_chan,\n\t\t\t\t\t\t       band));\n\n\tbss = cfg80211_inform_bss(priv->wdev.wiphy, chan,\n\t\t\t\t  CFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t  bss_info.bssid, 0, WLAN_CAPABILITY_IBSS,\n\t\t\t\t  0, ie_buf, ie_len, 0, GFP_KERNEL);\n\tif (bss) {\n\t\tcfg80211_put_bss(priv->wdev.wiphy, bss);\n\t\tether_addr_copy(priv->cfg_bssid, bss_info.bssid);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cfg80211_assoc(struct mwifiex_private *priv, size_t ssid_len,\n\t\t       const u8 *ssid, const u8 *bssid, int mode,\n\t\t       struct ieee80211_channel *channel,\n\t\t       struct cfg80211_connect_params *sme, bool privacy,\n\t\t       struct cfg80211_bss **sel_bss)\n{\n\tstruct cfg80211_ssid req_ssid;\n\tint ret, auth_type = 0;\n\tstruct cfg80211_bss *bss = NULL;\n\tu8 is_scanning_required = 0;\n\n\tmemset(&req_ssid, 0, sizeof(struct cfg80211_ssid));\n\n\treq_ssid.ssid_len = ssid_len;\n\tif (ssid_len > IEEE80211_MAX_SSID_LEN) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"invalid SSID - aborting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(req_ssid.ssid, ssid, ssid_len);\n\tif (!req_ssid.ssid_len || req_ssid.ssid[0] < 0x20) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"invalid SSID - aborting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpriv->sec_info.wpa_enabled = false;\n\tpriv->sec_info.wpa2_enabled = false;\n\tpriv->wep_key_curr_index = 0;\n\tpriv->sec_info.encryption_mode = 0;\n\tpriv->sec_info.is_authtype_auto = 0;\n\tret = mwifiex_set_encode(priv, NULL, NULL, 0, 0, NULL, 1);\n\n\tif (mode == NL80211_IFTYPE_ADHOC) {\n\t\tu16 enable = true;\n\n\t\t \n\t\tret = mwifiex_send_cmd(\n\t\t\t\tpriv,\n\t\t\t\tHostCmd_CMD_802_11_IBSS_COALESCING_STATUS,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &enable, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (privacy) {\n\t\t\t \n\t\t\tpriv->sec_info.encryption_mode =\n\t\t\t\t\tWLAN_CIPHER_SUITE_WEP104;\n\t\t\tpriv->sec_info.authentication_mode =\n\t\t\t\t\tNL80211_AUTHTYPE_OPEN_SYSTEM;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\t \n\tif (sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) {\n\t\tauth_type = NL80211_AUTHTYPE_OPEN_SYSTEM;\n\t\tpriv->sec_info.is_authtype_auto = 1;\n\t} else {\n\t\tauth_type = sme->auth_type;\n\t}\n\n\tif (sme->crypto.n_ciphers_pairwise) {\n\t\tpriv->sec_info.encryption_mode =\n\t\t\t\t\t\tsme->crypto.ciphers_pairwise[0];\n\t\tpriv->sec_info.authentication_mode = auth_type;\n\t}\n\n\tif (sme->crypto.cipher_group) {\n\t\tpriv->sec_info.encryption_mode = sme->crypto.cipher_group;\n\t\tpriv->sec_info.authentication_mode = auth_type;\n\t}\n\tif (sme->ie)\n\t\tret = mwifiex_set_gen_ie(priv, sme->ie, sme->ie_len);\n\n\tif (sme->key) {\n\t\tif (mwifiex_is_alg_wep(priv->sec_info.encryption_mode)) {\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: setting wep encryption\\t\"\n\t\t\t\t    \"with key len %d\\n\", sme->key_len);\n\t\t\tpriv->wep_key_curr_index = sme->key_idx;\n\t\t\tret = mwifiex_set_encode(priv, NULL, sme->key,\n\t\t\t\t\t\t sme->key_len, sme->key_idx,\n\t\t\t\t\t\t NULL, 0);\n\t\t}\n\t}\ndone:\n\t \n\twhile (1) {\n\t\tif (is_scanning_required) {\n\t\t\t \n\t\t\tif (mwifiex_request_scan(priv, &req_ssid)) {\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR, \"scan error\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (mode == NL80211_IFTYPE_ADHOC)\n\t\t\tbss = cfg80211_get_bss(priv->wdev.wiphy, channel,\n\t\t\t\t\t       bssid, ssid, ssid_len,\n\t\t\t\t\t       IEEE80211_BSS_TYPE_IBSS,\n\t\t\t\t\t       IEEE80211_PRIVACY_ANY);\n\t\telse\n\t\t\tbss = cfg80211_get_bss(priv->wdev.wiphy, channel,\n\t\t\t\t\t       bssid, ssid, ssid_len,\n\t\t\t\t\t       IEEE80211_BSS_TYPE_ESS,\n\t\t\t\t\t       IEEE80211_PRIVACY_ANY);\n\n\t\tif (!bss) {\n\t\t\tif (is_scanning_required) {\n\t\t\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t\t\t    \"assoc: requested bss not found in scan results\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tis_scanning_required = 1;\n\t\t} else {\n\t\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t\t    \"info: trying to associate to bssid %pM\\n\",\n\t\t\t\t    bss->bssid);\n\t\t\tmemcpy(&priv->cfg_bssid, bss->bssid, ETH_ALEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bss)\n\t\tcfg80211_ref_bss(priv->adapter->wiphy, bss);\n\n\tret = mwifiex_bss_start(priv, bss, &req_ssid);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tif (mode == NL80211_IFTYPE_ADHOC) {\n\t\t \n\t\tif (mwifiex_cfg80211_inform_ibss_bss(priv)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\tif (sel_bss) {\n\t\t*sel_bss = bss;\n\t\tbss = NULL;\n\t}\n\ncleanup:\n\tif (bss)\n\t\tcfg80211_put_bss(priv->adapter->wiphy, bss);\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t struct cfg80211_connect_params *sme)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct cfg80211_bss *bss = NULL;\n\tint ret;\n\n\tif (GET_BSS_ROLE(priv) != MWIFIEX_BSS_ROLE_STA) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: reject infra assoc request in non-STA role\\n\",\n\t\t\t    dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (priv->wdev.connected) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: already connected\\n\", dev->name);\n\t\treturn -EALREADY;\n\t}\n\n\tif (priv->scan_block)\n\t\tpriv->scan_block = false;\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags) ||\n\t    test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: Ignore connection.\\t\"\n\t\t\t    \"Card removed or FW in bad state\\n\",\n\t\t\t    dev->name);\n\t\treturn -EFAULT;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: Trying to associate to bssid %pM\\n\", sme->bssid);\n\n\tif (!mwifiex_stop_bg_scan(priv))\n\t\tcfg80211_sched_scan_stopped_locked(priv->wdev.wiphy, 0);\n\n\tret = mwifiex_cfg80211_assoc(priv, sme->ssid_len, sme->ssid, sme->bssid,\n\t\t\t\t     priv->bss_mode, sme->channel, sme, 0,\n\t\t\t\t     &bss);\n\tif (!ret) {\n\t\tcfg80211_connect_bss(priv->netdev, priv->cfg_bssid, bss, NULL,\n\t\t\t\t     0, NULL, 0, WLAN_STATUS_SUCCESS,\n\t\t\t\t     GFP_KERNEL, NL80211_TIMEOUT_UNSPECIFIED);\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"info: associated to bssid %pM successfully\\n\",\n\t\t\t    priv->cfg_bssid);\n\t\tif (ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t\t    priv->adapter->auto_tdls &&\n\t\t    priv->bss_type == MWIFIEX_BSS_TYPE_STA)\n\t\t\tmwifiex_setup_auto_tdls_timer(priv);\n\t} else {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"info: association to bssid %pM failed\\n\",\n\t\t\t    priv->cfg_bssid);\n\t\teth_zero_addr(priv->cfg_bssid);\n\n\t\tif (ret > 0)\n\t\t\tcfg80211_connect_result(priv->netdev, priv->cfg_bssid,\n\t\t\t\t\t\tNULL, 0, NULL, 0, ret,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\telse\n\t\t\tcfg80211_connect_result(priv->netdev, priv->cfg_bssid,\n\t\t\t\t\t\tNULL, 0, NULL, 0,\n\t\t\t\t\t\tWLAN_STATUS_UNSPECIFIED_FAILURE,\n\t\t\t\t\t\tGFP_KERNEL);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_set_ibss_params(struct mwifiex_private *priv,\n\t\t\t\t   struct cfg80211_ibss_params *params)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint index = 0, i;\n\tu8 config_bands = 0;\n\n\tif (params->chandef.chan->band == NL80211_BAND_2GHZ) {\n\t\tif (!params->basic_rates) {\n\t\t\tconfig_bands = BAND_B | BAND_G;\n\t\t} else {\n\t\t\tfor (i = 0; i < mwifiex_band_2ghz.n_bitrates; i++) {\n\t\t\t\t \n\t\t\t\tif (mwifiex_rates[i].bitrate == 60) {\n\t\t\t\t\tindex = 1 << i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (params->basic_rates < index) {\n\t\t\t\tconfig_bands = BAND_B;\n\t\t\t} else {\n\t\t\t\tconfig_bands = BAND_G;\n\t\t\t\tif (params->basic_rates % index)\n\t\t\t\t\tconfig_bands |= BAND_B;\n\t\t\t}\n\t\t}\n\n\t\tif (cfg80211_get_chandef_type(&params->chandef) !=\n\t\t\t\t\t\tNL80211_CHAN_NO_HT)\n\t\t\tconfig_bands |= BAND_G | BAND_GN;\n\t} else {\n\t\tif (cfg80211_get_chandef_type(&params->chandef) ==\n\t\t\t\t\t\tNL80211_CHAN_NO_HT)\n\t\t\tconfig_bands = BAND_A;\n\t\telse\n\t\t\tconfig_bands = BAND_AN | BAND_A;\n\t}\n\n\tif (!((config_bands | adapter->fw_bands) & ~adapter->fw_bands)) {\n\t\tadapter->config_bands = config_bands;\n\t\tadapter->adhoc_start_band = config_bands;\n\n\t\tif ((config_bands & BAND_GN) || (config_bands & BAND_AN))\n\t\t\tadapter->adhoc_11n_enabled = true;\n\t\telse\n\t\t\tadapter->adhoc_11n_enabled = false;\n\t}\n\n\tadapter->sec_chan_offset =\n\t\tmwifiex_chan_type_to_sec_chan_offset(\n\t\t\tcfg80211_get_chandef_type(&params->chandef));\n\tpriv->adhoc_channel = ieee80211_frequency_to_channel(\n\t\t\t\tparams->chandef.chan->center_freq);\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: set ibss band %d, chan %d, chan offset %d\\n\",\n\t\t    config_bands, priv->adhoc_channel,\n\t\t    adapter->sec_chan_offset);\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   struct cfg80211_ibss_params *params)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tint ret = 0;\n\n\tif (priv->bss_mode != NL80211_IFTYPE_ADHOC) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"request to join ibss received\\t\"\n\t\t\t    \"when station is not in ibss mode\\n\");\n\t\tgoto done;\n\t}\n\n\tmwifiex_dbg(priv->adapter, MSG, \"info: trying to join to bssid %pM\\n\",\n\t\t    params->bssid);\n\n\tmwifiex_set_ibss_params(priv, params);\n\n\tret = mwifiex_cfg80211_assoc(priv, params->ssid_len, params->ssid,\n\t\t\t\t     params->bssid, priv->bss_mode,\n\t\t\t\t     params->chandef.chan, NULL,\n\t\t\t\t     params->privacy, NULL);\ndone:\n\tif (!ret) {\n\t\tcfg80211_ibss_joined(priv->netdev, priv->cfg_bssid,\n\t\t\t\t     params->chandef.chan, GFP_KERNEL);\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"info: joined/created adhoc network with bssid\\t\"\n\t\t\t    \"%pM successfully\\n\", priv->cfg_bssid);\n\t} else {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"info: failed creating/joining adhoc network\\n\");\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_cfg80211_leave_ibss(struct wiphy *wiphy, struct net_device *dev)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\tmwifiex_dbg(priv->adapter, MSG, \"info: disconnecting from essid %pM\\n\",\n\t\t    priv->cfg_bssid);\n\tif (mwifiex_deauthenticate(priv, NULL))\n\t\treturn -EFAULT;\n\n\teth_zero_addr(priv->cfg_bssid);\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cfg80211_scan(struct wiphy *wiphy,\n\t\t      struct cfg80211_scan_request *request)\n{\n\tstruct net_device *dev = request->wdev->netdev;\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tint i, offset, ret;\n\tstruct ieee80211_channel *chan;\n\tstruct ieee_types_header *ie;\n\tstruct mwifiex_user_scan_cfg *user_scan_cfg;\n\tu8 mac_addr[ETH_ALEN];\n\n\tmwifiex_dbg(priv->adapter, CMD,\n\t\t    \"info: received scan request on %s\\n\", dev->name);\n\n\t \n\tif (priv->scan_request || priv->scan_aborting) {\n\t\tmwifiex_dbg(priv->adapter, WARN,\n\t\t\t    \"cmd: Scan already in process..\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!priv->wdev.connected && priv->scan_block)\n\t\tpriv->scan_block = false;\n\n\tif (!mwifiex_stop_bg_scan(priv))\n\t\tcfg80211_sched_scan_stopped_locked(priv->wdev.wiphy, 0);\n\n\tuser_scan_cfg = kzalloc(sizeof(*user_scan_cfg), GFP_KERNEL);\n\tif (!user_scan_cfg)\n\t\treturn -ENOMEM;\n\n\tpriv->scan_request = request;\n\n\tif (request->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\tget_random_mask_addr(mac_addr, request->mac_addr,\n\t\t\t\t     request->mac_addr_mask);\n\t\tether_addr_copy(request->mac_addr, mac_addr);\n\t\tether_addr_copy(user_scan_cfg->random_mac, mac_addr);\n\t}\n\n\tuser_scan_cfg->num_ssids = request->n_ssids;\n\tuser_scan_cfg->ssid_list = request->ssids;\n\n\tif (request->ie && request->ie_len) {\n\t\toffset = 0;\n\t\tfor (i = 0; i < MWIFIEX_MAX_VSIE_NUM; i++) {\n\t\t\tif (priv->vs_ie[i].mask != MWIFIEX_VSIE_MASK_CLEAR)\n\t\t\t\tcontinue;\n\t\t\tpriv->vs_ie[i].mask = MWIFIEX_VSIE_MASK_SCAN;\n\t\t\tie = (struct ieee_types_header *)(request->ie + offset);\n\t\t\tmemcpy(&priv->vs_ie[i].ie, ie, sizeof(*ie) + ie->len);\n\t\t\toffset += sizeof(*ie) + ie->len;\n\n\t\t\tif (offset >= request->ie_len)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < min_t(u32, request->n_channels,\n\t\t\t      MWIFIEX_USER_SCAN_CHAN_MAX); i++) {\n\t\tchan = request->channels[i];\n\t\tuser_scan_cfg->chan_list[i].chan_number = chan->hw_value;\n\t\tuser_scan_cfg->chan_list[i].radio_type = chan->band;\n\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_IR) || !request->n_ssids)\n\t\t\tuser_scan_cfg->chan_list[i].scan_type =\n\t\t\t\t\t\tMWIFIEX_SCAN_TYPE_PASSIVE;\n\t\telse\n\t\t\tuser_scan_cfg->chan_list[i].scan_type =\n\t\t\t\t\t\tMWIFIEX_SCAN_TYPE_ACTIVE;\n\n\t\tuser_scan_cfg->chan_list[i].scan_time = 0;\n\t}\n\n\tif (priv->adapter->scan_chan_gap_enabled &&\n\t    mwifiex_is_any_intf_active(priv))\n\t\tuser_scan_cfg->scan_chan_gap =\n\t\t\t\t\t      priv->adapter->scan_chan_gap_time;\n\n\tret = mwifiex_scan_networks(priv, user_scan_cfg);\n\tkfree(user_scan_cfg);\n\tif (ret) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"scan failed: %d\\n\", ret);\n\t\tpriv->scan_aborting = false;\n\t\tpriv->scan_request = NULL;\n\t\treturn ret;\n\t}\n\n\tif (request->ie && request->ie_len) {\n\t\tfor (i = 0; i < MWIFIEX_MAX_VSIE_NUM; i++) {\n\t\t\tif (priv->vs_ie[i].mask == MWIFIEX_VSIE_MASK_SCAN) {\n\t\t\t\tpriv->vs_ie[i].mask = MWIFIEX_VSIE_MASK_CLEAR;\n\t\t\t\tmemset(&priv->vs_ie[i].ie, 0,\n\t\t\t\t       MWIFIEX_MAX_VSIE_LEN);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cfg80211_sched_scan_start(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  struct cfg80211_sched_scan_request *request)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tint i, offset;\n\tstruct ieee80211_channel *chan;\n\tstruct mwifiex_bg_scan_cfg *bgscan_cfg;\n\tstruct ieee_types_header *ie;\n\n\tif (!request || (!request->n_ssids && !request->n_match_sets)) {\n\t\twiphy_err(wiphy, \"%s : Invalid Sched_scan parameters\",\n\t\t\t  __func__);\n\t\treturn -EINVAL;\n\t}\n\n\twiphy_info(wiphy, \"sched_scan start : n_ssids=%d n_match_sets=%d \",\n\t\t   request->n_ssids, request->n_match_sets);\n\twiphy_info(wiphy, \"n_channels=%d interval=%d ie_len=%d\\n\",\n\t\t   request->n_channels, request->scan_plans->interval,\n\t\t   (int)request->ie_len);\n\n\tbgscan_cfg = kzalloc(sizeof(*bgscan_cfg), GFP_KERNEL);\n\tif (!bgscan_cfg)\n\t\treturn -ENOMEM;\n\n\tif (priv->scan_request || priv->scan_aborting)\n\t\tbgscan_cfg->start_later = true;\n\n\tbgscan_cfg->num_ssids = request->n_match_sets;\n\tbgscan_cfg->ssid_list = request->match_sets;\n\n\tif (request->ie && request->ie_len) {\n\t\toffset = 0;\n\t\tfor (i = 0; i < MWIFIEX_MAX_VSIE_NUM; i++) {\n\t\t\tif (priv->vs_ie[i].mask != MWIFIEX_VSIE_MASK_CLEAR)\n\t\t\t\tcontinue;\n\t\t\tpriv->vs_ie[i].mask = MWIFIEX_VSIE_MASK_BGSCAN;\n\t\t\tie = (struct ieee_types_header *)(request->ie + offset);\n\t\t\tmemcpy(&priv->vs_ie[i].ie, ie, sizeof(*ie) + ie->len);\n\t\t\toffset += sizeof(*ie) + ie->len;\n\n\t\t\tif (offset >= request->ie_len)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < min_t(u32, request->n_channels,\n\t\t\t      MWIFIEX_BG_SCAN_CHAN_MAX); i++) {\n\t\tchan = request->channels[i];\n\t\tbgscan_cfg->chan_list[i].chan_number = chan->hw_value;\n\t\tbgscan_cfg->chan_list[i].radio_type = chan->band;\n\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_IR) || !request->n_ssids)\n\t\t\tbgscan_cfg->chan_list[i].scan_type =\n\t\t\t\t\t\tMWIFIEX_SCAN_TYPE_PASSIVE;\n\t\telse\n\t\t\tbgscan_cfg->chan_list[i].scan_type =\n\t\t\t\t\t\tMWIFIEX_SCAN_TYPE_ACTIVE;\n\n\t\tbgscan_cfg->chan_list[i].scan_time = 0;\n\t}\n\n\tbgscan_cfg->chan_per_scan = min_t(u32, request->n_channels,\n\t\t\t\t\t  MWIFIEX_BG_SCAN_CHAN_MAX);\n\n\t \n\tbgscan_cfg->scan_interval = (request->scan_plans->interval >\n\t\t\t\t     MWIFIEX_BGSCAN_INTERVAL) ?\n\t\t\t\trequest->scan_plans->interval :\n\t\t\t\tMWIFIEX_BGSCAN_INTERVAL;\n\n\tbgscan_cfg->repeat_count = MWIFIEX_BGSCAN_REPEAT_COUNT;\n\tbgscan_cfg->report_condition = MWIFIEX_BGSCAN_SSID_MATCH |\n\t\t\t\tMWIFIEX_BGSCAN_WAIT_ALL_CHAN_DONE;\n\tbgscan_cfg->bss_type = MWIFIEX_BSS_MODE_INFRA;\n\tbgscan_cfg->action = MWIFIEX_BGSCAN_ACT_SET;\n\tbgscan_cfg->enable = true;\n\tif (request->min_rssi_thold != NL80211_SCAN_RSSI_THOLD_OFF) {\n\t\tbgscan_cfg->report_condition |= MWIFIEX_BGSCAN_SSID_RSSI_MATCH;\n\t\tbgscan_cfg->rssi_threshold = request->min_rssi_thold;\n\t}\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11_BG_SCAN_CONFIG,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, bgscan_cfg, true)) {\n\t\tkfree(bgscan_cfg);\n\t\treturn -EFAULT;\n\t}\n\n\tpriv->sched_scanning = true;\n\n\tkfree(bgscan_cfg);\n\treturn 0;\n}\n\n \nstatic int mwifiex_cfg80211_sched_scan_stop(struct wiphy *wiphy,\n\t\t\t\t\t    struct net_device *dev, u64 reqid)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\twiphy_info(wiphy, \"sched scan stop!\");\n\tmwifiex_stop_bg_scan(priv);\n\n\treturn 0;\n}\n\nstatic void mwifiex_setup_vht_caps(struct ieee80211_sta_vht_cap *vht_info,\n\t\t\t\t   struct mwifiex_private *priv)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tvht_info->vht_supported = true;\n\n\tvht_info->cap = adapter->hw_dot_11ac_dev_cap;\n\t \n\tvht_info->vht_mcs.rx_mcs_map = cpu_to_le16(\n\t\t\t\tadapter->hw_dot_11ac_mcs_support & 0xFFFF);\n\tvht_info->vht_mcs.rx_highest = 0;\n\tvht_info->vht_mcs.tx_mcs_map = cpu_to_le16(\n\t\t\t\tadapter->hw_dot_11ac_mcs_support >> 16);\n\tvht_info->vht_mcs.tx_highest = 0;\n}\n\n \nstatic void\nmwifiex_setup_ht_caps(struct ieee80211_sta_ht_cap *ht_info,\n\t\t      struct mwifiex_private *priv)\n{\n\tint rx_mcs_supp;\n\tstruct ieee80211_mcs_info mcs_set;\n\tu8 *mcs = (u8 *)&mcs_set;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tht_info->ht_supported = true;\n\tht_info->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tht_info->ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;\n\n\tmemset(&ht_info->mcs, 0, sizeof(ht_info->mcs));\n\n\t \n\tif (ISSUPP_CHANWIDTH40(adapter->hw_dot_11n_dev_cap))\n\t\tht_info->cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\telse\n\t\tht_info->cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\n\tif (ISSUPP_SHORTGI20(adapter->hw_dot_11n_dev_cap))\n\t\tht_info->cap |= IEEE80211_HT_CAP_SGI_20;\n\telse\n\t\tht_info->cap &= ~IEEE80211_HT_CAP_SGI_20;\n\n\tif (ISSUPP_SHORTGI40(adapter->hw_dot_11n_dev_cap))\n\t\tht_info->cap |= IEEE80211_HT_CAP_SGI_40;\n\telse\n\t\tht_info->cap &= ~IEEE80211_HT_CAP_SGI_40;\n\n\tif (adapter->user_dev_mcs_support == HT_STREAM_2X2)\n\t\tht_info->cap |= 2 << IEEE80211_HT_CAP_RX_STBC_SHIFT;\n\telse\n\t\tht_info->cap |= 1 << IEEE80211_HT_CAP_RX_STBC_SHIFT;\n\n\tif (ISSUPP_TXSTBC(adapter->hw_dot_11n_dev_cap))\n\t\tht_info->cap |= IEEE80211_HT_CAP_TX_STBC;\n\telse\n\t\tht_info->cap &= ~IEEE80211_HT_CAP_TX_STBC;\n\n\tif (ISSUPP_GREENFIELD(adapter->hw_dot_11n_dev_cap))\n\t\tht_info->cap |= IEEE80211_HT_CAP_GRN_FLD;\n\telse\n\t\tht_info->cap &= ~IEEE80211_HT_CAP_GRN_FLD;\n\n\tif (ISENABLED_40MHZ_INTOLERANT(adapter->hw_dot_11n_dev_cap))\n\t\tht_info->cap |= IEEE80211_HT_CAP_40MHZ_INTOLERANT;\n\telse\n\t\tht_info->cap &= ~IEEE80211_HT_CAP_40MHZ_INTOLERANT;\n\n\tif (ISSUPP_RXLDPC(adapter->hw_dot_11n_dev_cap))\n\t\tht_info->cap |= IEEE80211_HT_CAP_LDPC_CODING;\n\telse\n\t\tht_info->cap &= ~IEEE80211_HT_CAP_LDPC_CODING;\n\n\tht_info->cap &= ~IEEE80211_HT_CAP_MAX_AMSDU;\n\tht_info->cap |= IEEE80211_HT_CAP_SM_PS;\n\n\trx_mcs_supp = GET_RXMCSSUPP(adapter->user_dev_mcs_support);\n\t \n\tmemset(mcs, 0xff, rx_mcs_supp);\n\t \n\tmemset(&mcs[rx_mcs_supp], 0,\n\t       sizeof(struct ieee80211_mcs_info) - rx_mcs_supp);\n\tif (priv->bss_mode == NL80211_IFTYPE_STATION ||\n\t    ISSUPP_CHANWIDTH40(adapter->hw_dot_11n_dev_cap))\n\t\t \n\t\tSETHT_MCS32(mcs_set.rx_mask);\n\n\tmemcpy((u8 *) &ht_info->mcs, mcs, sizeof(struct ieee80211_mcs_info));\n\n\tht_info->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n}\n\n \nstruct wireless_dev *mwifiex_add_virtual_intf(struct wiphy *wiphy,\n\t\t\t\t\t      const char *name,\n\t\t\t\t\t      unsigned char name_assign_type,\n\t\t\t\t\t      enum nl80211_iftype type,\n\t\t\t\t\t      struct vif_params *params)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv;\n\tstruct net_device *dev;\n\tvoid *mdev_priv;\n\tint ret;\n\n\tif (!adapter)\n\t\treturn ERR_PTR(-EFAULT);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (adapter->curr_iface_comb.sta_intf ==\n\t\t    adapter->iface_limit.sta_intf) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cannot create multiple sta/adhoc ifaces\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tpriv = mwifiex_get_unused_priv_by_bss_type(\n\t\t\t\t\t\tadapter, MWIFIEX_BSS_TYPE_STA);\n\t\tif (!priv) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"could not get free private struct\\n\");\n\t\t\treturn ERR_PTR(-EFAULT);\n\t\t}\n\n\t\tpriv->wdev.wiphy = wiphy;\n\t\tpriv->wdev.iftype = NL80211_IFTYPE_STATION;\n\n\t\tif (type == NL80211_IFTYPE_UNSPECIFIED)\n\t\t\tpriv->bss_mode = NL80211_IFTYPE_STATION;\n\t\telse\n\t\t\tpriv->bss_mode = type;\n\n\t\tpriv->bss_type = MWIFIEX_BSS_TYPE_STA;\n\t\tpriv->frame_type = MWIFIEX_DATA_FRAME_TYPE_ETH_II;\n\t\tpriv->bss_priority = 0;\n\t\tpriv->bss_role = MWIFIEX_BSS_ROLE_STA;\n\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tif (adapter->curr_iface_comb.uap_intf ==\n\t\t    adapter->iface_limit.uap_intf) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cannot create multiple AP ifaces\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tpriv = mwifiex_get_unused_priv_by_bss_type(\n\t\t\t\t\t\tadapter, MWIFIEX_BSS_TYPE_UAP);\n\t\tif (!priv) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"could not get free private struct\\n\");\n\t\t\treturn ERR_PTR(-EFAULT);\n\t\t}\n\n\t\tpriv->wdev.wiphy = wiphy;\n\t\tpriv->wdev.iftype = NL80211_IFTYPE_AP;\n\n\t\tpriv->bss_type = MWIFIEX_BSS_TYPE_UAP;\n\t\tpriv->frame_type = MWIFIEX_DATA_FRAME_TYPE_ETH_II;\n\t\tpriv->bss_priority = 0;\n\t\tpriv->bss_role = MWIFIEX_BSS_ROLE_UAP;\n\t\tpriv->bss_started = 0;\n\t\tpriv->bss_mode = type;\n\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (adapter->curr_iface_comb.p2p_intf ==\n\t\t    adapter->iface_limit.p2p_intf) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cannot create multiple P2P ifaces\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tpriv = mwifiex_get_unused_priv_by_bss_type(\n\t\t\t\t\t\tadapter, MWIFIEX_BSS_TYPE_P2P);\n\t\tif (!priv) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"could not get free private struct\\n\");\n\t\t\treturn ERR_PTR(-EFAULT);\n\t\t}\n\n\t\tpriv->wdev.wiphy = wiphy;\n\t\t \n\t\tpriv->wdev.iftype = NL80211_IFTYPE_P2P_CLIENT;\n\t\tpriv->bss_mode = NL80211_IFTYPE_P2P_CLIENT;\n\n\t\t \n\t\tpriv->bss_type = MWIFIEX_BSS_TYPE_P2P;\n\n\t\tpriv->frame_type = MWIFIEX_DATA_FRAME_TYPE_ETH_II;\n\t\tpriv->bss_priority = 0;\n\t\tpriv->bss_role = MWIFIEX_BSS_ROLE_STA;\n\t\tpriv->bss_started = 0;\n\n\t\tif (mwifiex_cfg80211_init_p2p_client(priv)) {\n\t\t\tmemset(&priv->wdev, 0, sizeof(priv->wdev));\n\t\t\tpriv->wdev.iftype = NL80211_IFTYPE_UNSPECIFIED;\n\t\t\treturn ERR_PTR(-EFAULT);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(adapter, ERROR, \"type not supported\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tdev = alloc_netdev_mqs(sizeof(struct mwifiex_private *), name,\n\t\t\t       name_assign_type, ether_setup,\n\t\t\t       IEEE80211_NUM_ACS, 1);\n\tif (!dev) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"no memory available for netdevice\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_netdev;\n\t}\n\n\tmwifiex_init_priv_params(priv, dev);\n\n\tpriv->netdev = dev;\n\n\tif (!adapter->mfg_mode) {\n\t\tmwifiex_set_mac_address(priv, dev, false, NULL);\n\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_SET_BSS_MODE,\n\t\t\t\t       HostCmd_ACT_GEN_SET, 0, NULL, true);\n\t\tif (ret)\n\t\t\tgoto err_set_bss_mode;\n\n\t\tret = mwifiex_sta_init_cmd(priv, false, false);\n\t\tif (ret)\n\t\t\tgoto err_sta_init;\n\t}\n\n\tmwifiex_setup_ht_caps(&wiphy->bands[NL80211_BAND_2GHZ]->ht_cap, priv);\n\tif (adapter->is_hw_11ac_capable)\n\t\tmwifiex_setup_vht_caps(\n\t\t\t&wiphy->bands[NL80211_BAND_2GHZ]->vht_cap, priv);\n\n\tif (adapter->config_bands & BAND_A)\n\t\tmwifiex_setup_ht_caps(\n\t\t\t&wiphy->bands[NL80211_BAND_5GHZ]->ht_cap, priv);\n\n\tif ((adapter->config_bands & BAND_A) && adapter->is_hw_11ac_capable)\n\t\tmwifiex_setup_vht_caps(\n\t\t\t&wiphy->bands[NL80211_BAND_5GHZ]->vht_cap, priv);\n\n\tdev_net_set(dev, wiphy_net(wiphy));\n\tdev->ieee80211_ptr = &priv->wdev;\n\tdev->ieee80211_ptr->iftype = priv->bss_mode;\n\tSET_NETDEV_DEV(dev, wiphy_dev(wiphy));\n\n\tdev->flags |= IFF_BROADCAST | IFF_MULTICAST;\n\tdev->watchdog_timeo = MWIFIEX_DEFAULT_WATCHDOG_TIMEOUT;\n\tdev->needed_headroom = MWIFIEX_MIN_DATA_HEADER_LEN;\n\tdev->ethtool_ops = &mwifiex_ethtool_ops;\n\n\tmdev_priv = netdev_priv(dev);\n\t*((unsigned long *) mdev_priv) = (unsigned long) priv;\n\n\tSET_NETDEV_DEV(dev, adapter->dev);\n\n\tpriv->dfs_cac_workqueue = alloc_workqueue(\"MWIFIEX_DFS_CAC%s\",\n\t\t\t\t\t\t  WQ_HIGHPRI |\n\t\t\t\t\t\t  WQ_MEM_RECLAIM |\n\t\t\t\t\t\t  WQ_UNBOUND, 0, name);\n\tif (!priv->dfs_cac_workqueue) {\n\t\tmwifiex_dbg(adapter, ERROR, \"cannot alloc DFS CAC queue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_cac;\n\t}\n\n\tINIT_DELAYED_WORK(&priv->dfs_cac_work, mwifiex_dfs_cac_work_queue);\n\n\tpriv->dfs_chan_sw_workqueue = alloc_workqueue(\"MWIFIEX_DFS_CHSW%s\",\n\t\t\t\t\t\t      WQ_HIGHPRI | WQ_UNBOUND |\n\t\t\t\t\t\t      WQ_MEM_RECLAIM, 0, name);\n\tif (!priv->dfs_chan_sw_workqueue) {\n\t\tmwifiex_dbg(adapter, ERROR, \"cannot alloc DFS channel sw queue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_chsw;\n\t}\n\n\tINIT_DELAYED_WORK(&priv->dfs_chan_sw_work,\n\t\t\t  mwifiex_dfs_chan_sw_work_queue);\n\n\tmutex_init(&priv->async_mutex);\n\n\t \n\tif (cfg80211_register_netdevice(dev)) {\n\t\tmwifiex_dbg(adapter, ERROR, \"cannot register network device\\n\");\n\t\tret = -EFAULT;\n\t\tgoto err_reg_netdev;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: %s: Marvell 802.11 Adapter\\n\", dev->name);\n\n#ifdef CONFIG_DEBUG_FS\n\tmwifiex_dev_debugfs_init(priv);\n#endif\n\n\tupdate_vif_type_counter(adapter, type, +1);\n\n\treturn &priv->wdev;\n\nerr_reg_netdev:\n\tdestroy_workqueue(priv->dfs_chan_sw_workqueue);\n\tpriv->dfs_chan_sw_workqueue = NULL;\nerr_alloc_chsw:\n\tdestroy_workqueue(priv->dfs_cac_workqueue);\n\tpriv->dfs_cac_workqueue = NULL;\nerr_alloc_cac:\n\tfree_netdev(dev);\n\tpriv->netdev = NULL;\nerr_sta_init:\nerr_set_bss_mode:\nerr_alloc_netdev:\n\tmemset(&priv->wdev, 0, sizeof(priv->wdev));\n\tpriv->wdev.iftype = NL80211_IFTYPE_UNSPECIFIED;\n\tpriv->bss_mode = NL80211_IFTYPE_UNSPECIFIED;\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(mwifiex_add_virtual_intf);\n\n \nint mwifiex_del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct sk_buff *skb, *tmp;\n\n#ifdef CONFIG_DEBUG_FS\n\tmwifiex_dev_debugfs_remove(priv);\n#endif\n\n\tif (priv->sched_scanning)\n\t\tpriv->sched_scanning = false;\n\n\tmwifiex_stop_net_dev_queue(priv->netdev, adapter);\n\n\tskb_queue_walk_safe(&priv->bypass_txq, skb, tmp) {\n\t\tskb_unlink(skb, &priv->bypass_txq);\n\t\tmwifiex_write_data_complete(priv->adapter, skb, 0, -1);\n\t}\n\n\tif (netif_carrier_ok(priv->netdev))\n\t\tnetif_carrier_off(priv->netdev);\n\n\tif (wdev->netdev->reg_state == NETREG_REGISTERED)\n\t\tcfg80211_unregister_netdevice(wdev->netdev);\n\n\tif (priv->dfs_cac_workqueue) {\n\t\tdestroy_workqueue(priv->dfs_cac_workqueue);\n\t\tpriv->dfs_cac_workqueue = NULL;\n\t}\n\n\tif (priv->dfs_chan_sw_workqueue) {\n\t\tdestroy_workqueue(priv->dfs_chan_sw_workqueue);\n\t\tpriv->dfs_chan_sw_workqueue = NULL;\n\t}\n\t \n\tpriv->netdev = NULL;\n\n\tupdate_vif_type_counter(adapter, priv->bss_mode, -1);\n\n\tpriv->bss_mode = NL80211_IFTYPE_UNSPECIFIED;\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA ||\n\t    GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP)\n\t\tkfree(priv->hist_data);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mwifiex_del_virtual_intf);\n\nstatic bool\nmwifiex_is_pattern_supported(struct cfg80211_pkt_pattern *pat, s8 *byte_seq,\n\t\t\t     u8 max_byte_seq)\n{\n\tint j, k, valid_byte_cnt = 0;\n\tbool dont_care_byte = false;\n\n\tfor (j = 0; j < DIV_ROUND_UP(pat->pattern_len, 8); j++) {\n\t\tfor (k = 0; k < 8; k++) {\n\t\t\tif (pat->mask[j] & 1 << k) {\n\t\t\t\tmemcpy(byte_seq + valid_byte_cnt,\n\t\t\t\t       &pat->pattern[j * 8 + k], 1);\n\t\t\t\tvalid_byte_cnt++;\n\t\t\t\tif (dont_care_byte)\n\t\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tif (valid_byte_cnt)\n\t\t\t\t\tdont_care_byte = true;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!valid_byte_cnt && !dont_care_byte)\n\t\t\t\tpat->pkt_offset++;\n\n\t\t\tif (valid_byte_cnt > max_byte_seq)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tbyte_seq[max_byte_seq] = valid_byte_cnt;\n\n\treturn true;\n}\n\n#ifdef CONFIG_PM\nstatic void mwifiex_set_auto_arp_mef_entry(struct mwifiex_private *priv,\n\t\t\t\t\t   struct mwifiex_mef_entry *mef_entry)\n{\n\tint i, filt_num = 0, num_ipv4 = 0;\n\tstruct in_device *in_dev;\n\tstruct in_ifaddr *ifa;\n\t__be32 ips[MWIFIEX_MAX_SUPPORTED_IPADDR];\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tmef_entry->mode = MEF_MODE_HOST_SLEEP;\n\tmef_entry->action = MEF_ACTION_AUTO_ARP;\n\n\t \n\tmemset(ips, 0, sizeof(ips));\n\tfor (i = 0; i < MWIFIEX_MAX_BSS_NUM; i++) {\n\t\tif (adapter->priv[i]->netdev) {\n\t\t\tin_dev = __in_dev_get_rtnl(adapter->priv[i]->netdev);\n\t\t\tif (!in_dev)\n\t\t\t\tcontinue;\n\t\t\tifa = rtnl_dereference(in_dev->ifa_list);\n\t\t\tif (!ifa || !ifa->ifa_local)\n\t\t\t\tcontinue;\n\t\t\tips[i] = ifa->ifa_local;\n\t\t\tnum_ipv4++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_ipv4; i++) {\n\t\tif (!ips[i])\n\t\t\tcontinue;\n\t\tmef_entry->filter[filt_num].repeat = 1;\n\t\tmemcpy(mef_entry->filter[filt_num].byte_seq,\n\t\t       (u8 *)&ips[i], sizeof(ips[i]));\n\t\tmef_entry->filter[filt_num].\n\t\t\tbyte_seq[MWIFIEX_MEF_MAX_BYTESEQ] =\n\t\t\tsizeof(ips[i]);\n\t\tmef_entry->filter[filt_num].offset = 46;\n\t\tmef_entry->filter[filt_num].filt_type = TYPE_EQ;\n\t\tif (filt_num) {\n\t\t\tmef_entry->filter[filt_num].filt_action =\n\t\t\t\tTYPE_OR;\n\t\t}\n\t\tfilt_num++;\n\t}\n\n\tmef_entry->filter[filt_num].repeat = 1;\n\tmef_entry->filter[filt_num].byte_seq[0] = 0x08;\n\tmef_entry->filter[filt_num].byte_seq[1] = 0x06;\n\tmef_entry->filter[filt_num].byte_seq[MWIFIEX_MEF_MAX_BYTESEQ] = 2;\n\tmef_entry->filter[filt_num].offset = 20;\n\tmef_entry->filter[filt_num].filt_type = TYPE_EQ;\n\tmef_entry->filter[filt_num].filt_action = TYPE_AND;\n}\n\nstatic int mwifiex_set_wowlan_mef_entry(struct mwifiex_private *priv,\n\t\t\t\t\tstruct mwifiex_ds_mef_cfg *mef_cfg,\n\t\t\t\t\tstruct mwifiex_mef_entry *mef_entry,\n\t\t\t\t\tstruct cfg80211_wowlan *wowlan)\n{\n\tint i, filt_num = 0, ret = 0;\n\tbool first_pat = true;\n\tu8 byte_seq[MWIFIEX_MEF_MAX_BYTESEQ + 1];\n\tstatic const u8 ipv4_mc_mac[] = {0x33, 0x33};\n\tstatic const u8 ipv6_mc_mac[] = {0x01, 0x00, 0x5e};\n\n\tmef_entry->mode = MEF_MODE_HOST_SLEEP;\n\tmef_entry->action = MEF_ACTION_ALLOW_AND_WAKEUP_HOST;\n\n\tfor (i = 0; i < wowlan->n_patterns; i++) {\n\t\tmemset(byte_seq, 0, sizeof(byte_seq));\n\t\tif (!mwifiex_is_pattern_supported(&wowlan->patterns[i],\n\t\t\t\t\tbyte_seq,\n\t\t\t\t\tMWIFIEX_MEF_MAX_BYTESEQ)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"Pattern not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (!wowlan->patterns[i].pkt_offset) {\n\t\t\tif (!(byte_seq[0] & 0x01) &&\n\t\t\t    (byte_seq[MWIFIEX_MEF_MAX_BYTESEQ] == 1)) {\n\t\t\t\tmef_cfg->criteria |= MWIFIEX_CRITERIA_UNICAST;\n\t\t\t\tcontinue;\n\t\t\t} else if (is_broadcast_ether_addr(byte_seq)) {\n\t\t\t\tmef_cfg->criteria |= MWIFIEX_CRITERIA_BROADCAST;\n\t\t\t\tcontinue;\n\t\t\t} else if ((!memcmp(byte_seq, ipv4_mc_mac, 2) &&\n\t\t\t\t    (byte_seq[MWIFIEX_MEF_MAX_BYTESEQ] == 2)) ||\n\t\t\t\t   (!memcmp(byte_seq, ipv6_mc_mac, 3) &&\n\t\t\t\t    (byte_seq[MWIFIEX_MEF_MAX_BYTESEQ] == 3))) {\n\t\t\t\tmef_cfg->criteria |= MWIFIEX_CRITERIA_MULTICAST;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tmef_entry->filter[filt_num].repeat = 1;\n\t\tmef_entry->filter[filt_num].offset =\n\t\t\twowlan->patterns[i].pkt_offset;\n\t\tmemcpy(mef_entry->filter[filt_num].byte_seq, byte_seq,\n\t\t\t\tsizeof(byte_seq));\n\t\tmef_entry->filter[filt_num].filt_type = TYPE_EQ;\n\n\t\tif (first_pat) {\n\t\t\tfirst_pat = false;\n\t\t\tmwifiex_dbg(priv->adapter, INFO, \"Wake on patterns\\n\");\n\t\t} else {\n\t\t\tmef_entry->filter[filt_num].filt_action = TYPE_AND;\n\t\t}\n\n\t\tfilt_num++;\n\t}\n\n\tif (wowlan->magic_pkt) {\n\t\tmef_cfg->criteria |= MWIFIEX_CRITERIA_UNICAST;\n\t\tmef_entry->filter[filt_num].repeat = 16;\n\t\tmemcpy(mef_entry->filter[filt_num].byte_seq, priv->curr_addr,\n\t\t\t\tETH_ALEN);\n\t\tmef_entry->filter[filt_num].byte_seq[MWIFIEX_MEF_MAX_BYTESEQ] =\n\t\t\tETH_ALEN;\n\t\tmef_entry->filter[filt_num].offset = 28;\n\t\tmef_entry->filter[filt_num].filt_type = TYPE_EQ;\n\t\tif (filt_num)\n\t\t\tmef_entry->filter[filt_num].filt_action = TYPE_OR;\n\n\t\tfilt_num++;\n\t\tmef_entry->filter[filt_num].repeat = 16;\n\t\tmemcpy(mef_entry->filter[filt_num].byte_seq, priv->curr_addr,\n\t\t\t\tETH_ALEN);\n\t\tmef_entry->filter[filt_num].byte_seq[MWIFIEX_MEF_MAX_BYTESEQ] =\n\t\t\tETH_ALEN;\n\t\tmef_entry->filter[filt_num].offset = 56;\n\t\tmef_entry->filter[filt_num].filt_type = TYPE_EQ;\n\t\tmef_entry->filter[filt_num].filt_action = TYPE_OR;\n\t\tmwifiex_dbg(priv->adapter, INFO, \"Wake on magic packet\\n\");\n\t}\n\treturn ret;\n}\n\nstatic int mwifiex_set_mef_filter(struct mwifiex_private *priv,\n\t\t\t\t  struct cfg80211_wowlan *wowlan)\n{\n\tint ret = 0, num_entries = 1;\n\tstruct mwifiex_ds_mef_cfg mef_cfg;\n\tstruct mwifiex_mef_entry *mef_entry;\n\n\tif (wowlan->n_patterns || wowlan->magic_pkt)\n\t\tnum_entries++;\n\n\tmef_entry = kcalloc(num_entries, sizeof(*mef_entry), GFP_KERNEL);\n\tif (!mef_entry)\n\t\treturn -ENOMEM;\n\n\tmemset(&mef_cfg, 0, sizeof(mef_cfg));\n\tmef_cfg.criteria |= MWIFIEX_CRITERIA_BROADCAST |\n\t\tMWIFIEX_CRITERIA_UNICAST;\n\tmef_cfg.num_entries = num_entries;\n\tmef_cfg.mef_entry = mef_entry;\n\n\tmwifiex_set_auto_arp_mef_entry(priv, &mef_entry[0]);\n\n\tif (wowlan->n_patterns || wowlan->magic_pkt) {\n\t\tret = mwifiex_set_wowlan_mef_entry(priv, &mef_cfg,\n\t\t\t\t\t\t   &mef_entry[1], wowlan);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (!mef_cfg.criteria)\n\t\tmef_cfg.criteria = MWIFIEX_CRITERIA_BROADCAST |\n\t\t\tMWIFIEX_CRITERIA_UNICAST |\n\t\t\tMWIFIEX_CRITERIA_MULTICAST;\n\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_MEF_CFG,\n\t\t\tHostCmd_ACT_GEN_SET, 0,\n\t\t\t&mef_cfg, true);\n\nerr:\n\tkfree(mef_entry);\n\treturn ret;\n}\n\nstatic int mwifiex_cfg80211_suspend(struct wiphy *wiphy,\n\t\t\t\t    struct cfg80211_wowlan *wowlan)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_ds_hs_cfg hs_cfg;\n\tint i, ret = 0, retry_num = 10;\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_private *sta_priv =\n\t\t\tmwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA);\n\n\tsta_priv->scan_aborting = true;\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tmwifiex_abort_cac(priv);\n\t}\n\n\tmwifiex_cancel_all_pending_cmd(adapter);\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tif (priv && priv->netdev)\n\t\t\tnetif_device_detach(priv->netdev);\n\t}\n\n\tfor (i = 0; i < retry_num; i++) {\n\t\tif (!mwifiex_wmm_lists_empty(adapter) ||\n\t\t    !mwifiex_bypass_txlist_empty(adapter) ||\n\t\t    !skb_queue_empty(&adapter->tx_data_q))\n\t\t\tusleep_range(10000, 15000);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (!wowlan) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"None of the WOWLAN triggers enabled\\n\");\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\tif (!sta_priv->media_connected && !wowlan->nd_config) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Can not configure WOWLAN in disconnected state\\n\");\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\tret = mwifiex_set_mef_filter(sta_priv, wowlan);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to set MEF filter\\n\");\n\t\tgoto done;\n\t}\n\n\tmemset(&hs_cfg, 0, sizeof(hs_cfg));\n\ths_cfg.conditions = le32_to_cpu(adapter->hs_cfg.conditions);\n\n\tif (wowlan->nd_config) {\n\t\tmwifiex_dbg(adapter, INFO, \"Wake on net detect\\n\");\n\t\ths_cfg.conditions |= HS_CFG_COND_MAC_EVENT;\n\t\tmwifiex_cfg80211_sched_scan_start(wiphy, sta_priv->netdev,\n\t\t\t\t\t\t  wowlan->nd_config);\n\t}\n\n\tif (wowlan->disconnect) {\n\t\ths_cfg.conditions |= HS_CFG_COND_MAC_EVENT;\n\t\tmwifiex_dbg(sta_priv->adapter, INFO, \"Wake on device disconnect\\n\");\n\t}\n\n\ths_cfg.is_invoke_hostcmd = false;\n\ths_cfg.gpio = adapter->hs_cfg.gpio;\n\ths_cfg.gap = adapter->hs_cfg.gap;\n\tret = mwifiex_set_hs_params(sta_priv, HostCmd_ACT_GEN_SET,\n\t\t\t\t    MWIFIEX_SYNC_CMD, &hs_cfg);\n\tif (ret)\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to set HS params\\n\");\n\ndone:\n\tsta_priv->scan_aborting = false;\n\treturn ret;\n}\n\nstatic int mwifiex_cfg80211_resume(struct wiphy *wiphy)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_ds_wakeup_reason wakeup_reason;\n\tstruct cfg80211_wowlan_wakeup wakeup_report;\n\tint i;\n\tbool report_wakeup_reason = true;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tif (priv && priv->netdev)\n\t\t\tnetif_device_attach(priv->netdev);\n\t}\n\n\tif (!wiphy->wowlan_config)\n\t\tgoto done;\n\n\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA);\n\tmwifiex_get_wakeup_reason(priv, HostCmd_ACT_GEN_GET, MWIFIEX_SYNC_CMD,\n\t\t\t\t  &wakeup_reason);\n\tmemset(&wakeup_report, 0, sizeof(struct cfg80211_wowlan_wakeup));\n\n\twakeup_report.pattern_idx = -1;\n\n\tswitch (wakeup_reason.hs_wakeup_reason) {\n\tcase NO_HSWAKEUP_REASON:\n\t\tbreak;\n\tcase BCAST_DATA_MATCHED:\n\t\tbreak;\n\tcase MCAST_DATA_MATCHED:\n\t\tbreak;\n\tcase UCAST_DATA_MATCHED:\n\t\tbreak;\n\tcase MASKTABLE_EVENT_MATCHED:\n\t\tbreak;\n\tcase NON_MASKABLE_EVENT_MATCHED:\n\t\tif (wiphy->wowlan_config->disconnect)\n\t\t\twakeup_report.disconnect = true;\n\t\tif (wiphy->wowlan_config->nd_config)\n\t\t\twakeup_report.net_detect = adapter->nd_info;\n\t\tbreak;\n\tcase NON_MASKABLE_CONDITION_MATCHED:\n\t\tbreak;\n\tcase MAGIC_PATTERN_MATCHED:\n\t\tif (wiphy->wowlan_config->magic_pkt)\n\t\t\twakeup_report.magic_pkt = true;\n\t\tif (wiphy->wowlan_config->n_patterns)\n\t\t\twakeup_report.pattern_idx = 1;\n\t\tbreak;\n\tcase GTK_REKEY_FAILURE:\n\t\tif (wiphy->wowlan_config->gtk_rekey_failure)\n\t\t\twakeup_report.gtk_rekey_failure = true;\n\t\tbreak;\n\tdefault:\n\t\treport_wakeup_reason = false;\n\t\tbreak;\n\t}\n\n\tif (report_wakeup_reason)\n\t\tcfg80211_report_wowlan_wakeup(&priv->wdev, &wakeup_report,\n\t\t\t\t\t      GFP_KERNEL);\n\ndone:\n\tif (adapter->nd_info) {\n\t\tfor (i = 0 ; i < adapter->nd_info->n_matches ; i++)\n\t\t\tkfree(adapter->nd_info->matches[i]);\n\t\tkfree(adapter->nd_info);\n\t\tadapter->nd_info = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic void mwifiex_cfg80211_set_wakeup(struct wiphy *wiphy,\n\t\t\t\t       bool enabled)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\n\tdevice_set_wakeup_enable(adapter->dev, enabled);\n}\n\nstatic int mwifiex_set_rekey_data(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  struct cfg80211_gtk_rekey_data *data)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\tif (!ISSUPP_FIRMWARE_SUPPLICANT(priv->adapter->fw_cap_info))\n\t\treturn -EOPNOTSUPP;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, data, true);\n}\n\n#endif\n\nstatic int mwifiex_get_coalesce_pkt_type(u8 *byte_seq)\n{\n\tstatic const u8 ipv4_mc_mac[] = {0x33, 0x33};\n\tstatic const u8 ipv6_mc_mac[] = {0x01, 0x00, 0x5e};\n\tstatic const u8 bc_mac[] = {0xff, 0xff, 0xff, 0xff};\n\n\tif ((byte_seq[0] & 0x01) &&\n\t    (byte_seq[MWIFIEX_COALESCE_MAX_BYTESEQ] == 1))\n\t\treturn PACKET_TYPE_UNICAST;\n\telse if (!memcmp(byte_seq, bc_mac, 4))\n\t\treturn PACKET_TYPE_BROADCAST;\n\telse if ((!memcmp(byte_seq, ipv4_mc_mac, 2) &&\n\t\t  byte_seq[MWIFIEX_COALESCE_MAX_BYTESEQ] == 2) ||\n\t\t (!memcmp(byte_seq, ipv6_mc_mac, 3) &&\n\t\t  byte_seq[MWIFIEX_COALESCE_MAX_BYTESEQ] == 3))\n\t\treturn PACKET_TYPE_MULTICAST;\n\n\treturn 0;\n}\n\nstatic int\nmwifiex_fill_coalesce_rule_info(struct mwifiex_private *priv,\n\t\t\t\tstruct cfg80211_coalesce_rules *crule,\n\t\t\t\tstruct mwifiex_coalesce_rule *mrule)\n{\n\tu8 byte_seq[MWIFIEX_COALESCE_MAX_BYTESEQ + 1];\n\tstruct filt_field_param *param;\n\tint i;\n\n\tmrule->max_coalescing_delay = crule->delay;\n\n\tparam = mrule->params;\n\n\tfor (i = 0; i < crule->n_patterns; i++) {\n\t\tmemset(byte_seq, 0, sizeof(byte_seq));\n\t\tif (!mwifiex_is_pattern_supported(&crule->patterns[i],\n\t\t\t\t\t\t  byte_seq,\n\t\t\t\t\t\tMWIFIEX_COALESCE_MAX_BYTESEQ)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"Pattern not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (!crule->patterns[i].pkt_offset) {\n\t\t\tu8 pkt_type;\n\n\t\t\tpkt_type = mwifiex_get_coalesce_pkt_type(byte_seq);\n\t\t\tif (pkt_type && mrule->pkt_type) {\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"Multiple packet types not allowed\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t} else if (pkt_type) {\n\t\t\t\tmrule->pkt_type = pkt_type;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (crule->condition == NL80211_COALESCE_CONDITION_MATCH)\n\t\t\tparam->operation = RECV_FILTER_MATCH_TYPE_EQ;\n\t\telse\n\t\t\tparam->operation = RECV_FILTER_MATCH_TYPE_NE;\n\n\t\tparam->operand_len = byte_seq[MWIFIEX_COALESCE_MAX_BYTESEQ];\n\t\tmemcpy(param->operand_byte_stream, byte_seq,\n\t\t       param->operand_len);\n\t\tparam->offset = crule->patterns[i].pkt_offset;\n\t\tparam++;\n\n\t\tmrule->num_of_fields++;\n\t}\n\n\tif (!mrule->pkt_type) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Packet type can not be determined\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int mwifiex_cfg80211_set_coalesce(struct wiphy *wiphy,\n\t\t\t\t\t struct cfg80211_coalesce *coalesce)\n{\n\tstruct mwifiex_adapter *adapter = mwifiex_cfg80211_get_adapter(wiphy);\n\tint i, ret;\n\tstruct mwifiex_ds_coalesce_cfg coalesce_cfg;\n\tstruct mwifiex_private *priv =\n\t\t\tmwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA);\n\n\tmemset(&coalesce_cfg, 0, sizeof(coalesce_cfg));\n\tif (!coalesce) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"Disable coalesce and reset all previous rules\\n\");\n\t\treturn mwifiex_send_cmd(priv, HostCmd_CMD_COALESCE_CFG,\n\t\t\t\t\tHostCmd_ACT_GEN_SET, 0,\n\t\t\t\t\t&coalesce_cfg, true);\n\t}\n\n\tcoalesce_cfg.num_of_rules = coalesce->n_rules;\n\tfor (i = 0; i < coalesce->n_rules; i++) {\n\t\tret = mwifiex_fill_coalesce_rule_info(priv, &coalesce->rules[i],\n\t\t\t\t\t\t      &coalesce_cfg.rule[i]);\n\t\tif (ret) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Recheck the patterns provided for rule %d\\n\",\n\t\t\t\ti + 1);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_COALESCE_CFG,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &coalesce_cfg, true);\n}\n\n \nstatic int\nmwifiex_cfg80211_tdls_mgmt(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   const u8 *peer, int link_id, u8 action_code,\n\t\t\t   u8 dialog_token, u16 status_code,\n\t\t\t   u32 peer_capability, bool initiator,\n\t\t\t   const u8 *extra_ies, size_t extra_ies_len)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tint ret;\n\n\tif (!(wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!(priv->bss_type == MWIFIEX_BSS_TYPE_STA && priv->media_connected))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (action_code) {\n\tcase WLAN_TDLS_SETUP_REQUEST:\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"Send TDLS Setup Request to %pM status_code=%d\\n\",\n\t\t\t    peer, status_code);\n\t\tmwifiex_add_auto_tdls_peer(priv, peer);\n\t\tret = mwifiex_send_tdls_data_frame(priv, peer, action_code,\n\t\t\t\t\t\t   dialog_token, status_code,\n\t\t\t\t\t\t   extra_ies, extra_ies_len);\n\t\tbreak;\n\tcase WLAN_TDLS_SETUP_RESPONSE:\n\t\tmwifiex_add_auto_tdls_peer(priv, peer);\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"Send TDLS Setup Response to %pM status_code=%d\\n\",\n\t\t\t    peer, status_code);\n\t\tret = mwifiex_send_tdls_data_frame(priv, peer, action_code,\n\t\t\t\t\t\t   dialog_token, status_code,\n\t\t\t\t\t\t   extra_ies, extra_ies_len);\n\t\tbreak;\n\tcase WLAN_TDLS_SETUP_CONFIRM:\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"Send TDLS Confirm to %pM status_code=%d\\n\", peer,\n\t\t\t    status_code);\n\t\tret = mwifiex_send_tdls_data_frame(priv, peer, action_code,\n\t\t\t\t\t\t   dialog_token, status_code,\n\t\t\t\t\t\t   extra_ies, extra_ies_len);\n\t\tbreak;\n\tcase WLAN_TDLS_TEARDOWN:\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"Send TDLS Tear down to %pM\\n\", peer);\n\t\tret = mwifiex_send_tdls_data_frame(priv, peer, action_code,\n\t\t\t\t\t\t   dialog_token, status_code,\n\t\t\t\t\t\t   extra_ies, extra_ies_len);\n\t\tbreak;\n\tcase WLAN_TDLS_DISCOVERY_REQUEST:\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"Send TDLS Discovery Request to %pM\\n\", peer);\n\t\tret = mwifiex_send_tdls_data_frame(priv, peer, action_code,\n\t\t\t\t\t\t   dialog_token, status_code,\n\t\t\t\t\t\t   extra_ies, extra_ies_len);\n\t\tbreak;\n\tcase WLAN_PUB_ACTION_TDLS_DISCOVER_RES:\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"Send TDLS Discovery Response to %pM\\n\", peer);\n\t\tret = mwifiex_send_tdls_action_frame(priv, peer, action_code,\n\t\t\t\t\t\t   dialog_token, status_code,\n\t\t\t\t\t\t   extra_ies, extra_ies_len);\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Unknown TDLS mgmt/action frame %pM\\n\", peer);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nmwifiex_cfg80211_tdls_oper(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   const u8 *peer, enum nl80211_tdls_operation action)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\tif (!(wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS) ||\n\t    !(wiphy->flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!(priv->bss_type == MWIFIEX_BSS_TYPE_STA && priv->media_connected))\n\t\treturn -EOPNOTSUPP;\n\n\tmwifiex_dbg(priv->adapter, MSG,\n\t\t    \"TDLS peer=%pM, oper=%d\\n\", peer, action);\n\n\tswitch (action) {\n\tcase NL80211_TDLS_ENABLE_LINK:\n\t\taction = MWIFIEX_TDLS_ENABLE_LINK;\n\t\tbreak;\n\tcase NL80211_TDLS_DISABLE_LINK:\n\t\taction = MWIFIEX_TDLS_DISABLE_LINK;\n\t\tbreak;\n\tcase NL80211_TDLS_TEARDOWN:\n\t\t \n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"tdls_oper: teardown from driver not supported\\n\");\n\t\treturn -EINVAL;\n\tcase NL80211_TDLS_SETUP:\n\t\t \n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"tdls_oper: setup from driver not supported\\n\");\n\t\treturn -EINVAL;\n\tcase NL80211_TDLS_DISCOVERY_REQ:\n\t\t \n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"tdls_oper: discovery from driver not supported\\n\");\n\t\treturn -EINVAL;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"tdls_oper: operation not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn mwifiex_tdls_oper(priv, peer, action);\n}\n\nstatic int\nmwifiex_cfg80211_tdls_chan_switch(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const u8 *addr, u8 oper_class,\n\t\t\t\t  struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_sta_node *sta_ptr;\n\tu16 chan;\n\tu8 second_chan_offset, band;\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\tspin_lock_bh(&priv->sta_list_spinlock);\n\tsta_ptr = mwifiex_get_sta_entry(priv, addr);\n\tif (!sta_ptr) {\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\twiphy_err(wiphy, \"%s: Invalid TDLS peer %pM\\n\",\n\t\t\t  __func__, addr);\n\t\treturn -ENOENT;\n\t}\n\n\tif (!(sta_ptr->tdls_cap.extcap.ext_capab[3] &\n\t      WLAN_EXT_CAPA4_TDLS_CHAN_SWITCH)) {\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\twiphy_err(wiphy, \"%pM do not support tdls cs\\n\", addr);\n\t\treturn -ENOENT;\n\t}\n\n\tif (sta_ptr->tdls_status == TDLS_CHAN_SWITCHING ||\n\t    sta_ptr->tdls_status == TDLS_IN_OFF_CHAN) {\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\twiphy_err(wiphy, \"channel switch is running, abort request\\n\");\n\t\treturn -EALREADY;\n\t}\n\tspin_unlock_bh(&priv->sta_list_spinlock);\n\n\tchan = chandef->chan->hw_value;\n\tsecond_chan_offset = mwifiex_get_sec_chan_offset(chan);\n\tband = chandef->chan->band;\n\tmwifiex_start_tdls_cs(priv, addr, chan, second_chan_offset, band);\n\n\treturn 0;\n}\n\nstatic void\nmwifiex_cfg80211_tdls_cancel_chan_switch(struct wiphy *wiphy,\n\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t const u8 *addr)\n{\n\tstruct mwifiex_sta_node *sta_ptr;\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\tspin_lock_bh(&priv->sta_list_spinlock);\n\tsta_ptr = mwifiex_get_sta_entry(priv, addr);\n\tif (!sta_ptr) {\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\twiphy_err(wiphy, \"%s: Invalid TDLS peer %pM\\n\",\n\t\t\t  __func__, addr);\n\t} else if (!(sta_ptr->tdls_status == TDLS_CHAN_SWITCHING ||\n\t\t     sta_ptr->tdls_status == TDLS_IN_BASE_CHAN ||\n\t\t     sta_ptr->tdls_status == TDLS_IN_OFF_CHAN)) {\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\twiphy_err(wiphy, \"tdls chan switch not initialize by %pM\\n\",\n\t\t\t  addr);\n\t} else {\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\tmwifiex_stop_tdls_cs(priv, addr);\n\t}\n}\n\nstatic int\nmwifiex_cfg80211_add_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     const u8 *mac, struct station_parameters *params)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\tif (!(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((priv->bss_type != MWIFIEX_BSS_TYPE_STA) || !priv->media_connected)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mwifiex_tdls_oper(priv, mac, MWIFIEX_TDLS_CREATE_LINK);\n}\n\nstatic int\nmwifiex_cfg80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tstruct cfg80211_csa_settings *params)\n{\n\tstruct ieee_types_header *chsw_ie;\n\tstruct ieee80211_channel_sw_ie *channel_sw;\n\tint chsw_msec;\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\tif (priv->adapter->scan_processing) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"radar detection: scan in process...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (priv->wdev.cac_started)\n\t\treturn -EBUSY;\n\n\tif (cfg80211_chandef_identical(&params->chandef,\n\t\t\t\t       &priv->dfs_chandef))\n\t\treturn -EINVAL;\n\n\tchsw_ie = (void *)cfg80211_find_ie(WLAN_EID_CHANNEL_SWITCH,\n\t\t\t\t\t   params->beacon_csa.tail,\n\t\t\t\t\t   params->beacon_csa.tail_len);\n\tif (!chsw_ie) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Could not parse channel switch announcement IE\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannel_sw = (void *)(chsw_ie + 1);\n\tif (channel_sw->mode) {\n\t\tif (netif_carrier_ok(priv->netdev))\n\t\t\tnetif_carrier_off(priv->netdev);\n\t\tmwifiex_stop_net_dev_queue(priv->netdev, priv->adapter);\n\t}\n\n\tif (mwifiex_del_mgmt_ies(priv))\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to delete mgmt IEs!\\n\");\n\n\tif (mwifiex_set_mgmt_ies(priv, &params->beacon_csa)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"%s: setting mgmt ies failed\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(&priv->dfs_chandef, &params->chandef, sizeof(priv->dfs_chandef));\n\tmemcpy(&priv->beacon_after, &params->beacon_after,\n\t       sizeof(priv->beacon_after));\n\n\tchsw_msec = max(channel_sw->count * priv->bss_cfg.beacon_period, 100);\n\tqueue_delayed_work(priv->dfs_chan_sw_workqueue, &priv->dfs_chan_sw_work,\n\t\t\t   msecs_to_jiffies(chsw_msec));\n\treturn 0;\n}\n\nstatic int mwifiex_cfg80211_get_channel(struct wiphy *wiphy,\n\t\t\t\t\tstruct wireless_dev *wdev,\n\t\t\t\t\tunsigned int link_id,\n\t\t\t\t\tstruct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tstruct mwifiex_bssdescriptor *curr_bss;\n\tstruct ieee80211_channel *chan;\n\tenum nl80211_channel_type chan_type;\n\tenum nl80211_band band;\n\tint freq;\n\tint ret = -ENODATA;\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP &&\n\t    cfg80211_chandef_valid(&priv->bss_chandef)) {\n\t\t*chandef = priv->bss_chandef;\n\t\tret = 0;\n\t} else if (priv->media_connected) {\n\t\tcurr_bss = &priv->curr_bss_params.bss_descriptor;\n\t\tband = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n\t\tfreq = ieee80211_channel_to_frequency(curr_bss->channel, band);\n\t\tchan = ieee80211_get_channel(wiphy, freq);\n\n\t\tif (priv->ht_param_present) {\n\t\t\tchan_type = mwifiex_get_chan_type(priv);\n\t\t\tcfg80211_chandef_create(chandef, chan, chan_type);\n\t\t} else {\n\t\t\tcfg80211_chandef_create(chandef, chan,\n\t\t\t\t\t\tNL80211_CHAN_NO_HT);\n\t\t}\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_NL80211_TESTMODE\n\nenum mwifiex_tm_attr {\n\t__MWIFIEX_TM_ATTR_INVALID\t= 0,\n\tMWIFIEX_TM_ATTR_CMD\t\t= 1,\n\tMWIFIEX_TM_ATTR_DATA\t\t= 2,\n\n\t \n\t__MWIFIEX_TM_ATTR_AFTER_LAST,\n\tMWIFIEX_TM_ATTR_MAX\t\t= __MWIFIEX_TM_ATTR_AFTER_LAST - 1,\n};\n\nstatic const struct nla_policy mwifiex_tm_policy[MWIFIEX_TM_ATTR_MAX + 1] = {\n\t[MWIFIEX_TM_ATTR_CMD]\t\t= { .type = NLA_U32 },\n\t[MWIFIEX_TM_ATTR_DATA]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = MWIFIEX_SIZE_OF_CMD_BUFFER },\n};\n\nenum mwifiex_tm_command {\n\tMWIFIEX_TM_CMD_HOSTCMD\t= 0,\n};\n\nstatic int mwifiex_tm_cmd(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t  void *data, int len)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tstruct mwifiex_ds_misc_cmd *hostcmd;\n\tstruct nlattr *tb[MWIFIEX_TM_ATTR_MAX + 1];\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (!priv)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_deprecated(tb, MWIFIEX_TM_ATTR_MAX, data, len,\n\t\t\t\t   mwifiex_tm_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[MWIFIEX_TM_ATTR_CMD])\n\t\treturn -EINVAL;\n\n\tswitch (nla_get_u32(tb[MWIFIEX_TM_ATTR_CMD])) {\n\tcase MWIFIEX_TM_CMD_HOSTCMD:\n\t\tif (!tb[MWIFIEX_TM_ATTR_DATA])\n\t\t\treturn -EINVAL;\n\n\t\thostcmd = kzalloc(sizeof(*hostcmd), GFP_KERNEL);\n\t\tif (!hostcmd)\n\t\t\treturn -ENOMEM;\n\n\t\thostcmd->len = nla_len(tb[MWIFIEX_TM_ATTR_DATA]);\n\t\tmemcpy(hostcmd->cmd, nla_data(tb[MWIFIEX_TM_ATTR_DATA]),\n\t\t       hostcmd->len);\n\n\t\tif (mwifiex_send_cmd(priv, 0, 0, 0, hostcmd, true)) {\n\t\t\tdev_err(priv->adapter->dev, \"Failed to process hostcmd\\n\");\n\t\t\tkfree(hostcmd);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t \n\t\tskb = cfg80211_testmode_alloc_reply_skb(wiphy, hostcmd->len);\n\t\tif (!skb) {\n\t\t\tkfree(hostcmd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\terr = nla_put(skb, MWIFIEX_TM_ATTR_DATA,\n\t\t\t      hostcmd->len, hostcmd->cmd);\n\t\tif (err) {\n\t\t\tkfree(hostcmd);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\terr = cfg80211_testmode_reply(skb);\n\t\tkfree(hostcmd);\n\t\treturn err;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n#endif\n\nstatic int\nmwifiex_cfg80211_start_radar_detection(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       struct cfg80211_chan_def *chandef,\n\t\t\t\t       u32 cac_time_ms)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\tstruct mwifiex_radar_params radar_params;\n\n\tif (priv->adapter->scan_processing) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"radar detection: scan already in process...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!mwifiex_is_11h_active(priv)) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"Enable 11h extensions in FW\\n\");\n\t\tif (mwifiex_11h_activate(priv, true)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"Failed to activate 11h extensions!!\");\n\t\t\treturn -1;\n\t\t}\n\t\tpriv->state_11h.is_11h_active = true;\n\t}\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = cac_time_ms;\n\n\tmemcpy(&priv->dfs_chandef, chandef, sizeof(priv->dfs_chandef));\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, &radar_params, true))\n\t\treturn -1;\n\n\tqueue_delayed_work(priv->dfs_cac_workqueue, &priv->dfs_cac_work,\n\t\t\t   msecs_to_jiffies(cac_time_ms));\n\treturn 0;\n}\n\nstatic int\nmwifiex_cfg80211_change_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tconst u8 *mac,\n\t\t\t\tstruct station_parameters *params)\n{\n\tint ret;\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);\n\n\t \n\tif (!(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((priv->bss_type != MWIFIEX_BSS_TYPE_STA) || !priv->media_connected)\n\t\treturn -EOPNOTSUPP;\n\n\tpriv->sta_params = params;\n\n\tret = mwifiex_tdls_oper(priv, mac, MWIFIEX_TDLS_CONFIG_LINK);\n\tpriv->sta_params = NULL;\n\n\treturn ret;\n}\n\n \nstatic struct cfg80211_ops mwifiex_cfg80211_ops = {\n\t.add_virtual_intf = mwifiex_add_virtual_intf,\n\t.del_virtual_intf = mwifiex_del_virtual_intf,\n\t.change_virtual_intf = mwifiex_cfg80211_change_virtual_intf,\n\t.scan = mwifiex_cfg80211_scan,\n\t.connect = mwifiex_cfg80211_connect,\n\t.disconnect = mwifiex_cfg80211_disconnect,\n\t.get_station = mwifiex_cfg80211_get_station,\n\t.dump_station = mwifiex_cfg80211_dump_station,\n\t.dump_survey = mwifiex_cfg80211_dump_survey,\n\t.set_wiphy_params = mwifiex_cfg80211_set_wiphy_params,\n\t.join_ibss = mwifiex_cfg80211_join_ibss,\n\t.leave_ibss = mwifiex_cfg80211_leave_ibss,\n\t.add_key = mwifiex_cfg80211_add_key,\n\t.del_key = mwifiex_cfg80211_del_key,\n\t.set_default_mgmt_key = mwifiex_cfg80211_set_default_mgmt_key,\n\t.mgmt_tx = mwifiex_cfg80211_mgmt_tx,\n\t.update_mgmt_frame_registrations =\n\t\tmwifiex_cfg80211_update_mgmt_frame_registrations,\n\t.remain_on_channel = mwifiex_cfg80211_remain_on_channel,\n\t.cancel_remain_on_channel = mwifiex_cfg80211_cancel_remain_on_channel,\n\t.set_default_key = mwifiex_cfg80211_set_default_key,\n\t.set_power_mgmt = mwifiex_cfg80211_set_power_mgmt,\n\t.set_tx_power = mwifiex_cfg80211_set_tx_power,\n\t.get_tx_power = mwifiex_cfg80211_get_tx_power,\n\t.set_bitrate_mask = mwifiex_cfg80211_set_bitrate_mask,\n\t.start_ap = mwifiex_cfg80211_start_ap,\n\t.stop_ap = mwifiex_cfg80211_stop_ap,\n\t.change_beacon = mwifiex_cfg80211_change_beacon,\n\t.set_cqm_rssi_config = mwifiex_cfg80211_set_cqm_rssi_config,\n\t.set_antenna = mwifiex_cfg80211_set_antenna,\n\t.get_antenna = mwifiex_cfg80211_get_antenna,\n\t.del_station = mwifiex_cfg80211_del_station,\n\t.sched_scan_start = mwifiex_cfg80211_sched_scan_start,\n\t.sched_scan_stop = mwifiex_cfg80211_sched_scan_stop,\n#ifdef CONFIG_PM\n\t.suspend = mwifiex_cfg80211_suspend,\n\t.resume = mwifiex_cfg80211_resume,\n\t.set_wakeup = mwifiex_cfg80211_set_wakeup,\n\t.set_rekey_data = mwifiex_set_rekey_data,\n#endif\n\t.set_coalesce = mwifiex_cfg80211_set_coalesce,\n\t.tdls_mgmt = mwifiex_cfg80211_tdls_mgmt,\n\t.tdls_oper = mwifiex_cfg80211_tdls_oper,\n\t.tdls_channel_switch = mwifiex_cfg80211_tdls_chan_switch,\n\t.tdls_cancel_channel_switch = mwifiex_cfg80211_tdls_cancel_chan_switch,\n\t.add_station = mwifiex_cfg80211_add_station,\n\t.change_station = mwifiex_cfg80211_change_station,\n\tCFG80211_TESTMODE_CMD(mwifiex_tm_cmd)\n\t.get_channel = mwifiex_cfg80211_get_channel,\n\t.start_radar_detection = mwifiex_cfg80211_start_radar_detection,\n\t.channel_switch = mwifiex_cfg80211_channel_switch,\n};\n\n#ifdef CONFIG_PM\nstatic const struct wiphy_wowlan_support mwifiex_wowlan_support = {\n\t.flags = WIPHY_WOWLAN_MAGIC_PKT | WIPHY_WOWLAN_DISCONNECT |\n\t\tWIPHY_WOWLAN_NET_DETECT | WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |\n\t\tWIPHY_WOWLAN_GTK_REKEY_FAILURE,\n\t.n_patterns = MWIFIEX_MEF_MAX_FILTERS,\n\t.pattern_min_len = 1,\n\t.pattern_max_len = MWIFIEX_MAX_PATTERN_LEN,\n\t.max_pkt_offset = MWIFIEX_MAX_OFFSET_LEN,\n\t.max_nd_match_sets = MWIFIEX_MAX_ND_MATCH_SETS,\n};\n\nstatic const struct wiphy_wowlan_support mwifiex_wowlan_support_no_gtk = {\n\t.flags = WIPHY_WOWLAN_MAGIC_PKT | WIPHY_WOWLAN_DISCONNECT |\n\t\t WIPHY_WOWLAN_NET_DETECT,\n\t.n_patterns = MWIFIEX_MEF_MAX_FILTERS,\n\t.pattern_min_len = 1,\n\t.pattern_max_len = MWIFIEX_MAX_PATTERN_LEN,\n\t.max_pkt_offset = MWIFIEX_MAX_OFFSET_LEN,\n\t.max_nd_match_sets = MWIFIEX_MAX_ND_MATCH_SETS,\n};\n#endif\n\nstatic bool mwifiex_is_valid_alpha2(const char *alpha2)\n{\n\tif (!alpha2 || strlen(alpha2) != 2)\n\t\treturn false;\n\n\tif (isalpha(alpha2[0]) && isalpha(alpha2[1]))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct wiphy_coalesce_support mwifiex_coalesce_support = {\n\t.n_rules = MWIFIEX_COALESCE_MAX_RULES,\n\t.max_delay = MWIFIEX_MAX_COALESCING_DELAY,\n\t.n_patterns = MWIFIEX_COALESCE_MAX_FILTERS,\n\t.pattern_min_len = 1,\n\t.pattern_max_len = MWIFIEX_MAX_PATTERN_LEN,\n\t.max_pkt_offset = MWIFIEX_MAX_OFFSET_LEN,\n};\n\nint mwifiex_init_channel_scan_gap(struct mwifiex_adapter *adapter)\n{\n\tu32 n_channels_bg, n_channels_a = 0;\n\n\tn_channels_bg = mwifiex_band_2ghz.n_channels;\n\n\tif (adapter->config_bands & BAND_A)\n\t\tn_channels_a = mwifiex_band_5ghz.n_channels;\n\n\t \n\tadapter->num_in_chan_stats = 2 * (n_channels_bg + n_channels_a);\n\tadapter->chan_stats = vmalloc(array_size(sizeof(*adapter->chan_stats),\n\t\t\t\t\t\t adapter->num_in_chan_stats));\n\n\tif (!adapter->chan_stats)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \n\nint mwifiex_register_cfg80211(struct mwifiex_adapter *adapter)\n{\n\tint ret;\n\tvoid *wdev_priv;\n\tstruct wiphy *wiphy;\n\tstruct mwifiex_private *priv = adapter->priv[MWIFIEX_BSS_TYPE_STA];\n\tu8 *country_code;\n\tu32 thr, retry;\n\n\t \n\twiphy = wiphy_new(&mwifiex_cfg80211_ops,\n\t\t\t  sizeof(struct mwifiex_adapter *));\n\tif (!wiphy) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: creating new wiphy\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\twiphy->max_scan_ssids = MWIFIEX_MAX_SSID_LIST_LENGTH;\n\twiphy->max_scan_ie_len = MWIFIEX_MAX_VSIE_LEN;\n\twiphy->mgmt_stypes = mwifiex_mgmt_stypes;\n\twiphy->max_remain_on_channel_duration = 5000;\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t\t BIT(NL80211_IFTYPE_AP);\n\n\tif (ISSUPP_ADHOC_ENABLED(adapter->fw_cap_info))\n\t\twiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);\n\n\twiphy->bands[NL80211_BAND_2GHZ] = &mwifiex_band_2ghz;\n\tif (adapter->config_bands & BAND_A)\n\t\twiphy->bands[NL80211_BAND_5GHZ] = &mwifiex_band_5ghz;\n\telse\n\t\twiphy->bands[NL80211_BAND_5GHZ] = NULL;\n\n\tif (adapter->drcs_enabled && ISSUPP_DRCS_ENABLED(adapter->fw_cap_info))\n\t\twiphy->iface_combinations = &mwifiex_iface_comb_ap_sta_drcs;\n\telse if (adapter->is_hw_11ac_capable)\n\t\twiphy->iface_combinations = &mwifiex_iface_comb_ap_sta_vht;\n\telse\n\t\twiphy->iface_combinations = &mwifiex_iface_comb_ap_sta;\n\twiphy->n_iface_combinations = 1;\n\n\tif (adapter->max_sta_conn > adapter->max_p2p_conn)\n\t\twiphy->max_ap_assoc_sta = adapter->max_sta_conn;\n\telse\n\t\twiphy->max_ap_assoc_sta = adapter->max_p2p_conn;\n\n\t \n\twiphy->cipher_suites = mwifiex_cipher_suites;\n\twiphy->n_cipher_suites = ARRAY_SIZE(mwifiex_cipher_suites);\n\n\tif (adapter->regd) {\n\t\twiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |\n\t\t\t\t\t   REGULATORY_DISABLE_BEACON_HINTS |\n\t\t\t\t\t   REGULATORY_COUNTRY_IE_IGNORE;\n\t\twiphy_apply_custom_regulatory(wiphy, adapter->regd);\n\t}\n\n\tether_addr_copy(wiphy->perm_addr, adapter->perm_addr);\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\twiphy->flags |= WIPHY_FLAG_HAVE_AP_SME |\n\t\t\tWIPHY_FLAG_AP_PROBE_RESP_OFFLOAD |\n\t\t\tWIPHY_FLAG_AP_UAPSD |\n\t\t\tWIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |\n\t\t\tWIPHY_FLAG_HAS_CHANNEL_SWITCH |\n\t\t\tWIPHY_FLAG_NETNS_OK |\n\t\t\tWIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\tif (ISSUPP_TDLS_ENABLED(adapter->fw_cap_info))\n\t\twiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS |\n\t\t\t\tWIPHY_FLAG_TDLS_EXTERNAL_SETUP;\n\n#ifdef CONFIG_PM\n\tif (ISSUPP_FIRMWARE_SUPPLICANT(priv->adapter->fw_cap_info))\n\t\twiphy->wowlan = &mwifiex_wowlan_support;\n\telse\n\t\twiphy->wowlan = &mwifiex_wowlan_support_no_gtk;\n#endif\n\n\twiphy->coalesce = &mwifiex_coalesce_support;\n\n\twiphy->probe_resp_offload = NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS |\n\t\t\t\t    NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 |\n\t\t\t\t    NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P;\n\n\twiphy->max_sched_scan_reqs = 1;\n\twiphy->max_sched_scan_ssids = MWIFIEX_MAX_SSID_LIST_LENGTH;\n\twiphy->max_sched_scan_ie_len = MWIFIEX_MAX_VSIE_LEN;\n\twiphy->max_match_sets = MWIFIEX_MAX_SSID_LIST_LENGTH;\n\n\twiphy->available_antennas_tx = BIT(adapter->number_of_antenna) - 1;\n\twiphy->available_antennas_rx = BIT(adapter->number_of_antenna) - 1;\n\n\twiphy->features |= NL80211_FEATURE_INACTIVITY_TIMER |\n\t\t\t   NL80211_FEATURE_LOW_PRIORITY_SCAN |\n\t\t\t   NL80211_FEATURE_NEED_OBSS_SCAN;\n\n\tif (ISSUPP_ADHOC_ENABLED(adapter->fw_cap_info))\n\t\twiphy->features |= NL80211_FEATURE_HT_IBSS;\n\n\tif (ISSUPP_RANDOM_MAC(adapter->fw_cap_info))\n\t\twiphy->features |= NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR |\n\t\t\t\t   NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR |\n\t\t\t\t   NL80211_FEATURE_ND_RANDOM_MAC_ADDR;\n\n\tif (ISSUPP_TDLS_ENABLED(adapter->fw_cap_info))\n\t\twiphy->features |= NL80211_FEATURE_TDLS_CHANNEL_SWITCH;\n\n\tif (adapter->fw_api_ver == MWIFIEX_FW_V15)\n\t\twiphy->features |= NL80211_FEATURE_SK_TX_STATUS;\n\n\t \n\twiphy->bss_priv_size = sizeof(struct mwifiex_bss_priv);\n\n\twiphy->reg_notifier = mwifiex_reg_notifier;\n\n\t \n\twdev_priv = wiphy_priv(wiphy);\n\t*(unsigned long *)wdev_priv = (unsigned long)adapter;\n\n\tset_wiphy_dev(wiphy, priv->adapter->dev);\n\n\tret = wiphy_register(wiphy);\n\tif (ret < 0) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: wiphy_register failed: %d\\n\", __func__, ret);\n\t\twiphy_free(wiphy);\n\t\treturn ret;\n\t}\n\n\tif (!adapter->regd) {\n\t\tif (reg_alpha2 && mwifiex_is_valid_alpha2(reg_alpha2)) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"driver hint alpha2: %2.2s\\n\", reg_alpha2);\n\t\t\tregulatory_hint(wiphy, reg_alpha2);\n\t\t} else {\n\t\t\tif (adapter->region_code == 0x00) {\n\t\t\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t\t\t    \"Ignore world regulatory domain\\n\");\n\t\t\t} else {\n\t\t\t\twiphy->regulatory_flags |=\n\t\t\t\t\tREGULATORY_DISABLE_BEACON_HINTS |\n\t\t\t\t\tREGULATORY_COUNTRY_IE_IGNORE;\n\t\t\t\tcountry_code =\n\t\t\t\t\tmwifiex_11d_code_2_region(\n\t\t\t\t\t\tadapter->region_code);\n\t\t\t\tif (country_code &&\n\t\t\t\t    regulatory_hint(wiphy, country_code))\n\t\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t\t    \"regulatory_hint() failed\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tmwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t HostCmd_ACT_GEN_GET, FRAG_THRESH_I, &thr, true);\n\twiphy->frag_threshold = thr;\n\tmwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t HostCmd_ACT_GEN_GET, RTS_THRESH_I, &thr, true);\n\twiphy->rts_threshold = thr;\n\tmwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t HostCmd_ACT_GEN_GET, SHORT_RETRY_LIM_I, &retry, true);\n\twiphy->retry_short = (u8) retry;\n\tmwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t HostCmd_ACT_GEN_GET, LONG_RETRY_LIM_I, &retry, true);\n\twiphy->retry_long = (u8) retry;\n\n\tadapter->wiphy = wiphy;\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}