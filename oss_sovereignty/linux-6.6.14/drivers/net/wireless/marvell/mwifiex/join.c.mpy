{
  "module_name": "join.c",
  "hash_id": "3eb3065c963941e0523ca46aa70ad6fe11167694b46842d9d40f37c2d893c7f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/join.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"11ac.h\"\n\n#define CAPINFO_MASK    (~(BIT(15) | BIT(14) | BIT(12) | BIT(11) | BIT(9)))\n\n \nstatic int\nmwifiex_cmd_append_generic_ie(struct mwifiex_private *priv, u8 **buffer)\n{\n\tint ret_len = 0;\n\tstruct mwifiex_ie_types_header ie_header;\n\n\t \n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\n\t \n\tif (priv->gen_ie_buf_len) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: %s: append generic ie len %d to %p\\n\",\n\t\t\t    __func__, priv->gen_ie_buf_len, *buffer);\n\n\t\t \n\t\tie_header.type = cpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\tie_header.len = cpu_to_le16(priv->gen_ie_buf_len);\n\t\tmemcpy(*buffer, &ie_header, sizeof(ie_header));\n\n\t\t \n\t\t*buffer += sizeof(ie_header);\n\t\tret_len += sizeof(ie_header);\n\n\t\t \n\t\tmemcpy(*buffer, priv->gen_ie_buf, priv->gen_ie_buf_len);\n\n\t\t \n\t\t*buffer += priv->gen_ie_buf_len;\n\t\tret_len += priv->gen_ie_buf_len;\n\n\t\t \n\t\tpriv->gen_ie_buf_len = 0;\n\t}\n\n\t \n\treturn ret_len;\n}\n\n \nstatic int\nmwifiex_cmd_append_tsf_tlv(struct mwifiex_private *priv, u8 **buffer,\n\t\t\t   struct mwifiex_bssdescriptor *bss_desc)\n{\n\tstruct mwifiex_ie_types_tsf_timestamp tsf_tlv;\n\t__le64 tsf_val;\n\n\t \n\tif (buffer == NULL)\n\t\treturn 0;\n\tif (*buffer == NULL)\n\t\treturn 0;\n\n\tmemset(&tsf_tlv, 0x00, sizeof(struct mwifiex_ie_types_tsf_timestamp));\n\n\ttsf_tlv.header.type = cpu_to_le16(TLV_TYPE_TSFTIMESTAMP);\n\ttsf_tlv.header.len = cpu_to_le16(2 * sizeof(tsf_val));\n\n\tmemcpy(*buffer, &tsf_tlv, sizeof(tsf_tlv.header));\n\t*buffer += sizeof(tsf_tlv.header);\n\n\t \n\ttsf_val = cpu_to_le64(bss_desc->fw_tsf);\n\tmemcpy(*buffer, &tsf_val, sizeof(tsf_val));\n\t*buffer += sizeof(tsf_val);\n\n\ttsf_val = cpu_to_le64(bss_desc->timestamp);\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: %s: TSF offset calc: %016llx - %016llx\\n\",\n\t\t    __func__, bss_desc->timestamp, bss_desc->fw_tsf);\n\n\tmemcpy(*buffer, &tsf_val, sizeof(tsf_val));\n\t*buffer += sizeof(tsf_val);\n\n\treturn sizeof(tsf_tlv.header) + (2 * sizeof(tsf_val));\n}\n\n \nstatic int mwifiex_get_common_rates(struct mwifiex_private *priv, u8 *rate1,\n\t\t\t\t    u32 rate1_size, u8 *rate2, u32 rate2_size)\n{\n\tint ret;\n\tu8 *ptr = rate1, *tmp;\n\tu32 i, j;\n\n\ttmp = kmemdup(rate1, rate1_size, GFP_KERNEL);\n\tif (!tmp) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"failed to alloc tmp buf\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(rate1, 0, rate1_size);\n\n\tfor (i = 0; i < rate2_size && rate2[i]; i++) {\n\t\tfor (j = 0; j < rate1_size && tmp[j]; j++) {\n\t\t\t \n\t\t\tif ((rate2[i] & 0x7F) == (tmp[j] & 0x7F)) {\n\t\t\t\t*rate1++ = tmp[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: Tx data rate set to %#x\\n\",\n\t\t    priv->data_rate);\n\n\tif (!priv->is_data_rate_auto) {\n\t\twhile (*ptr) {\n\t\t\tif ((*ptr & 0x7f) == priv->data_rate) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"previously set fixed data rate %#x\\t\"\n\t\t\t    \"is not compatible with the network\\n\",\n\t\t\t    priv->data_rate);\n\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\tret = 0;\ndone:\n\tkfree(tmp);\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_setup_rates_from_bssdesc(struct mwifiex_private *priv,\n\t\t\t\t struct mwifiex_bssdescriptor *bss_desc,\n\t\t\t\t u8 *out_rates, u32 *out_rates_size)\n{\n\tu8 card_rates[MWIFIEX_SUPPORTED_RATES];\n\tu32 card_rates_size;\n\n\t \n\tmemcpy(out_rates, bss_desc->supported_rates, MWIFIEX_SUPPORTED_RATES);\n\t \n\tcard_rates_size = mwifiex_get_active_data_rates(priv, card_rates);\n\t \n\tif (mwifiex_get_common_rates(priv, out_rates, MWIFIEX_SUPPORTED_RATES,\n\t\t\t\t     card_rates, card_rates_size)) {\n\t\t*out_rates_size = 0;\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"%s: cannot get common rates\\n\",\n\t\t\t    __func__);\n\t\treturn -1;\n\t}\n\n\t*out_rates_size =\n\t\tmin_t(size_t, strlen(out_rates), MWIFIEX_SUPPORTED_RATES);\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cmd_append_wps_ie(struct mwifiex_private *priv, u8 **buffer)\n{\n\tint retLen = 0;\n\tstruct mwifiex_ie_types_header ie_header;\n\n\tif (!buffer || !*buffer)\n\t\treturn 0;\n\n\t \n\tif (priv->wps_ie_len) {\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: append wps ie %d to %p\\n\",\n\t\t\t    priv->wps_ie_len, *buffer);\n\n\t\t \n\t\tie_header.type = cpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\tie_header.len = cpu_to_le16(priv->wps_ie_len);\n\t\tmemcpy(*buffer, &ie_header, sizeof(ie_header));\n\t\t*buffer += sizeof(ie_header);\n\t\tretLen += sizeof(ie_header);\n\n\t\tmemcpy(*buffer, priv->wps_ie, priv->wps_ie_len);\n\t\t*buffer += priv->wps_ie_len;\n\t\tretLen += priv->wps_ie_len;\n\n\t}\n\n\tkfree(priv->wps_ie);\n\tpriv->wps_ie_len = 0;\n\treturn retLen;\n}\n\n \nstatic int\nmwifiex_cmd_append_wapi_ie(struct mwifiex_private *priv, u8 **buffer)\n{\n\tint retLen = 0;\n\tstruct mwifiex_ie_types_header ie_header;\n\n\t \n\tif (buffer == NULL)\n\t\treturn 0;\n\tif (*buffer == NULL)\n\t\treturn 0;\n\n\t \n\tif (priv->wapi_ie_len) {\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: append wapi ie %d to %p\\n\",\n\t\t\t    priv->wapi_ie_len, *buffer);\n\n\t\t \n\t\tie_header.type = cpu_to_le16(TLV_TYPE_WAPI_IE);\n\t\tie_header.len = cpu_to_le16(priv->wapi_ie_len);\n\t\tmemcpy(*buffer, &ie_header, sizeof(ie_header));\n\n\t\t \n\t\t*buffer += sizeof(ie_header);\n\t\tretLen += sizeof(ie_header);\n\n\t\t \n\t\tmemcpy(*buffer, priv->wapi_ie, priv->wapi_ie_len);\n\n\t\t \n\t\t*buffer += priv->wapi_ie_len;\n\t\tretLen += priv->wapi_ie_len;\n\n\t}\n\t \n\treturn retLen;\n}\n\n \nstatic int mwifiex_append_rsn_ie_wpa_wpa2(struct mwifiex_private *priv,\n\t\t\t\t\t  u8 **buffer)\n{\n\tstruct mwifiex_ie_types_rsn_param_set *rsn_ie_tlv;\n\tint rsn_ie_len;\n\n\tif (!buffer || !(*buffer))\n\t\treturn 0;\n\n\trsn_ie_tlv = (struct mwifiex_ie_types_rsn_param_set *) (*buffer);\n\trsn_ie_tlv->header.type = cpu_to_le16((u16) priv->wpa_ie[0]);\n\trsn_ie_tlv->header.type = cpu_to_le16(\n\t\t\t\t le16_to_cpu(rsn_ie_tlv->header.type) & 0x00FF);\n\trsn_ie_tlv->header.len = cpu_to_le16((u16) priv->wpa_ie[1]);\n\trsn_ie_tlv->header.len = cpu_to_le16(le16_to_cpu(rsn_ie_tlv->header.len)\n\t\t\t\t\t\t\t & 0x00FF);\n\tif (le16_to_cpu(rsn_ie_tlv->header.len) <= (sizeof(priv->wpa_ie) - 2))\n\t\tmemcpy(rsn_ie_tlv->rsn_ie, &priv->wpa_ie[2],\n\t\t       le16_to_cpu(rsn_ie_tlv->header.len));\n\telse\n\t\treturn -1;\n\n\trsn_ie_len = sizeof(rsn_ie_tlv->header) +\n\t\t\t\t\tle16_to_cpu(rsn_ie_tlv->header.len);\n\t*buffer += rsn_ie_len;\n\n\treturn rsn_ie_len;\n}\n\n \nint mwifiex_cmd_802_11_associate(struct mwifiex_private *priv,\n\t\t\t\t struct host_cmd_ds_command *cmd,\n\t\t\t\t struct mwifiex_bssdescriptor *bss_desc)\n{\n\tstruct host_cmd_ds_802_11_associate *assoc = &cmd->params.associate;\n\tstruct mwifiex_ie_types_ssid_param_set *ssid_tlv;\n\tstruct mwifiex_ie_types_phy_param_set *phy_tlv;\n\tstruct mwifiex_ie_types_ss_param_set *ss_tlv;\n\tstruct mwifiex_ie_types_rates_param_set *rates_tlv;\n\tstruct mwifiex_ie_types_auth_type *auth_tlv;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu8 rates[MWIFIEX_SUPPORTED_RATES];\n\tu32 rates_size;\n\tu16 tmp_cap;\n\tu8 *pos;\n\tint rsn_ie_len = 0;\n\n\tpos = (u8 *) assoc;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_ASSOCIATE);\n\n\t \n\tpriv->attempted_bss_desc = bss_desc;\n\n\tmemcpy(assoc->peer_sta_addr,\n\t       bss_desc->mac_address, sizeof(assoc->peer_sta_addr));\n\tpos += sizeof(assoc->peer_sta_addr);\n\n\t \n\tassoc->listen_interval = cpu_to_le16(priv->listen_interval);\n\t \n\tassoc->beacon_period = cpu_to_le16(bss_desc->beacon_period);\n\n\tpos += sizeof(assoc->cap_info_bitmap);\n\tpos += sizeof(assoc->listen_interval);\n\tpos += sizeof(assoc->beacon_period);\n\tpos += sizeof(assoc->dtim_period);\n\n\tssid_tlv = (struct mwifiex_ie_types_ssid_param_set *) pos;\n\tssid_tlv->header.type = cpu_to_le16(WLAN_EID_SSID);\n\tssid_tlv->header.len = cpu_to_le16((u16) bss_desc->ssid.ssid_len);\n\tmemcpy(ssid_tlv->ssid, bss_desc->ssid.ssid,\n\t       le16_to_cpu(ssid_tlv->header.len));\n\tpos += sizeof(ssid_tlv->header) + le16_to_cpu(ssid_tlv->header.len);\n\n\tphy_tlv = (struct mwifiex_ie_types_phy_param_set *) pos;\n\tphy_tlv->header.type = cpu_to_le16(WLAN_EID_DS_PARAMS);\n\tphy_tlv->header.len = cpu_to_le16(sizeof(phy_tlv->fh_ds.ds_param_set));\n\tmemcpy(&phy_tlv->fh_ds.ds_param_set,\n\t       &bss_desc->phy_param_set.ds_param_set.current_chan,\n\t       sizeof(phy_tlv->fh_ds.ds_param_set));\n\tpos += sizeof(phy_tlv->header) + le16_to_cpu(phy_tlv->header.len);\n\n\tss_tlv = (struct mwifiex_ie_types_ss_param_set *) pos;\n\tss_tlv->header.type = cpu_to_le16(WLAN_EID_CF_PARAMS);\n\tss_tlv->header.len = cpu_to_le16(sizeof(ss_tlv->cf_ibss.cf_param_set));\n\tpos += sizeof(ss_tlv->header) + le16_to_cpu(ss_tlv->header.len);\n\n\t \n\tif (mwifiex_setup_rates_from_bssdesc\n\t    (priv, bss_desc, rates, &rates_size))\n\t\treturn -1;\n\n\t \n\tpriv->curr_bss_params.num_of_rates = rates_size;\n\tmemcpy(&priv->curr_bss_params.data_rates, rates, rates_size);\n\n\t \n\trates_tlv = (struct mwifiex_ie_types_rates_param_set *) pos;\n\trates_tlv->header.type = cpu_to_le16(WLAN_EID_SUPP_RATES);\n\trates_tlv->header.len = cpu_to_le16((u16) rates_size);\n\tmemcpy(rates_tlv->rates, rates, rates_size);\n\tpos += sizeof(rates_tlv->header) + rates_size;\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ASSOC_CMD: rates size = %d\\n\",\n\t\t    rates_size);\n\n\t \n\tauth_tlv = (struct mwifiex_ie_types_auth_type *) pos;\n\tauth_tlv->header.type = cpu_to_le16(TLV_TYPE_AUTH_TYPE);\n\tauth_tlv->header.len = cpu_to_le16(sizeof(auth_tlv->auth_type));\n\tif (priv->sec_info.wep_enabled)\n\t\tauth_tlv->auth_type = cpu_to_le16(\n\t\t\t\t(u16) priv->sec_info.authentication_mode);\n\telse\n\t\tauth_tlv->auth_type = cpu_to_le16(NL80211_AUTHTYPE_OPEN_SYSTEM);\n\n\tpos += sizeof(auth_tlv->header) + le16_to_cpu(auth_tlv->header.len);\n\n\tif (IS_SUPPORT_MULTI_BANDS(priv->adapter) &&\n\t    !(ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\n\t    (!bss_desc->disable_11n) &&\n\t    (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN) &&\n\t    (bss_desc->bcn_ht_cap)\n\t    )\n\t\t) {\n\t\t \n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(bss_desc->phy_param_set.ds_param_set.current_chan);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: Assoc: TLV Chan = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\n\t\tchan_tlv->chan_scan_param[0].radio_type =\n\t\t\tmwifiex_band_to_radio_type((u8) bss_desc->bss_band);\n\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: Assoc: TLV Band = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\n\tif (!priv->wps.session_enable) {\n\t\tif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\n\t\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\n\t\tif (rsn_ie_len == -1)\n\t\t\treturn -1;\n\t}\n\n\tif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\n\t    (!bss_desc->disable_11n) &&\n\t    (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN))\n\t\tmwifiex_cmd_append_11n_tlv(priv, bss_desc, &pos);\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    !bss_desc->disable_11n && !bss_desc->disable_11ac &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_cmd_append_11ac_tlv(priv, bss_desc, &pos);\n\n\t \n\tmwifiex_cmd_append_vsie_tlv(priv, MWIFIEX_VSIE_MASK_ASSOC, &pos);\n\n\tmwifiex_wmm_process_association_req(priv, &pos, &bss_desc->wmm_ie,\n\t\t\t\t\t    bss_desc->bcn_ht_cap);\n\tif (priv->sec_info.wapi_enabled && priv->wapi_ie_len)\n\t\tmwifiex_cmd_append_wapi_ie(priv, &pos);\n\n\tif (priv->wps.session_enable && priv->wps_ie_len)\n\t\tmwifiex_cmd_append_wps_ie(priv, &pos);\n\n\tmwifiex_cmd_append_generic_ie(priv, &pos);\n\n\tmwifiex_cmd_append_tsf_tlv(priv, &pos, bss_desc);\n\n\tmwifiex_11h_process_join(priv, &pos, bss_desc);\n\n\tcmd->size = cpu_to_le16((u16) (pos - (u8 *) assoc) + S_DS_GEN);\n\n\t \n\ttmp_cap = bss_desc->cap_info_bitmap;\n\n\tif (priv->adapter->config_bands == BAND_B)\n\t\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\n\ttmp_cap &= CAPINFO_MASK;\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ASSOC_CMD: tmp_cap=%4X CAPINFO_MASK=%4lX\\n\",\n\t\t    tmp_cap, CAPINFO_MASK);\n\tassoc->cap_info_bitmap = cpu_to_le16(tmp_cap);\n\n\treturn 0;\n}\n\nstatic const char *assoc_failure_reason_to_str(u16 cap_info)\n{\n\tswitch (cap_info) {\n\tcase CONNECT_ERR_AUTH_ERR_STA_FAILURE:\n\t\treturn \"CONNECT_ERR_AUTH_ERR_STA_FAILURE\";\n\tcase CONNECT_ERR_AUTH_MSG_UNHANDLED:\n\t\treturn \"CONNECT_ERR_AUTH_MSG_UNHANDLED\";\n\tcase CONNECT_ERR_ASSOC_ERR_TIMEOUT:\n\t\treturn \"CONNECT_ERR_ASSOC_ERR_TIMEOUT\";\n\tcase CONNECT_ERR_ASSOC_ERR_AUTH_REFUSED:\n\t\treturn \"CONNECT_ERR_ASSOC_ERR_AUTH_REFUSED\";\n\tcase CONNECT_ERR_STA_FAILURE:\n\t\treturn \"CONNECT_ERR_STA_FAILURE\";\n\t}\n\n\treturn \"Unknown connect failure\";\n}\n \nint mwifiex_ret_802_11_associate(struct mwifiex_private *priv,\n\t\t\t     struct host_cmd_ds_command *resp)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret = 0;\n\tstruct ieee_types_assoc_rsp *assoc_rsp;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tbool enable_data = true;\n\tu16 cap_info, status_code, aid;\n\tconst u8 *ie_ptr;\n\tstruct ieee80211_ht_operation *assoc_resp_ht_oper;\n\n\tif (!priv->attempted_bss_desc) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"ASSOC_RESP: failed, association terminated by host\\n\");\n\t\tgoto done;\n\t}\n\n\tassoc_rsp = (struct ieee_types_assoc_rsp *) &resp->params;\n\n\tcap_info = le16_to_cpu(assoc_rsp->cap_info_bitmap);\n\tstatus_code = le16_to_cpu(assoc_rsp->status_code);\n\taid = le16_to_cpu(assoc_rsp->a_id);\n\n\tif ((aid & (BIT(15) | BIT(14))) != (BIT(15) | BIT(14)))\n\t\tdev_err(priv->adapter->dev,\n\t\t\t\"invalid AID value 0x%x; bits 15:14 not set\\n\",\n\t\t\taid);\n\n\taid &= ~(BIT(15) | BIT(14));\n\n\tpriv->assoc_rsp_size = min(le16_to_cpu(resp->size) - S_DS_GEN,\n\t\t\t\t   sizeof(priv->assoc_rsp_buf));\n\n\tassoc_rsp->a_id = cpu_to_le16(aid);\n\tmemcpy(priv->assoc_rsp_buf, &resp->params, priv->assoc_rsp_size);\n\n\tif (status_code) {\n\t\tpriv->adapter->dbg.num_cmd_assoc_failure++;\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"ASSOC_RESP: failed,\\t\"\n\t\t\t    \"status code=%d err=%#x a_id=%#x\\n\",\n\t\t\t    status_code, cap_info,\n\t\t\t    le16_to_cpu(assoc_rsp->a_id));\n\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"assoc failure: reason %s\\n\",\n\t\t\t    assoc_failure_reason_to_str(cap_info));\n\t\tif (cap_info == CONNECT_ERR_ASSOC_ERR_TIMEOUT) {\n\t\t\tif (status_code == MWIFIEX_ASSOC_CMD_FAILURE_AUTH) {\n\t\t\t\tret = WLAN_STATUS_AUTH_TIMEOUT;\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"ASSOC_RESP: AUTH timeout\\n\");\n\t\t\t} else {\n\t\t\t\tret = WLAN_STATUS_UNSPECIFIED_FAILURE;\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"ASSOC_RESP: UNSPECIFIED failure\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tret = status_code;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\t \n\tpriv->media_connected = true;\n\n\tpriv->adapter->ps_state = PS_STATE_AWAKE;\n\tpriv->adapter->pps_uapsd_mode = false;\n\tpriv->adapter->tx_lock_flag = false;\n\n\t \n\tbss_desc = priv->attempted_bss_desc;\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ASSOC_RESP: %s\\n\",\n\t\t    bss_desc->ssid.ssid);\n\n\t \n\tmemcpy(&priv->curr_bss_params.bss_descriptor,\n\t       bss_desc, sizeof(struct mwifiex_bssdescriptor));\n\n\t \n\tpriv->curr_bss_params.bss_descriptor.channel\n\t\t= bss_desc->phy_param_set.ds_param_set.current_chan;\n\n\tpriv->curr_bss_params.band = (u8) bss_desc->bss_band;\n\n\tif (bss_desc->wmm_ie.vend_hdr.element_id == WLAN_EID_VENDOR_SPECIFIC)\n\t\tpriv->curr_bss_params.wmm_enabled = true;\n\telse\n\t\tpriv->curr_bss_params.wmm_enabled = false;\n\n\tif ((priv->wmm_required || bss_desc->bcn_ht_cap) &&\n\t    priv->curr_bss_params.wmm_enabled)\n\t\tpriv->wmm_enabled = true;\n\telse\n\t\tpriv->wmm_enabled = false;\n\n\tpriv->curr_bss_params.wmm_uapsd_enabled = false;\n\n\tif (priv->wmm_enabled)\n\t\tpriv->curr_bss_params.wmm_uapsd_enabled\n\t\t\t= ((bss_desc->wmm_ie.qos_info_bitmap &\n\t\t\t\tIEEE80211_WMM_IE_AP_QOSINFO_UAPSD) ? 1 : 0);\n\n\t \n\tie_ptr = cfg80211_find_ie(WLAN_EID_HT_OPERATION, assoc_rsp->ie_buffer,\n\t\t\t\t  priv->assoc_rsp_size\n\t\t\t\t  - sizeof(struct ieee_types_assoc_rsp));\n\tif (ie_ptr) {\n\t\tassoc_resp_ht_oper = (struct ieee80211_ht_operation *)(ie_ptr\n\t\t\t\t\t+ sizeof(struct ieee_types_header));\n\t\tpriv->assoc_resp_ht_param = assoc_resp_ht_oper->ht_param;\n\t\tpriv->ht_param_present = true;\n\t} else {\n\t\tpriv->ht_param_present = false;\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ASSOC_RESP: curr_pkt_filter is %#x\\n\",\n\t\t    priv->curr_pkt_filter);\n\tif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\n\t\tpriv->wpa_is_gtk_set = false;\n\n\tif (priv->wmm_enabled) {\n\t\t \n\t\tenable_data = false;\n\t} else {\n\t\t \n\t\tmwifiex_wmm_setup_queue_priorities(priv, NULL);\n\t\tmwifiex_wmm_setup_ac_downgrade(priv);\n\t}\n\n\tif (enable_data)\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: post association, re-enabling data flow\\n\");\n\n\t \n\tpriv->data_rssi_last = 0;\n\tpriv->data_nf_last = 0;\n\tpriv->data_rssi_avg = 0;\n\tpriv->data_nf_avg = 0;\n\tpriv->bcn_rssi_last = 0;\n\tpriv->bcn_nf_last = 0;\n\tpriv->bcn_rssi_avg = 0;\n\tpriv->bcn_nf_avg = 0;\n\tpriv->rxpd_rate = 0;\n\tpriv->rxpd_htinfo = 0;\n\n\tmwifiex_save_curr_bcn(priv);\n\n\tpriv->adapter->dbg.num_cmd_assoc_success++;\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ASSOC_RESP: associated\\n\");\n\n\t \n\tmwifiex_ralist_add(priv,\n\t\t\t   priv->curr_bss_params.bss_descriptor.mac_address);\n\n\tif (!netif_carrier_ok(priv->netdev))\n\t\tnetif_carrier_on(priv->netdev);\n\tmwifiex_wake_up_net_dev_queue(priv->netdev, adapter);\n\n\tif (priv->sec_info.wpa_enabled || priv->sec_info.wpa2_enabled)\n\t\tpriv->scan_block = true;\n\telse\n\t\tpriv->port_open = true;\n\ndone:\n\t \n\tif (adapter->curr_cmd->wait_q_enabled) {\n\t\tif (ret)\n\t\t\tadapter->cmd_wait_q.status = -1;\n\t\telse\n\t\t\tadapter->cmd_wait_q.status = 0;\n\t}\n\n\treturn ret;\n}\n\n \nint\nmwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *cmd,\n\t\t\t\tstruct cfg80211_ssid *req_ssid)\n{\n\tint rsn_ie_len = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\n\t\t&cmd->params.adhoc_start;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tu32 cmd_append_size = 0;\n\tu32 i;\n\tu16 tmp_cap;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu8 radio_type;\n\n\tstruct mwifiex_ie_types_htcap *ht_cap;\n\tstruct mwifiex_ie_types_htinfo *ht_info;\n\tu8 *pos = (u8 *) adhoc_start +\n\t\t\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\n\n\tif (!adapter)\n\t\treturn -1;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\n\n\tbss_desc = &priv->curr_bss_params.bss_descriptor;\n\tpriv->attempted_bss_desc = bss_desc;\n\n\t \n\n\tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\n\n\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\n\t\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\n\tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\n\",\n\t\t    adhoc_start->ssid);\n\n\tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\n\tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\n\n\tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\n\n\t \n\tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\n\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\n\tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\n\tbss_desc->beacon_period = priv->beacon_period;\n\n\t \n \n#define DS_PARA_IE_ID   3\n \n#define DS_PARA_IE_LEN  1\n\n\tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\n\tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\n\n\tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t     (u16) priv->adhoc_channel, 0)) {\n\t\tstruct mwifiex_chan_freq_power *cfp;\n\t\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n\t\t\t\t      FIRST_VALID_CHANNEL, 0);\n\t\tif (cfp)\n\t\t\tpriv->adhoc_channel = (u8) cfp->channel;\n\t}\n\n\tif (!priv->adhoc_channel) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"ADHOC_S_CMD: adhoc_channel cannot be 0\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: ADHOC_S_CMD: creating ADHOC on channel %d\\n\",\n\t\t    priv->adhoc_channel);\n\n\tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\n\tpriv->curr_bss_params.band = adapter->adhoc_start_band;\n\n\tbss_desc->channel = priv->adhoc_channel;\n\tadhoc_start->phy_param_set.ds_param_set.current_chan =\n\t\tpriv->adhoc_channel;\n\n\tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\n\t       sizeof(union ieee_types_phy_param_set));\n\n\t \n \n#define IBSS_PARA_IE_ID   6\n \n#define IBSS_PARA_IE_LEN  2\n\n\tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\n\tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\n\tadhoc_start->ss_param_set.ibss_param_set.atim_window\n\t\t\t\t\t= cpu_to_le16(priv->atim_window);\n\tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\n\t       sizeof(union ieee_types_ss_param_set));\n\n\t \n\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\n\ttmp_cap = WLAN_CAPABILITY_IBSS;\n\n\t \n\tif (priv->sec_info.encryption_mode) {\n\t\t \n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status set privacy to WEP\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\n\t\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ADHOC_S_CMD: wep_status NOT set,\\t\"\n\t\t\t    \"setting privacy to ACCEPT ALL\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\n\t}\n\n\tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\n\tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\n\tif ((adapter->adhoc_start_band & BAND_G) &&\n\t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t     &priv->curr_pkt_filter, false)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"ADHOC_S_CMD: G Protection config failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\n\t\tif (!adhoc_start->data_rate[i])\n\t\t\tbreak;\n\n\tpriv->curr_bss_params.num_of_rates = i;\n\n\t \n\tmemcpy(&priv->curr_bss_params.data_rates,\n\t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: rates=%4ph\\n\",\n\t\t    adhoc_start->data_rate);\n\n\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: AD-HOC Start command is ready\\n\");\n\n\tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\n\t\t \n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Chan = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\n\t\tchan_tlv->chan_scan_param[0].radio_type\n\t\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n\t\tif (adapter->adhoc_start_band & BAND_GN ||\n\t\t    adapter->adhoc_start_band & BAND_AN) {\n\t\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\n\t\t\telse if (adapter->sec_chan_offset ==\n\t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\n\t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n\t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\n\t\t}\n\t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Band = %d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t\tcmd_append_size +=\n\t\t\tsizeof(chan_tlv->header) +\n\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\n\t \n\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\n\t\t\t\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\n\n\tif (priv->sec_info.wpa_enabled) {\n\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\t\tif (rsn_ie_len == -1)\n\t\t\treturn -1;\n\t\tcmd_append_size += rsn_ie_len;\n\t}\n\n\tif (adapter->adhoc_11n_enabled) {\n\t\t \n\t\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\n\t\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\n\t\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\tht_cap->header.len =\n\t\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\tradio_type = mwifiex_band_to_radio_type(\n\t\t\t\t\tpriv->adapter->config_bands);\n\t\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\n\n\t\tif (adapter->sec_chan_offset ==\n\t\t\t\t\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\n\t\t\tu16 tmp_ht_cap;\n\n\t\t\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\n\t\t\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\n\t\t}\n\n\t\tpos += sizeof(struct mwifiex_ie_types_htcap);\n\t\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\n\n\t\t \n\t\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\n\t\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\n\t\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\n\t\tht_info->header.len =\n\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\n\n\t\tht_info->ht_oper.primary_chan =\n\t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n\t\tif (adapter->sec_chan_offset) {\n\t\t\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\n\t\t\tht_info->ht_oper.ht_param |=\n\t\t\t\t\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\n\t\t}\n\t\tht_info->ht_oper.operation_mode =\n\t\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\t\tht_info->ht_oper.basic_set[0] = 0xff;\n\t\tpos += sizeof(struct mwifiex_ie_types_htinfo);\n\t\tcmd_append_size +=\n\t\t\t\tsizeof(struct mwifiex_ie_types_htinfo);\n\t}\n\n\tcmd->size =\n\t\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\n\t\t\t\t  + S_DS_GEN + cmd_append_size));\n\n\tif (adapter->adhoc_start_band == BAND_B)\n\t\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\telse\n\t\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\n\tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\n\n\treturn 0;\n}\n\n \nint\nmwifiex_cmd_802_11_ad_hoc_join(struct mwifiex_private *priv,\n\t\t\t       struct host_cmd_ds_command *cmd,\n\t\t\t       struct mwifiex_bssdescriptor *bss_desc)\n{\n\tint rsn_ie_len = 0;\n\tstruct host_cmd_ds_802_11_ad_hoc_join *adhoc_join =\n\t\t&cmd->params.adhoc_join;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n\tu32 cmd_append_size = 0;\n\tu16 tmp_cap;\n\tu32 i, rates_size = 0;\n\tu16 curr_pkt_filter;\n\tu8 *pos =\n\t\t(u8 *) adhoc_join +\n\t\tsizeof(struct host_cmd_ds_802_11_ad_hoc_join);\n\n \n#define USE_G_PROTECTION        0x02\n\tif (bss_desc->erp_flags & USE_G_PROTECTION) {\n\t\tcurr_pkt_filter =\n\t\t\tpriv->\n\t\t\tcurr_pkt_filter | HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON;\n\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t     &curr_pkt_filter, false)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"ADHOC_J_CMD: G Protection config failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpriv->attempted_bss_desc = bss_desc;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_JOIN);\n\n\tadhoc_join->bss_descriptor.bss_mode = HostCmd_BSS_MODE_IBSS;\n\n\tadhoc_join->bss_descriptor.beacon_period\n\t\t= cpu_to_le16(bss_desc->beacon_period);\n\n\tmemcpy(&adhoc_join->bss_descriptor.bssid,\n\t       &bss_desc->mac_address, ETH_ALEN);\n\n\tmemcpy(&adhoc_join->bss_descriptor.ssid,\n\t       &bss_desc->ssid.ssid, bss_desc->ssid.ssid_len);\n\n\tmemcpy(&adhoc_join->bss_descriptor.phy_param_set,\n\t       &bss_desc->phy_param_set,\n\t       sizeof(union ieee_types_phy_param_set));\n\n\tmemcpy(&adhoc_join->bss_descriptor.ss_param_set,\n\t       &bss_desc->ss_param_set, sizeof(union ieee_types_ss_param_set));\n\n\ttmp_cap = bss_desc->cap_info_bitmap;\n\n\ttmp_cap &= CAPINFO_MASK;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ADHOC_J_CMD: tmp_cap=%4X CAPINFO_MASK=%4lX\\n\",\n\t\t    tmp_cap, CAPINFO_MASK);\n\n\t \n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: ADHOC_J_CMD: BSSID=%pM, SSID='%s'\\n\",\n\t\t    adhoc_join->bss_descriptor.bssid,\n\t\t    adhoc_join->bss_descriptor.ssid);\n\n\tfor (i = 0; i < MWIFIEX_SUPPORTED_RATES &&\n\t\t    bss_desc->supported_rates[i]; i++)\n\t\t;\n\trates_size = i;\n\n\t \n\tmemset(adhoc_join->bss_descriptor.data_rates, 0,\n\t       sizeof(adhoc_join->bss_descriptor.data_rates));\n\tmemcpy(adhoc_join->bss_descriptor.data_rates,\n\t       bss_desc->supported_rates, rates_size);\n\n\t \n\tpriv->curr_bss_params.num_of_rates = rates_size;\n\tmemcpy(&priv->curr_bss_params.data_rates, bss_desc->supported_rates,\n\t       rates_size);\n\n\t \n\tpriv->curr_bss_params.bss_descriptor.channel = bss_desc->channel;\n\tpriv->curr_bss_params.band = (u8) bss_desc->bss_band;\n\n\tif (priv->sec_info.wep_enabled || priv->sec_info.wpa_enabled)\n\t\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\n\n\tif (IS_SUPPORT_MULTI_BANDS(priv->adapter)) {\n\t\t \n\t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n\t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n\n\t\tmemset(chan_tlv->chan_scan_param, 0x00,\n\t\t       sizeof(struct mwifiex_chan_scan_param_set));\n\t\tchan_tlv->chan_scan_param[0].chan_number =\n\t\t\t(bss_desc->phy_param_set.ds_param_set.current_chan);\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_J_CMD: TLV Chan=%d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n\n\t\tchan_tlv->chan_scan_param[0].radio_type =\n\t\t\tmwifiex_band_to_radio_type((u8) bss_desc->bss_band);\n\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_J_CMD: TLV Band=%d\\n\",\n\t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n\t\tpos += sizeof(chan_tlv->header) +\n\t\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t\tcmd_append_size += sizeof(chan_tlv->header) +\n\t\t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n\t}\n\n\tif (priv->sec_info.wpa_enabled)\n\t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n\tif (rsn_ie_len == -1)\n\t\treturn -1;\n\tcmd_append_size += rsn_ie_len;\n\n\tif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info))\n\t\tcmd_append_size += mwifiex_cmd_append_11n_tlv(priv,\n\t\t\tbss_desc, &pos);\n\n\t \n\tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\n\t\t\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\n\n\tcmd->size = cpu_to_le16\n\t\t((u16) (sizeof(struct host_cmd_ds_802_11_ad_hoc_join)\n\t\t\t+ S_DS_GEN + cmd_append_size));\n\n\tadhoc_join->bss_descriptor.cap_info_bitmap = cpu_to_le16(tmp_cap);\n\n\treturn 0;\n}\n\n \nint mwifiex_ret_802_11_ad_hoc(struct mwifiex_private *priv,\n\t\t\t      struct host_cmd_ds_command *resp)\n{\n\tint ret = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_ad_hoc_start_result *start_result =\n\t\t\t\t&resp->params.start_result;\n\tstruct host_cmd_ds_802_11_ad_hoc_join_result *join_result =\n\t\t\t\t&resp->params.join_result;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tu16 cmd = le16_to_cpu(resp->command);\n\tu8 result;\n\n\tif (!priv->attempted_bss_desc) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"ADHOC_RESP: failed, association terminated by host\\n\");\n\t\tgoto done;\n\t}\n\n\tif (cmd == HostCmd_CMD_802_11_AD_HOC_START)\n\t\tresult = start_result->result;\n\telse\n\t\tresult = join_result->result;\n\n\tbss_desc = priv->attempted_bss_desc;\n\n\t \n\tif (result) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"ADHOC_RESP: failed\\n\");\n\t\tif (priv->media_connected)\n\t\t\tmwifiex_reset_connect_state(priv, result, true);\n\n\t\tmemset(&priv->curr_bss_params.bss_descriptor,\n\t\t       0x00, sizeof(struct mwifiex_bssdescriptor));\n\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t \n\tpriv->media_connected = true;\n\n\tif (le16_to_cpu(resp->command) == HostCmd_CMD_802_11_AD_HOC_START) {\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_S_RESP %s\\n\",\n\t\t\t    bss_desc->ssid.ssid);\n\n\t\t \n\t\tmemcpy(bss_desc->mac_address,\n\t\t       start_result->bssid, ETH_ALEN);\n\n\t\tpriv->adhoc_state = ADHOC_STARTED;\n\t} else {\n\t\t \n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ADHOC_J_RESP %s\\n\",\n\t\t\t    bss_desc->ssid.ssid);\n\n\t\t \n\t\tmemcpy(&priv->curr_bss_params.bss_descriptor,\n\t\t       bss_desc, sizeof(struct mwifiex_bssdescriptor));\n\n\t\tpriv->adhoc_state = ADHOC_JOINED;\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_RESP: channel = %d\\n\",\n\t\t    priv->adhoc_channel);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: ADHOC_RESP: BSSID = %pM\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.mac_address);\n\n\tif (!netif_carrier_ok(priv->netdev))\n\t\tnetif_carrier_on(priv->netdev);\n\tmwifiex_wake_up_net_dev_queue(priv->netdev, adapter);\n\n\tmwifiex_save_curr_bcn(priv);\n\ndone:\n\t \n\tif (adapter->curr_cmd->wait_q_enabled) {\n\t\tif (ret)\n\t\t\tadapter->cmd_wait_q.status = -1;\n\t\telse\n\t\t\tadapter->cmd_wait_q.status = 0;\n\n\t}\n\n\treturn ret;\n}\n\n \nint mwifiex_associate(struct mwifiex_private *priv,\n\t\t      struct mwifiex_bssdescriptor *bss_desc)\n{\n\t \n\tif ((GET_BSS_ROLE(priv) != MWIFIEX_BSS_ROLE_STA) ||\n\t    (bss_desc->bss_mode != NL80211_IFTYPE_STATION))\n\t\treturn -1;\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    !bss_desc->disable_11n && !bss_desc->disable_11ac &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_set_11ac_ba_params(priv);\n\telse\n\t\tmwifiex_set_ba_params(priv);\n\n\t \n\tpriv->assoc_rsp_size = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_ASSOCIATE,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, bss_desc, true);\n}\n\n \nint\nmwifiex_adhoc_start(struct mwifiex_private *priv,\n\t\t    struct cfg80211_ssid *adhoc_ssid)\n{\n\tmwifiex_dbg(priv->adapter, INFO, \"info: Adhoc Channel = %d\\n\",\n\t\t    priv->adhoc_channel);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: curr_bss_params.channel = %d\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.channel);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: curr_bss_params.band = %d\\n\",\n\t\t    priv->curr_bss_params.band);\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_set_11ac_ba_params(priv);\n\telse\n\t\tmwifiex_set_ba_params(priv);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_START,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, adhoc_ssid, true);\n}\n\n \nint mwifiex_adhoc_join(struct mwifiex_private *priv,\n\t\t       struct mwifiex_bssdescriptor *bss_desc)\n{\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: adhoc join: curr_bss ssid =%s\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.ssid.ssid);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: adhoc join: curr_bss ssid_len =%u\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.ssid.ssid_len);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: adhoc join: ssid =%s\\n\",\n\t\t    bss_desc->ssid.ssid);\n\tmwifiex_dbg(priv->adapter, INFO, \"info: adhoc join: ssid_len =%u\\n\",\n\t\t    bss_desc->ssid.ssid_len);\n\n\t \n\tif (priv->curr_bss_params.bss_descriptor.ssid.ssid_len &&\n\t    !mwifiex_ssid_cmp(&bss_desc->ssid,\n\t\t\t      &priv->curr_bss_params.bss_descriptor.ssid) &&\n\t    (priv->curr_bss_params.bss_descriptor.bss_mode ==\n\t\t\t\t\t\t\tNL80211_IFTYPE_ADHOC)) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ADHOC_J_CMD: new ad-hoc SSID\\t\"\n\t\t\t    \"is the same as current; not attempting to re-join\\n\");\n\t\treturn -1;\n\t}\n\n\tif (ISSUPP_11ACENABLED(priv->adapter->fw_cap_info) &&\n\t    !bss_desc->disable_11n && !bss_desc->disable_11ac &&\n\t    priv->adapter->config_bands & BAND_AAC)\n\t\tmwifiex_set_11ac_ba_params(priv);\n\telse\n\t\tmwifiex_set_ba_params(priv);\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: curr_bss_params.channel = %d\\n\",\n\t\t    priv->curr_bss_params.bss_descriptor.channel);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: curr_bss_params.band = %c\\n\",\n\t\t    priv->curr_bss_params.band);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_JOIN,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, bss_desc, true);\n}\n\n \nstatic int mwifiex_deauthenticate_infra(struct mwifiex_private *priv, u8 *mac)\n{\n\tu8 mac_address[ETH_ALEN];\n\tint ret;\n\n\tif (!mac || is_zero_ether_addr(mac))\n\t\tmemcpy(mac_address,\n\t\t       priv->curr_bss_params.bss_descriptor.mac_address,\n\t\t       ETH_ALEN);\n\telse\n\t\tmemcpy(mac_address, mac, ETH_ALEN);\n\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_DEAUTHENTICATE,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, mac_address, true);\n\n\treturn ret;\n}\n\n \nint mwifiex_deauthenticate(struct mwifiex_private *priv, u8 *mac)\n{\n\tint ret = 0;\n\n\tif (!priv->media_connected)\n\t\treturn 0;\n\n\tswitch (priv->bss_mode) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tret = mwifiex_deauthenticate_infra(priv, mac);\n\t\tif (ret)\n\t\t\tcfg80211_disconnected(priv->netdev, 0, NULL, 0,\n\t\t\t\t\t      true, GFP_KERNEL);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_AD_HOC_STOP,\n\t\t\t\t\tHostCmd_ACT_GEN_SET, 0, NULL, true);\n\tcase NL80211_IFTYPE_AP:\n\t\treturn mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_STOP,\n\t\t\t\t\tHostCmd_ACT_GEN_SET, 0, NULL, true);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nvoid mwifiex_deauthenticate_all(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tif (priv)\n\t\t\tmwifiex_deauthenticate(priv, NULL);\n\t}\n}\nEXPORT_SYMBOL_GPL(mwifiex_deauthenticate_all);\n\n \nu8\nmwifiex_band_to_radio_type(u8 band)\n{\n\tswitch (band) {\n\tcase BAND_A:\n\tcase BAND_AN:\n\tcase BAND_A | BAND_AN:\n\tcase BAND_A | BAND_AN | BAND_AAC:\n\t\treturn HostCmd_SCAN_RADIO_TYPE_A;\n\tcase BAND_B:\n\tcase BAND_G:\n\tcase BAND_B | BAND_G:\n\tdefault:\n\t\treturn HostCmd_SCAN_RADIO_TYPE_BG;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}