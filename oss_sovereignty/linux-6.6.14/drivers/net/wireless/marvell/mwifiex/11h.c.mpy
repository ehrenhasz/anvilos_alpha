{
  "module_name": "11h.c",
  "hash_id": "5a7e9405f4e5047209c275bfab3a87c37cdfb3805f7bea2ba5bb64a7de600eb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/11h.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"fw.h\"\n\n\nvoid mwifiex_init_11h_params(struct mwifiex_private *priv)\n{\n\tpriv->state_11h.is_11h_enabled = true;\n\tpriv->state_11h.is_11h_active = false;\n}\n\ninline int mwifiex_is_11h_active(struct mwifiex_private *priv)\n{\n\treturn priv->state_11h.is_11h_active;\n}\n \nstatic void\nmwifiex_11h_process_infra_join(struct mwifiex_private *priv, u8 **buffer,\n\t\t\t       struct mwifiex_bssdescriptor *bss_desc)\n{\n\tstruct mwifiex_ie_types_header *ie_header;\n\tstruct mwifiex_ie_types_pwr_capability *cap;\n\tstruct mwifiex_ie_types_local_pwr_constraint *constraint;\n\tstruct ieee80211_supported_band *sband;\n\tu8 radio_type;\n\tint i;\n\n\tif (!buffer || !(*buffer))\n\t\treturn;\n\n\tradio_type = mwifiex_band_to_radio_type((u8) bss_desc->bss_band);\n\tsband = priv->wdev.wiphy->bands[radio_type];\n\n\tcap = (struct mwifiex_ie_types_pwr_capability *)*buffer;\n\tcap->header.type = cpu_to_le16(WLAN_EID_PWR_CAPABILITY);\n\tcap->header.len = cpu_to_le16(2);\n\tcap->min_pwr = 0;\n\tcap->max_pwr = 0;\n\t*buffer += sizeof(*cap);\n\n\tconstraint = (struct mwifiex_ie_types_local_pwr_constraint *)*buffer;\n\tconstraint->header.type = cpu_to_le16(WLAN_EID_PWR_CONSTRAINT);\n\tconstraint->header.len = cpu_to_le16(2);\n\tconstraint->chan = bss_desc->channel;\n\tconstraint->constraint = bss_desc->local_constraint;\n\t*buffer += sizeof(*constraint);\n\n\tie_header = (struct mwifiex_ie_types_header *)*buffer;\n\tie_header->type = cpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\tie_header->len  = cpu_to_le16(2 * sband->n_channels + 2);\n\t*buffer += sizeof(*ie_header);\n\t*(*buffer)++ = WLAN_EID_SUPPORTED_CHANNELS;\n\t*(*buffer)++ = 2 * sband->n_channels;\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t*(*buffer)++ = ieee80211_frequency_to_channel(\n\t\t\t\t\tsband->channels[i].center_freq);\n\t\t*(*buffer)++ = 1;  \n\t}\n}\n\n \nint mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\n{\n\tu32 enable = flag;\n\n\t \n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\n\t\tenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\tHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\n}\n\n \nvoid mwifiex_11h_process_join(struct mwifiex_private *priv, u8 **buffer,\n\t\t\t      struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (bss_desc->sensed_11h) {\n\t\t \n\t\tmwifiex_11h_activate(priv, true);\n\t\tpriv->state_11h.is_11h_active = true;\n\t\tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_SPECTRUM_MGMT;\n\t\tmwifiex_11h_process_infra_join(priv, buffer, bss_desc);\n\t} else {\n\t\t \n\t\tmwifiex_11h_activate(priv, false);\n\t\tpriv->state_11h.is_11h_active = false;\n\t\tbss_desc->cap_info_bitmap &= ~WLAN_CAPABILITY_SPECTRUM_MGMT;\n\t}\n}\n\n \nvoid mwifiex_dfs_cac_work_queue(struct work_struct *work)\n{\n\tstruct cfg80211_chan_def chandef;\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct mwifiex_private *priv =\n\t\t\tcontainer_of(delayed_work, struct mwifiex_private,\n\t\t\t\t     dfs_cac_work);\n\n\tchandef = priv->dfs_chandef;\n\tif (priv->wdev.cac_started) {\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"CAC timer finished; No radar detected\\n\");\n\t\tcfg80211_cac_event(priv->netdev, &chandef,\n\t\t\t\t   NL80211_RADAR_CAC_FINISHED,\n\t\t\t\t   GFP_KERNEL);\n\t}\n}\n\n \nint mwifiex_cmd_issue_chan_report_request(struct mwifiex_private *priv,\n\t\t\t\t\t  struct host_cmd_ds_command *cmd,\n\t\t\t\t\t  void *data_buf)\n{\n\tstruct host_cmd_ds_chan_rpt_req *cr_req = &cmd->params.chan_rpt_req;\n\tstruct mwifiex_radar_params *radar_params = (void *)data_buf;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_CHAN_REPORT_REQUEST);\n\tcmd->size = cpu_to_le16(S_DS_GEN);\n\tle16_unaligned_add_cpu(&cmd->size,\n\t\t\t       sizeof(struct host_cmd_ds_chan_rpt_req));\n\n\tcr_req->chan_desc.start_freq = cpu_to_le16(MWIFIEX_A_BAND_START_FREQ);\n\tcr_req->chan_desc.chan_num = radar_params->chandef->chan->hw_value;\n\tcr_req->chan_desc.chan_width = radar_params->chandef->width;\n\tcr_req->msec_dwell_time = cpu_to_le32(radar_params->cac_time_ms);\n\n\tif (radar_params->cac_time_ms)\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"11h: issuing DFS Radar check for channel=%d\\n\",\n\t\t\t    radar_params->chandef->chan->hw_value);\n\telse\n\t\tmwifiex_dbg(priv->adapter, MSG, \"cancelling CAC\\n\");\n\n\treturn 0;\n}\n\nint mwifiex_stop_radar_detection(struct mwifiex_private *priv,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct mwifiex_radar_params radar_params;\n\n\tmemset(&radar_params, 0, sizeof(struct mwifiex_radar_params));\n\tradar_params.chandef = chandef;\n\tradar_params.cac_time_ms = 0;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &radar_params, true);\n}\n\n \nvoid mwifiex_abort_cac(struct mwifiex_private *priv)\n{\n\tif (priv->wdev.cac_started) {\n\t\tif (mwifiex_stop_radar_detection(priv, &priv->dfs_chandef))\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"failed to stop CAC in FW\\n\");\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"Aborting delayed work for CAC.\\n\");\n\t\tcancel_delayed_work_sync(&priv->dfs_cac_work);\n\t\tcfg80211_cac_event(priv->netdev, &priv->dfs_chandef,\n\t\t\t\t   NL80211_RADAR_CAC_ABORTED, GFP_KERNEL);\n\t}\n}\n\n \nint mwifiex_11h_handle_chanrpt_ready(struct mwifiex_private *priv,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct host_cmd_ds_chan_rpt_event *rpt_event;\n\tstruct mwifiex_ie_types_chan_rpt_data *rpt;\n\tu16 event_len, tlv_len;\n\n\trpt_event = (void *)(skb->data + sizeof(u32));\n\tevent_len = skb->len - (sizeof(struct host_cmd_ds_chan_rpt_event)+\n\t\t\t\tsizeof(u32));\n\n\tif (le32_to_cpu(rpt_event->result) != HostCmd_RESULT_OK) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Error in channel report event\\n\");\n\t\treturn -1;\n\t}\n\n\twhile (event_len >= sizeof(struct mwifiex_ie_types_header)) {\n\t\trpt = (void *)&rpt_event->tlvbuf;\n\t\ttlv_len = le16_to_cpu(rpt->header.len);\n\n\t\tswitch (le16_to_cpu(rpt->header.type)) {\n\t\tcase TLV_TYPE_CHANRPT_11H_BASIC:\n\t\t\tif (rpt->map.radar) {\n\t\t\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t\t\t    \"RADAR Detected on channel %d!\\n\",\n\t\t\t\t\t    priv->dfs_chandef.chan->hw_value);\n\t\t\t\tcancel_delayed_work_sync(&priv->dfs_cac_work);\n\t\t\t\tcfg80211_cac_event(priv->netdev,\n\t\t\t\t\t\t   &priv->dfs_chandef,\n\t\t\t\t\t\t   NL80211_RADAR_DETECTED,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tevent_len -= (tlv_len + sizeof(rpt->header));\n\t}\n\n\treturn 0;\n}\n\n \nint mwifiex_11h_handle_radar_detected(struct mwifiex_private *priv,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct mwifiex_radar_det_event *rdr_event;\n\n\trdr_event = (void *)(skb->data + sizeof(u32));\n\n\tmwifiex_dbg(priv->adapter, MSG,\n\t\t    \"radar detected; indicating kernel\\n\");\n\tif (mwifiex_stop_radar_detection(priv, &priv->dfs_chandef))\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to stop CAC in FW\\n\");\n\tcfg80211_radar_event(priv->adapter->wiphy, &priv->dfs_chandef,\n\t\t\t     GFP_KERNEL);\n\tmwifiex_dbg(priv->adapter, MSG, \"regdomain: %d\\n\",\n\t\t    rdr_event->reg_domain);\n\tmwifiex_dbg(priv->adapter, MSG, \"radar detection type: %d\\n\",\n\t\t    rdr_event->det_type);\n\n\treturn 0;\n}\n\n \nvoid mwifiex_dfs_chan_sw_work_queue(struct work_struct *work)\n{\n\tstruct mwifiex_uap_bss_param *bss_cfg;\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct mwifiex_private *priv =\n\t\t\tcontainer_of(delayed_work, struct mwifiex_private,\n\t\t\t\t     dfs_chan_sw_work);\n\n\tbss_cfg = &priv->bss_cfg;\n\tif (!bss_cfg->beacon_period) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"channel switch: AP already stopped\\n\");\n\t\treturn;\n\t}\n\n\tmwifiex_uap_set_channel(priv, bss_cfg, priv->dfs_chandef);\n\n\tif (mwifiex_config_start_uap(priv, bss_cfg)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to start AP after channel switch\\n\");\n\t\treturn;\n\t}\n\n\tmwifiex_dbg(priv->adapter, MSG,\n\t\t    \"indicating channel switch completion to kernel\\n\");\n\tmutex_lock(&priv->wdev.mtx);\n\tcfg80211_ch_switch_notify(priv->netdev, &priv->dfs_chandef, 0, 0);\n\tmutex_unlock(&priv->wdev.mtx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}