{
  "module_name": "sta_tx.c",
  "hash_id": "96a1859cd178d4f629b44d1b0f2c0b8748cd648239e703ca9a9944a9a192860b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/sta_tx.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n\n \nvoid mwifiex_process_sta_txpd(struct mwifiex_private *priv,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct txpd *local_tx_pd;\n\tstruct mwifiex_txinfo *tx_info = MWIFIEX_SKB_TXCB(skb);\n\tunsigned int pad;\n\tu16 pkt_type, pkt_offset;\n\tint hroom = adapter->intf_hdr_len;\n\n\tpkt_type = mwifiex_is_skb_mgmt_frame(skb) ? PKT_TYPE_MGMT : 0;\n\n\tpad = ((uintptr_t)skb->data - (sizeof(*local_tx_pd) + hroom)) &\n\t       (MWIFIEX_DMA_ALIGN_SZ - 1);\n\tskb_push(skb, sizeof(*local_tx_pd) + pad);\n\n\tlocal_tx_pd = (struct txpd *) skb->data;\n\tmemset(local_tx_pd, 0, sizeof(struct txpd));\n\tlocal_tx_pd->bss_num = priv->bss_num;\n\tlocal_tx_pd->bss_type = priv->bss_type;\n\tlocal_tx_pd->tx_pkt_length = cpu_to_le16((u16)(skb->len -\n\t\t\t\t\t\t       (sizeof(struct txpd) +\n\t\t\t\t\t\t\tpad)));\n\n\tlocal_tx_pd->priority = (u8) skb->priority;\n\tlocal_tx_pd->pkt_delay_2ms =\n\t\t\t\tmwifiex_wmm_compute_drv_pkt_delay(priv, skb);\n\n\tif (tx_info->flags & MWIFIEX_BUF_FLAG_EAPOL_TX_STATUS ||\n\t    tx_info->flags & MWIFIEX_BUF_FLAG_ACTION_TX_STATUS) {\n\t\tlocal_tx_pd->tx_token_id = tx_info->ack_frame_id;\n\t\tlocal_tx_pd->flags |= MWIFIEX_TXPD_FLAGS_REQ_TX_STATUS;\n\t}\n\n\tif (local_tx_pd->priority <\n\t    ARRAY_SIZE(priv->wmm.user_pri_pkt_tx_ctrl))\n\t\t \n\t\tlocal_tx_pd->tx_control =\n\t\t\tcpu_to_le32(priv->wmm.user_pri_pkt_tx_ctrl[local_tx_pd->\n\t\t\t\t\t\t\t\t   priority]);\n\n\tif (adapter->pps_uapsd_mode) {\n\t\tif (mwifiex_check_last_packet_indication(priv)) {\n\t\t\tadapter->tx_lock_flag = true;\n\t\t\tlocal_tx_pd->flags =\n\t\t\t\tMWIFIEX_TxPD_POWER_MGMT_LAST_PACKET;\n\t\t}\n\t}\n\n\tif (tx_info->flags & MWIFIEX_BUF_FLAG_TDLS_PKT)\n\t\tlocal_tx_pd->flags |= MWIFIEX_TXPD_FLAGS_TDLS_PACKET;\n\n\t \n\tpkt_offset = sizeof(struct txpd) + pad;\n\tif (pkt_type == PKT_TYPE_MGMT) {\n\t\t \n\t\tlocal_tx_pd->tx_pkt_type = cpu_to_le16(pkt_type);\n\t\tpkt_offset += MWIFIEX_MGMT_FRAME_HEADER_SIZE;\n\t}\n\n\tlocal_tx_pd->tx_pkt_offset = cpu_to_le16(pkt_offset);\n\n\t \n\tskb_push(skb, hroom);\n\n\tif (!local_tx_pd->tx_control)\n\t\t \n\t\tlocal_tx_pd->tx_control = cpu_to_le32(priv->pkt_tx_ctrl);\n}\n\n \nint mwifiex_send_null_packet(struct mwifiex_private *priv, u8 flags)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct txpd *local_tx_pd;\n\tstruct mwifiex_tx_param tx_param;\n \n#define NULL_PACKET_HDR 64\n\tu32 data_len = NULL_PACKET_HDR;\n\tstruct sk_buff *skb;\n\tint ret;\n\tstruct mwifiex_txinfo *tx_info = NULL;\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags))\n\t\treturn -1;\n\n\tif (!priv->media_connected)\n\t\treturn -1;\n\n\tif (adapter->data_sent)\n\t\treturn -1;\n\n\tif (adapter->if_ops.is_port_ready &&\n\t    !adapter->if_ops.is_port_ready(priv))\n\t\treturn -1;\n\n\tskb = dev_alloc_skb(data_len);\n\tif (!skb)\n\t\treturn -1;\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tmemset(tx_info, 0, sizeof(*tx_info));\n\ttx_info->bss_num = priv->bss_num;\n\ttx_info->bss_type = priv->bss_type;\n\ttx_info->pkt_len = data_len -\n\t\t\t(sizeof(struct txpd) + adapter->intf_hdr_len);\n\tskb_reserve(skb, sizeof(struct txpd) + adapter->intf_hdr_len);\n\tskb_push(skb, sizeof(struct txpd));\n\n\tlocal_tx_pd = (struct txpd *) skb->data;\n\tlocal_tx_pd->tx_control = cpu_to_le32(priv->pkt_tx_ctrl);\n\tlocal_tx_pd->flags = flags;\n\tlocal_tx_pd->priority = WMM_HIGHEST_PRIORITY;\n\tlocal_tx_pd->tx_pkt_offset = cpu_to_le16(sizeof(struct txpd));\n\tlocal_tx_pd->bss_num = priv->bss_num;\n\tlocal_tx_pd->bss_type = priv->bss_type;\n\n\tskb_push(skb, adapter->intf_hdr_len);\n\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\tret = adapter->if_ops.host_to_card(adapter, priv->usb_port,\n\t\t\t\t\t\t   skb, NULL);\n\t} else {\n\t\ttx_param.next_pkt_len = 0;\n\t\tret = adapter->if_ops.host_to_card(adapter, MWIFIEX_TYPE_DATA,\n\t\t\t\t\t\t   skb, &tx_param);\n\t}\n\tswitch (ret) {\n\tcase -EBUSY:\n\t\tdev_kfree_skb_any(skb);\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: host_to_card failed: ret=%d\\n\",\n\t\t\t    __func__, ret);\n\t\tadapter->dbg.num_tx_host_to_card_failure++;\n\t\tbreak;\n\tcase -1:\n\t\tdev_kfree_skb_any(skb);\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: host_to_card failed: ret=%d\\n\",\n\t\t\t    __func__, ret);\n\t\tadapter->dbg.num_tx_host_to_card_failure++;\n\t\tbreak;\n\tcase 0:\n\t\tdev_kfree_skb_any(skb);\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"data: %s: host_to_card succeeded\\n\",\n\t\t\t    __func__);\n\t\tadapter->tx_lock_flag = true;\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tadapter->tx_lock_flag = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nu8\nmwifiex_check_last_packet_indication(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu8 ret = false;\n\n\tif (!adapter->sleep_period.period)\n\t\treturn ret;\n\tif (mwifiex_wmm_lists_empty(adapter))\n\t\t\tret = true;\n\n\tif (ret && !adapter->cmd_sent && !adapter->curr_cmd &&\n\t    !is_command_pending(adapter)) {\n\t\tadapter->delay_null_pkt = false;\n\t\tret = true;\n\t} else {\n\t\tret = false;\n\t\tadapter->delay_null_pkt = true;\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}