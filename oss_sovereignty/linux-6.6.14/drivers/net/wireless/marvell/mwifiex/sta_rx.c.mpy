{
  "module_name": "sta_rx.c",
  "hash_id": "168235f16e9211c6360b1827c2d01d6661fb563f3767dc55817cabcf2212a53c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/sta_rx.c",
  "human_readable_source": "\n \n\n#include <uapi/linux/ipv6.h>\n#include <net/ndisc.h>\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"11n_aggr.h\"\n#include \"11n_rxreorder.h\"\n\n \nstatic bool\nmwifiex_discard_gratuitous_arp(struct mwifiex_private *priv,\n\t\t\t       struct sk_buff *skb)\n{\n\tconst struct mwifiex_arp_eth_header *arp;\n\tstruct ethhdr *eth;\n\tstruct ipv6hdr *ipv6;\n\tstruct icmp6hdr *icmpv6;\n\n\teth = (struct ethhdr *)skb->data;\n\tswitch (ntohs(eth->h_proto)) {\n\tcase ETH_P_ARP:\n\t\tarp = (void *)(skb->data + sizeof(struct ethhdr));\n\t\tif (arp->hdr.ar_op == htons(ARPOP_REPLY) ||\n\t\t    arp->hdr.ar_op == htons(ARPOP_REQUEST)) {\n\t\t\tif (!memcmp(arp->ar_sip, arp->ar_tip, 4))\n\t\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase ETH_P_IPV6:\n\t\tipv6 = (void *)(skb->data + sizeof(struct ethhdr));\n\t\ticmpv6 = (void *)(skb->data + sizeof(struct ethhdr) +\n\t\t\t\t  sizeof(struct ipv6hdr));\n\t\tif (NDISC_NEIGHBOUR_ADVERTISEMENT == icmpv6->icmp6_type) {\n\t\t\tif (!memcmp(&ipv6->saddr, &ipv6->daddr,\n\t\t\t\t    sizeof(struct in6_addr)))\n\t\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n \nint mwifiex_process_rx_packet(struct mwifiex_private *priv,\n\t\t\t      struct sk_buff *skb)\n{\n\tint ret;\n\tstruct rx_packet_hdr *rx_pkt_hdr;\n\tstruct rxpd *local_rx_pd;\n\tint hdr_chop;\n\tstruct ethhdr *eth;\n\tu16 rx_pkt_off, rx_pkt_len;\n\tu8 *offset;\n\tu8 adj_rx_rate = 0;\n\n\tlocal_rx_pd = (struct rxpd *) (skb->data);\n\n\trx_pkt_off = le16_to_cpu(local_rx_pd->rx_pkt_offset);\n\trx_pkt_len = le16_to_cpu(local_rx_pd->rx_pkt_length);\n\trx_pkt_hdr = (void *)local_rx_pd + rx_pkt_off;\n\n\tif (sizeof(rx_pkt_hdr->eth803_hdr) + sizeof(rfc1042_header) +\n\t    rx_pkt_off > skb->len) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"wrong rx packet offset: len=%d, rx_pkt_off=%d\\n\",\n\t\t\t    skb->len, rx_pkt_off);\n\t\tpriv->stats.rx_dropped++;\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -1;\n\t}\n\n\tif (sizeof(*rx_pkt_hdr) + rx_pkt_off <= skb->len &&\n\t    ((!memcmp(&rx_pkt_hdr->rfc1042_hdr, bridge_tunnel_header,\n\t\t      sizeof(bridge_tunnel_header))) ||\n\t     (!memcmp(&rx_pkt_hdr->rfc1042_hdr, rfc1042_header,\n\t\t      sizeof(rfc1042_header)) &&\n\t      ntohs(rx_pkt_hdr->rfc1042_hdr.snap_type) != ETH_P_AARP &&\n\t      ntohs(rx_pkt_hdr->rfc1042_hdr.snap_type) != ETH_P_IPX))) {\n\t\t \n\t\teth = (struct ethhdr *)\n\t\t\t((u8 *) &rx_pkt_hdr->eth803_hdr\n\t\t\t + sizeof(rx_pkt_hdr->eth803_hdr) +\n\t\t\t sizeof(rx_pkt_hdr->rfc1042_hdr)\n\t\t\t - sizeof(rx_pkt_hdr->eth803_hdr.h_dest)\n\t\t\t - sizeof(rx_pkt_hdr->eth803_hdr.h_source)\n\t\t\t - sizeof(rx_pkt_hdr->rfc1042_hdr.snap_type));\n\n\t\tmemcpy(eth->h_source, rx_pkt_hdr->eth803_hdr.h_source,\n\t\t       sizeof(eth->h_source));\n\t\tmemcpy(eth->h_dest, rx_pkt_hdr->eth803_hdr.h_dest,\n\t\t       sizeof(eth->h_dest));\n\n\t\t \n\t\thdr_chop = (u8 *) eth - (u8 *) local_rx_pd;\n\t} else {\n\t\t \n\t\thdr_chop = (u8 *) &rx_pkt_hdr->eth803_hdr -\n\t\t\t(u8 *) local_rx_pd;\n\t}\n\n\t \n\tskb_pull(skb, hdr_chop);\n\n\tif (priv->hs2_enabled &&\n\t    mwifiex_discard_gratuitous_arp(priv, skb)) {\n\t\tmwifiex_dbg(priv->adapter, INFO, \"Bypassed Gratuitous ARP\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn 0;\n\t}\n\n\tif (ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    ntohs(rx_pkt_hdr->eth803_hdr.h_proto) == ETH_P_TDLS) {\n\t\toffset = (u8 *)local_rx_pd + rx_pkt_off;\n\t\tmwifiex_process_tdls_action_frame(priv, offset, rx_pkt_len);\n\t}\n\n\t \n\tif (likely(!is_multicast_ether_addr(rx_pkt_hdr->eth803_hdr.h_dest))) {\n\t\tpriv->rxpd_rate = local_rx_pd->rx_rate;\n\t\tpriv->rxpd_htinfo = local_rx_pd->ht_info;\n\t}\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA ||\n\t    GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\n\t\tadj_rx_rate = mwifiex_adjust_data_rate(priv,\n\t\t\t\t\t\t       local_rx_pd->rx_rate,\n\t\t\t\t\t\t       local_rx_pd->ht_info);\n\t\tmwifiex_hist_data_add(priv, adj_rx_rate, local_rx_pd->snr,\n\t\t\t\t      local_rx_pd->nf);\n\t}\n\n\tret = mwifiex_recv_packet(priv, skb);\n\tif (ret == -1)\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"recv packet failed\\n\");\n\n\treturn ret;\n}\n\n \nint mwifiex_process_sta_rx_packet(struct mwifiex_private *priv,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret = 0;\n\tstruct rxpd *local_rx_pd;\n\tstruct rx_packet_hdr *rx_pkt_hdr;\n\tu8 ta[ETH_ALEN];\n\tu16 rx_pkt_type, rx_pkt_offset, rx_pkt_length, seq_num;\n\tstruct mwifiex_sta_node *sta_ptr;\n\n\tlocal_rx_pd = (struct rxpd *) (skb->data);\n\trx_pkt_type = le16_to_cpu(local_rx_pd->rx_pkt_type);\n\trx_pkt_offset = le16_to_cpu(local_rx_pd->rx_pkt_offset);\n\trx_pkt_length = le16_to_cpu(local_rx_pd->rx_pkt_length);\n\tseq_num = le16_to_cpu(local_rx_pd->seq_num);\n\n\trx_pkt_hdr = (void *)local_rx_pd + rx_pkt_offset;\n\n\tif ((rx_pkt_offset + rx_pkt_length) > skb->len ||\n\t    sizeof(rx_pkt_hdr->eth803_hdr) + rx_pkt_offset > skb->len) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"wrong rx packet: len=%d, rx_pkt_offset=%d, rx_pkt_length=%d\\n\",\n\t\t\t    skb->len, rx_pkt_offset, rx_pkt_length);\n\t\tpriv->stats.rx_dropped++;\n\t\tdev_kfree_skb_any(skb);\n\t\treturn ret;\n\t}\n\n\tif (rx_pkt_type == PKT_TYPE_MGMT) {\n\t\tret = mwifiex_process_mgmt_packet(priv, skb);\n\t\tif (ret)\n\t\t\tmwifiex_dbg(adapter, DATA, \"Rx of mgmt packet failed\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn ret;\n\t}\n\n\t \n\tif ((!IS_11N_ENABLED(priv) &&\n\t     !(ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t       !(local_rx_pd->flags & MWIFIEX_RXPD_FLAGS_TDLS_PACKET))) ||\n\t    !ether_addr_equal_unaligned(priv->curr_addr, rx_pkt_hdr->eth803_hdr.h_dest)) {\n\t\tmwifiex_process_rx_packet(priv, skb);\n\t\treturn ret;\n\t}\n\n\tif (mwifiex_queuing_ra_based(priv) ||\n\t    (ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t     local_rx_pd->flags & MWIFIEX_RXPD_FLAGS_TDLS_PACKET)) {\n\t\tmemcpy(ta, rx_pkt_hdr->eth803_hdr.h_source, ETH_ALEN);\n\t\tif (local_rx_pd->flags & MWIFIEX_RXPD_FLAGS_TDLS_PACKET &&\n\t\t    local_rx_pd->priority < MAX_NUM_TID) {\n\t\t\tsta_ptr = mwifiex_get_sta_entry(priv, ta);\n\t\t\tif (sta_ptr)\n\t\t\t\tsta_ptr->rx_seq[local_rx_pd->priority] =\n\t\t\t\t\t      le16_to_cpu(local_rx_pd->seq_num);\n\t\t\tmwifiex_auto_tdls_update_peer_signal(priv, ta,\n\t\t\t\t\t\t\t     local_rx_pd->snr,\n\t\t\t\t\t\t\t     local_rx_pd->nf);\n\t\t}\n\t} else {\n\t\tif (rx_pkt_type != PKT_TYPE_BAR &&\n\t\t    local_rx_pd->priority < MAX_NUM_TID)\n\t\t\tpriv->rx_seq[local_rx_pd->priority] = seq_num;\n\t\tmemcpy(ta, priv->curr_bss_params.bss_descriptor.mac_address,\n\t\t       ETH_ALEN);\n\t}\n\n\t \n\tret = mwifiex_11n_rx_reorder_pkt(priv, seq_num, local_rx_pd->priority,\n\t\t\t\t\t ta, (u8) rx_pkt_type, skb);\n\n\tif (ret || (rx_pkt_type == PKT_TYPE_BAR))\n\t\tdev_kfree_skb_any(skb);\n\n\tif (ret)\n\t\tpriv->stats.rx_dropped++;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}