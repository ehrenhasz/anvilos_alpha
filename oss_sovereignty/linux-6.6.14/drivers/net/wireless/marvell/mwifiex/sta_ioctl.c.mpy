{
  "module_name": "sta_ioctl.c",
  "hash_id": "bda76784685f47a8fe21059de5c21b1510841fbe83f47daa8563d7c5105a6297",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/sta_ioctl.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"cfg80211.h\"\n\nstatic int disconnect_on_suspend;\nmodule_param(disconnect_on_suspend, int, 0644);\n\n \nint mwifiex_copy_mcast_addr(struct mwifiex_multicast_list *mlist,\n\t\t\t    struct net_device *dev)\n{\n\tint i = 0;\n\tstruct netdev_hw_addr *ha;\n\n\tnetdev_for_each_mc_addr(ha, dev)\n\t\tmemcpy(&mlist->mac_list[i++], ha->addr, ETH_ALEN);\n\n\treturn i;\n}\n\n \nint mwifiex_wait_queue_complete(struct mwifiex_adapter *adapter,\n\t\t\t\tstruct cmd_ctrl_node *cmd_queued)\n{\n\tint status;\n\n\t \n\tstatus = wait_event_interruptible_timeout(adapter->cmd_wait_q.wait,\n\t\t\t\t\t\t  *(cmd_queued->condition),\n\t\t\t\t\t\t  (12 * HZ));\n\tif (status <= 0) {\n\t\tif (status == 0)\n\t\t\tstatus = -ETIMEDOUT;\n\t\tmwifiex_dbg(adapter, ERROR, \"cmd_wait_q terminated: %d\\n\",\n\t\t\t    status);\n\t\tmwifiex_cancel_all_pending_cmd(adapter);\n\t\treturn status;\n\t}\n\n\tstatus = adapter->cmd_wait_q.status;\n\tadapter->cmd_wait_q.status = 0;\n\n\treturn status;\n}\n\n \nint mwifiex_request_set_multicast_list(struct mwifiex_private *priv,\n\t\t\t\tstruct mwifiex_multicast_list *mcast_list)\n{\n\tint ret = 0;\n\tu16 old_pkt_filter;\n\n\told_pkt_filter = priv->curr_pkt_filter;\n\n\tif (mcast_list->mode == MWIFIEX_PROMISC_MODE) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: Enable Promiscuous mode\\n\");\n\t\tpriv->curr_pkt_filter |= HostCmd_ACT_MAC_PROMISCUOUS_ENABLE;\n\t\tpriv->curr_pkt_filter &=\n\t\t\t~HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;\n\t} else {\n\t\t \n\t\tpriv->curr_pkt_filter &= ~HostCmd_ACT_MAC_PROMISCUOUS_ENABLE;\n\t\tif (mcast_list->mode == MWIFIEX_ALL_MULTI_MODE) {\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: Enabling All Multicast!\\n\");\n\t\t\tpriv->curr_pkt_filter |=\n\t\t\t\tHostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;\n\t\t} else {\n\t\t\tpriv->curr_pkt_filter &=\n\t\t\t\t~HostCmd_ACT_MAC_ALL_MULTICAST_ENABLE;\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: Set multicast list=%d\\n\",\n\t\t\t\t    mcast_list->num_multicast_addr);\n\t\t\t \n\t\t\tret = mwifiex_send_cmd(priv,\n\t\t\t\t\t       HostCmd_CMD_MAC_MULTICAST_ADR,\n\t\t\t\t\t       HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t\t       mcast_list, false);\n\t\t}\n\t}\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: old_pkt_filter=%#x, curr_pkt_filter=%#x\\n\",\n\t\t    old_pkt_filter, priv->curr_pkt_filter);\n\tif (old_pkt_filter != priv->curr_pkt_filter) {\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t\t       HostCmd_ACT_GEN_SET,\n\t\t\t\t       0, &priv->curr_pkt_filter, false);\n\t}\n\n\treturn ret;\n}\n\n \nint mwifiex_fill_new_bss_desc(struct mwifiex_private *priv,\n\t\t\t      struct cfg80211_bss *bss,\n\t\t\t      struct mwifiex_bssdescriptor *bss_desc)\n{\n\tu8 *beacon_ie;\n\tsize_t beacon_ie_len;\n\tstruct mwifiex_bss_priv *bss_priv = (void *)bss->priv;\n\tconst struct cfg80211_bss_ies *ies;\n\n\trcu_read_lock();\n\ties = rcu_dereference(bss->ies);\n\tbeacon_ie = kmemdup(ies->data, ies->len, GFP_ATOMIC);\n\tbeacon_ie_len = ies->len;\n\tbss_desc->timestamp = ies->tsf;\n\trcu_read_unlock();\n\n\tif (!beacon_ie) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \" failed to alloc beacon_ie\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(bss_desc->mac_address, bss->bssid, ETH_ALEN);\n\tbss_desc->rssi = bss->signal;\n\t \n\tbss_desc->beacon_buf = beacon_ie;\n\tbss_desc->beacon_buf_size = beacon_ie_len;\n\tbss_desc->beacon_period = bss->beacon_interval;\n\tbss_desc->cap_info_bitmap = bss->capability;\n\tbss_desc->bss_band = bss_priv->band;\n\tbss_desc->fw_tsf = bss_priv->fw_tsf;\n\tif (bss_desc->cap_info_bitmap & WLAN_CAPABILITY_PRIVACY) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: InterpretIE: AP WEP enabled\\n\");\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\n\t} else {\n\t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\n\t}\n\tif (bss_desc->cap_info_bitmap & WLAN_CAPABILITY_IBSS)\n\t\tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\n\telse\n\t\tbss_desc->bss_mode = NL80211_IFTYPE_STATION;\n\n\t \n\tbss_desc->disable_11ac = true;\n\n\tif (bss_desc->cap_info_bitmap & WLAN_CAPABILITY_SPECTRUM_MGMT)\n\t\tbss_desc->sensed_11h = true;\n\n\treturn mwifiex_update_bss_desc_with_ie(priv->adapter, bss_desc);\n}\n\nvoid mwifiex_dnld_txpwr_table(struct mwifiex_private *priv)\n{\n\tif (priv->adapter->dt_node) {\n\t\tchar txpwr[] = {\"marvell,00_txpwrlimit\"};\n\n\t\tmemcpy(&txpwr[8], priv->adapter->country_code, 2);\n\t\tmwifiex_dnld_dt_cfgdata(priv, priv->adapter->dt_node, txpwr);\n\t}\n}\n\nstatic int mwifiex_process_country_ie(struct mwifiex_private *priv,\n\t\t\t\t      struct cfg80211_bss *bss)\n{\n\tconst u8 *country_ie;\n\tu8 country_ie_len;\n\tstruct mwifiex_802_11d_domain_reg *domain_info =\n\t\t\t\t\t&priv->adapter->domain_reg;\n\n\trcu_read_lock();\n\tcountry_ie = ieee80211_bss_get_ie(bss, WLAN_EID_COUNTRY);\n\tif (!country_ie) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tcountry_ie_len = country_ie[1];\n\tif (country_ie_len < IEEE80211_COUNTRY_IE_MIN_LEN) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tif (!strncmp(priv->adapter->country_code, &country_ie[2], 2)) {\n\t\trcu_read_unlock();\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"11D: skip setting domain info in FW\\n\");\n\t\treturn 0;\n\t}\n\n\tif (country_ie_len >\n\t    (IEEE80211_COUNTRY_STRING_LEN + MWIFIEX_MAX_TRIPLET_802_11D)) {\n\t\trcu_read_unlock();\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"11D: country_ie_len overflow!, deauth AP\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(priv->adapter->country_code, &country_ie[2], 2);\n\n\tdomain_info->country_code[0] = country_ie[2];\n\tdomain_info->country_code[1] = country_ie[3];\n\tdomain_info->country_code[2] = ' ';\n\n\tcountry_ie_len -= IEEE80211_COUNTRY_STRING_LEN;\n\n\tdomain_info->no_of_triplet =\n\t\tcountry_ie_len / sizeof(struct ieee80211_country_ie_triplet);\n\n\tmemcpy((u8 *)domain_info->triplet,\n\t       &country_ie[2] + IEEE80211_COUNTRY_STRING_LEN, country_ie_len);\n\n\trcu_read_unlock();\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11D_DOMAIN_INFO,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, NULL, false)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"11D: setting domain info in FW fail\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dnld_txpwr_table(priv);\n\n\treturn 0;\n}\n\n \nint mwifiex_bss_start(struct mwifiex_private *priv, struct cfg80211_bss *bss,\n\t\t      struct cfg80211_ssid *req_ssid)\n{\n\tint ret;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_bssdescriptor *bss_desc = NULL;\n\n\tpriv->scan_block = false;\n\n\tif (bss) {\n\t\tif (adapter->region_code == 0x00 &&\n\t\t    mwifiex_process_country_ie(priv, bss))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tbss_desc = kzalloc(sizeof(struct mwifiex_bssdescriptor),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!bss_desc)\n\t\t\treturn -ENOMEM;\n\n\t\tret = mwifiex_fill_new_bss_desc(priv, bss, bss_desc);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tif (priv->bss_mode == NL80211_IFTYPE_STATION ||\n\t    priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT) {\n\t\tu8 config_bands;\n\n\t\tif (!bss_desc)\n\t\t\treturn -1;\n\n\t\tif (mwifiex_band_to_radio_type(bss_desc->bss_band) ==\n\t\t\t\t\t\tHostCmd_SCAN_RADIO_TYPE_BG) {\n\t\t\tconfig_bands = BAND_B | BAND_G | BAND_GN;\n\t\t} else {\n\t\t\tconfig_bands = BAND_A | BAND_AN;\n\t\t\tif (adapter->fw_bands & BAND_AAC)\n\t\t\t\tconfig_bands |= BAND_AAC;\n\t\t}\n\n\t\tif (!((config_bands | adapter->fw_bands) & ~adapter->fw_bands))\n\t\t\tadapter->config_bands = config_bands;\n\n\t\tret = mwifiex_check_network_compatibility(priv, bss_desc);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tif (mwifiex_11h_get_csa_closed_channel(priv) ==\n\t\t\t\t\t\t\t(u8)bss_desc->channel) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Attempt to reconnect on csa closed chan(%d)\\n\",\n\t\t\t\t    bss_desc->channel);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: SSID found in scan list ...\\t\"\n\t\t\t    \"associating...\\n\");\n\n\t\tmwifiex_stop_net_dev_queue(priv->netdev, adapter);\n\t\tif (netif_carrier_ok(priv->netdev))\n\t\t\tnetif_carrier_off(priv->netdev);\n\n\t\t \n\t\tpriv->assoc_rsp_size = 0;\n\t\tret = mwifiex_associate(priv, bss_desc);\n\n\t\t \n\t\tif (ret == WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG &&\n\t\t    priv->sec_info.is_authtype_auto &&\n\t\t    priv->sec_info.wep_enabled) {\n\t\t\tpriv->sec_info.authentication_mode =\n\t\t\t\t\t\tNL80211_AUTHTYPE_SHARED_KEY;\n\t\t\tret = mwifiex_associate(priv, bss_desc);\n\t\t}\n\n\t\tif (bss)\n\t\t\tcfg80211_put_bss(priv->adapter->wiphy, bss);\n\t} else {\n\t\t \n\t\t \n\t\tif (bss_desc && bss_desc->ssid.ssid_len &&\n\t\t    (!mwifiex_ssid_cmp(&priv->curr_bss_params.bss_descriptor.\n\t\t\t\t       ssid, &bss_desc->ssid))) {\n\t\t\tret = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\tpriv->adhoc_is_link_sensed = false;\n\n\t\tret = mwifiex_check_network_compatibility(priv, bss_desc);\n\n\t\tmwifiex_stop_net_dev_queue(priv->netdev, adapter);\n\t\tif (netif_carrier_ok(priv->netdev))\n\t\t\tnetif_carrier_off(priv->netdev);\n\n\t\tif (!ret) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: network found in scan\\t\"\n\t\t\t\t    \" list. Joining...\\n\");\n\t\t\tret = mwifiex_adhoc_join(priv, bss_desc);\n\t\t\tif (bss)\n\t\t\t\tcfg80211_put_bss(priv->adapter->wiphy, bss);\n\t\t} else {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: Network not found in\\t\"\n\t\t\t\t    \"the list, creating adhoc with ssid = %s\\n\",\n\t\t\t\t    req_ssid->ssid);\n\t\t\tret = mwifiex_adhoc_start(priv, req_ssid);\n\t\t}\n\t}\n\ndone:\n\t \n\tif (bss_desc)\n\t\tkfree(bss_desc->beacon_buf);\n\tkfree(bss_desc);\n\n\tif (ret < 0)\n\t\tpriv->attempted_bss_desc = NULL;\n\n\treturn ret;\n}\n\n \nint mwifiex_set_hs_params(struct mwifiex_private *priv, u16 action,\n\t\t\t  int cmd_type, struct mwifiex_ds_hs_cfg *hs_cfg)\n\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint status = 0;\n\tu32 prev_cond = 0;\n\n\tif (!hs_cfg)\n\t\treturn -ENOMEM;\n\n\tswitch (action) {\n\tcase HostCmd_ACT_GEN_SET:\n\t\tif (adapter->pps_uapsd_mode) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: Host Sleep IOCTL\\t\"\n\t\t\t\t    \"is blocked in UAPSD/PPS mode\\n\");\n\t\t\tstatus = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (hs_cfg->is_invoke_hostcmd) {\n\t\t\tif (hs_cfg->conditions == HS_CFG_CANCEL) {\n\t\t\t\tif (!test_bit(MWIFIEX_IS_HS_CONFIGURED,\n\t\t\t\t\t      &adapter->work_flags))\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tprev_cond = le32_to_cpu(adapter->hs_cfg\n\t\t\t\t\t\t\t.conditions);\n\t\t\t\tadapter->hs_cfg.conditions =\n\t\t\t\t\t\tcpu_to_le32(hs_cfg->conditions);\n\t\t\t} else if (hs_cfg->conditions) {\n\t\t\t\tadapter->hs_cfg.conditions =\n\t\t\t\t\t\tcpu_to_le32(hs_cfg->conditions);\n\t\t\t\tadapter->hs_cfg.gpio = (u8)hs_cfg->gpio;\n\t\t\t\tif (hs_cfg->gap)\n\t\t\t\t\tadapter->hs_cfg.gap = (u8)hs_cfg->gap;\n\t\t\t} else if (adapter->hs_cfg.conditions ==\n\t\t\t\t   cpu_to_le32(HS_CFG_CANCEL)) {\n\t\t\t\t \n\t\t\t\tstatus = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstatus = mwifiex_send_cmd(priv,\n\t\t\t\t\t\t  HostCmd_CMD_802_11_HS_CFG_ENH,\n\t\t\t\t\t\t  HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t\t\t  &adapter->hs_cfg,\n\t\t\t\t\t\t  cmd_type == MWIFIEX_SYNC_CMD);\n\n\t\t\tif (hs_cfg->conditions == HS_CFG_CANCEL)\n\t\t\t\t \n\t\t\t\tadapter->hs_cfg.conditions =\n\t\t\t\t\t\tcpu_to_le32(prev_cond);\n\t\t} else {\n\t\t\tadapter->hs_cfg.conditions =\n\t\t\t\t\t\tcpu_to_le32(hs_cfg->conditions);\n\t\t\tadapter->hs_cfg.gpio = (u8)hs_cfg->gpio;\n\t\t\tadapter->hs_cfg.gap = (u8)hs_cfg->gap;\n\t\t}\n\t\tbreak;\n\tcase HostCmd_ACT_GEN_GET:\n\t\ths_cfg->conditions = le32_to_cpu(adapter->hs_cfg.conditions);\n\t\ths_cfg->gpio = adapter->hs_cfg.gpio;\n\t\ths_cfg->gap = adapter->hs_cfg.gap;\n\t\tbreak;\n\tdefault:\n\t\tstatus = -1;\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nint mwifiex_cancel_hs(struct mwifiex_private *priv, int cmd_type)\n{\n\tstruct mwifiex_ds_hs_cfg hscfg;\n\n\thscfg.conditions = HS_CFG_CANCEL;\n\thscfg.is_invoke_hostcmd = true;\n\n\treturn mwifiex_set_hs_params(priv, HostCmd_ACT_GEN_SET,\n\t\t\t\t    cmd_type, &hscfg);\n}\nEXPORT_SYMBOL_GPL(mwifiex_cancel_hs);\n\n \nint mwifiex_enable_hs(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_ds_hs_cfg hscfg;\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\tif (disconnect_on_suspend) {\n\t\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\t\tpriv = adapter->priv[i];\n\t\t\tif (priv)\n\t\t\t\tmwifiex_deauthenticate(priv, NULL);\n\t\t}\n\t}\n\n\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA);\n\n\tif (priv && priv->sched_scanning) {\n#ifdef CONFIG_PM\n\t\tif (priv->wdev.wiphy->wowlan_config &&\n\t\t    !priv->wdev.wiphy->wowlan_config->nd_config) {\n#endif\n\t\t\tmwifiex_dbg(adapter, CMD, \"aborting bgscan!\\n\");\n\t\t\tmwifiex_stop_bg_scan(priv);\n\t\t\tcfg80211_sched_scan_stopped(priv->wdev.wiphy, 0);\n#ifdef CONFIG_PM\n\t\t}\n#endif\n\t}\n\n\tif (adapter->hs_activated) {\n\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t    \"cmd: HS Already activated\\n\");\n\t\treturn true;\n\t}\n\n\tadapter->hs_activate_wait_q_woken = false;\n\n\tmemset(&hscfg, 0, sizeof(hscfg));\n\thscfg.is_invoke_hostcmd = true;\n\n\tset_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);\n\tmwifiex_cancel_all_pending_cmd(adapter);\n\n\tif (mwifiex_set_hs_params(mwifiex_get_priv(adapter,\n\t\t\t\t\t\t   MWIFIEX_BSS_ROLE_STA),\n\t\t\t\t  HostCmd_ACT_GEN_SET, MWIFIEX_SYNC_CMD,\n\t\t\t\t  &hscfg)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"IOCTL request HS enable failed\\n\");\n\t\treturn false;\n\t}\n\n\tif (wait_event_interruptible_timeout(adapter->hs_activate_wait_q,\n\t\t\t\t\t     adapter->hs_activate_wait_q_woken,\n\t\t\t\t\t     (10 * HZ)) <= 0) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"hs_activate_wait_q terminated\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(mwifiex_enable_hs);\n\n \nint mwifiex_get_bss_info(struct mwifiex_private *priv,\n\t\t\t struct mwifiex_bss_info *info)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\n\tif (!info)\n\t\treturn -1;\n\n\tbss_desc = &priv->curr_bss_params.bss_descriptor;\n\n\tinfo->bss_mode = priv->bss_mode;\n\n\tmemcpy(&info->ssid, &bss_desc->ssid, sizeof(struct cfg80211_ssid));\n\n\tmemcpy(&info->bssid, &bss_desc->mac_address, ETH_ALEN);\n\n\tinfo->bss_chan = bss_desc->channel;\n\n\tmemcpy(info->country_code, adapter->country_code,\n\t       IEEE80211_COUNTRY_STRING_LEN);\n\n\tinfo->media_connected = priv->media_connected;\n\n\tinfo->max_power_level = priv->max_tx_power_level;\n\tinfo->min_power_level = priv->min_tx_power_level;\n\n\tinfo->adhoc_state = priv->adhoc_state;\n\n\tinfo->bcn_nf_last = priv->bcn_nf_last;\n\n\tif (priv->sec_info.wep_enabled)\n\t\tinfo->wep_status = true;\n\telse\n\t\tinfo->wep_status = false;\n\n\tinfo->is_hs_configured = test_bit(MWIFIEX_IS_HS_CONFIGURED,\n\t\t\t\t\t  &adapter->work_flags);\n\tinfo->is_deep_sleep = adapter->is_deep_sleep;\n\n\treturn 0;\n}\n\n \nint mwifiex_disable_auto_ds(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_ds_auto_ds auto_ds = {\n\t\t.auto_ds = DEEP_SLEEP_OFF,\n\t};\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,\n\t\t\t\tDIS_AUTO_PS, BITMAP_AUTO_DS, &auto_ds, true);\n}\nEXPORT_SYMBOL_GPL(mwifiex_disable_auto_ds);\n\n \nint mwifiex_drv_get_data_rate(struct mwifiex_private *priv, u32 *rate)\n{\n\tint ret;\n\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_TX_RATE_QUERY,\n\t\t\t       HostCmd_ACT_GEN_GET, 0, NULL, true);\n\n\tif (!ret) {\n\t\tif (priv->is_data_rate_auto)\n\t\t\t*rate = mwifiex_index_to_data_rate(priv, priv->tx_rate,\n\t\t\t\t\t\t\t   priv->tx_htinfo);\n\t\telse\n\t\t\t*rate = priv->data_rate;\n\t}\n\n\treturn ret;\n}\n\n \nint mwifiex_set_tx_power(struct mwifiex_private *priv,\n\t\t\t struct mwifiex_power_cfg *power_cfg)\n{\n\tint ret;\n\tstruct host_cmd_ds_txpwr_cfg *txp_cfg;\n\tstruct mwifiex_types_power_group *pg_tlv;\n\tstruct mwifiex_power_group *pg;\n\tu8 *buf;\n\tu16 dbm = 0;\n\n\tif (!power_cfg->is_power_auto) {\n\t\tdbm = (u16) power_cfg->power_level;\n\t\tif ((dbm < priv->min_tx_power_level) ||\n\t\t    (dbm > priv->max_tx_power_level)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"txpower value %d dBm\\t\"\n\t\t\t\t    \"is out of range (%d dBm-%d dBm)\\n\",\n\t\t\t\t    dbm, priv->min_tx_power_level,\n\t\t\t\t    priv->max_tx_power_level);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tbuf = kzalloc(MWIFIEX_SIZE_OF_CMD_BUFFER, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\ttxp_cfg = (struct host_cmd_ds_txpwr_cfg *) buf;\n\ttxp_cfg->action = cpu_to_le16(HostCmd_ACT_GEN_SET);\n\tif (!power_cfg->is_power_auto) {\n\t\tu16 dbm_min = power_cfg->is_power_fixed ?\n\t\t\t      dbm : priv->min_tx_power_level;\n\n\t\ttxp_cfg->mode = cpu_to_le32(1);\n\t\tpg_tlv = (struct mwifiex_types_power_group *)\n\t\t\t (buf + sizeof(struct host_cmd_ds_txpwr_cfg));\n\t\tpg_tlv->type = cpu_to_le16(TLV_TYPE_POWER_GROUP);\n\t\tpg_tlv->length =\n\t\t\tcpu_to_le16(4 * sizeof(struct mwifiex_power_group));\n\t\tpg = (struct mwifiex_power_group *)\n\t\t     (buf + sizeof(struct host_cmd_ds_txpwr_cfg)\n\t\t      + sizeof(struct mwifiex_types_power_group));\n\t\t \n\t\tpg->first_rate_code = 0x00;\n\t\tpg->last_rate_code = 0x03;\n\t\tpg->modulation_class = MOD_CLASS_HR_DSSS;\n\t\tpg->power_step = 0;\n\t\tpg->power_min = (s8) dbm_min;\n\t\tpg->power_max = (s8) dbm;\n\t\tpg++;\n\t\t \n\t\tpg->first_rate_code = 0x00;\n\t\tpg->last_rate_code = 0x07;\n\t\tpg->modulation_class = MOD_CLASS_OFDM;\n\t\tpg->power_step = 0;\n\t\tpg->power_min = (s8) dbm_min;\n\t\tpg->power_max = (s8) dbm;\n\t\tpg++;\n\t\t \n\t\tpg->first_rate_code = 0x00;\n\t\tpg->last_rate_code = 0x20;\n\t\tpg->modulation_class = MOD_CLASS_HT;\n\t\tpg->power_step = 0;\n\t\tpg->power_min = (s8) dbm_min;\n\t\tpg->power_max = (s8) dbm;\n\t\tpg->ht_bandwidth = HT_BW_20;\n\t\tpg++;\n\t\t \n\t\tpg->first_rate_code = 0x00;\n\t\tpg->last_rate_code = 0x20;\n\t\tpg->modulation_class = MOD_CLASS_HT;\n\t\tpg->power_step = 0;\n\t\tpg->power_min = (s8) dbm_min;\n\t\tpg->power_max = (s8) dbm;\n\t\tpg->ht_bandwidth = HT_BW_40;\n\t}\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_TXPWR_CFG,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, buf, true);\n\n\tkfree(buf);\n\treturn ret;\n}\n\n \nint mwifiex_drv_set_power(struct mwifiex_private *priv, u32 *ps_mode)\n{\n\tint ret;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu16 sub_cmd;\n\n\tif (*ps_mode)\n\t\tadapter->ps_mode = MWIFIEX_802_11_POWER_MODE_PSP;\n\telse\n\t\tadapter->ps_mode = MWIFIEX_802_11_POWER_MODE_CAM;\n\tsub_cmd = (*ps_mode) ? EN_AUTO_PS : DIS_AUTO_PS;\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,\n\t\t\t       sub_cmd, BITMAP_STA_PS, NULL, true);\n\tif ((!ret) && (sub_cmd == DIS_AUTO_PS))\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,\n\t\t\t\t       GET_PS, 0, NULL, false);\n\n\treturn ret;\n}\n\n \nstatic int mwifiex_set_wpa_ie(struct mwifiex_private *priv,\n\t\t\t      u8 *ie_data_ptr, u16 ie_len)\n{\n\tif (ie_len) {\n\t\tif (ie_len > sizeof(priv->wpa_ie)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"failed to copy WPA IE, too big\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(priv->wpa_ie, ie_data_ptr, ie_len);\n\t\tpriv->wpa_ie_len = ie_len;\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: Set Wpa_ie_len=%d IE=%#x\\n\",\n\t\t\t    priv->wpa_ie_len, priv->wpa_ie[0]);\n\n\t\tif (priv->wpa_ie[0] == WLAN_EID_VENDOR_SPECIFIC) {\n\t\t\tpriv->sec_info.wpa_enabled = true;\n\t\t} else if (priv->wpa_ie[0] == WLAN_EID_RSN) {\n\t\t\tpriv->sec_info.wpa2_enabled = true;\n\t\t} else {\n\t\t\tpriv->sec_info.wpa_enabled = false;\n\t\t\tpriv->sec_info.wpa2_enabled = false;\n\t\t}\n\t} else {\n\t\tmemset(priv->wpa_ie, 0, sizeof(priv->wpa_ie));\n\t\tpriv->wpa_ie_len = 0;\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: reset wpa_ie_len=%d IE=%#x\\n\",\n\t\t\t    priv->wpa_ie_len, priv->wpa_ie[0]);\n\t\tpriv->sec_info.wpa_enabled = false;\n\t\tpriv->sec_info.wpa2_enabled = false;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_set_wapi_ie(struct mwifiex_private *priv,\n\t\t\t       u8 *ie_data_ptr, u16 ie_len)\n{\n\tif (ie_len) {\n\t\tif (ie_len > sizeof(priv->wapi_ie)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"info: failed to copy WAPI IE, too big\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(priv->wapi_ie, ie_data_ptr, ie_len);\n\t\tpriv->wapi_ie_len = ie_len;\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: Set wapi_ie_len=%d IE=%#x\\n\",\n\t\t\t    priv->wapi_ie_len, priv->wapi_ie[0]);\n\n\t\tif (priv->wapi_ie[0] == WLAN_EID_BSS_AC_ACCESS_DELAY)\n\t\t\tpriv->sec_info.wapi_enabled = true;\n\t} else {\n\t\tmemset(priv->wapi_ie, 0, sizeof(priv->wapi_ie));\n\t\tpriv->wapi_ie_len = ie_len;\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: Reset wapi_ie_len=%d IE=%#x\\n\",\n\t\t\t    priv->wapi_ie_len, priv->wapi_ie[0]);\n\t\tpriv->sec_info.wapi_enabled = false;\n\t}\n\treturn 0;\n}\n\n \nstatic int mwifiex_set_wps_ie(struct mwifiex_private *priv,\n\t\t\t       u8 *ie_data_ptr, u16 ie_len)\n{\n\tif (ie_len) {\n\t\tif (ie_len > MWIFIEX_MAX_VSIE_LEN) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"info: failed to copy WPS IE, too big\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tpriv->wps_ie = kzalloc(MWIFIEX_MAX_VSIE_LEN, GFP_KERNEL);\n\t\tif (!priv->wps_ie)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(priv->wps_ie, ie_data_ptr, ie_len);\n\t\tpriv->wps_ie_len = ie_len;\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: Set wps_ie_len=%d IE=%#x\\n\",\n\t\t\t    priv->wps_ie_len, priv->wps_ie[0]);\n\t} else {\n\t\tkfree(priv->wps_ie);\n\t\tpriv->wps_ie_len = ie_len;\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: Reset wps_ie_len=%d\\n\", priv->wps_ie_len);\n\t}\n\treturn 0;\n}\n\n \nstatic int mwifiex_sec_ioctl_set_wapi_key(struct mwifiex_private *priv,\n\t\t\t       struct mwifiex_ds_encrypt_key *encrypt_key)\n{\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\tHostCmd_ACT_GEN_SET, KEY_INFO_ENABLED,\n\t\t\t\tencrypt_key, true);\n}\n\n \nstatic int mwifiex_sec_ioctl_set_wep_key(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_ds_encrypt_key *encrypt_key)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret;\n\tstruct mwifiex_wep_key *wep_key;\n\tint index;\n\n\tif (priv->wep_key_curr_index >= NUM_WEP_KEYS)\n\t\tpriv->wep_key_curr_index = 0;\n\twep_key = &priv->wep_key[priv->wep_key_curr_index];\n\tindex = encrypt_key->key_index;\n\tif (encrypt_key->key_disable) {\n\t\tpriv->sec_info.wep_enabled = 0;\n\t} else if (!encrypt_key->key_len) {\n\t\t \n\t\twep_key = &priv->wep_key[index];\n\t\tif (!wep_key->key_length) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"key not set, so cannot enable it\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (adapter->key_api_major_ver == KEY_API_VER_MAJOR_V2) {\n\t\t\tmemcpy(encrypt_key->key_material,\n\t\t\t       wep_key->key_material, wep_key->key_length);\n\t\t\tencrypt_key->key_len = wep_key->key_length;\n\t\t}\n\n\t\tpriv->wep_key_curr_index = (u16) index;\n\t\tpriv->sec_info.wep_enabled = 1;\n\t} else {\n\t\twep_key = &priv->wep_key[index];\n\t\tmemset(wep_key, 0, sizeof(struct mwifiex_wep_key));\n\t\t \n\t\tmemcpy(wep_key->key_material,\n\t\t       encrypt_key->key_material,\n\t\t       encrypt_key->key_len);\n\t\twep_key->key_index = index;\n\t\twep_key->key_length = encrypt_key->key_len;\n\t\tpriv->sec_info.wep_enabled = 1;\n\t}\n\tif (wep_key->key_length) {\n\t\tvoid *enc_key;\n\n\t\tif (encrypt_key->key_disable) {\n\t\t\tmemset(&priv->wep_key[index], 0,\n\t\t\t       sizeof(struct mwifiex_wep_key));\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (adapter->key_api_major_ver == KEY_API_VER_MAJOR_V2)\n\t\t\tenc_key = encrypt_key;\n\t\telse\n\t\t\tenc_key = NULL;\n\n\t\t \n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\t       HostCmd_ACT_GEN_SET, 0, enc_key, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\ndone:\n\tif (priv->sec_info.wep_enabled)\n\t\tpriv->curr_pkt_filter |= HostCmd_ACT_MAC_WEP_ENABLE;\n\telse\n\t\tpriv->curr_pkt_filter &= ~HostCmd_ACT_MAC_WEP_ENABLE;\n\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t       HostCmd_ACT_GEN_SET, 0,\n\t\t\t       &priv->curr_pkt_filter, true);\n\n\treturn ret;\n}\n\n \nstatic int mwifiex_sec_ioctl_set_wpa_key(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_ds_encrypt_key *encrypt_key)\n{\n\tint ret;\n\tu8 remove_key = false;\n\tstruct host_cmd_ds_802_11_key_material *ibss_key;\n\n\t \n\tif (encrypt_key->key_len > WLAN_MAX_KEY_LEN) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"key length too long\\n\");\n\t\treturn -1;\n\t}\n\n\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC) {\n\t\t \n\t\t \n\t\tencrypt_key->key_index = MWIFIEX_KEY_INDEX_UNICAST;\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\t       HostCmd_ACT_GEN_SET,\n\t\t\t\t       KEY_INFO_ENABLED, encrypt_key, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tibss_key = &priv->aes_key;\n\t\tmemset(ibss_key, 0,\n\t\t       sizeof(struct host_cmd_ds_802_11_key_material));\n\t\t \n\t\tmemcpy(ibss_key->key_param_set.key, encrypt_key->key_material,\n\t\t       encrypt_key->key_len);\n\t\tmemcpy(&ibss_key->key_param_set.key_len, &encrypt_key->key_len,\n\t\t       sizeof(ibss_key->key_param_set.key_len));\n\t\tibss_key->key_param_set.key_type_id\n\t\t\t= cpu_to_le16(KEY_TYPE_ID_TKIP);\n\t\tibss_key->key_param_set.key_info = cpu_to_le16(KEY_ENABLED);\n\n\t\t \n\t\tencrypt_key->key_index = ~MWIFIEX_KEY_INDEX_UNICAST;\n\t}\n\n\tif (!encrypt_key->key_index)\n\t\tencrypt_key->key_index = MWIFIEX_KEY_INDEX_UNICAST;\n\n\tif (remove_key)\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\t       HostCmd_ACT_GEN_SET,\n\t\t\t\t       !KEY_INFO_ENABLED, encrypt_key, true);\n\telse\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_KEY_MATERIAL,\n\t\t\t\t       HostCmd_ACT_GEN_SET,\n\t\t\t\t       KEY_INFO_ENABLED, encrypt_key, true);\n\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_sec_ioctl_encrypt_key(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_ds_encrypt_key *encrypt_key)\n{\n\tint status;\n\n\tif (encrypt_key->is_wapi_key)\n\t\tstatus = mwifiex_sec_ioctl_set_wapi_key(priv, encrypt_key);\n\telse if (encrypt_key->key_len > WLAN_KEY_LEN_WEP104)\n\t\tstatus = mwifiex_sec_ioctl_set_wpa_key(priv, encrypt_key);\n\telse\n\t\tstatus = mwifiex_sec_ioctl_set_wep_key(priv, encrypt_key);\n\treturn status;\n}\n\n \nint\nmwifiex_drv_get_driver_version(struct mwifiex_adapter *adapter, char *version,\n\t\t\t       int max_len)\n{\n\tunion {\n\t\t__le32 l;\n\t\tu8 c[4];\n\t} ver;\n\tchar fw_ver[32];\n\n\tver.l = cpu_to_le32(adapter->fw_release_number);\n\tsprintf(fw_ver, \"%u.%u.%u.p%u\", ver.c[2], ver.c[1], ver.c[0], ver.c[3]);\n\n\tsnprintf(version, max_len, driver_version, fw_ver);\n\n\tmwifiex_dbg(adapter, MSG, \"info: MWIFIEX VERSION: %s\\n\", version);\n\n\treturn 0;\n}\n\n \nint mwifiex_set_encode(struct mwifiex_private *priv, struct key_params *kp,\n\t\t       const u8 *key, int key_len, u8 key_index,\n\t\t       const u8 *mac_addr, int disable)\n{\n\tstruct mwifiex_ds_encrypt_key encrypt_key;\n\n\tmemset(&encrypt_key, 0, sizeof(encrypt_key));\n\tencrypt_key.key_len = key_len;\n\tencrypt_key.key_index = key_index;\n\n\tif (kp && kp->cipher == WLAN_CIPHER_SUITE_AES_CMAC)\n\t\tencrypt_key.is_igtk_key = true;\n\n\tif (!disable) {\n\t\tif (key_len)\n\t\t\tmemcpy(encrypt_key.key_material, key, key_len);\n\t\telse\n\t\t\tencrypt_key.is_current_wep_key = true;\n\n\t\tif (mac_addr)\n\t\t\tmemcpy(encrypt_key.mac_addr, mac_addr, ETH_ALEN);\n\t\tif (kp && kp->seq && kp->seq_len) {\n\t\t\tmemcpy(encrypt_key.pn, kp->seq, kp->seq_len);\n\t\t\tencrypt_key.pn_len = kp->seq_len;\n\t\t\tencrypt_key.is_rx_seq_valid = true;\n\t\t}\n\t} else {\n\t\tencrypt_key.key_disable = true;\n\t\tif (mac_addr)\n\t\t\tmemcpy(encrypt_key.mac_addr, mac_addr, ETH_ALEN);\n\t}\n\n\treturn mwifiex_sec_ioctl_encrypt_key(priv, &encrypt_key);\n}\n\n \nint\nmwifiex_get_ver_ext(struct mwifiex_private *priv, u32 version_str_sel)\n{\n\tstruct mwifiex_ver_ext ver_ext;\n\n\tmemset(&ver_ext, 0, sizeof(ver_ext));\n\tver_ext.version_str_sel = version_str_sel;\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_VERSION_EXT,\n\t\t\t     HostCmd_ACT_GEN_GET, 0, &ver_ext, true))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint\nmwifiex_remain_on_chan_cfg(struct mwifiex_private *priv, u16 action,\n\t\t\t   struct ieee80211_channel *chan,\n\t\t\t   unsigned int duration)\n{\n\tstruct host_cmd_ds_remain_on_chan roc_cfg;\n\tu8 sc;\n\n\tmemset(&roc_cfg, 0, sizeof(roc_cfg));\n\troc_cfg.action = cpu_to_le16(action);\n\tif (action == HostCmd_ACT_GEN_SET) {\n\t\troc_cfg.band_cfg = chan->band;\n\t\tsc = mwifiex_chan_type_to_sec_chan_offset(NL80211_CHAN_NO_HT);\n\t\troc_cfg.band_cfg |= (sc << 2);\n\n\t\troc_cfg.channel =\n\t\t\tieee80211_frequency_to_channel(chan->center_freq);\n\t\troc_cfg.duration = cpu_to_le32(duration);\n\t}\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_REMAIN_ON_CHAN,\n\t\t\t     action, 0, &roc_cfg, true)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"failed to remain on channel\\n\");\n\t\treturn -1;\n\t}\n\n\treturn roc_cfg.status;\n}\n\n \nint\nmwifiex_get_stats_info(struct mwifiex_private *priv,\n\t\t       struct mwifiex_ds_get_stats *log)\n{\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_GET_LOG,\n\t\t\t\tHostCmd_ACT_GEN_GET, 0, log, true);\n}\n\n \nstatic int mwifiex_reg_mem_ioctl_reg_rw(struct mwifiex_private *priv,\n\t\t\t\t\tstruct mwifiex_ds_reg_rw *reg_rw,\n\t\t\t\t\tu16 action)\n{\n\tu16 cmd_no;\n\n\tswitch (reg_rw->type) {\n\tcase MWIFIEX_REG_MAC:\n\t\tcmd_no = HostCmd_CMD_MAC_REG_ACCESS;\n\t\tbreak;\n\tcase MWIFIEX_REG_BBP:\n\t\tcmd_no = HostCmd_CMD_BBP_REG_ACCESS;\n\t\tbreak;\n\tcase MWIFIEX_REG_RF:\n\t\tcmd_no = HostCmd_CMD_RF_REG_ACCESS;\n\t\tbreak;\n\tcase MWIFIEX_REG_PMIC:\n\t\tcmd_no = HostCmd_CMD_PMIC_REG_ACCESS;\n\t\tbreak;\n\tcase MWIFIEX_REG_CAU:\n\t\tcmd_no = HostCmd_CMD_CAU_REG_ACCESS;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn mwifiex_send_cmd(priv, cmd_no, action, 0, reg_rw, true);\n}\n\n \nint\nmwifiex_reg_write(struct mwifiex_private *priv, u32 reg_type,\n\t\t  u32 reg_offset, u32 reg_value)\n{\n\tstruct mwifiex_ds_reg_rw reg_rw;\n\n\treg_rw.type = reg_type;\n\treg_rw.offset = reg_offset;\n\treg_rw.value = reg_value;\n\n\treturn mwifiex_reg_mem_ioctl_reg_rw(priv, &reg_rw, HostCmd_ACT_GEN_SET);\n}\n\n \nint\nmwifiex_reg_read(struct mwifiex_private *priv, u32 reg_type,\n\t\t u32 reg_offset, u32 *value)\n{\n\tint ret;\n\tstruct mwifiex_ds_reg_rw reg_rw;\n\n\treg_rw.type = reg_type;\n\treg_rw.offset = reg_offset;\n\tret = mwifiex_reg_mem_ioctl_reg_rw(priv, &reg_rw, HostCmd_ACT_GEN_GET);\n\n\tif (ret)\n\t\tgoto done;\n\n\t*value = reg_rw.value;\n\ndone:\n\treturn ret;\n}\n\n \nint\nmwifiex_eeprom_read(struct mwifiex_private *priv, u16 offset, u16 bytes,\n\t\t    u8 *value)\n{\n\tint ret;\n\tstruct mwifiex_ds_read_eeprom rd_eeprom;\n\n\trd_eeprom.offset =  offset;\n\trd_eeprom.byte_count = bytes;\n\n\t \n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_EEPROM_ACCESS,\n\t\t\t       HostCmd_ACT_GEN_GET, 0, &rd_eeprom, true);\n\n\tif (!ret)\n\t\tmemcpy(value, rd_eeprom.value, min((u16)MAX_EEPROM_DATA,\n\t\t       rd_eeprom.byte_count));\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_set_gen_ie_helper(struct mwifiex_private *priv, u8 *ie_data_ptr,\n\t\t\t  u16 ie_len)\n{\n\tstruct ieee_types_vendor_header *pvendor_ie;\n\tstatic const u8 wpa_oui[] = { 0x00, 0x50, 0xf2, 0x01 };\n\tstatic const u8 wps_oui[] = { 0x00, 0x50, 0xf2, 0x04 };\n\tu16 unparsed_len = ie_len, cur_ie_len;\n\n\t \n\tif (!ie_len) {\n\t\tpriv->gen_ie_buf_len = 0;\n\t\tpriv->wps.session_enable = false;\n\t\treturn 0;\n\t} else if (!ie_data_ptr ||\n\t\t   ie_len <= sizeof(struct ieee_types_header)) {\n\t\treturn -1;\n\t}\n\tpvendor_ie = (struct ieee_types_vendor_header *) ie_data_ptr;\n\n\twhile (pvendor_ie) {\n\t\tcur_ie_len = pvendor_ie->len + sizeof(struct ieee_types_header);\n\n\t\tif (pvendor_ie->element_id == WLAN_EID_RSN) {\n\t\t\t \n\t\t\tmwifiex_set_wpa_ie(priv, (u8 *)pvendor_ie, cur_ie_len);\n\t\t\tpriv->wps.session_enable = false;\n\t\t\tgoto next_ie;\n\t\t}\n\n\t\tif (pvendor_ie->element_id == WLAN_EID_BSS_AC_ACCESS_DELAY) {\n\t\t\t \n\t\t\tmwifiex_set_wapi_ie(priv, (u8 *)pvendor_ie,\n\t\t\t\t\t    cur_ie_len);\n\t\t\tgoto next_ie;\n\t\t}\n\n\t\tif (pvendor_ie->element_id == WLAN_EID_VENDOR_SPECIFIC) {\n\t\t\t \n\t\t\tif (!memcmp(&pvendor_ie->oui, wpa_oui,\n\t\t\t\t    sizeof(wpa_oui))) {\n\t\t\t\t \n\t\t\t\tmwifiex_set_wpa_ie(priv, (u8 *)pvendor_ie,\n\t\t\t\t\t\t   cur_ie_len);\n\t\t\t\tpriv->wps.session_enable = false;\n\t\t\t\tgoto next_ie;\n\t\t\t}\n\n\t\t\tif (!memcmp(&pvendor_ie->oui, wps_oui,\n\t\t\t\t    sizeof(wps_oui))) {\n\t\t\t\t \n\t\t\t\tpriv->wps.session_enable = true;\n\t\t\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t\t\t    \"WPS Session Enabled.\\n\");\n\t\t\t\tmwifiex_set_wps_ie(priv, (u8 *)pvendor_ie,\n\t\t\t\t\t\t   cur_ie_len);\n\t\t\t\tgoto next_ie;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (cur_ie_len <\n\t\t    (sizeof(priv->gen_ie_buf) - priv->gen_ie_buf_len)) {\n\t\t\t \n\t\t\tmemcpy(priv->gen_ie_buf + priv->gen_ie_buf_len,\n\t\t\t       (u8 *)pvendor_ie, cur_ie_len);\n\t\t\t \n\t\t\tpriv->gen_ie_buf_len += cur_ie_len;\n\t\t}\n\nnext_ie:\n\t\tunparsed_len -= cur_ie_len;\n\n\t\tif (unparsed_len <= sizeof(struct ieee_types_header))\n\t\t\tpvendor_ie = NULL;\n\t\telse\n\t\t\tpvendor_ie = (struct ieee_types_vendor_header *)\n\t\t\t\t(((u8 *)pvendor_ie) + cur_ie_len);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_misc_ioctl_gen_ie(struct mwifiex_private *priv,\n\t\t\t\t     struct mwifiex_ds_misc_gen_ie *gen_ie,\n\t\t\t\t     u16 action)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tswitch (gen_ie->type) {\n\tcase MWIFIEX_IE_TYPE_GEN_IE:\n\t\tif (action == HostCmd_ACT_GEN_GET) {\n\t\t\tgen_ie->len = priv->wpa_ie_len;\n\t\t\tmemcpy(gen_ie->ie_data, priv->wpa_ie, gen_ie->len);\n\t\t} else {\n\t\t\tmwifiex_set_gen_ie_helper(priv, gen_ie->ie_data,\n\t\t\t\t\t\t  (u16) gen_ie->len);\n\t\t}\n\t\tbreak;\n\tcase MWIFIEX_IE_TYPE_ARP_FILTER:\n\t\tmemset(adapter->arp_filter, 0, sizeof(adapter->arp_filter));\n\t\tif (gen_ie->len > ARP_FILTER_MAX_BUF_SIZE) {\n\t\t\tadapter->arp_filter_size = 0;\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"invalid ARP filter size\\n\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tmemcpy(adapter->arp_filter, gen_ie->ie_data,\n\t\t\t       gen_ie->len);\n\t\t\tadapter->arp_filter_size = gen_ie->len;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(adapter, ERROR, \"invalid IE type\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nint\nmwifiex_set_gen_ie(struct mwifiex_private *priv, const u8 *ie, int ie_len)\n{\n\tstruct mwifiex_ds_misc_gen_ie gen_ie;\n\n\tif (ie_len > IEEE_MAX_IE_SIZE)\n\t\treturn -EFAULT;\n\n\tgen_ie.type = MWIFIEX_IE_TYPE_GEN_IE;\n\tgen_ie.len = ie_len;\n\tmemcpy(gen_ie.ie_data, ie, ie_len);\n\tif (mwifiex_misc_ioctl_gen_ie(priv, &gen_ie, HostCmd_ACT_GEN_SET))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nint mwifiex_get_wakeup_reason(struct mwifiex_private *priv, u16 action,\n\t\t\t      int cmd_type,\n\t\t\t      struct mwifiex_ds_wakeup_reason *wakeup_reason)\n{\n\tint status = 0;\n\n\tstatus = mwifiex_send_cmd(priv, HostCmd_CMD_HS_WAKEUP_REASON,\n\t\t\t\t  HostCmd_ACT_GEN_GET, 0, wakeup_reason,\n\t\t\t\t  cmd_type == MWIFIEX_SYNC_CMD);\n\n\treturn status;\n}\n\nint mwifiex_get_chan_info(struct mwifiex_private *priv,\n\t\t\t  struct mwifiex_channel_band *channel_band)\n{\n\tint status = 0;\n\n\tstatus = mwifiex_send_cmd(priv, HostCmd_CMD_STA_CONFIGURE,\n\t\t\t\t  HostCmd_ACT_GEN_GET, 0, channel_band,\n\t\t\t\t  MWIFIEX_SYNC_CMD);\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}