{
  "module_name": "11n_rxreorder.c",
  "hash_id": "8d735fc7a7d0bbd600e375b38c65b11179c9d4dc54fc3d8027726e0e1e79751c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"11n_rxreorder.h\"\n\n \nstatic int mwifiex_11n_dispatch_amsdu_pkt(struct mwifiex_private *priv,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct rxpd *local_rx_pd = (struct rxpd *)(skb->data);\n\tint ret;\n\n\tif (le16_to_cpu(local_rx_pd->rx_pkt_type) == PKT_TYPE_AMSDU) {\n\t\tstruct sk_buff_head list;\n\t\tstruct sk_buff *rx_skb;\n\n\t\t__skb_queue_head_init(&list);\n\n\t\tskb_pull(skb, le16_to_cpu(local_rx_pd->rx_pkt_offset));\n\t\tskb_trim(skb, le16_to_cpu(local_rx_pd->rx_pkt_length));\n\n\t\tieee80211_amsdu_to_8023s(skb, &list, priv->curr_addr,\n\t\t\t\t\t priv->wdev.iftype, 0, NULL, NULL, false);\n\n\t\twhile (!skb_queue_empty(&list)) {\n\t\t\tstruct rx_packet_hdr *rx_hdr;\n\n\t\t\trx_skb = __skb_dequeue(&list);\n\t\t\trx_hdr = (struct rx_packet_hdr *)rx_skb->data;\n\t\t\tif (ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t\t\t    ntohs(rx_hdr->eth803_hdr.h_proto) == ETH_P_TDLS) {\n\t\t\t\tmwifiex_process_tdls_action_frame(priv,\n\t\t\t\t\t\t\t\t  (u8 *)rx_hdr,\n\t\t\t\t\t\t\t\t  skb->len);\n\t\t\t}\n\n\t\t\tif (priv->bss_role == MWIFIEX_BSS_ROLE_UAP)\n\t\t\t\tret = mwifiex_uap_recv_packet(priv, rx_skb);\n\t\t\telse\n\t\t\t\tret = mwifiex_recv_packet(priv, rx_skb);\n\t\t\tif (ret == -1)\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"Rx of A-MSDU failed\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\n \nstatic int mwifiex_11n_dispatch_pkt(struct mwifiex_private *priv,\n\t\t\t\t    struct sk_buff *payload)\n{\n\n\tint ret;\n\n\tif (!payload) {\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: fw drop data\\n\");\n\t\treturn 0;\n\t}\n\n\tret = mwifiex_11n_dispatch_amsdu_pkt(priv, payload);\n\tif (!ret)\n\t\treturn 0;\n\n\tif (priv->bss_role == MWIFIEX_BSS_ROLE_UAP)\n\t\treturn mwifiex_handle_uap_rx_forward(priv, payload);\n\n\treturn mwifiex_process_rx_packet(priv, payload);\n}\n\n \nstatic void\nmwifiex_11n_dispatch_pkt_until_start_win(struct mwifiex_private *priv,\n\t\t\t\t\t struct mwifiex_rx_reorder_tbl *tbl,\n\t\t\t\t\t int start_win)\n{\n\tstruct sk_buff_head list;\n\tstruct sk_buff *skb;\n\tint pkt_to_send, i;\n\n\t__skb_queue_head_init(&list);\n\tspin_lock_bh(&priv->rx_reorder_tbl_lock);\n\n\tpkt_to_send = (start_win > tbl->start_win) ?\n\t\t      min((start_win - tbl->start_win), tbl->win_size) :\n\t\t      tbl->win_size;\n\n\tfor (i = 0; i < pkt_to_send; ++i) {\n\t\tif (tbl->rx_reorder_ptr[i]) {\n\t\t\tskb = tbl->rx_reorder_ptr[i];\n\t\t\t__skb_queue_tail(&list, skb);\n\t\t\ttbl->rx_reorder_ptr[i] = NULL;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < tbl->win_size - pkt_to_send; ++i) {\n\t\ttbl->rx_reorder_ptr[i] = tbl->rx_reorder_ptr[pkt_to_send + i];\n\t\ttbl->rx_reorder_ptr[pkt_to_send + i] = NULL;\n\t}\n\n\ttbl->start_win = start_win;\n\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n\n\twhile ((skb = __skb_dequeue(&list)))\n\t\tmwifiex_11n_dispatch_pkt(priv, skb);\n}\n\n \nstatic void\nmwifiex_11n_scan_and_dispatch(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_rx_reorder_tbl *tbl)\n{\n\tstruct sk_buff_head list;\n\tstruct sk_buff *skb;\n\tint i, j, xchg;\n\n\t__skb_queue_head_init(&list);\n\tspin_lock_bh(&priv->rx_reorder_tbl_lock);\n\n\tfor (i = 0; i < tbl->win_size; ++i) {\n\t\tif (!tbl->rx_reorder_ptr[i])\n\t\t\tbreak;\n\t\tskb = tbl->rx_reorder_ptr[i];\n\t\t__skb_queue_tail(&list, skb);\n\t\ttbl->rx_reorder_ptr[i] = NULL;\n\t}\n\n\t \n\tif (i > 0) {\n\t\txchg = tbl->win_size - i;\n\t\tfor (j = 0; j < xchg; ++j) {\n\t\t\ttbl->rx_reorder_ptr[j] = tbl->rx_reorder_ptr[i + j];\n\t\t\ttbl->rx_reorder_ptr[i + j] = NULL;\n\t\t}\n\t}\n\ttbl->start_win = (tbl->start_win + i) & (MAX_TID_VALUE - 1);\n\n\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n\n\twhile ((skb = __skb_dequeue(&list)))\n\t\tmwifiex_11n_dispatch_pkt(priv, skb);\n}\n\n \nstatic void\nmwifiex_del_rx_reorder_entry(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_rx_reorder_tbl *tbl)\n{\n\tint start_win;\n\n\tif (!tbl)\n\t\treturn;\n\n\tspin_lock_bh(&priv->adapter->rx_proc_lock);\n\tpriv->adapter->rx_locked = true;\n\tif (priv->adapter->rx_processing) {\n\t\tspin_unlock_bh(&priv->adapter->rx_proc_lock);\n\t\tflush_workqueue(priv->adapter->rx_workqueue);\n\t} else {\n\t\tspin_unlock_bh(&priv->adapter->rx_proc_lock);\n\t}\n\n\tstart_win = (tbl->start_win + tbl->win_size) & (MAX_TID_VALUE - 1);\n\tmwifiex_11n_dispatch_pkt_until_start_win(priv, tbl, start_win);\n\n\tdel_timer_sync(&tbl->timer_context.timer);\n\ttbl->timer_context.timer_is_set = false;\n\n\tspin_lock_bh(&priv->rx_reorder_tbl_lock);\n\tlist_del(&tbl->list);\n\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n\n\tkfree(tbl->rx_reorder_ptr);\n\tkfree(tbl);\n\n\tspin_lock_bh(&priv->adapter->rx_proc_lock);\n\tpriv->adapter->rx_locked = false;\n\tspin_unlock_bh(&priv->adapter->rx_proc_lock);\n\n}\n\n \nstruct mwifiex_rx_reorder_tbl *\nmwifiex_11n_get_rx_reorder_tbl(struct mwifiex_private *priv, int tid, u8 *ta)\n{\n\tstruct mwifiex_rx_reorder_tbl *tbl;\n\n\tspin_lock_bh(&priv->rx_reorder_tbl_lock);\n\tlist_for_each_entry(tbl, &priv->rx_reorder_tbl_ptr, list) {\n\t\tif (!memcmp(tbl->ta, ta, ETH_ALEN) && tbl->tid == tid) {\n\t\t\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n\t\t\treturn tbl;\n\t\t}\n\t}\n\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n\n\treturn NULL;\n}\n\n \nvoid mwifiex_11n_del_rx_reorder_tbl_by_ta(struct mwifiex_private *priv, u8 *ta)\n{\n\tstruct mwifiex_rx_reorder_tbl *tbl, *tmp;\n\n\tif (!ta)\n\t\treturn;\n\n\tspin_lock_bh(&priv->rx_reorder_tbl_lock);\n\tlist_for_each_entry_safe(tbl, tmp, &priv->rx_reorder_tbl_ptr, list) {\n\t\tif (!memcmp(tbl->ta, ta, ETH_ALEN)) {\n\t\t\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n\t\t\tmwifiex_del_rx_reorder_entry(priv, tbl);\n\t\t\tspin_lock_bh(&priv->rx_reorder_tbl_lock);\n\t\t}\n\t}\n\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n\n\treturn;\n}\n\n \nstatic int\nmwifiex_11n_find_last_seq_num(struct reorder_tmr_cnxt *ctx)\n{\n\tstruct mwifiex_rx_reorder_tbl *rx_reorder_tbl_ptr = ctx->ptr;\n\tstruct mwifiex_private *priv = ctx->priv;\n\tint i;\n\n\tspin_lock_bh(&priv->rx_reorder_tbl_lock);\n\tfor (i = rx_reorder_tbl_ptr->win_size - 1; i >= 0; --i) {\n\t\tif (rx_reorder_tbl_ptr->rx_reorder_ptr[i]) {\n\t\t\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n\t\t\treturn i;\n\t\t}\n\t}\n\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n\n\treturn -1;\n}\n\n \nstatic void\nmwifiex_flush_data(struct timer_list *t)\n{\n\tstruct reorder_tmr_cnxt *ctx =\n\t\tfrom_timer(ctx, t, timer);\n\tint start_win, seq_num;\n\n\tctx->timer_is_set = false;\n\tseq_num = mwifiex_11n_find_last_seq_num(ctx);\n\n\tif (seq_num < 0)\n\t\treturn;\n\n\tmwifiex_dbg(ctx->priv->adapter, INFO, \"info: flush data %d\\n\", seq_num);\n\tstart_win = (ctx->ptr->start_win + seq_num + 1) & (MAX_TID_VALUE - 1);\n\tmwifiex_11n_dispatch_pkt_until_start_win(ctx->priv, ctx->ptr,\n\t\t\t\t\t\t start_win);\n}\n\n \nstatic void\nmwifiex_11n_create_rx_reorder_tbl(struct mwifiex_private *priv, u8 *ta,\n\t\t\t\t  int tid, int win_size, int seq_num)\n{\n\tint i;\n\tstruct mwifiex_rx_reorder_tbl *tbl, *new_node;\n\tu16 last_seq = 0;\n\tstruct mwifiex_sta_node *node;\n\n\t \n\ttbl = mwifiex_11n_get_rx_reorder_tbl(priv, tid, ta);\n\tif (tbl) {\n\t\tmwifiex_11n_dispatch_pkt_until_start_win(priv, tbl, seq_num);\n\t\treturn;\n\t}\n\t \n\tnew_node = kzalloc(sizeof(struct mwifiex_rx_reorder_tbl), GFP_KERNEL);\n\tif (!new_node)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&new_node->list);\n\tnew_node->tid = tid;\n\tmemcpy(new_node->ta, ta, ETH_ALEN);\n\tnew_node->start_win = seq_num;\n\tnew_node->init_win = seq_num;\n\tnew_node->flags = 0;\n\n\tspin_lock_bh(&priv->sta_list_spinlock);\n\tif (mwifiex_queuing_ra_based(priv)) {\n\t\tif (priv->bss_role == MWIFIEX_BSS_ROLE_UAP) {\n\t\t\tnode = mwifiex_get_sta_entry(priv, ta);\n\t\t\tif (node)\n\t\t\t\tlast_seq = node->rx_seq[tid];\n\t\t}\n\t} else {\n\t\tnode = mwifiex_get_sta_entry(priv, ta);\n\t\tif (node)\n\t\t\tlast_seq = node->rx_seq[tid];\n\t\telse\n\t\t\tlast_seq = priv->rx_seq[tid];\n\t}\n\tspin_unlock_bh(&priv->sta_list_spinlock);\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: last_seq=%d start_win=%d\\n\",\n\t\t    last_seq, new_node->start_win);\n\n\tif (last_seq != MWIFIEX_DEF_11N_RX_SEQ_NUM &&\n\t    last_seq >= new_node->start_win) {\n\t\tnew_node->start_win = last_seq + 1;\n\t\tnew_node->flags |= RXREOR_INIT_WINDOW_SHIFT;\n\t}\n\n\tnew_node->win_size = win_size;\n\n\tnew_node->rx_reorder_ptr = kcalloc(win_size, sizeof(void *),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!new_node->rx_reorder_ptr) {\n\t\tkfree(new_node);\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"%s: failed to alloc reorder_ptr\\n\", __func__);\n\t\treturn;\n\t}\n\n\tnew_node->timer_context.ptr = new_node;\n\tnew_node->timer_context.priv = priv;\n\tnew_node->timer_context.timer_is_set = false;\n\n\ttimer_setup(&new_node->timer_context.timer, mwifiex_flush_data, 0);\n\n\tfor (i = 0; i < win_size; ++i)\n\t\tnew_node->rx_reorder_ptr[i] = NULL;\n\n\tspin_lock_bh(&priv->rx_reorder_tbl_lock);\n\tlist_add_tail(&new_node->list, &priv->rx_reorder_tbl_ptr);\n\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n}\n\nstatic void\nmwifiex_11n_rxreorder_timer_restart(struct mwifiex_rx_reorder_tbl *tbl)\n{\n\tu32 min_flush_time;\n\n\tif (tbl->win_size >= MWIFIEX_BA_WIN_SIZE_32)\n\t\tmin_flush_time = MIN_FLUSH_TIMER_15_MS;\n\telse\n\t\tmin_flush_time = MIN_FLUSH_TIMER_MS;\n\n\tmod_timer(&tbl->timer_context.timer,\n\t\t  jiffies + msecs_to_jiffies(min_flush_time * tbl->win_size));\n\n\ttbl->timer_context.timer_is_set = true;\n}\n\n \nint mwifiex_cmd_11n_addba_req(struct host_cmd_ds_command *cmd, void *data_buf)\n{\n\tstruct host_cmd_ds_11n_addba_req *add_ba_req = &cmd->params.add_ba_req;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_11N_ADDBA_REQ);\n\tcmd->size = cpu_to_le16(sizeof(*add_ba_req) + S_DS_GEN);\n\tmemcpy(add_ba_req, data_buf, sizeof(*add_ba_req));\n\n\treturn 0;\n}\n\n \nint mwifiex_cmd_11n_addba_rsp_gen(struct mwifiex_private *priv,\n\t\t\t\t  struct host_cmd_ds_command *cmd,\n\t\t\t\t  struct host_cmd_ds_11n_addba_req\n\t\t\t\t  *cmd_addba_req)\n{\n\tstruct host_cmd_ds_11n_addba_rsp *add_ba_rsp = &cmd->params.add_ba_rsp;\n\tstruct mwifiex_sta_node *sta_ptr;\n\tu32 rx_win_size = priv->add_ba_param.rx_win_size;\n\tu8 tid;\n\tint win_size;\n\tuint16_t block_ack_param_set;\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, cmd_addba_req->peer_mac_addr, ETH_ALEN)) {\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv,\n\t\t\t\t\t\tcmd_addba_req->peer_mac_addr);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    cmd_addba_req->peer_mac_addr);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\trx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_RXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_11N_ADDBA_RSP);\n\tcmd->size = cpu_to_le16(sizeof(*add_ba_rsp) + S_DS_GEN);\n\n\tmemcpy(add_ba_rsp->peer_mac_addr, cmd_addba_req->peer_mac_addr,\n\t       ETH_ALEN);\n\tadd_ba_rsp->dialog_token = cmd_addba_req->dialog_token;\n\tadd_ba_rsp->block_ack_tmo = cmd_addba_req->block_ack_tmo;\n\tadd_ba_rsp->ssn = cmd_addba_req->ssn;\n\n\tblock_ack_param_set = le16_to_cpu(cmd_addba_req->block_ack_param_set);\n\ttid = (block_ack_param_set & IEEE80211_ADDBA_PARAM_TID_MASK)\n\t\t>> BLOCKACKPARAM_TID_POS;\n\tadd_ba_rsp->status_code = cpu_to_le16(ADDBA_RSP_STATUS_ACCEPT);\n\tblock_ack_param_set &= ~IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK;\n\n\t \n\tif (!priv->add_ba_param.rx_amsdu ||\n\t    (priv->aggr_prio_tbl[tid].amsdu == BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set &= ~BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\tblock_ack_param_set |= rx_win_size << BLOCKACKPARAM_WINSIZE_POS;\n\tadd_ba_rsp->block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\twin_size = (le16_to_cpu(add_ba_rsp->block_ack_param_set)\n\t\t\t\t\t& IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK)\n\t\t\t\t\t>> BLOCKACKPARAM_WINSIZE_POS;\n\tcmd_addba_req->block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\n\tmwifiex_11n_create_rx_reorder_tbl(priv, cmd_addba_req->peer_mac_addr,\n\t\t\t\t\t  tid, win_size,\n\t\t\t\t\t  le16_to_cpu(cmd_addba_req->ssn));\n\treturn 0;\n}\n\n \nint mwifiex_cmd_11n_delba(struct host_cmd_ds_command *cmd, void *data_buf)\n{\n\tstruct host_cmd_ds_11n_delba *del_ba = &cmd->params.del_ba;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_11N_DELBA);\n\tcmd->size = cpu_to_le16(sizeof(*del_ba) + S_DS_GEN);\n\tmemcpy(del_ba, data_buf, sizeof(*del_ba));\n\n\treturn 0;\n}\n\n \nint mwifiex_11n_rx_reorder_pkt(struct mwifiex_private *priv,\n\t\t\t\tu16 seq_num, u16 tid,\n\t\t\t\tu8 *ta, u8 pkt_type, void *payload)\n{\n\tstruct mwifiex_rx_reorder_tbl *tbl;\n\tint prev_start_win, start_win, end_win, win_size;\n\tu16 pkt_index;\n\tbool init_window_shift = false;\n\tint ret = 0;\n\n\ttbl = mwifiex_11n_get_rx_reorder_tbl(priv, tid, ta);\n\tif (!tbl) {\n\t\tif (pkt_type != PKT_TYPE_BAR)\n\t\t\tmwifiex_11n_dispatch_pkt(priv, payload);\n\t\treturn ret;\n\t}\n\n\tif ((pkt_type == PKT_TYPE_AMSDU) && !tbl->amsdu) {\n\t\tmwifiex_11n_dispatch_pkt(priv, payload);\n\t\treturn ret;\n\t}\n\n\tstart_win = tbl->start_win;\n\tprev_start_win = start_win;\n\twin_size = tbl->win_size;\n\tend_win = ((start_win + win_size) - 1) & (MAX_TID_VALUE - 1);\n\tif (tbl->flags & RXREOR_INIT_WINDOW_SHIFT) {\n\t\tinit_window_shift = true;\n\t\ttbl->flags &= ~RXREOR_INIT_WINDOW_SHIFT;\n\t}\n\n\tif (tbl->flags & RXREOR_FORCE_NO_DROP) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"RXREOR_FORCE_NO_DROP when HS is activated\\n\");\n\t\ttbl->flags &= ~RXREOR_FORCE_NO_DROP;\n\t} else if (init_window_shift && seq_num < start_win &&\n\t\t   seq_num >= tbl->init_win) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"Sender TID sequence number reset %d->%d for SSN %d\\n\",\n\t\t\t    start_win, seq_num, tbl->init_win);\n\t\ttbl->start_win = start_win = seq_num;\n\t\tend_win = ((start_win + win_size) - 1) & (MAX_TID_VALUE - 1);\n\t} else {\n\t\t \n\t\tif ((start_win + TWOPOW11) > (MAX_TID_VALUE - 1)) {\n\t\t\tif (seq_num >= ((start_win + TWOPOW11) &\n\t\t\t\t\t(MAX_TID_VALUE - 1)) &&\n\t\t\t    seq_num < start_win) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else if ((seq_num < start_win) ||\n\t\t\t   (seq_num >= (start_win + TWOPOW11))) {\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (pkt_type == PKT_TYPE_BAR)\n\t\tseq_num = ((seq_num + win_size) - 1) & (MAX_TID_VALUE - 1);\n\n\tif (((end_win < start_win) &&\n\t     (seq_num < start_win) && (seq_num > end_win)) ||\n\t    ((end_win > start_win) && ((seq_num > end_win) ||\n\t\t\t\t       (seq_num < start_win)))) {\n\t\tend_win = seq_num;\n\t\tif (((end_win - win_size) + 1) >= 0)\n\t\t\tstart_win = (end_win - win_size) + 1;\n\t\telse\n\t\t\tstart_win = (MAX_TID_VALUE - (win_size - end_win)) + 1;\n\t\tmwifiex_11n_dispatch_pkt_until_start_win(priv, tbl, start_win);\n\t}\n\n\tif (pkt_type != PKT_TYPE_BAR) {\n\t\tif (seq_num >= start_win)\n\t\t\tpkt_index = seq_num - start_win;\n\t\telse\n\t\t\tpkt_index = (seq_num+MAX_TID_VALUE) - start_win;\n\n\t\tif (tbl->rx_reorder_ptr[pkt_index]) {\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\ttbl->rx_reorder_ptr[pkt_index] = payload;\n\t}\n\n\t \n\tmwifiex_11n_scan_and_dispatch(priv, tbl);\n\ndone:\n\tif (!tbl->timer_context.timer_is_set ||\n\t    prev_start_win != tbl->start_win)\n\t\tmwifiex_11n_rxreorder_timer_restart(tbl);\n\treturn ret;\n}\n\n \nvoid\nmwifiex_del_ba_tbl(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t   u8 type, int initiator)\n{\n\tstruct mwifiex_rx_reorder_tbl *tbl;\n\tstruct mwifiex_tx_ba_stream_tbl *ptx_tbl;\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tu8 cleanup_rx_reorder_tbl;\n\tint tid_down;\n\n\tif (type == TYPE_DELBA_RECEIVE)\n\t\tcleanup_rx_reorder_tbl = (initiator) ? true : false;\n\telse\n\t\tcleanup_rx_reorder_tbl = (initiator) ? false : true;\n\n\tmwifiex_dbg(priv->adapter, EVENT, \"event: DELBA: %pM tid=%d initiator=%d\\n\",\n\t\t    peer_mac, tid, initiator);\n\n\tif (cleanup_rx_reorder_tbl) {\n\t\ttbl = mwifiex_11n_get_rx_reorder_tbl(priv, tid,\n\t\t\t\t\t\t\t\t peer_mac);\n\t\tif (!tbl) {\n\t\t\tmwifiex_dbg(priv->adapter, EVENT,\n\t\t\t\t    \"event: TID, TA not found in table\\n\");\n\t\t\treturn;\n\t\t}\n\t\tmwifiex_del_rx_reorder_entry(priv, tbl);\n\t} else {\n\t\tptx_tbl = mwifiex_get_ba_tbl(priv, tid, peer_mac);\n\t\tif (!ptx_tbl) {\n\t\t\tmwifiex_dbg(priv->adapter, EVENT,\n\t\t\t\t    \"event: TID, RA not found in table\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\ttid_down = mwifiex_wmm_downgrade_tid(priv, tid);\n\t\tra_list = mwifiex_wmm_get_ralist_node(priv, tid_down, peer_mac);\n\t\tif (ra_list) {\n\t\t\tra_list->amsdu_in_ampdu = false;\n\t\t\tra_list->ba_status = BA_SETUP_NONE;\n\t\t}\n\t\tspin_lock_bh(&priv->tx_ba_stream_tbl_lock);\n\t\tmwifiex_11n_delete_tx_ba_stream_tbl_entry(priv, ptx_tbl);\n\t\tspin_unlock_bh(&priv->tx_ba_stream_tbl_lock);\n\t}\n}\n\n \nint mwifiex_ret_11n_addba_resp(struct mwifiex_private *priv,\n\t\t\t       struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_11n_addba_rsp *add_ba_rsp = &resp->params.add_ba_rsp;\n\tint tid, win_size;\n\tstruct mwifiex_rx_reorder_tbl *tbl;\n\tuint16_t block_ack_param_set;\n\n\tblock_ack_param_set = le16_to_cpu(add_ba_rsp->block_ack_param_set);\n\n\ttid = (block_ack_param_set & IEEE80211_ADDBA_PARAM_TID_MASK)\n\t\t>> BLOCKACKPARAM_TID_POS;\n\t \n\tif (le16_to_cpu(add_ba_rsp->status_code) != BA_RESULT_SUCCESS) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"ADDBA RSP: failed %pM tid=%d)\\n\",\n\t\t\t    add_ba_rsp->peer_mac_addr, tid);\n\n\t\ttbl = mwifiex_11n_get_rx_reorder_tbl(priv, tid,\n\t\t\t\t\t\t     add_ba_rsp->peer_mac_addr);\n\t\tif (tbl)\n\t\t\tmwifiex_del_rx_reorder_entry(priv, tbl);\n\n\t\treturn 0;\n\t}\n\n\twin_size = (block_ack_param_set & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK)\n\t\t    >> BLOCKACKPARAM_WINSIZE_POS;\n\n\ttbl = mwifiex_11n_get_rx_reorder_tbl(priv, tid,\n\t\t\t\t\t     add_ba_rsp->peer_mac_addr);\n\tif (tbl) {\n\t\tif ((block_ack_param_set & BLOCKACKPARAM_AMSDU_SUPP_MASK) &&\n\t\t    priv->add_ba_param.rx_amsdu &&\n\t\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\t\ttbl->amsdu = true;\n\t\telse\n\t\t\ttbl->amsdu = false;\n\t}\n\n\tmwifiex_dbg(priv->adapter, CMD,\n\t\t    \"cmd: ADDBA RSP: %pM tid=%d ssn=%d win_size=%d\\n\",\n\t\tadd_ba_rsp->peer_mac_addr, tid, add_ba_rsp->ssn, win_size);\n\n\treturn 0;\n}\n\n \nvoid mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_11n_batimeout *event)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\n\tmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\n\tmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\n\n\tdelba.del_ba_param_set |=\n\t\tcpu_to_le16((u16) event->tid << DELBA_TID_POS);\n\tdelba.del_ba_param_set |= cpu_to_le16(\n\t\t(u16) event->origninator << DELBA_INITIATOR_POS);\n\tdelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\n}\n\n \nvoid mwifiex_11n_cleanup_reorder_tbl(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_rx_reorder_tbl *del_tbl_ptr, *tmp_node;\n\n\tspin_lock_bh(&priv->rx_reorder_tbl_lock);\n\tlist_for_each_entry_safe(del_tbl_ptr, tmp_node,\n\t\t\t\t &priv->rx_reorder_tbl_ptr, list) {\n\t\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n\t\tmwifiex_del_rx_reorder_entry(priv, del_tbl_ptr);\n\t\tspin_lock_bh(&priv->rx_reorder_tbl_lock);\n\t}\n\tINIT_LIST_HEAD(&priv->rx_reorder_tbl_ptr);\n\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n\n\tmwifiex_reset_11n_rx_seq_num(priv);\n}\n\n \nvoid mwifiex_update_rxreor_flags(struct mwifiex_adapter *adapter, u8 flags)\n{\n\tstruct mwifiex_private *priv;\n\tstruct mwifiex_rx_reorder_tbl *tbl;\n\tint i;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tif (!priv)\n\t\t\tcontinue;\n\n\t\tspin_lock_bh(&priv->rx_reorder_tbl_lock);\n\t\tlist_for_each_entry(tbl, &priv->rx_reorder_tbl_ptr, list)\n\t\t\ttbl->flags = flags;\n\t\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n\t}\n\n\treturn;\n}\n\n \nstatic void mwifiex_update_ampdu_rxwinsize(struct mwifiex_adapter *adapter,\n\t\t\t\t\t   bool coex_flag)\n{\n\tu8 i;\n\tu32 rx_win_size;\n\tstruct mwifiex_private *priv;\n\n\tdev_dbg(adapter->dev, \"Update rxwinsize %d\\n\", coex_flag);\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (!adapter->priv[i])\n\t\t\tcontinue;\n\t\tpriv = adapter->priv[i];\n\t\trx_win_size = priv->add_ba_param.rx_win_size;\n\t\tif (coex_flag) {\n\t\t\tif (priv->bss_type == MWIFIEX_BSS_TYPE_STA)\n\t\t\t\tpriv->add_ba_param.rx_win_size =\n\t\t\t\t\tMWIFIEX_STA_COEX_AMPDU_DEF_RXWINSIZE;\n\t\t\tif (priv->bss_type == MWIFIEX_BSS_TYPE_P2P)\n\t\t\t\tpriv->add_ba_param.rx_win_size =\n\t\t\t\t\tMWIFIEX_STA_COEX_AMPDU_DEF_RXWINSIZE;\n\t\t\tif (priv->bss_type == MWIFIEX_BSS_TYPE_UAP)\n\t\t\t\tpriv->add_ba_param.rx_win_size =\n\t\t\t\t\tMWIFIEX_UAP_COEX_AMPDU_DEF_RXWINSIZE;\n\t\t} else {\n\t\t\tif (priv->bss_type == MWIFIEX_BSS_TYPE_STA)\n\t\t\t\tpriv->add_ba_param.rx_win_size =\n\t\t\t\t\tMWIFIEX_STA_AMPDU_DEF_RXWINSIZE;\n\t\t\tif (priv->bss_type == MWIFIEX_BSS_TYPE_P2P)\n\t\t\t\tpriv->add_ba_param.rx_win_size =\n\t\t\t\t\tMWIFIEX_STA_AMPDU_DEF_RXWINSIZE;\n\t\t\tif (priv->bss_type == MWIFIEX_BSS_TYPE_UAP)\n\t\t\t\tpriv->add_ba_param.rx_win_size =\n\t\t\t\t\tMWIFIEX_UAP_AMPDU_DEF_RXWINSIZE;\n\t\t}\n\n\t\tif (adapter->coex_win_size && adapter->coex_rx_win_size)\n\t\t\tpriv->add_ba_param.rx_win_size =\n\t\t\t\t\tadapter->coex_rx_win_size;\n\n\t\tif (rx_win_size != priv->add_ba_param.rx_win_size) {\n\t\t\tif (!priv->media_connected)\n\t\t\t\tcontinue;\n\t\t\tfor (i = 0; i < MAX_NUM_TID; i++)\n\t\t\t\tmwifiex_11n_delba(priv, i);\n\t\t}\n\t}\n}\n\n \nvoid mwifiex_coex_ampdu_rxwinsize(struct mwifiex_adapter *adapter)\n{\n\tu8 i;\n\tstruct mwifiex_private *priv;\n\tu8 count = 0;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (adapter->priv[i]) {\n\t\t\tpriv = adapter->priv[i];\n\t\t\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) {\n\t\t\t\tif (priv->media_connected)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\n\t\t\t\tif (priv->bss_started)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count >= MWIFIEX_BSS_COEX_COUNT)\n\t\t\tbreak;\n\t}\n\tif (count >= MWIFIEX_BSS_COEX_COUNT)\n\t\tmwifiex_update_ampdu_rxwinsize(adapter, true);\n\telse\n\t\tmwifiex_update_ampdu_rxwinsize(adapter, false);\n}\n\n \nvoid mwifiex_11n_rxba_sync_event(struct mwifiex_private *priv,\n\t\t\t\t u8 *event_buf, u16 len)\n{\n\tstruct mwifiex_ie_types_rxba_sync *tlv_rxba = (void *)event_buf;\n\tu16 tlv_type, tlv_len;\n\tstruct mwifiex_rx_reorder_tbl *rx_reor_tbl_ptr;\n\tu8 i, j;\n\tu16 seq_num, tlv_seq_num, tlv_bitmap_len;\n\tint tlv_buf_left = len;\n\tint ret;\n\tu8 *tmp;\n\n\tmwifiex_dbg_dump(priv->adapter, EVT_D, \"RXBA_SYNC event:\",\n\t\t\t event_buf, len);\n\twhile (tlv_buf_left > sizeof(*tlv_rxba)) {\n\t\ttlv_type = le16_to_cpu(tlv_rxba->header.type);\n\t\ttlv_len  = le16_to_cpu(tlv_rxba->header.len);\n\t\tif (size_add(sizeof(tlv_rxba->header), tlv_len) > tlv_buf_left) {\n\t\t\tmwifiex_dbg(priv->adapter, WARN,\n\t\t\t\t    \"TLV size (%zu) overflows event_buf buf_left=%d\\n\",\n\t\t\t\t    size_add(sizeof(tlv_rxba->header), tlv_len),\n\t\t\t\t    tlv_buf_left);\n\t\t\treturn;\n\t\t}\n\n\t\tif (tlv_type != TLV_TYPE_RXBA_SYNC) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"Wrong TLV id=0x%x\\n\", tlv_type);\n\t\t\treturn;\n\t\t}\n\n\t\ttlv_seq_num = le16_to_cpu(tlv_rxba->seq_num);\n\t\ttlv_bitmap_len = le16_to_cpu(tlv_rxba->bitmap_len);\n\t\tif (size_add(sizeof(*tlv_rxba), tlv_bitmap_len) > tlv_buf_left) {\n\t\t\tmwifiex_dbg(priv->adapter, WARN,\n\t\t\t\t    \"TLV size (%zu) overflows event_buf buf_left=%d\\n\",\n\t\t\t\t    size_add(sizeof(*tlv_rxba), tlv_bitmap_len),\n\t\t\t\t    tlv_buf_left);\n\t\t\treturn;\n\t\t}\n\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"%pM tid=%d seq_num=%d bitmap_len=%d\\n\",\n\t\t\t    tlv_rxba->mac, tlv_rxba->tid, tlv_seq_num,\n\t\t\t    tlv_bitmap_len);\n\n\t\trx_reor_tbl_ptr =\n\t\t\tmwifiex_11n_get_rx_reorder_tbl(priv, tlv_rxba->tid,\n\t\t\t\t\t\t       tlv_rxba->mac);\n\t\tif (!rx_reor_tbl_ptr) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"Can not find rx_reorder_tbl!\");\n\t\t\treturn;\n\t\t}\n\n\t\tfor (i = 0; i < tlv_bitmap_len; i++) {\n\t\t\tfor (j = 0 ; j < 8; j++) {\n\t\t\t\tif (tlv_rxba->bitmap[i] & (1 << j)) {\n\t\t\t\t\tseq_num = (MAX_TID_VALUE - 1) &\n\t\t\t\t\t\t(tlv_seq_num + i * 8 + j);\n\n\t\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t\t    \"drop packet,seq=%d\\n\",\n\t\t\t\t\t\t    seq_num);\n\n\t\t\t\t\tret = mwifiex_11n_rx_reorder_pkt\n\t\t\t\t\t(priv, seq_num, tlv_rxba->tid,\n\t\t\t\t\t tlv_rxba->mac, 0, NULL);\n\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tmwifiex_dbg(priv->adapter,\n\t\t\t\t\t\t\t    ERROR,\n\t\t\t\t\t\t\t    \"Fail to drop packet\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttlv_buf_left -= (sizeof(tlv_rxba->header) + tlv_len);\n\t\ttmp = (u8 *)tlv_rxba  + sizeof(tlv_rxba->header) + tlv_len;\n\t\ttlv_rxba = (struct mwifiex_ie_types_rxba_sync *)tmp;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}