{
  "module_name": "11n.c",
  "hash_id": "19fabf131daeebefd04051aee808c08a396b03953e333389155a518f9470566f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/11n.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n\n \nint mwifiex_fill_cap_info(struct mwifiex_private *priv, u8 radio_type,\n\t\t\t  struct ieee80211_ht_cap *ht_cap)\n{\n\tuint16_t ht_ext_cap = le16_to_cpu(ht_cap->extended_ht_cap_info);\n\tstruct ieee80211_supported_band *sband =\n\t\t\t\t\tpriv->wdev.wiphy->bands[radio_type];\n\n\tif (WARN_ON_ONCE(!sband)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"Invalid radio type!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tht_cap->ampdu_params_info =\n\t\t(sband->ht_cap.ampdu_factor &\n\t\t IEEE80211_HT_AMPDU_PARM_FACTOR) |\n\t\t((sband->ht_cap.ampdu_density <<\n\t\t IEEE80211_HT_AMPDU_PARM_DENSITY_SHIFT) &\n\t\t IEEE80211_HT_AMPDU_PARM_DENSITY);\n\n\tmemcpy((u8 *)&ht_cap->mcs, &sband->ht_cap.mcs,\n\t       sizeof(sband->ht_cap.mcs));\n\n\tif (priv->bss_mode == NL80211_IFTYPE_STATION ||\n\t    (sband->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 &&\n\t     (priv->adapter->sec_chan_offset !=\n\t\t\t\t\tIEEE80211_HT_PARAM_CHA_SEC_NONE)))\n\t\t \n\t\tSETHT_MCS32(ht_cap->mcs.rx_mask);\n\n\t \n\tht_ext_cap &= ~IEEE80211_HT_EXT_CAP_RD_RESPONDER;\n\n\tht_cap->cap_info = cpu_to_le16(sband->ht_cap.cap);\n\tht_cap->extended_ht_cap_info = cpu_to_le16(ht_ext_cap);\n\n\tif (ISSUPP_BEAMFORMING(priv->adapter->hw_dot_11n_dev_cap))\n\t\tht_cap->tx_BF_cap_info = cpu_to_le32(MWIFIEX_DEF_11N_TX_BF_CAP);\n\n\treturn 0;\n}\n\n \nstatic struct mwifiex_tx_ba_stream_tbl *\nmwifiex_get_ba_status(struct mwifiex_private *priv,\n\t\t      enum mwifiex_ba_status ba_status)\n{\n\tstruct mwifiex_tx_ba_stream_tbl *tx_ba_tsr_tbl;\n\n\tspin_lock_bh(&priv->tx_ba_stream_tbl_lock);\n\tlist_for_each_entry(tx_ba_tsr_tbl, &priv->tx_ba_stream_tbl_ptr, list) {\n\t\tif (tx_ba_tsr_tbl->ba_status == ba_status) {\n\t\t\tspin_unlock_bh(&priv->tx_ba_stream_tbl_lock);\n\t\t\treturn tx_ba_tsr_tbl;\n\t\t}\n\t}\n\tspin_unlock_bh(&priv->tx_ba_stream_tbl_lock);\n\treturn NULL;\n}\n\n \nint mwifiex_ret_11n_delba(struct mwifiex_private *priv,\n\t\t\t  struct host_cmd_ds_command *resp)\n{\n\tint tid;\n\tstruct mwifiex_tx_ba_stream_tbl *tx_ba_tbl;\n\tstruct host_cmd_ds_11n_delba *del_ba = &resp->params.del_ba;\n\tuint16_t del_ba_param_set = le16_to_cpu(del_ba->del_ba_param_set);\n\n\ttid = del_ba_param_set >> DELBA_TID_POS;\n\tif (del_ba->del_result == BA_RESULT_SUCCESS) {\n\t\tmwifiex_del_ba_tbl(priv, tid, del_ba->peer_mac_addr,\n\t\t\t\t   TYPE_DELBA_SENT,\n\t\t\t\t   INITIATOR_BIT(del_ba_param_set));\n\n\t\ttx_ba_tbl = mwifiex_get_ba_status(priv, BA_SETUP_INPROGRESS);\n\t\tif (tx_ba_tbl)\n\t\t\tmwifiex_send_addba(priv, tx_ba_tbl->tid,\n\t\t\t\t\t   tx_ba_tbl->ra);\n\t} else {  \n\t\tif (!INITIATOR_BIT(del_ba_param_set))\n\t\t\treturn 0;\n\n\t\tmwifiex_create_ba_tbl(priv, del_ba->peer_mac_addr, tid,\n\t\t\t\t      BA_SETUP_INPROGRESS);\n\n\t\ttx_ba_tbl = mwifiex_get_ba_status(priv, BA_SETUP_INPROGRESS);\n\n\t\tif (tx_ba_tbl)\n\t\t\tmwifiex_del_ba_tbl(priv, tx_ba_tbl->tid, tx_ba_tbl->ra,\n\t\t\t\t\t   TYPE_DELBA_SENT, true);\n\t}\n\n\treturn 0;\n}\n\n \nint mwifiex_ret_11n_addba_req(struct mwifiex_private *priv,\n\t\t\t      struct host_cmd_ds_command *resp)\n{\n\tint tid, tid_down;\n\tstruct host_cmd_ds_11n_addba_rsp *add_ba_rsp = &resp->params.add_ba_rsp;\n\tstruct mwifiex_tx_ba_stream_tbl *tx_ba_tbl;\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tu16 block_ack_param_set = le16_to_cpu(add_ba_rsp->block_ack_param_set);\n\n\tadd_ba_rsp->ssn = cpu_to_le16((le16_to_cpu(add_ba_rsp->ssn))\n\t\t\t& SSN_MASK);\n\n\ttid = (block_ack_param_set & IEEE80211_ADDBA_PARAM_TID_MASK)\n\t       >> BLOCKACKPARAM_TID_POS;\n\n\ttid_down = mwifiex_wmm_downgrade_tid(priv, tid);\n\tra_list = mwifiex_wmm_get_ralist_node(priv, tid_down, add_ba_rsp->\n\t\tpeer_mac_addr);\n\tif (le16_to_cpu(add_ba_rsp->status_code) != BA_RESULT_SUCCESS) {\n\t\tif (ra_list) {\n\t\t\tra_list->ba_status = BA_SETUP_NONE;\n\t\t\tra_list->amsdu_in_ampdu = false;\n\t\t}\n\t\tmwifiex_del_ba_tbl(priv, tid, add_ba_rsp->peer_mac_addr,\n\t\t\t\t   TYPE_DELBA_SENT, true);\n\t\tif (add_ba_rsp->add_rsp_result != BA_RESULT_TIMEOUT)\n\t\t\tpriv->aggr_prio_tbl[tid].ampdu_ap =\n\t\t\t\tBA_STREAM_NOT_ALLOWED;\n\t\treturn 0;\n\t}\n\n\ttx_ba_tbl = mwifiex_get_ba_tbl(priv, tid, add_ba_rsp->peer_mac_addr);\n\tif (tx_ba_tbl) {\n\t\tmwifiex_dbg(priv->adapter, EVENT, \"info: BA stream complete\\n\");\n\t\ttx_ba_tbl->ba_status = BA_SETUP_COMPLETE;\n\t\tif ((block_ack_param_set & BLOCKACKPARAM_AMSDU_SUPP_MASK) &&\n\t\t    priv->add_ba_param.tx_amsdu &&\n\t\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\t\ttx_ba_tbl->amsdu = true;\n\t\telse\n\t\t\ttx_ba_tbl->amsdu = false;\n\t\tif (ra_list) {\n\t\t\tra_list->amsdu_in_ampdu = tx_ba_tbl->amsdu;\n\t\t\tra_list->ba_status = BA_SETUP_COMPLETE;\n\t\t}\n\t} else {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"BA stream not created\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nint mwifiex_cmd_recfg_tx_buf(struct mwifiex_private *priv,\n\t\t\t     struct host_cmd_ds_command *cmd, int cmd_action,\n\t\t\t     u16 *buf_size)\n{\n\tstruct host_cmd_ds_txbuf_cfg *tx_buf = &cmd->params.tx_buf;\n\tu16 action = (u16) cmd_action;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_RECONFIGURE_TX_BUFF);\n\tcmd->size =\n\t\tcpu_to_le16(sizeof(struct host_cmd_ds_txbuf_cfg) + S_DS_GEN);\n\ttx_buf->action = cpu_to_le16(action);\n\tswitch (action) {\n\tcase HostCmd_ACT_GEN_SET:\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: set tx_buf=%d\\n\", *buf_size);\n\t\ttx_buf->buff_size = cpu_to_le16(*buf_size);\n\t\tbreak;\n\tcase HostCmd_ACT_GEN_GET:\n\tdefault:\n\t\ttx_buf->buff_size = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nint mwifiex_cmd_amsdu_aggr_ctrl(struct host_cmd_ds_command *cmd,\n\t\t\t\tint cmd_action,\n\t\t\t\tstruct mwifiex_ds_11n_amsdu_aggr_ctrl *aa_ctrl)\n{\n\tstruct host_cmd_ds_amsdu_aggr_ctrl *amsdu_ctrl =\n\t\t&cmd->params.amsdu_aggr_ctrl;\n\tu16 action = (u16) cmd_action;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_AMSDU_AGGR_CTRL);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_amsdu_aggr_ctrl)\n\t\t\t\t+ S_DS_GEN);\n\tamsdu_ctrl->action = cpu_to_le16(action);\n\tswitch (action) {\n\tcase HostCmd_ACT_GEN_SET:\n\t\tamsdu_ctrl->enable = cpu_to_le16(aa_ctrl->enable);\n\t\tamsdu_ctrl->curr_buf_size = 0;\n\t\tbreak;\n\tcase HostCmd_ACT_GEN_GET:\n\tdefault:\n\t\tamsdu_ctrl->curr_buf_size = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nint mwifiex_cmd_11n_cfg(struct mwifiex_private *priv,\n\t\t\tstruct host_cmd_ds_command *cmd, u16 cmd_action,\n\t\t\tstruct mwifiex_ds_11n_tx_cfg *txcfg)\n{\n\tstruct host_cmd_ds_11n_cfg *htcfg = &cmd->params.htcfg;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_11N_CFG);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_11n_cfg) + S_DS_GEN);\n\thtcfg->action = cpu_to_le16(cmd_action);\n\thtcfg->ht_tx_cap = cpu_to_le16(txcfg->tx_htcap);\n\thtcfg->ht_tx_info = cpu_to_le16(txcfg->tx_htinfo);\n\n\tif (priv->adapter->is_hw_11ac_capable)\n\t\thtcfg->misc_config = cpu_to_le16(txcfg->misc_config);\n\n\treturn 0;\n}\n\n \nint\nmwifiex_cmd_append_11n_tlv(struct mwifiex_private *priv,\n\t\t\t   struct mwifiex_bssdescriptor *bss_desc,\n\t\t\t   u8 **buffer)\n{\n\tstruct mwifiex_ie_types_htcap *ht_cap;\n\tstruct mwifiex_ie_types_htinfo *ht_info;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_list;\n\tstruct mwifiex_ie_types_2040bssco *bss_co_2040;\n\tstruct mwifiex_ie_types_extcap *ext_cap;\n\tint ret_len = 0;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee_types_header *hdr;\n\tu8 radio_type;\n\n\tif (!buffer || !*buffer)\n\t\treturn ret_len;\n\n\tradio_type = mwifiex_band_to_radio_type((u8) bss_desc->bss_band);\n\tsband = priv->wdev.wiphy->bands[radio_type];\n\n\tif (bss_desc->bcn_ht_cap) {\n\t\tht_cap = (struct mwifiex_ie_types_htcap *) *buffer;\n\t\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\n\t\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\tht_cap->header.len =\n\t\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\tmemcpy((u8 *) ht_cap + sizeof(struct mwifiex_ie_types_header),\n\t\t       (u8 *)bss_desc->bcn_ht_cap,\n\t\t       le16_to_cpu(ht_cap->header.len));\n\n\t\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\n\t\t \n\t\tif (bss_desc->bcn_ht_oper) {\n\t\t\tu8 ht_param = bss_desc->bcn_ht_oper->ht_param;\n\t\t\tu8 radio =\n\t\t\tmwifiex_band_to_radio_type(bss_desc->bss_band);\n\t\t\tint freq =\n\t\t\tieee80211_channel_to_frequency(bss_desc->channel,\n\t\t\t\t\t\t       radio);\n\t\t\tstruct ieee80211_channel *chan =\n\t\t\tieee80211_get_channel(priv->adapter->wiphy, freq);\n\n\t\t\tswitch (ht_param & IEEE80211_HT_PARAM_CHA_SEC_OFFSET) {\n\t\t\tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_NO_HT40PLUS) {\n\t\t\t\t\tht_cap->ht_cap.cap_info &=\n\t\t\t\t\tcpu_to_le16\n\t\t\t\t\t(~IEEE80211_HT_CAP_SUP_WIDTH_20_40);\n\t\t\t\t\tht_cap->ht_cap.cap_info &=\n\t\t\t\t\tcpu_to_le16(~IEEE80211_HT_CAP_SGI_40);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_NO_HT40MINUS) {\n\t\t\t\t\tht_cap->ht_cap.cap_info &=\n\t\t\t\t\tcpu_to_le16\n\t\t\t\t\t(~IEEE80211_HT_CAP_SUP_WIDTH_20_40);\n\t\t\t\t\tht_cap->ht_cap.cap_info &=\n\t\t\t\t\tcpu_to_le16(~IEEE80211_HT_CAP_SGI_40);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t*buffer += sizeof(struct mwifiex_ie_types_htcap);\n\t\tret_len += sizeof(struct mwifiex_ie_types_htcap);\n\t}\n\n\tif (bss_desc->bcn_ht_oper) {\n\t\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC) {\n\t\t\tht_info = (struct mwifiex_ie_types_htinfo *) *buffer;\n\t\t\tmemset(ht_info, 0,\n\t\t\t       sizeof(struct mwifiex_ie_types_htinfo));\n\t\t\tht_info->header.type =\n\t\t\t\t\tcpu_to_le16(WLAN_EID_HT_OPERATION);\n\t\t\tht_info->header.len =\n\t\t\t\tcpu_to_le16(\n\t\t\t\t\tsizeof(struct ieee80211_ht_operation));\n\n\t\t\tmemcpy((u8 *) ht_info +\n\t\t\t       sizeof(struct mwifiex_ie_types_header),\n\t\t\t       (u8 *)bss_desc->bcn_ht_oper,\n\t\t\t       le16_to_cpu(ht_info->header.len));\n\n\t\t\tif (!(sband->ht_cap.cap &\n\t\t\t\t\tIEEE80211_HT_CAP_SUP_WIDTH_20_40))\n\t\t\t\tht_info->ht_oper.ht_param &=\n\t\t\t\t\t~(IEEE80211_HT_PARAM_CHAN_WIDTH_ANY |\n\t\t\t\t\tIEEE80211_HT_PARAM_CHA_SEC_OFFSET);\n\n\t\t\t*buffer += sizeof(struct mwifiex_ie_types_htinfo);\n\t\t\tret_len += sizeof(struct mwifiex_ie_types_htinfo);\n\t\t}\n\n\t\tchan_list =\n\t\t\t(struct mwifiex_ie_types_chan_list_param_set *) *buffer;\n\t\tmemset(chan_list, 0,\n\t\t       sizeof(struct mwifiex_ie_types_chan_list_param_set));\n\t\tchan_list->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\t\tchan_list->header.len = cpu_to_le16(\n\t\t\tsizeof(struct mwifiex_ie_types_chan_list_param_set) -\n\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\tchan_list->chan_scan_param[0].chan_number =\n\t\t\tbss_desc->bcn_ht_oper->primary_chan;\n\t\tchan_list->chan_scan_param[0].radio_type =\n\t\t\tmwifiex_band_to_radio_type((u8) bss_desc->bss_band);\n\n\t\tif (sband->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 &&\n\t\t    bss_desc->bcn_ht_oper->ht_param &\n\t\t    IEEE80211_HT_PARAM_CHAN_WIDTH_ANY)\n\t\t\tSET_SECONDARYCHAN(chan_list->chan_scan_param[0].\n\t\t\t\t\t  radio_type,\n\t\t\t\t\t  (bss_desc->bcn_ht_oper->ht_param &\n\t\t\t\t\t  IEEE80211_HT_PARAM_CHA_SEC_OFFSET));\n\n\t\t*buffer += sizeof(struct mwifiex_ie_types_chan_list_param_set);\n\t\tret_len += sizeof(struct mwifiex_ie_types_chan_list_param_set);\n\t}\n\n\tif (bss_desc->bcn_bss_co_2040) {\n\t\tbss_co_2040 = (struct mwifiex_ie_types_2040bssco *) *buffer;\n\t\tmemset(bss_co_2040, 0,\n\t\t       sizeof(struct mwifiex_ie_types_2040bssco));\n\t\tbss_co_2040->header.type = cpu_to_le16(WLAN_EID_BSS_COEX_2040);\n\t\tbss_co_2040->header.len =\n\t\t       cpu_to_le16(sizeof(bss_co_2040->bss_co_2040));\n\n\t\tmemcpy((u8 *) bss_co_2040 +\n\t\t       sizeof(struct mwifiex_ie_types_header),\n\t\t       bss_desc->bcn_bss_co_2040 +\n\t\t       sizeof(struct ieee_types_header),\n\t\t       le16_to_cpu(bss_co_2040->header.len));\n\n\t\t*buffer += sizeof(struct mwifiex_ie_types_2040bssco);\n\t\tret_len += sizeof(struct mwifiex_ie_types_2040bssco);\n\t}\n\n\tif (bss_desc->bcn_ext_cap) {\n\t\thdr = (void *)bss_desc->bcn_ext_cap;\n\t\text_cap = (struct mwifiex_ie_types_extcap *) *buffer;\n\t\tmemset(ext_cap, 0, sizeof(struct mwifiex_ie_types_extcap));\n\t\text_cap->header.type = cpu_to_le16(WLAN_EID_EXT_CAPABILITY);\n\t\text_cap->header.len = cpu_to_le16(hdr->len);\n\n\t\tmemcpy((u8 *)ext_cap->ext_capab,\n\t\t       bss_desc->bcn_ext_cap + sizeof(struct ieee_types_header),\n\t\t       le16_to_cpu(ext_cap->header.len));\n\n\t\tif (hdr->len > 3 &&\n\t\t    ext_cap->ext_capab[3] & WLAN_EXT_CAPA4_INTERWORKING_ENABLED)\n\t\t\tpriv->hs2_enabled = true;\n\t\telse\n\t\t\tpriv->hs2_enabled = false;\n\n\t\t*buffer += sizeof(struct mwifiex_ie_types_extcap) + hdr->len;\n\t\tret_len += sizeof(struct mwifiex_ie_types_extcap) + hdr->len;\n\t}\n\n\treturn ret_len;\n}\n\n \nstatic int mwifiex_is_tx_ba_stream_ptr_valid(struct mwifiex_private *priv,\n\t\t\t\tstruct mwifiex_tx_ba_stream_tbl *tx_tbl_ptr)\n{\n\tstruct mwifiex_tx_ba_stream_tbl *tx_ba_tsr_tbl;\n\n\tlist_for_each_entry(tx_ba_tsr_tbl, &priv->tx_ba_stream_tbl_ptr, list) {\n\t\tif (tx_ba_tsr_tbl == tx_tbl_ptr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nvoid mwifiex_11n_delete_tx_ba_stream_tbl_entry(struct mwifiex_private *priv,\n\t\t\t\tstruct mwifiex_tx_ba_stream_tbl *tx_ba_tsr_tbl)\n{\n\tif (!tx_ba_tsr_tbl &&\n\t    mwifiex_is_tx_ba_stream_ptr_valid(priv, tx_ba_tsr_tbl))\n\t\treturn;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: tx_ba_tsr_tbl %p\\n\", tx_ba_tsr_tbl);\n\n\tlist_del(&tx_ba_tsr_tbl->list);\n\n\tkfree(tx_ba_tsr_tbl);\n}\n\n \nvoid mwifiex_11n_delete_all_tx_ba_stream_tbl(struct mwifiex_private *priv)\n{\n\tint i;\n\tstruct mwifiex_tx_ba_stream_tbl *del_tbl_ptr, *tmp_node;\n\n\tspin_lock_bh(&priv->tx_ba_stream_tbl_lock);\n\tlist_for_each_entry_safe(del_tbl_ptr, tmp_node,\n\t\t\t\t &priv->tx_ba_stream_tbl_ptr, list)\n\t\tmwifiex_11n_delete_tx_ba_stream_tbl_entry(priv, del_tbl_ptr);\n\tspin_unlock_bh(&priv->tx_ba_stream_tbl_lock);\n\n\tINIT_LIST_HEAD(&priv->tx_ba_stream_tbl_ptr);\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i)\n\t\tpriv->aggr_prio_tbl[i].ampdu_ap =\n\t\t\tpriv->aggr_prio_tbl[i].ampdu_user;\n}\n\n \nstruct mwifiex_tx_ba_stream_tbl *\nmwifiex_get_ba_tbl(struct mwifiex_private *priv, int tid, u8 *ra)\n{\n\tstruct mwifiex_tx_ba_stream_tbl *tx_ba_tsr_tbl;\n\n\tspin_lock_bh(&priv->tx_ba_stream_tbl_lock);\n\tlist_for_each_entry(tx_ba_tsr_tbl, &priv->tx_ba_stream_tbl_ptr, list) {\n\t\tif (ether_addr_equal_unaligned(tx_ba_tsr_tbl->ra, ra) &&\n\t\t    tx_ba_tsr_tbl->tid == tid) {\n\t\t\tspin_unlock_bh(&priv->tx_ba_stream_tbl_lock);\n\t\t\treturn tx_ba_tsr_tbl;\n\t\t}\n\t}\n\tspin_unlock_bh(&priv->tx_ba_stream_tbl_lock);\n\treturn NULL;\n}\n\n \nvoid mwifiex_create_ba_tbl(struct mwifiex_private *priv, u8 *ra, int tid,\n\t\t\t   enum mwifiex_ba_status ba_status)\n{\n\tstruct mwifiex_tx_ba_stream_tbl *new_node;\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tint tid_down;\n\n\tif (!mwifiex_get_ba_tbl(priv, tid, ra)) {\n\t\tnew_node = kzalloc(sizeof(struct mwifiex_tx_ba_stream_tbl),\n\t\t\t\t   GFP_ATOMIC);\n\t\tif (!new_node)\n\t\t\treturn;\n\n\t\ttid_down = mwifiex_wmm_downgrade_tid(priv, tid);\n\t\tra_list = mwifiex_wmm_get_ralist_node(priv, tid_down, ra);\n\t\tif (ra_list) {\n\t\t\tra_list->ba_status = ba_status;\n\t\t\tra_list->amsdu_in_ampdu = false;\n\t\t}\n\t\tINIT_LIST_HEAD(&new_node->list);\n\n\t\tnew_node->tid = tid;\n\t\tnew_node->ba_status = ba_status;\n\t\tmemcpy(new_node->ra, ra, ETH_ALEN);\n\n\t\tspin_lock_bh(&priv->tx_ba_stream_tbl_lock);\n\t\tlist_add_tail(&new_node->list, &priv->tx_ba_stream_tbl_ptr);\n\t\tspin_unlock_bh(&priv->tx_ba_stream_tbl_lock);\n\t}\n}\n\n \nint mwifiex_send_addba(struct mwifiex_private *priv, int tid, u8 *peer_mac)\n{\n\tstruct host_cmd_ds_11n_addba_req add_ba_req;\n\tu32 tx_win_size = priv->add_ba_param.tx_win_size;\n\tstatic u8 dialog_tok;\n\tint ret;\n\tu16 block_ack_param_set;\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: %s: tid %d\\n\", __func__, tid);\n\n\tmemset(&add_ba_req, 0, sizeof(add_ba_req));\n\n\tif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\n\t    ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->is_hw_11ac_capable &&\n\t    memcmp(priv->cfg_bssid, peer_mac, ETH_ALEN)) {\n\t\tstruct mwifiex_sta_node *sta_ptr;\n\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tsta_ptr = mwifiex_get_sta_entry(priv, peer_mac);\n\t\tif (!sta_ptr) {\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"BA setup with unknown TDLS peer %pM!\\n\",\n\t\t\t\t    peer_mac);\n\t\t\treturn -1;\n\t\t}\n\t\tif (sta_ptr->is_11ac_enabled)\n\t\t\ttx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_TXWINSIZE;\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tblock_ack_param_set = (u16)((tid << BLOCKACKPARAM_TID_POS) |\n\t\t\t\t    tx_win_size << BLOCKACKPARAM_WINSIZE_POS |\n\t\t\t\t    IMMEDIATE_BLOCK_ACK);\n\n\t \n\tif (priv->add_ba_param.tx_amsdu &&\n\t    (priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\n\t\tblock_ack_param_set |= BLOCKACKPARAM_AMSDU_SUPP_MASK;\n\n\tadd_ba_req.block_ack_param_set = cpu_to_le16(block_ack_param_set);\n\tadd_ba_req.block_ack_tmo = cpu_to_le16((u16)priv->add_ba_param.timeout);\n\n\t++dialog_tok;\n\n\tif (dialog_tok == 0)\n\t\tdialog_tok = 1;\n\n\tadd_ba_req.dialog_token = dialog_tok;\n\tmemcpy(&add_ba_req.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t \n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_REQ,\n\t\t\t       0, 0, &add_ba_req, false);\n\n\treturn ret;\n}\n\n \nint mwifiex_send_delba(struct mwifiex_private *priv, int tid, u8 *peer_mac,\n\t\t       int initiator)\n{\n\tstruct host_cmd_ds_11n_delba delba;\n\tint ret;\n\tuint16_t del_ba_param_set;\n\n\tmemset(&delba, 0, sizeof(delba));\n\n\tdel_ba_param_set = tid << DELBA_TID_POS;\n\n\tif (initiator)\n\t\tdel_ba_param_set |= IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\telse\n\t\tdel_ba_param_set &= ~IEEE80211_DELBA_PARAM_INITIATOR_MASK;\n\n\tdelba.del_ba_param_set = cpu_to_le16(del_ba_param_set);\n\tmemcpy(&delba.peer_mac_addr, peer_mac, ETH_ALEN);\n\n\t \n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &delba, false);\n\n\treturn ret;\n}\n\n \nvoid mwifiex_11n_delba(struct mwifiex_private *priv, int tid)\n{\n\tstruct mwifiex_rx_reorder_tbl *rx_reor_tbl_ptr;\n\n\tspin_lock_bh(&priv->rx_reorder_tbl_lock);\n\tlist_for_each_entry(rx_reor_tbl_ptr, &priv->rx_reorder_tbl_ptr, list) {\n\t\tif (rx_reor_tbl_ptr->tid == tid) {\n\t\t\tdev_dbg(priv->adapter->dev,\n\t\t\t\t\"Send delba to tid=%d, %pM\\n\",\n\t\t\t\ttid, rx_reor_tbl_ptr->ta);\n\t\t\tmwifiex_send_delba(priv, tid, rx_reor_tbl_ptr->ta, 0);\n\t\t\tgoto exit;\n\t\t}\n\t}\nexit:\n\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n}\n\n \nvoid mwifiex_11n_delete_ba_stream(struct mwifiex_private *priv, u8 *del_ba)\n{\n\tstruct host_cmd_ds_11n_delba *cmd_del_ba =\n\t\t(struct host_cmd_ds_11n_delba *) del_ba;\n\tuint16_t del_ba_param_set = le16_to_cpu(cmd_del_ba->del_ba_param_set);\n\tint tid;\n\n\ttid = del_ba_param_set >> DELBA_TID_POS;\n\n\tmwifiex_del_ba_tbl(priv, tid, cmd_del_ba->peer_mac_addr,\n\t\t\t   TYPE_DELBA_RECEIVE, INITIATOR_BIT(del_ba_param_set));\n}\n\n \nint mwifiex_get_rx_reorder_tbl(struct mwifiex_private *priv,\n\t\t\t       struct mwifiex_ds_rx_reorder_tbl *buf)\n{\n\tint i;\n\tstruct mwifiex_ds_rx_reorder_tbl *rx_reo_tbl = buf;\n\tstruct mwifiex_rx_reorder_tbl *rx_reorder_tbl_ptr;\n\tint count = 0;\n\n\tspin_lock_bh(&priv->rx_reorder_tbl_lock);\n\tlist_for_each_entry(rx_reorder_tbl_ptr, &priv->rx_reorder_tbl_ptr,\n\t\t\t    list) {\n\t\trx_reo_tbl->tid = (u16) rx_reorder_tbl_ptr->tid;\n\t\tmemcpy(rx_reo_tbl->ta, rx_reorder_tbl_ptr->ta, ETH_ALEN);\n\t\trx_reo_tbl->start_win = rx_reorder_tbl_ptr->start_win;\n\t\trx_reo_tbl->win_size = rx_reorder_tbl_ptr->win_size;\n\t\tfor (i = 0; i < rx_reorder_tbl_ptr->win_size; ++i) {\n\t\t\tif (rx_reorder_tbl_ptr->rx_reorder_ptr[i])\n\t\t\t\trx_reo_tbl->buffer[i] = true;\n\t\t\telse\n\t\t\t\trx_reo_tbl->buffer[i] = false;\n\t\t}\n\t\trx_reo_tbl++;\n\t\tcount++;\n\n\t\tif (count >= MWIFIEX_MAX_RX_BASTREAM_SUPPORTED)\n\t\t\tbreak;\n\t}\n\tspin_unlock_bh(&priv->rx_reorder_tbl_lock);\n\n\treturn count;\n}\n\n \nint mwifiex_get_tx_ba_stream_tbl(struct mwifiex_private *priv,\n\t\t\t\t struct mwifiex_ds_tx_ba_stream_tbl *buf)\n{\n\tstruct mwifiex_tx_ba_stream_tbl *tx_ba_tsr_tbl;\n\tstruct mwifiex_ds_tx_ba_stream_tbl *rx_reo_tbl = buf;\n\tint count = 0;\n\n\tspin_lock_bh(&priv->tx_ba_stream_tbl_lock);\n\tlist_for_each_entry(tx_ba_tsr_tbl, &priv->tx_ba_stream_tbl_ptr, list) {\n\t\trx_reo_tbl->tid = (u16) tx_ba_tsr_tbl->tid;\n\t\tmwifiex_dbg(priv->adapter, DATA, \"data: %s tid=%d\\n\",\n\t\t\t    __func__, rx_reo_tbl->tid);\n\t\tmemcpy(rx_reo_tbl->ra, tx_ba_tsr_tbl->ra, ETH_ALEN);\n\t\trx_reo_tbl->amsdu = tx_ba_tsr_tbl->amsdu;\n\t\trx_reo_tbl++;\n\t\tcount++;\n\t\tif (count >= MWIFIEX_MAX_TX_BASTREAM_SUPPORTED)\n\t\t\tbreak;\n\t}\n\tspin_unlock_bh(&priv->tx_ba_stream_tbl_lock);\n\n\treturn count;\n}\n\n \nvoid mwifiex_del_tx_ba_stream_tbl_by_ra(struct mwifiex_private *priv, u8 *ra)\n{\n\tstruct mwifiex_tx_ba_stream_tbl *tbl, *tmp;\n\n\tif (!ra)\n\t\treturn;\n\n\tspin_lock_bh(&priv->tx_ba_stream_tbl_lock);\n\tlist_for_each_entry_safe(tbl, tmp, &priv->tx_ba_stream_tbl_ptr, list)\n\t\tif (!memcmp(tbl->ra, ra, ETH_ALEN))\n\t\t\tmwifiex_11n_delete_tx_ba_stream_tbl_entry(priv, tbl);\n\tspin_unlock_bh(&priv->tx_ba_stream_tbl_lock);\n\n\treturn;\n}\n\n \nvoid mwifiex_set_ba_params(struct mwifiex_private *priv)\n{\n\tpriv->add_ba_param.timeout = MWIFIEX_DEFAULT_BLOCK_ACK_TIMEOUT;\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\n\t\tpriv->add_ba_param.tx_win_size =\n\t\t\t\t\t\tMWIFIEX_UAP_AMPDU_DEF_TXWINSIZE;\n\t\tpriv->add_ba_param.rx_win_size =\n\t\t\t\t\t\tMWIFIEX_UAP_AMPDU_DEF_RXWINSIZE;\n\t} else {\n\t\tpriv->add_ba_param.tx_win_size =\n\t\t\t\t\t\tMWIFIEX_STA_AMPDU_DEF_TXWINSIZE;\n\t\tpriv->add_ba_param.rx_win_size =\n\t\t\t\t\t\tMWIFIEX_STA_AMPDU_DEF_RXWINSIZE;\n\t}\n\n\tpriv->add_ba_param.tx_amsdu = true;\n\tpriv->add_ba_param.rx_amsdu = true;\n\n\treturn;\n}\n\nu8 mwifiex_get_sec_chan_offset(int chan)\n{\n\tu8 sec_offset;\n\n\tswitch (chan) {\n\tcase 36:\n\tcase 44:\n\tcase 52:\n\tcase 60:\n\tcase 100:\n\tcase 108:\n\tcase 116:\n\tcase 124:\n\tcase 132:\n\tcase 140:\n\tcase 149:\n\tcase 157:\n\t\tsec_offset = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;\n\t\tbreak;\n\tcase 40:\n\tcase 48:\n\tcase 56:\n\tcase 64:\n\tcase 104:\n\tcase 112:\n\tcase 120:\n\tcase 128:\n\tcase 136:\n\tcase 144:\n\tcase 153:\n\tcase 161:\n\t\tsec_offset = IEEE80211_HT_PARAM_CHA_SEC_BELOW;\n\t\tbreak;\n\tcase 165:\n\tdefault:\n\t\tsec_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n\t\tbreak;\n\t}\n\n\treturn sec_offset;\n}\n\n \nstatic void\nmwifiex_send_delba_txbastream_tbl(struct mwifiex_private *priv, u8 tid)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_tx_ba_stream_tbl *tx_ba_stream_tbl_ptr;\n\n\tlist_for_each_entry(tx_ba_stream_tbl_ptr,\n\t\t\t    &priv->tx_ba_stream_tbl_ptr, list) {\n\t\tif (tx_ba_stream_tbl_ptr->ba_status == BA_SETUP_COMPLETE) {\n\t\t\tif (tid == tx_ba_stream_tbl_ptr->tid) {\n\t\t\t\tdev_dbg(adapter->dev,\n\t\t\t\t\t\"Tx:Send delba to tid=%d, %pM\\n\", tid,\n\t\t\t\t\ttx_ba_stream_tbl_ptr->ra);\n\t\t\t\tmwifiex_send_delba(priv,\n\t\t\t\t\t\t   tx_ba_stream_tbl_ptr->tid,\n\t\t\t\t\t\t   tx_ba_stream_tbl_ptr->ra, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid mwifiex_update_ampdu_txwinsize(struct mwifiex_adapter *adapter)\n{\n\tu8 i, j;\n\tu32 tx_win_size;\n\tstruct mwifiex_private *priv;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (!adapter->priv[i])\n\t\t\tcontinue;\n\t\tpriv = adapter->priv[i];\n\t\ttx_win_size = priv->add_ba_param.tx_win_size;\n\n\t\tif (priv->bss_type == MWIFIEX_BSS_TYPE_STA)\n\t\t\tpriv->add_ba_param.tx_win_size =\n\t\t\t\tMWIFIEX_STA_AMPDU_DEF_TXWINSIZE;\n\n\t\tif (priv->bss_type == MWIFIEX_BSS_TYPE_P2P)\n\t\t\tpriv->add_ba_param.tx_win_size =\n\t\t\t\tMWIFIEX_STA_AMPDU_DEF_TXWINSIZE;\n\n\t\tif (priv->bss_type == MWIFIEX_BSS_TYPE_UAP)\n\t\t\tpriv->add_ba_param.tx_win_size =\n\t\t\t\tMWIFIEX_UAP_AMPDU_DEF_TXWINSIZE;\n\n\t\tif (adapter->coex_win_size) {\n\t\t\tif (adapter->coex_tx_win_size)\n\t\t\t\tpriv->add_ba_param.tx_win_size =\n\t\t\t\t\tadapter->coex_tx_win_size;\n\t\t}\n\n\t\tif (tx_win_size != priv->add_ba_param.tx_win_size) {\n\t\t\tif (!priv->media_connected)\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < MAX_NUM_TID; j++)\n\t\t\t\tmwifiex_send_delba_txbastream_tbl(priv, j);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}