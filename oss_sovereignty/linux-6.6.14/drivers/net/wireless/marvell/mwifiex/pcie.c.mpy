{
  "module_name": "pcie.c",
  "hash_id": "d06e9aef3b369bcb38cd311959e8e8d6f45784dab1a7dac80e6126128daadaca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/pcie.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n#include <linux/firmware.h>\n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"pcie.h\"\n#include \"pcie_quirks.h\"\n\n#define PCIE_VERSION\t\"1.0\"\n#define DRV_NAME        \"Marvell mwifiex PCIe\"\n\nstatic struct mwifiex_if_ops pcie_ops;\n\nstatic const struct mwifiex_pcie_card_reg mwifiex_reg_8766 = {\n\t.cmd_addr_lo = PCIE_SCRATCH_0_REG,\n\t.cmd_addr_hi = PCIE_SCRATCH_1_REG,\n\t.cmd_size = PCIE_SCRATCH_2_REG,\n\t.fw_status = PCIE_SCRATCH_3_REG,\n\t.cmdrsp_addr_lo = PCIE_SCRATCH_4_REG,\n\t.cmdrsp_addr_hi = PCIE_SCRATCH_5_REG,\n\t.tx_rdptr = PCIE_SCRATCH_6_REG,\n\t.tx_wrptr = PCIE_SCRATCH_7_REG,\n\t.rx_rdptr = PCIE_SCRATCH_8_REG,\n\t.rx_wrptr = PCIE_SCRATCH_9_REG,\n\t.evt_rdptr = PCIE_SCRATCH_10_REG,\n\t.evt_wrptr = PCIE_SCRATCH_11_REG,\n\t.drv_rdy = PCIE_SCRATCH_12_REG,\n\t.tx_start_ptr = 0,\n\t.tx_mask = MWIFIEX_TXBD_MASK,\n\t.tx_wrap_mask = 0,\n\t.rx_mask = MWIFIEX_RXBD_MASK,\n\t.rx_wrap_mask = 0,\n\t.tx_rollover_ind = MWIFIEX_BD_FLAG_ROLLOVER_IND,\n\t.rx_rollover_ind = MWIFIEX_BD_FLAG_ROLLOVER_IND,\n\t.evt_rollover_ind = MWIFIEX_BD_FLAG_ROLLOVER_IND,\n\t.ring_flag_sop = 0,\n\t.ring_flag_eop = 0,\n\t.ring_flag_xs_sop = 0,\n\t.ring_flag_xs_eop = 0,\n\t.ring_tx_start_ptr = 0,\n\t.pfu_enabled = 0,\n\t.sleep_cookie = 1,\n\t.msix_support = 0,\n};\n\nstatic const struct mwifiex_pcie_card_reg mwifiex_reg_8897 = {\n\t.cmd_addr_lo = PCIE_SCRATCH_0_REG,\n\t.cmd_addr_hi = PCIE_SCRATCH_1_REG,\n\t.cmd_size = PCIE_SCRATCH_2_REG,\n\t.fw_status = PCIE_SCRATCH_3_REG,\n\t.cmdrsp_addr_lo = PCIE_SCRATCH_4_REG,\n\t.cmdrsp_addr_hi = PCIE_SCRATCH_5_REG,\n\t.tx_rdptr = PCIE_RD_DATA_PTR_Q0_Q1,\n\t.tx_wrptr = PCIE_WR_DATA_PTR_Q0_Q1,\n\t.rx_rdptr = PCIE_WR_DATA_PTR_Q0_Q1,\n\t.rx_wrptr = PCIE_RD_DATA_PTR_Q0_Q1,\n\t.evt_rdptr = PCIE_SCRATCH_10_REG,\n\t.evt_wrptr = PCIE_SCRATCH_11_REG,\n\t.drv_rdy = PCIE_SCRATCH_12_REG,\n\t.tx_start_ptr = 16,\n\t.tx_mask = 0x03FF0000,\n\t.tx_wrap_mask = 0x07FF0000,\n\t.rx_mask = 0x000003FF,\n\t.rx_wrap_mask = 0x000007FF,\n\t.tx_rollover_ind = MWIFIEX_BD_FLAG_TX_ROLLOVER_IND,\n\t.rx_rollover_ind = MWIFIEX_BD_FLAG_RX_ROLLOVER_IND,\n\t.evt_rollover_ind = MWIFIEX_BD_FLAG_EVT_ROLLOVER_IND,\n\t.ring_flag_sop = MWIFIEX_BD_FLAG_SOP,\n\t.ring_flag_eop = MWIFIEX_BD_FLAG_EOP,\n\t.ring_flag_xs_sop = MWIFIEX_BD_FLAG_XS_SOP,\n\t.ring_flag_xs_eop = MWIFIEX_BD_FLAG_XS_EOP,\n\t.ring_tx_start_ptr = MWIFIEX_BD_FLAG_TX_START_PTR,\n\t.pfu_enabled = 1,\n\t.sleep_cookie = 0,\n\t.fw_dump_ctrl = PCIE_SCRATCH_13_REG,\n\t.fw_dump_start = PCIE_SCRATCH_14_REG,\n\t.fw_dump_end = 0xcff,\n\t.fw_dump_host_ready = 0xee,\n\t.fw_dump_read_done = 0xfe,\n\t.msix_support = 0,\n};\n\nstatic const struct mwifiex_pcie_card_reg mwifiex_reg_8997 = {\n\t.cmd_addr_lo = PCIE_SCRATCH_0_REG,\n\t.cmd_addr_hi = PCIE_SCRATCH_1_REG,\n\t.cmd_size = PCIE_SCRATCH_2_REG,\n\t.fw_status = PCIE_SCRATCH_3_REG,\n\t.cmdrsp_addr_lo = PCIE_SCRATCH_4_REG,\n\t.cmdrsp_addr_hi = PCIE_SCRATCH_5_REG,\n\t.tx_rdptr = 0xC1A4,\n\t.tx_wrptr = 0xC174,\n\t.rx_rdptr = 0xC174,\n\t.rx_wrptr = 0xC1A4,\n\t.evt_rdptr = PCIE_SCRATCH_10_REG,\n\t.evt_wrptr = PCIE_SCRATCH_11_REG,\n\t.drv_rdy = PCIE_SCRATCH_12_REG,\n\t.tx_start_ptr = 16,\n\t.tx_mask = 0x0FFF0000,\n\t.tx_wrap_mask = 0x1FFF0000,\n\t.rx_mask = 0x00000FFF,\n\t.rx_wrap_mask = 0x00001FFF,\n\t.tx_rollover_ind = BIT(28),\n\t.rx_rollover_ind = BIT(12),\n\t.evt_rollover_ind = MWIFIEX_BD_FLAG_EVT_ROLLOVER_IND,\n\t.ring_flag_sop = MWIFIEX_BD_FLAG_SOP,\n\t.ring_flag_eop = MWIFIEX_BD_FLAG_EOP,\n\t.ring_flag_xs_sop = MWIFIEX_BD_FLAG_XS_SOP,\n\t.ring_flag_xs_eop = MWIFIEX_BD_FLAG_XS_EOP,\n\t.ring_tx_start_ptr = MWIFIEX_BD_FLAG_TX_START_PTR,\n\t.pfu_enabled = 1,\n\t.sleep_cookie = 0,\n\t.fw_dump_ctrl = PCIE_SCRATCH_13_REG,\n\t.fw_dump_start = PCIE_SCRATCH_14_REG,\n\t.fw_dump_end = 0xcff,\n\t.fw_dump_host_ready = 0xcc,\n\t.fw_dump_read_done = 0xdd,\n\t.msix_support = 0,\n};\n\nstatic struct memory_type_mapping mem_type_mapping_tbl_w8897[] = {\n\t{\"ITCM\", NULL, 0, 0xF0},\n\t{\"DTCM\", NULL, 0, 0xF1},\n\t{\"SQRAM\", NULL, 0, 0xF2},\n\t{\"IRAM\", NULL, 0, 0xF3},\n\t{\"APU\", NULL, 0, 0xF4},\n\t{\"CIU\", NULL, 0, 0xF5},\n\t{\"ICU\", NULL, 0, 0xF6},\n\t{\"MAC\", NULL, 0, 0xF7},\n};\n\nstatic struct memory_type_mapping mem_type_mapping_tbl_w8997[] = {\n\t{\"DUMP\", NULL, 0, 0xDD},\n};\n\nstatic const struct mwifiex_pcie_device mwifiex_pcie8766 = {\n\t.reg            = &mwifiex_reg_8766,\n\t.blksz_fw_dl = MWIFIEX_PCIE_BLOCK_SIZE_FW_DNLD,\n\t.tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K,\n\t.can_dump_fw = false,\n\t.can_ext_scan = true,\n};\n\nstatic const struct mwifiex_pcie_device mwifiex_pcie8897 = {\n\t.reg            = &mwifiex_reg_8897,\n\t.blksz_fw_dl = MWIFIEX_PCIE_BLOCK_SIZE_FW_DNLD,\n\t.tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_4K,\n\t.can_dump_fw = true,\n\t.mem_type_mapping_tbl = mem_type_mapping_tbl_w8897,\n\t.num_mem_types = ARRAY_SIZE(mem_type_mapping_tbl_w8897),\n\t.can_ext_scan = true,\n};\n\nstatic const struct mwifiex_pcie_device mwifiex_pcie8997 = {\n\t.reg            = &mwifiex_reg_8997,\n\t.blksz_fw_dl = MWIFIEX_PCIE_BLOCK_SIZE_FW_DNLD,\n\t.tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_4K,\n\t.can_dump_fw = true,\n\t.mem_type_mapping_tbl = mem_type_mapping_tbl_w8997,\n\t.num_mem_types = ARRAY_SIZE(mem_type_mapping_tbl_w8997),\n\t.can_ext_scan = true,\n};\n\nstatic const struct of_device_id mwifiex_pcie_of_match_table[] __maybe_unused = {\n\t{ .compatible = \"pci11ab,2b42\" },\n\t{ .compatible = \"pci1b4b,2b42\" },\n\t{ }\n};\n\nstatic int mwifiex_pcie_probe_of(struct device *dev)\n{\n\tif (!of_match_node(mwifiex_pcie_of_match_table, dev->of_node)) {\n\t\tdev_err(dev, \"required compatible string missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void mwifiex_pcie_work(struct work_struct *work);\nstatic int mwifiex_pcie_delete_rxbd_ring(struct mwifiex_adapter *adapter);\nstatic int mwifiex_pcie_delete_evtbd_ring(struct mwifiex_adapter *adapter);\n\nstatic int\nmwifiex_map_pci_memory(struct mwifiex_adapter *adapter, struct sk_buff *skb,\n\t\t       size_t size, int flags)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_dma_mapping mapping;\n\n\tmapping.addr = dma_map_single(&card->dev->dev, skb->data, size, flags);\n\tif (dma_mapping_error(&card->dev->dev, mapping.addr)) {\n\t\tmwifiex_dbg(adapter, ERROR, \"failed to map pci memory!\\n\");\n\t\treturn -1;\n\t}\n\tmapping.len = size;\n\tmwifiex_store_mapping(skb, &mapping);\n\treturn 0;\n}\n\nstatic void mwifiex_unmap_pci_memory(struct mwifiex_adapter *adapter,\n\t\t\t\t     struct sk_buff *skb, int flags)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_dma_mapping mapping;\n\n\tmwifiex_get_mapping(skb, &mapping);\n\tdma_unmap_single(&card->dev->dev, mapping.addr, mapping.len, flags);\n}\n\n \nstatic int mwifiex_write_reg(struct mwifiex_adapter *adapter, int reg, u32 data)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tiowrite32(data, card->pci_mmap1 + reg);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_read_reg(struct mwifiex_adapter *adapter, int reg, u32 *data)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\t*data = ioread32(card->pci_mmap1 + reg);\n\tif (*data == 0xffffffff)\n\t\treturn 0xffffffff;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_read_reg_byte(struct mwifiex_adapter *adapter,\n\t\t\t\t int reg, u8 *data)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\t*data = ioread8(card->pci_mmap1 + reg);\n\n\treturn 0;\n}\n\n \nstatic bool mwifiex_pcie_ok_to_access_hw(struct mwifiex_adapter *adapter)\n{\n\tu32 cookie_value;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (!reg->sleep_cookie)\n\t\treturn true;\n\n\tif (card->sleep_cookie_vbase) {\n\t\tcookie_value = get_unaligned_le32(card->sleep_cookie_vbase);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: ACCESS_HW: sleep cookie=0x%x\\n\",\n\t\t\t    cookie_value);\n\t\tif (cookie_value == FW_AWAKE_COOKIE)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int mwifiex_pcie_suspend(struct device *dev)\n{\n\tstruct mwifiex_adapter *adapter;\n\tstruct pcie_service_card *card = dev_get_drvdata(dev);\n\n\n\t \n\twait_for_completion(&card->fw_done);\n\n\tadapter = card->adapter;\n\tif (!adapter) {\n\t\tdev_err(dev, \"adapter is not valid\\n\");\n\t\treturn 0;\n\t}\n\n\tmwifiex_enable_wake(adapter);\n\n\t \n\tif (!mwifiex_enable_hs(adapter)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"cmd: failed to suspend\\n\");\n\t\tclear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);\n\t\tmwifiex_disable_wake(adapter);\n\t\treturn -EFAULT;\n\t}\n\n\tflush_workqueue(adapter->workqueue);\n\n\t \n\tset_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);\n\tclear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_resume(struct device *dev)\n{\n\tstruct mwifiex_adapter *adapter;\n\tstruct pcie_service_card *card = dev_get_drvdata(dev);\n\n\n\tif (!card->adapter) {\n\t\tdev_err(dev, \"adapter structure is not valid\\n\");\n\t\treturn 0;\n\t}\n\n\tadapter = card->adapter;\n\n\tif (!test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"Device already resumed\\n\");\n\t\treturn 0;\n\t}\n\n\tclear_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);\n\n\tmwifiex_cancel_hs(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA),\n\t\t\t  MWIFIEX_ASYNC_CMD);\n\tmwifiex_disable_wake(adapter);\n\n\treturn 0;\n}\n#endif\n\n \nstatic int mwifiex_pcie_probe(struct pci_dev *pdev,\n\t\t\t\t\tconst struct pci_device_id *ent)\n{\n\tstruct pcie_service_card *card;\n\tint ret;\n\n\tpr_debug(\"info: vendor=0x%4.04X device=0x%4.04X rev=%d\\n\",\n\t\t pdev->vendor, pdev->device, pdev->revision);\n\n\tcard = devm_kzalloc(&pdev->dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&card->fw_done);\n\n\tcard->dev = pdev;\n\n\tif (ent->driver_data) {\n\t\tstruct mwifiex_pcie_device *data = (void *)ent->driver_data;\n\t\tcard->pcie.reg = data->reg;\n\t\tcard->pcie.blksz_fw_dl = data->blksz_fw_dl;\n\t\tcard->pcie.tx_buf_size = data->tx_buf_size;\n\t\tcard->pcie.can_dump_fw = data->can_dump_fw;\n\t\tcard->pcie.mem_type_mapping_tbl = data->mem_type_mapping_tbl;\n\t\tcard->pcie.num_mem_types = data->num_mem_types;\n\t\tcard->pcie.can_ext_scan = data->can_ext_scan;\n\t\tINIT_WORK(&card->work, mwifiex_pcie_work);\n\t}\n\n\t \n\tif (pdev->dev.of_node) {\n\t\tret = mwifiex_pcie_probe_of(&pdev->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tmwifiex_initialize_quirks(card);\n\n\tif (mwifiex_add_card(card, &card->fw_done, &pcie_ops,\n\t\t\t     MWIFIEX_PCIE, &pdev->dev)) {\n\t\tpr_err(\"%s failed\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void mwifiex_pcie_remove(struct pci_dev *pdev)\n{\n\tstruct pcie_service_card *card;\n\tstruct mwifiex_adapter *adapter;\n\tstruct mwifiex_private *priv;\n\tconst struct mwifiex_pcie_card_reg *reg;\n\tu32 fw_status;\n\n\tcard = pci_get_drvdata(pdev);\n\n\twait_for_completion(&card->fw_done);\n\n\tadapter = card->adapter;\n\tif (!adapter || !adapter->priv_num)\n\t\treturn;\n\n\treg = card->pcie.reg;\n\tif (reg)\n\t\tmwifiex_read_reg(adapter, reg->fw_status, &fw_status);\n\telse\n\t\tfw_status = -1;\n\n\tif (fw_status == FIRMWARE_READY_PCIE && !adapter->mfg_mode) {\n\t\tmwifiex_deauthenticate_all(adapter);\n\n\t\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\n\t\tmwifiex_disable_auto_ds(priv);\n\n\t\tmwifiex_init_shutdown_fw(priv, MWIFIEX_FUNC_SHUTDOWN);\n\t}\n\n\tmwifiex_remove_card(adapter);\n}\n\nstatic void mwifiex_pcie_shutdown(struct pci_dev *pdev)\n{\n\tmwifiex_pcie_remove(pdev);\n\n\treturn;\n}\n\nstatic void mwifiex_pcie_coredump(struct device *dev)\n{\n\tstruct pci_dev *pdev;\n\tstruct pcie_service_card *card;\n\n\tpdev = container_of(dev, struct pci_dev, dev);\n\tcard = pci_get_drvdata(pdev);\n\n\tif (!test_and_set_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP,\n\t\t\t      &card->work_flags))\n\t\tschedule_work(&card->work);\n}\n\nstatic const struct pci_device_id mwifiex_ids[] = {\n\t{\n\t\tPCIE_VENDOR_ID_MARVELL, PCIE_DEVICE_ID_MARVELL_88W8766P,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\t.driver_data = (unsigned long)&mwifiex_pcie8766,\n\t},\n\t{\n\t\tPCIE_VENDOR_ID_MARVELL, PCIE_DEVICE_ID_MARVELL_88W8897,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\t.driver_data = (unsigned long)&mwifiex_pcie8897,\n\t},\n\t{\n\t\tPCIE_VENDOR_ID_MARVELL, PCIE_DEVICE_ID_MARVELL_88W8997,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\t.driver_data = (unsigned long)&mwifiex_pcie8997,\n\t},\n\t{\n\t\tPCIE_VENDOR_ID_V2_MARVELL, PCIE_DEVICE_ID_MARVELL_88W8997,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\t.driver_data = (unsigned long)&mwifiex_pcie8997,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(pci, mwifiex_ids);\n\n \nstatic void mwifiex_pcie_reset_prepare(struct pci_dev *pdev)\n{\n\tstruct pcie_service_card *card = pci_get_drvdata(pdev);\n\tstruct mwifiex_adapter *adapter = card->adapter;\n\n\tif (!adapter) {\n\t\tdev_err(&pdev->dev, \"%s: adapter structure is not valid\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"%s: vendor=0x%4.04x device=0x%4.04x rev=%d Pre-FLR\\n\",\n\t\t    __func__, pdev->vendor, pdev->device, pdev->revision);\n\n\tmwifiex_shutdown_sw(adapter);\n\tclear_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP, &card->work_flags);\n\tclear_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &card->work_flags);\n\n\t \n\tif (card->quirks & QUIRK_FW_RST_D3COLD)\n\t\tmwifiex_pcie_reset_d3cold_quirk(pdev);\n\n\tmwifiex_dbg(adapter, INFO, \"%s, successful\\n\", __func__);\n\n\tcard->pci_reset_ongoing = true;\n}\n\n \nstatic void mwifiex_pcie_reset_done(struct pci_dev *pdev)\n{\n\tstruct pcie_service_card *card = pci_get_drvdata(pdev);\n\tstruct mwifiex_adapter *adapter = card->adapter;\n\tint ret;\n\n\tif (!adapter) {\n\t\tdev_err(&pdev->dev, \"%s: adapter structure is not valid\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"%s: vendor=0x%4.04x device=0x%4.04x rev=%d Post-FLR\\n\",\n\t\t    __func__, pdev->vendor, pdev->device, pdev->revision);\n\n\tret = mwifiex_reinit_sw(adapter);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"reinit failed: %d\\n\", ret);\n\telse\n\t\tmwifiex_dbg(adapter, INFO, \"%s, successful\\n\", __func__);\n\n\tcard->pci_reset_ongoing = false;\n}\n\nstatic const struct pci_error_handlers mwifiex_pcie_err_handler = {\n\t.reset_prepare\t\t= mwifiex_pcie_reset_prepare,\n\t.reset_done\t\t= mwifiex_pcie_reset_done,\n};\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic SIMPLE_DEV_PM_OPS(mwifiex_pcie_pm_ops, mwifiex_pcie_suspend,\n\t\t\t\tmwifiex_pcie_resume);\n#endif\n\n \nstatic struct pci_driver mwifiex_pcie = {\n\t.name     = \"mwifiex_pcie\",\n\t.id_table = mwifiex_ids,\n\t.probe    = mwifiex_pcie_probe,\n\t.remove   = mwifiex_pcie_remove,\n\t.driver   = {\n\t\t.coredump = mwifiex_pcie_coredump,\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm = &mwifiex_pcie_pm_ops,\n#endif\n\t},\n\t.shutdown = mwifiex_pcie_shutdown,\n\t.err_handler = &mwifiex_pcie_err_handler,\n};\n\n \nstatic void mwifiex_pcie_dev_wakeup_delay(struct mwifiex_adapter *adapter)\n{\n\tint i = 0;\n\n\twhile (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\ti++;\n\t\tusleep_range(10, 20);\n\t\t \n\t\tif (i == 5000)\n\t\t\tbreak;\n\t}\n\n\treturn;\n}\n\nstatic void mwifiex_delay_for_sleep_cookie(struct mwifiex_adapter *adapter,\n\t\t\t\t\t   u32 max_delay_loop_cnt)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tu8 *buffer;\n\tu32 sleep_cookie, count;\n\tstruct sk_buff *cmdrsp = card->cmdrsp_buf;\n\n\tfor (count = 0; count < max_delay_loop_cnt; count++) {\n\t\tdma_sync_single_for_cpu(&card->dev->dev,\n\t\t\t\t\tMWIFIEX_SKB_DMA_ADDR(cmdrsp),\n\t\t\t\t\tsizeof(sleep_cookie), DMA_FROM_DEVICE);\n\t\tbuffer = cmdrsp->data;\n\t\tsleep_cookie = get_unaligned_le32(buffer);\n\n\t\tif (sleep_cookie == MWIFIEX_DEF_SLEEP_COOKIE) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"sleep cookie found at count %d\\n\", count);\n\t\t\tbreak;\n\t\t}\n\t\tdma_sync_single_for_device(&card->dev->dev,\n\t\t\t\t\t   MWIFIEX_SKB_DMA_ADDR(cmdrsp),\n\t\t\t\t\t   sizeof(sleep_cookie),\n\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\tusleep_range(20, 30);\n\t}\n\n\tif (count >= max_delay_loop_cnt)\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"max count reached while accessing sleep cookie\\n\");\n}\n\n#define N_WAKEUP_TRIES_SHORT_INTERVAL 15\n#define N_WAKEUP_TRIES_LONG_INTERVAL 35\n\n \nstatic int mwifiex_pm_wakeup_card(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint retval __maybe_unused;\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"event: Wakeup device...\\n\");\n\n\tif (reg->sleep_cookie)\n\t\tmwifiex_pcie_dev_wakeup_delay(adapter);\n\n\t \n\tif (read_poll_timeout(mwifiex_write_reg, retval,\n\t\t\t      READ_ONCE(adapter->int_status) != 0,\n\t\t\t      500, 500 * N_WAKEUP_TRIES_SHORT_INTERVAL,\n\t\t\t      false,\n\t\t\t      adapter, reg->fw_status, FIRMWARE_READY_PCIE)) {\n\t\tif (read_poll_timeout(mwifiex_write_reg, retval,\n\t\t\t\t      READ_ONCE(adapter->int_status) != 0,\n\t\t\t\t      10000, 10000 * N_WAKEUP_TRIES_LONG_INTERVAL,\n\t\t\t\t      false,\n\t\t\t\t      adapter, reg->fw_status, FIRMWARE_READY_PCIE)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Firmware didn't wake up\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (reg->sleep_cookie) {\n\t\tmwifiex_pcie_dev_wakeup_delay(adapter);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"PCIE wakeup: Setting PS_STATE_AWAKE\\n\");\n\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pm_wakeup_card_complete(struct mwifiex_adapter *adapter)\n{\n\tmwifiex_dbg(adapter, CMD,\n\t\t    \"cmd: Wakeup device completed\\n\");\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_disable_host_int(struct mwifiex_adapter *adapter)\n{\n\tif (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\tif (mwifiex_write_reg(adapter, PCIE_HOST_INT_MASK,\n\t\t\t\t      0x00000000)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Disable host interrupt failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tatomic_set(&adapter->tx_hw_pending, 0);\n\treturn 0;\n}\n\nstatic void mwifiex_pcie_disable_host_int_noerr(struct mwifiex_adapter *adapter)\n{\n\tWARN_ON(mwifiex_pcie_disable_host_int(adapter));\n}\n\n \nstatic int mwifiex_pcie_enable_host_int(struct mwifiex_adapter *adapter)\n{\n\tif (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\t \n\t\tif (mwifiex_write_reg(adapter, PCIE_HOST_INT_MASK,\n\t\t\t\t      HOST_INTR_MASK)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Enable host interrupt failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_init_txq_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_TXRX_BD; i++) {\n\t\tcard->tx_buf_list[i] = NULL;\n\t\tif (reg->pfu_enabled) {\n\t\t\tcard->txbd_ring[i] = (void *)card->txbd_ring_vbase +\n\t\t\t\t\t     (sizeof(*desc2) * i);\n\t\t\tdesc2 = card->txbd_ring[i];\n\t\t\tmemset(desc2, 0, sizeof(*desc2));\n\t\t} else {\n\t\t\tcard->txbd_ring[i] = (void *)card->txbd_ring_vbase +\n\t\t\t\t\t     (sizeof(*desc) * i);\n\t\t\tdesc = card->txbd_ring[i];\n\t\t\tmemset(desc, 0, sizeof(*desc));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_init_rxq_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct sk_buff *skb;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tdma_addr_t buf_pa;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_TXRX_BD; i++) {\n\t\t \n\t\tskb = mwifiex_alloc_dma_align_buf(MWIFIEX_RX_DATA_BUF_SIZE,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for RX ring.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb,\n\t\t\t\t\t   MWIFIEX_RX_DATA_BUF_SIZE,\n\t\t\t\t\t   DMA_FROM_DEVICE)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: RX ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\n\t\tcard->rx_buf_list[i] = skb;\n\t\tif (reg->pfu_enabled) {\n\t\t\tcard->rxbd_ring[i] = (void *)card->rxbd_ring_vbase +\n\t\t\t\t\t     (sizeof(*desc2) * i);\n\t\t\tdesc2 = card->rxbd_ring[i];\n\t\t\tdesc2->paddr = buf_pa;\n\t\t\tdesc2->len = (u16)skb->len;\n\t\t\tdesc2->frag_len = (u16)skb->len;\n\t\t\tdesc2->flags = reg->ring_flag_eop | reg->ring_flag_sop;\n\t\t\tdesc2->offset = 0;\n\t\t} else {\n\t\t\tcard->rxbd_ring[i] = (void *)(card->rxbd_ring_vbase +\n\t\t\t\t\t     (sizeof(*desc) * i));\n\t\t\tdesc = card->rxbd_ring[i];\n\t\t\tdesc->paddr = buf_pa;\n\t\t\tdesc->len = (u16)skb->len;\n\t\t\tdesc->flags = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\t \n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   DMA_FROM_DEVICE)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void mwifiex_cleanup_txq_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct sk_buff *skb;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_TXRX_BD; i++) {\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->txbd_ring[i];\n\t\t\tif (card->tx_buf_list[i]) {\n\t\t\t\tskb = card->tx_buf_list[i];\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t}\n\t\t\tmemset(desc2, 0, sizeof(*desc2));\n\t\t} else {\n\t\t\tdesc = card->txbd_ring[i];\n\t\t\tif (card->tx_buf_list[i]) {\n\t\t\t\tskb = card->tx_buf_list[i];\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t}\n\t\t\tmemset(desc, 0, sizeof(*desc));\n\t\t}\n\t\tcard->tx_buf_list[i] = NULL;\n\t}\n\n\tatomic_set(&adapter->tx_hw_pending, 0);\n\treturn;\n}\n\n \nstatic void mwifiex_cleanup_rxq_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_TXRX_BD; i++) {\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->rxbd_ring[i];\n\t\t\tif (card->rx_buf_list[i]) {\n\t\t\t\tskb = card->rx_buf_list[i];\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t}\n\t\t\tmemset(desc2, 0, sizeof(*desc2));\n\t\t} else {\n\t\t\tdesc = card->rxbd_ring[i];\n\t\t\tif (card->rx_buf_list[i]) {\n\t\t\t\tskb = card->rx_buf_list[i];\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t}\n\t\t\tmemset(desc, 0, sizeof(*desc));\n\t\t}\n\t\tcard->rx_buf_list[i] = NULL;\n\t}\n\n\treturn;\n}\n\n \nstatic void mwifiex_cleanup_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\tdesc = card->evtbd_ring[i];\n\t\tif (card->evt_buf_list[i]) {\n\t\t\tskb = card->evt_buf_list[i];\n\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t\tcard->evt_buf_list[i] = NULL;\n\t\tmemset(desc, 0, sizeof(*desc));\n\t}\n\n\treturn;\n}\n\n \nstatic int mwifiex_pcie_create_txbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\t \n\tcard->txbd_wrptr = 0;\n\n\tif (reg->pfu_enabled)\n\t\tcard->txbd_rdptr = 0;\n\telse\n\t\tcard->txbd_rdptr |= reg->tx_rollover_ind;\n\n\t \n\tif (reg->pfu_enabled)\n\t\tcard->txbd_ring_size = sizeof(struct mwifiex_pfu_buf_desc) *\n\t\t\t\t       MWIFIEX_MAX_TXRX_BD;\n\telse\n\t\tcard->txbd_ring_size = sizeof(struct mwifiex_pcie_buf_desc) *\n\t\t\t\t       MWIFIEX_MAX_TXRX_BD;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: txbd_ring: Allocating %d bytes\\n\",\n\t\t    card->txbd_ring_size);\n\tcard->txbd_ring_vbase = dma_alloc_coherent(&card->dev->dev,\n\t\t\t\t\t\t   card->txbd_ring_size,\n\t\t\t\t\t\t   &card->txbd_ring_pbase,\n\t\t\t\t\t\t   GFP_KERNEL);\n\tif (!card->txbd_ring_vbase) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"allocate coherent memory (%d bytes) failed!\\n\",\n\t\t\t    card->txbd_ring_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"info: txbd_ring - base: %p, pbase: %#x:%x, len: %#x\\n\",\n\t\t    card->txbd_ring_vbase, (u32)card->txbd_ring_pbase,\n\t\t    (u32)((u64)card->txbd_ring_pbase >> 32),\n\t\t    card->txbd_ring_size);\n\n\treturn mwifiex_init_txq_ring(adapter);\n}\n\nstatic int mwifiex_pcie_delete_txbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tmwifiex_cleanup_txq_ring(adapter);\n\n\tif (card->txbd_ring_vbase)\n\t\tdma_free_coherent(&card->dev->dev, card->txbd_ring_size,\n\t\t\t\t  card->txbd_ring_vbase,\n\t\t\t\t  card->txbd_ring_pbase);\n\tcard->txbd_ring_size = 0;\n\tcard->txbd_wrptr = 0;\n\tcard->txbd_rdptr = 0 | reg->tx_rollover_ind;\n\tcard->txbd_ring_vbase = NULL;\n\tcard->txbd_ring_pbase = 0;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_create_rxbd_ring(struct mwifiex_adapter *adapter)\n{\n\tint ret;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\t \n\tcard->rxbd_wrptr = 0;\n\tcard->rxbd_rdptr = reg->rx_rollover_ind;\n\n\tif (reg->pfu_enabled)\n\t\tcard->rxbd_ring_size = sizeof(struct mwifiex_pfu_buf_desc) *\n\t\t\t\t       MWIFIEX_MAX_TXRX_BD;\n\telse\n\t\tcard->rxbd_ring_size = sizeof(struct mwifiex_pcie_buf_desc) *\n\t\t\t\t       MWIFIEX_MAX_TXRX_BD;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: rxbd_ring: Allocating %d bytes\\n\",\n\t\t    card->rxbd_ring_size);\n\tcard->rxbd_ring_vbase = dma_alloc_coherent(&card->dev->dev,\n\t\t\t\t\t\t   card->rxbd_ring_size,\n\t\t\t\t\t\t   &card->rxbd_ring_pbase,\n\t\t\t\t\t\t   GFP_KERNEL);\n\tif (!card->rxbd_ring_vbase) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"allocate coherent memory (%d bytes) failed!\\n\",\n\t\t\t    card->rxbd_ring_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"info: rxbd_ring - base: %p, pbase: %#x:%x, len: %#x\\n\",\n\t\t    card->rxbd_ring_vbase, (u32)card->rxbd_ring_pbase,\n\t\t    (u32)((u64)card->rxbd_ring_pbase >> 32),\n\t\t    card->rxbd_ring_size);\n\n\tret = mwifiex_init_rxq_ring(adapter);\n\tif (ret)\n\t\tmwifiex_pcie_delete_rxbd_ring(adapter);\n\treturn ret;\n}\n\n \nstatic int mwifiex_pcie_delete_rxbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tmwifiex_cleanup_rxq_ring(adapter);\n\n\tif (card->rxbd_ring_vbase)\n\t\tdma_free_coherent(&card->dev->dev, card->rxbd_ring_size,\n\t\t\t\t  card->rxbd_ring_vbase,\n\t\t\t\t  card->rxbd_ring_pbase);\n\tcard->rxbd_ring_size = 0;\n\tcard->rxbd_wrptr = 0;\n\tcard->rxbd_rdptr = 0 | reg->rx_rollover_ind;\n\tcard->rxbd_ring_vbase = NULL;\n\tcard->rxbd_ring_pbase = 0;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_create_evtbd_ring(struct mwifiex_adapter *adapter)\n{\n\tint ret;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\t \n\tcard->evtbd_wrptr = 0;\n\tcard->evtbd_rdptr = reg->evt_rollover_ind;\n\n\tcard->evtbd_ring_size = sizeof(struct mwifiex_evt_buf_desc) *\n\t\t\t\tMWIFIEX_MAX_EVT_BD;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: evtbd_ring: Allocating %d bytes\\n\",\n\t\t    card->evtbd_ring_size);\n\tcard->evtbd_ring_vbase = dma_alloc_coherent(&card->dev->dev,\n\t\t\t\t\t\t    card->evtbd_ring_size,\n\t\t\t\t\t\t    &card->evtbd_ring_pbase,\n\t\t\t\t\t\t    GFP_KERNEL);\n\tif (!card->evtbd_ring_vbase) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"allocate coherent memory (%d bytes) failed!\\n\",\n\t\t\t    card->evtbd_ring_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"info: CMDRSP/EVT bd_ring - base: %p pbase: %#x:%x len: %#x\\n\",\n\t\t    card->evtbd_ring_vbase, (u32)card->evtbd_ring_pbase,\n\t\t    (u32)((u64)card->evtbd_ring_pbase >> 32),\n\t\t    card->evtbd_ring_size);\n\n\tret = mwifiex_pcie_init_evt_ring(adapter);\n\tif (ret)\n\t\tmwifiex_pcie_delete_evtbd_ring(adapter);\n\treturn ret;\n}\n\n \nstatic int mwifiex_pcie_delete_evtbd_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tmwifiex_cleanup_evt_ring(adapter);\n\n\tif (card->evtbd_ring_vbase)\n\t\tdma_free_coherent(&card->dev->dev, card->evtbd_ring_size,\n\t\t\t\t  card->evtbd_ring_vbase,\n\t\t\t\t  card->evtbd_ring_pbase);\n\tcard->evtbd_wrptr = 0;\n\tcard->evtbd_rdptr = 0 | reg->evt_rollover_ind;\n\tcard->evtbd_ring_size = 0;\n\tcard->evtbd_ring_vbase = NULL;\n\tcard->evtbd_ring_pbase = 0;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\n\t \n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   DMA_FROM_DEVICE)) {\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\tcard->cmdrsp_buf = skb;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_delete_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card;\n\n\tif (!adapter)\n\t\treturn 0;\n\n\tcard = adapter->card;\n\n\tif (card && card->cmdrsp_buf) {\n\t\tmwifiex_unmap_pci_memory(adapter, card->cmdrsp_buf,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(card->cmdrsp_buf);\n\t\tcard->cmdrsp_buf = NULL;\n\t}\n\n\tif (card && card->cmd_buf) {\n\t\tmwifiex_unmap_pci_memory(adapter, card->cmd_buf,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\tdev_kfree_skb_any(card->cmd_buf);\n\t\tcard->cmd_buf = NULL;\n\t}\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_alloc_sleep_cookie_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tu32 *cookie;\n\n\tcard->sleep_cookie_vbase = dma_alloc_coherent(&card->dev->dev,\n\t\t\t\t\t\t      sizeof(u32),\n\t\t\t\t\t\t      &card->sleep_cookie_pbase,\n\t\t\t\t\t\t      GFP_KERNEL);\n\tif (!card->sleep_cookie_vbase) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"dma_alloc_coherent failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tcookie = (u32 *)card->sleep_cookie_vbase;\n\t \n\t*cookie = FW_AWAKE_COOKIE;\n\n\tmwifiex_dbg(adapter, INFO, \"alloc_scook: sleep cookie=0x%x\\n\", *cookie);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_delete_sleep_cookie_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card;\n\n\tif (!adapter)\n\t\treturn 0;\n\n\tcard = adapter->card;\n\n\tif (card && card->sleep_cookie_vbase) {\n\t\tdma_free_coherent(&card->dev->dev, sizeof(u32),\n\t\t\t\t  card->sleep_cookie_vbase,\n\t\t\t\t  card->sleep_cookie_pbase);\n\t\tcard->sleep_cookie_vbase = NULL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_clean_pcie_ring_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (!mwifiex_pcie_txbd_empty(card, card->txbd_rdptr)) {\n\t\tcard->txbd_flush = 1;\n\t\t \n\t\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t\t      CPU_INTR_DNLD_RDY)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"failed to assert dnld-rdy interrupt.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_send_data_complete(struct mwifiex_adapter *adapter)\n{\n\tstruct sk_buff *skb;\n\tu32 wrdoneidx, rdptr, num_tx_buffs, unmap_count = 0;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\t \n\tif (mwifiex_read_reg(adapter, reg->tx_rdptr, &rdptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"SEND COMP: failed to read reg->tx_rdptr\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"SEND COMP: rdptr_prev=0x%x, rdptr=0x%x\\n\",\n\t\t    card->txbd_rdptr, rdptr);\n\n\tnum_tx_buffs = MWIFIEX_MAX_TXRX_BD << reg->tx_start_ptr;\n\t \n\twhile (((card->txbd_rdptr & reg->tx_mask) !=\n\t\t(rdptr & reg->tx_mask)) ||\n\t       ((card->txbd_rdptr & reg->tx_rollover_ind) !=\n\t\t(rdptr & reg->tx_rollover_ind))) {\n\t\twrdoneidx = (card->txbd_rdptr & reg->tx_mask) >>\n\t\t\t    reg->tx_start_ptr;\n\n\t\tskb = card->tx_buf_list[wrdoneidx];\n\n\t\tif (skb) {\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"SEND COMP: Detach skb %p at txbd_rdidx=%d\\n\",\n\t\t\t\t    skb, wrdoneidx);\n\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\n\t\t\tunmap_count++;\n\n\t\t\tif (card->txbd_flush)\n\t\t\t\tmwifiex_write_data_complete(adapter, skb, 0,\n\t\t\t\t\t\t\t    -1);\n\t\t\telse\n\t\t\t\tmwifiex_write_data_complete(adapter, skb, 0, 0);\n\t\t\tatomic_dec(&adapter->tx_hw_pending);\n\t\t}\n\n\t\tcard->tx_buf_list[wrdoneidx] = NULL;\n\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->txbd_ring[wrdoneidx];\n\t\t\tmemset(desc2, 0, sizeof(*desc2));\n\t\t} else {\n\t\t\tdesc = card->txbd_ring[wrdoneidx];\n\t\t\tmemset(desc, 0, sizeof(*desc));\n\t\t}\n\t\tswitch (card->dev->device) {\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8766P:\n\t\t\tcard->txbd_rdptr++;\n\t\t\tbreak;\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8897:\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8997:\n\t\t\tcard->txbd_rdptr += reg->ring_tx_start_ptr;\n\t\t\tbreak;\n\t\t}\n\n\n\t\tif ((card->txbd_rdptr & reg->tx_mask) == num_tx_buffs)\n\t\t\tcard->txbd_rdptr = ((card->txbd_rdptr &\n\t\t\t\t\t     reg->tx_rollover_ind) ^\n\t\t\t\t\t     reg->tx_rollover_ind);\n\t}\n\n\tif (unmap_count)\n\t\tadapter->data_sent = false;\n\n\tif (card->txbd_flush) {\n\t\tif (mwifiex_pcie_txbd_empty(card, card->txbd_rdptr))\n\t\t\tcard->txbd_flush = 0;\n\t\telse\n\t\t\tmwifiex_clean_pcie_ring_buf(adapter);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_pcie_send_data(struct mwifiex_adapter *adapter, struct sk_buff *skb,\n\t\t       struct mwifiex_tx_param *tx_param)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 wrindx, num_tx_buffs, rx_val;\n\tint ret;\n\tdma_addr_t buf_pa;\n\tstruct mwifiex_pcie_buf_desc *desc = NULL;\n\tstruct mwifiex_pfu_buf_desc *desc2 = NULL;\n\n\tif (!(skb->data && skb->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s(): invalid parameter <%p, %#x>\\n\",\n\t\t\t    __func__, skb->data, skb->len);\n\t\treturn -1;\n\t}\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\tnum_tx_buffs = MWIFIEX_MAX_TXRX_BD << reg->tx_start_ptr;\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"info: SEND DATA: <Rd: %#x, Wr: %#x>\\n\",\n\t\tcard->txbd_rdptr, card->txbd_wrptr);\n\tif (mwifiex_pcie_txbd_not_full(card)) {\n\t\tu8 *payload;\n\n\t\tadapter->data_sent = true;\n\t\tpayload = skb->data;\n\t\tput_unaligned_le16((u16)skb->len, payload + 0);\n\t\tput_unaligned_le16(MWIFIEX_TYPE_DATA, payload + 2);\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb, skb->len,\n\t\t\t\t\t   DMA_TO_DEVICE))\n\t\t\treturn -1;\n\n\t\twrindx = (card->txbd_wrptr & reg->tx_mask) >> reg->tx_start_ptr;\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tcard->tx_buf_list[wrindx] = skb;\n\t\tatomic_inc(&adapter->tx_hw_pending);\n\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->txbd_ring[wrindx];\n\t\t\tdesc2->paddr = buf_pa;\n\t\t\tdesc2->len = (u16)skb->len;\n\t\t\tdesc2->frag_len = (u16)skb->len;\n\t\t\tdesc2->offset = 0;\n\t\t\tdesc2->flags = MWIFIEX_BD_FLAG_FIRST_DESC |\n\t\t\t\t\t MWIFIEX_BD_FLAG_LAST_DESC;\n\t\t} else {\n\t\t\tdesc = card->txbd_ring[wrindx];\n\t\t\tdesc->paddr = buf_pa;\n\t\t\tdesc->len = (u16)skb->len;\n\t\t\tdesc->flags = MWIFIEX_BD_FLAG_FIRST_DESC |\n\t\t\t\t      MWIFIEX_BD_FLAG_LAST_DESC;\n\t\t}\n\n\t\tswitch (card->dev->device) {\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8766P:\n\t\t\tcard->txbd_wrptr++;\n\t\t\tbreak;\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8897:\n\t\tcase PCIE_DEVICE_ID_MARVELL_88W8997:\n\t\t\tcard->txbd_wrptr += reg->ring_tx_start_ptr;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((card->txbd_wrptr & reg->tx_mask) == num_tx_buffs)\n\t\t\tcard->txbd_wrptr = ((card->txbd_wrptr &\n\t\t\t\t\t\treg->tx_rollover_ind) ^\n\t\t\t\t\t\treg->tx_rollover_ind);\n\n\t\trx_val = card->rxbd_rdptr & reg->rx_wrap_mask;\n\t\t \n\t\tif (mwifiex_write_reg(adapter, reg->tx_wrptr,\n\t\t\t\t      card->txbd_wrptr | rx_val)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"SEND DATA: failed to write reg->tx_wrptr\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done_unmap;\n\t\t}\n\n\t\t \n\t\tmwifiex_read_reg(adapter, PCI_VENDOR_ID, &rx_val);\n\n\t\tif ((mwifiex_pcie_txbd_not_full(card)) &&\n\t\t    tx_param->next_pkt_len) {\n\t\t\t \n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"SEND DATA: delay dnld-rdy interrupt.\\n\");\n\t\t\tadapter->data_sent = false;\n\t\t} else {\n\t\t\t \n\t\t\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t\t\t      CPU_INTR_DNLD_RDY)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"SEND DATA: failed to assert dnld-rdy interrupt.\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done_unmap;\n\t\t\t}\n\t\t}\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: SEND DATA: Updated <Rd: %#x, Wr:\\t\"\n\t\t\t    \"%#x> and sent packet to firmware successfully\\n\",\n\t\t\t    card->txbd_rdptr, card->txbd_wrptr);\n\t} else {\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: TX Ring full, can't send packets to fw\\n\");\n\t\tadapter->data_sent = true;\n\t\t \n\t\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t\t      CPU_INTR_DNLD_RDY))\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"SEND DATA: failed to assert door-bell intr\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn -EINPROGRESS;\ndone_unmap:\n\tmwifiex_unmap_pci_memory(adapter, skb, DMA_TO_DEVICE);\n\tcard->tx_buf_list[wrindx] = NULL;\n\tatomic_dec(&adapter->tx_hw_pending);\n\tif (reg->pfu_enabled)\n\t\tmemset(desc2, 0, sizeof(*desc2));\n\telse\n\t\tmemset(desc, 0, sizeof(*desc));\n\n\treturn ret;\n}\n\n \nstatic int mwifiex_pcie_process_recv_data(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 wrptr, rd_index, tx_val;\n\tdma_addr_t buf_pa;\n\tint ret = 0;\n\tstruct sk_buff *skb_tmp = NULL;\n\tstruct mwifiex_pcie_buf_desc *desc;\n\tstruct mwifiex_pfu_buf_desc *desc2;\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\t \n\tif (mwifiex_read_reg(adapter, reg->rx_wrptr, &wrptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"RECV DATA: failed to read reg->rx_wrptr\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\tcard->rxbd_wrptr = wrptr;\n\n\twhile (((wrptr & reg->rx_mask) !=\n\t\t(card->rxbd_rdptr & reg->rx_mask)) ||\n\t       ((wrptr & reg->rx_rollover_ind) ==\n\t\t(card->rxbd_rdptr & reg->rx_rollover_ind))) {\n\t\tstruct sk_buff *skb_data;\n\t\tu16 rx_len;\n\n\t\trd_index = card->rxbd_rdptr & reg->rx_mask;\n\t\tskb_data = card->rx_buf_list[rd_index];\n\n\t\t \n\t\tif (!skb_data)\n\t\t\treturn -ENOMEM;\n\n\t\tmwifiex_unmap_pci_memory(adapter, skb_data, DMA_FROM_DEVICE);\n\t\tcard->rx_buf_list[rd_index] = NULL;\n\n\t\t \n\t\trx_len = get_unaligned_le16(skb_data->data);\n\t\tif (WARN_ON(rx_len <= adapter->intf_hdr_len ||\n\t\t\t    rx_len > MWIFIEX_RX_DATA_BUF_SIZE)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Invalid RX len %d, Rd=%#x, Wr=%#x\\n\",\n\t\t\t\t    rx_len, card->rxbd_rdptr, wrptr);\n\t\t\tdev_kfree_skb_any(skb_data);\n\t\t} else {\n\t\t\tskb_put(skb_data, rx_len);\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"info: RECV DATA: Rd=%#x, Wr=%#x, Len=%d\\n\",\n\t\t\t\t    card->rxbd_rdptr, wrptr, rx_len);\n\t\t\tskb_pull(skb_data, adapter->intf_hdr_len);\n\t\t\tif (adapter->rx_work_enabled) {\n\t\t\t\tskb_queue_tail(&adapter->rx_data_q, skb_data);\n\t\t\t\tadapter->data_received = true;\n\t\t\t\tatomic_inc(&adapter->rx_pending);\n\t\t\t} else {\n\t\t\t\tmwifiex_handle_rx_packet(adapter, skb_data);\n\t\t\t}\n\t\t}\n\n\t\tskb_tmp = mwifiex_alloc_dma_align_buf(MWIFIEX_RX_DATA_BUF_SIZE,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!skb_tmp) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb_tmp,\n\t\t\t\t\t   MWIFIEX_RX_DATA_BUF_SIZE,\n\t\t\t\t\t   DMA_FROM_DEVICE))\n\t\t\treturn -1;\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb_tmp);\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"RECV DATA: Attach new sk_buff %p at rxbd_rdidx=%d\\n\",\n\t\t\t    skb_tmp, rd_index);\n\t\tcard->rx_buf_list[rd_index] = skb_tmp;\n\n\t\tif (reg->pfu_enabled) {\n\t\t\tdesc2 = card->rxbd_ring[rd_index];\n\t\t\tdesc2->paddr = buf_pa;\n\t\t\tdesc2->len = skb_tmp->len;\n\t\t\tdesc2->frag_len = skb_tmp->len;\n\t\t\tdesc2->offset = 0;\n\t\t\tdesc2->flags = reg->ring_flag_sop | reg->ring_flag_eop;\n\t\t} else {\n\t\t\tdesc = card->rxbd_ring[rd_index];\n\t\t\tdesc->paddr = buf_pa;\n\t\t\tdesc->len = skb_tmp->len;\n\t\t\tdesc->flags = 0;\n\t\t}\n\n\t\tif ((++card->rxbd_rdptr & reg->rx_mask) ==\n\t\t\t\t\t\t\tMWIFIEX_MAX_TXRX_BD) {\n\t\t\tcard->rxbd_rdptr = ((card->rxbd_rdptr &\n\t\t\t\t\t     reg->rx_rollover_ind) ^\n\t\t\t\t\t     reg->rx_rollover_ind);\n\t\t}\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: RECV DATA: <Rd: %#x, Wr: %#x>\\n\",\n\t\t\t    card->rxbd_rdptr, wrptr);\n\n\t\ttx_val = card->txbd_wrptr & reg->tx_wrap_mask;\n\t\t \n\t\tif (mwifiex_write_reg(adapter, reg->rx_rdptr,\n\t\t\t\t      card->rxbd_rdptr | tx_val)) {\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"RECV DATA: failed to write reg->rx_rdptr\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (mwifiex_read_reg(adapter, reg->rx_wrptr, &wrptr)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"RECV DATA: failed to read reg->rx_wrptr\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: RECV DATA: Rcvd packet from fw successfully\\n\");\n\t\tcard->rxbd_wrptr = wrptr;\n\t}\n\ndone:\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_pcie_send_boot_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)\n{\n\tdma_addr_t buf_pa;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (!(skb->data && skb->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Invalid parameter in %s <%p. len %d>\\n\",\n\t\t\t    __func__, skb->data, skb->len);\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_map_pci_memory(adapter, skb, skb->len, DMA_TO_DEVICE))\n\t\treturn -1;\n\n\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t \n\tif (mwifiex_write_reg(adapter, reg->cmd_addr_lo, (u32)buf_pa)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to write download command to boot code.\\n\",\n\t\t\t    __func__);\n\t\tmwifiex_unmap_pci_memory(adapter, skb, DMA_TO_DEVICE);\n\t\treturn -1;\n\t}\n\n\t \n\tif (mwifiex_write_reg(adapter, reg->cmd_addr_hi,\n\t\t\t      (u32)((u64)buf_pa >> 32))) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to write download command to boot code.\\n\",\n\t\t\t    __func__);\n\t\tmwifiex_unmap_pci_memory(adapter, skb, DMA_TO_DEVICE);\n\t\treturn -1;\n\t}\n\n\t \n\tif (mwifiex_write_reg(adapter, reg->cmd_size, skb->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to write command len to cmd_size scratch reg\\n\",\n\t\t\t    __func__);\n\t\tmwifiex_unmap_pci_memory(adapter, skb, DMA_TO_DEVICE);\n\t\treturn -1;\n\t}\n\n\t \n\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t      CPU_INTR_DOOR_BELL)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to assert door-bell intr\\n\", __func__);\n\t\tmwifiex_unmap_pci_memory(adapter, skb, DMA_TO_DEVICE);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_init_fw_port(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint tx_wrap = card->txbd_wrptr & reg->tx_wrap_mask;\n\n\t \n\tif (mwifiex_write_reg(adapter, reg->rx_rdptr, card->rxbd_rdptr |\n\t\t\t      tx_wrap)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"RECV DATA: failed to write reg->rx_rdptr\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_pcie_send_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint ret = 0;\n\tdma_addr_t cmd_buf_pa, cmdrsp_buf_pa;\n\tu8 *payload = (u8 *)skb->data;\n\n\tif (!(skb->data && skb->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Invalid parameter in %s <%p, %#x>\\n\",\n\t\t\t    __func__, skb->data, skb->len);\n\t\treturn -1;\n\t}\n\n\t \n\tif (!card->cmdrsp_buf) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"No response buffer available, send command failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\tadapter->cmd_sent = true;\n\n\tput_unaligned_le16((u16)skb->len, &payload[0]);\n\tput_unaligned_le16(MWIFIEX_TYPE_CMD, &payload[2]);\n\n\tif (mwifiex_map_pci_memory(adapter, skb, skb->len, DMA_TO_DEVICE))\n\t\treturn -1;\n\n\tcard->cmd_buf = skb;\n\t \n\tskb_get(skb);\n\n\t \n\n\tif (card->cmdrsp_buf) {\n\t\tcmdrsp_buf_pa = MWIFIEX_SKB_DMA_ADDR(card->cmdrsp_buf);\n\t\t \n\t\tif (mwifiex_write_reg(adapter, reg->cmdrsp_addr_lo,\n\t\t\t\t      (u32)cmdrsp_buf_pa)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Failed to write download cmd to boot code.\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\tif (mwifiex_write_reg(adapter, reg->cmdrsp_addr_hi,\n\t\t\t\t      (u32)((u64)cmdrsp_buf_pa >> 32))) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Failed to write download cmd to boot code.\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tcmd_buf_pa = MWIFIEX_SKB_DMA_ADDR(card->cmd_buf);\n\t \n\tif (mwifiex_write_reg(adapter, reg->cmd_addr_lo,\n\t\t\t      (u32)cmd_buf_pa)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to write download cmd to boot code.\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\t \n\tif (mwifiex_write_reg(adapter, reg->cmd_addr_hi,\n\t\t\t      (u32)((u64)cmd_buf_pa >> 32))) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to write download cmd to boot code.\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t \n\tif (mwifiex_write_reg(adapter, reg->cmd_size,\n\t\t\t      card->cmd_buf->len)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to write cmd len to reg->cmd_size\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t \n\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t      CPU_INTR_DOOR_BELL)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to assert door-bell intr\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\ndone:\n\tif (ret)\n\t\tadapter->cmd_sent = false;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_process_cmd_complete(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct sk_buff *skb = card->cmdrsp_buf;\n\tint count = 0;\n\tu16 rx_len;\n\n\tmwifiex_dbg(adapter, CMD,\n\t\t    \"info: Rx CMD Response\\n\");\n\n\tif (adapter->curr_cmd)\n\t\tmwifiex_unmap_pci_memory(adapter, skb, DMA_FROM_DEVICE);\n\telse\n\t\tdma_sync_single_for_cpu(&card->dev->dev,\n\t\t\t\t\tMWIFIEX_SKB_DMA_ADDR(skb),\n\t\t\t\t\tMWIFIEX_UPLD_SIZE, DMA_FROM_DEVICE);\n\n\t \n\tif (card->cmd_buf) {\n\t\tmwifiex_unmap_pci_memory(adapter, card->cmd_buf,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\tdev_kfree_skb_any(card->cmd_buf);\n\t\tcard->cmd_buf = NULL;\n\t}\n\n\trx_len = get_unaligned_le16(skb->data);\n\tskb_put(skb, MWIFIEX_UPLD_SIZE - skb->len);\n\tskb_trim(skb, rx_len);\n\n\tif (!adapter->curr_cmd) {\n\t\tif (adapter->ps_state == PS_STATE_SLEEP_CFM) {\n\t\t\tdma_sync_single_for_device(&card->dev->dev,\n\t\t\t\t\t\t   MWIFIEX_SKB_DMA_ADDR(skb),\n\t\t\t\t\t\t   MWIFIEX_SLEEP_COOKIE_SIZE,\n\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\tif (mwifiex_write_reg(adapter,\n\t\t\t\t\t      PCIE_CPU_INT_EVENT,\n\t\t\t\t\t      CPU_INTR_SLEEP_CFM_DONE)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"Write register failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmwifiex_delay_for_sleep_cookie(adapter,\n\t\t\t\t\t\t       MWIFIEX_MAX_DELAY_COUNT);\n\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tskb_pull(skb, adapter->intf_hdr_len);\n\t\t\twhile (reg->sleep_cookie && (count++ < 10) &&\n\t\t\t       mwifiex_pcie_ok_to_access_hw(adapter))\n\t\t\t\tusleep_range(50, 60);\n\t\t\tmwifiex_pcie_enable_host_int(adapter);\n\t\t\tmwifiex_process_sleep_confirm_resp(adapter, skb->data,\n\t\t\t\t\t\t\t   skb->len);\n\t\t} else {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"There is no command but got cmdrsp\\n\");\n\t\t}\n\t\tmemcpy(adapter->upld_buf, skb->data,\n\t\t       min_t(u32, MWIFIEX_SIZE_OF_CMD_BUFFER, skb->len));\n\t\tskb_push(skb, adapter->intf_hdr_len);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t\t   DMA_FROM_DEVICE))\n\t\t\treturn -1;\n\t} else if (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\tskb_pull(skb, adapter->intf_hdr_len);\n\t\tadapter->curr_cmd->resp_skb = skb;\n\t\tadapter->cmd_resp_received = true;\n\t\t \n\t\tcard->cmdrsp_buf = NULL;\n\n\t\t \n\t\tif (mwifiex_write_reg(adapter, reg->cmdrsp_addr_lo, 0)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cmd_done: failed to clear cmd_rsp_addr_lo\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t \n\t\tif (mwifiex_write_reg(adapter, reg->cmdrsp_addr_hi, 0)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"cmd_done: failed to clear cmd_rsp_addr_hi\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_cmdrsp_complete(struct mwifiex_adapter *adapter,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (skb) {\n\t\tcard->cmdrsp_buf = skb;\n\t\tskb_push(card->cmdrsp_buf, adapter->intf_hdr_len);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t\t   DMA_FROM_DEVICE))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_process_event_ready(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 rdptr = card->evtbd_rdptr & MWIFIEX_EVTBD_MASK;\n\tu32 wrptr, event;\n\tstruct mwifiex_evt_buf_desc *desc;\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\tmwifiex_pm_wakeup_card(adapter);\n\n\tif (adapter->event_received) {\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: Event being processed,\\t\"\n\t\t\t    \"do not process this interrupt just yet\\n\");\n\t\treturn 0;\n\t}\n\n\tif (rdptr >= MWIFIEX_MAX_EVT_BD) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"info: Invalid read pointer...\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (mwifiex_read_reg(adapter, reg->evt_wrptr, &wrptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"EventReady: failed to read reg->evt_wrptr\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"info: EventReady: Initial <Rd: 0x%x, Wr: 0x%x>\",\n\t\t    card->evtbd_rdptr, wrptr);\n\tif (((wrptr & MWIFIEX_EVTBD_MASK) != (card->evtbd_rdptr\n\t\t\t\t\t      & MWIFIEX_EVTBD_MASK)) ||\n\t    ((wrptr & reg->evt_rollover_ind) ==\n\t     (card->evtbd_rdptr & reg->evt_rollover_ind))) {\n\t\tstruct sk_buff *skb_cmd;\n\t\t__le16 data_len = 0;\n\t\tu16 evt_len;\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: Read Index: %d\\n\", rdptr);\n\t\tskb_cmd = card->evt_buf_list[rdptr];\n\t\tmwifiex_unmap_pci_memory(adapter, skb_cmd, DMA_FROM_DEVICE);\n\n\t\t \n\t\tcard->evt_buf_list[rdptr] = NULL;\n\t\tdesc = card->evtbd_ring[rdptr];\n\t\tmemset(desc, 0, sizeof(*desc));\n\n\t\tevent = get_unaligned_le32(\n\t\t\t&skb_cmd->data[adapter->intf_hdr_len]);\n\t\tadapter->event_cause = event;\n\t\t \n\t\tmemcpy(&data_len, skb_cmd->data, sizeof(__le16));\n\t\tevt_len = le16_to_cpu(data_len);\n\t\tskb_trim(skb_cmd, evt_len);\n\t\tskb_pull(skb_cmd, adapter->intf_hdr_len);\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: Event length: %d\\n\", evt_len);\n\n\t\tif (evt_len > MWIFIEX_EVENT_HEADER_LEN &&\n\t\t    evt_len < MAX_EVENT_SIZE)\n\t\t\tmemcpy(adapter->event_body, skb_cmd->data +\n\t\t\t       MWIFIEX_EVENT_HEADER_LEN, evt_len -\n\t\t\t       MWIFIEX_EVENT_HEADER_LEN);\n\n\t\tadapter->event_received = true;\n\t\tadapter->event_skb = skb_cmd;\n\n\t\t \n\t} else {\n\t\tif (mwifiex_write_reg(adapter, PCIE_CPU_INT_EVENT,\n\t\t\t\t      CPU_INTR_EVENT_DONE)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Write register failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_event_complete(struct mwifiex_adapter *adapter,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint ret = 0;\n\tu32 rdptr = card->evtbd_rdptr & MWIFIEX_EVTBD_MASK;\n\tu32 wrptr;\n\tstruct mwifiex_evt_buf_desc *desc;\n\n\tif (!skb)\n\t\treturn 0;\n\n\tif (rdptr >= MWIFIEX_MAX_EVT_BD) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"event_complete: Invalid rdptr 0x%x\\n\",\n\t\t\t    rdptr);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mwifiex_read_reg(adapter, reg->evt_wrptr, &wrptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"event_complete: failed to read reg->evt_wrptr\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!card->evt_buf_list[rdptr]) {\n\t\tskb_push(skb, adapter->intf_hdr_len);\n\t\tskb_put(skb, MAX_EVENT_SIZE - skb->len);\n\t\tif (mwifiex_map_pci_memory(adapter, skb,\n\t\t\t\t\t   MAX_EVENT_SIZE,\n\t\t\t\t\t   DMA_FROM_DEVICE))\n\t\t\treturn -1;\n\t\tcard->evt_buf_list[rdptr] = skb;\n\t\tdesc = card->evtbd_ring[rdptr];\n\t\tdesc->paddr = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t\tskb = NULL;\n\t} else {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"info: ERROR: buf still valid at index %d, <%p, %p>\\n\",\n\t\t\t    rdptr, card->evt_buf_list[rdptr], skb);\n\t}\n\n\tif ((++card->evtbd_rdptr & MWIFIEX_EVTBD_MASK) == MWIFIEX_MAX_EVT_BD) {\n\t\tcard->evtbd_rdptr = ((card->evtbd_rdptr &\n\t\t\t\t\treg->evt_rollover_ind) ^\n\t\t\t\t\treg->evt_rollover_ind);\n\t}\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"info: Updated <Rd: 0x%x, Wr: 0x%x>\",\n\t\t    card->evtbd_rdptr, wrptr);\n\n\t \n\tif (mwifiex_write_reg(adapter, reg->evt_rdptr,\n\t\t\t      card->evtbd_rdptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"event_complete: failed to read reg->evt_rdptr\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"info: Check Events Again\\n\");\n\tret = mwifiex_pcie_process_event_ready(adapter);\n\n\treturn ret;\n}\n\n \n\nstatic int mwifiex_extract_wifi_fw(struct mwifiex_adapter *adapter,\n\t\t\t\t   const void *firmware, u32 firmware_len) {\n\tconst struct mwifiex_fw_data *fwdata;\n\tu32 offset = 0, data_len, dnld_cmd;\n\tint ret = 0;\n\tbool cmd7_before = false, first_cmd = false;\n\n\twhile (1) {\n\t\t \n\t\tif (offset + sizeof(fwdata->header) < sizeof(fwdata->header) ||\n\t\t    offset + sizeof(fwdata->header) >= firmware_len) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"extract wifi-only fw failure!\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tfwdata = firmware + offset;\n\t\tdnld_cmd = le32_to_cpu(fwdata->header.dnld_cmd);\n\t\tdata_len = le32_to_cpu(fwdata->header.data_length);\n\n\t\t \n\t\toffset += sizeof(fwdata->header);\n\n\t\tswitch (dnld_cmd) {\n\t\tcase MWIFIEX_FW_DNLD_CMD_1:\n\t\t\tif (offset + data_len < data_len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"bad FW parse\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!first_cmd) {\n\t\t\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t\t\t    \"input wifi-only firmware\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (!cmd7_before) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"no cmd7 before cmd1!\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\toffset += data_len;\n\t\t\tbreak;\n\t\tcase MWIFIEX_FW_DNLD_CMD_5:\n\t\t\tfirst_cmd = true;\n\t\t\t \n\t\t\tif (offset + data_len < data_len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"bad FW parse\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\toffset += data_len;\n\t\t\tbreak;\n\t\tcase MWIFIEX_FW_DNLD_CMD_6:\n\t\t\tfirst_cmd = true;\n\t\t\t \n\t\t\tif (offset + data_len < data_len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"bad FW parse\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\toffset += data_len;\n\t\t\tif (offset >= firmware_len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"extract wifi-only fw failure!\\n\");\n\t\t\t\tret = -1;\n\t\t\t} else {\n\t\t\t\tret = offset;\n\t\t\t}\n\t\t\tgoto done;\n\t\tcase MWIFIEX_FW_DNLD_CMD_7:\n\t\t\tfirst_cmd = true;\n\t\t\tcmd7_before = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmwifiex_dbg(adapter, ERROR, \"unknown dnld_cmd %d\\n\",\n\t\t\t\t    dnld_cmd);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\treturn ret;\n}\n\n \nstatic int mwifiex_prog_fw_w_helper(struct mwifiex_adapter *adapter,\n\t\t\t\t    struct mwifiex_fw_image *fw)\n{\n\tint ret;\n\tu8 *firmware = fw->fw_buf;\n\tu32 firmware_len = fw->fw_len;\n\tu32 offset = 0;\n\tstruct sk_buff *skb;\n\tu32 txlen, tx_blocks = 0, tries, len, val;\n\tu32 block_retry_cnt = 0;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (!firmware || !firmware_len) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"No firmware image found! Terminating download\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: Downloading FW image (%d bytes)\\n\",\n\t\t    firmware_len);\n\n\tif (mwifiex_pcie_disable_host_int(adapter)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: Disabling interrupts failed.\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tret = mwifiex_read_reg(adapter, PCIE_SCRATCH_13_REG, &val);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, FATAL, \"Failed to read scratch register 13\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tif (val == MWIFIEX_PCIE_FLR_HAPPENS) {\n\t\tret = mwifiex_extract_wifi_fw(adapter, firmware, firmware_len);\n\t\tif (ret < 0) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"Failed to extract wifi fw\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\toffset = ret;\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"info: dnld wifi firmware from %d bytes\\n\", offset);\n\t}\n\n\t \n\tdo {\n\t\tu32 ireg_intr = 0;\n\n\t\t \n\t\tif (offset >= firmware_len)\n\t\t\tbreak;\n\n\t\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\t\tret = mwifiex_read_reg(adapter, reg->cmd_size,\n\t\t\t\t\t       &len);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, FATAL,\n\t\t\t\t\t    \"Failed reading len from boot code\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (len)\n\t\t\t\tbreak;\n\t\t\tusleep_range(10, 20);\n\t\t}\n\n\t\tif (!len) {\n\t\t\tbreak;\n\t\t} else if (len > MWIFIEX_UPLD_SIZE) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"FW download failure @ %d, invalid length %d\\n\",\n\t\t\t\t    offset, len);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\ttxlen = len;\n\n\t\tif (len & BIT(0)) {\n\t\t\tblock_retry_cnt++;\n\t\t\tif (block_retry_cnt > MAX_WRITE_IOMEM_RETRY) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"FW download failure @ %d, over max\\t\"\n\t\t\t\t\t    \"retry count\\n\", offset);\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"FW CRC error indicated by the\\t\"\n\t\t\t\t    \"helper: len = 0x%04X, txlen = %d\\n\",\n\t\t\t\t    len, txlen);\n\t\t\tlen &= ~BIT(0);\n\t\t\t \n\t\t\ttxlen = 0;\n\t\t} else {\n\t\t\tblock_retry_cnt = 0;\n\t\t\t \n\t\t\tif (firmware_len - offset < txlen)\n\t\t\t\ttxlen = firmware_len - offset;\n\n\t\t\ttx_blocks = (txlen + card->pcie.blksz_fw_dl - 1) /\n\t\t\t\t    card->pcie.blksz_fw_dl;\n\n\t\t\t \n\t\t\tmemmove(skb->data, &firmware[offset], txlen);\n\t\t}\n\n\t\tskb_put(skb, MWIFIEX_UPLD_SIZE - skb->len);\n\t\tskb_trim(skb, tx_blocks * card->pcie.blksz_fw_dl);\n\n\t\t \n\t\tif (mwifiex_pcie_send_boot_cmd(adapter, skb)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Failed to send firmware download command\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\t\tif (mwifiex_read_reg(adapter, PCIE_CPU_INT_STATUS,\n\t\t\t\t\t     &ireg_intr)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"%s: Failed to read\\t\"\n\t\t\t\t\t    \"interrupt status during fw dnld.\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (!(ireg_intr & CPU_INTR_DOOR_BELL))\n\t\t\t\tbreak;\n\t\t\tusleep_range(10, 20);\n\t\t}\n\t\tif (ireg_intr & CPU_INTR_DOOR_BELL) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"%s: Card failed to ACK download\\n\",\n\t\t\t\t    __func__);\n\t\t\tmwifiex_unmap_pci_memory(adapter, skb,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tmwifiex_unmap_pci_memory(adapter, skb, DMA_TO_DEVICE);\n\n\t\toffset += txlen;\n\t} while (true);\n\n\tmwifiex_dbg(adapter, MSG,\n\t\t    \"info: FW download over, size %d bytes\\n\", offset);\n\n\tret = 0;\n\ndone:\n\tdev_kfree_skb_any(skb);\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_check_fw_status(struct mwifiex_adapter *adapter, u32 poll_num)\n{\n\tint ret = 0;\n\tu32 firmware_stat;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 tries;\n\n\t \n\tif (mwifiex_write_reg(adapter, PCIE_HOST_INT_STATUS_MASK,\n\t\t\t      HOST_INTR_MASK)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Write register failed\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"Setting driver ready signature\\n\");\n\tif (mwifiex_write_reg(adapter, reg->drv_rdy,\n\t\t\t      FIRMWARE_READY_PCIE)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Failed to write driver ready signature\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tfor (tries = 0; tries < poll_num; tries++) {\n\t\tif (mwifiex_read_reg(adapter, reg->fw_status,\n\t\t\t\t     &firmware_stat))\n\t\t\tret = -1;\n\t\telse\n\t\t\tret = 0;\n\n\t\tmwifiex_dbg(adapter, INFO, \"Try %d if FW is ready <%d,%#x>\",\n\t\t\t    tries, ret, firmware_stat);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tif (firmware_stat == FIRMWARE_READY_PCIE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tmsleep(100);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_check_winner_status(struct mwifiex_adapter *adapter)\n{\n\tu32 winner = 0;\n\tint ret = 0;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (mwifiex_read_reg(adapter, reg->fw_status, &winner)) {\n\t\tret = -1;\n\t} else if (!winner) {\n\t\tmwifiex_dbg(adapter, INFO, \"PCI-E is the winner\\n\");\n\t\tadapter->winner = 1;\n\t} else {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PCI-E is not the winner <%#x>\", winner);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void mwifiex_interrupt_status(struct mwifiex_adapter *adapter,\n\t\t\t\t     int msg_id)\n{\n\tu32 pcie_ireg;\n\tunsigned long flags;\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (card->msi_enable) {\n\t\tspin_lock_irqsave(&adapter->int_lock, flags);\n\t\tadapter->int_status = 1;\n\t\tspin_unlock_irqrestore(&adapter->int_lock, flags);\n\t\treturn;\n\t}\n\n\tif (!mwifiex_pcie_ok_to_access_hw(adapter))\n\t\treturn;\n\n\tif (card->msix_enable && msg_id >= 0) {\n\t\tpcie_ireg = BIT(msg_id);\n\t} else {\n\t\tif (mwifiex_read_reg(adapter, PCIE_HOST_INT_STATUS,\n\t\t\t\t     &pcie_ireg)) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"Read register failed\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif ((pcie_ireg == 0xFFFFFFFF) || !pcie_ireg)\n\t\t\treturn;\n\n\n\t\tmwifiex_pcie_disable_host_int(adapter);\n\n\t\t \n\t\tif (mwifiex_write_reg(adapter, PCIE_HOST_INT_STATUS,\n\t\t\t\t      ~pcie_ireg)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Write register failed\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!adapter->pps_uapsd_mode &&\n\t    adapter->ps_state == PS_STATE_SLEEP &&\n\t    mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\t \n\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t\tadapter->pm_wakeup_fw_try = false;\n\t\tdel_timer(&adapter->wakeup_timer);\n\t}\n\n\tspin_lock_irqsave(&adapter->int_lock, flags);\n\tadapter->int_status |= pcie_ireg;\n\tspin_unlock_irqrestore(&adapter->int_lock, flags);\n\tmwifiex_dbg(adapter, INTR, \"ireg: 0x%08x\\n\", pcie_ireg);\n}\n\n \nstatic irqreturn_t mwifiex_pcie_interrupt(int irq, void *context)\n{\n\tstruct mwifiex_msix_context *ctx = context;\n\tstruct pci_dev *pdev = ctx->dev;\n\tstruct pcie_service_card *card;\n\tstruct mwifiex_adapter *adapter;\n\n\tcard = pci_get_drvdata(pdev);\n\n\tif (!card->adapter) {\n\t\tpr_err(\"info: %s: card=%p adapter=%p\\n\", __func__, card,\n\t\t       card ? card->adapter : NULL);\n\t\tgoto exit;\n\t}\n\tadapter = card->adapter;\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags))\n\t\tgoto exit;\n\n\tif (card->msix_enable)\n\t\tmwifiex_interrupt_status(adapter, ctx->msg_id);\n\telse\n\t\tmwifiex_interrupt_status(adapter, -1);\n\n\tmwifiex_queue_main_work(adapter);\n\nexit:\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int mwifiex_process_int_status(struct mwifiex_adapter *adapter)\n{\n\tint ret;\n\tu32 pcie_ireg = 0;\n\tunsigned long flags;\n\tstruct pcie_service_card *card = adapter->card;\n\n\tspin_lock_irqsave(&adapter->int_lock, flags);\n\tif (!card->msi_enable) {\n\t\t \n\t\tpcie_ireg = adapter->int_status;\n\t}\n\tadapter->int_status = 0;\n\tspin_unlock_irqrestore(&adapter->int_lock, flags);\n\n\tif (card->msi_enable) {\n\t\tif (mwifiex_pcie_ok_to_access_hw(adapter)) {\n\t\t\tif (mwifiex_read_reg(adapter, PCIE_HOST_INT_STATUS,\n\t\t\t\t\t     &pcie_ireg)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"Read register failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif ((pcie_ireg != 0xFFFFFFFF) && (pcie_ireg)) {\n\t\t\t\tif (mwifiex_write_reg(adapter,\n\t\t\t\t\t\t      PCIE_HOST_INT_STATUS,\n\t\t\t\t\t\t      ~pcie_ireg)) {\n\t\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t\t    \"Write register failed\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (!adapter->pps_uapsd_mode &&\n\t\t\t\t    adapter->ps_state == PS_STATE_SLEEP) {\n\t\t\t\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t\t\t\t\tadapter->pm_wakeup_fw_try = false;\n\t\t\t\t\tdel_timer(&adapter->wakeup_timer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pcie_ireg & HOST_INTR_DNLD_DONE) {\n\t\tmwifiex_dbg(adapter, INTR, \"info: TX DNLD Done\\n\");\n\t\tret = mwifiex_pcie_send_data_complete(adapter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (pcie_ireg & HOST_INTR_UPLD_RDY) {\n\t\tmwifiex_dbg(adapter, INTR, \"info: Rx DATA\\n\");\n\t\tret = mwifiex_pcie_process_recv_data(adapter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (pcie_ireg & HOST_INTR_EVENT_RDY) {\n\t\tmwifiex_dbg(adapter, INTR, \"info: Rx EVENT\\n\");\n\t\tret = mwifiex_pcie_process_event_ready(adapter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (pcie_ireg & HOST_INTR_CMD_DONE) {\n\t\tif (adapter->cmd_sent) {\n\t\t\tmwifiex_dbg(adapter, INTR,\n\t\t\t\t    \"info: CMD sent Interrupt\\n\");\n\t\t\tadapter->cmd_sent = false;\n\t\t}\n\t\t \n\t\tret = mwifiex_pcie_process_cmd_complete(adapter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmwifiex_dbg(adapter, INTR,\n\t\t    \"info: cmd_sent=%d data_sent=%d\\n\",\n\t\t    adapter->cmd_sent, adapter->data_sent);\n\tif (!card->msi_enable && !card->msix_enable &&\n\t\t\t\t adapter->ps_state != PS_STATE_SLEEP)\n\t\tmwifiex_pcie_enable_host_int(adapter);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_pcie_host_to_card(struct mwifiex_adapter *adapter, u8 type,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     struct mwifiex_tx_param *tx_param)\n{\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Passed NULL skb to %s\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tif (type == MWIFIEX_TYPE_DATA)\n\t\treturn mwifiex_pcie_send_data(adapter, skb, tx_param);\n\telse if (type == MWIFIEX_TYPE_CMD)\n\t\treturn mwifiex_pcie_send_cmd(adapter, skb);\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_pcie_reg_dump(struct mwifiex_adapter *adapter, char *drv_buf)\n{\n\tchar *p = drv_buf;\n\tchar buf[256], *ptr;\n\tint i;\n\tu32 value;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint pcie_scratch_reg[] = {PCIE_SCRATCH_12_REG,\n\t\t\t\t  PCIE_SCRATCH_14_REG,\n\t\t\t\t  PCIE_SCRATCH_15_REG};\n\n\tif (!p)\n\t\treturn 0;\n\n\tmwifiex_dbg(adapter, MSG, \"PCIE register dump start\\n\");\n\n\tif (mwifiex_read_reg(adapter, reg->fw_status, &value)) {\n\t\tmwifiex_dbg(adapter, ERROR, \"failed to read firmware status\");\n\t\treturn 0;\n\t}\n\n\tptr = buf;\n\tmwifiex_dbg(adapter, MSG, \"pcie scratch register:\");\n\tfor (i = 0; i < ARRAY_SIZE(pcie_scratch_reg); i++) {\n\t\tmwifiex_read_reg(adapter, pcie_scratch_reg[i], &value);\n\t\tptr += sprintf(ptr, \"reg:0x%x, value=0x%x\\n\",\n\t\t\t       pcie_scratch_reg[i], value);\n\t}\n\n\tmwifiex_dbg(adapter, MSG, \"%s\\n\", buf);\n\tp += sprintf(p, \"%s\\n\", buf);\n\n\tmwifiex_dbg(adapter, MSG, \"PCIE register dump end\\n\");\n\n\treturn p - drv_buf;\n}\n\n \nstatic enum rdwr_status\nmwifiex_pcie_rdwr_firmware(struct mwifiex_adapter *adapter, u8 doneflag)\n{\n\tint ret, tries;\n\tu8 ctrl_data;\n\tu32 fw_status;\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (mwifiex_read_reg(adapter, reg->fw_status, &fw_status))\n\t\treturn RDWR_STATUS_FAILURE;\n\n\tret = mwifiex_write_reg(adapter, reg->fw_dump_ctrl,\n\t\t\t\treg->fw_dump_host_ready);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PCIE write err\\n\");\n\t\treturn RDWR_STATUS_FAILURE;\n\t}\n\n\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\tmwifiex_read_reg_byte(adapter, reg->fw_dump_ctrl, &ctrl_data);\n\t\tif (ctrl_data == FW_DUMP_DONE)\n\t\t\treturn RDWR_STATUS_SUCCESS;\n\t\tif (doneflag && ctrl_data == doneflag)\n\t\t\treturn RDWR_STATUS_DONE;\n\t\tif (ctrl_data != reg->fw_dump_host_ready) {\n\t\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t\t    \"The ctrl reg was changed, re-try again!\\n\");\n\t\t\tret = mwifiex_write_reg(adapter, reg->fw_dump_ctrl,\n\t\t\t\t\t\treg->fw_dump_host_ready);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"PCIE write err\\n\");\n\t\t\t\treturn RDWR_STATUS_FAILURE;\n\t\t\t}\n\t\t}\n\t\tusleep_range(100, 200);\n\t}\n\n\tmwifiex_dbg(adapter, ERROR, \"Fail to pull ctrl_data\\n\");\n\treturn RDWR_STATUS_FAILURE;\n}\n\n \nstatic void mwifiex_pcie_fw_dump(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *creg = card->pcie.reg;\n\tunsigned int reg, reg_start, reg_end;\n\tu8 *dbg_ptr, *end_ptr, *tmp_ptr, fw_dump_num, dump_num;\n\tu8 idx, i, read_reg, doneflag = 0;\n\tenum rdwr_status stat;\n\tu32 memory_size;\n\tint ret;\n\n\tif (!card->pcie.can_dump_fw)\n\t\treturn;\n\n\tfor (idx = 0; idx < adapter->num_mem_types; idx++) {\n\t\tstruct memory_type_mapping *entry =\n\t\t\t\t&adapter->mem_type_mapping_tbl[idx];\n\n\t\tif (entry->mem_ptr) {\n\t\t\tvfree(entry->mem_ptr);\n\t\t\tentry->mem_ptr = NULL;\n\t\t}\n\t\tentry->mem_size = 0;\n\t}\n\n\tmwifiex_dbg(adapter, MSG, \"== mwifiex firmware dump start ==\\n\");\n\n\t \n\tstat = mwifiex_pcie_rdwr_firmware(adapter, doneflag);\n\tif (stat == RDWR_STATUS_FAILURE)\n\t\treturn;\n\n\treg = creg->fw_dump_start;\n\tmwifiex_read_reg_byte(adapter, reg, &fw_dump_num);\n\n\t \n\tif (fw_dump_num == 0)\n\t\tdump_num = 1;\n\telse\n\t\tdump_num = fw_dump_num;\n\n\t \n\tfor (idx = 0; idx < dump_num; idx++) {\n\t\tstruct memory_type_mapping *entry =\n\t\t\t\t&adapter->mem_type_mapping_tbl[idx];\n\t\tmemory_size = 0;\n\t\tif (fw_dump_num != 0) {\n\t\t\tstat = mwifiex_pcie_rdwr_firmware(adapter, doneflag);\n\t\t\tif (stat == RDWR_STATUS_FAILURE)\n\t\t\t\treturn;\n\n\t\t\treg = creg->fw_dump_start;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tmwifiex_read_reg_byte(adapter, reg, &read_reg);\n\t\t\t\tmemory_size |= (read_reg << (i * 8));\n\t\t\t\treg++;\n\t\t\t}\n\t\t} else {\n\t\t\tmemory_size = MWIFIEX_FW_DUMP_MAX_MEMSIZE;\n\t\t}\n\n\t\tif (memory_size == 0) {\n\t\t\tmwifiex_dbg(adapter, MSG, \"Firmware dump Finished!\\n\");\n\t\t\tret = mwifiex_write_reg(adapter, creg->fw_dump_ctrl,\n\t\t\t\t\t\tcreg->fw_dump_read_done);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"PCIE write err\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tmwifiex_dbg(adapter, DUMP,\n\t\t\t    \"%s_SIZE=0x%x\\n\", entry->mem_name, memory_size);\n\t\tentry->mem_ptr = vmalloc(memory_size + 1);\n\t\tentry->mem_size = memory_size;\n\t\tif (!entry->mem_ptr) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Vmalloc %s failed\\n\", entry->mem_name);\n\t\t\treturn;\n\t\t}\n\t\tdbg_ptr = entry->mem_ptr;\n\t\tend_ptr = dbg_ptr + memory_size;\n\n\t\tdoneflag = entry->done_flag;\n\t\tmwifiex_dbg(adapter, DUMP, \"Start %s output, please wait...\\n\",\n\t\t\t    entry->mem_name);\n\n\t\tdo {\n\t\t\tstat = mwifiex_pcie_rdwr_firmware(adapter, doneflag);\n\t\t\tif (RDWR_STATUS_FAILURE == stat)\n\t\t\t\treturn;\n\n\t\t\treg_start = creg->fw_dump_start;\n\t\t\treg_end = creg->fw_dump_end;\n\t\t\tfor (reg = reg_start; reg <= reg_end; reg++) {\n\t\t\t\tmwifiex_read_reg_byte(adapter, reg, dbg_ptr);\n\t\t\t\tif (dbg_ptr < end_ptr) {\n\t\t\t\t\tdbg_ptr++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"pre-allocated buf not enough\\n\");\n\t\t\t\ttmp_ptr =\n\t\t\t\t\tvzalloc(memory_size + MWIFIEX_SIZE_4K);\n\t\t\t\tif (!tmp_ptr)\n\t\t\t\t\treturn;\n\t\t\t\tmemcpy(tmp_ptr, entry->mem_ptr, memory_size);\n\t\t\t\tvfree(entry->mem_ptr);\n\t\t\t\tentry->mem_ptr = tmp_ptr;\n\t\t\t\ttmp_ptr = NULL;\n\t\t\t\tdbg_ptr = entry->mem_ptr + memory_size;\n\t\t\t\tmemory_size += MWIFIEX_SIZE_4K;\n\t\t\t\tend_ptr = entry->mem_ptr + memory_size;\n\t\t\t}\n\n\t\t\tif (stat != RDWR_STATUS_DONE)\n\t\t\t\tcontinue;\n\n\t\t\tmwifiex_dbg(adapter, DUMP,\n\t\t\t\t    \"%s done: size=0x%tx\\n\",\n\t\t\t\t    entry->mem_name, dbg_ptr - entry->mem_ptr);\n\t\t\tbreak;\n\t\t} while (true);\n\t}\n\tmwifiex_dbg(adapter, MSG, \"== mwifiex firmware dump end ==\\n\");\n}\n\nstatic void mwifiex_pcie_device_dump_work(struct mwifiex_adapter *adapter)\n{\n\tadapter->devdump_data = vzalloc(MWIFIEX_FW_DUMP_SIZE);\n\tif (!adapter->devdump_data) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"vzalloc devdump data failure!\\n\");\n\t\treturn;\n\t}\n\n\tmwifiex_drv_info_dump(adapter);\n\tmwifiex_pcie_fw_dump(adapter);\n\tmwifiex_prepare_fw_dump_info(adapter);\n\tmwifiex_upload_device_dump(adapter);\n}\n\nstatic void mwifiex_pcie_card_reset_work(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\t \n\tpci_try_reset_function(card->dev);\n}\n\nstatic void mwifiex_pcie_work(struct work_struct *work)\n{\n\tstruct pcie_service_card *card =\n\t\tcontainer_of(work, struct pcie_service_card, work);\n\n\tif (test_and_clear_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP,\n\t\t\t       &card->work_flags))\n\t\tmwifiex_pcie_device_dump_work(card->adapter);\n\tif (test_and_clear_bit(MWIFIEX_IFACE_WORK_CARD_RESET,\n\t\t\t       &card->work_flags))\n\t\tmwifiex_pcie_card_reset_work(card->adapter);\n}\n\n \nstatic void mwifiex_pcie_device_dump(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (!test_and_set_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP,\n\t\t\t      &card->work_flags))\n\t\tschedule_work(&card->work);\n}\n\nstatic void mwifiex_pcie_card_reset(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\tif (!test_and_set_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &card->work_flags))\n\t\tschedule_work(&card->work);\n}\n\nstatic int mwifiex_pcie_alloc_buffers(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tint ret;\n\n\tcard->cmdrsp_buf = NULL;\n\tret = mwifiex_pcie_create_txbd_ring(adapter);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to create txbd ring\\n\");\n\t\tgoto err_cre_txbd;\n\t}\n\n\tret = mwifiex_pcie_create_rxbd_ring(adapter);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to create rxbd ring\\n\");\n\t\tgoto err_cre_rxbd;\n\t}\n\n\tret = mwifiex_pcie_create_evtbd_ring(adapter);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to create evtbd ring\\n\");\n\t\tgoto err_cre_evtbd;\n\t}\n\n\tret = mwifiex_pcie_alloc_cmdrsp_buf(adapter);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to allocate cmdbuf buffer\\n\");\n\t\tgoto err_alloc_cmdbuf;\n\t}\n\n\tif (reg->sleep_cookie) {\n\t\tret = mwifiex_pcie_alloc_sleep_cookie_buf(adapter);\n\t\tif (ret) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"Failed to allocate sleep_cookie buffer\\n\");\n\t\t\tgoto err_alloc_cookie;\n\t\t}\n\t} else {\n\t\tcard->sleep_cookie_vbase = NULL;\n\t}\n\n\treturn 0;\n\nerr_alloc_cookie:\n\tmwifiex_pcie_delete_cmdrsp_buf(adapter);\nerr_alloc_cmdbuf:\n\tmwifiex_pcie_delete_evtbd_ring(adapter);\nerr_cre_evtbd:\n\tmwifiex_pcie_delete_rxbd_ring(adapter);\nerr_cre_rxbd:\n\tmwifiex_pcie_delete_txbd_ring(adapter);\nerr_cre_txbd:\n\treturn ret;\n}\n\nstatic void mwifiex_pcie_free_buffers(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\n\tif (reg->sleep_cookie)\n\t\tmwifiex_pcie_delete_sleep_cookie_buf(adapter);\n\n\tmwifiex_pcie_delete_cmdrsp_buf(adapter);\n\tmwifiex_pcie_delete_evtbd_ring(adapter);\n\tmwifiex_pcie_delete_rxbd_ring(adapter);\n\tmwifiex_pcie_delete_txbd_ring(adapter);\n}\n\n \nstatic int mwifiex_init_pcie(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tint ret;\n\tstruct pci_dev *pdev = card->dev;\n\n\tpci_set_drvdata(pdev, card);\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\tgoto err_enable_dev;\n\n\tpci_set_master(pdev);\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tpr_err(\"dma_set_mask(32) failed: %d\\n\", ret);\n\t\tgoto err_set_dma_mask;\n\t}\n\n\tret = pci_request_region(pdev, 0, DRV_NAME);\n\tif (ret) {\n\t\tpr_err(\"req_reg(0) error\\n\");\n\t\tgoto err_req_region0;\n\t}\n\tcard->pci_mmap = pci_iomap(pdev, 0, 0);\n\tif (!card->pci_mmap) {\n\t\tpr_err(\"iomap(0) error\\n\");\n\t\tret = -EIO;\n\t\tgoto err_iomap0;\n\t}\n\tret = pci_request_region(pdev, 2, DRV_NAME);\n\tif (ret) {\n\t\tpr_err(\"req_reg(2) error\\n\");\n\t\tgoto err_req_region2;\n\t}\n\tcard->pci_mmap1 = pci_iomap(pdev, 2, 0);\n\tif (!card->pci_mmap1) {\n\t\tpr_err(\"iomap(2) error\\n\");\n\t\tret = -EIO;\n\t\tgoto err_iomap2;\n\t}\n\n\tpr_notice(\"PCI memory map Virt0: %pK PCI memory map Virt2: %pK\\n\",\n\t\t  card->pci_mmap, card->pci_mmap1);\n\n\tret = mwifiex_pcie_alloc_buffers(adapter);\n\tif (ret)\n\t\tgoto err_alloc_buffers;\n\n\tif (pdev->device == PCIE_DEVICE_ID_MARVELL_88W8897)\n\t\tadapter->ignore_btcoex_events = true;\n\n\treturn 0;\n\nerr_alloc_buffers:\n\tpci_iounmap(pdev, card->pci_mmap1);\nerr_iomap2:\n\tpci_release_region(pdev, 2);\nerr_req_region2:\n\tpci_iounmap(pdev, card->pci_mmap);\nerr_iomap0:\n\tpci_release_region(pdev, 0);\nerr_req_region0:\nerr_set_dma_mask:\n\tpci_disable_device(pdev);\nerr_enable_dev:\n\treturn ret;\n}\n\n \nstatic void mwifiex_cleanup_pcie(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct pci_dev *pdev = card->dev;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tu32 fw_status;\n\n\t \n\tif (!card->pci_reset_ongoing) {\n\t\tmwifiex_dbg(adapter, MSG, \"performing cancel_work_sync()...\\n\");\n\t\tcancel_work_sync(&card->work);\n\t\tmwifiex_dbg(adapter, MSG, \"cancel_work_sync() done\\n\");\n\t} else {\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"skipped cancel_work_sync() because we're in card reset failure path\\n\");\n\t}\n\n\tmwifiex_read_reg(adapter, reg->fw_status, &fw_status);\n\tif (fw_status == FIRMWARE_READY_PCIE) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"Clearing driver ready signature\\n\");\n\t\tif (mwifiex_write_reg(adapter, reg->drv_rdy, 0x00000000))\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Failed to write driver not-ready signature\\n\");\n\t}\n\n\tpci_disable_device(pdev);\n\n\tpci_iounmap(pdev, card->pci_mmap);\n\tpci_iounmap(pdev, card->pci_mmap1);\n\tpci_release_region(pdev, 2);\n\tpci_release_region(pdev, 0);\n\n\tmwifiex_pcie_free_buffers(adapter);\n}\n\nstatic int mwifiex_pcie_request_irq(struct mwifiex_adapter *adapter)\n{\n\tint ret, i, j;\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct pci_dev *pdev = card->dev;\n\n\tif (card->pcie.reg->msix_support) {\n\t\tfor (i = 0; i < MWIFIEX_NUM_MSIX_VECTORS; i++)\n\t\t\tcard->msix_entries[i].entry = i;\n\t\tret = pci_enable_msix_exact(pdev, card->msix_entries,\n\t\t\t\t\t    MWIFIEX_NUM_MSIX_VECTORS);\n\t\tif (!ret) {\n\t\t\tfor (i = 0; i < MWIFIEX_NUM_MSIX_VECTORS; i++) {\n\t\t\t\tcard->msix_ctx[i].dev = pdev;\n\t\t\t\tcard->msix_ctx[i].msg_id = i;\n\n\t\t\t\tret = request_irq(card->msix_entries[i].vector,\n\t\t\t\t\t\t  mwifiex_pcie_interrupt, 0,\n\t\t\t\t\t\t  \"MWIFIEX_PCIE_MSIX\",\n\t\t\t\t\t\t  &card->msix_ctx[i]);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, INFO, \"request_irq fail: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tfree_irq(card->msix_entries[j].vector,\n\t\t\t\t\t\t &card->msix_ctx[i]);\n\t\t\t\tpci_disable_msix(pdev);\n\t\t\t} else {\n\t\t\t\tmwifiex_dbg(adapter, MSG, \"MSIx enabled!\");\n\t\t\t\tcard->msix_enable = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pci_enable_msi(pdev) != 0)\n\t\tpci_disable_msi(pdev);\n\telse\n\t\tcard->msi_enable = 1;\n\n\tmwifiex_dbg(adapter, INFO, \"msi_enable = %d\\n\", card->msi_enable);\n\n\tcard->share_irq_ctx.dev = pdev;\n\tcard->share_irq_ctx.msg_id = -1;\n\tret = request_irq(pdev->irq, mwifiex_pcie_interrupt, IRQF_SHARED,\n\t\t\t  \"MRVL_PCIE\", &card->share_irq_ctx);\n\tif (ret) {\n\t\tpr_err(\"request_irq failed: ret=%d\\n\", ret);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void mwifiex_pcie_get_fw_name(struct mwifiex_adapter *adapter)\n{\n\tint revision_id = 0;\n\tint version, magic;\n\tstruct pcie_service_card *card = adapter->card;\n\n\tswitch (card->dev->device) {\n\tcase PCIE_DEVICE_ID_MARVELL_88W8766P:\n\t\tstrcpy(adapter->fw_name, PCIE8766_DEFAULT_FW_NAME);\n\t\tbreak;\n\tcase PCIE_DEVICE_ID_MARVELL_88W8897:\n\t\tmwifiex_write_reg(adapter, 0x0c58, 0x80c00000);\n\t\tmwifiex_read_reg(adapter, 0x0c58, &revision_id);\n\t\trevision_id &= 0xff00;\n\t\tswitch (revision_id) {\n\t\tcase PCIE8897_A0:\n\t\t\tstrcpy(adapter->fw_name, PCIE8897_A0_FW_NAME);\n\t\t\tbreak;\n\t\tcase PCIE8897_B0:\n\t\t\tstrcpy(adapter->fw_name, PCIE8897_B0_FW_NAME);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(adapter->fw_name, PCIE8897_DEFAULT_FW_NAME);\n\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PCIE_DEVICE_ID_MARVELL_88W8997:\n\t\tmwifiex_read_reg(adapter, 0x8, &revision_id);\n\t\tmwifiex_read_reg(adapter, 0x0cd0, &version);\n\t\tmwifiex_read_reg(adapter, 0x0cd4, &magic);\n\t\trevision_id &= 0xff;\n\t\tversion &= 0x7;\n\t\tmagic &= 0xff;\n\t\tif (revision_id == PCIE8997_A1 &&\n\t\t    magic == CHIP_MAGIC_VALUE &&\n\t\t    version == CHIP_VER_PCIEUART)\n\t\t\tstrcpy(adapter->fw_name, PCIEUART8997_FW_NAME_V4);\n\t\telse\n\t\t\tstrcpy(adapter->fw_name, PCIEUSB8997_FW_NAME_V4);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic int mwifiex_register_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\n\t \n\tcard->adapter = adapter;\n\n\tif (mwifiex_pcie_request_irq(adapter))\n\t\treturn -1;\n\n\tadapter->tx_buf_size = card->pcie.tx_buf_size;\n\tadapter->mem_type_mapping_tbl = card->pcie.mem_type_mapping_tbl;\n\tadapter->num_mem_types = card->pcie.num_mem_types;\n\tadapter->ext_scan = card->pcie.can_ext_scan;\n\tmwifiex_pcie_get_fw_name(adapter);\n\n\treturn 0;\n}\n\n \nstatic void mwifiex_unregister_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct pci_dev *pdev = card->dev;\n\tint i;\n\n\tif (card->msix_enable) {\n\t\tfor (i = 0; i < MWIFIEX_NUM_MSIX_VECTORS; i++)\n\t\t\tsynchronize_irq(card->msix_entries[i].vector);\n\n\t\tfor (i = 0; i < MWIFIEX_NUM_MSIX_VECTORS; i++)\n\t\t\tfree_irq(card->msix_entries[i].vector,\n\t\t\t\t &card->msix_ctx[i]);\n\n\t\tcard->msix_enable = 0;\n\t\tpci_disable_msix(pdev);\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"%s(): calling free_irq()\\n\", __func__);\n\t\tfree_irq(card->dev->irq, &card->share_irq_ctx);\n\n\t\tif (card->msi_enable)\n\t\t\tpci_disable_msi(pdev);\n\t}\n\tcard->adapter = NULL;\n}\n\n \nstatic void mwifiex_pcie_up_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct pci_dev *pdev = card->dev;\n\n\t \n\tadapter->tx_buf_size = card->pcie.tx_buf_size;\n\n\tmwifiex_pcie_alloc_buffers(adapter);\n\n\tpci_set_master(pdev);\n}\n\n \nstatic void mwifiex_pcie_down_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tconst struct mwifiex_pcie_card_reg *reg = card->pcie.reg;\n\tstruct pci_dev *pdev = card->dev;\n\n\tif (mwifiex_write_reg(adapter, reg->drv_rdy, 0x00000000))\n\t\tmwifiex_dbg(adapter, ERROR, \"Failed to write driver not-ready signature\\n\");\n\n\tpci_clear_master(pdev);\n\n\tadapter->seq_num = 0;\n\n\tmwifiex_pcie_free_buffers(adapter);\n}\n\nstatic struct mwifiex_if_ops pcie_ops = {\n\t.init_if =\t\t\tmwifiex_init_pcie,\n\t.cleanup_if =\t\t\tmwifiex_cleanup_pcie,\n\t.check_fw_status =\t\tmwifiex_check_fw_status,\n\t.check_winner_status =          mwifiex_check_winner_status,\n\t.prog_fw =\t\t\tmwifiex_prog_fw_w_helper,\n\t.register_dev =\t\t\tmwifiex_register_dev,\n\t.unregister_dev =\t\tmwifiex_unregister_dev,\n\t.enable_int =\t\t\tmwifiex_pcie_enable_host_int,\n\t.disable_int =\t\t\tmwifiex_pcie_disable_host_int_noerr,\n\t.process_int_status =\t\tmwifiex_process_int_status,\n\t.host_to_card =\t\t\tmwifiex_pcie_host_to_card,\n\t.wakeup =\t\t\tmwifiex_pm_wakeup_card,\n\t.wakeup_complete =\t\tmwifiex_pm_wakeup_card_complete,\n\n\t \n\t.cmdrsp_complete =\t\tmwifiex_pcie_cmdrsp_complete,\n\t.event_complete =\t\tmwifiex_pcie_event_complete,\n\t.update_mp_end_port =\t\tNULL,\n\t.cleanup_mpa_buf =\t\tNULL,\n\t.init_fw_port =\t\t\tmwifiex_pcie_init_fw_port,\n\t.clean_pcie_ring =\t\tmwifiex_clean_pcie_ring_buf,\n\t.card_reset =\t\t\tmwifiex_pcie_card_reset,\n\t.reg_dump =\t\t\tmwifiex_pcie_reg_dump,\n\t.device_dump =\t\t\tmwifiex_pcie_device_dump,\n\t.down_dev =\t\t\tmwifiex_pcie_down_dev,\n\t.up_dev =\t\t\tmwifiex_pcie_up_dev,\n};\n\nmodule_pci_driver(mwifiex_pcie);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell WiFi-Ex PCI-Express Driver version \" PCIE_VERSION);\nMODULE_VERSION(PCIE_VERSION);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}