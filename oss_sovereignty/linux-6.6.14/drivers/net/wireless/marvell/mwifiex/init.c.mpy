{
  "module_name": "init.c",
  "hash_id": "e8bea11aed65812490d5ee9d2375f1b6727368fac3169af3ef1f783482fe204c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/init.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n\n \nstatic int mwifiex_add_bss_prio_tbl(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_bss_prio_node *bss_prio;\n\tstruct mwifiex_bss_prio_tbl *tbl = adapter->bss_prio_tbl;\n\n\tbss_prio = kzalloc(sizeof(struct mwifiex_bss_prio_node), GFP_KERNEL);\n\tif (!bss_prio)\n\t\treturn -ENOMEM;\n\n\tbss_prio->priv = priv;\n\tINIT_LIST_HEAD(&bss_prio->list);\n\n\tspin_lock_bh(&tbl[priv->bss_priority].bss_prio_lock);\n\tlist_add_tail(&bss_prio->list, &tbl[priv->bss_priority].bss_prio_head);\n\tspin_unlock_bh(&tbl[priv->bss_priority].bss_prio_lock);\n\n\treturn 0;\n}\n\nstatic void wakeup_timer_fn(struct timer_list *t)\n{\n\tstruct mwifiex_adapter *adapter = from_timer(adapter, t, wakeup_timer);\n\n\tmwifiex_dbg(adapter, ERROR, \"Firmware wakeup failed\\n\");\n\tadapter->hw_status = MWIFIEX_HW_STATUS_RESET;\n\tmwifiex_cancel_all_pending_cmd(adapter);\n\n\tif (adapter->if_ops.card_reset)\n\t\tadapter->if_ops.card_reset(adapter);\n}\n\nstatic void fw_dump_work(struct work_struct *work)\n{\n\tstruct mwifiex_adapter *adapter =\n\t\tcontainer_of(work, struct mwifiex_adapter, devdump_work.work);\n\n\tmwifiex_upload_device_dump(adapter);\n}\n\n \nint mwifiex_init_priv(struct mwifiex_private *priv)\n{\n\tu32 i;\n\n\tpriv->media_connected = false;\n\teth_broadcast_addr(priv->curr_addr);\n\tpriv->port_open = false;\n\tpriv->usb_port = MWIFIEX_USB_EP_DATA;\n\tpriv->pkt_tx_ctrl = 0;\n\tpriv->bss_mode = NL80211_IFTYPE_UNSPECIFIED;\n\tpriv->data_rate = 0;\t \n\tpriv->is_data_rate_auto = true;\n\tpriv->bcn_avg_factor = DEFAULT_BCN_AVG_FACTOR;\n\tpriv->data_avg_factor = DEFAULT_DATA_AVG_FACTOR;\n\n\tpriv->sec_info.wep_enabled = 0;\n\tpriv->sec_info.authentication_mode = NL80211_AUTHTYPE_OPEN_SYSTEM;\n\tpriv->sec_info.encryption_mode = 0;\n\tfor (i = 0; i < ARRAY_SIZE(priv->wep_key); i++)\n\t\tmemset(&priv->wep_key[i], 0, sizeof(struct mwifiex_wep_key));\n\tpriv->wep_key_curr_index = 0;\n\tpriv->curr_pkt_filter = HostCmd_ACT_MAC_DYNAMIC_BW_ENABLE |\n\t\t\t\tHostCmd_ACT_MAC_RX_ON | HostCmd_ACT_MAC_TX_ON |\n\t\t\t\tHostCmd_ACT_MAC_ETHERNETII_ENABLE;\n\n\tpriv->beacon_period = 100;  \n\tpriv->attempted_bss_desc = NULL;\n\tmemset(&priv->curr_bss_params, 0, sizeof(priv->curr_bss_params));\n\tpriv->listen_interval = MWIFIEX_DEFAULT_LISTEN_INTERVAL;\n\n\tmemset(&priv->prev_ssid, 0, sizeof(priv->prev_ssid));\n\tmemset(&priv->prev_bssid, 0, sizeof(priv->prev_bssid));\n\tmemset(&priv->assoc_rsp_buf, 0, sizeof(priv->assoc_rsp_buf));\n\tpriv->assoc_rsp_size = 0;\n\tpriv->adhoc_channel = DEFAULT_AD_HOC_CHANNEL;\n\tpriv->atim_window = 0;\n\tpriv->adhoc_state = ADHOC_IDLE;\n\tpriv->tx_power_level = 0;\n\tpriv->max_tx_power_level = 0;\n\tpriv->min_tx_power_level = 0;\n\tpriv->tx_ant = 0;\n\tpriv->rx_ant = 0;\n\tpriv->tx_rate = 0;\n\tpriv->rxpd_htinfo = 0;\n\tpriv->rxpd_rate = 0;\n\tpriv->rate_bitmap = 0;\n\tpriv->data_rssi_last = 0;\n\tpriv->data_rssi_avg = 0;\n\tpriv->data_nf_avg = 0;\n\tpriv->data_nf_last = 0;\n\tpriv->bcn_rssi_last = 0;\n\tpriv->bcn_rssi_avg = 0;\n\tpriv->bcn_nf_avg = 0;\n\tpriv->bcn_nf_last = 0;\n\tmemset(&priv->wpa_ie, 0, sizeof(priv->wpa_ie));\n\tmemset(&priv->aes_key, 0, sizeof(priv->aes_key));\n\tpriv->wpa_ie_len = 0;\n\tpriv->wpa_is_gtk_set = false;\n\n\tmemset(&priv->assoc_tlv_buf, 0, sizeof(priv->assoc_tlv_buf));\n\tpriv->assoc_tlv_buf_len = 0;\n\tmemset(&priv->wps, 0, sizeof(priv->wps));\n\tmemset(&priv->gen_ie_buf, 0, sizeof(priv->gen_ie_buf));\n\tpriv->gen_ie_buf_len = 0;\n\tmemset(priv->vs_ie, 0, sizeof(priv->vs_ie));\n\n\tpriv->wmm_required = true;\n\tpriv->wmm_enabled = false;\n\tpriv->wmm_qosinfo = 0;\n\tpriv->curr_bcn_buf = NULL;\n\tpriv->curr_bcn_size = 0;\n\tpriv->wps_ie = NULL;\n\tpriv->wps_ie_len = 0;\n\tpriv->ap_11n_enabled = 0;\n\tmemset(&priv->roc_cfg, 0, sizeof(priv->roc_cfg));\n\n\tpriv->scan_block = false;\n\n\tpriv->csa_chan = 0;\n\tpriv->csa_expire_time = 0;\n\tpriv->del_list_idx = 0;\n\tpriv->hs2_enabled = false;\n\tpriv->check_tdls_tx = false;\n\tmemcpy(priv->tos_to_tid_inv, tos_to_tid_inv, MAX_NUM_TID);\n\n\tmwifiex_init_11h_params(priv);\n\n\treturn mwifiex_add_bss_prio_tbl(priv);\n}\n\n \nstatic int mwifiex_allocate_adapter(struct mwifiex_adapter *adapter)\n{\n\tint ret;\n\n\t \n\tret = mwifiex_alloc_cmd_buffer(adapter);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to alloc cmd buffer\\n\",\n\t\t\t    __func__);\n\t\treturn -1;\n\t}\n\n\tadapter->sleep_cfm =\n\t\tdev_alloc_skb(sizeof(struct mwifiex_opt_sleep_confirm)\n\t\t\t      + INTF_HEADER_LEN);\n\n\tif (!adapter->sleep_cfm) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: failed to alloc sleep cfm\\t\"\n\t\t\t    \" cmd buffer\\n\", __func__);\n\t\treturn -1;\n\t}\n\tskb_reserve(adapter->sleep_cfm, INTF_HEADER_LEN);\n\n\treturn 0;\n}\n\n \nstatic void mwifiex_init_adapter(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_opt_sleep_confirm *sleep_cfm_buf = NULL;\n\n\tskb_put(adapter->sleep_cfm, sizeof(struct mwifiex_opt_sleep_confirm));\n\n\tadapter->cmd_sent = false;\n\n\tif (adapter->iface_type == MWIFIEX_SDIO)\n\t\tadapter->data_sent = true;\n\telse\n\t\tadapter->data_sent = false;\n\n\tif (adapter->iface_type == MWIFIEX_USB)\n\t\tadapter->intf_hdr_len = 0;\n\telse\n\t\tadapter->intf_hdr_len = INTF_HEADER_LEN;\n\n\tadapter->cmd_resp_received = false;\n\tadapter->event_received = false;\n\tadapter->data_received = false;\n\n\tclear_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags);\n\n\tadapter->hw_status = MWIFIEX_HW_STATUS_INITIALIZING;\n\n\tadapter->ps_mode = MWIFIEX_802_11_POWER_MODE_CAM;\n\tadapter->ps_state = PS_STATE_AWAKE;\n\tadapter->need_to_wakeup = false;\n\n\tadapter->scan_mode = HostCmd_BSS_MODE_ANY;\n\tadapter->specific_scan_time = MWIFIEX_SPECIFIC_SCAN_CHAN_TIME;\n\tadapter->active_scan_time = MWIFIEX_ACTIVE_SCAN_CHAN_TIME;\n\tadapter->passive_scan_time = MWIFIEX_PASSIVE_SCAN_CHAN_TIME;\n\tadapter->scan_chan_gap_time = MWIFIEX_DEF_SCAN_CHAN_GAP_TIME;\n\n\tadapter->scan_probes = 1;\n\n\tadapter->multiple_dtim = 1;\n\n\tadapter->local_listen_interval = 0;\t \n\n\tadapter->is_deep_sleep = false;\n\n\tadapter->delay_null_pkt = false;\n\tadapter->delay_to_ps = 1000;\n\tadapter->enhanced_ps_mode = PS_MODE_AUTO;\n\n\tadapter->gen_null_pkt = false;\t \n\tadapter->pps_uapsd_mode = false;  \n\tadapter->pm_wakeup_card_req = false;\n\n\tadapter->pm_wakeup_fw_try = false;\n\n\tadapter->curr_tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K;\n\n\tclear_bit(MWIFIEX_IS_HS_CONFIGURED, &adapter->work_flags);\n\tadapter->hs_cfg.conditions = cpu_to_le32(HS_CFG_COND_DEF);\n\tadapter->hs_cfg.gpio = HS_CFG_GPIO_DEF;\n\tadapter->hs_cfg.gap = HS_CFG_GAP_DEF;\n\tadapter->hs_activated = false;\n\n\tmemset(adapter->event_body, 0, sizeof(adapter->event_body));\n\tadapter->hw_dot_11n_dev_cap = 0;\n\tadapter->hw_dev_mcs_support = 0;\n\tadapter->sec_chan_offset = 0;\n\tadapter->adhoc_11n_enabled = false;\n\n\tmwifiex_wmm_init(adapter);\n\tatomic_set(&adapter->tx_hw_pending, 0);\n\n\tsleep_cfm_buf = (struct mwifiex_opt_sleep_confirm *)\n\t\t\t\t\tadapter->sleep_cfm->data;\n\tmemset(sleep_cfm_buf, 0, adapter->sleep_cfm->len);\n\tsleep_cfm_buf->command = cpu_to_le16(HostCmd_CMD_802_11_PS_MODE_ENH);\n\tsleep_cfm_buf->size = cpu_to_le16(adapter->sleep_cfm->len);\n\tsleep_cfm_buf->result = 0;\n\tsleep_cfm_buf->action = cpu_to_le16(SLEEP_CONFIRM);\n\tsleep_cfm_buf->resp_ctrl = cpu_to_le16(RESP_NEEDED);\n\n\tmemset(&adapter->sleep_period, 0, sizeof(adapter->sleep_period));\n\tadapter->tx_lock_flag = false;\n\tadapter->null_pkt_interval = 0;\n\tadapter->fw_bands = 0;\n\tadapter->config_bands = 0;\n\tadapter->adhoc_start_band = 0;\n\tadapter->fw_release_number = 0;\n\tadapter->fw_cap_info = 0;\n\tmemset(&adapter->upld_buf, 0, sizeof(adapter->upld_buf));\n\tadapter->event_cause = 0;\n\tadapter->region_code = 0;\n\tadapter->bcn_miss_time_out = DEFAULT_BCN_MISS_TIMEOUT;\n\tadapter->adhoc_awake_period = 0;\n\tmemset(&adapter->arp_filter, 0, sizeof(adapter->arp_filter));\n\tadapter->arp_filter_size = 0;\n\tadapter->max_mgmt_ie_index = MAX_MGMT_IE_INDEX;\n\tadapter->mfg_mode = mfg_mode;\n\tadapter->key_api_major_ver = 0;\n\tadapter->key_api_minor_ver = 0;\n\teth_broadcast_addr(adapter->perm_addr);\n\tadapter->iface_limit.sta_intf = MWIFIEX_MAX_STA_NUM;\n\tadapter->iface_limit.uap_intf = MWIFIEX_MAX_UAP_NUM;\n\tadapter->iface_limit.p2p_intf = MWIFIEX_MAX_P2P_NUM;\n\tadapter->active_scan_triggered = false;\n\ttimer_setup(&adapter->wakeup_timer, wakeup_timer_fn, 0);\n\tadapter->devdump_len = 0;\n\tINIT_DELAYED_WORK(&adapter->devdump_work, fw_dump_work);\n}\n\n \nvoid mwifiex_set_trans_start(struct net_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < dev->num_tx_queues; i++)\n\t\ttxq_trans_cond_update(netdev_get_tx_queue(dev, i));\n\n\tnetif_trans_update(dev);\n}\n\n \nvoid mwifiex_wake_up_net_dev_queue(struct net_device *netdev,\n\t\t\t\t\tstruct mwifiex_adapter *adapter)\n{\n\tspin_lock_bh(&adapter->queue_lock);\n\tnetif_tx_wake_all_queues(netdev);\n\tspin_unlock_bh(&adapter->queue_lock);\n}\n\n \nvoid mwifiex_stop_net_dev_queue(struct net_device *netdev,\n\t\t\t\t\tstruct mwifiex_adapter *adapter)\n{\n\tspin_lock_bh(&adapter->queue_lock);\n\tnetif_tx_stop_all_queues(netdev);\n\tspin_unlock_bh(&adapter->queue_lock);\n}\n\n \nstatic void mwifiex_invalidate_lists(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\ts32 i, j;\n\n\tlist_del(&adapter->cmd_free_q);\n\tlist_del(&adapter->cmd_pending_q);\n\tlist_del(&adapter->scan_pending_q);\n\n\tfor (i = 0; i < adapter->priv_num; i++)\n\t\tlist_del(&adapter->bss_prio_tbl[i].bss_prio_head);\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (adapter->priv[i]) {\n\t\t\tpriv = adapter->priv[i];\n\t\t\tfor (j = 0; j < MAX_NUM_TID; ++j)\n\t\t\t\tlist_del(&priv->wmm.tid_tbl_ptr[j].ra_list);\n\t\t\tlist_del(&priv->tx_ba_stream_tbl_ptr);\n\t\t\tlist_del(&priv->rx_reorder_tbl_ptr);\n\t\t\tlist_del(&priv->sta_list);\n\t\t\tlist_del(&priv->auto_tdls_list);\n\t\t}\n\t}\n}\n\n \nstatic void\nmwifiex_adapter_cleanup(struct mwifiex_adapter *adapter)\n{\n\tdel_timer(&adapter->wakeup_timer);\n\tcancel_delayed_work_sync(&adapter->devdump_work);\n\tmwifiex_cancel_all_pending_cmd(adapter);\n\twake_up_interruptible(&adapter->cmd_wait_q.wait);\n\twake_up_interruptible(&adapter->hs_activate_wait_q);\n}\n\nvoid mwifiex_free_cmd_buffers(struct mwifiex_adapter *adapter)\n{\n\tmwifiex_invalidate_lists(adapter);\n\n\t \n\tmwifiex_dbg(adapter, INFO, \"info: free cmd buffer\\n\");\n\tmwifiex_free_cmd_buffer(adapter);\n\n\tif (adapter->sleep_cfm)\n\t\tdev_kfree_skb_any(adapter->sleep_cfm);\n}\n\n \nint mwifiex_init_lock_list(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\ts32 i, j;\n\n\tspin_lock_init(&adapter->int_lock);\n\tspin_lock_init(&adapter->main_proc_lock);\n\tspin_lock_init(&adapter->mwifiex_cmd_lock);\n\tspin_lock_init(&adapter->queue_lock);\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (adapter->priv[i]) {\n\t\t\tpriv = adapter->priv[i];\n\t\t\tspin_lock_init(&priv->wmm.ra_list_spinlock);\n\t\t\tspin_lock_init(&priv->curr_bcn_buf_lock);\n\t\t\tspin_lock_init(&priv->sta_list_spinlock);\n\t\t\tspin_lock_init(&priv->auto_tdls_lock);\n\t\t}\n\t}\n\n\t \n\tINIT_LIST_HEAD(&adapter->cmd_free_q);\n\t \n\tINIT_LIST_HEAD(&adapter->cmd_pending_q);\n\t \n\tINIT_LIST_HEAD(&adapter->scan_pending_q);\n\n\tspin_lock_init(&adapter->cmd_free_q_lock);\n\tspin_lock_init(&adapter->cmd_pending_q_lock);\n\tspin_lock_init(&adapter->scan_pending_q_lock);\n\tspin_lock_init(&adapter->rx_proc_lock);\n\n\tskb_queue_head_init(&adapter->rx_data_q);\n\tskb_queue_head_init(&adapter->tx_data_q);\n\n\tfor (i = 0; i < adapter->priv_num; ++i) {\n\t\tINIT_LIST_HEAD(&adapter->bss_prio_tbl[i].bss_prio_head);\n\t\tspin_lock_init(&adapter->bss_prio_tbl[i].bss_prio_lock);\n\t}\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (!adapter->priv[i])\n\t\t\tcontinue;\n\t\tpriv = adapter->priv[i];\n\t\tfor (j = 0; j < MAX_NUM_TID; ++j)\n\t\t\tINIT_LIST_HEAD(&priv->wmm.tid_tbl_ptr[j].ra_list);\n\t\tINIT_LIST_HEAD(&priv->tx_ba_stream_tbl_ptr);\n\t\tINIT_LIST_HEAD(&priv->rx_reorder_tbl_ptr);\n\t\tINIT_LIST_HEAD(&priv->sta_list);\n\t\tINIT_LIST_HEAD(&priv->auto_tdls_list);\n\t\tskb_queue_head_init(&priv->tdls_txq);\n\t\tskb_queue_head_init(&priv->bypass_txq);\n\n\t\tspin_lock_init(&priv->tx_ba_stream_tbl_lock);\n\t\tspin_lock_init(&priv->rx_reorder_tbl_lock);\n\n\t\tspin_lock_init(&priv->ack_status_lock);\n\t\tidr_init(&priv->ack_status_frames);\n\t}\n\n\treturn 0;\n}\n\n \nint mwifiex_init_fw(struct mwifiex_adapter *adapter)\n{\n\tint ret;\n\tstruct mwifiex_private *priv;\n\tu8 i, first_sta = true;\n\tint is_cmd_pend_q_empty;\n\n\tadapter->hw_status = MWIFIEX_HW_STATUS_INITIALIZING;\n\n\t \n\tret = mwifiex_allocate_adapter(adapter);\n\tif (ret)\n\t\treturn -1;\n\n\t \n\tmwifiex_init_adapter(adapter);\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (adapter->priv[i]) {\n\t\t\tpriv = adapter->priv[i];\n\n\t\t\t \n\t\t\tret = mwifiex_init_priv(priv);\n\t\t\tif (ret)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tif (adapter->mfg_mode) {\n\t\tadapter->hw_status = MWIFIEX_HW_STATUS_READY;\n\t\tret = -EINPROGRESS;\n\t} else {\n\t\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\t\tif (adapter->priv[i]) {\n\t\t\t\tret = mwifiex_sta_init_cmd(adapter->priv[i],\n\t\t\t\t\t\t\t   first_sta, true);\n\t\t\t\tif (ret == -1)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tfirst_sta = false;\n\t\t\t}\n\n\n\n\t\t}\n\t}\n\n\tspin_lock_bh(&adapter->cmd_pending_q_lock);\n\tis_cmd_pend_q_empty = list_empty(&adapter->cmd_pending_q);\n\tspin_unlock_bh(&adapter->cmd_pending_q_lock);\n\tif (!is_cmd_pend_q_empty) {\n\t\t \n\t\tif (mwifiex_main_process(adapter) != -1)\n\t\t\tret = -EINPROGRESS;\n\t} else {\n\t\tadapter->hw_status = MWIFIEX_HW_STATUS_READY;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void mwifiex_delete_bss_prio_tbl(struct mwifiex_private *priv)\n{\n\tint i;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_bss_prio_node *bssprio_node, *tmp_node;\n\tstruct list_head *head;\n\tspinlock_t *lock;  \n\n\tfor (i = 0; i < adapter->priv_num; ++i) {\n\t\thead = &adapter->bss_prio_tbl[i].bss_prio_head;\n\t\tlock = &adapter->bss_prio_tbl[i].bss_prio_lock;\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: delete BSS priority table,\\t\"\n\t\t\t    \"bss_type = %d, bss_num = %d, i = %d,\\t\"\n\t\t\t    \"head = %p\\n\",\n\t\t\t    priv->bss_type, priv->bss_num, i, head);\n\n\t\t{\n\t\t\tspin_lock_bh(lock);\n\t\t\tlist_for_each_entry_safe(bssprio_node, tmp_node, head,\n\t\t\t\t\t\t list) {\n\t\t\t\tif (bssprio_node->priv == priv) {\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"info: Delete\\t\"\n\t\t\t\t\t\t    \"node %p, next = %p\\n\",\n\t\t\t\t\t\t    bssprio_node, tmp_node);\n\t\t\t\t\tlist_del(&bssprio_node->list);\n\t\t\t\t\tkfree(bssprio_node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_bh(lock);\n\t\t}\n\t}\n}\n\n \nvoid mwifiex_free_priv(struct mwifiex_private *priv)\n{\n\tmwifiex_clean_txrx(priv);\n\tmwifiex_delete_bss_prio_tbl(priv);\n\tmwifiex_free_curr_bcn(priv);\n}\n\n \nvoid\nmwifiex_shutdown_drv(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\ts32 i;\n\tstruct sk_buff *skb;\n\n\t \n\tif (adapter->hw_status == MWIFIEX_HW_STATUS_NOT_READY)\n\t\treturn;\n\n\t \n\tif (adapter->curr_cmd) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"curr_cmd is still in processing\\n\");\n\t\tdel_timer_sync(&adapter->cmd_timer);\n\t\tmwifiex_recycle_cmd_node(adapter, adapter->curr_cmd);\n\t\tadapter->curr_cmd = NULL;\n\t}\n\n\t \n\tmwifiex_dbg(adapter, MSG,\n\t\t    \"info: shutdown mwifiex...\\n\");\n\n\t \n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (adapter->priv[i]) {\n\t\t\tpriv = adapter->priv[i];\n\n\t\t\tmwifiex_clean_auto_tdls(priv);\n\t\t\tmwifiex_abort_cac(priv);\n\t\t\tmwifiex_free_priv(priv);\n\t\t}\n\t}\n\n\tatomic_set(&adapter->tx_queued, 0);\n\twhile ((skb = skb_dequeue(&adapter->tx_data_q)))\n\t\tmwifiex_write_data_complete(adapter, skb, 0, 0);\n\n\tspin_lock_bh(&adapter->rx_proc_lock);\n\n\twhile ((skb = skb_dequeue(&adapter->rx_data_q))) {\n\t\tstruct mwifiex_rxinfo *rx_info = MWIFIEX_SKB_RXCB(skb);\n\n\t\tatomic_dec(&adapter->rx_pending);\n\t\tpriv = adapter->priv[rx_info->bss_num];\n\t\tif (priv)\n\t\t\tpriv->stats.rx_dropped++;\n\n\t\tdev_kfree_skb_any(skb);\n\t}\n\n\tspin_unlock_bh(&adapter->rx_proc_lock);\n\n\tmwifiex_adapter_cleanup(adapter);\n\n\tadapter->hw_status = MWIFIEX_HW_STATUS_NOT_READY;\n}\n\n \nint mwifiex_dnld_fw(struct mwifiex_adapter *adapter,\n\t\t    struct mwifiex_fw_image *pmfw)\n{\n\tint ret;\n\tu32 poll_num = 1;\n\n\t \n\tret = adapter->if_ops.check_fw_status(adapter, poll_num);\n\tif (!ret) {\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"WLAN FW already running! Skip FW dnld\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (adapter->if_ops.check_winner_status) {\n\t\tadapter->winner = 0;\n\t\tret = adapter->if_ops.check_winner_status(adapter);\n\n\t\tpoll_num = MAX_FIRMWARE_POLL_TRIES;\n\t\tif (ret) {\n\t\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t\t    \"WLAN read winner status failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!adapter->winner) {\n\t\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t\t    \"WLAN is not the winner! Skip FW dnld\\n\");\n\t\t\tgoto poll_fw;\n\t\t}\n\t}\n\n\tif (pmfw) {\n\t\t \n\t\tret = adapter->if_ops.prog_fw(adapter, pmfw);\n\t\tif (ret) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"prog_fw failed ret=%#x\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\npoll_fw:\n\t \n\tret = adapter->if_ops.check_fw_status(adapter, poll_num);\n\tif (ret)\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"FW failed to be active in time\\n\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mwifiex_dnld_fw);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}