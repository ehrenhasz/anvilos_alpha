{
  "module_name": "uap_cmd.c",
  "hash_id": "03d62b9ae1274bddb80b428414c2c17b2230323a279a13a21110c7c678cf64f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/uap_cmd.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"11ac.h\"\n#include \"11n.h\"\n\n \nint mwifiex_set_secure_params(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_uap_bss_param *bss_config,\n\t\t\t      struct cfg80211_ap_settings *params) {\n\tint i;\n\tstruct mwifiex_wep_key wep_key;\n\n\tif (!params->privacy) {\n\t\tbss_config->protocol = PROTOCOL_NO_SECURITY;\n\t\tbss_config->key_mgmt = KEY_MGMT_NONE;\n\t\tbss_config->wpa_cfg.length = 0;\n\t\tpriv->sec_info.wep_enabled = 0;\n\t\tpriv->sec_info.wpa_enabled = 0;\n\t\tpriv->sec_info.wpa2_enabled = 0;\n\n\t\treturn 0;\n\t}\n\n\tswitch (params->auth_type) {\n\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\t\tbss_config->auth_mode = WLAN_AUTH_OPEN;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_SHARED_KEY:\n\t\tbss_config->auth_mode = WLAN_AUTH_SHARED_KEY;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_NETWORK_EAP:\n\t\tbss_config->auth_mode = WLAN_AUTH_LEAP;\n\t\tbreak;\n\tdefault:\n\t\tbss_config->auth_mode = MWIFIEX_AUTH_MODE_AUTO;\n\t\tbreak;\n\t}\n\n\tbss_config->key_mgmt_operation |= KEY_MGMT_ON_HOST;\n\n\tfor (i = 0; i < params->crypto.n_akm_suites; i++) {\n\t\tswitch (params->crypto.akm_suites[i]) {\n\t\tcase WLAN_AKM_SUITE_8021X:\n\t\t\tif (params->crypto.wpa_versions &\n\t\t\t    NL80211_WPA_VERSION_1) {\n\t\t\t\tbss_config->protocol = PROTOCOL_WPA;\n\t\t\t\tbss_config->key_mgmt = KEY_MGMT_EAP;\n\t\t\t}\n\t\t\tif (params->crypto.wpa_versions &\n\t\t\t    NL80211_WPA_VERSION_2) {\n\t\t\t\tbss_config->protocol |= PROTOCOL_WPA2;\n\t\t\t\tbss_config->key_mgmt = KEY_MGMT_EAP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_PSK:\n\t\t\tif (params->crypto.wpa_versions &\n\t\t\t    NL80211_WPA_VERSION_1) {\n\t\t\t\tbss_config->protocol = PROTOCOL_WPA;\n\t\t\t\tbss_config->key_mgmt = KEY_MGMT_PSK;\n\t\t\t}\n\t\t\tif (params->crypto.wpa_versions &\n\t\t\t    NL80211_WPA_VERSION_2) {\n\t\t\t\tbss_config->protocol |= PROTOCOL_WPA2;\n\t\t\t\tbss_config->key_mgmt = KEY_MGMT_PSK;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 0; i < params->crypto.n_ciphers_pairwise; i++) {\n\t\tswitch (params->crypto.ciphers_pairwise[i]) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tif (params->crypto.wpa_versions & NL80211_WPA_VERSION_1)\n\t\t\t\tbss_config->wpa_cfg.pairwise_cipher_wpa |=\n\t\t\t\t\t\t\t\tCIPHER_TKIP;\n\t\t\tif (params->crypto.wpa_versions & NL80211_WPA_VERSION_2)\n\t\t\t\tbss_config->wpa_cfg.pairwise_cipher_wpa2 |=\n\t\t\t\t\t\t\t\tCIPHER_TKIP;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tif (params->crypto.wpa_versions & NL80211_WPA_VERSION_1)\n\t\t\t\tbss_config->wpa_cfg.pairwise_cipher_wpa |=\n\t\t\t\t\t\t\t\tCIPHER_AES_CCMP;\n\t\t\tif (params->crypto.wpa_versions & NL80211_WPA_VERSION_2)\n\t\t\t\tbss_config->wpa_cfg.pairwise_cipher_wpa2 |=\n\t\t\t\t\t\t\t\tCIPHER_AES_CCMP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (params->crypto.cipher_group) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tif (priv->sec_info.wep_enabled) {\n\t\t\tbss_config->protocol = PROTOCOL_STATIC_WEP;\n\t\t\tbss_config->key_mgmt = KEY_MGMT_NONE;\n\t\t\tbss_config->wpa_cfg.length = 0;\n\n\t\t\tfor (i = 0; i < NUM_WEP_KEYS; i++) {\n\t\t\t\twep_key = priv->wep_key[i];\n\t\t\t\tbss_config->wep_cfg[i].key_index = i;\n\n\t\t\t\tif (priv->wep_key_curr_index == i)\n\t\t\t\t\tbss_config->wep_cfg[i].is_default = 1;\n\t\t\t\telse\n\t\t\t\t\tbss_config->wep_cfg[i].is_default = 0;\n\n\t\t\t\tbss_config->wep_cfg[i].length =\n\t\t\t\t\t\t\t     wep_key.key_length;\n\t\t\t\tmemcpy(&bss_config->wep_cfg[i].key,\n\t\t\t\t       &wep_key.key_material,\n\t\t\t\t       wep_key.key_length);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tbss_config->wpa_cfg.group_cipher = CIPHER_TKIP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tbss_config->wpa_cfg.group_cipher = CIPHER_AES_CCMP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nvoid\nmwifiex_set_ht_params(struct mwifiex_private *priv,\n\t\t      struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tconst u8 *ht_ie;\n\n\tif (!ISSUPP_11NENABLED(priv->adapter->fw_cap_info))\n\t\treturn;\n\n\tht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, params->beacon.tail,\n\t\t\t\t params->beacon.tail_len);\n\tif (ht_ie) {\n\t\tmemcpy(&bss_cfg->ht_cap, ht_ie + 2,\n\t\t       sizeof(struct ieee80211_ht_cap));\n\t\tpriv->ap_11n_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->ht_cap, 0, sizeof(struct ieee80211_ht_cap));\n\t\tbss_cfg->ht_cap.cap_info = cpu_to_le16(MWIFIEX_DEF_HT_CAP);\n\t\tbss_cfg->ht_cap.ampdu_params_info = MWIFIEX_DEF_AMPDU;\n\t}\n\n\treturn;\n}\n\n \nvoid mwifiex_set_vht_params(struct mwifiex_private *priv,\n\t\t\t    struct mwifiex_uap_bss_param *bss_cfg,\n\t\t\t    struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vht_ie;\n\n\tvht_ie = cfg80211_find_ie(WLAN_EID_VHT_CAPABILITY, params->beacon.tail,\n\t\t\t\t  params->beacon.tail_len);\n\tif (vht_ie) {\n\t\tmemcpy(&bss_cfg->vht_cap, vht_ie + 2,\n\t\t       sizeof(struct ieee80211_vht_cap));\n\t\tpriv->ap_11ac_enabled = 1;\n\t} else {\n\t\tpriv->ap_11ac_enabled = 0;\n\t}\n\n\treturn;\n}\n\n \nvoid mwifiex_set_tpc_params(struct mwifiex_private *priv,\n\t\t\t    struct mwifiex_uap_bss_param *bss_cfg,\n\t\t\t    struct cfg80211_ap_settings *params)\n{\n\tconst u8 *tpc_ie;\n\n\ttpc_ie = cfg80211_find_ie(WLAN_EID_TPC_REQUEST, params->beacon.tail,\n\t\t\t\t  params->beacon.tail_len);\n\tif (tpc_ie)\n\t\tbss_cfg->power_constraint = *(tpc_ie + 2);\n\telse\n\t\tbss_cfg->power_constraint = 0;\n}\n\n \nvoid mwifiex_set_vht_width(struct mwifiex_private *priv,\n\t\t\t   enum nl80211_chan_width width,\n\t\t\t   bool ap_11ac_enable)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_11ac_vht_cfg vht_cfg;\n\n\tvht_cfg.band_config = VHT_CFG_5GHZ;\n\tvht_cfg.cap_info = adapter->hw_dot_11ac_dev_cap;\n\n\tif (!ap_11ac_enable) {\n\t\tvht_cfg.mcs_tx_set = DISABLE_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DISABLE_VHT_MCS_SET;\n\t} else {\n\t\tvht_cfg.mcs_tx_set = DEFAULT_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DEFAULT_VHT_MCS_SET;\n\t}\n\n\tvht_cfg.misc_config  = VHT_CAP_UAP_ONLY;\n\n\tif (ap_11ac_enable && width >= NL80211_CHAN_WIDTH_80)\n\t\tvht_cfg.misc_config |= VHT_BW_80_160_80P80;\n\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11AC_CFG,\n\t\t\t HostCmd_ACT_GEN_SET, 0, &vht_cfg, true);\n\n\treturn;\n}\n\n \nvoid\nmwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES)\n\t\t\treturn;\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie) {\n\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES - rate_len)\n\t\t\treturn;\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\t}\n\n\treturn;\n}\n\n \nvoid mwifiex_set_sys_config_invalid_data(struct mwifiex_uap_bss_param *config)\n{\n\tconfig->bcast_ssid_ctl = 0x7F;\n\tconfig->radio_ctl = 0x7F;\n\tconfig->dtim_period = 0x7F;\n\tconfig->beacon_period = 0x7FFF;\n\tconfig->auth_mode = 0x7F;\n\tconfig->rts_threshold = 0x7FFF;\n\tconfig->frag_threshold = 0x7FFF;\n\tconfig->retry_limit = 0x7F;\n\tconfig->qos_info = 0xFF;\n}\n\n \nstatic void\nmwifiex_uap_bss_wpa(u8 **tlv_buf, void *cmd_buf, u16 *param_size)\n{\n\tstruct host_cmd_tlv_pwk_cipher *pwk_cipher;\n\tstruct host_cmd_tlv_gwk_cipher *gwk_cipher;\n\tstruct host_cmd_tlv_passphrase *passphrase;\n\tstruct host_cmd_tlv_akmp *tlv_akmp;\n\tstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\n\tu16 cmd_size = *param_size;\n\tu8 *tlv = *tlv_buf;\n\n\ttlv_akmp = (struct host_cmd_tlv_akmp *)tlv;\n\ttlv_akmp->header.type = cpu_to_le16(TLV_TYPE_UAP_AKMP);\n\ttlv_akmp->header.len = cpu_to_le16(sizeof(struct host_cmd_tlv_akmp) -\n\t\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\ttlv_akmp->key_mgmt_operation = cpu_to_le16(bss_cfg->key_mgmt_operation);\n\ttlv_akmp->key_mgmt = cpu_to_le16(bss_cfg->key_mgmt);\n\tcmd_size += sizeof(struct host_cmd_tlv_akmp);\n\ttlv += sizeof(struct host_cmd_tlv_akmp);\n\n\tif (bss_cfg->wpa_cfg.pairwise_cipher_wpa & VALID_CIPHER_BITMAP) {\n\t\tpwk_cipher = (struct host_cmd_tlv_pwk_cipher *)tlv;\n\t\tpwk_cipher->header.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);\n\t\tpwk_cipher->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_pwk_cipher) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tpwk_cipher->proto = cpu_to_le16(PROTOCOL_WPA);\n\t\tpwk_cipher->cipher = bss_cfg->wpa_cfg.pairwise_cipher_wpa;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t\ttlv += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t}\n\n\tif (bss_cfg->wpa_cfg.pairwise_cipher_wpa2 & VALID_CIPHER_BITMAP) {\n\t\tpwk_cipher = (struct host_cmd_tlv_pwk_cipher *)tlv;\n\t\tpwk_cipher->header.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);\n\t\tpwk_cipher->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_pwk_cipher) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tpwk_cipher->proto = cpu_to_le16(PROTOCOL_WPA2);\n\t\tpwk_cipher->cipher = bss_cfg->wpa_cfg.pairwise_cipher_wpa2;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t\ttlv += sizeof(struct host_cmd_tlv_pwk_cipher);\n\t}\n\n\tif (bss_cfg->wpa_cfg.group_cipher & VALID_CIPHER_BITMAP) {\n\t\tgwk_cipher = (struct host_cmd_tlv_gwk_cipher *)tlv;\n\t\tgwk_cipher->header.type = cpu_to_le16(TLV_TYPE_GWK_CIPHER);\n\t\tgwk_cipher->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_gwk_cipher) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tgwk_cipher->cipher = bss_cfg->wpa_cfg.group_cipher;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_gwk_cipher);\n\t\ttlv += sizeof(struct host_cmd_tlv_gwk_cipher);\n\t}\n\n\tif (bss_cfg->wpa_cfg.length) {\n\t\tpassphrase = (struct host_cmd_tlv_passphrase *)tlv;\n\t\tpassphrase->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_WPA_PASSPHRASE);\n\t\tpassphrase->header.len = cpu_to_le16(bss_cfg->wpa_cfg.length);\n\t\tmemcpy(passphrase->passphrase, bss_cfg->wpa_cfg.passphrase,\n\t\t       bss_cfg->wpa_cfg.length);\n\t\tcmd_size += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t    bss_cfg->wpa_cfg.length;\n\t\ttlv += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\tbss_cfg->wpa_cfg.length;\n\t}\n\n\t*param_size = cmd_size;\n\t*tlv_buf = tlv;\n\n\treturn;\n}\n\n \nvoid\nmwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tstatic const u8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n\t\t\treturn;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}\n \nstatic void\nmwifiex_uap_bss_wep(u8 **tlv_buf, void *cmd_buf, u16 *param_size)\n{\n\tstruct host_cmd_tlv_wep_key *wep_key;\n\tu16 cmd_size = *param_size;\n\tint i;\n\tu8 *tlv = *tlv_buf;\n\tstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\n\n\tfor (i = 0; i < NUM_WEP_KEYS; i++) {\n\t\tif (bss_cfg->wep_cfg[i].length &&\n\t\t    (bss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP40 ||\n\t\t     bss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP104)) {\n\t\t\twep_key = (struct host_cmd_tlv_wep_key *)tlv;\n\t\t\twep_key->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_WEP_KEY);\n\t\t\twep_key->header.len =\n\t\t\t\tcpu_to_le16(bss_cfg->wep_cfg[i].length + 2);\n\t\t\twep_key->key_index = bss_cfg->wep_cfg[i].key_index;\n\t\t\twep_key->is_default = bss_cfg->wep_cfg[i].is_default;\n\t\t\tmemcpy(wep_key->key, bss_cfg->wep_cfg[i].key,\n\t\t\t       bss_cfg->wep_cfg[i].length);\n\t\t\tcmd_size += sizeof(struct mwifiex_ie_types_header) + 2 +\n\t\t\t\t    bss_cfg->wep_cfg[i].length;\n\t\t\ttlv += sizeof(struct mwifiex_ie_types_header) + 2 +\n\t\t\t\t    bss_cfg->wep_cfg[i].length;\n\t\t}\n\t}\n\n\t*param_size = cmd_size;\n\t*tlv_buf = tlv;\n\n\treturn;\n}\n\n \nvoid mwifiex_config_uap_11d(struct mwifiex_private *priv,\n\t\t\t    struct cfg80211_beacon_data *beacon_data)\n{\n\tenum state_11d_t state_11d;\n\tconst u8 *country_ie;\n\n\tcountry_ie = cfg80211_find_ie(WLAN_EID_COUNTRY, beacon_data->tail,\n\t\t\t\t      beacon_data->tail_len);\n\tif (country_ie) {\n\t\t \n\t\tstate_11d = ENABLE_11D;\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\t     HostCmd_ACT_GEN_SET, DOT11D_I,\n\t\t\t\t     &state_11d, true)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"11D: failed to enable 11D\\n\");\n\t\t}\n\t}\n}\n\n \nstatic int\nmwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)\n{\n\tstruct host_cmd_tlv_mac_addr *mac_tlv;\n\tstruct host_cmd_tlv_dtim_period *dtim_period;\n\tstruct host_cmd_tlv_beacon_period *beacon_period;\n\tstruct host_cmd_tlv_ssid *ssid;\n\tstruct host_cmd_tlv_bcast_ssid *bcast_ssid;\n\tstruct host_cmd_tlv_channel_band *chan_band;\n\tstruct host_cmd_tlv_frag_threshold *frag_threshold;\n\tstruct host_cmd_tlv_rts_threshold *rts_threshold;\n\tstruct host_cmd_tlv_retry_limit *retry_limit;\n\tstruct host_cmd_tlv_encrypt_protocol *encrypt_protocol;\n\tstruct host_cmd_tlv_auth_type *auth_type;\n\tstruct host_cmd_tlv_rates *tlv_rates;\n\tstruct host_cmd_tlv_ageout_timer *ao_timer, *ps_ao_timer;\n\tstruct host_cmd_tlv_power_constraint *pwr_ct;\n\tstruct mwifiex_ie_types_htcap *htcap;\n\tstruct mwifiex_ie_types_wmmcap *wmm_cap;\n\tstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\n\tint i;\n\tu16 cmd_size = *param_size;\n\n\tmac_tlv = (struct host_cmd_tlv_mac_addr *)tlv;\n\tmac_tlv->header.type = cpu_to_le16(TLV_TYPE_UAP_MAC_ADDRESS);\n\tmac_tlv->header.len = cpu_to_le16(ETH_ALEN);\n\tmemcpy(mac_tlv->mac_addr, bss_cfg->mac_addr, ETH_ALEN);\n\tcmd_size += sizeof(struct host_cmd_tlv_mac_addr);\n\ttlv += sizeof(struct host_cmd_tlv_mac_addr);\n\n\tif (bss_cfg->ssid.ssid_len) {\n\t\tssid = (struct host_cmd_tlv_ssid *)tlv;\n\t\tssid->header.type = cpu_to_le16(TLV_TYPE_UAP_SSID);\n\t\tssid->header.len = cpu_to_le16((u16)bss_cfg->ssid.ssid_len);\n\t\tmemcpy(ssid->ssid, bss_cfg->ssid.ssid, bss_cfg->ssid.ssid_len);\n\t\tcmd_size += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t    bss_cfg->ssid.ssid_len;\n\t\ttlv += sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\tbss_cfg->ssid.ssid_len;\n\n\t\tbcast_ssid = (struct host_cmd_tlv_bcast_ssid *)tlv;\n\t\tbcast_ssid->header.type = cpu_to_le16(TLV_TYPE_UAP_BCAST_SSID);\n\t\tbcast_ssid->header.len =\n\t\t\t\tcpu_to_le16(sizeof(bcast_ssid->bcast_ctl));\n\t\tbcast_ssid->bcast_ctl = bss_cfg->bcast_ssid_ctl;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_bcast_ssid);\n\t\ttlv += sizeof(struct host_cmd_tlv_bcast_ssid);\n\t}\n\tif (bss_cfg->rates[0]) {\n\t\ttlv_rates = (struct host_cmd_tlv_rates *)tlv;\n\t\ttlv_rates->header.type = cpu_to_le16(TLV_TYPE_UAP_RATES);\n\n\t\tfor (i = 0; i < MWIFIEX_SUPPORTED_RATES && bss_cfg->rates[i];\n\t\t     i++)\n\t\t\ttlv_rates->rates[i] = bss_cfg->rates[i];\n\n\t\ttlv_rates->header.len = cpu_to_le16(i);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_rates) + i;\n\t\ttlv += sizeof(struct host_cmd_tlv_rates) + i;\n\t}\n\tif (bss_cfg->channel &&\n\t    (((bss_cfg->band_cfg & BIT(0)) == BAND_CONFIG_BG &&\n\t      bss_cfg->channel <= MAX_CHANNEL_BAND_BG) ||\n\t    ((bss_cfg->band_cfg & BIT(0)) == BAND_CONFIG_A &&\n\t     bss_cfg->channel <= MAX_CHANNEL_BAND_A))) {\n\t\tchan_band = (struct host_cmd_tlv_channel_band *)tlv;\n\t\tchan_band->header.type = cpu_to_le16(TLV_TYPE_CHANNELBANDLIST);\n\t\tchan_band->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_channel_band) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tchan_band->band_config = bss_cfg->band_cfg;\n\t\tchan_band->channel = bss_cfg->channel;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_channel_band);\n\t\ttlv += sizeof(struct host_cmd_tlv_channel_band);\n\t}\n\tif (bss_cfg->beacon_period >= MIN_BEACON_PERIOD &&\n\t    bss_cfg->beacon_period <= MAX_BEACON_PERIOD) {\n\t\tbeacon_period = (struct host_cmd_tlv_beacon_period *)tlv;\n\t\tbeacon_period->header.type =\n\t\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_BEACON_PERIOD);\n\t\tbeacon_period->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_beacon_period) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tbeacon_period->period = cpu_to_le16(bss_cfg->beacon_period);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_beacon_period);\n\t\ttlv += sizeof(struct host_cmd_tlv_beacon_period);\n\t}\n\tif (bss_cfg->dtim_period >= MIN_DTIM_PERIOD &&\n\t    bss_cfg->dtim_period <= MAX_DTIM_PERIOD) {\n\t\tdtim_period = (struct host_cmd_tlv_dtim_period *)tlv;\n\t\tdtim_period->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_UAP_DTIM_PERIOD);\n\t\tdtim_period->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_dtim_period) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tdtim_period->period = bss_cfg->dtim_period;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_dtim_period);\n\t\ttlv += sizeof(struct host_cmd_tlv_dtim_period);\n\t}\n\tif (bss_cfg->rts_threshold <= MWIFIEX_RTS_MAX_VALUE) {\n\t\trts_threshold = (struct host_cmd_tlv_rts_threshold *)tlv;\n\t\trts_threshold->header.type =\n\t\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_RTS_THRESHOLD);\n\t\trts_threshold->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_rts_threshold) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\trts_threshold->rts_thr = cpu_to_le16(bss_cfg->rts_threshold);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_frag_threshold);\n\t\ttlv += sizeof(struct host_cmd_tlv_frag_threshold);\n\t}\n\tif ((bss_cfg->frag_threshold >= MWIFIEX_FRAG_MIN_VALUE) &&\n\t    (bss_cfg->frag_threshold <= MWIFIEX_FRAG_MAX_VALUE)) {\n\t\tfrag_threshold = (struct host_cmd_tlv_frag_threshold *)tlv;\n\t\tfrag_threshold->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_FRAG_THRESHOLD);\n\t\tfrag_threshold->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_frag_threshold) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tfrag_threshold->frag_thr = cpu_to_le16(bss_cfg->frag_threshold);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_frag_threshold);\n\t\ttlv += sizeof(struct host_cmd_tlv_frag_threshold);\n\t}\n\tif (bss_cfg->retry_limit <= MWIFIEX_RETRY_LIMIT) {\n\t\tretry_limit = (struct host_cmd_tlv_retry_limit *)tlv;\n\t\tretry_limit->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_UAP_RETRY_LIMIT);\n\t\tretry_limit->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_retry_limit) -\n\t\t\t\t    sizeof(struct mwifiex_ie_types_header));\n\t\tretry_limit->limit = (u8)bss_cfg->retry_limit;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_retry_limit);\n\t\ttlv += sizeof(struct host_cmd_tlv_retry_limit);\n\t}\n\tif ((bss_cfg->protocol & PROTOCOL_WPA) ||\n\t    (bss_cfg->protocol & PROTOCOL_WPA2) ||\n\t    (bss_cfg->protocol & PROTOCOL_EAP))\n\t\tmwifiex_uap_bss_wpa(&tlv, cmd_buf, &cmd_size);\n\telse\n\t\tmwifiex_uap_bss_wep(&tlv, cmd_buf, &cmd_size);\n\n\tif ((bss_cfg->auth_mode <= WLAN_AUTH_SHARED_KEY) ||\n\t    (bss_cfg->auth_mode == MWIFIEX_AUTH_MODE_AUTO)) {\n\t\tauth_type = (struct host_cmd_tlv_auth_type *)tlv;\n\t\tauth_type->header.type = cpu_to_le16(TLV_TYPE_AUTH_TYPE);\n\t\tauth_type->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_auth_type) -\n\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\tauth_type->auth_type = (u8)bss_cfg->auth_mode;\n\t\tcmd_size += sizeof(struct host_cmd_tlv_auth_type);\n\t\ttlv += sizeof(struct host_cmd_tlv_auth_type);\n\t}\n\tif (bss_cfg->protocol) {\n\t\tencrypt_protocol = (struct host_cmd_tlv_encrypt_protocol *)tlv;\n\t\tencrypt_protocol->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_UAP_ENCRY_PROTOCOL);\n\t\tencrypt_protocol->header.len =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_tlv_encrypt_protocol)\n\t\t\t- sizeof(struct mwifiex_ie_types_header));\n\t\tencrypt_protocol->proto = cpu_to_le16(bss_cfg->protocol);\n\t\tcmd_size += sizeof(struct host_cmd_tlv_encrypt_protocol);\n\t\ttlv += sizeof(struct host_cmd_tlv_encrypt_protocol);\n\t}\n\n\tif (bss_cfg->ht_cap.cap_info) {\n\t\thtcap = (struct mwifiex_ie_types_htcap *)tlv;\n\t\thtcap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\thtcap->header.len =\n\t\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\thtcap->ht_cap.cap_info = bss_cfg->ht_cap.cap_info;\n\t\thtcap->ht_cap.ampdu_params_info =\n\t\t\t\t\t     bss_cfg->ht_cap.ampdu_params_info;\n\t\tmemcpy(&htcap->ht_cap.mcs, &bss_cfg->ht_cap.mcs,\n\t\t       sizeof(struct ieee80211_mcs_info));\n\t\thtcap->ht_cap.extended_ht_cap_info =\n\t\t\t\t\tbss_cfg->ht_cap.extended_ht_cap_info;\n\t\thtcap->ht_cap.tx_BF_cap_info = bss_cfg->ht_cap.tx_BF_cap_info;\n\t\thtcap->ht_cap.antenna_selection_info =\n\t\t\t\t\tbss_cfg->ht_cap.antenna_selection_info;\n\t\tcmd_size += sizeof(struct mwifiex_ie_types_htcap);\n\t\ttlv += sizeof(struct mwifiex_ie_types_htcap);\n\t}\n\n\tif (bss_cfg->wmm_info.qos_info != 0xFF) {\n\t\twmm_cap = (struct mwifiex_ie_types_wmmcap *)tlv;\n\t\twmm_cap->header.type = cpu_to_le16(WLAN_EID_VENDOR_SPECIFIC);\n\t\twmm_cap->header.len = cpu_to_le16(sizeof(wmm_cap->wmm_info));\n\t\tmemcpy(&wmm_cap->wmm_info, &bss_cfg->wmm_info,\n\t\t       sizeof(wmm_cap->wmm_info));\n\t\tcmd_size += sizeof(struct mwifiex_ie_types_wmmcap);\n\t\ttlv += sizeof(struct mwifiex_ie_types_wmmcap);\n\t}\n\n\tif (bss_cfg->sta_ao_timer) {\n\t\tao_timer = (struct host_cmd_tlv_ageout_timer *)tlv;\n\t\tao_timer->header.type = cpu_to_le16(TLV_TYPE_UAP_AO_TIMER);\n\t\tao_timer->header.len = cpu_to_le16(sizeof(*ao_timer) -\n\t\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\tao_timer->sta_ao_timer = cpu_to_le32(bss_cfg->sta_ao_timer);\n\t\tcmd_size += sizeof(*ao_timer);\n\t\ttlv += sizeof(*ao_timer);\n\t}\n\n\tif (bss_cfg->power_constraint) {\n\t\tpwr_ct = (void *)tlv;\n\t\tpwr_ct->header.type = cpu_to_le16(TLV_TYPE_PWR_CONSTRAINT);\n\t\tpwr_ct->header.len = cpu_to_le16(sizeof(u8));\n\t\tpwr_ct->constraint = bss_cfg->power_constraint;\n\t\tcmd_size += sizeof(*pwr_ct);\n\t\ttlv += sizeof(*pwr_ct);\n\t}\n\n\tif (bss_cfg->ps_sta_ao_timer) {\n\t\tps_ao_timer = (struct host_cmd_tlv_ageout_timer *)tlv;\n\t\tps_ao_timer->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_UAP_PS_AO_TIMER);\n\t\tps_ao_timer->header.len = cpu_to_le16(sizeof(*ps_ao_timer) -\n\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\tps_ao_timer->sta_ao_timer =\n\t\t\t\t\tcpu_to_le32(bss_cfg->ps_sta_ao_timer);\n\t\tcmd_size += sizeof(*ps_ao_timer);\n\t\ttlv += sizeof(*ps_ao_timer);\n\t}\n\n\t*param_size = cmd_size;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_uap_custom_ie_prepare(u8 *tlv, void *cmd_buf, u16 *ie_size)\n{\n\tstruct mwifiex_ie_list *ap_ie = cmd_buf;\n\tstruct mwifiex_ie_types_header *tlv_ie = (void *)tlv;\n\n\tif (!ap_ie || !ap_ie->len)\n\t\treturn -1;\n\n\t*ie_size += le16_to_cpu(ap_ie->len) +\n\t\t\tsizeof(struct mwifiex_ie_types_header);\n\n\ttlv_ie->type = cpu_to_le16(TLV_TYPE_MGMT_IE);\n\ttlv_ie->len = ap_ie->len;\n\ttlv += sizeof(struct mwifiex_ie_types_header);\n\n\tmemcpy(tlv, ap_ie->ie_list, le16_to_cpu(ap_ie->len));\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cmd_uap_sys_config(struct host_cmd_ds_command *cmd, u16 cmd_action,\n\t\t\t   u32 type, void *cmd_buf)\n{\n\tu8 *tlv;\n\tu16 cmd_size, param_size, ie_size;\n\tstruct host_cmd_ds_sys_config *sys_cfg;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_UAP_SYS_CONFIG);\n\tcmd_size = (u16)(sizeof(struct host_cmd_ds_sys_config) + S_DS_GEN);\n\tsys_cfg = (struct host_cmd_ds_sys_config *)&cmd->params.uap_sys_config;\n\tsys_cfg->action = cpu_to_le16(cmd_action);\n\ttlv = sys_cfg->tlv;\n\n\tswitch (type) {\n\tcase UAP_BSS_PARAMS_I:\n\t\tparam_size = cmd_size;\n\t\tif (mwifiex_uap_bss_param_prepare(tlv, cmd_buf, &param_size))\n\t\t\treturn -1;\n\t\tcmd->size = cpu_to_le16(param_size);\n\t\tbreak;\n\tcase UAP_CUSTOM_IE_I:\n\t\tie_size = cmd_size;\n\t\tif (mwifiex_uap_custom_ie_prepare(tlv, cmd_buf, &ie_size))\n\t\t\treturn -1;\n\t\tcmd->size = cpu_to_le16(ie_size);\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_uap_sta_deauth(struct mwifiex_private *priv,\n\t\t\t\t      struct host_cmd_ds_command *cmd, u8 *mac)\n{\n\tstruct host_cmd_ds_sta_deauth *sta_deauth = &cmd->params.sta_deauth;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_UAP_STA_DEAUTH);\n\tmemcpy(sta_deauth->mac, mac, ETH_ALEN);\n\tsta_deauth->reason = cpu_to_le16(WLAN_REASON_DEAUTH_LEAVING);\n\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_sta_deauth) +\n\t\t\t\tS_DS_GEN);\n\treturn 0;\n}\n\n \nint mwifiex_uap_prepare_cmd(struct mwifiex_private *priv, u16 cmd_no,\n\t\t\t    u16 cmd_action, u32 type,\n\t\t\t    void *data_buf, void *cmd_buf)\n{\n\tstruct host_cmd_ds_command *cmd = cmd_buf;\n\n\tswitch (cmd_no) {\n\tcase HostCmd_CMD_UAP_SYS_CONFIG:\n\t\tif (mwifiex_cmd_uap_sys_config(cmd, cmd_action, type, data_buf))\n\t\t\treturn -1;\n\t\tbreak;\n\tcase HostCmd_CMD_UAP_BSS_START:\n\tcase HostCmd_CMD_UAP_BSS_STOP:\n\tcase HOST_CMD_APCMD_SYS_RESET:\n\tcase HOST_CMD_APCMD_STA_LIST:\n\t\tcmd->command = cpu_to_le16(cmd_no);\n\t\tcmd->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_UAP_STA_DEAUTH:\n\t\tif (mwifiex_cmd_uap_sta_deauth(priv, cmd, data_buf))\n\t\t\treturn -1;\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\n\t\tif (mwifiex_cmd_issue_chan_report_request(priv, cmd_buf,\n\t\t\t\t\t\t\t  data_buf))\n\t\t\treturn -1;\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"PREP_CMD: unknown cmd %#x\\n\", cmd_no);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid mwifiex_uap_set_channel(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_uap_bss_param *bss_cfg,\n\t\t\t     struct cfg80211_chan_def chandef)\n{\n\tu8 config_bands = 0, old_bands = priv->adapter->config_bands;\n\n\tpriv->bss_chandef = chandef;\n\n\tbss_cfg->channel = ieee80211_frequency_to_channel(\n\t\t\t\t\t\t     chandef.chan->center_freq);\n\n\t \n\tif (chandef.chan->band == NL80211_BAND_2GHZ) {\n\t\tbss_cfg->band_cfg = BAND_CONFIG_BG;\n\t\tconfig_bands = BAND_B | BAND_G;\n\n\t\tif (chandef.width > NL80211_CHAN_WIDTH_20_NOHT)\n\t\t\tconfig_bands |= BAND_GN;\n\t} else {\n\t\tbss_cfg->band_cfg = BAND_CONFIG_A;\n\t\tconfig_bands = BAND_A;\n\n\t\tif (chandef.width > NL80211_CHAN_WIDTH_20_NOHT)\n\t\t\tconfig_bands |= BAND_AN;\n\n\t\tif (chandef.width > NL80211_CHAN_WIDTH_40)\n\t\t\tconfig_bands |= BAND_AAC;\n\t}\n\n\tswitch (chandef.width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (chandef.center_freq1 < chandef.chan->center_freq)\n\t\t\tbss_cfg->band_cfg |= MWIFIEX_SEC_CHAN_BELOW;\n\t\telse\n\t\t\tbss_cfg->band_cfg |= MWIFIEX_SEC_CHAN_ABOVE;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tbss_cfg->band_cfg |=\n\t\t    mwifiex_get_sec_chan_offset(bss_cfg->channel) << 4;\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter,\n\t\t\t    WARN, \"Unknown channel width: %d\\n\",\n\t\t\t    chandef.width);\n\t\tbreak;\n\t}\n\n\tpriv->adapter->config_bands = config_bands;\n\n\tif (old_bands != config_bands) {\n\t\tmwifiex_send_domain_info_cmd_fw(priv->adapter->wiphy);\n\t\tmwifiex_dnld_txpwr_table(priv);\n\t}\n}\n\nint mwifiex_config_start_uap(struct mwifiex_private *priv,\n\t\t\t     struct mwifiex_uap_bss_param *bss_cfg)\n{\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_SYS_CONFIG,\n\t\t\t     HostCmd_ACT_GEN_SET,\n\t\t\t     UAP_BSS_PARAMS_I, bss_cfg, true)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to set AP configuration\\n\");\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_START,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, NULL, true)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Failed to start the BSS\\n\");\n\t\treturn -1;\n\t}\n\n\tif (priv->sec_info.wep_enabled)\n\t\tpriv->curr_pkt_filter |= HostCmd_ACT_MAC_WEP_ENABLE;\n\telse\n\t\tpriv->curr_pkt_filter &= ~HostCmd_ACT_MAC_WEP_ENABLE;\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t     HostCmd_ACT_GEN_SET, 0,\n\t\t\t     &priv->curr_pkt_filter, true))\n\t\treturn -1;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}