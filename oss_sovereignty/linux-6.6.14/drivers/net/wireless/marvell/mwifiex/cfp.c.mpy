{
  "module_name": "cfp.c",
  "hash_id": "3da211da00f657140b3706f8a7846ff9fee303903335d1b2941de1edb14459ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/cfp.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"cfg80211.h\"\n\n \n#define MWIFIEX_TX_PWR_DEFAULT     20\n \n#define MWIFIEX_TX_PWR_US_DEFAULT      20\n \n#define MWIFIEX_TX_PWR_JP_DEFAULT      16\n \n#define MWIFIEX_TX_PWR_FR_100MW        20\n \n#define MWIFIEX_TX_PWR_FR_10MW         10\n \n#define MWIFIEX_TX_PWR_EMEA_DEFAULT    20\n\nstatic u8 adhoc_rates_b[B_SUPPORTED_RATES] = { 0x82, 0x84, 0x8b, 0x96, 0 };\n\nstatic u8 adhoc_rates_g[G_SUPPORTED_RATES] = { 0x8c, 0x12, 0x98, 0x24,\n\t\t\t\t\t       0xb0, 0x48, 0x60, 0x6c, 0 };\n\nstatic u8 adhoc_rates_bg[BG_SUPPORTED_RATES] = { 0x82, 0x84, 0x8b, 0x96,\n\t\t\t\t\t\t 0x0c, 0x12, 0x18, 0x24,\n\t\t\t\t\t\t 0x30, 0x48, 0x60, 0x6c, 0 };\n\nstatic u8 adhoc_rates_a[A_SUPPORTED_RATES] = { 0x8c, 0x12, 0x98, 0x24,\n\t\t\t\t\t       0xb0, 0x48, 0x60, 0x6c, 0 };\nstatic u8 supported_rates_a[A_SUPPORTED_RATES] = { 0x0c, 0x12, 0x18, 0x24,\n\t\t\t\t\t0xb0, 0x48, 0x60, 0x6c, 0 };\nstatic u16 mwifiex_data_rates[MWIFIEX_SUPPORTED_RATES_EXT] = { 0x02, 0x04,\n\t\t\t\t\t0x0B, 0x16, 0x00, 0x0C, 0x12, 0x18,\n\t\t\t\t\t0x24, 0x30, 0x48, 0x60, 0x6C, 0x90,\n\t\t\t\t\t0x0D, 0x1A, 0x27, 0x34, 0x4E, 0x68,\n\t\t\t\t\t0x75, 0x82, 0x0C, 0x1B, 0x36, 0x51,\n\t\t\t\t\t0x6C, 0xA2, 0xD8, 0xF3, 0x10E, 0x00 };\n\nstatic u8 supported_rates_b[B_SUPPORTED_RATES] = { 0x02, 0x04, 0x0b, 0x16, 0 };\n\nstatic u8 supported_rates_g[G_SUPPORTED_RATES] = { 0x0c, 0x12, 0x18, 0x24,\n\t\t\t\t\t0x30, 0x48, 0x60, 0x6c, 0 };\n\nstatic u8 supported_rates_bg[BG_SUPPORTED_RATES] = { 0x02, 0x04, 0x0b, 0x0c,\n\t\t\t\t\t0x12, 0x16, 0x18, 0x24, 0x30, 0x48,\n\t\t\t\t\t0x60, 0x6c, 0 };\n\nu16 region_code_index[MWIFIEX_MAX_REGION_CODE] = { 0x00, 0x10, 0x20, 0x30,\n\t\t\t\t\t\t0x31, 0x32, 0x40, 0x41, 0x50 };\n\nstatic u8 supported_rates_n[N_SUPPORTED_RATES] = { 0x02, 0x04, 0 };\n\n \nstatic const u16 mcs_rate[4][16] = {\n\t \n\t{ 0x1b, 0x36, 0x51, 0x6c, 0xa2, 0xd8, 0xf3, 0x10e,\n\t  0x36, 0x6c, 0xa2, 0xd8, 0x144, 0x1b0, 0x1e6, 0x21c },\n\n\t \n\t{ 0x1e, 0x3c, 0x5a, 0x78, 0xb4, 0xf0, 0x10e, 0x12c,\n\t  0x3c, 0x78, 0xb4, 0xf0, 0x168, 0x1e0, 0x21c, 0x258 },\n\n\t \n\t{ 0x0d, 0x1a, 0x27, 0x34, 0x4e, 0x68, 0x75, 0x82,\n\t  0x1a, 0x34, 0x4e, 0x68, 0x9c, 0xd0, 0xea, 0x104 },\n\n\t \n\t{ 0x0e, 0x1c, 0x2b, 0x39, 0x56, 0x73, 0x82, 0x90,\n\t  0x1c, 0x39, 0x56, 0x73, 0xad, 0xe7, 0x104, 0x120 }\n};\n\n \nstatic const u16 ac_mcs_rate_nss1[8][10] = {\n\t \n\t{ 0x75, 0xEA, 0x15F, 0x1D4, 0x2BE, 0x3A8, 0x41D,\n\t  0x492, 0x57C, 0x618 },\n\n\t \n\t{ 0x82, 0x104, 0x186, 0x208, 0x30C, 0x410, 0x492,\n\t  0x514, 0x618, 0x6C6 },\n\n\t \n\t{ 0x3B, 0x75, 0xB0, 0xEA, 0x15F, 0x1D4, 0x20F,\n\t  0x249, 0x2BE, 0x30C },\n\n\t \n\t{ 0x41, 0x82, 0xC3, 0x104, 0x186, 0x208, 0x249,\n\t  0x28A, 0x30C, 0x363 },\n\n\t \n\t{ 0x1B, 0x36, 0x51, 0x6C, 0xA2, 0xD8, 0xF3,\n\t  0x10E, 0x144, 0x168 },\n\n\t \n\t{ 0x1E, 0x3C, 0x5A, 0x78, 0xB4, 0xF0, 0x10E,\n\t  0x12C, 0x168, 0x190 },\n\n\t \n\t{ 0xD, 0x1A, 0x27, 0x34, 0x4E, 0x68, 0x75, 0x82, 0x9C, 0x00 },\n\n\t \n\t{ 0xF, 0x1D, 0x2C, 0x3A, 0x57, 0x74, 0x82, 0x91, 0xAE, 0x00 },\n};\n\n \nstatic const u16 ac_mcs_rate_nss2[8][10] = {\n\t \n\t{ 0xEA, 0x1D4, 0x2BE, 0x3A8, 0x57C, 0x750, 0x83A,\n\t  0x924, 0xAF8, 0xC30 },\n\n\t \n\t{ 0x104, 0x208, 0x30C, 0x410, 0x618, 0x820, 0x924,\n\t  0xA28, 0xC30, 0xD8B },\n\n\t \n\t{ 0x75, 0xEA, 0x15F, 0x1D4, 0x2BE, 0x3A8, 0x41D,\n\t  0x492, 0x57C, 0x618 },\n\n\t \n\t{ 0x82, 0x104, 0x186, 0x208, 0x30C, 0x410, 0x492,\n\t  0x514, 0x618, 0x6C6 },\n\n\t \n\t{ 0x36, 0x6C, 0xA2, 0xD8, 0x144, 0x1B0, 0x1E6,\n\t  0x21C, 0x288, 0x2D0 },\n\n\t \n\t{ 0x3C, 0x78, 0xB4, 0xF0, 0x168, 0x1E0, 0x21C,\n\t  0x258, 0x2D0, 0x320 },\n\n\t \n\t{ 0x1A, 0x34, 0x4A, 0x68, 0x9C, 0xD0, 0xEA, 0x104,\n\t  0x138, 0x00 },\n\n\t \n\t{ 0x1D, 0x3A, 0x57, 0x74, 0xAE, 0xE6, 0x104, 0x121,\n\t  0x15B, 0x00 },\n};\n\nstruct region_code_mapping {\n\tu8 code;\n\tu8 region[IEEE80211_COUNTRY_STRING_LEN];\n};\n\nstatic struct region_code_mapping region_code_mapping_t[] = {\n\t{ 0x10, \"US \" },  \n\t{ 0x20, \"CA \" },  \n\t{ 0x30, \"FR \" },  \n\t{ 0x31, \"ES \" },  \n\t{ 0x32, \"FR \" },  \n\t{ 0x40, \"JP \" },  \n\t{ 0x41, \"JP \" },  \n\t{ 0x50, \"CN \" },  \n};\n\n \nu8 *mwifiex_11d_code_2_region(u8 code)\n{\n\tu8 i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(region_code_mapping_t); i++)\n\t\tif (region_code_mapping_t[i].code == code)\n\t\t\treturn region_code_mapping_t[i].region;\n\n\treturn NULL;\n}\n\n \nu32 mwifiex_index_to_acs_data_rate(struct mwifiex_private *priv,\n\t\t\t\t   u8 index, u8 ht_info)\n{\n\tu32 rate = 0;\n\tu8 mcs_index = 0;\n\tu8 bw = 0;\n\tu8 gi = 0;\n\n\tif ((ht_info & 0x3) == MWIFIEX_RATE_FORMAT_VHT) {\n\t\tmcs_index = min(index & 0xF, 9);\n\n\t\t \n\t\tbw = (ht_info & 0xC) >> 2;\n\n\t\t \n\t\tgi = (ht_info & 0x10) >> 4;\n\n\t\tif ((index >> 4) == 1)\t \n\t\t\trate = ac_mcs_rate_nss2[2 * (3 - bw) + gi][mcs_index];\n\t\telse\t\t\t \n\t\t\trate = ac_mcs_rate_nss1[2 * (3 - bw) + gi][mcs_index];\n\t} else if ((ht_info & 0x3) == MWIFIEX_RATE_FORMAT_HT) {\n\t\t \n\t\tbw = (ht_info & 0xC) >> 2;\n\n\t\t \n\t\tgi = (ht_info & 0x10) >> 4;\n\n\t\tif (index == MWIFIEX_RATE_BITMAP_MCS0) {\n\t\t\tif (gi == 1)\n\t\t\t\trate = 0x0D;     \n\t\t\telse\n\t\t\t\trate = 0x0C;     \n\t\t} else if (index < 16) {\n\t\t\tif ((bw == 1) || (bw == 0))\n\t\t\t\trate = mcs_rate[2 * (1 - bw) + gi][index];\n\t\t\telse\n\t\t\t\trate = mwifiex_data_rates[0];\n\t\t} else {\n\t\t\trate = mwifiex_data_rates[0];\n\t\t}\n\t} else {\n\t\t \n\t\tif (index >= MWIFIEX_SUPPORTED_RATES_EXT)\n\t\t\tindex = 0;\n\t\trate = mwifiex_data_rates[index];\n\t}\n\n\treturn rate;\n}\n\n \nu32 mwifiex_index_to_data_rate(struct mwifiex_private *priv,\n\t\t\t       u8 index, u8 ht_info)\n{\n\tu32 mcs_num_supp =\n\t\t(priv->adapter->user_dev_mcs_support == HT_STREAM_2X2) ? 16 : 8;\n\tu32 rate;\n\n\tif (priv->adapter->is_hw_11ac_capable)\n\t\treturn mwifiex_index_to_acs_data_rate(priv, index, ht_info);\n\n\tif (ht_info & BIT(0)) {\n\t\tif (index == MWIFIEX_RATE_BITMAP_MCS0) {\n\t\t\tif (ht_info & BIT(2))\n\t\t\t\trate = 0x0D;\t \n\t\t\telse\n\t\t\t\trate = 0x0C;\t \n\t\t} else if (index < mcs_num_supp) {\n\t\t\tif (ht_info & BIT(1)) {\n\t\t\t\tif (ht_info & BIT(2))\n\t\t\t\t\t \n\t\t\t\t\trate = mcs_rate[1][index];\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\trate = mcs_rate[0][index];\n\t\t\t} else {\n\t\t\t\tif (ht_info & BIT(2))\n\t\t\t\t\t \n\t\t\t\t\trate = mcs_rate[3][index];\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\trate = mcs_rate[2][index];\n\t\t\t}\n\t\t} else\n\t\t\trate = mwifiex_data_rates[0];\n\t} else {\n\t\tif (index >= MWIFIEX_SUPPORTED_RATES_EXT)\n\t\t\tindex = 0;\n\t\trate = mwifiex_data_rates[index];\n\t}\n\treturn rate;\n}\n\n \nu32 mwifiex_get_active_data_rates(struct mwifiex_private *priv, u8 *rates)\n{\n\tif (!priv->media_connected)\n\t\treturn mwifiex_get_supported_rates(priv, rates);\n\telse\n\t\treturn mwifiex_copy_rates(rates, 0,\n\t\t\t\t\t  priv->curr_bss_params.data_rates,\n\t\t\t\t\t  priv->curr_bss_params.num_of_rates);\n}\n\n \nstruct mwifiex_chan_freq_power *\nmwifiex_get_cfp(struct mwifiex_private *priv, u8 band, u16 channel, u32 freq)\n{\n\tstruct mwifiex_chan_freq_power *cfp = NULL;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch = NULL;\n\tint i;\n\n\tif (!channel && !freq)\n\t\treturn cfp;\n\n\tif (mwifiex_band_to_radio_type(band) == HostCmd_SCAN_RADIO_TYPE_BG)\n\t\tsband = priv->wdev.wiphy->bands[NL80211_BAND_2GHZ];\n\telse\n\t\tsband = priv->wdev.wiphy->bands[NL80211_BAND_5GHZ];\n\n\tif (!sband) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"%s: cannot find cfp by band %d\\n\",\n\t\t\t    __func__, band);\n\t\treturn cfp;\n\t}\n\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tch = &sband->channels[i];\n\n\t\tif (ch->flags & IEEE80211_CHAN_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (freq) {\n\t\t\tif (ch->center_freq == freq)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tif (ch->hw_value == channel ||\n\t\t\t    channel == FIRST_VALID_CHANNEL)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == sband->n_channels) {\n\t\tmwifiex_dbg(priv->adapter, WARN,\n\t\t\t    \"%s: cannot find cfp by band %d\\t\"\n\t\t\t    \"& channel=%d freq=%d\\n\",\n\t\t\t    __func__, band, channel, freq);\n\t} else {\n\t\tif (!ch)\n\t\t\treturn cfp;\n\n\t\tpriv->cfp.channel = ch->hw_value;\n\t\tpriv->cfp.freq = ch->center_freq;\n\t\tpriv->cfp.max_tx_power = ch->max_power;\n\t\tcfp = &priv->cfp;\n\t}\n\n\treturn cfp;\n}\n\n \nu8\nmwifiex_is_rate_auto(struct mwifiex_private *priv)\n{\n\tu32 i;\n\tint rate_num = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->bitmap_rates); i++)\n\t\tif (priv->bitmap_rates[i])\n\t\t\trate_num++;\n\n\tif (rate_num > 1)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nu32 mwifiex_get_rates_from_cfg80211(struct mwifiex_private *priv,\n\t\t\t\t    u8 *rates, u8 radio_type)\n{\n\tstruct wiphy *wiphy = priv->adapter->wiphy;\n\tstruct cfg80211_scan_request *request = priv->scan_request;\n\tu32 num_rates, rate_mask;\n\tstruct ieee80211_supported_band *sband;\n\tint i;\n\n\tif (radio_type) {\n\t\tsband = wiphy->bands[NL80211_BAND_5GHZ];\n\t\tif (WARN_ON_ONCE(!sband))\n\t\t\treturn 0;\n\t\trate_mask = request->rates[NL80211_BAND_5GHZ];\n\t} else {\n\t\tsband = wiphy->bands[NL80211_BAND_2GHZ];\n\t\tif (WARN_ON_ONCE(!sband))\n\t\t\treturn 0;\n\t\trate_mask = request->rates[NL80211_BAND_2GHZ];\n\t}\n\n\tnum_rates = 0;\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tif ((BIT(i) & rate_mask) == 0)\n\t\t\tcontinue;  \n\t\trates[num_rates++] = (u8)(sband->bitrates[i].bitrate / 5);\n\t}\n\n\treturn num_rates;\n}\n\n \nu32 mwifiex_get_supported_rates(struct mwifiex_private *priv, u8 *rates)\n{\n\tu32 k = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tif (priv->bss_mode == NL80211_IFTYPE_STATION ||\n\t    priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT) {\n\t\tswitch (adapter->config_bands) {\n\t\tcase BAND_B:\n\t\t\tmwifiex_dbg(adapter, INFO, \"info: infra band=%d\\t\"\n\t\t\t\t    \"supported_rates_b\\n\",\n\t\t\t\t    adapter->config_bands);\n\t\t\tk = mwifiex_copy_rates(rates, k, supported_rates_b,\n\t\t\t\t\t       sizeof(supported_rates_b));\n\t\t\tbreak;\n\t\tcase BAND_G:\n\t\tcase BAND_G | BAND_GN:\n\t\t\tmwifiex_dbg(adapter, INFO, \"info: infra band=%d\\t\"\n\t\t\t\t    \"supported_rates_g\\n\",\n\t\t\t\t    adapter->config_bands);\n\t\t\tk = mwifiex_copy_rates(rates, k, supported_rates_g,\n\t\t\t\t\t       sizeof(supported_rates_g));\n\t\t\tbreak;\n\t\tcase BAND_B | BAND_G:\n\t\tcase BAND_A | BAND_B | BAND_G:\n\t\tcase BAND_A | BAND_B:\n\t\tcase BAND_A | BAND_B | BAND_G | BAND_GN | BAND_AN:\n\t\tcase BAND_A | BAND_B | BAND_G | BAND_GN | BAND_AN | BAND_AAC:\n\t\tcase BAND_B | BAND_G | BAND_GN:\n\t\t\tmwifiex_dbg(adapter, INFO, \"info: infra band=%d\\t\"\n\t\t\t\t    \"supported_rates_bg\\n\",\n\t\t\t\t    adapter->config_bands);\n\t\t\tk = mwifiex_copy_rates(rates, k, supported_rates_bg,\n\t\t\t\t\t       sizeof(supported_rates_bg));\n\t\t\tbreak;\n\t\tcase BAND_A:\n\t\tcase BAND_A | BAND_G:\n\t\t\tmwifiex_dbg(adapter, INFO, \"info: infra band=%d\\t\"\n\t\t\t\t    \"supported_rates_a\\n\",\n\t\t\t\t    adapter->config_bands);\n\t\t\tk = mwifiex_copy_rates(rates, k, supported_rates_a,\n\t\t\t\t\t       sizeof(supported_rates_a));\n\t\t\tbreak;\n\t\tcase BAND_AN:\n\t\tcase BAND_A | BAND_AN:\n\t\tcase BAND_A | BAND_AN | BAND_AAC:\n\t\tcase BAND_A | BAND_G | BAND_AN | BAND_GN:\n\t\tcase BAND_A | BAND_G | BAND_AN | BAND_GN | BAND_AAC:\n\t\t\tmwifiex_dbg(adapter, INFO, \"info: infra band=%d\\t\"\n\t\t\t\t    \"supported_rates_a\\n\",\n\t\t\t\t    adapter->config_bands);\n\t\t\tk = mwifiex_copy_rates(rates, k, supported_rates_a,\n\t\t\t\t\t       sizeof(supported_rates_a));\n\t\t\tbreak;\n\t\tcase BAND_GN:\n\t\t\tmwifiex_dbg(adapter, INFO, \"info: infra band=%d\\t\"\n\t\t\t\t    \"supported_rates_n\\n\",\n\t\t\t\t    adapter->config_bands);\n\t\t\tk = mwifiex_copy_rates(rates, k, supported_rates_n,\n\t\t\t\t\t       sizeof(supported_rates_n));\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tswitch (adapter->adhoc_start_band) {\n\t\tcase BAND_B:\n\t\t\tmwifiex_dbg(adapter, INFO, \"info: adhoc B\\n\");\n\t\t\tk = mwifiex_copy_rates(rates, k, adhoc_rates_b,\n\t\t\t\t\t       sizeof(adhoc_rates_b));\n\t\t\tbreak;\n\t\tcase BAND_G:\n\t\tcase BAND_G | BAND_GN:\n\t\t\tmwifiex_dbg(adapter, INFO, \"info: adhoc G only\\n\");\n\t\t\tk = mwifiex_copy_rates(rates, k, adhoc_rates_g,\n\t\t\t\t\t       sizeof(adhoc_rates_g));\n\t\t\tbreak;\n\t\tcase BAND_B | BAND_G:\n\t\tcase BAND_B | BAND_G | BAND_GN:\n\t\t\tmwifiex_dbg(adapter, INFO, \"info: adhoc BG\\n\");\n\t\t\tk = mwifiex_copy_rates(rates, k, adhoc_rates_bg,\n\t\t\t\t\t       sizeof(adhoc_rates_bg));\n\t\t\tbreak;\n\t\tcase BAND_A:\n\t\tcase BAND_A | BAND_AN:\n\t\t\tmwifiex_dbg(adapter, INFO, \"info: adhoc A\\n\");\n\t\t\tk = mwifiex_copy_rates(rates, k, adhoc_rates_a,\n\t\t\t\t\t       sizeof(adhoc_rates_a));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn k;\n}\n\nu8 mwifiex_adjust_data_rate(struct mwifiex_private *priv,\n\t\t\t    u8 rx_rate, u8 rate_info)\n{\n\tu8 rate_index = 0;\n\n\t \n\tif ((rate_info & BIT(0)) && (rate_info & BIT(1)))\n\t\trate_index = MWIFIEX_RATE_INDEX_MCS0 +\n\t\t\t     MWIFIEX_BW20_MCS_NUM + rx_rate;\n\telse if (rate_info & BIT(0))  \n\t\trate_index = MWIFIEX_RATE_INDEX_MCS0 + rx_rate;\n\telse\n\t\trate_index = (rx_rate > MWIFIEX_RATE_INDEX_OFDM0) ?\n\t\t\t      rx_rate - 1 : rx_rate;\n\n\tif (rate_index >= MWIFIEX_MAX_AC_RX_RATES)\n\t\trate_index = MWIFIEX_MAX_AC_RX_RATES - 1;\n\n\treturn rate_index;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}