{
  "module_name": "util.c",
  "hash_id": "95c6123bbdfa5a257fb24ed184d8a2bdd3810480b422b952d53b32d62a053c78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/util.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n\nstatic struct mwifiex_debug_data items[] = {\n\t{\"debug_mask\", item_size(debug_mask),\n\t item_addr(debug_mask), 1},\n\t{\"int_counter\", item_size(int_counter),\n\t item_addr(int_counter), 1},\n\t{\"wmm_ac_vo\", item_size(packets_out[WMM_AC_VO]),\n\t item_addr(packets_out[WMM_AC_VO]), 1},\n\t{\"wmm_ac_vi\", item_size(packets_out[WMM_AC_VI]),\n\t item_addr(packets_out[WMM_AC_VI]), 1},\n\t{\"wmm_ac_be\", item_size(packets_out[WMM_AC_BE]),\n\t item_addr(packets_out[WMM_AC_BE]), 1},\n\t{\"wmm_ac_bk\", item_size(packets_out[WMM_AC_BK]),\n\t item_addr(packets_out[WMM_AC_BK]), 1},\n\t{\"tx_buf_size\", item_size(tx_buf_size),\n\t item_addr(tx_buf_size), 1},\n\t{\"curr_tx_buf_size\", item_size(curr_tx_buf_size),\n\t item_addr(curr_tx_buf_size), 1},\n\t{\"ps_mode\", item_size(ps_mode),\n\t item_addr(ps_mode), 1},\n\t{\"ps_state\", item_size(ps_state),\n\t item_addr(ps_state), 1},\n\t{\"is_deep_sleep\", item_size(is_deep_sleep),\n\t item_addr(is_deep_sleep), 1},\n\t{\"wakeup_dev_req\", item_size(pm_wakeup_card_req),\n\t item_addr(pm_wakeup_card_req), 1},\n\t{\"wakeup_tries\", item_size(pm_wakeup_fw_try),\n\t item_addr(pm_wakeup_fw_try), 1},\n\t{\"hs_configured\", item_size(is_hs_configured),\n\t item_addr(is_hs_configured), 1},\n\t{\"hs_activated\", item_size(hs_activated),\n\t item_addr(hs_activated), 1},\n\t{\"num_tx_timeout\", item_size(num_tx_timeout),\n\t item_addr(num_tx_timeout), 1},\n\t{\"is_cmd_timedout\", item_size(is_cmd_timedout),\n\t item_addr(is_cmd_timedout), 1},\n\t{\"timeout_cmd_id\", item_size(timeout_cmd_id),\n\t item_addr(timeout_cmd_id), 1},\n\t{\"timeout_cmd_act\", item_size(timeout_cmd_act),\n\t item_addr(timeout_cmd_act), 1},\n\t{\"last_cmd_id\", item_size(last_cmd_id),\n\t item_addr(last_cmd_id), DBG_CMD_NUM},\n\t{\"last_cmd_act\", item_size(last_cmd_act),\n\t item_addr(last_cmd_act), DBG_CMD_NUM},\n\t{\"last_cmd_index\", item_size(last_cmd_index),\n\t item_addr(last_cmd_index), 1},\n\t{\"last_cmd_resp_id\", item_size(last_cmd_resp_id),\n\t item_addr(last_cmd_resp_id), DBG_CMD_NUM},\n\t{\"last_cmd_resp_index\", item_size(last_cmd_resp_index),\n\t item_addr(last_cmd_resp_index), 1},\n\t{\"last_event\", item_size(last_event),\n\t item_addr(last_event), DBG_CMD_NUM},\n\t{\"last_event_index\", item_size(last_event_index),\n\t item_addr(last_event_index), 1},\n\t{\"last_mp_wr_bitmap\", item_size(last_mp_wr_bitmap),\n\t item_addr(last_mp_wr_bitmap), MWIFIEX_DBG_SDIO_MP_NUM},\n\t{\"last_mp_wr_ports\", item_size(last_mp_wr_ports),\n\t item_addr(last_mp_wr_ports), MWIFIEX_DBG_SDIO_MP_NUM},\n\t{\"last_mp_wr_len\", item_size(last_mp_wr_len),\n\t item_addr(last_mp_wr_len), MWIFIEX_DBG_SDIO_MP_NUM},\n\t{\"last_mp_curr_wr_port\", item_size(last_mp_curr_wr_port),\n\t item_addr(last_mp_curr_wr_port), MWIFIEX_DBG_SDIO_MP_NUM},\n\t{\"last_sdio_mp_index\", item_size(last_sdio_mp_index),\n\t item_addr(last_sdio_mp_index), 1},\n\t{\"num_cmd_h2c_fail\", item_size(num_cmd_host_to_card_failure),\n\t item_addr(num_cmd_host_to_card_failure), 1},\n\t{\"num_cmd_sleep_cfm_fail\",\n\t item_size(num_cmd_sleep_cfm_host_to_card_failure),\n\t item_addr(num_cmd_sleep_cfm_host_to_card_failure), 1},\n\t{\"num_tx_h2c_fail\", item_size(num_tx_host_to_card_failure),\n\t item_addr(num_tx_host_to_card_failure), 1},\n\t{\"num_evt_deauth\", item_size(num_event_deauth),\n\t item_addr(num_event_deauth), 1},\n\t{\"num_evt_disassoc\", item_size(num_event_disassoc),\n\t item_addr(num_event_disassoc), 1},\n\t{\"num_evt_link_lost\", item_size(num_event_link_lost),\n\t item_addr(num_event_link_lost), 1},\n\t{\"num_cmd_deauth\", item_size(num_cmd_deauth),\n\t item_addr(num_cmd_deauth), 1},\n\t{\"num_cmd_assoc_ok\", item_size(num_cmd_assoc_success),\n\t item_addr(num_cmd_assoc_success), 1},\n\t{\"num_cmd_assoc_fail\", item_size(num_cmd_assoc_failure),\n\t item_addr(num_cmd_assoc_failure), 1},\n\t{\"cmd_sent\", item_size(cmd_sent),\n\t item_addr(cmd_sent), 1},\n\t{\"data_sent\", item_size(data_sent),\n\t item_addr(data_sent), 1},\n\t{\"cmd_resp_received\", item_size(cmd_resp_received),\n\t item_addr(cmd_resp_received), 1},\n\t{\"event_received\", item_size(event_received),\n\t item_addr(event_received), 1},\n\n\t \n\t{\"cmd_pending\", adapter_item_size(cmd_pending),\n\t adapter_item_addr(cmd_pending), 1},\n\t{\"tx_pending\", adapter_item_size(tx_pending),\n\t adapter_item_addr(tx_pending), 1},\n\t{\"rx_pending\", adapter_item_size(rx_pending),\n\t adapter_item_addr(rx_pending), 1},\n};\n\nstatic int num_of_items = ARRAY_SIZE(items);\n\n \nint mwifiex_init_fw_complete(struct mwifiex_adapter *adapter)\n{\n\n\tif (adapter->hw_status == MWIFIEX_HW_STATUS_READY)\n\t\tif (adapter->if_ops.init_fw_port)\n\t\t\tadapter->if_ops.init_fw_port(adapter);\n\n\tadapter->init_wait_q_woken = true;\n\twake_up_interruptible(&adapter->init_wait_q);\n\treturn 0;\n}\n\n \nint mwifiex_init_shutdown_fw(struct mwifiex_private *priv,\n\t\t\t     u32 func_init_shutdown)\n{\n\tu16 cmd;\n\n\tif (func_init_shutdown == MWIFIEX_FUNC_INIT) {\n\t\tcmd = HostCmd_CMD_FUNC_INIT;\n\t} else if (func_init_shutdown == MWIFIEX_FUNC_SHUTDOWN) {\n\t\tcmd = HostCmd_CMD_FUNC_SHUTDOWN;\n\t} else {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"unsupported parameter\\n\");\n\t\treturn -1;\n\t}\n\n\treturn mwifiex_send_cmd(priv, cmd, HostCmd_ACT_GEN_SET, 0, NULL, true);\n}\nEXPORT_SYMBOL_GPL(mwifiex_init_shutdown_fw);\n\n \nint mwifiex_get_debug_info(struct mwifiex_private *priv,\n\t\t\t   struct mwifiex_debug_info *info)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tif (info) {\n\t\tinfo->debug_mask = adapter->debug_mask;\n\t\tmemcpy(info->packets_out,\n\t\t       priv->wmm.packets_out,\n\t\t       sizeof(priv->wmm.packets_out));\n\t\tinfo->curr_tx_buf_size = (u32) adapter->curr_tx_buf_size;\n\t\tinfo->tx_buf_size = (u32) adapter->tx_buf_size;\n\t\tinfo->rx_tbl_num = mwifiex_get_rx_reorder_tbl(priv,\n\t\t\t\t\t\t\t      info->rx_tbl);\n\t\tinfo->tx_tbl_num = mwifiex_get_tx_ba_stream_tbl(priv,\n\t\t\t\t\t\t\t\tinfo->tx_tbl);\n\t\tinfo->tdls_peer_num = mwifiex_get_tdls_list(priv,\n\t\t\t\t\t\t\t    info->tdls_list);\n\t\tinfo->ps_mode = adapter->ps_mode;\n\t\tinfo->ps_state = adapter->ps_state;\n\t\tinfo->is_deep_sleep = adapter->is_deep_sleep;\n\t\tinfo->pm_wakeup_card_req = adapter->pm_wakeup_card_req;\n\t\tinfo->pm_wakeup_fw_try = adapter->pm_wakeup_fw_try;\n\t\tinfo->is_hs_configured = test_bit(MWIFIEX_IS_HS_CONFIGURED,\n\t\t\t\t\t\t  &adapter->work_flags);\n\t\tinfo->hs_activated = adapter->hs_activated;\n\t\tinfo->is_cmd_timedout = test_bit(MWIFIEX_IS_CMD_TIMEDOUT,\n\t\t\t\t\t\t &adapter->work_flags);\n\t\tinfo->num_cmd_host_to_card_failure\n\t\t\t\t= adapter->dbg.num_cmd_host_to_card_failure;\n\t\tinfo->num_cmd_sleep_cfm_host_to_card_failure\n\t\t\t= adapter->dbg.num_cmd_sleep_cfm_host_to_card_failure;\n\t\tinfo->num_tx_host_to_card_failure\n\t\t\t\t= adapter->dbg.num_tx_host_to_card_failure;\n\t\tinfo->num_event_deauth = adapter->dbg.num_event_deauth;\n\t\tinfo->num_event_disassoc = adapter->dbg.num_event_disassoc;\n\t\tinfo->num_event_link_lost = adapter->dbg.num_event_link_lost;\n\t\tinfo->num_cmd_deauth = adapter->dbg.num_cmd_deauth;\n\t\tinfo->num_cmd_assoc_success =\n\t\t\t\t\tadapter->dbg.num_cmd_assoc_success;\n\t\tinfo->num_cmd_assoc_failure =\n\t\t\t\t\tadapter->dbg.num_cmd_assoc_failure;\n\t\tinfo->num_tx_timeout = adapter->dbg.num_tx_timeout;\n\t\tinfo->timeout_cmd_id = adapter->dbg.timeout_cmd_id;\n\t\tinfo->timeout_cmd_act = adapter->dbg.timeout_cmd_act;\n\t\tmemcpy(info->last_cmd_id, adapter->dbg.last_cmd_id,\n\t\t       sizeof(adapter->dbg.last_cmd_id));\n\t\tmemcpy(info->last_cmd_act, adapter->dbg.last_cmd_act,\n\t\t       sizeof(adapter->dbg.last_cmd_act));\n\t\tinfo->last_cmd_index = adapter->dbg.last_cmd_index;\n\t\tmemcpy(info->last_cmd_resp_id, adapter->dbg.last_cmd_resp_id,\n\t\t       sizeof(adapter->dbg.last_cmd_resp_id));\n\t\tinfo->last_cmd_resp_index = adapter->dbg.last_cmd_resp_index;\n\t\tmemcpy(info->last_event, adapter->dbg.last_event,\n\t\t       sizeof(adapter->dbg.last_event));\n\t\tinfo->last_event_index = adapter->dbg.last_event_index;\n\t\tmemcpy(info->last_mp_wr_bitmap, adapter->dbg.last_mp_wr_bitmap,\n\t\t       sizeof(adapter->dbg.last_mp_wr_bitmap));\n\t\tmemcpy(info->last_mp_wr_ports, adapter->dbg.last_mp_wr_ports,\n\t\t       sizeof(adapter->dbg.last_mp_wr_ports));\n\t\tmemcpy(info->last_mp_curr_wr_port,\n\t\t       adapter->dbg.last_mp_curr_wr_port,\n\t\t       sizeof(adapter->dbg.last_mp_curr_wr_port));\n\t\tmemcpy(info->last_mp_wr_len, adapter->dbg.last_mp_wr_len,\n\t\t       sizeof(adapter->dbg.last_mp_wr_len));\n\t\tinfo->last_sdio_mp_index = adapter->dbg.last_sdio_mp_index;\n\t\tinfo->data_sent = adapter->data_sent;\n\t\tinfo->cmd_sent = adapter->cmd_sent;\n\t\tinfo->cmd_resp_received = adapter->cmd_resp_received;\n\t}\n\n\treturn 0;\n}\n\nint mwifiex_debug_info_to_buffer(struct mwifiex_private *priv, char *buf,\n\t\t\t\t struct mwifiex_debug_info *info)\n{\n\tchar *p = buf;\n\tstruct mwifiex_debug_data *d = &items[0];\n\tsize_t size, addr;\n\tlong val;\n\tint i, j;\n\n\tif (!info)\n\t\treturn 0;\n\n\tfor (i = 0; i < num_of_items; i++) {\n\t\tp += sprintf(p, \"%s=\", d[i].name);\n\n\t\tsize = d[i].size / d[i].num;\n\n\t\tif (i < (num_of_items - 3))\n\t\t\taddr = d[i].addr + (size_t)info;\n\t\telse  \n\t\t\taddr = d[i].addr + (size_t)priv->adapter;\n\n\t\tfor (j = 0; j < d[i].num; j++) {\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\tval = *((u8 *)addr);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tval = get_unaligned((u16 *)addr);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tval = get_unaligned((u32 *)addr);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tval = get_unaligned((long long *)addr);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tval = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tp += sprintf(p, \"%#lx \", val);\n\t\t\taddr += size;\n\t\t}\n\n\t\tp += sprintf(p, \"\\n\");\n\t}\n\n\tif (info->tx_tbl_num) {\n\t\tp += sprintf(p, \"Tx BA stream table:\\n\");\n\t\tfor (i = 0; i < info->tx_tbl_num; i++)\n\t\t\tp += sprintf(p, \"tid = %d, ra = %pM\\n\",\n\t\t\t\t     info->tx_tbl[i].tid, info->tx_tbl[i].ra);\n\t}\n\n\tif (info->rx_tbl_num) {\n\t\tp += sprintf(p, \"Rx reorder table:\\n\");\n\t\tfor (i = 0; i < info->rx_tbl_num; i++) {\n\t\t\tp += sprintf(p, \"tid = %d, ta = %pM, \",\n\t\t\t\t     info->rx_tbl[i].tid,\n\t\t\t\t     info->rx_tbl[i].ta);\n\t\t\tp += sprintf(p, \"start_win = %d, \",\n\t\t\t\t     info->rx_tbl[i].start_win);\n\t\t\tp += sprintf(p, \"win_size = %d, buffer: \",\n\t\t\t\t     info->rx_tbl[i].win_size);\n\n\t\t\tfor (j = 0; j < info->rx_tbl[i].win_size; j++)\n\t\t\t\tp += sprintf(p, \"%c \",\n\t\t\t\t\t     info->rx_tbl[i].buffer[j] ?\n\t\t\t\t\t     '1' : '0');\n\n\t\t\tp += sprintf(p, \"\\n\");\n\t\t}\n\t}\n\n\tif (info->tdls_peer_num) {\n\t\tp += sprintf(p, \"TDLS peer table:\\n\");\n\t\tfor (i = 0; i < info->tdls_peer_num; i++) {\n\t\t\tp += sprintf(p, \"peer = %pM\",\n\t\t\t\t     info->tdls_list[i].peer_addr);\n\t\t\tp += sprintf(p, \"\\n\");\n\t\t}\n\t}\n\n\treturn p - buf;\n}\n\nstatic int\nmwifiex_parse_mgmt_packet(struct mwifiex_private *priv, u8 *payload, u16 len,\n\t\t\t  struct rxpd *rx_pd)\n{\n\tu16 stype;\n\tu8 category, action_code, *addr2;\n\tstruct ieee80211_hdr *ieee_hdr = (void *)payload;\n\n\tstype = (le16_to_cpu(ieee_hdr->frame_control) & IEEE80211_FCTL_STYPE);\n\n\tswitch (stype) {\n\tcase IEEE80211_STYPE_ACTION:\n\t\tcategory = *(payload + sizeof(struct ieee80211_hdr));\n\t\tswitch (category) {\n\t\tcase WLAN_CATEGORY_PUBLIC:\n\t\t\taction_code = *(payload + sizeof(struct ieee80211_hdr)\n\t\t\t\t\t+ 1);\n\t\t\tif (action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES) {\n\t\t\t\taddr2 = ieee_hdr->addr2;\n\t\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t\t    \"TDLS discovery response %pM nf=%d, snr=%d\\n\",\n\t\t\t\t\t    addr2, rx_pd->nf, rx_pd->snr);\n\t\t\t\tmwifiex_auto_tdls_update_peer_signal(priv,\n\t\t\t\t\t\t\t\t     addr2,\n\t\t\t\t\t\t\t\t     rx_pd->snr,\n\t\t\t\t\t\t\t\t     rx_pd->nf);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_CATEGORY_BACK:\n\t\t\t \n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"drop BACK action frames\");\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"unknown public action frame category %d\\n\",\n\t\t\t\t    category);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"unknown mgmt frame subtype %#x\\n\", stype);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n \nint\nmwifiex_process_mgmt_packet(struct mwifiex_private *priv,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct rxpd *rx_pd;\n\tu16 pkt_len;\n\tstruct ieee80211_hdr *ieee_hdr;\n\n\tif (!skb)\n\t\treturn -1;\n\n\tif (!priv->mgmt_frame_mask ||\n\t    priv->wdev.iftype == NL80211_IFTYPE_UNSPECIFIED) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"do not receive mgmt frames on uninitialized intf\");\n\t\treturn -1;\n\t}\n\n\trx_pd = (struct rxpd *)skb->data;\n\tpkt_len = le16_to_cpu(rx_pd->rx_pkt_length);\n\tif (pkt_len < sizeof(struct ieee80211_hdr) + sizeof(pkt_len)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"invalid rx_pkt_length\");\n\t\treturn -1;\n\t}\n\n\tskb_pull(skb, le16_to_cpu(rx_pd->rx_pkt_offset));\n\tskb_pull(skb, sizeof(pkt_len));\n\tpkt_len -= sizeof(pkt_len);\n\n\tieee_hdr = (void *)skb->data;\n\tif (ieee80211_is_mgmt(ieee_hdr->frame_control)) {\n\t\tif (mwifiex_parse_mgmt_packet(priv, (u8 *)ieee_hdr,\n\t\t\t\t\t      pkt_len, rx_pd))\n\t\t\treturn -1;\n\t}\n\t \n\tmemmove(skb->data + sizeof(struct ieee80211_hdr_3addr),\n\t\tskb->data + sizeof(struct ieee80211_hdr),\n\t\tpkt_len - sizeof(struct ieee80211_hdr));\n\n\tpkt_len -= ETH_ALEN;\n\trx_pd->rx_pkt_length = cpu_to_le16(pkt_len);\n\n\tcfg80211_rx_mgmt(&priv->wdev, priv->roc_cfg.chan.center_freq,\n\t\t\t CAL_RSSI(rx_pd->snr, rx_pd->nf), skb->data, pkt_len,\n\t\t\t 0);\n\n\treturn 0;\n}\n\n \nint mwifiex_recv_packet(struct mwifiex_private *priv, struct sk_buff *skb)\n{\n\tstruct mwifiex_sta_node *src_node;\n\tstruct ethhdr *p_ethhdr;\n\n\tif (!skb)\n\t\treturn -1;\n\n\tpriv->stats.rx_bytes += skb->len;\n\tpriv->stats.rx_packets++;\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\n\t\tp_ethhdr = (void *)skb->data;\n\t\tsrc_node = mwifiex_get_sta_entry(priv, p_ethhdr->h_source);\n\t\tif (src_node) {\n\t\t\tsrc_node->stats.last_rx = jiffies;\n\t\t\tsrc_node->stats.rx_bytes += skb->len;\n\t\t\tsrc_node->stats.rx_packets++;\n\t\t}\n\t}\n\n\tskb->dev = priv->netdev;\n\tskb->protocol = eth_type_trans(skb, priv->netdev);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t \n\tif ((priv->adapter->iface_type == MWIFIEX_USB ||\n\t     priv->adapter->iface_type == MWIFIEX_PCIE) &&\n\t    (skb->truesize > MWIFIEX_RX_DATA_BUF_SIZE))\n\t\tskb->truesize += (skb->len - MWIFIEX_RX_DATA_BUF_SIZE);\n\n\tnetif_rx(skb);\n\treturn 0;\n}\n\n \nint mwifiex_complete_cmd(struct mwifiex_adapter *adapter,\n\t\t\t struct cmd_ctrl_node *cmd_node)\n{\n\tWARN_ON(!cmd_node->wait_q_enabled);\n\tmwifiex_dbg(adapter, CMD, \"cmd completed: status=%d\\n\",\n\t\t    adapter->cmd_wait_q.status);\n\n\t*cmd_node->condition = true;\n\twake_up_interruptible(&adapter->cmd_wait_q.wait);\n\n\treturn 0;\n}\n\n \nstruct mwifiex_sta_node *\nmwifiex_get_sta_entry(struct mwifiex_private *priv, const u8 *mac)\n{\n\tstruct mwifiex_sta_node *node;\n\n\tif (!mac)\n\t\treturn NULL;\n\n\tlist_for_each_entry(node, &priv->sta_list, list) {\n\t\tif (!memcmp(node->mac_addr, mac, ETH_ALEN))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mwifiex_sta_node *\nmwifiex_get_tdls_sta_entry(struct mwifiex_private *priv, u8 status)\n{\n\tstruct mwifiex_sta_node *node;\n\n\tlist_for_each_entry(node, &priv->sta_list, list) {\n\t\tif (node->tdls_status == status)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\n \nu8 mwifiex_is_tdls_chan_switching(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_sta_node *sta_ptr;\n\n\tif (!priv || !ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info))\n\t\treturn false;\n\n\tsta_ptr = mwifiex_get_tdls_sta_entry(priv, TDLS_CHAN_SWITCHING);\n\tif (sta_ptr)\n\t\treturn true;\n\n\treturn false;\n}\n\nu8 mwifiex_is_tdls_off_chan(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_sta_node *sta_ptr;\n\n\tif (!priv || !ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info))\n\t\treturn false;\n\n\tsta_ptr = mwifiex_get_tdls_sta_entry(priv, TDLS_IN_OFF_CHAN);\n\tif (sta_ptr)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nu8 mwifiex_is_send_cmd_allowed(struct mwifiex_private *priv)\n{\n\tif (!priv || !ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info))\n\t\treturn true;\n\n\tif (mwifiex_is_tdls_chan_switching(priv) ||\n\t    mwifiex_is_tdls_off_chan(priv))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstruct mwifiex_sta_node *\nmwifiex_add_sta_entry(struct mwifiex_private *priv, const u8 *mac)\n{\n\tstruct mwifiex_sta_node *node;\n\n\tif (!mac)\n\t\treturn NULL;\n\n\tspin_lock_bh(&priv->sta_list_spinlock);\n\tnode = mwifiex_get_sta_entry(priv, mac);\n\tif (node)\n\t\tgoto done;\n\n\tnode = kzalloc(sizeof(*node), GFP_ATOMIC);\n\tif (!node)\n\t\tgoto done;\n\n\tmemcpy(node->mac_addr, mac, ETH_ALEN);\n\tlist_add_tail(&node->list, &priv->sta_list);\n\ndone:\n\tspin_unlock_bh(&priv->sta_list_spinlock);\n\treturn node;\n}\n\n \nvoid\nmwifiex_set_sta_ht_cap(struct mwifiex_private *priv, const u8 *ies,\n\t\t       int ies_len, struct mwifiex_sta_node *node)\n{\n\tstruct ieee_types_header *ht_cap_ie;\n\tconst struct ieee80211_ht_cap *ht_cap;\n\n\tif (!ies)\n\t\treturn;\n\n\tht_cap_ie = (void *)cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies,\n\t\t\t\t\t     ies_len);\n\tif (ht_cap_ie) {\n\t\tht_cap = (void *)(ht_cap_ie + 1);\n\t\tnode->is_11n_enabled = 1;\n\t\tnode->max_amsdu = le16_to_cpu(ht_cap->cap_info) &\n\t\t\t\t  IEEE80211_HT_CAP_MAX_AMSDU ?\n\t\t\t\t  MWIFIEX_TX_DATA_BUF_SIZE_8K :\n\t\t\t\t  MWIFIEX_TX_DATA_BUF_SIZE_4K;\n\t} else {\n\t\tnode->is_11n_enabled = 0;\n\t}\n\n\treturn;\n}\n\n \nvoid mwifiex_del_sta_entry(struct mwifiex_private *priv, const u8 *mac)\n{\n\tstruct mwifiex_sta_node *node;\n\n\tspin_lock_bh(&priv->sta_list_spinlock);\n\n\tnode = mwifiex_get_sta_entry(priv, mac);\n\tif (node) {\n\t\tlist_del(&node->list);\n\t\tkfree(node);\n\t}\n\n\tspin_unlock_bh(&priv->sta_list_spinlock);\n\treturn;\n}\n\n \nvoid mwifiex_del_all_sta_list(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_sta_node *node, *tmp;\n\n\tspin_lock_bh(&priv->sta_list_spinlock);\n\n\tlist_for_each_entry_safe(node, tmp, &priv->sta_list, list) {\n\t\tlist_del(&node->list);\n\t\tkfree(node);\n\t}\n\n\tINIT_LIST_HEAD(&priv->sta_list);\n\tspin_unlock_bh(&priv->sta_list_spinlock);\n\treturn;\n}\n\n \nvoid mwifiex_hist_data_add(struct mwifiex_private *priv,\n\t\t\t   u8 rx_rate, s8 snr, s8 nflr)\n{\n\tstruct mwifiex_histogram_data *phist_data = priv->hist_data;\n\n\tif (atomic_read(&phist_data->num_samples) > MWIFIEX_HIST_MAX_SAMPLES)\n\t\tmwifiex_hist_data_reset(priv);\n\tmwifiex_hist_data_set(priv, rx_rate, snr, nflr);\n}\n\n \nvoid mwifiex_hist_data_set(struct mwifiex_private *priv, u8 rx_rate, s8 snr,\n\t\t\t   s8 nflr)\n{\n\tstruct mwifiex_histogram_data *phist_data = priv->hist_data;\n\ts8 nf   = -nflr;\n\ts8 rssi = snr - nflr;\n\n\tatomic_inc(&phist_data->num_samples);\n\tatomic_inc(&phist_data->rx_rate[rx_rate]);\n\tatomic_inc(&phist_data->snr[snr + 128]);\n\tatomic_inc(&phist_data->noise_flr[nf + 128]);\n\tatomic_inc(&phist_data->sig_str[rssi + 128]);\n}\n\n \nvoid mwifiex_hist_data_reset(struct mwifiex_private *priv)\n{\n\tint ix;\n\tstruct mwifiex_histogram_data *phist_data = priv->hist_data;\n\n\tatomic_set(&phist_data->num_samples, 0);\n\tfor (ix = 0; ix < MWIFIEX_MAX_AC_RX_RATES; ix++)\n\t\tatomic_set(&phist_data->rx_rate[ix], 0);\n\tfor (ix = 0; ix < MWIFIEX_MAX_SNR; ix++)\n\t\tatomic_set(&phist_data->snr[ix], 0);\n\tfor (ix = 0; ix < MWIFIEX_MAX_NOISE_FLR; ix++)\n\t\tatomic_set(&phist_data->noise_flr[ix], 0);\n\tfor (ix = 0; ix < MWIFIEX_MAX_SIG_STRENGTH; ix++)\n\t\tatomic_set(&phist_data->sig_str[ix], 0);\n}\n\nvoid *mwifiex_alloc_dma_align_buf(int rx_len, gfp_t flags)\n{\n\tstruct sk_buff *skb;\n\tint buf_len, pad;\n\n\tbuf_len = rx_len + MWIFIEX_RX_HEADROOM + MWIFIEX_DMA_ALIGN_SZ;\n\n\tskb = __dev_alloc_skb(buf_len, flags);\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, MWIFIEX_RX_HEADROOM);\n\n\tpad = MWIFIEX_ALIGN_ADDR(skb->data, MWIFIEX_DMA_ALIGN_SZ) -\n\t      (long)skb->data;\n\n\tskb_reserve(skb, pad);\n\n\treturn skb;\n}\nEXPORT_SYMBOL_GPL(mwifiex_alloc_dma_align_buf);\n\nvoid mwifiex_fw_dump_event(struct mwifiex_private *priv)\n{\n\tmwifiex_send_cmd(priv, HostCmd_CMD_FW_DUMP_EVENT, HostCmd_ACT_GEN_SET,\n\t\t\t 0, NULL, true);\n}\nEXPORT_SYMBOL_GPL(mwifiex_fw_dump_event);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}