{
  "module_name": "uap_event.c",
  "hash_id": "510d1c25ac3ee6591be7bbc648580eb5ca5396af2b5ecf540fd7b732b04965f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/uap_event.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"main.h\"\n#include \"11n.h\"\n\n#define MWIFIEX_BSS_START_EVT_FIX_SIZE    12\n\nstatic int mwifiex_check_uap_capabilities(struct mwifiex_private *priv,\n\t\t\t\t\t  struct sk_buff *event)\n{\n\tint evt_len;\n\tu8 *curr;\n\tu16 tlv_len;\n\tstruct mwifiex_ie_types_data *tlv_hdr;\n\tstruct ieee_types_wmm_parameter *wmm_param_ie = NULL;\n\tint mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK;\n\n\tpriv->wmm_enabled = false;\n\tskb_pull(event, MWIFIEX_BSS_START_EVT_FIX_SIZE);\n\tevt_len = event->len;\n\tcurr = event->data;\n\n\tmwifiex_dbg_dump(priv->adapter, EVT_D, \"uap capabilities:\",\n\t\t\t event->data, event->len);\n\n\tskb_push(event, MWIFIEX_BSS_START_EVT_FIX_SIZE);\n\n\twhile ((evt_len >= sizeof(tlv_hdr->header))) {\n\t\ttlv_hdr = (struct mwifiex_ie_types_data *)curr;\n\t\ttlv_len = le16_to_cpu(tlv_hdr->header.len);\n\n\t\tif (evt_len < tlv_len + sizeof(tlv_hdr->header))\n\t\t\tbreak;\n\n\t\tswitch (le16_to_cpu(tlv_hdr->header.type)) {\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\t\tpriv->ap_11n_enabled = true;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\t\tpriv->ap_11ac_enabled = true;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t \n\t\t\twmm_param_ie = (void *)(curr + 2);\n\t\t\twmm_param_ie->vend_hdr.len = (u8)tlv_len;\n\t\t\twmm_param_ie->vend_hdr.element_id =\n\t\t\t\t\t\tWLAN_EID_VENDOR_SPECIFIC;\n\t\t\tmwifiex_dbg(priv->adapter, EVENT,\n\t\t\t\t    \"info: check uap capabilities:\\t\"\n\t\t\t\t    \"wmm parameter set count: %d\\n\",\n\t\t\t\t    wmm_param_ie->qos_info_bitmap & mask);\n\n\t\t\tmwifiex_wmm_setup_ac_downgrade(priv);\n\t\t\tpriv->wmm_enabled = true;\n\t\t\tmwifiex_wmm_setup_queue_priorities(priv, wmm_param_ie);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr += (tlv_len + sizeof(tlv_hdr->header));\n\t\tevt_len -= (tlv_len + sizeof(tlv_hdr->header));\n\t}\n\n\treturn 0;\n}\n\n \nint mwifiex_process_uap_event(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint len, i;\n\tu32 eventcause = adapter->event_cause;\n\tstruct station_info *sinfo;\n\tstruct mwifiex_assoc_event *event;\n\tstruct mwifiex_sta_node *node;\n\tu8 *deauth_mac;\n\tstruct host_cmd_ds_11n_batimeout *ba_timeout;\n\tu16 ctrl;\n\n\tswitch (eventcause) {\n\tcase EVENT_UAP_STA_ASSOC:\n\t\tsinfo = kzalloc(sizeof(*sinfo), GFP_KERNEL);\n\t\tif (!sinfo)\n\t\t\treturn -ENOMEM;\n\n\t\tevent = (struct mwifiex_assoc_event *)\n\t\t\t(adapter->event_body + MWIFIEX_UAP_EVENT_EXTRA_HEADER);\n\t\tif (le16_to_cpu(event->type) == TLV_TYPE_UAP_MGMT_FRAME) {\n\t\t\tlen = -1;\n\n\t\t\tif (ieee80211_is_assoc_req(event->frame_control))\n\t\t\t\tlen = 0;\n\t\t\telse if (ieee80211_is_reassoc_req(event->frame_control))\n\t\t\t\t \n\t\t\t\tlen = ETH_ALEN;\n\n\t\t\tif (len != -1) {\n\t\t\t\tsinfo->assoc_req_ies = &event->data[len];\n\t\t\t\tlen = (u8 *)sinfo->assoc_req_ies -\n\t\t\t\t      (u8 *)&event->frame_control;\n\t\t\t\tsinfo->assoc_req_ies_len =\n\t\t\t\t\tle16_to_cpu(event->len) - (u16)len;\n\t\t\t}\n\t\t}\n\t\tcfg80211_new_sta(priv->netdev, event->sta_addr, sinfo,\n\t\t\t\t GFP_KERNEL);\n\n\t\tnode = mwifiex_add_sta_entry(priv, event->sta_addr);\n\t\tif (!node) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"could not create station entry!\\n\");\n\t\t\tkfree(sinfo);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!priv->ap_11n_enabled) {\n\t\t\tkfree(sinfo);\n\t\t\tbreak;\n\t\t}\n\n\t\tmwifiex_set_sta_ht_cap(priv, sinfo->assoc_req_ies,\n\t\t\t\t       sinfo->assoc_req_ies_len, node);\n\n\t\tfor (i = 0; i < MAX_NUM_TID; i++) {\n\t\t\tif (node->is_11n_enabled)\n\t\t\t\tnode->ampdu_sta[i] =\n\t\t\t\t\t      priv->aggr_prio_tbl[i].ampdu_user;\n\t\t\telse\n\t\t\t\tnode->ampdu_sta[i] = BA_STREAM_NOT_ALLOWED;\n\t\t}\n\t\tmemset(node->rx_seq, 0xff, sizeof(node->rx_seq));\n\t\tkfree(sinfo);\n\t\tbreak;\n\tcase EVENT_UAP_STA_DEAUTH:\n\t\tdeauth_mac = adapter->event_body +\n\t\t\t     MWIFIEX_UAP_EVENT_EXTRA_HEADER;\n\t\tcfg80211_del_sta(priv->netdev, deauth_mac, GFP_KERNEL);\n\n\t\tif (priv->ap_11n_enabled) {\n\t\t\tmwifiex_11n_del_rx_reorder_tbl_by_ta(priv, deauth_mac);\n\t\t\tmwifiex_del_tx_ba_stream_tbl_by_ra(priv, deauth_mac);\n\t\t}\n\t\tmwifiex_wmm_del_peer_ra_list(priv, deauth_mac);\n\t\tmwifiex_del_sta_entry(priv, deauth_mac);\n\t\tbreak;\n\tcase EVENT_UAP_BSS_IDLE:\n\t\tpriv->media_connected = false;\n\t\tpriv->port_open = false;\n\t\tmwifiex_clean_txrx(priv);\n\t\tmwifiex_del_all_sta_list(priv);\n\t\tbreak;\n\tcase EVENT_UAP_BSS_ACTIVE:\n\t\tpriv->media_connected = true;\n\t\tpriv->port_open = true;\n\t\tbreak;\n\tcase EVENT_UAP_BSS_START:\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"AP EVENT: event id: %#x\\n\", eventcause);\n\t\tpriv->port_open = false;\n\t\teth_hw_addr_set(priv->netdev, adapter->event_body + 2);\n\t\tif (priv->hist_data)\n\t\t\tmwifiex_hist_data_reset(priv);\n\t\tmwifiex_check_uap_capabilities(priv, adapter->event_skb);\n\t\tbreak;\n\tcase EVENT_UAP_MIC_COUNTERMEASURES:\n\t\t \n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"AP EVENT: event id: %#x\\n\", eventcause);\n\t\tbreak;\n\tcase EVENT_AMSDU_AGGR_CTRL:\n\t\tctrl = get_unaligned_le16(adapter->event_body);\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"event: AMSDU_AGGR_CTRL %d\\n\", ctrl);\n\n\t\tif (priv->media_connected) {\n\t\t\tadapter->tx_buf_size =\n\t\t\t\tmin_t(u16, adapter->curr_tx_buf_size, ctrl);\n\t\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t\t    \"event: tx_buf_size %d\\n\",\n\t\t\t\t    adapter->tx_buf_size);\n\t\t}\n\t\tbreak;\n\tcase EVENT_ADDBA:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: ADDBA Request\\n\");\n\t\tif (priv->media_connected)\n\t\t\tmwifiex_send_cmd(priv, HostCmd_CMD_11N_ADDBA_RSP,\n\t\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t\t adapter->event_body, false);\n\t\tbreak;\n\tcase EVENT_DELBA:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: DELBA Request\\n\");\n\t\tif (priv->media_connected)\n\t\t\tmwifiex_11n_delete_ba_stream(priv, adapter->event_body);\n\t\tbreak;\n\tcase EVENT_BA_STREAM_TIEMOUT:\n\t\tmwifiex_dbg(adapter, EVENT, \"event:  BA Stream timeout\\n\");\n\t\tif (priv->media_connected) {\n\t\t\tba_timeout = (void *)adapter->event_body;\n\t\t\tmwifiex_11n_ba_stream_timeout(priv, ba_timeout);\n\t\t}\n\t\tbreak;\n\tcase EVENT_EXT_SCAN_REPORT:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: EXT_SCAN Report\\n\");\n\t\tif (adapter->ext_scan)\n\t\t\treturn mwifiex_handle_event_ext_scan_report(priv,\n\t\t\t\t\t\tadapter->event_skb->data);\n\t\tbreak;\n\tcase EVENT_TX_STATUS_REPORT:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: TX_STATUS Report\\n\");\n\t\tmwifiex_parse_tx_status_event(priv, adapter->event_body);\n\t\tbreak;\n\tcase EVENT_PS_SLEEP:\n\t\tmwifiex_dbg(adapter, EVENT, \"info: EVENT: SLEEP\\n\");\n\n\t\tadapter->ps_state = PS_STATE_PRE_SLEEP;\n\n\t\tmwifiex_check_ps_cond(adapter);\n\t\tbreak;\n\n\tcase EVENT_PS_AWAKE:\n\t\tmwifiex_dbg(adapter, EVENT, \"info: EVENT: AWAKE\\n\");\n\t\tif (!adapter->pps_uapsd_mode &&\n\t\t    priv->media_connected && adapter->sleep_period.period) {\n\t\t\t\tadapter->pps_uapsd_mode = true;\n\t\t\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t\t\t    \"event: PPS/UAPSD mode activated\\n\");\n\t\t}\n\t\tadapter->tx_lock_flag = false;\n\t\tif (adapter->pps_uapsd_mode && adapter->gen_null_pkt) {\n\t\t\tif (mwifiex_check_last_packet_indication(priv)) {\n\t\t\t\tif (adapter->data_sent ||\n\t\t\t\t    (adapter->if_ops.is_port_ready &&\n\t\t\t\t     !adapter->if_ops.is_port_ready(priv))) {\n\t\t\t\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t\t\t\t\tadapter->pm_wakeup_card_req = false;\n\t\t\t\t\tadapter->pm_wakeup_fw_try = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!mwifiex_send_null_packet\n\t\t\t\t\t(priv,\n\t\t\t\t\t MWIFIEX_TxPD_POWER_MGMT_NULL_PACKET |\n\t\t\t\t\t MWIFIEX_TxPD_POWER_MGMT_LAST_PACKET))\n\t\t\t\t\t\tadapter->ps_state =\n\t\t\t\t\t\t\tPS_STATE_SLEEP;\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tadapter->ps_state = PS_STATE_AWAKE;\n\t\tadapter->pm_wakeup_card_req = false;\n\t\tadapter->pm_wakeup_fw_try = false;\n\t\tbreak;\n\n\tcase EVENT_CHANNEL_REPORT_RDY:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Channel Report\\n\");\n\t\tmwifiex_11h_handle_chanrpt_ready(priv, adapter->event_skb);\n\t\tbreak;\n\tcase EVENT_RADAR_DETECTED:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: Radar detected\\n\");\n\t\tmwifiex_11h_handle_radar_detected(priv, adapter->event_skb);\n\t\tbreak;\n\tcase EVENT_BT_COEX_WLAN_PARA_CHANGE:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: BT coex wlan param update\\n\");\n\t\tmwifiex_bt_coex_wlan_param_update_event(priv,\n\t\t\t\t\t\t\tadapter->event_skb);\n\t\tbreak;\n\tcase EVENT_TX_DATA_PAUSE:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: TX DATA PAUSE\\n\");\n\t\tmwifiex_process_tx_pause_event(priv, adapter->event_skb);\n\t\tbreak;\n\n\tcase EVENT_MULTI_CHAN_INFO:\n\t\tmwifiex_dbg(adapter, EVENT, \"event: multi-chan info\\n\");\n\t\tmwifiex_process_multi_chan_event(priv, adapter->event_skb);\n\t\tbreak;\n\tcase EVENT_RXBA_SYNC:\n\t\tdev_dbg(adapter->dev, \"EVENT: RXBA_SYNC\\n\");\n\t\tmwifiex_11n_rxba_sync_event(priv, adapter->event_body,\n\t\t\t\t\t    adapter->event_skb->len -\n\t\t\t\t\t    sizeof(eventcause));\n\t\tbreak;\n\n\tcase EVENT_REMAIN_ON_CHAN_EXPIRED:\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"event: uap: Remain on channel expired\\n\");\n\t\tcfg80211_remain_on_channel_expired(&priv->wdev,\n\t\t\t\t\t\t   priv->roc_cfg.cookie,\n\t\t\t\t\t\t   &priv->roc_cfg.chan,\n\t\t\t\t\t\t   GFP_ATOMIC);\n\t\tmemset(&priv->roc_cfg, 0x00, sizeof(struct mwifiex_roc_cfg));\n\t\tbreak;\n\n\tdefault:\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"event: unknown event id: %#x\\n\", eventcause);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nvoid mwifiex_uap_del_sta_data(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_sta_node *node)\n{\n\tif (priv->ap_11n_enabled && node->is_11n_enabled) {\n\t\tmwifiex_11n_del_rx_reorder_tbl_by_ta(priv, node->mac_addr);\n\t\tmwifiex_del_tx_ba_stream_tbl_by_ra(priv, node->mac_addr);\n\t}\n\tmwifiex_del_sta_entry(priv, node->mac_addr);\n\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}