{
  "module_name": "tdls.c",
  "hash_id": "5fbcaa5a5445a67dfb1aa9b0daab68ea611aa0b95585b0b574b1bd95cabedac7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/tdls.c",
  "human_readable_source": " \n\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"11n_rxreorder.h\"\n#include \"11ac.h\"\n\n#define TDLS_REQ_FIX_LEN      6\n#define TDLS_RESP_FIX_LEN     8\n#define TDLS_CONFIRM_FIX_LEN  6\n#define MWIFIEX_TDLS_WMM_INFO_SIZE 7\n\nstatic void mwifiex_restore_tdls_packets(struct mwifiex_private *priv,\n\t\t\t\t\t const u8 *mac, u8 status)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tstruct list_head *tid_list;\n\tstruct sk_buff *skb, *tmp;\n\tstruct mwifiex_txinfo *tx_info;\n\tu32 tid;\n\tu8 tid_down;\n\n\tmwifiex_dbg(priv->adapter, DATA, \"%s: %pM\\n\", __func__, mac);\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tskb_queue_walk_safe(&priv->tdls_txq, skb, tmp) {\n\t\tif (!ether_addr_equal(mac, skb->data))\n\t\t\tcontinue;\n\n\t\t__skb_unlink(skb, &priv->tdls_txq);\n\t\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\t\ttid = skb->priority;\n\t\ttid_down = mwifiex_wmm_downgrade_tid(priv, tid);\n\n\t\tif (mwifiex_is_tdls_link_setup(status)) {\n\t\t\tra_list = mwifiex_wmm_get_queue_raptr(priv, tid, mac);\n\t\t\tra_list->tdls_link = true;\n\t\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_TDLS_PKT;\n\t\t} else {\n\t\t\ttid_list = &priv->wmm.tid_tbl_ptr[tid_down].ra_list;\n\t\t\tra_list = list_first_entry_or_null(tid_list,\n\t\t\t\t\tstruct mwifiex_ra_list_tbl, list);\n\t\t\ttx_info->flags &= ~MWIFIEX_BUF_FLAG_TDLS_PKT;\n\t\t}\n\n\t\tif (!ra_list) {\n\t\t\tmwifiex_write_data_complete(priv->adapter, skb, 0, -1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tskb_queue_tail(&ra_list->skb_head, skb);\n\n\t\tra_list->ba_pkt_count++;\n\t\tra_list->total_pkt_count++;\n\n\t\tif (atomic_read(&priv->wmm.highest_queued_prio) <\n\t\t\t\t\t\t       tos_to_tid_inv[tid_down])\n\t\t\tatomic_set(&priv->wmm.highest_queued_prio,\n\t\t\t\t   tos_to_tid_inv[tid_down]);\n\n\t\tatomic_inc(&priv->wmm.tx_pkts_queued);\n\t}\n\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\treturn;\n}\n\nstatic void mwifiex_hold_tdls_packets(struct mwifiex_private *priv,\n\t\t\t\t      const u8 *mac)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tstruct list_head *ra_list_head;\n\tstruct sk_buff *skb, *tmp;\n\tint i;\n\n\tmwifiex_dbg(priv->adapter, DATA, \"%s: %pM\\n\", __func__, mac);\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tfor (i = 0; i < MAX_NUM_TID; i++) {\n\t\tif (!list_empty(&priv->wmm.tid_tbl_ptr[i].ra_list)) {\n\t\t\tra_list_head = &priv->wmm.tid_tbl_ptr[i].ra_list;\n\t\t\tlist_for_each_entry(ra_list, ra_list_head, list) {\n\t\t\t\tskb_queue_walk_safe(&ra_list->skb_head, skb,\n\t\t\t\t\t\t    tmp) {\n\t\t\t\t\tif (!ether_addr_equal(mac, skb->data))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t__skb_unlink(skb, &ra_list->skb_head);\n\t\t\t\t\tatomic_dec(&priv->wmm.tx_pkts_queued);\n\t\t\t\t\tra_list->total_pkt_count--;\n\t\t\t\t\tskb_queue_tail(&priv->tdls_txq, skb);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\treturn;\n}\n\n \nstatic int\nmwifiex_tdls_append_rates_ie(struct mwifiex_private *priv,\n\t\t\t     struct sk_buff *skb)\n{\n\tu8 rates[MWIFIEX_SUPPORTED_RATES], *pos;\n\tu16 rates_size, supp_rates_size, ext_rates_size;\n\n\tmemset(rates, 0, sizeof(rates));\n\trates_size = mwifiex_get_supported_rates(priv, rates);\n\n\tsupp_rates_size = min_t(u16, rates_size, MWIFIEX_TDLS_SUPPORTED_RATES);\n\n\tif (skb_tailroom(skb) < rates_size + 4) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Insufficient space while adding rates\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpos = skb_put(skb, supp_rates_size + 2);\n\t*pos++ = WLAN_EID_SUPP_RATES;\n\t*pos++ = supp_rates_size;\n\tmemcpy(pos, rates, supp_rates_size);\n\n\tif (rates_size > MWIFIEX_TDLS_SUPPORTED_RATES) {\n\t\text_rates_size = rates_size - MWIFIEX_TDLS_SUPPORTED_RATES;\n\t\tpos = skb_put(skb, ext_rates_size + 2);\n\t\t*pos++ = WLAN_EID_EXT_SUPP_RATES;\n\t\t*pos++ = ext_rates_size;\n\t\tmemcpy(pos, rates + MWIFIEX_TDLS_SUPPORTED_RATES,\n\t\t       ext_rates_size);\n\t}\n\n\treturn 0;\n}\n\nstatic void mwifiex_tdls_add_aid(struct mwifiex_private *priv,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee_types_assoc_rsp *assoc_rsp;\n\tu8 *pos;\n\n\tassoc_rsp = (struct ieee_types_assoc_rsp *)&priv->assoc_rsp_buf;\n\tpos = skb_put(skb, 4);\n\t*pos++ = WLAN_EID_AID;\n\t*pos++ = 2;\n\tmemcpy(pos, &assoc_rsp->a_id, sizeof(assoc_rsp->a_id));\n\n\treturn;\n}\n\nstatic int mwifiex_tdls_add_vht_capab(struct mwifiex_private *priv,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_vht_cap vht_cap;\n\tu8 *pos;\n\n\tpos = skb_put(skb, sizeof(struct ieee80211_vht_cap) + 2);\n\t*pos++ = WLAN_EID_VHT_CAPABILITY;\n\t*pos++ = sizeof(struct ieee80211_vht_cap);\n\n\tmemset(&vht_cap, 0, sizeof(struct ieee80211_vht_cap));\n\n\tmwifiex_fill_vht_cap_tlv(priv, &vht_cap, priv->curr_bss_params.band);\n\tmemcpy(pos, &vht_cap, sizeof(vht_cap));\n\n\treturn 0;\n}\n\nstatic int\nmwifiex_tdls_add_ht_oper(struct mwifiex_private *priv, const u8 *mac,\n\t\t\t u8 vht_enabled, struct sk_buff *skb)\n{\n\tstruct ieee80211_ht_operation *ht_oper;\n\tstruct mwifiex_sta_node *sta_ptr;\n\tstruct mwifiex_bssdescriptor *bss_desc =\n\t\t\t\t\t&priv->curr_bss_params.bss_descriptor;\n\tu8 *pos;\n\n\tsta_ptr = mwifiex_get_sta_entry(priv, mac);\n\tif (unlikely(!sta_ptr)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"TDLS peer station not found in list\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!(le16_to_cpu(sta_ptr->tdls_cap.ht_capb.cap_info))) {\n\t\tmwifiex_dbg(priv->adapter, WARN,\n\t\t\t    \"TDLS peer doesn't support ht capabilities\\n\");\n\t\treturn 0;\n\t}\n\n\tpos = skb_put(skb, sizeof(struct ieee80211_ht_operation) + 2);\n\t*pos++ = WLAN_EID_HT_OPERATION;\n\t*pos++ = sizeof(struct ieee80211_ht_operation);\n\tht_oper = (void *)pos;\n\n\tht_oper->primary_chan = bss_desc->channel;\n\n\t \n\tif (ISSUPP_CHANWIDTH40(priv->adapter->hw_dot_11n_dev_cap) &&\n\t    bss_desc->bcn_ht_cap &&\n\t    ISALLOWED_CHANWIDTH40(bss_desc->bcn_ht_oper->ht_param))\n\t\tht_oper->ht_param = bss_desc->bcn_ht_oper->ht_param;\n\n\tif (vht_enabled) {\n\t\tht_oper->ht_param =\n\t\t\t  mwifiex_get_sec_chan_offset(bss_desc->channel);\n\t\tht_oper->ht_param |= BIT(2);\n\t}\n\n\tmemcpy(&sta_ptr->tdls_cap.ht_oper, ht_oper,\n\t       sizeof(struct ieee80211_ht_operation));\n\n\treturn 0;\n}\n\nstatic int mwifiex_tdls_add_vht_oper(struct mwifiex_private *priv,\n\t\t\t\t     const u8 *mac, struct sk_buff *skb)\n{\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tstruct ieee80211_vht_operation *vht_oper;\n\tstruct ieee80211_vht_cap *vht_cap, *ap_vht_cap = NULL;\n\tstruct mwifiex_sta_node *sta_ptr;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu8 supp_chwd_set, peer_supp_chwd_set;\n\tu8 *pos, ap_supp_chwd_set, chan_bw;\n\tu16 mcs_map_user, mcs_map_resp, mcs_map_result;\n\tu16 mcs_user, mcs_resp, nss;\n\tu32 usr_vht_cap_info;\n\n\tbss_desc = &priv->curr_bss_params.bss_descriptor;\n\n\tsta_ptr = mwifiex_get_sta_entry(priv, mac);\n\tif (unlikely(!sta_ptr)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"TDLS peer station not found in list\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!(le32_to_cpu(sta_ptr->tdls_cap.vhtcap.vht_cap_info))) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"TDLS peer doesn't support vht capabilities\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!mwifiex_is_bss_in_11ac_mode(priv)) {\n\t\tif (sta_ptr->tdls_cap.extcap.ext_capab[7] &\n\t\t   WLAN_EXT_CAPA8_TDLS_WIDE_BW_ENABLED) {\n\t\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t\t    \"TDLS peer doesn't support wider bandwidth\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tap_vht_cap = bss_desc->bcn_vht_cap;\n\t}\n\n\tpos = skb_put(skb, sizeof(struct ieee80211_vht_operation) + 2);\n\t*pos++ = WLAN_EID_VHT_OPERATION;\n\t*pos++ = sizeof(struct ieee80211_vht_operation);\n\tvht_oper = (struct ieee80211_vht_operation *)pos;\n\n\tif (bss_desc->bss_band & BAND_A)\n\t\tusr_vht_cap_info = adapter->usr_dot_11ac_dev_cap_a;\n\telse\n\t\tusr_vht_cap_info = adapter->usr_dot_11ac_dev_cap_bg;\n\n\t \n\tvht_cap = &sta_ptr->tdls_cap.vhtcap;\n\tsupp_chwd_set = GET_VHTCAP_CHWDSET(usr_vht_cap_info);\n\tpeer_supp_chwd_set =\n\t\t\t GET_VHTCAP_CHWDSET(le32_to_cpu(vht_cap->vht_cap_info));\n\tsupp_chwd_set = min_t(u8, supp_chwd_set, peer_supp_chwd_set);\n\n\t \n\n\tif (ap_vht_cap && sta_ptr->tdls_cap.extcap.ext_capab[7] &\n\t    WLAN_EXT_CAPA8_TDLS_WIDE_BW_ENABLED) {\n\t\tap_supp_chwd_set =\n\t\t      GET_VHTCAP_CHWDSET(le32_to_cpu(ap_vht_cap->vht_cap_info));\n\t\tsupp_chwd_set = min_t(u8, supp_chwd_set, ap_supp_chwd_set);\n\t}\n\n\tswitch (supp_chwd_set) {\n\tcase IEEE80211_VHT_CHANWIDTH_80MHZ:\n\t\tvht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_80MHZ;\n\t\tbreak;\n\tcase IEEE80211_VHT_CHANWIDTH_160MHZ:\n\t\tvht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_160MHZ;\n\t\tbreak;\n\tcase IEEE80211_VHT_CHANWIDTH_80P80MHZ:\n\t\tvht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_80P80MHZ;\n\t\tbreak;\n\tdefault:\n\t\tvht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_USE_HT;\n\t\tbreak;\n\t}\n\n\tmcs_map_user = GET_DEVRXMCSMAP(adapter->usr_dot_11ac_mcs_support);\n\tmcs_map_resp = le16_to_cpu(vht_cap->supp_mcs.rx_mcs_map);\n\tmcs_map_result = 0;\n\n\tfor (nss = 1; nss <= 8; nss++) {\n\t\tmcs_user = GET_VHTNSSMCS(mcs_map_user, nss);\n\t\tmcs_resp = GET_VHTNSSMCS(mcs_map_resp, nss);\n\n\t\tif ((mcs_user == IEEE80211_VHT_MCS_NOT_SUPPORTED) ||\n\t\t    (mcs_resp == IEEE80211_VHT_MCS_NOT_SUPPORTED))\n\t\t\tSET_VHTNSSMCS(mcs_map_result, nss,\n\t\t\t\t      IEEE80211_VHT_MCS_NOT_SUPPORTED);\n\t\telse\n\t\t\tSET_VHTNSSMCS(mcs_map_result, nss,\n\t\t\t\t      min_t(u16, mcs_user, mcs_resp));\n\t}\n\n\tvht_oper->basic_mcs_set = cpu_to_le16(mcs_map_result);\n\n\tswitch (vht_oper->chan_width) {\n\tcase IEEE80211_VHT_CHANWIDTH_80MHZ:\n\t\tchan_bw = IEEE80211_VHT_CHANWIDTH_80MHZ;\n\t\tbreak;\n\tcase IEEE80211_VHT_CHANWIDTH_160MHZ:\n\t\tchan_bw = IEEE80211_VHT_CHANWIDTH_160MHZ;\n\t\tbreak;\n\tcase IEEE80211_VHT_CHANWIDTH_80P80MHZ:\n\t\tchan_bw = IEEE80211_VHT_CHANWIDTH_80MHZ;\n\t\tbreak;\n\tdefault:\n\t\tchan_bw = IEEE80211_VHT_CHANWIDTH_USE_HT;\n\t\tbreak;\n\t}\n\tvht_oper->center_freq_seg0_idx =\n\t\t\tmwifiex_get_center_freq_index(priv, BAND_AAC,\n\t\t\t\t\t\t      bss_desc->channel,\n\t\t\t\t\t\t      chan_bw);\n\n\treturn 0;\n}\n\nstatic void mwifiex_tdls_add_ext_capab(struct mwifiex_private *priv,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct ieee_types_extcap *extcap;\n\n\textcap = skb_put(skb, sizeof(struct ieee_types_extcap));\n\textcap->ieee_hdr.element_id = WLAN_EID_EXT_CAPABILITY;\n\textcap->ieee_hdr.len = 8;\n\tmemset(extcap->ext_capab, 0, 8);\n\textcap->ext_capab[4] |= WLAN_EXT_CAPA5_TDLS_ENABLED;\n\textcap->ext_capab[3] |= WLAN_EXT_CAPA4_TDLS_CHAN_SWITCH;\n\n\tif (priv->adapter->is_hw_11ac_capable)\n\t\textcap->ext_capab[7] |= WLAN_EXT_CAPA8_TDLS_WIDE_BW_ENABLED;\n}\n\nstatic void mwifiex_tdls_add_qos_capab(struct sk_buff *skb)\n{\n\tu8 *pos = skb_put(skb, 3);\n\n\t*pos++ = WLAN_EID_QOS_CAPA;\n\t*pos++ = 1;\n\t*pos++ = MWIFIEX_TDLS_DEF_QOS_CAPAB;\n}\n\nstatic void\nmwifiex_tdls_add_wmm_param_ie(struct mwifiex_private *priv, struct sk_buff *skb)\n{\n\tstruct ieee80211_wmm_param_ie *wmm;\n\tu8 ac_vi[] = {0x42, 0x43, 0x5e, 0x00};\n\tu8 ac_vo[] = {0x62, 0x32, 0x2f, 0x00};\n\tu8 ac_be[] = {0x03, 0xa4, 0x00, 0x00};\n\tu8 ac_bk[] = {0x27, 0xa4, 0x00, 0x00};\n\n\twmm = skb_put_zero(skb, sizeof(*wmm));\n\n\twmm->element_id = WLAN_EID_VENDOR_SPECIFIC;\n\twmm->len = sizeof(*wmm) - 2;\n\twmm->oui[0] = 0x00;  \n\twmm->oui[1] = 0x50;\n\twmm->oui[2] = 0xf2;\n\twmm->oui_type = 2;  \n\twmm->oui_subtype = 1;  \n\twmm->version = 1;  \n\twmm->qos_info = 0;  \n\n\t \n\tmemcpy(&wmm->ac[0], ac_be, sizeof(ac_be));\n\tmemcpy(&wmm->ac[1], ac_bk, sizeof(ac_bk));\n\tmemcpy(&wmm->ac[2], ac_vi, sizeof(ac_vi));\n\tmemcpy(&wmm->ac[3], ac_vo, sizeof(ac_vo));\n}\n\nstatic void\nmwifiex_add_wmm_info_ie(struct mwifiex_private *priv, struct sk_buff *skb,\n\t\t\tu8 qosinfo)\n{\n\tu8 *buf;\n\n\tbuf = skb_put(skb,\n\t\t      MWIFIEX_TDLS_WMM_INFO_SIZE + sizeof(struct ieee_types_header));\n\n\t*buf++ = WLAN_EID_VENDOR_SPECIFIC;\n\t*buf++ = 7;  \n\t*buf++ = 0x00;  \n\t*buf++ = 0x50;\n\t*buf++ = 0xf2;\n\t*buf++ = 2;  \n\t*buf++ = 0;  \n\t*buf++ = 1;  \n\t*buf++ = qosinfo;  \n}\n\nstatic void mwifiex_tdls_add_bss_co_2040(struct sk_buff *skb)\n{\n\tstruct ieee_types_bss_co_2040 *bssco;\n\n\tbssco = skb_put(skb, sizeof(struct ieee_types_bss_co_2040));\n\tbssco->ieee_hdr.element_id = WLAN_EID_BSS_COEX_2040;\n\tbssco->ieee_hdr.len = sizeof(struct ieee_types_bss_co_2040) -\n\t\t\t      sizeof(struct ieee_types_header);\n\tbssco->bss_2040co = 0x01;\n}\n\nstatic void mwifiex_tdls_add_supported_chan(struct sk_buff *skb)\n{\n\tstruct ieee_types_generic *supp_chan;\n\tu8 chan_supp[] = {1, 11};\n\n\tsupp_chan = skb_put(skb,\n\t\t\t    (sizeof(struct ieee_types_header) + sizeof(chan_supp)));\n\tsupp_chan->ieee_hdr.element_id = WLAN_EID_SUPPORTED_CHANNELS;\n\tsupp_chan->ieee_hdr.len = sizeof(chan_supp);\n\tmemcpy(supp_chan->data, chan_supp, sizeof(chan_supp));\n}\n\nstatic void mwifiex_tdls_add_oper_class(struct sk_buff *skb)\n{\n\tstruct ieee_types_generic *reg_class;\n\tu8 rc_list[] = {1,\n\t\t1, 2, 3, 4, 12, 22, 23, 24, 25, 27, 28, 29, 30, 32, 33};\n\treg_class = skb_put(skb,\n\t\t\t    (sizeof(struct ieee_types_header) + sizeof(rc_list)));\n\treg_class->ieee_hdr.element_id = WLAN_EID_SUPPORTED_REGULATORY_CLASSES;\n\treg_class->ieee_hdr.len = sizeof(rc_list);\n\tmemcpy(reg_class->data, rc_list, sizeof(rc_list));\n}\n\nstatic int mwifiex_prep_tdls_encap_data(struct mwifiex_private *priv,\n\t\t\t\t\tconst u8 *peer, u8 action_code,\n\t\t\t\t\tu8 dialog_token,\n\t\t\t\t\tu16 status_code, struct sk_buff *skb)\n{\n\tstruct ieee80211_tdls_data *tf;\n\tint ret;\n\tu16 capab;\n\tstruct ieee80211_ht_cap *ht_cap;\n\tu8 radio, *pos;\n\n\tcapab = priv->curr_bss_params.bss_descriptor.cap_info_bitmap;\n\n\ttf = skb_put(skb, offsetof(struct ieee80211_tdls_data, u));\n\tmemcpy(tf->da, peer, ETH_ALEN);\n\tmemcpy(tf->sa, priv->curr_addr, ETH_ALEN);\n\ttf->ether_type = cpu_to_be16(ETH_P_TDLS);\n\ttf->payload_type = WLAN_TDLS_SNAP_RFTYPE;\n\n\tswitch (action_code) {\n\tcase WLAN_TDLS_SETUP_REQUEST:\n\t\ttf->category = WLAN_CATEGORY_TDLS;\n\t\ttf->action_code = WLAN_TDLS_SETUP_REQUEST;\n\t\tskb_put(skb, sizeof(tf->u.setup_req));\n\t\ttf->u.setup_req.dialog_token = dialog_token;\n\t\ttf->u.setup_req.capability = cpu_to_le16(capab);\n\t\tret = mwifiex_tdls_append_rates_ie(priv, skb);\n\t\tif (ret) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);\n\t\t*pos++ = WLAN_EID_HT_CAPABILITY;\n\t\t*pos++ = sizeof(struct ieee80211_ht_cap);\n\t\tht_cap = (void *)pos;\n\t\tradio = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n\t\tret = mwifiex_fill_cap_info(priv, radio, ht_cap);\n\t\tif (ret) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (priv->adapter->is_hw_11ac_capable) {\n\t\t\tret = mwifiex_tdls_add_vht_capab(priv, skb);\n\t\t\tif (ret) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tmwifiex_tdls_add_aid(priv, skb);\n\t\t}\n\n\t\tmwifiex_tdls_add_ext_capab(priv, skb);\n\t\tmwifiex_tdls_add_bss_co_2040(skb);\n\t\tmwifiex_tdls_add_supported_chan(skb);\n\t\tmwifiex_tdls_add_oper_class(skb);\n\t\tmwifiex_add_wmm_info_ie(priv, skb, 0);\n\t\tbreak;\n\n\tcase WLAN_TDLS_SETUP_RESPONSE:\n\t\ttf->category = WLAN_CATEGORY_TDLS;\n\t\ttf->action_code = WLAN_TDLS_SETUP_RESPONSE;\n\t\tskb_put(skb, sizeof(tf->u.setup_resp));\n\t\ttf->u.setup_resp.status_code = cpu_to_le16(status_code);\n\t\ttf->u.setup_resp.dialog_token = dialog_token;\n\t\ttf->u.setup_resp.capability = cpu_to_le16(capab);\n\t\tret = mwifiex_tdls_append_rates_ie(priv, skb);\n\t\tif (ret) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);\n\t\t*pos++ = WLAN_EID_HT_CAPABILITY;\n\t\t*pos++ = sizeof(struct ieee80211_ht_cap);\n\t\tht_cap = (void *)pos;\n\t\tradio = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n\t\tret = mwifiex_fill_cap_info(priv, radio, ht_cap);\n\t\tif (ret) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (priv->adapter->is_hw_11ac_capable) {\n\t\t\tret = mwifiex_tdls_add_vht_capab(priv, skb);\n\t\t\tif (ret) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tmwifiex_tdls_add_aid(priv, skb);\n\t\t}\n\n\t\tmwifiex_tdls_add_ext_capab(priv, skb);\n\t\tmwifiex_tdls_add_bss_co_2040(skb);\n\t\tmwifiex_tdls_add_supported_chan(skb);\n\t\tmwifiex_tdls_add_oper_class(skb);\n\t\tmwifiex_add_wmm_info_ie(priv, skb, 0);\n\t\tbreak;\n\n\tcase WLAN_TDLS_SETUP_CONFIRM:\n\t\ttf->category = WLAN_CATEGORY_TDLS;\n\t\ttf->action_code = WLAN_TDLS_SETUP_CONFIRM;\n\t\tskb_put(skb, sizeof(tf->u.setup_cfm));\n\t\ttf->u.setup_cfm.status_code = cpu_to_le16(status_code);\n\t\ttf->u.setup_cfm.dialog_token = dialog_token;\n\n\t\tmwifiex_tdls_add_wmm_param_ie(priv, skb);\n\t\tif (priv->adapter->is_hw_11ac_capable) {\n\t\t\tret = mwifiex_tdls_add_vht_oper(priv, peer, skb);\n\t\t\tif (ret) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret = mwifiex_tdls_add_ht_oper(priv, peer, 1, skb);\n\t\t\tif (ret) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tret = mwifiex_tdls_add_ht_oper(priv, peer, 0, skb);\n\t\t\tif (ret) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase WLAN_TDLS_TEARDOWN:\n\t\ttf->category = WLAN_CATEGORY_TDLS;\n\t\ttf->action_code = WLAN_TDLS_TEARDOWN;\n\t\tskb_put(skb, sizeof(tf->u.teardown));\n\t\ttf->u.teardown.reason_code = cpu_to_le16(status_code);\n\t\tbreak;\n\n\tcase WLAN_TDLS_DISCOVERY_REQUEST:\n\t\ttf->category = WLAN_CATEGORY_TDLS;\n\t\ttf->action_code = WLAN_TDLS_DISCOVERY_REQUEST;\n\t\tskb_put(skb, sizeof(tf->u.discover_req));\n\t\ttf->u.discover_req.dialog_token = dialog_token;\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"Unknown TDLS frame type.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nmwifiex_tdls_add_link_ie(struct sk_buff *skb, const u8 *src_addr,\n\t\t\t const u8 *peer, const u8 *bssid)\n{\n\tstruct ieee80211_tdls_lnkie *lnkid;\n\n\tlnkid = skb_put(skb, sizeof(struct ieee80211_tdls_lnkie));\n\tlnkid->ie_type = WLAN_EID_LINK_ID;\n\tlnkid->ie_len = sizeof(struct ieee80211_tdls_lnkie) -\n\t\t\tsizeof(struct ieee_types_header);\n\n\tmemcpy(lnkid->bssid, bssid, ETH_ALEN);\n\tmemcpy(lnkid->init_sta, src_addr, ETH_ALEN);\n\tmemcpy(lnkid->resp_sta, peer, ETH_ALEN);\n}\n\nint mwifiex_send_tdls_data_frame(struct mwifiex_private *priv, const u8 *peer,\n\t\t\t\t u8 action_code, u8 dialog_token,\n\t\t\t\t u16 status_code, const u8 *extra_ies,\n\t\t\t\t size_t extra_ies_len)\n{\n\tstruct sk_buff *skb;\n\tstruct mwifiex_txinfo *tx_info;\n\tint ret;\n\tu16 skb_len;\n\n\tskb_len = MWIFIEX_MIN_DATA_HEADER_LEN +\n\t\t  max(sizeof(struct ieee80211_mgmt),\n\t\t      sizeof(struct ieee80211_tdls_data)) +\n\t\t  MWIFIEX_MGMT_FRAME_HEADER_SIZE +\n\t\t  MWIFIEX_SUPPORTED_RATES +\n\t\t  3 +  \n\t\t  sizeof(struct ieee_types_extcap) +\n\t\t  sizeof(struct ieee80211_ht_cap) +\n\t\t  sizeof(struct ieee_types_bss_co_2040) +\n\t\t  sizeof(struct ieee80211_ht_operation) +\n\t\t  sizeof(struct ieee80211_tdls_lnkie) +\n\t\t  (2 * (sizeof(struct ieee_types_header))) +\n\t\t   MWIFIEX_SUPPORTED_CHANNELS +\n\t\t   MWIFIEX_OPERATING_CLASSES +\n\t\t  sizeof(struct ieee80211_wmm_param_ie) +\n\t\t  extra_ies_len;\n\n\tif (priv->adapter->is_hw_11ac_capable)\n\t\tskb_len += sizeof(struct ieee_types_vht_cap) +\n\t\t\t   sizeof(struct ieee_types_vht_oper) +\n\t\t\t   sizeof(struct ieee_types_aid);\n\n\tskb = dev_alloc_skb(skb_len);\n\tif (!skb) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"allocate skb failed for management frame\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, MWIFIEX_MIN_DATA_HEADER_LEN);\n\n\tswitch (action_code) {\n\tcase WLAN_TDLS_SETUP_REQUEST:\n\tcase WLAN_TDLS_SETUP_CONFIRM:\n\tcase WLAN_TDLS_TEARDOWN:\n\tcase WLAN_TDLS_DISCOVERY_REQUEST:\n\t\tret = mwifiex_prep_tdls_encap_data(priv, peer, action_code,\n\t\t\t\t\t\t   dialog_token, status_code,\n\t\t\t\t\t\t   skb);\n\t\tif (ret) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn ret;\n\t\t}\n\t\tif (extra_ies_len)\n\t\t\tskb_put_data(skb, extra_ies, extra_ies_len);\n\t\tmwifiex_tdls_add_link_ie(skb, priv->curr_addr, peer,\n\t\t\t\t\t priv->cfg_bssid);\n\t\tbreak;\n\tcase WLAN_TDLS_SETUP_RESPONSE:\n\t\tret = mwifiex_prep_tdls_encap_data(priv, peer, action_code,\n\t\t\t\t\t\t   dialog_token, status_code,\n\t\t\t\t\t\t   skb);\n\t\tif (ret) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn ret;\n\t\t}\n\t\tif (extra_ies_len)\n\t\t\tskb_put_data(skb, extra_ies, extra_ies_len);\n\t\tmwifiex_tdls_add_link_ie(skb, peer, priv->curr_addr,\n\t\t\t\t\t priv->cfg_bssid);\n\t\tbreak;\n\t}\n\n\tswitch (action_code) {\n\tcase WLAN_TDLS_SETUP_REQUEST:\n\tcase WLAN_TDLS_SETUP_RESPONSE:\n\t\tskb->priority = MWIFIEX_PRIO_BK;\n\t\tbreak;\n\tdefault:\n\t\tskb->priority = MWIFIEX_PRIO_VI;\n\t\tbreak;\n\t}\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tmemset(tx_info, 0, sizeof(*tx_info));\n\ttx_info->bss_num = priv->bss_num;\n\ttx_info->bss_type = priv->bss_type;\n\n\t__net_timestamp(skb);\n\tmwifiex_queue_tx_pkt(priv, skb);\n\n\t \n\tif (action_code == WLAN_TDLS_SETUP_CONFIRM ||\n\t    action_code == WLAN_TDLS_TEARDOWN)\n\t\tmsleep_interruptible(10);\n\n\treturn 0;\n}\n\nstatic int\nmwifiex_construct_tdls_action_frame(struct mwifiex_private *priv,\n\t\t\t\t    const u8 *peer,\n\t\t\t\t    u8 action_code, u8 dialog_token,\n\t\t\t\t    u16 status_code, struct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *mgmt;\n\tint ret;\n\tu16 capab;\n\tstruct ieee80211_ht_cap *ht_cap;\n\tunsigned int extra;\n\tu8 radio, *pos;\n\n\tcapab = priv->curr_bss_params.bss_descriptor.cap_info_bitmap;\n\n\tmgmt = skb_put(skb, offsetof(struct ieee80211_mgmt, u));\n\n\tmemset(mgmt, 0, 24);\n\tmemcpy(mgmt->da, peer, ETH_ALEN);\n\tmemcpy(mgmt->sa, priv->curr_addr, ETH_ALEN);\n\tmemcpy(mgmt->bssid, priv->cfg_bssid, ETH_ALEN);\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\n\t \n\tpos = skb_put(skb, ETH_ALEN);\n\n\tswitch (action_code) {\n\tcase WLAN_PUB_ACTION_TDLS_DISCOVER_RES:\n\t\t \n\t\textra = sizeof(mgmt->u.action.u.tdls_discover_resp) +\n\t\t\tsizeof(mgmt->u.action.category);\n\t\tskb_put(skb, extra);\n\t\tmgmt->u.action.category = WLAN_CATEGORY_PUBLIC;\n\t\tmgmt->u.action.u.tdls_discover_resp.action_code =\n\t\t\t\t\t      WLAN_PUB_ACTION_TDLS_DISCOVER_RES;\n\t\tmgmt->u.action.u.tdls_discover_resp.dialog_token =\n\t\t\t\t\t\t\t\t   dialog_token;\n\t\tmgmt->u.action.u.tdls_discover_resp.capability =\n\t\t\t\t\t\t\t     cpu_to_le16(capab);\n\t\t \n\t\tmemmove(pos + ETH_ALEN, &mgmt->u.action, extra);\n\t\t \n\t\teth_broadcast_addr(pos);\n\n\t\tret = mwifiex_tdls_append_rates_ie(priv, skb);\n\t\tif (ret) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);\n\t\t*pos++ = WLAN_EID_HT_CAPABILITY;\n\t\t*pos++ = sizeof(struct ieee80211_ht_cap);\n\t\tht_cap = (void *)pos;\n\t\tradio = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n\t\tret = mwifiex_fill_cap_info(priv, radio, ht_cap);\n\t\tif (ret) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (priv->adapter->is_hw_11ac_capable) {\n\t\t\tret = mwifiex_tdls_add_vht_capab(priv, skb);\n\t\t\tif (ret) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tmwifiex_tdls_add_aid(priv, skb);\n\t\t}\n\n\t\tmwifiex_tdls_add_ext_capab(priv, skb);\n\t\tmwifiex_tdls_add_bss_co_2040(skb);\n\t\tmwifiex_tdls_add_supported_chan(skb);\n\t\tmwifiex_tdls_add_qos_capab(skb);\n\t\tmwifiex_tdls_add_oper_class(skb);\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"Unknown TDLS action frame type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint mwifiex_send_tdls_action_frame(struct mwifiex_private *priv, const u8 *peer,\n\t\t\t\t   u8 action_code, u8 dialog_token,\n\t\t\t\t   u16 status_code, const u8 *extra_ies,\n\t\t\t\t   size_t extra_ies_len)\n{\n\tstruct sk_buff *skb;\n\tstruct mwifiex_txinfo *tx_info;\n\tu8 *pos;\n\tu32 pkt_type, tx_control;\n\tu16 pkt_len, skb_len;\n\n\tskb_len = MWIFIEX_MIN_DATA_HEADER_LEN +\n\t\t  max(sizeof(struct ieee80211_mgmt),\n\t\t      sizeof(struct ieee80211_tdls_data)) +\n\t\t  MWIFIEX_MGMT_FRAME_HEADER_SIZE +\n\t\t  MWIFIEX_SUPPORTED_RATES +\n\t\t  sizeof(struct ieee_types_extcap) +\n\t\t  sizeof(struct ieee80211_ht_cap) +\n\t\t  sizeof(struct ieee_types_bss_co_2040) +\n\t\t  sizeof(struct ieee80211_ht_operation) +\n\t\t  sizeof(struct ieee80211_tdls_lnkie) +\n\t\t  extra_ies_len +\n\t\t  3 +  \n\t\t  ETH_ALEN;  \n\n\tif (priv->adapter->is_hw_11ac_capable)\n\t\tskb_len += sizeof(struct ieee_types_vht_cap) +\n\t\t\t   sizeof(struct ieee_types_vht_oper) +\n\t\t\t   sizeof(struct ieee_types_aid);\n\n\tskb = dev_alloc_skb(skb_len);\n\tif (!skb) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"allocate skb failed for management frame\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_reserve(skb, MWIFIEX_MIN_DATA_HEADER_LEN);\n\n\tpkt_type = PKT_TYPE_MGMT;\n\ttx_control = 0;\n\tpos = skb_put_zero(skb,\n\t\t\t   MWIFIEX_MGMT_FRAME_HEADER_SIZE + sizeof(pkt_len));\n\tmemcpy(pos, &pkt_type, sizeof(pkt_type));\n\tmemcpy(pos + sizeof(pkt_type), &tx_control, sizeof(tx_control));\n\n\tif (mwifiex_construct_tdls_action_frame(priv, peer, action_code,\n\t\t\t\t\t\tdialog_token, status_code,\n\t\t\t\t\t\tskb)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (extra_ies_len)\n\t\tskb_put_data(skb, extra_ies, extra_ies_len);\n\n\t \n\n\tmwifiex_tdls_add_link_ie(skb, peer, priv->curr_addr,\n\t\t\t\t priv->cfg_bssid);\n\n\tskb->priority = MWIFIEX_PRIO_VI;\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tmemset(tx_info, 0, sizeof(*tx_info));\n\ttx_info->bss_num = priv->bss_num;\n\ttx_info->bss_type = priv->bss_type;\n\ttx_info->flags |= MWIFIEX_BUF_FLAG_TDLS_PKT;\n\n\tpkt_len = skb->len - MWIFIEX_MGMT_FRAME_HEADER_SIZE - sizeof(pkt_len);\n\tmemcpy(skb->data + MWIFIEX_MGMT_FRAME_HEADER_SIZE, &pkt_len,\n\t       sizeof(pkt_len));\n\t__net_timestamp(skb);\n\tmwifiex_queue_tx_pkt(priv, skb);\n\n\treturn 0;\n}\n\n \nvoid mwifiex_process_tdls_action_frame(struct mwifiex_private *priv,\n\t\t\t\t       u8 *buf, int len)\n{\n\tstruct mwifiex_sta_node *sta_ptr;\n\tu8 *peer, *pos, *end;\n\tu8 i, action, basic;\n\tu16 cap = 0;\n\tint ies_len = 0;\n\n\tif (len < (sizeof(struct ethhdr) + 3))\n\t\treturn;\n\tif (*(buf + sizeof(struct ethhdr)) != WLAN_TDLS_SNAP_RFTYPE)\n\t\treturn;\n\tif (*(buf + sizeof(struct ethhdr) + 1) != WLAN_CATEGORY_TDLS)\n\t\treturn;\n\n\tpeer = buf + ETH_ALEN;\n\taction = *(buf + sizeof(struct ethhdr) + 2);\n\tmwifiex_dbg(priv->adapter, DATA,\n\t\t    \"rx:tdls action: peer=%pM, action=%d\\n\", peer, action);\n\n\tswitch (action) {\n\tcase WLAN_TDLS_SETUP_REQUEST:\n\t\tif (len < (sizeof(struct ethhdr) + TDLS_REQ_FIX_LEN))\n\t\t\treturn;\n\n\t\tpos = buf + sizeof(struct ethhdr) + 4;\n\t\t \n\t\tcap = get_unaligned_le16(pos);\n\t\ties_len = len - sizeof(struct ethhdr) - TDLS_REQ_FIX_LEN;\n\t\tpos += 2;\n\t\tbreak;\n\n\tcase WLAN_TDLS_SETUP_RESPONSE:\n\t\tif (len < (sizeof(struct ethhdr) + TDLS_RESP_FIX_LEN))\n\t\t\treturn;\n\t\t \n\t\tpos = buf + sizeof(struct ethhdr) + 6;\n\t\tcap = get_unaligned_le16(pos);\n\t\ties_len = len - sizeof(struct ethhdr) - TDLS_RESP_FIX_LEN;\n\t\tpos += 2;\n\t\tbreak;\n\n\tcase WLAN_TDLS_SETUP_CONFIRM:\n\t\tif (len < (sizeof(struct ethhdr) + TDLS_CONFIRM_FIX_LEN))\n\t\t\treturn;\n\t\tpos = buf + sizeof(struct ethhdr) + TDLS_CONFIRM_FIX_LEN;\n\t\ties_len = len - sizeof(struct ethhdr) - TDLS_CONFIRM_FIX_LEN;\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"Unknown TDLS frame type.\\n\");\n\t\treturn;\n\t}\n\n\tsta_ptr = mwifiex_add_sta_entry(priv, peer);\n\tif (!sta_ptr)\n\t\treturn;\n\n\tsta_ptr->tdls_cap.capab = cpu_to_le16(cap);\n\n\tfor (end = pos + ies_len; pos + 1 < end; pos += 2 + pos[1]) {\n\t\tu8 ie_len = pos[1];\n\n\t\tif (pos + 2 + ie_len > end)\n\t\t\tbreak;\n\n\t\tswitch (*pos) {\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\t\tif (ie_len > sizeof(sta_ptr->tdls_cap.rates))\n\t\t\t\treturn;\n\t\t\tsta_ptr->tdls_cap.rates_len = ie_len;\n\t\t\tfor (i = 0; i < ie_len; i++)\n\t\t\t\tsta_ptr->tdls_cap.rates[i] = pos[i + 2];\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\t\tif (ie_len > sizeof(sta_ptr->tdls_cap.rates))\n\t\t\t\treturn;\n\t\t\tbasic = sta_ptr->tdls_cap.rates_len;\n\t\t\tif (ie_len > sizeof(sta_ptr->tdls_cap.rates) - basic)\n\t\t\t\treturn;\n\t\t\tfor (i = 0; i < ie_len; i++)\n\t\t\t\tsta_ptr->tdls_cap.rates[basic + i] = pos[i + 2];\n\t\t\tsta_ptr->tdls_cap.rates_len += ie_len;\n\t\t\tbreak;\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\t\tif (ie_len != sizeof(struct ieee80211_ht_cap))\n\t\t\t\treturn;\n\t\t\t \n\t\t\tmemcpy((u8 *)&sta_ptr->tdls_cap.ht_capb, pos + 2,\n\t\t\t       sizeof(struct ieee80211_ht_cap));\n\t\t\tsta_ptr->is_11n_enabled = 1;\n\t\t\tbreak;\n\t\tcase WLAN_EID_HT_OPERATION:\n\t\t\tif (ie_len != sizeof(struct ieee80211_ht_operation))\n\t\t\t\treturn;\n\t\t\t \n\t\t\tmemcpy(&sta_ptr->tdls_cap.ht_oper, pos + 2,\n\t\t\t       sizeof(struct ieee80211_ht_operation));\n\t\t\tbreak;\n\t\tcase WLAN_EID_BSS_COEX_2040:\n\t\t\tif (ie_len != sizeof(pos[2]))\n\t\t\t\treturn;\n\t\t\tsta_ptr->tdls_cap.coex_2040 = pos[2];\n\t\t\tbreak;\n\t\tcase WLAN_EID_EXT_CAPABILITY:\n\t\t\tif (ie_len < sizeof(struct ieee_types_header))\n\t\t\t\treturn;\n\t\t\tif (ie_len > 8)\n\t\t\t\treturn;\n\t\t\tmemcpy((u8 *)&sta_ptr->tdls_cap.extcap, pos,\n\t\t\t       sizeof(struct ieee_types_header) +\n\t\t\t       min_t(u8, ie_len, 8));\n\t\t\tbreak;\n\t\tcase WLAN_EID_RSN:\n\t\t\tif (ie_len < sizeof(struct ieee_types_header))\n\t\t\t\treturn;\n\t\t\tif (ie_len > IEEE_MAX_IE_SIZE -\n\t\t\t    sizeof(struct ieee_types_header))\n\t\t\t\treturn;\n\t\t\tmemcpy((u8 *)&sta_ptr->tdls_cap.rsn_ie, pos,\n\t\t\t       sizeof(struct ieee_types_header) +\n\t\t\t       min_t(u8, ie_len, IEEE_MAX_IE_SIZE -\n\t\t\t\t     sizeof(struct ieee_types_header)));\n\t\t\tbreak;\n\t\tcase WLAN_EID_QOS_CAPA:\n\t\t\tif (ie_len != sizeof(pos[2]))\n\t\t\t\treturn;\n\t\t\tsta_ptr->tdls_cap.qos_info = pos[2];\n\t\t\tbreak;\n\t\tcase WLAN_EID_VHT_OPERATION:\n\t\t\tif (priv->adapter->is_hw_11ac_capable) {\n\t\t\t\tif (ie_len !=\n\t\t\t\t    sizeof(struct ieee80211_vht_operation))\n\t\t\t\t\treturn;\n\t\t\t\t \n\t\t\t\tmemcpy(&sta_ptr->tdls_cap.vhtoper, pos + 2,\n\t\t\t\t       sizeof(struct ieee80211_vht_operation));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\t\tif (priv->adapter->is_hw_11ac_capable) {\n\t\t\t\tif (ie_len != sizeof(struct ieee80211_vht_cap))\n\t\t\t\t\treturn;\n\t\t\t\t \n\t\t\t\tmemcpy((u8 *)&sta_ptr->tdls_cap.vhtcap, pos + 2,\n\t\t\t\t       sizeof(struct ieee80211_vht_cap));\n\t\t\t\tsta_ptr->is_11ac_enabled = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_EID_AID:\n\t\t\tif (priv->adapter->is_hw_11ac_capable) {\n\t\t\t\tif (ie_len != sizeof(u16))\n\t\t\t\t\treturn;\n\t\t\t\tsta_ptr->tdls_cap.aid =\n\t\t\t\t\tget_unaligned_le16((pos + 2));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn;\n}\n\nstatic int\nmwifiex_tdls_process_config_link(struct mwifiex_private *priv, const u8 *peer)\n{\n\tstruct mwifiex_sta_node *sta_ptr;\n\tstruct mwifiex_ds_tdls_oper tdls_oper;\n\n\tmemset(&tdls_oper, 0, sizeof(struct mwifiex_ds_tdls_oper));\n\tsta_ptr = mwifiex_get_sta_entry(priv, peer);\n\n\tif (!sta_ptr || sta_ptr->tdls_status == TDLS_SETUP_FAILURE) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"link absent for peer %pM; cannot config\\n\", peer);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&tdls_oper.peer_mac, peer, ETH_ALEN);\n\ttdls_oper.tdls_action = MWIFIEX_TDLS_CONFIG_LINK;\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_OPER,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &tdls_oper, true);\n}\n\nstatic int\nmwifiex_tdls_process_create_link(struct mwifiex_private *priv, const u8 *peer)\n{\n\tstruct mwifiex_sta_node *sta_ptr;\n\tstruct mwifiex_ds_tdls_oper tdls_oper;\n\n\tmemset(&tdls_oper, 0, sizeof(struct mwifiex_ds_tdls_oper));\n\tsta_ptr = mwifiex_get_sta_entry(priv, peer);\n\n\tif (sta_ptr && sta_ptr->tdls_status == TDLS_SETUP_INPROGRESS) {\n\t\tmwifiex_dbg(priv->adapter, WARN,\n\t\t\t    \"Setup already in progress for peer %pM\\n\", peer);\n\t\treturn 0;\n\t}\n\n\tsta_ptr = mwifiex_add_sta_entry(priv, peer);\n\tif (!sta_ptr)\n\t\treturn -ENOMEM;\n\n\tsta_ptr->tdls_status = TDLS_SETUP_INPROGRESS;\n\tmwifiex_hold_tdls_packets(priv, peer);\n\tmemcpy(&tdls_oper.peer_mac, peer, ETH_ALEN);\n\ttdls_oper.tdls_action = MWIFIEX_TDLS_CREATE_LINK;\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_OPER,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &tdls_oper, true);\n}\n\nstatic int\nmwifiex_tdls_process_disable_link(struct mwifiex_private *priv, const u8 *peer)\n{\n\tstruct mwifiex_sta_node *sta_ptr;\n\tstruct mwifiex_ds_tdls_oper tdls_oper;\n\n\tmemset(&tdls_oper, 0, sizeof(struct mwifiex_ds_tdls_oper));\n\tsta_ptr = mwifiex_get_sta_entry(priv, peer);\n\n\tif (sta_ptr) {\n\t\tif (sta_ptr->is_11n_enabled) {\n\t\t\tmwifiex_11n_cleanup_reorder_tbl(priv);\n\t\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\tmwifiex_11n_delete_all_tx_ba_stream_tbl(priv);\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t}\n\t\tmwifiex_del_sta_entry(priv, peer);\n\t}\n\n\tmwifiex_restore_tdls_packets(priv, peer, TDLS_LINK_TEARDOWN);\n\tmwifiex_auto_tdls_update_peer_status(priv, peer, TDLS_NOT_SETUP);\n\tmemcpy(&tdls_oper.peer_mac, peer, ETH_ALEN);\n\ttdls_oper.tdls_action = MWIFIEX_TDLS_DISABLE_LINK;\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_OPER,\n\t\t\t\tHostCmd_ACT_GEN_SET, 0, &tdls_oper, true);\n}\n\nstatic int\nmwifiex_tdls_process_enable_link(struct mwifiex_private *priv, const u8 *peer)\n{\n\tstruct mwifiex_sta_node *sta_ptr;\n\tstruct ieee80211_mcs_info mcs;\n\tint i;\n\n\tsta_ptr = mwifiex_get_sta_entry(priv, peer);\n\n\tif (sta_ptr && (sta_ptr->tdls_status != TDLS_SETUP_FAILURE)) {\n\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t    \"tdls: enable link %pM success\\n\", peer);\n\n\t\tsta_ptr->tdls_status = TDLS_SETUP_COMPLETE;\n\n\t\tmcs = sta_ptr->tdls_cap.ht_capb.mcs;\n\t\tif (mcs.rx_mask[0] != 0xff)\n\t\t\tsta_ptr->is_11n_enabled = true;\n\t\tif (sta_ptr->is_11n_enabled) {\n\t\t\tif (le16_to_cpu(sta_ptr->tdls_cap.ht_capb.cap_info) &\n\t\t\t    IEEE80211_HT_CAP_MAX_AMSDU)\n\t\t\t\tsta_ptr->max_amsdu =\n\t\t\t\t\tMWIFIEX_TX_DATA_BUF_SIZE_8K;\n\t\t\telse\n\t\t\t\tsta_ptr->max_amsdu =\n\t\t\t\t\tMWIFIEX_TX_DATA_BUF_SIZE_4K;\n\n\t\t\tfor (i = 0; i < MAX_NUM_TID; i++)\n\t\t\t\tsta_ptr->ampdu_sta[i] =\n\t\t\t\t\t      priv->aggr_prio_tbl[i].ampdu_user;\n\t\t} else {\n\t\t\tfor (i = 0; i < MAX_NUM_TID; i++)\n\t\t\t\tsta_ptr->ampdu_sta[i] = BA_STREAM_NOT_ALLOWED;\n\t\t}\n\t\tif (sta_ptr->tdls_cap.extcap.ext_capab[3] &\n\t\t    WLAN_EXT_CAPA4_TDLS_CHAN_SWITCH) {\n\t\t\tmwifiex_config_tdls_enable(priv);\n\t\t\tmwifiex_config_tdls_cs_params(priv);\n\t\t}\n\n\t\tmemset(sta_ptr->rx_seq, 0xff, sizeof(sta_ptr->rx_seq));\n\t\tmwifiex_restore_tdls_packets(priv, peer, TDLS_SETUP_COMPLETE);\n\t\tmwifiex_auto_tdls_update_peer_status(priv, peer,\n\t\t\t\t\t\t     TDLS_SETUP_COMPLETE);\n\t} else {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"tdls: enable link %pM failed\\n\", peer);\n\t\tif (sta_ptr) {\n\t\t\tmwifiex_11n_cleanup_reorder_tbl(priv);\n\t\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\tmwifiex_11n_delete_all_tx_ba_stream_tbl(priv);\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\tmwifiex_del_sta_entry(priv, peer);\n\t\t}\n\t\tmwifiex_restore_tdls_packets(priv, peer, TDLS_LINK_TEARDOWN);\n\t\tmwifiex_auto_tdls_update_peer_status(priv, peer,\n\t\t\t\t\t\t     TDLS_NOT_SETUP);\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint mwifiex_tdls_oper(struct mwifiex_private *priv, const u8 *peer, u8 action)\n{\n\tswitch (action) {\n\tcase MWIFIEX_TDLS_ENABLE_LINK:\n\t\treturn mwifiex_tdls_process_enable_link(priv, peer);\n\tcase MWIFIEX_TDLS_DISABLE_LINK:\n\t\treturn mwifiex_tdls_process_disable_link(priv, peer);\n\tcase MWIFIEX_TDLS_CREATE_LINK:\n\t\treturn mwifiex_tdls_process_create_link(priv, peer);\n\tcase MWIFIEX_TDLS_CONFIG_LINK:\n\t\treturn mwifiex_tdls_process_config_link(priv, peer);\n\t}\n\treturn 0;\n}\n\nint mwifiex_get_tdls_link_status(struct mwifiex_private *priv, const u8 *mac)\n{\n\tstruct mwifiex_sta_node *sta_ptr;\n\n\tsta_ptr = mwifiex_get_sta_entry(priv, mac);\n\tif (sta_ptr)\n\t\treturn sta_ptr->tdls_status;\n\n\treturn TDLS_NOT_SETUP;\n}\n\nint mwifiex_get_tdls_list(struct mwifiex_private *priv,\n\t\t\t  struct tdls_peer_info *buf)\n{\n\tstruct mwifiex_sta_node *sta_ptr;\n\tstruct tdls_peer_info *peer = buf;\n\tint count = 0;\n\n\tif (!ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info))\n\t\treturn 0;\n\n\t \n\tif (!(priv->bss_type == MWIFIEX_BSS_TYPE_STA && priv->media_connected))\n\t\treturn 0;\n\n\tspin_lock_bh(&priv->sta_list_spinlock);\n\tlist_for_each_entry(sta_ptr, &priv->sta_list, list) {\n\t\tif (mwifiex_is_tdls_link_setup(sta_ptr->tdls_status)) {\n\t\t\tether_addr_copy(peer->peer_addr, sta_ptr->mac_addr);\n\t\t\tpeer++;\n\t\t\tcount++;\n\t\t\tif (count >= MWIFIEX_MAX_TDLS_PEER_SUPPORTED)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&priv->sta_list_spinlock);\n\n\treturn count;\n}\n\nvoid mwifiex_disable_all_tdls_links(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_sta_node *sta_ptr;\n\tstruct mwifiex_ds_tdls_oper tdls_oper;\n\n\tif (list_empty(&priv->sta_list))\n\t\treturn;\n\n\tlist_for_each_entry(sta_ptr, &priv->sta_list, list) {\n\t\tmemset(&tdls_oper, 0, sizeof(struct mwifiex_ds_tdls_oper));\n\n\t\tif (sta_ptr->is_11n_enabled) {\n\t\t\tmwifiex_11n_cleanup_reorder_tbl(priv);\n\t\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\tmwifiex_11n_delete_all_tx_ba_stream_tbl(priv);\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t}\n\n\t\tmwifiex_restore_tdls_packets(priv, sta_ptr->mac_addr,\n\t\t\t\t\t     TDLS_LINK_TEARDOWN);\n\t\tmemcpy(&tdls_oper.peer_mac, sta_ptr->mac_addr, ETH_ALEN);\n\t\ttdls_oper.tdls_action = MWIFIEX_TDLS_DISABLE_LINK;\n\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_OPER,\n\t\t\t\t     HostCmd_ACT_GEN_SET, 0, &tdls_oper, false))\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"Disable link failed for TDLS peer %pM\",\n\t\t\t\t    sta_ptr->mac_addr);\n\t}\n\n\tmwifiex_del_all_sta_list(priv);\n}\n\nint mwifiex_tdls_check_tx(struct mwifiex_private *priv, struct sk_buff *skb)\n{\n\tstruct mwifiex_auto_tdls_peer *peer;\n\tu8 mac[ETH_ALEN];\n\n\tether_addr_copy(mac, skb->data);\n\n\tspin_lock_bh(&priv->auto_tdls_lock);\n\tlist_for_each_entry(peer, &priv->auto_tdls_list, list) {\n\t\tif (!memcmp(mac, peer->mac_addr, ETH_ALEN)) {\n\t\t\tif (peer->rssi <= MWIFIEX_TDLS_RSSI_HIGH &&\n\t\t\t    peer->tdls_status == TDLS_NOT_SETUP &&\n\t\t\t    (peer->failure_count <\n\t\t\t     MWIFIEX_TDLS_MAX_FAIL_COUNT)) {\n\t\t\t\tpeer->tdls_status = TDLS_SETUP_INPROGRESS;\n\t\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t\t    \"setup TDLS link, peer=%pM rssi=%d\\n\",\n\t\t\t\t\t    peer->mac_addr, peer->rssi);\n\n\t\t\t\tcfg80211_tdls_oper_request(priv->netdev,\n\t\t\t\t\t\t\t   peer->mac_addr,\n\t\t\t\t\t\t\t   NL80211_TDLS_SETUP,\n\t\t\t\t\t\t\t   0, GFP_ATOMIC);\n\t\t\t\tpeer->do_setup = false;\n\t\t\t\tpriv->check_tdls_tx = false;\n\t\t\t} else if (peer->failure_count <\n\t\t\t\t   MWIFIEX_TDLS_MAX_FAIL_COUNT &&\n\t\t\t\t   peer->do_discover) {\n\t\t\t\tmwifiex_send_tdls_data_frame(priv,\n\t\t\t\t\t\t\t     peer->mac_addr,\n\t\t\t\t\t\t    WLAN_TDLS_DISCOVERY_REQUEST,\n\t\t\t\t\t\t\t     1, 0, NULL, 0);\n\t\t\t\tpeer->do_discover = false;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&priv->auto_tdls_lock);\n\n\treturn 0;\n}\n\nvoid mwifiex_flush_auto_tdls_list(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_auto_tdls_peer *peer, *tmp_node;\n\n\tspin_lock_bh(&priv->auto_tdls_lock);\n\tlist_for_each_entry_safe(peer, tmp_node, &priv->auto_tdls_list, list) {\n\t\tlist_del(&peer->list);\n\t\tkfree(peer);\n\t}\n\n\tINIT_LIST_HEAD(&priv->auto_tdls_list);\n\tspin_unlock_bh(&priv->auto_tdls_lock);\n\tpriv->check_tdls_tx = false;\n}\n\nvoid mwifiex_add_auto_tdls_peer(struct mwifiex_private *priv, const u8 *mac)\n{\n\tstruct mwifiex_auto_tdls_peer *tdls_peer;\n\n\tif (!priv->adapter->auto_tdls)\n\t\treturn;\n\n\tspin_lock_bh(&priv->auto_tdls_lock);\n\tlist_for_each_entry(tdls_peer, &priv->auto_tdls_list, list) {\n\t\tif (!memcmp(tdls_peer->mac_addr, mac, ETH_ALEN)) {\n\t\t\ttdls_peer->tdls_status = TDLS_SETUP_INPROGRESS;\n\t\t\ttdls_peer->rssi_jiffies = jiffies;\n\t\t\tspin_unlock_bh(&priv->auto_tdls_lock);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\ttdls_peer = kzalloc(sizeof(*tdls_peer), GFP_ATOMIC);\n\tif (tdls_peer) {\n\t\tether_addr_copy(tdls_peer->mac_addr, mac);\n\t\ttdls_peer->tdls_status = TDLS_SETUP_INPROGRESS;\n\t\ttdls_peer->rssi_jiffies = jiffies;\n\t\tINIT_LIST_HEAD(&tdls_peer->list);\n\t\tlist_add_tail(&tdls_peer->list, &priv->auto_tdls_list);\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"Add auto TDLS peer= %pM to list\\n\", mac);\n\t}\n\n\tspin_unlock_bh(&priv->auto_tdls_lock);\n}\n\nvoid mwifiex_auto_tdls_update_peer_status(struct mwifiex_private *priv,\n\t\t\t\t\t  const u8 *mac, u8 link_status)\n{\n\tstruct mwifiex_auto_tdls_peer *peer;\n\n\tif (!priv->adapter->auto_tdls)\n\t\treturn;\n\n\tspin_lock_bh(&priv->auto_tdls_lock);\n\tlist_for_each_entry(peer, &priv->auto_tdls_list, list) {\n\t\tif (!memcmp(peer->mac_addr, mac, ETH_ALEN)) {\n\t\t\tif ((link_status == TDLS_NOT_SETUP) &&\n\t\t\t    (peer->tdls_status == TDLS_SETUP_INPROGRESS))\n\t\t\t\tpeer->failure_count++;\n\t\t\telse if (mwifiex_is_tdls_link_setup(link_status))\n\t\t\t\tpeer->failure_count = 0;\n\n\t\t\tpeer->tdls_status = link_status;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&priv->auto_tdls_lock);\n}\n\nvoid mwifiex_auto_tdls_update_peer_signal(struct mwifiex_private *priv,\n\t\t\t\t\t  u8 *mac, s8 snr, s8 nflr)\n{\n\tstruct mwifiex_auto_tdls_peer *peer;\n\n\tif (!priv->adapter->auto_tdls)\n\t\treturn;\n\n\tspin_lock_bh(&priv->auto_tdls_lock);\n\tlist_for_each_entry(peer, &priv->auto_tdls_list, list) {\n\t\tif (!memcmp(peer->mac_addr, mac, ETH_ALEN)) {\n\t\t\tpeer->rssi = nflr - snr;\n\t\t\tpeer->rssi_jiffies = jiffies;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&priv->auto_tdls_lock);\n}\n\nvoid mwifiex_check_auto_tdls(struct timer_list *t)\n{\n\tstruct mwifiex_private *priv = from_timer(priv, t, auto_tdls_timer);\n\tstruct mwifiex_auto_tdls_peer *tdls_peer;\n\tu16 reason = WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED;\n\n\tif (WARN_ON_ONCE(!priv || !priv->adapter)) {\n\t\tpr_err(\"mwifiex: %s: adapter or private structure is NULL\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\tif (unlikely(!priv->adapter->auto_tdls))\n\t\treturn;\n\n\tif (!priv->auto_tdls_timer_active) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"auto TDLS timer inactive; return\");\n\t\treturn;\n\t}\n\n\tpriv->check_tdls_tx = false;\n\n\tspin_lock_bh(&priv->auto_tdls_lock);\n\tlist_for_each_entry(tdls_peer, &priv->auto_tdls_list, list) {\n\t\tif ((jiffies - tdls_peer->rssi_jiffies) >\n\t\t    (MWIFIEX_AUTO_TDLS_IDLE_TIME * HZ)) {\n\t\t\ttdls_peer->rssi = 0;\n\t\t\ttdls_peer->do_discover = true;\n\t\t\tpriv->check_tdls_tx = true;\n\t\t}\n\n\t\tif (((tdls_peer->rssi >= MWIFIEX_TDLS_RSSI_LOW) ||\n\t\t     !tdls_peer->rssi) &&\n\t\t    mwifiex_is_tdls_link_setup(tdls_peer->tdls_status)) {\n\t\t\ttdls_peer->tdls_status = TDLS_LINK_TEARDOWN;\n\t\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t\t    \"teardown TDLS link,peer=%pM rssi=%d\\n\",\n\t\t\t\t    tdls_peer->mac_addr, -tdls_peer->rssi);\n\t\t\ttdls_peer->do_discover = true;\n\t\t\tpriv->check_tdls_tx = true;\n\t\t\tcfg80211_tdls_oper_request(priv->netdev,\n\t\t\t\t\t\t   tdls_peer->mac_addr,\n\t\t\t\t\t\t   NL80211_TDLS_TEARDOWN,\n\t\t\t\t\t\t   reason, GFP_ATOMIC);\n\t\t} else if (tdls_peer->rssi &&\n\t\t\t   tdls_peer->rssi <= MWIFIEX_TDLS_RSSI_HIGH &&\n\t\t\t   tdls_peer->tdls_status == TDLS_NOT_SETUP &&\n\t\t\t   tdls_peer->failure_count <\n\t\t\t   MWIFIEX_TDLS_MAX_FAIL_COUNT) {\n\t\t\t\tpriv->check_tdls_tx = true;\n\t\t\t\ttdls_peer->do_setup = true;\n\t\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t\t    \"check TDLS with peer=%pM\\t\"\n\t\t\t\t\t    \"rssi=%d\\n\", tdls_peer->mac_addr,\n\t\t\t\t\t    tdls_peer->rssi);\n\t\t}\n\t}\n\tspin_unlock_bh(&priv->auto_tdls_lock);\n\n\tmod_timer(&priv->auto_tdls_timer,\n\t\t  jiffies + msecs_to_jiffies(MWIFIEX_TIMER_10S));\n}\n\nvoid mwifiex_setup_auto_tdls_timer(struct mwifiex_private *priv)\n{\n\ttimer_setup(&priv->auto_tdls_timer, mwifiex_check_auto_tdls, 0);\n\tpriv->auto_tdls_timer_active = true;\n\tmod_timer(&priv->auto_tdls_timer,\n\t\t  jiffies + msecs_to_jiffies(MWIFIEX_TIMER_10S));\n}\n\nvoid mwifiex_clean_auto_tdls(struct mwifiex_private *priv)\n{\n\tif (ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\n\t    priv->adapter->auto_tdls &&\n\t    priv->bss_type == MWIFIEX_BSS_TYPE_STA) {\n\t\tpriv->auto_tdls_timer_active = false;\n\t\tdel_timer(&priv->auto_tdls_timer);\n\t\tmwifiex_flush_auto_tdls_list(priv);\n\t}\n}\n\nstatic int mwifiex_config_tdls(struct mwifiex_private *priv, u8 enable)\n{\n\tstruct mwifiex_tdls_config config;\n\n\tconfig.enable = cpu_to_le16(enable);\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_CONFIG,\n\t\t\t\tACT_TDLS_CS_ENABLE_CONFIG, 0, &config, true);\n}\n\nint mwifiex_config_tdls_enable(struct mwifiex_private *priv)\n{\n\treturn mwifiex_config_tdls(priv, true);\n}\n\nint mwifiex_config_tdls_disable(struct mwifiex_private *priv)\n{\n\treturn mwifiex_config_tdls(priv, false);\n}\n\nint mwifiex_config_tdls_cs_params(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_tdls_config_cs_params config_tdls_cs_params;\n\n\tconfig_tdls_cs_params.unit_time = MWIFIEX_DEF_CS_UNIT_TIME;\n\tconfig_tdls_cs_params.thr_otherlink = MWIFIEX_DEF_CS_THR_OTHERLINK;\n\tconfig_tdls_cs_params.thr_directlink = MWIFIEX_DEF_THR_DIRECTLINK;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_CONFIG,\n\t\t\t\tACT_TDLS_CS_PARAMS, 0,\n\t\t\t\t&config_tdls_cs_params, true);\n}\n\nint mwifiex_stop_tdls_cs(struct mwifiex_private *priv, const u8 *peer_mac)\n{\n\tstruct mwifiex_tdls_stop_cs_params stop_tdls_cs_params;\n\n\tether_addr_copy(stop_tdls_cs_params.peer_mac, peer_mac);\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_CONFIG,\n\t\t\t\tACT_TDLS_CS_STOP, 0,\n\t\t\t\t&stop_tdls_cs_params, true);\n}\n\nint mwifiex_start_tdls_cs(struct mwifiex_private *priv, const u8 *peer_mac,\n\t\t\t  u8 primary_chan, u8 second_chan_offset, u8 band)\n{\n\tstruct mwifiex_tdls_init_cs_params start_tdls_cs_params;\n\n\tether_addr_copy(start_tdls_cs_params.peer_mac, peer_mac);\n\tstart_tdls_cs_params.primary_chan = primary_chan;\n\tstart_tdls_cs_params.second_chan_offset = second_chan_offset;\n\tstart_tdls_cs_params.band = band;\n\n\tstart_tdls_cs_params.switch_time = cpu_to_le16(MWIFIEX_DEF_CS_TIME);\n\tstart_tdls_cs_params.switch_timeout =\n\t\t\t\t\tcpu_to_le16(MWIFIEX_DEF_CS_TIMEOUT);\n\tstart_tdls_cs_params.reg_class = MWIFIEX_DEF_CS_REG_CLASS;\n\tstart_tdls_cs_params.periodicity = MWIFIEX_DEF_CS_PERIODICITY;\n\n\treturn mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_CONFIG,\n\t\t\t\tACT_TDLS_CS_INIT, 0,\n\t\t\t\t&start_tdls_cs_params, true);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}