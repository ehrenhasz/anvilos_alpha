{
  "module_name": "uap_txrx.c",
  "hash_id": "fcb1470ff5592f5f60462486234ce63f8bc5695f021ec0c3e8beb8b2881fd95c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/uap_txrx.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n_aggr.h\"\n#include \"11n_rxreorder.h\"\n\n \nstatic bool\nmwifiex_uap_del_tx_pkts_in_ralist(struct mwifiex_private *priv,\n\t\t\t\t  struct list_head *ra_list_head,\n\t\t\t\t  int tid)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tstruct sk_buff *skb, *tmp;\n\tbool pkt_deleted = false;\n\tstruct mwifiex_txinfo *tx_info;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tlist_for_each_entry(ra_list, ra_list_head, list) {\n\t\tif (skb_queue_empty(&ra_list->skb_head))\n\t\t\tcontinue;\n\n\t\tskb_queue_walk_safe(&ra_list->skb_head, skb, tmp) {\n\t\t\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\t\t\tif (tx_info->flags & MWIFIEX_BUF_FLAG_BRIDGED_PKT) {\n\t\t\t\t__skb_unlink(skb, &ra_list->skb_head);\n\t\t\t\tmwifiex_write_data_complete(adapter, skb, 0,\n\t\t\t\t\t\t\t    -1);\n\t\t\t\tif (ra_list->tx_paused)\n\t\t\t\t\tpriv->wmm.pkts_paused[tid]--;\n\t\t\t\telse\n\t\t\t\t\tatomic_dec(&priv->wmm.tx_pkts_queued);\n\t\t\t\tpkt_deleted = true;\n\t\t\t}\n\t\t\tif ((atomic_read(&adapter->pending_bridged_pkts) <=\n\t\t\t\t\t     MWIFIEX_BRIDGED_PKTS_THR_LOW))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pkt_deleted;\n}\n\n \nstatic void mwifiex_uap_cleanup_tx_queues(struct mwifiex_private *priv)\n{\n\tstruct list_head *ra_list;\n\tint i;\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tfor (i = 0; i < MAX_NUM_TID; i++, priv->del_list_idx++) {\n\t\tif (priv->del_list_idx == MAX_NUM_TID)\n\t\t\tpriv->del_list_idx = 0;\n\t\tra_list = &priv->wmm.tid_tbl_ptr[priv->del_list_idx].ra_list;\n\t\tif (mwifiex_uap_del_tx_pkts_in_ralist(priv, ra_list, i)) {\n\t\t\tpriv->del_list_idx++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n\nstatic void mwifiex_uap_queue_bridged_pkt(struct mwifiex_private *priv,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct uap_rxpd *uap_rx_pd;\n\tstruct rx_packet_hdr *rx_pkt_hdr;\n\tstruct sk_buff *new_skb;\n\tstruct mwifiex_txinfo *tx_info;\n\tint hdr_chop;\n\tstruct ethhdr *p_ethhdr;\n\tstruct mwifiex_sta_node *src_node;\n\tint index;\n\n\tuap_rx_pd = (struct uap_rxpd *)(skb->data);\n\trx_pkt_hdr = (void *)uap_rx_pd + le16_to_cpu(uap_rx_pd->rx_pkt_offset);\n\n\tif ((atomic_read(&adapter->pending_bridged_pkts) >=\n\t\t\t\t\t     MWIFIEX_BRIDGED_PKTS_THR_HIGH)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Tx: Bridge packet limit reached. Drop packet!\\n\");\n\t\tkfree_skb(skb);\n\t\tmwifiex_uap_cleanup_tx_queues(priv);\n\t\treturn;\n\t}\n\n\tif (sizeof(*rx_pkt_hdr) +\n\t    le16_to_cpu(uap_rx_pd->rx_pkt_offset) > skb->len) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"wrong rx packet offset: len=%d,rx_pkt_offset=%d\\n\",\n\t\t\t    skb->len, le16_to_cpu(uap_rx_pd->rx_pkt_offset));\n\t\tpriv->stats.rx_dropped++;\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\tif ((!memcmp(&rx_pkt_hdr->rfc1042_hdr, bridge_tunnel_header,\n\t\t     sizeof(bridge_tunnel_header))) ||\n\t    (!memcmp(&rx_pkt_hdr->rfc1042_hdr, rfc1042_header,\n\t\t     sizeof(rfc1042_header)) &&\n\t     ntohs(rx_pkt_hdr->rfc1042_hdr.snap_type) != ETH_P_AARP &&\n\t     ntohs(rx_pkt_hdr->rfc1042_hdr.snap_type) != ETH_P_IPX)) {\n\t\t \n\t\tp_ethhdr = (struct ethhdr *)\n\t\t\t((u8 *)(&rx_pkt_hdr->eth803_hdr)\n\t\t\t + sizeof(rx_pkt_hdr->eth803_hdr)\n\t\t\t + sizeof(rx_pkt_hdr->rfc1042_hdr)\n\t\t\t - sizeof(rx_pkt_hdr->eth803_hdr.h_dest)\n\t\t\t - sizeof(rx_pkt_hdr->eth803_hdr.h_source)\n\t\t\t - sizeof(rx_pkt_hdr->rfc1042_hdr.snap_type));\n\t\tmemcpy(p_ethhdr->h_source, rx_pkt_hdr->eth803_hdr.h_source,\n\t\t       sizeof(p_ethhdr->h_source));\n\t\tmemcpy(p_ethhdr->h_dest, rx_pkt_hdr->eth803_hdr.h_dest,\n\t\t       sizeof(p_ethhdr->h_dest));\n\t\t \n\t\thdr_chop = (u8 *)p_ethhdr - (u8 *)uap_rx_pd;\n\t} else {\n\t\t \n\t\thdr_chop = (u8 *)&rx_pkt_hdr->eth803_hdr - (u8 *)uap_rx_pd;\n\t}\n\n\t \n\tskb_pull(skb, hdr_chop);\n\n\tif (skb_headroom(skb) < MWIFIEX_MIN_DATA_HEADER_LEN) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"data: Tx: insufficient skb headroom %d\\n\",\n\t\t\t    skb_headroom(skb));\n\t\t \n\t\tnew_skb =\n\t\t\tskb_realloc_headroom(skb, MWIFIEX_MIN_DATA_HEADER_LEN);\n\t\tif (unlikely(!new_skb)) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"Tx: cannot allocate new_skb\\n\");\n\t\t\tkfree_skb(skb);\n\t\t\tpriv->stats.tx_dropped++;\n\t\t\treturn;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t\tskb = new_skb;\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: new skb headroom %d\\n\",\n\t\t\t    skb_headroom(skb));\n\t}\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tmemset(tx_info, 0, sizeof(*tx_info));\n\ttx_info->bss_num = priv->bss_num;\n\ttx_info->bss_type = priv->bss_type;\n\ttx_info->flags |= MWIFIEX_BUF_FLAG_BRIDGED_PKT;\n\n\tsrc_node = mwifiex_get_sta_entry(priv, rx_pkt_hdr->eth803_hdr.h_source);\n\tif (src_node) {\n\t\tsrc_node->stats.last_rx = jiffies;\n\t\tsrc_node->stats.rx_bytes += skb->len;\n\t\tsrc_node->stats.rx_packets++;\n\t\tsrc_node->stats.last_tx_rate = uap_rx_pd->rx_rate;\n\t\tsrc_node->stats.last_tx_htinfo = uap_rx_pd->ht_info;\n\t}\n\n\tif (is_unicast_ether_addr(rx_pkt_hdr->eth803_hdr.h_dest)) {\n\t\t \n\t\tpriv->stats.rx_bytes += skb->len;\n\t\tpriv->stats.rx_packets++;\n\n\t\t \n\t\ttx_info->pkt_len = skb->len;\n\t}\n\n\t__net_timestamp(skb);\n\n\tindex = mwifiex_1d_to_wmm_queue[skb->priority];\n\tatomic_inc(&priv->wmm_tx_pending[index]);\n\tmwifiex_wmm_add_buf_txqueue(priv, skb);\n\tatomic_inc(&adapter->tx_pending);\n\tatomic_inc(&adapter->pending_bridged_pkts);\n\n\tmwifiex_queue_main_work(priv->adapter);\n\n\treturn;\n}\n\n \nint mwifiex_handle_uap_rx_forward(struct mwifiex_private *priv,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct uap_rxpd *uap_rx_pd;\n\tstruct rx_packet_hdr *rx_pkt_hdr;\n\tu8 ra[ETH_ALEN];\n\tstruct sk_buff *skb_uap;\n\n\tuap_rx_pd = (struct uap_rxpd *)(skb->data);\n\trx_pkt_hdr = (void *)uap_rx_pd + le16_to_cpu(uap_rx_pd->rx_pkt_offset);\n\n\t \n\tif (!priv->media_connected) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"drop packet in disconnected state.\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn 0;\n\t}\n\n\tmemcpy(ra, rx_pkt_hdr->eth803_hdr.h_dest, ETH_ALEN);\n\n\tif (is_multicast_ether_addr(ra)) {\n\t\tskb_uap = skb_copy(skb, GFP_ATOMIC);\n\t\tif (likely(skb_uap)) {\n\t\t\tmwifiex_uap_queue_bridged_pkt(priv, skb_uap);\n\t\t} else {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"failed to copy skb for uAP\\n\");\n\t\t\tpriv->stats.rx_dropped++;\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (mwifiex_get_sta_entry(priv, ra)) {\n\t\t\t \n\t\t\tmwifiex_uap_queue_bridged_pkt(priv, skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\treturn mwifiex_process_rx_packet(priv, skb);\n}\n\nint mwifiex_uap_recv_packet(struct mwifiex_private *priv,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_sta_node *src_node;\n\tstruct ethhdr *p_ethhdr;\n\tstruct sk_buff *skb_uap;\n\tstruct mwifiex_txinfo *tx_info;\n\n\tif (!skb)\n\t\treturn -1;\n\n\tp_ethhdr = (void *)skb->data;\n\tsrc_node = mwifiex_get_sta_entry(priv, p_ethhdr->h_source);\n\tif (src_node) {\n\t\tsrc_node->stats.last_rx = jiffies;\n\t\tsrc_node->stats.rx_bytes += skb->len;\n\t\tsrc_node->stats.rx_packets++;\n\t}\n\n\tif (is_multicast_ether_addr(p_ethhdr->h_dest) ||\n\t    mwifiex_get_sta_entry(priv, p_ethhdr->h_dest)) {\n\t\tif (skb_headroom(skb) < MWIFIEX_MIN_DATA_HEADER_LEN)\n\t\t\tskb_uap =\n\t\t\tskb_realloc_headroom(skb, MWIFIEX_MIN_DATA_HEADER_LEN);\n\t\telse\n\t\t\tskb_uap = skb_copy(skb, GFP_ATOMIC);\n\n\t\tif (likely(skb_uap)) {\n\t\t\ttx_info = MWIFIEX_SKB_TXCB(skb_uap);\n\t\t\tmemset(tx_info, 0, sizeof(*tx_info));\n\t\t\ttx_info->bss_num = priv->bss_num;\n\t\t\ttx_info->bss_type = priv->bss_type;\n\t\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_BRIDGED_PKT;\n\t\t\t__net_timestamp(skb_uap);\n\t\t\tmwifiex_wmm_add_buf_txqueue(priv, skb_uap);\n\t\t\tatomic_inc(&adapter->tx_pending);\n\t\t\tatomic_inc(&adapter->pending_bridged_pkts);\n\t\t\tif ((atomic_read(&adapter->pending_bridged_pkts) >=\n\t\t\t\t\tMWIFIEX_BRIDGED_PKTS_THR_HIGH)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"Tx: Bridge packet limit reached. Drop packet!\\n\");\n\t\t\t\tmwifiex_uap_cleanup_tx_queues(priv);\n\t\t\t}\n\n\t\t} else {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"failed to allocate skb_uap\");\n\t\t}\n\n\t\tmwifiex_queue_main_work(adapter);\n\t\t \n\t\tif (mwifiex_get_sta_entry(priv, p_ethhdr->h_dest))\n\t\t\treturn 0;\n\t}\n\n\tskb->dev = priv->netdev;\n\tskb->protocol = eth_type_trans(skb, priv->netdev);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t \n\tif ((adapter->iface_type == MWIFIEX_USB ||\n\t     adapter->iface_type == MWIFIEX_PCIE) &&\n\t    skb->truesize > MWIFIEX_RX_DATA_BUF_SIZE)\n\t\tskb->truesize += (skb->len - MWIFIEX_RX_DATA_BUF_SIZE);\n\n\t \n\tnetif_rx(skb);\n\treturn 0;\n}\n\n \nint mwifiex_process_uap_rx_packet(struct mwifiex_private *priv,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret;\n\tstruct uap_rxpd *uap_rx_pd;\n\tstruct rx_packet_hdr *rx_pkt_hdr;\n\tu16 rx_pkt_type;\n\tu8 ta[ETH_ALEN], pkt_type;\n\tstruct mwifiex_sta_node *node;\n\n\tuap_rx_pd = (struct uap_rxpd *)(skb->data);\n\trx_pkt_type = le16_to_cpu(uap_rx_pd->rx_pkt_type);\n\trx_pkt_hdr = (void *)uap_rx_pd + le16_to_cpu(uap_rx_pd->rx_pkt_offset);\n\n\tif (le16_to_cpu(uap_rx_pd->rx_pkt_offset) +\n\t    sizeof(rx_pkt_hdr->eth803_hdr) > skb->len) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"wrong rx packet for struct ethhdr: len=%d, offset=%d\\n\",\n\t\t\t    skb->len, le16_to_cpu(uap_rx_pd->rx_pkt_offset));\n\t\tpriv->stats.rx_dropped++;\n\t\tdev_kfree_skb_any(skb);\n\t\treturn 0;\n\t}\n\n\tether_addr_copy(ta, rx_pkt_hdr->eth803_hdr.h_source);\n\n\tif ((le16_to_cpu(uap_rx_pd->rx_pkt_offset) +\n\t     le16_to_cpu(uap_rx_pd->rx_pkt_length)) > (u16) skb->len) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"wrong rx packet: len=%d, offset=%d, length=%d\\n\",\n\t\t\t    skb->len, le16_to_cpu(uap_rx_pd->rx_pkt_offset),\n\t\t\t    le16_to_cpu(uap_rx_pd->rx_pkt_length));\n\t\tpriv->stats.rx_dropped++;\n\n\t\tnode = mwifiex_get_sta_entry(priv, ta);\n\t\tif (node)\n\t\t\tnode->stats.tx_failed++;\n\n\t\tdev_kfree_skb_any(skb);\n\t\treturn 0;\n\t}\n\n\tif (rx_pkt_type == PKT_TYPE_MGMT) {\n\t\tret = mwifiex_process_mgmt_packet(priv, skb);\n\t\tif (ret)\n\t\t\tmwifiex_dbg(adapter, DATA, \"Rx of mgmt packet failed\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn ret;\n\t}\n\n\n\tif (rx_pkt_type != PKT_TYPE_BAR && uap_rx_pd->priority < MAX_NUM_TID) {\n\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\tnode = mwifiex_get_sta_entry(priv, ta);\n\t\tif (node)\n\t\t\tnode->rx_seq[uap_rx_pd->priority] =\n\t\t\t\t\t\tle16_to_cpu(uap_rx_pd->seq_num);\n\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t}\n\n\tif (!priv->ap_11n_enabled ||\n\t    (!mwifiex_11n_get_rx_reorder_tbl(priv, uap_rx_pd->priority, ta) &&\n\t    (le16_to_cpu(uap_rx_pd->rx_pkt_type) != PKT_TYPE_AMSDU))) {\n\t\tret = mwifiex_handle_uap_rx_forward(priv, skb);\n\t\treturn ret;\n\t}\n\n\t \n\tpkt_type = (u8)le16_to_cpu(uap_rx_pd->rx_pkt_type);\n\tret = mwifiex_11n_rx_reorder_pkt(priv, le16_to_cpu(uap_rx_pd->seq_num),\n\t\t\t\t\t uap_rx_pd->priority, ta, pkt_type,\n\t\t\t\t\t skb);\n\n\tif (ret || (rx_pkt_type == PKT_TYPE_BAR))\n\t\tdev_kfree_skb_any(skb);\n\n\tif (ret)\n\t\tpriv->stats.rx_dropped++;\n\n\treturn ret;\n}\n\n \nvoid mwifiex_process_uap_txpd(struct mwifiex_private *priv,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct uap_txpd *txpd;\n\tstruct mwifiex_txinfo *tx_info = MWIFIEX_SKB_TXCB(skb);\n\tint pad;\n\tu16 pkt_type, pkt_offset;\n\tint hroom = adapter->intf_hdr_len;\n\n\tpkt_type = mwifiex_is_skb_mgmt_frame(skb) ? PKT_TYPE_MGMT : 0;\n\n\tpad = ((uintptr_t)skb->data - (sizeof(*txpd) + hroom)) &\n\t       (MWIFIEX_DMA_ALIGN_SZ - 1);\n\n\tskb_push(skb, sizeof(*txpd) + pad);\n\n\ttxpd = (struct uap_txpd *)skb->data;\n\tmemset(txpd, 0, sizeof(*txpd));\n\ttxpd->bss_num = priv->bss_num;\n\ttxpd->bss_type = priv->bss_type;\n\ttxpd->tx_pkt_length = cpu_to_le16((u16)(skb->len - (sizeof(*txpd) +\n\t\t\t\t\t\tpad)));\n\ttxpd->priority = (u8)skb->priority;\n\n\ttxpd->pkt_delay_2ms = mwifiex_wmm_compute_drv_pkt_delay(priv, skb);\n\n\tif (tx_info->flags & MWIFIEX_BUF_FLAG_EAPOL_TX_STATUS ||\n\t    tx_info->flags & MWIFIEX_BUF_FLAG_ACTION_TX_STATUS) {\n\t\ttxpd->tx_token_id = tx_info->ack_frame_id;\n\t\ttxpd->flags |= MWIFIEX_TXPD_FLAGS_REQ_TX_STATUS;\n\t}\n\n\tif (txpd->priority < ARRAY_SIZE(priv->wmm.user_pri_pkt_tx_ctrl))\n\t\t \n\t\ttxpd->tx_control =\n\t\t    cpu_to_le32(priv->wmm.user_pri_pkt_tx_ctrl[txpd->priority]);\n\n\t \n\tpkt_offset = sizeof(*txpd) + pad;\n\tif (pkt_type == PKT_TYPE_MGMT) {\n\t\t \n\t\ttxpd->tx_pkt_type = cpu_to_le16(pkt_type);\n\t\tpkt_offset += MWIFIEX_MGMT_FRAME_HEADER_SIZE;\n\t}\n\n\ttxpd->tx_pkt_offset = cpu_to_le16(pkt_offset);\n\n\t \n\tskb_push(skb, hroom);\n\n\tif (!txpd->tx_control)\n\t\t \n\t\ttxpd->tx_control = cpu_to_le32(priv->pkt_tx_ctrl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}