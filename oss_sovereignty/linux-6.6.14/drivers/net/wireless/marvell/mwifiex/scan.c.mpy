{
  "module_name": "scan.c",
  "hash_id": "84ffee2f157bed08907e835cd8ef6c7bef4be33a9c5df2d2706b1db2bc9bdb63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/scan.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"11n.h\"\n#include \"cfg80211.h\"\n\n \n#define MWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN   14\n\n#define MWIFIEX_DEF_CHANNELS_PER_SCAN_CMD\t4\n\n \n#define CHAN_TLV_MAX_SIZE  (sizeof(struct mwifiex_ie_types_header)         \\\n\t\t\t\t+ (MWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN     \\\n\t\t\t\t*sizeof(struct mwifiex_chan_scan_param_set)))\n\n \n#define RATE_TLV_MAX_SIZE   (sizeof(struct mwifiex_ie_types_rates_param_set) \\\n\t\t\t\t+ HOSTCMD_SUPPORTED_RATES)\n\n \n#define WILDCARD_SSID_TLV_MAX_SIZE  \\\n\t(MWIFIEX_MAX_SSID_LIST_LENGTH *\t\t\t\t\t\\\n\t\t(sizeof(struct mwifiex_ie_types_wildcard_ssid_params)\t\\\n\t\t\t+ IEEE80211_MAX_SSID_LEN))\n\n \n#define MAX_SCAN_CFG_ALLOC (sizeof(struct mwifiex_scan_cmd_config)        \\\n\t\t\t\t+ sizeof(struct mwifiex_ie_types_num_probes)   \\\n\t\t\t\t+ sizeof(struct mwifiex_ie_types_htcap)       \\\n\t\t\t\t+ CHAN_TLV_MAX_SIZE                 \\\n\t\t\t\t+ RATE_TLV_MAX_SIZE                 \\\n\t\t\t\t+ WILDCARD_SSID_TLV_MAX_SIZE)\n\n\nunion mwifiex_scan_cmd_config_tlv {\n\t \n\tstruct mwifiex_scan_cmd_config config;\n\t \n\tu8 config_alloc_buf[MAX_SCAN_CFG_ALLOC];\n};\n\nenum cipher_suite {\n\tCIPHER_SUITE_TKIP,\n\tCIPHER_SUITE_CCMP,\n\tCIPHER_SUITE_MAX\n};\nstatic u8 mwifiex_wpa_oui[CIPHER_SUITE_MAX][4] = {\n\t{ 0x00, 0x50, 0xf2, 0x02 },\t \n\t{ 0x00, 0x50, 0xf2, 0x04 },\t \n};\nstatic u8 mwifiex_rsn_oui[CIPHER_SUITE_MAX][4] = {\n\t{ 0x00, 0x0f, 0xac, 0x02 },\t \n\t{ 0x00, 0x0f, 0xac, 0x04 },\t \n};\n\nstatic void\n_dbg_security_flags(int log_level, const char *func, const char *desc,\n\t\t    struct mwifiex_private *priv,\n\t\t    struct mwifiex_bssdescriptor *bss_desc)\n{\n\t_mwifiex_dbg(priv->adapter, log_level,\n\t\t     \"info: %s: %s:\\twpa_ie=%#x wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s\\tEncMode=%#x privacy=%#x\\n\",\n\t\t     func, desc,\n\t\t     bss_desc->bcn_wpa_ie ?\n\t\t     bss_desc->bcn_wpa_ie->vend_hdr.element_id : 0,\n\t\t     bss_desc->bcn_rsn_ie ?\n\t\t     bss_desc->bcn_rsn_ie->ieee_hdr.element_id : 0,\n\t\t     priv->sec_info.wep_enabled ? \"e\" : \"d\",\n\t\t     priv->sec_info.wpa_enabled ? \"e\" : \"d\",\n\t\t     priv->sec_info.wpa2_enabled ? \"e\" : \"d\",\n\t\t     priv->sec_info.encryption_mode,\n\t\t     bss_desc->privacy);\n}\n#define dbg_security_flags(mask, desc, priv, bss_desc) \\\n\t_dbg_security_flags(MWIFIEX_DBG_##mask, desc, __func__, priv, bss_desc)\n\nstatic bool\nhas_ieee_hdr(struct ieee_types_generic *ie, u8 key)\n{\n\treturn (ie && ie->ieee_hdr.element_id == key);\n}\n\nstatic bool\nhas_vendor_hdr(struct ieee_types_vendor_specific *ie, u8 key)\n{\n\treturn (ie && ie->vend_hdr.element_id == key);\n}\n\n \nstatic u8\nmwifiex_search_oui_in_ie(struct ie_body *iebody, u8 *oui)\n{\n\tu8 count;\n\n\tcount = iebody->ptk_cnt[0];\n\n\t \n\twhile (count) {\n\t\tif (!memcmp(iebody->ptk_body, oui, sizeof(iebody->ptk_body)))\n\t\t\treturn MWIFIEX_OUI_PRESENT;\n\n\t\t--count;\n\t\tif (count)\n\t\t\tiebody = (struct ie_body *) ((u8 *) iebody +\n\t\t\t\t\t\tsizeof(iebody->ptk_body));\n\t}\n\n\tpr_debug(\"info: %s: OUI is not found in PTK\\n\", __func__);\n\treturn MWIFIEX_OUI_NOT_PRESENT;\n}\n\n \nstatic u8\nmwifiex_is_rsn_oui_present(struct mwifiex_bssdescriptor *bss_desc, u32 cipher)\n{\n\tu8 *oui;\n\tstruct ie_body *iebody;\n\tu8 ret = MWIFIEX_OUI_NOT_PRESENT;\n\n\tif (has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN)) {\n\t\tiebody = (struct ie_body *)\n\t\t\t (((u8 *) bss_desc->bcn_rsn_ie->data) +\n\t\t\t  RSN_GTK_OUI_OFFSET);\n\t\toui = &mwifiex_rsn_oui[cipher][0];\n\t\tret = mwifiex_search_oui_in_ie(iebody, oui);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\n \nstatic u8\nmwifiex_is_wpa_oui_present(struct mwifiex_bssdescriptor *bss_desc, u32 cipher)\n{\n\tu8 *oui;\n\tstruct ie_body *iebody;\n\tu8 ret = MWIFIEX_OUI_NOT_PRESENT;\n\n\tif (has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC)) {\n\t\tiebody = (struct ie_body *)((u8 *)bss_desc->bcn_wpa_ie->data +\n\t\t\t\t\t    WPA_GTK_OUI_OFFSET);\n\t\toui = &mwifiex_wpa_oui[cipher][0];\n\t\tret = mwifiex_search_oui_in_ie(iebody, oui);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\n \ns32\nmwifiex_ssid_cmp(struct cfg80211_ssid *ssid1, struct cfg80211_ssid *ssid2)\n{\n\tif (!ssid1 || !ssid2 || (ssid1->ssid_len != ssid2->ssid_len))\n\t\treturn -1;\n\treturn memcmp(ssid1->ssid, ssid2->ssid, ssid1->ssid_len);\n}\n\n \nstatic bool\nmwifiex_is_bss_wapi(struct mwifiex_private *priv,\n\t\t    struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (priv->sec_info.wapi_enabled &&\n\t    has_ieee_hdr(bss_desc->bcn_wapi_ie, WLAN_EID_BSS_AC_ACCESS_DELAY))\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic bool\nmwifiex_is_bss_no_sec(struct mwifiex_private *priv,\n\t\t      struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled &&\n\t    !has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC) &&\n\t    !has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN) &&\n\t    !priv->sec_info.encryption_mode && !bss_desc->privacy) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic bool\nmwifiex_is_bss_static_wep(struct mwifiex_private *priv,\n\t\t\t  struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled && bss_desc->privacy) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic bool\nmwifiex_is_bss_wpa(struct mwifiex_private *priv,\n\t\t   struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled &&\n\t    has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC)\n\t    \n\t ) {\n\t\tdbg_security_flags(INFO, \"WPA\", priv, bss_desc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic bool\nmwifiex_is_bss_wpa2(struct mwifiex_private *priv,\n\t\t    struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    priv->sec_info.wpa2_enabled &&\n\t    has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN)) {\n\t\t \n\t\tdbg_security_flags(INFO, \"WAP2\", priv, bss_desc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic bool\nmwifiex_is_bss_adhoc_aes(struct mwifiex_private *priv,\n\t\t\t struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled &&\n\t    !has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC) &&\n\t    !has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN) &&\n\t    !priv->sec_info.encryption_mode && bss_desc->privacy) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic bool\nmwifiex_is_bss_dynamic_wep(struct mwifiex_private *priv,\n\t\t\t   struct mwifiex_bssdescriptor *bss_desc)\n{\n\tif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\n\t    !priv->sec_info.wpa2_enabled &&\n\t    !has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC) &&\n\t    !has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN) &&\n\t    priv->sec_info.encryption_mode && bss_desc->privacy) {\n\t\tdbg_security_flags(INFO, \"dynamic\", priv, bss_desc);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic s32\nmwifiex_is_network_compatible(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_bssdescriptor *bss_desc, u32 mode)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tbss_desc->disable_11n = false;\n\n\t \n\tif (priv->media_connected &&\n\t    (priv->bss_mode == NL80211_IFTYPE_STATION) &&\n\t    (bss_desc->bss_mode == NL80211_IFTYPE_STATION))\n\t\treturn 0;\n\n\tif (priv->wps.session_enable) {\n\t\tmwifiex_dbg(adapter, IOCTL,\n\t\t\t    \"info: return success directly in WPS period\\n\");\n\t\treturn 0;\n\t}\n\n\tif (bss_desc->chan_sw_ie_present) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"Don't connect to AP with WLAN_EID_CHANNEL_SWITCH\\n\");\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_is_bss_wapi(priv, bss_desc)) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: return success for WAPI AP\\n\");\n\t\treturn 0;\n\t}\n\n\tif (bss_desc->bss_mode == mode) {\n\t\tif (mwifiex_is_bss_no_sec(priv, bss_desc)) {\n\t\t\t \n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_static_wep(priv, bss_desc)) {\n\t\t\t \n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: Disable 11n in WEP mode.\\n\");\n\t\t\tbss_desc->disable_11n = true;\n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_wpa(priv, bss_desc)) {\n\t\t\t \n\t\t\tif (((priv->adapter->config_bands & BAND_GN ||\n\t\t\t      priv->adapter->config_bands & BAND_AN) &&\n\t\t\t     bss_desc->bcn_ht_cap) &&\n\t\t\t    !mwifiex_is_wpa_oui_present(bss_desc,\n\t\t\t\t\t\t\t CIPHER_SUITE_CCMP)) {\n\n\t\t\t\tif (mwifiex_is_wpa_oui_present\n\t\t\t\t\t\t(bss_desc, CIPHER_SUITE_TKIP)) {\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"info: Disable 11n if AES\\t\"\n\t\t\t\t\t\t    \"is not supported by AP\\n\");\n\t\t\t\t\tbss_desc->disable_11n = true;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_wpa2(priv, bss_desc)) {\n\t\t\t \n\t\t\tif (((priv->adapter->config_bands & BAND_GN ||\n\t\t\t      priv->adapter->config_bands & BAND_AN) &&\n\t\t\t     bss_desc->bcn_ht_cap) &&\n\t\t\t    !mwifiex_is_rsn_oui_present(bss_desc,\n\t\t\t\t\t\t\tCIPHER_SUITE_CCMP)) {\n\n\t\t\t\tif (mwifiex_is_rsn_oui_present\n\t\t\t\t\t\t(bss_desc, CIPHER_SUITE_TKIP)) {\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"info: Disable 11n if AES\\t\"\n\t\t\t\t\t\t    \"is not supported by AP\\n\");\n\t\t\t\t\tbss_desc->disable_11n = true;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_adhoc_aes(priv, bss_desc)) {\n\t\t\t \n\t\t\treturn 0;\n\t\t} else if (mwifiex_is_bss_dynamic_wep(priv, bss_desc)) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tdbg_security_flags(ERROR, \"failed\", priv, bss_desc);\n\t\treturn -1;\n\t}\n\n\t \n\treturn -1;\n}\n\n \nstatic int\nmwifiex_scan_create_channel_list(struct mwifiex_private *priv,\n\t\t\t\t const struct mwifiex_user_scan_cfg\n\t\t\t\t\t\t\t*user_scan_in,\n\t\t\t\t struct mwifiex_chan_scan_param_set\n\t\t\t\t\t\t\t*scan_chan_list,\n\t\t\t\t u8 filtered_scan)\n{\n\tenum nl80211_band band;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint chan_idx = 0, i;\n\n\tfor (band = 0; (band < NUM_NL80211_BANDS) ; band++) {\n\n\t\tif (!priv->wdev.wiphy->bands[band])\n\t\t\tcontinue;\n\n\t\tsband = priv->wdev.wiphy->bands[band];\n\n\t\tfor (i = 0; (i < sband->n_channels) ; i++) {\n\t\t\tch = &sband->channels[i];\n\t\t\tif (ch->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\t\t\tscan_chan_list[chan_idx].radio_type = band;\n\n\t\t\tif (user_scan_in &&\n\t\t\t    user_scan_in->chan_list[0].scan_time)\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16((u16) user_scan_in->\n\t\t\t\t\tchan_list[0].scan_time);\n\t\t\telse if ((ch->flags & IEEE80211_CHAN_NO_IR) ||\n\t\t\t\t (ch->flags & IEEE80211_CHAN_RADAR))\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16(adapter->passive_scan_time);\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16(adapter->active_scan_time);\n\n\t\t\tif (ch->flags & IEEE80211_CHAN_NO_IR)\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t|= (MWIFIEX_PASSIVE_SCAN |\n\t\t\t\t\t    MWIFIEX_HIDDEN_SSID_REPORT);\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t&= ~MWIFIEX_PASSIVE_SCAN;\n\t\t\tscan_chan_list[chan_idx].chan_number =\n\t\t\t\t\t\t\t(u32) ch->hw_value;\n\n\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t|= MWIFIEX_DISABLE_CHAN_FILT;\n\n\t\t\tif (filtered_scan &&\n\t\t\t    !((ch->flags & IEEE80211_CHAN_NO_IR) ||\n\t\t\t      (ch->flags & IEEE80211_CHAN_RADAR)))\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\tcpu_to_le16(adapter->specific_scan_time);\n\n\t\t\tchan_idx++;\n\t\t}\n\n\t}\n\treturn chan_idx;\n}\n\n \nstatic int\nmwifiex_bgscan_create_channel_list(struct mwifiex_private *priv,\n\t\t\t\t   const struct mwifiex_bg_scan_cfg\n\t\t\t\t\t\t*bgscan_cfg_in,\n\t\t\t\t   struct mwifiex_chan_scan_param_set\n\t\t\t\t\t\t*scan_chan_list)\n{\n\tenum nl80211_band band;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint chan_idx = 0, i;\n\n\tfor (band = 0; (band < NUM_NL80211_BANDS); band++) {\n\t\tif (!priv->wdev.wiphy->bands[band])\n\t\t\tcontinue;\n\n\t\tsband = priv->wdev.wiphy->bands[band];\n\n\t\tfor (i = 0; (i < sband->n_channels) ; i++) {\n\t\t\tch = &sband->channels[i];\n\t\t\tif (ch->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\t\t\tscan_chan_list[chan_idx].radio_type = band;\n\n\t\t\tif (bgscan_cfg_in->chan_list[0].scan_time)\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16((u16)bgscan_cfg_in->\n\t\t\t\t\tchan_list[0].scan_time);\n\t\t\telse if (ch->flags & IEEE80211_CHAN_NO_IR)\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16(adapter->passive_scan_time);\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\t\tcpu_to_le16(adapter->\n\t\t\t\t\t\t    specific_scan_time);\n\n\t\t\tif (ch->flags & IEEE80211_CHAN_NO_IR)\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t|= MWIFIEX_PASSIVE_SCAN;\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t&= ~MWIFIEX_PASSIVE_SCAN;\n\n\t\t\tscan_chan_list[chan_idx].chan_number =\n\t\t\t\t\t\t\t(u32)ch->hw_value;\n\t\t\tchan_idx++;\n\t\t}\n\t}\n\treturn chan_idx;\n}\n\n \nstatic int\nmwifiex_append_rate_tlv(struct mwifiex_private *priv,\n\t\t\tstruct mwifiex_scan_cmd_config *scan_cfg_out,\n\t\t\tu8 radio)\n{\n\tstruct mwifiex_ie_types_rates_param_set *rates_tlv;\n\tu8 rates[MWIFIEX_SUPPORTED_RATES], *tlv_pos;\n\tu32 rates_size;\n\n\tmemset(rates, 0, sizeof(rates));\n\n\ttlv_pos = (u8 *)scan_cfg_out->tlv_buf + scan_cfg_out->tlv_buf_len;\n\n\tif (priv->scan_request)\n\t\trates_size = mwifiex_get_rates_from_cfg80211(priv, rates,\n\t\t\t\t\t\t\t     radio);\n\telse\n\t\trates_size = mwifiex_get_supported_rates(priv, rates);\n\n\tmwifiex_dbg(priv->adapter, CMD,\n\t\t    \"info: SCAN_CMD: Rates size = %d\\n\",\n\t\trates_size);\n\trates_tlv = (struct mwifiex_ie_types_rates_param_set *)tlv_pos;\n\trates_tlv->header.type = cpu_to_le16(WLAN_EID_SUPP_RATES);\n\trates_tlv->header.len = cpu_to_le16((u16) rates_size);\n\tmemcpy(rates_tlv->rates, rates, rates_size);\n\tscan_cfg_out->tlv_buf_len += sizeof(rates_tlv->header) + rates_size;\n\n\treturn rates_size;\n}\n\n \nstatic int\nmwifiex_scan_channel_list(struct mwifiex_private *priv,\n\t\t\t  u32 max_chan_per_scan, u8 filtered_scan,\n\t\t\t  struct mwifiex_scan_cmd_config *scan_cfg_out,\n\t\t\t  struct mwifiex_ie_types_chan_list_param_set\n\t\t\t  *chan_tlv_out,\n\t\t\t  struct mwifiex_chan_scan_param_set *scan_chan_list)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret = 0;\n\tstruct mwifiex_chan_scan_param_set *tmp_chan_list;\n\tu32 tlv_idx, rates_size, cmd_no;\n\tu32 total_scan_time;\n\tu32 done_early;\n\tu8 radio_type;\n\n\tif (!scan_cfg_out || !chan_tlv_out || !scan_chan_list) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"info: Scan: Null detect: %p, %p, %p\\n\",\n\t\t\t    scan_cfg_out, chan_tlv_out, scan_chan_list);\n\t\treturn -1;\n\t}\n\n\t \n\tmwifiex_11h_get_csa_closed_channel(priv);\n\n\tchan_tlv_out->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\n\t \n\ttmp_chan_list = scan_chan_list;\n\n\t \n\twhile (tmp_chan_list->chan_number) {\n\n\t\ttlv_idx = 0;\n\t\ttotal_scan_time = 0;\n\t\tradio_type = 0;\n\t\tchan_tlv_out->header.len = 0;\n\t\tdone_early = false;\n\n\t\t \n\t\twhile (tlv_idx < max_chan_per_scan &&\n\t\t       tmp_chan_list->chan_number && !done_early) {\n\n\t\t\tif (tmp_chan_list->chan_number == priv->csa_chan) {\n\t\t\t\ttmp_chan_list++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tradio_type = tmp_chan_list->radio_type;\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: Scan: Chan(%3d), Radio(%d),\\t\"\n\t\t\t\t    \"Mode(%d, %d), Dur(%d)\\n\",\n\t\t\t\t    tmp_chan_list->chan_number,\n\t\t\t\t    tmp_chan_list->radio_type,\n\t\t\t\t    tmp_chan_list->chan_scan_mode_bitmap\n\t\t\t\t    & MWIFIEX_PASSIVE_SCAN,\n\t\t\t\t    (tmp_chan_list->chan_scan_mode_bitmap\n\t\t\t\t    & MWIFIEX_DISABLE_CHAN_FILT) >> 1,\n\t\t\t\t    le16_to_cpu(tmp_chan_list->max_scan_time));\n\n\t\t\t \n\t\t\tmemcpy(chan_tlv_out->chan_scan_param + tlv_idx,\n\t\t\t       tmp_chan_list,\n\t\t\t       sizeof(chan_tlv_out->chan_scan_param));\n\n\t\t\t \n\t\t\tle16_unaligned_add_cpu(&chan_tlv_out->header.len,\n\t\t\t\t\t       sizeof(\n\t\t\t\t\t\tchan_tlv_out->chan_scan_param));\n\n\t\t\t \n\t\t\tscan_cfg_out->tlv_buf_len = (u32) ((u8 *) chan_tlv_out -\n\t\t\t\t\t\t\tscan_cfg_out->tlv_buf);\n\n\t\t\t \n\t\t\tscan_cfg_out->tlv_buf_len +=\n\t\t\t\t(sizeof(chan_tlv_out->header)\n\t\t\t\t + le16_to_cpu(chan_tlv_out->header.len));\n\n\t\t\t \n\t\t\ttlv_idx++;\n\n\t\t\t \n\t\t\ttotal_scan_time +=\n\t\t\t\tle16_to_cpu(tmp_chan_list->max_scan_time);\n\n\t\t\tdone_early = false;\n\n\t\t\t \n\t\t\tif (!filtered_scan &&\n\t\t\t    (tmp_chan_list->chan_number == 1 ||\n\t\t\t     tmp_chan_list->chan_number == 6 ||\n\t\t\t     tmp_chan_list->chan_number == 11))\n\t\t\t\tdone_early = true;\n\n\t\t\t \n\t\t\ttmp_chan_list++;\n\n\t\t\t \n\t\t\tif (!filtered_scan &&\n\t\t\t    (tmp_chan_list->chan_number == 1 ||\n\t\t\t     tmp_chan_list->chan_number == 6 ||\n\t\t\t     tmp_chan_list->chan_number == 11))\n\t\t\t\tdone_early = true;\n\t\t}\n\n\t\t \n\t\tif (total_scan_time > MWIFIEX_MAX_TOTAL_SCAN_TIME) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"total scan time %dms\\t\"\n\t\t\t\t    \"is over limit (%dms), scan skipped\\n\",\n\t\t\t\t    total_scan_time,\n\t\t\t\t    MWIFIEX_MAX_TOTAL_SCAN_TIME);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\trates_size = mwifiex_append_rate_tlv(priv, scan_cfg_out,\n\t\t\t\t\t\t     radio_type);\n\n\t\t \n\t\tif (priv->adapter->ext_scan)\n\t\t\tcmd_no = HostCmd_CMD_802_11_SCAN_EXT;\n\t\telse\n\t\t\tcmd_no = HostCmd_CMD_802_11_SCAN;\n\n\t\tret = mwifiex_send_cmd(priv, cmd_no, HostCmd_ACT_GEN_SET,\n\t\t\t\t       0, scan_cfg_out, false);\n\n\t\t \n\t\tscan_cfg_out->tlv_buf_len -=\n\t\t\t    sizeof(struct mwifiex_ie_types_header) + rates_size;\n\n\t\tif (ret) {\n\t\t\tmwifiex_cancel_pending_scan_cmd(adapter);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic void\nmwifiex_config_scan(struct mwifiex_private *priv,\n\t\t    const struct mwifiex_user_scan_cfg *user_scan_in,\n\t\t    struct mwifiex_scan_cmd_config *scan_cfg_out,\n\t\t    struct mwifiex_ie_types_chan_list_param_set **chan_list_out,\n\t\t    struct mwifiex_chan_scan_param_set *scan_chan_list,\n\t\t    u8 *max_chan_per_scan, u8 *filtered_scan,\n\t\t    u8 *scan_current_only)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_ie_types_num_probes *num_probes_tlv;\n\tstruct mwifiex_ie_types_scan_chan_gap *chan_gap_tlv;\n\tstruct mwifiex_ie_types_random_mac *random_mac_tlv;\n\tstruct mwifiex_ie_types_wildcard_ssid_params *wildcard_ssid_tlv;\n\tstruct mwifiex_ie_types_bssid_list *bssid_tlv;\n\tu8 *tlv_pos;\n\tu32 num_probes;\n\tu32 ssid_len;\n\tu32 chan_idx;\n\tu32 scan_type;\n\tu16 scan_dur;\n\tu8 channel;\n\tu8 radio_type;\n\tint i;\n\tu8 ssid_filter;\n\tstruct mwifiex_ie_types_htcap *ht_cap;\n\tstruct mwifiex_ie_types_bss_mode *bss_mode;\n\n\t \n\tscan_cfg_out->tlv_buf_len = 0;\n\n\t \n\ttlv_pos = scan_cfg_out->tlv_buf;\n\n\t \n\t*filtered_scan = false;\n\n\t \n\t*scan_current_only = false;\n\n\tif (user_scan_in) {\n\t\tu8 tmpaddr[ETH_ALEN];\n\n\t\t \n\t\tssid_filter = true;\n\n\t\t \n\t\tscan_cfg_out->bss_mode =\n\t\t\t(u8)(user_scan_in->bss_mode ?: adapter->scan_mode);\n\n\t\t \n\t\tnum_probes = user_scan_in->num_probes ?: adapter->scan_probes;\n\n\t\t \n\t\tmemcpy(scan_cfg_out->specific_bssid,\n\t\t       user_scan_in->specific_bssid,\n\t\t       sizeof(scan_cfg_out->specific_bssid));\n\n\t\tmemcpy(tmpaddr, scan_cfg_out->specific_bssid, ETH_ALEN);\n\n\t\tif (adapter->ext_scan &&\n\t\t    !is_zero_ether_addr(tmpaddr)) {\n\t\t\tbssid_tlv =\n\t\t\t\t(struct mwifiex_ie_types_bssid_list *)tlv_pos;\n\t\t\tbssid_tlv->header.type = cpu_to_le16(TLV_TYPE_BSSID);\n\t\t\tbssid_tlv->header.len = cpu_to_le16(ETH_ALEN);\n\t\t\tmemcpy(bssid_tlv->bssid, user_scan_in->specific_bssid,\n\t\t\t       ETH_ALEN);\n\t\t\ttlv_pos += sizeof(struct mwifiex_ie_types_bssid_list);\n\t\t}\n\n\t\tfor (i = 0; i < user_scan_in->num_ssids; i++) {\n\t\t\tssid_len = user_scan_in->ssid_list[i].ssid_len;\n\n\t\t\twildcard_ssid_tlv =\n\t\t\t\t(struct mwifiex_ie_types_wildcard_ssid_params *)\n\t\t\t\ttlv_pos;\n\t\t\twildcard_ssid_tlv->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_WILDCARDSSID);\n\t\t\twildcard_ssid_tlv->header.len = cpu_to_le16(\n\t\t\t\t(u16) (ssid_len + sizeof(wildcard_ssid_tlv->\n\t\t\t\t\t\t\t max_ssid_length)));\n\n\t\t\t \n\t\t\tif (ssid_len)\n\t\t\t\twildcard_ssid_tlv->max_ssid_length = 0;\n\t\t\telse\n\t\t\t\twildcard_ssid_tlv->max_ssid_length =\n\t\t\t\t\t\t\tIEEE80211_MAX_SSID_LEN;\n\n\t\t\tif (!memcmp(user_scan_in->ssid_list[i].ssid,\n\t\t\t\t    \"DIRECT-\", 7))\n\t\t\t\twildcard_ssid_tlv->max_ssid_length = 0xfe;\n\n\t\t\tmemcpy(wildcard_ssid_tlv->ssid,\n\t\t\t       user_scan_in->ssid_list[i].ssid, ssid_len);\n\n\t\t\ttlv_pos += (sizeof(wildcard_ssid_tlv->header)\n\t\t\t\t+ le16_to_cpu(wildcard_ssid_tlv->header.len));\n\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: scan: ssid[%d]: %s, %d\\n\",\n\t\t\t\t    i, wildcard_ssid_tlv->ssid,\n\t\t\t\t    wildcard_ssid_tlv->max_ssid_length);\n\n\t\t\t \n\t\t\tif (!ssid_len && wildcard_ssid_tlv->max_ssid_length)\n\t\t\t\tssid_filter = false;\n\t\t}\n\n\t\t \n\t\tmemcpy(tmpaddr, scan_cfg_out->specific_bssid, ETH_ALEN);\n\t\tif ((i && ssid_filter) ||\n\t\t    !is_zero_ether_addr(tmpaddr))\n\t\t\t*filtered_scan = true;\n\n\t\tif (user_scan_in->scan_chan_gap) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: scan: channel gap = %d\\n\",\n\t\t\t\t    user_scan_in->scan_chan_gap);\n\t\t\t*max_chan_per_scan =\n\t\t\t\t\tMWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN;\n\n\t\t\tchan_gap_tlv = (void *)tlv_pos;\n\t\t\tchan_gap_tlv->header.type =\n\t\t\t\t\t cpu_to_le16(TLV_TYPE_SCAN_CHANNEL_GAP);\n\t\t\tchan_gap_tlv->header.len =\n\t\t\t\t    cpu_to_le16(sizeof(chan_gap_tlv->chan_gap));\n\t\t\tchan_gap_tlv->chan_gap =\n\t\t\t\t     cpu_to_le16((user_scan_in->scan_chan_gap));\n\t\t\ttlv_pos +=\n\t\t\t\t  sizeof(struct mwifiex_ie_types_scan_chan_gap);\n\t\t}\n\n\t\tif (!is_zero_ether_addr(user_scan_in->random_mac)) {\n\t\t\trandom_mac_tlv = (void *)tlv_pos;\n\t\t\trandom_mac_tlv->header.type =\n\t\t\t\t\t cpu_to_le16(TLV_TYPE_RANDOM_MAC);\n\t\t\trandom_mac_tlv->header.len =\n\t\t\t\t    cpu_to_le16(sizeof(random_mac_tlv->mac));\n\t\t\tether_addr_copy(random_mac_tlv->mac,\n\t\t\t\t\tuser_scan_in->random_mac);\n\t\t\ttlv_pos +=\n\t\t\t\t  sizeof(struct mwifiex_ie_types_random_mac);\n\t\t}\n\t} else {\n\t\tscan_cfg_out->bss_mode = (u8) adapter->scan_mode;\n\t\tnum_probes = adapter->scan_probes;\n\t}\n\n\t \n\tif (*filtered_scan) {\n\t\t*max_chan_per_scan = MWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN;\n\t} else {\n\t\tif (!priv->media_connected)\n\t\t\t*max_chan_per_scan = MWIFIEX_DEF_CHANNELS_PER_SCAN_CMD;\n\t\telse\n\t\t\t*max_chan_per_scan =\n\t\t\t\t\tMWIFIEX_DEF_CHANNELS_PER_SCAN_CMD / 2;\n\t}\n\n\tif (adapter->ext_scan) {\n\t\tbss_mode = (struct mwifiex_ie_types_bss_mode *)tlv_pos;\n\t\tbss_mode->header.type = cpu_to_le16(TLV_TYPE_BSS_MODE);\n\t\tbss_mode->header.len = cpu_to_le16(sizeof(bss_mode->bss_mode));\n\t\tbss_mode->bss_mode = scan_cfg_out->bss_mode;\n\t\ttlv_pos += sizeof(bss_mode->header) +\n\t\t\t   le16_to_cpu(bss_mode->header.len);\n\t}\n\n\t \n\tif (num_probes) {\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: scan: num_probes = %d\\n\",\n\t\t\t    num_probes);\n\n\t\tnum_probes_tlv = (struct mwifiex_ie_types_num_probes *) tlv_pos;\n\t\tnum_probes_tlv->header.type = cpu_to_le16(TLV_TYPE_NUMPROBES);\n\t\tnum_probes_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(num_probes_tlv->num_probes));\n\t\tnum_probes_tlv->num_probes = cpu_to_le16((u16) num_probes);\n\n\t\ttlv_pos += sizeof(num_probes_tlv->header) +\n\t\t\tle16_to_cpu(num_probes_tlv->header.len);\n\n\t}\n\n\tif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\n\t    (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN)) {\n\t\tht_cap = (struct mwifiex_ie_types_htcap *) tlv_pos;\n\t\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\n\t\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\tht_cap->header.len =\n\t\t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\tradio_type =\n\t\t\tmwifiex_band_to_radio_type(priv->adapter->config_bands);\n\t\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\n\t\ttlv_pos += sizeof(struct mwifiex_ie_types_htcap);\n\t}\n\n\t \n\tmwifiex_cmd_append_vsie_tlv(priv, MWIFIEX_VSIE_MASK_SCAN, &tlv_pos);\n\n\t \n\t*chan_list_out =\n\t\t(struct mwifiex_ie_types_chan_list_param_set *) tlv_pos;\n\n\tif (user_scan_in && user_scan_in->chan_list[0].chan_number) {\n\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: Scan: Using supplied channel list\\n\");\n\n\t\tfor (chan_idx = 0;\n\t\t     chan_idx < MWIFIEX_USER_SCAN_CHAN_MAX &&\n\t\t     user_scan_in->chan_list[chan_idx].chan_number;\n\t\t     chan_idx++) {\n\n\t\t\tchannel = user_scan_in->chan_list[chan_idx].chan_number;\n\t\t\tscan_chan_list[chan_idx].chan_number = channel;\n\n\t\t\tradio_type =\n\t\t\t\tuser_scan_in->chan_list[chan_idx].radio_type;\n\t\t\tscan_chan_list[chan_idx].radio_type = radio_type;\n\n\t\t\tscan_type = user_scan_in->chan_list[chan_idx].scan_type;\n\n\t\t\tif (scan_type == MWIFIEX_SCAN_TYPE_PASSIVE)\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t|= (MWIFIEX_PASSIVE_SCAN |\n\t\t\t\t\t    MWIFIEX_HIDDEN_SSID_REPORT);\n\t\t\telse\n\t\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t\t&= ~MWIFIEX_PASSIVE_SCAN;\n\n\t\t\tscan_chan_list[chan_idx].chan_scan_mode_bitmap\n\t\t\t\t|= MWIFIEX_DISABLE_CHAN_FILT;\n\n\t\t\tif (user_scan_in->chan_list[chan_idx].scan_time) {\n\t\t\t\tscan_dur = (u16) user_scan_in->\n\t\t\t\t\tchan_list[chan_idx].scan_time;\n\t\t\t} else {\n\t\t\t\tif (scan_type == MWIFIEX_SCAN_TYPE_PASSIVE)\n\t\t\t\t\tscan_dur = adapter->passive_scan_time;\n\t\t\t\telse if (*filtered_scan)\n\t\t\t\t\tscan_dur = adapter->specific_scan_time;\n\t\t\t\telse\n\t\t\t\t\tscan_dur = adapter->active_scan_time;\n\t\t\t}\n\n\t\t\tscan_chan_list[chan_idx].min_scan_time =\n\t\t\t\tcpu_to_le16(scan_dur);\n\t\t\tscan_chan_list[chan_idx].max_scan_time =\n\t\t\t\tcpu_to_le16(scan_dur);\n\t\t}\n\n\t\t \n\t\tif ((chan_idx == 1) &&\n\t\t    (user_scan_in->chan_list[0].chan_number ==\n\t\t     priv->curr_bss_params.bss_descriptor.channel)) {\n\t\t\t*scan_current_only = true;\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: Scan: Scanning current channel only\\n\");\n\t\t}\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: Scan: Creating full region channel list\\n\");\n\t\tmwifiex_scan_create_channel_list(priv, user_scan_in,\n\t\t\t\t\t\t scan_chan_list,\n\t\t\t\t\t\t *filtered_scan);\n\t}\n\n}\n\n \nstatic void\nmwifiex_ret_802_11_scan_get_tlv_ptrs(struct mwifiex_adapter *adapter,\n\t\t\t\t     struct mwifiex_ie_types_data *tlv,\n\t\t\t\t     u32 tlv_buf_size, u32 req_tlv_type,\n\t\t\t\t     struct mwifiex_ie_types_data **tlv_data)\n{\n\tstruct mwifiex_ie_types_data *current_tlv;\n\tu32 tlv_buf_left;\n\tu32 tlv_type;\n\tu32 tlv_len;\n\n\tcurrent_tlv = tlv;\n\ttlv_buf_left = tlv_buf_size;\n\t*tlv_data = NULL;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: SCAN_RESP: tlv_buf_size = %d\\n\",\n\t\t    tlv_buf_size);\n\n\twhile (tlv_buf_left >= sizeof(struct mwifiex_ie_types_header)) {\n\n\t\ttlv_type = le16_to_cpu(current_tlv->header.type);\n\t\ttlv_len = le16_to_cpu(current_tlv->header.len);\n\n\t\tif (sizeof(tlv->header) + tlv_len > tlv_buf_left) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"SCAN_RESP: TLV buffer corrupt\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (req_tlv_type == tlv_type) {\n\t\t\tswitch (tlv_type) {\n\t\t\tcase TLV_TYPE_TSFTIMESTAMP:\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: SCAN_RESP: TSF\\t\"\n\t\t\t\t\t    \"timestamp TLV, len = %d\\n\",\n\t\t\t\t\t    tlv_len);\n\t\t\t\t*tlv_data = current_tlv;\n\t\t\t\tbreak;\n\t\t\tcase TLV_TYPE_CHANNELBANDLIST:\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: SCAN_RESP: channel\\t\"\n\t\t\t\t\t    \"band list TLV, len = %d\\n\",\n\t\t\t\t\t    tlv_len);\n\t\t\t\t*tlv_data = current_tlv;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"SCAN_RESP: unhandled TLV = %d\\n\",\n\t\t\t\t\t    tlv_type);\n\t\t\t\t \n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (*tlv_data)\n\t\t\tbreak;\n\n\n\t\ttlv_buf_left -= (sizeof(tlv->header) + tlv_len);\n\t\tcurrent_tlv =\n\t\t\t(struct mwifiex_ie_types_data *) (current_tlv->data +\n\t\t\t\t\t\t\t  tlv_len);\n\n\t}\t\t\t \n}\n\n \nint mwifiex_update_bss_desc_with_ie(struct mwifiex_adapter *adapter,\n\t\t\t\t    struct mwifiex_bssdescriptor *bss_entry)\n{\n\tu8 element_id;\n\tstruct ieee_types_fh_param_set *fh_param_set;\n\tstruct ieee_types_ds_param_set *ds_param_set;\n\tstruct ieee_types_cf_param_set *cf_param_set;\n\tstruct ieee_types_ibss_param_set *ibss_param_set;\n\tu8 *current_ptr;\n\tu8 *rate;\n\tu8 element_len;\n\tu16 total_ie_len;\n\tu8 bytes_to_copy;\n\tu8 rate_size;\n\tu8 found_data_rate_ie;\n\tu32 bytes_left;\n\tstruct ieee_types_vendor_specific *vendor_ie;\n\tconst u8 wpa_oui[4] = { 0x00, 0x50, 0xf2, 0x01 };\n\tconst u8 wmm_oui[4] = { 0x00, 0x50, 0xf2, 0x02 };\n\n\tfound_data_rate_ie = false;\n\trate_size = 0;\n\tcurrent_ptr = bss_entry->beacon_buf;\n\tbytes_left = bss_entry->beacon_buf_size;\n\n\t \n\twhile (bytes_left >= 2) {\n\t\telement_id = *current_ptr;\n\t\telement_len = *(current_ptr + 1);\n\t\ttotal_ie_len = element_len + sizeof(struct ieee_types_header);\n\n\t\tif (bytes_left < total_ie_len) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"err: InterpretIE: in processing\\t\"\n\t\t\t\t    \"IE, bytes left < IE length\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (element_id) {\n\t\tcase WLAN_EID_SSID:\n\t\t\tif (element_len > IEEE80211_MAX_SSID_LEN)\n\t\t\t\treturn -EINVAL;\n\t\t\tbss_entry->ssid.ssid_len = element_len;\n\t\t\tmemcpy(bss_entry->ssid.ssid, (current_ptr + 2),\n\t\t\t       element_len);\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: InterpretIE: ssid: %-32s\\n\",\n\t\t\t\t    bss_entry->ssid.ssid);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\t\tif (element_len > MWIFIEX_SUPPORTED_RATES)\n\t\t\t\treturn -EINVAL;\n\t\t\tmemcpy(bss_entry->data_rates, current_ptr + 2,\n\t\t\t       element_len);\n\t\t\tmemcpy(bss_entry->supported_rates, current_ptr + 2,\n\t\t\t       element_len);\n\t\t\trate_size = element_len;\n\t\t\tfound_data_rate_ie = true;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_FH_PARAMS:\n\t\t\tif (total_ie_len < sizeof(*fh_param_set))\n\t\t\t\treturn -EINVAL;\n\t\t\tfh_param_set =\n\t\t\t\t(struct ieee_types_fh_param_set *) current_ptr;\n\t\t\tmemcpy(&bss_entry->phy_param_set.fh_param_set,\n\t\t\t       fh_param_set,\n\t\t\t       sizeof(struct ieee_types_fh_param_set));\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_DS_PARAMS:\n\t\t\tif (total_ie_len < sizeof(*ds_param_set))\n\t\t\t\treturn -EINVAL;\n\t\t\tds_param_set =\n\t\t\t\t(struct ieee_types_ds_param_set *) current_ptr;\n\n\t\t\tbss_entry->channel = ds_param_set->current_chan;\n\n\t\t\tmemcpy(&bss_entry->phy_param_set.ds_param_set,\n\t\t\t       ds_param_set,\n\t\t\t       sizeof(struct ieee_types_ds_param_set));\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_CF_PARAMS:\n\t\t\tif (total_ie_len < sizeof(*cf_param_set))\n\t\t\t\treturn -EINVAL;\n\t\t\tcf_param_set =\n\t\t\t\t(struct ieee_types_cf_param_set *) current_ptr;\n\t\t\tmemcpy(&bss_entry->ss_param_set.cf_param_set,\n\t\t\t       cf_param_set,\n\t\t\t       sizeof(struct ieee_types_cf_param_set));\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_IBSS_PARAMS:\n\t\t\tif (total_ie_len < sizeof(*ibss_param_set))\n\t\t\t\treturn -EINVAL;\n\t\t\tibss_param_set =\n\t\t\t\t(struct ieee_types_ibss_param_set *)\n\t\t\t\tcurrent_ptr;\n\t\t\tmemcpy(&bss_entry->ss_param_set.ibss_param_set,\n\t\t\t       ibss_param_set,\n\t\t\t       sizeof(struct ieee_types_ibss_param_set));\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_ERP_INFO:\n\t\t\tif (!element_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tbss_entry->erp_flags = *(current_ptr + 2);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_PWR_CONSTRAINT:\n\t\t\tif (!element_len)\n\t\t\t\treturn -EINVAL;\n\t\t\tbss_entry->local_constraint = *(current_ptr + 2);\n\t\t\tbss_entry->sensed_11h = true;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_CHANNEL_SWITCH:\n\t\t\tbss_entry->chan_sw_ie_present = true;\n\t\t\tfallthrough;\n\t\tcase WLAN_EID_PWR_CAPABILITY:\n\t\tcase WLAN_EID_TPC_REPORT:\n\t\tcase WLAN_EID_QUIET:\n\t\t\tbss_entry->sensed_11h = true;\n\t\t    break;\n\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\t\t \n\t\t\tif (found_data_rate_ie) {\n\t\t\t\tif ((element_len + rate_size) >\n\t\t\t\t    MWIFIEX_SUPPORTED_RATES)\n\t\t\t\t\tbytes_to_copy =\n\t\t\t\t\t\t(MWIFIEX_SUPPORTED_RATES -\n\t\t\t\t\t\t rate_size);\n\t\t\t\telse\n\t\t\t\t\tbytes_to_copy = element_len;\n\n\t\t\t\trate = (u8 *) bss_entry->data_rates;\n\t\t\t\trate += rate_size;\n\t\t\t\tmemcpy(rate, current_ptr + 2, bytes_to_copy);\n\n\t\t\t\trate = (u8 *) bss_entry->supported_rates;\n\t\t\t\trate += rate_size;\n\t\t\t\tmemcpy(rate, current_ptr + 2, bytes_to_copy);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\tvendor_ie = (struct ieee_types_vendor_specific *)\n\t\t\t\t\tcurrent_ptr;\n\n\t\t\t \n\t\t\tif (element_len < sizeof(vendor_ie->vend_hdr.oui.oui))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tif (element_len < sizeof(wpa_oui))\n\t\t\t\tbreak;\n\n\t\t\tif (!memcmp(&vendor_ie->vend_hdr.oui, wpa_oui,\n\t\t\t\t    sizeof(wpa_oui))) {\n\t\t\t\tbss_entry->bcn_wpa_ie =\n\t\t\t\t\t(struct ieee_types_vendor_specific *)\n\t\t\t\t\tcurrent_ptr;\n\t\t\t\tbss_entry->wpa_offset = (u16)\n\t\t\t\t\t(current_ptr - bss_entry->beacon_buf);\n\t\t\t} else if (!memcmp(&vendor_ie->vend_hdr.oui, wmm_oui,\n\t\t\t\t    sizeof(wmm_oui))) {\n\t\t\t\tif (total_ie_len ==\n\t\t\t\t    sizeof(struct ieee_types_wmm_parameter) ||\n\t\t\t\t    total_ie_len ==\n\t\t\t\t    sizeof(struct ieee_types_wmm_info))\n\t\t\t\t\t \n\t\t\t\t\tmemcpy((u8 *) &bss_entry->wmm_ie,\n\t\t\t\t\t       current_ptr, total_ie_len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_EID_RSN:\n\t\t\tbss_entry->bcn_rsn_ie =\n\t\t\t\t(struct ieee_types_generic *) current_ptr;\n\t\t\tbss_entry->rsn_offset = (u16) (current_ptr -\n\t\t\t\t\t\t\tbss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_BSS_AC_ACCESS_DELAY:\n\t\t\tbss_entry->bcn_wapi_ie =\n\t\t\t\t(struct ieee_types_generic *) current_ptr;\n\t\t\tbss_entry->wapi_offset = (u16) (current_ptr -\n\t\t\t\t\t\t\tbss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\t\tbss_entry->bcn_ht_cap = (struct ieee80211_ht_cap *)\n\t\t\t\t\t(current_ptr +\n\t\t\t\t\tsizeof(struct ieee_types_header));\n\t\t\tbss_entry->ht_cap_offset = (u16) (current_ptr +\n\t\t\t\t\tsizeof(struct ieee_types_header) -\n\t\t\t\t\tbss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_HT_OPERATION:\n\t\t\tbss_entry->bcn_ht_oper =\n\t\t\t\t(struct ieee80211_ht_operation *)(current_ptr +\n\t\t\t\t\tsizeof(struct ieee_types_header));\n\t\t\tbss_entry->ht_info_offset = (u16) (current_ptr +\n\t\t\t\t\tsizeof(struct ieee_types_header) -\n\t\t\t\t\tbss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\t\tbss_entry->disable_11ac = false;\n\t\t\tbss_entry->bcn_vht_cap =\n\t\t\t\t(void *)(current_ptr +\n\t\t\t\t\t sizeof(struct ieee_types_header));\n\t\t\tbss_entry->vht_cap_offset =\n\t\t\t\t\t(u16)((u8 *)bss_entry->bcn_vht_cap -\n\t\t\t\t\t      bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_VHT_OPERATION:\n\t\t\tbss_entry->bcn_vht_oper =\n\t\t\t\t(void *)(current_ptr +\n\t\t\t\t\t sizeof(struct ieee_types_header));\n\t\t\tbss_entry->vht_info_offset =\n\t\t\t\t\t(u16)((u8 *)bss_entry->bcn_vht_oper -\n\t\t\t\t\t      bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_BSS_COEX_2040:\n\t\t\tbss_entry->bcn_bss_co_2040 = current_ptr;\n\t\t\tbss_entry->bss_co_2040_offset =\n\t\t\t\t(u16) (current_ptr - bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_EXT_CAPABILITY:\n\t\t\tbss_entry->bcn_ext_cap = current_ptr;\n\t\t\tbss_entry->ext_cap_offset =\n\t\t\t\t(u16) (current_ptr - bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tcase WLAN_EID_OPMODE_NOTIF:\n\t\t\tbss_entry->oper_mode = (void *)current_ptr;\n\t\t\tbss_entry->oper_mode_offset =\n\t\t\t\t\t(u16)((u8 *)bss_entry->oper_mode -\n\t\t\t\t\t      bss_entry->beacon_buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tcurrent_ptr += total_ie_len;\n\t\tbytes_left -= total_ie_len;\n\n\t}\t \n\treturn 0;\n}\n\n \nstatic u8\nmwifiex_radio_type_to_band(u8 radio_type)\n{\n\tswitch (radio_type) {\n\tcase HostCmd_SCAN_RADIO_TYPE_A:\n\t\treturn BAND_A;\n\tcase HostCmd_SCAN_RADIO_TYPE_BG:\n\tdefault:\n\t\treturn BAND_G;\n\t}\n}\n\n \nint mwifiex_scan_networks(struct mwifiex_private *priv,\n\t\t\t  const struct mwifiex_user_scan_cfg *user_scan_in)\n{\n\tint ret;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct cmd_ctrl_node *cmd_node;\n\tunion mwifiex_scan_cmd_config_tlv *scan_cfg_out;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_list_out;\n\tstruct mwifiex_chan_scan_param_set *scan_chan_list;\n\tu8 filtered_scan;\n\tu8 scan_current_chan_only;\n\tu8 max_chan_per_scan;\n\n\tif (adapter->scan_processing) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"cmd: Scan already in process...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (priv->scan_block) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"cmd: Scan is blocked during association...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (test_bit(MWIFIEX_SURPRISE_REMOVED, &adapter->work_flags) ||\n\t    test_bit(MWIFIEX_IS_CMD_TIMEDOUT, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Ignore scan. Card removed or firmware in bad state\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\tadapter->scan_processing = true;\n\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\n\tscan_cfg_out = kzalloc(sizeof(union mwifiex_scan_cmd_config_tlv),\n\t\t\t       GFP_KERNEL);\n\tif (!scan_cfg_out) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tscan_chan_list = kcalloc(MWIFIEX_USER_SCAN_CHAN_MAX,\n\t\t\t\t sizeof(struct mwifiex_chan_scan_param_set),\n\t\t\t\t GFP_KERNEL);\n\tif (!scan_chan_list) {\n\t\tkfree(scan_cfg_out);\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tmwifiex_config_scan(priv, user_scan_in, &scan_cfg_out->config,\n\t\t\t    &chan_list_out, scan_chan_list, &max_chan_per_scan,\n\t\t\t    &filtered_scan, &scan_current_chan_only);\n\n\tret = mwifiex_scan_channel_list(priv, max_chan_per_scan, filtered_scan,\n\t\t\t\t\t&scan_cfg_out->config, chan_list_out,\n\t\t\t\t\tscan_chan_list);\n\n\t \n\tif (!ret) {\n\t\tspin_lock_bh(&adapter->scan_pending_q_lock);\n\t\tif (!list_empty(&adapter->scan_pending_q)) {\n\t\t\tcmd_node = list_first_entry(&adapter->scan_pending_q,\n\t\t\t\t\t\t    struct cmd_ctrl_node, list);\n\t\t\tlist_del(&cmd_node->list);\n\t\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\t\t\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\n\t\t\tqueue_work(adapter->workqueue, &adapter->main_work);\n\n\t\t\t \n\t\t\tif (!priv->scan_request) {\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"wait internal scan\\n\");\n\t\t\t\tmwifiex_wait_queue_complete(adapter, cmd_node);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\t\t}\n\t}\n\n\tkfree(scan_cfg_out);\n\tkfree(scan_chan_list);\ndone:\n\tif (ret) {\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->scan_processing = false;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\t}\n\treturn ret;\n}\n\n \nint mwifiex_cmd_802_11_scan(struct host_cmd_ds_command *cmd,\n\t\t\t    struct mwifiex_scan_cmd_config *scan_cfg)\n{\n\tstruct host_cmd_ds_802_11_scan *scan_cmd = &cmd->params.scan;\n\n\t \n\tscan_cmd->bss_mode = scan_cfg->bss_mode;\n\tmemcpy(scan_cmd->bssid, scan_cfg->specific_bssid,\n\t       sizeof(scan_cmd->bssid));\n\tmemcpy(scan_cmd->tlv_buffer, scan_cfg->tlv_buf, scan_cfg->tlv_buf_len);\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_SCAN);\n\n\t \n\tcmd->size = cpu_to_le16((u16) (sizeof(scan_cmd->bss_mode)\n\t\t\t\t\t  + sizeof(scan_cmd->bssid)\n\t\t\t\t\t  + scan_cfg->tlv_buf_len + S_DS_GEN));\n\n\treturn 0;\n}\n\n \nint mwifiex_check_network_compatibility(struct mwifiex_private *priv,\n\t\t\t\t\tstruct mwifiex_bssdescriptor *bss_desc)\n{\n\tint ret = -1;\n\n\tif (!bss_desc)\n\t\treturn -1;\n\n\tif ((mwifiex_get_cfp(priv, (u8) bss_desc->bss_band,\n\t\t\t     (u16) bss_desc->channel, 0))) {\n\t\tswitch (priv->bss_mode) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tret = mwifiex_is_network_compatible(priv, bss_desc,\n\t\t\t\t\t\t\t    priv->bss_mode);\n\t\t\tif (ret)\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"Incompatible network settings\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic bool mwifiex_is_hidden_ssid(struct cfg80211_ssid *ssid)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < ssid->ssid_len; idx++) {\n\t\tif (ssid->ssid[idx])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int mwifiex_save_hidden_ssid_channels(struct mwifiex_private *priv,\n\t\t\t\t\t     struct cfg80211_bss *bss)\n{\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tint ret;\n\tint chid;\n\n\t \n\tbss_desc = kzalloc(sizeof(*bss_desc), GFP_KERNEL);\n\tif (!bss_desc)\n\t\treturn -ENOMEM;\n\n\tret = mwifiex_fill_new_bss_desc(priv, bss, bss_desc);\n\tif (ret)\n\t\tgoto done;\n\n\tif (mwifiex_is_hidden_ssid(&bss_desc->ssid)) {\n\t\tmwifiex_dbg(priv->adapter, INFO, \"found hidden SSID\\n\");\n\t\tfor (chid = 0 ; chid < MWIFIEX_USER_SCAN_CHAN_MAX; chid++) {\n\t\t\tif (priv->hidden_chan[chid].chan_number ==\n\t\t\t    bss->channel->hw_value)\n\t\t\t\tbreak;\n\n\t\t\tif (!priv->hidden_chan[chid].chan_number) {\n\t\t\t\tpriv->hidden_chan[chid].chan_number =\n\t\t\t\t\tbss->channel->hw_value;\n\t\t\t\tpriv->hidden_chan[chid].radio_type =\n\t\t\t\t\tbss->channel->band;\n\t\t\t\tpriv->hidden_chan[chid].scan_type =\n\t\t\t\t\tMWIFIEX_SCAN_TYPE_ACTIVE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\t \n\tkfree(bss_desc->beacon_buf);\n\tkfree(bss_desc);\n\treturn 0;\n}\n\nstatic int mwifiex_update_curr_bss_params(struct mwifiex_private *priv,\n\t\t\t\t\t  struct cfg80211_bss *bss)\n{\n\tstruct mwifiex_bssdescriptor *bss_desc;\n\tint ret;\n\n\t \n\tbss_desc = kzalloc(sizeof(struct mwifiex_bssdescriptor), GFP_KERNEL);\n\tif (!bss_desc)\n\t\treturn -ENOMEM;\n\n\tret = mwifiex_fill_new_bss_desc(priv, bss, bss_desc);\n\tif (ret)\n\t\tgoto done;\n\n\tret = mwifiex_check_network_compatibility(priv, bss_desc);\n\tif (ret)\n\t\tgoto done;\n\n\tspin_lock_bh(&priv->curr_bcn_buf_lock);\n\t \n\tmemcpy(&priv->curr_bss_params.bss_descriptor, bss_desc,\n\t       sizeof(priv->curr_bss_params.bss_descriptor));\n\n\t \n\tmwifiex_save_curr_bcn(priv);\n\tspin_unlock_bh(&priv->curr_bcn_buf_lock);\n\ndone:\n\t \n\tkfree(bss_desc->beacon_buf);\n\tkfree(bss_desc);\n\treturn 0;\n}\n\nstatic int\nmwifiex_parse_single_response_buf(struct mwifiex_private *priv, u8 **bss_info,\n\t\t\t\t  u32 *bytes_left, u64 fw_tsf, u8 *radio_type,\n\t\t\t\t  bool ext_scan, s32 rssi_val)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_chan_freq_power *cfp;\n\tstruct cfg80211_bss *bss;\n\tu8 bssid[ETH_ALEN];\n\ts32 rssi;\n\tconst u8 *ie_buf;\n\tsize_t ie_len;\n\tu16 channel = 0;\n\tu16 beacon_size = 0;\n\tu32 curr_bcn_bytes;\n\tu32 freq;\n\tu16 beacon_period;\n\tu16 cap_info_bitmap;\n\tu8 *current_ptr;\n\tu64 timestamp;\n\tstruct mwifiex_fixed_bcn_param *bcn_param;\n\tstruct mwifiex_bss_priv *bss_priv;\n\n\tif (*bytes_left >= sizeof(beacon_size)) {\n\t\t \n\t\tbeacon_size = get_unaligned_le16((*bss_info));\n\t\t*bytes_left -= sizeof(beacon_size);\n\t\t*bss_info += sizeof(beacon_size);\n\t}\n\n\tif (!beacon_size || beacon_size > *bytes_left) {\n\t\t*bss_info += *bytes_left;\n\t\t*bytes_left = 0;\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tcurrent_ptr = *bss_info;\n\n\t \n\t*bss_info += beacon_size;\n\t*bytes_left -= beacon_size;\n\n\tcurr_bcn_bytes = beacon_size;\n\n\t \n\tif (curr_bcn_bytes < ETH_ALEN + sizeof(u8) +\n\t    sizeof(struct mwifiex_fixed_bcn_param)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"InterpretIE: not enough bytes left\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(bssid, current_ptr, ETH_ALEN);\n\tcurrent_ptr += ETH_ALEN;\n\tcurr_bcn_bytes -= ETH_ALEN;\n\n\tif (!ext_scan) {\n\t\trssi = (s32) *current_ptr;\n\t\trssi = (-rssi) * 100;\t\t \n\t\tcurrent_ptr += sizeof(u8);\n\t\tcurr_bcn_bytes -= sizeof(u8);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: InterpretIE: RSSI=%d\\n\", rssi);\n\t} else {\n\t\trssi = rssi_val;\n\t}\n\n\tbcn_param = (struct mwifiex_fixed_bcn_param *)current_ptr;\n\tcurrent_ptr += sizeof(*bcn_param);\n\tcurr_bcn_bytes -= sizeof(*bcn_param);\n\n\ttimestamp = le64_to_cpu(bcn_param->timestamp);\n\tbeacon_period = le16_to_cpu(bcn_param->beacon_period);\n\n\tcap_info_bitmap = le16_to_cpu(bcn_param->cap_info_bitmap);\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: InterpretIE: capabilities=0x%X\\n\",\n\t\t    cap_info_bitmap);\n\n\t \n\tie_buf = current_ptr;\n\tie_len = curr_bcn_bytes;\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: InterpretIE: IELength for this AP = %d\\n\",\n\t\t    curr_bcn_bytes);\n\n\twhile (curr_bcn_bytes >= sizeof(struct ieee_types_header)) {\n\t\tu8 element_id, element_len;\n\n\t\telement_id = *current_ptr;\n\t\telement_len = *(current_ptr + 1);\n\t\tif (curr_bcn_bytes < element_len +\n\t\t\t\tsizeof(struct ieee_types_header)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"%s: bytes left < IE length\\n\", __func__);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (element_id == WLAN_EID_DS_PARAMS) {\n\t\t\tchannel = *(current_ptr +\n\t\t\t\t    sizeof(struct ieee_types_header));\n\t\t\tbreak;\n\t\t}\n\n\t\tcurrent_ptr += element_len + sizeof(struct ieee_types_header);\n\t\tcurr_bcn_bytes -= element_len +\n\t\t\t\t\tsizeof(struct ieee_types_header);\n\t}\n\n\tif (channel) {\n\t\tstruct ieee80211_channel *chan;\n\t\tu8 band;\n\n\t\t \n\t\tif (channel == priv->csa_chan) {\n\t\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t\t    \"Dropping entry on csa closed channel\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tband = BAND_G;\n\t\tif (radio_type)\n\t\t\tband = mwifiex_radio_type_to_band(*radio_type &\n\t\t\t\t\t\t\t  (BIT(0) | BIT(1)));\n\n\t\tcfp = mwifiex_get_cfp(priv, band, channel, 0);\n\n\t\tfreq = cfp ? cfp->freq : 0;\n\n\t\tchan = ieee80211_get_channel(priv->wdev.wiphy, freq);\n\n\t\tif (chan && !(chan->flags & IEEE80211_CHAN_DISABLED)) {\n\t\t\tbss = cfg80211_inform_bss(priv->wdev.wiphy,\n\t\t\t\t\t    chan, CFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t\t    bssid, timestamp,\n\t\t\t\t\t    cap_info_bitmap, beacon_period,\n\t\t\t\t\t    ie_buf, ie_len, rssi, GFP_ATOMIC);\n\t\t\tif (bss) {\n\t\t\t\tbss_priv = (struct mwifiex_bss_priv *)bss->priv;\n\t\t\t\tbss_priv->band = band;\n\t\t\t\tbss_priv->fw_tsf = fw_tsf;\n\t\t\t\tif (priv->media_connected &&\n\t\t\t\t    !memcmp(bssid, priv->curr_bss_params.\n\t\t\t\t\t    bss_descriptor.mac_address,\n\t\t\t\t\t    ETH_ALEN))\n\t\t\t\t\tmwifiex_update_curr_bss_params(priv,\n\t\t\t\t\t\t\t\t       bss);\n\n\t\t\t\tif ((chan->flags & IEEE80211_CHAN_RADAR) ||\n\t\t\t\t    (chan->flags & IEEE80211_CHAN_NO_IR)) {\n\t\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t\t    \"radar or passive channel %d\\n\",\n\t\t\t\t\t\t    channel);\n\t\t\t\t\tmwifiex_save_hidden_ssid_channels(priv,\n\t\t\t\t\t\t\t\t\t  bss);\n\t\t\t\t}\n\n\t\t\t\tcfg80211_put_bss(priv->wdev.wiphy, bss);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmwifiex_dbg(adapter, WARN, \"missing BSS channel IE\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void mwifiex_complete_scan(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tadapter->survey_idx = 0;\n\tif (adapter->curr_cmd->wait_q_enabled) {\n\t\tadapter->cmd_wait_q.status = 0;\n\t\tif (!priv->scan_request) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"complete internal scan\\n\");\n\t\t\tmwifiex_complete_cmd(adapter, adapter->curr_cmd);\n\t\t}\n\t}\n}\n\n \nstatic int\nmwifiex_active_scan_req_for_passive_chan(struct mwifiex_private *priv)\n{\n\tint ret;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu8 id = 0;\n\tstruct mwifiex_user_scan_cfg  *user_scan_cfg;\n\n\tif (adapter->active_scan_triggered || !priv->scan_request ||\n\t    priv->scan_aborting) {\n\t\tadapter->active_scan_triggered = false;\n\t\treturn 0;\n\t}\n\n\tif (!priv->hidden_chan[0].chan_number) {\n\t\tmwifiex_dbg(adapter, INFO, \"No BSS with hidden SSID found on DFS channels\\n\");\n\t\treturn 0;\n\t}\n\tuser_scan_cfg = kzalloc(sizeof(*user_scan_cfg), GFP_KERNEL);\n\n\tif (!user_scan_cfg)\n\t\treturn -ENOMEM;\n\n\tfor (id = 0; id < MWIFIEX_USER_SCAN_CHAN_MAX; id++) {\n\t\tif (!priv->hidden_chan[id].chan_number)\n\t\t\tbreak;\n\t\tmemcpy(&user_scan_cfg->chan_list[id],\n\t\t       &priv->hidden_chan[id],\n\t\t       sizeof(struct mwifiex_user_scan_chan));\n\t}\n\n\tadapter->active_scan_triggered = true;\n\tif (priv->scan_request->flags & NL80211_SCAN_FLAG_RANDOM_ADDR)\n\t\tether_addr_copy(user_scan_cfg->random_mac,\n\t\t\t\tpriv->scan_request->mac_addr);\n\tuser_scan_cfg->num_ssids = priv->scan_request->n_ssids;\n\tuser_scan_cfg->ssid_list = priv->scan_request->ssids;\n\n\tret = mwifiex_scan_networks(priv, user_scan_cfg);\n\tkfree(user_scan_cfg);\n\n\tmemset(&priv->hidden_chan, 0, sizeof(priv->hidden_chan));\n\n\tif (ret) {\n\t\tdev_err(priv->adapter->dev, \"scan failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nstatic void mwifiex_check_next_scan_command(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct cmd_ctrl_node *cmd_node;\n\n\tspin_lock_bh(&adapter->scan_pending_q_lock);\n\tif (list_empty(&adapter->scan_pending_q)) {\n\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->scan_processing = false;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\n\t\tmwifiex_active_scan_req_for_passive_chan(priv);\n\n\t\tif (!adapter->ext_scan)\n\t\t\tmwifiex_complete_scan(priv);\n\n\t\tif (priv->scan_request) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = false,\n\t\t\t};\n\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: notifying scan done\\n\");\n\t\t\tcfg80211_scan_done(priv->scan_request, &info);\n\t\t\tpriv->scan_request = NULL;\n\t\t\tpriv->scan_aborting = false;\n\t\t} else {\n\t\t\tpriv->scan_aborting = false;\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: scan already aborted\\n\");\n\t\t}\n\t} else if ((priv->scan_aborting && !priv->scan_request) ||\n\t\t   priv->scan_block) {\n\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\n\t\tmwifiex_cancel_pending_scan_cmd(adapter);\n\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->scan_processing = false;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\n\t\tif (!adapter->active_scan_triggered) {\n\t\t\tif (priv->scan_request) {\n\t\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t\t.aborted = true,\n\t\t\t\t};\n\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: aborting scan\\n\");\n\t\t\t\tcfg80211_scan_done(priv->scan_request, &info);\n\t\t\t\tpriv->scan_request = NULL;\n\t\t\t\tpriv->scan_aborting = false;\n\t\t\t} else {\n\t\t\t\tpriv->scan_aborting = false;\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: scan already aborted\\n\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tcmd_node = list_first_entry(&adapter->scan_pending_q,\n\t\t\t\t\t    struct cmd_ctrl_node, list);\n\t\tlist_del(&cmd_node->list);\n\t\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\t\tmwifiex_insert_cmd_to_pending_q(adapter, cmd_node);\n\t}\n\n\treturn;\n}\n\nvoid mwifiex_cancel_scan(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\tmwifiex_cancel_pending_scan_cmd(adapter);\n\n\tif (adapter->scan_processing) {\n\t\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\t\tadapter->scan_processing = false;\n\t\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n\t\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\t\tpriv = adapter->priv[i];\n\t\t\tif (!priv)\n\t\t\t\tcontinue;\n\t\t\tif (priv->scan_request) {\n\t\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t\t.aborted = true,\n\t\t\t\t};\n\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: aborting scan\\n\");\n\t\t\t\tcfg80211_scan_done(priv->scan_request, &info);\n\t\t\t\tpriv->scan_request = NULL;\n\t\t\t\tpriv->scan_aborting = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nint mwifiex_ret_802_11_scan(struct mwifiex_private *priv,\n\t\t\t    struct host_cmd_ds_command *resp)\n{\n\tint ret = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_scan_rsp *scan_rsp;\n\tstruct mwifiex_ie_types_data *tlv_data;\n\tstruct mwifiex_ie_types_tsf_timestamp *tsf_tlv;\n\tu8 *bss_info;\n\tu32 scan_resp_size;\n\tu32 bytes_left;\n\tu32 idx;\n\tu32 tlv_buf_size;\n\tstruct mwifiex_ie_types_chan_band_list_param_set *chan_band_tlv;\n\tstruct chan_band_param_set *chan_band;\n\tu8 is_bgscan_resp;\n\t__le64 fw_tsf = 0;\n\tu8 *radio_type;\n\tstruct cfg80211_wowlan_nd_match *pmatch;\n\tstruct cfg80211_sched_scan_request *nd_config = NULL;\n\n\tis_bgscan_resp = (le16_to_cpu(resp->command)\n\t\t\t  == HostCmd_CMD_802_11_BG_SCAN_QUERY);\n\tif (is_bgscan_resp)\n\t\tscan_rsp = &resp->params.bg_scan_query_resp.scan_resp;\n\telse\n\t\tscan_rsp = &resp->params.scan_resp;\n\n\n\tif (scan_rsp->number_of_sets > MWIFIEX_MAX_AP) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"SCAN_RESP: too many AP returned (%d)\\n\",\n\t\t\t    scan_rsp->number_of_sets);\n\t\tret = -1;\n\t\tgoto check_next_scan;\n\t}\n\n\t \n\tmwifiex_11h_get_csa_closed_channel(priv);\n\n\tbytes_left = le16_to_cpu(scan_rsp->bss_descript_size);\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: SCAN_RESP: bss_descript_size %d\\n\",\n\t\t    bytes_left);\n\n\tscan_resp_size = le16_to_cpu(resp->size);\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: SCAN_RESP: returned %d APs before parsing\\n\",\n\t\t    scan_rsp->number_of_sets);\n\n\tbss_info = scan_rsp->bss_desc_and_tlv_buffer;\n\n\t \n\ttlv_buf_size = scan_resp_size - (bytes_left\n\t\t\t\t\t + sizeof(scan_rsp->bss_descript_size)\n\t\t\t\t\t + sizeof(scan_rsp->number_of_sets)\n\t\t\t\t\t + S_DS_GEN);\n\n\ttlv_data = (struct mwifiex_ie_types_data *) (scan_rsp->\n\t\t\t\t\t\t bss_desc_and_tlv_buffer +\n\t\t\t\t\t\t bytes_left);\n\n\t \n\tmwifiex_ret_802_11_scan_get_tlv_ptrs(adapter, tlv_data, tlv_buf_size,\n\t\t\t\t\t     TLV_TYPE_TSFTIMESTAMP,\n\t\t\t\t\t     (struct mwifiex_ie_types_data **)\n\t\t\t\t\t     &tsf_tlv);\n\n\t \n\tmwifiex_ret_802_11_scan_get_tlv_ptrs(adapter, tlv_data, tlv_buf_size,\n\t\t\t\t\t     TLV_TYPE_CHANNELBANDLIST,\n\t\t\t\t\t     (struct mwifiex_ie_types_data **)\n\t\t\t\t\t     &chan_band_tlv);\n\n#ifdef CONFIG_PM\n\tif (priv->wdev.wiphy->wowlan_config)\n\t\tnd_config = priv->wdev.wiphy->wowlan_config->nd_config;\n#endif\n\n\tif (nd_config) {\n\t\tadapter->nd_info =\n\t\t\tkzalloc(struct_size(adapter->nd_info, matches,\n\t\t\t\t\t    scan_rsp->number_of_sets),\n\t\t\t\tGFP_ATOMIC);\n\n\t\tif (adapter->nd_info)\n\t\t\tadapter->nd_info->n_matches = scan_rsp->number_of_sets;\n\t}\n\n\tfor (idx = 0; idx < scan_rsp->number_of_sets && bytes_left; idx++) {\n\t\t \n\t\tif (tsf_tlv)\n\t\t\tmemcpy(&fw_tsf, &tsf_tlv->tsf_data[idx * TSF_DATA_SIZE],\n\t\t\t       sizeof(fw_tsf));\n\n\t\tif (chan_band_tlv) {\n\t\t\tchan_band = &chan_band_tlv->chan_band_param[idx];\n\t\t\tradio_type = &chan_band->radio_type;\n\t\t} else {\n\t\t\tradio_type = NULL;\n\t\t}\n\n\t\tif (chan_band_tlv && adapter->nd_info) {\n\t\t\tadapter->nd_info->matches[idx] =\n\t\t\t\tkzalloc(sizeof(*pmatch) + sizeof(u32),\n\t\t\t\t\tGFP_ATOMIC);\n\n\t\t\tpmatch = adapter->nd_info->matches[idx];\n\n\t\t\tif (pmatch) {\n\t\t\t\tpmatch->n_channels = 1;\n\t\t\t\tpmatch->channels[0] = chan_band->chan_number;\n\t\t\t}\n\t\t}\n\n\t\tret = mwifiex_parse_single_response_buf(priv, &bss_info,\n\t\t\t\t\t\t\t&bytes_left,\n\t\t\t\t\t\t\tle64_to_cpu(fw_tsf),\n\t\t\t\t\t\t\tradio_type, false, 0);\n\t\tif (ret)\n\t\t\tgoto check_next_scan;\n\t}\n\ncheck_next_scan:\n\tmwifiex_check_next_scan_command(priv);\n\treturn ret;\n}\n\n \nint mwifiex_cmd_802_11_scan_ext(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *cmd,\n\t\t\t\tvoid *data_buf)\n{\n\tstruct host_cmd_ds_802_11_scan_ext *ext_scan = &cmd->params.ext_scan;\n\tstruct mwifiex_scan_cmd_config *scan_cfg = data_buf;\n\n\tmemcpy(ext_scan->tlv_buffer, scan_cfg->tlv_buf, scan_cfg->tlv_buf_len);\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_SCAN_EXT);\n\n\t \n\tcmd->size = cpu_to_le16((u16)(sizeof(ext_scan->reserved)\n\t\t\t\t      + scan_cfg->tlv_buf_len + S_DS_GEN));\n\n\treturn 0;\n}\n\n \nint mwifiex_cmd_802_11_bg_scan_config(struct mwifiex_private *priv,\n\t\t\t\t      struct host_cmd_ds_command *cmd,\n\t\t\t\t      void *data_buf)\n{\n\tstruct host_cmd_ds_802_11_bg_scan_config *bgscan_config =\n\t\t\t\t\t&cmd->params.bg_scan_config;\n\tstruct mwifiex_bg_scan_cfg *bgscan_cfg_in = data_buf;\n\tu8 *tlv_pos = bgscan_config->tlv;\n\tu8 num_probes;\n\tu32 ssid_len, chan_idx, scan_type, scan_dur, chan_num;\n\tint i;\n\tstruct mwifiex_ie_types_num_probes *num_probes_tlv;\n\tstruct mwifiex_ie_types_repeat_count *repeat_count_tlv;\n\tstruct mwifiex_ie_types_min_rssi_threshold *rssi_threshold_tlv;\n\tstruct mwifiex_ie_types_bgscan_start_later *start_later_tlv;\n\tstruct mwifiex_ie_types_wildcard_ssid_params *wildcard_ssid_tlv;\n\tstruct mwifiex_ie_types_chan_list_param_set *chan_list_tlv;\n\tstruct mwifiex_chan_scan_param_set *temp_chan;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_CONFIG);\n\tcmd->size = cpu_to_le16(sizeof(*bgscan_config) + S_DS_GEN);\n\n\tbgscan_config->action = cpu_to_le16(bgscan_cfg_in->action);\n\tbgscan_config->enable = bgscan_cfg_in->enable;\n\tbgscan_config->bss_type = bgscan_cfg_in->bss_type;\n\tbgscan_config->scan_interval =\n\t\tcpu_to_le32(bgscan_cfg_in->scan_interval);\n\tbgscan_config->report_condition =\n\t\tcpu_to_le32(bgscan_cfg_in->report_condition);\n\n\t \n\tif (!bgscan_config->enable)\n\t\treturn 0;\n\n\tbgscan_config->chan_per_scan = bgscan_cfg_in->chan_per_scan;\n\n\tnum_probes = (bgscan_cfg_in->num_probes ? bgscan_cfg_in->\n\t\t      num_probes : priv->adapter->scan_probes);\n\n\tif (num_probes) {\n\t\tnum_probes_tlv = (struct mwifiex_ie_types_num_probes *)tlv_pos;\n\t\tnum_probes_tlv->header.type = cpu_to_le16(TLV_TYPE_NUMPROBES);\n\t\tnum_probes_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(num_probes_tlv->num_probes));\n\t\tnum_probes_tlv->num_probes = cpu_to_le16((u16)num_probes);\n\n\t\ttlv_pos += sizeof(num_probes_tlv->header) +\n\t\t\tle16_to_cpu(num_probes_tlv->header.len);\n\t}\n\n\tif (bgscan_cfg_in->repeat_count) {\n\t\trepeat_count_tlv =\n\t\t\t(struct mwifiex_ie_types_repeat_count *)tlv_pos;\n\t\trepeat_count_tlv->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_REPEAT_COUNT);\n\t\trepeat_count_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(repeat_count_tlv->repeat_count));\n\t\trepeat_count_tlv->repeat_count =\n\t\t\tcpu_to_le16(bgscan_cfg_in->repeat_count);\n\n\t\ttlv_pos += sizeof(repeat_count_tlv->header) +\n\t\t\tle16_to_cpu(repeat_count_tlv->header.len);\n\t}\n\n\tif (bgscan_cfg_in->rssi_threshold) {\n\t\trssi_threshold_tlv =\n\t\t\t(struct mwifiex_ie_types_min_rssi_threshold *)tlv_pos;\n\t\trssi_threshold_tlv->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_RSSI_LOW);\n\t\trssi_threshold_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(rssi_threshold_tlv->rssi_threshold));\n\t\trssi_threshold_tlv->rssi_threshold =\n\t\t\tcpu_to_le16(bgscan_cfg_in->rssi_threshold);\n\n\t\ttlv_pos += sizeof(rssi_threshold_tlv->header) +\n\t\t\tle16_to_cpu(rssi_threshold_tlv->header.len);\n\t}\n\n\tfor (i = 0; i < bgscan_cfg_in->num_ssids; i++) {\n\t\tssid_len = bgscan_cfg_in->ssid_list[i].ssid.ssid_len;\n\n\t\twildcard_ssid_tlv =\n\t\t\t(struct mwifiex_ie_types_wildcard_ssid_params *)tlv_pos;\n\t\twildcard_ssid_tlv->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_WILDCARDSSID);\n\t\twildcard_ssid_tlv->header.len = cpu_to_le16(\n\t\t\t\t(u16)(ssid_len + sizeof(wildcard_ssid_tlv->\n\t\t\t\t\t\t\t max_ssid_length)));\n\n\t\t \n\t\tif (ssid_len)\n\t\t\twildcard_ssid_tlv->max_ssid_length = 0;\n\t\telse\n\t\t\twildcard_ssid_tlv->max_ssid_length =\n\t\t\t\t\t\tIEEE80211_MAX_SSID_LEN;\n\n\t\tmemcpy(wildcard_ssid_tlv->ssid,\n\t\t       bgscan_cfg_in->ssid_list[i].ssid.ssid, ssid_len);\n\n\t\ttlv_pos += (sizeof(wildcard_ssid_tlv->header)\n\t\t\t\t+ le16_to_cpu(wildcard_ssid_tlv->header.len));\n\t}\n\n\tchan_list_tlv = (struct mwifiex_ie_types_chan_list_param_set *)tlv_pos;\n\n\tif (bgscan_cfg_in->chan_list[0].chan_number) {\n\t\tdev_dbg(priv->adapter->dev, \"info: bgscan: Using supplied channel list\\n\");\n\n\t\tchan_list_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\n\t\tfor (chan_idx = 0;\n\t\t     chan_idx < MWIFIEX_BG_SCAN_CHAN_MAX &&\n\t\t     bgscan_cfg_in->chan_list[chan_idx].chan_number;\n\t\t     chan_idx++) {\n\t\t\ttemp_chan = chan_list_tlv->chan_scan_param + chan_idx;\n\n\t\t\t \n\t\t\tle16_unaligned_add_cpu(&chan_list_tlv->header.len,\n\t\t\t\t\t       sizeof(\n\t\t\t\t\t       chan_list_tlv->chan_scan_param));\n\n\t\t\ttemp_chan->chan_number =\n\t\t\t\tbgscan_cfg_in->chan_list[chan_idx].chan_number;\n\t\t\ttemp_chan->radio_type =\n\t\t\t\tbgscan_cfg_in->chan_list[chan_idx].radio_type;\n\n\t\t\tscan_type =\n\t\t\t\tbgscan_cfg_in->chan_list[chan_idx].scan_type;\n\n\t\t\tif (scan_type == MWIFIEX_SCAN_TYPE_PASSIVE)\n\t\t\t\ttemp_chan->chan_scan_mode_bitmap\n\t\t\t\t\t|= MWIFIEX_PASSIVE_SCAN;\n\t\t\telse\n\t\t\t\ttemp_chan->chan_scan_mode_bitmap\n\t\t\t\t\t&= ~MWIFIEX_PASSIVE_SCAN;\n\n\t\t\tif (bgscan_cfg_in->chan_list[chan_idx].scan_time) {\n\t\t\t\tscan_dur = (u16)bgscan_cfg_in->\n\t\t\t\t\tchan_list[chan_idx].scan_time;\n\t\t\t} else {\n\t\t\t\tscan_dur = (scan_type ==\n\t\t\t\t\t    MWIFIEX_SCAN_TYPE_PASSIVE) ?\n\t\t\t\t\t    priv->adapter->passive_scan_time :\n\t\t\t\t\t    priv->adapter->specific_scan_time;\n\t\t\t}\n\n\t\t\ttemp_chan->min_scan_time = cpu_to_le16(scan_dur);\n\t\t\ttemp_chan->max_scan_time = cpu_to_le16(scan_dur);\n\t\t}\n\t} else {\n\t\tdev_dbg(priv->adapter->dev,\n\t\t\t\"info: bgscan: Creating full region channel list\\n\");\n\t\tchan_num =\n\t\t\tmwifiex_bgscan_create_channel_list(priv, bgscan_cfg_in,\n\t\t\t\t\t\t\t   chan_list_tlv->\n\t\t\t\t\t\t\t   chan_scan_param);\n\t\tle16_unaligned_add_cpu(&chan_list_tlv->header.len,\n\t\t\t\t       chan_num *\n\t\t\t     sizeof(chan_list_tlv->chan_scan_param[0]));\n\t}\n\n\ttlv_pos += (sizeof(chan_list_tlv->header)\n\t\t\t+ le16_to_cpu(chan_list_tlv->header.len));\n\n\tif (bgscan_cfg_in->start_later) {\n\t\tstart_later_tlv =\n\t\t\t(struct mwifiex_ie_types_bgscan_start_later *)tlv_pos;\n\t\tstart_later_tlv->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_BGSCAN_START_LATER);\n\t\tstart_later_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(start_later_tlv->start_later));\n\t\tstart_later_tlv->start_later =\n\t\t\tcpu_to_le16(bgscan_cfg_in->start_later);\n\n\t\ttlv_pos += sizeof(start_later_tlv->header) +\n\t\t\tle16_to_cpu(start_later_tlv->header.len);\n\t}\n\n\t \n\tmwifiex_cmd_append_vsie_tlv(priv, MWIFIEX_VSIE_MASK_BGSCAN, &tlv_pos);\n\n\tle16_unaligned_add_cpu(&cmd->size, tlv_pos - bgscan_config->tlv);\n\n\treturn 0;\n}\n\nint mwifiex_stop_bg_scan(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_bg_scan_cfg *bgscan_cfg;\n\n\tif (!priv->sched_scanning) {\n\t\tdev_dbg(priv->adapter->dev, \"bgscan already stopped!\\n\");\n\t\treturn 0;\n\t}\n\n\tbgscan_cfg = kzalloc(sizeof(*bgscan_cfg), GFP_KERNEL);\n\tif (!bgscan_cfg)\n\t\treturn -ENOMEM;\n\n\tbgscan_cfg->bss_type = MWIFIEX_BSS_MODE_INFRA;\n\tbgscan_cfg->action = MWIFIEX_BGSCAN_ACT_SET;\n\tbgscan_cfg->enable = false;\n\n\tif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11_BG_SCAN_CONFIG,\n\t\t\t     HostCmd_ACT_GEN_SET, 0, bgscan_cfg, true)) {\n\t\tkfree(bgscan_cfg);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(bgscan_cfg);\n\tpriv->sched_scanning = false;\n\n\treturn 0;\n}\n\nstatic void\nmwifiex_update_chan_statistics(struct mwifiex_private *priv,\n\t\t\t       struct mwifiex_ietypes_chanstats *tlv_stat)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu8 i, num_chan;\n\tstruct mwifiex_fw_chan_stats *fw_chan_stats;\n\tstruct mwifiex_chan_stats chan_stats;\n\n\tfw_chan_stats = (void *)((u8 *)tlv_stat +\n\t\t\t      sizeof(struct mwifiex_ie_types_header));\n\tnum_chan = le16_to_cpu(tlv_stat->header.len) /\n\t\t\t\t\t      sizeof(struct mwifiex_chan_stats);\n\n\tfor (i = 0 ; i < num_chan; i++) {\n\t\tif (adapter->survey_idx >= adapter->num_in_chan_stats) {\n\t\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t\t    \"FW reported too many channel results (max %d)\\n\",\n\t\t\t\t    adapter->num_in_chan_stats);\n\t\t\treturn;\n\t\t}\n\t\tchan_stats.chan_num = fw_chan_stats->chan_num;\n\t\tchan_stats.bandcfg = fw_chan_stats->bandcfg;\n\t\tchan_stats.flags = fw_chan_stats->flags;\n\t\tchan_stats.noise = fw_chan_stats->noise;\n\t\tchan_stats.total_bss = le16_to_cpu(fw_chan_stats->total_bss);\n\t\tchan_stats.cca_scan_dur =\n\t\t\t\t       le16_to_cpu(fw_chan_stats->cca_scan_dur);\n\t\tchan_stats.cca_busy_dur =\n\t\t\t\t       le16_to_cpu(fw_chan_stats->cca_busy_dur);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"chan=%d, noise=%d, total_network=%d scan_duration=%d, busy_duration=%d\\n\",\n\t\t\t    chan_stats.chan_num,\n\t\t\t    chan_stats.noise,\n\t\t\t    chan_stats.total_bss,\n\t\t\t    chan_stats.cca_scan_dur,\n\t\t\t    chan_stats.cca_busy_dur);\n\t\tmemcpy(&adapter->chan_stats[adapter->survey_idx++], &chan_stats,\n\t\t       sizeof(struct mwifiex_chan_stats));\n\t\tfw_chan_stats++;\n\t}\n}\n\n \nint mwifiex_ret_802_11_scan_ext(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *resp)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_scan_ext *ext_scan_resp;\n\tstruct mwifiex_ie_types_header *tlv;\n\tstruct mwifiex_ietypes_chanstats *tlv_stat;\n\tu16 buf_left, type, len;\n\n\tstruct host_cmd_ds_command *cmd_ptr;\n\tstruct cmd_ctrl_node *cmd_node;\n\tbool complete_scan = false;\n\n\tmwifiex_dbg(adapter, INFO, \"info: EXT scan returns successfully\\n\");\n\n\text_scan_resp = &resp->params.ext_scan;\n\n\ttlv = (void *)ext_scan_resp->tlv_buffer;\n\tbuf_left = le16_to_cpu(resp->size) - (sizeof(*ext_scan_resp) + S_DS_GEN\n\t\t\t\t\t      - 1);\n\n\twhile (buf_left >= sizeof(struct mwifiex_ie_types_header)) {\n\t\ttype = le16_to_cpu(tlv->type);\n\t\tlen = le16_to_cpu(tlv->len);\n\n\t\tif (buf_left < (sizeof(struct mwifiex_ie_types_header) + len)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"error processing scan response TLVs\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase TLV_TYPE_CHANNEL_STATS:\n\t\t\ttlv_stat = (void *)tlv;\n\t\t\tmwifiex_update_chan_statistics(priv, tlv_stat);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf_left -= len + sizeof(struct mwifiex_ie_types_header);\n\t\ttlv = (void *)((u8 *)tlv + len +\n\t\t\t       sizeof(struct mwifiex_ie_types_header));\n\t}\n\n\tspin_lock_bh(&adapter->cmd_pending_q_lock);\n\tspin_lock_bh(&adapter->scan_pending_q_lock);\n\tif (list_empty(&adapter->scan_pending_q)) {\n\t\tcomplete_scan = true;\n\t\tlist_for_each_entry(cmd_node, &adapter->cmd_pending_q, list) {\n\t\t\tcmd_ptr = (void *)cmd_node->cmd_skb->data;\n\t\t\tif (le16_to_cpu(cmd_ptr->command) ==\n\t\t\t    HostCmd_CMD_802_11_SCAN_EXT) {\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"Scan pending in command pending list\");\n\t\t\t\tcomplete_scan = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n\tspin_unlock_bh(&adapter->cmd_pending_q_lock);\n\n\tif (complete_scan)\n\t\tmwifiex_complete_scan(priv);\n\n\treturn 0;\n}\n\n \nint mwifiex_handle_event_ext_scan_report(struct mwifiex_private *priv,\n\t\t\t\t\t void *buf)\n{\n\tint ret = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu8 *bss_info;\n\tu32 bytes_left, bytes_left_for_tlv, idx;\n\tu16 type, len;\n\tstruct mwifiex_ie_types_data *tlv;\n\tstruct mwifiex_ie_types_bss_scan_rsp *scan_rsp_tlv;\n\tstruct mwifiex_ie_types_bss_scan_info *scan_info_tlv;\n\tu8 *radio_type;\n\tu64 fw_tsf = 0;\n\ts32 rssi = 0;\n\tstruct mwifiex_event_scan_result *event_scan = buf;\n\tu8 num_of_set = event_scan->num_of_set;\n\tu8 *scan_resp = buf + sizeof(struct mwifiex_event_scan_result);\n\tu16 scan_resp_size = le16_to_cpu(event_scan->buf_size);\n\n\tif (num_of_set > MWIFIEX_MAX_AP) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"EXT_SCAN: Invalid number of AP returned (%d)!!\\n\",\n\t\t\t    num_of_set);\n\t\tret = -1;\n\t\tgoto check_next_scan;\n\t}\n\n\tbytes_left = scan_resp_size;\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"EXT_SCAN: size %d, returned %d APs...\",\n\t\t    scan_resp_size, num_of_set);\n\tmwifiex_dbg_dump(adapter, CMD_D, \"EXT_SCAN buffer:\", buf,\n\t\t\t scan_resp_size +\n\t\t\t sizeof(struct mwifiex_event_scan_result));\n\n\ttlv = (struct mwifiex_ie_types_data *)scan_resp;\n\n\tfor (idx = 0; idx < num_of_set && bytes_left; idx++) {\n\t\ttype = le16_to_cpu(tlv->header.type);\n\t\tlen = le16_to_cpu(tlv->header.len);\n\t\tif (bytes_left < sizeof(struct mwifiex_ie_types_header) + len) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"EXT_SCAN: Error bytes left < TLV length\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tscan_rsp_tlv = NULL;\n\t\tscan_info_tlv = NULL;\n\t\tbytes_left_for_tlv = bytes_left;\n\n\t\t \n\t\tif (type != TLV_TYPE_BSS_SCAN_RSP)\n\t\t\tbreak;\n\n\t\tbss_info = (u8 *)tlv;\n\t\tscan_rsp_tlv = (struct mwifiex_ie_types_bss_scan_rsp *)tlv;\n\t\ttlv = (struct mwifiex_ie_types_data *)(tlv->data + len);\n\t\tbytes_left_for_tlv -=\n\t\t\t\t(len + sizeof(struct mwifiex_ie_types_header));\n\n\t\twhile (bytes_left_for_tlv >=\n\t\t       sizeof(struct mwifiex_ie_types_header) &&\n\t\t       le16_to_cpu(tlv->header.type) != TLV_TYPE_BSS_SCAN_RSP) {\n\t\t\ttype = le16_to_cpu(tlv->header.type);\n\t\t\tlen = le16_to_cpu(tlv->header.len);\n\t\t\tif (bytes_left_for_tlv <\n\t\t\t    sizeof(struct mwifiex_ie_types_header) + len) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"EXT_SCAN: Error in processing TLV,\\t\"\n\t\t\t\t\t    \"bytes left < TLV length\\n\");\n\t\t\t\tscan_rsp_tlv = NULL;\n\t\t\t\tbytes_left_for_tlv = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (type) {\n\t\t\tcase TLV_TYPE_BSS_SCAN_INFO:\n\t\t\t\tscan_info_tlv =\n\t\t\t\t  (struct mwifiex_ie_types_bss_scan_info *)tlv;\n\t\t\t\tif (len !=\n\t\t\t\t sizeof(struct mwifiex_ie_types_bss_scan_info) -\n\t\t\t\t sizeof(struct mwifiex_ie_types_header)) {\n\t\t\t\t\tbytes_left_for_tlv = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttlv = (struct mwifiex_ie_types_data *)(tlv->data + len);\n\t\t\tbytes_left -=\n\t\t\t\t(len + sizeof(struct mwifiex_ie_types_header));\n\t\t\tbytes_left_for_tlv -=\n\t\t\t\t(len + sizeof(struct mwifiex_ie_types_header));\n\t\t}\n\n\t\tif (!scan_rsp_tlv)\n\t\t\tbreak;\n\n\t\t \n\t\tbss_info += sizeof(u16);\n\t\tbytes_left -= sizeof(u16);\n\n\t\tif (scan_info_tlv) {\n\t\t\trssi = (s32)(s16)(le16_to_cpu(scan_info_tlv->rssi));\n\t\t\trssi *= 100;            \n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: InterpretIE: RSSI=%d\\n\", rssi);\n\t\t\tfw_tsf = le64_to_cpu(scan_info_tlv->tsf);\n\t\t\tradio_type = &scan_info_tlv->radio_type;\n\t\t} else {\n\t\t\tradio_type = NULL;\n\t\t}\n\t\tret = mwifiex_parse_single_response_buf(priv, &bss_info,\n\t\t\t\t\t\t\t&bytes_left, fw_tsf,\n\t\t\t\t\t\t\tradio_type, true, rssi);\n\t\tif (ret)\n\t\t\tgoto check_next_scan;\n\t}\n\ncheck_next_scan:\n\tif (!event_scan->more_event)\n\t\tmwifiex_check_next_scan_command(priv);\n\n\treturn ret;\n}\n\n \nint mwifiex_cmd_802_11_bg_scan_query(struct host_cmd_ds_command *cmd)\n{\n\tstruct host_cmd_ds_802_11_bg_scan_query *bg_query =\n\t\t&cmd->params.bg_scan_query;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_QUERY);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_bg_scan_query)\n\t\t\t\t+ S_DS_GEN);\n\n\tbg_query->flush = 1;\n\n\treturn 0;\n}\n\n \nvoid\nmwifiex_queue_scan_cmd(struct mwifiex_private *priv,\n\t\t       struct cmd_ctrl_node *cmd_node)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tcmd_node->wait_q_enabled = true;\n\tcmd_node->condition = &adapter->scan_wait_q_woken;\n\tspin_lock_bh(&adapter->scan_pending_q_lock);\n\tlist_add_tail(&cmd_node->list, &adapter->scan_pending_q);\n\tspin_unlock_bh(&adapter->scan_pending_q_lock);\n}\n\n \nstatic int mwifiex_scan_specific_ssid(struct mwifiex_private *priv,\n\t\t\t\t      struct cfg80211_ssid *req_ssid)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret;\n\tstruct mwifiex_user_scan_cfg *scan_cfg;\n\n\tif (adapter->scan_processing) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"cmd: Scan already in process...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (priv->scan_block) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"cmd: Scan is blocked during association...\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tscan_cfg = kzalloc(sizeof(struct mwifiex_user_scan_cfg), GFP_KERNEL);\n\tif (!scan_cfg)\n\t\treturn -ENOMEM;\n\n\tscan_cfg->ssid_list = req_ssid;\n\tscan_cfg->num_ssids = 1;\n\n\tret = mwifiex_scan_networks(priv, scan_cfg);\n\n\tkfree(scan_cfg);\n\treturn ret;\n}\n\n \nint mwifiex_request_scan(struct mwifiex_private *priv,\n\t\t\t struct cfg80211_ssid *req_ssid)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&priv->async_mutex)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"%s: acquire semaphore fail\\n\",\n\t\t\t    __func__);\n\t\treturn -1;\n\t}\n\n\tpriv->adapter->scan_wait_q_woken = false;\n\n\tif (req_ssid && req_ssid->ssid_len != 0)\n\t\t \n\t\tret = mwifiex_scan_specific_ssid(priv, req_ssid);\n\telse\n\t\t \n\t\tret = mwifiex_scan_networks(priv, NULL);\n\n\tmutex_unlock(&priv->async_mutex);\n\n\treturn ret;\n}\n\n \nint\nmwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\n\t \n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tif (le16_to_cpu(vs_param_set->header.len) >\n\t\t\t\tMWIFIEX_MAX_VSIE_LEN) {\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"Invalid param length!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}\n\n \nvoid\nmwifiex_save_curr_bcn(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_bssdescriptor *curr_bss =\n\t\t&priv->curr_bss_params.bss_descriptor;\n\n\tif (!curr_bss->beacon_buf_size)\n\t\treturn;\n\n\t \n\tif (!priv->curr_bcn_buf ||\n\t    priv->curr_bcn_size != curr_bss->beacon_buf_size) {\n\t\tpriv->curr_bcn_size = curr_bss->beacon_buf_size;\n\n\t\tkfree(priv->curr_bcn_buf);\n\t\tpriv->curr_bcn_buf = kmalloc(curr_bss->beacon_buf_size,\n\t\t\t\t\t     GFP_ATOMIC);\n\t\tif (!priv->curr_bcn_buf)\n\t\t\treturn;\n\t}\n\n\tmemcpy(priv->curr_bcn_buf, curr_bss->beacon_buf,\n\t       curr_bss->beacon_buf_size);\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: current beacon saved %d\\n\",\n\t\t    priv->curr_bcn_size);\n\n\tcurr_bss->beacon_buf = priv->curr_bcn_buf;\n\n\t \n\tif (curr_bss->bcn_wpa_ie)\n\t\tcurr_bss->bcn_wpa_ie =\n\t\t\t(struct ieee_types_vendor_specific *)\n\t\t\t(curr_bss->beacon_buf +\n\t\t\t curr_bss->wpa_offset);\n\n\tif (curr_bss->bcn_rsn_ie)\n\t\tcurr_bss->bcn_rsn_ie = (struct ieee_types_generic *)\n\t\t\t(curr_bss->beacon_buf +\n\t\t\t curr_bss->rsn_offset);\n\n\tif (curr_bss->bcn_ht_cap)\n\t\tcurr_bss->bcn_ht_cap = (struct ieee80211_ht_cap *)\n\t\t\t(curr_bss->beacon_buf +\n\t\t\t curr_bss->ht_cap_offset);\n\n\tif (curr_bss->bcn_ht_oper)\n\t\tcurr_bss->bcn_ht_oper = (struct ieee80211_ht_operation *)\n\t\t\t(curr_bss->beacon_buf +\n\t\t\t curr_bss->ht_info_offset);\n\n\tif (curr_bss->bcn_vht_cap)\n\t\tcurr_bss->bcn_vht_cap = (void *)(curr_bss->beacon_buf +\n\t\t\t\t\t\t curr_bss->vht_cap_offset);\n\n\tif (curr_bss->bcn_vht_oper)\n\t\tcurr_bss->bcn_vht_oper = (void *)(curr_bss->beacon_buf +\n\t\t\t\t\t\t  curr_bss->vht_info_offset);\n\n\tif (curr_bss->bcn_bss_co_2040)\n\t\tcurr_bss->bcn_bss_co_2040 =\n\t\t\t(curr_bss->beacon_buf + curr_bss->bss_co_2040_offset);\n\n\tif (curr_bss->bcn_ext_cap)\n\t\tcurr_bss->bcn_ext_cap = curr_bss->beacon_buf +\n\t\t\tcurr_bss->ext_cap_offset;\n\n\tif (curr_bss->oper_mode)\n\t\tcurr_bss->oper_mode = (void *)(curr_bss->beacon_buf +\n\t\t\t\t\t       curr_bss->oper_mode_offset);\n}\n\n \nvoid\nmwifiex_free_curr_bcn(struct mwifiex_private *priv)\n{\n\tkfree(priv->curr_bcn_buf);\n\tpriv->curr_bcn_buf = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}