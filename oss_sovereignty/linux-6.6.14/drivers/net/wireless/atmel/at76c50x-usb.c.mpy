{
  "module_name": "at76c50x-usb.c",
  "hash_id": "c5b5c8f77e4f0107a726df332f7427e9934f65521f286c0d52c7ed52084b0411",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/atmel/at76c50x-usb.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/wireless.h>\n#include <net/iw_handler.h>\n#include <net/ieee80211_radiotap.h>\n#include <linux/firmware.h>\n#include <linux/leds.h>\n#include <net/mac80211.h>\n\n#include \"at76c50x-usb.h\"\n\n \n#define DRIVER_NAME \"at76c50x-usb\"\n#define DRIVER_VERSION\t\"0.17\"\n#define DRIVER_DESC \"Atmel at76x USB Wireless LAN Driver\"\n\n \n#define DBG_PROGRESS\t\t0x00000001\t \n#define DBG_BSS_TABLE\t\t0x00000002\t \n#define DBG_IOCTL\t\t0x00000004\t \n#define DBG_MAC_STATE\t\t0x00000008\t \n#define DBG_TX_DATA\t\t0x00000010\t \n#define DBG_TX_DATA_CONTENT\t0x00000020\t \n#define DBG_TX_MGMT\t\t0x00000040\t \n#define DBG_RX_DATA\t\t0x00000080\t \n#define DBG_RX_DATA_CONTENT\t0x00000100\t \n#define DBG_RX_MGMT\t\t0x00000200\t \n#define DBG_RX_BEACON\t\t0x00000400\t \n#define DBG_RX_CTRL\t\t0x00000800\t \n#define DBG_RX_MGMT_CONTENT\t0x00001000\t \n#define DBG_RX_FRAGS\t\t0x00002000\t \n#define DBG_DEVSTART\t\t0x00004000\t \n#define DBG_URB\t\t\t0x00008000\t \n#define DBG_RX_ATMEL_HDR\t0x00010000\t \n#define DBG_PROC_ENTRY\t\t0x00020000\t \n#define DBG_PM\t\t\t0x00040000\t \n#define DBG_BSS_MATCH\t\t0x00080000\t \n#define DBG_PARAMS\t\t0x00100000\t \n#define DBG_WAIT_COMPLETE\t0x00200000\t \n#define DBG_RX_FRAGS_SKB\t0x00400000\t \n#define DBG_BSS_TABLE_RM\t0x00800000\t \n#define DBG_MONITOR_MODE\t0x01000000\t \n#define DBG_MIB\t\t\t0x02000000\t \n#define DBG_MGMT_TIMER\t\t0x04000000\t \n#define DBG_WE_EVENTS\t\t0x08000000\t \n#define DBG_FW\t\t\t0x10000000\t \n#define DBG_DFU\t\t\t0x20000000\t \n#define DBG_CMD\t\t\t0x40000000\n#define DBG_MAC80211\t\t0x80000000\n\n#define DBG_DEFAULTS\t\t0\n\n \n#define at76_dbg(bits, format, arg...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (at76_debug & (bits))\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG DRIVER_NAME \": \" format \"\\n\", ##arg);\t\\\n} while (0)\n\n#define at76_dbg_dump(bits, buf, len, format, arg...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (at76_debug & (bits)) {\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG DRIVER_NAME \": \" format \"\\n\", ##arg);\t\\\n\t\tprint_hex_dump_bytes(\"\", DUMP_PREFIX_OFFSET, buf, len);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\nstatic uint at76_debug = DBG_DEFAULTS;\n\n \nstatic DEFINE_MUTEX(fw_mutex);\n\nstatic struct fwentry firmwares[] = {\n\t[0] = { \"\" },\n\t[BOARD_503_ISL3861] = { \"atmel_at76c503-i3861.bin\" },\n\t[BOARD_503_ISL3863] = { \"atmel_at76c503-i3863.bin\" },\n\t[BOARD_503] = { \"atmel_at76c503-rfmd.bin\" },\n\t[BOARD_503_ACC] = { \"atmel_at76c503-rfmd-acc.bin\" },\n\t[BOARD_505] = { \"atmel_at76c505-rfmd.bin\" },\n\t[BOARD_505_2958] = { \"atmel_at76c505-rfmd2958.bin\" },\n\t[BOARD_505A] = { \"atmel_at76c505a-rfmd2958.bin\" },\n\t[BOARD_505AMX] = { \"atmel_at76c505amx-rfmd.bin\" },\n};\nMODULE_FIRMWARE(\"atmel_at76c503-i3861.bin\");\nMODULE_FIRMWARE(\"atmel_at76c503-i3863.bin\");\nMODULE_FIRMWARE(\"atmel_at76c503-rfmd.bin\");\nMODULE_FIRMWARE(\"atmel_at76c503-rfmd-acc.bin\");\nMODULE_FIRMWARE(\"atmel_at76c505-rfmd.bin\");\nMODULE_FIRMWARE(\"atmel_at76c505-rfmd2958.bin\");\nMODULE_FIRMWARE(\"atmel_at76c505a-rfmd2958.bin\");\nMODULE_FIRMWARE(\"atmel_at76c505amx-rfmd.bin\");\n\n#define USB_DEVICE_DATA(__ops)\t.driver_info = (kernel_ulong_t)(__ops)\n\nstatic const struct usb_device_id dev_table[] = {\n\t \n\t \n\t{ USB_DEVICE(0x03eb, 0x7603), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x066b, 0x2211), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x0864, 0x4100), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x0b3b, 0x1612), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x03f0, 0x011c), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x0cde, 0x0001), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x069a, 0x0320), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x0d5c, 0xa001), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x04a5, 0x9000), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x05dd, 0xff31), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x8086, 0x0200), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x0d8e, 0x7100), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x0d8e, 0x7110), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x04bb, 0x0919), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t{ USB_DEVICE(0x069a, 0x0821), USB_DEVICE_DATA(BOARD_503_ISL3861) },\n\t \n\t \n\t{ USB_DEVICE(0x03eb, 0x7604), USB_DEVICE_DATA(BOARD_503_ISL3863) },\n\t \n\t{ USB_DEVICE(0x055d, 0xa000), USB_DEVICE_DATA(BOARD_503_ISL3863) },\n\t \n\t \n\t{ USB_DEVICE(0x03eb, 0x7605), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x069a, 0x0321), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x077b, 0x2219), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x077b, 0x2227), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x0864, 0x4102), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x2001, 0x3200), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x1668, 0x7605), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x03eb, 0x4102), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x1371, 0x5743), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x1371, 0x0001), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x1371, 0x0002), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x04a5, 0x9001), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x0506, 0x0a01), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x0681, 0x001b), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x050d, 0x0050), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x07b8, 0xb000), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x1044, 0x8003), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x2019, 0x3220), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x049f, 0x0032), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x07aa, 0x0011), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x07aa, 0x0018), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t{ USB_DEVICE(0x05dd, 0xff35), USB_DEVICE_DATA(BOARD_503) },\n\t \n\t \n\t{ USB_DEVICE(0x083a, 0x3501), USB_DEVICE_DATA(BOARD_503_ACC) },\n\t \n\t{ USB_DEVICE(0x0d5c, 0xa002), USB_DEVICE_DATA(BOARD_503_ACC) },\n\t \n\t \n\t{ USB_DEVICE(0x03eb, 0x7606), USB_DEVICE_DATA(BOARD_505) },\n\t \n\t \n\t{ USB_DEVICE(0x03eb, 0x7613), USB_DEVICE_DATA(BOARD_505_2958) },\n\t \n\t{ USB_DEVICE(0x1371, 0x0014), USB_DEVICE_DATA(BOARD_505_2958) },\n\t \n\t{ USB_DEVICE(0x1371, 0x0013), USB_DEVICE_DATA(BOARD_505_2958) },\n\t \n\t{ USB_DEVICE(0x1915, 0x2233), USB_DEVICE_DATA(BOARD_505_2958) },\n\t \n\t{ USB_DEVICE(0x12fd, 0x1001), USB_DEVICE_DATA(BOARD_505_2958) },\n\t \n\t{ USB_DEVICE(0x07aa, 0x7613), USB_DEVICE_DATA(BOARD_505_2958) },\n\t \n\t{ USB_DEVICE(0x0db0, 0x1020), USB_DEVICE_DATA(BOARD_505_2958) },\n\t \n\t \n\t{ USB_DEVICE(0x03eb, 0x7614), USB_DEVICE_DATA(BOARD_505A) },\n\t \n\t{ USB_DEVICE(0x03eb, 0x7617), USB_DEVICE_DATA(BOARD_505A) },\n\t \n\t{ USB_DEVICE(0x1690, 0x0701), USB_DEVICE_DATA(BOARD_505A) },\n\t \n\t{ USB_DEVICE(0x1557, 0x0002), USB_DEVICE_DATA(BOARD_505A) },\n\t \n\t \n\t{ USB_DEVICE(0x03eb, 0x7615), USB_DEVICE_DATA(BOARD_505AMX) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, dev_table);\n\n \nstatic const u8 hw_rates[] = { 0x82, 0x84, 0x0b, 0x16 };\n\nstatic const char *const preambles[] = { \"long\", \"short\", \"auto\" };\n\n \n \n#define STATE_IDLE\t\t\t0x00\n#define STATE_DETACH\t\t\t0x01\n#define STATE_DFU_IDLE\t\t\t0x02\n#define STATE_DFU_DOWNLOAD_SYNC\t\t0x03\n#define STATE_DFU_DOWNLOAD_BUSY\t\t0x04\n#define STATE_DFU_DOWNLOAD_IDLE\t\t0x05\n#define STATE_DFU_MANIFEST_SYNC\t\t0x06\n#define STATE_DFU_MANIFEST\t\t0x07\n#define STATE_DFU_MANIFEST_WAIT_RESET\t0x08\n#define STATE_DFU_UPLOAD_IDLE\t\t0x09\n#define STATE_DFU_ERROR\t\t\t0x0a\n\n \n#define DFU_DETACH\t\t\t0\n#define DFU_DNLOAD\t\t\t1\n#define DFU_UPLOAD\t\t\t2\n#define DFU_GETSTATUS\t\t\t3\n#define DFU_CLRSTATUS\t\t\t4\n#define DFU_GETSTATE\t\t\t5\n#define DFU_ABORT\t\t\t6\n\n#define FW_BLOCK_SIZE 1024\n\nstruct dfu_status {\n\tunsigned char status;\n\tunsigned char poll_timeout[3];\n\tunsigned char state;\n\tunsigned char string;\n} __packed;\n\nstatic inline int at76_is_intersil(enum board_type board)\n{\n\treturn (board == BOARD_503_ISL3861 || board == BOARD_503_ISL3863);\n}\n\nstatic inline int at76_is_503rfmd(enum board_type board)\n{\n\treturn (board == BOARD_503 || board == BOARD_503_ACC);\n}\n\nstatic inline int at76_is_505a(enum board_type board)\n{\n\treturn (board == BOARD_505A || board == BOARD_505AMX);\n}\n\n \nstatic int at76_load_int_fw_block(struct usb_device *udev, int blockno,\n\t\t\t\t  void *block, int size)\n{\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0), DFU_DNLOAD,\n\t\t\t       USB_TYPE_CLASS | USB_DIR_OUT |\n\t\t\t       USB_RECIP_INTERFACE, blockno, 0, block, size,\n\t\t\t       USB_CTRL_GET_TIMEOUT);\n}\n\nstatic int at76_dfu_get_status(struct usb_device *udev,\n\t\t\t       struct dfu_status *status)\n{\n\tint ret;\n\n\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), DFU_GETSTATUS,\n\t\t\t      USB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,\n\t\t\t      0, 0, status, sizeof(struct dfu_status),\n\t\t\t      USB_CTRL_GET_TIMEOUT);\n\treturn ret;\n}\n\nstatic int at76_dfu_get_state(struct usb_device *udev, u8 *state)\n{\n\tint ret;\n\n\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), DFU_GETSTATE,\n\t\t\t      USB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,\n\t\t\t      0, 0, state, 1, USB_CTRL_GET_TIMEOUT);\n\treturn ret;\n}\n\n \nstatic inline unsigned long at76_get_timeout(struct dfu_status *s)\n{\n\treturn msecs_to_jiffies((s->poll_timeout[2] << 16)\n\t\t\t\t| (s->poll_timeout[1] << 8)\n\t\t\t\t| (s->poll_timeout[0]));\n}\n\n \nstatic int at76_usbdfu_download(struct usb_device *udev, u8 *buf, u32 size,\n\t\t\t\tint manifest_sync_timeout)\n{\n\tint ret = 0;\n\tint need_dfu_state = 1;\n\tint is_done = 0;\n\tu32 dfu_timeout = 0;\n\tint bsize = 0;\n\tint blockno = 0;\n\tstruct dfu_status *dfu_stat_buf = NULL;\n\tu8 *dfu_state = NULL;\n\tu8 *block = NULL;\n\n\tat76_dbg(DBG_DFU, \"%s( %p, %u, %d)\", __func__, buf, size,\n\t\t manifest_sync_timeout);\n\n\tif (!size) {\n\t\tdev_err(&udev->dev, \"FW buffer length invalid!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdfu_stat_buf = kmalloc(sizeof(struct dfu_status), GFP_KERNEL);\n\tif (!dfu_stat_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tblock = kmalloc(FW_BLOCK_SIZE, GFP_KERNEL);\n\tif (!block) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tdfu_state = kmalloc(sizeof(u8), GFP_KERNEL);\n\tif (!dfu_state) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\t*dfu_state = 0;\n\n\tdo {\n\t\tif (need_dfu_state) {\n\t\t\tret = at76_dfu_get_state(udev, dfu_state);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"cannot get DFU state: %d\\n\", ret);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tneed_dfu_state = 0;\n\t\t}\n\n\t\tswitch (*dfu_state) {\n\t\tcase STATE_DFU_DOWNLOAD_SYNC:\n\t\t\tat76_dbg(DBG_DFU, \"STATE_DFU_DOWNLOAD_SYNC\");\n\t\t\tret = at76_dfu_get_status(udev, dfu_stat_buf);\n\t\t\tif (ret >= 0) {\n\t\t\t\t*dfu_state = dfu_stat_buf->state;\n\t\t\t\tdfu_timeout = at76_get_timeout(dfu_stat_buf);\n\t\t\t\tneed_dfu_state = 0;\n\t\t\t} else\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"at76_dfu_get_status returned %d\\n\",\n\t\t\t\t\tret);\n\t\t\tbreak;\n\n\t\tcase STATE_DFU_DOWNLOAD_BUSY:\n\t\t\tat76_dbg(DBG_DFU, \"STATE_DFU_DOWNLOAD_BUSY\");\n\t\t\tneed_dfu_state = 1;\n\n\t\t\tat76_dbg(DBG_DFU, \"DFU: Resetting device\");\n\t\t\tschedule_timeout_interruptible(dfu_timeout);\n\t\t\tbreak;\n\n\t\tcase STATE_DFU_DOWNLOAD_IDLE:\n\t\t\tat76_dbg(DBG_DFU, \"DOWNLOAD...\");\n\t\t\tfallthrough;\n\t\tcase STATE_DFU_IDLE:\n\t\t\tat76_dbg(DBG_DFU, \"DFU IDLE\");\n\n\t\t\tbsize = min_t(int, size, FW_BLOCK_SIZE);\n\t\t\tmemcpy(block, buf, bsize);\n\t\t\tat76_dbg(DBG_DFU, \"int fw, size left = %5d, \"\n\t\t\t\t \"bsize = %4d, blockno = %2d\", size, bsize,\n\t\t\t\t blockno);\n\t\t\tret =\n\t\t\t    at76_load_int_fw_block(udev, blockno, block, bsize);\n\t\t\tbuf += bsize;\n\t\t\tsize -= bsize;\n\t\t\tblockno++;\n\n\t\t\tif (ret != bsize)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"at76_load_int_fw_block returned %d\\n\",\n\t\t\t\t\tret);\n\t\t\tneed_dfu_state = 1;\n\t\t\tbreak;\n\n\t\tcase STATE_DFU_MANIFEST_SYNC:\n\t\t\tat76_dbg(DBG_DFU, \"STATE_DFU_MANIFEST_SYNC\");\n\n\t\t\tret = at76_dfu_get_status(udev, dfu_stat_buf);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\t*dfu_state = dfu_stat_buf->state;\n\t\t\tdfu_timeout = at76_get_timeout(dfu_stat_buf);\n\t\t\tneed_dfu_state = 0;\n\n\t\t\t \n\t\t\tif (manifest_sync_timeout > 0)\n\t\t\t\tdfu_timeout = manifest_sync_timeout;\n\n\t\t\tat76_dbg(DBG_DFU, \"DFU: Waiting for manifest phase\");\n\t\t\tschedule_timeout_interruptible(dfu_timeout);\n\t\t\tbreak;\n\n\t\tcase STATE_DFU_MANIFEST:\n\t\t\tat76_dbg(DBG_DFU, \"STATE_DFU_MANIFEST\");\n\t\t\tis_done = 1;\n\t\t\tbreak;\n\n\t\tcase STATE_DFU_MANIFEST_WAIT_RESET:\n\t\t\tat76_dbg(DBG_DFU, \"STATE_DFU_MANIFEST_WAIT_RESET\");\n\t\t\tis_done = 1;\n\t\t\tbreak;\n\n\t\tcase STATE_DFU_UPLOAD_IDLE:\n\t\t\tat76_dbg(DBG_DFU, \"STATE_DFU_UPLOAD_IDLE\");\n\t\t\tbreak;\n\n\t\tcase STATE_DFU_ERROR:\n\t\t\tat76_dbg(DBG_DFU, \"STATE_DFU_ERROR\");\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tat76_dbg(DBG_DFU, \"DFU UNKNOWN STATE (%d)\", *dfu_state);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t} while (!is_done && (ret >= 0));\n\nexit:\n\tkfree(dfu_state);\n\tkfree(block);\n\tkfree(dfu_stat_buf);\n\n\tif (ret >= 0)\n\t\tret = 0;\n\n\treturn ret;\n}\n\n \nstatic int tx_activity;\nstatic void at76_ledtrig_tx_timerfunc(struct timer_list *unused);\nstatic DEFINE_TIMER(ledtrig_tx_timer, at76_ledtrig_tx_timerfunc);\nDEFINE_LED_TRIGGER(ledtrig_tx);\n\nstatic void at76_ledtrig_tx_timerfunc(struct timer_list *unused)\n{\n\tstatic int tx_lastactivity;\n\n\tif (tx_lastactivity != tx_activity) {\n\t\ttx_lastactivity = tx_activity;\n\t\tled_trigger_event(ledtrig_tx, LED_FULL);\n\t\tmod_timer(&ledtrig_tx_timer, jiffies + HZ / 4);\n\t} else\n\t\tled_trigger_event(ledtrig_tx, LED_OFF);\n}\n\nstatic void at76_ledtrig_tx_activity(void)\n{\n\ttx_activity++;\n\tif (!timer_pending(&ledtrig_tx_timer))\n\t\tmod_timer(&ledtrig_tx_timer, jiffies + HZ / 4);\n}\n\nstatic int at76_remap(struct usb_device *udev)\n{\n\tint ret;\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x0a,\n\t\t\t      USB_TYPE_VENDOR | USB_DIR_OUT |\n\t\t\t      USB_RECIP_INTERFACE, 0, 0, NULL, 0,\n\t\t\t      USB_CTRL_GET_TIMEOUT);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int at76_get_op_mode(struct usb_device *udev)\n{\n\tint ret;\n\tu8 saved;\n\tu8 *op_mode;\n\n\top_mode = kmalloc(1, GFP_NOIO);\n\tif (!op_mode)\n\t\treturn -ENOMEM;\n\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x33,\n\t\t\t      USB_TYPE_VENDOR | USB_DIR_IN |\n\t\t\t      USB_RECIP_INTERFACE, 0x01, 0, op_mode, 1,\n\t\t\t      USB_CTRL_GET_TIMEOUT);\n\tsaved = *op_mode;\n\tkfree(op_mode);\n\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret < 1)\n\t\treturn -EIO;\n\telse\n\t\treturn saved;\n}\n\n \nstatic inline int at76_load_ext_fw_block(struct usb_device *udev, int blockno,\n\t\t\t\t\t void *block, int size)\n{\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x0e,\n\t\t\t       USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\n\t\t\t       0x0802, blockno, block, size,\n\t\t\t       USB_CTRL_GET_TIMEOUT);\n}\n\nstatic inline int at76_get_hw_cfg(struct usb_device *udev,\n\t\t\t\t  union at76_hwcfg *buf, int buf_size)\n{\n\treturn usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x33,\n\t\t\t       USB_TYPE_VENDOR | USB_DIR_IN |\n\t\t\t       USB_RECIP_INTERFACE, 0x0a02, 0,\n\t\t\t       buf, buf_size, USB_CTRL_GET_TIMEOUT);\n}\n\n \nstatic inline int at76_get_hw_cfg_intersil(struct usb_device *udev,\n\t\t\t\t\t   union at76_hwcfg *buf, int buf_size)\n{\n\treturn usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x33,\n\t\t\t       USB_TYPE_VENDOR | USB_DIR_IN |\n\t\t\t       USB_RECIP_INTERFACE, 0x0902, 0,\n\t\t\t       buf, buf_size, USB_CTRL_GET_TIMEOUT);\n}\n\n \nstatic int at76_get_hw_config(struct at76_priv *priv)\n{\n\tint ret;\n\tunion at76_hwcfg *hwcfg = kmalloc(sizeof(*hwcfg), GFP_KERNEL);\n\n\tif (!hwcfg)\n\t\treturn -ENOMEM;\n\n\tif (at76_is_intersil(priv->board_type)) {\n\t\tret = at76_get_hw_cfg_intersil(priv->udev, hwcfg,\n\t\t\t\t\t       sizeof(hwcfg->i));\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t\tmemcpy(priv->mac_addr, hwcfg->i.mac_addr, ETH_ALEN);\n\t\tpriv->regulatory_domain = hwcfg->i.regulatory_domain;\n\t} else if (at76_is_503rfmd(priv->board_type)) {\n\t\tret = at76_get_hw_cfg(priv->udev, hwcfg, sizeof(hwcfg->r3));\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t\tmemcpy(priv->mac_addr, hwcfg->r3.mac_addr, ETH_ALEN);\n\t\tpriv->regulatory_domain = hwcfg->r3.regulatory_domain;\n\t} else {\n\t\tret = at76_get_hw_cfg(priv->udev, hwcfg, sizeof(hwcfg->r5));\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t\tmemcpy(priv->mac_addr, hwcfg->r5.mac_addr, ETH_ALEN);\n\t\tpriv->regulatory_domain = hwcfg->r5.regulatory_domain;\n\t}\n\nexit:\n\tkfree(hwcfg);\n\tif (ret < 0)\n\t\twiphy_err(priv->hw->wiphy, \"cannot get HW Config (error %d)\\n\",\n\t\t\t  ret);\n\n\treturn ret;\n}\n\nstatic struct reg_domain const *at76_get_reg_domain(u16 code)\n{\n\tint i;\n\tstatic struct reg_domain const fd_tab[] = {\n\t\t{ 0x10, \"FCC (USA)\", 0x7ff },\t \n\t\t{ 0x20, \"IC (Canada)\", 0x7ff },\t \n\t\t{ 0x30, \"ETSI (most of Europe)\", 0x1fff },\t \n\t\t{ 0x31, \"Spain\", 0x600 },\t \n\t\t{ 0x32, \"France\", 0x1e00 },\t \n\t\t{ 0x40, \"MKK (Japan)\", 0x2000 },\t \n\t\t{ 0x41, \"MKK1 (Japan)\", 0x3fff },\t \n\t\t{ 0x50, \"Israel\", 0x3fc },\t \n\t\t{ 0x00, \"<unknown>\", 0xffffffff }\t \n\t};\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fd_tab) - 1; i++)\n\t\tif (code == fd_tab[i].code)\n\t\t\tbreak;\n\n\treturn &fd_tab[i];\n}\n\nstatic inline int at76_get_mib(struct usb_device *udev, u16 mib, void *buf,\n\t\t\t       int buf_size)\n{\n\tint ret;\n\n\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x33,\n\t\t\t      USB_TYPE_VENDOR | USB_DIR_IN |\n\t\t\t      USB_RECIP_INTERFACE, mib << 8, 0, buf, buf_size,\n\t\t\t      USB_CTRL_GET_TIMEOUT);\n\tif (ret >= 0 && ret != buf_size)\n\t\treturn -EIO;\n\treturn ret;\n}\n\n \nstatic inline int at76_get_cmd_status(struct usb_device *udev, u8 cmd)\n{\n\tu8 *stat_buf;\n\tint ret;\n\n\tstat_buf = kmalloc(40, GFP_NOIO);\n\tif (!stat_buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x22,\n\t\t\tUSB_TYPE_VENDOR | USB_DIR_IN |\n\t\t\tUSB_RECIP_INTERFACE, cmd, 0, stat_buf,\n\t\t\t40, USB_CTRL_GET_TIMEOUT);\n\tif (ret >= 0)\n\t\tret = stat_buf[5];\n\tkfree(stat_buf);\n\n\treturn ret;\n}\n\n#define MAKE_CMD_CASE(c) case (c): return #c\nstatic const char *at76_get_cmd_string(u8 cmd_status)\n{\n\tswitch (cmd_status) {\n\t\tMAKE_CMD_CASE(CMD_SET_MIB);\n\t\tMAKE_CMD_CASE(CMD_GET_MIB);\n\t\tMAKE_CMD_CASE(CMD_SCAN);\n\t\tMAKE_CMD_CASE(CMD_JOIN);\n\t\tMAKE_CMD_CASE(CMD_START_IBSS);\n\t\tMAKE_CMD_CASE(CMD_RADIO_ON);\n\t\tMAKE_CMD_CASE(CMD_RADIO_OFF);\n\t\tMAKE_CMD_CASE(CMD_STARTUP);\n\t}\n\n\treturn \"UNKNOWN\";\n}\n\nstatic int at76_set_card_command(struct usb_device *udev, u8 cmd, void *buf,\n\t\t\t\t int buf_size)\n{\n\tint ret;\n\tstruct at76_command *cmd_buf = kmalloc(sizeof(struct at76_command) +\n\t\t\t\t\t       buf_size, GFP_KERNEL);\n\n\tif (!cmd_buf)\n\t\treturn -ENOMEM;\n\n\tcmd_buf->cmd = cmd;\n\tcmd_buf->reserved = 0;\n\tcmd_buf->size = cpu_to_le16(buf_size);\n\tmemcpy(cmd_buf->data, buf, buf_size);\n\n\tat76_dbg_dump(DBG_CMD, cmd_buf, sizeof(struct at76_command) + buf_size,\n\t\t      \"issuing command %s (0x%02x)\",\n\t\t      at76_get_cmd_string(cmd), cmd);\n\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x0e,\n\t\t\t      USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\n\t\t\t      0, 0, cmd_buf,\n\t\t\t      sizeof(struct at76_command) + buf_size,\n\t\t\t      USB_CTRL_GET_TIMEOUT);\n\tkfree(cmd_buf);\n\treturn ret;\n}\n\n#define MAKE_CMD_STATUS_CASE(c)\tcase (c): return #c\nstatic const char *at76_get_cmd_status_string(u8 cmd_status)\n{\n\tswitch (cmd_status) {\n\t\tMAKE_CMD_STATUS_CASE(CMD_STATUS_IDLE);\n\t\tMAKE_CMD_STATUS_CASE(CMD_STATUS_COMPLETE);\n\t\tMAKE_CMD_STATUS_CASE(CMD_STATUS_UNKNOWN);\n\t\tMAKE_CMD_STATUS_CASE(CMD_STATUS_INVALID_PARAMETER);\n\t\tMAKE_CMD_STATUS_CASE(CMD_STATUS_FUNCTION_NOT_SUPPORTED);\n\t\tMAKE_CMD_STATUS_CASE(CMD_STATUS_TIME_OUT);\n\t\tMAKE_CMD_STATUS_CASE(CMD_STATUS_IN_PROGRESS);\n\t\tMAKE_CMD_STATUS_CASE(CMD_STATUS_HOST_FAILURE);\n\t\tMAKE_CMD_STATUS_CASE(CMD_STATUS_SCAN_FAILED);\n\t}\n\n\treturn \"UNKNOWN\";\n}\n\n \nstatic int at76_wait_completion(struct at76_priv *priv, int cmd)\n{\n\tint status = 0;\n\tunsigned long timeout = jiffies + CMD_COMPLETION_TIMEOUT;\n\n\tdo {\n\t\tstatus = at76_get_cmd_status(priv->udev, cmd);\n\t\tif (status < 0) {\n\t\t\twiphy_err(priv->hw->wiphy,\n\t\t\t\t  \"at76_get_cmd_status failed: %d\\n\",\n\t\t\t\t  status);\n\t\t\tbreak;\n\t\t}\n\n\t\tat76_dbg(DBG_WAIT_COMPLETE,\n\t\t\t \"%s: Waiting on cmd %d, status = %d (%s)\",\n\t\t\t wiphy_name(priv->hw->wiphy), cmd, status,\n\t\t\t at76_get_cmd_status_string(status));\n\n\t\tif (status != CMD_STATUS_IN_PROGRESS\n\t\t    && status != CMD_STATUS_IDLE)\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(HZ / 10);\t \n\t\tif (time_after(jiffies, timeout)) {\n\t\t\twiphy_err(priv->hw->wiphy,\n\t\t\t\t  \"completion timeout for command %d\\n\", cmd);\n\t\t\tstatus = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\treturn status;\n}\n\nstatic int at76_set_mib(struct at76_priv *priv, struct set_mib_buffer *buf)\n{\n\tint ret;\n\n\tret = at76_set_card_command(priv->udev, CMD_SET_MIB, buf,\n\t\t\t\t    offsetof(struct set_mib_buffer,\n\t\t\t\t\t     data) + buf->size);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = at76_wait_completion(priv, CMD_SET_MIB);\n\tif (ret != CMD_STATUS_COMPLETE) {\n\t\twiphy_info(priv->hw->wiphy,\n\t\t\t   \"set_mib: at76_wait_completion failed with %d\\n\",\n\t\t\t   ret);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int at76_set_radio(struct at76_priv *priv, int enable)\n{\n\tint ret;\n\tint cmd;\n\n\tif (priv->radio_on == enable)\n\t\treturn 0;\n\n\tcmd = enable ? CMD_RADIO_ON : CMD_RADIO_OFF;\n\n\tret = at76_set_card_command(priv->udev, cmd, NULL, 0);\n\tif (ret < 0)\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"at76_set_card_command(%d) failed: %d\\n\", cmd, ret);\n\telse\n\t\tret = 1;\n\n\tpriv->radio_on = enable;\n\treturn ret;\n}\n\n \nstatic int at76_set_pm_mode(struct at76_priv *priv)\n{\n\tint ret = 0;\n\n\tpriv->mib_buf.type = MIB_MAC_MGMT;\n\tpriv->mib_buf.size = 1;\n\tpriv->mib_buf.index = offsetof(struct mib_mac_mgmt, power_mgmt_mode);\n\tpriv->mib_buf.data.byte = priv->pm_mode;\n\n\tret = at76_set_mib(priv, &priv->mib_buf);\n\tif (ret < 0)\n\t\twiphy_err(priv->hw->wiphy, \"set_mib (pm_mode) failed: %d\\n\",\n\t\t\t  ret);\n\n\treturn ret;\n}\n\nstatic int at76_set_preamble(struct at76_priv *priv, u8 type)\n{\n\tint ret = 0;\n\n\tpriv->mib_buf.type = MIB_LOCAL;\n\tpriv->mib_buf.size = 1;\n\tpriv->mib_buf.index = offsetof(struct mib_local, preamble_type);\n\tpriv->mib_buf.data.byte = type;\n\n\tret = at76_set_mib(priv, &priv->mib_buf);\n\tif (ret < 0)\n\t\twiphy_err(priv->hw->wiphy, \"set_mib (preamble) failed: %d\\n\",\n\t\t\t  ret);\n\n\treturn ret;\n}\n\nstatic int at76_set_frag(struct at76_priv *priv, u16 size)\n{\n\tint ret = 0;\n\n\tpriv->mib_buf.type = MIB_MAC;\n\tpriv->mib_buf.size = 2;\n\tpriv->mib_buf.index = offsetof(struct mib_mac, frag_threshold);\n\tpriv->mib_buf.data.word = cpu_to_le16(size);\n\n\tret = at76_set_mib(priv, &priv->mib_buf);\n\tif (ret < 0)\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"set_mib (frag threshold) failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int at76_set_rts(struct at76_priv *priv, u16 size)\n{\n\tint ret = 0;\n\n\tpriv->mib_buf.type = MIB_MAC;\n\tpriv->mib_buf.size = 2;\n\tpriv->mib_buf.index = offsetof(struct mib_mac, rts_threshold);\n\tpriv->mib_buf.data.word = cpu_to_le16(size);\n\n\tret = at76_set_mib(priv, &priv->mib_buf);\n\tif (ret < 0)\n\t\twiphy_err(priv->hw->wiphy, \"set_mib (rts) failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int at76_set_autorate_fallback(struct at76_priv *priv, int onoff)\n{\n\tint ret = 0;\n\n\tpriv->mib_buf.type = MIB_LOCAL;\n\tpriv->mib_buf.size = 1;\n\tpriv->mib_buf.index = offsetof(struct mib_local, txautorate_fallback);\n\tpriv->mib_buf.data.byte = onoff;\n\n\tret = at76_set_mib(priv, &priv->mib_buf);\n\tif (ret < 0)\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"set_mib (autorate fallback) failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void at76_dump_mib_mac_addr(struct at76_priv *priv)\n{\n\tint i;\n\tint ret;\n\tstruct mib_mac_addr *m = kmalloc(sizeof(struct mib_mac_addr),\n\t\t\t\t\t GFP_KERNEL);\n\n\tif (!m)\n\t\treturn;\n\n\tret = at76_get_mib(priv->udev, MIB_MAC_ADDR, m,\n\t\t\t   sizeof(struct mib_mac_addr));\n\tif (ret < 0) {\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"at76_get_mib (MAC_ADDR) failed: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tat76_dbg(DBG_MIB, \"%s: MIB MAC_ADDR: mac_addr %pM res 0x%x 0x%x\",\n\t\t wiphy_name(priv->hw->wiphy),\n\t\t m->mac_addr, m->res[0], m->res[1]);\n\tfor (i = 0; i < ARRAY_SIZE(m->group_addr); i++)\n\t\tat76_dbg(DBG_MIB, \"%s: MIB MAC_ADDR: group addr %d: %pM, \"\n\t\t\t \"status %d\", wiphy_name(priv->hw->wiphy), i,\n\t\t\t m->group_addr[i], m->group_addr_status[i]);\nexit:\n\tkfree(m);\n}\n\nstatic void at76_dump_mib_mac_wep(struct at76_priv *priv)\n{\n\tint i;\n\tint ret;\n\tint key_len;\n\tstruct mib_mac_wep *m = kmalloc(sizeof(struct mib_mac_wep), GFP_KERNEL);\n\n\tif (!m)\n\t\treturn;\n\n\tret = at76_get_mib(priv->udev, MIB_MAC_WEP, m,\n\t\t\t   sizeof(struct mib_mac_wep));\n\tif (ret < 0) {\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"at76_get_mib (MAC_WEP) failed: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tat76_dbg(DBG_MIB, \"%s: MIB MAC_WEP: priv_invoked %u def_key_id %u \"\n\t\t \"key_len %u excl_unencr %u wep_icv_err %u wep_excluded %u \"\n\t\t \"encr_level %u key %d\", wiphy_name(priv->hw->wiphy),\n\t\t m->privacy_invoked, m->wep_default_key_id,\n\t\t m->wep_key_mapping_len, m->exclude_unencrypted,\n\t\t le32_to_cpu(m->wep_icv_error_count),\n\t\t le32_to_cpu(m->wep_excluded_count), m->encryption_level,\n\t\t m->wep_default_key_id);\n\n\tkey_len = (m->encryption_level == 1) ?\n\t    WEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN;\n\n\tfor (i = 0; i < WEP_KEYS; i++)\n\t\tat76_dbg(DBG_MIB, \"%s: MIB MAC_WEP: key %d: %*phD\",\n\t\t\t wiphy_name(priv->hw->wiphy), i,\n\t\t\t key_len, m->wep_default_keyvalue[i]);\nexit:\n\tkfree(m);\n}\n\nstatic void at76_dump_mib_mac_mgmt(struct at76_priv *priv)\n{\n\tint ret;\n\tstruct mib_mac_mgmt *m = kmalloc(sizeof(struct mib_mac_mgmt),\n\t\t\t\t\t GFP_KERNEL);\n\n\tif (!m)\n\t\treturn;\n\n\tret = at76_get_mib(priv->udev, MIB_MAC_MGMT, m,\n\t\t\t   sizeof(struct mib_mac_mgmt));\n\tif (ret < 0) {\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"at76_get_mib (MAC_MGMT) failed: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tat76_dbg(DBG_MIB, \"%s: MIB MAC_MGMT: beacon_period %d CFP_max_duration \"\n\t\t \"%d medium_occupancy_limit %d station_id 0x%x ATIM_window %d \"\n\t\t \"CFP_mode %d privacy_opt_impl %d DTIM_period %d CFP_period %d \"\n\t\t \"current_bssid %pM current_essid %*phD current_bss_type %d \"\n\t\t \"pm_mode %d ibss_change %d res %d \"\n\t\t \"multi_domain_capability_implemented %d \"\n\t\t \"international_roaming %d country_string %.3s\",\n\t\t wiphy_name(priv->hw->wiphy), le16_to_cpu(m->beacon_period),\n\t\t le16_to_cpu(m->CFP_max_duration),\n\t\t le16_to_cpu(m->medium_occupancy_limit),\n\t\t le16_to_cpu(m->station_id), le16_to_cpu(m->ATIM_window),\n\t\t m->CFP_mode, m->privacy_option_implemented, m->DTIM_period,\n\t\t m->CFP_period, m->current_bssid,\n\t\t IW_ESSID_MAX_SIZE, m->current_essid,\n\t\t m->current_bss_type, m->power_mgmt_mode, m->ibss_change,\n\t\t m->res, m->multi_domain_capability_implemented,\n\t\t m->multi_domain_capability_enabled, m->country_string);\nexit:\n\tkfree(m);\n}\n\nstatic void at76_dump_mib_mac(struct at76_priv *priv)\n{\n\tint ret;\n\tstruct mib_mac *m = kmalloc(sizeof(struct mib_mac), GFP_KERNEL);\n\n\tif (!m)\n\t\treturn;\n\n\tret = at76_get_mib(priv->udev, MIB_MAC, m, sizeof(struct mib_mac));\n\tif (ret < 0) {\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"at76_get_mib (MAC) failed: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tat76_dbg(DBG_MIB, \"%s: MIB MAC: max_tx_msdu_lifetime %d \"\n\t\t \"max_rx_lifetime %d frag_threshold %d rts_threshold %d \"\n\t\t \"cwmin %d cwmax %d short_retry_time %d long_retry_time %d \"\n\t\t \"scan_type %d scan_channel %d probe_delay %u \"\n\t\t \"min_channel_time %d max_channel_time %d listen_int %d \"\n\t\t \"desired_ssid %*phD desired_bssid %pM desired_bsstype %d\",\n\t\t wiphy_name(priv->hw->wiphy),\n\t\t le32_to_cpu(m->max_tx_msdu_lifetime),\n\t\t le32_to_cpu(m->max_rx_lifetime),\n\t\t le16_to_cpu(m->frag_threshold), le16_to_cpu(m->rts_threshold),\n\t\t le16_to_cpu(m->cwmin), le16_to_cpu(m->cwmax),\n\t\t m->short_retry_time, m->long_retry_time, m->scan_type,\n\t\t m->scan_channel, le16_to_cpu(m->probe_delay),\n\t\t le16_to_cpu(m->min_channel_time),\n\t\t le16_to_cpu(m->max_channel_time),\n\t\t le16_to_cpu(m->listen_interval),\n\t\t IW_ESSID_MAX_SIZE, m->desired_ssid,\n\t\t m->desired_bssid, m->desired_bsstype);\nexit:\n\tkfree(m);\n}\n\nstatic void at76_dump_mib_phy(struct at76_priv *priv)\n{\n\tint ret;\n\tstruct mib_phy *m = kmalloc(sizeof(struct mib_phy), GFP_KERNEL);\n\n\tif (!m)\n\t\treturn;\n\n\tret = at76_get_mib(priv->udev, MIB_PHY, m, sizeof(struct mib_phy));\n\tif (ret < 0) {\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"at76_get_mib (PHY) failed: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tat76_dbg(DBG_MIB, \"%s: MIB PHY: ed_threshold %d slot_time %d \"\n\t\t \"sifs_time %d preamble_length %d plcp_header_length %d \"\n\t\t \"mpdu_max_length %d cca_mode_supported %d operation_rate_set \"\n\t\t \"0x%x 0x%x 0x%x 0x%x channel_id %d current_cca_mode %d \"\n\t\t \"phy_type %d current_reg_domain %d\",\n\t\t wiphy_name(priv->hw->wiphy), le32_to_cpu(m->ed_threshold),\n\t\t le16_to_cpu(m->slot_time), le16_to_cpu(m->sifs_time),\n\t\t le16_to_cpu(m->preamble_length),\n\t\t le16_to_cpu(m->plcp_header_length),\n\t\t le16_to_cpu(m->mpdu_max_length),\n\t\t le16_to_cpu(m->cca_mode_supported), m->operation_rate_set[0],\n\t\t m->operation_rate_set[1], m->operation_rate_set[2],\n\t\t m->operation_rate_set[3], m->channel_id, m->current_cca_mode,\n\t\t m->phy_type, m->current_reg_domain);\nexit:\n\tkfree(m);\n}\n\nstatic void at76_dump_mib_local(struct at76_priv *priv)\n{\n\tint ret;\n\tstruct mib_local *m = kmalloc(sizeof(*m), GFP_KERNEL);\n\n\tif (!m)\n\t\treturn;\n\n\tret = at76_get_mib(priv->udev, MIB_LOCAL, m, sizeof(*m));\n\tif (ret < 0) {\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"at76_get_mib (LOCAL) failed: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tat76_dbg(DBG_MIB, \"%s: MIB LOCAL: beacon_enable %d \"\n\t\t \"txautorate_fallback %d ssid_size %d promiscuous_mode %d \"\n\t\t \"preamble_type %d\", wiphy_name(priv->hw->wiphy),\n\t\t m->beacon_enable,\n\t\t m->txautorate_fallback, m->ssid_size, m->promiscuous_mode,\n\t\t m->preamble_type);\nexit:\n\tkfree(m);\n}\n\nstatic void at76_dump_mib_mdomain(struct at76_priv *priv)\n{\n\tint ret;\n\tstruct mib_mdomain *m = kmalloc(sizeof(struct mib_mdomain), GFP_KERNEL);\n\n\tif (!m)\n\t\treturn;\n\n\tret = at76_get_mib(priv->udev, MIB_MDOMAIN, m,\n\t\t\t   sizeof(struct mib_mdomain));\n\tif (ret < 0) {\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"at76_get_mib (MDOMAIN) failed: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tat76_dbg(DBG_MIB, \"%s: MIB MDOMAIN: channel_list %*phD\",\n\t\t wiphy_name(priv->hw->wiphy),\n\t\t (int)sizeof(m->channel_list), m->channel_list);\n\n\tat76_dbg(DBG_MIB, \"%s: MIB MDOMAIN: tx_powerlevel %*phD\",\n\t\t wiphy_name(priv->hw->wiphy),\n\t\t (int)sizeof(m->tx_powerlevel), m->tx_powerlevel);\nexit:\n\tkfree(m);\n}\n\n \nstatic int at76_start_monitor(struct at76_priv *priv)\n{\n\tstruct at76_req_scan scan;\n\tint ret;\n\n\tmemset(&scan, 0, sizeof(struct at76_req_scan));\n\teth_broadcast_addr(scan.bssid);\n\n\tscan.channel = priv->channel;\n\tscan.scan_type = SCAN_TYPE_PASSIVE;\n\tscan.international_scan = 0;\n\tscan.min_channel_time = cpu_to_le16(priv->scan_min_time);\n\tscan.max_channel_time = cpu_to_le16(priv->scan_max_time);\n\tscan.probe_delay = cpu_to_le16(0);\n\n\tret = at76_set_card_command(priv->udev, CMD_SCAN, &scan, sizeof(scan));\n\tif (ret >= 0)\n\t\tret = at76_get_cmd_status(priv->udev, CMD_SCAN);\n\n\treturn ret;\n}\n\n \nstatic inline int at76_calc_padding(int wlen)\n{\n\t \n\twlen += AT76_TX_HDRLEN;\n\n\twlen = wlen % 64;\n\n\tif (wlen < 50)\n\t\treturn 50 - wlen;\n\n\tif (wlen >= 61)\n\t\treturn 64 + 50 - wlen;\n\n\treturn 0;\n}\n\nstatic void at76_rx_callback(struct urb *urb)\n{\n\tstruct at76_priv *priv = urb->context;\n\n\ttasklet_schedule(&priv->rx_tasklet);\n}\n\nstatic int at76_submit_rx_urb(struct at76_priv *priv)\n{\n\tint ret;\n\tint size;\n\tstruct sk_buff *skb = priv->rx_skb;\n\n\tif (!priv->rx_urb) {\n\t\twiphy_err(priv->hw->wiphy, \"%s: priv->rx_urb is NULL\\n\",\n\t\t\t  __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tif (!skb) {\n\t\tskb = dev_alloc_skb(sizeof(struct at76_rx_buffer));\n\t\tif (!skb) {\n\t\t\twiphy_err(priv->hw->wiphy,\n\t\t\t\t  \"cannot allocate rx skbuff\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\tpriv->rx_skb = skb;\n\t} else {\n\t\tskb_push(skb, skb_headroom(skb));\n\t\tskb_trim(skb, 0);\n\t}\n\n\tsize = skb_tailroom(skb);\n\tusb_fill_bulk_urb(priv->rx_urb, priv->udev, priv->rx_pipe,\n\t\t\t  skb_put(skb, size), size, at76_rx_callback, priv);\n\tret = usb_submit_urb(priv->rx_urb, GFP_ATOMIC);\n\tif (ret < 0) {\n\t\tif (ret == -ENODEV)\n\t\t\tat76_dbg(DBG_DEVSTART,\n\t\t\t\t \"usb_submit_urb returned -ENODEV\");\n\t\telse\n\t\t\twiphy_err(priv->hw->wiphy,\n\t\t\t\t  \"rx, usb_submit_urb failed: %d\\n\", ret);\n\t}\n\nexit:\n\tif (ret < 0 && ret != -ENODEV)\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"cannot submit rx urb - please unload the driver and/or power cycle the device\\n\");\n\n\treturn ret;\n}\n\n \nstatic int at76_load_external_fw(struct usb_device *udev, struct fwentry *fwe)\n{\n\tint ret;\n\tint op_mode;\n\tint blockno = 0;\n\tint bsize;\n\tu8 *block;\n\tu8 *buf = fwe->extfw;\n\tint size = fwe->extfw_size;\n\n\tif (!buf || !size)\n\t\treturn -ENOENT;\n\n\top_mode = at76_get_op_mode(udev);\n\tat76_dbg(DBG_DEVSTART, \"opmode %d\", op_mode);\n\n\tif (op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {\n\t\tdev_err(&udev->dev, \"unexpected opmode %d\\n\", op_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tblock = kmalloc(FW_BLOCK_SIZE, GFP_KERNEL);\n\tif (!block)\n\t\treturn -ENOMEM;\n\n\tat76_dbg(DBG_DEVSTART, \"downloading external firmware\");\n\n\t \n\tdo {\n\t\tbsize = min_t(int, size, FW_BLOCK_SIZE);\n\t\tmemcpy(block, buf, bsize);\n\t\tat76_dbg(DBG_DEVSTART,\n\t\t\t \"ext fw, size left = %5d, bsize = %4d, blockno = %2d\",\n\t\t\t size, bsize, blockno);\n\t\tret = at76_load_ext_fw_block(udev, blockno, block, bsize);\n\t\tif (ret != bsize) {\n\t\t\tdev_err(&udev->dev,\n\t\t\t\t\"loading %dth firmware block failed: %d\\n\",\n\t\t\t\tblockno, ret);\n\t\t\tret = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\t\tbuf += bsize;\n\t\tsize -= bsize;\n\t\tblockno++;\n\t} while (bsize > 0);\n\n\tif (at76_is_505a(fwe->board_type)) {\n\t\tat76_dbg(DBG_DEVSTART, \"200 ms delay for 505a\");\n\t\tschedule_timeout_interruptible(HZ / 5 + 1);\n\t}\n\nexit:\n\tkfree(block);\n\tif (ret < 0)\n\t\tdev_err(&udev->dev,\n\t\t\t\"downloading external firmware failed: %d\\n\", ret);\n\treturn ret;\n}\n\n \nstatic int at76_load_internal_fw(struct usb_device *udev, struct fwentry *fwe)\n{\n\tint ret;\n\tint need_remap = !at76_is_505a(fwe->board_type);\n\n\tret = at76_usbdfu_download(udev, fwe->intfw, fwe->intfw_size,\n\t\t\t\t   need_remap ? 0 : 2 * HZ);\n\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"downloading internal fw failed with %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tat76_dbg(DBG_DEVSTART, \"sending REMAP\");\n\n\t \n\tif (need_remap) {\n\t\tret = at76_remap(udev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev,\n\t\t\t\t\"sending REMAP failed with %d\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tat76_dbg(DBG_DEVSTART, \"sleeping for 2 seconds\");\n\tschedule_timeout_interruptible(2 * HZ + 1);\n\tusb_reset_device(udev);\n\nexit:\n\treturn ret;\n}\n\nstatic int at76_startup_device(struct at76_priv *priv)\n{\n\tstruct at76_card_config *ccfg = &priv->card_config;\n\tint ret;\n\n\tat76_dbg(DBG_PARAMS,\n\t\t \"%s param: ssid %.*s (%*phD) mode %s ch %d wep %s key %d \"\n\t\t \"keylen %d\", wiphy_name(priv->hw->wiphy), priv->essid_size,\n\t\t priv->essid, IW_ESSID_MAX_SIZE, priv->essid,\n\t\t priv->iw_mode == IW_MODE_ADHOC ? \"adhoc\" : \"infra\",\n\t\t priv->channel, priv->wep_enabled ? \"enabled\" : \"disabled\",\n\t\t priv->wep_key_id, priv->wep_keys_len[priv->wep_key_id]);\n\tat76_dbg(DBG_PARAMS,\n\t\t \"%s param: preamble %s rts %d retry %d frag %d \"\n\t\t \"txrate %s auth_mode %d\", wiphy_name(priv->hw->wiphy),\n\t\t preambles[priv->preamble_type], priv->rts_threshold,\n\t\t priv->short_retry_limit, priv->frag_threshold,\n\t\t priv->txrate == TX_RATE_1MBIT ? \"1MBit\" : priv->txrate ==\n\t\t TX_RATE_2MBIT ? \"2MBit\" : priv->txrate ==\n\t\t TX_RATE_5_5MBIT ? \"5.5MBit\" : priv->txrate ==\n\t\t TX_RATE_11MBIT ? \"11MBit\" : priv->txrate ==\n\t\t TX_RATE_AUTO ? \"auto\" : \"<invalid>\", priv->auth_mode);\n\tat76_dbg(DBG_PARAMS,\n\t\t \"%s param: pm_mode %d pm_period %d auth_mode %s \"\n\t\t \"scan_times %d %d scan_mode %s\",\n\t\t wiphy_name(priv->hw->wiphy), priv->pm_mode, priv->pm_period,\n\t\t priv->auth_mode == WLAN_AUTH_OPEN ? \"open\" : \"shared_secret\",\n\t\t priv->scan_min_time, priv->scan_max_time,\n\t\t priv->scan_mode == SCAN_TYPE_ACTIVE ? \"active\" : \"passive\");\n\n\tmemset(ccfg, 0, sizeof(struct at76_card_config));\n\tccfg->promiscuous_mode = 0;\n\tccfg->short_retry_limit = priv->short_retry_limit;\n\n\tif (priv->wep_enabled) {\n\t\tif (priv->wep_keys_len[priv->wep_key_id] > WEP_SMALL_KEY_LEN)\n\t\t\tccfg->encryption_type = 2;\n\t\telse\n\t\t\tccfg->encryption_type = 1;\n\n\t\t \n\t\tccfg->exclude_unencrypted = 1;\n\t} else {\n\t\tccfg->exclude_unencrypted = 0;\n\t\tccfg->encryption_type = 0;\n\t}\n\n\tccfg->rts_threshold = cpu_to_le16(priv->rts_threshold);\n\tccfg->fragmentation_threshold = cpu_to_le16(priv->frag_threshold);\n\n\tmemcpy(ccfg->basic_rate_set, hw_rates, 4);\n\t \n\tccfg->auto_rate_fallback = (priv->txrate == TX_RATE_AUTO ? 1 : 0);\n\tccfg->channel = priv->channel;\n\tccfg->privacy_invoked = priv->wep_enabled;\n\tmemcpy(ccfg->current_ssid, priv->essid, IW_ESSID_MAX_SIZE);\n\tccfg->ssid_len = priv->essid_size;\n\n\tccfg->wep_default_key_id = priv->wep_key_id;\n\tmemcpy(ccfg->wep_default_key_value, priv->wep_keys,\n\t       sizeof(priv->wep_keys));\n\n\tccfg->short_preamble = priv->preamble_type;\n\tccfg->beacon_period = cpu_to_le16(priv->beacon_period);\n\n\tret = at76_set_card_command(priv->udev, CMD_STARTUP, &priv->card_config,\n\t\t\t\t    sizeof(struct at76_card_config));\n\tif (ret < 0) {\n\t\twiphy_err(priv->hw->wiphy, \"at76_set_card_command failed: %d\\n\",\n\t\t\t  ret);\n\t\treturn ret;\n\t}\n\n\tat76_wait_completion(priv, CMD_STARTUP);\n\n\t \n\teth_zero_addr(priv->bssid);\n\n\tpriv->scanning = false;\n\n\tif (at76_set_radio(priv, 1) == 1)\n\t\tat76_wait_completion(priv, CMD_RADIO_ON);\n\n\tret = at76_set_preamble(priv, priv->preamble_type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = at76_set_frag(priv, priv->frag_threshold);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = at76_set_rts(priv, priv->rts_threshold);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = at76_set_autorate_fallback(priv,\n\t\t\t\t\t priv->txrate == TX_RATE_AUTO ? 1 : 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = at76_set_pm_mode(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (at76_debug & DBG_MIB) {\n\t\tat76_dump_mib_mac(priv);\n\t\tat76_dump_mib_mac_addr(priv);\n\t\tat76_dump_mib_mac_mgmt(priv);\n\t\tat76_dump_mib_mac_wep(priv);\n\t\tat76_dump_mib_mdomain(priv);\n\t\tat76_dump_mib_phy(priv);\n\t\tat76_dump_mib_local(priv);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void at76_work_set_promisc(struct work_struct *work)\n{\n\tstruct at76_priv *priv = container_of(work, struct at76_priv,\n\t\t\t\t\t      work_set_promisc);\n\tint ret = 0;\n\n\tif (priv->device_unplugged)\n\t\treturn;\n\n\tmutex_lock(&priv->mtx);\n\n\tpriv->mib_buf.type = MIB_LOCAL;\n\tpriv->mib_buf.size = 1;\n\tpriv->mib_buf.index = offsetof(struct mib_local, promiscuous_mode);\n\tpriv->mib_buf.data.byte = priv->promisc ? 1 : 0;\n\n\tret = at76_set_mib(priv, &priv->mib_buf);\n\tif (ret < 0)\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"set_mib (promiscuous_mode) failed: %d\\n\", ret);\n\n\tmutex_unlock(&priv->mtx);\n}\n\n \nstatic void at76_work_submit_rx(struct work_struct *work)\n{\n\tstruct at76_priv *priv = container_of(work, struct at76_priv,\n\t\t\t\t\t      work_submit_rx);\n\n\tmutex_lock(&priv->mtx);\n\tat76_submit_rx_urb(priv);\n\tmutex_unlock(&priv->mtx);\n}\n\n \nstatic inline int at76_guess_freq(struct at76_priv *priv)\n{\n\tsize_t el_off;\n\tconst u8 *el;\n\tint channel = priv->channel;\n\tint len = priv->rx_skb->len;\n\tstruct ieee80211_hdr *hdr = (void *)priv->rx_skb->data;\n\n\tif (!priv->scanning)\n\t\tgoto exit;\n\n\tif (len < 24)\n\t\tgoto exit;\n\n\tif (ieee80211_is_probe_resp(hdr->frame_control)) {\n\t\tel_off = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);\n\t\tel = ((struct ieee80211_mgmt *)hdr)->u.probe_resp.variable;\n\t} else if (ieee80211_is_beacon(hdr->frame_control)) {\n\t\tel_off = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\t\tel = ((struct ieee80211_mgmt *)hdr)->u.beacon.variable;\n\t} else {\n\t\tgoto exit;\n\t}\n\tlen -= el_off;\n\n\tel = cfg80211_find_ie(WLAN_EID_DS_PARAMS, el, len);\n\tif (el && el[1] > 0)\n\t\tchannel = el[2];\n\nexit:\n\treturn ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);\n}\n\nstatic void at76_rx_tasklet(struct tasklet_struct *t)\n{\n\tstruct at76_priv *priv = from_tasklet(priv, t, rx_tasklet);\n\tstruct urb *urb = priv->rx_urb;\n\tstruct at76_rx_buffer *buf;\n\tstruct ieee80211_rx_status rx_status = { 0 };\n\n\tif (priv->device_unplugged) {\n\t\tat76_dbg(DBG_DEVSTART, \"device unplugged\");\n\t\tat76_dbg(DBG_DEVSTART, \"urb status %d\", urb->status);\n\t\treturn;\n\t}\n\n\tif (!priv->rx_skb || !priv->rx_skb->data)\n\t\treturn;\n\n\tbuf = (struct at76_rx_buffer *)priv->rx_skb->data;\n\n\tif (urb->status != 0) {\n\t\tif (urb->status != -ENOENT && urb->status != -ECONNRESET)\n\t\t\tat76_dbg(DBG_URB,\n\t\t\t\t \"%s %s: - nonzero Rx bulk status received: %d\",\n\t\t\t\t __func__, wiphy_name(priv->hw->wiphy),\n\t\t\t\t urb->status);\n\t\treturn;\n\t}\n\n\tat76_dbg(DBG_RX_ATMEL_HDR,\n\t\t \"%s: rx frame: rate %d rssi %d noise %d link %d\",\n\t\t wiphy_name(priv->hw->wiphy), buf->rx_rate, buf->rssi,\n\t\t buf->noise_level, buf->link_quality);\n\n\tskb_pull(priv->rx_skb, AT76_RX_HDRLEN);\n\tskb_trim(priv->rx_skb, le16_to_cpu(buf->wlength));\n\tat76_dbg_dump(DBG_RX_DATA, priv->rx_skb->data,\n\t\t      priv->rx_skb->len, \"RX: len=%d\", priv->rx_skb->len);\n\n\trx_status.signal = buf->rssi;\n\trx_status.flag |= RX_FLAG_DECRYPTED;\n\trx_status.flag |= RX_FLAG_IV_STRIPPED;\n\trx_status.band = NL80211_BAND_2GHZ;\n\trx_status.freq = at76_guess_freq(priv);\n\n\tat76_dbg(DBG_MAC80211, \"calling ieee80211_rx_irqsafe(): %d/%d\",\n\t\t priv->rx_skb->len, priv->rx_skb->data_len);\n\tmemcpy(IEEE80211_SKB_RXCB(priv->rx_skb), &rx_status, sizeof(rx_status));\n\tieee80211_rx_irqsafe(priv->hw, priv->rx_skb);\n\n\t \n\tpriv->rx_skb = NULL;\n\n\tat76_submit_rx_urb(priv);\n}\n\n \nstatic struct fwentry *at76_load_firmware(struct usb_device *udev,\n\t\t\t\t\t  enum board_type board_type)\n{\n\tint ret;\n\tchar *str;\n\tstruct at76_fw_header *fwh;\n\tstruct fwentry *fwe = &firmwares[board_type];\n\n\tmutex_lock(&fw_mutex);\n\n\tif (fwe->loaded) {\n\t\tat76_dbg(DBG_FW, \"re-using previously loaded fw\");\n\t\tgoto exit;\n\t}\n\n\tat76_dbg(DBG_FW, \"downloading firmware %s\", fwe->fwname);\n\tret = request_firmware(&fwe->fw, fwe->fwname, &udev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev, \"firmware %s not found!\\n\",\n\t\t\tfwe->fwname);\n\t\tdev_err(&udev->dev,\n\t\t\t\"you may need to download the firmware from http://developer.berlios.de/projects/at76c503a/\\n\");\n\t\tgoto exit;\n\t}\n\n\tat76_dbg(DBG_FW, \"got it.\");\n\tfwh = (struct at76_fw_header *)(fwe->fw->data);\n\n\tif (fwe->fw->size <= sizeof(*fwh)) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"firmware is too short (0x%zx)\\n\", fwe->fw->size);\n\t\tgoto exit;\n\t}\n\n\t \n\tfwe->board_type = le32_to_cpu(fwh->board_type);\n\tif (fwe->board_type != board_type) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"board type mismatch, requested %u, got %u\\n\",\n\t\t\tboard_type, fwe->board_type);\n\t\tgoto exit;\n\t}\n\n\tfwe->fw_version.major = fwh->major;\n\tfwe->fw_version.minor = fwh->minor;\n\tfwe->fw_version.patch = fwh->patch;\n\tfwe->fw_version.build = fwh->build;\n\n\tstr = (char *)fwh + le32_to_cpu(fwh->str_offset);\n\tfwe->intfw = (u8 *)fwh + le32_to_cpu(fwh->int_fw_offset);\n\tfwe->intfw_size = le32_to_cpu(fwh->int_fw_len);\n\tfwe->extfw = (u8 *)fwh + le32_to_cpu(fwh->ext_fw_offset);\n\tfwe->extfw_size = le32_to_cpu(fwh->ext_fw_len);\n\n\tfwe->loaded = 1;\n\n\tdev_printk(KERN_DEBUG, &udev->dev,\n\t\t   \"using firmware %s (version %d.%d.%d-%d)\\n\",\n\t\t   fwe->fwname, fwh->major, fwh->minor, fwh->patch, fwh->build);\n\n\tat76_dbg(DBG_DEVSTART, \"board %u, int %d:%d, ext %d:%d\", board_type,\n\t\t le32_to_cpu(fwh->int_fw_offset), le32_to_cpu(fwh->int_fw_len),\n\t\t le32_to_cpu(fwh->ext_fw_offset), le32_to_cpu(fwh->ext_fw_len));\n\tat76_dbg(DBG_DEVSTART, \"firmware id %s\", str);\n\nexit:\n\tmutex_unlock(&fw_mutex);\n\n\tif (fwe->loaded)\n\t\treturn fwe;\n\telse\n\t\treturn NULL;\n}\n\nstatic int at76_join(struct at76_priv *priv)\n{\n\tstruct at76_req_join join;\n\tint ret;\n\n\tmemset(&join, 0, sizeof(struct at76_req_join));\n\tmemcpy(join.essid, priv->essid, priv->essid_size);\n\tjoin.essid_size = priv->essid_size;\n\tmemcpy(join.bssid, priv->bssid, ETH_ALEN);\n\tjoin.bss_type = INFRASTRUCTURE_MODE;\n\tjoin.channel = priv->channel;\n\tjoin.timeout = cpu_to_le16(2000);\n\n\tat76_dbg(DBG_MAC80211, \"%s: sending CMD_JOIN\", __func__);\n\tret = at76_set_card_command(priv->udev, CMD_JOIN, &join,\n\t\t\t\t    sizeof(struct at76_req_join));\n\n\tif (ret < 0) {\n\t\twiphy_err(priv->hw->wiphy, \"at76_set_card_command failed: %d\\n\",\n\t\t\t  ret);\n\t\treturn 0;\n\t}\n\n\tret = at76_wait_completion(priv, CMD_JOIN);\n\tat76_dbg(DBG_MAC80211, \"%s: CMD_JOIN returned: 0x%02x\", __func__, ret);\n\tif (ret != CMD_STATUS_COMPLETE) {\n\t\twiphy_err(priv->hw->wiphy, \"at76_wait_completion failed: %d\\n\",\n\t\t\t  ret);\n\t\treturn 0;\n\t}\n\n\tat76_set_pm_mode(priv);\n\n\treturn 0;\n}\n\nstatic void at76_work_join_bssid(struct work_struct *work)\n{\n\tstruct at76_priv *priv = container_of(work, struct at76_priv,\n\t\t\t\t\t      work_join_bssid);\n\n\tif (priv->device_unplugged)\n\t\treturn;\n\n\tmutex_lock(&priv->mtx);\n\n\tif (is_valid_ether_addr(priv->bssid))\n\t\tat76_join(priv);\n\n\tmutex_unlock(&priv->mtx);\n}\n\nstatic void at76_mac80211_tx_callback(struct urb *urb)\n{\n\tstruct at76_priv *priv = urb->context;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(priv->tx_skb);\n\n\tat76_dbg(DBG_MAC80211, \"%s()\", __func__);\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\t\t \n\t\t \n\t\tbreak;\n\tdefault:\n\t\tat76_dbg(DBG_URB, \"%s - nonzero tx status received: %d\",\n\t\t\t __func__, urb->status);\n\t\tbreak;\n\t}\n\n\tmemset(&info->status, 0, sizeof(info->status));\n\n\tieee80211_tx_status_irqsafe(priv->hw, priv->tx_skb);\n\n\tpriv->tx_skb = NULL;\n\n\tieee80211_wake_queues(priv->hw);\n}\n\nstatic void at76_mac80211_tx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_tx_control *control,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct at76_priv *priv = hw->priv;\n\tstruct at76_tx_buffer *tx_buffer = priv->bulk_out_buffer;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\n\tint padding, submit_len, ret;\n\n\tat76_dbg(DBG_MAC80211, \"%s()\", __func__);\n\n\tif (priv->tx_urb->status == -EINPROGRESS) {\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"%s called while tx urb is pending\\n\", __func__);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\t \n\tif (mgmt->frame_control & cpu_to_le16(IEEE80211_STYPE_AUTH)) {\n\t\tif (!ether_addr_equal_64bits(priv->bssid, mgmt->bssid)) {\n\t\t\tmemcpy(priv->bssid, mgmt->bssid, ETH_ALEN);\n\t\t\tieee80211_queue_work(hw, &priv->work_join_bssid);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tieee80211_stop_queues(hw);\n\n\tat76_ledtrig_tx_activity();\t \n\n\tWARN_ON(priv->tx_skb != NULL);\n\n\tpriv->tx_skb = skb;\n\tpadding = at76_calc_padding(skb->len);\n\tsubmit_len = AT76_TX_HDRLEN + skb->len + padding;\n\n\t \n\tmemset(tx_buffer, 0, sizeof(*tx_buffer));\n\ttx_buffer->padding = padding;\n\ttx_buffer->wlength = cpu_to_le16(skb->len);\n\ttx_buffer->tx_rate = ieee80211_get_tx_rate(hw, info)->hw_value;\n\tmemset(tx_buffer->reserved, 0, sizeof(tx_buffer->reserved));\n\tmemcpy(tx_buffer->packet, skb->data, skb->len);\n\n\tat76_dbg(DBG_TX_DATA, \"%s tx: wlen 0x%x pad 0x%x rate %d hdr\",\n\t\t wiphy_name(priv->hw->wiphy), le16_to_cpu(tx_buffer->wlength),\n\t\t tx_buffer->padding, tx_buffer->tx_rate);\n\n\t \n\tat76_dbg_dump(DBG_TX_DATA_CONTENT, tx_buffer, submit_len,\n\t\t      \"%s(): tx_buffer %d bytes:\", __func__, submit_len);\n\tusb_fill_bulk_urb(priv->tx_urb, priv->udev, priv->tx_pipe, tx_buffer,\n\t\t\t  submit_len, at76_mac80211_tx_callback, priv);\n\tret = usb_submit_urb(priv->tx_urb, GFP_ATOMIC);\n\tif (ret) {\n\t\twiphy_err(priv->hw->wiphy, \"error in tx submit urb: %d\\n\", ret);\n\t\tif (ret == -EINVAL)\n\t\t\twiphy_err(priv->hw->wiphy,\n\t\t\t\t  \"-EINVAL: tx urb %p hcpriv %p complete %p\\n\",\n\t\t\t\t  priv->tx_urb,\n\t\t\t\t  priv->tx_urb->hcpriv, priv->tx_urb->complete);\n\t}\n}\n\nstatic int at76_mac80211_start(struct ieee80211_hw *hw)\n{\n\tstruct at76_priv *priv = hw->priv;\n\tint ret;\n\n\tat76_dbg(DBG_MAC80211, \"%s()\", __func__);\n\n\tmutex_lock(&priv->mtx);\n\n\tret = at76_submit_rx_urb(priv);\n\tif (ret < 0) {\n\t\twiphy_err(priv->hw->wiphy, \"open: submit_rx_urb failed: %d\\n\",\n\t\t\t  ret);\n\t\tgoto error;\n\t}\n\n\tat76_startup_device(priv);\n\n\tat76_start_monitor(priv);\n\nerror:\n\tmutex_unlock(&priv->mtx);\n\n\treturn 0;\n}\n\nstatic void at76_mac80211_stop(struct ieee80211_hw *hw)\n{\n\tstruct at76_priv *priv = hw->priv;\n\n\tat76_dbg(DBG_MAC80211, \"%s()\", __func__);\n\n\tcancel_delayed_work(&priv->dwork_hw_scan);\n\tcancel_work_sync(&priv->work_join_bssid);\n\tcancel_work_sync(&priv->work_set_promisc);\n\n\tmutex_lock(&priv->mtx);\n\n\tif (!priv->device_unplugged) {\n\t\t \n\t\tat76_set_radio(priv, 0);\n\n\t\t \n\t\tusb_kill_urb(priv->rx_urb);\n\t}\n\n\tmutex_unlock(&priv->mtx);\n}\n\nstatic int at76_add_interface(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct at76_priv *priv = hw->priv;\n\tint ret = 0;\n\n\tat76_dbg(DBG_MAC80211, \"%s()\", __func__);\n\n\tmutex_lock(&priv->mtx);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tpriv->iw_mode = IW_MODE_INFRA;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tgoto exit;\n\t}\n\nexit:\n\tmutex_unlock(&priv->mtx);\n\n\treturn ret;\n}\n\nstatic void at76_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tat76_dbg(DBG_MAC80211, \"%s()\", __func__);\n}\n\nstatic void at76_dwork_hw_scan(struct work_struct *work)\n{\n\tstruct at76_priv *priv = container_of(work, struct at76_priv,\n\t\t\t\t\t      dwork_hw_scan.work);\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = false,\n\t};\n\tint ret;\n\n\tif (priv->device_unplugged)\n\t\treturn;\n\n\tmutex_lock(&priv->mtx);\n\n\tret = at76_get_cmd_status(priv->udev, CMD_SCAN);\n\tat76_dbg(DBG_MAC80211, \"%s: CMD_SCAN status 0x%02x\", __func__, ret);\n\n\t \n\n\tif (ret != CMD_STATUS_COMPLETE) {\n\t\tieee80211_queue_delayed_work(priv->hw, &priv->dwork_hw_scan,\n\t\t\t\t\t     SCAN_POLL_INTERVAL);\n\t\tmutex_unlock(&priv->mtx);\n\t\treturn;\n\t}\n\n\tif (is_valid_ether_addr(priv->bssid))\n\t\tat76_join(priv);\n\n\tpriv->scanning = false;\n\n\tmutex_unlock(&priv->mtx);\n\n\tieee80211_scan_completed(priv->hw, &info);\n\n\tieee80211_wake_queues(priv->hw);\n}\n\nstatic int at76_hw_scan(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_scan_request *hw_req)\n{\n\tstruct cfg80211_scan_request *req = &hw_req->req;\n\tstruct at76_priv *priv = hw->priv;\n\tstruct at76_req_scan scan;\n\tu8 *ssid = NULL;\n\tint ret, len = 0;\n\n\tat76_dbg(DBG_MAC80211, \"%s():\", __func__);\n\n\tif (priv->device_unplugged)\n\t\treturn 0;\n\n\tmutex_lock(&priv->mtx);\n\n\tieee80211_stop_queues(hw);\n\n\tmemset(&scan, 0, sizeof(struct at76_req_scan));\n\teth_broadcast_addr(scan.bssid);\n\n\tif (req->n_ssids) {\n\t\tscan.scan_type = SCAN_TYPE_ACTIVE;\n\t\tssid = req->ssids[0].ssid;\n\t\tlen = req->ssids[0].ssid_len;\n\t} else {\n\t\tscan.scan_type = SCAN_TYPE_PASSIVE;\n\t}\n\n\tif (len) {\n\t\tmemcpy(scan.essid, ssid, len);\n\t\tscan.essid_size = len;\n\t}\n\n\tscan.min_channel_time = cpu_to_le16(priv->scan_min_time);\n\tscan.max_channel_time = cpu_to_le16(priv->scan_max_time);\n\tscan.probe_delay = cpu_to_le16(priv->scan_min_time * 1000);\n\tscan.international_scan = 0;\n\n\tat76_dbg(DBG_MAC80211, \"%s: sending CMD_SCAN\", __func__);\n\tret = at76_set_card_command(priv->udev, CMD_SCAN, &scan, sizeof(scan));\n\n\tif (ret < 0) {\n\t\twiphy_err(priv->hw->wiphy, \"CMD_SCAN failed: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tpriv->scanning = true;\n\tieee80211_queue_delayed_work(priv->hw, &priv->dwork_hw_scan,\n\t\t\t\t     SCAN_POLL_INTERVAL);\n\nexit:\n\tmutex_unlock(&priv->mtx);\n\n\treturn 0;\n}\n\nstatic int at76_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct at76_priv *priv = hw->priv;\n\n\tat76_dbg(DBG_MAC80211, \"%s(): channel %d\",\n\t\t __func__, hw->conf.chandef.chan->hw_value);\n\tat76_dbg_dump(DBG_MAC80211, priv->bssid, ETH_ALEN, \"bssid:\");\n\n\tmutex_lock(&priv->mtx);\n\n\tpriv->channel = hw->conf.chandef.chan->hw_value;\n\n\tif (is_valid_ether_addr(priv->bssid))\n\t\tat76_join(priv);\n\telse\n\t\tat76_start_monitor(priv);\n\n\tmutex_unlock(&priv->mtx);\n\n\treturn 0;\n}\n\nstatic void at76_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_bss_conf *conf,\n\t\t\t\t  u64 changed)\n{\n\tstruct at76_priv *priv = hw->priv;\n\n\tat76_dbg(DBG_MAC80211, \"%s():\", __func__);\n\n\tif (!(changed & BSS_CHANGED_BSSID))\n\t\treturn;\n\n\tat76_dbg_dump(DBG_MAC80211, conf->bssid, ETH_ALEN, \"bssid:\");\n\n\tmutex_lock(&priv->mtx);\n\n\tmemcpy(priv->bssid, conf->bssid, ETH_ALEN);\n\n\tif (is_valid_ether_addr(priv->bssid))\n\t\t \n\t\tat76_join(priv);\n\n\tmutex_unlock(&priv->mtx);\n}\n\n \nstatic void at76_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t  unsigned int changed_flags,\n\t\t\t\t  unsigned int *total_flags, u64 multicast)\n{\n\tstruct at76_priv *priv = hw->priv;\n\tint flags;\n\n\tat76_dbg(DBG_MAC80211, \"%s(): changed_flags=0x%08x \"\n\t\t \"total_flags=0x%08x\",\n\t\t __func__, changed_flags, *total_flags);\n\n\tflags = changed_flags & AT76_SUPPORTED_FILTERS;\n\t*total_flags = AT76_SUPPORTED_FILTERS;\n\n\t \n\tif (priv->device_unplugged)\n\t\treturn;\n\n\t \n\n\tif (flags && !priv->promisc) {\n\t\t \n\t\tpriv->promisc = 1;\n\t} else if (!flags && priv->promisc) {\n\t\t \n\t\tpriv->promisc = 0;\n\t} else\n\t\treturn;\n\n\tieee80211_queue_work(hw, &priv->work_set_promisc);\n}\n\nstatic int at76_set_wep(struct at76_priv *priv)\n{\n\tint ret = 0;\n\tstruct mib_mac_wep *mib_data = &priv->mib_buf.data.wep_mib;\n\n\tpriv->mib_buf.type = MIB_MAC_WEP;\n\tpriv->mib_buf.size = sizeof(struct mib_mac_wep);\n\tpriv->mib_buf.index = 0;\n\n\tmemset(mib_data, 0, sizeof(*mib_data));\n\n\tif (priv->wep_enabled) {\n\t\tif (priv->wep_keys_len[priv->wep_key_id] > WEP_SMALL_KEY_LEN)\n\t\t\tmib_data->encryption_level = 2;\n\t\telse\n\t\t\tmib_data->encryption_level = 1;\n\n\t\t \n\t\tmib_data->exclude_unencrypted = 1;\n\t} else {\n\t\tmib_data->exclude_unencrypted = 0;\n\t\tmib_data->encryption_level = 0;\n\t}\n\n\tmib_data->privacy_invoked = priv->wep_enabled;\n\tmib_data->wep_default_key_id = priv->wep_key_id;\n\tmemcpy(mib_data->wep_default_keyvalue, priv->wep_keys,\n\t       sizeof(priv->wep_keys));\n\n\tret = at76_set_mib(priv, &priv->mib_buf);\n\n\tif (ret < 0)\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"set_mib (wep) failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int at76_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\tstruct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\tstruct ieee80211_key_conf *key)\n{\n\tstruct at76_priv *priv = hw->priv;\n\n\tint i;\n\n\tat76_dbg(DBG_MAC80211, \"%s(): cmd %d key->cipher %d key->keyidx %d \"\n\t\t \"key->keylen %d\",\n\t\t __func__, cmd, key->cipher, key->keyidx, key->keylen);\n\n\tif ((key->cipher != WLAN_CIPHER_SUITE_WEP40) &&\n\t    (key->cipher != WLAN_CIPHER_SUITE_WEP104))\n\t\treturn -EOPNOTSUPP;\n\n\tkey->hw_key_idx = key->keyidx;\n\n\tmutex_lock(&priv->mtx);\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tmemcpy(priv->wep_keys[key->keyidx], key->key, key->keylen);\n\t\tpriv->wep_keys_len[key->keyidx] = key->keylen;\n\n\t\t \n\t\tpriv->wep_key_id = key->keyidx;\n\n\t\tbreak;\n\tcase DISABLE_KEY:\n\tdefault:\n\t\tpriv->wep_keys_len[key->keyidx] = 0;\n\t\tbreak;\n\t}\n\n\tpriv->wep_enabled = 0;\n\n\tfor (i = 0; i < WEP_KEYS; i++) {\n\t\tif (priv->wep_keys_len[i] != 0)\n\t\t\tpriv->wep_enabled = 1;\n\t}\n\n\tat76_set_wep(priv);\n\n\tmutex_unlock(&priv->mtx);\n\n\treturn 0;\n}\n\nstatic const struct ieee80211_ops at76_ops = {\n\t.tx = at76_mac80211_tx,\n\t.wake_tx_queue = ieee80211_handle_wake_tx_queue,\n\t.add_interface = at76_add_interface,\n\t.remove_interface = at76_remove_interface,\n\t.config = at76_config,\n\t.bss_info_changed = at76_bss_info_changed,\n\t.configure_filter = at76_configure_filter,\n\t.start = at76_mac80211_start,\n\t.stop = at76_mac80211_stop,\n\t.hw_scan = at76_hw_scan,\n\t.set_key = at76_set_key,\n};\n\n \nstatic struct at76_priv *at76_alloc_new_device(struct usb_device *udev)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct at76_priv *priv;\n\n\thw = ieee80211_alloc_hw(sizeof(struct at76_priv), &at76_ops);\n\tif (!hw) {\n\t\tprintk(KERN_ERR DRIVER_NAME \": could not register\"\n\t\t       \" ieee80211_hw\\n\");\n\t\treturn NULL;\n\t}\n\n\tpriv = hw->priv;\n\tpriv->hw = hw;\n\n\tpriv->udev = udev;\n\n\tmutex_init(&priv->mtx);\n\tINIT_WORK(&priv->work_set_promisc, at76_work_set_promisc);\n\tINIT_WORK(&priv->work_submit_rx, at76_work_submit_rx);\n\tINIT_WORK(&priv->work_join_bssid, at76_work_join_bssid);\n\tINIT_DELAYED_WORK(&priv->dwork_hw_scan, at76_dwork_hw_scan);\n\n\ttasklet_setup(&priv->rx_tasklet, at76_rx_tasklet);\n\n\tpriv->pm_mode = AT76_PM_OFF;\n\tpriv->pm_period = 0;\n\n\t \n\n\treturn priv;\n}\n\nstatic int at76_alloc_urbs(struct at76_priv *priv,\n\t\t\t   struct usb_interface *interface)\n{\n\tstruct usb_endpoint_descriptor *endpoint, *ep_in, *ep_out;\n\tint i;\n\tint buffer_size;\n\tstruct usb_host_interface *iface_desc;\n\n\tat76_dbg(DBG_PROC_ENTRY, \"%s: ENTER\", __func__);\n\n\tat76_dbg(DBG_URB, \"%s: NumEndpoints %d \", __func__,\n\t\t interface->cur_altsetting->desc.bNumEndpoints);\n\n\tep_in = NULL;\n\tep_out = NULL;\n\tiface_desc = interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tat76_dbg(DBG_URB, \"%s: %d. endpoint: addr 0x%x attr 0x%x\",\n\t\t\t __func__, i, endpoint->bEndpointAddress,\n\t\t\t endpoint->bmAttributes);\n\n\t\tif (!ep_in && usb_endpoint_is_bulk_in(endpoint))\n\t\t\tep_in = endpoint;\n\n\t\tif (!ep_out && usb_endpoint_is_bulk_out(endpoint))\n\t\t\tep_out = endpoint;\n\t}\n\n\tif (!ep_in || !ep_out) {\n\t\tdev_err(&interface->dev, \"bulk endpoints missing\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpriv->rx_pipe = usb_rcvbulkpipe(priv->udev, ep_in->bEndpointAddress);\n\tpriv->tx_pipe = usb_sndbulkpipe(priv->udev, ep_out->bEndpointAddress);\n\n\tpriv->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tpriv->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!priv->rx_urb || !priv->tx_urb) {\n\t\tdev_err(&interface->dev, \"cannot allocate URB\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbuffer_size = sizeof(struct at76_tx_buffer) + MAX_PADDING_SIZE;\n\tpriv->bulk_out_buffer = kmalloc(buffer_size, GFP_KERNEL);\n\tif (!priv->bulk_out_buffer)\n\t\treturn -ENOMEM;\n\n\tat76_dbg(DBG_PROC_ENTRY, \"%s: EXIT\", __func__);\n\n\treturn 0;\n}\n\nstatic struct ieee80211_rate at76_rates[] = {\n\t{ .bitrate = 10, .hw_value = TX_RATE_1MBIT, },\n\t{ .bitrate = 20, .hw_value = TX_RATE_2MBIT, },\n\t{ .bitrate = 55, .hw_value = TX_RATE_5_5MBIT, },\n\t{ .bitrate = 110, .hw_value = TX_RATE_11MBIT, },\n};\n\nstatic struct ieee80211_channel at76_channels[] = {\n\t{ .center_freq = 2412, .hw_value = 1 },\n\t{ .center_freq = 2417, .hw_value = 2 },\n\t{ .center_freq = 2422, .hw_value = 3 },\n\t{ .center_freq = 2427, .hw_value = 4 },\n\t{ .center_freq = 2432, .hw_value = 5 },\n\t{ .center_freq = 2437, .hw_value = 6 },\n\t{ .center_freq = 2442, .hw_value = 7 },\n\t{ .center_freq = 2447, .hw_value = 8 },\n\t{ .center_freq = 2452, .hw_value = 9 },\n\t{ .center_freq = 2457, .hw_value = 10 },\n\t{ .center_freq = 2462, .hw_value = 11 },\n\t{ .center_freq = 2467, .hw_value = 12 },\n\t{ .center_freq = 2472, .hw_value = 13 },\n\t{ .center_freq = 2484, .hw_value = 14 }\n};\n\nstatic struct ieee80211_supported_band at76_supported_band = {\n\t.channels = at76_channels,\n\t.n_channels = ARRAY_SIZE(at76_channels),\n\t.bitrates = at76_rates,\n\t.n_bitrates = ARRAY_SIZE(at76_rates),\n};\n\n \nstatic int at76_init_new_device(struct at76_priv *priv,\n\t\t\t\tstruct usb_interface *interface)\n{\n\tstruct wiphy *wiphy;\n\tsize_t len;\n\tint ret;\n\n\t \n\t \n\n\tat76_dbg(DBG_DEVSTART, \"USB interface: %d endpoints\",\n\t\t interface->cur_altsetting->desc.bNumEndpoints);\n\n\tret = at76_alloc_urbs(priv, interface);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\t \n\tret = at76_get_hw_config(priv);\n\tif (ret < 0) {\n\t\tdev_err(&interface->dev, \"cannot get MAC address\\n\");\n\t\tgoto exit;\n\t}\n\n\tpriv->domain = at76_get_reg_domain(priv->regulatory_domain);\n\n\tpriv->channel = DEF_CHANNEL;\n\tpriv->iw_mode = IW_MODE_INFRA;\n\tpriv->rts_threshold = DEF_RTS_THRESHOLD;\n\tpriv->frag_threshold = DEF_FRAG_THRESHOLD;\n\tpriv->short_retry_limit = DEF_SHORT_RETRY_LIMIT;\n\tpriv->txrate = TX_RATE_AUTO;\n\tpriv->preamble_type = PREAMBLE_TYPE_LONG;\n\tpriv->beacon_period = 100;\n\tpriv->auth_mode = WLAN_AUTH_OPEN;\n\tpriv->scan_min_time = DEF_SCAN_MIN_TIME;\n\tpriv->scan_max_time = DEF_SCAN_MAX_TIME;\n\tpriv->scan_mode = SCAN_TYPE_ACTIVE;\n\tpriv->device_unplugged = 0;\n\n\t \n\twiphy = priv->hw->wiphy;\n\tpriv->hw->wiphy->max_scan_ssids = 1;\n\tpriv->hw->wiphy->max_scan_ie_len = 0;\n\tpriv->hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\n\tpriv->hw->wiphy->bands[NL80211_BAND_2GHZ] = &at76_supported_band;\n\tieee80211_hw_set(priv->hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(priv->hw, SIGNAL_UNSPEC);\n\tpriv->hw->max_signal = 100;\n\n\tSET_IEEE80211_DEV(priv->hw, &interface->dev);\n\tSET_IEEE80211_PERM_ADDR(priv->hw, priv->mac_addr);\n\n\tlen = sizeof(wiphy->fw_version);\n\tsnprintf(wiphy->fw_version, len, \"%d.%d.%d-%d\",\n\t\t priv->fw_version.major, priv->fw_version.minor,\n\t\t priv->fw_version.patch, priv->fw_version.build);\n\n\twiphy->hw_version = priv->board_type;\n\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\tret = ieee80211_register_hw(priv->hw);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"cannot register mac80211 hw (status %d)!\\n\",\n\t\t       ret);\n\t\tgoto exit;\n\t}\n\n\tpriv->mac80211_registered = 1;\n\n\twiphy_info(priv->hw->wiphy, \"USB %s, MAC %pM, firmware %d.%d.%d-%d\\n\",\n\t\t   dev_name(&interface->dev), priv->mac_addr,\n\t\t   priv->fw_version.major, priv->fw_version.minor,\n\t\t   priv->fw_version.patch, priv->fw_version.build);\n\twiphy_info(priv->hw->wiphy, \"regulatory domain 0x%02x: %s\\n\",\n\t\t   priv->regulatory_domain, priv->domain->name);\n\nexit:\n\treturn ret;\n}\n\nstatic void at76_delete_device(struct at76_priv *priv)\n{\n\tat76_dbg(DBG_PROC_ENTRY, \"%s: ENTER\", __func__);\n\n\t \n\tpriv->device_unplugged = 1;\n\n\ttasklet_kill(&priv->rx_tasklet);\n\n\tif (priv->mac80211_registered)\n\t\tieee80211_unregister_hw(priv->hw);\n\n\tif (priv->tx_urb) {\n\t\tusb_kill_urb(priv->tx_urb);\n\t\tusb_free_urb(priv->tx_urb);\n\t}\n\tif (priv->rx_urb) {\n\t\tusb_kill_urb(priv->rx_urb);\n\t\tusb_free_urb(priv->rx_urb);\n\t}\n\n\tat76_dbg(DBG_PROC_ENTRY, \"%s: unlinked urbs\", __func__);\n\n\tkfree(priv->bulk_out_buffer);\n\n\tdel_timer_sync(&ledtrig_tx_timer);\n\n\tkfree_skb(priv->rx_skb);\n\n\tat76_dbg(DBG_PROC_ENTRY, \"%s: before freeing priv/ieee80211_hw\",\n\t\t __func__);\n\tieee80211_free_hw(priv->hw);\n\n\tat76_dbg(DBG_PROC_ENTRY, \"%s: EXIT\", __func__);\n}\n\nstatic int at76_probe(struct usb_interface *interface,\n\t\t      const struct usb_device_id *id)\n{\n\tint ret;\n\tstruct at76_priv *priv;\n\tstruct fwentry *fwe;\n\tstruct usb_device *udev;\n\tint op_mode;\n\tint need_ext_fw = 0;\n\tstruct mib_fw_version *fwv = NULL;\n\tint board_type = (int)id->driver_info;\n\n\tudev = usb_get_dev(interface_to_usbdev(interface));\n\n\tfwv = kmalloc(sizeof(*fwv), GFP_KERNEL);\n\tif (!fwv) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\t \n\tfwe = at76_load_firmware(udev, board_type);\n\tif (!fwe) {\n\t\tret = -ENOENT;\n\t\tgoto exit;\n\t}\n\n\top_mode = at76_get_op_mode(udev);\n\n\tat76_dbg(DBG_DEVSTART, \"opmode %d\", op_mode);\n\n\t \n\n\tif (op_mode == OPMODE_HW_CONFIG_MODE) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"cannot handle a device in HW_CONFIG_MODE\\n\");\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tif (op_mode != OPMODE_NORMAL_NIC_WITH_FLASH\n\t    && op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {\n\t\t \n\t\tdev_printk(KERN_DEBUG, &interface->dev,\n\t\t\t   \"downloading internal firmware\\n\");\n\t\tret = at76_load_internal_fw(udev, fwe);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&interface->dev,\n\t\t\t\t\"error %d downloading internal firmware\\n\",\n\t\t\t\tret);\n\t\t}\n\t\tgoto exit;\n\t}\n\n\t \n\n\t \n\tif ((fwe->fw_version.major > 0 || fwe->fw_version.minor >= 100)\n\t    || (op_mode == OPMODE_NORMAL_NIC_WITH_FLASH)) {\n\t\tret = at76_get_mib(udev, MIB_FW_VERSION, fwv, sizeof(*fwv));\n\t\tif (ret < 0 || (fwv->major | fwv->minor) == 0)\n\t\t\tneed_ext_fw = 1;\n\t} else\n\t\t \n\t\tneed_ext_fw = 1;\n\n\tif (need_ext_fw) {\n\t\tdev_printk(KERN_DEBUG, &interface->dev,\n\t\t\t   \"downloading external firmware\\n\");\n\n\t\tret = at76_load_external_fw(udev, fwe);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\t \n\t\tret = at76_get_mib(udev, MIB_FW_VERSION, fwv, sizeof(*fwv));\n\t\tif (ret < 0) {\n\t\t\tdev_err(&interface->dev,\n\t\t\t\t\"error %d getting firmware version\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tpriv = at76_alloc_new_device(udev);\n\tif (!priv) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tusb_set_intfdata(interface, priv);\n\n\tmemcpy(&priv->fw_version, fwv, sizeof(struct mib_fw_version));\n\tpriv->board_type = board_type;\n\n\tret = at76_init_new_device(priv, interface);\n\tif (ret < 0)\n\t\tat76_delete_device(priv);\n\nexit:\n\tkfree(fwv);\n\tif (ret < 0)\n\t\tusb_put_dev(udev);\n\treturn ret;\n}\n\nstatic void at76_disconnect(struct usb_interface *interface)\n{\n\tstruct at76_priv *priv;\n\n\tpriv = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\n\t \n\tif (!priv)\n\t\treturn;\n\n\twiphy_info(priv->hw->wiphy, \"disconnecting\\n\");\n\tat76_delete_device(priv);\n\tusb_put_dev(priv->udev);\n\tdev_info(&interface->dev, \"disconnected\\n\");\n}\n\n \nstatic struct usb_driver at76_driver = {\n\t.name = DRIVER_NAME,\n\t.probe = at76_probe,\n\t.disconnect = at76_disconnect,\n\t.id_table = dev_table,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nstatic int __init at76_mod_init(void)\n{\n\tint result;\n\n\tprintk(KERN_INFO DRIVER_DESC \" \" DRIVER_VERSION \" loading\\n\");\n\n\t \n\tresult = usb_register(&at76_driver);\n\tif (result < 0)\n\t\tprintk(KERN_ERR DRIVER_NAME\n\t\t       \": usb_register failed (status %d)\\n\", result);\n\telse\n\t\tled_trigger_register_simple(\"at76_usb-tx\", &ledtrig_tx);\n\treturn result;\n}\n\nstatic void __exit at76_mod_exit(void)\n{\n\tint i;\n\n\tprintk(KERN_INFO DRIVER_DESC \" \" DRIVER_VERSION \" unloading\\n\");\n\tusb_deregister(&at76_driver);\n\tfor (i = 0; i < ARRAY_SIZE(firmwares); i++)\n\t\trelease_firmware(firmwares[i].fw);\n\tled_trigger_unregister_simple(ledtrig_tx);\n}\n\nmodule_param_named(debug, at76_debug, uint, 0600);\nMODULE_PARM_DESC(debug, \"Debugging level\");\n\nmodule_init(at76_mod_init);\nmodule_exit(at76_mod_exit);\n\nMODULE_AUTHOR(\"Oliver Kurth <oku@masqmail.cx>\");\nMODULE_AUTHOR(\"Joerg Albert <joerg.albert@gmx.de>\");\nMODULE_AUTHOR(\"Alex <alex@foogod.com>\");\nMODULE_AUTHOR(\"Nick Jones\");\nMODULE_AUTHOR(\"Balint Seeber <n0_5p4m_p13453@hotmail.com>\");\nMODULE_AUTHOR(\"Pavel Roskin <proski@gnu.org>\");\nMODULE_AUTHOR(\"Guido Guenther <agx@sigxcpu.org>\");\nMODULE_AUTHOR(\"Kalle Valo <kalle.valo@iki.fi>\");\nMODULE_AUTHOR(\"Sebastian Smolorz <sesmo@gmx.net>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}