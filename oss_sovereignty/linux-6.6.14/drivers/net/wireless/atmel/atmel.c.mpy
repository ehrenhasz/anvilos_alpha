{
  "module_name": "atmel.c",
  "hash_id": "ff4fd9a19a23ecb45eaec918a3db42f361e68bec96b17da206a10f54b2af347d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/atmel/atmel.c",
  "human_readable_source": " \n\n#include <linux/interrupt.h>\n\n#include <linux/kernel.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <asm/byteorder.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/fcntl.h>\n#include <linux/delay.h>\n#include <linux/wireless.h>\n#include <net/iw_handler.h>\n#include <linux/crc32.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/firmware.h>\n#include <linux/jiffies.h>\n#include <net/cfg80211.h>\n#include \"atmel.h\"\n\n#define DRIVER_MAJOR 0\n#define DRIVER_MINOR 98\n\nMODULE_AUTHOR(\"Simon Kelley\");\nMODULE_DESCRIPTION(\"Support for Atmel at76c50x 802.11 wireless ethernet cards.\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic char *firmware = NULL;\nmodule_param(firmware, charp, 0);\n\n \nstatic struct {\n\tAtmelFWType fw_type;\n\tconst char *fw_file;\n\tconst char *fw_file_ext;\n} fw_table[] = {\n\t{ ATMEL_FW_TYPE_502,\t\t\"atmel_at76c502\",\t\"bin\" },\n\t{ ATMEL_FW_TYPE_502D,\t\t\"atmel_at76c502d\",\t\"bin\" },\n\t{ ATMEL_FW_TYPE_502E,\t\t\"atmel_at76c502e\",\t\"bin\" },\n\t{ ATMEL_FW_TYPE_502_3COM,\t\"atmel_at76c502_3com\",\t\"bin\" },\n\t{ ATMEL_FW_TYPE_504,\t\t\"atmel_at76c504\",\t\"bin\" },\n\t{ ATMEL_FW_TYPE_504_2958,\t\"atmel_at76c504_2958\",\t\"bin\" },\n\t{ ATMEL_FW_TYPE_504A_2958,\t\"atmel_at76c504a_2958\",\t\"bin\" },\n\t{ ATMEL_FW_TYPE_506,\t\t\"atmel_at76c506\",\t\"bin\" },\n\t{ ATMEL_FW_TYPE_NONE,\t\tNULL,\t\t\tNULL }\n};\nMODULE_FIRMWARE(\"atmel_at76c502-wpa.bin\");\nMODULE_FIRMWARE(\"atmel_at76c502.bin\");\nMODULE_FIRMWARE(\"atmel_at76c502d-wpa.bin\");\nMODULE_FIRMWARE(\"atmel_at76c502d.bin\");\nMODULE_FIRMWARE(\"atmel_at76c502e-wpa.bin\");\nMODULE_FIRMWARE(\"atmel_at76c502e.bin\");\nMODULE_FIRMWARE(\"atmel_at76c502_3com-wpa.bin\");\nMODULE_FIRMWARE(\"atmel_at76c502_3com.bin\");\nMODULE_FIRMWARE(\"atmel_at76c504-wpa.bin\");\nMODULE_FIRMWARE(\"atmel_at76c504.bin\");\nMODULE_FIRMWARE(\"atmel_at76c504_2958-wpa.bin\");\nMODULE_FIRMWARE(\"atmel_at76c504_2958.bin\");\nMODULE_FIRMWARE(\"atmel_at76c504a_2958-wpa.bin\");\nMODULE_FIRMWARE(\"atmel_at76c504a_2958.bin\");\nMODULE_FIRMWARE(\"atmel_at76c506-wpa.bin\");\nMODULE_FIRMWARE(\"atmel_at76c506.bin\");\n\n#define MAX_SSID_LENGTH 32\n#define MGMT_JIFFIES (256 * HZ / 100)\n\n#define MAX_BSS_ENTRIES\t64\n\n \n#define GCR  0x00     \n#define BSR  0x02     \n#define AR   0x04\n#define DR   0x08\n#define MR1  0x12     \n#define MR2  0x14     \n#define MR3  0x16     \n#define MR4  0x18     \n\n#define GPR1                            0x0c\n#define GPR2                            0x0e\n#define GPR3                            0x10\n \n#define GCR_REMAP     0x0400           \n#define GCR_SWRES     0x0080           \n#define GCR_CORES     0x0060           \n#define GCR_ENINT     0x0002           \n#define GCR_ACKINT    0x0008           \n\n#define BSS_SRAM      0x0200           \n#define BSS_IRAM      0x0100           \n \n#define MAC_INIT_COMPLETE       0x0001         \n#define MAC_BOOT_COMPLETE       0x0010         \n#define MAC_INIT_OK             0x0002         \n\n#define MIB_MAX_DATA_BYTES    212\n#define MIB_HEADER_SIZE       4     \n\nstruct get_set_mib {\n\tu8 type;\n\tu8 size;\n\tu8 index;\n\tu8 reserved;\n\tu8 data[MIB_MAX_DATA_BYTES];\n};\n\nstruct rx_desc {\n\tu32          Next;\n\tu16          MsduPos;\n\tu16          MsduSize;\n\n\tu8           State;\n\tu8           Status;\n\tu8           Rate;\n\tu8           Rssi;\n\tu8           LinkQuality;\n\tu8           PreambleType;\n\tu16          Duration;\n\tu32          RxTime;\n};\n\n#define RX_DESC_FLAG_VALID       0x80\n#define RX_DESC_FLAG_CONSUMED    0x40\n#define RX_DESC_FLAG_IDLE        0x00\n\n#define RX_STATUS_SUCCESS        0x00\n\n#define RX_DESC_MSDU_POS_OFFSET      4\n#define RX_DESC_MSDU_SIZE_OFFSET     6\n#define RX_DESC_FLAGS_OFFSET         8\n#define RX_DESC_STATUS_OFFSET        9\n#define RX_DESC_RSSI_OFFSET          11\n#define RX_DESC_LINK_QUALITY_OFFSET  12\n#define RX_DESC_PREAMBLE_TYPE_OFFSET 13\n#define RX_DESC_DURATION_OFFSET      14\n#define RX_DESC_RX_TIME_OFFSET       16\n\nstruct tx_desc {\n\tu32       NextDescriptor;\n\tu16       TxStartOfFrame;\n\tu16       TxLength;\n\n\tu8        TxState;\n\tu8        TxStatus;\n\tu8        RetryCount;\n\n\tu8        TxRate;\n\n\tu8        KeyIndex;\n\tu8        ChiperType;\n\tu8        ChipreLength;\n\tu8        Reserved1;\n\n\tu8        Reserved;\n\tu8        PacketType;\n\tu16       HostTxLength;\n};\n\n#define TX_DESC_NEXT_OFFSET          0\n#define TX_DESC_POS_OFFSET           4\n#define TX_DESC_SIZE_OFFSET          6\n#define TX_DESC_FLAGS_OFFSET         8\n#define TX_DESC_STATUS_OFFSET        9\n#define TX_DESC_RETRY_OFFSET         10\n#define TX_DESC_RATE_OFFSET          11\n#define TX_DESC_KEY_INDEX_OFFSET     12\n#define TX_DESC_CIPHER_TYPE_OFFSET   13\n#define TX_DESC_CIPHER_LENGTH_OFFSET 14\n#define TX_DESC_PACKET_TYPE_OFFSET   17\n#define TX_DESC_HOST_LENGTH_OFFSET   18\n\n \n\n#define TX_STATUS_SUCCESS       0x00\n\n#define TX_FIRM_OWN             0x80\n#define TX_DONE                 0x40\n\n#define TX_ERROR                0x01\n\n#define TX_PACKET_TYPE_DATA     0x01\n#define TX_PACKET_TYPE_MGMT     0x02\n\n#define ISR_EMPTY               0x00         \n#define ISR_TxCOMPLETE          0x01         \n#define ISR_RxCOMPLETE          0x02         \n#define ISR_RxFRAMELOST         0x04         \n#define ISR_FATAL_ERROR         0x08         \n#define ISR_COMMAND_COMPLETE    0x10         \n#define ISR_OUT_OF_RANGE        0x20         \n#define ISR_IBSS_MERGE          0x40         \n#define ISR_GENERIC_IRQ         0x80\n\n#define Local_Mib_Type          0x01\n#define Mac_Address_Mib_Type    0x02\n#define Mac_Mib_Type            0x03\n#define Statistics_Mib_Type     0x04\n#define Mac_Mgmt_Mib_Type       0x05\n#define Mac_Wep_Mib_Type        0x06\n#define Phy_Mib_Type            0x07\n#define Multi_Domain_MIB        0x08\n\n#define MAC_MGMT_MIB_CUR_BSSID_POS            14\n#define MAC_MIB_FRAG_THRESHOLD_POS            8\n#define MAC_MIB_RTS_THRESHOLD_POS             10\n#define MAC_MIB_SHORT_RETRY_POS               16\n#define MAC_MIB_LONG_RETRY_POS                17\n#define MAC_MIB_SHORT_RETRY_LIMIT_POS         16\n#define MAC_MGMT_MIB_BEACON_PER_POS           0\n#define MAC_MGMT_MIB_STATION_ID_POS           6\n#define MAC_MGMT_MIB_CUR_PRIVACY_POS          11\n#define MAC_MGMT_MIB_CUR_BSSID_POS            14\n#define MAC_MGMT_MIB_PS_MODE_POS              53\n#define MAC_MGMT_MIB_LISTEN_INTERVAL_POS      54\n#define MAC_MGMT_MIB_MULTI_DOMAIN_IMPLEMENTED 56\n#define MAC_MGMT_MIB_MULTI_DOMAIN_ENABLED     57\n#define PHY_MIB_CHANNEL_POS                   14\n#define PHY_MIB_RATE_SET_POS                  20\n#define PHY_MIB_REG_DOMAIN_POS                26\n#define LOCAL_MIB_AUTO_TX_RATE_POS            3\n#define LOCAL_MIB_SSID_SIZE                   5\n#define LOCAL_MIB_TX_PROMISCUOUS_POS          6\n#define LOCAL_MIB_TX_MGMT_RATE_POS            7\n#define LOCAL_MIB_TX_CONTROL_RATE_POS         8\n#define LOCAL_MIB_PREAMBLE_TYPE               9\n#define MAC_ADDR_MIB_MAC_ADDR_POS             0\n\n#define         CMD_Set_MIB_Vars              0x01\n#define         CMD_Get_MIB_Vars              0x02\n#define         CMD_Scan                      0x03\n#define         CMD_Join                      0x04\n#define         CMD_Start                     0x05\n#define         CMD_EnableRadio               0x06\n#define         CMD_DisableRadio              0x07\n#define         CMD_SiteSurvey                0x0B\n\n#define         CMD_STATUS_IDLE                   0x00\n#define         CMD_STATUS_COMPLETE               0x01\n#define         CMD_STATUS_UNKNOWN                0x02\n#define         CMD_STATUS_INVALID_PARAMETER      0x03\n#define         CMD_STATUS_FUNCTION_NOT_SUPPORTED 0x04\n#define         CMD_STATUS_TIME_OUT               0x07\n#define         CMD_STATUS_IN_PROGRESS            0x08\n#define         CMD_STATUS_REJECTED_RADIO_OFF     0x09\n#define         CMD_STATUS_HOST_ERROR             0xFF\n#define         CMD_STATUS_BUSY                   0xFE\n\n#define CMD_BLOCK_COMMAND_OFFSET        0\n#define CMD_BLOCK_STATUS_OFFSET         1\n#define CMD_BLOCK_PARAMETERS_OFFSET     4\n\n#define SCAN_OPTIONS_SITE_SURVEY        0x80\n\n#define MGMT_FRAME_BODY_OFFSET\t\t24\n#define MAX_AUTHENTICATION_RETRIES\t3\n#define MAX_ASSOCIATION_RETRIES\t\t3\n\n#define AUTHENTICATION_RESPONSE_TIME_OUT  1000\n\n#define MAX_WIRELESS_BODY  2316  \n#define LOOP_RETRY_LIMIT   500000\n\n#define ACTIVE_MODE\t1\n#define PS_MODE\t\t2\n\n#define MAX_ENCRYPTION_KEYS 4\n#define MAX_ENCRYPTION_KEY_SIZE 40\n\n \n\n \n\n#define REG_DOMAIN_FCC\t\t0x10\t \n#define REG_DOMAIN_DOC\t\t0x20\t \n#define REG_DOMAIN_ETSI\t\t0x30\t \n#define REG_DOMAIN_SPAIN\t0x31\t \n#define REG_DOMAIN_FRANCE\t0x32\t \n#define REG_DOMAIN_MKK\t\t0x40\t \n#define REG_DOMAIN_MKK1\t\t0x41\t \n#define REG_DOMAIN_ISRAEL\t0x50\t \n\n#define BSS_TYPE_AD_HOC\t\t1\n#define BSS_TYPE_INFRASTRUCTURE 2\n\n#define SCAN_TYPE_ACTIVE\t0\n#define SCAN_TYPE_PASSIVE\t1\n\n#define LONG_PREAMBLE\t\t0\n#define SHORT_PREAMBLE\t\t1\n#define AUTO_PREAMBLE\t\t2\n\n#define DATA_FRAME_WS_HEADER_SIZE   30\n\n \n#define PROM_MODE_OFF\t\t\t0x0\n#define PROM_MODE_UNKNOWN\t\t0x1\n#define PROM_MODE_CRC_FAILED\t\t0x2\n#define PROM_MODE_DUPLICATED\t\t0x4\n#define PROM_MODE_MGMT\t\t\t0x8\n#define PROM_MODE_CTRL\t\t\t0x10\n#define PROM_MODE_BAD_PROTOCOL\t\t0x20\n\n#define IFACE_INT_STATUS_OFFSET\t\t0\n#define IFACE_INT_MASK_OFFSET\t\t1\n#define IFACE_LOCKOUT_HOST_OFFSET\t2\n#define IFACE_LOCKOUT_MAC_OFFSET\t3\n#define IFACE_FUNC_CTRL_OFFSET\t\t28\n#define IFACE_MAC_STAT_OFFSET\t\t30\n#define IFACE_GENERIC_INT_TYPE_OFFSET\t32\n\n#define CIPHER_SUITE_NONE     0\n#define CIPHER_SUITE_WEP_64   1\n#define CIPHER_SUITE_TKIP     2\n#define CIPHER_SUITE_AES      3\n#define CIPHER_SUITE_CCX      4\n#define CIPHER_SUITE_WEP_128  5\n\n \n\n \n#define FUNC_CTRL_TxENABLE\t\t0x10\n#define FUNC_CTRL_RxENABLE\t\t0x20\n#define FUNC_CTRL_INIT_COMPLETE\t\t0x01\n\n \nstatic u8 mac_reader[] = {\n\t0x06, 0x00, 0x00, 0xea, 0x04, 0x00, 0x00, 0xea, 0x03, 0x00, 0x00, 0xea, 0x02, 0x00, 0x00, 0xea,\n\t0x01, 0x00, 0x00, 0xea, 0x00, 0x00, 0x00, 0xea, 0xff, 0xff, 0xff, 0xea, 0xfe, 0xff, 0xff, 0xea,\n\t0xd3, 0x00, 0xa0, 0xe3, 0x00, 0xf0, 0x21, 0xe1, 0x0e, 0x04, 0xa0, 0xe3, 0x00, 0x10, 0xa0, 0xe3,\n\t0x81, 0x11, 0xa0, 0xe1, 0x00, 0x10, 0x81, 0xe3, 0x00, 0x10, 0x80, 0xe5, 0x1c, 0x10, 0x90, 0xe5,\n\t0x10, 0x10, 0xc1, 0xe3, 0x1c, 0x10, 0x80, 0xe5, 0x01, 0x10, 0xa0, 0xe3, 0x08, 0x10, 0x80, 0xe5,\n\t0x02, 0x03, 0xa0, 0xe3, 0x00, 0x10, 0xa0, 0xe3, 0xb0, 0x10, 0xc0, 0xe1, 0xb4, 0x10, 0xc0, 0xe1,\n\t0xb8, 0x10, 0xc0, 0xe1, 0xbc, 0x10, 0xc0, 0xe1, 0x56, 0xdc, 0xa0, 0xe3, 0x21, 0x00, 0x00, 0xeb,\n\t0x0a, 0x00, 0xa0, 0xe3, 0x1a, 0x00, 0x00, 0xeb, 0x10, 0x00, 0x00, 0xeb, 0x07, 0x00, 0x00, 0xeb,\n\t0x02, 0x03, 0xa0, 0xe3, 0x02, 0x14, 0xa0, 0xe3, 0xb4, 0x10, 0xc0, 0xe1, 0x4c, 0x10, 0x9f, 0xe5,\n\t0xbc, 0x10, 0xc0, 0xe1, 0x10, 0x10, 0xa0, 0xe3, 0xb8, 0x10, 0xc0, 0xe1, 0xfe, 0xff, 0xff, 0xea,\n\t0x00, 0x40, 0x2d, 0xe9, 0x00, 0x20, 0xa0, 0xe3, 0x02, 0x3c, 0xa0, 0xe3, 0x00, 0x10, 0xa0, 0xe3,\n\t0x28, 0x00, 0x9f, 0xe5, 0x37, 0x00, 0x00, 0xeb, 0x00, 0x40, 0xbd, 0xe8, 0x1e, 0xff, 0x2f, 0xe1,\n\t0x00, 0x40, 0x2d, 0xe9, 0x12, 0x2e, 0xa0, 0xe3, 0x06, 0x30, 0xa0, 0xe3, 0x00, 0x10, 0xa0, 0xe3,\n\t0x02, 0x04, 0xa0, 0xe3, 0x2f, 0x00, 0x00, 0xeb, 0x00, 0x40, 0xbd, 0xe8, 0x1e, 0xff, 0x2f, 0xe1,\n\t0x00, 0x02, 0x00, 0x02, 0x80, 0x01, 0x90, 0xe0, 0x01, 0x00, 0x00, 0x0a, 0x01, 0x00, 0x50, 0xe2,\n\t0xfc, 0xff, 0xff, 0xea, 0x1e, 0xff, 0x2f, 0xe1, 0x80, 0x10, 0xa0, 0xe3, 0xf3, 0x06, 0xa0, 0xe3,\n\t0x00, 0x10, 0x80, 0xe5, 0x00, 0x10, 0xa0, 0xe3, 0x00, 0x10, 0x80, 0xe5, 0x01, 0x10, 0xa0, 0xe3,\n\t0x04, 0x10, 0x80, 0xe5, 0x00, 0x10, 0x80, 0xe5, 0x0e, 0x34, 0xa0, 0xe3, 0x1c, 0x10, 0x93, 0xe5,\n\t0x02, 0x1a, 0x81, 0xe3, 0x1c, 0x10, 0x83, 0xe5, 0x58, 0x11, 0x9f, 0xe5, 0x30, 0x10, 0x80, 0xe5,\n\t0x54, 0x11, 0x9f, 0xe5, 0x34, 0x10, 0x80, 0xe5, 0x38, 0x10, 0x80, 0xe5, 0x3c, 0x10, 0x80, 0xe5,\n\t0x10, 0x10, 0x90, 0xe5, 0x08, 0x00, 0x90, 0xe5, 0x1e, 0xff, 0x2f, 0xe1, 0xf3, 0x16, 0xa0, 0xe3,\n\t0x08, 0x00, 0x91, 0xe5, 0x05, 0x00, 0xa0, 0xe3, 0x0c, 0x00, 0x81, 0xe5, 0x10, 0x00, 0x91, 0xe5,\n\t0x02, 0x00, 0x10, 0xe3, 0xfc, 0xff, 0xff, 0x0a, 0xff, 0x00, 0xa0, 0xe3, 0x0c, 0x00, 0x81, 0xe5,\n\t0x10, 0x00, 0x91, 0xe5, 0x02, 0x00, 0x10, 0xe3, 0xfc, 0xff, 0xff, 0x0a, 0x08, 0x00, 0x91, 0xe5,\n\t0x10, 0x00, 0x91, 0xe5, 0x01, 0x00, 0x10, 0xe3, 0xfc, 0xff, 0xff, 0x0a, 0x08, 0x00, 0x91, 0xe5,\n\t0xff, 0x00, 0x00, 0xe2, 0x1e, 0xff, 0x2f, 0xe1, 0x30, 0x40, 0x2d, 0xe9, 0x00, 0x50, 0xa0, 0xe1,\n\t0x03, 0x40, 0xa0, 0xe1, 0xa2, 0x02, 0xa0, 0xe1, 0x08, 0x00, 0x00, 0xe2, 0x03, 0x00, 0x80, 0xe2,\n\t0xd8, 0x10, 0x9f, 0xe5, 0x00, 0x00, 0xc1, 0xe5, 0x01, 0x20, 0xc1, 0xe5, 0xe2, 0xff, 0xff, 0xeb,\n\t0x01, 0x00, 0x10, 0xe3, 0xfc, 0xff, 0xff, 0x1a, 0x14, 0x00, 0xa0, 0xe3, 0xc4, 0xff, 0xff, 0xeb,\n\t0x04, 0x20, 0xa0, 0xe1, 0x05, 0x10, 0xa0, 0xe1, 0x02, 0x00, 0xa0, 0xe3, 0x01, 0x00, 0x00, 0xeb,\n\t0x30, 0x40, 0xbd, 0xe8, 0x1e, 0xff, 0x2f, 0xe1, 0x70, 0x40, 0x2d, 0xe9, 0xf3, 0x46, 0xa0, 0xe3,\n\t0x00, 0x30, 0xa0, 0xe3, 0x00, 0x00, 0x50, 0xe3, 0x08, 0x00, 0x00, 0x9a, 0x8c, 0x50, 0x9f, 0xe5,\n\t0x03, 0x60, 0xd5, 0xe7, 0x0c, 0x60, 0x84, 0xe5, 0x10, 0x60, 0x94, 0xe5, 0x02, 0x00, 0x16, 0xe3,\n\t0xfc, 0xff, 0xff, 0x0a, 0x01, 0x30, 0x83, 0xe2, 0x00, 0x00, 0x53, 0xe1, 0xf7, 0xff, 0xff, 0x3a,\n\t0xff, 0x30, 0xa0, 0xe3, 0x0c, 0x30, 0x84, 0xe5, 0x08, 0x00, 0x94, 0xe5, 0x10, 0x00, 0x94, 0xe5,\n\t0x01, 0x00, 0x10, 0xe3, 0xfc, 0xff, 0xff, 0x0a, 0x08, 0x00, 0x94, 0xe5, 0x00, 0x00, 0xa0, 0xe3,\n\t0x00, 0x00, 0x52, 0xe3, 0x0b, 0x00, 0x00, 0x9a, 0x10, 0x50, 0x94, 0xe5, 0x02, 0x00, 0x15, 0xe3,\n\t0xfc, 0xff, 0xff, 0x0a, 0x0c, 0x30, 0x84, 0xe5, 0x10, 0x50, 0x94, 0xe5, 0x01, 0x00, 0x15, 0xe3,\n\t0xfc, 0xff, 0xff, 0x0a, 0x08, 0x50, 0x94, 0xe5, 0x01, 0x50, 0xc1, 0xe4, 0x01, 0x00, 0x80, 0xe2,\n\t0x02, 0x00, 0x50, 0xe1, 0xf3, 0xff, 0xff, 0x3a, 0xc8, 0x00, 0xa0, 0xe3, 0x98, 0xff, 0xff, 0xeb,\n\t0x70, 0x40, 0xbd, 0xe8, 0x1e, 0xff, 0x2f, 0xe1, 0x01, 0x0c, 0x00, 0x02, 0x01, 0x02, 0x00, 0x02,\n\t0x00, 0x01, 0x00, 0x02\n};\n\nstruct atmel_private {\n\tvoid *card;  \n\tint (*present_callback)(void *);  \n\tchar firmware_id[32];\n\tAtmelFWType firmware_type;\n\tu8 *firmware;\n\tint firmware_length;\n\tstruct timer_list management_timer;\n\tstruct net_device *dev;\n\tstruct device *sys_dev;\n\tstruct iw_statistics wstats;\n\tspinlock_t irqlock, timerlock;\t \n\tenum { BUS_TYPE_PCCARD, BUS_TYPE_PCI } bus_type;\n\tenum {\n\t\tCARD_TYPE_PARALLEL_FLASH,\n\t\tCARD_TYPE_SPI_FLASH,\n\t\tCARD_TYPE_EEPROM\n\t} card_type;\n\tint do_rx_crc;  \n\tint probe_crc;  \n\tint crc_ok_cnt, crc_ko_cnt;  \n\tu16 rx_desc_head;\n\tu16 tx_desc_free, tx_desc_head, tx_desc_tail, tx_desc_previous;\n\tu16 tx_free_mem, tx_buff_head, tx_buff_tail;\n\n\tu16 frag_seq, frag_len, frag_no;\n\tu8 frag_source[6];\n\n\tu8 wep_is_on, default_key, exclude_unencrypted, encryption_level;\n\tu8 group_cipher_suite, pairwise_cipher_suite;\n\tu8 wep_keys[MAX_ENCRYPTION_KEYS][MAX_ENCRYPTION_KEY_SIZE];\n\tint wep_key_len[MAX_ENCRYPTION_KEYS];\n\tint use_wpa, radio_on_broken;  \n\n\tu16 host_info_base;\n\tstruct host_info_struct {\n\t\t \n\t\tu8 volatile int_status;\n\t\tu8 volatile int_mask;\n\t\tu8 volatile lockout_host;\n\t\tu8 volatile lockout_mac;\n\n\t\tu16 tx_buff_pos;\n\t\tu16 tx_buff_size;\n\t\tu16 tx_desc_pos;\n\t\tu16 tx_desc_count;\n\n\t\tu16 rx_buff_pos;\n\t\tu16 rx_buff_size;\n\t\tu16 rx_desc_pos;\n\t\tu16 rx_desc_count;\n\n\t\tu16 build_version;\n\t\tu16 command_pos;\n\n\t\tu16 major_version;\n\t\tu16 minor_version;\n\n\t\tu16 func_ctrl;\n\t\tu16 mac_status;\n\t\tu16 generic_IRQ_type;\n\t\tu8  reserved[2];\n\t} host_info;\n\n\tenum {\n\t\tSTATION_STATE_SCANNING,\n\t\tSTATION_STATE_JOINNING,\n\t\tSTATION_STATE_AUTHENTICATING,\n\t\tSTATION_STATE_ASSOCIATING,\n\t\tSTATION_STATE_READY,\n\t\tSTATION_STATE_REASSOCIATING,\n\t\tSTATION_STATE_DOWN,\n\t\tSTATION_STATE_MGMT_ERROR\n\t} station_state;\n\n\tint operating_mode, power_mode;\n\tunsigned long last_qual;\n\tint beacons_this_sec;\n\tint channel;\n\tint reg_domain, config_reg_domain;\n\tint tx_rate;\n\tint auto_tx_rate;\n\tint rts_threshold;\n\tint frag_threshold;\n\tint long_retry, short_retry;\n\tint preamble;\n\tint default_beacon_period, beacon_period, listen_interval;\n\tint CurrentAuthentTransactionSeqNum, ExpectedAuthentTransactionSeqNum;\n\tint AuthenticationRequestRetryCnt, AssociationRequestRetryCnt, ReAssociationRequestRetryCnt;\n\tenum {\n\t\tSITE_SURVEY_IDLE,\n\t\tSITE_SURVEY_IN_PROGRESS,\n\t\tSITE_SURVEY_COMPLETED\n\t} site_survey_state;\n\tunsigned long last_survey;\n\n\tint station_was_associated, station_is_associated;\n\tint fast_scan;\n\n\tstruct bss_info {\n\t\tint channel;\n\t\tint SSIDsize;\n\t\tint RSSI;\n\t\tint UsingWEP;\n\t\tint preamble;\n\t\tint beacon_period;\n\t\tint BSStype;\n\t\tu8 BSSID[6];\n\t\tu8 SSID[MAX_SSID_LENGTH];\n\t} BSSinfo[MAX_BSS_ENTRIES];\n\tint BSS_list_entries, current_BSS;\n\tint connect_to_any_BSS;\n\tint SSID_size, new_SSID_size;\n\tu8 CurrentBSSID[6], BSSID[6];\n\tu8 SSID[MAX_SSID_LENGTH], new_SSID[MAX_SSID_LENGTH];\n\tu64 last_beacon_timestamp;\n\tu8 rx_buf[MAX_WIRELESS_BODY];\n};\n\nstatic u8 atmel_basic_rates[4] = {0x82, 0x84, 0x0b, 0x16};\n\nstatic const struct {\n\tint reg_domain;\n\tint min, max;\n\tchar *name;\n} channel_table[] = { { REG_DOMAIN_FCC, 1, 11, \"USA\" },\n\t\t      { REG_DOMAIN_DOC, 1, 11, \"Canada\" },\n\t\t      { REG_DOMAIN_ETSI, 1, 13, \"Europe\" },\n\t\t      { REG_DOMAIN_SPAIN, 10, 11, \"Spain\" },\n\t\t      { REG_DOMAIN_FRANCE, 10, 13, \"France\" },\n\t\t      { REG_DOMAIN_MKK, 14, 14, \"MKK\" },\n\t\t      { REG_DOMAIN_MKK1, 1, 14, \"MKK1\" },\n\t\t      { REG_DOMAIN_ISRAEL, 3, 9, \"Israel\"} };\n\nstatic void build_wpa_mib(struct atmel_private *priv);\nstatic int atmel_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic void atmel_copy_to_card(struct net_device *dev, u16 dest,\n\t\t\t       const unsigned char *src, u16 len);\nstatic void atmel_copy_to_host(struct net_device *dev, unsigned char *dest,\n\t\t\t       u16 src, u16 len);\nstatic void atmel_set_gcr(struct net_device *dev, u16 mask);\nstatic void atmel_clear_gcr(struct net_device *dev, u16 mask);\nstatic int atmel_lock_mac(struct atmel_private *priv);\nstatic void atmel_wmem32(struct atmel_private *priv, u16 pos, u32 data);\nstatic void atmel_command_irq(struct atmel_private *priv);\nstatic int atmel_validate_channel(struct atmel_private *priv, int channel);\nstatic void atmel_management_frame(struct atmel_private *priv,\n\t\t\t\t   struct ieee80211_hdr *header,\n\t\t\t\t   u16 frame_len, u8 rssi);\nstatic void atmel_management_timer(struct timer_list *t);\nstatic void atmel_send_command(struct atmel_private *priv, int command,\n\t\t\t       void *cmd, int cmd_size);\nstatic int atmel_send_command_wait(struct atmel_private *priv, int command,\n\t\t\t\t   void *cmd, int cmd_size);\nstatic void atmel_transmit_management_frame(struct atmel_private *priv,\n\t\t\t\t\t    struct ieee80211_hdr *header,\n\t\t\t\t\t    u8 *body, int body_len);\n\nstatic u8 atmel_get_mib8(struct atmel_private *priv, u8 type, u8 index);\nstatic void atmel_set_mib8(struct atmel_private *priv, u8 type, u8 index,\n\t\t\t   u8 data);\nstatic void atmel_set_mib16(struct atmel_private *priv, u8 type, u8 index,\n\t\t\t    u16 data);\nstatic void atmel_set_mib(struct atmel_private *priv, u8 type, u8 index,\n\t\t\t  const u8 *data, int data_len);\nstatic void atmel_get_mib(struct atmel_private *priv, u8 type, u8 index,\n\t\t\t  u8 *data, int data_len);\nstatic void atmel_scan(struct atmel_private *priv, int specific_ssid);\nstatic void atmel_join_bss(struct atmel_private *priv, int bss_index);\nstatic void atmel_smooth_qual(struct atmel_private *priv);\nstatic void atmel_writeAR(struct net_device *dev, u16 data);\nstatic int probe_atmel_card(struct net_device *dev);\nstatic int reset_atmel_card(struct net_device *dev);\nstatic void atmel_enter_state(struct atmel_private *priv, int new_state);\nint atmel_open (struct net_device *dev);\n\nstatic inline u16 atmel_hi(struct atmel_private *priv, u16 offset)\n{\n\treturn priv->host_info_base + offset;\n}\n\nstatic inline u16 atmel_co(struct atmel_private *priv, u16 offset)\n{\n\treturn priv->host_info.command_pos + offset;\n}\n\nstatic inline u16 atmel_rx(struct atmel_private *priv, u16 offset, u16 desc)\n{\n\treturn priv->host_info.rx_desc_pos + (sizeof(struct rx_desc) * desc) + offset;\n}\n\nstatic inline u16 atmel_tx(struct atmel_private *priv, u16 offset, u16 desc)\n{\n\treturn priv->host_info.tx_desc_pos + (sizeof(struct tx_desc) * desc) + offset;\n}\n\nstatic inline u8 atmel_read8(struct net_device *dev, u16 offset)\n{\n\treturn inb(dev->base_addr + offset);\n}\n\nstatic inline void atmel_write8(struct net_device *dev, u16 offset, u8 data)\n{\n\toutb(data, dev->base_addr + offset);\n}\n\nstatic inline u16 atmel_read16(struct net_device *dev, u16 offset)\n{\n\treturn inw(dev->base_addr + offset);\n}\n\nstatic inline void atmel_write16(struct net_device *dev, u16 offset, u16 data)\n{\n\toutw(data, dev->base_addr + offset);\n}\n\nstatic inline u8 atmel_rmem8(struct atmel_private *priv, u16 pos)\n{\n\tatmel_writeAR(priv->dev, pos);\n\treturn atmel_read8(priv->dev, DR);\n}\n\nstatic inline void atmel_wmem8(struct atmel_private *priv, u16 pos, u16 data)\n{\n\tatmel_writeAR(priv->dev, pos);\n\tatmel_write8(priv->dev, DR, data);\n}\n\nstatic inline u16 atmel_rmem16(struct atmel_private *priv, u16 pos)\n{\n\tatmel_writeAR(priv->dev, pos);\n\treturn atmel_read16(priv->dev, DR);\n}\n\nstatic inline void atmel_wmem16(struct atmel_private *priv, u16 pos, u16 data)\n{\n\tatmel_writeAR(priv->dev, pos);\n\tatmel_write16(priv->dev, DR, data);\n}\n\nstatic const struct iw_handler_def atmel_handler_def;\n\nstatic void tx_done_irq(struct atmel_private *priv)\n{\n\tint i;\n\n\tfor (i = 0;\n\t     atmel_rmem8(priv, atmel_tx(priv, TX_DESC_FLAGS_OFFSET, priv->tx_desc_head)) == TX_DONE &&\n\t\t     i < priv->host_info.tx_desc_count;\n\t     i++) {\n\t\tu8 status = atmel_rmem8(priv, atmel_tx(priv, TX_DESC_STATUS_OFFSET, priv->tx_desc_head));\n\t\tu16 msdu_size = atmel_rmem16(priv, atmel_tx(priv, TX_DESC_SIZE_OFFSET, priv->tx_desc_head));\n\t\tu8 type = atmel_rmem8(priv, atmel_tx(priv, TX_DESC_PACKET_TYPE_OFFSET, priv->tx_desc_head));\n\n\t\tatmel_wmem8(priv, atmel_tx(priv, TX_DESC_FLAGS_OFFSET, priv->tx_desc_head), 0);\n\n\t\tpriv->tx_free_mem += msdu_size;\n\t\tpriv->tx_desc_free++;\n\n\t\tif (priv->tx_buff_head + msdu_size > (priv->host_info.tx_buff_pos + priv->host_info.tx_buff_size))\n\t\t\tpriv->tx_buff_head = 0;\n\t\telse\n\t\t\tpriv->tx_buff_head += msdu_size;\n\n\t\tif (priv->tx_desc_head < (priv->host_info.tx_desc_count - 1))\n\t\t\tpriv->tx_desc_head++ ;\n\t\telse\n\t\t\tpriv->tx_desc_head = 0;\n\n\t\tif (type == TX_PACKET_TYPE_DATA) {\n\t\t\tif (status == TX_STATUS_SUCCESS)\n\t\t\t\tpriv->dev->stats.tx_packets++;\n\t\t\telse\n\t\t\t\tpriv->dev->stats.tx_errors++;\n\t\t\tnetif_wake_queue(priv->dev);\n\t\t}\n\t}\n}\n\nstatic u16 find_tx_buff(struct atmel_private *priv, u16 len)\n{\n\tu16 bottom_free = priv->host_info.tx_buff_size - priv->tx_buff_tail;\n\n\tif (priv->tx_desc_free == 3 || priv->tx_free_mem < len)\n\t\treturn 0;\n\n\tif (bottom_free >= len)\n\t\treturn priv->host_info.tx_buff_pos + priv->tx_buff_tail;\n\n\tif (priv->tx_free_mem - bottom_free >= len) {\n\t\tpriv->tx_buff_tail = 0;\n\t\treturn priv->host_info.tx_buff_pos;\n\t}\n\n\treturn 0;\n}\n\nstatic void tx_update_descriptor(struct atmel_private *priv, int is_bcast,\n\t\t\t\t u16 len, u16 buff, u8 type)\n{\n\tatmel_wmem16(priv, atmel_tx(priv, TX_DESC_POS_OFFSET, priv->tx_desc_tail), buff);\n\tatmel_wmem16(priv, atmel_tx(priv, TX_DESC_SIZE_OFFSET, priv->tx_desc_tail), len);\n\tif (!priv->use_wpa)\n\t\tatmel_wmem16(priv, atmel_tx(priv, TX_DESC_HOST_LENGTH_OFFSET, priv->tx_desc_tail), len);\n\tatmel_wmem8(priv, atmel_tx(priv, TX_DESC_PACKET_TYPE_OFFSET, priv->tx_desc_tail), type);\n\tatmel_wmem8(priv, atmel_tx(priv, TX_DESC_RATE_OFFSET, priv->tx_desc_tail), priv->tx_rate);\n\tatmel_wmem8(priv, atmel_tx(priv, TX_DESC_RETRY_OFFSET, priv->tx_desc_tail), 0);\n\tif (priv->use_wpa) {\n\t\tint cipher_type, cipher_length;\n\t\tif (is_bcast) {\n\t\t\tcipher_type = priv->group_cipher_suite;\n\t\t\tif (cipher_type == CIPHER_SUITE_WEP_64 ||\n\t\t\t    cipher_type == CIPHER_SUITE_WEP_128)\n\t\t\t\tcipher_length = 8;\n\t\t\telse if (cipher_type == CIPHER_SUITE_TKIP)\n\t\t\t\tcipher_length = 12;\n\t\t\telse if (priv->pairwise_cipher_suite == CIPHER_SUITE_WEP_64 ||\n\t\t\t\t priv->pairwise_cipher_suite == CIPHER_SUITE_WEP_128) {\n\t\t\t\tcipher_type = priv->pairwise_cipher_suite;\n\t\t\t\tcipher_length = 8;\n\t\t\t} else {\n\t\t\t\tcipher_type = CIPHER_SUITE_NONE;\n\t\t\t\tcipher_length = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tcipher_type = priv->pairwise_cipher_suite;\n\t\t\tif (cipher_type == CIPHER_SUITE_WEP_64 ||\n\t\t\t    cipher_type == CIPHER_SUITE_WEP_128)\n\t\t\t\tcipher_length = 8;\n\t\t\telse if (cipher_type == CIPHER_SUITE_TKIP)\n\t\t\t\tcipher_length = 12;\n\t\t\telse if (priv->group_cipher_suite == CIPHER_SUITE_WEP_64 ||\n\t\t\t\t priv->group_cipher_suite == CIPHER_SUITE_WEP_128) {\n\t\t\t\tcipher_type = priv->group_cipher_suite;\n\t\t\t\tcipher_length = 8;\n\t\t\t} else {\n\t\t\t\tcipher_type = CIPHER_SUITE_NONE;\n\t\t\t\tcipher_length = 0;\n\t\t\t}\n\t\t}\n\n\t\tatmel_wmem8(priv, atmel_tx(priv, TX_DESC_CIPHER_TYPE_OFFSET, priv->tx_desc_tail),\n\t\t\t    cipher_type);\n\t\tatmel_wmem8(priv, atmel_tx(priv, TX_DESC_CIPHER_LENGTH_OFFSET, priv->tx_desc_tail),\n\t\t\t    cipher_length);\n\t}\n\tatmel_wmem32(priv, atmel_tx(priv, TX_DESC_NEXT_OFFSET, priv->tx_desc_tail), 0x80000000L);\n\tatmel_wmem8(priv, atmel_tx(priv, TX_DESC_FLAGS_OFFSET, priv->tx_desc_tail), TX_FIRM_OWN);\n\tif (priv->tx_desc_previous != priv->tx_desc_tail)\n\t\tatmel_wmem32(priv, atmel_tx(priv, TX_DESC_NEXT_OFFSET, priv->tx_desc_previous), 0);\n\tpriv->tx_desc_previous = priv->tx_desc_tail;\n\tif (priv->tx_desc_tail < (priv->host_info.tx_desc_count - 1))\n\t\tpriv->tx_desc_tail++;\n\telse\n\t\tpriv->tx_desc_tail = 0;\n\tpriv->tx_desc_free--;\n\tpriv->tx_free_mem -= len;\n}\n\nstatic netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tstruct ieee80211_hdr header;\n\tunsigned long flags;\n\tu16 buff, frame_ctl, len = (ETH_ZLEN < skb->len) ? skb->len : ETH_ZLEN;\n\n\tif (priv->card && priv->present_callback &&\n\t    !(*priv->present_callback)(priv->card)) {\n\t\tdev->stats.tx_errors++;\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (priv->station_state != STATION_STATE_READY) {\n\t\tdev->stats.tx_errors++;\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tspin_lock_bh(&priv->timerlock);\n\t \n\tspin_lock_irqsave(&priv->irqlock, flags);\n\t \n\n\t \n\n\tif (!(buff = find_tx_buff(priv, len + 18))) {\n\t\tdev->stats.tx_dropped++;\n\t\tspin_unlock_irqrestore(&priv->irqlock, flags);\n\t\tspin_unlock_bh(&priv->timerlock);\n\t\tnetif_stop_queue(dev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tframe_ctl = IEEE80211_FTYPE_DATA;\n\theader.duration_id = 0;\n\theader.seq_ctrl = 0;\n\tif (priv->wep_is_on)\n\t\tframe_ctl |= IEEE80211_FCTL_PROTECTED;\n\tif (priv->operating_mode == IW_MODE_ADHOC) {\n\t\tskb_copy_from_linear_data(skb, &header.addr1, ETH_ALEN);\n\t\tmemcpy(&header.addr2, dev->dev_addr, ETH_ALEN);\n\t\tmemcpy(&header.addr3, priv->BSSID, ETH_ALEN);\n\t} else {\n\t\tframe_ctl |= IEEE80211_FCTL_TODS;\n\t\tmemcpy(&header.addr1, priv->CurrentBSSID, ETH_ALEN);\n\t\tmemcpy(&header.addr2, dev->dev_addr, ETH_ALEN);\n\t\tskb_copy_from_linear_data(skb, &header.addr3, ETH_ALEN);\n\t}\n\n\tif (priv->use_wpa)\n\t\tmemcpy(&header.addr4, rfc1042_header, ETH_ALEN);\n\n\theader.frame_control = cpu_to_le16(frame_ctl);\n\t \n\tatmel_copy_to_card(dev, buff, (unsigned char *)&header, DATA_FRAME_WS_HEADER_SIZE);\n\t \n\tatmel_copy_to_card(dev, buff + DATA_FRAME_WS_HEADER_SIZE, skb->data + 12, len - 12);\n\tpriv->tx_buff_tail += len - 12 + DATA_FRAME_WS_HEADER_SIZE;\n\n\t \n\ttx_update_descriptor(priv, *(skb->data) & 0x01, len + 18, buff, TX_PACKET_TYPE_DATA);\n\tdev->stats.tx_bytes += len;\n\n\tspin_unlock_irqrestore(&priv->irqlock, flags);\n\tspin_unlock_bh(&priv->timerlock);\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void atmel_transmit_management_frame(struct atmel_private *priv,\n\t\t\t\t\t    struct ieee80211_hdr *header,\n\t\t\t\t\t    u8 *body, int body_len)\n{\n\tu16 buff;\n\tint len = MGMT_FRAME_BODY_OFFSET + body_len;\n\n\tif (!(buff = find_tx_buff(priv, len)))\n\t\treturn;\n\n\tatmel_copy_to_card(priv->dev, buff, (u8 *)header, MGMT_FRAME_BODY_OFFSET);\n\tatmel_copy_to_card(priv->dev, buff + MGMT_FRAME_BODY_OFFSET, body, body_len);\n\tpriv->tx_buff_tail += len;\n\ttx_update_descriptor(priv, header->addr1[0] & 0x01, len, buff, TX_PACKET_TYPE_MGMT);\n}\n\nstatic void fast_rx_path(struct atmel_private *priv,\n\t\t\t struct ieee80211_hdr *header,\n\t\t\t u16 msdu_size, u16 rx_packet_loc, u32 crc)\n{\n\t \n\tu8 mac4[6];\n\tstruct sk_buff\t*skb;\n\tunsigned char *skbp;\n\n\t \n\tatmel_copy_to_host(priv->dev, mac4, rx_packet_loc + 24, 6);\n\tmsdu_size -= 6;\n\n\tif (priv->do_rx_crc) {\n\t\tcrc = crc32_le(crc, mac4, 6);\n\t\tmsdu_size -= 4;\n\t}\n\n\tif (!(skb = dev_alloc_skb(msdu_size + 14))) {\n\t\tpriv->dev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\n\tskb_reserve(skb, 2);\n\tskbp = skb_put(skb, msdu_size + 12);\n\tatmel_copy_to_host(priv->dev, skbp + 12, rx_packet_loc + 30, msdu_size);\n\n\tif (priv->do_rx_crc) {\n\t\tu32 netcrc;\n\t\tcrc = crc32_le(crc, skbp + 12, msdu_size);\n\t\tatmel_copy_to_host(priv->dev, (void *)&netcrc, rx_packet_loc + 30 + msdu_size, 4);\n\t\tif ((crc ^ 0xffffffff) != netcrc) {\n\t\t\tpriv->dev->stats.rx_crc_errors++;\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmemcpy(skbp, header->addr1, ETH_ALEN);  \n\tif (le16_to_cpu(header->frame_control) & IEEE80211_FCTL_FROMDS)\n\t\tmemcpy(&skbp[ETH_ALEN], header->addr3, ETH_ALEN);\n\telse\n\t\tmemcpy(&skbp[ETH_ALEN], header->addr2, ETH_ALEN);  \n\n\tskb->protocol = eth_type_trans(skb, priv->dev);\n\tskb->ip_summed = CHECKSUM_NONE;\n\tnetif_rx(skb);\n\tpriv->dev->stats.rx_bytes += 12 + msdu_size;\n\tpriv->dev->stats.rx_packets++;\n}\n\n \nstatic int probe_crc(struct atmel_private *priv, u16 packet_loc, u16 msdu_size)\n{\n\tint i = msdu_size - 4;\n\tu32 netcrc, crc = 0xffffffff;\n\n\tif (msdu_size < 4)\n\t\treturn 0;\n\n\tatmel_copy_to_host(priv->dev, (void *)&netcrc, packet_loc + i, 4);\n\n\tatmel_writeAR(priv->dev, packet_loc);\n\twhile (i--) {\n\t\tu8 octet = atmel_read8(priv->dev, DR);\n\t\tcrc = crc32_le(crc, &octet, 1);\n\t}\n\n\treturn (crc ^ 0xffffffff) == netcrc;\n}\n\nstatic void frag_rx_path(struct atmel_private *priv,\n\t\t\t struct ieee80211_hdr *header,\n\t\t\t u16 msdu_size, u16 rx_packet_loc, u32 crc, u16 seq_no,\n\t\t\t u8 frag_no, int more_frags)\n{\n\tu8 mac4[ETH_ALEN];\n\tu8 source[ETH_ALEN];\n\tstruct sk_buff *skb;\n\n\tif (le16_to_cpu(header->frame_control) & IEEE80211_FCTL_FROMDS)\n\t\tmemcpy(source, header->addr3, ETH_ALEN);\n\telse\n\t\tmemcpy(source, header->addr2, ETH_ALEN);\n\n\trx_packet_loc += 24;  \n\n\tif (priv->do_rx_crc)\n\t\tmsdu_size -= 4;\n\n\tif (frag_no == 0) {  \n\t\tatmel_copy_to_host(priv->dev, mac4, rx_packet_loc, ETH_ALEN);\n\t\tmsdu_size -= ETH_ALEN;\n\t\trx_packet_loc += ETH_ALEN;\n\n\t\tif (priv->do_rx_crc)\n\t\t\tcrc = crc32_le(crc, mac4, 6);\n\n\t\tpriv->frag_seq = seq_no;\n\t\tpriv->frag_no = 1;\n\t\tpriv->frag_len = msdu_size;\n\t\tmemcpy(priv->frag_source, source, ETH_ALEN);\n\t\tmemcpy(&priv->rx_buf[ETH_ALEN], source, ETH_ALEN);\n\t\tmemcpy(priv->rx_buf, header->addr1, ETH_ALEN);\n\n\t\tatmel_copy_to_host(priv->dev, &priv->rx_buf[12], rx_packet_loc, msdu_size);\n\n\t\tif (priv->do_rx_crc) {\n\t\t\tu32 netcrc;\n\t\t\tcrc = crc32_le(crc, &priv->rx_buf[12], msdu_size);\n\t\t\tatmel_copy_to_host(priv->dev, (void *)&netcrc, rx_packet_loc + msdu_size, 4);\n\t\t\tif ((crc ^ 0xffffffff) != netcrc) {\n\t\t\t\tpriv->dev->stats.rx_crc_errors++;\n\t\t\t\teth_broadcast_addr(priv->frag_source);\n\t\t\t}\n\t\t}\n\n\t} else if (priv->frag_no == frag_no &&\n\t\t   priv->frag_seq == seq_no &&\n\t\t   memcmp(priv->frag_source, source, ETH_ALEN) == 0) {\n\n\t\tatmel_copy_to_host(priv->dev, &priv->rx_buf[12 + priv->frag_len],\n\t\t\t\t   rx_packet_loc, msdu_size);\n\t\tif (priv->do_rx_crc) {\n\t\t\tu32 netcrc;\n\t\t\tcrc = crc32_le(crc,\n\t\t\t\t       &priv->rx_buf[12 + priv->frag_len],\n\t\t\t\t       msdu_size);\n\t\t\tatmel_copy_to_host(priv->dev, (void *)&netcrc, rx_packet_loc + msdu_size, 4);\n\t\t\tif ((crc ^ 0xffffffff) != netcrc) {\n\t\t\t\tpriv->dev->stats.rx_crc_errors++;\n\t\t\t\teth_broadcast_addr(priv->frag_source);\n\t\t\t\tmore_frags = 1;  \n\t\t\t}\n\t\t}\n\n\t\tpriv->frag_len += msdu_size;\n\t\tpriv->frag_no++;\n\n\t\tif (!more_frags) {  \n\t\t\teth_broadcast_addr(priv->frag_source);\n\t\t\tif (!(skb = dev_alloc_skb(priv->frag_len + 14))) {\n\t\t\t\tpriv->dev->stats.rx_dropped++;\n\t\t\t} else {\n\t\t\t\tskb_reserve(skb, 2);\n\t\t\t\tskb_put_data(skb, priv->rx_buf,\n\t\t\t\t             priv->frag_len + 12);\n\t\t\t\tskb->protocol = eth_type_trans(skb, priv->dev);\n\t\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tpriv->dev->stats.rx_bytes += priv->frag_len + 12;\n\t\t\t\tpriv->dev->stats.rx_packets++;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpriv->wstats.discard.fragment++;\n}\n\nstatic void rx_done_irq(struct atmel_private *priv)\n{\n\tint i;\n\tstruct ieee80211_hdr header;\n\n\tfor (i = 0;\n\t     atmel_rmem8(priv, atmel_rx(priv, RX_DESC_FLAGS_OFFSET, priv->rx_desc_head)) == RX_DESC_FLAG_VALID &&\n\t\t     i < priv->host_info.rx_desc_count;\n\t     i++) {\n\n\t\tu16 msdu_size, rx_packet_loc, frame_ctl, seq_control;\n\t\tu8 status = atmel_rmem8(priv, atmel_rx(priv, RX_DESC_STATUS_OFFSET, priv->rx_desc_head));\n\t\tu32 crc = 0xffffffff;\n\n\t\tif (status != RX_STATUS_SUCCESS) {\n\t\t\tif (status == 0xc1)  \n\t\t\t\tpriv->wstats.discard.nwid++;\n\t\t\telse\n\t\t\t\tpriv->dev->stats.rx_errors++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tmsdu_size = atmel_rmem16(priv, atmel_rx(priv, RX_DESC_MSDU_SIZE_OFFSET, priv->rx_desc_head));\n\t\trx_packet_loc = atmel_rmem16(priv, atmel_rx(priv, RX_DESC_MSDU_POS_OFFSET, priv->rx_desc_head));\n\n\t\tif (msdu_size < 30) {\n\t\t\tpriv->dev->stats.rx_errors++;\n\t\t\tgoto next;\n\t\t}\n\n\t\t \n\t\tatmel_copy_to_host(priv->dev, (char *)&header, rx_packet_loc, 24);\n\t\tframe_ctl = le16_to_cpu(header.frame_control);\n\t\tseq_control = le16_to_cpu(header.seq_ctrl);\n\n\t\t \n\t\tif (priv->probe_crc) {\n\t\t\tif (!priv->wep_is_on || !(frame_ctl & IEEE80211_FCTL_PROTECTED)) {\n\t\t\t\tpriv->do_rx_crc = probe_crc(priv, rx_packet_loc, msdu_size);\n\t\t\t} else {\n\t\t\t\tpriv->do_rx_crc = probe_crc(priv, rx_packet_loc + 24, msdu_size - 24);\n\t\t\t}\n\t\t\tif (priv->do_rx_crc) {\n\t\t\t\tif (priv->crc_ok_cnt++ > 5)\n\t\t\t\t\tpriv->probe_crc = 0;\n\t\t\t} else {\n\t\t\t\tif (priv->crc_ko_cnt++ > 5)\n\t\t\t\t\tpriv->probe_crc = 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (priv->do_rx_crc && (!priv->wep_is_on || !(frame_ctl & IEEE80211_FCTL_PROTECTED))) {\n\t\t\tcrc = crc32_le(0xffffffff, (unsigned char *)&header, 24);\n\t\t}\n\t\tmsdu_size -= 24;  \n\n\t\tif ((frame_ctl & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA) {\n\t\t\tint more_fragments = frame_ctl & IEEE80211_FCTL_MOREFRAGS;\n\t\t\tu8 packet_fragment_no = seq_control & IEEE80211_SCTL_FRAG;\n\t\t\tu16 packet_sequence_no = (seq_control & IEEE80211_SCTL_SEQ) >> 4;\n\n\t\t\tif (!more_fragments && packet_fragment_no == 0) {\n\t\t\t\tfast_rx_path(priv, &header, msdu_size, rx_packet_loc, crc);\n\t\t\t} else {\n\t\t\t\tfrag_rx_path(priv, &header, msdu_size, rx_packet_loc, crc,\n\t\t\t\t\t     packet_sequence_no, packet_fragment_no, more_fragments);\n\t\t\t}\n\t\t}\n\n\t\tif ((frame_ctl & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT) {\n\t\t\t \n\t\t\tatmel_copy_to_host(priv->dev, (unsigned char *)&priv->rx_buf, rx_packet_loc + 24, msdu_size);\n\n\t\t\t \n\t\t\teth_broadcast_addr(priv->frag_source);\n\n\t\t\tif (priv->do_rx_crc) {\n\t\t\t\t \n\t\t\t\tmsdu_size -= 4;\n\t\t\t\tcrc = crc32_le(crc, (unsigned char *)&priv->rx_buf, msdu_size);\n\t\t\t\tif ((crc ^ 0xffffffff) != (*((u32 *)&priv->rx_buf[msdu_size]))) {\n\t\t\t\t\tpriv->dev->stats.rx_crc_errors++;\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tatmel_management_frame(priv, &header, msdu_size,\n\t\t\t\t\t       atmel_rmem8(priv, atmel_rx(priv, RX_DESC_RSSI_OFFSET, priv->rx_desc_head)));\n\t\t}\n\nnext:\n\t\t \n\t\tatmel_wmem8(priv, atmel_rx(priv, RX_DESC_FLAGS_OFFSET, priv->rx_desc_head), RX_DESC_FLAG_CONSUMED);\n\n\t\tif (priv->rx_desc_head < (priv->host_info.rx_desc_count - 1))\n\t\t\tpriv->rx_desc_head++;\n\t\telse\n\t\t\tpriv->rx_desc_head = 0;\n\t}\n}\n\nstatic irqreturn_t service_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *) dev_id;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tu8 isr;\n\tint i = -1;\n\tstatic const u8 irq_order[] = {\n\t\tISR_OUT_OF_RANGE,\n\t\tISR_RxCOMPLETE,\n\t\tISR_TxCOMPLETE,\n\t\tISR_RxFRAMELOST,\n\t\tISR_FATAL_ERROR,\n\t\tISR_COMMAND_COMPLETE,\n\t\tISR_IBSS_MERGE,\n\t\tISR_GENERIC_IRQ\n\t};\n\n\tif (priv->card && priv->present_callback &&\n\t    !(*priv->present_callback)(priv->card))\n\t\treturn IRQ_HANDLED;\n\n\t \n\tif (priv->station_state == STATION_STATE_DOWN)\n\t\treturn IRQ_NONE;\n\n\tatmel_clear_gcr(dev, GCR_ENINT);  \n\n\twhile (1) {\n\t\tif (!atmel_lock_mac(priv)) {\n\t\t\t \n\t\t\tprintk(KERN_ALERT \"%s: failed to contact MAC.\\n\", dev->name);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tisr = atmel_rmem8(priv, atmel_hi(priv, IFACE_INT_STATUS_OFFSET));\n\t\tatmel_wmem8(priv, atmel_hi(priv, IFACE_LOCKOUT_MAC_OFFSET), 0);\n\n\t\tif (!isr) {\n\t\t\tatmel_set_gcr(dev, GCR_ENINT);  \n\t\t\treturn i == -1 ? IRQ_NONE : IRQ_HANDLED;\n\t\t}\n\n\t\tatmel_set_gcr(dev, GCR_ACKINT);  \n\n\t\tfor (i = 0; i < ARRAY_SIZE(irq_order); i++)\n\t\t\tif (isr & irq_order[i])\n\t\t\t\tbreak;\n\n\t\tif (!atmel_lock_mac(priv)) {\n\t\t\t \n\t\t\tprintk(KERN_ALERT \"%s: failed to contact MAC.\\n\", dev->name);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tisr = atmel_rmem8(priv, atmel_hi(priv, IFACE_INT_STATUS_OFFSET));\n\t\tisr ^= irq_order[i];\n\t\tatmel_wmem8(priv, atmel_hi(priv, IFACE_INT_STATUS_OFFSET), isr);\n\t\tatmel_wmem8(priv, atmel_hi(priv, IFACE_LOCKOUT_MAC_OFFSET), 0);\n\n\t\tswitch (irq_order[i]) {\n\n\t\tcase ISR_OUT_OF_RANGE:\n\t\t\tif (priv->operating_mode == IW_MODE_INFRA &&\n\t\t\t    priv->station_state == STATION_STATE_READY) {\n\t\t\t\tpriv->station_is_associated = 0;\n\t\t\t\tatmel_scan(priv, 1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ISR_RxFRAMELOST:\n\t\t\tpriv->wstats.discard.misc++;\n\t\t\tfallthrough;\n\t\tcase ISR_RxCOMPLETE:\n\t\t\trx_done_irq(priv);\n\t\t\tbreak;\n\n\t\tcase ISR_TxCOMPLETE:\n\t\t\ttx_done_irq(priv);\n\t\t\tbreak;\n\n\t\tcase ISR_FATAL_ERROR:\n\t\t\tprintk(KERN_ALERT \"%s: *** FATAL error interrupt ***\\n\", dev->name);\n\t\t\tatmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\n\t\t\tbreak;\n\n\t\tcase ISR_COMMAND_COMPLETE:\n\t\t\tatmel_command_irq(priv);\n\t\t\tbreak;\n\n\t\tcase ISR_IBSS_MERGE:\n\t\t\tatmel_get_mib(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_BSSID_POS,\n\t\t\t\t      priv->CurrentBSSID, 6);\n\t\t\t \n\t\t\tif (priv->use_wpa)\n\t\t\t\tbuild_wpa_mib(priv);\n\t\t\tbreak;\n\t\tcase ISR_GENERIC_IRQ:\n\t\t\tprintk(KERN_INFO \"%s: Generic_irq received.\\n\", dev->name);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct iw_statistics *atmel_get_wireless_stats(struct net_device *dev)\n{\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\t \n\tatmel_smooth_qual(priv);\n\n\tpriv->wstats.status = priv->station_state;\n\n\tif (priv->operating_mode == IW_MODE_INFRA) {\n\t\tif (priv->station_state != STATION_STATE_READY) {\n\t\t\tpriv->wstats.qual.qual = 0;\n\t\t\tpriv->wstats.qual.level = 0;\n\t\t\tpriv->wstats.qual.updated = (IW_QUAL_QUAL_INVALID\n\t\t\t\t\t| IW_QUAL_LEVEL_INVALID);\n\t\t}\n\t\tpriv->wstats.qual.noise = 0;\n\t\tpriv->wstats.qual.updated |= IW_QUAL_NOISE_INVALID;\n\t} else {\n\t\t \n\t\tpriv->wstats.qual.qual = 0;\n\t\tpriv->wstats.qual.level\t= 0;\n\t\tpriv->wstats.qual.noise\t= 0;\n\t\tpriv->wstats.qual.updated = IW_QUAL_QUAL_INVALID\n\t\t\t\t\t| IW_QUAL_LEVEL_INVALID\n\t\t\t\t\t| IW_QUAL_NOISE_INVALID;\n\t\tpriv->wstats.miss.beacon = 0;\n\t}\n\n\treturn &priv->wstats;\n}\n\nstatic int atmel_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\treturn atmel_open(dev);\n}\n\nEXPORT_SYMBOL(atmel_open);\n\nint atmel_open(struct net_device *dev)\n{\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tint i, channel, err;\n\n\t \n\tdel_timer_sync(&priv->management_timer);\n\n\t \n\tpriv->station_state = STATION_STATE_DOWN;\n\n\tif (priv->new_SSID_size) {\n\t\tmemcpy(priv->SSID, priv->new_SSID, priv->new_SSID_size);\n\t\tpriv->SSID_size = priv->new_SSID_size;\n\t\tpriv->new_SSID_size = 0;\n\t}\n\tpriv->BSS_list_entries = 0;\n\n\tpriv->AuthenticationRequestRetryCnt = 0;\n\tpriv->AssociationRequestRetryCnt = 0;\n\tpriv->ReAssociationRequestRetryCnt = 0;\n\tpriv->CurrentAuthentTransactionSeqNum = 0x0001;\n\tpriv->ExpectedAuthentTransactionSeqNum = 0x0002;\n\n\tpriv->site_survey_state = SITE_SURVEY_IDLE;\n\tpriv->station_is_associated = 0;\n\n\terr = reset_atmel_card(dev);\n\tif (err)\n\t\treturn err;\n\n\tif (priv->config_reg_domain) {\n\t\tpriv->reg_domain = priv->config_reg_domain;\n\t\tatmel_set_mib8(priv, Phy_Mib_Type, PHY_MIB_REG_DOMAIN_POS, priv->reg_domain);\n\t} else {\n\t\tpriv->reg_domain = atmel_get_mib8(priv, Phy_Mib_Type, PHY_MIB_REG_DOMAIN_POS);\n\t\tfor (i = 0; i < ARRAY_SIZE(channel_table); i++)\n\t\t\tif (priv->reg_domain == channel_table[i].reg_domain)\n\t\t\t\tbreak;\n\t\tif (i == ARRAY_SIZE(channel_table)) {\n\t\t\tpriv->reg_domain = REG_DOMAIN_MKK1;\n\t\t\tprintk(KERN_ALERT \"%s: failed to get regulatory domain: assuming MKK1.\\n\", dev->name);\n\t\t}\n\t}\n\n\tif ((channel = atmel_validate_channel(priv, priv->channel)))\n\t\tpriv->channel = channel;\n\n\t \n\tatmel_scan(priv, 1);\n\n\tatmel_set_gcr(priv->dev, GCR_ENINT);  \n\treturn 0;\n}\n\nstatic int atmel_close(struct net_device *dev)\n{\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\t \n\tif (priv->station_state == STATION_STATE_READY) {\n\t\tunion iwreq_data wrqu;\n\n\t\twrqu.data.length = 0;\n\t\twrqu.data.flags = 0;\n\t\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\t\teth_zero_addr(wrqu.ap_addr.sa_data);\n\t\twireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);\n\t}\n\n\tatmel_enter_state(priv, STATION_STATE_DOWN);\n\n\tif (priv->bus_type == BUS_TYPE_PCCARD)\n\t\tatmel_write16(dev, GCR, 0x0060);\n\tatmel_write16(dev, GCR, 0x0040);\n\treturn 0;\n}\n\nstatic int atmel_validate_channel(struct atmel_private *priv, int channel)\n{\n\t \n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(channel_table); i++)\n\t\tif (priv->reg_domain == channel_table[i].reg_domain) {\n\t\t\tif (channel >= channel_table[i].min &&\n\t\t\t    channel <= channel_table[i].max)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn channel_table[i].min;\n\t\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic int atmel_proc_show(struct seq_file *m, void *v)\n{\n\tstruct atmel_private *priv = m->private;\n\tint i;\n\tchar *s, *r, *c;\n\n\tseq_printf(m, \"Driver version:\\t\\t%d.%d\\n\", DRIVER_MAJOR, DRIVER_MINOR);\n\n\tif (priv->station_state != STATION_STATE_DOWN) {\n\t\tseq_printf(m,\n\t\t\t   \"Firmware version:\\t%d.%d build %d\\n\"\n\t\t\t   \"Firmware location:\\t\",\n\t\t\t   priv->host_info.major_version,\n\t\t\t   priv->host_info.minor_version,\n\t\t\t   priv->host_info.build_version);\n\n\t\tif (priv->card_type != CARD_TYPE_EEPROM)\n\t\t\tseq_puts(m, \"on card\\n\");\n\t\telse if (priv->firmware)\n\t\t\tseq_printf(m, \"%s loaded by host\\n\", priv->firmware_id);\n\t\telse\n\t\t\tseq_printf(m, \"%s loaded by hotplug\\n\", priv->firmware_id);\n\n\t\tswitch (priv->card_type) {\n\t\tcase CARD_TYPE_PARALLEL_FLASH:\n\t\t\tc = \"Parallel flash\";\n\t\t\tbreak;\n\t\tcase CARD_TYPE_SPI_FLASH:\n\t\t\tc = \"SPI flash\\n\";\n\t\t\tbreak;\n\t\tcase CARD_TYPE_EEPROM:\n\t\t\tc = \"EEPROM\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc = \"<unknown>\";\n\t\t}\n\n\t\tr = \"<unknown>\";\n\t\tfor (i = 0; i < ARRAY_SIZE(channel_table); i++)\n\t\t\tif (priv->reg_domain == channel_table[i].reg_domain)\n\t\t\t\tr = channel_table[i].name;\n\n\t\tseq_printf(m, \"MAC memory type:\\t%s\\n\", c);\n\t\tseq_printf(m, \"Regulatory domain:\\t%s\\n\", r);\n\t\tseq_printf(m, \"Host CRC checking:\\t%s\\n\",\n\t\t\t priv->do_rx_crc ? \"On\" : \"Off\");\n\t\tseq_printf(m, \"WPA-capable firmware:\\t%s\\n\",\n\t\t\t priv->use_wpa ? \"Yes\" : \"No\");\n\t}\n\n\tswitch (priv->station_state) {\n\tcase STATION_STATE_SCANNING:\n\t\ts = \"Scanning\";\n\t\tbreak;\n\tcase STATION_STATE_JOINNING:\n\t\ts = \"Joining\";\n\t\tbreak;\n\tcase STATION_STATE_AUTHENTICATING:\n\t\ts = \"Authenticating\";\n\t\tbreak;\n\tcase STATION_STATE_ASSOCIATING:\n\t\ts = \"Associating\";\n\t\tbreak;\n\tcase STATION_STATE_READY:\n\t\ts = \"Ready\";\n\t\tbreak;\n\tcase STATION_STATE_REASSOCIATING:\n\t\ts = \"Reassociating\";\n\t\tbreak;\n\tcase STATION_STATE_MGMT_ERROR:\n\t\ts = \"Management error\";\n\t\tbreak;\n\tcase STATION_STATE_DOWN:\n\t\ts = \"Down\";\n\t\tbreak;\n\tdefault:\n\t\ts = \"<unknown>\";\n\t}\n\n\tseq_printf(m, \"Current state:\\t\\t%s\\n\", s);\n\treturn 0;\n}\n#endif\n\nstatic const struct net_device_ops atmel_netdev_ops = {\n\t.ndo_open \t\t= atmel_open,\n\t.ndo_stop\t\t= atmel_close,\n\t.ndo_set_mac_address \t= atmel_set_mac_address,\n\t.ndo_start_xmit \t= start_tx,\n\t.ndo_do_ioctl \t\t= atmel_ioctl,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstruct net_device *init_atmel_card(unsigned short irq, unsigned long port,\n\t\t\t\t   const AtmelFWType fw_type,\n\t\t\t\t   struct device *sys_dev,\n\t\t\t\t   int (*card_present)(void *), void *card)\n{\n\tstruct net_device *dev;\n\tstruct atmel_private *priv;\n\tint rc;\n\n\t \n\tdev = alloc_etherdev(sizeof(*priv));\n\tif (!dev)\n\t\treturn NULL;\n\n\tif (dev_alloc_name(dev, dev->name) < 0) {\n\t\tprintk(KERN_ERR \"atmel: Couldn't get name!\\n\");\n\t\tgoto err_out_free;\n\t}\n\n\tpriv = netdev_priv(dev);\n\tpriv->dev = dev;\n\tpriv->sys_dev = sys_dev;\n\tpriv->present_callback = card_present;\n\tpriv->card = card;\n\tpriv->firmware = NULL;\n\tpriv->firmware_type = fw_type;\n\tif (firmware)  \n\t\tstrscpy(priv->firmware_id, firmware, sizeof(priv->firmware_id));\n\tpriv->bus_type = card_present ? BUS_TYPE_PCCARD : BUS_TYPE_PCI;\n\tpriv->station_state = STATION_STATE_DOWN;\n\tpriv->do_rx_crc = 0;\n\t \n\tif (priv->bus_type == BUS_TYPE_PCCARD) {\n\t\tpriv->probe_crc = 1;\n\t\tpriv->crc_ok_cnt = priv->crc_ko_cnt = 0;\n\t} else\n\t\tpriv->probe_crc = 0;\n\tpriv->last_qual = jiffies;\n\tpriv->last_beacon_timestamp = 0;\n\tmemset(priv->frag_source, 0xff, sizeof(priv->frag_source));\n\teth_zero_addr(priv->BSSID);\n\tpriv->CurrentBSSID[0] = 0xFF;  \n\tpriv->station_was_associated = 0;\n\n\tpriv->last_survey = jiffies;\n\tpriv->preamble = LONG_PREAMBLE;\n\tpriv->operating_mode = IW_MODE_INFRA;\n\tpriv->connect_to_any_BSS = 0;\n\tpriv->config_reg_domain = 0;\n\tpriv->reg_domain = 0;\n\tpriv->tx_rate = 3;\n\tpriv->auto_tx_rate = 1;\n\tpriv->channel = 4;\n\tpriv->power_mode = 0;\n\tpriv->SSID[0] = '\\0';\n\tpriv->SSID_size = 0;\n\tpriv->new_SSID_size = 0;\n\tpriv->frag_threshold = 2346;\n\tpriv->rts_threshold = 2347;\n\tpriv->short_retry = 7;\n\tpriv->long_retry = 4;\n\n\tpriv->wep_is_on = 0;\n\tpriv->default_key = 0;\n\tpriv->encryption_level = 0;\n\tpriv->exclude_unencrypted = 0;\n\tpriv->group_cipher_suite = priv->pairwise_cipher_suite = CIPHER_SUITE_NONE;\n\tpriv->use_wpa = 0;\n\tmemset(priv->wep_keys, 0, sizeof(priv->wep_keys));\n\tmemset(priv->wep_key_len, 0, sizeof(priv->wep_key_len));\n\n\tpriv->default_beacon_period = priv->beacon_period = 100;\n\tpriv->listen_interval = 1;\n\n\ttimer_setup(&priv->management_timer, atmel_management_timer, 0);\n\tspin_lock_init(&priv->irqlock);\n\tspin_lock_init(&priv->timerlock);\n\n\tdev->netdev_ops = &atmel_netdev_ops;\n\tdev->wireless_handlers = &atmel_handler_def;\n\tdev->irq = irq;\n\tdev->base_addr = port;\n\n\t \n\tdev->min_mtu = 68;\n\tdev->max_mtu = MAX_WIRELESS_BODY - ETH_FCS_LEN;\n\n\tSET_NETDEV_DEV(dev, sys_dev);\n\n\tif ((rc = request_irq(dev->irq, service_interrupt, IRQF_SHARED, dev->name, dev))) {\n\t\tprintk(KERN_ERR \"%s: register interrupt %d failed, rc %d\\n\", dev->name, irq, rc);\n\t\tgoto err_out_free;\n\t}\n\n\tif (!request_region(dev->base_addr, 32,\n\t\t\t    priv->bus_type == BUS_TYPE_PCCARD ?  \"atmel_cs\" : \"atmel_pci\")) {\n\t\tgoto err_out_irq;\n\t}\n\n\tif (register_netdev(dev))\n\t\tgoto err_out_res;\n\n\tif (!probe_atmel_card(dev)) {\n\t\tunregister_netdev(dev);\n\t\tgoto err_out_res;\n\t}\n\n\tnetif_carrier_off(dev);\n\n\tif (!proc_create_single_data(\"driver/atmel\", 0, NULL, atmel_proc_show,\n\t\t\tpriv))\n\t\tprintk(KERN_WARNING \"atmel: unable to create /proc entry.\\n\");\n\n\tprintk(KERN_INFO \"%s: Atmel at76c50x. Version %d.%d. MAC %pM\\n\",\n\t       dev->name, DRIVER_MAJOR, DRIVER_MINOR, dev->dev_addr);\n\n\treturn dev;\n\nerr_out_res:\n\trelease_region(dev->base_addr, 32);\nerr_out_irq:\n\tfree_irq(dev->irq, dev);\nerr_out_free:\n\tfree_netdev(dev);\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(init_atmel_card);\n\nvoid stop_atmel_card(struct net_device *dev)\n{\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\t \n\tif (priv->bus_type == BUS_TYPE_PCCARD)\n\t\tatmel_write16(dev, GCR, 0x0060);\n\tatmel_write16(dev, GCR, 0x0040);\n\n\tdel_timer_sync(&priv->management_timer);\n\tunregister_netdev(dev);\n\tremove_proc_entry(\"driver/atmel\", NULL);\n\tfree_irq(dev->irq, dev);\n\tkfree(priv->firmware);\n\trelease_region(dev->base_addr, 32);\n\tfree_netdev(dev);\n}\n\nEXPORT_SYMBOL(stop_atmel_card);\n\nstatic int atmel_set_essid(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu,\n\t\t\t   char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->essid;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\t \n\tif (dwrq->flags == 0) {\n\t\tpriv->connect_to_any_BSS = 1;\n\t} else {\n\t\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\n\t\tpriv->connect_to_any_BSS = 0;\n\n\t\t \n\t\tif (dwrq->length > MAX_SSID_LENGTH)\n\t\t\t return -E2BIG;\n\t\tif (index != 0)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(priv->new_SSID, extra, dwrq->length);\n\t\tpriv->new_SSID_size = dwrq->length;\n\t}\n\n\treturn -EINPROGRESS;\n}\n\nstatic int atmel_get_essid(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu,\n\t\t\t   char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->essid;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\t \n\tif (priv->new_SSID_size != 0) {\n\t\tmemcpy(extra, priv->new_SSID, priv->new_SSID_size);\n\t\tdwrq->length = priv->new_SSID_size;\n\t} else {\n\t\tmemcpy(extra, priv->SSID, priv->SSID_size);\n\t\tdwrq->length = priv->SSID_size;\n\t}\n\n\tdwrq->flags = !priv->connect_to_any_BSS;  \n\n\treturn 0;\n}\n\nstatic int atmel_get_wap(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct sockaddr *awrq = &wrqu->ap_addr;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tmemcpy(awrq->sa_data, priv->CurrentBSSID, ETH_ALEN);\n\tawrq->sa_family = ARPHRD_ETHER;\n\n\treturn 0;\n}\n\nstatic int atmel_set_encode(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu,\n\t\t\t    char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->encoding;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\t \n\tif (dwrq->length > 0) {\n\t\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\t\tint current_index = priv->default_key;\n\t\t \n\t\tif (dwrq->length > 13) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (index < 0 || index >= 4)\n\t\t\tindex = current_index;\n\t\telse\n\t\t\tpriv->default_key = index;\n\t\t \n\t\tif (dwrq->length > 5)\n\t\t\tpriv->wep_key_len[index] = 13;\n\t\telse\n\t\t\tif (dwrq->length > 0)\n\t\t\t\tpriv->wep_key_len[index] = 5;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tpriv->wep_key_len[index] = 0;\n\t\t \n\t\tif (!(dwrq->flags & IW_ENCODE_NOKEY)) {\n\t\t\t \n\t\t\tmemset(priv->wep_keys[index], 0, 13);\n\t\t\t \n\t\t\tmemcpy(priv->wep_keys[index], extra, dwrq->length);\n\t\t}\n\t\t \n\t\tif (index == current_index &&\n\t\t    priv->wep_key_len[index] > 0) {\n\t\t\tpriv->wep_is_on = 1;\n\t\t\tpriv->exclude_unencrypted = 1;\n\t\t\tif (priv->wep_key_len[index] > 5) {\n\t\t\t\tpriv->pairwise_cipher_suite = CIPHER_SUITE_WEP_128;\n\t\t\t\tpriv->encryption_level = 2;\n\t\t\t} else {\n\t\t\t\tpriv->pairwise_cipher_suite = CIPHER_SUITE_WEP_64;\n\t\t\t\tpriv->encryption_level = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\t\tif (index >= 0 && index < 4) {\n\t\t\tpriv->default_key = index;\n\t\t} else\n\t\t\t \n\t\t\tif (!(dwrq->flags & IW_ENCODE_MODE))\n\t\t\t\treturn -EINVAL;\n\t}\n\t \n\tif (dwrq->flags & IW_ENCODE_DISABLED) {\n\t\tpriv->wep_is_on = 0;\n\t\tpriv->encryption_level = 0;\n\t\tpriv->pairwise_cipher_suite = CIPHER_SUITE_NONE;\n\t} else {\n\t\tpriv->wep_is_on = 1;\n\t\tif (priv->wep_key_len[priv->default_key] > 5) {\n\t\t\tpriv->pairwise_cipher_suite = CIPHER_SUITE_WEP_128;\n\t\t\tpriv->encryption_level = 2;\n\t\t} else {\n\t\t\tpriv->pairwise_cipher_suite = CIPHER_SUITE_WEP_64;\n\t\t\tpriv->encryption_level = 1;\n\t\t}\n\t}\n\tif (dwrq->flags & IW_ENCODE_RESTRICTED)\n\t\tpriv->exclude_unencrypted = 1;\n\tif (dwrq->flags & IW_ENCODE_OPEN)\n\t\tpriv->exclude_unencrypted = 0;\n\n\treturn -EINPROGRESS;\t\t \n}\n\nstatic int atmel_get_encode(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu,\n\t\t\t    char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->encoding;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\n\tif (!priv->wep_is_on)\n\t\tdwrq->flags = IW_ENCODE_DISABLED;\n\telse {\n\t\tif (priv->exclude_unencrypted)\n\t\t\tdwrq->flags = IW_ENCODE_RESTRICTED;\n\t\telse\n\t\t\tdwrq->flags = IW_ENCODE_OPEN;\n\t}\n\t\t \n\tif (index < 0 || index >= 4)\n\t\tindex = priv->default_key;\n\tdwrq->flags |= index + 1;\n\t \n\tdwrq->length = priv->wep_key_len[index];\n\tif (dwrq->length > 16) {\n\t\tdwrq->length = 0;\n\t} else {\n\t\tmemset(extra, 0, 16);\n\t\tmemcpy(extra, priv->wep_keys[index], dwrq->length);\n\t}\n\n\treturn 0;\n}\n\nstatic int atmel_set_encodeext(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu,\n\t\t\t    char *extra)\n{\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint idx, key_len, alg = ext->alg, set_key = 1;\n\n\t \n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif (idx < 1 || idx > 4)\n\t\t\treturn -EINVAL;\n\t\tidx--;\n\t} else\n\t\tidx = priv->default_key;\n\n\tif (encoding->flags & IW_ENCODE_DISABLED)\n\t    alg = IW_ENCODE_ALG_NONE;\n\n\tif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\n\t\tpriv->default_key = idx;\n\t\tset_key = ext->key_len > 0 ? 1 : 0;\n\t}\n\n\tif (set_key) {\n\t\t \n\t\tswitch (alg) {\n\t\tcase IW_ENCODE_ALG_NONE:\n\t\t\tpriv->wep_is_on = 0;\n\t\t\tpriv->encryption_level = 0;\n\t\t\tpriv->pairwise_cipher_suite = CIPHER_SUITE_NONE;\n\t\t\tbreak;\n\t\tcase IW_ENCODE_ALG_WEP:\n\t\t\tif (ext->key_len > 5) {\n\t\t\t\tpriv->wep_key_len[idx] = 13;\n\t\t\t\tpriv->pairwise_cipher_suite = CIPHER_SUITE_WEP_128;\n\t\t\t\tpriv->encryption_level = 2;\n\t\t\t} else if (ext->key_len > 0) {\n\t\t\t\tpriv->wep_key_len[idx] = 5;\n\t\t\t\tpriv->pairwise_cipher_suite = CIPHER_SUITE_WEP_64;\n\t\t\t\tpriv->encryption_level = 1;\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpriv->wep_is_on = 1;\n\t\t\tmemset(priv->wep_keys[idx], 0, 13);\n\t\t\tkey_len = min ((int)ext->key_len, priv->wep_key_len[idx]);\n\t\t\tmemcpy(priv->wep_keys[idx], ext->key, key_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn -EINPROGRESS;\n}\n\nstatic int atmel_get_encodeext(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu,\n\t\t\t    char *extra)\n{\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint idx, max_key_len;\n\n\tmax_key_len = encoding->length - sizeof(*ext);\n\tif (max_key_len < 0)\n\t\treturn -EINVAL;\n\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif (idx < 1 || idx > 4)\n\t\t\treturn -EINVAL;\n\t\tidx--;\n\t} else\n\t\tidx = priv->default_key;\n\n\tencoding->flags = idx + 1;\n\tmemset(ext, 0, sizeof(*ext));\n\n\tif (!priv->wep_is_on) {\n\t\text->alg = IW_ENCODE_ALG_NONE;\n\t\text->key_len = 0;\n\t\tencoding->flags |= IW_ENCODE_DISABLED;\n\t} else {\n\t\tif (priv->encryption_level > 0)\n\t\t\text->alg = IW_ENCODE_ALG_WEP;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\text->key_len = priv->wep_key_len[idx];\n\t\tmemcpy(ext->key, priv->wep_keys[idx], ext->key_len);\n\t\tencoding->flags |= IW_ENCODE_ENABLED;\n\t}\n\n\treturn 0;\n}\n\nstatic int atmel_set_auth(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tstruct iw_param *param = &wrqu->param;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\t \n\t\tbreak;\n\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tpriv->exclude_unencrypted = param->value ? 1 : 0;\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG: {\n\t\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY) {\n\t\t\t\tpriv->exclude_unencrypted = 1;\n\t\t\t} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {\n\t\t\t\tpriv->exclude_unencrypted = 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\t \n\t\tif (param->value > 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn -EINPROGRESS;\n}\n\nstatic int atmel_get_auth(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tstruct iw_param *param = &wrqu->param;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tparam->value = priv->exclude_unencrypted;\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (priv->exclude_unencrypted == 1)\n\t\t\tparam->value = IW_AUTH_ALG_SHARED_KEY;\n\t\telse\n\t\t\tparam->value = IW_AUTH_ALG_OPEN_SYSTEM;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tparam->value = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n\nstatic int atmel_get_name(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstrcpy(wrqu->name, \"IEEE 802.11-DS\");\n\treturn 0;\n}\n\nstatic int atmel_set_rate(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->bitrate;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\tif (vwrq->fixed == 0) {\n\t\tpriv->tx_rate = 3;\n\t\tpriv->auto_tx_rate = 1;\n\t} else {\n\t\tpriv->auto_tx_rate = 0;\n\n\t\t \n\t\tif ((vwrq->value < 4) && (vwrq->value >= 0)) {\n\t\t\t \n\t\t\tpriv->tx_rate = vwrq->value;\n\t\t} else {\n\t\t \n\t\t\tswitch (vwrq->value) {\n\t\t\tcase  1000000:\n\t\t\t\tpriv->tx_rate = 0;\n\t\t\t\tbreak;\n\t\t\tcase  2000000:\n\t\t\t\tpriv->tx_rate = 1;\n\t\t\t\tbreak;\n\t\t\tcase  5500000:\n\t\t\t\tpriv->tx_rate = 2;\n\t\t\t\tbreak;\n\t\t\tcase 11000000:\n\t\t\t\tpriv->tx_rate = 3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINPROGRESS;\n}\n\nstatic int atmel_set_mode(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\t__u32 *uwrq = &wrqu->mode;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\tif (*uwrq != IW_MODE_ADHOC && *uwrq != IW_MODE_INFRA)\n\t\treturn -EINVAL;\n\n\tpriv->operating_mode = *uwrq;\n\treturn -EINPROGRESS;\n}\n\nstatic int atmel_get_mode(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\t__u32 *uwrq = &wrqu->mode;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\t*uwrq = priv->operating_mode;\n\treturn 0;\n}\n\nstatic int atmel_get_rate(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->bitrate;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\tif (priv->auto_tx_rate) {\n\t\tvwrq->fixed = 0;\n\t\tvwrq->value = 11000000;\n\t} else {\n\t\tvwrq->fixed = 1;\n\t\tswitch (priv->tx_rate) {\n\t\tcase 0:\n\t\t\tvwrq->value =  1000000;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tvwrq->value =  2000000;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvwrq->value =  5500000;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tvwrq->value = 11000000;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int atmel_set_power(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu,\n\t\t\t   char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->power;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tpriv->power_mode = vwrq->disabled ? 0 : 1;\n\treturn -EINPROGRESS;\n}\n\nstatic int atmel_get_power(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu,\n\t\t\t   char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->power;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tvwrq->disabled = priv->power_mode ? 0 : 1;\n\tvwrq->flags = IW_POWER_ON;\n\treturn 0;\n}\n\nstatic int atmel_set_retry(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu,\n\t\t\t   char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->retry;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\tif (!vwrq->disabled && (vwrq->flags & IW_RETRY_LIMIT)) {\n\t\tif (vwrq->flags & IW_RETRY_LONG)\n\t\t\tpriv->long_retry = vwrq->value;\n\t\telse if (vwrq->flags & IW_RETRY_SHORT)\n\t\t\tpriv->short_retry = vwrq->value;\n\t\telse {\n\t\t\t \n\t\t\tpriv->long_retry = vwrq->value;\n\t\t\tpriv->short_retry = vwrq->value;\n\t\t}\n\t\treturn -EINPROGRESS;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int atmel_get_retry(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu,\n\t\t\t   char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->retry;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\tvwrq->disabled = 0;       \n\n\t \n\tif (vwrq->flags & IW_RETRY_LONG) {\n\t\tvwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\n\t\tvwrq->value = priv->long_retry;\n\t} else {\n\t\tvwrq->flags = IW_RETRY_LIMIT;\n\t\tvwrq->value = priv->short_retry;\n\t\tif (priv->long_retry != priv->short_retry)\n\t\t\tvwrq->flags |= IW_RETRY_SHORT;\n\t}\n\n\treturn 0;\n}\n\nstatic int atmel_set_rts(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->rts;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tint rthr = vwrq->value;\n\n\tif (vwrq->disabled)\n\t\trthr = 2347;\n\tif ((rthr < 0) || (rthr > 2347)) {\n\t\treturn -EINVAL;\n\t}\n\tpriv->rts_threshold = rthr;\n\n\treturn -EINPROGRESS;\t\t \n}\n\nstatic int atmel_get_rts(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->rts;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\tvwrq->value = priv->rts_threshold;\n\tvwrq->disabled = (vwrq->value >= 2347);\n\tvwrq->fixed = 1;\n\n\treturn 0;\n}\n\nstatic int atmel_set_frag(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->frag;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tint fthr = vwrq->value;\n\n\tif (vwrq->disabled)\n\t\tfthr = 2346;\n\tif ((fthr < 256) || (fthr > 2346)) {\n\t\treturn -EINVAL;\n\t}\n\tfthr &= ~0x1;\t \n\tpriv->frag_threshold = fthr;\n\n\treturn -EINPROGRESS;\t\t \n}\n\nstatic int atmel_get_frag(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_param *vwrq = &wrqu->frag;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\tvwrq->value = priv->frag_threshold;\n\tvwrq->disabled = (vwrq->value >= 2346);\n\tvwrq->fixed = 1;\n\n\treturn 0;\n}\n\nstatic int atmel_set_freq(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_freq *fwrq = &wrqu->freq;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tint rc = -EINPROGRESS;\t\t \n\n\t \n\tif (fwrq->e == 1) {\n\t\tint f = fwrq->m / 100000;\n\n\t\t \n\t\tfwrq->e = 0;\n\t\tfwrq->m = ieee80211_frequency_to_channel(f);\n\t}\n\t \n\tif (fwrq->m < 0 || fwrq->m > 1000 || fwrq->e > 0)\n\t\trc = -EOPNOTSUPP;\n\telse {\n\t\tint channel = fwrq->m;\n\t\tif (atmel_validate_channel(priv, channel) == 0) {\n\t\t\tpriv->channel = channel;\n\t\t} else {\n\t\t\trc = -EINVAL;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int atmel_get_freq(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_freq *fwrq = &wrqu->freq;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\n\tfwrq->m = priv->channel;\n\tfwrq->e = 0;\n\treturn 0;\n}\n\nstatic int atmel_set_scan(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *dwrq,\n\t\t\t  char *extra)\n{\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\t \n\n\tif (priv->station_state == STATION_STATE_DOWN)\n\t\treturn -EAGAIN;\n\n\t \n\tif (time_after(jiffies, priv->last_survey + 20 * HZ))\n\t\tpriv->site_survey_state = SITE_SURVEY_IDLE;\n\tpriv->last_survey = jiffies;\n\n\t \n\tif (priv->site_survey_state == SITE_SURVEY_IN_PROGRESS)\n\t\treturn -EBUSY;\n\n\tdel_timer_sync(&priv->management_timer);\n\tspin_lock_irqsave(&priv->irqlock, flags);\n\n\tpriv->site_survey_state = SITE_SURVEY_IN_PROGRESS;\n\tpriv->fast_scan = 0;\n\tatmel_scan(priv, 0);\n\tspin_unlock_irqrestore(&priv->irqlock, flags);\n\n\treturn 0;\n}\n\nstatic int atmel_get_scan(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu,\n\t\t\t  char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->data;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tint i;\n\tchar *current_ev = extra;\n\tstruct iw_event\tiwe;\n\n\tif (priv->site_survey_state != SITE_SURVEY_COMPLETED)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < priv->BSS_list_entries; i++) {\n\t\tiwe.cmd = SIOCGIWAP;\n\t\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\t\tmemcpy(iwe.u.ap_addr.sa_data, priv->BSSinfo[i].BSSID, ETH_ALEN);\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev,\n\t\t\t\t\t\t  extra + IW_SCAN_MAX_DATA,\n\t\t\t\t\t\t  &iwe, IW_EV_ADDR_LEN);\n\n\t\tiwe.u.data.length =  priv->BSSinfo[i].SSIDsize;\n\t\tif (iwe.u.data.length > 32)\n\t\t\tiwe.u.data.length = 32;\n\t\tiwe.cmd = SIOCGIWESSID;\n\t\tiwe.u.data.flags = 1;\n\t\tcurrent_ev = iwe_stream_add_point(info, current_ev,\n\t\t\t\t\t\t  extra + IW_SCAN_MAX_DATA,\n\t\t\t\t\t\t  &iwe, priv->BSSinfo[i].SSID);\n\n\t\tiwe.cmd = SIOCGIWMODE;\n\t\tiwe.u.mode = priv->BSSinfo[i].BSStype;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev,\n\t\t\t\t\t\t  extra + IW_SCAN_MAX_DATA,\n\t\t\t\t\t\t  &iwe, IW_EV_UINT_LEN);\n\n\t\tiwe.cmd = SIOCGIWFREQ;\n\t\tiwe.u.freq.m = priv->BSSinfo[i].channel;\n\t\tiwe.u.freq.e = 0;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev,\n\t\t\t\t\t\t  extra + IW_SCAN_MAX_DATA,\n\t\t\t\t\t\t  &iwe, IW_EV_FREQ_LEN);\n\n\t\t \n\t\tiwe.cmd = IWEVQUAL;\n\t\tiwe.u.qual.level = priv->BSSinfo[i].RSSI;\n\t\tiwe.u.qual.qual  = iwe.u.qual.level;\n\t\t \n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev,\n\t\t\t\t\t\t  extra + IW_SCAN_MAX_DATA,\n\t\t\t\t\t\t  &iwe, IW_EV_QUAL_LEN);\n\n\n\t\tiwe.cmd = SIOCGIWENCODE;\n\t\tif (priv->BSSinfo[i].UsingWEP)\n\t\t\tiwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\n\t\telse\n\t\t\tiwe.u.data.flags = IW_ENCODE_DISABLED;\n\t\tiwe.u.data.length = 0;\n\t\tcurrent_ev = iwe_stream_add_point(info, current_ev,\n\t\t\t\t\t\t  extra + IW_SCAN_MAX_DATA,\n\t\t\t\t\t\t  &iwe, NULL);\n\t}\n\n\t \n\tdwrq->length = (current_ev - extra);\n\tdwrq->flags = 0;\n\n\treturn 0;\n}\n\nstatic int atmel_get_range(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu,\n\t\t\t   char *extra)\n{\n\tstruct iw_point *dwrq = &wrqu->data;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tstruct iw_range *range = (struct iw_range *) extra;\n\tint k, i, j;\n\n\tdwrq->length = sizeof(struct iw_range);\n\tmemset(range, 0, sizeof(struct iw_range));\n\trange->min_nwid = 0x0000;\n\trange->max_nwid = 0x0000;\n\trange->num_channels = 0;\n\tfor (j = 0; j < ARRAY_SIZE(channel_table); j++)\n\t\tif (priv->reg_domain == channel_table[j].reg_domain) {\n\t\t\trange->num_channels = channel_table[j].max - channel_table[j].min + 1;\n\t\t\tbreak;\n\t\t}\n\tif (range->num_channels != 0) {\n\t\tfor (k = 0, i = channel_table[j].min; i <= channel_table[j].max; i++) {\n\t\t\trange->freq[k].i = i;  \n\n\t\t\t \n\t\t\trange->freq[k].m = 100000 *\n\t\t\t ieee80211_channel_to_frequency(i, NL80211_BAND_2GHZ);\n\t\t\trange->freq[k++].e = 1;\n\t\t}\n\t\trange->num_frequency = k;\n\t}\n\n\trange->max_qual.qual = 100;\n\trange->max_qual.level = 100;\n\trange->max_qual.noise = 0;\n\trange->max_qual.updated = IW_QUAL_NOISE_INVALID;\n\n\trange->avg_qual.qual = 50;\n\trange->avg_qual.level = 50;\n\trange->avg_qual.noise = 0;\n\trange->avg_qual.updated = IW_QUAL_NOISE_INVALID;\n\n\trange->sensitivity = 0;\n\n\trange->bitrate[0] =  1000000;\n\trange->bitrate[1] =  2000000;\n\trange->bitrate[2] =  5500000;\n\trange->bitrate[3] = 11000000;\n\trange->num_bitrates = 4;\n\n\trange->min_rts = 0;\n\trange->max_rts = 2347;\n\trange->min_frag = 256;\n\trange->max_frag = 2346;\n\n\trange->encoding_size[0] = 5;\n\trange->encoding_size[1] = 13;\n\trange->num_encoding_sizes = 2;\n\trange->max_encoding_tokens = 4;\n\n\trange->pmp_flags = IW_POWER_ON;\n\trange->pmt_flags = IW_POWER_ON;\n\trange->pm_capa = 0;\n\n\trange->we_version_source = WIRELESS_EXT;\n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->retry_capa = IW_RETRY_LIMIT ;\n\trange->retry_flags = IW_RETRY_LIMIT;\n\trange->r_time_flags = 0;\n\trange->min_retry = 1;\n\trange->max_retry = 65535;\n\n\treturn 0;\n}\n\nstatic int atmel_set_wap(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu,\n\t\t\t char *extra)\n{\n\tstruct sockaddr *awrq = &wrqu->ap_addr;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tint i;\n\tstatic const u8 any[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\tstatic const u8 off[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tunsigned long flags;\n\n\tif (awrq->sa_family != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\n\tif (!memcmp(any, awrq->sa_data, 6) ||\n\t    !memcmp(off, awrq->sa_data, 6)) {\n\t\tdel_timer_sync(&priv->management_timer);\n\t\tspin_lock_irqsave(&priv->irqlock, flags);\n\t\tatmel_scan(priv, 1);\n\t\tspin_unlock_irqrestore(&priv->irqlock, flags);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < priv->BSS_list_entries; i++) {\n\t\tif (memcmp(priv->BSSinfo[i].BSSID, awrq->sa_data, 6) == 0) {\n\t\t\tif (!priv->wep_is_on && priv->BSSinfo[i].UsingWEP) {\n\t\t\t\treturn -EINVAL;\n\t\t\t} else if  (priv->wep_is_on && !priv->BSSinfo[i].UsingWEP) {\n\t\t\t\treturn -EINVAL;\n\t\t\t} else {\n\t\t\t\tdel_timer_sync(&priv->management_timer);\n\t\t\t\tspin_lock_irqsave(&priv->irqlock, flags);\n\t\t\t\tatmel_join_bss(priv, i);\n\t\t\t\tspin_unlock_irqrestore(&priv->irqlock, flags);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int atmel_config_commit(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\t \n\t\t\t       union iwreq_data *zwrq,\t\t \n\t\t\t       char *extra)\t\t\t \n{\n\treturn atmel_open(dev);\n}\n\nstatic const iw_handler atmel_handler[] =\n{\n\tIW_HANDLER(SIOCSIWCOMMIT,\tatmel_config_commit),\n\tIW_HANDLER(SIOCGIWNAME,\t\tatmel_get_name),\n\tIW_HANDLER(SIOCSIWFREQ,\t\tatmel_set_freq),\n\tIW_HANDLER(SIOCGIWFREQ,\t\tatmel_get_freq),\n\tIW_HANDLER(SIOCSIWMODE,\t\tatmel_set_mode),\n\tIW_HANDLER(SIOCGIWMODE,\t\tatmel_get_mode),\n\tIW_HANDLER(SIOCGIWRANGE,\tatmel_get_range),\n\tIW_HANDLER(SIOCSIWAP,\t\tatmel_set_wap),\n\tIW_HANDLER(SIOCGIWAP,\t\tatmel_get_wap),\n\tIW_HANDLER(SIOCSIWSCAN,\t\tatmel_set_scan),\n\tIW_HANDLER(SIOCGIWSCAN,\t\tatmel_get_scan),\n\tIW_HANDLER(SIOCSIWESSID,\tatmel_set_essid),\n\tIW_HANDLER(SIOCGIWESSID,\tatmel_get_essid),\n\tIW_HANDLER(SIOCSIWRATE,\t\tatmel_set_rate),\n\tIW_HANDLER(SIOCGIWRATE,\t\tatmel_get_rate),\n\tIW_HANDLER(SIOCSIWRTS,\t\tatmel_set_rts),\n\tIW_HANDLER(SIOCGIWRTS,\t\tatmel_get_rts),\n\tIW_HANDLER(SIOCSIWFRAG,\t\tatmel_set_frag),\n\tIW_HANDLER(SIOCGIWFRAG,\t\tatmel_get_frag),\n\tIW_HANDLER(SIOCSIWRETRY,\tatmel_set_retry),\n\tIW_HANDLER(SIOCGIWRETRY,\tatmel_get_retry),\n\tIW_HANDLER(SIOCSIWENCODE,\tatmel_set_encode),\n\tIW_HANDLER(SIOCGIWENCODE,\tatmel_get_encode),\n\tIW_HANDLER(SIOCSIWPOWER,\tatmel_set_power),\n\tIW_HANDLER(SIOCGIWPOWER,\tatmel_get_power),\n\tIW_HANDLER(SIOCSIWAUTH,\t\tatmel_set_auth),\n\tIW_HANDLER(SIOCGIWAUTH,\t\tatmel_get_auth),\n\tIW_HANDLER(SIOCSIWENCODEEXT,\tatmel_set_encodeext),\n\tIW_HANDLER(SIOCGIWENCODEEXT,\tatmel_get_encodeext),\n};\n\nstatic const iw_handler atmel_private_handler[] =\n{\n\tNULL,\t\t\t\t \n};\n\nstruct atmel_priv_ioctl {\n\tchar id[32];\n\tunsigned char __user *data;\n\tunsigned short len;\n};\n\n#define ATMELFWL\tSIOCIWFIRSTPRIV\n#define ATMELIDIFC\tATMELFWL + 1\n#define ATMELRD\t\tATMELFWL + 2\n#define ATMELMAGIC 0x51807\n#define REGDOMAINSZ 20\n\nstatic const struct iw_priv_args atmel_private_args[] = {\n\t{\n\t\t.cmd = ATMELFWL,\n\t\t.set_args = IW_PRIV_TYPE_BYTE\n\t\t\t\t| IW_PRIV_SIZE_FIXED\n\t\t\t\t| sizeof(struct atmel_priv_ioctl),\n\t\t.get_args = IW_PRIV_TYPE_NONE,\n\t\t.name = \"atmelfwl\"\n\t}, {\n\t\t.cmd = ATMELIDIFC,\n\t\t.set_args = IW_PRIV_TYPE_NONE,\n\t\t.get_args = IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t\t.name = \"atmelidifc\"\n\t}, {\n\t\t.cmd = ATMELRD,\n\t\t.set_args = IW_PRIV_TYPE_CHAR | REGDOMAINSZ,\n\t\t.get_args = IW_PRIV_TYPE_NONE,\n\t\t.name = \"regdomain\"\n\t},\n};\n\nstatic const struct iw_handler_def atmel_handler_def = {\n\t.num_standard\t= ARRAY_SIZE(atmel_handler),\n\t.num_private\t= ARRAY_SIZE(atmel_private_handler),\n\t.num_private_args = ARRAY_SIZE(atmel_private_args),\n\t.standard\t= atmel_handler,\n\t.private\t= atmel_private_handler,\n\t.private_args\t= (struct iw_priv_args *) atmel_private_args,\n\t.get_wireless_stats = atmel_get_wireless_stats\n};\n\nstatic int atmel_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint i, rc = 0;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tstruct atmel_priv_ioctl com;\n\tstruct iwreq *wrq = (struct iwreq *) rq;\n\tunsigned char *new_firmware;\n\tchar domain[REGDOMAINSZ + 1];\n\n\tswitch (cmd) {\n\tcase ATMELIDIFC:\n\t\twrq->u.param.value = ATMELMAGIC;\n\t\tbreak;\n\n\tcase ATMELFWL:\n\t\tif (copy_from_user(&com, rq->ifr_data, sizeof(com))) {\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\n\t\tnew_firmware = memdup_user(com.data, com.len);\n\t\tif (IS_ERR(new_firmware)) {\n\t\t\trc = PTR_ERR(new_firmware);\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(priv->firmware);\n\n\t\tpriv->firmware = new_firmware;\n\t\tpriv->firmware_length = com.len;\n\t\tstrncpy(priv->firmware_id, com.id, 31);\n\t\tpriv->firmware_id[31] = '\\0';\n\t\tbreak;\n\n\tcase ATMELRD:\n\t\tif (copy_from_user(domain, rq->ifr_data, REGDOMAINSZ)) {\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\trc = -EPERM;\n\t\t\tbreak;\n\t\t}\n\n\t\tdomain[REGDOMAINSZ] = 0;\n\t\trc = -EINVAL;\n\t\tfor (i = 0; i < ARRAY_SIZE(channel_table); i++) {\n\t\t\tif (!strcasecmp(channel_table[i].name, domain)) {\n\t\t\t\tpriv->config_reg_domain = channel_table[i].reg_domain;\n\t\t\t\trc = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (rc == 0 &&  priv->station_state != STATION_STATE_DOWN)\n\t\t\trc = atmel_open(dev);\n\t\tbreak;\n\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\treturn rc;\n}\n\nstruct auth_body {\n\t__le16 alg;\n\t__le16 trans_seq;\n\t__le16 status;\n\tu8 el_id;\n\tu8 chall_text_len;\n\tu8 chall_text[253];\n};\n\nstatic void atmel_enter_state(struct atmel_private *priv, int new_state)\n{\n\tint old_state = priv->station_state;\n\n\tif (new_state == old_state)\n\t\treturn;\n\n\tpriv->station_state = new_state;\n\n\tif (new_state == STATION_STATE_READY) {\n\t\tnetif_start_queue(priv->dev);\n\t\tnetif_carrier_on(priv->dev);\n\t}\n\n\tif (old_state == STATION_STATE_READY) {\n\t\tnetif_carrier_off(priv->dev);\n\t\tif (netif_running(priv->dev))\n\t\t\tnetif_stop_queue(priv->dev);\n\t\tpriv->last_beacon_timestamp = 0;\n\t}\n}\n\nstatic void atmel_scan(struct atmel_private *priv, int specific_ssid)\n{\n\tstruct {\n\t\tu8 BSSID[ETH_ALEN];\n\t\tu8 SSID[MAX_SSID_LENGTH];\n\t\tu8 scan_type;\n\t\tu8 channel;\n\t\t__le16 BSS_type;\n\t\t__le16 min_channel_time;\n\t\t__le16 max_channel_time;\n\t\tu8 options;\n\t\tu8 SSID_size;\n\t} cmd;\n\n\teth_broadcast_addr(cmd.BSSID);\n\n\tif (priv->fast_scan) {\n\t\tcmd.SSID_size = priv->SSID_size;\n\t\tmemcpy(cmd.SSID, priv->SSID, priv->SSID_size);\n\t\tcmd.min_channel_time = cpu_to_le16(10);\n\t\tcmd.max_channel_time = cpu_to_le16(50);\n\t} else {\n\t\tpriv->BSS_list_entries = 0;\n\t\tcmd.SSID_size = 0;\n\t\tcmd.min_channel_time = cpu_to_le16(10);\n\t\tcmd.max_channel_time = cpu_to_le16(120);\n\t}\n\n\tcmd.options = 0;\n\n\tif (!specific_ssid)\n\t\tcmd.options |= SCAN_OPTIONS_SITE_SURVEY;\n\n\tcmd.channel = (priv->channel & 0x7f);\n\tcmd.scan_type = SCAN_TYPE_ACTIVE;\n\tcmd.BSS_type = cpu_to_le16(priv->operating_mode == IW_MODE_ADHOC ?\n\t\tBSS_TYPE_AD_HOC : BSS_TYPE_INFRASTRUCTURE);\n\n\tatmel_send_command(priv, CMD_Scan, &cmd, sizeof(cmd));\n\n\t \n\tatmel_enter_state(priv, STATION_STATE_SCANNING);\n}\n\nstatic void join(struct atmel_private *priv, int type)\n{\n\tstruct {\n\t\tu8 BSSID[6];\n\t\tu8 SSID[MAX_SSID_LENGTH];\n\t\tu8 BSS_type;  \n\t\tu8 channel;\n\t\t__le16 timeout;\n\t\tu8 SSID_size;\n\t\tu8 reserved;\n\t} cmd;\n\n\tcmd.SSID_size = priv->SSID_size;\n\tmemcpy(cmd.SSID, priv->SSID, priv->SSID_size);\n\tmemcpy(cmd.BSSID, priv->CurrentBSSID, ETH_ALEN);\n\tcmd.channel = (priv->channel & 0x7f);\n\tcmd.BSS_type = type;\n\tcmd.timeout = cpu_to_le16(2000);\n\n\tatmel_send_command(priv, CMD_Join, &cmd, sizeof(cmd));\n}\n\nstatic void start(struct atmel_private *priv, int type)\n{\n\tstruct {\n\t\tu8 BSSID[6];\n\t\tu8 SSID[MAX_SSID_LENGTH];\n\t\tu8 BSS_type;\n\t\tu8 channel;\n\t\tu8 SSID_size;\n\t\tu8 reserved[3];\n\t} cmd;\n\n\tcmd.SSID_size = priv->SSID_size;\n\tmemcpy(cmd.SSID, priv->SSID, priv->SSID_size);\n\tmemcpy(cmd.BSSID, priv->BSSID, ETH_ALEN);\n\tcmd.BSS_type = type;\n\tcmd.channel = (priv->channel & 0x7f);\n\n\tatmel_send_command(priv, CMD_Start, &cmd, sizeof(cmd));\n}\n\nstatic void handle_beacon_probe(struct atmel_private *priv, u16 capability,\n\t\t\t\tu8 channel)\n{\n\tint rejoin = 0;\n\tint new = capability & WLAN_CAPABILITY_SHORT_PREAMBLE ?\n\t\tSHORT_PREAMBLE : LONG_PREAMBLE;\n\n\tif (priv->preamble != new) {\n\t\tpriv->preamble = new;\n\t\trejoin = 1;\n\t\tatmel_set_mib8(priv, Local_Mib_Type, LOCAL_MIB_PREAMBLE_TYPE, new);\n\t}\n\n\tif (priv->channel != channel) {\n\t\tpriv->channel = channel;\n\t\trejoin = 1;\n\t\tatmel_set_mib8(priv, Phy_Mib_Type, PHY_MIB_CHANNEL_POS, channel);\n\t}\n\n\tif (rejoin) {\n\t\tpriv->station_is_associated = 0;\n\t\tatmel_enter_state(priv, STATION_STATE_JOINNING);\n\n\t\tif (priv->operating_mode == IW_MODE_INFRA)\n\t\t\tjoin(priv, BSS_TYPE_INFRASTRUCTURE);\n\t\telse\n\t\t\tjoin(priv, BSS_TYPE_AD_HOC);\n\t}\n}\n\nstatic void send_authentication_request(struct atmel_private *priv, u16 system,\n\t\t\t\t\tu8 *challenge, int challenge_len)\n{\n\tstruct ieee80211_hdr header;\n\tstruct auth_body auth;\n\n\theader.frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH);\n\theader.duration_id = cpu_to_le16(0x8000);\n\theader.seq_ctrl = 0;\n\tmemcpy(header.addr1, priv->CurrentBSSID, ETH_ALEN);\n\tmemcpy(header.addr2, priv->dev->dev_addr, ETH_ALEN);\n\tmemcpy(header.addr3, priv->CurrentBSSID, ETH_ALEN);\n\n\tif (priv->wep_is_on && priv->CurrentAuthentTransactionSeqNum != 1)\n\t\t \n\t\theader.frame_control |=  cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\n\tauth.alg = cpu_to_le16(system);\n\n\tauth.status = 0;\n\tauth.trans_seq = cpu_to_le16(priv->CurrentAuthentTransactionSeqNum);\n\tpriv->ExpectedAuthentTransactionSeqNum = priv->CurrentAuthentTransactionSeqNum+1;\n\tpriv->CurrentAuthentTransactionSeqNum += 2;\n\n\tif (challenge_len != 0)\t{\n\t\tauth.el_id = 16;  \n\t\tauth.chall_text_len = challenge_len;\n\t\tmemcpy(auth.chall_text, challenge, challenge_len);\n\t\tatmel_transmit_management_frame(priv, &header, (u8 *)&auth, 8 + challenge_len);\n\t} else {\n\t\tatmel_transmit_management_frame(priv, &header, (u8 *)&auth, 6);\n\t}\n}\n\nstatic void send_association_request(struct atmel_private *priv, int is_reassoc)\n{\n\tu8 *ssid_el_p;\n\tint bodysize;\n\tstruct ieee80211_hdr header;\n\tstruct ass_req_format {\n\t\t__le16 capability;\n\t\t__le16 listen_interval;\n\t\tu8 ap[ETH_ALEN];  \n\t\tu8 ssid_el_id;\n\t\tu8 ssid_len;\n\t\tu8 ssid[MAX_SSID_LENGTH];\n\t\tu8 sup_rates_el_id;\n\t\tu8 sup_rates_len;\n\t\tu8 rates[4];\n\t} body;\n\n\theader.frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t(is_reassoc ? IEEE80211_STYPE_REASSOC_REQ : IEEE80211_STYPE_ASSOC_REQ));\n\theader.duration_id = cpu_to_le16(0x8000);\n\theader.seq_ctrl = 0;\n\n\tmemcpy(header.addr1, priv->CurrentBSSID, ETH_ALEN);\n\tmemcpy(header.addr2, priv->dev->dev_addr, ETH_ALEN);\n\tmemcpy(header.addr3, priv->CurrentBSSID, ETH_ALEN);\n\n\tbody.capability = cpu_to_le16(WLAN_CAPABILITY_ESS);\n\tif (priv->wep_is_on)\n\t\tbody.capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\n\tif (priv->preamble == SHORT_PREAMBLE)\n\t\tbody.capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE);\n\n\tbody.listen_interval = cpu_to_le16(priv->listen_interval * priv->beacon_period);\n\n\t \n\tif (is_reassoc) {\n\t\tmemcpy(body.ap, priv->CurrentBSSID, ETH_ALEN);\n\t\tssid_el_p = &body.ssid_el_id;\n\t\tbodysize = 18 + priv->SSID_size;\n\t} else {\n\t\tssid_el_p = &body.ap[0];\n\t\tbodysize = 12 + priv->SSID_size;\n\t}\n\n\tssid_el_p[0] = WLAN_EID_SSID;\n\tssid_el_p[1] = priv->SSID_size;\n\tmemcpy(ssid_el_p + 2, priv->SSID, priv->SSID_size);\n\tssid_el_p[2 + priv->SSID_size] = WLAN_EID_SUPP_RATES;\n\tssid_el_p[3 + priv->SSID_size] = 4;  \n\tmemcpy(ssid_el_p + 4 + priv->SSID_size, atmel_basic_rates, 4);\n\n\tatmel_transmit_management_frame(priv, &header, (void *)&body, bodysize);\n}\n\nstatic int is_frame_from_current_bss(struct atmel_private *priv,\n\t\t\t\t     struct ieee80211_hdr *header)\n{\n\tif (le16_to_cpu(header->frame_control) & IEEE80211_FCTL_FROMDS)\n\t\treturn memcmp(header->addr3, priv->CurrentBSSID, 6) == 0;\n\telse\n\t\treturn memcmp(header->addr2, priv->CurrentBSSID, 6) == 0;\n}\n\nstatic int retrieve_bss(struct atmel_private *priv)\n{\n\tint i;\n\tint max_rssi = -128;\n\tint max_index = -1;\n\n\tif (priv->BSS_list_entries == 0)\n\t\treturn -1;\n\n\tif (priv->connect_to_any_BSS) {\n\t\t \n\t\tpriv->current_BSS = 0;\n\t\tfor (i = 0; i < priv->BSS_list_entries; i++) {\n\t\t\tif (priv->operating_mode == priv->BSSinfo[i].BSStype &&\n\t\t\t    ((!priv->wep_is_on && !priv->BSSinfo[i].UsingWEP) ||\n\t\t\t     (priv->wep_is_on && priv->BSSinfo[i].UsingWEP)) &&\n\t\t\t    !(priv->BSSinfo[i].channel & 0x80)) {\n\t\t\t\tmax_rssi = priv->BSSinfo[i].RSSI;\n\t\t\t\tpriv->current_BSS = max_index = i;\n\t\t\t}\n\t\t}\n\t\treturn max_index;\n\t}\n\n\tfor (i = 0; i < priv->BSS_list_entries; i++) {\n\t\tif (priv->SSID_size == priv->BSSinfo[i].SSIDsize &&\n\t\t    memcmp(priv->SSID, priv->BSSinfo[i].SSID, priv->SSID_size) == 0 &&\n\t\t    priv->operating_mode == priv->BSSinfo[i].BSStype &&\n\t\t    atmel_validate_channel(priv, priv->BSSinfo[i].channel) == 0) {\n\t\t\tif (priv->BSSinfo[i].RSSI >= max_rssi) {\n\t\t\t\tmax_rssi = priv->BSSinfo[i].RSSI;\n\t\t\t\tmax_index = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn max_index;\n}\n\nstatic void store_bss_info(struct atmel_private *priv,\n\t\t\t   struct ieee80211_hdr *header, u16 capability,\n\t\t\t   u16 beacon_period, u8 channel, u8 rssi, u8 ssid_len,\n\t\t\t   u8 *ssid, int is_beacon)\n{\n\tu8 *bss = capability & WLAN_CAPABILITY_ESS ? header->addr2 : header->addr3;\n\tint i, index;\n\n\tfor (index = -1, i = 0; i < priv->BSS_list_entries; i++)\n\t\tif (memcmp(bss, priv->BSSinfo[i].BSSID, ETH_ALEN) == 0)\n\t\t\tindex = i;\n\n\t \n\n\tif (index == -1) {\n\t\tif (priv->BSS_list_entries == MAX_BSS_ENTRIES)\n\t\t\treturn;\n\t\tindex = priv->BSS_list_entries++;\n\t\tmemcpy(priv->BSSinfo[index].BSSID, bss, ETH_ALEN);\n\t\tpriv->BSSinfo[index].RSSI = rssi;\n\t} else {\n\t\tif (rssi > priv->BSSinfo[index].RSSI)\n\t\t\tpriv->BSSinfo[index].RSSI = rssi;\n\t\tif (is_beacon)\n\t\t\treturn;\n\t}\n\n\tpriv->BSSinfo[index].channel = channel;\n\tpriv->BSSinfo[index].beacon_period = beacon_period;\n\tpriv->BSSinfo[index].UsingWEP = capability & WLAN_CAPABILITY_PRIVACY;\n\tmemcpy(priv->BSSinfo[index].SSID, ssid, ssid_len);\n\tpriv->BSSinfo[index].SSIDsize = ssid_len;\n\n\tif (capability & WLAN_CAPABILITY_IBSS)\n\t\tpriv->BSSinfo[index].BSStype = IW_MODE_ADHOC;\n\telse if (capability & WLAN_CAPABILITY_ESS)\n\t\tpriv->BSSinfo[index].BSStype = IW_MODE_INFRA;\n\n\tpriv->BSSinfo[index].preamble = capability & WLAN_CAPABILITY_SHORT_PREAMBLE ?\n\t\tSHORT_PREAMBLE : LONG_PREAMBLE;\n}\n\nstatic void authenticate(struct atmel_private *priv, u16 frame_len)\n{\n\tstruct auth_body *auth = (struct auth_body *)priv->rx_buf;\n\tu16 status = le16_to_cpu(auth->status);\n\tu16 trans_seq_no = le16_to_cpu(auth->trans_seq);\n\tu16 system = le16_to_cpu(auth->alg);\n\n\tif (status == WLAN_STATUS_SUCCESS && !priv->wep_is_on) {\n\t\t \n\t\tif (priv->station_was_associated) {\n\t\t\tatmel_enter_state(priv, STATION_STATE_REASSOCIATING);\n\t\t\tsend_association_request(priv, 1);\n\t\t\treturn;\n\t\t} else {\n\t\t\tatmel_enter_state(priv, STATION_STATE_ASSOCIATING);\n\t\t\tsend_association_request(priv, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (status == WLAN_STATUS_SUCCESS && priv->wep_is_on) {\n\t\tint should_associate = 0;\n\t\t \n\t\tif (trans_seq_no != priv->ExpectedAuthentTransactionSeqNum)\n\t\t\treturn;\n\n\t\tif (system == WLAN_AUTH_OPEN) {\n\t\t\tif (trans_seq_no == 0x0002) {\n\t\t\t\tshould_associate = 1;\n\t\t\t}\n\t\t} else if (system == WLAN_AUTH_SHARED_KEY) {\n\t\t\tif (trans_seq_no == 0x0002 &&\n\t\t\t    auth->el_id == WLAN_EID_CHALLENGE) {\n\t\t\t\tsend_authentication_request(priv, system, auth->chall_text, auth->chall_text_len);\n\t\t\t\treturn;\n\t\t\t} else if (trans_seq_no == 0x0004) {\n\t\t\t\tshould_associate = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (should_associate) {\n\t\t\tif (priv->station_was_associated) {\n\t\t\t\tatmel_enter_state(priv, STATION_STATE_REASSOCIATING);\n\t\t\t\tsend_association_request(priv, 1);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tatmel_enter_state(priv, STATION_STATE_ASSOCIATING);\n\t\t\t\tsend_association_request(priv, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (status == WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG) {\n\t\t \n\t\tif (system == WLAN_AUTH_OPEN) {\n\t\t\tpriv->CurrentAuthentTransactionSeqNum = 0x001;\n\t\t\tpriv->exclude_unencrypted = 1;\n\t\t\tsend_authentication_request(priv, WLAN_AUTH_SHARED_KEY, NULL, 0);\n\t\t\treturn;\n\t\t} else if (system == WLAN_AUTH_SHARED_KEY\n\t\t\t   && priv->wep_is_on) {\n\t\t\tpriv->CurrentAuthentTransactionSeqNum = 0x001;\n\t\t\tpriv->exclude_unencrypted = 0;\n\t\t\tsend_authentication_request(priv, WLAN_AUTH_OPEN, NULL, 0);\n\t\t\treturn;\n\t\t} else if (priv->connect_to_any_BSS) {\n\t\t\tint bss_index;\n\n\t\t\tpriv->BSSinfo[(int)(priv->current_BSS)].channel |= 0x80;\n\n\t\t\tif ((bss_index  = retrieve_bss(priv)) != -1) {\n\t\t\t\tatmel_join_bss(priv, bss_index);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriv->AuthenticationRequestRetryCnt = 0;\n\tatmel_enter_state(priv,  STATION_STATE_MGMT_ERROR);\n\tpriv->station_is_associated = 0;\n}\n\nstatic void associate(struct atmel_private *priv, u16 frame_len, u16 subtype)\n{\n\tstruct ass_resp_format {\n\t\t__le16 capability;\n\t\t__le16 status;\n\t\t__le16 ass_id;\n\t\tu8 el_id;\n\t\tu8 length;\n\t\tu8 rates[4];\n\t} *ass_resp = (struct ass_resp_format *)priv->rx_buf;\n\n\tu16 status = le16_to_cpu(ass_resp->status);\n\tu16 ass_id = le16_to_cpu(ass_resp->ass_id);\n\tu16 rates_len = ass_resp->length > 4 ? 4 : ass_resp->length;\n\n\tunion iwreq_data wrqu;\n\n\tif (frame_len < 8 + rates_len)\n\t\treturn;\n\n\tif (status == WLAN_STATUS_SUCCESS) {\n\t\tif (subtype == IEEE80211_STYPE_ASSOC_RESP)\n\t\t\tpriv->AssociationRequestRetryCnt = 0;\n\t\telse\n\t\t\tpriv->ReAssociationRequestRetryCnt = 0;\n\n\t\tatmel_set_mib16(priv, Mac_Mgmt_Mib_Type,\n\t\t\t\tMAC_MGMT_MIB_STATION_ID_POS, ass_id & 0x3fff);\n\t\tatmel_set_mib(priv, Phy_Mib_Type,\n\t\t\t      PHY_MIB_RATE_SET_POS, ass_resp->rates, rates_len);\n\t\tif (priv->power_mode == 0) {\n\t\t\tpriv->listen_interval = 1;\n\t\t\tatmel_set_mib8(priv, Mac_Mgmt_Mib_Type,\n\t\t\t\t       MAC_MGMT_MIB_PS_MODE_POS, ACTIVE_MODE);\n\t\t\tatmel_set_mib16(priv, Mac_Mgmt_Mib_Type,\n\t\t\t\t\tMAC_MGMT_MIB_LISTEN_INTERVAL_POS, 1);\n\t\t} else {\n\t\t\tpriv->listen_interval = 2;\n\t\t\tatmel_set_mib8(priv, Mac_Mgmt_Mib_Type,\n\t\t\t\t       MAC_MGMT_MIB_PS_MODE_POS,  PS_MODE);\n\t\t\tatmel_set_mib16(priv, Mac_Mgmt_Mib_Type,\n\t\t\t\t\tMAC_MGMT_MIB_LISTEN_INTERVAL_POS, 2);\n\t\t}\n\n\t\tpriv->station_is_associated = 1;\n\t\tpriv->station_was_associated = 1;\n\t\tatmel_enter_state(priv, STATION_STATE_READY);\n\n\t\t \n\t\twrqu.data.length = 0;\n\t\twrqu.data.flags = 0;\n\t\tmemcpy(wrqu.ap_addr.sa_data, priv->CurrentBSSID, ETH_ALEN);\n\t\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\t\twireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);\n\n\t\treturn;\n\t}\n\n\tif (subtype == IEEE80211_STYPE_ASSOC_RESP &&\n\t    status != WLAN_STATUS_ASSOC_DENIED_RATES &&\n\t    status != WLAN_STATUS_CAPS_UNSUPPORTED &&\n\t    priv->AssociationRequestRetryCnt < MAX_ASSOCIATION_RETRIES) {\n\t\tmod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);\n\t\tpriv->AssociationRequestRetryCnt++;\n\t\tsend_association_request(priv, 0);\n\t\treturn;\n\t}\n\n\tif (subtype == IEEE80211_STYPE_REASSOC_RESP &&\n\t    status != WLAN_STATUS_ASSOC_DENIED_RATES &&\n\t    status != WLAN_STATUS_CAPS_UNSUPPORTED &&\n\t    priv->ReAssociationRequestRetryCnt < MAX_ASSOCIATION_RETRIES) {\n\t\tmod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);\n\t\tpriv->ReAssociationRequestRetryCnt++;\n\t\tsend_association_request(priv, 1);\n\t\treturn;\n\t}\n\n\tatmel_enter_state(priv,  STATION_STATE_MGMT_ERROR);\n\tpriv->station_is_associated = 0;\n\n\tif (priv->connect_to_any_BSS) {\n\t\tint bss_index;\n\t\tpriv->BSSinfo[(int)(priv->current_BSS)].channel |= 0x80;\n\n\t\tif ((bss_index = retrieve_bss(priv)) != -1)\n\t\t\tatmel_join_bss(priv, bss_index);\n\t}\n}\n\nstatic void atmel_join_bss(struct atmel_private *priv, int bss_index)\n{\n\tstruct bss_info *bss =  &priv->BSSinfo[bss_index];\n\n\tmemcpy(priv->CurrentBSSID, bss->BSSID, ETH_ALEN);\n\tmemcpy(priv->SSID, bss->SSID, priv->SSID_size = bss->SSIDsize);\n\n\t \n\tif (priv->use_wpa)\n\t\tbuild_wpa_mib(priv);\n\n\t \n\n\tif (bss->BSStype == IW_MODE_ADHOC &&\n\t    priv->operating_mode != IW_MODE_ADHOC &&\n\t    priv->power_mode) {\n\t\tpriv->power_mode = 0;\n\t\tpriv->listen_interval = 1;\n\t\tatmel_set_mib8(priv, Mac_Mgmt_Mib_Type,\n\t\t\t       MAC_MGMT_MIB_PS_MODE_POS,  ACTIVE_MODE);\n\t\tatmel_set_mib16(priv, Mac_Mgmt_Mib_Type,\n\t\t\t\tMAC_MGMT_MIB_LISTEN_INTERVAL_POS, 1);\n\t}\n\n\tpriv->operating_mode = bss->BSStype;\n\tpriv->channel = bss->channel & 0x7f;\n\tpriv->beacon_period = bss->beacon_period;\n\n\tif (priv->preamble != bss->preamble) {\n\t\tpriv->preamble = bss->preamble;\n\t\tatmel_set_mib8(priv, Local_Mib_Type,\n\t\t\t       LOCAL_MIB_PREAMBLE_TYPE, bss->preamble);\n\t}\n\n\tif (!priv->wep_is_on && bss->UsingWEP) {\n\t\tatmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\n\t\tpriv->station_is_associated = 0;\n\t\treturn;\n\t}\n\n\tif (priv->wep_is_on && !bss->UsingWEP) {\n\t\tatmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\n\t\tpriv->station_is_associated = 0;\n\t\treturn;\n\t}\n\n\tatmel_enter_state(priv, STATION_STATE_JOINNING);\n\n\tif (priv->operating_mode == IW_MODE_INFRA)\n\t\tjoin(priv, BSS_TYPE_INFRASTRUCTURE);\n\telse\n\t\tjoin(priv, BSS_TYPE_AD_HOC);\n}\n\nstatic void restart_search(struct atmel_private *priv)\n{\n\tint bss_index;\n\n\tif (!priv->connect_to_any_BSS) {\n\t\tatmel_scan(priv, 1);\n\t} else {\n\t\tpriv->BSSinfo[(int)(priv->current_BSS)].channel |= 0x80;\n\n\t\tif ((bss_index = retrieve_bss(priv)) != -1)\n\t\t\tatmel_join_bss(priv, bss_index);\n\t\telse\n\t\t\tatmel_scan(priv, 0);\n\t}\n}\n\nstatic void smooth_rssi(struct atmel_private *priv, u8 rssi)\n{\n\tu8 old = priv->wstats.qual.level;\n\tu8 max_rssi = 42;  \n\n\tswitch (priv->firmware_type) {\n\tcase ATMEL_FW_TYPE_502E:\n\t\tmax_rssi = 63;  \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trssi = rssi * 100 / max_rssi;\n\tif ((rssi + old) % 2)\n\t\tpriv->wstats.qual.level = (rssi + old) / 2 + 1;\n\telse\n\t\tpriv->wstats.qual.level = (rssi + old) / 2;\n\tpriv->wstats.qual.updated |= IW_QUAL_LEVEL_UPDATED;\n\tpriv->wstats.qual.updated &= ~IW_QUAL_LEVEL_INVALID;\n}\n\nstatic void atmel_smooth_qual(struct atmel_private *priv)\n{\n\tunsigned long time_diff = (jiffies - priv->last_qual) / HZ;\n\twhile (time_diff--) {\n\t\tpriv->last_qual += HZ;\n\t\tpriv->wstats.qual.qual = priv->wstats.qual.qual / 2;\n\t\tpriv->wstats.qual.qual +=\n\t\t\tpriv->beacons_this_sec * priv->beacon_period * (priv->wstats.qual.level + 100) / 4000;\n\t\tpriv->beacons_this_sec = 0;\n\t}\n\tpriv->wstats.qual.updated |= IW_QUAL_QUAL_UPDATED;\n\tpriv->wstats.qual.updated &= ~IW_QUAL_QUAL_INVALID;\n}\n\n \nstatic void atmel_management_frame(struct atmel_private *priv,\n\t\t\t\t   struct ieee80211_hdr *header,\n\t\t\t\t   u16 frame_len, u8 rssi)\n{\n\tu16 subtype;\n\n\tsubtype = le16_to_cpu(header->frame_control) & IEEE80211_FCTL_STYPE;\n\tswitch (subtype) {\n\tcase IEEE80211_STYPE_BEACON:\n\tcase IEEE80211_STYPE_PROBE_RESP:\n\n\t\t \n\t\t{\n\t\t\tstruct beacon_format {\n\t\t\t\t__le64 timestamp;\n\t\t\t\t__le16 interval;\n\t\t\t\t__le16 capability;\n\t\t\t\tu8 ssid_el_id;\n\t\t\t\tu8 ssid_length;\n\t\t\t\t \n\t\t\t\tu8 rates_el_id;\n\t\t\t\tu8 rates_length;\n\t\t\t\t \n\t\t\t\tu8 ds_el_id;\n\t\t\t\tu8 ds_length;\n\t\t\t\t \n\t\t\t} *beacon = (struct beacon_format *)priv->rx_buf;\n\n\t\t\tu8 channel, rates_length, ssid_length;\n\t\t\tu64 timestamp = le64_to_cpu(beacon->timestamp);\n\t\t\tu16 beacon_interval = le16_to_cpu(beacon->interval);\n\t\t\tu16 capability = le16_to_cpu(beacon->capability);\n\t\t\tu8 *beaconp = priv->rx_buf;\n\t\t\tssid_length = beacon->ssid_length;\n\t\t\t \n\t\t\tif (frame_len < 14 || frame_len < ssid_length + 15)\n\t\t\t\treturn;\n\t\t\trates_length = beaconp[beacon->ssid_length + 15];\n\t\t\tif (frame_len < ssid_length + rates_length + 18)\n\t\t\t\treturn;\n\t\t\tif (ssid_length >  MAX_SSID_LENGTH)\n\t\t\t\treturn;\n\t\t\tchannel = beaconp[ssid_length + rates_length + 18];\n\n\t\t\tif (priv->station_state == STATION_STATE_READY) {\n\t\t\t\tsmooth_rssi(priv, rssi);\n\t\t\t\tif (is_frame_from_current_bss(priv, header)) {\n\t\t\t\t\tpriv->beacons_this_sec++;\n\t\t\t\t\tatmel_smooth_qual(priv);\n\t\t\t\t\tif (priv->last_beacon_timestamp) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tu32 beacon_delay = timestamp - priv->last_beacon_timestamp;\n\t\t\t\t\t\tint beacons = beacon_delay / (beacon_interval * 1000);\n\t\t\t\t\t\tif (beacons > 1)\n\t\t\t\t\t\t\tpriv->wstats.miss.beacon += beacons - 1;\n\t\t\t\t\t}\n\t\t\t\t\tpriv->last_beacon_timestamp = timestamp;\n\t\t\t\t\thandle_beacon_probe(priv, capability, channel);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (priv->station_state == STATION_STATE_SCANNING)\n\t\t\t\tstore_bss_info(priv, header, capability,\n\t\t\t\t\t       beacon_interval, channel, rssi,\n\t\t\t\t\t       ssid_length,\n\t\t\t\t\t       &beacon->rates_el_id,\n\t\t\t\t\t       subtype == IEEE80211_STYPE_BEACON);\n\t\t}\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_AUTH:\n\n\t\tif (priv->station_state == STATION_STATE_AUTHENTICATING)\n\t\t\tauthenticate(priv, frame_len);\n\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_ASSOC_RESP:\n\tcase IEEE80211_STYPE_REASSOC_RESP:\n\n\t\tif (priv->station_state == STATION_STATE_ASSOCIATING ||\n\t\t    priv->station_state == STATION_STATE_REASSOCIATING)\n\t\t\tassociate(priv, frame_len, subtype);\n\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_DISASSOC:\n\t\tif (priv->station_is_associated &&\n\t\t    priv->operating_mode == IW_MODE_INFRA &&\n\t\t    is_frame_from_current_bss(priv, header)) {\n\t\t\tpriv->station_was_associated = 0;\n\t\t\tpriv->station_is_associated = 0;\n\n\t\t\tatmel_enter_state(priv, STATION_STATE_JOINNING);\n\t\t\tjoin(priv, BSS_TYPE_INFRASTRUCTURE);\n\t\t}\n\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_DEAUTH:\n\t\tif (priv->operating_mode == IW_MODE_INFRA &&\n\t\t    is_frame_from_current_bss(priv, header)) {\n\t\t\tpriv->station_was_associated = 0;\n\n\t\t\tatmel_enter_state(priv, STATION_STATE_JOINNING);\n\t\t\tjoin(priv, BSS_TYPE_INFRASTRUCTURE);\n\t\t}\n\n\t\tbreak;\n\t}\n}\n\n \nstatic void atmel_management_timer(struct timer_list *t)\n{\n\tstruct atmel_private *priv = from_timer(priv, t, management_timer);\n\tunsigned long flags;\n\n\t \n\tif (priv->card && priv->present_callback &&\n\t\t!(*priv->present_callback)(priv->card))\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->irqlock, flags);\n\n\tswitch (priv->station_state) {\n\n\tcase STATION_STATE_AUTHENTICATING:\n\t\tif (priv->AuthenticationRequestRetryCnt >= MAX_AUTHENTICATION_RETRIES) {\n\t\t\tatmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\n\t\t\tpriv->station_is_associated = 0;\n\t\t\tpriv->AuthenticationRequestRetryCnt = 0;\n\t\t\trestart_search(priv);\n\t\t} else {\n\t\t\tint auth = WLAN_AUTH_OPEN;\n\t\t\tpriv->AuthenticationRequestRetryCnt++;\n\t\t\tpriv->CurrentAuthentTransactionSeqNum = 0x0001;\n\t\t\tmod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);\n\t\t\tif (priv->wep_is_on && priv->exclude_unencrypted)\n\t\t\t\tauth = WLAN_AUTH_SHARED_KEY;\n\t\t\tsend_authentication_request(priv, auth, NULL, 0);\n\t  }\n\t  break;\n\n\tcase STATION_STATE_ASSOCIATING:\n\t\tif (priv->AssociationRequestRetryCnt == MAX_ASSOCIATION_RETRIES) {\n\t\t\tatmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\n\t\t\tpriv->station_is_associated = 0;\n\t\t\tpriv->AssociationRequestRetryCnt = 0;\n\t\t\trestart_search(priv);\n\t\t} else {\n\t\t\tpriv->AssociationRequestRetryCnt++;\n\t\t\tmod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);\n\t\t\tsend_association_request(priv, 0);\n\t\t}\n\t  break;\n\n\tcase STATION_STATE_REASSOCIATING:\n\t\tif (priv->ReAssociationRequestRetryCnt == MAX_ASSOCIATION_RETRIES) {\n\t\t\tatmel_enter_state(priv, STATION_STATE_MGMT_ERROR);\n\t\t\tpriv->station_is_associated = 0;\n\t\t\tpriv->ReAssociationRequestRetryCnt = 0;\n\t\t\trestart_search(priv);\n\t\t} else {\n\t\t\tpriv->ReAssociationRequestRetryCnt++;\n\t\t\tmod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);\n\t\t\tsend_association_request(priv, 1);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&priv->irqlock, flags);\n}\n\nstatic void atmel_command_irq(struct atmel_private *priv)\n{\n\tu8 status = atmel_rmem8(priv, atmel_co(priv, CMD_BLOCK_STATUS_OFFSET));\n\tu8 command = atmel_rmem8(priv, atmel_co(priv, CMD_BLOCK_COMMAND_OFFSET));\n\tint fast_scan;\n\tunion iwreq_data wrqu;\n\n\tif (status == CMD_STATUS_IDLE ||\n\t    status == CMD_STATUS_IN_PROGRESS)\n\t\treturn;\n\n\tswitch (command) {\n\tcase CMD_Start:\n\t\tif (status == CMD_STATUS_COMPLETE) {\n\t\t\tpriv->station_was_associated = priv->station_is_associated;\n\t\t\tatmel_get_mib(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_BSSID_POS,\n\t\t\t\t      (u8 *)priv->CurrentBSSID, 6);\n\t\t\tatmel_enter_state(priv, STATION_STATE_READY);\n\t\t}\n\t\tbreak;\n\n\tcase CMD_Scan:\n\t\tfast_scan = priv->fast_scan;\n\t\tpriv->fast_scan = 0;\n\n\t\tif (status != CMD_STATUS_COMPLETE) {\n\t\t\tatmel_scan(priv, 1);\n\t\t} else {\n\t\t\tint bss_index = retrieve_bss(priv);\n\t\t\tint notify_scan_complete = 1;\n\t\t\tif (bss_index != -1) {\n\t\t\t\tatmel_join_bss(priv, bss_index);\n\t\t\t} else if (priv->operating_mode == IW_MODE_ADHOC &&\n\t\t\t\t   priv->SSID_size != 0) {\n\t\t\t\tstart(priv, BSS_TYPE_AD_HOC);\n\t\t\t} else {\n\t\t\t\tpriv->fast_scan = !fast_scan;\n\t\t\t\tatmel_scan(priv, 1);\n\t\t\t\tnotify_scan_complete = 0;\n\t\t\t}\n\t\t\tpriv->site_survey_state = SITE_SURVEY_COMPLETED;\n\t\t\tif (notify_scan_complete) {\n\t\t\t\twrqu.data.length = 0;\n\t\t\t\twrqu.data.flags = 0;\n\t\t\t\twireless_send_event(priv->dev, SIOCGIWSCAN, &wrqu, NULL);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase CMD_SiteSurvey:\n\t\tpriv->fast_scan = 0;\n\n\t\tif (status != CMD_STATUS_COMPLETE)\n\t\t\treturn;\n\n\t\tpriv->site_survey_state = SITE_SURVEY_COMPLETED;\n\t\tif (priv->station_is_associated) {\n\t\t\tatmel_enter_state(priv, STATION_STATE_READY);\n\t\t\twrqu.data.length = 0;\n\t\t\twrqu.data.flags = 0;\n\t\t\twireless_send_event(priv->dev, SIOCGIWSCAN, &wrqu, NULL);\n\t\t} else {\n\t\t\tatmel_scan(priv, 1);\n\t\t}\n\t\tbreak;\n\n\tcase CMD_Join:\n\t\tif (status == CMD_STATUS_COMPLETE) {\n\t\t\tif (priv->operating_mode == IW_MODE_ADHOC) {\n\t\t\t\tpriv->station_was_associated = priv->station_is_associated;\n\t\t\t\tatmel_enter_state(priv, STATION_STATE_READY);\n\t\t\t} else {\n\t\t\t\tint auth = WLAN_AUTH_OPEN;\n\t\t\t\tpriv->AuthenticationRequestRetryCnt = 0;\n\t\t\t\tatmel_enter_state(priv, STATION_STATE_AUTHENTICATING);\n\n\t\t\t\tmod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);\n\t\t\t\tpriv->CurrentAuthentTransactionSeqNum = 0x0001;\n\t\t\t\tif (priv->wep_is_on && priv->exclude_unencrypted)\n\t\t\t\t\tauth = WLAN_AUTH_SHARED_KEY;\n\t\t\t\tsend_authentication_request(priv, auth, NULL, 0);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tatmel_scan(priv, 1);\n\t}\n}\n\nstatic int atmel_wakeup_firmware(struct atmel_private *priv)\n{\n\tstruct host_info_struct *iface = &priv->host_info;\n\tu16 mr1, mr3;\n\tint i;\n\n\tif (priv->card_type == CARD_TYPE_SPI_FLASH)\n\t\tatmel_set_gcr(priv->dev, GCR_REMAP);\n\n\t \n\tatmel_clear_gcr(priv->dev, 0x0040);\n\tatmel_write16(priv->dev, BSR, BSS_SRAM);\n\n\tif (priv->card_type == CARD_TYPE_SPI_FLASH)\n\t\tmdelay(100);\n\n\t \n\tfor (i = LOOP_RETRY_LIMIT; i; i--) {\n\t\tmr1 = atmel_read16(priv->dev, MR1);\n\t\tmr3 = atmel_read16(priv->dev, MR3);\n\n\t\tif (mr3 & MAC_BOOT_COMPLETE)\n\t\t\tbreak;\n\t\tif (mr1 & MAC_BOOT_COMPLETE &&\n\t\t    priv->bus_type == BUS_TYPE_PCCARD)\n\t\t\tbreak;\n\t}\n\n\tif (i == 0) {\n\t\tprintk(KERN_ALERT \"%s: MAC failed to boot.\\n\", priv->dev->name);\n\t\treturn -EIO;\n\t}\n\n\tif ((priv->host_info_base = atmel_read16(priv->dev, MR2)) == 0xffff) {\n\t\tprintk(KERN_ALERT \"%s: card missing.\\n\", priv->dev->name);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\tatmel_wmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET), FUNC_CTRL_INIT_COMPLETE);\n\n\tfor (i = LOOP_RETRY_LIMIT; i; i--) {\n\t\tmr1 = atmel_read16(priv->dev, MR1);\n\t\tmr3 = atmel_read16(priv->dev, MR3);\n\n\t\tif (mr3 & MAC_INIT_COMPLETE)\n\t\t\tbreak;\n\t\tif (mr1 & MAC_INIT_COMPLETE &&\n\t\t    priv->bus_type == BUS_TYPE_PCCARD)\n\t\t\tbreak;\n\t}\n\n\tif (i == 0) {\n\t\tprintk(KERN_ALERT \"%s: MAC failed to initialise.\\n\",\n\t\t\t\tpriv->dev->name);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif ((mr3 & MAC_INIT_COMPLETE) &&\n\t    !(atmel_read16(priv->dev, MR3) & MAC_INIT_OK)) {\n\t\tprintk(KERN_ALERT \"%s: MAC failed MR3 self-test.\\n\", priv->dev->name);\n\t\treturn -EIO;\n\t}\n\tif ((mr1 & MAC_INIT_COMPLETE) &&\n\t    !(atmel_read16(priv->dev, MR1) & MAC_INIT_OK)) {\n\t\tprintk(KERN_ALERT \"%s: MAC failed MR1 self-test.\\n\", priv->dev->name);\n\t\treturn -EIO;\n\t}\n\n\tatmel_copy_to_host(priv->dev, (unsigned char *)iface,\n\t\t\t   priv->host_info_base, sizeof(*iface));\n\n\tiface->tx_buff_pos = le16_to_cpu(iface->tx_buff_pos);\n\tiface->tx_buff_size = le16_to_cpu(iface->tx_buff_size);\n\tiface->tx_desc_pos = le16_to_cpu(iface->tx_desc_pos);\n\tiface->tx_desc_count = le16_to_cpu(iface->tx_desc_count);\n\tiface->rx_buff_pos = le16_to_cpu(iface->rx_buff_pos);\n\tiface->rx_buff_size = le16_to_cpu(iface->rx_buff_size);\n\tiface->rx_desc_pos = le16_to_cpu(iface->rx_desc_pos);\n\tiface->rx_desc_count = le16_to_cpu(iface->rx_desc_count);\n\tiface->build_version = le16_to_cpu(iface->build_version);\n\tiface->command_pos = le16_to_cpu(iface->command_pos);\n\tiface->major_version = le16_to_cpu(iface->major_version);\n\tiface->minor_version = le16_to_cpu(iface->minor_version);\n\tiface->func_ctrl = le16_to_cpu(iface->func_ctrl);\n\tiface->mac_status = le16_to_cpu(iface->mac_status);\n\n\treturn 0;\n}\n\n \nstatic int probe_atmel_card(struct net_device *dev)\n{\n\tint rc = 0;\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tu8 addr[ETH_ALEN] = {};\n\n\t \n\tif (priv->bus_type == BUS_TYPE_PCCARD)\n\t\tatmel_write16(dev, GCR, 0x0060);\n\n\tatmel_write16(dev, GCR, 0x0040);\n\tmsleep(500);\n\n\tif (atmel_read16(dev, MR2) == 0) {\n\t\t \n\t\tint i;\n\t\tpriv->card_type = CARD_TYPE_EEPROM;\n\t\tatmel_write16(dev, BSR, BSS_IRAM);\n\t\tatmel_copy_to_card(dev, 0, mac_reader, sizeof(mac_reader));\n\t\tatmel_set_gcr(dev, GCR_REMAP);\n\t\tatmel_clear_gcr(priv->dev, 0x0040);\n\t\tatmel_write16(dev, BSR, BSS_SRAM);\n\t\tfor (i = LOOP_RETRY_LIMIT; i; i--)\n\t\t\tif (atmel_read16(dev, MR3) & MAC_BOOT_COMPLETE)\n\t\t\t\tbreak;\n\t\tif (i == 0) {\n\t\t\tprintk(KERN_ALERT \"%s: MAC failed to boot MAC address reader.\\n\", dev->name);\n\t\t} else {\n\n\t\t\tatmel_copy_to_host(dev, addr, atmel_read16(dev, MR2), 6);\n\t\t\teth_hw_addr_set(dev, addr);\n\t\t\t \n\t\t\tif (priv->bus_type == BUS_TYPE_PCCARD)\n\t\t\t\tatmel_write16(dev, GCR, 0x0060);\n\t\t\tatmel_write16(dev, GCR, 0x0040);\n\t\t\trc = 1;\n\t\t}\n\t} else if (atmel_read16(dev, MR4) == 0) {\n\t\t \n\t\tpriv->card_type = CARD_TYPE_PARALLEL_FLASH;\n\t\tatmel_write16(dev,  BSR, 1);\n\t\tatmel_copy_to_host(dev, addr, 0xc000, 6);\n\t\teth_hw_addr_set(dev, addr);\n\t\tatmel_write16(dev,  BSR, 0x200);\n\t\trc = 1;\n\t} else {\n\t\t \n\t\tpriv->card_type = CARD_TYPE_SPI_FLASH;\n\t\tif (atmel_wakeup_firmware(priv) == 0) {\n\t\t\tatmel_get_mib(priv, Mac_Address_Mib_Type, 0, addr, 6);\n\t\t\teth_hw_addr_set(dev, addr);\n\n\t\t\t \n\t\t\tif (priv->bus_type == BUS_TYPE_PCCARD)\n\t\t\t\tatmel_write16(dev, GCR, 0x0060);\n\t\t\tatmel_write16(dev, GCR, 0x0040);\n\t\t\trc = 1;\n\t\t}\n\t}\n\n\tif (rc) {\n\t\tif (dev->dev_addr[0] == 0xFF) {\n\t\t\tstatic const u8 default_mac[] = {\n\t\t\t\t0x00, 0x04, 0x25, 0x00, 0x00, 0x00\n\t\t\t};\n\t\t\tprintk(KERN_ALERT \"%s: *** Invalid MAC address. UPGRADE Firmware ****\\n\", dev->name);\n\t\t\teth_hw_addr_set(dev, default_mac);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n \nstatic void build_wep_mib(struct atmel_private *priv)\n{\n\tstruct {  \n\t\tu8 wep_is_on;\n\t\tu8 default_key;  \n\t\tu8 reserved;\n\t\tu8 exclude_unencrypted;\n\n\t\tu32 WEPICV_error_count;\n\t\tu32 WEP_excluded_count;\n\n\t\tu8 wep_keys[MAX_ENCRYPTION_KEYS][13];\n\t\tu8 encryption_level;  \n\t\tu8 reserved2[3];\n\t} mib;\n\tint i;\n\n\tmib.wep_is_on = priv->wep_is_on;\n\tif (priv->wep_is_on) {\n\t\tif (priv->wep_key_len[priv->default_key] > 5)\n\t\t\tmib.encryption_level = 2;\n\t\telse\n\t\t\tmib.encryption_level = 1;\n\t} else {\n\t\tmib.encryption_level = 0;\n\t}\n\n\tmib.default_key = priv->default_key;\n\tmib.exclude_unencrypted = priv->exclude_unencrypted;\n\n\tfor (i = 0; i < MAX_ENCRYPTION_KEYS; i++)\n\t\tmemcpy(mib.wep_keys[i], priv->wep_keys[i], 13);\n\n\tatmel_set_mib(priv, Mac_Wep_Mib_Type, 0, (u8 *)&mib, sizeof(mib));\n}\n\nstatic void build_wpa_mib(struct atmel_private *priv)\n{\n\t \n\n\tstruct {  \n\t\tu8 cipher_default_key_value[MAX_ENCRYPTION_KEYS][MAX_ENCRYPTION_KEY_SIZE];\n\t\tu8 receiver_address[ETH_ALEN];\n\t\tu8 wep_is_on;\n\t\tu8 default_key;  \n\t\tu8 group_key;\n\t\tu8 exclude_unencrypted;\n\t\tu8 encryption_type;\n\t\tu8 reserved;\n\n\t\tu32 WEPICV_error_count;\n\t\tu32 WEP_excluded_count;\n\n\t\tu8 key_RSC[4][8];\n\t} mib;\n\n\tint i;\n\n\tmib.wep_is_on = priv->wep_is_on;\n\tmib.exclude_unencrypted = priv->exclude_unencrypted;\n\tmemcpy(mib.receiver_address, priv->CurrentBSSID, ETH_ALEN);\n\n\t \n\tmemset(mib.cipher_default_key_value, 0, sizeof(mib.cipher_default_key_value));\n\n\tif (priv->wep_is_on) {\n\t\t \n\t\tmemset(mib.key_RSC, 0, sizeof(mib.key_RSC));\n\n\t\tmib.default_key = mib.group_key = 255;\n\t\tfor (i = 0; i < MAX_ENCRYPTION_KEYS; i++) {\n\t\t\tif (priv->wep_key_len[i] > 0) {\n\t\t\t\tmemcpy(mib.cipher_default_key_value[i], priv->wep_keys[i], MAX_ENCRYPTION_KEY_SIZE);\n\t\t\t\tif (i == priv->default_key) {\n\t\t\t\t\tmib.default_key = i;\n\t\t\t\t\tmib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-1] = 7;\n\t\t\t\t\tmib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-2] = priv->pairwise_cipher_suite;\n\t\t\t\t} else {\n\t\t\t\t\tmib.group_key = i;\n\t\t\t\t\tpriv->group_cipher_suite = priv->pairwise_cipher_suite;\n\t\t\t\t\tmib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-1] = 1;\n\t\t\t\t\tmib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-2] = priv->group_cipher_suite;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (mib.default_key == 255)\n\t\t\tmib.default_key = mib.group_key != 255 ? mib.group_key : 0;\n\t\tif (mib.group_key == 255)\n\t\t\tmib.group_key = mib.default_key;\n\n\t}\n\n\tatmel_set_mib(priv, Mac_Wep_Mib_Type, 0, (u8 *)&mib, sizeof(mib));\n}\n\nstatic int reset_atmel_card(struct net_device *dev)\n{\n\t \n\n\tstruct atmel_private *priv = netdev_priv(dev);\n\tu8 configuration;\n\tint old_state = priv->station_state;\n\tint err = 0;\n\n\t \n\n\tstatic char *firmware_modifier[] = {\n\t\t\"-wpa\",\n\t\t\"\",\n\t\tNULL\n\t};\n\n\t \n\tif (priv->bus_type == BUS_TYPE_PCCARD)\n\t\tatmel_write16(priv->dev, GCR, 0x0060);\n\n\t \n\tatmel_write16(priv->dev, GCR, 0x0040);\n\n\tif (priv->card_type == CARD_TYPE_EEPROM) {\n\t\t \n\t\tconst struct firmware *fw_entry = NULL;\n\t\tconst unsigned char *fw;\n\t\tint len = priv->firmware_length;\n\t\tif (!(fw = priv->firmware)) {\n\t\t\tif (priv->firmware_type == ATMEL_FW_TYPE_NONE) {\n\t\t\t\tif (strlen(priv->firmware_id) == 0) {\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"%s: card type is unknown: assuming at76c502 firmware is OK.\\n\",\n\t\t\t\t\t       dev->name);\n\t\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t       \"%s: if not, use the firmware= module parameter.\\n\",\n\t\t\t\t\t       dev->name);\n\t\t\t\t\tstrcpy(priv->firmware_id, \"atmel_at76c502.bin\");\n\t\t\t\t}\n\t\t\t\terr = request_firmware(&fw_entry, priv->firmware_id, priv->sys_dev);\n\t\t\t\tif (err != 0) {\n\t\t\t\t\tprintk(KERN_ALERT\n\t\t\t\t\t       \"%s: firmware %s is missing, cannot continue.\\n\",\n\t\t\t\t\t       dev->name, priv->firmware_id);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint fw_index = 0;\n\t\t\t\tint success = 0;\n\n\t\t\t\t \n\t\t\t\twhile (fw_table[fw_index].fw_type != priv->firmware_type\n\t\t\t\t\t\t&& fw_table[fw_index].fw_type != ATMEL_FW_TYPE_NONE)\n\t\t\t\t\tfw_index++;\n\n\t\t\t\t \n\t\t\t\tif (fw_table[fw_index].fw_type != ATMEL_FW_TYPE_NONE) {\n\t\t\t\t\tint i;\n\t\t\t\t\tfor (i = 0; firmware_modifier[i]; i++) {\n\t\t\t\t\t\tsnprintf(priv->firmware_id, 32, \"%s%s.%s\", fw_table[fw_index].fw_file,\n\t\t\t\t\t\t\tfirmware_modifier[i], fw_table[fw_index].fw_file_ext);\n\t\t\t\t\t\tpriv->firmware_id[31] = '\\0';\n\t\t\t\t\t\tif (request_firmware(&fw_entry, priv->firmware_id, priv->sys_dev) == 0) {\n\t\t\t\t\t\t\tsuccess = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!success) {\n\t\t\t\t\tprintk(KERN_ALERT\n\t\t\t\t\t       \"%s: firmware %s is missing, cannot start.\\n\",\n\t\t\t\t\t       dev->name, priv->firmware_id);\n\t\t\t\t\tpriv->firmware_id[0] = '\\0';\n\t\t\t\t\treturn -ENOENT;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfw = fw_entry->data;\n\t\t\tlen = fw_entry->size;\n\t\t}\n\n\t\tif (len <= 0x6000) {\n\t\t\tatmel_write16(priv->dev, BSR, BSS_IRAM);\n\t\t\tatmel_copy_to_card(priv->dev, 0, fw, len);\n\t\t\tatmel_set_gcr(priv->dev, GCR_REMAP);\n\t\t} else {\n\t\t\t \n\t\t\tatmel_set_gcr(priv->dev, GCR_REMAP);\n\t\t\tatmel_write16(priv->dev, BSR, BSS_IRAM);\n\t\t\tatmel_copy_to_card(priv->dev, 0, fw, 0x6000);\n\t\t\tatmel_write16(priv->dev, BSR, 0x2ff);\n\t\t\tatmel_copy_to_card(priv->dev, 0x8000, &fw[0x6000], len - 0x6000);\n\t\t}\n\n\t\trelease_firmware(fw_entry);\n\t}\n\n\terr = atmel_wakeup_firmware(priv);\n\tif (err != 0)\n\t\treturn err;\n\n\t \n\tpriv->use_wpa = (priv->host_info.major_version == 4);\n\tpriv->radio_on_broken = (priv->host_info.major_version == 5);\n\n\t \n\tatmel_wmem8(priv, atmel_hi(priv, IFACE_INT_MASK_OFFSET), 0xff);\n\n\t \n\tatmel_wmem8(priv, atmel_tx(priv, TX_DESC_FLAGS_OFFSET, 0), 0);\n\tatmel_wmem32(priv, atmel_tx(priv, TX_DESC_NEXT_OFFSET, 0), 0x80000000L);\n\tatmel_wmem16(priv, atmel_tx(priv, TX_DESC_POS_OFFSET, 0), 0);\n\tatmel_wmem16(priv, atmel_tx(priv, TX_DESC_SIZE_OFFSET, 0), 0);\n\n\tpriv->tx_desc_free = priv->host_info.tx_desc_count;\n\tpriv->tx_desc_head = 0;\n\tpriv->tx_desc_tail = 0;\n\tpriv->tx_desc_previous = 0;\n\tpriv->tx_free_mem = priv->host_info.tx_buff_size;\n\tpriv->tx_buff_head = 0;\n\tpriv->tx_buff_tail = 0;\n\n\tconfiguration = atmel_rmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET));\n\tatmel_wmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET),\n\t\t\t\t   configuration | FUNC_CTRL_TxENABLE);\n\n\t \n\tpriv->rx_desc_head = 0;\n\n\tconfiguration = atmel_rmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET));\n\tatmel_wmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET),\n\t\t\t\t   configuration | FUNC_CTRL_RxENABLE);\n\n\tif (!priv->radio_on_broken) {\n\t\tif (atmel_send_command_wait(priv, CMD_EnableRadio, NULL, 0) ==\n\t\t    CMD_STATUS_REJECTED_RADIO_OFF) {\n\t\t\tprintk(KERN_INFO \"%s: cannot turn the radio on.\\n\",\n\t\t\t       dev->name);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tatmel_set_mib8(priv, Local_Mib_Type, LOCAL_MIB_AUTO_TX_RATE_POS, priv->auto_tx_rate);\n\tatmel_set_mib8(priv, Local_Mib_Type,  LOCAL_MIB_TX_PROMISCUOUS_POS,  PROM_MODE_OFF);\n\tatmel_set_mib16(priv, Mac_Mib_Type, MAC_MIB_RTS_THRESHOLD_POS, priv->rts_threshold);\n\tatmel_set_mib16(priv, Mac_Mib_Type, MAC_MIB_FRAG_THRESHOLD_POS, priv->frag_threshold);\n\tatmel_set_mib8(priv, Mac_Mib_Type, MAC_MIB_SHORT_RETRY_POS, priv->short_retry);\n\tatmel_set_mib8(priv, Mac_Mib_Type, MAC_MIB_LONG_RETRY_POS, priv->long_retry);\n\tatmel_set_mib8(priv, Local_Mib_Type, LOCAL_MIB_PREAMBLE_TYPE, priv->preamble);\n\tatmel_set_mib(priv, Mac_Address_Mib_Type, MAC_ADDR_MIB_MAC_ADDR_POS,\n\t\t      priv->dev->dev_addr, 6);\n\tatmel_set_mib8(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_PS_MODE_POS, ACTIVE_MODE);\n\tatmel_set_mib16(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_LISTEN_INTERVAL_POS, 1);\n\tatmel_set_mib16(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_BEACON_PER_POS, priv->default_beacon_period);\n\tatmel_set_mib(priv, Phy_Mib_Type, PHY_MIB_RATE_SET_POS, atmel_basic_rates, 4);\n\tatmel_set_mib8(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_PRIVACY_POS, priv->wep_is_on);\n\tif (priv->use_wpa)\n\t\tbuild_wpa_mib(priv);\n\telse\n\t\tbuild_wep_mib(priv);\n\n\tif (old_state == STATION_STATE_READY) {\n\t\tunion iwreq_data wrqu;\n\n\t\twrqu.data.length = 0;\n\t\twrqu.data.flags = 0;\n\t\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\t\teth_zero_addr(wrqu.ap_addr.sa_data);\n\t\twireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic void atmel_send_command(struct atmel_private *priv, int command,\n\t\t\t       void *cmd, int cmd_size)\n{\n\tif (cmd)\n\t\tatmel_copy_to_card(priv->dev, atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET),\n\t\t\t\t   cmd, cmd_size);\n\n\tatmel_wmem8(priv, atmel_co(priv, CMD_BLOCK_COMMAND_OFFSET), command);\n\tatmel_wmem8(priv, atmel_co(priv, CMD_BLOCK_STATUS_OFFSET), 0);\n}\n\nstatic int atmel_send_command_wait(struct atmel_private *priv, int command,\n\t\t\t\t   void *cmd, int cmd_size)\n{\n\tint i, status;\n\n\tatmel_send_command(priv, command, cmd, cmd_size);\n\n\tfor (i = 5000; i; i--) {\n\t\tstatus = atmel_rmem8(priv, atmel_co(priv, CMD_BLOCK_STATUS_OFFSET));\n\t\tif (status != CMD_STATUS_IDLE &&\n\t\t    status != CMD_STATUS_IN_PROGRESS)\n\t\t\tbreak;\n\t\tudelay(20);\n\t}\n\n\tif (i == 0) {\n\t\tprintk(KERN_ALERT \"%s: failed to contact MAC.\\n\", priv->dev->name);\n\t\tstatus =  CMD_STATUS_HOST_ERROR;\n\t} else {\n\t\tif (command != CMD_EnableRadio)\n\t\t\tstatus = CMD_STATUS_COMPLETE;\n\t}\n\n\treturn status;\n}\n\nstatic u8 atmel_get_mib8(struct atmel_private *priv, u8 type, u8 index)\n{\n\tstruct get_set_mib m;\n\tm.type = type;\n\tm.size = 1;\n\tm.index = index;\n\n\tatmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, MIB_HEADER_SIZE + 1);\n\treturn atmel_rmem8(priv, atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + MIB_HEADER_SIZE));\n}\n\nstatic void atmel_set_mib8(struct atmel_private *priv, u8 type, u8 index, u8 data)\n{\n\tstruct get_set_mib m;\n\tm.type = type;\n\tm.size = 1;\n\tm.index = index;\n\tm.data[0] = data;\n\n\tatmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, MIB_HEADER_SIZE + 1);\n}\n\nstatic void atmel_set_mib16(struct atmel_private *priv, u8 type, u8 index,\n\t\t\t    u16 data)\n{\n\tstruct get_set_mib m;\n\tm.type = type;\n\tm.size = 2;\n\tm.index = index;\n\tm.data[0] = data;\n\tm.data[1] = data >> 8;\n\n\tatmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, MIB_HEADER_SIZE + 2);\n}\n\nstatic void atmel_set_mib(struct atmel_private *priv, u8 type, u8 index,\n\t\t\t  const u8 *data, int data_len)\n{\n\tstruct get_set_mib m;\n\tm.type = type;\n\tm.size = data_len;\n\tm.index = index;\n\n\tif (data_len > MIB_MAX_DATA_BYTES)\n\t\tprintk(KERN_ALERT \"%s: MIB buffer too small.\\n\", priv->dev->name);\n\n\tmemcpy(m.data, data, data_len);\n\tatmel_send_command_wait(priv, CMD_Set_MIB_Vars, &m, MIB_HEADER_SIZE + data_len);\n}\n\nstatic void atmel_get_mib(struct atmel_private *priv, u8 type, u8 index,\n\t\t\t  u8 *data, int data_len)\n{\n\tstruct get_set_mib m;\n\tm.type = type;\n\tm.size = data_len;\n\tm.index = index;\n\n\tif (data_len > MIB_MAX_DATA_BYTES)\n\t\tprintk(KERN_ALERT \"%s: MIB buffer too small.\\n\", priv->dev->name);\n\n\tatmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, MIB_HEADER_SIZE + data_len);\n\tatmel_copy_to_host(priv->dev, data,\n\t\t\t   atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + MIB_HEADER_SIZE), data_len);\n}\n\nstatic void atmel_writeAR(struct net_device *dev, u16 data)\n{\n\tint i;\n\toutw(data, dev->base_addr + AR);\n\t \n\tfor (i = 0; data != inw(dev->base_addr + AR) && i < 10; i++)\n\t\toutw(data, dev->base_addr + AR);\n}\n\nstatic void atmel_copy_to_card(struct net_device *dev, u16 dest,\n\t\t\t       const unsigned char *src, u16 len)\n{\n\tint i;\n\tatmel_writeAR(dev, dest);\n\tif (dest % 2) {\n\t\tatmel_write8(dev, DR, *src);\n\t\tsrc++; len--;\n\t}\n\tfor (i = len; i > 1 ; i -= 2) {\n\t\tu8 lb = *src++;\n\t\tu8 hb = *src++;\n\t\tatmel_write16(dev, DR, lb | (hb << 8));\n\t}\n\tif (i)\n\t\tatmel_write8(dev, DR, *src);\n}\n\nstatic void atmel_copy_to_host(struct net_device *dev, unsigned char *dest,\n\t\t\t       u16 src, u16 len)\n{\n\tint i;\n\tatmel_writeAR(dev, src);\n\tif (src % 2) {\n\t\t*dest = atmel_read8(dev, DR);\n\t\tdest++; len--;\n\t}\n\tfor (i = len; i > 1 ; i -= 2) {\n\t\tu16 hw = atmel_read16(dev, DR);\n\t\t*dest++ = hw;\n\t\t*dest++ = hw >> 8;\n\t}\n\tif (i)\n\t\t*dest = atmel_read8(dev, DR);\n}\n\nstatic void atmel_set_gcr(struct net_device *dev, u16 mask)\n{\n\toutw(inw(dev->base_addr + GCR) | mask, dev->base_addr + GCR);\n}\n\nstatic void atmel_clear_gcr(struct net_device *dev, u16 mask)\n{\n\toutw(inw(dev->base_addr + GCR) & ~mask, dev->base_addr + GCR);\n}\n\nstatic int atmel_lock_mac(struct atmel_private *priv)\n{\n\tint i, j = 20;\n retry:\n\tfor (i = 5000; i; i--) {\n\t\tif (!atmel_rmem8(priv, atmel_hi(priv, IFACE_LOCKOUT_HOST_OFFSET)))\n\t\t\tbreak;\n\t\tudelay(20);\n\t}\n\n\tif (!i)\n\t\treturn 0;  \n\n\tatmel_wmem8(priv, atmel_hi(priv, IFACE_LOCKOUT_MAC_OFFSET), 1);\n\tif (atmel_rmem8(priv, atmel_hi(priv, IFACE_LOCKOUT_HOST_OFFSET))) {\n\t\tatmel_wmem8(priv, atmel_hi(priv, IFACE_LOCKOUT_MAC_OFFSET), 0);\n\t\tif (!j--)\n\t\t\treturn 0;  \n\t\tgoto retry;\n\t}\n\n\treturn 1;\n}\n\nstatic void atmel_wmem32(struct atmel_private *priv, u16 pos, u32 data)\n{\n\tatmel_writeAR(priv->dev, pos);\n\tatmel_write16(priv->dev, DR, data);  \n\tatmel_write16(priv->dev, DR, data >> 16);\n}\n\n \n \n \n#if 0\n\n \n \n \n \n \n \n \n\n \n \n \n \n \n \n\n\t.org 0\n    .set MRBASE, 0x8000000\n\t.set CPSR_INITIAL, 0xD3  \n\t.set CPSR_USER, 0xD1  \n\t.set SRAM_BASE,  0x02000000\n\t.set SP_BASE,    0x0F300000\n\t.set UNK_BASE,   0x0F000000  \n\t.set SPI_CGEN_BASE,  0x0E000000  \n\t.set UNK3_BASE,  0x02014000  \n\t.set STACK_BASE, 0x5600\n\t.set SP_SR, 0x10\n\t.set SP_TDRE, 2  \n\t.set SP_RDRF, 1  \n\t.set SP_SWRST, 0x80\n\t.set SP_SPIEN, 0x1\n\t.set SP_CR, 0    \n\t.set SP_MR, 4    \n\t.set SP_RDR, 0x08  \n\t.set SP_TDR, 0x0C  \n\t.set SP_CSR0, 0x30  \n\t.set SP_CSR1, 0x34\n\t.set SP_CSR2, 0x38\n\t.set SP_CSR3, 0x3C\n\t.set NVRAM_CMD_RDSR, 5  \n\t.set NVRAM_CMD_READ, 3  \n\t.set NVRAM_SR_RDY, 1  \n\t.set SPI_8CLOCKS, 0xFF  \n\n\t.set NVRAM_SCRATCH, 0x02000100   \n\t.set NVRAM_IMAGE, 0x02000200\n\t.set NVRAM_LENGTH, 0x0200\n\t.set MAC_ADDRESS_MIB, SRAM_BASE\n\t.set MAC_ADDRESS_LENGTH, 6\n\t.set MAC_BOOT_FLAG, 0x10\n\t.set MR1, 0\n\t.set MR2, 4\n\t.set MR3, 8\n\t.set MR4, 0xC\nRESET_VECTOR:\n\tb RESET_HANDLER\nUNDEF_VECTOR:\n\tb HALT1\nSWI_VECTOR:\n\tb HALT1\nIABORT_VECTOR:\n\tb HALT1\nDABORT_VECTOR:\nRESERVED_VECTOR:\n\tb HALT1\nIRQ_VECTOR:\n\tb HALT1\nFIQ_VECTOR:\n\tb HALT1\nHALT1:\tb HALT1\nRESET_HANDLER:\n\tmov     r0, #CPSR_INITIAL\n\tmsr\tCPSR_c, r0\t \n\n \n\tldr\tr0, =SPI_CGEN_BASE\n\tmov\tr1, #0\n\tmov\tr1, r1, lsl #3\n\torr\tr1, r1, #0\n\tstr\tr1, [r0]\n\tldr\tr1, [r0, #28]\n\tbic\tr1, r1, #16\n\tstr\tr1, [r0, #28]\n\tmov\tr1, #1\n\tstr\tr1, [r0, #8]\n\n\tldr\tr0, =MRBASE\n\tmov\tr1, #0\n\tstrh\tr1, [r0, #MR1]\n\tstrh\tr1, [r0, #MR2]\n\tstrh\tr1, [r0, #MR3]\n\tstrh\tr1, [r0, #MR4]\n\n\tmov\tsp, #STACK_BASE\n\tbl\tSP_INIT\n\tmov\tr0, #10\n\tbl\tDELAY9\n\tbl\tGET_MAC_ADDR\n\tbl\tGET_WHOLE_NVRAM\n\tldr\tr0, =MRBASE\n\tldr\tr1, =MAC_ADDRESS_MIB\n\tstrh\tr1, [r0, #MR2]\n\tldr\tr1, =NVRAM_IMAGE\n\tstrh\tr1, [r0, #MR4]\n\tmov\tr1, #MAC_BOOT_FLAG\n\tstrh\tr1, [r0, #MR3]\nHALT2:\tb HALT2\n.func Get_Whole_NVRAM, GET_WHOLE_NVRAM\nGET_WHOLE_NVRAM:\n\tstmdb\tsp!, {lr}\n\tmov\tr2, #0  \n\tmov\tr3, #NVRAM_LENGTH\n\tmov\tr1, #0\t\t \n\tldr\tr0, =NVRAM_IMAGE\n\tbl\tNVRAM_XFER\n\tldmia\tsp!, {lr}\n\tbx\tlr\n.endfunc\n\n.func Get_MAC_Addr, GET_MAC_ADDR\nGET_MAC_ADDR:\n\tstmdb\tsp!, {lr}\n\tmov\tr2, #0x120\t \n\tmov\tr3, #MAC_ADDRESS_LENGTH\n\tmov\tr1, #0\t\t \n\tldr\tr0, =MAC_ADDRESS_MIB\n\tbl\tNVRAM_XFER\n\tldmia\tsp!, {lr}\n\tbx\tlr\n.endfunc\n.ltorg\n.func Delay9, DELAY9\nDELAY9:\n\tadds\tr0, r0, r0, LSL #3    \nDELAYLOOP:\n\tbeq\tDELAY9_done\n\tsubs\tr0, r0, #1\n\tb\tDELAYLOOP\nDELAY9_done:\n\tbx\tlr\n.endfunc\n\n.func SP_Init, SP_INIT\nSP_INIT:\n\tmov\tr1, #SP_SWRST\n\tldr\tr0, =SP_BASE\n\tstr\tr1, [r0, #SP_CR]  \n\tmov\tr1, #0\n\tstr\tr1, [r0, #SP_CR]  \n\tmov\tr1, #SP_SPIEN\n\tstr\tr1, [r0, #SP_MR]  \n\tstr\tr1, [r0, #SP_CR]  \n\n \n\tldr\tr3, =SPI_CGEN_BASE\n\tldr\tr1, [r3, #28]\n\torr\tr1, r1, #0x2000\n\tstr\tr1, [r3, #28]\n\n\tldr\tr1, =0x2000c01\n\tstr\tr1, [r0, #SP_CSR0]\n\tldr\tr1, =0x2000201\n\tstr\tr1, [r0, #SP_CSR1]\n\tstr\tr1, [r0, #SP_CSR2]\n\tstr\tr1, [r0, #SP_CSR3]\n\tldr\tr1, [r0, #SP_SR]\n\tldr\tr0, [r0, #SP_RDR]\n\tbx\tlr\n.endfunc\n.func NVRAM_Init, NVRAM_INIT\nNVRAM_INIT:\n\tldr\tr1, =SP_BASE\n\tldr\tr0, [r1, #SP_RDR]\n\tmov\tr0, #NVRAM_CMD_RDSR\n\tstr\tr0, [r1, #SP_TDR]\nSP_loop1:\n\tldr\tr0, [r1, #SP_SR]\n\ttst\tr0, #SP_TDRE\n\tbeq\tSP_loop1\n\n\tmov\tr0, #SPI_8CLOCKS\n\tstr\tr0, [r1, #SP_TDR]\nSP_loop2:\n\tldr\tr0, [r1, #SP_SR]\n\ttst\tr0, #SP_TDRE\n\tbeq\tSP_loop2\n\n\tldr\tr0, [r1, #SP_RDR]\nSP_loop3:\n\tldr\tr0, [r1, #SP_SR]\n\ttst\tr0, #SP_RDRF\n\tbeq\tSP_loop3\n\n\tldr\tr0, [r1, #SP_RDR]\n\tand\tr0, r0, #255\n\tbx\tlr\n.endfunc\n\n.func NVRAM_Xfer, NVRAM_XFER\n\t \n\t \n\t \n\t \nNVRAM_XFER:\n\tstmdb\tsp!, {r4, r5, lr}\n\tmov\tr5, r0\t\t \n\tmov\tr4, r3\t\t \n\tmov\tr0, r2, LSR #5  \n\tand\tr0, r0, #8\n\tadd\tr0, r0, #NVRAM_CMD_READ\n\tldr\tr1, =NVRAM_SCRATCH\n\tstrb\tr0, [r1, #0]\t \n\tstrb\tr2, [r1, #1]     \n_local1:\n\tbl\tNVRAM_INIT\n\ttst\tr0, #NVRAM_SR_RDY\n\tbne\t_local1\n\tmov\tr0, #20\n\tbl\tDELAY9\n\tmov\tr2, r4\t\t \n\tmov\tr1, r5\t\t \n\tmov\tr0, #2\t\t \n\tbl\tNVRAM_XFER2\n\tldmia\tsp!, {r4, r5, lr}\n\tbx\tlr\n.endfunc\n\n.func NVRAM_Xfer2, NVRAM_XFER2\nNVRAM_XFER2:\n\tstmdb\tsp!, {r4, r5, r6, lr}\n\tldr\tr4, =SP_BASE\n\tmov\tr3, #0\n\tcmp\tr0, #0\n\tbls\t_local2\n\tldr\tr5, =NVRAM_SCRATCH\n_local4:\n\tldrb\tr6, [r5, r3]\n\tstr\tr6, [r4, #SP_TDR]\n_local3:\n\tldr\tr6, [r4, #SP_SR]\n\ttst\tr6, #SP_TDRE\n\tbeq\t_local3\n\tadd\tr3, r3, #1\n\tcmp\tr3, r0  \n\tblo\t_local4\n_local2:\n\tmov\tr3, #SPI_8CLOCKS\n\tstr\tr3, [r4, #SP_TDR]\n\tldr\tr0, [r4, #SP_RDR]\n_local5:\n\tldr\tr0, [r4, #SP_SR]\n\ttst\tr0, #SP_RDRF\n\tbeq\t_local5\n\tldr\tr0, [r4, #SP_RDR]  \n\tmov\tr0, #0\n\tcmp\tr2, #0   \n\tbls\t_local6\n_local7:\n\tldr\tr5, [r4, #SP_SR]\n\ttst\tr5, #SP_TDRE\n\tbeq\t_local7\n\tstr\tr3, [r4, #SP_TDR]   \n_local8:\n\tldr\tr5, [r4, #SP_SR]\n\ttst\tr5, #SP_RDRF\n\tbeq\t_local8\n\tldr\tr5, [r4, #SP_RDR]  \n\tstrb\tr5, [r1], #1  \n\tadd\tr0, r0, #1\n\tcmp\tr0, r2\n\tblo\t_local7  \n_local6:\n\tmov\tr0, #200\n\tbl\tDELAY9\n\tldmia\tsp!, {r4, r5, r6, lr}\n\tbx\tlr\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}