{
  "module_name": "pppoe.c",
  "hash_id": "abb6c8c5ef0690ced0ce09418a347e72968286e5bac1e047e1a83ddc53d15962",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ppp/pppoe.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/net.h>\n#include <linux/inetdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/if_ether.h>\n#include <linux/if_pppox.h>\n#include <linux/ppp_channel.h>\n#include <linux/ppp_defs.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/notifier.h>\n#include <linux/file.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#include <linux/nsproxy.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/sock.h>\n\n#include <linux/uaccess.h>\n\n#define PPPOE_HASH_BITS CONFIG_PPPOE_HASH_BITS\n#define PPPOE_HASH_SIZE (1 << PPPOE_HASH_BITS)\n#define PPPOE_HASH_MASK\t(PPPOE_HASH_SIZE - 1)\n\nstatic int __pppoe_xmit(struct sock *sk, struct sk_buff *skb);\n\nstatic const struct proto_ops pppoe_ops;\nstatic const struct ppp_channel_ops pppoe_chan_ops;\n\n \nstatic unsigned int pppoe_net_id __read_mostly;\nstruct pppoe_net {\n\t \n\tstruct pppox_sock *hash_table[PPPOE_HASH_SIZE];\n\trwlock_t hash_lock;\n};\n\n \nstatic inline bool stage_session(__be16 sid)\n{\n\treturn sid != 0;\n}\n\nstatic inline struct pppoe_net *pppoe_pernet(struct net *net)\n{\n\treturn net_generic(net, pppoe_net_id);\n}\n\nstatic inline int cmp_2_addr(struct pppoe_addr *a, struct pppoe_addr *b)\n{\n\treturn a->sid == b->sid && ether_addr_equal(a->remote, b->remote);\n}\n\nstatic inline int cmp_addr(struct pppoe_addr *a, __be16 sid, char *addr)\n{\n\treturn a->sid == sid && ether_addr_equal(a->remote, addr);\n}\n\n#if 8 % PPPOE_HASH_BITS\n#error 8 must be a multiple of PPPOE_HASH_BITS\n#endif\n\nstatic int hash_item(__be16 sid, unsigned char *addr)\n{\n\tunsigned char hash = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\thash ^= addr[i];\n\tfor (i = 0; i < sizeof(sid_t) * 8; i += 8)\n\t\thash ^= (__force __u32)sid >> i;\n\tfor (i = 8; (i >>= 1) >= PPPOE_HASH_BITS;)\n\t\thash ^= hash >> i;\n\n\treturn hash & PPPOE_HASH_MASK;\n}\n\n \nstatic struct pppox_sock *__get_item(struct pppoe_net *pn, __be16 sid,\n\t\t\t\tunsigned char *addr, int ifindex)\n{\n\tint hash = hash_item(sid, addr);\n\tstruct pppox_sock *ret;\n\n\tret = pn->hash_table[hash];\n\twhile (ret) {\n\t\tif (cmp_addr(&ret->pppoe_pa, sid, addr) &&\n\t\t    ret->pppoe_ifindex == ifindex)\n\t\t\treturn ret;\n\n\t\tret = ret->next;\n\t}\n\n\treturn NULL;\n}\n\nstatic int __set_item(struct pppoe_net *pn, struct pppox_sock *po)\n{\n\tint hash = hash_item(po->pppoe_pa.sid, po->pppoe_pa.remote);\n\tstruct pppox_sock *ret;\n\n\tret = pn->hash_table[hash];\n\twhile (ret) {\n\t\tif (cmp_2_addr(&ret->pppoe_pa, &po->pppoe_pa) &&\n\t\t    ret->pppoe_ifindex == po->pppoe_ifindex)\n\t\t\treturn -EALREADY;\n\n\t\tret = ret->next;\n\t}\n\n\tpo->next = pn->hash_table[hash];\n\tpn->hash_table[hash] = po;\n\n\treturn 0;\n}\n\nstatic void __delete_item(struct pppoe_net *pn, __be16 sid,\n\t\t\t\t\tchar *addr, int ifindex)\n{\n\tint hash = hash_item(sid, addr);\n\tstruct pppox_sock *ret, **src;\n\n\tret = pn->hash_table[hash];\n\tsrc = &pn->hash_table[hash];\n\n\twhile (ret) {\n\t\tif (cmp_addr(&ret->pppoe_pa, sid, addr) &&\n\t\t    ret->pppoe_ifindex == ifindex) {\n\t\t\t*src = ret->next;\n\t\t\tbreak;\n\t\t}\n\n\t\tsrc = &ret->next;\n\t\tret = ret->next;\n\t}\n}\n\n \nstatic inline struct pppox_sock *get_item(struct pppoe_net *pn, __be16 sid,\n\t\t\t\t\tunsigned char *addr, int ifindex)\n{\n\tstruct pppox_sock *po;\n\n\tread_lock_bh(&pn->hash_lock);\n\tpo = __get_item(pn, sid, addr, ifindex);\n\tif (po)\n\t\tsock_hold(sk_pppox(po));\n\tread_unlock_bh(&pn->hash_lock);\n\n\treturn po;\n}\n\nstatic inline struct pppox_sock *get_item_by_addr(struct net *net,\n\t\t\t\t\t\tstruct sockaddr_pppox *sp)\n{\n\tstruct net_device *dev;\n\tstruct pppoe_net *pn;\n\tstruct pppox_sock *pppox_sock = NULL;\n\n\tint ifindex;\n\n\trcu_read_lock();\n\tdev = dev_get_by_name_rcu(net, sp->sa_addr.pppoe.dev);\n\tif (dev) {\n\t\tifindex = dev->ifindex;\n\t\tpn = pppoe_pernet(net);\n\t\tpppox_sock = get_item(pn, sp->sa_addr.pppoe.sid,\n\t\t\t\tsp->sa_addr.pppoe.remote, ifindex);\n\t}\n\trcu_read_unlock();\n\treturn pppox_sock;\n}\n\nstatic inline void delete_item(struct pppoe_net *pn, __be16 sid,\n\t\t\t\t\tchar *addr, int ifindex)\n{\n\twrite_lock_bh(&pn->hash_lock);\n\t__delete_item(pn, sid, addr, ifindex);\n\twrite_unlock_bh(&pn->hash_lock);\n}\n\n \n\nstatic void pppoe_flush_dev(struct net_device *dev)\n{\n\tstruct pppoe_net *pn;\n\tint i;\n\n\tpn = pppoe_pernet(dev_net(dev));\n\twrite_lock_bh(&pn->hash_lock);\n\tfor (i = 0; i < PPPOE_HASH_SIZE; i++) {\n\t\tstruct pppox_sock *po = pn->hash_table[i];\n\t\tstruct sock *sk;\n\n\t\twhile (po) {\n\t\t\twhile (po && po->pppoe_dev != dev) {\n\t\t\t\tpo = po->next;\n\t\t\t}\n\n\t\t\tif (!po)\n\t\t\t\tbreak;\n\n\t\t\tsk = sk_pppox(po);\n\n\t\t\t \n\n\t\t\tsock_hold(sk);\n\t\t\twrite_unlock_bh(&pn->hash_lock);\n\t\t\tlock_sock(sk);\n\n\t\t\tif (po->pppoe_dev == dev &&\n\t\t\t    sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND)) {\n\t\t\t\tpppox_unbind_sock(sk);\n\t\t\t\tsk->sk_state_change(sk);\n\t\t\t\tpo->pppoe_dev = NULL;\n\t\t\t\tdev_put(dev);\n\t\t\t}\n\n\t\t\trelease_sock(sk);\n\t\t\tsock_put(sk);\n\n\t\t\t \n\n\t\t\tBUG_ON(pppoe_pernet(dev_net(dev)) == NULL);\n\t\t\twrite_lock_bh(&pn->hash_lock);\n\t\t\tpo = pn->hash_table[i];\n\t\t}\n\t}\n\twrite_unlock_bh(&pn->hash_lock);\n}\n\nstatic int pppoe_device_event(struct notifier_block *this,\n\t\t\t      unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\t \n\tswitch (event) {\n\tcase NETDEV_CHANGEADDR:\n\tcase NETDEV_CHANGEMTU:\n\t\t \n\n\tcase NETDEV_GOING_DOWN:\n\tcase NETDEV_DOWN:\n\t\t \n\t\tpppoe_flush_dev(dev);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block pppoe_notifier = {\n\t.notifier_call = pppoe_device_event,\n};\n\n \nstatic int pppoe_rcv_core(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pppox_sock *relay_po;\n\n\t \n\n\tif (skb->pkt_type == PACKET_OTHERHOST)\n\t\tgoto abort_kfree;\n\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\tppp_input(&po->chan, skb);\n\t} else if (sk->sk_state & PPPOX_RELAY) {\n\t\trelay_po = get_item_by_addr(sock_net(sk),\n\t\t\t\t\t    &po->pppoe_relay);\n\t\tif (relay_po == NULL)\n\t\t\tgoto abort_kfree;\n\n\t\tif ((sk_pppox(relay_po)->sk_state & PPPOX_CONNECTED) == 0)\n\t\t\tgoto abort_put;\n\n\t\tif (!__pppoe_xmit(sk_pppox(relay_po), skb))\n\t\t\tgoto abort_put;\n\n\t\tsock_put(sk_pppox(relay_po));\n\t} else {\n\t\tif (sock_queue_rcv_skb(sk, skb))\n\t\t\tgoto abort_kfree;\n\t}\n\n\treturn NET_RX_SUCCESS;\n\nabort_put:\n\tsock_put(sk_pppox(relay_po));\n\nabort_kfree:\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\n \nstatic int pppoe_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct pppoe_hdr *ph;\n\tstruct pppox_sock *po;\n\tstruct pppoe_net *pn;\n\tint len;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto out;\n\n\tif (skb_mac_header_len(skb) < ETH_HLEN)\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, sizeof(struct pppoe_hdr)))\n\t\tgoto drop;\n\n\tph = pppoe_hdr(skb);\n\tlen = ntohs(ph->length);\n\n\tskb_pull_rcsum(skb, sizeof(*ph));\n\tif (skb->len < len)\n\t\tgoto drop;\n\n\tif (pskb_trim_rcsum(skb, len))\n\t\tgoto drop;\n\n\tph = pppoe_hdr(skb);\n\tpn = pppoe_pernet(dev_net(dev));\n\n\t \n\tpo = get_item(pn, ph->sid, eth_hdr(skb)->h_source, dev->ifindex);\n\tif (!po)\n\t\tgoto drop;\n\n\treturn sk_receive_skb(sk_pppox(po), skb, 0);\n\ndrop:\n\tkfree_skb(skb);\nout:\n\treturn NET_RX_DROP;\n}\n\nstatic void pppoe_unbind_sock_work(struct work_struct *work)\n{\n\tstruct pppox_sock *po = container_of(work, struct pppox_sock,\n\t\t\t\t\t     proto.pppoe.padt_work);\n\tstruct sock *sk = sk_pppox(po);\n\n\tlock_sock(sk);\n\tif (po->pppoe_dev) {\n\t\tdev_put(po->pppoe_dev);\n\t\tpo->pppoe_dev = NULL;\n\t}\n\tpppox_unbind_sock(sk);\n\trelease_sock(sk);\n\tsock_put(sk);\n}\n\n \nstatic int pppoe_disc_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t\t  struct packet_type *pt, struct net_device *orig_dev)\n\n{\n\tstruct pppoe_hdr *ph;\n\tstruct pppox_sock *po;\n\tstruct pppoe_net *pn;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto out;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto abort;\n\n\tif (!pskb_may_pull(skb, sizeof(struct pppoe_hdr)))\n\t\tgoto abort;\n\n\tph = pppoe_hdr(skb);\n\tif (ph->code != PADT_CODE)\n\t\tgoto abort;\n\n\tpn = pppoe_pernet(dev_net(dev));\n\tpo = get_item(pn, ph->sid, eth_hdr(skb)->h_source, dev->ifindex);\n\tif (po)\n\t\tif (!schedule_work(&po->proto.pppoe.padt_work))\n\t\t\tsock_put(sk_pppox(po));\n\nabort:\n\tkfree_skb(skb);\nout:\n\treturn NET_RX_SUCCESS;  \n}\n\nstatic struct packet_type pppoes_ptype __read_mostly = {\n\t.type\t= cpu_to_be16(ETH_P_PPP_SES),\n\t.func\t= pppoe_rcv,\n};\n\nstatic struct packet_type pppoed_ptype __read_mostly = {\n\t.type\t= cpu_to_be16(ETH_P_PPP_DISC),\n\t.func\t= pppoe_disc_rcv,\n};\n\nstatic struct proto pppoe_sk_proto __read_mostly = {\n\t.name\t  = \"PPPOE\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct pppox_sock),\n};\n\n \nstatic int pppoe_create(struct net *net, struct socket *sock, int kern)\n{\n\tstruct sock *sk;\n\n\tsk = sk_alloc(net, PF_PPPOX, GFP_KERNEL, &pppoe_sk_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\n\tsock->state\t= SS_UNCONNECTED;\n\tsock->ops\t= &pppoe_ops;\n\n\tsk->sk_backlog_rcv\t= pppoe_rcv_core;\n\tsk->sk_state\t\t= PPPOX_NONE;\n\tsk->sk_type\t\t= SOCK_STREAM;\n\tsk->sk_family\t\t= PF_PPPOX;\n\tsk->sk_protocol\t\t= PX_PROTO_OE;\n\n\tINIT_WORK(&pppox_sk(sk)->proto.pppoe.padt_work,\n\t\t  pppoe_unbind_sock_work);\n\n\treturn 0;\n}\n\nstatic int pppoe_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pppox_sock *po;\n\tstruct pppoe_net *pn;\n\tstruct net *net = NULL;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_DEAD)) {\n\t\trelease_sock(sk);\n\t\treturn -EBADF;\n\t}\n\n\tpo = pppox_sk(sk);\n\n\tif (po->pppoe_dev) {\n\t\tdev_put(po->pppoe_dev);\n\t\tpo->pppoe_dev = NULL;\n\t}\n\n\tpppox_unbind_sock(sk);\n\n\t \n\tsk->sk_state = PPPOX_DEAD;\n\n\tnet = sock_net(sk);\n\tpn = pppoe_pernet(net);\n\n\t \n\tdelete_item(pn, po->pppoe_pa.sid, po->pppoe_pa.remote,\n\t\t    po->pppoe_ifindex);\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int pppoe_connect(struct socket *sock, struct sockaddr *uservaddr,\n\t\t  int sockaddr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *)uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct net_device *dev = NULL;\n\tstruct pppoe_net *pn;\n\tstruct net *net = NULL;\n\tint error;\n\n\tlock_sock(sk);\n\n\terror = -EINVAL;\n\n\tif (sockaddr_len != sizeof(struct sockaddr_pppox))\n\t\tgoto end;\n\n\tif (sp->sa_protocol != PX_PROTO_OE)\n\t\tgoto end;\n\n\t \n\terror = -EBUSY;\n\tif ((sk->sk_state & PPPOX_CONNECTED) &&\n\t     stage_session(sp->sa_addr.pppoe.sid))\n\t\tgoto end;\n\n\t \n\terror = -EALREADY;\n\tif ((sk->sk_state & PPPOX_DEAD) &&\n\t     !stage_session(sp->sa_addr.pppoe.sid))\n\t\tgoto end;\n\n\terror = 0;\n\n\t \n\tif (stage_session(po->pppoe_pa.sid)) {\n\t\tpppox_unbind_sock(sk);\n\t\tpn = pppoe_pernet(sock_net(sk));\n\t\tdelete_item(pn, po->pppoe_pa.sid,\n\t\t\t    po->pppoe_pa.remote, po->pppoe_ifindex);\n\t\tif (po->pppoe_dev) {\n\t\t\tdev_put(po->pppoe_dev);\n\t\t\tpo->pppoe_dev = NULL;\n\t\t}\n\n\t\tpo->pppoe_ifindex = 0;\n\t\tmemset(&po->pppoe_pa, 0, sizeof(po->pppoe_pa));\n\t\tmemset(&po->pppoe_relay, 0, sizeof(po->pppoe_relay));\n\t\tmemset(&po->chan, 0, sizeof(po->chan));\n\t\tpo->next = NULL;\n\t\tpo->num = 0;\n\n\t\tsk->sk_state = PPPOX_NONE;\n\t}\n\n\t \n\tif (stage_session(sp->sa_addr.pppoe.sid)) {\n\t\terror = -ENODEV;\n\t\tnet = sock_net(sk);\n\t\tdev = dev_get_by_name(net, sp->sa_addr.pppoe.dev);\n\t\tif (!dev)\n\t\t\tgoto err_put;\n\n\t\tpo->pppoe_dev = dev;\n\t\tpo->pppoe_ifindex = dev->ifindex;\n\t\tpn = pppoe_pernet(net);\n\t\tif (!(dev->flags & IFF_UP)) {\n\t\t\tgoto err_put;\n\t\t}\n\n\t\tmemcpy(&po->pppoe_pa,\n\t\t       &sp->sa_addr.pppoe,\n\t\t       sizeof(struct pppoe_addr));\n\n\t\twrite_lock_bh(&pn->hash_lock);\n\t\terror = __set_item(pn, po);\n\t\twrite_unlock_bh(&pn->hash_lock);\n\t\tif (error < 0)\n\t\t\tgoto err_put;\n\n\t\tpo->chan.hdrlen = (sizeof(struct pppoe_hdr) +\n\t\t\t\t   dev->hard_header_len);\n\n\t\tpo->chan.mtu = dev->mtu - sizeof(struct pppoe_hdr) - 2;\n\t\tpo->chan.private = sk;\n\t\tpo->chan.ops = &pppoe_chan_ops;\n\n\t\terror = ppp_register_net_channel(dev_net(dev), &po->chan);\n\t\tif (error) {\n\t\t\tdelete_item(pn, po->pppoe_pa.sid,\n\t\t\t\t    po->pppoe_pa.remote, po->pppoe_ifindex);\n\t\t\tgoto err_put;\n\t\t}\n\n\t\tsk->sk_state = PPPOX_CONNECTED;\n\t}\n\n\tpo->num = sp->sa_addr.pppoe.sid;\n\nend:\n\trelease_sock(sk);\n\treturn error;\nerr_put:\n\tif (po->pppoe_dev) {\n\t\tdev_put(po->pppoe_dev);\n\t\tpo->pppoe_dev = NULL;\n\t}\n\tgoto end;\n}\n\nstatic int pppoe_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t  int peer)\n{\n\tint len = sizeof(struct sockaddr_pppox);\n\tstruct sockaddr_pppox sp;\n\n\tsp.sa_family\t= AF_PPPOX;\n\tsp.sa_protocol\t= PX_PROTO_OE;\n\tmemcpy(&sp.sa_addr.pppoe, &pppox_sk(sock->sk)->pppoe_pa,\n\t       sizeof(struct pppoe_addr));\n\n\tmemcpy(uaddr, &sp, len);\n\n\treturn len;\n}\n\nstatic int pppoe_ioctl(struct socket *sock, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tint val;\n\tint err;\n\n\tswitch (cmd) {\n\tcase PPPIOCGMRU:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\terr = -EFAULT;\n\t\tif (put_user(po->pppoe_dev->mtu -\n\t\t\t     sizeof(struct pppoe_hdr) -\n\t\t\t     PPP_HDRLEN,\n\t\t\t     (int __user *)arg))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSMRU:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\terr = -EFAULT;\n\t\tif (get_user(val, (int __user *)arg))\n\t\t\tbreak;\n\n\t\tif (val < (po->pppoe_dev->mtu\n\t\t\t   - sizeof(struct pppoe_hdr)\n\t\t\t   - PPP_HDRLEN))\n\t\t\terr = 0;\n\t\telse\n\t\t\terr = -EINVAL;\n\t\tbreak;\n\n\tcase PPPIOCSFLAGS:\n\t\terr = -EFAULT;\n\t\tif (get_user(val, (int __user *)arg))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPOEIOCSFWD:\n\t{\n\t\tstruct pppox_sock *relay_po;\n\n\t\terr = -EBUSY;\n\t\tif (sk->sk_state & (PPPOX_BOUND | PPPOX_DEAD))\n\t\t\tbreak;\n\n\t\terr = -ENOTCONN;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\t \n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&po->pppoe_relay,\n\t\t\t\t   (void __user *)arg,\n\t\t\t\t   sizeof(struct sockaddr_pppox)))\n\t\t\tbreak;\n\n\t\terr = -EINVAL;\n\t\tif (po->pppoe_relay.sa_family != AF_PPPOX ||\n\t\t    po->pppoe_relay.sa_protocol != PX_PROTO_OE)\n\t\t\tbreak;\n\n\t\t \n\t\trelay_po = get_item_by_addr(sock_net(sk), &po->pppoe_relay);\n\t\tif (!relay_po)\n\t\t\tbreak;\n\n\t\tsock_put(sk_pppox(relay_po));\n\t\tsk->sk_state |= PPPOX_RELAY;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tcase PPPOEIOCDFWD:\n\t\terr = -EALREADY;\n\t\tif (!(sk->sk_state & PPPOX_RELAY))\n\t\t\tbreak;\n\n\t\tsk->sk_state &= ~PPPOX_RELAY;\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\n\treturn err;\n}\n\nstatic int pppoe_sendmsg(struct socket *sock, struct msghdr *m,\n\t\t\t size_t total_len)\n{\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tint error;\n\tstruct pppoe_hdr hdr;\n\tstruct pppoe_hdr *ph;\n\tstruct net_device *dev;\n\tchar *start;\n\tint hlen;\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_DEAD) || !(sk->sk_state & PPPOX_CONNECTED)) {\n\t\terror = -ENOTCONN;\n\t\tgoto end;\n\t}\n\n\thdr.ver = 1;\n\thdr.type = 1;\n\thdr.code = 0;\n\thdr.sid = po->num;\n\n\tdev = po->pppoe_dev;\n\n\terror = -EMSGSIZE;\n\tif (total_len > (dev->mtu + dev->hard_header_len))\n\t\tgoto end;\n\n\thlen = LL_RESERVED_SPACE(dev);\n\tskb = sock_wmalloc(sk, hlen + sizeof(*ph) + total_len +\n\t\t\t   dev->needed_tailroom, 0, GFP_KERNEL);\n\tif (!skb) {\n\t\terror = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\t \n\tskb_reserve(skb, hlen);\n\tskb_reset_network_header(skb);\n\n\tskb->dev = dev;\n\n\tskb->priority = sk->sk_priority;\n\tskb->protocol = cpu_to_be16(ETH_P_PPP_SES);\n\n\tph = skb_put(skb, total_len + sizeof(struct pppoe_hdr));\n\tstart = (char *)&ph->tag[0];\n\n\terror = memcpy_from_msg(start, m, total_len);\n\tif (error < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto end;\n\t}\n\n\terror = total_len;\n\tdev_hard_header(skb, dev, ETH_P_PPP_SES,\n\t\t\tpo->pppoe_pa.remote, NULL, total_len);\n\n\tmemcpy(ph, &hdr, sizeof(struct pppoe_hdr));\n\n\tph->length = htons(total_len);\n\n\tdev_queue_xmit(skb);\n\nend:\n\trelease_sock(sk);\n\treturn error;\n}\n\n \nstatic int __pppoe_xmit(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct net_device *dev = po->pppoe_dev;\n\tstruct pppoe_hdr *ph;\n\tint data_len = skb->len;\n\n\t \n\n\tif (sock_flag(sk, SOCK_DEAD) || !(sk->sk_state & PPPOX_CONNECTED))\n\t\tgoto abort;\n\n\tif (!dev)\n\t\tgoto abort;\n\n\t \n\tif (skb_cow_head(skb, LL_RESERVED_SPACE(dev) + sizeof(*ph)))\n\t\tgoto abort;\n\n\t__skb_push(skb, sizeof(*ph));\n\tskb_reset_network_header(skb);\n\n\tph = pppoe_hdr(skb);\n\tph->ver\t= 1;\n\tph->type = 1;\n\tph->code = 0;\n\tph->sid\t= po->num;\n\tph->length = htons(data_len);\n\n\tskb->protocol = cpu_to_be16(ETH_P_PPP_SES);\n\tskb->dev = dev;\n\n\tdev_hard_header(skb, dev, ETH_P_PPP_SES,\n\t\t\tpo->pppoe_pa.remote, NULL, data_len);\n\n\tdev_queue_xmit(skb);\n\treturn 1;\n\nabort:\n\tkfree_skb(skb);\n\treturn 1;\n}\n\n \nstatic int pppoe_xmit(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstruct sock *sk = chan->private;\n\treturn __pppoe_xmit(sk, skb);\n}\n\nstatic int pppoe_fill_forward_path(struct net_device_path_ctx *ctx,\n\t\t\t\t   struct net_device_path *path,\n\t\t\t\t   const struct ppp_channel *chan)\n{\n\tstruct sock *sk = chan->private;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct net_device *dev = po->pppoe_dev;\n\n\tif (sock_flag(sk, SOCK_DEAD) ||\n\t    !(sk->sk_state & PPPOX_CONNECTED) || !dev)\n\t\treturn -1;\n\n\tpath->type = DEV_PATH_PPPOE;\n\tpath->encap.proto = htons(ETH_P_PPP_SES);\n\tpath->encap.id = be16_to_cpu(po->num);\n\tmemcpy(path->encap.h_dest, po->pppoe_pa.remote, ETH_ALEN);\n\tmemcpy(ctx->daddr, po->pppoe_pa.remote, ETH_ALEN);\n\tpath->dev = ctx->dev;\n\tctx->dev = dev;\n\n\treturn 0;\n}\n\nstatic const struct ppp_channel_ops pppoe_chan_ops = {\n\t.start_xmit = pppoe_xmit,\n\t.fill_forward_path = pppoe_fill_forward_path,\n};\n\nstatic int pppoe_recvmsg(struct socket *sock, struct msghdr *m,\n\t\t\t size_t total_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error = 0;\n\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\terror = -EIO;\n\t\tgoto end;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, &error);\n\tif (error < 0)\n\t\tgoto end;\n\n\tif (skb) {\n\t\ttotal_len = min_t(size_t, total_len, skb->len);\n\t\terror = skb_copy_datagram_msg(skb, 0, m, total_len);\n\t\tif (error == 0) {\n\t\t\tconsume_skb(skb);\n\t\t\treturn total_len;\n\t\t}\n\t}\n\n\tkfree_skb(skb);\nend:\n\treturn error;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic int pppoe_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct pppox_sock *po;\n\tchar *dev_name;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"Id       Address              Device\\n\");\n\t\tgoto out;\n\t}\n\n\tpo = v;\n\tdev_name = po->pppoe_pa.dev;\n\n\tseq_printf(seq, \"%08X %pM %8s\\n\",\n\t\tpo->pppoe_pa.sid, po->pppoe_pa.remote, dev_name);\nout:\n\treturn 0;\n}\n\nstatic inline struct pppox_sock *pppoe_get_idx(struct pppoe_net *pn, loff_t pos)\n{\n\tstruct pppox_sock *po;\n\tint i;\n\n\tfor (i = 0; i < PPPOE_HASH_SIZE; i++) {\n\t\tpo = pn->hash_table[i];\n\t\twhile (po) {\n\t\t\tif (!pos--)\n\t\t\t\tgoto out;\n\t\t\tpo = po->next;\n\t\t}\n\t}\n\nout:\n\treturn po;\n}\n\nstatic void *pppoe_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(pn->hash_lock)\n{\n\tstruct pppoe_net *pn = pppoe_pernet(seq_file_net(seq));\n\tloff_t l = *pos;\n\n\tread_lock_bh(&pn->hash_lock);\n\treturn l ? pppoe_get_idx(pn, --l) : SEQ_START_TOKEN;\n}\n\nstatic void *pppoe_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct pppoe_net *pn = pppoe_pernet(seq_file_net(seq));\n\tstruct pppox_sock *po;\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN) {\n\t\tpo = pppoe_get_idx(pn, 0);\n\t\tgoto out;\n\t}\n\tpo = v;\n\tif (po->next)\n\t\tpo = po->next;\n\telse {\n\t\tint hash = hash_item(po->pppoe_pa.sid, po->pppoe_pa.remote);\n\n\t\tpo = NULL;\n\t\twhile (++hash < PPPOE_HASH_SIZE) {\n\t\t\tpo = pn->hash_table[hash];\n\t\t\tif (po)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\treturn po;\n}\n\nstatic void pppoe_seq_stop(struct seq_file *seq, void *v)\n\t__releases(pn->hash_lock)\n{\n\tstruct pppoe_net *pn = pppoe_pernet(seq_file_net(seq));\n\tread_unlock_bh(&pn->hash_lock);\n}\n\nstatic const struct seq_operations pppoe_seq_ops = {\n\t.start\t\t= pppoe_seq_start,\n\t.next\t\t= pppoe_seq_next,\n\t.stop\t\t= pppoe_seq_stop,\n\t.show\t\t= pppoe_seq_show,\n};\n#endif  \n\nstatic const struct proto_ops pppoe_ops = {\n\t.family\t\t= AF_PPPOX,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= pppoe_release,\n\t.bind\t\t= sock_no_bind,\n\t.connect\t= pppoe_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.getname\t= pppoe_getname,\n\t.poll\t\t= datagram_poll,\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.sendmsg\t= pppoe_sendmsg,\n\t.recvmsg\t= pppoe_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n\t.ioctl\t\t= pppox_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= pppox_compat_ioctl,\n#endif\n};\n\nstatic const struct pppox_proto pppoe_proto = {\n\t.create\t= pppoe_create,\n\t.ioctl\t= pppoe_ioctl,\n\t.owner\t= THIS_MODULE,\n};\n\nstatic __net_init int pppoe_init_net(struct net *net)\n{\n\tstruct pppoe_net *pn = pppoe_pernet(net);\n\tstruct proc_dir_entry *pde;\n\n\trwlock_init(&pn->hash_lock);\n\n\tpde = proc_create_net(\"pppoe\", 0444, net->proc_net,\n\t\t\t&pppoe_seq_ops, sizeof(struct seq_net_private));\n#ifdef CONFIG_PROC_FS\n\tif (!pde)\n\t\treturn -ENOMEM;\n#endif\n\n\treturn 0;\n}\n\nstatic __net_exit void pppoe_exit_net(struct net *net)\n{\n\tremove_proc_entry(\"pppoe\", net->proc_net);\n}\n\nstatic struct pernet_operations pppoe_net_ops = {\n\t.init = pppoe_init_net,\n\t.exit = pppoe_exit_net,\n\t.id   = &pppoe_net_id,\n\t.size = sizeof(struct pppoe_net),\n};\n\nstatic int __init pppoe_init(void)\n{\n\tint err;\n\n\terr = register_pernet_device(&pppoe_net_ops);\n\tif (err)\n\t\tgoto out;\n\n\terr = proto_register(&pppoe_sk_proto, 0);\n\tif (err)\n\t\tgoto out_unregister_net_ops;\n\n\terr = register_pppox_proto(PX_PROTO_OE, &pppoe_proto);\n\tif (err)\n\t\tgoto out_unregister_pppoe_proto;\n\n\tdev_add_pack(&pppoes_ptype);\n\tdev_add_pack(&pppoed_ptype);\n\tregister_netdevice_notifier(&pppoe_notifier);\n\n\treturn 0;\n\nout_unregister_pppoe_proto:\n\tproto_unregister(&pppoe_sk_proto);\nout_unregister_net_ops:\n\tunregister_pernet_device(&pppoe_net_ops);\nout:\n\treturn err;\n}\n\nstatic void __exit pppoe_exit(void)\n{\n\tunregister_netdevice_notifier(&pppoe_notifier);\n\tdev_remove_pack(&pppoed_ptype);\n\tdev_remove_pack(&pppoes_ptype);\n\tunregister_pppox_proto(PX_PROTO_OE);\n\tproto_unregister(&pppoe_sk_proto);\n\tunregister_pernet_device(&pppoe_net_ops);\n}\n\nmodule_init(pppoe_init);\nmodule_exit(pppoe_exit);\n\nMODULE_AUTHOR(\"Michal Ostrowski <mostrows@speakeasy.net>\");\nMODULE_DESCRIPTION(\"PPP over Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO(PF_PPPOX, PX_PROTO_OE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}