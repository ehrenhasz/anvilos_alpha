{
  "module_name": "ppp_deflate.c",
  "hash_id": "8e8d13d5da863f004f11a60dba15d3fad4467dae436f5f29e081770e14f2512e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ppp/ppp_deflate.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/string.h>\n\n#include <linux/ppp_defs.h>\n#include <linux/ppp-comp.h>\n\n#include <linux/zlib.h>\n#include <asm/unaligned.h>\n\n \nstruct ppp_deflate_state {\n    int\t\tseqno;\n    int\t\tw_size;\n    int\t\tunit;\n    int\t\tmru;\n    int\t\tdebug;\n    z_stream\tstrm;\n    struct compstat stats;\n};\n\n#define DEFLATE_OVHD\t2\t\t \n\nstatic void\t*z_comp_alloc(unsigned char *options, int opt_len);\nstatic void\t*z_decomp_alloc(unsigned char *options, int opt_len);\nstatic void\tz_comp_free(void *state);\nstatic void\tz_decomp_free(void *state);\nstatic int\tz_comp_init(void *state, unsigned char *options,\n\t\t\t\t int opt_len,\n\t\t\t\t int unit, int hdrlen, int debug);\nstatic int\tz_decomp_init(void *state, unsigned char *options,\n\t\t\t\t   int opt_len,\n\t\t\t\t   int unit, int hdrlen, int mru, int debug);\nstatic int\tz_compress(void *state, unsigned char *rptr,\n\t\t\t\tunsigned char *obuf,\n\t\t\t\tint isize, int osize);\nstatic void\tz_incomp(void *state, unsigned char *ibuf, int icnt);\nstatic int\tz_decompress(void *state, unsigned char *ibuf,\n\t\t\t\tint isize, unsigned char *obuf, int osize);\nstatic void\tz_comp_reset(void *state);\nstatic void\tz_decomp_reset(void *state);\nstatic void\tz_comp_stats(void *state, struct compstat *stats);\n\n \nstatic void z_comp_free(void *arg)\n{\n\tstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\n\n\tif (state) {\n\t\tzlib_deflateEnd(&state->strm);\n\t\tvfree(state->strm.workspace);\n\t\tkfree(state);\n\t}\n}\n\n \nstatic void *z_comp_alloc(unsigned char *options, int opt_len)\n{\n\tstruct ppp_deflate_state *state;\n\tint w_size;\n\n\tif (opt_len != CILEN_DEFLATE ||\n\t    (options[0] != CI_DEFLATE && options[0] != CI_DEFLATE_DRAFT) ||\n\t    options[1] != CILEN_DEFLATE ||\n\t    DEFLATE_METHOD(options[2]) != DEFLATE_METHOD_VAL ||\n\t    options[3] != DEFLATE_CHK_SEQUENCE)\n\t\treturn NULL;\n\tw_size = DEFLATE_SIZE(options[2]);\n\tif (w_size < DEFLATE_MIN_SIZE || w_size > DEFLATE_MAX_SIZE)\n\t\treturn NULL;\n\n\tstate = kzalloc(sizeof(*state),\n\t\t\t\t\t\t     GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tstate->strm.next_in   = NULL;\n\tstate->w_size         = w_size;\n\tstate->strm.workspace = vmalloc(zlib_deflate_workspacesize(-w_size, 8));\n\tif (state->strm.workspace == NULL)\n\t\tgoto out_free;\n\n\tif (zlib_deflateInit2(&state->strm, Z_DEFAULT_COMPRESSION,\n\t\t\t DEFLATE_METHOD_VAL, -w_size, 8, Z_DEFAULT_STRATEGY)\n\t    != Z_OK)\n\t\tgoto out_free;\n\treturn (void *) state;\n\nout_free:\n\tz_comp_free(state);\n\treturn NULL;\n}\n\n \nstatic int z_comp_init(void *arg, unsigned char *options, int opt_len,\n\t\t       int unit, int hdrlen, int debug)\n{\n\tstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\n\n\tif (opt_len < CILEN_DEFLATE ||\n\t    (options[0] != CI_DEFLATE && options[0] != CI_DEFLATE_DRAFT) ||\n\t    options[1] != CILEN_DEFLATE ||\n\t    DEFLATE_METHOD(options[2]) != DEFLATE_METHOD_VAL ||\n\t    DEFLATE_SIZE(options[2]) != state->w_size ||\n\t    options[3] != DEFLATE_CHK_SEQUENCE)\n\t\treturn 0;\n\n\tstate->seqno = 0;\n\tstate->unit  = unit;\n\tstate->debug = debug;\n\n\tzlib_deflateReset(&state->strm);\n\n\treturn 1;\n}\n\n \nstatic void z_comp_reset(void *arg)\n{\n\tstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\n\n\tstate->seqno = 0;\n\tzlib_deflateReset(&state->strm);\n}\n\n \nstatic int z_compress(void *arg, unsigned char *rptr, unsigned char *obuf,\n\t       int isize, int osize)\n{\n\tstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\n\tint r, proto, off, olen, oavail;\n\tunsigned char *wptr;\n\n\t \n\tproto = PPP_PROTOCOL(rptr);\n\tif (proto > 0x3fff || proto == 0xfd || proto == 0xfb)\n\t\treturn 0;\n\n\t \n\tif (osize > isize)\n\t\tosize = isize;\n\n\twptr = obuf;\n\n\t \n\twptr[0] = PPP_ADDRESS(rptr);\n\twptr[1] = PPP_CONTROL(rptr);\n\tput_unaligned_be16(PPP_COMP, wptr + 2);\n\twptr += PPP_HDRLEN;\n\tput_unaligned_be16(state->seqno, wptr);\n\twptr += DEFLATE_OVHD;\n\tolen = PPP_HDRLEN + DEFLATE_OVHD;\n\tstate->strm.next_out = wptr;\n\tstate->strm.avail_out = oavail = osize - olen;\n\t++state->seqno;\n\n\toff = (proto > 0xff) ? 2 : 3;\t \n\trptr += off;\n\tstate->strm.next_in = rptr;\n\tstate->strm.avail_in = (isize - off);\n\n\tfor (;;) {\n\t\tr = zlib_deflate(&state->strm, Z_PACKET_FLUSH);\n\t\tif (r != Z_OK) {\n\t\t\tif (state->debug)\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"z_compress: deflate returned %d\\n\", r);\n\t\t\tbreak;\n\t\t}\n\t\tif (state->strm.avail_out == 0) {\n\t\t\tolen += oavail;\n\t\t\tstate->strm.next_out = NULL;\n\t\t\tstate->strm.avail_out = oavail = 1000000;\n\t\t} else {\n\t\t\tbreak;\t\t \n\t\t}\n\t}\n\tolen += oavail - state->strm.avail_out;\n\n\t \n\tif (olen < isize && olen <= osize) {\n\t\tstate->stats.comp_bytes += olen;\n\t\tstate->stats.comp_packets++;\n\t} else {\n\t\tstate->stats.inc_bytes += isize;\n\t\tstate->stats.inc_packets++;\n\t\tolen = 0;\n\t}\n\tstate->stats.unc_bytes += isize;\n\tstate->stats.unc_packets++;\n\n\treturn olen;\n}\n\n \nstatic void z_comp_stats(void *arg, struct compstat *stats)\n{\n\tstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\n\n\t*stats = state->stats;\n}\n\n \nstatic void z_decomp_free(void *arg)\n{\n\tstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\n\n\tif (state) {\n\t\tvfree(state->strm.workspace);\n\t\tkfree(state);\n\t}\n}\n\n \nstatic void *z_decomp_alloc(unsigned char *options, int opt_len)\n{\n\tstruct ppp_deflate_state *state;\n\tint w_size;\n\n\tif (opt_len != CILEN_DEFLATE ||\n\t    (options[0] != CI_DEFLATE && options[0] != CI_DEFLATE_DRAFT) ||\n\t    options[1] != CILEN_DEFLATE ||\n\t    DEFLATE_METHOD(options[2]) != DEFLATE_METHOD_VAL ||\n\t    options[3] != DEFLATE_CHK_SEQUENCE)\n\t\treturn NULL;\n\tw_size = DEFLATE_SIZE(options[2]);\n\tif (w_size < DEFLATE_MIN_SIZE || w_size > DEFLATE_MAX_SIZE)\n\t\treturn NULL;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn NULL;\n\n\tstate->w_size         = w_size;\n\tstate->strm.next_out  = NULL;\n\tstate->strm.workspace = vmalloc(zlib_inflate_workspacesize());\n\tif (state->strm.workspace == NULL)\n\t\tgoto out_free;\n\n\tif (zlib_inflateInit2(&state->strm, -w_size) != Z_OK)\n\t\tgoto out_free;\n\treturn (void *) state;\n\nout_free:\n\tz_decomp_free(state);\n\treturn NULL;\n}\n\n \nstatic int z_decomp_init(void *arg, unsigned char *options, int opt_len,\n\t\t\t int unit, int hdrlen, int mru, int debug)\n{\n\tstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\n\n\tif (opt_len < CILEN_DEFLATE ||\n\t    (options[0] != CI_DEFLATE && options[0] != CI_DEFLATE_DRAFT) ||\n\t    options[1] != CILEN_DEFLATE ||\n\t    DEFLATE_METHOD(options[2]) != DEFLATE_METHOD_VAL ||\n\t    DEFLATE_SIZE(options[2]) != state->w_size ||\n\t    options[3] != DEFLATE_CHK_SEQUENCE)\n\t\treturn 0;\n\n\tstate->seqno = 0;\n\tstate->unit  = unit;\n\tstate->debug = debug;\n\tstate->mru   = mru;\n\n\tzlib_inflateReset(&state->strm);\n\n\treturn 1;\n}\n\n \nstatic void z_decomp_reset(void *arg)\n{\n\tstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\n\n\tstate->seqno = 0;\n\tzlib_inflateReset(&state->strm);\n}\n\n \nstatic int z_decompress(void *arg, unsigned char *ibuf, int isize,\n\t\t unsigned char *obuf, int osize)\n{\n\tstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\n\tint olen, seq, r;\n\tint decode_proto, overflow;\n\tunsigned char overflow_buf[1];\n\n\tif (isize <= PPP_HDRLEN + DEFLATE_OVHD) {\n\t\tif (state->debug)\n\t\t\tprintk(KERN_DEBUG \"z_decompress%d: short pkt (%d)\\n\",\n\t\t\t       state->unit, isize);\n\t\treturn DECOMP_ERROR;\n\t}\n\n\t \n\tseq = get_unaligned_be16(ibuf + PPP_HDRLEN);\n\tif (seq != (state->seqno & 0xffff)) {\n\t\tif (state->debug)\n\t\t\tprintk(KERN_DEBUG \"z_decompress%d: bad seq # %d, expected %d\\n\",\n\t\t\t       state->unit, seq, state->seqno & 0xffff);\n\t\treturn DECOMP_ERROR;\n\t}\n\t++state->seqno;\n\n\t \n\tobuf[0] = PPP_ADDRESS(ibuf);\n\tobuf[1] = PPP_CONTROL(ibuf);\n\tobuf[2] = 0;\n\n\t \n\tstate->strm.next_in = ibuf + PPP_HDRLEN + DEFLATE_OVHD;\n\tstate->strm.avail_in = isize - (PPP_HDRLEN + DEFLATE_OVHD);\n\tstate->strm.next_out = obuf + 3;\n\tstate->strm.avail_out = 1;\n\tdecode_proto = 1;\n\toverflow = 0;\n\n\t \n\tfor (;;) {\n\t\tr = zlib_inflate(&state->strm, Z_PACKET_FLUSH);\n\t\tif (r != Z_OK) {\n\t\t\tif (state->debug)\n\t\t\t\tprintk(KERN_DEBUG \"z_decompress%d: inflate returned %d (%s)\\n\",\n\t\t\t\t       state->unit, r, (state->strm.msg? state->strm.msg: \"\"));\n\t\t\treturn DECOMP_FATALERROR;\n\t\t}\n\t\tif (state->strm.avail_out != 0)\n\t\t\tbreak;\t\t \n\t\tif (decode_proto) {\n\t\t\tstate->strm.avail_out = osize - PPP_HDRLEN;\n\t\t\tif ((obuf[3] & 1) == 0) {\n\t\t\t\t \n\t\t\t\tobuf[2] = obuf[3];\n\t\t\t\t--state->strm.next_out;\n\t\t\t\t++state->strm.avail_out;\n\t\t\t}\n\t\t\tdecode_proto = 0;\n\t\t} else if (!overflow) {\n\t\t\t \n\t\t\tstate->strm.next_out = overflow_buf;\n\t\t\tstate->strm.avail_out = 1;\n\t\t\toverflow = 1;\n\t\t} else {\n\t\t\tif (state->debug)\n\t\t\t\tprintk(KERN_DEBUG \"z_decompress%d: ran out of mru\\n\",\n\t\t\t\t       state->unit);\n\t\t\treturn DECOMP_FATALERROR;\n\t\t}\n\t}\n\n\tif (decode_proto) {\n\t\tif (state->debug)\n\t\t\tprintk(KERN_DEBUG \"z_decompress%d: didn't get proto\\n\",\n\t\t\t       state->unit);\n\t\treturn DECOMP_ERROR;\n\t}\n\n\tolen = osize + overflow - state->strm.avail_out;\n\tstate->stats.unc_bytes += olen;\n\tstate->stats.unc_packets++;\n\tstate->stats.comp_bytes += isize;\n\tstate->stats.comp_packets++;\n\n\treturn olen;\n}\n\n \nstatic void z_incomp(void *arg, unsigned char *ibuf, int icnt)\n{\n\tstruct ppp_deflate_state *state = (struct ppp_deflate_state *) arg;\n\tint proto, r;\n\n\t \n\tproto = PPP_PROTOCOL(ibuf);\n\tif (proto > 0x3fff || proto == 0xfd || proto == 0xfb)\n\t\treturn;\n\n\t++state->seqno;\n\n\t \n\tstate->strm.next_in = ibuf + 3;\n\tstate->strm.avail_in = icnt - 3;\n\tif (proto > 0xff) {\n\t\t--state->strm.next_in;\n\t\t++state->strm.avail_in;\n\t}\n\n\tr = zlib_inflateIncomp(&state->strm);\n\tif (r != Z_OK) {\n\t\t \n\t\tif (state->debug) {\n\t\t\tprintk(KERN_DEBUG \"z_incomp%d: inflateIncomp returned %d (%s)\\n\",\n\t\t\t       state->unit, r, (state->strm.msg? state->strm.msg: \"\"));\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tstate->stats.inc_bytes += icnt;\n\tstate->stats.inc_packets++;\n\tstate->stats.unc_bytes += icnt;\n\tstate->stats.unc_packets++;\n}\n\n \n\n \nextern int  ppp_register_compressor   (struct compressor *cp);\nextern void ppp_unregister_compressor (struct compressor *cp);\n\n \nstatic struct compressor ppp_deflate = {\n\t.compress_proto =\tCI_DEFLATE,\n\t.comp_alloc =\t\tz_comp_alloc,\n\t.comp_free =\t\tz_comp_free,\n\t.comp_init =\t\tz_comp_init,\n\t.comp_reset =\t\tz_comp_reset,\n\t.compress =\t\tz_compress,\n\t.comp_stat =\t\tz_comp_stats,\n\t.decomp_alloc =\t\tz_decomp_alloc,\n\t.decomp_free =\t\tz_decomp_free,\n\t.decomp_init =\t\tz_decomp_init,\n\t.decomp_reset =\t\tz_decomp_reset,\n\t.decompress =\t\tz_decompress,\n\t.incomp =\t\tz_incomp,\n\t.decomp_stat =\t\tz_comp_stats,\n\t.owner =\t\tTHIS_MODULE\n};\n\nstatic struct compressor ppp_deflate_draft = {\n\t.compress_proto =\tCI_DEFLATE_DRAFT,\n\t.comp_alloc =\t\tz_comp_alloc,\n\t.comp_free =\t\tz_comp_free,\n\t.comp_init =\t\tz_comp_init,\n\t.comp_reset =\t\tz_comp_reset,\n\t.compress =\t\tz_compress,\n\t.comp_stat =\t\tz_comp_stats,\n\t.decomp_alloc =\t\tz_decomp_alloc,\n\t.decomp_free =\t\tz_decomp_free,\n\t.decomp_init =\t\tz_decomp_init,\n\t.decomp_reset =\t\tz_decomp_reset,\n\t.decompress =\t\tz_decompress,\n\t.incomp =\t\tz_incomp,\n\t.decomp_stat =\t\tz_comp_stats,\n\t.owner =\t\tTHIS_MODULE\n};\n\nstatic int __init deflate_init(void)\n{\n\tint rc;\n\n\trc = ppp_register_compressor(&ppp_deflate);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ppp_register_compressor(&ppp_deflate_draft);\n\tif (rc) {\n\t\tppp_unregister_compressor(&ppp_deflate);\n\t\treturn rc;\n\t}\n\n\tpr_info(\"PPP Deflate Compression module registered\\n\");\n\treturn 0;\n}\n\nstatic void __exit deflate_cleanup(void)\n{\n\tppp_unregister_compressor(&ppp_deflate);\n\tppp_unregister_compressor(&ppp_deflate_draft);\n}\n\nmodule_init(deflate_init);\nmodule_exit(deflate_cleanup);\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"ppp-compress-\" __stringify(CI_DEFLATE));\nMODULE_ALIAS(\"ppp-compress-\" __stringify(CI_DEFLATE_DRAFT));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}