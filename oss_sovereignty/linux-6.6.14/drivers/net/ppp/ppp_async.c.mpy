{
  "module_name": "ppp_async.c",
  "hash_id": "40fa7763a5ff5ec3fc0bcf8c239bb8981e850c7f50f75b73ee78c851d21b1eec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ppp/ppp_async.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/tty.h>\n#include <linux/netdevice.h>\n#include <linux/poll.h>\n#include <linux/crc-ccitt.h>\n#include <linux/ppp_defs.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/ppp_channel.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <asm/string.h>\n\n#define PPP_VERSION\t\"2.4.2\"\n\n#define OBUFSIZE\t4096\n\n \nstruct asyncppp {\n\tstruct tty_struct *tty;\n\tunsigned int\tflags;\n\tunsigned int\tstate;\n\tunsigned int\trbits;\n\tint\t\tmru;\n\tspinlock_t\txmit_lock;\n\tspinlock_t\trecv_lock;\n\tunsigned long\txmit_flags;\n\tu32\t\txaccm[8];\n\tu32\t\traccm;\n\tunsigned int\tbytes_sent;\n\tunsigned int\tbytes_rcvd;\n\n\tstruct sk_buff\t*tpkt;\n\tint\t\ttpkt_pos;\n\tu16\t\ttfcs;\n\tunsigned char\t*optr;\n\tunsigned char\t*olim;\n\tunsigned long\tlast_xmit;\n\n\tstruct sk_buff\t*rpkt;\n\tint\t\tlcp_fcs;\n\tstruct sk_buff_head rqueue;\n\n\tstruct tasklet_struct tsk;\n\n\trefcount_t\trefcnt;\n\tstruct completion dead;\n\tstruct ppp_channel chan;\t \n\tunsigned char\tobuf[OBUFSIZE];\n};\n\n \n#define XMIT_WAKEUP\t0\n#define XMIT_FULL\t1\n#define XMIT_BUSY\t2\n\n \n#define SC_TOSS\t\t1\n#define SC_ESCAPE\t2\n#define SC_PREV_ERROR\t4\n\n \n#define SC_RCV_BITS\t(SC_RCV_B7_1|SC_RCV_B7_0|SC_RCV_ODDP|SC_RCV_EVNP)\n\nstatic int flag_time = HZ;\nmodule_param(flag_time, int, 0);\nMODULE_PARM_DESC(flag_time, \"ppp_async: interval between flagged packets (in clock ticks)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_PPP);\n\n \nstatic int ppp_async_encode(struct asyncppp *ap);\nstatic int ppp_async_send(struct ppp_channel *chan, struct sk_buff *skb);\nstatic int ppp_async_push(struct asyncppp *ap);\nstatic void ppp_async_flush_output(struct asyncppp *ap);\nstatic void ppp_async_input(struct asyncppp *ap, const unsigned char *buf,\n\t\t\t    const u8 *flags, int count);\nstatic int ppp_async_ioctl(struct ppp_channel *chan, unsigned int cmd,\n\t\t\t   unsigned long arg);\nstatic void ppp_async_process(struct tasklet_struct *t);\n\nstatic void async_lcp_peek(struct asyncppp *ap, unsigned char *data,\n\t\t\t   int len, int inbound);\n\nstatic const struct ppp_channel_ops async_ops = {\n\t.start_xmit = ppp_async_send,\n\t.ioctl      = ppp_async_ioctl,\n};\n\n \n\n \nstatic DEFINE_RWLOCK(disc_data_lock);\n\nstatic struct asyncppp *ap_get(struct tty_struct *tty)\n{\n\tstruct asyncppp *ap;\n\n\tread_lock(&disc_data_lock);\n\tap = tty->disc_data;\n\tif (ap != NULL)\n\t\trefcount_inc(&ap->refcnt);\n\tread_unlock(&disc_data_lock);\n\treturn ap;\n}\n\nstatic void ap_put(struct asyncppp *ap)\n{\n\tif (refcount_dec_and_test(&ap->refcnt))\n\t\tcomplete(&ap->dead);\n}\n\n \nstatic int\nppp_asynctty_open(struct tty_struct *tty)\n{\n\tstruct asyncppp *ap;\n\tint err;\n\tint speed;\n\n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\terr = -ENOMEM;\n\tap = kzalloc(sizeof(*ap), GFP_KERNEL);\n\tif (!ap)\n\t\tgoto out;\n\n\t \n\tap->tty = tty;\n\tap->mru = PPP_MRU;\n\tspin_lock_init(&ap->xmit_lock);\n\tspin_lock_init(&ap->recv_lock);\n\tap->xaccm[0] = ~0U;\n\tap->xaccm[3] = 0x60000000U;\n\tap->raccm = ~0U;\n\tap->optr = ap->obuf;\n\tap->olim = ap->obuf;\n\tap->lcp_fcs = -1;\n\n\tskb_queue_head_init(&ap->rqueue);\n\ttasklet_setup(&ap->tsk, ppp_async_process);\n\n\trefcount_set(&ap->refcnt, 1);\n\tinit_completion(&ap->dead);\n\n\tap->chan.private = ap;\n\tap->chan.ops = &async_ops;\n\tap->chan.mtu = PPP_MRU;\n\tspeed = tty_get_baud_rate(tty);\n\tap->chan.speed = speed;\n\terr = ppp_register_channel(&ap->chan);\n\tif (err)\n\t\tgoto out_free;\n\n\ttty->disc_data = ap;\n\ttty->receive_room = 65536;\n\treturn 0;\n\n out_free:\n\tkfree(ap);\n out:\n\treturn err;\n}\n\n \nstatic void\nppp_asynctty_close(struct tty_struct *tty)\n{\n\tstruct asyncppp *ap;\n\n\twrite_lock_irq(&disc_data_lock);\n\tap = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!ap)\n\t\treturn;\n\n\t \n\tif (!refcount_dec_and_test(&ap->refcnt))\n\t\twait_for_completion(&ap->dead);\n\ttasklet_kill(&ap->tsk);\n\n\tppp_unregister_channel(&ap->chan);\n\tkfree_skb(ap->rpkt);\n\tskb_queue_purge(&ap->rqueue);\n\tkfree_skb(ap->tpkt);\n\tkfree(ap);\n}\n\n \nstatic void ppp_asynctty_hangup(struct tty_struct *tty)\n{\n\tppp_asynctty_close(tty);\n}\n\n \nstatic ssize_t\nppp_asynctty_read(struct tty_struct *tty, struct file *file, u8 *buf,\n\t\t  size_t count, void **cookie, unsigned long offset)\n{\n\treturn -EAGAIN;\n}\n\n \nstatic ssize_t\nppp_asynctty_write(struct tty_struct *tty, struct file *file, const u8 *buf,\n\t\t   size_t count)\n{\n\treturn -EAGAIN;\n}\n\n \n\nstatic int\nppp_asynctty_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)\n{\n\tstruct asyncppp *ap = ap_get(tty);\n\tint err, val;\n\tint __user *p = (int __user *)arg;\n\n\tif (!ap)\n\t\treturn -ENXIO;\n\terr = -EFAULT;\n\tswitch (cmd) {\n\tcase PPPIOCGCHAN:\n\t\terr = -EFAULT;\n\t\tif (put_user(ppp_channel_index(&ap->chan), p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGUNIT:\n\t\terr = -EFAULT;\n\t\tif (put_user(ppp_unit_number(&ap->chan), p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase TCFLSH:\n\t\t \n\t\tif (arg == TCIOFLUSH || arg == TCOFLUSH)\n\t\t\tppp_async_flush_output(ap);\n\t\terr = n_tty_ioctl_helper(tty, cmd, arg);\n\t\tbreak;\n\n\tcase FIONREAD:\n\t\tval = 0;\n\t\tif (put_user(val, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\terr = tty_mode_ioctl(tty, cmd, arg);\n\t}\n\n\tap_put(ap);\n\treturn err;\n}\n\n \nstatic void\nppp_asynctty_receive(struct tty_struct *tty, const u8 *buf, const u8 *cflags,\n\t\t     size_t count)\n{\n\tstruct asyncppp *ap = ap_get(tty);\n\tunsigned long flags;\n\n\tif (!ap)\n\t\treturn;\n\tspin_lock_irqsave(&ap->recv_lock, flags);\n\tppp_async_input(ap, buf, cflags, count);\n\tspin_unlock_irqrestore(&ap->recv_lock, flags);\n\tif (!skb_queue_empty(&ap->rqueue))\n\t\ttasklet_schedule(&ap->tsk);\n\tap_put(ap);\n\ttty_unthrottle(tty);\n}\n\nstatic void\nppp_asynctty_wakeup(struct tty_struct *tty)\n{\n\tstruct asyncppp *ap = ap_get(tty);\n\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tif (!ap)\n\t\treturn;\n\tset_bit(XMIT_WAKEUP, &ap->xmit_flags);\n\ttasklet_schedule(&ap->tsk);\n\tap_put(ap);\n}\n\n\nstatic struct tty_ldisc_ops ppp_ldisc = {\n\t.owner  = THIS_MODULE,\n\t.num\t= N_PPP,\n\t.name\t= \"ppp\",\n\t.open\t= ppp_asynctty_open,\n\t.close\t= ppp_asynctty_close,\n\t.hangup\t= ppp_asynctty_hangup,\n\t.read\t= ppp_asynctty_read,\n\t.write\t= ppp_asynctty_write,\n\t.ioctl\t= ppp_asynctty_ioctl,\n\t.receive_buf = ppp_asynctty_receive,\n\t.write_wakeup = ppp_asynctty_wakeup,\n};\n\nstatic int __init\nppp_async_init(void)\n{\n\tint err;\n\n\terr = tty_register_ldisc(&ppp_ldisc);\n\tif (err != 0)\n\t\tprintk(KERN_ERR \"PPP_async: error %d registering line disc.\\n\",\n\t\t       err);\n\treturn err;\n}\n\n \nstatic int\nppp_async_ioctl(struct ppp_channel *chan, unsigned int cmd, unsigned long arg)\n{\n\tstruct asyncppp *ap = chan->private;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tint err, val;\n\tu32 accm[8];\n\n\terr = -EFAULT;\n\tswitch (cmd) {\n\tcase PPPIOCGFLAGS:\n\t\tval = ap->flags | ap->rbits;\n\t\tif (put_user(val, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCSFLAGS:\n\t\tif (get_user(val, p))\n\t\t\tbreak;\n\t\tap->flags = val & ~SC_RCV_BITS;\n\t\tspin_lock_irq(&ap->recv_lock);\n\t\tap->rbits = val & SC_RCV_BITS;\n\t\tspin_unlock_irq(&ap->recv_lock);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGASYNCMAP:\n\t\tif (put_user(ap->xaccm[0], (u32 __user *)argp))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCSASYNCMAP:\n\t\tif (get_user(ap->xaccm[0], (u32 __user *)argp))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGRASYNCMAP:\n\t\tif (put_user(ap->raccm, (u32 __user *)argp))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCSRASYNCMAP:\n\t\tif (get_user(ap->raccm, (u32 __user *)argp))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGXASYNCMAP:\n\t\tif (copy_to_user(argp, ap->xaccm, sizeof(ap->xaccm)))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCSXASYNCMAP:\n\t\tif (copy_from_user(accm, argp, sizeof(accm)))\n\t\t\tbreak;\n\t\taccm[2] &= ~0x40000000U;\t \n\t\taccm[3] |= 0x60000000U;\t\t \n\t\tmemcpy(ap->xaccm, accm, sizeof(ap->xaccm));\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGMRU:\n\t\tif (put_user(ap->mru, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCSMRU:\n\t\tif (get_user(val, p))\n\t\t\tbreak;\n\t\tif (val < PPP_MRU)\n\t\t\tval = PPP_MRU;\n\t\tap->mru = val;\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\n\treturn err;\n}\n\n \nstatic void ppp_async_process(struct tasklet_struct *t)\n{\n\tstruct asyncppp *ap = from_tasklet(ap, t, tsk);\n\tstruct sk_buff *skb;\n\n\t \n\twhile ((skb = skb_dequeue(&ap->rqueue)) != NULL) {\n\t\tif (skb->cb[0])\n\t\t\tppp_input_error(&ap->chan, 0);\n\t\tppp_input(&ap->chan, skb);\n\t}\n\n\t \n\tif (test_bit(XMIT_WAKEUP, &ap->xmit_flags) && ppp_async_push(ap))\n\t\tppp_output_wakeup(&ap->chan);\n}\n\n \n\n \n\n#define PUT_BYTE(ap, buf, c, islcp)\tdo {\t\t\\\n\tif ((islcp && c < 0x20) || (ap->xaccm[c >> 5] & (1 << (c & 0x1f)))) {\\\n\t\t*buf++ = PPP_ESCAPE;\t\t\t\\\n\t\t*buf++ = c ^ PPP_TRANS;\t\t\t\\\n\t} else\t\t\t\t\t\t\\\n\t\t*buf++ = c;\t\t\t\t\\\n} while (0)\n\nstatic int\nppp_async_encode(struct asyncppp *ap)\n{\n\tint fcs, i, count, c, proto;\n\tunsigned char *buf, *buflim;\n\tunsigned char *data;\n\tint islcp;\n\n\tbuf = ap->obuf;\n\tap->olim = buf;\n\tap->optr = buf;\n\ti = ap->tpkt_pos;\n\tdata = ap->tpkt->data;\n\tcount = ap->tpkt->len;\n\tfcs = ap->tfcs;\n\tproto = get_unaligned_be16(data);\n\n\t \n\tislcp = proto == PPP_LCP && 1 <= data[2] && data[2] <= 7;\n\n\tif (i == 0) {\n\t\tif (islcp)\n\t\t\tasync_lcp_peek(ap, data, count, 0);\n\n\t\t \n\t\tif (islcp || flag_time == 0 ||\n\t\t    time_after_eq(jiffies, ap->last_xmit + flag_time))\n\t\t\t*buf++ = PPP_FLAG;\n\t\tap->last_xmit = jiffies;\n\t\tfcs = PPP_INITFCS;\n\n\t\t \n\t\tif ((ap->flags & SC_COMP_AC) == 0 || islcp) {\n\t\t\tPUT_BYTE(ap, buf, 0xff, islcp);\n\t\t\tfcs = PPP_FCS(fcs, 0xff);\n\t\t\tPUT_BYTE(ap, buf, 0x03, islcp);\n\t\t\tfcs = PPP_FCS(fcs, 0x03);\n\t\t}\n\t}\n\n\t \n\tbuflim = ap->obuf + OBUFSIZE - 6;\n\twhile (i < count && buf < buflim) {\n\t\tc = data[i++];\n\t\tif (i == 1 && c == 0 && (ap->flags & SC_COMP_PROT))\n\t\t\tcontinue;\t \n\t\tfcs = PPP_FCS(fcs, c);\n\t\tPUT_BYTE(ap, buf, c, islcp);\n\t}\n\n\tif (i < count) {\n\t\t \n\t\tap->olim = buf;\n\t\tap->tpkt_pos = i;\n\t\tap->tfcs = fcs;\n\t\treturn 0;\n\t}\n\n\t \n\tfcs = ~fcs;\n\tc = fcs & 0xff;\n\tPUT_BYTE(ap, buf, c, islcp);\n\tc = (fcs >> 8) & 0xff;\n\tPUT_BYTE(ap, buf, c, islcp);\n\t*buf++ = PPP_FLAG;\n\tap->olim = buf;\n\n\tconsume_skb(ap->tpkt);\n\tap->tpkt = NULL;\n\treturn 1;\n}\n\n \n\n \nstatic int\nppp_async_send(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstruct asyncppp *ap = chan->private;\n\n\tppp_async_push(ap);\n\n\tif (test_and_set_bit(XMIT_FULL, &ap->xmit_flags))\n\t\treturn 0;\t \n\tap->tpkt = skb;\n\tap->tpkt_pos = 0;\n\n\tppp_async_push(ap);\n\treturn 1;\n}\n\n \nstatic int\nppp_async_push(struct asyncppp *ap)\n{\n\tint avail, sent, done = 0;\n\tstruct tty_struct *tty = ap->tty;\n\tint tty_stuffed = 0;\n\n\t \n\tif (test_and_set_bit(XMIT_BUSY, &ap->xmit_flags))\n\t\treturn 0;\n\tspin_lock_bh(&ap->xmit_lock);\n\tfor (;;) {\n\t\tif (test_and_clear_bit(XMIT_WAKEUP, &ap->xmit_flags))\n\t\t\ttty_stuffed = 0;\n\t\tif (!tty_stuffed && ap->optr < ap->olim) {\n\t\t\tavail = ap->olim - ap->optr;\n\t\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\t\t\tsent = tty->ops->write(tty, ap->optr, avail);\n\t\t\tif (sent < 0)\n\t\t\t\tgoto flush;\t \n\t\t\tap->optr += sent;\n\t\t\tif (sent < avail)\n\t\t\t\ttty_stuffed = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ap->optr >= ap->olim && ap->tpkt) {\n\t\t\tif (ppp_async_encode(ap)) {\n\t\t\t\t \n\t\t\t\tclear_bit(XMIT_FULL, &ap->xmit_flags);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tclear_bit(XMIT_BUSY, &ap->xmit_flags);\n\t\t \n\t\tif (!(test_bit(XMIT_WAKEUP, &ap->xmit_flags) ||\n\t\t      (!tty_stuffed && ap->tpkt)))\n\t\t\tbreak;\n\t\t \n\t\tif (test_and_set_bit(XMIT_BUSY, &ap->xmit_flags))\n\t\t\tbreak;\n\t}\n\tspin_unlock_bh(&ap->xmit_lock);\n\treturn done;\n\nflush:\n\tclear_bit(XMIT_BUSY, &ap->xmit_flags);\n\tif (ap->tpkt) {\n\t\tkfree_skb(ap->tpkt);\n\t\tap->tpkt = NULL;\n\t\tclear_bit(XMIT_FULL, &ap->xmit_flags);\n\t\tdone = 1;\n\t}\n\tap->optr = ap->olim;\n\tspin_unlock_bh(&ap->xmit_lock);\n\treturn done;\n}\n\n \nstatic void\nppp_async_flush_output(struct asyncppp *ap)\n{\n\tint done = 0;\n\n\tspin_lock_bh(&ap->xmit_lock);\n\tap->optr = ap->olim;\n\tif (ap->tpkt != NULL) {\n\t\tkfree_skb(ap->tpkt);\n\t\tap->tpkt = NULL;\n\t\tclear_bit(XMIT_FULL, &ap->xmit_flags);\n\t\tdone = 1;\n\t}\n\tspin_unlock_bh(&ap->xmit_lock);\n\tif (done)\n\t\tppp_output_wakeup(&ap->chan);\n}\n\n \n\n \nstatic inline int\nscan_ordinary(struct asyncppp *ap, const unsigned char *buf, int count)\n{\n\tint i, c;\n\n\tfor (i = 0; i < count; ++i) {\n\t\tc = buf[i];\n\t\tif (c == PPP_ESCAPE || c == PPP_FLAG ||\n\t\t    (c < 0x20 && (ap->raccm & (1 << c)) != 0))\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\n \nstatic void\nprocess_input_packet(struct asyncppp *ap)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *p;\n\tunsigned int len, fcs;\n\n\tskb = ap->rpkt;\n\tif (ap->state & (SC_TOSS | SC_ESCAPE))\n\t\tgoto err;\n\n\tif (skb == NULL)\n\t\treturn;\t\t \n\n\t \n\tp = skb->data;\n\tlen = skb->len;\n\tif (len < 3)\n\t\tgoto err;\t \n\tfcs = PPP_INITFCS;\n\tfor (; len > 0; --len)\n\t\tfcs = PPP_FCS(fcs, *p++);\n\tif (fcs != PPP_GOODFCS)\n\t\tgoto err;\t \n\tskb_trim(skb, skb->len - 2);\n\n\t \n\tp = skb->data;\n\tif (p[0] == PPP_ALLSTATIONS) {\n\t\t \n\t\tif (p[1] != PPP_UI || skb->len < 3)\n\t\t\tgoto err;\n\t\tp = skb_pull(skb, 2);\n\t}\n\n\t \n\tif (!(p[0] & 0x01)) {\n\t\tunsigned int proto;\n\n\t\tif (skb->len < 2)\n\t\t\tgoto err;\n\t\tproto = (p[0] << 8) + p[1];\n\t\tif (proto == PPP_LCP)\n\t\t\tasync_lcp_peek(ap, p, skb->len, 1);\n\t}\n\n\t \n\tskb->cb[0] = ap->state;\n\tskb_queue_tail(&ap->rqueue, skb);\n\tap->rpkt = NULL;\n\tap->state = 0;\n\treturn;\n\n err:\n\t \n\tap->state = SC_PREV_ERROR;\n\tif (skb) {\n\t\t \n\t\tskb_trim(skb, 0);\n\t\tskb_reserve(skb, - skb_headroom(skb));\n\t}\n}\n\n \n\nstatic void\nppp_async_input(struct asyncppp *ap, const u8 *buf, const u8 *flags, int count)\n{\n\tstruct sk_buff *skb;\n\tint c, i, j, n, s, f;\n\tunsigned char *sp;\n\n\t \n\tif (~ap->rbits & SC_RCV_BITS) {\n\t\ts = 0;\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tc = buf[i];\n\t\t\tif (flags && flags[i] != 0)\n\t\t\t\tcontinue;\n\t\t\ts |= (c & 0x80)? SC_RCV_B7_1: SC_RCV_B7_0;\n\t\t\tc = ((c >> 4) ^ c) & 0xf;\n\t\t\ts |= (0x6996 & (1 << c))? SC_RCV_ODDP: SC_RCV_EVNP;\n\t\t}\n\t\tap->rbits |= s;\n\t}\n\n\twhile (count > 0) {\n\t\t \n\t\tif ((ap->state & SC_ESCAPE) && buf[0] == PPP_ESCAPE)\n\t\t\tn = 1;\n\t\telse\n\t\t\tn = scan_ordinary(ap, buf, count);\n\n\t\tf = 0;\n\t\tif (flags && (ap->state & SC_TOSS) == 0) {\n\t\t\t \n\t\t\tfor (j = 0; j < n; ++j)\n\t\t\t\tif ((f = flags[j]) != 0)\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif (f != 0) {\n\t\t\t \n\t\t\tap->state |= SC_TOSS;\n\n\t\t} else if (n > 0 && (ap->state & SC_TOSS) == 0) {\n\t\t\t \n\t\t\tskb = ap->rpkt;\n\t\t\tif (!skb) {\n\t\t\t\tskb = dev_alloc_skb(ap->mru + PPP_HDRLEN + 2);\n\t\t\t\tif (!skb)\n\t\t\t\t\tgoto nomem;\n\t\t\t\tap->rpkt = skb;\n\t\t\t}\n\t\t\tif (skb->len == 0) {\n\t\t\t\t \n\t\t\t\tif (buf[0] != PPP_ALLSTATIONS)\n\t\t\t\t\tskb_reserve(skb, 2 + (buf[0] & 1));\n\t\t\t}\n\t\t\tif (n > skb_tailroom(skb)) {\n\t\t\t\t \n\t\t\t\tap->state |= SC_TOSS;\n\t\t\t} else {\n\t\t\t\tsp = skb_put_data(skb, buf, n);\n\t\t\t\tif (ap->state & SC_ESCAPE) {\n\t\t\t\t\tsp[0] ^= PPP_TRANS;\n\t\t\t\t\tap->state &= ~SC_ESCAPE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n >= count)\n\t\t\tbreak;\n\n\t\tc = buf[n];\n\t\tif (flags != NULL && flags[n] != 0) {\n\t\t\tap->state |= SC_TOSS;\n\t\t} else if (c == PPP_FLAG) {\n\t\t\tprocess_input_packet(ap);\n\t\t} else if (c == PPP_ESCAPE) {\n\t\t\tap->state |= SC_ESCAPE;\n\t\t} else if (I_IXON(ap->tty)) {\n\t\t\tif (c == START_CHAR(ap->tty))\n\t\t\t\tstart_tty(ap->tty);\n\t\t\telse if (c == STOP_CHAR(ap->tty))\n\t\t\t\tstop_tty(ap->tty);\n\t\t}\n\t\t \n\t\t++n;\n\n\t\tbuf += n;\n\t\tif (flags)\n\t\t\tflags += n;\n\t\tcount -= n;\n\t}\n\treturn;\n\n nomem:\n\tprintk(KERN_ERR \"PPPasync: no memory (input pkt)\\n\");\n\tap->state |= SC_TOSS;\n}\n\n \n#define CONFREQ\t\t1\t \n#define CONFACK\t\t2\n#define LCP_MRU\t\t1\t \n#define LCP_ASYNCMAP\t2\n\nstatic void async_lcp_peek(struct asyncppp *ap, unsigned char *data,\n\t\t\t   int len, int inbound)\n{\n\tint dlen, fcs, i, code;\n\tu32 val;\n\n\tdata += 2;\t\t \n\tlen -= 2;\n\tif (len < 4)\t\t \n\t\treturn;\n\tcode = data[0];\n\tif (code != CONFACK && code != CONFREQ)\n\t\treturn;\n\tdlen = get_unaligned_be16(data + 2);\n\tif (len < dlen)\n\t\treturn;\t\t \n\n\tif (code == (inbound? CONFACK: CONFREQ)) {\n\t\t \n\t\tfcs = PPP_INITFCS;\n\t\tfor (i = 1; i < dlen; ++i)\n\t\t\tfcs = PPP_FCS(fcs, data[i]);\n\n\t\tif (!inbound) {\n\t\t\t \n\t\t\tap->lcp_fcs = fcs;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tfcs ^= ap->lcp_fcs;\n\t\tap->lcp_fcs = -1;\n\t\tif (fcs != 0)\n\t\t\treturn;\n\t} else if (inbound)\n\t\treturn;\t \n\n\t \n\tdata += 4;\n\tdlen -= 4;\n\t \n\twhile (dlen >= 2 && dlen >= data[1] && data[1] >= 2) {\n\t\tswitch (data[0]) {\n\t\tcase LCP_MRU:\n\t\t\tval = get_unaligned_be16(data + 2);\n\t\t\tif (inbound)\n\t\t\t\tap->mru = val;\n\t\t\telse\n\t\t\t\tap->chan.mtu = val;\n\t\t\tbreak;\n\t\tcase LCP_ASYNCMAP:\n\t\t\tval = get_unaligned_be32(data + 2);\n\t\t\tif (inbound)\n\t\t\t\tap->raccm = val;\n\t\t\telse\n\t\t\t\tap->xaccm[0] = val;\n\t\t\tbreak;\n\t\t}\n\t\tdlen -= data[1];\n\t\tdata += data[1];\n\t}\n}\n\nstatic void __exit ppp_async_cleanup(void)\n{\n\ttty_unregister_ldisc(&ppp_ldisc);\n}\n\nmodule_init(ppp_async_init);\nmodule_exit(ppp_async_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}