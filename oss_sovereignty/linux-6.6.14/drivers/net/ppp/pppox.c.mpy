{
  "module_name": "pppox.c",
  "hash_id": "b8a83bb27b13bfad9138e412d33ccd9248298de8fd00877835b7af2745bca9d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ppp/pppox.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/compat.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/net.h>\n#include <linux/init.h>\n#include <linux/if_pppox.h>\n#include <linux/ppp_defs.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/ppp_channel.h>\n#include <linux/kmod.h>\n\n#include <net/sock.h>\n\n#include <linux/uaccess.h>\n\nstatic const struct pppox_proto *pppox_protos[PX_MAX_PROTO + 1];\n\nint register_pppox_proto(int proto_num, const struct pppox_proto *pp)\n{\n\tif (proto_num < 0 || proto_num > PX_MAX_PROTO)\n\t\treturn -EINVAL;\n\tif (pppox_protos[proto_num])\n\t\treturn -EALREADY;\n\tpppox_protos[proto_num] = pp;\n\treturn 0;\n}\n\nvoid unregister_pppox_proto(int proto_num)\n{\n\tif (proto_num >= 0 && proto_num <= PX_MAX_PROTO)\n\t\tpppox_protos[proto_num] = NULL;\n}\n\nvoid pppox_unbind_sock(struct sock *sk)\n{\n\t \n\n\tif (sk->sk_state & (PPPOX_BOUND | PPPOX_CONNECTED)) {\n\t\tppp_unregister_channel(&pppox_sk(sk)->chan);\n\t\tsk->sk_state = PPPOX_DEAD;\n\t}\n}\n\nEXPORT_SYMBOL(register_pppox_proto);\nEXPORT_SYMBOL(unregister_pppox_proto);\nEXPORT_SYMBOL(pppox_unbind_sock);\n\nint pppox_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tint rc;\n\n\tlock_sock(sk);\n\n\tswitch (cmd) {\n\tcase PPPIOCGCHAN: {\n\t\tint index;\n\t\trc = -ENOTCONN;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\trc = -EINVAL;\n\t\tindex = ppp_channel_index(&po->chan);\n\t\tif (put_user(index , (int __user *) arg))\n\t\t\tbreak;\n\n\t\trc = 0;\n\t\tsk->sk_state |= PPPOX_BOUND;\n\t\tbreak;\n\t}\n\tdefault:\n\t\trc = pppox_protos[sk->sk_protocol]->ioctl ?\n\t\t\tpppox_protos[sk->sk_protocol]->ioctl(sock, cmd, arg) : -ENOTTY;\n\t}\n\n\trelease_sock(sk);\n\treturn rc;\n}\n\nEXPORT_SYMBOL(pppox_ioctl);\n\n#ifdef CONFIG_COMPAT\nint pppox_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tif (cmd == PPPOEIOCSFWD32)\n\t\tcmd = PPPOEIOCSFWD;\n\n\treturn pppox_ioctl(sock, cmd, (unsigned long)compat_ptr(arg));\n}\n\nEXPORT_SYMBOL(pppox_compat_ioctl);\n#endif\n\nstatic int pppox_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tint rc = -EPROTOTYPE;\n\n\tif (protocol < 0 || protocol > PX_MAX_PROTO)\n\t\tgoto out;\n\n\trc = -EPROTONOSUPPORT;\n\tif (!pppox_protos[protocol])\n\t\trequest_module(\"net-pf-%d-proto-%d\", PF_PPPOX, protocol);\n\tif (!pppox_protos[protocol] ||\n\t    !try_module_get(pppox_protos[protocol]->owner))\n\t\tgoto out;\n\n\trc = pppox_protos[protocol]->create(net, sock, kern);\n\n\tmodule_put(pppox_protos[protocol]->owner);\nout:\n\treturn rc;\n}\n\nstatic const struct net_proto_family pppox_proto_family = {\n\t.family\t= PF_PPPOX,\n\t.create\t= pppox_create,\n\t.owner\t= THIS_MODULE,\n};\n\nstatic int __init pppox_init(void)\n{\n\treturn sock_register(&pppox_proto_family);\n}\n\nstatic void __exit pppox_exit(void)\n{\n\tsock_unregister(PF_PPPOX);\n}\n\nmodule_init(pppox_init);\nmodule_exit(pppox_exit);\n\nMODULE_AUTHOR(\"Michal Ostrowski <mostrows@speakeasy.net>\");\nMODULE_DESCRIPTION(\"PPP over Ethernet driver (generic socket layer)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_PPPOX);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}