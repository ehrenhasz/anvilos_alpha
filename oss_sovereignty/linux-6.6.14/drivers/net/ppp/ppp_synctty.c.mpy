{
  "module_name": "ppp_synctty.c",
  "hash_id": "e3abfbbc025b96112564e7ac9f8959daa8c0b93902fc3fb482c98dc67e708139",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ppp/ppp_synctty.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/tty.h>\n#include <linux/netdevice.h>\n#include <linux/poll.h>\n#include <linux/ppp_defs.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/ppp_channel.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n\n#define PPP_VERSION\t\"2.4.2\"\n\n \nstruct syncppp {\n\tstruct tty_struct *tty;\n\tunsigned int\tflags;\n\tunsigned int\trbits;\n\tint\t\tmru;\n\tspinlock_t\txmit_lock;\n\tspinlock_t\trecv_lock;\n\tunsigned long\txmit_flags;\n\tu32\t\txaccm[8];\n\tu32\t\traccm;\n\tunsigned int\tbytes_sent;\n\tunsigned int\tbytes_rcvd;\n\n\tstruct sk_buff\t*tpkt;\n\tunsigned long\tlast_xmit;\n\n\tstruct sk_buff_head rqueue;\n\n\tstruct tasklet_struct tsk;\n\n\trefcount_t\trefcnt;\n\tstruct completion dead_cmp;\n\tstruct ppp_channel chan;\t \n};\n\n \n#define XMIT_WAKEUP\t0\n#define XMIT_FULL\t1\n\n \n#define SC_RCV_BITS\t(SC_RCV_B7_1|SC_RCV_B7_0|SC_RCV_ODDP|SC_RCV_EVNP)\n\n#define PPPSYNC_MAX_RQLEN\t32\t \n\n \nstatic struct sk_buff* ppp_sync_txmunge(struct syncppp *ap, struct sk_buff *);\nstatic int ppp_sync_send(struct ppp_channel *chan, struct sk_buff *skb);\nstatic int ppp_sync_ioctl(struct ppp_channel *chan, unsigned int cmd,\n\t\t\t  unsigned long arg);\nstatic void ppp_sync_process(struct tasklet_struct *t);\nstatic int ppp_sync_push(struct syncppp *ap);\nstatic void ppp_sync_flush_output(struct syncppp *ap);\nstatic void ppp_sync_input(struct syncppp *ap, const u8 *buf, const u8 *flags,\n\t\t\t   int count);\n\nstatic const struct ppp_channel_ops sync_ops = {\n\t.start_xmit = ppp_sync_send,\n\t.ioctl      = ppp_sync_ioctl,\n};\n\n \nstatic void\nppp_print_buffer (const char *name, const __u8 *buf, int count)\n{\n\tif (name != NULL)\n\t\tprintk(KERN_DEBUG \"ppp_synctty: %s, count = %d\\n\", name, count);\n\n\tprint_hex_dump_bytes(\"\", DUMP_PREFIX_NONE, buf, count);\n}\n\n\n \n\n \nstatic DEFINE_RWLOCK(disc_data_lock);\n\nstatic struct syncppp *sp_get(struct tty_struct *tty)\n{\n\tstruct syncppp *ap;\n\n\tread_lock(&disc_data_lock);\n\tap = tty->disc_data;\n\tif (ap != NULL)\n\t\trefcount_inc(&ap->refcnt);\n\tread_unlock(&disc_data_lock);\n\treturn ap;\n}\n\nstatic void sp_put(struct syncppp *ap)\n{\n\tif (refcount_dec_and_test(&ap->refcnt))\n\t\tcomplete(&ap->dead_cmp);\n}\n\n \nstatic int\nppp_sync_open(struct tty_struct *tty)\n{\n\tstruct syncppp *ap;\n\tint err;\n\tint speed;\n\n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tap = kzalloc(sizeof(*ap), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!ap)\n\t\tgoto out;\n\n\t \n\tap->tty = tty;\n\tap->mru = PPP_MRU;\n\tspin_lock_init(&ap->xmit_lock);\n\tspin_lock_init(&ap->recv_lock);\n\tap->xaccm[0] = ~0U;\n\tap->xaccm[3] = 0x60000000U;\n\tap->raccm = ~0U;\n\n\tskb_queue_head_init(&ap->rqueue);\n\ttasklet_setup(&ap->tsk, ppp_sync_process);\n\n\trefcount_set(&ap->refcnt, 1);\n\tinit_completion(&ap->dead_cmp);\n\n\tap->chan.private = ap;\n\tap->chan.ops = &sync_ops;\n\tap->chan.mtu = PPP_MRU;\n\tap->chan.hdrlen = 2;\t \n\tspeed = tty_get_baud_rate(tty);\n\tap->chan.speed = speed;\n\terr = ppp_register_channel(&ap->chan);\n\tif (err)\n\t\tgoto out_free;\n\n\ttty->disc_data = ap;\n\ttty->receive_room = 65536;\n\treturn 0;\n\n out_free:\n\tkfree(ap);\n out:\n\treturn err;\n}\n\n \nstatic void\nppp_sync_close(struct tty_struct *tty)\n{\n\tstruct syncppp *ap;\n\n\twrite_lock_irq(&disc_data_lock);\n\tap = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!ap)\n\t\treturn;\n\n\t \n\tif (!refcount_dec_and_test(&ap->refcnt))\n\t\twait_for_completion(&ap->dead_cmp);\n\ttasklet_kill(&ap->tsk);\n\n\tppp_unregister_channel(&ap->chan);\n\tskb_queue_purge(&ap->rqueue);\n\tkfree_skb(ap->tpkt);\n\tkfree(ap);\n}\n\n \nstatic void ppp_sync_hangup(struct tty_struct *tty)\n{\n\tppp_sync_close(tty);\n}\n\n \nstatic ssize_t\nppp_sync_read(struct tty_struct *tty, struct file *file, u8 *buf, size_t count,\n\t      void **cookie, unsigned long offset)\n{\n\treturn -EAGAIN;\n}\n\n \nstatic ssize_t\nppp_sync_write(struct tty_struct *tty, struct file *file, const u8 *buf,\n\t       size_t count)\n{\n\treturn -EAGAIN;\n}\n\nstatic int\nppp_synctty_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)\n{\n\tstruct syncppp *ap = sp_get(tty);\n\tint __user *p = (int __user *)arg;\n\tint err, val;\n\n\tif (!ap)\n\t\treturn -ENXIO;\n\terr = -EFAULT;\n\tswitch (cmd) {\n\tcase PPPIOCGCHAN:\n\t\terr = -EFAULT;\n\t\tif (put_user(ppp_channel_index(&ap->chan), p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGUNIT:\n\t\terr = -EFAULT;\n\t\tif (put_user(ppp_unit_number(&ap->chan), p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase TCFLSH:\n\t\t \n\t\tif (arg == TCIOFLUSH || arg == TCOFLUSH)\n\t\t\tppp_sync_flush_output(ap);\n\t\terr = n_tty_ioctl_helper(tty, cmd, arg);\n\t\tbreak;\n\n\tcase FIONREAD:\n\t\tval = 0;\n\t\tif (put_user(val, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = tty_mode_ioctl(tty, cmd, arg);\n\t\tbreak;\n\t}\n\n\tsp_put(ap);\n\treturn err;\n}\n\n \nstatic void\nppp_sync_receive(struct tty_struct *tty, const u8 *buf, const u8 *cflags,\n\t\t size_t count)\n{\n\tstruct syncppp *ap = sp_get(tty);\n\tunsigned long flags;\n\n\tif (!ap)\n\t\treturn;\n\tspin_lock_irqsave(&ap->recv_lock, flags);\n\tppp_sync_input(ap, buf, cflags, count);\n\tspin_unlock_irqrestore(&ap->recv_lock, flags);\n\tif (!skb_queue_empty(&ap->rqueue))\n\t\ttasklet_schedule(&ap->tsk);\n\tsp_put(ap);\n\ttty_unthrottle(tty);\n}\n\nstatic void\nppp_sync_wakeup(struct tty_struct *tty)\n{\n\tstruct syncppp *ap = sp_get(tty);\n\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tif (!ap)\n\t\treturn;\n\tset_bit(XMIT_WAKEUP, &ap->xmit_flags);\n\ttasklet_schedule(&ap->tsk);\n\tsp_put(ap);\n}\n\n\nstatic struct tty_ldisc_ops ppp_sync_ldisc = {\n\t.owner\t= THIS_MODULE,\n\t.num\t= N_SYNC_PPP,\n\t.name\t= \"pppsync\",\n\t.open\t= ppp_sync_open,\n\t.close\t= ppp_sync_close,\n\t.hangup\t= ppp_sync_hangup,\n\t.read\t= ppp_sync_read,\n\t.write\t= ppp_sync_write,\n\t.ioctl\t= ppp_synctty_ioctl,\n\t.receive_buf = ppp_sync_receive,\n\t.write_wakeup = ppp_sync_wakeup,\n};\n\nstatic int __init\nppp_sync_init(void)\n{\n\tint err;\n\n\terr = tty_register_ldisc(&ppp_sync_ldisc);\n\tif (err != 0)\n\t\tprintk(KERN_ERR \"PPP_sync: error %d registering line disc.\\n\",\n\t\t       err);\n\treturn err;\n}\n\n \nstatic int\nppp_sync_ioctl(struct ppp_channel *chan, unsigned int cmd, unsigned long arg)\n{\n\tstruct syncppp *ap = chan->private;\n\tint err, val;\n\tu32 accm[8];\n\tvoid __user *argp = (void __user *)arg;\n\tu32 __user *p = argp;\n\n\terr = -EFAULT;\n\tswitch (cmd) {\n\tcase PPPIOCGFLAGS:\n\t\tval = ap->flags | ap->rbits;\n\t\tif (put_user(val, (int __user *) argp))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCSFLAGS:\n\t\tif (get_user(val, (int __user *) argp))\n\t\t\tbreak;\n\t\tap->flags = val & ~SC_RCV_BITS;\n\t\tspin_lock_irq(&ap->recv_lock);\n\t\tap->rbits = val & SC_RCV_BITS;\n\t\tspin_unlock_irq(&ap->recv_lock);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGASYNCMAP:\n\t\tif (put_user(ap->xaccm[0], p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCSASYNCMAP:\n\t\tif (get_user(ap->xaccm[0], p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGRASYNCMAP:\n\t\tif (put_user(ap->raccm, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCSRASYNCMAP:\n\t\tif (get_user(ap->raccm, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGXASYNCMAP:\n\t\tif (copy_to_user(argp, ap->xaccm, sizeof(ap->xaccm)))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCSXASYNCMAP:\n\t\tif (copy_from_user(accm, argp, sizeof(accm)))\n\t\t\tbreak;\n\t\taccm[2] &= ~0x40000000U;\t \n\t\taccm[3] |= 0x60000000U;\t\t \n\t\tmemcpy(ap->xaccm, accm, sizeof(ap->xaccm));\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGMRU:\n\t\tif (put_user(ap->mru, (int __user *) argp))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCSMRU:\n\t\tif (get_user(val, (int __user *) argp))\n\t\t\tbreak;\n\t\tif (val > U16_MAX) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (val < PPP_MRU)\n\t\t\tval = PPP_MRU;\n\t\tap->mru = val;\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\treturn err;\n}\n\n \nstatic void ppp_sync_process(struct tasklet_struct *t)\n{\n\tstruct syncppp *ap = from_tasklet(ap, t, tsk);\n\tstruct sk_buff *skb;\n\n\t \n\twhile ((skb = skb_dequeue(&ap->rqueue)) != NULL) {\n\t\tif (skb->len == 0) {\n\t\t\t \n\t\t\tppp_input_error(&ap->chan, 0);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t\telse\n\t\t\tppp_input(&ap->chan, skb);\n\t}\n\n\t \n\tif (test_bit(XMIT_WAKEUP, &ap->xmit_flags) && ppp_sync_push(ap))\n\t\tppp_output_wakeup(&ap->chan);\n}\n\n \n\nstatic struct sk_buff*\nppp_sync_txmunge(struct syncppp *ap, struct sk_buff *skb)\n{\n\tint proto;\n\tunsigned char *data;\n\tint islcp;\n\n\tdata  = skb->data;\n\tproto = get_unaligned_be16(data);\n\n\t \n\tislcp = proto == PPP_LCP && 1 <= data[2] && data[2] <= 7;\n\n\t \n\tif (data[0] == 0 && (ap->flags & SC_COMP_PROT) && !islcp)\n\t\tskb_pull(skb,1);\n\n\t \n\tif ((ap->flags & SC_COMP_AC) == 0 || islcp) {\n\t\tif (skb_headroom(skb) < 2) {\n\t\t\tstruct sk_buff *npkt = dev_alloc_skb(skb->len + 2);\n\t\t\tif (npkt == NULL) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tskb_reserve(npkt,2);\n\t\t\tskb_copy_from_linear_data(skb,\n\t\t\t\t      skb_put(npkt, skb->len), skb->len);\n\t\t\tconsume_skb(skb);\n\t\t\tskb = npkt;\n\t\t}\n\t\tskb_push(skb,2);\n\t\tskb->data[0] = PPP_ALLSTATIONS;\n\t\tskb->data[1] = PPP_UI;\n\t}\n\n\tap->last_xmit = jiffies;\n\n\tif (skb && ap->flags & SC_LOG_OUTPKT)\n\t\tppp_print_buffer (\"send buffer\", skb->data, skb->len);\n\n\treturn skb;\n}\n\n \n\n \nstatic int\nppp_sync_send(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstruct syncppp *ap = chan->private;\n\n\tppp_sync_push(ap);\n\n\tif (test_and_set_bit(XMIT_FULL, &ap->xmit_flags))\n\t\treturn 0;\t \n\tskb = ppp_sync_txmunge(ap, skb);\n\tif (skb != NULL)\n\t\tap->tpkt = skb;\n\telse\n\t\tclear_bit(XMIT_FULL, &ap->xmit_flags);\n\n\tppp_sync_push(ap);\n\treturn 1;\n}\n\n \nstatic int\nppp_sync_push(struct syncppp *ap)\n{\n\tint sent, done = 0;\n\tstruct tty_struct *tty = ap->tty;\n\tint tty_stuffed = 0;\n\n\tif (!spin_trylock_bh(&ap->xmit_lock))\n\t\treturn 0;\n\tfor (;;) {\n\t\tif (test_and_clear_bit(XMIT_WAKEUP, &ap->xmit_flags))\n\t\t\ttty_stuffed = 0;\n\t\tif (!tty_stuffed && ap->tpkt) {\n\t\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\t\t\tsent = tty->ops->write(tty, ap->tpkt->data, ap->tpkt->len);\n\t\t\tif (sent < 0)\n\t\t\t\tgoto flush;\t \n\t\t\tif (sent < ap->tpkt->len) {\n\t\t\t\ttty_stuffed = 1;\n\t\t\t} else {\n\t\t\t\tconsume_skb(ap->tpkt);\n\t\t\t\tap->tpkt = NULL;\n\t\t\t\tclear_bit(XMIT_FULL, &ap->xmit_flags);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tspin_unlock_bh(&ap->xmit_lock);\n\t\tif (!(test_bit(XMIT_WAKEUP, &ap->xmit_flags) ||\n\t\t      (!tty_stuffed && ap->tpkt)))\n\t\t\tbreak;\n\t\tif (!spin_trylock_bh(&ap->xmit_lock))\n\t\t\tbreak;\n\t}\n\treturn done;\n\nflush:\n\tif (ap->tpkt) {\n\t\tkfree_skb(ap->tpkt);\n\t\tap->tpkt = NULL;\n\t\tclear_bit(XMIT_FULL, &ap->xmit_flags);\n\t\tdone = 1;\n\t}\n\tspin_unlock_bh(&ap->xmit_lock);\n\treturn done;\n}\n\n \nstatic void\nppp_sync_flush_output(struct syncppp *ap)\n{\n\tint done = 0;\n\n\tspin_lock_bh(&ap->xmit_lock);\n\tif (ap->tpkt != NULL) {\n\t\tkfree_skb(ap->tpkt);\n\t\tap->tpkt = NULL;\n\t\tclear_bit(XMIT_FULL, &ap->xmit_flags);\n\t\tdone = 1;\n\t}\n\tspin_unlock_bh(&ap->xmit_lock);\n\tif (done)\n\t\tppp_output_wakeup(&ap->chan);\n}\n\n \n\n \nstatic void\nppp_sync_input(struct syncppp *ap, const u8 *buf, const u8 *flags, int count)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *p;\n\n\tif (count == 0)\n\t\treturn;\n\n\tif (ap->flags & SC_LOG_INPKT)\n\t\tppp_print_buffer (\"receive buffer\", buf, count);\n\n\t \n\tskb = dev_alloc_skb(ap->mru + PPP_HDRLEN + 2);\n\tif (!skb) {\n\t\tprintk(KERN_ERR \"PPPsync: no memory (input pkt)\\n\");\n\t\tgoto err;\n\t}\n\t \n\tif (buf[0] != PPP_ALLSTATIONS)\n\t\tskb_reserve(skb, 2 + (buf[0] & 1));\n\n\tif (flags && *flags) {\n\t\t \n\t\tgoto err;\n\t} else if (count > skb_tailroom(skb)) {\n\t\t \n\t\tgoto err;\n\t}\n\n\tskb_put_data(skb, buf, count);\n\n\t \n\tp = skb->data;\n\tif (skb->len >= 2 && p[0] == PPP_ALLSTATIONS && p[1] == PPP_UI) {\n\t\t \n\t\tif (skb->len < 3)\n\t\t\tgoto err;\n\t\tp = skb_pull(skb, 2);\n\t}\n\n\t \n\tif (!(p[0] & 0x01) && skb->len < 2)\n\t\tgoto err;\n\n\t \n\tskb_queue_tail(&ap->rqueue, skb);\n\treturn;\n\nerr:\n\t \n\tif (skb || (skb = dev_alloc_skb(0))) {\n\t\tskb_trim(skb, 0);\n\t\tskb_queue_tail(&ap->rqueue, skb);\n\t}\n}\n\nstatic void __exit\nppp_sync_cleanup(void)\n{\n\ttty_unregister_ldisc(&ppp_sync_ldisc);\n}\n\nmodule_init(ppp_sync_init);\nmodule_exit(ppp_sync_cleanup);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_SYNC_PPP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}