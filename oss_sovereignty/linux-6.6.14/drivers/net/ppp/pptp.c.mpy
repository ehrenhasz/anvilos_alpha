{
  "module_name": "pptp.c",
  "hash_id": "b2178ba771cb128903840f9b958ca0651961c56aaea416bc9c036b24c8569f5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ppp/pptp.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/ppp_channel.h>\n#include <linux/ppp_defs.h>\n#include <linux/if_pppox.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/notifier.h>\n#include <linux/file.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/rcupdate.h>\n#include <linux/security.h>\n#include <linux/spinlock.h>\n\n#include <net/sock.h>\n#include <net/protocol.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/route.h>\n#include <net/gre.h>\n#include <net/pptp.h>\n\n#include <linux/uaccess.h>\n\n#define PPTP_DRIVER_VERSION \"0.8.5\"\n\n#define MAX_CALLID 65535\n\nstatic DECLARE_BITMAP(callid_bitmap, MAX_CALLID + 1);\nstatic struct pppox_sock __rcu **callid_sock;\n\nstatic DEFINE_SPINLOCK(chan_lock);\n\nstatic struct proto pptp_sk_proto __read_mostly;\nstatic const struct ppp_channel_ops pptp_chan_ops;\nstatic const struct proto_ops pptp_ops;\n\nstatic struct pppox_sock *lookup_chan(u16 call_id, __be32 s_addr)\n{\n\tstruct pppox_sock *sock;\n\tstruct pptp_opt *opt;\n\n\trcu_read_lock();\n\tsock = rcu_dereference(callid_sock[call_id]);\n\tif (sock) {\n\t\topt = &sock->proto.pptp;\n\t\tif (opt->dst_addr.sin_addr.s_addr != s_addr)\n\t\t\tsock = NULL;\n\t\telse\n\t\t\tsock_hold(sk_pppox(sock));\n\t}\n\trcu_read_unlock();\n\n\treturn sock;\n}\n\nstatic int lookup_chan_dst(u16 call_id, __be32 d_addr)\n{\n\tstruct pppox_sock *sock;\n\tstruct pptp_opt *opt;\n\tint i;\n\n\trcu_read_lock();\n\ti = 1;\n\tfor_each_set_bit_from(i, callid_bitmap, MAX_CALLID) {\n\t\tsock = rcu_dereference(callid_sock[i]);\n\t\tif (!sock)\n\t\t\tcontinue;\n\t\topt = &sock->proto.pptp;\n\t\tif (opt->dst_addr.call_id == call_id &&\n\t\t\t  opt->dst_addr.sin_addr.s_addr == d_addr)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn i < MAX_CALLID;\n}\n\nstatic int add_chan(struct pppox_sock *sock,\n\t\t    struct pptp_addr *sa)\n{\n\tstatic int call_id;\n\n\tspin_lock(&chan_lock);\n\tif (!sa->call_id)\t{\n\t\tcall_id = find_next_zero_bit(callid_bitmap, MAX_CALLID, call_id + 1);\n\t\tif (call_id == MAX_CALLID) {\n\t\t\tcall_id = find_next_zero_bit(callid_bitmap, MAX_CALLID, 1);\n\t\t\tif (call_id == MAX_CALLID)\n\t\t\t\tgoto out_err;\n\t\t}\n\t\tsa->call_id = call_id;\n\t} else if (test_bit(sa->call_id, callid_bitmap)) {\n\t\tgoto out_err;\n\t}\n\n\tsock->proto.pptp.src_addr = *sa;\n\tset_bit(sa->call_id, callid_bitmap);\n\trcu_assign_pointer(callid_sock[sa->call_id], sock);\n\tspin_unlock(&chan_lock);\n\n\treturn 0;\n\nout_err:\n\tspin_unlock(&chan_lock);\n\treturn -1;\n}\n\nstatic void del_chan(struct pppox_sock *sock)\n{\n\tspin_lock(&chan_lock);\n\tclear_bit(sock->proto.pptp.src_addr.call_id, callid_bitmap);\n\tRCU_INIT_POINTER(callid_sock[sock->proto.pptp.src_addr.call_id], NULL);\n\tspin_unlock(&chan_lock);\n}\n\nstatic struct rtable *pptp_route_output(const struct pppox_sock *po,\n\t\t\t\t\tstruct flowi4 *fl4)\n{\n\tconst struct sock *sk = &po->sk;\n\tstruct net *net;\n\n\tnet = sock_net(sk);\n\tflowi4_init_output(fl4, sk->sk_bound_dev_if, sk->sk_mark, 0,\n\t\t\t   RT_SCOPE_UNIVERSE, IPPROTO_GRE, 0,\n\t\t\t   po->proto.pptp.dst_addr.sin_addr.s_addr,\n\t\t\t   po->proto.pptp.src_addr.sin_addr.s_addr,\n\t\t\t   0, 0, sock_net_uid(net, sk));\n\tsecurity_sk_classify_flow(sk, flowi4_to_flowi_common(fl4));\n\n\treturn ip_route_output_flow(net, fl4, sk);\n}\n\nstatic int pptp_xmit(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstruct sock *sk = chan->private;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tstruct pptp_gre_header *hdr;\n\tunsigned int header_len = sizeof(*hdr);\n\tstruct flowi4 fl4;\n\tint islcp;\n\tint len;\n\tunsigned char *data;\n\t__u32 seq_recv;\n\n\n\tstruct rtable *rt;\n\tstruct net_device *tdev;\n\tstruct iphdr  *iph;\n\tint    max_headroom;\n\n\tif (sk_pppox(po)->sk_state & PPPOX_DEAD)\n\t\tgoto tx_error;\n\n\trt = pptp_route_output(po, &fl4);\n\tif (IS_ERR(rt))\n\t\tgoto tx_error;\n\n\ttdev = rt->dst.dev;\n\n\tmax_headroom = LL_RESERVED_SPACE(tdev) + sizeof(*iph) + sizeof(*hdr) + 2;\n\n\tif (skb_headroom(skb) < max_headroom || skb_cloned(skb) || skb_shared(skb)) {\n\t\tstruct sk_buff *new_skb = skb_realloc_headroom(skb, max_headroom);\n\t\tif (!new_skb) {\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(new_skb, skb->sk);\n\t\tconsume_skb(skb);\n\t\tskb = new_skb;\n\t}\n\n\tdata = skb->data;\n\tislcp = ((data[0] << 8) + data[1]) == PPP_LCP && 1 <= data[2] && data[2] <= 7;\n\n\t \n\tif ((opt->ppp_flags & SC_COMP_PROT) && data[0] == 0 && !islcp)\n\t\tskb_pull(skb, 1);\n\n\t \n\tif ((opt->ppp_flags & SC_COMP_AC) == 0 || islcp) {\n\t\tdata = skb_push(skb, 2);\n\t\tdata[0] = PPP_ALLSTATIONS;\n\t\tdata[1] = PPP_UI;\n\t}\n\n\tlen = skb->len;\n\n\tseq_recv = opt->seq_recv;\n\n\tif (opt->ack_sent == seq_recv)\n\t\theader_len -= sizeof(hdr->ack);\n\n\t \n\tskb_push(skb, header_len);\n\thdr = (struct pptp_gre_header *)(skb->data);\n\n\thdr->gre_hd.flags = GRE_KEY | GRE_VERSION_1 | GRE_SEQ;\n\thdr->gre_hd.protocol = GRE_PROTO_PPP;\n\thdr->call_id = htons(opt->dst_addr.call_id);\n\n\thdr->seq = htonl(++opt->seq_sent);\n\tif (opt->ack_sent != seq_recv)\t{\n\t\t \n\t\thdr->gre_hd.flags |= GRE_ACK;\n\t\thdr->ack  = htonl(seq_recv);\n\t\topt->ack_sent = seq_recv;\n\t}\n\thdr->payload_len = htons(len);\n\n\t \n\n\tskb_reset_transport_header(skb);\n\tskb_push(skb, sizeof(*iph));\n\tskb_reset_network_header(skb);\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\tIPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED | IPSKB_REROUTED);\n\n\tiph =\tip_hdr(skb);\n\tiph->version =\t4;\n\tiph->ihl =\tsizeof(struct iphdr) >> 2;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off\t=\thtons(IP_DF);\n\telse\n\t\tiph->frag_off\t=\t0;\n\tiph->protocol = IPPROTO_GRE;\n\tiph->tos      = 0;\n\tiph->daddr    = fl4.daddr;\n\tiph->saddr    = fl4.saddr;\n\tiph->ttl      = ip4_dst_hoplimit(&rt->dst);\n\tiph->tot_len  = htons(skb->len);\n\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, &rt->dst);\n\n\tnf_reset_ct(skb);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\tip_select_ident(net, skb, NULL);\n\tip_send_check(iph);\n\n\tip_local_out(net, skb->sk, skb);\n\treturn 1;\n\ntx_error:\n\tkfree_skb(skb);\n\treturn 1;\n}\n\nstatic int pptp_rcv_core(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tint headersize, payload_len, seq;\n\t__u8 *payload;\n\tstruct pptp_gre_header *header;\n\n\tif (!(sk->sk_state & PPPOX_CONNECTED)) {\n\t\tif (sock_queue_rcv_skb(sk, skb))\n\t\t\tgoto drop;\n\t\treturn NET_RX_SUCCESS;\n\t}\n\n\theader = (struct pptp_gre_header *)(skb->data);\n\theadersize  = sizeof(*header);\n\n\t \n\tif (GRE_IS_ACK(header->gre_hd.flags)) {\n\t\t__u32 ack;\n\n\t\tif (!pskb_may_pull(skb, headersize))\n\t\t\tgoto drop;\n\t\theader = (struct pptp_gre_header *)(skb->data);\n\n\t\t \n\t\tack = GRE_IS_SEQ(header->gre_hd.flags) ? ntohl(header->ack) :\n\t\t\t\t\t\t\t ntohl(header->seq);\n\t\tif (ack > opt->ack_recv)\n\t\t\topt->ack_recv = ack;\n\t\t \n\t\tif (WRAPPED(ack, opt->ack_recv))\n\t\t\topt->ack_recv = ack;\n\t} else {\n\t\theadersize -= sizeof(header->ack);\n\t}\n\t \n\tif (!GRE_IS_SEQ(header->gre_hd.flags))\n\t\tgoto drop;\n\n\tpayload_len = ntohs(header->payload_len);\n\tseq         = ntohl(header->seq);\n\n\t \n\tif (!pskb_may_pull(skb, headersize + payload_len))\n\t\tgoto drop;\n\n\tpayload = skb->data + headersize;\n\t \n\tif (seq < opt->seq_recv + 1 || WRAPPED(opt->seq_recv, seq)) {\n\t\tif ((payload[0] == PPP_ALLSTATIONS) && (payload[1] == PPP_UI) &&\n\t\t\t\t(PPP_PROTOCOL(payload) == PPP_LCP) &&\n\t\t\t\t((payload[4] == PPP_LCP_ECHOREQ) || (payload[4] == PPP_LCP_ECHOREP)))\n\t\t\tgoto allow_packet;\n\t} else {\n\t\topt->seq_recv = seq;\nallow_packet:\n\t\tskb_pull(skb, headersize);\n\n\t\tif (payload[0] == PPP_ALLSTATIONS && payload[1] == PPP_UI) {\n\t\t\t \n\t\t\tif (skb->len < 3)\n\t\t\t\tgoto drop;\n\t\t\tskb_pull(skb, 2);\n\t\t}\n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tskb_set_network_header(skb, skb->head-skb->data);\n\t\tppp_input(&po->chan, skb);\n\n\t\treturn NET_RX_SUCCESS;\n\t}\ndrop:\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\nstatic int pptp_rcv(struct sk_buff *skb)\n{\n\tstruct pppox_sock *po;\n\tstruct pptp_gre_header *header;\n\tstruct iphdr *iph;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, 12))\n\t\tgoto drop;\n\n\tiph = ip_hdr(skb);\n\n\theader = (struct pptp_gre_header *)skb->data;\n\n\tif (header->gre_hd.protocol != GRE_PROTO_PPP ||  \n\t\tGRE_IS_CSUM(header->gre_hd.flags) ||     \n\t\tGRE_IS_ROUTING(header->gre_hd.flags) ||  \n\t\t!GRE_IS_KEY(header->gre_hd.flags) ||     \n\t\t(header->gre_hd.flags & GRE_FLAGS))      \n\t\t \n\t\tgoto drop;\n\n\tpo = lookup_chan(ntohs(header->call_id), iph->saddr);\n\tif (po) {\n\t\tskb_dst_drop(skb);\n\t\tnf_reset_ct(skb);\n\t\treturn sk_receive_skb(sk_pppox(po), skb, 0);\n\t}\ndrop:\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\nstatic int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tint error = 0;\n\n\tif (sockaddr_len < sizeof(struct sockaddr_pppox))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state & PPPOX_DEAD) {\n\t\terror = -EALREADY;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (add_chan(po, &sp->sa_addr.pptp))\n\t\terror = -EBUSY;\n\telse\n\t\tsk->sk_state |= PPPOX_BOUND;\n\nout:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\tint error = 0;\n\n\tif (sockaddr_len < sizeof(struct sockaddr_pppox))\n\t\treturn -EINVAL;\n\n\tif (sp->sa_protocol != PX_PROTO_PPTP)\n\t\treturn -EINVAL;\n\n\tif (lookup_chan_dst(sp->sa_addr.pptp.call_id, sp->sa_addr.pptp.sin_addr.s_addr))\n\t\treturn -EALREADY;\n\n\tlock_sock(sk);\n\t \n\tif (sk->sk_state & PPPOX_CONNECTED) {\n\t\terror = -EBUSY;\n\t\tgoto end;\n\t}\n\n\t \n\tif (sk->sk_state & PPPOX_DEAD) {\n\t\terror = -EALREADY;\n\t\tgoto end;\n\t}\n\n\tif (!opt->src_addr.sin_addr.s_addr || !sp->sa_addr.pptp.sin_addr.s_addr) {\n\t\terror = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tpo->chan.private = sk;\n\tpo->chan.ops = &pptp_chan_ops;\n\n\trt = pptp_route_output(po, &fl4);\n\tif (IS_ERR(rt)) {\n\t\terror = -EHOSTUNREACH;\n\t\tgoto end;\n\t}\n\tsk_setup_caps(sk, &rt->dst);\n\n\tpo->chan.mtu = dst_mtu(&rt->dst);\n\tif (!po->chan.mtu)\n\t\tpo->chan.mtu = PPP_MRU;\n\tpo->chan.mtu -= PPTP_HEADER_OVERHEAD;\n\n\tpo->chan.hdrlen = 2 + sizeof(struct pptp_gre_header);\n\terror = ppp_register_channel(&po->chan);\n\tif (error) {\n\t\tpr_err(\"PPTP: failed to register PPP channel (%d)\\n\", error);\n\t\tgoto end;\n\t}\n\n\topt->dst_addr = sp->sa_addr.pptp;\n\tsk->sk_state |= PPPOX_CONNECTED;\n\n end:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic int pptp_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint peer)\n{\n\tint len = sizeof(struct sockaddr_pppox);\n\tstruct sockaddr_pppox sp;\n\n\tmemset(&sp.sa_addr, 0, sizeof(sp.sa_addr));\n\n\tsp.sa_family    = AF_PPPOX;\n\tsp.sa_protocol  = PX_PROTO_PPTP;\n\tsp.sa_addr.pptp = pppox_sk(sock->sk)->proto.pptp.src_addr;\n\n\tmemcpy(uaddr, &sp, len);\n\n\treturn len;\n}\n\nstatic int pptp_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pppox_sock *po;\n\tint error = 0;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\n\tif (sock_flag(sk, SOCK_DEAD)) {\n\t\trelease_sock(sk);\n\t\treturn -EBADF;\n\t}\n\n\tpo = pppox_sk(sk);\n\tdel_chan(po);\n\tsynchronize_rcu();\n\n\tpppox_unbind_sock(sk);\n\tsk->sk_state = PPPOX_DEAD;\n\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn error;\n}\n\nstatic void pptp_sock_destruct(struct sock *sk)\n{\n\tif (!(sk->sk_state & PPPOX_DEAD)) {\n\t\tdel_chan(pppox_sk(sk));\n\t\tpppox_unbind_sock(sk);\n\t}\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tdst_release(rcu_dereference_protected(sk->sk_dst_cache, 1));\n}\n\nstatic int pptp_create(struct net *net, struct socket *sock, int kern)\n{\n\tint error = -ENOMEM;\n\tstruct sock *sk;\n\tstruct pppox_sock *po;\n\tstruct pptp_opt *opt;\n\n\tsk = sk_alloc(net, PF_PPPOX, GFP_KERNEL, &pptp_sk_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock_init_data(sock, sk);\n\n\tsock->state = SS_UNCONNECTED;\n\tsock->ops   = &pptp_ops;\n\n\tsk->sk_backlog_rcv = pptp_rcv_core;\n\tsk->sk_state       = PPPOX_NONE;\n\tsk->sk_type        = SOCK_STREAM;\n\tsk->sk_family      = PF_PPPOX;\n\tsk->sk_protocol    = PX_PROTO_PPTP;\n\tsk->sk_destruct    = pptp_sock_destruct;\n\n\tpo = pppox_sk(sk);\n\topt = &po->proto.pptp;\n\n\topt->seq_sent = 0; opt->seq_recv = 0xffffffff;\n\topt->ack_recv = 0; opt->ack_sent = 0xffffffff;\n\n\terror = 0;\nout:\n\treturn error;\n}\n\nstatic int pptp_ppp_ioctl(struct ppp_channel *chan, unsigned int cmd,\n\tunsigned long arg)\n{\n\tstruct sock *sk = chan->private;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\tint err, val;\n\n\terr = -EFAULT;\n\tswitch (cmd) {\n\tcase PPPIOCGFLAGS:\n\t\tval = opt->ppp_flags;\n\t\tif (put_user(val, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCSFLAGS:\n\t\tif (get_user(val, p))\n\t\t\tbreak;\n\t\topt->ppp_flags = val & ~SC_RCV_BITS;\n\t\terr = 0;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\n\treturn err;\n}\n\nstatic const struct ppp_channel_ops pptp_chan_ops = {\n\t.start_xmit = pptp_xmit,\n\t.ioctl      = pptp_ppp_ioctl,\n};\n\nstatic struct proto pptp_sk_proto __read_mostly = {\n\t.name     = \"PPTP\",\n\t.owner    = THIS_MODULE,\n\t.obj_size = sizeof(struct pppox_sock),\n};\n\nstatic const struct proto_ops pptp_ops = {\n\t.family     = AF_PPPOX,\n\t.owner      = THIS_MODULE,\n\t.release    = pptp_release,\n\t.bind       = pptp_bind,\n\t.connect    = pptp_connect,\n\t.socketpair = sock_no_socketpair,\n\t.accept     = sock_no_accept,\n\t.getname    = pptp_getname,\n\t.listen     = sock_no_listen,\n\t.shutdown   = sock_no_shutdown,\n\t.sendmsg    = sock_no_sendmsg,\n\t.recvmsg    = sock_no_recvmsg,\n\t.mmap       = sock_no_mmap,\n\t.ioctl      = pppox_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = pppox_compat_ioctl,\n#endif\n};\n\nstatic const struct pppox_proto pppox_pptp_proto = {\n\t.create = pptp_create,\n\t.owner  = THIS_MODULE,\n};\n\nstatic const struct gre_protocol gre_pptp_protocol = {\n\t.handler = pptp_rcv,\n};\n\nstatic int __init pptp_init_module(void)\n{\n\tint err = 0;\n\tpr_info(\"PPTP driver version \" PPTP_DRIVER_VERSION \"\\n\");\n\n\tcallid_sock = vzalloc(array_size(sizeof(void *), (MAX_CALLID + 1)));\n\tif (!callid_sock)\n\t\treturn -ENOMEM;\n\n\terr = gre_add_protocol(&gre_pptp_protocol, GREPROTO_PPTP);\n\tif (err) {\n\t\tpr_err(\"PPTP: can't add gre protocol\\n\");\n\t\tgoto out_mem_free;\n\t}\n\n\terr = proto_register(&pptp_sk_proto, 0);\n\tif (err) {\n\t\tpr_err(\"PPTP: can't register sk_proto\\n\");\n\t\tgoto out_gre_del_protocol;\n\t}\n\n\terr = register_pppox_proto(PX_PROTO_PPTP, &pppox_pptp_proto);\n\tif (err) {\n\t\tpr_err(\"PPTP: can't register pppox_proto\\n\");\n\t\tgoto out_unregister_sk_proto;\n\t}\n\n\treturn 0;\n\nout_unregister_sk_proto:\n\tproto_unregister(&pptp_sk_proto);\nout_gre_del_protocol:\n\tgre_del_protocol(&gre_pptp_protocol, GREPROTO_PPTP);\nout_mem_free:\n\tvfree(callid_sock);\n\n\treturn err;\n}\n\nstatic void __exit pptp_exit_module(void)\n{\n\tunregister_pppox_proto(PX_PROTO_PPTP);\n\tproto_unregister(&pptp_sk_proto);\n\tgre_del_protocol(&gre_pptp_protocol, GREPROTO_PPTP);\n\tvfree(callid_sock);\n}\n\nmodule_init(pptp_init_module);\nmodule_exit(pptp_exit_module);\n\nMODULE_DESCRIPTION(\"Point-to-Point Tunneling Protocol\");\nMODULE_AUTHOR(\"D. Kozlov (xeb@mail.ru)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO(PF_PPPOX, PX_PROTO_PPTP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}