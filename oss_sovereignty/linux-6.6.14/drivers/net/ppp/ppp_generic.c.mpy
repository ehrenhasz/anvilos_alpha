{
  "module_name": "ppp_generic.c",
  "hash_id": "fddbb54a4a81a10b6a2e9dd0c0ccfba5270ca753a5f859ff7bab0c742514f52f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ppp/ppp_generic.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/kmod.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/idr.h>\n#include <linux/netdevice.h>\n#include <linux/poll.h>\n#include <linux/ppp_defs.h>\n#include <linux/filter.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/ppp_channel.h>\n#include <linux/ppp-comp.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_arp.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/spinlock.h>\n#include <linux/rwsem.h>\n#include <linux/stddef.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <asm/unaligned.h>\n#include <net/slhc_vj.h>\n#include <linux/atomic.h>\n#include <linux/refcount.h>\n\n#include <linux/nsproxy.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n#define PPP_VERSION\t\"2.4.2\"\n\n \n#define NP_IP\t0\t\t \n#define NP_IPV6\t1\t\t \n#define NP_IPX\t2\t\t \n#define NP_AT\t3\t\t \n#define NP_MPLS_UC 4\t\t \n#define NP_MPLS_MC 5\t\t \n#define NUM_NP\t6\t\t \n\n#define MPHDRLEN\t6\t \n#define MPHDRLEN_SSN\t4\t \n\n#define PPP_PROTO_LEN\t2\n\n \nstruct ppp_file {\n\tenum {\n\t\tINTERFACE=1, CHANNEL\n\t}\t\tkind;\n\tstruct sk_buff_head xq;\t\t \n\tstruct sk_buff_head rq;\t\t \n\twait_queue_head_t rwait;\t \n\trefcount_t\trefcnt;\t\t \n\tint\t\thdrlen;\t\t \n\tint\t\tindex;\t\t \n\tint\t\tdead;\t\t \n};\n\n#define PF_TO_X(pf, X)\t\tcontainer_of(pf, X, file)\n\n#define PF_TO_PPP(pf)\t\tPF_TO_X(pf, struct ppp)\n#define PF_TO_CHANNEL(pf)\tPF_TO_X(pf, struct channel)\n\n \nstruct ppp_link_stats {\n\tu64 rx_packets;\n\tu64 tx_packets;\n\tu64 rx_bytes;\n\tu64 tx_bytes;\n};\n\n \nstruct ppp {\n\tstruct ppp_file\tfile;\t\t \n\tstruct file\t*owner;\t\t \n\tstruct list_head channels;\t \n\tint\t\tn_channels;\t \n\tspinlock_t\trlock;\t\t \n\tspinlock_t\twlock;\t\t \n\tint __percpu\t*xmit_recursion;  \n\tint\t\tmru;\t\t \n\tunsigned int\tflags;\t\t \n\tunsigned int\txstate;\t\t \n\tunsigned int\trstate;\t\t \n\tint\t\tdebug;\t\t \n\tstruct slcompress *vj;\t\t \n\tenum NPmode\tnpmode[NUM_NP];\t \n\tstruct sk_buff\t*xmit_pending;\t \n\tstruct compressor *xcomp;\t \n\tvoid\t\t*xc_state;\t \n\tstruct compressor *rcomp;\t \n\tvoid\t\t*rc_state;\t \n\tunsigned long\tlast_xmit;\t \n\tunsigned long\tlast_recv;\t \n\tstruct net_device *dev;\t\t \n\tint\t\tclosing;\t \n#ifdef CONFIG_PPP_MULTILINK\n\tint\t\tnxchan;\t\t \n\tu32\t\tnxseq;\t\t \n\tint\t\tmrru;\t\t \n\tu32\t\tnextseq;\t \n\tu32\t\tminseq;\t\t \n\tstruct sk_buff_head mrq;\t \n#endif  \n#ifdef CONFIG_PPP_FILTER\n\tstruct bpf_prog *pass_filter;\t \n\tstruct bpf_prog *active_filter;  \n#endif  \n\tstruct net\t*ppp_net;\t \n\tstruct ppp_link_stats stats64;\t \n};\n\n \n#define SC_FLAG_BITS\t(SC_NO_TCP_CCID|SC_CCP_OPEN|SC_CCP_UP|SC_LOOP_TRAFFIC \\\n\t\t\t |SC_MULTILINK|SC_MP_SHORTSEQ|SC_MP_XSHORTSEQ \\\n\t\t\t |SC_COMP_TCP|SC_REJ_COMP_TCP|SC_MUST_COMP)\n\n \nstruct channel {\n\tstruct ppp_file\tfile;\t\t \n\tstruct list_head list;\t\t \n\tstruct ppp_channel *chan;\t \n\tstruct rw_semaphore chan_sem;\t \n\tspinlock_t\tdownl;\t\t \n\tstruct ppp\t*ppp;\t\t \n\tstruct net\t*chan_net;\t \n\tnetns_tracker\tns_tracker;\n\tstruct list_head clist;\t\t \n\trwlock_t\tupl;\t\t \n\tstruct channel __rcu *bridge;\t \n#ifdef CONFIG_PPP_MULTILINK\n\tu8\t\tavail;\t\t \n\tu8\t\thad_frag;\t \n\tu32\t\tlastseq;\t \n\tint\t\tspeed;\t\t \n#endif  \n};\n\nstruct ppp_config {\n\tstruct file *file;\n\ts32 unit;\n\tbool ifname_is_set;\n};\n\n \n\nstatic DEFINE_MUTEX(ppp_mutex);\nstatic atomic_t ppp_unit_count = ATOMIC_INIT(0);\nstatic atomic_t channel_count = ATOMIC_INIT(0);\n\n \nstatic unsigned int ppp_net_id __read_mostly;\nstruct ppp_net {\n\t \n\tstruct idr units_idr;\n\n\t \n\tstruct mutex all_ppp_mutex;\n\n\t \n\tstruct list_head all_channels;\n\tstruct list_head new_channels;\n\tint last_channel_index;\n\n\t \n\tspinlock_t all_channels_lock;\n};\n\n \n#define PPP_PROTO(skb)\tget_unaligned_be16((skb)->data)\n\n \n#define PPP_MAX_RQLEN\t32\n\n \n#define PPP_MP_MAX_QLEN\t128\n\n \n#define B\t0x80\t\t \n#define E\t0x40\t\t \n\n \n#define seq_before(a, b)\t((s32)((a) - (b)) < 0)\n#define seq_after(a, b)\t\t((s32)((a) - (b)) > 0)\n\n \nstatic int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,\n\t\t\tstruct file *file, unsigned int cmd, unsigned long arg);\nstatic void ppp_xmit_process(struct ppp *ppp, struct sk_buff *skb);\nstatic void ppp_send_frame(struct ppp *ppp, struct sk_buff *skb);\nstatic void ppp_push(struct ppp *ppp);\nstatic void ppp_channel_push(struct channel *pch);\nstatic void ppp_receive_frame(struct ppp *ppp, struct sk_buff *skb,\n\t\t\t      struct channel *pch);\nstatic void ppp_receive_error(struct ppp *ppp);\nstatic void ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb);\nstatic struct sk_buff *ppp_decompress_frame(struct ppp *ppp,\n\t\t\t\t\t    struct sk_buff *skb);\n#ifdef CONFIG_PPP_MULTILINK\nstatic void ppp_receive_mp_frame(struct ppp *ppp, struct sk_buff *skb,\n\t\t\t\tstruct channel *pch);\nstatic void ppp_mp_insert(struct ppp *ppp, struct sk_buff *skb);\nstatic struct sk_buff *ppp_mp_reconstruct(struct ppp *ppp);\nstatic int ppp_mp_explode(struct ppp *ppp, struct sk_buff *skb);\n#endif  \nstatic int ppp_set_compress(struct ppp *ppp, struct ppp_option_data *data);\nstatic void ppp_ccp_peek(struct ppp *ppp, struct sk_buff *skb, int inbound);\nstatic void ppp_ccp_closed(struct ppp *ppp);\nstatic struct compressor *find_compressor(int type);\nstatic void ppp_get_stats(struct ppp *ppp, struct ppp_stats *st);\nstatic int ppp_create_interface(struct net *net, struct file *file, int *unit);\nstatic void init_ppp_file(struct ppp_file *pf, int kind);\nstatic void ppp_destroy_interface(struct ppp *ppp);\nstatic struct ppp *ppp_find_unit(struct ppp_net *pn, int unit);\nstatic struct channel *ppp_find_channel(struct ppp_net *pn, int unit);\nstatic int ppp_connect_channel(struct channel *pch, int unit);\nstatic int ppp_disconnect_channel(struct channel *pch);\nstatic void ppp_destroy_channel(struct channel *pch);\nstatic int unit_get(struct idr *p, void *ptr, int min);\nstatic int unit_set(struct idr *p, void *ptr, int n);\nstatic void unit_put(struct idr *p, int n);\nstatic void *unit_find(struct idr *p, int n);\nstatic void ppp_setup(struct net_device *dev);\n\nstatic const struct net_device_ops ppp_netdev_ops;\n\nstatic struct class *ppp_class;\n\n \nstatic inline struct ppp_net *ppp_pernet(struct net *net)\n{\n\treturn net_generic(net, ppp_net_id);\n}\n\n \nstatic inline int proto_to_npindex(int proto)\n{\n\tswitch (proto) {\n\tcase PPP_IP:\n\t\treturn NP_IP;\n\tcase PPP_IPV6:\n\t\treturn NP_IPV6;\n\tcase PPP_IPX:\n\t\treturn NP_IPX;\n\tcase PPP_AT:\n\t\treturn NP_AT;\n\tcase PPP_MPLS_UC:\n\t\treturn NP_MPLS_UC;\n\tcase PPP_MPLS_MC:\n\t\treturn NP_MPLS_MC;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic const int npindex_to_proto[NUM_NP] = {\n\tPPP_IP,\n\tPPP_IPV6,\n\tPPP_IPX,\n\tPPP_AT,\n\tPPP_MPLS_UC,\n\tPPP_MPLS_MC,\n};\n\n \nstatic inline int ethertype_to_npindex(int ethertype)\n{\n\tswitch (ethertype) {\n\tcase ETH_P_IP:\n\t\treturn NP_IP;\n\tcase ETH_P_IPV6:\n\t\treturn NP_IPV6;\n\tcase ETH_P_IPX:\n\t\treturn NP_IPX;\n\tcase ETH_P_PPPTALK:\n\tcase ETH_P_ATALK:\n\t\treturn NP_AT;\n\tcase ETH_P_MPLS_UC:\n\t\treturn NP_MPLS_UC;\n\tcase ETH_P_MPLS_MC:\n\t\treturn NP_MPLS_MC;\n\t}\n\treturn -1;\n}\n\n \nstatic const int npindex_to_ethertype[NUM_NP] = {\n\tETH_P_IP,\n\tETH_P_IPV6,\n\tETH_P_IPX,\n\tETH_P_PPPTALK,\n\tETH_P_MPLS_UC,\n\tETH_P_MPLS_MC,\n};\n\n \n#define ppp_xmit_lock(ppp)\tspin_lock_bh(&(ppp)->wlock)\n#define ppp_xmit_unlock(ppp)\tspin_unlock_bh(&(ppp)->wlock)\n#define ppp_recv_lock(ppp)\tspin_lock_bh(&(ppp)->rlock)\n#define ppp_recv_unlock(ppp)\tspin_unlock_bh(&(ppp)->rlock)\n#define ppp_lock(ppp)\t\tdo { ppp_xmit_lock(ppp); \\\n\t\t\t\t     ppp_recv_lock(ppp); } while (0)\n#define ppp_unlock(ppp)\t\tdo { ppp_recv_unlock(ppp); \\\n\t\t\t\t     ppp_xmit_unlock(ppp); } while (0)\n\n \nstatic int ppp_open(struct inode *inode, struct file *file)\n{\n\t \n\tif (!ns_capable(file->f_cred->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}\n\nstatic int ppp_release(struct inode *unused, struct file *file)\n{\n\tstruct ppp_file *pf = file->private_data;\n\tstruct ppp *ppp;\n\n\tif (pf) {\n\t\tfile->private_data = NULL;\n\t\tif (pf->kind == INTERFACE) {\n\t\t\tppp = PF_TO_PPP(pf);\n\t\t\trtnl_lock();\n\t\t\tif (file == ppp->owner)\n\t\t\t\tunregister_netdevice(ppp->dev);\n\t\t\trtnl_unlock();\n\t\t}\n\t\tif (refcount_dec_and_test(&pf->refcnt)) {\n\t\t\tswitch (pf->kind) {\n\t\t\tcase INTERFACE:\n\t\t\t\tppp_destroy_interface(PF_TO_PPP(pf));\n\t\t\t\tbreak;\n\t\t\tcase CHANNEL:\n\t\t\t\tppp_destroy_channel(PF_TO_CHANNEL(pf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ssize_t ppp_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ppp_file *pf = file->private_data;\n\tDECLARE_WAITQUEUE(wait, current);\n\tssize_t ret;\n\tstruct sk_buff *skb = NULL;\n\tstruct iovec iov;\n\tstruct iov_iter to;\n\n\tret = count;\n\n\tif (!pf)\n\t\treturn -ENXIO;\n\tadd_wait_queue(&pf->rwait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&pf->rq);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (pf->dead)\n\t\t\tbreak;\n\t\tif (pf->kind == INTERFACE) {\n\t\t\t \n\t\t\tstruct ppp *ppp = PF_TO_PPP(pf);\n\n\t\t\tppp_recv_lock(ppp);\n\t\t\tif (ppp->n_channels == 0 &&\n\t\t\t    (ppp->flags & SC_LOOP_TRAFFIC) == 0) {\n\t\t\t\tppp_recv_unlock(ppp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tppp_recv_unlock(ppp);\n\t\t}\n\t\tret = -EAGAIN;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&pf->rwait, &wait);\n\n\tif (!skb)\n\t\tgoto out;\n\n\tret = -EOVERFLOW;\n\tif (skb->len > count)\n\t\tgoto outf;\n\tret = -EFAULT;\n\tiov.iov_base = buf;\n\tiov.iov_len = count;\n\tiov_iter_init(&to, ITER_DEST, &iov, 1, count);\n\tif (skb_copy_datagram_iter(skb, 0, &to, skb->len))\n\t\tgoto outf;\n\tret = skb->len;\n\n outf:\n\tkfree_skb(skb);\n out:\n\treturn ret;\n}\n\nstatic ssize_t ppp_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ppp_file *pf = file->private_data;\n\tstruct sk_buff *skb;\n\tssize_t ret;\n\n\tif (!pf)\n\t\treturn -ENXIO;\n\t \n\tif (count < PPP_PROTO_LEN)\n\t\treturn -EINVAL;\n\tret = -ENOMEM;\n\tskb = alloc_skb(count + pf->hdrlen, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto out;\n\tskb_reserve(skb, pf->hdrlen);\n\tret = -EFAULT;\n\tif (copy_from_user(skb_put(skb, count), buf, count)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tswitch (pf->kind) {\n\tcase INTERFACE:\n\t\tppp_xmit_process(PF_TO_PPP(pf), skb);\n\t\tbreak;\n\tcase CHANNEL:\n\t\tskb_queue_tail(&pf->xq, skb);\n\t\tppp_channel_push(PF_TO_CHANNEL(pf));\n\t\tbreak;\n\t}\n\n\tret = count;\n\n out:\n\treturn ret;\n}\n\n \nstatic __poll_t ppp_poll(struct file *file, poll_table *wait)\n{\n\tstruct ppp_file *pf = file->private_data;\n\t__poll_t mask;\n\n\tif (!pf)\n\t\treturn 0;\n\tpoll_wait(file, &pf->rwait, wait);\n\tmask = EPOLLOUT | EPOLLWRNORM;\n\tif (skb_peek(&pf->rq))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (pf->dead)\n\t\tmask |= EPOLLHUP;\n\telse if (pf->kind == INTERFACE) {\n\t\t \n\t\tstruct ppp *ppp = PF_TO_PPP(pf);\n\n\t\tppp_recv_lock(ppp);\n\t\tif (ppp->n_channels == 0 &&\n\t\t    (ppp->flags & SC_LOOP_TRAFFIC) == 0)\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t\tppp_recv_unlock(ppp);\n\t}\n\n\treturn mask;\n}\n\n#ifdef CONFIG_PPP_FILTER\nstatic struct bpf_prog *get_filter(struct sock_fprog *uprog)\n{\n\tstruct sock_fprog_kern fprog;\n\tstruct bpf_prog *res = NULL;\n\tint err;\n\n\tif (!uprog->len)\n\t\treturn NULL;\n\n\t \n\tfprog.len = uprog->len;\n\tfprog.filter = memdup_user(uprog->filter,\n\t\t\t\t   uprog->len * sizeof(struct sock_filter));\n\tif (IS_ERR(fprog.filter))\n\t\treturn ERR_CAST(fprog.filter);\n\n\terr = bpf_prog_create(&res, &fprog);\n\tkfree(fprog.filter);\n\n\treturn err ? ERR_PTR(err) : res;\n}\n\nstatic struct bpf_prog *ppp_get_filter(struct sock_fprog __user *p)\n{\n\tstruct sock_fprog uprog;\n\n\tif (copy_from_user(&uprog, p, sizeof(struct sock_fprog)))\n\t\treturn ERR_PTR(-EFAULT);\n\treturn get_filter(&uprog);\n}\n\n#ifdef CONFIG_COMPAT\nstruct sock_fprog32 {\n\tunsigned short len;\n\tcompat_caddr_t filter;\n};\n\n#define PPPIOCSPASS32\t\t_IOW('t', 71, struct sock_fprog32)\n#define PPPIOCSACTIVE32\t\t_IOW('t', 70, struct sock_fprog32)\n\nstatic struct bpf_prog *compat_ppp_get_filter(struct sock_fprog32 __user *p)\n{\n\tstruct sock_fprog32 uprog32;\n\tstruct sock_fprog uprog;\n\n\tif (copy_from_user(&uprog32, p, sizeof(struct sock_fprog32)))\n\t\treturn ERR_PTR(-EFAULT);\n\tuprog.len = uprog32.len;\n\tuprog.filter = compat_ptr(uprog32.filter);\n\treturn get_filter(&uprog);\n}\n#endif\n#endif\n\n \nstatic int ppp_bridge_channels(struct channel *pch, struct channel *pchb)\n{\n\twrite_lock_bh(&pch->upl);\n\tif (pch->ppp ||\n\t    rcu_dereference_protected(pch->bridge, lockdep_is_held(&pch->upl))) {\n\t\twrite_unlock_bh(&pch->upl);\n\t\treturn -EALREADY;\n\t}\n\trefcount_inc(&pchb->file.refcnt);\n\trcu_assign_pointer(pch->bridge, pchb);\n\twrite_unlock_bh(&pch->upl);\n\n\twrite_lock_bh(&pchb->upl);\n\tif (pchb->ppp ||\n\t    rcu_dereference_protected(pchb->bridge, lockdep_is_held(&pchb->upl))) {\n\t\twrite_unlock_bh(&pchb->upl);\n\t\tgoto err_unset;\n\t}\n\trefcount_inc(&pch->file.refcnt);\n\trcu_assign_pointer(pchb->bridge, pch);\n\twrite_unlock_bh(&pchb->upl);\n\n\treturn 0;\n\nerr_unset:\n\twrite_lock_bh(&pch->upl);\n\t \n\tpchb = rcu_dereference_protected(pch->bridge, lockdep_is_held(&pch->upl));\n\tRCU_INIT_POINTER(pch->bridge, NULL);\n\twrite_unlock_bh(&pch->upl);\n\tsynchronize_rcu();\n\n\tif (pchb)\n\t\tif (refcount_dec_and_test(&pchb->file.refcnt))\n\t\t\tppp_destroy_channel(pchb);\n\n\treturn -EALREADY;\n}\n\nstatic int ppp_unbridge_channels(struct channel *pch)\n{\n\tstruct channel *pchb, *pchbb;\n\n\twrite_lock_bh(&pch->upl);\n\tpchb = rcu_dereference_protected(pch->bridge, lockdep_is_held(&pch->upl));\n\tif (!pchb) {\n\t\twrite_unlock_bh(&pch->upl);\n\t\treturn -EINVAL;\n\t}\n\tRCU_INIT_POINTER(pch->bridge, NULL);\n\twrite_unlock_bh(&pch->upl);\n\n\t \n\twrite_lock_bh(&pchb->upl);\n\tpchbb = rcu_dereference_protected(pchb->bridge, lockdep_is_held(&pchb->upl));\n\tif (pchbb == pch)\n\t\tRCU_INIT_POINTER(pchb->bridge, NULL);\n\twrite_unlock_bh(&pchb->upl);\n\n\tsynchronize_rcu();\n\n\tif (pchbb == pch)\n\t\tif (refcount_dec_and_test(&pch->file.refcnt))\n\t\t\tppp_destroy_channel(pch);\n\n\tif (refcount_dec_and_test(&pchb->file.refcnt))\n\t\tppp_destroy_channel(pchb);\n\n\treturn 0;\n}\n\nstatic long ppp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct ppp_file *pf;\n\tstruct ppp *ppp;\n\tint err = -EFAULT, val, val2, i;\n\tstruct ppp_idle32 idle32;\n\tstruct ppp_idle64 idle64;\n\tstruct npioctl npi;\n\tint unit, cflags;\n\tstruct slcompress *vj;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\tmutex_lock(&ppp_mutex);\n\n\tpf = file->private_data;\n\tif (!pf) {\n\t\terr = ppp_unattached_ioctl(current->nsproxy->net_ns,\n\t\t\t\t\t   pf, file, cmd, arg);\n\t\tgoto out;\n\t}\n\n\tif (cmd == PPPIOCDETACH) {\n\t\t \n\t\tpr_warn_once(\"%s (%d) used obsolete PPPIOCDETACH ioctl\\n\",\n\t\t\t     current->comm, current->pid);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (pf->kind == CHANNEL) {\n\t\tstruct channel *pch, *pchb;\n\t\tstruct ppp_channel *chan;\n\t\tstruct ppp_net *pn;\n\n\t\tpch = PF_TO_CHANNEL(pf);\n\n\t\tswitch (cmd) {\n\t\tcase PPPIOCCONNECT:\n\t\t\tif (get_user(unit, p))\n\t\t\t\tbreak;\n\t\t\terr = ppp_connect_channel(pch, unit);\n\t\t\tbreak;\n\n\t\tcase PPPIOCDISCONN:\n\t\t\terr = ppp_disconnect_channel(pch);\n\t\t\tbreak;\n\n\t\tcase PPPIOCBRIDGECHAN:\n\t\t\tif (get_user(unit, p))\n\t\t\t\tbreak;\n\t\t\terr = -ENXIO;\n\t\t\tpn = ppp_pernet(current->nsproxy->net_ns);\n\t\t\tspin_lock_bh(&pn->all_channels_lock);\n\t\t\tpchb = ppp_find_channel(pn, unit);\n\t\t\t \n\t\t\tif (pchb)\n\t\t\t\trefcount_inc(&pchb->file.refcnt);\n\t\t\tspin_unlock_bh(&pn->all_channels_lock);\n\t\t\tif (!pchb)\n\t\t\t\tbreak;\n\t\t\terr = ppp_bridge_channels(pch, pchb);\n\t\t\t \n\t\t\tif (refcount_dec_and_test(&pchb->file.refcnt))\n\t\t\t\tppp_destroy_channel(pchb);\n\t\t\tbreak;\n\n\t\tcase PPPIOCUNBRIDGECHAN:\n\t\t\terr = ppp_unbridge_channels(pch);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdown_read(&pch->chan_sem);\n\t\t\tchan = pch->chan;\n\t\t\terr = -ENOTTY;\n\t\t\tif (chan && chan->ops->ioctl)\n\t\t\t\terr = chan->ops->ioctl(chan, cmd, arg);\n\t\t\tup_read(&pch->chan_sem);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (pf->kind != INTERFACE) {\n\t\t \n\t\tpr_err(\"PPP: not interface or channel??\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tppp = PF_TO_PPP(pf);\n\tswitch (cmd) {\n\tcase PPPIOCSMRU:\n\t\tif (get_user(val, p))\n\t\t\tbreak;\n\t\tppp->mru = val;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSFLAGS:\n\t\tif (get_user(val, p))\n\t\t\tbreak;\n\t\tppp_lock(ppp);\n\t\tcflags = ppp->flags & ~val;\n#ifdef CONFIG_PPP_MULTILINK\n\t\tif (!(ppp->flags & SC_MULTILINK) && (val & SC_MULTILINK))\n\t\t\tppp->nextseq = 0;\n#endif\n\t\tppp->flags = val & SC_FLAG_BITS;\n\t\tppp_unlock(ppp);\n\t\tif (cflags & SC_CCP_OPEN)\n\t\t\tppp_ccp_closed(ppp);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGFLAGS:\n\t\tval = ppp->flags | ppp->xstate | ppp->rstate;\n\t\tif (put_user(val, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSCOMPRESS:\n\t{\n\t\tstruct ppp_option_data data;\n\t\tif (copy_from_user(&data, argp, sizeof(data)))\n\t\t\terr = -EFAULT;\n\t\telse\n\t\t\terr = ppp_set_compress(ppp, &data);\n\t\tbreak;\n\t}\n\tcase PPPIOCGUNIT:\n\t\tif (put_user(ppp->file.index, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSDEBUG:\n\t\tif (get_user(val, p))\n\t\t\tbreak;\n\t\tppp->debug = val;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGDEBUG:\n\t\tif (put_user(ppp->debug, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGIDLE32:\n                idle32.xmit_idle = (jiffies - ppp->last_xmit) / HZ;\n                idle32.recv_idle = (jiffies - ppp->last_recv) / HZ;\n                if (copy_to_user(argp, &idle32, sizeof(idle32)))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGIDLE64:\n\t\tidle64.xmit_idle = (jiffies - ppp->last_xmit) / HZ;\n\t\tidle64.recv_idle = (jiffies - ppp->last_recv) / HZ;\n\t\tif (copy_to_user(argp, &idle64, sizeof(idle64)))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSMAXCID:\n\t\tif (get_user(val, p))\n\t\t\tbreak;\n\t\tval2 = 15;\n\t\tif ((val >> 16) != 0) {\n\t\t\tval2 = val >> 16;\n\t\t\tval &= 0xffff;\n\t\t}\n\t\tvj = slhc_init(val2+1, val+1);\n\t\tif (IS_ERR(vj)) {\n\t\t\terr = PTR_ERR(vj);\n\t\t\tbreak;\n\t\t}\n\t\tppp_lock(ppp);\n\t\tif (ppp->vj)\n\t\t\tslhc_free(ppp->vj);\n\t\tppp->vj = vj;\n\t\tppp_unlock(ppp);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGNPMODE:\n\tcase PPPIOCSNPMODE:\n\t\tif (copy_from_user(&npi, argp, sizeof(npi)))\n\t\t\tbreak;\n\t\terr = proto_to_npindex(npi.protocol);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\ti = err;\n\t\tif (cmd == PPPIOCGNPMODE) {\n\t\t\terr = -EFAULT;\n\t\t\tnpi.mode = ppp->npmode[i];\n\t\t\tif (copy_to_user(argp, &npi, sizeof(npi)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tppp->npmode[i] = npi.mode;\n\t\t\t \n\t\t\tnetif_wake_queue(ppp->dev);\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\n#ifdef CONFIG_PPP_FILTER\n\tcase PPPIOCSPASS:\n\tcase PPPIOCSACTIVE:\n\t{\n\t\tstruct bpf_prog *filter = ppp_get_filter(argp);\n\t\tstruct bpf_prog **which;\n\n\t\tif (IS_ERR(filter)) {\n\t\t\terr = PTR_ERR(filter);\n\t\t\tbreak;\n\t\t}\n\t\tif (cmd == PPPIOCSPASS)\n\t\t\twhich = &ppp->pass_filter;\n\t\telse\n\t\t\twhich = &ppp->active_filter;\n\t\tppp_lock(ppp);\n\t\tif (*which)\n\t\t\tbpf_prog_destroy(*which);\n\t\t*which = filter;\n\t\tppp_unlock(ppp);\n\t\terr = 0;\n\t\tbreak;\n\t}\n#endif  \n\n#ifdef CONFIG_PPP_MULTILINK\n\tcase PPPIOCSMRRU:\n\t\tif (get_user(val, p))\n\t\t\tbreak;\n\t\tppp_recv_lock(ppp);\n\t\tppp->mrru = val;\n\t\tppp_recv_unlock(ppp);\n\t\terr = 0;\n\t\tbreak;\n#endif  \n\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\nout:\n\tmutex_unlock(&ppp_mutex);\n\n\treturn err;\n}\n\n#ifdef CONFIG_COMPAT\nstruct ppp_option_data32 {\n\tcompat_uptr_t\t\tptr;\n\tu32\t\t\tlength;\n\tcompat_int_t\t\ttransmit;\n};\n#define PPPIOCSCOMPRESS32\t_IOW('t', 77, struct ppp_option_data32)\n\nstatic long ppp_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct ppp_file *pf;\n\tint err = -ENOIOCTLCMD;\n\tvoid __user *argp = (void __user *)arg;\n\n\tmutex_lock(&ppp_mutex);\n\n\tpf = file->private_data;\n\tif (pf && pf->kind == INTERFACE) {\n\t\tstruct ppp *ppp = PF_TO_PPP(pf);\n\t\tswitch (cmd) {\n#ifdef CONFIG_PPP_FILTER\n\t\tcase PPPIOCSPASS32:\n\t\tcase PPPIOCSACTIVE32:\n\t\t{\n\t\t\tstruct bpf_prog *filter = compat_ppp_get_filter(argp);\n\t\t\tstruct bpf_prog **which;\n\n\t\t\tif (IS_ERR(filter)) {\n\t\t\t\terr = PTR_ERR(filter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cmd == PPPIOCSPASS32)\n\t\t\t\twhich = &ppp->pass_filter;\n\t\t\telse\n\t\t\t\twhich = &ppp->active_filter;\n\t\t\tppp_lock(ppp);\n\t\t\tif (*which)\n\t\t\t\tbpf_prog_destroy(*which);\n\t\t\t*which = filter;\n\t\t\tppp_unlock(ppp);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n#endif  \n\t\tcase PPPIOCSCOMPRESS32:\n\t\t{\n\t\t\tstruct ppp_option_data32 data32;\n\t\t\tif (copy_from_user(&data32, argp, sizeof(data32))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t} else {\n\t\t\t\tstruct ppp_option_data data = {\n\t\t\t\t\t.ptr = compat_ptr(data32.ptr),\n\t\t\t\t\t.length = data32.length,\n\t\t\t\t\t.transmit = data32.transmit\n\t\t\t\t};\n\t\t\t\terr = ppp_set_compress(ppp, &data);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ppp_mutex);\n\n\t \n\tif (err == -ENOIOCTLCMD)\n\t\terr = ppp_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\n\n\treturn err;\n}\n#endif\n\nstatic int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,\n\t\t\tstruct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint unit, err = -EFAULT;\n\tstruct ppp *ppp;\n\tstruct channel *chan;\n\tstruct ppp_net *pn;\n\tint __user *p = (int __user *)arg;\n\n\tswitch (cmd) {\n\tcase PPPIOCNEWUNIT:\n\t\t \n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\terr = ppp_create_interface(net, file, &unit);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\terr = -EFAULT;\n\t\tif (put_user(unit, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCATTACH:\n\t\t \n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\terr = -ENXIO;\n\t\tpn = ppp_pernet(net);\n\t\tmutex_lock(&pn->all_ppp_mutex);\n\t\tppp = ppp_find_unit(pn, unit);\n\t\tif (ppp) {\n\t\t\trefcount_inc(&ppp->file.refcnt);\n\t\t\tfile->private_data = &ppp->file;\n\t\t\terr = 0;\n\t\t}\n\t\tmutex_unlock(&pn->all_ppp_mutex);\n\t\tbreak;\n\n\tcase PPPIOCATTCHAN:\n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\terr = -ENXIO;\n\t\tpn = ppp_pernet(net);\n\t\tspin_lock_bh(&pn->all_channels_lock);\n\t\tchan = ppp_find_channel(pn, unit);\n\t\tif (chan) {\n\t\t\trefcount_inc(&chan->file.refcnt);\n\t\t\tfile->private_data = &chan->file;\n\t\t\terr = 0;\n\t\t}\n\t\tspin_unlock_bh(&pn->all_channels_lock);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\n\treturn err;\n}\n\nstatic const struct file_operations ppp_device_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= ppp_read,\n\t.write\t\t= ppp_write,\n\t.poll\t\t= ppp_poll,\n\t.unlocked_ioctl\t= ppp_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= ppp_compat_ioctl,\n#endif\n\t.open\t\t= ppp_open,\n\t.release\t= ppp_release,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic __net_init int ppp_init_net(struct net *net)\n{\n\tstruct ppp_net *pn = net_generic(net, ppp_net_id);\n\n\tidr_init(&pn->units_idr);\n\tmutex_init(&pn->all_ppp_mutex);\n\n\tINIT_LIST_HEAD(&pn->all_channels);\n\tINIT_LIST_HEAD(&pn->new_channels);\n\n\tspin_lock_init(&pn->all_channels_lock);\n\n\treturn 0;\n}\n\nstatic __net_exit void ppp_exit_net(struct net *net)\n{\n\tstruct ppp_net *pn = net_generic(net, ppp_net_id);\n\tstruct net_device *dev;\n\tstruct net_device *aux;\n\tstruct ppp *ppp;\n\tLIST_HEAD(list);\n\tint id;\n\n\trtnl_lock();\n\tfor_each_netdev_safe(net, dev, aux) {\n\t\tif (dev->netdev_ops == &ppp_netdev_ops)\n\t\t\tunregister_netdevice_queue(dev, &list);\n\t}\n\n\tidr_for_each_entry(&pn->units_idr, ppp, id)\n\t\t \n\t\tif (!net_eq(dev_net(ppp->dev), net))\n\t\t\tunregister_netdevice_queue(ppp->dev, &list);\n\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n\n\tmutex_destroy(&pn->all_ppp_mutex);\n\tidr_destroy(&pn->units_idr);\n\tWARN_ON_ONCE(!list_empty(&pn->all_channels));\n\tWARN_ON_ONCE(!list_empty(&pn->new_channels));\n}\n\nstatic struct pernet_operations ppp_net_ops = {\n\t.init = ppp_init_net,\n\t.exit = ppp_exit_net,\n\t.id   = &ppp_net_id,\n\t.size = sizeof(struct ppp_net),\n};\n\nstatic int ppp_unit_register(struct ppp *ppp, int unit, bool ifname_is_set)\n{\n\tstruct ppp_net *pn = ppp_pernet(ppp->ppp_net);\n\tint ret;\n\n\tmutex_lock(&pn->all_ppp_mutex);\n\n\tif (unit < 0) {\n\t\tret = unit_get(&pn->units_idr, ppp, 0);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tif (!ifname_is_set) {\n\t\t\twhile (1) {\n\t\t\t\tsnprintf(ppp->dev->name, IFNAMSIZ, \"ppp%i\", ret);\n\t\t\t\tif (!netdev_name_in_use(ppp->ppp_net, ppp->dev->name))\n\t\t\t\t\tbreak;\n\t\t\t\tunit_put(&pn->units_idr, ret);\n\t\t\t\tret = unit_get(&pn->units_idr, ppp, ret + 1);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (unit_find(&pn->units_idr, unit)) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto err;\n\t\t}\n\t\tret = unit_set(&pn->units_idr, ppp, unit);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tret = -EEXIST;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tppp->file.index = ret;\n\n\tif (!ifname_is_set)\n\t\tsnprintf(ppp->dev->name, IFNAMSIZ, \"ppp%i\", ppp->file.index);\n\n\tmutex_unlock(&pn->all_ppp_mutex);\n\n\tret = register_netdevice(ppp->dev);\n\tif (ret < 0)\n\t\tgoto err_unit;\n\n\tatomic_inc(&ppp_unit_count);\n\n\treturn 0;\n\nerr_unit:\n\tmutex_lock(&pn->all_ppp_mutex);\n\tunit_put(&pn->units_idr, ppp->file.index);\nerr:\n\tmutex_unlock(&pn->all_ppp_mutex);\n\n\treturn ret;\n}\n\nstatic int ppp_dev_configure(struct net *src_net, struct net_device *dev,\n\t\t\t     const struct ppp_config *conf)\n{\n\tstruct ppp *ppp = netdev_priv(dev);\n\tint indx;\n\tint err;\n\tint cpu;\n\n\tppp->dev = dev;\n\tppp->ppp_net = src_net;\n\tppp->mru = PPP_MRU;\n\tppp->owner = conf->file;\n\n\tinit_ppp_file(&ppp->file, INTERFACE);\n\tppp->file.hdrlen = PPP_HDRLEN - 2;  \n\n\tfor (indx = 0; indx < NUM_NP; ++indx)\n\t\tppp->npmode[indx] = NPMODE_PASS;\n\tINIT_LIST_HEAD(&ppp->channels);\n\tspin_lock_init(&ppp->rlock);\n\tspin_lock_init(&ppp->wlock);\n\n\tppp->xmit_recursion = alloc_percpu(int);\n\tif (!ppp->xmit_recursion) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tfor_each_possible_cpu(cpu)\n\t\t(*per_cpu_ptr(ppp->xmit_recursion, cpu)) = 0;\n\n#ifdef CONFIG_PPP_MULTILINK\n\tppp->minseq = -1;\n\tskb_queue_head_init(&ppp->mrq);\n#endif  \n#ifdef CONFIG_PPP_FILTER\n\tppp->pass_filter = NULL;\n\tppp->active_filter = NULL;\n#endif  \n\n\terr = ppp_unit_register(ppp, conf->unit, conf->ifname_is_set);\n\tif (err < 0)\n\t\tgoto err2;\n\n\tconf->file->private_data = &ppp->file;\n\n\treturn 0;\nerr2:\n\tfree_percpu(ppp->xmit_recursion);\nerr1:\n\treturn err;\n}\n\nstatic const struct nla_policy ppp_nl_policy[IFLA_PPP_MAX + 1] = {\n\t[IFLA_PPP_DEV_FD]\t= { .type = NLA_S32 },\n};\n\nstatic int ppp_nl_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tif (!data[IFLA_PPP_DEV_FD])\n\t\treturn -EINVAL;\n\tif (nla_get_s32(data[IFLA_PPP_DEV_FD]) < 0)\n\t\treturn -EBADF;\n\n\treturn 0;\n}\n\nstatic int ppp_nl_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t  struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ppp_config conf = {\n\t\t.unit = -1,\n\t\t.ifname_is_set = true,\n\t};\n\tstruct file *file;\n\tint err;\n\n\tfile = fget(nla_get_s32(data[IFLA_PPP_DEV_FD]));\n\tif (!file)\n\t\treturn -EBADF;\n\n\t \n\tif (!mutex_trylock(&ppp_mutex)) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (file->f_op != &ppp_device_fops || file->private_data) {\n\t\terr = -EBADF;\n\t\tgoto out_unlock;\n\t}\n\n\tconf.file = file;\n\n\t \n\tif (!tb[IFLA_IFNAME] || !nla_len(tb[IFLA_IFNAME]) || !*(char *)nla_data(tb[IFLA_IFNAME]))\n\t\tconf.ifname_is_set = false;\n\n\terr = ppp_dev_configure(src_net, dev, &conf);\n\nout_unlock:\n\tmutex_unlock(&ppp_mutex);\nout:\n\tfput(file);\n\n\treturn err;\n}\n\nstatic void ppp_nl_dellink(struct net_device *dev, struct list_head *head)\n{\n\tunregister_netdevice_queue(dev, head);\n}\n\nstatic size_t ppp_nl_get_size(const struct net_device *dev)\n{\n\treturn 0;\n}\n\nstatic int ppp_nl_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\treturn 0;\n}\n\nstatic struct net *ppp_nl_get_link_net(const struct net_device *dev)\n{\n\tstruct ppp *ppp = netdev_priv(dev);\n\n\treturn ppp->ppp_net;\n}\n\nstatic struct rtnl_link_ops ppp_link_ops __read_mostly = {\n\t.kind\t\t= \"ppp\",\n\t.maxtype\t= IFLA_PPP_MAX,\n\t.policy\t\t= ppp_nl_policy,\n\t.priv_size\t= sizeof(struct ppp),\n\t.setup\t\t= ppp_setup,\n\t.validate\t= ppp_nl_validate,\n\t.newlink\t= ppp_nl_newlink,\n\t.dellink\t= ppp_nl_dellink,\n\t.get_size\t= ppp_nl_get_size,\n\t.fill_info\t= ppp_nl_fill_info,\n\t.get_link_net\t= ppp_nl_get_link_net,\n};\n\n#define PPP_MAJOR\t108\n\n \nstatic int __init ppp_init(void)\n{\n\tint err;\n\n\tpr_info(\"PPP generic driver version \" PPP_VERSION \"\\n\");\n\n\terr = register_pernet_device(&ppp_net_ops);\n\tif (err) {\n\t\tpr_err(\"failed to register PPP pernet device (%d)\\n\", err);\n\t\tgoto out;\n\t}\n\n\terr = register_chrdev(PPP_MAJOR, \"ppp\", &ppp_device_fops);\n\tif (err) {\n\t\tpr_err(\"failed to register PPP device (%d)\\n\", err);\n\t\tgoto out_net;\n\t}\n\n\tppp_class = class_create(\"ppp\");\n\tif (IS_ERR(ppp_class)) {\n\t\terr = PTR_ERR(ppp_class);\n\t\tgoto out_chrdev;\n\t}\n\n\terr = rtnl_link_register(&ppp_link_ops);\n\tif (err) {\n\t\tpr_err(\"failed to register rtnetlink PPP handler\\n\");\n\t\tgoto out_class;\n\t}\n\n\t \n\tdevice_create(ppp_class, NULL, MKDEV(PPP_MAJOR, 0), NULL, \"ppp\");\n\n\treturn 0;\n\nout_class:\n\tclass_destroy(ppp_class);\nout_chrdev:\n\tunregister_chrdev(PPP_MAJOR, \"ppp\");\nout_net:\n\tunregister_pernet_device(&ppp_net_ops);\nout:\n\treturn err;\n}\n\n \nstatic netdev_tx_t\nppp_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ppp *ppp = netdev_priv(dev);\n\tint npi, proto;\n\tunsigned char *pp;\n\n\tnpi = ethertype_to_npindex(ntohs(skb->protocol));\n\tif (npi < 0)\n\t\tgoto outf;\n\n\t \n\tswitch (ppp->npmode[npi]) {\n\tcase NPMODE_PASS:\n\t\tbreak;\n\tcase NPMODE_QUEUE:\n\t\t \n\t\tgoto outf;\n\tcase NPMODE_DROP:\n\tcase NPMODE_ERROR:\n\t\tgoto outf;\n\t}\n\n\t \n\tif (skb_cow_head(skb, PPP_HDRLEN))\n\t\tgoto outf;\n\n\tpp = skb_push(skb, 2);\n\tproto = npindex_to_proto[npi];\n\tput_unaligned_be16(proto, pp);\n\n\tskb_scrub_packet(skb, !net_eq(ppp->ppp_net, dev_net(dev)));\n\tppp_xmit_process(ppp, skb);\n\n\treturn NETDEV_TX_OK;\n\n outf:\n\tkfree_skb(skb);\n\t++dev->stats.tx_dropped;\n\treturn NETDEV_TX_OK;\n}\n\nstatic int\nppp_net_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t       void __user *addr, int cmd)\n{\n\tstruct ppp *ppp = netdev_priv(dev);\n\tint err = -EFAULT;\n\tstruct ppp_stats stats;\n\tstruct ppp_comp_stats cstats;\n\tchar *vers;\n\n\tswitch (cmd) {\n\tcase SIOCGPPPSTATS:\n\t\tppp_get_stats(ppp, &stats);\n\t\tif (copy_to_user(addr, &stats, sizeof(stats)))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase SIOCGPPPCSTATS:\n\t\tmemset(&cstats, 0, sizeof(cstats));\n\t\tif (ppp->xc_state)\n\t\t\tppp->xcomp->comp_stat(ppp->xc_state, &cstats.c);\n\t\tif (ppp->rc_state)\n\t\t\tppp->rcomp->decomp_stat(ppp->rc_state, &cstats.d);\n\t\tif (copy_to_user(addr, &cstats, sizeof(cstats)))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase SIOCGPPPVER:\n\t\tvers = PPP_VERSION;\n\t\tif (copy_to_user(addr, vers, strlen(vers) + 1))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic void\nppp_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats64)\n{\n\tstruct ppp *ppp = netdev_priv(dev);\n\n\tppp_recv_lock(ppp);\n\tstats64->rx_packets = ppp->stats64.rx_packets;\n\tstats64->rx_bytes   = ppp->stats64.rx_bytes;\n\tppp_recv_unlock(ppp);\n\n\tppp_xmit_lock(ppp);\n\tstats64->tx_packets = ppp->stats64.tx_packets;\n\tstats64->tx_bytes   = ppp->stats64.tx_bytes;\n\tppp_xmit_unlock(ppp);\n\n\tstats64->rx_errors        = dev->stats.rx_errors;\n\tstats64->tx_errors        = dev->stats.tx_errors;\n\tstats64->rx_dropped       = dev->stats.rx_dropped;\n\tstats64->tx_dropped       = dev->stats.tx_dropped;\n\tstats64->rx_length_errors = dev->stats.rx_length_errors;\n}\n\nstatic int ppp_dev_init(struct net_device *dev)\n{\n\tstruct ppp *ppp;\n\n\tnetdev_lockdep_set_classes(dev);\n\n\tppp = netdev_priv(dev);\n\t \n\trefcount_inc(&ppp->file.refcnt);\n\n\treturn 0;\n}\n\nstatic void ppp_dev_uninit(struct net_device *dev)\n{\n\tstruct ppp *ppp = netdev_priv(dev);\n\tstruct ppp_net *pn = ppp_pernet(ppp->ppp_net);\n\n\tppp_lock(ppp);\n\tppp->closing = 1;\n\tppp_unlock(ppp);\n\n\tmutex_lock(&pn->all_ppp_mutex);\n\tunit_put(&pn->units_idr, ppp->file.index);\n\tmutex_unlock(&pn->all_ppp_mutex);\n\n\tppp->owner = NULL;\n\n\tppp->file.dead = 1;\n\twake_up_interruptible(&ppp->file.rwait);\n}\n\nstatic void ppp_dev_priv_destructor(struct net_device *dev)\n{\n\tstruct ppp *ppp;\n\n\tppp = netdev_priv(dev);\n\tif (refcount_dec_and_test(&ppp->file.refcnt))\n\t\tppp_destroy_interface(ppp);\n}\n\nstatic int ppp_fill_forward_path(struct net_device_path_ctx *ctx,\n\t\t\t\t struct net_device_path *path)\n{\n\tstruct ppp *ppp = netdev_priv(ctx->dev);\n\tstruct ppp_channel *chan;\n\tstruct channel *pch;\n\n\tif (ppp->flags & SC_MULTILINK)\n\t\treturn -EOPNOTSUPP;\n\n\tif (list_empty(&ppp->channels))\n\t\treturn -ENODEV;\n\n\tpch = list_first_entry(&ppp->channels, struct channel, clist);\n\tchan = pch->chan;\n\tif (!chan->ops->fill_forward_path)\n\t\treturn -EOPNOTSUPP;\n\n\treturn chan->ops->fill_forward_path(ctx, path, chan);\n}\n\nstatic const struct net_device_ops ppp_netdev_ops = {\n\t.ndo_init\t = ppp_dev_init,\n\t.ndo_uninit      = ppp_dev_uninit,\n\t.ndo_start_xmit  = ppp_start_xmit,\n\t.ndo_siocdevprivate = ppp_net_siocdevprivate,\n\t.ndo_get_stats64 = ppp_get_stats64,\n\t.ndo_fill_forward_path = ppp_fill_forward_path,\n};\n\nstatic struct device_type ppp_type = {\n\t.name = \"ppp\",\n};\n\nstatic void ppp_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &ppp_netdev_ops;\n\tSET_NETDEV_DEVTYPE(dev, &ppp_type);\n\n\tdev->features |= NETIF_F_LLTX;\n\n\tdev->hard_header_len = PPP_HDRLEN;\n\tdev->mtu = PPP_MRU;\n\tdev->addr_len = 0;\n\tdev->tx_queue_len = 3;\n\tdev->type = ARPHRD_PPP;\n\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\tdev->priv_destructor = ppp_dev_priv_destructor;\n\tnetif_keep_dst(dev);\n}\n\n \n\n \nstatic void __ppp_xmit_process(struct ppp *ppp, struct sk_buff *skb)\n{\n\tppp_xmit_lock(ppp);\n\tif (!ppp->closing) {\n\t\tppp_push(ppp);\n\n\t\tif (skb)\n\t\t\tskb_queue_tail(&ppp->file.xq, skb);\n\t\twhile (!ppp->xmit_pending &&\n\t\t       (skb = skb_dequeue(&ppp->file.xq)))\n\t\t\tppp_send_frame(ppp, skb);\n\t\t \n\t\tif (!ppp->xmit_pending && !skb_peek(&ppp->file.xq))\n\t\t\tnetif_wake_queue(ppp->dev);\n\t\telse\n\t\t\tnetif_stop_queue(ppp->dev);\n\t} else {\n\t\tkfree_skb(skb);\n\t}\n\tppp_xmit_unlock(ppp);\n}\n\nstatic void ppp_xmit_process(struct ppp *ppp, struct sk_buff *skb)\n{\n\tlocal_bh_disable();\n\n\tif (unlikely(*this_cpu_ptr(ppp->xmit_recursion)))\n\t\tgoto err;\n\n\t(*this_cpu_ptr(ppp->xmit_recursion))++;\n\t__ppp_xmit_process(ppp, skb);\n\t(*this_cpu_ptr(ppp->xmit_recursion))--;\n\n\tlocal_bh_enable();\n\n\treturn;\n\nerr:\n\tlocal_bh_enable();\n\n\tkfree_skb(skb);\n\n\tif (net_ratelimit())\n\t\tnetdev_err(ppp->dev, \"recursion detected\\n\");\n}\n\nstatic inline struct sk_buff *\npad_compress_skb(struct ppp *ppp, struct sk_buff *skb)\n{\n\tstruct sk_buff *new_skb;\n\tint len;\n\tint new_skb_size = ppp->dev->mtu +\n\t\tppp->xcomp->comp_extra + ppp->dev->hard_header_len;\n\tint compressor_skb_size = ppp->dev->mtu +\n\t\tppp->xcomp->comp_extra + PPP_HDRLEN;\n\tnew_skb = alloc_skb(new_skb_size, GFP_ATOMIC);\n\tif (!new_skb) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(ppp->dev, \"PPP: no memory (comp pkt)\\n\");\n\t\treturn NULL;\n\t}\n\tif (ppp->dev->hard_header_len > PPP_HDRLEN)\n\t\tskb_reserve(new_skb,\n\t\t\t    ppp->dev->hard_header_len - PPP_HDRLEN);\n\n\t \n\tlen = ppp->xcomp->compress(ppp->xc_state, skb->data - 2,\n\t\t\t\t   new_skb->data, skb->len + 2,\n\t\t\t\t   compressor_skb_size);\n\tif (len > 0 && (ppp->flags & SC_CCP_UP)) {\n\t\tconsume_skb(skb);\n\t\tskb = new_skb;\n\t\tskb_put(skb, len);\n\t\tskb_pull(skb, 2);\t \n\t} else if (len == 0) {\n\t\t \n\t\tconsume_skb(new_skb);\n\t\tnew_skb = skb;\n\t} else {\n\t\t \n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(ppp->dev, \"ppp: compressor dropped pkt\\n\");\n\t\tkfree_skb(skb);\n\t\tconsume_skb(new_skb);\n\t\tnew_skb = NULL;\n\t}\n\treturn new_skb;\n}\n\n \nstatic void\nppp_send_frame(struct ppp *ppp, struct sk_buff *skb)\n{\n\tint proto = PPP_PROTO(skb);\n\tstruct sk_buff *new_skb;\n\tint len;\n\tunsigned char *cp;\n\n\tskb->dev = ppp->dev;\n\n\tif (proto < 0x8000) {\n#ifdef CONFIG_PPP_FILTER\n\t\t \n\t\t \n\t\t*(u8 *)skb_push(skb, 2) = 1;\n\t\tif (ppp->pass_filter &&\n\t\t    bpf_prog_run(ppp->pass_filter, skb) == 0) {\n\t\t\tif (ppp->debug & 1)\n\t\t\t\tnetdev_printk(KERN_DEBUG, ppp->dev,\n\t\t\t\t\t      \"PPP: outbound frame \"\n\t\t\t\t\t      \"not passed\\n\");\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (!(ppp->active_filter &&\n\t\t      bpf_prog_run(ppp->active_filter, skb) == 0))\n\t\t\tppp->last_xmit = jiffies;\n\t\tskb_pull(skb, 2);\n#else\n\t\t \n\t\tppp->last_xmit = jiffies;\n#endif  \n\t}\n\n\t++ppp->stats64.tx_packets;\n\tppp->stats64.tx_bytes += skb->len - PPP_PROTO_LEN;\n\n\tswitch (proto) {\n\tcase PPP_IP:\n\t\tif (!ppp->vj || (ppp->flags & SC_COMP_TCP) == 0)\n\t\t\tbreak;\n\t\t \n\t\tnew_skb = alloc_skb(skb->len + ppp->dev->hard_header_len - 2,\n\t\t\t\t    GFP_ATOMIC);\n\t\tif (!new_skb) {\n\t\t\tnetdev_err(ppp->dev, \"PPP: no memory (VJ comp pkt)\\n\");\n\t\t\tgoto drop;\n\t\t}\n\t\tskb_reserve(new_skb, ppp->dev->hard_header_len - 2);\n\t\tcp = skb->data + 2;\n\t\tlen = slhc_compress(ppp->vj, cp, skb->len - 2,\n\t\t\t\t    new_skb->data + 2, &cp,\n\t\t\t\t    !(ppp->flags & SC_NO_TCP_CCID));\n\t\tif (cp == skb->data + 2) {\n\t\t\t \n\t\t\tconsume_skb(new_skb);\n\t\t} else {\n\t\t\tif (cp[0] & SL_TYPE_COMPRESSED_TCP) {\n\t\t\t\tproto = PPP_VJC_COMP;\n\t\t\t\tcp[0] &= ~SL_TYPE_COMPRESSED_TCP;\n\t\t\t} else {\n\t\t\t\tproto = PPP_VJC_UNCOMP;\n\t\t\t\tcp[0] = skb->data[2];\n\t\t\t}\n\t\t\tconsume_skb(skb);\n\t\t\tskb = new_skb;\n\t\t\tcp = skb_put(skb, len + 2);\n\t\t\tcp[0] = 0;\n\t\t\tcp[1] = proto;\n\t\t}\n\t\tbreak;\n\n\tcase PPP_CCP:\n\t\t \n\t\tppp_ccp_peek(ppp, skb, 0);\n\t\tbreak;\n\t}\n\n\t \n\tif ((ppp->xstate & SC_COMP_RUN) && ppp->xc_state &&\n\t    proto != PPP_LCP && proto != PPP_CCP) {\n\t\tif (!(ppp->flags & SC_CCP_UP) && (ppp->flags & SC_MUST_COMP)) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_err(ppp->dev,\n\t\t\t\t\t   \"ppp: compression required but \"\n\t\t\t\t\t   \"down - pkt dropped.\\n\");\n\t\t\tgoto drop;\n\t\t}\n\t\tskb = pad_compress_skb(ppp, skb);\n\t\tif (!skb)\n\t\t\tgoto drop;\n\t}\n\n\t \n\tif (ppp->flags & SC_LOOP_TRAFFIC) {\n\t\tif (ppp->file.rq.qlen > PPP_MAX_RQLEN)\n\t\t\tgoto drop;\n\t\tskb_queue_tail(&ppp->file.rq, skb);\n\t\twake_up_interruptible(&ppp->file.rwait);\n\t\treturn;\n\t}\n\n\tppp->xmit_pending = skb;\n\tppp_push(ppp);\n\treturn;\n\n drop:\n\tkfree_skb(skb);\n\t++ppp->dev->stats.tx_errors;\n}\n\n \nstatic void\nppp_push(struct ppp *ppp)\n{\n\tstruct list_head *list;\n\tstruct channel *pch;\n\tstruct sk_buff *skb = ppp->xmit_pending;\n\n\tif (!skb)\n\t\treturn;\n\n\tlist = &ppp->channels;\n\tif (list_empty(list)) {\n\t\t \n\t\tppp->xmit_pending = NULL;\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif ((ppp->flags & SC_MULTILINK) == 0) {\n\t\t \n\t\tlist = list->next;\n\t\tpch = list_entry(list, struct channel, clist);\n\n\t\tspin_lock(&pch->downl);\n\t\tif (pch->chan) {\n\t\t\tif (pch->chan->ops->start_xmit(pch->chan, skb))\n\t\t\t\tppp->xmit_pending = NULL;\n\t\t} else {\n\t\t\t \n\t\t\tkfree_skb(skb);\n\t\t\tppp->xmit_pending = NULL;\n\t\t}\n\t\tspin_unlock(&pch->downl);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPP_MULTILINK\n\t \n\tif (!ppp_mp_explode(ppp, skb))\n\t\treturn;\n#endif  \n\n\tppp->xmit_pending = NULL;\n\tkfree_skb(skb);\n}\n\n#ifdef CONFIG_PPP_MULTILINK\nstatic bool mp_protocol_compress __read_mostly = true;\nmodule_param(mp_protocol_compress, bool, 0644);\nMODULE_PARM_DESC(mp_protocol_compress,\n\t\t \"compress protocol id in multilink fragments\");\n\n \nstatic int ppp_mp_explode(struct ppp *ppp, struct sk_buff *skb)\n{\n\tint len, totlen;\n\tint i, bits, hdrlen, mtu;\n\tint flen;\n\tint navail, nfree, nzero;\n\tint nbigger;\n\tint totspeed;\n\tint totfree;\n\tunsigned char *p, *q;\n\tstruct list_head *list;\n\tstruct channel *pch;\n\tstruct sk_buff *frag;\n\tstruct ppp_channel *chan;\n\n\ttotspeed = 0;  \n\tnfree = 0;  \n\tnavail = 0;  \n\tnzero = 0;  \n\ttotfree = 0;  \n\n\thdrlen = (ppp->flags & SC_MP_XSHORTSEQ)? MPHDRLEN_SSN: MPHDRLEN;\n\ti = 0;\n\tlist_for_each_entry(pch, &ppp->channels, clist) {\n\t\tif (pch->chan) {\n\t\t\tpch->avail = 1;\n\t\t\tnavail++;\n\t\t\tpch->speed = pch->chan->speed;\n\t\t} else {\n\t\t\tpch->avail = 0;\n\t\t}\n\t\tif (pch->avail) {\n\t\t\tif (skb_queue_empty(&pch->file.xq) ||\n\t\t\t\t!pch->had_frag) {\n\t\t\t\t\tif (pch->speed == 0)\n\t\t\t\t\t\tnzero++;\n\t\t\t\t\telse\n\t\t\t\t\t\ttotspeed += pch->speed;\n\n\t\t\t\t\tpch->avail = 2;\n\t\t\t\t\t++nfree;\n\t\t\t\t\t++totfree;\n\t\t\t\t}\n\t\t\tif (!pch->had_frag && i < ppp->nxchan)\n\t\t\t\tppp->nxchan = i;\n\t\t}\n\t\t++i;\n\t}\n\t \n\tif (nfree == 0 || nfree < navail / 2)\n\t\treturn 0;  \n\n\t \n\tp = skb->data;\n\tlen = skb->len;\n\tif (*p == 0 && mp_protocol_compress) {\n\t\t++p;\n\t\t--len;\n\t}\n\n\ttotlen = len;\n\tnbigger = len % nfree;\n\n\t \n\tlist = &ppp->channels;\n\tfor (i = 0; i < ppp->nxchan; ++i) {\n\t\tlist = list->next;\n\t\tif (list == &ppp->channels) {\n\t\t\ti = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tbits = B;\n\twhile (len > 0) {\n\t\tlist = list->next;\n\t\tif (list == &ppp->channels) {\n\t\t\ti = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tpch = list_entry(list, struct channel, clist);\n\t\t++i;\n\t\tif (!pch->avail)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (pch->avail == 1) {\n\t\t\tif (nfree > 0)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tpch->avail = 1;\n\t\t}\n\n\t\t \n\t\tspin_lock(&pch->downl);\n\t\tif (pch->chan == NULL) {\n\t\t\t \n\t\t\tif (pch->speed == 0)\n\t\t\t\tnzero--;\n\t\t\telse\n\t\t\t\ttotspeed -= pch->speed;\n\n\t\t\tspin_unlock(&pch->downl);\n\t\t\tpch->avail = 0;\n\t\t\ttotlen = len;\n\t\t\ttotfree--;\n\t\t\tnfree--;\n\t\t\tif (--navail == 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tflen = len;\n\t\tif (nfree > 0) {\n\t\t\tif (pch->speed == 0) {\n\t\t\t\tflen = len/nfree;\n\t\t\t\tif (nbigger > 0) {\n\t\t\t\t\tflen++;\n\t\t\t\t\tnbigger--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflen = (((totfree - nzero)*(totlen + hdrlen*totfree)) /\n\t\t\t\t\t((totspeed*totfree)/pch->speed)) - hdrlen;\n\t\t\t\tif (nbigger > 0) {\n\t\t\t\t\tflen += ((totfree - nzero)*pch->speed)/totspeed;\n\t\t\t\t\tnbigger -= ((totfree - nzero)*pch->speed)/\n\t\t\t\t\t\t\ttotspeed;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnfree--;\n\t\t}\n\n\t\t \n\t\tif ((nfree <= 0) || (flen > len))\n\t\t\tflen = len;\n\t\t \n\t\tif (flen <= 0) {\n\t\t\tpch->avail = 2;\n\t\t\tspin_unlock(&pch->downl);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmtu = pch->chan->mtu - (hdrlen - 2);\n\t\tif (mtu < 4)\n\t\t\tmtu = 4;\n\t\tif (flen > mtu)\n\t\t\tflen = mtu;\n\t\tif (flen == len)\n\t\t\tbits |= E;\n\t\tfrag = alloc_skb(flen + hdrlen + (flen == 0), GFP_ATOMIC);\n\t\tif (!frag)\n\t\t\tgoto noskb;\n\t\tq = skb_put(frag, flen + hdrlen);\n\n\t\t \n\t\tput_unaligned_be16(PPP_MP, q);\n\t\tif (ppp->flags & SC_MP_XSHORTSEQ) {\n\t\t\tq[2] = bits + ((ppp->nxseq >> 8) & 0xf);\n\t\t\tq[3] = ppp->nxseq;\n\t\t} else {\n\t\t\tq[2] = bits;\n\t\t\tq[3] = ppp->nxseq >> 16;\n\t\t\tq[4] = ppp->nxseq >> 8;\n\t\t\tq[5] = ppp->nxseq;\n\t\t}\n\n\t\tmemcpy(q + hdrlen, p, flen);\n\n\t\t \n\t\tchan = pch->chan;\n\t\tif (!skb_queue_empty(&pch->file.xq) ||\n\t\t\t!chan->ops->start_xmit(chan, frag))\n\t\t\tskb_queue_tail(&pch->file.xq, frag);\n\t\tpch->had_frag = 1;\n\t\tp += flen;\n\t\tlen -= flen;\n\t\t++ppp->nxseq;\n\t\tbits = 0;\n\t\tspin_unlock(&pch->downl);\n\t}\n\tppp->nxchan = i;\n\n\treturn 1;\n\n noskb:\n\tspin_unlock(&pch->downl);\n\tif (ppp->debug & 1)\n\t\tnetdev_err(ppp->dev, \"PPP: no memory (fragment)\\n\");\n\t++ppp->dev->stats.tx_errors;\n\t++ppp->nxseq;\n\treturn 1;\t \n}\n#endif  \n\n \nstatic void __ppp_channel_push(struct channel *pch)\n{\n\tstruct sk_buff *skb;\n\tstruct ppp *ppp;\n\n\tspin_lock(&pch->downl);\n\tif (pch->chan) {\n\t\twhile (!skb_queue_empty(&pch->file.xq)) {\n\t\t\tskb = skb_dequeue(&pch->file.xq);\n\t\t\tif (!pch->chan->ops->start_xmit(pch->chan, skb)) {\n\t\t\t\t \n\t\t\t\tskb_queue_head(&pch->file.xq, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tskb_queue_purge(&pch->file.xq);\n\t}\n\tspin_unlock(&pch->downl);\n\t \n\tif (skb_queue_empty(&pch->file.xq)) {\n\t\tppp = pch->ppp;\n\t\tif (ppp)\n\t\t\t__ppp_xmit_process(ppp, NULL);\n\t}\n}\n\nstatic void ppp_channel_push(struct channel *pch)\n{\n\tread_lock_bh(&pch->upl);\n\tif (pch->ppp) {\n\t\t(*this_cpu_ptr(pch->ppp->xmit_recursion))++;\n\t\t__ppp_channel_push(pch);\n\t\t(*this_cpu_ptr(pch->ppp->xmit_recursion))--;\n\t} else {\n\t\t__ppp_channel_push(pch);\n\t}\n\tread_unlock_bh(&pch->upl);\n}\n\n \n\nstruct ppp_mp_skb_parm {\n\tu32\t\tsequence;\n\tu8\t\tBEbits;\n};\n#define PPP_MP_CB(skb)\t((struct ppp_mp_skb_parm *)((skb)->cb))\n\nstatic inline void\nppp_do_recv(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\n{\n\tppp_recv_lock(ppp);\n\tif (!ppp->closing)\n\t\tppp_receive_frame(ppp, skb, pch);\n\telse\n\t\tkfree_skb(skb);\n\tppp_recv_unlock(ppp);\n}\n\n \nstatic void __ppp_decompress_proto(struct sk_buff *skb)\n{\n\tif (skb->data[0] & 0x01)\n\t\t*(u8 *)skb_push(skb, 1) = 0x00;\n}\n\n \nstatic bool ppp_decompress_proto(struct sk_buff *skb)\n{\n\t \n\tif (!pskb_may_pull(skb, 1))\n\t\treturn false;\n\n\t__ppp_decompress_proto(skb);\n\n\t \n\treturn pskb_may_pull(skb, 2);\n}\n\n \nstatic bool ppp_channel_bridge_input(struct channel *pch, struct sk_buff *skb)\n{\n\tstruct channel *pchb;\n\n\trcu_read_lock();\n\tpchb = rcu_dereference(pch->bridge);\n\tif (!pchb)\n\t\tgoto out_rcu;\n\n\tspin_lock(&pchb->downl);\n\tif (!pchb->chan) {\n\t\t \n\t\tkfree_skb(skb);\n\t\tgoto outl;\n\t}\n\n\tskb_scrub_packet(skb, !net_eq(pch->chan_net, pchb->chan_net));\n\tif (!pchb->chan->ops->start_xmit(pchb->chan, skb))\n\t\tkfree_skb(skb);\n\noutl:\n\tspin_unlock(&pchb->downl);\nout_rcu:\n\trcu_read_unlock();\n\n\t \n\treturn !!pchb;\n}\n\nvoid\nppp_input(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstruct channel *pch = chan->ppp;\n\tint proto;\n\n\tif (!pch) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tif (ppp_channel_bridge_input(pch, skb))\n\t\treturn;\n\n\tread_lock_bh(&pch->upl);\n\tif (!ppp_decompress_proto(skb)) {\n\t\tkfree_skb(skb);\n\t\tif (pch->ppp) {\n\t\t\t++pch->ppp->dev->stats.rx_length_errors;\n\t\t\tppp_receive_error(pch->ppp);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tproto = PPP_PROTO(skb);\n\tif (!pch->ppp || proto >= 0xc000 || proto == PPP_CCPFRAG) {\n\t\t \n\t\tskb_queue_tail(&pch->file.rq, skb);\n\t\t \n\t\twhile (pch->file.rq.qlen > PPP_MAX_RQLEN &&\n\t\t       (skb = skb_dequeue(&pch->file.rq)))\n\t\t\tkfree_skb(skb);\n\t\twake_up_interruptible(&pch->file.rwait);\n\t} else {\n\t\tppp_do_recv(pch->ppp, skb, pch);\n\t}\n\ndone:\n\tread_unlock_bh(&pch->upl);\n}\n\n \nvoid\nppp_input_error(struct ppp_channel *chan, int code)\n{\n\tstruct channel *pch = chan->ppp;\n\tstruct sk_buff *skb;\n\n\tif (!pch)\n\t\treturn;\n\n\tread_lock_bh(&pch->upl);\n\tif (pch->ppp) {\n\t\tskb = alloc_skb(0, GFP_ATOMIC);\n\t\tif (skb) {\n\t\t\tskb->len = 0;\t\t \n\t\t\tskb->cb[0] = code;\n\t\t\tppp_do_recv(pch->ppp, skb, pch);\n\t\t}\n\t}\n\tread_unlock_bh(&pch->upl);\n}\n\n \nstatic void\nppp_receive_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\n{\n\t \n\tif (skb->len > 0) {\n\t\tskb_checksum_complete_unset(skb);\n#ifdef CONFIG_PPP_MULTILINK\n\t\t \n\t\tif (PPP_PROTO(skb) == PPP_MP)\n\t\t\tppp_receive_mp_frame(ppp, skb, pch);\n\t\telse\n#endif  \n\t\t\tppp_receive_nonmp_frame(ppp, skb);\n\t} else {\n\t\tkfree_skb(skb);\n\t\tppp_receive_error(ppp);\n\t}\n}\n\nstatic void\nppp_receive_error(struct ppp *ppp)\n{\n\t++ppp->dev->stats.rx_errors;\n\tif (ppp->vj)\n\t\tslhc_toss(ppp->vj);\n}\n\nstatic void\nppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb)\n{\n\tstruct sk_buff *ns;\n\tint proto, len, npi;\n\n\t \n\tif (ppp->rc_state && (ppp->rstate & SC_DECOMP_RUN) &&\n\t    (ppp->rstate & (SC_DC_FERROR | SC_DC_ERROR)) == 0)\n\t\tskb = ppp_decompress_frame(ppp, skb);\n\n\tif (ppp->flags & SC_MUST_COMP && ppp->rstate & SC_DC_FERROR)\n\t\tgoto err;\n\n\t \n\tproto = PPP_PROTO(skb);\n\tswitch (proto) {\n\tcase PPP_VJC_COMP:\n\t\t \n\t\tif (!ppp->vj || (ppp->flags & SC_REJ_COMP_TCP))\n\t\t\tgoto err;\n\n\t\tif (skb_tailroom(skb) < 124 || skb_cloned(skb)) {\n\t\t\t \n\t\t\tns = dev_alloc_skb(skb->len + 128);\n\t\t\tif (!ns) {\n\t\t\t\tnetdev_err(ppp->dev, \"PPP: no memory \"\n\t\t\t\t\t   \"(VJ decomp)\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tskb_reserve(ns, 2);\n\t\t\tskb_copy_bits(skb, 0, skb_put(ns, skb->len), skb->len);\n\t\t\tconsume_skb(skb);\n\t\t\tskb = ns;\n\t\t}\n\t\telse\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\tlen = slhc_uncompress(ppp->vj, skb->data + 2, skb->len - 2);\n\t\tif (len <= 0) {\n\t\t\tnetdev_printk(KERN_DEBUG, ppp->dev,\n\t\t\t\t      \"PPP: VJ decompression error\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tlen += 2;\n\t\tif (len > skb->len)\n\t\t\tskb_put(skb, len - skb->len);\n\t\telse if (len < skb->len)\n\t\t\tskb_trim(skb, len);\n\t\tproto = PPP_IP;\n\t\tbreak;\n\n\tcase PPP_VJC_UNCOMP:\n\t\tif (!ppp->vj || (ppp->flags & SC_REJ_COMP_TCP))\n\t\t\tgoto err;\n\n\t\t \n\t\tif (!pskb_may_pull(skb, skb->len))\n\t\t\tgoto err;\n\n\t\tif (slhc_remember(ppp->vj, skb->data + 2, skb->len - 2) <= 0) {\n\t\t\tnetdev_err(ppp->dev, \"PPP: VJ uncompressed error\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tproto = PPP_IP;\n\t\tbreak;\n\n\tcase PPP_CCP:\n\t\tppp_ccp_peek(ppp, skb, 1);\n\t\tbreak;\n\t}\n\n\t++ppp->stats64.rx_packets;\n\tppp->stats64.rx_bytes += skb->len - 2;\n\n\tnpi = proto_to_npindex(proto);\n\tif (npi < 0) {\n\t\t \n\t\tskb_queue_tail(&ppp->file.rq, skb);\n\t\t \n\t\twhile (ppp->file.rq.qlen > PPP_MAX_RQLEN &&\n\t\t       (skb = skb_dequeue(&ppp->file.rq)))\n\t\t\tkfree_skb(skb);\n\t\t \n\t\twake_up_interruptible(&ppp->file.rwait);\n\n\t} else {\n\t\t \n\n#ifdef CONFIG_PPP_FILTER\n\t\t \n\t\t \n\t\tif (ppp->pass_filter || ppp->active_filter) {\n\t\t\tif (skb_unclone(skb, GFP_ATOMIC))\n\t\t\t\tgoto err;\n\n\t\t\t*(u8 *)skb_push(skb, 2) = 0;\n\t\t\tif (ppp->pass_filter &&\n\t\t\t    bpf_prog_run(ppp->pass_filter, skb) == 0) {\n\t\t\t\tif (ppp->debug & 1)\n\t\t\t\t\tnetdev_printk(KERN_DEBUG, ppp->dev,\n\t\t\t\t\t\t      \"PPP: inbound frame \"\n\t\t\t\t\t\t      \"not passed\\n\");\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(ppp->active_filter &&\n\t\t\t      bpf_prog_run(ppp->active_filter, skb) == 0))\n\t\t\t\tppp->last_recv = jiffies;\n\t\t\t__skb_pull(skb, 2);\n\t\t} else\n#endif  \n\t\t\tppp->last_recv = jiffies;\n\n\t\tif ((ppp->dev->flags & IFF_UP) == 0 ||\n\t\t    ppp->npmode[npi] != NPMODE_PASS) {\n\t\t\tkfree_skb(skb);\n\t\t} else {\n\t\t\t \n\t\t\tskb_pull_rcsum(skb, 2);\n\t\t\tskb->dev = ppp->dev;\n\t\t\tskb->protocol = htons(npindex_to_ethertype[npi]);\n\t\t\tskb_reset_mac_header(skb);\n\t\t\tskb_scrub_packet(skb, !net_eq(ppp->ppp_net,\n\t\t\t\t\t\t      dev_net(ppp->dev)));\n\t\t\tnetif_rx(skb);\n\t\t}\n\t}\n\treturn;\n\n err:\n\tkfree_skb(skb);\n\tppp_receive_error(ppp);\n}\n\nstatic struct sk_buff *\nppp_decompress_frame(struct ppp *ppp, struct sk_buff *skb)\n{\n\tint proto = PPP_PROTO(skb);\n\tstruct sk_buff *ns;\n\tint len;\n\n\t \n\tif (!pskb_may_pull(skb, skb->len))\n\t\tgoto err;\n\n\tif (proto == PPP_COMP) {\n\t\tint obuff_size;\n\n\t\tswitch(ppp->rcomp->compress_proto) {\n\t\tcase CI_MPPE:\n\t\t\tobuff_size = ppp->mru + PPP_HDRLEN + 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tobuff_size = ppp->mru + PPP_HDRLEN;\n\t\t\tbreak;\n\t\t}\n\n\t\tns = dev_alloc_skb(obuff_size);\n\t\tif (!ns) {\n\t\t\tnetdev_err(ppp->dev, \"ppp_decompress_frame: \"\n\t\t\t\t   \"no memory\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\t \n\t\tlen = ppp->rcomp->decompress(ppp->rc_state, skb->data - 2,\n\t\t\t\tskb->len + 2, ns->data, obuff_size);\n\t\tif (len < 0) {\n\t\t\t \n\t\t\tif (len == DECOMP_FATALERROR)\n\t\t\t\tppp->rstate |= SC_DC_FERROR;\n\t\t\tkfree_skb(ns);\n\t\t\tgoto err;\n\t\t}\n\n\t\tconsume_skb(skb);\n\t\tskb = ns;\n\t\tskb_put(skb, len);\n\t\tskb_pull(skb, 2);\t \n\n\t\t \n\t} else {\n\t\t \n\t\tif (ppp->rcomp->incomp)\n\t\t\tppp->rcomp->incomp(ppp->rc_state, skb->data - 2,\n\t\t\t\t\t   skb->len + 2);\n\t}\n\n\treturn skb;\n\n err:\n\tppp->rstate |= SC_DC_ERROR;\n\tppp_receive_error(ppp);\n\treturn skb;\n}\n\n#ifdef CONFIG_PPP_MULTILINK\n \nstatic void\nppp_receive_mp_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\n{\n\tu32 mask, seq;\n\tstruct channel *ch;\n\tint mphdrlen = (ppp->flags & SC_MP_SHORTSEQ)? MPHDRLEN_SSN: MPHDRLEN;\n\n\tif (!pskb_may_pull(skb, mphdrlen + 1) || ppp->mrru == 0)\n\t\tgoto err;\t\t \n\n\t \n\tif (ppp->flags & SC_MP_SHORTSEQ) {\n\t\tseq = ((skb->data[2] & 0x0f) << 8) | skb->data[3];\n\t\tmask = 0xfff;\n\t} else {\n\t\tseq = (skb->data[3] << 16) | (skb->data[4] << 8)| skb->data[5];\n\t\tmask = 0xffffff;\n\t}\n\tPPP_MP_CB(skb)->BEbits = skb->data[2];\n\tskb_pull(skb, mphdrlen);\t \n\n\t \n\tif (PPP_MP_CB(skb)->BEbits & B)\n\t\t__ppp_decompress_proto(skb);\n\n\t \n\tseq |= ppp->minseq & ~mask;\n\tif ((int)(ppp->minseq - seq) > (int)(mask >> 1))\n\t\tseq += mask + 1;\n\telse if ((int)(seq - ppp->minseq) > (int)(mask >> 1))\n\t\tseq -= mask + 1;\t \n\tPPP_MP_CB(skb)->sequence = seq;\n\tpch->lastseq = seq;\n\n\t \n\tif (seq_before(seq, ppp->nextseq)) {\n\t\tkfree_skb(skb);\n\t\t++ppp->dev->stats.rx_dropped;\n\t\tppp_receive_error(ppp);\n\t\treturn;\n\t}\n\n\t \n\tlist_for_each_entry(ch, &ppp->channels, clist) {\n\t\tif (seq_before(ch->lastseq, seq))\n\t\t\tseq = ch->lastseq;\n\t}\n\tif (seq_before(ppp->minseq, seq))\n\t\tppp->minseq = seq;\n\n\t \n\tppp_mp_insert(ppp, skb);\n\n\t \n\tif (skb_queue_len(&ppp->mrq) >= PPP_MP_MAX_QLEN) {\n\t\tstruct sk_buff *mskb = skb_peek(&ppp->mrq);\n\t\tif (seq_before(ppp->minseq, PPP_MP_CB(mskb)->sequence))\n\t\t\tppp->minseq = PPP_MP_CB(mskb)->sequence;\n\t}\n\n\t \n\twhile ((skb = ppp_mp_reconstruct(ppp))) {\n\t\tif (pskb_may_pull(skb, 2))\n\t\t\tppp_receive_nonmp_frame(ppp, skb);\n\t\telse {\n\t\t\t++ppp->dev->stats.rx_length_errors;\n\t\t\tkfree_skb(skb);\n\t\t\tppp_receive_error(ppp);\n\t\t}\n\t}\n\n\treturn;\n\n err:\n\tkfree_skb(skb);\n\tppp_receive_error(ppp);\n}\n\n \nstatic void\nppp_mp_insert(struct ppp *ppp, struct sk_buff *skb)\n{\n\tstruct sk_buff *p;\n\tstruct sk_buff_head *list = &ppp->mrq;\n\tu32 seq = PPP_MP_CB(skb)->sequence;\n\n\t \n\tskb_queue_walk(list, p) {\n\t\tif (seq_before(seq, PPP_MP_CB(p)->sequence))\n\t\t\tbreak;\n\t}\n\t__skb_queue_before(list, p, skb);\n}\n\n \nstatic struct sk_buff *\nppp_mp_reconstruct(struct ppp *ppp)\n{\n\tu32 seq = ppp->nextseq;\n\tu32 minseq = ppp->minseq;\n\tstruct sk_buff_head *list = &ppp->mrq;\n\tstruct sk_buff *p, *tmp;\n\tstruct sk_buff *head, *tail;\n\tstruct sk_buff *skb = NULL;\n\tint lost = 0, len = 0;\n\n\tif (ppp->mrru == 0)\t \n\t\treturn NULL;\n\thead = __skb_peek(list);\n\ttail = NULL;\n\tskb_queue_walk_safe(list, p, tmp) {\n\tagain:\n\t\tif (seq_before(PPP_MP_CB(p)->sequence, seq)) {\n\t\t\t \n\t\t\tnetdev_err(ppp->dev, \"ppp_mp_reconstruct bad \"\n\t\t\t\t   \"seq %u < %u\\n\",\n\t\t\t\t   PPP_MP_CB(p)->sequence, seq);\n\t\t\t__skb_unlink(p, list);\n\t\t\tkfree_skb(p);\n\t\t\tcontinue;\n\t\t}\n\t\tif (PPP_MP_CB(p)->sequence != seq) {\n\t\t\tu32 oldseq;\n\t\t\t \n\t\t\tif (seq_after(seq, minseq))\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tlost = 1;\n\t\t\toldseq = seq;\n\t\t\tseq = seq_before(minseq, PPP_MP_CB(p)->sequence)?\n\t\t\t\tminseq + 1: PPP_MP_CB(p)->sequence;\n\n\t\t\tif (ppp->debug & 1)\n\t\t\t\tnetdev_printk(KERN_DEBUG, ppp->dev,\n\t\t\t\t\t      \"lost frag %u..%u\\n\",\n\t\t\t\t\t      oldseq, seq-1);\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (PPP_MP_CB(p)->BEbits & B) {\n\t\t\thead = p;\n\t\t\tlost = 0;\n\t\t\tlen = 0;\n\t\t}\n\n\t\tlen += p->len;\n\n\t\t \n\t\tif (lost == 0 && (PPP_MP_CB(p)->BEbits & E) &&\n\t\t    (PPP_MP_CB(head)->BEbits & B)) {\n\t\t\tif (len > ppp->mrru + 2) {\n\t\t\t\t++ppp->dev->stats.rx_length_errors;\n\t\t\t\tnetdev_printk(KERN_DEBUG, ppp->dev,\n\t\t\t\t\t      \"PPP: reconstructed packet\"\n\t\t\t\t\t      \" is too long (%d)\\n\", len);\n\t\t\t} else {\n\t\t\t\ttail = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tppp->nextseq = seq + 1;\n\t\t}\n\n\t\t \n\t\tif (PPP_MP_CB(p)->BEbits & E) {\n\t\t\tstruct sk_buff *tmp2;\n\n\t\t\tskb_queue_reverse_walk_from_safe(list, p, tmp2) {\n\t\t\t\tif (ppp->debug & 1)\n\t\t\t\t\tnetdev_printk(KERN_DEBUG, ppp->dev,\n\t\t\t\t\t\t      \"discarding frag %u\\n\",\n\t\t\t\t\t\t      PPP_MP_CB(p)->sequence);\n\t\t\t\t__skb_unlink(p, list);\n\t\t\t\tkfree_skb(p);\n\t\t\t}\n\t\t\thead = skb_peek(list);\n\t\t\tif (!head)\n\t\t\t\tbreak;\n\t\t}\n\t\t++seq;\n\t}\n\n\t \n\tif (tail != NULL) {\n\t\t \n\t\tif (PPP_MP_CB(head)->sequence != ppp->nextseq) {\n\t\t\tskb_queue_walk_safe(list, p, tmp) {\n\t\t\t\tif (p == head)\n\t\t\t\t\tbreak;\n\t\t\t\tif (ppp->debug & 1)\n\t\t\t\t\tnetdev_printk(KERN_DEBUG, ppp->dev,\n\t\t\t\t\t\t      \"discarding frag %u\\n\",\n\t\t\t\t\t\t      PPP_MP_CB(p)->sequence);\n\t\t\t\t__skb_unlink(p, list);\n\t\t\t\tkfree_skb(p);\n\t\t\t}\n\n\t\t\tif (ppp->debug & 1)\n\t\t\t\tnetdev_printk(KERN_DEBUG, ppp->dev,\n\t\t\t\t\t      \"  missed pkts %u..%u\\n\",\n\t\t\t\t\t      ppp->nextseq,\n\t\t\t\t\t      PPP_MP_CB(head)->sequence-1);\n\t\t\t++ppp->dev->stats.rx_dropped;\n\t\t\tppp_receive_error(ppp);\n\t\t}\n\n\t\tskb = head;\n\t\tif (head != tail) {\n\t\t\tstruct sk_buff **fragpp = &skb_shinfo(skb)->frag_list;\n\t\t\tp = skb_queue_next(list, head);\n\t\t\t__skb_unlink(skb, list);\n\t\t\tskb_queue_walk_from_safe(list, p, tmp) {\n\t\t\t\t__skb_unlink(p, list);\n\t\t\t\t*fragpp = p;\n\t\t\t\tp->next = NULL;\n\t\t\t\tfragpp = &p->next;\n\n\t\t\t\tskb->len += p->len;\n\t\t\t\tskb->data_len += p->len;\n\t\t\t\tskb->truesize += p->truesize;\n\n\t\t\t\tif (p == tail)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t__skb_unlink(skb, list);\n\t\t}\n\n\t\tppp->nextseq = PPP_MP_CB(tail)->sequence + 1;\n\t}\n\n\treturn skb;\n}\n#endif  \n\n \n\n \nint ppp_register_channel(struct ppp_channel *chan)\n{\n\treturn ppp_register_net_channel(current->nsproxy->net_ns, chan);\n}\n\n \nint ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n{\n\tstruct channel *pch;\n\tstruct ppp_net *pn;\n\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\n\tpn = ppp_pernet(net);\n\n\tpch->ppp = NULL;\n\tpch->chan = chan;\n\tpch->chan_net = get_net_track(net, &pch->ns_tracker, GFP_KERNEL);\n\tchan->ppp = pch;\n\tinit_ppp_file(&pch->file, CHANNEL);\n\tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif  \n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n\n\tspin_lock_bh(&pn->all_channels_lock);\n\tpch->file.index = ++pn->last_channel_index;\n\tlist_add(&pch->list, &pn->new_channels);\n\tatomic_inc(&channel_count);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\n\treturn 0;\n}\n\n \nint ppp_channel_index(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\n\tif (pch)\n\t\treturn pch->file.index;\n\treturn -1;\n}\n\n \nint ppp_unit_number(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\tint unit = -1;\n\n\tif (pch) {\n\t\tread_lock_bh(&pch->upl);\n\t\tif (pch->ppp)\n\t\t\tunit = pch->ppp->file.index;\n\t\tread_unlock_bh(&pch->upl);\n\t}\n\treturn unit;\n}\n\n \nchar *ppp_dev_name(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\tchar *name = NULL;\n\n\tif (pch) {\n\t\tread_lock_bh(&pch->upl);\n\t\tif (pch->ppp && pch->ppp->dev)\n\t\t\tname = pch->ppp->dev->name;\n\t\tread_unlock_bh(&pch->upl);\n\t}\n\treturn name;\n}\n\n\n \nvoid\nppp_unregister_channel(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\tstruct ppp_net *pn;\n\n\tif (!pch)\n\t\treturn;\t\t \n\n\tchan->ppp = NULL;\n\n\t \n\tdown_write(&pch->chan_sem);\n\tspin_lock_bh(&pch->downl);\n\tpch->chan = NULL;\n\tspin_unlock_bh(&pch->downl);\n\tup_write(&pch->chan_sem);\n\tppp_disconnect_channel(pch);\n\n\tpn = ppp_pernet(pch->chan_net);\n\tspin_lock_bh(&pn->all_channels_lock);\n\tlist_del(&pch->list);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\n\tppp_unbridge_channels(pch);\n\n\tpch->file.dead = 1;\n\twake_up_interruptible(&pch->file.rwait);\n\n\tif (refcount_dec_and_test(&pch->file.refcnt))\n\t\tppp_destroy_channel(pch);\n}\n\n \nvoid\nppp_output_wakeup(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\n\tif (!pch)\n\t\treturn;\n\tppp_channel_push(pch);\n}\n\n \n\n \nstatic int\nppp_set_compress(struct ppp *ppp, struct ppp_option_data *data)\n{\n\tint err = -EFAULT;\n\tstruct compressor *cp, *ocomp;\n\tvoid *state, *ostate;\n\tunsigned char ccp_option[CCP_MAX_OPTION_LENGTH];\n\n\tif (data->length > CCP_MAX_OPTION_LENGTH)\n\t\tgoto out;\n\tif (copy_from_user(ccp_option, data->ptr, data->length))\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (data->length < 2 || ccp_option[1] < 2 || ccp_option[1] > data->length)\n\t\tgoto out;\n\n\tcp = try_then_request_module(\n\t\tfind_compressor(ccp_option[0]),\n\t\t\"ppp-compress-%d\", ccp_option[0]);\n\tif (!cp)\n\t\tgoto out;\n\n\terr = -ENOBUFS;\n\tif (data->transmit) {\n\t\tstate = cp->comp_alloc(ccp_option, data->length);\n\t\tif (state) {\n\t\t\tppp_xmit_lock(ppp);\n\t\t\tppp->xstate &= ~SC_COMP_RUN;\n\t\t\tocomp = ppp->xcomp;\n\t\t\tostate = ppp->xc_state;\n\t\t\tppp->xcomp = cp;\n\t\t\tppp->xc_state = state;\n\t\t\tppp_xmit_unlock(ppp);\n\t\t\tif (ostate) {\n\t\t\t\tocomp->comp_free(ostate);\n\t\t\t\tmodule_put(ocomp->owner);\n\t\t\t}\n\t\t\terr = 0;\n\t\t} else\n\t\t\tmodule_put(cp->owner);\n\n\t} else {\n\t\tstate = cp->decomp_alloc(ccp_option, data->length);\n\t\tif (state) {\n\t\t\tppp_recv_lock(ppp);\n\t\t\tppp->rstate &= ~SC_DECOMP_RUN;\n\t\t\tocomp = ppp->rcomp;\n\t\t\tostate = ppp->rc_state;\n\t\t\tppp->rcomp = cp;\n\t\t\tppp->rc_state = state;\n\t\t\tppp_recv_unlock(ppp);\n\t\t\tif (ostate) {\n\t\t\t\tocomp->decomp_free(ostate);\n\t\t\t\tmodule_put(ocomp->owner);\n\t\t\t}\n\t\t\terr = 0;\n\t\t} else\n\t\t\tmodule_put(cp->owner);\n\t}\n\n out:\n\treturn err;\n}\n\n \nstatic void\nppp_ccp_peek(struct ppp *ppp, struct sk_buff *skb, int inbound)\n{\n\tunsigned char *dp;\n\tint len;\n\n\tif (!pskb_may_pull(skb, CCP_HDRLEN + 2))\n\t\treturn;\t \n\tdp = skb->data + 2;\n\n\tswitch (CCP_CODE(dp)) {\n\tcase CCP_CONFREQ:\n\n\t\t \n\t\tif(inbound)\n\t\t\t \n\t\t\tppp->xstate &= ~SC_COMP_RUN;\n\t\telse\n\t\t\t \n\t\t\tppp->rstate &= ~SC_DECOMP_RUN;\n\n\t\tbreak;\n\n\tcase CCP_TERMREQ:\n\tcase CCP_TERMACK:\n\t\t \n\t\tppp->rstate &= ~SC_DECOMP_RUN;\n\t\tppp->xstate &= ~SC_COMP_RUN;\n\t\tbreak;\n\n\tcase CCP_CONFACK:\n\t\tif ((ppp->flags & (SC_CCP_OPEN | SC_CCP_UP)) != SC_CCP_OPEN)\n\t\t\tbreak;\n\t\tlen = CCP_LENGTH(dp);\n\t\tif (!pskb_may_pull(skb, len + 2))\n\t\t\treturn;\t\t \n\t\tdp += CCP_HDRLEN;\n\t\tlen -= CCP_HDRLEN;\n\t\tif (len < CCP_OPT_MINLEN || len < CCP_OPT_LENGTH(dp))\n\t\t\tbreak;\n\t\tif (inbound) {\n\t\t\t \n\t\t\tif (!ppp->rc_state)\n\t\t\t\tbreak;\n\t\t\tif (ppp->rcomp->decomp_init(ppp->rc_state, dp, len,\n\t\t\t\t\tppp->file.index, 0, ppp->mru, ppp->debug)) {\n\t\t\t\tppp->rstate |= SC_DECOMP_RUN;\n\t\t\t\tppp->rstate &= ~(SC_DC_ERROR | SC_DC_FERROR);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (!ppp->xc_state)\n\t\t\t\tbreak;\n\t\t\tif (ppp->xcomp->comp_init(ppp->xc_state, dp, len,\n\t\t\t\t\tppp->file.index, 0, ppp->debug))\n\t\t\t\tppp->xstate |= SC_COMP_RUN;\n\t\t}\n\t\tbreak;\n\n\tcase CCP_RESETACK:\n\t\t \n\t\tif ((ppp->flags & SC_CCP_UP) == 0)\n\t\t\tbreak;\n\t\tif (inbound) {\n\t\t\tif (ppp->rc_state && (ppp->rstate & SC_DECOMP_RUN)) {\n\t\t\t\tppp->rcomp->decomp_reset(ppp->rc_state);\n\t\t\t\tppp->rstate &= ~SC_DC_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ppp->xc_state && (ppp->xstate & SC_COMP_RUN))\n\t\t\t\tppp->xcomp->comp_reset(ppp->xc_state);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nppp_ccp_closed(struct ppp *ppp)\n{\n\tvoid *xstate, *rstate;\n\tstruct compressor *xcomp, *rcomp;\n\n\tppp_lock(ppp);\n\tppp->flags &= ~(SC_CCP_OPEN | SC_CCP_UP);\n\tppp->xstate = 0;\n\txcomp = ppp->xcomp;\n\txstate = ppp->xc_state;\n\tppp->xc_state = NULL;\n\tppp->rstate = 0;\n\trcomp = ppp->rcomp;\n\trstate = ppp->rc_state;\n\tppp->rc_state = NULL;\n\tppp_unlock(ppp);\n\n\tif (xstate) {\n\t\txcomp->comp_free(xstate);\n\t\tmodule_put(xcomp->owner);\n\t}\n\tif (rstate) {\n\t\trcomp->decomp_free(rstate);\n\t\tmodule_put(rcomp->owner);\n\t}\n}\n\n \nstatic LIST_HEAD(compressor_list);\nstatic DEFINE_SPINLOCK(compressor_list_lock);\n\nstruct compressor_entry {\n\tstruct list_head list;\n\tstruct compressor *comp;\n};\n\nstatic struct compressor_entry *\nfind_comp_entry(int proto)\n{\n\tstruct compressor_entry *ce;\n\n\tlist_for_each_entry(ce, &compressor_list, list) {\n\t\tif (ce->comp->compress_proto == proto)\n\t\t\treturn ce;\n\t}\n\treturn NULL;\n}\n\n \nint\nppp_register_compressor(struct compressor *cp)\n{\n\tstruct compressor_entry *ce;\n\tint ret;\n\tspin_lock(&compressor_list_lock);\n\tret = -EEXIST;\n\tif (find_comp_entry(cp->compress_proto))\n\t\tgoto out;\n\tret = -ENOMEM;\n\tce = kmalloc(sizeof(struct compressor_entry), GFP_ATOMIC);\n\tif (!ce)\n\t\tgoto out;\n\tret = 0;\n\tce->comp = cp;\n\tlist_add(&ce->list, &compressor_list);\n out:\n\tspin_unlock(&compressor_list_lock);\n\treturn ret;\n}\n\n \nvoid\nppp_unregister_compressor(struct compressor *cp)\n{\n\tstruct compressor_entry *ce;\n\n\tspin_lock(&compressor_list_lock);\n\tce = find_comp_entry(cp->compress_proto);\n\tif (ce && ce->comp == cp) {\n\t\tlist_del(&ce->list);\n\t\tkfree(ce);\n\t}\n\tspin_unlock(&compressor_list_lock);\n}\n\n \nstatic struct compressor *\nfind_compressor(int type)\n{\n\tstruct compressor_entry *ce;\n\tstruct compressor *cp = NULL;\n\n\tspin_lock(&compressor_list_lock);\n\tce = find_comp_entry(type);\n\tif (ce) {\n\t\tcp = ce->comp;\n\t\tif (!try_module_get(cp->owner))\n\t\t\tcp = NULL;\n\t}\n\tspin_unlock(&compressor_list_lock);\n\treturn cp;\n}\n\n \n\nstatic void\nppp_get_stats(struct ppp *ppp, struct ppp_stats *st)\n{\n\tstruct slcompress *vj = ppp->vj;\n\n\tmemset(st, 0, sizeof(*st));\n\tst->p.ppp_ipackets = ppp->stats64.rx_packets;\n\tst->p.ppp_ierrors = ppp->dev->stats.rx_errors;\n\tst->p.ppp_ibytes = ppp->stats64.rx_bytes;\n\tst->p.ppp_opackets = ppp->stats64.tx_packets;\n\tst->p.ppp_oerrors = ppp->dev->stats.tx_errors;\n\tst->p.ppp_obytes = ppp->stats64.tx_bytes;\n\tif (!vj)\n\t\treturn;\n\tst->vj.vjs_packets = vj->sls_o_compressed + vj->sls_o_uncompressed;\n\tst->vj.vjs_compressed = vj->sls_o_compressed;\n\tst->vj.vjs_searches = vj->sls_o_searches;\n\tst->vj.vjs_misses = vj->sls_o_misses;\n\tst->vj.vjs_errorin = vj->sls_i_error;\n\tst->vj.vjs_tossed = vj->sls_i_tossed;\n\tst->vj.vjs_uncompressedin = vj->sls_i_uncompressed;\n\tst->vj.vjs_compressedin = vj->sls_i_compressed;\n}\n\n \n\n \nstatic int ppp_create_interface(struct net *net, struct file *file, int *unit)\n{\n\tstruct ppp_config conf = {\n\t\t.file = file,\n\t\t.unit = *unit,\n\t\t.ifname_is_set = false,\n\t};\n\tstruct net_device *dev;\n\tstruct ppp *ppp;\n\tint err;\n\n\tdev = alloc_netdev(sizeof(struct ppp), \"\", NET_NAME_ENUM, ppp_setup);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev_net_set(dev, net);\n\tdev->rtnl_link_ops = &ppp_link_ops;\n\n\trtnl_lock();\n\n\terr = ppp_dev_configure(net, dev, &conf);\n\tif (err < 0)\n\t\tgoto err_dev;\n\tppp = netdev_priv(dev);\n\t*unit = ppp->file.index;\n\n\trtnl_unlock();\n\n\treturn 0;\n\nerr_dev:\n\trtnl_unlock();\n\tfree_netdev(dev);\nerr:\n\treturn err;\n}\n\n \nstatic void\ninit_ppp_file(struct ppp_file *pf, int kind)\n{\n\tpf->kind = kind;\n\tskb_queue_head_init(&pf->xq);\n\tskb_queue_head_init(&pf->rq);\n\trefcount_set(&pf->refcnt, 1);\n\tinit_waitqueue_head(&pf->rwait);\n}\n\n \nstatic void ppp_destroy_interface(struct ppp *ppp)\n{\n\tatomic_dec(&ppp_unit_count);\n\n\tif (!ppp->file.dead || ppp->n_channels) {\n\t\t \n\t\tnetdev_err(ppp->dev, \"ppp: destroying ppp struct %p \"\n\t\t\t   \"but dead=%d n_channels=%d !\\n\",\n\t\t\t   ppp, ppp->file.dead, ppp->n_channels);\n\t\treturn;\n\t}\n\n\tppp_ccp_closed(ppp);\n\tif (ppp->vj) {\n\t\tslhc_free(ppp->vj);\n\t\tppp->vj = NULL;\n\t}\n\tskb_queue_purge(&ppp->file.xq);\n\tskb_queue_purge(&ppp->file.rq);\n#ifdef CONFIG_PPP_MULTILINK\n\tskb_queue_purge(&ppp->mrq);\n#endif  \n#ifdef CONFIG_PPP_FILTER\n\tif (ppp->pass_filter) {\n\t\tbpf_prog_destroy(ppp->pass_filter);\n\t\tppp->pass_filter = NULL;\n\t}\n\n\tif (ppp->active_filter) {\n\t\tbpf_prog_destroy(ppp->active_filter);\n\t\tppp->active_filter = NULL;\n\t}\n#endif  \n\n\tkfree_skb(ppp->xmit_pending);\n\tfree_percpu(ppp->xmit_recursion);\n\n\tfree_netdev(ppp->dev);\n}\n\n \nstatic struct ppp *\nppp_find_unit(struct ppp_net *pn, int unit)\n{\n\treturn unit_find(&pn->units_idr, unit);\n}\n\n \nstatic struct channel *\nppp_find_channel(struct ppp_net *pn, int unit)\n{\n\tstruct channel *pch;\n\n\tlist_for_each_entry(pch, &pn->new_channels, list) {\n\t\tif (pch->file.index == unit) {\n\t\t\tlist_move(&pch->list, &pn->all_channels);\n\t\t\treturn pch;\n\t\t}\n\t}\n\n\tlist_for_each_entry(pch, &pn->all_channels, list) {\n\t\tif (pch->file.index == unit)\n\t\t\treturn pch;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int\nppp_connect_channel(struct channel *pch, int unit)\n{\n\tstruct ppp *ppp;\n\tstruct ppp_net *pn;\n\tint ret = -ENXIO;\n\tint hdrlen;\n\n\tpn = ppp_pernet(pch->chan_net);\n\n\tmutex_lock(&pn->all_ppp_mutex);\n\tppp = ppp_find_unit(pn, unit);\n\tif (!ppp)\n\t\tgoto out;\n\twrite_lock_bh(&pch->upl);\n\tret = -EINVAL;\n\tif (pch->ppp ||\n\t    rcu_dereference_protected(pch->bridge, lockdep_is_held(&pch->upl)))\n\t\tgoto outl;\n\n\tppp_lock(ppp);\n\tspin_lock_bh(&pch->downl);\n\tif (!pch->chan) {\n\t\t \n\t\tspin_unlock_bh(&pch->downl);\n\t\tppp_unlock(ppp);\n\t\tret = -ENOTCONN;\n\t\tgoto outl;\n\t}\n\tspin_unlock_bh(&pch->downl);\n\tif (pch->file.hdrlen > ppp->file.hdrlen)\n\t\tppp->file.hdrlen = pch->file.hdrlen;\n\thdrlen = pch->file.hdrlen + 2;\t \n\tif (hdrlen > ppp->dev->hard_header_len)\n\t\tppp->dev->hard_header_len = hdrlen;\n\tlist_add_tail(&pch->clist, &ppp->channels);\n\t++ppp->n_channels;\n\tpch->ppp = ppp;\n\trefcount_inc(&ppp->file.refcnt);\n\tppp_unlock(ppp);\n\tret = 0;\n\n outl:\n\twrite_unlock_bh(&pch->upl);\n out:\n\tmutex_unlock(&pn->all_ppp_mutex);\n\treturn ret;\n}\n\n \nstatic int\nppp_disconnect_channel(struct channel *pch)\n{\n\tstruct ppp *ppp;\n\tint err = -EINVAL;\n\n\twrite_lock_bh(&pch->upl);\n\tppp = pch->ppp;\n\tpch->ppp = NULL;\n\twrite_unlock_bh(&pch->upl);\n\tif (ppp) {\n\t\t \n\t\tppp_lock(ppp);\n\t\tlist_del(&pch->clist);\n\t\tif (--ppp->n_channels == 0)\n\t\t\twake_up_interruptible(&ppp->file.rwait);\n\t\tppp_unlock(ppp);\n\t\tif (refcount_dec_and_test(&ppp->file.refcnt))\n\t\t\tppp_destroy_interface(ppp);\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\n \nstatic void ppp_destroy_channel(struct channel *pch)\n{\n\tput_net_track(pch->chan_net, &pch->ns_tracker);\n\tpch->chan_net = NULL;\n\n\tatomic_dec(&channel_count);\n\n\tif (!pch->file.dead) {\n\t\t \n\t\tpr_err(\"ppp: destroying undead channel %p !\\n\", pch);\n\t\treturn;\n\t}\n\tskb_queue_purge(&pch->file.xq);\n\tskb_queue_purge(&pch->file.rq);\n\tkfree(pch);\n}\n\nstatic void __exit ppp_cleanup(void)\n{\n\t \n\tif (atomic_read(&ppp_unit_count) || atomic_read(&channel_count))\n\t\tpr_err(\"PPP: removing module but units remain!\\n\");\n\trtnl_link_unregister(&ppp_link_ops);\n\tunregister_chrdev(PPP_MAJOR, \"ppp\");\n\tdevice_destroy(ppp_class, MKDEV(PPP_MAJOR, 0));\n\tclass_destroy(ppp_class);\n\tunregister_pernet_device(&ppp_net_ops);\n}\n\n \n\n \nstatic int unit_set(struct idr *p, void *ptr, int n)\n{\n\tint unit;\n\n\tunit = idr_alloc(p, ptr, n, n + 1, GFP_KERNEL);\n\tif (unit == -ENOSPC)\n\t\tunit = -EINVAL;\n\treturn unit;\n}\n\n \nstatic int unit_get(struct idr *p, void *ptr, int min)\n{\n\treturn idr_alloc(p, ptr, min, 0, GFP_KERNEL);\n}\n\n \nstatic void unit_put(struct idr *p, int n)\n{\n\tidr_remove(p, n);\n}\n\n \nstatic void *unit_find(struct idr *p, int n)\n{\n\treturn idr_find(p, n);\n}\n\n \n\nmodule_init(ppp_init);\nmodule_exit(ppp_cleanup);\n\nEXPORT_SYMBOL(ppp_register_net_channel);\nEXPORT_SYMBOL(ppp_register_channel);\nEXPORT_SYMBOL(ppp_unregister_channel);\nEXPORT_SYMBOL(ppp_channel_index);\nEXPORT_SYMBOL(ppp_unit_number);\nEXPORT_SYMBOL(ppp_dev_name);\nEXPORT_SYMBOL(ppp_input);\nEXPORT_SYMBOL(ppp_input_error);\nEXPORT_SYMBOL(ppp_output_wakeup);\nEXPORT_SYMBOL(ppp_register_compressor);\nEXPORT_SYMBOL(ppp_unregister_compressor);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CHARDEV(PPP_MAJOR, 0);\nMODULE_ALIAS_RTNL_LINK(\"ppp\");\nMODULE_ALIAS(\"devname:ppp\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}