{
  "module_name": "ppp_mppe.c",
  "hash_id": "f1513739c4dd08d0b4dfe456c39f3291619bf327ad91c901739b8aa4996c16e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ppp/ppp_mppe.c",
  "human_readable_source": " \n\n#include <crypto/arc4.h>\n#include <crypto/hash.h>\n#include <linux/err.h>\n#include <linux/fips.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/ppp_defs.h>\n#include <linux/ppp-comp.h>\n#include <linux/scatterlist.h>\n#include <asm/unaligned.h>\n\n#include \"ppp_mppe.h\"\n\nMODULE_AUTHOR(\"Frank Cusack <fcusack@fcusack.com>\");\nMODULE_DESCRIPTION(\"Point-to-Point Protocol Microsoft Point-to-Point Encryption support\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"ppp-compress-\" __stringify(CI_MPPE));\nMODULE_VERSION(\"1.0.2\");\n\n#define SHA1_PAD_SIZE 40\n\n \n\nstruct sha_pad {\n\tunsigned char sha_pad1[SHA1_PAD_SIZE];\n\tunsigned char sha_pad2[SHA1_PAD_SIZE];\n};\nstatic struct sha_pad *sha_pad;\n\nstatic inline void sha_pad_init(struct sha_pad *shapad)\n{\n\tmemset(shapad->sha_pad1, 0x00, sizeof(shapad->sha_pad1));\n\tmemset(shapad->sha_pad2, 0xF2, sizeof(shapad->sha_pad2));\n}\n\n \nstruct ppp_mppe_state {\n\tstruct arc4_ctx arc4;\n\tstruct shash_desc *sha1;\n\tunsigned char *sha1_digest;\n\tunsigned char master_key[MPPE_MAX_KEY_LEN];\n\tunsigned char session_key[MPPE_MAX_KEY_LEN];\n\tunsigned keylen;\t \n\t \n\t \n\t \n\tunsigned char bits;\t \n\tunsigned ccount;\t \n\tunsigned stateful;\t \n\tint discard;\t\t \n\tint sanity_errors;\t \n\tint unit;\n\tint debug;\n\tstruct compstat stats;\n};\n\n \n#define MPPE_BIT_A\t0x80\t \n#define MPPE_BIT_B\t0x40\t \n#define MPPE_BIT_C\t0x20\t \n#define MPPE_BIT_D\t0x10\t \n\n#define MPPE_BIT_FLUSHED\tMPPE_BIT_A\n#define MPPE_BIT_ENCRYPTED\tMPPE_BIT_D\n\n#define MPPE_BITS(p) ((p)[4] & 0xf0)\n#define MPPE_CCOUNT(p) ((((p)[4] & 0x0f) << 8) + (p)[5])\n#define MPPE_CCOUNT_SPACE 0x1000\t \n\n#define MPPE_OVHD\t2\t \n#define SANITY_MAX\t1600\t \n\n \nstatic void get_new_key_from_sha(struct ppp_mppe_state * state)\n{\n\tcrypto_shash_init(state->sha1);\n\tcrypto_shash_update(state->sha1, state->master_key,\n\t\t\t    state->keylen);\n\tcrypto_shash_update(state->sha1, sha_pad->sha_pad1,\n\t\t\t    sizeof(sha_pad->sha_pad1));\n\tcrypto_shash_update(state->sha1, state->session_key,\n\t\t\t    state->keylen);\n\tcrypto_shash_update(state->sha1, sha_pad->sha_pad2,\n\t\t\t    sizeof(sha_pad->sha_pad2));\n\tcrypto_shash_final(state->sha1, state->sha1_digest);\n}\n\n \nstatic void mppe_rekey(struct ppp_mppe_state * state, int initial_key)\n{\n\tget_new_key_from_sha(state);\n\tif (!initial_key) {\n\t\tarc4_setkey(&state->arc4, state->sha1_digest, state->keylen);\n\t\tarc4_crypt(&state->arc4, state->session_key, state->sha1_digest,\n\t\t\t   state->keylen);\n\t} else {\n\t\tmemcpy(state->session_key, state->sha1_digest, state->keylen);\n\t}\n\tif (state->keylen == 8) {\n\t\t \n\t\tstate->session_key[0] = 0xd1;\n\t\tstate->session_key[1] = 0x26;\n\t\tstate->session_key[2] = 0x9e;\n\t}\n\tarc4_setkey(&state->arc4, state->session_key, state->keylen);\n}\n\n \nstatic void *mppe_alloc(unsigned char *options, int optlen)\n{\n\tstruct ppp_mppe_state *state;\n\tstruct crypto_shash *shash;\n\tunsigned int digestsize;\n\n\tif (optlen != CILEN_MPPE + sizeof(state->master_key) ||\n\t    options[0] != CI_MPPE || options[1] != CILEN_MPPE ||\n\t    fips_enabled)\n\t\tgoto out;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state == NULL)\n\t\tgoto out;\n\n\n\tshash = crypto_alloc_shash(\"sha1\", 0, 0);\n\tif (IS_ERR(shash))\n\t\tgoto out_free;\n\n\tstate->sha1 = kmalloc(sizeof(*state->sha1) +\n\t\t\t\t     crypto_shash_descsize(shash),\n\t\t\t      GFP_KERNEL);\n\tif (!state->sha1) {\n\t\tcrypto_free_shash(shash);\n\t\tgoto out_free;\n\t}\n\tstate->sha1->tfm = shash;\n\n\tdigestsize = crypto_shash_digestsize(shash);\n\tif (digestsize < MPPE_MAX_KEY_LEN)\n\t\tgoto out_free;\n\n\tstate->sha1_digest = kmalloc(digestsize, GFP_KERNEL);\n\tif (!state->sha1_digest)\n\t\tgoto out_free;\n\n\t \n\tmemcpy(state->master_key, &options[CILEN_MPPE],\n\t       sizeof(state->master_key));\n\tmemcpy(state->session_key, state->master_key,\n\t       sizeof(state->master_key));\n\n\t \n\n\treturn (void *)state;\n\nout_free:\n\tkfree(state->sha1_digest);\n\tif (state->sha1) {\n\t\tcrypto_free_shash(state->sha1->tfm);\n\t\tkfree_sensitive(state->sha1);\n\t}\n\tkfree(state);\nout:\n\treturn NULL;\n}\n\n \nstatic void mppe_free(void *arg)\n{\n\tstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\n\tif (state) {\n\t\tkfree(state->sha1_digest);\n\t\tcrypto_free_shash(state->sha1->tfm);\n\t\tkfree_sensitive(state->sha1);\n\t\tkfree_sensitive(state);\n\t}\n}\n\n \nstatic int\nmppe_init(void *arg, unsigned char *options, int optlen, int unit, int debug,\n\t  const char *debugstr)\n{\n\tstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\n\tunsigned char mppe_opts;\n\n\tif (optlen != CILEN_MPPE ||\n\t    options[0] != CI_MPPE || options[1] != CILEN_MPPE)\n\t\treturn 0;\n\n\tMPPE_CI_TO_OPTS(&options[2], mppe_opts);\n\tif (mppe_opts & MPPE_OPT_128)\n\t\tstate->keylen = 16;\n\telse if (mppe_opts & MPPE_OPT_40)\n\t\tstate->keylen = 8;\n\telse {\n\t\tprintk(KERN_WARNING \"%s[%d]: unknown key length\\n\", debugstr,\n\t\t       unit);\n\t\treturn 0;\n\t}\n\tif (mppe_opts & MPPE_OPT_STATEFUL)\n\t\tstate->stateful = 1;\n\n\t \n\tmppe_rekey(state, 1);\n\n\tif (debug) {\n\t\tprintk(KERN_DEBUG \"%s[%d]: initialized with %d-bit %s mode\\n\",\n\t\t       debugstr, unit, (state->keylen == 16) ? 128 : 40,\n\t\t       (state->stateful) ? \"stateful\" : \"stateless\");\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s[%d]: keys: master: %*phN initial session: %*phN\\n\",\n\t\t       debugstr, unit,\n\t\t       (int)sizeof(state->master_key), state->master_key,\n\t\t       (int)sizeof(state->session_key), state->session_key);\n\t}\n\n\t \n\tstate->ccount = MPPE_CCOUNT_SPACE - 1;\n\n\t \n\tstate->bits = MPPE_BIT_ENCRYPTED;\n\n\tstate->unit = unit;\n\tstate->debug = debug;\n\n\treturn 1;\n}\n\nstatic int\nmppe_comp_init(void *arg, unsigned char *options, int optlen, int unit,\n\t       int hdrlen, int debug)\n{\n\t \n\treturn mppe_init(arg, options, optlen, unit, debug, \"mppe_comp_init\");\n}\n\n \nstatic void mppe_comp_reset(void *arg)\n{\n\tstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\n\n\tstate->bits |= MPPE_BIT_FLUSHED;\n}\n\n \nstatic int\nmppe_compress(void *arg, unsigned char *ibuf, unsigned char *obuf,\n\t      int isize, int osize)\n{\n\tstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\n\tint proto;\n\n\t \n\tproto = PPP_PROTOCOL(ibuf);\n\tif (proto < 0x0021 || proto > 0x00fa)\n\t\treturn 0;\n\n\t \n\tif (osize < isize + MPPE_OVHD + 2) {\n\t\t \n\t\tprintk(KERN_DEBUG \"mppe_compress[%d]: osize too small! \"\n\t\t       \"(have: %d need: %d)\\n\", state->unit,\n\t\t       osize, osize + MPPE_OVHD + 2);\n\t\treturn -1;\n\t}\n\n\tosize = isize + MPPE_OVHD + 2;\n\n\t \n\tobuf[0] = PPP_ADDRESS(ibuf);\n\tobuf[1] = PPP_CONTROL(ibuf);\n\tput_unaligned_be16(PPP_COMP, obuf + 2);\n\tobuf += PPP_HDRLEN;\n\n\tstate->ccount = (state->ccount + 1) % MPPE_CCOUNT_SPACE;\n\tif (state->debug >= 7)\n\t\tprintk(KERN_DEBUG \"mppe_compress[%d]: ccount %d\\n\", state->unit,\n\t\t       state->ccount);\n\tput_unaligned_be16(state->ccount, obuf);\n\n\tif (!state->stateful ||\t \n\t    ((state->ccount & 0xff) == 0xff) ||\t \n\t    (state->bits & MPPE_BIT_FLUSHED)) {\t \n\t\t \n\t\tif (state->debug && state->stateful)\n\t\t\tprintk(KERN_DEBUG \"mppe_compress[%d]: rekeying\\n\",\n\t\t\t       state->unit);\n\t\tmppe_rekey(state, 0);\n\t\tstate->bits |= MPPE_BIT_FLUSHED;\n\t}\n\tobuf[0] |= state->bits;\n\tstate->bits &= ~MPPE_BIT_FLUSHED;\t \n\n\tobuf += MPPE_OVHD;\n\tibuf += 2;\t\t \n\tisize -= 2;\n\n\tarc4_crypt(&state->arc4, obuf, ibuf, isize);\n\n\tstate->stats.unc_bytes += isize;\n\tstate->stats.unc_packets++;\n\tstate->stats.comp_bytes += osize;\n\tstate->stats.comp_packets++;\n\n\treturn osize;\n}\n\n \nstatic void mppe_comp_stats(void *arg, struct compstat *stats)\n{\n\tstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\n\n\t*stats = state->stats;\n}\n\nstatic int\nmppe_decomp_init(void *arg, unsigned char *options, int optlen, int unit,\n\t\t int hdrlen, int mru, int debug)\n{\n\t \n\treturn mppe_init(arg, options, optlen, unit, debug, \"mppe_decomp_init\");\n}\n\n \nstatic void mppe_decomp_reset(void *arg)\n{\n\t \n\treturn;\n}\n\n \nstatic int\nmppe_decompress(void *arg, unsigned char *ibuf, int isize, unsigned char *obuf,\n\t\tint osize)\n{\n\tstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\n\tunsigned ccount;\n\tint flushed = MPPE_BITS(ibuf) & MPPE_BIT_FLUSHED;\n\n\tif (isize <= PPP_HDRLEN + MPPE_OVHD) {\n\t\tif (state->debug)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"mppe_decompress[%d]: short pkt (%d)\\n\",\n\t\t\t       state->unit, isize);\n\t\treturn DECOMP_ERROR;\n\t}\n\n\t \n\tif (osize < isize - MPPE_OVHD - 1) {\n\t\tprintk(KERN_DEBUG \"mppe_decompress[%d]: osize too small! \"\n\t\t       \"(have: %d need: %d)\\n\", state->unit,\n\t\t       osize, isize - MPPE_OVHD - 1);\n\t\treturn DECOMP_ERROR;\n\t}\n\tosize = isize - MPPE_OVHD - 2;\t \n\n\tccount = MPPE_CCOUNT(ibuf);\n\tif (state->debug >= 7)\n\t\tprintk(KERN_DEBUG \"mppe_decompress[%d]: ccount %d\\n\",\n\t\t       state->unit, ccount);\n\n\t \n\tif (!(MPPE_BITS(ibuf) & MPPE_BIT_ENCRYPTED)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"mppe_decompress[%d]: ENCRYPTED bit not set!\\n\",\n\t\t       state->unit);\n\t\tstate->sanity_errors += 100;\n\t\tgoto sanity_error;\n\t}\n\tif (!state->stateful && !flushed) {\n\t\tprintk(KERN_DEBUG \"mppe_decompress[%d]: FLUSHED bit not set in \"\n\t\t       \"stateless mode!\\n\", state->unit);\n\t\tstate->sanity_errors += 100;\n\t\tgoto sanity_error;\n\t}\n\tif (state->stateful && ((ccount & 0xff) == 0xff) && !flushed) {\n\t\tprintk(KERN_DEBUG \"mppe_decompress[%d]: FLUSHED bit not set on \"\n\t\t       \"flag packet!\\n\", state->unit);\n\t\tstate->sanity_errors += 100;\n\t\tgoto sanity_error;\n\t}\n\n\t \n\n\tif (!state->stateful) {\n\t\t \n\t\tif ((ccount - state->ccount) % MPPE_CCOUNT_SPACE\n\t\t\t\t\t\t> MPPE_CCOUNT_SPACE / 2) {\n\t\t\tstate->sanity_errors++;\n\t\t\tgoto sanity_error;\n\t\t}\n\n\t\t \n\t\twhile (state->ccount != ccount) {\n\t\t\tmppe_rekey(state, 0);\n\t\t\tstate->ccount = (state->ccount + 1) % MPPE_CCOUNT_SPACE;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!state->discard) {\n\t\t\t \n\t\t\tstate->ccount = (state->ccount + 1) % MPPE_CCOUNT_SPACE;\n\t\t\tif (ccount != state->ccount) {\n\t\t\t\t \n\t\t\t\tstate->discard = 1;\n\t\t\t\treturn DECOMP_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (!flushed) {\n\t\t\t\t \n\t\t\t\treturn DECOMP_ERROR;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\twhile ((ccount & ~0xff) !=\n\t\t\t\t       (state->ccount & ~0xff)) {\n\t\t\t\t\tmppe_rekey(state, 0);\n\t\t\t\t\tstate->ccount =\n\t\t\t\t\t    (state->ccount +\n\t\t\t\t\t     256) % MPPE_CCOUNT_SPACE;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tstate->discard = 0;\n\t\t\t\tstate->ccount = ccount;\n\t\t\t\t \n\t\t\t}\n\t\t}\n\t\tif (flushed)\n\t\t\tmppe_rekey(state, 0);\n\t}\n\n\t \n\tobuf[0] = PPP_ADDRESS(ibuf);\t \n\tobuf[1] = PPP_CONTROL(ibuf);\t \n\tobuf += 2;\n\tibuf += PPP_HDRLEN + MPPE_OVHD;\n\tisize -= PPP_HDRLEN + MPPE_OVHD;\t \n\t \n\n\t \n\tarc4_crypt(&state->arc4, obuf, ibuf, 1);\n\n\t \n\tif ((obuf[0] & 0x01) != 0) {\n\t\tobuf[1] = obuf[0];\n\t\tobuf[0] = 0;\n\t\tobuf++;\n\t\tosize++;\n\t}\n\n\t \n\tarc4_crypt(&state->arc4, obuf + 1, ibuf + 1, isize - 1);\n\n\tstate->stats.unc_bytes += osize;\n\tstate->stats.unc_packets++;\n\tstate->stats.comp_bytes += isize;\n\tstate->stats.comp_packets++;\n\n\t \n\tstate->sanity_errors >>= 1;\n\n\treturn osize;\n\nsanity_error:\n\tif (state->sanity_errors < SANITY_MAX)\n\t\treturn DECOMP_ERROR;\n\telse\n\t\t \n\t\treturn DECOMP_FATALERROR;\n}\n\n \nstatic void mppe_incomp(void *arg, unsigned char *ibuf, int icnt)\n{\n\tstruct ppp_mppe_state *state = (struct ppp_mppe_state *) arg;\n\n\tif (state->debug &&\n\t    (PPP_PROTOCOL(ibuf) >= 0x0021 && PPP_PROTOCOL(ibuf) <= 0x00fa))\n\t\tprintk(KERN_DEBUG\n\t\t       \"mppe_incomp[%d]: incompressible (unencrypted) data! \"\n\t\t       \"(proto %04x)\\n\", state->unit, PPP_PROTOCOL(ibuf));\n\n\tstate->stats.inc_bytes += icnt;\n\tstate->stats.inc_packets++;\n\tstate->stats.unc_bytes += icnt;\n\tstate->stats.unc_packets++;\n}\n\n \n\n \nstatic struct compressor ppp_mppe = {\n\t.compress_proto = CI_MPPE,\n\t.comp_alloc     = mppe_alloc,\n\t.comp_free      = mppe_free,\n\t.comp_init      = mppe_comp_init,\n\t.comp_reset     = mppe_comp_reset,\n\t.compress       = mppe_compress,\n\t.comp_stat      = mppe_comp_stats,\n\t.decomp_alloc   = mppe_alloc,\n\t.decomp_free    = mppe_free,\n\t.decomp_init    = mppe_decomp_init,\n\t.decomp_reset   = mppe_decomp_reset,\n\t.decompress     = mppe_decompress,\n\t.incomp         = mppe_incomp,\n\t.decomp_stat    = mppe_comp_stats,\n\t.owner          = THIS_MODULE,\n\t.comp_extra     = MPPE_PAD,\n};\n\n \n\nstatic int __init ppp_mppe_init(void)\n{\n\tint answer;\n\tif (fips_enabled || !crypto_has_ahash(\"sha1\", 0, CRYPTO_ALG_ASYNC))\n\t\treturn -ENODEV;\n\n\tsha_pad = kmalloc(sizeof(struct sha_pad), GFP_KERNEL);\n\tif (!sha_pad)\n\t\treturn -ENOMEM;\n\tsha_pad_init(sha_pad);\n\n\tanswer = ppp_register_compressor(&ppp_mppe);\n\n\tif (answer == 0)\n\t\tprintk(KERN_INFO \"PPP MPPE Compression module registered\\n\");\n\telse\n\t\tkfree(sha_pad);\n\n\treturn answer;\n}\n\nstatic void __exit ppp_mppe_cleanup(void)\n{\n\tppp_unregister_compressor(&ppp_mppe);\n\tkfree(sha_pad);\n}\n\nmodule_init(ppp_mppe_init);\nmodule_exit(ppp_mppe_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}