{
  "module_name": "bsd_comp.c",
  "hash_id": "bcb908feaecd1d7104fd0967bce3ba0abc97f15b1479dcfa75d289c6ac5b7ee8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ppp/bsd_comp.c",
  "human_readable_source": " \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n\n#include <linux/ppp_defs.h>\n\n#undef   PACKETPTR\n#define  PACKETPTR 1\n#include <linux/ppp-comp.h>\n#undef   PACKETPTR\n\n#include <asm/byteorder.h>\n\n \n\n \n\n#define BSD_VERSION(x)\t((x) >> 5)\n#define BSD_NBITS(x)\t((x) & 0x1F)\n\n#define BSD_CURRENT_VERSION\t1\n\n \n\nstruct bsd_dict {\n    union {\t\t\t\t \n\tunsigned long\tfcode;\n\tstruct {\n#if defined(__LITTLE_ENDIAN)\t\t \n\t    unsigned short\tprefix;\t \n\t    unsigned char\tsuffix;  \n\t    unsigned char\tpad;\n#elif defined(__BIG_ENDIAN)\t\t \n\t    unsigned char\tpad;\n\t    unsigned char\tsuffix;  \n\t    unsigned short\tprefix;  \n#else\n#error Endianness not defined...\n#endif\n\t} hs;\n    } f;\n    unsigned short codem1;\t\t \n    unsigned short cptr;\t\t \n};\n\nstruct bsd_db {\n    int\t    totlen;\t\t\t \n    unsigned int   hsize;\t\t \n    unsigned char  hshift;\t\t \n    unsigned char  n_bits;\t\t \n    unsigned char  maxbits;\t\t \n    unsigned char  debug;\t\t \n    unsigned char  unit;\t\t \n    unsigned short seqno;\t\t \n    unsigned int   mru;\t\t\t \n    unsigned int   maxmaxcode;\t\t \n    unsigned int   max_ent;\t\t \n    unsigned int   in_count;\t\t \n    unsigned int   bytes_out;\t\t \n    unsigned int   ratio;\t\t \n    unsigned int   checkpoint;\t\t \n    unsigned int   clear_count;\t\t \n    unsigned int   incomp_count;\t \n    unsigned int   incomp_bytes;\t \n    unsigned int   uncomp_count;\t \n    unsigned int   uncomp_bytes;\t \n    unsigned int   comp_count;\t\t \n    unsigned int   comp_bytes;\t\t \n    unsigned short  *lens;\t\t \n    struct bsd_dict *dict;\t\t \n};\n\n#define BSD_OVHD\t2\t\t \n#define MIN_BSD_BITS\t9\n#define BSD_INIT_BITS\tMIN_BSD_BITS\n#define MAX_BSD_BITS\t15\n\nstatic void\tbsd_free (void *state);\nstatic void\t*bsd_alloc(unsigned char *options, int opt_len, int decomp);\nstatic void\t*bsd_comp_alloc (unsigned char *options, int opt_len);\nstatic void\t*bsd_decomp_alloc (unsigned char *options, int opt_len);\n\nstatic int\tbsd_init        (void *db, unsigned char *options,\n\t\t\t         int opt_len, int unit, int debug, int decomp);\nstatic int\tbsd_comp_init   (void *state, unsigned char *options,\n\t\t\t         int opt_len, int unit, int opthdr, int debug);\nstatic int\tbsd_decomp_init (void *state, unsigned char *options,\n\t\t\t\t int opt_len, int unit, int opthdr, int mru,\n\t\t\t\t int debug);\n\nstatic void\tbsd_reset (void *state);\nstatic void\tbsd_comp_stats (void *state, struct compstat *stats);\n\nstatic int\tbsd_compress (void *state, unsigned char *rptr,\n\t\t\t      unsigned char *obuf, int isize, int osize);\nstatic void\tbsd_incomp (void *state, unsigned char *ibuf, int icnt);\n\nstatic int\tbsd_decompress (void *state, unsigned char *ibuf, int isize,\n\t\t\t\tunsigned char *obuf, int osize);\n\n \nextern int  ppp_register_compressor   (struct compressor *cp);\nextern void ppp_unregister_compressor (struct compressor *cp);\n\n \n#define CLEAR\t256\t\t\t \n#define FIRST\t257\t\t\t \n#define LAST\t255\n\n#define MAXCODE(b)\t((1 << (b)) - 1)\n#define BADCODEM1\tMAXCODE(MAX_BSD_BITS)\n\n#define BSD_HASH(prefix,suffix,hshift) ((((unsigned long)(suffix))<<(hshift)) \\\n\t\t\t\t\t ^ (unsigned long)(prefix))\n#define BSD_KEY(prefix,suffix)\t\t((((unsigned long)(suffix)) << 16) \\\n\t\t\t\t\t + (unsigned long)(prefix))\n\n#define CHECK_GAP\t10000\t\t \n\n#define RATIO_SCALE_LOG\t8\n#define RATIO_SCALE\t(1<<RATIO_SCALE_LOG)\n#define RATIO_MAX\t(0x7fffffff>>RATIO_SCALE_LOG)\n\n \n\nstatic void\nbsd_clear(struct bsd_db *db)\n{\n    db->clear_count++;\n    db->max_ent      = FIRST-1;\n    db->n_bits       = BSD_INIT_BITS;\n    db->bytes_out    = 0;\n    db->in_count     = 0;\n    db->ratio\t     = 0;\n    db->checkpoint   = CHECK_GAP;\n}\n\n \n\nstatic int bsd_check (struct bsd_db *db)\t \n  {\n    unsigned int new_ratio;\n\n    if (db->in_count >= db->checkpoint)\n      {\n\t \n\tif (db->in_count >= RATIO_MAX || db->bytes_out >= RATIO_MAX)\n\t  {\n\t    db->in_count  -= (db->in_count  >> 2);\n\t    db->bytes_out -= (db->bytes_out >> 2);\n\t  }\n\n\tdb->checkpoint = db->in_count + CHECK_GAP;\n\n\tif (db->max_ent >= db->maxmaxcode)\n\t  {\n\t     \n\n\t    new_ratio = db->in_count << RATIO_SCALE_LOG;\n\t    if (db->bytes_out != 0)\n\t      {\n\t\tnew_ratio /= db->bytes_out;\n\t      }\n\n\t    if (new_ratio < db->ratio || new_ratio < 1 * RATIO_SCALE)\n\t      {\n\t\tbsd_clear (db);\n\t\treturn 1;\n\t      }\n\t    db->ratio = new_ratio;\n\t  }\n      }\n    return 0;\n  }\n\n \n\nstatic void bsd_comp_stats (void *state, struct compstat *stats)\n  {\n    struct bsd_db *db = (struct bsd_db *) state;\n\n    stats->unc_bytes    = db->uncomp_bytes;\n    stats->unc_packets  = db->uncomp_count;\n    stats->comp_bytes   = db->comp_bytes;\n    stats->comp_packets = db->comp_count;\n    stats->inc_bytes    = db->incomp_bytes;\n    stats->inc_packets  = db->incomp_count;\n    stats->in_count     = db->in_count;\n    stats->bytes_out    = db->bytes_out;\n  }\n\n \n\nstatic void bsd_reset (void *state)\n  {\n    struct bsd_db *db = (struct bsd_db *) state;\n\n    bsd_clear(db);\n\n    db->seqno       = 0;\n    db->clear_count = 0;\n  }\n\n \n\nstatic void bsd_free (void *state)\n{\n\tstruct bsd_db *db = state;\n\n\tif (!db)\n\t\treturn;\n\n \n\tvfree(db->dict);\n\tdb->dict = NULL;\n \n\tvfree(db->lens);\n\tdb->lens = NULL;\n \n\tkfree(db);\n}\n\n \n\nstatic void *bsd_alloc (unsigned char *options, int opt_len, int decomp)\n  {\n    int bits;\n    unsigned int hsize, hshift, maxmaxcode;\n    struct bsd_db *db;\n\n    if (opt_len != 3 || options[0] != CI_BSD_COMPRESS || options[1] != 3\n\t|| BSD_VERSION(options[2]) != BSD_CURRENT_VERSION)\n      {\n\treturn NULL;\n      }\n\n    bits = BSD_NBITS(options[2]);\n\n    switch (bits)\n      {\n    case 9:\t\t\t \n    case 10:\t\t\t \n    case 11:\t\t\t \n    case 12:\t\t\t \n\thsize = 5003;\n\thshift = 4;\n\tbreak;\n    case 13:\t\t\t \n\thsize = 9001;\n\thshift = 5;\n\tbreak;\n    case 14:\t\t\t \n\thsize = 18013;\n\thshift = 6;\n\tbreak;\n    case 15:\t\t\t \n\thsize = 35023;\n\thshift = 7;\n\tbreak;\n    case 16:\t\t\t \n\t \t \n\t \t \n\t \n    default:\n\treturn NULL;\n      }\n \n    maxmaxcode = MAXCODE(bits);\n    db         = kzalloc(sizeof (struct bsd_db),\n\t\t\t\t\t    GFP_KERNEL);\n    if (!db)\n      {\n\treturn NULL;\n      }\n\n \n    db->dict = vmalloc(array_size(hsize, sizeof(struct bsd_dict)));\n    if (!db->dict)\n      {\n\tbsd_free (db);\n\treturn NULL;\n      }\n\n \n    if (!decomp)\n      {\n\tdb->lens = NULL;\n      }\n \n    else\n      {\n        db->lens = vmalloc(array_size(sizeof(db->lens[0]), (maxmaxcode + 1)));\n\tif (!db->lens)\n\t  {\n\t    bsd_free (db);\n\t    return NULL;\n\t  }\n      }\n \n    db->totlen     = sizeof (struct bsd_db)   +\n\t\t    (sizeof (struct bsd_dict) * hsize);\n\n    db->hsize      = hsize;\n    db->hshift     = hshift;\n    db->maxmaxcode = maxmaxcode;\n    db->maxbits    = bits;\n\n    return (void *) db;\n  }\n\nstatic void *bsd_comp_alloc (unsigned char *options, int opt_len)\n  {\n    return bsd_alloc (options, opt_len, 0);\n  }\n\nstatic void *bsd_decomp_alloc (unsigned char *options, int opt_len)\n  {\n    return bsd_alloc (options, opt_len, 1);\n  }\n\n \n\nstatic int bsd_init (void *state, unsigned char *options,\n\t\t     int opt_len, int unit, int debug, int decomp)\n  {\n    struct bsd_db *db = state;\n    int indx;\n\n    if ((opt_len != 3) || (options[0] != CI_BSD_COMPRESS) || (options[1] != 3)\n\t|| (BSD_VERSION(options[2]) != BSD_CURRENT_VERSION)\n\t|| (BSD_NBITS(options[2]) != db->maxbits)\n\t|| (decomp && db->lens == NULL))\n      {\n\treturn 0;\n      }\n\n    if (decomp)\n      {\n\tindx = LAST;\n\tdo\n\t  {\n\t    db->lens[indx] = 1;\n\t  }\n\twhile (indx-- > 0);\n      }\n\n    indx = db->hsize;\n    while (indx-- != 0)\n      {\n\tdb->dict[indx].codem1 = BADCODEM1;\n\tdb->dict[indx].cptr   = 0;\n      }\n\n    db->unit = unit;\n    db->mru  = 0;\n#ifndef DEBUG\n    if (debug)\n#endif\n      db->debug = 1;\n\n    bsd_reset(db);\n\n    return 1;\n  }\n\nstatic int bsd_comp_init (void *state, unsigned char *options,\n\t\t\t  int opt_len, int unit, int opthdr, int debug)\n  {\n    return bsd_init (state, options, opt_len, unit, debug, 0);\n  }\n\nstatic int bsd_decomp_init (void *state, unsigned char *options,\n\t\t\t    int opt_len, int unit, int opthdr, int mru,\n\t\t\t    int debug)\n  {\n    return bsd_init (state, options, opt_len, unit, debug, 1);\n  }\n\n \n\n#define dict_ptrx(p,idx) &(p->dict[idx])\n#define lens_ptrx(p,idx) &(p->lens[idx])\n\n#ifdef DEBUG\nstatic unsigned short *lens_ptr(struct bsd_db *db, int idx)\n  {\n    if ((unsigned int) idx > (unsigned int) db->maxmaxcode)\n      {\n\tprintk (\"<9>ppp: lens_ptr(%d) > max\\n\", idx);\n\tidx = 0;\n      }\n    return lens_ptrx (db, idx);\n  }\n\nstatic struct bsd_dict *dict_ptr(struct bsd_db *db, int idx)\n  {\n    if ((unsigned int) idx >= (unsigned int) db->hsize)\n      {\n\tprintk (\"<9>ppp: dict_ptr(%d) > max\\n\", idx);\n\tidx = 0;\n      }\n    return dict_ptrx (db, idx);\n  }\n\n#else\n#define lens_ptr(db,idx) lens_ptrx(db,idx)\n#define dict_ptr(db,idx) dict_ptrx(db,idx)\n#endif\n\n \n\nstatic int bsd_compress (void *state, unsigned char *rptr, unsigned char *obuf,\n\t\t\t int isize, int osize)\n  {\n    struct bsd_db *db;\n    int hshift;\n    unsigned int max_ent;\n    unsigned int n_bits;\n    unsigned int bitno;\n    unsigned long accm;\n    int ent;\n    unsigned long fcode;\n    struct bsd_dict *dictp;\n    unsigned char c;\n    int hval;\n    int disp;\n    int ilen;\n    int mxcode;\n    unsigned char *wptr;\n    int olen;\n\n#define PUTBYTE(v)\t\t\t\\\n  {\t\t\t\t\t\\\n    ++olen;\t\t\t\t\\\n    if (wptr)\t\t\t\t\\\n      {\t\t\t\t\t\\\n\t*wptr++ = (unsigned char) (v);\t\\\n\tif (olen >= osize)\t\t\\\n\t  {\t\t\t\t\\\n\t    wptr = NULL;\t\t\\\n\t  }\t\t\t\t\\\n      }\t\t\t\t\t\\\n  }\n\n#define OUTPUT(ent)\t\t\t\\\n  {\t\t\t\t\t\\\n    bitno -= n_bits;\t\t\t\\\n    accm |= ((ent) << bitno);\t\t\\\n    do\t\t\t\t\t\\\n      {\t\t\t\t\t\\\n\tPUTBYTE(accm >> 24);\t\t\\\n\taccm <<= 8;\t\t\t\\\n\tbitno += 8;\t\t\t\\\n      }\t\t\t\t\t\\\n    while (bitno <= 24);\t\t\\\n  }\n\n   \n\n    ent = PPP_PROTOCOL(rptr);\n    if (ent < 0x21 || ent > 0xf9)\n      {\n\treturn 0;\n      }\n\n    db      = (struct bsd_db *) state;\n    hshift  = db->hshift;\n    max_ent = db->max_ent;\n    n_bits  = db->n_bits;\n    bitno   = 32;\n    accm    = 0;\n    mxcode  = MAXCODE (n_bits);\n\n     \n    wptr  = obuf;\n    olen  = PPP_HDRLEN + BSD_OVHD;\n\n    if (osize > isize)\n      {\n\tosize = isize;\n      }\n\n     \n    if (wptr)\n      {\n\t*wptr++ = PPP_ADDRESS(rptr);\n\t*wptr++ = PPP_CONTROL(rptr);\n\t*wptr++ = 0;\n\t*wptr++ = PPP_COMP;\n\t*wptr++ = db->seqno >> 8;\n\t*wptr++ = db->seqno;\n      }\n\n     \n    rptr  += PPP_HDRLEN;\n    isize -= PPP_HDRLEN;\n    ilen   = ++isize;\t \n\n    while (--ilen > 0)\n      {\n\tc     = *rptr++;\n\tfcode = BSD_KEY  (ent, c);\n\thval  = BSD_HASH (ent, c, hshift);\n\tdictp = dict_ptr (db, hval);\n\n\t \n\tif (dictp->codem1 >= max_ent)\n\t  {\n\t    goto nomatch;\n\t  }\n\n\tif (dictp->f.fcode == fcode)\n\t  {\n\t    ent = dictp->codem1 + 1;\n\t    continue;\t \n\t  }\n\n\t \n\tdisp = (hval == 0) ? 1 : hval;\n\n\tdo\n\t  {\n\t    hval += disp;\n\t    if (hval >= db->hsize)\n\t      {\n\t\thval -= db->hsize;\n\t      }\n\t    dictp = dict_ptr (db, hval);\n\t    if (dictp->codem1 >= max_ent)\n\t      {\n\t\tgoto nomatch;\n\t      }\n\t  }\n\twhile (dictp->f.fcode != fcode);\n\n\tent = dictp->codem1 + 1;\t \n\tcontinue;\n\nnomatch:\n\tOUTPUT(ent);\t\t \n\n\t \n\tif (max_ent < db->maxmaxcode)\n\t  {\n\t    struct bsd_dict *dictp2;\n\t    struct bsd_dict *dictp3;\n\t    int    indx;\n\n\t     \n\t    if (max_ent >= mxcode)\n\t      {\n\t\tdb->n_bits = ++n_bits;\n\t\tmxcode     = MAXCODE (n_bits);\n\t      }\n\n\t     \n\n\t    dictp2 = dict_ptr (db, max_ent + 1);\n\t    indx   = dictp2->cptr;\n\t    dictp3 = dict_ptr (db, indx);\n\n\t    if (dictp3->codem1 == max_ent)\n\t      {\n\t\tdictp3->codem1 = BADCODEM1;\n\t      }\n\n\t    dictp2->cptr   = hval;\n\t    dictp->codem1  = max_ent;\n\t    dictp->f.fcode = fcode;\n\t    db->max_ent    = ++max_ent;\n\n\t    if (db->lens)\n\t      {\n\t\tunsigned short *len1 = lens_ptr (db, max_ent);\n\t\tunsigned short *len2 = lens_ptr (db, ent);\n\t\t*len1 = *len2 + 1;\n\t      }\n\t  }\n\tent = c;\n      }\n\n    OUTPUT(ent);\t\t \n\n    db->bytes_out    += olen - PPP_HDRLEN - BSD_OVHD;\n    db->uncomp_bytes += isize;\n    db->in_count     += isize;\n    ++db->uncomp_count;\n    ++db->seqno;\n\n    if (bitno < 32)\n      {\n\t++db->bytes_out;  \n      }\n\n     \n\n    if (bsd_check(db))\n      {\n\tOUTPUT (CLEAR);\n      }\n\n     \n\n    if (bitno != 32)\n      {\n\tPUTBYTE((accm | (0xff << (bitno-8))) >> 24);\n      }\n\n     \n\n    if (max_ent >= mxcode && max_ent < db->maxmaxcode)\n      {\n\tdb->n_bits++;\n      }\n\n     \n    if (wptr == NULL)\n      {\n\t++db->incomp_count;\n\tdb->incomp_bytes += isize;\n\tolen              = 0;\n      }\n    else  \n      {\n\t++db->comp_count;\n\tdb->comp_bytes += olen;\n      }\n\n     \n    return olen;\n#undef OUTPUT\n#undef PUTBYTE\n  }\n\n \n\nstatic void bsd_incomp (void *state, unsigned char *ibuf, int icnt)\n  {\n    (void) bsd_compress (state, ibuf, (char *) 0, icnt, 0);\n  }\n\n \n\nstatic int bsd_decompress (void *state, unsigned char *ibuf, int isize,\n\t\t\t   unsigned char *obuf, int osize)\n  {\n    struct bsd_db *db;\n    unsigned int max_ent;\n    unsigned long accm;\n    unsigned int bitno;\t\t \n    unsigned int n_bits;\n    unsigned int tgtbitno;\t \n    struct bsd_dict *dictp;\n    int explen;\n    int seq;\n    unsigned int incode;\n    unsigned int oldcode;\n    unsigned int finchar;\n    unsigned char *p;\n    unsigned char *wptr;\n    int adrs;\n    int ctrl;\n    int ilen;\n    int codelen;\n    int extra;\n\n    db       = (struct bsd_db *) state;\n    max_ent  = db->max_ent;\n    accm     = 0;\n    bitno    = 32;\t\t \n    n_bits   = db->n_bits;\n    tgtbitno = 32 - n_bits;\t \n\n     \n\n    adrs  = PPP_ADDRESS (ibuf);\n    ctrl  = PPP_CONTROL (ibuf);\n\n    seq   = (ibuf[4] << 8) + ibuf[5];\n\n    ibuf += (PPP_HDRLEN + 2);\n    ilen  = isize - (PPP_HDRLEN + 2);\n\n     \n\n    if (seq != db->seqno)\n      {\n\tif (db->debug)\n\t  {\n\t    printk(\"bsd_decomp%d: bad sequence # %d, expected %d\\n\",\n\t\t   db->unit, seq, db->seqno - 1);\n\t  }\n\treturn DECOMP_ERROR;\n      }\n\n    ++db->seqno;\n    db->bytes_out += ilen;\n\n     \n\n    wptr    = obuf;\n    *wptr++ = adrs;\n    *wptr++ = ctrl;\n    *wptr++ = 0;\n\n    oldcode = CLEAR;\n    explen  = 3;\n\n     \n\n    for (;;)\n      {\n\tif (ilen-- <= 0)\n\t  {\n\t    db->in_count += (explen - 3);  \n\t    break;\n\t  }\n\n\t \n\n\tbitno -= 8;\n\taccm  |= *ibuf++ << bitno;\n\tif (tgtbitno < bitno)\n\t  {\n\t    continue;\n\t  }\n\n\tincode = accm >> tgtbitno;\n\taccm <<= n_bits;\n\tbitno += n_bits;\n\n\t \n\n\tif (incode == CLEAR)\n\t  {\n\t    if (ilen > 0)\n\t      {\n\t\tif (db->debug)\n\t\t  {\n\t\t    printk(\"bsd_decomp%d: bad CLEAR\\n\", db->unit);\n\t\t  }\n\t\treturn DECOMP_FATALERROR;\t \n\t      }\n\n\t    bsd_clear(db);\n\t    break;\n\t  }\n\n\tif ((incode > max_ent + 2) || (incode > db->maxmaxcode)\n\t    || (incode > max_ent && oldcode == CLEAR))\n\t  {\n\t    if (db->debug)\n\t      {\n\t\tprintk(\"bsd_decomp%d: bad code 0x%x oldcode=0x%x \",\n\t\t       db->unit, incode, oldcode);\n\t\tprintk(\"max_ent=0x%x explen=%d seqno=%d\\n\",\n\t\t       max_ent, explen, db->seqno);\n\t      }\n\t    return DECOMP_FATALERROR;\t \n\t  }\n\n\t \n\tif (incode > max_ent)\n\t  {\n\t    finchar = oldcode;\n\t    extra   = 1;\n\t  }\n\telse\n\t  {\n\t    finchar = incode;\n\t    extra   = 0;\n\t  }\n\n\tcodelen = *(lens_ptr (db, finchar));\n\texplen += codelen + extra;\n\tif (explen > osize)\n\t  {\n\t    if (db->debug)\n\t      {\n\t\tprintk(\"bsd_decomp%d: ran out of mru\\n\", db->unit);\n#ifdef DEBUG\n\t\tprintk(\"  len=%d, finchar=0x%x, codelen=%d, explen=%d\\n\",\n\t\t       ilen, finchar, codelen, explen);\n#endif\n\t      }\n\t    return DECOMP_FATALERROR;\n\t  }\n\n\t \n\n\twptr += codelen;\n\tp     = wptr;\n\twhile (finchar > LAST)\n\t  {\n\t    struct bsd_dict *dictp2 = dict_ptr (db, finchar);\n\n\t    dictp = dict_ptr (db, dictp2->cptr);\n#ifdef DEBUG\n\t    if (--codelen <= 0 || dictp->codem1 != finchar-1)\n\t      {\n\t\tif (codelen <= 0)\n\t\t  {\n\t\t    printk(\"bsd_decomp%d: fell off end of chain \", db->unit);\n\t\t    printk(\"0x%x at 0x%x by 0x%x, max_ent=0x%x\\n\",\n\t\t\t   incode, finchar, dictp2->cptr, max_ent);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (dictp->codem1 != finchar-1)\n\t\t      {\n\t\t\tprintk(\"bsd_decomp%d: bad code chain 0x%x \"\n\t\t\t       \"finchar=0x%x \",\n\t\t\t       db->unit, incode, finchar);\n\n\t\t\tprintk(\"oldcode=0x%x cptr=0x%x codem1=0x%x\\n\",\n\t\t\t       oldcode, dictp2->cptr, dictp->codem1);\n\t\t      }\n\t\t  }\n\t\treturn DECOMP_FATALERROR;\n\t      }\n#endif\n\t    *--p    = dictp->f.hs.suffix;\n\t    finchar = dictp->f.hs.prefix;\n\t  }\n\t*--p = finchar;\n\n#ifdef DEBUG\n\tif (--codelen != 0)\n\t  {\n\t    printk(\"bsd_decomp%d: short by %d after code 0x%x, max_ent=0x%x\\n\",\n\t\t   db->unit, codelen, incode, max_ent);\n\t  }\n#endif\n\n\tif (extra)\t\t \n\t  {\n\t    *wptr++ = finchar;\n\t  }\n\n\t \n\n\tif (oldcode != CLEAR && max_ent < db->maxmaxcode)\n\t  {\n\t    struct bsd_dict *dictp2, *dictp3;\n\t    unsigned short  *lens1,  *lens2;\n\t    unsigned long fcode;\n\t    int hval, disp, indx;\n\n\t    fcode = BSD_KEY(oldcode,finchar);\n\t    hval  = BSD_HASH(oldcode,finchar,db->hshift);\n\t    dictp = dict_ptr (db, hval);\n\n\t     \n\t    if (dictp->codem1 < max_ent)\n\t      {\n\t\tdisp = (hval == 0) ? 1 : hval;\n\t\tdo\n\t\t  {\n\t\t    hval += disp;\n\t\t    if (hval >= db->hsize)\n\t\t      {\n\t\t\thval -= db->hsize;\n\t\t      }\n\t\t    dictp = dict_ptr (db, hval);\n\t\t  }\n\t\twhile (dictp->codem1 < max_ent);\n\t      }\n\n\t     \n\n\t    dictp2 = dict_ptr (db, max_ent + 1);\n\t    indx   = dictp2->cptr;\n\t    dictp3 = dict_ptr (db, indx);\n\n\t    if (dictp3->codem1 == max_ent)\n\t      {\n\t\tdictp3->codem1 = BADCODEM1;\n\t      }\n\n\t    dictp2->cptr   = hval;\n\t    dictp->codem1  = max_ent;\n\t    dictp->f.fcode = fcode;\n\t    db->max_ent    = ++max_ent;\n\n\t     \n\t    lens1  = lens_ptr (db, max_ent);\n\t    lens2  = lens_ptr (db, oldcode);\n\t    *lens1 = *lens2 + 1;\n\n\t     \n\t    if (max_ent >= MAXCODE(n_bits) && max_ent < db->maxmaxcode)\n\t      {\n\t\tdb->n_bits = ++n_bits;\n\t\ttgtbitno   = 32-n_bits;\n\t      }\n\t  }\n\toldcode = incode;\n      }\n\n    ++db->comp_count;\n    ++db->uncomp_count;\n    db->comp_bytes   += isize - BSD_OVHD - PPP_HDRLEN;\n    db->uncomp_bytes += explen;\n\n    if (bsd_check(db))\n      {\n\tif (db->debug)\n\t  {\n\t    printk(\"bsd_decomp%d: peer should have cleared dictionary on %d\\n\",\n\t\t   db->unit, db->seqno - 1);\n\t  }\n      }\n    return explen;\n  }\n\n \n\nstatic struct compressor ppp_bsd_compress = {\n\t.compress_proto =\tCI_BSD_COMPRESS,\n\t.comp_alloc =\t\tbsd_comp_alloc,\n\t.comp_free =\t\tbsd_free,\n\t.comp_init =\t\tbsd_comp_init,\n\t.comp_reset =\t\tbsd_reset,\n\t.compress =\t\tbsd_compress,\n\t.comp_stat =\t\tbsd_comp_stats,\n\t.decomp_alloc =\t\tbsd_decomp_alloc,\n\t.decomp_free =\t\tbsd_free,\n\t.decomp_init =\t\tbsd_decomp_init,\n\t.decomp_reset =\t\tbsd_reset,\n\t.decompress =\t\tbsd_decompress,\n\t.incomp =\t\tbsd_incomp,\n\t.decomp_stat =\t\tbsd_comp_stats,\n\t.owner =\t\tTHIS_MODULE\n};\n\n \n\nstatic int __init bsdcomp_init(void)\n{\n\tint answer = ppp_register_compressor(&ppp_bsd_compress);\n\tif (answer == 0)\n\t\tprintk(KERN_INFO \"PPP BSD Compression module registered\\n\");\n\treturn answer;\n}\n\nstatic void __exit bsdcomp_cleanup(void)\n{\n\tppp_unregister_compressor(&ppp_bsd_compress);\n}\n\nmodule_init(bsdcomp_init);\nmodule_exit(bsdcomp_cleanup);\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"ppp-compress-\" __stringify(CI_BSD_COMPRESS));\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}