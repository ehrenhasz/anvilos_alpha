{
  "module_name": "tun.c",
  "hash_id": "a40e9850b80846065f67ff570cd8e112c90a84c77a5973659da6195e93a5dde5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/tun.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRV_NAME\t\"tun\"\n#define DRV_VERSION\t\"1.6\"\n#define DRV_DESCRIPTION\t\"Universal TUN/TAP device driver\"\n#define DRV_COPYRIGHT\t\"(C) 1999-2004 Max Krasnyansky <maxk@qualcomm.com>\"\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/major.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/fcntl.h>\n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/miscdevice.h>\n#include <linux/ethtool.h>\n#include <linux/rtnetlink.h>\n#include <linux/compat.h>\n#include <linux/if.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/if_tun.h>\n#include <linux/if_vlan.h>\n#include <linux/crc32.h>\n#include <linux/nsproxy.h>\n#include <linux/virtio_net.h>\n#include <linux/rcupdate.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/rtnetlink.h>\n#include <net/sock.h>\n#include <net/xdp.h>\n#include <net/ip_tunnels.h>\n#include <linux/seq_file.h>\n#include <linux/uio.h>\n#include <linux/skb_array.h>\n#include <linux/bpf.h>\n#include <linux/bpf_trace.h>\n#include <linux/mutex.h>\n#include <linux/ieee802154.h>\n#include <linux/if_ltalk.h>\n#include <uapi/linux/if_fddi.h>\n#include <uapi/linux/if_hippi.h>\n#include <uapi/linux/if_fc.h>\n#include <net/ax25.h>\n#include <net/rose.h>\n#include <net/6lowpan.h>\n\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n\nstatic void tun_default_link_ksettings(struct net_device *dev,\n\t\t\t\t       struct ethtool_link_ksettings *cmd);\n\n#define TUN_RX_PAD (NET_IP_ALIGN + NET_SKB_PAD)\n\n \n\n \n#define TUN_FASYNC\tIFF_ATTACH_QUEUE\n \n#define TUN_VNET_LE     0x80000000\n#define TUN_VNET_BE     0x40000000\n\n#define TUN_FEATURES (IFF_NO_PI | IFF_ONE_QUEUE | IFF_VNET_HDR | \\\n\t\t      IFF_MULTI_QUEUE | IFF_NAPI | IFF_NAPI_FRAGS)\n\n#define GOODCOPY_LEN 128\n\n#define FLT_EXACT_COUNT 8\nstruct tap_filter {\n\tunsigned int    count;     \n\tu32             mask[2];   \n\tunsigned char\taddr[FLT_EXACT_COUNT][ETH_ALEN];\n};\n\n \n#define MAX_TAP_QUEUES 256\n#define MAX_TAP_FLOWS  4096\n\n#define TUN_FLOW_EXPIRE (3 * HZ)\n\n \nstruct tun_file {\n\tstruct sock sk;\n\tstruct socket socket;\n\tstruct tun_struct __rcu *tun;\n\tstruct fasync_struct *fasync;\n\t \n\tunsigned int flags;\n\tunion {\n\t\tu16 queue_index;\n\t\tunsigned int ifindex;\n\t};\n\tstruct napi_struct napi;\n\tbool napi_enabled;\n\tbool napi_frags_enabled;\n\tstruct mutex napi_mutex;\t \n\tstruct list_head next;\n\tstruct tun_struct *detached;\n\tstruct ptr_ring tx_ring;\n\tstruct xdp_rxq_info xdp_rxq;\n};\n\nstruct tun_page {\n\tstruct page *page;\n\tint count;\n};\n\nstruct tun_flow_entry {\n\tstruct hlist_node hash_link;\n\tstruct rcu_head rcu;\n\tstruct tun_struct *tun;\n\n\tu32 rxhash;\n\tu32 rps_rxhash;\n\tint queue_index;\n\tunsigned long updated ____cacheline_aligned_in_smp;\n};\n\n#define TUN_NUM_FLOW_ENTRIES 1024\n#define TUN_MASK_FLOW_ENTRIES (TUN_NUM_FLOW_ENTRIES - 1)\n\nstruct tun_prog {\n\tstruct rcu_head rcu;\n\tstruct bpf_prog *prog;\n};\n\n \nstruct tun_struct {\n\tstruct tun_file __rcu\t*tfiles[MAX_TAP_QUEUES];\n\tunsigned int            numqueues;\n\tunsigned int \t\tflags;\n\tkuid_t\t\t\towner;\n\tkgid_t\t\t\tgroup;\n\n\tstruct net_device\t*dev;\n\tnetdev_features_t\tset_features;\n#define TUN_USER_FEATURES (NETIF_F_HW_CSUM|NETIF_F_TSO_ECN|NETIF_F_TSO| \\\n\t\t\t  NETIF_F_TSO6 | NETIF_F_GSO_UDP_L4)\n\n\tint\t\t\talign;\n\tint\t\t\tvnet_hdr_sz;\n\tint\t\t\tsndbuf;\n\tstruct tap_filter\ttxflt;\n\tstruct sock_fprog\tfprog;\n\t \n\tbool\t\t\tfilter_attached;\n\tu32\t\t\tmsg_enable;\n\tspinlock_t lock;\n\tstruct hlist_head flows[TUN_NUM_FLOW_ENTRIES];\n\tstruct timer_list flow_gc_timer;\n\tunsigned long ageing_time;\n\tunsigned int numdisabled;\n\tstruct list_head disabled;\n\tvoid *security;\n\tu32 flow_count;\n\tu32 rx_batched;\n\tatomic_long_t rx_frame_errors;\n\tstruct bpf_prog __rcu *xdp_prog;\n\tstruct tun_prog __rcu *steering_prog;\n\tstruct tun_prog __rcu *filter_prog;\n\tstruct ethtool_link_ksettings link_ksettings;\n\t \n\tstruct file *file;\n\tstruct ifreq *ifr;\n};\n\nstruct veth {\n\t__be16 h_vlan_proto;\n\t__be16 h_vlan_TCI;\n};\n\nstatic void tun_flow_init(struct tun_struct *tun);\nstatic void tun_flow_uninit(struct tun_struct *tun);\n\nstatic int tun_napi_receive(struct napi_struct *napi, int budget)\n{\n\tstruct tun_file *tfile = container_of(napi, struct tun_file, napi);\n\tstruct sk_buff_head *queue = &tfile->sk.sk_write_queue;\n\tstruct sk_buff_head process_queue;\n\tstruct sk_buff *skb;\n\tint received = 0;\n\n\t__skb_queue_head_init(&process_queue);\n\n\tspin_lock(&queue->lock);\n\tskb_queue_splice_tail_init(queue, &process_queue);\n\tspin_unlock(&queue->lock);\n\n\twhile (received < budget && (skb = __skb_dequeue(&process_queue))) {\n\t\tnapi_gro_receive(napi, skb);\n\t\t++received;\n\t}\n\n\tif (!skb_queue_empty(&process_queue)) {\n\t\tspin_lock(&queue->lock);\n\t\tskb_queue_splice(&process_queue, queue);\n\t\tspin_unlock(&queue->lock);\n\t}\n\n\treturn received;\n}\n\nstatic int tun_napi_poll(struct napi_struct *napi, int budget)\n{\n\tunsigned int received;\n\n\treceived = tun_napi_receive(napi, budget);\n\n\tif (received < budget)\n\t\tnapi_complete_done(napi, received);\n\n\treturn received;\n}\n\nstatic void tun_napi_init(struct tun_struct *tun, struct tun_file *tfile,\n\t\t\t  bool napi_en, bool napi_frags)\n{\n\ttfile->napi_enabled = napi_en;\n\ttfile->napi_frags_enabled = napi_en && napi_frags;\n\tif (napi_en) {\n\t\tnetif_napi_add_tx(tun->dev, &tfile->napi, tun_napi_poll);\n\t\tnapi_enable(&tfile->napi);\n\t}\n}\n\nstatic void tun_napi_enable(struct tun_file *tfile)\n{\n\tif (tfile->napi_enabled)\n\t\tnapi_enable(&tfile->napi);\n}\n\nstatic void tun_napi_disable(struct tun_file *tfile)\n{\n\tif (tfile->napi_enabled)\n\t\tnapi_disable(&tfile->napi);\n}\n\nstatic void tun_napi_del(struct tun_file *tfile)\n{\n\tif (tfile->napi_enabled)\n\t\tnetif_napi_del(&tfile->napi);\n}\n\nstatic bool tun_napi_frags_enabled(const struct tun_file *tfile)\n{\n\treturn tfile->napi_frags_enabled;\n}\n\n#ifdef CONFIG_TUN_VNET_CROSS_LE\nstatic inline bool tun_legacy_is_little_endian(struct tun_struct *tun)\n{\n\treturn tun->flags & TUN_VNET_BE ? false :\n\t\tvirtio_legacy_is_little_endian();\n}\n\nstatic long tun_get_vnet_be(struct tun_struct *tun, int __user *argp)\n{\n\tint be = !!(tun->flags & TUN_VNET_BE);\n\n\tif (put_user(be, argp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long tun_set_vnet_be(struct tun_struct *tun, int __user *argp)\n{\n\tint be;\n\n\tif (get_user(be, argp))\n\t\treturn -EFAULT;\n\n\tif (be)\n\t\ttun->flags |= TUN_VNET_BE;\n\telse\n\t\ttun->flags &= ~TUN_VNET_BE;\n\n\treturn 0;\n}\n#else\nstatic inline bool tun_legacy_is_little_endian(struct tun_struct *tun)\n{\n\treturn virtio_legacy_is_little_endian();\n}\n\nstatic long tun_get_vnet_be(struct tun_struct *tun, int __user *argp)\n{\n\treturn -EINVAL;\n}\n\nstatic long tun_set_vnet_be(struct tun_struct *tun, int __user *argp)\n{\n\treturn -EINVAL;\n}\n#endif  \n\nstatic inline bool tun_is_little_endian(struct tun_struct *tun)\n{\n\treturn tun->flags & TUN_VNET_LE ||\n\t\ttun_legacy_is_little_endian(tun);\n}\n\nstatic inline u16 tun16_to_cpu(struct tun_struct *tun, __virtio16 val)\n{\n\treturn __virtio16_to_cpu(tun_is_little_endian(tun), val);\n}\n\nstatic inline __virtio16 cpu_to_tun16(struct tun_struct *tun, u16 val)\n{\n\treturn __cpu_to_virtio16(tun_is_little_endian(tun), val);\n}\n\nstatic inline u32 tun_hashfn(u32 rxhash)\n{\n\treturn rxhash & TUN_MASK_FLOW_ENTRIES;\n}\n\nstatic struct tun_flow_entry *tun_flow_find(struct hlist_head *head, u32 rxhash)\n{\n\tstruct tun_flow_entry *e;\n\n\thlist_for_each_entry_rcu(e, head, hash_link) {\n\t\tif (e->rxhash == rxhash)\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}\n\nstatic struct tun_flow_entry *tun_flow_create(struct tun_struct *tun,\n\t\t\t\t\t      struct hlist_head *head,\n\t\t\t\t\t      u32 rxhash, u16 queue_index)\n{\n\tstruct tun_flow_entry *e = kmalloc(sizeof(*e), GFP_ATOMIC);\n\n\tif (e) {\n\t\tnetif_info(tun, tx_queued, tun->dev,\n\t\t\t   \"create flow: hash %u index %u\\n\",\n\t\t\t   rxhash, queue_index);\n\t\te->updated = jiffies;\n\t\te->rxhash = rxhash;\n\t\te->rps_rxhash = 0;\n\t\te->queue_index = queue_index;\n\t\te->tun = tun;\n\t\thlist_add_head_rcu(&e->hash_link, head);\n\t\t++tun->flow_count;\n\t}\n\treturn e;\n}\n\nstatic void tun_flow_delete(struct tun_struct *tun, struct tun_flow_entry *e)\n{\n\tnetif_info(tun, tx_queued, tun->dev, \"delete flow: hash %u index %u\\n\",\n\t\t   e->rxhash, e->queue_index);\n\thlist_del_rcu(&e->hash_link);\n\tkfree_rcu(e, rcu);\n\t--tun->flow_count;\n}\n\nstatic void tun_flow_flush(struct tun_struct *tun)\n{\n\tint i;\n\n\tspin_lock_bh(&tun->lock);\n\tfor (i = 0; i < TUN_NUM_FLOW_ENTRIES; i++) {\n\t\tstruct tun_flow_entry *e;\n\t\tstruct hlist_node *n;\n\n\t\thlist_for_each_entry_safe(e, n, &tun->flows[i], hash_link)\n\t\t\ttun_flow_delete(tun, e);\n\t}\n\tspin_unlock_bh(&tun->lock);\n}\n\nstatic void tun_flow_delete_by_queue(struct tun_struct *tun, u16 queue_index)\n{\n\tint i;\n\n\tspin_lock_bh(&tun->lock);\n\tfor (i = 0; i < TUN_NUM_FLOW_ENTRIES; i++) {\n\t\tstruct tun_flow_entry *e;\n\t\tstruct hlist_node *n;\n\n\t\thlist_for_each_entry_safe(e, n, &tun->flows[i], hash_link) {\n\t\t\tif (e->queue_index == queue_index)\n\t\t\t\ttun_flow_delete(tun, e);\n\t\t}\n\t}\n\tspin_unlock_bh(&tun->lock);\n}\n\nstatic void tun_flow_cleanup(struct timer_list *t)\n{\n\tstruct tun_struct *tun = from_timer(tun, t, flow_gc_timer);\n\tunsigned long delay = tun->ageing_time;\n\tunsigned long next_timer = jiffies + delay;\n\tunsigned long count = 0;\n\tint i;\n\n\tspin_lock(&tun->lock);\n\tfor (i = 0; i < TUN_NUM_FLOW_ENTRIES; i++) {\n\t\tstruct tun_flow_entry *e;\n\t\tstruct hlist_node *n;\n\n\t\thlist_for_each_entry_safe(e, n, &tun->flows[i], hash_link) {\n\t\t\tunsigned long this_timer;\n\n\t\t\tthis_timer = e->updated + delay;\n\t\t\tif (time_before_eq(this_timer, jiffies)) {\n\t\t\t\ttun_flow_delete(tun, e);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (time_before(this_timer, next_timer))\n\t\t\t\tnext_timer = this_timer;\n\t\t}\n\t}\n\n\tif (count)\n\t\tmod_timer(&tun->flow_gc_timer, round_jiffies_up(next_timer));\n\tspin_unlock(&tun->lock);\n}\n\nstatic void tun_flow_update(struct tun_struct *tun, u32 rxhash,\n\t\t\t    struct tun_file *tfile)\n{\n\tstruct hlist_head *head;\n\tstruct tun_flow_entry *e;\n\tunsigned long delay = tun->ageing_time;\n\tu16 queue_index = tfile->queue_index;\n\n\thead = &tun->flows[tun_hashfn(rxhash)];\n\n\trcu_read_lock();\n\n\te = tun_flow_find(head, rxhash);\n\tif (likely(e)) {\n\t\t \n\t\tif (READ_ONCE(e->queue_index) != queue_index)\n\t\t\tWRITE_ONCE(e->queue_index, queue_index);\n\t\tif (e->updated != jiffies)\n\t\t\te->updated = jiffies;\n\t\tsock_rps_record_flow_hash(e->rps_rxhash);\n\t} else {\n\t\tspin_lock_bh(&tun->lock);\n\t\tif (!tun_flow_find(head, rxhash) &&\n\t\t    tun->flow_count < MAX_TAP_FLOWS)\n\t\t\ttun_flow_create(tun, head, rxhash, queue_index);\n\n\t\tif (!timer_pending(&tun->flow_gc_timer))\n\t\t\tmod_timer(&tun->flow_gc_timer,\n\t\t\t\t  round_jiffies_up(jiffies + delay));\n\t\tspin_unlock_bh(&tun->lock);\n\t}\n\n\trcu_read_unlock();\n}\n\n \nstatic inline void tun_flow_save_rps_rxhash(struct tun_flow_entry *e, u32 hash)\n{\n\tif (unlikely(e->rps_rxhash != hash))\n\t\te->rps_rxhash = hash;\n}\n\n \nstatic u16 tun_automq_select_queue(struct tun_struct *tun, struct sk_buff *skb)\n{\n\tstruct tun_flow_entry *e;\n\tu32 txq = 0;\n\tu32 numqueues = 0;\n\n\tnumqueues = READ_ONCE(tun->numqueues);\n\n\ttxq = __skb_get_hash_symmetric(skb);\n\te = tun_flow_find(&tun->flows[tun_hashfn(txq)], txq);\n\tif (e) {\n\t\ttun_flow_save_rps_rxhash(e, txq);\n\t\ttxq = e->queue_index;\n\t} else {\n\t\t \n\t\ttxq = ((u64)txq * numqueues) >> 32;\n\t}\n\n\treturn txq;\n}\n\nstatic u16 tun_ebpf_select_queue(struct tun_struct *tun, struct sk_buff *skb)\n{\n\tstruct tun_prog *prog;\n\tu32 numqueues;\n\tu16 ret = 0;\n\n\tnumqueues = READ_ONCE(tun->numqueues);\n\tif (!numqueues)\n\t\treturn 0;\n\n\tprog = rcu_dereference(tun->steering_prog);\n\tif (prog)\n\t\tret = bpf_prog_run_clear_cb(prog->prog, skb);\n\n\treturn ret % numqueues;\n}\n\nstatic u16 tun_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t    struct net_device *sb_dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tu16 ret;\n\n\trcu_read_lock();\n\tif (rcu_dereference(tun->steering_prog))\n\t\tret = tun_ebpf_select_queue(tun, skb);\n\telse\n\t\tret = tun_automq_select_queue(tun, skb);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic inline bool tun_not_capable(struct tun_struct *tun)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct net *net = dev_net(tun->dev);\n\n\treturn ((uid_valid(tun->owner) && !uid_eq(cred->euid, tun->owner)) ||\n\t\t  (gid_valid(tun->group) && !in_egroup_p(tun->group))) &&\n\t\t!ns_capable(net->user_ns, CAP_NET_ADMIN);\n}\n\nstatic void tun_set_real_num_queues(struct tun_struct *tun)\n{\n\tnetif_set_real_num_tx_queues(tun->dev, tun->numqueues);\n\tnetif_set_real_num_rx_queues(tun->dev, tun->numqueues);\n}\n\nstatic void tun_disable_queue(struct tun_struct *tun, struct tun_file *tfile)\n{\n\ttfile->detached = tun;\n\tlist_add_tail(&tfile->next, &tun->disabled);\n\t++tun->numdisabled;\n}\n\nstatic struct tun_struct *tun_enable_queue(struct tun_file *tfile)\n{\n\tstruct tun_struct *tun = tfile->detached;\n\n\ttfile->detached = NULL;\n\tlist_del_init(&tfile->next);\n\t--tun->numdisabled;\n\treturn tun;\n}\n\nvoid tun_ptr_free(void *ptr)\n{\n\tif (!ptr)\n\t\treturn;\n\tif (tun_is_xdp_frame(ptr)) {\n\t\tstruct xdp_frame *xdpf = tun_ptr_to_xdp(ptr);\n\n\t\txdp_return_frame(xdpf);\n\t} else {\n\t\t__skb_array_destroy_skb(ptr);\n\t}\n}\nEXPORT_SYMBOL_GPL(tun_ptr_free);\n\nstatic void tun_queue_purge(struct tun_file *tfile)\n{\n\tvoid *ptr;\n\n\twhile ((ptr = ptr_ring_consume(&tfile->tx_ring)) != NULL)\n\t\ttun_ptr_free(ptr);\n\n\tskb_queue_purge(&tfile->sk.sk_write_queue);\n\tskb_queue_purge(&tfile->sk.sk_error_queue);\n}\n\nstatic void __tun_detach(struct tun_file *tfile, bool clean)\n{\n\tstruct tun_file *ntfile;\n\tstruct tun_struct *tun;\n\n\ttun = rtnl_dereference(tfile->tun);\n\n\tif (tun && clean) {\n\t\tif (!tfile->detached)\n\t\t\ttun_napi_disable(tfile);\n\t\ttun_napi_del(tfile);\n\t}\n\n\tif (tun && !tfile->detached) {\n\t\tu16 index = tfile->queue_index;\n\t\tBUG_ON(index >= tun->numqueues);\n\n\t\trcu_assign_pointer(tun->tfiles[index],\n\t\t\t\t   tun->tfiles[tun->numqueues - 1]);\n\t\tntfile = rtnl_dereference(tun->tfiles[index]);\n\t\tntfile->queue_index = index;\n\t\trcu_assign_pointer(tun->tfiles[tun->numqueues - 1],\n\t\t\t\t   NULL);\n\n\t\t--tun->numqueues;\n\t\tif (clean) {\n\t\t\tRCU_INIT_POINTER(tfile->tun, NULL);\n\t\t\tsock_put(&tfile->sk);\n\t\t} else {\n\t\t\ttun_disable_queue(tun, tfile);\n\t\t\ttun_napi_disable(tfile);\n\t\t}\n\n\t\tsynchronize_net();\n\t\ttun_flow_delete_by_queue(tun, tun->numqueues + 1);\n\t\t \n\t\ttun_queue_purge(tfile);\n\t\ttun_set_real_num_queues(tun);\n\t} else if (tfile->detached && clean) {\n\t\ttun = tun_enable_queue(tfile);\n\t\tsock_put(&tfile->sk);\n\t}\n\n\tif (clean) {\n\t\tif (tun && tun->numqueues == 0 && tun->numdisabled == 0) {\n\t\t\tnetif_carrier_off(tun->dev);\n\n\t\t\tif (!(tun->flags & IFF_PERSIST) &&\n\t\t\t    tun->dev->reg_state == NETREG_REGISTERED)\n\t\t\t\tunregister_netdevice(tun->dev);\n\t\t}\n\t\tif (tun)\n\t\t\txdp_rxq_info_unreg(&tfile->xdp_rxq);\n\t\tptr_ring_cleanup(&tfile->tx_ring, tun_ptr_free);\n\t}\n}\n\nstatic void tun_detach(struct tun_file *tfile, bool clean)\n{\n\tstruct tun_struct *tun;\n\tstruct net_device *dev;\n\n\trtnl_lock();\n\ttun = rtnl_dereference(tfile->tun);\n\tdev = tun ? tun->dev : NULL;\n\t__tun_detach(tfile, clean);\n\tif (dev)\n\t\tnetdev_state_change(dev);\n\trtnl_unlock();\n\n\tif (clean)\n\t\tsock_put(&tfile->sk);\n}\n\nstatic void tun_detach_all(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tstruct tun_file *tfile, *tmp;\n\tint i, n = tun->numqueues;\n\n\tfor (i = 0; i < n; i++) {\n\t\ttfile = rtnl_dereference(tun->tfiles[i]);\n\t\tBUG_ON(!tfile);\n\t\ttun_napi_disable(tfile);\n\t\ttfile->socket.sk->sk_shutdown = RCV_SHUTDOWN;\n\t\ttfile->socket.sk->sk_data_ready(tfile->socket.sk);\n\t\tRCU_INIT_POINTER(tfile->tun, NULL);\n\t\t--tun->numqueues;\n\t}\n\tlist_for_each_entry(tfile, &tun->disabled, next) {\n\t\ttfile->socket.sk->sk_shutdown = RCV_SHUTDOWN;\n\t\ttfile->socket.sk->sk_data_ready(tfile->socket.sk);\n\t\tRCU_INIT_POINTER(tfile->tun, NULL);\n\t}\n\tBUG_ON(tun->numqueues != 0);\n\n\tsynchronize_net();\n\tfor (i = 0; i < n; i++) {\n\t\ttfile = rtnl_dereference(tun->tfiles[i]);\n\t\ttun_napi_del(tfile);\n\t\t \n\t\ttun_queue_purge(tfile);\n\t\txdp_rxq_info_unreg(&tfile->xdp_rxq);\n\t\tsock_put(&tfile->sk);\n\t}\n\tlist_for_each_entry_safe(tfile, tmp, &tun->disabled, next) {\n\t\ttun_napi_del(tfile);\n\t\ttun_enable_queue(tfile);\n\t\ttun_queue_purge(tfile);\n\t\txdp_rxq_info_unreg(&tfile->xdp_rxq);\n\t\tsock_put(&tfile->sk);\n\t}\n\tBUG_ON(tun->numdisabled != 0);\n\n\tif (tun->flags & IFF_PERSIST)\n\t\tmodule_put(THIS_MODULE);\n}\n\nstatic int tun_attach(struct tun_struct *tun, struct file *file,\n\t\t      bool skip_filter, bool napi, bool napi_frags,\n\t\t      bool publish_tun)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev = tun->dev;\n\tint err;\n\n\terr = security_tun_dev_attach(tfile->socket.sk, tun->security);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (rtnl_dereference(tfile->tun) && !tfile->detached)\n\t\tgoto out;\n\n\terr = -EBUSY;\n\tif (!(tun->flags & IFF_MULTI_QUEUE) && tun->numqueues == 1)\n\t\tgoto out;\n\n\terr = -E2BIG;\n\tif (!tfile->detached &&\n\t    tun->numqueues + tun->numdisabled == MAX_TAP_QUEUES)\n\t\tgoto out;\n\n\terr = 0;\n\n\t \n\tif (!skip_filter && (tun->filter_attached == true)) {\n\t\tlock_sock(tfile->socket.sk);\n\t\terr = sk_attach_filter(&tun->fprog, tfile->socket.sk);\n\t\trelease_sock(tfile->socket.sk);\n\t\tif (!err)\n\t\t\tgoto out;\n\t}\n\n\tif (!tfile->detached &&\n\t    ptr_ring_resize(&tfile->tx_ring, dev->tx_queue_len,\n\t\t\t    GFP_KERNEL, tun_ptr_free)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttfile->queue_index = tun->numqueues;\n\ttfile->socket.sk->sk_shutdown &= ~RCV_SHUTDOWN;\n\n\tif (tfile->detached) {\n\t\t \n\t\tWARN_ON(!xdp_rxq_info_is_reg(&tfile->xdp_rxq));\n\n\t\tif (tfile->xdp_rxq.queue_index    != tfile->queue_index)\n\t\t\ttfile->xdp_rxq.queue_index = tfile->queue_index;\n\t} else {\n\t\t \n\t\terr = xdp_rxq_info_reg(&tfile->xdp_rxq,\n\t\t\t\t       tun->dev, tfile->queue_index, 0);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\terr = xdp_rxq_info_reg_mem_model(&tfile->xdp_rxq,\n\t\t\t\t\t\t MEM_TYPE_PAGE_SHARED, NULL);\n\t\tif (err < 0) {\n\t\t\txdp_rxq_info_unreg(&tfile->xdp_rxq);\n\t\t\tgoto out;\n\t\t}\n\t\terr = 0;\n\t}\n\n\tif (tfile->detached) {\n\t\ttun_enable_queue(tfile);\n\t\ttun_napi_enable(tfile);\n\t} else {\n\t\tsock_hold(&tfile->sk);\n\t\ttun_napi_init(tun, tfile, napi, napi_frags);\n\t}\n\n\tif (rtnl_dereference(tun->xdp_prog))\n\t\tsock_set_flag(&tfile->sk, SOCK_XDP);\n\n\t \n\n\t \n\tif (publish_tun)\n\t\trcu_assign_pointer(tfile->tun, tun);\n\trcu_assign_pointer(tun->tfiles[tun->numqueues], tfile);\n\ttun->numqueues++;\n\ttun_set_real_num_queues(tun);\nout:\n\treturn err;\n}\n\nstatic struct tun_struct *tun_get(struct tun_file *tfile)\n{\n\tstruct tun_struct *tun;\n\n\trcu_read_lock();\n\ttun = rcu_dereference(tfile->tun);\n\tif (tun)\n\t\tdev_hold(tun->dev);\n\trcu_read_unlock();\n\n\treturn tun;\n}\n\nstatic void tun_put(struct tun_struct *tun)\n{\n\tdev_put(tun->dev);\n}\n\n \nstatic void addr_hash_set(u32 *mask, const u8 *addr)\n{\n\tint n = ether_crc(ETH_ALEN, addr) >> 26;\n\tmask[n >> 5] |= (1 << (n & 31));\n}\n\nstatic unsigned int addr_hash_test(const u32 *mask, const u8 *addr)\n{\n\tint n = ether_crc(ETH_ALEN, addr) >> 26;\n\treturn mask[n >> 5] & (1 << (n & 31));\n}\n\nstatic int update_filter(struct tap_filter *filter, void __user *arg)\n{\n\tstruct { u8 u[ETH_ALEN]; } *addr;\n\tstruct tun_filter uf;\n\tint err, alen, n, nexact;\n\n\tif (copy_from_user(&uf, arg, sizeof(uf)))\n\t\treturn -EFAULT;\n\n\tif (!uf.count) {\n\t\t \n\t\tfilter->count = 0;\n\t\treturn 0;\n\t}\n\n\talen = ETH_ALEN * uf.count;\n\taddr = memdup_user(arg + sizeof(uf), alen);\n\tif (IS_ERR(addr))\n\t\treturn PTR_ERR(addr);\n\n\t \n\tfilter->count = 0;\n\twmb();\n\n\t \n\tfor (n = 0; n < uf.count && n < FLT_EXACT_COUNT; n++)\n\t\tmemcpy(filter->addr[n], addr[n].u, ETH_ALEN);\n\n\tnexact = n;\n\n\t \n\tmemset(filter->mask, 0, sizeof(filter->mask));\n\tfor (; n < uf.count; n++) {\n\t\tif (!is_multicast_ether_addr(addr[n].u)) {\n\t\t\terr = 0;  \n\t\t\tgoto free_addr;\n\t\t}\n\t\taddr_hash_set(filter->mask, addr[n].u);\n\t}\n\n\t \n\tif ((uf.flags & TUN_FLT_ALLMULTI))\n\t\tmemset(filter->mask, ~0, sizeof(filter->mask));\n\n\t \n\twmb();\n\tfilter->count = nexact;\n\n\t \n\terr = nexact;\nfree_addr:\n\tkfree(addr);\n\treturn err;\n}\n\n \nstatic int run_filter(struct tap_filter *filter, const struct sk_buff *skb)\n{\n\t \n\tstruct ethhdr *eh = (struct ethhdr *) skb->data;\n\tint i;\n\n\t \n\tfor (i = 0; i < filter->count; i++)\n\t\tif (ether_addr_equal(eh->h_dest, filter->addr[i]))\n\t\t\treturn 1;\n\n\t \n\tif (is_multicast_ether_addr(eh->h_dest))\n\t\treturn addr_hash_test(filter->mask, eh->h_dest);\n\n\treturn 0;\n}\n\n \nstatic int check_filter(struct tap_filter *filter, const struct sk_buff *skb)\n{\n\tif (!filter->count)\n\t\treturn 1;\n\n\treturn run_filter(filter, skb);\n}\n\n \n\nstatic const struct ethtool_ops tun_ethtool_ops;\n\nstatic int tun_net_init(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tstruct ifreq *ifr = tun->ifr;\n\tint err;\n\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&tun->lock);\n\n\terr = security_tun_dev_alloc_security(&tun->security);\n\tif (err < 0) {\n\t\tfree_percpu(dev->tstats);\n\t\treturn err;\n\t}\n\n\ttun_flow_init(tun);\n\n\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t   NETIF_F_HW_VLAN_STAG_TX;\n\tdev->features = dev->hw_features | NETIF_F_LLTX;\n\tdev->vlan_features = dev->features &\n\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t       NETIF_F_HW_VLAN_STAG_TX);\n\n\ttun->flags = (tun->flags & ~TUN_FEATURES) |\n\t\t      (ifr->ifr_flags & TUN_FEATURES);\n\n\tINIT_LIST_HEAD(&tun->disabled);\n\terr = tun_attach(tun, tun->file, false, ifr->ifr_flags & IFF_NAPI,\n\t\t\t ifr->ifr_flags & IFF_NAPI_FRAGS, false);\n\tif (err < 0) {\n\t\ttun_flow_uninit(tun);\n\t\tsecurity_tun_dev_free_security(tun->security);\n\t\tfree_percpu(dev->tstats);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic void tun_net_uninit(struct net_device *dev)\n{\n\ttun_detach_all(dev);\n}\n\n \nstatic int tun_net_open(struct net_device *dev)\n{\n\tnetif_tx_start_all_queues(dev);\n\n\treturn 0;\n}\n\n \nstatic int tun_net_close(struct net_device *dev)\n{\n\tnetif_tx_stop_all_queues(dev);\n\treturn 0;\n}\n\n \nstatic void tun_automq_xmit(struct tun_struct *tun, struct sk_buff *skb)\n{\n#ifdef CONFIG_RPS\n\tif (tun->numqueues == 1 && static_branch_unlikely(&rps_needed)) {\n\t\t \n\t\tstruct tun_flow_entry *e;\n\t\t__u32 rxhash;\n\n\t\trxhash = __skb_get_hash_symmetric(skb);\n\t\te = tun_flow_find(&tun->flows[tun_hashfn(rxhash)], rxhash);\n\t\tif (e)\n\t\t\ttun_flow_save_rps_rxhash(e, rxhash);\n\t}\n#endif\n}\n\nstatic unsigned int run_ebpf_filter(struct tun_struct *tun,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    int len)\n{\n\tstruct tun_prog *prog = rcu_dereference(tun->filter_prog);\n\n\tif (prog)\n\t\tlen = bpf_prog_run_clear_cb(prog->prog, skb);\n\n\treturn len;\n}\n\n \nstatic netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tenum skb_drop_reason drop_reason;\n\tint txq = skb->queue_mapping;\n\tstruct netdev_queue *queue;\n\tstruct tun_file *tfile;\n\tint len = skb->len;\n\n\trcu_read_lock();\n\ttfile = rcu_dereference(tun->tfiles[txq]);\n\n\t \n\tif (!tfile) {\n\t\tdrop_reason = SKB_DROP_REASON_DEV_READY;\n\t\tgoto drop;\n\t}\n\n\tif (!rcu_dereference(tun->steering_prog))\n\t\ttun_automq_xmit(tun, skb);\n\n\tnetif_info(tun, tx_queued, tun->dev, \"%s %d\\n\", __func__, skb->len);\n\n\t \n\tif (!check_filter(&tun->txflt, skb)) {\n\t\tdrop_reason = SKB_DROP_REASON_TAP_TXFILTER;\n\t\tgoto drop;\n\t}\n\n\tif (tfile->socket.sk->sk_filter &&\n\t    sk_filter(tfile->socket.sk, skb)) {\n\t\tdrop_reason = SKB_DROP_REASON_SOCKET_FILTER;\n\t\tgoto drop;\n\t}\n\n\tlen = run_ebpf_filter(tun, skb, len);\n\tif (len == 0) {\n\t\tdrop_reason = SKB_DROP_REASON_TAP_FILTER;\n\t\tgoto drop;\n\t}\n\n\tif (pskb_trim(skb, len)) {\n\t\tdrop_reason = SKB_DROP_REASON_NOMEM;\n\t\tgoto drop;\n\t}\n\n\tif (unlikely(skb_orphan_frags_rx(skb, GFP_ATOMIC))) {\n\t\tdrop_reason = SKB_DROP_REASON_SKB_UCOPY_FAULT;\n\t\tgoto drop;\n\t}\n\n\tskb_tx_timestamp(skb);\n\n\t \n\tskb_orphan(skb);\n\n\tnf_reset_ct(skb);\n\n\tif (ptr_ring_produce(&tfile->tx_ring, skb)) {\n\t\tdrop_reason = SKB_DROP_REASON_FULL_RING;\n\t\tgoto drop;\n\t}\n\n\t \n\tqueue = netdev_get_tx_queue(dev, txq);\n\ttxq_trans_cond_update(queue);\n\n\t \n\tif (tfile->flags & TUN_FASYNC)\n\t\tkill_fasync(&tfile->fasync, SIGIO, POLL_IN);\n\ttfile->socket.sk->sk_data_ready(tfile->socket.sk);\n\n\trcu_read_unlock();\n\treturn NETDEV_TX_OK;\n\ndrop:\n\tdev_core_stats_tx_dropped_inc(dev);\n\tskb_tx_error(skb);\n\tkfree_skb_reason(skb, drop_reason);\n\trcu_read_unlock();\n\treturn NET_XMIT_DROP;\n}\n\nstatic void tun_net_mclist(struct net_device *dev)\n{\n\t \n}\n\nstatic netdev_features_t tun_net_fix_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\treturn (features & tun->set_features) | (features & ~TUN_USER_FEATURES);\n}\n\nstatic void tun_set_headroom(struct net_device *dev, int new_hr)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tif (new_hr < NET_SKB_PAD)\n\t\tnew_hr = NET_SKB_PAD;\n\n\ttun->align = new_hr;\n}\n\nstatic void\ntun_net_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tdev_get_tstats64(dev, stats);\n\n\tstats->rx_frame_errors +=\n\t\t(unsigned long)atomic_long_read(&tun->rx_frame_errors);\n}\n\nstatic int tun_xdp_set(struct net_device *dev, struct bpf_prog *prog,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tstruct tun_file *tfile;\n\tstruct bpf_prog *old_prog;\n\tint i;\n\n\told_prog = rtnl_dereference(tun->xdp_prog);\n\trcu_assign_pointer(tun->xdp_prog, prog);\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\n\tfor (i = 0; i < tun->numqueues; i++) {\n\t\ttfile = rtnl_dereference(tun->tfiles[i]);\n\t\tif (prog)\n\t\t\tsock_set_flag(&tfile->sk, SOCK_XDP);\n\t\telse\n\t\t\tsock_reset_flag(&tfile->sk, SOCK_XDP);\n\t}\n\tlist_for_each_entry(tfile, &tun->disabled, next) {\n\t\tif (prog)\n\t\t\tsock_set_flag(&tfile->sk, SOCK_XDP);\n\t\telse\n\t\t\tsock_reset_flag(&tfile->sk, SOCK_XDP);\n\t}\n\n\treturn 0;\n}\n\nstatic int tun_xdp(struct net_device *dev, struct netdev_bpf *xdp)\n{\n\tswitch (xdp->command) {\n\tcase XDP_SETUP_PROG:\n\t\treturn tun_xdp_set(dev, xdp->prog, xdp->extack);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tun_net_change_carrier(struct net_device *dev, bool new_carrier)\n{\n\tif (new_carrier) {\n\t\tstruct tun_struct *tun = netdev_priv(dev);\n\n\t\tif (!tun->numqueues)\n\t\t\treturn -EPERM;\n\n\t\tnetif_carrier_on(dev);\n\t} else {\n\t\tnetif_carrier_off(dev);\n\t}\n\treturn 0;\n}\n\nstatic const struct net_device_ops tun_netdev_ops = {\n\t.ndo_init\t\t= tun_net_init,\n\t.ndo_uninit\t\t= tun_net_uninit,\n\t.ndo_open\t\t= tun_net_open,\n\t.ndo_stop\t\t= tun_net_close,\n\t.ndo_start_xmit\t\t= tun_net_xmit,\n\t.ndo_fix_features\t= tun_net_fix_features,\n\t.ndo_select_queue\t= tun_select_queue,\n\t.ndo_set_rx_headroom\t= tun_set_headroom,\n\t.ndo_get_stats64\t= tun_net_get_stats64,\n\t.ndo_change_carrier\t= tun_net_change_carrier,\n};\n\nstatic void __tun_xdp_flush_tfile(struct tun_file *tfile)\n{\n\t \n\tif (tfile->flags & TUN_FASYNC)\n\t\tkill_fasync(&tfile->fasync, SIGIO, POLL_IN);\n\ttfile->socket.sk->sk_data_ready(tfile->socket.sk);\n}\n\nstatic int tun_xdp_xmit(struct net_device *dev, int n,\n\t\t\tstruct xdp_frame **frames, u32 flags)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tstruct tun_file *tfile;\n\tu32 numqueues;\n\tint nxmit = 0;\n\tint i;\n\n\tif (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\nresample:\n\tnumqueues = READ_ONCE(tun->numqueues);\n\tif (!numqueues) {\n\t\trcu_read_unlock();\n\t\treturn -ENXIO;  \n\t}\n\n\ttfile = rcu_dereference(tun->tfiles[smp_processor_id() %\n\t\t\t\t\t    numqueues]);\n\tif (unlikely(!tfile))\n\t\tgoto resample;\n\n\tspin_lock(&tfile->tx_ring.producer_lock);\n\tfor (i = 0; i < n; i++) {\n\t\tstruct xdp_frame *xdp = frames[i];\n\t\t \n\t\tvoid *frame = tun_xdp_to_ptr(xdp);\n\n\t\tif (__ptr_ring_produce(&tfile->tx_ring, frame)) {\n\t\t\tdev_core_stats_tx_dropped_inc(dev);\n\t\t\tbreak;\n\t\t}\n\t\tnxmit++;\n\t}\n\tspin_unlock(&tfile->tx_ring.producer_lock);\n\n\tif (flags & XDP_XMIT_FLUSH)\n\t\t__tun_xdp_flush_tfile(tfile);\n\n\trcu_read_unlock();\n\treturn nxmit;\n}\n\nstatic int tun_xdp_tx(struct net_device *dev, struct xdp_buff *xdp)\n{\n\tstruct xdp_frame *frame = xdp_convert_buff_to_frame(xdp);\n\tint nxmit;\n\n\tif (unlikely(!frame))\n\t\treturn -EOVERFLOW;\n\n\tnxmit = tun_xdp_xmit(dev, 1, &frame, XDP_XMIT_FLUSH);\n\tif (!nxmit)\n\t\txdp_return_frame_rx_napi(frame);\n\treturn nxmit;\n}\n\nstatic const struct net_device_ops tap_netdev_ops = {\n\t.ndo_init\t\t= tun_net_init,\n\t.ndo_uninit\t\t= tun_net_uninit,\n\t.ndo_open\t\t= tun_net_open,\n\t.ndo_stop\t\t= tun_net_close,\n\t.ndo_start_xmit\t\t= tun_net_xmit,\n\t.ndo_fix_features\t= tun_net_fix_features,\n\t.ndo_set_rx_mode\t= tun_net_mclist,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_select_queue\t= tun_select_queue,\n\t.ndo_features_check\t= passthru_features_check,\n\t.ndo_set_rx_headroom\t= tun_set_headroom,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_bpf\t\t= tun_xdp,\n\t.ndo_xdp_xmit\t\t= tun_xdp_xmit,\n\t.ndo_change_carrier\t= tun_net_change_carrier,\n};\n\nstatic void tun_flow_init(struct tun_struct *tun)\n{\n\tint i;\n\n\tfor (i = 0; i < TUN_NUM_FLOW_ENTRIES; i++)\n\t\tINIT_HLIST_HEAD(&tun->flows[i]);\n\n\ttun->ageing_time = TUN_FLOW_EXPIRE;\n\ttimer_setup(&tun->flow_gc_timer, tun_flow_cleanup, 0);\n\tmod_timer(&tun->flow_gc_timer,\n\t\t  round_jiffies_up(jiffies + tun->ageing_time));\n}\n\nstatic void tun_flow_uninit(struct tun_struct *tun)\n{\n\tdel_timer_sync(&tun->flow_gc_timer);\n\ttun_flow_flush(tun);\n}\n\n#define MIN_MTU 68\n#define MAX_MTU 65535\n\n \nstatic void tun_net_initialize(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase IFF_TUN:\n\t\tdev->netdev_ops = &tun_netdev_ops;\n\t\tdev->header_ops = &ip_tunnel_header_ops;\n\n\t\t \n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->mtu = 1500;\n\n\t\t \n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tbreak;\n\n\tcase IFF_TAP:\n\t\tdev->netdev_ops = &tap_netdev_ops;\n\t\t \n\t\tether_setup(dev);\n\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\t\tdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\n\t\teth_hw_addr_random(dev);\n\n\t\t \n\t\tdev->xdp_features = NETDEV_XDP_ACT_BASIC |\n\t\t\t\t    NETDEV_XDP_ACT_REDIRECT |\n\t\t\t\t    NETDEV_XDP_ACT_NDO_XMIT;\n\n\t\tbreak;\n\t}\n\n\tdev->min_mtu = MIN_MTU;\n\tdev->max_mtu = MAX_MTU - dev->hard_header_len;\n}\n\nstatic bool tun_sock_writeable(struct tun_struct *tun, struct tun_file *tfile)\n{\n\tstruct sock *sk = tfile->socket.sk;\n\n\treturn (tun->dev->flags & IFF_UP) && sock_writeable(sk);\n}\n\n \n\n \nstatic __poll_t tun_chr_poll(struct file *file, poll_table *wait)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = tun_get(tfile);\n\tstruct sock *sk;\n\t__poll_t mask = 0;\n\n\tif (!tun)\n\t\treturn EPOLLERR;\n\n\tsk = tfile->socket.sk;\n\n\tpoll_wait(file, sk_sleep(sk), wait);\n\n\tif (!ptr_ring_empty(&tfile->tx_ring))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\t \n\tif (tun_sock_writeable(tun, tfile) ||\n\t    (!test_and_set_bit(SOCKWQ_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n\t     tun_sock_writeable(tun, tfile)))\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\n\tif (tun->dev->reg_state != NETREG_REGISTERED)\n\t\tmask = EPOLLERR;\n\n\ttun_put(tun);\n\treturn mask;\n}\n\nstatic struct sk_buff *tun_napi_alloc_frags(struct tun_file *tfile,\n\t\t\t\t\t    size_t len,\n\t\t\t\t\t    const struct iov_iter *it)\n{\n\tstruct sk_buff *skb;\n\tsize_t linear;\n\tint err;\n\tint i;\n\n\tif (it->nr_segs > MAX_SKB_FRAGS + 1 ||\n\t    len > (ETH_MAX_MTU - NET_SKB_PAD - NET_IP_ALIGN))\n\t\treturn ERR_PTR(-EMSGSIZE);\n\n\tlocal_bh_disable();\n\tskb = napi_get_frags(&tfile->napi);\n\tlocal_bh_enable();\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlinear = iov_iter_single_seg_count(it);\n\terr = __skb_grow(skb, linear);\n\tif (err)\n\t\tgoto free;\n\n\tskb->len = len;\n\tskb->data_len = len - linear;\n\tskb->truesize += skb->data_len;\n\n\tfor (i = 1; i < it->nr_segs; i++) {\n\t\tconst struct iovec *iov = iter_iov(it);\n\t\tsize_t fragsz = iov->iov_len;\n\t\tstruct page *page;\n\t\tvoid *frag;\n\n\t\tif (fragsz == 0 || fragsz > PAGE_SIZE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t\tfrag = netdev_alloc_frag(fragsz);\n\t\tif (!frag) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t\tpage = virt_to_head_page(frag);\n\t\tskb_fill_page_desc(skb, i - 1, page,\n\t\t\t\t   frag - page_address(page), fragsz);\n\t}\n\n\treturn skb;\nfree:\n\t \n\tnapi_free_frags(&tfile->napi);\n\treturn ERR_PTR(err);\n}\n\n \nstatic struct sk_buff *tun_alloc_skb(struct tun_file *tfile,\n\t\t\t\t     size_t prepad, size_t len,\n\t\t\t\t     size_t linear, int noblock)\n{\n\tstruct sock *sk = tfile->socket.sk;\n\tstruct sk_buff *skb;\n\tint err;\n\n\t \n\tif (prepad + len < PAGE_SIZE)\n\t\tlinear = len;\n\n\tif (len - linear > MAX_SKB_FRAGS * (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tlinear = len - MAX_SKB_FRAGS * (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER);\n\tskb = sock_alloc_send_pskb(sk, prepad + linear, len - linear, noblock,\n\t\t\t\t   &err, PAGE_ALLOC_COSTLY_ORDER);\n\tif (!skb)\n\t\treturn ERR_PTR(err);\n\n\tskb_reserve(skb, prepad);\n\tskb_put(skb, linear);\n\tskb->data_len = len - linear;\n\tskb->len += len - linear;\n\n\treturn skb;\n}\n\nstatic void tun_rx_batched(struct tun_struct *tun, struct tun_file *tfile,\n\t\t\t   struct sk_buff *skb, int more)\n{\n\tstruct sk_buff_head *queue = &tfile->sk.sk_write_queue;\n\tstruct sk_buff_head process_queue;\n\tu32 rx_batched = tun->rx_batched;\n\tbool rcv = false;\n\n\tif (!rx_batched || (!more && skb_queue_empty(queue))) {\n\t\tlocal_bh_disable();\n\t\tskb_record_rx_queue(skb, tfile->queue_index);\n\t\tnetif_receive_skb(skb);\n\t\tlocal_bh_enable();\n\t\treturn;\n\t}\n\n\tspin_lock(&queue->lock);\n\tif (!more || skb_queue_len(queue) == rx_batched) {\n\t\t__skb_queue_head_init(&process_queue);\n\t\tskb_queue_splice_tail_init(queue, &process_queue);\n\t\trcv = true;\n\t} else {\n\t\t__skb_queue_tail(queue, skb);\n\t}\n\tspin_unlock(&queue->lock);\n\n\tif (rcv) {\n\t\tstruct sk_buff *nskb;\n\n\t\tlocal_bh_disable();\n\t\twhile ((nskb = __skb_dequeue(&process_queue))) {\n\t\t\tskb_record_rx_queue(nskb, tfile->queue_index);\n\t\t\tnetif_receive_skb(nskb);\n\t\t}\n\t\tskb_record_rx_queue(skb, tfile->queue_index);\n\t\tnetif_receive_skb(skb);\n\t\tlocal_bh_enable();\n\t}\n}\n\nstatic bool tun_can_build_skb(struct tun_struct *tun, struct tun_file *tfile,\n\t\t\t      int len, int noblock, bool zerocopy)\n{\n\tif ((tun->flags & TUN_TYPE_MASK) != IFF_TAP)\n\t\treturn false;\n\n\tif (tfile->socket.sk->sk_sndbuf != INT_MAX)\n\t\treturn false;\n\n\tif (!noblock)\n\t\treturn false;\n\n\tif (zerocopy)\n\t\treturn false;\n\n\tif (SKB_DATA_ALIGN(len + TUN_RX_PAD + XDP_PACKET_HEADROOM) +\n\t    SKB_DATA_ALIGN(sizeof(struct skb_shared_info)) > PAGE_SIZE)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct sk_buff *__tun_build_skb(struct tun_file *tfile,\n\t\t\t\t       struct page_frag *alloc_frag, char *buf,\n\t\t\t\t       int buflen, int len, int pad)\n{\n\tstruct sk_buff *skb = build_skb(buf, buflen);\n\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskb_reserve(skb, pad);\n\tskb_put(skb, len);\n\tskb_set_owner_w(skb, tfile->socket.sk);\n\n\tget_page(alloc_frag->page);\n\talloc_frag->offset += buflen;\n\n\treturn skb;\n}\n\nstatic int tun_xdp_act(struct tun_struct *tun, struct bpf_prog *xdp_prog,\n\t\t       struct xdp_buff *xdp, u32 act)\n{\n\tint err;\n\n\tswitch (act) {\n\tcase XDP_REDIRECT:\n\t\terr = xdp_do_redirect(tun->dev, xdp, xdp_prog);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase XDP_TX:\n\t\terr = tun_xdp_tx(tun->dev, xdp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase XDP_PASS:\n\t\tbreak;\n\tdefault:\n\t\tbpf_warn_invalid_xdp_action(tun->dev, xdp_prog, act);\n\t\tfallthrough;\n\tcase XDP_ABORTED:\n\t\ttrace_xdp_exception(tun->dev, xdp_prog, act);\n\t\tfallthrough;\n\tcase XDP_DROP:\n\t\tdev_core_stats_rx_dropped_inc(tun->dev);\n\t\tbreak;\n\t}\n\n\treturn act;\n}\n\nstatic struct sk_buff *tun_build_skb(struct tun_struct *tun,\n\t\t\t\t     struct tun_file *tfile,\n\t\t\t\t     struct iov_iter *from,\n\t\t\t\t     struct virtio_net_hdr *hdr,\n\t\t\t\t     int len, int *skb_xdp)\n{\n\tstruct page_frag *alloc_frag = &current->task_frag;\n\tstruct bpf_prog *xdp_prog;\n\tint buflen = SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\tchar *buf;\n\tsize_t copied;\n\tint pad = TUN_RX_PAD;\n\tint err = 0;\n\n\trcu_read_lock();\n\txdp_prog = rcu_dereference(tun->xdp_prog);\n\tif (xdp_prog)\n\t\tpad += XDP_PACKET_HEADROOM;\n\tbuflen += SKB_DATA_ALIGN(len + pad);\n\trcu_read_unlock();\n\n\talloc_frag->offset = ALIGN((u64)alloc_frag->offset, SMP_CACHE_BYTES);\n\tif (unlikely(!skb_page_frag_refill(buflen, alloc_frag, GFP_KERNEL)))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbuf = (char *)page_address(alloc_frag->page) + alloc_frag->offset;\n\tcopied = copy_page_from_iter(alloc_frag->page,\n\t\t\t\t     alloc_frag->offset + pad,\n\t\t\t\t     len, from);\n\tif (copied != len)\n\t\treturn ERR_PTR(-EFAULT);\n\n\t \n\tif (hdr->gso_type || !xdp_prog) {\n\t\t*skb_xdp = 1;\n\t\treturn __tun_build_skb(tfile, alloc_frag, buf, buflen, len,\n\t\t\t\t       pad);\n\t}\n\n\t*skb_xdp = 0;\n\n\tlocal_bh_disable();\n\trcu_read_lock();\n\txdp_prog = rcu_dereference(tun->xdp_prog);\n\tif (xdp_prog) {\n\t\tstruct xdp_buff xdp;\n\t\tu32 act;\n\n\t\txdp_init_buff(&xdp, buflen, &tfile->xdp_rxq);\n\t\txdp_prepare_buff(&xdp, buf, pad, len, false);\n\n\t\tact = bpf_prog_run_xdp(xdp_prog, &xdp);\n\t\tif (act == XDP_REDIRECT || act == XDP_TX) {\n\t\t\tget_page(alloc_frag->page);\n\t\t\talloc_frag->offset += buflen;\n\t\t}\n\t\terr = tun_xdp_act(tun, xdp_prog, &xdp, act);\n\t\tif (err < 0) {\n\t\t\tif (act == XDP_REDIRECT || act == XDP_TX)\n\t\t\t\tput_page(alloc_frag->page);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (err == XDP_REDIRECT)\n\t\t\txdp_do_flush();\n\t\tif (err != XDP_PASS)\n\t\t\tgoto out;\n\n\t\tpad = xdp.data - xdp.data_hard_start;\n\t\tlen = xdp.data_end - xdp.data;\n\t}\n\trcu_read_unlock();\n\tlocal_bh_enable();\n\n\treturn __tun_build_skb(tfile, alloc_frag, buf, buflen, len, pad);\n\nout:\n\trcu_read_unlock();\n\tlocal_bh_enable();\n\treturn NULL;\n}\n\n \nstatic ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,\n\t\t\t    void *msg_control, struct iov_iter *from,\n\t\t\t    int noblock, bool more)\n{\n\tstruct tun_pi pi = { 0, cpu_to_be16(ETH_P_IP) };\n\tstruct sk_buff *skb;\n\tsize_t total_len = iov_iter_count(from);\n\tsize_t len = total_len, align = tun->align, linear;\n\tstruct virtio_net_hdr gso = { 0 };\n\tint good_linear;\n\tint copylen;\n\tbool zerocopy = false;\n\tint err;\n\tu32 rxhash = 0;\n\tint skb_xdp = 1;\n\tbool frags = tun_napi_frags_enabled(tfile);\n\tenum skb_drop_reason drop_reason = SKB_DROP_REASON_NOT_SPECIFIED;\n\n\tif (!(tun->flags & IFF_NO_PI)) {\n\t\tif (len < sizeof(pi))\n\t\t\treturn -EINVAL;\n\t\tlen -= sizeof(pi);\n\n\t\tif (!copy_from_iter_full(&pi, sizeof(pi), from))\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (tun->flags & IFF_VNET_HDR) {\n\t\tint vnet_hdr_sz = READ_ONCE(tun->vnet_hdr_sz);\n\n\t\tif (len < vnet_hdr_sz)\n\t\t\treturn -EINVAL;\n\t\tlen -= vnet_hdr_sz;\n\n\t\tif (!copy_from_iter_full(&gso, sizeof(gso), from))\n\t\t\treturn -EFAULT;\n\n\t\tif ((gso.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&\n\t\t    tun16_to_cpu(tun, gso.csum_start) + tun16_to_cpu(tun, gso.csum_offset) + 2 > tun16_to_cpu(tun, gso.hdr_len))\n\t\t\tgso.hdr_len = cpu_to_tun16(tun, tun16_to_cpu(tun, gso.csum_start) + tun16_to_cpu(tun, gso.csum_offset) + 2);\n\n\t\tif (tun16_to_cpu(tun, gso.hdr_len) > len)\n\t\t\treturn -EINVAL;\n\t\tiov_iter_advance(from, vnet_hdr_sz - sizeof(gso));\n\t}\n\n\tif ((tun->flags & TUN_TYPE_MASK) == IFF_TAP) {\n\t\talign += NET_IP_ALIGN;\n\t\tif (unlikely(len < ETH_HLEN ||\n\t\t\t     (gso.hdr_len && tun16_to_cpu(tun, gso.hdr_len) < ETH_HLEN)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tgood_linear = SKB_MAX_HEAD(align);\n\n\tif (msg_control) {\n\t\tstruct iov_iter i = *from;\n\n\t\t \n\t\tcopylen = gso.hdr_len ? tun16_to_cpu(tun, gso.hdr_len) : GOODCOPY_LEN;\n\t\tif (copylen > good_linear)\n\t\t\tcopylen = good_linear;\n\t\tlinear = copylen;\n\t\tiov_iter_advance(&i, copylen);\n\t\tif (iov_iter_npages(&i, INT_MAX) <= MAX_SKB_FRAGS)\n\t\t\tzerocopy = true;\n\t}\n\n\tif (!frags && tun_can_build_skb(tun, tfile, len, noblock, zerocopy)) {\n\t\t \n\t\tskb = tun_build_skb(tun, tfile, from, &gso, len, &skb_xdp);\n\t\terr = PTR_ERR_OR_ZERO(skb);\n\t\tif (err)\n\t\t\tgoto drop;\n\t\tif (!skb)\n\t\t\treturn total_len;\n\t} else {\n\t\tif (!zerocopy) {\n\t\t\tcopylen = len;\n\t\t\tif (tun16_to_cpu(tun, gso.hdr_len) > good_linear)\n\t\t\t\tlinear = good_linear;\n\t\t\telse\n\t\t\t\tlinear = tun16_to_cpu(tun, gso.hdr_len);\n\t\t}\n\n\t\tif (frags) {\n\t\t\tmutex_lock(&tfile->napi_mutex);\n\t\t\tskb = tun_napi_alloc_frags(tfile, copylen, from);\n\t\t\t \n\t\t\tzerocopy = false;\n\t\t} else {\n\t\t\tif (!linear)\n\t\t\t\tlinear = min_t(size_t, good_linear, copylen);\n\n\t\t\tskb = tun_alloc_skb(tfile, align, copylen, linear,\n\t\t\t\t\t    noblock);\n\t\t}\n\n\t\terr = PTR_ERR_OR_ZERO(skb);\n\t\tif (err)\n\t\t\tgoto drop;\n\n\t\tif (zerocopy)\n\t\t\terr = zerocopy_sg_from_iter(skb, from);\n\t\telse\n\t\t\terr = skb_copy_datagram_from_iter(skb, 0, from, len);\n\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tdrop_reason = SKB_DROP_REASON_SKB_UCOPY_FAULT;\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (virtio_net_hdr_to_skb(skb, &gso, tun_is_little_endian(tun))) {\n\t\tatomic_long_inc(&tun->rx_frame_errors);\n\t\terr = -EINVAL;\n\t\tgoto free_skb;\n\t}\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase IFF_TUN:\n\t\tif (tun->flags & IFF_NO_PI) {\n\t\t\tu8 ip_version = skb->len ? (skb->data[0] >> 4) : 0;\n\n\t\t\tswitch (ip_version) {\n\t\t\tcase 4:\n\t\t\t\tpi.proto = htons(ETH_P_IP);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tpi.proto = htons(ETH_P_IPV6);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\n\t\tskb_reset_mac_header(skb);\n\t\tskb->protocol = pi.proto;\n\t\tskb->dev = tun->dev;\n\t\tbreak;\n\tcase IFF_TAP:\n\t\tif (frags && !pskb_may_pull(skb, ETH_HLEN)) {\n\t\t\terr = -ENOMEM;\n\t\t\tdrop_reason = SKB_DROP_REASON_HDR_TRUNC;\n\t\t\tgoto drop;\n\t\t}\n\t\tskb->protocol = eth_type_trans(skb, tun->dev);\n\t\tbreak;\n\t}\n\n\t \n\tif (zerocopy) {\n\t\tskb_zcopy_init(skb, msg_control);\n\t} else if (msg_control) {\n\t\tstruct ubuf_info *uarg = msg_control;\n\t\tuarg->callback(NULL, uarg, false);\n\t}\n\n\tskb_reset_network_header(skb);\n\tskb_probe_transport_header(skb);\n\tskb_record_rx_queue(skb, tfile->queue_index);\n\n\tif (skb_xdp) {\n\t\tstruct bpf_prog *xdp_prog;\n\t\tint ret;\n\n\t\tlocal_bh_disable();\n\t\trcu_read_lock();\n\t\txdp_prog = rcu_dereference(tun->xdp_prog);\n\t\tif (xdp_prog) {\n\t\t\tret = do_xdp_generic(xdp_prog, skb);\n\t\t\tif (ret != XDP_PASS) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tlocal_bh_enable();\n\t\t\t\tgoto unlock_frags;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tlocal_bh_enable();\n\t}\n\n\t \n\tif (!rcu_access_pointer(tun->steering_prog) && tun->numqueues > 1 &&\n\t    !tfile->detached)\n\t\trxhash = __skb_get_hash_symmetric(skb);\n\n\trcu_read_lock();\n\tif (unlikely(!(tun->dev->flags & IFF_UP))) {\n\t\terr = -EIO;\n\t\trcu_read_unlock();\n\t\tdrop_reason = SKB_DROP_REASON_DEV_READY;\n\t\tgoto drop;\n\t}\n\n\tif (frags) {\n\t\tu32 headlen;\n\n\t\t \n\t\tskb_push(skb, ETH_HLEN);\n\t\theadlen = eth_get_headlen(tun->dev, skb->data,\n\t\t\t\t\t  skb_headlen(skb));\n\n\t\tif (unlikely(headlen > skb_headlen(skb))) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\terr = -ENOMEM;\n\t\t\tdev_core_stats_rx_dropped_inc(tun->dev);\nnapi_busy:\n\t\t\tnapi_free_frags(&tfile->napi);\n\t\t\trcu_read_unlock();\n\t\t\tmutex_unlock(&tfile->napi_mutex);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (likely(napi_schedule_prep(&tfile->napi))) {\n\t\t\tlocal_bh_disable();\n\t\t\tnapi_gro_frags(&tfile->napi);\n\t\t\tnapi_complete(&tfile->napi);\n\t\t\tlocal_bh_enable();\n\t\t} else {\n\t\t\terr = -EBUSY;\n\t\t\tgoto napi_busy;\n\t\t}\n\t\tmutex_unlock(&tfile->napi_mutex);\n\t} else if (tfile->napi_enabled) {\n\t\tstruct sk_buff_head *queue = &tfile->sk.sk_write_queue;\n\t\tint queue_len;\n\n\t\tspin_lock_bh(&queue->lock);\n\n\t\tif (unlikely(tfile->detached)) {\n\t\t\tspin_unlock_bh(&queue->lock);\n\t\t\trcu_read_unlock();\n\t\t\terr = -EBUSY;\n\t\t\tgoto free_skb;\n\t\t}\n\n\t\t__skb_queue_tail(queue, skb);\n\t\tqueue_len = skb_queue_len(queue);\n\t\tspin_unlock(&queue->lock);\n\n\t\tif (!more || queue_len > NAPI_POLL_WEIGHT)\n\t\t\tnapi_schedule(&tfile->napi);\n\n\t\tlocal_bh_enable();\n\t} else if (!IS_ENABLED(CONFIG_4KSTACKS)) {\n\t\ttun_rx_batched(tun, tfile, skb, more);\n\t} else {\n\t\tnetif_rx(skb);\n\t}\n\trcu_read_unlock();\n\n\tpreempt_disable();\n\tdev_sw_netstats_rx_add(tun->dev, len);\n\tpreempt_enable();\n\n\tif (rxhash)\n\t\ttun_flow_update(tun, rxhash, tfile);\n\n\treturn total_len;\n\ndrop:\n\tif (err != -EAGAIN)\n\t\tdev_core_stats_rx_dropped_inc(tun->dev);\n\nfree_skb:\n\tif (!IS_ERR_OR_NULL(skb))\n\t\tkfree_skb_reason(skb, drop_reason);\n\nunlock_frags:\n\tif (frags) {\n\t\ttfile->napi.skb = NULL;\n\t\tmutex_unlock(&tfile->napi_mutex);\n\t}\n\n\treturn err ?: total_len;\n}\n\nstatic ssize_t tun_chr_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = tun_get(tfile);\n\tssize_t result;\n\tint noblock = 0;\n\n\tif (!tun)\n\t\treturn -EBADFD;\n\n\tif ((file->f_flags & O_NONBLOCK) || (iocb->ki_flags & IOCB_NOWAIT))\n\t\tnoblock = 1;\n\n\tresult = tun_get_user(tun, tfile, NULL, from, noblock, false);\n\n\ttun_put(tun);\n\treturn result;\n}\n\nstatic ssize_t tun_put_user_xdp(struct tun_struct *tun,\n\t\t\t\tstruct tun_file *tfile,\n\t\t\t\tstruct xdp_frame *xdp_frame,\n\t\t\t\tstruct iov_iter *iter)\n{\n\tint vnet_hdr_sz = 0;\n\tsize_t size = xdp_frame->len;\n\tsize_t ret;\n\n\tif (tun->flags & IFF_VNET_HDR) {\n\t\tstruct virtio_net_hdr gso = { 0 };\n\n\t\tvnet_hdr_sz = READ_ONCE(tun->vnet_hdr_sz);\n\t\tif (unlikely(iov_iter_count(iter) < vnet_hdr_sz))\n\t\t\treturn -EINVAL;\n\t\tif (unlikely(copy_to_iter(&gso, sizeof(gso), iter) !=\n\t\t\t     sizeof(gso)))\n\t\t\treturn -EFAULT;\n\t\tiov_iter_advance(iter, vnet_hdr_sz - sizeof(gso));\n\t}\n\n\tret = copy_to_iter(xdp_frame->data, size, iter) + vnet_hdr_sz;\n\n\tpreempt_disable();\n\tdev_sw_netstats_tx_add(tun->dev, 1, ret);\n\tpreempt_enable();\n\n\treturn ret;\n}\n\n \nstatic ssize_t tun_put_user(struct tun_struct *tun,\n\t\t\t    struct tun_file *tfile,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct iov_iter *iter)\n{\n\tstruct tun_pi pi = { 0, skb->protocol };\n\tssize_t total;\n\tint vlan_offset = 0;\n\tint vlan_hlen = 0;\n\tint vnet_hdr_sz = 0;\n\n\tif (skb_vlan_tag_present(skb))\n\t\tvlan_hlen = VLAN_HLEN;\n\n\tif (tun->flags & IFF_VNET_HDR)\n\t\tvnet_hdr_sz = READ_ONCE(tun->vnet_hdr_sz);\n\n\ttotal = skb->len + vlan_hlen + vnet_hdr_sz;\n\n\tif (!(tun->flags & IFF_NO_PI)) {\n\t\tif (iov_iter_count(iter) < sizeof(pi))\n\t\t\treturn -EINVAL;\n\n\t\ttotal += sizeof(pi);\n\t\tif (iov_iter_count(iter) < total) {\n\t\t\t \n\t\t\tpi.flags |= TUN_PKT_STRIP;\n\t\t}\n\n\t\tif (copy_to_iter(&pi, sizeof(pi), iter) != sizeof(pi))\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (vnet_hdr_sz) {\n\t\tstruct virtio_net_hdr gso;\n\n\t\tif (iov_iter_count(iter) < vnet_hdr_sz)\n\t\t\treturn -EINVAL;\n\n\t\tif (virtio_net_hdr_from_skb(skb, &gso,\n\t\t\t\t\t    tun_is_little_endian(tun), true,\n\t\t\t\t\t    vlan_hlen)) {\n\t\t\tstruct skb_shared_info *sinfo = skb_shinfo(skb);\n\t\t\tpr_err(\"unexpected GSO type: \"\n\t\t\t       \"0x%x, gso_size %d, hdr_len %d\\n\",\n\t\t\t       sinfo->gso_type, tun16_to_cpu(tun, gso.gso_size),\n\t\t\t       tun16_to_cpu(tun, gso.hdr_len));\n\t\t\tprint_hex_dump(KERN_ERR, \"tun: \",\n\t\t\t\t       DUMP_PREFIX_NONE,\n\t\t\t\t       16, 1, skb->head,\n\t\t\t\t       min((int)tun16_to_cpu(tun, gso.hdr_len), 64), true);\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (copy_to_iter(&gso, sizeof(gso), iter) != sizeof(gso))\n\t\t\treturn -EFAULT;\n\n\t\tiov_iter_advance(iter, vnet_hdr_sz - sizeof(gso));\n\t}\n\n\tif (vlan_hlen) {\n\t\tint ret;\n\t\tstruct veth veth;\n\n\t\tveth.h_vlan_proto = skb->vlan_proto;\n\t\tveth.h_vlan_TCI = htons(skb_vlan_tag_get(skb));\n\n\t\tvlan_offset = offsetof(struct vlan_ethhdr, h_vlan_proto);\n\n\t\tret = skb_copy_datagram_iter(skb, 0, iter, vlan_offset);\n\t\tif (ret || !iov_iter_count(iter))\n\t\t\tgoto done;\n\n\t\tret = copy_to_iter(&veth, sizeof(veth), iter);\n\t\tif (ret != sizeof(veth) || !iov_iter_count(iter))\n\t\t\tgoto done;\n\t}\n\n\tskb_copy_datagram_iter(skb, vlan_offset, iter, skb->len - vlan_offset);\n\ndone:\n\t \n\tpreempt_disable();\n\tdev_sw_netstats_tx_add(tun->dev, 1, skb->len + vlan_hlen);\n\tpreempt_enable();\n\n\treturn total;\n}\n\nstatic void *tun_ring_recv(struct tun_file *tfile, int noblock, int *err)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tvoid *ptr = NULL;\n\tint error = 0;\n\n\tptr = ptr_ring_consume(&tfile->tx_ring);\n\tif (ptr)\n\t\tgoto out;\n\tif (noblock) {\n\t\terror = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tadd_wait_queue(&tfile->socket.wq.wait, &wait);\n\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tptr = ptr_ring_consume(&tfile->tx_ring);\n\t\tif (ptr)\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\terror = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (tfile->socket.sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\terror = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tschedule();\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tfile->socket.wq.wait, &wait);\n\nout:\n\t*err = error;\n\treturn ptr;\n}\n\nstatic ssize_t tun_do_read(struct tun_struct *tun, struct tun_file *tfile,\n\t\t\t   struct iov_iter *to,\n\t\t\t   int noblock, void *ptr)\n{\n\tssize_t ret;\n\tint err;\n\n\tif (!iov_iter_count(to)) {\n\t\ttun_ptr_free(ptr);\n\t\treturn 0;\n\t}\n\n\tif (!ptr) {\n\t\t \n\t\tptr = tun_ring_recv(tfile, noblock, &err);\n\t\tif (!ptr)\n\t\t\treturn err;\n\t}\n\n\tif (tun_is_xdp_frame(ptr)) {\n\t\tstruct xdp_frame *xdpf = tun_ptr_to_xdp(ptr);\n\n\t\tret = tun_put_user_xdp(tun, tfile, xdpf, to);\n\t\txdp_return_frame(xdpf);\n\t} else {\n\t\tstruct sk_buff *skb = ptr;\n\n\t\tret = tun_put_user(tun, tfile, skb, to);\n\t\tif (unlikely(ret < 0))\n\t\t\tkfree_skb(skb);\n\t\telse\n\t\t\tconsume_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t tun_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = tun_get(tfile);\n\tssize_t len = iov_iter_count(to), ret;\n\tint noblock = 0;\n\n\tif (!tun)\n\t\treturn -EBADFD;\n\n\tif ((file->f_flags & O_NONBLOCK) || (iocb->ki_flags & IOCB_NOWAIT))\n\t\tnoblock = 1;\n\n\tret = tun_do_read(tun, tfile, to, noblock, NULL);\n\tret = min_t(ssize_t, ret, len);\n\tif (ret > 0)\n\t\tiocb->ki_pos = ret;\n\ttun_put(tun);\n\treturn ret;\n}\n\nstatic void tun_prog_free(struct rcu_head *rcu)\n{\n\tstruct tun_prog *prog = container_of(rcu, struct tun_prog, rcu);\n\n\tbpf_prog_destroy(prog->prog);\n\tkfree(prog);\n}\n\nstatic int __tun_set_ebpf(struct tun_struct *tun,\n\t\t\t  struct tun_prog __rcu **prog_p,\n\t\t\t  struct bpf_prog *prog)\n{\n\tstruct tun_prog *old, *new = NULL;\n\n\tif (prog) {\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tnew->prog = prog;\n\t}\n\n\tspin_lock_bh(&tun->lock);\n\told = rcu_dereference_protected(*prog_p,\n\t\t\t\t\tlockdep_is_held(&tun->lock));\n\trcu_assign_pointer(*prog_p, new);\n\tspin_unlock_bh(&tun->lock);\n\n\tif (old)\n\t\tcall_rcu(&old->rcu, tun_prog_free);\n\n\treturn 0;\n}\n\nstatic void tun_free_netdev(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tBUG_ON(!(list_empty(&tun->disabled)));\n\n\tfree_percpu(dev->tstats);\n\ttun_flow_uninit(tun);\n\tsecurity_tun_dev_free_security(tun->security);\n\t__tun_set_ebpf(tun, &tun->steering_prog, NULL);\n\t__tun_set_ebpf(tun, &tun->filter_prog, NULL);\n}\n\nstatic void tun_setup(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\ttun->owner = INVALID_UID;\n\ttun->group = INVALID_GID;\n\ttun_default_link_ksettings(dev, &tun->link_ksettings);\n\n\tdev->ethtool_ops = &tun_ethtool_ops;\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = tun_free_netdev;\n\t \n\tdev->tx_queue_len = TUN_READQ_SIZE;\n}\n\n \nstatic int tun_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tNL_SET_ERR_MSG(extack,\n\t\t       \"tun/tap creation via rtnetlink is not supported.\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic size_t tun_get_size(const struct net_device *dev)\n{\n\tBUILD_BUG_ON(sizeof(u32) != sizeof(uid_t));\n\tBUILD_BUG_ON(sizeof(u32) != sizeof(gid_t));\n\n\treturn nla_total_size(sizeof(uid_t)) +  \n\t       nla_total_size(sizeof(gid_t)) +  \n\t       nla_total_size(sizeof(u8)) +  \n\t       nla_total_size(sizeof(u8)) +  \n\t       nla_total_size(sizeof(u8)) +  \n\t       nla_total_size(sizeof(u8)) +  \n\t       nla_total_size(sizeof(u8)) +  \n\t       nla_total_size(sizeof(u32)) +  \n\t       nla_total_size(sizeof(u32)) +  \n\t       0;\n}\n\nstatic int tun_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tif (nla_put_u8(skb, IFLA_TUN_TYPE, tun->flags & TUN_TYPE_MASK))\n\t\tgoto nla_put_failure;\n\tif (uid_valid(tun->owner) &&\n\t    nla_put_u32(skb, IFLA_TUN_OWNER,\n\t\t\tfrom_kuid_munged(current_user_ns(), tun->owner)))\n\t\tgoto nla_put_failure;\n\tif (gid_valid(tun->group) &&\n\t    nla_put_u32(skb, IFLA_TUN_GROUP,\n\t\t\tfrom_kgid_munged(current_user_ns(), tun->group)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(skb, IFLA_TUN_PI, !(tun->flags & IFF_NO_PI)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(skb, IFLA_TUN_VNET_HDR, !!(tun->flags & IFF_VNET_HDR)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(skb, IFLA_TUN_PERSIST, !!(tun->flags & IFF_PERSIST)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(skb, IFLA_TUN_MULTI_QUEUE,\n\t\t       !!(tun->flags & IFF_MULTI_QUEUE)))\n\t\tgoto nla_put_failure;\n\tif (tun->flags & IFF_MULTI_QUEUE) {\n\t\tif (nla_put_u32(skb, IFLA_TUN_NUM_QUEUES, tun->numqueues))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, IFLA_TUN_NUM_DISABLED_QUEUES,\n\t\t\t\ttun->numdisabled))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic struct rtnl_link_ops tun_link_ops __read_mostly = {\n\t.kind\t\t= DRV_NAME,\n\t.priv_size\t= sizeof(struct tun_struct),\n\t.setup\t\t= tun_setup,\n\t.validate\t= tun_validate,\n\t.get_size       = tun_get_size,\n\t.fill_info      = tun_fill_info,\n};\n\nstatic void tun_sock_write_space(struct sock *sk)\n{\n\tstruct tun_file *tfile;\n\twait_queue_head_t *wqueue;\n\n\tif (!sock_writeable(sk))\n\t\treturn;\n\n\tif (!test_and_clear_bit(SOCKWQ_ASYNC_NOSPACE, &sk->sk_socket->flags))\n\t\treturn;\n\n\twqueue = sk_sleep(sk);\n\tif (wqueue && waitqueue_active(wqueue))\n\t\twake_up_interruptible_sync_poll(wqueue, EPOLLOUT |\n\t\t\t\t\t\tEPOLLWRNORM | EPOLLWRBAND);\n\n\ttfile = container_of(sk, struct tun_file, sk);\n\tkill_fasync(&tfile->fasync, SIGIO, POLL_OUT);\n}\n\nstatic void tun_put_page(struct tun_page *tpage)\n{\n\tif (tpage->page)\n\t\t__page_frag_cache_drain(tpage->page, tpage->count);\n}\n\nstatic int tun_xdp_one(struct tun_struct *tun,\n\t\t       struct tun_file *tfile,\n\t\t       struct xdp_buff *xdp, int *flush,\n\t\t       struct tun_page *tpage)\n{\n\tunsigned int datasize = xdp->data_end - xdp->data;\n\tstruct tun_xdp_hdr *hdr = xdp->data_hard_start;\n\tstruct virtio_net_hdr *gso = &hdr->gso;\n\tstruct bpf_prog *xdp_prog;\n\tstruct sk_buff *skb = NULL;\n\tstruct sk_buff_head *queue;\n\tu32 rxhash = 0, act;\n\tint buflen = hdr->buflen;\n\tint ret = 0;\n\tbool skb_xdp = false;\n\tstruct page *page;\n\n\txdp_prog = rcu_dereference(tun->xdp_prog);\n\tif (xdp_prog) {\n\t\tif (gso->gso_type) {\n\t\t\tskb_xdp = true;\n\t\t\tgoto build;\n\t\t}\n\n\t\txdp_init_buff(xdp, buflen, &tfile->xdp_rxq);\n\t\txdp_set_data_meta_invalid(xdp);\n\n\t\tact = bpf_prog_run_xdp(xdp_prog, xdp);\n\t\tret = tun_xdp_act(tun, xdp_prog, xdp, act);\n\t\tif (ret < 0) {\n\t\t\tput_page(virt_to_head_page(xdp->data));\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase XDP_REDIRECT:\n\t\t\t*flush = true;\n\t\t\tfallthrough;\n\t\tcase XDP_TX:\n\t\t\treturn 0;\n\t\tcase XDP_PASS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpage = virt_to_head_page(xdp->data);\n\t\t\tif (tpage->page == page) {\n\t\t\t\t++tpage->count;\n\t\t\t} else {\n\t\t\t\ttun_put_page(tpage);\n\t\t\t\ttpage->page = page;\n\t\t\t\ttpage->count = 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\nbuild:\n\tskb = build_skb(xdp->data_hard_start, buflen);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tskb_reserve(skb, xdp->data - xdp->data_hard_start);\n\tskb_put(skb, xdp->data_end - xdp->data);\n\n\tif (virtio_net_hdr_to_skb(skb, gso, tun_is_little_endian(tun))) {\n\t\tatomic_long_inc(&tun->rx_frame_errors);\n\t\tkfree_skb(skb);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tskb->protocol = eth_type_trans(skb, tun->dev);\n\tskb_reset_network_header(skb);\n\tskb_probe_transport_header(skb);\n\tskb_record_rx_queue(skb, tfile->queue_index);\n\n\tif (skb_xdp) {\n\t\tret = do_xdp_generic(xdp_prog, skb);\n\t\tif (ret != XDP_PASS) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!rcu_dereference(tun->steering_prog) && tun->numqueues > 1 &&\n\t    !tfile->detached)\n\t\trxhash = __skb_get_hash_symmetric(skb);\n\n\tif (tfile->napi_enabled) {\n\t\tqueue = &tfile->sk.sk_write_queue;\n\t\tspin_lock(&queue->lock);\n\n\t\tif (unlikely(tfile->detached)) {\n\t\t\tspin_unlock(&queue->lock);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t__skb_queue_tail(queue, skb);\n\t\tspin_unlock(&queue->lock);\n\t\tret = 1;\n\t} else {\n\t\tnetif_receive_skb(skb);\n\t\tret = 0;\n\t}\n\n\t \n\tdev_sw_netstats_rx_add(tun->dev, datasize);\n\n\tif (rxhash)\n\t\ttun_flow_update(tun, rxhash, tfile);\n\nout:\n\treturn ret;\n}\n\nstatic int tun_sendmsg(struct socket *sock, struct msghdr *m, size_t total_len)\n{\n\tint ret, i;\n\tstruct tun_file *tfile = container_of(sock, struct tun_file, socket);\n\tstruct tun_struct *tun = tun_get(tfile);\n\tstruct tun_msg_ctl *ctl = m->msg_control;\n\tstruct xdp_buff *xdp;\n\n\tif (!tun)\n\t\treturn -EBADFD;\n\n\tif (m->msg_controllen == sizeof(struct tun_msg_ctl) &&\n\t    ctl && ctl->type == TUN_MSG_PTR) {\n\t\tstruct tun_page tpage;\n\t\tint n = ctl->num;\n\t\tint flush = 0, queued = 0;\n\n\t\tmemset(&tpage, 0, sizeof(tpage));\n\n\t\tlocal_bh_disable();\n\t\trcu_read_lock();\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\txdp = &((struct xdp_buff *)ctl->ptr)[i];\n\t\t\tret = tun_xdp_one(tun, tfile, xdp, &flush, &tpage);\n\t\t\tif (ret > 0)\n\t\t\t\tqueued += ret;\n\t\t}\n\n\t\tif (flush)\n\t\t\txdp_do_flush();\n\n\t\tif (tfile->napi_enabled && queued > 0)\n\t\t\tnapi_schedule(&tfile->napi);\n\n\t\trcu_read_unlock();\n\t\tlocal_bh_enable();\n\n\t\ttun_put_page(&tpage);\n\n\t\tret = total_len;\n\t\tgoto out;\n\t}\n\n\tret = tun_get_user(tun, tfile, ctl ? ctl->ptr : NULL, &m->msg_iter,\n\t\t\t   m->msg_flags & MSG_DONTWAIT,\n\t\t\t   m->msg_flags & MSG_MORE);\nout:\n\ttun_put(tun);\n\treturn ret;\n}\n\nstatic int tun_recvmsg(struct socket *sock, struct msghdr *m, size_t total_len,\n\t\t       int flags)\n{\n\tstruct tun_file *tfile = container_of(sock, struct tun_file, socket);\n\tstruct tun_struct *tun = tun_get(tfile);\n\tvoid *ptr = m->msg_control;\n\tint ret;\n\n\tif (!tun) {\n\t\tret = -EBADFD;\n\t\tgoto out_free;\n\t}\n\n\tif (flags & ~(MSG_DONTWAIT|MSG_TRUNC|MSG_ERRQUEUE)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_tun;\n\t}\n\tif (flags & MSG_ERRQUEUE) {\n\t\tret = sock_recv_errqueue(sock->sk, m, total_len,\n\t\t\t\t\t SOL_PACKET, TUN_TX_TIMESTAMP);\n\t\tgoto out;\n\t}\n\tret = tun_do_read(tun, tfile, &m->msg_iter, flags & MSG_DONTWAIT, ptr);\n\tif (ret > (ssize_t)total_len) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tret = flags & MSG_TRUNC ? ret : total_len;\n\t}\nout:\n\ttun_put(tun);\n\treturn ret;\n\nout_put_tun:\n\ttun_put(tun);\nout_free:\n\ttun_ptr_free(ptr);\n\treturn ret;\n}\n\nstatic int tun_ptr_peek_len(void *ptr)\n{\n\tif (likely(ptr)) {\n\t\tif (tun_is_xdp_frame(ptr)) {\n\t\t\tstruct xdp_frame *xdpf = tun_ptr_to_xdp(ptr);\n\n\t\t\treturn xdpf->len;\n\t\t}\n\t\treturn __skb_array_len_with_tag(ptr);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic int tun_peek_len(struct socket *sock)\n{\n\tstruct tun_file *tfile = container_of(sock, struct tun_file, socket);\n\tstruct tun_struct *tun;\n\tint ret = 0;\n\n\ttun = tun_get(tfile);\n\tif (!tun)\n\t\treturn 0;\n\n\tret = PTR_RING_PEEK_CALL(&tfile->tx_ring, tun_ptr_peek_len);\n\ttun_put(tun);\n\n\treturn ret;\n}\n\n \nstatic const struct proto_ops tun_socket_ops = {\n\t.peek_len = tun_peek_len,\n\t.sendmsg = tun_sendmsg,\n\t.recvmsg = tun_recvmsg,\n};\n\nstatic struct proto tun_proto = {\n\t.name\t\t= \"tun\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct tun_file),\n};\n\nstatic int tun_flags(struct tun_struct *tun)\n{\n\treturn tun->flags & (TUN_FEATURES | IFF_PERSIST | IFF_TUN | IFF_TAP);\n}\n\nstatic ssize_t tun_flags_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct tun_struct *tun = netdev_priv(to_net_dev(dev));\n\treturn sysfs_emit(buf, \"0x%x\\n\", tun_flags(tun));\n}\n\nstatic ssize_t owner_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct tun_struct *tun = netdev_priv(to_net_dev(dev));\n\treturn uid_valid(tun->owner)?\n\t\tsysfs_emit(buf, \"%u\\n\",\n\t\t\t   from_kuid_munged(current_user_ns(), tun->owner)) :\n\t\tsysfs_emit(buf, \"-1\\n\");\n}\n\nstatic ssize_t group_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct tun_struct *tun = netdev_priv(to_net_dev(dev));\n\treturn gid_valid(tun->group) ?\n\t\tsysfs_emit(buf, \"%u\\n\",\n\t\t\t   from_kgid_munged(current_user_ns(), tun->group)) :\n\t\tsysfs_emit(buf, \"-1\\n\");\n}\n\nstatic DEVICE_ATTR_RO(tun_flags);\nstatic DEVICE_ATTR_RO(owner);\nstatic DEVICE_ATTR_RO(group);\n\nstatic struct attribute *tun_dev_attrs[] = {\n\t&dev_attr_tun_flags.attr,\n\t&dev_attr_owner.attr,\n\t&dev_attr_group.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tun_attr_group = {\n\t.attrs = tun_dev_attrs\n};\n\nstatic int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct tun_struct *tun;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (tfile->detached)\n\t\treturn -EINVAL;\n\n\tif ((ifr->ifr_flags & IFF_NAPI_FRAGS)) {\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!(ifr->ifr_flags & IFF_NAPI) ||\n\t\t    (ifr->ifr_flags & TUN_TYPE_MASK) != IFF_TAP)\n\t\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)\n\t\t\treturn -EBUSY;\n\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=\n\t\t    !!(tun->flags & IFF_MULTI_QUEUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (tun_not_capable(tun))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_open(tun->security);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER,\n\t\t\t\t ifr->ifr_flags & IFF_NAPI,\n\t\t\t\t ifr->ifr_flags & IFF_NAPI_FRAGS, true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tun->flags & IFF_MULTI_QUEUE &&\n\t\t    (tun->numqueues + tun->numdisabled > 1)) {\n\t\t\t \n\t\t\tnetdev_state_change(dev);\n\t\t\treturn 0;\n\t\t}\n\n\t\ttun->flags = (tun->flags & ~TUN_FEATURES) |\n\t\t\t      (ifr->ifr_flags & TUN_FEATURES);\n\n\t\tnetdev_state_change(dev);\n\t} else {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?\n\t\t\t     MAX_TAP_QUEUES : 1;\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tif (ifr->ifr_flags & IFF_TUN) {\n\t\t\t \n\t\t\tflags |= IFF_TUN;\n\t\t\tname = \"tun%d\";\n\t\t} else if (ifr->ifr_flags & IFF_TAP) {\n\t\t\t \n\t\t\tflags |= IFF_TAP;\n\t\t\tname = \"tap%d\";\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tif (*ifr->ifr_name)\n\t\t\tname = ifr->ifr_name;\n\n\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,\n\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,\n\t\t\t\t       queues);\n\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_net_set(dev, net);\n\t\tdev->rtnl_link_ops = &tun_link_ops;\n\t\tdev->ifindex = tfile->ifindex;\n\t\tdev->sysfs_groups[0] = &tun_attr_group;\n\n\t\ttun = netdev_priv(dev);\n\t\ttun->dev = dev;\n\t\ttun->flags = flags;\n\t\ttun->txflt.count = 0;\n\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\ttun->align = NET_SKB_PAD;\n\t\ttun->filter_attached = false;\n\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;\n\t\ttun->rx_batched = 0;\n\t\tRCU_INIT_POINTER(tun->steering_prog, NULL);\n\n\t\ttun->ifr = ifr;\n\t\ttun->file = file;\n\n\t\ttun_net_initialize(dev);\n\n\t\terr = register_netdevice(tun->dev);\n\t\tif (err < 0) {\n\t\t\tfree_netdev(dev);\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\trcu_assign_pointer(tfile->tun, tun);\n\t}\n\n\tif (ifr->ifr_flags & IFF_NO_CARRIER)\n\t\tnetif_carrier_off(tun->dev);\n\telse\n\t\tnetif_carrier_on(tun->dev);\n\n\t \n\tif (netif_running(tun->dev))\n\t\tnetif_tx_wake_all_queues(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n}\n\nstatic void tun_get_iff(struct tun_struct *tun, struct ifreq *ifr)\n{\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\n\tifr->ifr_flags = tun_flags(tun);\n\n}\n\n \nstatic int set_offload(struct tun_struct *tun, unsigned long arg)\n{\n\tnetdev_features_t features = 0;\n\n\tif (arg & TUN_F_CSUM) {\n\t\tfeatures |= NETIF_F_HW_CSUM;\n\t\targ &= ~TUN_F_CSUM;\n\n\t\tif (arg & (TUN_F_TSO4|TUN_F_TSO6)) {\n\t\t\tif (arg & TUN_F_TSO_ECN) {\n\t\t\t\tfeatures |= NETIF_F_TSO_ECN;\n\t\t\t\targ &= ~TUN_F_TSO_ECN;\n\t\t\t}\n\t\t\tif (arg & TUN_F_TSO4)\n\t\t\t\tfeatures |= NETIF_F_TSO;\n\t\t\tif (arg & TUN_F_TSO6)\n\t\t\t\tfeatures |= NETIF_F_TSO6;\n\t\t\targ &= ~(TUN_F_TSO4|TUN_F_TSO6);\n\t\t}\n\n\t\targ &= ~TUN_F_UFO;\n\n\t\t \n\t\tif (arg & TUN_F_USO4 && arg & TUN_F_USO6) {\n\t\t\tfeatures |= NETIF_F_GSO_UDP_L4;\n\t\t\targ &= ~(TUN_F_USO4 | TUN_F_USO6);\n\t\t}\n\t}\n\n\t \n\tif (arg)\n\t\treturn -EINVAL;\n\n\ttun->set_features = features;\n\ttun->dev->wanted_features &= ~TUN_USER_FEATURES;\n\ttun->dev->wanted_features |= features;\n\tnetdev_update_features(tun->dev);\n\n\treturn 0;\n}\n\nstatic void tun_detach_filter(struct tun_struct *tun, int n)\n{\n\tint i;\n\tstruct tun_file *tfile;\n\n\tfor (i = 0; i < n; i++) {\n\t\ttfile = rtnl_dereference(tun->tfiles[i]);\n\t\tlock_sock(tfile->socket.sk);\n\t\tsk_detach_filter(tfile->socket.sk);\n\t\trelease_sock(tfile->socket.sk);\n\t}\n\n\ttun->filter_attached = false;\n}\n\nstatic int tun_attach_filter(struct tun_struct *tun)\n{\n\tint i, ret = 0;\n\tstruct tun_file *tfile;\n\n\tfor (i = 0; i < tun->numqueues; i++) {\n\t\ttfile = rtnl_dereference(tun->tfiles[i]);\n\t\tlock_sock(tfile->socket.sk);\n\t\tret = sk_attach_filter(&tun->fprog, tfile->socket.sk);\n\t\trelease_sock(tfile->socket.sk);\n\t\tif (ret) {\n\t\t\ttun_detach_filter(tun, i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttun->filter_attached = true;\n\treturn ret;\n}\n\nstatic void tun_set_sndbuf(struct tun_struct *tun)\n{\n\tstruct tun_file *tfile;\n\tint i;\n\n\tfor (i = 0; i < tun->numqueues; i++) {\n\t\ttfile = rtnl_dereference(tun->tfiles[i]);\n\t\ttfile->socket.sk->sk_sndbuf = tun->sndbuf;\n\t}\n}\n\nstatic int tun_set_queue(struct file *file, struct ifreq *ifr)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\tint ret = 0;\n\n\trtnl_lock();\n\n\tif (ifr->ifr_flags & IFF_ATTACH_QUEUE) {\n\t\ttun = tfile->detached;\n\t\tif (!tun) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\tret = security_tun_dev_attach_queue(tun->security);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t\tret = tun_attach(tun, file, false, tun->flags & IFF_NAPI,\n\t\t\t\t tun->flags & IFF_NAPI_FRAGS, true);\n\t} else if (ifr->ifr_flags & IFF_DETACH_QUEUE) {\n\t\ttun = rtnl_dereference(tfile->tun);\n\t\tif (!tun || !(tun->flags & IFF_MULTI_QUEUE) || tfile->detached)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\t__tun_detach(tfile, false);\n\t} else\n\t\tret = -EINVAL;\n\n\tif (ret >= 0)\n\t\tnetdev_state_change(tun->dev);\n\nunlock:\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic int tun_set_ebpf(struct tun_struct *tun, struct tun_prog __rcu **prog_p,\n\t\t\tvoid __user *data)\n{\n\tstruct bpf_prog *prog;\n\tint fd;\n\n\tif (copy_from_user(&fd, data, sizeof(fd)))\n\t\treturn -EFAULT;\n\n\tif (fd == -1) {\n\t\tprog = NULL;\n\t} else {\n\t\tprog = bpf_prog_get_type(fd, BPF_PROG_TYPE_SOCKET_FILTER);\n\t\tif (IS_ERR(prog))\n\t\t\treturn PTR_ERR(prog);\n\t}\n\n\treturn __tun_set_ebpf(tun, prog_p, prog);\n}\n\n \nstatic unsigned char tun_get_addr_len(unsigned short type)\n{\n\tswitch (type) {\n\tcase ARPHRD_IP6GRE:\n\tcase ARPHRD_TUNNEL6:\n\t\treturn sizeof(struct in6_addr);\n\tcase ARPHRD_IPGRE:\n\tcase ARPHRD_TUNNEL:\n\tcase ARPHRD_SIT:\n\t\treturn 4;\n\tcase ARPHRD_ETHER:\n\t\treturn ETH_ALEN;\n\tcase ARPHRD_IEEE802154:\n\tcase ARPHRD_IEEE802154_MONITOR:\n\t\treturn IEEE802154_EXTENDED_ADDR_LEN;\n\tcase ARPHRD_PHONET_PIPE:\n\tcase ARPHRD_PPP:\n\tcase ARPHRD_NONE:\n\t\treturn 0;\n\tcase ARPHRD_6LOWPAN:\n\t\treturn EUI64_ADDR_LEN;\n\tcase ARPHRD_FDDI:\n\t\treturn FDDI_K_ALEN;\n\tcase ARPHRD_HIPPI:\n\t\treturn HIPPI_ALEN;\n\tcase ARPHRD_IEEE802:\n\t\treturn FC_ALEN;\n\tcase ARPHRD_ROSE:\n\t\treturn ROSE_ADDR_LEN;\n\tcase ARPHRD_NETROM:\n\t\treturn AX25_ADDR_LEN;\n\tcase ARPHRD_LOCALTLK:\n\t\treturn LTALK_ALEN;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic long __tun_chr_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg, int ifreq_len)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net *net = sock_net(&tfile->sk);\n\tstruct tun_struct *tun;\n\tvoid __user* argp = (void __user*)arg;\n\tunsigned int carrier;\n\tstruct ifreq ifr;\n\tkuid_t owner;\n\tkgid_t group;\n\tint ifindex;\n\tint sndbuf;\n\tint vnet_hdr_sz;\n\tint le;\n\tint ret;\n\tbool do_notify = false;\n\n\tif (cmd == TUNSETIFF || cmd == TUNSETQUEUE ||\n\t    (_IOC_TYPE(cmd) == SOCK_IOC_TYPE && cmd != SIOCGSKNS)) {\n\t\tif (copy_from_user(&ifr, argp, ifreq_len))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(&ifr, 0, sizeof(ifr));\n\t}\n\tif (cmd == TUNGETFEATURES) {\n\t\t \n\t\treturn put_user(IFF_TUN | IFF_TAP | IFF_NO_CARRIER |\n\t\t\t\tTUN_FEATURES, (unsigned int __user*)argp);\n\t} else if (cmd == TUNSETQUEUE) {\n\t\treturn tun_set_queue(file, &ifr);\n\t} else if (cmd == SIOCGSKNS) {\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn open_related_ns(&net->ns, get_net_ns);\n\t}\n\n\trtnl_lock();\n\n\ttun = tun_get(tfile);\n\tif (cmd == TUNSETIFF) {\n\t\tret = -EEXIST;\n\t\tif (tun)\n\t\t\tgoto unlock;\n\n\t\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\n\t\tret = tun_set_iff(net, file, &ifr);\n\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tgoto unlock;\n\t}\n\tif (cmd == TUNSETIFINDEX) {\n\t\tret = -EPERM;\n\t\tif (tun)\n\t\t\tgoto unlock;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(&ifindex, argp, sizeof(ifindex)))\n\t\t\tgoto unlock;\n\t\tret = -EINVAL;\n\t\tif (ifindex < 0)\n\t\t\tgoto unlock;\n\t\tret = 0;\n\t\ttfile->ifindex = ifindex;\n\t\tgoto unlock;\n\t}\n\n\tret = -EBADFD;\n\tif (!tun)\n\t\tgoto unlock;\n\n\tnetif_info(tun, drv, tun->dev, \"tun_chr_ioctl cmd %u\\n\", cmd);\n\n\tnet = dev_net(tun->dev);\n\tret = 0;\n\tswitch (cmd) {\n\tcase TUNGETIFF:\n\t\ttun_get_iff(tun, &ifr);\n\n\t\tif (tfile->detached)\n\t\t\tifr.ifr_flags |= IFF_DETACH_QUEUE;\n\t\tif (!tfile->socket.sk->sk_filter)\n\t\t\tifr.ifr_flags |= IFF_NOFILTER;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETNOCSUM:\n\t\t \n\n\t\t \n\t\tnetif_info(tun, drv, tun->dev, \"ignored: set checksum %s\\n\",\n\t\t\t   arg ? \"disabled\" : \"enabled\");\n\t\tbreak;\n\n\tcase TUNSETPERSIST:\n\t\t \n\t\tif (arg && !(tun->flags & IFF_PERSIST)) {\n\t\t\ttun->flags |= IFF_PERSIST;\n\t\t\t__module_get(THIS_MODULE);\n\t\t\tdo_notify = true;\n\t\t}\n\t\tif (!arg && (tun->flags & IFF_PERSIST)) {\n\t\t\ttun->flags &= ~IFF_PERSIST;\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\tdo_notify = true;\n\t\t}\n\n\t\tnetif_info(tun, drv, tun->dev, \"persist %s\\n\",\n\t\t\t   arg ? \"enabled\" : \"disabled\");\n\t\tbreak;\n\n\tcase TUNSETOWNER:\n\t\t \n\t\towner = make_kuid(current_user_ns(), arg);\n\t\tif (!uid_valid(owner)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\ttun->owner = owner;\n\t\tdo_notify = true;\n\t\tnetif_info(tun, drv, tun->dev, \"owner set to %u\\n\",\n\t\t\t   from_kuid(&init_user_ns, tun->owner));\n\t\tbreak;\n\n\tcase TUNSETGROUP:\n\t\t \n\t\tgroup = make_kgid(current_user_ns(), arg);\n\t\tif (!gid_valid(group)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\ttun->group = group;\n\t\tdo_notify = true;\n\t\tnetif_info(tun, drv, tun->dev, \"group set to %u\\n\",\n\t\t\t   from_kgid(&init_user_ns, tun->group));\n\t\tbreak;\n\n\tcase TUNSETLINK:\n\t\t \n\t\tif (tun->dev->flags & IFF_UP) {\n\t\t\tnetif_info(tun, drv, tun->dev,\n\t\t\t\t   \"Linktype set failed because interface is up\\n\");\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tret = call_netdevice_notifiers(NETDEV_PRE_TYPE_CHANGE,\n\t\t\t\t\t\t       tun->dev);\n\t\t\tret = notifier_to_errno(ret);\n\t\t\tif (ret) {\n\t\t\t\tnetif_info(tun, drv, tun->dev,\n\t\t\t\t\t   \"Refused to change device type\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttun->dev->type = (int) arg;\n\t\t\ttun->dev->addr_len = tun_get_addr_len(tun->dev->type);\n\t\t\tnetif_info(tun, drv, tun->dev, \"linktype set to %d\\n\",\n\t\t\t\t   tun->dev->type);\n\t\t\tcall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE,\n\t\t\t\t\t\t tun->dev);\n\t\t}\n\t\tbreak;\n\n\tcase TUNSETDEBUG:\n\t\ttun->msg_enable = (u32)arg;\n\t\tbreak;\n\n\tcase TUNSETOFFLOAD:\n\t\tret = set_offload(tun, arg);\n\t\tbreak;\n\n\tcase TUNSETTXFILTER:\n\t\t \n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != IFF_TAP)\n\t\t\tbreak;\n\t\tret = update_filter(&tun->txflt, (void __user *)arg);\n\t\tbreak;\n\n\tcase SIOCGIFHWADDR:\n\t\t \n\t\tdev_get_mac_address(&ifr.ifr_hwaddr, net, tun->dev->name);\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase SIOCSIFHWADDR:\n\t\t \n\t\tret = dev_set_mac_address_user(tun->dev, &ifr.ifr_hwaddr, NULL);\n\t\tbreak;\n\n\tcase TUNGETSNDBUF:\n\t\tsndbuf = tfile->socket.sk->sk_sndbuf;\n\t\tif (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETSNDBUF:\n\t\tif (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (sndbuf <= 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->sndbuf = sndbuf;\n\t\ttun_set_sndbuf(tun);\n\t\tbreak;\n\n\tcase TUNGETVNETHDRSZ:\n\t\tvnet_hdr_sz = tun->vnet_hdr_sz;\n\t\tif (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETVNETHDRSZ:\n\t\tif (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->vnet_hdr_sz = vnet_hdr_sz;\n\t\tbreak;\n\n\tcase TUNGETVNETLE:\n\t\tle = !!(tun->flags & TUN_VNET_LE);\n\t\tif (put_user(le, (int __user *)argp))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETVNETLE:\n\t\tif (get_user(le, (int __user *)argp)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (le)\n\t\t\ttun->flags |= TUN_VNET_LE;\n\t\telse\n\t\t\ttun->flags &= ~TUN_VNET_LE;\n\t\tbreak;\n\n\tcase TUNGETVNETBE:\n\t\tret = tun_get_vnet_be(tun, argp);\n\t\tbreak;\n\n\tcase TUNSETVNETBE:\n\t\tret = tun_set_vnet_be(tun, argp);\n\t\tbreak;\n\n\tcase TUNATTACHFILTER:\n\t\t \n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != IFF_TAP)\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(&tun->fprog, argp, sizeof(tun->fprog)))\n\t\t\tbreak;\n\n\t\tret = tun_attach_filter(tun);\n\t\tbreak;\n\n\tcase TUNDETACHFILTER:\n\t\t \n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != IFF_TAP)\n\t\t\tbreak;\n\t\tret = 0;\n\t\ttun_detach_filter(tun, tun->numqueues);\n\t\tbreak;\n\n\tcase TUNGETFILTER:\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != IFF_TAP)\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (copy_to_user(argp, &tun->fprog, sizeof(tun->fprog)))\n\t\t\tbreak;\n\t\tret = 0;\n\t\tbreak;\n\n\tcase TUNSETSTEERINGEBPF:\n\t\tret = tun_set_ebpf(tun, &tun->steering_prog, argp);\n\t\tbreak;\n\n\tcase TUNSETFILTEREBPF:\n\t\tret = tun_set_ebpf(tun, &tun->filter_prog, argp);\n\t\tbreak;\n\n\tcase TUNSETCARRIER:\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(&carrier, argp, sizeof(carrier)))\n\t\t\tgoto unlock;\n\n\t\tret = tun_net_change_carrier(tun->dev, (bool)carrier);\n\t\tbreak;\n\n\tcase TUNGETDEVNETNS:\n\t\tret = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tgoto unlock;\n\t\tret = open_related_ns(&net->ns, get_net_ns);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (do_notify)\n\t\tnetdev_state_change(tun->dev);\n\nunlock:\n\trtnl_unlock();\n\tif (tun)\n\t\ttun_put(tun);\n\treturn ret;\n}\n\nstatic long tun_chr_ioctl(struct file *file,\n\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\treturn __tun_chr_ioctl(file, cmd, arg, sizeof (struct ifreq));\n}\n\n#ifdef CONFIG_COMPAT\nstatic long tun_chr_compat_ioctl(struct file *file,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase TUNSETIFF:\n\tcase TUNGETIFF:\n\tcase TUNSETTXFILTER:\n\tcase TUNGETSNDBUF:\n\tcase TUNSETSNDBUF:\n\tcase SIOCGIFHWADDR:\n\tcase SIOCSIFHWADDR:\n\t\targ = (unsigned long)compat_ptr(arg);\n\t\tbreak;\n\tdefault:\n\t\targ = (compat_ulong_t)arg;\n\t\tbreak;\n\t}\n\n\t \n\treturn __tun_chr_ioctl(file, cmd, arg, sizeof(struct compat_ifreq));\n}\n#endif  \n\nstatic int tun_chr_fasync(int fd, struct file *file, int on)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tint ret;\n\n\tif ((ret = fasync_helper(fd, file, on, &tfile->fasync)) < 0)\n\t\tgoto out;\n\n\tif (on) {\n\t\t__f_setown(file, task_pid(current), PIDTYPE_TGID, 0);\n\t\ttfile->flags |= TUN_FASYNC;\n\t} else\n\t\ttfile->flags &= ~TUN_FASYNC;\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic int tun_chr_open(struct inode *inode, struct file * file)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tstruct tun_file *tfile;\n\n\ttfile = (struct tun_file *)sk_alloc(net, AF_UNSPEC, GFP_KERNEL,\n\t\t\t\t\t    &tun_proto, 0);\n\tif (!tfile)\n\t\treturn -ENOMEM;\n\tif (ptr_ring_init(&tfile->tx_ring, 0, GFP_KERNEL)) {\n\t\tsk_free(&tfile->sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&tfile->napi_mutex);\n\tRCU_INIT_POINTER(tfile->tun, NULL);\n\ttfile->flags = 0;\n\ttfile->ifindex = 0;\n\n\tinit_waitqueue_head(&tfile->socket.wq.wait);\n\n\ttfile->socket.file = file;\n\ttfile->socket.ops = &tun_socket_ops;\n\n\tsock_init_data_uid(&tfile->socket, &tfile->sk, current_fsuid());\n\n\ttfile->sk.sk_write_space = tun_sock_write_space;\n\ttfile->sk.sk_sndbuf = INT_MAX;\n\n\tfile->private_data = tfile;\n\tINIT_LIST_HEAD(&tfile->next);\n\n\tsock_set_flag(&tfile->sk, SOCK_ZEROCOPY);\n\n\t \n\tfile->f_mode |= FMODE_NOWAIT;\n\treturn 0;\n}\n\nstatic int tun_chr_close(struct inode *inode, struct file *file)\n{\n\tstruct tun_file *tfile = file->private_data;\n\n\ttun_detach(tfile, true);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void tun_chr_show_fdinfo(struct seq_file *m, struct file *file)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\tstruct ifreq ifr;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\n\trtnl_lock();\n\ttun = tun_get(tfile);\n\tif (tun)\n\t\ttun_get_iff(tun, &ifr);\n\trtnl_unlock();\n\n\tif (tun)\n\t\ttun_put(tun);\n\n\tseq_printf(m, \"iff:\\t%s\\n\", ifr.ifr_name);\n}\n#endif\n\nstatic const struct file_operations tun_fops = {\n\t.owner\t= THIS_MODULE,\n\t.llseek = no_llseek,\n\t.read_iter  = tun_chr_read_iter,\n\t.write_iter = tun_chr_write_iter,\n\t.poll\t= tun_chr_poll,\n\t.unlocked_ioctl\t= tun_chr_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = tun_chr_compat_ioctl,\n#endif\n\t.open\t= tun_chr_open,\n\t.release = tun_chr_close,\n\t.fasync = tun_chr_fasync,\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo = tun_chr_show_fdinfo,\n#endif\n};\n\nstatic struct miscdevice tun_miscdev = {\n\t.minor = TUN_MINOR,\n\t.name = \"tun\",\n\t.nodename = \"net/tun\",\n\t.fops = &tun_fops,\n};\n\n \n\nstatic void tun_default_link_ksettings(struct net_device *dev,\n\t\t\t\t       struct ethtool_link_ksettings *cmd)\n{\n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\tethtool_link_ksettings_zero_link_mode(cmd, advertising);\n\tcmd->base.speed\t\t= SPEED_10000;\n\tcmd->base.duplex\t= DUPLEX_FULL;\n\tcmd->base.port\t\t= PORT_TP;\n\tcmd->base.phy_address\t= 0;\n\tcmd->base.autoneg\t= AUTONEG_DISABLE;\n}\n\nstatic int tun_get_link_ksettings(struct net_device *dev,\n\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tmemcpy(cmd, &tun->link_ksettings, sizeof(*cmd));\n\treturn 0;\n}\n\nstatic int tun_set_link_ksettings(struct net_device *dev,\n\t\t\t\t  const struct ethtool_link_ksettings *cmd)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tmemcpy(&tun->link_ksettings, cmd, sizeof(*cmd));\n\treturn 0;\n}\n\nstatic void tun_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase IFF_TUN:\n\t\tstrscpy(info->bus_info, \"tun\", sizeof(info->bus_info));\n\t\tbreak;\n\tcase IFF_TAP:\n\t\tstrscpy(info->bus_info, \"tap\", sizeof(info->bus_info));\n\t\tbreak;\n\t}\n}\n\nstatic u32 tun_get_msglevel(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\treturn tun->msg_enable;\n}\n\nstatic void tun_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\ttun->msg_enable = value;\n}\n\nstatic int tun_get_coalesce(struct net_device *dev,\n\t\t\t    struct ethtool_coalesce *ec,\n\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tec->rx_max_coalesced_frames = tun->rx_batched;\n\n\treturn 0;\n}\n\nstatic int tun_set_coalesce(struct net_device *dev,\n\t\t\t    struct ethtool_coalesce *ec,\n\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tif (ec->rx_max_coalesced_frames > NAPI_POLL_WEIGHT)\n\t\ttun->rx_batched = NAPI_POLL_WEIGHT;\n\telse\n\t\ttun->rx_batched = ec->rx_max_coalesced_frames;\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops tun_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_MAX_FRAMES,\n\t.get_drvinfo\t= tun_get_drvinfo,\n\t.get_msglevel\t= tun_get_msglevel,\n\t.set_msglevel\t= tun_set_msglevel,\n\t.get_link\t= ethtool_op_get_link,\n\t.get_ts_info\t= ethtool_op_get_ts_info,\n\t.get_coalesce   = tun_get_coalesce,\n\t.set_coalesce   = tun_set_coalesce,\n\t.get_link_ksettings = tun_get_link_ksettings,\n\t.set_link_ksettings = tun_set_link_ksettings,\n};\n\nstatic int tun_queue_resize(struct tun_struct *tun)\n{\n\tstruct net_device *dev = tun->dev;\n\tstruct tun_file *tfile;\n\tstruct ptr_ring **rings;\n\tint n = tun->numqueues + tun->numdisabled;\n\tint ret, i;\n\n\trings = kmalloc_array(n, sizeof(*rings), GFP_KERNEL);\n\tif (!rings)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < tun->numqueues; i++) {\n\t\ttfile = rtnl_dereference(tun->tfiles[i]);\n\t\trings[i] = &tfile->tx_ring;\n\t}\n\tlist_for_each_entry(tfile, &tun->disabled, next)\n\t\trings[i++] = &tfile->tx_ring;\n\n\tret = ptr_ring_resize_multiple(rings, n,\n\t\t\t\t       dev->tx_queue_len, GFP_KERNEL,\n\t\t\t\t       tun_ptr_free);\n\n\tkfree(rings);\n\treturn ret;\n}\n\nstatic int tun_device_event(struct notifier_block *unused,\n\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tint i;\n\n\tif (dev->rtnl_link_ops != &tun_link_ops)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGE_TX_QUEUE_LEN:\n\t\tif (tun_queue_resize(tun))\n\t\t\treturn NOTIFY_BAD;\n\t\tbreak;\n\tcase NETDEV_UP:\n\t\tfor (i = 0; i < tun->numqueues; i++) {\n\t\t\tstruct tun_file *tfile;\n\n\t\t\ttfile = rtnl_dereference(tun->tfiles[i]);\n\t\t\ttfile->socket.sk->sk_write_space(tfile->socket.sk);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block tun_notifier_block __read_mostly = {\n\t.notifier_call\t= tun_device_event,\n};\n\nstatic int __init tun_init(void)\n{\n\tint ret = 0;\n\n\tpr_info(\"%s, %s\\n\", DRV_DESCRIPTION, DRV_VERSION);\n\n\tret = rtnl_link_register(&tun_link_ops);\n\tif (ret) {\n\t\tpr_err(\"Can't register link_ops\\n\");\n\t\tgoto err_linkops;\n\t}\n\n\tret = misc_register(&tun_miscdev);\n\tif (ret) {\n\t\tpr_err(\"Can't register misc device %d\\n\", TUN_MINOR);\n\t\tgoto err_misc;\n\t}\n\n\tret = register_netdevice_notifier(&tun_notifier_block);\n\tif (ret) {\n\t\tpr_err(\"Can't register netdevice notifier\\n\");\n\t\tgoto err_notifier;\n\t}\n\n\treturn  0;\n\nerr_notifier:\n\tmisc_deregister(&tun_miscdev);\nerr_misc:\n\trtnl_link_unregister(&tun_link_ops);\nerr_linkops:\n\treturn ret;\n}\n\nstatic void __exit tun_cleanup(void)\n{\n\tmisc_deregister(&tun_miscdev);\n\trtnl_link_unregister(&tun_link_ops);\n\tunregister_netdevice_notifier(&tun_notifier_block);\n}\n\n \nstruct socket *tun_get_socket(struct file *file)\n{\n\tstruct tun_file *tfile;\n\tif (file->f_op != &tun_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\ttfile = file->private_data;\n\tif (!tfile)\n\t\treturn ERR_PTR(-EBADFD);\n\treturn &tfile->socket;\n}\nEXPORT_SYMBOL_GPL(tun_get_socket);\n\nstruct ptr_ring *tun_get_tx_ring(struct file *file)\n{\n\tstruct tun_file *tfile;\n\n\tif (file->f_op != &tun_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\ttfile = file->private_data;\n\tif (!tfile)\n\t\treturn ERR_PTR(-EBADFD);\n\treturn &tfile->tx_ring;\n}\nEXPORT_SYMBOL_GPL(tun_get_tx_ring);\n\nmodule_init(tun_init);\nmodule_exit(tun_cleanup);\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_AUTHOR(DRV_COPYRIGHT);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_MISCDEV(TUN_MINOR);\nMODULE_ALIAS(\"devname:net/tun\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}