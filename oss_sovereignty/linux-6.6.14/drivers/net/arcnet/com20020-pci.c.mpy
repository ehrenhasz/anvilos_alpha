{
  "module_name": "com20020-pci.c",
  "hash_id": "362e0807980f225d6a424eeeecd374d974502ddd2ee2c22611ac0426f0038508",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/arcnet/com20020-pci.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"arcnet:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/leds.h>\n\n#include \"arcdevice.h\"\n#include \"com20020.h\"\n\n \n\nstatic int node;\nstatic char device[9];\t\t \nstatic int timeout = 3;\nstatic int backplane;\nstatic int clockp;\nstatic int clockm;\n\nmodule_param(node, int, 0);\nmodule_param_string(device, device, sizeof(device), 0);\nmodule_param(timeout, int, 0);\nmodule_param(backplane, int, 0);\nmodule_param(clockp, int, 0);\nmodule_param(clockm, int, 0);\nMODULE_LICENSE(\"GPL\");\n\nstatic void led_tx_set(struct led_classdev *led_cdev,\n\t\t\t     enum led_brightness value)\n{\n\tstruct com20020_dev *card;\n\tstruct com20020_priv *priv;\n\tstruct com20020_pci_card_info *ci;\n\n\tcard = container_of(led_cdev, struct com20020_dev, tx_led);\n\n\tpriv = card->pci_priv;\n\tci = priv->ci;\n\n\toutb(!!value, priv->misc + ci->leds[card->index].green);\n}\n\nstatic void led_recon_set(struct led_classdev *led_cdev,\n\t\t\t     enum led_brightness value)\n{\n\tstruct com20020_dev *card;\n\tstruct com20020_priv *priv;\n\tstruct com20020_pci_card_info *ci;\n\n\tcard = container_of(led_cdev, struct com20020_dev, recon_led);\n\n\tpriv = card->pci_priv;\n\tci = priv->ci;\n\n\toutb(!!value, priv->misc + ci->leds[card->index].red);\n}\n\nstatic ssize_t backplane_mode_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct net_device *net_dev = to_net_dev(dev);\n\tstruct arcnet_local *lp = netdev_priv(net_dev);\n\n\treturn sprintf(buf, \"%s\\n\", lp->backplane ? \"true\" : \"false\");\n}\nstatic DEVICE_ATTR_RO(backplane_mode);\n\nstatic struct attribute *com20020_state_attrs[] = {\n\t&dev_attr_backplane_mode.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group com20020_state_group = {\n\t.name = NULL,\n\t.attrs = com20020_state_attrs,\n};\n\nstatic void com20020pci_remove(struct pci_dev *pdev);\n\nstatic int com20020pci_probe(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tstruct com20020_pci_card_info *ci;\n\tstruct com20020_pci_channel_map *mm;\n\tstruct net_device *dev;\n\tstruct arcnet_local *lp;\n\tstruct com20020_priv *priv;\n\tint i, ioaddr, ret;\n\tstruct resource *r;\n\n\tret = 0;\n\n\tif (pci_enable_device(pdev))\n\t\treturn -EIO;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct com20020_priv),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tci = (struct com20020_pci_card_info *)id->driver_data;\n\tif (!ci)\n\t\treturn -EINVAL;\n\n\tpriv->ci = ci;\n\tmm = &ci->misc_map;\n\n\tpci_set_drvdata(pdev, priv);\n\n\tINIT_LIST_HEAD(&priv->list_dev);\n\n\tif (mm->size) {\n\t\tioaddr = pci_resource_start(pdev, mm->bar) + mm->offset;\n\t\tr = devm_request_region(&pdev->dev, ioaddr, mm->size,\n\t\t\t\t\t\"com20020-pci\");\n\t\tif (!r) {\n\t\t\tpr_err(\"IO region %xh-%xh already allocated.\\n\",\n\t\t\t       ioaddr, ioaddr + mm->size - 1);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tpriv->misc = ioaddr;\n\t}\n\n\tfor (i = 0; i < ci->devcount; i++) {\n\t\tstruct com20020_pci_channel_map *cm = &ci->chan_map_tbl[i];\n\t\tstruct com20020_dev *card;\n\t\tint dev_id_mask = 0xf;\n\n\t\tdev = alloc_arcdev(device);\n\t\tif (!dev) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tdev->dev_port = i;\n\n\t\tdev->netdev_ops = &com20020_netdev_ops;\n\n\t\tlp = netdev_priv(dev);\n\n\t\tarc_printk(D_NORMAL, dev, \"%s Controls\\n\", ci->name);\n\t\tioaddr = pci_resource_start(pdev, cm->bar) + cm->offset;\n\n\t\tr = devm_request_region(&pdev->dev, ioaddr, cm->size,\n\t\t\t\t\t\"com20020-pci\");\n\t\tif (!r) {\n\t\t\tpr_err(\"IO region %xh-%xh already allocated\\n\",\n\t\t\t       ioaddr, ioaddr + cm->size - 1);\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_free_arcdev;\n\t\t}\n\n\t\t \n\t\tarcnet_outb(0x00, ioaddr, COM20020_REG_W_COMMAND);\n\t\tarcnet_inb(ioaddr, COM20020_REG_R_DIAGSTAT);\n\n\t\tSET_NETDEV_DEV(dev, &pdev->dev);\n\t\tdev->base_addr = ioaddr;\n\t\tarcnet_set_addr(dev, node);\n\t\tdev->sysfs_groups[0] = &com20020_state_group;\n\t\tdev->irq = pdev->irq;\n\t\tlp->card_name = \"PCI COM20020\";\n\t\tlp->card_flags = ci->flags;\n\t\tlp->backplane = backplane;\n\t\tlp->clockp = clockp & 7;\n\t\tlp->clockm = clockm & 3;\n\t\tlp->timeout = timeout;\n\t\tlp->hw.owner = THIS_MODULE;\n\n\t\tlp->backplane = (inb(priv->misc) >> (2 + i)) & 0x1;\n\n\t\tif (!strncmp(ci->name, \"EAE PLX-PCI FB2\", 15))\n\t\t\tlp->backplane = 1;\n\n\t\tif (ci->flags & ARC_HAS_ROTARY) {\n\t\t\t \n\t\t\tif (!strncmp(ci->name, \"EAE PLX-PCI MA1\", 15))\n\t\t\t\tdev_id_mask = 0x3;\n\t\t\tdev->dev_id = (inb(priv->misc + ci->rotary) >> 4) & dev_id_mask;\n\t\t\tsnprintf(dev->name, sizeof(dev->name), \"arc%d-%d\", dev->dev_id, i);\n\t\t}\n\n\t\tif (arcnet_inb(ioaddr, COM20020_REG_R_STATUS) == 0xFF) {\n\t\t\tpr_err(\"IO address %Xh is empty!\\n\", ioaddr);\n\t\t\tret = -EIO;\n\t\t\tgoto err_free_arcdev;\n\t\t}\n\t\tif (com20020_check(dev)) {\n\t\t\tret = -EIO;\n\t\t\tgoto err_free_arcdev;\n\t\t}\n\n\t\tret = com20020_found(dev, IRQF_SHARED);\n\t\tif (ret)\n\t\t\tgoto err_free_arcdev;\n\n\t\tcard = devm_kzalloc(&pdev->dev, sizeof(struct com20020_dev),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!card) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_arcdev;\n\t\t}\n\n\t\tcard->index = i;\n\t\tcard->pci_priv = priv;\n\n\t\tif (ci->flags & ARC_HAS_LED) {\n\t\t\tcard->tx_led.brightness_set = led_tx_set;\n\t\t\tcard->tx_led.default_trigger = devm_kasprintf(&pdev->dev,\n\t\t\t\t\t\t\tGFP_KERNEL, \"arc%d-%d-tx\",\n\t\t\t\t\t\t\tdev->dev_id, i);\n\t\t\tcard->tx_led.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t\t\"pci:green:tx:%d-%d\",\n\t\t\t\t\t\t\tdev->dev_id, i);\n\n\t\t\tcard->tx_led.dev = &dev->dev;\n\t\t\tcard->recon_led.brightness_set = led_recon_set;\n\t\t\tcard->recon_led.default_trigger = devm_kasprintf(&pdev->dev,\n\t\t\t\t\t\t\tGFP_KERNEL, \"arc%d-%d-recon\",\n\t\t\t\t\t\t\tdev->dev_id, i);\n\t\t\tcard->recon_led.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t\t\"pci:red:recon:%d-%d\",\n\t\t\t\t\t\t\tdev->dev_id, i);\n\t\t\tcard->recon_led.dev = &dev->dev;\n\n\t\t\tret = devm_led_classdev_register(&pdev->dev, &card->tx_led);\n\t\t\tif (ret)\n\t\t\t\tgoto err_free_arcdev;\n\n\t\t\tret = devm_led_classdev_register(&pdev->dev, &card->recon_led);\n\t\t\tif (ret)\n\t\t\t\tgoto err_free_arcdev;\n\n\t\t\tdev_set_drvdata(&dev->dev, card);\n\t\t\tdevm_arcnet_led_init(dev, dev->dev_id, i);\n\t\t}\n\n\t\tcard->dev = dev;\n\t\tlist_add(&card->list, &priv->list_dev);\n\t\tcontinue;\n\nerr_free_arcdev:\n\t\tfree_arcdev(dev);\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tcom20020pci_remove(pdev);\n\treturn ret;\n}\n\nstatic void com20020pci_remove(struct pci_dev *pdev)\n{\n\tstruct com20020_dev *card, *tmpcard;\n\tstruct com20020_priv *priv;\n\n\tpriv = pci_get_drvdata(pdev);\n\n\tlist_for_each_entry_safe(card, tmpcard, &priv->list_dev, list) {\n\t\tstruct net_device *dev = card->dev;\n\n\t\tunregister_netdev(dev);\n\t\tfree_irq(dev->irq, dev);\n\t\tfree_arcdev(dev);\n\t}\n}\n\nstatic struct com20020_pci_card_info card_info_10mbit = {\n\t.name = \"ARC-PCI\",\n\t.devcount = 1,\n\t.chan_map_tbl = {\n\t\t{\n\t\t\t.bar = 2,\n\t\t\t.offset = 0x00,\n\t\t\t.size = 0x08,\n\t\t},\n\t},\n\t.flags = ARC_CAN_10MBIT,\n};\n\nstatic struct com20020_pci_card_info card_info_5mbit = {\n\t.name = \"ARC-PCI\",\n\t.devcount = 1,\n\t.chan_map_tbl = {\n\t\t{\n\t\t\t.bar = 2,\n\t\t\t.offset = 0x00,\n\t\t\t.size = 0x08,\n\t\t},\n\t},\n\t.flags = ARC_IS_5MBIT,\n};\n\nstatic struct com20020_pci_card_info card_info_sohard = {\n\t.name = \"SOHARD SH ARC-PCI\",\n\t.devcount = 1,\n\t \n\t.chan_map_tbl = {\n\t\t{\n\t\t\t.bar = 4,\n\t\t\t.offset = 0x00,\n\t\t\t.size = 0x08\n\t\t},\n\t},\n\t.flags = ARC_CAN_10MBIT,\n};\n\nstatic struct com20020_pci_card_info card_info_eae_arc1 = {\n\t.name = \"EAE PLX-PCI ARC1\",\n\t.devcount = 1,\n\t.chan_map_tbl = {\n\t\t{\n\t\t\t.bar = 2,\n\t\t\t.offset = 0x00,\n\t\t\t.size = 0x08,\n\t\t},\n\t},\n\t.misc_map = {\n\t\t.bar = 2,\n\t\t.offset = 0x10,\n\t\t.size = 0x04,\n\t},\n\t.leds = {\n\t\t{\n\t\t\t.green = 0x0,\n\t\t\t.red = 0x1,\n\t\t},\n\t},\n\t.rotary = 0x0,\n\t.flags = ARC_HAS_ROTARY | ARC_HAS_LED | ARC_CAN_10MBIT,\n};\n\nstatic struct com20020_pci_card_info card_info_eae_ma1 = {\n\t.name = \"EAE PLX-PCI MA1\",\n\t.devcount = 2,\n\t.chan_map_tbl = {\n\t\t{\n\t\t\t.bar = 2,\n\t\t\t.offset = 0x00,\n\t\t\t.size = 0x08,\n\t\t}, {\n\t\t\t.bar = 2,\n\t\t\t.offset = 0x08,\n\t\t\t.size = 0x08,\n\t\t}\n\t},\n\t.misc_map = {\n\t\t.bar = 2,\n\t\t.offset = 0x10,\n\t\t.size = 0x04,\n\t},\n\t.leds = {\n\t\t{\n\t\t\t.green = 0x0,\n\t\t\t.red = 0x1,\n\t\t}, {\n\t\t\t.green = 0x2,\n\t\t\t.red = 0x3,\n\t\t},\n\t},\n\t.rotary = 0x0,\n\t.flags = ARC_HAS_ROTARY | ARC_HAS_LED | ARC_CAN_10MBIT,\n};\n\nstatic struct com20020_pci_card_info card_info_eae_fb2 = {\n\t.name = \"EAE PLX-PCI FB2\",\n\t.devcount = 1,\n\t.chan_map_tbl = {\n\t\t{\n\t\t\t.bar = 2,\n\t\t\t.offset = 0x00,\n\t\t\t.size = 0x08,\n\t\t},\n\t},\n\t.misc_map = {\n\t\t.bar = 2,\n\t\t.offset = 0x10,\n\t\t.size = 0x04,\n\t},\n\t.leds = {\n\t\t{\n\t\t\t.green = 0x0,\n\t\t\t.red = 0x1,\n\t\t},\n\t},\n\t.rotary = 0x0,\n\t.flags = ARC_HAS_ROTARY | ARC_HAS_LED | ARC_CAN_10MBIT,\n};\n\nstatic const struct pci_device_id com20020pci_id_table[] = {\n\t{\n\t\t0x1571, 0xa001,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t0,\n\t},\n\t{\n\t\t0x1571, 0xa002,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t0,\n\t},\n\t{\n\t\t0x1571, 0xa003,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t0\n\t},\n\t{\n\t\t0x1571, 0xa004,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t0,\n\t},\n\t{\n\t\t0x1571, 0xa005,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t0\n\t},\n\t{\n\t\t0x1571, 0xa006,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t0\n\t},\n\t{\n\t\t0x1571, 0xa007,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t0\n\t},\n\t{\n\t\t0x1571, 0xa008,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t0\n\t},\n\t{\n\t\t0x1571, 0xa009,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_5mbit\n\t},\n\t{\n\t\t0x1571, 0xa00a,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_5mbit\n\t},\n\t{\n\t\t0x1571, 0xa00b,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_5mbit\n\t},\n\t{\n\t\t0x1571, 0xa00c,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_5mbit\n\t},\n\t{\n\t\t0x1571, 0xa00d,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_5mbit\n\t},\n\t{\n\t\t0x1571, 0xa00e,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_5mbit\n\t},\n\t{\n\t\t0x1571, 0xa201,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_10mbit\n\t},\n\t{\n\t\t0x1571, 0xa202,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_10mbit\n\t},\n\t{\n\t\t0x1571, 0xa203,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_10mbit\n\t},\n\t{\n\t\t0x1571, 0xa204,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_10mbit\n\t},\n\t{\n\t\t0x1571, 0xa205,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_10mbit\n\t},\n\t{\n\t\t0x1571, 0xa206,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_10mbit\n\t},\n\t{\n\t\t0x10B5, 0x9030,\n\t\t0x10B5, 0x2978,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_sohard\n\t},\n\t{\n\t\t0x10B5, 0x9050,\n\t\t0x10B5, 0x2273,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_sohard\n\t},\n\t{\n\t\t0x10B5, 0x9050,\n\t\t0x10B5, 0x3263,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_eae_arc1\n\t},\n\t{\n\t\t0x10B5, 0x9050,\n\t\t0x10B5, 0x3292,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_eae_ma1\n\t},\n\t{\n\t\t0x10B5, 0x9050,\n\t\t0x10B5, 0x3294,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_eae_fb2\n\t},\n\t{\n\t\t0x14BA, 0x6000,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_10mbit\n\t},\n\t{\n\t\t0x10B5, 0x2200,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&card_info_10mbit\n\t},\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, com20020pci_id_table);\n\nstatic struct pci_driver com20020pci_driver = {\n\t.name\t\t= \"com20020\",\n\t.id_table\t= com20020pci_id_table,\n\t.probe\t\t= com20020pci_probe,\n\t.remove\t\t= com20020pci_remove,\n};\n\nstatic int __init com20020pci_init(void)\n{\n\tif (BUGLVL(D_NORMAL))\n\t\tpr_info(\"%s\\n\", \"COM20020 PCI support\");\n\treturn pci_register_driver(&com20020pci_driver);\n}\n\nstatic void __exit com20020pci_cleanup(void)\n{\n\tpci_unregister_driver(&com20020pci_driver);\n}\n\nmodule_init(com20020pci_init)\nmodule_exit(com20020pci_cleanup)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}