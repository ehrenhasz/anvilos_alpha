{
  "module_name": "com20020-isa.c",
  "hash_id": "1e6f4540c3541f8bac8f56326e87d82b159dc2b895f8efcb7178b6c67572b484",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/arcnet/com20020-isa.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"arcnet:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/memblock.h>\n#include <linux/io.h>\n\n#include \"arcdevice.h\"\n#include \"com20020.h\"\n\n \nstatic int __init com20020isa_probe(struct net_device *dev)\n{\n\tint ioaddr;\n\tunsigned long airqmask;\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tint err;\n\n\tif (BUGLVL(D_NORMAL))\n\t\tpr_info(\"%s\\n\", \"COM20020 ISA support (by David Woodhouse et al.)\");\n\n\tioaddr = dev->base_addr;\n\tif (!ioaddr) {\n\t\tarc_printk(D_NORMAL, dev, \"No autoprobe (yet) for IO mapped cards; you must specify the base address!\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!request_region(ioaddr, ARCNET_TOTAL_SIZE, \"arcnet (COM20020)\")) {\n\t\tarc_printk(D_NORMAL, dev, \"IO region %xh-%xh already allocated.\\n\",\n\t\t\t   ioaddr, ioaddr + ARCNET_TOTAL_SIZE - 1);\n\t\treturn -ENXIO;\n\t}\n\tif (arcnet_inb(ioaddr, COM20020_REG_R_STATUS) == 0xFF) {\n\t\tarc_printk(D_NORMAL, dev, \"IO address %x empty\\n\", ioaddr);\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (com20020_check(dev)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!dev->irq) {\n\t\t \n\t\tarc_printk(D_INIT_REASONS, dev, \"intmask was %02Xh\\n\",\n\t\t\t   arcnet_inb(ioaddr, COM20020_REG_R_STATUS));\n\t\tarcnet_outb(0, ioaddr, COM20020_REG_W_INTMASK);\n\t\tairqmask = probe_irq_on();\n\t\tarcnet_outb(NORXflag, ioaddr, COM20020_REG_W_INTMASK);\n\t\tudelay(1);\n\t\tarcnet_outb(0, ioaddr, COM20020_REG_W_INTMASK);\n\t\tdev->irq = probe_irq_off(airqmask);\n\n\t\tif ((int)dev->irq <= 0) {\n\t\t\tarc_printk(D_INIT_REASONS, dev, \"Autoprobe IRQ failed first time\\n\");\n\t\t\tairqmask = probe_irq_on();\n\t\t\tarcnet_outb(NORXflag, ioaddr, COM20020_REG_W_INTMASK);\n\t\t\tudelay(5);\n\t\t\tarcnet_outb(0, ioaddr, COM20020_REG_W_INTMASK);\n\t\t\tdev->irq = probe_irq_off(airqmask);\n\t\t\tif ((int)dev->irq <= 0) {\n\t\t\t\tarc_printk(D_NORMAL, dev, \"Autoprobe IRQ failed.\\n\");\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tlp->card_name = \"ISA COM20020\";\n\n\terr = com20020_found(dev, 0);\n\tif (err != 0)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\trelease_region(ioaddr, ARCNET_TOTAL_SIZE);\n\treturn err;\n}\n\nstatic int node = 0;\nstatic int io = 0x0;\t\t \nstatic int irq = 0;\t\t \nstatic char device[9];\t\t \nstatic int timeout = 3;\nstatic int backplane = 0;\nstatic int clockp = 0;\nstatic int clockm = 0;\n\nmodule_param(node, int, 0);\nmodule_param_hw(io, int, ioport, 0);\nmodule_param_hw(irq, int, irq, 0);\nmodule_param_string(device, device, sizeof(device), 0);\nmodule_param(timeout, int, 0);\nmodule_param(backplane, int, 0);\nmodule_param(clockp, int, 0);\nmodule_param(clockm, int, 0);\n\nMODULE_LICENSE(\"GPL\");\n\nstatic struct net_device *my_dev;\n\nstatic int __init com20020_init(void)\n{\n\tstruct net_device *dev;\n\tstruct arcnet_local *lp;\n\n\tdev = alloc_arcdev(device);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tif (node && node != 0xff)\n\t\tarcnet_set_addr(dev, node);\n\n\tdev->netdev_ops = &com20020_netdev_ops;\n\n\tlp = netdev_priv(dev);\n\tlp->backplane = backplane;\n\tlp->clockp = clockp & 7;\n\tlp->clockm = clockm & 3;\n\tlp->timeout = timeout & 3;\n\tlp->hw.owner = THIS_MODULE;\n\n\tdev->base_addr = io;\n\tdev->irq = irq;\n\n\tif (dev->irq == 2)\n\t\tdev->irq = 9;\n\n\tif (com20020isa_probe(dev)) {\n\t\tfree_arcdev(dev);\n\t\treturn -EIO;\n\t}\n\n\tmy_dev = dev;\n\treturn 0;\n}\n\nstatic void __exit com20020_exit(void)\n{\n\tunregister_netdev(my_dev);\n\tfree_irq(my_dev->irq, my_dev);\n\trelease_region(my_dev->base_addr, ARCNET_TOTAL_SIZE);\n\tfree_arcdev(my_dev);\n}\n\n#ifndef MODULE\nstatic int __init com20020isa_setup(char *s)\n{\n\tint ints[8];\n\n\ts = get_options(s, 8, ints);\n\tif (!ints[0])\n\t\treturn 1;\n\n\tswitch (ints[0]) {\n\tdefault:\t\t \n\t\tpr_info(\"Too many arguments\\n\");\n\t\tfallthrough;\n\tcase 6:\t\t \n\t\ttimeout = ints[6];\n\t\tfallthrough;\n\tcase 5:\t\t \n\t\tclockp = ints[5];\n\t\tfallthrough;\n\tcase 4:\t\t \n\t\tbackplane = ints[4];\n\t\tfallthrough;\n\tcase 3:\t\t \n\t\tnode = ints[3];\n\t\tfallthrough;\n\tcase 2:\t\t \n\t\tirq = ints[2];\n\t\tfallthrough;\n\tcase 1:\t\t \n\t\tio = ints[1];\n\t}\n\tif (*s)\n\t\tsnprintf(device, sizeof(device), \"%s\", s);\n\treturn 1;\n}\n\n__setup(\"com20020=\", com20020isa_setup);\n\n#endif\t\t\t\t \n\nmodule_init(com20020_init)\nmodule_exit(com20020_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}