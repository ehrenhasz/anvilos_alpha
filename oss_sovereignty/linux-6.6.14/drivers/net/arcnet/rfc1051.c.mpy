{
  "module_name": "rfc1051.c",
  "hash_id": "0afbfe06972b234524bc35672bceb06da2450413dfbc97c592818019b39ea5d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/arcnet/rfc1051.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"arcnet:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/if_arp.h>\n#include <net/arp.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n\n#include \"arcdevice.h\"\n\nstatic __be16 type_trans(struct sk_buff *skb, struct net_device *dev);\nstatic void rx(struct net_device *dev, int bufnum,\n\t       struct archdr *pkthdr, int length);\nstatic int build_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\tunsigned short type, uint8_t daddr);\nstatic int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,\n\t\t      int bufnum);\n\nstatic struct ArcProto rfc1051_proto = {\n\t.suffix\t\t= 's',\n\t.mtu\t\t= XMTU - RFC1051_HDR_SIZE,\n\t.is_ip          = 1,\n\t.rx\t\t= rx,\n\t.build_header\t= build_header,\n\t.prepare_tx\t= prepare_tx,\n\t.continue_tx    = NULL,\n\t.ack_tx         = NULL\n};\n\nstatic int __init arcnet_rfc1051_init(void)\n{\n\tpr_info(\"%s\\n\", \"RFC1051 \\\"simple standard\\\" (`s') encapsulation support loaded\");\n\n\tarc_proto_map[ARC_P_IP_RFC1051]\n\t    = arc_proto_map[ARC_P_ARP_RFC1051]\n\t    = &rfc1051_proto;\n\n\t \n\tif (arc_bcast_proto == arc_proto_default)\n\t\tarc_bcast_proto = &rfc1051_proto;\n\n\treturn 0;\n}\n\nstatic void __exit arcnet_rfc1051_exit(void)\n{\n\tarcnet_unregister_proto(&rfc1051_proto);\n}\n\nmodule_init(arcnet_rfc1051_init);\nmodule_exit(arcnet_rfc1051_exit);\n\nMODULE_LICENSE(\"GPL\");\n\n \nstatic __be16 type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct archdr *pkt = (struct archdr *)skb->data;\n\tstruct arc_rfc1051 *soft = &pkt->soft.rfc1051;\n\tint hdr_size = ARC_HDR_SIZE + RFC1051_HDR_SIZE;\n\n\t \n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, hdr_size);\n\n\tif (pkt->hard.dest == 0) {\n\t\tskb->pkt_type = PACKET_BROADCAST;\n\t} else if (dev->flags & IFF_PROMISC) {\n\t\t \n\t\tif (pkt->hard.dest != dev->dev_addr[0])\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t}\n\t \n\tswitch (soft->proto) {\n\tcase ARC_P_IP_RFC1051:\n\t\treturn htons(ETH_P_IP);\n\tcase ARC_P_ARP_RFC1051:\n\t\treturn htons(ETH_P_ARP);\n\n\tdefault:\n\t\tdev->stats.rx_errors++;\n\t\tdev->stats.rx_crc_errors++;\n\t\treturn 0;\n\t}\n\n\treturn htons(ETH_P_IP);\n}\n\n \nstatic void rx(struct net_device *dev, int bufnum,\n\t       struct archdr *pkthdr, int length)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tstruct archdr *pkt = pkthdr;\n\tint ofs;\n\n\tarc_printk(D_DURING, dev, \"it's a raw packet (length=%d)\\n\", length);\n\n\tif (length >= MinTU)\n\t\tofs = 512 - length;\n\telse\n\t\tofs = 256 - length;\n\n\tskb = alloc_skb(length + ARC_HDR_SIZE, GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\tskb_put(skb, length + ARC_HDR_SIZE);\n\tskb->dev = dev;\n\n\tpkt = (struct archdr *)skb->data;\n\n\t \n\tmemcpy(pkt, pkthdr, sizeof(struct archdr));\n\tif (length > sizeof(pkt->soft))\n\t\tlp->hw.copy_from_card(dev, bufnum, ofs + sizeof(pkt->soft),\n\t\t\t\t      pkt->soft.raw + sizeof(pkt->soft),\n\t\t\t\t      length - sizeof(pkt->soft));\n\n\tif (BUGLVL(D_SKB))\n\t\tarcnet_dump_skb(dev, skb, \"rx\");\n\n\tskb->protocol = type_trans(skb, dev);\n\tnetif_rx(skb);\n}\n\n \nstatic int build_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\tunsigned short type, uint8_t daddr)\n{\n\tint hdr_size = ARC_HDR_SIZE + RFC1051_HDR_SIZE;\n\tstruct archdr *pkt = skb_push(skb, hdr_size);\n\tstruct arc_rfc1051 *soft = &pkt->soft.rfc1051;\n\n\t \n\tswitch (type) {\n\tcase ETH_P_IP:\n\t\tsoft->proto = ARC_P_IP_RFC1051;\n\t\tbreak;\n\tcase ETH_P_ARP:\n\t\tsoft->proto = ARC_P_ARP_RFC1051;\n\t\tbreak;\n\tdefault:\n\t\tarc_printk(D_NORMAL, dev, \"RFC1051: I don't understand protocol %d (%Xh)\\n\",\n\t\t\t   type, type);\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_aborted_errors++;\n\t\treturn 0;\n\t}\n\n\t \n\tpkt->hard.source = *dev->dev_addr;\n\n\t \n\n\tif (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {\n\t\t \n\t\tpkt->hard.dest = 0;\n\t\treturn hdr_size;\n\t}\n\t \n\tpkt->hard.dest = daddr;\n\n\treturn hdr_size;\t \n}\n\nstatic int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,\n\t\t      int bufnum)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct arc_hardware *hard = &pkt->hard;\n\tint ofs;\n\n\tarc_printk(D_DURING, dev, \"prepare_tx: txbufs=%d/%d/%d\\n\",\n\t\t   lp->next_tx, lp->cur_tx, bufnum);\n\n\t \n\tlength -= ARC_HDR_SIZE;\n\n\tif (length > XMTU) {\n\t\t \n\t\tarc_printk(D_NORMAL, dev, \"Bug!  prepare_tx with size %d (> %d)\\n\",\n\t\t\t   length, XMTU);\n\t\tlength = XMTU;\n\t}\n\tif (length > MinTU) {\n\t\thard->offset[0] = 0;\n\t\thard->offset[1] = ofs = 512 - length;\n\t} else if (length > MTU) {\n\t\thard->offset[0] = 0;\n\t\thard->offset[1] = ofs = 512 - length - 3;\n\t} else {\n\t\thard->offset[0] = ofs = 256 - length;\n\t}\n\n\tlp->hw.copy_to_card(dev, bufnum, 0, hard, ARC_HDR_SIZE);\n\tlp->hw.copy_to_card(dev, bufnum, ofs, &pkt->soft, length);\n\n\tlp->lastload_dest = hard->dest;\n\n\treturn 1;\t\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}