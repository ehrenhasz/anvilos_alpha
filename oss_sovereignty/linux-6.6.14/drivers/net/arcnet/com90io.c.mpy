{
  "module_name": "com90io.c",
  "hash_id": "dfdab1b04d2896d44b8cf1ee9d89e1e718a6915e97bcc08f062e65a2bf15f2eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/arcnet/com90io.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"arcnet:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n\n#include \"arcdevice.h\"\n#include \"com9026.h\"\n\n \n\nstatic int com90io_found(struct net_device *dev);\nstatic void com90io_command(struct net_device *dev, int command);\nstatic int com90io_status(struct net_device *dev);\nstatic void com90io_setmask(struct net_device *dev, int mask);\nstatic int com90io_reset(struct net_device *dev, int really_reset);\nstatic void com90io_copy_to_card(struct net_device *dev, int bufnum, int offset,\n\t\t\t\t void *buf, int count);\nstatic void com90io_copy_from_card(struct net_device *dev, int bufnum,\n\t\t\t\t   int offset, void *buf, int count);\n\n \n\n \n#define ARCNET_TOTAL_SIZE 16\n\n \n\n#undef ONE_AT_A_TIME_TX\n#undef ONE_AT_A_TIME_RX\n\nstatic u_char get_buffer_byte(struct net_device *dev, unsigned offset)\n{\n\tint ioaddr = dev->base_addr;\n\n\tarcnet_outb(offset >> 8, ioaddr, COM9026_REG_W_ADDR_HI);\n\tarcnet_outb(offset & 0xff, ioaddr, COM9026_REG_W_ADDR_LO);\n\n\treturn arcnet_inb(ioaddr, COM9026_REG_RW_MEMDATA);\n}\n\n#ifdef ONE_AT_A_TIME_TX\nstatic void put_buffer_byte(struct net_device *dev, unsigned offset,\n\t\t\t    u_char datum)\n{\n\tint ioaddr = dev->base_addr;\n\n\tarcnet_outb(offset >> 8, ioaddr, COM9026_REG_W_ADDR_HI);\n\tarcnet_outb(offset & 0xff, ioaddr, COM9026_REG_W_ADDR_LO);\n\n\tarcnet_outb(datum, ioaddr, COM9026_REG_RW_MEMDATA);\n}\n\n#endif\n\nstatic void get_whole_buffer(struct net_device *dev, unsigned offset,\n\t\t\t     unsigned length, char *dest)\n{\n\tint ioaddr = dev->base_addr;\n\n\tarcnet_outb((offset >> 8) | AUTOINCflag, ioaddr, COM9026_REG_W_ADDR_HI);\n\tarcnet_outb(offset & 0xff, ioaddr, COM9026_REG_W_ADDR_LO);\n\n\twhile (length--)\n#ifdef ONE_AT_A_TIME_RX\n\t\t*(dest++) = get_buffer_byte(dev, offset++);\n#else\n\t\t*(dest++) = arcnet_inb(ioaddr, COM9026_REG_RW_MEMDATA);\n#endif\n}\n\nstatic void put_whole_buffer(struct net_device *dev, unsigned offset,\n\t\t\t     unsigned length, char *dest)\n{\n\tint ioaddr = dev->base_addr;\n\n\tarcnet_outb((offset >> 8) | AUTOINCflag, ioaddr, COM9026_REG_W_ADDR_HI);\n\tarcnet_outb(offset & 0xff, ioaddr,COM9026_REG_W_ADDR_LO);\n\n\twhile (length--)\n#ifdef ONE_AT_A_TIME_TX\n\t\tput_buffer_byte(dev, offset++, *(dest++));\n#else\n\t\tarcnet_outb(*(dest++), ioaddr, COM9026_REG_RW_MEMDATA);\n#endif\n}\n\n \nstatic int __init com90io_probe(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr, status;\n\tunsigned long airqmask;\n\n\tif (BUGLVL(D_NORMAL)) {\n\t\tpr_info(\"%s\\n\", \"COM90xx IO-mapped mode support (by David Woodhouse et el.)\");\n\t\tpr_info(\"E-mail me if you actually test this driver, please!\\n\");\n\t}\n\n\tif (!ioaddr) {\n\t\tarc_printk(D_NORMAL, dev, \"No autoprobe for IO mapped cards; you must specify the base address!\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!request_region(ioaddr, ARCNET_TOTAL_SIZE, \"com90io probe\")) {\n\t\tarc_printk(D_INIT_REASONS, dev, \"IO request_region %x-%x failed\\n\",\n\t\t\t   ioaddr, ioaddr + ARCNET_TOTAL_SIZE - 1);\n\t\treturn -ENXIO;\n\t}\n\tif (arcnet_inb(ioaddr, COM9026_REG_R_STATUS) == 0xFF) {\n\t\tarc_printk(D_INIT_REASONS, dev, \"IO address %x empty\\n\",\n\t\t\t   ioaddr);\n\t\tgoto err_out;\n\t}\n\tarcnet_inb(ioaddr, COM9026_REG_R_RESET);\n\tmdelay(RESETtime);\n\n\tstatus = arcnet_inb(ioaddr, COM9026_REG_R_STATUS);\n\n\tif ((status & 0x9D) != (NORXflag | RECONflag | TXFREEflag | RESETflag)) {\n\t\tarc_printk(D_INIT_REASONS, dev, \"Status invalid (%Xh)\\n\",\n\t\t\t   status);\n\t\tgoto err_out;\n\t}\n\tarc_printk(D_INIT_REASONS, dev, \"Status after reset: %X\\n\", status);\n\n\tarcnet_outb(CFLAGScmd | RESETclear | CONFIGclear,\n\t\t    ioaddr, COM9026_REG_W_COMMAND);\n\n\tarc_printk(D_INIT_REASONS, dev, \"Status after reset acknowledged: %X\\n\",\n\t\t   status);\n\n\tstatus = arcnet_inb(ioaddr, COM9026_REG_R_STATUS);\n\n\tif (status & RESETflag) {\n\t\tarc_printk(D_INIT_REASONS, dev, \"Eternal reset (status=%Xh)\\n\",\n\t\t\t   status);\n\t\tgoto err_out;\n\t}\n\tarcnet_outb((0x16 | IOMAPflag) & ~ENABLE16flag,\n\t\t    ioaddr, COM9026_REG_RW_CONFIG);\n\n\t \n\n\tarcnet_outb(AUTOINCflag, ioaddr, COM9026_REG_W_ADDR_HI);\n\tarcnet_outb(0, ioaddr,  COM9026_REG_W_ADDR_LO);\n\n\tstatus = arcnet_inb(ioaddr, COM9026_REG_RW_MEMDATA);\n\tif (status != 0xd1) {\n\t\tarc_printk(D_INIT_REASONS, dev, \"Signature byte not found (%Xh instead).\\n\",\n\t\t\t   status);\n\t\tgoto err_out;\n\t}\n\tif (!dev->irq) {\n\t\t \n\n\t\tairqmask = probe_irq_on();\n\t\tarcnet_outb(NORXflag, ioaddr, COM9026_REG_W_INTMASK);\n\t\tudelay(1);\n\t\tarcnet_outb(0, ioaddr, COM9026_REG_W_INTMASK);\n\t\tdev->irq = probe_irq_off(airqmask);\n\n\t\tif ((int)dev->irq <= 0) {\n\t\t\tarc_printk(D_INIT_REASONS, dev, \"Autoprobe IRQ failed\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\trelease_region(ioaddr, ARCNET_TOTAL_SIZE);  \n\treturn com90io_found(dev);\n\nerr_out:\n\trelease_region(ioaddr, ARCNET_TOTAL_SIZE);\n\treturn -ENODEV;\n}\n\n \nstatic int __init com90io_found(struct net_device *dev)\n{\n\tstruct arcnet_local *lp;\n\tint ioaddr = dev->base_addr;\n\tint err;\n\n\t \n\tif (request_irq(dev->irq, arcnet_interrupt, 0,\n\t\t\t\"arcnet (COM90xx-IO)\", dev)) {\n\t\tarc_printk(D_NORMAL, dev, \"Can't get IRQ %d!\\n\", dev->irq);\n\t\treturn -ENODEV;\n\t}\n\t \n\tif (!request_region(dev->base_addr, ARCNET_TOTAL_SIZE,\n\t\t\t    \"arcnet (COM90xx-IO)\")) {\n\t\tfree_irq(dev->irq, dev);\n\t\treturn -EBUSY;\n\t}\n\n\tlp = netdev_priv(dev);\n\tlp->card_name = \"COM90xx I/O\";\n\tlp->hw.command = com90io_command;\n\tlp->hw.status = com90io_status;\n\tlp->hw.intmask = com90io_setmask;\n\tlp->hw.reset = com90io_reset;\n\tlp->hw.owner = THIS_MODULE;\n\tlp->hw.copy_to_card = com90io_copy_to_card;\n\tlp->hw.copy_from_card = com90io_copy_from_card;\n\n\tlp->config = (0x16 | IOMAPflag) & ~ENABLE16flag;\n\tarcnet_outb(lp->config, ioaddr, COM9026_REG_RW_CONFIG);\n\n\t \n\n\tarcnet_set_addr(dev, get_buffer_byte(dev, 1));\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tarcnet_outb(arcnet_inb(ioaddr, COM9026_REG_RW_CONFIG) & ~IOMAPflag,\n\t\t\t    ioaddr, COM9026_REG_RW_CONFIG);\n\t\tfree_irq(dev->irq, dev);\n\t\trelease_region(dev->base_addr, ARCNET_TOTAL_SIZE);\n\t\treturn err;\n\t}\n\n\tarc_printk(D_NORMAL, dev, \"COM90IO: station %02Xh found at %03lXh, IRQ %d.\\n\",\n\t\t   dev->dev_addr[0], dev->base_addr, dev->irq);\n\n\treturn 0;\n}\n\n \nstatic int com90io_reset(struct net_device *dev, int really_reset)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tshort ioaddr = dev->base_addr;\n\n\tarc_printk(D_INIT, dev, \"Resetting %s (status=%02Xh)\\n\",\n\t\t   dev->name, arcnet_inb(ioaddr, COM9026_REG_R_STATUS));\n\n\tif (really_reset) {\n\t\t \n\t\tarcnet_inb(ioaddr, COM9026_REG_R_RESET);\n\t\tmdelay(RESETtime);\n\t}\n\t \n\tlp->config = (0x1C | IOMAPflag) & ~ENABLE16flag;\n\tarcnet_outb(lp->config, ioaddr, COM9026_REG_RW_CONFIG);\n\n\tarcnet_outb(CFLAGScmd | RESETclear, ioaddr, COM9026_REG_W_COMMAND);\n\t\t\t\t\t \n\tarcnet_outb(CFLAGScmd | CONFIGclear, ioaddr, COM9026_REG_W_COMMAND);\n\n\t \n\tif (get_buffer_byte(dev, 0) != TESTvalue) {\n\t\tarc_printk(D_NORMAL, dev, \"reset failed: TESTvalue not present.\\n\");\n\t\treturn 1;\n\t}\n\t \n\tarcnet_outb(CONFIGcmd | EXTconf, ioaddr, COM9026_REG_W_COMMAND);\n\t \n\treturn 0;\n}\n\nstatic void com90io_command(struct net_device *dev, int cmd)\n{\n\tshort ioaddr = dev->base_addr;\n\n\tarcnet_outb(cmd, ioaddr, COM9026_REG_W_COMMAND);\n}\n\nstatic int com90io_status(struct net_device *dev)\n{\n\tshort ioaddr = dev->base_addr;\n\n\treturn arcnet_inb(ioaddr, COM9026_REG_R_STATUS);\n}\n\nstatic void com90io_setmask(struct net_device *dev, int mask)\n{\n\tshort ioaddr = dev->base_addr;\n\n\tarcnet_outb(mask, ioaddr, COM9026_REG_W_INTMASK);\n}\n\nstatic void com90io_copy_to_card(struct net_device *dev, int bufnum,\n\t\t\t\t int offset, void *buf, int count)\n{\n\tTIME(dev, \"put_whole_buffer\", count,\n\t     put_whole_buffer(dev, bufnum * 512 + offset, count, buf));\n}\n\nstatic void com90io_copy_from_card(struct net_device *dev, int bufnum,\n\t\t\t\t   int offset, void *buf, int count)\n{\n\tTIME(dev, \"get_whole_buffer\", count,\n\t     get_whole_buffer(dev, bufnum * 512 + offset, count, buf));\n}\n\nstatic int io;\t\t\t \nstatic int irq;\nstatic char device[9];\t\t \n\nmodule_param_hw(io, int, ioport, 0);\nmodule_param_hw(irq, int, irq, 0);\nmodule_param_string(device, device, sizeof(device), 0);\nMODULE_LICENSE(\"GPL\");\n\n#ifndef MODULE\nstatic int __init com90io_setup(char *s)\n{\n\tint ints[4];\n\n\ts = get_options(s, 4, ints);\n\tif (!ints[0])\n\t\treturn 0;\n\tswitch (ints[0]) {\n\tdefault:\t\t \n\t\tpr_err(\"Too many arguments\\n\");\n\t\tfallthrough;\n\tcase 2:\t\t \n\t\tirq = ints[2];\n\t\tfallthrough;\n\tcase 1:\t\t \n\t\tio = ints[1];\n\t}\n\tif (*s)\n\t\tsnprintf(device, sizeof(device), \"%s\", s);\n\treturn 1;\n}\n__setup(\"com90io=\", com90io_setup);\n#endif\n\nstatic struct net_device *my_dev;\n\nstatic int __init com90io_init(void)\n{\n\tstruct net_device *dev;\n\tint err;\n\n\tdev = alloc_arcdev(device);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->base_addr = io;\n\tdev->irq = irq;\n\tif (dev->irq == 2)\n\t\tdev->irq = 9;\n\n\terr = com90io_probe(dev);\n\n\tif (err) {\n\t\tfree_arcdev(dev);\n\t\treturn err;\n\t}\n\n\tmy_dev = dev;\n\treturn 0;\n}\n\nstatic void __exit com90io_exit(void)\n{\n\tstruct net_device *dev = my_dev;\n\tint ioaddr = dev->base_addr;\n\n\tunregister_netdev(dev);\n\n\t \n\tarcnet_outb(arcnet_inb(ioaddr, COM9026_REG_RW_CONFIG) & ~IOMAPflag,\n\t\t    ioaddr, COM9026_REG_RW_CONFIG);\n\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->base_addr, ARCNET_TOTAL_SIZE);\n\tfree_arcdev(dev);\n}\n\nmodule_init(com90io_init)\nmodule_exit(com90io_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}