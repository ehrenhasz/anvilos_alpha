{
  "module_name": "arcdevice.h",
  "hash_id": "4ec4078d637feca75c1119118287cb97514013c4b54d322da498f9b3fce55b58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/arcnet/arcdevice.h",
  "human_readable_source": " \n \n#ifndef _LINUX_ARCDEVICE_H\n#define _LINUX_ARCDEVICE_H\n\n#include <asm/timex.h>\n#include <linux/if_arcnet.h>\n\n#ifdef __KERNEL__\n#include <linux/interrupt.h>\n\n \n#define RECON_THRESHOLD 30\n\n \n#define TX_TIMEOUT (HZ * 200 / 1000)\n\n \n#undef ALPHA_WARNING\n\n \n#define D_NORMAL\t1\t \n#define D_EXTRA\t\t2\t \n#define\tD_INIT\t\t4\t \n#define D_INIT_REASONS\t8\t \n#define D_RECON\t\t32\t \n#define D_PROTO\t\t64\t \n \n#define D_DURING\t128\t \n#define D_TX\t        256\t \n#define D_RX\t\t512\t \n#define D_SKB\t\t1024\t \n#define D_SKB_SIZE\t2048\t \n#define D_TIMING\t4096\t \n#define D_DEBUG         8192     \n\n#ifndef ARCNET_DEBUG_MAX\n#define ARCNET_DEBUG_MAX (127)\t \n#endif\n\n#ifndef ARCNET_DEBUG\n#define ARCNET_DEBUG (D_NORMAL | D_EXTRA)\n#endif\nextern int arcnet_debug;\n\n#define BUGLVL(x)\t((x) & ARCNET_DEBUG_MAX & arcnet_debug)\n\n \n#define arc_printk(x, dev, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (BUGLVL(x)) {\t\t\t\t\t\t\\\n\t\tif ((x) == D_NORMAL)\t\t\t\t\t\\\n\t\t\tnetdev_warn(dev, fmt, ##__VA_ARGS__);\t\t\\\n\t\telse if ((x) < D_DURING)\t\t\t\t\\\n\t\t\tnetdev_info(dev, fmt, ##__VA_ARGS__);\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tnetdev_dbg(dev, fmt, ##__VA_ARGS__);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define arc_cont(x, fmt, ...)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (BUGLVL(x))\t\t\t\t\t\t\t\\\n\t\tpr_cont(fmt, ##__VA_ARGS__);\t\t\t\t\\\n} while (0)\n\n \n#define TIME(dev, name, bytes, call)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (BUGLVL(D_TIMING)) {\t\t\t\t\t\t\\\n\t\tunsigned long _x, _y;\t\t\t\t\t\\\n\t\t_x = get_cycles();\t\t\t\t\t\\\n\t\tcall;\t\t\t\t\t\t\t\\\n\t\t_y = get_cycles();\t\t\t\t\t\\\n\t\tarc_printk(D_TIMING, dev,\t\t\t\t\\\n\t\t\t   \"%s: %d bytes in %lu cycles == %lu Kbytes/100Mcycle\\n\", \\\n\t\t\t   name, bytes, _y - _x,\t\t\t\\\n\t\t\t   100000000 / 1024 * bytes / (_y - _x + 1));\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tcall;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n \n#define RESETtime (300)\n\n \n#define MTU\t253\t\t \n#define MinTU\t257\t\t \n#define XMTU\t508\t\t \n\n \n#define TXFREEflag\t0x01\t \n#define TXACKflag       0x02\t \n#define RECONflag       0x04\t \n#define TESTflag        0x08\t \n#define EXCNAKflag      0x08     \n#define RESETflag       0x10\t \n#define RES1flag        0x20\t \n#define RES2flag        0x40\t \n#define NORXflag        0x80\t \n\n \n#define AUTOINCflag     0x40\t \n#define IOMAPflag       0x02\t \n#define ENABLE16flag    0x80\t \n\n \n#define NOTXcmd         0x01\t \n#define NORXcmd         0x02\t \n#define TXcmd           0x03\t \n#define RXcmd           0x04\t \n#define CONFIGcmd       0x05\t \n#define CFLAGScmd       0x06\t \n#define TESTcmd         0x07\t \n#define STARTIOcmd      0x18\t \n\n \n#define RESETclear      0x08\t \n#define CONFIGclear     0x10\t \n\n#define EXCNAKclear     0x0E     \n\n \n#define TESTload        0x08\t \n\n \n#define TESTvalue       0321\t \n\n \n#define RXbcasts        0x80\t \n\n \n#define NORMALconf      0x00\t \n#define EXTconf         0x08\t \n\n \n#define ARC_IS_5MBIT    1    \n#define ARC_CAN_10MBIT  2    \n#define ARC_HAS_LED     4    \n#define ARC_HAS_ROTARY  8    \n\n \nstruct ArcProto {\n\tchar suffix;\t\t \n\tint mtu;\t\t \n\tint is_ip;               \n\n\tvoid (*rx)(struct net_device *dev, int bufnum,\n\t\t   struct archdr *pkthdr, int length);\n\tint (*build_header)(struct sk_buff *skb, struct net_device *dev,\n\t\t\t    unsigned short ethproto, uint8_t daddr);\n\n\t \n\tint (*prepare_tx)(struct net_device *dev, struct archdr *pkt,\n\t\t\t  int length, int bufnum);\n\tint (*continue_tx)(struct net_device *dev, int bufnum);\n\tint (*ack_tx)(struct net_device *dev, int acked);\n};\n\nextern struct ArcProto *arc_proto_map[256], *arc_proto_default,\n\t*arc_bcast_proto, *arc_raw_proto;\n\n \nstruct Incoming {\n\tstruct sk_buff *skb;\t \n\t__be16 sequence;\t \n\tuint8_t lastpacket,\t \n\t\tnumpackets;\t \n};\n\n \nstruct Outgoing {\n\tstruct ArcProto *proto;\t \n\tstruct sk_buff *skb;\t \n\tstruct archdr *pkt;\t \n\tuint16_t length,\t \n\t\tdataleft,\t \n\t\tsegnum,\t\t \n\t\tnumsegs;\t \n};\n\n#define ARCNET_LED_NAME_SZ (IFNAMSIZ + 6)\n\nstruct arcnet_local {\n\tuint8_t config,\t\t \n\t\ttimeout,\t \n\t\tbackplane,\t \n\t\tclockp,\t\t \n\t\tclockm,\t\t \n\t\tsetup,\t\t \n\t\tsetup2,\t\t \n\t\tintmask;\t \n\tuint8_t default_proto[256];\t \n\tint\tcur_tx,\t\t \n\t\tnext_tx,\t \n\t\tcur_rx;\t\t \n\tint\tlastload_dest,\t \n\t\tlasttrans_dest;\t \n\tint\ttimed_out;\t \n\tunsigned long last_timeout;\t \n\tchar *card_name;\t \n\tint card_flags;\t\t \n\n\t \n\tspinlock_t lock;\n\n\tstruct led_trigger *tx_led_trig;\n\tchar tx_led_trig_name[ARCNET_LED_NAME_SZ];\n\tstruct led_trigger *recon_led_trig;\n\tchar recon_led_trig_name[ARCNET_LED_NAME_SZ];\n\n\tstruct timer_list\ttimer;\n\n\tstruct net_device *dev;\n\tint reply_status;\n\tstruct tasklet_struct reply_tasklet;\n\n\t \n\tatomic_t buf_lock;\n\tint buf_queue[5];\n\tint next_buf, first_free_buf;\n\n\t \n\tunsigned long first_recon;  \n\tunsigned long last_recon;   \n\tint num_recons;\t\t \n\tint network_down;\t \n\n\tint excnak_pending;     \n\n\t \n\tint reset_in_progress;\n\tstruct work_struct reset_work;\n\n\tstruct {\n\t\tuint16_t sequence;\t \n\t\t__be16 aborted_seq;\n\n\t\tstruct Incoming incoming[256];\t \n\t} rfc1201;\n\n\t \n\tstruct Outgoing outgoing;\t \n\n\t \n\tstruct {\n\t\tstruct module *owner;\n\t\tvoid (*command)(struct net_device *dev, int cmd);\n\t\tint (*status)(struct net_device *dev);\n\t\tvoid (*intmask)(struct net_device *dev, int mask);\n\t\tint (*reset)(struct net_device *dev, int really_reset);\n\t\tvoid (*open)(struct net_device *dev);\n\t\tvoid (*close)(struct net_device *dev);\n\t\tvoid (*datatrigger) (struct net_device * dev, int enable);\n\t\tvoid (*recontrigger) (struct net_device * dev, int enable);\n\n\t\tvoid (*copy_to_card)(struct net_device *dev, int bufnum,\n\t\t\t\t     int offset, void *buf, int count);\n\t\tvoid (*copy_from_card)(struct net_device *dev, int bufnum,\n\t\t\t\t       int offset, void *buf, int count);\n\t} hw;\n\n\tvoid __iomem *mem_start;\t \n};\n\nenum arcnet_led_event {\n\tARCNET_LED_EVENT_RECON,\n\tARCNET_LED_EVENT_OPEN,\n\tARCNET_LED_EVENT_STOP,\n\tARCNET_LED_EVENT_TX,\n};\n\nvoid arcnet_led_event(struct net_device *netdev, enum arcnet_led_event event);\nvoid devm_arcnet_led_init(struct net_device *netdev, int index, int subid);\n\n#if ARCNET_DEBUG_MAX & D_SKB\nvoid arcnet_dump_skb(struct net_device *dev, struct sk_buff *skb, char *desc);\n#else\nstatic inline\nvoid arcnet_dump_skb(struct net_device *dev, struct sk_buff *skb, char *desc)\n{\n}\n#endif\n\nvoid arcnet_unregister_proto(struct ArcProto *proto);\nirqreturn_t arcnet_interrupt(int irq, void *dev_id);\n\nstruct net_device *alloc_arcdev(const char *name);\nvoid free_arcdev(struct net_device *dev);\n\nint arcnet_open(struct net_device *dev);\nint arcnet_close(struct net_device *dev);\nnetdev_tx_t arcnet_send_packet(struct sk_buff *skb,\n\t\t\t       struct net_device *dev);\nvoid arcnet_timeout(struct net_device *dev, unsigned int txqueue);\n\nstatic inline void arcnet_set_addr(struct net_device *dev, u8 addr)\n{\n\tdev_addr_set(dev, &addr);\n}\n\n \n\n#ifdef CONFIG_SA1100_CT6001\n#define BUS_ALIGN  2   \n#else\n#define BUS_ALIGN  1\n#endif\n\n \n#define arcnet_inb(addr, offset)\t\t\t\t\t\\\n\tinb((addr) + BUS_ALIGN * (offset))\n#define arcnet_outb(value, addr, offset)\t\t\t\t\\\n\toutb(value, (addr) + BUS_ALIGN * (offset))\n\n#define arcnet_insb(addr, offset, buffer, count)\t\t\t\\\n\tinsb((addr) + BUS_ALIGN * (offset), buffer, count)\n#define arcnet_outsb(addr, offset, buffer, count)\t\t\t\\\n\toutsb((addr) + BUS_ALIGN * (offset), buffer, count)\n\n#define arcnet_readb(addr, offset)\t\t\t\t\t\\\n\treadb((addr) + (offset))\n#define arcnet_writeb(value, addr, offset)\t\t\t\t\\\n\twriteb(value, (addr) + (offset))\n\n#endif\t\t\t\t \n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}