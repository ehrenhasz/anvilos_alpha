{
  "module_name": "rfc1201.c",
  "hash_id": "3ab5d10845099bf0845b1aedd615977430104f27f4be8e8c5200b23c23a260a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/arcnet/rfc1201.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"arcnet:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n\n#include \"arcdevice.h\"\n\nMODULE_LICENSE(\"GPL\");\n\nstatic __be16 type_trans(struct sk_buff *skb, struct net_device *dev);\nstatic void rx(struct net_device *dev, int bufnum,\n\t       struct archdr *pkthdr, int length);\nstatic int build_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\tunsigned short type, uint8_t daddr);\nstatic int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,\n\t\t      int bufnum);\nstatic int continue_tx(struct net_device *dev, int bufnum);\n\nstatic struct ArcProto rfc1201_proto = {\n\t.suffix\t\t= 'a',\n\t.mtu\t\t= 1500,\t \n\t.is_ip          = 1,     \n\t.rx\t\t= rx,\n\t.build_header\t= build_header,\n\t.prepare_tx\t= prepare_tx,\n\t.continue_tx\t= continue_tx,\n\t.ack_tx         = NULL\n};\n\nstatic int __init arcnet_rfc1201_init(void)\n{\n\tpr_info(\"%s\\n\", \"RFC1201 \\\"standard\\\" (`a') encapsulation support loaded\");\n\n\tarc_proto_map[ARC_P_IP]\n\t    = arc_proto_map[ARC_P_IPV6]\n\t    = arc_proto_map[ARC_P_ARP]\n\t    = arc_proto_map[ARC_P_RARP]\n\t    = arc_proto_map[ARC_P_IPX]\n\t    = arc_proto_map[ARC_P_NOVELL_EC]\n\t    = &rfc1201_proto;\n\n\t \n\tif (arc_bcast_proto == arc_proto_default)\n\t\tarc_bcast_proto = &rfc1201_proto;\n\n\treturn 0;\n}\n\nstatic void __exit arcnet_rfc1201_exit(void)\n{\n\tarcnet_unregister_proto(&rfc1201_proto);\n}\n\nmodule_init(arcnet_rfc1201_init);\nmodule_exit(arcnet_rfc1201_exit);\n\n \nstatic __be16 type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct archdr *pkt = (struct archdr *)skb->data;\n\tstruct arc_rfc1201 *soft = &pkt->soft.rfc1201;\n\tint hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;\n\n\t \n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, hdr_size);\n\n\tif (pkt->hard.dest == 0) {\n\t\tskb->pkt_type = PACKET_BROADCAST;\n\t} else if (dev->flags & IFF_PROMISC) {\n\t\t \n\t\tif (pkt->hard.dest != dev->dev_addr[0])\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t}\n\t \n\tswitch (soft->proto) {\n\tcase ARC_P_IP:\n\t\treturn htons(ETH_P_IP);\n\tcase ARC_P_IPV6:\n\t\treturn htons(ETH_P_IPV6);\n\tcase ARC_P_ARP:\n\t\treturn htons(ETH_P_ARP);\n\tcase ARC_P_RARP:\n\t\treturn htons(ETH_P_RARP);\n\n\tcase ARC_P_IPX:\n\tcase ARC_P_NOVELL_EC:\n\t\treturn htons(ETH_P_802_3);\n\tdefault:\n\t\tdev->stats.rx_errors++;\n\t\tdev->stats.rx_crc_errors++;\n\t\treturn 0;\n\t}\n\n\treturn htons(ETH_P_IP);\n}\n\n \nstatic void rx(struct net_device *dev, int bufnum,\n\t       struct archdr *pkthdr, int length)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tstruct archdr *pkt = pkthdr;\n\tstruct arc_rfc1201 *soft = &pkthdr->soft.rfc1201;\n\tint saddr = pkt->hard.source, ofs;\n\tstruct Incoming *in = &lp->rfc1201.incoming[saddr];\n\n\tarc_printk(D_DURING, dev, \"it's an RFC1201 packet (length=%d)\\n\",\n\t\t   length);\n\n\tif (length >= MinTU)\n\t\tofs = 512 - length;\n\telse\n\t\tofs = 256 - length;\n\n\tif (soft->split_flag == 0xFF) {\t\t \n\t\tif (length >= 4 + RFC1201_HDR_SIZE) {\n\t\t\tarc_printk(D_DURING, dev, \"compensating for exception packet\\n\");\n\t\t} else {\n\t\t\tarc_printk(D_EXTRA, dev, \"short RFC1201 exception packet from %02Xh\",\n\t\t\t\t   saddr);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tlength -= 4;\n\t\tofs += 4;\n\t\tlp->hw.copy_from_card(dev, bufnum, 512 - length,\n\t\t\t\t      soft, sizeof(pkt->soft));\n\t}\n\tif (!soft->split_flag) {\t \n\t\tarc_printk(D_RX, dev, \"incoming is not split (splitflag=%d)\\n\",\n\t\t\t   soft->split_flag);\n\n\t\tif (in->skb) {\t \n\t\t\tarc_printk(D_EXTRA, dev, \"aborting assembly (seq=%d) for unsplit packet (splitflag=%d, seq=%d)\\n\",\n\t\t\t\t   in->sequence, soft->split_flag,\n\t\t\t\t   soft->sequence);\n\t\t\tlp->rfc1201.aborted_seq = soft->sequence;\n\t\t\tdev_kfree_skb_irq(in->skb);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tdev->stats.rx_missed_errors++;\n\t\t\tin->skb = NULL;\n\t\t}\n\t\tin->sequence = soft->sequence;\n\n\t\tskb = alloc_skb(length + ARC_HDR_SIZE, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tdev->stats.rx_dropped++;\n\t\t\treturn;\n\t\t}\n\t\tskb_put(skb, length + ARC_HDR_SIZE);\n\t\tskb->dev = dev;\n\n\t\tpkt = (struct archdr *)skb->data;\n\t\tsoft = &pkt->soft.rfc1201;\n\n\t\t \n\t\tmemcpy(pkt, pkthdr, sizeof(struct archdr));\n\t\tif (length > sizeof(pkt->soft))\n\t\t\tlp->hw.copy_from_card(dev, bufnum,\n\t\t\t\t\t      ofs + sizeof(pkt->soft),\n\t\t\t\t\t      pkt->soft.raw + sizeof(pkt->soft),\n\t\t\t\t\t      length - sizeof(pkt->soft));\n\n\t\t \n\t\tif (soft->proto == ARC_P_ARP) {\n\t\t\tstruct arphdr *arp = (struct arphdr *)soft->payload;\n\n\t\t\t \n\t\t\tif (arp->ar_hln == 1 && arp->ar_pln == 4) {\n\t\t\t\tuint8_t *cptr = (uint8_t *)arp + sizeof(struct arphdr);\n\n\t\t\t\tif (!*cptr) {\t \n\t\t\t\t\tarc_printk(D_EXTRA, dev,\n\t\t\t\t\t\t   \"ARP source address was 00h, set to %02Xh\\n\",\n\t\t\t\t\t\t   saddr);\n\t\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t\t\t*cptr = saddr;\n\t\t\t\t} else {\n\t\t\t\t\tarc_printk(D_DURING, dev, \"ARP source address (%Xh) is fine.\\n\",\n\t\t\t\t\t\t   *cptr);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarc_printk(D_NORMAL, dev, \"funny-shaped ARP packet. (%Xh, %Xh)\\n\",\n\t\t\t\t\t   arp->ar_hln, arp->ar_pln);\n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t}\n\t\t}\n\t\tif (BUGLVL(D_SKB))\n\t\t\tarcnet_dump_skb(dev, skb, \"rx\");\n\n\t\tskb->protocol = type_trans(skb, dev);\n\t\tnetif_rx(skb);\n\t} else {\t\t \n\t\t \n\n\t\tarc_printk(D_RX, dev, \"packet is split (splitflag=%d, seq=%d)\\n\",\n\t\t\t   soft->split_flag, in->sequence);\n\n\t\tif (in->skb && in->sequence != soft->sequence) {\n\t\t\tarc_printk(D_EXTRA, dev, \"wrong seq number (saddr=%d, expected=%d, seq=%d, splitflag=%d)\\n\",\n\t\t\t\t   saddr, in->sequence, soft->sequence,\n\t\t\t\t   soft->split_flag);\n\t\t\tdev_kfree_skb_irq(in->skb);\n\t\t\tin->skb = NULL;\n\t\t\tdev->stats.rx_errors++;\n\t\t\tdev->stats.rx_missed_errors++;\n\t\t\tin->lastpacket = in->numpackets = 0;\n\t\t}\n\t\tif (soft->split_flag & 1) {\t \n\t\t\tarc_printk(D_RX, dev, \"brand new splitpacket (splitflag=%d)\\n\",\n\t\t\t\t   soft->split_flag);\n\t\t\tif (in->skb) {\t \n\t\t\t\tarc_printk(D_EXTRA, dev, \"aborting previous (seq=%d) assembly (splitflag=%d, seq=%d)\\n\",\n\t\t\t\t\t   in->sequence, soft->split_flag,\n\t\t\t\t\t   soft->sequence);\n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t\tdev->stats.rx_missed_errors++;\n\t\t\t\tdev_kfree_skb_irq(in->skb);\n\t\t\t}\n\t\t\tin->sequence = soft->sequence;\n\t\t\tin->numpackets = ((unsigned)soft->split_flag >> 1) + 2;\n\t\t\tin->lastpacket = 1;\n\n\t\t\tif (in->numpackets > 16) {\n\t\t\t\tarc_printk(D_EXTRA, dev, \"incoming packet more than 16 segments; dropping. (splitflag=%d)\\n\",\n\t\t\t\t\t   soft->split_flag);\n\t\t\t\tlp->rfc1201.aborted_seq = soft->sequence;\n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tin->skb = skb = alloc_skb(508 * in->numpackets + ARC_HDR_SIZE,\n\t\t\t\t\t\t  GFP_ATOMIC);\n\t\t\tif (!skb) {\n\t\t\t\tarc_printk(D_NORMAL, dev, \"(split) memory squeeze, dropping packet.\\n\");\n\t\t\t\tlp->rfc1201.aborted_seq = soft->sequence;\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tskb->dev = dev;\n\t\t\tpkt = (struct archdr *)skb->data;\n\t\t\tsoft = &pkt->soft.rfc1201;\n\n\t\t\tmemcpy(pkt, pkthdr, ARC_HDR_SIZE + RFC1201_HDR_SIZE);\n\t\t\tskb_put(skb, ARC_HDR_SIZE + RFC1201_HDR_SIZE);\n\n\t\t\tsoft->split_flag = 0;\t \n\t\t} else {\t \n\t\t\tint packetnum = ((unsigned)soft->split_flag >> 1) + 1;\n\n\t\t\t \n\t\t\tif (!in->skb) {\n\t\t\t\tif (lp->rfc1201.aborted_seq != soft->sequence) {\n\t\t\t\t\tarc_printk(D_EXTRA, dev, \"can't continue split without starting first! (splitflag=%d, seq=%d, aborted=%d)\\n\",\n\t\t\t\t\t\t   soft->split_flag,\n\t\t\t\t\t\t   soft->sequence,\n\t\t\t\t\t\t   lp->rfc1201.aborted_seq);\n\t\t\t\t\tdev->stats.rx_errors++;\n\t\t\t\t\tdev->stats.rx_missed_errors++;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tin->lastpacket++;\n\t\t\t \n\t\t\tif (packetnum != in->lastpacket) {\n\t\t\t\t \n\t\t\t\tif (packetnum <= in->lastpacket - 1) {\n\t\t\t\t\tarc_printk(D_EXTRA, dev, \"duplicate splitpacket ignored! (splitflag=%d)\\n\",\n\t\t\t\t\t\t   soft->split_flag);\n\t\t\t\t\tdev->stats.rx_errors++;\n\t\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tarc_printk(D_EXTRA, dev, \"out-of-order splitpacket, reassembly (seq=%d) aborted (splitflag=%d, seq=%d)\\n\",\n\t\t\t\t\t   in->sequence, soft->split_flag,\n\t\t\t\t\t   soft->sequence);\n\t\t\t\tlp->rfc1201.aborted_seq = soft->sequence;\n\t\t\t\tdev_kfree_skb_irq(in->skb);\n\t\t\t\tin->skb = NULL;\n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t\tdev->stats.rx_missed_errors++;\n\t\t\t\tin->lastpacket = in->numpackets = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpkt = (struct archdr *)in->skb->data;\n\t\t\tsoft = &pkt->soft.rfc1201;\n\t\t}\n\n\t\tskb = in->skb;\n\n\t\tlp->hw.copy_from_card(dev, bufnum, ofs + RFC1201_HDR_SIZE,\n\t\t\t\t      skb->data + skb->len,\n\t\t\t\t      length - RFC1201_HDR_SIZE);\n\t\tskb_put(skb, length - RFC1201_HDR_SIZE);\n\n\t\t \n\t\tif (in->lastpacket == in->numpackets) {\n\t\t\tin->skb = NULL;\n\t\t\tin->lastpacket = in->numpackets = 0;\n\n\t\t\tarc_printk(D_SKB_SIZE, dev, \"skb: received %d bytes from %02X (unsplit)\\n\",\n\t\t\t\t   skb->len, pkt->hard.source);\n\t\t\tarc_printk(D_SKB_SIZE, dev, \"skb: received %d bytes from %02X (split)\\n\",\n\t\t\t\t   skb->len, pkt->hard.source);\n\t\t\tif (BUGLVL(D_SKB))\n\t\t\t\tarcnet_dump_skb(dev, skb, \"rx\");\n\n\t\t\tskb->protocol = type_trans(skb, dev);\n\t\t\tnetif_rx(skb);\n\t\t}\n\t}\n}\n\n \nstatic int build_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\tunsigned short type, uint8_t daddr)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tint hdr_size = ARC_HDR_SIZE + RFC1201_HDR_SIZE;\n\tstruct archdr *pkt = skb_push(skb, hdr_size);\n\tstruct arc_rfc1201 *soft = &pkt->soft.rfc1201;\n\n\t \n\tswitch (type) {\n\tcase ETH_P_IP:\n\t\tsoft->proto = ARC_P_IP;\n\t\tbreak;\n\tcase ETH_P_IPV6:\n\t\tsoft->proto = ARC_P_IPV6;\n\t\tbreak;\n\tcase ETH_P_ARP:\n\t\tsoft->proto = ARC_P_ARP;\n\t\tbreak;\n\tcase ETH_P_RARP:\n\t\tsoft->proto = ARC_P_RARP;\n\t\tbreak;\n\tcase ETH_P_IPX:\n\tcase ETH_P_802_3:\n\tcase ETH_P_802_2:\n\t\tsoft->proto = ARC_P_IPX;\n\t\tbreak;\n\tcase ETH_P_ATALK:\n\t\tsoft->proto = ARC_P_ATALK;\n\t\tbreak;\n\tdefault:\n\t\tarc_printk(D_NORMAL, dev, \"RFC1201: I don't understand protocol %d (%Xh)\\n\",\n\t\t\t   type, type);\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_aborted_errors++;\n\t\treturn 0;\n\t}\n\n\t \n\tpkt->hard.source = *dev->dev_addr;\n\n\tsoft->sequence = htons(lp->rfc1201.sequence++);\n\tsoft->split_flag = 0;\t \n\n\t \n\n\tif (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {\n\t\t \n\t\tpkt->hard.dest = 0;\n\t\treturn hdr_size;\n\t}\n\t \n\tpkt->hard.dest = daddr;\n\treturn hdr_size;\n}\n\nstatic void load_pkt(struct net_device *dev, struct arc_hardware *hard,\n\t\t     struct arc_rfc1201 *soft, int softlen, int bufnum)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tint ofs;\n\n\t \n\n\tif (softlen > MinTU) {\n\t\thard->offset[0] = 0;\n\t\thard->offset[1] = ofs = 512 - softlen;\n\t} else if (softlen > MTU) {\t \n\t\tstruct arc_rfc1201 excsoft;\n\n\t\texcsoft.proto = soft->proto;\n\t\texcsoft.split_flag = 0xff;\n\t\texcsoft.sequence = htons(0xffff);\n\n\t\thard->offset[0] = 0;\n\t\tofs = 512 - softlen;\n\t\thard->offset[1] = ofs - RFC1201_HDR_SIZE;\n\t\tlp->hw.copy_to_card(dev, bufnum, ofs - RFC1201_HDR_SIZE,\n\t\t\t\t    &excsoft, RFC1201_HDR_SIZE);\n\t} else {\n\t\thard->offset[0] = ofs = 256 - softlen;\n\t}\n\n\tlp->hw.copy_to_card(dev, bufnum, 0, hard, ARC_HDR_SIZE);\n\tlp->hw.copy_to_card(dev, bufnum, ofs, soft, softlen);\n\n\tlp->lastload_dest = hard->dest;\n}\n\nstatic int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,\n\t\t      int bufnum)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tconst int maxsegsize = XMTU - RFC1201_HDR_SIZE;\n\tstruct Outgoing *out;\n\n\tarc_printk(D_DURING, dev, \"prepare_tx: txbufs=%d/%d/%d\\n\",\n\t\t   lp->next_tx, lp->cur_tx, bufnum);\n\n\t \n\tlength -= ARC_HDR_SIZE;\n\tpkt->soft.rfc1201.split_flag = 0;\n\n\t \n\tif (length > XMTU) {\n\t\tout = &lp->outgoing;\n\n\t\tout->length = length - RFC1201_HDR_SIZE;\n\t\tout->dataleft = lp->outgoing.length;\n\t\tout->numsegs = (out->dataleft + maxsegsize - 1) / maxsegsize;\n\t\tout->segnum = 0;\n\n\t\tarc_printk(D_DURING, dev, \"rfc1201 prep_tx: ready for %d-segment split (%d bytes, seq=%d)\\n\",\n\t\t\t   out->numsegs, out->length,\n\t\t\t   pkt->soft.rfc1201.sequence);\n\n\t\treturn 0;\t \n\t}\n\t \n\tload_pkt(dev, &pkt->hard, &pkt->soft.rfc1201, length, bufnum);\n\n\treturn 1;\t\t \n}\n\nstatic int continue_tx(struct net_device *dev, int bufnum)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct Outgoing *out = &lp->outgoing;\n\tstruct arc_hardware *hard = &out->pkt->hard;\n\tstruct arc_rfc1201 *soft = &out->pkt->soft.rfc1201, *newsoft;\n\tint maxsegsize = XMTU - RFC1201_HDR_SIZE;\n\tint seglen;\n\n\tarc_printk(D_DURING, dev,\n\t\t   \"rfc1201 continue_tx: loading segment %d(+1) of %d (seq=%d)\\n\",\n\t\t   out->segnum, out->numsegs, soft->sequence);\n\n\t \n\tnewsoft = (struct arc_rfc1201 *)\n\t    (out->pkt->soft.raw + out->length - out->dataleft);\n\n\tif (!out->segnum)\t \n\t\tnewsoft->split_flag = ((out->numsegs - 2) << 1) | 1;\n\telse {\n\t\tnewsoft->split_flag = out->segnum << 1;\n\t\tnewsoft->proto = soft->proto;\n\t\tnewsoft->sequence = soft->sequence;\n\t}\n\n\tseglen = maxsegsize;\n\tif (seglen > out->dataleft)\n\t\tseglen = out->dataleft;\n\tout->dataleft -= seglen;\n\n\tload_pkt(dev, hard, newsoft, seglen + RFC1201_HDR_SIZE, bufnum);\n\n\tout->segnum++;\n\tif (out->segnum >= out->numsegs)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}