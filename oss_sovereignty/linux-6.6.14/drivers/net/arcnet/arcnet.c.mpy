{
  "module_name": "arcnet.c",
  "hash_id": "0c8a5079ce606b67402b0949402c17eec8542c47112021fc55e271340b852821",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/arcnet/arcnet.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <net/arp.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/errqueue.h>\n\n#include <linux/leds.h>\n\n#include \"arcdevice.h\"\n#include \"com9026.h\"\n\n \nstatic void null_rx(struct net_device *dev, int bufnum,\n\t\t    struct archdr *pkthdr, int length);\nstatic int null_build_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     unsigned short type, uint8_t daddr);\nstatic int null_prepare_tx(struct net_device *dev, struct archdr *pkt,\n\t\t\t   int length, int bufnum);\n\nstatic void arcnet_rx(struct net_device *dev, int bufnum);\n\n \nstruct ArcProto *arc_proto_map[256];\nEXPORT_SYMBOL(arc_proto_map);\n\nstruct ArcProto *arc_proto_default;\nEXPORT_SYMBOL(arc_proto_default);\n\nstruct ArcProto *arc_bcast_proto;\nEXPORT_SYMBOL(arc_bcast_proto);\n\nstruct ArcProto *arc_raw_proto;\nEXPORT_SYMBOL(arc_raw_proto);\n\nstatic struct ArcProto arc_proto_null = {\n\t.suffix\t\t= '?',\n\t.mtu\t\t= XMTU,\n\t.is_ip          = 0,\n\t.rx\t\t= null_rx,\n\t.build_header\t= null_build_header,\n\t.prepare_tx\t= null_prepare_tx,\n\t.continue_tx    = NULL,\n\t.ack_tx         = NULL\n};\n\n \nint arcnet_debug = ARCNET_DEBUG;\nEXPORT_SYMBOL(arcnet_debug);\n\n \nstatic int arcnet_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t unsigned short type, const void *daddr,\n\t\t\t const void *saddr, unsigned len);\nstatic int go_tx(struct net_device *dev);\n\nstatic int debug = ARCNET_DEBUG;\nmodule_param(debug, int, 0);\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init arcnet_init(void)\n{\n\tint count;\n\n\tarcnet_debug = debug;\n\n\tpr_info(\"arcnet loaded\\n\");\n\n\t \n\tarc_raw_proto = arc_proto_default = arc_bcast_proto = &arc_proto_null;\n\tfor (count = 0; count < 256; count++)\n\t\tarc_proto_map[count] = arc_proto_default;\n\n\tif (BUGLVL(D_DURING))\n\t\tpr_info(\"struct sizes: %zd %zd %zd %zd %zd\\n\",\n\t\t\tsizeof(struct arc_hardware),\n\t\t\tsizeof(struct arc_rfc1201),\n\t\t\tsizeof(struct arc_rfc1051),\n\t\t\tsizeof(struct arc_eth_encap),\n\t\t\tsizeof(struct archdr));\n\n\treturn 0;\n}\n\nstatic void __exit arcnet_exit(void)\n{\n}\n\nmodule_init(arcnet_init);\nmodule_exit(arcnet_exit);\n\n \n#if ARCNET_DEBUG_MAX & D_SKB\nvoid arcnet_dump_skb(struct net_device *dev,\n\t\t     struct sk_buff *skb, char *desc)\n{\n\tchar hdr[32];\n\n\t \n\tsnprintf(hdr, sizeof(hdr), \"%6s:%s skb->data:\", dev->name, desc);\n\tprint_hex_dump(KERN_DEBUG, hdr, DUMP_PREFIX_OFFSET,\n\t\t       16, 1, skb->data, skb->len, true);\n}\nEXPORT_SYMBOL(arcnet_dump_skb);\n#endif\n\n \n#if (ARCNET_DEBUG_MAX & (D_RX | D_TX))\nstatic void arcnet_dump_packet(struct net_device *dev, int bufnum,\n\t\t\t       char *desc, int take_arcnet_lock)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tint i, length;\n\tunsigned long flags = 0;\n\tstatic uint8_t buf[512];\n\tchar hdr[32];\n\n\t \n\tif (take_arcnet_lock)\n\t\tspin_lock_irqsave(&lp->lock, flags);\n\n\tlp->hw.copy_from_card(dev, bufnum, 0, buf, 512);\n\tif (take_arcnet_lock)\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\t \n\tlength = (buf[2] ? 256 : 512);\n\n\t \n\tsnprintf(hdr, sizeof(hdr), \"%6s:%s packet dump:\", dev->name, desc);\n\tprint_hex_dump(KERN_DEBUG, hdr, DUMP_PREFIX_OFFSET,\n\t\t       16, 1, buf, length, true);\n}\n\n#else\n\n#define arcnet_dump_packet(dev, bufnum, desc, take_arcnet_lock) do { } while (0)\n\n#endif\n\n \nvoid arcnet_led_event(struct net_device *dev, enum arcnet_led_event event)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\n\tswitch (event) {\n\tcase ARCNET_LED_EVENT_RECON:\n\t\tled_trigger_blink_oneshot(lp->recon_led_trig, 350, 350, 0);\n\t\tbreak;\n\tcase ARCNET_LED_EVENT_OPEN:\n\t\tled_trigger_event(lp->tx_led_trig, LED_OFF);\n\t\tled_trigger_event(lp->recon_led_trig, LED_OFF);\n\t\tbreak;\n\tcase ARCNET_LED_EVENT_STOP:\n\t\tled_trigger_event(lp->tx_led_trig, LED_OFF);\n\t\tled_trigger_event(lp->recon_led_trig, LED_OFF);\n\t\tbreak;\n\tcase ARCNET_LED_EVENT_TX:\n\t\tled_trigger_blink_oneshot(lp->tx_led_trig, 50, 50, 0);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(arcnet_led_event);\n\nstatic void arcnet_led_release(struct device *gendev, void *res)\n{\n\tstruct arcnet_local *lp = netdev_priv(to_net_dev(gendev));\n\n\tled_trigger_unregister_simple(lp->tx_led_trig);\n\tled_trigger_unregister_simple(lp->recon_led_trig);\n}\n\n \nvoid devm_arcnet_led_init(struct net_device *netdev, int index, int subid)\n{\n\tstruct arcnet_local *lp = netdev_priv(netdev);\n\tvoid *res;\n\n\tres = devres_alloc(arcnet_led_release, 0, GFP_KERNEL);\n\tif (!res) {\n\t\tnetdev_err(netdev, \"cannot register LED triggers\\n\");\n\t\treturn;\n\t}\n\n\tsnprintf(lp->tx_led_trig_name, sizeof(lp->tx_led_trig_name),\n\t\t \"arc%d-%d-tx\", index, subid);\n\tsnprintf(lp->recon_led_trig_name, sizeof(lp->recon_led_trig_name),\n\t\t \"arc%d-%d-recon\", index, subid);\n\n\tled_trigger_register_simple(lp->tx_led_trig_name,\n\t\t\t\t    &lp->tx_led_trig);\n\tled_trigger_register_simple(lp->recon_led_trig_name,\n\t\t\t\t    &lp->recon_led_trig);\n\n\tdevres_add(&netdev->dev, res);\n}\nEXPORT_SYMBOL_GPL(devm_arcnet_led_init);\n\n \nvoid arcnet_unregister_proto(struct ArcProto *proto)\n{\n\tint count;\n\n\tif (arc_proto_default == proto)\n\t\tarc_proto_default = &arc_proto_null;\n\tif (arc_bcast_proto == proto)\n\t\tarc_bcast_proto = arc_proto_default;\n\tif (arc_raw_proto == proto)\n\t\tarc_raw_proto = arc_proto_default;\n\n\tfor (count = 0; count < 256; count++) {\n\t\tif (arc_proto_map[count] == proto)\n\t\t\tarc_proto_map[count] = arc_proto_default;\n\t}\n}\nEXPORT_SYMBOL(arcnet_unregister_proto);\n\n \nstatic void release_arcbuf(struct net_device *dev, int bufnum)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tint i;\n\n\tlp->buf_queue[lp->first_free_buf++] = bufnum;\n\tlp->first_free_buf %= 5;\n\n\tif (BUGLVL(D_DURING)) {\n\t\tarc_printk(D_DURING, dev, \"release_arcbuf: freed #%d; buffer queue is now: \",\n\t\t\t   bufnum);\n\t\tfor (i = lp->next_buf; i != lp->first_free_buf; i = (i + 1) % 5)\n\t\t\tarc_cont(D_DURING, \"#%d \", lp->buf_queue[i]);\n\t\tarc_cont(D_DURING, \"\\n\");\n\t}\n}\n\n \nstatic int get_arcbuf(struct net_device *dev)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tint buf = -1, i;\n\n\tif (!atomic_dec_and_test(&lp->buf_lock)) {\n\t\t \n\t\tarc_printk(D_NORMAL, dev, \"get_arcbuf: overlap (%d)!\\n\",\n\t\t\t   lp->buf_lock.counter);\n\t} else {\t\t\t \n\t\tif (lp->next_buf >= 5)\n\t\t\tlp->next_buf -= 5;\n\n\t\tif (lp->next_buf == lp->first_free_buf) {\n\t\t\tarc_printk(D_NORMAL, dev, \"get_arcbuf: BUG: no buffers are available??\\n\");\n\t\t} else {\n\t\t\tbuf = lp->buf_queue[lp->next_buf++];\n\t\t\tlp->next_buf %= 5;\n\t\t}\n\t}\n\n\tif (BUGLVL(D_DURING)) {\n\t\tarc_printk(D_DURING, dev, \"get_arcbuf: got #%d; buffer queue is now: \",\n\t\t\t   buf);\n\t\tfor (i = lp->next_buf; i != lp->first_free_buf; i = (i + 1) % 5)\n\t\t\tarc_cont(D_DURING, \"#%d \", lp->buf_queue[i]);\n\t\tarc_cont(D_DURING, \"\\n\");\n\t}\n\n\tatomic_inc(&lp->buf_lock);\n\treturn buf;\n}\n\nstatic int choose_mtu(void)\n{\n\tint count, mtu = 65535;\n\n\t \n\tfor (count = 0; count < 256; count++) {\n\t\tif (arc_proto_map[count] != &arc_proto_null &&\n\t\t    arc_proto_map[count]->mtu < mtu) {\n\t\t\tmtu = arc_proto_map[count]->mtu;\n\t\t}\n\t}\n\n\treturn mtu == 65535 ? XMTU : mtu;\n}\n\nstatic const struct header_ops arcnet_header_ops = {\n\t.create = arcnet_header,\n};\n\nstatic const struct net_device_ops arcnet_netdev_ops = {\n\t.ndo_open\t= arcnet_open,\n\t.ndo_stop\t= arcnet_close,\n\t.ndo_start_xmit = arcnet_send_packet,\n\t.ndo_tx_timeout = arcnet_timeout,\n};\n\n \nstatic void arcdev_setup(struct net_device *dev)\n{\n\tdev->type = ARPHRD_ARCNET;\n\tdev->netdev_ops = &arcnet_netdev_ops;\n\tdev->header_ops = &arcnet_header_ops;\n\tdev->hard_header_len = sizeof(struct arc_hardware);\n\tdev->mtu = choose_mtu();\n\n\tdev->addr_len = ARCNET_ALEN;\n\tdev->tx_queue_len = 100;\n\tdev->broadcast[0] = 0x00;\t \n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\t \n\tdev->flags = IFF_BROADCAST;\n}\n\nstatic void arcnet_timer(struct timer_list *t)\n{\n\tstruct arcnet_local *lp = from_timer(lp, t, timer);\n\tstruct net_device *dev = lp->dev;\n\n\tspin_lock_irq(&lp->lock);\n\n\tif (!lp->reset_in_progress && !netif_carrier_ok(dev)) {\n\t\tnetif_carrier_on(dev);\n\t\tnetdev_info(dev, \"link up\\n\");\n\t}\n\n\tspin_unlock_irq(&lp->lock);\n}\n\nstatic void reset_device_work(struct work_struct *work)\n{\n\tstruct arcnet_local *lp;\n\tstruct net_device *dev;\n\n\tlp = container_of(work, struct arcnet_local, reset_work);\n\tdev = lp->dev;\n\n\t \n\tif (!netif_running(dev) || !lp->reset_in_progress)\n\t\treturn;\n\n\trtnl_lock();\n\n\t \n\tif (!netif_running(dev) || !lp->reset_in_progress)\n\t\tgoto out;\n\n\tdev_close(dev);\n\tdev_open(dev, NULL);\n\nout:\n\trtnl_unlock();\n}\n\nstatic void arcnet_reply_tasklet(struct tasklet_struct *t)\n{\n\tstruct arcnet_local *lp = from_tasklet(lp, t, reply_tasklet);\n\n\tstruct sk_buff *ackskb, *skb;\n\tstruct sock_exterr_skb *serr;\n\tstruct sock *sk;\n\tint ret;\n\n\tlocal_irq_disable();\n\tskb = lp->outgoing.skb;\n\tif (!skb || !skb->sk) {\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\tsock_hold(skb->sk);\n\tsk = skb->sk;\n\tackskb = skb_clone_sk(skb);\n\tsock_put(skb->sk);\n\n\tif (!ackskb) {\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\tserr = SKB_EXT_ERR(ackskb);\n\tmemset(serr, 0, sizeof(*serr));\n\tserr->ee.ee_errno = ENOMSG;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_TXSTATUS;\n\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n\tserr->ee.ee_info = lp->reply_status;\n\n\t \n\tdev_kfree_skb(lp->outgoing.skb);\n\tlp->outgoing.skb = NULL;\n\n\tackskb->dev = lp->dev;\n\n\tret = sock_queue_err_skb(sk, ackskb);\n\tif (ret)\n\t\tdev_kfree_skb_irq(ackskb);\n\n\tlocal_irq_enable();\n};\n\nstruct net_device *alloc_arcdev(const char *name)\n{\n\tstruct net_device *dev;\n\n\tdev = alloc_netdev(sizeof(struct arcnet_local),\n\t\t\t   name && *name ? name : \"arc%d\", NET_NAME_UNKNOWN,\n\t\t\t   arcdev_setup);\n\tif (dev) {\n\t\tstruct arcnet_local *lp = netdev_priv(dev);\n\n\t\tlp->dev = dev;\n\t\tspin_lock_init(&lp->lock);\n\t\ttimer_setup(&lp->timer, arcnet_timer, 0);\n\t\tINIT_WORK(&lp->reset_work, reset_device_work);\n\t}\n\n\treturn dev;\n}\nEXPORT_SYMBOL(alloc_arcdev);\n\nvoid free_arcdev(struct net_device *dev)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\n\t \n\tcancel_work_sync(&lp->reset_work);\n\tfree_netdev(dev);\n}\nEXPORT_SYMBOL(free_arcdev);\n\n \nint arcnet_open(struct net_device *dev)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tint count, newmtu, error;\n\n\tarc_printk(D_INIT, dev, \"opened.\");\n\n\tif (!try_module_get(lp->hw.owner))\n\t\treturn -ENODEV;\n\n\tif (BUGLVL(D_PROTO)) {\n\t\tarc_printk(D_PROTO, dev, \"protocol map (default is '%c'): \",\n\t\t\t   arc_proto_default->suffix);\n\t\tfor (count = 0; count < 256; count++)\n\t\t\tarc_cont(D_PROTO, \"%c\", arc_proto_map[count]->suffix);\n\t\tarc_cont(D_PROTO, \"\\n\");\n\t}\n\n\ttasklet_setup(&lp->reply_tasklet, arcnet_reply_tasklet);\n\n\tarc_printk(D_INIT, dev, \"arcnet_open: resetting card.\\n\");\n\n\t \n\terror = -ENODEV;\n\tif (lp->hw.reset(dev, 0) && lp->hw.reset(dev, 1))\n\t\tgoto out_module_put;\n\n\tnewmtu = choose_mtu();\n\tif (newmtu < dev->mtu)\n\t\tdev->mtu = newmtu;\n\n\tarc_printk(D_INIT, dev, \"arcnet_open: mtu: %d.\\n\", dev->mtu);\n\n\t \n\tmemset(lp->default_proto, 0, sizeof(lp->default_proto));\n\n\t \n\tfor (count = 0; count < 256; count++) {\n\t\tif (arc_proto_map[count] == arc_bcast_proto) {\n\t\t\tlp->default_proto[0] = count;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tatomic_set(&lp->buf_lock, 1);\n\n\tlp->next_buf = lp->first_free_buf = 0;\n\trelease_arcbuf(dev, 0);\n\trelease_arcbuf(dev, 1);\n\trelease_arcbuf(dev, 2);\n\trelease_arcbuf(dev, 3);\n\tlp->cur_tx = lp->next_tx = -1;\n\tlp->cur_rx = -1;\n\n\tlp->rfc1201.sequence = 1;\n\n\t \n\tif (lp->hw.open)\n\t\tlp->hw.open(dev);\n\n\tif (dev->dev_addr[0] == 0)\n\t\tarc_printk(D_NORMAL, dev, \"WARNING!  Station address 00 is reserved for broadcasts!\\n\");\n\telse if (dev->dev_addr[0] == 255)\n\t\tarc_printk(D_NORMAL, dev, \"WARNING!  Station address FF may confuse DOS networking programs!\\n\");\n\n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s\\n\", __FILE__, __LINE__, __func__);\n\tif (lp->hw.status(dev) & RESETflag) {\n\t\tarc_printk(D_DEBUG, dev, \"%s: %d: %s\\n\",\n\t\t\t   __FILE__, __LINE__, __func__);\n\t\tlp->hw.command(dev, CFLAGScmd | RESETclear);\n\t}\n\n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s\\n\", __FILE__, __LINE__, __func__);\n\t \n\tlp->hw.intmask(dev, 0);\n\tudelay(1);\t\t \n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s\\n\", __FILE__, __LINE__, __func__);\n\tlp->intmask = NORXflag | RECONflag;\n\tlp->hw.intmask(dev, lp->intmask);\n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s\\n\", __FILE__, __LINE__, __func__);\n\n\tnetif_carrier_off(dev);\n\tnetif_start_queue(dev);\n\tmod_timer(&lp->timer, jiffies + msecs_to_jiffies(1000));\n\n\tarcnet_led_event(dev, ARCNET_LED_EVENT_OPEN);\n\treturn 0;\n\n out_module_put:\n\tmodule_put(lp->hw.owner);\n\treturn error;\n}\nEXPORT_SYMBOL(arcnet_open);\n\n \nint arcnet_close(struct net_device *dev)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\n\tarcnet_led_event(dev, ARCNET_LED_EVENT_STOP);\n\tdel_timer_sync(&lp->timer);\n\n\tnetif_stop_queue(dev);\n\tnetif_carrier_off(dev);\n\n\ttasklet_kill(&lp->reply_tasklet);\n\n\t \n\tlp->hw.intmask(dev, 0);\n\tlp->hw.command(dev, NOTXcmd);\t \n\tlp->hw.command(dev, NORXcmd);\t \n\tmdelay(1);\n\n\t \n\tlp->hw.close(dev);\n\n\t \n\tlp->reset_in_progress = 0;\n\n\tmodule_put(lp->hw.owner);\n\treturn 0;\n}\nEXPORT_SYMBOL(arcnet_close);\n\nstatic int arcnet_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t unsigned short type, const void *daddr,\n\t\t\t const void *saddr, unsigned len)\n{\n\tconst struct arcnet_local *lp = netdev_priv(dev);\n\tuint8_t _daddr, proto_num;\n\tstruct ArcProto *proto;\n\n\tarc_printk(D_DURING, dev,\n\t\t   \"create header from %d to %d; protocol %d (%Xh); size %u.\\n\",\n\t\t   saddr ? *(uint8_t *)saddr : -1,\n\t\t   daddr ? *(uint8_t *)daddr : -1,\n\t\t   type, type, len);\n\n\tif (skb->len != 0 && len != skb->len)\n\t\tarc_printk(D_NORMAL, dev, \"arcnet_header: Yikes!  skb->len(%d) != len(%d)!\\n\",\n\t\t\t   skb->len, len);\n\n\t \n\tif (type == ETH_P_ARCNET) {\n\t\tproto = arc_raw_proto;\n\t\tarc_printk(D_DEBUG, dev, \"arc_raw_proto used. proto='%c'\\n\",\n\t\t\t   proto->suffix);\n\t\t_daddr = daddr ? *(uint8_t *)daddr : 0;\n\t} else if (!daddr) {\n\t\t \n\t\t*(uint16_t *)skb_push(skb, 2) = type;\n\t\t \n\t\tif (skb->network_header - skb->mac_header != 2)\n\t\t\tarc_printk(D_NORMAL, dev, \"arcnet_header: Yikes!  diff (%u) is not 2!\\n\",\n\t\t\t\t   skb->network_header - skb->mac_header);\n\t\treturn -2;\t \n\t} else {\n\t\t \n\t\t_daddr = *(uint8_t *)daddr;\n\t\tproto_num = lp->default_proto[_daddr];\n\t\tproto = arc_proto_map[proto_num];\n\t\tarc_printk(D_DURING, dev, \"building header for %02Xh using protocol '%c'\\n\",\n\t\t\t   proto_num, proto->suffix);\n\t\tif (proto == &arc_proto_null && arc_bcast_proto != proto) {\n\t\t\tarc_printk(D_DURING, dev, \"actually, let's use '%c' instead.\\n\",\n\t\t\t\t   arc_bcast_proto->suffix);\n\t\t\tproto = arc_bcast_proto;\n\t\t}\n\t}\n\treturn proto->build_header(skb, dev, type, _daddr);\n}\n\n \nnetdev_tx_t arcnet_send_packet(struct sk_buff *skb,\n\t\t\t       struct net_device *dev)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct archdr *pkt;\n\tstruct arc_rfc1201 *soft;\n\tstruct ArcProto *proto;\n\tint txbuf;\n\tunsigned long flags;\n\tint retval;\n\n\tarc_printk(D_DURING, dev,\n\t\t   \"transmit requested (status=%Xh, txbufs=%d/%d, len=%d, protocol %x)\\n\",\n\t\t   lp->hw.status(dev), lp->cur_tx, lp->next_tx, skb->len, skb->protocol);\n\n\tpkt = (struct archdr *)skb->data;\n\tsoft = &pkt->soft.rfc1201;\n\tproto = arc_proto_map[soft->proto];\n\n\tarc_printk(D_SKB_SIZE, dev, \"skb: transmitting %d bytes to %02X\\n\",\n\t\t   skb->len, pkt->hard.dest);\n\tif (BUGLVL(D_SKB))\n\t\tarcnet_dump_skb(dev, skb, \"tx\");\n\n\t \n\tif (skb->len - ARC_HDR_SIZE > XMTU && !proto->continue_tx) {\n\t\tarc_printk(D_NORMAL, dev, \"fixme: packet too large: compensating badly!\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\t \n\t}\n\n\t \n\tnetif_stop_queue(dev);\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tlp->hw.intmask(dev, 0);\n\tif (lp->next_tx == -1)\n\t\ttxbuf = get_arcbuf(dev);\n\telse\n\t\ttxbuf = -1;\n\n\tif (txbuf != -1) {\n\t\tlp->outgoing.skb = skb;\n\t\tif (proto->prepare_tx(dev, pkt, skb->len, txbuf) &&\n\t\t    !proto->ack_tx) {\n\t\t\t \n\t\t\tdev->stats.tx_bytes += skb->len;\n\t\t} else {\n\t\t\t \n\t\t\tlp->outgoing.proto = proto;\n\t\t\tlp->outgoing.skb = skb;\n\t\t\tlp->outgoing.pkt = pkt;\n\n\t\t\tif (proto->continue_tx &&\n\t\t\t    proto->continue_tx(dev, txbuf)) {\n\t\t\t\tarc_printk(D_NORMAL, dev,\n\t\t\t\t\t   \"bug! continue_tx finished the first time! (proto='%c')\\n\",\n\t\t\t\t\t   proto->suffix);\n\t\t\t}\n\t\t}\n\t\tretval = NETDEV_TX_OK;\n\t\tlp->next_tx = txbuf;\n\t} else {\n\t\tretval = NETDEV_TX_BUSY;\n\t}\n\n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s, status: %x\\n\",\n\t\t   __FILE__, __LINE__, __func__, lp->hw.status(dev));\n\t \n\tlp->hw.intmask(dev, 0);\n\n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s\\n\", __FILE__, __LINE__, __func__);\n\tlp->intmask |= TXFREEflag | EXCNAKflag;\n\tlp->hw.intmask(dev, lp->intmask);\n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s, status: %x\\n\",\n\t\t   __FILE__, __LINE__, __func__, lp->hw.status(dev));\n\n\tarcnet_led_event(dev, ARCNET_LED_EVENT_TX);\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\treturn retval;\t\t \n}\nEXPORT_SYMBOL(arcnet_send_packet);\n\n \nstatic int go_tx(struct net_device *dev)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\n\tarc_printk(D_DURING, dev, \"go_tx: status=%Xh, intmask=%Xh, next_tx=%d, cur_tx=%d\\n\",\n\t\t   lp->hw.status(dev), lp->intmask, lp->next_tx, lp->cur_tx);\n\n\tif (lp->cur_tx != -1 || lp->next_tx == -1)\n\t\treturn 0;\n\n\tif (BUGLVL(D_TX))\n\t\tarcnet_dump_packet(dev, lp->next_tx, \"go_tx\", 0);\n\n\tlp->cur_tx = lp->next_tx;\n\tlp->next_tx = -1;\n\n\t \n\tlp->hw.command(dev, TXcmd | (lp->cur_tx << 3));\n\n\tdev->stats.tx_packets++;\n\tlp->lasttrans_dest = lp->lastload_dest;\n\tlp->lastload_dest = 0;\n\tlp->excnak_pending = 0;\n\tlp->intmask |= TXFREEflag | EXCNAKflag;\n\n\treturn 1;\n}\n\n \nvoid arcnet_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tunsigned long flags;\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tint status = lp->hw.status(dev);\n\tchar *msg;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tif (status & TXFREEflag) {\t \n\t\tmsg = \" - missed IRQ?\";\n\t} else {\n\t\tmsg = \"\";\n\t\tdev->stats.tx_aborted_errors++;\n\t\tlp->timed_out = 1;\n\t\tlp->hw.command(dev, NOTXcmd | (lp->cur_tx << 3));\n\t}\n\tdev->stats.tx_errors++;\n\n\t \n\tlp->hw.intmask(dev, 0);\n\tlp->intmask |= TXFREEflag | EXCNAKflag;\n\tlp->hw.intmask(dev, lp->intmask);\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\tif (time_after(jiffies, lp->last_timeout + 10 * HZ)) {\n\t\tarc_printk(D_EXTRA, dev, \"tx timed out%s (status=%Xh, intmask=%Xh, dest=%02Xh)\\n\",\n\t\t\t   msg, status, lp->intmask, lp->lasttrans_dest);\n\t\tlp->last_timeout = jiffies;\n\t}\n\n\tif (lp->cur_tx == -1)\n\t\tnetif_wake_queue(dev);\n}\nEXPORT_SYMBOL(arcnet_timeout);\n\n \nirqreturn_t arcnet_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct arcnet_local *lp;\n\tint recbuf, status, diagstatus, didsomething, boguscount;\n\tunsigned long flags;\n\tint retval = IRQ_NONE;\n\n\tarc_printk(D_DURING, dev, \"\\n\");\n\n\tarc_printk(D_DURING, dev, \"in arcnet_interrupt\\n\");\n\n\tlp = netdev_priv(dev);\n\tBUG_ON(!lp);\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\tif (lp->reset_in_progress)\n\t\tgoto out;\n\n\t \n\tif (!netif_running(dev)) {\n\t\tif (lp->hw.status(dev) & RESETflag)\n\t\t\tlp->hw.command(dev, CFLAGScmd | RESETclear);\n\t\tlp->hw.intmask(dev, 0);\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t\treturn retval;\n\t}\n\n\tarc_printk(D_DURING, dev, \"in arcnet_inthandler (status=%Xh, intmask=%Xh)\\n\",\n\t\t   lp->hw.status(dev), lp->intmask);\n\n\tboguscount = 5;\n\tdo {\n\t\tstatus = lp->hw.status(dev);\n\t\tdiagstatus = (status >> 8) & 0xFF;\n\n\t\tarc_printk(D_DEBUG, dev, \"%s: %d: %s: status=%x\\n\",\n\t\t\t   __FILE__, __LINE__, __func__, status);\n\t\tdidsomething = 0;\n\n\t\t \n\t\tif (status & RESETflag) {\n\t\t\tarc_printk(D_NORMAL, dev, \"spurious reset (status=%Xh)\\n\",\n\t\t\t\t   status);\n\n\t\t\tlp->reset_in_progress = 1;\n\t\t\tnetif_stop_queue(dev);\n\t\t\tnetif_carrier_off(dev);\n\t\t\tschedule_work(&lp->reset_work);\n\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\trecbuf = -1;\n\t\tif (status & lp->intmask & NORXflag) {\n\t\t\trecbuf = lp->cur_rx;\n\t\t\tarc_printk(D_DURING, dev, \"Buffer #%d: receive irq (status=%Xh)\\n\",\n\t\t\t\t   recbuf, status);\n\n\t\t\tlp->cur_rx = get_arcbuf(dev);\n\t\t\tif (lp->cur_rx != -1) {\n\t\t\t\tarc_printk(D_DURING, dev, \"enabling receive to buffer #%d\\n\",\n\t\t\t\t\t   lp->cur_rx);\n\t\t\t\tlp->hw.command(dev, RXcmd | (lp->cur_rx << 3) | RXbcasts);\n\t\t\t}\n\t\t\tdidsomething++;\n\t\t}\n\n\t\tif ((diagstatus & EXCNAKflag)) {\n\t\t\tarc_printk(D_DURING, dev, \"EXCNAK IRQ (diagstat=%Xh)\\n\",\n\t\t\t\t   diagstatus);\n\n\t\t\tlp->hw.command(dev, NOTXcmd);       \n\t\t\tlp->excnak_pending = 1;\n\n\t\t\tlp->hw.command(dev, EXCNAKclear);\n\t\t\tlp->intmask &= ~(EXCNAKflag);\n\t\t\tdidsomething++;\n\t\t}\n\n\t\t \n\t\tif ((status & lp->intmask & TXFREEflag) || lp->timed_out) {\n\t\t\tint ackstatus;\n\t\t\tlp->intmask &= ~(TXFREEflag | EXCNAKflag);\n\n\t\t\tif (status & TXACKflag)\n\t\t\t\tackstatus = 2;\n\t\t\telse if (lp->excnak_pending)\n\t\t\t\tackstatus = 1;\n\t\t\telse\n\t\t\t\tackstatus = 0;\n\n\t\t\tarc_printk(D_DURING, dev, \"TX IRQ (stat=%Xh)\\n\",\n\t\t\t\t   status);\n\n\t\t\tif (lp->cur_tx != -1 && !lp->timed_out) {\n\t\t\t\tif (!(status & TXACKflag)) {\n\t\t\t\t\tif (lp->lasttrans_dest != 0) {\n\t\t\t\t\t\tarc_printk(D_EXTRA, dev,\n\t\t\t\t\t\t\t   \"transmit was not acknowledged! (status=%Xh, dest=%02Xh)\\n\",\n\t\t\t\t\t\t\t   status,\n\t\t\t\t\t\t\t   lp->lasttrans_dest);\n\t\t\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tarc_printk(D_DURING, dev,\n\t\t\t\t\t\t\t   \"broadcast was not acknowledged; that's normal (status=%Xh, dest=%02Xh)\\n\",\n\t\t\t\t\t\t\t   status,\n\t\t\t\t\t\t\t   lp->lasttrans_dest);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lp->outgoing.proto &&\n\t\t\t\t    lp->outgoing.proto->ack_tx) {\n\t\t\t\t\tlp->outgoing.proto\n\t\t\t\t\t\t->ack_tx(dev, ackstatus);\n\t\t\t\t}\n\t\t\t\tlp->reply_status = ackstatus;\n\t\t\t\ttasklet_hi_schedule(&lp->reply_tasklet);\n\t\t\t}\n\t\t\tif (lp->cur_tx != -1)\n\t\t\t\trelease_arcbuf(dev, lp->cur_tx);\n\n\t\t\tlp->cur_tx = -1;\n\t\t\tlp->timed_out = 0;\n\t\t\tdidsomething++;\n\n\t\t\t \n\t\t\tgo_tx(dev);\n\n\t\t\t \n\t\t\tif (lp->outgoing.proto &&\n\t\t\t    lp->outgoing.proto->continue_tx) {\n\t\t\t\tint txbuf = get_arcbuf(dev);\n\n\t\t\t\tif (txbuf != -1) {\n\t\t\t\t\tif (lp->outgoing.proto->continue_tx(dev, txbuf)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tdev->stats.tx_bytes += lp->outgoing.skb->len;\n\t\t\t\t\t\tif (!lp->outgoing.proto->ack_tx) {\n\t\t\t\t\t\t\tdev_kfree_skb_irq(lp->outgoing.skb);\n\t\t\t\t\t\t\tlp->outgoing.proto = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlp->next_tx = txbuf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (lp->cur_tx == -1)\n\t\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t\t \n\t\tif (recbuf != -1) {\n\t\t\tif (BUGLVL(D_RX))\n\t\t\t\tarcnet_dump_packet(dev, recbuf, \"rx irq\", 0);\n\n\t\t\tarcnet_rx(dev, recbuf);\n\t\t\trelease_arcbuf(dev, recbuf);\n\n\t\t\tdidsomething++;\n\t\t}\n\t\tif (status & lp->intmask & RECONflag) {\n\t\t\tlp->hw.command(dev, CFLAGScmd | CONFIGclear);\n\t\t\tdev->stats.tx_carrier_errors++;\n\n\t\t\tarc_printk(D_RECON, dev, \"Network reconfiguration detected (status=%Xh)\\n\",\n\t\t\t\t   status);\n\t\t\tif (netif_carrier_ok(dev)) {\n\t\t\t\tnetif_carrier_off(dev);\n\t\t\t\tnetdev_info(dev, \"link down\\n\");\n\t\t\t}\n\t\t\tmod_timer(&lp->timer, jiffies + msecs_to_jiffies(1000));\n\n\t\t\tarcnet_led_event(dev, ARCNET_LED_EVENT_RECON);\n\t\t\t \n\t\t\tif (diagstatus & 0x80)\n\t\t\t\tarc_printk(D_RECON, dev, \"Put out that recon myself\\n\");\n\n\t\t\t \n\t\t\tif (!lp->first_recon || !lp->last_recon ||\n\t\t\t    time_after(jiffies, lp->last_recon + HZ * 10)) {\n\t\t\t\tif (lp->network_down)\n\t\t\t\t\tarc_printk(D_NORMAL, dev, \"reconfiguration detected: cabling restored?\\n\");\n\t\t\t\tlp->first_recon = lp->last_recon = jiffies;\n\t\t\t\tlp->num_recons = lp->network_down = 0;\n\n\t\t\t\tarc_printk(D_DURING, dev, \"recon: clearing counters.\\n\");\n\t\t\t} else {\t \n\t\t\t\tlp->last_recon = jiffies;\n\t\t\t\tlp->num_recons++;\n\n\t\t\t\tarc_printk(D_DURING, dev, \"recon: counter=%d, time=%lds, net=%d\\n\",\n\t\t\t\t\t   lp->num_recons,\n\t\t\t\t\t   (lp->last_recon - lp->first_recon) / HZ,\n\t\t\t\t\t   lp->network_down);\n\n\t\t\t\t \n\t\t\t\tif (!lp->network_down &&\n\t\t\t\t    (lp->last_recon - lp->first_recon) <= HZ * 60 &&\n\t\t\t\t    lp->num_recons >= RECON_THRESHOLD) {\n\t\t\t\t\tlp->network_down = 1;\n\t\t\t\t\tarc_printk(D_NORMAL, dev, \"many reconfigurations detected: cabling problem?\\n\");\n\t\t\t\t} else if (!lp->network_down &&\n\t\t\t\t\t   lp->last_recon - lp->first_recon > HZ * 60) {\n\t\t\t\t\t \n\t\t\t\t\tlp->first_recon = lp->last_recon;\n\t\t\t\t\tlp->num_recons = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (lp->network_down &&\n\t\t\t   time_after(jiffies, lp->last_recon + HZ * 10)) {\n\t\t\tif (lp->network_down)\n\t\t\t\tarc_printk(D_NORMAL, dev, \"cabling restored?\\n\");\n\t\t\tlp->first_recon = lp->last_recon = 0;\n\t\t\tlp->num_recons = lp->network_down = 0;\n\n\t\t\tarc_printk(D_DURING, dev, \"not recon: clearing counters anyway.\\n\");\n\t\t\tnetif_carrier_on(dev);\n\t\t}\n\n\t\tif (didsomething)\n\t\t\tretval |= IRQ_HANDLED;\n\t} while (--boguscount && didsomething);\n\n\tarc_printk(D_DURING, dev, \"arcnet_interrupt complete (status=%Xh, count=%d)\\n\",\n\t\t   lp->hw.status(dev), boguscount);\n\tarc_printk(D_DURING, dev, \"\\n\");\n\n\tlp->hw.intmask(dev, 0);\n\tudelay(1);\n\tlp->hw.intmask(dev, lp->intmask);\n\nout:\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\treturn retval;\n}\nEXPORT_SYMBOL(arcnet_interrupt);\n\n \nstatic void arcnet_rx(struct net_device *dev, int bufnum)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tunion {\n\t\tstruct archdr pkt;\n\t\tchar buf[512];\n\t} rxdata;\n\tstruct arc_rfc1201 *soft;\n\tint length, ofs;\n\n\tsoft = &rxdata.pkt.soft.rfc1201;\n\n\tlp->hw.copy_from_card(dev, bufnum, 0, &rxdata.pkt, ARC_HDR_SIZE);\n\tif (rxdata.pkt.hard.offset[0]) {\n\t\tofs = rxdata.pkt.hard.offset[0];\n\t\tlength = 256 - ofs;\n\t} else {\n\t\tofs = rxdata.pkt.hard.offset[1];\n\t\tlength = 512 - ofs;\n\t}\n\n\t \n\tif (sizeof(rxdata.pkt.soft) <= length) {\n\t\tlp->hw.copy_from_card(dev, bufnum, ofs, soft, sizeof(rxdata.pkt.soft));\n\t} else {\n\t\tmemset(&rxdata.pkt.soft, 0, sizeof(rxdata.pkt.soft));\n\t\tlp->hw.copy_from_card(dev, bufnum, ofs, soft, length);\n\t}\n\n\tarc_printk(D_DURING, dev, \"Buffer #%d: received packet from %02Xh to %02Xh (%d+4 bytes)\\n\",\n\t\t   bufnum, rxdata.pkt.hard.source, rxdata.pkt.hard.dest, length);\n\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += length + ARC_HDR_SIZE;\n\n\t \n\tif (arc_proto_map[soft->proto]->is_ip) {\n\t\tif (BUGLVL(D_PROTO)) {\n\t\t\tstruct ArcProto\n\t\t\t*oldp = arc_proto_map[lp->default_proto[rxdata.pkt.hard.source]],\n\t\t\t*newp = arc_proto_map[soft->proto];\n\n\t\t\tif (oldp != newp) {\n\t\t\t\tarc_printk(D_PROTO, dev,\n\t\t\t\t\t   \"got protocol %02Xh; encap for host %02Xh is now '%c' (was '%c')\\n\",\n\t\t\t\t\t   soft->proto, rxdata.pkt.hard.source,\n\t\t\t\t\t   newp->suffix, oldp->suffix);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tlp->default_proto[0] = soft->proto;\n\n\t\t \n\t\tlp->default_proto[rxdata.pkt.hard.source] = soft->proto;\n\t}\n\t \n\tarc_proto_map[soft->proto]->rx(dev, bufnum, &rxdata.pkt, length);\n}\n\nstatic void null_rx(struct net_device *dev, int bufnum,\n\t\t    struct archdr *pkthdr, int length)\n{\n\tarc_printk(D_PROTO, dev,\n\t\t   \"rx: don't know how to deal with proto %02Xh from host %02Xh.\\n\",\n\t\t   pkthdr->soft.rfc1201.proto, pkthdr->hard.source);\n}\n\nstatic int null_build_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     unsigned short type, uint8_t daddr)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\n\tarc_printk(D_PROTO, dev,\n\t\t   \"tx: can't build header for encap %02Xh; load a protocol driver.\\n\",\n\t\t   lp->default_proto[daddr]);\n\n\t \n\treturn 0;\n}\n\n \nstatic int null_prepare_tx(struct net_device *dev, struct archdr *pkt,\n\t\t\t   int length, int bufnum)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct arc_hardware newpkt;\n\n\tarc_printk(D_PROTO, dev, \"tx: no encap for this host; load a protocol driver.\\n\");\n\n\t \n\tnewpkt.source = newpkt.dest = dev->dev_addr[0];\n\n\t \n\tnewpkt.offset[0] = 0xFF;\n\n\tlp->hw.copy_to_card(dev, bufnum, 0, &newpkt, ARC_HDR_SIZE);\n\n\treturn 1;\t\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}