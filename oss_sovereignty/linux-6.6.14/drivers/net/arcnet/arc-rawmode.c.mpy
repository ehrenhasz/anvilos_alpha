{
  "module_name": "arc-rawmode.c",
  "hash_id": "11130545104dd30fe22a06ebeeec15898f6320377451b61330773908fb7fdbec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/arcnet/arc-rawmode.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"arcnet:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/if_arp.h>\n#include <net/arp.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include \"arcdevice.h\"\n\n \nstatic void rx(struct net_device *dev, int bufnum,\n\t       struct archdr *pkthdr, int length)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tstruct archdr *pkt = pkthdr;\n\tint ofs;\n\n\tarc_printk(D_DURING, dev, \"it's a raw packet (length=%d)\\n\", length);\n\n\tif (length > MTU)\n\t\tofs = 512 - length;\n\telse\n\t\tofs = 256 - length;\n\n\tskb = alloc_skb(length + ARC_HDR_SIZE, GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\tskb_put(skb, length + ARC_HDR_SIZE);\n\tskb->dev = dev;\n\n\tpkt = (struct archdr *)skb->data;\n\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, ARC_HDR_SIZE);\n\n\t \n\tmemcpy(pkt, pkthdr, sizeof(struct archdr));\n\tif (length > sizeof(pkt->soft))\n\t\tlp->hw.copy_from_card(dev, bufnum, ofs + sizeof(pkt->soft),\n\t\t\t\t      pkt->soft.raw + sizeof(pkt->soft),\n\t\t\t\t      length - sizeof(pkt->soft));\n\n\tif (BUGLVL(D_SKB))\n\t\tarcnet_dump_skb(dev, skb, \"rx\");\n\n\tskb->protocol = cpu_to_be16(ETH_P_ARCNET);\n\tnetif_rx(skb);\n}\n\n \nstatic int build_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\tunsigned short type, uint8_t daddr)\n{\n\tint hdr_size = ARC_HDR_SIZE;\n\tstruct archdr *pkt = skb_push(skb, hdr_size);\n\n\t \n\tpkt->hard.source = *dev->dev_addr;\n\n\t \n\n\tif (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {\n\t\t \n\t\tpkt->hard.dest = 0;\n\t\treturn hdr_size;\n\t}\n\t \n\tpkt->hard.dest = daddr;\n\n\treturn hdr_size;\t \n}\n\nstatic int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,\n\t\t      int bufnum)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct arc_hardware *hard = &pkt->hard;\n\tint ofs;\n\n\tarc_printk(D_DURING, dev, \"prepare_tx: txbufs=%d/%d/%d\\n\",\n\t\t   lp->next_tx, lp->cur_tx, bufnum);\n\n\t \n\tlength -= ARC_HDR_SIZE;\n\n\tif (length > XMTU) {\n\t\t \n\t\tarc_printk(D_NORMAL, dev, \"Bug!  prepare_tx with size %d (> %d)\\n\",\n\t\t\t   length, XMTU);\n\t\tlength = XMTU;\n\t}\n\tif (length >= MinTU) {\n\t\thard->offset[0] = 0;\n\t\thard->offset[1] = ofs = 512 - length;\n\t} else if (length > MTU) {\n\t\thard->offset[0] = 0;\n\t\thard->offset[1] = ofs = 512 - length - 3;\n\t} else {\n\t\thard->offset[0] = ofs = 256 - length;\n\t}\n\n\tarc_printk(D_DURING, dev, \"prepare_tx: length=%d ofs=%d\\n\",\n\t\t   length, ofs);\n\n\tlp->hw.copy_to_card(dev, bufnum, 0, hard, ARC_HDR_SIZE);\n\tlp->hw.copy_to_card(dev, bufnum, ofs, &pkt->soft, length);\n\n\tlp->lastload_dest = hard->dest;\n\n\treturn 1;\t\t \n}\n\nstatic struct ArcProto rawmode_proto = {\n\t.suffix\t\t= 'r',\n\t.mtu\t\t= XMTU,\n\t.rx\t\t= rx,\n\t.build_header\t= build_header,\n\t.prepare_tx\t= prepare_tx,\n\t.continue_tx    = NULL,\n\t.ack_tx         = NULL\n};\n\nstatic int __init arcnet_raw_init(void)\n{\n\tint count;\n\n\tpr_info(\"raw mode (`r') encapsulation support loaded\\n\");\n\n\tfor (count = 0; count < 256; count++)\n\t\tif (arc_proto_map[count] == arc_proto_default)\n\t\t\tarc_proto_map[count] = &rawmode_proto;\n\n\t \n\tif (arc_bcast_proto == arc_proto_default)\n\t\tarc_bcast_proto = &rawmode_proto;\n\n\tarc_proto_default = &rawmode_proto;\n\treturn 0;\n}\n\nstatic void __exit arcnet_raw_exit(void)\n{\n\tarcnet_unregister_proto(&rawmode_proto);\n}\n\nmodule_init(arcnet_raw_init);\nmodule_exit(arcnet_raw_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}