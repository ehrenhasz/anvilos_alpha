{
  "module_name": "com20020.c",
  "hash_id": "18bc88bf6ef8a2371deb944dcbd7d97b72ff77bd223d5aa2f2705375fab1c3e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/arcnet/com20020.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"arcnet:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n\n#include \"arcdevice.h\"\n#include \"com20020.h\"\n\nstatic const char * const clockrates[] = {\n\t\"XXXXXXX\", \"XXXXXXXX\", \"XXXXXX\", \"2.5 Mb/s\",\n\t\"1.25Mb/s\", \"625 Kb/s\", \"312.5 Kb/s\", \"156.25 Kb/s\",\n\t\"Reserved\", \"Reserved\", \"Reserved\"\n};\n\nstatic void com20020_command(struct net_device *dev, int command);\nstatic int com20020_status(struct net_device *dev);\nstatic void com20020_setmask(struct net_device *dev, int mask);\nstatic int com20020_reset(struct net_device *dev, int really_reset);\nstatic void com20020_copy_to_card(struct net_device *dev, int bufnum,\n\t\t\t\t  int offset, void *buf, int count);\nstatic void com20020_copy_from_card(struct net_device *dev, int bufnum,\n\t\t\t\t    int offset, void *buf, int count);\nstatic void com20020_set_mc_list(struct net_device *dev);\nstatic void com20020_close(struct net_device *);\n\nstatic void com20020_copy_from_card(struct net_device *dev, int bufnum,\n\t\t\t\t    int offset, void *buf, int count)\n{\n\tint ioaddr = dev->base_addr, ofs = 512 * bufnum + offset;\n\n\t \n\tarcnet_outb((ofs >> 8) | RDDATAflag | AUTOINCflag,\n\t\t    ioaddr, COM20020_REG_W_ADDR_HI);\n\tarcnet_outb(ofs & 0xff, ioaddr, COM20020_REG_W_ADDR_LO);\n\n\t \n\tTIME(dev, \"insb\", count,\n\t     arcnet_insb(ioaddr, COM20020_REG_RW_MEMDATA, buf, count));\n}\n\nstatic void com20020_copy_to_card(struct net_device *dev, int bufnum,\n\t\t\t\t  int offset, void *buf, int count)\n{\n\tint ioaddr = dev->base_addr, ofs = 512 * bufnum + offset;\n\n\t \n\tarcnet_outb((ofs >> 8) | AUTOINCflag, ioaddr, COM20020_REG_W_ADDR_HI);\n\tarcnet_outb(ofs & 0xff, ioaddr, COM20020_REG_W_ADDR_LO);\n\n\t \n\tTIME(dev, \"outsb\", count,\n\t     arcnet_outsb(ioaddr, COM20020_REG_RW_MEMDATA, buf, count));\n}\n\n \nint com20020_check(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr, status;\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\n\tarcnet_outb(XTOcfg(3) | RESETcfg, ioaddr, COM20020_REG_W_CONFIG);\n\tudelay(5);\n\tarcnet_outb(XTOcfg(3), ioaddr, COM20020_REG_W_CONFIG);\n\tmdelay(RESETtime);\n\n\tlp->setup = lp->clockm ? 0 : (lp->clockp << 1);\n\tlp->setup2 = (lp->clockm << 4) | 8;\n\n\t \n\t \n\tlp->setup = lp->setup | P1MODE;\n\n\tcom20020_set_subaddress(lp, ioaddr, SUB_SETUP1);\n\tarcnet_outb(lp->setup, ioaddr, COM20020_REG_W_XREG);\n\n\tif (lp->clockm != 0) {\n\t\tcom20020_set_subaddress(lp, ioaddr, SUB_SETUP2);\n\t\tarcnet_outb(lp->setup2, ioaddr, COM20020_REG_W_XREG);\n\n\t\t \n\t\tmdelay(1);\n\t\tarcnet_outb(STARTIOcmd, ioaddr, COM20020_REG_W_COMMAND);\n\t}\n\n\tlp->config = (lp->timeout << 3) | (lp->backplane << 2) | SUB_NODE;\n\t \n\tarcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\n\tarcnet_outb(0x42, ioaddr, COM20020_REG_W_XREG);\n\n\tstatus = arcnet_inb(ioaddr, COM20020_REG_R_STATUS);\n\n\tif ((status & 0x99) != (NORXflag | TXFREEflag | RESETflag)) {\n\t\tarc_printk(D_NORMAL, dev, \"status invalid (%Xh).\\n\", status);\n\t\treturn -ENODEV;\n\t}\n\tarc_printk(D_INIT_REASONS, dev, \"status after reset: %X\\n\", status);\n\n\tarcnet_outb(CFLAGScmd | RESETclear | CONFIGclear,\n\t\t    ioaddr, COM20020_REG_W_COMMAND);\n\tstatus = arcnet_inb(ioaddr, COM20020_REG_R_STATUS);\n\tarc_printk(D_INIT_REASONS, dev, \"status after reset acknowledged: %X\\n\",\n\t\t   status);\n\n\t \n\tarcnet_outb(0 | RDDATAflag | AUTOINCflag,\n\t\t    ioaddr, COM20020_REG_W_ADDR_HI);\n\tarcnet_outb(0, ioaddr, COM20020_REG_W_ADDR_LO);\n\n\tstatus = arcnet_inb(ioaddr, COM20020_REG_RW_MEMDATA);\n\tif (status != TESTvalue) {\n\t\tarc_printk(D_NORMAL, dev, \"Signature byte not found (%02Xh != D1h).\\n\",\n\t\t\t   status);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int com20020_set_hwaddr(struct net_device *dev, void *addr)\n{\n\tint ioaddr = dev->base_addr;\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct sockaddr *hwaddr = addr;\n\n\tdev_addr_set(dev, hwaddr->sa_data);\n\tcom20020_set_subaddress(lp, ioaddr, SUB_NODE);\n\tarcnet_outb(dev->dev_addr[0], ioaddr, COM20020_REG_W_XREG);\n\n\treturn 0;\n}\n\nstatic int com20020_netdev_open(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr;\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\n\tlp->config |= TXENcfg;\n\tarcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\n\n\treturn arcnet_open(dev);\n}\n\nstatic int com20020_netdev_close(struct net_device *dev)\n{\n\tint ioaddr = dev->base_addr;\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\n\tarcnet_close(dev);\n\n\t \n\tlp->config &= ~TXENcfg;\n\tarcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\n\treturn 0;\n}\n\nconst struct net_device_ops com20020_netdev_ops = {\n\t.ndo_open\t= com20020_netdev_open,\n\t.ndo_stop\t= com20020_netdev_close,\n\t.ndo_start_xmit = arcnet_send_packet,\n\t.ndo_tx_timeout = arcnet_timeout,\n\t.ndo_set_mac_address = com20020_set_hwaddr,\n\t.ndo_set_rx_mode = com20020_set_mc_list,\n};\n\n \nint com20020_found(struct net_device *dev, int shared)\n{\n\tstruct arcnet_local *lp;\n\tint ioaddr = dev->base_addr;\n\n\t \n\n\tlp = netdev_priv(dev);\n\n\tlp->hw.owner = THIS_MODULE;\n\tlp->hw.command = com20020_command;\n\tlp->hw.status = com20020_status;\n\tlp->hw.intmask = com20020_setmask;\n\tlp->hw.reset = com20020_reset;\n\tlp->hw.copy_to_card = com20020_copy_to_card;\n\tlp->hw.copy_from_card = com20020_copy_from_card;\n\tlp->hw.close = com20020_close;\n\n\t \n\tif (!dev->dev_addr[0])\n\t\tarcnet_set_addr(dev, arcnet_inb(ioaddr, 8));\n\n\tcom20020_set_subaddress(lp, ioaddr, SUB_SETUP1);\n\tarcnet_outb(lp->setup, ioaddr, COM20020_REG_W_XREG);\n\n\tif (lp->card_flags & ARC_CAN_10MBIT) {\n\t\tcom20020_set_subaddress(lp, ioaddr, SUB_SETUP2);\n\t\tarcnet_outb(lp->setup2, ioaddr, COM20020_REG_W_XREG);\n\n\t\t \n\t\tmdelay(1);\n\t\tarcnet_outb(STARTIOcmd, ioaddr, COM20020_REG_W_COMMAND);\n\t}\n\n\tlp->config = (lp->timeout << 3) | (lp->backplane << 2) | SUB_NODE;\n\t \n\tarcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\n\tarcnet_outb(dev->dev_addr[0], ioaddr, COM20020_REG_W_XREG);\n\n\t \n\tif (request_irq(dev->irq, arcnet_interrupt, shared,\n\t\t\t\"arcnet (COM20020)\", dev)) {\n\t\tarc_printk(D_NORMAL, dev, \"Can't get IRQ %d!\\n\", dev->irq);\n\t\treturn -ENODEV;\n\t}\n\n\tarc_printk(D_NORMAL, dev, \"%s: station %02Xh found at %03lXh, IRQ %d.\\n\",\n\t\t   lp->card_name, dev->dev_addr[0], dev->base_addr, dev->irq);\n\n\tif (lp->backplane)\n\t\tarc_printk(D_NORMAL, dev, \"Using backplane mode.\\n\");\n\n\tif (lp->timeout != 3)\n\t\tarc_printk(D_NORMAL, dev, \"Using extended timeout value of %d\\n\",\n\t\t\t   lp->timeout);\n\n\tarc_printk(D_NORMAL, dev, \"Using CKP %d - data rate %s\\n\",\n\t\t   lp->setup >> 1,\n\t\t   clockrates[3 -\n\t\t\t      ((lp->setup2 & 0xF0) >> 4) +\n\t\t\t      ((lp->setup & 0x0F) >> 1)]);\n\t\t\t \n\n\tif (register_netdev(dev)) {\n\t\tfree_irq(dev->irq, dev);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int com20020_reset(struct net_device *dev, int really_reset)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tu_int ioaddr = dev->base_addr;\n\tu_char inbyte;\n\n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s: dev: %p, lp: %p, dev->name: %s\\n\",\n\t\t   __FILE__, __LINE__, __func__, dev, lp, dev->name);\n\tarc_printk(D_INIT, dev, \"Resetting %s (status=%02Xh)\\n\",\n\t\t   dev->name, arcnet_inb(ioaddr, COM20020_REG_R_STATUS));\n\n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s\\n\", __FILE__, __LINE__, __func__);\n\tlp->config |= (lp->timeout << 3) | (lp->backplane << 2);\n\t \n\tarcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s\\n\", __FILE__, __LINE__, __func__);\n\n\tif (really_reset) {\n\t\t \n\t\tarcnet_outb(lp->config | RESETcfg, ioaddr, COM20020_REG_W_CONFIG);\n\t\tudelay(5);\n\t\tarcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\n\t\tmdelay(RESETtime * 2);\n\t\t\t\t \n\t}\n\t \n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s\\n\", __FILE__, __LINE__, __func__);\n\tarcnet_outb(CFLAGScmd | RESETclear | CONFIGclear,\n\t\t    ioaddr, COM20020_REG_W_COMMAND);\n\n\t \n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s\\n\", __FILE__, __LINE__, __func__);\n\n\tcom20020_copy_from_card(dev, 0, 0, &inbyte, 1);\n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s\\n\", __FILE__, __LINE__, __func__);\n\tif (inbyte != TESTvalue) {\n\t\tarc_printk(D_DEBUG, dev, \"%s: %d: %s\\n\",\n\t\t\t   __FILE__, __LINE__, __func__);\n\t\tarc_printk(D_NORMAL, dev, \"reset failed: TESTvalue not present.\\n\");\n\t\treturn 1;\n\t}\n\t \n\tarcnet_outb(CONFIGcmd | EXTconf, ioaddr, COM20020_REG_W_COMMAND);\n\n\tarc_printk(D_DEBUG, dev, \"%s: %d: %s\\n\", __FILE__, __LINE__, __func__);\n\n\t \n\treturn 0;\n}\n\nstatic void com20020_setmask(struct net_device *dev, int mask)\n{\n\tu_int ioaddr = dev->base_addr;\n\n\tarc_printk(D_DURING, dev, \"Setting mask to %x at %x\\n\", mask, ioaddr);\n\tarcnet_outb(mask, ioaddr, COM20020_REG_W_INTMASK);\n}\n\nstatic void com20020_command(struct net_device *dev, int cmd)\n{\n\tu_int ioaddr = dev->base_addr;\n\n\tarcnet_outb(cmd, ioaddr, COM20020_REG_W_COMMAND);\n}\n\nstatic int com20020_status(struct net_device *dev)\n{\n\tu_int ioaddr = dev->base_addr;\n\n\treturn arcnet_inb(ioaddr, COM20020_REG_R_STATUS) +\n\t\t(arcnet_inb(ioaddr, COM20020_REG_R_DIAGSTAT) << 8);\n}\n\nstatic void com20020_close(struct net_device *dev)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tint ioaddr = dev->base_addr;\n\n\t \n\tlp->config &= ~TXENcfg;\n\tarcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\n}\n\n \nstatic void com20020_set_mc_list(struct net_device *dev)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tint ioaddr = dev->base_addr;\n\n\tif ((dev->flags & IFF_PROMISC) && (dev->flags & IFF_UP)) {\n\t\t \n\t\tif (!(lp->setup & PROMISCset))\n\t\t\tarc_printk(D_NORMAL, dev, \"Setting promiscuous flag...\\n\");\n\t\tcom20020_set_subaddress(lp, ioaddr, SUB_SETUP1);\n\t\tlp->setup |= PROMISCset;\n\t\tarcnet_outb(lp->setup, ioaddr, COM20020_REG_W_XREG);\n\t} else {\n\t\t \n\t\tif ((lp->setup & PROMISCset))\n\t\t\tarc_printk(D_NORMAL, dev, \"Resetting promiscuous flag...\\n\");\n\t\tcom20020_set_subaddress(lp, ioaddr, SUB_SETUP1);\n\t\tlp->setup &= ~PROMISCset;\n\t\tarcnet_outb(lp->setup, ioaddr, COM20020_REG_W_XREG);\n\t}\n}\n\n#if defined(CONFIG_ARCNET_COM20020_PCI_MODULE) || \\\n    defined(CONFIG_ARCNET_COM20020_ISA_MODULE) || \\\n    defined(CONFIG_ARCNET_COM20020_CS_MODULE)\nEXPORT_SYMBOL(com20020_check);\nEXPORT_SYMBOL(com20020_found);\nEXPORT_SYMBOL(com20020_netdev_ops);\n#endif\n\nMODULE_LICENSE(\"GPL\");\n\n#ifdef MODULE\n\nstatic int __init com20020_module_init(void)\n{\n\tif (BUGLVL(D_NORMAL))\n\t\tpr_info(\"%s\\n\", \"COM20020 chipset support (by David Woodhouse et al.)\");\n\treturn 0;\n}\n\nstatic void __exit com20020_module_exit(void)\n{\n}\nmodule_init(com20020_module_init);\nmodule_exit(com20020_module_exit);\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}