{
  "module_name": "capmode.c",
  "hash_id": "fb0f0fe7614c40cbc4223f8c5b567b2000205633e868d4ba8893bb712633165d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/arcnet/capmode.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"arcnet:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/if_arp.h>\n#include <net/arp.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n\n#include \"arcdevice.h\"\n\n \nstatic void rx(struct net_device *dev, int bufnum,\n\t       struct archdr *pkthdr, int length)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tstruct archdr *pkt;\n\tchar *pktbuf, *pkthdrbuf;\n\tint ofs;\n\n\tarc_printk(D_DURING, dev, \"it's a raw(cap) packet (length=%d)\\n\",\n\t\t   length);\n\n\tif (length >= MinTU)\n\t\tofs = 512 - length;\n\telse\n\t\tofs = 256 - length;\n\n\tskb = alloc_skb(length + ARC_HDR_SIZE + sizeof(int), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\tskb_put(skb, length + ARC_HDR_SIZE + sizeof(int));\n\tskb->dev = dev;\n\tskb_reset_mac_header(skb);\n\tpkt = (struct archdr *)skb_mac_header(skb);\n\tskb_pull(skb, ARC_HDR_SIZE);\n\n\t \n\tpktbuf = (char *)pkt;\n\tpkthdrbuf = (char *)pkthdr;\n\tmemcpy(pktbuf, pkthdrbuf, ARC_HDR_SIZE + sizeof(pkt->soft.cap.proto));\n\tmemcpy(pktbuf + ARC_HDR_SIZE + sizeof(pkt->soft.cap.proto) + sizeof(int),\n\t       pkthdrbuf + ARC_HDR_SIZE + sizeof(pkt->soft.cap.proto),\n\t       sizeof(struct archdr) - ARC_HDR_SIZE - sizeof(pkt->soft.cap.proto));\n\n\tif (length > sizeof(pkt->soft))\n\t\tlp->hw.copy_from_card(dev, bufnum, ofs + sizeof(pkt->soft),\n\t\t\t\t      pkt->soft.raw + sizeof(pkt->soft)\n\t\t\t\t      + sizeof(int),\n\t\t\t\t      length - sizeof(pkt->soft));\n\n\tif (BUGLVL(D_SKB))\n\t\tarcnet_dump_skb(dev, skb, \"rx\");\n\n\tskb->protocol = cpu_to_be16(ETH_P_ARCNET);\n\tnetif_rx(skb);\n}\n\n \nstatic int build_header(struct sk_buff *skb,\n\t\t\tstruct net_device *dev,\n\t\t\tunsigned short type,\n\t\t\tuint8_t daddr)\n{\n\tint hdr_size = ARC_HDR_SIZE;\n\tstruct archdr *pkt = skb_push(skb, hdr_size);\n\n\tarc_printk(D_PROTO, dev, \"Preparing header for cap packet %x.\\n\",\n\t\t   *((int *)&pkt->soft.cap.cookie[0]));\n\n\t \n\tpkt->hard.source = *dev->dev_addr;\n\n\t \n\n\tif (dev->flags & (IFF_LOOPBACK | IFF_NOARP)) {\n\t\t \n\t\tpkt->hard.dest = 0;\n\t\treturn hdr_size;\n\t}\n\t \n\tpkt->hard.dest = daddr;\n\n\treturn hdr_size;\t \n}\n\nstatic int prepare_tx(struct net_device *dev, struct archdr *pkt, int length,\n\t\t      int bufnum)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct arc_hardware *hard = &pkt->hard;\n\tint ofs;\n\n\t \n\tlength -= ARC_HDR_SIZE;\n\t \n\tlength -= sizeof(int);\n\n\tarc_printk(D_DURING, dev, \"prepare_tx: txbufs=%d/%d/%d\\n\",\n\t\t   lp->next_tx, lp->cur_tx, bufnum);\n\n\tarc_printk(D_PROTO, dev, \"Sending for cap packet %x.\\n\",\n\t\t   *((int *)&pkt->soft.cap.cookie[0]));\n\n\tif (length > XMTU) {\n\t\t \n\t\tarc_printk(D_NORMAL, dev, \"Bug!  prepare_tx with size %d (> %d)\\n\",\n\t\t\t   length, XMTU);\n\t\tlength = XMTU;\n\t}\n\tif (length > MinTU) {\n\t\thard->offset[0] = 0;\n\t\thard->offset[1] = ofs = 512 - length;\n\t} else if (length > MTU) {\n\t\thard->offset[0] = 0;\n\t\thard->offset[1] = ofs = 512 - length - 3;\n\t} else {\n\t\thard->offset[0] = ofs = 256 - length;\n\t}\n\n\tarc_printk(D_DURING, dev, \"prepare_tx: length=%d ofs=%d\\n\",\n\t\t   length, ofs);\n\n\t \n\tlp->hw.copy_to_card(dev, bufnum, 0, hard, ARC_HDR_SIZE);\n\tlp->hw.copy_to_card(dev, bufnum, ofs, &pkt->soft.cap.proto,\n\t\t\t    sizeof(pkt->soft.cap.proto));\n\n\t \n\tlp->hw.copy_to_card(dev, bufnum, ofs + 1,\n\t\t\t    ((unsigned char *)&pkt->soft.cap.mes), length - 1);\n\n\tlp->lastload_dest = hard->dest;\n\n\treturn 1;\t \n}\n\nstatic int ack_tx(struct net_device *dev, int acked)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tstruct sk_buff *ackskb;\n\tstruct archdr *ackpkt;\n\tint length = sizeof(struct arc_cap);\n\n\tarc_printk(D_DURING, dev, \"capmode: ack_tx: protocol: %x: result: %d\\n\",\n\t\t   lp->outgoing.skb->protocol, acked);\n\n\tif (BUGLVL(D_SKB))\n\t\tarcnet_dump_skb(dev, lp->outgoing.skb, \"ack_tx\");\n\n\t \n\tackskb = alloc_skb(length + ARC_HDR_SIZE, GFP_ATOMIC);\n\tif (!ackskb)\n\t\tgoto free_outskb;\n\n\tskb_put(ackskb, length + ARC_HDR_SIZE);\n\tackskb->dev = dev;\n\n\tskb_reset_mac_header(ackskb);\n\tackpkt = (struct archdr *)skb_mac_header(ackskb);\n\t \n\n\tskb_copy_from_linear_data(lp->outgoing.skb, ackpkt,\n\t\t\t\t  ARC_HDR_SIZE + sizeof(struct arc_cap));\n\tackpkt->soft.cap.proto = 0;  \n\tackpkt->soft.cap.mes.ack = acked;\n\n\tarc_printk(D_PROTO, dev, \"Acknowledge for cap packet %x.\\n\",\n\t\t   *((int *)&ackpkt->soft.cap.cookie[0]));\n\n\tackskb->protocol = cpu_to_be16(ETH_P_ARCNET);\n\n\tif (BUGLVL(D_SKB))\n\t\tarcnet_dump_skb(dev, ackskb, \"ack_tx_recv\");\n\tnetif_rx(ackskb);\n\nfree_outskb:\n\tdev_kfree_skb_irq(lp->outgoing.skb);\n\tlp->outgoing.proto = NULL;\n\t\t\t \n\n\treturn 0;\n}\n\nstatic struct ArcProto capmode_proto = {\n\t.suffix\t\t= 'r',\n\t.mtu\t\t= XMTU,\n\t.rx\t\t= rx,\n\t.build_header\t= build_header,\n\t.prepare_tx\t= prepare_tx,\n\t.ack_tx\t\t= ack_tx\n};\n\nstatic int __init capmode_module_init(void)\n{\n\tint count;\n\n\tpr_info(\"cap mode (`c') encapsulation support loaded\\n\");\n\n\tfor (count = 1; count <= 8; count++)\n\t\tif (arc_proto_map[count] == arc_proto_default)\n\t\t\tarc_proto_map[count] = &capmode_proto;\n\n\t \n\tif (arc_bcast_proto == arc_proto_default)\n\t\tarc_bcast_proto = &capmode_proto;\n\n\tarc_proto_default = &capmode_proto;\n\tarc_raw_proto = &capmode_proto;\n\n\treturn 0;\n}\n\nstatic void __exit capmode_module_exit(void)\n{\n\tarcnet_unregister_proto(&capmode_proto);\n}\nmodule_init(capmode_module_init);\nmodule_exit(capmode_module_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}