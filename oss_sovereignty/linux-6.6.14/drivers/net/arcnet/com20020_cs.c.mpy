{
  "module_name": "com20020_cs.c",
  "hash_id": "5e0f593a9a95fc4ab385f7e1122430e0503546585bc86ea286bebb5b2ace90b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/arcnet/com20020_cs.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"arcnet:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/io.h>\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n\n#include \"arcdevice.h\"\n#include \"com20020.h\"\n\nstatic void regdump(struct net_device *dev)\n{\n#ifdef DEBUG\n\tint ioaddr = dev->base_addr;\n\tint count;\n\n\tnetdev_dbg(dev, \"register dump:\\n\");\n\tfor (count = 0; count < 16; count++) {\n\t\tif (!(count % 16))\n\t\t\tpr_cont(\"%04X:\", ioaddr + count);\n\t\tpr_cont(\" %02X\", arcnet_inb(ioaddr, count));\n\t}\n\tpr_cont(\"\\n\");\n\n\tnetdev_dbg(dev, \"buffer0 dump:\\n\");\n\t \n\tcount = 0;\n\tarcnet_outb((count >> 8) | RDDATAflag | AUTOINCflag,\n\t\t    ioaddr, COM20020_REG_W_ADDR_HI);\n\tarcnet_outb(count & 0xff, ioaddr, COM20020_REG_W_ADDR_LO);\n\n\tfor (count = 0; count < 256 + 32; count++) {\n\t\tif (!(count % 16))\n\t\t\tpr_cont(\"%04X:\", count);\n\n\t\t \n\t\tpr_cont(\" %02X\", arcnet_inb(ioaddr, COM20020_REG_RW_MEMDATA));\n\t}\n\tpr_cont(\"\\n\");\n#endif\n}\n\n \n\n \n\nstatic int node;\nstatic int timeout = 3;\nstatic int backplane;\nstatic int clockp;\nstatic int clockm;\n\nmodule_param(node, int, 0);\nmodule_param(timeout, int, 0);\nmodule_param(backplane, int, 0);\nmodule_param(clockp, int, 0);\nmodule_param(clockm, int, 0);\n\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic int com20020_config(struct pcmcia_device *link);\nstatic void com20020_release(struct pcmcia_device *link);\n\nstatic void com20020_detach(struct pcmcia_device *p_dev);\n\n \n\nstatic int com20020_probe(struct pcmcia_device *p_dev)\n{\n\tstruct com20020_dev *info;\n\tstruct net_device *dev;\n\tstruct arcnet_local *lp;\n\tint ret = -ENOMEM;\n\n\tdev_dbg(&p_dev->dev, \"com20020_attach()\\n\");\n\n\t \n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\tgoto fail_alloc_info;\n\n\tdev = alloc_arcdev(\"\");\n\tif (!dev)\n\t\tgoto fail_alloc_dev;\n\n\tlp = netdev_priv(dev);\n\tlp->timeout = timeout;\n\tlp->backplane = backplane;\n\tlp->clockp = clockp;\n\tlp->clockm = clockm & 3;\n\tlp->hw.owner = THIS_MODULE;\n\n\t \n\tarcnet_set_addr(dev, node);\n\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\n\tp_dev->resource[0]->end = 16;\n\tp_dev->config_flags |= CONF_ENABLE_IRQ;\n\n\tinfo->dev = dev;\n\tp_dev->priv = info;\n\n\tret = com20020_config(p_dev);\n\tif (ret)\n\t\tgoto fail_config;\n\n\treturn 0;\n\nfail_config:\n\tfree_arcdev(dev);\nfail_alloc_dev:\n\tkfree(info);\nfail_alloc_info:\n\treturn ret;\n}  \n\nstatic void com20020_detach(struct pcmcia_device *link)\n{\n\tstruct com20020_dev *info = link->priv;\n\tstruct net_device *dev = info->dev;\n\n\tdev_dbg(&link->dev, \"detach...\\n\");\n\n\tdev_dbg(&link->dev, \"com20020_detach\\n\");\n\n\tdev_dbg(&link->dev, \"unregister...\\n\");\n\n\tunregister_netdev(dev);\n\n\t \n\tif (dev->irq)\n\t\tfree_irq(dev->irq, dev);\n\n\tcom20020_release(link);\n\n\t \n\tdev_dbg(&link->dev, \"unlinking...\\n\");\n\tif (link->priv) {\n\t\tdev = info->dev;\n\t\tif (dev) {\n\t\t\tdev_dbg(&link->dev, \"kfree...\\n\");\n\t\t\tfree_arcdev(dev);\n\t\t}\n\t\tdev_dbg(&link->dev, \"kfree2...\\n\");\n\t\tkfree(info);\n\t}\n\n}  \n\nstatic int com20020_config(struct pcmcia_device *link)\n{\n\tstruct arcnet_local *lp;\n\tstruct com20020_dev *info;\n\tstruct net_device *dev;\n\tint i, ret;\n\tint ioaddr;\n\n\tinfo = link->priv;\n\tdev = info->dev;\n\n\tdev_dbg(&link->dev, \"config...\\n\");\n\n\tdev_dbg(&link->dev, \"com20020_config\\n\");\n\n\tdev_dbg(&link->dev, \"baseport1 is %Xh\\n\",\n\t\t(unsigned int)link->resource[0]->start);\n\n\ti = -ENODEV;\n\tlink->io_lines = 16;\n\n\tif (!link->resource[0]->start) {\n\t\tfor (ioaddr = 0x100; ioaddr < 0x400; ioaddr += 0x10) {\n\t\t\tlink->resource[0]->start = ioaddr;\n\t\t\ti = pcmcia_request_io(link);\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\ti = pcmcia_request_io(link);\n\t}\n\n\tif (i != 0) {\n\t\tdev_dbg(&link->dev, \"requestIO failed totally!\\n\");\n\t\tgoto failed;\n\t}\n\n\tioaddr = dev->base_addr = link->resource[0]->start;\n\tdev_dbg(&link->dev, \"got ioaddr %Xh\\n\", ioaddr);\n\n\tdev_dbg(&link->dev, \"request IRQ %d\\n\",\n\t\tlink->irq);\n\tif (!link->irq) {\n\t\tdev_dbg(&link->dev, \"requestIRQ failed totally!\\n\");\n\t\tgoto failed;\n\t}\n\n\tdev->irq = link->irq;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\tgoto failed;\n\n\tif (com20020_check(dev)) {\n\t\tregdump(dev);\n\t\tgoto failed;\n\t}\n\n\tlp = netdev_priv(dev);\n\tlp->card_name = \"PCMCIA COM20020\";\n\tlp->card_flags = ARC_CAN_10MBIT;  \n\n\tSET_NETDEV_DEV(dev, &link->dev);\n\n\ti = com20020_found(dev, 0);\t \n\n\tif (i != 0) {\n\t\tdev_notice(&link->dev,\n\t\t\t   \"com20020_found() failed\\n\");\n\t\tgoto failed;\n\t}\n\n\tnetdev_dbg(dev, \"port %#3lx, irq %d\\n\",\n\t\t   dev->base_addr, dev->irq);\n\treturn 0;\n\nfailed:\n\tdev_dbg(&link->dev, \"com20020_config failed...\\n\");\n\tcom20020_release(link);\n\treturn -ENODEV;\n}  \n\nstatic void com20020_release(struct pcmcia_device *link)\n{\n\tdev_dbg(&link->dev, \"com20020_release\\n\");\n\tpcmcia_disable_device(link);\n}\n\nstatic int com20020_suspend(struct pcmcia_device *link)\n{\n\tstruct com20020_dev *info = link->priv;\n\tstruct net_device *dev = info->dev;\n\n\tif (link->open)\n\t\tnetif_device_detach(dev);\n\n\treturn 0;\n}\n\nstatic int com20020_resume(struct pcmcia_device *link)\n{\n\tstruct com20020_dev *info = link->priv;\n\tstruct net_device *dev = info->dev;\n\n\tif (link->open) {\n\t\tint ioaddr = dev->base_addr;\n\t\tstruct arcnet_local *lp = netdev_priv(dev);\n\n\t\tarcnet_outb(lp->config | 0x80, ioaddr, COM20020_REG_W_CONFIG);\n\t\tudelay(5);\n\t\tarcnet_outb(lp->config, ioaddr, COM20020_REG_W_CONFIG);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pcmcia_device_id com20020_ids[] = {\n\tPCMCIA_DEVICE_PROD_ID12(\"Contemporary Control Systems, Inc.\",\n\t\t\t\t\"PCM20 Arcnet Adapter\", 0x59991666, 0x95dfffaf),\n\tPCMCIA_DEVICE_PROD_ID12(\"SoHard AG\",\n\t\t\t\t\"SH ARC PCMCIA\", 0xf8991729, 0x69dff0c7),\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, com20020_ids);\n\nstatic struct pcmcia_driver com20020_cs_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"com20020_cs\",\n\t.probe\t\t= com20020_probe,\n\t.remove\t\t= com20020_detach,\n\t.id_table\t= com20020_ids,\n\t.suspend\t= com20020_suspend,\n\t.resume\t\t= com20020_resume,\n};\nmodule_pcmcia_driver(com20020_cs_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}