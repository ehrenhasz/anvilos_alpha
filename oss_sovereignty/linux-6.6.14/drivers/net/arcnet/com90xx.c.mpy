{
  "module_name": "com90xx.c",
  "hash_id": "ad3bee7b1d6e7e23994ca826a486566379ebfcbf07778e3855a29edb10ca5f8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/arcnet/com90xx.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"arcnet:\" KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#include \"arcdevice.h\"\n#include \"com9026.h\"\n\n \n#undef FAST_PROBE\n\n \nstatic int com90xx_found(int ioaddr, int airq, u_long shmem, void __iomem *);\nstatic void com90xx_command(struct net_device *dev, int command);\nstatic int com90xx_status(struct net_device *dev);\nstatic void com90xx_setmask(struct net_device *dev, int mask);\nstatic int com90xx_reset(struct net_device *dev, int really_reset);\nstatic void com90xx_copy_to_card(struct net_device *dev, int bufnum, int offset,\n\t\t\t\t void *buf, int count);\nstatic void com90xx_copy_from_card(struct net_device *dev, int bufnum,\n\t\t\t\t   int offset, void *buf, int count);\n\n \n\nstatic struct net_device *cards[16];\nstatic int numcards;\n\n \n\n \n#define ARCNET_TOTAL_SIZE\t16\n\n \n#define BUFFER_SIZE (512)\n#define MIRROR_SIZE (BUFFER_SIZE * 4)\n\nstatic int com90xx_skip_probe __initdata = 0;\n\n \n\nstatic int io;\t\t\t \nstatic int irq;\nstatic int shmem;\nstatic char device[9];\t\t \n\nmodule_param_hw(io, int, ioport, 0);\nmodule_param_hw(irq, int, irq, 0);\nmodule_param(shmem, int, 0);\nmodule_param_string(device, device, sizeof(device), 0);\n\nstatic void __init com90xx_probe(void)\n{\n\tint count, status, ioaddr, numprint, airq, openparen = 0;\n\tunsigned long airqmask;\n\tint ports[(0x3f0 - 0x200) / 16 + 1] = {\t0 };\n\tunsigned long *shmems;\n\tvoid __iomem **iomem;\n\tint numports, numshmems, *port;\n\tu_long *p;\n\tint index;\n\n\tif (!io && !irq && !shmem && !*device && com90xx_skip_probe)\n\t\treturn;\n\n\tshmems = kzalloc(((0x100000 - 0xa0000) / 0x800) * sizeof(unsigned long),\n\t\t\t GFP_KERNEL);\n\tif (!shmems)\n\t\treturn;\n\tiomem = kzalloc(((0x100000 - 0xa0000) / 0x800) * sizeof(void __iomem *),\n\t\t\tGFP_KERNEL);\n\tif (!iomem) {\n\t\tkfree(shmems);\n\t\treturn;\n\t}\n\n\tif (BUGLVL(D_NORMAL))\n\t\tpr_info(\"%s\\n\", \"COM90xx chipset support\");\n\n\t \n\tnumports = numshmems = 0;\n\tif (io)\n\t\tports[numports++] = io;\n\telse\n\t\tfor (count = 0x200; count <= 0x3f0; count += 16)\n\t\t\tports[numports++] = count;\n\tif (shmem)\n\t\tshmems[numshmems++] = shmem;\n\telse\n\t\tfor (count = 0xA0000; count <= 0xFF800; count += 2048)\n\t\t\tshmems[numshmems++] = count;\n\n\t \n\tnumprint = -1;\n\tfor (port = &ports[0]; port - ports < numports; port++) {\n\t\tnumprint++;\n\t\tnumprint %= 8;\n\t\tif (!numprint) {\n\t\t\tarc_cont(D_INIT, \"\\n\");\n\t\t\tarc_cont(D_INIT, \"S1: \");\n\t\t}\n\t\tarc_cont(D_INIT, \"%Xh \", *port);\n\n\t\tioaddr = *port;\n\n\t\tif (!request_region(*port, ARCNET_TOTAL_SIZE,\n\t\t\t\t    \"arcnet (90xx)\")) {\n\t\t\tarc_cont(D_INIT_REASONS, \"(request_region)\\n\");\n\t\t\tarc_cont(D_INIT_REASONS, \"S1: \");\n\t\t\tif (BUGLVL(D_INIT_REASONS))\n\t\t\t\tnumprint = 0;\n\t\t\t*port-- = ports[--numports];\n\t\t\tcontinue;\n\t\t}\n\t\tif (arcnet_inb(ioaddr, COM9026_REG_R_STATUS) == 0xFF) {\n\t\t\tarc_cont(D_INIT_REASONS, \"(empty)\\n\");\n\t\t\tarc_cont(D_INIT_REASONS, \"S1: \");\n\t\t\tif (BUGLVL(D_INIT_REASONS))\n\t\t\t\tnumprint = 0;\n\t\t\trelease_region(*port, ARCNET_TOTAL_SIZE);\n\t\t\t*port-- = ports[--numports];\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tarcnet_inb(ioaddr, COM9026_REG_R_RESET);\n\n\t\tarc_cont(D_INIT_REASONS, \"\\n\");\n\t\tarc_cont(D_INIT_REASONS, \"S1: \");\n\t\tif (BUGLVL(D_INIT_REASONS))\n\t\t\tnumprint = 0;\n\t}\n\tarc_cont(D_INIT, \"\\n\");\n\n\tif (!numports) {\n\t\tarc_cont(D_NORMAL, \"S1: No ARCnet cards found.\\n\");\n\t\tkfree(shmems);\n\t\tkfree(iomem);\n\t\treturn;\n\t}\n\t \n\tnumprint = -1;\n\tfor (port = &ports[0]; port < ports + numports; port++) {\n\t\tnumprint++;\n\t\tnumprint %= 8;\n\t\tif (!numprint) {\n\t\t\tarc_cont(D_INIT, \"\\n\");\n\t\t\tarc_cont(D_INIT, \"S2: \");\n\t\t}\n\t\tarc_cont(D_INIT, \"%Xh \", *port);\n\t}\n\tarc_cont(D_INIT, \"\\n\");\n\tmdelay(RESETtime);\n\n\t \n\tnumprint = -1;\n\tfor (index = 0, p = &shmems[0]; index < numshmems; p++, index++) {\n\t\tvoid __iomem *base;\n\n\t\tnumprint++;\n\t\tnumprint %= 8;\n\t\tif (!numprint) {\n\t\t\tarc_cont(D_INIT, \"\\n\");\n\t\t\tarc_cont(D_INIT, \"S3: \");\n\t\t}\n\t\tarc_cont(D_INIT, \"%lXh \", *p);\n\n\t\tif (!request_mem_region(*p, MIRROR_SIZE, \"arcnet (90xx)\")) {\n\t\t\tarc_cont(D_INIT_REASONS, \"(request_mem_region)\\n\");\n\t\t\tarc_cont(D_INIT_REASONS, \"Stage 3: \");\n\t\t\tif (BUGLVL(D_INIT_REASONS))\n\t\t\t\tnumprint = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbase = ioremap(*p, MIRROR_SIZE);\n\t\tif (!base) {\n\t\t\tarc_cont(D_INIT_REASONS, \"(ioremap)\\n\");\n\t\t\tarc_cont(D_INIT_REASONS, \"Stage 3: \");\n\t\t\tif (BUGLVL(D_INIT_REASONS))\n\t\t\t\tnumprint = 0;\n\t\t\tgoto out1;\n\t\t}\n\t\tif (arcnet_readb(base, COM9026_REG_R_STATUS) != TESTvalue) {\n\t\t\tarc_cont(D_INIT_REASONS, \"(%02Xh != %02Xh)\\n\",\n\t\t\t\t arcnet_readb(base, COM9026_REG_R_STATUS),\n\t\t\t\t TESTvalue);\n\t\t\tarc_cont(D_INIT_REASONS, \"S3: \");\n\t\t\tif (BUGLVL(D_INIT_REASONS))\n\t\t\t\tnumprint = 0;\n\t\t\tgoto out2;\n\t\t}\n\t\t \n\t\tarcnet_writeb(0x42, base, COM9026_REG_W_INTMASK);\n\t\tif (arcnet_readb(base, COM9026_REG_R_STATUS) != 0x42) {\n\t\t\tarc_cont(D_INIT_REASONS, \"(read only)\\n\");\n\t\t\tarc_cont(D_INIT_REASONS, \"S3: \");\n\t\t\tgoto out2;\n\t\t}\n\t\tarc_cont(D_INIT_REASONS, \"\\n\");\n\t\tarc_cont(D_INIT_REASONS, \"S3: \");\n\t\tif (BUGLVL(D_INIT_REASONS))\n\t\t\tnumprint = 0;\n\t\tiomem[index] = base;\n\t\tcontinue;\n\tout2:\n\t\tiounmap(base);\n\tout1:\n\t\trelease_mem_region(*p, MIRROR_SIZE);\n\tout:\n\t\t*p-- = shmems[--numshmems];\n\t\tindex--;\n\t}\n\tarc_cont(D_INIT, \"\\n\");\n\n\tif (!numshmems) {\n\t\tarc_cont(D_NORMAL, \"S3: No ARCnet cards found.\\n\");\n\t\tfor (port = &ports[0]; port < ports + numports; port++)\n\t\t\trelease_region(*port, ARCNET_TOTAL_SIZE);\n\t\tkfree(shmems);\n\t\tkfree(iomem);\n\t\treturn;\n\t}\n\t \n\tnumprint = -1;\n\tfor (p = &shmems[0]; p < shmems + numshmems; p++) {\n\t\tnumprint++;\n\t\tnumprint %= 8;\n\t\tif (!numprint) {\n\t\t\tarc_cont(D_INIT, \"\\n\");\n\t\t\tarc_cont(D_INIT, \"S4: \");\n\t\t}\n\t\tarc_cont(D_INIT, \"%lXh \", *p);\n\t}\n\tarc_cont(D_INIT, \"\\n\");\n\n\t \n\tnumprint = -1;\n\tfor (port = &ports[0]; port < ports + numports; port++) {\n\t\tint found = 0;\n\n\t\tnumprint++;\n\t\tnumprint %= 8;\n\t\tif (!numprint) {\n\t\t\tarc_cont(D_INIT, \"\\n\");\n\t\t\tarc_cont(D_INIT, \"S5: \");\n\t\t}\n\t\tarc_cont(D_INIT, \"%Xh \", *port);\n\n\t\tioaddr = *port;\n\t\tstatus = arcnet_inb(ioaddr, COM9026_REG_R_STATUS);\n\n\t\tif ((status & 0x9D)\n\t\t    != (NORXflag | RECONflag | TXFREEflag | RESETflag)) {\n\t\t\tarc_cont(D_INIT_REASONS, \"(status=%Xh)\\n\", status);\n\t\t\tarc_cont(D_INIT_REASONS, \"S5: \");\n\t\t\tif (BUGLVL(D_INIT_REASONS))\n\t\t\t\tnumprint = 0;\n\t\t\trelease_region(*port, ARCNET_TOTAL_SIZE);\n\t\t\t*port-- = ports[--numports];\n\t\t\tcontinue;\n\t\t}\n\t\tarcnet_outb(CFLAGScmd | RESETclear | CONFIGclear,\n\t\t\t    ioaddr, COM9026_REG_W_COMMAND);\n\t\tstatus = arcnet_inb(ioaddr, COM9026_REG_R_STATUS);\n\t\tif (status & RESETflag) {\n\t\t\tarc_cont(D_INIT_REASONS, \" (eternal reset, status=%Xh)\\n\",\n\t\t\t\t status);\n\t\t\tarc_cont(D_INIT_REASONS, \"S5: \");\n\t\t\tif (BUGLVL(D_INIT_REASONS))\n\t\t\t\tnumprint = 0;\n\t\t\trelease_region(*port, ARCNET_TOTAL_SIZE);\n\t\t\t*port-- = ports[--numports];\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (!irq) {\n\t\t\t \n\t\t\tairqmask = probe_irq_on();\n\t\t\tarcnet_outb(NORXflag, ioaddr, COM9026_REG_W_INTMASK);\n\t\t\tudelay(1);\n\t\t\tarcnet_outb(0, ioaddr, COM9026_REG_W_INTMASK);\n\t\t\tairq = probe_irq_off(airqmask);\n\n\t\t\tif (airq <= 0) {\n\t\t\t\tarc_cont(D_INIT_REASONS, \"(airq=%d)\\n\", airq);\n\t\t\t\tarc_cont(D_INIT_REASONS, \"S5: \");\n\t\t\t\tif (BUGLVL(D_INIT_REASONS))\n\t\t\t\t\tnumprint = 0;\n\t\t\t\trelease_region(*port, ARCNET_TOTAL_SIZE);\n\t\t\t\t*port-- = ports[--numports];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tairq = irq;\n\t\t}\n\n\t\tarc_cont(D_INIT, \"(%d,\", airq);\n\t\topenparen = 1;\n\n\t\t \n#ifdef FAST_PROBE\n\t\tif (numports > 1 || numshmems > 1) {\n\t\t\tarcnet_inb(ioaddr, COM9026_REG_R_RESET);\n\t\t\tmdelay(RESETtime);\n\t\t} else {\n\t\t\t \n\t\t\tarcnet_writeb(TESTvalue, iomem[0],\n\t\t\t\t      COM9026_REG_W_INTMASK);\n\t\t}\n#else\n\t\tarcnet_inb(ioaddr, COM9026_REG_R_RESET);\n\t\tmdelay(RESETtime);\n#endif\n\n\t\tfor (index = 0; index < numshmems; index++) {\n\t\t\tu_long ptr = shmems[index];\n\t\t\tvoid __iomem *base = iomem[index];\n\n\t\t\tif (arcnet_readb(base, COM9026_REG_R_STATUS) == TESTvalue) {\t \n\t\t\t\tarc_cont(D_INIT, \"%lXh)\\n\", *p);\n\t\t\t\topenparen = 0;\n\n\t\t\t\t \n\t\t\t\tif (com90xx_found(*port, airq, ptr, base) == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tnumprint = -1;\n\n\t\t\t\t \n\t\t\t\tshmems[index] = shmems[--numshmems];\n\t\t\t\tiomem[index] = iomem[numshmems];\n\t\t\t\tbreak;\t \n\t\t\t} else {\n\t\t\t\tarc_cont(D_INIT_REASONS, \"%Xh-\",\n\t\t\t\t\t arcnet_readb(base, COM9026_REG_R_STATUS));\n\t\t\t}\n\t\t}\n\n\t\tif (openparen) {\n\t\t\tif (BUGLVL(D_INIT))\n\t\t\t\tpr_cont(\"no matching shmem)\\n\");\n\t\t\tif (BUGLVL(D_INIT_REASONS)) {\n\t\t\t\tpr_cont(\"S5: \");\n\t\t\t\tnumprint = 0;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\trelease_region(*port, ARCNET_TOTAL_SIZE);\n\t\t*port-- = ports[--numports];\n\t}\n\n\tif (BUGLVL(D_INIT_REASONS))\n\t\tpr_cont(\"\\n\");\n\n\t \n\tfor (index = 0; index < numshmems; index++) {\n\t\tarcnet_writeb(TESTvalue, iomem[index], COM9026_REG_W_INTMASK);\n\t\tiounmap(iomem[index]);\n\t\trelease_mem_region(shmems[index], MIRROR_SIZE);\n\t}\n\tkfree(shmems);\n\tkfree(iomem);\n}\n\nstatic int __init check_mirror(unsigned long addr, size_t size)\n{\n\tvoid __iomem *p;\n\tint res = -1;\n\n\tif (!request_mem_region(addr, size, \"arcnet (90xx)\"))\n\t\treturn -1;\n\n\tp = ioremap(addr, size);\n\tif (p) {\n\t\tif (arcnet_readb(p, COM9026_REG_R_STATUS) == TESTvalue)\n\t\t\tres = 1;\n\t\telse\n\t\t\tres = 0;\n\t\tiounmap(p);\n\t}\n\n\trelease_mem_region(addr, size);\n\treturn res;\n}\n\n \nstatic int __init com90xx_found(int ioaddr, int airq, u_long shmem,\n\t\t\t\tvoid __iomem *p)\n{\n\tstruct net_device *dev = NULL;\n\tstruct arcnet_local *lp;\n\tu_long first_mirror, last_mirror;\n\tint mirror_size;\n\n\t \n\tdev = alloc_arcdev(device);\n\tif (!dev) {\n\t\tarc_cont(D_NORMAL, \"com90xx: Can't allocate device!\\n\");\n\t\tiounmap(p);\n\t\trelease_mem_region(shmem, MIRROR_SIZE);\n\t\treturn -ENOMEM;\n\t}\n\tlp = netdev_priv(dev);\n\t \n\n\t \n\tmirror_size = MIRROR_SIZE;\n\tif (arcnet_readb(p, COM9026_REG_R_STATUS) == TESTvalue &&\n\t    check_mirror(shmem - MIRROR_SIZE, MIRROR_SIZE) == 0 &&\n\t    check_mirror(shmem - 2 * MIRROR_SIZE, MIRROR_SIZE) == 1)\n\t\tmirror_size = 2 * MIRROR_SIZE;\n\n\tfirst_mirror = shmem - mirror_size;\n\twhile (check_mirror(first_mirror, mirror_size) == 1)\n\t\tfirst_mirror -= mirror_size;\n\tfirst_mirror += mirror_size;\n\n\tlast_mirror = shmem + mirror_size;\n\twhile (check_mirror(last_mirror, mirror_size) == 1)\n\t\tlast_mirror += mirror_size;\n\tlast_mirror -= mirror_size;\n\n\tdev->mem_start = first_mirror;\n\tdev->mem_end = last_mirror + MIRROR_SIZE - 1;\n\n\tiounmap(p);\n\trelease_mem_region(shmem, MIRROR_SIZE);\n\n\tif (!request_mem_region(dev->mem_start,\n\t\t\t\tdev->mem_end - dev->mem_start + 1,\n\t\t\t\t\"arcnet (90xx)\"))\n\t\tgoto err_free_dev;\n\n\t \n\tif (request_irq(airq, arcnet_interrupt, 0, \"arcnet (90xx)\", dev)) {\n\t\tarc_printk(D_NORMAL, dev, \"Can't get IRQ %d!\\n\", airq);\n\t\tgoto err_release_mem;\n\t}\n\tdev->irq = airq;\n\n\t \n\tlp->card_name = \"COM90xx\";\n\tlp->hw.command = com90xx_command;\n\tlp->hw.status = com90xx_status;\n\tlp->hw.intmask = com90xx_setmask;\n\tlp->hw.reset = com90xx_reset;\n\tlp->hw.owner = THIS_MODULE;\n\tlp->hw.copy_to_card = com90xx_copy_to_card;\n\tlp->hw.copy_from_card = com90xx_copy_from_card;\n\tlp->mem_start = ioremap(dev->mem_start,\n\t\t\t\tdev->mem_end - dev->mem_start + 1);\n\tif (!lp->mem_start) {\n\t\tarc_printk(D_NORMAL, dev, \"Can't remap device memory!\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\t \n\tarcnet_set_addr(dev, arcnet_readb(lp->mem_start,\n\t\t\t\t\t  COM9026_REG_R_STATION));\n\n\tdev->base_addr = ioaddr;\n\n\tarc_printk(D_NORMAL, dev, \"COM90xx station %02Xh found at %03lXh, IRQ %d, ShMem %lXh (%ld*%xh).\\n\",\n\t\t   dev->dev_addr[0],\n\t\t   dev->base_addr, dev->irq, dev->mem_start,\n\t\t   (dev->mem_end - dev->mem_start + 1) / mirror_size,\n\t\t   mirror_size);\n\n\tif (register_netdev(dev))\n\t\tgoto err_unmap;\n\n\tcards[numcards++] = dev;\n\treturn 0;\n\nerr_unmap:\n\tiounmap(lp->mem_start);\nerr_free_irq:\n\tfree_irq(dev->irq, dev);\nerr_release_mem:\n\trelease_mem_region(dev->mem_start, dev->mem_end - dev->mem_start + 1);\nerr_free_dev:\n\tfree_arcdev(dev);\n\treturn -EIO;\n}\n\nstatic void com90xx_command(struct net_device *dev, int cmd)\n{\n\tshort ioaddr = dev->base_addr;\n\n\tarcnet_outb(cmd, ioaddr, COM9026_REG_W_COMMAND);\n}\n\nstatic int com90xx_status(struct net_device *dev)\n{\n\tshort ioaddr = dev->base_addr;\n\n\treturn arcnet_inb(ioaddr, COM9026_REG_R_STATUS);\n}\n\nstatic void com90xx_setmask(struct net_device *dev, int mask)\n{\n\tshort ioaddr = dev->base_addr;\n\n\tarcnet_outb(mask, ioaddr, COM9026_REG_W_INTMASK);\n}\n\n \nstatic int com90xx_reset(struct net_device *dev, int really_reset)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tshort ioaddr = dev->base_addr;\n\n\tarc_printk(D_INIT, dev, \"Resetting (status=%02Xh)\\n\",\n\t\t   arcnet_inb(ioaddr, COM9026_REG_R_STATUS));\n\n\tif (really_reset) {\n\t\t \n\t\tarcnet_inb(ioaddr, COM9026_REG_R_RESET);\n\t\tmdelay(RESETtime);\n\t}\n\t \n\tarcnet_outb(CFLAGScmd | RESETclear, ioaddr, COM9026_REG_W_COMMAND);\n\tarcnet_outb(CFLAGScmd | CONFIGclear, ioaddr, COM9026_REG_W_COMMAND);\n\n#if 0\n\t \n\tarcnet_outb(arcnet_inb(ioaddr, COM9026_REG_RW_CONFIG) | ENABLE16flag,\n\t\t    ioaddr, COM9026_REG_RW_CONFIG);\n#endif\n\n\t \n\tif (arcnet_readb(lp->mem_start, COM9026_REG_R_STATUS) != TESTvalue) {\n\t\tif (really_reset)\n\t\t\tarc_printk(D_NORMAL, dev, \"reset failed: TESTvalue not present.\\n\");\n\t\treturn 1;\n\t}\n\t \n\tarcnet_outb(CONFIGcmd | EXTconf, ioaddr, COM9026_REG_W_COMMAND);\n\n\t \n\tif (BUGLVL(D_DURING))\n\t\tmemset_io(lp->mem_start, 0x42, 2048);\n\n\t \n\treturn 0;\n}\n\nstatic void com90xx_copy_to_card(struct net_device *dev, int bufnum,\n\t\t\t\t int offset, void *buf, int count)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tvoid __iomem *memaddr = lp->mem_start + bufnum * 512 + offset;\n\n\tTIME(dev, \"memcpy_toio\", count, memcpy_toio(memaddr, buf, count));\n}\n\nstatic void com90xx_copy_from_card(struct net_device *dev, int bufnum,\n\t\t\t\t   int offset, void *buf, int count)\n{\n\tstruct arcnet_local *lp = netdev_priv(dev);\n\tvoid __iomem *memaddr = lp->mem_start + bufnum * 512 + offset;\n\n\tTIME(dev, \"memcpy_fromio\", count, memcpy_fromio(buf, memaddr, count));\n}\n\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init com90xx_init(void)\n{\n\tif (irq == 2)\n\t\tirq = 9;\n\tcom90xx_probe();\n\tif (!numcards)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic void __exit com90xx_exit(void)\n{\n\tstruct net_device *dev;\n\tstruct arcnet_local *lp;\n\tint count;\n\n\tfor (count = 0; count < numcards; count++) {\n\t\tdev = cards[count];\n\t\tlp = netdev_priv(dev);\n\n\t\tunregister_netdev(dev);\n\t\tfree_irq(dev->irq, dev);\n\t\tiounmap(lp->mem_start);\n\t\trelease_region(dev->base_addr, ARCNET_TOTAL_SIZE);\n\t\trelease_mem_region(dev->mem_start,\n\t\t\t\t   dev->mem_end - dev->mem_start + 1);\n\t\tfree_arcdev(dev);\n\t}\n}\n\nmodule_init(com90xx_init);\nmodule_exit(com90xx_exit);\n\n#ifndef MODULE\nstatic int __init com90xx_setup(char *s)\n{\n\tint ints[8];\n\n\ts = get_options(s, 8, ints);\n\tif (!ints[0] && !*s) {\n\t\tpr_notice(\"Disabled\\n\");\n\t\treturn 1;\n\t}\n\n\tswitch (ints[0]) {\n\tdefault:\t\t \n\t\tpr_err(\"Too many arguments\\n\");\n\t\tfallthrough;\n\tcase 3:\t\t \n\t\tshmem = ints[3];\n\t\tfallthrough;\n\tcase 2:\t\t \n\t\tirq = ints[2];\n\t\tfallthrough;\n\tcase 1:\t\t \n\t\tio = ints[1];\n\t}\n\n\tif (*s)\n\t\tsnprintf(device, sizeof(device), \"%s\", s);\n\n\treturn 1;\n}\n\n__setup(\"com90xx=\", com90xx_setup);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}