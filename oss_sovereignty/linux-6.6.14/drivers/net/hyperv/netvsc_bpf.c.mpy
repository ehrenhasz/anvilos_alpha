{
  "module_name": "netvsc_bpf.c",
  "hash_id": "f5c28ef2f174c02d74bc06eef14f4caf6e67f30b762adb782f2aeda0e9b2ece8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hyperv/netvsc_bpf.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/netpoll.h>\n#include <linux/bpf.h>\n#include <linux/bpf_trace.h>\n#include <linux/kernel.h>\n#include <net/xdp.h>\n\n#include <linux/mutex.h>\n#include <linux/rtnetlink.h>\n\n#include \"hyperv_net.h\"\n\nu32 netvsc_run_xdp(struct net_device *ndev, struct netvsc_channel *nvchan,\n\t\t   struct xdp_buff *xdp)\n{\n\tstruct netvsc_stats_rx *rx_stats = &nvchan->rx_stats;\n\tvoid *data = nvchan->rsc.data[0];\n\tu32 len = nvchan->rsc.len[0];\n\tstruct page *page = NULL;\n\tstruct bpf_prog *prog;\n\tu32 act = XDP_PASS;\n\tbool drop = true;\n\n\txdp->data_hard_start = NULL;\n\n\trcu_read_lock();\n\tprog = rcu_dereference(nvchan->bpf_prog);\n\n\tif (!prog)\n\t\tgoto out;\n\n\t \n\tif (len > ndev->mtu + ETH_HLEN) {\n\t\tact = XDP_DROP;\n\t\tgoto out;\n\t}\n\n\t \n\tpage = alloc_page(GFP_ATOMIC);\n\tif (!page) {\n\t\tact = XDP_DROP;\n\t\tgoto out;\n\t}\n\n\txdp_init_buff(xdp, PAGE_SIZE, &nvchan->xdp_rxq);\n\txdp_prepare_buff(xdp, page_address(page), NETVSC_XDP_HDRM, len, false);\n\n\tmemcpy(xdp->data, data, len);\n\n\tact = bpf_prog_run_xdp(prog, xdp);\n\n\tswitch (act) {\n\tcase XDP_PASS:\n\tcase XDP_TX:\n\t\tdrop = false;\n\t\tbreak;\n\n\tcase XDP_DROP:\n\t\tbreak;\n\n\tcase XDP_REDIRECT:\n\t\tif (!xdp_do_redirect(ndev, xdp, prog)) {\n\t\t\tnvchan->xdp_flush = true;\n\t\t\tdrop = false;\n\n\t\t\tu64_stats_update_begin(&rx_stats->syncp);\n\n\t\t\trx_stats->xdp_redirect++;\n\t\t\trx_stats->packets++;\n\t\t\trx_stats->bytes += nvchan->rsc.pktlen;\n\n\t\t\tu64_stats_update_end(&rx_stats->syncp);\n\n\t\t\tbreak;\n\t\t} else {\n\t\t\tu64_stats_update_begin(&rx_stats->syncp);\n\t\t\trx_stats->xdp_drop++;\n\t\t\tu64_stats_update_end(&rx_stats->syncp);\n\t\t}\n\n\t\tfallthrough;\n\n\tcase XDP_ABORTED:\n\t\ttrace_xdp_exception(ndev, prog, act);\n\t\tbreak;\n\n\tdefault:\n\t\tbpf_warn_invalid_xdp_action(ndev, prog, act);\n\t}\n\nout:\n\trcu_read_unlock();\n\n\tif (page && drop) {\n\t\t__free_page(page);\n\t\txdp->data_hard_start = NULL;\n\t}\n\n\treturn act;\n}\n\nunsigned int netvsc_xdp_fraglen(unsigned int len)\n{\n\treturn SKB_DATA_ALIGN(len) +\n\t       SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n}\n\nstruct bpf_prog *netvsc_xdp_get(struct netvsc_device *nvdev)\n{\n\treturn rtnl_dereference(nvdev->chan_table[0].bpf_prog);\n}\n\nint netvsc_xdp_set(struct net_device *dev, struct bpf_prog *prog,\n\t\t   struct netlink_ext_ack *extack,\n\t\t   struct netvsc_device *nvdev)\n{\n\tstruct bpf_prog *old_prog;\n\tint buf_max, i;\n\n\told_prog = netvsc_xdp_get(nvdev);\n\n\tif (!old_prog && !prog)\n\t\treturn 0;\n\n\tbuf_max = NETVSC_XDP_HDRM + netvsc_xdp_fraglen(dev->mtu + ETH_HLEN);\n\tif (prog && buf_max > PAGE_SIZE) {\n\t\tnetdev_err(dev, \"XDP: mtu:%u too large, buf_max:%u\\n\",\n\t\t\t   dev->mtu, buf_max);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"XDP: mtu too large\");\n\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (prog && (dev->features & NETIF_F_LRO)) {\n\t\tnetdev_err(dev, \"XDP: not support LRO\\n\");\n\t\tNL_SET_ERR_MSG_MOD(extack, \"XDP: not support LRO\");\n\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (prog)\n\t\tbpf_prog_add(prog, nvdev->num_chn - 1);\n\n\tfor (i = 0; i < nvdev->num_chn; i++)\n\t\trcu_assign_pointer(nvdev->chan_table[i].bpf_prog, prog);\n\n\tif (old_prog)\n\t\tfor (i = 0; i < nvdev->num_chn; i++)\n\t\t\tbpf_prog_put(old_prog);\n\n\treturn 0;\n}\n\nint netvsc_vf_setxdp(struct net_device *vf_netdev, struct bpf_prog *prog)\n{\n\tstruct netdev_bpf xdp;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tif (!vf_netdev)\n\t\treturn 0;\n\n\tif (!vf_netdev->netdev_ops->ndo_bpf)\n\t\treturn 0;\n\n\tmemset(&xdp, 0, sizeof(xdp));\n\n\tif (prog)\n\t\tbpf_prog_inc(prog);\n\n\txdp.command = XDP_SETUP_PROG;\n\txdp.prog = prog;\n\n\tret = vf_netdev->netdev_ops->ndo_bpf(vf_netdev, &xdp);\n\n\tif (ret && prog)\n\t\tbpf_prog_put(prog);\n\n\treturn ret;\n}\n\nint netvsc_bpf(struct net_device *dev, struct netdev_bpf *bpf)\n{\n\tstruct net_device_context *ndevctx = netdev_priv(dev);\n\tstruct netvsc_device *nvdev = rtnl_dereference(ndevctx->nvdev);\n\tstruct net_device *vf_netdev = rtnl_dereference(ndevctx->vf_netdev);\n\tstruct netlink_ext_ack *extack = bpf->extack;\n\tint ret;\n\n\tif (!nvdev || nvdev->destroy) {\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (bpf->command) {\n\tcase XDP_SETUP_PROG:\n\t\tret = netvsc_xdp_set(dev, bpf->prog, extack, nvdev);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = netvsc_vf_setxdp(vf_netdev, bpf->prog);\n\n\t\tif (ret) {\n\t\t\tnetdev_err(dev, \"vf_setxdp failed:%d\\n\", ret);\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"vf_setxdp failed\");\n\n\t\t\tnetvsc_xdp_set(dev, NULL, extack, nvdev);\n\t\t}\n\n\t\treturn ret;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int netvsc_ndoxdp_xmit_fm(struct net_device *ndev,\n\t\t\t\t struct xdp_frame *frame, u16 q_idx)\n{\n\tstruct sk_buff *skb;\n\n\tskb = xdp_build_skb_from_frame(frame, ndev);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tnetvsc_get_hash(skb, netdev_priv(ndev));\n\n\tskb_record_rx_queue(skb, q_idx);\n\n\tnetvsc_xdp_xmit(skb, ndev);\n\n\treturn 0;\n}\n\nint netvsc_ndoxdp_xmit(struct net_device *ndev, int n,\n\t\t       struct xdp_frame **frames, u32 flags)\n{\n\tstruct net_device_context *ndev_ctx = netdev_priv(ndev);\n\tconst struct net_device_ops *vf_ops;\n\tstruct netvsc_stats_tx *tx_stats;\n\tstruct netvsc_device *nvsc_dev;\n\tstruct net_device *vf_netdev;\n\tint i, count = 0;\n\tu16 q_idx;\n\n\t \n\tnvsc_dev = rcu_dereference_bh(ndev_ctx->nvdev);\n\tif (unlikely(!nvsc_dev || nvsc_dev->destroy))\n\t\treturn 0;\n\n\t \n\tvf_netdev = rcu_dereference_bh(ndev_ctx->vf_netdev);\n\tif (vf_netdev && netif_running(vf_netdev) &&\n\t    netif_carrier_ok(vf_netdev) && !netpoll_tx_running(ndev) &&\n\t    vf_netdev->netdev_ops->ndo_xdp_xmit &&\n\t    ndev_ctx->data_path_is_vf) {\n\t\tvf_ops = vf_netdev->netdev_ops;\n\t\treturn vf_ops->ndo_xdp_xmit(vf_netdev, n, frames, flags);\n\t}\n\n\tq_idx = smp_processor_id() % ndev->real_num_tx_queues;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (netvsc_ndoxdp_xmit_fm(ndev, frames[i], q_idx))\n\t\t\tbreak;\n\n\t\tcount++;\n\t}\n\n\ttx_stats = &nvsc_dev->chan_table[q_idx].tx_stats;\n\n\tu64_stats_update_begin(&tx_stats->syncp);\n\ttx_stats->xdp_xmit += count;\n\tu64_stats_update_end(&tx_stats->syncp);\n\n\treturn count;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}