{
  "module_name": "rndis_filter.c",
  "hash_id": "865d0f5f0b5e745181500db827568f17cf71ef56b181285afd88bdfb5886d820",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hyperv/rndis_filter.c",
  "human_readable_source": "\n \n#include <linux/ethtool.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/if_ether.h>\n#include <linux/netdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/nls.h>\n#include <linux/vmalloc.h>\n#include <linux/rtnetlink.h>\n#include <linux/ucs2_string.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include \"hyperv_net.h\"\n#include \"netvsc_trace.h\"\n\nstatic void rndis_set_multicast(struct work_struct *w);\n\n#define RNDIS_EXT_LEN HV_HYP_PAGE_SIZE\nstruct rndis_request {\n\tstruct list_head list_ent;\n\tstruct completion  wait_event;\n\n\tstruct rndis_message response_msg;\n\t \n\tu8 response_ext[RNDIS_EXT_LEN];\n\n\t \n\tstruct hv_netvsc_packet\tpkt;\n\n\tstruct rndis_message request_msg;\n\t \n\tu8 request_ext[RNDIS_EXT_LEN];\n};\n\nstatic const u8 netvsc_hash_key[NETVSC_HASH_KEYLEN] = {\n\t0x6d, 0x5a, 0x56, 0xda, 0x25, 0x5b, 0x0e, 0xc2,\n\t0x41, 0x67, 0x25, 0x3d, 0x43, 0xa3, 0x8f, 0xb0,\n\t0xd0, 0xca, 0x2b, 0xcb, 0xae, 0x7b, 0x30, 0xb4,\n\t0x77, 0xcb, 0x2d, 0xa3, 0x80, 0x30, 0xf2, 0x0c,\n\t0x6a, 0x42, 0xb7, 0x3b, 0xbe, 0xac, 0x01, 0xfa\n};\n\nstatic struct rndis_device *get_rndis_device(void)\n{\n\tstruct rndis_device *device;\n\n\tdevice = kzalloc(sizeof(struct rndis_device), GFP_KERNEL);\n\tif (!device)\n\t\treturn NULL;\n\n\tspin_lock_init(&device->request_lock);\n\n\tINIT_LIST_HEAD(&device->req_list);\n\tINIT_WORK(&device->mcast_work, rndis_set_multicast);\n\n\tdevice->state = RNDIS_DEV_UNINITIALIZED;\n\n\treturn device;\n}\n\nstatic struct rndis_request *get_rndis_request(struct rndis_device *dev,\n\t\t\t\t\t     u32 msg_type,\n\t\t\t\t\t     u32 msg_len)\n{\n\tstruct rndis_request *request;\n\tstruct rndis_message *rndis_msg;\n\tstruct rndis_set_request *set;\n\tunsigned long flags;\n\n\trequest = kzalloc(sizeof(struct rndis_request), GFP_KERNEL);\n\tif (!request)\n\t\treturn NULL;\n\n\tinit_completion(&request->wait_event);\n\n\trndis_msg = &request->request_msg;\n\trndis_msg->ndis_msg_type = msg_type;\n\trndis_msg->msg_len = msg_len;\n\n\trequest->pkt.q_idx = 0;\n\n\t \n\tset = &rndis_msg->msg.set_req;\n\tset->req_id = atomic_inc_return(&dev->new_req_id);\n\n\t \n\tspin_lock_irqsave(&dev->request_lock, flags);\n\tlist_add_tail(&request->list_ent, &dev->req_list);\n\tspin_unlock_irqrestore(&dev->request_lock, flags);\n\n\treturn request;\n}\n\nstatic void put_rndis_request(struct rndis_device *dev,\n\t\t\t    struct rndis_request *req)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->request_lock, flags);\n\tlist_del(&req->list_ent);\n\tspin_unlock_irqrestore(&dev->request_lock, flags);\n\n\tkfree(req);\n}\n\nstatic void dump_rndis_message(struct net_device *netdev,\n\t\t\t       const struct rndis_message *rndis_msg,\n\t\t\t       const void *data)\n{\n\tswitch (rndis_msg->ndis_msg_type) {\n\tcase RNDIS_MSG_PACKET:\n\t\tif (rndis_msg->msg_len - RNDIS_HEADER_SIZE >= sizeof(struct rndis_packet)) {\n\t\t\tconst struct rndis_packet *pkt = data + RNDIS_HEADER_SIZE;\n\t\t\tnetdev_dbg(netdev, \"RNDIS_MSG_PACKET (len %u, \"\n\t\t\t\t   \"data offset %u data len %u, # oob %u, \"\n\t\t\t\t   \"oob offset %u, oob len %u, pkt offset %u, \"\n\t\t\t\t   \"pkt len %u\\n\",\n\t\t\t\t   rndis_msg->msg_len,\n\t\t\t\t   pkt->data_offset,\n\t\t\t\t   pkt->data_len,\n\t\t\t\t   pkt->num_oob_data_elements,\n\t\t\t\t   pkt->oob_data_offset,\n\t\t\t\t   pkt->oob_data_len,\n\t\t\t\t   pkt->per_pkt_info_offset,\n\t\t\t\t   pkt->per_pkt_info_len);\n\t\t}\n\t\tbreak;\n\n\tcase RNDIS_MSG_INIT_C:\n\t\tif (rndis_msg->msg_len - RNDIS_HEADER_SIZE >=\n\t\t\t\tsizeof(struct rndis_initialize_complete)) {\n\t\t\tconst struct rndis_initialize_complete *init_complete =\n\t\t\t\tdata + RNDIS_HEADER_SIZE;\n\t\t\tnetdev_dbg(netdev, \"RNDIS_MSG_INIT_C \"\n\t\t\t\t\"(len %u, id 0x%x, status 0x%x, major %d, minor %d, \"\n\t\t\t\t\"device flags %d, max xfer size 0x%x, max pkts %u, \"\n\t\t\t\t\"pkt aligned %u)\\n\",\n\t\t\t\trndis_msg->msg_len,\n\t\t\t\tinit_complete->req_id,\n\t\t\t\tinit_complete->status,\n\t\t\t\tinit_complete->major_ver,\n\t\t\t\tinit_complete->minor_ver,\n\t\t\t\tinit_complete->dev_flags,\n\t\t\t\tinit_complete->max_xfer_size,\n\t\t\t\tinit_complete->max_pkt_per_msg,\n\t\t\t\tinit_complete->pkt_alignment_factor);\n\t\t}\n\t\tbreak;\n\n\tcase RNDIS_MSG_QUERY_C:\n\t\tif (rndis_msg->msg_len - RNDIS_HEADER_SIZE >=\n\t\t\t\tsizeof(struct rndis_query_complete)) {\n\t\t\tconst struct rndis_query_complete *query_complete =\n\t\t\t\tdata + RNDIS_HEADER_SIZE;\n\t\t\tnetdev_dbg(netdev, \"RNDIS_MSG_QUERY_C \"\n\t\t\t\t\"(len %u, id 0x%x, status 0x%x, buf len %u, \"\n\t\t\t\t\"buf offset %u)\\n\",\n\t\t\t\trndis_msg->msg_len,\n\t\t\t\tquery_complete->req_id,\n\t\t\t\tquery_complete->status,\n\t\t\t\tquery_complete->info_buflen,\n\t\t\t\tquery_complete->info_buf_offset);\n\t\t}\n\t\tbreak;\n\n\tcase RNDIS_MSG_SET_C:\n\t\tif (rndis_msg->msg_len - RNDIS_HEADER_SIZE + sizeof(struct rndis_set_complete)) {\n\t\t\tconst struct rndis_set_complete *set_complete =\n\t\t\t\tdata + RNDIS_HEADER_SIZE;\n\t\t\tnetdev_dbg(netdev,\n\t\t\t\t\"RNDIS_MSG_SET_C (len %u, id 0x%x, status 0x%x)\\n\",\n\t\t\t\trndis_msg->msg_len,\n\t\t\t\tset_complete->req_id,\n\t\t\t\tset_complete->status);\n\t\t}\n\t\tbreak;\n\n\tcase RNDIS_MSG_INDICATE:\n\t\tif (rndis_msg->msg_len - RNDIS_HEADER_SIZE >=\n\t\t\t\tsizeof(struct rndis_indicate_status)) {\n\t\t\tconst struct rndis_indicate_status *indicate_status =\n\t\t\t\tdata + RNDIS_HEADER_SIZE;\n\t\t\tnetdev_dbg(netdev, \"RNDIS_MSG_INDICATE \"\n\t\t\t\t\"(len %u, status 0x%x, buf len %u, buf offset %u)\\n\",\n\t\t\t\trndis_msg->msg_len,\n\t\t\t\tindicate_status->status,\n\t\t\t\tindicate_status->status_buflen,\n\t\t\t\tindicate_status->status_buf_offset);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_dbg(netdev, \"0x%x (len %u)\\n\",\n\t\t\trndis_msg->ndis_msg_type,\n\t\t\trndis_msg->msg_len);\n\t\tbreak;\n\t}\n}\n\nstatic int rndis_filter_send_request(struct rndis_device *dev,\n\t\t\t\t  struct rndis_request *req)\n{\n\tstruct hv_netvsc_packet *packet;\n\tstruct hv_page_buffer page_buf[2];\n\tstruct hv_page_buffer *pb = page_buf;\n\tint ret;\n\n\t \n\tpacket = &req->pkt;\n\n\tpacket->total_data_buflen = req->request_msg.msg_len;\n\tpacket->page_buf_cnt = 1;\n\n\tpb[0].pfn = virt_to_phys(&req->request_msg) >>\n\t\t\t\t\tHV_HYP_PAGE_SHIFT;\n\tpb[0].len = req->request_msg.msg_len;\n\tpb[0].offset = offset_in_hvpage(&req->request_msg);\n\n\t \n\tif (pb[0].offset + pb[0].len > HV_HYP_PAGE_SIZE) {\n\t\tpacket->page_buf_cnt++;\n\t\tpb[0].len = HV_HYP_PAGE_SIZE -\n\t\t\tpb[0].offset;\n\t\tpb[1].pfn = virt_to_phys((void *)&req->request_msg\n\t\t\t+ pb[0].len) >> HV_HYP_PAGE_SHIFT;\n\t\tpb[1].offset = 0;\n\t\tpb[1].len = req->request_msg.msg_len -\n\t\t\tpb[0].len;\n\t}\n\n\ttrace_rndis_send(dev->ndev, 0, &req->request_msg);\n\n\trcu_read_lock_bh();\n\tret = netvsc_send(dev->ndev, packet, NULL, pb, NULL, false);\n\trcu_read_unlock_bh();\n\n\treturn ret;\n}\n\nstatic void rndis_set_link_state(struct rndis_device *rdev,\n\t\t\t\t struct rndis_request *request)\n{\n\tu32 link_status;\n\tstruct rndis_query_complete *query_complete;\n\tu32 msg_len = request->response_msg.msg_len;\n\n\t \n\tif (msg_len - RNDIS_HEADER_SIZE < sizeof(struct rndis_query_complete))\n\t\treturn;\n\n\tquery_complete = &request->response_msg.msg.query_complete;\n\n\tif (query_complete->status == RNDIS_STATUS_SUCCESS &&\n\t    query_complete->info_buflen >= sizeof(u32) &&\n\t    query_complete->info_buf_offset >= sizeof(*query_complete) &&\n\t    msg_len - RNDIS_HEADER_SIZE >= query_complete->info_buf_offset &&\n\t    msg_len - RNDIS_HEADER_SIZE - query_complete->info_buf_offset\n\t\t\t>= query_complete->info_buflen) {\n\t\tmemcpy(&link_status, (void *)((unsigned long)query_complete +\n\t\t       query_complete->info_buf_offset), sizeof(u32));\n\t\trdev->link_state = link_status != 0;\n\t}\n}\n\nstatic void rndis_filter_receive_response(struct net_device *ndev,\n\t\t\t\t\t  struct netvsc_device *nvdev,\n\t\t\t\t\t  struct rndis_message *resp,\n\t\t\t\t\t  void *data)\n{\n\tu32 *req_id = &resp->msg.init_complete.req_id;\n\tstruct rndis_device *dev = nvdev->extension;\n\tstruct rndis_request *request = NULL;\n\tbool found = false;\n\tunsigned long flags;\n\n\t \n\tif (dev->state == RNDIS_DEV_UNINITIALIZED) {\n\t\tnetdev_err(ndev,\n\t\t\t   \"got rndis message uninitialized\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (resp->msg_len - RNDIS_HEADER_SIZE < sizeof(u32)) {\n\t\tnetdev_err(ndev, \"rndis msg_len too small: %u\\n\",\n\t\t\t   resp->msg_len);\n\t\treturn;\n\t}\n\n\t \n\t*req_id = *(u32 *)(data + RNDIS_HEADER_SIZE);\n\n\tspin_lock_irqsave(&dev->request_lock, flags);\n\tlist_for_each_entry(request, &dev->req_list, list_ent) {\n\t\t \n\t\tif (request->request_msg.msg.init_req.req_id == *req_id) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->request_lock, flags);\n\n\tif (found) {\n\t\tif (resp->msg_len <=\n\t\t    sizeof(struct rndis_message) + RNDIS_EXT_LEN) {\n\t\t\tmemcpy(&request->response_msg, resp, RNDIS_HEADER_SIZE + sizeof(*req_id));\n\t\t\tunsafe_memcpy((void *)&request->response_msg + RNDIS_HEADER_SIZE + sizeof(*req_id),\n\t\t\t       data + RNDIS_HEADER_SIZE + sizeof(*req_id),\n\t\t\t       resp->msg_len - RNDIS_HEADER_SIZE - sizeof(*req_id),\n\t\t\t       \"request->response_msg is followed by a padding of RNDIS_EXT_LEN inside rndis_request\");\n\t\t\tif (request->request_msg.ndis_msg_type ==\n\t\t\t    RNDIS_MSG_QUERY && request->request_msg.msg.\n\t\t\t    query_req.oid == RNDIS_OID_GEN_MEDIA_CONNECT_STATUS)\n\t\t\t\trndis_set_link_state(dev, request);\n\t\t} else {\n\t\t\tnetdev_err(ndev,\n\t\t\t\t\"rndis response buffer overflow \"\n\t\t\t\t\"detected (size %u max %zu)\\n\",\n\t\t\t\tresp->msg_len,\n\t\t\t\tsizeof(struct rndis_message));\n\n\t\t\tif (resp->ndis_msg_type ==\n\t\t\t    RNDIS_MSG_RESET_C) {\n\t\t\t\t \n\t\t\t\trequest->response_msg.msg.reset_complete.\n\t\t\t\t\tstatus = RNDIS_STATUS_BUFFER_OVERFLOW;\n\t\t\t} else {\n\t\t\t\trequest->response_msg.msg.\n\t\t\t\tinit_complete.status =\n\t\t\t\t\tRNDIS_STATUS_BUFFER_OVERFLOW;\n\t\t\t}\n\t\t}\n\n\t\tnetvsc_dma_unmap(((struct net_device_context *)\n\t\t\tnetdev_priv(ndev))->device_ctx, &request->pkt);\n\t\tcomplete(&request->wait_event);\n\t} else {\n\t\tnetdev_err(ndev,\n\t\t\t\"no rndis request found for this response \"\n\t\t\t\"(id 0x%x res type 0x%x)\\n\",\n\t\t\t*req_id,\n\t\t\tresp->ndis_msg_type);\n\t}\n}\n\n \nstatic inline void *rndis_get_ppi(struct net_device *ndev,\n\t\t\t\t  struct rndis_packet *rpkt,\n\t\t\t\t  u32 rpkt_len, u32 type, u8 internal,\n\t\t\t\t  u32 ppi_size, void *data)\n{\n\tstruct rndis_per_packet_info *ppi;\n\tint len;\n\n\tif (rpkt->per_pkt_info_offset == 0)\n\t\treturn NULL;\n\n\t \n\tif (rpkt->per_pkt_info_offset < sizeof(struct rndis_packet) ||\n\t    rpkt->per_pkt_info_offset > rpkt_len) {\n\t\tnetdev_err(ndev, \"Invalid per_pkt_info_offset: %u\\n\",\n\t\t\t   rpkt->per_pkt_info_offset);\n\t\treturn NULL;\n\t}\n\n\tif (rpkt->per_pkt_info_len < sizeof(*ppi) ||\n\t    rpkt->per_pkt_info_len > rpkt_len - rpkt->per_pkt_info_offset) {\n\t\tnetdev_err(ndev, \"Invalid per_pkt_info_len: %u\\n\",\n\t\t\t   rpkt->per_pkt_info_len);\n\t\treturn NULL;\n\t}\n\n\tppi = (struct rndis_per_packet_info *)((ulong)rpkt +\n\t\trpkt->per_pkt_info_offset);\n\t \n\tmemcpy(ppi, data + RNDIS_HEADER_SIZE + rpkt->per_pkt_info_offset, rpkt->per_pkt_info_len);\n\tlen = rpkt->per_pkt_info_len;\n\n\twhile (len > 0) {\n\t\t \n\t\tif (ppi->size > len) {\n\t\t\tnetdev_err(ndev, \"Invalid ppi size: %u\\n\", ppi->size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ppi->ppi_offset >= ppi->size) {\n\t\t\tnetdev_err(ndev, \"Invalid ppi_offset: %u\\n\", ppi->ppi_offset);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ppi->type == type && ppi->internal == internal) {\n\t\t\t \n\t\t\tif (ppi->size - ppi->ppi_offset < ppi_size) {\n\t\t\t\tnetdev_err(ndev, \"Invalid ppi: size %u ppi_offset %u\\n\",\n\t\t\t\t\t   ppi->size, ppi->ppi_offset);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn (void *)((ulong)ppi + ppi->ppi_offset);\n\t\t}\n\t\tlen -= ppi->size;\n\t\tppi = (struct rndis_per_packet_info *)((ulong)ppi + ppi->size);\n\t}\n\n\treturn NULL;\n}\n\nstatic inline\nvoid rsc_add_data(struct netvsc_channel *nvchan,\n\t\t  const struct ndis_pkt_8021q_info *vlan,\n\t\t  const struct ndis_tcp_ip_checksum_info *csum_info,\n\t\t  const u32 *hash_info,\n\t\t  void *data, u32 len)\n{\n\tu32 cnt = nvchan->rsc.cnt;\n\n\tif (cnt) {\n\t\tnvchan->rsc.pktlen += len;\n\t} else {\n\t\t \n\t\tif (vlan != NULL) {\n\t\t\tmemcpy(&nvchan->rsc.vlan, vlan, sizeof(*vlan));\n\t\t\tnvchan->rsc.ppi_flags |= NVSC_RSC_VLAN;\n\t\t} else {\n\t\t\tnvchan->rsc.ppi_flags &= ~NVSC_RSC_VLAN;\n\t\t}\n\t\tif (csum_info != NULL) {\n\t\t\tmemcpy(&nvchan->rsc.csum_info, csum_info, sizeof(*csum_info));\n\t\t\tnvchan->rsc.ppi_flags |= NVSC_RSC_CSUM_INFO;\n\t\t} else {\n\t\t\tnvchan->rsc.ppi_flags &= ~NVSC_RSC_CSUM_INFO;\n\t\t}\n\t\tnvchan->rsc.pktlen = len;\n\t\tif (hash_info != NULL) {\n\t\t\tnvchan->rsc.hash_info = *hash_info;\n\t\t\tnvchan->rsc.ppi_flags |= NVSC_RSC_HASH_INFO;\n\t\t} else {\n\t\t\tnvchan->rsc.ppi_flags &= ~NVSC_RSC_HASH_INFO;\n\t\t}\n\t}\n\n\tnvchan->rsc.data[cnt] = data;\n\tnvchan->rsc.len[cnt] = len;\n\tnvchan->rsc.cnt++;\n}\n\nstatic int rndis_filter_receive_data(struct net_device *ndev,\n\t\t\t\t     struct netvsc_device *nvdev,\n\t\t\t\t     struct netvsc_channel *nvchan,\n\t\t\t\t     struct rndis_message *msg,\n\t\t\t\t     void *data, u32 data_buflen)\n{\n\tstruct rndis_packet *rndis_pkt = &msg->msg.pkt;\n\tconst struct ndis_tcp_ip_checksum_info *csum_info;\n\tconst struct ndis_pkt_8021q_info *vlan;\n\tconst struct rndis_pktinfo_id *pktinfo_id;\n\tconst u32 *hash_info;\n\tu32 data_offset, rpkt_len;\n\tbool rsc_more = false;\n\tint ret;\n\n\t \n\tif (data_buflen < RNDIS_HEADER_SIZE + sizeof(struct rndis_packet)) {\n\t\tnetdev_err(ndev, \"invalid rndis pkt, data_buflen too small: %u\\n\",\n\t\t\t   data_buflen);\n\t\treturn NVSP_STAT_FAIL;\n\t}\n\n\t \n\tmemcpy(rndis_pkt, data + RNDIS_HEADER_SIZE, sizeof(*rndis_pkt));\n\n\t \n\tif (rndis_pkt->data_offset >= data_buflen - RNDIS_HEADER_SIZE) {\n\t\tnetdev_err(ndev, \"invalid rndis packet offset: %u\\n\",\n\t\t\t   rndis_pkt->data_offset);\n\t\treturn NVSP_STAT_FAIL;\n\t}\n\n\t \n\tdata_offset = RNDIS_HEADER_SIZE + rndis_pkt->data_offset;\n\n\trpkt_len = data_buflen - RNDIS_HEADER_SIZE;\n\tdata_buflen -= data_offset;\n\n\t \n\tif (unlikely(data_buflen < rndis_pkt->data_len)) {\n\t\tnetdev_err(ndev, \"rndis message buffer \"\n\t\t\t   \"overflow detected (got %u, min %u)\"\n\t\t\t   \"...dropping this message!\\n\",\n\t\t\t   data_buflen, rndis_pkt->data_len);\n\t\treturn NVSP_STAT_FAIL;\n\t}\n\n\tvlan = rndis_get_ppi(ndev, rndis_pkt, rpkt_len, IEEE_8021Q_INFO, 0, sizeof(*vlan),\n\t\t\t     data);\n\n\tcsum_info = rndis_get_ppi(ndev, rndis_pkt, rpkt_len, TCPIP_CHKSUM_PKTINFO, 0,\n\t\t\t\t  sizeof(*csum_info), data);\n\n\thash_info = rndis_get_ppi(ndev, rndis_pkt, rpkt_len, NBL_HASH_VALUE, 0,\n\t\t\t\t  sizeof(*hash_info), data);\n\n\tpktinfo_id = rndis_get_ppi(ndev, rndis_pkt, rpkt_len, RNDIS_PKTINFO_ID, 1,\n\t\t\t\t   sizeof(*pktinfo_id), data);\n\n\t \n\tif (pktinfo_id && (pktinfo_id->flag & RNDIS_PKTINFO_SUBALLOC)) {\n\t\tif (pktinfo_id->flag & RNDIS_PKTINFO_1ST_FRAG)\n\t\t\tnvchan->rsc.cnt = 0;\n\t\telse if (nvchan->rsc.cnt == 0)\n\t\t\tgoto drop;\n\n\t\trsc_more = true;\n\n\t\tif (pktinfo_id->flag & RNDIS_PKTINFO_LAST_FRAG)\n\t\t\trsc_more = false;\n\n\t\tif (rsc_more && nvchan->rsc.is_last)\n\t\t\tgoto drop;\n\t} else {\n\t\tnvchan->rsc.cnt = 0;\n\t}\n\n\tif (unlikely(nvchan->rsc.cnt >= NVSP_RSC_MAX))\n\t\tgoto drop;\n\n\t \n\trsc_add_data(nvchan, vlan, csum_info, hash_info,\n\t\t     data + data_offset, rndis_pkt->data_len);\n\n\tif (rsc_more)\n\t\treturn NVSP_STAT_SUCCESS;\n\n\tret = netvsc_recv_callback(ndev, nvdev, nvchan);\n\tnvchan->rsc.cnt = 0;\n\n\treturn ret;\n\ndrop:\n\treturn NVSP_STAT_FAIL;\n}\n\nint rndis_filter_receive(struct net_device *ndev,\n\t\t\t struct netvsc_device *net_dev,\n\t\t\t struct netvsc_channel *nvchan,\n\t\t\t void *data, u32 buflen)\n{\n\tstruct net_device_context *net_device_ctx = netdev_priv(ndev);\n\tstruct rndis_message *rndis_msg = nvchan->recv_buf;\n\n\tif (buflen < RNDIS_HEADER_SIZE) {\n\t\tnetdev_err(ndev, \"Invalid rndis_msg (buflen: %u)\\n\", buflen);\n\t\treturn NVSP_STAT_FAIL;\n\t}\n\n\t \n\tmemcpy(rndis_msg, data, RNDIS_HEADER_SIZE);\n\n\t \n\tif (rndis_msg->msg_len < RNDIS_HEADER_SIZE ||\n\t    buflen < rndis_msg->msg_len) {\n\t\tnetdev_err(ndev, \"Invalid rndis_msg (buflen: %u, msg_len: %u)\\n\",\n\t\t\t   buflen, rndis_msg->msg_len);\n\t\treturn NVSP_STAT_FAIL;\n\t}\n\n\tif (netif_msg_rx_status(net_device_ctx))\n\t\tdump_rndis_message(ndev, rndis_msg, data);\n\n\tswitch (rndis_msg->ndis_msg_type) {\n\tcase RNDIS_MSG_PACKET:\n\t\treturn rndis_filter_receive_data(ndev, net_dev, nvchan,\n\t\t\t\t\t\t rndis_msg, data, buflen);\n\tcase RNDIS_MSG_INIT_C:\n\tcase RNDIS_MSG_QUERY_C:\n\tcase RNDIS_MSG_SET_C:\n\t\t \n\t\trndis_filter_receive_response(ndev, net_dev, rndis_msg, data);\n\t\tbreak;\n\n\tcase RNDIS_MSG_INDICATE:\n\t\t \n\t\tnetvsc_linkstatus_callback(ndev, rndis_msg, data, buflen);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(ndev,\n\t\t\t\"unhandled rndis message (type %u len %u)\\n\",\n\t\t\t   rndis_msg->ndis_msg_type,\n\t\t\t   rndis_msg->msg_len);\n\t\treturn NVSP_STAT_FAIL;\n\t}\n\n\treturn NVSP_STAT_SUCCESS;\n}\n\nstatic int rndis_filter_query_device(struct rndis_device *dev,\n\t\t\t\t     struct netvsc_device *nvdev,\n\t\t\t\t     u32 oid, void *result, u32 *result_size)\n{\n\tstruct rndis_request *request;\n\tu32 inresult_size = *result_size;\n\tstruct rndis_query_request *query;\n\tstruct rndis_query_complete *query_complete;\n\tu32 msg_len;\n\tint ret = 0;\n\n\tif (!result)\n\t\treturn -EINVAL;\n\n\t*result_size = 0;\n\trequest = get_rndis_request(dev, RNDIS_MSG_QUERY,\n\t\t\tRNDIS_MESSAGE_SIZE(struct rndis_query_request));\n\tif (!request) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tquery = &request->request_msg.msg.query_req;\n\tquery->oid = oid;\n\tquery->info_buf_offset = sizeof(struct rndis_query_request);\n\tquery->info_buflen = 0;\n\tquery->dev_vc_handle = 0;\n\n\tif (oid == OID_TCP_OFFLOAD_HARDWARE_CAPABILITIES) {\n\t\tstruct ndis_offload *hwcaps;\n\t\tu32 nvsp_version = nvdev->nvsp_version;\n\t\tu8 ndis_rev;\n\t\tsize_t size;\n\n\t\tif (nvsp_version >= NVSP_PROTOCOL_VERSION_5) {\n\t\t\tndis_rev = NDIS_OFFLOAD_PARAMETERS_REVISION_3;\n\t\t\tsize = NDIS_OFFLOAD_SIZE;\n\t\t} else if (nvsp_version >= NVSP_PROTOCOL_VERSION_4) {\n\t\t\tndis_rev = NDIS_OFFLOAD_PARAMETERS_REVISION_2;\n\t\t\tsize = NDIS_OFFLOAD_SIZE_6_1;\n\t\t} else {\n\t\t\tndis_rev = NDIS_OFFLOAD_PARAMETERS_REVISION_1;\n\t\t\tsize = NDIS_OFFLOAD_SIZE_6_0;\n\t\t}\n\n\t\trequest->request_msg.msg_len += size;\n\t\tquery->info_buflen = size;\n\t\thwcaps = (struct ndis_offload *)\n\t\t\t((unsigned long)query + query->info_buf_offset);\n\n\t\thwcaps->header.type = NDIS_OBJECT_TYPE_OFFLOAD;\n\t\thwcaps->header.revision = ndis_rev;\n\t\thwcaps->header.size = size;\n\n\t} else if (oid == OID_GEN_RECEIVE_SCALE_CAPABILITIES) {\n\t\tstruct ndis_recv_scale_cap *cap;\n\n\t\trequest->request_msg.msg_len +=\n\t\t\tsizeof(struct ndis_recv_scale_cap);\n\t\tquery->info_buflen = sizeof(struct ndis_recv_scale_cap);\n\t\tcap = (struct ndis_recv_scale_cap *)((unsigned long)query +\n\t\t\t\t\t\t     query->info_buf_offset);\n\t\tcap->hdr.type = NDIS_OBJECT_TYPE_RSS_CAPABILITIES;\n\t\tcap->hdr.rev = NDIS_RECEIVE_SCALE_CAPABILITIES_REVISION_2;\n\t\tcap->hdr.size = sizeof(struct ndis_recv_scale_cap);\n\t}\n\n\tret = rndis_filter_send_request(dev, request);\n\tif (ret != 0)\n\t\tgoto cleanup;\n\n\twait_for_completion(&request->wait_event);\n\n\t \n\tquery_complete = &request->response_msg.msg.query_complete;\n\tmsg_len = request->response_msg.msg_len;\n\n\t \n\tif (msg_len - RNDIS_HEADER_SIZE < sizeof(struct rndis_query_complete)) {\n\t\tret = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (query_complete->info_buflen > inresult_size ||\n\t    query_complete->info_buf_offset < sizeof(*query_complete) ||\n\t    msg_len - RNDIS_HEADER_SIZE < query_complete->info_buf_offset ||\n\t    msg_len - RNDIS_HEADER_SIZE - query_complete->info_buf_offset\n\t\t\t< query_complete->info_buflen) {\n\t\tret = -1;\n\t\tgoto cleanup;\n\t}\n\n\tmemcpy(result,\n\t       (void *)((unsigned long)query_complete +\n\t\t\t query_complete->info_buf_offset),\n\t       query_complete->info_buflen);\n\n\t*result_size = query_complete->info_buflen;\n\ncleanup:\n\tif (request)\n\t\tput_rndis_request(dev, request);\n\n\treturn ret;\n}\n\n \nstatic int\nrndis_query_hwcaps(struct rndis_device *dev, struct netvsc_device *net_device,\n\t\t   struct ndis_offload *caps)\n{\n\tu32 caps_len = sizeof(*caps);\n\tint ret;\n\n\tmemset(caps, 0, sizeof(*caps));\n\n\tret = rndis_filter_query_device(dev, net_device,\n\t\t\t\t\tOID_TCP_OFFLOAD_HARDWARE_CAPABILITIES,\n\t\t\t\t\tcaps, &caps_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (caps->header.type != NDIS_OBJECT_TYPE_OFFLOAD) {\n\t\tnetdev_warn(dev->ndev, \"invalid NDIS objtype %#x\\n\",\n\t\t\t    caps->header.type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (caps->header.revision < NDIS_OFFLOAD_PARAMETERS_REVISION_1) {\n\t\tnetdev_warn(dev->ndev, \"invalid NDIS objrev %x\\n\",\n\t\t\t    caps->header.revision);\n\t\treturn -EINVAL;\n\t}\n\n\tif (caps->header.size > caps_len ||\n\t    caps->header.size < NDIS_OFFLOAD_SIZE_6_0) {\n\t\tnetdev_warn(dev->ndev,\n\t\t\t    \"invalid NDIS objsize %u, data size %u\\n\",\n\t\t\t    caps->header.size, caps_len);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rndis_filter_query_device_mac(struct rndis_device *dev,\n\t\t\t\t\t struct netvsc_device *net_device)\n{\n\tu32 size = ETH_ALEN;\n\n\treturn rndis_filter_query_device(dev, net_device,\n\t\t\t\t      RNDIS_OID_802_3_PERMANENT_ADDRESS,\n\t\t\t\t      dev->hw_mac_adr, &size);\n}\n\n#define NWADR_STR \"NetworkAddress\"\n#define NWADR_STRLEN 14\n\nint rndis_filter_set_device_mac(struct netvsc_device *nvdev,\n\t\t\t\tconst char *mac)\n{\n\tstruct rndis_device *rdev = nvdev->extension;\n\tstruct rndis_request *request;\n\tstruct rndis_set_request *set;\n\tstruct rndis_config_parameter_info *cpi;\n\twchar_t *cfg_nwadr, *cfg_mac;\n\tstruct rndis_set_complete *set_complete;\n\tchar macstr[2*ETH_ALEN+1];\n\tu32 extlen = sizeof(struct rndis_config_parameter_info) +\n\t\t2*NWADR_STRLEN + 4*ETH_ALEN;\n\tint ret;\n\n\trequest = get_rndis_request(rdev, RNDIS_MSG_SET,\n\t\tRNDIS_MESSAGE_SIZE(struct rndis_set_request) + extlen);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tset = &request->request_msg.msg.set_req;\n\tset->oid = RNDIS_OID_GEN_RNDIS_CONFIG_PARAMETER;\n\tset->info_buflen = extlen;\n\tset->info_buf_offset = sizeof(struct rndis_set_request);\n\tset->dev_vc_handle = 0;\n\n\tcpi = (struct rndis_config_parameter_info *)((ulong)set +\n\t\tset->info_buf_offset);\n\tcpi->parameter_name_offset =\n\t\tsizeof(struct rndis_config_parameter_info);\n\t \n\tcpi->parameter_name_length = 2*NWADR_STRLEN;\n\tcpi->parameter_type = RNDIS_CONFIG_PARAM_TYPE_STRING;\n\tcpi->parameter_value_offset =\n\t\tcpi->parameter_name_offset + cpi->parameter_name_length;\n\t \n\tcpi->parameter_value_length = 4*ETH_ALEN;\n\n\tcfg_nwadr = (wchar_t *)((ulong)cpi + cpi->parameter_name_offset);\n\tcfg_mac = (wchar_t *)((ulong)cpi + cpi->parameter_value_offset);\n\tret = utf8s_to_utf16s(NWADR_STR, NWADR_STRLEN, UTF16_HOST_ENDIAN,\n\t\t\t      cfg_nwadr, NWADR_STRLEN);\n\tif (ret < 0)\n\t\tgoto cleanup;\n\tsnprintf(macstr, 2*ETH_ALEN+1, \"%pm\", mac);\n\tret = utf8s_to_utf16s(macstr, 2*ETH_ALEN, UTF16_HOST_ENDIAN,\n\t\t\t      cfg_mac, 2*ETH_ALEN);\n\tif (ret < 0)\n\t\tgoto cleanup;\n\n\tret = rndis_filter_send_request(rdev, request);\n\tif (ret != 0)\n\t\tgoto cleanup;\n\n\twait_for_completion(&request->wait_event);\n\n\tset_complete = &request->response_msg.msg.set_complete;\n\tif (set_complete->status != RNDIS_STATUS_SUCCESS)\n\t\tret = -EIO;\n\ncleanup:\n\tput_rndis_request(rdev, request);\n\treturn ret;\n}\n\nint\nrndis_filter_set_offload_params(struct net_device *ndev,\n\t\t\t\tstruct netvsc_device *nvdev,\n\t\t\t\tstruct ndis_offload_params *req_offloads)\n{\n\tstruct rndis_device *rdev = nvdev->extension;\n\tstruct rndis_request *request;\n\tstruct rndis_set_request *set;\n\tstruct ndis_offload_params *offload_params;\n\tstruct rndis_set_complete *set_complete;\n\tu32 extlen = sizeof(struct ndis_offload_params);\n\tint ret;\n\tu32 vsp_version = nvdev->nvsp_version;\n\n\tif (vsp_version <= NVSP_PROTOCOL_VERSION_4) {\n\t\textlen = VERSION_4_OFFLOAD_SIZE;\n\t\t \n\t\treq_offloads->udp_ip_v4_csum = 0;\n\t\treq_offloads->udp_ip_v6_csum = 0;\n\t}\n\n\trequest = get_rndis_request(rdev, RNDIS_MSG_SET,\n\t\tRNDIS_MESSAGE_SIZE(struct rndis_set_request) + extlen);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tset = &request->request_msg.msg.set_req;\n\tset->oid = OID_TCP_OFFLOAD_PARAMETERS;\n\tset->info_buflen = extlen;\n\tset->info_buf_offset = sizeof(struct rndis_set_request);\n\tset->dev_vc_handle = 0;\n\n\toffload_params = (struct ndis_offload_params *)((ulong)set +\n\t\t\t\tset->info_buf_offset);\n\t*offload_params = *req_offloads;\n\toffload_params->header.type = NDIS_OBJECT_TYPE_DEFAULT;\n\toffload_params->header.revision = NDIS_OFFLOAD_PARAMETERS_REVISION_3;\n\toffload_params->header.size = extlen;\n\n\tret = rndis_filter_send_request(rdev, request);\n\tif (ret != 0)\n\t\tgoto cleanup;\n\n\twait_for_completion(&request->wait_event);\n\tset_complete = &request->response_msg.msg.set_complete;\n\tif (set_complete->status != RNDIS_STATUS_SUCCESS) {\n\t\tnetdev_err(ndev, \"Fail to set offload on host side:0x%x\\n\",\n\t\t\t   set_complete->status);\n\t\tret = -EINVAL;\n\t}\n\ncleanup:\n\tput_rndis_request(rdev, request);\n\treturn ret;\n}\n\nstatic int rndis_set_rss_param_msg(struct rndis_device *rdev,\n\t\t\t\t   const u8 *rss_key, u16 flag)\n{\n\tstruct net_device *ndev = rdev->ndev;\n\tstruct net_device_context *ndc = netdev_priv(ndev);\n\tstruct rndis_request *request;\n\tstruct rndis_set_request *set;\n\tstruct rndis_set_complete *set_complete;\n\tu32 extlen = sizeof(struct ndis_recv_scale_param) +\n\t\t     4 * ndc->rx_table_sz + NETVSC_HASH_KEYLEN;\n\tstruct ndis_recv_scale_param *rssp;\n\tu32 *itab;\n\tu8 *keyp;\n\tint i, ret;\n\n\trequest = get_rndis_request(\n\t\t\trdev, RNDIS_MSG_SET,\n\t\t\tRNDIS_MESSAGE_SIZE(struct rndis_set_request) + extlen);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tset = &request->request_msg.msg.set_req;\n\tset->oid = OID_GEN_RECEIVE_SCALE_PARAMETERS;\n\tset->info_buflen = extlen;\n\tset->info_buf_offset = sizeof(struct rndis_set_request);\n\tset->dev_vc_handle = 0;\n\n\trssp = (struct ndis_recv_scale_param *)(set + 1);\n\trssp->hdr.type = NDIS_OBJECT_TYPE_RSS_PARAMETERS;\n\trssp->hdr.rev = NDIS_RECEIVE_SCALE_PARAMETERS_REVISION_2;\n\trssp->hdr.size = sizeof(struct ndis_recv_scale_param);\n\trssp->flag = flag;\n\trssp->hashinfo = NDIS_HASH_FUNC_TOEPLITZ | NDIS_HASH_IPV4 |\n\t\t\t NDIS_HASH_TCP_IPV4 | NDIS_HASH_IPV6 |\n\t\t\t NDIS_HASH_TCP_IPV6;\n\trssp->indirect_tabsize = 4 * ndc->rx_table_sz;\n\trssp->indirect_taboffset = sizeof(struct ndis_recv_scale_param);\n\trssp->hashkey_size = NETVSC_HASH_KEYLEN;\n\trssp->hashkey_offset = rssp->indirect_taboffset +\n\t\t\t       rssp->indirect_tabsize;\n\n\t \n\titab = (u32 *)(rssp + 1);\n\tfor (i = 0; i < ndc->rx_table_sz; i++)\n\t\titab[i] = ndc->rx_table[i];\n\n\t \n\tkeyp = (u8 *)((unsigned long)rssp + rssp->hashkey_offset);\n\tmemcpy(keyp, rss_key, NETVSC_HASH_KEYLEN);\n\n\tret = rndis_filter_send_request(rdev, request);\n\tif (ret != 0)\n\t\tgoto cleanup;\n\n\twait_for_completion(&request->wait_event);\n\tset_complete = &request->response_msg.msg.set_complete;\n\tif (set_complete->status == RNDIS_STATUS_SUCCESS) {\n\t\tif (!(flag & NDIS_RSS_PARAM_FLAG_DISABLE_RSS) &&\n\t\t    !(flag & NDIS_RSS_PARAM_FLAG_HASH_KEY_UNCHANGED))\n\t\t\tmemcpy(rdev->rss_key, rss_key, NETVSC_HASH_KEYLEN);\n\n\t} else {\n\t\tnetdev_err(ndev, \"Fail to set RSS parameters:0x%x\\n\",\n\t\t\t   set_complete->status);\n\t\tret = -EINVAL;\n\t}\n\ncleanup:\n\tput_rndis_request(rdev, request);\n\treturn ret;\n}\n\nint rndis_filter_set_rss_param(struct rndis_device *rdev,\n\t\t\t       const u8 *rss_key)\n{\n\t \n\trndis_set_rss_param_msg(rdev, rss_key,\n\t\t\t\tNDIS_RSS_PARAM_FLAG_DISABLE_RSS);\n\n\treturn rndis_set_rss_param_msg(rdev, rss_key, 0);\n}\n\nstatic int rndis_filter_query_device_link_status(struct rndis_device *dev,\n\t\t\t\t\t\t struct netvsc_device *net_device)\n{\n\tu32 size = sizeof(u32);\n\tu32 link_status;\n\n\treturn rndis_filter_query_device(dev, net_device,\n\t\t\t\t\t RNDIS_OID_GEN_MEDIA_CONNECT_STATUS,\n\t\t\t\t\t &link_status, &size);\n}\n\nstatic int rndis_filter_query_link_speed(struct rndis_device *dev,\n\t\t\t\t\t struct netvsc_device *net_device)\n{\n\tu32 size = sizeof(u32);\n\tu32 link_speed;\n\tstruct net_device_context *ndc;\n\tint ret;\n\n\tret = rndis_filter_query_device(dev, net_device,\n\t\t\t\t\tRNDIS_OID_GEN_LINK_SPEED,\n\t\t\t\t\t&link_speed, &size);\n\n\tif (!ret) {\n\t\tndc = netdev_priv(dev->ndev);\n\n\t\t \n\t\tndc->speed = link_speed / 10000;\n\t}\n\n\treturn ret;\n}\n\nstatic int rndis_filter_set_packet_filter(struct rndis_device *dev,\n\t\t\t\t\t  u32 new_filter)\n{\n\tstruct rndis_request *request;\n\tstruct rndis_set_request *set;\n\tint ret;\n\n\tif (dev->filter == new_filter)\n\t\treturn 0;\n\n\trequest = get_rndis_request(dev, RNDIS_MSG_SET,\n\t\t\tRNDIS_MESSAGE_SIZE(struct rndis_set_request) +\n\t\t\tsizeof(u32));\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\t \n\tset = &request->request_msg.msg.set_req;\n\tset->oid = RNDIS_OID_GEN_CURRENT_PACKET_FILTER;\n\tset->info_buflen = sizeof(u32);\n\tset->info_buf_offset = offsetof(typeof(*set), info_buf);\n\tmemcpy(set->info_buf, &new_filter, sizeof(u32));\n\n\tret = rndis_filter_send_request(dev, request);\n\tif (ret == 0) {\n\t\twait_for_completion(&request->wait_event);\n\t\tdev->filter = new_filter;\n\t}\n\n\tput_rndis_request(dev, request);\n\n\treturn ret;\n}\n\nstatic void rndis_set_multicast(struct work_struct *w)\n{\n\tstruct rndis_device *rdev\n\t\t= container_of(w, struct rndis_device, mcast_work);\n\tu32 filter = NDIS_PACKET_TYPE_DIRECTED;\n\tunsigned int flags = rdev->ndev->flags;\n\n\tif (flags & IFF_PROMISC) {\n\t\tfilter = NDIS_PACKET_TYPE_PROMISCUOUS;\n\t} else {\n\t\tif (!netdev_mc_empty(rdev->ndev) || (flags & IFF_ALLMULTI))\n\t\t\tfilter |= NDIS_PACKET_TYPE_ALL_MULTICAST;\n\t\tif (flags & IFF_BROADCAST)\n\t\t\tfilter |= NDIS_PACKET_TYPE_BROADCAST;\n\t}\n\n\trndis_filter_set_packet_filter(rdev, filter);\n}\n\nvoid rndis_filter_update(struct netvsc_device *nvdev)\n{\n\tstruct rndis_device *rdev = nvdev->extension;\n\n\tschedule_work(&rdev->mcast_work);\n}\n\nstatic int rndis_filter_init_device(struct rndis_device *dev,\n\t\t\t\t    struct netvsc_device *nvdev)\n{\n\tstruct rndis_request *request;\n\tstruct rndis_initialize_request *init;\n\tstruct rndis_initialize_complete *init_complete;\n\tu32 status;\n\tint ret;\n\n\trequest = get_rndis_request(dev, RNDIS_MSG_INIT,\n\t\t\tRNDIS_MESSAGE_SIZE(struct rndis_initialize_request));\n\tif (!request) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tinit = &request->request_msg.msg.init_req;\n\tinit->major_ver = RNDIS_MAJOR_VERSION;\n\tinit->minor_ver = RNDIS_MINOR_VERSION;\n\tinit->max_xfer_size = 0x4000;\n\n\tdev->state = RNDIS_DEV_INITIALIZING;\n\n\tret = rndis_filter_send_request(dev, request);\n\tif (ret != 0) {\n\t\tdev->state = RNDIS_DEV_UNINITIALIZED;\n\t\tgoto cleanup;\n\t}\n\n\twait_for_completion(&request->wait_event);\n\n\tinit_complete = &request->response_msg.msg.init_complete;\n\tstatus = init_complete->status;\n\tif (status == RNDIS_STATUS_SUCCESS) {\n\t\tdev->state = RNDIS_DEV_INITIALIZED;\n\t\tnvdev->max_pkt = init_complete->max_pkt_per_msg;\n\t\tnvdev->pkt_align = 1 << init_complete->pkt_alignment_factor;\n\t\tret = 0;\n\t} else {\n\t\tdev->state = RNDIS_DEV_UNINITIALIZED;\n\t\tret = -EINVAL;\n\t}\n\ncleanup:\n\tif (request)\n\t\tput_rndis_request(dev, request);\n\n\treturn ret;\n}\n\nstatic bool netvsc_device_idle(const struct netvsc_device *nvdev)\n{\n\tint i;\n\n\tfor (i = 0; i < nvdev->num_chn; i++) {\n\t\tconst struct netvsc_channel *nvchan = &nvdev->chan_table[i];\n\n\t\tif (nvchan->mrc.first != nvchan->mrc.next)\n\t\t\treturn false;\n\n\t\tif (atomic_read(&nvchan->queue_sends) > 0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void rndis_filter_halt_device(struct netvsc_device *nvdev,\n\t\t\t\t     struct rndis_device *dev)\n{\n\tstruct rndis_request *request;\n\tstruct rndis_halt_request *halt;\n\n\t \n\trequest = get_rndis_request(dev, RNDIS_MSG_HALT,\n\t\t\t\tRNDIS_MESSAGE_SIZE(struct rndis_halt_request));\n\tif (!request)\n\t\tgoto cleanup;\n\n\t \n\thalt = &request->request_msg.msg.halt_req;\n\thalt->req_id = atomic_inc_return(&dev->new_req_id);\n\n\t \n\trndis_filter_send_request(dev, request);\n\n\tdev->state = RNDIS_DEV_UNINITIALIZED;\n\ncleanup:\n\tnvdev->destroy = true;\n\n\t \n\twmb();\n\n\t \n\twait_event(nvdev->wait_drain, netvsc_device_idle(nvdev));\n\n\tif (request)\n\t\tput_rndis_request(dev, request);\n}\n\nstatic int rndis_filter_open_device(struct rndis_device *dev)\n{\n\tint ret;\n\n\tif (dev->state != RNDIS_DEV_INITIALIZED)\n\t\treturn 0;\n\n\tret = rndis_filter_set_packet_filter(dev,\n\t\t\t\t\t NDIS_PACKET_TYPE_BROADCAST |\n\t\t\t\t\t NDIS_PACKET_TYPE_ALL_MULTICAST |\n\t\t\t\t\t NDIS_PACKET_TYPE_DIRECTED);\n\tif (ret == 0)\n\t\tdev->state = RNDIS_DEV_DATAINITIALIZED;\n\n\treturn ret;\n}\n\nstatic int rndis_filter_close_device(struct rndis_device *dev)\n{\n\tint ret;\n\n\tif (dev->state != RNDIS_DEV_DATAINITIALIZED)\n\t\treturn 0;\n\n\t \n\tcancel_work_sync(&dev->mcast_work);\n\n\tret = rndis_filter_set_packet_filter(dev, 0);\n\tif (ret == -ENODEV)\n\t\tret = 0;\n\n\tif (ret == 0)\n\t\tdev->state = RNDIS_DEV_INITIALIZED;\n\n\treturn ret;\n}\n\nstatic void netvsc_sc_open(struct vmbus_channel *new_sc)\n{\n\tstruct net_device *ndev =\n\t\thv_get_drvdata(new_sc->primary_channel->device_obj);\n\tstruct net_device_context *ndev_ctx = netdev_priv(ndev);\n\tstruct netvsc_device *nvscdev;\n\tu16 chn_index = new_sc->offermsg.offer.sub_channel_index;\n\tstruct netvsc_channel *nvchan;\n\tint ret;\n\n\t \n\tnvscdev = rcu_dereference_raw(ndev_ctx->nvdev);\n\tif (!nvscdev || chn_index >= nvscdev->num_chn)\n\t\treturn;\n\n\tnvchan = nvscdev->chan_table + chn_index;\n\n\t \n\tset_channel_read_mode(new_sc, HV_CALL_ISR);\n\n\t \n\tnvchan->channel = new_sc;\n\n\tnew_sc->next_request_id_callback = vmbus_next_request_id;\n\tnew_sc->request_addr_callback = vmbus_request_addr;\n\tnew_sc->rqstor_size = netvsc_rqstor_size(netvsc_ring_bytes);\n\tnew_sc->max_pkt_size = NETVSC_MAX_PKT_SIZE;\n\n\tret = vmbus_open(new_sc, netvsc_ring_bytes,\n\t\t\t netvsc_ring_bytes, NULL, 0,\n\t\t\t netvsc_channel_cb, nvchan);\n\tif (ret == 0)\n\t\tnapi_enable(&nvchan->napi);\n\telse\n\t\tnetdev_notice(ndev, \"sub channel open failed: %d\\n\", ret);\n\n\tif (atomic_inc_return(&nvscdev->open_chn) == nvscdev->num_chn)\n\t\twake_up(&nvscdev->subchan_open);\n}\n\n \nint rndis_set_subchannel(struct net_device *ndev,\n\t\t\t struct netvsc_device *nvdev,\n\t\t\t struct netvsc_device_info *dev_info)\n{\n\tstruct nvsp_message *init_packet = &nvdev->channel_init_pkt;\n\tstruct net_device_context *ndev_ctx = netdev_priv(ndev);\n\tstruct hv_device *hv_dev = ndev_ctx->device_ctx;\n\tstruct rndis_device *rdev = nvdev->extension;\n\tint i, ret;\n\n\tASSERT_RTNL();\n\n\tmemset(init_packet, 0, sizeof(struct nvsp_message));\n\tinit_packet->hdr.msg_type = NVSP_MSG5_TYPE_SUBCHANNEL;\n\tinit_packet->msg.v5_msg.subchn_req.op = NVSP_SUBCHANNEL_ALLOCATE;\n\tinit_packet->msg.v5_msg.subchn_req.num_subchannels =\n\t\t\t\t\t\tnvdev->num_chn - 1;\n\ttrace_nvsp_send(ndev, init_packet);\n\n\tret = vmbus_sendpacket(hv_dev->channel, init_packet,\n\t\t\t       sizeof(struct nvsp_message),\n\t\t\t       (unsigned long)init_packet,\n\t\t\t       VM_PKT_DATA_INBAND,\n\t\t\t       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"sub channel allocate send failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twait_for_completion(&nvdev->channel_init_wait);\n\tif (init_packet->msg.v5_msg.subchn_comp.status != NVSP_STAT_SUCCESS) {\n\t\tnetdev_err(ndev, \"sub channel request failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (init_packet->msg.v5_msg.subchn_comp.num_subchannels > nvdev->num_chn - 1) {\n\t\tnetdev_err(ndev, \"invalid number of allocated sub channel\\n\");\n\t\treturn -EINVAL;\n\t}\n\tnvdev->num_chn = 1 +\n\t\tinit_packet->msg.v5_msg.subchn_comp.num_subchannels;\n\n\t \n\twait_event(nvdev->subchan_open,\n\t\t   atomic_read(&nvdev->open_chn) == nvdev->num_chn);\n\n\tfor (i = 0; i < VRSS_SEND_TAB_SIZE; i++)\n\t\tndev_ctx->tx_table[i] = i % nvdev->num_chn;\n\n\t \n\tif (dev_info)\n\t\trndis_filter_set_rss_param(rdev, dev_info->rss_key);\n\telse\n\t\trndis_filter_set_rss_param(rdev, netvsc_hash_key);\n\n\tnetif_set_real_num_tx_queues(ndev, nvdev->num_chn);\n\tnetif_set_real_num_rx_queues(ndev, nvdev->num_chn);\n\n\treturn 0;\n}\n\nstatic int rndis_netdev_set_hwcaps(struct rndis_device *rndis_device,\n\t\t\t\t   struct netvsc_device *nvdev)\n{\n\tstruct net_device *net = rndis_device->ndev;\n\tstruct net_device_context *net_device_ctx = netdev_priv(net);\n\tstruct ndis_offload hwcaps;\n\tstruct ndis_offload_params offloads;\n\tunsigned int gso_max_size = GSO_LEGACY_MAX_SIZE;\n\tint ret;\n\n\t \n\tret = rndis_query_hwcaps(rndis_device, nvdev, &hwcaps);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tmemset(&offloads, 0, sizeof(struct ndis_offload_params));\n\n\t \n\toffloads.ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_DISABLED;\n\n\t \n\tnet->hw_features &= ~NETVSC_SUPPORTED_HW_FEATURES;\n\tnet_device_ctx->tx_checksum_mask = 0;\n\n\t \n\tnet->hw_features |= NETIF_F_RXCSUM;\n\tnet->hw_features |= NETIF_F_SG;\n\tnet->hw_features |= NETIF_F_RXHASH;\n\n\tif ((hwcaps.csum.ip4_txcsum & NDIS_TXCSUM_ALL_TCP4) == NDIS_TXCSUM_ALL_TCP4) {\n\t\t \n\t\tnet->hw_features |= NETIF_F_IP_CSUM;\n\t\tnet_device_ctx->tx_checksum_mask |= TRANSPORT_INFO_IPV4_TCP;\n\n\t\toffloads.tcp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;\n\n\t\tif (hwcaps.lsov2.ip4_encap & NDIS_OFFLOAD_ENCAP_8023) {\n\t\t\toffloads.lso_v2_ipv4 = NDIS_OFFLOAD_PARAMETERS_LSOV2_ENABLED;\n\t\t\tnet->hw_features |= NETIF_F_TSO;\n\n\t\t\tif (hwcaps.lsov2.ip4_maxsz < gso_max_size)\n\t\t\t\tgso_max_size = hwcaps.lsov2.ip4_maxsz;\n\t\t}\n\n\t\tif (hwcaps.csum.ip4_txcsum & NDIS_TXCSUM_CAP_UDP4) {\n\t\t\toffloads.udp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;\n\t\t\tnet_device_ctx->tx_checksum_mask |= TRANSPORT_INFO_IPV4_UDP;\n\t\t}\n\t}\n\n\tif ((hwcaps.csum.ip6_txcsum & NDIS_TXCSUM_ALL_TCP6) == NDIS_TXCSUM_ALL_TCP6) {\n\t\tnet->hw_features |= NETIF_F_IPV6_CSUM;\n\n\t\toffloads.tcp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;\n\t\tnet_device_ctx->tx_checksum_mask |= TRANSPORT_INFO_IPV6_TCP;\n\n\t\tif ((hwcaps.lsov2.ip6_encap & NDIS_OFFLOAD_ENCAP_8023) &&\n\t\t    (hwcaps.lsov2.ip6_opts & NDIS_LSOV2_CAP_IP6) == NDIS_LSOV2_CAP_IP6) {\n\t\t\toffloads.lso_v2_ipv6 = NDIS_OFFLOAD_PARAMETERS_LSOV2_ENABLED;\n\t\t\tnet->hw_features |= NETIF_F_TSO6;\n\n\t\t\tif (hwcaps.lsov2.ip6_maxsz < gso_max_size)\n\t\t\t\tgso_max_size = hwcaps.lsov2.ip6_maxsz;\n\t\t}\n\n\t\tif (hwcaps.csum.ip6_txcsum & NDIS_TXCSUM_CAP_UDP6) {\n\t\t\toffloads.udp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;\n\t\t\tnet_device_ctx->tx_checksum_mask |= TRANSPORT_INFO_IPV6_UDP;\n\t\t}\n\t}\n\n\tif (hwcaps.rsc.ip4 && hwcaps.rsc.ip6) {\n\t\tnet->hw_features |= NETIF_F_LRO;\n\n\t\tif (net->features & NETIF_F_LRO) {\n\t\t\toffloads.rsc_ip_v4 = NDIS_OFFLOAD_PARAMETERS_RSC_ENABLED;\n\t\t\toffloads.rsc_ip_v6 = NDIS_OFFLOAD_PARAMETERS_RSC_ENABLED;\n\t\t} else {\n\t\t\toffloads.rsc_ip_v4 = NDIS_OFFLOAD_PARAMETERS_RSC_DISABLED;\n\t\t\toffloads.rsc_ip_v6 = NDIS_OFFLOAD_PARAMETERS_RSC_DISABLED;\n\t\t}\n\t}\n\n\t \n\tnet->features &= ~NETVSC_SUPPORTED_HW_FEATURES | net->hw_features;\n\n\tnetif_set_tso_max_size(net, gso_max_size);\n\n\tret = rndis_filter_set_offload_params(net, nvdev, &offloads);\n\n\treturn ret;\n}\n\nstatic void rndis_get_friendly_name(struct net_device *net,\n\t\t\t\t    struct rndis_device *rndis_device,\n\t\t\t\t    struct netvsc_device *net_device)\n{\n\tucs2_char_t wname[256];\n\tunsigned long len;\n\tu8 ifalias[256];\n\tu32 size;\n\n\tsize = sizeof(wname);\n\tif (rndis_filter_query_device(rndis_device, net_device,\n\t\t\t\t      RNDIS_OID_GEN_FRIENDLY_NAME,\n\t\t\t\t      wname, &size) != 0)\n\t\treturn;\t \n\n\tif (size == 0)\n\t\treturn;\t \n\n\t \n\tlen = ucs2_as_utf8(ifalias, wname, sizeof(ifalias));\n\n\t \n\tif (strcmp(ifalias, \"Network Adapter\") != 0)\n\t\tdev_set_alias(net, ifalias, len);\n}\n\nstruct netvsc_device *rndis_filter_device_add(struct hv_device *dev,\n\t\t\t\t      struct netvsc_device_info *device_info)\n{\n\tstruct net_device *net = hv_get_drvdata(dev);\n\tstruct net_device_context *ndc = netdev_priv(net);\n\tstruct netvsc_device *net_device;\n\tstruct rndis_device *rndis_device;\n\tstruct ndis_recv_scale_cap rsscap;\n\tu32 rsscap_size = sizeof(struct ndis_recv_scale_cap);\n\tu32 mtu, size;\n\tu32 num_possible_rss_qs;\n\tint i, ret;\n\n\trndis_device = get_rndis_device();\n\tif (!rndis_device)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t \n\tnet_device = netvsc_device_add(dev, device_info);\n\tif (IS_ERR(net_device)) {\n\t\tkfree(rndis_device);\n\t\treturn net_device;\n\t}\n\n\t \n\tnet_device->max_chn = 1;\n\tnet_device->num_chn = 1;\n\n\tnet_device->extension = rndis_device;\n\trndis_device->ndev = net;\n\n\t \n\tret = rndis_filter_init_device(rndis_device, net_device);\n\tif (ret != 0)\n\t\tgoto err_dev_remv;\n\n\t \n\tsize = sizeof(u32);\n\tret = rndis_filter_query_device(rndis_device, net_device,\n\t\t\t\t\tRNDIS_OID_GEN_MAXIMUM_FRAME_SIZE,\n\t\t\t\t\t&mtu, &size);\n\tif (ret == 0 && size == sizeof(u32) && mtu < net->mtu)\n\t\tnet->mtu = mtu;\n\n\t \n\tret = rndis_filter_query_device_mac(rndis_device, net_device);\n\tif (ret != 0)\n\t\tgoto err_dev_remv;\n\n\tmemcpy(device_info->mac_adr, rndis_device->hw_mac_adr, ETH_ALEN);\n\n\t \n\tif (!net->ifalias)\n\t\trndis_get_friendly_name(net, rndis_device, net_device);\n\n\t \n\tret = rndis_netdev_set_hwcaps(rndis_device, net_device);\n\tif (ret != 0)\n\t\tgoto err_dev_remv;\n\n\trndis_filter_query_device_link_status(rndis_device, net_device);\n\n\tnetdev_dbg(net, \"Device MAC %pM link state %s\\n\",\n\t\t   rndis_device->hw_mac_adr,\n\t\t   rndis_device->link_state ? \"down\" : \"up\");\n\n\tif (net_device->nvsp_version < NVSP_PROTOCOL_VERSION_5)\n\t\tgoto out;\n\n\trndis_filter_query_link_speed(rndis_device, net_device);\n\n\t \n\tmemset(&rsscap, 0, rsscap_size);\n\tret = rndis_filter_query_device(rndis_device, net_device,\n\t\t\t\t\tOID_GEN_RECEIVE_SCALE_CAPABILITIES,\n\t\t\t\t\t&rsscap, &rsscap_size);\n\tif (ret || rsscap.num_recv_que < 2)\n\t\tgoto out;\n\n\tif (rsscap.num_indirect_tabent &&\n\t    rsscap.num_indirect_tabent <= ITAB_NUM_MAX)\n\t\tndc->rx_table_sz = rsscap.num_indirect_tabent;\n\telse\n\t\tndc->rx_table_sz = ITAB_NUM;\n\n\tndc->rx_table = kcalloc(ndc->rx_table_sz, sizeof(u16), GFP_KERNEL);\n\tif (!ndc->rx_table) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dev_remv;\n\t}\n\n\t \n\tnum_possible_rss_qs = min_t(u32, num_online_cpus(),\n\t\t\t\t    rsscap.num_recv_que);\n\n\tnet_device->max_chn = min_t(u32, VRSS_CHANNEL_MAX, num_possible_rss_qs);\n\n\t \n\tnet_device->num_chn = min(net_device->max_chn, device_info->num_chn);\n\n\tif (!netif_is_rxfh_configured(net)) {\n\t\tfor (i = 0; i < ndc->rx_table_sz; i++)\n\t\t\tndc->rx_table[i] = ethtool_rxfh_indir_default(\n\t\t\t\t\t\ti, net_device->num_chn);\n\t}\n\n\tatomic_set(&net_device->open_chn, 1);\n\tvmbus_set_sc_create_callback(dev->channel, netvsc_sc_open);\n\n\tfor (i = 1; i < net_device->num_chn; i++) {\n\t\tret = netvsc_alloc_recv_comp_ring(net_device, i);\n\t\tif (ret) {\n\t\t\twhile (--i != 0)\n\t\t\t\tvfree(net_device->chan_table[i].mrc.slots);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 1; i < net_device->num_chn; i++)\n\t\tnetif_napi_add(net, &net_device->chan_table[i].napi,\n\t\t\t       netvsc_poll);\n\n\treturn net_device;\n\nout:\n\t \n\tnet_device->max_chn = 1;\n\tnet_device->num_chn = 1;\n\treturn net_device;\n\nerr_dev_remv:\n\trndis_filter_device_remove(dev, net_device);\n\treturn ERR_PTR(ret);\n}\n\nvoid rndis_filter_device_remove(struct hv_device *dev,\n\t\t\t\tstruct netvsc_device *net_dev)\n{\n\tstruct rndis_device *rndis_dev = net_dev->extension;\n\tstruct net_device *net = hv_get_drvdata(dev);\n\tstruct net_device_context *ndc;\n\n\tndc = netdev_priv(net);\n\n\t \n\trndis_filter_halt_device(net_dev, rndis_dev);\n\n\tnetvsc_device_remove(dev);\n\n\tndc->rx_table_sz = 0;\n\tkfree(ndc->rx_table);\n\tndc->rx_table = NULL;\n}\n\nint rndis_filter_open(struct netvsc_device *nvdev)\n{\n\tif (!nvdev)\n\t\treturn -EINVAL;\n\n\treturn rndis_filter_open_device(nvdev->extension);\n}\n\nint rndis_filter_close(struct netvsc_device *nvdev)\n{\n\tif (!nvdev)\n\t\treturn -EINVAL;\n\n\treturn rndis_filter_close_device(nvdev->extension);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}