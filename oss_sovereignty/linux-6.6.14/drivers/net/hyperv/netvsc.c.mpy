{
  "module_name": "netvsc.c",
  "hash_id": "40b41af42f33a58f636e3ac5a58be6f4c9994bcb649e24857209a6f6bef06f22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hyperv/netvsc.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/if_ether.h>\n#include <linux/vmalloc.h>\n#include <linux/rtnetlink.h>\n#include <linux/prefetch.h>\n#include <linux/filter.h>\n\n#include <asm/sync_bitops.h>\n#include <asm/mshyperv.h>\n\n#include \"hyperv_net.h\"\n#include \"netvsc_trace.h\"\n\n \nint netvsc_switch_datapath(struct net_device *ndev, bool vf)\n{\n\tstruct net_device_context *net_device_ctx = netdev_priv(ndev);\n\tstruct hv_device *dev = net_device_ctx->device_ctx;\n\tstruct netvsc_device *nv_dev = rtnl_dereference(net_device_ctx->nvdev);\n\tstruct nvsp_message *init_pkt = &nv_dev->channel_init_pkt;\n\tint ret, retry = 0;\n\n\t \n\tif (!vf)\n\t\tnet_device_ctx->data_path_is_vf = vf;\n\n\tmemset(init_pkt, 0, sizeof(struct nvsp_message));\n\tinit_pkt->hdr.msg_type = NVSP_MSG4_TYPE_SWITCH_DATA_PATH;\n\tif (vf)\n\t\tinit_pkt->msg.v4_msg.active_dp.active_datapath =\n\t\t\tNVSP_DATAPATH_VF;\n\telse\n\t\tinit_pkt->msg.v4_msg.active_dp.active_datapath =\n\t\t\tNVSP_DATAPATH_SYNTHETIC;\n\nagain:\n\ttrace_nvsp_send(ndev, init_pkt);\n\n\tret = vmbus_sendpacket(dev->channel, init_pkt,\n\t\t\t       sizeof(struct nvsp_message),\n\t\t\t       (unsigned long)init_pkt, VM_PKT_DATA_INBAND,\n\t\t\t       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\n\t \n\tif (ret) {\n\t\tif (ret != -EAGAIN) {\n\t\t\tnetdev_err(ndev,\n\t\t\t\t   \"Unable to send sw datapath msg, err: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (retry++ < RETRY_MAX) {\n\t\t\tusleep_range(RETRY_US_LO, RETRY_US_HI);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tnetdev_err(\n\t\t\t\tndev,\n\t\t\t\t\"Retry failed to send sw datapath msg, err: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\twait_for_completion(&nv_dev->channel_init_wait);\n\tnet_device_ctx->data_path_is_vf = vf;\n\n\treturn 0;\n}\n\n \nstatic void netvsc_subchan_work(struct work_struct *w)\n{\n\tstruct netvsc_device *nvdev =\n\t\tcontainer_of(w, struct netvsc_device, subchan_work);\n\tstruct rndis_device *rdev;\n\tint i, ret;\n\n\t \n\tif (!rtnl_trylock()) {\n\t\tschedule_work(w);\n\t\treturn;\n\t}\n\n\trdev = nvdev->extension;\n\tif (rdev) {\n\t\tret = rndis_set_subchannel(rdev->ndev, nvdev, NULL);\n\t\tif (ret == 0) {\n\t\t\tnetif_device_attach(rdev->ndev);\n\t\t} else {\n\t\t\t \n\t\t\tfor (i = 1; i < nvdev->num_chn; i++)\n\t\t\t\tnetif_napi_del(&nvdev->chan_table[i].napi);\n\n\t\t\tnvdev->max_chn = 1;\n\t\t\tnvdev->num_chn = 1;\n\t\t}\n\t}\n\n\trtnl_unlock();\n}\n\nstatic struct netvsc_device *alloc_net_device(void)\n{\n\tstruct netvsc_device *net_device;\n\n\tnet_device = kzalloc(sizeof(struct netvsc_device), GFP_KERNEL);\n\tif (!net_device)\n\t\treturn NULL;\n\n\tinit_waitqueue_head(&net_device->wait_drain);\n\tnet_device->destroy = false;\n\tnet_device->tx_disable = true;\n\n\tnet_device->max_pkt = RNDIS_MAX_PKT_DEFAULT;\n\tnet_device->pkt_align = RNDIS_PKT_ALIGN_DEFAULT;\n\n\tinit_completion(&net_device->channel_init_wait);\n\tinit_waitqueue_head(&net_device->subchan_open);\n\tINIT_WORK(&net_device->subchan_work, netvsc_subchan_work);\n\n\treturn net_device;\n}\n\nstatic void free_netvsc_device(struct rcu_head *head)\n{\n\tstruct netvsc_device *nvdev\n\t\t= container_of(head, struct netvsc_device, rcu);\n\tint i;\n\n\tkfree(nvdev->extension);\n\tvfree(nvdev->recv_buf);\n\tvfree(nvdev->send_buf);\n\tbitmap_free(nvdev->send_section_map);\n\n\tfor (i = 0; i < VRSS_CHANNEL_MAX; i++) {\n\t\txdp_rxq_info_unreg(&nvdev->chan_table[i].xdp_rxq);\n\t\tkfree(nvdev->chan_table[i].recv_buf);\n\t\tvfree(nvdev->chan_table[i].mrc.slots);\n\t}\n\n\tkfree(nvdev);\n}\n\nstatic void free_netvsc_device_rcu(struct netvsc_device *nvdev)\n{\n\tcall_rcu(&nvdev->rcu, free_netvsc_device);\n}\n\nstatic void netvsc_revoke_recv_buf(struct hv_device *device,\n\t\t\t\t   struct netvsc_device *net_device,\n\t\t\t\t   struct net_device *ndev)\n{\n\tstruct nvsp_message *revoke_packet;\n\tint ret;\n\n\t \n\tif (net_device->recv_section_cnt) {\n\t\t \n\t\trevoke_packet = &net_device->revoke_packet;\n\t\tmemset(revoke_packet, 0, sizeof(struct nvsp_message));\n\n\t\trevoke_packet->hdr.msg_type =\n\t\t\tNVSP_MSG1_TYPE_REVOKE_RECV_BUF;\n\t\trevoke_packet->msg.v1_msg.\n\t\trevoke_recv_buf.id = NETVSC_RECEIVE_BUFFER_ID;\n\n\t\ttrace_nvsp_send(ndev, revoke_packet);\n\n\t\tret = vmbus_sendpacket(device->channel,\n\t\t\t\t       revoke_packet,\n\t\t\t\t       sizeof(struct nvsp_message),\n\t\t\t\t       VMBUS_RQST_ID_NO_RESPONSE,\n\t\t\t\t       VM_PKT_DATA_INBAND, 0);\n\t\t \n\t\tif (device->channel->rescind)\n\t\t\tret = 0;\n\t\t \n\t\tif (ret != 0) {\n\t\t\tnetdev_err(ndev, \"unable to send \"\n\t\t\t\t\"revoke receive buffer to netvsp\\n\");\n\t\t\treturn;\n\t\t}\n\t\tnet_device->recv_section_cnt = 0;\n\t}\n}\n\nstatic void netvsc_revoke_send_buf(struct hv_device *device,\n\t\t\t\t   struct netvsc_device *net_device,\n\t\t\t\t   struct net_device *ndev)\n{\n\tstruct nvsp_message *revoke_packet;\n\tint ret;\n\n\t \n\tif (net_device->send_section_cnt) {\n\t\t \n\t\trevoke_packet = &net_device->revoke_packet;\n\t\tmemset(revoke_packet, 0, sizeof(struct nvsp_message));\n\n\t\trevoke_packet->hdr.msg_type =\n\t\t\tNVSP_MSG1_TYPE_REVOKE_SEND_BUF;\n\t\trevoke_packet->msg.v1_msg.revoke_send_buf.id =\n\t\t\tNETVSC_SEND_BUFFER_ID;\n\n\t\ttrace_nvsp_send(ndev, revoke_packet);\n\n\t\tret = vmbus_sendpacket(device->channel,\n\t\t\t\t       revoke_packet,\n\t\t\t\t       sizeof(struct nvsp_message),\n\t\t\t\t       VMBUS_RQST_ID_NO_RESPONSE,\n\t\t\t\t       VM_PKT_DATA_INBAND, 0);\n\n\t\t \n\t\tif (device->channel->rescind)\n\t\t\tret = 0;\n\n\t\t \n\t\tif (ret != 0) {\n\t\t\tnetdev_err(ndev, \"unable to send \"\n\t\t\t\t   \"revoke send buffer to netvsp\\n\");\n\t\t\treturn;\n\t\t}\n\t\tnet_device->send_section_cnt = 0;\n\t}\n}\n\nstatic void netvsc_teardown_recv_gpadl(struct hv_device *device,\n\t\t\t\t       struct netvsc_device *net_device,\n\t\t\t\t       struct net_device *ndev)\n{\n\tint ret;\n\n\tif (net_device->recv_buf_gpadl_handle.gpadl_handle) {\n\t\tret = vmbus_teardown_gpadl(device->channel,\n\t\t\t\t\t   &net_device->recv_buf_gpadl_handle);\n\n\t\t \n\t\tif (ret != 0) {\n\t\t\tnetdev_err(ndev,\n\t\t\t\t   \"unable to teardown receive buffer's gpadl\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void netvsc_teardown_send_gpadl(struct hv_device *device,\n\t\t\t\t       struct netvsc_device *net_device,\n\t\t\t\t       struct net_device *ndev)\n{\n\tint ret;\n\n\tif (net_device->send_buf_gpadl_handle.gpadl_handle) {\n\t\tret = vmbus_teardown_gpadl(device->channel,\n\t\t\t\t\t   &net_device->send_buf_gpadl_handle);\n\n\t\t \n\t\tif (ret != 0) {\n\t\t\tnetdev_err(ndev,\n\t\t\t\t   \"unable to teardown send buffer's gpadl\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint netvsc_alloc_recv_comp_ring(struct netvsc_device *net_device, u32 q_idx)\n{\n\tstruct netvsc_channel *nvchan = &net_device->chan_table[q_idx];\n\tint node = cpu_to_node(nvchan->channel->target_cpu);\n\tsize_t size;\n\n\tsize = net_device->recv_completion_cnt * sizeof(struct recv_comp_data);\n\tnvchan->mrc.slots = vzalloc_node(size, node);\n\tif (!nvchan->mrc.slots)\n\t\tnvchan->mrc.slots = vzalloc(size);\n\n\treturn nvchan->mrc.slots ? 0 : -ENOMEM;\n}\n\nstatic int netvsc_init_buf(struct hv_device *device,\n\t\t\t   struct netvsc_device *net_device,\n\t\t\t   const struct netvsc_device_info *device_info)\n{\n\tstruct nvsp_1_message_send_receive_buffer_complete *resp;\n\tstruct net_device *ndev = hv_get_drvdata(device);\n\tstruct nvsp_message *init_packet;\n\tunsigned int buf_size;\n\tint i, ret = 0;\n\n\t \n\tbuf_size = device_info->recv_sections * device_info->recv_section_size;\n\tbuf_size = roundup(buf_size, PAGE_SIZE);\n\n\t \n\tif (net_device->nvsp_version <= NVSP_PROTOCOL_VERSION_2)\n\t\tbuf_size = min_t(unsigned int, buf_size,\n\t\t\t\t NETVSC_RECEIVE_BUFFER_SIZE_LEGACY);\n\n\tnet_device->recv_buf = vzalloc(buf_size);\n\tif (!net_device->recv_buf) {\n\t\tnetdev_err(ndev,\n\t\t\t   \"unable to allocate receive buffer of size %u\\n\",\n\t\t\t   buf_size);\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tnet_device->recv_buf_size = buf_size;\n\n\t \n\tret = vmbus_establish_gpadl(device->channel, net_device->recv_buf,\n\t\t\t\t    buf_size,\n\t\t\t\t    &net_device->recv_buf_gpadl_handle);\n\tif (ret != 0) {\n\t\tnetdev_err(ndev,\n\t\t\t\"unable to establish receive buffer's gpadl\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\tinit_packet = &net_device->channel_init_pkt;\n\tmemset(init_packet, 0, sizeof(struct nvsp_message));\n\tinit_packet->hdr.msg_type = NVSP_MSG1_TYPE_SEND_RECV_BUF;\n\tinit_packet->msg.v1_msg.send_recv_buf.\n\t\tgpadl_handle = net_device->recv_buf_gpadl_handle.gpadl_handle;\n\tinit_packet->msg.v1_msg.\n\t\tsend_recv_buf.id = NETVSC_RECEIVE_BUFFER_ID;\n\n\ttrace_nvsp_send(ndev, init_packet);\n\n\t \n\tret = vmbus_sendpacket(device->channel, init_packet,\n\t\t\t       sizeof(struct nvsp_message),\n\t\t\t       (unsigned long)init_packet,\n\t\t\t       VM_PKT_DATA_INBAND,\n\t\t\t       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\tif (ret != 0) {\n\t\tnetdev_err(ndev,\n\t\t\t\"unable to send receive buffer's gpadl to netvsp\\n\");\n\t\tgoto cleanup;\n\t}\n\n\twait_for_completion(&net_device->channel_init_wait);\n\n\t \n\tresp = &init_packet->msg.v1_msg.send_recv_buf_complete;\n\tif (resp->status != NVSP_STAT_SUCCESS) {\n\t\tnetdev_err(ndev,\n\t\t\t   \"Unable to complete receive buffer initialization with NetVsp - status %d\\n\",\n\t\t\t   resp->status);\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tnetdev_dbg(ndev, \"Receive sections: %u sub_allocs: size %u count: %u\\n\",\n\t\t   resp->num_sections, resp->sections[0].sub_alloc_size,\n\t\t   resp->sections[0].num_sub_allocs);\n\n\t \n\tif (resp->num_sections != 1 || resp->sections[0].offset != 0) {\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tnet_device->recv_section_size = resp->sections[0].sub_alloc_size;\n\tnet_device->recv_section_cnt = resp->sections[0].num_sub_allocs;\n\n\t \n\tif (net_device->recv_section_size < NETVSC_MTU_MIN || (u64)net_device->recv_section_size *\n\t    (u64)net_device->recv_section_cnt > (u64)buf_size) {\n\t\tnetdev_err(ndev, \"invalid recv_section_size %u\\n\",\n\t\t\t   net_device->recv_section_size);\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tfor (i = 0; i < VRSS_CHANNEL_MAX; i++) {\n\t\tstruct netvsc_channel *nvchan = &net_device->chan_table[i];\n\n\t\tnvchan->recv_buf = kzalloc(net_device->recv_section_size, GFP_KERNEL);\n\t\tif (nvchan->recv_buf == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\tnet_device->recv_completion_cnt = net_device->recv_section_cnt + 1;\n\tret = netvsc_alloc_recv_comp_ring(net_device, 0);\n\tif (ret)\n\t\tgoto cleanup;\n\n\t \n\tbuf_size = device_info->send_sections * device_info->send_section_size;\n\tbuf_size = round_up(buf_size, PAGE_SIZE);\n\n\tnet_device->send_buf = vzalloc(buf_size);\n\tif (!net_device->send_buf) {\n\t\tnetdev_err(ndev, \"unable to allocate send buffer of size %u\\n\",\n\t\t\t   buf_size);\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tnet_device->send_buf_size = buf_size;\n\n\t \n\tret = vmbus_establish_gpadl(device->channel, net_device->send_buf,\n\t\t\t\t    buf_size,\n\t\t\t\t    &net_device->send_buf_gpadl_handle);\n\tif (ret != 0) {\n\t\tnetdev_err(ndev,\n\t\t\t   \"unable to establish send buffer's gpadl\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\tinit_packet = &net_device->channel_init_pkt;\n\tmemset(init_packet, 0, sizeof(struct nvsp_message));\n\tinit_packet->hdr.msg_type = NVSP_MSG1_TYPE_SEND_SEND_BUF;\n\tinit_packet->msg.v1_msg.send_send_buf.gpadl_handle =\n\t\tnet_device->send_buf_gpadl_handle.gpadl_handle;\n\tinit_packet->msg.v1_msg.send_send_buf.id = NETVSC_SEND_BUFFER_ID;\n\n\ttrace_nvsp_send(ndev, init_packet);\n\n\t \n\tret = vmbus_sendpacket(device->channel, init_packet,\n\t\t\t       sizeof(struct nvsp_message),\n\t\t\t       (unsigned long)init_packet,\n\t\t\t       VM_PKT_DATA_INBAND,\n\t\t\t       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\tif (ret != 0) {\n\t\tnetdev_err(ndev,\n\t\t\t   \"unable to send send buffer's gpadl to netvsp\\n\");\n\t\tgoto cleanup;\n\t}\n\n\twait_for_completion(&net_device->channel_init_wait);\n\n\t \n\tif (init_packet->msg.v1_msg.\n\t    send_send_buf_complete.status != NVSP_STAT_SUCCESS) {\n\t\tnetdev_err(ndev, \"Unable to complete send buffer \"\n\t\t\t   \"initialization with NetVsp - status %d\\n\",\n\t\t\t   init_packet->msg.v1_msg.\n\t\t\t   send_send_buf_complete.status);\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tnet_device->send_section_size = init_packet->msg.\n\t\t\t\tv1_msg.send_send_buf_complete.section_size;\n\tif (net_device->send_section_size < NETVSC_MTU_MIN) {\n\t\tnetdev_err(ndev, \"invalid send_section_size %u\\n\",\n\t\t\t   net_device->send_section_size);\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tnet_device->send_section_cnt = buf_size / net_device->send_section_size;\n\n\tnetdev_dbg(ndev, \"Send section size: %d, Section count:%d\\n\",\n\t\t   net_device->send_section_size, net_device->send_section_cnt);\n\n\t \n\tnet_device->send_section_map = bitmap_zalloc(net_device->send_section_cnt,\n\t\t\t\t\t\t     GFP_KERNEL);\n\tif (!net_device->send_section_map) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tgoto exit;\n\ncleanup:\n\tnetvsc_revoke_recv_buf(device, net_device, ndev);\n\tnetvsc_revoke_send_buf(device, net_device, ndev);\n\tnetvsc_teardown_recv_gpadl(device, net_device, ndev);\n\tnetvsc_teardown_send_gpadl(device, net_device, ndev);\n\nexit:\n\treturn ret;\n}\n\n \nstatic int negotiate_nvsp_ver(struct hv_device *device,\n\t\t\t      struct netvsc_device *net_device,\n\t\t\t      struct nvsp_message *init_packet,\n\t\t\t      u32 nvsp_ver)\n{\n\tstruct net_device *ndev = hv_get_drvdata(device);\n\tint ret;\n\n\tmemset(init_packet, 0, sizeof(struct nvsp_message));\n\tinit_packet->hdr.msg_type = NVSP_MSG_TYPE_INIT;\n\tinit_packet->msg.init_msg.init.min_protocol_ver = nvsp_ver;\n\tinit_packet->msg.init_msg.init.max_protocol_ver = nvsp_ver;\n\ttrace_nvsp_send(ndev, init_packet);\n\n\t \n\tret = vmbus_sendpacket(device->channel, init_packet,\n\t\t\t       sizeof(struct nvsp_message),\n\t\t\t       (unsigned long)init_packet,\n\t\t\t       VM_PKT_DATA_INBAND,\n\t\t\t       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\twait_for_completion(&net_device->channel_init_wait);\n\n\tif (init_packet->msg.init_msg.init_complete.status !=\n\t    NVSP_STAT_SUCCESS)\n\t\treturn -EINVAL;\n\n\tif (nvsp_ver == NVSP_PROTOCOL_VERSION_1)\n\t\treturn 0;\n\n\t \n\tmemset(init_packet, 0, sizeof(struct nvsp_message));\n\tinit_packet->hdr.msg_type = NVSP_MSG2_TYPE_SEND_NDIS_CONFIG;\n\tinit_packet->msg.v2_msg.send_ndis_config.mtu = ndev->mtu + ETH_HLEN;\n\tinit_packet->msg.v2_msg.send_ndis_config.capability.ieee8021q = 1;\n\n\tif (nvsp_ver >= NVSP_PROTOCOL_VERSION_5) {\n\t\tif (hv_is_isolation_supported())\n\t\t\tnetdev_info(ndev, \"SR-IOV not advertised by guests on the host supporting isolation\\n\");\n\t\telse\n\t\t\tinit_packet->msg.v2_msg.send_ndis_config.capability.sriov = 1;\n\n\t\t \n\t\tinit_packet->msg.v2_msg.send_ndis_config.capability.teaming = 1;\n\t}\n\n\tif (nvsp_ver >= NVSP_PROTOCOL_VERSION_61)\n\t\tinit_packet->msg.v2_msg.send_ndis_config.capability.rsc = 1;\n\n\ttrace_nvsp_send(ndev, init_packet);\n\n\tret = vmbus_sendpacket(device->channel, init_packet,\n\t\t\t\tsizeof(struct nvsp_message),\n\t\t\t\tVMBUS_RQST_ID_NO_RESPONSE,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n\n\treturn ret;\n}\n\nstatic int netvsc_connect_vsp(struct hv_device *device,\n\t\t\t      struct netvsc_device *net_device,\n\t\t\t      const struct netvsc_device_info *device_info)\n{\n\tstruct net_device *ndev = hv_get_drvdata(device);\n\tstatic const u32 ver_list[] = {\n\t\tNVSP_PROTOCOL_VERSION_1, NVSP_PROTOCOL_VERSION_2,\n\t\tNVSP_PROTOCOL_VERSION_4, NVSP_PROTOCOL_VERSION_5,\n\t\tNVSP_PROTOCOL_VERSION_6, NVSP_PROTOCOL_VERSION_61\n\t};\n\tstruct nvsp_message *init_packet;\n\tint ndis_version, i, ret;\n\n\tinit_packet = &net_device->channel_init_pkt;\n\n\t \n\tfor (i = ARRAY_SIZE(ver_list) - 1; i >= 0; i--)\n\t\tif (negotiate_nvsp_ver(device, net_device, init_packet,\n\t\t\t\t       ver_list[i])  == 0) {\n\t\t\tnet_device->nvsp_version = ver_list[i];\n\t\t\tbreak;\n\t\t}\n\n\tif (i < 0) {\n\t\tret = -EPROTO;\n\t\tgoto cleanup;\n\t}\n\n\tif (hv_is_isolation_supported() && net_device->nvsp_version < NVSP_PROTOCOL_VERSION_61) {\n\t\tnetdev_err(ndev, \"Invalid NVSP version 0x%x (expected >= 0x%x) from the host supporting isolation\\n\",\n\t\t\t   net_device->nvsp_version, NVSP_PROTOCOL_VERSION_61);\n\t\tret = -EPROTO;\n\t\tgoto cleanup;\n\t}\n\n\tpr_debug(\"Negotiated NVSP version:%x\\n\", net_device->nvsp_version);\n\n\t \n\tmemset(init_packet, 0, sizeof(struct nvsp_message));\n\n\tif (net_device->nvsp_version <= NVSP_PROTOCOL_VERSION_4)\n\t\tndis_version = 0x00060001;\n\telse\n\t\tndis_version = 0x0006001e;\n\n\tinit_packet->hdr.msg_type = NVSP_MSG1_TYPE_SEND_NDIS_VER;\n\tinit_packet->msg.v1_msg.\n\t\tsend_ndis_ver.ndis_major_ver =\n\t\t\t\t(ndis_version & 0xFFFF0000) >> 16;\n\tinit_packet->msg.v1_msg.\n\t\tsend_ndis_ver.ndis_minor_ver =\n\t\t\t\tndis_version & 0xFFFF;\n\n\ttrace_nvsp_send(ndev, init_packet);\n\n\t \n\tret = vmbus_sendpacket(device->channel, init_packet,\n\t\t\t\tsizeof(struct nvsp_message),\n\t\t\t\tVMBUS_RQST_ID_NO_RESPONSE,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n\tif (ret != 0)\n\t\tgoto cleanup;\n\n\n\tret = netvsc_init_buf(device, net_device, device_info);\n\ncleanup:\n\treturn ret;\n}\n\n \nvoid netvsc_device_remove(struct hv_device *device)\n{\n\tstruct net_device *ndev = hv_get_drvdata(device);\n\tstruct net_device_context *net_device_ctx = netdev_priv(ndev);\n\tstruct netvsc_device *net_device\n\t\t= rtnl_dereference(net_device_ctx->nvdev);\n\tint i;\n\n\t \n\tnetvsc_revoke_recv_buf(device, net_device, ndev);\n\tif (vmbus_proto_version < VERSION_WIN10)\n\t\tnetvsc_teardown_recv_gpadl(device, net_device, ndev);\n\n\tnetvsc_revoke_send_buf(device, net_device, ndev);\n\tif (vmbus_proto_version < VERSION_WIN10)\n\t\tnetvsc_teardown_send_gpadl(device, net_device, ndev);\n\n\tRCU_INIT_POINTER(net_device_ctx->nvdev, NULL);\n\n\t \n\tfor (i = 0; i < net_device->num_chn; i++) {\n\t\t \n\t\tnapi_disable(&net_device->chan_table[i].napi);\n\t\tnetif_napi_del(&net_device->chan_table[i].napi);\n\t}\n\n\t \n\tnetdev_dbg(ndev, \"net device safe to remove\\n\");\n\n\t \n\tvmbus_close(device->channel);\n\n\t \n\tif (vmbus_proto_version >= VERSION_WIN10) {\n\t\tnetvsc_teardown_recv_gpadl(device, net_device, ndev);\n\t\tnetvsc_teardown_send_gpadl(device, net_device, ndev);\n\t}\n\n\t \n\tfree_netvsc_device_rcu(net_device);\n}\n\n#define RING_AVAIL_PERCENT_HIWATER 20\n#define RING_AVAIL_PERCENT_LOWATER 10\n\nstatic inline void netvsc_free_send_slot(struct netvsc_device *net_device,\n\t\t\t\t\t u32 index)\n{\n\tsync_change_bit(index, net_device->send_section_map);\n}\n\nstatic void netvsc_send_tx_complete(struct net_device *ndev,\n\t\t\t\t    struct netvsc_device *net_device,\n\t\t\t\t    struct vmbus_channel *channel,\n\t\t\t\t    const struct vmpacket_descriptor *desc,\n\t\t\t\t    int budget)\n{\n\tstruct net_device_context *ndev_ctx = netdev_priv(ndev);\n\tstruct sk_buff *skb;\n\tu16 q_idx = 0;\n\tint queue_sends;\n\tu64 cmd_rqst;\n\n\tcmd_rqst = channel->request_addr_callback(channel, desc->trans_id);\n\tif (cmd_rqst == VMBUS_RQST_ERROR) {\n\t\tnetdev_err(ndev, \"Invalid transaction ID %llx\\n\", desc->trans_id);\n\t\treturn;\n\t}\n\n\tskb = (struct sk_buff *)(unsigned long)cmd_rqst;\n\n\t \n\tif (likely(skb)) {\n\t\tstruct hv_netvsc_packet *packet\n\t\t\t= (struct hv_netvsc_packet *)skb->cb;\n\t\tu32 send_index = packet->send_buf_index;\n\t\tstruct netvsc_stats_tx *tx_stats;\n\n\t\tif (send_index != NETVSC_INVALID_INDEX)\n\t\t\tnetvsc_free_send_slot(net_device, send_index);\n\t\tq_idx = packet->q_idx;\n\n\t\ttx_stats = &net_device->chan_table[q_idx].tx_stats;\n\n\t\tu64_stats_update_begin(&tx_stats->syncp);\n\t\ttx_stats->packets += packet->total_packets;\n\t\ttx_stats->bytes += packet->total_bytes;\n\t\tu64_stats_update_end(&tx_stats->syncp);\n\n\t\tnetvsc_dma_unmap(ndev_ctx->device_ctx, packet);\n\t\tnapi_consume_skb(skb, budget);\n\t}\n\n\tqueue_sends =\n\t\tatomic_dec_return(&net_device->chan_table[q_idx].queue_sends);\n\n\tif (unlikely(net_device->destroy)) {\n\t\tif (queue_sends == 0)\n\t\t\twake_up(&net_device->wait_drain);\n\t} else {\n\t\tstruct netdev_queue *txq = netdev_get_tx_queue(ndev, q_idx);\n\n\t\tif (netif_tx_queue_stopped(txq) && !net_device->tx_disable &&\n\t\t    (hv_get_avail_to_write_percent(&channel->outbound) >\n\t\t     RING_AVAIL_PERCENT_HIWATER || queue_sends < 1)) {\n\t\t\tnetif_tx_wake_queue(txq);\n\t\t\tndev_ctx->eth_stats.wake_queue++;\n\t\t}\n\t}\n}\n\nstatic void netvsc_send_completion(struct net_device *ndev,\n\t\t\t\t   struct netvsc_device *net_device,\n\t\t\t\t   struct vmbus_channel *incoming_channel,\n\t\t\t\t   const struct vmpacket_descriptor *desc,\n\t\t\t\t   int budget)\n{\n\tconst struct nvsp_message *nvsp_packet;\n\tu32 msglen = hv_pkt_datalen(desc);\n\tstruct nvsp_message *pkt_rqst;\n\tu64 cmd_rqst;\n\tu32 status;\n\n\t \n\tif (!msglen) {\n\t\tcmd_rqst = incoming_channel->request_addr_callback(incoming_channel,\n\t\t\t\t\t\t\t\t   desc->trans_id);\n\t\tif (cmd_rqst == VMBUS_RQST_ERROR) {\n\t\t\tnetdev_err(ndev, \"Invalid transaction ID %llx\\n\", desc->trans_id);\n\t\t\treturn;\n\t\t}\n\n\t\tpkt_rqst = (struct nvsp_message *)(uintptr_t)cmd_rqst;\n\t\tswitch (pkt_rqst->hdr.msg_type) {\n\t\tcase NVSP_MSG4_TYPE_SWITCH_DATA_PATH:\n\t\t\tcomplete(&net_device->channel_init_wait);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnetdev_err(ndev, \"Unexpected VMBUS completion!!\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (msglen < sizeof(struct nvsp_message_header)) {\n\t\tnetdev_err(ndev, \"nvsp_message length too small: %u\\n\", msglen);\n\t\treturn;\n\t}\n\n\tnvsp_packet = hv_pkt_data(desc);\n\tswitch (nvsp_packet->hdr.msg_type) {\n\tcase NVSP_MSG_TYPE_INIT_COMPLETE:\n\t\tif (msglen < sizeof(struct nvsp_message_header) +\n\t\t\t\tsizeof(struct nvsp_message_init_complete)) {\n\t\t\tnetdev_err(ndev, \"nvsp_msg length too small: %u\\n\",\n\t\t\t\t   msglen);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\n\tcase NVSP_MSG1_TYPE_SEND_RECV_BUF_COMPLETE:\n\t\tif (msglen < sizeof(struct nvsp_message_header) +\n\t\t\t\tsizeof(struct nvsp_1_message_send_receive_buffer_complete)) {\n\t\t\tnetdev_err(ndev, \"nvsp_msg1 length too small: %u\\n\",\n\t\t\t\t   msglen);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\n\tcase NVSP_MSG1_TYPE_SEND_SEND_BUF_COMPLETE:\n\t\tif (msglen < sizeof(struct nvsp_message_header) +\n\t\t\t\tsizeof(struct nvsp_1_message_send_send_buffer_complete)) {\n\t\t\tnetdev_err(ndev, \"nvsp_msg1 length too small: %u\\n\",\n\t\t\t\t   msglen);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\n\tcase NVSP_MSG5_TYPE_SUBCHANNEL:\n\t\tif (msglen < sizeof(struct nvsp_message_header) +\n\t\t\t\tsizeof(struct nvsp_5_subchannel_complete)) {\n\t\t\tnetdev_err(ndev, \"nvsp_msg5 length too small: %u\\n\",\n\t\t\t\t   msglen);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tmemcpy(&net_device->channel_init_pkt, nvsp_packet,\n\t\t       sizeof(struct nvsp_message));\n\t\tcomplete(&net_device->channel_init_wait);\n\t\tbreak;\n\n\tcase NVSP_MSG1_TYPE_SEND_RNDIS_PKT_COMPLETE:\n\t\tif (msglen < sizeof(struct nvsp_message_header) +\n\t\t    sizeof(struct nvsp_1_message_send_rndis_packet_complete)) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_err(ndev, \"nvsp_rndis_pkt_complete length too small: %u\\n\",\n\t\t\t\t\t   msglen);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tstatus = nvsp_packet->msg.v1_msg.send_rndis_pkt_complete.status;\n\t\tif (status != NVSP_STAT_SUCCESS && net_ratelimit())\n\t\t\tnetdev_err(ndev, \"nvsp_rndis_pkt_complete error status: %x\\n\",\n\t\t\t\t   status);\n\n\t\tnetvsc_send_tx_complete(ndev, net_device, incoming_channel,\n\t\t\t\t\tdesc, budget);\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_err(ndev,\n\t\t\t   \"Unknown send completion type %d received!!\\n\",\n\t\t\t   nvsp_packet->hdr.msg_type);\n\t}\n}\n\nstatic u32 netvsc_get_next_send_section(struct netvsc_device *net_device)\n{\n\tunsigned long *map_addr = net_device->send_section_map;\n\tunsigned int i;\n\n\tfor_each_clear_bit(i, map_addr, net_device->send_section_cnt) {\n\t\tif (sync_test_and_set_bit(i, map_addr) == 0)\n\t\t\treturn i;\n\t}\n\n\treturn NETVSC_INVALID_INDEX;\n}\n\nstatic void netvsc_copy_to_send_buf(struct netvsc_device *net_device,\n\t\t\t\t    unsigned int section_index,\n\t\t\t\t    u32 pend_size,\n\t\t\t\t    struct hv_netvsc_packet *packet,\n\t\t\t\t    struct rndis_message *rndis_msg,\n\t\t\t\t    struct hv_page_buffer *pb,\n\t\t\t\t    bool xmit_more)\n{\n\tchar *start = net_device->send_buf;\n\tchar *dest = start + (section_index * net_device->send_section_size)\n\t\t     + pend_size;\n\tint i;\n\tu32 padding = 0;\n\tu32 page_count = packet->cp_partial ? packet->rmsg_pgcnt :\n\t\tpacket->page_buf_cnt;\n\tu32 remain;\n\n\t \n\tremain = packet->total_data_buflen & (net_device->pkt_align - 1);\n\tif (xmit_more && remain) {\n\t\tpadding = net_device->pkt_align - remain;\n\t\trndis_msg->msg_len += padding;\n\t\tpacket->total_data_buflen += padding;\n\t}\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tchar *src = phys_to_virt(pb[i].pfn << HV_HYP_PAGE_SHIFT);\n\t\tu32 offset = pb[i].offset;\n\t\tu32 len = pb[i].len;\n\n\t\tmemcpy(dest, (src + offset), len);\n\t\tdest += len;\n\t}\n\n\tif (padding)\n\t\tmemset(dest, 0, padding);\n}\n\nvoid netvsc_dma_unmap(struct hv_device *hv_dev,\n\t\t      struct hv_netvsc_packet *packet)\n{\n\tint i;\n\n\tif (!hv_is_isolation_supported())\n\t\treturn;\n\n\tif (!packet->dma_range)\n\t\treturn;\n\n\tfor (i = 0; i < packet->page_buf_cnt; i++)\n\t\tdma_unmap_single(&hv_dev->device, packet->dma_range[i].dma,\n\t\t\t\t packet->dma_range[i].mapping_size,\n\t\t\t\t DMA_TO_DEVICE);\n\n\tkfree(packet->dma_range);\n}\n\n \nstatic int netvsc_dma_map(struct hv_device *hv_dev,\n\t\t\t  struct hv_netvsc_packet *packet,\n\t\t\t  struct hv_page_buffer *pb)\n{\n\tu32 page_count = packet->page_buf_cnt;\n\tdma_addr_t dma;\n\tint i;\n\n\tif (!hv_is_isolation_supported())\n\t\treturn 0;\n\n\tpacket->dma_range = kcalloc(page_count,\n\t\t\t\t    sizeof(*packet->dma_range),\n\t\t\t\t    GFP_ATOMIC);\n\tif (!packet->dma_range)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tchar *src = phys_to_virt((pb[i].pfn << HV_HYP_PAGE_SHIFT)\n\t\t\t\t\t + pb[i].offset);\n\t\tu32 len = pb[i].len;\n\n\t\tdma = dma_map_single(&hv_dev->device, src, len,\n\t\t\t\t     DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(&hv_dev->device, dma)) {\n\t\t\tkfree(packet->dma_range);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tpacket->dma_range[i].dma = dma;\n\t\tpacket->dma_range[i].mapping_size = len;\n\t\tpb[i].pfn = dma >> HV_HYP_PAGE_SHIFT;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int netvsc_send_pkt(\n\tstruct hv_device *device,\n\tstruct hv_netvsc_packet *packet,\n\tstruct netvsc_device *net_device,\n\tstruct hv_page_buffer *pb,\n\tstruct sk_buff *skb)\n{\n\tstruct nvsp_message nvmsg;\n\tstruct nvsp_1_message_send_rndis_packet *rpkt =\n\t\t&nvmsg.msg.v1_msg.send_rndis_pkt;\n\tstruct netvsc_channel * const nvchan =\n\t\t&net_device->chan_table[packet->q_idx];\n\tstruct vmbus_channel *out_channel = nvchan->channel;\n\tstruct net_device *ndev = hv_get_drvdata(device);\n\tstruct net_device_context *ndev_ctx = netdev_priv(ndev);\n\tstruct netdev_queue *txq = netdev_get_tx_queue(ndev, packet->q_idx);\n\tu64 req_id;\n\tint ret;\n\tu32 ring_avail = hv_get_avail_to_write_percent(&out_channel->outbound);\n\n\tmemset(&nvmsg, 0, sizeof(struct nvsp_message));\n\tnvmsg.hdr.msg_type = NVSP_MSG1_TYPE_SEND_RNDIS_PKT;\n\tif (skb)\n\t\trpkt->channel_type = 0;\t\t \n\telse\n\t\trpkt->channel_type = 1;\t\t \n\n\trpkt->send_buf_section_index = packet->send_buf_index;\n\tif (packet->send_buf_index == NETVSC_INVALID_INDEX)\n\t\trpkt->send_buf_section_size = 0;\n\telse\n\t\trpkt->send_buf_section_size = packet->total_data_buflen;\n\n\treq_id = (ulong)skb;\n\n\tif (out_channel->rescind)\n\t\treturn -ENODEV;\n\n\ttrace_nvsp_send_pkt(ndev, out_channel, rpkt);\n\n\tpacket->dma_range = NULL;\n\tif (packet->page_buf_cnt) {\n\t\tif (packet->cp_partial)\n\t\t\tpb += packet->rmsg_pgcnt;\n\n\t\tret = netvsc_dma_map(ndev_ctx->device_ctx, packet, pb);\n\t\tif (ret) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = vmbus_sendpacket_pagebuffer(out_channel,\n\t\t\t\t\t\t  pb, packet->page_buf_cnt,\n\t\t\t\t\t\t  &nvmsg, sizeof(nvmsg),\n\t\t\t\t\t\t  req_id);\n\n\t\tif (ret)\n\t\t\tnetvsc_dma_unmap(ndev_ctx->device_ctx, packet);\n\t} else {\n\t\tret = vmbus_sendpacket(out_channel,\n\t\t\t\t       &nvmsg, sizeof(nvmsg),\n\t\t\t\t       req_id, VM_PKT_DATA_INBAND,\n\t\t\t\t       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\n\t}\n\nexit:\n\tif (ret == 0) {\n\t\tatomic_inc_return(&nvchan->queue_sends);\n\n\t\tif (ring_avail < RING_AVAIL_PERCENT_LOWATER) {\n\t\t\tnetif_tx_stop_queue(txq);\n\t\t\tndev_ctx->eth_stats.stop_queue++;\n\t\t}\n\t} else if (ret == -EAGAIN) {\n\t\tnetif_tx_stop_queue(txq);\n\t\tndev_ctx->eth_stats.stop_queue++;\n\t} else {\n\t\tnetdev_err(ndev,\n\t\t\t   \"Unable to send packet pages %u len %u, ret %d\\n\",\n\t\t\t   packet->page_buf_cnt, packet->total_data_buflen,\n\t\t\t   ret);\n\t}\n\n\tif (netif_tx_queue_stopped(txq) &&\n\t    atomic_read(&nvchan->queue_sends) < 1 &&\n\t    !net_device->tx_disable) {\n\t\tnetif_tx_wake_queue(txq);\n\t\tndev_ctx->eth_stats.wake_queue++;\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOSPC;\n\t}\n\n\treturn ret;\n}\n\n \nstatic inline void move_pkt_msd(struct hv_netvsc_packet **msd_send,\n\t\t\t\tstruct sk_buff **msd_skb,\n\t\t\t\tstruct multi_send_data *msdp)\n{\n\t*msd_skb = msdp->skb;\n\t*msd_send = msdp->pkt;\n\tmsdp->skb = NULL;\n\tmsdp->pkt = NULL;\n\tmsdp->count = 0;\n}\n\n \n \nint netvsc_send(struct net_device *ndev,\n\t\tstruct hv_netvsc_packet *packet,\n\t\tstruct rndis_message *rndis_msg,\n\t\tstruct hv_page_buffer *pb,\n\t\tstruct sk_buff *skb,\n\t\tbool xdp_tx)\n{\n\tstruct net_device_context *ndev_ctx = netdev_priv(ndev);\n\tstruct netvsc_device *net_device\n\t\t= rcu_dereference_bh(ndev_ctx->nvdev);\n\tstruct hv_device *device = ndev_ctx->device_ctx;\n\tint ret = 0;\n\tstruct netvsc_channel *nvchan;\n\tu32 pktlen = packet->total_data_buflen, msd_len = 0;\n\tunsigned int section_index = NETVSC_INVALID_INDEX;\n\tstruct multi_send_data *msdp;\n\tstruct hv_netvsc_packet *msd_send = NULL, *cur_send = NULL;\n\tstruct sk_buff *msd_skb = NULL;\n\tbool try_batch, xmit_more;\n\n\t \n\tif (unlikely(!net_device || net_device->destroy))\n\t\treturn -ENODEV;\n\n\tnvchan = &net_device->chan_table[packet->q_idx];\n\tpacket->send_buf_index = NETVSC_INVALID_INDEX;\n\tpacket->cp_partial = false;\n\n\t \n\tif (!skb || xdp_tx)\n\t\treturn netvsc_send_pkt(device, packet, net_device, pb, skb);\n\n\t \n\tmsdp = &nvchan->msd;\n\tif (msdp->pkt)\n\t\tmsd_len = msdp->pkt->total_data_buflen;\n\n\ttry_batch =  msd_len > 0 && msdp->count < net_device->max_pkt;\n\tif (try_batch && msd_len + pktlen + net_device->pkt_align <\n\t    net_device->send_section_size) {\n\t\tsection_index = msdp->pkt->send_buf_index;\n\n\t} else if (try_batch && msd_len + packet->rmsg_size <\n\t\t   net_device->send_section_size) {\n\t\tsection_index = msdp->pkt->send_buf_index;\n\t\tpacket->cp_partial = true;\n\n\t} else if (pktlen + net_device->pkt_align <\n\t\t   net_device->send_section_size) {\n\t\tsection_index = netvsc_get_next_send_section(net_device);\n\t\tif (unlikely(section_index == NETVSC_INVALID_INDEX)) {\n\t\t\t++ndev_ctx->eth_stats.tx_send_full;\n\t\t} else {\n\t\t\tmove_pkt_msd(&msd_send, &msd_skb, msdp);\n\t\t\tmsd_len = 0;\n\t\t}\n\t}\n\n\t \n\txmit_more = netdev_xmit_more() &&\n\t\t!packet->cp_partial &&\n\t\t!netif_xmit_stopped(netdev_get_tx_queue(ndev, packet->q_idx));\n\n\tif (section_index != NETVSC_INVALID_INDEX) {\n\t\tnetvsc_copy_to_send_buf(net_device,\n\t\t\t\t\tsection_index, msd_len,\n\t\t\t\t\tpacket, rndis_msg, pb, xmit_more);\n\n\t\tpacket->send_buf_index = section_index;\n\n\t\tif (packet->cp_partial) {\n\t\t\tpacket->page_buf_cnt -= packet->rmsg_pgcnt;\n\t\t\tpacket->total_data_buflen = msd_len + packet->rmsg_size;\n\t\t} else {\n\t\t\tpacket->page_buf_cnt = 0;\n\t\t\tpacket->total_data_buflen += msd_len;\n\t\t}\n\n\t\tif (msdp->pkt) {\n\t\t\tpacket->total_packets += msdp->pkt->total_packets;\n\t\t\tpacket->total_bytes += msdp->pkt->total_bytes;\n\t\t}\n\n\t\tif (msdp->skb)\n\t\t\tdev_consume_skb_any(msdp->skb);\n\n\t\tif (xmit_more) {\n\t\t\tmsdp->skb = skb;\n\t\t\tmsdp->pkt = packet;\n\t\t\tmsdp->count++;\n\t\t} else {\n\t\t\tcur_send = packet;\n\t\t\tmsdp->skb = NULL;\n\t\t\tmsdp->pkt = NULL;\n\t\t\tmsdp->count = 0;\n\t\t}\n\t} else {\n\t\tmove_pkt_msd(&msd_send, &msd_skb, msdp);\n\t\tcur_send = packet;\n\t}\n\n\tif (msd_send) {\n\t\tint m_ret = netvsc_send_pkt(device, msd_send, net_device,\n\t\t\t\t\t    NULL, msd_skb);\n\n\t\tif (m_ret != 0) {\n\t\t\tnetvsc_free_send_slot(net_device,\n\t\t\t\t\t      msd_send->send_buf_index);\n\t\t\tdev_kfree_skb_any(msd_skb);\n\t\t}\n\t}\n\n\tif (cur_send)\n\t\tret = netvsc_send_pkt(device, cur_send, net_device, pb, skb);\n\n\tif (ret != 0 && section_index != NETVSC_INVALID_INDEX)\n\t\tnetvsc_free_send_slot(net_device, section_index);\n\n\treturn ret;\n}\n\n \nstatic int send_recv_completions(struct net_device *ndev,\n\t\t\t\t struct netvsc_device *nvdev,\n\t\t\t\t struct netvsc_channel *nvchan)\n{\n\tstruct multi_recv_comp *mrc = &nvchan->mrc;\n\tstruct recv_comp_msg {\n\t\tstruct nvsp_message_header hdr;\n\t\tu32 status;\n\t}  __packed;\n\tstruct recv_comp_msg msg = {\n\t\t.hdr.msg_type = NVSP_MSG1_TYPE_SEND_RNDIS_PKT_COMPLETE,\n\t};\n\tint ret;\n\n\twhile (mrc->first != mrc->next) {\n\t\tconst struct recv_comp_data *rcd\n\t\t\t= mrc->slots + mrc->first;\n\n\t\tmsg.status = rcd->status;\n\t\tret = vmbus_sendpacket(nvchan->channel, &msg, sizeof(msg),\n\t\t\t\t       rcd->tid, VM_PKT_COMP, 0);\n\t\tif (unlikely(ret)) {\n\t\t\tstruct net_device_context *ndev_ctx = netdev_priv(ndev);\n\n\t\t\t++ndev_ctx->eth_stats.rx_comp_busy;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (++mrc->first == nvdev->recv_completion_cnt)\n\t\t\tmrc->first = 0;\n\t}\n\n\t \n\tif (unlikely(nvdev->destroy))\n\t\twake_up(&nvdev->wait_drain);\n\n\treturn 0;\n}\n\n \nstatic void recv_comp_slot_avail(const struct netvsc_device *nvdev,\n\t\t\t\t const struct multi_recv_comp *mrc,\n\t\t\t\t u32 *filled, u32 *avail)\n{\n\tu32 count = nvdev->recv_completion_cnt;\n\n\tif (mrc->next >= mrc->first)\n\t\t*filled = mrc->next - mrc->first;\n\telse\n\t\t*filled = (count - mrc->first) + mrc->next;\n\n\t*avail = count - *filled - 1;\n}\n\n \nstatic void enq_receive_complete(struct net_device *ndev,\n\t\t\t\t struct netvsc_device *nvdev, u16 q_idx,\n\t\t\t\t u64 tid, u32 status)\n{\n\tstruct netvsc_channel *nvchan = &nvdev->chan_table[q_idx];\n\tstruct multi_recv_comp *mrc = &nvchan->mrc;\n\tstruct recv_comp_data *rcd;\n\tu32 filled, avail;\n\n\trecv_comp_slot_avail(nvdev, mrc, &filled, &avail);\n\n\tif (unlikely(filled > NAPI_POLL_WEIGHT)) {\n\t\tsend_recv_completions(ndev, nvdev, nvchan);\n\t\trecv_comp_slot_avail(nvdev, mrc, &filled, &avail);\n\t}\n\n\tif (unlikely(!avail)) {\n\t\tnetdev_err(ndev, \"Recv_comp full buf q:%hd, tid:%llx\\n\",\n\t\t\t   q_idx, tid);\n\t\treturn;\n\t}\n\n\trcd = mrc->slots + mrc->next;\n\trcd->tid = tid;\n\trcd->status = status;\n\n\tif (++mrc->next == nvdev->recv_completion_cnt)\n\t\tmrc->next = 0;\n}\n\nstatic int netvsc_receive(struct net_device *ndev,\n\t\t\t  struct netvsc_device *net_device,\n\t\t\t  struct netvsc_channel *nvchan,\n\t\t\t  const struct vmpacket_descriptor *desc)\n{\n\tstruct net_device_context *net_device_ctx = netdev_priv(ndev);\n\tstruct vmbus_channel *channel = nvchan->channel;\n\tconst struct vmtransfer_page_packet_header *vmxferpage_packet\n\t\t= container_of(desc, const struct vmtransfer_page_packet_header, d);\n\tconst struct nvsp_message *nvsp = hv_pkt_data(desc);\n\tu32 msglen = hv_pkt_datalen(desc);\n\tu16 q_idx = channel->offermsg.offer.sub_channel_index;\n\tchar *recv_buf = net_device->recv_buf;\n\tu32 status = NVSP_STAT_SUCCESS;\n\tint i;\n\tint count = 0;\n\n\t \n\tif (msglen < sizeof(struct nvsp_message_header)) {\n\t\tnetif_err(net_device_ctx, rx_err, ndev,\n\t\t\t  \"invalid nvsp header, length too small: %u\\n\",\n\t\t\t  msglen);\n\t\treturn 0;\n\t}\n\n\t \n\tif (unlikely(nvsp->hdr.msg_type != NVSP_MSG1_TYPE_SEND_RNDIS_PKT)) {\n\t\tnetif_err(net_device_ctx, rx_err, ndev,\n\t\t\t  \"Unknown nvsp packet type received %u\\n\",\n\t\t\t  nvsp->hdr.msg_type);\n\t\treturn 0;\n\t}\n\n\t \n\tif ((desc->offset8 << 3) < sizeof(struct vmtransfer_page_packet_header)) {\n\t\tnetif_err(net_device_ctx, rx_err, ndev,\n\t\t\t  \"Invalid xfer page pkt, offset too small: %u\\n\",\n\t\t\t  desc->offset8 << 3);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmxferpage_packet->xfer_pageset_id != NETVSC_RECEIVE_BUFFER_ID)) {\n\t\tnetif_err(net_device_ctx, rx_err, ndev,\n\t\t\t  \"Invalid xfer page set id - expecting %x got %x\\n\",\n\t\t\t  NETVSC_RECEIVE_BUFFER_ID,\n\t\t\t  vmxferpage_packet->xfer_pageset_id);\n\t\treturn 0;\n\t}\n\n\tcount = vmxferpage_packet->range_cnt;\n\n\t \n\tif (NETVSC_XFER_HEADER_SIZE(count) > desc->offset8 << 3) {\n\t\tnetif_err(net_device_ctx, rx_err, ndev,\n\t\t\t  \"Range count is not valid: %d\\n\",\n\t\t\t  count);\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tu32 offset = vmxferpage_packet->ranges[i].byte_offset;\n\t\tu32 buflen = vmxferpage_packet->ranges[i].byte_count;\n\t\tvoid *data;\n\t\tint ret;\n\n\t\tif (unlikely(offset > net_device->recv_buf_size ||\n\t\t\t     buflen > net_device->recv_buf_size - offset)) {\n\t\t\tnvchan->rsc.cnt = 0;\n\t\t\tstatus = NVSP_STAT_FAIL;\n\t\t\tnetif_err(net_device_ctx, rx_err, ndev,\n\t\t\t\t  \"Packet offset:%u + len:%u too big\\n\",\n\t\t\t\t  offset, buflen);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (unlikely(buflen > net_device->recv_section_size)) {\n\t\t\tnvchan->rsc.cnt = 0;\n\t\t\tstatus = NVSP_STAT_FAIL;\n\t\t\tnetif_err(net_device_ctx, rx_err, ndev,\n\t\t\t\t  \"Packet too big: buflen=%u recv_section_size=%u\\n\",\n\t\t\t\t  buflen, net_device->recv_section_size);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata = recv_buf + offset;\n\n\t\tnvchan->rsc.is_last = (i == count - 1);\n\n\t\ttrace_rndis_recv(ndev, q_idx, data);\n\n\t\t \n\t\tret = rndis_filter_receive(ndev, net_device,\n\t\t\t\t\t   nvchan, data, buflen);\n\n\t\tif (unlikely(ret != NVSP_STAT_SUCCESS)) {\n\t\t\t \n\t\t\tnvchan->rsc.cnt = 0;\n\t\t\tstatus = NVSP_STAT_FAIL;\n\t\t}\n\t}\n\n\tenq_receive_complete(ndev, net_device, q_idx,\n\t\t\t     vmxferpage_packet->d.trans_id, status);\n\n\treturn count;\n}\n\nstatic void netvsc_send_table(struct net_device *ndev,\n\t\t\t      struct netvsc_device *nvscdev,\n\t\t\t      const struct nvsp_message *nvmsg,\n\t\t\t      u32 msglen)\n{\n\tstruct net_device_context *net_device_ctx = netdev_priv(ndev);\n\tu32 count, offset, *tab;\n\tint i;\n\n\t \n\tif (msglen < sizeof(struct nvsp_message_header) +\n\t\t     sizeof(struct nvsp_5_send_indirect_table)) {\n\t\tnetdev_err(ndev, \"nvsp_v5_msg length too small: %u\\n\", msglen);\n\t\treturn;\n\t}\n\n\tcount = nvmsg->msg.v5_msg.send_table.count;\n\toffset = nvmsg->msg.v5_msg.send_table.offset;\n\n\tif (count != VRSS_SEND_TAB_SIZE) {\n\t\tnetdev_err(ndev, \"Received wrong send-table size:%u\\n\", count);\n\t\treturn;\n\t}\n\n\t \n\tif (nvscdev->nvsp_version <= NVSP_PROTOCOL_VERSION_6 &&\n\t    msglen >= sizeof(struct nvsp_message_header) +\n\t    sizeof(union nvsp_6_message_uber) + count * sizeof(u32))\n\t\toffset = sizeof(struct nvsp_message_header) +\n\t\t\t sizeof(union nvsp_6_message_uber);\n\n\t \n\tif (msglen < count * sizeof(u32) || offset > msglen - count * sizeof(u32)) {\n\t\tnetdev_err(ndev, \"Received send-table offset too big:%u\\n\",\n\t\t\t   offset);\n\t\treturn;\n\t}\n\n\ttab = (void *)nvmsg + offset;\n\n\tfor (i = 0; i < count; i++)\n\t\tnet_device_ctx->tx_table[i] = tab[i];\n}\n\nstatic void netvsc_send_vf(struct net_device *ndev,\n\t\t\t   const struct nvsp_message *nvmsg,\n\t\t\t   u32 msglen)\n{\n\tstruct net_device_context *net_device_ctx = netdev_priv(ndev);\n\n\t \n\tif (msglen < sizeof(struct nvsp_message_header) +\n\t\t     sizeof(struct nvsp_4_send_vf_association)) {\n\t\tnetdev_err(ndev, \"nvsp_v4_msg length too small: %u\\n\", msglen);\n\t\treturn;\n\t}\n\n\tnet_device_ctx->vf_alloc = nvmsg->msg.v4_msg.vf_assoc.allocated;\n\tnet_device_ctx->vf_serial = nvmsg->msg.v4_msg.vf_assoc.serial;\n\n\tif (net_device_ctx->vf_alloc)\n\t\tcomplete(&net_device_ctx->vf_add);\n\n\tnetdev_info(ndev, \"VF slot %u %s\\n\",\n\t\t    net_device_ctx->vf_serial,\n\t\t    net_device_ctx->vf_alloc ? \"added\" : \"removed\");\n}\n\nstatic void netvsc_receive_inband(struct net_device *ndev,\n\t\t\t\t  struct netvsc_device *nvscdev,\n\t\t\t\t  const struct vmpacket_descriptor *desc)\n{\n\tconst struct nvsp_message *nvmsg = hv_pkt_data(desc);\n\tu32 msglen = hv_pkt_datalen(desc);\n\n\t \n\tif (msglen < sizeof(struct nvsp_message_header)) {\n\t\tnetdev_err(ndev, \"inband nvsp_message length too small: %u\\n\", msglen);\n\t\treturn;\n\t}\n\n\tswitch (nvmsg->hdr.msg_type) {\n\tcase NVSP_MSG5_TYPE_SEND_INDIRECTION_TABLE:\n\t\tnetvsc_send_table(ndev, nvscdev, nvmsg, msglen);\n\t\tbreak;\n\n\tcase NVSP_MSG4_TYPE_SEND_VF_ASSOCIATION:\n\t\tif (hv_is_isolation_supported())\n\t\t\tnetdev_err(ndev, \"Ignore VF_ASSOCIATION msg from the host supporting isolation\\n\");\n\t\telse\n\t\t\tnetvsc_send_vf(ndev, nvmsg, msglen);\n\t\tbreak;\n\t}\n}\n\nstatic int netvsc_process_raw_pkt(struct hv_device *device,\n\t\t\t\t  struct netvsc_channel *nvchan,\n\t\t\t\t  struct netvsc_device *net_device,\n\t\t\t\t  struct net_device *ndev,\n\t\t\t\t  const struct vmpacket_descriptor *desc,\n\t\t\t\t  int budget)\n{\n\tstruct vmbus_channel *channel = nvchan->channel;\n\tconst struct nvsp_message *nvmsg = hv_pkt_data(desc);\n\n\ttrace_nvsp_recv(ndev, channel, nvmsg);\n\n\tswitch (desc->type) {\n\tcase VM_PKT_COMP:\n\t\tnetvsc_send_completion(ndev, net_device, channel, desc, budget);\n\t\tbreak;\n\n\tcase VM_PKT_DATA_USING_XFER_PAGES:\n\t\treturn netvsc_receive(ndev, net_device, nvchan, desc);\n\n\tcase VM_PKT_DATA_INBAND:\n\t\tnetvsc_receive_inband(ndev, net_device, desc);\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_err(ndev, \"unhandled packet type %d, tid %llx\\n\",\n\t\t\t   desc->type, desc->trans_id);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct hv_device *netvsc_channel_to_device(struct vmbus_channel *channel)\n{\n\tstruct vmbus_channel *primary = channel->primary_channel;\n\n\treturn primary ? primary->device_obj : channel->device_obj;\n}\n\n \nint netvsc_poll(struct napi_struct *napi, int budget)\n{\n\tstruct netvsc_channel *nvchan\n\t\t= container_of(napi, struct netvsc_channel, napi);\n\tstruct netvsc_device *net_device = nvchan->net_device;\n\tstruct vmbus_channel *channel = nvchan->channel;\n\tstruct hv_device *device = netvsc_channel_to_device(channel);\n\tstruct net_device *ndev = hv_get_drvdata(device);\n\tint work_done = 0;\n\tint ret;\n\n\t \n\tif (!nvchan->desc)\n\t\tnvchan->desc = hv_pkt_iter_first(channel);\n\n\tnvchan->xdp_flush = false;\n\n\twhile (nvchan->desc && work_done < budget) {\n\t\twork_done += netvsc_process_raw_pkt(device, nvchan, net_device,\n\t\t\t\t\t\t    ndev, nvchan->desc, budget);\n\t\tnvchan->desc = hv_pkt_iter_next(channel, nvchan->desc);\n\t}\n\n\tif (nvchan->xdp_flush)\n\t\txdp_do_flush();\n\n\t \n\tret = send_recv_completions(ndev, net_device, nvchan);\n\n\t \n\tif (work_done < budget &&\n\t    napi_complete_done(napi, work_done) &&\n\t    (ret || hv_end_read(&channel->inbound)) &&\n\t    napi_schedule_prep(napi)) {\n\t\thv_begin_read(&channel->inbound);\n\t\t__napi_schedule(napi);\n\t}\n\n\t \n\treturn min(work_done, budget);\n}\n\n \nvoid netvsc_channel_cb(void *context)\n{\n\tstruct netvsc_channel *nvchan = context;\n\tstruct vmbus_channel *channel = nvchan->channel;\n\tstruct hv_ring_buffer_info *rbi = &channel->inbound;\n\n\t \n\tprefetch(hv_get_ring_buffer(rbi) + rbi->priv_read_index);\n\n\tif (napi_schedule_prep(&nvchan->napi)) {\n\t\t \n\t\thv_begin_read(rbi);\n\n\t\t__napi_schedule_irqoff(&nvchan->napi);\n\t}\n}\n\n \nstruct netvsc_device *netvsc_device_add(struct hv_device *device,\n\t\t\t\tconst struct netvsc_device_info *device_info)\n{\n\tint i, ret = 0;\n\tstruct netvsc_device *net_device;\n\tstruct net_device *ndev = hv_get_drvdata(device);\n\tstruct net_device_context *net_device_ctx = netdev_priv(ndev);\n\n\tnet_device = alloc_net_device();\n\tif (!net_device)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < VRSS_SEND_TAB_SIZE; i++)\n\t\tnet_device_ctx->tx_table[i] = 0;\n\n\t \n\tset_channel_read_mode(device->channel, HV_CALL_ISR);\n\n\t \n\n\tfor (i = 0; i < VRSS_CHANNEL_MAX; i++) {\n\t\tstruct netvsc_channel *nvchan = &net_device->chan_table[i];\n\n\t\tnvchan->channel = device->channel;\n\t\tnvchan->net_device = net_device;\n\t\tu64_stats_init(&nvchan->tx_stats.syncp);\n\t\tu64_stats_init(&nvchan->rx_stats.syncp);\n\n\t\tret = xdp_rxq_info_reg(&nvchan->xdp_rxq, ndev, i, 0);\n\n\t\tif (ret) {\n\t\t\tnetdev_err(ndev, \"xdp_rxq_info_reg fail: %d\\n\", ret);\n\t\t\tgoto cleanup2;\n\t\t}\n\n\t\tret = xdp_rxq_info_reg_mem_model(&nvchan->xdp_rxq,\n\t\t\t\t\t\t MEM_TYPE_PAGE_SHARED, NULL);\n\n\t\tif (ret) {\n\t\t\tnetdev_err(ndev, \"xdp reg_mem_model fail: %d\\n\", ret);\n\t\t\tgoto cleanup2;\n\t\t}\n\t}\n\n\t \n\tnetif_napi_add(ndev, &net_device->chan_table[0].napi, netvsc_poll);\n\n\t \n\tdevice->channel->next_request_id_callback = vmbus_next_request_id;\n\tdevice->channel->request_addr_callback = vmbus_request_addr;\n\tdevice->channel->rqstor_size = netvsc_rqstor_size(netvsc_ring_bytes);\n\tdevice->channel->max_pkt_size = NETVSC_MAX_PKT_SIZE;\n\n\tret = vmbus_open(device->channel, netvsc_ring_bytes,\n\t\t\t netvsc_ring_bytes,  NULL, 0,\n\t\t\t netvsc_channel_cb, net_device->chan_table);\n\n\tif (ret != 0) {\n\t\tnetdev_err(ndev, \"unable to open channel: %d\\n\", ret);\n\t\tgoto cleanup;\n\t}\n\n\t \n\tnetdev_dbg(ndev, \"hv_netvsc channel opened successfully\\n\");\n\n\tnapi_enable(&net_device->chan_table[0].napi);\n\n\t \n\tret = netvsc_connect_vsp(device, net_device, device_info);\n\tif (ret != 0) {\n\t\tnetdev_err(ndev,\n\t\t\t\"unable to connect to NetVSP - %d\\n\", ret);\n\t\tgoto close;\n\t}\n\n\t \n\trcu_assign_pointer(net_device_ctx->nvdev, net_device);\n\n\treturn net_device;\n\nclose:\n\tRCU_INIT_POINTER(net_device_ctx->nvdev, NULL);\n\tnapi_disable(&net_device->chan_table[0].napi);\n\n\t \n\tvmbus_close(device->channel);\n\ncleanup:\n\tnetif_napi_del(&net_device->chan_table[0].napi);\n\ncleanup2:\n\tfree_netvsc_device(&net_device->rcu);\n\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}