{
  "module_name": "net_failover.c",
  "hash_id": "2f783d01cc73158870546785c51f5503248503864c67634f4d9d79947ddeb176",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/net_failover.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/netpoll.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_vlan.h>\n#include <linux/pci.h>\n#include <net/sch_generic.h>\n#include <uapi/linux/if_arp.h>\n#include <net/net_failover.h>\n\nstatic bool net_failover_xmit_ready(struct net_device *dev)\n{\n\treturn netif_running(dev) && netif_carrier_ok(dev);\n}\n\nstatic int net_failover_open(struct net_device *dev)\n{\n\tstruct net_failover_info *nfo_info = netdev_priv(dev);\n\tstruct net_device *primary_dev, *standby_dev;\n\tint err;\n\n\tprimary_dev = rtnl_dereference(nfo_info->primary_dev);\n\tif (primary_dev) {\n\t\terr = dev_open(primary_dev, NULL);\n\t\tif (err)\n\t\t\tgoto err_primary_open;\n\t}\n\n\tstandby_dev = rtnl_dereference(nfo_info->standby_dev);\n\tif (standby_dev) {\n\t\terr = dev_open(standby_dev, NULL);\n\t\tif (err)\n\t\t\tgoto err_standby_open;\n\t}\n\n\tif ((primary_dev && net_failover_xmit_ready(primary_dev)) ||\n\t    (standby_dev && net_failover_xmit_ready(standby_dev))) {\n\t\tnetif_carrier_on(dev);\n\t\tnetif_tx_wake_all_queues(dev);\n\t}\n\n\treturn 0;\n\nerr_standby_open:\n\tif (primary_dev)\n\t\tdev_close(primary_dev);\nerr_primary_open:\n\tnetif_tx_disable(dev);\n\treturn err;\n}\n\nstatic int net_failover_close(struct net_device *dev)\n{\n\tstruct net_failover_info *nfo_info = netdev_priv(dev);\n\tstruct net_device *slave_dev;\n\n\tnetif_tx_disable(dev);\n\n\tslave_dev = rtnl_dereference(nfo_info->primary_dev);\n\tif (slave_dev)\n\t\tdev_close(slave_dev);\n\n\tslave_dev = rtnl_dereference(nfo_info->standby_dev);\n\tif (slave_dev)\n\t\tdev_close(slave_dev);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t net_failover_drop_xmit(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *dev)\n{\n\tdev_core_stats_tx_dropped_inc(dev);\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic netdev_tx_t net_failover_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tstruct net_failover_info *nfo_info = netdev_priv(dev);\n\tstruct net_device *xmit_dev;\n\n\t \n\txmit_dev = rcu_dereference_bh(nfo_info->primary_dev);\n\tif (!xmit_dev || !net_failover_xmit_ready(xmit_dev)) {\n\t\txmit_dev = rcu_dereference_bh(nfo_info->standby_dev);\n\t\tif (!xmit_dev || !net_failover_xmit_ready(xmit_dev))\n\t\t\treturn net_failover_drop_xmit(skb, dev);\n\t}\n\n\tskb->dev = xmit_dev;\n\tskb->queue_mapping = qdisc_skb_cb(skb)->slave_dev_queue_mapping;\n\n\treturn dev_queue_xmit(skb);\n}\n\nstatic u16 net_failover_select_queue(struct net_device *dev,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     struct net_device *sb_dev)\n{\n\tstruct net_failover_info *nfo_info = netdev_priv(dev);\n\tstruct net_device *primary_dev;\n\tu16 txq;\n\n\tprimary_dev = rcu_dereference(nfo_info->primary_dev);\n\tif (primary_dev) {\n\t\tconst struct net_device_ops *ops = primary_dev->netdev_ops;\n\n\t\tif (ops->ndo_select_queue)\n\t\t\ttxq = ops->ndo_select_queue(primary_dev, skb, sb_dev);\n\t\telse\n\t\t\ttxq = netdev_pick_tx(primary_dev, skb, NULL);\n\t} else {\n\t\ttxq = skb_rx_queue_recorded(skb) ? skb_get_rx_queue(skb) : 0;\n\t}\n\n\t \n\tqdisc_skb_cb(skb)->slave_dev_queue_mapping = skb->queue_mapping;\n\n\tif (unlikely(txq >= dev->real_num_tx_queues)) {\n\t\tdo {\n\t\t\ttxq -= dev->real_num_tx_queues;\n\t\t} while (txq >= dev->real_num_tx_queues);\n\t}\n\n\treturn txq;\n}\n\n \nstatic void net_failover_fold_stats(struct rtnl_link_stats64 *_res,\n\t\t\t\t    const struct rtnl_link_stats64 *_new,\n\t\t\t\t    const struct rtnl_link_stats64 *_old)\n{\n\tconst u64 *new = (const u64 *)_new;\n\tconst u64 *old = (const u64 *)_old;\n\tu64 *res = (u64 *)_res;\n\tint i;\n\n\tfor (i = 0; i < sizeof(*_res) / sizeof(u64); i++) {\n\t\tu64 nv = new[i];\n\t\tu64 ov = old[i];\n\t\ts64 delta = nv - ov;\n\n\t\t \n\t\tif (((nv | ov) >> 32) == 0)\n\t\t\tdelta = (s64)(s32)((u32)nv - (u32)ov);\n\n\t\t \n\t\tif (delta > 0)\n\t\t\tres[i] += delta;\n\t}\n}\n\nstatic void net_failover_get_stats(struct net_device *dev,\n\t\t\t\t   struct rtnl_link_stats64 *stats)\n{\n\tstruct net_failover_info *nfo_info = netdev_priv(dev);\n\tconst struct rtnl_link_stats64 *new;\n\tstruct rtnl_link_stats64 temp;\n\tstruct net_device *slave_dev;\n\n\tspin_lock(&nfo_info->stats_lock);\n\tmemcpy(stats, &nfo_info->failover_stats, sizeof(*stats));\n\n\trcu_read_lock();\n\n\tslave_dev = rcu_dereference(nfo_info->primary_dev);\n\tif (slave_dev) {\n\t\tnew = dev_get_stats(slave_dev, &temp);\n\t\tnet_failover_fold_stats(stats, new, &nfo_info->primary_stats);\n\t\tmemcpy(&nfo_info->primary_stats, new, sizeof(*new));\n\t}\n\n\tslave_dev = rcu_dereference(nfo_info->standby_dev);\n\tif (slave_dev) {\n\t\tnew = dev_get_stats(slave_dev, &temp);\n\t\tnet_failover_fold_stats(stats, new, &nfo_info->standby_stats);\n\t\tmemcpy(&nfo_info->standby_stats, new, sizeof(*new));\n\t}\n\n\trcu_read_unlock();\n\n\tmemcpy(&nfo_info->failover_stats, stats, sizeof(*stats));\n\tspin_unlock(&nfo_info->stats_lock);\n}\n\nstatic int net_failover_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct net_failover_info *nfo_info = netdev_priv(dev);\n\tstruct net_device *primary_dev, *standby_dev;\n\tint ret = 0;\n\n\tprimary_dev = rtnl_dereference(nfo_info->primary_dev);\n\tif (primary_dev) {\n\t\tret = dev_set_mtu(primary_dev, new_mtu);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tstandby_dev = rtnl_dereference(nfo_info->standby_dev);\n\tif (standby_dev) {\n\t\tret = dev_set_mtu(standby_dev, new_mtu);\n\t\tif (ret) {\n\t\t\tif (primary_dev)\n\t\t\t\tdev_set_mtu(primary_dev, dev->mtu);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\nstatic void net_failover_set_rx_mode(struct net_device *dev)\n{\n\tstruct net_failover_info *nfo_info = netdev_priv(dev);\n\tstruct net_device *slave_dev;\n\n\trcu_read_lock();\n\n\tslave_dev = rcu_dereference(nfo_info->primary_dev);\n\tif (slave_dev) {\n\t\tdev_uc_sync_multiple(slave_dev, dev);\n\t\tdev_mc_sync_multiple(slave_dev, dev);\n\t}\n\n\tslave_dev = rcu_dereference(nfo_info->standby_dev);\n\tif (slave_dev) {\n\t\tdev_uc_sync_multiple(slave_dev, dev);\n\t\tdev_mc_sync_multiple(slave_dev, dev);\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic int net_failover_vlan_rx_add_vid(struct net_device *dev, __be16 proto,\n\t\t\t\t\tu16 vid)\n{\n\tstruct net_failover_info *nfo_info = netdev_priv(dev);\n\tstruct net_device *primary_dev, *standby_dev;\n\tint ret = 0;\n\n\tprimary_dev = rcu_dereference(nfo_info->primary_dev);\n\tif (primary_dev) {\n\t\tret = vlan_vid_add(primary_dev, proto, vid);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tstandby_dev = rcu_dereference(nfo_info->standby_dev);\n\tif (standby_dev) {\n\t\tret = vlan_vid_add(standby_dev, proto, vid);\n\t\tif (ret)\n\t\t\tif (primary_dev)\n\t\t\t\tvlan_vid_del(primary_dev, proto, vid);\n\t}\n\n\treturn ret;\n}\n\nstatic int net_failover_vlan_rx_kill_vid(struct net_device *dev, __be16 proto,\n\t\t\t\t\t u16 vid)\n{\n\tstruct net_failover_info *nfo_info = netdev_priv(dev);\n\tstruct net_device *slave_dev;\n\n\tslave_dev = rcu_dereference(nfo_info->primary_dev);\n\tif (slave_dev)\n\t\tvlan_vid_del(slave_dev, proto, vid);\n\n\tslave_dev = rcu_dereference(nfo_info->standby_dev);\n\tif (slave_dev)\n\t\tvlan_vid_del(slave_dev, proto, vid);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops failover_dev_ops = {\n\t.ndo_open\t\t= net_failover_open,\n\t.ndo_stop\t\t= net_failover_close,\n\t.ndo_start_xmit\t\t= net_failover_start_xmit,\n\t.ndo_select_queue\t= net_failover_select_queue,\n\t.ndo_get_stats64\t= net_failover_get_stats,\n\t.ndo_change_mtu\t\t= net_failover_change_mtu,\n\t.ndo_set_rx_mode\t= net_failover_set_rx_mode,\n\t.ndo_vlan_rx_add_vid\t= net_failover_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= net_failover_vlan_rx_kill_vid,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_features_check\t= passthru_features_check,\n};\n\n#define FAILOVER_NAME \"net_failover\"\n#define FAILOVER_VERSION \"0.1\"\n\nstatic void nfo_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t    struct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->driver, FAILOVER_NAME, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->version, FAILOVER_VERSION, sizeof(drvinfo->version));\n}\n\nstatic int nfo_ethtool_get_link_ksettings(struct net_device *dev,\n\t\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct net_failover_info *nfo_info = netdev_priv(dev);\n\tstruct net_device *slave_dev;\n\n\tslave_dev = rtnl_dereference(nfo_info->primary_dev);\n\tif (!slave_dev || !net_failover_xmit_ready(slave_dev)) {\n\t\tslave_dev = rtnl_dereference(nfo_info->standby_dev);\n\t\tif (!slave_dev || !net_failover_xmit_ready(slave_dev)) {\n\t\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t\t\tcmd->base.port = PORT_OTHER;\n\t\t\tcmd->base.speed = SPEED_UNKNOWN;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn __ethtool_get_link_ksettings(slave_dev, cmd);\n}\n\nstatic const struct ethtool_ops failover_ethtool_ops = {\n\t.get_drvinfo            = nfo_ethtool_get_drvinfo,\n\t.get_link               = ethtool_op_get_link,\n\t.get_link_ksettings     = nfo_ethtool_get_link_ksettings,\n};\n\n \nstatic rx_handler_result_t net_failover_handle_frame(struct sk_buff **pskb)\n{\n\tstruct sk_buff *skb = *pskb;\n\tstruct net_device *dev = rcu_dereference(skb->dev->rx_handler_data);\n\tstruct net_failover_info *nfo_info = netdev_priv(dev);\n\tstruct net_device *primary_dev, *standby_dev;\n\n\tprimary_dev = rcu_dereference(nfo_info->primary_dev);\n\tstandby_dev = rcu_dereference(nfo_info->standby_dev);\n\n\tif (primary_dev && skb->dev == standby_dev)\n\t\treturn RX_HANDLER_EXACT;\n\n\tskb->dev = dev;\n\n\treturn RX_HANDLER_ANOTHER;\n}\n\nstatic void net_failover_compute_features(struct net_device *dev)\n{\n\tnetdev_features_t vlan_features = FAILOVER_VLAN_FEATURES &\n\t\t\t\t\t  NETIF_F_ALL_FOR_ALL;\n\tnetdev_features_t enc_features  = FAILOVER_ENC_FEATURES;\n\tunsigned short max_hard_header_len = ETH_HLEN;\n\tunsigned int dst_release_flag = IFF_XMIT_DST_RELEASE |\n\t\t\t\t\tIFF_XMIT_DST_RELEASE_PERM;\n\tstruct net_failover_info *nfo_info = netdev_priv(dev);\n\tstruct net_device *primary_dev, *standby_dev;\n\n\tprimary_dev = rcu_dereference(nfo_info->primary_dev);\n\tif (primary_dev) {\n\t\tvlan_features =\n\t\t\tnetdev_increment_features(vlan_features,\n\t\t\t\t\t\t  primary_dev->vlan_features,\n\t\t\t\t\t\t  FAILOVER_VLAN_FEATURES);\n\t\tenc_features =\n\t\t\tnetdev_increment_features(enc_features,\n\t\t\t\t\t\t  primary_dev->hw_enc_features,\n\t\t\t\t\t\t  FAILOVER_ENC_FEATURES);\n\n\t\tdst_release_flag &= primary_dev->priv_flags;\n\t\tif (primary_dev->hard_header_len > max_hard_header_len)\n\t\t\tmax_hard_header_len = primary_dev->hard_header_len;\n\t}\n\n\tstandby_dev = rcu_dereference(nfo_info->standby_dev);\n\tif (standby_dev) {\n\t\tvlan_features =\n\t\t\tnetdev_increment_features(vlan_features,\n\t\t\t\t\t\t  standby_dev->vlan_features,\n\t\t\t\t\t\t  FAILOVER_VLAN_FEATURES);\n\t\tenc_features =\n\t\t\tnetdev_increment_features(enc_features,\n\t\t\t\t\t\t  standby_dev->hw_enc_features,\n\t\t\t\t\t\t  FAILOVER_ENC_FEATURES);\n\n\t\tdst_release_flag &= standby_dev->priv_flags;\n\t\tif (standby_dev->hard_header_len > max_hard_header_len)\n\t\t\tmax_hard_header_len = standby_dev->hard_header_len;\n\t}\n\n\tdev->vlan_features = vlan_features;\n\tdev->hw_enc_features = enc_features | NETIF_F_GSO_ENCAP_ALL;\n\tdev->hard_header_len = max_hard_header_len;\n\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\tif (dst_release_flag == (IFF_XMIT_DST_RELEASE |\n\t\t\t\t IFF_XMIT_DST_RELEASE_PERM))\n\t\tdev->priv_flags |= IFF_XMIT_DST_RELEASE;\n\n\tnetdev_change_features(dev);\n}\n\nstatic void net_failover_lower_state_changed(struct net_device *slave_dev,\n\t\t\t\t\t     struct net_device *primary_dev,\n\t\t\t\t\t     struct net_device *standby_dev)\n{\n\tstruct netdev_lag_lower_state_info info;\n\n\tif (netif_carrier_ok(slave_dev))\n\t\tinfo.link_up = true;\n\telse\n\t\tinfo.link_up = false;\n\n\tif (slave_dev == primary_dev) {\n\t\tif (netif_running(primary_dev))\n\t\t\tinfo.tx_enabled = true;\n\t\telse\n\t\t\tinfo.tx_enabled = false;\n\t} else {\n\t\tif ((primary_dev && netif_running(primary_dev)) ||\n\t\t    (!netif_running(standby_dev)))\n\t\t\tinfo.tx_enabled = false;\n\t\telse\n\t\t\tinfo.tx_enabled = true;\n\t}\n\n\tnetdev_lower_state_changed(slave_dev, &info);\n}\n\nstatic int net_failover_slave_pre_register(struct net_device *slave_dev,\n\t\t\t\t\t   struct net_device *failover_dev)\n{\n\tstruct net_device *standby_dev, *primary_dev;\n\tstruct net_failover_info *nfo_info;\n\tbool slave_is_standby;\n\n\tnfo_info = netdev_priv(failover_dev);\n\tstandby_dev = rtnl_dereference(nfo_info->standby_dev);\n\tprimary_dev = rtnl_dereference(nfo_info->primary_dev);\n\tslave_is_standby = slave_dev->dev.parent == failover_dev->dev.parent;\n\tif (slave_is_standby ? standby_dev : primary_dev) {\n\t\tnetdev_err(failover_dev, \"%s attempting to register as slave dev when %s already present\\n\",\n\t\t\t   slave_dev->name,\n\t\t\t   slave_is_standby ? \"standby\" : \"primary\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!slave_is_standby && (!slave_dev->dev.parent ||\n\t\t\t\t  !dev_is_pci(slave_dev->dev.parent)))\n\t\treturn -EINVAL;\n\n\tif (failover_dev->features & NETIF_F_VLAN_CHALLENGED &&\n\t    vlan_uses_dev(failover_dev)) {\n\t\tnetdev_err(failover_dev, \"Device %s is VLAN challenged and failover device has VLAN set up\\n\",\n\t\t\t   failover_dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int net_failover_slave_register(struct net_device *slave_dev,\n\t\t\t\t       struct net_device *failover_dev)\n{\n\tstruct net_device *standby_dev, *primary_dev;\n\tstruct net_failover_info *nfo_info;\n\tbool slave_is_standby;\n\tu32 orig_mtu;\n\tint err;\n\n\t \n\torig_mtu = slave_dev->mtu;\n\terr = dev_set_mtu(slave_dev, failover_dev->mtu);\n\tif (err) {\n\t\tnetdev_err(failover_dev, \"unable to change mtu of %s to %u register failed\\n\",\n\t\t\t   slave_dev->name, failover_dev->mtu);\n\t\tgoto done;\n\t}\n\n\tdev_hold(slave_dev);\n\n\tif (netif_running(failover_dev)) {\n\t\terr = dev_open(slave_dev, NULL);\n\t\tif (err && (err != -EBUSY)) {\n\t\t\tnetdev_err(failover_dev, \"Opening slave %s failed err:%d\\n\",\n\t\t\t\t   slave_dev->name, err);\n\t\t\tgoto err_dev_open;\n\t\t}\n\t}\n\n\tnetif_addr_lock_bh(failover_dev);\n\tdev_uc_sync_multiple(slave_dev, failover_dev);\n\tdev_mc_sync_multiple(slave_dev, failover_dev);\n\tnetif_addr_unlock_bh(failover_dev);\n\n\terr = vlan_vids_add_by_dev(slave_dev, failover_dev);\n\tif (err) {\n\t\tnetdev_err(failover_dev, \"Failed to add vlan ids to device %s err:%d\\n\",\n\t\t\t   slave_dev->name, err);\n\t\tgoto err_vlan_add;\n\t}\n\n\tnfo_info = netdev_priv(failover_dev);\n\tstandby_dev = rtnl_dereference(nfo_info->standby_dev);\n\tprimary_dev = rtnl_dereference(nfo_info->primary_dev);\n\tslave_is_standby = slave_dev->dev.parent == failover_dev->dev.parent;\n\n\tif (slave_is_standby) {\n\t\trcu_assign_pointer(nfo_info->standby_dev, slave_dev);\n\t\tstandby_dev = slave_dev;\n\t\tdev_get_stats(standby_dev, &nfo_info->standby_stats);\n\t} else {\n\t\trcu_assign_pointer(nfo_info->primary_dev, slave_dev);\n\t\tprimary_dev = slave_dev;\n\t\tdev_get_stats(primary_dev, &nfo_info->primary_stats);\n\t\tfailover_dev->min_mtu = slave_dev->min_mtu;\n\t\tfailover_dev->max_mtu = slave_dev->max_mtu;\n\t}\n\n\tnet_failover_lower_state_changed(slave_dev, primary_dev, standby_dev);\n\tnet_failover_compute_features(failover_dev);\n\n\tcall_netdevice_notifiers(NETDEV_JOIN, slave_dev);\n\n\tnetdev_info(failover_dev, \"failover %s slave:%s registered\\n\",\n\t\t    slave_is_standby ? \"standby\" : \"primary\", slave_dev->name);\n\n\treturn 0;\n\nerr_vlan_add:\n\tdev_uc_unsync(slave_dev, failover_dev);\n\tdev_mc_unsync(slave_dev, failover_dev);\n\tdev_close(slave_dev);\nerr_dev_open:\n\tdev_put(slave_dev);\n\tdev_set_mtu(slave_dev, orig_mtu);\ndone:\n\treturn err;\n}\n\nstatic int net_failover_slave_pre_unregister(struct net_device *slave_dev,\n\t\t\t\t\t     struct net_device *failover_dev)\n{\n\tstruct net_device *standby_dev, *primary_dev;\n\tstruct net_failover_info *nfo_info;\n\n\tnfo_info = netdev_priv(failover_dev);\n\tprimary_dev = rtnl_dereference(nfo_info->primary_dev);\n\tstandby_dev = rtnl_dereference(nfo_info->standby_dev);\n\n\tif (slave_dev != primary_dev && slave_dev != standby_dev)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int net_failover_slave_unregister(struct net_device *slave_dev,\n\t\t\t\t\t struct net_device *failover_dev)\n{\n\tstruct net_device *standby_dev, *primary_dev;\n\tstruct net_failover_info *nfo_info;\n\tbool slave_is_standby;\n\n\tnfo_info = netdev_priv(failover_dev);\n\tprimary_dev = rtnl_dereference(nfo_info->primary_dev);\n\tstandby_dev = rtnl_dereference(nfo_info->standby_dev);\n\n\tif (WARN_ON_ONCE(slave_dev != primary_dev && slave_dev != standby_dev))\n\t\treturn -ENODEV;\n\n\tvlan_vids_del_by_dev(slave_dev, failover_dev);\n\tdev_uc_unsync(slave_dev, failover_dev);\n\tdev_mc_unsync(slave_dev, failover_dev);\n\tdev_close(slave_dev);\n\n\tnfo_info = netdev_priv(failover_dev);\n\tdev_get_stats(failover_dev, &nfo_info->failover_stats);\n\n\tslave_is_standby = slave_dev->dev.parent == failover_dev->dev.parent;\n\tif (slave_is_standby) {\n\t\tRCU_INIT_POINTER(nfo_info->standby_dev, NULL);\n\t} else {\n\t\tRCU_INIT_POINTER(nfo_info->primary_dev, NULL);\n\t\tif (standby_dev) {\n\t\t\tfailover_dev->min_mtu = standby_dev->min_mtu;\n\t\t\tfailover_dev->max_mtu = standby_dev->max_mtu;\n\t\t}\n\t}\n\n\tdev_put(slave_dev);\n\n\tnet_failover_compute_features(failover_dev);\n\n\tnetdev_info(failover_dev, \"failover %s slave:%s unregistered\\n\",\n\t\t    slave_is_standby ? \"standby\" : \"primary\", slave_dev->name);\n\n\treturn 0;\n}\n\nstatic int net_failover_slave_link_change(struct net_device *slave_dev,\n\t\t\t\t\t  struct net_device *failover_dev)\n{\n\tstruct net_device *primary_dev, *standby_dev;\n\tstruct net_failover_info *nfo_info;\n\n\tnfo_info = netdev_priv(failover_dev);\n\n\tprimary_dev = rtnl_dereference(nfo_info->primary_dev);\n\tstandby_dev = rtnl_dereference(nfo_info->standby_dev);\n\n\tif (slave_dev != primary_dev && slave_dev != standby_dev)\n\t\treturn -ENODEV;\n\n\tif ((primary_dev && net_failover_xmit_ready(primary_dev)) ||\n\t    (standby_dev && net_failover_xmit_ready(standby_dev))) {\n\t\tnetif_carrier_on(failover_dev);\n\t\tnetif_tx_wake_all_queues(failover_dev);\n\t} else {\n\t\tdev_get_stats(failover_dev, &nfo_info->failover_stats);\n\t\tnetif_carrier_off(failover_dev);\n\t\tnetif_tx_stop_all_queues(failover_dev);\n\t}\n\n\tnet_failover_lower_state_changed(slave_dev, primary_dev, standby_dev);\n\n\treturn 0;\n}\n\nstatic int net_failover_slave_name_change(struct net_device *slave_dev,\n\t\t\t\t\t  struct net_device *failover_dev)\n{\n\tstruct net_device *primary_dev, *standby_dev;\n\tstruct net_failover_info *nfo_info;\n\n\tnfo_info = netdev_priv(failover_dev);\n\n\tprimary_dev = rtnl_dereference(nfo_info->primary_dev);\n\tstandby_dev = rtnl_dereference(nfo_info->standby_dev);\n\n\tif (slave_dev != primary_dev && slave_dev != standby_dev)\n\t\treturn -ENODEV;\n\n\t \n\tdev_open(slave_dev, NULL);\n\n\treturn 0;\n}\n\nstatic struct failover_ops net_failover_ops = {\n\t.slave_pre_register\t= net_failover_slave_pre_register,\n\t.slave_register\t\t= net_failover_slave_register,\n\t.slave_pre_unregister\t= net_failover_slave_pre_unregister,\n\t.slave_unregister\t= net_failover_slave_unregister,\n\t.slave_link_change\t= net_failover_slave_link_change,\n\t.slave_name_change\t= net_failover_slave_name_change,\n\t.slave_handle_frame\t= net_failover_handle_frame,\n};\n\n \nstruct failover *net_failover_create(struct net_device *standby_dev)\n{\n\tstruct device *dev = standby_dev->dev.parent;\n\tstruct net_device *failover_dev;\n\tstruct failover *failover;\n\tint err;\n\n\t \n\tfailover_dev = alloc_etherdev_mq(sizeof(struct net_failover_info), 16);\n\tif (!failover_dev) {\n\t\tdev_err(dev, \"Unable to allocate failover_netdev!\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdev_net_set(failover_dev, dev_net(standby_dev));\n\tSET_NETDEV_DEV(failover_dev, dev);\n\n\tfailover_dev->netdev_ops = &failover_dev_ops;\n\tfailover_dev->ethtool_ops = &failover_ethtool_ops;\n\n\t \n\tfailover_dev->priv_flags |= IFF_UNICAST_FLT | IFF_NO_QUEUE;\n\tfailover_dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE |\n\t\t\t\t       IFF_TX_SKB_SHARING);\n\n\t \n\tfailover_dev->features |= NETIF_F_LLTX;\n\n\t \n\tfailover_dev->features |= NETIF_F_NETNS_LOCAL;\n\n\tfailover_dev->hw_features = FAILOVER_VLAN_FEATURES |\n\t\t\t\t    NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t    NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t\t    NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\tfailover_dev->hw_features |= NETIF_F_GSO_ENCAP_ALL;\n\tfailover_dev->features |= failover_dev->hw_features;\n\n\tdev_addr_set(failover_dev, standby_dev->dev_addr);\n\n\tfailover_dev->min_mtu = standby_dev->min_mtu;\n\tfailover_dev->max_mtu = standby_dev->max_mtu;\n\n\terr = register_netdev(failover_dev);\n\tif (err) {\n\t\tdev_err(dev, \"Unable to register failover_dev!\\n\");\n\t\tgoto err_register_netdev;\n\t}\n\n\tnetif_carrier_off(failover_dev);\n\n\tfailover = failover_register(failover_dev, &net_failover_ops);\n\tif (IS_ERR(failover)) {\n\t\terr = PTR_ERR(failover);\n\t\tgoto err_failover_register;\n\t}\n\n\treturn failover;\n\nerr_failover_register:\n\tunregister_netdev(failover_dev);\nerr_register_netdev:\n\tfree_netdev(failover_dev);\n\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(net_failover_create);\n\n \nvoid net_failover_destroy(struct failover *failover)\n{\n\tstruct net_failover_info *nfo_info;\n\tstruct net_device *failover_dev;\n\tstruct net_device *slave_dev;\n\n\tif (!failover)\n\t\treturn;\n\n\tfailover_dev = rcu_dereference(failover->failover_dev);\n\tnfo_info = netdev_priv(failover_dev);\n\n\tnetif_device_detach(failover_dev);\n\n\trtnl_lock();\n\n\tslave_dev = rtnl_dereference(nfo_info->primary_dev);\n\tif (slave_dev)\n\t\tfailover_slave_unregister(slave_dev);\n\n\tslave_dev = rtnl_dereference(nfo_info->standby_dev);\n\tif (slave_dev)\n\t\tfailover_slave_unregister(slave_dev);\n\n\tfailover_unregister(failover);\n\n\tunregister_netdevice(failover_dev);\n\n\trtnl_unlock();\n\n\tfree_netdev(failover_dev);\n}\nEXPORT_SYMBOL_GPL(net_failover_destroy);\n\nstatic __init int\nnet_failover_init(void)\n{\n\treturn 0;\n}\nmodule_init(net_failover_init);\n\nstatic __exit\nvoid net_failover_exit(void)\n{\n}\nmodule_exit(net_failover_exit);\n\nMODULE_DESCRIPTION(\"Failover driver for Paravirtual drivers\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}