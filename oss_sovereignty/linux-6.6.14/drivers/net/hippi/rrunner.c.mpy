{
  "module_name": "rrunner.c",
  "hash_id": "7e160e5ddec4a1f9f3a67fb6bdd341591c22d54044ea0d91142fcd343e5dd72c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hippi/rrunner.c",
  "human_readable_source": "\n \n\n\n#define DEBUG 1\n#define RX_DMA_SKBUFF 1\n#define PKT_COPY_THRESHOLD 512\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/hippidevice.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n\n#include <asm/cache.h>\n#include <asm/byteorder.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n\n#define rr_if_busy(dev)     netif_queue_stopped(dev)\n#define rr_if_running(dev)  netif_running(dev)\n\n#include \"rrunner.h\"\n\n#define RUN_AT(x) (jiffies + (x))\n\n\nMODULE_AUTHOR(\"Jes Sorensen <jes@wildopensource.com>\");\nMODULE_DESCRIPTION(\"Essential RoadRunner HIPPI driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const char version[] =\n\"rrunner.c: v0.50 11/11/2002  Jes Sorensen (jes@wildopensource.com)\\n\";\n\n\nstatic const struct net_device_ops rr_netdev_ops = {\n\t.ndo_open \t\t= rr_open,\n\t.ndo_stop\t\t= rr_close,\n\t.ndo_siocdevprivate\t= rr_siocdevprivate,\n\t.ndo_start_xmit\t\t= rr_start_xmit,\n\t.ndo_set_mac_address\t= hippi_mac_addr,\n};\n\n \n\nstatic int rr_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstatic int version_disp;\n\tu8 pci_latency;\n\tstruct rr_private *rrpriv;\n\tvoid *tmpptr;\n\tdma_addr_t ring_dma;\n\tint ret = -ENOMEM;\n\n\tdev = alloc_hippi_dev(sizeof(struct rr_private));\n\tif (!dev)\n\t\tgoto out3;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tret = -ENODEV;\n\t\tgoto out2;\n\t}\n\n\trrpriv = netdev_priv(dev);\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tret = pci_request_regions(pdev, \"rrunner\");\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpci_set_drvdata(pdev, dev);\n\n\trrpriv->pci_dev = pdev;\n\n\tspin_lock_init(&rrpriv->lock);\n\n\tdev->netdev_ops = &rr_netdev_ops;\n\n\t \n\tif (!version_disp) {\n\t\t \n\t\t \n\t\tversion_disp = 1;\n\t\tprintk(version);\n\t}\n\n\tpci_read_config_byte(pdev, PCI_LATENCY_TIMER, &pci_latency);\n\tif (pci_latency <= 0x58){\n\t\tpci_latency = 0x58;\n\t\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, pci_latency);\n\t}\n\n\tpci_set_master(pdev);\n\n\tprintk(KERN_INFO \"%s: Essential RoadRunner serial HIPPI \"\n\t       \"at 0x%llx, irq %i, PCI latency %i\\n\", dev->name,\n\t       (unsigned long long)pci_resource_start(pdev, 0),\n\t       pdev->irq, pci_latency);\n\n\t \n\trrpriv->regs = pci_iomap(pdev, 0, 0x1000);\n\tif (!rrpriv->regs) {\n\t\tprintk(KERN_ERR \"%s:  Unable to map I/O register, \"\n\t\t\t\"RoadRunner will be disabled.\\n\", dev->name);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\ttmpptr = dma_alloc_coherent(&pdev->dev, TX_TOTAL_SIZE, &ring_dma,\n\t\t\t\t    GFP_KERNEL);\n\trrpriv->tx_ring = tmpptr;\n\trrpriv->tx_ring_dma = ring_dma;\n\n\tif (!tmpptr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttmpptr = dma_alloc_coherent(&pdev->dev, RX_TOTAL_SIZE, &ring_dma,\n\t\t\t\t    GFP_KERNEL);\n\trrpriv->rx_ring = tmpptr;\n\trrpriv->rx_ring_dma = ring_dma;\n\n\tif (!tmpptr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttmpptr = dma_alloc_coherent(&pdev->dev, EVT_RING_SIZE, &ring_dma,\n\t\t\t\t    GFP_KERNEL);\n\trrpriv->evt_ring = tmpptr;\n\trrpriv->evt_ring_dma = ring_dma;\n\n\tif (!tmpptr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n#ifdef __BIG_ENDIAN\n\twritel(readl(&rrpriv->regs->HostCtrl) | NO_SWAP,\n\t\t&rrpriv->regs->HostCtrl);\n#endif\n\t \n\n\trr_init(dev);\n\n\tret = register_netdev(dev);\n\tif (ret)\n\t\tgoto out;\n\treturn 0;\n\n out:\n\tif (rrpriv->evt_ring)\n\t\tdma_free_coherent(&pdev->dev, EVT_RING_SIZE, rrpriv->evt_ring,\n\t\t\t\t  rrpriv->evt_ring_dma);\n\tif (rrpriv->rx_ring)\n\t\tdma_free_coherent(&pdev->dev, RX_TOTAL_SIZE, rrpriv->rx_ring,\n\t\t\t\t  rrpriv->rx_ring_dma);\n\tif (rrpriv->tx_ring)\n\t\tdma_free_coherent(&pdev->dev, TX_TOTAL_SIZE, rrpriv->tx_ring,\n\t\t\t\t  rrpriv->tx_ring_dma);\n\tif (rrpriv->regs)\n\t\tpci_iounmap(pdev, rrpriv->regs);\n\tif (pdev)\n\t\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n out2:\n\tfree_netdev(dev);\n out3:\n\treturn ret;\n}\n\nstatic void rr_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct rr_private *rr = netdev_priv(dev);\n\n\tif (!(readl(&rr->regs->HostCtrl) & NIC_HALTED)) {\n\t\tprintk(KERN_ERR \"%s: trying to unload running NIC\\n\",\n\t\t       dev->name);\n\t\twritel(HALT_NIC, &rr->regs->HostCtrl);\n\t}\n\n\tunregister_netdev(dev);\n\tdma_free_coherent(&pdev->dev, EVT_RING_SIZE, rr->evt_ring,\n\t\t\t  rr->evt_ring_dma);\n\tdma_free_coherent(&pdev->dev, RX_TOTAL_SIZE, rr->rx_ring,\n\t\t\t  rr->rx_ring_dma);\n\tdma_free_coherent(&pdev->dev, TX_TOTAL_SIZE, rr->tx_ring,\n\t\t\t  rr->tx_ring_dma);\n\tpci_iounmap(pdev, rr->regs);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tfree_netdev(dev);\n}\n\n\n \nstatic void rr_issue_cmd(struct rr_private *rrpriv, struct cmd *cmd)\n{\n\tstruct rr_regs __iomem *regs;\n\tu32 idx;\n\n\tregs = rrpriv->regs;\n\t \n\tif (readl(&regs->HostCtrl) & NIC_HALTED){\n\t\tprintk(\"issuing command for halted NIC, code 0x%x, \"\n\t\t       \"HostCtrl %08x\\n\", cmd->code, readl(&regs->HostCtrl));\n\t\tif (readl(&regs->Mode) & FATAL_ERR)\n\t\t\tprintk(\"error codes Fail1 %02x, Fail2 %02x\\n\",\n\t\t\t       readl(&regs->Fail1), readl(&regs->Fail2));\n\t}\n\n\tidx = rrpriv->info->cmd_ctrl.pi;\n\n\twritel(*(u32*)(cmd), &regs->CmdRing[idx]);\n\twmb();\n\n\tidx = (idx - 1) % CMD_RING_ENTRIES;\n\trrpriv->info->cmd_ctrl.pi = idx;\n\twmb();\n\n\tif (readl(&regs->Mode) & FATAL_ERR)\n\t\tprintk(\"error code %02x\\n\", readl(&regs->Fail1));\n}\n\n\n \nstatic int rr_reset(struct net_device *dev)\n{\n\tstruct rr_private *rrpriv;\n\tstruct rr_regs __iomem *regs;\n\tu32 start_pc;\n\tint i;\n\n\trrpriv = netdev_priv(dev);\n\tregs = rrpriv->regs;\n\n\trr_load_firmware(dev);\n\n\twritel(0x01000000, &regs->TX_state);\n\twritel(0xff800000, &regs->RX_state);\n\twritel(0, &regs->AssistState);\n\twritel(CLEAR_INTA, &regs->LocalCtrl);\n\twritel(0x01, &regs->BrkPt);\n\twritel(0, &regs->Timer);\n\twritel(0, &regs->TimerRef);\n\twritel(RESET_DMA, &regs->DmaReadState);\n\twritel(RESET_DMA, &regs->DmaWriteState);\n\twritel(0, &regs->DmaWriteHostHi);\n\twritel(0, &regs->DmaWriteHostLo);\n\twritel(0, &regs->DmaReadHostHi);\n\twritel(0, &regs->DmaReadHostLo);\n\twritel(0, &regs->DmaReadLen);\n\twritel(0, &regs->DmaWriteLen);\n\twritel(0, &regs->DmaWriteLcl);\n\twritel(0, &regs->DmaWriteIPchecksum);\n\twritel(0, &regs->DmaReadLcl);\n\twritel(0, &regs->DmaReadIPchecksum);\n\twritel(0, &regs->PciState);\n#if (BITS_PER_LONG == 64) && defined __LITTLE_ENDIAN\n\twritel(SWAP_DATA | PTR64BIT | PTR_WD_SWAP, &regs->Mode);\n#elif (BITS_PER_LONG == 64)\n\twritel(SWAP_DATA | PTR64BIT | PTR_WD_NOSWAP, &regs->Mode);\n#else\n\twritel(SWAP_DATA | PTR32BIT | PTR_WD_NOSWAP, &regs->Mode);\n#endif\n\n#if 0\n\t \n\twritel(0xdf000, &regs->RxBase);\n\twritel(0xdf000, &regs->RxPrd);\n\twritel(0xdf000, &regs->RxCon);\n\twritel(0xce000, &regs->TxBase);\n\twritel(0xce000, &regs->TxPrd);\n\twritel(0xce000, &regs->TxCon);\n\twritel(0, &regs->RxIndPro);\n\twritel(0, &regs->RxIndCon);\n\twritel(0, &regs->RxIndRef);\n\twritel(0, &regs->TxIndPro);\n\twritel(0, &regs->TxIndCon);\n\twritel(0, &regs->TxIndRef);\n\twritel(0xcc000, &regs->pad10[0]);\n\twritel(0, &regs->DrCmndPro);\n\twritel(0, &regs->DrCmndCon);\n\twritel(0, &regs->DwCmndPro);\n\twritel(0, &regs->DwCmndCon);\n\twritel(0, &regs->DwCmndRef);\n\twritel(0, &regs->DrDataPro);\n\twritel(0, &regs->DrDataCon);\n\twritel(0, &regs->DrDataRef);\n\twritel(0, &regs->DwDataPro);\n\twritel(0, &regs->DwDataCon);\n\twritel(0, &regs->DwDataRef);\n#endif\n\n\twritel(0xffffffff, &regs->MbEvent);\n\twritel(0, &regs->Event);\n\n\twritel(0, &regs->TxPi);\n\twritel(0, &regs->IpRxPi);\n\n\twritel(0, &regs->EvtCon);\n\twritel(0, &regs->EvtPrd);\n\n\trrpriv->info->evt_ctrl.pi = 0;\n\n\tfor (i = 0; i < CMD_RING_ENTRIES; i++)\n\t\twritel(0, &regs->CmdRing[i]);\n\n \n\twritel(RBURST_64|WBURST_64, &regs->PciState);\n\twmb();\n\n\tstart_pc = rr_read_eeprom_word(rrpriv,\n\t\t\toffsetof(struct eeprom, rncd_info.FwStart));\n\n#if (DEBUG > 1)\n\tprintk(\"%s: Executing firmware at address 0x%06x\\n\",\n\t       dev->name, start_pc);\n#endif\n\n\twritel(start_pc + 0x800, &regs->Pc);\n\twmb();\n\tudelay(5);\n\n\twritel(start_pc, &regs->Pc);\n\twmb();\n\n\treturn 0;\n}\n\n\n \nstatic unsigned int rr_read_eeprom(struct rr_private *rrpriv,\n\t\t\t\tunsigned long offset,\n\t\t\t\tunsigned char *buf,\n\t\t\t\tunsigned long length)\n{\n\tstruct rr_regs __iomem *regs = rrpriv->regs;\n\tu32 misc, io, host, i;\n\n\tio = readl(&regs->ExtIo);\n\twritel(0, &regs->ExtIo);\n\tmisc = readl(&regs->LocalCtrl);\n\twritel(0, &regs->LocalCtrl);\n\thost = readl(&regs->HostCtrl);\n\twritel(host | HALT_NIC, &regs->HostCtrl);\n\tmb();\n\n\tfor (i = 0; i < length; i++){\n\t\twritel((EEPROM_BASE + ((offset+i) << 3)), &regs->WinBase);\n\t\tmb();\n\t\tbuf[i] = (readl(&regs->WinData) >> 24) & 0xff;\n\t\tmb();\n\t}\n\n\twritel(host, &regs->HostCtrl);\n\twritel(misc, &regs->LocalCtrl);\n\twritel(io, &regs->ExtIo);\n\tmb();\n\treturn i;\n}\n\n\n \nstatic u32 rr_read_eeprom_word(struct rr_private *rrpriv,\n\t\t\t    size_t offset)\n{\n\t__be32 word;\n\n\tif ((rr_read_eeprom(rrpriv, offset,\n\t\t\t    (unsigned char *)&word, 4) == 4))\n\t\treturn be32_to_cpu(word);\n\treturn 0;\n}\n\n\n \nstatic unsigned int write_eeprom(struct rr_private *rrpriv,\n\t\t\t\t unsigned long offset,\n\t\t\t\t unsigned char *buf,\n\t\t\t\t unsigned long length)\n{\n\tstruct rr_regs __iomem *regs = rrpriv->regs;\n\tu32 misc, io, data, i, j, ready, error = 0;\n\n\tio = readl(&regs->ExtIo);\n\twritel(0, &regs->ExtIo);\n\tmisc = readl(&regs->LocalCtrl);\n\twritel(ENABLE_EEPROM_WRITE, &regs->LocalCtrl);\n\tmb();\n\n\tfor (i = 0; i < length; i++){\n\t\twritel((EEPROM_BASE + ((offset+i) << 3)), &regs->WinBase);\n\t\tmb();\n\t\tdata = buf[i] << 24;\n\t\t \n\t\tif ((readl(&regs->WinData) & 0xff000000) != data){\n\t\t\twritel(data, &regs->WinData);\n\t\t\tready = 0;\n\t\t\tj = 0;\n\t\t\tmb();\n\t\t\twhile(!ready){\n\t\t\t\tudelay(20);\n\t\t\t\tif ((readl(&regs->WinData) & 0xff000000) ==\n\t\t\t\t    data)\n\t\t\t\t\tready = 1;\n\t\t\t\tmb();\n\t\t\t\tif (j++ > 5000){\n\t\t\t\t\tprintk(\"data mismatch: %08x, \"\n\t\t\t\t\t       \"WinData %08x\\n\", data,\n\t\t\t\t\t       readl(&regs->WinData));\n\t\t\t\t\tready = 1;\n\t\t\t\t\terror = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twritel(misc, &regs->LocalCtrl);\n\twritel(io, &regs->ExtIo);\n\tmb();\n\n\treturn error;\n}\n\n\nstatic int rr_init(struct net_device *dev)\n{\n\tu8 addr[HIPPI_ALEN] __aligned(4);\n\tstruct rr_private *rrpriv;\n\tstruct rr_regs __iomem *regs;\n\tu32 sram_size, rev;\n\n\trrpriv = netdev_priv(dev);\n\tregs = rrpriv->regs;\n\n\trev = readl(&regs->FwRev);\n\trrpriv->fw_rev = rev;\n\tif (rev > 0x00020024)\n\t\tprintk(\"  Firmware revision: %i.%i.%i\\n\", (rev >> 16),\n\t\t       ((rev >> 8) & 0xff), (rev & 0xff));\n\telse if (rev >= 0x00020000) {\n\t\tprintk(\"  Firmware revision: %i.%i.%i (2.0.37 or \"\n\t\t       \"later is recommended)\\n\", (rev >> 16),\n\t\t       ((rev >> 8) & 0xff), (rev & 0xff));\n\t}else{\n\t\tprintk(\"  Firmware revision too old: %i.%i.%i, please \"\n\t\t       \"upgrade to 2.0.37 or later.\\n\",\n\t\t       (rev >> 16), ((rev >> 8) & 0xff), (rev & 0xff));\n\t}\n\n#if (DEBUG > 2)\n\tprintk(\"  Maximum receive rings %i\\n\", readl(&regs->MaxRxRng));\n#endif\n\n\t \n\n\t*(__be16 *)(addr) =\n\t  htons(rr_read_eeprom_word(rrpriv, offsetof(struct eeprom, manf.BoardULA)));\n\t*(__be32 *)(addr+2) =\n\t  htonl(rr_read_eeprom_word(rrpriv, offsetof(struct eeprom, manf.BoardULA[4])));\n\tdev_addr_set(dev, addr);\n\n\tprintk(\"  MAC: %pM\\n\", dev->dev_addr);\n\n\tsram_size = rr_read_eeprom_word(rrpriv, 8);\n\tprintk(\"  SRAM size 0x%06x\\n\", sram_size);\n\n\treturn 0;\n}\n\n\nstatic int rr_init1(struct net_device *dev)\n{\n\tstruct rr_private *rrpriv;\n\tstruct rr_regs __iomem *regs;\n\tunsigned long myjif, flags;\n\tstruct cmd cmd;\n\tu32 hostctrl;\n\tint ecode = 0;\n\tshort i;\n\n\trrpriv = netdev_priv(dev);\n\tregs = rrpriv->regs;\n\n\tspin_lock_irqsave(&rrpriv->lock, flags);\n\n\thostctrl = readl(&regs->HostCtrl);\n\twritel(hostctrl | HALT_NIC | RR_CLEAR_INT, &regs->HostCtrl);\n\twmb();\n\n\tif (hostctrl & PARITY_ERR){\n\t\tprintk(\"%s: Parity error halting NIC - this is serious!\\n\",\n\t\t       dev->name);\n\t\tspin_unlock_irqrestore(&rrpriv->lock, flags);\n\t\tecode = -EFAULT;\n\t\tgoto error;\n\t}\n\n\tset_rxaddr(regs, rrpriv->rx_ctrl_dma);\n\tset_infoaddr(regs, rrpriv->info_dma);\n\n\trrpriv->info->evt_ctrl.entry_size = sizeof(struct event);\n\trrpriv->info->evt_ctrl.entries = EVT_RING_ENTRIES;\n\trrpriv->info->evt_ctrl.mode = 0;\n\trrpriv->info->evt_ctrl.pi = 0;\n\tset_rraddr(&rrpriv->info->evt_ctrl.rngptr, rrpriv->evt_ring_dma);\n\n\trrpriv->info->cmd_ctrl.entry_size = sizeof(struct cmd);\n\trrpriv->info->cmd_ctrl.entries = CMD_RING_ENTRIES;\n\trrpriv->info->cmd_ctrl.mode = 0;\n\trrpriv->info->cmd_ctrl.pi = 15;\n\n\tfor (i = 0; i < CMD_RING_ENTRIES; i++) {\n\t\twritel(0, &regs->CmdRing[i]);\n\t}\n\n\tfor (i = 0; i < TX_RING_ENTRIES; i++) {\n\t\trrpriv->tx_ring[i].size = 0;\n\t\tset_rraddr(&rrpriv->tx_ring[i].addr, 0);\n\t\trrpriv->tx_skbuff[i] = NULL;\n\t}\n\trrpriv->info->tx_ctrl.entry_size = sizeof(struct tx_desc);\n\trrpriv->info->tx_ctrl.entries = TX_RING_ENTRIES;\n\trrpriv->info->tx_ctrl.mode = 0;\n\trrpriv->info->tx_ctrl.pi = 0;\n\tset_rraddr(&rrpriv->info->tx_ctrl.rngptr, rrpriv->tx_ring_dma);\n\n\t \n\trrpriv->tx_full = 0;\n\trrpriv->cur_rx = 0;\n\trrpriv->dirty_rx = rrpriv->dirty_tx = 0;\n\n\trr_reset(dev);\n\n\t \n\twritel(0x5000, &regs->ConRetry);\n\twritel(0x100, &regs->ConRetryTmr);\n\twritel(0x500000, &regs->ConTmout);\n \twritel(0x60, &regs->IntrTmr);\n\twritel(0x500000, &regs->TxDataMvTimeout);\n\twritel(0x200000, &regs->RxDataMvTimeout);\n \twritel(0x80, &regs->WriteDmaThresh);\n \twritel(0x80, &regs->ReadDmaThresh);\n\n\trrpriv->fw_running = 0;\n\twmb();\n\n\thostctrl &= ~(HALT_NIC | INVALID_INST_B | PARITY_ERR);\n\twritel(hostctrl, &regs->HostCtrl);\n\twmb();\n\n\tspin_unlock_irqrestore(&rrpriv->lock, flags);\n\n\tfor (i = 0; i < RX_RING_ENTRIES; i++) {\n\t\tstruct sk_buff *skb;\n\t\tdma_addr_t addr;\n\n\t\trrpriv->rx_ring[i].mode = 0;\n\t\tskb = alloc_skb(dev->mtu + HIPPI_HLEN, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tprintk(KERN_WARNING \"%s: Unable to allocate memory \"\n\t\t\t       \"for receive ring - halting NIC\\n\", dev->name);\n\t\t\tecode = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\trrpriv->rx_skbuff[i] = skb;\n\t\taddr = dma_map_single(&rrpriv->pci_dev->dev, skb->data,\n\t\t\t\t      dev->mtu + HIPPI_HLEN, DMA_FROM_DEVICE);\n\t\t \n\t\tif ((((unsigned long)skb->data) & 0xfff) > ~65320)\n\t\t\tprintk(\"skb alloc error\\n\");\n\n\t\tset_rraddr(&rrpriv->rx_ring[i].addr, addr);\n\t\trrpriv->rx_ring[i].size = dev->mtu + HIPPI_HLEN;\n\t}\n\n\trrpriv->rx_ctrl[4].entry_size = sizeof(struct rx_desc);\n\trrpriv->rx_ctrl[4].entries = RX_RING_ENTRIES;\n\trrpriv->rx_ctrl[4].mode = 8;\n\trrpriv->rx_ctrl[4].pi = 0;\n\twmb();\n\tset_rraddr(&rrpriv->rx_ctrl[4].rngptr, rrpriv->rx_ring_dma);\n\n\tudelay(1000);\n\n\t \n\tcmd.code = C_START_FW;\n\tcmd.ring = 0;\n\tcmd.index = 0;\n\n\trr_issue_cmd(rrpriv, &cmd);\n\n\t \n\tmyjif = jiffies + 5 * HZ;\n\twhile (time_before(jiffies, myjif) && !rrpriv->fw_running)\n\t\tcpu_relax();\n\n\tnetif_start_queue(dev);\n\n\treturn ecode;\n\n error:\n\t \n\tfor (i = 0; i < RX_RING_ENTRIES; i++) {\n\t\tstruct sk_buff *skb = rrpriv->rx_skbuff[i];\n\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&rrpriv->pci_dev->dev,\n\t\t\t\t\t rrpriv->rx_ring[i].addr.addrlo,\n\t\t\t\t\t dev->mtu + HIPPI_HLEN,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\trrpriv->rx_ring[i].size = 0;\n\t\t\tset_rraddr(&rrpriv->rx_ring[i].addr, 0);\n\t\t\tdev_kfree_skb(skb);\n\t\t\trrpriv->rx_skbuff[i] = NULL;\n\t\t}\n\t}\n\treturn ecode;\n}\n\n\n \nstatic u32 rr_handle_event(struct net_device *dev, u32 prodidx, u32 eidx)\n{\n\tstruct rr_private *rrpriv;\n\tstruct rr_regs __iomem *regs;\n\tu32 tmp;\n\n\trrpriv = netdev_priv(dev);\n\tregs = rrpriv->regs;\n\n\twhile (prodidx != eidx){\n\t\tswitch (rrpriv->evt_ring[eidx].code){\n\t\tcase E_NIC_UP:\n\t\t\ttmp = readl(&regs->FwRev);\n\t\t\tprintk(KERN_INFO \"%s: Firmware revision %i.%i.%i \"\n\t\t\t       \"up and running\\n\", dev->name,\n\t\t\t       (tmp >> 16), ((tmp >> 8) & 0xff), (tmp & 0xff));\n\t\t\trrpriv->fw_running = 1;\n\t\t\twritel(RX_RING_ENTRIES - 1, &regs->IpRxPi);\n\t\t\twmb();\n\t\t\tbreak;\n\t\tcase E_LINK_ON:\n\t\t\tprintk(KERN_INFO \"%s: Optical link ON\\n\", dev->name);\n\t\t\tbreak;\n\t\tcase E_LINK_OFF:\n\t\t\tprintk(KERN_INFO \"%s: Optical link OFF\\n\", dev->name);\n\t\t\tbreak;\n\t\tcase E_RX_IDLE:\n\t\t\tprintk(KERN_WARNING \"%s: RX data not moving\\n\",\n\t\t\t       dev->name);\n\t\t\tgoto drop;\n\t\tcase E_WATCHDOG:\n\t\t\tprintk(KERN_INFO \"%s: The watchdog is here to see \"\n\t\t\t       \"us\\n\", dev->name);\n\t\t\tbreak;\n\t\tcase E_INTERN_ERR:\n\t\t\tprintk(KERN_ERR \"%s: HIPPI Internal NIC error\\n\",\n\t\t\t       dev->name);\n\t\t\twritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\n\t\t\t       &regs->HostCtrl);\n\t\t\twmb();\n\t\t\tbreak;\n\t\tcase E_HOST_ERR:\n\t\t\tprintk(KERN_ERR \"%s: Host software error\\n\",\n\t\t\t       dev->name);\n\t\t\twritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\n\t\t\t       &regs->HostCtrl);\n\t\t\twmb();\n\t\t\tbreak;\n\t\t \n\t\tcase E_CON_REJ:\n\t\t\tprintk(KERN_WARNING \"%s: Connection rejected\\n\",\n\t\t\t       dev->name);\n\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\tbreak;\n\t\tcase E_CON_TMOUT:\n\t\t\tprintk(KERN_WARNING \"%s: Connection timeout\\n\",\n\t\t\t       dev->name);\n\t\t\tbreak;\n\t\tcase E_DISC_ERR:\n\t\t\tprintk(KERN_WARNING \"%s: HIPPI disconnect error\\n\",\n\t\t\t       dev->name);\n\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\tbreak;\n\t\tcase E_INT_PRTY:\n\t\t\tprintk(KERN_ERR \"%s: HIPPI Internal Parity error\\n\",\n\t\t\t       dev->name);\n\t\t\twritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\n\t\t\t       &regs->HostCtrl);\n\t\t\twmb();\n\t\t\tbreak;\n\t\tcase E_TX_IDLE:\n\t\t\tprintk(KERN_WARNING \"%s: Transmitter idle\\n\",\n\t\t\t       dev->name);\n\t\t\tbreak;\n\t\tcase E_TX_LINK_DROP:\n\t\t\tprintk(KERN_WARNING \"%s: Link lost during transmit\\n\",\n\t\t\t       dev->name);\n\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\twritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\n\t\t\t       &regs->HostCtrl);\n\t\t\twmb();\n\t\t\tbreak;\n\t\tcase E_TX_INV_RNG:\n\t\t\tprintk(KERN_ERR \"%s: Invalid send ring block\\n\",\n\t\t\t       dev->name);\n\t\t\twritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\n\t\t\t       &regs->HostCtrl);\n\t\t\twmb();\n\t\t\tbreak;\n\t\tcase E_TX_INV_BUF:\n\t\t\tprintk(KERN_ERR \"%s: Invalid send buffer address\\n\",\n\t\t\t       dev->name);\n\t\t\twritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\n\t\t\t       &regs->HostCtrl);\n\t\t\twmb();\n\t\t\tbreak;\n\t\tcase E_TX_INV_DSC:\n\t\t\tprintk(KERN_ERR \"%s: Invalid descriptor address\\n\",\n\t\t\t       dev->name);\n\t\t\twritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\n\t\t\t       &regs->HostCtrl);\n\t\t\twmb();\n\t\t\tbreak;\n\t\t \n\t\tcase E_RX_RNG_OUT:\n\t\t\tprintk(KERN_INFO \"%s: Receive ring full\\n\", dev->name);\n\t\t\tbreak;\n\n\t\tcase E_RX_PAR_ERR:\n\t\t\tprintk(KERN_WARNING \"%s: Receive parity error\\n\",\n\t\t\t       dev->name);\n\t\t\tgoto drop;\n\t\tcase E_RX_LLRC_ERR:\n\t\t\tprintk(KERN_WARNING \"%s: Receive LLRC error\\n\",\n\t\t\t       dev->name);\n\t\t\tgoto drop;\n\t\tcase E_PKT_LN_ERR:\n\t\t\tprintk(KERN_WARNING \"%s: Receive packet length \"\n\t\t\t       \"error\\n\", dev->name);\n\t\t\tgoto drop;\n\t\tcase E_DTA_CKSM_ERR:\n\t\t\tprintk(KERN_WARNING \"%s: Data checksum error\\n\",\n\t\t\t       dev->name);\n\t\t\tgoto drop;\n\t\tcase E_SHT_BST:\n\t\t\tprintk(KERN_WARNING \"%s: Unexpected short burst \"\n\t\t\t       \"error\\n\", dev->name);\n\t\t\tgoto drop;\n\t\tcase E_STATE_ERR:\n\t\t\tprintk(KERN_WARNING \"%s: Recv. state transition\"\n\t\t\t       \" error\\n\", dev->name);\n\t\t\tgoto drop;\n\t\tcase E_UNEXP_DATA:\n\t\t\tprintk(KERN_WARNING \"%s: Unexpected data error\\n\",\n\t\t\t       dev->name);\n\t\t\tgoto drop;\n\t\tcase E_LST_LNK_ERR:\n\t\t\tprintk(KERN_WARNING \"%s: Link lost error\\n\",\n\t\t\t       dev->name);\n\t\t\tgoto drop;\n\t\tcase E_FRM_ERR:\n\t\t\tprintk(KERN_WARNING \"%s: Framing Error\\n\",\n\t\t\t       dev->name);\n\t\t\tgoto drop;\n\t\tcase E_FLG_SYN_ERR:\n\t\t\tprintk(KERN_WARNING \"%s: Flag sync. lost during \"\n\t\t\t       \"packet\\n\", dev->name);\n\t\t\tgoto drop;\n\t\tcase E_RX_INV_BUF:\n\t\t\tprintk(KERN_ERR \"%s: Invalid receive buffer \"\n\t\t\t       \"address\\n\", dev->name);\n\t\t\twritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\n\t\t\t       &regs->HostCtrl);\n\t\t\twmb();\n\t\t\tbreak;\n\t\tcase E_RX_INV_DSC:\n\t\t\tprintk(KERN_ERR \"%s: Invalid receive descriptor \"\n\t\t\t       \"address\\n\", dev->name);\n\t\t\twritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\n\t\t\t       &regs->HostCtrl);\n\t\t\twmb();\n\t\t\tbreak;\n\t\tcase E_RNG_BLK:\n\t\t\tprintk(KERN_ERR \"%s: Invalid ring block\\n\",\n\t\t\t       dev->name);\n\t\t\twritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\n\t\t\t       &regs->HostCtrl);\n\t\t\twmb();\n\t\t\tbreak;\n\t\tdrop:\n\t\t\t \n\t\t\t{\n\t\t\t\tu16 index = rrpriv->evt_ring[eidx].index;\n\t\t\t\tindex = (index + (RX_RING_ENTRIES - 1)) %\n\t\t\t\t\tRX_RING_ENTRIES;\n\t\t\t\trrpriv->rx_ring[index].mode |=\n\t\t\t\t\t(PACKET_BAD | PACKET_END);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING \"%s: Unhandled event 0x%02x\\n\",\n\t\t\t       dev->name, rrpriv->evt_ring[eidx].code);\n\t\t}\n\t\teidx = (eidx + 1) % EVT_RING_ENTRIES;\n\t}\n\n\trrpriv->info->evt_ctrl.pi = eidx;\n\twmb();\n\treturn eidx;\n}\n\n\nstatic void rx_int(struct net_device *dev, u32 rxlimit, u32 index)\n{\n\tstruct rr_private *rrpriv = netdev_priv(dev);\n\tstruct rr_regs __iomem *regs = rrpriv->regs;\n\n\tdo {\n\t\tstruct rx_desc *desc;\n\t\tu32 pkt_len;\n\n\t\tdesc = &(rrpriv->rx_ring[index]);\n\t\tpkt_len = desc->size;\n#if (DEBUG > 2)\n\t\tprintk(\"index %i, rxlimit %i\\n\", index, rxlimit);\n\t\tprintk(\"len %x, mode %x\\n\", pkt_len, desc->mode);\n#endif\n\t\tif ( (rrpriv->rx_ring[index].mode & PACKET_BAD) == PACKET_BAD){\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tgoto defer;\n\t\t}\n\n\t\tif (pkt_len > 0){\n\t\t\tstruct sk_buff *skb, *rx_skb;\n\n\t\t\trx_skb = rrpriv->rx_skbuff[index];\n\n\t\t\tif (pkt_len < PKT_COPY_THRESHOLD) {\n\t\t\t\tskb = alloc_skb(pkt_len, GFP_ATOMIC);\n\t\t\t\tif (skb == NULL){\n\t\t\t\t\tprintk(KERN_WARNING \"%s: Unable to allocate skb (%i bytes), deferring packet\\n\", dev->name, pkt_len);\n\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t\tgoto defer;\n\t\t\t\t} else {\n\t\t\t\t\tdma_sync_single_for_cpu(&rrpriv->pci_dev->dev,\n\t\t\t\t\t\t\t\tdesc->addr.addrlo,\n\t\t\t\t\t\t\t\tpkt_len,\n\t\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t\t\t\tskb_put_data(skb, rx_skb->data,\n\t\t\t\t\t\t     pkt_len);\n\n\t\t\t\t\tdma_sync_single_for_device(&rrpriv->pci_dev->dev,\n\t\t\t\t\t\t\t\t   desc->addr.addrlo,\n\t\t\t\t\t\t\t\t   pkt_len,\n\t\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tstruct sk_buff *newskb;\n\n\t\t\t\tnewskb = alloc_skb(dev->mtu + HIPPI_HLEN,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (newskb){\n\t\t\t\t\tdma_addr_t addr;\n\n\t\t\t\t\tdma_unmap_single(&rrpriv->pci_dev->dev,\n\t\t\t\t\t\t\t desc->addr.addrlo,\n\t\t\t\t\t\t\t dev->mtu + HIPPI_HLEN,\n\t\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\t\tskb = rx_skb;\n\t\t\t\t\tskb_put(skb, pkt_len);\n\t\t\t\t\trrpriv->rx_skbuff[index] = newskb;\n\t\t\t\t\taddr = dma_map_single(&rrpriv->pci_dev->dev,\n\t\t\t\t\t\t\t      newskb->data,\n\t\t\t\t\t\t\t      dev->mtu + HIPPI_HLEN,\n\t\t\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\t\t\t\tset_rraddr(&desc->addr, addr);\n\t\t\t\t} else {\n\t\t\t\t\tprintk(\"%s: Out of memory, deferring \"\n\t\t\t\t\t       \"packet\\n\", dev->name);\n\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t\tgoto defer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tskb->protocol = hippi_type_trans(skb, dev);\n\n\t\t\tnetif_rx(skb);\t\t \n\n\t\t\tdev->stats.rx_packets++;\n\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t}\n\tdefer:\n\t\tdesc->mode = 0;\n\t\tdesc->size = dev->mtu + HIPPI_HLEN;\n\n\t\tif ((index & 7) == 7)\n\t\t\twritel(index, &regs->IpRxPi);\n\n\t\tindex = (index + 1) % RX_RING_ENTRIES;\n\t} while(index != rxlimit);\n\n\trrpriv->cur_rx = index;\n\twmb();\n}\n\n\nstatic irqreturn_t rr_interrupt(int irq, void *dev_id)\n{\n\tstruct rr_private *rrpriv;\n\tstruct rr_regs __iomem *regs;\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tu32 prodidx, rxindex, eidx, txcsmr, rxlimit, txcon;\n\n\trrpriv = netdev_priv(dev);\n\tregs = rrpriv->regs;\n\n\tif (!(readl(&regs->HostCtrl) & RR_INT))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&rrpriv->lock);\n\n\tprodidx = readl(&regs->EvtPrd);\n\ttxcsmr = (prodidx >> 8) & 0xff;\n\trxlimit = (prodidx >> 16) & 0xff;\n\tprodidx &= 0xff;\n\n#if (DEBUG > 2)\n\tprintk(\"%s: interrupt, prodidx = %i, eidx = %i\\n\", dev->name,\n\t       prodidx, rrpriv->info->evt_ctrl.pi);\n#endif\n\t \n\n\teidx = rrpriv->info->evt_ctrl.pi;\n\tif (prodidx != eidx)\n\t\teidx = rr_handle_event(dev, prodidx, eidx);\n\n\trxindex = rrpriv->cur_rx;\n\tif (rxindex != rxlimit)\n\t\trx_int(dev, rxlimit, rxindex);\n\n\ttxcon = rrpriv->dirty_tx;\n\tif (txcsmr != txcon) {\n\t\tdo {\n\t\t\t \n\t\t\tif(rrpriv->tx_skbuff[txcon]){\n\t\t\t\tstruct tx_desc *desc;\n\t\t\t\tstruct sk_buff *skb;\n\n\t\t\t\tdesc = &(rrpriv->tx_ring[txcon]);\n\t\t\t\tskb = rrpriv->tx_skbuff[txcon];\n\n\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\tdev->stats.tx_bytes += skb->len;\n\n\t\t\t\tdma_unmap_single(&rrpriv->pci_dev->dev,\n\t\t\t\t\t\t desc->addr.addrlo, skb->len,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tdev_kfree_skb_irq(skb);\n\n\t\t\t\trrpriv->tx_skbuff[txcon] = NULL;\n\t\t\t\tdesc->size = 0;\n\t\t\t\tset_rraddr(&rrpriv->tx_ring[txcon].addr, 0);\n\t\t\t\tdesc->mode = 0;\n\t\t\t}\n\t\t\ttxcon = (txcon + 1) % TX_RING_ENTRIES;\n\t\t} while (txcsmr != txcon);\n\t\twmb();\n\n\t\trrpriv->dirty_tx = txcon;\n\t\tif (rrpriv->tx_full && rr_if_busy(dev) &&\n\t\t    (((rrpriv->info->tx_ctrl.pi + 1) % TX_RING_ENTRIES)\n\t\t     != rrpriv->dirty_tx)){\n\t\t\trrpriv->tx_full = 0;\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t}\n\n\teidx |= ((txcsmr << 8) | (rxlimit << 16));\n\twritel(eidx, &regs->EvtCon);\n\twmb();\n\n\tspin_unlock(&rrpriv->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic inline void rr_raz_tx(struct rr_private *rrpriv,\n\t\t\t     struct net_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < TX_RING_ENTRIES; i++) {\n\t\tstruct sk_buff *skb = rrpriv->tx_skbuff[i];\n\n\t\tif (skb) {\n\t\t\tstruct tx_desc *desc = &(rrpriv->tx_ring[i]);\n\n\t\t\tdma_unmap_single(&rrpriv->pci_dev->dev,\n\t\t\t\t\t desc->addr.addrlo, skb->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdesc->size = 0;\n\t\t\tset_rraddr(&desc->addr, 0);\n\t\t\tdev_kfree_skb(skb);\n\t\t\trrpriv->tx_skbuff[i] = NULL;\n\t\t}\n\t}\n}\n\n\nstatic inline void rr_raz_rx(struct rr_private *rrpriv,\n\t\t\t     struct net_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < RX_RING_ENTRIES; i++) {\n\t\tstruct sk_buff *skb = rrpriv->rx_skbuff[i];\n\n\t\tif (skb) {\n\t\t\tstruct rx_desc *desc = &(rrpriv->rx_ring[i]);\n\n\t\t\tdma_unmap_single(&rrpriv->pci_dev->dev,\n\t\t\t\t\t desc->addr.addrlo,\n\t\t\t\t\t dev->mtu + HIPPI_HLEN,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdesc->size = 0;\n\t\t\tset_rraddr(&desc->addr, 0);\n\t\t\tdev_kfree_skb(skb);\n\t\t\trrpriv->rx_skbuff[i] = NULL;\n\t\t}\n\t}\n}\n\nstatic void rr_timer(struct timer_list *t)\n{\n\tstruct rr_private *rrpriv = from_timer(rrpriv, t, timer);\n\tstruct net_device *dev = pci_get_drvdata(rrpriv->pci_dev);\n\tstruct rr_regs __iomem *regs = rrpriv->regs;\n\tunsigned long flags;\n\n\tif (readl(&regs->HostCtrl) & NIC_HALTED){\n\t\tprintk(\"%s: Restarting nic\\n\", dev->name);\n\t\tmemset(rrpriv->rx_ctrl, 0, 256 * sizeof(struct ring_ctrl));\n\t\tmemset(rrpriv->info, 0, sizeof(struct rr_info));\n\t\twmb();\n\n\t\trr_raz_tx(rrpriv, dev);\n\t\trr_raz_rx(rrpriv, dev);\n\n\t\tif (rr_init1(dev)) {\n\t\t\tspin_lock_irqsave(&rrpriv->lock, flags);\n\t\t\twritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT,\n\t\t\t       &regs->HostCtrl);\n\t\t\tspin_unlock_irqrestore(&rrpriv->lock, flags);\n\t\t}\n\t}\n\trrpriv->timer.expires = RUN_AT(5*HZ);\n\tadd_timer(&rrpriv->timer);\n}\n\n\nstatic int rr_open(struct net_device *dev)\n{\n\tstruct rr_private *rrpriv = netdev_priv(dev);\n\tstruct pci_dev *pdev = rrpriv->pci_dev;\n\tstruct rr_regs __iomem *regs;\n\tint ecode = 0;\n\tunsigned long flags;\n\tdma_addr_t dma_addr;\n\n\tregs = rrpriv->regs;\n\n\tif (rrpriv->fw_rev < 0x00020000) {\n\t\tprintk(KERN_WARNING \"%s: trying to configure device with \"\n\t\t       \"obsolete firmware\\n\", dev->name);\n\t\tecode = -EBUSY;\n\t\tgoto error;\n\t}\n\n\trrpriv->rx_ctrl = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t     256 * sizeof(struct ring_ctrl),\n\t\t\t\t\t     &dma_addr, GFP_KERNEL);\n\tif (!rrpriv->rx_ctrl) {\n\t\tecode = -ENOMEM;\n\t\tgoto error;\n\t}\n\trrpriv->rx_ctrl_dma = dma_addr;\n\n\trrpriv->info = dma_alloc_coherent(&pdev->dev, sizeof(struct rr_info),\n\t\t\t\t\t  &dma_addr, GFP_KERNEL);\n\tif (!rrpriv->info) {\n\t\tecode = -ENOMEM;\n\t\tgoto error;\n\t}\n\trrpriv->info_dma = dma_addr;\n\twmb();\n\n\tspin_lock_irqsave(&rrpriv->lock, flags);\n\twritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT, &regs->HostCtrl);\n\treadl(&regs->HostCtrl);\n\tspin_unlock_irqrestore(&rrpriv->lock, flags);\n\n\tif (request_irq(pdev->irq, rr_interrupt, IRQF_SHARED, dev->name, dev)) {\n\t\tprintk(KERN_WARNING \"%s: Requested IRQ %d is busy\\n\",\n\t\t       dev->name, pdev->irq);\n\t\tecode = -EAGAIN;\n\t\tgoto error;\n\t}\n\n\tif ((ecode = rr_init1(dev)))\n\t\tgoto error;\n\n\t \n\ttimer_setup(&rrpriv->timer, rr_timer, 0);\n\trrpriv->timer.expires = RUN_AT(5*HZ);            \n\tadd_timer(&rrpriv->timer);\n\n\tnetif_start_queue(dev);\n\n\treturn ecode;\n\n error:\n\tspin_lock_irqsave(&rrpriv->lock, flags);\n\twritel(readl(&regs->HostCtrl)|HALT_NIC|RR_CLEAR_INT, &regs->HostCtrl);\n\tspin_unlock_irqrestore(&rrpriv->lock, flags);\n\n\tif (rrpriv->info) {\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct rr_info),\n\t\t\t\t  rrpriv->info, rrpriv->info_dma);\n\t\trrpriv->info = NULL;\n\t}\n\tif (rrpriv->rx_ctrl) {\n\t\tdma_free_coherent(&pdev->dev, 256 * sizeof(struct ring_ctrl),\n\t\t\t\t  rrpriv->rx_ctrl, rrpriv->rx_ctrl_dma);\n\t\trrpriv->rx_ctrl = NULL;\n\t}\n\n\tnetif_stop_queue(dev);\n\n\treturn ecode;\n}\n\n\nstatic void rr_dump(struct net_device *dev)\n{\n\tstruct rr_private *rrpriv;\n\tstruct rr_regs __iomem *regs;\n\tu32 index, cons;\n\tshort i;\n\tint len;\n\n\trrpriv = netdev_priv(dev);\n\tregs = rrpriv->regs;\n\n\tprintk(\"%s: dumping NIC TX rings\\n\", dev->name);\n\n\tprintk(\"RxPrd %08x, TxPrd %02x, EvtPrd %08x, TxPi %02x, TxCtrlPi %02x\\n\",\n\t       readl(&regs->RxPrd), readl(&regs->TxPrd),\n\t       readl(&regs->EvtPrd), readl(&regs->TxPi),\n\t       rrpriv->info->tx_ctrl.pi);\n\n\tprintk(\"Error code 0x%x\\n\", readl(&regs->Fail1));\n\n\tindex = (((readl(&regs->EvtPrd) >> 8) & 0xff) - 1) % TX_RING_ENTRIES;\n\tcons = rrpriv->dirty_tx;\n\tprintk(\"TX ring index %i, TX consumer %i\\n\",\n\t       index, cons);\n\n\tif (rrpriv->tx_skbuff[index]){\n\t\tlen = min_t(int, 0x80, rrpriv->tx_skbuff[index]->len);\n\t\tprintk(\"skbuff for index %i is valid - dumping data (0x%x bytes - DMA len 0x%x)\\n\", index, len, rrpriv->tx_ring[index].size);\n\t\tfor (i = 0; i < len; i++){\n\t\t\tif (!(i & 7))\n\t\t\t\tprintk(\"\\n\");\n\t\t\tprintk(\"%02x \", (unsigned char) rrpriv->tx_skbuff[index]->data[i]);\n\t\t}\n\t\tprintk(\"\\n\");\n\t}\n\n\tif (rrpriv->tx_skbuff[cons]){\n\t\tlen = min_t(int, 0x80, rrpriv->tx_skbuff[cons]->len);\n\t\tprintk(\"skbuff for cons %i is valid - dumping data (0x%x bytes - skbuff len 0x%x)\\n\", cons, len, rrpriv->tx_skbuff[cons]->len);\n\t\tprintk(\"mode 0x%x, size 0x%x,\\n phys %08Lx, skbuff-addr %p, truesize 0x%x\\n\",\n\t\t       rrpriv->tx_ring[cons].mode,\n\t\t       rrpriv->tx_ring[cons].size,\n\t\t       (unsigned long long) rrpriv->tx_ring[cons].addr.addrlo,\n\t\t       rrpriv->tx_skbuff[cons]->data,\n\t\t       (unsigned int)rrpriv->tx_skbuff[cons]->truesize);\n\t\tfor (i = 0; i < len; i++){\n\t\t\tif (!(i & 7))\n\t\t\t\tprintk(\"\\n\");\n\t\t\tprintk(\"%02x \", (unsigned char)rrpriv->tx_ring[cons].size);\n\t\t}\n\t\tprintk(\"\\n\");\n\t}\n\n\tprintk(\"dumping TX ring info:\\n\");\n\tfor (i = 0; i < TX_RING_ENTRIES; i++)\n\t\tprintk(\"mode 0x%x, size 0x%x, phys-addr %08Lx\\n\",\n\t\t       rrpriv->tx_ring[i].mode,\n\t\t       rrpriv->tx_ring[i].size,\n\t\t       (unsigned long long) rrpriv->tx_ring[i].addr.addrlo);\n\n}\n\n\nstatic int rr_close(struct net_device *dev)\n{\n\tstruct rr_private *rrpriv = netdev_priv(dev);\n\tstruct rr_regs __iomem *regs = rrpriv->regs;\n\tstruct pci_dev *pdev = rrpriv->pci_dev;\n\tunsigned long flags;\n\tu32 tmp;\n\tshort i;\n\n\tnetif_stop_queue(dev);\n\n\n\t \n\tspin_lock_irqsave(&rrpriv->lock, flags);\n\n\ttmp = readl(&regs->HostCtrl);\n\tif (tmp & NIC_HALTED){\n\t\tprintk(\"%s: NIC already halted\\n\", dev->name);\n\t\trr_dump(dev);\n\t}else{\n\t\ttmp |= HALT_NIC | RR_CLEAR_INT;\n\t\twritel(tmp, &regs->HostCtrl);\n\t\treadl(&regs->HostCtrl);\n\t}\n\n\trrpriv->fw_running = 0;\n\n\tspin_unlock_irqrestore(&rrpriv->lock, flags);\n\tdel_timer_sync(&rrpriv->timer);\n\tspin_lock_irqsave(&rrpriv->lock, flags);\n\n\twritel(0, &regs->TxPi);\n\twritel(0, &regs->IpRxPi);\n\n\twritel(0, &regs->EvtCon);\n\twritel(0, &regs->EvtPrd);\n\n\tfor (i = 0; i < CMD_RING_ENTRIES; i++)\n\t\twritel(0, &regs->CmdRing[i]);\n\n\trrpriv->info->tx_ctrl.entries = 0;\n\trrpriv->info->cmd_ctrl.pi = 0;\n\trrpriv->info->evt_ctrl.pi = 0;\n\trrpriv->rx_ctrl[4].entries = 0;\n\n\trr_raz_tx(rrpriv, dev);\n\trr_raz_rx(rrpriv, dev);\n\n\tdma_free_coherent(&pdev->dev, 256 * sizeof(struct ring_ctrl),\n\t\t\t  rrpriv->rx_ctrl, rrpriv->rx_ctrl_dma);\n\trrpriv->rx_ctrl = NULL;\n\n\tdma_free_coherent(&pdev->dev, sizeof(struct rr_info), rrpriv->info,\n\t\t\t  rrpriv->info_dma);\n\trrpriv->info = NULL;\n\n\tspin_unlock_irqrestore(&rrpriv->lock, flags);\n\tfree_irq(pdev->irq, dev);\n\n\treturn 0;\n}\n\n\nstatic netdev_tx_t rr_start_xmit(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct rr_private *rrpriv = netdev_priv(dev);\n\tstruct rr_regs __iomem *regs = rrpriv->regs;\n\tstruct hippi_cb *hcb = (struct hippi_cb *) skb->cb;\n\tstruct ring_ctrl *txctrl;\n\tunsigned long flags;\n\tu32 index, len = skb->len;\n\tu32 *ifield;\n\tstruct sk_buff *new_skb;\n\n\tif (readl(&regs->Mode) & FATAL_ERR)\n\t\tprintk(\"error codes Fail1 %02x, Fail2 %02x\\n\",\n\t\t       readl(&regs->Fail1), readl(&regs->Fail2));\n\n\t \n\n\tif (skb_headroom(skb) < 8){\n\t\tprintk(\"incoming skb too small - reallocating\\n\");\n\t\tif (!(new_skb = dev_alloc_skb(len + 8))) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tnetif_wake_queue(dev);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tskb_reserve(new_skb, 8);\n\t\tskb_put(new_skb, len);\n\t\tskb_copy_from_linear_data(skb, new_skb->data, len);\n\t\tdev_kfree_skb(skb);\n\t\tskb = new_skb;\n\t}\n\n\tifield = skb_push(skb, 8);\n\n\tifield[0] = 0;\n\tifield[1] = hcb->ifield;\n\n\t \n\tspin_lock_irqsave(&rrpriv->lock, flags);\n\n\ttxctrl = &rrpriv->info->tx_ctrl;\n\n\tindex = txctrl->pi;\n\n\trrpriv->tx_skbuff[index] = skb;\n\tset_rraddr(&rrpriv->tx_ring[index].addr,\n\t\t   dma_map_single(&rrpriv->pci_dev->dev, skb->data, len + 8, DMA_TO_DEVICE));\n\trrpriv->tx_ring[index].size = len + 8;  \n\trrpriv->tx_ring[index].mode = PACKET_START | PACKET_END;\n\ttxctrl->pi = (index + 1) % TX_RING_ENTRIES;\n\twmb();\n\twritel(txctrl->pi, &regs->TxPi);\n\n\tif (txctrl->pi == rrpriv->dirty_tx){\n\t\trrpriv->tx_full = 1;\n\t\tnetif_stop_queue(dev);\n\t}\n\n\tspin_unlock_irqrestore(&rrpriv->lock, flags);\n\n\treturn NETDEV_TX_OK;\n}\n\n\n \nstatic int rr_load_firmware(struct net_device *dev)\n{\n\tstruct rr_private *rrpriv;\n\tstruct rr_regs __iomem *regs;\n\tsize_t eptr, segptr;\n\tint i, j;\n\tu32 localctrl, sptr, len, tmp;\n\tu32 p2len, p2size, nr_seg, revision, io, sram_size;\n\n\trrpriv = netdev_priv(dev);\n\tregs = rrpriv->regs;\n\n\tif (dev->flags & IFF_UP)\n\t\treturn -EBUSY;\n\n\tif (!(readl(&regs->HostCtrl) & NIC_HALTED)){\n\t\tprintk(\"%s: Trying to load firmware to a running NIC.\\n\",\n\t\t       dev->name);\n\t\treturn -EBUSY;\n\t}\n\n\tlocalctrl = readl(&regs->LocalCtrl);\n\twritel(0, &regs->LocalCtrl);\n\n\twritel(0, &regs->EvtPrd);\n\twritel(0, &regs->RxPrd);\n\twritel(0, &regs->TxPrd);\n\n\t \n\tio = readl(&regs->ExtIo);\n\twritel(0, &regs->ExtIo);\n\tsram_size = rr_read_eeprom_word(rrpriv, 8);\n\n\tfor (i = 200; i < sram_size / 4; i++){\n\t\twritel(i * 4, &regs->WinBase);\n\t\tmb();\n\t\twritel(0, &regs->WinData);\n\t\tmb();\n\t}\n\twritel(io, &regs->ExtIo);\n\tmb();\n\n\teptr = rr_read_eeprom_word(rrpriv,\n\t\t       offsetof(struct eeprom, rncd_info.AddrRunCodeSegs));\n\teptr = ((eptr & 0x1fffff) >> 3);\n\n\tp2len = rr_read_eeprom_word(rrpriv, 0x83*4);\n\tp2len = (p2len << 2);\n\tp2size = rr_read_eeprom_word(rrpriv, 0x84*4);\n\tp2size = ((p2size & 0x1fffff) >> 3);\n\n\tif ((eptr < p2size) || (eptr > (p2size + p2len))){\n\t\tprintk(\"%s: eptr is invalid\\n\", dev->name);\n\t\tgoto out;\n\t}\n\n\trevision = rr_read_eeprom_word(rrpriv,\n\t\t\toffsetof(struct eeprom, manf.HeaderFmt));\n\n\tif (revision != 1){\n\t\tprintk(\"%s: invalid firmware format (%i)\\n\",\n\t\t       dev->name, revision);\n\t\tgoto out;\n\t}\n\n\tnr_seg = rr_read_eeprom_word(rrpriv, eptr);\n\teptr +=4;\n#if (DEBUG > 1)\n\tprintk(\"%s: nr_seg %i\\n\", dev->name, nr_seg);\n#endif\n\n\tfor (i = 0; i < nr_seg; i++){\n\t\tsptr = rr_read_eeprom_word(rrpriv, eptr);\n\t\teptr += 4;\n\t\tlen = rr_read_eeprom_word(rrpriv, eptr);\n\t\teptr += 4;\n\t\tsegptr = rr_read_eeprom_word(rrpriv, eptr);\n\t\tsegptr = ((segptr & 0x1fffff) >> 3);\n\t\teptr += 4;\n#if (DEBUG > 1)\n\t\tprintk(\"%s: segment %i, sram address %06x, length %04x, segptr %06x\\n\",\n\t\t       dev->name, i, sptr, len, segptr);\n#endif\n\t\tfor (j = 0; j < len; j++){\n\t\t\ttmp = rr_read_eeprom_word(rrpriv, segptr);\n\t\t\twritel(sptr, &regs->WinBase);\n\t\t\tmb();\n\t\t\twritel(tmp, &regs->WinData);\n\t\t\tmb();\n\t\t\tsegptr += 4;\n\t\t\tsptr += 4;\n\t\t}\n\t}\n\nout:\n\twritel(localctrl, &regs->LocalCtrl);\n\tmb();\n\treturn 0;\n}\n\n\nstatic int rr_siocdevprivate(struct net_device *dev, struct ifreq *rq,\n\t\t\t     void __user *data, int cmd)\n{\n\tstruct rr_private *rrpriv;\n\tunsigned char *image, *oldimage;\n\tunsigned long flags;\n\tunsigned int i;\n\tint error = -EOPNOTSUPP;\n\n\trrpriv = netdev_priv(dev);\n\n\tswitch(cmd){\n\tcase SIOCRRGFW:\n\t\tif (!capable(CAP_SYS_RAWIO)){\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\timage = kmalloc_array(EEPROM_WORDS, sizeof(u32), GFP_KERNEL);\n\t\tif (!image)\n\t\t\treturn -ENOMEM;\n\n\t\tif (rrpriv->fw_running){\n\t\t\tprintk(\"%s: Firmware already running\\n\", dev->name);\n\t\t\terror = -EPERM;\n\t\t\tgoto gf_out;\n\t\t}\n\n\t\tspin_lock_irqsave(&rrpriv->lock, flags);\n\t\ti = rr_read_eeprom(rrpriv, 0, image, EEPROM_BYTES);\n\t\tspin_unlock_irqrestore(&rrpriv->lock, flags);\n\t\tif (i != EEPROM_BYTES){\n\t\t\tprintk(KERN_ERR \"%s: Error reading EEPROM\\n\",\n\t\t\t       dev->name);\n\t\t\terror = -EFAULT;\n\t\t\tgoto gf_out;\n\t\t}\n\t\terror = copy_to_user(data, image, EEPROM_BYTES);\n\t\tif (error)\n\t\t\terror = -EFAULT;\n\tgf_out:\n\t\tkfree(image);\n\t\treturn error;\n\n\tcase SIOCRRPFW:\n\t\tif (!capable(CAP_SYS_RAWIO)){\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\timage = memdup_user(data, EEPROM_BYTES);\n\t\tif (IS_ERR(image))\n\t\t\treturn PTR_ERR(image);\n\n\t\toldimage = kmalloc(EEPROM_BYTES, GFP_KERNEL);\n\t\tif (!oldimage) {\n\t\t\tkfree(image);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (rrpriv->fw_running){\n\t\t\tprintk(\"%s: Firmware already running\\n\", dev->name);\n\t\t\terror = -EPERM;\n\t\t\tgoto wf_out;\n\t\t}\n\n\t\tprintk(\"%s: Updating EEPROM firmware\\n\", dev->name);\n\n\t\tspin_lock_irqsave(&rrpriv->lock, flags);\n\t\terror = write_eeprom(rrpriv, 0, image, EEPROM_BYTES);\n\t\tif (error)\n\t\t\tprintk(KERN_ERR \"%s: Error writing EEPROM\\n\",\n\t\t\t       dev->name);\n\n\t\ti = rr_read_eeprom(rrpriv, 0, oldimage, EEPROM_BYTES);\n\t\tspin_unlock_irqrestore(&rrpriv->lock, flags);\n\n\t\tif (i != EEPROM_BYTES)\n\t\t\tprintk(KERN_ERR \"%s: Error reading back EEPROM \"\n\t\t\t       \"image\\n\", dev->name);\n\n\t\terror = memcmp(image, oldimage, EEPROM_BYTES);\n\t\tif (error){\n\t\t\tprintk(KERN_ERR \"%s: Error verifying EEPROM image\\n\",\n\t\t\t       dev->name);\n\t\t\terror = -EFAULT;\n\t\t}\n\twf_out:\n\t\tkfree(oldimage);\n\t\tkfree(image);\n\t\treturn error;\n\n\tcase SIOCRRID:\n\t\treturn put_user(0x52523032, (int __user *)data);\n\tdefault:\n\t\treturn error;\n\t}\n}\n\nstatic const struct pci_device_id rr_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_ESSENTIAL, PCI_DEVICE_ID_ESSENTIAL_ROADRUNNER,\n\t\tPCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0,}\n};\nMODULE_DEVICE_TABLE(pci, rr_pci_tbl);\n\nstatic struct pci_driver rr_driver = {\n\t.name\t\t= \"rrunner\",\n\t.id_table\t= rr_pci_tbl,\n\t.probe\t\t= rr_init_one,\n\t.remove\t\t= rr_remove_one,\n};\n\nmodule_pci_driver(rr_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}