{
  "module_name": "pse_core.c",
  "hash_id": "90526ba28fcdc737e89b207990019069d8ad2ab48ce7636a0c205c373f9adbe3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/pse-pd/pse_core.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/pse-pd/pse.h>\n\nstatic DEFINE_MUTEX(pse_list_mutex);\nstatic LIST_HEAD(pse_controller_list);\n\n \nstruct pse_control {\n\tstruct pse_controller_dev *pcdev;\n\tstruct list_head list;\n\tunsigned int id;\n\tstruct kref refcnt;\n};\n\n \nstatic int of_pse_zero_xlate(struct pse_controller_dev *pcdev,\n\t\t\t     const struct of_phandle_args *pse_spec)\n{\n\treturn 0;\n}\n\n \nstatic int of_pse_simple_xlate(struct pse_controller_dev *pcdev,\n\t\t\t       const struct of_phandle_args *pse_spec)\n{\n\tif (pse_spec->args[0] >= pcdev->nr_lines)\n\t\treturn -EINVAL;\n\n\treturn pse_spec->args[0];\n}\n\n \nint pse_controller_register(struct pse_controller_dev *pcdev)\n{\n\tif (!pcdev->of_xlate) {\n\t\tif (pcdev->of_pse_n_cells == 0)\n\t\t\tpcdev->of_xlate = of_pse_zero_xlate;\n\t\telse if (pcdev->of_pse_n_cells == 1)\n\t\t\tpcdev->of_xlate = of_pse_simple_xlate;\n\t}\n\n\tmutex_init(&pcdev->lock);\n\tINIT_LIST_HEAD(&pcdev->pse_control_head);\n\n\tmutex_lock(&pse_list_mutex);\n\tlist_add(&pcdev->list, &pse_controller_list);\n\tmutex_unlock(&pse_list_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pse_controller_register);\n\n \nvoid pse_controller_unregister(struct pse_controller_dev *pcdev)\n{\n\tmutex_lock(&pse_list_mutex);\n\tlist_del(&pcdev->list);\n\tmutex_unlock(&pse_list_mutex);\n}\nEXPORT_SYMBOL_GPL(pse_controller_unregister);\n\nstatic void devm_pse_controller_release(struct device *dev, void *res)\n{\n\tpse_controller_unregister(*(struct pse_controller_dev **)res);\n}\n\n \nint devm_pse_controller_register(struct device *dev,\n\t\t\t\t struct pse_controller_dev *pcdev)\n{\n\tstruct pse_controller_dev **pcdevp;\n\tint ret;\n\n\tpcdevp = devres_alloc(devm_pse_controller_release, sizeof(*pcdevp),\n\t\t\t      GFP_KERNEL);\n\tif (!pcdevp)\n\t\treturn -ENOMEM;\n\n\tret = pse_controller_register(pcdev);\n\tif (ret) {\n\t\tdevres_free(pcdevp);\n\t\treturn ret;\n\t}\n\n\t*pcdevp = pcdev;\n\tdevres_add(dev, pcdevp);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_pse_controller_register);\n\n \n\nstatic void __pse_control_release(struct kref *kref)\n{\n\tstruct pse_control *psec = container_of(kref, struct pse_control,\n\t\t\t\t\t\t  refcnt);\n\n\tlockdep_assert_held(&pse_list_mutex);\n\n\tmodule_put(psec->pcdev->owner);\n\n\tlist_del(&psec->list);\n\tkfree(psec);\n}\n\nstatic void __pse_control_put_internal(struct pse_control *psec)\n{\n\tlockdep_assert_held(&pse_list_mutex);\n\n\tkref_put(&psec->refcnt, __pse_control_release);\n}\n\n \nvoid pse_control_put(struct pse_control *psec)\n{\n\tif (IS_ERR_OR_NULL(psec))\n\t\treturn;\n\n\tmutex_lock(&pse_list_mutex);\n\t__pse_control_put_internal(psec);\n\tmutex_unlock(&pse_list_mutex);\n}\nEXPORT_SYMBOL_GPL(pse_control_put);\n\nstatic struct pse_control *\npse_control_get_internal(struct pse_controller_dev *pcdev, unsigned int index)\n{\n\tstruct pse_control *psec;\n\n\tlockdep_assert_held(&pse_list_mutex);\n\n\tlist_for_each_entry(psec, &pcdev->pse_control_head, list) {\n\t\tif (psec->id == index) {\n\t\t\tkref_get(&psec->refcnt);\n\t\t\treturn psec;\n\t\t}\n\t}\n\n\tpsec = kzalloc(sizeof(*psec), GFP_KERNEL);\n\tif (!psec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!try_module_get(pcdev->owner)) {\n\t\tkfree(psec);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tpsec->pcdev = pcdev;\n\tlist_add(&psec->list, &pcdev->pse_control_head);\n\tpsec->id = index;\n\tkref_init(&psec->refcnt);\n\n\treturn psec;\n}\n\nstruct pse_control *\nof_pse_control_get(struct device_node *node)\n{\n\tstruct pse_controller_dev *r, *pcdev;\n\tstruct of_phandle_args args;\n\tstruct pse_control *psec;\n\tint psec_id;\n\tint ret;\n\n\tif (!node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tret = of_parse_phandle_with_args(node, \"pses\", \"#pse-cells\", 0, &args);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tmutex_lock(&pse_list_mutex);\n\tpcdev = NULL;\n\tlist_for_each_entry(r, &pse_controller_list, list) {\n\t\tif (args.np == r->dev->of_node) {\n\t\t\tpcdev = r;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!pcdev) {\n\t\tpsec = ERR_PTR(-EPROBE_DEFER);\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON(args.args_count != pcdev->of_pse_n_cells)) {\n\t\tpsec = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tpsec_id = pcdev->of_xlate(pcdev, &args);\n\tif (psec_id < 0) {\n\t\tpsec = ERR_PTR(psec_id);\n\t\tgoto out;\n\t}\n\n\t \n\tpsec = pse_control_get_internal(pcdev, psec_id);\n\nout:\n\tmutex_unlock(&pse_list_mutex);\n\tof_node_put(args.np);\n\n\treturn psec;\n}\nEXPORT_SYMBOL_GPL(of_pse_control_get);\n\n \nint pse_ethtool_get_status(struct pse_control *psec,\n\t\t\t   struct netlink_ext_ack *extack,\n\t\t\t   struct pse_control_status *status)\n{\n\tconst struct pse_controller_ops *ops;\n\tint err;\n\n\tops = psec->pcdev->ops;\n\n\tif (!ops->ethtool_get_status) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PSE driver does not support status report\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&psec->pcdev->lock);\n\terr = ops->ethtool_get_status(psec->pcdev, psec->id, extack, status);\n\tmutex_unlock(&psec->pcdev->lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(pse_ethtool_get_status);\n\n \nint pse_ethtool_set_config(struct pse_control *psec,\n\t\t\t   struct netlink_ext_ack *extack,\n\t\t\t   const struct pse_control_config *config)\n{\n\tconst struct pse_controller_ops *ops;\n\tint err;\n\n\tops = psec->pcdev->ops;\n\n\tif (!ops->ethtool_set_config) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PSE driver does not configuration\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&psec->pcdev->lock);\n\terr = ops->ethtool_set_config(psec->pcdev, psec->id, extack, config);\n\tmutex_unlock(&psec->pcdev->lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(pse_ethtool_set_config);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}