{
  "module_name": "pse_regulator.c",
  "hash_id": "6b657e39c60277921450a8c2fc5d40cfaf7bbea73446f02479afc10d092417fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/pse-pd/pse_regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pse-pd/pse.h>\n#include <linux/regulator/consumer.h>\n\nstruct pse_reg_priv {\n\tstruct pse_controller_dev pcdev;\n\tstruct regulator *ps;  \n\tenum ethtool_podl_pse_admin_state admin_state;\n};\n\nstatic struct pse_reg_priv *to_pse_reg(struct pse_controller_dev *pcdev)\n{\n\treturn container_of(pcdev, struct pse_reg_priv, pcdev);\n}\n\nstatic int\npse_reg_ethtool_set_config(struct pse_controller_dev *pcdev, unsigned long id,\n\t\t\t   struct netlink_ext_ack *extack,\n\t\t\t   const struct pse_control_config *config)\n{\n\tstruct pse_reg_priv *priv = to_pse_reg(pcdev);\n\tint ret;\n\n\tif (priv->admin_state == config->admin_cotrol)\n\t\treturn 0;\n\n\tswitch (config->admin_cotrol) {\n\tcase ETHTOOL_PODL_PSE_ADMIN_STATE_ENABLED:\n\t\tret = regulator_enable(priv->ps);\n\t\tbreak;\n\tcase ETHTOOL_PODL_PSE_ADMIN_STATE_DISABLED:\n\t\tret = regulator_disable(priv->ps);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pcdev->dev, \"Unknown admin state %i\\n\",\n\t\t\tconfig->admin_cotrol);\n\t\tret = -ENOTSUPP;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->admin_state = config->admin_cotrol;\n\n\treturn 0;\n}\n\nstatic int\npse_reg_ethtool_get_status(struct pse_controller_dev *pcdev, unsigned long id,\n\t\t\t   struct netlink_ext_ack *extack,\n\t\t\t   struct pse_control_status *status)\n{\n\tstruct pse_reg_priv *priv = to_pse_reg(pcdev);\n\tint ret;\n\n\tret = regulator_is_enabled(priv->ps);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!ret)\n\t\tstatus->podl_pw_status = ETHTOOL_PODL_PSE_PW_D_STATUS_DISABLED;\n\telse\n\t\tstatus->podl_pw_status =\n\t\t\tETHTOOL_PODL_PSE_PW_D_STATUS_DELIVERING;\n\n\tstatus->podl_admin_state = priv->admin_state;\n\n\treturn 0;\n}\n\nstatic const struct pse_controller_ops pse_reg_ops = {\n\t.ethtool_get_status = pse_reg_ethtool_get_status,\n\t.ethtool_set_config = pse_reg_ethtool_set_config,\n};\n\nstatic int\npse_reg_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pse_reg_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENOENT;\n\n\tpriv->ps = devm_regulator_get_exclusive(dev, \"pse\");\n\tif (IS_ERR(priv->ps))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->ps),\n\t\t\t\t     \"failed to get PSE regulator.\\n\");\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = regulator_is_enabled(priv->ps);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret)\n\t\tpriv->admin_state = ETHTOOL_PODL_PSE_ADMIN_STATE_ENABLED;\n\telse\n\t\tpriv->admin_state = ETHTOOL_PODL_PSE_ADMIN_STATE_DISABLED;\n\n\tpriv->pcdev.owner = THIS_MODULE;\n\tpriv->pcdev.ops = &pse_reg_ops;\n\tpriv->pcdev.dev = dev;\n\tret = devm_pse_controller_register(dev, &priv->pcdev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register PSE controller (%pe)\\n\",\n\t\t\tERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const __maybe_unused struct of_device_id pse_reg_of_match[] = {\n\t{ .compatible = \"podl-pse-regulator\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pse_reg_of_match);\n\nstatic struct platform_driver pse_reg_driver = {\n\t.probe\t\t= pse_reg_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"PSE regulator\",\n\t\t.of_match_table = of_match_ptr(pse_reg_of_match),\n\t},\n};\nmodule_platform_driver(pse_reg_driver);\n\nMODULE_AUTHOR(\"Oleksij Rempel <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"regulator based Ethernet Power Sourcing Equipment\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:pse-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}