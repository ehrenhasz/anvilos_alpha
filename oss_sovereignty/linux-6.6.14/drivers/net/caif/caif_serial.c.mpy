{
  "module_name": "caif_serial.c",
  "hash_id": "d39ae27dd5f18f015f3feec4ceb642e35d8a00e077ef8c0f8d9cdb4c8a78eb5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/caif/caif_serial.c",
  "human_readable_source": "\n \n\n#include <linux/hardirq.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/if_arp.h>\n#include <net/caif/caif_device.h>\n#include <net/caif/cfcnfg.h>\n#include <linux/err.h>\n#include <linux/debugfs.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Sjur Brendeland\");\nMODULE_DESCRIPTION(\"CAIF serial device TTY line discipline\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_CAIF);\n\n#define SEND_QUEUE_LOW 10\n#define SEND_QUEUE_HIGH 100\n#define CAIF_SENDING\t        1  \n#define CAIF_FLOW_OFF_SENT\t4  \n#define MAX_WRITE_CHUNK\t     4096\n#define ON 1\n#define OFF 0\n#define CAIF_MAX_MTU 4096\n\nstatic DEFINE_SPINLOCK(ser_lock);\nstatic LIST_HEAD(ser_list);\nstatic LIST_HEAD(ser_release_list);\n\nstatic bool ser_loop;\nmodule_param(ser_loop, bool, 0444);\nMODULE_PARM_DESC(ser_loop, \"Run in simulated loopback mode.\");\n\nstatic bool ser_use_stx = true;\nmodule_param(ser_use_stx, bool, 0444);\nMODULE_PARM_DESC(ser_use_stx, \"STX enabled or not.\");\n\nstatic bool ser_use_fcs = true;\n\nmodule_param(ser_use_fcs, bool, 0444);\nMODULE_PARM_DESC(ser_use_fcs, \"FCS enabled or not.\");\n\nstatic int ser_write_chunk = MAX_WRITE_CHUNK;\nmodule_param(ser_write_chunk, int, 0444);\n\nMODULE_PARM_DESC(ser_write_chunk, \"Maximum size of data written to UART.\");\n\nstatic struct dentry *debugfsdir;\n\nstatic int caif_net_open(struct net_device *dev);\nstatic int caif_net_close(struct net_device *dev);\n\nstruct ser_device {\n\tstruct caif_dev_common common;\n\tstruct list_head node;\n\tstruct net_device *dev;\n\tstruct sk_buff_head head;\n\tstruct tty_struct *tty;\n\tbool tx_started;\n\tunsigned long state;\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *debugfs_tty_dir;\n\tstruct debugfs_blob_wrapper tx_blob;\n\tstruct debugfs_blob_wrapper rx_blob;\n\tu8 rx_data[128];\n\tu8 tx_data[128];\n\tu8 tty_status;\n\n#endif\n};\n\nstatic void caifdev_setup(struct net_device *dev);\nstatic void ldisc_tx_wakeup(struct tty_struct *tty);\n#ifdef CONFIG_DEBUG_FS\nstatic inline void update_tty_status(struct ser_device *ser)\n{\n\tser->tty_status =\n\t\tser->tty->flow.stopped << 5 |\n\t\tser->tty->flow.tco_stopped << 3 |\n\t\tser->tty->ctrl.packet << 2;\n}\nstatic inline void debugfs_init(struct ser_device *ser, struct tty_struct *tty)\n{\n\tser->debugfs_tty_dir = debugfs_create_dir(tty->name, debugfsdir);\n\n\tdebugfs_create_blob(\"last_tx_msg\", 0400, ser->debugfs_tty_dir,\n\t\t\t    &ser->tx_blob);\n\n\tdebugfs_create_blob(\"last_rx_msg\", 0400, ser->debugfs_tty_dir,\n\t\t\t    &ser->rx_blob);\n\n\tdebugfs_create_xul(\"ser_state\", 0400, ser->debugfs_tty_dir,\n\t\t\t   &ser->state);\n\n\tdebugfs_create_x8(\"tty_status\", 0400, ser->debugfs_tty_dir,\n\t\t\t  &ser->tty_status);\n\n\tser->tx_blob.data = ser->tx_data;\n\tser->tx_blob.size = 0;\n\tser->rx_blob.data = ser->rx_data;\n\tser->rx_blob.size = 0;\n}\n\nstatic inline void debugfs_deinit(struct ser_device *ser)\n{\n\tdebugfs_remove_recursive(ser->debugfs_tty_dir);\n}\n\nstatic inline void debugfs_rx(struct ser_device *ser, const u8 *data, int size)\n{\n\tif (size > sizeof(ser->rx_data))\n\t\tsize = sizeof(ser->rx_data);\n\tmemcpy(ser->rx_data, data, size);\n\tser->rx_blob.data = ser->rx_data;\n\tser->rx_blob.size = size;\n}\n\nstatic inline void debugfs_tx(struct ser_device *ser, const u8 *data, int size)\n{\n\tif (size > sizeof(ser->tx_data))\n\t\tsize = sizeof(ser->tx_data);\n\tmemcpy(ser->tx_data, data, size);\n\tser->tx_blob.data = ser->tx_data;\n\tser->tx_blob.size = size;\n}\n#else\nstatic inline void debugfs_init(struct ser_device *ser, struct tty_struct *tty)\n{\n}\n\nstatic inline void debugfs_deinit(struct ser_device *ser)\n{\n}\n\nstatic inline void update_tty_status(struct ser_device *ser)\n{\n}\n\nstatic inline void debugfs_rx(struct ser_device *ser, const u8 *data, int size)\n{\n}\n\nstatic inline void debugfs_tx(struct ser_device *ser, const u8 *data, int size)\n{\n}\n\n#endif\n\nstatic void ldisc_receive(struct tty_struct *tty, const u8 *data,\n\t\t\t  const u8 *flags, size_t count)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct ser_device *ser;\n\tint ret;\n\n\tser = tty->disc_data;\n\n\t \n\n\n\t \n\tif (!ser->common.use_stx && !ser->tx_started) {\n\t\tdev_info(&ser->dev->dev,\n\t\t\t\"Bytes received before initial transmission -\"\n\t\t\t\"bytes discarded.\\n\");\n\t\treturn;\n\t}\n\n\tBUG_ON(ser->dev == NULL);\n\n\t \n\tskb = netdev_alloc_skb(ser->dev, count+1);\n\tif (skb == NULL)\n\t\treturn;\n\tskb_put_data(skb, data, count);\n\n\tskb->protocol = htons(ETH_P_CAIF);\n\tskb_reset_mac_header(skb);\n\tdebugfs_rx(ser, data, count);\n\t \n\tret = netif_rx(skb);\n\tif (!ret) {\n\t\tser->dev->stats.rx_packets++;\n\t\tser->dev->stats.rx_bytes += count;\n\t} else\n\t\t++ser->dev->stats.rx_dropped;\n\tupdate_tty_status(ser);\n}\n\nstatic int handle_tx(struct ser_device *ser)\n{\n\tstruct tty_struct *tty;\n\tstruct sk_buff *skb;\n\tint tty_wr, len, room;\n\n\ttty = ser->tty;\n\tser->tx_started = true;\n\n\t \n\tif (test_and_set_bit(CAIF_SENDING, &ser->state))\n\t\treturn 0;\n\n\t \n\twhile ((skb = skb_peek(&ser->head)) != NULL) {\n\n\t\t \n\t\tlen = skb->len;\n\t\troom = tty_write_room(tty);\n\t\tif (!room)\n\t\t\tbreak;\n\t\tif (room > ser_write_chunk)\n\t\t\troom = ser_write_chunk;\n\t\tif (len > room)\n\t\t\tlen = room;\n\n\t\t \n\t\tif (!ser_loop) {\n\t\t\ttty_wr = tty->ops->write(tty, skb->data, len);\n\t\t\tupdate_tty_status(ser);\n\t\t} else {\n\t\t\ttty_wr = len;\n\t\t\tldisc_receive(tty, skb->data, NULL, len);\n\t\t}\n\t\tser->dev->stats.tx_packets++;\n\t\tser->dev->stats.tx_bytes += tty_wr;\n\n\t\t \n\t\tif (tty_wr < 0)\n\t\t\tgoto error;\n\t\t \n\t\tskb_pull(skb, tty_wr);\n\t\tif (skb->len == 0) {\n\t\t\tstruct sk_buff *tmp = skb_dequeue(&ser->head);\n\t\t\tWARN_ON(tmp != skb);\n\t\t\tdev_consume_skb_any(skb);\n\t\t}\n\t}\n\t \n\tif (ser->head.qlen <= SEND_QUEUE_LOW &&\n\t\ttest_and_clear_bit(CAIF_FLOW_OFF_SENT, &ser->state) &&\n\t\tser->common.flowctrl != NULL)\n\t\t\t\tser->common.flowctrl(ser->dev, ON);\n\tclear_bit(CAIF_SENDING, &ser->state);\n\treturn 0;\nerror:\n\tclear_bit(CAIF_SENDING, &ser->state);\n\treturn tty_wr;\n}\n\nstatic netdev_tx_t caif_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ser_device *ser;\n\n\tser = netdev_priv(dev);\n\n\t \n\tif (ser->head.qlen > SEND_QUEUE_HIGH &&\n\t\t!test_and_set_bit(CAIF_FLOW_OFF_SENT, &ser->state) &&\n\t\tser->common.flowctrl != NULL)\n\n\t\tser->common.flowctrl(ser->dev, OFF);\n\n\tskb_queue_tail(&ser->head, skb);\n\treturn handle_tx(ser);\n}\n\n\nstatic void ldisc_tx_wakeup(struct tty_struct *tty)\n{\n\tstruct ser_device *ser;\n\n\tser = tty->disc_data;\n\tBUG_ON(ser == NULL);\n\tWARN_ON(ser->tty != tty);\n\thandle_tx(ser);\n}\n\n\nstatic void ser_release(struct work_struct *work)\n{\n\tstruct list_head list;\n\tstruct ser_device *ser, *tmp;\n\n\tspin_lock(&ser_lock);\n\tlist_replace_init(&ser_release_list, &list);\n\tspin_unlock(&ser_lock);\n\n\tif (!list_empty(&list)) {\n\t\trtnl_lock();\n\t\tlist_for_each_entry_safe(ser, tmp, &list, node) {\n\t\t\tdev_close(ser->dev);\n\t\t\tunregister_netdevice(ser->dev);\n\t\t\tdebugfs_deinit(ser);\n\t\t}\n\t\trtnl_unlock();\n\t}\n}\n\nstatic DECLARE_WORK(ser_release_work, ser_release);\n\nstatic int ldisc_open(struct tty_struct *tty)\n{\n\tstruct ser_device *ser;\n\tstruct net_device *dev;\n\tchar name[64];\n\tint result;\n\n\t \n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\tif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_TTY_CONFIG))\n\t\treturn -EPERM;\n\n\t \n\tser_release(NULL);\n\n\tresult = snprintf(name, sizeof(name), \"cf%s\", tty->name);\n\tif (result >= IFNAMSIZ)\n\t\treturn -EINVAL;\n\tdev = alloc_netdev(sizeof(*ser), name, NET_NAME_UNKNOWN,\n\t\t\t   caifdev_setup);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tser = netdev_priv(dev);\n\tser->tty = tty_kref_get(tty);\n\tser->dev = dev;\n\tdebugfs_init(ser, tty);\n\ttty->receive_room = N_TTY_BUF_SIZE;\n\ttty->disc_data = ser;\n\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\trtnl_lock();\n\tresult = register_netdevice(dev);\n\tif (result) {\n\t\ttty_kref_put(tty);\n\t\trtnl_unlock();\n\t\tfree_netdev(dev);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock(&ser_lock);\n\tlist_add(&ser->node, &ser_list);\n\tspin_unlock(&ser_lock);\n\trtnl_unlock();\n\tnetif_stop_queue(dev);\n\tupdate_tty_status(ser);\n\treturn 0;\n}\n\nstatic void ldisc_close(struct tty_struct *tty)\n{\n\tstruct ser_device *ser = tty->disc_data;\n\n\ttty_kref_put(ser->tty);\n\n\tspin_lock(&ser_lock);\n\tlist_move(&ser->node, &ser_release_list);\n\tspin_unlock(&ser_lock);\n\tschedule_work(&ser_release_work);\n}\n\n \nstatic struct tty_ldisc_ops caif_ldisc = {\n\t.owner =\tTHIS_MODULE,\n\t.num =\t\tN_CAIF,\n\t.name =\t\t\"n_caif\",\n\t.open =\t\tldisc_open,\n\t.close =\tldisc_close,\n\t.receive_buf =\tldisc_receive,\n\t.write_wakeup =\tldisc_tx_wakeup\n};\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open = caif_net_open,\n\t.ndo_stop = caif_net_close,\n\t.ndo_start_xmit = caif_xmit\n};\n\nstatic void caifdev_setup(struct net_device *dev)\n{\n\tstruct ser_device *serdev = netdev_priv(dev);\n\n\tdev->features = 0;\n\tdev->netdev_ops = &netdev_ops;\n\tdev->type = ARPHRD_CAIF;\n\tdev->flags = IFF_POINTOPOINT | IFF_NOARP;\n\tdev->mtu = CAIF_MAX_MTU;\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\tdev->needs_free_netdev = true;\n\tskb_queue_head_init(&serdev->head);\n\tserdev->common.link_select = CAIF_LINK_LOW_LATENCY;\n\tserdev->common.use_frag = true;\n\tserdev->common.use_stx = ser_use_stx;\n\tserdev->common.use_fcs = ser_use_fcs;\n\tserdev->dev = dev;\n}\n\n\nstatic int caif_net_open(struct net_device *dev)\n{\n\tnetif_wake_queue(dev);\n\treturn 0;\n}\n\nstatic int caif_net_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\nstatic int __init caif_ser_init(void)\n{\n\tint ret;\n\n\tret = tty_register_ldisc(&caif_ldisc);\n\tif (ret < 0)\n\t\tpr_err(\"cannot register CAIF ldisc=%d err=%d\\n\", N_CAIF, ret);\n\n\tdebugfsdir = debugfs_create_dir(\"caif_serial\", NULL);\n\treturn ret;\n}\n\nstatic void __exit caif_ser_exit(void)\n{\n\tspin_lock(&ser_lock);\n\tlist_splice(&ser_list, &ser_release_list);\n\tspin_unlock(&ser_lock);\n\tser_release(NULL);\n\tcancel_work_sync(&ser_release_work);\n\ttty_unregister_ldisc(&caif_ldisc);\n\tdebugfs_remove_recursive(debugfsdir);\n}\n\nmodule_init(caif_ser_init);\nmodule_exit(caif_ser_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}