{
  "module_name": "Kconfig",
  "hash_id": "5ac2ffc0df076efcbc841955618d988286a3f95f72ec6a76be63978afba6db60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# Network device configuration\n#\n\nmenuconfig NETDEVICES\n\tdefault y if UML\n\tdepends on NET\n\tbool \"Network device support\"\n\thelp\n\t  You can say N here if you don't intend to connect your Linux box to\n\t  any other computer at all.\n\n\t  You'll have to say Y if your computer contains a network card that\n\t  you want to use under Linux. If you are going to run SLIP or PPP over\n\t  telephone line or null modem cable you need say Y here. Connecting\n\t  two machines with parallel ports using PLIP needs this, as well as\n\t  AX.25/KISS for sending Internet traffic over amateur radio links.\n\n\t  See also \"The Linux Network Administrator's Guide\" by Olaf Kirch and\n\t  Terry Dawson. Available at <http://www.tldp.org/guides.html>.\n\n\t  If unsure, say Y.\n\n# All the following symbols are dependent on NETDEVICES - do not repeat\n# that for each of the symbols.\nif NETDEVICES\n\nconfig MII\n\ttristate\n\nconfig NET_CORE\n\tdefault y\n\tbool \"Network core driver support\"\n\thelp\n\t  You can say N here if you do not intend to use any of the\n\t  networking core drivers (i.e. VLAN, bridging, bonding, etc.)\n\nif NET_CORE\n\nconfig BONDING\n\ttristate \"Bonding driver support\"\n\tdepends on INET\n\tdepends on IPV6 || IPV6=n\n\tdepends on TLS || TLS_DEVICE=n\n\thelp\n\t  Say 'Y' or 'M' if you wish to be able to 'bond' multiple Ethernet\n\t  Channels together. This is called 'Etherchannel' by Cisco,\n\t  'Trunking' by Sun, 802.3ad by the IEEE, and 'Bonding' in Linux.\n\n\t  The driver supports multiple bonding modes to allow for both high\n\t  performance and high availability operation.\n\n\t  Refer to <file:Documentation/networking/bonding.rst> for more\n\t  information.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called bonding.\n\nconfig DUMMY\n\ttristate \"Dummy net driver support\"\n\thelp\n\t  This is essentially a bit-bucket device (i.e. traffic you send to\n\t  this device is consigned into oblivion) with a configurable IP\n\t  address. It is most commonly used in order to make your currently\n\t  inactive SLIP address seem like a real address for local programs.\n\t  If you use SLIP or PPP, you might want to say Y here. It won't\n\t  enlarge your kernel. What a deal. Read about it in the Network\n\t  Administrator's Guide, available from\n\t  <http://www.tldp.org/docs.html#guide>.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called dummy.\n\nconfig WIREGUARD\n\ttristate \"WireGuard secure network tunnel\"\n\tdepends on NET && INET\n\tdepends on IPV6 || !IPV6\n\tdepends on !KMSAN # KMSAN doesn't support the crypto configs below\n\tselect NET_UDP_TUNNEL\n\tselect DST_CACHE\n\tselect CRYPTO\n\tselect CRYPTO_LIB_CURVE25519\n\tselect CRYPTO_LIB_CHACHA20POLY1305\n\tselect CRYPTO_CHACHA20_X86_64 if X86 && 64BIT\n\tselect CRYPTO_POLY1305_X86_64 if X86 && 64BIT\n\tselect CRYPTO_BLAKE2S_X86 if X86 && 64BIT\n\tselect CRYPTO_CURVE25519_X86 if X86 && 64BIT\n\tselect CRYPTO_CHACHA20_NEON if ARM || (ARM64 && KERNEL_MODE_NEON)\n\tselect CRYPTO_POLY1305_NEON if ARM64 && KERNEL_MODE_NEON\n\tselect CRYPTO_POLY1305_ARM if ARM\n\tselect CRYPTO_BLAKE2S_ARM if ARM\n\tselect CRYPTO_CURVE25519_NEON if ARM && KERNEL_MODE_NEON\n\tselect CRYPTO_CHACHA_MIPS if CPU_MIPS32_R2\n\tselect CRYPTO_POLY1305_MIPS if MIPS\n\tselect CRYPTO_CHACHA_S390 if S390\n\thelp\n\t  WireGuard is a secure, fast, and easy to use replacement for IPSec\n\t  that uses modern cryptography and clever networking tricks. It's\n\t  designed to be fairly general purpose and abstract enough to fit most\n\t  use cases, while at the same time remaining extremely simple to\n\t  configure. See www.wireguard.com for more info.\n\n\t  It's safe to say Y or M here, as the driver is very lightweight and\n\t  is only in use when an administrator chooses to add an interface.\n\nconfig WIREGUARD_DEBUG\n\tbool \"Debugging checks and verbose messages\"\n\tdepends on WIREGUARD\n\thelp\n\t  This will write log messages for handshake and other events\n\t  that occur for a WireGuard interface. It will also perform some\n\t  extra validation checks and unit tests at various points. This is\n\t  only useful for debugging.\n\n\t  Say N here unless you know what you're doing.\n\nconfig EQUALIZER\n\ttristate \"EQL (serial line load balancing) support\"\n\thelp\n\t  If you have two serial connections to some other computer (this\n\t  usually requires two modems and two telephone lines) and you use\n\t  SLIP (the protocol for sending Internet traffic over telephone\n\t  lines) or PPP (a better SLIP) on them, you can make them behave like\n\t  one double speed connection using this driver.  Naturally, this has\n\t  to be supported at the other end as well, either with a similar EQL\n\t  Linux driver or with a Livingston Portmaster 2e.\n\n\t  Say Y if you want this and read\n\t  <file:Documentation/networking/eql.rst>.  You may also want to read\n\t  section 6.2 of the NET-3-HOWTO, available from\n\t  <http://www.tldp.org/docs.html#howto>.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called eql.  If unsure, say N.\n\nconfig NET_FC\n\tbool \"Fibre Channel driver support\"\n\tdepends on SCSI && PCI\n\thelp\n\t  Fibre Channel is a high speed serial protocol mainly used to connect\n\t  large storage devices to the computer; it is compatible with and\n\t  intended to replace SCSI.\n\n\t  If you intend to use Fibre Channel, you need to have a Fibre channel\n\t  adaptor card in your computer; say Y here and to the driver for your\n\t  adaptor below. You also should have said Y to \"SCSI support\" and\n\t  \"SCSI generic support\".\n\nconfig IFB\n\ttristate \"Intermediate Functional Block support\"\n\tdepends on NET_ACT_MIRRED || NFT_FWD_NETDEV\n\tselect NET_REDIRECT\n\thelp\n\t  This is an intermediate driver that allows sharing of\n\t  resources.\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called ifb.  If you want to use more than one ifb\n\t  device at a time, you need to compile this driver as a module.\n\t  Instead of 'ifb', the devices will then be called 'ifb0',\n\t  'ifb1' etc.\n\t  Look at the iproute2 documentation directory for usage etc\n\nsource \"drivers/net/team/Kconfig\"\n\nconfig MACVLAN\n\ttristate \"MAC-VLAN support\"\n\thelp\n\t  This allows one to create virtual interfaces that map packets to\n\t  or from specific MAC addresses to a particular interface.\n\n\t  Macvlan devices can be added using the \"ip\" command from the\n\t  iproute2 package starting with the iproute2-2.6.23 release:\n\n\t  \"ip link add link <real dev> [ address MAC ] [ NAME ] type macvlan\"\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called macvlan.\n\nconfig MACVTAP\n\ttristate \"MAC-VLAN based tap driver\"\n\tdepends on MACVLAN\n\tdepends on INET\n\tselect TAP\n\thelp\n\t  This adds a specialized tap character device driver that is based\n\t  on the MAC-VLAN network interface, called macvtap. A macvtap device\n\t  can be added in the same way as a macvlan device, using 'type\n\t  macvtap', and then be accessed through the tap user space interface.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called macvtap.\n\nconfig IPVLAN_L3S\n\tdepends on NETFILTER\n\tdepends on IPVLAN\n\tdef_bool y\n\tselect NET_L3_MASTER_DEV\n\nconfig IPVLAN\n\ttristate \"IP-VLAN support\"\n\tdepends on INET\n\tdepends on IPV6 || !IPV6\n\thelp\n\t  This allows one to create virtual devices off of a main interface\n\t  and packets will be delivered based on the dest L3 (IPv6/IPv4 addr)\n\t  on packets. All interfaces (including the main interface) share L2\n\t  making it transparent to the connected L2 switch.\n\n\t  Ipvlan devices can be added using the \"ip\" command from the\n\t  iproute2 package starting with the iproute2-3.19 release:\n\n\t  \"ip link add link <main-dev> [ NAME ] type ipvlan\"\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called ipvlan.\n\nconfig IPVTAP\n\ttristate \"IP-VLAN based tap driver\"\n\tdepends on IPVLAN\n\tdepends on INET\n\tselect TAP\n\thelp\n\t  This adds a specialized tap character device driver that is based\n\t  on the IP-VLAN network interface, called ipvtap. An ipvtap device\n\t  can be added in the same way as a ipvlan device, using 'type\n\t  ipvtap', and then be accessed through the tap user space interface.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called ipvtap.\n\nconfig VXLAN\n\ttristate \"Virtual eXtensible Local Area Network (VXLAN)\"\n\tdepends on INET\n\tselect NET_UDP_TUNNEL\n\tselect GRO_CELLS\n\thelp\n\t  This allows one to create vxlan virtual interfaces that provide\n\t  Layer 2 Networks over Layer 3 Networks. VXLAN is often used\n\t  to tunnel virtual network infrastructure in virtualized environments.\n\t  For more information see:\n\t    http://tools.ietf.org/html/draft-mahalingam-dutt-dcops-vxlan-02\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called vxlan.\n\nconfig GENEVE\n\ttristate \"Generic Network Virtualization Encapsulation\"\n\tdepends on INET\n\tdepends on IPV6 || !IPV6\n\tselect NET_UDP_TUNNEL\n\tselect GRO_CELLS\n\thelp\n\t  This allows one to create geneve virtual interfaces that provide\n\t  Layer 2 Networks over Layer 3 Networks. GENEVE is often used\n\t  to tunnel virtual network infrastructure in virtualized environments.\n\t  For more information see:\n\t    http://tools.ietf.org/html/draft-gross-geneve-02\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called geneve.\n\nconfig BAREUDP\n\ttristate \"Bare UDP Encapsulation\"\n\tdepends on INET\n\tdepends on IPV6 || !IPV6\n\tselect NET_UDP_TUNNEL\n\tselect GRO_CELLS\n\thelp\n\t  This adds a bare UDP tunnel module for tunnelling different\n\t  kinds of traffic like MPLS, IP, etc. inside a UDP tunnel.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called bareudp.\n\nconfig GTP\n\ttristate \"GPRS Tunneling Protocol datapath (GTP-U)\"\n\tdepends on INET\n\tselect NET_UDP_TUNNEL\n\thelp\n\t  This allows one to create gtp virtual interfaces that provide\n\t  the GPRS Tunneling Protocol datapath (GTP-U). This tunneling protocol\n\t  is used to prevent subscribers from accessing mobile carrier core\n\t  network infrastructure. This driver requires a userspace software that\n\t  implements the signaling protocol (GTP-C) to update its PDP context\n\t  base, such as OpenGGSN <http://git.osmocom.org/openggsn/). This\n\t  tunneling protocol is implemented according to the GSM TS 09.60 and\n\t  3GPP TS 29.060 standards.\n\n\t  To compile this drivers as a module, choose M here: the module\n\t  will be called gtp.\n\nconfig AMT\n\ttristate \"Automatic Multicast Tunneling (AMT)\"\n\tdepends on INET && IP_MULTICAST\n\tdepends on IPV6 || !IPV6\n\tselect NET_UDP_TUNNEL\n\thelp\n\t  This allows one to create AMT(Automatic Multicast Tunneling)\n\t  virtual interfaces that provide multicast tunneling.\n\t  There are two roles, Gateway, and Relay.\n\t  Gateway Encapsulates IGMP/MLD traffic from listeners to the Relay.\n\t  Gateway Decapsulates multicast traffic from the Relay to Listeners.\n\t  Relay Encapsulates multicast traffic from Sources to Gateway.\n\t  Relay Decapsulates IGMP/MLD traffic from Gateway.\n\n\t  To compile this drivers as a module, choose M here: the module\n\t  will be called amt.\n\nconfig MACSEC\n\ttristate \"IEEE 802.1AE MAC-level encryption (MACsec)\"\n\tselect CRYPTO\n\tselect CRYPTO_AES\n\tselect CRYPTO_GCM\n\tselect GRO_CELLS\n\thelp\n\t   MACsec is an encryption standard for Ethernet.\n\nconfig NETCONSOLE\n\ttristate \"Network console logging support\"\n\thelp\n\t  If you want to log kernel messages over the network, enable this.\n\t  See <file:Documentation/networking/netconsole.rst> for details.\n\nconfig NETCONSOLE_DYNAMIC\n\tbool \"Dynamic reconfiguration of logging targets\"\n\tdepends on NETCONSOLE && SYSFS && CONFIGFS_FS && \\\n\t\t\t!(NETCONSOLE=y && CONFIGFS_FS=m)\n\thelp\n\t  This option enables the ability to dynamically reconfigure target\n\t  parameters (interface, IP addresses, port numbers, MAC addresses)\n\t  at runtime through a userspace interface exported using configfs.\n\t  See <file:Documentation/networking/netconsole.rst> for details.\n\nconfig NETCONSOLE_EXTENDED_LOG\n\tbool \"Set kernel extended message by default\"\n\tdepends on NETCONSOLE\n\tdefault n\n\thelp\n\t  Set extended log support for netconsole message. If this option is\n\t  set, log messages are transmitted with extended metadata header in a\n\t  format similar to /dev/kmsg.  See\n\t  <file:Documentation/networking/netconsole.rst> for details.\n\nconfig NETCONSOLE_PREPEND_RELEASE\n\tbool \"Prepend kernel release version in the message by default\"\n\tdepends on NETCONSOLE_EXTENDED_LOG\n\tdefault n\n\thelp\n\t  Set kernel release to be prepended to each netconsole message by\n\t  default. If this option is set, the kernel release is prepended into\n\t  the first field of every netconsole message, so, the netconsole\n\t  server/peer can easily identify what kernel release is logging each\n\t  message.  See <file:Documentation/networking/netconsole.rst> for\n\t  details.\n\nconfig NETPOLL\n\tdef_bool NETCONSOLE\n\nconfig NET_POLL_CONTROLLER\n\tdef_bool NETPOLL\n\nconfig NTB_NETDEV\n\ttristate \"Virtual Ethernet over NTB Transport\"\n\tdepends on NTB_TRANSPORT\n\nconfig RIONET\n\ttristate \"RapidIO Ethernet over messaging driver support\"\n\tdepends on RAPIDIO\n\nconfig RIONET_TX_SIZE\n\tint \"Number of outbound queue entries\"\n\tdepends on RIONET\n\tdefault \"128\"\n\nconfig RIONET_RX_SIZE\n\tint \"Number of inbound queue entries\"\n\tdepends on RIONET\n\tdefault \"128\"\n\nconfig TUN\n\ttristate \"Universal TUN/TAP device driver support\"\n\tdepends on INET\n\tselect CRC32\n\thelp\n\t  TUN/TAP provides packet reception and transmission for user space\n\t  programs.  It can be viewed as a simple Point-to-Point or Ethernet\n\t  device, which instead of receiving packets from a physical media,\n\t  receives them from user space program and instead of sending packets\n\t  via physical media writes them to the user space program.\n\n\t  When a program opens /dev/net/tun, driver creates and registers\n\t  corresponding net device tunX or tapX.  After a program closed above\n\t  devices, driver will automatically delete tunXX or tapXX device and\n\t  all routes corresponding to it.\n\n\t  Please read <file:Documentation/networking/tuntap.rst> for more\n\t  information.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called tun.\n\n\t  If you don't know what to use this for, you don't need it.\n\nconfig TAP\n\ttristate\n\thelp\n\t  This option is selected by any driver implementing tap user space\n\t  interface for a virtual interface to re-use core tap functionality.\n\nconfig TUN_VNET_CROSS_LE\n\tbool \"Support for cross-endian vnet headers on little-endian kernels\"\n\tdefault n\n\thelp\n\t  This option allows TUN/TAP and MACVTAP device drivers in a\n\t  little-endian kernel to parse vnet headers that come from a\n\t  big-endian legacy virtio device.\n\n\t  Userspace programs can control the feature using the TUNSETVNETBE\n\t  and TUNGETVNETBE ioctls.\n\n\t  Unless you have a little-endian system hosting a big-endian virtual\n\t  machine with a legacy virtio NIC, you should say N.\n\nconfig VETH\n\ttristate \"Virtual ethernet pair device\"\n\tselect PAGE_POOL\n\thelp\n\t  This device is a local ethernet tunnel. Devices are created in pairs.\n\t  When one end receives the packet it appears on its pair and vice\n\t  versa.\n\nconfig VIRTIO_NET\n\ttristate \"Virtio network driver\"\n\tdepends on VIRTIO\n\tselect NET_FAILOVER\n\thelp\n\t  This is the virtual network driver for virtio.  It can be used with\n\t  QEMU based VMMs (like KVM or Xen).  Say Y or M.\n\nconfig NLMON\n\ttristate \"Virtual netlink monitoring device\"\n\thelp\n\t  This option enables a monitoring net device for netlink skbs. The\n\t  purpose of this is to analyze netlink messages with packet sockets.\n\t  Thus applications like tcpdump will be able to see local netlink\n\t  messages if they tap into the netlink device, record pcaps for further\n\t  diagnostics, etc. This is mostly intended for developers or support\n\t  to debug netlink issues. If unsure, say N.\n\nconfig NET_VRF\n\ttristate \"Virtual Routing and Forwarding (Lite)\"\n\tdepends on IP_MULTIPLE_TABLES\n\tdepends on NET_L3_MASTER_DEV\n\tdepends on IPV6 || IPV6=n\n\tdepends on IPV6_MULTIPLE_TABLES || IPV6=n\n\thelp\n\t  This option enables the support for mapping interfaces into VRF's. The\n\t  support enables VRF devices.\n\nconfig VSOCKMON\n\ttristate \"Virtual vsock monitoring device\"\n\tdepends on VHOST_VSOCK\n\thelp\n\t  This option enables a monitoring net device for vsock sockets. It is\n\t  mostly intended for developers or support to debug vsock issues. If\n\t  unsure, say N.\n\nconfig MHI_NET\n\ttristate \"MHI network driver\"\n\tdepends on MHI_BUS\n\thelp\n\t  This is the network driver for MHI bus.  It can be used with\n\t  QCOM based WWAN modems for IP or QMAP/rmnet protocol (like SDX55).\n\t  Say Y or M.\n\nendif # NET_CORE\n\nconfig SUNGEM_PHY\n\ttristate\n\nsource \"drivers/net/arcnet/Kconfig\"\n\nsource \"drivers/atm/Kconfig\"\n\nsource \"drivers/net/caif/Kconfig\"\n\nsource \"drivers/net/dsa/Kconfig\"\n\nsource \"drivers/net/ethernet/Kconfig\"\n\nsource \"drivers/net/fddi/Kconfig\"\n\nsource \"drivers/net/hippi/Kconfig\"\n\nsource \"drivers/net/ipa/Kconfig\"\n\nconfig NET_SB1000\n\ttristate \"General Instruments Surfboard 1000\"\n\tdepends on PNP\n\thelp\n\t  This is a driver for the General Instrument (also known as\n\t  NextLevel) SURFboard 1000 internal\n\t  cable modem. This is an ISA card which is used by a number of cable\n\t  TV companies to provide cable modem access. It's a one-way\n\t  downstream-only cable modem, meaning that your upstream net link is\n\t  provided by your regular phone modem.\n\n\t  At present this driver only compiles as a module, so say M here if\n\t  you have this card. The module will be called sb1000. Then read\n\t  <file:Documentation/networking/device_drivers/cable/sb1000.rst> for\n\t  information on how to use this module, as it needs special ppp\n\t  scripts for establishing a connection. Further documentation\n\t  and the necessary scripts can be found at:\n\n\t  <http://www.jacksonville.net/~fventuri/>\n\t  <http://home.adelphia.net/~siglercm/sb1000.html>\n\t  <http://linuxpower.cx/~cable/>\n\n\t  If you don't have this card, of course say N.\n\nsource \"drivers/net/phy/Kconfig\"\n\nsource \"drivers/net/pse-pd/Kconfig\"\n\nsource \"drivers/net/can/Kconfig\"\n\nsource \"drivers/net/mctp/Kconfig\"\n\nsource \"drivers/net/mdio/Kconfig\"\n\nsource \"drivers/net/pcs/Kconfig\"\n\nsource \"drivers/net/plip/Kconfig\"\n\nsource \"drivers/net/ppp/Kconfig\"\n\nsource \"drivers/net/slip/Kconfig\"\n\nsource \"drivers/s390/net/Kconfig\"\n\nsource \"drivers/net/usb/Kconfig\"\n\nsource \"drivers/net/wireless/Kconfig\"\n\nsource \"drivers/net/wan/Kconfig\"\n\nsource \"drivers/net/ieee802154/Kconfig\"\n\nsource \"drivers/net/wwan/Kconfig\"\n\nconfig XEN_NETDEV_FRONTEND\n\ttristate \"Xen network device frontend driver\"\n\tdepends on XEN\n\tselect XEN_XENBUS_FRONTEND\n\tselect PAGE_POOL\n\tdefault y\n\thelp\n\t  This driver provides support for Xen paravirtual network\n\t  devices exported by a Xen network driver domain (often\n\t  domain 0).\n\n\t  The corresponding Linux backend driver is enabled by the\n\t  CONFIG_XEN_NETDEV_BACKEND option.\n\n\t  If you are compiling a kernel for use as Xen guest, you\n\t  should say Y here. To compile this driver as a module, chose\n\t  M here: the module will be called xen-netfront.\n\nconfig XEN_NETDEV_BACKEND\n\ttristate \"Xen backend network device\"\n\tdepends on XEN_BACKEND\n\thelp\n\t  This driver allows the kernel to act as a Xen network driver\n\t  domain which exports paravirtual network devices to other\n\t  Xen domains. These devices can be accessed by any operating\n\t  system that implements a compatible front end.\n\n\t  The corresponding Linux frontend driver is enabled by the\n\t  CONFIG_XEN_NETDEV_FRONTEND configuration option.\n\n\t  The backend driver presents a standard network device\n\t  endpoint for each paravirtual network device to the driver\n\t  domain network stack. These can then be bridged or routed\n\t  etc in order to provide full network connectivity.\n\n\t  If you are compiling a kernel to run in a Xen network driver\n\t  domain (often this is domain 0) you should say Y here. To\n\t  compile this driver as a module, chose M here: the module\n\t  will be called xen-netback.\n\nconfig VMXNET3\n\ttristate \"VMware VMXNET3 ethernet driver\"\n\tdepends on PCI && INET\n\tdepends on PAGE_SIZE_LESS_THAN_64KB\n\tselect PAGE_POOL\n\thelp\n\t  This driver supports VMware's vmxnet3 virtual ethernet NIC.\n\t  To compile this driver as a module, choose M here: the\n\t  module will be called vmxnet3.\n\nconfig FUJITSU_ES\n\ttristate \"FUJITSU Extended Socket Network Device driver\"\n\tdepends on ACPI\n\thelp\n\t  This driver provides support for Extended Socket network device\n\t  on Extended Partitioning of FUJITSU PRIMEQUEST 2000 E2 series.\n\nsource \"drivers/net/thunderbolt/Kconfig\"\nsource \"drivers/net/hyperv/Kconfig\"\n\nconfig NETDEVSIM\n\ttristate \"Simulated networking device\"\n\tdepends on DEBUG_FS\n\tdepends on INET\n\tdepends on IPV6 || IPV6=n\n\tdepends on PSAMPLE || PSAMPLE=n\n\tdepends on PTP_1588_CLOCK_MOCK || PTP_1588_CLOCK_MOCK=n\n\tselect NET_DEVLINK\n\thelp\n\t  This driver is a developer testing tool and software model that can\n\t  be used to test various control path networking APIs, especially\n\t  HW-offload related.\n\n\t  To compile this driver as a module, choose M here: the module\n\t  will be called netdevsim.\n\nconfig NET_FAILOVER\n\ttristate \"Failover driver\"\n\tselect FAILOVER\n\thelp\n\t  This provides an automated failover mechanism via APIs to create\n\t  and destroy a failover master netdev and manages a primary and\n\t  standby slave netdevs that get registered via the generic failover\n\t  infrastructure. This can be used by paravirtual drivers to enable\n\t  an alternate low latency datapath. It also enables live migration of\n\t  a VM with direct attached VF by failing over to the paravirtual\n\t  datapath when the VF is unplugged.\n\nconfig NETDEV_LEGACY_INIT\n\tbool\n\tdepends on ISA\n\thelp\n\t  Drivers that call netdev_boot_setup_check() should select this\n\t  symbol, everything else no longer needs it.\n\nendif # NETDEVICES\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}