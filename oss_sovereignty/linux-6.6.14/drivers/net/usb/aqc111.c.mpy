{
  "module_name": "aqc111.c",
  "hash_id": "7236792910599e55767ed78dd5682497e8bb07e167a3ddea8790a1b6656dfa41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/aqc111.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/crc32.h>\n#include <linux/if_vlan.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/usbnet.h>\n#include <linux/linkmode.h>\n\n#include \"aqc111.h\"\n\n#define DRIVER_NAME \"aqc111\"\n\nstatic int aqc111_read_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t\tu16 index, u16 size, void *data)\n{\n\tint ret;\n\n\tret = usbnet_read_cmd_nopm(dev, cmd, USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t\t   USB_RECIP_DEVICE, value, index, data, size);\n\n\tif (unlikely(ret < 0))\n\t\tnetdev_warn(dev->net,\n\t\t\t    \"Failed to read(0x%x) reg index 0x%04x: %d\\n\",\n\t\t\t    cmd, index, ret);\n\n\treturn ret;\n}\n\nstatic int aqc111_read_cmd(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t   u16 index, u16 size, void *data)\n{\n\tint ret;\n\n\tret = usbnet_read_cmd(dev, cmd, USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, index, data, size);\n\n\tif (unlikely(ret < 0))\n\t\tnetdev_warn(dev->net,\n\t\t\t    \"Failed to read(0x%x) reg index 0x%04x: %d\\n\",\n\t\t\t    cmd, index, ret);\n\n\treturn ret;\n}\n\nstatic int aqc111_read16_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t\t  u16 index, u16 *data)\n{\n\tint ret = 0;\n\n\tret = aqc111_read_cmd_nopm(dev, cmd, value, index, sizeof(*data), data);\n\tle16_to_cpus(data);\n\n\treturn ret;\n}\n\nstatic int aqc111_read16_cmd(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t     u16 index, u16 *data)\n{\n\tint ret = 0;\n\n\tret = aqc111_read_cmd(dev, cmd, value, index, sizeof(*data), data);\n\tle16_to_cpus(data);\n\n\treturn ret;\n}\n\nstatic int __aqc111_write_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,\n\t\t\t      u16 value, u16 index, u16 size, const void *data)\n{\n\tint err = -ENOMEM;\n\tvoid *buf = NULL;\n\n\tnetdev_dbg(dev->net,\n\t\t   \"%s cmd=%#x reqtype=%#x value=%#x index=%#x size=%d\\n\",\n\t\t   __func__, cmd, reqtype, value, index, size);\n\n\tif (data) {\n\t\tbuf = kmemdup(data, size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t}\n\n\terr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t      cmd, reqtype, value, index, buf, size,\n\t\t\t      (cmd == AQ_PHY_POWER) ? AQ_USB_PHY_SET_TIMEOUT :\n\t\t\t      AQ_USB_SET_TIMEOUT);\n\n\tif (unlikely(err < 0))\n\t\tnetdev_warn(dev->net,\n\t\t\t    \"Failed to write(0x%x) reg index 0x%04x: %d\\n\",\n\t\t\t    cmd, index, err);\n\tkfree(buf);\n\nout:\n\treturn err;\n}\n\nstatic int aqc111_write_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t\t u16 index, u16 size, void *data)\n{\n\tint ret;\n\n\tret = __aqc111_write_cmd(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t USB_RECIP_DEVICE, value, index, size, data);\n\n\treturn ret;\n}\n\nstatic int aqc111_write_cmd(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t    u16 index, u16 size, const void *data)\n{\n\tint ret;\n\n\tif (usb_autopm_get_interface(dev->intf) < 0)\n\t\treturn -ENODEV;\n\n\tret = __aqc111_write_cmd(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t USB_RECIP_DEVICE, value, index, size, data);\n\n\tusb_autopm_put_interface(dev->intf);\n\n\treturn ret;\n}\n\nstatic int aqc111_write16_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t\t   u16 index, u16 *data)\n{\n\tu16 tmp = *data;\n\n\tcpu_to_le16s(&tmp);\n\n\treturn aqc111_write_cmd_nopm(dev, cmd, value, index, sizeof(tmp), &tmp);\n}\n\nstatic int aqc111_write16_cmd(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t      u16 index, u16 *data)\n{\n\tu16 tmp = *data;\n\n\tcpu_to_le16s(&tmp);\n\n\treturn aqc111_write_cmd(dev, cmd, value, index, sizeof(tmp), &tmp);\n}\n\nstatic int aqc111_write32_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t\t   u16 index, u32 *data)\n{\n\tu32 tmp = *data;\n\n\tcpu_to_le32s(&tmp);\n\n\treturn aqc111_write_cmd_nopm(dev, cmd, value, index, sizeof(tmp), &tmp);\n}\n\nstatic int aqc111_write32_cmd(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t      u16 index, u32 *data)\n{\n\tu32 tmp = *data;\n\n\tcpu_to_le32s(&tmp);\n\n\treturn aqc111_write_cmd(dev, cmd, value, index, sizeof(tmp), &tmp);\n}\n\nstatic int aqc111_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t\t  u16 index, u16 size, void *data)\n{\n\treturn usbnet_write_cmd_async(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t      USB_RECIP_DEVICE, value, index, data,\n\t\t\t\t      size);\n}\n\nstatic int aqc111_write16_cmd_async(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t\t    u16 index, u16 *data)\n{\n\tu16 tmp = *data;\n\n\tcpu_to_le16s(&tmp);\n\n\treturn aqc111_write_cmd_async(dev, cmd, value, index,\n\t\t\t\t      sizeof(tmp), &tmp);\n}\n\nstatic void aqc111_get_drvinfo(struct net_device *net,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\n\t \n\tusbnet_get_drvinfo(net, info);\n\tstrscpy(info->driver, DRIVER_NAME, sizeof(info->driver));\n\tsnprintf(info->fw_version, sizeof(info->fw_version), \"%u.%u.%u\",\n\t\t aqc111_data->fw_ver.major,\n\t\t aqc111_data->fw_ver.minor,\n\t\t aqc111_data->fw_ver.rev);\n\tinfo->eedump_len = 0x00;\n\tinfo->regdump_len = 0x00;\n}\n\nstatic void aqc111_get_wol(struct net_device *net,\n\t\t\t   struct ethtool_wolinfo *wolinfo)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\n\twolinfo->supported = WAKE_MAGIC;\n\twolinfo->wolopts = 0;\n\n\tif (aqc111_data->wol_flags & AQ_WOL_FLAG_MP)\n\t\twolinfo->wolopts |= WAKE_MAGIC;\n}\n\nstatic int aqc111_set_wol(struct net_device *net,\n\t\t\t  struct ethtool_wolinfo *wolinfo)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\n\tif (wolinfo->wolopts & ~WAKE_MAGIC)\n\t\treturn -EINVAL;\n\n\taqc111_data->wol_flags = 0;\n\tif (wolinfo->wolopts & WAKE_MAGIC)\n\t\taqc111_data->wol_flags |= AQ_WOL_FLAG_MP;\n\n\treturn 0;\n}\n\nstatic void aqc111_speed_to_link_mode(u32 speed,\n\t\t\t\t      struct ethtool_link_ksettings *elk)\n{\n\tswitch (speed) {\n\tcase SPEED_5000:\n\t\tethtool_link_ksettings_add_link_mode(elk, advertising,\n\t\t\t\t\t\t     5000baseT_Full);\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tethtool_link_ksettings_add_link_mode(elk, advertising,\n\t\t\t\t\t\t     2500baseT_Full);\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tethtool_link_ksettings_add_link_mode(elk, advertising,\n\t\t\t\t\t\t     1000baseT_Full);\n\t\tbreak;\n\tcase SPEED_100:\n\t\tethtool_link_ksettings_add_link_mode(elk, advertising,\n\t\t\t\t\t\t     100baseT_Full);\n\t\tbreak;\n\t}\n}\n\nstatic int aqc111_get_link_ksettings(struct net_device *net,\n\t\t\t\t     struct ethtool_link_ksettings *elk)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\tenum usb_device_speed usb_speed = dev->udev->speed;\n\tu32 speed = SPEED_UNKNOWN;\n\n\tethtool_link_ksettings_zero_link_mode(elk, supported);\n\tethtool_link_ksettings_add_link_mode(elk, supported,\n\t\t\t\t\t     100baseT_Full);\n\tethtool_link_ksettings_add_link_mode(elk, supported,\n\t\t\t\t\t     1000baseT_Full);\n\tif (usb_speed == USB_SPEED_SUPER) {\n\t\tethtool_link_ksettings_add_link_mode(elk, supported,\n\t\t\t\t\t\t     2500baseT_Full);\n\t\tethtool_link_ksettings_add_link_mode(elk, supported,\n\t\t\t\t\t\t     5000baseT_Full);\n\t}\n\tethtool_link_ksettings_add_link_mode(elk, supported, TP);\n\tethtool_link_ksettings_add_link_mode(elk, supported, Autoneg);\n\n\telk->base.port = PORT_TP;\n\telk->base.transceiver = XCVR_INTERNAL;\n\n\telk->base.mdio_support = 0x00;  \n\n\tif (aqc111_data->autoneg)\n\t\tlinkmode_copy(elk->link_modes.advertising,\n\t\t\t      elk->link_modes.supported);\n\telse\n\t\taqc111_speed_to_link_mode(aqc111_data->advertised_speed, elk);\n\n\telk->base.autoneg = aqc111_data->autoneg;\n\n\tswitch (aqc111_data->link_speed) {\n\tcase AQ_INT_SPEED_5G:\n\t\tspeed = SPEED_5000;\n\t\tbreak;\n\tcase AQ_INT_SPEED_2_5G:\n\t\tspeed = SPEED_2500;\n\t\tbreak;\n\tcase AQ_INT_SPEED_1G:\n\t\tspeed = SPEED_1000;\n\t\tbreak;\n\tcase AQ_INT_SPEED_100M:\n\t\tspeed = SPEED_100;\n\t\tbreak;\n\t}\n\telk->base.duplex = DUPLEX_FULL;\n\telk->base.speed = speed;\n\n\treturn 0;\n}\n\nstatic void aqc111_set_phy_speed(struct usbnet *dev, u8 autoneg, u16 speed)\n{\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\n\taqc111_data->phy_cfg &= ~AQ_ADV_MASK;\n\taqc111_data->phy_cfg |= AQ_PAUSE;\n\taqc111_data->phy_cfg |= AQ_ASYM_PAUSE;\n\taqc111_data->phy_cfg |= AQ_DOWNSHIFT;\n\taqc111_data->phy_cfg &= ~AQ_DSH_RETRIES_MASK;\n\taqc111_data->phy_cfg |= (3 << AQ_DSH_RETRIES_SHIFT) &\n\t\t\t\tAQ_DSH_RETRIES_MASK;\n\n\tif (autoneg == AUTONEG_ENABLE) {\n\t\tswitch (speed) {\n\t\tcase SPEED_5000:\n\t\t\taqc111_data->phy_cfg |= AQ_ADV_5G;\n\t\t\tfallthrough;\n\t\tcase SPEED_2500:\n\t\t\taqc111_data->phy_cfg |= AQ_ADV_2G5;\n\t\t\tfallthrough;\n\t\tcase SPEED_1000:\n\t\t\taqc111_data->phy_cfg |= AQ_ADV_1G;\n\t\t\tfallthrough;\n\t\tcase SPEED_100:\n\t\t\taqc111_data->phy_cfg |= AQ_ADV_100M;\n\t\t\t \n\t\t}\n\t} else {\n\t\tswitch (speed) {\n\t\tcase SPEED_5000:\n\t\t\taqc111_data->phy_cfg |= AQ_ADV_5G;\n\t\t\tbreak;\n\t\tcase SPEED_2500:\n\t\t\taqc111_data->phy_cfg |= AQ_ADV_2G5;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\taqc111_data->phy_cfg |= AQ_ADV_1G;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\taqc111_data->phy_cfg |= AQ_ADV_100M;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\taqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0, &aqc111_data->phy_cfg);\n}\n\nstatic int aqc111_set_link_ksettings(struct net_device *net,\n\t\t\t\t     const struct ethtool_link_ksettings *elk)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\tenum usb_device_speed usb_speed = dev->udev->speed;\n\tu8 autoneg = elk->base.autoneg;\n\tu32 speed = elk->base.speed;\n\n\tif (autoneg == AUTONEG_ENABLE) {\n\t\tif (aqc111_data->autoneg != AUTONEG_ENABLE) {\n\t\t\taqc111_data->autoneg = AUTONEG_ENABLE;\n\t\t\taqc111_data->advertised_speed =\n\t\t\t\t\t(usb_speed == USB_SPEED_SUPER) ?\n\t\t\t\t\t SPEED_5000 : SPEED_1000;\n\t\t\taqc111_set_phy_speed(dev, aqc111_data->autoneg,\n\t\t\t\t\t     aqc111_data->advertised_speed);\n\t\t}\n\t} else {\n\t\tif (speed != SPEED_100 &&\n\t\t    speed != SPEED_1000 &&\n\t\t    speed != SPEED_2500 &&\n\t\t    speed != SPEED_5000 &&\n\t\t    speed != SPEED_UNKNOWN)\n\t\t\treturn -EINVAL;\n\n\t\tif (elk->base.duplex != DUPLEX_FULL)\n\t\t\treturn -EINVAL;\n\n\t\tif (usb_speed != USB_SPEED_SUPER && speed > SPEED_1000)\n\t\t\treturn -EINVAL;\n\n\t\taqc111_data->autoneg = AUTONEG_DISABLE;\n\t\tif (speed != SPEED_UNKNOWN)\n\t\t\taqc111_data->advertised_speed = speed;\n\n\t\taqc111_set_phy_speed(dev, aqc111_data->autoneg,\n\t\t\t\t     aqc111_data->advertised_speed);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops aqc111_ethtool_ops = {\n\t.get_drvinfo = aqc111_get_drvinfo,\n\t.get_wol = aqc111_get_wol,\n\t.set_wol = aqc111_set_wol,\n\t.get_msglevel = usbnet_get_msglevel,\n\t.set_msglevel = usbnet_set_msglevel,\n\t.get_link = ethtool_op_get_link,\n\t.get_link_ksettings = aqc111_get_link_ksettings,\n\t.set_link_ksettings = aqc111_set_link_ksettings\n};\n\nstatic int aqc111_change_mtu(struct net_device *net, int new_mtu)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tu16 reg16 = 0;\n\tu8 buf[5];\n\n\tnet->mtu = new_mtu;\n\tdev->hard_mtu = net->mtu + net->hard_header_len;\n\n\taqc111_read16_cmd(dev, AQ_ACCESS_MAC, SFR_MEDIUM_STATUS_MODE,\n\t\t\t  2, &reg16);\n\tif (net->mtu > 1500)\n\t\treg16 |= SFR_MEDIUM_JUMBO_EN;\n\telse\n\t\treg16 &= ~SFR_MEDIUM_JUMBO_EN;\n\n\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_MEDIUM_STATUS_MODE,\n\t\t\t   2, &reg16);\n\n\tif (dev->net->mtu > 12500) {\n\t\tmemcpy(buf, &AQC111_BULKIN_SIZE[2], 5);\n\t\t \n\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_RX_BULKIN_QCTRL,\n\t\t\t\t 5, 5, buf);\n\t}\n\n\t \n\tif (dev->net->mtu <= 4500)\n\t\treg16 = 0x0810;\n\telse if (dev->net->mtu <= 9500)\n\t\treg16 = 0x1020;\n\telse if (dev->net->mtu <= 12500)\n\t\treg16 = 0x1420;\n\telse\n\t\treg16 = 0x1A20;\n\n\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_PAUSE_WATERLVL_LOW,\n\t\t\t   2, &reg16);\n\n\treturn 0;\n}\n\nstatic int aqc111_set_mac_addr(struct net_device *net, void *p)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tint ret = 0;\n\n\tret = eth_mac_addr(net, p);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn aqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_NODE_ID, ETH_ALEN,\n\t\t\t\tETH_ALEN, net->dev_addr);\n}\n\nstatic int aqc111_vlan_rx_kill_vid(struct net_device *net,\n\t\t\t\t   __be16 proto, u16 vid)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tu8 vlan_ctrl = 0;\n\tu16 reg16 = 0;\n\tu8 reg8 = 0;\n\n\taqc111_read_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_CONTROL, 1, 1, &reg8);\n\tvlan_ctrl = reg8;\n\n\t \n\treg8 = (vid / 16);\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_ADDRESS, 1, 1, &reg8);\n\t \n\treg8 = vlan_ctrl | SFR_VLAN_CONTROL_RD;\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_CONTROL, 1, 1, &reg8);\n\taqc111_read16_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_DATA0, 2, &reg16);\n\treg16 &= ~(1 << (vid % 16));\n\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_DATA0, 2, &reg16);\n\treg8 = vlan_ctrl | SFR_VLAN_CONTROL_WE;\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_CONTROL, 1, 1, &reg8);\n\n\treturn 0;\n}\n\nstatic int aqc111_vlan_rx_add_vid(struct net_device *net, __be16 proto, u16 vid)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tu8 vlan_ctrl = 0;\n\tu16 reg16 = 0;\n\tu8 reg8 = 0;\n\n\taqc111_read_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_CONTROL, 1, 1, &reg8);\n\tvlan_ctrl = reg8;\n\n\t \n\treg8 = (vid / 16);\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_ADDRESS, 1, 1, &reg8);\n\t \n\treg8 = vlan_ctrl | SFR_VLAN_CONTROL_RD;\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_CONTROL, 1, 1, &reg8);\n\taqc111_read16_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_DATA0, 2, &reg16);\n\treg16 |= (1 << (vid % 16));\n\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_DATA0, 2, &reg16);\n\treg8 = vlan_ctrl | SFR_VLAN_CONTROL_WE;\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_CONTROL, 1, 1, &reg8);\n\n\treturn 0;\n}\n\nstatic void aqc111_set_rx_mode(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\tint mc_count = 0;\n\n\tmc_count = netdev_mc_count(net);\n\n\taqc111_data->rxctl &= ~(SFR_RX_CTL_PRO | SFR_RX_CTL_AMALL |\n\t\t\t\tSFR_RX_CTL_AM);\n\n\tif (net->flags & IFF_PROMISC) {\n\t\taqc111_data->rxctl |= SFR_RX_CTL_PRO;\n\t} else if ((net->flags & IFF_ALLMULTI) || mc_count > AQ_MAX_MCAST) {\n\t\taqc111_data->rxctl |= SFR_RX_CTL_AMALL;\n\t} else if (!netdev_mc_empty(net)) {\n\t\tu8 m_filter[AQ_MCAST_FILTER_SIZE] = { 0 };\n\t\tstruct netdev_hw_addr *ha = NULL;\n\t\tu32 crc_bits = 0;\n\n\t\tnetdev_for_each_mc_addr(ha, net) {\n\t\t\tcrc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\t\t\tm_filter[crc_bits >> 3] |= BIT(crc_bits & 7);\n\t\t}\n\n\t\taqc111_write_cmd_async(dev, AQ_ACCESS_MAC,\n\t\t\t\t       SFR_MULTI_FILTER_ARRY,\n\t\t\t\t       AQ_MCAST_FILTER_SIZE,\n\t\t\t\t       AQ_MCAST_FILTER_SIZE, m_filter);\n\n\t\taqc111_data->rxctl |= SFR_RX_CTL_AM;\n\t}\n\n\taqc111_write16_cmd_async(dev, AQ_ACCESS_MAC, SFR_RX_CTL,\n\t\t\t\t 2, &aqc111_data->rxctl);\n}\n\nstatic int aqc111_set_features(struct net_device *net,\n\t\t\t       netdev_features_t features)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\tnetdev_features_t changed = net->features ^ features;\n\tu16 reg16 = 0;\n\tu8 reg8 = 0;\n\n\tif (changed & NETIF_F_IP_CSUM) {\n\t\taqc111_read_cmd(dev, AQ_ACCESS_MAC, SFR_TXCOE_CTL, 1, 1, &reg8);\n\t\treg8 ^= SFR_TXCOE_TCP | SFR_TXCOE_UDP;\n\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_TXCOE_CTL,\n\t\t\t\t 1, 1, &reg8);\n\t}\n\n\tif (changed & NETIF_F_IPV6_CSUM) {\n\t\taqc111_read_cmd(dev, AQ_ACCESS_MAC, SFR_TXCOE_CTL, 1, 1, &reg8);\n\t\treg8 ^= SFR_TXCOE_TCPV6 | SFR_TXCOE_UDPV6;\n\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_TXCOE_CTL,\n\t\t\t\t 1, 1, &reg8);\n\t}\n\n\tif (changed & NETIF_F_RXCSUM) {\n\t\taqc111_read_cmd(dev, AQ_ACCESS_MAC, SFR_RXCOE_CTL, 1, 1, &reg8);\n\t\tif (features & NETIF_F_RXCSUM) {\n\t\t\taqc111_data->rx_checksum = 1;\n\t\t\treg8 &= ~(SFR_RXCOE_IP | SFR_RXCOE_TCP | SFR_RXCOE_UDP |\n\t\t\t\t  SFR_RXCOE_TCPV6 | SFR_RXCOE_UDPV6);\n\t\t} else {\n\t\t\taqc111_data->rx_checksum = 0;\n\t\t\treg8 |= SFR_RXCOE_IP | SFR_RXCOE_TCP | SFR_RXCOE_UDP |\n\t\t\t\tSFR_RXCOE_TCPV6 | SFR_RXCOE_UDPV6;\n\t\t}\n\n\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_RXCOE_CTL,\n\t\t\t\t 1, 1, &reg8);\n\t}\n\tif (changed & NETIF_F_HW_VLAN_CTAG_FILTER) {\n\t\tif (features & NETIF_F_HW_VLAN_CTAG_FILTER) {\n\t\t\tu16 i = 0;\n\n\t\t\tfor (i = 0; i < 256; i++) {\n\t\t\t\t \n\t\t\t\treg8 = i;\n\t\t\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC,\n\t\t\t\t\t\t SFR_VLAN_ID_ADDRESS,\n\t\t\t\t\t\t 1, 1, &reg8);\n\t\t\t\t \n\t\t\t\taqc111_write16_cmd(dev, AQ_ACCESS_MAC,\n\t\t\t\t\t\t   SFR_VLAN_ID_DATA0,\n\t\t\t\t\t\t   2, &reg16);\n\t\t\t\treg8 = SFR_VLAN_CONTROL_WE;\n\t\t\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC,\n\t\t\t\t\t\t SFR_VLAN_ID_CONTROL,\n\t\t\t\t\t\t 1, 1, &reg8);\n\t\t\t}\n\t\t\taqc111_read_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_CONTROL,\n\t\t\t\t\t1, 1, &reg8);\n\t\t\treg8 |= SFR_VLAN_CONTROL_VFE;\n\t\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC,\n\t\t\t\t\t SFR_VLAN_ID_CONTROL, 1, 1, &reg8);\n\t\t} else {\n\t\t\taqc111_read_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_CONTROL,\n\t\t\t\t\t1, 1, &reg8);\n\t\t\treg8 &= ~SFR_VLAN_CONTROL_VFE;\n\t\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC,\n\t\t\t\t\t SFR_VLAN_ID_CONTROL, 1, 1, &reg8);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops aqc111_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_change_mtu\t\t= aqc111_change_mtu,\n\t.ndo_set_mac_address\t= aqc111_set_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_vlan_rx_add_vid\t= aqc111_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= aqc111_vlan_rx_kill_vid,\n\t.ndo_set_rx_mode\t= aqc111_set_rx_mode,\n\t.ndo_set_features\t= aqc111_set_features,\n};\n\nstatic int aqc111_read_perm_mac(struct usbnet *dev)\n{\n\tu8 buf[ETH_ALEN];\n\tint ret;\n\n\tret = aqc111_read_cmd(dev, AQ_FLASH_PARAMETERS, 0, 0, ETH_ALEN, buf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tether_addr_copy(dev->net->perm_addr, buf);\n\n\treturn 0;\nout:\n\treturn ret;\n}\n\nstatic void aqc111_read_fw_version(struct usbnet *dev,\n\t\t\t\t   struct aqc111_data *aqc111_data)\n{\n\taqc111_read_cmd(dev, AQ_ACCESS_MAC, AQ_FW_VER_MAJOR,\n\t\t\t1, 1, &aqc111_data->fw_ver.major);\n\taqc111_read_cmd(dev, AQ_ACCESS_MAC, AQ_FW_VER_MINOR,\n\t\t\t1, 1, &aqc111_data->fw_ver.minor);\n\taqc111_read_cmd(dev, AQ_ACCESS_MAC, AQ_FW_VER_REV,\n\t\t\t1, 1, &aqc111_data->fw_ver.rev);\n\n\tif (aqc111_data->fw_ver.major & 0x80)\n\t\taqc111_data->fw_ver.major &= ~0x80;\n}\n\nstatic int aqc111_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tenum usb_device_speed usb_speed = udev->speed;\n\tstruct aqc111_data *aqc111_data;\n\tint ret;\n\n\t \n\tif (udev->actconfig->desc.bConfigurationValue != 1) {\n\t\tusb_driver_set_configuration(udev, 1);\n\t\treturn -ENODEV;\n\t}\n\n\tusb_reset_configuration(dev->udev);\n\n\tret = usbnet_get_endpoints(dev, intf);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"usbnet_get_endpoints failed\");\n\t\treturn ret;\n\t}\n\n\taqc111_data = kzalloc(sizeof(*aqc111_data), GFP_KERNEL);\n\tif (!aqc111_data)\n\t\treturn -ENOMEM;\n\n\t \n\tdev->driver_priv = aqc111_data;\n\n\t \n\tret = aqc111_read_perm_mac(dev);\n\tif (ret)\n\t\tgoto out;\n\n\teth_hw_addr_set(dev->net, dev->net->perm_addr);\n\n\t \n\tdev->rx_urb_size = URB_SIZE;\n\n\t \n\tdev->net->needed_headroom += sizeof(u64);\n\tdev->net->needed_tailroom += sizeof(u64);\n\n\tdev->net->max_mtu = 16334;\n\n\tdev->net->netdev_ops = &aqc111_netdev_ops;\n\tdev->net->ethtool_ops = &aqc111_ethtool_ops;\n\n\tif (usb_device_no_sg_constraint(dev->udev))\n\t\tdev->can_dma_sg = 1;\n\n\tdev->net->hw_features |= AQ_SUPPORT_HW_FEATURE;\n\tdev->net->features |= AQ_SUPPORT_FEATURE;\n\tdev->net->vlan_features |= AQ_SUPPORT_VLAN_FEATURE;\n\n\tnetif_set_tso_max_size(dev->net, 65535);\n\n\taqc111_read_fw_version(dev, aqc111_data);\n\taqc111_data->autoneg = AUTONEG_ENABLE;\n\taqc111_data->advertised_speed = (usb_speed == USB_SPEED_SUPER) ?\n\t\t\t\t\t SPEED_5000 : SPEED_1000;\n\n\treturn 0;\n\nout:\n\tkfree(aqc111_data);\n\treturn ret;\n}\n\nstatic void aqc111_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\tu16 reg16;\n\n\t \n\treg16 = SFR_PHYPWR_RSTCTL_BZ;\n\taqc111_write16_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_PHYPWR_RSTCTL,\n\t\t\t\t2, &reg16);\n\treg16 = 0;\n\taqc111_write16_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_PHYPWR_RSTCTL,\n\t\t\t\t2, &reg16);\n\n\t \n\taqc111_data->phy_cfg &= ~AQ_ADV_MASK;\n\taqc111_data->phy_cfg |= AQ_LOW_POWER;\n\taqc111_data->phy_cfg &= ~AQ_PHY_POWER_EN;\n\taqc111_write32_cmd_nopm(dev, AQ_PHY_OPS, 0, 0,\n\t\t\t\t&aqc111_data->phy_cfg);\n\n\tkfree(aqc111_data);\n}\n\nstatic void aqc111_status(struct usbnet *dev, struct urb *urb)\n{\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\tu64 *event_data = NULL;\n\tint link = 0;\n\n\tif (urb->actual_length < sizeof(*event_data))\n\t\treturn;\n\n\tevent_data = urb->transfer_buffer;\n\tle64_to_cpus(event_data);\n\n\tif (*event_data & AQ_LS_MASK)\n\t\tlink = 1;\n\telse\n\t\tlink = 0;\n\n\taqc111_data->link_speed = (*event_data & AQ_SPEED_MASK) >>\n\t\t\t\t  AQ_SPEED_SHIFT;\n\taqc111_data->link = link;\n\n\tif (netif_carrier_ok(dev->net) != link)\n\t\tusbnet_defer_kevent(dev, EVENT_LINK_RESET);\n}\n\nstatic void aqc111_configure_rx(struct usbnet *dev,\n\t\t\t\tstruct aqc111_data *aqc111_data)\n{\n\tenum usb_device_speed usb_speed = dev->udev->speed;\n\tu16 link_speed = 0, usb_host = 0;\n\tu8 buf[5] = { 0 };\n\tu8 queue_num = 0;\n\tu16 reg16 = 0;\n\tu8 reg8 = 0;\n\n\tbuf[0] = 0x00;\n\tbuf[1] = 0xF8;\n\tbuf[2] = 0x07;\n\tswitch (aqc111_data->link_speed) {\n\tcase AQ_INT_SPEED_5G:\n\t\tlink_speed = 5000;\n\t\treg8 = 0x05;\n\t\treg16 = 0x001F;\n\t\tbreak;\n\tcase AQ_INT_SPEED_2_5G:\n\t\tlink_speed = 2500;\n\t\treg16 = 0x003F;\n\t\tbreak;\n\tcase AQ_INT_SPEED_1G:\n\t\tlink_speed = 1000;\n\t\treg16 = 0x009F;\n\t\tbreak;\n\tcase AQ_INT_SPEED_100M:\n\t\tlink_speed = 100;\n\t\tqueue_num = 1;\n\t\treg16 = 0x063F;\n\t\tbuf[1] = 0xFB;\n\t\tbuf[2] = 0x4;\n\t\tbreak;\n\t}\n\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_INTER_PACKET_GAP_0,\n\t\t\t 1, 1, &reg8);\n\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_TX_PAUSE_RESEND_T, 3, 3, buf);\n\n\tswitch (usb_speed) {\n\tcase USB_SPEED_SUPER:\n\t\tusb_host = 3;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tusb_host = 2;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_LOW:\n\t\tusb_host = 1;\n\t\tqueue_num = 0;\n\t\tbreak;\n\tdefault:\n\t\tusb_host = 0;\n\t\tbreak;\n\t}\n\n\tif (dev->net->mtu > 12500 && dev->net->mtu <= 16334)\n\t\tqueue_num = 2;  \n\n\tmemcpy(buf, &AQC111_BULKIN_SIZE[queue_num], 5);\n\t \n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_RX_BULKIN_QCTRL, 5, 5, buf);\n\n\t \n\tif (dev->net->mtu <= 4500)\n\t\treg16 = 0x0810;\n\telse if (dev->net->mtu <= 9500)\n\t\treg16 = 0x1020;\n\telse if (dev->net->mtu <= 12500)\n\t\treg16 = 0x1420;\n\telse if (dev->net->mtu <= 16334)\n\t\treg16 = 0x1A20;\n\n\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_PAUSE_WATERLVL_LOW,\n\t\t\t   2, &reg16);\n\tnetdev_info(dev->net, \"Link Speed %d, USB %d\", link_speed, usb_host);\n}\n\nstatic void aqc111_configure_csum_offload(struct usbnet *dev)\n{\n\tu8 reg8 = 0;\n\n\tif (dev->net->features & NETIF_F_RXCSUM) {\n\t\treg8 |= SFR_RXCOE_IP | SFR_RXCOE_TCP | SFR_RXCOE_UDP |\n\t\t\tSFR_RXCOE_TCPV6 | SFR_RXCOE_UDPV6;\n\t}\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_RXCOE_CTL, 1, 1, &reg8);\n\n\treg8 = 0;\n\tif (dev->net->features & NETIF_F_IP_CSUM)\n\t\treg8 |= SFR_TXCOE_IP | SFR_TXCOE_TCP | SFR_TXCOE_UDP;\n\n\tif (dev->net->features & NETIF_F_IPV6_CSUM)\n\t\treg8 |= SFR_TXCOE_TCPV6 | SFR_TXCOE_UDPV6;\n\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_TXCOE_CTL, 1, 1, &reg8);\n}\n\nstatic int aqc111_link_reset(struct usbnet *dev)\n{\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\tu16 reg16 = 0;\n\tu8 reg8 = 0;\n\n\tif (aqc111_data->link == 1) {  \n\t\taqc111_configure_rx(dev, aqc111_data);\n\n\t\t \n\t\treg8 = SFR_VLAN_CONTROL_VSO;\n\t\tif (dev->net->features & NETIF_F_HW_VLAN_CTAG_FILTER)\n\t\t\treg8 |= SFR_VLAN_CONTROL_VFE;\n\n\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_VLAN_ID_CONTROL,\n\t\t\t\t 1, 1, &reg8);\n\n\t\treg8 = 0x0;\n\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_BMRX_DMA_CONTROL,\n\t\t\t\t 1, 1, &reg8);\n\n\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_BMTX_DMA_CONTROL,\n\t\t\t\t 1, 1, &reg8);\n\n\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_ARC_CTRL, 1, 1, &reg8);\n\n\t\treg16 = SFR_RX_CTL_IPE | SFR_RX_CTL_AB;\n\t\taqc111_data->rxctl = reg16;\n\t\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_RX_CTL, 2, &reg16);\n\n\t\treg8 = SFR_RX_PATH_READY;\n\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_ETH_MAC_PATH,\n\t\t\t\t 1, 1, &reg8);\n\n\t\treg8 = SFR_BULK_OUT_EFF_EN;\n\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_BULK_OUT_CTRL,\n\t\t\t\t 1, 1, &reg8);\n\n\t\treg16 = 0;\n\t\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_MEDIUM_STATUS_MODE,\n\t\t\t\t   2, &reg16);\n\n\t\treg16 = SFR_MEDIUM_XGMIIMODE | SFR_MEDIUM_FULL_DUPLEX;\n\t\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_MEDIUM_STATUS_MODE,\n\t\t\t\t   2, &reg16);\n\n\t\taqc111_configure_csum_offload(dev);\n\n\t\taqc111_set_rx_mode(dev->net);\n\n\t\taqc111_read16_cmd(dev, AQ_ACCESS_MAC, SFR_MEDIUM_STATUS_MODE,\n\t\t\t\t  2, &reg16);\n\n\t\tif (dev->net->mtu > 1500)\n\t\t\treg16 |= SFR_MEDIUM_JUMBO_EN;\n\n\t\treg16 |= SFR_MEDIUM_RECEIVE_EN | SFR_MEDIUM_RXFLOW_CTRLEN |\n\t\t\t SFR_MEDIUM_TXFLOW_CTRLEN;\n\t\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_MEDIUM_STATUS_MODE,\n\t\t\t\t   2, &reg16);\n\n\t\taqc111_data->rxctl |= SFR_RX_CTL_START;\n\t\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_RX_CTL,\n\t\t\t\t   2, &aqc111_data->rxctl);\n\n\t\tnetif_carrier_on(dev->net);\n\t} else {\n\t\taqc111_read16_cmd(dev, AQ_ACCESS_MAC, SFR_MEDIUM_STATUS_MODE,\n\t\t\t\t  2, &reg16);\n\t\treg16 &= ~SFR_MEDIUM_RECEIVE_EN;\n\t\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_MEDIUM_STATUS_MODE,\n\t\t\t\t   2, &reg16);\n\n\t\taqc111_data->rxctl &= ~SFR_RX_CTL_START;\n\t\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_RX_CTL,\n\t\t\t\t   2, &aqc111_data->rxctl);\n\n\t\treg8 = SFR_BULK_OUT_FLUSH_EN | SFR_BULK_OUT_EFF_EN;\n\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_BULK_OUT_CTRL,\n\t\t\t\t 1, 1, &reg8);\n\t\treg8 = SFR_BULK_OUT_EFF_EN;\n\t\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_BULK_OUT_CTRL,\n\t\t\t\t 1, 1, &reg8);\n\n\t\tnetif_carrier_off(dev->net);\n\t}\n\treturn 0;\n}\n\nstatic int aqc111_reset(struct usbnet *dev)\n{\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\tu8 reg8 = 0;\n\n\tdev->rx_urb_size = URB_SIZE;\n\n\tif (usb_device_no_sg_constraint(dev->udev))\n\t\tdev->can_dma_sg = 1;\n\n\tdev->net->hw_features |= AQ_SUPPORT_HW_FEATURE;\n\tdev->net->features |= AQ_SUPPORT_FEATURE;\n\tdev->net->vlan_features |= AQ_SUPPORT_VLAN_FEATURE;\n\n\t \n\taqc111_data->phy_cfg = AQ_PHY_POWER_EN;\n\taqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0,\n\t\t\t   &aqc111_data->phy_cfg);\n\n\t \n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_NODE_ID, ETH_ALEN,\n\t\t\t ETH_ALEN, dev->net->dev_addr);\n\n\treg8 = 0xFF;\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_BM_INT_MASK, 1, 1, &reg8);\n\n\treg8 = 0x0;\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_SWP_CTRL, 1, 1, &reg8);\n\n\taqc111_read_cmd(dev, AQ_ACCESS_MAC, SFR_MONITOR_MODE, 1, 1, &reg8);\n\treg8 &= ~(SFR_MONITOR_MODE_EPHYRW | SFR_MONITOR_MODE_RWLC |\n\t\t  SFR_MONITOR_MODE_RWMP | SFR_MONITOR_MODE_RWWF |\n\t\t  SFR_MONITOR_MODE_RW_FLAG);\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_MONITOR_MODE, 1, 1, &reg8);\n\n\tnetif_carrier_off(dev->net);\n\n\t \n\taqc111_set_phy_speed(dev, aqc111_data->autoneg,\n\t\t\t     aqc111_data->advertised_speed);\n\n\treturn 0;\n}\n\nstatic int aqc111_stop(struct usbnet *dev)\n{\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\tu16 reg16 = 0;\n\n\taqc111_read16_cmd(dev, AQ_ACCESS_MAC, SFR_MEDIUM_STATUS_MODE,\n\t\t\t  2, &reg16);\n\treg16 &= ~SFR_MEDIUM_RECEIVE_EN;\n\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_MEDIUM_STATUS_MODE,\n\t\t\t   2, &reg16);\n\treg16 = 0;\n\taqc111_write16_cmd(dev, AQ_ACCESS_MAC, SFR_RX_CTL, 2, &reg16);\n\n\t \n\taqc111_data->phy_cfg |= AQ_LOW_POWER;\n\taqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0,\n\t\t\t   &aqc111_data->phy_cfg);\n\n\tnetif_carrier_off(dev->net);\n\n\treturn 0;\n}\n\nstatic void aqc111_rx_checksum(struct sk_buff *skb, u64 pkt_desc)\n{\n\tu32 pkt_type = 0;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\t \n\tif (pkt_desc & AQ_RX_PD_L4_ERR || pkt_desc & AQ_RX_PD_L3_ERR)\n\t\treturn;\n\n\tpkt_type = pkt_desc & AQ_RX_PD_L4_TYPE_MASK;\n\t \n\tif (pkt_type == AQ_RX_PD_L4_TCP || pkt_type == AQ_RX_PD_L4_UDP)\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n}\n\nstatic int aqc111_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\tstruct sk_buff *new_skb = NULL;\n\tu32 pkt_total_offset = 0;\n\tu64 *pkt_desc_ptr = NULL;\n\tu32 start_of_descs = 0;\n\tu32 desc_offset = 0;  \n\tu16 pkt_count = 0;\n\tu64 desc_hdr = 0;\n\tu16 vlan_tag = 0;\n\tu32 skb_len;\n\n\tif (!skb)\n\t\tgoto err;\n\n\tskb_len = skb->len;\n\tif (skb_len < sizeof(desc_hdr))\n\t\tgoto err;\n\n\t \n\tskb_trim(skb, skb_len - sizeof(desc_hdr));\n\tdesc_hdr = le64_to_cpup((u64 *)skb_tail_pointer(skb));\n\n\t \n\tdesc_offset = (desc_hdr & AQ_RX_DH_DESC_OFFSET_MASK) >>\n\t\t      AQ_RX_DH_DESC_OFFSET_SHIFT;\n\tpkt_count = desc_hdr & AQ_RX_DH_PKT_CNT_MASK;\n\tstart_of_descs = skb_len - ((pkt_count + 1) *  sizeof(desc_hdr));\n\n\t \n\tif (start_of_descs != desc_offset)\n\t\tgoto err;\n\n\t \n\tif (pkt_count * 2 + desc_offset >= skb_len)\n\t\tgoto err;\n\n\t \n\tskb_trim(skb, desc_offset);\n\n\tif (pkt_count == 0)\n\t\tgoto err;\n\n\t \n\tpkt_desc_ptr = (u64 *)(skb->data + desc_offset);\n\n\twhile (pkt_count--) {\n\t\tu64 pkt_desc = le64_to_cpup(pkt_desc_ptr);\n\t\tu32 pkt_len_with_padd = 0;\n\t\tu32 pkt_len = 0;\n\n\t\tpkt_len = (u32)((pkt_desc & AQ_RX_PD_LEN_MASK) >>\n\t\t\t  AQ_RX_PD_LEN_SHIFT);\n\t\tpkt_len_with_padd = ((pkt_len + 7) & 0x7FFF8);\n\n\t\tpkt_total_offset += pkt_len_with_padd;\n\t\tif (pkt_total_offset > desc_offset ||\n\t\t    (pkt_count == 0 && pkt_total_offset != desc_offset)) {\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (pkt_desc & AQ_RX_PD_DROP ||\n\t\t    !(pkt_desc & AQ_RX_PD_RX_OK) ||\n\t\t    pkt_len > (dev->hard_mtu + AQ_RX_HW_PAD)) {\n\t\t\tskb_pull(skb, pkt_len_with_padd);\n\t\t\t \n\t\t\tpkt_desc_ptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tnew_skb = skb_clone(skb, GFP_ATOMIC);\n\n\t\tif (!new_skb)\n\t\t\tgoto err;\n\n\t\tnew_skb->len = pkt_len;\n\t\tskb_pull(new_skb, AQ_RX_HW_PAD);\n\t\tskb_set_tail_pointer(new_skb, new_skb->len);\n\n\t\tnew_skb->truesize = SKB_TRUESIZE(new_skb->len);\n\t\tif (aqc111_data->rx_checksum)\n\t\t\taqc111_rx_checksum(new_skb, pkt_desc);\n\n\t\tif (pkt_desc & AQ_RX_PD_VLAN) {\n\t\t\tvlan_tag = pkt_desc >> AQ_RX_PD_VLAN_SHIFT;\n\t\t\t__vlan_hwaccel_put_tag(new_skb, htons(ETH_P_8021Q),\n\t\t\t\t\t       vlan_tag & VLAN_VID_MASK);\n\t\t}\n\n\t\tusbnet_skb_return(dev, new_skb);\n\t\tif (pkt_count == 0)\n\t\t\tbreak;\n\n\t\tskb_pull(skb, pkt_len_with_padd);\n\n\t\t \n\t\tpkt_desc_ptr++;\n\n\t\tnew_skb = NULL;\n\t}\n\n\treturn 1;\n\nerr:\n\treturn 0;\n}\n\nstatic struct sk_buff *aqc111_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\n\t\t\t\t       gfp_t flags)\n{\n\tint frame_size = dev->maxpacket;\n\tstruct sk_buff *new_skb = NULL;\n\tu64 *tx_desc_ptr = NULL;\n\tint padding_size = 0;\n\tint headroom = 0;\n\tint tailroom = 0;\n\tu64 tx_desc = 0;\n\tu16 tci = 0;\n\n\t \n\ttx_desc |= skb->len & AQ_TX_DESC_LEN_MASK;\n\n\t \n\ttx_desc |= ((u64)(skb_shinfo(skb)->gso_size & AQ_TX_DESC_MSS_MASK)) <<\n\t\t   AQ_TX_DESC_MSS_SHIFT;\n\n\theadroom = (skb->len + sizeof(tx_desc)) % 8;\n\tif (headroom != 0)\n\t\tpadding_size = 8 - headroom;\n\n\tif (((skb->len + sizeof(tx_desc) + padding_size) % frame_size) == 0) {\n\t\tpadding_size += 8;\n\t\ttx_desc |= AQ_TX_DESC_DROP_PADD;\n\t}\n\n\t \n\tif (vlan_get_tag(skb, &tci) >= 0) {\n\t\ttx_desc |= AQ_TX_DESC_VLAN;\n\t\ttx_desc |= ((u64)tci & AQ_TX_DESC_VLAN_MASK) <<\n\t\t\t   AQ_TX_DESC_VLAN_SHIFT;\n\t}\n\n\tif (!dev->can_dma_sg && (dev->net->features & NETIF_F_SG) &&\n\t    skb_linearize(skb))\n\t\treturn NULL;\n\n\theadroom = skb_headroom(skb);\n\ttailroom = skb_tailroom(skb);\n\n\tif (!(headroom >= sizeof(tx_desc) && tailroom >= padding_size)) {\n\t\tnew_skb = skb_copy_expand(skb, sizeof(tx_desc),\n\t\t\t\t\t  padding_size, flags);\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = new_skb;\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t}\n\tif (padding_size != 0)\n\t\tskb_put_zero(skb, padding_size);\n\t \n\ttx_desc_ptr = skb_push(skb, sizeof(tx_desc));\n\t*tx_desc_ptr = cpu_to_le64(tx_desc);\n\n\tusbnet_set_skb_tx_stats(skb, 1, 0);\n\n\treturn skb;\n}\n\nstatic const struct driver_info aqc111_info = {\n\t.description\t= \"Aquantia AQtion USB to 5GbE Controller\",\n\t.bind\t\t= aqc111_bind,\n\t.unbind\t\t= aqc111_unbind,\n\t.status\t\t= aqc111_status,\n\t.link_reset\t= aqc111_link_reset,\n\t.reset\t\t= aqc111_reset,\n\t.stop\t\t= aqc111_stop,\n\t.flags\t\t= FLAG_ETHER | FLAG_FRAMING_AX |\n\t\t\t  FLAG_AVOID_UNLINK_URBS | FLAG_MULTI_PACKET,\n\t.rx_fixup\t= aqc111_rx_fixup,\n\t.tx_fixup\t= aqc111_tx_fixup,\n};\n\n#define ASIX111_DESC \\\n\"ASIX USB 3.1 Gen1 to 5G Multi-Gigabit Ethernet Adapter\"\n\nstatic const struct driver_info asix111_info = {\n\t.description\t= ASIX111_DESC,\n\t.bind\t\t= aqc111_bind,\n\t.unbind\t\t= aqc111_unbind,\n\t.status\t\t= aqc111_status,\n\t.link_reset\t= aqc111_link_reset,\n\t.reset\t\t= aqc111_reset,\n\t.stop\t\t= aqc111_stop,\n\t.flags\t\t= FLAG_ETHER | FLAG_FRAMING_AX |\n\t\t\t  FLAG_AVOID_UNLINK_URBS | FLAG_MULTI_PACKET,\n\t.rx_fixup\t= aqc111_rx_fixup,\n\t.tx_fixup\t= aqc111_tx_fixup,\n};\n\n#undef ASIX111_DESC\n\n#define ASIX112_DESC \\\n\"ASIX USB 3.1 Gen1 to 2.5G Multi-Gigabit Ethernet Adapter\"\n\nstatic const struct driver_info asix112_info = {\n\t.description\t= ASIX112_DESC,\n\t.bind\t\t= aqc111_bind,\n\t.unbind\t\t= aqc111_unbind,\n\t.status\t\t= aqc111_status,\n\t.link_reset\t= aqc111_link_reset,\n\t.reset\t\t= aqc111_reset,\n\t.stop\t\t= aqc111_stop,\n\t.flags\t\t= FLAG_ETHER | FLAG_FRAMING_AX |\n\t\t\t  FLAG_AVOID_UNLINK_URBS | FLAG_MULTI_PACKET,\n\t.rx_fixup\t= aqc111_rx_fixup,\n\t.tx_fixup\t= aqc111_tx_fixup,\n};\n\n#undef ASIX112_DESC\n\nstatic const struct driver_info trendnet_info = {\n\t.description\t= \"USB-C 3.1 to 5GBASE-T Ethernet Adapter\",\n\t.bind\t\t= aqc111_bind,\n\t.unbind\t\t= aqc111_unbind,\n\t.status\t\t= aqc111_status,\n\t.link_reset\t= aqc111_link_reset,\n\t.reset\t\t= aqc111_reset,\n\t.stop\t\t= aqc111_stop,\n\t.flags\t\t= FLAG_ETHER | FLAG_FRAMING_AX |\n\t\t\t  FLAG_AVOID_UNLINK_URBS | FLAG_MULTI_PACKET,\n\t.rx_fixup\t= aqc111_rx_fixup,\n\t.tx_fixup\t= aqc111_tx_fixup,\n};\n\nstatic const struct driver_info qnap_info = {\n\t.description\t= \"QNAP QNA-UC5G1T USB to 5GbE Adapter\",\n\t.bind\t\t= aqc111_bind,\n\t.unbind\t\t= aqc111_unbind,\n\t.status\t\t= aqc111_status,\n\t.link_reset\t= aqc111_link_reset,\n\t.reset\t\t= aqc111_reset,\n\t.stop\t\t= aqc111_stop,\n\t.flags\t\t= FLAG_ETHER | FLAG_FRAMING_AX |\n\t\t\t  FLAG_AVOID_UNLINK_URBS | FLAG_MULTI_PACKET,\n\t.rx_fixup\t= aqc111_rx_fixup,\n\t.tx_fixup\t= aqc111_tx_fixup,\n};\n\nstatic int aqc111_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\tu16 temp_rx_ctrl = 0x00;\n\tu16 reg16;\n\tu8 reg8;\n\n\tusbnet_suspend(intf, message);\n\n\taqc111_read16_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_RX_CTL, 2, &reg16);\n\ttemp_rx_ctrl = reg16;\n\t \n\treg16 &= ~SFR_RX_CTL_START;\n\taqc111_write16_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_RX_CTL, 2, &reg16);\n\t \n\taqc111_read16_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_PHYPWR_RSTCTL,\n\t\t\t       2, &reg16);\n\treg16 |= SFR_PHYPWR_RSTCTL_BZ;\n\taqc111_write16_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_PHYPWR_RSTCTL,\n\t\t\t\t2, &reg16);\n\n\treg8 = SFR_BULK_OUT_EFF_EN;\n\taqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_BULK_OUT_CTRL,\n\t\t\t      1, 1, &reg8);\n\n\ttemp_rx_ctrl &= ~(SFR_RX_CTL_START | SFR_RX_CTL_RF_WAK |\n\t\t\t  SFR_RX_CTL_AP | SFR_RX_CTL_AM);\n\taqc111_write16_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_RX_CTL,\n\t\t\t\t2, &temp_rx_ctrl);\n\n\treg8 = 0x00;\n\taqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_ETH_MAC_PATH,\n\t\t\t      1, 1, &reg8);\n\n\tif (aqc111_data->wol_flags) {\n\t\tstruct aqc111_wol_cfg wol_cfg;\n\n\t\tmemset(&wol_cfg, 0, sizeof(struct aqc111_wol_cfg));\n\n\t\taqc111_data->phy_cfg |= AQ_WOL;\n\t\tether_addr_copy(wol_cfg.hw_addr, dev->net->dev_addr);\n\t\twol_cfg.flags = aqc111_data->wol_flags;\n\n\t\ttemp_rx_ctrl |= (SFR_RX_CTL_AB | SFR_RX_CTL_START);\n\t\taqc111_write16_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_RX_CTL,\n\t\t\t\t\t2, &temp_rx_ctrl);\n\t\treg8 = 0x00;\n\t\taqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_BM_INT_MASK,\n\t\t\t\t      1, 1, &reg8);\n\t\treg8 = SFR_BMRX_DMA_EN;\n\t\taqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_BMRX_DMA_CONTROL,\n\t\t\t\t      1, 1, &reg8);\n\t\treg8 = SFR_RX_PATH_READY;\n\t\taqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_ETH_MAC_PATH,\n\t\t\t\t      1, 1, &reg8);\n\t\treg8 = 0x07;\n\t\taqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_RX_BULKIN_QCTRL,\n\t\t\t\t      1, 1, &reg8);\n\t\treg8 = 0x00;\n\t\taqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC,\n\t\t\t\t      SFR_RX_BULKIN_QTIMR_LOW, 1, 1, &reg8);\n\t\taqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC,\n\t\t\t\t      SFR_RX_BULKIN_QTIMR_HIGH, 1, 1, &reg8);\n\t\treg8 = 0xFF;\n\t\taqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_RX_BULKIN_QSIZE,\n\t\t\t\t      1, 1, &reg8);\n\t\taqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_RX_BULKIN_QIFG,\n\t\t\t\t      1, 1, &reg8);\n\n\t\taqc111_read16_cmd_nopm(dev, AQ_ACCESS_MAC,\n\t\t\t\t       SFR_MEDIUM_STATUS_MODE, 2, &reg16);\n\t\treg16 |= SFR_MEDIUM_RECEIVE_EN;\n\t\taqc111_write16_cmd_nopm(dev, AQ_ACCESS_MAC,\n\t\t\t\t\tSFR_MEDIUM_STATUS_MODE, 2, &reg16);\n\n\t\taqc111_write_cmd(dev, AQ_WOL_CFG, 0, 0,\n\t\t\t\t WOL_CFG_SIZE, &wol_cfg);\n\t\taqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0,\n\t\t\t\t   &aqc111_data->phy_cfg);\n\t} else {\n\t\taqc111_data->phy_cfg |= AQ_LOW_POWER;\n\t\taqc111_write32_cmd(dev, AQ_PHY_OPS, 0, 0,\n\t\t\t\t   &aqc111_data->phy_cfg);\n\n\t\t \n\t\taqc111_read16_cmd_nopm(dev, AQ_ACCESS_MAC,\n\t\t\t\t       SFR_MEDIUM_STATUS_MODE, 2, &reg16);\n\t\treg16 &= ~SFR_MEDIUM_RECEIVE_EN;\n\t\taqc111_write16_cmd_nopm(dev, AQ_ACCESS_MAC,\n\t\t\t\t\tSFR_MEDIUM_STATUS_MODE, 2, &reg16);\n\t}\n\n\treturn 0;\n}\n\nstatic int aqc111_resume(struct usb_interface *intf)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct aqc111_data *aqc111_data = dev->driver_priv;\n\tu16 reg16;\n\tu8 reg8;\n\n\tnetif_carrier_off(dev->net);\n\n\t \n\taqc111_data->phy_cfg |= AQ_PHY_POWER_EN;\n\taqc111_data->phy_cfg &= ~AQ_LOW_POWER;\n\taqc111_data->phy_cfg &= ~AQ_WOL;\n\n\treg8 = 0xFF;\n\taqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_BM_INT_MASK,\n\t\t\t      1, 1, &reg8);\n\t \n\treg16 = aqc111_data->rxctl;\n\treg16 &= ~SFR_RX_CTL_START;\n\taqc111_write16_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_RX_CTL, 2, &reg16);\n\n\treg16 |= SFR_RX_CTL_START;\n\taqc111_write16_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_RX_CTL, 2, &reg16);\n\n\taqc111_set_phy_speed(dev, aqc111_data->autoneg,\n\t\t\t     aqc111_data->advertised_speed);\n\n\taqc111_read16_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_MEDIUM_STATUS_MODE,\n\t\t\t       2, &reg16);\n\treg16 |= SFR_MEDIUM_RECEIVE_EN;\n\taqc111_write16_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_MEDIUM_STATUS_MODE,\n\t\t\t\t2, &reg16);\n\treg8 = SFR_RX_PATH_READY;\n\taqc111_write_cmd_nopm(dev, AQ_ACCESS_MAC, SFR_ETH_MAC_PATH,\n\t\t\t      1, 1, &reg8);\n\treg8 = 0x0;\n\taqc111_write_cmd(dev, AQ_ACCESS_MAC, SFR_BMRX_DMA_CONTROL, 1, 1, &reg8);\n\n\treturn usbnet_resume(intf);\n}\n\n#define AQC111_USB_ETH_DEV(vid, pid, table) \\\n\tUSB_DEVICE_INTERFACE_CLASS((vid), (pid), USB_CLASS_VENDOR_SPEC), \\\n\t.driver_info = (unsigned long)&(table) \\\n}, \\\n{ \\\n\tUSB_DEVICE_AND_INTERFACE_INFO((vid), (pid), \\\n\t\t\t\t      USB_CLASS_COMM, \\\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET, \\\n\t\t\t\t      USB_CDC_PROTO_NONE), \\\n\t.driver_info = (unsigned long)&(table),\n\nstatic const struct usb_device_id products[] = {\n\t{AQC111_USB_ETH_DEV(0x2eca, 0xc101, aqc111_info)},\n\t{AQC111_USB_ETH_DEV(0x0b95, 0x2790, asix111_info)},\n\t{AQC111_USB_ETH_DEV(0x0b95, 0x2791, asix112_info)},\n\t{AQC111_USB_ETH_DEV(0x20f4, 0xe05a, trendnet_info)},\n\t{AQC111_USB_ETH_DEV(0x1c04, 0x0015, qnap_info)},\n\t{ }, \n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver aq_driver = {\n\t.name\t\t= \"aqc111\",\n\t.id_table\t= products,\n\t.probe\t\t= usbnet_probe,\n\t.suspend\t= aqc111_suspend,\n\t.resume\t\t= aqc111_resume,\n\t.disconnect\t= usbnet_disconnect,\n};\n\nmodule_usb_driver(aq_driver);\n\nMODULE_DESCRIPTION(\"Aquantia AQtion USB to 5/2.5GbE Controllers\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}