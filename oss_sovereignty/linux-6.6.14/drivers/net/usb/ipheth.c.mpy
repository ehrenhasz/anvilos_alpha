{
  "module_name": "ipheth.c",
  "hash_id": "58fb38b1a8d0bfae3526fddc7ce286146a949f8924d1d057a961ffa15f2e1228",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/ipheth.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/usb.h>\n#include <linux/workqueue.h>\n#include <linux/usb/cdc.h>\n\n#define USB_VENDOR_APPLE        0x05ac\n\n#define IPHETH_USBINTF_CLASS    255\n#define IPHETH_USBINTF_SUBCLASS 253\n#define IPHETH_USBINTF_PROTO    1\n\n#define IPHETH_IP_ALIGN\t\t2\t \n#define IPHETH_NCM_HEADER_SIZE  (12 + 96)  \n#define IPHETH_TX_BUF_SIZE      ETH_FRAME_LEN\n#define IPHETH_RX_BUF_SIZE_LEGACY (IPHETH_IP_ALIGN + ETH_FRAME_LEN)\n#define IPHETH_RX_BUF_SIZE_NCM\t65536\n\n#define IPHETH_TX_TIMEOUT       (5 * HZ)\n\n#define IPHETH_INTFNUM          2\n#define IPHETH_ALT_INTFNUM      1\n\n#define IPHETH_CTRL_ENDP        0x00\n#define IPHETH_CTRL_BUF_SIZE    0x40\n#define IPHETH_CTRL_TIMEOUT     (5 * HZ)\n\n#define IPHETH_CMD_GET_MACADDR   0x00\n#define IPHETH_CMD_ENABLE_NCM    0x04\n#define IPHETH_CMD_CARRIER_CHECK 0x45\n\n#define IPHETH_CARRIER_CHECK_TIMEOUT round_jiffies_relative(1 * HZ)\n#define IPHETH_CARRIER_ON       0x04\n\nstatic const struct usb_device_id ipheth_table[] = {\n\t{ USB_VENDOR_AND_INTERFACE_INFO(USB_VENDOR_APPLE, IPHETH_USBINTF_CLASS,\n\t\t\t\t\tIPHETH_USBINTF_SUBCLASS,\n\t\t\t\t\tIPHETH_USBINTF_PROTO) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, ipheth_table);\n\nstruct ipheth_device {\n\tstruct usb_device *udev;\n\tstruct usb_interface *intf;\n\tstruct net_device *net;\n\tstruct urb *tx_urb;\n\tstruct urb *rx_urb;\n\tunsigned char *tx_buf;\n\tunsigned char *rx_buf;\n\tunsigned char *ctrl_buf;\n\tu8 bulk_in;\n\tu8 bulk_out;\n\tstruct delayed_work carrier_work;\n\tbool confirmed_pairing;\n\tint (*rcvbulk_callback)(struct urb *urb);\n\tsize_t rx_buf_len;\n};\n\nstatic int ipheth_rx_submit(struct ipheth_device *dev, gfp_t mem_flags);\n\nstatic int ipheth_alloc_urbs(struct ipheth_device *iphone)\n{\n\tstruct urb *tx_urb = NULL;\n\tstruct urb *rx_urb = NULL;\n\tu8 *tx_buf = NULL;\n\tu8 *rx_buf = NULL;\n\n\ttx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (tx_urb == NULL)\n\t\tgoto error_nomem;\n\n\trx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (rx_urb == NULL)\n\t\tgoto free_tx_urb;\n\n\ttx_buf = usb_alloc_coherent(iphone->udev, IPHETH_TX_BUF_SIZE,\n\t\t\t\t    GFP_KERNEL, &tx_urb->transfer_dma);\n\tif (tx_buf == NULL)\n\t\tgoto free_rx_urb;\n\n\trx_buf = usb_alloc_coherent(iphone->udev, iphone->rx_buf_len,\n\t\t\t\t    GFP_KERNEL, &rx_urb->transfer_dma);\n\tif (rx_buf == NULL)\n\t\tgoto free_tx_buf;\n\n\n\tiphone->tx_urb = tx_urb;\n\tiphone->rx_urb = rx_urb;\n\tiphone->tx_buf = tx_buf;\n\tiphone->rx_buf = rx_buf;\n\treturn 0;\n\nfree_tx_buf:\n\tusb_free_coherent(iphone->udev, IPHETH_TX_BUF_SIZE, tx_buf,\n\t\t\t  tx_urb->transfer_dma);\nfree_rx_urb:\n\tusb_free_urb(rx_urb);\nfree_tx_urb:\n\tusb_free_urb(tx_urb);\nerror_nomem:\n\treturn -ENOMEM;\n}\n\nstatic void ipheth_free_urbs(struct ipheth_device *iphone)\n{\n\tusb_free_coherent(iphone->udev, iphone->rx_buf_len, iphone->rx_buf,\n\t\t\t  iphone->rx_urb->transfer_dma);\n\tusb_free_coherent(iphone->udev, IPHETH_TX_BUF_SIZE, iphone->tx_buf,\n\t\t\t  iphone->tx_urb->transfer_dma);\n\tusb_free_urb(iphone->rx_urb);\n\tusb_free_urb(iphone->tx_urb);\n}\n\nstatic void ipheth_kill_urbs(struct ipheth_device *dev)\n{\n\tusb_kill_urb(dev->tx_urb);\n\tusb_kill_urb(dev->rx_urb);\n}\n\nstatic int ipheth_consume_skb(char *buf, int len, struct ipheth_device *dev)\n{\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t\tdev->net->stats.rx_dropped++;\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put_data(skb, buf, len);\n\tskb->dev = dev->net;\n\tskb->protocol = eth_type_trans(skb, dev->net);\n\n\tdev->net->stats.rx_packets++;\n\tdev->net->stats.rx_bytes += len;\n\tnetif_rx(skb);\n\n\treturn 0;\n}\n\nstatic int ipheth_rcvbulk_callback_legacy(struct urb *urb)\n{\n\tstruct ipheth_device *dev;\n\tchar *buf;\n\tint len;\n\n\tdev = urb->context;\n\n\tif (urb->actual_length <= IPHETH_IP_ALIGN) {\n\t\tdev->net->stats.rx_length_errors++;\n\t\treturn -EINVAL;\n\t}\n\tlen = urb->actual_length - IPHETH_IP_ALIGN;\n\tbuf = urb->transfer_buffer + IPHETH_IP_ALIGN;\n\n\treturn ipheth_consume_skb(buf, len, dev);\n}\n\nstatic int ipheth_rcvbulk_callback_ncm(struct urb *urb)\n{\n\tstruct usb_cdc_ncm_nth16 *ncmh;\n\tstruct usb_cdc_ncm_ndp16 *ncm0;\n\tstruct usb_cdc_ncm_dpe16 *dpe;\n\tstruct ipheth_device *dev;\n\tint retval = -EINVAL;\n\tchar *buf;\n\tint len;\n\n\tdev = urb->context;\n\n\tif (urb->actual_length < IPHETH_NCM_HEADER_SIZE) {\n\t\tdev->net->stats.rx_length_errors++;\n\t\treturn retval;\n\t}\n\n\tncmh = urb->transfer_buffer;\n\tif (ncmh->dwSignature != cpu_to_le32(USB_CDC_NCM_NTH16_SIGN) ||\n\t    le16_to_cpu(ncmh->wNdpIndex) >= urb->actual_length) {\n\t\tdev->net->stats.rx_errors++;\n\t\treturn retval;\n\t}\n\n\tncm0 = urb->transfer_buffer + le16_to_cpu(ncmh->wNdpIndex);\n\tif (ncm0->dwSignature != cpu_to_le32(USB_CDC_NCM_NDP16_NOCRC_SIGN) ||\n\t    le16_to_cpu(ncmh->wHeaderLength) + le16_to_cpu(ncm0->wLength) >=\n\t    urb->actual_length) {\n\t\tdev->net->stats.rx_errors++;\n\t\treturn retval;\n\t}\n\n\tdpe = ncm0->dpe16;\n\twhile (le16_to_cpu(dpe->wDatagramIndex) != 0 &&\n\t       le16_to_cpu(dpe->wDatagramLength) != 0) {\n\t\tif (le16_to_cpu(dpe->wDatagramIndex) >= urb->actual_length ||\n\t\t    le16_to_cpu(dpe->wDatagramIndex) +\n\t\t    le16_to_cpu(dpe->wDatagramLength) > urb->actual_length) {\n\t\t\tdev->net->stats.rx_length_errors++;\n\t\t\treturn retval;\n\t\t}\n\n\t\tbuf = urb->transfer_buffer + le16_to_cpu(dpe->wDatagramIndex);\n\t\tlen = le16_to_cpu(dpe->wDatagramLength);\n\n\t\tretval = ipheth_consume_skb(buf, len, dev);\n\t\tif (retval != 0)\n\t\t\treturn retval;\n\n\t\tdpe++;\n\t}\n\n\treturn 0;\n}\n\nstatic void ipheth_rcvbulk_callback(struct urb *urb)\n{\n\tstruct ipheth_device *dev;\n\tint retval, status;\n\n\tdev = urb->context;\n\tif (dev == NULL)\n\t\treturn;\n\n\tstatus = urb->status;\n\tswitch (status) {\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\tcase -EPROTO:\n\t\treturn;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->intf->dev, \"%s: urb status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\t}\n\n\tif (urb->actual_length <= IPHETH_IP_ALIGN) {\n\t\tdev->net->stats.rx_length_errors++;\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely\n\t\t(((char *)urb->transfer_buffer)[0] == 0 &&\n\t\t ((char *)urb->transfer_buffer)[1] == 1))\n\t\tgoto rx_submit;\n\n\tretval = dev->rcvbulk_callback(urb);\n\tif (retval != 0) {\n\t\tdev_err(&dev->intf->dev, \"%s: callback retval: %d\\n\",\n\t\t\t__func__, retval);\n\t\treturn;\n\t}\n\nrx_submit:\n\tdev->confirmed_pairing = true;\n\tipheth_rx_submit(dev, GFP_ATOMIC);\n}\n\nstatic void ipheth_sndbulk_callback(struct urb *urb)\n{\n\tstruct ipheth_device *dev;\n\tint status = urb->status;\n\n\tdev = urb->context;\n\tif (dev == NULL)\n\t\treturn;\n\n\tif (status != 0 &&\n\t    status != -ENOENT &&\n\t    status != -ECONNRESET &&\n\t    status != -ESHUTDOWN)\n\t\tdev_err(&dev->intf->dev, \"%s: urb status: %d\\n\",\n\t\t__func__, status);\n\n\tif (status == 0)\n\t\tnetif_wake_queue(dev->net);\n\telse\n\t\t\n\t\tschedule_delayed_work(&dev->carrier_work, 0);\n}\n\nstatic int ipheth_carrier_set(struct ipheth_device *dev)\n{\n\tstruct usb_device *udev;\n\tint retval;\n\n\tif (!dev->confirmed_pairing)\n\t\treturn 0;\n\n\tudev = dev->udev;\n\tretval = usb_control_msg(udev,\n\t\t\tusb_rcvctrlpipe(udev, IPHETH_CTRL_ENDP),\n\t\t\tIPHETH_CMD_CARRIER_CHECK,  \n\t\t\t0xc0,  \n\t\t\t0x00,  \n\t\t\t0x02,  \n\t\t\tdev->ctrl_buf, IPHETH_CTRL_BUF_SIZE,\n\t\t\tIPHETH_CTRL_TIMEOUT);\n\tif (retval < 0) {\n\t\tdev_err(&dev->intf->dev, \"%s: usb_control_msg: %d\\n\",\n\t\t\t__func__, retval);\n\t\treturn retval;\n\t}\n\n\tif (dev->ctrl_buf[0] == IPHETH_CARRIER_ON) {\n\t\tnetif_carrier_on(dev->net);\n\t\tif (dev->tx_urb->status != -EINPROGRESS)\n\t\t\tnetif_wake_queue(dev->net);\n\t} else {\n\t\tnetif_carrier_off(dev->net);\n\t\tnetif_stop_queue(dev->net);\n\t}\n\treturn 0;\n}\n\nstatic void ipheth_carrier_check_work(struct work_struct *work)\n{\n\tstruct ipheth_device *dev = container_of(work, struct ipheth_device,\n\t\t\t\t\t\t carrier_work.work);\n\n\tipheth_carrier_set(dev);\n\tschedule_delayed_work(&dev->carrier_work, IPHETH_CARRIER_CHECK_TIMEOUT);\n}\n\nstatic int ipheth_get_macaddr(struct ipheth_device *dev)\n{\n\tstruct usb_device *udev = dev->udev;\n\tstruct net_device *net = dev->net;\n\tint retval;\n\n\tretval = usb_control_msg(udev,\n\t\t\t\t usb_rcvctrlpipe(udev, IPHETH_CTRL_ENDP),\n\t\t\t\t IPHETH_CMD_GET_MACADDR,  \n\t\t\t\t 0xc0,  \n\t\t\t\t 0x00,  \n\t\t\t\t 0x02,  \n\t\t\t\t dev->ctrl_buf,\n\t\t\t\t IPHETH_CTRL_BUF_SIZE,\n\t\t\t\t IPHETH_CTRL_TIMEOUT);\n\tif (retval < 0) {\n\t\tdev_err(&dev->intf->dev, \"%s: usb_control_msg: %d\\n\",\n\t\t\t__func__, retval);\n\t} else if (retval < ETH_ALEN) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"%s: usb_control_msg: short packet: %d bytes\\n\",\n\t\t\t__func__, retval);\n\t\tretval = -EINVAL;\n\t} else {\n\t\teth_hw_addr_set(net, dev->ctrl_buf);\n\t\tretval = 0;\n\t}\n\n\treturn retval;\n}\n\nstatic int ipheth_enable_ncm(struct ipheth_device *dev)\n{\n\tstruct usb_device *udev = dev->udev;\n\tint retval;\n\n\tretval = usb_control_msg(udev,\n\t\t\t\t usb_sndctrlpipe(udev, IPHETH_CTRL_ENDP),\n\t\t\t\t IPHETH_CMD_ENABLE_NCM,  \n\t\t\t\t 0x41,  \n\t\t\t\t 0x00,  \n\t\t\t\t 0x02,  \n\t\t\t\t NULL,\n\t\t\t\t 0,\n\t\t\t\t IPHETH_CTRL_TIMEOUT);\n\n\tdev_info(&dev->intf->dev, \"%s: usb_control_msg: %d\\n\",\n\t\t __func__, retval);\n\n\treturn retval;\n}\n\nstatic int ipheth_rx_submit(struct ipheth_device *dev, gfp_t mem_flags)\n{\n\tstruct usb_device *udev = dev->udev;\n\tint retval;\n\n\tusb_fill_bulk_urb(dev->rx_urb, udev,\n\t\t\t  usb_rcvbulkpipe(udev, dev->bulk_in),\n\t\t\t  dev->rx_buf, dev->rx_buf_len,\n\t\t\t  ipheth_rcvbulk_callback,\n\t\t\t  dev);\n\tdev->rx_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tretval = usb_submit_urb(dev->rx_urb, mem_flags);\n\tif (retval)\n\t\tdev_err(&dev->intf->dev, \"%s: usb_submit_urb: %d\\n\",\n\t\t\t__func__, retval);\n\treturn retval;\n}\n\nstatic int ipheth_open(struct net_device *net)\n{\n\tstruct ipheth_device *dev = netdev_priv(net);\n\tstruct usb_device *udev = dev->udev;\n\tint retval = 0;\n\n\tusb_set_interface(udev, IPHETH_INTFNUM, IPHETH_ALT_INTFNUM);\n\n\tretval = ipheth_carrier_set(dev);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = ipheth_rx_submit(dev, GFP_KERNEL);\n\tif (retval)\n\t\treturn retval;\n\n\tschedule_delayed_work(&dev->carrier_work, IPHETH_CARRIER_CHECK_TIMEOUT);\n\treturn retval;\n}\n\nstatic int ipheth_close(struct net_device *net)\n{\n\tstruct ipheth_device *dev = netdev_priv(net);\n\n\tcancel_delayed_work_sync(&dev->carrier_work);\n\tnetif_stop_queue(net);\n\treturn 0;\n}\n\nstatic netdev_tx_t ipheth_tx(struct sk_buff *skb, struct net_device *net)\n{\n\tstruct ipheth_device *dev = netdev_priv(net);\n\tstruct usb_device *udev = dev->udev;\n\tint retval;\n\n\t \n\tif (skb->len > IPHETH_TX_BUF_SIZE) {\n\t\tWARN(1, \"%s: skb too large: %d bytes\\n\", __func__, skb->len);\n\t\tdev->net->stats.tx_dropped++;\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tmemcpy(dev->tx_buf, skb->data, skb->len);\n\n\tusb_fill_bulk_urb(dev->tx_urb, udev,\n\t\t\t  usb_sndbulkpipe(udev, dev->bulk_out),\n\t\t\t  dev->tx_buf, skb->len,\n\t\t\t  ipheth_sndbulk_callback,\n\t\t\t  dev);\n\tdev->tx_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tnetif_stop_queue(net);\n\tretval = usb_submit_urb(dev->tx_urb, GFP_ATOMIC);\n\tif (retval) {\n\t\tdev_err(&dev->intf->dev, \"%s: usb_submit_urb: %d\\n\",\n\t\t\t__func__, retval);\n\t\tdev->net->stats.tx_errors++;\n\t\tdev_kfree_skb_any(skb);\n\t\tnetif_wake_queue(net);\n\t} else {\n\t\tdev->net->stats.tx_packets++;\n\t\tdev->net->stats.tx_bytes += skb->len;\n\t\tdev_consume_skb_any(skb);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ipheth_tx_timeout(struct net_device *net, unsigned int txqueue)\n{\n\tstruct ipheth_device *dev = netdev_priv(net);\n\n\tdev_err(&dev->intf->dev, \"%s: TX timeout\\n\", __func__);\n\tdev->net->stats.tx_errors++;\n\tusb_unlink_urb(dev->tx_urb);\n}\n\nstatic u32 ipheth_ethtool_op_get_link(struct net_device *net)\n{\n\tstruct ipheth_device *dev = netdev_priv(net);\n\treturn netif_carrier_ok(dev->net);\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_link = ipheth_ethtool_op_get_link\n};\n\nstatic const struct net_device_ops ipheth_netdev_ops = {\n\t.ndo_open = ipheth_open,\n\t.ndo_stop = ipheth_close,\n\t.ndo_start_xmit = ipheth_tx,\n\t.ndo_tx_timeout = ipheth_tx_timeout,\n};\n\nstatic int ipheth_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_host_interface *hintf;\n\tstruct usb_endpoint_descriptor *endp;\n\tstruct ipheth_device *dev;\n\tstruct net_device *netdev;\n\tint i;\n\tint retval;\n\n\tnetdev = alloc_etherdev(sizeof(struct ipheth_device));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tnetdev->netdev_ops = &ipheth_netdev_ops;\n\tnetdev->watchdog_timeo = IPHETH_TX_TIMEOUT;\n\tstrscpy(netdev->name, \"eth%d\", sizeof(netdev->name));\n\n\tdev = netdev_priv(netdev);\n\tdev->udev = udev;\n\tdev->net = netdev;\n\tdev->intf = intf;\n\tdev->confirmed_pairing = false;\n\tdev->rx_buf_len = IPHETH_RX_BUF_SIZE_LEGACY;\n\tdev->rcvbulk_callback = ipheth_rcvbulk_callback_legacy;\n\t \n\thintf = usb_altnum_to_altsetting(intf, IPHETH_ALT_INTFNUM);\n\tif (hintf == NULL) {\n\t\tretval = -ENODEV;\n\t\tdev_err(&intf->dev, \"Unable to find alternate settings interface\\n\");\n\t\tgoto err_endpoints;\n\t}\n\n\tfor (i = 0; i < hintf->desc.bNumEndpoints; i++) {\n\t\tendp = &hintf->endpoint[i].desc;\n\t\tif (usb_endpoint_is_bulk_in(endp))\n\t\t\tdev->bulk_in = endp->bEndpointAddress;\n\t\telse if (usb_endpoint_is_bulk_out(endp))\n\t\t\tdev->bulk_out = endp->bEndpointAddress;\n\t}\n\tif (!(dev->bulk_in && dev->bulk_out)) {\n\t\tretval = -ENODEV;\n\t\tdev_err(&intf->dev, \"Unable to find endpoints\\n\");\n\t\tgoto err_endpoints;\n\t}\n\n\tdev->ctrl_buf = kmalloc(IPHETH_CTRL_BUF_SIZE, GFP_KERNEL);\n\tif (dev->ctrl_buf == NULL) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_alloc_ctrl_buf;\n\t}\n\n\tretval = ipheth_get_macaddr(dev);\n\tif (retval)\n\t\tgoto err_get_macaddr;\n\n\tretval = ipheth_enable_ncm(dev);\n\tif (!retval) {\n\t\tdev->rx_buf_len = IPHETH_RX_BUF_SIZE_NCM;\n\t\tdev->rcvbulk_callback = ipheth_rcvbulk_callback_ncm;\n\t}\n\n\tINIT_DELAYED_WORK(&dev->carrier_work, ipheth_carrier_check_work);\n\n\tretval = ipheth_alloc_urbs(dev);\n\tif (retval) {\n\t\tdev_err(&intf->dev, \"error allocating urbs: %d\\n\", retval);\n\t\tgoto err_alloc_urbs;\n\t}\n\n\tusb_set_intfdata(intf, dev);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tnetdev->ethtool_ops = &ops;\n\n\tretval = register_netdev(netdev);\n\tif (retval) {\n\t\tdev_err(&intf->dev, \"error registering netdev: %d\\n\", retval);\n\t\tretval = -EIO;\n\t\tgoto err_register_netdev;\n\t}\n\t\n\tnetif_carrier_off(netdev);\n\tnetif_tx_stop_all_queues(netdev);\n\tdev_info(&intf->dev, \"Apple iPhone USB Ethernet device attached\\n\");\n\treturn 0;\n\nerr_register_netdev:\n\tipheth_free_urbs(dev);\nerr_alloc_urbs:\nerr_get_macaddr:\n\tkfree(dev->ctrl_buf);\nerr_alloc_ctrl_buf:\nerr_endpoints:\n\tfree_netdev(netdev);\n\treturn retval;\n}\n\nstatic void ipheth_disconnect(struct usb_interface *intf)\n{\n\tstruct ipheth_device *dev;\n\n\tdev = usb_get_intfdata(intf);\n\tif (dev != NULL) {\n\t\tunregister_netdev(dev->net);\n\t\tipheth_kill_urbs(dev);\n\t\tipheth_free_urbs(dev);\n\t\tkfree(dev->ctrl_buf);\n\t\tfree_netdev(dev->net);\n\t}\n\tusb_set_intfdata(intf, NULL);\n\tdev_info(&intf->dev, \"Apple iPhone USB Ethernet now disconnected\\n\");\n}\n\nstatic struct usb_driver ipheth_driver = {\n\t.name =\t\t\"ipheth\",\n\t.probe =\tipheth_probe,\n\t.disconnect =\tipheth_disconnect,\n\t.id_table =\tipheth_table,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(ipheth_driver);\n\nMODULE_AUTHOR(\"Diego Giagio <diego@giagio.com>\");\nMODULE_DESCRIPTION(\"Apple iPhone USB Ethernet driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}