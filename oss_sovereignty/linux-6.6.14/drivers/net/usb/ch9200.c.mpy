{
  "module_name": "ch9200.c",
  "hash_id": "24c9cef46276cb0f4dd01bcd999ab0eb7080bb2bd9fd0f8ffee7befb527d8dc2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/ch9200.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/stddef.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/crc32.h>\n#include <linux/usb/usbnet.h>\n#include <linux/slab.h>\n\n#define CH9200_VID\t\t0x1A86\n#define CH9200_PID_E092\t\t0xE092\n\n#define CTRL_TIMEOUT_MS\t\t1000\n\n#define CONTROL_TIMEOUT_MS 1000\n\n#define REQUEST_READ\t0x0E\n#define REQUEST_WRITE\t0x0F\n\n \n\n#define MAC_REG_CTRL 64\n#define MAC_REG_STATUS 66\n#define MAC_REG_INTERRUPT_MASK 68\n#define MAC_REG_PHY_COMMAND 70\n#define MAC_REG_PHY_DATA 72\n#define MAC_REG_STATION_L 74\n#define MAC_REG_STATION_M 76\n#define MAC_REG_STATION_H 78\n#define MAC_REG_HASH_L 80\n#define MAC_REG_HASH_M1 82\n#define MAC_REG_HASH_M2 84\n#define MAC_REG_HASH_H 86\n#define MAC_REG_THRESHOLD 88\n#define MAC_REG_FIFO_DEPTH 90\n#define MAC_REG_PAUSE 92\n#define MAC_REG_FLOW_CONTROL 94\n\n \n#define LOOPBACK\t\t(0x01 << 14)\n#define BASE100X\t\t(0x01 << 12)\n#define MBPS_10\t\t\t(0x01 << 11)\n#define DUPLEX_MODE\t\t(0x01 << 10)\n#define PAUSE_FRAME\t\t(0x01 << 9)\n#define PROMISCUOUS\t\t(0x01 << 8)\n#define MULTICAST\t\t(0x01 << 7)\n#define BROADCAST\t\t(0x01 << 6)\n#define HASH\t\t\t(0x01 << 5)\n#define APPEND_PAD\t\t(0x01 << 4)\n#define APPEND_CRC\t\t(0x01 << 3)\n#define TRANSMITTER_ACTION\t(0x01 << 2)\n#define RECEIVER_ACTION\t\t(0x01 << 1)\n#define DMA_ACTION\t\t(0x01 << 0)\n\n \n#define ALIGNMENT\t\t(0x01 << 6)\n#define FIFO_OVER_RUN\t\t(0x01 << 5)\n#define FIFO_UNDER_RUN\t\t(0x01 << 4)\n#define RX_ERROR\t\t(0x01 << 3)\n#define RX_COMPLETE\t\t(0x01 << 2)\n#define TX_ERROR\t\t(0x01 << 1)\n#define TX_COMPLETE\t\t(0x01 << 0)\n\n \n\n#define ETH_TXBD\t\t(0x01 << 15)\n#define ETN_TX_FIFO_DEPTH\t(0x01 << 8)\n#define ETH_RXBD\t\t(0x01 << 7)\n#define ETH_RX_FIFO_DEPTH\t(0x01 << 0)\n\nstatic int control_read(struct usbnet *dev,\n\t\t\tunsigned char request, unsigned short value,\n\t\t\tunsigned short index, void *data, unsigned short size,\n\t\t\tint timeout)\n{\n\tunsigned char *buf = NULL;\n\tunsigned char request_type;\n\tint err = 0;\n\n\tif (request == REQUEST_READ)\n\t\trequest_type = (USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_OTHER);\n\telse\n\t\trequest_type = (USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t\tUSB_RECIP_DEVICE);\n\n\tnetdev_dbg(dev->net, \"%s() index=0x%02x size=%d\\n\",\n\t\t   __func__, index, size);\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\terr = usb_control_msg(dev->udev,\n\t\t\t      usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t      request, request_type, value, index, buf, size,\n\t\t\t      timeout);\n\tif (err == size)\n\t\tmemcpy(data, buf, size);\n\telse if (err >= 0)\n\t\terr = -EINVAL;\n\tkfree(buf);\n\nerr_out:\n\treturn err;\n}\n\nstatic int control_write(struct usbnet *dev, unsigned char request,\n\t\t\t unsigned short value, unsigned short index,\n\t\t\t void *data, unsigned short size, int timeout)\n{\n\tunsigned char *buf = NULL;\n\tunsigned char request_type;\n\tint err = 0;\n\n\tif (request == REQUEST_WRITE)\n\t\trequest_type = (USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\tUSB_RECIP_OTHER);\n\telse\n\t\trequest_type = (USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\tUSB_RECIP_DEVICE);\n\n\tnetdev_dbg(dev->net, \"%s() index=0x%02x size=%d\\n\",\n\t\t   __func__, index, size);\n\n\tif (data) {\n\t\tbuf = kmemdup(data, size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\terr = usb_control_msg(dev->udev,\n\t\t\t      usb_sndctrlpipe(dev->udev, 0),\n\t\t\t      request, request_type, value, index, buf, size,\n\t\t\t      timeout);\n\tif (err >= 0 && err < size)\n\t\terr = -EINVAL;\n\tkfree(buf);\n\n\treturn 0;\n\nerr_out:\n\treturn err;\n}\n\nstatic int ch9200_mdio_read(struct net_device *netdev, int phy_id, int loc)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tunsigned char buff[2];\n\n\tnetdev_dbg(netdev, \"%s phy_id:%02x loc:%02x\\n\",\n\t\t   __func__, phy_id, loc);\n\n\tif (phy_id != 0)\n\t\treturn -ENODEV;\n\n\tcontrol_read(dev, REQUEST_READ, 0, loc * 2, buff, 0x02,\n\t\t     CONTROL_TIMEOUT_MS);\n\n\treturn (buff[0] | buff[1] << 8);\n}\n\nstatic void ch9200_mdio_write(struct net_device *netdev,\n\t\t\t      int phy_id, int loc, int val)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tunsigned char buff[2];\n\n\tnetdev_dbg(netdev, \"%s() phy_id=%02x loc:%02x\\n\",\n\t\t   __func__, phy_id, loc);\n\n\tif (phy_id != 0)\n\t\treturn;\n\n\tbuff[0] = (unsigned char)val;\n\tbuff[1] = (unsigned char)(val >> 8);\n\n\tcontrol_write(dev, REQUEST_WRITE, 0, loc * 2, buff, 0x02,\n\t\t      CONTROL_TIMEOUT_MS);\n}\n\nstatic int ch9200_link_reset(struct usbnet *dev)\n{\n\tstruct ethtool_cmd ecmd;\n\n\tmii_check_media(&dev->mii, 1, 1);\n\tmii_ethtool_gset(&dev->mii, &ecmd);\n\n\tnetdev_dbg(dev->net, \"%s() speed:%d duplex:%d\\n\",\n\t\t   __func__, ecmd.speed, ecmd.duplex);\n\n\treturn 0;\n}\n\nstatic void ch9200_status(struct usbnet *dev, struct urb *urb)\n{\n\tint link;\n\tunsigned char *buf;\n\n\tif (urb->actual_length < 16)\n\t\treturn;\n\n\tbuf = urb->transfer_buffer;\n\tlink = !!(buf[0] & 0x01);\n\n\tif (link) {\n\t\tnetif_carrier_on(dev->net);\n\t\tusbnet_defer_kevent(dev, EVENT_LINK_RESET);\n\t} else {\n\t\tnetif_carrier_off(dev->net);\n\t}\n}\n\nstatic struct sk_buff *ch9200_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\n\t\t\t\t       gfp_t flags)\n{\n\tint i = 0;\n\tint len = 0;\n\tint tx_overhead = 0;\n\n\ttx_overhead = 0x40;\n\n\tlen = skb->len;\n\tif (skb_cow_head(skb, tx_overhead)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NULL;\n\t}\n\n\t__skb_push(skb, tx_overhead);\n\t \n\tif ((skb->len % dev->maxpacket) == 0)\n\t\tlen++;\n\n\tskb->data[0] = len;\n\tskb->data[1] = len >> 8;\n\tskb->data[2] = 0x00;\n\tskb->data[3] = 0x80;\n\n\tfor (i = 4; i < 48; i++)\n\t\tskb->data[i] = 0x00;\n\n\tskb->data[48] = len;\n\tskb->data[49] = len >> 8;\n\tskb->data[50] = 0x00;\n\tskb->data[51] = 0x80;\n\n\tfor (i = 52; i < 64; i++)\n\t\tskb->data[i] = 0x00;\n\n\treturn skb;\n}\n\nstatic int ch9200_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tint len = 0;\n\tint rx_overhead = 0;\n\n\trx_overhead = 64;\n\n\tif (unlikely(skb->len < rx_overhead)) {\n\t\tdev_err(&dev->udev->dev, \"unexpected tiny rx frame\\n\");\n\t\treturn 0;\n\t}\n\n\tlen = (skb->data[skb->len - 16] | skb->data[skb->len - 15] << 8);\n\tskb_trim(skb, len);\n\n\treturn 1;\n}\n\nstatic int get_mac_address(struct usbnet *dev, unsigned char *data)\n{\n\tint err = 0;\n\tunsigned char mac_addr[0x06];\n\tint rd_mac_len = 0;\n\n\tnetdev_dbg(dev->net, \"%s:\\n\\tusbnet VID:%0x PID:%0x\\n\", __func__,\n\t\t   le16_to_cpu(dev->udev->descriptor.idVendor),\n\t\t   le16_to_cpu(dev->udev->descriptor.idProduct));\n\n\tmemset(mac_addr, 0, sizeof(mac_addr));\n\trd_mac_len = control_read(dev, REQUEST_READ, 0,\n\t\t\t\t  MAC_REG_STATION_L, mac_addr, 0x02,\n\t\t\t\t  CONTROL_TIMEOUT_MS);\n\trd_mac_len += control_read(dev, REQUEST_READ, 0, MAC_REG_STATION_M,\n\t\t\t\t   mac_addr + 2, 0x02, CONTROL_TIMEOUT_MS);\n\trd_mac_len += control_read(dev, REQUEST_READ, 0, MAC_REG_STATION_H,\n\t\t\t\t   mac_addr + 4, 0x02, CONTROL_TIMEOUT_MS);\n\tif (rd_mac_len != ETH_ALEN)\n\t\terr = -EINVAL;\n\n\tdata[0] = mac_addr[5];\n\tdata[1] = mac_addr[4];\n\tdata[2] = mac_addr[3];\n\tdata[3] = mac_addr[2];\n\tdata[4] = mac_addr[1];\n\tdata[5] = mac_addr[0];\n\n\treturn err;\n}\n\nstatic int ch9200_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint retval = 0;\n\tunsigned char data[2];\n\tu8 addr[ETH_ALEN];\n\n\tretval = usbnet_get_endpoints(dev, intf);\n\tif (retval)\n\t\treturn retval;\n\n\tdev->mii.dev = dev->net;\n\tdev->mii.mdio_read = ch9200_mdio_read;\n\tdev->mii.mdio_write = ch9200_mdio_write;\n\tdev->mii.reg_num_mask = 0x1f;\n\n\tdev->mii.phy_id_mask = 0x1f;\n\n\tdev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\n\tdev->rx_urb_size = 24 * 64 + 16;\n\tmii_nway_restart(&dev->mii);\n\n\tdata[0] = 0x01;\n\tdata[1] = 0x0F;\n\tretval = control_write(dev, REQUEST_WRITE, 0, MAC_REG_THRESHOLD, data,\n\t\t\t       0x02, CONTROL_TIMEOUT_MS);\n\n\tdata[0] = 0xA0;\n\tdata[1] = 0x90;\n\tretval = control_write(dev, REQUEST_WRITE, 0, MAC_REG_FIFO_DEPTH, data,\n\t\t\t       0x02, CONTROL_TIMEOUT_MS);\n\n\tdata[0] = 0x30;\n\tdata[1] = 0x00;\n\tretval = control_write(dev, REQUEST_WRITE, 0, MAC_REG_PAUSE, data,\n\t\t\t       0x02, CONTROL_TIMEOUT_MS);\n\n\tdata[0] = 0x17;\n\tdata[1] = 0xD8;\n\tretval = control_write(dev, REQUEST_WRITE, 0, MAC_REG_FLOW_CONTROL,\n\t\t\t       data, 0x02, CONTROL_TIMEOUT_MS);\n\n\t \n\tdata[0] = 0x01;\n\tdata[1] = 0x00;\n\tretval = control_write(dev, REQUEST_WRITE, 0, 254, data, 0x02,\n\t\t\t       CONTROL_TIMEOUT_MS);\n\n\tdata[0] = 0x5F;\n\tdata[1] = 0x0D;\n\tretval = control_write(dev, REQUEST_WRITE, 0, MAC_REG_CTRL, data, 0x02,\n\t\t\t       CONTROL_TIMEOUT_MS);\n\n\tretval = get_mac_address(dev, addr);\n\teth_hw_addr_set(dev->net, addr);\n\n\treturn retval;\n}\n\nstatic const struct driver_info ch9200_info = {\n\t.description = \"CH9200 USB to Network Adaptor\",\n\t.flags = FLAG_ETHER,\n\t.bind = ch9200_bind,\n\t.rx_fixup = ch9200_rx_fixup,\n\t.tx_fixup = ch9200_tx_fixup,\n\t.status = ch9200_status,\n\t.link_reset = ch9200_link_reset,\n\t.reset = ch9200_link_reset,\n};\n\nstatic const struct usb_device_id ch9200_products[] = {\n\t{\n\t USB_DEVICE(0x1A86, 0xE092),\n\t .driver_info = (unsigned long)&ch9200_info,\n\t },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(usb, ch9200_products);\n\nstatic struct usb_driver ch9200_driver = {\n\t.name = \"ch9200\",\n\t.id_table = ch9200_products,\n\t.probe = usbnet_probe,\n\t.disconnect = usbnet_disconnect,\n\t.suspend = usbnet_suspend,\n\t.resume = usbnet_resume,\n};\n\nmodule_usb_driver(ch9200_driver);\n\nMODULE_DESCRIPTION(\"QinHeng CH9200 USB Network device\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}