{
  "module_name": "cdc-phonet.c",
  "hash_id": "4c974fba219884456ef15c913b2f873ef0c98f46a38d56005effb34a020f71cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/cdc-phonet.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/if_phonet.h>\n#include <linux/phonet.h>\n\n#define PN_MEDIA_USB\t0x1B\n\nstatic const unsigned rxq_size = 17;\n\nstruct usbpn_dev {\n\tstruct net_device\t*dev;\n\n\tstruct usb_interface\t*intf, *data_intf;\n\tstruct usb_device\t*usb;\n\tunsigned int\t\ttx_pipe, rx_pipe;\n\tu8 active_setting;\n\tu8 disconnected;\n\n\tunsigned\t\ttx_queue;\n\tspinlock_t\t\ttx_lock;\n\n\tspinlock_t\t\trx_lock;\n\tstruct sk_buff\t\t*rx_skb;\n\tstruct urb\t\t*urbs[];\n};\n\nstatic void tx_complete(struct urb *req);\nstatic void rx_complete(struct urb *req);\n\n \nstatic netdev_tx_t usbpn_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct usbpn_dev *pnd = netdev_priv(dev);\n\tstruct urb *req = NULL;\n\tunsigned long flags;\n\tint err;\n\n\tif (skb->protocol != htons(ETH_P_PHONET))\n\t\tgoto drop;\n\n\treq = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!req)\n\t\tgoto drop;\n\tusb_fill_bulk_urb(req, pnd->usb, pnd->tx_pipe, skb->data, skb->len,\n\t\t\t\ttx_complete, skb);\n\treq->transfer_flags = URB_ZERO_PACKET;\n\terr = usb_submit_urb(req, GFP_ATOMIC);\n\tif (err) {\n\t\tusb_free_urb(req);\n\t\tgoto drop;\n\t}\n\n\tspin_lock_irqsave(&pnd->tx_lock, flags);\n\tpnd->tx_queue++;\n\tif (pnd->tx_queue >= dev->tx_queue_len)\n\t\tnetif_stop_queue(dev);\n\tspin_unlock_irqrestore(&pnd->tx_lock, flags);\n\treturn NETDEV_TX_OK;\n\ndrop:\n\tdev_kfree_skb(skb);\n\tdev->stats.tx_dropped++;\n\treturn NETDEV_TX_OK;\n}\n\nstatic void tx_complete(struct urb *req)\n{\n\tstruct sk_buff *skb = req->context;\n\tstruct net_device *dev = skb->dev;\n\tstruct usbpn_dev *pnd = netdev_priv(dev);\n\tint status = req->status;\n\tunsigned long flags;\n\n\tswitch (status) {\n\tcase 0:\n\t\tdev->stats.tx_bytes += skb->len;\n\t\tbreak;\n\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tdev->stats.tx_aborted_errors++;\n\t\tfallthrough;\n\tdefault:\n\t\tdev->stats.tx_errors++;\n\t\tdev_dbg(&dev->dev, \"TX error (%d)\\n\", status);\n\t}\n\tdev->stats.tx_packets++;\n\n\tspin_lock_irqsave(&pnd->tx_lock, flags);\n\tpnd->tx_queue--;\n\tnetif_wake_queue(dev);\n\tspin_unlock_irqrestore(&pnd->tx_lock, flags);\n\n\tdev_kfree_skb_any(skb);\n\tusb_free_urb(req);\n}\n\nstatic int rx_submit(struct usbpn_dev *pnd, struct urb *req, gfp_t gfp_flags)\n{\n\tstruct net_device *dev = pnd->dev;\n\tstruct page *page;\n\tint err;\n\n\tpage = __dev_alloc_page(gfp_flags | __GFP_NOMEMALLOC);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tusb_fill_bulk_urb(req, pnd->usb, pnd->rx_pipe, page_address(page),\n\t\t\t\tPAGE_SIZE, rx_complete, dev);\n\treq->transfer_flags = 0;\n\terr = usb_submit_urb(req, gfp_flags);\n\tif (unlikely(err)) {\n\t\tdev_dbg(&dev->dev, \"RX submit error (%d)\\n\", err);\n\t\tput_page(page);\n\t}\n\treturn err;\n}\n\nstatic void rx_complete(struct urb *req)\n{\n\tstruct net_device *dev = req->context;\n\tstruct usbpn_dev *pnd = netdev_priv(dev);\n\tstruct page *page = virt_to_page(req->transfer_buffer);\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tint status = req->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\tspin_lock_irqsave(&pnd->rx_lock, flags);\n\t\tskb = pnd->rx_skb;\n\t\tif (!skb) {\n\t\t\tskb = pnd->rx_skb = netdev_alloc_skb(dev, 12);\n\t\t\tif (likely(skb)) {\n\t\t\t\t \n\t\t\t\tskb_put_data(skb, page_address(page), 1);\n\t\t\t\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags,\n\t\t\t\t\t\tpage, 1, req->actual_length,\n\t\t\t\t\t\tPAGE_SIZE);\n\t\t\t\tpage = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags,\n\t\t\t\t\tpage, 0, req->actual_length,\n\t\t\t\t\tPAGE_SIZE);\n\t\t\tpage = NULL;\n\t\t}\n\t\tif (req->actual_length < PAGE_SIZE)\n\t\t\tpnd->rx_skb = NULL;  \n\t\telse\n\t\t\tskb = NULL;\n\t\tspin_unlock_irqrestore(&pnd->rx_lock, flags);\n\t\tif (skb) {\n\t\t\tskb->protocol = htons(ETH_P_PHONET);\n\t\t\tskb_reset_mac_header(skb);\n\t\t\t__skb_pull(skb, 1);\n\t\t\tskb->dev = dev;\n\t\t\tdev->stats.rx_packets++;\n\t\t\tdev->stats.rx_bytes += skb->len;\n\n\t\t\tnetif_rx(skb);\n\t\t}\n\t\tgoto resubmit;\n\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\treq = NULL;\n\t\tbreak;\n\n\tcase -EOVERFLOW:\n\t\tdev->stats.rx_over_errors++;\n\t\tdev_dbg(&dev->dev, \"RX overflow\\n\");\n\t\tbreak;\n\n\tcase -EILSEQ:\n\t\tdev->stats.rx_crc_errors++;\n\t\tbreak;\n\t}\n\n\tdev->stats.rx_errors++;\nresubmit:\n\tif (page)\n\t\tput_page(page);\n\tif (req)\n\t\trx_submit(pnd, req, GFP_ATOMIC);\n}\n\nstatic int usbpn_close(struct net_device *dev);\n\nstatic int usbpn_open(struct net_device *dev)\n{\n\tstruct usbpn_dev *pnd = netdev_priv(dev);\n\tint err;\n\tunsigned i;\n\tunsigned num = pnd->data_intf->cur_altsetting->desc.bInterfaceNumber;\n\n\terr = usb_set_interface(pnd->usb, num, pnd->active_setting);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < rxq_size; i++) {\n\t\tstruct urb *req = usb_alloc_urb(0, GFP_KERNEL);\n\n\t\tif (!req || rx_submit(pnd, req, GFP_KERNEL)) {\n\t\t\tusb_free_urb(req);\n\t\t\tusbpn_close(dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpnd->urbs[i] = req;\n\t}\n\n\tnetif_wake_queue(dev);\n\treturn 0;\n}\n\nstatic int usbpn_close(struct net_device *dev)\n{\n\tstruct usbpn_dev *pnd = netdev_priv(dev);\n\tunsigned i;\n\tunsigned num = pnd->data_intf->cur_altsetting->desc.bInterfaceNumber;\n\n\tnetif_stop_queue(dev);\n\n\tfor (i = 0; i < rxq_size; i++) {\n\t\tstruct urb *req = pnd->urbs[i];\n\n\t\tif (!req)\n\t\t\tcontinue;\n\t\tusb_kill_urb(req);\n\t\tusb_free_urb(req);\n\t\tpnd->urbs[i] = NULL;\n\t}\n\n\treturn usb_set_interface(pnd->usb, num, !pnd->active_setting);\n}\n\nstatic int usbpn_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t\tvoid __user *data, int cmd)\n{\n\tstruct if_phonet_req *req = (struct if_phonet_req *)ifr;\n\n\tswitch (cmd) {\n\tcase SIOCPNGAUTOCONF:\n\t\treq->ifr_phonet_autoconf.device = PN_DEV_PC;\n\t\treturn 0;\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\nstatic const struct net_device_ops usbpn_ops = {\n\t.ndo_open\t= usbpn_open,\n\t.ndo_stop\t= usbpn_close,\n\t.ndo_start_xmit = usbpn_xmit,\n\t.ndo_siocdevprivate = usbpn_siocdevprivate,\n};\n\nstatic void usbpn_setup(struct net_device *dev)\n{\n\tconst u8 addr = PN_MEDIA_USB;\n\n\tdev->features\t\t= 0;\n\tdev->netdev_ops\t\t= &usbpn_ops;\n\tdev->header_ops\t\t= &phonet_header_ops;\n\tdev->type\t\t= ARPHRD_PHONET;\n\tdev->flags\t\t= IFF_POINTOPOINT | IFF_NOARP;\n\tdev->mtu\t\t= PHONET_MAX_MTU;\n\tdev->min_mtu\t\t= PHONET_MIN_MTU;\n\tdev->max_mtu\t\t= PHONET_MAX_MTU;\n\tdev->hard_header_len\t= 1;\n\tdev->addr_len\t\t= 1;\n\tdev_addr_set(dev, &addr);\n\tdev->tx_queue_len\t= 3;\n\n\tdev->needs_free_netdev\t= true;\n}\n\n \nstatic const struct usb_device_id usbpn_ids[] = {\n\t{\n\t\t.match_flags = USB_DEVICE_ID_MATCH_VENDOR\n\t\t\t| USB_DEVICE_ID_MATCH_INT_CLASS\n\t\t\t| USB_DEVICE_ID_MATCH_INT_SUBCLASS,\n\t\t.idVendor = 0x0421,  \n\t\t.bInterfaceClass = USB_CLASS_COMM,\n\t\t.bInterfaceSubClass = 0xFE,\n\t},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(usb, usbpn_ids);\n\nstatic struct usb_driver usbpn_driver;\n\nstatic int usbpn_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstatic const char ifname[] = \"usbpn%d\";\n\tconst struct usb_cdc_union_desc *union_header = NULL;\n\tconst struct usb_host_interface *data_desc;\n\tstruct usb_interface *data_intf;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *dev;\n\tstruct usbpn_dev *pnd;\n\tu8 *data;\n\tint phonet = 0;\n\tint len, err;\n\tstruct usb_cdc_parsed_header hdr;\n\n\tdata = intf->altsetting->extra;\n\tlen = intf->altsetting->extralen;\n\tcdc_parse_cdc_header(&hdr, intf, data, len);\n\tunion_header = hdr.usb_cdc_union_desc;\n\tphonet = hdr.phonet_magic_present;\n\n\tif (!union_header || !phonet)\n\t\treturn -EINVAL;\n\n\tdata_intf = usb_ifnum_to_if(usbdev, union_header->bSlaveInterface0);\n\tif (data_intf == NULL)\n\t\treturn -ENODEV;\n\t \n\tif (data_intf->num_altsetting != 2)\n\t\treturn -EINVAL;\n\tif (data_intf->altsetting[0].desc.bNumEndpoints == 0 &&\n\t    data_intf->altsetting[1].desc.bNumEndpoints == 2)\n\t\tdata_desc = data_intf->altsetting + 1;\n\telse\n\tif (data_intf->altsetting[0].desc.bNumEndpoints == 2 &&\n\t    data_intf->altsetting[1].desc.bNumEndpoints == 0)\n\t\tdata_desc = data_intf->altsetting;\n\telse\n\t\treturn -EINVAL;\n\n\tdev = alloc_netdev(struct_size(pnd, urbs, rxq_size), ifname,\n\t\t\t   NET_NAME_UNKNOWN, usbpn_setup);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tpnd = netdev_priv(dev);\n\tSET_NETDEV_DEV(dev, &intf->dev);\n\n\tpnd->dev = dev;\n\tpnd->usb = usbdev;\n\tpnd->intf = intf;\n\tpnd->data_intf = data_intf;\n\tspin_lock_init(&pnd->tx_lock);\n\tspin_lock_init(&pnd->rx_lock);\n\t \n\tif (usb_pipein(data_desc->endpoint[0].desc.bEndpointAddress)) {\n\t\tpnd->rx_pipe = usb_rcvbulkpipe(usbdev,\n\t\t\tdata_desc->endpoint[0].desc.bEndpointAddress);\n\t\tpnd->tx_pipe = usb_sndbulkpipe(usbdev,\n\t\t\tdata_desc->endpoint[1].desc.bEndpointAddress);\n\t} else {\n\t\tpnd->rx_pipe = usb_rcvbulkpipe(usbdev,\n\t\t\tdata_desc->endpoint[1].desc.bEndpointAddress);\n\t\tpnd->tx_pipe = usb_sndbulkpipe(usbdev,\n\t\t\tdata_desc->endpoint[0].desc.bEndpointAddress);\n\t}\n\tpnd->active_setting = data_desc - data_intf->altsetting;\n\n\terr = usb_driver_claim_interface(&usbpn_driver, data_intf, pnd);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tusb_set_interface(usbdev, union_header->bSlaveInterface0,\n\t\t\t\t!pnd->active_setting);\n\tusb_set_intfdata(intf, pnd);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\t \n\t\tpnd->disconnected = 1;\n\t\tusb_driver_release_interface(&usbpn_driver, data_intf);\n\t\tgoto out;\n\t}\n\n\tdev_dbg(&dev->dev, \"USB CDC Phonet device found\\n\");\n\treturn 0;\n\nout:\n\tusb_set_intfdata(intf, NULL);\n\tfree_netdev(dev);\n\treturn err;\n}\n\nstatic void usbpn_disconnect(struct usb_interface *intf)\n{\n\tstruct usbpn_dev *pnd = usb_get_intfdata(intf);\n\n\tif (pnd->disconnected)\n\t\treturn;\n\n\tpnd->disconnected = 1;\n\tusb_driver_release_interface(&usbpn_driver,\n\t\t\t(pnd->intf == intf) ? pnd->data_intf : pnd->intf);\n\tunregister_netdev(pnd->dev);\n}\n\nstatic struct usb_driver usbpn_driver = {\n\t.name =\t\t\"cdc_phonet\",\n\t.probe =\tusbpn_probe,\n\t.disconnect =\tusbpn_disconnect,\n\t.id_table =\tusbpn_ids,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(usbpn_driver);\n\nMODULE_AUTHOR(\"Remi Denis-Courmont\");\nMODULE_DESCRIPTION(\"USB CDC Phonet host interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}