{
  "module_name": "usbnet.c",
  "hash_id": "0c4b891aafff9ffcfe80a5cd7d2d15c42e706fe0939e673a99a40c5c3a92a3c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/usbnet.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ctype.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/usbnet.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pm_runtime.h>\n\n \n\n \n#define\tMAX_QUEUE_MEMORY\t(60 * 1518)\n#define\tRX_QLEN(dev)\t\t((dev)->rx_qlen)\n#define\tTX_QLEN(dev)\t\t((dev)->tx_qlen)\n\n\n#define TX_TIMEOUT_JIFFIES\t(5*HZ)\n\n \n#define THROTTLE_JIFFIES\t(HZ/8)\n\n\n#define UNLINK_TIMEOUT_MS\t3\n\n \n\n\nstatic u8\tnode_id [ETH_ALEN];\n\n \nstatic int msg_level = -1;\nmodule_param (msg_level, int, 0);\nMODULE_PARM_DESC (msg_level, \"Override default message level\");\n\n \n\nstatic const char * const usbnet_event_names[] = {\n\t[EVENT_TX_HALT]\t\t   = \"EVENT_TX_HALT\",\n\t[EVENT_RX_HALT]\t\t   = \"EVENT_RX_HALT\",\n\t[EVENT_RX_MEMORY]\t   = \"EVENT_RX_MEMORY\",\n\t[EVENT_STS_SPLIT]\t   = \"EVENT_STS_SPLIT\",\n\t[EVENT_LINK_RESET]\t   = \"EVENT_LINK_RESET\",\n\t[EVENT_RX_PAUSED]\t   = \"EVENT_RX_PAUSED\",\n\t[EVENT_DEV_ASLEEP]\t   = \"EVENT_DEV_ASLEEP\",\n\t[EVENT_DEV_OPEN]\t   = \"EVENT_DEV_OPEN\",\n\t[EVENT_DEVICE_REPORT_IDLE] = \"EVENT_DEVICE_REPORT_IDLE\",\n\t[EVENT_NO_RUNTIME_PM]\t   = \"EVENT_NO_RUNTIME_PM\",\n\t[EVENT_RX_KILL]\t\t   = \"EVENT_RX_KILL\",\n\t[EVENT_LINK_CHANGE]\t   = \"EVENT_LINK_CHANGE\",\n\t[EVENT_SET_RX_MODE]\t   = \"EVENT_SET_RX_MODE\",\n\t[EVENT_NO_IP_ALIGN]\t   = \"EVENT_NO_IP_ALIGN\",\n};\n\n \nint usbnet_get_endpoints(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint\t\t\t\ttmp;\n\tstruct usb_host_interface\t*alt = NULL;\n\tstruct usb_host_endpoint\t*in = NULL, *out = NULL;\n\tstruct usb_host_endpoint\t*status = NULL;\n\n\tfor (tmp = 0; tmp < intf->num_altsetting; tmp++) {\n\t\tunsigned\tep;\n\n\t\tin = out = status = NULL;\n\t\talt = intf->altsetting + tmp;\n\n\t\t \n\t\tfor (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {\n\t\t\tstruct usb_host_endpoint\t*e;\n\t\t\tint\t\t\t\tintr = 0;\n\n\t\t\te = alt->endpoint + ep;\n\n\t\t\t \n\t\t\tif (!usb_endpoint_maxp(&e->desc))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (e->desc.bmAttributes) {\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (!usb_endpoint_dir_in(&e->desc))\n\t\t\t\t\tcontinue;\n\t\t\t\tintr = 1;\n\t\t\t\tfallthrough;\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (usb_endpoint_dir_in(&e->desc)) {\n\t\t\t\tif (!intr && !in)\n\t\t\t\t\tin = e;\n\t\t\t\telse if (intr && !status)\n\t\t\t\t\tstatus = e;\n\t\t\t} else {\n\t\t\t\tif (!out)\n\t\t\t\t\tout = e;\n\t\t\t}\n\t\t}\n\t\tif (in && out)\n\t\t\tbreak;\n\t}\n\tif (!alt || !in || !out)\n\t\treturn -EINVAL;\n\n\tif (alt->desc.bAlternateSetting != 0 ||\n\t    !(dev->driver_info->flags & FLAG_NO_SETINT)) {\n\t\ttmp = usb_set_interface (dev->udev, alt->desc.bInterfaceNumber,\n\t\t\t\talt->desc.bAlternateSetting);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t}\n\n\tdev->in = usb_rcvbulkpipe (dev->udev,\n\t\t\tin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\tdev->out = usb_sndbulkpipe (dev->udev,\n\t\t\tout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\tdev->status = status;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usbnet_get_endpoints);\n\nint usbnet_get_ethernet_addr(struct usbnet *dev, int iMACAddress)\n{\n\tu8\t\taddr[ETH_ALEN];\n\tint \t\ttmp = -1, ret;\n\tunsigned char\tbuf [13];\n\n\tret = usb_string(dev->udev, iMACAddress, buf, sizeof buf);\n\tif (ret == 12)\n\t\ttmp = hex2bin(addr, buf, 6);\n\tif (tmp < 0) {\n\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\"bad MAC string %d fetch, %d\\n\", iMACAddress, tmp);\n\t\tif (ret >= 0)\n\t\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\teth_hw_addr_set(dev->net, addr);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usbnet_get_ethernet_addr);\n\nstatic void intr_complete (struct urb *urb)\n{\n\tstruct usbnet\t*dev = urb->context;\n\tint\t\tstatus = urb->status;\n\n\tswitch (status) {\n\t \n\tcase 0:\n\t\tdev->driver_info->status(dev, urb);\n\t\tbreak;\n\n\t \n\tcase -ENOENT:\t\t \n\tcase -ESHUTDOWN:\t \n\t\tnetif_dbg(dev, ifdown, dev->net,\n\t\t\t  \"intr shutdown, code %d\\n\", status);\n\t\treturn;\n\n\t \n\tdefault:\n\t\tnetdev_dbg(dev->net, \"intr status %d\\n\", status);\n\t\tbreak;\n\t}\n\n\tstatus = usb_submit_urb (urb, GFP_ATOMIC);\n\tif (status != 0)\n\t\tnetif_err(dev, timer, dev->net,\n\t\t\t  \"intr resubmit --> %d\\n\", status);\n}\n\nstatic int init_status (struct usbnet *dev, struct usb_interface *intf)\n{\n\tchar\t\t*buf = NULL;\n\tunsigned\tpipe = 0;\n\tunsigned\tmaxp;\n\tunsigned\tperiod;\n\n\tif (!dev->driver_info->status)\n\t\treturn 0;\n\n\tpipe = usb_rcvintpipe (dev->udev,\n\t\t\tdev->status->desc.bEndpointAddress\n\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\tmaxp = usb_maxpacket(dev->udev, pipe);\n\n\t \n\tperiod = max ((int) dev->status->desc.bInterval,\n\t\t(dev->udev->speed == USB_SPEED_HIGH) ? 7 : 3);\n\n\tbuf = kmalloc (maxp, GFP_KERNEL);\n\tif (buf) {\n\t\tdev->interrupt = usb_alloc_urb (0, GFP_KERNEL);\n\t\tif (!dev->interrupt) {\n\t\t\tkfree (buf);\n\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tusb_fill_int_urb(dev->interrupt, dev->udev, pipe,\n\t\t\t\tbuf, maxp, intr_complete, dev, period);\n\t\t\tdev->interrupt->transfer_flags |= URB_FREE_BUFFER;\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"status ep%din, %d bytes period %d\\n\",\n\t\t\t\tusb_pipeendpoint(pipe), maxp, period);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint usbnet_status_start(struct usbnet *dev, gfp_t mem_flags)\n{\n\tint ret = 0;\n\n\tWARN_ON_ONCE(dev->interrupt == NULL);\n\tif (dev->interrupt) {\n\t\tmutex_lock(&dev->interrupt_mutex);\n\n\t\tif (++dev->interrupt_count == 1)\n\t\t\tret = usb_submit_urb(dev->interrupt, mem_flags);\n\n\t\tdev_dbg(&dev->udev->dev, \"incremented interrupt URB count to %d\\n\",\n\t\t\tdev->interrupt_count);\n\t\tmutex_unlock(&dev->interrupt_mutex);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usbnet_status_start);\n\n \nstatic int __usbnet_status_start_force(struct usbnet *dev, gfp_t mem_flags)\n{\n\tint ret = 0;\n\n\tmutex_lock(&dev->interrupt_mutex);\n\tif (dev->interrupt_count) {\n\t\tret = usb_submit_urb(dev->interrupt, mem_flags);\n\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\"submitted interrupt URB for resume\\n\");\n\t}\n\tmutex_unlock(&dev->interrupt_mutex);\n\treturn ret;\n}\n\n \nvoid usbnet_status_stop(struct usbnet *dev)\n{\n\tif (dev->interrupt) {\n\t\tmutex_lock(&dev->interrupt_mutex);\n\t\tWARN_ON(dev->interrupt_count == 0);\n\n\t\tif (dev->interrupt_count && --dev->interrupt_count == 0)\n\t\t\tusb_kill_urb(dev->interrupt);\n\n\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\"decremented interrupt URB count to %d\\n\",\n\t\t\tdev->interrupt_count);\n\t\tmutex_unlock(&dev->interrupt_mutex);\n\t}\n}\nEXPORT_SYMBOL_GPL(usbnet_status_stop);\n\n \nstatic void __usbnet_status_stop_force(struct usbnet *dev)\n{\n\tif (dev->interrupt) {\n\t\tmutex_lock(&dev->interrupt_mutex);\n\t\tusb_kill_urb(dev->interrupt);\n\t\tdev_dbg(&dev->udev->dev, \"killed interrupt URB for suspend\\n\");\n\t\tmutex_unlock(&dev->interrupt_mutex);\n\t}\n}\n\n \nvoid usbnet_skb_return (struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct pcpu_sw_netstats *stats64 = this_cpu_ptr(dev->net->tstats);\n\tunsigned long flags;\n\tint\tstatus;\n\n\tif (test_bit(EVENT_RX_PAUSED, &dev->flags)) {\n\t\tskb_queue_tail(&dev->rxq_pause, skb);\n\t\treturn;\n\t}\n\n\t \n\tif (skb->protocol == 0)\n\t\tskb->protocol = eth_type_trans (skb, dev->net);\n\n\tflags = u64_stats_update_begin_irqsave(&stats64->syncp);\n\tu64_stats_inc(&stats64->rx_packets);\n\tu64_stats_add(&stats64->rx_bytes, skb->len);\n\tu64_stats_update_end_irqrestore(&stats64->syncp, flags);\n\n\tnetif_dbg(dev, rx_status, dev->net, \"< rx, len %zu, type 0x%x\\n\",\n\t\t  skb->len + sizeof (struct ethhdr), skb->protocol);\n\tmemset (skb->cb, 0, sizeof (struct skb_data));\n\n\tif (skb_defer_rx_timestamp(skb))\n\t\treturn;\n\n\tstatus = netif_rx (skb);\n\tif (status != NET_RX_SUCCESS)\n\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t  \"netif_rx status %d\\n\", status);\n}\nEXPORT_SYMBOL_GPL(usbnet_skb_return);\n\n \nvoid usbnet_update_max_qlen(struct usbnet *dev)\n{\n\tenum usb_device_speed speed = dev->udev->speed;\n\n\tif (!dev->rx_urb_size || !dev->hard_mtu)\n\t\tgoto insanity;\n\tswitch (speed) {\n\tcase USB_SPEED_HIGH:\n\t\tdev->rx_qlen = MAX_QUEUE_MEMORY / dev->rx_urb_size;\n\t\tdev->tx_qlen = MAX_QUEUE_MEMORY / dev->hard_mtu;\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\t \n\t\tdev->rx_qlen = 5 * MAX_QUEUE_MEMORY / dev->rx_urb_size;\n\t\tdev->tx_qlen = 5 * MAX_QUEUE_MEMORY / dev->hard_mtu;\n\t\tbreak;\n\tdefault:\ninsanity:\n\t\tdev->rx_qlen = dev->tx_qlen = 4;\n\t}\n}\nEXPORT_SYMBOL_GPL(usbnet_update_max_qlen);\n\n\n \n\nint usbnet_change_mtu (struct net_device *net, int new_mtu)\n{\n\tstruct usbnet\t*dev = netdev_priv(net);\n\tint\t\tll_mtu = new_mtu + net->hard_header_len;\n\tint\t\told_hard_mtu = dev->hard_mtu;\n\tint\t\told_rx_urb_size = dev->rx_urb_size;\n\n\t\n\tif ((ll_mtu % dev->maxpacket) == 0)\n\t\treturn -EDOM;\n\tnet->mtu = new_mtu;\n\n\tdev->hard_mtu = net->mtu + net->hard_header_len;\n\tif (dev->rx_urb_size == old_hard_mtu) {\n\t\tdev->rx_urb_size = dev->hard_mtu;\n\t\tif (dev->rx_urb_size > old_rx_urb_size) {\n\t\t\tusbnet_pause_rx(dev);\n\t\t\tusbnet_unlink_rx_urbs(dev);\n\t\t\tusbnet_resume_rx(dev);\n\t\t}\n\t}\n\n\t \n\tusbnet_update_max_qlen(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usbnet_change_mtu);\n\n \nstatic void __usbnet_queue_skb(struct sk_buff_head *list,\n\t\t\tstruct sk_buff *newsk, enum skb_state state)\n{\n\tstruct skb_data *entry = (struct skb_data *) newsk->cb;\n\n\t__skb_queue_tail(list, newsk);\n\tentry->state = state;\n}\n\n \n\n \n\nstatic enum skb_state defer_bh(struct usbnet *dev, struct sk_buff *skb,\n\t\tstruct sk_buff_head *list, enum skb_state state)\n{\n\tunsigned long\t\tflags;\n\tenum skb_state \t\told_state;\n\tstruct skb_data *entry = (struct skb_data *) skb->cb;\n\n\tspin_lock_irqsave(&list->lock, flags);\n\told_state = entry->state;\n\tentry->state = state;\n\t__skb_unlink(skb, list);\n\n\t \n\tspin_lock_nested(&dev->done.lock, SINGLE_DEPTH_NESTING);\n\n\t__skb_queue_tail(&dev->done, skb);\n\tif (dev->done.qlen == 1)\n\t\ttasklet_schedule(&dev->bh);\n\tspin_unlock(&dev->done.lock);\n\tspin_unlock_irqrestore(&list->lock, flags);\n\treturn old_state;\n}\n\n \nvoid usbnet_defer_kevent (struct usbnet *dev, int work)\n{\n\tset_bit (work, &dev->flags);\n\tif (!schedule_work (&dev->kevent))\n\t\tnetdev_dbg(dev->net, \"kevent %s may have been dropped\\n\", usbnet_event_names[work]);\n\telse\n\t\tnetdev_dbg(dev->net, \"kevent %s scheduled\\n\", usbnet_event_names[work]);\n}\nEXPORT_SYMBOL_GPL(usbnet_defer_kevent);\n\n \n\nstatic void rx_complete (struct urb *urb);\n\nstatic int rx_submit (struct usbnet *dev, struct urb *urb, gfp_t flags)\n{\n\tstruct sk_buff\t\t*skb;\n\tstruct skb_data\t\t*entry;\n\tint\t\t\tretval = 0;\n\tunsigned long\t\tlockflags;\n\tsize_t\t\t\tsize = dev->rx_urb_size;\n\n\t \n\tif (test_bit(EVENT_RX_KILL, &dev->flags)) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOLINK;\n\t}\n\n\tif (test_bit(EVENT_NO_IP_ALIGN, &dev->flags))\n\t\tskb = __netdev_alloc_skb(dev->net, size, flags);\n\telse\n\t\tskb = __netdev_alloc_skb_ip_align(dev->net, size, flags);\n\tif (!skb) {\n\t\tnetif_dbg(dev, rx_err, dev->net, \"no rx skb\\n\");\n\t\tusbnet_defer_kevent (dev, EVENT_RX_MEMORY);\n\t\tusb_free_urb (urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = (struct skb_data *) skb->cb;\n\tentry->urb = urb;\n\tentry->dev = dev;\n\tentry->length = 0;\n\n\tusb_fill_bulk_urb (urb, dev->udev, dev->in,\n\t\tskb->data, size, rx_complete, skb);\n\n\tspin_lock_irqsave (&dev->rxq.lock, lockflags);\n\n\tif (netif_running (dev->net) &&\n\t    netif_device_present (dev->net) &&\n\t    test_bit(EVENT_DEV_OPEN, &dev->flags) &&\n\t    !test_bit (EVENT_RX_HALT, &dev->flags) &&\n\t    !test_bit (EVENT_DEV_ASLEEP, &dev->flags)) {\n\t\tswitch (retval = usb_submit_urb (urb, GFP_ATOMIC)) {\n\t\tcase -EPIPE:\n\t\t\tusbnet_defer_kevent (dev, EVENT_RX_HALT);\n\t\t\tbreak;\n\t\tcase -ENOMEM:\n\t\t\tusbnet_defer_kevent (dev, EVENT_RX_MEMORY);\n\t\t\tbreak;\n\t\tcase -ENODEV:\n\t\t\tnetif_dbg(dev, ifdown, dev->net, \"device gone\\n\");\n\t\t\tnetif_device_detach (dev->net);\n\t\t\tbreak;\n\t\tcase -EHOSTUNREACH:\n\t\t\tretval = -ENOLINK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t  \"rx submit, %d\\n\", retval);\n\t\t\ttasklet_schedule (&dev->bh);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t__usbnet_queue_skb(&dev->rxq, skb, rx_start);\n\t\t}\n\t} else {\n\t\tnetif_dbg(dev, ifdown, dev->net, \"rx: stopped\\n\");\n\t\tretval = -ENOLINK;\n\t}\n\tspin_unlock_irqrestore (&dev->rxq.lock, lockflags);\n\tif (retval) {\n\t\tdev_kfree_skb_any (skb);\n\t\tusb_free_urb (urb);\n\t}\n\treturn retval;\n}\n\n\n \n\nstatic inline int rx_process(struct usbnet *dev, struct sk_buff *skb)\n{\n\tif (dev->driver_info->rx_fixup &&\n\t    !dev->driver_info->rx_fixup (dev, skb)) {\n\t\t \n\t\tif (!(dev->driver_info->flags & FLAG_RX_ASSEMBLE))\n\t\t\tdev->net->stats.rx_errors++;\n\t\treturn -EPROTO;\n\t}\n\t \n\n\t \n\tif (dev->driver_info->flags & FLAG_MULTI_PACKET)\n\t\treturn -EALREADY;\n\n\tif (skb->len < ETH_HLEN) {\n\t\tdev->net->stats.rx_errors++;\n\t\tdev->net->stats.rx_length_errors++;\n\t\tnetif_dbg(dev, rx_err, dev->net, \"rx length %d\\n\", skb->len);\n\t\treturn -EPROTO;\n\t}\n\n\tusbnet_skb_return(dev, skb);\n\treturn 0;\n}\n\n \n\nstatic void rx_complete (struct urb *urb)\n{\n\tstruct sk_buff\t\t*skb = (struct sk_buff *) urb->context;\n\tstruct skb_data\t\t*entry = (struct skb_data *) skb->cb;\n\tstruct usbnet\t\t*dev = entry->dev;\n\tint\t\t\turb_status = urb->status;\n\tenum skb_state\t\tstate;\n\n\tskb_put (skb, urb->actual_length);\n\tstate = rx_done;\n\tentry->urb = NULL;\n\n\tswitch (urb_status) {\n\t \n\tcase 0:\n\t\tbreak;\n\n\t \n\tcase -EPIPE:\n\t\tdev->net->stats.rx_errors++;\n\t\tusbnet_defer_kevent (dev, EVENT_RX_HALT);\n\t\tfallthrough;\n\n\t \n\tcase -ECONNRESET:\t\t \n\tcase -ESHUTDOWN:\t\t \n\t\tnetif_dbg(dev, ifdown, dev->net,\n\t\t\t  \"rx shutdown, code %d\\n\", urb_status);\n\t\tgoto block;\n\n\t \n\tcase -EPROTO:\n\tcase -ETIME:\n\tcase -EILSEQ:\n\t\tdev->net->stats.rx_errors++;\n\t\tif (!timer_pending (&dev->delay)) {\n\t\t\tmod_timer (&dev->delay, jiffies + THROTTLE_JIFFIES);\n\t\t\tnetif_dbg(dev, link, dev->net,\n\t\t\t\t  \"rx throttle %d\\n\", urb_status);\n\t\t}\nblock:\n\t\tstate = rx_cleanup;\n\t\tentry->urb = urb;\n\t\turb = NULL;\n\t\tbreak;\n\n\t \n\tcase -EOVERFLOW:\n\t\tdev->net->stats.rx_over_errors++;\n\t\tfallthrough;\n\n\tdefault:\n\t\tstate = rx_cleanup;\n\t\tdev->net->stats.rx_errors++;\n\t\tnetif_dbg(dev, rx_err, dev->net, \"rx status %d\\n\", urb_status);\n\t\tbreak;\n\t}\n\n\t \n\tif (++dev->pkt_cnt > 30) {\n\t\tdev->pkt_cnt = 0;\n\t\tdev->pkt_err = 0;\n\t} else {\n\t\tif (state == rx_cleanup)\n\t\t\tdev->pkt_err++;\n\t\tif (dev->pkt_err > 20)\n\t\t\tset_bit(EVENT_RX_KILL, &dev->flags);\n\t}\n\n\tstate = defer_bh(dev, skb, &dev->rxq, state);\n\n\tif (urb) {\n\t\tif (netif_running (dev->net) &&\n\t\t    !test_bit (EVENT_RX_HALT, &dev->flags) &&\n\t\t    state != unlink_start) {\n\t\t\trx_submit (dev, urb, GFP_ATOMIC);\n\t\t\tusb_mark_last_busy(dev->udev);\n\t\t\treturn;\n\t\t}\n\t\tusb_free_urb (urb);\n\t}\n\tnetif_dbg(dev, rx_err, dev->net, \"no read resubmitted\\n\");\n}\n\n \nvoid usbnet_pause_rx(struct usbnet *dev)\n{\n\tset_bit(EVENT_RX_PAUSED, &dev->flags);\n\n\tnetif_dbg(dev, rx_status, dev->net, \"paused rx queue enabled\\n\");\n}\nEXPORT_SYMBOL_GPL(usbnet_pause_rx);\n\nvoid usbnet_resume_rx(struct usbnet *dev)\n{\n\tstruct sk_buff *skb;\n\tint num = 0;\n\n\tclear_bit(EVENT_RX_PAUSED, &dev->flags);\n\n\twhile ((skb = skb_dequeue(&dev->rxq_pause)) != NULL) {\n\t\tusbnet_skb_return(dev, skb);\n\t\tnum++;\n\t}\n\n\ttasklet_schedule(&dev->bh);\n\n\tnetif_dbg(dev, rx_status, dev->net,\n\t\t  \"paused rx queue disabled, %d skbs requeued\\n\", num);\n}\nEXPORT_SYMBOL_GPL(usbnet_resume_rx);\n\nvoid usbnet_purge_paused_rxq(struct usbnet *dev)\n{\n\tskb_queue_purge(&dev->rxq_pause);\n}\nEXPORT_SYMBOL_GPL(usbnet_purge_paused_rxq);\n\n \n\n\n\nstatic int unlink_urbs (struct usbnet *dev, struct sk_buff_head *q)\n{\n\tunsigned long\t\tflags;\n\tstruct sk_buff\t\t*skb;\n\tint\t\t\tcount = 0;\n\n\tspin_lock_irqsave (&q->lock, flags);\n\twhile (!skb_queue_empty(q)) {\n\t\tstruct skb_data\t\t*entry;\n\t\tstruct urb\t\t*urb;\n\t\tint\t\t\tretval;\n\n\t\tskb_queue_walk(q, skb) {\n\t\t\tentry = (struct skb_data *) skb->cb;\n\t\t\tif (entry->state != unlink_start)\n\t\t\t\tgoto found;\n\t\t}\n\t\tbreak;\nfound:\n\t\tentry->state = unlink_start;\n\t\turb = entry->urb;\n\n\t\t \n\t\tusb_get_urb(urb);\n\t\tspin_unlock_irqrestore(&q->lock, flags);\n\t\t\n\t\t\n\t\tretval = usb_unlink_urb (urb);\n\t\tif (retval != -EINPROGRESS && retval != 0)\n\t\t\tnetdev_dbg(dev->net, \"unlink urb err, %d\\n\", retval);\n\t\telse\n\t\t\tcount++;\n\t\tusb_put_urb(urb);\n\t\tspin_lock_irqsave(&q->lock, flags);\n\t}\n\tspin_unlock_irqrestore (&q->lock, flags);\n\treturn count;\n}\n\n\n\n\nvoid usbnet_unlink_rx_urbs(struct usbnet *dev)\n{\n\tif (netif_running(dev->net)) {\n\t\t(void) unlink_urbs (dev, &dev->rxq);\n\t\ttasklet_schedule(&dev->bh);\n\t}\n}\nEXPORT_SYMBOL_GPL(usbnet_unlink_rx_urbs);\n\n \n\nstatic void wait_skb_queue_empty(struct sk_buff_head *q)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&q->lock, flags);\n\twhile (!skb_queue_empty(q)) {\n\t\tspin_unlock_irqrestore(&q->lock, flags);\n\t\tschedule_timeout(msecs_to_jiffies(UNLINK_TIMEOUT_MS));\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tspin_lock_irqsave(&q->lock, flags);\n\t}\n\tspin_unlock_irqrestore(&q->lock, flags);\n}\n\n\nstatic void usbnet_terminate_urbs(struct usbnet *dev)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint temp;\n\n\t \n\tadd_wait_queue(&dev->wait, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\ttemp = unlink_urbs(dev, &dev->txq) +\n\t\tunlink_urbs(dev, &dev->rxq);\n\n\t \n\twait_skb_queue_empty(&dev->rxq);\n\twait_skb_queue_empty(&dev->txq);\n\twait_skb_queue_empty(&dev->done);\n\tnetif_dbg(dev, ifdown, dev->net,\n\t\t  \"waited for %d urb completions\\n\", temp);\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&dev->wait, &wait);\n}\n\nint usbnet_stop (struct net_device *net)\n{\n\tstruct usbnet\t\t*dev = netdev_priv(net);\n\tconst struct driver_info *info = dev->driver_info;\n\tint\t\t\tretval, pm, mpn;\n\n\tclear_bit(EVENT_DEV_OPEN, &dev->flags);\n\tnetif_stop_queue (net);\n\n\tnetif_info(dev, ifdown, dev->net,\n\t\t   \"stop stats: rx/tx %lu/%lu, errs %lu/%lu\\n\",\n\t\t   net->stats.rx_packets, net->stats.tx_packets,\n\t\t   net->stats.rx_errors, net->stats.tx_errors);\n\n\t \n\tpm = usb_autopm_get_interface(dev->intf);\n\t \n\tif (info->stop) {\n\t\tretval = info->stop(dev);\n\t\tif (retval < 0)\n\t\t\tnetif_info(dev, ifdown, dev->net,\n\t\t\t\t   \"stop fail (%d) usbnet usb-%s-%s, %s\\n\",\n\t\t\t\t   retval,\n\t\t\t\t   dev->udev->bus->bus_name, dev->udev->devpath,\n\t\t\t\t   info->description);\n\t}\n\n\tif (!(info->flags & FLAG_AVOID_UNLINK_URBS))\n\t\tusbnet_terminate_urbs(dev);\n\n\tusbnet_status_stop(dev);\n\n\tusbnet_purge_paused_rxq(dev);\n\n\tmpn = !test_and_clear_bit(EVENT_NO_RUNTIME_PM, &dev->flags);\n\n\t \n\tdev->flags = 0;\n\tdel_timer_sync (&dev->delay);\n\ttasklet_kill (&dev->bh);\n\tcancel_work_sync(&dev->kevent);\n\tif (!pm)\n\t\tusb_autopm_put_interface(dev->intf);\n\n\tif (info->manage_power && mpn)\n\t\tinfo->manage_power(dev, 0);\n\telse\n\t\tusb_autopm_put_interface(dev->intf);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usbnet_stop);\n\n \n\n\n\n\n\nint usbnet_open (struct net_device *net)\n{\n\tstruct usbnet\t\t*dev = netdev_priv(net);\n\tint\t\t\tretval;\n\tconst struct driver_info *info = dev->driver_info;\n\n\tif ((retval = usb_autopm_get_interface(dev->intf)) < 0) {\n\t\tnetif_info(dev, ifup, dev->net,\n\t\t\t   \"resumption fail (%d) usbnet usb-%s-%s, %s\\n\",\n\t\t\t   retval,\n\t\t\t   dev->udev->bus->bus_name,\n\t\t\t   dev->udev->devpath,\n\t\t\t   info->description);\n\t\tgoto done_nopm;\n\t}\n\n\t\n\tif (info->reset && (retval = info->reset (dev)) < 0) {\n\t\tnetif_info(dev, ifup, dev->net,\n\t\t\t   \"open reset fail (%d) usbnet usb-%s-%s, %s\\n\",\n\t\t\t   retval,\n\t\t\t   dev->udev->bus->bus_name,\n\t\t\t   dev->udev->devpath,\n\t\t\t   info->description);\n\t\tgoto done;\n\t}\n\n\t \n\tusbnet_update_max_qlen(dev);\n\n\t\n\tif (info->check_connect && (retval = info->check_connect (dev)) < 0) {\n\t\tnetif_err(dev, ifup, dev->net, \"can't open; %d\\n\", retval);\n\t\tgoto done;\n\t}\n\n\t \n\tif (dev->interrupt) {\n\t\tretval = usbnet_status_start(dev, GFP_KERNEL);\n\t\tif (retval < 0) {\n\t\t\tnetif_err(dev, ifup, dev->net,\n\t\t\t\t  \"intr submit %d\\n\", retval);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tset_bit(EVENT_DEV_OPEN, &dev->flags);\n\tnetif_start_queue (net);\n\tnetif_info(dev, ifup, dev->net,\n\t\t   \"open: enable queueing (rx %d, tx %d) mtu %d %s framing\\n\",\n\t\t   (int)RX_QLEN(dev), (int)TX_QLEN(dev),\n\t\t   dev->net->mtu,\n\t\t   (dev->driver_info->flags & FLAG_FRAMING_NC) ? \"NetChip\" :\n\t\t   (dev->driver_info->flags & FLAG_FRAMING_GL) ? \"GeneSys\" :\n\t\t   (dev->driver_info->flags & FLAG_FRAMING_Z) ? \"Zaurus\" :\n\t\t   (dev->driver_info->flags & FLAG_FRAMING_RN) ? \"RNDIS\" :\n\t\t   (dev->driver_info->flags & FLAG_FRAMING_AX) ? \"ASIX\" :\n\t\t   \"simple\");\n\n\t \n\tdev->pkt_cnt = 0;\n\tdev->pkt_err = 0;\n\tclear_bit(EVENT_RX_KILL, &dev->flags);\n\n\t\n\ttasklet_schedule (&dev->bh);\n\tif (info->manage_power) {\n\t\tretval = info->manage_power(dev, 1);\n\t\tif (retval < 0) {\n\t\t\tretval = 0;\n\t\t\tset_bit(EVENT_NO_RUNTIME_PM, &dev->flags);\n\t\t} else {\n\t\t\tusb_autopm_put_interface(dev->intf);\n\t\t}\n\t}\n\treturn retval;\ndone:\n\tusb_autopm_put_interface(dev->intf);\ndone_nopm:\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(usbnet_open);\n\n \n\n \n\n \nint usbnet_get_link_ksettings_mii(struct net_device *net,\n\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\tif (!dev->mii.mdio_read)\n\t\treturn -EOPNOTSUPP;\n\n\tmii_ethtool_get_link_ksettings(&dev->mii, cmd);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usbnet_get_link_ksettings_mii);\n\nint usbnet_get_link_ksettings_internal(struct net_device *net,\n\t\t\t\t\tstruct ethtool_link_ksettings *cmd)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\t \n\tif (dev->rx_speed != SPEED_UNSET)\n\t\tcmd->base.speed = dev->rx_speed / 1000000;\n\telse if (dev->tx_speed != SPEED_UNSET)\n\t\tcmd->base.speed = dev->tx_speed / 1000000;\n\telse\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usbnet_get_link_ksettings_internal);\n\nint usbnet_set_link_ksettings_mii(struct net_device *net,\n\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tint retval;\n\n\tif (!dev->mii.mdio_write)\n\t\treturn -EOPNOTSUPP;\n\n\tretval = mii_ethtool_set_link_ksettings(&dev->mii, cmd);\n\n\t \n\tif (dev->driver_info->link_reset)\n\t\tdev->driver_info->link_reset(dev);\n\n\t \n\tusbnet_update_max_qlen(dev);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(usbnet_set_link_ksettings_mii);\n\nu32 usbnet_get_link (struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\t \n\tif (dev->driver_info->check_connect)\n\t\treturn dev->driver_info->check_connect (dev) == 0;\n\n\t \n\tif (dev->mii.mdio_read)\n\t\treturn mii_link_ok(&dev->mii);\n\n\t \n\treturn ethtool_op_get_link(net);\n}\nEXPORT_SYMBOL_GPL(usbnet_get_link);\n\nint usbnet_nway_reset(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\tif (!dev->mii.mdio_write)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mii_nway_restart(&dev->mii);\n}\nEXPORT_SYMBOL_GPL(usbnet_nway_reset);\n\nvoid usbnet_get_drvinfo (struct net_device *net, struct ethtool_drvinfo *info)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\tstrscpy(info->driver, dev->driver_name, sizeof(info->driver));\n\tstrscpy(info->fw_version, dev->driver_info->description,\n\t\tsizeof(info->fw_version));\n\tusb_make_path (dev->udev, info->bus_info, sizeof info->bus_info);\n}\nEXPORT_SYMBOL_GPL(usbnet_get_drvinfo);\n\nu32 usbnet_get_msglevel (struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\treturn dev->msg_enable;\n}\nEXPORT_SYMBOL_GPL(usbnet_get_msglevel);\n\nvoid usbnet_set_msglevel (struct net_device *net, u32 level)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\tdev->msg_enable = level;\n}\nEXPORT_SYMBOL_GPL(usbnet_set_msglevel);\n\n \nstatic const struct ethtool_ops usbnet_ethtool_ops = {\n\t.get_link\t\t= usbnet_get_link,\n\t.nway_reset\t\t= usbnet_nway_reset,\n\t.get_drvinfo\t\t= usbnet_get_drvinfo,\n\t.get_msglevel\t\t= usbnet_get_msglevel,\n\t.set_msglevel\t\t= usbnet_set_msglevel,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_link_ksettings\t= usbnet_get_link_ksettings_mii,\n\t.set_link_ksettings\t= usbnet_set_link_ksettings_mii,\n};\n\n \n\nstatic void __handle_link_change(struct usbnet *dev)\n{\n\tif (!test_bit(EVENT_DEV_OPEN, &dev->flags))\n\t\treturn;\n\n\tif (!netif_carrier_ok(dev->net)) {\n\t\t \n\t\tunlink_urbs(dev, &dev->rxq);\n\n\t\t \n\t} else {\n\t\t \n\t\ttasklet_schedule(&dev->bh);\n\t}\n\n\t \n\tusbnet_update_max_qlen(dev);\n\n\tclear_bit(EVENT_LINK_CHANGE, &dev->flags);\n}\n\nvoid usbnet_set_rx_mode(struct net_device *net)\n{\n\tstruct usbnet\t\t*dev = netdev_priv(net);\n\n\tusbnet_defer_kevent(dev, EVENT_SET_RX_MODE);\n}\nEXPORT_SYMBOL_GPL(usbnet_set_rx_mode);\n\nstatic void __handle_set_rx_mode(struct usbnet *dev)\n{\n\tif (dev->driver_info->set_rx_mode)\n\t\t(dev->driver_info->set_rx_mode)(dev);\n\n\tclear_bit(EVENT_SET_RX_MODE, &dev->flags);\n}\n\n \nstatic void\nusbnet_deferred_kevent (struct work_struct *work)\n{\n\tstruct usbnet\t\t*dev =\n\t\tcontainer_of(work, struct usbnet, kevent);\n\tint\t\t\tstatus;\n\n\t \n\tif (test_bit (EVENT_TX_HALT, &dev->flags)) {\n\t\tunlink_urbs (dev, &dev->txq);\n\t\tstatus = usb_autopm_get_interface(dev->intf);\n\t\tif (status < 0)\n\t\t\tgoto fail_pipe;\n\t\tstatus = usb_clear_halt (dev->udev, dev->out);\n\t\tusb_autopm_put_interface(dev->intf);\n\t\tif (status < 0 &&\n\t\t    status != -EPIPE &&\n\t\t    status != -ESHUTDOWN) {\n\t\t\tif (netif_msg_tx_err (dev))\nfail_pipe:\n\t\t\t\tnetdev_err(dev->net, \"can't clear tx halt, status %d\\n\",\n\t\t\t\t\t   status);\n\t\t} else {\n\t\t\tclear_bit (EVENT_TX_HALT, &dev->flags);\n\t\t\tif (status != -ESHUTDOWN)\n\t\t\t\tnetif_wake_queue (dev->net);\n\t\t}\n\t}\n\tif (test_bit (EVENT_RX_HALT, &dev->flags)) {\n\t\tunlink_urbs (dev, &dev->rxq);\n\t\tstatus = usb_autopm_get_interface(dev->intf);\n\t\tif (status < 0)\n\t\t\tgoto fail_halt;\n\t\tstatus = usb_clear_halt (dev->udev, dev->in);\n\t\tusb_autopm_put_interface(dev->intf);\n\t\tif (status < 0 &&\n\t\t    status != -EPIPE &&\n\t\t    status != -ESHUTDOWN) {\n\t\t\tif (netif_msg_rx_err (dev))\nfail_halt:\n\t\t\t\tnetdev_err(dev->net, \"can't clear rx halt, status %d\\n\",\n\t\t\t\t\t   status);\n\t\t} else {\n\t\t\tclear_bit (EVENT_RX_HALT, &dev->flags);\n\t\t\ttasklet_schedule (&dev->bh);\n\t\t}\n\t}\n\n\t \n\tif (test_bit (EVENT_RX_MEMORY, &dev->flags)) {\n\t\tstruct urb\t*urb = NULL;\n\t\tint resched = 1;\n\n\t\tif (netif_running (dev->net))\n\t\t\turb = usb_alloc_urb (0, GFP_KERNEL);\n\t\telse\n\t\t\tclear_bit (EVENT_RX_MEMORY, &dev->flags);\n\t\tif (urb != NULL) {\n\t\t\tclear_bit (EVENT_RX_MEMORY, &dev->flags);\n\t\t\tstatus = usb_autopm_get_interface(dev->intf);\n\t\t\tif (status < 0) {\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\tgoto fail_lowmem;\n\t\t\t}\n\t\t\tif (rx_submit (dev, urb, GFP_KERNEL) == -ENOLINK)\n\t\t\t\tresched = 0;\n\t\t\tusb_autopm_put_interface(dev->intf);\nfail_lowmem:\n\t\t\tif (resched)\n\t\t\t\ttasklet_schedule (&dev->bh);\n\t\t}\n\t}\n\n\tif (test_bit (EVENT_LINK_RESET, &dev->flags)) {\n\t\tconst struct driver_info *info = dev->driver_info;\n\t\tint\t\t\tretval = 0;\n\n\t\tclear_bit (EVENT_LINK_RESET, &dev->flags);\n\t\tstatus = usb_autopm_get_interface(dev->intf);\n\t\tif (status < 0)\n\t\t\tgoto skip_reset;\n\t\tif(info->link_reset && (retval = info->link_reset(dev)) < 0) {\n\t\t\tusb_autopm_put_interface(dev->intf);\nskip_reset:\n\t\t\tnetdev_info(dev->net, \"link reset failed (%d) usbnet usb-%s-%s, %s\\n\",\n\t\t\t\t    retval,\n\t\t\t\t    dev->udev->bus->bus_name,\n\t\t\t\t    dev->udev->devpath,\n\t\t\t\t    info->description);\n\t\t} else {\n\t\t\tusb_autopm_put_interface(dev->intf);\n\t\t}\n\n\t\t \n\t\t__handle_link_change(dev);\n\t}\n\n\tif (test_bit (EVENT_LINK_CHANGE, &dev->flags))\n\t\t__handle_link_change(dev);\n\n\tif (test_bit (EVENT_SET_RX_MODE, &dev->flags))\n\t\t__handle_set_rx_mode(dev);\n\n\n\tif (dev->flags)\n\t\tnetdev_dbg(dev->net, \"kevent done, flags = 0x%lx\\n\", dev->flags);\n}\n\n \n\nstatic void tx_complete (struct urb *urb)\n{\n\tstruct sk_buff\t\t*skb = (struct sk_buff *) urb->context;\n\tstruct skb_data\t\t*entry = (struct skb_data *) skb->cb;\n\tstruct usbnet\t\t*dev = entry->dev;\n\n\tif (urb->status == 0) {\n\t\tstruct pcpu_sw_netstats *stats64 = this_cpu_ptr(dev->net->tstats);\n\t\tunsigned long flags;\n\n\t\tflags = u64_stats_update_begin_irqsave(&stats64->syncp);\n\t\tu64_stats_add(&stats64->tx_packets, entry->packets);\n\t\tu64_stats_add(&stats64->tx_bytes, entry->length);\n\t\tu64_stats_update_end_irqrestore(&stats64->syncp, flags);\n\t} else {\n\t\tdev->net->stats.tx_errors++;\n\n\t\tswitch (urb->status) {\n\t\tcase -EPIPE:\n\t\t\tusbnet_defer_kevent (dev, EVENT_TX_HALT);\n\t\t\tbreak;\n\n\t\t \n\t\tcase -ECONNRESET:\t\t \n\t\tcase -ESHUTDOWN:\t\t \n\t\t\tbreak;\n\n\t\t \n\t\tcase -EPROTO:\n\t\tcase -ETIME:\n\t\tcase -EILSEQ:\n\t\t\tusb_mark_last_busy(dev->udev);\n\t\t\tif (!timer_pending (&dev->delay)) {\n\t\t\t\tmod_timer (&dev->delay,\n\t\t\t\t\tjiffies + THROTTLE_JIFFIES);\n\t\t\t\tnetif_dbg(dev, link, dev->net,\n\t\t\t\t\t  \"tx throttle %d\\n\", urb->status);\n\t\t\t}\n\t\t\tnetif_stop_queue (dev->net);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetif_dbg(dev, tx_err, dev->net,\n\t\t\t\t  \"tx err %d\\n\", entry->urb->status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tusb_autopm_put_interface_async(dev->intf);\n\t(void) defer_bh(dev, skb, &dev->txq, tx_done);\n}\n\n \n\nvoid usbnet_tx_timeout (struct net_device *net, unsigned int txqueue)\n{\n\tstruct usbnet\t\t*dev = netdev_priv(net);\n\n\tunlink_urbs (dev, &dev->txq);\n\ttasklet_schedule (&dev->bh);\n\t \n\tif (dev->driver_info->recover)\n\t\t(dev->driver_info->recover)(dev);\n}\nEXPORT_SYMBOL_GPL(usbnet_tx_timeout);\n\n \n\nstatic int build_dma_sg(const struct sk_buff *skb, struct urb *urb)\n{\n\tunsigned num_sgs, total_len = 0;\n\tint i, s = 0;\n\n\tnum_sgs = skb_shinfo(skb)->nr_frags + 1;\n\tif (num_sgs == 1)\n\t\treturn 0;\n\n\t \n\turb->sg = kmalloc_array(num_sgs + 1, sizeof(struct scatterlist),\n\t\t\t\tGFP_ATOMIC);\n\tif (!urb->sg)\n\t\treturn -ENOMEM;\n\n\turb->num_sgs = num_sgs;\n\tsg_init_table(urb->sg, urb->num_sgs + 1);\n\n\tsg_set_buf(&urb->sg[s++], skb->data, skb_headlen(skb));\n\ttotal_len += skb_headlen(skb);\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tskb_frag_t *f = &skb_shinfo(skb)->frags[i];\n\n\t\ttotal_len += skb_frag_size(f);\n\t\tsg_set_page(&urb->sg[i + s], skb_frag_page(f), skb_frag_size(f),\n\t\t\t    skb_frag_off(f));\n\t}\n\turb->transfer_buffer_length = total_len;\n\n\treturn 1;\n}\n\nnetdev_tx_t usbnet_start_xmit (struct sk_buff *skb,\n\t\t\t\t     struct net_device *net)\n{\n\tstruct usbnet\t\t*dev = netdev_priv(net);\n\tunsigned int\t\t\tlength;\n\tstruct urb\t\t*urb = NULL;\n\tstruct skb_data\t\t*entry;\n\tconst struct driver_info *info = dev->driver_info;\n\tunsigned long\t\tflags;\n\tint retval;\n\n\tif (skb)\n\t\tskb_tx_timestamp(skb);\n\n\t\n\t\n\tif (info->tx_fixup) {\n\t\tskb = info->tx_fixup (dev, skb, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\t \n\t\t\tif (info->flags & FLAG_MULTI_PACKET)\n\t\t\t\tgoto not_drop;\n\t\t\tnetif_dbg(dev, tx_err, dev->net, \"can't tx_fixup skb\\n\");\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (!(urb = usb_alloc_urb (0, GFP_ATOMIC))) {\n\t\tnetif_dbg(dev, tx_err, dev->net, \"no urb\\n\");\n\t\tgoto drop;\n\t}\n\n\tentry = (struct skb_data *) skb->cb;\n\tentry->urb = urb;\n\tentry->dev = dev;\n\n\tusb_fill_bulk_urb (urb, dev->udev, dev->out,\n\t\t\tskb->data, skb->len, tx_complete, skb);\n\tif (dev->can_dma_sg) {\n\t\tif (build_dma_sg(skb, urb) < 0)\n\t\t\tgoto drop;\n\t}\n\tlength = urb->transfer_buffer_length;\n\n\t \n\tif (length % dev->maxpacket == 0) {\n\t\tif (!(info->flags & FLAG_SEND_ZLP)) {\n\t\t\tif (!(info->flags & FLAG_MULTI_PACKET)) {\n\t\t\t\tlength++;\n\t\t\t\tif (skb_tailroom(skb) && !urb->num_sgs) {\n\t\t\t\t\tskb->data[skb->len] = 0;\n\t\t\t\t\t__skb_put(skb, 1);\n\t\t\t\t} else if (urb->num_sgs)\n\t\t\t\t\tsg_set_buf(&urb->sg[urb->num_sgs++],\n\t\t\t\t\t\t\tdev->padding_pkt, 1);\n\t\t\t}\n\t\t} else\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t}\n\turb->transfer_buffer_length = length;\n\n\tif (info->flags & FLAG_MULTI_PACKET) {\n\t\t \n\t\tentry->length += length;\n\t\tif (WARN_ON_ONCE(entry->length <= 0))\n\t\t\tentry->length = length;\n\t} else {\n\t\tusbnet_set_skb_tx_stats(skb, 1, length);\n\t}\n\n\tspin_lock_irqsave(&dev->txq.lock, flags);\n\tretval = usb_autopm_get_interface_async(dev->intf);\n\tif (retval < 0) {\n\t\tspin_unlock_irqrestore(&dev->txq.lock, flags);\n\t\tgoto drop;\n\t}\n\tif (netif_queue_stopped(net)) {\n\t\tusb_autopm_put_interface_async(dev->intf);\n\t\tspin_unlock_irqrestore(&dev->txq.lock, flags);\n\t\tgoto drop;\n\t}\n\n#ifdef CONFIG_PM\n\t \n\tif (test_bit(EVENT_DEV_ASLEEP, &dev->flags)) {\n\t\t \n\t\tusb_anchor_urb(urb, &dev->deferred);\n\t\t \n\t\tnetif_stop_queue(net);\n\t\tusb_put_urb(urb);\n\t\tspin_unlock_irqrestore(&dev->txq.lock, flags);\n\t\tnetdev_dbg(dev->net, \"Delaying transmission for resumption\\n\");\n\t\tgoto deferred;\n\t}\n#endif\n\n\tswitch ((retval = usb_submit_urb (urb, GFP_ATOMIC))) {\n\tcase -EPIPE:\n\t\tnetif_stop_queue (net);\n\t\tusbnet_defer_kevent (dev, EVENT_TX_HALT);\n\t\tusb_autopm_put_interface_async(dev->intf);\n\t\tbreak;\n\tdefault:\n\t\tusb_autopm_put_interface_async(dev->intf);\n\t\tnetif_dbg(dev, tx_err, dev->net,\n\t\t\t  \"tx: submit urb err %d\\n\", retval);\n\t\tbreak;\n\tcase 0:\n\t\tnetif_trans_update(net);\n\t\t__usbnet_queue_skb(&dev->txq, skb, tx_start);\n\t\tif (dev->txq.qlen >= TX_QLEN (dev))\n\t\t\tnetif_stop_queue (net);\n\t}\n\tspin_unlock_irqrestore (&dev->txq.lock, flags);\n\n\tif (retval) {\n\t\tnetif_dbg(dev, tx_err, dev->net, \"drop, code %d\\n\", retval);\ndrop:\n\t\tdev->net->stats.tx_dropped++;\nnot_drop:\n\t\tif (skb)\n\t\t\tdev_kfree_skb_any (skb);\n\t\tif (urb) {\n\t\t\tkfree(urb->sg);\n\t\t\tusb_free_urb(urb);\n\t\t}\n\t} else\n\t\tnetif_dbg(dev, tx_queued, dev->net,\n\t\t\t  \"> tx, len %u, type 0x%x\\n\", length, skb->protocol);\n#ifdef CONFIG_PM\ndeferred:\n#endif\n\treturn NETDEV_TX_OK;\n}\nEXPORT_SYMBOL_GPL(usbnet_start_xmit);\n\nstatic int rx_alloc_submit(struct usbnet *dev, gfp_t flags)\n{\n\tstruct urb\t*urb;\n\tint\t\ti;\n\tint\t\tret = 0;\n\n\t \n\tfor (i = 0; i < 10 && dev->rxq.qlen < RX_QLEN(dev); i++) {\n\t\turb = usb_alloc_urb(0, flags);\n\t\tif (urb != NULL) {\n\t\t\tret = rx_submit(dev, urb, flags);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\nerr:\n\treturn ret;\n}\n\nstatic inline void usb_free_skb(struct sk_buff *skb)\n{\n\tstruct skb_data *entry = (struct skb_data *)skb->cb;\n\n\tusb_free_urb(entry->urb);\n\tdev_kfree_skb(skb);\n}\n\n \n\n \n\nstatic void usbnet_bh (struct timer_list *t)\n{\n\tstruct usbnet\t\t*dev = from_timer(dev, t, delay);\n\tstruct sk_buff\t\t*skb;\n\tstruct skb_data\t\t*entry;\n\n\twhile ((skb = skb_dequeue (&dev->done))) {\n\t\tentry = (struct skb_data *) skb->cb;\n\t\tswitch (entry->state) {\n\t\tcase rx_done:\n\t\t\tif (rx_process(dev, skb))\n\t\t\t\tusb_free_skb(skb);\n\t\t\tcontinue;\n\t\tcase tx_done:\n\t\t\tkfree(entry->urb->sg);\n\t\t\tfallthrough;\n\t\tcase rx_cleanup:\n\t\t\tusb_free_skb(skb);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tnetdev_dbg(dev->net, \"bogus skb state %d\\n\", entry->state);\n\t\t}\n\t}\n\n\t \n\tclear_bit(EVENT_RX_KILL, &dev->flags);\n\n\t \n\tif (waitqueue_active(&dev->wait)) {\n\t\tif (dev->txq.qlen + dev->rxq.qlen + dev->done.qlen == 0)\n\t\t\twake_up_all(&dev->wait);\n\n\t \n\t} else if (netif_running (dev->net) &&\n\t\t   netif_device_present (dev->net) &&\n\t\t   netif_carrier_ok(dev->net) &&\n\t\t   !timer_pending(&dev->delay) &&\n\t\t   !test_bit(EVENT_RX_PAUSED, &dev->flags) &&\n\t\t   !test_bit(EVENT_RX_HALT, &dev->flags)) {\n\t\tint\ttemp = dev->rxq.qlen;\n\n\t\tif (temp < RX_QLEN(dev)) {\n\t\t\tif (rx_alloc_submit(dev, GFP_ATOMIC) == -ENOLINK)\n\t\t\t\treturn;\n\t\t\tif (temp != dev->rxq.qlen)\n\t\t\t\tnetif_dbg(dev, link, dev->net,\n\t\t\t\t\t  \"rxqlen %d --> %d\\n\",\n\t\t\t\t\t  temp, dev->rxq.qlen);\n\t\t\tif (dev->rxq.qlen < RX_QLEN(dev))\n\t\t\t\ttasklet_schedule (&dev->bh);\n\t\t}\n\t\tif (dev->txq.qlen < TX_QLEN (dev))\n\t\t\tnetif_wake_queue (dev->net);\n\t}\n}\n\nstatic void usbnet_bh_tasklet(struct tasklet_struct *t)\n{\n\tstruct usbnet *dev = from_tasklet(dev, t, bh);\n\n\tusbnet_bh(&dev->delay);\n}\n\n\n \n\n \n\nvoid usbnet_disconnect (struct usb_interface *intf)\n{\n\tstruct usbnet\t\t*dev;\n\tstruct usb_device\t*xdev;\n\tstruct net_device\t*net;\n\tstruct urb\t\t*urb;\n\n\tdev = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\tif (!dev)\n\t\treturn;\n\n\txdev = interface_to_usbdev (intf);\n\n\tnetif_info(dev, probe, dev->net, \"unregister '%s' usb-%s-%s, %s\\n\",\n\t\t   intf->dev.driver->name,\n\t\t   xdev->bus->bus_name, xdev->devpath,\n\t\t   dev->driver_info->description);\n\n\tnet = dev->net;\n\tunregister_netdev (net);\n\n\twhile ((urb = usb_get_from_anchor(&dev->deferred))) {\n\t\tdev_kfree_skb(urb->context);\n\t\tkfree(urb->sg);\n\t\tusb_free_urb(urb);\n\t}\n\n\tif (dev->driver_info->unbind)\n\t\tdev->driver_info->unbind(dev, intf);\n\n\tusb_kill_urb(dev->interrupt);\n\tusb_free_urb(dev->interrupt);\n\tkfree(dev->padding_pkt);\n\n\tfree_percpu(net->tstats);\n\tfree_netdev(net);\n}\nEXPORT_SYMBOL_GPL(usbnet_disconnect);\n\nstatic const struct net_device_ops usbnet_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_set_rx_mode\t= usbnet_set_rx_mode,\n\t.ndo_change_mtu\t\t= usbnet_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n \n\n \n\nstatic struct device_type wlan_type = {\n\t.name\t= \"wlan\",\n};\n\nstatic struct device_type wwan_type = {\n\t.name\t= \"wwan\",\n};\n\nint\nusbnet_probe (struct usb_interface *udev, const struct usb_device_id *prod)\n{\n\tstruct usbnet\t\t\t*dev;\n\tstruct net_device\t\t*net;\n\tstruct usb_host_interface\t*interface;\n\tconst struct driver_info\t*info;\n\tstruct usb_device\t\t*xdev;\n\tint\t\t\t\tstatus;\n\tconst char\t\t\t*name;\n\tstruct usb_driver \t*driver = to_usb_driver(udev->dev.driver);\n\n\t \n\tif (!driver->supports_autosuspend) {\n\t\tdriver->supports_autosuspend = 1;\n\t\tpm_runtime_enable(&udev->dev);\n\t}\n\n\tname = udev->dev.driver->name;\n\tinfo = (const struct driver_info *) prod->driver_info;\n\tif (!info) {\n\t\tdev_dbg (&udev->dev, \"blacklisted by %s\\n\", name);\n\t\treturn -ENODEV;\n\t}\n\txdev = interface_to_usbdev (udev);\n\tinterface = udev->cur_altsetting;\n\n\tstatus = -ENOMEM;\n\n\t \n\tnet = alloc_etherdev(sizeof(*dev));\n\tif (!net)\n\t\tgoto out;\n\n\t \n\tSET_NETDEV_DEV(net, &udev->dev);\n\n\tdev = netdev_priv(net);\n\tdev->udev = xdev;\n\tdev->intf = udev;\n\tdev->driver_info = info;\n\tdev->driver_name = name;\n\tdev->rx_speed = SPEED_UNSET;\n\tdev->tx_speed = SPEED_UNSET;\n\n\tnet->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!net->tstats)\n\t\tgoto out0;\n\n\tdev->msg_enable = netif_msg_init (msg_level, NETIF_MSG_DRV\n\t\t\t\t| NETIF_MSG_PROBE | NETIF_MSG_LINK);\n\tinit_waitqueue_head(&dev->wait);\n\tskb_queue_head_init (&dev->rxq);\n\tskb_queue_head_init (&dev->txq);\n\tskb_queue_head_init (&dev->done);\n\tskb_queue_head_init(&dev->rxq_pause);\n\ttasklet_setup(&dev->bh, usbnet_bh_tasklet);\n\tINIT_WORK (&dev->kevent, usbnet_deferred_kevent);\n\tinit_usb_anchor(&dev->deferred);\n\ttimer_setup(&dev->delay, usbnet_bh, 0);\n\tmutex_init (&dev->phy_mutex);\n\tmutex_init(&dev->interrupt_mutex);\n\tdev->interrupt_count = 0;\n\n\tdev->net = net;\n\tstrscpy(net->name, \"usb%d\", sizeof(net->name));\n\teth_hw_addr_set(net, node_id);\n\n\t \n\tdev->hard_mtu = net->mtu + net->hard_header_len;\n\tnet->min_mtu = 0;\n\tnet->max_mtu = ETH_MAX_MTU;\n\n\tnet->netdev_ops = &usbnet_netdev_ops;\n\tnet->watchdog_timeo = TX_TIMEOUT_JIFFIES;\n\tnet->ethtool_ops = &usbnet_ethtool_ops;\n\n\t \n\t \n\tif (info->bind) {\n\t\tstatus = info->bind (dev, udev);\n\t\tif (status < 0)\n\t\t\tgoto out1;\n\n\t\t \n\t\t \n\t\t\n\t\tif ((dev->driver_info->flags & FLAG_ETHER) != 0 &&\n\t\t    ((dev->driver_info->flags & FLAG_POINTTOPOINT) == 0 ||\n\t\t     (net->dev_addr [0] & 0x02) == 0))\n\t\t\tstrscpy(net->name, \"eth%d\", sizeof(net->name));\n\t\t \n\t\tif ((dev->driver_info->flags & FLAG_WLAN) != 0)\n\t\t\tstrscpy(net->name, \"wlan%d\", sizeof(net->name));\n\t\t \n\t\tif ((dev->driver_info->flags & FLAG_WWAN) != 0)\n\t\t\tstrscpy(net->name, \"wwan%d\", sizeof(net->name));\n\n\t\t \n\t\tif ((dev->driver_info->flags & FLAG_NOARP) != 0)\n\t\t\tnet->flags |= IFF_NOARP;\n\n\t\t \n\t\tif (net->mtu > (dev->hard_mtu - net->hard_header_len))\n\t\t\tnet->mtu = dev->hard_mtu - net->hard_header_len;\n\t} else if (!info->in || !info->out)\n\t\tstatus = usbnet_get_endpoints (dev, udev);\n\telse {\n\t\tu8 ep_addrs[3] = {\n\t\t\tinfo->in + USB_DIR_IN, info->out + USB_DIR_OUT, 0\n\t\t};\n\n\t\tdev->in = usb_rcvbulkpipe (xdev, info->in);\n\t\tdev->out = usb_sndbulkpipe (xdev, info->out);\n\t\tif (!(info->flags & FLAG_NO_SETINT))\n\t\t\tstatus = usb_set_interface (xdev,\n\t\t\t\tinterface->desc.bInterfaceNumber,\n\t\t\t\tinterface->desc.bAlternateSetting);\n\t\telse\n\t\t\tstatus = 0;\n\n\t\tif (status == 0 && !usb_check_bulk_endpoints(udev, ep_addrs))\n\t\t\tstatus = -EINVAL;\n\t}\n\tif (status >= 0 && dev->status)\n\t\tstatus = init_status (dev, udev);\n\tif (status < 0)\n\t\tgoto out3;\n\n\tif (!dev->rx_urb_size)\n\t\tdev->rx_urb_size = dev->hard_mtu;\n\tdev->maxpacket = usb_maxpacket(dev->udev, dev->out);\n\tif (dev->maxpacket == 0) {\n\t\t \n\t\tstatus = -ENODEV;\n\t\tgoto out4;\n\t}\n\n\t \n\tif (ether_addr_equal(net->dev_addr, node_id))\n\t\tnet->addr_assign_type = NET_ADDR_RANDOM;\n\n\tif ((dev->driver_info->flags & FLAG_WLAN) != 0)\n\t\tSET_NETDEV_DEVTYPE(net, &wlan_type);\n\tif ((dev->driver_info->flags & FLAG_WWAN) != 0)\n\t\tSET_NETDEV_DEVTYPE(net, &wwan_type);\n\n\t \n\tusbnet_update_max_qlen(dev);\n\n\tif (dev->can_dma_sg && !(info->flags & FLAG_SEND_ZLP) &&\n\t\t!(info->flags & FLAG_MULTI_PACKET)) {\n\t\tdev->padding_pkt = kzalloc(1, GFP_KERNEL);\n\t\tif (!dev->padding_pkt) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto out4;\n\t\t}\n\t}\n\n\tstatus = register_netdev (net);\n\tif (status)\n\t\tgoto out5;\n\tnetif_info(dev, probe, dev->net,\n\t\t   \"register '%s' at usb-%s-%s, %s, %pM\\n\",\n\t\t   udev->dev.driver->name,\n\t\t   xdev->bus->bus_name, xdev->devpath,\n\t\t   dev->driver_info->description,\n\t\t   net->dev_addr);\n\n\t \n\tusb_set_intfdata (udev, dev);\n\n\tnetif_device_attach (net);\n\n\tif (dev->driver_info->flags & FLAG_LINK_INTR)\n\t\tusbnet_link_change(dev, 0, 0);\n\n\treturn 0;\n\nout5:\n\tkfree(dev->padding_pkt);\nout4:\n\tusb_free_urb(dev->interrupt);\nout3:\n\tif (info->unbind)\n\t\tinfo->unbind (dev, udev);\nout1:\n\t \n\tcancel_work_sync(&dev->kevent);\n\tdel_timer_sync(&dev->delay);\n\tfree_percpu(net->tstats);\nout0:\n\tfree_netdev(net);\nout:\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usbnet_probe);\n\n \n\n \n\nint usbnet_suspend (struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usbnet\t\t*dev = usb_get_intfdata(intf);\n\n\tif (!dev->suspend_count++) {\n\t\tspin_lock_irq(&dev->txq.lock);\n\t\t \n\t\tif (dev->txq.qlen && PMSG_IS_AUTO(message)) {\n\t\t\tdev->suspend_count--;\n\t\t\tspin_unlock_irq(&dev->txq.lock);\n\t\t\treturn -EBUSY;\n\t\t} else {\n\t\t\tset_bit(EVENT_DEV_ASLEEP, &dev->flags);\n\t\t\tspin_unlock_irq(&dev->txq.lock);\n\t\t}\n\t\t \n\t\tnetif_device_detach (dev->net);\n\t\tusbnet_terminate_urbs(dev);\n\t\t__usbnet_status_stop_force(dev);\n\n\t\t \n\t\tnetif_device_attach (dev->net);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usbnet_suspend);\n\nint usbnet_resume (struct usb_interface *intf)\n{\n\tstruct usbnet\t\t*dev = usb_get_intfdata(intf);\n\tstruct sk_buff          *skb;\n\tstruct urb              *res;\n\tint                     retval;\n\n\tif (!--dev->suspend_count) {\n\t\t \n\t\t__usbnet_status_start_force(dev, GFP_NOIO);\n\n\t\tspin_lock_irq(&dev->txq.lock);\n\t\twhile ((res = usb_get_from_anchor(&dev->deferred))) {\n\n\t\t\tskb = (struct sk_buff *)res->context;\n\t\t\tretval = usb_submit_urb(res, GFP_ATOMIC);\n\t\t\tif (retval < 0) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tkfree(res->sg);\n\t\t\t\tusb_free_urb(res);\n\t\t\t\tusb_autopm_put_interface_async(dev->intf);\n\t\t\t} else {\n\t\t\t\tnetif_trans_update(dev->net);\n\t\t\t\t__skb_queue_tail(&dev->txq, skb);\n\t\t\t}\n\t\t}\n\n\t\tsmp_mb();\n\t\tclear_bit(EVENT_DEV_ASLEEP, &dev->flags);\n\t\tspin_unlock_irq(&dev->txq.lock);\n\n\t\tif (test_bit(EVENT_DEV_OPEN, &dev->flags)) {\n\t\t\t \n\t\t\tif (netif_device_present(dev->net) &&\n\t\t\t\t!timer_pending(&dev->delay) &&\n\t\t\t\t!test_bit(EVENT_RX_HALT, &dev->flags))\n\t\t\t\t\trx_alloc_submit(dev, GFP_NOIO);\n\n\t\t\tif (!(dev->txq.qlen >= TX_QLEN(dev)))\n\t\t\t\tnetif_tx_wake_all_queues(dev->net);\n\t\t\ttasklet_schedule (&dev->bh);\n\t\t}\n\t}\n\n\tif (test_and_clear_bit(EVENT_DEVICE_REPORT_IDLE, &dev->flags))\n\t\tusb_autopm_get_interface_no_resume(intf);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usbnet_resume);\n\n \nvoid usbnet_device_suggests_idle(struct usbnet *dev)\n{\n\tif (!test_and_set_bit(EVENT_DEVICE_REPORT_IDLE, &dev->flags)) {\n\t\tdev->intf->needs_remote_wakeup = 1;\n\t\tusb_autopm_put_interface_async(dev->intf);\n\t}\n}\nEXPORT_SYMBOL(usbnet_device_suggests_idle);\n\n \nint usbnet_manage_power(struct usbnet *dev, int on)\n{\n\tdev->intf->needs_remote_wakeup = on;\n\treturn 0;\n}\nEXPORT_SYMBOL(usbnet_manage_power);\n\nvoid usbnet_link_change(struct usbnet *dev, bool link, bool need_reset)\n{\n\t \n\tif (link && !need_reset)\n\t\tnetif_carrier_on(dev->net);\n\telse\n\t\tnetif_carrier_off(dev->net);\n\n\tif (need_reset && link)\n\t\tusbnet_defer_kevent(dev, EVENT_LINK_RESET);\n\telse\n\t\tusbnet_defer_kevent(dev, EVENT_LINK_CHANGE);\n}\nEXPORT_SYMBOL(usbnet_link_change);\n\n \nstatic int __usbnet_read_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,\n\t\t\t     u16 value, u16 index, void *data, u16 size)\n{\n\tvoid *buf = NULL;\n\tint err = -ENOMEM;\n\n\tnetdev_dbg(dev->net, \"usbnet_read_cmd cmd=0x%02x reqtype=%02x\"\n\t\t   \" value=0x%04x index=0x%04x size=%d\\n\",\n\t\t   cmd, reqtype, value, index, size);\n\n\tif (size) {\n\t\tbuf = kmalloc(size, GFP_NOIO);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t}\n\n\terr = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t      cmd, reqtype, value, index, buf, size,\n\t\t\t      USB_CTRL_GET_TIMEOUT);\n\tif (err > 0 && err <= size) {\n\t\tif (data)\n\t\t\tmemcpy(data, buf, err);\n\t\telse\n\t\t\tnetdev_dbg(dev->net,\n\t\t\t\t   \"Huh? Data requested but thrown away.\\n\");\n\t}\n\tkfree(buf);\nout:\n\treturn err;\n}\n\nstatic int __usbnet_write_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,\n\t\t\t      u16 value, u16 index, const void *data,\n\t\t\t      u16 size)\n{\n\tvoid *buf = NULL;\n\tint err = -ENOMEM;\n\n\tnetdev_dbg(dev->net, \"usbnet_write_cmd cmd=0x%02x reqtype=%02x\"\n\t\t   \" value=0x%04x index=0x%04x size=%d\\n\",\n\t\t   cmd, reqtype, value, index, size);\n\n\tif (data) {\n\t\tbuf = kmemdup(data, size, GFP_NOIO);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t} else {\n        if (size) {\n            WARN_ON_ONCE(1);\n            err = -EINVAL;\n            goto out;\n        }\n    }\n\n\terr = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t      cmd, reqtype, value, index, buf, size,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tkfree(buf);\n\nout:\n\treturn err;\n}\n\n \nint usbnet_read_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,\n\t\t    u16 value, u16 index, void *data, u16 size)\n{\n\tint ret;\n\n\tif (usb_autopm_get_interface(dev->intf) < 0)\n\t\treturn -ENODEV;\n\tret = __usbnet_read_cmd(dev, cmd, reqtype, value, index,\n\t\t\t\tdata, size);\n\tusb_autopm_put_interface(dev->intf);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usbnet_read_cmd);\n\n \nint usbnet_write_cmd(struct usbnet *dev, u8 cmd, u8 reqtype,\n\t\t     u16 value, u16 index, const void *data, u16 size)\n{\n\tint ret;\n\n\tif (usb_autopm_get_interface(dev->intf) < 0)\n\t\treturn -ENODEV;\n\tret = __usbnet_write_cmd(dev, cmd, reqtype, value, index,\n\t\t\t\t data, size);\n\tusb_autopm_put_interface(dev->intf);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usbnet_write_cmd);\n\n \nint usbnet_read_cmd_nopm(struct usbnet *dev, u8 cmd, u8 reqtype,\n\t\t\t  u16 value, u16 index, void *data, u16 size)\n{\n\treturn __usbnet_read_cmd(dev, cmd, reqtype, value, index,\n\t\t\t\t data, size);\n}\nEXPORT_SYMBOL_GPL(usbnet_read_cmd_nopm);\n\n \nint usbnet_write_cmd_nopm(struct usbnet *dev, u8 cmd, u8 reqtype,\n\t\t\t  u16 value, u16 index, const void *data,\n\t\t\t  u16 size)\n{\n\treturn __usbnet_write_cmd(dev, cmd, reqtype, value, index,\n\t\t\t\t  data, size);\n}\nEXPORT_SYMBOL_GPL(usbnet_write_cmd_nopm);\n\nstatic void usbnet_async_cmd_cb(struct urb *urb)\n{\n\tstruct usb_ctrlrequest *req = (struct usb_ctrlrequest *)urb->context;\n\tint status = urb->status;\n\n\tif (status < 0)\n\t\tdev_dbg(&urb->dev->dev, \"%s failed with %d\",\n\t\t\t__func__, status);\n\n\tkfree(req);\n\tusb_free_urb(urb);\n}\n\n \nint usbnet_write_cmd_async(struct usbnet *dev, u8 cmd, u8 reqtype,\n\t\t\t   u16 value, u16 index, const void *data, u16 size)\n{\n\tstruct usb_ctrlrequest *req;\n\tstruct urb *urb;\n\tint err = -ENOMEM;\n\tvoid *buf = NULL;\n\n\tnetdev_dbg(dev->net, \"usbnet_write_cmd cmd=0x%02x reqtype=%02x\"\n\t\t   \" value=0x%04x index=0x%04x size=%d\\n\",\n\t\t   cmd, reqtype, value, index, size);\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto fail;\n\n\tif (data) {\n\t\tbuf = kmemdup(data, size, GFP_ATOMIC);\n\t\tif (!buf) {\n\t\t\tnetdev_err(dev->net, \"Error allocating buffer\"\n\t\t\t\t   \" in %s!\\n\", __func__);\n\t\t\tgoto fail_free_urb;\n\t\t}\n\t}\n\n\treq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);\n\tif (!req)\n\t\tgoto fail_free_buf;\n\n\treq->bRequestType = reqtype;\n\treq->bRequest = cmd;\n\treq->wValue = cpu_to_le16(value);\n\treq->wIndex = cpu_to_le16(index);\n\treq->wLength = cpu_to_le16(size);\n\n\tusb_fill_control_urb(urb, dev->udev,\n\t\t\t     usb_sndctrlpipe(dev->udev, 0),\n\t\t\t     (void *)req, buf, size,\n\t\t\t     usbnet_async_cmd_cb, req);\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tnetdev_err(dev->net, \"Error submitting the control\"\n\t\t\t   \" message: status=%d\\n\", err);\n\t\tgoto fail_free_all;\n\t}\n\treturn 0;\n\nfail_free_all:\n\tkfree(req);\nfail_free_buf:\n\tkfree(buf);\n\t \n\turb->transfer_flags = 0;\nfail_free_urb:\n\tusb_free_urb(urb);\nfail:\n\treturn err;\n\n}\nEXPORT_SYMBOL_GPL(usbnet_write_cmd_async);\n \n\nstatic int __init usbnet_init(void)\n{\n\t \n\tBUILD_BUG_ON(\n\t\tsizeof_field(struct sk_buff, cb) < sizeof(struct skb_data));\n\n\teth_random_addr(node_id);\n\treturn 0;\n}\nmodule_init(usbnet_init);\n\nstatic void __exit usbnet_exit(void)\n{\n}\nmodule_exit(usbnet_exit);\n\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_DESCRIPTION(\"USB network driver framework\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}