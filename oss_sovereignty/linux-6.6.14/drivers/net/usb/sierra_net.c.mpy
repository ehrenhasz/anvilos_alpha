{
  "module_name": "sierra_net.c",
  "hash_id": "7b214bcb71078232bf79ffe8e8b60bc1f2d29d3377179d19e20df68ee0f1fa0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/sierra_net.c",
  "human_readable_source": "\n \n\n#define DRIVER_VERSION \"v.2.0\"\n#define DRIVER_AUTHOR \"Paxton Smith, Matthew Safar, Rory Filer\"\n#define DRIVER_DESC \"USB-to-WWAN Driver for Sierra Wireless modems\"\nstatic const char driver_name[] = \"sierra_net\";\n\n \n \n\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <net/ip.h>\n#include <net/udp.h>\n#include <asm/unaligned.h>\n#include <linux/usb/usbnet.h>\n\n#define SWI_USB_REQUEST_GET_FW_ATTR\t0x06\n#define SWI_GET_FW_ATTR_MASK\t\t0x08\n\n \nstatic\tatomic_t iface_counter = ATOMIC_INIT(0);\n\n \n#define SIERRA_NET_SYNCDELAY (2*HZ)\n\n \n#define SIERRA_NET_MAX_SUPPORTED_MTU\t1500\n\n \n#define SIERRA_NET_USBCTL_BUF_LEN\t1024\n\n \n#define SIERRA_NET_RX_URB_SIZE\t\t(8 * 1024)\n\n \nstruct sierra_net_data {\n\n\tu16 link_up;\t\t \n\tu8 tx_hdr_template[4];\t \n\n\tu8 sync_msg[4];\t\t \n\tu8 shdwn_msg[4];\t \n\n\t \n\tstruct usbnet *usbnet;\n\n\tu8 ifnum;\t \n\n \n#define SIERRA_NET_EVENT_RESP_AVAIL    0x01\n#define SIERRA_NET_TIMER_EXPIRY        0x02\n\tunsigned long kevent_flags;\n\tstruct work_struct sierra_net_kevent;\n\tstruct timer_list sync_timer;  \n};\n\nstruct param {\n\tint is_present;\n\tunion {\n\t\tvoid  *ptr;\n\t\tu32    dword;\n\t\tu16    word;\n\t\tu8     byte;\n\t};\n};\n\n \n#define SIERRA_NET_HIP_EXTENDEDID\t0x7F\n#define SIERRA_NET_HIP_HSYNC_ID\t\t0x60\t \n#define SIERRA_NET_HIP_RESTART_ID\t0x62\t \n#define SIERRA_NET_HIP_MSYNC_ID\t\t0x20\t \n#define SIERRA_NET_HIP_SHUTD_ID\t\t0x26\t \n\n#define SIERRA_NET_HIP_EXT_IP_IN_ID   0x0202\n#define SIERRA_NET_HIP_EXT_IP_OUT_ID  0x0002\n\n \n#define SIERRA_NET_HIP_LSI_UMTSID\t0x78\n\n \n#define SIERRA_NET_HIP_RCGI\t\t0x64\n\n \n#define SIERRA_NET_PROTOCOL_UMTS      0x01\n#define SIERRA_NET_PROTOCOL_UMTS_DS   0x04\n \n#define SIERRA_NET_COVERAGE_NONE      0x00\n#define SIERRA_NET_COVERAGE_NOPACKET  0x01\n\n \n#define SIERRA_NET_SESSION_IDLE       0x00\n \n#define SIERRA_NET_AS_LINK_TYPE_IPV4  0x00\n#define SIERRA_NET_AS_LINK_TYPE_IPV6  0x02\n\nstruct lsi_umts {\n\tu8 protocol;\n\tu8 unused1;\n\t__be16 length;\n\t \n\tu8 coverage;\n\tu8 network_len;  \n\tu8 network[40];  \n\tu8 session_state;\n\tu8 unused3[33];\n} __packed;\n\nstruct lsi_umts_single {\n\tstruct lsi_umts lsi;\n\tu8 link_type;\n\tu8 pdp_addr_len;  \n\tu8 pdp_addr[16];  \n\tu8 unused4[23];\n\tu8 dns1_addr_len;  \n\tu8 dns1_addr[16];  \n\tu8 dns2_addr_len;  \n\tu8 dns2_addr[16];  \n\tu8 wins1_addr_len;  \n\tu8 wins1_addr[16];  \n\tu8 wins2_addr_len;  \n\tu8 wins2_addr[16];  \n\tu8 unused5[4];\n\tu8 gw_addr_len;  \n\tu8 gw_addr[16];  \n\tu8 reserved[8];\n} __packed;\n\nstruct lsi_umts_dual {\n\tstruct lsi_umts lsi;\n\tu8 pdp_addr4_len;  \n\tu8 pdp_addr4[4];   \n\tu8 pdp_addr6_len;  \n\tu8 pdp_addr6[16];  \n\tu8 unused4[23];\n\tu8 dns1_addr4_len;  \n\tu8 dns1_addr4[4];   \n\tu8 dns1_addr6_len;  \n\tu8 dns1_addr6[16];  \n\tu8 dns2_addr4_len;  \n\tu8 dns2_addr4[4];   \n\tu8 dns2_addr6_len;  \n\tu8 dns2_addr6[16];  \n\tu8 unused5[68];\n} __packed;\n\n#define SIERRA_NET_LSI_COMMON_LEN      4\n#define SIERRA_NET_LSI_UMTS_LEN        (sizeof(struct lsi_umts_single))\n#define SIERRA_NET_LSI_UMTS_STATUS_LEN \\\n\t(SIERRA_NET_LSI_UMTS_LEN - SIERRA_NET_LSI_COMMON_LEN)\n#define SIERRA_NET_LSI_UMTS_DS_LEN     (sizeof(struct lsi_umts_dual))\n#define SIERRA_NET_LSI_UMTS_DS_STATUS_LEN \\\n\t(SIERRA_NET_LSI_UMTS_DS_LEN - SIERRA_NET_LSI_COMMON_LEN)\n\n \nstatic const struct net_device_ops sierra_net_device_ops = {\n\t.ndo_open               = usbnet_open,\n\t.ndo_stop               = usbnet_stop,\n\t.ndo_start_xmit         = usbnet_start_xmit,\n\t.ndo_tx_timeout         = usbnet_tx_timeout,\n\t.ndo_change_mtu         = usbnet_change_mtu,\n\t.ndo_get_stats64        = dev_get_tstats64,\n\t.ndo_set_mac_address    = eth_mac_addr,\n\t.ndo_validate_addr      = eth_validate_addr,\n};\n\n \nstatic inline struct sierra_net_data *sierra_net_get_private(struct usbnet *dev)\n{\n\treturn (struct sierra_net_data *)dev->data[0];\n}\n\n \nstatic inline void sierra_net_set_private(struct usbnet *dev,\n\t\t\tstruct sierra_net_data *priv)\n{\n\tdev->data[0] = (unsigned long)priv;\n}\n\n \nstatic inline int is_ip(struct sk_buff *skb)\n{\n\treturn skb->protocol == cpu_to_be16(ETH_P_IP) ||\n\t       skb->protocol == cpu_to_be16(ETH_P_IPV6);\n}\n\n \nstatic int check_ethip_packet(struct sk_buff *skb, struct usbnet *dev)\n{\n\tskb_reset_mac_header(skb);  \n\n\tif (skb_is_nonlinear(skb)) {\n\t\tnetdev_err(dev->net, \"Non linear buffer-dropping\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!pskb_may_pull(skb, ETH_HLEN))\n\t\treturn 0;\n\tskb->protocol = eth_hdr(skb)->h_proto;\n\n\treturn 1;\n}\n\nstatic const u8 *save16bit(struct param *p, const u8 *datap)\n{\n\tp->is_present = 1;\n\tp->word = get_unaligned_be16(datap);\n\treturn datap + sizeof(p->word);\n}\n\nstatic const u8 *save8bit(struct param *p, const u8 *datap)\n{\n\tp->is_present = 1;\n\tp->byte = *datap;\n\treturn datap + sizeof(p->byte);\n}\n\n \n \n#define SIERRA_NET_HIP_HDR_LEN 4\n \n#define SIERRA_NET_HIP_EXT_HDR_LEN 6\n\nstruct hip_hdr {\n\tint    hdrlen;\n\tstruct param payload_len;\n\tstruct param msgid;\n\tstruct param msgspecific;\n\tstruct param extmsgid;\n};\n\nstatic int parse_hip(const u8 *buf, const u32 buflen, struct hip_hdr *hh)\n{\n\tconst u8 *curp = buf;\n\tint    padded;\n\n\tif (buflen < SIERRA_NET_HIP_HDR_LEN)\n\t\treturn -EPROTO;\n\n\tcurp = save16bit(&hh->payload_len, curp);\n\tcurp = save8bit(&hh->msgid, curp);\n\tcurp = save8bit(&hh->msgspecific, curp);\n\n\tpadded = hh->msgid.byte & 0x80;\n\thh->msgid.byte &= 0x7F;\t\t\t \n\n\thh->extmsgid.is_present = (hh->msgid.byte == SIERRA_NET_HIP_EXTENDEDID);\n\tif (hh->extmsgid.is_present) {\n\t\tif (buflen < SIERRA_NET_HIP_EXT_HDR_LEN)\n\t\t\treturn -EPROTO;\n\n\t\thh->payload_len.word &= 0x3FFF;  \n\n\t\tcurp = save16bit(&hh->extmsgid, curp);\n\t\thh->extmsgid.word &= 0x03FF;\t \n\n\t\thh->hdrlen = SIERRA_NET_HIP_EXT_HDR_LEN;\n\t} else {\n\t\thh->payload_len.word &= 0x07FF;\t \n\t\thh->hdrlen = SIERRA_NET_HIP_HDR_LEN;\n\t}\n\n\tif (padded) {\n\t\thh->hdrlen++;\n\t\thh->payload_len.word--;\n\t}\n\n\t \n\tif (buflen < (hh->hdrlen + hh->payload_len.word))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void build_hip(u8 *buf, const u16 payloadlen,\n\t\tstruct sierra_net_data *priv)\n{\n\t \n\tput_unaligned_be16(payloadlen, buf);\n\tmemcpy(buf+2, priv->tx_hdr_template, sizeof(priv->tx_hdr_template));\n}\n \n\nstatic int sierra_net_send_cmd(struct usbnet *dev,\n\t\tu8 *cmd, int cmdlen, const char * cmd_name)\n{\n\tstruct sierra_net_data *priv = sierra_net_get_private(dev);\n\tint  status;\n\n\tstatus = usbnet_write_cmd(dev, USB_CDC_SEND_ENCAPSULATED_COMMAND,\n\t\t\t\t  USB_DIR_OUT|USB_TYPE_CLASS|USB_RECIP_INTERFACE,\n\t\t\t\t  0, priv->ifnum, cmd, cmdlen);\n\n\tif (status != cmdlen && status != -ENODEV)\n\t\tnetdev_err(dev->net, \"Submit %s failed %d\\n\", cmd_name, status);\n\n\treturn status;\n}\n\nstatic int sierra_net_send_sync(struct usbnet *dev)\n{\n\tint  status;\n\tstruct sierra_net_data *priv = sierra_net_get_private(dev);\n\n\tdev_dbg(&dev->udev->dev, \"%s\", __func__);\n\n\tstatus = sierra_net_send_cmd(dev, priv->sync_msg,\n\t\t\tsizeof(priv->sync_msg), \"SYNC\");\n\n\treturn status;\n}\n\nstatic void sierra_net_set_ctx_index(struct sierra_net_data *priv, u8 ctx_ix)\n{\n\tdev_dbg(&(priv->usbnet->udev->dev), \"%s %d\", __func__, ctx_ix);\n\tpriv->tx_hdr_template[0] = 0x3F;\n\tpriv->tx_hdr_template[1] = ctx_ix;\n\t*((__be16 *)&priv->tx_hdr_template[2]) =\n\t\tcpu_to_be16(SIERRA_NET_HIP_EXT_IP_OUT_ID);\n}\n\nstatic int sierra_net_parse_lsi(struct usbnet *dev, char *data, int datalen)\n{\n\tstruct lsi_umts *lsi = (struct lsi_umts *)data;\n\tu32 expected_length;\n\n\tif (datalen < sizeof(struct lsi_umts_single)) {\n\t\tnetdev_err(dev->net, \"%s: Data length %d, exp >= %zu\\n\",\n\t\t\t   __func__, datalen, sizeof(struct lsi_umts_single));\n\t\treturn -1;\n\t}\n\n\t \n\tif (lsi->session_state == SIERRA_NET_SESSION_IDLE) {\n\t\tnetdev_err(dev->net, \"Session idle, 0x%02x\\n\",\n\t\t\t   lsi->session_state);\n\t\treturn 0;\n\t}\n\n\t \n\tif (lsi->protocol == SIERRA_NET_PROTOCOL_UMTS) {\n\t\tstruct lsi_umts_single *single = (struct lsi_umts_single *)lsi;\n\n\t\t \n\t\tif (single->link_type != SIERRA_NET_AS_LINK_TYPE_IPV4 &&\n\t\t    single->link_type != SIERRA_NET_AS_LINK_TYPE_IPV6) {\n\t\t\tnetdev_err(dev->net, \"Link type unsupported: 0x%02x\\n\",\n\t\t\t\t   single->link_type);\n\t\t\treturn -1;\n\t\t}\n\t\texpected_length = SIERRA_NET_LSI_UMTS_STATUS_LEN;\n\t} else if (lsi->protocol == SIERRA_NET_PROTOCOL_UMTS_DS) {\n\t\texpected_length = SIERRA_NET_LSI_UMTS_DS_STATUS_LEN;\n\t} else {\n\t\tnetdev_err(dev->net, \"Protocol unsupported, 0x%02x\\n\",\n\t\t\t   lsi->protocol);\n\t\treturn -1;\n\t}\n\n\tif (be16_to_cpu(lsi->length) != expected_length) {\n\t\tnetdev_err(dev->net, \"%s: LSI_UMTS_STATUS_LEN %d, exp %u\\n\",\n\t\t\t   __func__, be16_to_cpu(lsi->length), expected_length);\n\t\treturn -1;\n\t}\n\n\t \n\tif (lsi->coverage == SIERRA_NET_COVERAGE_NONE ||\n\t    lsi->coverage == SIERRA_NET_COVERAGE_NOPACKET) {\n\t\tnetdev_err(dev->net, \"No coverage, 0x%02x\\n\", lsi->coverage);\n\t\treturn 0;\n\t}\n\n\t \n\treturn 1;\n}\n\nstatic void sierra_net_handle_lsi(struct usbnet *dev, char *data,\n\t\tstruct hip_hdr\t*hh)\n{\n\tstruct sierra_net_data *priv = sierra_net_get_private(dev);\n\tint link_up;\n\n\tlink_up = sierra_net_parse_lsi(dev, data + hh->hdrlen,\n\t\t\t\t\thh->payload_len.word);\n\tif (link_up < 0) {\n\t\tnetdev_err(dev->net, \"Invalid LSI\\n\");\n\t\treturn;\n\t}\n\tif (link_up) {\n\t\tsierra_net_set_ctx_index(priv, hh->msgspecific.byte);\n\t\tpriv->link_up = 1;\n\t} else {\n\t\tpriv->link_up = 0;\n\t}\n\tusbnet_link_change(dev, link_up, 0);\n}\n\nstatic void sierra_net_dosync(struct usbnet *dev)\n{\n\tint status;\n\tstruct sierra_net_data *priv = sierra_net_get_private(dev);\n\n\tdev_dbg(&dev->udev->dev, \"%s\", __func__);\n\n\t \n\n\t \n\tstatus = sierra_net_send_sync(dev);\n\tif (status < 0)\n\t\tnetdev_err(dev->net,\n\t\t\t\"Send SYNC failed, status %d\\n\", status);\n\tstatus = sierra_net_send_sync(dev);\n\tif (status < 0)\n\t\tnetdev_err(dev->net,\n\t\t\t\"Send SYNC failed, status %d\\n\", status);\n\n\t \n\tpriv->sync_timer.expires = jiffies + SIERRA_NET_SYNCDELAY;\n\tadd_timer(&priv->sync_timer);\n}\n\nstatic void sierra_net_kevent(struct work_struct *work)\n{\n\tstruct sierra_net_data *priv =\n\t\tcontainer_of(work, struct sierra_net_data, sierra_net_kevent);\n\tstruct usbnet *dev = priv->usbnet;\n\tint  len;\n\tint  err;\n\tu8  *buf;\n\tu8   ifnum;\n\n\tif (test_bit(SIERRA_NET_EVENT_RESP_AVAIL, &priv->kevent_flags)) {\n\t\tclear_bit(SIERRA_NET_EVENT_RESP_AVAIL, &priv->kevent_flags);\n\n\t\t \n\t\tbuf = kzalloc(SIERRA_NET_USBCTL_BUF_LEN, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn;\n\n\t\tifnum = priv->ifnum;\n\t\tlen = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t\tUSB_CDC_GET_ENCAPSULATED_RESPONSE,\n\t\t\t\tUSB_DIR_IN|USB_TYPE_CLASS|USB_RECIP_INTERFACE,\n\t\t\t\t0, ifnum, buf, SIERRA_NET_USBCTL_BUF_LEN,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\n\t\tif (len < 0) {\n\t\t\tnetdev_err(dev->net,\n\t\t\t\t\"usb_control_msg failed, status %d\\n\", len);\n\t\t} else {\n\t\t\tstruct hip_hdr\thh;\n\n\t\t\tdev_dbg(&dev->udev->dev, \"%s: Received status message,\"\n\t\t\t\t\" %04x bytes\", __func__, len);\n\n\t\t\terr = parse_hip(buf, len, &hh);\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(dev->net, \"%s: Bad packet,\"\n\t\t\t\t\t\" parse result %d\\n\", __func__, err);\n\t\t\t\tkfree(buf);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (len != hh.hdrlen + hh.payload_len.word) {\n\t\t\t\tnetdev_err(dev->net, \"%s: Bad packet, received\"\n\t\t\t\t\t\" %d, expected %d\\n\",\t__func__, len,\n\t\t\t\t\thh.hdrlen + hh.payload_len.word);\n\t\t\t\tkfree(buf);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tswitch (hh.msgid.byte) {\n\t\t\tcase SIERRA_NET_HIP_LSI_UMTSID:\n\t\t\t\tdev_dbg(&dev->udev->dev, \"LSI for ctx:%d\",\n\t\t\t\t\thh.msgspecific.byte);\n\t\t\t\tsierra_net_handle_lsi(dev, buf, &hh);\n\t\t\t\tbreak;\n\t\t\tcase SIERRA_NET_HIP_RESTART_ID:\n\t\t\t\tdev_dbg(&dev->udev->dev, \"Restart reported: %d,\"\n\t\t\t\t\t\t\" stopping sync timer\",\n\t\t\t\t\t\thh.msgspecific.byte);\n\t\t\t\t \n\t\t\t\tdel_timer_sync(&priv->sync_timer);\n\t\t\t\tclear_bit(SIERRA_NET_TIMER_EXPIRY,\n\t\t\t\t\t  &priv->kevent_flags);\n\t\t\t\tbreak;\n\t\t\tcase SIERRA_NET_HIP_HSYNC_ID:\n\t\t\t\tdev_dbg(&dev->udev->dev, \"SYNC received\");\n\t\t\t\terr = sierra_net_send_sync(dev);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tnetdev_err(dev->net,\n\t\t\t\t\t\t\"Send SYNC failed %d\\n\", err);\n\t\t\t\tbreak;\n\t\t\tcase SIERRA_NET_HIP_EXTENDEDID:\n\t\t\t\tnetdev_err(dev->net, \"Unrecognized HIP msg, \"\n\t\t\t\t\t\"extmsgid 0x%04x\\n\", hh.extmsgid.word);\n\t\t\t\tbreak;\n\t\t\tcase SIERRA_NET_HIP_RCGI:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnetdev_err(dev->net, \"Unrecognized HIP msg, \"\n\t\t\t\t\t\"msgid 0x%02x\\n\", hh.msgid.byte);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tkfree(buf);\n\t}\n\t \n\tif (test_bit(SIERRA_NET_TIMER_EXPIRY, &priv->kevent_flags)) {\n\t\tclear_bit(SIERRA_NET_TIMER_EXPIRY, &priv->kevent_flags);\n\t\tdev_dbg(&dev->udev->dev, \"Deferred sync timer expiry\");\n\t\tsierra_net_dosync(priv->usbnet);\n\t}\n\n\tif (priv->kevent_flags)\n\t\tdev_dbg(&dev->udev->dev, \"sierra_net_kevent done, \"\n\t\t\t\"kevent_flags = 0x%lx\", priv->kevent_flags);\n}\n\nstatic void sierra_net_defer_kevent(struct usbnet *dev, int work)\n{\n\tstruct sierra_net_data *priv = sierra_net_get_private(dev);\n\n\tset_bit(work, &priv->kevent_flags);\n\tschedule_work(&priv->sierra_net_kevent);\n}\n\n \nstatic void sierra_sync_timer(struct timer_list *t)\n{\n\tstruct sierra_net_data *priv = from_timer(priv, t, sync_timer);\n\tstruct usbnet *dev = priv->usbnet;\n\n\tdev_dbg(&dev->udev->dev, \"%s\", __func__);\n\t \n\tsierra_net_defer_kevent(dev, SIERRA_NET_TIMER_EXPIRY);\n}\n\nstatic void sierra_net_status(struct usbnet *dev, struct urb *urb)\n{\n\tstruct usb_cdc_notification *event;\n\n\tdev_dbg(&dev->udev->dev, \"%s\", __func__);\n\n\tif (urb->actual_length < sizeof *event)\n\t\treturn;\n\n\t \n\tevent = urb->transfer_buffer;\n\tswitch (event->bNotificationType) {\n\tcase USB_CDC_NOTIFY_NETWORK_CONNECTION:\n\tcase USB_CDC_NOTIFY_SPEED_CHANGE:\n\t\t \n\t\tbreak;\n\tcase USB_CDC_NOTIFY_RESPONSE_AVAILABLE:\n\t\tsierra_net_defer_kevent(dev, SIERRA_NET_EVENT_RESP_AVAIL);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(dev->net, \": unexpected notification %02x!\\n\",\n\t\t\t\tevent->bNotificationType);\n\t\tbreak;\n\t}\n}\n\nstatic void sierra_net_get_drvinfo(struct net_device *net,\n\t\tstruct ethtool_drvinfo *info)\n{\n\t \n\tusbnet_get_drvinfo(net, info);\n\tstrscpy(info->driver, driver_name, sizeof(info->driver));\n\tstrscpy(info->version, DRIVER_VERSION, sizeof(info->version));\n}\n\nstatic u32 sierra_net_get_link(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\t \n\treturn sierra_net_get_private(dev)->link_up && netif_running(net);\n}\n\nstatic const struct ethtool_ops sierra_net_ethtool_ops = {\n\t.get_drvinfo = sierra_net_get_drvinfo,\n\t.get_link = sierra_net_get_link,\n\t.get_msglevel = usbnet_get_msglevel,\n\t.set_msglevel = usbnet_set_msglevel,\n\t.nway_reset = usbnet_nway_reset,\n\t.get_link_ksettings = usbnet_get_link_ksettings_mii,\n\t.set_link_ksettings = usbnet_set_link_ksettings_mii,\n};\n\nstatic int sierra_net_get_fw_attr(struct usbnet *dev, u16 *datap)\n{\n\tint result = 0;\n\t__le16 attrdata;\n\n\tresult = usbnet_read_cmd(dev,\n\t\t\t\t \n\t\t\t\tSWI_USB_REQUEST_GET_FW_ATTR,\n\t\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR,\t \n\t\t\t\t0x0000,\t\t \n\t\t\t\t0x0000,\t\t \n\t\t\t\t&attrdata,\t \n\t\t\t\tsizeof(attrdata)\t \n\t\t\t\t);\n\n\tif (result < 0)\n\t\treturn -EIO;\n\n\t*datap = le16_to_cpu(attrdata);\n\treturn result;\n}\n\n \nstatic int sierra_net_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tu8\tifacenum;\n\tu8\tnumendpoints;\n\tu16\tfwattr = 0;\n\tint\tstatus;\n\tstruct sierra_net_data *priv;\n\tstatic const u8 sync_tmplate[sizeof(priv->sync_msg)] = {\n\t\t0x00, 0x00, SIERRA_NET_HIP_MSYNC_ID, 0x00};\n\tstatic const u8 shdwn_tmplate[sizeof(priv->shdwn_msg)] = {\n\t\t0x00, 0x00, SIERRA_NET_HIP_SHUTD_ID, 0x00};\n\tu8 mod[2];\n\n\tdev_dbg(&dev->udev->dev, \"%s\", __func__);\n\n\tifacenum = intf->cur_altsetting->desc.bInterfaceNumber;\n\tnumendpoints = intf->cur_altsetting->desc.bNumEndpoints;\n\t \n\tif (numendpoints != 3) {\n\t\tdev_err(&dev->udev->dev, \"Expected 3 endpoints, found: %d\",\n\t\t\tnumendpoints);\n\t\treturn -ENODEV;\n\t}\n\t \n\tdev->status = NULL;\n\tstatus = usbnet_get_endpoints(dev, intf);\n\tif (status < 0) {\n\t\tdev_err(&dev->udev->dev, \"Error in usbnet_get_endpoints (%d)\",\n\t\t\tstatus);\n\t\treturn -ENODEV;\n\t}\n\t \n\tpriv = kzalloc(sizeof *priv, GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->usbnet = dev;\n\tpriv->ifnum = ifacenum;\n\tdev->net->netdev_ops = &sierra_net_device_ops;\n\n\t \n\tmod[0] = atomic_inc_return(&iface_counter);\n\tmod[1] = ifacenum;\n\tdev_addr_mod(dev->net, ETH_ALEN - 2, mod, 2);\n\n\t \n\tmemcpy(priv->shdwn_msg, shdwn_tmplate, sizeof(priv->shdwn_msg));\n\t \n\tsierra_net_set_ctx_index(priv, 0);\n\n\t \n\tmemcpy(priv->sync_msg, sync_tmplate, sizeof(priv->sync_msg));\n\n\t \n\tdev->rx_urb_size  = SIERRA_NET_RX_URB_SIZE;\n\tif (dev->udev->speed != USB_SPEED_HIGH)\n\t\tdev->rx_urb_size  = min_t(size_t, 4096, SIERRA_NET_RX_URB_SIZE);\n\n\tdev->net->hard_header_len += SIERRA_NET_HIP_EXT_HDR_LEN;\n\tdev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\n\tdev->net->max_mtu = SIERRA_NET_MAX_SUPPORTED_MTU;\n\n\t \n\tdev->net->flags |= IFF_NOARP;\n\tdev->net->ethtool_ops = &sierra_net_ethtool_ops;\n\tnetif_carrier_off(dev->net);\n\n\tsierra_net_set_private(dev, priv);\n\n\tpriv->kevent_flags = 0;\n\n\t \n\tINIT_WORK(&priv->sierra_net_kevent, sierra_net_kevent);\n\n\t \n\ttimer_setup(&priv->sync_timer, sierra_sync_timer, 0);\n\n\t \n\tstatus = sierra_net_get_fw_attr(dev, &fwattr);\n\tdev_dbg(&dev->udev->dev, \"Fw attr: %x\\n\", fwattr);\n\n\t \n\tif (!(status == sizeof(fwattr) && (fwattr & SWI_GET_FW_ATTR_MASK))) {\n\t\t \n\t\tdev_err(&dev->udev->dev, \"Incompatible driver and firmware\"\n\t\t\t\" versions\\n\");\n\t\tkfree(priv);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void sierra_net_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint status;\n\tstruct sierra_net_data *priv = sierra_net_get_private(dev);\n\n\tdev_dbg(&dev->udev->dev, \"%s\", __func__);\n\n\t \n\ttimer_shutdown_sync(&priv->sync_timer);\n\tcancel_work_sync(&priv->sierra_net_kevent);\n\n\t \n\tstatus = sierra_net_send_cmd(dev, priv->shdwn_msg,\n\t\t\tsizeof(priv->shdwn_msg), \"Shutdown\");\n\tif (status < 0)\n\t\tnetdev_err(dev->net,\n\t\t\t\"usb_control_msg failed, status %d\\n\", status);\n\n\tusbnet_status_stop(dev);\n\n\tsierra_net_set_private(dev, NULL);\n\tkfree(priv);\n}\n\nstatic struct sk_buff *sierra_net_skb_clone(struct usbnet *dev,\n\t\tstruct sk_buff *skb, int len)\n{\n\tstruct sk_buff *new_skb;\n\n\t \n\tnew_skb = skb_clone(skb, GFP_ATOMIC);\n\n\t \n\tskb_pull(skb, len);\n\n\t \n\tif (new_skb) {\n\t\tskb_trim(new_skb, len);\n\t} else {\n\t\tif (netif_msg_rx_err(dev))\n\t\t\tnetdev_err(dev->net, \"failed to get skb\\n\");\n\t\tdev->net->stats.rx_dropped++;\n\t}\n\n\treturn new_skb;\n}\n\n \nstatic int sierra_net_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tint err;\n\tstruct hip_hdr  hh;\n\tstruct sk_buff *new_skb;\n\n\tdev_dbg(&dev->udev->dev, \"%s\", __func__);\n\n\t \n\twhile (likely(skb->len)) {\n\t\terr = parse_hip(skb->data, skb->len, &hh);\n\t\tif (err) {\n\t\t\tif (netif_msg_rx_err(dev))\n\t\t\t\tnetdev_err(dev->net, \"Invalid HIP header %d\\n\",\n\t\t\t\t\terr);\n\t\t\t \n\t\t\tdev->net->stats.rx_length_errors++;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (!hh.extmsgid.is_present\n\t\t    || hh.extmsgid.word != SIERRA_NET_HIP_EXT_IP_IN_ID) {\n\t\t\tif (netif_msg_rx_err(dev))\n\t\t\t\tnetdev_err(dev->net, \"HIP/ETH: Invalid pkt\\n\");\n\n\t\t\tdev->net->stats.rx_frame_errors++;\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\n\t\tskb_pull(skb, hh.hdrlen);\n\n\t\t \n\t\tskb_reset_mac_header(skb);\n\t\tif (eth_hdr(skb)->h_proto != cpu_to_be16(ETH_P_IPV6))\n\t\t\teth_hdr(skb)->h_proto = cpu_to_be16(ETH_P_IP);\n\t\teth_zero_addr(eth_hdr(skb)->h_source);\n\t\tmemcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);\n\n\t\t \n\t\tif (hh.payload_len.word == skb->len)\n\t\t\treturn 1;\n\n\t\tnew_skb = sierra_net_skb_clone(dev, skb, hh.payload_len.word);\n\t\tif (new_skb)\n\t\t\tusbnet_skb_return(dev, new_skb);\n\n\t}  \n\n\treturn 0;\n}\n\n \nstatic struct sk_buff *sierra_net_tx_fixup(struct usbnet *dev,\n\t\t\t\t\t   struct sk_buff *skb, gfp_t flags)\n{\n\tstruct sierra_net_data *priv = sierra_net_get_private(dev);\n\tu16 len;\n\tbool need_tail;\n\n\tBUILD_BUG_ON(sizeof_field(struct usbnet, data)\n\t\t\t\t< sizeof(struct cdc_state));\n\n\tdev_dbg(&dev->udev->dev, \"%s\", __func__);\n\tif (priv->link_up && check_ethip_packet(skb, dev) && is_ip(skb)) {\n\t\t \n\t\tif (SIERRA_NET_HIP_EXT_HDR_LEN <= skb_headroom(skb)) {\n\t\t\t \n\t\t\tlen = skb->len;\n\t\t\tskb_push(skb, SIERRA_NET_HIP_EXT_HDR_LEN);\n\t\t\t \n\t\t\tneed_tail = ((len + SIERRA_NET_HIP_EXT_HDR_LEN)\n\t\t\t\t% dev->maxpacket == 0);\n\t\t\tif (need_tail) {\n\t\t\t\tif (unlikely(skb_tailroom(skb) == 0)) {\n\t\t\t\t\tnetdev_err(dev->net, \"tx_fixup:\"\n\t\t\t\t\t\t\"no room for packet\\n\");\n\t\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\t\treturn NULL;\n\t\t\t\t} else {\n\t\t\t\t\tskb->data[skb->len] = 0;\n\t\t\t\t\t__skb_put(skb, 1);\n\t\t\t\t\tlen = len + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuild_hip(skb->data, len, priv);\n\t\t\treturn skb;\n\t\t} else {\n\t\t\t \n\t\t\tnetdev_err(dev->net, \"tx_fixup: no room for HIP\\n\");\n\t\t}  \n\t}\n\n\tif (!priv->link_up)\n\t\tdev->net->stats.tx_carrier_errors++;\n\n\t \n\n\t \n\tdev_kfree_skb_any(skb);\n\treturn NULL;\n}\n\nstatic const struct driver_info sierra_net_info_direct_ip = {\n\t.description = \"Sierra Wireless USB-to-WWAN Modem\",\n\t.flags = FLAG_WWAN | FLAG_SEND_ZLP,\n\t.bind = sierra_net_bind,\n\t.unbind = sierra_net_unbind,\n\t.status = sierra_net_status,\n\t.rx_fixup = sierra_net_rx_fixup,\n\t.tx_fixup = sierra_net_tx_fixup,\n};\n\nstatic int\nsierra_net_probe(struct usb_interface *udev, const struct usb_device_id *prod)\n{\n\tint ret;\n\n\tret = usbnet_probe(udev, prod);\n\tif (ret == 0) {\n\t\tstruct usbnet *dev = usb_get_intfdata(udev);\n\n\t\tret = usbnet_status_start(dev, GFP_KERNEL);\n\t\tif (ret == 0) {\n\t\t\t \n\t\t\tsierra_net_dosync(dev);\n\t\t}\n\t}\n\treturn ret;\n}\n\n#define DIRECT_IP_DEVICE(vend, prod) \\\n\t{USB_DEVICE_INTERFACE_NUMBER(vend, prod, 7), \\\n\t.driver_info = (unsigned long)&sierra_net_info_direct_ip}, \\\n\t{USB_DEVICE_INTERFACE_NUMBER(vend, prod, 10), \\\n\t.driver_info = (unsigned long)&sierra_net_info_direct_ip}, \\\n\t{USB_DEVICE_INTERFACE_NUMBER(vend, prod, 11), \\\n\t.driver_info = (unsigned long)&sierra_net_info_direct_ip}\n\nstatic const struct usb_device_id products[] = {\n\tDIRECT_IP_DEVICE(0x1199, 0x68A3),  \n\tDIRECT_IP_DEVICE(0x0F3D, 0x68A3),  \n\tDIRECT_IP_DEVICE(0x1199, 0x68AA),  \n\tDIRECT_IP_DEVICE(0x0F3D, 0x68AA),  \n\n\t{},  \n};\nMODULE_DEVICE_TABLE(usb, products);\n\n \nstatic struct usb_driver sierra_net_driver = {\n\t.name = \"sierra_net\",\n\t.id_table = products,\n\t.probe = sierra_net_probe,\n\t.disconnect = usbnet_disconnect,\n\t.suspend = usbnet_suspend,\n\t.resume = usbnet_resume,\n\t.no_dynamic_id = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(sierra_net_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}