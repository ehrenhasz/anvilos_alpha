{
  "module_name": "ax88179_178a.c",
  "hash_id": "f921a1a848ddeac832b5b767af798c0d0dfb50b6a2125343d819db0545744fd3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/ax88179_178a.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/crc32.h>\n#include <linux/usb/usbnet.h>\n#include <uapi/linux/mdio.h>\n#include <linux/mdio.h>\n\n#define AX88179_PHY_ID\t\t\t\t0x03\n#define AX_EEPROM_LEN\t\t\t\t0x100\n#define AX88179_EEPROM_MAGIC\t\t\t0x17900b95\n#define AX_MCAST_FLTSIZE\t\t\t8\n#define AX_MAX_MCAST\t\t\t\t64\n#define AX_INT_PPLS_LINK\t\t\t((u32)BIT(16))\n#define AX_RXHDR_L4_TYPE_MASK\t\t\t0x1c\n#define AX_RXHDR_L4_TYPE_UDP\t\t\t4\n#define AX_RXHDR_L4_TYPE_TCP\t\t\t16\n#define AX_RXHDR_L3CSUM_ERR\t\t\t2\n#define AX_RXHDR_L4CSUM_ERR\t\t\t1\n#define AX_RXHDR_CRC_ERR\t\t\t((u32)BIT(29))\n#define AX_RXHDR_DROP_ERR\t\t\t((u32)BIT(31))\n#define AX_ACCESS_MAC\t\t\t\t0x01\n#define AX_ACCESS_PHY\t\t\t\t0x02\n#define AX_ACCESS_EEPROM\t\t\t0x04\n#define AX_ACCESS_EFUS\t\t\t\t0x05\n#define AX_RELOAD_EEPROM_EFUSE\t\t\t0x06\n#define AX_PAUSE_WATERLVL_HIGH\t\t\t0x54\n#define AX_PAUSE_WATERLVL_LOW\t\t\t0x55\n\n#define PHYSICAL_LINK_STATUS\t\t\t0x02\n\t#define\tAX_USB_SS\t\t0x04\n\t#define\tAX_USB_HS\t\t0x02\n\n#define GENERAL_STATUS\t\t\t\t0x03\n \n\t#define\tAX_SECLD\t\t0x04\n\n#define AX_SROM_ADDR\t\t\t\t0x07\n#define AX_SROM_CMD\t\t\t\t0x0a\n\t#define EEP_RD\t\t\t0x04\n\t#define EEP_BUSY\t\t0x10\n\n#define AX_SROM_DATA_LOW\t\t\t0x08\n#define AX_SROM_DATA_HIGH\t\t\t0x09\n\n#define AX_RX_CTL\t\t\t\t0x0b\n\t#define AX_RX_CTL_DROPCRCERR\t0x0100\n\t#define AX_RX_CTL_IPE\t\t0x0200\n\t#define AX_RX_CTL_START\t\t0x0080\n\t#define AX_RX_CTL_AP\t\t0x0020\n\t#define AX_RX_CTL_AM\t\t0x0010\n\t#define AX_RX_CTL_AB\t\t0x0008\n\t#define AX_RX_CTL_AMALL\t\t0x0002\n\t#define AX_RX_CTL_PRO\t\t0x0001\n\t#define AX_RX_CTL_STOP\t\t0x0000\n\n#define AX_NODE_ID\t\t\t\t0x10\n#define AX_MULFLTARY\t\t\t\t0x16\n\n#define AX_MEDIUM_STATUS_MODE\t\t\t0x22\n\t#define AX_MEDIUM_GIGAMODE\t0x01\n\t#define AX_MEDIUM_FULL_DUPLEX\t0x02\n\t#define AX_MEDIUM_EN_125MHZ\t0x08\n\t#define AX_MEDIUM_RXFLOW_CTRLEN\t0x10\n\t#define AX_MEDIUM_TXFLOW_CTRLEN\t0x20\n\t#define AX_MEDIUM_RECEIVE_EN\t0x100\n\t#define AX_MEDIUM_PS\t\t0x200\n\t#define AX_MEDIUM_JUMBO_EN\t0x8040\n\n#define AX_MONITOR_MOD\t\t\t\t0x24\n\t#define AX_MONITOR_MODE_RWLC\t0x02\n\t#define AX_MONITOR_MODE_RWMP\t0x04\n\t#define AX_MONITOR_MODE_PMEPOL\t0x20\n\t#define AX_MONITOR_MODE_PMETYPE\t0x40\n\n#define AX_GPIO_CTRL\t\t\t\t0x25\n\t#define AX_GPIO_CTRL_GPIO3EN\t0x80\n\t#define AX_GPIO_CTRL_GPIO2EN\t0x40\n\t#define AX_GPIO_CTRL_GPIO1EN\t0x20\n\n#define AX_PHYPWR_RSTCTL\t\t\t0x26\n\t#define AX_PHYPWR_RSTCTL_BZ\t0x0010\n\t#define AX_PHYPWR_RSTCTL_IPRL\t0x0020\n\t#define AX_PHYPWR_RSTCTL_AT\t0x1000\n\n#define AX_RX_BULKIN_QCTRL\t\t\t0x2e\n#define AX_CLK_SELECT\t\t\t\t0x33\n\t#define AX_CLK_SELECT_BCS\t0x01\n\t#define AX_CLK_SELECT_ACS\t0x02\n\t#define AX_CLK_SELECT_ULR\t0x08\n\n#define AX_RXCOE_CTL\t\t\t\t0x34\n\t#define AX_RXCOE_IP\t\t0x01\n\t#define AX_RXCOE_TCP\t\t0x02\n\t#define AX_RXCOE_UDP\t\t0x04\n\t#define AX_RXCOE_TCPV6\t\t0x20\n\t#define AX_RXCOE_UDPV6\t\t0x40\n\n#define AX_TXCOE_CTL\t\t\t\t0x35\n\t#define AX_TXCOE_IP\t\t0x01\n\t#define AX_TXCOE_TCP\t\t0x02\n\t#define AX_TXCOE_UDP\t\t0x04\n\t#define AX_TXCOE_TCPV6\t\t0x20\n\t#define AX_TXCOE_UDPV6\t\t0x40\n\n#define AX_LEDCTRL\t\t\t\t0x73\n\n#define GMII_PHY_PHYSR\t\t\t\t0x11\n\t#define GMII_PHY_PHYSR_SMASK\t0xc000\n\t#define GMII_PHY_PHYSR_GIGA\t0x8000\n\t#define GMII_PHY_PHYSR_100\t0x4000\n\t#define GMII_PHY_PHYSR_FULL\t0x2000\n\t#define GMII_PHY_PHYSR_LINK\t0x400\n\n#define GMII_LED_ACT\t\t\t\t0x1a\n\t#define\tGMII_LED_ACTIVE_MASK\t0xff8f\n\t#define\tGMII_LED0_ACTIVE\tBIT(4)\n\t#define\tGMII_LED1_ACTIVE\tBIT(5)\n\t#define\tGMII_LED2_ACTIVE\tBIT(6)\n\n#define GMII_LED_LINK\t\t\t\t0x1c\n\t#define\tGMII_LED_LINK_MASK\t0xf888\n\t#define\tGMII_LED0_LINK_10\tBIT(0)\n\t#define\tGMII_LED0_LINK_100\tBIT(1)\n\t#define\tGMII_LED0_LINK_1000\tBIT(2)\n\t#define\tGMII_LED1_LINK_10\tBIT(4)\n\t#define\tGMII_LED1_LINK_100\tBIT(5)\n\t#define\tGMII_LED1_LINK_1000\tBIT(6)\n\t#define\tGMII_LED2_LINK_10\tBIT(8)\n\t#define\tGMII_LED2_LINK_100\tBIT(9)\n\t#define\tGMII_LED2_LINK_1000\tBIT(10)\n\t#define\tLED0_ACTIVE\t\tBIT(0)\n\t#define\tLED0_LINK_10\t\tBIT(1)\n\t#define\tLED0_LINK_100\t\tBIT(2)\n\t#define\tLED0_LINK_1000\t\tBIT(3)\n\t#define\tLED0_FD\t\t\tBIT(4)\n\t#define\tLED0_USB3_MASK\t\t0x001f\n\t#define\tLED1_ACTIVE\t\tBIT(5)\n\t#define\tLED1_LINK_10\t\tBIT(6)\n\t#define\tLED1_LINK_100\t\tBIT(7)\n\t#define\tLED1_LINK_1000\t\tBIT(8)\n\t#define\tLED1_FD\t\t\tBIT(9)\n\t#define\tLED1_USB3_MASK\t\t0x03e0\n\t#define\tLED2_ACTIVE\t\tBIT(10)\n\t#define\tLED2_LINK_1000\t\tBIT(13)\n\t#define\tLED2_LINK_100\t\tBIT(12)\n\t#define\tLED2_LINK_10\t\tBIT(11)\n\t#define\tLED2_FD\t\t\tBIT(14)\n\t#define\tLED_VALID\t\tBIT(15)\n\t#define\tLED2_USB3_MASK\t\t0x7c00\n\n#define GMII_PHYPAGE\t\t\t\t0x1e\n#define GMII_PHY_PAGE_SELECT\t\t\t0x1f\n\t#define GMII_PHY_PGSEL_EXT\t0x0007\n\t#define GMII_PHY_PGSEL_PAGE0\t0x0000\n\t#define GMII_PHY_PGSEL_PAGE3\t0x0003\n\t#define GMII_PHY_PGSEL_PAGE5\t0x0005\n\nstatic int ax88179_reset(struct usbnet *dev);\n\nstruct ax88179_data {\n\tu8  eee_enabled;\n\tu8  eee_active;\n\tu16 rxctl;\n\tu8 in_pm;\n\tu32 wol_supported;\n\tu32 wolopts;\n\tu8 disconnecting;\n};\n\nstruct ax88179_int_data {\n\t__le32 intdata1;\n\t__le32 intdata2;\n};\n\nstatic const struct {\n\tunsigned char ctrl, timer_l, timer_h, size, ifg;\n} AX88179_BULKIN_SIZE[] =\t{\n\t{7, 0x4f, 0,\t0x12, 0xff},\n\t{7, 0x20, 3,\t0x16, 0xff},\n\t{7, 0xae, 7,\t0x18, 0xff},\n\t{7, 0xcc, 0x4c, 0x18, 8},\n};\n\nstatic void ax88179_set_pm_mode(struct usbnet *dev, bool pm_mode)\n{\n\tstruct ax88179_data *ax179_data = dev->driver_priv;\n\n\tax179_data->in_pm = pm_mode;\n}\n\nstatic int ax88179_in_pm(struct usbnet *dev)\n{\n\tstruct ax88179_data *ax179_data = dev->driver_priv;\n\n\treturn ax179_data->in_pm;\n}\n\nstatic int __ax88179_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\n\t\t\t      u16 size, void *data)\n{\n\tint ret;\n\tint (*fn)(struct usbnet *, u8, u8, u16, u16, void *, u16);\n\tstruct ax88179_data *ax179_data = dev->driver_priv;\n\n\tBUG_ON(!dev);\n\n\tif (!ax88179_in_pm(dev))\n\t\tfn = usbnet_read_cmd;\n\telse\n\t\tfn = usbnet_read_cmd_nopm;\n\n\tret = fn(dev, cmd, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t value, index, data, size);\n\n\tif (unlikely((ret < 0) && !(ret == -ENODEV && ax179_data->disconnecting)))\n\t\tnetdev_warn(dev->net, \"Failed to read reg index 0x%04x: %d\\n\",\n\t\t\t    index, ret);\n\n\treturn ret;\n}\n\nstatic int __ax88179_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\n\t\t\t       u16 size, const void *data)\n{\n\tint ret;\n\tint (*fn)(struct usbnet *, u8, u8, u16, u16, const void *, u16);\n\tstruct ax88179_data *ax179_data = dev->driver_priv;\n\n\tBUG_ON(!dev);\n\n\tif (!ax88179_in_pm(dev))\n\t\tfn = usbnet_write_cmd;\n\telse\n\t\tfn = usbnet_write_cmd_nopm;\n\n\tret = fn(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t value, index, data, size);\n\n\tif (unlikely((ret < 0) && !(ret == -ENODEV && ax179_data->disconnecting)))\n\t\tnetdev_warn(dev->net, \"Failed to write reg index 0x%04x: %d\\n\",\n\t\t\t    index, ret);\n\n\treturn ret;\n}\n\nstatic void ax88179_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value,\n\t\t\t\t    u16 index, u16 size, void *data)\n{\n\tu16 buf;\n\n\tif (2 == size) {\n\t\tbuf = *((u16 *)data);\n\t\tcpu_to_le16s(&buf);\n\t\tusbnet_write_cmd_async(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t       USB_RECIP_DEVICE, value, index, &buf,\n\t\t\t\t       size);\n\t} else {\n\t\tusbnet_write_cmd_async(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t       USB_RECIP_DEVICE, value, index, data,\n\t\t\t\t       size);\n\t}\n}\n\nstatic int ax88179_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\n\t\t\t    u16 size, void *data)\n{\n\tint ret;\n\n\tif (2 == size) {\n\t\tu16 buf = 0;\n\t\tret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf);\n\t\tle16_to_cpus(&buf);\n\t\t*((u16 *)data) = buf;\n\t} else if (4 == size) {\n\t\tu32 buf = 0;\n\t\tret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf);\n\t\tle32_to_cpus(&buf);\n\t\t*((u32 *)data) = buf;\n\t} else {\n\t\tret = __ax88179_read_cmd(dev, cmd, value, index, size, data);\n\t}\n\n\treturn ret;\n}\n\nstatic int ax88179_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\n\t\t\t     u16 size, const void *data)\n{\n\tint ret;\n\n\tif (2 == size) {\n\t\tu16 buf;\n\t\tbuf = *((u16 *)data);\n\t\tcpu_to_le16s(&buf);\n\t\tret = __ax88179_write_cmd(dev, cmd, value, index,\n\t\t\t\t\t  size, &buf);\n\t} else {\n\t\tret = __ax88179_write_cmd(dev, cmd, value, index,\n\t\t\t\t\t  size, data);\n\t}\n\n\treturn ret;\n}\n\nstatic void ax88179_status(struct usbnet *dev, struct urb *urb)\n{\n\tstruct ax88179_int_data *event;\n\tu32 link;\n\n\tif (urb->actual_length < 8)\n\t\treturn;\n\n\tevent = urb->transfer_buffer;\n\tle32_to_cpus((void *)&event->intdata1);\n\n\tlink = (((__force u32)event->intdata1) & AX_INT_PPLS_LINK) >> 16;\n\n\tif (netif_carrier_ok(dev->net) != link) {\n\t\tusbnet_link_change(dev, link, 1);\n\t\tnetdev_info(dev->net, \"ax88179 - Link status is: %d\\n\", link);\n\t}\n}\n\nstatic int ax88179_mdio_read(struct net_device *netdev, int phy_id, int loc)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tu16 res;\n\n\tax88179_read_cmd(dev, AX_ACCESS_PHY, phy_id, (__u16)loc, 2, &res);\n\treturn res;\n}\n\nstatic void ax88179_mdio_write(struct net_device *netdev, int phy_id, int loc,\n\t\t\t       int val)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tu16 res = (u16) val;\n\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, phy_id, (__u16)loc, 2, &res);\n}\n\nstatic inline int ax88179_phy_mmd_indirect(struct usbnet *dev, u16 prtad,\n\t\t\t\t\t   u16 devad)\n{\n\tu16 tmp16;\n\tint ret;\n\n\ttmp16 = devad;\n\tret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t\tMII_MMD_CTRL, 2, &tmp16);\n\n\ttmp16 = prtad;\n\tret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t\tMII_MMD_DATA, 2, &tmp16);\n\n\ttmp16 = devad | MII_MMD_CTRL_NOINCR;\n\tret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t\tMII_MMD_CTRL, 2, &tmp16);\n\n\treturn ret;\n}\n\nstatic int\nax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)\n{\n\tint ret;\n\tu16 tmp16;\n\n\tax88179_phy_mmd_indirect(dev, prtad, devad);\n\n\tret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t       MII_MMD_DATA, 2, &tmp16);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn tmp16;\n}\n\nstatic int\nax88179_phy_write_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad,\n\t\t\t       u16 data)\n{\n\tint ret;\n\n\tax88179_phy_mmd_indirect(dev, prtad, devad);\n\n\tret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t\tMII_MMD_DATA, 2, &data);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ax88179_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct ax88179_data *priv = dev->driver_priv;\n\tu16 tmp16;\n\tu8 tmp8;\n\n\tax88179_set_pm_mode(dev, true);\n\n\tusbnet_suspend(intf, message);\n\n\t \n\tif (priv->wolopts) {\n\t\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD,\n\t\t\t\t 1, 1, &tmp8);\n\t\tif (priv->wolopts & WAKE_PHY)\n\t\t\ttmp8 |= AX_MONITOR_MODE_RWLC;\n\t\tif (priv->wolopts & WAKE_MAGIC)\n\t\t\ttmp8 |= AX_MONITOR_MODE_RWMP;\n\n\t\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD,\n\t\t\t\t  1, 1, &tmp8);\n\t}\n\n\t \n\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\n\t\t\t 2, 2, &tmp16);\n\ttmp16 &= ~AX_MEDIUM_RECEIVE_EN;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\n\t\t\t  2, 2, &tmp16);\n\n\t \n\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,\n\t\t\t 2, 2, &tmp16);\n\n\ttmp16 |= AX_PHYPWR_RSTCTL_BZ | AX_PHYPWR_RSTCTL_IPRL;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,\n\t\t\t  2, 2, &tmp16);\n\n\t \n\ttmp8 = 0;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);\n\n\t \n\ttmp16 = AX_RX_CTL_STOP;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &tmp16);\n\n\tax88179_set_pm_mode(dev, false);\n\n\treturn 0;\n}\n\n \n \nstatic int ax88179_auto_detach(struct usbnet *dev)\n{\n\tu16 tmp16;\n\tu8 tmp8;\n\n\tif (ax88179_read_cmd(dev, AX_ACCESS_EEPROM, 0x43, 1, 2, &tmp16) < 0)\n\t\treturn 0;\n\n\tif ((tmp16 == 0xFFFF) || (!(tmp16 & 0x0100)))\n\t\treturn 0;\n\n\t \n\ttmp8 = 0;\n\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);\n\ttmp8 |= AX_CLK_SELECT_ULR;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);\n\n\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &tmp16);\n\ttmp16 |= AX_PHYPWR_RSTCTL_AT;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &tmp16);\n\n\treturn 0;\n}\n\nstatic int ax88179_resume(struct usb_interface *intf)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\n\tax88179_set_pm_mode(dev, true);\n\n\tusbnet_link_change(dev, 0, 0);\n\n\tax88179_reset(dev);\n\n\tax88179_set_pm_mode(dev, false);\n\n\treturn usbnet_resume(intf);\n}\n\nstatic void ax88179_disconnect(struct usb_interface *intf)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct ax88179_data *ax179_data;\n\n\tif (!dev)\n\t\treturn;\n\n\tax179_data = dev->driver_priv;\n\tax179_data->disconnecting = 1;\n\n\tusbnet_disconnect(intf);\n}\n\nstatic void\nax88179_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct ax88179_data *priv = dev->driver_priv;\n\n\twolinfo->supported = priv->wol_supported;\n\twolinfo->wolopts = priv->wolopts;\n}\n\nstatic int\nax88179_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct ax88179_data *priv = dev->driver_priv;\n\n\tif (wolinfo->wolopts & ~(priv->wol_supported))\n\t\treturn -EINVAL;\n\n\tpriv->wolopts = wolinfo->wolopts;\n\n\treturn 0;\n}\n\nstatic int ax88179_get_eeprom_len(struct net_device *net)\n{\n\treturn AX_EEPROM_LEN;\n}\n\nstatic int\nax88179_get_eeprom(struct net_device *net, struct ethtool_eeprom *eeprom,\n\t\t   u8 *data)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tu16 *eeprom_buff;\n\tint first_word, last_word;\n\tint i, ret;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\teeprom->magic = AX88179_EEPROM_MAGIC;\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\teeprom_buff = kmalloc_array(last_word - first_word + 1, sizeof(u16),\n\t\t\t\t    GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = first_word; i <= last_word; i++) {\n\t\tret = __ax88179_read_cmd(dev, AX_ACCESS_EEPROM, i, 1, 2,\n\t\t\t\t\t &eeprom_buff[i - first_word]);\n\t\tif (ret < 0) {\n\t\t\tkfree(eeprom_buff);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tmemcpy(data, (u8 *)eeprom_buff + (eeprom->offset & 1), eeprom->len);\n\tkfree(eeprom_buff);\n\treturn 0;\n}\n\nstatic int\nax88179_set_eeprom(struct net_device *net, struct ethtool_eeprom *eeprom,\n\t\t   u8 *data)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tu16 *eeprom_buff;\n\tint first_word;\n\tint last_word;\n\tint ret;\n\tint i;\n\n\tnetdev_dbg(net, \"write EEPROM len %d, offset %d, magic 0x%x\\n\",\n\t\t   eeprom->len, eeprom->offset, eeprom->magic);\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\tif (eeprom->magic != AX88179_EEPROM_MAGIC)\n\t\treturn -EINVAL;\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\n\teeprom_buff = kmalloc_array(last_word - first_word + 1, sizeof(u16),\n\t\t\t\t    GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\t \n\tif (eeprom->offset & 1) {\n\t\tret = ax88179_read_cmd(dev, AX_ACCESS_EEPROM, first_word, 1, 2,\n\t\t\t\t       &eeprom_buff[0]);\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(net, \"Failed to read EEPROM at offset 0x%02x.\\n\", first_word);\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif ((eeprom->offset + eeprom->len) & 1) {\n\t\tret = ax88179_read_cmd(dev, AX_ACCESS_EEPROM, last_word, 1, 2,\n\t\t\t\t       &eeprom_buff[last_word - first_word]);\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(net, \"Failed to read EEPROM at offset 0x%02x.\\n\", last_word);\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tmemcpy((u8 *)eeprom_buff + (eeprom->offset & 1), data, eeprom->len);\n\n\tfor (i = first_word; i <= last_word; i++) {\n\t\tnetdev_dbg(net, \"write to EEPROM at offset 0x%02x, data 0x%04x\\n\",\n\t\t\t   i, eeprom_buff[i - first_word]);\n\t\tret = ax88179_write_cmd(dev, AX_ACCESS_EEPROM, i, 1, 2,\n\t\t\t\t\t&eeprom_buff[i - first_word]);\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(net, \"Failed to write EEPROM at offset 0x%02x.\\n\", i);\n\t\t\tgoto free;\n\t\t}\n\t\tmsleep(20);\n\t}\n\n\t \n\tret = ax88179_write_cmd(dev, AX_RELOAD_EEPROM_EFUSE, 0x0000, 0, 0, NULL);\n\tif (ret < 0) {\n\t\tnetdev_err(net, \"Failed to reload EEPROM data\\n\");\n\t\tgoto free;\n\t}\n\n\tret = 0;\nfree:\n\tkfree(eeprom_buff);\n\treturn ret;\n}\n\nstatic int ax88179_get_link_ksettings(struct net_device *net,\n\t\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\tmii_ethtool_get_link_ksettings(&dev->mii, cmd);\n\n\treturn 0;\n}\n\nstatic int ax88179_set_link_ksettings(struct net_device *net,\n\t\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\treturn mii_ethtool_set_link_ksettings(&dev->mii, cmd);\n}\n\nstatic int\nax88179_ethtool_get_eee(struct usbnet *dev, struct ethtool_eee *data)\n{\n\tint val;\n\n\t \n\tval = ax88179_phy_read_mmd_indirect(dev, MDIO_PCS_EEE_ABLE,\n\t\t\t\t\t    MDIO_MMD_PCS);\n\tif (val < 0)\n\t\treturn val;\n\tdata->supported = mmd_eee_cap_to_ethtool_sup_t(val);\n\n\t \n\tval = ax88179_phy_read_mmd_indirect(dev, MDIO_AN_EEE_ADV,\n\t\t\t\t\t    MDIO_MMD_AN);\n\tif (val < 0)\n\t\treturn val;\n\tdata->advertised = mmd_eee_adv_to_ethtool_adv_t(val);\n\n\t \n\tval = ax88179_phy_read_mmd_indirect(dev, MDIO_AN_EEE_LPABLE,\n\t\t\t\t\t    MDIO_MMD_AN);\n\tif (val < 0)\n\t\treturn val;\n\tdata->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(val);\n\n\treturn 0;\n}\n\nstatic int\nax88179_ethtool_set_eee(struct usbnet *dev, struct ethtool_eee *data)\n{\n\tu16 tmp16 = ethtool_adv_to_mmd_eee_adv_t(data->advertised);\n\n\treturn ax88179_phy_write_mmd_indirect(dev, MDIO_AN_EEE_ADV,\n\t\t\t\t\t      MDIO_MMD_AN, tmp16);\n}\n\nstatic int ax88179_chk_eee(struct usbnet *dev)\n{\n\tstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\n\tstruct ax88179_data *priv = dev->driver_priv;\n\n\tmii_ethtool_gset(&dev->mii, &ecmd);\n\n\tif (ecmd.duplex & DUPLEX_FULL) {\n\t\tint eee_lp, eee_cap, eee_adv;\n\t\tu32 lp, cap, adv, supported = 0;\n\n\t\teee_cap = ax88179_phy_read_mmd_indirect(dev,\n\t\t\t\t\t\t\tMDIO_PCS_EEE_ABLE,\n\t\t\t\t\t\t\tMDIO_MMD_PCS);\n\t\tif (eee_cap < 0) {\n\t\t\tpriv->eee_active = 0;\n\t\t\treturn false;\n\t\t}\n\n\t\tcap = mmd_eee_cap_to_ethtool_sup_t(eee_cap);\n\t\tif (!cap) {\n\t\t\tpriv->eee_active = 0;\n\t\t\treturn false;\n\t\t}\n\n\t\teee_lp = ax88179_phy_read_mmd_indirect(dev,\n\t\t\t\t\t\t       MDIO_AN_EEE_LPABLE,\n\t\t\t\t\t\t       MDIO_MMD_AN);\n\t\tif (eee_lp < 0) {\n\t\t\tpriv->eee_active = 0;\n\t\t\treturn false;\n\t\t}\n\n\t\teee_adv = ax88179_phy_read_mmd_indirect(dev,\n\t\t\t\t\t\t\tMDIO_AN_EEE_ADV,\n\t\t\t\t\t\t\tMDIO_MMD_AN);\n\n\t\tif (eee_adv < 0) {\n\t\t\tpriv->eee_active = 0;\n\t\t\treturn false;\n\t\t}\n\n\t\tadv = mmd_eee_adv_to_ethtool_adv_t(eee_adv);\n\t\tlp = mmd_eee_adv_to_ethtool_adv_t(eee_lp);\n\t\tsupported = (ecmd.speed == SPEED_1000) ?\n\t\t\t     SUPPORTED_1000baseT_Full :\n\t\t\t     SUPPORTED_100baseT_Full;\n\n\t\tif (!(lp & adv & supported)) {\n\t\t\tpriv->eee_active = 0;\n\t\t\treturn false;\n\t\t}\n\n\t\tpriv->eee_active = 1;\n\t\treturn true;\n\t}\n\n\tpriv->eee_active = 0;\n\treturn false;\n}\n\nstatic void ax88179_disable_eee(struct usbnet *dev)\n{\n\tu16 tmp16;\n\n\ttmp16 = GMII_PHY_PGSEL_PAGE3;\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t  GMII_PHY_PAGE_SELECT, 2, &tmp16);\n\n\ttmp16 = 0x3246;\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t  MII_PHYADDR, 2, &tmp16);\n\n\ttmp16 = GMII_PHY_PGSEL_PAGE0;\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t  GMII_PHY_PAGE_SELECT, 2, &tmp16);\n}\n\nstatic void ax88179_enable_eee(struct usbnet *dev)\n{\n\tu16 tmp16;\n\n\ttmp16 = GMII_PHY_PGSEL_PAGE3;\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t  GMII_PHY_PAGE_SELECT, 2, &tmp16);\n\n\ttmp16 = 0x3247;\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t  MII_PHYADDR, 2, &tmp16);\n\n\ttmp16 = GMII_PHY_PGSEL_PAGE5;\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t  GMII_PHY_PAGE_SELECT, 2, &tmp16);\n\n\ttmp16 = 0x0680;\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t  MII_BMSR, 2, &tmp16);\n\n\ttmp16 = GMII_PHY_PGSEL_PAGE0;\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t  GMII_PHY_PAGE_SELECT, 2, &tmp16);\n}\n\nstatic int ax88179_get_eee(struct net_device *net, struct ethtool_eee *edata)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct ax88179_data *priv = dev->driver_priv;\n\n\tedata->eee_enabled = priv->eee_enabled;\n\tedata->eee_active = priv->eee_active;\n\n\treturn ax88179_ethtool_get_eee(dev, edata);\n}\n\nstatic int ax88179_set_eee(struct net_device *net, struct ethtool_eee *edata)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct ax88179_data *priv = dev->driver_priv;\n\tint ret;\n\n\tpriv->eee_enabled = edata->eee_enabled;\n\tif (!priv->eee_enabled) {\n\t\tax88179_disable_eee(dev);\n\t} else {\n\t\tpriv->eee_enabled = ax88179_chk_eee(dev);\n\t\tif (!priv->eee_enabled)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tax88179_enable_eee(dev);\n\t}\n\n\tret = ax88179_ethtool_set_eee(dev, edata);\n\tif (ret)\n\t\treturn ret;\n\n\tmii_nway_restart(&dev->mii);\n\n\tusbnet_link_change(dev, 0, 0);\n\n\treturn ret;\n}\n\nstatic int ax88179_ioctl(struct net_device *net, struct ifreq *rq, int cmd)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\treturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\n}\n\nstatic const struct ethtool_ops ax88179_ethtool_ops = {\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_msglevel\t\t= usbnet_get_msglevel,\n\t.set_msglevel\t\t= usbnet_set_msglevel,\n\t.get_wol\t\t= ax88179_get_wol,\n\t.set_wol\t\t= ax88179_set_wol,\n\t.get_eeprom_len\t\t= ax88179_get_eeprom_len,\n\t.get_eeprom\t\t= ax88179_get_eeprom,\n\t.set_eeprom\t\t= ax88179_set_eeprom,\n\t.get_eee\t\t= ax88179_get_eee,\n\t.set_eee\t\t= ax88179_set_eee,\n\t.nway_reset\t\t= usbnet_nway_reset,\n\t.get_link_ksettings\t= ax88179_get_link_ksettings,\n\t.set_link_ksettings\t= ax88179_set_link_ksettings,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n};\n\nstatic void ax88179_set_multicast(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct ax88179_data *data = dev->driver_priv;\n\tu8 *m_filter = ((u8 *)dev->data);\n\n\tdata->rxctl = (AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_CTL_IPE);\n\n\tif (net->flags & IFF_PROMISC) {\n\t\tdata->rxctl |= AX_RX_CTL_PRO;\n\t} else if (net->flags & IFF_ALLMULTI ||\n\t\t   netdev_mc_count(net) > AX_MAX_MCAST) {\n\t\tdata->rxctl |= AX_RX_CTL_AMALL;\n\t} else if (netdev_mc_empty(net)) {\n\t\t \n\t} else {\n\t\t \n\t\tu32 crc_bits;\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tmemset(m_filter, 0, AX_MCAST_FLTSIZE);\n\n\t\tnetdev_for_each_mc_addr(ha, net) {\n\t\t\tcrc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\t\t\t*(m_filter + (crc_bits >> 3)) |= (1 << (crc_bits & 7));\n\t\t}\n\n\t\tax88179_write_cmd_async(dev, AX_ACCESS_MAC, AX_MULFLTARY,\n\t\t\t\t\tAX_MCAST_FLTSIZE, AX_MCAST_FLTSIZE,\n\t\t\t\t\tm_filter);\n\n\t\tdata->rxctl |= AX_RX_CTL_AM;\n\t}\n\n\tax88179_write_cmd_async(dev, AX_ACCESS_MAC, AX_RX_CTL,\n\t\t\t\t2, 2, &data->rxctl);\n}\n\nstatic int\nax88179_set_features(struct net_device *net, netdev_features_t features)\n{\n\tu8 tmp;\n\tstruct usbnet *dev = netdev_priv(net);\n\tnetdev_features_t changed = net->features ^ features;\n\n\tif (changed & NETIF_F_IP_CSUM) {\n\t\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);\n\t\ttmp ^= AX_TXCOE_TCP | AX_TXCOE_UDP;\n\t\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);\n\t}\n\n\tif (changed & NETIF_F_IPV6_CSUM) {\n\t\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);\n\t\ttmp ^= AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;\n\t\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);\n\t}\n\n\tif (changed & NETIF_F_RXCSUM) {\n\t\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &tmp);\n\t\ttmp ^= AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |\n\t\t       AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;\n\t\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &tmp);\n\t}\n\n\treturn 0;\n}\n\nstatic int ax88179_change_mtu(struct net_device *net, int new_mtu)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tu16 tmp16;\n\n\tnet->mtu = new_mtu;\n\tdev->hard_mtu = net->mtu + net->hard_header_len;\n\n\tif (net->mtu > 1500) {\n\t\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\n\t\t\t\t 2, 2, &tmp16);\n\t\ttmp16 |= AX_MEDIUM_JUMBO_EN;\n\t\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\n\t\t\t\t  2, 2, &tmp16);\n\t} else {\n\t\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\n\t\t\t\t 2, 2, &tmp16);\n\t\ttmp16 &= ~AX_MEDIUM_JUMBO_EN;\n\t\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\n\t\t\t\t  2, 2, &tmp16);\n\t}\n\n\t \n\tusbnet_update_max_qlen(dev);\n\n\treturn 0;\n}\n\nstatic int ax88179_set_mac_addr(struct net_device *net, void *p)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct sockaddr *addr = p;\n\tint ret;\n\n\tif (netif_running(net))\n\t\treturn -EBUSY;\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(net, addr->sa_data);\n\n\t \n\tret = ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,\n\t\t\t\t ETH_ALEN, net->dev_addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ax88179_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_change_mtu\t\t= ax88179_change_mtu,\n\t.ndo_set_mac_address\t= ax88179_set_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= ax88179_ioctl,\n\t.ndo_set_rx_mode\t= ax88179_set_multicast,\n\t.ndo_set_features\t= ax88179_set_features,\n};\n\nstatic int ax88179_check_eeprom(struct usbnet *dev)\n{\n\tu8 i, buf, eeprom[20];\n\tu16 csum, delay = HZ / 10;\n\tunsigned long jtimeout;\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tbuf = i;\n\t\tif (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_ADDR,\n\t\t\t\t      1, 1, &buf) < 0)\n\t\t\treturn -EINVAL;\n\n\t\tbuf = EEP_RD;\n\t\tif (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,\n\t\t\t\t      1, 1, &buf) < 0)\n\t\t\treturn -EINVAL;\n\n\t\tjtimeout = jiffies + delay;\n\t\tdo {\n\t\t\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,\n\t\t\t\t\t 1, 1, &buf);\n\n\t\t\tif (time_after(jiffies, jtimeout))\n\t\t\t\treturn -EINVAL;\n\n\t\t} while (buf & EEP_BUSY);\n\n\t\t__ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,\n\t\t\t\t   2, 2, &eeprom[i * 2]);\n\n\t\tif ((i == 0) && (eeprom[0] == 0xFF))\n\t\t\treturn -EINVAL;\n\t}\n\n\tcsum = eeprom[6] + eeprom[7] + eeprom[8] + eeprom[9];\n\tcsum = (csum >> 8) + (csum & 0xff);\n\tif ((csum + eeprom[10]) != 0xff)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ax88179_check_efuse(struct usbnet *dev, u16 *ledmode)\n{\n\tu8\ti;\n\tu8\tefuse[64];\n\tu16\tcsum = 0;\n\n\tif (ax88179_read_cmd(dev, AX_ACCESS_EFUS, 0, 64, 64, efuse) < 0)\n\t\treturn -EINVAL;\n\n\tif (*efuse == 0xFF)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 64; i++)\n\t\tcsum = csum + efuse[i];\n\n\twhile (csum > 255)\n\t\tcsum = (csum & 0x00FF) + ((csum >> 8) & 0x00FF);\n\n\tif (csum != 0xFF)\n\t\treturn -EINVAL;\n\n\t*ledmode = (efuse[51] << 8) | efuse[52];\n\n\treturn 0;\n}\n\nstatic int ax88179_convert_old_led(struct usbnet *dev, u16 *ledvalue)\n{\n\tu16 led;\n\n\t \n\tif (ax88179_read_cmd(dev, AX_ACCESS_EEPROM, 0x3C, 1, 2, &led) < 0)\n\t\treturn -EINVAL;\n\n\tled >>= 8;\n\tswitch (led) {\n\tcase 0xFF:\n\t\tled = LED0_ACTIVE | LED1_LINK_10 | LED1_LINK_100 |\n\t\t      LED1_LINK_1000 | LED2_ACTIVE | LED2_LINK_10 |\n\t\t      LED2_LINK_100 | LED2_LINK_1000 | LED_VALID;\n\t\tbreak;\n\tcase 0xFE:\n\t\tled = LED0_ACTIVE | LED1_LINK_1000 | LED2_LINK_100 | LED_VALID;\n\t\tbreak;\n\tcase 0xFD:\n\t\tled = LED0_ACTIVE | LED1_LINK_1000 | LED2_LINK_100 |\n\t\t      LED2_LINK_10 | LED_VALID;\n\t\tbreak;\n\tcase 0xFC:\n\t\tled = LED0_ACTIVE | LED1_ACTIVE | LED1_LINK_1000 | LED2_ACTIVE |\n\t\t      LED2_LINK_100 | LED2_LINK_10 | LED_VALID;\n\t\tbreak;\n\tdefault:\n\t\tled = LED0_ACTIVE | LED1_LINK_10 | LED1_LINK_100 |\n\t\t      LED1_LINK_1000 | LED2_ACTIVE | LED2_LINK_10 |\n\t\t      LED2_LINK_100 | LED2_LINK_1000 | LED_VALID;\n\t\tbreak;\n\t}\n\n\t*ledvalue = led;\n\n\treturn 0;\n}\n\nstatic int ax88179_led_setting(struct usbnet *dev)\n{\n\tu8 ledfd, value = 0;\n\tu16 tmp, ledact, ledlink, ledvalue = 0, delay = HZ / 10;\n\tunsigned long jtimeout;\n\n\t \n\tax88179_read_cmd(dev, AX_ACCESS_MAC, GENERAL_STATUS, 1, 1, &value);\n\n\tif (!(value & AX_SECLD)) {\t \n\t\tvalue = AX_GPIO_CTRL_GPIO3EN | AX_GPIO_CTRL_GPIO2EN |\n\t\t\tAX_GPIO_CTRL_GPIO1EN;\n\t\tif (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_GPIO_CTRL,\n\t\t\t\t      1, 1, &value) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!ax88179_check_eeprom(dev)) {\n\t\tvalue = 0x42;\n\t\tif (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_ADDR,\n\t\t\t\t      1, 1, &value) < 0)\n\t\t\treturn -EINVAL;\n\n\t\tvalue = EEP_RD;\n\t\tif (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,\n\t\t\t\t      1, 1, &value) < 0)\n\t\t\treturn -EINVAL;\n\n\t\tjtimeout = jiffies + delay;\n\t\tdo {\n\t\t\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,\n\t\t\t\t\t 1, 1, &value);\n\n\t\t\tif (time_after(jiffies, jtimeout))\n\t\t\t\treturn -EINVAL;\n\n\t\t} while (value & EEP_BUSY);\n\n\t\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_DATA_HIGH,\n\t\t\t\t 1, 1, &value);\n\t\tledvalue = (value << 8);\n\n\t\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,\n\t\t\t\t 1, 1, &value);\n\t\tledvalue |= value;\n\n\t\t \n\t\tif ((ledvalue == 0xFFFF) || ((ledvalue & LED_VALID) == 0))\n\t\t\tax88179_convert_old_led(dev, &ledvalue);\n\n\t} else if (!ax88179_check_efuse(dev, &ledvalue)) {\n\t\tif ((ledvalue == 0xFFFF) || ((ledvalue & LED_VALID) == 0))\n\t\t\tax88179_convert_old_led(dev, &ledvalue);\n\t} else {\n\t\tax88179_convert_old_led(dev, &ledvalue);\n\t}\n\n\ttmp = GMII_PHY_PGSEL_EXT;\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t  GMII_PHY_PAGE_SELECT, 2, &tmp);\n\n\ttmp = 0x2c;\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t  GMII_PHYPAGE, 2, &tmp);\n\n\tax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t GMII_LED_ACT, 2, &ledact);\n\n\tax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t GMII_LED_LINK, 2, &ledlink);\n\n\tledact &= GMII_LED_ACTIVE_MASK;\n\tledlink &= GMII_LED_LINK_MASK;\n\n\tif (ledvalue & LED0_ACTIVE)\n\t\tledact |= GMII_LED0_ACTIVE;\n\n\tif (ledvalue & LED1_ACTIVE)\n\t\tledact |= GMII_LED1_ACTIVE;\n\n\tif (ledvalue & LED2_ACTIVE)\n\t\tledact |= GMII_LED2_ACTIVE;\n\n\tif (ledvalue & LED0_LINK_10)\n\t\tledlink |= GMII_LED0_LINK_10;\n\n\tif (ledvalue & LED1_LINK_10)\n\t\tledlink |= GMII_LED1_LINK_10;\n\n\tif (ledvalue & LED2_LINK_10)\n\t\tledlink |= GMII_LED2_LINK_10;\n\n\tif (ledvalue & LED0_LINK_100)\n\t\tledlink |= GMII_LED0_LINK_100;\n\n\tif (ledvalue & LED1_LINK_100)\n\t\tledlink |= GMII_LED1_LINK_100;\n\n\tif (ledvalue & LED2_LINK_100)\n\t\tledlink |= GMII_LED2_LINK_100;\n\n\tif (ledvalue & LED0_LINK_1000)\n\t\tledlink |= GMII_LED0_LINK_1000;\n\n\tif (ledvalue & LED1_LINK_1000)\n\t\tledlink |= GMII_LED1_LINK_1000;\n\n\tif (ledvalue & LED2_LINK_1000)\n\t\tledlink |= GMII_LED2_LINK_1000;\n\n\ttmp = ledact;\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t  GMII_LED_ACT, 2, &tmp);\n\n\ttmp = ledlink;\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t  GMII_LED_LINK, 2, &tmp);\n\n\ttmp = GMII_PHY_PGSEL_PAGE0;\n\tax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t  GMII_PHY_PAGE_SELECT, 2, &tmp);\n\n\t \n\tledfd = 0;\n\tif (ledvalue & LED0_FD)\n\t\tledfd |= 0x01;\n\telse if ((ledvalue & LED0_USB3_MASK) == 0)\n\t\tledfd |= 0x02;\n\n\tif (ledvalue & LED1_FD)\n\t\tledfd |= 0x04;\n\telse if ((ledvalue & LED1_USB3_MASK) == 0)\n\t\tledfd |= 0x08;\n\n\tif (ledvalue & LED2_FD)\n\t\tledfd |= 0x10;\n\telse if ((ledvalue & LED2_USB3_MASK) == 0)\n\t\tledfd |= 0x20;\n\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_LEDCTRL, 1, 1, &ledfd);\n\n\treturn 0;\n}\n\nstatic void ax88179_get_mac_addr(struct usbnet *dev)\n{\n\tu8 mac[ETH_ALEN];\n\n\tmemset(mac, 0, sizeof(mac));\n\n\t \n\tif (!eth_platform_get_mac_address(&dev->udev->dev, mac)) {\n\t\tnetif_dbg(dev, ifup, dev->net,\n\t\t\t  \"MAC address read from device tree\");\n\t} else {\n\t\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,\n\t\t\t\t ETH_ALEN, mac);\n\t\tnetif_dbg(dev, ifup, dev->net,\n\t\t\t  \"MAC address read from ASIX chip\");\n\t}\n\n\tif (is_valid_ether_addr(mac)) {\n\t\teth_hw_addr_set(dev->net, mac);\n\t} else {\n\t\tnetdev_info(dev->net, \"invalid MAC address, using random\\n\");\n\t\teth_hw_addr_random(dev->net);\n\t}\n\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN, ETH_ALEN,\n\t\t\t  dev->net->dev_addr);\n}\n\nstatic int ax88179_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct ax88179_data *ax179_data;\n\n\tusbnet_get_endpoints(dev, intf);\n\n\tax179_data = kzalloc(sizeof(*ax179_data), GFP_KERNEL);\n\tif (!ax179_data)\n\t\treturn -ENOMEM;\n\n\tdev->driver_priv = ax179_data;\n\n\tdev->net->netdev_ops = &ax88179_netdev_ops;\n\tdev->net->ethtool_ops = &ax88179_ethtool_ops;\n\tdev->net->needed_headroom = 8;\n\tdev->net->max_mtu = 4088;\n\n\t \n\tdev->mii.dev = dev->net;\n\tdev->mii.mdio_read = ax88179_mdio_read;\n\tdev->mii.mdio_write = ax88179_mdio_write;\n\tdev->mii.phy_id_mask = 0xff;\n\tdev->mii.reg_num_mask = 0xff;\n\tdev->mii.phy_id = 0x03;\n\tdev->mii.supports_gmii = 1;\n\n\tdev->net->features |= NETIF_F_SG | NETIF_F_IP_CSUM |\n\t\t\t      NETIF_F_IPV6_CSUM | NETIF_F_RXCSUM | NETIF_F_TSO;\n\n\tdev->net->hw_features |= dev->net->features;\n\n\tnetif_set_tso_max_size(dev->net, 16384);\n\n\tax88179_reset(dev);\n\n\treturn 0;\n}\n\nstatic void ax88179_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct ax88179_data *ax179_data = dev->driver_priv;\n\tu16 tmp16;\n\n\t \n\ttmp16 = AX_RX_CTL_STOP;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &tmp16);\n\n\ttmp16 = 0;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp16);\n\n\t \n\ttmp16 = 0;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &tmp16);\n\n\tkfree(ax179_data);\n}\n\nstatic void\nax88179_rx_checksum(struct sk_buff *skb, u32 *pkt_hdr)\n{\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t \n\tif ((*pkt_hdr & AX_RXHDR_L3CSUM_ERR) ||\n\t    (*pkt_hdr & AX_RXHDR_L4CSUM_ERR))\n\t\treturn;\n\n\t \n\tif (((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_TCP) ||\n\t    ((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_UDP))\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n}\n\nstatic int ax88179_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct sk_buff *ax_skb;\n\tint pkt_cnt;\n\tu32 rx_hdr;\n\tu16 hdr_off;\n\tu32 *pkt_hdr;\n\n\t \n\n\t \n\n\tif (skb->len < 4)\n\t\treturn 0;\n\tskb_trim(skb, skb->len - 4);\n\trx_hdr = get_unaligned_le32(skb_tail_pointer(skb));\n\tpkt_cnt = (u16)rx_hdr;\n\thdr_off = (u16)(rx_hdr >> 16);\n\n\tif (pkt_cnt == 0)\n\t\treturn 0;\n\n\t \n\tif (pkt_cnt * 4 + hdr_off > skb->len)\n\t\treturn 0;\n\tpkt_hdr = (u32 *)(skb->data + hdr_off);\n\n\t \n\tskb_trim(skb, hdr_off);\n\n\tfor (; pkt_cnt > 0; pkt_cnt--, pkt_hdr++) {\n\t\tu16 pkt_len_plus_padd;\n\t\tu16 pkt_len;\n\n\t\tle32_to_cpus(pkt_hdr);\n\t\tpkt_len = (*pkt_hdr >> 16) & 0x1fff;\n\t\tpkt_len_plus_padd = (pkt_len + 7) & 0xfff8;\n\n\t\t \n\t\tif (pkt_len == 0)\n\t\t\tcontinue;\n\n\t\tif (pkt_len_plus_padd > skb->len)\n\t\t\treturn 0;\n\n\t\t \n\t\tif ((*pkt_hdr & (AX_RXHDR_CRC_ERR | AX_RXHDR_DROP_ERR)) ||\n\t\t    pkt_len < 2 + ETH_HLEN) {\n\t\t\tdev->net->stats.rx_errors++;\n\t\t\tskb_pull(skb, pkt_len_plus_padd);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (pkt_len_plus_padd == skb->len) {\n\t\t\tskb_trim(skb, pkt_len);\n\n\t\t\t \n\t\t\tskb_pull(skb, 2);\n\n\t\t\tskb->truesize = SKB_TRUESIZE(pkt_len_plus_padd);\n\t\t\tax88179_rx_checksum(skb, pkt_hdr);\n\t\t\treturn 1;\n\t\t}\n\n\t\tax_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!ax_skb)\n\t\t\treturn 0;\n\t\tskb_trim(ax_skb, pkt_len);\n\n\t\t \n\t\tskb_pull(ax_skb, 2);\n\n\t\tskb->truesize = pkt_len_plus_padd +\n\t\t\t\tSKB_DATA_ALIGN(sizeof(struct sk_buff));\n\t\tax88179_rx_checksum(ax_skb, pkt_hdr);\n\t\tusbnet_skb_return(dev, ax_skb);\n\n\t\tskb_pull(skb, pkt_len_plus_padd);\n\t}\n\n\treturn 0;\n}\n\nstatic struct sk_buff *\nax88179_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\n{\n\tu32 tx_hdr1, tx_hdr2;\n\tint frame_size = dev->maxpacket;\n\tint headroom;\n\tvoid *ptr;\n\n\ttx_hdr1 = skb->len;\n\ttx_hdr2 = skb_shinfo(skb)->gso_size;  \n\tif (((skb->len + 8) % frame_size) == 0)\n\t\ttx_hdr2 |= 0x80008000;\t \n\n\theadroom = skb_headroom(skb) - 8;\n\n\tif ((dev->net->features & NETIF_F_SG) && skb_linearize(skb))\n\t\treturn NULL;\n\n\tif ((skb_header_cloned(skb) || headroom < 0) &&\n\t    pskb_expand_head(skb, headroom < 0 ? 8 : 0, 0, GFP_ATOMIC)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NULL;\n\t}\n\n\tptr = skb_push(skb, 8);\n\tput_unaligned_le32(tx_hdr1, ptr);\n\tput_unaligned_le32(tx_hdr2, ptr + 4);\n\n\tusbnet_set_skb_tx_stats(skb, (skb_shinfo(skb)->gso_segs ?: 1), 0);\n\n\treturn skb;\n}\n\nstatic int ax88179_link_reset(struct usbnet *dev)\n{\n\tstruct ax88179_data *ax179_data = dev->driver_priv;\n\tu8 tmp[5], link_sts;\n\tu16 mode, tmp16, delay = HZ / 10;\n\tu32 tmp32 = 0x40000000;\n\tunsigned long jtimeout;\n\n\tjtimeout = jiffies + delay;\n\twhile (tmp32 & 0x40000000) {\n\t\tmode = 0;\n\t\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &mode);\n\t\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2,\n\t\t\t\t  &ax179_data->rxctl);\n\n\t\t \n\t\tax88179_read_cmd(dev, 0x81, 0x8c, 0, 4, &tmp32);\n\n\t\tif (time_after(jiffies, jtimeout))\n\t\t\treturn 0;\n\t}\n\n\tmode = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_TXFLOW_CTRLEN |\n\t       AX_MEDIUM_RXFLOW_CTRLEN;\n\n\tax88179_read_cmd(dev, AX_ACCESS_MAC, PHYSICAL_LINK_STATUS,\n\t\t\t 1, 1, &link_sts);\n\n\tax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,\n\t\t\t GMII_PHY_PHYSR, 2, &tmp16);\n\n\tif (!(tmp16 & GMII_PHY_PHYSR_LINK)) {\n\t\treturn 0;\n\t} else if (GMII_PHY_PHYSR_GIGA == (tmp16 & GMII_PHY_PHYSR_SMASK)) {\n\t\tmode |= AX_MEDIUM_GIGAMODE | AX_MEDIUM_EN_125MHZ;\n\t\tif (dev->net->mtu > 1500)\n\t\t\tmode |= AX_MEDIUM_JUMBO_EN;\n\n\t\tif (link_sts & AX_USB_SS)\n\t\t\tmemcpy(tmp, &AX88179_BULKIN_SIZE[0], 5);\n\t\telse if (link_sts & AX_USB_HS)\n\t\t\tmemcpy(tmp, &AX88179_BULKIN_SIZE[1], 5);\n\t\telse\n\t\t\tmemcpy(tmp, &AX88179_BULKIN_SIZE[3], 5);\n\t} else if (GMII_PHY_PHYSR_100 == (tmp16 & GMII_PHY_PHYSR_SMASK)) {\n\t\tmode |= AX_MEDIUM_PS;\n\n\t\tif (link_sts & (AX_USB_SS | AX_USB_HS))\n\t\t\tmemcpy(tmp, &AX88179_BULKIN_SIZE[2], 5);\n\t\telse\n\t\t\tmemcpy(tmp, &AX88179_BULKIN_SIZE[3], 5);\n\t} else {\n\t\tmemcpy(tmp, &AX88179_BULKIN_SIZE[3], 5);\n\t}\n\n\t \n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, tmp);\n\n\tdev->rx_urb_size = (1024 * (tmp[3] + 2));\n\n\tif (tmp16 & GMII_PHY_PHYSR_FULL)\n\t\tmode |= AX_MEDIUM_FULL_DUPLEX;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\n\t\t\t  2, 2, &mode);\n\n\tax179_data->eee_enabled = ax88179_chk_eee(dev);\n\n\tnetif_carrier_on(dev->net);\n\n\treturn 0;\n}\n\nstatic int ax88179_reset(struct usbnet *dev)\n{\n\tu8 buf[5];\n\tu16 *tmp16;\n\tu8 *tmp;\n\tstruct ax88179_data *ax179_data = dev->driver_priv;\n\tstruct ethtool_eee eee_data;\n\n\ttmp16 = (u16 *)buf;\n\ttmp = (u8 *)buf;\n\n\t \n\t*tmp16 = 0;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);\n\n\t*tmp16 = AX_PHYPWR_RSTCTL_IPRL;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);\n\tmsleep(500);\n\n\t*tmp = AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, tmp);\n\tmsleep(200);\n\n\t \n\tax88179_auto_detach(dev);\n\n\t \n\tax88179_get_mac_addr(dev);\n\tmemcpy(dev->net->perm_addr, dev->net->dev_addr, ETH_ALEN);\n\n\t \n\tmemcpy(tmp, &AX88179_BULKIN_SIZE[0], 5);\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, tmp);\n\n\tdev->rx_urb_size = 1024 * 20;\n\n\t*tmp = 0x34;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_LOW, 1, 1, tmp);\n\n\t*tmp = 0x52;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,\n\t\t\t  1, 1, tmp);\n\n\t \n\t*tmp = AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |\n\t       AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, tmp);\n\n\t*tmp = AX_TXCOE_IP | AX_TXCOE_TCP | AX_TXCOE_UDP |\n\t       AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, tmp);\n\n\t \n\t*tmp16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_IPE | AX_RX_CTL_START |\n\t\t AX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, tmp16);\n\n\t*tmp = AX_MONITOR_MODE_PMETYPE | AX_MONITOR_MODE_PMEPOL |\n\t       AX_MONITOR_MODE_RWMP;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD, 1, 1, tmp);\n\n\t \n\t*tmp16 = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_TXFLOW_CTRLEN |\n\t\t AX_MEDIUM_RXFLOW_CTRLEN | AX_MEDIUM_FULL_DUPLEX |\n\t\t AX_MEDIUM_GIGAMODE;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\n\t\t\t  2, 2, tmp16);\n\n\t \n\tax179_data->wol_supported = 0;\n\tif (ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD,\n\t\t\t     1, 1, &tmp) > 0)\n\t\tax179_data->wol_supported = WAKE_MAGIC | WAKE_PHY;\n\n\tax88179_led_setting(dev);\n\n\tax179_data->eee_enabled = 0;\n\tax179_data->eee_active = 0;\n\n\tax88179_disable_eee(dev);\n\n\tax88179_ethtool_get_eee(dev, &eee_data);\n\teee_data.advertised = 0;\n\tax88179_ethtool_set_eee(dev, &eee_data);\n\n\t \n\tmii_nway_restart(&dev->mii);\n\n\tusbnet_link_change(dev, 0, 0);\n\n\treturn 0;\n}\n\nstatic int ax88179_stop(struct usbnet *dev)\n{\n\tu16 tmp16;\n\n\tax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\n\t\t\t 2, 2, &tmp16);\n\ttmp16 &= ~AX_MEDIUM_RECEIVE_EN;\n\tax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,\n\t\t\t  2, 2, &tmp16);\n\n\treturn 0;\n}\n\nstatic const struct driver_info ax88179_info = {\n\t.description = \"ASIX AX88179 USB 3.0 Gigabit Ethernet\",\n\t.bind = ax88179_bind,\n\t.unbind = ax88179_unbind,\n\t.status = ax88179_status,\n\t.link_reset = ax88179_link_reset,\n\t.reset = ax88179_reset,\n\t.stop = ax88179_stop,\n\t.flags = FLAG_ETHER | FLAG_FRAMING_AX,\n\t.rx_fixup = ax88179_rx_fixup,\n\t.tx_fixup = ax88179_tx_fixup,\n};\n\nstatic const struct driver_info ax88178a_info = {\n\t.description = \"ASIX AX88178A USB 2.0 Gigabit Ethernet\",\n\t.bind = ax88179_bind,\n\t.unbind = ax88179_unbind,\n\t.status = ax88179_status,\n\t.link_reset = ax88179_link_reset,\n\t.reset = ax88179_reset,\n\t.stop = ax88179_stop,\n\t.flags = FLAG_ETHER | FLAG_FRAMING_AX,\n\t.rx_fixup = ax88179_rx_fixup,\n\t.tx_fixup = ax88179_tx_fixup,\n};\n\nstatic const struct driver_info cypress_GX3_info = {\n\t.description = \"Cypress GX3 SuperSpeed to Gigabit Ethernet Controller\",\n\t.bind = ax88179_bind,\n\t.unbind = ax88179_unbind,\n\t.status = ax88179_status,\n\t.link_reset = ax88179_link_reset,\n\t.reset = ax88179_reset,\n\t.stop = ax88179_stop,\n\t.flags = FLAG_ETHER | FLAG_FRAMING_AX,\n\t.rx_fixup = ax88179_rx_fixup,\n\t.tx_fixup = ax88179_tx_fixup,\n};\n\nstatic const struct driver_info dlink_dub1312_info = {\n\t.description = \"D-Link DUB-1312 USB 3.0 to Gigabit Ethernet Adapter\",\n\t.bind = ax88179_bind,\n\t.unbind = ax88179_unbind,\n\t.status = ax88179_status,\n\t.link_reset = ax88179_link_reset,\n\t.reset = ax88179_reset,\n\t.stop = ax88179_stop,\n\t.flags = FLAG_ETHER | FLAG_FRAMING_AX,\n\t.rx_fixup = ax88179_rx_fixup,\n\t.tx_fixup = ax88179_tx_fixup,\n};\n\nstatic const struct driver_info sitecom_info = {\n\t.description = \"Sitecom USB 3.0 to Gigabit Adapter\",\n\t.bind = ax88179_bind,\n\t.unbind = ax88179_unbind,\n\t.status = ax88179_status,\n\t.link_reset = ax88179_link_reset,\n\t.reset = ax88179_reset,\n\t.stop = ax88179_stop,\n\t.flags = FLAG_ETHER | FLAG_FRAMING_AX,\n\t.rx_fixup = ax88179_rx_fixup,\n\t.tx_fixup = ax88179_tx_fixup,\n};\n\nstatic const struct driver_info samsung_info = {\n\t.description = \"Samsung USB Ethernet Adapter\",\n\t.bind = ax88179_bind,\n\t.unbind = ax88179_unbind,\n\t.status = ax88179_status,\n\t.link_reset = ax88179_link_reset,\n\t.reset = ax88179_reset,\n\t.stop = ax88179_stop,\n\t.flags = FLAG_ETHER | FLAG_FRAMING_AX,\n\t.rx_fixup = ax88179_rx_fixup,\n\t.tx_fixup = ax88179_tx_fixup,\n};\n\nstatic const struct driver_info lenovo_info = {\n\t.description = \"Lenovo OneLinkDock Gigabit LAN\",\n\t.bind = ax88179_bind,\n\t.unbind = ax88179_unbind,\n\t.status = ax88179_status,\n\t.link_reset = ax88179_link_reset,\n\t.reset = ax88179_reset,\n\t.stop = ax88179_stop,\n\t.flags = FLAG_ETHER | FLAG_FRAMING_AX,\n\t.rx_fixup = ax88179_rx_fixup,\n\t.tx_fixup = ax88179_tx_fixup,\n};\n\nstatic const struct driver_info belkin_info = {\n\t.description = \"Belkin USB Ethernet Adapter\",\n\t.bind\t= ax88179_bind,\n\t.unbind = ax88179_unbind,\n\t.status = ax88179_status,\n\t.link_reset = ax88179_link_reset,\n\t.reset\t= ax88179_reset,\n\t.stop\t= ax88179_stop,\n\t.flags\t= FLAG_ETHER | FLAG_FRAMING_AX,\n\t.rx_fixup = ax88179_rx_fixup,\n\t.tx_fixup = ax88179_tx_fixup,\n};\n\nstatic const struct driver_info toshiba_info = {\n\t.description = \"Toshiba USB Ethernet Adapter\",\n\t.bind\t= ax88179_bind,\n\t.unbind = ax88179_unbind,\n\t.status = ax88179_status,\n\t.link_reset = ax88179_link_reset,\n\t.reset\t= ax88179_reset,\n\t.stop = ax88179_stop,\n\t.flags\t= FLAG_ETHER | FLAG_FRAMING_AX,\n\t.rx_fixup = ax88179_rx_fixup,\n\t.tx_fixup = ax88179_tx_fixup,\n};\n\nstatic const struct driver_info mct_info = {\n\t.description = \"MCT USB 3.0 Gigabit Ethernet Adapter\",\n\t.bind\t= ax88179_bind,\n\t.unbind\t= ax88179_unbind,\n\t.status\t= ax88179_status,\n\t.link_reset = ax88179_link_reset,\n\t.reset\t= ax88179_reset,\n\t.stop\t= ax88179_stop,\n\t.flags\t= FLAG_ETHER | FLAG_FRAMING_AX,\n\t.rx_fixup = ax88179_rx_fixup,\n\t.tx_fixup = ax88179_tx_fixup,\n};\n\nstatic const struct driver_info at_umc2000_info = {\n\t.description = \"AT-UMC2000 USB 3.0/USB 3.1 Gen 1 to Gigabit Ethernet Adapter\",\n\t.bind   = ax88179_bind,\n\t.unbind = ax88179_unbind,\n\t.status = ax88179_status,\n\t.link_reset = ax88179_link_reset,\n\t.reset  = ax88179_reset,\n\t.stop   = ax88179_stop,\n\t.flags  = FLAG_ETHER | FLAG_FRAMING_AX,\n\t.rx_fixup = ax88179_rx_fixup,\n\t.tx_fixup = ax88179_tx_fixup,\n};\n\nstatic const struct driver_info at_umc200_info = {\n\t.description = \"AT-UMC200 USB 3.0/USB 3.1 Gen 1 to Fast Ethernet Adapter\",\n\t.bind   = ax88179_bind,\n\t.unbind = ax88179_unbind,\n\t.status = ax88179_status,\n\t.link_reset = ax88179_link_reset,\n\t.reset  = ax88179_reset,\n\t.stop   = ax88179_stop,\n\t.flags  = FLAG_ETHER | FLAG_FRAMING_AX,\n\t.rx_fixup = ax88179_rx_fixup,\n\t.tx_fixup = ax88179_tx_fixup,\n};\n\nstatic const struct driver_info at_umc2000sp_info = {\n\t.description = \"AT-UMC2000/SP USB 3.0/USB 3.1 Gen 1 to Gigabit Ethernet Adapter\",\n\t.bind   = ax88179_bind,\n\t.unbind = ax88179_unbind,\n\t.status = ax88179_status,\n\t.link_reset = ax88179_link_reset,\n\t.reset  = ax88179_reset,\n\t.stop   = ax88179_stop,\n\t.flags  = FLAG_ETHER | FLAG_FRAMING_AX,\n\t.rx_fixup = ax88179_rx_fixup,\n\t.tx_fixup = ax88179_tx_fixup,\n};\n\nstatic const struct usb_device_id products[] = {\n{\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x0b95, 0x1790, 0xff, 0xff, 0),\n\t.driver_info = (unsigned long)&ax88179_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x0b95, 0x178a, 0xff, 0xff, 0),\n\t.driver_info = (unsigned long)&ax88178a_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x04b4, 0x3610, 0xff, 0xff, 0),\n\t.driver_info = (unsigned long)&cypress_GX3_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x4a00, 0xff, 0xff, 0),\n\t.driver_info = (unsigned long)&dlink_dub1312_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x0df6, 0x0072, 0xff, 0xff, 0),\n\t.driver_info = (unsigned long)&sitecom_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x04e8, 0xa100, 0xff, 0xff, 0),\n\t.driver_info = (unsigned long)&samsung_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x17ef, 0x304b, 0xff, 0xff, 0),\n\t.driver_info = (unsigned long)&lenovo_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x050d, 0x0128, 0xff, 0xff, 0),\n\t.driver_info = (unsigned long)&belkin_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x0930, 0x0a13, 0xff, 0xff, 0),\n\t.driver_info = (unsigned long)&toshiba_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x0711, 0x0179, 0xff, 0xff, 0),\n\t.driver_info = (unsigned long)&mct_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x07c9, 0x000e, 0xff, 0xff, 0),\n\t.driver_info = (unsigned long)&at_umc2000_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x07c9, 0x000f, 0xff, 0xff, 0),\n\t.driver_info = (unsigned long)&at_umc200_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x07c9, 0x0010, 0xff, 0xff, 0),\n\t.driver_info = (unsigned long)&at_umc2000sp_info,\n},\n\t{ },\n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver ax88179_178a_driver = {\n\t.name =\t\t\"ax88179_178a\",\n\t.id_table =\tproducts,\n\t.probe =\tusbnet_probe,\n\t.suspend =\tax88179_suspend,\n\t.resume =\tax88179_resume,\n\t.reset_resume =\tax88179_resume,\n\t.disconnect =\tax88179_disconnect,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(ax88179_178a_driver);\n\nMODULE_DESCRIPTION(\"ASIX AX88179/178A based USB 3.0/2.0 Gigabit Ethernet Devices\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}