{
  "module_name": "r8153_ecm.c",
  "hash_id": "61d89e2da4d9d2402bed0a1d374237d5d439032bd0afd83eca3ecf12b016643b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/r8153_ecm.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/usbnet.h>\n#include <linux/usb/r8152.h>\n\n#define OCP_BASE\t\t0xe86c\n\nstatic int pla_read_word(struct usbnet *dev, u16 index)\n{\n\tu16 byen = BYTE_EN_WORD;\n\tu8 shift = index & 2;\n\t__le32 tmp;\n\tint ret;\n\n\tif (shift)\n\t\tbyen <<= shift;\n\n\tindex &= ~3;\n\n\tret = usbnet_read_cmd(dev, RTL8152_REQ_GET_REGS, RTL8152_REQT_READ, index,\n\t\t\t      MCU_TYPE_PLA | byen, &tmp, sizeof(tmp));\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = __le32_to_cpu(tmp);\n\tret >>= (shift * 8);\n\tret &= 0xffff;\n\nout:\n\treturn ret;\n}\n\nstatic int pla_write_word(struct usbnet *dev, u16 index, u32 data)\n{\n\tu32 mask = 0xffff;\n\tu16 byen = BYTE_EN_WORD;\n\tu8 shift = index & 2;\n\t__le32 tmp;\n\tint ret;\n\n\tdata &= mask;\n\n\tif (shift) {\n\t\tbyen <<= shift;\n\t\tmask <<= (shift * 8);\n\t\tdata <<= (shift * 8);\n\t}\n\n\tindex &= ~3;\n\n\tret = usbnet_read_cmd(dev, RTL8152_REQ_GET_REGS, RTL8152_REQT_READ, index,\n\t\t\t      MCU_TYPE_PLA | byen, &tmp, sizeof(tmp));\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdata |= __le32_to_cpu(tmp) & ~mask;\n\ttmp = __cpu_to_le32(data);\n\n\tret = usbnet_write_cmd(dev, RTL8152_REQ_SET_REGS, RTL8152_REQT_WRITE, index,\n\t\t\t       MCU_TYPE_PLA | byen, &tmp, sizeof(tmp));\n\nout:\n\treturn ret;\n}\n\nstatic int r8153_ecm_mdio_read(struct net_device *netdev, int phy_id, int reg)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tint ret;\n\n\tret = pla_write_word(dev, OCP_BASE, 0xa000);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = pla_read_word(dev, 0xb400 + reg * 2);\n\nout:\n\treturn ret;\n}\n\nstatic void r8153_ecm_mdio_write(struct net_device *netdev, int phy_id, int reg, int val)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tint ret;\n\n\tret = pla_write_word(dev, OCP_BASE, 0xa000);\n\tif (ret < 0)\n\t\treturn;\n\n\tret = pla_write_word(dev, 0xb400 + reg * 2, val);\n}\n\nstatic int r8153_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint status;\n\n\tstatus = usbnet_cdc_bind(dev, intf);\n\tif (status < 0)\n\t\treturn status;\n\n\tdev->mii.dev = dev->net;\n\tdev->mii.mdio_read = r8153_ecm_mdio_read;\n\tdev->mii.mdio_write = r8153_ecm_mdio_write;\n\tdev->mii.reg_num_mask = 0x1f;\n\tdev->mii.supports_gmii = 1;\n\n\treturn status;\n}\n\nstatic const struct driver_info r8153_info = {\n\t.description =\t\"RTL8153 ECM Device\",\n\t.flags =\tFLAG_ETHER,\n\t.bind =\t\tr8153_bind,\n\t.unbind =\tusbnet_cdc_unbind,\n\t.status =\tusbnet_cdc_status,\n\t.manage_power =\tusbnet_manage_power,\n};\n\nstatic const struct usb_device_id products[] = {\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(VENDOR_ID_REALTEK, 0x8153, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&r8153_info,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(VENDOR_ID_LENOVO, 0x721e, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&r8153_info,\n},\n\n\t{ },\t\t \n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic int rtl8153_ecm_probe(struct usb_interface *intf,\n\t\t\t     const struct usb_device_id *id)\n{\n#if IS_REACHABLE(CONFIG_USB_RTL8152)\n\tif (rtl8152_get_version(intf))\n\t\treturn -ENODEV;\n#endif\n\n\treturn usbnet_probe(intf, id);\n}\n\nstatic struct usb_driver r8153_ecm_driver = {\n\t.name =\t\t\"r8153_ecm\",\n\t.id_table =\tproducts,\n\t.probe =\trtl8153_ecm_probe,\n\t.disconnect =\tusbnet_disconnect,\n\t.suspend =\tusbnet_suspend,\n\t.resume =\tusbnet_resume,\n\t.reset_resume =\tusbnet_resume,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(r8153_ecm_driver);\n\nMODULE_AUTHOR(\"Hayes Wang\");\nMODULE_DESCRIPTION(\"Realtek USB ECM device\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}