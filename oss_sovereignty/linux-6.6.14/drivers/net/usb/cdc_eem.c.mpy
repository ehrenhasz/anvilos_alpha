{
  "module_name": "cdc_eem.c",
  "hash_id": "027540c86a4f4700d57641a9c48f134ad98558ff9957ee1e2aa79a0fc419c6fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/cdc_eem.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ctype.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/crc32.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/usbnet.h>\n#include <linux/gfp.h>\n#include <linux/if_vlan.h>\n\n\n \n\n#define EEM_HEAD\t2\t\t \n\n \n\nstatic void eem_linkcmd_complete(struct urb *urb)\n{\n\tdev_kfree_skb(urb->context);\n\tusb_free_urb(urb);\n}\n\nstatic void eem_linkcmd(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct urb\t\t*urb;\n\tint\t\t\tstatus;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto fail;\n\n\tusb_fill_bulk_urb(urb, dev->udev, dev->out,\n\t\t\tskb->data, skb->len, eem_linkcmd_complete, skb);\n\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status) {\n\t\tusb_free_urb(urb);\nfail:\n\t\tdev_kfree_skb(skb);\n\t\tnetdev_warn(dev->net, \"link cmd failure\\n\");\n\t\treturn;\n\t}\n}\n\nstatic int eem_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint status = 0;\n\n\tstatus = usbnet_get_endpoints(dev, intf);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\n\tdev->net->hard_header_len += EEM_HEAD + ETH_FCS_LEN + VLAN_HLEN;\n\tdev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\n\n\treturn 0;\n}\n\n \nstatic struct sk_buff *eem_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\n\t\t\t\t       gfp_t flags)\n{\n\tstruct sk_buff\t*skb2 = NULL;\n\tu16\t\tlen = skb->len;\n\tu32\t\tcrc = 0;\n\tint\t\tpadlen = 0;\n\n\t \n\tif (!((len + EEM_HEAD + ETH_FCS_LEN) % dev->maxpacket))\n\t\tpadlen += 2;\n\n\tif (!skb_cloned(skb)) {\n\t\tint\theadroom = skb_headroom(skb);\n\t\tint\ttailroom = skb_tailroom(skb);\n\n\t\tif ((tailroom >= ETH_FCS_LEN + padlen) &&\n\t\t    (headroom >= EEM_HEAD))\n\t\t\tgoto done;\n\n\t\tif ((headroom + tailroom)\n\t\t\t\t> (EEM_HEAD + ETH_FCS_LEN + padlen)) {\n\t\t\tskb->data = memmove(skb->head +\n\t\t\t\t\tEEM_HEAD,\n\t\t\t\t\tskb->data,\n\t\t\t\t\tskb->len);\n\t\t\tskb_set_tail_pointer(skb, len);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tskb2 = skb_copy_expand(skb, EEM_HEAD, ETH_FCS_LEN + padlen, flags);\n\tdev_kfree_skb_any(skb);\n\tif (!skb2)\n\t\treturn NULL;\n\n\tskb = skb2;\n\ndone:\n\t \n\tcrc = crc32_le(~0, skb->data, skb->len);\n\tcrc = ~crc;\n\n\tput_unaligned_le32(crc, skb_put(skb, 4));\n\n\t \n\tlen = skb->len;\n\tput_unaligned_le16(BIT(14) | len, skb_push(skb, 2));\n\n\t \n\tif (padlen)\n\t\tput_unaligned_le16(0, skb_put(skb, 2));\n\n\treturn skb;\n}\n\nstatic int eem_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\t \n\tdo {\n\t\tstruct sk_buff\t*skb2 = NULL;\n\t\tu16\t\theader;\n\t\tu16\t\tlen = 0;\n\n\t\t \n\t\tif (skb->len < EEM_HEAD)\n\t\t\treturn 0;\n\n\t\t \n\t\theader = get_unaligned_le16(skb->data);\n\t\tskb_pull(skb, EEM_HEAD);\n\n\t\t \n\t\tif (header & BIT(15)) {\n\t\t\tu16\tbmEEMCmd;\n\n\t\t\t \n\t\t\tif (header & BIT(14)) {\n\t\t\t\tnetdev_dbg(dev->net, \"reserved command %04x\\n\",\n\t\t\t\t\t   header);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbmEEMCmd = (header >> 11) & 0x7;\n\t\t\tswitch (bmEEMCmd) {\n\n\t\t\t \n\t\t\tcase 0:\t\t \n\t\t\t\tlen = header & 0x7FF;\n\n\t\t\t\t \n\t\t\t\tif (skb->len < len)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (unlikely(!skb2))\n\t\t\t\t\tgoto next;\n\t\t\t\tskb_trim(skb2, len);\n\t\t\t\tput_unaligned_le16(BIT(15) | BIT(11) | len,\n\t\t\t\t\t\tskb_push(skb2, 2));\n\t\t\t\teem_linkcmd(dev, skb2);\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tcase 2:\t\t \n\t\t\t\tusbnet_device_suggests_idle(dev);\n\t\t\t\tcontinue;\n\t\t\tcase 3:\t\t \n\t\t\tcase 4:\t\t \n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tcase 1:\t\t \n\t\t\tcase 5:\t\t \n\t\t\tdefault:\t \n\t\t\t\tnetdev_warn(dev->net,\n\t\t\t\t\t    \"unexpected link command %d\\n\",\n\t\t\t\t\t    bmEEMCmd);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t} else {\n\t\t\tu32\tcrc, crc2;\n\t\t\tint\tis_last;\n\n\t\t\t \n\t\t\tif (header == 0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tlen = header & 0x3FFF;\n\n\t\t\t \n\t\t\tif (skb->len < len)\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\tif (len < (ETH_HLEN + ETH_FCS_LEN))\n\t\t\t\tgoto next;\n\n\t\t\t \n\t\t\tis_last = (len == skb->len);\n\t\t\tif (is_last)\n\t\t\t\tskb2 = skb;\n\t\t\telse {\n\t\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (unlikely(!skb2))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (header & BIT(14)) {\n\t\t\t\tcrc = get_unaligned_le32(skb2->data\n\t\t\t\t\t\t+ len - ETH_FCS_LEN);\n\t\t\t\tcrc2 = ~crc32_le(~0, skb2->data, skb2->len\n\t\t\t\t\t\t- ETH_FCS_LEN);\n\t\t\t} else {\n\t\t\t\tcrc = get_unaligned_be32(skb2->data\n\t\t\t\t\t\t+ len - ETH_FCS_LEN);\n\t\t\t\tcrc2 = 0xdeadbeef;\n\t\t\t}\n\t\t\tskb_trim(skb2, len - ETH_FCS_LEN);\n\n\t\t\tif (is_last)\n\t\t\t\treturn crc == crc2;\n\n\t\t\tif (unlikely(crc != crc2)) {\n\t\t\t\tdev->net->stats.rx_errors++;\n\t\t\t\tdev_kfree_skb_any(skb2);\n\t\t\t} else\n\t\t\t\tusbnet_skb_return(dev, skb2);\n\t\t}\n\nnext:\n\t\tskb_pull(skb, len);\n\t} while (skb->len);\n\n\treturn 1;\n}\n\nstatic const struct driver_info eem_info = {\n\t.description =\t\"CDC EEM Device\",\n\t.flags =\tFLAG_ETHER | FLAG_POINTTOPOINT,\n\t.bind =\t\teem_bind,\n\t.rx_fixup =\teem_rx_fixup,\n\t.tx_fixup =\teem_tx_fixup,\n};\n\n \n\nstatic const struct usb_device_id products[] = {\n{\n\tUSB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_EEM,\n\t\t\tUSB_CDC_PROTO_EEM),\n\t.driver_info = (unsigned long) &eem_info,\n},\n{\n\t \n},\n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver eem_driver = {\n\t.name =\t\t\"cdc_eem\",\n\t.id_table =\tproducts,\n\t.probe =\tusbnet_probe,\n\t.disconnect =\tusbnet_disconnect,\n\t.suspend =\tusbnet_suspend,\n\t.resume =\tusbnet_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(eem_driver);\n\nMODULE_AUTHOR(\"Omar Laazimani <omar.oberthur@gmail.com>\");\nMODULE_DESCRIPTION(\"USB CDC EEM\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}