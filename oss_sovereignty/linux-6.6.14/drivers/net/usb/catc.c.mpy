{
  "module_name": "catc.c",
  "hash_id": "4f978a17504285ba6219424ec1a88f8b061459635b103d91bce7c16064ccd527",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/catc.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/ethtool.h>\n#include <linux/crc32.h>\n#include <linux/bitops.h>\n#include <linux/gfp.h>\n#include <linux/uaccess.h>\n\n#undef DEBUG\n\n#include <linux/usb.h>\n\n \n\n#define DRIVER_VERSION \"v2.8\"\n#define DRIVER_AUTHOR \"Vojtech Pavlik <vojtech@suse.cz>\"\n#define DRIVER_DESC \"CATC EL1210A NetMate USB Ethernet driver\"\n#define SHORT_DRIVER_DESC \"EL1210A NetMate USB Ethernet\"\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic const char driver_name[] = \"catc\";\n\n \n\n#define STATS_UPDATE\t\t(HZ)\t \n#define TX_TIMEOUT\t\t(5*HZ)\t \n#define PKT_SZ\t\t\t1536\t \n#define RX_MAX_BURST\t\t15\t \n#define TX_MAX_BURST\t\t15\t \n#define CTRL_QUEUE\t\t16\t \n#define RX_PKT_SZ\t\t1600\t \n\n \n\nenum control_requests {\n\tReadMem =\t0xf1,\n\tGetMac =\t0xf2,\n\tReset =\t\t0xf4,\n\tSetMac =\t0xf5,\n\tSetRxMode =     0xf5,   \n\tWriteROM =\t0xf8,\n\tSetReg =\t0xfa,\n\tGetReg =\t0xfb,\n\tWriteMem =\t0xfc,\n\tReadROM =\t0xfd,\n};\n\n \n\nenum register_offsets {\n\tTxBufCount =\t0x20,\n\tRxBufCount =\t0x21,\n\tOpModes =\t0x22,\n\tTxQed =\t\t0x23,\n\tRxQed =\t\t0x24,\n\tMaxBurst =\t0x25,\n\tRxUnit =\t0x60,\n\tEthStatus =\t0x61,\n\tStationAddr0 =\t0x67,\n\tEthStats =\t0x69,\n\tLEDCtrl =\t0x81,\n};\n\nenum eth_stats {\n\tTxSingleColl =\t0x00,\n        TxMultiColl =\t0x02,\n        TxExcessColl =\t0x04,\n        RxFramErr =\t0x06,\n};\n\nenum op_mode_bits {\n\tOp3MemWaits =\t0x03,\n\tOpLenInclude =\t0x08,\n\tOpRxMerge =\t0x10,\n\tOpTxMerge =\t0x20,\n\tOpWin95bugfix =\t0x40,\n\tOpLoopback =\t0x80,\n};\n\nenum rx_filter_bits {\n\tRxEnable =\t0x01,\n\tRxPolarity =\t0x02,\n\tRxForceOK =\t0x04,\n\tRxMultiCast =\t0x08,\n\tRxPromisc =\t0x10,\n\tAltRxPromisc =  0x20,  \n};\n\nenum led_values {\n\tLEDFast = \t0x01,\n\tLEDSlow =\t0x02,\n\tLEDFlash =\t0x03,\n\tLEDPulse =\t0x04,\n\tLEDLink =\t0x08,\n};\n\nenum link_status {\n\tLinkNoChange = 0,\n\tLinkGood     = 1,\n\tLinkBad      = 2\n};\n\n \n\n#define CTRL_RUNNING\t0\n#define RX_RUNNING\t1\n#define TX_RUNNING\t2\n\nstruct catc {\n\tstruct net_device *netdev;\n\tstruct usb_device *usbdev;\n\n\tunsigned long flags;\n\n\tunsigned int tx_ptr, tx_idx;\n\tunsigned int ctrl_head, ctrl_tail;\n\tspinlock_t tx_lock, ctrl_lock;\n\n\tu8 tx_buf[2][TX_MAX_BURST * (PKT_SZ + 2)];\n\tu8 rx_buf[RX_MAX_BURST * (PKT_SZ + 2)];\n\tu8 irq_buf[2];\n\tu8 ctrl_buf[64];\n\tstruct usb_ctrlrequest ctrl_dr;\n\n\tstruct timer_list timer;\n\tu8 stats_buf[8];\n\tu16 stats_vals[4];\n\tunsigned long last_stats;\n\n\tu8 multicast[64];\n\n\tstruct ctrl_queue {\n\t\tu8 dir;\n\t\tu8 request;\n\t\tu16 value;\n\t\tu16 index;\n\t\tvoid *buf;\n\t\tint len;\n\t\tvoid (*callback)(struct catc *catc, struct ctrl_queue *q);\n\t} ctrl_queue[CTRL_QUEUE];\n\n\tstruct urb *tx_urb, *rx_urb, *irq_urb, *ctrl_urb;\n\n\tu8 is_f5u011;\t \n\tu8 rxmode[2];\t \n\tatomic_t recq_sz;  \n};\n\n \n\n#define catc_get_mac(catc, mac)\t\t\t\tcatc_ctrl_msg(catc, USB_DIR_IN,  GetMac, 0, 0, mac,  6)\n#define catc_reset(catc)\t\t\t\tcatc_ctrl_msg(catc, USB_DIR_OUT, Reset, 0, 0, NULL, 0)\n#define catc_set_reg(catc, reg, val)\t\t\tcatc_ctrl_msg(catc, USB_DIR_OUT, SetReg, val, reg, NULL, 0)\n#define catc_get_reg(catc, reg, buf)\t\t\tcatc_ctrl_msg(catc, USB_DIR_IN,  GetReg, 0, reg, buf, 1)\n#define catc_write_mem(catc, addr, buf, size)\t\tcatc_ctrl_msg(catc, USB_DIR_OUT, WriteMem, 0, addr, buf, size)\n#define catc_read_mem(catc, addr, buf, size)\t\tcatc_ctrl_msg(catc, USB_DIR_IN,  ReadMem, 0, addr, buf, size)\n\n#define f5u011_rxmode(catc, rxmode)\t\t\tcatc_ctrl_msg(catc, USB_DIR_OUT, SetRxMode, 0, 1, rxmode, 2)\n#define f5u011_rxmode_async(catc, rxmode)\t\tcatc_ctrl_async(catc, USB_DIR_OUT, SetRxMode, 0, 1, &rxmode, 2, NULL)\n#define f5u011_mchash_async(catc, hash)\t\t\tcatc_ctrl_async(catc, USB_DIR_OUT, SetRxMode, 0, 2, &hash, 8, NULL)\n\n#define catc_set_reg_async(catc, reg, val)\t\tcatc_ctrl_async(catc, USB_DIR_OUT, SetReg, val, reg, NULL, 0, NULL)\n#define catc_get_reg_async(catc, reg, cb)\t\tcatc_ctrl_async(catc, USB_DIR_IN, GetReg, 0, reg, NULL, 1, cb)\n#define catc_write_mem_async(catc, addr, buf, size)\tcatc_ctrl_async(catc, USB_DIR_OUT, WriteMem, 0, addr, buf, size, NULL)\n\n \n\nstatic void catc_rx_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tu8 *pkt_start = urb->transfer_buffer;\n\tstruct sk_buff *skb;\n\tint pkt_len, pkt_offset = 0;\n\tint status = urb->status;\n\n\tif (!catc->is_f5u011) {\n\t\tclear_bit(RX_RUNNING, &catc->flags);\n\t\tpkt_offset = 2;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"rx_done, status %d, length %d\\n\",\n\t\t\tstatus, urb->actual_length);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tif(!catc->is_f5u011) {\n\t\t\tpkt_len = le16_to_cpup((__le16*)pkt_start);\n\t\t\tif (pkt_len > urb->actual_length) {\n\t\t\t\tcatc->netdev->stats.rx_length_errors++;\n\t\t\t\tcatc->netdev->stats.rx_errors++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tpkt_len = urb->actual_length;\n\t\t}\n\n\t\tif (!(skb = dev_alloc_skb(pkt_len)))\n\t\t\treturn;\n\n\t\tskb_copy_to_linear_data(skb, pkt_start + pkt_offset, pkt_len);\n\t\tskb_put(skb, pkt_len);\n\n\t\tskb->protocol = eth_type_trans(skb, catc->netdev);\n\t\tnetif_rx(skb);\n\n\t\tcatc->netdev->stats.rx_packets++;\n\t\tcatc->netdev->stats.rx_bytes += pkt_len;\n\n\t\t \n\t\tif (catc->is_f5u011)\n\t\t\tbreak;\n\t\tpkt_start += (((pkt_len + 1) >> 6) + 1) << 6;\n\n\t} while (pkt_start - (u8 *) urb->transfer_buffer < urb->actual_length);\n\n\tif (catc->is_f5u011) {\n\t\tif (atomic_read(&catc->recq_sz)) {\n\t\t\tint state;\n\t\t\tatomic_dec(&catc->recq_sz);\n\t\t\tnetdev_dbg(catc->netdev, \"getting extra packet\\n\");\n\t\t\turb->dev = catc->usbdev;\n\t\t\tif ((state = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {\n\t\t\t\tnetdev_dbg(catc->netdev,\n\t\t\t\t\t   \"submit(rx_urb) status %d\\n\", state);\n\t\t\t}\n\t\t} else {\n\t\t\tclear_bit(RX_RUNNING, &catc->flags);\n\t\t}\n\t}\n}\n\nstatic void catc_irq_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tu8 *data = urb->transfer_buffer;\n\tint status = urb->status;\n\tunsigned int hasdata, linksts = LinkNoChange;\n\tint res;\n\n\tif (!catc->is_f5u011) {\n\t\thasdata = data[1] & 0x80;\n\t\tif (data[1] & 0x40)\n\t\t\tlinksts = LinkGood;\n\t\telse if (data[1] & 0x20)\n\t\t\tlinksts = LinkBad;\n\t} else {\n\t\thasdata = (unsigned int)(be16_to_cpup((__be16*)data) & 0x0fff);\n\t\tif (data[0] == 0x90)\n\t\t\tlinksts = LinkGood;\n\t\telse if (data[0] == 0xA0)\n\t\t\tlinksts = LinkBad;\n\t}\n\n\tswitch (status) {\n\tcase 0:\t\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\t \n\tdefault:\t\t \n\t\tdev_dbg(&urb->dev->dev,\n\t\t\t\"irq_done, status %d, data %02x %02x.\\n\",\n\t\t\tstatus, data[0], data[1]);\n\t\tgoto resubmit;\n\t}\n\n\tif (linksts == LinkGood) {\n\t\tnetif_carrier_on(catc->netdev);\n\t\tnetdev_dbg(catc->netdev, \"link ok\\n\");\n\t}\n\n\tif (linksts == LinkBad) {\n\t\tnetif_carrier_off(catc->netdev);\n\t\tnetdev_dbg(catc->netdev, \"link bad\\n\");\n\t}\n\n\tif (hasdata) {\n\t\tif (test_and_set_bit(RX_RUNNING, &catc->flags)) {\n\t\t\tif (catc->is_f5u011)\n\t\t\t\tatomic_inc(&catc->recq_sz);\n\t\t} else {\n\t\t\tcatc->rx_urb->dev = catc->usbdev;\n\t\t\tif ((res = usb_submit_urb(catc->rx_urb, GFP_ATOMIC)) < 0) {\n\t\t\t\tdev_err(&catc->usbdev->dev,\n\t\t\t\t\t\"submit(rx_urb) status %d\\n\", res);\n\t\t\t}\n\t\t}\n\t}\nresubmit:\n\tres = usb_submit_urb (urb, GFP_ATOMIC);\n\tif (res)\n\t\tdev_err(&catc->usbdev->dev,\n\t\t\t\"can't resubmit intr, %s-%s, status %d\\n\",\n\t\t\tcatc->usbdev->bus->bus_name,\n\t\t\tcatc->usbdev->devpath, res);\n}\n\n \n\nstatic int catc_tx_run(struct catc *catc)\n{\n\tint status;\n\n\tif (catc->is_f5u011)\n\t\tcatc->tx_ptr = (catc->tx_ptr + 63) & ~63;\n\n\tcatc->tx_urb->transfer_buffer_length = catc->tx_ptr;\n\tcatc->tx_urb->transfer_buffer = catc->tx_buf[catc->tx_idx];\n\tcatc->tx_urb->dev = catc->usbdev;\n\n\tif ((status = usb_submit_urb(catc->tx_urb, GFP_ATOMIC)) < 0)\n\t\tdev_err(&catc->usbdev->dev, \"submit(tx_urb), status %d\\n\",\n\t\t\tstatus);\n\n\tcatc->tx_idx = !catc->tx_idx;\n\tcatc->tx_ptr = 0;\n\n\tnetif_trans_update(catc->netdev);\n\treturn status;\n}\n\nstatic void catc_tx_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tunsigned long flags;\n\tint r, status = urb->status;\n\n\tif (status == -ECONNRESET) {\n\t\tdev_dbg(&urb->dev->dev, \"Tx Reset.\\n\");\n\t\turb->status = 0;\n\t\tnetif_trans_update(catc->netdev);\n\t\tcatc->netdev->stats.tx_errors++;\n\t\tclear_bit(TX_RUNNING, &catc->flags);\n\t\tnetif_wake_queue(catc->netdev);\n\t\treturn;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"tx_done, status %d, length %d\\n\",\n\t\t\tstatus, urb->actual_length);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&catc->tx_lock, flags);\n\n\tif (catc->tx_ptr) {\n\t\tr = catc_tx_run(catc);\n\t\tif (unlikely(r < 0))\n\t\t\tclear_bit(TX_RUNNING, &catc->flags);\n\t} else {\n\t\tclear_bit(TX_RUNNING, &catc->flags);\n\t}\n\n\tnetif_wake_queue(catc->netdev);\n\n\tspin_unlock_irqrestore(&catc->tx_lock, flags);\n}\n\nstatic netdev_tx_t catc_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\tunsigned long flags;\n\tint r = 0;\n\tchar *tx_buf;\n\n\tspin_lock_irqsave(&catc->tx_lock, flags);\n\n\tcatc->tx_ptr = (((catc->tx_ptr - 1) >> 6) + 1) << 6;\n\ttx_buf = catc->tx_buf[catc->tx_idx] + catc->tx_ptr;\n\tif (catc->is_f5u011)\n\t\t*(__be16 *)tx_buf = cpu_to_be16(skb->len);\n\telse\n\t\t*(__le16 *)tx_buf = cpu_to_le16(skb->len);\n\tskb_copy_from_linear_data(skb, tx_buf + 2, skb->len);\n\tcatc->tx_ptr += skb->len + 2;\n\n\tif (!test_and_set_bit(TX_RUNNING, &catc->flags)) {\n\t\tr = catc_tx_run(catc);\n\t\tif (r < 0)\n\t\t\tclear_bit(TX_RUNNING, &catc->flags);\n\t}\n\n\tif ((catc->is_f5u011 && catc->tx_ptr) ||\n\t    (catc->tx_ptr >= ((TX_MAX_BURST - 1) * (PKT_SZ + 2))))\n\t\tnetif_stop_queue(netdev);\n\n\tspin_unlock_irqrestore(&catc->tx_lock, flags);\n\n\tif (r >= 0) {\n\t\tcatc->netdev->stats.tx_bytes += skb->len;\n\t\tcatc->netdev->stats.tx_packets++;\n\t}\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void catc_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\n\tdev_warn(&netdev->dev, \"Transmit timed out.\\n\");\n\tusb_unlink_urb(catc->tx_urb);\n}\n\n \n\nstatic int catc_ctrl_msg(struct catc *catc, u8 dir, u8 request, u16 value, u16 index, void *buf, int len)\n{\n        int retval = usb_control_msg(catc->usbdev,\n\t\tdir ? usb_rcvctrlpipe(catc->usbdev, 0) : usb_sndctrlpipe(catc->usbdev, 0),\n\t\t request, 0x40 | dir, value, index, buf, len, 1000);\n        return retval < 0 ? retval : 0;\n}\n\nstatic void catc_ctrl_run(struct catc *catc)\n{\n\tstruct ctrl_queue *q = catc->ctrl_queue + catc->ctrl_tail;\n\tstruct usb_device *usbdev = catc->usbdev;\n\tstruct urb *urb = catc->ctrl_urb;\n\tstruct usb_ctrlrequest *dr = &catc->ctrl_dr;\n\tint status;\n\n\tdr->bRequest = q->request;\n\tdr->bRequestType = 0x40 | q->dir;\n\tdr->wValue = cpu_to_le16(q->value);\n\tdr->wIndex = cpu_to_le16(q->index);\n\tdr->wLength = cpu_to_le16(q->len);\n\n        urb->pipe = q->dir ? usb_rcvctrlpipe(usbdev, 0) : usb_sndctrlpipe(usbdev, 0);\n\turb->transfer_buffer_length = q->len;\n\turb->transfer_buffer = catc->ctrl_buf;\n\turb->setup_packet = (void *) dr;\n\turb->dev = usbdev;\n\n\tif (!q->dir && q->buf && q->len)\n\t\tmemcpy(catc->ctrl_buf, q->buf, q->len);\n\n\tif ((status = usb_submit_urb(catc->ctrl_urb, GFP_ATOMIC)))\n\t\tdev_err(&catc->usbdev->dev, \"submit(ctrl_urb) status %d\\n\",\n\t\t\tstatus);\n}\n\nstatic void catc_ctrl_done(struct urb *urb)\n{\n\tstruct catc *catc = urb->context;\n\tstruct ctrl_queue *q;\n\tunsigned long flags;\n\tint status = urb->status;\n\n\tif (status)\n\t\tdev_dbg(&urb->dev->dev, \"ctrl_done, status %d, len %d.\\n\",\n\t\t\tstatus, urb->actual_length);\n\n\tspin_lock_irqsave(&catc->ctrl_lock, flags);\n\n\tq = catc->ctrl_queue + catc->ctrl_tail;\n\n\tif (q->dir) {\n\t\tif (q->buf && q->len)\n\t\t\tmemcpy(q->buf, catc->ctrl_buf, q->len);\n\t\telse\n\t\t\tq->buf = catc->ctrl_buf;\n\t}\n\n\tif (q->callback)\n\t\tq->callback(catc, q);\n\n\tcatc->ctrl_tail = (catc->ctrl_tail + 1) & (CTRL_QUEUE - 1);\n\n\tif (catc->ctrl_head != catc->ctrl_tail)\n\t\tcatc_ctrl_run(catc);\n\telse\n\t\tclear_bit(CTRL_RUNNING, &catc->flags);\n\n\tspin_unlock_irqrestore(&catc->ctrl_lock, flags);\n}\n\nstatic int catc_ctrl_async(struct catc *catc, u8 dir, u8 request, u16 value,\n\tu16 index, void *buf, int len, void (*callback)(struct catc *catc, struct ctrl_queue *q))\n{\n\tstruct ctrl_queue *q;\n\tint retval = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&catc->ctrl_lock, flags);\n\n\tq = catc->ctrl_queue + catc->ctrl_head;\n\n\tq->dir = dir;\n\tq->request = request;\n\tq->value = value;\n\tq->index = index;\n\tq->buf = buf;\n\tq->len = len;\n\tq->callback = callback;\n\n\tcatc->ctrl_head = (catc->ctrl_head + 1) & (CTRL_QUEUE - 1);\n\n\tif (catc->ctrl_head == catc->ctrl_tail) {\n\t\tdev_err(&catc->usbdev->dev, \"ctrl queue full\\n\");\n\t\tcatc->ctrl_tail = (catc->ctrl_tail + 1) & (CTRL_QUEUE - 1);\n\t\tretval = -1;\n\t}\n\n\tif (!test_and_set_bit(CTRL_RUNNING, &catc->flags))\n\t\tcatc_ctrl_run(catc);\n\n\tspin_unlock_irqrestore(&catc->ctrl_lock, flags);\n\n\treturn retval;\n}\n\n \n\nstatic void catc_stats_done(struct catc *catc, struct ctrl_queue *q)\n{\n\tint index = q->index - EthStats;\n\tu16 data, last;\n\n\tcatc->stats_buf[index] = *((char *)q->buf);\n\n\tif (index & 1)\n\t\treturn;\n\n\tdata = ((u16)catc->stats_buf[index] << 8) | catc->stats_buf[index + 1];\n\tlast = catc->stats_vals[index >> 1];\n\n\tswitch (index) {\n\t\tcase TxSingleColl:\n\t\tcase TxMultiColl:\n\t\t\tcatc->netdev->stats.collisions += data - last;\n\t\t\tbreak;\n\t\tcase TxExcessColl:\n\t\t\tcatc->netdev->stats.tx_aborted_errors += data - last;\n\t\t\tcatc->netdev->stats.tx_errors += data - last;\n\t\t\tbreak;\n\t\tcase RxFramErr:\n\t\t\tcatc->netdev->stats.rx_frame_errors += data - last;\n\t\t\tcatc->netdev->stats.rx_errors += data - last;\n\t\t\tbreak;\n\t}\n\n\tcatc->stats_vals[index >> 1] = data;\n}\n\nstatic void catc_stats_timer(struct timer_list *t)\n{\n\tstruct catc *catc = from_timer(catc, t, timer);\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tcatc_get_reg_async(catc, EthStats + 7 - i, catc_stats_done);\n\n\tmod_timer(&catc->timer, jiffies + STATS_UPDATE);\n}\n\n \n\nstatic void catc_multicast(const unsigned char *addr, u8 *multicast)\n{\n\tu32 crc;\n\n\tcrc = ether_crc_le(6, addr);\n\tmulticast[(crc >> 3) & 0x3f] |= 1 << (crc & 7);\n}\n\nstatic void catc_set_multicast_list(struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\tstruct netdev_hw_addr *ha;\n\tu8 broadcast[ETH_ALEN];\n\tu8 rx = RxEnable | RxPolarity | RxMultiCast;\n\n\teth_broadcast_addr(broadcast);\n\tmemset(catc->multicast, 0, 64);\n\n\tcatc_multicast(broadcast, catc->multicast);\n\tcatc_multicast(netdev->dev_addr, catc->multicast);\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\tmemset(catc->multicast, 0xff, 64);\n\t\trx |= (!catc->is_f5u011) ? RxPromisc : AltRxPromisc;\n\t}\n\n\tif (netdev->flags & IFF_ALLMULTI) {\n\t\tmemset(catc->multicast, 0xff, 64);\n\t} else {\n\t\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\t\tu32 crc = ether_crc_le(6, ha->addr);\n\t\t\tif (!catc->is_f5u011) {\n\t\t\t\tcatc->multicast[(crc >> 3) & 0x3f] |= 1 << (crc & 7);\n\t\t\t} else {\n\t\t\t\tcatc->multicast[7-(crc >> 29)] |= 1 << ((crc >> 26) & 7);\n\t\t\t}\n\t\t}\n\t}\n\tif (!catc->is_f5u011) {\n\t\tcatc_set_reg_async(catc, RxUnit, rx);\n\t\tcatc_write_mem_async(catc, 0xfa80, catc->multicast, 64);\n\t} else {\n\t\tf5u011_mchash_async(catc, catc->multicast);\n\t\tif (catc->rxmode[0] != rx) {\n\t\t\tcatc->rxmode[0] = rx;\n\t\t\tnetdev_dbg(catc->netdev,\n\t\t\t\t   \"Setting RX mode to %2.2X %2.2X\\n\",\n\t\t\t\t   catc->rxmode[0], catc->rxmode[1]);\n\t\t\tf5u011_rxmode_async(catc, catc->rxmode);\n\t\t}\n\t}\n}\n\nstatic void catc_get_drvinfo(struct net_device *dev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstruct catc *catc = netdev_priv(dev);\n\tstrscpy(info->driver, driver_name, sizeof(info->driver));\n\tstrscpy(info->version, DRIVER_VERSION, sizeof(info->version));\n\tusb_make_path(catc->usbdev, info->bus_info, sizeof(info->bus_info));\n}\n\nstatic int catc_get_link_ksettings(struct net_device *dev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct catc *catc = netdev_priv(dev);\n\tif (!catc->is_f5u011)\n\t\treturn -EOPNOTSUPP;\n\n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 10baseT_Half);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, TP);\n\n\tethtool_link_ksettings_zero_link_mode(cmd, advertising);\n\tethtool_link_ksettings_add_link_mode(cmd, advertising, 10baseT_Half);\n\tethtool_link_ksettings_add_link_mode(cmd, advertising, TP);\n\n\tcmd->base.speed = SPEED_10;\n\tcmd->base.duplex = DUPLEX_HALF;\n\tcmd->base.port = PORT_TP;\n\tcmd->base.phy_address = 0;\n\tcmd->base.autoneg = AUTONEG_DISABLE;\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo = catc_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n\t.get_link_ksettings = catc_get_link_ksettings,\n};\n\n \n\nstatic int catc_open(struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\tint status;\n\n\tcatc->irq_urb->dev = catc->usbdev;\n\tif ((status = usb_submit_urb(catc->irq_urb, GFP_KERNEL)) < 0) {\n\t\tdev_err(&catc->usbdev->dev, \"submit(irq_urb) status %d\\n\",\n\t\t\tstatus);\n\t\treturn -1;\n\t}\n\n\tnetif_start_queue(netdev);\n\n\tif (!catc->is_f5u011)\n\t\tmod_timer(&catc->timer, jiffies + STATS_UPDATE);\n\n\treturn 0;\n}\n\nstatic int catc_stop(struct net_device *netdev)\n{\n\tstruct catc *catc = netdev_priv(netdev);\n\n\tnetif_stop_queue(netdev);\n\n\tif (!catc->is_f5u011)\n\t\tdel_timer_sync(&catc->timer);\n\n\tusb_kill_urb(catc->rx_urb);\n\tusb_kill_urb(catc->tx_urb);\n\tusb_kill_urb(catc->irq_urb);\n\tusb_kill_urb(catc->ctrl_urb);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops catc_netdev_ops = {\n\t.ndo_open\t\t= catc_open,\n\t.ndo_stop\t\t= catc_stop,\n\t.ndo_start_xmit\t\t= catc_start_xmit,\n\n\t.ndo_tx_timeout\t\t= catc_tx_timeout,\n\t.ndo_set_rx_mode\t= catc_set_multicast_list,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n \n\nstatic int catc_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct catc *catc;\n\tu8 broadcast[ETH_ALEN];\n\tu8 *macbuf;\n\tint pktsz, ret = -ENOMEM;\n\n\tmacbuf = kmalloc(ETH_ALEN, GFP_KERNEL);\n\tif (!macbuf)\n\t\tgoto error;\n\n\tif (usb_set_interface(usbdev,\n\t\t\tintf->altsetting->desc.bInterfaceNumber, 1)) {\n\t\tdev_err(dev, \"Can't set altsetting 1.\\n\");\n\t\tret = -EIO;\n\t\tgoto fail_mem;\n\t}\n\n\tnetdev = alloc_etherdev(sizeof(struct catc));\n\tif (!netdev)\n\t\tgoto fail_mem;\n\n\tcatc = netdev_priv(netdev);\n\n\tnetdev->netdev_ops = &catc_netdev_ops;\n\tnetdev->watchdog_timeo = TX_TIMEOUT;\n\tnetdev->ethtool_ops = &ops;\n\n\tcatc->usbdev = usbdev;\n\tcatc->netdev = netdev;\n\n\tspin_lock_init(&catc->tx_lock);\n\tspin_lock_init(&catc->ctrl_lock);\n\n\ttimer_setup(&catc->timer, catc_stats_timer, 0);\n\n\tcatc->ctrl_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tcatc->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif ((!catc->ctrl_urb) || (!catc->tx_urb) ||\n\t    (!catc->rx_urb) || (!catc->irq_urb)) {\n\t\tdev_err(&intf->dev, \"No free urbs available.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_free;\n\t}\n\n\t \n\tif (le16_to_cpu(usbdev->descriptor.idVendor) == 0x0423 &&\n\t    le16_to_cpu(usbdev->descriptor.idProduct) == 0xa &&\n\t    le16_to_cpu(catc->usbdev->descriptor.bcdDevice) == 0x0130) {\n\t\tdev_dbg(dev, \"Testing for f5u011\\n\");\n\t\tcatc->is_f5u011 = 1;\n\t\tatomic_set(&catc->recq_sz, 0);\n\t\tpktsz = RX_PKT_SZ;\n\t} else {\n\t\tpktsz = RX_MAX_BURST * (PKT_SZ + 2);\n\t}\n\n\tusb_fill_control_urb(catc->ctrl_urb, usbdev, usb_sndctrlpipe(usbdev, 0),\n\t\tNULL, NULL, 0, catc_ctrl_done, catc);\n\n\tusb_fill_bulk_urb(catc->tx_urb, usbdev, usb_sndbulkpipe(usbdev, 1),\n\t\tNULL, 0, catc_tx_done, catc);\n\n\tusb_fill_bulk_urb(catc->rx_urb, usbdev, usb_rcvbulkpipe(usbdev, 1),\n\t\tcatc->rx_buf, pktsz, catc_rx_done, catc);\n\n\tusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\n                catc->irq_buf, 2, catc_irq_done, catc, 1);\n\n\tif (!catc->is_f5u011) {\n\t\tu32 *buf;\n\t\tint i;\n\n\t\tdev_dbg(dev, \"Checking memory size\\n\");\n\n\t\tbuf = kmalloc(4, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free;\n\t\t}\n\n\t\t*buf = 0x12345678;\n\t\tcatc_write_mem(catc, 0x7a80, buf, 4);\n\t\t*buf = 0x87654321;\n\t\tcatc_write_mem(catc, 0xfa80, buf, 4);\n\t\tcatc_read_mem(catc, 0x7a80, buf, 4);\n\n\t\tswitch (*buf) {\n\t\tcase 0x12345678:\n\t\t\tcatc_set_reg(catc, TxBufCount, 8);\n\t\t\tcatc_set_reg(catc, RxBufCount, 32);\n\t\t\tdev_dbg(dev, \"64k Memory\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&intf->dev,\n\t\t\t\t \"Couldn't detect memory size, assuming 32k\\n\");\n\t\t\tfallthrough;\n\t\tcase 0x87654321:\n\t\t\tcatc_set_reg(catc, TxBufCount, 4);\n\t\t\tcatc_set_reg(catc, RxBufCount, 16);\n\t\t\tdev_dbg(dev, \"32k Memory\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(buf);\n\n\t\tdev_dbg(dev, \"Getting MAC from SEEROM.\\n\");\n\n\t\tcatc_get_mac(catc, macbuf);\n\t\teth_hw_addr_set(netdev, macbuf);\n\n\t\tdev_dbg(dev, \"Setting MAC into registers.\\n\");\n\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tcatc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);\n\n\t\tdev_dbg(dev, \"Filling the multicast list.\\n\");\n\n\t\teth_broadcast_addr(broadcast);\n\t\tcatc_multicast(broadcast, catc->multicast);\n\t\tcatc_multicast(netdev->dev_addr, catc->multicast);\n\t\tcatc_write_mem(catc, 0xfa80, catc->multicast, 64);\n\n\t\tdev_dbg(dev, \"Clearing error counters.\\n\");\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tcatc_set_reg(catc, EthStats + i, 0);\n\t\tcatc->last_stats = jiffies;\n\n\t\tdev_dbg(dev, \"Enabling.\\n\");\n\n\t\tcatc_set_reg(catc, MaxBurst, RX_MAX_BURST);\n\t\tcatc_set_reg(catc, OpModes, OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits);\n\t\tcatc_set_reg(catc, LEDCtrl, LEDLink);\n\t\tcatc_set_reg(catc, RxUnit, RxEnable | RxPolarity | RxMultiCast);\n\t} else {\n\t\tdev_dbg(dev, \"Performing reset\\n\");\n\t\tcatc_reset(catc);\n\t\tcatc_get_mac(catc, macbuf);\n\t\teth_hw_addr_set(netdev, macbuf);\n\n\t\tdev_dbg(dev, \"Setting RX Mode\\n\");\n\t\tcatc->rxmode[0] = RxEnable | RxPolarity | RxMultiCast;\n\t\tcatc->rxmode[1] = 0;\n\t\tf5u011_rxmode(catc, catc->rxmode);\n\t}\n\tdev_dbg(dev, \"Init done.\\n\");\n\tprintk(KERN_INFO \"%s: %s USB Ethernet at usb-%s-%s, %pM.\\n\",\n\t       netdev->name, (catc->is_f5u011) ? \"Belkin F5U011\" : \"CATC EL1210A NetMate\",\n\t       usbdev->bus->bus_name, usbdev->devpath, netdev->dev_addr);\n\tusb_set_intfdata(intf, catc);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tret = register_netdev(netdev);\n\tif (ret)\n\t\tgoto fail_clear_intfdata;\n\n\tkfree(macbuf);\n\treturn 0;\n\nfail_clear_intfdata:\n\tusb_set_intfdata(intf, NULL);\nfail_free:\n\tusb_free_urb(catc->ctrl_urb);\n\tusb_free_urb(catc->tx_urb);\n\tusb_free_urb(catc->rx_urb);\n\tusb_free_urb(catc->irq_urb);\n\tfree_netdev(netdev);\nfail_mem:\n\tkfree(macbuf);\nerror:\n\treturn ret;\n}\n\nstatic void catc_disconnect(struct usb_interface *intf)\n{\n\tstruct catc *catc = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tif (catc) {\n\t\tunregister_netdev(catc->netdev);\n\t\tusb_free_urb(catc->ctrl_urb);\n\t\tusb_free_urb(catc->tx_urb);\n\t\tusb_free_urb(catc->rx_urb);\n\t\tusb_free_urb(catc->irq_urb);\n\t\tfree_netdev(catc->netdev);\n\t}\n}\n\n \n\nstatic const struct usb_device_id catc_id_table[] = {\n\t{ USB_DEVICE(0x0423, 0xa) },\t \n\t{ USB_DEVICE(0x0423, 0xc) },\t \n\t{ USB_DEVICE(0x08d1, 0x1) },\t \n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, catc_id_table);\n\nstatic struct usb_driver catc_driver = {\n\t.name =\t\tdriver_name,\n\t.probe =\tcatc_probe,\n\t.disconnect =\tcatc_disconnect,\n\t.id_table =\tcatc_id_table,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(catc_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}