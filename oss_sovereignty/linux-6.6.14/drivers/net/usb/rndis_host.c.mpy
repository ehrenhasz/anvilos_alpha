{
  "module_name": "rndis_host.c",
  "hash_id": "c6369062ec2538a06de85bf2df06400e133e208f8f643542de893f5a7d2ff1c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/rndis_host.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/usbnet.h>\n#include <linux/usb/rndis_host.h>\n\n\n \n\n \nvoid rndis_status(struct usbnet *dev, struct urb *urb)\n{\n\tnetdev_dbg(dev->net, \"rndis status urb, len %d stat %d\\n\",\n\t\t   urb->actual_length, urb->status);\n\t \n\t \n}\nEXPORT_SYMBOL_GPL(rndis_status);\n\n \nstatic void rndis_msg_indicate(struct usbnet *dev, struct rndis_indicate *msg,\n\t\t\t\tint buflen)\n{\n\tstruct cdc_state *info = (void *)&dev->data;\n\tstruct device *udev = &info->control->dev;\n\n\tif (dev->driver_info->indication) {\n\t\tdev->driver_info->indication(dev, msg, buflen);\n\t} else {\n\t\tu32 status = le32_to_cpu(msg->status);\n\n\t\tswitch (status) {\n\t\tcase RNDIS_STATUS_MEDIA_CONNECT:\n\t\t\tdev_info(udev, \"rndis media connect\\n\");\n\t\t\tbreak;\n\t\tcase RNDIS_STATUS_MEDIA_DISCONNECT:\n\t\t\tdev_info(udev, \"rndis media disconnect\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(udev, \"rndis indication: 0x%08x\\n\", status);\n\t\t}\n\t}\n}\n\n \nint rndis_command(struct usbnet *dev, struct rndis_msg_hdr *buf, int buflen)\n{\n\tstruct cdc_state\t*info = (void *) &dev->data;\n\tstruct usb_cdc_notification notification;\n\tint\t\t\tmaster_ifnum;\n\tint\t\t\tretval;\n\tint\t\t\tpartial;\n\tunsigned\t\tcount;\n\tu32\t\t\txid = 0, msg_len, request_id, msg_type, rsp,\n\t\t\t\tstatus;\n\n\t \n\n\tmsg_type = le32_to_cpu(buf->msg_type);\n\n\t \n\tif (likely(msg_type != RNDIS_MSG_HALT && msg_type != RNDIS_MSG_RESET)) {\n\t\txid = dev->xid++;\n\t\tif (!xid)\n\t\t\txid = dev->xid++;\n\t\tbuf->request_id = (__force __le32) xid;\n\t}\n\tmaster_ifnum = info->control->cur_altsetting->desc.bInterfaceNumber;\n\tretval = usb_control_msg(dev->udev,\n\t\tusb_sndctrlpipe(dev->udev, 0),\n\t\tUSB_CDC_SEND_ENCAPSULATED_COMMAND,\n\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t0, master_ifnum,\n\t\tbuf, le32_to_cpu(buf->msg_len),\n\t\tRNDIS_CONTROL_TIMEOUT_MS);\n\tif (unlikely(retval < 0 || xid == 0))\n\t\treturn retval;\n\n\t \n\tif (dev->driver_info->data & RNDIS_DRIVER_DATA_POLL_STATUS) {\n\t\tretval = usb_interrupt_msg(\n\t\t\tdev->udev,\n\t\t\tusb_rcvintpipe(dev->udev,\n\t\t\t\t       dev->status->desc.bEndpointAddress),\n\t\t\t&notification, sizeof(notification), &partial,\n\t\t\tRNDIS_CONTROL_TIMEOUT_MS);\n\t\tif (unlikely(retval < 0))\n\t\t\treturn retval;\n\t}\n\n\t \n\trsp = le32_to_cpu(buf->msg_type) | RNDIS_MSG_COMPLETION;\n\tfor (count = 0; count < 10; count++) {\n\t\tmemset(buf, 0, CONTROL_BUFFER_SIZE);\n\t\tretval = usb_control_msg(dev->udev,\n\t\t\tusb_rcvctrlpipe(dev->udev, 0),\n\t\t\tUSB_CDC_GET_ENCAPSULATED_RESPONSE,\n\t\t\tUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t0, master_ifnum,\n\t\t\tbuf, buflen,\n\t\t\tRNDIS_CONTROL_TIMEOUT_MS);\n\t\tif (likely(retval >= 8)) {\n\t\t\tmsg_type = le32_to_cpu(buf->msg_type);\n\t\t\tmsg_len = le32_to_cpu(buf->msg_len);\n\t\t\tstatus = le32_to_cpu(buf->status);\n\t\t\trequest_id = (__force u32) buf->request_id;\n\t\t\tif (likely(msg_type == rsp)) {\n\t\t\t\tif (likely(request_id == xid)) {\n\t\t\t\t\tif (unlikely(rsp == RNDIS_MSG_RESET_C))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (likely(RNDIS_STATUS_SUCCESS ==\n\t\t\t\t\t\t\tstatus))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tdev_dbg(&info->control->dev,\n\t\t\t\t\t\t\"rndis reply status %08x\\n\",\n\t\t\t\t\t\tstatus);\n\t\t\t\t\treturn -EL3RST;\n\t\t\t\t}\n\t\t\t\tdev_dbg(&info->control->dev,\n\t\t\t\t\t\"rndis reply id %d expected %d\\n\",\n\t\t\t\t\trequest_id, xid);\n\t\t\t\t \n\t\t\t} else switch (msg_type) {\n\t\t\tcase RNDIS_MSG_INDICATE:  \n\t\t\t\trndis_msg_indicate(dev, (void *)buf, buflen);\n\t\t\t\tbreak;\n\t\t\tcase RNDIS_MSG_KEEPALIVE: {  \n\t\t\t\tstruct rndis_keepalive_c *msg = (void *)buf;\n\n\t\t\t\tmsg->msg_type = cpu_to_le32(RNDIS_MSG_KEEPALIVE_C);\n\t\t\t\tmsg->msg_len = cpu_to_le32(sizeof *msg);\n\t\t\t\tmsg->status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\t\t\t\tretval = usb_control_msg(dev->udev,\n\t\t\t\t\tusb_sndctrlpipe(dev->udev, 0),\n\t\t\t\t\tUSB_CDC_SEND_ENCAPSULATED_COMMAND,\n\t\t\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t\t\t0, master_ifnum,\n\t\t\t\t\tmsg, sizeof *msg,\n\t\t\t\t\tRNDIS_CONTROL_TIMEOUT_MS);\n\t\t\t\tif (unlikely(retval < 0))\n\t\t\t\t\tdev_dbg(&info->control->dev,\n\t\t\t\t\t\t\"rndis keepalive err %d\\n\",\n\t\t\t\t\t\tretval);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_dbg(&info->control->dev,\n\t\t\t\t\t\"unexpected rndis msg %08x len %d\\n\",\n\t\t\t\t\tle32_to_cpu(buf->msg_type), msg_len);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(&info->control->dev,\n\t\t\t\t\"rndis response error, code %d\\n\", retval);\n\t\t}\n\t\tmsleep(40);\n\t}\n\tdev_dbg(&info->control->dev, \"rndis response timeout\\n\");\n\treturn -ETIMEDOUT;\n}\nEXPORT_SYMBOL_GPL(rndis_command);\n\n \nstatic int rndis_query(struct usbnet *dev, struct usb_interface *intf,\n\t\tvoid *buf, u32 oid, u32 in_len,\n\t\tvoid **reply, int *reply_len)\n{\n\tint retval;\n\tunion {\n\t\tvoid\t\t\t*buf;\n\t\tstruct rndis_msg_hdr\t*header;\n\t\tstruct rndis_query\t*get;\n\t\tstruct rndis_query_c\t*get_c;\n\t} u;\n\tu32 off, len;\n\n\tu.buf = buf;\n\n\tmemset(u.get, 0, sizeof *u.get + in_len);\n\tu.get->msg_type = cpu_to_le32(RNDIS_MSG_QUERY);\n\tu.get->msg_len = cpu_to_le32(sizeof *u.get + in_len);\n\tu.get->oid = cpu_to_le32(oid);\n\tu.get->len = cpu_to_le32(in_len);\n\tu.get->offset = cpu_to_le32(20);\n\n\tretval = rndis_command(dev, u.header, CONTROL_BUFFER_SIZE);\n\tif (unlikely(retval < 0)) {\n\t\tdev_err(&intf->dev, \"RNDIS_MSG_QUERY(0x%08x) failed, %d\\n\",\n\t\t\t\toid, retval);\n\t\treturn retval;\n\t}\n\n\toff = le32_to_cpu(u.get_c->offset);\n\tlen = le32_to_cpu(u.get_c->len);\n\tif (unlikely((off > CONTROL_BUFFER_SIZE - 8) ||\n\t\t     (len > CONTROL_BUFFER_SIZE - 8 - off)))\n\t\tgoto response_error;\n\n\tif (*reply_len != -1 && len != *reply_len)\n\t\tgoto response_error;\n\n\t*reply = (unsigned char *) &u.get_c->request_id + off;\n\t*reply_len = len;\n\n\treturn retval;\n\nresponse_error:\n\tdev_err(&intf->dev, \"RNDIS_MSG_QUERY(0x%08x) \"\n\t\t\t\"invalid response - off %d len %d\\n\",\n\t\toid, off, len);\n\treturn -EDOM;\n}\n\n \nstatic const struct net_device_ops rndis_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nint\ngeneric_rndis_bind(struct usbnet *dev, struct usb_interface *intf, int flags)\n{\n\tint\t\t\tretval;\n\tstruct net_device\t*net = dev->net;\n\tstruct cdc_state\t*info = (void *) &dev->data;\n\tunion {\n\t\tvoid\t\t\t*buf;\n\t\tstruct rndis_msg_hdr\t*header;\n\t\tstruct rndis_init\t*init;\n\t\tstruct rndis_init_c\t*init_c;\n\t\tstruct rndis_query\t*get;\n\t\tstruct rndis_query_c\t*get_c;\n\t\tstruct rndis_set\t*set;\n\t\tstruct rndis_set_c\t*set_c;\n\t\tstruct rndis_halt\t*halt;\n\t} u;\n\tu32\t\t\ttmp;\n\t__le32\t\t\tphym_unspec, *phym;\n\tint\t\t\treply_len;\n\tunsigned char\t\t*bp;\n\n\t \n\tu.buf = kmalloc(CONTROL_BUFFER_SIZE, GFP_KERNEL);\n\tif (!u.buf)\n\t\treturn -ENOMEM;\n\tretval = usbnet_generic_cdc_bind(dev, intf);\n\tif (retval < 0)\n\t\tgoto fail;\n\n\tu.init->msg_type = cpu_to_le32(RNDIS_MSG_INIT);\n\tu.init->msg_len = cpu_to_le32(sizeof *u.init);\n\tu.init->major_version = cpu_to_le32(1);\n\tu.init->minor_version = cpu_to_le32(0);\n\n\t \n\tnet->hard_header_len += sizeof (struct rndis_data_hdr);\n\tdev->hard_mtu = net->mtu + net->hard_header_len;\n\n\tdev->maxpacket = usb_maxpacket(dev->udev, dev->out);\n\tif (dev->maxpacket == 0) {\n\t\tnetif_dbg(dev, probe, dev->net,\n\t\t\t  \"dev->maxpacket can't be 0\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto fail_and_release;\n\t}\n\n\tdev->rx_urb_size = dev->hard_mtu + (dev->maxpacket + 1);\n\tdev->rx_urb_size &= ~(dev->maxpacket - 1);\n\tu.init->max_transfer_size = cpu_to_le32(dev->rx_urb_size);\n\n\tnet->netdev_ops = &rndis_netdev_ops;\n\n\tretval = rndis_command(dev, u.header, CONTROL_BUFFER_SIZE);\n\tif (unlikely(retval < 0)) {\n\t\t \n\t\tdev_err(&intf->dev, \"RNDIS init failed, %d\\n\", retval);\n\t\tgoto fail_and_release;\n\t}\n\ttmp = le32_to_cpu(u.init_c->max_transfer_size);\n\tif (tmp < dev->hard_mtu) {\n\t\tif (tmp <= net->hard_header_len) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"dev can't take %u byte packets (max %u)\\n\",\n\t\t\t\tdev->hard_mtu, tmp);\n\t\t\tretval = -EINVAL;\n\t\t\tgoto halt_fail_and_release;\n\t\t}\n\t\tdev_warn(&intf->dev,\n\t\t\t \"dev can't take %u byte packets (max %u), \"\n\t\t\t \"adjusting MTU to %u\\n\",\n\t\t\t dev->hard_mtu, tmp, tmp - net->hard_header_len);\n\t\tdev->hard_mtu = tmp;\n\t\tnet->mtu = dev->hard_mtu - net->hard_header_len;\n\t}\n\n\t \n\tdev_dbg(&intf->dev,\n\t\t\"hard mtu %u (%u from dev), rx buflen %zu, align %d\\n\",\n\t\tdev->hard_mtu, tmp, dev->rx_urb_size,\n\t\t1 << le32_to_cpu(u.init_c->packet_alignment));\n\n\t \n\tif (dev->driver_info->early_init &&\n\t\t\tdev->driver_info->early_init(dev) != 0)\n\t\tgoto halt_fail_and_release;\n\n\t \n\tphym = NULL;\n\treply_len = sizeof *phym;\n\tretval = rndis_query(dev, intf, u.buf,\n\t\t\t     RNDIS_OID_GEN_PHYSICAL_MEDIUM,\n\t\t\t     reply_len, (void **)&phym, &reply_len);\n\tif (retval != 0 || !phym) {\n\t\t \n\t\tphym_unspec = cpu_to_le32(RNDIS_PHYSICAL_MEDIUM_UNSPECIFIED);\n\t\tphym = &phym_unspec;\n\t}\n\tif ((flags & FLAG_RNDIS_PHYM_WIRELESS) &&\n\t    le32_to_cpup(phym) != RNDIS_PHYSICAL_MEDIUM_WIRELESS_LAN) {\n\t\tnetif_dbg(dev, probe, dev->net,\n\t\t\t  \"driver requires wireless physical medium, but device is not\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto halt_fail_and_release;\n\t}\n\tif ((flags & FLAG_RNDIS_PHYM_NOT_WIRELESS) &&\n\t    le32_to_cpup(phym) == RNDIS_PHYSICAL_MEDIUM_WIRELESS_LAN) {\n\t\tnetif_dbg(dev, probe, dev->net,\n\t\t\t  \"driver requires non-wireless physical medium, but device is wireless.\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto halt_fail_and_release;\n\t}\n\n\t \n\treply_len = ETH_ALEN;\n\tretval = rndis_query(dev, intf, u.buf,\n\t\t\t     RNDIS_OID_802_3_PERMANENT_ADDRESS,\n\t\t\t     48, (void **) &bp, &reply_len);\n\tif (unlikely(retval< 0)) {\n\t\tdev_err(&intf->dev, \"rndis get ethaddr, %d\\n\", retval);\n\t\tgoto halt_fail_and_release;\n\t}\n\n\teth_hw_addr_set(net, bp);\n\n\t \n\tmemset(u.set, 0, sizeof *u.set);\n\tu.set->msg_type = cpu_to_le32(RNDIS_MSG_SET);\n\tu.set->msg_len = cpu_to_le32(4 + sizeof *u.set);\n\tu.set->oid = cpu_to_le32(RNDIS_OID_GEN_CURRENT_PACKET_FILTER);\n\tu.set->len = cpu_to_le32(4);\n\tu.set->offset = cpu_to_le32((sizeof *u.set) - 8);\n\t*(__le32 *)(u.buf + sizeof *u.set) = cpu_to_le32(RNDIS_DEFAULT_FILTER);\n\n\tretval = rndis_command(dev, u.header, CONTROL_BUFFER_SIZE);\n\tif (unlikely(retval < 0)) {\n\t\tdev_err(&intf->dev, \"rndis set packet filter, %d\\n\", retval);\n\t\tgoto halt_fail_and_release;\n\t}\n\n\tretval = 0;\n\n\tkfree(u.buf);\n\treturn retval;\n\nhalt_fail_and_release:\n\tmemset(u.halt, 0, sizeof *u.halt);\n\tu.halt->msg_type = cpu_to_le32(RNDIS_MSG_HALT);\n\tu.halt->msg_len = cpu_to_le32(sizeof *u.halt);\n\t(void) rndis_command(dev, (void *)u.halt, CONTROL_BUFFER_SIZE);\nfail_and_release:\n\tusb_set_intfdata(info->data, NULL);\n\tusb_driver_release_interface(driver_of(intf), info->data);\n\tinfo->data = NULL;\nfail:\n\tkfree(u.buf);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(generic_rndis_bind);\n\nstatic int rndis_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\treturn generic_rndis_bind(dev, intf, FLAG_RNDIS_PHYM_NOT_WIRELESS);\n}\n\nstatic int zte_rndis_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint status = rndis_bind(dev, intf);\n\n\tif (!status && (dev->net->dev_addr[0] & 0x02))\n\t\teth_hw_addr_random(dev->net);\n\n\treturn status;\n}\n\nvoid rndis_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct rndis_halt\t*halt;\n\n\t \n\thalt = kzalloc(CONTROL_BUFFER_SIZE, GFP_KERNEL);\n\tif (halt) {\n\t\thalt->msg_type = cpu_to_le32(RNDIS_MSG_HALT);\n\t\thalt->msg_len = cpu_to_le32(sizeof *halt);\n\t\t(void) rndis_command(dev, (void *)halt, CONTROL_BUFFER_SIZE);\n\t\tkfree(halt);\n\t}\n\n\tusbnet_cdc_unbind(dev, intf);\n}\nEXPORT_SYMBOL_GPL(rndis_unbind);\n\n \nint rndis_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tbool dst_mac_fixup;\n\n\t \n\tif (skb->len < dev->net->hard_header_len)\n\t\treturn 0;\n\n\tdst_mac_fixup = !!(dev->driver_info->data & RNDIS_DRIVER_DATA_DST_MAC_FIXUP);\n\n\t \n\twhile (likely(skb->len)) {\n\t\tstruct rndis_data_hdr\t*hdr = (void *)skb->data;\n\t\tstruct sk_buff\t\t*skb2;\n\t\tu32\t\t\tmsg_type, msg_len, data_offset, data_len;\n\n\t\tmsg_type = le32_to_cpu(hdr->msg_type);\n\t\tmsg_len = le32_to_cpu(hdr->msg_len);\n\t\tdata_offset = le32_to_cpu(hdr->data_offset);\n\t\tdata_len = le32_to_cpu(hdr->data_len);\n\n\t\t \n\t\tif (unlikely(msg_type != RNDIS_MSG_PACKET || skb->len < msg_len\n\t\t\t\t|| (data_offset + data_len + 8) > msg_len)) {\n\t\t\tdev->net->stats.rx_frame_errors++;\n\t\t\tnetdev_dbg(dev->net, \"bad rndis message %d/%d/%d/%d, len %d\\n\",\n\t\t\t\t   le32_to_cpu(hdr->msg_type),\n\t\t\t\t   msg_len, data_offset, data_len, skb->len);\n\t\t\treturn 0;\n\t\t}\n\t\tskb_pull(skb, 8 + data_offset);\n\n\t\t \n\t\tif (likely((data_len - skb->len) <= sizeof *hdr)) {\n\t\t\tskb_trim(skb, data_len);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tif (unlikely(!skb2))\n\t\t\tbreak;\n\t\tskb_pull(skb, msg_len - sizeof *hdr);\n\t\tskb_trim(skb2, data_len);\n\n\t\tif (unlikely(dst_mac_fixup))\n\t\t\tusbnet_cdc_zte_rx_fixup(dev, skb2);\n\n\t\tusbnet_skb_return(dev, skb2);\n\t}\n\n\t \n\tif (unlikely(dst_mac_fixup))\n\t\tusbnet_cdc_zte_rx_fixup(dev, skb);\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(rndis_rx_fixup);\n\nstruct sk_buff *\nrndis_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\n{\n\tstruct rndis_data_hdr\t*hdr;\n\tstruct sk_buff\t\t*skb2;\n\tunsigned\t\tlen = skb->len;\n\n\tif (likely(!skb_cloned(skb))) {\n\t\tint\troom = skb_headroom(skb);\n\n\t\t \n\t\tif (unlikely((sizeof *hdr) <= room))\n\t\t\tgoto fill;\n\n\t\t \n\t\troom += skb_tailroom(skb);\n\t\tif (likely((sizeof *hdr) <= room)) {\n\t\t\tskb->data = memmove(skb->head + sizeof *hdr,\n\t\t\t\t\t    skb->data, len);\n\t\t\tskb_set_tail_pointer(skb, len);\n\t\t\tgoto fill;\n\t\t}\n\t}\n\n\t \n\tskb2 = skb_copy_expand(skb, sizeof *hdr, 1, flags);\n\tdev_kfree_skb_any(skb);\n\tif (unlikely(!skb2))\n\t\treturn skb2;\n\tskb = skb2;\n\n\t \nfill:\n\thdr = __skb_push(skb, sizeof *hdr);\n\tmemset(hdr, 0, sizeof *hdr);\n\thdr->msg_type = cpu_to_le32(RNDIS_MSG_PACKET);\n\thdr->msg_len = cpu_to_le32(skb->len);\n\thdr->data_offset = cpu_to_le32(sizeof(*hdr) - 8);\n\thdr->data_len = cpu_to_le32(len);\n\n\t \n\treturn skb;\n}\nEXPORT_SYMBOL_GPL(rndis_tx_fixup);\n\n\nstatic const struct driver_info\trndis_info = {\n\t.description =\t\"RNDIS device\",\n\t.flags =\tFLAG_ETHER | FLAG_POINTTOPOINT | FLAG_FRAMING_RN | FLAG_NO_SETINT,\n\t.bind =\t\trndis_bind,\n\t.unbind =\trndis_unbind,\n\t.status =\trndis_status,\n\t.rx_fixup =\trndis_rx_fixup,\n\t.tx_fixup =\trndis_tx_fixup,\n};\n\nstatic const struct driver_info\trndis_poll_status_info = {\n\t.description =\t\"RNDIS device (poll status before control)\",\n\t.flags =\tFLAG_ETHER | FLAG_POINTTOPOINT | FLAG_FRAMING_RN | FLAG_NO_SETINT,\n\t.data =\t\tRNDIS_DRIVER_DATA_POLL_STATUS,\n\t.bind =\t\trndis_bind,\n\t.unbind =\trndis_unbind,\n\t.status =\trndis_status,\n\t.rx_fixup =\trndis_rx_fixup,\n\t.tx_fixup =\trndis_tx_fixup,\n};\n\nstatic const struct driver_info\tzte_rndis_info = {\n\t.description =\t\"ZTE RNDIS device\",\n\t.flags =\tFLAG_ETHER | FLAG_POINTTOPOINT | FLAG_FRAMING_RN | FLAG_NO_SETINT,\n\t.data =\t\tRNDIS_DRIVER_DATA_DST_MAC_FIXUP,\n\t.bind =\t\tzte_rndis_bind,\n\t.unbind =\trndis_unbind,\n\t.status =\trndis_status,\n\t.rx_fixup =\trndis_rx_fixup,\n\t.tx_fixup =\trndis_tx_fixup,\n};\n\n \n\nstatic const struct usb_device_id\tproducts [] = {\n{\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x1630, 0x0042,\n\t\t\t\t      USB_CLASS_COMM, 2  , 0x0ff),\n\t.driver_info = (unsigned long) &rndis_poll_status_info,\n}, {\n\t \n\tUSB_VENDOR_AND_INTERFACE_INFO(0x238b,\n\t\t\t\t      USB_CLASS_COMM, 2  , 0x0ff),\n\t.driver_info = (unsigned long)&rndis_info,\n}, {\n\t \n\tUSB_VENDOR_AND_INTERFACE_INFO(0x19d2,\n\t\t\t\t      USB_CLASS_WIRELESS_CONTROLLER, 1, 3),\n\t.driver_info = (unsigned long)&zte_rndis_info,\n}, {\n\t \n\tUSB_VENDOR_AND_INTERFACE_INFO(0x19d2,\n\t\t\t\t      USB_CLASS_COMM, 2  , 0x0ff),\n\t.driver_info = (unsigned long)&zte_rndis_info,\n}, {\n\t \n\tUSB_INTERFACE_INFO(USB_CLASS_COMM, 2  , 0x0ff),\n\t.driver_info = (unsigned long) &rndis_info,\n}, {\n\t \n\tUSB_INTERFACE_INFO(USB_CLASS_MISC, 1, 1),\n\t.driver_info = (unsigned long) &rndis_poll_status_info,\n}, {\n\t \n\tUSB_INTERFACE_INFO(USB_CLASS_WIRELESS_CONTROLLER, 1, 3),\n\t.driver_info = (unsigned long) &rndis_info,\n}, {\n\t \n\tUSB_INTERFACE_INFO(USB_CLASS_MISC, 4, 1),\n\t.driver_info = (unsigned long) &rndis_info,\n},\n\t{ },\t\t \n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver rndis_driver = {\n\t.name =\t\t\"rndis_host\",\n\t.id_table =\tproducts,\n\t.probe =\tusbnet_probe,\n\t.disconnect =\tusbnet_disconnect,\n\t.suspend =\tusbnet_suspend,\n\t.resume =\tusbnet_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(rndis_driver);\n\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_DESCRIPTION(\"USB Host side RNDIS driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}