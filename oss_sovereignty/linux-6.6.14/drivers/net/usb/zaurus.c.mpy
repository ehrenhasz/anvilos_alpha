{
  "module_name": "zaurus.c",
  "hash_id": "e5dc23812f260c20ad180ff8fbf1501634ce59ace62bca574b32267bfd6bf728",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/zaurus.c",
  "human_readable_source": "\n \n\n\n\n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/mii.h>\n#include <linux/crc32.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/usbnet.h>\n\n\n \n\nstatic struct sk_buff *\nzaurus_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\n{\n\tint\t\t\tpadlen;\n\tstruct sk_buff\t\t*skb2;\n\n\tpadlen = 2;\n\tif (!skb_cloned(skb)) {\n\t\tint\ttailroom = skb_tailroom(skb);\n\t\tif ((padlen + 4) <= tailroom)\n\t\t\tgoto done;\n\t}\n\tskb2 = skb_copy_expand(skb, 0, 4 + padlen, flags);\n\tdev_kfree_skb_any(skb);\n\tskb = skb2;\n\tif (skb) {\n\t\tu32\t\tfcs;\ndone:\n\t\tfcs = crc32_le(~0, skb->data, skb->len);\n\t\tfcs = ~fcs;\n\n\t\tskb_put_u8(skb, fcs & 0xff);\n\t\tskb_put_u8(skb, (fcs >> 8) & 0xff);\n\t\tskb_put_u8(skb, (fcs >> 16) & 0xff);\n\t\tskb_put_u8(skb, (fcs >> 24) & 0xff);\n\t}\n\treturn skb;\n}\n\nstatic int zaurus_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\t \n\tdev->net->hard_header_len += 6;\n\tdev->rx_urb_size = dev->net->hard_header_len + dev->net->mtu;\n\treturn usbnet_generic_cdc_bind(dev, intf);\n}\n\n \nstatic int always_connected (struct usbnet *dev)\n{\n\treturn 0;\n}\n\nstatic const struct driver_info\tzaurus_sl5x00_info = {\n\t.description =\t\"Sharp Zaurus SL-5x00\",\n\t.flags =\tFLAG_POINTTOPOINT | FLAG_FRAMING_Z,\n\t.check_connect = always_connected,\n\t.bind =\t\tzaurus_bind,\n\t.unbind =\tusbnet_cdc_unbind,\n\t.tx_fixup =\tzaurus_tx_fixup,\n};\n#define\tZAURUS_STRONGARM_INFO\t((unsigned long)&zaurus_sl5x00_info)\n\nstatic const struct driver_info\tzaurus_pxa_info = {\n\t.description =\t\"Sharp Zaurus, PXA-2xx based\",\n\t.flags =\tFLAG_POINTTOPOINT | FLAG_FRAMING_Z,\n\t.check_connect = always_connected,\n\t.bind =\t\tzaurus_bind,\n\t.unbind =\tusbnet_cdc_unbind,\n\t.tx_fixup =\tzaurus_tx_fixup,\n};\n#define\tZAURUS_PXA_INFO\t\t((unsigned long)&zaurus_pxa_info)\n\nstatic const struct driver_info\tolympus_mxl_info = {\n\t.description =\t\"Olympus R1000\",\n\t.flags =\tFLAG_POINTTOPOINT | FLAG_FRAMING_Z,\n\t.check_connect = always_connected,\n\t.bind =\t\tzaurus_bind,\n\t.unbind =\tusbnet_cdc_unbind,\n\t.tx_fixup =\tzaurus_tx_fixup,\n};\n#define\tOLYMPUS_MXL_INFO\t((unsigned long)&olympus_mxl_info)\n\n\n \nstatic const u8 safe_guid[16] = {\n\t0x5d, 0x34, 0xcf, 0x66, 0x11, 0x18, 0x11, 0xd6,\n\t0xa2, 0x1a, 0x00, 0x01, 0x02, 0xca, 0x9a, 0x7f,\n};\nstatic const u8 blan_guid[16] = {\n\t0x74, 0xf0, 0x3d, 0xbd, 0x1e, 0xc1, 0x44, 0x70,\n\t0xa3, 0x67, 0x71, 0x34, 0xc9, 0xf5, 0x54, 0x37,\n};\n\nstatic int blan_mdlm_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tu8\t\t\t\t*buf = intf->cur_altsetting->extra;\n\tint\t\t\t\tlen = intf->cur_altsetting->extralen;\n\tstruct usb_cdc_mdlm_desc\t*desc = NULL;\n\tstruct usb_cdc_mdlm_detail_desc\t*detail = NULL;\n\n\twhile (len > 3) {\n\t\tif (buf [1] != USB_DT_CS_INTERFACE)\n\t\t\tgoto next_desc;\n\n\t\t \n\t\tswitch (buf [2]) {\n\t\tcase USB_CDC_MDLM_TYPE:\n\t\t\tif (desc) {\n\t\t\t\tdev_dbg(&intf->dev, \"extra MDLM\\n\");\n\t\t\t\tgoto bad_desc;\n\t\t\t}\n\t\t\tdesc = (void *) buf;\n\t\t\tif (desc->bLength != sizeof *desc) {\n\t\t\t\tdev_dbg(&intf->dev, \"MDLM len %u\\n\",\n\t\t\t\t\tdesc->bLength);\n\t\t\t\tgoto bad_desc;\n\t\t\t}\n\t\t\t \n\t\t\tif (memcmp(&desc->bGUID, blan_guid, 16) &&\n\t\t\t    memcmp(&desc->bGUID, safe_guid, 16)) {\n\t\t\t\t \n\t\t\t\tdev_dbg(&intf->dev, \"MDLM guid\\n\");\n\t\t\t\tgoto bad_desc;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_DETAIL_TYPE:\n\t\t\tif (detail) {\n\t\t\t\tdev_dbg(&intf->dev, \"extra MDLM detail\\n\");\n\t\t\t\tgoto bad_desc;\n\t\t\t}\n\t\t\tdetail = (void *) buf;\n\t\t\tswitch (detail->bGuidDescriptorType) {\n\t\t\tcase 0:\t\t\t \n\t\t\t\tif (detail->bLength != (sizeof *detail + 2))\n\t\t\t\t\tgoto bad_detail;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t\t\t \n\t\t\t\tif (detail->bLength != (sizeof *detail + 3))\n\t\t\t\t\tgoto bad_detail;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto bad_detail;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((detail->bDetailData[1] & ~0x02) != 0x01) {\n\t\t\t\t \nbad_detail:\n\t\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\t\t\"bad MDLM detail, %d %d %d\\n\",\n\t\t\t\t\t\tdetail->bLength,\n\t\t\t\t\t\tdetail->bDetailData[0],\n\t\t\t\t\t\tdetail->bDetailData[2]);\n\t\t\t\tgoto bad_desc;\n\t\t\t}\n\n\t\t\t \n\t\t\tdev->net->hard_header_len += 6;\n\t\t\tdev->rx_urb_size = dev->net->hard_header_len\n\t\t\t\t\t+ dev->net->mtu;\n\t\t\tbreak;\n\t\t}\nnext_desc:\n\t\tlen -= buf [0];\t \n\t\tbuf += buf [0];\n\t}\n\n\tif (!desc || !detail) {\n\t\tdev_dbg(&intf->dev, \"missing cdc mdlm %s%sdescriptor\\n\",\n\t\t\tdesc ? \"\" : \"func \",\n\t\t\tdetail ? \"\" : \"detail \");\n\t\tgoto bad_desc;\n\t}\n\n\t \n\treturn usbnet_get_endpoints(dev, intf);\n\nbad_desc:\n\tdev_info(&dev->udev->dev, \"unsupported MDLM descriptors\\n\");\n\treturn -ENODEV;\n}\n\nstatic const struct driver_info\tbogus_mdlm_info = {\n\t.description =\t\"pseudo-MDLM (BLAN) device\",\n\t.flags =\tFLAG_POINTTOPOINT | FLAG_FRAMING_Z,\n\t.check_connect = always_connected,\n\t.tx_fixup =\tzaurus_tx_fixup,\n\t.bind =\t\tblan_mdlm_bind,\n};\n\nstatic const struct usb_device_id\tproducts [] = {\n#define\tZAURUS_MASTER_INTERFACE \\\n\t.bInterfaceClass\t= USB_CLASS_COMM, \\\n\t.bInterfaceSubClass\t= USB_CDC_SUBCLASS_ETHERNET, \\\n\t.bInterfaceProtocol\t= USB_CDC_PROTO_NONE\n\n#define ZAURUS_FAKE_INTERFACE \\\n\t.bInterfaceClass\t= USB_CLASS_COMM, \\\n\t.bInterfaceSubClass\t= USB_CDC_SUBCLASS_MDLM, \\\n\t.bInterfaceProtocol\t= USB_CDC_PROTO_NONE\n\n \n{\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8004,\n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info = ZAURUS_STRONGARM_INFO,\n},\n\n \n{\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8005,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info = ZAURUS_PXA_INFO,\n}, {\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8005,\t \n\tZAURUS_FAKE_INTERFACE,\n\t.driver_info = (unsigned long)&bogus_mdlm_info,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8006,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info = ZAURUS_PXA_INFO,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8006,\t \n\tZAURUS_FAKE_INTERFACE,\n\t.driver_info = (unsigned long)&bogus_mdlm_info,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t          | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8007,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info = ZAURUS_PXA_INFO,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8007,\t \n\tZAURUS_FAKE_INTERFACE,\n\t.driver_info = (unsigned long)&bogus_mdlm_info,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor               = 0x04DD,\n\t.idProduct              = 0x9031,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info = ZAURUS_PXA_INFO,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x04DD, 0x9031, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_MDLM, USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long) &bogus_mdlm_info,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor               = 0x04DD,\n\t.idProduct              = 0x9032,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info = ZAURUS_PXA_INFO,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t    | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x9032,\t \n\tZAURUS_FAKE_INTERFACE,\n\t.driver_info = (unsigned long)&bogus_mdlm_info,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor               = 0x04DD,\n\t \n\t.idProduct              = 0x9050,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info = ZAURUS_PXA_INFO,\n},\n{\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x22b8, 0x6027, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_MDLM, USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long) &bogus_mdlm_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x22b8, 0x6425, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_MDLM, USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long) &bogus_mdlm_info,\n},\n\n \n{\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor               = 0x07B4,\n\t.idProduct              = 0x0F02,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info = OLYMPUS_MXL_INFO,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(0x046d, 0xc11f, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_MDLM, USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long) &bogus_mdlm_info,\n},\n\t{ },\t\t\n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver zaurus_driver = {\n\t.name =\t\t\"zaurus\",\n\t.id_table =\tproducts,\n\t.probe =\tusbnet_probe,\n\t.disconnect =\tusbnet_disconnect,\n\t.suspend =\tusbnet_suspend,\n\t.resume =\tusbnet_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(zaurus_driver);\n\nMODULE_AUTHOR(\"Pavel Machek, David Brownell\");\nMODULE_DESCRIPTION(\"Sharp Zaurus PDA, and compatible products\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}