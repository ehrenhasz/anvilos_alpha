{
  "module_name": "smsc75xx.c",
  "hash_id": "db406faa0228566ae8275ba8ea250211b0f39bef0165ee3bd599649473656b33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/smsc75xx.c",
  "human_readable_source": "\n  \n\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/bitrev.h>\n#include <linux/crc16.h>\n#include <linux/crc32.h>\n#include <linux/usb/usbnet.h>\n#include <linux/slab.h>\n#include <linux/of_net.h>\n#include \"smsc75xx.h\"\n\n#define SMSC_CHIPNAME\t\t\t\"smsc75xx\"\n#define SMSC_DRIVER_VERSION\t\t\"1.0.0\"\n#define HS_USB_PKT_SIZE\t\t\t(512)\n#define FS_USB_PKT_SIZE\t\t\t(64)\n#define DEFAULT_HS_BURST_CAP_SIZE\t(16 * 1024 + 5 * HS_USB_PKT_SIZE)\n#define DEFAULT_FS_BURST_CAP_SIZE\t(6 * 1024 + 33 * FS_USB_PKT_SIZE)\n#define DEFAULT_BULK_IN_DELAY\t\t(0x00002000)\n#define MAX_SINGLE_PACKET_SIZE\t\t(9000)\n#define LAN75XX_EEPROM_MAGIC\t\t(0x7500)\n#define EEPROM_MAC_OFFSET\t\t(0x01)\n#define DEFAULT_TX_CSUM_ENABLE\t\t(true)\n#define DEFAULT_RX_CSUM_ENABLE\t\t(true)\n#define SMSC75XX_INTERNAL_PHY_ID\t(1)\n#define SMSC75XX_TX_OVERHEAD\t\t(8)\n#define MAX_RX_FIFO_SIZE\t\t(20 * 1024)\n#define MAX_TX_FIFO_SIZE\t\t(12 * 1024)\n#define USB_VENDOR_ID_SMSC\t\t(0x0424)\n#define USB_PRODUCT_ID_LAN7500\t\t(0x7500)\n#define USB_PRODUCT_ID_LAN7505\t\t(0x7505)\n#define RXW_PADDING\t\t\t2\n#define SUPPORTED_WAKE\t\t\t(WAKE_PHY | WAKE_UCAST | WAKE_BCAST | \\\n\t\t\t\t\t WAKE_MCAST | WAKE_ARP | WAKE_MAGIC)\n\n#define SUSPEND_SUSPEND0\t\t(0x01)\n#define SUSPEND_SUSPEND1\t\t(0x02)\n#define SUSPEND_SUSPEND2\t\t(0x04)\n#define SUSPEND_SUSPEND3\t\t(0x08)\n#define SUSPEND_ALLMODES\t\t(SUSPEND_SUSPEND0 | SUSPEND_SUSPEND1 | \\\n\t\t\t\t\t SUSPEND_SUSPEND2 | SUSPEND_SUSPEND3)\n\nstruct smsc75xx_priv {\n\tstruct usbnet *dev;\n\tu32 rfe_ctl;\n\tu32 wolopts;\n\tu32 multicast_hash_table[DP_SEL_VHF_HASH_LEN];\n\tstruct mutex dataport_mutex;\n\tspinlock_t rfe_ctl_lock;\n\tstruct work_struct set_multicast;\n\tu8 suspend_flags;\n};\n\nstruct usb_context {\n\tstruct usb_ctrlrequest req;\n\tstruct usbnet *dev;\n};\n\nstatic bool turbo_mode = true;\nmodule_param(turbo_mode, bool, 0644);\nMODULE_PARM_DESC(turbo_mode, \"Enable multiple frames per Rx transaction\");\n\nstatic int smsc75xx_link_ok_nopm(struct usbnet *dev);\nstatic int smsc75xx_phy_gig_workaround(struct usbnet *dev);\n\nstatic int __must_check __smsc75xx_read_reg(struct usbnet *dev, u32 index,\n\t\t\t\t\t    u32 *data, int in_pm)\n{\n\tu32 buf;\n\tint ret;\n\tint (*fn)(struct usbnet *, u8, u8, u16, u16, void *, u16);\n\n\tBUG_ON(!dev);\n\n\tif (!in_pm)\n\t\tfn = usbnet_read_cmd;\n\telse\n\t\tfn = usbnet_read_cmd_nopm;\n\n\tret = fn(dev, USB_VENDOR_REQUEST_READ_REGISTER, USB_DIR_IN\n\t\t | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t 0, index, &buf, 4);\n\tif (unlikely(ret < 4)) {\n\t\tret = ret < 0 ? ret : -ENODATA;\n\n\t\tnetdev_warn(dev->net, \"Failed to read reg index 0x%08x: %d\\n\",\n\t\t\t    index, ret);\n\t\treturn ret;\n\t}\n\n\tle32_to_cpus(&buf);\n\t*data = buf;\n\n\treturn ret;\n}\n\nstatic int __must_check __smsc75xx_write_reg(struct usbnet *dev, u32 index,\n\t\t\t\t\t     u32 data, int in_pm)\n{\n\tu32 buf;\n\tint ret;\n\tint (*fn)(struct usbnet *, u8, u8, u16, u16, const void *, u16);\n\n\tBUG_ON(!dev);\n\n\tif (!in_pm)\n\t\tfn = usbnet_write_cmd;\n\telse\n\t\tfn = usbnet_write_cmd_nopm;\n\n\tbuf = data;\n\tcpu_to_le32s(&buf);\n\n\tret = fn(dev, USB_VENDOR_REQUEST_WRITE_REGISTER, USB_DIR_OUT\n\t\t | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t 0, index, &buf, 4);\n\tif (unlikely(ret < 0))\n\t\tnetdev_warn(dev->net, \"Failed to write reg index 0x%08x: %d\\n\",\n\t\t\t    index, ret);\n\n\treturn ret;\n}\n\nstatic int __must_check smsc75xx_read_reg_nopm(struct usbnet *dev, u32 index,\n\t\t\t\t\t       u32 *data)\n{\n\treturn __smsc75xx_read_reg(dev, index, data, 1);\n}\n\nstatic int __must_check smsc75xx_write_reg_nopm(struct usbnet *dev, u32 index,\n\t\t\t\t\t\tu32 data)\n{\n\treturn __smsc75xx_write_reg(dev, index, data, 1);\n}\n\nstatic int __must_check smsc75xx_read_reg(struct usbnet *dev, u32 index,\n\t\t\t\t\t  u32 *data)\n{\n\treturn __smsc75xx_read_reg(dev, index, data, 0);\n}\n\nstatic int __must_check smsc75xx_write_reg(struct usbnet *dev, u32 index,\n\t\t\t\t\t   u32 data)\n{\n\treturn __smsc75xx_write_reg(dev, index, data, 0);\n}\n\n \nstatic __must_check int __smsc75xx_phy_wait_not_busy(struct usbnet *dev,\n\t\t\t\t\t\t     int in_pm)\n{\n\tunsigned long start_time = jiffies;\n\tu32 val;\n\tint ret;\n\n\tdo {\n\t\tret = __smsc75xx_read_reg(dev, MII_ACCESS, &val, in_pm);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading MII_ACCESS\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(val & MII_ACCESS_BUSY))\n\t\t\treturn 0;\n\t} while (!time_after(jiffies, start_time + HZ));\n\n\treturn -EIO;\n}\n\nstatic int __smsc75xx_mdio_read(struct net_device *netdev, int phy_id, int idx,\n\t\t\t\tint in_pm)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tu32 val, addr;\n\tint ret;\n\n\tmutex_lock(&dev->phy_mutex);\n\n\t \n\tret = __smsc75xx_phy_wait_not_busy(dev, in_pm);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"MII is busy in smsc75xx_mdio_read\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tphy_id &= dev->mii.phy_id_mask;\n\tidx &= dev->mii.reg_num_mask;\n\taddr = ((phy_id << MII_ACCESS_PHY_ADDR_SHIFT) & MII_ACCESS_PHY_ADDR)\n\t\t| ((idx << MII_ACCESS_REG_ADDR_SHIFT) & MII_ACCESS_REG_ADDR)\n\t\t| MII_ACCESS_READ | MII_ACCESS_BUSY;\n\tret = __smsc75xx_write_reg(dev, MII_ACCESS, addr, in_pm);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing MII_ACCESS\\n\");\n\t\tgoto done;\n\t}\n\n\tret = __smsc75xx_phy_wait_not_busy(dev, in_pm);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Timed out reading MII reg %02X\\n\", idx);\n\t\tgoto done;\n\t}\n\n\tret = __smsc75xx_read_reg(dev, MII_DATA, &val, in_pm);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error reading MII_DATA\\n\");\n\t\tgoto done;\n\t}\n\n\tret = (u16)(val & 0xFFFF);\n\ndone:\n\tmutex_unlock(&dev->phy_mutex);\n\treturn ret;\n}\n\nstatic void __smsc75xx_mdio_write(struct net_device *netdev, int phy_id,\n\t\t\t\t  int idx, int regval, int in_pm)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tu32 val, addr;\n\tint ret;\n\n\tmutex_lock(&dev->phy_mutex);\n\n\t \n\tret = __smsc75xx_phy_wait_not_busy(dev, in_pm);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"MII is busy in smsc75xx_mdio_write\\n\");\n\t\tgoto done;\n\t}\n\n\tval = regval;\n\tret = __smsc75xx_write_reg(dev, MII_DATA, val, in_pm);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing MII_DATA\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tphy_id &= dev->mii.phy_id_mask;\n\tidx &= dev->mii.reg_num_mask;\n\taddr = ((phy_id << MII_ACCESS_PHY_ADDR_SHIFT) & MII_ACCESS_PHY_ADDR)\n\t\t| ((idx << MII_ACCESS_REG_ADDR_SHIFT) & MII_ACCESS_REG_ADDR)\n\t\t| MII_ACCESS_WRITE | MII_ACCESS_BUSY;\n\tret = __smsc75xx_write_reg(dev, MII_ACCESS, addr, in_pm);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing MII_ACCESS\\n\");\n\t\tgoto done;\n\t}\n\n\tret = __smsc75xx_phy_wait_not_busy(dev, in_pm);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Timed out writing MII reg %02X\\n\", idx);\n\t\tgoto done;\n\t}\n\ndone:\n\tmutex_unlock(&dev->phy_mutex);\n}\n\nstatic int smsc75xx_mdio_read_nopm(struct net_device *netdev, int phy_id,\n\t\t\t\t   int idx)\n{\n\treturn __smsc75xx_mdio_read(netdev, phy_id, idx, 1);\n}\n\nstatic void smsc75xx_mdio_write_nopm(struct net_device *netdev, int phy_id,\n\t\t\t\t     int idx, int regval)\n{\n\t__smsc75xx_mdio_write(netdev, phy_id, idx, regval, 1);\n}\n\nstatic int smsc75xx_mdio_read(struct net_device *netdev, int phy_id, int idx)\n{\n\treturn __smsc75xx_mdio_read(netdev, phy_id, idx, 0);\n}\n\nstatic void smsc75xx_mdio_write(struct net_device *netdev, int phy_id, int idx,\n\t\t\t\tint regval)\n{\n\t__smsc75xx_mdio_write(netdev, phy_id, idx, regval, 0);\n}\n\nstatic int smsc75xx_wait_eeprom(struct usbnet *dev)\n{\n\tunsigned long start_time = jiffies;\n\tu32 val;\n\tint ret;\n\n\tdo {\n\t\tret = smsc75xx_read_reg(dev, E2P_CMD, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading E2P_CMD\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(val & E2P_CMD_BUSY) || (val & E2P_CMD_TIMEOUT))\n\t\t\tbreak;\n\t\tudelay(40);\n\t} while (!time_after(jiffies, start_time + HZ));\n\n\tif (val & (E2P_CMD_TIMEOUT | E2P_CMD_BUSY)) {\n\t\tnetdev_warn(dev->net, \"EEPROM read operation timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int smsc75xx_eeprom_confirm_not_busy(struct usbnet *dev)\n{\n\tunsigned long start_time = jiffies;\n\tu32 val;\n\tint ret;\n\n\tdo {\n\t\tret = smsc75xx_read_reg(dev, E2P_CMD, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading E2P_CMD\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(val & E2P_CMD_BUSY))\n\t\t\treturn 0;\n\n\t\tudelay(40);\n\t} while (!time_after(jiffies, start_time + HZ));\n\n\tnetdev_warn(dev->net, \"EEPROM is busy\\n\");\n\treturn -EIO;\n}\n\nstatic int smsc75xx_read_eeprom(struct usbnet *dev, u32 offset, u32 length,\n\t\t\t\tu8 *data)\n{\n\tu32 val;\n\tint i, ret;\n\n\tBUG_ON(!dev);\n\tBUG_ON(!data);\n\n\tret = smsc75xx_eeprom_confirm_not_busy(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < length; i++) {\n\t\tval = E2P_CMD_BUSY | E2P_CMD_READ | (offset & E2P_CMD_ADDR);\n\t\tret = smsc75xx_write_reg(dev, E2P_CMD, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing E2P_CMD\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = smsc75xx_wait_eeprom(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = smsc75xx_read_reg(dev, E2P_DATA, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading E2P_DATA\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata[i] = val & 0xFF;\n\t\toffset++;\n\t}\n\n\treturn 0;\n}\n\nstatic int smsc75xx_write_eeprom(struct usbnet *dev, u32 offset, u32 length,\n\t\t\t\t u8 *data)\n{\n\tu32 val;\n\tint i, ret;\n\n\tBUG_ON(!dev);\n\tBUG_ON(!data);\n\n\tret = smsc75xx_eeprom_confirm_not_busy(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = E2P_CMD_BUSY | E2P_CMD_EWEN;\n\tret = smsc75xx_write_reg(dev, E2P_CMD, val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing E2P_CMD\\n\");\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_wait_eeprom(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < length; i++) {\n\n\t\t \n\t\tval = data[i];\n\t\tret = smsc75xx_write_reg(dev, E2P_DATA, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing E2P_DATA\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tval = E2P_CMD_BUSY | E2P_CMD_WRITE | (offset & E2P_CMD_ADDR);\n\t\tret = smsc75xx_write_reg(dev, E2P_CMD, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing E2P_CMD\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = smsc75xx_wait_eeprom(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\toffset++;\n\t}\n\n\treturn 0;\n}\n\nstatic int smsc75xx_dataport_wait_not_busy(struct usbnet *dev)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tu32 dp_sel;\n\t\tret = smsc75xx_read_reg(dev, DP_SEL, &dp_sel);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading DP_SEL\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (dp_sel & DP_SEL_DPRDY)\n\t\t\treturn 0;\n\n\t\tudelay(40);\n\t}\n\n\tnetdev_warn(dev->net, \"smsc75xx_dataport_wait_not_busy timed out\\n\");\n\n\treturn -EIO;\n}\n\nstatic int smsc75xx_dataport_write(struct usbnet *dev, u32 ram_select, u32 addr,\n\t\t\t\t   u32 length, u32 *buf)\n{\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tu32 dp_sel;\n\tint i, ret;\n\n\tmutex_lock(&pdata->dataport_mutex);\n\n\tret = smsc75xx_dataport_wait_not_busy(dev);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"smsc75xx_dataport_write busy on entry\\n\");\n\t\tgoto done;\n\t}\n\n\tret = smsc75xx_read_reg(dev, DP_SEL, &dp_sel);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error reading DP_SEL\\n\");\n\t\tgoto done;\n\t}\n\n\tdp_sel &= ~DP_SEL_RSEL;\n\tdp_sel |= ram_select;\n\tret = smsc75xx_write_reg(dev, DP_SEL, dp_sel);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing DP_SEL\\n\");\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < length; i++) {\n\t\tret = smsc75xx_write_reg(dev, DP_ADDR, addr + i);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing DP_ADDR\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = smsc75xx_write_reg(dev, DP_DATA, buf[i]);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing DP_DATA\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = smsc75xx_write_reg(dev, DP_CMD, DP_CMD_WRITE);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing DP_CMD\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = smsc75xx_dataport_wait_not_busy(dev);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"smsc75xx_dataport_write timeout\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tmutex_unlock(&pdata->dataport_mutex);\n\treturn ret;\n}\n\n \nstatic u32 smsc75xx_hash(char addr[ETH_ALEN])\n{\n\treturn (ether_crc(ETH_ALEN, addr) >> 23) & 0x1ff;\n}\n\nstatic void smsc75xx_deferred_multicast_write(struct work_struct *param)\n{\n\tstruct smsc75xx_priv *pdata =\n\t\tcontainer_of(param, struct smsc75xx_priv, set_multicast);\n\tstruct usbnet *dev = pdata->dev;\n\tint ret;\n\n\tnetif_dbg(dev, drv, dev->net, \"deferred multicast write 0x%08x\\n\",\n\t\t  pdata->rfe_ctl);\n\n\tsmsc75xx_dataport_write(dev, DP_SEL_VHF, DP_SEL_VHF_VLAN_LEN,\n\t\tDP_SEL_VHF_HASH_LEN, pdata->multicast_hash_table);\n\n\tret = smsc75xx_write_reg(dev, RFE_CTL, pdata->rfe_ctl);\n\tif (ret < 0)\n\t\tnetdev_warn(dev->net, \"Error writing RFE_CRL\\n\");\n}\n\nstatic void smsc75xx_set_multicast(struct net_device *netdev)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&pdata->rfe_ctl_lock, flags);\n\n\tpdata->rfe_ctl &=\n\t\t~(RFE_CTL_AU | RFE_CTL_AM | RFE_CTL_DPF | RFE_CTL_MHF);\n\tpdata->rfe_ctl |= RFE_CTL_AB;\n\n\tfor (i = 0; i < DP_SEL_VHF_HASH_LEN; i++)\n\t\tpdata->multicast_hash_table[i] = 0;\n\n\tif (dev->net->flags & IFF_PROMISC) {\n\t\tnetif_dbg(dev, drv, dev->net, \"promiscuous mode enabled\\n\");\n\t\tpdata->rfe_ctl |= RFE_CTL_AM | RFE_CTL_AU;\n\t} else if (dev->net->flags & IFF_ALLMULTI) {\n\t\tnetif_dbg(dev, drv, dev->net, \"receive all multicast enabled\\n\");\n\t\tpdata->rfe_ctl |= RFE_CTL_AM | RFE_CTL_DPF;\n\t} else if (!netdev_mc_empty(dev->net)) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tnetif_dbg(dev, drv, dev->net, \"receive multicast hash filter\\n\");\n\n\t\tpdata->rfe_ctl |= RFE_CTL_MHF | RFE_CTL_DPF;\n\n\t\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\t\tu32 bitnum = smsc75xx_hash(ha->addr);\n\t\t\tpdata->multicast_hash_table[bitnum / 32] |=\n\t\t\t\t(1 << (bitnum % 32));\n\t\t}\n\t} else {\n\t\tnetif_dbg(dev, drv, dev->net, \"receive own packets only\\n\");\n\t\tpdata->rfe_ctl |= RFE_CTL_DPF;\n\t}\n\n\tspin_unlock_irqrestore(&pdata->rfe_ctl_lock, flags);\n\n\t \n\tschedule_work(&pdata->set_multicast);\n}\n\nstatic int smsc75xx_update_flowcontrol(struct usbnet *dev, u8 duplex,\n\t\t\t\t\t    u16 lcladv, u16 rmtadv)\n{\n\tu32 flow = 0, fct_flow = 0;\n\tint ret;\n\n\tif (duplex == DUPLEX_FULL) {\n\t\tu8 cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);\n\n\t\tif (cap & FLOW_CTRL_TX) {\n\t\t\tflow = (FLOW_TX_FCEN | 0xFFFF);\n\t\t\t \n\t\t\tfct_flow = (8 << 8) | 32;\n\t\t}\n\n\t\tif (cap & FLOW_CTRL_RX)\n\t\t\tflow |= FLOW_RX_FCEN;\n\n\t\tnetif_dbg(dev, link, dev->net, \"rx pause %s, tx pause %s\\n\",\n\t\t\t  (cap & FLOW_CTRL_RX ? \"enabled\" : \"disabled\"),\n\t\t\t  (cap & FLOW_CTRL_TX ? \"enabled\" : \"disabled\"));\n\t} else {\n\t\tnetif_dbg(dev, link, dev->net, \"half duplex\\n\");\n\t}\n\n\tret = smsc75xx_write_reg(dev, FLOW, flow);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing FLOW\\n\");\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_write_reg(dev, FCT_FLOW, fct_flow);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing FCT_FLOW\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int smsc75xx_link_reset(struct usbnet *dev)\n{\n\tstruct mii_if_info *mii = &dev->mii;\n\tstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\n\tu16 lcladv, rmtadv;\n\tint ret;\n\n\t \n\tsmsc75xx_mdio_write(dev->net, mii->phy_id, PHY_INT_SRC,\n\t\tPHY_INT_SRC_CLEAR_ALL);\n\n\tret = smsc75xx_write_reg(dev, INT_STS, INT_STS_CLEAR_ALL);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing INT_STS\\n\");\n\t\treturn ret;\n\t}\n\n\tmii_check_media(mii, 1, 1);\n\tmii_ethtool_gset(&dev->mii, &ecmd);\n\tlcladv = smsc75xx_mdio_read(dev->net, mii->phy_id, MII_ADVERTISE);\n\trmtadv = smsc75xx_mdio_read(dev->net, mii->phy_id, MII_LPA);\n\n\tnetif_dbg(dev, link, dev->net, \"speed: %u duplex: %d lcladv: %04x rmtadv: %04x\\n\",\n\t\t  ethtool_cmd_speed(&ecmd), ecmd.duplex, lcladv, rmtadv);\n\n\treturn smsc75xx_update_flowcontrol(dev, ecmd.duplex, lcladv, rmtadv);\n}\n\nstatic void smsc75xx_status(struct usbnet *dev, struct urb *urb)\n{\n\tu32 intdata;\n\n\tif (urb->actual_length != 4) {\n\t\tnetdev_warn(dev->net, \"unexpected urb length %d\\n\",\n\t\t\t    urb->actual_length);\n\t\treturn;\n\t}\n\n\tintdata = get_unaligned_le32(urb->transfer_buffer);\n\n\tnetif_dbg(dev, link, dev->net, \"intdata: 0x%08X\\n\", intdata);\n\n\tif (intdata & INT_ENP_PHY_INT)\n\t\tusbnet_defer_kevent(dev, EVENT_LINK_RESET);\n\telse\n\t\tnetdev_warn(dev->net, \"unexpected interrupt, intdata=0x%08X\\n\",\n\t\t\t    intdata);\n}\n\nstatic int smsc75xx_ethtool_get_eeprom_len(struct net_device *net)\n{\n\treturn MAX_EEPROM_SIZE;\n}\n\nstatic int smsc75xx_ethtool_get_eeprom(struct net_device *netdev,\n\t\t\t\t       struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\n\tee->magic = LAN75XX_EEPROM_MAGIC;\n\n\treturn smsc75xx_read_eeprom(dev, ee->offset, ee->len, data);\n}\n\nstatic int smsc75xx_ethtool_set_eeprom(struct net_device *netdev,\n\t\t\t\t       struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\n\tif (ee->magic != LAN75XX_EEPROM_MAGIC) {\n\t\tnetdev_warn(dev->net, \"EEPROM: magic value mismatch: 0x%x\\n\",\n\t\t\t    ee->magic);\n\t\treturn -EINVAL;\n\t}\n\n\treturn smsc75xx_write_eeprom(dev, ee->offset, ee->len, data);\n}\n\nstatic void smsc75xx_ethtool_get_wol(struct net_device *net,\n\t\t\t\t     struct ethtool_wolinfo *wolinfo)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\n\twolinfo->supported = SUPPORTED_WAKE;\n\twolinfo->wolopts = pdata->wolopts;\n}\n\nstatic int smsc75xx_ethtool_set_wol(struct net_device *net,\n\t\t\t\t    struct ethtool_wolinfo *wolinfo)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tint ret;\n\n\tif (wolinfo->wolopts & ~SUPPORTED_WAKE)\n\t\treturn -EINVAL;\n\n\tpdata->wolopts = wolinfo->wolopts & SUPPORTED_WAKE;\n\n\tret = device_set_wakeup_enable(&dev->udev->dev, pdata->wolopts);\n\tif (ret < 0)\n\t\tnetdev_warn(dev->net, \"device_set_wakeup_enable error %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct ethtool_ops smsc75xx_ethtool_ops = {\n\t.get_link\t= usbnet_get_link,\n\t.nway_reset\t= usbnet_nway_reset,\n\t.get_drvinfo\t= usbnet_get_drvinfo,\n\t.get_msglevel\t= usbnet_get_msglevel,\n\t.set_msglevel\t= usbnet_set_msglevel,\n\t.get_eeprom_len\t= smsc75xx_ethtool_get_eeprom_len,\n\t.get_eeprom\t= smsc75xx_ethtool_get_eeprom,\n\t.set_eeprom\t= smsc75xx_ethtool_set_eeprom,\n\t.get_wol\t= smsc75xx_ethtool_get_wol,\n\t.set_wol\t= smsc75xx_ethtool_set_wol,\n\t.get_link_ksettings\t= usbnet_get_link_ksettings_mii,\n\t.set_link_ksettings\t= usbnet_set_link_ksettings_mii,\n};\n\nstatic int smsc75xx_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\n\tif (!netif_running(netdev))\n\t\treturn -EINVAL;\n\n\treturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\n}\n\nstatic void smsc75xx_init_mac_address(struct usbnet *dev)\n{\n\tu8 addr[ETH_ALEN];\n\n\t \n\tif (!platform_get_ethdev_address(&dev->udev->dev, dev->net)) {\n\t\tif (is_valid_ether_addr(dev->net->dev_addr)) {\n\t\t\t \n\t\t\tnetif_dbg(dev, ifup, dev->net, \"MAC address read from the device tree\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (smsc75xx_read_eeprom(dev, EEPROM_MAC_OFFSET, ETH_ALEN, addr) == 0) {\n\t\teth_hw_addr_set(dev->net, addr);\n\t\tif (is_valid_ether_addr(dev->net->dev_addr)) {\n\t\t\t \n\t\t\tnetif_dbg(dev, ifup, dev->net,\n\t\t\t\t  \"MAC address read from EEPROM\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\teth_hw_addr_random(dev->net);\n\tnetif_dbg(dev, ifup, dev->net, \"MAC address set to eth_random_addr\\n\");\n}\n\nstatic int smsc75xx_set_mac_address(struct usbnet *dev)\n{\n\tu32 addr_lo = dev->net->dev_addr[0] | dev->net->dev_addr[1] << 8 |\n\t\tdev->net->dev_addr[2] << 16 | dev->net->dev_addr[3] << 24;\n\tu32 addr_hi = dev->net->dev_addr[4] | dev->net->dev_addr[5] << 8;\n\n\tint ret = smsc75xx_write_reg(dev, RX_ADDRH, addr_hi);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write RX_ADDRH: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_write_reg(dev, RX_ADDRL, addr_lo);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write RX_ADDRL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\taddr_hi |= ADDR_FILTX_FB_VALID;\n\tret = smsc75xx_write_reg(dev, ADDR_FILTX, addr_hi);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write ADDR_FILTX: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_write_reg(dev, ADDR_FILTX + 4, addr_lo);\n\tif (ret < 0)\n\t\tnetdev_warn(dev->net, \"Failed to write ADDR_FILTX+4: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int smsc75xx_phy_initialize(struct usbnet *dev)\n{\n\tint bmcr, ret, timeout = 0;\n\n\t \n\tdev->mii.dev = dev->net;\n\tdev->mii.mdio_read = smsc75xx_mdio_read;\n\tdev->mii.mdio_write = smsc75xx_mdio_write;\n\tdev->mii.phy_id_mask = 0x1f;\n\tdev->mii.reg_num_mask = 0x1f;\n\tdev->mii.supports_gmii = 1;\n\tdev->mii.phy_id = SMSC75XX_INTERNAL_PHY_ID;\n\n\t \n\tsmsc75xx_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);\n\n\tdo {\n\t\tmsleep(10);\n\t\tbmcr = smsc75xx_mdio_read(dev->net, dev->mii.phy_id, MII_BMCR);\n\t\tif (bmcr < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading MII_BMCR\\n\");\n\t\t\treturn bmcr;\n\t\t}\n\t\ttimeout++;\n\t} while ((bmcr & BMCR_RESET) && (timeout < 100));\n\n\tif (timeout >= 100) {\n\t\tnetdev_warn(dev->net, \"timeout on PHY Reset\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tsmsc75xx_phy_gig_workaround(dev);\n\n\tsmsc75xx_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,\n\t\tADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP |\n\t\tADVERTISE_PAUSE_ASYM);\n\tsmsc75xx_mdio_write(dev->net, dev->mii.phy_id, MII_CTRL1000,\n\t\tADVERTISE_1000FULL);\n\n\t \n\tret = smsc75xx_mdio_read(dev->net, dev->mii.phy_id, PHY_INT_SRC);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error reading PHY_INT_SRC\\n\");\n\t\treturn ret;\n\t}\n\n\tsmsc75xx_mdio_write(dev->net, dev->mii.phy_id, PHY_INT_SRC, 0xffff);\n\n\tsmsc75xx_mdio_write(dev->net, dev->mii.phy_id, PHY_INT_MASK,\n\t\tPHY_INT_MASK_DEFAULT);\n\tmii_nway_restart(&dev->mii);\n\n\tnetif_dbg(dev, ifup, dev->net, \"phy initialised successfully\\n\");\n\treturn 0;\n}\n\nstatic int smsc75xx_set_rx_max_frame_length(struct usbnet *dev, int size)\n{\n\tint ret = 0;\n\tu32 buf;\n\tbool rxenabled;\n\n\tret = smsc75xx_read_reg(dev, MAC_RX, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read MAC_RX: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trxenabled = ((buf & MAC_RX_RXEN) != 0);\n\n\tif (rxenabled) {\n\t\tbuf &= ~MAC_RX_RXEN;\n\t\tret = smsc75xx_write_reg(dev, MAC_RX, buf);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Failed to write MAC_RX: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tbuf &= ~MAC_RX_MAX_SIZE;\n\tbuf |= (((size + 4) << MAC_RX_MAX_SIZE_SHIFT) & MAC_RX_MAX_SIZE);\n\n\tret = smsc75xx_write_reg(dev, MAC_RX, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write MAC_RX: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (rxenabled) {\n\t\tbuf |= MAC_RX_RXEN;\n\t\tret = smsc75xx_write_reg(dev, MAC_RX, buf);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Failed to write MAC_RX: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int smsc75xx_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tint ret;\n\n\tret = smsc75xx_set_rx_max_frame_length(dev, new_mtu + ETH_HLEN);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to set mac rx frame length\\n\");\n\t\treturn ret;\n\t}\n\n\treturn usbnet_change_mtu(netdev, new_mtu);\n}\n\n \nstatic int smsc75xx_set_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pdata->rfe_ctl_lock, flags);\n\n\tif (features & NETIF_F_RXCSUM)\n\t\tpdata->rfe_ctl |= RFE_CTL_TCPUDP_CKM | RFE_CTL_IP_CKM;\n\telse\n\t\tpdata->rfe_ctl &= ~(RFE_CTL_TCPUDP_CKM | RFE_CTL_IP_CKM);\n\n\tspin_unlock_irqrestore(&pdata->rfe_ctl_lock, flags);\n\t \n\n\tret = smsc75xx_write_reg(dev, RFE_CTL, pdata->rfe_ctl);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing RFE_CTL\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int smsc75xx_wait_ready(struct usbnet *dev, int in_pm)\n{\n\tint timeout = 0;\n\n\tdo {\n\t\tu32 buf;\n\t\tint ret;\n\n\t\tret = __smsc75xx_read_reg(dev, PMT_CTL, &buf, in_pm);\n\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Failed to read PMT_CTL: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (buf & PMT_CTL_DEV_RDY)\n\t\t\treturn 0;\n\n\t\tmsleep(10);\n\t\ttimeout++;\n\t} while (timeout < 100);\n\n\tnetdev_warn(dev->net, \"timeout waiting for device ready\\n\");\n\treturn -EIO;\n}\n\nstatic int smsc75xx_phy_gig_workaround(struct usbnet *dev)\n{\n\tstruct mii_if_info *mii = &dev->mii;\n\tint ret = 0, timeout = 0;\n\tu32 buf, link_up = 0;\n\n\t \n\tsmsc75xx_mdio_write(dev->net, mii->phy_id, MII_BMCR, 0x4040);\n\n\t \n\tdo {\n\t\tlink_up = smsc75xx_link_ok_nopm(dev);\n\t\tusleep_range(10000, 20000);\n\t\ttimeout++;\n\t} while ((!link_up) && (timeout < 1000));\n\n\tif (timeout >= 1000) {\n\t\tnetdev_warn(dev->net, \"Timeout waiting for PHY link up\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tret = smsc75xx_read_reg(dev, PMT_CTL, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read PMT_CTL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbuf |= PMT_CTL_PHY_RST;\n\n\tret = smsc75xx_write_reg(dev, PMT_CTL, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write PMT_CTL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttimeout = 0;\n\tdo {\n\t\tusleep_range(10000, 20000);\n\t\tret = smsc75xx_read_reg(dev, PMT_CTL, &buf);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Failed to read PMT_CTL: %d\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t\ttimeout++;\n\t} while ((buf & PMT_CTL_PHY_RST) && (timeout < 100));\n\n\tif (timeout >= 100) {\n\t\tnetdev_warn(dev->net, \"timeout waiting for PHY Reset\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int smsc75xx_reset(struct usbnet *dev)\n{\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tu32 buf;\n\tint ret = 0, timeout;\n\n\tnetif_dbg(dev, ifup, dev->net, \"entering smsc75xx_reset\\n\");\n\n\tret = smsc75xx_wait_ready(dev, 0);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"device not ready in smsc75xx_reset\\n\");\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_read_reg(dev, HW_CFG, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read HW_CFG: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbuf |= HW_CFG_LRST;\n\n\tret = smsc75xx_write_reg(dev, HW_CFG, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write HW_CFG: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttimeout = 0;\n\tdo {\n\t\tmsleep(10);\n\t\tret = smsc75xx_read_reg(dev, HW_CFG, &buf);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Failed to read HW_CFG: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\ttimeout++;\n\t} while ((buf & HW_CFG_LRST) && (timeout < 100));\n\n\tif (timeout >= 100) {\n\t\tnetdev_warn(dev->net, \"timeout on completion of Lite Reset\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"Lite reset complete, resetting PHY\\n\");\n\n\tret = smsc75xx_read_reg(dev, PMT_CTL, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read PMT_CTL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbuf |= PMT_CTL_PHY_RST;\n\n\tret = smsc75xx_write_reg(dev, PMT_CTL, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write PMT_CTL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttimeout = 0;\n\tdo {\n\t\tmsleep(10);\n\t\tret = smsc75xx_read_reg(dev, PMT_CTL, &buf);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Failed to read PMT_CTL: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\ttimeout++;\n\t} while ((buf & PMT_CTL_PHY_RST) && (timeout < 100));\n\n\tif (timeout >= 100) {\n\t\tnetdev_warn(dev->net, \"timeout waiting for PHY Reset\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"PHY reset complete\\n\");\n\n\tret = smsc75xx_set_mac_address(dev);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to set mac address\\n\");\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"MAC Address: %pM\\n\",\n\t\t  dev->net->dev_addr);\n\n\tret = smsc75xx_read_reg(dev, HW_CFG, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read HW_CFG: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"Read Value from HW_CFG : 0x%08x\\n\",\n\t\t  buf);\n\n\tbuf |= HW_CFG_BIR;\n\n\tret = smsc75xx_write_reg(dev, HW_CFG, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net,  \"Failed to write HW_CFG: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_read_reg(dev, HW_CFG, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read HW_CFG: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"Read Value from HW_CFG after writing HW_CFG_BIR: 0x%08x\\n\",\n\t\t  buf);\n\n\tif (!turbo_mode) {\n\t\tbuf = 0;\n\t\tdev->rx_urb_size = MAX_SINGLE_PACKET_SIZE;\n\t} else if (dev->udev->speed == USB_SPEED_HIGH) {\n\t\tbuf = DEFAULT_HS_BURST_CAP_SIZE / HS_USB_PKT_SIZE;\n\t\tdev->rx_urb_size = DEFAULT_HS_BURST_CAP_SIZE;\n\t} else {\n\t\tbuf = DEFAULT_FS_BURST_CAP_SIZE / FS_USB_PKT_SIZE;\n\t\tdev->rx_urb_size = DEFAULT_FS_BURST_CAP_SIZE;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"rx_urb_size=%ld\\n\",\n\t\t  (ulong)dev->rx_urb_size);\n\n\tret = smsc75xx_write_reg(dev, BURST_CAP, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write BURST_CAP: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_read_reg(dev, BURST_CAP, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read BURST_CAP: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net,\n\t\t  \"Read Value from BURST_CAP after writing: 0x%08x\\n\", buf);\n\n\tret = smsc75xx_write_reg(dev, BULK_IN_DLY, DEFAULT_BULK_IN_DELAY);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write BULK_IN_DLY: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_read_reg(dev, BULK_IN_DLY, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read BULK_IN_DLY: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net,\n\t\t  \"Read Value from BULK_IN_DLY after writing: 0x%08x\\n\", buf);\n\n\tif (turbo_mode) {\n\t\tret = smsc75xx_read_reg(dev, HW_CFG, &buf);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Failed to read HW_CFG: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tnetif_dbg(dev, ifup, dev->net, \"HW_CFG: 0x%08x\\n\", buf);\n\n\t\tbuf |= (HW_CFG_MEF | HW_CFG_BCE);\n\n\t\tret = smsc75xx_write_reg(dev, HW_CFG, buf);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Failed to write HW_CFG: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = smsc75xx_read_reg(dev, HW_CFG, &buf);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Failed to read HW_CFG: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tnetif_dbg(dev, ifup, dev->net, \"HW_CFG: 0x%08x\\n\", buf);\n\t}\n\n\t \n\tbuf = (MAX_RX_FIFO_SIZE - 512) / 512;\n\tret = smsc75xx_write_reg(dev, FCT_RX_FIFO_END, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write FCT_RX_FIFO_END: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"FCT_RX_FIFO_END set to 0x%08x\\n\", buf);\n\n\tbuf = (MAX_TX_FIFO_SIZE - 512) / 512;\n\tret = smsc75xx_write_reg(dev, FCT_TX_FIFO_END, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write FCT_TX_FIFO_END: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"FCT_TX_FIFO_END set to 0x%08x\\n\", buf);\n\n\tret = smsc75xx_write_reg(dev, INT_STS, INT_STS_CLEAR_ALL);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write INT_STS: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_read_reg(dev, ID_REV, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read ID_REV: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"ID_REV = 0x%08x\\n\", buf);\n\n\tret = smsc75xx_read_reg(dev, E2P_CMD, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read E2P_CMD: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!(buf & E2P_CMD_LOADED)) {\n\t\tret = smsc75xx_read_reg(dev, LED_GPIO_CFG, &buf);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Failed to read LED_GPIO_CFG: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbuf &= ~(LED_GPIO_CFG_LED2_FUN_SEL | LED_GPIO_CFG_LED10_FUN_SEL);\n\t\tbuf |= LED_GPIO_CFG_LEDGPIO_EN | LED_GPIO_CFG_LED2_FUN_SEL;\n\n\t\tret = smsc75xx_write_reg(dev, LED_GPIO_CFG, buf);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Failed to write LED_GPIO_CFG: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = smsc75xx_write_reg(dev, FLOW, 0);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write FLOW: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_write_reg(dev, FCT_FLOW, 0);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write FCT_FLOW: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = smsc75xx_read_reg(dev, RFE_CTL, &pdata->rfe_ctl);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read RFE_CTL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpdata->rfe_ctl |= RFE_CTL_AB | RFE_CTL_DPF;\n\n\tret = smsc75xx_write_reg(dev, RFE_CTL, pdata->rfe_ctl);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write RFE_CTL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_read_reg(dev, RFE_CTL, &pdata->rfe_ctl);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read RFE_CTL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"RFE_CTL set to 0x%08x\\n\",\n\t\t  pdata->rfe_ctl);\n\n\t \n\tsmsc75xx_set_features(dev->net, dev->net->features);\n\n\tsmsc75xx_set_multicast(dev->net);\n\n\tret = smsc75xx_phy_initialize(dev);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to initialize PHY: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_read_reg(dev, INT_EP_CTL, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read INT_EP_CTL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tbuf |= INT_ENP_PHY_INT;\n\n\tret = smsc75xx_write_reg(dev, INT_EP_CTL, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write INT_EP_CTL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = smsc75xx_read_reg(dev, MAC_CR, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read MAC_CR: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbuf |= (MAC_CR_ADD | MAC_CR_ASD);\n\tret = smsc75xx_write_reg(dev, MAC_CR, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write MAC_CR: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_read_reg(dev, MAC_TX, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read MAC_TX: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbuf |= MAC_TX_TXEN;\n\n\tret = smsc75xx_write_reg(dev, MAC_TX, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write MAC_TX: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"MAC_TX set to 0x%08x\\n\", buf);\n\n\tret = smsc75xx_read_reg(dev, FCT_TX_CTL, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read FCT_TX_CTL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbuf |= FCT_TX_CTL_EN;\n\n\tret = smsc75xx_write_reg(dev, FCT_TX_CTL, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write FCT_TX_CTL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"FCT_TX_CTL set to 0x%08x\\n\", buf);\n\n\tret = smsc75xx_set_rx_max_frame_length(dev, dev->net->mtu + ETH_HLEN);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to set max rx frame length\\n\");\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_read_reg(dev, MAC_RX, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read MAC_RX: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbuf |= MAC_RX_RXEN;\n\n\tret = smsc75xx_write_reg(dev, MAC_RX, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write MAC_RX: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"MAC_RX set to 0x%08x\\n\", buf);\n\n\tret = smsc75xx_read_reg(dev, FCT_RX_CTL, &buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read FCT_RX_CTL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbuf |= FCT_RX_CTL_EN;\n\n\tret = smsc75xx_write_reg(dev, FCT_RX_CTL, buf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write FCT_RX_CTL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"FCT_RX_CTL set to 0x%08x\\n\", buf);\n\n\tnetif_dbg(dev, ifup, dev->net, \"smsc75xx_reset, return 0\\n\");\n\treturn 0;\n}\n\nstatic const struct net_device_ops smsc75xx_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_change_mtu\t\t= smsc75xx_change_mtu,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= smsc75xx_ioctl,\n\t.ndo_set_rx_mode\t= smsc75xx_set_multicast,\n\t.ndo_set_features\t= smsc75xx_set_features,\n};\n\nstatic int smsc75xx_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct smsc75xx_priv *pdata = NULL;\n\tint ret;\n\n\tprintk(KERN_INFO SMSC_CHIPNAME \" v\" SMSC_DRIVER_VERSION \"\\n\");\n\n\tret = usbnet_get_endpoints(dev, intf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"usbnet_get_endpoints failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev->data[0] = (unsigned long)kzalloc(sizeof(struct smsc75xx_priv),\n\t\t\t\t\t      GFP_KERNEL);\n\n\tpdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->dev = dev;\n\n\tspin_lock_init(&pdata->rfe_ctl_lock);\n\tmutex_init(&pdata->dataport_mutex);\n\n\tINIT_WORK(&pdata->set_multicast, smsc75xx_deferred_multicast_write);\n\n\tif (DEFAULT_TX_CSUM_ENABLE)\n\t\tdev->net->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\n\n\tif (DEFAULT_RX_CSUM_ENABLE)\n\t\tdev->net->features |= NETIF_F_RXCSUM;\n\n\tdev->net->hw_features = NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\n\t\t\t\tNETIF_F_RXCSUM;\n\n\tret = smsc75xx_wait_ready(dev, 0);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"device not ready in smsc75xx_bind\\n\");\n\t\tgoto free_pdata;\n\t}\n\n\tsmsc75xx_init_mac_address(dev);\n\n\t \n\tret = smsc75xx_reset(dev);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"smsc75xx_reset error %d\\n\", ret);\n\t\tgoto cancel_work;\n\t}\n\n\tdev->net->netdev_ops = &smsc75xx_netdev_ops;\n\tdev->net->ethtool_ops = &smsc75xx_ethtool_ops;\n\tdev->net->flags |= IFF_MULTICAST;\n\tdev->net->hard_header_len += SMSC75XX_TX_OVERHEAD;\n\tdev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\n\tdev->net->max_mtu = MAX_SINGLE_PACKET_SIZE;\n\treturn 0;\n\ncancel_work:\n\tcancel_work_sync(&pdata->set_multicast);\nfree_pdata:\n\tkfree(pdata);\n\tdev->data[0] = 0;\n\treturn ret;\n}\n\nstatic void smsc75xx_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tif (pdata) {\n\t\tcancel_work_sync(&pdata->set_multicast);\n\t\tnetif_dbg(dev, ifdown, dev->net, \"free pdata\\n\");\n\t\tkfree(pdata);\n\t\tdev->data[0] = 0;\n\t}\n}\n\nstatic u16 smsc_crc(const u8 *buffer, size_t len)\n{\n\treturn bitrev16(crc16(0xFFFF, buffer, len));\n}\n\nstatic int smsc75xx_write_wuff(struct usbnet *dev, int filter, u32 wuf_cfg,\n\t\t\t       u32 wuf_mask1)\n{\n\tint cfg_base = WUF_CFGX + filter * 4;\n\tint mask_base = WUF_MASKX + filter * 16;\n\tint ret;\n\n\tret = smsc75xx_write_reg(dev, cfg_base, wuf_cfg);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing WUF_CFGX\\n\");\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_write_reg(dev, mask_base, wuf_mask1);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing WUF_MASKX\\n\");\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_write_reg(dev, mask_base + 4, 0);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing WUF_MASKX\\n\");\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_write_reg(dev, mask_base + 8, 0);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing WUF_MASKX\\n\");\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_write_reg(dev, mask_base + 12, 0);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing WUF_MASKX\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int smsc75xx_enter_suspend0(struct usbnet *dev)\n{\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tu32 val;\n\tint ret;\n\n\tret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error reading PMT_CTL\\n\");\n\t\treturn ret;\n\t}\n\n\tval &= (~(PMT_CTL_SUS_MODE | PMT_CTL_PHY_RST));\n\tval |= PMT_CTL_SUS_MODE_0 | PMT_CTL_WOL_EN | PMT_CTL_WUPS;\n\n\tret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing PMT_CTL\\n\");\n\t\treturn ret;\n\t}\n\n\tpdata->suspend_flags |= SUSPEND_SUSPEND0;\n\n\treturn 0;\n}\n\nstatic int smsc75xx_enter_suspend1(struct usbnet *dev)\n{\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tu32 val;\n\tint ret;\n\n\tret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error reading PMT_CTL\\n\");\n\t\treturn ret;\n\t}\n\n\tval &= ~(PMT_CTL_SUS_MODE | PMT_CTL_WUPS | PMT_CTL_PHY_RST);\n\tval |= PMT_CTL_SUS_MODE_1;\n\n\tret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing PMT_CTL\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tval &= ~PMT_CTL_WUPS;\n\tval |= (PMT_CTL_WUPS_ED | PMT_CTL_ED_EN);\n\n\tret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing PMT_CTL\\n\");\n\t\treturn ret;\n\t}\n\n\tpdata->suspend_flags |= SUSPEND_SUSPEND1;\n\n\treturn 0;\n}\n\nstatic int smsc75xx_enter_suspend2(struct usbnet *dev)\n{\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tu32 val;\n\tint ret;\n\n\tret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error reading PMT_CTL\\n\");\n\t\treturn ret;\n\t}\n\n\tval &= ~(PMT_CTL_SUS_MODE | PMT_CTL_WUPS | PMT_CTL_PHY_RST);\n\tval |= PMT_CTL_SUS_MODE_2;\n\n\tret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing PMT_CTL\\n\");\n\t\treturn ret;\n\t}\n\n\tpdata->suspend_flags |= SUSPEND_SUSPEND2;\n\n\treturn 0;\n}\n\nstatic int smsc75xx_enter_suspend3(struct usbnet *dev)\n{\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tu32 val;\n\tint ret;\n\n\tret = smsc75xx_read_reg_nopm(dev, FCT_RX_CTL, &val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error reading FCT_RX_CTL\\n\");\n\t\treturn ret;\n\t}\n\n\tif (val & FCT_RX_CTL_RXUSED) {\n\t\tnetdev_dbg(dev->net, \"rx fifo not empty in autosuspend\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error reading PMT_CTL\\n\");\n\t\treturn ret;\n\t}\n\n\tval &= ~(PMT_CTL_SUS_MODE | PMT_CTL_WUPS | PMT_CTL_PHY_RST);\n\tval |= PMT_CTL_SUS_MODE_3 | PMT_CTL_RES_CLR_WKP_EN;\n\n\tret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing PMT_CTL\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tval &= ~PMT_CTL_WUPS;\n\tval |= PMT_CTL_WUPS_WOL;\n\n\tret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing PMT_CTL\\n\");\n\t\treturn ret;\n\t}\n\n\tpdata->suspend_flags |= SUSPEND_SUSPEND3;\n\n\treturn 0;\n}\n\nstatic int smsc75xx_enable_phy_wakeup_interrupts(struct usbnet *dev, u16 mask)\n{\n\tstruct mii_if_info *mii = &dev->mii;\n\tint ret;\n\n\tnetdev_dbg(dev->net, \"enabling PHY wakeup interrupts\\n\");\n\n\t \n\tret = smsc75xx_mdio_read_nopm(dev->net, mii->phy_id, PHY_INT_SRC);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error reading PHY_INT_SRC\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = smsc75xx_mdio_read_nopm(dev->net, mii->phy_id, PHY_INT_MASK);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error reading PHY_INT_MASK\\n\");\n\t\treturn ret;\n\t}\n\n\tret |= mask;\n\n\tsmsc75xx_mdio_write_nopm(dev->net, mii->phy_id, PHY_INT_MASK, ret);\n\n\treturn 0;\n}\n\nstatic int smsc75xx_link_ok_nopm(struct usbnet *dev)\n{\n\tstruct mii_if_info *mii = &dev->mii;\n\tint ret;\n\n\t \n\tret = smsc75xx_mdio_read_nopm(dev->net, mii->phy_id, MII_BMSR);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error reading MII_BMSR\\n\");\n\t\treturn ret;\n\t}\n\n\tret = smsc75xx_mdio_read_nopm(dev->net, mii->phy_id, MII_BMSR);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error reading MII_BMSR\\n\");\n\t\treturn ret;\n\t}\n\n\treturn !!(ret & BMSR_LSTATUS);\n}\n\nstatic int smsc75xx_autosuspend(struct usbnet *dev, u32 link_up)\n{\n\tint ret;\n\n\tif (!netif_running(dev->net)) {\n\t\t \n\t\tnetdev_dbg(dev->net, \"autosuspend entering SUSPEND2\\n\");\n\t\treturn smsc75xx_enter_suspend2(dev);\n\t}\n\n\tif (!link_up) {\n\t\t \n\t\tnetdev_dbg(dev->net, \"autosuspend entering SUSPEND1\\n\");\n\n\t\t \n\t\tret = smsc75xx_enable_phy_wakeup_interrupts(dev,\n\t\t\tPHY_INT_MASK_ANEG_COMP);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"error enabling PHY wakeup ints\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tnetdev_info(dev->net, \"entering SUSPEND1 mode\\n\");\n\t\treturn smsc75xx_enter_suspend1(dev);\n\t}\n\n\t \n\tret = smsc75xx_enable_phy_wakeup_interrupts(dev,\n\t\tPHY_INT_MASK_LINK_DOWN);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"error enabling PHY wakeup ints\\n\");\n\t\treturn ret;\n\t}\n\n\tnetdev_dbg(dev->net, \"autosuspend entering SUSPEND3\\n\");\n\treturn smsc75xx_enter_suspend3(dev);\n}\n\nstatic int smsc75xx_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tu32 val, link_up;\n\tint ret;\n\n\tret = usbnet_suspend(intf, message);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"usbnet_suspend error\\n\");\n\t\treturn ret;\n\t}\n\n\tif (pdata->suspend_flags) {\n\t\tnetdev_warn(dev->net, \"error during last resume\\n\");\n\t\tpdata->suspend_flags = 0;\n\t}\n\n\t \n\tlink_up = smsc75xx_link_ok_nopm(dev);\n\n\tif (message.event == PM_EVENT_AUTO_SUSPEND) {\n\t\tret = smsc75xx_autosuspend(dev, link_up);\n\t\tgoto done;\n\t}\n\n\t \n\t \n\tif (!(pdata->wolopts & SUPPORTED_WAKE) ||\n\t\t!(link_up || (pdata->wolopts & WAKE_PHY))) {\n\t\tnetdev_info(dev->net, \"entering SUSPEND2 mode\\n\");\n\n\t\t \n\t\tret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tval &= ~(WUCSR_MPEN | WUCSR_WUEN);\n\n\t\tret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading PMT_CTL\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tval &= ~(PMT_CTL_ED_EN | PMT_CTL_WOL_EN);\n\n\t\tret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing PMT_CTL\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = smsc75xx_enter_suspend2(dev);\n\t\tgoto done;\n\t}\n\n\tif (pdata->wolopts & WAKE_PHY) {\n\t\tret = smsc75xx_enable_phy_wakeup_interrupts(dev,\n\t\t\t(PHY_INT_MASK_ANEG_COMP | PHY_INT_MASK_LINK_DOWN));\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"error enabling PHY wakeup ints\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (!link_up) {\n\t\t\tstruct mii_if_info *mii = &dev->mii;\n\t\t\tnetdev_info(dev->net, \"entering SUSPEND1 mode\\n\");\n\n\t\t\t \n\t\t\tret = smsc75xx_mdio_read_nopm(dev->net, mii->phy_id,\n\t\t\t\tPHY_MODE_CTRL_STS);\n\t\t\tif (ret < 0) {\n\t\t\t\tnetdev_warn(dev->net, \"Error reading PHY_MODE_CTRL_STS\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret |= MODE_CTRL_STS_EDPWRDOWN;\n\n\t\t\tsmsc75xx_mdio_write_nopm(dev->net, mii->phy_id,\n\t\t\t\tPHY_MODE_CTRL_STS, ret);\n\n\t\t\t \n\t\t\tret = smsc75xx_enter_suspend1(dev);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (pdata->wolopts & (WAKE_MCAST | WAKE_ARP)) {\n\t\tint i, filter = 0;\n\n\t\t \n\t\tfor (i = 0; i < WUF_NUM; i++) {\n\t\t\tret = smsc75xx_write_reg_nopm(dev, WUF_CFGX + i * 4, 0);\n\t\t\tif (ret < 0) {\n\t\t\t\tnetdev_warn(dev->net, \"Error writing WUF_CFGX\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tif (pdata->wolopts & WAKE_MCAST) {\n\t\t\tconst u8 mcast[] = {0x01, 0x00, 0x5E};\n\t\t\tnetdev_info(dev->net, \"enabling multicast detection\\n\");\n\n\t\t\tval = WUF_CFGX_EN | WUF_CFGX_ATYPE_MULTICAST\n\t\t\t\t| smsc_crc(mcast, 3);\n\t\t\tret = smsc75xx_write_wuff(dev, filter++, val, 0x0007);\n\t\t\tif (ret < 0) {\n\t\t\t\tnetdev_warn(dev->net, \"Error writing wakeup filter\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tif (pdata->wolopts & WAKE_ARP) {\n\t\t\tconst u8 arp[] = {0x08, 0x06};\n\t\t\tnetdev_info(dev->net, \"enabling ARP detection\\n\");\n\n\t\t\tval = WUF_CFGX_EN | WUF_CFGX_ATYPE_ALL | (0x0C << 16)\n\t\t\t\t| smsc_crc(arp, 2);\n\t\t\tret = smsc75xx_write_wuff(dev, filter++, val, 0x0003);\n\t\t\tif (ret < 0) {\n\t\t\t\tnetdev_warn(dev->net, \"Error writing wakeup filter\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tval |= WUCSR_WUFR;\n\n\t\tret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tnetdev_info(dev->net, \"enabling packet match detection\\n\");\n\t\tret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tval |= WUCSR_WUEN;\n\n\t\tret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tnetdev_info(dev->net, \"disabling packet match detection\\n\");\n\t\tret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tval &= ~WUCSR_WUEN;\n\n\t\tret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error reading WUCSR\\n\");\n\t\tgoto done;\n\t}\n\n\tval &= ~(WUCSR_MPEN | WUCSR_BCST_EN | WUCSR_PFDA_EN);\n\n\tret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing WUCSR\\n\");\n\t\tgoto done;\n\t}\n\n\tif (pdata->wolopts & WAKE_PHY) {\n\t\tnetdev_info(dev->net, \"enabling PHY wakeup\\n\");\n\n\t\tret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading PMT_CTL\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tval &= ~PMT_CTL_WUPS;\n\t\tval |= (PMT_CTL_WUPS_ED | PMT_CTL_ED_EN);\n\n\t\tret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing PMT_CTL\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (pdata->wolopts & WAKE_MAGIC) {\n\t\tnetdev_info(dev->net, \"enabling magic packet wakeup\\n\");\n\t\tret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tval |= WUCSR_MPR | WUCSR_MPEN;\n\n\t\tret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (pdata->wolopts & WAKE_BCAST) {\n\t\tnetdev_info(dev->net, \"enabling broadcast detection\\n\");\n\t\tret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tval |= WUCSR_BCAST_FR | WUCSR_BCST_EN;\n\n\t\tret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (pdata->wolopts & WAKE_UCAST) {\n\t\tnetdev_info(dev->net, \"enabling unicast detection\\n\");\n\t\tret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tval |= WUCSR_WUFR | WUCSR_PFDA_EN;\n\n\t\tret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing WUCSR\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tret = smsc75xx_read_reg_nopm(dev, MAC_RX, &val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to read MAC_RX: %d\\n\", ret);\n\t\tgoto done;\n\t}\n\n\tval |= MAC_RX_RXEN;\n\n\tret = smsc75xx_write_reg_nopm(dev, MAC_RX, val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to write MAC_RX: %d\\n\", ret);\n\t\tgoto done;\n\t}\n\n\t \n\tnetdev_info(dev->net, \"entering SUSPEND0 mode\\n\");\n\tret = smsc75xx_enter_suspend0(dev);\n\ndone:\n\t \n\tif (ret && PMSG_IS_AUTO(message))\n\t\tusbnet_resume(intf);\n\treturn ret;\n}\n\nstatic int smsc75xx_resume(struct usb_interface *intf)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct smsc75xx_priv *pdata = (struct smsc75xx_priv *)(dev->data[0]);\n\tu8 suspend_flags = pdata->suspend_flags;\n\tint ret;\n\tu32 val;\n\n\tnetdev_dbg(dev->net, \"resume suspend_flags=0x%02x\\n\", suspend_flags);\n\n\t \n\tpdata->suspend_flags = 0;\n\n\tif (suspend_flags & SUSPEND_ALLMODES) {\n\t\t \n\t\tret = smsc75xx_read_reg_nopm(dev, WUCSR, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading WUCSR\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tval &= ~(WUCSR_WUEN | WUCSR_MPEN | WUCSR_PFDA_EN\n\t\t\t| WUCSR_BCST_EN);\n\n\t\tret = smsc75xx_write_reg_nopm(dev, WUCSR, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing WUCSR\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading PMT_CTL\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tval &= ~PMT_CTL_WOL_EN;\n\t\tval |= PMT_CTL_WUPS;\n\n\t\tret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing PMT_CTL\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (suspend_flags & SUSPEND_SUSPEND2) {\n\t\tnetdev_info(dev->net, \"resuming from SUSPEND2\\n\");\n\n\t\tret = smsc75xx_read_reg_nopm(dev, PMT_CTL, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading PMT_CTL\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tval |= PMT_CTL_PHY_PWRUP;\n\n\t\tret = smsc75xx_write_reg_nopm(dev, PMT_CTL, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing PMT_CTL\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = smsc75xx_wait_ready(dev, 1);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"device not ready in smsc75xx_resume\\n\");\n\t\treturn ret;\n\t}\n\n\treturn usbnet_resume(intf);\n}\n\nstatic void smsc75xx_rx_csum_offload(struct usbnet *dev, struct sk_buff *skb,\n\t\t\t\t     u32 rx_cmd_a, u32 rx_cmd_b)\n{\n\tif (!(dev->net->features & NETIF_F_RXCSUM) ||\n\t    unlikely(rx_cmd_a & RX_CMD_A_LCSM)) {\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t} else {\n\t\tskb->csum = ntohs((u16)(rx_cmd_b >> RX_CMD_B_CSUM_SHIFT));\n\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t}\n}\n\nstatic int smsc75xx_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\t \n\tif (skb->len < dev->net->hard_header_len)\n\t\treturn 0;\n\n\twhile (skb->len > 0) {\n\t\tu32 rx_cmd_a, rx_cmd_b, align_count, size;\n\t\tstruct sk_buff *ax_skb;\n\t\tunsigned char *packet;\n\n\t\trx_cmd_a = get_unaligned_le32(skb->data);\n\t\tskb_pull(skb, 4);\n\n\t\trx_cmd_b = get_unaligned_le32(skb->data);\n\t\tskb_pull(skb, 4 + RXW_PADDING);\n\n\t\tpacket = skb->data;\n\n\t\t \n\t\tsize = (rx_cmd_a & RX_CMD_A_LEN) - RXW_PADDING;\n\t\talign_count = (4 - ((size + RXW_PADDING) % 4)) % 4;\n\n\t\tif (unlikely(size > skb->len)) {\n\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t  \"size err rx_cmd_a=0x%08x\\n\",\n\t\t\t\t  rx_cmd_a);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (unlikely(rx_cmd_a & RX_CMD_A_RED)) {\n\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t  \"Error rx_cmd_a=0x%08x\\n\", rx_cmd_a);\n\t\t\tdev->net->stats.rx_errors++;\n\t\t\tdev->net->stats.rx_dropped++;\n\n\t\t\tif (rx_cmd_a & RX_CMD_A_FCS)\n\t\t\t\tdev->net->stats.rx_crc_errors++;\n\t\t\telse if (rx_cmd_a & (RX_CMD_A_LONG | RX_CMD_A_RUNT))\n\t\t\t\tdev->net->stats.rx_frame_errors++;\n\t\t} else {\n\t\t\t \n\t\t\tif (unlikely(size > (MAX_SINGLE_PACKET_SIZE + ETH_HLEN + 12))) {\n\t\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t\t  \"size err rx_cmd_a=0x%08x\\n\",\n\t\t\t\t\t  rx_cmd_a);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (skb->len == size) {\n\t\t\t\tsmsc75xx_rx_csum_offload(dev, skb, rx_cmd_a,\n\t\t\t\t\trx_cmd_b);\n\n\t\t\t\tskb_trim(skb, skb->len - 4);  \n\t\t\t\tskb->truesize = size + sizeof(struct sk_buff);\n\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tax_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (unlikely(!ax_skb)) {\n\t\t\t\tnetdev_warn(dev->net, \"Error allocating skb\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tax_skb->len = size;\n\t\t\tax_skb->data = packet;\n\t\t\tskb_set_tail_pointer(ax_skb, size);\n\n\t\t\tsmsc75xx_rx_csum_offload(dev, ax_skb, rx_cmd_a,\n\t\t\t\trx_cmd_b);\n\n\t\t\tskb_trim(ax_skb, ax_skb->len - 4);  \n\t\t\tax_skb->truesize = size + sizeof(struct sk_buff);\n\n\t\t\tusbnet_skb_return(dev, ax_skb);\n\t\t}\n\n\t\tskb_pull(skb, size);\n\n\t\t \n\t\tif (skb->len)\n\t\t\tskb_pull(skb, align_count);\n\t}\n\n\treturn 1;\n}\n\nstatic struct sk_buff *smsc75xx_tx_fixup(struct usbnet *dev,\n\t\t\t\t\t struct sk_buff *skb, gfp_t flags)\n{\n\tu32 tx_cmd_a, tx_cmd_b;\n\tvoid *ptr;\n\n\tif (skb_cow_head(skb, SMSC75XX_TX_OVERHEAD)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NULL;\n\t}\n\n\ttx_cmd_a = (u32)(skb->len & TX_CMD_A_LEN) | TX_CMD_A_FCS;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\ttx_cmd_a |= TX_CMD_A_IPE | TX_CMD_A_TPE;\n\n\tif (skb_is_gso(skb)) {\n\t\tu16 mss = max(skb_shinfo(skb)->gso_size, TX_MSS_MIN);\n\t\ttx_cmd_b = (mss << TX_CMD_B_MSS_SHIFT) & TX_CMD_B_MSS;\n\n\t\ttx_cmd_a |= TX_CMD_A_LSO;\n\t} else {\n\t\ttx_cmd_b = 0;\n\t}\n\n\tptr = skb_push(skb, 8);\n\tput_unaligned_le32(tx_cmd_a, ptr);\n\tput_unaligned_le32(tx_cmd_b, ptr + 4);\n\n\treturn skb;\n}\n\nstatic int smsc75xx_manage_power(struct usbnet *dev, int on)\n{\n\tdev->intf->needs_remote_wakeup = on;\n\treturn 0;\n}\n\nstatic const struct driver_info smsc75xx_info = {\n\t.description\t= \"smsc75xx USB 2.0 Gigabit Ethernet\",\n\t.bind\t\t= smsc75xx_bind,\n\t.unbind\t\t= smsc75xx_unbind,\n\t.link_reset\t= smsc75xx_link_reset,\n\t.reset\t\t= smsc75xx_reset,\n\t.rx_fixup\t= smsc75xx_rx_fixup,\n\t.tx_fixup\t= smsc75xx_tx_fixup,\n\t.status\t\t= smsc75xx_status,\n\t.manage_power\t= smsc75xx_manage_power,\n\t.flags\t\t= FLAG_ETHER | FLAG_SEND_ZLP | FLAG_LINK_INTR,\n};\n\nstatic const struct usb_device_id products[] = {\n\t{\n\t\t \n\t\tUSB_DEVICE(USB_VENDOR_ID_SMSC, USB_PRODUCT_ID_LAN7500),\n\t\t.driver_info = (unsigned long) &smsc75xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(USB_VENDOR_ID_SMSC, USB_PRODUCT_ID_LAN7505),\n\t\t.driver_info = (unsigned long) &smsc75xx_info,\n\t},\n\t{ },\t\t \n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver smsc75xx_driver = {\n\t.name\t\t= SMSC_CHIPNAME,\n\t.id_table\t= products,\n\t.probe\t\t= usbnet_probe,\n\t.suspend\t= smsc75xx_suspend,\n\t.resume\t\t= smsc75xx_resume,\n\t.reset_resume\t= smsc75xx_resume,\n\t.disconnect\t= usbnet_disconnect,\n\t.disable_hub_initiated_lpm = 1,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(smsc75xx_driver);\n\nMODULE_AUTHOR(\"Nancy Lin\");\nMODULE_AUTHOR(\"Steve Glendinning <steve.glendinning@shawell.net>\");\nMODULE_DESCRIPTION(\"SMSC75XX USB 2.0 Gigabit Ethernet Devices\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}