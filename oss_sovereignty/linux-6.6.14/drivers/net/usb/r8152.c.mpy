{
  "module_name": "r8152.c",
  "hash_id": "0e263b99804962226cdb40b472003385bb6e1df4839b1994bc45fb0ec9f9f71f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/r8152.c",
  "human_readable_source": "\n \n\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/usb.h>\n#include <linux/crc32.h>\n#include <linux/if_vlan.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <net/ip6_checksum.h>\n#include <uapi/linux/mdio.h>\n#include <linux/mdio.h>\n#include <linux/usb/cdc.h>\n#include <linux/suspend.h>\n#include <linux/atomic.h>\n#include <linux/acpi.h>\n#include <linux/firmware.h>\n#include <crypto/hash.h>\n#include <linux/usb/r8152.h>\n#include <net/gso.h>\n\n \n#define NETNEXT_VERSION\t\t\"12\"\n\n \n#define NET_VERSION\t\t\"13\"\n\n#define DRIVER_VERSION\t\t\"v1.\" NETNEXT_VERSION \".\" NET_VERSION\n#define DRIVER_AUTHOR \"Realtek linux nic maintainers <nic_swsd@realtek.com>\"\n#define DRIVER_DESC \"Realtek RTL8152/RTL8153 Based USB Ethernet Adapters\"\n#define MODULENAME \"r8152\"\n\n#define R8152_PHY_ID\t\t32\n\n#define PLA_IDR\t\t\t0xc000\n#define PLA_RCR\t\t\t0xc010\n#define PLA_RCR1\t\t0xc012\n#define PLA_RMS\t\t\t0xc016\n#define PLA_RXFIFO_CTRL0\t0xc0a0\n#define PLA_RXFIFO_FULL\t\t0xc0a2\n#define PLA_RXFIFO_CTRL1\t0xc0a4\n#define PLA_RX_FIFO_FULL\t0xc0a6\n#define PLA_RXFIFO_CTRL2\t0xc0a8\n#define PLA_RX_FIFO_EMPTY\t0xc0aa\n#define PLA_DMY_REG0\t\t0xc0b0\n#define PLA_FMC\t\t\t0xc0b4\n#define PLA_CFG_WOL\t\t0xc0b6\n#define PLA_TEREDO_CFG\t\t0xc0bc\n#define PLA_TEREDO_WAKE_BASE\t0xc0c4\n#define PLA_MAR\t\t\t0xcd00\n#define PLA_BACKUP\t\t0xd000\n#define PLA_BDC_CR\t\t0xd1a0\n#define PLA_TEREDO_TIMER\t0xd2cc\n#define PLA_REALWOW_TIMER\t0xd2e8\n#define PLA_UPHY_TIMER\t\t0xd388\n#define PLA_SUSPEND_FLAG\t0xd38a\n#define PLA_INDICATE_FALG\t0xd38c\n#define PLA_MACDBG_PRE\t\t0xd38c\t \n#define PLA_MACDBG_POST\t\t0xd38e\t \n#define PLA_EXTRA_STATUS\t0xd398\n#define PLA_GPHY_CTRL\t\t0xd3ae\n#define PLA_POL_GPIO_CTRL\t0xdc6a\n#define PLA_EFUSE_DATA\t\t0xdd00\n#define PLA_EFUSE_CMD\t\t0xdd02\n#define PLA_LEDSEL\t\t0xdd90\n#define PLA_LED_FEATURE\t\t0xdd92\n#define PLA_PHYAR\t\t0xde00\n#define PLA_BOOT_CTRL\t\t0xe004\n#define PLA_LWAKE_CTRL_REG\t0xe007\n#define PLA_GPHY_INTR_IMR\t0xe022\n#define PLA_EEE_CR\t\t0xe040\n#define PLA_EEE_TXTWSYS\t\t0xe04c\n#define PLA_EEE_TXTWSYS_2P5G\t0xe058\n#define PLA_EEEP_CR\t\t0xe080\n#define PLA_MAC_PWR_CTRL\t0xe0c0\n#define PLA_MAC_PWR_CTRL2\t0xe0ca\n#define PLA_MAC_PWR_CTRL3\t0xe0cc\n#define PLA_MAC_PWR_CTRL4\t0xe0ce\n#define PLA_WDT6_CTRL\t\t0xe428\n#define PLA_TCR0\t\t0xe610\n#define PLA_TCR1\t\t0xe612\n#define PLA_MTPS\t\t0xe615\n#define PLA_TXFIFO_CTRL\t\t0xe618\n#define PLA_TXFIFO_FULL\t\t0xe61a\n#define PLA_RSTTALLY\t\t0xe800\n#define PLA_CR\t\t\t0xe813\n#define PLA_CRWECR\t\t0xe81c\n#define PLA_CONFIG12\t\t0xe81e\t \n#define PLA_CONFIG34\t\t0xe820\t \n#define PLA_CONFIG5\t\t0xe822\n#define PLA_PHY_PWR\t\t0xe84c\n#define PLA_OOB_CTRL\t\t0xe84f\n#define PLA_CPCR\t\t0xe854\n#define PLA_MISC_0\t\t0xe858\n#define PLA_MISC_1\t\t0xe85a\n#define PLA_OCP_GPHY_BASE\t0xe86c\n#define PLA_TALLYCNT\t\t0xe890\n#define PLA_SFF_STS_7\t\t0xe8de\n#define PLA_PHYSTATUS\t\t0xe908\n#define PLA_CONFIG6\t\t0xe90a  \n#define PLA_USB_CFG\t\t0xe952\n#define PLA_BP_BA\t\t0xfc26\n#define PLA_BP_0\t\t0xfc28\n#define PLA_BP_1\t\t0xfc2a\n#define PLA_BP_2\t\t0xfc2c\n#define PLA_BP_3\t\t0xfc2e\n#define PLA_BP_4\t\t0xfc30\n#define PLA_BP_5\t\t0xfc32\n#define PLA_BP_6\t\t0xfc34\n#define PLA_BP_7\t\t0xfc36\n#define PLA_BP_EN\t\t0xfc38\n\n#define USB_USB2PHY\t\t0xb41e\n#define USB_SSPHYLINK1\t\t0xb426\n#define USB_SSPHYLINK2\t\t0xb428\n#define USB_L1_CTRL\t\t0xb45e\n#define USB_U2P3_CTRL\t\t0xb460\n#define USB_CSR_DUMMY1\t\t0xb464\n#define USB_CSR_DUMMY2\t\t0xb466\n#define USB_DEV_STAT\t\t0xb808\n#define USB_CONNECT_TIMER\t0xcbf8\n#define USB_MSC_TIMER\t\t0xcbfc\n#define USB_BURST_SIZE\t\t0xcfc0\n#define USB_FW_FIX_EN0\t\t0xcfca\n#define USB_FW_FIX_EN1\t\t0xcfcc\n#define USB_LPM_CONFIG\t\t0xcfd8\n#define USB_ECM_OPTION\t\t0xcfee\n#define USB_CSTMR\t\t0xcfef\t \n#define USB_MISC_2\t\t0xcfff\n#define USB_ECM_OP\t\t0xd26b\n#define USB_GPHY_CTRL\t\t0xd284\n#define USB_SPEED_OPTION\t0xd32a\n#define USB_FW_CTRL\t\t0xd334\t \n#define USB_FC_TIMER\t\t0xd340\n#define USB_USB_CTRL\t\t0xd406\n#define USB_PHY_CTRL\t\t0xd408\n#define USB_TX_AGG\t\t0xd40a\n#define USB_RX_BUF_TH\t\t0xd40c\n#define USB_USB_TIMER\t\t0xd428\n#define USB_RX_EARLY_TIMEOUT\t0xd42c\n#define USB_RX_EARLY_SIZE\t0xd42e\n#define USB_PM_CTRL_STATUS\t0xd432\t \n#define USB_RX_EXTRA_AGGR_TMR\t0xd432\t \n#define USB_TX_DMA\t\t0xd434\n#define USB_UPT_RXDMA_OWN\t0xd437\n#define USB_UPHY3_MDCMDIO\t0xd480\n#define USB_TOLERANCE\t\t0xd490\n#define USB_LPM_CTRL\t\t0xd41a\n#define USB_BMU_RESET\t\t0xd4b0\n#define USB_BMU_CONFIG\t\t0xd4b4\n#define USB_U1U2_TIMER\t\t0xd4da\n#define USB_FW_TASK\t\t0xd4e8\t \n#define USB_RX_AGGR_NUM\t\t0xd4ee\n#define USB_UPS_CTRL\t\t0xd800\n#define USB_POWER_CUT\t\t0xd80a\n#define USB_MISC_0\t\t0xd81a\n#define USB_MISC_1\t\t0xd81f\n#define USB_AFE_CTRL2\t\t0xd824\n#define USB_UPHY_XTAL\t\t0xd826\n#define USB_UPS_CFG\t\t0xd842\n#define USB_UPS_FLAGS\t\t0xd848\n#define USB_WDT1_CTRL\t\t0xe404\n#define USB_WDT11_CTRL\t\t0xe43c\n#define USB_BP_BA\t\tPLA_BP_BA\n#define USB_BP_0\t\tPLA_BP_0\n#define USB_BP_1\t\tPLA_BP_1\n#define USB_BP_2\t\tPLA_BP_2\n#define USB_BP_3\t\tPLA_BP_3\n#define USB_BP_4\t\tPLA_BP_4\n#define USB_BP_5\t\tPLA_BP_5\n#define USB_BP_6\t\tPLA_BP_6\n#define USB_BP_7\t\tPLA_BP_7\n#define USB_BP_EN\t\tPLA_BP_EN\t \n#define USB_BP_8\t\t0xfc38\t\t \n#define USB_BP_9\t\t0xfc3a\n#define USB_BP_10\t\t0xfc3c\n#define USB_BP_11\t\t0xfc3e\n#define USB_BP_12\t\t0xfc40\n#define USB_BP_13\t\t0xfc42\n#define USB_BP_14\t\t0xfc44\n#define USB_BP_15\t\t0xfc46\n#define USB_BP2_EN\t\t0xfc48\n\n \n#define OCP_ALDPS_CONFIG\t0x2010\n#define OCP_EEE_CONFIG1\t\t0x2080\n#define OCP_EEE_CONFIG2\t\t0x2092\n#define OCP_EEE_CONFIG3\t\t0x2094\n#define OCP_BASE_MII\t\t0xa400\n#define OCP_EEE_AR\t\t0xa41a\n#define OCP_EEE_DATA\t\t0xa41c\n#define OCP_PHY_STATUS\t\t0xa420\n#define OCP_INTR_EN\t\t0xa424\n#define OCP_NCTL_CFG\t\t0xa42c\n#define OCP_POWER_CFG\t\t0xa430\n#define OCP_EEE_CFG\t\t0xa432\n#define OCP_SRAM_ADDR\t\t0xa436\n#define OCP_SRAM_DATA\t\t0xa438\n#define OCP_DOWN_SPEED\t\t0xa442\n#define OCP_EEE_ABLE\t\t0xa5c4\n#define OCP_EEE_ADV\t\t0xa5d0\n#define OCP_EEE_LPABLE\t\t0xa5d2\n#define OCP_10GBT_CTRL\t\t0xa5d4\n#define OCP_10GBT_STAT\t\t0xa5d6\n#define OCP_EEE_ADV2\t\t0xa6d4\n#define OCP_PHY_STATE\t\t0xa708\t\t \n#define OCP_PHY_PATCH_STAT\t0xb800\n#define OCP_PHY_PATCH_CMD\t0xb820\n#define OCP_PHY_LOCK\t\t0xb82e\n#define OCP_ADC_IOFFSET\t\t0xbcfc\n#define OCP_ADC_CFG\t\t0xbc06\n#define OCP_SYSCLK_CFG\t\t0xc416\n\n \n#define SRAM_GREEN_CFG\t\t0x8011\n#define SRAM_LPF_CFG\t\t0x8012\n#define SRAM_GPHY_FW_VER\t0x801e\n#define SRAM_10M_AMP1\t\t0x8080\n#define SRAM_10M_AMP2\t\t0x8082\n#define SRAM_IMPEDANCE\t\t0x8084\n#define SRAM_PHY_LOCK\t\t0xb82e\n\n \n#define RCR_AAP\t\t\t0x00000001\n#define RCR_APM\t\t\t0x00000002\n#define RCR_AM\t\t\t0x00000004\n#define RCR_AB\t\t\t0x00000008\n#define RCR_ACPT_ALL\t\t(RCR_AAP | RCR_APM | RCR_AM | RCR_AB)\n#define SLOT_EN\t\t\tBIT(11)\n\n \n#define OUTER_VLAN\t\tBIT(7)\n#define INNER_VLAN\t\tBIT(6)\n\n \n#define RXFIFO_THR1_NORMAL\t0x00080002\n#define RXFIFO_THR1_OOB\t\t0x01800003\n\n \n#define RXFIFO_FULL_MASK\t0xfff\n\n \n#define RXFIFO_THR2_FULL\t0x00000060\n#define RXFIFO_THR2_HIGH\t0x00000038\n#define RXFIFO_THR2_OOB\t\t0x0000004a\n#define RXFIFO_THR2_NORMAL\t0x00a0\n\n \n#define RXFIFO_THR3_FULL\t0x00000078\n#define RXFIFO_THR3_HIGH\t0x00000048\n#define RXFIFO_THR3_OOB\t\t0x0000005a\n#define RXFIFO_THR3_NORMAL\t0x0110\n\n \n#define TXFIFO_THR_NORMAL\t0x00400008\n#define TXFIFO_THR_NORMAL2\t0x01000008\n\n \n#define ECM_ALDPS\t\t0x0002\n\n \n#define FMC_FCR_MCU_EN\t\t0x0001\n\n \n#define EEEP_CR_EEEP_TX\t\t0x0002\n\n \n#define WDT6_SET_MODE\t\t0x0010\n\n \n#define TCR0_TX_EMPTY\t\t0x0800\n#define TCR0_AUTO_FIFO\t\t0x0080\n\n \n#define VERSION_MASK\t\t0x7cf0\n#define IFG_MASK\t\t(BIT(3) | BIT(9) | BIT(8))\n#define IFG_144NS\t\tBIT(9)\n#define IFG_96NS\t\t(BIT(9) | BIT(8))\n\n \n#define MTPS_JUMBO\t\t(12 * 1024 / 64)\n#define MTPS_DEFAULT\t\t(6 * 1024 / 64)\n\n \n#define TALLY_RESET\t\t0x0001\n\n \n#define CR_RST\t\t\t0x10\n#define CR_RE\t\t\t0x08\n#define CR_TE\t\t\t0x04\n\n \n#define CRWECR_NORAML\t\t0x00\n#define CRWECR_CONFIG\t\t0xc0\n\n \n#define NOW_IS_OOB\t\t0x80\n#define TXFIFO_EMPTY\t\t0x20\n#define RXFIFO_EMPTY\t\t0x10\n#define LINK_LIST_READY\t\t0x02\n#define DIS_MCU_CLROOB\t\t0x01\n#define FIFO_EMPTY\t\t(TXFIFO_EMPTY | RXFIFO_EMPTY)\n\n \n#define RXDY_GATED_EN\t\t0x0008\n\n \n#define RE_INIT_LL\t\t0x8000\n#define MCU_BORW_EN\t\t0x4000\n\n \n#define FLOW_CTRL_EN\t\tBIT(0)\n#define CPCR_RX_VLAN\t\t0x0040\n\n \n#define MAGIC_EN\t\t0x0001\n\n \n#define TEREDO_SEL\t\t0x8000\n#define TEREDO_WAKE_MASK\t0x7f00\n#define TEREDO_RS_EVENT_MASK\t0x00fe\n#define OOB_TEREDO_EN\t\t0x0001\n\n \n#define ALDPS_PROXY_MODE\t0x0001\n\n \n#define EFUSE_READ_CMD\t\tBIT(15)\n#define EFUSE_DATA_BIT16\tBIT(7)\n\n \n#define LINK_ON_WAKE_EN\t\t0x0010\n#define LINK_OFF_WAKE_EN\t0x0008\n\n \n#define LANWAKE_CLR_EN\t\tBIT(0)\n\n \n#define EN_XG_LIP\t\tBIT(1)\n#define EN_G_LIP\t\tBIT(2)\n\n \n#define BWF_EN\t\t\t0x0040\n#define MWF_EN\t\t\t0x0020\n#define UWF_EN\t\t\t0x0010\n#define LAN_WAKE_EN\t\t0x0002\n\n \n#define LED_MODE_MASK\t\t0x0700\n\n \n#define TX_10M_IDLE_EN\t\t0x0080\n#define PFM_PWM_SWITCH\t\t0x0040\n#define TEST_IO_OFF\t\tBIT(4)\n\n \n#define D3_CLK_GATED_EN\t\t0x00004000\n#define MCU_CLK_RATIO\t\t0x07010f07\n#define MCU_CLK_RATIO_MASK\t0x0f0f0f0f\n#define ALDPS_SPDWN_RATIO\t0x0f87\n\n \n#define EEE_SPDWN_RATIO\t\t0x8007\n#define MAC_CLK_SPDWN_EN\tBIT(15)\n#define EEE_SPDWN_RATIO_MASK\t0xff\n\n \n#define PLA_MCU_SPDWN_EN\tBIT(14)\n#define PKT_AVAIL_SPDWN_EN\t0x0100\n#define SUSPEND_SPDWN_EN\t0x0004\n#define U1U2_SPDWN_EN\t\t0x0002\n#define L1_SPDWN_EN\t\t0x0001\n\n \n#define PWRSAVE_SPDWN_EN\t0x1000\n#define RXDV_SPDWN_EN\t\t0x0800\n#define TX10MIDLE_EN\t\t0x0100\n#define IDLE_SPDWN_EN\t\tBIT(6)\n#define TP100_SPDWN_EN\t\t0x0020\n#define TP500_SPDWN_EN\t\t0x0010\n#define TP1000_SPDWN_EN\t\t0x0008\n#define EEE_SPDWN_EN\t\t0x0001\n\n \n#define GPHY_STS_MSK\t\t0x0001\n#define SPEED_DOWN_MSK\t\t0x0002\n#define SPDWN_RXDV_MSK\t\t0x0004\n#define SPDWN_LINKCHG_MSK\t0x0008\n\n \n#define PHYAR_FLAG\t\t0x80000000\n\n \n#define EEE_RX_EN\t\t0x0001\n#define EEE_TX_EN\t\t0x0002\n\n \n#define AUTOLOAD_DONE\t\t0x0002\n\n \n#define LANWAKE_PIN\t\tBIT(7)\n\n \n#define LINK_CHG_EVENT\t\tBIT(0)\n\n \n#define UPCOMING_RUNTIME_D3\tBIT(0)\n\n \n#define DEBUG_OE\t\tBIT(0)\n#define DEBUG_LTSSM\t\t0x0082\n\n \n#define CUR_LINK_OK\t\tBIT(15)\n#define U3P3_CHECK_EN\t\tBIT(7)\t \n#define LINK_CHANGE_FLAG\tBIT(8)\n#define POLL_LINK_CHG\t\tBIT(0)\n\n \n#define GPHY_FLASH\t\tBIT(1)\n\n \n#define DACK_DET_EN\t\tBIT(15)\n#define POL_GPHY_PATCH\t\tBIT(4)\n\n \n#define USB2PHY_SUSPEND\t\t0x0001\n#define USB2PHY_L1\t\t0x0002\n\n \n#define DELAY_PHY_PWR_CHG\tBIT(1)\n\n \n#define pwd_dn_scale_mask\t0x3ffe\n#define pwd_dn_scale(x)\t\t((x) << 1)\n\n \n#define DYNAMIC_BURST\t\t0x0001\n\n \n#define EP4_FULL_FC\t\t0x0001\n\n \n#define STAT_SPEED_MASK\t\t0x0006\n#define STAT_SPEED_HIGH\t\t0x0000\n#define STAT_SPEED_FULL\t\t0x0002\n\n \n#define FW_FIX_SUSPEND\t\tBIT(14)\n\n \n#define FW_IP_RESET_EN\t\tBIT(9)\n\n \n#define LPM_U1U2_EN\t\tBIT(0)\n\n \n#define TX_AGG_MAX_THRESHOLD\t0x03\n\n \n#define RX_THR_SUPPER\t\t0x0c350180\n#define RX_THR_HIGH\t\t0x7a120180\n#define RX_THR_SLOW\t\t0xffff0180\n#define RX_THR_B\t\t0x00010001\n\n \n#define TEST_MODE_DISABLE\t0x00000001\n#define TX_SIZE_ADJUST1\t\t0x00000100\n\n \n#define BMU_RESET_EP_IN\t\t0x01\n#define BMU_RESET_EP_OUT\t0x02\n\n \n#define ACT_ODMA\t\tBIT(1)\n\n \n#define OWN_UPDATE\t\tBIT(0)\n#define OWN_CLEAR\t\tBIT(1)\n\n \n#define FC_PATCH_TASK\t\tBIT(1)\n\n \n#define RX_AGGR_NUM_MASK\t0x1ff\n\n \n#define POWER_CUT\t\t0x0100\n\n \n#define RESUME_INDICATE\t\t0x0001\n\n \n#define BYPASS_MAC_RESET\tBIT(5)\n\n \n#define FORCE_SUPER\t\tBIT(0)\n\n \n#define UPS_FORCE_PWR_DOWN\tBIT(0)\n\n \n#define\tEN_ALL_SPEED\t\tBIT(0)\n\n \n#define GPHY_PATCH_DONE\t\tBIT(2)\n#define BYPASS_FLASH\t\tBIT(5)\n#define BACKUP_RESTRORE\t\tBIT(6)\n\n \n#define RG_PWRDN_EN\t\tBIT(8)\n#define ALL_SPEED_OFF\t\tBIT(9)\n\n \n#define FLOW_CTRL_PATCH_OPT\tBIT(1)\n#define AUTO_SPEEDUP\t\tBIT(3)\n#define FLOW_CTRL_PATCH_2\tBIT(8)\n\n \n#define CTRL_TIMER_EN\t\tBIT(15)\n\n \n#define CDC_ECM_EN\t\tBIT(3)\n#define RX_AGG_DISABLE\t\t0x0010\n#define RX_ZERO_EN\t\t0x0080\n\n \n#define U2P3_ENABLE\t\t0x0001\n#define RX_DETECT8\t\tBIT(3)\n\n \n#define PWR_EN\t\t\t0x0001\n#define PHASE2_EN\t\t0x0008\n#define UPS_EN\t\t\tBIT(4)\n#define USP_PREWAKE\t\tBIT(5)\n\n \n#define PCUT_STATUS\t\t0x0001\n\n \n#define COALESCE_SUPER\t\t 85000U\n#define COALESCE_HIGH\t\t250000U\n#define COALESCE_SLOW\t\t524280U\n\n \n#define WTD1_EN\t\t\tBIT(0)\n\n \n#define TIMER11_EN\t\t0x0001\n\n \n \n#define FIFO_EMPTY_1FB\t\t0x30\t \n \n#define LPM_TIMER_MASK\t\t0x0c\n#define LPM_TIMER_500MS\t\t0x04\t \n#define LPM_TIMER_500US\t\t0x0c\t \n#define ROK_EXIT_LPM\t\t0x02\n\n \n#define SEN_VAL_MASK\t\t0xf800\n#define SEN_VAL_NORMAL\t\t0xa000\n#define SEL_RXIDLE\t\t0x0100\n\n \n#define OOBS_POLLING\t\tBIT(8)\n\n \n#define SAW_CNT_1MS_MASK\t0x0fff\n#define MID_REVERSE\t\tBIT(5)\t \n\n \n#define UPS_FLAGS_R_TUNE\t\tBIT(0)\n#define UPS_FLAGS_EN_10M_CKDIV\t\tBIT(1)\n#define UPS_FLAGS_250M_CKDIV\t\tBIT(2)\n#define UPS_FLAGS_EN_ALDPS\t\tBIT(3)\n#define UPS_FLAGS_CTAP_SHORT_DIS\tBIT(4)\n#define UPS_FLAGS_SPEED_MASK\t\t(0xf << 16)\n#define ups_flags_speed(x)\t\t((x) << 16)\n#define UPS_FLAGS_EN_EEE\t\tBIT(20)\n#define UPS_FLAGS_EN_500M_EEE\t\tBIT(21)\n#define UPS_FLAGS_EN_EEE_CKDIV\t\tBIT(22)\n#define UPS_FLAGS_EEE_PLLOFF_100\tBIT(23)\n#define UPS_FLAGS_EEE_PLLOFF_GIGA\tBIT(24)\n#define UPS_FLAGS_EEE_CMOD_LV_EN\tBIT(25)\n#define UPS_FLAGS_EN_GREEN\t\tBIT(26)\n#define UPS_FLAGS_EN_FLOW_CTR\t\tBIT(27)\n\nenum spd_duplex {\n\tNWAY_10M_HALF,\n\tNWAY_10M_FULL,\n\tNWAY_100M_HALF,\n\tNWAY_100M_FULL,\n\tNWAY_1000M_FULL,\n\tFORCE_10M_HALF,\n\tFORCE_10M_FULL,\n\tFORCE_100M_HALF,\n\tFORCE_100M_FULL,\n\tFORCE_1000M_FULL,\n\tNWAY_2500M_FULL,\n};\n\n \n#define ENPWRSAVE\t\t0x8000\n#define ENPDNPS\t\t\t0x0200\n#define LINKENA\t\t\t0x0100\n#define DIS_SDSAVE\t\t0x0010\n\n \n#define PHY_STAT_MASK\t\t0x0007\n#define PHY_STAT_EXT_INIT\t2\n#define PHY_STAT_LAN_ON\t\t3\n#define PHY_STAT_PWRDN\t\t5\n\n \n#define INTR_SPEED_FORCE\tBIT(3)\n\n \n#define PGA_RETURN_EN\t\tBIT(1)\n\n \n#define EEE_CLKDIV_EN\t\t0x8000\n#define EN_ALDPS\t\t0x0004\n#define EN_10M_PLLOFF\t\t0x0001\n\n \n#define RG_TXLPI_MSK_HFDUP\t0x8000\n#define RG_MATCLR_EN\t\t0x4000\n#define EEE_10_CAP\t\t0x2000\n#define EEE_NWAY_EN\t\t0x1000\n#define TX_QUIET_EN\t\t0x0200\n#define RX_QUIET_EN\t\t0x0100\n#define sd_rise_time_mask\t0x0070\n#define sd_rise_time(x)\t\t(min(x, 7) << 4)\t \n#define RG_RXLPI_MSK_HFDUP\t0x0008\n#define SDFALLTIME\t\t0x0007\t \n\n \n#define RG_LPIHYS_NUM\t\t0x7000\t \n#define RG_DACQUIET_EN\t\t0x0400\n#define RG_LDVQUIET_EN\t\t0x0200\n#define RG_CKRSEL\t\t0x0020\n#define RG_EEEPRG_EN\t\t0x0010\n\n \n#define fast_snr_mask\t\t0xff80\n#define fast_snr(x)\t\t(min(x, 0x1ff) << 7)\t \n#define RG_LFS_SEL\t\t0x0060\t \n#define MSK_PH\t\t\t0x0006\t \n\n \n \n#define FUN_ADDR\t\t0x0000\n#define FUN_DATA\t\t0x4000\n \n\n \n#define CTAP_SHORT_EN\t\t0x0040\n#define EEE10_EN\t\t0x0010\n\n \n#define EN_EEE_CMODE\t\tBIT(14)\n#define EN_EEE_1000\t\tBIT(13)\n#define EN_EEE_100\t\tBIT(12)\n#define EN_10M_CLKDIV\t\tBIT(11)\n#define EN_10M_BGOFF\t\t0x0080\n\n \n#define RTL_ADV2_5G_F_R\t\tBIT(5)\t \n\n \n#define TXDIS_STATE\t\t0x01\n#define ABD_STATE\t\t0x02\n\n \n#define PATCH_READY\t\tBIT(6)\n\n \n#define PATCH_REQUEST\t\tBIT(4)\n\n \n#define PATCH_LOCK\t\tBIT(0)\n\n \n#define CKADSEL_L\t\t0x0100\n#define ADC_EN\t\t\t0x0080\n#define EN_EMI_L\t\t0x0040\n\n \n#define sysclk_div_expo(x)\t(min(x, 5) << 8)\n#define clk_div_expo(x)\t\t(min(x, 5) << 4)\n\n \n#define GREEN_ETH_EN\t\tBIT(15)\n#define R_TUNE_EN\t\tBIT(11)\n\n \n#define LPF_AUTO_TUNE\t\t0x8000\n\n \n#define GDAC_IB_UPALL\t\t0x0008\n\n \n#define AMP_DN\t\t\t0x0200\n\n \n#define RX_DRIVING_MASK\t\t0x6000\n\n \n#define PHY_PATCH_LOCK\t\t0x0001\n\n \n#define AD_MASK\t\t\t0xfee0\n#define BND_MASK\t\t0x0004\n#define BD_MASK\t\t\t0x0001\n#define EFUSE\t\t\t0xcfdb\n#define PASS_THRU_MASK\t\t0x1\n\n#define BP4_SUPER_ONLY\t\t0x1578\t \n\nenum rtl_register_content {\n\t_2500bps\t= BIT(10),\n\t_1250bps\t= BIT(9),\n\t_500bps\t\t= BIT(8),\n\t_tx_flow\t= BIT(6),\n\t_rx_flow\t= BIT(5),\n\t_1000bps\t= 0x10,\n\t_100bps\t\t= 0x08,\n\t_10bps\t\t= 0x04,\n\tLINK_STATUS\t= 0x02,\n\tFULL_DUP\t= 0x01,\n};\n\n#define is_speed_2500(_speed)\t(((_speed) & (_2500bps | LINK_STATUS)) == (_2500bps | LINK_STATUS))\n#define is_flow_control(_speed)\t(((_speed) & (_tx_flow | _rx_flow)) == (_tx_flow | _rx_flow))\n\n#define RTL8152_MAX_TX\t\t4\n#define RTL8152_MAX_RX\t\t10\n#define INTBUFSIZE\t\t2\n#define TX_ALIGN\t\t4\n#define RX_ALIGN\t\t8\n\n#define RTL8152_RX_MAX_PENDING\t4096\n#define RTL8152_RXFG_HEADSZ\t256\n\n#define INTR_LINK\t\t0x0004\n\n#define RTL8152_RMS\t\t(VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)\n#define RTL8153_RMS\t\tRTL8153_MAX_PACKET\n#define RTL8152_TX_TIMEOUT\t(5 * HZ)\n#define mtu_to_size(m)\t\t((m) + VLAN_ETH_HLEN + ETH_FCS_LEN)\n#define size_to_mtu(s)\t\t((s) - VLAN_ETH_HLEN - ETH_FCS_LEN)\n#define rx_reserved_size(x)\t(mtu_to_size(x) + sizeof(struct rx_desc) + RX_ALIGN)\n\n \nenum rtl8152_flags {\n\tRTL8152_INACCESSIBLE = 0,\n\tRTL8152_SET_RX_MODE,\n\tWORK_ENABLE,\n\tRTL8152_LINK_CHG,\n\tSELECTIVE_SUSPEND,\n\tPHY_RESET,\n\tSCHEDULE_TASKLET,\n\tGREEN_ETHERNET,\n\tRX_EPROTO,\n\tIN_PRE_RESET,\n\tPROBED_WITH_NO_ERRORS,\n\tPROBE_SHOULD_RETRY,\n};\n\n#define DEVICE_ID_LENOVO_USB_C_TRAVEL_HUB\t\t0x721e\n#define DEVICE_ID_THINKPAD_ONELINK_PLUS_DOCK\t\t0x3054\n#define DEVICE_ID_THINKPAD_THUNDERBOLT3_DOCK_GEN2\t0x3082\n#define DEVICE_ID_THINKPAD_USB_C_DONGLE\t\t\t0x720c\n#define DEVICE_ID_THINKPAD_USB_C_DOCK_GEN2\t\t0xa387\n#define DEVICE_ID_THINKPAD_USB_C_DOCK_GEN3\t\t0x3062\n\nstruct tally_counter {\n\t__le64\ttx_packets;\n\t__le64\trx_packets;\n\t__le64\ttx_errors;\n\t__le32\trx_errors;\n\t__le16\trx_missed;\n\t__le16\talign_errors;\n\t__le32\ttx_one_collision;\n\t__le32\ttx_multi_collision;\n\t__le64\trx_unicast;\n\t__le64\trx_broadcast;\n\t__le32\trx_multicast;\n\t__le16\ttx_aborted;\n\t__le16\ttx_underrun;\n};\n\nstruct rx_desc {\n\t__le32 opts1;\n#define RX_LEN_MASK\t\t\t0x7fff\n\n\t__le32 opts2;\n#define RD_UDP_CS\t\t\tBIT(23)\n#define RD_TCP_CS\t\t\tBIT(22)\n#define RD_IPV6_CS\t\t\tBIT(20)\n#define RD_IPV4_CS\t\t\tBIT(19)\n\n\t__le32 opts3;\n#define IPF\t\t\t\tBIT(23)  \n#define UDPF\t\t\t\tBIT(22)  \n#define TCPF\t\t\t\tBIT(21)  \n#define RX_VLAN_TAG\t\t\tBIT(16)\n\n\t__le32 opts4;\n\t__le32 opts5;\n\t__le32 opts6;\n};\n\nstruct tx_desc {\n\t__le32 opts1;\n#define TX_FS\t\t\tBIT(31)  \n#define TX_LS\t\t\tBIT(30)  \n#define GTSENDV4\t\tBIT(28)\n#define GTSENDV6\t\tBIT(27)\n#define GTTCPHO_SHIFT\t\t18\n#define GTTCPHO_MAX\t\t0x7fU\n#define TX_LEN_MAX\t\t0x3ffffU\n\n\t__le32 opts2;\n#define UDP_CS\t\t\tBIT(31)  \n#define TCP_CS\t\t\tBIT(30)  \n#define IPV4_CS\t\t\tBIT(29)  \n#define IPV6_CS\t\t\tBIT(28)  \n#define MSS_SHIFT\t\t17\n#define MSS_MAX\t\t\t0x7ffU\n#define TCPHO_SHIFT\t\t17\n#define TCPHO_MAX\t\t0x7ffU\n#define TX_VLAN_TAG\t\tBIT(16)\n};\n\nstruct r8152;\n\nstruct rx_agg {\n\tstruct list_head list, info_list;\n\tstruct urb *urb;\n\tstruct r8152 *context;\n\tstruct page *page;\n\tvoid *buffer;\n};\n\nstruct tx_agg {\n\tstruct list_head list;\n\tstruct urb *urb;\n\tstruct r8152 *context;\n\tvoid *buffer;\n\tvoid *head;\n\tu32 skb_num;\n\tu32 skb_len;\n};\n\nstruct r8152 {\n\tunsigned long flags;\n\tstruct usb_device *udev;\n\tstruct napi_struct napi;\n\tstruct usb_interface *intf;\n\tstruct net_device *netdev;\n\tstruct urb *intr_urb;\n\tstruct tx_agg tx_info[RTL8152_MAX_TX];\n\tstruct list_head rx_info, rx_used;\n\tstruct list_head rx_done, tx_free;\n\tstruct sk_buff_head tx_queue, rx_queue;\n\tspinlock_t rx_lock, tx_lock;\n\tstruct delayed_work schedule, hw_phy_work;\n\tstruct mii_if_info mii;\n\tstruct mutex control;\t \n#ifdef CONFIG_PM_SLEEP\n\tstruct notifier_block pm_notifier;\n#endif\n\tstruct tasklet_struct tx_tl;\n\n\tstruct rtl_ops {\n\t\tvoid (*init)(struct r8152 *tp);\n\t\tint (*enable)(struct r8152 *tp);\n\t\tvoid (*disable)(struct r8152 *tp);\n\t\tvoid (*up)(struct r8152 *tp);\n\t\tvoid (*down)(struct r8152 *tp);\n\t\tvoid (*unload)(struct r8152 *tp);\n\t\tint (*eee_get)(struct r8152 *tp, struct ethtool_eee *eee);\n\t\tint (*eee_set)(struct r8152 *tp, struct ethtool_eee *eee);\n\t\tbool (*in_nway)(struct r8152 *tp);\n\t\tvoid (*hw_phy_cfg)(struct r8152 *tp);\n\t\tvoid (*autosuspend_en)(struct r8152 *tp, bool enable);\n\t\tvoid (*change_mtu)(struct r8152 *tp);\n\t} rtl_ops;\n\n\tstruct ups_info {\n\t\tu32 r_tune:1;\n\t\tu32 _10m_ckdiv:1;\n\t\tu32 _250m_ckdiv:1;\n\t\tu32 aldps:1;\n\t\tu32 lite_mode:2;\n\t\tu32 speed_duplex:4;\n\t\tu32 eee:1;\n\t\tu32 eee_lite:1;\n\t\tu32 eee_ckdiv:1;\n\t\tu32 eee_plloff_100:1;\n\t\tu32 eee_plloff_giga:1;\n\t\tu32 eee_cmod_lv:1;\n\t\tu32 green:1;\n\t\tu32 flow_control:1;\n\t\tu32 ctap_short_off:1;\n\t} ups_info;\n\n#define RTL_VER_SIZE\t\t32\n\n\tstruct rtl_fw {\n\t\tconst char *fw_name;\n\t\tconst struct firmware *fw;\n\n\t\tchar version[RTL_VER_SIZE];\n\t\tint (*pre_fw)(struct r8152 *tp);\n\t\tint (*post_fw)(struct r8152 *tp);\n\n\t\tbool retry;\n\t} rtl_fw;\n\n\tatomic_t rx_count;\n\n\tbool eee_en;\n\tint intr_interval;\n\tu32 saved_wolopts;\n\tu32 msg_enable;\n\tu32 tx_qlen;\n\tu32 coalesce;\n\tu32 advertising;\n\tu32 rx_buf_sz;\n\tu32 rx_copybreak;\n\tu32 rx_pending;\n\tu32 fc_pause_on, fc_pause_off;\n\n\tunsigned int pipe_in, pipe_out, pipe_intr, pipe_ctrl_in, pipe_ctrl_out;\n\n\tu32 support_2500full:1;\n\tu32 lenovo_macpassthru:1;\n\tu32 dell_tb_rx_agg_bug:1;\n\tu16 ocp_base;\n\tu16 speed;\n\tu16 eee_adv;\n\tu8 *intr_buff;\n\tu8 version;\n\tu8 duplex;\n\tu8 autoneg;\n\n\tunsigned int reg_access_reset_count;\n};\n\n \nstruct fw_block {\n\t__le32 type;\n\t__le32 length;\n} __packed;\n\n \nstruct fw_header {\n\tu8 checksum[32];\n\tchar version[RTL_VER_SIZE];\n\tstruct fw_block blocks[];\n} __packed;\n\nenum rtl8152_fw_flags {\n\tFW_FLAGS_USB = 0,\n\tFW_FLAGS_PLA,\n\tFW_FLAGS_START,\n\tFW_FLAGS_STOP,\n\tFW_FLAGS_NC,\n\tFW_FLAGS_NC1,\n\tFW_FLAGS_NC2,\n\tFW_FLAGS_UC2,\n\tFW_FLAGS_UC,\n\tFW_FLAGS_SPEED_UP,\n\tFW_FLAGS_VER,\n};\n\nenum rtl8152_fw_fixup_cmd {\n\tFW_FIXUP_AND = 0,\n\tFW_FIXUP_OR,\n\tFW_FIXUP_NOT,\n\tFW_FIXUP_XOR,\n};\n\nstruct fw_phy_set {\n\t__le16 addr;\n\t__le16 data;\n} __packed;\n\nstruct fw_phy_speed_up {\n\tstruct fw_block blk_hdr;\n\t__le16 fw_offset;\n\t__le16 version;\n\t__le16 fw_reg;\n\t__le16 reserved;\n\tchar info[];\n} __packed;\n\nstruct fw_phy_ver {\n\tstruct fw_block blk_hdr;\n\tstruct fw_phy_set ver;\n\t__le32 reserved;\n} __packed;\n\nstruct fw_phy_fixup {\n\tstruct fw_block blk_hdr;\n\tstruct fw_phy_set setting;\n\t__le16 bit_cmd;\n\t__le16 reserved;\n} __packed;\n\nstruct fw_phy_union {\n\tstruct fw_block blk_hdr;\n\t__le16 fw_offset;\n\t__le16 fw_reg;\n\tstruct fw_phy_set pre_set[2];\n\tstruct fw_phy_set bp[8];\n\tstruct fw_phy_set bp_en;\n\tu8 pre_num;\n\tu8 bp_num;\n\tchar info[];\n} __packed;\n\n \nstruct fw_mac {\n\tstruct fw_block blk_hdr;\n\t__le16 fw_offset;\n\t__le16 fw_reg;\n\t__le16 bp_ba_addr;\n\t__le16 bp_ba_value;\n\t__le16 bp_en_addr;\n\t__le16 bp_en_value;\n\t__le16 bp_start;\n\t__le16 bp_num;\n\t__le16 bp[16];  \n\t__le32 reserved;\n\t__le16 fw_ver_reg;\n\tu8 fw_ver_data;\n\tchar info[];\n} __packed;\n\n \nstruct fw_phy_patch_key {\n\tstruct fw_block blk_hdr;\n\t__le16 key_reg;\n\t__le16 key_data;\n\t__le32 reserved;\n} __packed;\n\n \nstruct fw_phy_nc {\n\tstruct fw_block blk_hdr;\n\t__le16 fw_offset;\n\t__le16 fw_reg;\n\t__le16 ba_reg;\n\t__le16 ba_data;\n\t__le16 patch_en_addr;\n\t__le16 patch_en_value;\n\t__le16 mode_reg;\n\t__le16 mode_pre;\n\t__le16 mode_post;\n\t__le16 reserved;\n\t__le16 bp_start;\n\t__le16 bp_num;\n\t__le16 bp[4];\n\tchar info[];\n} __packed;\n\nenum rtl_fw_type {\n\tRTL_FW_END = 0,\n\tRTL_FW_PLA,\n\tRTL_FW_USB,\n\tRTL_FW_PHY_START,\n\tRTL_FW_PHY_STOP,\n\tRTL_FW_PHY_NC,\n\tRTL_FW_PHY_FIXUP,\n\tRTL_FW_PHY_UNION_NC,\n\tRTL_FW_PHY_UNION_NC1,\n\tRTL_FW_PHY_UNION_NC2,\n\tRTL_FW_PHY_UNION_UC2,\n\tRTL_FW_PHY_UNION_UC,\n\tRTL_FW_PHY_UNION_MISC,\n\tRTL_FW_PHY_SPEED_UP,\n\tRTL_FW_PHY_VER,\n};\n\nenum rtl_version {\n\tRTL_VER_UNKNOWN = 0,\n\tRTL_VER_01,\n\tRTL_VER_02,\n\tRTL_VER_03,\n\tRTL_VER_04,\n\tRTL_VER_05,\n\tRTL_VER_06,\n\tRTL_VER_07,\n\tRTL_VER_08,\n\tRTL_VER_09,\n\n\tRTL_TEST_01,\n\tRTL_VER_10,\n\tRTL_VER_11,\n\tRTL_VER_12,\n\tRTL_VER_13,\n\tRTL_VER_14,\n\tRTL_VER_15,\n\n\tRTL_VER_MAX\n};\n\nenum tx_csum_stat {\n\tTX_CSUM_SUCCESS = 0,\n\tTX_CSUM_TSO,\n\tTX_CSUM_NONE\n};\n\n#define RTL_ADVERTISED_10_HALF\t\t\tBIT(0)\n#define RTL_ADVERTISED_10_FULL\t\t\tBIT(1)\n#define RTL_ADVERTISED_100_HALF\t\t\tBIT(2)\n#define RTL_ADVERTISED_100_FULL\t\t\tBIT(3)\n#define RTL_ADVERTISED_1000_HALF\t\tBIT(4)\n#define RTL_ADVERTISED_1000_FULL\t\tBIT(5)\n#define RTL_ADVERTISED_2500_FULL\t\tBIT(6)\n\n \nstatic const int multicast_filter_limit = 32;\nstatic unsigned int agg_buf_sz = 16384;\n\n#define RTL_LIMITED_TSO_SIZE\t(size_to_mtu(agg_buf_sz) - sizeof(struct tx_desc))\n\n \n#define REGISTER_ACCESS_MAX_RESETS\t3\n\nstatic void rtl_set_inaccessible(struct r8152 *tp)\n{\n\tset_bit(RTL8152_INACCESSIBLE, &tp->flags);\n\tsmp_mb__after_atomic();\n}\n\nstatic void rtl_set_accessible(struct r8152 *tp)\n{\n\tclear_bit(RTL8152_INACCESSIBLE, &tp->flags);\n\tsmp_mb__after_atomic();\n}\n\nstatic\nint r8152_control_msg(struct r8152 *tp, unsigned int pipe, __u8 request,\n\t\t      __u8 requesttype, __u16 value, __u16 index, void *data,\n\t\t      __u16 size, const char *msg_tag)\n{\n\tstruct usb_device *udev = tp->udev;\n\tint ret;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn -ENODEV;\n\n\tret = usb_control_msg(udev, pipe, request, requesttype,\n\t\t\t      value, index, data, size,\n\t\t\t      USB_CTRL_GET_TIMEOUT);\n\n\t \n\tif (ret == -ENODEV)\n\t\treturn ret;\n\n\t \n\tif (ret >= 0) {\n\t\ttp->reg_access_reset_count = 0;\n\t\treturn ret;\n\t}\n\n\tdev_err(&udev->dev,\n\t\t\"Failed to %s %d bytes at %#06x/%#06x (%d)\\n\",\n\t\tmsg_tag, size, value, index, ret);\n\n\t \n\trtl_set_inaccessible(tp);\n\n\t \n\tif (!test_bit(PROBED_WITH_NO_ERRORS, &tp->flags)) {\n\t\tset_bit(PROBE_SHOULD_RETRY, &tp->flags);\n\t\treturn ret;\n\t}\n\n\t \n\tif (test_bit(IN_PRE_RESET, &tp->flags))\n\t\treturn ret;\n\n\tif (tp->reg_access_reset_count < REGISTER_ACCESS_MAX_RESETS) {\n\t\tusb_queue_reset_device(tp->intf);\n\t\ttp->reg_access_reset_count++;\n\t} else if (tp->reg_access_reset_count == REGISTER_ACCESS_MAX_RESETS) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"Tried to reset %d times; giving up.\\n\",\n\t\t\tREGISTER_ACCESS_MAX_RESETS);\n\t}\n\n\treturn ret;\n}\n\nstatic\nint get_registers(struct r8152 *tp, u16 value, u16 index, u16 size, void *data)\n{\n\tint ret;\n\tvoid *tmp;\n\n\ttmp = kmalloc(size, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tret = r8152_control_msg(tp, tp->pipe_ctrl_in,\n\t\t\t\tRTL8152_REQ_GET_REGS, RTL8152_REQT_READ,\n\t\t\t\tvalue, index, tmp, size, \"read\");\n\n\tif (ret < 0)\n\t\tmemset(data, 0xff, size);\n\telse\n\t\tmemcpy(data, tmp, size);\n\n\tkfree(tmp);\n\n\treturn ret;\n}\n\nstatic\nint set_registers(struct r8152 *tp, u16 value, u16 index, u16 size, void *data)\n{\n\tint ret;\n\tvoid *tmp;\n\n\ttmp = kmemdup(data, size, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tret = r8152_control_msg(tp, tp->pipe_ctrl_out,\n\t\t\t\tRTL8152_REQ_SET_REGS, RTL8152_REQT_WRITE,\n\t\t\t\tvalue, index, tmp, size, \"write\");\n\n\tkfree(tmp);\n\n\treturn ret;\n}\n\nstatic void rtl_set_unplug(struct r8152 *tp)\n{\n\tif (tp->udev->state == USB_STATE_NOTATTACHED)\n\t\trtl_set_inaccessible(tp);\n}\n\nstatic int generic_ocp_read(struct r8152 *tp, u16 index, u16 size,\n\t\t\t    void *data, u16 type)\n{\n\tu16 limit = 64;\n\tint ret = 0;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn -ENODEV;\n\n\t \n\tif ((size & 3) || !size || (index & 3) || !data)\n\t\treturn -EPERM;\n\n\tif ((u32)index + (u32)size > 0xffff)\n\t\treturn -EPERM;\n\n\twhile (size) {\n\t\tif (size > limit) {\n\t\t\tret = get_registers(tp, index, type, limit, data);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tindex += limit;\n\t\t\tdata += limit;\n\t\t\tsize -= limit;\n\t\t} else {\n\t\t\tret = get_registers(tp, index, type, size, data);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tindex += size;\n\t\t\tdata += size;\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret == -ENODEV)\n\t\trtl_set_unplug(tp);\n\n\treturn ret;\n}\n\nstatic int generic_ocp_write(struct r8152 *tp, u16 index, u16 byteen,\n\t\t\t     u16 size, void *data, u16 type)\n{\n\tint ret;\n\tu16 byteen_start, byteen_end, byen;\n\tu16 limit = 512;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn -ENODEV;\n\n\t \n\tif ((size & 3) || !size || (index & 3) || !data)\n\t\treturn -EPERM;\n\n\tif ((u32)index + (u32)size > 0xffff)\n\t\treturn -EPERM;\n\n\tbyteen_start = byteen & BYTE_EN_START_MASK;\n\tbyteen_end = byteen & BYTE_EN_END_MASK;\n\n\tbyen = byteen_start | (byteen_start << 4);\n\n\t \n\tif (byen != BYTE_EN_DWORD) {\n\t\tret = set_registers(tp, index, type | byen, 4, data);\n\t\tif (ret < 0)\n\t\t\tgoto error1;\n\n\t\tindex += 4;\n\t\tdata += 4;\n\t\tsize -= 4;\n\t}\n\n\tif (size) {\n\t\tbyen = byteen_end | (byteen_end >> 4);\n\n\t\t \n\t\tif (byen != BYTE_EN_DWORD)\n\t\t\tsize -= 4;\n\n\t\twhile (size) {\n\t\t\tif (size > limit) {\n\t\t\t\tret = set_registers(tp, index,\n\t\t\t\t\t\t    type | BYTE_EN_DWORD,\n\t\t\t\t\t\t    limit, data);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto error1;\n\n\t\t\t\tindex += limit;\n\t\t\t\tdata += limit;\n\t\t\t\tsize -= limit;\n\t\t\t} else {\n\t\t\t\tret = set_registers(tp, index,\n\t\t\t\t\t\t    type | BYTE_EN_DWORD,\n\t\t\t\t\t\t    size, data);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto error1;\n\n\t\t\t\tindex += size;\n\t\t\t\tdata += size;\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (byen != BYTE_EN_DWORD)\n\t\t\tret = set_registers(tp, index, type | byen, 4, data);\n\t}\n\nerror1:\n\tif (ret == -ENODEV)\n\t\trtl_set_unplug(tp);\n\n\treturn ret;\n}\n\nstatic inline\nint pla_ocp_read(struct r8152 *tp, u16 index, u16 size, void *data)\n{\n\treturn generic_ocp_read(tp, index, size, data, MCU_TYPE_PLA);\n}\n\nstatic inline\nint pla_ocp_write(struct r8152 *tp, u16 index, u16 byteen, u16 size, void *data)\n{\n\treturn generic_ocp_write(tp, index, byteen, size, data, MCU_TYPE_PLA);\n}\n\nstatic inline\nint usb_ocp_write(struct r8152 *tp, u16 index, u16 byteen, u16 size, void *data)\n{\n\treturn generic_ocp_write(tp, index, byteen, size, data, MCU_TYPE_USB);\n}\n\nstatic u32 ocp_read_dword(struct r8152 *tp, u16 type, u16 index)\n{\n\t__le32 data;\n\n\tgeneric_ocp_read(tp, index, sizeof(data), &data, type);\n\n\treturn __le32_to_cpu(data);\n}\n\nstatic void ocp_write_dword(struct r8152 *tp, u16 type, u16 index, u32 data)\n{\n\t__le32 tmp = __cpu_to_le32(data);\n\n\tgeneric_ocp_write(tp, index, BYTE_EN_DWORD, sizeof(tmp), &tmp, type);\n}\n\nstatic u16 ocp_read_word(struct r8152 *tp, u16 type, u16 index)\n{\n\tu32 data;\n\t__le32 tmp;\n\tu16 byen = BYTE_EN_WORD;\n\tu8 shift = index & 2;\n\n\tindex &= ~3;\n\tbyen <<= shift;\n\n\tgeneric_ocp_read(tp, index, sizeof(tmp), &tmp, type | byen);\n\n\tdata = __le32_to_cpu(tmp);\n\tdata >>= (shift * 8);\n\tdata &= 0xffff;\n\n\treturn (u16)data;\n}\n\nstatic void ocp_write_word(struct r8152 *tp, u16 type, u16 index, u32 data)\n{\n\tu32 mask = 0xffff;\n\t__le32 tmp;\n\tu16 byen = BYTE_EN_WORD;\n\tu8 shift = index & 2;\n\n\tdata &= mask;\n\n\tif (index & 2) {\n\t\tbyen <<= shift;\n\t\tmask <<= (shift * 8);\n\t\tdata <<= (shift * 8);\n\t\tindex &= ~3;\n\t}\n\n\ttmp = __cpu_to_le32(data);\n\n\tgeneric_ocp_write(tp, index, byen, sizeof(tmp), &tmp, type);\n}\n\nstatic u8 ocp_read_byte(struct r8152 *tp, u16 type, u16 index)\n{\n\tu32 data;\n\t__le32 tmp;\n\tu8 shift = index & 3;\n\n\tindex &= ~3;\n\n\tgeneric_ocp_read(tp, index, sizeof(tmp), &tmp, type);\n\n\tdata = __le32_to_cpu(tmp);\n\tdata >>= (shift * 8);\n\tdata &= 0xff;\n\n\treturn (u8)data;\n}\n\nstatic void ocp_write_byte(struct r8152 *tp, u16 type, u16 index, u32 data)\n{\n\tu32 mask = 0xff;\n\t__le32 tmp;\n\tu16 byen = BYTE_EN_BYTE;\n\tu8 shift = index & 3;\n\n\tdata &= mask;\n\n\tif (index & 3) {\n\t\tbyen <<= shift;\n\t\tmask <<= (shift * 8);\n\t\tdata <<= (shift * 8);\n\t\tindex &= ~3;\n\t}\n\n\ttmp = __cpu_to_le32(data);\n\n\tgeneric_ocp_write(tp, index, byen, sizeof(tmp), &tmp, type);\n}\n\nstatic u16 ocp_reg_read(struct r8152 *tp, u16 addr)\n{\n\tu16 ocp_base, ocp_index;\n\n\tocp_base = addr & 0xf000;\n\tif (ocp_base != tp->ocp_base) {\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, ocp_base);\n\t\ttp->ocp_base = ocp_base;\n\t}\n\n\tocp_index = (addr & 0x0fff) | 0xb000;\n\treturn ocp_read_word(tp, MCU_TYPE_PLA, ocp_index);\n}\n\nstatic void ocp_reg_write(struct r8152 *tp, u16 addr, u16 data)\n{\n\tu16 ocp_base, ocp_index;\n\n\tocp_base = addr & 0xf000;\n\tif (ocp_base != tp->ocp_base) {\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, ocp_base);\n\t\ttp->ocp_base = ocp_base;\n\t}\n\n\tocp_index = (addr & 0x0fff) | 0xb000;\n\tocp_write_word(tp, MCU_TYPE_PLA, ocp_index, data);\n}\n\nstatic inline void r8152_mdio_write(struct r8152 *tp, u32 reg_addr, u32 value)\n{\n\tocp_reg_write(tp, OCP_BASE_MII + reg_addr * 2, value);\n}\n\nstatic inline int r8152_mdio_read(struct r8152 *tp, u32 reg_addr)\n{\n\treturn ocp_reg_read(tp, OCP_BASE_MII + reg_addr * 2);\n}\n\nstatic void sram_write(struct r8152 *tp, u16 addr, u16 data)\n{\n\tocp_reg_write(tp, OCP_SRAM_ADDR, addr);\n\tocp_reg_write(tp, OCP_SRAM_DATA, data);\n}\n\nstatic u16 sram_read(struct r8152 *tp, u16 addr)\n{\n\tocp_reg_write(tp, OCP_SRAM_ADDR, addr);\n\treturn ocp_reg_read(tp, OCP_SRAM_DATA);\n}\n\nstatic int read_mii_word(struct net_device *netdev, int phy_id, int reg)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\tint ret;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn -ENODEV;\n\n\tif (phy_id != R8152_PHY_ID)\n\t\treturn -EINVAL;\n\n\tret = r8152_mdio_read(tp, reg);\n\n\treturn ret;\n}\n\nstatic\nvoid write_mii_word(struct net_device *netdev, int phy_id, int reg, int val)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tif (phy_id != R8152_PHY_ID)\n\t\treturn;\n\n\tr8152_mdio_write(tp, reg, val);\n}\n\nstatic int\nr8152_submit_rx(struct r8152 *tp, struct rx_agg *agg, gfp_t mem_flags);\n\nstatic int\nrtl8152_set_speed(struct r8152 *tp, u8 autoneg, u32 speed, u8 duplex,\n\t\t  u32 advertising);\n\nstatic int __rtl8152_set_mac_address(struct net_device *netdev, void *p,\n\t\t\t\t     bool in_resume)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\tstruct sockaddr *addr = p;\n\tint ret = -EADDRNOTAVAIL;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\tgoto out1;\n\n\tif (!in_resume) {\n\t\tret = usb_autopm_get_interface(tp->intf);\n\t\tif (ret < 0)\n\t\t\tgoto out1;\n\t}\n\n\tmutex_lock(&tp->control);\n\n\teth_hw_addr_set(netdev, addr->sa_data);\n\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);\n\tpla_ocp_write(tp, PLA_IDR, BYTE_EN_SIX_BYTES, 8, addr->sa_data);\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);\n\n\tmutex_unlock(&tp->control);\n\n\tif (!in_resume)\n\t\tusb_autopm_put_interface(tp->intf);\nout1:\n\treturn ret;\n}\n\nstatic int rtl8152_set_mac_address(struct net_device *netdev, void *p)\n{\n\treturn __rtl8152_set_mac_address(netdev, p, false);\n}\n\n \nstatic int vendor_mac_passthru_addr_read(struct r8152 *tp, struct sockaddr *sa)\n{\n\tacpi_status status;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tint ret = -EINVAL;\n\tu32 ocp_data;\n\tunsigned char buf[6];\n\tchar *mac_obj_name;\n\tacpi_object_type mac_obj_type;\n\tint mac_strlen;\n\n\tif (tp->lenovo_macpassthru) {\n\t\tmac_obj_name = \"\\\\MACA\";\n\t\tmac_obj_type = ACPI_TYPE_STRING;\n\t\tmac_strlen = 0x16;\n\t} else {\n\t\t \n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);\n\t\tif ((ocp_data & AD_MASK) == 0x1000) {\n\t\t\t \n\t\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, EFUSE);\n\t\t\tif ((ocp_data & PASS_THRU_MASK) != 1) {\n\t\t\t\tnetif_dbg(tp, probe, tp->netdev,\n\t\t\t\t\t\t\"No efuse for RTL8153-AD MAC pass through\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_1);\n\t\t\tif ((ocp_data & BND_MASK) == 0 && (ocp_data & BD_MASK) == 0) {\n\t\t\t\tnetif_dbg(tp, probe, tp->netdev,\n\t\t\t\t\t\t\"Invalid variant for MAC pass through\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\n\t\tmac_obj_name = \"\\\\_SB.AMAC\";\n\t\tmac_obj_type = ACPI_TYPE_BUFFER;\n\t\tmac_strlen = 0x17;\n\t}\n\n\t \n\tstatus = acpi_evaluate_object(NULL, mac_obj_name, NULL, &buffer);\n\tobj = (union acpi_object *)buffer.pointer;\n\tif (!ACPI_SUCCESS(status))\n\t\treturn -ENODEV;\n\tif (obj->type != mac_obj_type || obj->string.length != mac_strlen) {\n\t\tnetif_warn(tp, probe, tp->netdev,\n\t\t\t   \"Invalid buffer for pass-thru MAC addr: (%d, %d)\\n\",\n\t\t\t   obj->type, obj->string.length);\n\t\tgoto amacout;\n\t}\n\n\tif (strncmp(obj->string.pointer, \"_AUXMAC_#\", 9) != 0 ||\n\t    strncmp(obj->string.pointer + 0x15, \"#\", 1) != 0) {\n\t\tnetif_warn(tp, probe, tp->netdev,\n\t\t\t   \"Invalid header when reading pass-thru MAC addr\\n\");\n\t\tgoto amacout;\n\t}\n\tret = hex2bin(buf, obj->string.pointer + 9, 6);\n\tif (!(ret == 0 && is_valid_ether_addr(buf))) {\n\t\tnetif_warn(tp, probe, tp->netdev,\n\t\t\t   \"Invalid MAC for pass-thru MAC addr: %d, %pM\\n\",\n\t\t\t   ret, buf);\n\t\tret = -EINVAL;\n\t\tgoto amacout;\n\t}\n\tmemcpy(sa->sa_data, buf, 6);\n\tnetif_info(tp, probe, tp->netdev,\n\t\t   \"Using pass-thru MAC addr %pM\\n\", sa->sa_data);\n\namacout:\n\tkfree(obj);\n\treturn ret;\n}\n\nstatic int determine_ethernet_addr(struct r8152 *tp, struct sockaddr *sa)\n{\n\tstruct net_device *dev = tp->netdev;\n\tint ret;\n\n\tsa->sa_family = dev->type;\n\n\tret = eth_platform_get_mac_address(&tp->udev->dev, sa->sa_data);\n\tif (ret < 0) {\n\t\tif (tp->version == RTL_VER_01) {\n\t\t\tret = pla_ocp_read(tp, PLA_IDR, 8, sa->sa_data);\n\t\t} else {\n\t\t\t \n\t\t\tret = vendor_mac_passthru_addr_read(tp, sa);\n\t\t\tif (ret < 0)\n\t\t\t\tret = pla_ocp_read(tp, PLA_BACKUP, 8,\n\t\t\t\t\t\t   sa->sa_data);\n\t\t}\n\t}\n\n\tif (ret < 0) {\n\t\tnetif_err(tp, probe, dev, \"Get ether addr fail\\n\");\n\t} else if (!is_valid_ether_addr(sa->sa_data)) {\n\t\tnetif_err(tp, probe, dev, \"Invalid ether addr %pM\\n\",\n\t\t\t  sa->sa_data);\n\t\teth_hw_addr_random(dev);\n\t\tether_addr_copy(sa->sa_data, dev->dev_addr);\n\t\tnetif_info(tp, probe, dev, \"Random ether addr %pM\\n\",\n\t\t\t   sa->sa_data);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int set_ethernet_addr(struct r8152 *tp, bool in_resume)\n{\n\tstruct net_device *dev = tp->netdev;\n\tstruct sockaddr sa;\n\tint ret;\n\n\tret = determine_ethernet_addr(tp, &sa);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tp->version == RTL_VER_01)\n\t\teth_hw_addr_set(dev, sa.sa_data);\n\telse\n\t\tret = __rtl8152_set_mac_address(dev, &sa, in_resume);\n\n\treturn ret;\n}\n\nstatic void read_bulk_callback(struct urb *urb)\n{\n\tstruct net_device *netdev;\n\tint status = urb->status;\n\tstruct rx_agg *agg;\n\tstruct r8152 *tp;\n\tunsigned long flags;\n\n\tagg = urb->context;\n\tif (!agg)\n\t\treturn;\n\n\ttp = agg->context;\n\tif (!tp)\n\t\treturn;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tif (!test_bit(WORK_ENABLE, &tp->flags))\n\t\treturn;\n\n\tnetdev = tp->netdev;\n\n\t \n\t \n\tif (!netif_carrier_ok(netdev))\n\t\treturn;\n\n\tusb_mark_last_busy(tp->udev);\n\n\tswitch (status) {\n\tcase 0:\n\t\tif (urb->actual_length < ETH_ZLEN)\n\t\t\tbreak;\n\n\t\tspin_lock_irqsave(&tp->rx_lock, flags);\n\t\tlist_add_tail(&agg->list, &tp->rx_done);\n\t\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\t\tnapi_schedule(&tp->napi);\n\t\treturn;\n\tcase -ESHUTDOWN:\n\t\trtl_set_unplug(tp);\n\t\tnetif_device_detach(tp->netdev);\n\t\treturn;\n\tcase -EPROTO:\n\t\turb->actual_length = 0;\n\t\tspin_lock_irqsave(&tp->rx_lock, flags);\n\t\tlist_add_tail(&agg->list, &tp->rx_done);\n\t\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\t\tset_bit(RX_EPROTO, &tp->flags);\n\t\tschedule_delayed_work(&tp->schedule, 1);\n\t\treturn;\n\tcase -ENOENT:\n\t\treturn;\t \n\tcase -ETIME:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_warn(netdev, \"maybe reset is needed?\\n\");\n\t\tbreak;\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_warn(netdev, \"Rx status %d\\n\", status);\n\t\tbreak;\n\t}\n\n\tr8152_submit_rx(tp, agg, GFP_ATOMIC);\n}\n\nstatic void write_bulk_callback(struct urb *urb)\n{\n\tstruct net_device_stats *stats;\n\tstruct net_device *netdev;\n\tstruct tx_agg *agg;\n\tstruct r8152 *tp;\n\tunsigned long flags;\n\tint status = urb->status;\n\n\tagg = urb->context;\n\tif (!agg)\n\t\treturn;\n\n\ttp = agg->context;\n\tif (!tp)\n\t\treturn;\n\n\tnetdev = tp->netdev;\n\tstats = &netdev->stats;\n\tif (status) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_warn(netdev, \"Tx status %d\\n\", status);\n\t\tstats->tx_errors += agg->skb_num;\n\t} else {\n\t\tstats->tx_packets += agg->skb_num;\n\t\tstats->tx_bytes += agg->skb_len;\n\t}\n\n\tspin_lock_irqsave(&tp->tx_lock, flags);\n\tlist_add_tail(&agg->list, &tp->tx_free);\n\tspin_unlock_irqrestore(&tp->tx_lock, flags);\n\n\tusb_autopm_put_interface_async(tp->intf);\n\n\tif (!netif_carrier_ok(netdev))\n\t\treturn;\n\n\tif (!test_bit(WORK_ENABLE, &tp->flags))\n\t\treturn;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tif (!skb_queue_empty(&tp->tx_queue))\n\t\ttasklet_schedule(&tp->tx_tl);\n}\n\nstatic void intr_callback(struct urb *urb)\n{\n\tstruct r8152 *tp;\n\t__le16 *d;\n\tint status = urb->status;\n\tint res;\n\n\ttp = urb->context;\n\tif (!tp)\n\t\treturn;\n\n\tif (!test_bit(WORK_ENABLE, &tp->flags))\n\t\treturn;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tswitch (status) {\n\tcase 0:\t\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ESHUTDOWN:\n\t\tnetif_device_detach(tp->netdev);\n\t\tfallthrough;\n\tcase -ENOENT:\n\tcase -EPROTO:\n\t\tnetif_info(tp, intr, tp->netdev,\n\t\t\t   \"Stop submitting intr, status %d\\n\", status);\n\t\treturn;\n\tcase -EOVERFLOW:\n\t\tif (net_ratelimit())\n\t\t\tnetif_info(tp, intr, tp->netdev,\n\t\t\t\t   \"intr status -EOVERFLOW\\n\");\n\t\tgoto resubmit;\n\t \n\tdefault:\n\t\tnetif_info(tp, intr, tp->netdev, \"intr status %d\\n\", status);\n\t\tgoto resubmit;\n\t}\n\n\td = urb->transfer_buffer;\n\tif (INTR_LINK & __le16_to_cpu(d[0])) {\n\t\tif (!netif_carrier_ok(tp->netdev)) {\n\t\t\tset_bit(RTL8152_LINK_CHG, &tp->flags);\n\t\t\tschedule_delayed_work(&tp->schedule, 0);\n\t\t}\n\t} else {\n\t\tif (netif_carrier_ok(tp->netdev)) {\n\t\t\tnetif_stop_queue(tp->netdev);\n\t\t\tset_bit(RTL8152_LINK_CHG, &tp->flags);\n\t\t\tschedule_delayed_work(&tp->schedule, 0);\n\t\t}\n\t}\n\nresubmit:\n\tres = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (res == -ENODEV) {\n\t\trtl_set_unplug(tp);\n\t\tnetif_device_detach(tp->netdev);\n\t} else if (res) {\n\t\tnetif_err(tp, intr, tp->netdev,\n\t\t\t  \"can't resubmit intr, status %d\\n\", res);\n\t}\n}\n\nstatic inline void *rx_agg_align(void *data)\n{\n\treturn (void *)ALIGN((uintptr_t)data, RX_ALIGN);\n}\n\nstatic inline void *tx_agg_align(void *data)\n{\n\treturn (void *)ALIGN((uintptr_t)data, TX_ALIGN);\n}\n\nstatic void free_rx_agg(struct r8152 *tp, struct rx_agg *agg)\n{\n\tlist_del(&agg->info_list);\n\n\tusb_free_urb(agg->urb);\n\tput_page(agg->page);\n\tkfree(agg);\n\n\tatomic_dec(&tp->rx_count);\n}\n\nstatic struct rx_agg *alloc_rx_agg(struct r8152 *tp, gfp_t mflags)\n{\n\tstruct net_device *netdev = tp->netdev;\n\tint node = netdev->dev.parent ? dev_to_node(netdev->dev.parent) : -1;\n\tunsigned int order = get_order(tp->rx_buf_sz);\n\tstruct rx_agg *rx_agg;\n\tunsigned long flags;\n\n\trx_agg = kmalloc_node(sizeof(*rx_agg), mflags, node);\n\tif (!rx_agg)\n\t\treturn NULL;\n\n\trx_agg->page = alloc_pages(mflags | __GFP_COMP | __GFP_NOWARN, order);\n\tif (!rx_agg->page)\n\t\tgoto free_rx;\n\n\trx_agg->buffer = page_address(rx_agg->page);\n\n\trx_agg->urb = usb_alloc_urb(0, mflags);\n\tif (!rx_agg->urb)\n\t\tgoto free_buf;\n\n\trx_agg->context = tp;\n\n\tINIT_LIST_HEAD(&rx_agg->list);\n\tINIT_LIST_HEAD(&rx_agg->info_list);\n\tspin_lock_irqsave(&tp->rx_lock, flags);\n\tlist_add_tail(&rx_agg->info_list, &tp->rx_info);\n\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\n\tatomic_inc(&tp->rx_count);\n\n\treturn rx_agg;\n\nfree_buf:\n\t__free_pages(rx_agg->page, order);\nfree_rx:\n\tkfree(rx_agg);\n\treturn NULL;\n}\n\nstatic void free_all_mem(struct r8152 *tp)\n{\n\tstruct rx_agg *agg, *agg_next;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&tp->rx_lock, flags);\n\n\tlist_for_each_entry_safe(agg, agg_next, &tp->rx_info, info_list)\n\t\tfree_rx_agg(tp, agg);\n\n\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\n\tWARN_ON(atomic_read(&tp->rx_count));\n\n\tfor (i = 0; i < RTL8152_MAX_TX; i++) {\n\t\tusb_free_urb(tp->tx_info[i].urb);\n\t\ttp->tx_info[i].urb = NULL;\n\n\t\tkfree(tp->tx_info[i].buffer);\n\t\ttp->tx_info[i].buffer = NULL;\n\t\ttp->tx_info[i].head = NULL;\n\t}\n\n\tusb_free_urb(tp->intr_urb);\n\ttp->intr_urb = NULL;\n\n\tkfree(tp->intr_buff);\n\ttp->intr_buff = NULL;\n}\n\nstatic int alloc_all_mem(struct r8152 *tp)\n{\n\tstruct net_device *netdev = tp->netdev;\n\tstruct usb_interface *intf = tp->intf;\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tstruct usb_host_endpoint *ep_intr = alt->endpoint + 2;\n\tint node, i;\n\n\tnode = netdev->dev.parent ? dev_to_node(netdev->dev.parent) : -1;\n\n\tspin_lock_init(&tp->rx_lock);\n\tspin_lock_init(&tp->tx_lock);\n\tINIT_LIST_HEAD(&tp->rx_info);\n\tINIT_LIST_HEAD(&tp->tx_free);\n\tINIT_LIST_HEAD(&tp->rx_done);\n\tskb_queue_head_init(&tp->tx_queue);\n\tskb_queue_head_init(&tp->rx_queue);\n\tatomic_set(&tp->rx_count, 0);\n\n\tfor (i = 0; i < RTL8152_MAX_RX; i++) {\n\t\tif (!alloc_rx_agg(tp, GFP_KERNEL))\n\t\t\tgoto err1;\n\t}\n\n\tfor (i = 0; i < RTL8152_MAX_TX; i++) {\n\t\tstruct urb *urb;\n\t\tu8 *buf;\n\n\t\tbuf = kmalloc_node(agg_buf_sz, GFP_KERNEL, node);\n\t\tif (!buf)\n\t\t\tgoto err1;\n\n\t\tif (buf != tx_agg_align(buf)) {\n\t\t\tkfree(buf);\n\t\t\tbuf = kmalloc_node(agg_buf_sz + TX_ALIGN, GFP_KERNEL,\n\t\t\t\t\t   node);\n\t\t\tif (!buf)\n\t\t\t\tgoto err1;\n\t\t}\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tkfree(buf);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&tp->tx_info[i].list);\n\t\ttp->tx_info[i].context = tp;\n\t\ttp->tx_info[i].urb = urb;\n\t\ttp->tx_info[i].buffer = buf;\n\t\ttp->tx_info[i].head = tx_agg_align(buf);\n\n\t\tlist_add_tail(&tp->tx_info[i].list, &tp->tx_free);\n\t}\n\n\ttp->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!tp->intr_urb)\n\t\tgoto err1;\n\n\ttp->intr_buff = kmalloc(INTBUFSIZE, GFP_KERNEL);\n\tif (!tp->intr_buff)\n\t\tgoto err1;\n\n\ttp->intr_interval = (int)ep_intr->desc.bInterval;\n\tusb_fill_int_urb(tp->intr_urb, tp->udev, tp->pipe_intr,\n\t\t\t tp->intr_buff, INTBUFSIZE, intr_callback,\n\t\t\t tp, tp->intr_interval);\n\n\treturn 0;\n\nerr1:\n\tfree_all_mem(tp);\n\treturn -ENOMEM;\n}\n\nstatic struct tx_agg *r8152_get_tx_agg(struct r8152 *tp)\n{\n\tstruct tx_agg *agg = NULL;\n\tunsigned long flags;\n\n\tif (list_empty(&tp->tx_free))\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&tp->tx_lock, flags);\n\tif (!list_empty(&tp->tx_free)) {\n\t\tstruct list_head *cursor;\n\n\t\tcursor = tp->tx_free.next;\n\t\tlist_del_init(cursor);\n\t\tagg = list_entry(cursor, struct tx_agg, list);\n\t}\n\tspin_unlock_irqrestore(&tp->tx_lock, flags);\n\n\treturn agg;\n}\n\n \nstatic void r8152_csum_workaround(struct r8152 *tp, struct sk_buff *skb,\n\t\t\t\t  struct sk_buff_head *list)\n{\n\tif (skb_shinfo(skb)->gso_size) {\n\t\tnetdev_features_t features = tp->netdev->features;\n\t\tstruct sk_buff *segs, *seg, *next;\n\t\tstruct sk_buff_head seg_list;\n\n\t\tfeatures &= ~(NETIF_F_SG | NETIF_F_IPV6_CSUM | NETIF_F_TSO6);\n\t\tsegs = skb_gso_segment(skb, features);\n\t\tif (IS_ERR(segs) || !segs)\n\t\t\tgoto drop;\n\n\t\t__skb_queue_head_init(&seg_list);\n\n\t\tskb_list_walk_safe(segs, seg, next) {\n\t\t\tskb_mark_not_on_list(seg);\n\t\t\t__skb_queue_tail(&seg_list, seg);\n\t\t}\n\n\t\tskb_queue_splice(&seg_list, list);\n\t\tdev_kfree_skb(skb);\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tif (skb_checksum_help(skb) < 0)\n\t\t\tgoto drop;\n\n\t\t__skb_queue_head(list, skb);\n\t} else {\n\t\tstruct net_device_stats *stats;\n\ndrop:\n\t\tstats = &tp->netdev->stats;\n\t\tstats->tx_dropped++;\n\t\tdev_kfree_skb(skb);\n\t}\n}\n\nstatic inline void rtl_tx_vlan_tag(struct tx_desc *desc, struct sk_buff *skb)\n{\n\tif (skb_vlan_tag_present(skb)) {\n\t\tu32 opts2;\n\n\t\topts2 = TX_VLAN_TAG | swab16(skb_vlan_tag_get(skb));\n\t\tdesc->opts2 |= cpu_to_le32(opts2);\n\t}\n}\n\nstatic inline void rtl_rx_vlan_tag(struct rx_desc *desc, struct sk_buff *skb)\n{\n\tu32 opts2 = le32_to_cpu(desc->opts2);\n\n\tif (opts2 & RX_VLAN_TAG)\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\n\t\t\t\t       swab16(opts2 & 0xffff));\n}\n\nstatic int r8152_tx_csum(struct r8152 *tp, struct tx_desc *desc,\n\t\t\t struct sk_buff *skb, u32 len)\n{\n\tu32 mss = skb_shinfo(skb)->gso_size;\n\tu32 opts1, opts2 = 0;\n\tint ret = TX_CSUM_SUCCESS;\n\n\tWARN_ON_ONCE(len > TX_LEN_MAX);\n\n\topts1 = len | TX_FS | TX_LS;\n\n\tif (mss) {\n\t\tu32 transport_offset = (u32)skb_transport_offset(skb);\n\n\t\tif (transport_offset > GTTCPHO_MAX) {\n\t\t\tnetif_warn(tp, tx_err, tp->netdev,\n\t\t\t\t   \"Invalid transport offset 0x%x for TSO\\n\",\n\t\t\t\t   transport_offset);\n\t\t\tret = TX_CSUM_TSO;\n\t\t\tgoto unavailable;\n\t\t}\n\n\t\tswitch (vlan_get_protocol(skb)) {\n\t\tcase htons(ETH_P_IP):\n\t\t\topts1 |= GTSENDV4;\n\t\t\tbreak;\n\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tif (skb_cow_head(skb, 0)) {\n\t\t\t\tret = TX_CSUM_TSO;\n\t\t\t\tgoto unavailable;\n\t\t\t}\n\t\t\ttcp_v6_gso_csum_prep(skb);\n\t\t\topts1 |= GTSENDV6;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tbreak;\n\t\t}\n\n\t\topts1 |= transport_offset << GTTCPHO_SHIFT;\n\t\topts2 |= min(mss, MSS_MAX) << MSS_SHIFT;\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tu32 transport_offset = (u32)skb_transport_offset(skb);\n\t\tu8 ip_protocol;\n\n\t\tif (transport_offset > TCPHO_MAX) {\n\t\t\tnetif_warn(tp, tx_err, tp->netdev,\n\t\t\t\t   \"Invalid transport offset 0x%x\\n\",\n\t\t\t\t   transport_offset);\n\t\t\tret = TX_CSUM_NONE;\n\t\t\tgoto unavailable;\n\t\t}\n\n\t\tswitch (vlan_get_protocol(skb)) {\n\t\tcase htons(ETH_P_IP):\n\t\t\topts2 |= IPV4_CS;\n\t\t\tip_protocol = ip_hdr(skb)->protocol;\n\t\t\tbreak;\n\n\t\tcase htons(ETH_P_IPV6):\n\t\t\topts2 |= IPV6_CS;\n\t\t\tip_protocol = ipv6_hdr(skb)->nexthdr;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tip_protocol = IPPROTO_RAW;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ip_protocol == IPPROTO_TCP)\n\t\t\topts2 |= TCP_CS;\n\t\telse if (ip_protocol == IPPROTO_UDP)\n\t\t\topts2 |= UDP_CS;\n\t\telse\n\t\t\tWARN_ON_ONCE(1);\n\n\t\topts2 |= transport_offset << TCPHO_SHIFT;\n\t}\n\n\tdesc->opts2 = cpu_to_le32(opts2);\n\tdesc->opts1 = cpu_to_le32(opts1);\n\nunavailable:\n\treturn ret;\n}\n\nstatic int r8152_tx_agg_fill(struct r8152 *tp, struct tx_agg *agg)\n{\n\tstruct sk_buff_head skb_head, *tx_queue = &tp->tx_queue;\n\tint remain, ret;\n\tu8 *tx_data;\n\n\t__skb_queue_head_init(&skb_head);\n\tspin_lock(&tx_queue->lock);\n\tskb_queue_splice_init(tx_queue, &skb_head);\n\tspin_unlock(&tx_queue->lock);\n\n\ttx_data = agg->head;\n\tagg->skb_num = 0;\n\tagg->skb_len = 0;\n\tremain = agg_buf_sz;\n\n\twhile (remain >= ETH_ZLEN + sizeof(struct tx_desc)) {\n\t\tstruct tx_desc *tx_desc;\n\t\tstruct sk_buff *skb;\n\t\tunsigned int len;\n\n\t\tskb = __skb_dequeue(&skb_head);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tlen = skb->len + sizeof(*tx_desc);\n\n\t\tif (len > remain) {\n\t\t\t__skb_queue_head(&skb_head, skb);\n\t\t\tbreak;\n\t\t}\n\n\t\ttx_data = tx_agg_align(tx_data);\n\t\ttx_desc = (struct tx_desc *)tx_data;\n\n\t\tif (r8152_tx_csum(tp, tx_desc, skb, skb->len)) {\n\t\t\tr8152_csum_workaround(tp, skb, &skb_head);\n\t\t\tcontinue;\n\t\t}\n\n\t\trtl_tx_vlan_tag(tx_desc, skb);\n\n\t\ttx_data += sizeof(*tx_desc);\n\n\t\tlen = skb->len;\n\t\tif (skb_copy_bits(skb, 0, tx_data, len) < 0) {\n\t\t\tstruct net_device_stats *stats = &tp->netdev->stats;\n\n\t\t\tstats->tx_dropped++;\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\ttx_data -= sizeof(*tx_desc);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttx_data += len;\n\t\tagg->skb_len += len;\n\t\tagg->skb_num += skb_shinfo(skb)->gso_segs ?: 1;\n\n\t\tdev_kfree_skb_any(skb);\n\n\t\tremain = agg_buf_sz - (int)(tx_agg_align(tx_data) - agg->head);\n\n\t\tif (tp->dell_tb_rx_agg_bug)\n\t\t\tbreak;\n\t}\n\n\tif (!skb_queue_empty(&skb_head)) {\n\t\tspin_lock(&tx_queue->lock);\n\t\tskb_queue_splice(&skb_head, tx_queue);\n\t\tspin_unlock(&tx_queue->lock);\n\t}\n\n\tnetif_tx_lock(tp->netdev);\n\n\tif (netif_queue_stopped(tp->netdev) &&\n\t    skb_queue_len(&tp->tx_queue) < tp->tx_qlen)\n\t\tnetif_wake_queue(tp->netdev);\n\n\tnetif_tx_unlock(tp->netdev);\n\n\tret = usb_autopm_get_interface_async(tp->intf);\n\tif (ret < 0)\n\t\tgoto out_tx_fill;\n\n\tusb_fill_bulk_urb(agg->urb, tp->udev, tp->pipe_out,\n\t\t\t  agg->head, (int)(tx_data - (u8 *)agg->head),\n\t\t\t  (usb_complete_t)write_bulk_callback, agg);\n\n\tret = usb_submit_urb(agg->urb, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tusb_autopm_put_interface_async(tp->intf);\n\nout_tx_fill:\n\treturn ret;\n}\n\nstatic u8 r8152_rx_csum(struct r8152 *tp, struct rx_desc *rx_desc)\n{\n\tu8 checksum = CHECKSUM_NONE;\n\tu32 opts2, opts3;\n\n\tif (!(tp->netdev->features & NETIF_F_RXCSUM))\n\t\tgoto return_result;\n\n\topts2 = le32_to_cpu(rx_desc->opts2);\n\topts3 = le32_to_cpu(rx_desc->opts3);\n\n\tif (opts2 & RD_IPV4_CS) {\n\t\tif (opts3 & IPF)\n\t\t\tchecksum = CHECKSUM_NONE;\n\t\telse if ((opts2 & RD_UDP_CS) && !(opts3 & UDPF))\n\t\t\tchecksum = CHECKSUM_UNNECESSARY;\n\t\telse if ((opts2 & RD_TCP_CS) && !(opts3 & TCPF))\n\t\t\tchecksum = CHECKSUM_UNNECESSARY;\n\t} else if (opts2 & RD_IPV6_CS) {\n\t\tif ((opts2 & RD_UDP_CS) && !(opts3 & UDPF))\n\t\t\tchecksum = CHECKSUM_UNNECESSARY;\n\t\telse if ((opts2 & RD_TCP_CS) && !(opts3 & TCPF))\n\t\t\tchecksum = CHECKSUM_UNNECESSARY;\n\t}\n\nreturn_result:\n\treturn checksum;\n}\n\nstatic inline bool rx_count_exceed(struct r8152 *tp)\n{\n\treturn atomic_read(&tp->rx_count) > RTL8152_MAX_RX;\n}\n\nstatic inline int agg_offset(struct rx_agg *agg, void *addr)\n{\n\treturn (int)(addr - agg->buffer);\n}\n\nstatic struct rx_agg *rtl_get_free_rx(struct r8152 *tp, gfp_t mflags)\n{\n\tstruct rx_agg *agg, *agg_next, *agg_free = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tp->rx_lock, flags);\n\n\tlist_for_each_entry_safe(agg, agg_next, &tp->rx_used, list) {\n\t\tif (page_count(agg->page) == 1) {\n\t\t\tif (!agg_free) {\n\t\t\t\tlist_del_init(&agg->list);\n\t\t\t\tagg_free = agg;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rx_count_exceed(tp)) {\n\t\t\t\tlist_del_init(&agg->list);\n\t\t\t\tfree_rx_agg(tp, agg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\n\tif (!agg_free && atomic_read(&tp->rx_count) < tp->rx_pending)\n\t\tagg_free = alloc_rx_agg(tp, mflags);\n\n\treturn agg_free;\n}\n\nstatic int rx_bottom(struct r8152 *tp, int budget)\n{\n\tunsigned long flags;\n\tstruct list_head *cursor, *next, rx_queue;\n\tint ret = 0, work_done = 0;\n\tstruct napi_struct *napi = &tp->napi;\n\n\tif (!skb_queue_empty(&tp->rx_queue)) {\n\t\twhile (work_done < budget) {\n\t\t\tstruct sk_buff *skb = __skb_dequeue(&tp->rx_queue);\n\t\t\tstruct net_device *netdev = tp->netdev;\n\t\t\tstruct net_device_stats *stats = &netdev->stats;\n\t\t\tunsigned int pkt_len;\n\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\n\t\t\tpkt_len = skb->len;\n\t\t\tnapi_gro_receive(napi, skb);\n\t\t\twork_done++;\n\t\t\tstats->rx_packets++;\n\t\t\tstats->rx_bytes += pkt_len;\n\t\t}\n\t}\n\n\tif (list_empty(&tp->rx_done) || work_done >= budget)\n\t\tgoto out1;\n\n\tclear_bit(RX_EPROTO, &tp->flags);\n\tINIT_LIST_HEAD(&rx_queue);\n\tspin_lock_irqsave(&tp->rx_lock, flags);\n\tlist_splice_init(&tp->rx_done, &rx_queue);\n\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\n\tlist_for_each_safe(cursor, next, &rx_queue) {\n\t\tstruct rx_desc *rx_desc;\n\t\tstruct rx_agg *agg, *agg_free;\n\t\tint len_used = 0;\n\t\tstruct urb *urb;\n\t\tu8 *rx_data;\n\n\t\t \n\t\tif (work_done >= budget)\n\t\t\tbreak;\n\n\t\tlist_del_init(cursor);\n\n\t\tagg = list_entry(cursor, struct rx_agg, list);\n\t\turb = agg->urb;\n\t\tif (urb->status != 0 || urb->actual_length < ETH_ZLEN)\n\t\t\tgoto submit;\n\n\t\tagg_free = rtl_get_free_rx(tp, GFP_ATOMIC);\n\n\t\trx_desc = agg->buffer;\n\t\trx_data = agg->buffer;\n\t\tlen_used += sizeof(struct rx_desc);\n\n\t\twhile (urb->actual_length > len_used) {\n\t\t\tstruct net_device *netdev = tp->netdev;\n\t\t\tstruct net_device_stats *stats = &netdev->stats;\n\t\t\tunsigned int pkt_len, rx_frag_head_sz;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tWARN_ON_ONCE(skb_queue_len(&tp->rx_queue) >= 1000);\n\n\t\t\tpkt_len = le32_to_cpu(rx_desc->opts1) & RX_LEN_MASK;\n\t\t\tif (pkt_len < ETH_ZLEN)\n\t\t\t\tbreak;\n\n\t\t\tlen_used += pkt_len;\n\t\t\tif (urb->actual_length < len_used)\n\t\t\t\tbreak;\n\n\t\t\tpkt_len -= ETH_FCS_LEN;\n\t\t\trx_data += sizeof(struct rx_desc);\n\n\t\t\tif (!agg_free || tp->rx_copybreak > pkt_len)\n\t\t\t\trx_frag_head_sz = pkt_len;\n\t\t\telse\n\t\t\t\trx_frag_head_sz = tp->rx_copybreak;\n\n\t\t\tskb = napi_alloc_skb(napi, rx_frag_head_sz);\n\t\t\tif (!skb) {\n\t\t\t\tstats->rx_dropped++;\n\t\t\t\tgoto find_next_rx;\n\t\t\t}\n\n\t\t\tskb->ip_summed = r8152_rx_csum(tp, rx_desc);\n\t\t\tmemcpy(skb->data, rx_data, rx_frag_head_sz);\n\t\t\tskb_put(skb, rx_frag_head_sz);\n\t\t\tpkt_len -= rx_frag_head_sz;\n\t\t\trx_data += rx_frag_head_sz;\n\t\t\tif (pkt_len) {\n\t\t\t\tskb_add_rx_frag(skb, 0, agg->page,\n\t\t\t\t\t\tagg_offset(agg, rx_data),\n\t\t\t\t\t\tpkt_len,\n\t\t\t\t\t\tSKB_DATA_ALIGN(pkt_len));\n\t\t\t\tget_page(agg->page);\n\t\t\t}\n\n\t\t\tskb->protocol = eth_type_trans(skb, netdev);\n\t\t\trtl_rx_vlan_tag(rx_desc, skb);\n\t\t\tif (work_done < budget) {\n\t\t\t\twork_done++;\n\t\t\t\tstats->rx_packets++;\n\t\t\t\tstats->rx_bytes += skb->len;\n\t\t\t\tnapi_gro_receive(napi, skb);\n\t\t\t} else {\n\t\t\t\t__skb_queue_tail(&tp->rx_queue, skb);\n\t\t\t}\n\nfind_next_rx:\n\t\t\trx_data = rx_agg_align(rx_data + pkt_len + ETH_FCS_LEN);\n\t\t\trx_desc = (struct rx_desc *)rx_data;\n\t\t\tlen_used = agg_offset(agg, rx_data);\n\t\t\tlen_used += sizeof(struct rx_desc);\n\t\t}\n\n\t\tWARN_ON(!agg_free && page_count(agg->page) > 1);\n\n\t\tif (agg_free) {\n\t\t\tspin_lock_irqsave(&tp->rx_lock, flags);\n\t\t\tif (page_count(agg->page) == 1) {\n\t\t\t\tlist_add(&agg_free->list, &tp->rx_used);\n\t\t\t} else {\n\t\t\t\tlist_add_tail(&agg->list, &tp->rx_used);\n\t\t\t\tagg = agg_free;\n\t\t\t\turb = agg->urb;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\t\t}\n\nsubmit:\n\t\tif (!ret) {\n\t\t\tret = r8152_submit_rx(tp, agg, GFP_ATOMIC);\n\t\t} else {\n\t\t\turb->actual_length = 0;\n\t\t\tlist_add_tail(&agg->list, next);\n\t\t}\n\t}\n\n\t \n\tif (!list_empty(&rx_queue)) {\n\t\tspin_lock_irqsave(&tp->rx_lock, flags);\n\t\tlist_splice(&rx_queue, &tp->rx_done);\n\t\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\t}\n\nout1:\n\treturn work_done;\n}\n\nstatic void tx_bottom(struct r8152 *tp)\n{\n\tint res;\n\n\tdo {\n\t\tstruct net_device *netdev = tp->netdev;\n\t\tstruct tx_agg *agg;\n\n\t\tif (skb_queue_empty(&tp->tx_queue))\n\t\t\tbreak;\n\n\t\tagg = r8152_get_tx_agg(tp);\n\t\tif (!agg)\n\t\t\tbreak;\n\n\t\tres = r8152_tx_agg_fill(tp, agg);\n\t\tif (!res)\n\t\t\tcontinue;\n\n\t\tif (res == -ENODEV) {\n\t\t\trtl_set_unplug(tp);\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tstruct net_device_stats *stats = &netdev->stats;\n\t\t\tunsigned long flags;\n\n\t\t\tnetif_warn(tp, tx_err, netdev,\n\t\t\t\t   \"failed tx_urb %d\\n\", res);\n\t\t\tstats->tx_dropped += agg->skb_num;\n\n\t\t\tspin_lock_irqsave(&tp->tx_lock, flags);\n\t\t\tlist_add_tail(&agg->list, &tp->tx_free);\n\t\t\tspin_unlock_irqrestore(&tp->tx_lock, flags);\n\t\t}\n\t} while (res == 0);\n}\n\nstatic void bottom_half(struct tasklet_struct *t)\n{\n\tstruct r8152 *tp = from_tasklet(tp, t, tx_tl);\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tif (!test_bit(WORK_ENABLE, &tp->flags))\n\t\treturn;\n\n\t \n\t \n\tif (!netif_carrier_ok(tp->netdev))\n\t\treturn;\n\n\tclear_bit(SCHEDULE_TASKLET, &tp->flags);\n\n\ttx_bottom(tp);\n}\n\nstatic int r8152_poll(struct napi_struct *napi, int budget)\n{\n\tstruct r8152 *tp = container_of(napi, struct r8152, napi);\n\tint work_done;\n\n\tif (!budget)\n\t\treturn 0;\n\n\twork_done = rx_bottom(tp, budget);\n\n\tif (work_done < budget) {\n\t\tif (!napi_complete_done(napi, work_done))\n\t\t\tgoto out;\n\t\tif (!list_empty(&tp->rx_done))\n\t\t\tnapi_schedule(napi);\n\t}\n\nout:\n\treturn work_done;\n}\n\nstatic\nint r8152_submit_rx(struct r8152 *tp, struct rx_agg *agg, gfp_t mem_flags)\n{\n\tint ret;\n\n\t \n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags) ||\n\t    !test_bit(WORK_ENABLE, &tp->flags) || !netif_carrier_ok(tp->netdev))\n\t\treturn 0;\n\n\tusb_fill_bulk_urb(agg->urb, tp->udev, tp->pipe_in,\n\t\t\t  agg->buffer, tp->rx_buf_sz,\n\t\t\t  (usb_complete_t)read_bulk_callback, agg);\n\n\tret = usb_submit_urb(agg->urb, mem_flags);\n\tif (ret == -ENODEV) {\n\t\trtl_set_unplug(tp);\n\t\tnetif_device_detach(tp->netdev);\n\t} else if (ret) {\n\t\tstruct urb *urb = agg->urb;\n\t\tunsigned long flags;\n\n\t\turb->actual_length = 0;\n\t\tspin_lock_irqsave(&tp->rx_lock, flags);\n\t\tlist_add_tail(&agg->list, &tp->rx_done);\n\t\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\n\t\tnetif_err(tp, rx_err, tp->netdev,\n\t\t\t  \"Couldn't submit rx[%p], ret = %d\\n\", agg, ret);\n\n\t\tnapi_schedule(&tp->napi);\n\t}\n\n\treturn ret;\n}\n\nstatic void rtl_drop_queued_tx(struct r8152 *tp)\n{\n\tstruct net_device_stats *stats = &tp->netdev->stats;\n\tstruct sk_buff_head skb_head, *tx_queue = &tp->tx_queue;\n\tstruct sk_buff *skb;\n\n\tif (skb_queue_empty(tx_queue))\n\t\treturn;\n\n\t__skb_queue_head_init(&skb_head);\n\tspin_lock_bh(&tx_queue->lock);\n\tskb_queue_splice_init(tx_queue, &skb_head);\n\tspin_unlock_bh(&tx_queue->lock);\n\n\twhile ((skb = __skb_dequeue(&skb_head))) {\n\t\tdev_kfree_skb(skb);\n\t\tstats->tx_dropped++;\n\t}\n}\n\nstatic void rtl8152_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\n\tnetif_warn(tp, tx_err, netdev, \"Tx timeout\\n\");\n\n\tusb_queue_reset_device(tp->intf);\n}\n\nstatic void rtl8152_set_rx_mode(struct net_device *netdev)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\n\tif (netif_carrier_ok(netdev)) {\n\t\tset_bit(RTL8152_SET_RX_MODE, &tp->flags);\n\t\tschedule_delayed_work(&tp->schedule, 0);\n\t}\n}\n\nstatic void _rtl8152_set_rx_mode(struct net_device *netdev)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\tu32 mc_filter[2];\t \n\t__le32 tmp[2];\n\tu32 ocp_data;\n\n\tnetif_stop_queue(netdev);\n\tocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\n\tocp_data &= ~RCR_ACPT_ALL;\n\tocp_data |= RCR_AB | RCR_APM;\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\t \n\t\tnetif_notice(tp, link, netdev, \"Promiscuous mode enabled\\n\");\n\t\tocp_data |= RCR_AM | RCR_AAP;\n\t\tmc_filter[1] = 0xffffffff;\n\t\tmc_filter[0] = 0xffffffff;\n\t} else if ((netdev->flags & IFF_MULTICAST &&\n\t\t\t\tnetdev_mc_count(netdev) > multicast_filter_limit) ||\n\t\t\t   (netdev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\tocp_data |= RCR_AM;\n\t\tmc_filter[1] = 0xffffffff;\n\t\tmc_filter[0] = 0xffffffff;\n\t} else {\n\t\tmc_filter[1] = 0;\n\t\tmc_filter[0] = 0;\n\n\t\tif (netdev->flags & IFF_MULTICAST) {\n\t\t\tstruct netdev_hw_addr *ha;\n\n\t\t\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\t\t\tint bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\n\t\t\t\tmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\n\t\t\t\tocp_data |= RCR_AM;\n\t\t\t}\n\t\t}\n\t}\n\n\ttmp[0] = __cpu_to_le32(swab32(mc_filter[1]));\n\ttmp[1] = __cpu_to_le32(swab32(mc_filter[0]));\n\n\tpla_ocp_write(tp, PLA_MAR, BYTE_EN_DWORD, sizeof(tmp), tmp);\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\n\tnetif_wake_queue(netdev);\n}\n\nstatic netdev_features_t\nrtl8152_features_check(struct sk_buff *skb, struct net_device *dev,\n\t\t       netdev_features_t features)\n{\n\tu32 mss = skb_shinfo(skb)->gso_size;\n\tint max_offset = mss ? GTTCPHO_MAX : TCPHO_MAX;\n\n\tif ((mss || skb->ip_summed == CHECKSUM_PARTIAL) &&\n\t    skb_transport_offset(skb) > max_offset)\n\t\tfeatures &= ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n\telse if ((skb->len + sizeof(struct tx_desc)) > agg_buf_sz)\n\t\tfeatures &= ~NETIF_F_GSO_MASK;\n\n\treturn features;\n}\n\nstatic netdev_tx_t rtl8152_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *netdev)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\n\tskb_tx_timestamp(skb);\n\n\tskb_queue_tail(&tp->tx_queue, skb);\n\n\tif (!list_empty(&tp->tx_free)) {\n\t\tif (test_bit(SELECTIVE_SUSPEND, &tp->flags)) {\n\t\t\tset_bit(SCHEDULE_TASKLET, &tp->flags);\n\t\t\tschedule_delayed_work(&tp->schedule, 0);\n\t\t} else {\n\t\t\tusb_mark_last_busy(tp->udev);\n\t\t\ttasklet_schedule(&tp->tx_tl);\n\t\t}\n\t} else if (skb_queue_len(&tp->tx_queue) > tp->tx_qlen) {\n\t\tnetif_stop_queue(netdev);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void r8152b_reset_packet_filter(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_FMC);\n\tocp_data &= ~FMC_FCR_MCU_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_FMC, ocp_data);\n\tocp_data |= FMC_FCR_MCU_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_FMC, ocp_data);\n}\n\nstatic void rtl8152_nic_reset(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tint i;\n\n\tswitch (tp->version) {\n\tcase RTL_TEST_01:\n\tcase RTL_VER_10:\n\tcase RTL_VER_11:\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CR);\n\t\tocp_data &= ~CR_TE;\n\t\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, ocp_data);\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_BMU_RESET);\n\t\tocp_data &= ~BMU_RESET_EP_IN;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_BMU_RESET, ocp_data);\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);\n\t\tocp_data |= CDC_ECM_EN;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);\n\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CR);\n\t\tocp_data &= ~CR_RE;\n\t\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, ocp_data);\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_BMU_RESET);\n\t\tocp_data |= BMU_RESET_EP_IN;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_BMU_RESET, ocp_data);\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);\n\t\tocp_data &= ~CDC_ECM_EN;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);\n\t\tbreak;\n\n\tdefault:\n\t\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, CR_RST);\n\n\t\tfor (i = 0; i < 1000; i++) {\n\t\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\t\tbreak;\n\t\t\tif (!(ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CR) & CR_RST))\n\t\t\t\tbreak;\n\t\t\tusleep_range(100, 400);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void set_tx_qlen(struct r8152 *tp)\n{\n\ttp->tx_qlen = agg_buf_sz / (mtu_to_size(tp->netdev->mtu) + sizeof(struct tx_desc));\n}\n\nstatic inline u16 rtl8152_get_speed(struct r8152 *tp)\n{\n\treturn ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHYSTATUS);\n}\n\nstatic void rtl_eee_plus_en(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEEP_CR);\n\tif (enable)\n\t\tocp_data |= EEEP_CR_EEEP_TX;\n\telse\n\t\tocp_data &= ~EEEP_CR_EEEP_TX;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EEEP_CR, ocp_data);\n}\n\nstatic void rtl_set_eee_plus(struct r8152 *tp)\n{\n\tif (rtl8152_get_speed(tp) & _10bps)\n\t\trtl_eee_plus_en(tp, true);\n\telse\n\t\trtl_eee_plus_en(tp, false);\n}\n\nstatic void rxdy_gated_en(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MISC_1);\n\tif (enable)\n\t\tocp_data |= RXDY_GATED_EN;\n\telse\n\t\tocp_data &= ~RXDY_GATED_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MISC_1, ocp_data);\n}\n\nstatic int rtl_start_rx(struct r8152 *tp)\n{\n\tstruct rx_agg *agg, *agg_next;\n\tstruct list_head tmp_list;\n\tunsigned long flags;\n\tint ret = 0, i = 0;\n\n\tINIT_LIST_HEAD(&tmp_list);\n\n\tspin_lock_irqsave(&tp->rx_lock, flags);\n\n\tINIT_LIST_HEAD(&tp->rx_done);\n\tINIT_LIST_HEAD(&tp->rx_used);\n\n\tlist_splice_init(&tp->rx_info, &tmp_list);\n\n\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\n\tlist_for_each_entry_safe(agg, agg_next, &tmp_list, info_list) {\n\t\tINIT_LIST_HEAD(&agg->list);\n\n\t\t \n\t\tif (++i > RTL8152_MAX_RX) {\n\t\t\tspin_lock_irqsave(&tp->rx_lock, flags);\n\t\t\tlist_add_tail(&agg->list, &tp->rx_used);\n\t\t\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\t\t} else if (unlikely(ret < 0)) {\n\t\t\tspin_lock_irqsave(&tp->rx_lock, flags);\n\t\t\tlist_add_tail(&agg->list, &tp->rx_done);\n\t\t\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\t\t} else {\n\t\t\tret = r8152_submit_rx(tp, agg, GFP_KERNEL);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&tp->rx_lock, flags);\n\tWARN_ON(!list_empty(&tp->rx_info));\n\tlist_splice(&tmp_list, &tp->rx_info);\n\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\n\treturn ret;\n}\n\nstatic int rtl_stop_rx(struct r8152 *tp)\n{\n\tstruct rx_agg *agg, *agg_next;\n\tstruct list_head tmp_list;\n\tunsigned long flags;\n\n\tINIT_LIST_HEAD(&tmp_list);\n\n\t \n\n\tspin_lock_irqsave(&tp->rx_lock, flags);\n\tlist_splice_init(&tp->rx_info, &tmp_list);\n\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\n\tlist_for_each_entry_safe(agg, agg_next, &tmp_list, info_list) {\n\t\t \n\t\tif (page_count(agg->page) > 1)\n\t\t\tfree_rx_agg(tp, agg);\n\t\telse\n\t\t\tusb_kill_urb(agg->urb);\n\t}\n\n\t \n\tspin_lock_irqsave(&tp->rx_lock, flags);\n\tWARN_ON(!list_empty(&tp->rx_info));\n\tlist_splice(&tmp_list, &tp->rx_info);\n\tspin_unlock_irqrestore(&tp->rx_lock, flags);\n\n\twhile (!skb_queue_empty(&tp->rx_queue))\n\t\tdev_kfree_skb(__skb_dequeue(&tp->rx_queue));\n\n\treturn 0;\n}\n\nstatic void rtl_set_ifg(struct r8152 *tp, u16 speed)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR1);\n\tocp_data &= ~IFG_MASK;\n\tif ((speed & (_10bps | _100bps)) && !(speed & FULL_DUP)) {\n\t\tocp_data |= IFG_144NS;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_TCR1, ocp_data);\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4);\n\t\tocp_data &= ~TX10MIDLE_EN;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, ocp_data);\n\t} else {\n\t\tocp_data |= IFG_96NS;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_TCR1, ocp_data);\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4);\n\t\tocp_data |= TX10MIDLE_EN;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, ocp_data);\n\t}\n}\n\nstatic inline void r8153b_rx_agg_chg_indicate(struct r8152 *tp)\n{\n\tocp_write_byte(tp, MCU_TYPE_USB, USB_UPT_RXDMA_OWN,\n\t\t       OWN_UPDATE | OWN_CLEAR);\n}\n\nstatic int rtl_enable(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tr8152b_reset_packet_filter(tp);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CR);\n\tocp_data |= CR_RE | CR_TE;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, ocp_data);\n\n\tswitch (tp->version) {\n\tcase RTL_VER_01:\n\tcase RTL_VER_02:\n\tcase RTL_VER_03:\n\tcase RTL_VER_04:\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\tcase RTL_VER_07:\n\t\tbreak;\n\tdefault:\n\t\tr8153b_rx_agg_chg_indicate(tp);\n\t\tbreak;\n\t}\n\n\trxdy_gated_en(tp, false);\n\n\treturn 0;\n}\n\nstatic int rtl8152_enable(struct r8152 *tp)\n{\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn -ENODEV;\n\n\tset_tx_qlen(tp);\n\trtl_set_eee_plus(tp);\n\n\treturn rtl_enable(tp);\n}\n\nstatic void r8153_set_rx_early_timeout(struct r8152 *tp)\n{\n\tu32 ocp_data = tp->coalesce / 8;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_03:\n\tcase RTL_VER_04:\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_TIMEOUT,\n\t\t\t       ocp_data);\n\t\tbreak;\n\n\tcase RTL_VER_08:\n\tcase RTL_VER_09:\n\tcase RTL_VER_14:\n\t\t \n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_TIMEOUT,\n\t\t\t       128 / 8);\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_RX_EXTRA_AGGR_TMR,\n\t\t\t       ocp_data);\n\t\tbreak;\n\n\tcase RTL_VER_10:\n\tcase RTL_VER_11:\n\tcase RTL_VER_12:\n\tcase RTL_VER_13:\n\tcase RTL_VER_15:\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_TIMEOUT,\n\t\t\t       640 / 8);\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_RX_EXTRA_AGGR_TMR,\n\t\t\t       ocp_data);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void r8153_set_rx_early_size(struct r8152 *tp)\n{\n\tu32 ocp_data = tp->rx_buf_sz - rx_reserved_size(tp->netdev->mtu);\n\n\tswitch (tp->version) {\n\tcase RTL_VER_03:\n\tcase RTL_VER_04:\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_SIZE,\n\t\t\t       ocp_data / 4);\n\t\tbreak;\n\tcase RTL_VER_08:\n\tcase RTL_VER_09:\n\tcase RTL_VER_14:\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_SIZE,\n\t\t\t       ocp_data / 8);\n\t\tbreak;\n\tcase RTL_TEST_01:\n\tcase RTL_VER_10:\n\tcase RTL_VER_11:\n\tcase RTL_VER_12:\n\tcase RTL_VER_13:\n\tcase RTL_VER_15:\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_SIZE,\n\t\t\t       ocp_data / 8);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}\n\nstatic int rtl8153_enable(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn -ENODEV;\n\n\tset_tx_qlen(tp);\n\trtl_set_eee_plus(tp);\n\tr8153_set_rx_early_timeout(tp);\n\tr8153_set_rx_early_size(tp);\n\n\trtl_set_ifg(tp, rtl8152_get_speed(tp));\n\n\tswitch (tp->version) {\n\tcase RTL_VER_09:\n\tcase RTL_VER_14:\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);\n\t\tocp_data &= ~FC_PATCH_TASK;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);\n\t\tusleep_range(1000, 2000);\n\t\tocp_data |= FC_PATCH_TASK;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rtl_enable(tp);\n}\n\nstatic void rtl_disable(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tint i;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags)) {\n\t\trtl_drop_queued_tx(tp);\n\t\treturn;\n\t}\n\n\tocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\n\tocp_data &= ~RCR_ACPT_ALL;\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\n\n\trtl_drop_queued_tx(tp);\n\n\tfor (i = 0; i < RTL8152_MAX_TX; i++)\n\t\tusb_kill_urb(tp->tx_info[i].urb);\n\n\trxdy_gated_en(tp, true);\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\tbreak;\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\n\t\tif ((ocp_data & FIFO_EMPTY) == FIFO_EMPTY)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\tbreak;\n\t\tif (ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0) & TCR0_TX_EMPTY)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\trtl_stop_rx(tp);\n\n\trtl8152_nic_reset(tp);\n}\n\nstatic void r8152_power_cut_en(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_UPS_CTRL);\n\tif (enable)\n\t\tocp_data |= POWER_CUT;\n\telse\n\t\tocp_data &= ~POWER_CUT;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_UPS_CTRL, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_PM_CTRL_STATUS);\n\tocp_data &= ~RESUME_INDICATE;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_PM_CTRL_STATUS, ocp_data);\n}\n\nstatic void rtl_rx_vlan_en(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_01:\n\tcase RTL_VER_02:\n\tcase RTL_VER_03:\n\tcase RTL_VER_04:\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\tcase RTL_VER_07:\n\tcase RTL_VER_08:\n\tcase RTL_VER_09:\n\tcase RTL_VER_14:\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CPCR);\n\t\tif (enable)\n\t\t\tocp_data |= CPCR_RX_VLAN;\n\t\telse\n\t\t\tocp_data &= ~CPCR_RX_VLAN;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_CPCR, ocp_data);\n\t\tbreak;\n\n\tcase RTL_TEST_01:\n\tcase RTL_VER_10:\n\tcase RTL_VER_11:\n\tcase RTL_VER_12:\n\tcase RTL_VER_13:\n\tcase RTL_VER_15:\n\tdefault:\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_RCR1);\n\t\tif (enable)\n\t\t\tocp_data |= OUTER_VLAN | INNER_VLAN;\n\t\telse\n\t\t\tocp_data &= ~(OUTER_VLAN | INNER_VLAN);\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RCR1, ocp_data);\n\t\tbreak;\n\t}\n}\n\nstatic int rtl8152_set_features(struct net_device *dev,\n\t\t\t\tnetdev_features_t features)\n{\n\tnetdev_features_t changed = features ^ dev->features;\n\tstruct r8152 *tp = netdev_priv(dev);\n\tint ret;\n\n\tret = usb_autopm_get_interface(tp->intf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmutex_lock(&tp->control);\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX) {\n\t\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\t\trtl_rx_vlan_en(tp, true);\n\t\telse\n\t\t\trtl_rx_vlan_en(tp, false);\n\t}\n\n\tmutex_unlock(&tp->control);\n\n\tusb_autopm_put_interface(tp->intf);\n\nout:\n\treturn ret;\n}\n\n#define WAKE_ANY (WAKE_PHY | WAKE_MAGIC | WAKE_UCAST | WAKE_BCAST | WAKE_MCAST)\n\nstatic u32 __rtl_get_wol(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tu32 wolopts = 0;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);\n\tif (ocp_data & LINK_ON_WAKE_EN)\n\t\twolopts |= WAKE_PHY;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG5);\n\tif (ocp_data & UWF_EN)\n\t\twolopts |= WAKE_UCAST;\n\tif (ocp_data & BWF_EN)\n\t\twolopts |= WAKE_BCAST;\n\tif (ocp_data & MWF_EN)\n\t\twolopts |= WAKE_MCAST;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CFG_WOL);\n\tif (ocp_data & MAGIC_EN)\n\t\twolopts |= WAKE_MAGIC;\n\n\treturn wolopts;\n}\n\nstatic void __rtl_set_wol(struct r8152 *tp, u32 wolopts)\n{\n\tu32 ocp_data;\n\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);\n\tocp_data &= ~LINK_ON_WAKE_EN;\n\tif (wolopts & WAKE_PHY)\n\t\tocp_data |= LINK_ON_WAKE_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG5);\n\tocp_data &= ~(UWF_EN | BWF_EN | MWF_EN);\n\tif (wolopts & WAKE_UCAST)\n\t\tocp_data |= UWF_EN;\n\tif (wolopts & WAKE_BCAST)\n\t\tocp_data |= BWF_EN;\n\tif (wolopts & WAKE_MCAST)\n\t\tocp_data |= MWF_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG5, ocp_data);\n\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CFG_WOL);\n\tocp_data &= ~MAGIC_EN;\n\tif (wolopts & WAKE_MAGIC)\n\t\tocp_data |= MAGIC_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_CFG_WOL, ocp_data);\n\n\tif (wolopts & WAKE_ANY)\n\t\tdevice_set_wakeup_enable(&tp->udev->dev, true);\n\telse\n\t\tdevice_set_wakeup_enable(&tp->udev->dev, false);\n}\n\nstatic void r8153_mac_clk_speed_down(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL2);\n\n\t \n\tif (enable)\n\t\tocp_data |= MAC_CLK_SPDWN_EN;\n\telse\n\t\tocp_data &= ~MAC_CLK_SPDWN_EN;\n\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL2, ocp_data);\n}\n\nstatic void r8156_mac_clk_spd(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data;\n\n\t \n\tif (enable) {\n\t\t \n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL,\n\t\t\t       0x0403);\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL2);\n\t\tocp_data &= ~EEE_SPDWN_RATIO_MASK;\n\t\tocp_data |= MAC_CLK_SPDWN_EN | 0x03;  \n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL2, ocp_data);\n\t} else {\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL2);\n\t\tocp_data &= ~MAC_CLK_SPDWN_EN;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL2, ocp_data);\n\t}\n}\n\nstatic void r8153_u1u2en(struct r8152 *tp, bool enable)\n{\n\tu8 u1u2[8];\n\n\tif (enable)\n\t\tmemset(u1u2, 0xff, sizeof(u1u2));\n\telse\n\t\tmemset(u1u2, 0x00, sizeof(u1u2));\n\n\tusb_ocp_write(tp, USB_TOLERANCE, BYTE_EN_SIX_BYTES, sizeof(u1u2), u1u2);\n}\n\nstatic void r8153b_u1u2en(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_LPM_CONFIG);\n\tif (enable)\n\t\tocp_data |= LPM_U1U2_EN;\n\telse\n\t\tocp_data &= ~LPM_U1U2_EN;\n\n\tocp_write_word(tp, MCU_TYPE_USB, USB_LPM_CONFIG, ocp_data);\n}\n\nstatic void r8153_u2p3en(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_U2P3_CTRL);\n\tif (enable)\n\t\tocp_data |= U2P3_ENABLE;\n\telse\n\t\tocp_data &= ~U2P3_ENABLE;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_U2P3_CTRL, ocp_data);\n}\n\nstatic void r8153b_ups_flags(struct r8152 *tp)\n{\n\tu32 ups_flags = 0;\n\n\tif (tp->ups_info.green)\n\t\tups_flags |= UPS_FLAGS_EN_GREEN;\n\n\tif (tp->ups_info.aldps)\n\t\tups_flags |= UPS_FLAGS_EN_ALDPS;\n\n\tif (tp->ups_info.eee)\n\t\tups_flags |= UPS_FLAGS_EN_EEE;\n\n\tif (tp->ups_info.flow_control)\n\t\tups_flags |= UPS_FLAGS_EN_FLOW_CTR;\n\n\tif (tp->ups_info.eee_ckdiv)\n\t\tups_flags |= UPS_FLAGS_EN_EEE_CKDIV;\n\n\tif (tp->ups_info.eee_cmod_lv)\n\t\tups_flags |= UPS_FLAGS_EEE_CMOD_LV_EN;\n\n\tif (tp->ups_info.r_tune)\n\t\tups_flags |= UPS_FLAGS_R_TUNE;\n\n\tif (tp->ups_info._10m_ckdiv)\n\t\tups_flags |= UPS_FLAGS_EN_10M_CKDIV;\n\n\tif (tp->ups_info.eee_plloff_100)\n\t\tups_flags |= UPS_FLAGS_EEE_PLLOFF_100;\n\n\tif (tp->ups_info.eee_plloff_giga)\n\t\tups_flags |= UPS_FLAGS_EEE_PLLOFF_GIGA;\n\n\tif (tp->ups_info._250m_ckdiv)\n\t\tups_flags |= UPS_FLAGS_250M_CKDIV;\n\n\tif (tp->ups_info.ctap_short_off)\n\t\tups_flags |= UPS_FLAGS_CTAP_SHORT_DIS;\n\n\tswitch (tp->ups_info.speed_duplex) {\n\tcase NWAY_10M_HALF:\n\t\tups_flags |= ups_flags_speed(1);\n\t\tbreak;\n\tcase NWAY_10M_FULL:\n\t\tups_flags |= ups_flags_speed(2);\n\t\tbreak;\n\tcase NWAY_100M_HALF:\n\t\tups_flags |= ups_flags_speed(3);\n\t\tbreak;\n\tcase NWAY_100M_FULL:\n\t\tups_flags |= ups_flags_speed(4);\n\t\tbreak;\n\tcase NWAY_1000M_FULL:\n\t\tups_flags |= ups_flags_speed(5);\n\t\tbreak;\n\tcase FORCE_10M_HALF:\n\t\tups_flags |= ups_flags_speed(6);\n\t\tbreak;\n\tcase FORCE_10M_FULL:\n\t\tups_flags |= ups_flags_speed(7);\n\t\tbreak;\n\tcase FORCE_100M_HALF:\n\t\tups_flags |= ups_flags_speed(8);\n\t\tbreak;\n\tcase FORCE_100M_FULL:\n\t\tups_flags |= ups_flags_speed(9);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tocp_write_dword(tp, MCU_TYPE_USB, USB_UPS_FLAGS, ups_flags);\n}\n\nstatic void r8156_ups_flags(struct r8152 *tp)\n{\n\tu32 ups_flags = 0;\n\n\tif (tp->ups_info.green)\n\t\tups_flags |= UPS_FLAGS_EN_GREEN;\n\n\tif (tp->ups_info.aldps)\n\t\tups_flags |= UPS_FLAGS_EN_ALDPS;\n\n\tif (tp->ups_info.eee)\n\t\tups_flags |= UPS_FLAGS_EN_EEE;\n\n\tif (tp->ups_info.flow_control)\n\t\tups_flags |= UPS_FLAGS_EN_FLOW_CTR;\n\n\tif (tp->ups_info.eee_ckdiv)\n\t\tups_flags |= UPS_FLAGS_EN_EEE_CKDIV;\n\n\tif (tp->ups_info._10m_ckdiv)\n\t\tups_flags |= UPS_FLAGS_EN_10M_CKDIV;\n\n\tif (tp->ups_info.eee_plloff_100)\n\t\tups_flags |= UPS_FLAGS_EEE_PLLOFF_100;\n\n\tif (tp->ups_info.eee_plloff_giga)\n\t\tups_flags |= UPS_FLAGS_EEE_PLLOFF_GIGA;\n\n\tif (tp->ups_info._250m_ckdiv)\n\t\tups_flags |= UPS_FLAGS_250M_CKDIV;\n\n\tswitch (tp->ups_info.speed_duplex) {\n\tcase FORCE_10M_HALF:\n\t\tups_flags |= ups_flags_speed(0);\n\t\tbreak;\n\tcase FORCE_10M_FULL:\n\t\tups_flags |= ups_flags_speed(1);\n\t\tbreak;\n\tcase FORCE_100M_HALF:\n\t\tups_flags |= ups_flags_speed(2);\n\t\tbreak;\n\tcase FORCE_100M_FULL:\n\t\tups_flags |= ups_flags_speed(3);\n\t\tbreak;\n\tcase NWAY_10M_HALF:\n\t\tups_flags |= ups_flags_speed(4);\n\t\tbreak;\n\tcase NWAY_10M_FULL:\n\t\tups_flags |= ups_flags_speed(5);\n\t\tbreak;\n\tcase NWAY_100M_HALF:\n\t\tups_flags |= ups_flags_speed(6);\n\t\tbreak;\n\tcase NWAY_100M_FULL:\n\t\tups_flags |= ups_flags_speed(7);\n\t\tbreak;\n\tcase NWAY_1000M_FULL:\n\t\tups_flags |= ups_flags_speed(8);\n\t\tbreak;\n\tcase NWAY_2500M_FULL:\n\t\tups_flags |= ups_flags_speed(9);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (tp->ups_info.lite_mode) {\n\tcase 1:\n\t\tups_flags |= 0 << 5;\n\t\tbreak;\n\tcase 2:\n\t\tups_flags |= 2 << 5;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tups_flags |= 1 << 5;\n\t\tbreak;\n\t}\n\n\tocp_write_dword(tp, MCU_TYPE_USB, USB_UPS_FLAGS, ups_flags);\n}\n\nstatic void rtl_green_en(struct r8152 *tp, bool enable)\n{\n\tu16 data;\n\n\tdata = sram_read(tp, SRAM_GREEN_CFG);\n\tif (enable)\n\t\tdata |= GREEN_ETH_EN;\n\telse\n\t\tdata &= ~GREEN_ETH_EN;\n\tsram_write(tp, SRAM_GREEN_CFG, data);\n\n\ttp->ups_info.green = enable;\n}\n\nstatic void r8153b_green_en(struct r8152 *tp, bool enable)\n{\n\tif (enable) {\n\t\tsram_write(tp, 0x8045, 0);\t \n\t\tsram_write(tp, 0x804d, 0x1222);\t \n\t\tsram_write(tp, 0x805d, 0x0022);\t \n\t} else {\n\t\tsram_write(tp, 0x8045, 0x2444);\t \n\t\tsram_write(tp, 0x804d, 0x2444);\t \n\t\tsram_write(tp, 0x805d, 0x2444);\t \n\t}\n\n\trtl_green_en(tp, true);\n}\n\nstatic u16 r8153_phy_status(struct r8152 *tp, u16 desired)\n{\n\tu16 data;\n\tint i;\n\n\tfor (i = 0; i < 500; i++) {\n\t\tdata = ocp_reg_read(tp, OCP_PHY_STATUS);\n\t\tdata &= PHY_STAT_MASK;\n\t\tif (desired) {\n\t\t\tif (data == desired)\n\t\t\t\tbreak;\n\t\t} else if (data == PHY_STAT_LAN_ON || data == PHY_STAT_PWRDN ||\n\t\t\t   data == PHY_STAT_EXT_INIT) {\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(20);\n\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\tbreak;\n\t}\n\n\treturn data;\n}\n\nstatic void r8153b_ups_en(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_POWER_CUT);\n\n\tif (enable) {\n\t\tr8153b_ups_flags(tp);\n\n\t\tocp_data |= UPS_EN | USP_PREWAKE | PHASE2_EN;\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);\n\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);\n\t\tocp_data |= UPS_FORCE_PWR_DOWN;\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);\n\t} else {\n\t\tocp_data &= ~(UPS_EN | USP_PREWAKE);\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);\n\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);\n\t\tocp_data &= ~UPS_FORCE_PWR_DOWN;\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);\n\n\t\tif (ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0) & PCUT_STATUS) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 500; i++) {\n\t\t\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\t\t\treturn;\n\t\t\t\tif (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &\n\t\t\t\t    AUTOLOAD_DONE)\n\t\t\t\t\tbreak;\n\t\t\t\tmsleep(20);\n\t\t\t}\n\n\t\t\ttp->rtl_ops.hw_phy_cfg(tp);\n\n\t\t\trtl8152_set_speed(tp, tp->autoneg, tp->speed,\n\t\t\t\t\t  tp->duplex, tp->advertising);\n\t\t}\n\t}\n}\n\nstatic void r8153c_ups_en(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_POWER_CUT);\n\n\tif (enable) {\n\t\tr8153b_ups_flags(tp);\n\n\t\tocp_data |= UPS_EN | USP_PREWAKE | PHASE2_EN;\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);\n\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);\n\t\tocp_data |= UPS_FORCE_PWR_DOWN;\n\t\tocp_data &= ~BIT(7);\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);\n\t} else {\n\t\tocp_data &= ~(UPS_EN | USP_PREWAKE);\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);\n\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);\n\t\tocp_data &= ~UPS_FORCE_PWR_DOWN;\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);\n\n\t\tif (ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0) & PCUT_STATUS) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 500; i++) {\n\t\t\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\t\t\treturn;\n\t\t\t\tif (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &\n\t\t\t\t    AUTOLOAD_DONE)\n\t\t\t\t\tbreak;\n\t\t\t\tmsleep(20);\n\t\t\t}\n\n\t\t\ttp->rtl_ops.hw_phy_cfg(tp);\n\n\t\t\trtl8152_set_speed(tp, tp->autoneg, tp->speed,\n\t\t\t\t\t  tp->duplex, tp->advertising);\n\t\t}\n\n\t\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);\n\t\tocp_data |= BIT(8);\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, ocp_data);\n\n\t\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);\n\t}\n}\n\nstatic void r8156_ups_en(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_POWER_CUT);\n\n\tif (enable) {\n\t\tr8156_ups_flags(tp);\n\n\t\tocp_data |= UPS_EN | USP_PREWAKE | PHASE2_EN;\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);\n\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);\n\t\tocp_data |= UPS_FORCE_PWR_DOWN;\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);\n\n\t\tswitch (tp->version) {\n\t\tcase RTL_VER_13:\n\t\tcase RTL_VER_15:\n\t\t\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_UPHY_XTAL);\n\t\t\tocp_data &= ~OOBS_POLLING;\n\t\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_UPHY_XTAL, ocp_data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tocp_data &= ~(UPS_EN | USP_PREWAKE);\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);\n\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);\n\t\tocp_data &= ~UPS_FORCE_PWR_DOWN;\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);\n\n\t\tif (ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0) & PCUT_STATUS) {\n\t\t\ttp->rtl_ops.hw_phy_cfg(tp);\n\n\t\t\trtl8152_set_speed(tp, tp->autoneg, tp->speed,\n\t\t\t\t\t  tp->duplex, tp->advertising);\n\t\t}\n\t}\n}\n\nstatic void r8153_power_cut_en(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_POWER_CUT);\n\tif (enable)\n\t\tocp_data |= PWR_EN | PHASE2_EN;\n\telse\n\t\tocp_data &= ~(PWR_EN | PHASE2_EN);\n\tocp_write_word(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);\n\tocp_data &= ~PCUT_STATUS;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);\n}\n\nstatic void r8153b_power_cut_en(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_POWER_CUT);\n\tif (enable)\n\t\tocp_data |= PWR_EN | PHASE2_EN;\n\telse\n\t\tocp_data &= ~PWR_EN;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);\n\tocp_data &= ~PCUT_STATUS;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);\n}\n\nstatic void r8153_queue_wake(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_INDICATE_FALG);\n\tif (enable)\n\t\tocp_data |= UPCOMING_RUNTIME_D3;\n\telse\n\t\tocp_data &= ~UPCOMING_RUNTIME_D3;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_INDICATE_FALG, ocp_data);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_SUSPEND_FLAG);\n\tocp_data &= ~LINK_CHG_EVENT;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_SUSPEND_FLAG, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);\n\tocp_data &= ~LINK_CHANGE_FLAG;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);\n}\n\nstatic bool rtl_can_wakeup(struct r8152 *tp)\n{\n\tstruct usb_device *udev = tp->udev;\n\n\treturn (udev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_WAKEUP);\n}\n\nstatic void rtl_runtime_suspend_enable(struct r8152 *tp, bool enable)\n{\n\tif (enable) {\n\t\tu32 ocp_data;\n\n\t\t__rtl_set_wol(tp, WAKE_ANY);\n\n\t\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);\n\t\tocp_data |= LINK_OFF_WAKE_EN;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, ocp_data);\n\n\t\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);\n\t} else {\n\t\tu32 ocp_data;\n\n\t\t__rtl_set_wol(tp, tp->saved_wolopts);\n\n\t\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);\n\t\tocp_data &= ~LINK_OFF_WAKE_EN;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, ocp_data);\n\n\t\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);\n\t}\n}\n\nstatic void rtl8153_runtime_enable(struct r8152 *tp, bool enable)\n{\n\tif (enable) {\n\t\tr8153_u1u2en(tp, false);\n\t\tr8153_u2p3en(tp, false);\n\t\trtl_runtime_suspend_enable(tp, true);\n\t} else {\n\t\trtl_runtime_suspend_enable(tp, false);\n\n\t\tswitch (tp->version) {\n\t\tcase RTL_VER_03:\n\t\tcase RTL_VER_04:\n\t\t\tbreak;\n\t\tcase RTL_VER_05:\n\t\tcase RTL_VER_06:\n\t\tdefault:\n\t\t\tr8153_u2p3en(tp, true);\n\t\t\tbreak;\n\t\t}\n\n\t\tr8153_u1u2en(tp, true);\n\t}\n}\n\nstatic void rtl8153b_runtime_enable(struct r8152 *tp, bool enable)\n{\n\tif (enable) {\n\t\tr8153_queue_wake(tp, true);\n\t\tr8153b_u1u2en(tp, false);\n\t\tr8153_u2p3en(tp, false);\n\t\trtl_runtime_suspend_enable(tp, true);\n\t\tr8153b_ups_en(tp, true);\n\t} else {\n\t\tr8153b_ups_en(tp, false);\n\t\tr8153_queue_wake(tp, false);\n\t\trtl_runtime_suspend_enable(tp, false);\n\t\tif (tp->udev->speed >= USB_SPEED_SUPER)\n\t\t\tr8153b_u1u2en(tp, true);\n\t}\n}\n\nstatic void rtl8153c_runtime_enable(struct r8152 *tp, bool enable)\n{\n\tif (enable) {\n\t\tr8153_queue_wake(tp, true);\n\t\tr8153b_u1u2en(tp, false);\n\t\tr8153_u2p3en(tp, false);\n\t\trtl_runtime_suspend_enable(tp, true);\n\t\tr8153c_ups_en(tp, true);\n\t} else {\n\t\tr8153c_ups_en(tp, false);\n\t\tr8153_queue_wake(tp, false);\n\t\trtl_runtime_suspend_enable(tp, false);\n\t\tr8153b_u1u2en(tp, true);\n\t}\n}\n\nstatic void rtl8156_runtime_enable(struct r8152 *tp, bool enable)\n{\n\tif (enable) {\n\t\tr8153_queue_wake(tp, true);\n\t\tr8153b_u1u2en(tp, false);\n\t\tr8153_u2p3en(tp, false);\n\t\trtl_runtime_suspend_enable(tp, true);\n\t} else {\n\t\tr8153_queue_wake(tp, false);\n\t\trtl_runtime_suspend_enable(tp, false);\n\t\tr8153_u2p3en(tp, true);\n\t\tif (tp->udev->speed >= USB_SPEED_SUPER)\n\t\t\tr8153b_u1u2en(tp, true);\n\t}\n}\n\nstatic void r8153_teredo_off(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_01:\n\tcase RTL_VER_02:\n\tcase RTL_VER_03:\n\tcase RTL_VER_04:\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\tcase RTL_VER_07:\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG);\n\t\tocp_data &= ~(TEREDO_SEL | TEREDO_RS_EVENT_MASK |\n\t\t\t      OOB_TEREDO_EN);\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG, ocp_data);\n\t\tbreak;\n\n\tcase RTL_VER_08:\n\tcase RTL_VER_09:\n\tcase RTL_TEST_01:\n\tcase RTL_VER_10:\n\tcase RTL_VER_11:\n\tcase RTL_VER_12:\n\tcase RTL_VER_13:\n\tcase RTL_VER_14:\n\tcase RTL_VER_15:\n\tdefault:\n\t\t \n\t\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG, 0xff);\n\t\tbreak;\n\t}\n\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_WDT6_CTRL, WDT6_SET_MODE);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_REALWOW_TIMER, 0);\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_TEREDO_TIMER, 0);\n}\n\nstatic void rtl_reset_bmu(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_BMU_RESET);\n\tocp_data &= ~(BMU_RESET_EP_IN | BMU_RESET_EP_OUT);\n\tocp_write_byte(tp, MCU_TYPE_USB, USB_BMU_RESET, ocp_data);\n\tocp_data |= BMU_RESET_EP_IN | BMU_RESET_EP_OUT;\n\tocp_write_byte(tp, MCU_TYPE_USB, USB_BMU_RESET, ocp_data);\n}\n\n \nstatic void rtl_clear_bp(struct r8152 *tp, u16 type)\n{\n\tu16 bp[16] = {0};\n\tu16 bp_num;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_08:\n\tcase RTL_VER_09:\n\tcase RTL_VER_10:\n\tcase RTL_VER_11:\n\tcase RTL_VER_12:\n\tcase RTL_VER_13:\n\tcase RTL_VER_15:\n\t\tif (type == MCU_TYPE_USB) {\n\t\t\tocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0);\n\t\t\tbp_num = 16;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase RTL_VER_03:\n\tcase RTL_VER_04:\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\t\tocp_write_byte(tp, type, PLA_BP_EN, 0);\n\t\tfallthrough;\n\tcase RTL_VER_01:\n\tcase RTL_VER_02:\n\tcase RTL_VER_07:\n\t\tbp_num = 8;\n\t\tbreak;\n\tcase RTL_VER_14:\n\tdefault:\n\t\tocp_write_word(tp, type, USB_BP2_EN, 0);\n\t\tbp_num = 16;\n\t\tbreak;\n\t}\n\n\tgeneric_ocp_write(tp, PLA_BP_0, BYTE_EN_DWORD, bp_num << 1, bp, type);\n\n\t \n\tusleep_range(3000, 6000);\n\tocp_write_word(tp, type, PLA_BP_BA, 0);\n}\n\nstatic inline void rtl_reset_ocp_base(struct r8152 *tp)\n{\n\ttp->ocp_base = -1;\n}\n\nstatic int rtl_phy_patch_request(struct r8152 *tp, bool request, bool wait)\n{\n\tu16 data, check;\n\tint i;\n\n\tdata = ocp_reg_read(tp, OCP_PHY_PATCH_CMD);\n\tif (request) {\n\t\tdata |= PATCH_REQUEST;\n\t\tcheck = 0;\n\t} else {\n\t\tdata &= ~PATCH_REQUEST;\n\t\tcheck = PATCH_READY;\n\t}\n\tocp_reg_write(tp, OCP_PHY_PATCH_CMD, data);\n\n\tfor (i = 0; wait && i < 5000; i++) {\n\t\tu32 ocp_data;\n\n\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\treturn -ENODEV;\n\n\t\tusleep_range(1000, 2000);\n\t\tocp_data = ocp_reg_read(tp, OCP_PHY_PATCH_STAT);\n\t\tif ((ocp_data & PATCH_READY) ^ check)\n\t\t\tbreak;\n\t}\n\n\tif (request && wait &&\n\t    !(ocp_reg_read(tp, OCP_PHY_PATCH_STAT) & PATCH_READY)) {\n\t\tdev_err(&tp->intf->dev, \"PHY patch request fail\\n\");\n\t\trtl_phy_patch_request(tp, false, false);\n\t\treturn -ETIME;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic void rtl_patch_key_set(struct r8152 *tp, u16 key_addr, u16 patch_key)\n{\n\tif (patch_key && key_addr) {\n\t\tsram_write(tp, key_addr, patch_key);\n\t\tsram_write(tp, SRAM_PHY_LOCK, PHY_PATCH_LOCK);\n\t} else if (key_addr) {\n\t\tu16 data;\n\n\t\tsram_write(tp, 0x0000, 0x0000);\n\n\t\tdata = ocp_reg_read(tp, OCP_PHY_LOCK);\n\t\tdata &= ~PATCH_LOCK;\n\t\tocp_reg_write(tp, OCP_PHY_LOCK, data);\n\n\t\tsram_write(tp, key_addr, 0x0000);\n\t} else {\n\t\tWARN_ON_ONCE(1);\n\t}\n}\n\nstatic int\nrtl_pre_ram_code(struct r8152 *tp, u16 key_addr, u16 patch_key, bool wait)\n{\n\tif (rtl_phy_patch_request(tp, true, wait))\n\t\treturn -ETIME;\n\n\trtl_patch_key_set(tp, key_addr, patch_key);\n\n\treturn 0;\n}\n\nstatic int rtl_post_ram_code(struct r8152 *tp, u16 key_addr, bool wait)\n{\n\trtl_patch_key_set(tp, key_addr, 0);\n\n\trtl_phy_patch_request(tp, false, wait);\n\n\treturn 0;\n}\n\nstatic bool rtl8152_is_fw_phy_speed_up_ok(struct r8152 *tp, struct fw_phy_speed_up *phy)\n{\n\tu16 fw_offset;\n\tu32 length;\n\tbool rc = false;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_01:\n\tcase RTL_VER_02:\n\tcase RTL_VER_03:\n\tcase RTL_VER_04:\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\tcase RTL_VER_07:\n\tcase RTL_VER_08:\n\tcase RTL_VER_09:\n\tcase RTL_VER_10:\n\tcase RTL_VER_11:\n\tcase RTL_VER_12:\n\tcase RTL_VER_14:\n\t\tgoto out;\n\tcase RTL_VER_13:\n\tcase RTL_VER_15:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfw_offset = __le16_to_cpu(phy->fw_offset);\n\tlength = __le32_to_cpu(phy->blk_hdr.length);\n\tif (fw_offset < sizeof(*phy) || length <= fw_offset) {\n\t\tdev_err(&tp->intf->dev, \"invalid fw_offset\\n\");\n\t\tgoto out;\n\t}\n\n\tlength -= fw_offset;\n\tif (length & 3) {\n\t\tdev_err(&tp->intf->dev, \"invalid block length\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(phy->fw_reg) != 0x9A00) {\n\t\tdev_err(&tp->intf->dev, \"invalid register to load firmware\\n\");\n\t\tgoto out;\n\t}\n\n\trc = true;\nout:\n\treturn rc;\n}\n\nstatic bool rtl8152_is_fw_phy_ver_ok(struct r8152 *tp, struct fw_phy_ver *ver)\n{\n\tbool rc = false;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_10:\n\tcase RTL_VER_11:\n\tcase RTL_VER_12:\n\tcase RTL_VER_13:\n\tcase RTL_VER_15:\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif (__le32_to_cpu(ver->blk_hdr.length) != sizeof(*ver)) {\n\t\tdev_err(&tp->intf->dev, \"invalid block length\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(ver->ver.addr) != SRAM_GPHY_FW_VER) {\n\t\tdev_err(&tp->intf->dev, \"invalid phy ver addr\\n\");\n\t\tgoto out;\n\t}\n\n\trc = true;\nout:\n\treturn rc;\n}\n\nstatic bool rtl8152_is_fw_phy_fixup_ok(struct r8152 *tp, struct fw_phy_fixup *fix)\n{\n\tbool rc = false;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_10:\n\tcase RTL_VER_11:\n\tcase RTL_VER_12:\n\tcase RTL_VER_13:\n\tcase RTL_VER_15:\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif (__le32_to_cpu(fix->blk_hdr.length) != sizeof(*fix)) {\n\t\tdev_err(&tp->intf->dev, \"invalid block length\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(fix->setting.addr) != OCP_PHY_PATCH_CMD ||\n\t    __le16_to_cpu(fix->setting.data) != BIT(7)) {\n\t\tdev_err(&tp->intf->dev, \"invalid phy fixup\\n\");\n\t\tgoto out;\n\t}\n\n\trc = true;\nout:\n\treturn rc;\n}\n\nstatic bool rtl8152_is_fw_phy_union_ok(struct r8152 *tp, struct fw_phy_union *phy)\n{\n\tu16 fw_offset;\n\tu32 length;\n\tbool rc = false;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_10:\n\tcase RTL_VER_11:\n\tcase RTL_VER_12:\n\tcase RTL_VER_13:\n\tcase RTL_VER_15:\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tfw_offset = __le16_to_cpu(phy->fw_offset);\n\tlength = __le32_to_cpu(phy->blk_hdr.length);\n\tif (fw_offset < sizeof(*phy) || length <= fw_offset) {\n\t\tdev_err(&tp->intf->dev, \"invalid fw_offset\\n\");\n\t\tgoto out;\n\t}\n\n\tlength -= fw_offset;\n\tif (length & 1) {\n\t\tdev_err(&tp->intf->dev, \"invalid block length\\n\");\n\t\tgoto out;\n\t}\n\n\tif (phy->pre_num > 2) {\n\t\tdev_err(&tp->intf->dev, \"invalid pre_num %d\\n\", phy->pre_num);\n\t\tgoto out;\n\t}\n\n\tif (phy->bp_num > 8) {\n\t\tdev_err(&tp->intf->dev, \"invalid bp_num %d\\n\", phy->bp_num);\n\t\tgoto out;\n\t}\n\n\trc = true;\nout:\n\treturn rc;\n}\n\nstatic bool rtl8152_is_fw_phy_nc_ok(struct r8152 *tp, struct fw_phy_nc *phy)\n{\n\tu32 length;\n\tu16 fw_offset, fw_reg, ba_reg, patch_en_addr, mode_reg, bp_start;\n\tbool rc = false;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_04:\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\t\tfw_reg = 0xa014;\n\t\tba_reg = 0xa012;\n\t\tpatch_en_addr = 0xa01a;\n\t\tmode_reg = 0xb820;\n\t\tbp_start = 0xa000;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tfw_offset = __le16_to_cpu(phy->fw_offset);\n\tif (fw_offset < sizeof(*phy)) {\n\t\tdev_err(&tp->intf->dev, \"fw_offset too small\\n\");\n\t\tgoto out;\n\t}\n\n\tlength = __le32_to_cpu(phy->blk_hdr.length);\n\tif (length < fw_offset) {\n\t\tdev_err(&tp->intf->dev, \"invalid fw_offset\\n\");\n\t\tgoto out;\n\t}\n\n\tlength -= __le16_to_cpu(phy->fw_offset);\n\tif (!length || (length & 1)) {\n\t\tdev_err(&tp->intf->dev, \"invalid block length\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(phy->fw_reg) != fw_reg) {\n\t\tdev_err(&tp->intf->dev, \"invalid register to load firmware\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(phy->ba_reg) != ba_reg) {\n\t\tdev_err(&tp->intf->dev, \"invalid base address register\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(phy->patch_en_addr) != patch_en_addr) {\n\t\tdev_err(&tp->intf->dev,\n\t\t\t\"invalid patch mode enabled register\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(phy->mode_reg) != mode_reg) {\n\t\tdev_err(&tp->intf->dev,\n\t\t\t\"invalid register to switch the mode\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(phy->bp_start) != bp_start) {\n\t\tdev_err(&tp->intf->dev,\n\t\t\t\"invalid start register of break point\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(phy->bp_num) > 4) {\n\t\tdev_err(&tp->intf->dev, \"invalid break point number\\n\");\n\t\tgoto out;\n\t}\n\n\trc = true;\nout:\n\treturn rc;\n}\n\nstatic bool rtl8152_is_fw_mac_ok(struct r8152 *tp, struct fw_mac *mac)\n{\n\tu16 fw_reg, bp_ba_addr, bp_en_addr, bp_start, fw_offset;\n\tbool rc = false;\n\tu32 length, type;\n\tint i, max_bp;\n\n\ttype = __le32_to_cpu(mac->blk_hdr.type);\n\tif (type == RTL_FW_PLA) {\n\t\tswitch (tp->version) {\n\t\tcase RTL_VER_01:\n\t\tcase RTL_VER_02:\n\t\tcase RTL_VER_07:\n\t\t\tfw_reg = 0xf800;\n\t\t\tbp_ba_addr = PLA_BP_BA;\n\t\t\tbp_en_addr = 0;\n\t\t\tbp_start = PLA_BP_0;\n\t\t\tmax_bp = 8;\n\t\t\tbreak;\n\t\tcase RTL_VER_03:\n\t\tcase RTL_VER_04:\n\t\tcase RTL_VER_05:\n\t\tcase RTL_VER_06:\n\t\tcase RTL_VER_08:\n\t\tcase RTL_VER_09:\n\t\tcase RTL_VER_11:\n\t\tcase RTL_VER_12:\n\t\tcase RTL_VER_13:\n\t\tcase RTL_VER_15:\n\t\t\tfw_reg = 0xf800;\n\t\t\tbp_ba_addr = PLA_BP_BA;\n\t\t\tbp_en_addr = PLA_BP_EN;\n\t\t\tbp_start = PLA_BP_0;\n\t\t\tmax_bp = 8;\n\t\t\tbreak;\n\t\tcase RTL_VER_14:\n\t\t\tfw_reg = 0xf800;\n\t\t\tbp_ba_addr = PLA_BP_BA;\n\t\t\tbp_en_addr = USB_BP2_EN;\n\t\t\tbp_start = PLA_BP_0;\n\t\t\tmax_bp = 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t} else if (type == RTL_FW_USB) {\n\t\tswitch (tp->version) {\n\t\tcase RTL_VER_03:\n\t\tcase RTL_VER_04:\n\t\tcase RTL_VER_05:\n\t\tcase RTL_VER_06:\n\t\t\tfw_reg = 0xf800;\n\t\t\tbp_ba_addr = USB_BP_BA;\n\t\t\tbp_en_addr = USB_BP_EN;\n\t\t\tbp_start = USB_BP_0;\n\t\t\tmax_bp = 8;\n\t\t\tbreak;\n\t\tcase RTL_VER_08:\n\t\tcase RTL_VER_09:\n\t\tcase RTL_VER_11:\n\t\tcase RTL_VER_12:\n\t\tcase RTL_VER_13:\n\t\tcase RTL_VER_14:\n\t\tcase RTL_VER_15:\n\t\t\tfw_reg = 0xe600;\n\t\t\tbp_ba_addr = USB_BP_BA;\n\t\t\tbp_en_addr = USB_BP2_EN;\n\t\t\tbp_start = USB_BP_0;\n\t\t\tmax_bp = 16;\n\t\t\tbreak;\n\t\tcase RTL_VER_01:\n\t\tcase RTL_VER_02:\n\t\tcase RTL_VER_07:\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tgoto out;\n\t}\n\n\tfw_offset = __le16_to_cpu(mac->fw_offset);\n\tif (fw_offset < sizeof(*mac)) {\n\t\tdev_err(&tp->intf->dev, \"fw_offset too small\\n\");\n\t\tgoto out;\n\t}\n\n\tlength = __le32_to_cpu(mac->blk_hdr.length);\n\tif (length < fw_offset) {\n\t\tdev_err(&tp->intf->dev, \"invalid fw_offset\\n\");\n\t\tgoto out;\n\t}\n\n\tlength -= fw_offset;\n\tif (length < 4 || (length & 3)) {\n\t\tdev_err(&tp->intf->dev, \"invalid block length\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(mac->fw_reg) != fw_reg) {\n\t\tdev_err(&tp->intf->dev, \"invalid register to load firmware\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(mac->bp_ba_addr) != bp_ba_addr) {\n\t\tdev_err(&tp->intf->dev, \"invalid base address register\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(mac->bp_en_addr) != bp_en_addr) {\n\t\tdev_err(&tp->intf->dev, \"invalid enabled mask register\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(mac->bp_start) != bp_start) {\n\t\tdev_err(&tp->intf->dev,\n\t\t\t\"invalid start register of break point\\n\");\n\t\tgoto out;\n\t}\n\n\tif (__le16_to_cpu(mac->bp_num) > max_bp) {\n\t\tdev_err(&tp->intf->dev, \"invalid break point number\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (i = __le16_to_cpu(mac->bp_num); i < max_bp; i++) {\n\t\tif (mac->bp[i]) {\n\t\t\tdev_err(&tp->intf->dev, \"unused bp%u is not zero\\n\", i);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = true;\nout:\n\treturn rc;\n}\n\n \nstatic long rtl8152_fw_verify_checksum(struct r8152 *tp,\n\t\t\t\t       struct fw_header *fw_hdr, size_t size)\n{\n\tunsigned char checksum[sizeof(fw_hdr->checksum)];\n\tstruct crypto_shash *alg;\n\tstruct shash_desc *sdesc;\n\tsize_t len;\n\tlong rc;\n\n\talg = crypto_alloc_shash(\"sha256\", 0, 0);\n\tif (IS_ERR(alg)) {\n\t\trc = PTR_ERR(alg);\n\t\tgoto out;\n\t}\n\n\tif (crypto_shash_digestsize(alg) != sizeof(fw_hdr->checksum)) {\n\t\trc = -EFAULT;\n\t\tdev_err(&tp->intf->dev, \"digestsize incorrect (%u)\\n\",\n\t\t\tcrypto_shash_digestsize(alg));\n\t\tgoto free_shash;\n\t}\n\n\tlen = sizeof(*sdesc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(len, GFP_KERNEL);\n\tif (!sdesc) {\n\t\trc = -ENOMEM;\n\t\tgoto free_shash;\n\t}\n\tsdesc->tfm = alg;\n\n\tlen = size - sizeof(fw_hdr->checksum);\n\trc = crypto_shash_digest(sdesc, fw_hdr->version, len, checksum);\n\tkfree(sdesc);\n\tif (rc)\n\t\tgoto free_shash;\n\n\tif (memcmp(fw_hdr->checksum, checksum, sizeof(fw_hdr->checksum))) {\n\t\tdev_err(&tp->intf->dev, \"checksum fail\\n\");\n\t\trc = -EFAULT;\n\t}\n\nfree_shash:\n\tcrypto_free_shash(alg);\nout:\n\treturn rc;\n}\n\nstatic long rtl8152_check_firmware(struct r8152 *tp, struct rtl_fw *rtl_fw)\n{\n\tconst struct firmware *fw = rtl_fw->fw;\n\tstruct fw_header *fw_hdr = (struct fw_header *)fw->data;\n\tunsigned long fw_flags = 0;\n\tlong ret = -EFAULT;\n\tint i;\n\n\tif (fw->size < sizeof(*fw_hdr)) {\n\t\tdev_err(&tp->intf->dev, \"file too small\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = rtl8152_fw_verify_checksum(tp, fw_hdr, fw->size);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = -EFAULT;\n\n\tfor (i = sizeof(*fw_hdr); i < fw->size;) {\n\t\tstruct fw_block *block = (struct fw_block *)&fw->data[i];\n\t\tu32 type;\n\n\t\tif ((i + sizeof(*block)) > fw->size)\n\t\t\tgoto fail;\n\n\t\ttype = __le32_to_cpu(block->type);\n\t\tswitch (type) {\n\t\tcase RTL_FW_END:\n\t\t\tif (__le32_to_cpu(block->length) != sizeof(*block))\n\t\t\t\tgoto fail;\n\t\t\tgoto fw_end;\n\t\tcase RTL_FW_PLA:\n\t\t\tif (test_bit(FW_FLAGS_PLA, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev,\n\t\t\t\t\t\"multiple PLA firmware encountered\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (!rtl8152_is_fw_mac_ok(tp, (struct fw_mac *)block)) {\n\t\t\t\tdev_err(&tp->intf->dev,\n\t\t\t\t\t\"check PLA firmware failed\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t__set_bit(FW_FLAGS_PLA, &fw_flags);\n\t\t\tbreak;\n\t\tcase RTL_FW_USB:\n\t\t\tif (test_bit(FW_FLAGS_USB, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev,\n\t\t\t\t\t\"multiple USB firmware encountered\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (!rtl8152_is_fw_mac_ok(tp, (struct fw_mac *)block)) {\n\t\t\t\tdev_err(&tp->intf->dev,\n\t\t\t\t\t\"check USB firmware failed\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t__set_bit(FW_FLAGS_USB, &fw_flags);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_START:\n\t\t\tif (test_bit(FW_FLAGS_START, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_NC, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_NC1, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_NC2, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_UC2, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_UC, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_STOP, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev,\n\t\t\t\t\t\"check PHY_START fail\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (__le32_to_cpu(block->length) != sizeof(struct fw_phy_patch_key)) {\n\t\t\t\tdev_err(&tp->intf->dev,\n\t\t\t\t\t\"Invalid length for PHY_START\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t__set_bit(FW_FLAGS_START, &fw_flags);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_STOP:\n\t\t\tif (test_bit(FW_FLAGS_STOP, &fw_flags) ||\n\t\t\t    !test_bit(FW_FLAGS_START, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev,\n\t\t\t\t\t\"Check PHY_STOP fail\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (__le32_to_cpu(block->length) != sizeof(*block)) {\n\t\t\t\tdev_err(&tp->intf->dev,\n\t\t\t\t\t\"Invalid length for PHY_STOP\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t__set_bit(FW_FLAGS_STOP, &fw_flags);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_NC:\n\t\t\tif (!test_bit(FW_FLAGS_START, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_STOP, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev,\n\t\t\t\t\t\"check PHY_NC fail\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (test_bit(FW_FLAGS_NC, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev,\n\t\t\t\t\t\"multiple PHY NC encountered\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (!rtl8152_is_fw_phy_nc_ok(tp, (struct fw_phy_nc *)block)) {\n\t\t\t\tdev_err(&tp->intf->dev,\n\t\t\t\t\t\"check PHY NC firmware failed\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t__set_bit(FW_FLAGS_NC, &fw_flags);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_UNION_NC:\n\t\t\tif (!test_bit(FW_FLAGS_START, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_NC1, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_NC2, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_UC2, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_UC, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_STOP, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"PHY_UNION_NC out of order\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (test_bit(FW_FLAGS_NC, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"multiple PHY_UNION_NC encountered\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (!rtl8152_is_fw_phy_union_ok(tp, (struct fw_phy_union *)block)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"check PHY_UNION_NC failed\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t__set_bit(FW_FLAGS_NC, &fw_flags);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_UNION_NC1:\n\t\t\tif (!test_bit(FW_FLAGS_START, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_NC2, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_UC2, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_UC, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_STOP, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"PHY_UNION_NC1 out of order\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (test_bit(FW_FLAGS_NC1, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"multiple PHY NC1 encountered\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (!rtl8152_is_fw_phy_union_ok(tp, (struct fw_phy_union *)block)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"check PHY_UNION_NC1 failed\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t__set_bit(FW_FLAGS_NC1, &fw_flags);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_UNION_NC2:\n\t\t\tif (!test_bit(FW_FLAGS_START, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_UC2, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_UC, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_STOP, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"PHY_UNION_NC2 out of order\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (test_bit(FW_FLAGS_NC2, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"multiple PHY NC2 encountered\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (!rtl8152_is_fw_phy_union_ok(tp, (struct fw_phy_union *)block)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"check PHY_UNION_NC2 failed\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t__set_bit(FW_FLAGS_NC2, &fw_flags);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_UNION_UC2:\n\t\t\tif (!test_bit(FW_FLAGS_START, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_UC, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_STOP, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"PHY_UNION_UC2 out of order\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (test_bit(FW_FLAGS_UC2, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"multiple PHY UC2 encountered\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (!rtl8152_is_fw_phy_union_ok(tp, (struct fw_phy_union *)block)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"check PHY_UNION_UC2 failed\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t__set_bit(FW_FLAGS_UC2, &fw_flags);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_UNION_UC:\n\t\t\tif (!test_bit(FW_FLAGS_START, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_STOP, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"PHY_UNION_UC out of order\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (test_bit(FW_FLAGS_UC, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"multiple PHY UC encountered\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (!rtl8152_is_fw_phy_union_ok(tp, (struct fw_phy_union *)block)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"check PHY_UNION_UC failed\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t__set_bit(FW_FLAGS_UC, &fw_flags);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_UNION_MISC:\n\t\t\tif (!rtl8152_is_fw_phy_union_ok(tp, (struct fw_phy_union *)block)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"check RTL_FW_PHY_UNION_MISC failed\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_FIXUP:\n\t\t\tif (!rtl8152_is_fw_phy_fixup_ok(tp, (struct fw_phy_fixup *)block)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"check PHY fixup failed\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_SPEED_UP:\n\t\t\tif (test_bit(FW_FLAGS_SPEED_UP, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"multiple PHY firmware encountered\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (!rtl8152_is_fw_phy_speed_up_ok(tp, (struct fw_phy_speed_up *)block)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"check PHY speed up failed\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t__set_bit(FW_FLAGS_SPEED_UP, &fw_flags);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_VER:\n\t\t\tif (test_bit(FW_FLAGS_START, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_NC, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_NC1, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_NC2, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_UC2, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_UC, &fw_flags) ||\n\t\t\t    test_bit(FW_FLAGS_STOP, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"Invalid order to set PHY version\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (test_bit(FW_FLAGS_VER, &fw_flags)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"multiple PHY version encountered\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (!rtl8152_is_fw_phy_ver_ok(tp, (struct fw_phy_ver *)block)) {\n\t\t\t\tdev_err(&tp->intf->dev, \"check PHY version failed\\n\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t__set_bit(FW_FLAGS_VER, &fw_flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&tp->intf->dev, \"Unknown type %u is found\\n\",\n\t\t\t\t type);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ti += ALIGN(__le32_to_cpu(block->length), 8);\n\t}\n\nfw_end:\n\tif (test_bit(FW_FLAGS_START, &fw_flags) && !test_bit(FW_FLAGS_STOP, &fw_flags)) {\n\t\tdev_err(&tp->intf->dev, \"without PHY_STOP\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\treturn ret;\n}\n\nstatic void rtl_ram_code_speed_up(struct r8152 *tp, struct fw_phy_speed_up *phy, bool wait)\n{\n\tu32 len;\n\tu8 *data;\n\n\trtl_reset_ocp_base(tp);\n\n\tif (sram_read(tp, SRAM_GPHY_FW_VER) >= __le16_to_cpu(phy->version)) {\n\t\tdev_dbg(&tp->intf->dev, \"PHY firmware has been the newest\\n\");\n\t\treturn;\n\t}\n\n\tlen = __le32_to_cpu(phy->blk_hdr.length);\n\tlen -= __le16_to_cpu(phy->fw_offset);\n\tdata = (u8 *)phy + __le16_to_cpu(phy->fw_offset);\n\n\tif (rtl_phy_patch_request(tp, true, wait))\n\t\treturn;\n\n\twhile (len) {\n\t\tu32 ocp_data, size;\n\t\tint i;\n\n\t\tif (len < 2048)\n\t\t\tsize = len;\n\t\telse\n\t\t\tsize = 2048;\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL);\n\t\tocp_data |= GPHY_PATCH_DONE | BACKUP_RESTRORE;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL, ocp_data);\n\n\t\tgeneric_ocp_write(tp, __le16_to_cpu(phy->fw_reg), 0xff, size, data, MCU_TYPE_USB);\n\n\t\tdata += size;\n\t\tlen -= size;\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL);\n\t\tocp_data |= POL_GPHY_PATCH;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL, ocp_data);\n\n\t\tfor (i = 0; i < 1000; i++) {\n\t\t\tif (!(ocp_read_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL) & POL_GPHY_PATCH))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == 1000) {\n\t\t\tdev_err(&tp->intf->dev, \"ram code speedup mode timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trtl_reset_ocp_base(tp);\n\n\trtl_phy_patch_request(tp, false, wait);\n\n\tif (sram_read(tp, SRAM_GPHY_FW_VER) == __le16_to_cpu(phy->version))\n\t\tdev_dbg(&tp->intf->dev, \"successfully applied %s\\n\", phy->info);\n\telse\n\t\tdev_err(&tp->intf->dev, \"ram code speedup mode fail\\n\");\n}\n\nstatic int rtl8152_fw_phy_ver(struct r8152 *tp, struct fw_phy_ver *phy_ver)\n{\n\tu16 ver_addr, ver;\n\n\tver_addr = __le16_to_cpu(phy_ver->ver.addr);\n\tver = __le16_to_cpu(phy_ver->ver.data);\n\n\trtl_reset_ocp_base(tp);\n\n\tif (sram_read(tp, ver_addr) >= ver) {\n\t\tdev_dbg(&tp->intf->dev, \"PHY firmware has been the newest\\n\");\n\t\treturn 0;\n\t}\n\n\tsram_write(tp, ver_addr, ver);\n\n\tdev_dbg(&tp->intf->dev, \"PHY firmware version %x\\n\", ver);\n\n\treturn ver;\n}\n\nstatic void rtl8152_fw_phy_fixup(struct r8152 *tp, struct fw_phy_fixup *fix)\n{\n\tu16 addr, data;\n\n\trtl_reset_ocp_base(tp);\n\n\taddr = __le16_to_cpu(fix->setting.addr);\n\tdata = ocp_reg_read(tp, addr);\n\n\tswitch (__le16_to_cpu(fix->bit_cmd)) {\n\tcase FW_FIXUP_AND:\n\t\tdata &= __le16_to_cpu(fix->setting.data);\n\t\tbreak;\n\tcase FW_FIXUP_OR:\n\t\tdata |= __le16_to_cpu(fix->setting.data);\n\t\tbreak;\n\tcase FW_FIXUP_NOT:\n\t\tdata &= ~__le16_to_cpu(fix->setting.data);\n\t\tbreak;\n\tcase FW_FIXUP_XOR:\n\t\tdata ^= __le16_to_cpu(fix->setting.data);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tocp_reg_write(tp, addr, data);\n\n\tdev_dbg(&tp->intf->dev, \"applied ocp %x %x\\n\", addr, data);\n}\n\nstatic void rtl8152_fw_phy_union_apply(struct r8152 *tp, struct fw_phy_union *phy)\n{\n\t__le16 *data;\n\tu32 length;\n\tint i, num;\n\n\trtl_reset_ocp_base(tp);\n\n\tnum = phy->pre_num;\n\tfor (i = 0; i < num; i++)\n\t\tsram_write(tp, __le16_to_cpu(phy->pre_set[i].addr),\n\t\t\t   __le16_to_cpu(phy->pre_set[i].data));\n\n\tlength = __le32_to_cpu(phy->blk_hdr.length);\n\tlength -= __le16_to_cpu(phy->fw_offset);\n\tnum = length / 2;\n\tdata = (__le16 *)((u8 *)phy + __le16_to_cpu(phy->fw_offset));\n\n\tocp_reg_write(tp, OCP_SRAM_ADDR, __le16_to_cpu(phy->fw_reg));\n\tfor (i = 0; i < num; i++)\n\t\tocp_reg_write(tp, OCP_SRAM_DATA, __le16_to_cpu(data[i]));\n\n\tnum = phy->bp_num;\n\tfor (i = 0; i < num; i++)\n\t\tsram_write(tp, __le16_to_cpu(phy->bp[i].addr), __le16_to_cpu(phy->bp[i].data));\n\n\tif (phy->bp_num && phy->bp_en.addr)\n\t\tsram_write(tp, __le16_to_cpu(phy->bp_en.addr), __le16_to_cpu(phy->bp_en.data));\n\n\tdev_dbg(&tp->intf->dev, \"successfully applied %s\\n\", phy->info);\n}\n\nstatic void rtl8152_fw_phy_nc_apply(struct r8152 *tp, struct fw_phy_nc *phy)\n{\n\tu16 mode_reg, bp_index;\n\tu32 length, i, num;\n\t__le16 *data;\n\n\trtl_reset_ocp_base(tp);\n\n\tmode_reg = __le16_to_cpu(phy->mode_reg);\n\tsram_write(tp, mode_reg, __le16_to_cpu(phy->mode_pre));\n\tsram_write(tp, __le16_to_cpu(phy->ba_reg),\n\t\t   __le16_to_cpu(phy->ba_data));\n\n\tlength = __le32_to_cpu(phy->blk_hdr.length);\n\tlength -= __le16_to_cpu(phy->fw_offset);\n\tnum = length / 2;\n\tdata = (__le16 *)((u8 *)phy + __le16_to_cpu(phy->fw_offset));\n\n\tocp_reg_write(tp, OCP_SRAM_ADDR, __le16_to_cpu(phy->fw_reg));\n\tfor (i = 0; i < num; i++)\n\t\tocp_reg_write(tp, OCP_SRAM_DATA, __le16_to_cpu(data[i]));\n\n\tsram_write(tp, __le16_to_cpu(phy->patch_en_addr),\n\t\t   __le16_to_cpu(phy->patch_en_value));\n\n\tbp_index = __le16_to_cpu(phy->bp_start);\n\tnum = __le16_to_cpu(phy->bp_num);\n\tfor (i = 0; i < num; i++) {\n\t\tsram_write(tp, bp_index, __le16_to_cpu(phy->bp[i]));\n\t\tbp_index += 2;\n\t}\n\n\tsram_write(tp, mode_reg, __le16_to_cpu(phy->mode_post));\n\n\tdev_dbg(&tp->intf->dev, \"successfully applied %s\\n\", phy->info);\n}\n\nstatic void rtl8152_fw_mac_apply(struct r8152 *tp, struct fw_mac *mac)\n{\n\tu16 bp_en_addr, type, fw_ver_reg;\n\tu32 length;\n\tu8 *data;\n\n\tswitch (__le32_to_cpu(mac->blk_hdr.type)) {\n\tcase RTL_FW_PLA:\n\t\ttype = MCU_TYPE_PLA;\n\t\tbreak;\n\tcase RTL_FW_USB:\n\t\ttype = MCU_TYPE_USB;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tfw_ver_reg = __le16_to_cpu(mac->fw_ver_reg);\n\tif (fw_ver_reg && ocp_read_byte(tp, MCU_TYPE_USB, fw_ver_reg) >= mac->fw_ver_data) {\n\t\tdev_dbg(&tp->intf->dev, \"%s firmware has been the newest\\n\", type ? \"PLA\" : \"USB\");\n\t\treturn;\n\t}\n\n\trtl_clear_bp(tp, type);\n\n\t \n\tif (tp->version == RTL_VER_04 && type == MCU_TYPE_PLA &&\n\t    !(ocp_read_word(tp, MCU_TYPE_PLA, PLA_MACDBG_POST) & DEBUG_OE)) {\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MACDBG_PRE, DEBUG_LTSSM);\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MACDBG_POST, DEBUG_LTSSM);\n\t}\n\n\tlength = __le32_to_cpu(mac->blk_hdr.length);\n\tlength -= __le16_to_cpu(mac->fw_offset);\n\n\tdata = (u8 *)mac;\n\tdata += __le16_to_cpu(mac->fw_offset);\n\n\tgeneric_ocp_write(tp, __le16_to_cpu(mac->fw_reg), 0xff, length, data,\n\t\t\t  type);\n\n\tocp_write_word(tp, type, __le16_to_cpu(mac->bp_ba_addr),\n\t\t       __le16_to_cpu(mac->bp_ba_value));\n\n\tgeneric_ocp_write(tp, __le16_to_cpu(mac->bp_start), BYTE_EN_DWORD,\n\t\t\t  __le16_to_cpu(mac->bp_num) << 1, mac->bp, type);\n\n\tbp_en_addr = __le16_to_cpu(mac->bp_en_addr);\n\tif (bp_en_addr)\n\t\tocp_write_word(tp, type, bp_en_addr,\n\t\t\t       __le16_to_cpu(mac->bp_en_value));\n\n\tif (fw_ver_reg)\n\t\tocp_write_byte(tp, MCU_TYPE_USB, fw_ver_reg,\n\t\t\t       mac->fw_ver_data);\n\n\tdev_dbg(&tp->intf->dev, \"successfully applied %s\\n\", mac->info);\n}\n\nstatic void rtl8152_apply_firmware(struct r8152 *tp, bool power_cut)\n{\n\tstruct rtl_fw *rtl_fw = &tp->rtl_fw;\n\tconst struct firmware *fw;\n\tstruct fw_header *fw_hdr;\n\tstruct fw_phy_patch_key *key;\n\tu16 key_addr = 0;\n\tint i, patch_phy = 1;\n\n\tif (IS_ERR_OR_NULL(rtl_fw->fw))\n\t\treturn;\n\n\tfw = rtl_fw->fw;\n\tfw_hdr = (struct fw_header *)fw->data;\n\n\tif (rtl_fw->pre_fw)\n\t\trtl_fw->pre_fw(tp);\n\n\tfor (i = offsetof(struct fw_header, blocks); i < fw->size;) {\n\t\tstruct fw_block *block = (struct fw_block *)&fw->data[i];\n\n\t\tswitch (__le32_to_cpu(block->type)) {\n\t\tcase RTL_FW_END:\n\t\t\tgoto post_fw;\n\t\tcase RTL_FW_PLA:\n\t\tcase RTL_FW_USB:\n\t\t\trtl8152_fw_mac_apply(tp, (struct fw_mac *)block);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_START:\n\t\t\tif (!patch_phy)\n\t\t\t\tbreak;\n\t\t\tkey = (struct fw_phy_patch_key *)block;\n\t\t\tkey_addr = __le16_to_cpu(key->key_reg);\n\t\t\trtl_pre_ram_code(tp, key_addr, __le16_to_cpu(key->key_data), !power_cut);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_STOP:\n\t\t\tif (!patch_phy)\n\t\t\t\tbreak;\n\t\t\tWARN_ON(!key_addr);\n\t\t\trtl_post_ram_code(tp, key_addr, !power_cut);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_NC:\n\t\t\trtl8152_fw_phy_nc_apply(tp, (struct fw_phy_nc *)block);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_VER:\n\t\t\tpatch_phy = rtl8152_fw_phy_ver(tp, (struct fw_phy_ver *)block);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_UNION_NC:\n\t\tcase RTL_FW_PHY_UNION_NC1:\n\t\tcase RTL_FW_PHY_UNION_NC2:\n\t\tcase RTL_FW_PHY_UNION_UC2:\n\t\tcase RTL_FW_PHY_UNION_UC:\n\t\tcase RTL_FW_PHY_UNION_MISC:\n\t\t\tif (patch_phy)\n\t\t\t\trtl8152_fw_phy_union_apply(tp, (struct fw_phy_union *)block);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_FIXUP:\n\t\t\tif (patch_phy)\n\t\t\t\trtl8152_fw_phy_fixup(tp, (struct fw_phy_fixup *)block);\n\t\t\tbreak;\n\t\tcase RTL_FW_PHY_SPEED_UP:\n\t\t\trtl_ram_code_speed_up(tp, (struct fw_phy_speed_up *)block, !power_cut);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\ti += ALIGN(__le32_to_cpu(block->length), 8);\n\t}\n\npost_fw:\n\tif (rtl_fw->post_fw)\n\t\trtl_fw->post_fw(tp);\n\n\trtl_reset_ocp_base(tp);\n\tstrscpy(rtl_fw->version, fw_hdr->version, RTL_VER_SIZE);\n\tdev_info(&tp->intf->dev, \"load %s successfully\\n\", rtl_fw->version);\n}\n\nstatic void rtl8152_release_firmware(struct r8152 *tp)\n{\n\tstruct rtl_fw *rtl_fw = &tp->rtl_fw;\n\n\tif (!IS_ERR_OR_NULL(rtl_fw->fw)) {\n\t\trelease_firmware(rtl_fw->fw);\n\t\trtl_fw->fw = NULL;\n\t}\n}\n\nstatic int rtl8152_request_firmware(struct r8152 *tp)\n{\n\tstruct rtl_fw *rtl_fw = &tp->rtl_fw;\n\tlong rc;\n\n\tif (rtl_fw->fw || !rtl_fw->fw_name) {\n\t\tdev_info(&tp->intf->dev, \"skip request firmware\\n\");\n\t\trc = 0;\n\t\tgoto result;\n\t}\n\n\trc = request_firmware(&rtl_fw->fw, rtl_fw->fw_name, &tp->intf->dev);\n\tif (rc < 0)\n\t\tgoto result;\n\n\trc = rtl8152_check_firmware(tp, rtl_fw);\n\tif (rc < 0)\n\t\trelease_firmware(rtl_fw->fw);\n\nresult:\n\tif (rc) {\n\t\trtl_fw->fw = ERR_PTR(rc);\n\n\t\tdev_warn(&tp->intf->dev,\n\t\t\t \"unable to load firmware patch %s (%ld)\\n\",\n\t\t\t rtl_fw->fw_name, rc);\n\t}\n\n\treturn rc;\n}\n\nstatic void r8152_aldps_en(struct r8152 *tp, bool enable)\n{\n\tif (enable) {\n\t\tocp_reg_write(tp, OCP_ALDPS_CONFIG, ENPWRSAVE | ENPDNPS |\n\t\t\t\t\t\t    LINKENA | DIS_SDSAVE);\n\t} else {\n\t\tocp_reg_write(tp, OCP_ALDPS_CONFIG, ENPDNPS | LINKENA |\n\t\t\t\t\t\t    DIS_SDSAVE);\n\t\tmsleep(20);\n\t}\n}\n\nstatic inline void r8152_mmd_indirect(struct r8152 *tp, u16 dev, u16 reg)\n{\n\tocp_reg_write(tp, OCP_EEE_AR, FUN_ADDR | dev);\n\tocp_reg_write(tp, OCP_EEE_DATA, reg);\n\tocp_reg_write(tp, OCP_EEE_AR, FUN_DATA | dev);\n}\n\nstatic u16 r8152_mmd_read(struct r8152 *tp, u16 dev, u16 reg)\n{\n\tu16 data;\n\n\tr8152_mmd_indirect(tp, dev, reg);\n\tdata = ocp_reg_read(tp, OCP_EEE_DATA);\n\tocp_reg_write(tp, OCP_EEE_AR, 0x0000);\n\n\treturn data;\n}\n\nstatic void r8152_mmd_write(struct r8152 *tp, u16 dev, u16 reg, u16 data)\n{\n\tr8152_mmd_indirect(tp, dev, reg);\n\tocp_reg_write(tp, OCP_EEE_DATA, data);\n\tocp_reg_write(tp, OCP_EEE_AR, 0x0000);\n}\n\nstatic void r8152_eee_en(struct r8152 *tp, bool enable)\n{\n\tu16 config1, config2, config3;\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);\n\tconfig1 = ocp_reg_read(tp, OCP_EEE_CONFIG1) & ~sd_rise_time_mask;\n\tconfig2 = ocp_reg_read(tp, OCP_EEE_CONFIG2);\n\tconfig3 = ocp_reg_read(tp, OCP_EEE_CONFIG3) & ~fast_snr_mask;\n\n\tif (enable) {\n\t\tocp_data |= EEE_RX_EN | EEE_TX_EN;\n\t\tconfig1 |= EEE_10_CAP | EEE_NWAY_EN | TX_QUIET_EN | RX_QUIET_EN;\n\t\tconfig1 |= sd_rise_time(1);\n\t\tconfig2 |= RG_DACQUIET_EN | RG_LDVQUIET_EN;\n\t\tconfig3 |= fast_snr(42);\n\t} else {\n\t\tocp_data &= ~(EEE_RX_EN | EEE_TX_EN);\n\t\tconfig1 &= ~(EEE_10_CAP | EEE_NWAY_EN | TX_QUIET_EN |\n\t\t\t     RX_QUIET_EN);\n\t\tconfig1 |= sd_rise_time(7);\n\t\tconfig2 &= ~(RG_DACQUIET_EN | RG_LDVQUIET_EN);\n\t\tconfig3 |= fast_snr(511);\n\t}\n\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_CR, ocp_data);\n\tocp_reg_write(tp, OCP_EEE_CONFIG1, config1);\n\tocp_reg_write(tp, OCP_EEE_CONFIG2, config2);\n\tocp_reg_write(tp, OCP_EEE_CONFIG3, config3);\n}\n\nstatic void r8153_eee_en(struct r8152 *tp, bool enable)\n{\n\tu32 ocp_data;\n\tu16 config;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);\n\tconfig = ocp_reg_read(tp, OCP_EEE_CFG);\n\n\tif (enable) {\n\t\tocp_data |= EEE_RX_EN | EEE_TX_EN;\n\t\tconfig |= EEE10_EN;\n\t} else {\n\t\tocp_data &= ~(EEE_RX_EN | EEE_TX_EN);\n\t\tconfig &= ~EEE10_EN;\n\t}\n\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_CR, ocp_data);\n\tocp_reg_write(tp, OCP_EEE_CFG, config);\n\n\ttp->ups_info.eee = enable;\n}\n\nstatic void r8156_eee_en(struct r8152 *tp, bool enable)\n{\n\tu16 config;\n\n\tr8153_eee_en(tp, enable);\n\n\tconfig = ocp_reg_read(tp, OCP_EEE_ADV2);\n\n\tif (enable)\n\t\tconfig |= MDIO_EEE_2_5GT;\n\telse\n\t\tconfig &= ~MDIO_EEE_2_5GT;\n\n\tocp_reg_write(tp, OCP_EEE_ADV2, config);\n}\n\nstatic void rtl_eee_enable(struct r8152 *tp, bool enable)\n{\n\tswitch (tp->version) {\n\tcase RTL_VER_01:\n\tcase RTL_VER_02:\n\tcase RTL_VER_07:\n\t\tif (enable) {\n\t\t\tr8152_eee_en(tp, true);\n\t\t\tr8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV,\n\t\t\t\t\ttp->eee_adv);\n\t\t} else {\n\t\t\tr8152_eee_en(tp, false);\n\t\t\tr8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, 0);\n\t\t}\n\t\tbreak;\n\tcase RTL_VER_03:\n\tcase RTL_VER_04:\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\tcase RTL_VER_08:\n\tcase RTL_VER_09:\n\tcase RTL_VER_14:\n\t\tif (enable) {\n\t\t\tr8153_eee_en(tp, true);\n\t\t\tocp_reg_write(tp, OCP_EEE_ADV, tp->eee_adv);\n\t\t} else {\n\t\t\tr8153_eee_en(tp, false);\n\t\t\tocp_reg_write(tp, OCP_EEE_ADV, 0);\n\t\t}\n\t\tbreak;\n\tcase RTL_VER_10:\n\tcase RTL_VER_11:\n\tcase RTL_VER_12:\n\tcase RTL_VER_13:\n\tcase RTL_VER_15:\n\t\tif (enable) {\n\t\t\tr8156_eee_en(tp, true);\n\t\t\tocp_reg_write(tp, OCP_EEE_ADV, tp->eee_adv);\n\t\t} else {\n\t\t\tr8156_eee_en(tp, false);\n\t\t\tocp_reg_write(tp, OCP_EEE_ADV, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void r8152b_enable_fc(struct r8152 *tp)\n{\n\tu16 anar;\n\n\tanar = r8152_mdio_read(tp, MII_ADVERTISE);\n\tanar |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\n\tr8152_mdio_write(tp, MII_ADVERTISE, anar);\n\n\ttp->ups_info.flow_control = true;\n}\n\nstatic void rtl8152_disable(struct r8152 *tp)\n{\n\tr8152_aldps_en(tp, false);\n\trtl_disable(tp);\n\tr8152_aldps_en(tp, true);\n}\n\nstatic void r8152b_hw_phy_cfg(struct r8152 *tp)\n{\n\trtl8152_apply_firmware(tp, false);\n\trtl_eee_enable(tp, tp->eee_en);\n\tr8152_aldps_en(tp, true);\n\tr8152b_enable_fc(tp);\n\n\tset_bit(PHY_RESET, &tp->flags);\n}\n\nstatic void wait_oob_link_list_ready(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tint i;\n\n\tfor (i = 0; i < 1000; i++) {\n\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\tbreak;\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\n\t\tif (ocp_data & LINK_LIST_READY)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n}\n\nstatic void r8156b_wait_loading_flash(struct r8152 *tp)\n{\n\tif ((ocp_read_word(tp, MCU_TYPE_PLA, PLA_GPHY_CTRL) & GPHY_FLASH) &&\n\t    !(ocp_read_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL) & BYPASS_FLASH)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\t\tbreak;\n\t\t\tif (ocp_read_word(tp, MCU_TYPE_USB, USB_GPHY_CTRL) & GPHY_PATCH_DONE)\n\t\t\t\tbreak;\n\t\t\tusleep_range(1000, 2000);\n\t\t}\n\t}\n}\n\nstatic void r8152b_exit_oob(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\n\tocp_data &= ~RCR_ACPT_ALL;\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\n\n\trxdy_gated_en(tp, true);\n\tr8153_teredo_off(tp);\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, 0x00);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\n\tocp_data &= ~NOW_IS_OOB;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\n\tocp_data &= ~MCU_BORW_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\n\n\twait_oob_link_list_ready(tp);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\n\tocp_data |= RE_INIT_LL;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\n\n\twait_oob_link_list_ready(tp);\n\n\trtl8152_nic_reset(tp);\n\n\t \n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_NORMAL);\n\n\tif (tp->udev->speed == USB_SPEED_FULL ||\n\t    tp->udev->speed == USB_SPEED_LOW) {\n\t\t \n\t\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1,\n\t\t\t\tRXFIFO_THR2_FULL);\n\t\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2,\n\t\t\t\tRXFIFO_THR3_FULL);\n\t} else {\n\t\t \n\t\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1,\n\t\t\t\tRXFIFO_THR2_HIGH);\n\t\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2,\n\t\t\t\tRXFIFO_THR3_HIGH);\n\t}\n\n\t \n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, TXFIFO_THR_NORMAL2);\n\n\tocp_write_byte(tp, MCU_TYPE_USB, USB_TX_AGG, TX_AGG_MAX_THRESHOLD);\n\tocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_HIGH);\n\tocp_write_dword(tp, MCU_TYPE_USB, USB_TX_DMA,\n\t\t\tTEST_MODE_DISABLE | TX_SIZE_ADJUST1);\n\n\trtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);\n\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8152_RMS);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0);\n\tocp_data |= TCR0_AUTO_FIFO;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_TCR0, ocp_data);\n}\n\nstatic void r8152b_enter_oob(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\n\tocp_data &= ~NOW_IS_OOB;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\n\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_OOB);\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_OOB);\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_OOB);\n\n\trtl_disable(tp);\n\n\twait_oob_link_list_ready(tp);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\n\tocp_data |= RE_INIT_LL;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\n\n\twait_oob_link_list_ready(tp);\n\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8152_RMS);\n\n\trtl_rx_vlan_en(tp, true);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BDC_CR);\n\tocp_data |= ALDPS_PROXY_MODE;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_BDC_CR, ocp_data);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\n\tocp_data |= NOW_IS_OOB | DIS_MCU_CLROOB;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\n\n\trxdy_gated_en(tp, false);\n\n\tocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\n\tocp_data |= RCR_APM | RCR_AM | RCR_AB;\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\n}\n\nstatic int r8153_pre_firmware_1(struct r8152 *tp)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 104; i++) {\n\t\tu32 ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_WDT1_CTRL);\n\n\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\treturn -ENODEV;\n\t\tif (!(ocp_data & WTD1_EN))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn 0;\n}\n\nstatic int r8153_post_firmware_1(struct r8152 *tp)\n{\n\t \n\tif (ocp_read_byte(tp, MCU_TYPE_USB, USB_CSTMR) & FORCE_SUPER)\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_BP_4, BP4_SUPER_ONLY);\n\n\t \n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_UPHY_TIMER, 36000 / 16);\n\n\treturn 0;\n}\n\nstatic int r8153_pre_firmware_2(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tr8153_pre_firmware_1(tp);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN0);\n\tocp_data &= ~FW_FIX_SUSPEND;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN0, ocp_data);\n\n\treturn 0;\n}\n\nstatic int r8153_post_firmware_2(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\t \n\tif (ocp_read_byte(tp, MCU_TYPE_USB, USB_CSTMR) & FORCE_SUPER) {\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BP_EN);\n\t\tocp_data |= BIT(0);\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, ocp_data);\n\t}\n\n\t \n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_UPHY_TIMER, 36000 / 16);\n\n\t \n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, U3P3_CHECK_EN | 4);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN0);\n\tocp_data |= FW_FIX_SUSPEND;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN0, ocp_data);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_USB2PHY);\n\tocp_data |= USB2PHY_L1 | USB2PHY_SUSPEND;\n\tocp_write_byte(tp, MCU_TYPE_USB, USB_USB2PHY, ocp_data);\n\n\treturn 0;\n}\n\nstatic int r8153_post_firmware_3(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_USB2PHY);\n\tocp_data |= USB2PHY_L1 | USB2PHY_SUSPEND;\n\tocp_write_byte(tp, MCU_TYPE_USB, USB_USB2PHY, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1);\n\tocp_data |= FW_IP_RESET_EN;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1, ocp_data);\n\n\treturn 0;\n}\n\nstatic int r8153b_pre_firmware_1(struct r8152 *tp)\n{\n\t \n\tocp_write_word(tp, MCU_TYPE_USB, USB_FC_TIMER,\n\t\t       CTRL_TIMER_EN | (1000 / 8));\n\n\treturn 0;\n}\n\nstatic int r8153b_post_firmware_1(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\t \n\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_1);\n\tif (ocp_data & BND_MASK) {\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BP_EN);\n\t\tocp_data |= BIT(0);\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, ocp_data);\n\t}\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_CTRL);\n\tocp_data |= FLOW_CTRL_PATCH_OPT;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_CTRL, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);\n\tocp_data |= FC_PATCH_TASK;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1);\n\tocp_data |= FW_IP_RESET_EN;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1, ocp_data);\n\n\treturn 0;\n}\n\nstatic int r8153c_post_firmware_1(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_CTRL);\n\tocp_data |= FLOW_CTRL_PATCH_2;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_CTRL, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);\n\tocp_data |= FC_PATCH_TASK;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);\n\n\treturn 0;\n}\n\nstatic int r8156a_post_firmware_1(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1);\n\tocp_data |= FW_IP_RESET_EN;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_FIX_EN1, ocp_data);\n\n\t \n\tocp_write_dword(tp, MCU_TYPE_USB, USB_UPHY3_MDCMDIO, 0x4026840e);\n\tocp_write_dword(tp, MCU_TYPE_USB, USB_UPHY3_MDCMDIO, 0x4001acc9);\n\n\treturn 0;\n}\n\nstatic void r8153_aldps_en(struct r8152 *tp, bool enable)\n{\n\tu16 data;\n\n\tdata = ocp_reg_read(tp, OCP_POWER_CFG);\n\tif (enable) {\n\t\tdata |= EN_ALDPS;\n\t\tocp_reg_write(tp, OCP_POWER_CFG, data);\n\t} else {\n\t\tint i;\n\n\t\tdata &= ~EN_ALDPS;\n\t\tocp_reg_write(tp, OCP_POWER_CFG, data);\n\t\tfor (i = 0; i < 20; i++) {\n\t\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\t\treturn;\n\t\t\tusleep_range(1000, 2000);\n\t\t\tif (ocp_read_word(tp, MCU_TYPE_PLA, 0xe000) & 0x0100)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\ttp->ups_info.aldps = enable;\n}\n\nstatic void r8153_hw_phy_cfg(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tu16 data;\n\n\t \n\tr8153_aldps_en(tp, false);\n\n\t \n\trtl_eee_enable(tp, false);\n\n\trtl8152_apply_firmware(tp, false);\n\n\tif (tp->version == RTL_VER_03) {\n\t\tdata = ocp_reg_read(tp, OCP_EEE_CFG);\n\t\tdata &= ~CTAP_SHORT_EN;\n\t\tocp_reg_write(tp, OCP_EEE_CFG, data);\n\t}\n\n\tdata = ocp_reg_read(tp, OCP_POWER_CFG);\n\tdata |= EEE_CLKDIV_EN;\n\tocp_reg_write(tp, OCP_POWER_CFG, data);\n\n\tdata = ocp_reg_read(tp, OCP_DOWN_SPEED);\n\tdata |= EN_10M_BGOFF;\n\tocp_reg_write(tp, OCP_DOWN_SPEED, data);\n\tdata = ocp_reg_read(tp, OCP_POWER_CFG);\n\tdata |= EN_10M_PLLOFF;\n\tocp_reg_write(tp, OCP_POWER_CFG, data);\n\tsram_write(tp, SRAM_IMPEDANCE, 0x0b13);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);\n\tocp_data |= PFM_PWM_SWITCH;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);\n\n\t \n\tsram_write(tp, SRAM_LPF_CFG, 0xf70f);\n\n\t \n\tsram_write(tp, SRAM_10M_AMP1, 0x00af);\n\tsram_write(tp, SRAM_10M_AMP2, 0x0208);\n\n\tif (tp->eee_en)\n\t\trtl_eee_enable(tp, true);\n\n\tr8153_aldps_en(tp, true);\n\tr8152b_enable_fc(tp);\n\n\tswitch (tp->version) {\n\tcase RTL_VER_03:\n\tcase RTL_VER_04:\n\t\tbreak;\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\tdefault:\n\t\tr8153_u2p3en(tp, true);\n\t\tbreak;\n\t}\n\n\tset_bit(PHY_RESET, &tp->flags);\n}\n\nstatic u32 r8152_efuse_read(struct r8152 *tp, u8 addr)\n{\n\tu32 ocp_data;\n\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EFUSE_CMD, EFUSE_READ_CMD | addr);\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EFUSE_CMD);\n\tocp_data = (ocp_data & EFUSE_DATA_BIT16) << 9;\t \n\tocp_data |= ocp_read_word(tp, MCU_TYPE_PLA, PLA_EFUSE_DATA);\n\n\treturn ocp_data;\n}\n\nstatic void r8153b_hw_phy_cfg(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tu16 data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);\n\tif (ocp_data & PCUT_STATUS) {\n\t\tocp_data &= ~PCUT_STATUS;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);\n\t}\n\n\t \n\tr8153_aldps_en(tp, false);\n\n\t \n\trtl_eee_enable(tp, false);\n\n\t \n\tocp_write_word(tp, MCU_TYPE_USB, USB_U1U2_TIMER, 500);\n\n\tdata = r8153_phy_status(tp, 0);\n\n\tswitch (data) {\n\tcase PHY_STAT_PWRDN:\n\tcase PHY_STAT_EXT_INIT:\n\t\trtl8152_apply_firmware(tp, true);\n\n\t\tdata = r8152_mdio_read(tp, MII_BMCR);\n\t\tdata &= ~BMCR_PDOWN;\n\t\tr8152_mdio_write(tp, MII_BMCR, data);\n\t\tbreak;\n\tcase PHY_STAT_LAN_ON:\n\tdefault:\n\t\trtl8152_apply_firmware(tp, false);\n\t\tbreak;\n\t}\n\n\tr8153b_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));\n\n\tdata = sram_read(tp, SRAM_GREEN_CFG);\n\tdata |= R_TUNE_EN;\n\tsram_write(tp, SRAM_GREEN_CFG, data);\n\tdata = ocp_reg_read(tp, OCP_NCTL_CFG);\n\tdata |= PGA_RETURN_EN;\n\tocp_reg_write(tp, OCP_NCTL_CFG, data);\n\n\t \n\tocp_data = r8152_efuse_read(tp, 0x7d);\n\tdata = (u16)(((ocp_data & 0x1fff0) >> 1) | (ocp_data & 0x7));\n\tif (data != 0xffff)\n\t\tocp_reg_write(tp, OCP_ADC_IOFFSET, data);\n\n\t \n\tocp_data = ocp_reg_read(tp, 0xc426);\n\tocp_data &= 0x3fff;\n\tif (ocp_data) {\n\t\tu32 swr_cnt_1ms_ini;\n\n\t\tswr_cnt_1ms_ini = (16000000 / ocp_data) & SAW_CNT_1MS_MASK;\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_UPS_CFG);\n\t\tocp_data = (ocp_data & ~SAW_CNT_1MS_MASK) | swr_cnt_1ms_ini;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_UPS_CFG, ocp_data);\n\t}\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);\n\tocp_data |= PFM_PWM_SWITCH;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);\n\n\t \n\tif (!rtl_phy_patch_request(tp, true, true)) {\n\t\tdata = ocp_reg_read(tp, OCP_POWER_CFG);\n\t\tdata |= EEE_CLKDIV_EN;\n\t\tocp_reg_write(tp, OCP_POWER_CFG, data);\n\t\ttp->ups_info.eee_ckdiv = true;\n\n\t\tdata = ocp_reg_read(tp, OCP_DOWN_SPEED);\n\t\tdata |= EN_EEE_CMODE | EN_EEE_1000 | EN_10M_CLKDIV;\n\t\tocp_reg_write(tp, OCP_DOWN_SPEED, data);\n\t\ttp->ups_info.eee_cmod_lv = true;\n\t\ttp->ups_info._10m_ckdiv = true;\n\t\ttp->ups_info.eee_plloff_giga = true;\n\n\t\tocp_reg_write(tp, OCP_SYSCLK_CFG, 0);\n\t\tocp_reg_write(tp, OCP_SYSCLK_CFG, clk_div_expo(5));\n\t\ttp->ups_info._250m_ckdiv = true;\n\n\t\trtl_phy_patch_request(tp, false, true);\n\t}\n\n\tif (tp->eee_en)\n\t\trtl_eee_enable(tp, true);\n\n\tr8153_aldps_en(tp, true);\n\tr8152b_enable_fc(tp);\n\n\tset_bit(PHY_RESET, &tp->flags);\n}\n\nstatic void r8153c_hw_phy_cfg(struct r8152 *tp)\n{\n\tr8153b_hw_phy_cfg(tp);\n\n\ttp->ups_info.r_tune = true;\n}\n\nstatic void rtl8153_change_mtu(struct r8152 *tp)\n{\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, mtu_to_size(tp->netdev->mtu));\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_JUMBO);\n}\n\nstatic void r8153_first_init(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\trxdy_gated_en(tp, true);\n\tr8153_teredo_off(tp);\n\n\tocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\n\tocp_data &= ~RCR_ACPT_ALL;\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\n\n\trtl8152_nic_reset(tp);\n\trtl_reset_bmu(tp);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\n\tocp_data &= ~NOW_IS_OOB;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\n\tocp_data &= ~MCU_BORW_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\n\n\twait_oob_link_list_ready(tp);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\n\tocp_data |= RE_INIT_LL;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\n\n\twait_oob_link_list_ready(tp);\n\n\trtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);\n\n\trtl8153_change_mtu(tp);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0);\n\tocp_data |= TCR0_AUTO_FIFO;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_TCR0, ocp_data);\n\n\trtl8152_nic_reset(tp);\n\n\t \n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_NORMAL);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_NORMAL);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_NORMAL);\n\t \n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, TXFIFO_THR_NORMAL2);\n}\n\nstatic void r8153_enter_oob(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\n\tocp_data &= ~NOW_IS_OOB;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\n\n\t \n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_OOB);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_OOB);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_OOB);\n\n\trtl_disable(tp);\n\trtl_reset_bmu(tp);\n\n\twait_oob_link_list_ready(tp);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\n\tocp_data |= RE_INIT_LL;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\n\n\twait_oob_link_list_ready(tp);\n\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, 1522);\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_DEFAULT);\n\n\tswitch (tp->version) {\n\tcase RTL_VER_03:\n\tcase RTL_VER_04:\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG);\n\t\tocp_data &= ~TEREDO_WAKE_MASK;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG, ocp_data);\n\t\tbreak;\n\n\tcase RTL_VER_08:\n\tcase RTL_VER_09:\n\tcase RTL_VER_14:\n\t\t \n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_WAKE_BASE, 0x00ff);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\trtl_rx_vlan_en(tp, true);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_BDC_CR);\n\tocp_data |= ALDPS_PROXY_MODE;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_BDC_CR, ocp_data);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\n\tocp_data |= NOW_IS_OOB | DIS_MCU_CLROOB;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\n\tocp_data |= MCU_BORW_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\n\n\trxdy_gated_en(tp, false);\n\n\tocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\n\tocp_data |= RCR_APM | RCR_AM | RCR_AB;\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\n}\n\nstatic void rtl8153_disable(struct r8152 *tp)\n{\n\tr8153_aldps_en(tp, false);\n\trtl_disable(tp);\n\trtl_reset_bmu(tp);\n\tr8153_aldps_en(tp, true);\n}\n\nstatic u32 fc_pause_on_auto(struct r8152 *tp)\n{\n\treturn (ALIGN(mtu_to_size(tp->netdev->mtu), 1024) + 6 * 1024);\n}\n\nstatic u32 fc_pause_off_auto(struct r8152 *tp)\n{\n\treturn (ALIGN(mtu_to_size(tp->netdev->mtu), 1024) + 14 * 1024);\n}\n\nstatic void r8156_fc_parameter(struct r8152 *tp)\n{\n\tu32 pause_on = tp->fc_pause_on ? tp->fc_pause_on : fc_pause_on_auto(tp);\n\tu32 pause_off = tp->fc_pause_off ? tp->fc_pause_off : fc_pause_off_auto(tp);\n\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, pause_on / 16);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, pause_off / 16);\n}\n\nstatic int rtl8156_enable(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tu16 speed;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn -ENODEV;\n\n\tr8156_fc_parameter(tp);\n\tset_tx_qlen(tp);\n\trtl_set_eee_plus(tp);\n\tr8153_set_rx_early_timeout(tp);\n\tr8153_set_rx_early_size(tp);\n\n\tspeed = rtl8152_get_speed(tp);\n\trtl_set_ifg(tp, speed);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4);\n\tif (speed & _2500bps)\n\t\tocp_data &= ~IDLE_SPDWN_EN;\n\telse\n\t\tocp_data |= IDLE_SPDWN_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, ocp_data);\n\n\tif (speed & _1000bps)\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_TXTWSYS, 0x11);\n\telse if (speed & _500bps)\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_TXTWSYS, 0x3d);\n\n\tif (tp->udev->speed == USB_SPEED_HIGH) {\n\t\t \n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_L1_CTRL);\n\t\tocp_data &= ~0xf;\n\t\tif (is_flow_control(speed))\n\t\t\tocp_data |= 0xf;\n\t\telse\n\t\t\tocp_data |= 0x1;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_L1_CTRL, ocp_data);\n\t}\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);\n\tocp_data &= ~FC_PATCH_TASK;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);\n\tusleep_range(1000, 2000);\n\tocp_data |= FC_PATCH_TASK;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);\n\n\treturn rtl_enable(tp);\n}\n\nstatic void rtl8156_disable(struct r8152 *tp)\n{\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, 0);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, 0);\n\n\trtl8153_disable(tp);\n}\n\nstatic int rtl8156b_enable(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tu16 speed;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn -ENODEV;\n\n\tset_tx_qlen(tp);\n\trtl_set_eee_plus(tp);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_RX_AGGR_NUM);\n\tocp_data &= ~RX_AGGR_NUM_MASK;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_RX_AGGR_NUM, ocp_data);\n\n\tr8153_set_rx_early_timeout(tp);\n\tr8153_set_rx_early_size(tp);\n\n\tspeed = rtl8152_get_speed(tp);\n\trtl_set_ifg(tp, speed);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4);\n\tif (speed & _2500bps)\n\t\tocp_data &= ~IDLE_SPDWN_EN;\n\telse\n\t\tocp_data |= IDLE_SPDWN_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, ocp_data);\n\n\tif (tp->udev->speed == USB_SPEED_HIGH) {\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_L1_CTRL);\n\t\tocp_data &= ~0xf;\n\t\tif (is_flow_control(speed))\n\t\t\tocp_data |= 0xf;\n\t\telse\n\t\t\tocp_data |= 0x1;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_L1_CTRL, ocp_data);\n\t}\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);\n\tocp_data &= ~FC_PATCH_TASK;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);\n\tusleep_range(1000, 2000);\n\tocp_data |= FC_PATCH_TASK;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);\n\n\treturn rtl_enable(tp);\n}\n\nstatic int rtl8152_set_speed(struct r8152 *tp, u8 autoneg, u32 speed, u8 duplex,\n\t\t\t     u32 advertising)\n{\n\tu16 bmcr;\n\tint ret = 0;\n\n\tif (autoneg == AUTONEG_DISABLE) {\n\t\tif (duplex != DUPLEX_HALF && duplex != DUPLEX_FULL)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (speed) {\n\t\tcase SPEED_10:\n\t\t\tbmcr = BMCR_SPEED10;\n\t\t\tif (duplex == DUPLEX_FULL) {\n\t\t\t\tbmcr |= BMCR_FULLDPLX;\n\t\t\t\ttp->ups_info.speed_duplex = FORCE_10M_FULL;\n\t\t\t} else {\n\t\t\t\ttp->ups_info.speed_duplex = FORCE_10M_HALF;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tbmcr = BMCR_SPEED100;\n\t\t\tif (duplex == DUPLEX_FULL) {\n\t\t\t\tbmcr |= BMCR_FULLDPLX;\n\t\t\t\ttp->ups_info.speed_duplex = FORCE_100M_FULL;\n\t\t\t} else {\n\t\t\t\ttp->ups_info.speed_duplex = FORCE_100M_HALF;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tif (tp->mii.supports_gmii) {\n\t\t\t\tbmcr = BMCR_SPEED1000 | BMCR_FULLDPLX;\n\t\t\t\ttp->ups_info.speed_duplex = NWAY_1000M_FULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (duplex == DUPLEX_FULL)\n\t\t\ttp->mii.full_duplex = 1;\n\t\telse\n\t\t\ttp->mii.full_duplex = 0;\n\n\t\ttp->mii.force_media = 1;\n\t} else {\n\t\tu16 orig, new1;\n\t\tu32 support;\n\n\t\tsupport = RTL_ADVERTISED_10_HALF | RTL_ADVERTISED_10_FULL |\n\t\t\t  RTL_ADVERTISED_100_HALF | RTL_ADVERTISED_100_FULL;\n\n\t\tif (tp->mii.supports_gmii) {\n\t\t\tsupport |= RTL_ADVERTISED_1000_FULL;\n\n\t\t\tif (tp->support_2500full)\n\t\t\t\tsupport |= RTL_ADVERTISED_2500_FULL;\n\t\t}\n\n\t\tif (!(advertising & support))\n\t\t\treturn -EINVAL;\n\n\t\torig = r8152_mdio_read(tp, MII_ADVERTISE);\n\t\tnew1 = orig & ~(ADVERTISE_10HALF | ADVERTISE_10FULL |\n\t\t\t\tADVERTISE_100HALF | ADVERTISE_100FULL);\n\t\tif (advertising & RTL_ADVERTISED_10_HALF) {\n\t\t\tnew1 |= ADVERTISE_10HALF;\n\t\t\ttp->ups_info.speed_duplex = NWAY_10M_HALF;\n\t\t}\n\t\tif (advertising & RTL_ADVERTISED_10_FULL) {\n\t\t\tnew1 |= ADVERTISE_10FULL;\n\t\t\ttp->ups_info.speed_duplex = NWAY_10M_FULL;\n\t\t}\n\n\t\tif (advertising & RTL_ADVERTISED_100_HALF) {\n\t\t\tnew1 |= ADVERTISE_100HALF;\n\t\t\ttp->ups_info.speed_duplex = NWAY_100M_HALF;\n\t\t}\n\t\tif (advertising & RTL_ADVERTISED_100_FULL) {\n\t\t\tnew1 |= ADVERTISE_100FULL;\n\t\t\ttp->ups_info.speed_duplex = NWAY_100M_FULL;\n\t\t}\n\n\t\tif (orig != new1) {\n\t\t\tr8152_mdio_write(tp, MII_ADVERTISE, new1);\n\t\t\ttp->mii.advertising = new1;\n\t\t}\n\n\t\tif (tp->mii.supports_gmii) {\n\t\t\torig = r8152_mdio_read(tp, MII_CTRL1000);\n\t\t\tnew1 = orig & ~(ADVERTISE_1000FULL |\n\t\t\t\t\tADVERTISE_1000HALF);\n\n\t\t\tif (advertising & RTL_ADVERTISED_1000_FULL) {\n\t\t\t\tnew1 |= ADVERTISE_1000FULL;\n\t\t\t\ttp->ups_info.speed_duplex = NWAY_1000M_FULL;\n\t\t\t}\n\n\t\t\tif (orig != new1)\n\t\t\t\tr8152_mdio_write(tp, MII_CTRL1000, new1);\n\t\t}\n\n\t\tif (tp->support_2500full) {\n\t\t\torig = ocp_reg_read(tp, OCP_10GBT_CTRL);\n\t\t\tnew1 = orig & ~MDIO_AN_10GBT_CTRL_ADV2_5G;\n\n\t\t\tif (advertising & RTL_ADVERTISED_2500_FULL) {\n\t\t\t\tnew1 |= MDIO_AN_10GBT_CTRL_ADV2_5G;\n\t\t\t\ttp->ups_info.speed_duplex = NWAY_2500M_FULL;\n\t\t\t}\n\n\t\t\tif (orig != new1)\n\t\t\t\tocp_reg_write(tp, OCP_10GBT_CTRL, new1);\n\t\t}\n\n\t\tbmcr = BMCR_ANENABLE | BMCR_ANRESTART;\n\n\t\ttp->mii.force_media = 0;\n\t}\n\n\tif (test_and_clear_bit(PHY_RESET, &tp->flags))\n\t\tbmcr |= BMCR_RESET;\n\n\tr8152_mdio_write(tp, MII_BMCR, bmcr);\n\n\tif (bmcr & BMCR_RESET) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 50; i++) {\n\t\t\tmsleep(20);\n\t\t\tif ((r8152_mdio_read(tp, MII_BMCR) & BMCR_RESET) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic void rtl8152_up(struct r8152 *tp)\n{\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tr8152_aldps_en(tp, false);\n\tr8152b_exit_oob(tp);\n\tr8152_aldps_en(tp, true);\n}\n\nstatic void rtl8152_down(struct r8152 *tp)\n{\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags)) {\n\t\trtl_drop_queued_tx(tp);\n\t\treturn;\n\t}\n\n\tr8152_power_cut_en(tp, false);\n\tr8152_aldps_en(tp, false);\n\tr8152b_enter_oob(tp);\n\tr8152_aldps_en(tp, true);\n}\n\nstatic void rtl8153_up(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tr8153_u1u2en(tp, false);\n\tr8153_u2p3en(tp, false);\n\tr8153_aldps_en(tp, false);\n\tr8153_first_init(tp);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6);\n\tocp_data |= LANWAKE_CLR_EN;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6, ocp_data);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_LWAKE_CTRL_REG);\n\tocp_data &= ~LANWAKE_PIN;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_LWAKE_CTRL_REG, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SSPHYLINK1);\n\tocp_data &= ~DELAY_PHY_PWR_CHG;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_SSPHYLINK1, ocp_data);\n\n\tr8153_aldps_en(tp, true);\n\n\tswitch (tp->version) {\n\tcase RTL_VER_03:\n\tcase RTL_VER_04:\n\t\tbreak;\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\tdefault:\n\t\tr8153_u2p3en(tp, true);\n\t\tbreak;\n\t}\n\n\tr8153_u1u2en(tp, true);\n}\n\nstatic void rtl8153_down(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags)) {\n\t\trtl_drop_queued_tx(tp);\n\t\treturn;\n\t}\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6);\n\tocp_data &= ~LANWAKE_CLR_EN;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6, ocp_data);\n\n\tr8153_u1u2en(tp, false);\n\tr8153_u2p3en(tp, false);\n\tr8153_power_cut_en(tp, false);\n\tr8153_aldps_en(tp, false);\n\tr8153_enter_oob(tp);\n\tr8153_aldps_en(tp, true);\n}\n\nstatic void rtl8153b_up(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tr8153b_u1u2en(tp, false);\n\tr8153_u2p3en(tp, false);\n\tr8153_aldps_en(tp, false);\n\n\tr8153_first_init(tp);\n\tocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_B);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);\n\tocp_data &= ~PLA_MCU_SPDWN_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);\n\n\tr8153_aldps_en(tp, true);\n\n\tif (tp->udev->speed >= USB_SPEED_SUPER)\n\t\tr8153b_u1u2en(tp, true);\n}\n\nstatic void rtl8153b_down(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags)) {\n\t\trtl_drop_queued_tx(tp);\n\t\treturn;\n\t}\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);\n\tocp_data |= PLA_MCU_SPDWN_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);\n\n\tr8153b_u1u2en(tp, false);\n\tr8153_u2p3en(tp, false);\n\tr8153b_power_cut_en(tp, false);\n\tr8153_aldps_en(tp, false);\n\tr8153_enter_oob(tp);\n\tr8153_aldps_en(tp, true);\n}\n\nstatic void rtl8153c_change_mtu(struct r8152 *tp)\n{\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, mtu_to_size(tp->netdev->mtu));\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, 10 * 1024 / 64);\n\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, 512 / 64);\n\n\t \n\tif (tp->netdev->mtu < 8000)\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL, 2048 / 8);\n\telse\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL, 900 / 8);\n}\n\nstatic void rtl8153c_up(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tr8153b_u1u2en(tp, false);\n\tr8153_u2p3en(tp, false);\n\tr8153_aldps_en(tp, false);\n\n\trxdy_gated_en(tp, true);\n\tr8153_teredo_off(tp);\n\n\tocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\n\tocp_data &= ~RCR_ACPT_ALL;\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\n\n\trtl8152_nic_reset(tp);\n\trtl_reset_bmu(tp);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\n\tocp_data &= ~NOW_IS_OOB;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\n\tocp_data &= ~MCU_BORW_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\n\n\twait_oob_link_list_ready(tp);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\n\tocp_data |= RE_INIT_LL;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\n\n\twait_oob_link_list_ready(tp);\n\n\trtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);\n\n\trtl8153c_change_mtu(tp);\n\n\trtl8152_nic_reset(tp);\n\n\t \n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, 0x02);\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, 0x08);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_NORMAL);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_NORMAL);\n\n\tocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_B);\n\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);\n\tocp_data |= BIT(8);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, ocp_data);\n\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);\n\tocp_data &= ~PLA_MCU_SPDWN_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);\n\n\tr8153_aldps_en(tp, true);\n\tr8153b_u1u2en(tp, true);\n}\n\nstatic void rtl8156_change_mtu(struct r8152 *tp)\n{\n\tu32 rx_max_size = mtu_to_size(tp->netdev->mtu);\n\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, rx_max_size);\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_JUMBO);\n\tr8156_fc_parameter(tp);\n\n\t \n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, 512 / 64);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_TXFIFO_FULL,\n\t\t       ALIGN(rx_max_size + sizeof(struct tx_desc), 1024) / 16);\n}\n\nstatic void rtl8156_up(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tr8153b_u1u2en(tp, false);\n\tr8153_u2p3en(tp, false);\n\tr8153_aldps_en(tp, false);\n\n\trxdy_gated_en(tp, true);\n\tr8153_teredo_off(tp);\n\n\tocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\n\tocp_data &= ~RCR_ACPT_ALL;\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\n\n\trtl8152_nic_reset(tp);\n\trtl_reset_bmu(tp);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\n\tocp_data &= ~NOW_IS_OOB;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\n\tocp_data &= ~MCU_BORW_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\n\n\trtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);\n\n\trtl8156_change_mtu(tp);\n\n\tswitch (tp->version) {\n\tcase RTL_TEST_01:\n\tcase RTL_VER_10:\n\tcase RTL_VER_11:\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_BMU_CONFIG);\n\t\tocp_data |= ACT_ODMA;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_BMU_CONFIG, ocp_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL);\n\tocp_data &= ~RXFIFO_FULL_MASK;\n\tocp_data |= 0x08;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);\n\tocp_data &= ~PLA_MCU_SPDWN_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION);\n\tocp_data &= ~(RG_PWRDN_EN | ALL_SPEED_OFF);\n\tocp_write_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION, ocp_data);\n\n\tocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, 0x00600400);\n\n\tif (tp->saved_wolopts != __rtl_get_wol(tp)) {\n\t\tnetif_warn(tp, ifup, tp->netdev, \"wol setting is changed\\n\");\n\t\t__rtl_set_wol(tp, tp->saved_wolopts);\n\t}\n\n\tr8153_aldps_en(tp, true);\n\tr8153_u2p3en(tp, true);\n\n\tif (tp->udev->speed >= USB_SPEED_SUPER)\n\t\tr8153b_u1u2en(tp, true);\n}\n\nstatic void rtl8156_down(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags)) {\n\t\trtl_drop_queued_tx(tp);\n\t\treturn;\n\t}\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);\n\tocp_data |= PLA_MCU_SPDWN_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);\n\n\tr8153b_u1u2en(tp, false);\n\tr8153_u2p3en(tp, false);\n\tr8153b_power_cut_en(tp, false);\n\tr8153_aldps_en(tp, false);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\n\tocp_data &= ~NOW_IS_OOB;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\n\n\t \n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_FULL, 64 / 16);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_FULL, 1024 / 16);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RX_FIFO_EMPTY, 4096 / 16);\n\n\trtl_disable(tp);\n\trtl_reset_bmu(tp);\n\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, 1522);\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_DEFAULT);\n\n\t \n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_WAKE_BASE, 0x00ff);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);\n\tocp_data |= NOW_IS_OOB;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);\n\tocp_data |= MCU_BORW_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);\n\n\trtl_rx_vlan_en(tp, true);\n\trxdy_gated_en(tp, false);\n\n\tocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\n\tocp_data |= RCR_APM | RCR_AM | RCR_AB;\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\n\n\tr8153_aldps_en(tp, true);\n}\n\nstatic bool rtl8152_in_nway(struct r8152 *tp)\n{\n\tu16 nway_state;\n\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, 0x2000);\n\ttp->ocp_base = 0x2000;\n\tocp_write_byte(tp, MCU_TYPE_PLA, 0xb014, 0x4c);\t\t \n\tnway_state = ocp_read_word(tp, MCU_TYPE_PLA, 0xb01a);\n\n\t \n\tif (nway_state & 0xc000)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nstatic bool rtl8153_in_nway(struct r8152 *tp)\n{\n\tu16 phy_state = ocp_reg_read(tp, OCP_PHY_STATE) & 0xff;\n\n\tif (phy_state == TXDIS_STATE || phy_state == ABD_STATE)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nstatic void r8156_mdio_force_mode(struct r8152 *tp)\n{\n\tu16 data;\n\n\t \n\tdata = ocp_reg_read(tp, 0xa5b4);\n\tif (data & BIT(15)) {\n\t\tdata &= ~BIT(15);\n\t\tocp_reg_write(tp, 0xa5b4, data);\n\t}\n}\n\nstatic void set_carrier(struct r8152 *tp)\n{\n\tstruct net_device *netdev = tp->netdev;\n\tstruct napi_struct *napi = &tp->napi;\n\tu16 speed;\n\n\tspeed = rtl8152_get_speed(tp);\n\n\tif (speed & LINK_STATUS) {\n\t\tif (!netif_carrier_ok(netdev)) {\n\t\t\ttp->rtl_ops.enable(tp);\n\t\t\tnetif_stop_queue(netdev);\n\t\t\tnapi_disable(napi);\n\t\t\tnetif_carrier_on(netdev);\n\t\t\trtl_start_rx(tp);\n\t\t\tclear_bit(RTL8152_SET_RX_MODE, &tp->flags);\n\t\t\t_rtl8152_set_rx_mode(netdev);\n\t\t\tnapi_enable(napi);\n\t\t\tnetif_wake_queue(netdev);\n\t\t\tnetif_info(tp, link, netdev, \"carrier on\\n\");\n\t\t} else if (netif_queue_stopped(netdev) &&\n\t\t\t   skb_queue_len(&tp->tx_queue) < tp->tx_qlen) {\n\t\t\tnetif_wake_queue(netdev);\n\t\t}\n\t} else {\n\t\tif (netif_carrier_ok(netdev)) {\n\t\t\tnetif_carrier_off(netdev);\n\t\t\ttasklet_disable(&tp->tx_tl);\n\t\t\tnapi_disable(napi);\n\t\t\ttp->rtl_ops.disable(tp);\n\t\t\tnapi_enable(napi);\n\t\t\ttasklet_enable(&tp->tx_tl);\n\t\t\tnetif_info(tp, link, netdev, \"carrier off\\n\");\n\t\t}\n\t}\n}\n\nstatic void rtl_work_func_t(struct work_struct *work)\n{\n\tstruct r8152 *tp = container_of(work, struct r8152, schedule.work);\n\n\t \n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags) || !netif_running(tp->netdev))\n\t\treturn;\n\n\tif (usb_autopm_get_interface(tp->intf) < 0)\n\t\treturn;\n\n\tif (!test_bit(WORK_ENABLE, &tp->flags))\n\t\tgoto out1;\n\n\tif (!mutex_trylock(&tp->control)) {\n\t\tschedule_delayed_work(&tp->schedule, 0);\n\t\tgoto out1;\n\t}\n\n\tif (test_and_clear_bit(RTL8152_LINK_CHG, &tp->flags))\n\t\tset_carrier(tp);\n\n\tif (test_and_clear_bit(RTL8152_SET_RX_MODE, &tp->flags))\n\t\t_rtl8152_set_rx_mode(tp->netdev);\n\n\t \n\tif (test_and_clear_bit(SCHEDULE_TASKLET, &tp->flags) &&\n\t    netif_carrier_ok(tp->netdev))\n\t\ttasklet_schedule(&tp->tx_tl);\n\n\tif (test_and_clear_bit(RX_EPROTO, &tp->flags) &&\n\t    !list_empty(&tp->rx_done))\n\t\tnapi_schedule(&tp->napi);\n\n\tmutex_unlock(&tp->control);\n\nout1:\n\tusb_autopm_put_interface(tp->intf);\n}\n\nstatic void rtl_hw_phy_work_func_t(struct work_struct *work)\n{\n\tstruct r8152 *tp = container_of(work, struct r8152, hw_phy_work.work);\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tif (usb_autopm_get_interface(tp->intf) < 0)\n\t\treturn;\n\n\tmutex_lock(&tp->control);\n\n\tif (rtl8152_request_firmware(tp) == -ENODEV && tp->rtl_fw.retry) {\n\t\ttp->rtl_fw.retry = false;\n\t\ttp->rtl_fw.fw = NULL;\n\n\t\t \n\t\tqueue_delayed_work(system_long_wq, &tp->hw_phy_work, HZ * 10);\n\t\tgoto ignore_once;\n\t}\n\n\ttp->rtl_ops.hw_phy_cfg(tp);\n\n\trtl8152_set_speed(tp, tp->autoneg, tp->speed, tp->duplex,\n\t\t\t  tp->advertising);\n\nignore_once:\n\tmutex_unlock(&tp->control);\n\n\tusb_autopm_put_interface(tp->intf);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int rtl_notifier(struct notifier_block *nb, unsigned long action,\n\t\t\tvoid *data)\n{\n\tstruct r8152 *tp = container_of(nb, struct r8152, pm_notifier);\n\n\tswitch (action) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\tusb_autopm_get_interface(tp->intf);\n\t\tbreak;\n\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_SUSPEND:\n\t\tusb_autopm_put_interface(tp->intf);\n\t\tbreak;\n\n\tcase PM_POST_RESTORE:\n\tcase PM_RESTORE_PREPARE:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n#endif\n\nstatic int rtl8152_open(struct net_device *netdev)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\tint res = 0;\n\n\tif (work_busy(&tp->hw_phy_work.work) & WORK_BUSY_PENDING) {\n\t\tcancel_delayed_work_sync(&tp->hw_phy_work);\n\t\trtl_hw_phy_work_func_t(&tp->hw_phy_work.work);\n\t}\n\n\tres = alloc_all_mem(tp);\n\tif (res)\n\t\tgoto out;\n\n\tres = usb_autopm_get_interface(tp->intf);\n\tif (res < 0)\n\t\tgoto out_free;\n\n\tmutex_lock(&tp->control);\n\n\ttp->rtl_ops.up(tp);\n\n\tnetif_carrier_off(netdev);\n\tnetif_start_queue(netdev);\n\tset_bit(WORK_ENABLE, &tp->flags);\n\n\tres = usb_submit_urb(tp->intr_urb, GFP_KERNEL);\n\tif (res) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(tp->netdev);\n\t\tnetif_warn(tp, ifup, netdev, \"intr_urb submit failed: %d\\n\",\n\t\t\t   res);\n\t\tgoto out_unlock;\n\t}\n\tnapi_enable(&tp->napi);\n\ttasklet_enable(&tp->tx_tl);\n\n\tmutex_unlock(&tp->control);\n\n\tusb_autopm_put_interface(tp->intf);\n#ifdef CONFIG_PM_SLEEP\n\ttp->pm_notifier.notifier_call = rtl_notifier;\n\tregister_pm_notifier(&tp->pm_notifier);\n#endif\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&tp->control);\n\tusb_autopm_put_interface(tp->intf);\nout_free:\n\tfree_all_mem(tp);\nout:\n\treturn res;\n}\n\nstatic int rtl8152_close(struct net_device *netdev)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\tint res = 0;\n\n#ifdef CONFIG_PM_SLEEP\n\tunregister_pm_notifier(&tp->pm_notifier);\n#endif\n\ttasklet_disable(&tp->tx_tl);\n\tclear_bit(WORK_ENABLE, &tp->flags);\n\tusb_kill_urb(tp->intr_urb);\n\tcancel_delayed_work_sync(&tp->schedule);\n\tnapi_disable(&tp->napi);\n\tnetif_stop_queue(netdev);\n\n\tres = usb_autopm_get_interface(tp->intf);\n\tif (res < 0 || test_bit(RTL8152_INACCESSIBLE, &tp->flags)) {\n\t\trtl_drop_queued_tx(tp);\n\t\trtl_stop_rx(tp);\n\t} else {\n\t\tmutex_lock(&tp->control);\n\n\t\ttp->rtl_ops.down(tp);\n\n\t\tmutex_unlock(&tp->control);\n\t}\n\n\tif (!res)\n\t\tusb_autopm_put_interface(tp->intf);\n\n\tfree_all_mem(tp);\n\n\treturn res;\n}\n\nstatic void rtl_tally_reset(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_RSTTALLY);\n\tocp_data |= TALLY_RESET;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RSTTALLY, ocp_data);\n}\n\nstatic void r8152b_init(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tu16 data;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tdata = r8152_mdio_read(tp, MII_BMCR);\n\tif (data & BMCR_PDOWN) {\n\t\tdata &= ~BMCR_PDOWN;\n\t\tr8152_mdio_write(tp, MII_BMCR, data);\n\t}\n\n\tr8152_aldps_en(tp, false);\n\n\tif (tp->version == RTL_VER_01) {\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE);\n\t\tocp_data &= ~LED_MODE_MASK;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE, ocp_data);\n\t}\n\n\tr8152_power_cut_en(tp, false);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);\n\tocp_data |= TX_10M_IDLE_EN | PFM_PWM_SWITCH;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);\n\tocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL);\n\tocp_data &= ~MCU_CLK_RATIO_MASK;\n\tocp_data |= MCU_CLK_RATIO | D3_CLK_GATED_EN;\n\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL, ocp_data);\n\tocp_data = GPHY_STS_MSK | SPEED_DOWN_MSK |\n\t\t   SPDWN_RXDV_MSK | SPDWN_LINKCHG_MSK;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_GPHY_INTR_IMR, ocp_data);\n\n\trtl_tally_reset(tp);\n\n\t \n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);\n\tocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);\n\tocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);\n}\n\nstatic void r8153_init(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tu16 data;\n\tint i;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tr8153_u1u2en(tp, false);\n\n\tfor (i = 0; i < 500; i++) {\n\t\tif (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &\n\t\t    AUTOLOAD_DONE)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\tbreak;\n\t}\n\n\tdata = r8153_phy_status(tp, 0);\n\n\tif (tp->version == RTL_VER_03 || tp->version == RTL_VER_04 ||\n\t    tp->version == RTL_VER_05)\n\t\tocp_reg_write(tp, OCP_ADC_CFG, CKADSEL_L | ADC_EN | EN_EMI_L);\n\n\tdata = r8152_mdio_read(tp, MII_BMCR);\n\tif (data & BMCR_PDOWN) {\n\t\tdata &= ~BMCR_PDOWN;\n\t\tr8152_mdio_write(tp, MII_BMCR, data);\n\t}\n\n\tdata = r8153_phy_status(tp, PHY_STAT_LAN_ON);\n\n\tr8153_u2p3en(tp, false);\n\n\tif (tp->version == RTL_VER_04) {\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2);\n\t\tocp_data &= ~pwd_dn_scale_mask;\n\t\tocp_data |= pwd_dn_scale(96);\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2, ocp_data);\n\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_USB2PHY);\n\t\tocp_data |= USB2PHY_L1 | USB2PHY_SUSPEND;\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_USB2PHY, ocp_data);\n\t} else if (tp->version == RTL_VER_05) {\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_DMY_REG0);\n\t\tocp_data &= ~ECM_ALDPS;\n\t\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_DMY_REG0, ocp_data);\n\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1);\n\t\tif (ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE) == 0)\n\t\t\tocp_data &= ~DYNAMIC_BURST;\n\t\telse\n\t\t\tocp_data |= DYNAMIC_BURST;\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1, ocp_data);\n\t} else if (tp->version == RTL_VER_06) {\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1);\n\t\tif (ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE) == 0)\n\t\t\tocp_data &= ~DYNAMIC_BURST;\n\t\telse\n\t\t\tocp_data |= DYNAMIC_BURST;\n\t\tocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1, ocp_data);\n\n\t\tr8153_queue_wake(tp, false);\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);\n\t\tif (rtl8152_get_speed(tp) & LINK_STATUS)\n\t\t\tocp_data |= CUR_LINK_OK;\n\t\telse\n\t\t\tocp_data &= ~CUR_LINK_OK;\n\t\tocp_data |= POLL_LINK_CHG;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);\n\t}\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY2);\n\tocp_data |= EP4_FULL_FC;\n\tocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY2, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_WDT11_CTRL);\n\tocp_data &= ~TIMER11_EN;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_WDT11_CTRL, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE);\n\tocp_data &= ~LED_MODE_MASK;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE, ocp_data);\n\n\tocp_data = FIFO_EMPTY_1FB | ROK_EXIT_LPM;\n\tif (tp->version == RTL_VER_04 && tp->udev->speed < USB_SPEED_SUPER)\n\t\tocp_data |= LPM_TIMER_500MS;\n\telse\n\t\tocp_data |= LPM_TIMER_500US;\n\tocp_write_byte(tp, MCU_TYPE_USB, USB_LPM_CTRL, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_AFE_CTRL2);\n\tocp_data &= ~SEN_VAL_MASK;\n\tocp_data |= SEN_VAL_NORMAL | SEL_RXIDLE;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_AFE_CTRL2, ocp_data);\n\n\tocp_write_word(tp, MCU_TYPE_USB, USB_CONNECT_TIMER, 0x0001);\n\n\tr8153_power_cut_en(tp, false);\n\trtl_runtime_suspend_enable(tp, false);\n\tr8153_mac_clk_speed_down(tp, false);\n\tr8153_u1u2en(tp, true);\n\tusb_enable_lpm(tp->udev);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6);\n\tocp_data |= LANWAKE_CLR_EN;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CONFIG6, ocp_data);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_LWAKE_CTRL_REG);\n\tocp_data &= ~LANWAKE_PIN;\n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_LWAKE_CTRL_REG, ocp_data);\n\n\t \n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);\n\tocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);\n\tif (tp->dell_tb_rx_agg_bug)\n\t\tocp_data |= RX_AGG_DISABLE;\n\n\tocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);\n\n\trtl_tally_reset(tp);\n\n\tswitch (tp->udev->speed) {\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\ttp->coalesce = COALESCE_SUPER;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\ttp->coalesce = COALESCE_HIGH;\n\t\tbreak;\n\tdefault:\n\t\ttp->coalesce = COALESCE_SLOW;\n\t\tbreak;\n\t}\n}\n\nstatic void r8153b_init(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tu16 data;\n\tint i;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tr8153b_u1u2en(tp, false);\n\n\tfor (i = 0; i < 500; i++) {\n\t\tif (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &\n\t\t    AUTOLOAD_DONE)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\tbreak;\n\t}\n\n\tdata = r8153_phy_status(tp, 0);\n\n\tdata = r8152_mdio_read(tp, MII_BMCR);\n\tif (data & BMCR_PDOWN) {\n\t\tdata &= ~BMCR_PDOWN;\n\t\tr8152_mdio_write(tp, MII_BMCR, data);\n\t}\n\n\tdata = r8153_phy_status(tp, PHY_STAT_LAN_ON);\n\n\tr8153_u2p3en(tp, false);\n\n\t \n\tocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);\n\n\tr8153b_power_cut_en(tp, false);\n\tr8153b_ups_en(tp, false);\n\tr8153_queue_wake(tp, false);\n\trtl_runtime_suspend_enable(tp, false);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);\n\tif (rtl8152_get_speed(tp) & LINK_STATUS)\n\t\tocp_data |= CUR_LINK_OK;\n\telse\n\t\tocp_data &= ~CUR_LINK_OK;\n\tocp_data |= POLL_LINK_CHG;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);\n\n\tif (tp->udev->speed >= USB_SPEED_SUPER)\n\t\tr8153b_u1u2en(tp, true);\n\n\tusb_enable_lpm(tp->udev);\n\n\t \n\tr8153_mac_clk_speed_down(tp, true);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);\n\tocp_data &= ~PLA_MCU_SPDWN_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);\n\n\tif (tp->version == RTL_VER_09) {\n\t\t \n\t\tif (ocp_read_byte(tp, MCU_TYPE_PLA, 0xdc00) & BIT(5)) {\n\t\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);\n\t\t\tocp_data |= TEST_IO_OFF;\n\t\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);\n\t\t}\n\t}\n\n\tset_bit(GREEN_ETHERNET, &tp->flags);\n\n\t \n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);\n\tocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);\n\tocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);\n\n\trtl_tally_reset(tp);\n\n\ttp->coalesce = 15000;\t \n}\n\nstatic void r8153c_init(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tu16 data;\n\tint i;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tr8153b_u1u2en(tp, false);\n\n\t \n\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG5);\n\tocp_data &= ~BIT(3);\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG5, ocp_data);\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xcbf0);\n\tocp_data |= BIT(1);\n\tocp_write_word(tp, MCU_TYPE_USB, 0xcbf0, ocp_data);\n\n\tfor (i = 0; i < 500; i++) {\n\t\tif (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &\n\t\t    AUTOLOAD_DONE)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\treturn;\n\t}\n\n\tdata = r8153_phy_status(tp, 0);\n\n\tdata = r8152_mdio_read(tp, MII_BMCR);\n\tif (data & BMCR_PDOWN) {\n\t\tdata &= ~BMCR_PDOWN;\n\t\tr8152_mdio_write(tp, MII_BMCR, data);\n\t}\n\n\tdata = r8153_phy_status(tp, PHY_STAT_LAN_ON);\n\n\tr8153_u2p3en(tp, false);\n\n\t \n\tocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);\n\n\tr8153b_power_cut_en(tp, false);\n\tr8153c_ups_en(tp, false);\n\tr8153_queue_wake(tp, false);\n\trtl_runtime_suspend_enable(tp, false);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);\n\tif (rtl8152_get_speed(tp) & LINK_STATUS)\n\t\tocp_data |= CUR_LINK_OK;\n\telse\n\t\tocp_data &= ~CUR_LINK_OK;\n\n\tocp_data |= POLL_LINK_CHG;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);\n\n\tr8153b_u1u2en(tp, true);\n\n\tusb_enable_lpm(tp->udev);\n\n\t \n\tr8153_mac_clk_speed_down(tp, true);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_MISC_2);\n\tocp_data &= ~BIT(7);\n\tocp_write_byte(tp, MCU_TYPE_USB, USB_MISC_2, ocp_data);\n\n\tset_bit(GREEN_ETHERNET, &tp->flags);\n\n\t \n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);\n\tocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);\n\tocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);\n\n\trtl_tally_reset(tp);\n\n\ttp->coalesce = 15000;\t \n}\n\nstatic void r8156_hw_phy_cfg(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tu16 data;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);\n\tif (ocp_data & PCUT_STATUS) {\n\t\tocp_data &= ~PCUT_STATUS;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);\n\t}\n\n\tdata = r8153_phy_status(tp, 0);\n\tswitch (data) {\n\tcase PHY_STAT_EXT_INIT:\n\t\trtl8152_apply_firmware(tp, true);\n\n\t\tdata = ocp_reg_read(tp, 0xa468);\n\t\tdata &= ~(BIT(3) | BIT(1));\n\t\tocp_reg_write(tp, 0xa468, data);\n\t\tbreak;\n\tcase PHY_STAT_LAN_ON:\n\tcase PHY_STAT_PWRDN:\n\tdefault:\n\t\trtl8152_apply_firmware(tp, false);\n\t\tbreak;\n\t}\n\n\t \n\tr8153_aldps_en(tp, false);\n\n\t \n\trtl_eee_enable(tp, false);\n\n\tdata = r8153_phy_status(tp, PHY_STAT_LAN_ON);\n\tWARN_ON_ONCE(data != PHY_STAT_LAN_ON);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);\n\tocp_data |= PFM_PWM_SWITCH;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);\n\n\tswitch (tp->version) {\n\tcase RTL_VER_10:\n\t\tdata = ocp_reg_read(tp, 0xad40);\n\t\tdata &= ~0x3ff;\n\t\tdata |= BIT(7) | BIT(2);\n\t\tocp_reg_write(tp, 0xad40, data);\n\n\t\tdata = ocp_reg_read(tp, 0xad4e);\n\t\tdata |= BIT(4);\n\t\tocp_reg_write(tp, 0xad4e, data);\n\t\tdata = ocp_reg_read(tp, 0xad16);\n\t\tdata &= ~0x3ff;\n\t\tdata |= 0x6;\n\t\tocp_reg_write(tp, 0xad16, data);\n\t\tdata = ocp_reg_read(tp, 0xad32);\n\t\tdata &= ~0x3f;\n\t\tdata |= 6;\n\t\tocp_reg_write(tp, 0xad32, data);\n\t\tdata = ocp_reg_read(tp, 0xac08);\n\t\tdata &= ~(BIT(12) | BIT(8));\n\t\tocp_reg_write(tp, 0xac08, data);\n\t\tdata = ocp_reg_read(tp, 0xac8a);\n\t\tdata |= BIT(12) | BIT(13) | BIT(14);\n\t\tdata &= ~BIT(15);\n\t\tocp_reg_write(tp, 0xac8a, data);\n\t\tdata = ocp_reg_read(tp, 0xad18);\n\t\tdata |= BIT(10);\n\t\tocp_reg_write(tp, 0xad18, data);\n\t\tdata = ocp_reg_read(tp, 0xad1a);\n\t\tdata |= 0x3ff;\n\t\tocp_reg_write(tp, 0xad1a, data);\n\t\tdata = ocp_reg_read(tp, 0xad1c);\n\t\tdata |= 0x3ff;\n\t\tocp_reg_write(tp, 0xad1c, data);\n\n\t\tdata = sram_read(tp, 0x80ea);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0xc400;\n\t\tsram_write(tp, 0x80ea, data);\n\t\tdata = sram_read(tp, 0x80eb);\n\t\tdata &= ~0x0700;\n\t\tdata |= 0x0300;\n\t\tsram_write(tp, 0x80eb, data);\n\t\tdata = sram_read(tp, 0x80f8);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x1c00;\n\t\tsram_write(tp, 0x80f8, data);\n\t\tdata = sram_read(tp, 0x80f1);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x3000;\n\t\tsram_write(tp, 0x80f1, data);\n\n\t\tdata = sram_read(tp, 0x80fe);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0xa500;\n\t\tsram_write(tp, 0x80fe, data);\n\t\tdata = sram_read(tp, 0x8102);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x5000;\n\t\tsram_write(tp, 0x8102, data);\n\t\tdata = sram_read(tp, 0x8015);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x3300;\n\t\tsram_write(tp, 0x8015, data);\n\t\tdata = sram_read(tp, 0x8100);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x7000;\n\t\tsram_write(tp, 0x8100, data);\n\t\tdata = sram_read(tp, 0x8014);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0xf000;\n\t\tsram_write(tp, 0x8014, data);\n\t\tdata = sram_read(tp, 0x8016);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x6500;\n\t\tsram_write(tp, 0x8016, data);\n\t\tdata = sram_read(tp, 0x80dc);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0xed00;\n\t\tsram_write(tp, 0x80dc, data);\n\t\tdata = sram_read(tp, 0x80df);\n\t\tdata |= BIT(8);\n\t\tsram_write(tp, 0x80df, data);\n\t\tdata = sram_read(tp, 0x80e1);\n\t\tdata &= ~BIT(8);\n\t\tsram_write(tp, 0x80e1, data);\n\n\t\tdata = ocp_reg_read(tp, 0xbf06);\n\t\tdata &= ~0x003f;\n\t\tdata |= 0x0038;\n\t\tocp_reg_write(tp, 0xbf06, data);\n\n\t\tsram_write(tp, 0x819f, 0xddb6);\n\n\t\tocp_reg_write(tp, 0xbc34, 0x5555);\n\t\tdata = ocp_reg_read(tp, 0xbf0a);\n\t\tdata &= ~0x0e00;\n\t\tdata |= 0x0a00;\n\t\tocp_reg_write(tp, 0xbf0a, data);\n\n\t\tdata = ocp_reg_read(tp, 0xbd2c);\n\t\tdata &= ~BIT(13);\n\t\tocp_reg_write(tp, 0xbd2c, data);\n\t\tbreak;\n\tcase RTL_VER_11:\n\t\tdata = ocp_reg_read(tp, 0xad16);\n\t\tdata |= 0x3ff;\n\t\tocp_reg_write(tp, 0xad16, data);\n\t\tdata = ocp_reg_read(tp, 0xad32);\n\t\tdata &= ~0x3f;\n\t\tdata |= 6;\n\t\tocp_reg_write(tp, 0xad32, data);\n\t\tdata = ocp_reg_read(tp, 0xac08);\n\t\tdata &= ~(BIT(12) | BIT(8));\n\t\tocp_reg_write(tp, 0xac08, data);\n\t\tdata = ocp_reg_read(tp, 0xacc0);\n\t\tdata &= ~0x3;\n\t\tdata |= BIT(1);\n\t\tocp_reg_write(tp, 0xacc0, data);\n\t\tdata = ocp_reg_read(tp, 0xad40);\n\t\tdata &= ~0xe7;\n\t\tdata |= BIT(6) | BIT(2);\n\t\tocp_reg_write(tp, 0xad40, data);\n\t\tdata = ocp_reg_read(tp, 0xac14);\n\t\tdata &= ~BIT(7);\n\t\tocp_reg_write(tp, 0xac14, data);\n\t\tdata = ocp_reg_read(tp, 0xac80);\n\t\tdata &= ~(BIT(8) | BIT(9));\n\t\tocp_reg_write(tp, 0xac80, data);\n\t\tdata = ocp_reg_read(tp, 0xac5e);\n\t\tdata &= ~0x7;\n\t\tdata |= BIT(1);\n\t\tocp_reg_write(tp, 0xac5e, data);\n\t\tocp_reg_write(tp, 0xad4c, 0x00a8);\n\t\tocp_reg_write(tp, 0xac5c, 0x01ff);\n\t\tdata = ocp_reg_read(tp, 0xac8a);\n\t\tdata &= ~0xf0;\n\t\tdata |= BIT(4) | BIT(5);\n\t\tocp_reg_write(tp, 0xac8a, data);\n\t\tocp_reg_write(tp, 0xb87c, 0x8157);\n\t\tdata = ocp_reg_read(tp, 0xb87e);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x0500;\n\t\tocp_reg_write(tp, 0xb87e, data);\n\t\tocp_reg_write(tp, 0xb87c, 0x8159);\n\t\tdata = ocp_reg_read(tp, 0xb87e);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x0700;\n\t\tocp_reg_write(tp, 0xb87e, data);\n\n\t\t \n\t\tocp_reg_write(tp, 0xb87c, 0x80a2);\n\t\tocp_reg_write(tp, 0xb87e, 0x0153);\n\t\tocp_reg_write(tp, 0xb87c, 0x809c);\n\t\tocp_reg_write(tp, 0xb87e, 0x0153);\n\n\t\t \n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_TXTWSYS_2P5G, 0x0056);\n\n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_USB_CFG);\n\t\tocp_data |= EN_XG_LIP | EN_G_LIP;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_USB_CFG, ocp_data);\n\n\t\tsram_write(tp, 0x8257, 0x020f);  \n\t\tsram_write(tp, 0x80ea, 0x7843);  \n\n\t\tif (rtl_phy_patch_request(tp, true, true))\n\t\t\treturn;\n\n\t\t \n\t\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4);\n\t\tocp_data |= EEE_SPDWN_EN;\n\t\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, ocp_data);\n\n\t\tdata = ocp_reg_read(tp, OCP_DOWN_SPEED);\n\t\tdata &= ~(EN_EEE_100 | EN_EEE_1000);\n\t\tdata |= EN_10M_CLKDIV;\n\t\tocp_reg_write(tp, OCP_DOWN_SPEED, data);\n\t\ttp->ups_info._10m_ckdiv = true;\n\t\ttp->ups_info.eee_plloff_100 = false;\n\t\ttp->ups_info.eee_plloff_giga = false;\n\n\t\tdata = ocp_reg_read(tp, OCP_POWER_CFG);\n\t\tdata &= ~EEE_CLKDIV_EN;\n\t\tocp_reg_write(tp, OCP_POWER_CFG, data);\n\t\ttp->ups_info.eee_ckdiv = false;\n\n\t\tocp_reg_write(tp, OCP_SYSCLK_CFG, 0);\n\t\tocp_reg_write(tp, OCP_SYSCLK_CFG, sysclk_div_expo(5));\n\t\ttp->ups_info._250m_ckdiv = false;\n\n\t\trtl_phy_patch_request(tp, false, true);\n\n\t\t \n\t\tdata = ocp_reg_read(tp, 0xd068);\n\t\tdata |= BIT(13);\n\t\tocp_reg_write(tp, 0xd068, data);\n\n\t\t \n\t\tdata = sram_read(tp, 0x81a2);\n\t\tdata &= ~BIT(8);\n\t\tsram_write(tp, 0x81a2, data);\n\t\tdata = ocp_reg_read(tp, 0xb54c);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0xdb00;\n\t\tocp_reg_write(tp, 0xb54c, data);\n\n\t\t \n\t\tdata = ocp_reg_read(tp, 0xa454);\n\t\tdata &= ~BIT(0);\n\t\tocp_reg_write(tp, 0xa454, data);\n\n\t\t \n\t\tdata = ocp_reg_read(tp, OCP_10GBT_CTRL);\n\t\tdata |= RTL_ADV2_5G_F_R;\n\t\tocp_reg_write(tp, OCP_10GBT_CTRL, data);\n\t\tdata = ocp_reg_read(tp, 0xad4e);\n\t\tdata &= ~BIT(4);\n\t\tocp_reg_write(tp, 0xad4e, data);\n\t\tdata = ocp_reg_read(tp, 0xa86a);\n\t\tdata &= ~BIT(0);\n\t\tocp_reg_write(tp, 0xa86a, data);\n\n\t\t \n\t\tif ((ocp_read_word(tp, MCU_TYPE_USB, USB_UPS_CFG) & MID_REVERSE) &&\n\t\t    (ocp_reg_read(tp, 0xd068) & BIT(1))) {\n\t\t\tu16 swap_a, swap_b;\n\n\t\t\tdata = ocp_reg_read(tp, 0xd068);\n\t\t\tdata &= ~0x1f;\n\t\t\tdata |= 0x1;  \n\t\t\tocp_reg_write(tp, 0xd068, data);\n\t\t\tswap_a = ocp_reg_read(tp, 0xd06a);\n\t\t\tdata &= ~0x18;\n\t\t\tdata |= 0x18;  \n\t\t\tocp_reg_write(tp, 0xd068, data);\n\t\t\tswap_b = ocp_reg_read(tp, 0xd06a);\n\t\t\tdata &= ~0x18;  \n\t\t\tocp_reg_write(tp, 0xd068, data);\n\t\t\tocp_reg_write(tp, 0xd06a,\n\t\t\t\t      (swap_a & ~0x7ff) | (swap_b & 0x7ff));\n\t\t\tdata |= 0x18;  \n\t\t\tocp_reg_write(tp, 0xd068, data);\n\t\t\tocp_reg_write(tp, 0xd06a,\n\t\t\t\t      (swap_b & ~0x7ff) | (swap_a & 0x7ff));\n\t\t\tdata &= ~0x18;\n\t\t\tdata |= 0x08;  \n\t\t\tocp_reg_write(tp, 0xd068, data);\n\t\t\tswap_a = ocp_reg_read(tp, 0xd06a);\n\t\t\tdata &= ~0x18;\n\t\t\tdata |= 0x10;  \n\t\t\tocp_reg_write(tp, 0xd068, data);\n\t\t\tswap_b = ocp_reg_read(tp, 0xd06a);\n\t\t\tdata &= ~0x18;\n\t\t\tdata |= 0x08;  \n\t\t\tocp_reg_write(tp, 0xd068, data);\n\t\t\tocp_reg_write(tp, 0xd06a,\n\t\t\t\t      (swap_a & ~0x7ff) | (swap_b & 0x7ff));\n\t\t\tdata &= ~0x18;\n\t\t\tdata |= 0x10;  \n\t\t\tocp_reg_write(tp, 0xd068, data);\n\t\t\tocp_reg_write(tp, 0xd06a,\n\t\t\t\t      (swap_b & ~0x7ff) | (swap_a & 0x7ff));\n\t\t\tswap_a = ocp_reg_read(tp, 0xbd5a);\n\t\t\tswap_b = ocp_reg_read(tp, 0xbd5c);\n\t\t\tocp_reg_write(tp, 0xbd5a, (swap_a & ~0x1f1f) |\n\t\t\t\t      ((swap_b & 0x1f) << 8) |\n\t\t\t\t      ((swap_b >> 8) & 0x1f));\n\t\t\tocp_reg_write(tp, 0xbd5c, (swap_b & ~0x1f1f) |\n\t\t\t\t      ((swap_a & 0x1f) << 8) |\n\t\t\t\t      ((swap_a >> 8) & 0x1f));\n\t\t\tswap_a = ocp_reg_read(tp, 0xbc18);\n\t\t\tswap_b = ocp_reg_read(tp, 0xbc1a);\n\t\t\tocp_reg_write(tp, 0xbc18, (swap_a & ~0x1f1f) |\n\t\t\t\t      ((swap_b & 0x1f) << 8) |\n\t\t\t\t      ((swap_b >> 8) & 0x1f));\n\t\t\tocp_reg_write(tp, 0xbc1a, (swap_b & ~0x1f1f) |\n\t\t\t\t      ((swap_a & 0x1f) << 8) |\n\t\t\t\t      ((swap_a >> 8) & 0x1f));\n\t\t}\n\n\t\t \n\t\tdata = ocp_reg_read(tp, OCP_INTR_EN);\n\t\tdata |= INTR_SPEED_FORCE;\n\t\tocp_reg_write(tp, OCP_INTR_EN, data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trtl_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));\n\n\tdata = ocp_reg_read(tp, 0xa428);\n\tdata &= ~BIT(9);\n\tocp_reg_write(tp, 0xa428, data);\n\tdata = ocp_reg_read(tp, 0xa5ea);\n\tdata &= ~BIT(0);\n\tocp_reg_write(tp, 0xa5ea, data);\n\ttp->ups_info.lite_mode = 0;\n\n\tif (tp->eee_en)\n\t\trtl_eee_enable(tp, true);\n\n\tr8153_aldps_en(tp, true);\n\tr8152b_enable_fc(tp);\n\tr8153_u2p3en(tp, true);\n\n\tset_bit(PHY_RESET, &tp->flags);\n}\n\nstatic void r8156b_hw_phy_cfg(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tu16 data;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_12:\n\t\tocp_reg_write(tp, 0xbf86, 0x9000);\n\t\tdata = ocp_reg_read(tp, 0xc402);\n\t\tdata |= BIT(10);\n\t\tocp_reg_write(tp, 0xc402, data);\n\t\tdata &= ~BIT(10);\n\t\tocp_reg_write(tp, 0xc402, data);\n\t\tocp_reg_write(tp, 0xbd86, 0x1010);\n\t\tocp_reg_write(tp, 0xbd88, 0x1010);\n\t\tdata = ocp_reg_read(tp, 0xbd4e);\n\t\tdata &= ~(BIT(10) | BIT(11));\n\t\tdata |= BIT(11);\n\t\tocp_reg_write(tp, 0xbd4e, data);\n\t\tdata = ocp_reg_read(tp, 0xbf46);\n\t\tdata &= ~0xf00;\n\t\tdata |= 0x700;\n\t\tocp_reg_write(tp, 0xbf46, data);\n\t\tbreak;\n\tcase RTL_VER_13:\n\tcase RTL_VER_15:\n\t\tr8156b_wait_loading_flash(tp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);\n\tif (ocp_data & PCUT_STATUS) {\n\t\tocp_data &= ~PCUT_STATUS;\n\t\tocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);\n\t}\n\n\tdata = r8153_phy_status(tp, 0);\n\tswitch (data) {\n\tcase PHY_STAT_EXT_INIT:\n\t\trtl8152_apply_firmware(tp, true);\n\n\t\tdata = ocp_reg_read(tp, 0xa466);\n\t\tdata &= ~BIT(0);\n\t\tocp_reg_write(tp, 0xa466, data);\n\n\t\tdata = ocp_reg_read(tp, 0xa468);\n\t\tdata &= ~(BIT(3) | BIT(1));\n\t\tocp_reg_write(tp, 0xa468, data);\n\t\tbreak;\n\tcase PHY_STAT_LAN_ON:\n\tcase PHY_STAT_PWRDN:\n\tdefault:\n\t\trtl8152_apply_firmware(tp, false);\n\t\tbreak;\n\t}\n\n\tdata = r8152_mdio_read(tp, MII_BMCR);\n\tif (data & BMCR_PDOWN) {\n\t\tdata &= ~BMCR_PDOWN;\n\t\tr8152_mdio_write(tp, MII_BMCR, data);\n\t}\n\n\t \n\tr8153_aldps_en(tp, false);\n\n\t \n\trtl_eee_enable(tp, false);\n\n\tdata = r8153_phy_status(tp, PHY_STAT_LAN_ON);\n\tWARN_ON_ONCE(data != PHY_STAT_LAN_ON);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);\n\tocp_data |= PFM_PWM_SWITCH;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);\n\n\tswitch (tp->version) {\n\tcase RTL_VER_12:\n\t\tdata = ocp_reg_read(tp, 0xbc08);\n\t\tdata |= BIT(3) | BIT(2);\n\t\tocp_reg_write(tp, 0xbc08, data);\n\n\t\tdata = sram_read(tp, 0x8fff);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x0400;\n\t\tsram_write(tp, 0x8fff, data);\n\n\t\tdata = ocp_reg_read(tp, 0xacda);\n\t\tdata |= 0xff00;\n\t\tocp_reg_write(tp, 0xacda, data);\n\t\tdata = ocp_reg_read(tp, 0xacde);\n\t\tdata |= 0xf000;\n\t\tocp_reg_write(tp, 0xacde, data);\n\t\tocp_reg_write(tp, 0xac8c, 0x0ffc);\n\t\tocp_reg_write(tp, 0xac46, 0xb7b4);\n\t\tocp_reg_write(tp, 0xac50, 0x0fbc);\n\t\tocp_reg_write(tp, 0xac3c, 0x9240);\n\t\tocp_reg_write(tp, 0xac4e, 0x0db4);\n\t\tocp_reg_write(tp, 0xacc6, 0x0707);\n\t\tocp_reg_write(tp, 0xacc8, 0xa0d3);\n\t\tocp_reg_write(tp, 0xad08, 0x0007);\n\n\t\tocp_reg_write(tp, 0xb87c, 0x8560);\n\t\tocp_reg_write(tp, 0xb87e, 0x19cc);\n\t\tocp_reg_write(tp, 0xb87c, 0x8562);\n\t\tocp_reg_write(tp, 0xb87e, 0x19cc);\n\t\tocp_reg_write(tp, 0xb87c, 0x8564);\n\t\tocp_reg_write(tp, 0xb87e, 0x19cc);\n\t\tocp_reg_write(tp, 0xb87c, 0x8566);\n\t\tocp_reg_write(tp, 0xb87e, 0x147d);\n\t\tocp_reg_write(tp, 0xb87c, 0x8568);\n\t\tocp_reg_write(tp, 0xb87e, 0x147d);\n\t\tocp_reg_write(tp, 0xb87c, 0x856a);\n\t\tocp_reg_write(tp, 0xb87e, 0x147d);\n\t\tocp_reg_write(tp, 0xb87c, 0x8ffe);\n\t\tocp_reg_write(tp, 0xb87e, 0x0907);\n\t\tocp_reg_write(tp, 0xb87c, 0x80d6);\n\t\tocp_reg_write(tp, 0xb87e, 0x2801);\n\t\tocp_reg_write(tp, 0xb87c, 0x80f2);\n\t\tocp_reg_write(tp, 0xb87e, 0x2801);\n\t\tocp_reg_write(tp, 0xb87c, 0x80f4);\n\t\tocp_reg_write(tp, 0xb87e, 0x6077);\n\t\tocp_reg_write(tp, 0xb506, 0x01e7);\n\n\t\tocp_reg_write(tp, 0xb87c, 0x8013);\n\t\tocp_reg_write(tp, 0xb87e, 0x0700);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fb9);\n\t\tocp_reg_write(tp, 0xb87e, 0x2801);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fba);\n\t\tocp_reg_write(tp, 0xb87e, 0x0100);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fbc);\n\t\tocp_reg_write(tp, 0xb87e, 0x1900);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fbe);\n\t\tocp_reg_write(tp, 0xb87e, 0xe100);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fc0);\n\t\tocp_reg_write(tp, 0xb87e, 0x0800);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fc2);\n\t\tocp_reg_write(tp, 0xb87e, 0xe500);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fc4);\n\t\tocp_reg_write(tp, 0xb87e, 0x0f00);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fc6);\n\t\tocp_reg_write(tp, 0xb87e, 0xf100);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fc8);\n\t\tocp_reg_write(tp, 0xb87e, 0x0400);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fca);\n\t\tocp_reg_write(tp, 0xb87e, 0xf300);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fcc);\n\t\tocp_reg_write(tp, 0xb87e, 0xfd00);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fce);\n\t\tocp_reg_write(tp, 0xb87e, 0xff00);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fd0);\n\t\tocp_reg_write(tp, 0xb87e, 0xfb00);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fd2);\n\t\tocp_reg_write(tp, 0xb87e, 0x0100);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fd4);\n\t\tocp_reg_write(tp, 0xb87e, 0xf400);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fd6);\n\t\tocp_reg_write(tp, 0xb87e, 0xff00);\n\t\tocp_reg_write(tp, 0xb87c, 0x8fd8);\n\t\tocp_reg_write(tp, 0xb87e, 0xf600);\n\n\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_USB_CFG);\n\t\tocp_data |= EN_XG_LIP | EN_G_LIP;\n\t\tocp_write_byte(tp, MCU_TYPE_PLA, PLA_USB_CFG, ocp_data);\n\t\tocp_reg_write(tp, 0xb87c, 0x813d);\n\t\tocp_reg_write(tp, 0xb87e, 0x390e);\n\t\tocp_reg_write(tp, 0xb87c, 0x814f);\n\t\tocp_reg_write(tp, 0xb87e, 0x790e);\n\t\tocp_reg_write(tp, 0xb87c, 0x80b0);\n\t\tocp_reg_write(tp, 0xb87e, 0x0f31);\n\t\tdata = ocp_reg_read(tp, 0xbf4c);\n\t\tdata |= BIT(1);\n\t\tocp_reg_write(tp, 0xbf4c, data);\n\t\tdata = ocp_reg_read(tp, 0xbcca);\n\t\tdata |= BIT(9) | BIT(8);\n\t\tocp_reg_write(tp, 0xbcca, data);\n\t\tocp_reg_write(tp, 0xb87c, 0x8141);\n\t\tocp_reg_write(tp, 0xb87e, 0x320e);\n\t\tocp_reg_write(tp, 0xb87c, 0x8153);\n\t\tocp_reg_write(tp, 0xb87e, 0x720e);\n\t\tocp_reg_write(tp, 0xb87c, 0x8529);\n\t\tocp_reg_write(tp, 0xb87e, 0x050e);\n\t\tdata = ocp_reg_read(tp, OCP_EEE_CFG);\n\t\tdata &= ~CTAP_SHORT_EN;\n\t\tocp_reg_write(tp, OCP_EEE_CFG, data);\n\n\t\tsram_write(tp, 0x816c, 0xc4a0);\n\t\tsram_write(tp, 0x8170, 0xc4a0);\n\t\tsram_write(tp, 0x8174, 0x04a0);\n\t\tsram_write(tp, 0x8178, 0x04a0);\n\t\tsram_write(tp, 0x817c, 0x0719);\n\t\tsram_write(tp, 0x8ff4, 0x0400);\n\t\tsram_write(tp, 0x8ff1, 0x0404);\n\n\t\tocp_reg_write(tp, 0xbf4a, 0x001b);\n\t\tocp_reg_write(tp, 0xb87c, 0x8033);\n\t\tocp_reg_write(tp, 0xb87e, 0x7c13);\n\t\tocp_reg_write(tp, 0xb87c, 0x8037);\n\t\tocp_reg_write(tp, 0xb87e, 0x7c13);\n\t\tocp_reg_write(tp, 0xb87c, 0x803b);\n\t\tocp_reg_write(tp, 0xb87e, 0xfc32);\n\t\tocp_reg_write(tp, 0xb87c, 0x803f);\n\t\tocp_reg_write(tp, 0xb87e, 0x7c13);\n\t\tocp_reg_write(tp, 0xb87c, 0x8043);\n\t\tocp_reg_write(tp, 0xb87e, 0x7c13);\n\t\tocp_reg_write(tp, 0xb87c, 0x8047);\n\t\tocp_reg_write(tp, 0xb87e, 0x7c13);\n\n\t\tocp_reg_write(tp, 0xb87c, 0x8145);\n\t\tocp_reg_write(tp, 0xb87e, 0x370e);\n\t\tocp_reg_write(tp, 0xb87c, 0x8157);\n\t\tocp_reg_write(tp, 0xb87e, 0x770e);\n\t\tocp_reg_write(tp, 0xb87c, 0x8169);\n\t\tocp_reg_write(tp, 0xb87e, 0x0d0a);\n\t\tocp_reg_write(tp, 0xb87c, 0x817b);\n\t\tocp_reg_write(tp, 0xb87e, 0x1d0a);\n\n\t\tdata = sram_read(tp, 0x8217);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x5000;\n\t\tsram_write(tp, 0x8217, data);\n\t\tdata = sram_read(tp, 0x821a);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x5000;\n\t\tsram_write(tp, 0x821a, data);\n\t\tsram_write(tp, 0x80da, 0x0403);\n\t\tdata = sram_read(tp, 0x80dc);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x1000;\n\t\tsram_write(tp, 0x80dc, data);\n\t\tsram_write(tp, 0x80b3, 0x0384);\n\t\tsram_write(tp, 0x80b7, 0x2007);\n\t\tdata = sram_read(tp, 0x80ba);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x6c00;\n\t\tsram_write(tp, 0x80ba, data);\n\t\tsram_write(tp, 0x80b5, 0xf009);\n\t\tdata = sram_read(tp, 0x80bd);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x9f00;\n\t\tsram_write(tp, 0x80bd, data);\n\t\tsram_write(tp, 0x80c7, 0xf083);\n\t\tsram_write(tp, 0x80dd, 0x03f0);\n\t\tdata = sram_read(tp, 0x80df);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x1000;\n\t\tsram_write(tp, 0x80df, data);\n\t\tsram_write(tp, 0x80cb, 0x2007);\n\t\tdata = sram_read(tp, 0x80ce);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x6c00;\n\t\tsram_write(tp, 0x80ce, data);\n\t\tsram_write(tp, 0x80c9, 0x8009);\n\t\tdata = sram_read(tp, 0x80d1);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x8000;\n\t\tsram_write(tp, 0x80d1, data);\n\t\tsram_write(tp, 0x80a3, 0x200a);\n\t\tsram_write(tp, 0x80a5, 0xf0ad);\n\t\tsram_write(tp, 0x809f, 0x6073);\n\t\tsram_write(tp, 0x80a1, 0x000b);\n\t\tdata = sram_read(tp, 0x80a9);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0xc000;\n\t\tsram_write(tp, 0x80a9, data);\n\n\t\tif (rtl_phy_patch_request(tp, true, true))\n\t\t\treturn;\n\n\t\tdata = ocp_reg_read(tp, 0xb896);\n\t\tdata &= ~BIT(0);\n\t\tocp_reg_write(tp, 0xb896, data);\n\t\tdata = ocp_reg_read(tp, 0xb892);\n\t\tdata &= ~0xff00;\n\t\tocp_reg_write(tp, 0xb892, data);\n\t\tocp_reg_write(tp, 0xb88e, 0xc23e);\n\t\tocp_reg_write(tp, 0xb890, 0x0000);\n\t\tocp_reg_write(tp, 0xb88e, 0xc240);\n\t\tocp_reg_write(tp, 0xb890, 0x0103);\n\t\tocp_reg_write(tp, 0xb88e, 0xc242);\n\t\tocp_reg_write(tp, 0xb890, 0x0507);\n\t\tocp_reg_write(tp, 0xb88e, 0xc244);\n\t\tocp_reg_write(tp, 0xb890, 0x090b);\n\t\tocp_reg_write(tp, 0xb88e, 0xc246);\n\t\tocp_reg_write(tp, 0xb890, 0x0c0e);\n\t\tocp_reg_write(tp, 0xb88e, 0xc248);\n\t\tocp_reg_write(tp, 0xb890, 0x1012);\n\t\tocp_reg_write(tp, 0xb88e, 0xc24a);\n\t\tocp_reg_write(tp, 0xb890, 0x1416);\n\t\tdata = ocp_reg_read(tp, 0xb896);\n\t\tdata |= BIT(0);\n\t\tocp_reg_write(tp, 0xb896, data);\n\n\t\trtl_phy_patch_request(tp, false, true);\n\n\t\tdata = ocp_reg_read(tp, 0xa86a);\n\t\tdata |= BIT(0);\n\t\tocp_reg_write(tp, 0xa86a, data);\n\t\tdata = ocp_reg_read(tp, 0xa6f0);\n\t\tdata |= BIT(0);\n\t\tocp_reg_write(tp, 0xa6f0, data);\n\n\t\tocp_reg_write(tp, 0xbfa0, 0xd70d);\n\t\tocp_reg_write(tp, 0xbfa2, 0x4100);\n\t\tocp_reg_write(tp, 0xbfa4, 0xe868);\n\t\tocp_reg_write(tp, 0xbfa6, 0xdc59);\n\t\tocp_reg_write(tp, 0xb54c, 0x3c18);\n\t\tdata = ocp_reg_read(tp, 0xbfa4);\n\t\tdata &= ~BIT(5);\n\t\tocp_reg_write(tp, 0xbfa4, data);\n\t\tdata = sram_read(tp, 0x817d);\n\t\tdata |= BIT(12);\n\t\tsram_write(tp, 0x817d, data);\n\t\tbreak;\n\tcase RTL_VER_13:\n\t\t \n\t\tdata = ocp_reg_read(tp, 0xac46);\n\t\tdata &= ~0x00f0;\n\t\tdata |= 0x0090;\n\t\tocp_reg_write(tp, 0xac46, data);\n\t\tdata = ocp_reg_read(tp, 0xad30);\n\t\tdata &= ~0x0003;\n\t\tdata |= 0x0001;\n\t\tocp_reg_write(tp, 0xad30, data);\n\t\tfallthrough;\n\tcase RTL_VER_15:\n\t\t \n\t\tocp_reg_write(tp, 0xb87c, 0x80f5);\n\t\tocp_reg_write(tp, 0xb87e, 0x760e);\n\t\tocp_reg_write(tp, 0xb87c, 0x8107);\n\t\tocp_reg_write(tp, 0xb87e, 0x360e);\n\t\tocp_reg_write(tp, 0xb87c, 0x8551);\n\t\tdata = ocp_reg_read(tp, 0xb87e);\n\t\tdata &= ~0xff00;\n\t\tdata |= 0x0800;\n\t\tocp_reg_write(tp, 0xb87e, data);\n\n\t\t \n\t\tdata = ocp_reg_read(tp, 0xbf00);\n\t\tdata &= ~0xe000;\n\t\tdata |= 0xa000;\n\t\tocp_reg_write(tp, 0xbf00, data);\n\t\tdata = ocp_reg_read(tp, 0xbf46);\n\t\tdata &= ~0x0f00;\n\t\tdata |= 0x0300;\n\t\tocp_reg_write(tp, 0xbf46, data);\n\n\t\t \n\t\tsram_write(tp, 0x8044, 0x2417);\n\t\tsram_write(tp, 0x804a, 0x2417);\n\t\tsram_write(tp, 0x8050, 0x2417);\n\t\tsram_write(tp, 0x8056, 0x2417);\n\t\tsram_write(tp, 0x805c, 0x2417);\n\t\tsram_write(tp, 0x8062, 0x2417);\n\t\tsram_write(tp, 0x8068, 0x2417);\n\t\tsram_write(tp, 0x806e, 0x2417);\n\t\tsram_write(tp, 0x8074, 0x2417);\n\t\tsram_write(tp, 0x807a, 0x2417);\n\n\t\t \n\t\tdata = ocp_reg_read(tp, 0xbf84);\n\t\tdata &= ~0xe000;\n\t\tdata |= 0xa000;\n\t\tocp_reg_write(tp, 0xbf84, data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tdata = ocp_reg_read(tp, OCP_INTR_EN);\n\tdata |= INTR_SPEED_FORCE;\n\tocp_reg_write(tp, OCP_INTR_EN, data);\n\n\tif (rtl_phy_patch_request(tp, true, true))\n\t\treturn;\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4);\n\tocp_data |= EEE_SPDWN_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, ocp_data);\n\n\tdata = ocp_reg_read(tp, OCP_DOWN_SPEED);\n\tdata &= ~(EN_EEE_100 | EN_EEE_1000);\n\tdata |= EN_10M_CLKDIV;\n\tocp_reg_write(tp, OCP_DOWN_SPEED, data);\n\ttp->ups_info._10m_ckdiv = true;\n\ttp->ups_info.eee_plloff_100 = false;\n\ttp->ups_info.eee_plloff_giga = false;\n\n\tdata = ocp_reg_read(tp, OCP_POWER_CFG);\n\tdata &= ~EEE_CLKDIV_EN;\n\tocp_reg_write(tp, OCP_POWER_CFG, data);\n\ttp->ups_info.eee_ckdiv = false;\n\n\trtl_phy_patch_request(tp, false, true);\n\n\trtl_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));\n\n\tdata = ocp_reg_read(tp, 0xa428);\n\tdata &= ~BIT(9);\n\tocp_reg_write(tp, 0xa428, data);\n\tdata = ocp_reg_read(tp, 0xa5ea);\n\tdata &= ~BIT(0);\n\tocp_reg_write(tp, 0xa5ea, data);\n\ttp->ups_info.lite_mode = 0;\n\n\tif (tp->eee_en)\n\t\trtl_eee_enable(tp, true);\n\n\tr8153_aldps_en(tp, true);\n\tr8152b_enable_fc(tp);\n\tr8153_u2p3en(tp, true);\n\n\tset_bit(PHY_RESET, &tp->flags);\n}\n\nstatic void r8156_init(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tu16 data;\n\tint i;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_ECM_OP);\n\tocp_data &= ~EN_ALL_SPEED;\n\tocp_write_byte(tp, MCU_TYPE_USB, USB_ECM_OP, ocp_data);\n\n\tocp_write_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION, 0);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_ECM_OPTION);\n\tocp_data |= BYPASS_MAC_RESET;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_ECM_OPTION, ocp_data);\n\n\tr8153b_u1u2en(tp, false);\n\n\tfor (i = 0; i < 500; i++) {\n\t\tif (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &\n\t\t    AUTOLOAD_DONE)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\treturn;\n\t}\n\n\tdata = r8153_phy_status(tp, 0);\n\tif (data == PHY_STAT_EXT_INIT) {\n\t\tdata = ocp_reg_read(tp, 0xa468);\n\t\tdata &= ~(BIT(3) | BIT(1));\n\t\tocp_reg_write(tp, 0xa468, data);\n\t}\n\n\tdata = r8152_mdio_read(tp, MII_BMCR);\n\tif (data & BMCR_PDOWN) {\n\t\tdata &= ~BMCR_PDOWN;\n\t\tr8152_mdio_write(tp, MII_BMCR, data);\n\t}\n\n\tdata = r8153_phy_status(tp, PHY_STAT_LAN_ON);\n\tWARN_ON_ONCE(data != PHY_STAT_LAN_ON);\n\n\tr8153_u2p3en(tp, false);\n\n\t \n\tocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);\n\n\t \n\tocp_write_word(tp, MCU_TYPE_USB, USB_U1U2_TIMER, 500);\n\n\tr8153b_power_cut_en(tp, false);\n\tr8156_ups_en(tp, false);\n\tr8153_queue_wake(tp, false);\n\trtl_runtime_suspend_enable(tp, false);\n\n\tif (tp->udev->speed >= USB_SPEED_SUPER)\n\t\tr8153b_u1u2en(tp, true);\n\n\tusb_enable_lpm(tp->udev);\n\n\tr8156_mac_clk_spd(tp, true);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);\n\tocp_data &= ~PLA_MCU_SPDWN_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);\n\tif (rtl8152_get_speed(tp) & LINK_STATUS)\n\t\tocp_data |= CUR_LINK_OK;\n\telse\n\t\tocp_data &= ~CUR_LINK_OK;\n\tocp_data |= POLL_LINK_CHG;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);\n\n\tset_bit(GREEN_ETHERNET, &tp->flags);\n\n\t \n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);\n\tocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);\n\tocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_BMU_CONFIG);\n\tocp_data |= ACT_ODMA;\n\tocp_write_byte(tp, MCU_TYPE_USB, USB_BMU_CONFIG, ocp_data);\n\n\tr8156_mdio_force_mode(tp);\n\trtl_tally_reset(tp);\n\n\ttp->coalesce = 15000;\t \n}\n\nstatic void r8156b_init(struct r8152 *tp)\n{\n\tu32 ocp_data;\n\tu16 data;\n\tint i;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_ECM_OP);\n\tocp_data &= ~EN_ALL_SPEED;\n\tocp_write_byte(tp, MCU_TYPE_USB, USB_ECM_OP, ocp_data);\n\n\tocp_write_word(tp, MCU_TYPE_USB, USB_SPEED_OPTION, 0);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_ECM_OPTION);\n\tocp_data |= BYPASS_MAC_RESET;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_ECM_OPTION, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_U2P3_CTRL);\n\tocp_data |= RX_DETECT8;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_U2P3_CTRL, ocp_data);\n\n\tr8153b_u1u2en(tp, false);\n\n\tswitch (tp->version) {\n\tcase RTL_VER_13:\n\tcase RTL_VER_15:\n\t\tr8156b_wait_loading_flash(tp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 500; i++) {\n\t\tif (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &\n\t\t    AUTOLOAD_DONE)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\t\treturn;\n\t}\n\n\tdata = r8153_phy_status(tp, 0);\n\tif (data == PHY_STAT_EXT_INIT) {\n\t\tdata = ocp_reg_read(tp, 0xa468);\n\t\tdata &= ~(BIT(3) | BIT(1));\n\t\tocp_reg_write(tp, 0xa468, data);\n\n\t\tdata = ocp_reg_read(tp, 0xa466);\n\t\tdata &= ~BIT(0);\n\t\tocp_reg_write(tp, 0xa466, data);\n\t}\n\n\tdata = r8152_mdio_read(tp, MII_BMCR);\n\tif (data & BMCR_PDOWN) {\n\t\tdata &= ~BMCR_PDOWN;\n\t\tr8152_mdio_write(tp, MII_BMCR, data);\n\t}\n\n\tdata = r8153_phy_status(tp, PHY_STAT_LAN_ON);\n\n\tr8153_u2p3en(tp, false);\n\n\t \n\tocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);\n\n\t \n\tocp_write_word(tp, MCU_TYPE_USB, USB_U1U2_TIMER, 500);\n\n\tr8153b_power_cut_en(tp, false);\n\tr8156_ups_en(tp, false);\n\tr8153_queue_wake(tp, false);\n\trtl_runtime_suspend_enable(tp, false);\n\n\tif (tp->udev->speed >= USB_SPEED_SUPER)\n\t\tr8153b_u1u2en(tp, true);\n\n\tusb_enable_lpm(tp->udev);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_RCR);\n\tocp_data &= ~SLOT_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CPCR);\n\tocp_data |= FLOW_CTRL_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_CPCR, ocp_data);\n\n\t \n\tocp_write_word(tp, MCU_TYPE_USB, USB_FC_TIMER,\n\t\t       CTRL_TIMER_EN | (600 / 8));\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_CTRL);\n\tif (!(ocp_read_word(tp, MCU_TYPE_PLA, PLA_POL_GPIO_CTRL) & DACK_DET_EN))\n\t\tocp_data |= FLOW_CTRL_PATCH_2;\n\tocp_data &= ~AUTO_SPEEDUP;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_CTRL, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_FW_TASK);\n\tocp_data |= FC_PATCH_TASK;\n\tocp_write_word(tp, MCU_TYPE_USB, USB_FW_TASK, ocp_data);\n\n\tr8156_mac_clk_spd(tp, true);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);\n\tocp_data &= ~PLA_MCU_SPDWN_EN;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, ocp_data);\n\n\tocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS);\n\tif (rtl8152_get_speed(tp) & LINK_STATUS)\n\t\tocp_data |= CUR_LINK_OK;\n\telse\n\t\tocp_data &= ~CUR_LINK_OK;\n\tocp_data |= POLL_LINK_CHG;\n\tocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);\n\n\tset_bit(GREEN_ETHERNET, &tp->flags);\n\n\t \n\tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);\n\tocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);\n\tocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);\n\n\tr8156_mdio_force_mode(tp);\n\trtl_tally_reset(tp);\n\n\ttp->coalesce = 15000;\t \n}\n\nstatic bool rtl_check_vendor_ok(struct usb_interface *intf)\n{\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tstruct usb_endpoint_descriptor *in, *out, *intr;\n\n\tif (usb_find_common_endpoints(alt, &in, &out, &intr, NULL) < 0) {\n\t\tdev_err(&intf->dev, \"Expected endpoints are not found\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (usb_endpoint_num(in) != 1) {\n\t\tdev_err(&intf->dev, \"Invalid Rx endpoint address\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (usb_endpoint_num(out) != 2) {\n\t\tdev_err(&intf->dev, \"Invalid Tx endpoint address\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (usb_endpoint_num(intr) != 3) {\n\t\tdev_err(&intf->dev, \"Invalid interrupt endpoint address\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int rtl8152_pre_reset(struct usb_interface *intf)\n{\n\tstruct r8152 *tp = usb_get_intfdata(intf);\n\tstruct net_device *netdev;\n\n\trtnl_lock();\n\n\tif (!tp || !test_bit(PROBED_WITH_NO_ERRORS, &tp->flags))\n\t\treturn 0;\n\n\tnetdev = tp->netdev;\n\tif (!netif_running(netdev))\n\t\treturn 0;\n\n\tnetif_stop_queue(netdev);\n\ttasklet_disable(&tp->tx_tl);\n\tclear_bit(WORK_ENABLE, &tp->flags);\n\tusb_kill_urb(tp->intr_urb);\n\tcancel_delayed_work_sync(&tp->schedule);\n\tnapi_disable(&tp->napi);\n\tif (netif_carrier_ok(netdev)) {\n\t\tmutex_lock(&tp->control);\n\t\tset_bit(IN_PRE_RESET, &tp->flags);\n\t\ttp->rtl_ops.disable(tp);\n\t\tclear_bit(IN_PRE_RESET, &tp->flags);\n\t\tmutex_unlock(&tp->control);\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl8152_post_reset(struct usb_interface *intf)\n{\n\tstruct r8152 *tp = usb_get_intfdata(intf);\n\tstruct net_device *netdev;\n\tstruct sockaddr sa;\n\n\tif (!tp || !test_bit(PROBED_WITH_NO_ERRORS, &tp->flags))\n\t\tgoto exit;\n\n\trtl_set_accessible(tp);\n\n\t \n\tif (determine_ethernet_addr(tp, &sa) >= 0)\n\t\tdev_set_mac_address (tp->netdev, &sa, NULL);\n\n\tnetdev = tp->netdev;\n\tif (!netif_running(netdev))\n\t\tgoto exit;\n\n\tset_bit(WORK_ENABLE, &tp->flags);\n\tif (netif_carrier_ok(netdev)) {\n\t\tmutex_lock(&tp->control);\n\t\ttp->rtl_ops.enable(tp);\n\t\trtl_start_rx(tp);\n\t\t_rtl8152_set_rx_mode(netdev);\n\t\tmutex_unlock(&tp->control);\n\t}\n\n\tnapi_enable(&tp->napi);\n\ttasklet_enable(&tp->tx_tl);\n\tnetif_wake_queue(netdev);\n\tusb_submit_urb(tp->intr_urb, GFP_KERNEL);\n\n\tif (!list_empty(&tp->rx_done))\n\t\tnapi_schedule(&tp->napi);\n\nexit:\n\trtnl_unlock();\n\treturn 0;\n}\n\nstatic bool delay_autosuspend(struct r8152 *tp)\n{\n\tbool sw_linking = !!netif_carrier_ok(tp->netdev);\n\tbool hw_linking = !!(rtl8152_get_speed(tp) & LINK_STATUS);\n\n\t \n\tif (work_busy(&tp->schedule.work) || sw_linking != hw_linking)\n\t\treturn true;\n\n\t \n\tif (!sw_linking && tp->rtl_ops.in_nway(tp))\n\t\treturn true;\n\telse if (!skb_queue_empty(&tp->tx_queue))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int rtl8152_runtime_resume(struct r8152 *tp)\n{\n\tstruct net_device *netdev = tp->netdev;\n\n\tif (netif_running(netdev) && netdev->flags & IFF_UP) {\n\t\tstruct napi_struct *napi = &tp->napi;\n\n\t\ttp->rtl_ops.autosuspend_en(tp, false);\n\t\tnapi_disable(napi);\n\t\tset_bit(WORK_ENABLE, &tp->flags);\n\n\t\tif (netif_carrier_ok(netdev)) {\n\t\t\tif (rtl8152_get_speed(tp) & LINK_STATUS) {\n\t\t\t\trtl_start_rx(tp);\n\t\t\t} else {\n\t\t\t\tnetif_carrier_off(netdev);\n\t\t\t\ttp->rtl_ops.disable(tp);\n\t\t\t\tnetif_info(tp, link, netdev, \"linking down\\n\");\n\t\t\t}\n\t\t}\n\n\t\tnapi_enable(napi);\n\t\tclear_bit(SELECTIVE_SUSPEND, &tp->flags);\n\t\tsmp_mb__after_atomic();\n\n\t\tif (!list_empty(&tp->rx_done))\n\t\t\tnapi_schedule(&tp->napi);\n\n\t\tusb_submit_urb(tp->intr_urb, GFP_NOIO);\n\t} else {\n\t\tif (netdev->flags & IFF_UP)\n\t\t\ttp->rtl_ops.autosuspend_en(tp, false);\n\n\t\tclear_bit(SELECTIVE_SUSPEND, &tp->flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl8152_system_resume(struct r8152 *tp)\n{\n\tstruct net_device *netdev = tp->netdev;\n\n\tnetif_device_attach(netdev);\n\n\tif (netif_running(netdev) && (netdev->flags & IFF_UP)) {\n\t\ttp->rtl_ops.up(tp);\n\t\tnetif_carrier_off(netdev);\n\t\tset_bit(WORK_ENABLE, &tp->flags);\n\t\tusb_submit_urb(tp->intr_urb, GFP_NOIO);\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl8152_runtime_suspend(struct r8152 *tp)\n{\n\tstruct net_device *netdev = tp->netdev;\n\tint ret = 0;\n\n\tif (!tp->rtl_ops.autosuspend_en)\n\t\treturn -EBUSY;\n\n\tset_bit(SELECTIVE_SUSPEND, &tp->flags);\n\tsmp_mb__after_atomic();\n\n\tif (netif_running(netdev) && test_bit(WORK_ENABLE, &tp->flags)) {\n\t\tu32 rcr = 0;\n\n\t\tif (netif_carrier_ok(netdev)) {\n\t\t\tu32 ocp_data;\n\n\t\t\trcr = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);\n\t\t\tocp_data = rcr & ~RCR_ACPT_ALL;\n\t\t\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);\n\t\t\trxdy_gated_en(tp, true);\n\t\t\tocp_data = ocp_read_byte(tp, MCU_TYPE_PLA,\n\t\t\t\t\t\t PLA_OOB_CTRL);\n\t\t\tif (!(ocp_data & RXFIFO_EMPTY)) {\n\t\t\t\trxdy_gated_en(tp, false);\n\t\t\t\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, rcr);\n\t\t\t\tclear_bit(SELECTIVE_SUSPEND, &tp->flags);\n\t\t\t\tsmp_mb__after_atomic();\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out1;\n\t\t\t}\n\t\t}\n\n\t\tclear_bit(WORK_ENABLE, &tp->flags);\n\t\tusb_kill_urb(tp->intr_urb);\n\n\t\ttp->rtl_ops.autosuspend_en(tp, true);\n\n\t\tif (netif_carrier_ok(netdev)) {\n\t\t\tstruct napi_struct *napi = &tp->napi;\n\n\t\t\tnapi_disable(napi);\n\t\t\trtl_stop_rx(tp);\n\t\t\trxdy_gated_en(tp, false);\n\t\t\tocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, rcr);\n\t\t\tnapi_enable(napi);\n\t\t}\n\n\t\tif (delay_autosuspend(tp)) {\n\t\t\trtl8152_runtime_resume(tp);\n\t\t\tret = -EBUSY;\n\t\t}\n\t}\n\nout1:\n\treturn ret;\n}\n\nstatic int rtl8152_system_suspend(struct r8152 *tp)\n{\n\tstruct net_device *netdev = tp->netdev;\n\n\tnetif_device_detach(netdev);\n\n\tif (netif_running(netdev) && test_bit(WORK_ENABLE, &tp->flags)) {\n\t\tstruct napi_struct *napi = &tp->napi;\n\n\t\tclear_bit(WORK_ENABLE, &tp->flags);\n\t\tusb_kill_urb(tp->intr_urb);\n\t\ttasklet_disable(&tp->tx_tl);\n\t\tnapi_disable(napi);\n\t\tcancel_delayed_work_sync(&tp->schedule);\n\t\ttp->rtl_ops.down(tp);\n\t\tnapi_enable(napi);\n\t\ttasklet_enable(&tp->tx_tl);\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl8152_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct r8152 *tp = usb_get_intfdata(intf);\n\tint ret;\n\n\tmutex_lock(&tp->control);\n\n\tif (PMSG_IS_AUTO(message))\n\t\tret = rtl8152_runtime_suspend(tp);\n\telse\n\t\tret = rtl8152_system_suspend(tp);\n\n\tmutex_unlock(&tp->control);\n\n\treturn ret;\n}\n\nstatic int rtl8152_resume(struct usb_interface *intf)\n{\n\tstruct r8152 *tp = usb_get_intfdata(intf);\n\tint ret;\n\n\tmutex_lock(&tp->control);\n\n\trtl_reset_ocp_base(tp);\n\n\tif (test_bit(SELECTIVE_SUSPEND, &tp->flags))\n\t\tret = rtl8152_runtime_resume(tp);\n\telse\n\t\tret = rtl8152_system_resume(tp);\n\n\tmutex_unlock(&tp->control);\n\n\treturn ret;\n}\n\nstatic int rtl8152_reset_resume(struct usb_interface *intf)\n{\n\tstruct r8152 *tp = usb_get_intfdata(intf);\n\n\tclear_bit(SELECTIVE_SUSPEND, &tp->flags);\n\trtl_reset_ocp_base(tp);\n\ttp->rtl_ops.init(tp);\n\tqueue_delayed_work(system_long_wq, &tp->hw_phy_work, 0);\n\tset_ethernet_addr(tp, true);\n\treturn rtl8152_resume(intf);\n}\n\nstatic void rtl8152_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct r8152 *tp = netdev_priv(dev);\n\n\tif (usb_autopm_get_interface(tp->intf) < 0)\n\t\treturn;\n\n\tif (!rtl_can_wakeup(tp)) {\n\t\twol->supported = 0;\n\t\twol->wolopts = 0;\n\t} else {\n\t\tmutex_lock(&tp->control);\n\t\twol->supported = WAKE_ANY;\n\t\twol->wolopts = __rtl_get_wol(tp);\n\t\tmutex_unlock(&tp->control);\n\t}\n\n\tusb_autopm_put_interface(tp->intf);\n}\n\nstatic int rtl8152_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct r8152 *tp = netdev_priv(dev);\n\tint ret;\n\n\tif (!rtl_can_wakeup(tp))\n\t\treturn -EOPNOTSUPP;\n\n\tif (wol->wolopts & ~WAKE_ANY)\n\t\treturn -EINVAL;\n\n\tret = usb_autopm_get_interface(tp->intf);\n\tif (ret < 0)\n\t\tgoto out_set_wol;\n\n\tmutex_lock(&tp->control);\n\n\t__rtl_set_wol(tp, wol->wolopts);\n\ttp->saved_wolopts = wol->wolopts & WAKE_ANY;\n\n\tmutex_unlock(&tp->control);\n\n\tusb_autopm_put_interface(tp->intf);\n\nout_set_wol:\n\treturn ret;\n}\n\nstatic u32 rtl8152_get_msglevel(struct net_device *dev)\n{\n\tstruct r8152 *tp = netdev_priv(dev);\n\n\treturn tp->msg_enable;\n}\n\nstatic void rtl8152_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct r8152 *tp = netdev_priv(dev);\n\n\ttp->msg_enable = value;\n}\n\nstatic void rtl8152_get_drvinfo(struct net_device *netdev,\n\t\t\t\tstruct ethtool_drvinfo *info)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\n\tstrscpy(info->driver, MODULENAME, sizeof(info->driver));\n\tstrscpy(info->version, DRIVER_VERSION, sizeof(info->version));\n\tusb_make_path(tp->udev, info->bus_info, sizeof(info->bus_info));\n\tif (!IS_ERR_OR_NULL(tp->rtl_fw.fw))\n\t\tstrscpy(info->fw_version, tp->rtl_fw.version,\n\t\t\tsizeof(info->fw_version));\n}\n\nstatic\nint rtl8152_get_link_ksettings(struct net_device *netdev,\n\t\t\t       struct ethtool_link_ksettings *cmd)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\tint ret;\n\n\tif (!tp->mii.mdio_read)\n\t\treturn -EOPNOTSUPP;\n\n\tret = usb_autopm_get_interface(tp->intf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmutex_lock(&tp->control);\n\n\tmii_ethtool_get_link_ksettings(&tp->mii, cmd);\n\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,\n\t\t\t cmd->link_modes.supported, tp->support_2500full);\n\n\tif (tp->support_2500full) {\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,\n\t\t\t\t cmd->link_modes.advertising,\n\t\t\t\t ocp_reg_read(tp, OCP_10GBT_CTRL) & MDIO_AN_10GBT_CTRL_ADV2_5G);\n\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,\n\t\t\t\t cmd->link_modes.lp_advertising,\n\t\t\t\t ocp_reg_read(tp, OCP_10GBT_STAT) & MDIO_AN_10GBT_STAT_LP2_5G);\n\n\t\tif (is_speed_2500(rtl8152_get_speed(tp)))\n\t\t\tcmd->base.speed = SPEED_2500;\n\t}\n\n\tmutex_unlock(&tp->control);\n\n\tusb_autopm_put_interface(tp->intf);\n\nout:\n\treturn ret;\n}\n\nstatic int rtl8152_set_link_ksettings(struct net_device *dev,\n\t\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct r8152 *tp = netdev_priv(dev);\n\tu32 advertising = 0;\n\tint ret;\n\n\tret = usb_autopm_get_interface(tp->intf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (test_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,\n\t\t     cmd->link_modes.advertising))\n\t\tadvertising |= RTL_ADVERTISED_10_HALF;\n\n\tif (test_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,\n\t\t     cmd->link_modes.advertising))\n\t\tadvertising |= RTL_ADVERTISED_10_FULL;\n\n\tif (test_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,\n\t\t     cmd->link_modes.advertising))\n\t\tadvertising |= RTL_ADVERTISED_100_HALF;\n\n\tif (test_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,\n\t\t     cmd->link_modes.advertising))\n\t\tadvertising |= RTL_ADVERTISED_100_FULL;\n\n\tif (test_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,\n\t\t     cmd->link_modes.advertising))\n\t\tadvertising |= RTL_ADVERTISED_1000_HALF;\n\n\tif (test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t\t     cmd->link_modes.advertising))\n\t\tadvertising |= RTL_ADVERTISED_1000_FULL;\n\n\tif (test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,\n\t\t     cmd->link_modes.advertising))\n\t\tadvertising |= RTL_ADVERTISED_2500_FULL;\n\n\tmutex_lock(&tp->control);\n\n\tret = rtl8152_set_speed(tp, cmd->base.autoneg, cmd->base.speed,\n\t\t\t\tcmd->base.duplex, advertising);\n\tif (!ret) {\n\t\ttp->autoneg = cmd->base.autoneg;\n\t\ttp->speed = cmd->base.speed;\n\t\ttp->duplex = cmd->base.duplex;\n\t\ttp->advertising = advertising;\n\t}\n\n\tmutex_unlock(&tp->control);\n\n\tusb_autopm_put_interface(tp->intf);\n\nout:\n\treturn ret;\n}\n\nstatic const char rtl8152_gstrings[][ETH_GSTRING_LEN] = {\n\t\"tx_packets\",\n\t\"rx_packets\",\n\t\"tx_errors\",\n\t\"rx_errors\",\n\t\"rx_missed\",\n\t\"align_errors\",\n\t\"tx_single_collisions\",\n\t\"tx_multi_collisions\",\n\t\"rx_unicast\",\n\t\"rx_broadcast\",\n\t\"rx_multicast\",\n\t\"tx_aborted\",\n\t\"tx_underrun\",\n};\n\nstatic int rtl8152_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(rtl8152_gstrings);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void rtl8152_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t      struct ethtool_stats *stats, u64 *data)\n{\n\tstruct r8152 *tp = netdev_priv(dev);\n\tstruct tally_counter tally;\n\n\tif (usb_autopm_get_interface(tp->intf) < 0)\n\t\treturn;\n\n\tgeneric_ocp_read(tp, PLA_TALLYCNT, sizeof(tally), &tally, MCU_TYPE_PLA);\n\n\tusb_autopm_put_interface(tp->intf);\n\n\tdata[0] = le64_to_cpu(tally.tx_packets);\n\tdata[1] = le64_to_cpu(tally.rx_packets);\n\tdata[2] = le64_to_cpu(tally.tx_errors);\n\tdata[3] = le32_to_cpu(tally.rx_errors);\n\tdata[4] = le16_to_cpu(tally.rx_missed);\n\tdata[5] = le16_to_cpu(tally.align_errors);\n\tdata[6] = le32_to_cpu(tally.tx_one_collision);\n\tdata[7] = le32_to_cpu(tally.tx_multi_collision);\n\tdata[8] = le64_to_cpu(tally.rx_unicast);\n\tdata[9] = le64_to_cpu(tally.rx_broadcast);\n\tdata[10] = le32_to_cpu(tally.rx_multicast);\n\tdata[11] = le16_to_cpu(tally.tx_aborted);\n\tdata[12] = le16_to_cpu(tally.tx_underrun);\n}\n\nstatic void rtl8152_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(data, rtl8152_gstrings, sizeof(rtl8152_gstrings));\n\t\tbreak;\n\t}\n}\n\nstatic int r8152_get_eee(struct r8152 *tp, struct ethtool_eee *eee)\n{\n\tu32 lp, adv, supported = 0;\n\tu16 val;\n\n\tval = r8152_mmd_read(tp, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);\n\tsupported = mmd_eee_cap_to_ethtool_sup_t(val);\n\n\tval = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV);\n\tadv = mmd_eee_adv_to_ethtool_adv_t(val);\n\n\tval = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE);\n\tlp = mmd_eee_adv_to_ethtool_adv_t(val);\n\n\teee->eee_enabled = tp->eee_en;\n\teee->eee_active = !!(supported & adv & lp);\n\teee->supported = supported;\n\teee->advertised = tp->eee_adv;\n\teee->lp_advertised = lp;\n\n\treturn 0;\n}\n\nstatic int r8152_set_eee(struct r8152 *tp, struct ethtool_eee *eee)\n{\n\tu16 val = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);\n\n\ttp->eee_en = eee->eee_enabled;\n\ttp->eee_adv = val;\n\n\trtl_eee_enable(tp, tp->eee_en);\n\n\treturn 0;\n}\n\nstatic int r8153_get_eee(struct r8152 *tp, struct ethtool_eee *eee)\n{\n\tu32 lp, adv, supported = 0;\n\tu16 val;\n\n\tval = ocp_reg_read(tp, OCP_EEE_ABLE);\n\tsupported = mmd_eee_cap_to_ethtool_sup_t(val);\n\n\tval = ocp_reg_read(tp, OCP_EEE_ADV);\n\tadv = mmd_eee_adv_to_ethtool_adv_t(val);\n\n\tval = ocp_reg_read(tp, OCP_EEE_LPABLE);\n\tlp = mmd_eee_adv_to_ethtool_adv_t(val);\n\n\teee->eee_enabled = tp->eee_en;\n\teee->eee_active = !!(supported & adv & lp);\n\teee->supported = supported;\n\teee->advertised = tp->eee_adv;\n\teee->lp_advertised = lp;\n\n\treturn 0;\n}\n\nstatic int\nrtl_ethtool_get_eee(struct net_device *net, struct ethtool_eee *edata)\n{\n\tstruct r8152 *tp = netdev_priv(net);\n\tint ret;\n\n\tif (!tp->rtl_ops.eee_get) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = usb_autopm_get_interface(tp->intf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmutex_lock(&tp->control);\n\n\tret = tp->rtl_ops.eee_get(tp, edata);\n\n\tmutex_unlock(&tp->control);\n\n\tusb_autopm_put_interface(tp->intf);\n\nout:\n\treturn ret;\n}\n\nstatic int\nrtl_ethtool_set_eee(struct net_device *net, struct ethtool_eee *edata)\n{\n\tstruct r8152 *tp = netdev_priv(net);\n\tint ret;\n\n\tif (!tp->rtl_ops.eee_set) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = usb_autopm_get_interface(tp->intf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmutex_lock(&tp->control);\n\n\tret = tp->rtl_ops.eee_set(tp, edata);\n\tif (!ret)\n\t\tret = mii_nway_restart(&tp->mii);\n\n\tmutex_unlock(&tp->control);\n\n\tusb_autopm_put_interface(tp->intf);\n\nout:\n\treturn ret;\n}\n\nstatic int rtl8152_nway_reset(struct net_device *dev)\n{\n\tstruct r8152 *tp = netdev_priv(dev);\n\tint ret;\n\n\tret = usb_autopm_get_interface(tp->intf);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmutex_lock(&tp->control);\n\n\tret = mii_nway_restart(&tp->mii);\n\n\tmutex_unlock(&tp->control);\n\n\tusb_autopm_put_interface(tp->intf);\n\nout:\n\treturn ret;\n}\n\nstatic int rtl8152_get_coalesce(struct net_device *netdev,\n\t\t\t\tstruct ethtool_coalesce *coalesce,\n\t\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\n\tswitch (tp->version) {\n\tcase RTL_VER_01:\n\tcase RTL_VER_02:\n\tcase RTL_VER_07:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcoalesce->rx_coalesce_usecs = tp->coalesce;\n\n\treturn 0;\n}\n\nstatic int rtl8152_set_coalesce(struct net_device *netdev,\n\t\t\t\tstruct ethtool_coalesce *coalesce,\n\t\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\tint ret;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_01:\n\tcase RTL_VER_02:\n\tcase RTL_VER_07:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (coalesce->rx_coalesce_usecs > COALESCE_SLOW)\n\t\treturn -EINVAL;\n\n\tret = usb_autopm_get_interface(tp->intf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&tp->control);\n\n\tif (tp->coalesce != coalesce->rx_coalesce_usecs) {\n\t\ttp->coalesce = coalesce->rx_coalesce_usecs;\n\n\t\tif (netif_running(netdev) && netif_carrier_ok(netdev)) {\n\t\t\tnetif_stop_queue(netdev);\n\t\t\tnapi_disable(&tp->napi);\n\t\t\ttp->rtl_ops.disable(tp);\n\t\t\ttp->rtl_ops.enable(tp);\n\t\t\trtl_start_rx(tp);\n\t\t\tclear_bit(RTL8152_SET_RX_MODE, &tp->flags);\n\t\t\t_rtl8152_set_rx_mode(netdev);\n\t\t\tnapi_enable(&tp->napi);\n\t\t\tnetif_wake_queue(netdev);\n\t\t}\n\t}\n\n\tmutex_unlock(&tp->control);\n\n\tusb_autopm_put_interface(tp->intf);\n\n\treturn ret;\n}\n\nstatic int rtl8152_get_tunable(struct net_device *netdev,\n\t\t\t       const struct ethtool_tunable *tunable, void *d)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\n\tswitch (tunable->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\t*(u32 *)d = tp->rx_copybreak;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl8152_set_tunable(struct net_device *netdev,\n\t\t\t       const struct ethtool_tunable *tunable,\n\t\t\t       const void *d)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\tu32 val;\n\n\tswitch (tunable->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\tval = *(u32 *)d;\n\t\tif (val < ETH_ZLEN) {\n\t\t\tnetif_err(tp, rx_err, netdev,\n\t\t\t\t  \"Invalid rx copy break value\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tp->rx_copybreak != val) {\n\t\t\tif (netdev->flags & IFF_UP) {\n\t\t\t\tmutex_lock(&tp->control);\n\t\t\t\tnapi_disable(&tp->napi);\n\t\t\t\ttp->rx_copybreak = val;\n\t\t\t\tnapi_enable(&tp->napi);\n\t\t\t\tmutex_unlock(&tp->control);\n\t\t\t} else {\n\t\t\t\ttp->rx_copybreak = val;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtl8152_get_ringparam(struct net_device *netdev,\n\t\t\t\t  struct ethtool_ringparam *ring,\n\t\t\t\t  struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\n\tring->rx_max_pending = RTL8152_RX_MAX_PENDING;\n\tring->rx_pending = tp->rx_pending;\n}\n\nstatic int rtl8152_set_ringparam(struct net_device *netdev,\n\t\t\t\t struct ethtool_ringparam *ring,\n\t\t\t\t struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\n\tif (ring->rx_pending < (RTL8152_MAX_RX * 2))\n\t\treturn -EINVAL;\n\n\tif (tp->rx_pending != ring->rx_pending) {\n\t\tif (netdev->flags & IFF_UP) {\n\t\t\tmutex_lock(&tp->control);\n\t\t\tnapi_disable(&tp->napi);\n\t\t\ttp->rx_pending = ring->rx_pending;\n\t\t\tnapi_enable(&tp->napi);\n\t\t\tmutex_unlock(&tp->control);\n\t\t} else {\n\t\t\ttp->rx_pending = ring->rx_pending;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void rtl8152_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\tu16 bmcr, lcladv, rmtadv;\n\tu8 cap;\n\n\tif (usb_autopm_get_interface(tp->intf) < 0)\n\t\treturn;\n\n\tmutex_lock(&tp->control);\n\n\tbmcr = r8152_mdio_read(tp, MII_BMCR);\n\tlcladv = r8152_mdio_read(tp, MII_ADVERTISE);\n\trmtadv = r8152_mdio_read(tp, MII_LPA);\n\n\tmutex_unlock(&tp->control);\n\n\tusb_autopm_put_interface(tp->intf);\n\n\tif (!(bmcr & BMCR_ANENABLE)) {\n\t\tpause->autoneg = 0;\n\t\tpause->rx_pause = 0;\n\t\tpause->tx_pause = 0;\n\t\treturn;\n\t}\n\n\tpause->autoneg = 1;\n\n\tcap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);\n\n\tif (cap & FLOW_CTRL_RX)\n\t\tpause->rx_pause = 1;\n\n\tif (cap & FLOW_CTRL_TX)\n\t\tpause->tx_pause = 1;\n}\n\nstatic int rtl8152_set_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\tu16 old, new1;\n\tu8 cap = 0;\n\tint ret;\n\n\tret = usb_autopm_get_interface(tp->intf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&tp->control);\n\n\tif (pause->autoneg && !(r8152_mdio_read(tp, MII_BMCR) & BMCR_ANENABLE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (pause->rx_pause)\n\t\tcap |= FLOW_CTRL_RX;\n\n\tif (pause->tx_pause)\n\t\tcap |= FLOW_CTRL_TX;\n\n\told = r8152_mdio_read(tp, MII_ADVERTISE);\n\tnew1 = (old & ~(ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM)) | mii_advertise_flowctrl(cap);\n\tif (old != new1)\n\t\tr8152_mdio_write(tp, MII_ADVERTISE, new1);\n\nout:\n\tmutex_unlock(&tp->control);\n\tusb_autopm_put_interface(tp->intf);\n\n\treturn ret;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS,\n\t.get_drvinfo = rtl8152_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n\t.nway_reset = rtl8152_nway_reset,\n\t.get_msglevel = rtl8152_get_msglevel,\n\t.set_msglevel = rtl8152_set_msglevel,\n\t.get_wol = rtl8152_get_wol,\n\t.set_wol = rtl8152_set_wol,\n\t.get_strings = rtl8152_get_strings,\n\t.get_sset_count = rtl8152_get_sset_count,\n\t.get_ethtool_stats = rtl8152_get_ethtool_stats,\n\t.get_coalesce = rtl8152_get_coalesce,\n\t.set_coalesce = rtl8152_set_coalesce,\n\t.get_eee = rtl_ethtool_get_eee,\n\t.set_eee = rtl_ethtool_set_eee,\n\t.get_link_ksettings = rtl8152_get_link_ksettings,\n\t.set_link_ksettings = rtl8152_set_link_ksettings,\n\t.get_tunable = rtl8152_get_tunable,\n\t.set_tunable = rtl8152_set_tunable,\n\t.get_ringparam = rtl8152_get_ringparam,\n\t.set_ringparam = rtl8152_set_ringparam,\n\t.get_pauseparam = rtl8152_get_pauseparam,\n\t.set_pauseparam = rtl8152_set_pauseparam,\n};\n\nstatic int rtl8152_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\n{\n\tstruct r8152 *tp = netdev_priv(netdev);\n\tstruct mii_ioctl_data *data = if_mii(rq);\n\tint res;\n\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn -ENODEV;\n\n\tres = usb_autopm_get_interface(tp->intf);\n\tif (res < 0)\n\t\tgoto out;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = R8152_PHY_ID;  \n\t\tbreak;\n\n\tcase SIOCGMIIREG:\n\t\tmutex_lock(&tp->control);\n\t\tdata->val_out = r8152_mdio_read(tp, data->reg_num);\n\t\tmutex_unlock(&tp->control);\n\t\tbreak;\n\n\tcase SIOCSMIIREG:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tres = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_lock(&tp->control);\n\t\tr8152_mdio_write(tp, data->reg_num, data->val_in);\n\t\tmutex_unlock(&tp->control);\n\t\tbreak;\n\n\tdefault:\n\t\tres = -EOPNOTSUPP;\n\t}\n\n\tusb_autopm_put_interface(tp->intf);\n\nout:\n\treturn res;\n}\n\nstatic int rtl8152_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct r8152 *tp = netdev_priv(dev);\n\tint ret;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_01:\n\tcase RTL_VER_02:\n\tcase RTL_VER_07:\n\t\tdev->mtu = new_mtu;\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = usb_autopm_get_interface(tp->intf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&tp->control);\n\n\tdev->mtu = new_mtu;\n\n\tif (netif_running(dev)) {\n\t\tif (tp->rtl_ops.change_mtu)\n\t\t\ttp->rtl_ops.change_mtu(tp);\n\n\t\tif (netif_carrier_ok(dev)) {\n\t\t\tnetif_stop_queue(dev);\n\t\t\tnapi_disable(&tp->napi);\n\t\t\ttasklet_disable(&tp->tx_tl);\n\t\t\ttp->rtl_ops.disable(tp);\n\t\t\ttp->rtl_ops.enable(tp);\n\t\t\trtl_start_rx(tp);\n\t\t\ttasklet_enable(&tp->tx_tl);\n\t\t\tnapi_enable(&tp->napi);\n\t\t\trtl8152_set_rx_mode(dev);\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t}\n\n\tmutex_unlock(&tp->control);\n\n\tusb_autopm_put_interface(tp->intf);\n\n\treturn ret;\n}\n\nstatic const struct net_device_ops rtl8152_netdev_ops = {\n\t.ndo_open\t\t= rtl8152_open,\n\t.ndo_stop\t\t= rtl8152_close,\n\t.ndo_eth_ioctl\t\t= rtl8152_ioctl,\n\t.ndo_start_xmit\t\t= rtl8152_start_xmit,\n\t.ndo_tx_timeout\t\t= rtl8152_tx_timeout,\n\t.ndo_set_features\t= rtl8152_set_features,\n\t.ndo_set_rx_mode\t= rtl8152_set_rx_mode,\n\t.ndo_set_mac_address\t= rtl8152_set_mac_address,\n\t.ndo_change_mtu\t\t= rtl8152_change_mtu,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_features_check\t= rtl8152_features_check,\n};\n\nstatic void rtl8152_unload(struct r8152 *tp)\n{\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tif (tp->version != RTL_VER_01)\n\t\tr8152_power_cut_en(tp, true);\n}\n\nstatic void rtl8153_unload(struct r8152 *tp)\n{\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tr8153_power_cut_en(tp, false);\n}\n\nstatic void rtl8153b_unload(struct r8152 *tp)\n{\n\tif (test_bit(RTL8152_INACCESSIBLE, &tp->flags))\n\t\treturn;\n\n\tr8153b_power_cut_en(tp, false);\n}\n\nstatic int rtl_ops_init(struct r8152 *tp)\n{\n\tstruct rtl_ops *ops = &tp->rtl_ops;\n\tint ret = 0;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_01:\n\tcase RTL_VER_02:\n\tcase RTL_VER_07:\n\t\tops->init\t\t= r8152b_init;\n\t\tops->enable\t\t= rtl8152_enable;\n\t\tops->disable\t\t= rtl8152_disable;\n\t\tops->up\t\t\t= rtl8152_up;\n\t\tops->down\t\t= rtl8152_down;\n\t\tops->unload\t\t= rtl8152_unload;\n\t\tops->eee_get\t\t= r8152_get_eee;\n\t\tops->eee_set\t\t= r8152_set_eee;\n\t\tops->in_nway\t\t= rtl8152_in_nway;\n\t\tops->hw_phy_cfg\t\t= r8152b_hw_phy_cfg;\n\t\tops->autosuspend_en\t= rtl_runtime_suspend_enable;\n\t\ttp->rx_buf_sz\t\t= 16 * 1024;\n\t\ttp->eee_en\t\t= true;\n\t\ttp->eee_adv\t\t= MDIO_EEE_100TX;\n\t\tbreak;\n\n\tcase RTL_VER_03:\n\tcase RTL_VER_04:\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\t\tops->init\t\t= r8153_init;\n\t\tops->enable\t\t= rtl8153_enable;\n\t\tops->disable\t\t= rtl8153_disable;\n\t\tops->up\t\t\t= rtl8153_up;\n\t\tops->down\t\t= rtl8153_down;\n\t\tops->unload\t\t= rtl8153_unload;\n\t\tops->eee_get\t\t= r8153_get_eee;\n\t\tops->eee_set\t\t= r8152_set_eee;\n\t\tops->in_nway\t\t= rtl8153_in_nway;\n\t\tops->hw_phy_cfg\t\t= r8153_hw_phy_cfg;\n\t\tops->autosuspend_en\t= rtl8153_runtime_enable;\n\t\tops->change_mtu\t\t= rtl8153_change_mtu;\n\t\tif (tp->udev->speed < USB_SPEED_SUPER)\n\t\t\ttp->rx_buf_sz\t= 16 * 1024;\n\t\telse\n\t\t\ttp->rx_buf_sz\t= 32 * 1024;\n\t\ttp->eee_en\t\t= true;\n\t\ttp->eee_adv\t\t= MDIO_EEE_1000T | MDIO_EEE_100TX;\n\t\tbreak;\n\n\tcase RTL_VER_08:\n\tcase RTL_VER_09:\n\t\tops->init\t\t= r8153b_init;\n\t\tops->enable\t\t= rtl8153_enable;\n\t\tops->disable\t\t= rtl8153_disable;\n\t\tops->up\t\t\t= rtl8153b_up;\n\t\tops->down\t\t= rtl8153b_down;\n\t\tops->unload\t\t= rtl8153b_unload;\n\t\tops->eee_get\t\t= r8153_get_eee;\n\t\tops->eee_set\t\t= r8152_set_eee;\n\t\tops->in_nway\t\t= rtl8153_in_nway;\n\t\tops->hw_phy_cfg\t\t= r8153b_hw_phy_cfg;\n\t\tops->autosuspend_en\t= rtl8153b_runtime_enable;\n\t\tops->change_mtu\t\t= rtl8153_change_mtu;\n\t\ttp->rx_buf_sz\t\t= 32 * 1024;\n\t\ttp->eee_en\t\t= true;\n\t\ttp->eee_adv\t\t= MDIO_EEE_1000T | MDIO_EEE_100TX;\n\t\tbreak;\n\n\tcase RTL_VER_11:\n\t\ttp->eee_en\t\t= true;\n\t\ttp->eee_adv\t\t= MDIO_EEE_1000T | MDIO_EEE_100TX;\n\t\tfallthrough;\n\tcase RTL_VER_10:\n\t\tops->init\t\t= r8156_init;\n\t\tops->enable\t\t= rtl8156_enable;\n\t\tops->disable\t\t= rtl8156_disable;\n\t\tops->up\t\t\t= rtl8156_up;\n\t\tops->down\t\t= rtl8156_down;\n\t\tops->unload\t\t= rtl8153_unload;\n\t\tops->eee_get\t\t= r8153_get_eee;\n\t\tops->eee_set\t\t= r8152_set_eee;\n\t\tops->in_nway\t\t= rtl8153_in_nway;\n\t\tops->hw_phy_cfg\t\t= r8156_hw_phy_cfg;\n\t\tops->autosuspend_en\t= rtl8156_runtime_enable;\n\t\tops->change_mtu\t\t= rtl8156_change_mtu;\n\t\ttp->rx_buf_sz\t\t= 48 * 1024;\n\t\ttp->support_2500full\t= 1;\n\t\tbreak;\n\n\tcase RTL_VER_12:\n\tcase RTL_VER_13:\n\t\ttp->support_2500full\t= 1;\n\t\tfallthrough;\n\tcase RTL_VER_15:\n\t\ttp->eee_en\t\t= true;\n\t\ttp->eee_adv\t\t= MDIO_EEE_1000T | MDIO_EEE_100TX;\n\t\tops->init\t\t= r8156b_init;\n\t\tops->enable\t\t= rtl8156b_enable;\n\t\tops->disable\t\t= rtl8153_disable;\n\t\tops->up\t\t\t= rtl8156_up;\n\t\tops->down\t\t= rtl8156_down;\n\t\tops->unload\t\t= rtl8153_unload;\n\t\tops->eee_get\t\t= r8153_get_eee;\n\t\tops->eee_set\t\t= r8152_set_eee;\n\t\tops->in_nway\t\t= rtl8153_in_nway;\n\t\tops->hw_phy_cfg\t\t= r8156b_hw_phy_cfg;\n\t\tops->autosuspend_en\t= rtl8156_runtime_enable;\n\t\tops->change_mtu\t\t= rtl8156_change_mtu;\n\t\ttp->rx_buf_sz\t\t= 48 * 1024;\n\t\tbreak;\n\n\tcase RTL_VER_14:\n\t\tops->init\t\t= r8153c_init;\n\t\tops->enable\t\t= rtl8153_enable;\n\t\tops->disable\t\t= rtl8153_disable;\n\t\tops->up\t\t\t= rtl8153c_up;\n\t\tops->down\t\t= rtl8153b_down;\n\t\tops->unload\t\t= rtl8153_unload;\n\t\tops->eee_get\t\t= r8153_get_eee;\n\t\tops->eee_set\t\t= r8152_set_eee;\n\t\tops->in_nway\t\t= rtl8153_in_nway;\n\t\tops->hw_phy_cfg\t\t= r8153c_hw_phy_cfg;\n\t\tops->autosuspend_en\t= rtl8153c_runtime_enable;\n\t\tops->change_mtu\t\t= rtl8153c_change_mtu;\n\t\ttp->rx_buf_sz\t\t= 32 * 1024;\n\t\ttp->eee_en\t\t= true;\n\t\ttp->eee_adv\t\t= MDIO_EEE_1000T | MDIO_EEE_100TX;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENODEV;\n\t\tdev_err(&tp->intf->dev, \"Unknown Device\\n\");\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n#define FIRMWARE_8153A_2\t\"rtl_nic/rtl8153a-2.fw\"\n#define FIRMWARE_8153A_3\t\"rtl_nic/rtl8153a-3.fw\"\n#define FIRMWARE_8153A_4\t\"rtl_nic/rtl8153a-4.fw\"\n#define FIRMWARE_8153B_2\t\"rtl_nic/rtl8153b-2.fw\"\n#define FIRMWARE_8153C_1\t\"rtl_nic/rtl8153c-1.fw\"\n#define FIRMWARE_8156A_2\t\"rtl_nic/rtl8156a-2.fw\"\n#define FIRMWARE_8156B_2\t\"rtl_nic/rtl8156b-2.fw\"\n\nMODULE_FIRMWARE(FIRMWARE_8153A_2);\nMODULE_FIRMWARE(FIRMWARE_8153A_3);\nMODULE_FIRMWARE(FIRMWARE_8153A_4);\nMODULE_FIRMWARE(FIRMWARE_8153B_2);\nMODULE_FIRMWARE(FIRMWARE_8153C_1);\nMODULE_FIRMWARE(FIRMWARE_8156A_2);\nMODULE_FIRMWARE(FIRMWARE_8156B_2);\n\nstatic int rtl_fw_init(struct r8152 *tp)\n{\n\tstruct rtl_fw *rtl_fw = &tp->rtl_fw;\n\n\tswitch (tp->version) {\n\tcase RTL_VER_04:\n\t\trtl_fw->fw_name\t\t= FIRMWARE_8153A_2;\n\t\trtl_fw->pre_fw\t\t= r8153_pre_firmware_1;\n\t\trtl_fw->post_fw\t\t= r8153_post_firmware_1;\n\t\tbreak;\n\tcase RTL_VER_05:\n\t\trtl_fw->fw_name\t\t= FIRMWARE_8153A_3;\n\t\trtl_fw->pre_fw\t\t= r8153_pre_firmware_2;\n\t\trtl_fw->post_fw\t\t= r8153_post_firmware_2;\n\t\tbreak;\n\tcase RTL_VER_06:\n\t\trtl_fw->fw_name\t\t= FIRMWARE_8153A_4;\n\t\trtl_fw->post_fw\t\t= r8153_post_firmware_3;\n\t\tbreak;\n\tcase RTL_VER_09:\n\t\trtl_fw->fw_name\t\t= FIRMWARE_8153B_2;\n\t\trtl_fw->pre_fw\t\t= r8153b_pre_firmware_1;\n\t\trtl_fw->post_fw\t\t= r8153b_post_firmware_1;\n\t\tbreak;\n\tcase RTL_VER_11:\n\t\trtl_fw->fw_name\t\t= FIRMWARE_8156A_2;\n\t\trtl_fw->post_fw\t\t= r8156a_post_firmware_1;\n\t\tbreak;\n\tcase RTL_VER_13:\n\tcase RTL_VER_15:\n\t\trtl_fw->fw_name\t\t= FIRMWARE_8156B_2;\n\t\tbreak;\n\tcase RTL_VER_14:\n\t\trtl_fw->fw_name\t\t= FIRMWARE_8153C_1;\n\t\trtl_fw->pre_fw\t\t= r8153b_pre_firmware_1;\n\t\trtl_fw->post_fw\t\t= r8153c_post_firmware_1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 __rtl_get_hw_ver(struct usb_device *udev)\n{\n\tu32 ocp_data = 0;\n\t__le32 *tmp;\n\tu8 version;\n\tint ret;\n\tint i;\n\n\ttmp = kmalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t      RTL8152_REQ_GET_REGS, RTL8152_REQT_READ,\n\t\t\t\t      PLA_TCR0, MCU_TYPE_PLA, tmp, sizeof(*tmp),\n\t\t\t\t      USB_CTRL_GET_TIMEOUT);\n\t\tif (ret > 0) {\n\t\t\tocp_data = (__le32_to_cpu(*tmp) >> 16) & VERSION_MASK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i != 0 && ret > 0)\n\t\tdev_warn(&udev->dev, \"Needed %d retries to read version\\n\", i);\n\n\tkfree(tmp);\n\n\tswitch (ocp_data) {\n\tcase 0x4c00:\n\t\tversion = RTL_VER_01;\n\t\tbreak;\n\tcase 0x4c10:\n\t\tversion = RTL_VER_02;\n\t\tbreak;\n\tcase 0x5c00:\n\t\tversion = RTL_VER_03;\n\t\tbreak;\n\tcase 0x5c10:\n\t\tversion = RTL_VER_04;\n\t\tbreak;\n\tcase 0x5c20:\n\t\tversion = RTL_VER_05;\n\t\tbreak;\n\tcase 0x5c30:\n\t\tversion = RTL_VER_06;\n\t\tbreak;\n\tcase 0x4800:\n\t\tversion = RTL_VER_07;\n\t\tbreak;\n\tcase 0x6000:\n\t\tversion = RTL_VER_08;\n\t\tbreak;\n\tcase 0x6010:\n\t\tversion = RTL_VER_09;\n\t\tbreak;\n\tcase 0x7010:\n\t\tversion = RTL_TEST_01;\n\t\tbreak;\n\tcase 0x7020:\n\t\tversion = RTL_VER_10;\n\t\tbreak;\n\tcase 0x7030:\n\t\tversion = RTL_VER_11;\n\t\tbreak;\n\tcase 0x7400:\n\t\tversion = RTL_VER_12;\n\t\tbreak;\n\tcase 0x7410:\n\t\tversion = RTL_VER_13;\n\t\tbreak;\n\tcase 0x6400:\n\t\tversion = RTL_VER_14;\n\t\tbreak;\n\tcase 0x7420:\n\t\tversion = RTL_VER_15;\n\t\tbreak;\n\tdefault:\n\t\tversion = RTL_VER_UNKNOWN;\n\t\tdev_info(&udev->dev, \"Unknown version 0x%04x\\n\", ocp_data);\n\t\tbreak;\n\t}\n\n\treturn version;\n}\n\nu8 rtl8152_get_version(struct usb_interface *intf)\n{\n\tu8 version;\n\n\tversion = __rtl_get_hw_ver(interface_to_usbdev(intf));\n\n\tdev_dbg(&intf->dev, \"Detected version 0x%04x\\n\", version);\n\n\treturn version;\n}\nEXPORT_SYMBOL_GPL(rtl8152_get_version);\n\nstatic bool rtl8152_supports_lenovo_macpassthru(struct usb_device *udev)\n{\n\tint parent_vendor_id = le16_to_cpu(udev->parent->descriptor.idVendor);\n\tint product_id = le16_to_cpu(udev->descriptor.idProduct);\n\tint vendor_id = le16_to_cpu(udev->descriptor.idVendor);\n\n\tif (vendor_id == VENDOR_ID_LENOVO) {\n\t\tswitch (product_id) {\n\t\tcase DEVICE_ID_LENOVO_USB_C_TRAVEL_HUB:\n\t\tcase DEVICE_ID_THINKPAD_ONELINK_PLUS_DOCK:\n\t\tcase DEVICE_ID_THINKPAD_THUNDERBOLT3_DOCK_GEN2:\n\t\tcase DEVICE_ID_THINKPAD_USB_C_DOCK_GEN2:\n\t\tcase DEVICE_ID_THINKPAD_USB_C_DOCK_GEN3:\n\t\tcase DEVICE_ID_THINKPAD_USB_C_DONGLE:\n\t\t\treturn 1;\n\t\t}\n\t} else if (vendor_id == VENDOR_ID_REALTEK && parent_vendor_id == VENDOR_ID_LENOVO) {\n\t\tswitch (product_id) {\n\t\tcase 0x8153:\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int rtl8152_probe_once(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id, u8 version)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct r8152 *tp;\n\tstruct net_device *netdev;\n\tint ret;\n\n\tusb_reset_device(udev);\n\tnetdev = alloc_etherdev(sizeof(struct r8152));\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"Out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\ttp = netdev_priv(netdev);\n\ttp->msg_enable = 0x7FFF;\n\n\ttp->udev = udev;\n\ttp->netdev = netdev;\n\ttp->intf = intf;\n\ttp->version = version;\n\n\ttp->pipe_ctrl_in = usb_rcvctrlpipe(udev, 0);\n\ttp->pipe_ctrl_out = usb_sndctrlpipe(udev, 0);\n\ttp->pipe_in = usb_rcvbulkpipe(udev, 1);\n\ttp->pipe_out = usb_sndbulkpipe(udev, 2);\n\ttp->pipe_intr = usb_rcvintpipe(udev, 3);\n\n\tswitch (version) {\n\tcase RTL_VER_01:\n\tcase RTL_VER_02:\n\tcase RTL_VER_07:\n\t\ttp->mii.supports_gmii = 0;\n\t\tbreak;\n\tdefault:\n\t\ttp->mii.supports_gmii = 1;\n\t\tbreak;\n\t}\n\n\tret = rtl_ops_init(tp);\n\tif (ret)\n\t\tgoto out;\n\n\trtl_fw_init(tp);\n\n\tmutex_init(&tp->control);\n\tINIT_DELAYED_WORK(&tp->schedule, rtl_work_func_t);\n\tINIT_DELAYED_WORK(&tp->hw_phy_work, rtl_hw_phy_work_func_t);\n\ttasklet_setup(&tp->tx_tl, bottom_half);\n\ttasklet_disable(&tp->tx_tl);\n\n\tnetdev->netdev_ops = &rtl8152_netdev_ops;\n\tnetdev->watchdog_timeo = RTL8152_TX_TIMEOUT;\n\n\tnetdev->features |= NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG |\n\t\t\t    NETIF_F_TSO | NETIF_F_FRAGLIST | NETIF_F_IPV6_CSUM |\n\t\t\t    NETIF_F_TSO6 | NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_TX;\n\tnetdev->hw_features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG |\n\t\t\t      NETIF_F_TSO | NETIF_F_FRAGLIST |\n\t\t\t      NETIF_F_IPV6_CSUM | NETIF_F_TSO6 |\n\t\t\t      NETIF_F_HW_VLAN_CTAG_RX | NETIF_F_HW_VLAN_CTAG_TX;\n\tnetdev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |\n\t\t\t\tNETIF_F_HIGHDMA | NETIF_F_FRAGLIST |\n\t\t\t\tNETIF_F_IPV6_CSUM | NETIF_F_TSO6;\n\n\tif (tp->version == RTL_VER_01) {\n\t\tnetdev->features &= ~NETIF_F_RXCSUM;\n\t\tnetdev->hw_features &= ~NETIF_F_RXCSUM;\n\t}\n\n\ttp->lenovo_macpassthru = rtl8152_supports_lenovo_macpassthru(udev);\n\n\tif (le16_to_cpu(udev->descriptor.bcdDevice) == 0x3011 && udev->serial &&\n\t    (!strcmp(udev->serial, \"000001000000\") ||\n\t     !strcmp(udev->serial, \"000002000000\"))) {\n\t\tdev_info(&udev->dev, \"Dell TB16 Dock, disable RX aggregation\");\n\t\ttp->dell_tb_rx_agg_bug = 1;\n\t}\n\n\tnetdev->ethtool_ops = &ops;\n\tnetif_set_tso_max_size(netdev, RTL_LIMITED_TSO_SIZE);\n\n\t \n\tnetdev->min_mtu = ETH_MIN_MTU;\n\tswitch (tp->version) {\n\tcase RTL_VER_03:\n\tcase RTL_VER_04:\n\tcase RTL_VER_05:\n\tcase RTL_VER_06:\n\tcase RTL_VER_08:\n\tcase RTL_VER_09:\n\tcase RTL_VER_14:\n\t\tnetdev->max_mtu = size_to_mtu(9 * 1024);\n\t\tbreak;\n\tcase RTL_VER_10:\n\tcase RTL_VER_11:\n\t\tnetdev->max_mtu = size_to_mtu(15 * 1024);\n\t\tbreak;\n\tcase RTL_VER_12:\n\tcase RTL_VER_13:\n\tcase RTL_VER_15:\n\t\tnetdev->max_mtu = size_to_mtu(16 * 1024);\n\t\tbreak;\n\tcase RTL_VER_01:\n\tcase RTL_VER_02:\n\tcase RTL_VER_07:\n\tdefault:\n\t\tnetdev->max_mtu = ETH_DATA_LEN;\n\t\tbreak;\n\t}\n\n\ttp->mii.dev = netdev;\n\ttp->mii.mdio_read = read_mii_word;\n\ttp->mii.mdio_write = write_mii_word;\n\ttp->mii.phy_id_mask = 0x3f;\n\ttp->mii.reg_num_mask = 0x1f;\n\ttp->mii.phy_id = R8152_PHY_ID;\n\n\ttp->autoneg = AUTONEG_ENABLE;\n\ttp->speed = SPEED_100;\n\ttp->advertising = RTL_ADVERTISED_10_HALF | RTL_ADVERTISED_10_FULL |\n\t\t\t  RTL_ADVERTISED_100_HALF | RTL_ADVERTISED_100_FULL;\n\tif (tp->mii.supports_gmii) {\n\t\tif (tp->support_2500full &&\n\t\t    tp->udev->speed >= USB_SPEED_SUPER) {\n\t\t\ttp->speed = SPEED_2500;\n\t\t\ttp->advertising |= RTL_ADVERTISED_2500_FULL;\n\t\t} else {\n\t\t\ttp->speed = SPEED_1000;\n\t\t}\n\t\ttp->advertising |= RTL_ADVERTISED_1000_FULL;\n\t}\n\ttp->duplex = DUPLEX_FULL;\n\n\ttp->rx_copybreak = RTL8152_RXFG_HEADSZ;\n\ttp->rx_pending = 10 * RTL8152_MAX_RX;\n\n\tintf->needs_remote_wakeup = 1;\n\n\tif (!rtl_can_wakeup(tp))\n\t\t__rtl_set_wol(tp, 0);\n\telse\n\t\ttp->saved_wolopts = __rtl_get_wol(tp);\n\n\ttp->rtl_ops.init(tp);\n#if IS_BUILTIN(CONFIG_USB_RTL8152)\n\t \n\ttp->rtl_fw.retry = true;\n#endif\n\tqueue_delayed_work(system_long_wq, &tp->hw_phy_work, 0);\n\tset_ethernet_addr(tp, false);\n\n\tusb_set_intfdata(intf, tp);\n\n\tnetif_napi_add(netdev, &tp->napi, r8152_poll);\n\n\tret = register_netdev(netdev);\n\tif (ret != 0) {\n\t\tdev_err(&intf->dev, \"couldn't register the device\\n\");\n\t\tgoto out1;\n\t}\n\n\tif (tp->saved_wolopts)\n\t\tdevice_set_wakeup_enable(&udev->dev, true);\n\telse\n\t\tdevice_set_wakeup_enable(&udev->dev, false);\n\n\t \n\tif (test_bit(PROBE_SHOULD_RETRY, &tp->flags))\n\t\tgoto out2;\n\n\tset_bit(PROBED_WITH_NO_ERRORS, &tp->flags);\n\tnetif_info(tp, probe, netdev, \"%s\\n\", DRIVER_VERSION);\n\n\treturn 0;\n\nout2:\n\tunregister_netdev(netdev);\n\nout1:\n\ttasklet_kill(&tp->tx_tl);\n\tcancel_delayed_work_sync(&tp->hw_phy_work);\n\tif (tp->rtl_ops.unload)\n\t\ttp->rtl_ops.unload(tp);\n\trtl8152_release_firmware(tp);\n\tusb_set_intfdata(intf, NULL);\nout:\n\tif (test_bit(PROBE_SHOULD_RETRY, &tp->flags))\n\t\tret = -EAGAIN;\n\n\tfree_netdev(netdev);\n\treturn ret;\n}\n\n#define RTL8152_PROBE_TRIES\t3\n\nstatic int rtl8152_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tu8 version;\n\tint ret;\n\tint i;\n\n\tif (intf->cur_altsetting->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC)\n\t\treturn -ENODEV;\n\n\tif (!rtl_check_vendor_ok(intf))\n\t\treturn -ENODEV;\n\n\tversion = rtl8152_get_version(intf);\n\tif (version == RTL_VER_UNKNOWN)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < RTL8152_PROBE_TRIES; i++) {\n\t\tret = rtl8152_probe_once(intf, id, version);\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\t}\n\tif (ret == -EAGAIN) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"r8152 failed probe after %d tries; giving up\\n\", i);\n\t\treturn -ENODEV;\n\t}\n\n\treturn ret;\n}\n\nstatic void rtl8152_disconnect(struct usb_interface *intf)\n{\n\tstruct r8152 *tp = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tif (tp) {\n\t\trtl_set_unplug(tp);\n\n\t\tunregister_netdev(tp->netdev);\n\t\ttasklet_kill(&tp->tx_tl);\n\t\tcancel_delayed_work_sync(&tp->hw_phy_work);\n\t\tif (tp->rtl_ops.unload)\n\t\t\ttp->rtl_ops.unload(tp);\n\t\trtl8152_release_firmware(tp);\n\t\tfree_netdev(tp->netdev);\n\t}\n}\n\n \nstatic const struct usb_device_id rtl8152_table[] = {\n\t \n\t{ USB_DEVICE(VENDOR_ID_REALTEK, 0x8050) },\n\t{ USB_DEVICE(VENDOR_ID_REALTEK, 0x8053) },\n\t{ USB_DEVICE(VENDOR_ID_REALTEK, 0x8152) },\n\t{ USB_DEVICE(VENDOR_ID_REALTEK, 0x8153) },\n\t{ USB_DEVICE(VENDOR_ID_REALTEK, 0x8155) },\n\t{ USB_DEVICE(VENDOR_ID_REALTEK, 0x8156) },\n\n\t \n\t{ USB_DEVICE(VENDOR_ID_MICROSOFT, 0x07ab) },\n\t{ USB_DEVICE(VENDOR_ID_MICROSOFT, 0x07c6) },\n\t{ USB_DEVICE(VENDOR_ID_MICROSOFT, 0x0927) },\n\t{ USB_DEVICE(VENDOR_ID_MICROSOFT, 0x0c5e) },\n\t{ USB_DEVICE(VENDOR_ID_SAMSUNG, 0xa101) },\n\t{ USB_DEVICE(VENDOR_ID_LENOVO,  0x304f) },\n\t{ USB_DEVICE(VENDOR_ID_LENOVO,  0x3054) },\n\t{ USB_DEVICE(VENDOR_ID_LENOVO,  0x3062) },\n\t{ USB_DEVICE(VENDOR_ID_LENOVO,  0x3069) },\n\t{ USB_DEVICE(VENDOR_ID_LENOVO,  0x3082) },\n\t{ USB_DEVICE(VENDOR_ID_LENOVO,  0x7205) },\n\t{ USB_DEVICE(VENDOR_ID_LENOVO,  0x720c) },\n\t{ USB_DEVICE(VENDOR_ID_LENOVO,  0x7214) },\n\t{ USB_DEVICE(VENDOR_ID_LENOVO,  0x721e) },\n\t{ USB_DEVICE(VENDOR_ID_LENOVO,  0xa387) },\n\t{ USB_DEVICE(VENDOR_ID_LINKSYS, 0x0041) },\n\t{ USB_DEVICE(VENDOR_ID_NVIDIA,  0x09ff) },\n\t{ USB_DEVICE(VENDOR_ID_TPLINK,  0x0601) },\n\t{ USB_DEVICE(VENDOR_ID_DLINK,   0xb301) },\n\t{ USB_DEVICE(VENDOR_ID_ASUS,    0x1976) },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, rtl8152_table);\n\nstatic struct usb_driver rtl8152_driver = {\n\t.name =\t\tMODULENAME,\n\t.id_table =\trtl8152_table,\n\t.probe =\trtl8152_probe,\n\t.disconnect =\trtl8152_disconnect,\n\t.suspend =\trtl8152_suspend,\n\t.resume =\trtl8152_resume,\n\t.reset_resume =\trtl8152_reset_resume,\n\t.pre_reset =\trtl8152_pre_reset,\n\t.post_reset =\trtl8152_post_reset,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nstatic int rtl8152_cfgselector_probe(struct usb_device *udev)\n{\n\tstruct usb_host_config *c;\n\tint i, num_configs;\n\n\t \n\tif (__rtl_get_hw_ver(udev) == RTL_VER_UNKNOWN)\n\t\treturn 0;\n\n\t \n\tc = udev->config;\n\tnum_configs = udev->descriptor.bNumConfigurations;\n\tfor (i = 0; i < num_configs; (i++, c++)) {\n\t\tstruct usb_interface_descriptor\t*desc = NULL;\n\n\t\tif (!c->desc.bNumInterfaces)\n\t\t\tcontinue;\n\t\tdesc = &c->intf_cache[0]->altsetting->desc;\n\t\tif (desc->bInterfaceClass == USB_CLASS_VENDOR_SPEC)\n\t\t\tbreak;\n\t}\n\n\tif (i == num_configs)\n\t\treturn -ENODEV;\n\n\tif (usb_set_configuration(udev, c->desc.bConfigurationValue)) {\n\t\tdev_err(&udev->dev, \"Failed to set configuration %d\\n\",\n\t\t\tc->desc.bConfigurationValue);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic struct usb_device_driver rtl8152_cfgselector_driver = {\n\t.name =\t\tMODULENAME \"-cfgselector\",\n\t.probe =\trtl8152_cfgselector_probe,\n\t.id_table =\trtl8152_table,\n\t.generic_subclass = 1,\n\t.supports_autosuspend = 1,\n};\n\nstatic int __init rtl8152_driver_init(void)\n{\n\tint ret;\n\n\tret = usb_register_device_driver(&rtl8152_cfgselector_driver, THIS_MODULE);\n\tif (ret)\n\t\treturn ret;\n\treturn usb_register(&rtl8152_driver);\n}\n\nstatic void __exit rtl8152_driver_exit(void)\n{\n\tusb_deregister(&rtl8152_driver);\n\tusb_deregister_device_driver(&rtl8152_cfgselector_driver);\n}\n\nmodule_init(rtl8152_driver_init);\nmodule_exit(rtl8152_driver_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRIVER_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}