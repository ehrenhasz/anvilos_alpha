{
  "module_name": "cdc_mbim.c",
  "hash_id": "fe984b0841ea17169614a622ae6a957dbe25aca257c76bd9657826a29b698e29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/cdc_mbim.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/usbnet.h>\n#include <linux/usb/cdc-wdm.h>\n#include <linux/usb/cdc_ncm.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <net/ipv6_stubs.h>\n#include <net/ndisc.h>\n\n \n#define MBIM_IPS0_VID\t4094\n\n \nstruct cdc_mbim_state {\n\tstruct cdc_ncm_ctx *ctx;\n\tatomic_t pmcount;\n\tstruct usb_driver *subdriver;\n\tunsigned long _unused;\n\tunsigned long flags;\n};\n\n \nenum cdc_mbim_flags {\n\tFLAG_IPS0_VLAN = 1 << 0,\t \n};\n\n \nstatic int cdc_mbim_manage_power(struct usbnet *dev, int on)\n{\n\tstruct cdc_mbim_state *info = (void *)&dev->data;\n\tint rv = 0;\n\n\tdev_dbg(&dev->intf->dev, \"%s() pmcount=%d, on=%d\\n\", __func__, atomic_read(&info->pmcount), on);\n\n\tif ((on && atomic_add_return(1, &info->pmcount) == 1) || (!on && atomic_dec_and_test(&info->pmcount))) {\n\t\t \n\t\trv = usb_autopm_get_interface(dev->intf);\n\t\tdev->intf->needs_remote_wakeup = on;\n\t\tif (!rv)\n\t\t\tusb_autopm_put_interface(dev->intf);\n\t}\n\treturn 0;\n}\n\nstatic int cdc_mbim_wdm_manage_power(struct usb_interface *intf, int status)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\n\t \n\tif (!dev)\n\t\treturn 0;\n\n\treturn cdc_mbim_manage_power(dev, status);\n}\n\nstatic int cdc_mbim_rx_add_vid(struct net_device *netdev, __be16 proto, u16 vid)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tstruct cdc_mbim_state *info = (void *)&dev->data;\n\n\t \n\tif (vid == MBIM_IPS0_VID)\n\t\tinfo->flags |= FLAG_IPS0_VLAN;\n\telse\n\t\tif (vid >= 512)\t \n\t\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int cdc_mbim_rx_kill_vid(struct net_device *netdev, __be16 proto, u16 vid)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tstruct cdc_mbim_state *info = (void *)&dev->data;\n\n\t \n\tif (vid == MBIM_IPS0_VID)\n\t\tinfo->flags &= ~FLAG_IPS0_VLAN;\n\treturn 0;\n}\n\nstatic const struct net_device_ops cdc_mbim_netdev_ops = {\n\t.ndo_open             = usbnet_open,\n\t.ndo_stop             = usbnet_stop,\n\t.ndo_start_xmit       = usbnet_start_xmit,\n\t.ndo_tx_timeout       = usbnet_tx_timeout,\n\t.ndo_get_stats64      = dev_get_tstats64,\n\t.ndo_change_mtu       = cdc_ncm_change_mtu,\n\t.ndo_set_mac_address  = eth_mac_addr,\n\t.ndo_validate_addr    = eth_validate_addr,\n\t.ndo_vlan_rx_add_vid  = cdc_mbim_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid = cdc_mbim_rx_kill_vid,\n};\n\n \nstatic int cdc_mbim_set_ctrlalt(struct usbnet *dev, struct usb_interface *intf, u8 alt)\n{\n\tstruct usb_driver *driver = to_usb_driver(intf->dev.driver);\n\tconst struct usb_device_id *id;\n\tstruct driver_info *info;\n\tint ret;\n\n\tret = usb_set_interface(dev->udev,\n\t\t\t\tintf->cur_altsetting->desc.bInterfaceNumber,\n\t\t\t\talt);\n\tif (ret)\n\t\treturn ret;\n\n\tid = usb_match_id(intf, driver->id_table);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tinfo = (struct driver_info *)id->driver_info;\n\tif (info != dev->driver_info) {\n\t\tdev_dbg(&intf->dev, \"driver_info updated to '%s'\\n\",\n\t\t\tinfo->description);\n\t\tdev->driver_info = info;\n\t}\n\treturn 0;\n}\n\nstatic int cdc_mbim_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct cdc_ncm_ctx *ctx;\n\tstruct usb_driver *subdriver = ERR_PTR(-ENODEV);\n\tint ret = -ENODEV;\n\tu8 data_altsetting = 1;\n\tstruct cdc_mbim_state *info = (void *)&dev->data;\n\n\t \n\tif (cdc_ncm_select_altsetting(intf) == CDC_NCM_COMM_ALTSETTING_MBIM) {\n\t\tdata_altsetting = CDC_NCM_DATA_ALTSETTING_MBIM;\n\t\tret = cdc_mbim_set_ctrlalt(dev, intf, CDC_NCM_COMM_ALTSETTING_MBIM);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = -ENODEV;\n\t}\n\n\t \n\tif (!cdc_ncm_comm_intf_is_mbim(intf->cur_altsetting))\n\t\tgoto err;\n\n\tret = cdc_ncm_bind_common(dev, intf, data_altsetting, dev->driver_info->data);\n\tif (ret)\n\t\tgoto err;\n\n\tctx = info->ctx;\n\n\t \n\tif (ctx->mbim_desc && dev->status)\n\t\tsubdriver = usb_cdc_wdm_register(ctx->control,\n\t\t\t\t\t\t &dev->status->desc,\n\t\t\t\t\t\t le16_to_cpu(ctx->mbim_desc->wMaxControlMessage),\n\t\t\t\t\t\t WWAN_PORT_MBIM,\n\t\t\t\t\t\t cdc_mbim_wdm_manage_power);\n\tif (IS_ERR(subdriver)) {\n\t\tret = PTR_ERR(subdriver);\n\t\tcdc_ncm_unbind(dev, intf);\n\t\tgoto err;\n\t}\n\n\t \n\tdev->status = NULL;\n\tinfo->subdriver = subdriver;\n\n\t \n\tdev->net->flags |= IFF_NOARP;\n\n\t \n\tdev->net->features |= NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\t \n\tdev->net->netdev_ops = &cdc_mbim_netdev_ops;\nerr:\n\treturn ret;\n}\n\nstatic void cdc_mbim_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct cdc_mbim_state *info = (void *)&dev->data;\n\tstruct cdc_ncm_ctx *ctx = info->ctx;\n\n\t \n\tif (info->subdriver && info->subdriver->disconnect)\n\t\tinfo->subdriver->disconnect(ctx->control);\n\tinfo->subdriver = NULL;\n\n\t \n\tcdc_ncm_unbind(dev, intf);\n}\n\n \nstatic bool is_ip_proto(__be16 proto)\n{\n\tswitch (proto) {\n\tcase htons(ETH_P_IP):\n\tcase htons(ETH_P_IPV6):\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic struct sk_buff *cdc_mbim_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\n{\n\tstruct sk_buff *skb_out;\n\tstruct cdc_mbim_state *info = (void *)&dev->data;\n\tstruct cdc_ncm_ctx *ctx = info->ctx;\n\t__le32 sign = cpu_to_le32(USB_CDC_MBIM_NDP16_IPS_SIGN);\n\tu16 tci = 0;\n\tbool is_ip;\n\tu8 *c;\n\n\tif (!ctx)\n\t\tgoto error;\n\n\tif (skb) {\n\t\tif (skb->len <= ETH_HLEN)\n\t\t\tgoto error;\n\n\t\t \n\t\tskb_reset_mac_header(skb);\n\t\tif (vlan_get_tag(skb, &tci) < 0 && skb->len > VLAN_ETH_HLEN &&\n\t\t    __vlan_get_tag(skb, &tci) == 0) {\n\t\t\tis_ip = is_ip_proto(vlan_eth_hdr(skb)->h_vlan_encapsulated_proto);\n\t\t\tskb_pull(skb, VLAN_ETH_HLEN);\n\t\t} else {\n\t\t\tis_ip = is_ip_proto(eth_hdr(skb)->h_proto);\n\t\t\tskb_pull(skb, ETH_HLEN);\n\t\t}\n\n\t\t \n\t\tif (info->flags & FLAG_IPS0_VLAN) {\n\t\t\t \n\t\t\tif (!tci)\n\t\t\t\tgoto error;\n\t\t\t \n\t\t\tif (tci == MBIM_IPS0_VID)\n\t\t\t\ttci = 0;\n\t\t}\n\n\t\t \n\n\t\tswitch (tci & 0x0f00) {\n\t\tcase 0x0000:  \n\t\t\tif (!is_ip)\n\t\t\t\tgoto error;\n\t\t\tc = (u8 *)&sign;\n\t\t\tc[3] = tci;\n\t\t\tbreak;\n\t\tcase 0x0100:  \n\t\t\tif (is_ip)\n\t\t\t\tgoto error;\n\t\t\tsign = cpu_to_le32(USB_CDC_MBIM_NDP16_DSS_SIGN);\n\t\t\tc = (u8 *)&sign;\n\t\t\tc[3] = tci;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetif_err(dev, tx_err, dev->net,\n\t\t\t\t  \"unsupported tci=0x%04x\\n\", tci);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tspin_lock_bh(&ctx->mtx);\n\tskb_out = cdc_ncm_fill_tx_frame(dev, skb, sign);\n\tspin_unlock_bh(&ctx->mtx);\n\treturn skb_out;\n\nerror:\n\tif (skb)\n\t\tdev_kfree_skb_any(skb);\n\n\treturn NULL;\n}\n\n \nstatic void do_neigh_solicit(struct usbnet *dev, u8 *buf, u16 tci)\n{\n\tstruct ipv6hdr *iph = (void *)buf;\n\tstruct nd_msg *msg = (void *)(iph + 1);\n\tstruct net_device *netdev;\n\tstruct inet6_dev *in6_dev;\n\tbool is_router;\n\n\t \n\tif (!ipv6_addr_is_solict_mult(&iph->daddr) ||\n\t    !(ipv6_addr_type(&iph->saddr) & IPV6_ADDR_UNICAST))\n\t\treturn;\n\n\t \n\trcu_read_lock();\n\tif (tci) {\n\t\tnetdev = __vlan_find_dev_deep_rcu(dev->net, htons(ETH_P_8021Q),\n\t\t\t\t\t\t  tci);\n\t\tif (!netdev) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tnetdev = dev->net;\n\t}\n\tdev_hold(netdev);\n\trcu_read_unlock();\n\n\tin6_dev = in6_dev_get(netdev);\n\tif (!in6_dev)\n\t\tgoto out;\n\tis_router = !!in6_dev->cnf.forwarding;\n\tin6_dev_put(in6_dev);\n\n\t \n\tipv6_stub->ndisc_send_na(netdev, &iph->saddr, &msg->target,\n\t\t\t\t is_router  ,\n\t\t\t\t true  ,\n\t\t\t\t false  ,\n\t\t\t\t true  );\nout:\n\tdev_put(netdev);\n}\n\nstatic bool is_neigh_solicit(u8 *buf, size_t len)\n{\n\tstruct ipv6hdr *iph = (void *)buf;\n\tstruct nd_msg *msg = (void *)(iph + 1);\n\n\treturn (len >= sizeof(struct ipv6hdr) + sizeof(struct nd_msg) &&\n\t\tiph->nexthdr == IPPROTO_ICMPV6 &&\n\t\tmsg->icmph.icmp6_code == 0 &&\n\t\tmsg->icmph.icmp6_type == NDISC_NEIGHBOUR_SOLICITATION);\n}\n\n\nstatic struct sk_buff *cdc_mbim_process_dgram(struct usbnet *dev, u8 *buf, size_t len, u16 tci)\n{\n\t__be16 proto = htons(ETH_P_802_3);\n\tstruct sk_buff *skb = NULL;\n\n\tif (tci < 256 || tci == MBIM_IPS0_VID) {  \n\t\tif (len < sizeof(struct iphdr))\n\t\t\tgoto err;\n\n\t\tswitch (*buf & 0xf0) {\n\t\tcase 0x40:\n\t\t\tproto = htons(ETH_P_IP);\n\t\t\tbreak;\n\t\tcase 0x60:\n\t\t\tif (is_neigh_solicit(buf, len))\n\t\t\t\tdo_neigh_solicit(dev, buf, tci);\n\t\t\tproto = htons(ETH_P_IPV6);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tskb = netdev_alloc_skb_ip_align(dev->net,  len + ETH_HLEN);\n\tif (!skb)\n\t\tgoto err;\n\n\t \n\tskb_put(skb, ETH_HLEN);\n\tskb_reset_mac_header(skb);\n\teth_hdr(skb)->h_proto = proto;\n\teth_zero_addr(eth_hdr(skb)->h_source);\n\tmemcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);\n\n\t \n\tskb_put_data(skb, buf, len);\n\n\t \n\tif (tci)\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), tci);\nerr:\n\treturn skb;\n}\n\nstatic int cdc_mbim_rx_fixup(struct usbnet *dev, struct sk_buff *skb_in)\n{\n\tstruct sk_buff *skb;\n\tstruct cdc_mbim_state *info = (void *)&dev->data;\n\tstruct cdc_ncm_ctx *ctx = info->ctx;\n\tint len;\n\tint nframes;\n\tint x;\n\tint offset;\n\tstruct usb_cdc_ncm_ndp16 *ndp16;\n\tstruct usb_cdc_ncm_dpe16 *dpe16;\n\tint ndpoffset;\n\tint loopcount = 50;  \n\tu32 payload = 0;\n\tu8 *c;\n\tu16 tci;\n\n\tndpoffset = cdc_ncm_rx_verify_nth16(ctx, skb_in);\n\tif (ndpoffset < 0)\n\t\tgoto error;\n\nnext_ndp:\n\tnframes = cdc_ncm_rx_verify_ndp16(skb_in, ndpoffset);\n\tif (nframes < 0)\n\t\tgoto error;\n\n\tndp16 = (struct usb_cdc_ncm_ndp16 *)(skb_in->data + ndpoffset);\n\n\tswitch (ndp16->dwSignature & cpu_to_le32(0x00ffffff)) {\n\tcase cpu_to_le32(USB_CDC_MBIM_NDP16_IPS_SIGN):\n\t\tc = (u8 *)&ndp16->dwSignature;\n\t\ttci = c[3];\n\t\t \n\t\tif (!tci && info->flags & FLAG_IPS0_VLAN)\n\t\t\ttci = MBIM_IPS0_VID;\n\t\tbreak;\n\tcase cpu_to_le32(USB_CDC_MBIM_NDP16_DSS_SIGN):\n\t\tc = (u8 *)&ndp16->dwSignature;\n\t\ttci = c[3] + 256;\n\t\tbreak;\n\tdefault:\n\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t  \"unsupported NDP signature <0x%08x>\\n\",\n\t\t\t  le32_to_cpu(ndp16->dwSignature));\n\t\tgoto err_ndp;\n\n\t}\n\n\tdpe16 = ndp16->dpe16;\n\tfor (x = 0; x < nframes; x++, dpe16++) {\n\t\toffset = le16_to_cpu(dpe16->wDatagramIndex);\n\t\tlen = le16_to_cpu(dpe16->wDatagramLength);\n\n\t\t \n\t\tif ((offset == 0) || (len == 0)) {\n\t\t\tif (!x)\n\t\t\t\tgoto err_ndp;  \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (((offset + len) > skb_in->len) || (len > ctx->rx_max)) {\n\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t  \"invalid frame detected (ignored) offset[%u]=%u, length=%u, skb=%p\\n\",\n\t\t\t\t  x, offset, len, skb_in);\n\t\t\tif (!x)\n\t\t\t\tgoto err_ndp;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tskb = cdc_mbim_process_dgram(dev, skb_in->data + offset, len, tci);\n\t\t\tif (!skb)\n\t\t\t\tgoto error;\n\t\t\tusbnet_skb_return(dev, skb);\n\t\t\tpayload += len;\t \n\t\t}\n\t}\nerr_ndp:\n\t \n\tndpoffset = le16_to_cpu(ndp16->wNextNdpIndex);\n\tif (ndpoffset && loopcount--)\n\t\tgoto next_ndp;\n\n\t \n\tctx->rx_overhead += skb_in->len - payload;\n\tctx->rx_ntbs++;\n\n\treturn 1;\nerror:\n\treturn 0;\n}\n\nstatic int cdc_mbim_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tint ret = -ENODEV;\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct cdc_mbim_state *info = (void *)&dev->data;\n\tstruct cdc_ncm_ctx *ctx = info->ctx;\n\n\tif (!ctx)\n\t\tgoto error;\n\n\t \n\tret = usbnet_suspend(intf, message);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (intf == ctx->control && info->subdriver && info->subdriver->suspend)\n\t\tret = info->subdriver->suspend(intf, message);\n\tif (ret < 0)\n\t\tusbnet_resume(intf);\n\nerror:\n\treturn ret;\n}\n\nstatic int cdc_mbim_resume(struct usb_interface *intf)\n{\n\tint  ret = 0;\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct cdc_mbim_state *info = (void *)&dev->data;\n\tstruct cdc_ncm_ctx *ctx = info->ctx;\n\tbool callsub = (intf == ctx->control && info->subdriver && info->subdriver->resume);\n\n\tif (callsub)\n\t\tret = info->subdriver->resume(intf);\n\tif (ret < 0)\n\t\tgoto err;\n\tret = usbnet_resume(intf);\n\tif (ret < 0 && callsub)\n\t\tinfo->subdriver->suspend(intf, PMSG_SUSPEND);\nerr:\n\treturn ret;\n}\n\nstatic const struct driver_info cdc_mbim_info = {\n\t.description = \"CDC MBIM\",\n\t.flags = FLAG_NO_SETINT | FLAG_MULTI_PACKET | FLAG_WWAN,\n\t.bind = cdc_mbim_bind,\n\t.unbind = cdc_mbim_unbind,\n\t.manage_power = cdc_mbim_manage_power,\n\t.rx_fixup = cdc_mbim_rx_fixup,\n\t.tx_fixup = cdc_mbim_tx_fixup,\n};\n\n \nstatic const struct driver_info cdc_mbim_info_zlp = {\n\t.description = \"CDC MBIM\",\n\t.flags = FLAG_NO_SETINT | FLAG_MULTI_PACKET | FLAG_WWAN | FLAG_SEND_ZLP,\n\t.bind = cdc_mbim_bind,\n\t.unbind = cdc_mbim_unbind,\n\t.manage_power = cdc_mbim_manage_power,\n\t.rx_fixup = cdc_mbim_rx_fixup,\n\t.tx_fixup = cdc_mbim_tx_fixup,\n};\n\n \nstatic const struct driver_info cdc_mbim_info_ndp_to_end = {\n\t.description = \"CDC MBIM\",\n\t.flags = FLAG_NO_SETINT | FLAG_MULTI_PACKET | FLAG_WWAN,\n\t.bind = cdc_mbim_bind,\n\t.unbind = cdc_mbim_unbind,\n\t.manage_power = cdc_mbim_manage_power,\n\t.rx_fixup = cdc_mbim_rx_fixup,\n\t.tx_fixup = cdc_mbim_tx_fixup,\n\t.data = CDC_NCM_FLAG_NDP_TO_END,\n};\n\n \nstatic const struct driver_info cdc_mbim_info_avoid_altsetting_toggle = {\n\t.description = \"CDC MBIM\",\n\t.flags = FLAG_NO_SETINT | FLAG_MULTI_PACKET | FLAG_WWAN | FLAG_SEND_ZLP,\n\t.bind = cdc_mbim_bind,\n\t.unbind = cdc_mbim_unbind,\n\t.manage_power = cdc_mbim_manage_power,\n\t.rx_fixup = cdc_mbim_rx_fixup,\n\t.tx_fixup = cdc_mbim_tx_fixup,\n\t.data = CDC_MBIM_FLAG_AVOID_ALTSETTING_TOGGLE,\n};\n\nstatic const struct usb_device_id mbim_devs[] = {\n\t \n\t{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_NCM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&cdc_mbim_info,\n\t},\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x0bdb, USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&cdc_mbim_info,\n\t},\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x12d1, USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&cdc_mbim_info_ndp_to_end,\n\t},\n\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x03f0, 0xa31d, USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&cdc_mbim_info_ndp_to_end,\n\t},\n\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1bc7, 0x1041, USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&cdc_mbim_info_avoid_altsetting_toggle,\n\t},\n\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1bc7, 0x1061, USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&cdc_mbim_info_avoid_altsetting_toggle,\n\t},\n\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1bc7, 0x1071, USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&cdc_mbim_info_avoid_altsetting_toggle,\n\t},\n\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1bc7, 0x1081, USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&cdc_mbim_info_avoid_altsetting_toggle,\n\t},\n\n\t \n\t{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&cdc_mbim_info_zlp,\n\t},\n\t{\n\t},\n};\nMODULE_DEVICE_TABLE(usb, mbim_devs);\n\nstatic struct usb_driver cdc_mbim_driver = {\n\t.name = \"cdc_mbim\",\n\t.id_table = mbim_devs,\n\t.probe = usbnet_probe,\n\t.disconnect = usbnet_disconnect,\n\t.suspend = cdc_mbim_suspend,\n\t.resume = cdc_mbim_resume,\n\t.reset_resume =\tcdc_mbim_resume,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\nmodule_usb_driver(cdc_mbim_driver);\n\nMODULE_AUTHOR(\"Greg Suarez <gsuarez@smithmicro.com>\");\nMODULE_AUTHOR(\"Bj\u00f8rn Mork <bjorn@mork.no>\");\nMODULE_DESCRIPTION(\"USB CDC MBIM host driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}