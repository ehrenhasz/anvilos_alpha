{
  "module_name": "asix_devices.c",
  "hash_id": "a2e1489772655ef18a1c6d26fadd76252210249c46263db60f3e0b1aadc0de12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/asix_devices.c",
  "human_readable_source": "\n \n\n#include \"asix.h\"\n\n#define PHY_MODE_MARVELL\t0x0000\n#define MII_MARVELL_LED_CTRL\t0x0018\n#define MII_MARVELL_STATUS\t0x001b\n#define MII_MARVELL_CTRL\t0x0014\n\n#define MARVELL_LED_MANUAL\t0x0019\n\n#define MARVELL_STATUS_HWCFG\t0x0004\n\n#define MARVELL_CTRL_TXDELAY\t0x0002\n#define MARVELL_CTRL_RXDELAY\t0x0080\n\n#define\tPHY_MODE_RTL8211CL\t0x000C\n\n#define AX88772A_PHY14H\t\t0x14\n#define AX88772A_PHY14H_DEFAULT 0x442C\n\n#define AX88772A_PHY15H\t\t0x15\n#define AX88772A_PHY15H_DEFAULT 0x03C8\n\n#define AX88772A_PHY16H\t\t0x16\n#define AX88772A_PHY16H_DEFAULT 0x4044\n\nstruct ax88172_int_data {\n\t__le16 res1;\n\tu8 link;\n\t__le16 res2;\n\tu8 status;\n\t__le16 res3;\n} __packed;\n\nstatic void asix_status(struct usbnet *dev, struct urb *urb)\n{\n\tstruct ax88172_int_data *event;\n\tint link;\n\n\tif (urb->actual_length < 8)\n\t\treturn;\n\n\tevent = urb->transfer_buffer;\n\tlink = event->link & 0x01;\n\tif (netif_carrier_ok(dev->net) != link) {\n\t\tusbnet_link_change(dev, link, 1);\n\t\tnetdev_dbg(dev->net, \"Link Status is: %d\\n\", link);\n\t}\n}\n\nstatic void asix_set_netdev_dev_addr(struct usbnet *dev, u8 *addr)\n{\n\tif (is_valid_ether_addr(addr)) {\n\t\teth_hw_addr_set(dev->net, addr);\n\t} else {\n\t\tnetdev_info(dev->net, \"invalid hw address, using random\\n\");\n\t\teth_hw_addr_random(dev->net);\n\t}\n}\n\n \nstatic u32 asix_get_phyid(struct usbnet *dev)\n{\n\tint phy_reg;\n\tu32 phy_id;\n\tint i;\n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\tphy_reg = asix_mdio_read(dev->net, dev->mii.phy_id, MII_PHYSID1);\n\t\tif (phy_reg < 0)\n\t\t\treturn 0;\n\t\tif (phy_reg != 0 && phy_reg != 0xFFFF)\n\t\t\tbreak;\n\t\tmdelay(1);\n\t}\n\n\tif (phy_reg <= 0 || phy_reg == 0xFFFF)\n\t\treturn 0;\n\n\tphy_id = (phy_reg & 0xffff) << 16;\n\n\tphy_reg = asix_mdio_read(dev->net, dev->mii.phy_id, MII_PHYSID2);\n\tif (phy_reg < 0)\n\t\treturn 0;\n\n\tphy_id |= (phy_reg & 0xffff);\n\n\treturn phy_id;\n}\n\nstatic u32 asix_get_link(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\treturn mii_link_ok(&dev->mii);\n}\n\nstatic int asix_ioctl (struct net_device *net, struct ifreq *rq, int cmd)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\treturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\n}\n\n \nstatic const struct ethtool_ops ax88172_ethtool_ops = {\n\t.get_drvinfo\t\t= asix_get_drvinfo,\n\t.get_link\t\t= asix_get_link,\n\t.get_msglevel\t\t= usbnet_get_msglevel,\n\t.set_msglevel\t\t= usbnet_set_msglevel,\n\t.get_wol\t\t= asix_get_wol,\n\t.set_wol\t\t= asix_set_wol,\n\t.get_eeprom_len\t\t= asix_get_eeprom_len,\n\t.get_eeprom\t\t= asix_get_eeprom,\n\t.set_eeprom\t\t= asix_set_eeprom,\n\t.nway_reset\t\t= usbnet_nway_reset,\n\t.get_link_ksettings\t= usbnet_get_link_ksettings_mii,\n\t.set_link_ksettings\t= usbnet_set_link_ksettings_mii,\n};\n\nstatic void ax88172_set_multicast(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct asix_data *data = (struct asix_data *)&dev->data;\n\tu8 rx_ctl = 0x8c;\n\n\tif (net->flags & IFF_PROMISC) {\n\t\trx_ctl |= 0x01;\n\t} else if (net->flags & IFF_ALLMULTI ||\n\t\t   netdev_mc_count(net) > AX_MAX_MCAST) {\n\t\trx_ctl |= 0x02;\n\t} else if (netdev_mc_empty(net)) {\n\t\t \n\t} else {\n\t\t \n\t\tstruct netdev_hw_addr *ha;\n\t\tu32 crc_bits;\n\n\t\tmemset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);\n\n\t\t \n\t\tnetdev_for_each_mc_addr(ha, net) {\n\t\t\tcrc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\t\t\tdata->multi_filter[crc_bits >> 3] |=\n\t\t\t    1 << (crc_bits & 7);\n\t\t}\n\n\t\tasix_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,\n\t\t\t\t   AX_MCAST_FILTER_SIZE, data->multi_filter);\n\n\t\trx_ctl |= 0x10;\n\t}\n\n\tasix_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);\n}\n\nstatic int ax88172_link_reset(struct usbnet *dev)\n{\n\tu8 mode;\n\tstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\n\n\tmii_check_media(&dev->mii, 1, 1);\n\tmii_ethtool_gset(&dev->mii, &ecmd);\n\tmode = AX88172_MEDIUM_DEFAULT;\n\n\tif (ecmd.duplex != DUPLEX_FULL)\n\t\tmode |= ~AX88172_MEDIUM_FD;\n\n\tnetdev_dbg(dev->net, \"ax88172_link_reset() speed: %u duplex: %d setting mode to 0x%04x\\n\",\n\t\t   ethtool_cmd_speed(&ecmd), ecmd.duplex, mode);\n\n\tasix_write_medium_mode(dev, mode, 0);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ax88172_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_change_mtu\t\t= usbnet_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= asix_ioctl,\n\t.ndo_set_rx_mode\t= ax88172_set_multicast,\n};\n\nstatic void asix_phy_reset(struct usbnet *dev, unsigned int reset_bits)\n{\n\tunsigned int timeout = 5000;\n\n\tasix_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, reset_bits);\n\n\t \n\tudelay(500);\n\n\t \n\twhile (timeout--) {\n\t\tif (asix_mdio_read(dev->net, dev->mii.phy_id, MII_BMCR)\n\t\t\t\t\t\t\t& BMCR_RESET)\n\t\t\tudelay(100);\n\t\telse\n\t\t\treturn;\n\t}\n\n\tnetdev_err(dev->net, \"BMCR_RESET timeout on phy_id %d\\n\",\n\t\t   dev->mii.phy_id);\n}\n\nstatic int ax88172_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret = 0;\n\tu8 buf[ETH_ALEN] = {0};\n\tint i;\n\tunsigned long gpio_bits = dev->driver_info->data;\n\n\tusbnet_get_endpoints(dev,intf);\n\n\t \n\tfor (i = 2; i >= 0; i--) {\n\t\tret = asix_write_cmd(dev, AX_CMD_WRITE_GPIOS,\n\t\t\t\t(gpio_bits >> (i * 8)) & 0xff, 0, 0, NULL, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tmsleep(5);\n\t}\n\n\tret = asix_write_rx_ctl(dev, 0x80, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = asix_read_cmd(dev, AX88172_CMD_READ_NODE_ID,\n\t\t\t    0, 0, ETH_ALEN, buf, 0);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"read AX_CMD_READ_NODE_ID failed: %d\\n\",\n\t\t\t   ret);\n\t\tgoto out;\n\t}\n\n\tasix_set_netdev_dev_addr(dev, buf);\n\n\t \n\tdev->mii.dev = dev->net;\n\tdev->mii.mdio_read = asix_mdio_read;\n\tdev->mii.mdio_write = asix_mdio_write;\n\tdev->mii.phy_id_mask = 0x3f;\n\tdev->mii.reg_num_mask = 0x1f;\n\n\tdev->mii.phy_id = asix_read_phy_addr(dev, true);\n\tif (dev->mii.phy_id < 0)\n\t\treturn dev->mii.phy_id;\n\n\tdev->net->netdev_ops = &ax88172_netdev_ops;\n\tdev->net->ethtool_ops = &ax88172_ethtool_ops;\n\tdev->net->needed_headroom = 4;  \n\tdev->net->needed_tailroom = 4;  \n\n\tasix_phy_reset(dev, BMCR_RESET);\n\tasix_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,\n\t\tADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);\n\tmii_nway_restart(&dev->mii);\n\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic void ax88772_ethtool_get_strings(struct net_device *netdev, u32 sset,\n\t\t\t\t\tu8 *data)\n{\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\tnet_selftest_get_strings(data);\n\t\tbreak;\n\t}\n}\n\nstatic int ax88772_ethtool_get_sset_count(struct net_device *ndev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn net_selftest_get_count();\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void ax88772_ethtool_get_pauseparam(struct net_device *ndev,\n\t\t\t\t\t  struct ethtool_pauseparam *pause)\n{\n\tstruct usbnet *dev = netdev_priv(ndev);\n\tstruct asix_common_private *priv = dev->driver_priv;\n\n\tphylink_ethtool_get_pauseparam(priv->phylink, pause);\n}\n\nstatic int ax88772_ethtool_set_pauseparam(struct net_device *ndev,\n\t\t\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct usbnet *dev = netdev_priv(ndev);\n\tstruct asix_common_private *priv = dev->driver_priv;\n\n\treturn phylink_ethtool_set_pauseparam(priv->phylink, pause);\n}\n\nstatic const struct ethtool_ops ax88772_ethtool_ops = {\n\t.get_drvinfo\t\t= asix_get_drvinfo,\n\t.get_link\t\t= usbnet_get_link,\n\t.get_msglevel\t\t= usbnet_get_msglevel,\n\t.set_msglevel\t\t= usbnet_set_msglevel,\n\t.get_wol\t\t= asix_get_wol,\n\t.set_wol\t\t= asix_set_wol,\n\t.get_eeprom_len\t\t= asix_get_eeprom_len,\n\t.get_eeprom\t\t= asix_get_eeprom,\n\t.set_eeprom\t\t= asix_set_eeprom,\n\t.nway_reset\t\t= phy_ethtool_nway_reset,\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n\t.self_test\t\t= net_selftest,\n\t.get_strings\t\t= ax88772_ethtool_get_strings,\n\t.get_sset_count\t\t= ax88772_ethtool_get_sset_count,\n\t.get_pauseparam\t\t= ax88772_ethtool_get_pauseparam,\n\t.set_pauseparam\t\t= ax88772_ethtool_set_pauseparam,\n};\n\nstatic int ax88772_reset(struct usbnet *dev)\n{\n\tstruct asix_data *data = (struct asix_data *)&dev->data;\n\tstruct asix_common_private *priv = dev->driver_priv;\n\tint ret;\n\n\t \n\tether_addr_copy(data->mac_addr, dev->net->dev_addr);\n\tret = asix_write_cmd(dev, AX_CMD_WRITE_NODE_ID, 0, 0,\n\t\t\t     ETH_ALEN, data->mac_addr, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = asix_write_medium_mode(dev, AX88772_MEDIUM_DEFAULT, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tphylink_start(priv->phylink);\n\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic int ax88772_hw_reset(struct usbnet *dev, int in_pm)\n{\n\tstruct asix_data *data = (struct asix_data *)&dev->data;\n\tstruct asix_common_private *priv = dev->driver_priv;\n\tu16 rx_ctl;\n\tint ret;\n\n\tret = asix_write_gpio(dev, AX_GPIO_RSE | AX_GPIO_GPO_2 |\n\t\t\t      AX_GPIO_GPO2EN, 5, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = asix_write_cmd(dev, AX_CMD_SW_PHY_SELECT, priv->embd_phy,\n\t\t\t     0, 0, NULL, in_pm);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"Select PHY #1 failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (priv->embd_phy) {\n\t\tret = asix_sw_reset(dev, AX_SWRESET_IPPD, in_pm);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tusleep_range(10000, 11000);\n\n\t\tret = asix_sw_reset(dev, AX_SWRESET_CLEAR, in_pm);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tmsleep(60);\n\n\t\tret = asix_sw_reset(dev, AX_SWRESET_IPRL | AX_SWRESET_PRL,\n\t\t\t\t    in_pm);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = asix_sw_reset(dev, AX_SWRESET_IPPD | AX_SWRESET_PRL,\n\t\t\t\t    in_pm);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tmsleep(150);\n\n\tif (in_pm && (!asix_mdio_read_nopm(dev->net, dev->mii.phy_id,\n\t\t\t\t\t   MII_PHYSID1))){\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = asix_write_medium_mode(dev, AX88772_MEDIUM_DEFAULT, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = asix_write_cmd(dev, AX_CMD_WRITE_IPG0,\n\t\t\t     AX88772_IPG0_DEFAULT | AX88772_IPG1_DEFAULT,\n\t\t\t     AX88772_IPG2_DEFAULT, 0, NULL, in_pm);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"Write IPG,IPG1,IPG2 failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tether_addr_copy(data->mac_addr, dev->net->dev_addr);\n\tret = asix_write_cmd(dev, AX_CMD_WRITE_NODE_ID, 0, 0,\n\t\t\t     ETH_ALEN, data->mac_addr, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trx_ctl = asix_read_rx_ctl(dev, in_pm);\n\tnetdev_dbg(dev->net, \"RX_CTL is 0x%04x after all initializations\\n\",\n\t\t   rx_ctl);\n\n\trx_ctl = asix_read_medium_status(dev, in_pm);\n\tnetdev_dbg(dev->net,\n\t\t   \"Medium Status is 0x%04x after all initializations\\n\",\n\t\t   rx_ctl);\n\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic int ax88772a_hw_reset(struct usbnet *dev, int in_pm)\n{\n\tstruct asix_data *data = (struct asix_data *)&dev->data;\n\tstruct asix_common_private *priv = dev->driver_priv;\n\tu16 rx_ctl, phy14h, phy15h, phy16h;\n\tint ret;\n\n\tret = asix_write_gpio(dev, AX_GPIO_RSE, 5, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = asix_write_cmd(dev, AX_CMD_SW_PHY_SELECT, priv->embd_phy |\n\t\t\t     AX_PHYSEL_SSEN, 0, 0, NULL, in_pm);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"Select PHY #1 failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tusleep_range(10000, 11000);\n\n\tret = asix_sw_reset(dev, AX_SWRESET_IPPD | AX_SWRESET_IPRL, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tusleep_range(10000, 11000);\n\n\tret = asix_sw_reset(dev, AX_SWRESET_IPRL, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmsleep(160);\n\n\tret = asix_sw_reset(dev, AX_SWRESET_CLEAR, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = asix_sw_reset(dev, AX_SWRESET_IPRL, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmsleep(200);\n\n\tif (in_pm && (!asix_mdio_read_nopm(dev->net, dev->mii.phy_id,\n\t\t\t\t\t   MII_PHYSID1))) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tif (priv->chipcode == AX_AX88772B_CHIPCODE) {\n\t\tret = asix_write_cmd(dev, AX_QCTCTRL, 0x8000, 0x8001,\n\t\t\t\t     0, NULL, in_pm);\n\t\tif (ret < 0) {\n\t\t\tnetdev_dbg(dev->net, \"Write BQ setting failed: %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto out;\n\t\t}\n\t} else if (priv->chipcode == AX_AX88772A_CHIPCODE) {\n\t\t \n\t\tphy14h = asix_mdio_read_nopm(dev->net, dev->mii.phy_id,\n\t\t\t\t\t     AX88772A_PHY14H);\n\t\tphy15h = asix_mdio_read_nopm(dev->net, dev->mii.phy_id,\n\t\t\t\t\t     AX88772A_PHY15H);\n\t\tphy16h = asix_mdio_read_nopm(dev->net, dev->mii.phy_id,\n\t\t\t\t\t     AX88772A_PHY16H);\n\n\t\tnetdev_dbg(dev->net,\n\t\t\t   \"772a_hw_reset: MR20=0x%x MR21=0x%x MR22=0x%x\\n\",\n\t\t\t   phy14h, phy15h, phy16h);\n\n\t\t \n\t\tif (phy14h != AX88772A_PHY14H_DEFAULT)\n\t\t\tasix_mdio_write_nopm(dev->net, dev->mii.phy_id,\n\t\t\t\t\t     AX88772A_PHY14H,\n\t\t\t\t\t     AX88772A_PHY14H_DEFAULT);\n\t\tif (phy15h != AX88772A_PHY15H_DEFAULT)\n\t\t\tasix_mdio_write_nopm(dev->net, dev->mii.phy_id,\n\t\t\t\t\t     AX88772A_PHY15H,\n\t\t\t\t\t     AX88772A_PHY15H_DEFAULT);\n\t\tif (phy16h != AX88772A_PHY16H_DEFAULT)\n\t\t\tasix_mdio_write_nopm(dev->net, dev->mii.phy_id,\n\t\t\t\t\t     AX88772A_PHY16H,\n\t\t\t\t\t     AX88772A_PHY16H_DEFAULT);\n\t}\n\n\tret = asix_write_cmd(dev, AX_CMD_WRITE_IPG0,\n\t\t\t\tAX88772_IPG0_DEFAULT | AX88772_IPG1_DEFAULT,\n\t\t\t\tAX88772_IPG2_DEFAULT, 0, NULL, in_pm);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"Write IPG,IPG1,IPG2 failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(data->mac_addr, dev->net->dev_addr, ETH_ALEN);\n\tret = asix_write_cmd(dev, AX_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,\n\t\t\t\t\t\t\tdata->mac_addr, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = asix_write_medium_mode(dev, AX88772_MEDIUM_DEFAULT, in_pm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trx_ctl = asix_read_rx_ctl(dev, in_pm);\n\tnetdev_dbg(dev->net, \"RX_CTL is 0x%04x after all initializations\\n\",\n\t\t   rx_ctl);\n\n\trx_ctl = asix_read_medium_status(dev, in_pm);\n\tnetdev_dbg(dev->net,\n\t\t   \"Medium Status is 0x%04x after all initializations\\n\",\n\t\t   rx_ctl);\n\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic const struct net_device_ops ax88772_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_change_mtu\t\t= usbnet_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_set_mac_address \t= asix_set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_set_rx_mode        = asix_set_multicast,\n};\n\nstatic void ax88772_suspend(struct usbnet *dev)\n{\n\tstruct asix_common_private *priv = dev->driver_priv;\n\tu16 medium;\n\n\tif (netif_running(dev->net)) {\n\t\trtnl_lock();\n\t\tphylink_suspend(priv->phylink, false);\n\t\trtnl_unlock();\n\t}\n\n\t \n\tmedium = asix_read_medium_status(dev, 1);\n\tmedium &= ~AX_MEDIUM_RE;\n\tasix_write_medium_mode(dev, medium, 1);\n\n\tnetdev_dbg(dev->net, \"ax88772_suspend: medium=0x%04x\\n\",\n\t\t   asix_read_medium_status(dev, 1));\n}\n\nstatic int asix_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct asix_common_private *priv = dev->driver_priv;\n\n\tif (priv && priv->suspend)\n\t\tpriv->suspend(dev);\n\n\treturn usbnet_suspend(intf, message);\n}\n\nstatic void ax88772_resume(struct usbnet *dev)\n{\n\tstruct asix_common_private *priv = dev->driver_priv;\n\tint i;\n\n\tfor (i = 0; i < 3; i++)\n\t\tif (!priv->reset(dev, 1))\n\t\t\tbreak;\n\n\tif (netif_running(dev->net)) {\n\t\trtnl_lock();\n\t\tphylink_resume(priv->phylink);\n\t\trtnl_unlock();\n\t}\n}\n\nstatic int asix_resume(struct usb_interface *intf)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct asix_common_private *priv = dev->driver_priv;\n\n\tif (priv && priv->resume)\n\t\tpriv->resume(dev);\n\n\treturn usbnet_resume(intf);\n}\n\nstatic int ax88772_init_mdio(struct usbnet *dev)\n{\n\tstruct asix_common_private *priv = dev->driver_priv;\n\tint ret;\n\n\tpriv->mdio = mdiobus_alloc();\n\tif (!priv->mdio)\n\t\treturn -ENOMEM;\n\n\tpriv->mdio->priv = dev;\n\tpriv->mdio->read = &asix_mdio_bus_read;\n\tpriv->mdio->write = &asix_mdio_bus_write;\n\tpriv->mdio->name = \"Asix MDIO Bus\";\n\t \n\tsnprintf(priv->mdio->id, MII_BUS_ID_SIZE, \"usb-%03d:%03d\",\n\t\t dev->udev->bus->busnum, dev->udev->devnum);\n\n\tret = mdiobus_register(priv->mdio);\n\tif (ret) {\n\t\tnetdev_err(dev->net, \"Could not register MDIO bus (err %d)\\n\", ret);\n\t\tmdiobus_free(priv->mdio);\n\t\tpriv->mdio = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void ax88772_mdio_unregister(struct asix_common_private *priv)\n{\n\tmdiobus_unregister(priv->mdio);\n\tmdiobus_free(priv->mdio);\n}\n\nstatic int ax88772_init_phy(struct usbnet *dev)\n{\n\tstruct asix_common_private *priv = dev->driver_priv;\n\tint ret;\n\n\tpriv->phydev = mdiobus_get_phy(priv->mdio, priv->phy_addr);\n\tif (!priv->phydev) {\n\t\tnetdev_err(dev->net, \"Could not find PHY\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = phylink_connect_phy(priv->phylink, priv->phydev);\n\tif (ret) {\n\t\tnetdev_err(dev->net, \"Could not connect PHY\\n\");\n\t\treturn ret;\n\t}\n\n\tphy_suspend(priv->phydev);\n\tpriv->phydev->mac_managed_pm = true;\n\n\tphy_attached_info(priv->phydev);\n\n\tif (priv->embd_phy)\n\t\treturn 0;\n\n\t \n\tpriv->phydev_int = mdiobus_get_phy(priv->mdio, AX_EMBD_PHY_ADDR);\n\tif (!priv->phydev_int) {\n\t\trtnl_lock();\n\t\tphylink_disconnect_phy(priv->phylink);\n\t\trtnl_unlock();\n\t\tnetdev_err(dev->net, \"Could not find internal PHY\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->phydev_int->mac_managed_pm = true;\n\tphy_suspend(priv->phydev_int);\n\n\treturn 0;\n}\n\nstatic void ax88772_mac_config(struct phylink_config *config, unsigned int mode,\n\t\t\t      const struct phylink_link_state *state)\n{\n\t \n}\n\nstatic void ax88772_mac_link_down(struct phylink_config *config,\n\t\t\t\t unsigned int mode, phy_interface_t interface)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(config->dev));\n\n\tasix_write_medium_mode(dev, 0, 0);\n\tusbnet_link_change(dev, false, false);\n}\n\nstatic void ax88772_mac_link_up(struct phylink_config *config,\n\t\t\t       struct phy_device *phy,\n\t\t\t       unsigned int mode, phy_interface_t interface,\n\t\t\t       int speed, int duplex,\n\t\t\t       bool tx_pause, bool rx_pause)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(config->dev));\n\tu16 m = AX_MEDIUM_AC | AX_MEDIUM_RE;\n\n\tm |= duplex ? AX_MEDIUM_FD : 0;\n\n\tswitch (speed) {\n\tcase SPEED_100:\n\t\tm |= AX_MEDIUM_PS;\n\t\tbreak;\n\tcase SPEED_10:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (tx_pause)\n\t\tm |= AX_MEDIUM_TFC;\n\n\tif (rx_pause)\n\t\tm |= AX_MEDIUM_RFC;\n\n\tasix_write_medium_mode(dev, m, 0);\n\tusbnet_link_change(dev, true, false);\n}\n\nstatic const struct phylink_mac_ops ax88772_phylink_mac_ops = {\n\t.mac_config = ax88772_mac_config,\n\t.mac_link_down = ax88772_mac_link_down,\n\t.mac_link_up = ax88772_mac_link_up,\n};\n\nstatic int ax88772_phylink_setup(struct usbnet *dev)\n{\n\tstruct asix_common_private *priv = dev->driver_priv;\n\tphy_interface_t phy_if_mode;\n\tstruct phylink *phylink;\n\n\tpriv->phylink_config.dev = &dev->net->dev;\n\tpriv->phylink_config.type = PHYLINK_NETDEV;\n\tpriv->phylink_config.mac_capabilities = MAC_SYM_PAUSE | MAC_ASYM_PAUSE |\n\t\tMAC_10 | MAC_100;\n\n\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t  priv->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_RMII,\n\t\t  priv->phylink_config.supported_interfaces);\n\n\tif (priv->embd_phy)\n\t\tphy_if_mode = PHY_INTERFACE_MODE_INTERNAL;\n\telse\n\t\tphy_if_mode = PHY_INTERFACE_MODE_RMII;\n\n\tphylink = phylink_create(&priv->phylink_config, dev->net->dev.fwnode,\n\t\t\t\t phy_if_mode, &ax88772_phylink_mac_ops);\n\tif (IS_ERR(phylink))\n\t\treturn PTR_ERR(phylink);\n\n\tpriv->phylink = phylink;\n\treturn 0;\n}\n\nstatic int ax88772_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct asix_common_private *priv;\n\tu8 buf[ETH_ALEN] = {0};\n\tint ret, i;\n\n\tpriv = devm_kzalloc(&dev->udev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev->driver_priv = priv;\n\n\tusbnet_get_endpoints(dev, intf);\n\n\t \n\tif (!eth_platform_get_mac_address(&dev->udev->dev, buf)) {\n\t\tnetif_dbg(dev, ifup, dev->net,\n\t\t\t  \"MAC address read from device tree\");\n\t} else {\n\t\t \n\t\tif (dev->driver_info->data & FLAG_EEPROM_MAC) {\n\t\t\tfor (i = 0; i < (ETH_ALEN >> 1); i++) {\n\t\t\t\tret = asix_read_cmd(dev, AX_CMD_READ_EEPROM,\n\t\t\t\t\t\t    0x04 + i, 0, 2, buf + i * 2,\n\t\t\t\t\t\t    0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID,\n\t\t\t\t\t    0, 0, ETH_ALEN, buf, 0);\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tnetdev_dbg(dev->net, \"Failed to read MAC address: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tasix_set_netdev_dev_addr(dev, buf);\n\n\tdev->net->netdev_ops = &ax88772_netdev_ops;\n\tdev->net->ethtool_ops = &ax88772_ethtool_ops;\n\tdev->net->needed_headroom = 4;  \n\tdev->net->needed_tailroom = 4;  \n\n\tret = asix_read_phy_addr(dev, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->phy_addr = ret;\n\tpriv->embd_phy = ((priv->phy_addr & 0x1f) == AX_EMBD_PHY_ADDR);\n\n\tret = asix_read_cmd(dev, AX_CMD_STATMNGSTS_REG, 0, 0, 1,\n\t\t\t    &priv->chipcode, 0);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"Failed to read STATMNGSTS_REG: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->chipcode &= AX_CHIPCODE_MASK;\n\n\tpriv->resume = ax88772_resume;\n\tpriv->suspend = ax88772_suspend;\n\tif (priv->chipcode == AX_AX88772_CHIPCODE)\n\t\tpriv->reset = ax88772_hw_reset;\n\telse\n\t\tpriv->reset = ax88772a_hw_reset;\n\n\tret = priv->reset(dev, 0);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"Failed to reset AX88772: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (dev->driver_info->flags & FLAG_FRAMING_AX) {\n\t\t \n\t\tdev->rx_urb_size = 2048;\n\t}\n\n\tpriv->presvd_phy_bmcr = 0;\n\tpriv->presvd_phy_advertise = 0;\n\n\tret = ax88772_init_mdio(dev);\n\tif (ret)\n\t\tgoto mdio_err;\n\n\tret = ax88772_phylink_setup(dev);\n\tif (ret)\n\t\tgoto phylink_err;\n\n\tret = ax88772_init_phy(dev);\n\tif (ret)\n\t\tgoto initphy_err;\n\n\treturn 0;\n\ninitphy_err:\n\tphylink_destroy(priv->phylink);\nphylink_err:\n\tax88772_mdio_unregister(priv);\nmdio_err:\n\treturn ret;\n}\n\nstatic int ax88772_stop(struct usbnet *dev)\n{\n\tstruct asix_common_private *priv = dev->driver_priv;\n\n\tphylink_stop(priv->phylink);\n\n\treturn 0;\n}\n\nstatic void ax88772_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct asix_common_private *priv = dev->driver_priv;\n\n\trtnl_lock();\n\tphylink_disconnect_phy(priv->phylink);\n\trtnl_unlock();\n\tphylink_destroy(priv->phylink);\n\tax88772_mdio_unregister(priv);\n\tasix_rx_fixup_common_free(dev->driver_priv);\n}\n\nstatic void ax88178_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tasix_rx_fixup_common_free(dev->driver_priv);\n\tkfree(dev->driver_priv);\n}\n\nstatic const struct ethtool_ops ax88178_ethtool_ops = {\n\t.get_drvinfo\t\t= asix_get_drvinfo,\n\t.get_link\t\t= asix_get_link,\n\t.get_msglevel\t\t= usbnet_get_msglevel,\n\t.set_msglevel\t\t= usbnet_set_msglevel,\n\t.get_wol\t\t= asix_get_wol,\n\t.set_wol\t\t= asix_set_wol,\n\t.get_eeprom_len\t\t= asix_get_eeprom_len,\n\t.get_eeprom\t\t= asix_get_eeprom,\n\t.set_eeprom\t\t= asix_set_eeprom,\n\t.nway_reset\t\t= usbnet_nway_reset,\n\t.get_link_ksettings\t= usbnet_get_link_ksettings_mii,\n\t.set_link_ksettings\t= usbnet_set_link_ksettings_mii,\n};\n\nstatic int marvell_phy_init(struct usbnet *dev)\n{\n\tstruct asix_data *data = (struct asix_data *)&dev->data;\n\tu16 reg;\n\n\tnetdev_dbg(dev->net, \"marvell_phy_init()\\n\");\n\n\treg = asix_mdio_read(dev->net, dev->mii.phy_id, MII_MARVELL_STATUS);\n\tnetdev_dbg(dev->net, \"MII_MARVELL_STATUS = 0x%04x\\n\", reg);\n\n\tasix_mdio_write(dev->net, dev->mii.phy_id, MII_MARVELL_CTRL,\n\t\t\tMARVELL_CTRL_RXDELAY | MARVELL_CTRL_TXDELAY);\n\n\tif (data->ledmode) {\n\t\treg = asix_mdio_read(dev->net, dev->mii.phy_id,\n\t\t\tMII_MARVELL_LED_CTRL);\n\t\tnetdev_dbg(dev->net, \"MII_MARVELL_LED_CTRL (1) = 0x%04x\\n\", reg);\n\n\t\treg &= 0xf8ff;\n\t\treg |= (1 + 0x0100);\n\t\tasix_mdio_write(dev->net, dev->mii.phy_id,\n\t\t\tMII_MARVELL_LED_CTRL, reg);\n\n\t\treg = asix_mdio_read(dev->net, dev->mii.phy_id,\n\t\t\tMII_MARVELL_LED_CTRL);\n\t\tnetdev_dbg(dev->net, \"MII_MARVELL_LED_CTRL (2) = 0x%04x\\n\", reg);\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl8211cl_phy_init(struct usbnet *dev)\n{\n\tstruct asix_data *data = (struct asix_data *)&dev->data;\n\n\tnetdev_dbg(dev->net, \"rtl8211cl_phy_init()\\n\");\n\n\tasix_mdio_write (dev->net, dev->mii.phy_id, 0x1f, 0x0005);\n\tasix_mdio_write (dev->net, dev->mii.phy_id, 0x0c, 0);\n\tasix_mdio_write (dev->net, dev->mii.phy_id, 0x01,\n\t\tasix_mdio_read (dev->net, dev->mii.phy_id, 0x01) | 0x0080);\n\tasix_mdio_write (dev->net, dev->mii.phy_id, 0x1f, 0);\n\n\tif (data->ledmode == 12) {\n\t\tasix_mdio_write (dev->net, dev->mii.phy_id, 0x1f, 0x0002);\n\t\tasix_mdio_write (dev->net, dev->mii.phy_id, 0x1a, 0x00cb);\n\t\tasix_mdio_write (dev->net, dev->mii.phy_id, 0x1f, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int marvell_led_status(struct usbnet *dev, u16 speed)\n{\n\tu16 reg = asix_mdio_read(dev->net, dev->mii.phy_id, MARVELL_LED_MANUAL);\n\n\tnetdev_dbg(dev->net, \"marvell_led_status() read 0x%04x\\n\", reg);\n\n\t \n\treg &= 0xfc0f;\n\n\tswitch (speed) {\n\t\tcase SPEED_1000:\n\t\t\treg |= 0x03e0;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\treg |= 0x03b0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg |= 0x02f0;\n\t}\n\n\tnetdev_dbg(dev->net, \"marvell_led_status() writing 0x%04x\\n\", reg);\n\tasix_mdio_write(dev->net, dev->mii.phy_id, MARVELL_LED_MANUAL, reg);\n\n\treturn 0;\n}\n\nstatic int ax88178_reset(struct usbnet *dev)\n{\n\tstruct asix_data *data = (struct asix_data *)&dev->data;\n\tint ret;\n\t__le16 eeprom;\n\tu8 status;\n\tint gpio0 = 0;\n\tu32 phyid;\n\n\tret = asix_read_cmd(dev, AX_CMD_READ_GPIOS, 0, 0, 1, &status, 0);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"Failed to read GPIOS: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetdev_dbg(dev->net, \"GPIO Status: 0x%04x\\n\", status);\n\n\tasix_write_cmd(dev, AX_CMD_WRITE_ENABLE, 0, 0, 0, NULL, 0);\n\tret = asix_read_cmd(dev, AX_CMD_READ_EEPROM, 0x0017, 0, 2, &eeprom, 0);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"Failed to read EEPROM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tasix_write_cmd(dev, AX_CMD_WRITE_DISABLE, 0, 0, 0, NULL, 0);\n\n\tnetdev_dbg(dev->net, \"EEPROM index 0x17 is 0x%04x\\n\", eeprom);\n\n\tif (eeprom == cpu_to_le16(0xffff)) {\n\t\tdata->phymode = PHY_MODE_MARVELL;\n\t\tdata->ledmode = 0;\n\t\tgpio0 = 1;\n\t} else {\n\t\tdata->phymode = le16_to_cpu(eeprom) & 0x7F;\n\t\tdata->ledmode = le16_to_cpu(eeprom) >> 8;\n\t\tgpio0 = (le16_to_cpu(eeprom) & 0x80) ? 0 : 1;\n\t}\n\tnetdev_dbg(dev->net, \"GPIO0: %d, PhyMode: %d\\n\", gpio0, data->phymode);\n\n\t \n\tasix_write_gpio(dev, AX_GPIO_RSE | AX_GPIO_GPO_1 |\n\t\t\tAX_GPIO_GPO1EN, 40, 0);\n\tif ((le16_to_cpu(eeprom) >> 8) != 1) {\n\t\tasix_write_gpio(dev, 0x003c, 30, 0);\n\t\tasix_write_gpio(dev, 0x001c, 300, 0);\n\t\tasix_write_gpio(dev, 0x003c, 30, 0);\n\t} else {\n\t\tnetdev_dbg(dev->net, \"gpio phymode == 1 path\\n\");\n\t\tasix_write_gpio(dev, AX_GPIO_GPO1EN, 30, 0);\n\t\tasix_write_gpio(dev, AX_GPIO_GPO1EN | AX_GPIO_GPO_1, 30, 0);\n\t}\n\n\t \n\tphyid = asix_get_phyid(dev);\n\tnetdev_dbg(dev->net, \"PHYID=0x%08x\\n\", phyid);\n\n\t \n\tasix_write_cmd(dev, AX_CMD_SW_PHY_SELECT, 0, 0, 0, NULL, 0);\n\n\tasix_sw_reset(dev, 0, 0);\n\tmsleep(150);\n\n\tasix_sw_reset(dev, AX_SWRESET_PRL | AX_SWRESET_IPPD, 0);\n\tmsleep(150);\n\n\tasix_write_rx_ctl(dev, 0, 0);\n\n\tif (data->phymode == PHY_MODE_MARVELL) {\n\t\tmarvell_phy_init(dev);\n\t\tmsleep(60);\n\t} else if (data->phymode == PHY_MODE_RTL8211CL)\n\t\trtl8211cl_phy_init(dev);\n\n\tasix_phy_reset(dev, BMCR_RESET | BMCR_ANENABLE);\n\tasix_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,\n\t\t\tADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);\n\tasix_mdio_write(dev->net, dev->mii.phy_id, MII_CTRL1000,\n\t\t\tADVERTISE_1000FULL);\n\n\tasix_write_medium_mode(dev, AX88178_MEDIUM_DEFAULT, 0);\n\tmii_nway_restart(&dev->mii);\n\n\t \n\tmemcpy(data->mac_addr, dev->net->dev_addr, ETH_ALEN);\n\tret = asix_write_cmd(dev, AX_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,\n\t\t\t\t\t\t\tdata->mac_addr, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ax88178_link_reset(struct usbnet *dev)\n{\n\tu16 mode;\n\tstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\n\tstruct asix_data *data = (struct asix_data *)&dev->data;\n\tu32 speed;\n\n\tnetdev_dbg(dev->net, \"ax88178_link_reset()\\n\");\n\n\tmii_check_media(&dev->mii, 1, 1);\n\tmii_ethtool_gset(&dev->mii, &ecmd);\n\tmode = AX88178_MEDIUM_DEFAULT;\n\tspeed = ethtool_cmd_speed(&ecmd);\n\n\tif (speed == SPEED_1000)\n\t\tmode |= AX_MEDIUM_GM;\n\telse if (speed == SPEED_100)\n\t\tmode |= AX_MEDIUM_PS;\n\telse\n\t\tmode &= ~(AX_MEDIUM_PS | AX_MEDIUM_GM);\n\n\tmode |= AX_MEDIUM_ENCK;\n\n\tif (ecmd.duplex == DUPLEX_FULL)\n\t\tmode |= AX_MEDIUM_FD;\n\telse\n\t\tmode &= ~AX_MEDIUM_FD;\n\n\tnetdev_dbg(dev->net, \"ax88178_link_reset() speed: %u duplex: %d setting mode to 0x%04x\\n\",\n\t\t   speed, ecmd.duplex, mode);\n\n\tasix_write_medium_mode(dev, mode, 0);\n\n\tif (data->phymode == PHY_MODE_MARVELL && data->ledmode)\n\t\tmarvell_led_status(dev, speed);\n\n\treturn 0;\n}\n\nstatic void ax88178_set_mfb(struct usbnet *dev)\n{\n\tu16 mfb = AX_RX_CTL_MFB_16384;\n\tu16 rxctl;\n\tu16 medium;\n\tint old_rx_urb_size = dev->rx_urb_size;\n\n\tif (dev->hard_mtu < 2048) {\n\t\tdev->rx_urb_size = 2048;\n\t\tmfb = AX_RX_CTL_MFB_2048;\n\t} else if (dev->hard_mtu < 4096) {\n\t\tdev->rx_urb_size = 4096;\n\t\tmfb = AX_RX_CTL_MFB_4096;\n\t} else if (dev->hard_mtu < 8192) {\n\t\tdev->rx_urb_size = 8192;\n\t\tmfb = AX_RX_CTL_MFB_8192;\n\t} else if (dev->hard_mtu < 16384) {\n\t\tdev->rx_urb_size = 16384;\n\t\tmfb = AX_RX_CTL_MFB_16384;\n\t}\n\n\trxctl = asix_read_rx_ctl(dev, 0);\n\tasix_write_rx_ctl(dev, (rxctl & ~AX_RX_CTL_MFB_16384) | mfb, 0);\n\n\tmedium = asix_read_medium_status(dev, 0);\n\tif (dev->net->mtu > 1500)\n\t\tmedium |= AX_MEDIUM_JFE;\n\telse\n\t\tmedium &= ~AX_MEDIUM_JFE;\n\tasix_write_medium_mode(dev, medium, 0);\n\n\tif (dev->rx_urb_size > old_rx_urb_size)\n\t\tusbnet_unlink_rx_urbs(dev);\n}\n\nstatic int ax88178_change_mtu(struct net_device *net, int new_mtu)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tint ll_mtu = new_mtu + net->hard_header_len + 4;\n\n\tnetdev_dbg(dev->net, \"ax88178_change_mtu() new_mtu=%d\\n\", new_mtu);\n\n\tif ((ll_mtu % dev->maxpacket) == 0)\n\t\treturn -EDOM;\n\n\tnet->mtu = new_mtu;\n\tdev->hard_mtu = net->mtu + net->hard_header_len;\n\tax88178_set_mfb(dev);\n\n\t \n\tusbnet_update_max_qlen(dev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ax88178_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_set_mac_address \t= asix_set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_rx_mode\t= asix_set_multicast,\n\t.ndo_eth_ioctl\t\t= asix_ioctl,\n\t.ndo_change_mtu \t= ax88178_change_mtu,\n};\n\nstatic int ax88178_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tu8 buf[ETH_ALEN] = {0};\n\n\tusbnet_get_endpoints(dev,intf);\n\n\t \n\tret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID, 0, 0, ETH_ALEN, buf, 0);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"Failed to read MAC address: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tasix_set_netdev_dev_addr(dev, buf);\n\n\t \n\tdev->mii.dev = dev->net;\n\tdev->mii.mdio_read = asix_mdio_read;\n\tdev->mii.mdio_write = asix_mdio_write;\n\tdev->mii.phy_id_mask = 0x1f;\n\tdev->mii.reg_num_mask = 0xff;\n\tdev->mii.supports_gmii = 1;\n\n\tdev->mii.phy_id = asix_read_phy_addr(dev, true);\n\tif (dev->mii.phy_id < 0)\n\t\treturn dev->mii.phy_id;\n\n\tdev->net->netdev_ops = &ax88178_netdev_ops;\n\tdev->net->ethtool_ops = &ax88178_ethtool_ops;\n\tdev->net->max_mtu = 16384 - (dev->net->hard_header_len + 4);\n\n\t \n\tasix_sw_reset(dev, 0, 0);\n\tmsleep(150);\n\n\tasix_sw_reset(dev, AX_SWRESET_PRL | AX_SWRESET_IPPD, 0);\n\tmsleep(150);\n\n\t \n\tif (dev->driver_info->flags & FLAG_FRAMING_AX) {\n\t\t \n\t\tdev->rx_urb_size = 2048;\n\t}\n\n\tdev->driver_priv = kzalloc(sizeof(struct asix_common_private), GFP_KERNEL);\n\tif (!dev->driver_priv)\n\t\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic const struct driver_info ax8817x_info = {\n\t.description = \"ASIX AX8817x USB 2.0 Ethernet\",\n\t.bind = ax88172_bind,\n\t.status = asix_status,\n\t.link_reset = ax88172_link_reset,\n\t.reset = ax88172_link_reset,\n\t.flags =  FLAG_ETHER | FLAG_LINK_INTR,\n\t.data = 0x00130103,\n};\n\nstatic const struct driver_info dlink_dub_e100_info = {\n\t.description = \"DLink DUB-E100 USB Ethernet\",\n\t.bind = ax88172_bind,\n\t.status = asix_status,\n\t.link_reset = ax88172_link_reset,\n\t.reset = ax88172_link_reset,\n\t.flags =  FLAG_ETHER | FLAG_LINK_INTR,\n\t.data = 0x009f9d9f,\n};\n\nstatic const struct driver_info netgear_fa120_info = {\n\t.description = \"Netgear FA-120 USB Ethernet\",\n\t.bind = ax88172_bind,\n\t.status = asix_status,\n\t.link_reset = ax88172_link_reset,\n\t.reset = ax88172_link_reset,\n\t.flags =  FLAG_ETHER | FLAG_LINK_INTR,\n\t.data = 0x00130103,\n};\n\nstatic const struct driver_info hawking_uf200_info = {\n\t.description = \"Hawking UF200 USB Ethernet\",\n\t.bind = ax88172_bind,\n\t.status = asix_status,\n\t.link_reset = ax88172_link_reset,\n\t.reset = ax88172_link_reset,\n\t.flags =  FLAG_ETHER | FLAG_LINK_INTR,\n\t.data = 0x001f1d1f,\n};\n\nstatic const struct driver_info ax88772_info = {\n\t.description = \"ASIX AX88772 USB 2.0 Ethernet\",\n\t.bind = ax88772_bind,\n\t.unbind = ax88772_unbind,\n\t.status = asix_status,\n\t.reset = ax88772_reset,\n\t.stop = ax88772_stop,\n\t.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR | FLAG_MULTI_PACKET,\n\t.rx_fixup = asix_rx_fixup_common,\n\t.tx_fixup = asix_tx_fixup,\n};\n\nstatic const struct driver_info ax88772b_info = {\n\t.description = \"ASIX AX88772B USB 2.0 Ethernet\",\n\t.bind = ax88772_bind,\n\t.unbind = ax88772_unbind,\n\t.status = asix_status,\n\t.reset = ax88772_reset,\n\t.stop = ax88772_stop,\n\t.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR |\n\t         FLAG_MULTI_PACKET,\n\t.rx_fixup = asix_rx_fixup_common,\n\t.tx_fixup = asix_tx_fixup,\n\t.data = FLAG_EEPROM_MAC,\n};\n\nstatic const struct driver_info lxausb_t1l_info = {\n\t.description = \"Linux Automation GmbH USB 10Base-T1L\",\n\t.bind = ax88772_bind,\n\t.unbind = ax88772_unbind,\n\t.status = asix_status,\n\t.reset = ax88772_reset,\n\t.stop = ax88772_stop,\n\t.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR |\n\t\t FLAG_MULTI_PACKET,\n\t.rx_fixup = asix_rx_fixup_common,\n\t.tx_fixup = asix_tx_fixup,\n\t.data = FLAG_EEPROM_MAC,\n};\n\nstatic const struct driver_info ax88178_info = {\n\t.description = \"ASIX AX88178 USB 2.0 Ethernet\",\n\t.bind = ax88178_bind,\n\t.unbind = ax88178_unbind,\n\t.status = asix_status,\n\t.link_reset = ax88178_link_reset,\n\t.reset = ax88178_reset,\n\t.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR |\n\t\t FLAG_MULTI_PACKET,\n\t.rx_fixup = asix_rx_fixup_common,\n\t.tx_fixup = asix_tx_fixup,\n};\n\n \nstatic const struct driver_info hg20f9_info = {\n\t.description = \"HG20F9 USB 2.0 Ethernet\",\n\t.bind = ax88772_bind,\n\t.unbind = ax88772_unbind,\n\t.status = asix_status,\n\t.reset = ax88772_reset,\n\t.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR |\n\t         FLAG_MULTI_PACKET,\n\t.rx_fixup = asix_rx_fixup_common,\n\t.tx_fixup = asix_tx_fixup,\n\t.data = FLAG_EEPROM_MAC,\n};\n\nstatic const struct usb_device_id\tproducts [] = {\n{\n\t\n\tUSB_DEVICE (0x077b, 0x2226),\n\t.driver_info =\t(unsigned long) &ax8817x_info,\n}, {\n\t\n\tUSB_DEVICE (0x0846, 0x1040),\n\t.driver_info =  (unsigned long) &netgear_fa120_info,\n}, {\n\t\n\tUSB_DEVICE (0x2001, 0x1a00),\n\t.driver_info =  (unsigned long) &dlink_dub_e100_info,\n}, {\n\t\n\tUSB_DEVICE (0x0b95, 0x1720),\n\t.driver_info =  (unsigned long) &ax8817x_info,\n}, {\n\t\n\tUSB_DEVICE (0x07b8, 0x420a),\n\t.driver_info =  (unsigned long) &hawking_uf200_info,\n}, {\n\t\n\tUSB_DEVICE (0x08dd, 0x90ff),\n\t.driver_info =  (unsigned long) &ax8817x_info,\n}, {\n\t\n\tUSB_DEVICE(0x08dd, 0x0114),\n\t.driver_info =  (unsigned long) &ax88178_info,\n}, {\n\t\n\tUSB_DEVICE (0x0557, 0x2009),\n\t.driver_info =  (unsigned long) &ax8817x_info,\n}, {\n\t\n\tUSB_DEVICE (0x0411, 0x003d),\n\t.driver_info =  (unsigned long) &ax8817x_info,\n}, {\n\t\n\tUSB_DEVICE (0x0411, 0x006e),\n\t.driver_info =  (unsigned long) &ax88178_info,\n}, {\n\t\n\tUSB_DEVICE (0x6189, 0x182d),\n\t.driver_info =  (unsigned long) &ax8817x_info,\n}, {\n\t\n\tUSB_DEVICE (0x0df6, 0x0056),\n\t.driver_info =  (unsigned long) &ax88178_info,\n}, {\n\t\n\tUSB_DEVICE (0x0df6, 0x061c),\n\t.driver_info =  (unsigned long) &ax88178_info,\n}, {\n\t\n\tUSB_DEVICE (0x07aa, 0x0017),\n\t.driver_info =  (unsigned long) &ax8817x_info,\n}, {\n\t\n\tUSB_DEVICE (0x1189, 0x0893),\n\t.driver_info = (unsigned long) &ax8817x_info,\n}, {\n\t\n\tUSB_DEVICE (0x1631, 0x6200),\n\t.driver_info = (unsigned long) &ax8817x_info,\n}, {\n\t\n\tUSB_DEVICE (0x04f1, 0x3008),\n\t.driver_info = (unsigned long) &ax8817x_info,\n}, {\n\t\n\tUSB_DEVICE (0x17ef, 0x7203),\n\t.driver_info = (unsigned long)&ax88772b_info,\n}, {\n\t\n\tUSB_DEVICE (0x0b95, 0x772b),\n\t.driver_info = (unsigned long) &ax88772b_info,\n}, {\n\t\n\tUSB_DEVICE (0x0b95, 0x7720),\n\t.driver_info = (unsigned long) &ax88772_info,\n}, {\n\t\n\tUSB_DEVICE (0x0b95, 0x1780),\n\t.driver_info = (unsigned long) &ax88178_info,\n}, {\n\t\n\tUSB_DEVICE (0x0789, 0x0160),\n\t.driver_info = (unsigned long) &ax88178_info,\n}, {\n\t\n\tUSB_DEVICE (0x13b1, 0x0018),\n\t.driver_info = (unsigned long) &ax88772_info,\n}, {\n\t\n\tUSB_DEVICE (0x1557, 0x7720),\n\t.driver_info = (unsigned long) &ax88772_info,\n}, {\n\t\n\tUSB_DEVICE (0x07d1, 0x3c05),\n\t.driver_info = (unsigned long) &ax88772_info,\n}, {\n\t\n\tUSB_DEVICE (0x2001, 0x3c05),\n\t.driver_info = (unsigned long) &ax88772_info,\n}, {\n       \n       USB_DEVICE (0x2001, 0x1a02),\n       .driver_info = (unsigned long) &ax88772_info,\n}, {\n\t\n\tUSB_DEVICE (0x1737, 0x0039),\n\t.driver_info = (unsigned long) &ax88178_info,\n}, {\n\t\n\tUSB_DEVICE (0x04bb, 0x0930),\n\t.driver_info = (unsigned long) &ax88178_info,\n}, {\n\t\n\tUSB_DEVICE(0x050d, 0x5055),\n\t.driver_info = (unsigned long) &ax88178_info,\n}, {\n\t\n\tUSB_DEVICE(0x05ac, 0x1402),\n\t.driver_info = (unsigned long) &ax88772_info,\n}, {\n\t\n\tUSB_DEVICE(0x0b95, 0x772a),\n\t.driver_info = (unsigned long) &ax88772_info,\n}, {\n\t\n\tUSB_DEVICE(0x14ea, 0xab11),\n\t.driver_info = (unsigned long) &ax88178_info,\n}, {\n\t\n\tUSB_DEVICE(0x0db0, 0xa877),\n\t.driver_info = (unsigned long) &ax88772_info,\n}, {\n\t\n\tUSB_DEVICE (0x0b95, 0x7e2b),\n\t.driver_info = (unsigned long)&ax88772b_info,\n}, {\n\t \n\tUSB_DEVICE(0x0b95, 0x172a),\n\t.driver_info = (unsigned long) &ax88172a_info,\n}, {\n\t \n\tUSB_DEVICE(0x066b, 0x20f9),\n\t.driver_info = (unsigned long) &hg20f9_info,\n}, {\n\t\n\tUSB_DEVICE(0x33f7, 0x0004),\n\t.driver_info = (unsigned long) &lxausb_t1l_info,\n},\n\t{ },\t\t\n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver asix_driver = {\n\t.name =\t\tDRIVER_NAME,\n\t.id_table =\tproducts,\n\t.probe =\tusbnet_probe,\n\t.suspend =\tasix_suspend,\n\t.resume =\tasix_resume,\n\t.reset_resume =\tasix_resume,\n\t.disconnect =\tusbnet_disconnect,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(asix_driver);\n\nMODULE_AUTHOR(\"David Hollis\");\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_DESCRIPTION(\"ASIX AX8817X based USB 2.0 Ethernet Devices\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}