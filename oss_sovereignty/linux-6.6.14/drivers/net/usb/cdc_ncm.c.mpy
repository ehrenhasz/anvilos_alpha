{
  "module_name": "cdc_ncm.c",
  "hash_id": "40482ab5ef52c299f4ae38b410e8529372bf4ca00d3633b87981565c982b95f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/cdc_ncm.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/ctype.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/kstrtox.h>\n#include <linux/workqueue.h>\n#include <linux/mii.h>\n#include <linux/crc32.h>\n#include <linux/usb.h>\n#include <linux/hrtimer.h>\n#include <linux/atomic.h>\n#include <linux/usb/usbnet.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/cdc_ncm.h>\n\n#if IS_ENABLED(CONFIG_USB_NET_CDC_MBIM)\nstatic bool prefer_mbim = true;\n#else\nstatic bool prefer_mbim;\n#endif\nmodule_param(prefer_mbim, bool, 0644);\nMODULE_PARM_DESC(prefer_mbim, \"Prefer MBIM setting on dual NCM/MBIM functions\");\n\nstatic void cdc_ncm_txpath_bh(struct tasklet_struct *t);\nstatic void cdc_ncm_tx_timeout_start(struct cdc_ncm_ctx *ctx);\nstatic enum hrtimer_restart cdc_ncm_tx_timer_cb(struct hrtimer *hr_timer);\nstatic struct usb_driver cdc_ncm_driver;\n\nstruct cdc_ncm_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n#define CDC_NCM_STAT(str, m) { \\\n\t\t.stat_string = str, \\\n\t\t.sizeof_stat = sizeof(((struct cdc_ncm_ctx *)0)->m), \\\n\t\t.stat_offset = offsetof(struct cdc_ncm_ctx, m) }\n#define CDC_NCM_SIMPLE_STAT(m)\tCDC_NCM_STAT(__stringify(m), m)\n\nstatic const struct cdc_ncm_stats cdc_ncm_gstrings_stats[] = {\n\tCDC_NCM_SIMPLE_STAT(tx_reason_ntb_full),\n\tCDC_NCM_SIMPLE_STAT(tx_reason_ndp_full),\n\tCDC_NCM_SIMPLE_STAT(tx_reason_timeout),\n\tCDC_NCM_SIMPLE_STAT(tx_reason_max_datagram),\n\tCDC_NCM_SIMPLE_STAT(tx_overhead),\n\tCDC_NCM_SIMPLE_STAT(tx_ntbs),\n\tCDC_NCM_SIMPLE_STAT(rx_overhead),\n\tCDC_NCM_SIMPLE_STAT(rx_ntbs),\n};\n\n#define CDC_NCM_LOW_MEM_MAX_CNT 10\n\nstatic int cdc_ncm_get_sset_count(struct net_device __always_unused *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(cdc_ncm_gstrings_stats);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void cdc_ncm_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t    struct ethtool_stats __always_unused *stats,\n\t\t\t\t    u64 *data)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tint i;\n\tchar *p = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(cdc_ncm_gstrings_stats); i++) {\n\t\tp = (char *)ctx + cdc_ncm_gstrings_stats[i].stat_offset;\n\t\tdata[i] = (cdc_ncm_gstrings_stats[i].sizeof_stat == sizeof(u64)) ? *(u64 *)p : *(u32 *)p;\n\t}\n}\n\nstatic void cdc_ncm_get_strings(struct net_device __always_unused *netdev, u32 stringset, u8 *data)\n{\n\tu8 *p = data;\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < ARRAY_SIZE(cdc_ncm_gstrings_stats); i++) {\n\t\t\tmemcpy(p, cdc_ncm_gstrings_stats[i].stat_string, ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t}\n}\n\nstatic void cdc_ncm_update_rxtx_max(struct usbnet *dev, u32 new_rx, u32 new_tx);\n\nstatic const struct ethtool_ops cdc_ncm_ethtool_ops = {\n\t.get_link\t\t= usbnet_get_link,\n\t.nway_reset\t\t= usbnet_nway_reset,\n\t.get_drvinfo\t\t= usbnet_get_drvinfo,\n\t.get_msglevel\t\t= usbnet_get_msglevel,\n\t.set_msglevel\t\t= usbnet_set_msglevel,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_sset_count\t\t= cdc_ncm_get_sset_count,\n\t.get_strings\t\t= cdc_ncm_get_strings,\n\t.get_ethtool_stats\t= cdc_ncm_get_ethtool_stats,\n\t.get_link_ksettings\t= usbnet_get_link_ksettings_internal,\n\t.set_link_ksettings\t= NULL,\n};\n\nstatic u32 cdc_ncm_check_rx_max(struct usbnet *dev, u32 new_rx)\n{\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tu32 val, max, min;\n\n\t \n\tmin = USB_CDC_NCM_NTB_MIN_IN_SIZE;\n\tmax = min_t(u32, CDC_NCM_NTB_MAX_SIZE_RX, le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize));\n\n\t \n\tif (max < min) {\n\t\tdev_warn(&dev->intf->dev, \"dwNtbInMaxSize=%u is too small. Using %u\\n\",\n\t\t\t le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize), min);\n\t\tmax = min;\n\t}\n\n\tval = clamp_t(u32, new_rx, min, max);\n\tif (val != new_rx)\n\t\tdev_dbg(&dev->intf->dev, \"rx_max must be in the [%u, %u] range\\n\", min, max);\n\n\treturn val;\n}\n\nstatic u32 cdc_ncm_check_tx_max(struct usbnet *dev, u32 new_tx)\n{\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tu32 val, max, min;\n\n\t \n\tif (ctx->is_ndp16)\n\t\tmin = ctx->max_datagram_size + ctx->max_ndp_size + sizeof(struct usb_cdc_ncm_nth16);\n\telse\n\t\tmin = ctx->max_datagram_size + ctx->max_ndp_size + sizeof(struct usb_cdc_ncm_nth32);\n\n\tif (le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize) == 0)\n\t\tmax = CDC_NCM_NTB_MAX_SIZE_TX;  \n\telse\n\t\tmax = clamp_t(u32, le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize),\n\t\t\t      USB_CDC_NCM_NTB_MIN_OUT_SIZE,\n\t\t\t      CDC_NCM_NTB_MAX_SIZE_TX);\n\n\t \n\tmin = min(min, max);\n\n\tval = clamp_t(u32, new_tx, min, max);\n\tif (val != new_tx)\n\t\tdev_dbg(&dev->intf->dev, \"tx_max must be in the [%u, %u] range\\n\", min, max);\n\n\treturn val;\n}\n\nstatic ssize_t min_tx_pkt_show(struct device *d,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\n\treturn sprintf(buf, \"%u\\n\", ctx->min_tx_pkt);\n}\n\nstatic ssize_t rx_max_show(struct device *d,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\n\treturn sprintf(buf, \"%u\\n\", ctx->rx_max);\n}\n\nstatic ssize_t tx_max_show(struct device *d,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\n\treturn sprintf(buf, \"%u\\n\", ctx->tx_max);\n}\n\nstatic ssize_t tx_timer_usecs_show(struct device *d,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\n\treturn sprintf(buf, \"%u\\n\", ctx->timer_interval / (u32)NSEC_PER_USEC);\n}\n\nstatic ssize_t min_tx_pkt_store(struct device *d,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tunsigned long val;\n\n\t \n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tctx->min_tx_pkt = val;\n\treturn len;\n}\n\nstatic ssize_t rx_max_store(struct device *d,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t len)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val) || cdc_ncm_check_rx_max(dev, val) != val)\n\t\treturn -EINVAL;\n\n\tcdc_ncm_update_rxtx_max(dev, val, ctx->tx_max);\n\treturn len;\n}\n\nstatic ssize_t tx_max_store(struct device *d,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t len)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 0, &val) || cdc_ncm_check_tx_max(dev, val) != val)\n\t\treturn -EINVAL;\n\n\tcdc_ncm_update_rxtx_max(dev, ctx->rx_max, val);\n\treturn len;\n}\n\nstatic ssize_t tx_timer_usecs_store(struct device *d,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t len)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tssize_t ret;\n\tunsigned long val;\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val && (val < CDC_NCM_TIMER_INTERVAL_MIN || val > CDC_NCM_TIMER_INTERVAL_MAX))\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&ctx->mtx);\n\tctx->timer_interval = val * NSEC_PER_USEC;\n\tif (!ctx->timer_interval)\n\t\tctx->tx_timer_pending = 0;\n\tspin_unlock_bh(&ctx->mtx);\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RW(min_tx_pkt);\nstatic DEVICE_ATTR_RW(rx_max);\nstatic DEVICE_ATTR_RW(tx_max);\nstatic DEVICE_ATTR_RW(tx_timer_usecs);\n\nstatic ssize_t ndp_to_end_show(struct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\n\treturn sprintf(buf, \"%c\\n\", ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END ? 'Y' : 'N');\n}\n\nstatic ssize_t ndp_to_end_store(struct device *d,  struct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tbool enable;\n\n\tif (kstrtobool(buf, &enable))\n\t\treturn -EINVAL;\n\n\t \n\tif (enable == (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END))\n\t\treturn len;\n\n\tif (enable) {\n\t\tif (ctx->is_ndp16 && !ctx->delayed_ndp16) {\n\t\t\tctx->delayed_ndp16 = kzalloc(ctx->max_ndp_size, GFP_KERNEL);\n\t\t\tif (!ctx->delayed_ndp16)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!ctx->is_ndp16 && !ctx->delayed_ndp32) {\n\t\t\tctx->delayed_ndp32 = kzalloc(ctx->max_ndp_size, GFP_KERNEL);\n\t\t\tif (!ctx->delayed_ndp32)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tnetif_tx_lock_bh(dev->net);\n\tusbnet_start_xmit(NULL, dev->net);\n\tspin_lock_bh(&ctx->mtx);\n\tif (enable)\n\t\tctx->drvflags |= CDC_NCM_FLAG_NDP_TO_END;\n\telse\n\t\tctx->drvflags &= ~CDC_NCM_FLAG_NDP_TO_END;\n\tspin_unlock_bh(&ctx->mtx);\n\tnetif_tx_unlock_bh(dev->net);\n\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(ndp_to_end);\n\n#define NCM_PARM_ATTR(name, format, tocpu)\t\t\t\t\\\nstatic ssize_t cdc_ncm_show_##name(struct device *d, struct device_attribute *attr, char *buf) \\\n{ \\\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d)); \\\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0]; \\\n\treturn sprintf(buf, format \"\\n\", tocpu(ctx->ncm_parm.name));\t\\\n} \\\nstatic DEVICE_ATTR(name, 0444, cdc_ncm_show_##name, NULL)\n\nNCM_PARM_ATTR(bmNtbFormatsSupported, \"0x%04x\", le16_to_cpu);\nNCM_PARM_ATTR(dwNtbInMaxSize, \"%u\", le32_to_cpu);\nNCM_PARM_ATTR(wNdpInDivisor, \"%u\", le16_to_cpu);\nNCM_PARM_ATTR(wNdpInPayloadRemainder, \"%u\", le16_to_cpu);\nNCM_PARM_ATTR(wNdpInAlignment, \"%u\", le16_to_cpu);\nNCM_PARM_ATTR(dwNtbOutMaxSize, \"%u\", le32_to_cpu);\nNCM_PARM_ATTR(wNdpOutDivisor, \"%u\", le16_to_cpu);\nNCM_PARM_ATTR(wNdpOutPayloadRemainder, \"%u\", le16_to_cpu);\nNCM_PARM_ATTR(wNdpOutAlignment, \"%u\", le16_to_cpu);\nNCM_PARM_ATTR(wNtbOutMaxDatagrams, \"%u\", le16_to_cpu);\n\nstatic struct attribute *cdc_ncm_sysfs_attrs[] = {\n\t&dev_attr_min_tx_pkt.attr,\n\t&dev_attr_ndp_to_end.attr,\n\t&dev_attr_rx_max.attr,\n\t&dev_attr_tx_max.attr,\n\t&dev_attr_tx_timer_usecs.attr,\n\t&dev_attr_bmNtbFormatsSupported.attr,\n\t&dev_attr_dwNtbInMaxSize.attr,\n\t&dev_attr_wNdpInDivisor.attr,\n\t&dev_attr_wNdpInPayloadRemainder.attr,\n\t&dev_attr_wNdpInAlignment.attr,\n\t&dev_attr_dwNtbOutMaxSize.attr,\n\t&dev_attr_wNdpOutDivisor.attr,\n\t&dev_attr_wNdpOutPayloadRemainder.attr,\n\t&dev_attr_wNdpOutAlignment.attr,\n\t&dev_attr_wNtbOutMaxDatagrams.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cdc_ncm_sysfs_attr_group = {\n\t.name = \"cdc_ncm\",\n\t.attrs = cdc_ncm_sysfs_attrs,\n};\n\n \nstatic void cdc_ncm_update_rxtx_max(struct usbnet *dev, u32 new_rx, u32 new_tx)\n{\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tu8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;\n\tu32 val;\n\n\tval = cdc_ncm_check_rx_max(dev, new_rx);\n\n\t \n\tif (val != ctx->rx_max) {\n\t\t__le32 dwNtbInMaxSize = cpu_to_le32(val);\n\n\t\tdev_info(&dev->intf->dev, \"setting rx_max = %u\\n\", val);\n\n\t\t \n\t\tif (usbnet_write_cmd(dev, USB_CDC_SET_NTB_INPUT_SIZE,\n\t\t\t\t     USB_TYPE_CLASS | USB_DIR_OUT\n\t\t\t\t     | USB_RECIP_INTERFACE,\n\t\t\t\t     0, iface_no, &dwNtbInMaxSize, 4) < 0)\n\t\t\tdev_dbg(&dev->intf->dev, \"Setting NTB Input Size failed\\n\");\n\t\telse\n\t\t\tctx->rx_max = val;\n\t}\n\n\t \n\tif (dev->rx_urb_size != ctx->rx_max) {\n\t\tdev->rx_urb_size = ctx->rx_max;\n\t\tif (netif_running(dev->net))\n\t\t\tusbnet_unlink_rx_urbs(dev);\n\t}\n\n\tval = cdc_ncm_check_tx_max(dev, new_tx);\n\tif (val != ctx->tx_max)\n\t\tdev_info(&dev->intf->dev, \"setting tx_max = %u\\n\", val);\n\n\t \n\tif (val != le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize) &&\n\t    val % usb_maxpacket(dev->udev, dev->out) == 0)\n\t\tval++;\n\n\t \n\tif (netif_running(dev->net) && val > ctx->tx_max) {\n\t\tnetif_tx_lock_bh(dev->net);\n\t\tusbnet_start_xmit(NULL, dev->net);\n\t\t \n\t\tif (ctx->tx_curr_skb) {\n\t\t\tdev_kfree_skb_any(ctx->tx_curr_skb);\n\t\t\tctx->tx_curr_skb = NULL;\n\t\t}\n\t\tctx->tx_max = val;\n\t\tnetif_tx_unlock_bh(dev->net);\n\t} else {\n\t\tctx->tx_max = val;\n\t}\n\n\tdev->hard_mtu = ctx->tx_max;\n\n\t \n\tusbnet_update_max_qlen(dev);\n\n\t \n\tctx->min_tx_pkt = clamp_t(u16, ctx->tx_max - 3 * usb_maxpacket(dev->udev, dev->out),\n\t\t\t\t  CDC_NCM_MIN_TX_PKT, ctx->tx_max);\n}\n\n \nstatic u8 cdc_ncm_flags(struct usbnet *dev)\n{\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\n\tif (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting) && ctx->mbim_desc)\n\t\treturn ctx->mbim_desc->bmNetworkCapabilities;\n\tif (ctx->func_desc)\n\t\treturn ctx->func_desc->bmNetworkCapabilities;\n\treturn 0;\n}\n\nstatic int cdc_ncm_eth_hlen(struct usbnet *dev)\n{\n\tif (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting))\n\t\treturn 0;\n\treturn ETH_HLEN;\n}\n\nstatic u32 cdc_ncm_min_dgram_size(struct usbnet *dev)\n{\n\tif (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting))\n\t\treturn CDC_MBIM_MIN_DATAGRAM_SIZE;\n\treturn CDC_NCM_MIN_DATAGRAM_SIZE;\n}\n\nstatic u32 cdc_ncm_max_dgram_size(struct usbnet *dev)\n{\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\n\tif (cdc_ncm_comm_intf_is_mbim(dev->intf->cur_altsetting) && ctx->mbim_desc)\n\t\treturn le16_to_cpu(ctx->mbim_desc->wMaxSegmentSize);\n\tif (ctx->ether_desc)\n\t\treturn le16_to_cpu(ctx->ether_desc->wMaxSegmentSize);\n\treturn CDC_NCM_MAX_DATAGRAM_SIZE;\n}\n\n \nstatic int cdc_ncm_init(struct usbnet *dev)\n{\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tu8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;\n\tint err;\n\n\terr = usbnet_read_cmd(dev, USB_CDC_GET_NTB_PARAMETERS,\n\t\t\t      USB_TYPE_CLASS | USB_DIR_IN\n\t\t\t      |USB_RECIP_INTERFACE,\n\t\t\t      0, iface_no, &ctx->ncm_parm,\n\t\t\t      sizeof(ctx->ncm_parm));\n\tif (err < 0) {\n\t\tdev_err(&dev->intf->dev, \"failed GET_NTB_PARAMETERS\\n\");\n\t\treturn err;  \n\t}\n\n\t \n\tif (cdc_ncm_flags(dev) & USB_CDC_NCM_NCAP_CRC_MODE) {\n\t\tdev_dbg(&dev->intf->dev, \"Setting CRC mode off\\n\");\n\t\terr = usbnet_write_cmd(dev, USB_CDC_SET_CRC_MODE,\n\t\t\t\t       USB_TYPE_CLASS | USB_DIR_OUT\n\t\t\t\t       | USB_RECIP_INTERFACE,\n\t\t\t\t       USB_CDC_NCM_CRC_NOT_APPENDED,\n\t\t\t\t       iface_no, NULL, 0);\n\t\tif (err < 0)\n\t\t\tdev_err(&dev->intf->dev, \"SET_CRC_MODE failed\\n\");\n\t}\n\n\t \n\tctx->is_ndp16 = 1;\n\n\t \n\tif (le16_to_cpu(ctx->ncm_parm.bmNtbFormatsSupported) &\n\t\t\t\t\t\tUSB_CDC_NCM_NTB32_SUPPORTED) {\n\t\tif (ctx->drvflags & CDC_NCM_FLAG_PREFER_NTB32) {\n\t\t\tctx->is_ndp16 = 0;\n\t\t\tdev_dbg(&dev->intf->dev, \"Setting NTB format to 32-bit\\n\");\n\t\t\terr = usbnet_write_cmd(dev, USB_CDC_SET_NTB_FORMAT,\n\t\t\t\t\t       USB_TYPE_CLASS | USB_DIR_OUT\n\t\t\t\t\t       | USB_RECIP_INTERFACE,\n\t\t\t\t\t       USB_CDC_NCM_NTB32_FORMAT,\n\t\t\t\t\t       iface_no, NULL, 0);\n\t\t} else {\n\t\t\tctx->is_ndp16 = 1;\n\t\t\tdev_dbg(&dev->intf->dev, \"Setting NTB format to 16-bit\\n\");\n\t\t\terr = usbnet_write_cmd(dev, USB_CDC_SET_NTB_FORMAT,\n\t\t\t\t\t       USB_TYPE_CLASS | USB_DIR_OUT\n\t\t\t\t\t       | USB_RECIP_INTERFACE,\n\t\t\t\t\t       USB_CDC_NCM_NTB16_FORMAT,\n\t\t\t\t\t       iface_no, NULL, 0);\n\t\t}\n\t\tif (err < 0) {\n\t\t\tctx->is_ndp16 = 1;\n\t\t\tdev_err(&dev->intf->dev, \"SET_NTB_FORMAT failed\\n\");\n\t\t}\n\t}\n\n\t \n\tctx->rx_max = le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize);\n\tctx->tx_max = le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize);\n\tctx->tx_remainder = le16_to_cpu(ctx->ncm_parm.wNdpOutPayloadRemainder);\n\tctx->tx_modulus = le16_to_cpu(ctx->ncm_parm.wNdpOutDivisor);\n\tctx->tx_ndp_modulus = le16_to_cpu(ctx->ncm_parm.wNdpOutAlignment);\n\t \n\tctx->tx_max_datagrams = le16_to_cpu(ctx->ncm_parm.wNtbOutMaxDatagrams);\n\n\tdev_dbg(&dev->intf->dev,\n\t\t\"dwNtbInMaxSize=%u dwNtbOutMaxSize=%u wNdpOutPayloadRemainder=%u wNdpOutDivisor=%u wNdpOutAlignment=%u wNtbOutMaxDatagrams=%u flags=0x%x\\n\",\n\t\tctx->rx_max, ctx->tx_max, ctx->tx_remainder, ctx->tx_modulus,\n\t\tctx->tx_ndp_modulus, ctx->tx_max_datagrams, cdc_ncm_flags(dev));\n\n\t \n\tif ((ctx->tx_max_datagrams == 0) ||\n\t\t\t(ctx->tx_max_datagrams > CDC_NCM_DPT_DATAGRAMS_MAX))\n\t\tctx->tx_max_datagrams = CDC_NCM_DPT_DATAGRAMS_MAX;\n\n\t \n\tif (ctx->is_ndp16)\n\t\tctx->max_ndp_size = sizeof(struct usb_cdc_ncm_ndp16) + (ctx->tx_max_datagrams + 1) * sizeof(struct usb_cdc_ncm_dpe16);\n\telse\n\t\tctx->max_ndp_size = sizeof(struct usb_cdc_ncm_ndp32) + (ctx->tx_max_datagrams + 1) * sizeof(struct usb_cdc_ncm_dpe32);\n\n\t \n\tctx->timer_interval = CDC_NCM_TIMER_INTERVAL_USEC * NSEC_PER_USEC;\n\n\treturn 0;\n}\n\n \nstatic void cdc_ncm_set_dgram_size(struct usbnet *dev, int new_size)\n{\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tu8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;\n\t__le16 max_datagram_size;\n\tu16 mbim_mtu;\n\tint err;\n\n\t \n\tctx->max_datagram_size = clamp_t(u32, new_size,\n\t\t\t\t\t cdc_ncm_min_dgram_size(dev),\n\t\t\t\t\t CDC_NCM_MAX_DATAGRAM_SIZE);\n\n\t \n\tif (!(cdc_ncm_flags(dev) & USB_CDC_NCM_NCAP_MAX_DATAGRAM_SIZE))\n\t\tgoto out;\n\n\t \n\terr = usbnet_read_cmd(dev, USB_CDC_GET_MAX_DATAGRAM_SIZE,\n\t\t\t      USB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,\n\t\t\t      0, iface_no, &max_datagram_size, sizeof(max_datagram_size));\n\tif (err != sizeof(max_datagram_size)) {\n\t\tdev_dbg(&dev->intf->dev, \"GET_MAX_DATAGRAM_SIZE failed\\n\");\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(max_datagram_size) == ctx->max_datagram_size)\n\t\tgoto out;\n\n\tmax_datagram_size = cpu_to_le16(ctx->max_datagram_size);\n\terr = usbnet_write_cmd(dev, USB_CDC_SET_MAX_DATAGRAM_SIZE,\n\t\t\t       USB_TYPE_CLASS | USB_DIR_OUT | USB_RECIP_INTERFACE,\n\t\t\t       0, iface_no, &max_datagram_size, sizeof(max_datagram_size));\n\tif (err < 0)\n\t\tdev_dbg(&dev->intf->dev, \"SET_MAX_DATAGRAM_SIZE failed\\n\");\n\nout:\n\t \n\tdev->net->mtu = min_t(int, dev->net->mtu, ctx->max_datagram_size - cdc_ncm_eth_hlen(dev));\n\n\t \n\tif (ctx->mbim_extended_desc) {\n\t\tmbim_mtu = le16_to_cpu(ctx->mbim_extended_desc->wMTU);\n\t\tif (mbim_mtu != 0 && mbim_mtu < dev->net->mtu)\n\t\t\tdev->net->mtu = mbim_mtu;\n\t}\n}\n\nstatic void cdc_ncm_fix_modulus(struct usbnet *dev)\n{\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tu32 val;\n\n\t \n\tval = ctx->tx_ndp_modulus;\n\n\tif ((val < USB_CDC_NCM_NDP_ALIGN_MIN_SIZE) ||\n\t    (val != ((-val) & val)) || (val >= ctx->tx_max)) {\n\t\tdev_dbg(&dev->intf->dev, \"Using default alignment: 4 bytes\\n\");\n\t\tctx->tx_ndp_modulus = USB_CDC_NCM_NDP_ALIGN_MIN_SIZE;\n\t}\n\n\t \n\tval = ctx->tx_modulus;\n\n\tif ((val < USB_CDC_NCM_NDP_ALIGN_MIN_SIZE) ||\n\t    (val != ((-val) & val)) || (val >= ctx->tx_max)) {\n\t\tdev_dbg(&dev->intf->dev, \"Using default transmit modulus: 4 bytes\\n\");\n\t\tctx->tx_modulus = USB_CDC_NCM_NDP_ALIGN_MIN_SIZE;\n\t}\n\n\t \n\tif (ctx->tx_remainder >= ctx->tx_modulus) {\n\t\tdev_dbg(&dev->intf->dev, \"Using default transmit remainder: 0 bytes\\n\");\n\t\tctx->tx_remainder = 0;\n\t}\n\n\t \n\tctx->tx_remainder = ((ctx->tx_remainder - cdc_ncm_eth_hlen(dev)) &\n\t\t\t     (ctx->tx_modulus - 1));\n}\n\nstatic int cdc_ncm_setup(struct usbnet *dev)\n{\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tu32 def_rx, def_tx;\n\n\t \n\tdef_rx = min_t(u32, CDC_NCM_NTB_DEF_SIZE_RX,\n\t\t       le32_to_cpu(ctx->ncm_parm.dwNtbInMaxSize));\n\tdef_tx = min_t(u32, CDC_NCM_NTB_DEF_SIZE_TX,\n\t\t       le32_to_cpu(ctx->ncm_parm.dwNtbOutMaxSize));\n\n\t \n\tcdc_ncm_update_rxtx_max(dev, def_rx, def_tx);\n\n\t \n\tcdc_ncm_fix_modulus(dev);\n\n\t \n\tcdc_ncm_set_dgram_size(dev, cdc_ncm_max_dgram_size(dev));\n\treturn 0;\n}\n\nstatic void\ncdc_ncm_find_endpoints(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct usb_host_endpoint *e, *in = NULL, *out = NULL;\n\tu8 ep;\n\n\tfor (ep = 0; ep < intf->cur_altsetting->desc.bNumEndpoints; ep++) {\n\t\te = intf->cur_altsetting->endpoint + ep;\n\n\t\t \n\t\tif (!usb_endpoint_maxp(&e->desc))\n\t\t\tcontinue;\n\n\t\tswitch (e->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\n\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\tif (usb_endpoint_dir_in(&e->desc)) {\n\t\t\t\tif (!dev->status)\n\t\t\t\t\tdev->status = e;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\tif (usb_endpoint_dir_in(&e->desc)) {\n\t\t\t\tif (!in)\n\t\t\t\t\tin = e;\n\t\t\t} else {\n\t\t\t\tif (!out)\n\t\t\t\t\tout = e;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (in && !dev->in)\n\t\tdev->in = usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t  in->desc.bEndpointAddress &\n\t\t\t\t\t  USB_ENDPOINT_NUMBER_MASK);\n\tif (out && !dev->out)\n\t\tdev->out = usb_sndbulkpipe(dev->udev,\n\t\t\t\t\t   out->desc.bEndpointAddress &\n\t\t\t\t\t   USB_ENDPOINT_NUMBER_MASK);\n}\n\nstatic void cdc_ncm_free(struct cdc_ncm_ctx *ctx)\n{\n\tif (ctx == NULL)\n\t\treturn;\n\n\tif (ctx->tx_rem_skb != NULL) {\n\t\tdev_kfree_skb_any(ctx->tx_rem_skb);\n\t\tctx->tx_rem_skb = NULL;\n\t}\n\n\tif (ctx->tx_curr_skb != NULL) {\n\t\tdev_kfree_skb_any(ctx->tx_curr_skb);\n\t\tctx->tx_curr_skb = NULL;\n\t}\n\n\tif (ctx->is_ndp16)\n\t\tkfree(ctx->delayed_ndp16);\n\telse\n\t\tkfree(ctx->delayed_ndp32);\n\n\tkfree(ctx);\n}\n\n \nint cdc_ncm_change_mtu(struct net_device *net, int new_mtu)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\tnet->mtu = new_mtu;\n\tcdc_ncm_set_dgram_size(dev, new_mtu + cdc_ncm_eth_hlen(dev));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cdc_ncm_change_mtu);\n\nstatic const struct net_device_ops cdc_ncm_netdev_ops = {\n\t.ndo_open\t     = usbnet_open,\n\t.ndo_stop\t     = usbnet_stop,\n\t.ndo_start_xmit\t     = usbnet_start_xmit,\n\t.ndo_tx_timeout\t     = usbnet_tx_timeout,\n\t.ndo_set_rx_mode     = usbnet_set_rx_mode,\n\t.ndo_get_stats64     = dev_get_tstats64,\n\t.ndo_change_mtu\t     = cdc_ncm_change_mtu,\n\t.ndo_set_mac_address = eth_mac_addr,\n\t.ndo_validate_addr   = eth_validate_addr,\n};\n\nint cdc_ncm_bind_common(struct usbnet *dev, struct usb_interface *intf, u8 data_altsetting, int drvflags)\n{\n\tstruct cdc_ncm_ctx *ctx;\n\tstruct usb_driver *driver;\n\tu8 *buf;\n\tint len;\n\tint temp;\n\tu8 iface_no;\n\tstruct usb_cdc_parsed_header hdr;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = dev;\n\n\thrtimer_init(&ctx->tx_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tctx->tx_timer.function = &cdc_ncm_tx_timer_cb;\n\ttasklet_setup(&ctx->bh, cdc_ncm_txpath_bh);\n\tatomic_set(&ctx->stop, 0);\n\tspin_lock_init(&ctx->mtx);\n\n\t \n\tdev->data[0] = (unsigned long)ctx;\n\n\t \n\tctx->control = intf;\n\n\t \n\tdriver = driver_of(intf);\n\tbuf = intf->cur_altsetting->extra;\n\tlen = intf->cur_altsetting->extralen;\n\n\t \n\tcdc_parse_cdc_header(&hdr, intf, buf, len);\n\n\tif (hdr.usb_cdc_union_desc)\n\t\tctx->data = usb_ifnum_to_if(dev->udev,\n\t\t\t\t\t    hdr.usb_cdc_union_desc->bSlaveInterface0);\n\tctx->ether_desc = hdr.usb_cdc_ether_desc;\n\tctx->func_desc = hdr.usb_cdc_ncm_desc;\n\tctx->mbim_desc = hdr.usb_cdc_mbim_desc;\n\tctx->mbim_extended_desc = hdr.usb_cdc_mbim_extended_desc;\n\n\t \n\tif (!hdr.usb_cdc_union_desc && intf->intf_assoc && intf->intf_assoc->bInterfaceCount == 2) {\n\t\tctx->data = usb_ifnum_to_if(dev->udev, intf->cur_altsetting->desc.bInterfaceNumber + 1);\n\t\tdev_dbg(&intf->dev, \"CDC Union missing - got slave from IAD\\n\");\n\t}\n\n\t \n\tif (!ctx->data) {\n\t\tdev_err(&intf->dev, \"CDC Union missing and no IAD found\\n\");\n\t\tgoto error;\n\t}\n\tif (cdc_ncm_comm_intf_is_mbim(intf->cur_altsetting)) {\n\t\tif (!ctx->mbim_desc) {\n\t\t\tdev_err(&intf->dev, \"MBIM functional descriptor missing\\n\");\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tif (!ctx->ether_desc || !ctx->func_desc) {\n\t\t\tdev_err(&intf->dev, \"NCM or ECM functional descriptors missing\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tif (ctx->data != ctx->control) {\n\t\ttemp = usb_driver_claim_interface(driver, ctx->data, dev);\n\t\tif (temp) {\n\t\t\tdev_err(&intf->dev, \"failed to claim data intf\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tiface_no = ctx->data->cur_altsetting->desc.bInterfaceNumber;\n\n\t \n\tctx->drvflags = drvflags;\n\n\t \n\tif (!(ctx->drvflags & CDC_MBIM_FLAG_AVOID_ALTSETTING_TOGGLE))\n\t\tusb_set_interface(dev->udev, iface_no, data_altsetting);\n\n\ttemp = usb_set_interface(dev->udev, iface_no, 0);\n\tif (temp) {\n\t\tdev_dbg(&intf->dev, \"set interface failed\\n\");\n\t\tgoto error2;\n\t}\n\n\t \n\tif (cdc_ncm_init(dev))\n\t\tgoto error2;\n\n\t \n\tusleep_range(10000, 20000);\n\n\t \n\ttemp = usb_set_interface(dev->udev, iface_no, data_altsetting);\n\tif (temp) {\n\t\tdev_dbg(&intf->dev, \"set interface failed\\n\");\n\t\tgoto error2;\n\t}\n\n\tcdc_ncm_find_endpoints(dev, ctx->data);\n\tcdc_ncm_find_endpoints(dev, ctx->control);\n\tif (!dev->in || !dev->out || !dev->status) {\n\t\tdev_dbg(&intf->dev, \"failed to collect endpoints\\n\");\n\t\tgoto error2;\n\t}\n\n\tusb_set_intfdata(ctx->control, dev);\n\n\tif (ctx->ether_desc) {\n\t\ttemp = usbnet_get_ethernet_addr(dev, ctx->ether_desc->iMACAddress);\n\t\tif (temp) {\n\t\t\tdev_err(&intf->dev, \"failed to get mac address\\n\");\n\t\t\tgoto error2;\n\t\t}\n\t\tdev_info(&intf->dev, \"MAC-Address: %pM\\n\", dev->net->dev_addr);\n\t}\n\n\t \n\tcdc_ncm_setup(dev);\n\n\t \n\tif (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END) {\n\t\tif (ctx->is_ndp16) {\n\t\t\tctx->delayed_ndp16 = kzalloc(ctx->max_ndp_size, GFP_KERNEL);\n\t\t\tif (!ctx->delayed_ndp16)\n\t\t\t\tgoto error2;\n\t\t} else {\n\t\t\tctx->delayed_ndp32 = kzalloc(ctx->max_ndp_size, GFP_KERNEL);\n\t\t\tif (!ctx->delayed_ndp32)\n\t\t\t\tgoto error2;\n\t\t}\n\t\tdev_info(&intf->dev, \"NDP will be placed at end of frame for this device.\");\n\t}\n\n\t \n\tdev->net->ethtool_ops = &cdc_ncm_ethtool_ops;\n\n\t \n\tdev->net->sysfs_groups[0] = &cdc_ncm_sysfs_attr_group;\n\n\t \n\tdev->net->netdev_ops = &cdc_ncm_netdev_ops;\n\tdev->net->max_mtu = cdc_ncm_max_dgram_size(dev) - cdc_ncm_eth_hlen(dev);\n\n\treturn 0;\n\nerror2:\n\tusb_set_intfdata(ctx->control, NULL);\n\tusb_set_intfdata(ctx->data, NULL);\n\tif (ctx->data != ctx->control)\n\t\tusb_driver_release_interface(driver, ctx->data);\nerror:\n\tcdc_ncm_free((struct cdc_ncm_ctx *)dev->data[0]);\n\tdev->data[0] = 0;\n\tdev_info(&intf->dev, \"bind() failure\\n\");\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(cdc_ncm_bind_common);\n\nvoid cdc_ncm_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tstruct usb_driver *driver = driver_of(intf);\n\n\tif (ctx == NULL)\n\t\treturn;\t\t \n\n\tatomic_set(&ctx->stop, 1);\n\n\thrtimer_cancel(&ctx->tx_timer);\n\n\ttasklet_kill(&ctx->bh);\n\n\t \n\tif (ctx->control == ctx->data)\n\t\tctx->data = NULL;\n\n\t \n\tif (intf == ctx->control && ctx->data) {\n\t\tusb_set_intfdata(ctx->data, NULL);\n\t\tusb_driver_release_interface(driver, ctx->data);\n\t\tctx->data = NULL;\n\n\t} else if (intf == ctx->data && ctx->control) {\n\t\tusb_set_intfdata(ctx->control, NULL);\n\t\tusb_driver_release_interface(driver, ctx->control);\n\t\tctx->control = NULL;\n\t}\n\n\tusb_set_intfdata(intf, NULL);\n\tcdc_ncm_free(ctx);\n}\nEXPORT_SYMBOL_GPL(cdc_ncm_unbind);\n\n \nu8 cdc_ncm_select_altsetting(struct usb_interface *intf)\n{\n\tstruct usb_host_interface *alt;\n\n\t \n\tif (intf->num_altsetting < 2)\n\t\treturn intf->cur_altsetting->desc.bAlternateSetting;\n\n\tif (prefer_mbim) {\n\t\talt = usb_altnum_to_altsetting(intf, CDC_NCM_COMM_ALTSETTING_MBIM);\n\t\tif (alt && cdc_ncm_comm_intf_is_mbim(alt))\n\t\t\treturn CDC_NCM_COMM_ALTSETTING_MBIM;\n\t}\n\treturn CDC_NCM_COMM_ALTSETTING_NCM;\n}\nEXPORT_SYMBOL_GPL(cdc_ncm_select_altsetting);\n\nstatic int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\t \n\tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n\t\treturn -ENODEV;\n\n\t \n\treturn cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n}\n\nstatic void cdc_ncm_align_tail(struct sk_buff *skb, size_t modulus, size_t remainder, size_t max)\n{\n\tsize_t align = ALIGN(skb->len, modulus) - skb->len + remainder;\n\n\tif (skb->len + align > max)\n\t\talign = max - skb->len;\n\tif (align && skb_tailroom(skb) >= align)\n\t\tskb_put_zero(skb, align);\n}\n\n \nstatic struct usb_cdc_ncm_ndp16 *cdc_ncm_ndp16(struct cdc_ncm_ctx *ctx, struct sk_buff *skb, __le32 sign, size_t reserve)\n{\n\tstruct usb_cdc_ncm_ndp16 *ndp16 = NULL;\n\tstruct usb_cdc_ncm_nth16 *nth16 = (void *)skb->data;\n\tsize_t ndpoffset = le16_to_cpu(nth16->wNdpIndex);\n\n\t \n\tif (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END) {\n\t\tif (ctx->delayed_ndp16->dwSignature == sign)\n\t\t\treturn ctx->delayed_ndp16;\n\n\t\t \n\t\telse if (ctx->delayed_ndp16->dwSignature)\n\t\t\treturn NULL;\n\t}\n\n\t \n\twhile (ndpoffset) {\n\t\tndp16 = (struct usb_cdc_ncm_ndp16 *)(skb->data + ndpoffset);\n\t\tif  (ndp16->dwSignature == sign)\n\t\t\treturn ndp16;\n\t\tndpoffset = le16_to_cpu(ndp16->wNextNdpIndex);\n\t}\n\n\t \n\tif (!(ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END))\n\t\tcdc_ncm_align_tail(skb, ctx->tx_ndp_modulus, 0, ctx->tx_curr_size);\n\n\t \n\tif ((ctx->tx_curr_size - skb->len - reserve) < ctx->max_ndp_size)\n\t\treturn NULL;\n\n\t \n\tif (ndp16)\n\t\tndp16->wNextNdpIndex = cpu_to_le16(skb->len);\n\telse\n\t\tnth16->wNdpIndex = cpu_to_le16(skb->len);\n\n\t \n\tif (!(ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END))\n\t\tndp16 = skb_put_zero(skb, ctx->max_ndp_size);\n\telse\n\t\tndp16 = ctx->delayed_ndp16;\n\n\tndp16->dwSignature = sign;\n\tndp16->wLength = cpu_to_le16(sizeof(struct usb_cdc_ncm_ndp16) + sizeof(struct usb_cdc_ncm_dpe16));\n\treturn ndp16;\n}\n\nstatic struct usb_cdc_ncm_ndp32 *cdc_ncm_ndp32(struct cdc_ncm_ctx *ctx, struct sk_buff *skb, __le32 sign, size_t reserve)\n{\n\tstruct usb_cdc_ncm_ndp32 *ndp32 = NULL;\n\tstruct usb_cdc_ncm_nth32 *nth32 = (void *)skb->data;\n\tsize_t ndpoffset = le32_to_cpu(nth32->dwNdpIndex);\n\n\t \n\tif (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END) {\n\t\tif (ctx->delayed_ndp32->dwSignature == sign)\n\t\t\treturn ctx->delayed_ndp32;\n\n\t\t \n\t\telse if (ctx->delayed_ndp32->dwSignature)\n\t\t\treturn NULL;\n\t}\n\n\t \n\twhile (ndpoffset) {\n\t\tndp32 = (struct usb_cdc_ncm_ndp32 *)(skb->data + ndpoffset);\n\t\tif  (ndp32->dwSignature == sign)\n\t\t\treturn ndp32;\n\t\tndpoffset = le32_to_cpu(ndp32->dwNextNdpIndex);\n\t}\n\n\t \n\tif (!(ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END))\n\t\tcdc_ncm_align_tail(skb, ctx->tx_ndp_modulus, 0, ctx->tx_curr_size);\n\n\t \n\tif ((ctx->tx_curr_size - skb->len - reserve) < ctx->max_ndp_size)\n\t\treturn NULL;\n\n\t \n\tif (ndp32)\n\t\tndp32->dwNextNdpIndex = cpu_to_le32(skb->len);\n\telse\n\t\tnth32->dwNdpIndex = cpu_to_le32(skb->len);\n\n\t \n\tif (!(ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END))\n\t\tndp32 = skb_put_zero(skb, ctx->max_ndp_size);\n\telse\n\t\tndp32 = ctx->delayed_ndp32;\n\n\tndp32->dwSignature = sign;\n\tndp32->wLength = cpu_to_le16(sizeof(struct usb_cdc_ncm_ndp32) + sizeof(struct usb_cdc_ncm_dpe32));\n\treturn ndp32;\n}\n\nstruct sk_buff *\ncdc_ncm_fill_tx_frame(struct usbnet *dev, struct sk_buff *skb, __le32 sign)\n{\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tunion {\n\t\tstruct usb_cdc_ncm_nth16 *nth16;\n\t\tstruct usb_cdc_ncm_nth32 *nth32;\n\t} nth;\n\tunion {\n\t\tstruct usb_cdc_ncm_ndp16 *ndp16;\n\t\tstruct usb_cdc_ncm_ndp32 *ndp32;\n\t} ndp;\n\tstruct sk_buff *skb_out;\n\tu16 n = 0, index, ndplen;\n\tu8 ready2send = 0;\n\tu32 delayed_ndp_size;\n\tsize_t padding_count;\n\n\t \n\tif (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END)\n\t\tdelayed_ndp_size = ctx->max_ndp_size +\n\t\t\tmax_t(u32,\n\t\t\t      ctx->tx_ndp_modulus,\n\t\t\t      ctx->tx_modulus + ctx->tx_remainder) - 1;\n\telse\n\t\tdelayed_ndp_size = 0;\n\n\t \n\tif (skb != NULL) {\n\t\tswap(skb, ctx->tx_rem_skb);\n\t\tswap(sign, ctx->tx_rem_sign);\n\t} else {\n\t\tready2send = 1;\n\t}\n\n\t \n\tskb_out = ctx->tx_curr_skb;\n\n\t \n\tif (!skb_out) {\n\t\tif (ctx->tx_low_mem_val == 0) {\n\t\t\tctx->tx_curr_size = ctx->tx_max;\n\t\t\tskb_out = alloc_skb(ctx->tx_curr_size, GFP_ATOMIC);\n\t\t\t \n\t\t\tif (skb_out == NULL) {\n\t\t\t\t \n\t\t\t\tif (ctx->tx_curr_size == USB_CDC_NCM_NTB_MIN_OUT_SIZE)\n\t\t\t\t\tgoto alloc_failed;\n\t\t\t\tctx->tx_low_mem_max_cnt = min(ctx->tx_low_mem_max_cnt + 1,\n\t\t\t\t\t\t\t      (unsigned)CDC_NCM_LOW_MEM_MAX_CNT);\n\t\t\t\tctx->tx_low_mem_val = ctx->tx_low_mem_max_cnt;\n\t\t\t}\n\t\t}\n\t\tif (skb_out == NULL) {\n\t\t\t \n\t\t\tif (skb)\n\t\t\t\tctx->tx_curr_size = max(skb->len,\n\t\t\t\t\t(u32)USB_CDC_NCM_NTB_MIN_OUT_SIZE);\n\t\t\telse\n\t\t\t\tctx->tx_curr_size = USB_CDC_NCM_NTB_MIN_OUT_SIZE;\n\t\t\tskb_out = alloc_skb(ctx->tx_curr_size, GFP_ATOMIC);\n\n\t\t\t \n\t\t\tif (!skb_out)\n\t\t\t\tgoto alloc_failed;\n\t\t\tctx->tx_low_mem_val--;\n\t\t}\n\t\tif (ctx->is_ndp16) {\n\t\t\t \n\t\t\tnth.nth16 = skb_put_zero(skb_out, sizeof(struct usb_cdc_ncm_nth16));\n\t\t\tnth.nth16->dwSignature = cpu_to_le32(USB_CDC_NCM_NTH16_SIGN);\n\t\t\tnth.nth16->wHeaderLength = cpu_to_le16(sizeof(struct usb_cdc_ncm_nth16));\n\t\t\tnth.nth16->wSequence = cpu_to_le16(ctx->tx_seq++);\n\t\t} else {\n\t\t\t \n\t\t\tnth.nth32 = skb_put_zero(skb_out, sizeof(struct usb_cdc_ncm_nth32));\n\t\t\tnth.nth32->dwSignature = cpu_to_le32(USB_CDC_NCM_NTH32_SIGN);\n\t\t\tnth.nth32->wHeaderLength = cpu_to_le16(sizeof(struct usb_cdc_ncm_nth32));\n\t\t\tnth.nth32->wSequence = cpu_to_le16(ctx->tx_seq++);\n\t\t}\n\n\t\t \n\t\tctx->tx_curr_frame_num = 0;\n\n\t\t \n\t\tctx->tx_curr_frame_payload = 0;\n\t}\n\n\tfor (n = ctx->tx_curr_frame_num; n < ctx->tx_max_datagrams; n++) {\n\t\t \n\t\tif (skb == NULL) {\n\t\t\tskb = ctx->tx_rem_skb;\n\t\t\tsign = ctx->tx_rem_sign;\n\t\t\tctx->tx_rem_skb = NULL;\n\n\t\t\t \n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ctx->is_ndp16)\n\t\t\tndp.ndp16 = cdc_ncm_ndp16(ctx, skb_out, sign, skb->len + ctx->tx_modulus + ctx->tx_remainder);\n\t\telse\n\t\t\tndp.ndp32 = cdc_ncm_ndp32(ctx, skb_out, sign, skb->len + ctx->tx_modulus + ctx->tx_remainder);\n\n\t\t \n\t\tcdc_ncm_align_tail(skb_out,  ctx->tx_modulus, ctx->tx_remainder, ctx->tx_curr_size);\n\n\t\t \n\t\tif ((ctx->is_ndp16 && !ndp.ndp16) || (!ctx->is_ndp16 && !ndp.ndp32) ||\n\t\t    skb_out->len + skb->len + delayed_ndp_size > ctx->tx_curr_size) {\n\t\t\tif (n == 0) {\n\t\t\t\t \n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tskb = NULL;\n\t\t\t\tdev->net->stats.tx_dropped++;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (ctx->tx_rem_skb != NULL) {\n\t\t\t\t\tdev_kfree_skb_any(ctx->tx_rem_skb);\n\t\t\t\t\tdev->net->stats.tx_dropped++;\n\t\t\t\t}\n\t\t\t\tctx->tx_rem_skb = skb;\n\t\t\t\tctx->tx_rem_sign = sign;\n\t\t\t\tskb = NULL;\n\t\t\t\tready2send = 1;\n\t\t\t\tctx->tx_reason_ntb_full++;\t \n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ctx->is_ndp16) {\n\t\t\tndplen = le16_to_cpu(ndp.ndp16->wLength);\n\t\t\tindex = (ndplen - sizeof(struct usb_cdc_ncm_ndp16)) / sizeof(struct usb_cdc_ncm_dpe16) - 1;\n\n\t\t\t \n\t\t\tndp.ndp16->dpe16[index].wDatagramLength = cpu_to_le16(skb->len);\n\t\t\tndp.ndp16->dpe16[index].wDatagramIndex = cpu_to_le16(skb_out->len);\n\t\t\tndp.ndp16->wLength = cpu_to_le16(ndplen + sizeof(struct usb_cdc_ncm_dpe16));\n\t\t} else {\n\t\t\tndplen = le16_to_cpu(ndp.ndp32->wLength);\n\t\t\tindex = (ndplen - sizeof(struct usb_cdc_ncm_ndp32)) / sizeof(struct usb_cdc_ncm_dpe32) - 1;\n\n\t\t\tndp.ndp32->dpe32[index].dwDatagramLength = cpu_to_le32(skb->len);\n\t\t\tndp.ndp32->dpe32[index].dwDatagramIndex = cpu_to_le32(skb_out->len);\n\t\t\tndp.ndp32->wLength = cpu_to_le16(ndplen + sizeof(struct usb_cdc_ncm_dpe32));\n\t\t}\n\t\tskb_put_data(skb_out, skb->data, skb->len);\n\t\tctx->tx_curr_frame_payload += skb->len;\t \n\t\tdev_kfree_skb_any(skb);\n\t\tskb = NULL;\n\n\t\t \n\t\tif (index >= CDC_NCM_DPT_DATAGRAMS_MAX) {\n\t\t\tready2send = 1;\n\t\t\tctx->tx_reason_ndp_full++;\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (skb != NULL) {\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = NULL;\n\t\tdev->net->stats.tx_dropped++;\n\t}\n\n\tctx->tx_curr_frame_num = n;\n\n\tif (n == 0) {\n\t\t \n\t\t \n\t\tctx->tx_curr_skb = skb_out;\n\t\tgoto exit_no_skb;\n\n\t} else if ((n < ctx->tx_max_datagrams) && (ready2send == 0) && (ctx->timer_interval > 0)) {\n\t\t \n\t\t \n\t\tctx->tx_curr_skb = skb_out;\n\t\t \n\t\tif (n < CDC_NCM_RESTART_TIMER_DATAGRAM_CNT)\n\t\t\tctx->tx_timer_pending = CDC_NCM_TIMER_PENDING_CNT;\n\t\tgoto exit_no_skb;\n\n\t} else {\n\t\tif (n == ctx->tx_max_datagrams)\n\t\t\tctx->tx_reason_max_datagram++;\t \n\t\t \n\t\t \n\t}\n\n\t \n\tif (ctx->drvflags & CDC_NCM_FLAG_NDP_TO_END) {\n\t\tif (ctx->is_ndp16) {\n\t\t\tnth.nth16 = (struct usb_cdc_ncm_nth16 *)skb_out->data;\n\t\t\tcdc_ncm_align_tail(skb_out, ctx->tx_ndp_modulus, 0, ctx->tx_curr_size - ctx->max_ndp_size);\n\t\t\tnth.nth16->wNdpIndex = cpu_to_le16(skb_out->len);\n\t\t\tskb_put_data(skb_out, ctx->delayed_ndp16, ctx->max_ndp_size);\n\n\t\t\t \n\t\t\tndp.ndp16 = memset(ctx->delayed_ndp16, 0, ctx->max_ndp_size);\n\t\t} else {\n\t\t\tnth.nth32 = (struct usb_cdc_ncm_nth32 *)skb_out->data;\n\t\t\tcdc_ncm_align_tail(skb_out, ctx->tx_ndp_modulus, 0, ctx->tx_curr_size - ctx->max_ndp_size);\n\t\t\tnth.nth32->dwNdpIndex = cpu_to_le32(skb_out->len);\n\t\t\tskb_put_data(skb_out, ctx->delayed_ndp32, ctx->max_ndp_size);\n\n\t\t\tndp.ndp32 = memset(ctx->delayed_ndp32, 0, ctx->max_ndp_size);\n\t\t}\n\t}\n\n\t \n\tif (!(dev->driver_info->flags & FLAG_SEND_ZLP) &&\n\t    skb_out->len > ctx->min_tx_pkt) {\n\t\tpadding_count = ctx->tx_curr_size - skb_out->len;\n\t\tif (!WARN_ON(padding_count > ctx->tx_curr_size))\n\t\t\tskb_put_zero(skb_out, padding_count);\n\t} else if (skb_out->len < ctx->tx_curr_size &&\n\t\t   (skb_out->len % dev->maxpacket) == 0) {\n\t\tskb_put_u8(skb_out, 0);\t \n\t}\n\n\t \n\tif (ctx->is_ndp16) {\n\t\tnth.nth16 = (struct usb_cdc_ncm_nth16 *)skb_out->data;\n\t\tnth.nth16->wBlockLength = cpu_to_le16(skb_out->len);\n\t} else {\n\t\tnth.nth32 = (struct usb_cdc_ncm_nth32 *)skb_out->data;\n\t\tnth.nth32->dwBlockLength = cpu_to_le32(skb_out->len);\n\t}\n\n\t \n\tctx->tx_curr_skb = NULL;\n\n\t \n\tctx->tx_overhead += skb_out->len - ctx->tx_curr_frame_payload;\n\tctx->tx_ntbs++;\n\n\t \n\tusbnet_set_skb_tx_stats(skb_out, n,\n\t\t\t\t(long)ctx->tx_curr_frame_payload - skb_out->len);\n\n\treturn skb_out;\n\nalloc_failed:\n\tif (skb) {\n\t\tdev_kfree_skb_any(skb);\n\t\tdev->net->stats.tx_dropped++;\n\t}\nexit_no_skb:\n\t \n\tif (ctx->tx_curr_skb != NULL && n > 0)\n\t\tcdc_ncm_tx_timeout_start(ctx);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cdc_ncm_fill_tx_frame);\n\nstatic void cdc_ncm_tx_timeout_start(struct cdc_ncm_ctx *ctx)\n{\n\t \n\tif (!(hrtimer_active(&ctx->tx_timer) || atomic_read(&ctx->stop)))\n\t\thrtimer_start(&ctx->tx_timer,\n\t\t\t\tctx->timer_interval,\n\t\t\t\tHRTIMER_MODE_REL);\n}\n\nstatic enum hrtimer_restart cdc_ncm_tx_timer_cb(struct hrtimer *timer)\n{\n\tstruct cdc_ncm_ctx *ctx =\n\t\t\tcontainer_of(timer, struct cdc_ncm_ctx, tx_timer);\n\n\tif (!atomic_read(&ctx->stop))\n\t\ttasklet_schedule(&ctx->bh);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void cdc_ncm_txpath_bh(struct tasklet_struct *t)\n{\n\tstruct cdc_ncm_ctx *ctx = from_tasklet(ctx, t, bh);\n\tstruct usbnet *dev = ctx->dev;\n\n\tspin_lock(&ctx->mtx);\n\tif (ctx->tx_timer_pending != 0) {\n\t\tctx->tx_timer_pending--;\n\t\tcdc_ncm_tx_timeout_start(ctx);\n\t\tspin_unlock(&ctx->mtx);\n\t} else if (dev->net != NULL) {\n\t\tctx->tx_reason_timeout++;\t \n\t\tspin_unlock(&ctx->mtx);\n\t\tnetif_tx_lock_bh(dev->net);\n\t\tusbnet_start_xmit(NULL, dev->net);\n\t\tnetif_tx_unlock_bh(dev->net);\n\t} else {\n\t\tspin_unlock(&ctx->mtx);\n\t}\n}\n\nstruct sk_buff *\ncdc_ncm_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\n{\n\tstruct sk_buff *skb_out;\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\n\t \n\tif (ctx == NULL)\n\t\tgoto error;\n\n\tspin_lock_bh(&ctx->mtx);\n\n\tif (ctx->is_ndp16)\n\t\tskb_out = cdc_ncm_fill_tx_frame(dev, skb, cpu_to_le32(USB_CDC_NCM_NDP16_NOCRC_SIGN));\n\telse\n\t\tskb_out = cdc_ncm_fill_tx_frame(dev, skb, cpu_to_le32(USB_CDC_NCM_NDP32_NOCRC_SIGN));\n\n\tspin_unlock_bh(&ctx->mtx);\n\treturn skb_out;\n\nerror:\n\tif (skb != NULL)\n\t\tdev_kfree_skb_any(skb);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cdc_ncm_tx_fixup);\n\n \nint cdc_ncm_rx_verify_nth16(struct cdc_ncm_ctx *ctx, struct sk_buff *skb_in)\n{\n\tstruct usbnet *dev = netdev_priv(skb_in->dev);\n\tstruct usb_cdc_ncm_nth16 *nth16;\n\tint len;\n\tint ret = -EINVAL;\n\n\tif (ctx == NULL)\n\t\tgoto error;\n\n\tif (skb_in->len < (sizeof(struct usb_cdc_ncm_nth16) +\n\t\t\t\t\tsizeof(struct usb_cdc_ncm_ndp16))) {\n\t\tnetif_dbg(dev, rx_err, dev->net, \"frame too short\\n\");\n\t\tgoto error;\n\t}\n\n\tnth16 = (struct usb_cdc_ncm_nth16 *)skb_in->data;\n\n\tif (nth16->dwSignature != cpu_to_le32(USB_CDC_NCM_NTH16_SIGN)) {\n\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t  \"invalid NTH16 signature <%#010x>\\n\",\n\t\t\t  le32_to_cpu(nth16->dwSignature));\n\t\tgoto error;\n\t}\n\n\tlen = le16_to_cpu(nth16->wBlockLength);\n\tif (len > ctx->rx_max) {\n\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t  \"unsupported NTB block length %u/%u\\n\", len,\n\t\t\t  ctx->rx_max);\n\t\tgoto error;\n\t}\n\n\tif ((ctx->rx_seq + 1) != le16_to_cpu(nth16->wSequence) &&\n\t    (ctx->rx_seq || le16_to_cpu(nth16->wSequence)) &&\n\t    !((ctx->rx_seq == 0xffff) && !le16_to_cpu(nth16->wSequence))) {\n\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t  \"sequence number glitch prev=%d curr=%d\\n\",\n\t\t\t  ctx->rx_seq, le16_to_cpu(nth16->wSequence));\n\t}\n\tctx->rx_seq = le16_to_cpu(nth16->wSequence);\n\n\tret = le16_to_cpu(nth16->wNdpIndex);\nerror:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cdc_ncm_rx_verify_nth16);\n\nint cdc_ncm_rx_verify_nth32(struct cdc_ncm_ctx *ctx, struct sk_buff *skb_in)\n{\n\tstruct usbnet *dev = netdev_priv(skb_in->dev);\n\tstruct usb_cdc_ncm_nth32 *nth32;\n\tint len;\n\tint ret = -EINVAL;\n\n\tif (ctx == NULL)\n\t\tgoto error;\n\n\tif (skb_in->len < (sizeof(struct usb_cdc_ncm_nth32) +\n\t\t\t\t\tsizeof(struct usb_cdc_ncm_ndp32))) {\n\t\tnetif_dbg(dev, rx_err, dev->net, \"frame too short\\n\");\n\t\tgoto error;\n\t}\n\n\tnth32 = (struct usb_cdc_ncm_nth32 *)skb_in->data;\n\n\tif (nth32->dwSignature != cpu_to_le32(USB_CDC_NCM_NTH32_SIGN)) {\n\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t  \"invalid NTH32 signature <%#010x>\\n\",\n\t\t\t  le32_to_cpu(nth32->dwSignature));\n\t\tgoto error;\n\t}\n\n\tlen = le32_to_cpu(nth32->dwBlockLength);\n\tif (len > ctx->rx_max) {\n\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t  \"unsupported NTB block length %u/%u\\n\", len,\n\t\t\t  ctx->rx_max);\n\t\tgoto error;\n\t}\n\n\tif ((ctx->rx_seq + 1) != le16_to_cpu(nth32->wSequence) &&\n\t    (ctx->rx_seq || le16_to_cpu(nth32->wSequence)) &&\n\t    !((ctx->rx_seq == 0xffff) && !le16_to_cpu(nth32->wSequence))) {\n\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t  \"sequence number glitch prev=%d curr=%d\\n\",\n\t\t\t  ctx->rx_seq, le16_to_cpu(nth32->wSequence));\n\t}\n\tctx->rx_seq = le16_to_cpu(nth32->wSequence);\n\n\tret = le32_to_cpu(nth32->dwNdpIndex);\nerror:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cdc_ncm_rx_verify_nth32);\n\n \nint cdc_ncm_rx_verify_ndp16(struct sk_buff *skb_in, int ndpoffset)\n{\n\tstruct usbnet *dev = netdev_priv(skb_in->dev);\n\tstruct usb_cdc_ncm_ndp16 *ndp16;\n\tint ret = -EINVAL;\n\n\tif ((ndpoffset + sizeof(struct usb_cdc_ncm_ndp16)) > skb_in->len) {\n\t\tnetif_dbg(dev, rx_err, dev->net, \"invalid NDP offset  <%u>\\n\",\n\t\t\t  ndpoffset);\n\t\tgoto error;\n\t}\n\tndp16 = (struct usb_cdc_ncm_ndp16 *)(skb_in->data + ndpoffset);\n\n\tif (le16_to_cpu(ndp16->wLength) < USB_CDC_NCM_NDP16_LENGTH_MIN) {\n\t\tnetif_dbg(dev, rx_err, dev->net, \"invalid DPT16 length <%u>\\n\",\n\t\t\t  le16_to_cpu(ndp16->wLength));\n\t\tgoto error;\n\t}\n\n\tret = ((le16_to_cpu(ndp16->wLength) -\n\t\t\t\t\tsizeof(struct usb_cdc_ncm_ndp16)) /\n\t\t\t\t\tsizeof(struct usb_cdc_ncm_dpe16));\n\tret--;  \n\n\tif ((sizeof(struct usb_cdc_ncm_ndp16) +\n\t     ret * (sizeof(struct usb_cdc_ncm_dpe16))) > skb_in->len) {\n\t\tnetif_dbg(dev, rx_err, dev->net, \"Invalid nframes = %d\\n\", ret);\n\t\tret = -EINVAL;\n\t}\n\nerror:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cdc_ncm_rx_verify_ndp16);\n\n \nint cdc_ncm_rx_verify_ndp32(struct sk_buff *skb_in, int ndpoffset)\n{\n\tstruct usbnet *dev = netdev_priv(skb_in->dev);\n\tstruct usb_cdc_ncm_ndp32 *ndp32;\n\tint ret = -EINVAL;\n\n\tif ((ndpoffset + sizeof(struct usb_cdc_ncm_ndp32)) > skb_in->len) {\n\t\tnetif_dbg(dev, rx_err, dev->net, \"invalid NDP offset  <%u>\\n\",\n\t\t\t  ndpoffset);\n\t\tgoto error;\n\t}\n\tndp32 = (struct usb_cdc_ncm_ndp32 *)(skb_in->data + ndpoffset);\n\n\tif (le16_to_cpu(ndp32->wLength) < USB_CDC_NCM_NDP32_LENGTH_MIN) {\n\t\tnetif_dbg(dev, rx_err, dev->net, \"invalid DPT32 length <%u>\\n\",\n\t\t\t  le16_to_cpu(ndp32->wLength));\n\t\tgoto error;\n\t}\n\n\tret = ((le16_to_cpu(ndp32->wLength) -\n\t\t\t\t\tsizeof(struct usb_cdc_ncm_ndp32)) /\n\t\t\t\t\tsizeof(struct usb_cdc_ncm_dpe32));\n\tret--;  \n\n\tif ((sizeof(struct usb_cdc_ncm_ndp32) +\n\t     ret * (sizeof(struct usb_cdc_ncm_dpe32))) > skb_in->len) {\n\t\tnetif_dbg(dev, rx_err, dev->net, \"Invalid nframes = %d\\n\", ret);\n\t\tret = -EINVAL;\n\t}\n\nerror:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cdc_ncm_rx_verify_ndp32);\n\nint cdc_ncm_rx_fixup(struct usbnet *dev, struct sk_buff *skb_in)\n{\n\tstruct sk_buff *skb;\n\tstruct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n\tunsigned int len;\n\tint nframes;\n\tint x;\n\tunsigned int offset;\n\tunion {\n\t\tstruct usb_cdc_ncm_ndp16 *ndp16;\n\t\tstruct usb_cdc_ncm_ndp32 *ndp32;\n\t} ndp;\n\tunion {\n\t\tstruct usb_cdc_ncm_dpe16 *dpe16;\n\t\tstruct usb_cdc_ncm_dpe32 *dpe32;\n\t} dpe;\n\n\tint ndpoffset;\n\tint loopcount = 50;  \n\tu32 payload = 0;\n\n\tif (ctx->is_ndp16)\n\t\tndpoffset = cdc_ncm_rx_verify_nth16(ctx, skb_in);\n\telse\n\t\tndpoffset = cdc_ncm_rx_verify_nth32(ctx, skb_in);\n\n\tif (ndpoffset < 0)\n\t\tgoto error;\n\nnext_ndp:\n\tif (ctx->is_ndp16) {\n\t\tnframes = cdc_ncm_rx_verify_ndp16(skb_in, ndpoffset);\n\t\tif (nframes < 0)\n\t\t\tgoto error;\n\n\t\tndp.ndp16 = (struct usb_cdc_ncm_ndp16 *)(skb_in->data + ndpoffset);\n\n\t\tif (ndp.ndp16->dwSignature != cpu_to_le32(USB_CDC_NCM_NDP16_NOCRC_SIGN)) {\n\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t  \"invalid DPT16 signature <%#010x>\\n\",\n\t\t\t\t  le32_to_cpu(ndp.ndp16->dwSignature));\n\t\t\tgoto err_ndp;\n\t\t}\n\t\tdpe.dpe16 = ndp.ndp16->dpe16;\n\t} else {\n\t\tnframes = cdc_ncm_rx_verify_ndp32(skb_in, ndpoffset);\n\t\tif (nframes < 0)\n\t\t\tgoto error;\n\n\t\tndp.ndp32 = (struct usb_cdc_ncm_ndp32 *)(skb_in->data + ndpoffset);\n\n\t\tif (ndp.ndp32->dwSignature != cpu_to_le32(USB_CDC_NCM_NDP32_NOCRC_SIGN)) {\n\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t  \"invalid DPT32 signature <%#010x>\\n\",\n\t\t\t\t  le32_to_cpu(ndp.ndp32->dwSignature));\n\t\t\tgoto err_ndp;\n\t\t}\n\t\tdpe.dpe32 = ndp.ndp32->dpe32;\n\t}\n\n\tfor (x = 0; x < nframes; x++) {\n\t\tif (ctx->is_ndp16) {\n\t\t\toffset = le16_to_cpu(dpe.dpe16->wDatagramIndex);\n\t\t\tlen = le16_to_cpu(dpe.dpe16->wDatagramLength);\n\t\t} else {\n\t\t\toffset = le32_to_cpu(dpe.dpe32->dwDatagramIndex);\n\t\t\tlen = le32_to_cpu(dpe.dpe32->dwDatagramLength);\n\t\t}\n\n\t\t \n\t\tif ((offset == 0) || (len == 0)) {\n\t\t\tif (!x)\n\t\t\t\tgoto err_ndp;  \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif ((offset > skb_in->len) || (len > skb_in->len - offset) ||\n\t\t\t\t(len > ctx->rx_max) || (len < ETH_HLEN)) {\n\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t  \"invalid frame detected (ignored) offset[%u]=%u, length=%u, skb=%p\\n\",\n\t\t\t\t  x, offset, len, skb_in);\n\t\t\tif (!x)\n\t\t\t\tgoto err_ndp;\n\t\t\tbreak;\n\n\t\t} else {\n\t\t\t \n\t\t\tskb = netdev_alloc_skb_ip_align(dev->net,  len);\n\t\t\tif (!skb)\n\t\t\t\tgoto error;\n\t\t\tskb_put_data(skb, skb_in->data + offset, len);\n\t\t\tusbnet_skb_return(dev, skb);\n\t\t\tpayload += len;\t \n\t\t}\n\n\t\tif (ctx->is_ndp16)\n\t\t\tdpe.dpe16++;\n\t\telse\n\t\t\tdpe.dpe32++;\n\t}\nerr_ndp:\n\t \n\tif (ctx->is_ndp16)\n\t\tndpoffset = le16_to_cpu(ndp.ndp16->wNextNdpIndex);\n\telse\n\t\tndpoffset = le32_to_cpu(ndp.ndp32->dwNextNdpIndex);\n\n\tif (ndpoffset && loopcount--)\n\t\tgoto next_ndp;\n\n\t \n\tctx->rx_overhead += skb_in->len - payload;\n\tctx->rx_ntbs++;\n\n\treturn 1;\nerror:\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cdc_ncm_rx_fixup);\n\nstatic void\ncdc_ncm_speed_change(struct usbnet *dev,\n\t\t     struct usb_cdc_speed_change *data)\n{\n\t \n\tdev->rx_speed = le32_to_cpu(data->DLBitRRate);\n\tdev->tx_speed = le32_to_cpu(data->ULBitRate);\n}\n\nstatic void cdc_ncm_status(struct usbnet *dev, struct urb *urb)\n{\n\tstruct usb_cdc_notification *event;\n\n\tif (urb->actual_length < sizeof(*event))\n\t\treturn;\n\n\t \n\tif (test_and_clear_bit(EVENT_STS_SPLIT, &dev->flags)) {\n\t\tcdc_ncm_speed_change(dev,\n\t\t      (struct usb_cdc_speed_change *)urb->transfer_buffer);\n\t\treturn;\n\t}\n\n\tevent = urb->transfer_buffer;\n\n\tswitch (event->bNotificationType) {\n\tcase USB_CDC_NOTIFY_NETWORK_CONNECTION:\n\t\t \n\t\t \n\t\tif (netif_carrier_ok(dev->net) != !!event->wValue)\n\t\t\tusbnet_link_change(dev, !!event->wValue, 0);\n\t\tbreak;\n\n\tcase USB_CDC_NOTIFY_SPEED_CHANGE:\n\t\tif (urb->actual_length < (sizeof(*event) +\n\t\t\t\t\tsizeof(struct usb_cdc_speed_change)))\n\t\t\tset_bit(EVENT_STS_SPLIT, &dev->flags);\n\t\telse\n\t\t\tcdc_ncm_speed_change(dev,\n\t\t\t\t\t     (struct usb_cdc_speed_change *)&event[1]);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\"NCM: unexpected notification 0x%02x!\\n\",\n\t\t\tevent->bNotificationType);\n\t\tbreak;\n\t}\n}\n\nstatic const struct driver_info cdc_ncm_info = {\n\t.description = \"CDC NCM (NO ZLP)\",\n\t.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET\n\t\t\t| FLAG_LINK_INTR | FLAG_ETHER,\n\t.bind = cdc_ncm_bind,\n\t.unbind = cdc_ncm_unbind,\n\t.manage_power = usbnet_manage_power,\n\t.status = cdc_ncm_status,\n\t.rx_fixup = cdc_ncm_rx_fixup,\n\t.tx_fixup = cdc_ncm_tx_fixup,\n\t.set_rx_mode = usbnet_cdc_update_filter,\n};\n\n \nstatic const struct driver_info cdc_ncm_zlp_info = {\n\t.description = \"CDC NCM (SEND ZLP)\",\n\t.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET\n\t\t\t| FLAG_LINK_INTR | FLAG_ETHER | FLAG_SEND_ZLP,\n\t.bind = cdc_ncm_bind,\n\t.unbind = cdc_ncm_unbind,\n\t.manage_power = usbnet_manage_power,\n\t.status = cdc_ncm_status,\n\t.rx_fixup = cdc_ncm_rx_fixup,\n\t.tx_fixup = cdc_ncm_tx_fixup,\n\t.set_rx_mode = usbnet_cdc_update_filter,\n};\n\n \nstatic const struct driver_info wwan_info = {\n\t.description = \"Mobile Broadband Network Device\",\n\t.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET\n\t\t\t| FLAG_LINK_INTR | FLAG_WWAN,\n\t.bind = cdc_ncm_bind,\n\t.unbind = cdc_ncm_unbind,\n\t.manage_power = usbnet_manage_power,\n\t.status = cdc_ncm_status,\n\t.rx_fixup = cdc_ncm_rx_fixup,\n\t.tx_fixup = cdc_ncm_tx_fixup,\n\t.set_rx_mode = usbnet_cdc_update_filter,\n};\n\n \nstatic const struct driver_info wwan_noarp_info = {\n\t.description = \"Mobile Broadband Network Device (NO ARP)\",\n\t.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET\n\t\t\t| FLAG_LINK_INTR | FLAG_WWAN | FLAG_NOARP,\n\t.bind = cdc_ncm_bind,\n\t.unbind = cdc_ncm_unbind,\n\t.manage_power = usbnet_manage_power,\n\t.status = cdc_ncm_status,\n\t.rx_fixup = cdc_ncm_rx_fixup,\n\t.tx_fixup = cdc_ncm_tx_fixup,\n\t.set_rx_mode = usbnet_cdc_update_filter,\n};\n\nstatic const struct usb_device_id cdc_devs[] = {\n\t \n\t{ .match_flags = USB_DEVICE_ID_MATCH_INT_INFO\n\t\t| USB_DEVICE_ID_MATCH_VENDOR,\n\t  .idVendor = 0x0bdb,\n\t  .bInterfaceClass = USB_CLASS_COMM,\n\t  .bInterfaceSubClass = USB_CDC_SUBCLASS_NCM,\n\t  .bInterfaceProtocol = USB_CDC_PROTO_NONE,\n\t  .driver_info = (unsigned long) &wwan_info,\n\t},\n\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1bc7, 0x0036,\n\t\tUSB_CLASS_COMM,\n\t\tUSB_CDC_SUBCLASS_NCM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&wwan_noarp_info,\n\t},\n\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x413c, 0x81bb,\n\t\tUSB_CLASS_COMM,\n\t\tUSB_CDC_SUBCLASS_NCM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&wwan_noarp_info,\n\t},\n\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x413c, 0x81bc,\n\t\tUSB_CLASS_COMM,\n\t\tUSB_CDC_SUBCLASS_NCM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&wwan_noarp_info,\n\t},\n\n\t \n\t{ .match_flags = USB_DEVICE_ID_MATCH_INT_INFO\n\t\t| USB_DEVICE_ID_MATCH_VENDOR,\n\t  .idVendor = 0x413c,\n\t  .bInterfaceClass = USB_CLASS_COMM,\n\t  .bInterfaceSubClass = USB_CDC_SUBCLASS_NCM,\n\t  .bInterfaceProtocol = USB_CDC_PROTO_NONE,\n\t  .driver_info = (unsigned long) &wwan_info,\n\t},\n\n\t \n\t{ .match_flags = USB_DEVICE_ID_MATCH_INT_INFO\n\t\t| USB_DEVICE_ID_MATCH_VENDOR,\n\t  .idVendor = 0x0930,\n\t  .bInterfaceClass = USB_CLASS_COMM,\n\t  .bInterfaceSubClass = USB_CDC_SUBCLASS_NCM,\n\t  .bInterfaceProtocol = USB_CDC_PROTO_NONE,\n\t  .driver_info = (unsigned long) &wwan_info,\n\t},\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x12d1,\n\t\t\t\t\tUSB_CLASS_COMM,\n\t\t\t\t\tUSB_CDC_SUBCLASS_NCM,\n\t\t\t\t\tUSB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&wwan_info,\n\t},\n\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1519, 0x0443,\n\t\tUSB_CLASS_COMM,\n\t\tUSB_CDC_SUBCLASS_NCM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&wwan_noarp_info,\n\t},\n\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1546, 0x1010,\n\t\tUSB_CLASS_COMM,\n\t\tUSB_CDC_SUBCLASS_NCM, USB_CDC_PROTO_NONE),\n\t  .driver_info = (unsigned long)&wwan_info,\n\t},\n\n\t \n\t{ .match_flags = USB_DEVICE_ID_MATCH_INT_INFO\n\t\t| USB_DEVICE_ID_MATCH_VENDOR,\n\t  .idVendor = 0x17e9,\n\t  .bInterfaceClass = USB_CLASS_COMM,\n\t  .bInterfaceSubClass = USB_CDC_SUBCLASS_NCM,\n\t  .bInterfaceProtocol = USB_CDC_PROTO_NONE,\n\t  .driver_info = (unsigned long)&cdc_ncm_zlp_info,\n\t},\n\n\t \n\t{ USB_INTERFACE_INFO(USB_CLASS_COMM,\n\t\tUSB_CDC_SUBCLASS_NCM, USB_CDC_PROTO_NONE),\n\t\t.driver_info = (unsigned long)&cdc_ncm_info,\n\t},\n\t{\n\t},\n};\nMODULE_DEVICE_TABLE(usb, cdc_devs);\n\nstatic struct usb_driver cdc_ncm_driver = {\n\t.name = \"cdc_ncm\",\n\t.id_table = cdc_devs,\n\t.probe = usbnet_probe,\n\t.disconnect = usbnet_disconnect,\n\t.suspend = usbnet_suspend,\n\t.resume = usbnet_resume,\n\t.reset_resume =\tusbnet_resume,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(cdc_ncm_driver);\n\nMODULE_AUTHOR(\"Hans Petter Selasky\");\nMODULE_DESCRIPTION(\"USB CDC NCM host driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}