{
  "module_name": "hso.c",
  "hash_id": "3060e6195b17a366603dd85e62ce713f661e708c2ee8fa38c68604509fd339f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/hso.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/module.h>\n#include <linux/ethtool.h>\n#include <linux/usb.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/kmod.h>\n#include <linux/rfkill.h>\n#include <linux/ip.h>\n#include <linux/uaccess.h>\n#include <linux/usb/cdc.h>\n#include <net/arp.h>\n#include <asm/byteorder.h>\n#include <linux/serial_core.h>\n#include <linux/serial.h>\n\n\n#define MOD_AUTHOR\t\t\t\"Option Wireless\"\n#define MOD_DESCRIPTION\t\t\t\"USB High Speed Option driver\"\n\n#define HSO_MAX_NET_DEVICES\t\t10\n#define HSO__MAX_MTU\t\t\t2048\n#define DEFAULT_MTU\t\t\t1500\n#define DEFAULT_MRU\t\t\t1500\n\n#define CTRL_URB_RX_SIZE\t\t1024\n#define CTRL_URB_TX_SIZE\t\t64\n\n#define BULK_URB_RX_SIZE\t\t4096\n#define BULK_URB_TX_SIZE\t\t8192\n\n#define MUX_BULK_RX_BUF_SIZE\t\tHSO__MAX_MTU\n#define MUX_BULK_TX_BUF_SIZE\t\tHSO__MAX_MTU\n#define MUX_BULK_RX_BUF_COUNT\t\t4\n#define USB_TYPE_OPTION_VENDOR\t\t0x20\n\n \n \n#define HSO_NET_RUNNING\t\t\t0\n\n#define\tHSO_NET_TX_TIMEOUT\t\t(HZ*10)\n\n#define HSO_SERIAL_MAGIC\t\t0x48534f31\n\n \n#define HSO_SERIAL_TTY_MINORS\t\t256\n\n#define MAX_RX_URBS\t\t\t2\n\n \n \n \n#define hso_dbg(lvl, fmt, ...)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif ((lvl) & debug)\t\t\t\t\t\t\\\n\t\tpr_info(\"[%d:%s] \" fmt,\t\t\t\t\t\\\n\t\t\t__LINE__, __func__, ##__VA_ARGS__);\t\t\\\n} while (0)\n\n \n \n \nenum pkt_parse_state {\n\tWAIT_IP,\n\tWAIT_DATA,\n\tWAIT_SYNC\n};\n\n \n \n \n\nstruct hso_shared_int {\n\tstruct usb_endpoint_descriptor *intr_endp;\n\tvoid *shared_intr_buf;\n\tstruct urb *shared_intr_urb;\n\tstruct usb_device *usb;\n\tint use_count;\n\tint ref_count;\n\tstruct mutex shared_int_lock;\n};\n\nstruct hso_net {\n\tstruct hso_device *parent;\n\tstruct net_device *net;\n\tstruct rfkill *rfkill;\n\tchar name[24];\n\n\tstruct usb_endpoint_descriptor *in_endp;\n\tstruct usb_endpoint_descriptor *out_endp;\n\n\tstruct urb *mux_bulk_rx_urb_pool[MUX_BULK_RX_BUF_COUNT];\n\tstruct urb *mux_bulk_tx_urb;\n\tvoid *mux_bulk_rx_buf_pool[MUX_BULK_RX_BUF_COUNT];\n\tvoid *mux_bulk_tx_buf;\n\n\tstruct sk_buff *skb_rx_buf;\n\tstruct sk_buff *skb_tx_buf;\n\n\tenum pkt_parse_state rx_parse_state;\n\tspinlock_t net_lock;\n\n\tunsigned short rx_buf_size;\n\tunsigned short rx_buf_missing;\n\tstruct iphdr rx_ip_hdr;\n\n\tunsigned long flags;\n};\n\nenum rx_ctrl_state{\n\tRX_IDLE,\n\tRX_SENT,\n\tRX_PENDING\n};\n\n#define BM_REQUEST_TYPE (0xa1)\n#define B_NOTIFICATION  (0x20)\n#define W_VALUE         (0x0)\n#define W_LENGTH        (0x2)\n\n#define B_OVERRUN       (0x1<<6)\n#define B_PARITY        (0x1<<5)\n#define B_FRAMING       (0x1<<4)\n#define B_RING_SIGNAL   (0x1<<3)\n#define B_BREAK         (0x1<<2)\n#define B_TX_CARRIER    (0x1<<1)\n#define B_RX_CARRIER    (0x1<<0)\n\nstruct hso_serial_state_notification {\n\tu8 bmRequestType;\n\tu8 bNotification;\n\tu16 wValue;\n\tu16 wIndex;\n\tu16 wLength;\n\tu16 UART_state_bitmap;\n} __packed;\n\nstruct hso_tiocmget {\n\tstruct mutex mutex;\n\twait_queue_head_t waitq;\n\tint    intr_completed;\n\tstruct usb_endpoint_descriptor *endp;\n\tstruct urb *urb;\n\tstruct hso_serial_state_notification *serial_state_notification;\n\tu16    prev_UART_state_bitmap;\n\tstruct uart_icount icount;\n};\n\n\nstruct hso_serial {\n\tstruct hso_device *parent;\n\tint magic;\n\tu8 minor;\n\n\tstruct hso_shared_int *shared_int;\n\n\t \n\tstruct urb *rx_urb[MAX_RX_URBS];\n\tu8 num_rx_urbs;\n\tu8 *rx_data[MAX_RX_URBS];\n\tu16 rx_data_length;\t \n\n\tstruct urb *tx_urb;\n\tu8 *tx_data;\n\tu8 *tx_buffer;\n\tu16 tx_data_length;\t \n\tu16 tx_data_count;\n\tu16 tx_buffer_count;\n\tstruct usb_ctrlrequest ctrl_req_tx;\n\tstruct usb_ctrlrequest ctrl_req_rx;\n\n\tstruct usb_endpoint_descriptor *in_endp;\n\tstruct usb_endpoint_descriptor *out_endp;\n\n\tenum rx_ctrl_state rx_state;\n\tu8 rts_state;\n\tu8 dtr_state;\n\tunsigned tx_urb_used:1;\n\n\tstruct tty_port port;\n\t \n\tspinlock_t serial_lock;\n\n\tint (*write_data) (struct hso_serial *serial);\n\tstruct hso_tiocmget  *tiocmget;\n\t \n\tint  curr_rx_urb_idx;\n\tu8   rx_urb_filled[MAX_RX_URBS];\n\tstruct tasklet_struct unthrottle_tasklet;\n};\n\nstruct hso_device {\n\tunion {\n\t\tstruct hso_serial *dev_serial;\n\t\tstruct hso_net *dev_net;\n\t} port_data;\n\n\tu32 port_spec;\n\n\tu8 is_active;\n\tu8 usb_gone;\n\tstruct work_struct async_get_intf;\n\tstruct work_struct async_put_intf;\n\n\tstruct usb_device *usb;\n\tstruct usb_interface *interface;\n\n\tstruct device *dev;\n\tstruct kref ref;\n\tstruct mutex mutex;\n};\n\n \n#define HSO_INTF_MASK\t\t0xFF00\n#define\tHSO_INTF_MUX\t\t0x0100\n#define\tHSO_INTF_BULK   \t0x0200\n\n \n#define HSO_PORT_MASK\t\t0xFF\n#define HSO_PORT_NO_PORT\t0x0\n#define\tHSO_PORT_CONTROL\t0x1\n#define\tHSO_PORT_APP\t\t0x2\n#define\tHSO_PORT_GPS\t\t0x3\n#define\tHSO_PORT_PCSC\t\t0x4\n#define\tHSO_PORT_APP2\t\t0x5\n#define HSO_PORT_GPS_CONTROL\t0x6\n#define HSO_PORT_MSD\t\t0x7\n#define HSO_PORT_VOICE\t\t0x8\n#define HSO_PORT_DIAG2\t\t0x9\n#define\tHSO_PORT_DIAG\t\t0x10\n#define\tHSO_PORT_MODEM\t\t0x11\n#define\tHSO_PORT_NETWORK\t0x12\n\n \n#define HSO_INFO_MASK\t\t0xFF000000\n#define HSO_INFO_CRC_BUG\t0x01000000\n\n \n \n \n \nstatic int hso_serial_tiocmset(struct tty_struct *tty,\n\t\t\t       unsigned int set, unsigned int clear);\nstatic void ctrl_callback(struct urb *urb);\nstatic int put_rxbuf_data(struct urb *urb, struct hso_serial *serial);\nstatic void hso_kick_transmit(struct hso_serial *serial);\n \nstatic int hso_mux_submit_intr_urb(struct hso_shared_int *mux_int,\n\t\t\t\t   struct usb_device *usb, gfp_t gfp);\nstatic void handle_usb_error(int status, const char *function,\n\t\t\t     struct hso_device *hso_dev);\nstatic struct usb_endpoint_descriptor *hso_get_ep(struct usb_interface *intf,\n\t\t\t\t\t\t  int type, int dir);\nstatic int hso_get_mux_ports(struct usb_interface *intf, unsigned char *ports);\nstatic void hso_free_interface(struct usb_interface *intf);\nstatic int hso_start_serial_device(struct hso_device *hso_dev, gfp_t flags);\nstatic int hso_stop_serial_device(struct hso_device *hso_dev);\nstatic int hso_start_net_device(struct hso_device *hso_dev);\nstatic void hso_free_shared_int(struct hso_shared_int *shared_int);\nstatic int hso_stop_net_device(struct hso_device *hso_dev);\nstatic void hso_serial_ref_free(struct kref *ref);\nstatic void hso_std_serial_read_bulk_callback(struct urb *urb);\nstatic int hso_mux_serial_read(struct hso_serial *serial);\nstatic void async_get_intf(struct work_struct *data);\nstatic void async_put_intf(struct work_struct *data);\nstatic int hso_put_activity(struct hso_device *hso_dev);\nstatic int hso_get_activity(struct hso_device *hso_dev);\nstatic void tiocmget_intr_callback(struct urb *urb);\n \n \n \n\n \n\nstatic inline struct hso_net *dev2net(struct hso_device *hso_dev)\n{\n\treturn hso_dev->port_data.dev_net;\n}\n\nstatic inline struct hso_serial *dev2ser(struct hso_device *hso_dev)\n{\n\treturn hso_dev->port_data.dev_serial;\n}\n\n \n#ifdef DEBUG\nstatic void dbg_dump(int line_count, const char *func_name, unsigned char *buf,\n\t\t     unsigned int len)\n{\n\tstatic char name[255];\n\n\tsprintf(name, \"hso[%d:%s]\", line_count, func_name);\n\tprint_hex_dump_bytes(name, DUMP_PREFIX_NONE, buf, len);\n}\n\n#define DUMP(buf_, len_)\t\\\n\tdbg_dump(__LINE__, __func__, (unsigned char *)buf_, len_)\n\n#define DUMP1(buf_, len_)\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tif (0x01 & debug)\t\t\\\n\t\t\tDUMP(buf_, len_);\t\\\n\t} while (0)\n#else\n#define DUMP(buf_, len_)\n#define DUMP1(buf_, len_)\n#endif\n\n \nstatic int debug;\nstatic int tty_major;\nstatic int disable_net;\n\n \nstatic const char driver_name[] = \"hso\";\nstatic const char tty_filename[] = \"ttyHS\";\nstatic const char *version = __FILE__ \": \" MOD_AUTHOR;\n \nstatic struct usb_driver hso_driver;\n \nstatic struct tty_driver *tty_drv;\nstatic struct hso_device *serial_table[HSO_SERIAL_TTY_MINORS];\nstatic struct hso_device *network_table[HSO_MAX_NET_DEVICES];\nstatic DEFINE_SPINLOCK(serial_table_lock);\n\nstatic const s32 default_port_spec[] = {\n\tHSO_INTF_MUX | HSO_PORT_NETWORK,\n\tHSO_INTF_BULK | HSO_PORT_DIAG,\n\tHSO_INTF_BULK | HSO_PORT_MODEM,\n\t0\n};\n\nstatic const s32 icon321_port_spec[] = {\n\tHSO_INTF_MUX | HSO_PORT_NETWORK,\n\tHSO_INTF_BULK | HSO_PORT_DIAG2,\n\tHSO_INTF_BULK | HSO_PORT_MODEM,\n\tHSO_INTF_BULK | HSO_PORT_DIAG,\n\t0\n};\n\n#define default_port_device(vendor, product)\t\\\n\tUSB_DEVICE(vendor, product),\t\\\n\t\t.driver_info = (kernel_ulong_t)default_port_spec\n\n#define icon321_port_device(vendor, product)\t\\\n\tUSB_DEVICE(vendor, product),\t\\\n\t\t.driver_info = (kernel_ulong_t)icon321_port_spec\n\n \nstatic const struct usb_device_id hso_ids[] = {\n\t{default_port_device(0x0af0, 0x6711)},\n\t{default_port_device(0x0af0, 0x6731)},\n\t{default_port_device(0x0af0, 0x6751)},\n\t{default_port_device(0x0af0, 0x6771)},\n\t{default_port_device(0x0af0, 0x6791)},\n\t{default_port_device(0x0af0, 0x6811)},\n\t{default_port_device(0x0af0, 0x6911)},\n\t{default_port_device(0x0af0, 0x6951)},\n\t{default_port_device(0x0af0, 0x6971)},\n\t{default_port_device(0x0af0, 0x7011)},\n\t{default_port_device(0x0af0, 0x7031)},\n\t{default_port_device(0x0af0, 0x7051)},\n\t{default_port_device(0x0af0, 0x7071)},\n\t{default_port_device(0x0af0, 0x7111)},\n\t{default_port_device(0x0af0, 0x7211)},\n\t{default_port_device(0x0af0, 0x7251)},\n\t{default_port_device(0x0af0, 0x7271)},\n\t{default_port_device(0x0af0, 0x7311)},\n\t{default_port_device(0x0af0, 0xc031)},\t \n\t{icon321_port_device(0x0af0, 0xd013)},\t \n\t{icon321_port_device(0x0af0, 0xd031)},\t \n\t{icon321_port_device(0x0af0, 0xd033)},\t \n\t{USB_DEVICE(0x0af0, 0x7301)},\t\t \n\t{USB_DEVICE(0x0af0, 0x7361)},\t\t \n\t{USB_DEVICE(0x0af0, 0x7381)},\t\t \n\t{USB_DEVICE(0x0af0, 0x7401)},\t\t \n\t{USB_DEVICE(0x0af0, 0x7501)},\t\t \n\t{USB_DEVICE(0x0af0, 0x7601)},\t\t \n\t{USB_DEVICE(0x0af0, 0x7701)},\n\t{USB_DEVICE(0x0af0, 0x7706)},\n\t{USB_DEVICE(0x0af0, 0x7801)},\n\t{USB_DEVICE(0x0af0, 0x7901)},\n\t{USB_DEVICE(0x0af0, 0x7A01)},\n\t{USB_DEVICE(0x0af0, 0x7A05)},\n\t{USB_DEVICE(0x0af0, 0x8200)},\n\t{USB_DEVICE(0x0af0, 0x8201)},\n\t{USB_DEVICE(0x0af0, 0x8300)},\n\t{USB_DEVICE(0x0af0, 0x8302)},\n\t{USB_DEVICE(0x0af0, 0x8304)},\n\t{USB_DEVICE(0x0af0, 0x8400)},\n\t{USB_DEVICE(0x0af0, 0x8600)},\n\t{USB_DEVICE(0x0af0, 0x8800)},\n\t{USB_DEVICE(0x0af0, 0x8900)},\n\t{USB_DEVICE(0x0af0, 0x9000)},\n\t{USB_DEVICE(0x0af0, 0x9200)},\t\t \n\t{USB_DEVICE(0x0af0, 0xd035)},\n\t{USB_DEVICE(0x0af0, 0xd055)},\n\t{USB_DEVICE(0x0af0, 0xd155)},\n\t{USB_DEVICE(0x0af0, 0xd255)},\n\t{USB_DEVICE(0x0af0, 0xd057)},\n\t{USB_DEVICE(0x0af0, 0xd157)},\n\t{USB_DEVICE(0x0af0, 0xd257)},\n\t{USB_DEVICE(0x0af0, 0xd357)},\n\t{USB_DEVICE(0x0af0, 0xd058)},\n\t{USB_DEVICE(0x0af0, 0xc100)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, hso_ids);\n\n \nstatic ssize_t hsotype_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct hso_device *hso_dev = dev_get_drvdata(dev);\n\tchar *port_name;\n\n\tif (!hso_dev)\n\t\treturn 0;\n\n\tswitch (hso_dev->port_spec & HSO_PORT_MASK) {\n\tcase HSO_PORT_CONTROL:\n\t\tport_name = \"Control\";\n\t\tbreak;\n\tcase HSO_PORT_APP:\n\t\tport_name = \"Application\";\n\t\tbreak;\n\tcase HSO_PORT_APP2:\n\t\tport_name = \"Application2\";\n\t\tbreak;\n\tcase HSO_PORT_GPS:\n\t\tport_name = \"GPS\";\n\t\tbreak;\n\tcase HSO_PORT_GPS_CONTROL:\n\t\tport_name = \"GPS Control\";\n\t\tbreak;\n\tcase HSO_PORT_PCSC:\n\t\tport_name = \"PCSC\";\n\t\tbreak;\n\tcase HSO_PORT_DIAG:\n\t\tport_name = \"Diagnostic\";\n\t\tbreak;\n\tcase HSO_PORT_DIAG2:\n\t\tport_name = \"Diagnostic2\";\n\t\tbreak;\n\tcase HSO_PORT_MODEM:\n\t\tport_name = \"Modem\";\n\t\tbreak;\n\tcase HSO_PORT_NETWORK:\n\t\tport_name = \"Network\";\n\t\tbreak;\n\tdefault:\n\t\tport_name = \"Unknown\";\n\t\tbreak;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", port_name);\n}\nstatic DEVICE_ATTR_RO(hsotype);\n\nstatic struct attribute *hso_serial_dev_attrs[] = {\n\t&dev_attr_hsotype.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(hso_serial_dev);\n\nstatic int hso_urb_to_index(struct hso_serial *serial, struct urb *urb)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < serial->num_rx_urbs; idx++)\n\t\tif (serial->rx_urb[idx] == urb)\n\t\t\treturn idx;\n\tdev_err(serial->parent->dev, \"hso_urb_to_index failed\\n\");\n\treturn -1;\n}\n\n \nstatic u32 hso_mux_to_port(int mux)\n{\n\tu32 result;\n\n\tswitch (mux) {\n\tcase 0x1:\n\t\tresult = HSO_PORT_CONTROL;\n\t\tbreak;\n\tcase 0x2:\n\t\tresult = HSO_PORT_APP;\n\t\tbreak;\n\tcase 0x4:\n\t\tresult = HSO_PORT_PCSC;\n\t\tbreak;\n\tcase 0x8:\n\t\tresult = HSO_PORT_GPS;\n\t\tbreak;\n\tcase 0x10:\n\t\tresult = HSO_PORT_APP2;\n\t\tbreak;\n\tdefault:\n\t\tresult = HSO_PORT_NO_PORT;\n\t}\n\treturn result;\n}\n\n \nstatic u32 hso_port_to_mux(int port)\n{\n\tu32 result;\n\n\tswitch (port & HSO_PORT_MASK) {\n\tcase HSO_PORT_CONTROL:\n\t\tresult = 0x0;\n\t\tbreak;\n\tcase HSO_PORT_APP:\n\t\tresult = 0x1;\n\t\tbreak;\n\tcase HSO_PORT_PCSC:\n\t\tresult = 0x2;\n\t\tbreak;\n\tcase HSO_PORT_GPS:\n\t\tresult = 0x3;\n\t\tbreak;\n\tcase HSO_PORT_APP2:\n\t\tresult = 0x4;\n\t\tbreak;\n\tdefault:\n\t\tresult = 0x0;\n\t}\n\treturn result;\n}\n\nstatic struct hso_serial *get_serial_by_shared_int_and_type(\n\t\t\t\t\tstruct hso_shared_int *shared_int,\n\t\t\t\t\tint mux)\n{\n\tint i, port;\n\n\tport = hso_mux_to_port(mux);\n\n\tfor (i = 0; i < HSO_SERIAL_TTY_MINORS; i++) {\n\t\tif (serial_table[i] &&\n\t\t    (dev2ser(serial_table[i])->shared_int == shared_int) &&\n\t\t    ((serial_table[i]->port_spec & HSO_PORT_MASK) == port)) {\n\t\t\treturn dev2ser(serial_table[i]);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct hso_serial *get_serial_by_index(unsigned index)\n{\n\tstruct hso_serial *serial = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serial_table_lock, flags);\n\tif (serial_table[index])\n\t\tserial = dev2ser(serial_table[index]);\n\tspin_unlock_irqrestore(&serial_table_lock, flags);\n\n\treturn serial;\n}\n\nstatic int obtain_minor(struct hso_serial *serial)\n{\n\tint index;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serial_table_lock, flags);\n\tfor (index = 0; index < HSO_SERIAL_TTY_MINORS; index++) {\n\t\tif (serial_table[index] == NULL) {\n\t\t\tserial_table[index] = serial->parent;\n\t\t\tserial->minor = index;\n\t\t\tspin_unlock_irqrestore(&serial_table_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&serial_table_lock, flags);\n\n\tpr_err(\"%s: no free serial devices in table\\n\", __func__);\n\treturn -1;\n}\n\nstatic void release_minor(struct hso_serial *serial)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serial_table_lock, flags);\n\tserial_table[serial->minor] = NULL;\n\tspin_unlock_irqrestore(&serial_table_lock, flags);\n}\n\nstatic void handle_usb_error(int status, const char *function,\n\t\t\t     struct hso_device *hso_dev)\n{\n\tchar *explanation;\n\n\tswitch (status) {\n\tcase -ENODEV:\n\t\texplanation = \"no device\";\n\t\tbreak;\n\tcase -ENOENT:\n\t\texplanation = \"endpoint not enabled\";\n\t\tbreak;\n\tcase -EPIPE:\n\t\texplanation = \"endpoint stalled\";\n\t\tbreak;\n\tcase -ENOSPC:\n\t\texplanation = \"not enough bandwidth\";\n\t\tbreak;\n\tcase -ESHUTDOWN:\n\t\texplanation = \"device disabled\";\n\t\tbreak;\n\tcase -EHOSTUNREACH:\n\t\texplanation = \"device suspended\";\n\t\tbreak;\n\tcase -EINVAL:\n\tcase -EAGAIN:\n\tcase -EFBIG:\n\tcase -EMSGSIZE:\n\t\texplanation = \"internal error\";\n\t\tbreak;\n\tcase -EILSEQ:\n\tcase -EPROTO:\n\tcase -ETIME:\n\tcase -ETIMEDOUT:\n\t\texplanation = \"protocol error\";\n\t\tif (hso_dev)\n\t\t\tusb_queue_reset_device(hso_dev->interface);\n\t\tbreak;\n\tdefault:\n\t\texplanation = \"unknown status\";\n\t\tbreak;\n\t}\n\n\t \n\thso_dbg(0x1, \"%s: received USB status - %s (%d)\\n\",\n\t\tfunction, explanation, status);\n}\n\n \n\n \nstatic int hso_net_open(struct net_device *net)\n{\n\tstruct hso_net *odev = netdev_priv(net);\n\tunsigned long flags = 0;\n\n\tif (!odev) {\n\t\tdev_err(&net->dev, \"No net device !\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\todev->skb_tx_buf = NULL;\n\n\t \n\tspin_lock_irqsave(&odev->net_lock, flags);\n\todev->rx_parse_state = WAIT_IP;\n\todev->rx_buf_size = 0;\n\todev->rx_buf_missing = sizeof(struct iphdr);\n\tspin_unlock_irqrestore(&odev->net_lock, flags);\n\n\t \n\tset_bit(HSO_NET_RUNNING, &odev->flags);\n\thso_start_net_device(odev->parent);\n\n\t \n\tnetif_start_queue(net);\n\n\treturn 0;\n}\n\n \nstatic int hso_net_close(struct net_device *net)\n{\n\tstruct hso_net *odev = netdev_priv(net);\n\n\t \n\tnetif_stop_queue(net);\n\t \n\tclear_bit(HSO_NET_RUNNING, &odev->flags);\n\n\thso_stop_net_device(odev->parent);\n\n\t \n\treturn 0;\n}\n\n \nstatic void write_bulk_callback(struct urb *urb)\n{\n\tstruct hso_net *odev = urb->context;\n\tint status = urb->status;\n\n\t \n\tif (!odev || !test_bit(HSO_NET_RUNNING, &odev->flags)) {\n\t\tdev_err(&urb->dev->dev, \"%s: device not running\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tif (!netif_device_present(odev->net)) {\n\t\tdev_err(&urb->dev->dev, \"%s: net device not present\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\t \n\tif (status)\n\t\thandle_usb_error(status, __func__, odev->parent);\n\n\thso_put_activity(odev->parent);\n\n\t \n\tnetif_wake_queue(odev->net);\n}\n\n \nstatic netdev_tx_t hso_net_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *net)\n{\n\tstruct hso_net *odev = netdev_priv(net);\n\tint result;\n\n\t \n\tnetif_stop_queue(net);\n\tif (hso_get_activity(odev->parent) == -EAGAIN) {\n\t\todev->skb_tx_buf = skb;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tDUMP1(skb->data, skb->len);\n\t \n\tmemcpy(odev->mux_bulk_tx_buf, skb->data, skb->len);\n\thso_dbg(0x1, \"len: %d/%d\\n\", skb->len, MUX_BULK_TX_BUF_SIZE);\n\n\t \n\tusb_fill_bulk_urb(odev->mux_bulk_tx_urb,\n\t\t\t  odev->parent->usb,\n\t\t\t  usb_sndbulkpipe(odev->parent->usb,\n\t\t\t\t\t  odev->out_endp->\n\t\t\t\t\t  bEndpointAddress & 0x7F),\n\t\t\t  odev->mux_bulk_tx_buf, skb->len, write_bulk_callback,\n\t\t\t  odev);\n\n\t \n\todev->mux_bulk_tx_urb->transfer_flags |= URB_ZERO_PACKET;\n\n\t \n\tresult = usb_submit_urb(odev->mux_bulk_tx_urb, GFP_ATOMIC);\n\tif (result) {\n\t\tdev_warn(&odev->parent->interface->dev,\n\t\t\t\"failed mux_bulk_tx_urb %d\\n\", result);\n\t\tnet->stats.tx_errors++;\n\t\tnetif_start_queue(net);\n\t} else {\n\t\tnet->stats.tx_packets++;\n\t\tnet->stats.tx_bytes += skb->len;\n\t}\n\tdev_kfree_skb(skb);\n\t \n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_link = ethtool_op_get_link\n};\n\n \nstatic void hso_net_tx_timeout(struct net_device *net, unsigned int txqueue)\n{\n\tstruct hso_net *odev = netdev_priv(net);\n\n\tif (!odev)\n\t\treturn;\n\n\t \n\tdev_warn(&net->dev, \"Tx timed out.\\n\");\n\n\t \n\tif (odev->mux_bulk_tx_urb)\n\t\tusb_unlink_urb(odev->mux_bulk_tx_urb);\n\n\t \n\tnet->stats.tx_errors++;\n}\n\n \nstatic void packetizeRx(struct hso_net *odev, unsigned char *ip_pkt,\n\t\t\tunsigned int count, unsigned char is_eop)\n{\n\tunsigned short temp_bytes;\n\tunsigned short buffer_offset = 0;\n\tunsigned short frame_len;\n\n\t \n\thso_dbg(0x1, \"Rx %d bytes\\n\", count);\n\tDUMP(ip_pkt, min(128, (int)count));\n\n\twhile (count) {\n\t\tswitch (odev->rx_parse_state) {\n\t\tcase WAIT_IP:\n\t\t\t \n\t\t\t \n\t\t\ttemp_bytes =\n\t\t\t    (count <\n\t\t\t     odev->rx_buf_missing) ? count : odev->\n\t\t\t    rx_buf_missing;\n\n\t\t\tmemcpy(((unsigned char *)(&odev->rx_ip_hdr)) +\n\t\t\t       odev->rx_buf_size, ip_pkt + buffer_offset,\n\t\t\t       temp_bytes);\n\n\t\t\todev->rx_buf_size += temp_bytes;\n\t\t\tbuffer_offset += temp_bytes;\n\t\t\todev->rx_buf_missing -= temp_bytes;\n\t\t\tcount -= temp_bytes;\n\n\t\t\tif (!odev->rx_buf_missing) {\n\t\t\t\t \n\t\t\t\tframe_len = ntohs(odev->rx_ip_hdr.tot_len);\n\n\t\t\t\tif ((frame_len > DEFAULT_MRU) ||\n\t\t\t\t    (frame_len < sizeof(struct iphdr))) {\n\t\t\t\t\tdev_err(&odev->net->dev,\n\t\t\t\t\t\t\"Invalid frame (%d) length\\n\",\n\t\t\t\t\t\tframe_len);\n\t\t\t\t\todev->rx_parse_state = WAIT_SYNC;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\todev->skb_rx_buf = netdev_alloc_skb(odev->net,\n\t\t\t\t\t\t\t\t    frame_len);\n\t\t\t\tif (!odev->skb_rx_buf) {\n\t\t\t\t\t \n\t\t\t\t\thso_dbg(0x1, \"could not allocate memory\\n\");\n\t\t\t\t\todev->rx_parse_state = WAIT_SYNC;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tskb_put_data(odev->skb_rx_buf,\n\t\t\t\t\t     (char *)&(odev->rx_ip_hdr),\n\t\t\t\t\t     sizeof(struct iphdr));\n\n\t\t\t\t \n\t\t\t\todev->rx_buf_size = sizeof(struct iphdr);\n\n\t\t\t\t \n\t\t\t\todev->rx_buf_missing =\n\t\t\t\t    frame_len - sizeof(struct iphdr);\n\t\t\t\todev->rx_parse_state = WAIT_DATA;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase WAIT_DATA:\n\t\t\ttemp_bytes = (count < odev->rx_buf_missing)\n\t\t\t\t\t? count : odev->rx_buf_missing;\n\n\t\t\t \n\t\t\t \n\t\t\tskb_put_data(odev->skb_rx_buf,\n\t\t\t\t     ip_pkt + buffer_offset,\n\t\t\t\t     temp_bytes);\n\n\t\t\todev->rx_buf_missing -= temp_bytes;\n\t\t\tcount -= temp_bytes;\n\t\t\tbuffer_offset += temp_bytes;\n\t\t\todev->rx_buf_size += temp_bytes;\n\t\t\tif (!odev->rx_buf_missing) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\todev->skb_rx_buf->protocol = cpu_to_be16(ETH_P_IP);\n\t\t\t\tskb_reset_mac_header(odev->skb_rx_buf);\n\n\t\t\t\t \n\t\t\t\tnetif_rx(odev->skb_rx_buf);\n\t\t\t\t \n\t\t\t\todev->skb_rx_buf = NULL;\n\n\t\t\t\t \n\t\t\t\todev->net->stats.rx_packets++;\n\n\t\t\t\todev->net->stats.rx_bytes += odev->rx_buf_size;\n\n\t\t\t\todev->rx_buf_size = 0;\n\t\t\t\todev->rx_buf_missing = sizeof(struct iphdr);\n\t\t\t\todev->rx_parse_state = WAIT_IP;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase WAIT_SYNC:\n\t\t\thso_dbg(0x1, \" W_S\\n\");\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thso_dbg(0x1, \"\\n\");\n\t\t\tcount--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (is_eop) {\n\t\tif (odev->rx_parse_state == WAIT_SYNC) {\n\t\t\todev->rx_parse_state = WAIT_IP;\n\t\t\todev->rx_buf_size = 0;\n\t\t\todev->rx_buf_missing = sizeof(struct iphdr);\n\t\t}\n\t}\n}\n\nstatic void fix_crc_bug(struct urb *urb, __le16 max_packet_size)\n{\n\tstatic const u8 crc_check[4] = { 0xDE, 0xAD, 0xBE, 0xEF };\n\tu32 rest = urb->actual_length % le16_to_cpu(max_packet_size);\n\n\tif (((rest == 5) || (rest == 6)) &&\n\t    !memcmp(((u8 *)urb->transfer_buffer) + urb->actual_length - 4,\n\t\t    crc_check, 4)) {\n\t\turb->actual_length -= 4;\n\t}\n}\n\n \nstatic void read_bulk_callback(struct urb *urb)\n{\n\tstruct hso_net *odev = urb->context;\n\tstruct net_device *net;\n\tint result;\n\tunsigned long flags;\n\tint status = urb->status;\n\n\t \n\tif (status) {\n\t\thandle_usb_error(status, __func__, odev->parent);\n\t\treturn;\n\t}\n\n\t \n\tif (!odev || !test_bit(HSO_NET_RUNNING, &odev->flags)) {\n\t\thso_dbg(0x1, \"BULK IN callback but driver is not active!\\n\");\n\t\treturn;\n\t}\n\tusb_mark_last_busy(urb->dev);\n\n\tnet = odev->net;\n\n\tif (!netif_device_present(net)) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (odev->parent->port_spec & HSO_INFO_CRC_BUG)\n\t\tfix_crc_bug(urb, odev->in_endp->wMaxPacketSize);\n\n\t \n\tif (urb->actual_length) {\n\t\t \n\t\tspin_lock_irqsave(&odev->net_lock, flags);\n\t\tpacketizeRx(odev, urb->transfer_buffer, urb->actual_length,\n\t\t\t    (urb->transfer_buffer_length >\n\t\t\t     urb->actual_length) ? 1 : 0);\n\t\tspin_unlock_irqrestore(&odev->net_lock, flags);\n\t}\n\n\t \n\tusb_fill_bulk_urb(urb,\n\t\t\t  odev->parent->usb,\n\t\t\t  usb_rcvbulkpipe(odev->parent->usb,\n\t\t\t\t\t  odev->in_endp->\n\t\t\t\t\t  bEndpointAddress & 0x7F),\n\t\t\t  urb->transfer_buffer, MUX_BULK_RX_BUF_SIZE,\n\t\t\t  read_bulk_callback, odev);\n\n\t \n\tresult = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_warn(&odev->parent->interface->dev,\n\t\t\t \"%s failed submit mux_bulk_rx_urb %d\\n\", __func__,\n\t\t\t result);\n}\n\n \n\nstatic void hso_init_termios(struct ktermios *termios)\n{\n\t \n\ttermios->c_iflag &=\n\t\t~(IGNBRK\t \n\t\t| BRKINT\t \n\t\t| PARMRK\t \n\t\t| ISTRIP\t \n\t\t| INLCR\t\t \n\t\t| IGNCR\t\t \n\t\t| ICRNL\t\t \n\t\t| IXON);\t \n\n\t \n\ttermios->c_oflag &= ~OPOST;\n\n\ttermios->c_lflag &=\n\t\t~(ECHO\t\t \n\t\t| ECHONL\t \n\t\t| ICANON\t \n\t\t| ISIG\t\t \n\t\t| IEXTEN);\t \n\n\ttermios->c_cflag &=\n\t\t~(CSIZE\t\t \n\t\t| PARENB\t \n\t\t| CBAUD\t\t \n\t\t| CBAUDEX);\t \n\n\ttermios->c_cflag |= CS8;\t \n\n\t \n\ttty_termios_encode_baud_rate(termios, 115200, 115200);\n}\n\nstatic void _hso_serial_set_termios(struct tty_struct *tty)\n{\n\tstruct hso_serial *serial = tty->driver_data;\n\n\tif (!serial) {\n\t\tpr_err(\"%s: no tty structures\", __func__);\n\t\treturn;\n\t}\n\n\thso_dbg(0x8, \"port %d\\n\", serial->minor);\n\n\t \n\ttty->termios.c_iflag &= ~IXON;  \n\n\ttty->termios.c_cflag &=\n\t\t~(CSIZE\t\t \n\t\t| PARENB\t \n\t\t| CBAUD\t\t \n\t\t| CBAUDEX);\t \n\n\ttty->termios.c_cflag |= CS8;\t \n\n\t \n\ttty_encode_baud_rate(tty, 115200, 115200);\n}\n\nstatic void hso_resubmit_rx_bulk_urb(struct hso_serial *serial, struct urb *urb)\n{\n\tint result;\n\t \n\tusb_fill_bulk_urb(urb, serial->parent->usb,\n\t\t\t  usb_rcvbulkpipe(serial->parent->usb,\n\t\t\t\t\t  serial->in_endp->\n\t\t\t\t\t  bEndpointAddress & 0x7F),\n\t\t\t  urb->transfer_buffer, serial->rx_data_length,\n\t\t\t  hso_std_serial_read_bulk_callback, serial);\n\t \n\tresult = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (result) {\n\t\tdev_err(&urb->dev->dev, \"%s failed submit serial rx_urb %d\\n\",\n\t\t\t__func__, result);\n\t}\n}\n\n\n\n\nstatic void put_rxbuf_data_and_resubmit_bulk_urb(struct hso_serial *serial)\n{\n\tint count;\n\tstruct urb *curr_urb;\n\n\twhile (serial->rx_urb_filled[serial->curr_rx_urb_idx]) {\n\t\tcurr_urb = serial->rx_urb[serial->curr_rx_urb_idx];\n\t\tcount = put_rxbuf_data(curr_urb, serial);\n\t\tif (count == -1)\n\t\t\treturn;\n\t\tif (count == 0) {\n\t\t\tserial->curr_rx_urb_idx++;\n\t\t\tif (serial->curr_rx_urb_idx >= serial->num_rx_urbs)\n\t\t\t\tserial->curr_rx_urb_idx = 0;\n\t\t\thso_resubmit_rx_bulk_urb(serial, curr_urb);\n\t\t}\n\t}\n}\n\nstatic void put_rxbuf_data_and_resubmit_ctrl_urb(struct hso_serial *serial)\n{\n\tint count = 0;\n\tstruct urb *urb;\n\n\turb = serial->rx_urb[0];\n\tif (serial->port.count > 0) {\n\t\tcount = put_rxbuf_data(urb, serial);\n\t\tif (count == -1)\n\t\t\treturn;\n\t}\n\t \n\n\tif (count == 0 && ((urb->actual_length != 0) ||\n\t\t\t   (serial->rx_state == RX_PENDING))) {\n\t\tserial->rx_state = RX_SENT;\n\t\thso_mux_serial_read(serial);\n\t} else\n\t\tserial->rx_state = RX_IDLE;\n}\n\n\n \nstatic void hso_std_serial_read_bulk_callback(struct urb *urb)\n{\n\tstruct hso_serial *serial = urb->context;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\thso_dbg(0x8, \"--- Got serial_read_bulk callback %02x ---\\n\", status);\n\n\t \n\tif (!serial) {\n\t\thso_dbg(0x1, \"serial == NULL\\n\");\n\t\treturn;\n\t}\n\tif (status) {\n\t\thandle_usb_error(status, __func__, serial->parent);\n\t\treturn;\n\t}\n\n\thso_dbg(0x1, \"Actual length = %d\\n\", urb->actual_length);\n\tDUMP1(urb->transfer_buffer, urb->actual_length);\n\n\t \n\tif (serial->port.count == 0)\n\t\treturn;\n\n\tif (serial->parent->port_spec & HSO_INFO_CRC_BUG)\n\t\tfix_crc_bug(urb, serial->in_endp->wMaxPacketSize);\n\t \n\tspin_lock_irqsave(&serial->serial_lock, flags);\n\tserial->rx_urb_filled[hso_urb_to_index(serial, urb)] = 1;\n\tput_rxbuf_data_and_resubmit_bulk_urb(serial);\n\tspin_unlock_irqrestore(&serial->serial_lock, flags);\n}\n\n \nstatic void hso_unthrottle_tasklet(struct tasklet_struct *t)\n{\n\tstruct hso_serial *serial = from_tasklet(serial, t,\n\t\t\t\t\t\t unthrottle_tasklet);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serial->serial_lock, flags);\n\tif ((serial->parent->port_spec & HSO_INTF_MUX))\n\t\tput_rxbuf_data_and_resubmit_ctrl_urb(serial);\n\telse\n\t\tput_rxbuf_data_and_resubmit_bulk_urb(serial);\n\tspin_unlock_irqrestore(&serial->serial_lock, flags);\n}\n\nstatic\tvoid hso_unthrottle(struct tty_struct *tty)\n{\n\tstruct hso_serial *serial = tty->driver_data;\n\n\ttasklet_hi_schedule(&serial->unthrottle_tasklet);\n}\n\n \nstatic int hso_serial_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct hso_serial *serial = get_serial_by_index(tty->index);\n\tint result;\n\n\t \n\tif (serial == NULL || serial->magic != HSO_SERIAL_MAGIC) {\n\t\tWARN_ON(1);\n\t\ttty->driver_data = NULL;\n\t\thso_dbg(0x1, \"Failed to open port\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&serial->parent->mutex);\n\tresult = usb_autopm_get_interface(serial->parent->interface);\n\tif (result < 0)\n\t\tgoto err_out;\n\n\thso_dbg(0x1, \"Opening %d\\n\", serial->minor);\n\n\t \n\ttty->driver_data = serial;\n\ttty_port_tty_set(&serial->port, tty);\n\n\t \n\tserial->port.count++;\n\tif (serial->port.count == 1) {\n\t\tserial->rx_state = RX_IDLE;\n\t\t \n\t\t_hso_serial_set_termios(tty);\n\t\ttasklet_setup(&serial->unthrottle_tasklet,\n\t\t\t      hso_unthrottle_tasklet);\n\t\tresult = hso_start_serial_device(serial->parent, GFP_KERNEL);\n\t\tif (result) {\n\t\t\thso_stop_serial_device(serial->parent);\n\t\t\tserial->port.count--;\n\t\t} else {\n\t\t\tkref_get(&serial->parent->ref);\n\t\t}\n\t} else {\n\t\thso_dbg(0x1, \"Port was already open\\n\");\n\t}\n\n\tusb_autopm_put_interface(serial->parent->interface);\n\n\t \n\tif (result)\n\t\thso_serial_tiocmset(tty, TIOCM_RTS | TIOCM_DTR, 0);\nerr_out:\n\tmutex_unlock(&serial->parent->mutex);\n\treturn result;\n}\n\n \nstatic void hso_serial_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct hso_serial *serial = tty->driver_data;\n\tu8 usb_gone;\n\n\thso_dbg(0x1, \"Closing serial port\\n\");\n\n\t \n\tif (serial == NULL)\n\t\treturn;\n\n\tmutex_lock(&serial->parent->mutex);\n\tusb_gone = serial->parent->usb_gone;\n\n\tif (!usb_gone)\n\t\tusb_autopm_get_interface(serial->parent->interface);\n\n\t \n\t \n\tserial->port.count--;\n\n\tif (serial->port.count <= 0) {\n\t\tserial->port.count = 0;\n\t\ttty_port_tty_set(&serial->port, NULL);\n\t\tif (!usb_gone)\n\t\t\thso_stop_serial_device(serial->parent);\n\t\ttasklet_kill(&serial->unthrottle_tasklet);\n\t}\n\n\tif (!usb_gone)\n\t\tusb_autopm_put_interface(serial->parent->interface);\n\n\tmutex_unlock(&serial->parent->mutex);\n}\n\n \nstatic ssize_t hso_serial_write(struct tty_struct *tty, const u8 *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct hso_serial *serial = tty->driver_data;\n\tunsigned long flags;\n\n\t \n\tif (serial == NULL) {\n\t\tpr_err(\"%s: serial is NULL\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&serial->serial_lock, flags);\n\n\tcount = min_t(size_t, serial->tx_data_length - serial->tx_buffer_count,\n\t\t      count);\n\tmemcpy(serial->tx_buffer + serial->tx_buffer_count, buf, count);\n\tserial->tx_buffer_count += count;\n\n\tspin_unlock_irqrestore(&serial->serial_lock, flags);\n\n\thso_kick_transmit(serial);\n\t \n\treturn count;\n}\n\n \nstatic unsigned int hso_serial_write_room(struct tty_struct *tty)\n{\n\tstruct hso_serial *serial = tty->driver_data;\n\tunsigned int room;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&serial->serial_lock, flags);\n\troom = serial->tx_data_length - serial->tx_buffer_count;\n\tspin_unlock_irqrestore(&serial->serial_lock, flags);\n\n\t \n\treturn room;\n}\n\nstatic void hso_serial_cleanup(struct tty_struct *tty)\n{\n\tstruct hso_serial *serial = tty->driver_data;\n\n\tif (!serial)\n\t\treturn;\n\n\tkref_put(&serial->parent->ref, hso_serial_ref_free);\n}\n\n \nstatic void hso_serial_set_termios(struct tty_struct *tty,\n\t\t\t\t   const struct ktermios *old)\n{\n\tstruct hso_serial *serial = tty->driver_data;\n\tunsigned long flags;\n\n\tif (old)\n\t\thso_dbg(0x16, \"Termios called with: cflags new[%u] - old[%u]\\n\",\n\t\t\t(unsigned int)tty->termios.c_cflag,\n\t\t\t(unsigned int)old->c_cflag);\n\n\t \n\tspin_lock_irqsave(&serial->serial_lock, flags);\n\tif (serial->port.count)\n\t\t_hso_serial_set_termios(tty);\n\telse\n\t\ttty->termios = *old;\n\tspin_unlock_irqrestore(&serial->serial_lock, flags);\n\n\t \n}\n\n \nstatic unsigned int hso_serial_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct hso_serial *serial = tty->driver_data;\n\tunsigned long flags;\n\tunsigned int chars;\n\n\t \n\tif (serial == NULL)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&serial->serial_lock, flags);\n\tchars = serial->tx_buffer_count;\n\tspin_unlock_irqrestore(&serial->serial_lock, flags);\n\n\treturn chars;\n}\nstatic int tiocmget_submit_urb(struct hso_serial *serial,\n\t\t\t       struct hso_tiocmget *tiocmget,\n\t\t\t       struct usb_device *usb)\n{\n\tint result;\n\n\tif (serial->parent->usb_gone)\n\t\treturn -ENODEV;\n\tusb_fill_int_urb(tiocmget->urb, usb,\n\t\t\t usb_rcvintpipe(usb,\n\t\t\t\t\ttiocmget->endp->\n\t\t\t\t\tbEndpointAddress & 0x7F),\n\t\t\t tiocmget->serial_state_notification,\n\t\t\t sizeof(struct hso_serial_state_notification),\n\t\t\t tiocmget_intr_callback, serial,\n\t\t\t tiocmget->endp->bInterval);\n\tresult = usb_submit_urb(tiocmget->urb, GFP_ATOMIC);\n\tif (result) {\n\t\tdev_warn(&usb->dev, \"%s usb_submit_urb failed %d\\n\", __func__,\n\t\t\t result);\n\t}\n\treturn result;\n\n}\n\nstatic void tiocmget_intr_callback(struct urb *urb)\n{\n\tstruct hso_serial *serial = urb->context;\n\tstruct hso_tiocmget *tiocmget;\n\tint status = urb->status;\n\tu16 UART_state_bitmap, prev_UART_state_bitmap;\n\tstruct uart_icount *icount;\n\tstruct hso_serial_state_notification *serial_state_notification;\n\tstruct usb_device *usb;\n\tstruct usb_interface *interface;\n\tint if_num;\n\n\t \n\tif (!serial)\n\t\treturn;\n\tif (status) {\n\t\thandle_usb_error(status, __func__, serial->parent);\n\t\treturn;\n\t}\n\n\t \n\ttiocmget = serial->tiocmget;\n\tif (!tiocmget)\n\t\treturn;\n\tBUG_ON((serial->parent->port_spec & HSO_PORT_MASK) != HSO_PORT_MODEM);\n\n\tusb = serial->parent->usb;\n\tinterface = serial->parent->interface;\n\n\tif_num = interface->cur_altsetting->desc.bInterfaceNumber;\n\n\t \n\tserial_state_notification = tiocmget->serial_state_notification;\n\tif (serial_state_notification->bmRequestType != BM_REQUEST_TYPE ||\n\t    serial_state_notification->bNotification != B_NOTIFICATION ||\n\t    le16_to_cpu(serial_state_notification->wValue) != W_VALUE ||\n\t    le16_to_cpu(serial_state_notification->wIndex) != if_num ||\n\t    le16_to_cpu(serial_state_notification->wLength) != W_LENGTH) {\n\t\tdev_warn(&usb->dev,\n\t\t\t \"hso received invalid serial state notification\\n\");\n\t\tDUMP(serial_state_notification,\n\t\t     sizeof(struct hso_serial_state_notification));\n\t} else {\n\t\tunsigned long flags;\n\n\t\tUART_state_bitmap = le16_to_cpu(serial_state_notification->\n\t\t\t\t\t\tUART_state_bitmap);\n\t\tprev_UART_state_bitmap = tiocmget->prev_UART_state_bitmap;\n\t\ticount = &tiocmget->icount;\n\t\tspin_lock_irqsave(&serial->serial_lock, flags);\n\t\tif ((UART_state_bitmap & B_OVERRUN) !=\n\t\t   (prev_UART_state_bitmap & B_OVERRUN))\n\t\t\ticount->parity++;\n\t\tif ((UART_state_bitmap & B_PARITY) !=\n\t\t   (prev_UART_state_bitmap & B_PARITY))\n\t\t\ticount->parity++;\n\t\tif ((UART_state_bitmap & B_FRAMING) !=\n\t\t   (prev_UART_state_bitmap & B_FRAMING))\n\t\t\ticount->frame++;\n\t\tif ((UART_state_bitmap & B_RING_SIGNAL) &&\n\t\t   !(prev_UART_state_bitmap & B_RING_SIGNAL))\n\t\t\ticount->rng++;\n\t\tif ((UART_state_bitmap & B_BREAK) !=\n\t\t   (prev_UART_state_bitmap & B_BREAK))\n\t\t\ticount->brk++;\n\t\tif ((UART_state_bitmap & B_TX_CARRIER) !=\n\t\t   (prev_UART_state_bitmap & B_TX_CARRIER))\n\t\t\ticount->dsr++;\n\t\tif ((UART_state_bitmap & B_RX_CARRIER) !=\n\t\t   (prev_UART_state_bitmap & B_RX_CARRIER))\n\t\t\ticount->dcd++;\n\t\ttiocmget->prev_UART_state_bitmap = UART_state_bitmap;\n\t\tspin_unlock_irqrestore(&serial->serial_lock, flags);\n\t\ttiocmget->intr_completed = 1;\n\t\twake_up_interruptible(&tiocmget->waitq);\n\t}\n\tmemset(serial_state_notification, 0,\n\t       sizeof(struct hso_serial_state_notification));\n\ttiocmget_submit_urb(serial,\n\t\t\t    tiocmget,\n\t\t\t    serial->parent->usb);\n}\n\n \n \nstatic int\nhso_wait_modem_status(struct hso_serial *serial, unsigned long arg)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct uart_icount cprev, cnow;\n\tstruct hso_tiocmget  *tiocmget;\n\tint ret;\n\n\ttiocmget = serial->tiocmget;\n\tif (!tiocmget)\n\t\treturn -ENOENT;\n\t \n\tspin_lock_irq(&serial->serial_lock);\n\tmemcpy(&cprev, &tiocmget->icount, sizeof(struct uart_icount));\n\tspin_unlock_irq(&serial->serial_lock);\n\tadd_wait_queue(&tiocmget->waitq, &wait);\n\tfor (;;) {\n\t\tspin_lock_irq(&serial->serial_lock);\n\t\tmemcpy(&cnow, &tiocmget->icount, sizeof(struct uart_icount));\n\t\tspin_unlock_irq(&serial->serial_lock);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\n\t\t    ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\n\t\t    ((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd))) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t\t \n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tcprev = cnow;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tiocmget->waitq, &wait);\n\n\treturn ret;\n}\n\n \nstatic int hso_get_count(struct tty_struct *tty,\n\t\t  struct serial_icounter_struct *icount)\n{\n\tstruct uart_icount cnow;\n\tstruct hso_serial *serial = tty->driver_data;\n\tstruct hso_tiocmget  *tiocmget = serial->tiocmget;\n\n\tmemset(icount, 0, sizeof(struct serial_icounter_struct));\n\n\tif (!tiocmget)\n\t\t return -ENOENT;\n\tspin_lock_irq(&serial->serial_lock);\n\tmemcpy(&cnow, &tiocmget->icount, sizeof(struct uart_icount));\n\tspin_unlock_irq(&serial->serial_lock);\n\n\ticount->cts         = cnow.cts;\n\ticount->dsr         = cnow.dsr;\n\ticount->rng         = cnow.rng;\n\ticount->dcd         = cnow.dcd;\n\ticount->rx          = cnow.rx;\n\ticount->tx          = cnow.tx;\n\ticount->frame       = cnow.frame;\n\ticount->overrun     = cnow.overrun;\n\ticount->parity      = cnow.parity;\n\ticount->brk         = cnow.brk;\n\ticount->buf_overrun = cnow.buf_overrun;\n\n\treturn 0;\n}\n\n\nstatic int hso_serial_tiocmget(struct tty_struct *tty)\n{\n\tint retval;\n\tstruct hso_serial *serial = tty->driver_data;\n\tstruct hso_tiocmget  *tiocmget;\n\tu16 UART_state_bitmap;\n\n\t \n\tif (!serial) {\n\t\thso_dbg(0x1, \"no tty structures\\n\");\n\t\treturn -EINVAL;\n\t}\n\tspin_lock_irq(&serial->serial_lock);\n\tretval = ((serial->rts_state) ? TIOCM_RTS : 0) |\n\t    ((serial->dtr_state) ? TIOCM_DTR : 0);\n\ttiocmget = serial->tiocmget;\n\tif (tiocmget) {\n\n\t\tUART_state_bitmap = le16_to_cpu(\n\t\t\ttiocmget->prev_UART_state_bitmap);\n\t\tif (UART_state_bitmap & B_RING_SIGNAL)\n\t\t\tretval |=  TIOCM_RNG;\n\t\tif (UART_state_bitmap & B_RX_CARRIER)\n\t\t\tretval |=  TIOCM_CD;\n\t\tif (UART_state_bitmap & B_TX_CARRIER)\n\t\t\tretval |=  TIOCM_DSR;\n\t}\n\tspin_unlock_irq(&serial->serial_lock);\n\treturn retval;\n}\n\nstatic int hso_serial_tiocmset(struct tty_struct *tty,\n\t\t\t       unsigned int set, unsigned int clear)\n{\n\tint val = 0;\n\tunsigned long flags;\n\tint if_num;\n\tstruct hso_serial *serial = tty->driver_data;\n\tstruct usb_interface *interface;\n\n\t \n\tif (!serial) {\n\t\thso_dbg(0x1, \"no tty structures\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((serial->parent->port_spec & HSO_PORT_MASK) != HSO_PORT_MODEM)\n\t\treturn -EINVAL;\n\n\tinterface = serial->parent->interface;\n\tif_num = interface->cur_altsetting->desc.bInterfaceNumber;\n\n\tspin_lock_irqsave(&serial->serial_lock, flags);\n\tif (set & TIOCM_RTS)\n\t\tserial->rts_state = 1;\n\tif (set & TIOCM_DTR)\n\t\tserial->dtr_state = 1;\n\n\tif (clear & TIOCM_RTS)\n\t\tserial->rts_state = 0;\n\tif (clear & TIOCM_DTR)\n\t\tserial->dtr_state = 0;\n\n\tif (serial->dtr_state)\n\t\tval |= 0x01;\n\tif (serial->rts_state)\n\t\tval |= 0x02;\n\n\tspin_unlock_irqrestore(&serial->serial_lock, flags);\n\n\treturn usb_control_msg(serial->parent->usb,\n\t\t\t       usb_sndctrlpipe(serial->parent->usb, 0), 0x22,\n\t\t\t       0x21, val, if_num, NULL, 0,\n\t\t\t       USB_CTRL_SET_TIMEOUT);\n}\n\nstatic int hso_serial_ioctl(struct tty_struct *tty,\n\t\t\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct hso_serial *serial = tty->driver_data;\n\tint ret = 0;\n\thso_dbg(0x8, \"IOCTL cmd: %d, arg: %ld\\n\", cmd, arg);\n\n\tif (!serial)\n\t\treturn -ENODEV;\n\tswitch (cmd) {\n\tcase TIOCMIWAIT:\n\t\tret = hso_wait_modem_status(serial, arg);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n\n \nstatic void hso_kick_transmit(struct hso_serial *serial)\n{\n\tunsigned long flags;\n\tint res;\n\n\tspin_lock_irqsave(&serial->serial_lock, flags);\n\tif (!serial->tx_buffer_count)\n\t\tgoto out;\n\n\tif (serial->tx_urb_used)\n\t\tgoto out;\n\n\t \n\tif (hso_get_activity(serial->parent) == -EAGAIN)\n\t\tgoto out;\n\n\t \n\tswap(serial->tx_buffer, serial->tx_data);\n\tserial->tx_data_count = serial->tx_buffer_count;\n\tserial->tx_buffer_count = 0;\n\n\t \n\tif (serial->tx_data && serial->write_data) {\n\t\tres = serial->write_data(serial);\n\t\tif (res >= 0)\n\t\t\tserial->tx_urb_used = 1;\n\t}\nout:\n\tspin_unlock_irqrestore(&serial->serial_lock, flags);\n}\n\n \nstatic int mux_device_request(struct hso_serial *serial, u8 type, u16 port,\n\t\t\t      struct urb *ctrl_urb,\n\t\t\t      struct usb_ctrlrequest *ctrl_req,\n\t\t\t      u8 *ctrl_urb_data, u32 size)\n{\n\tint result;\n\tint pipe;\n\n\t \n\tif (!serial || !ctrl_urb || !ctrl_req) {\n\t\tpr_err(\"%s: Wrong arguments\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tctrl_req->wValue = 0;\n\tctrl_req->wIndex = cpu_to_le16(hso_port_to_mux(port));\n\tctrl_req->wLength = cpu_to_le16(size);\n\n\tif (type == USB_CDC_GET_ENCAPSULATED_RESPONSE) {\n\t\t \n\t\tctrl_req->bRequestType = USB_DIR_IN |\n\t\t\t\t\t USB_TYPE_OPTION_VENDOR |\n\t\t\t\t\t USB_RECIP_INTERFACE;\n\t\tctrl_req->bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;\n\t\tpipe = usb_rcvctrlpipe(serial->parent->usb, 0);\n\t} else {\n\t\t \n\t\tctrl_req->bRequestType = USB_DIR_OUT |\n\t\t\t\t\t USB_TYPE_OPTION_VENDOR |\n\t\t\t\t\t USB_RECIP_INTERFACE;\n\t\tctrl_req->bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;\n\t\tpipe = usb_sndctrlpipe(serial->parent->usb, 0);\n\t}\n\t \n\thso_dbg(0x2, \"%s command (%02x) len: %d, port: %d\\n\",\n\t\ttype == USB_CDC_GET_ENCAPSULATED_RESPONSE ? \"Read\" : \"Write\",\n\t\tctrl_req->bRequestType, ctrl_req->wLength, port);\n\n\t \n\tctrl_urb->transfer_flags = 0;\n\tusb_fill_control_urb(ctrl_urb,\n\t\t\t     serial->parent->usb,\n\t\t\t     pipe,\n\t\t\t     (u8 *) ctrl_req,\n\t\t\t     ctrl_urb_data, size, ctrl_callback, serial);\n\t \n\tresult = usb_submit_urb(ctrl_urb, GFP_ATOMIC);\n\tif (result) {\n\t\tdev_err(&ctrl_urb->dev->dev,\n\t\t\t\"%s failed submit ctrl_urb %d type %d\\n\", __func__,\n\t\t\tresult, type);\n\t\treturn result;\n\t}\n\n\t \n\treturn size;\n}\n\n \nstatic int hso_mux_serial_read(struct hso_serial *serial)\n{\n\tif (!serial)\n\t\treturn -EINVAL;\n\n\t \n\tmemset(serial->rx_data[0], 0, CTRL_URB_RX_SIZE);\n\t \n\n\tif (serial->num_rx_urbs != 1) {\n\t\tdev_err(&serial->parent->interface->dev,\n\t\t\t\"ERROR: mux'd reads with multiple buffers \"\n\t\t\t\"not possible\\n\");\n\t\treturn 0;\n\t}\n\treturn mux_device_request(serial,\n\t\t\t\t  USB_CDC_GET_ENCAPSULATED_RESPONSE,\n\t\t\t\t  serial->parent->port_spec & HSO_PORT_MASK,\n\t\t\t\t  serial->rx_urb[0],\n\t\t\t\t  &serial->ctrl_req_rx,\n\t\t\t\t  serial->rx_data[0], serial->rx_data_length);\n}\n\n \nstatic void intr_callback(struct urb *urb)\n{\n\tstruct hso_shared_int *shared_int = urb->context;\n\tstruct hso_serial *serial;\n\tunsigned char *port_req;\n\tint status = urb->status;\n\tunsigned long flags;\n\tint i;\n\n\tusb_mark_last_busy(urb->dev);\n\n\t \n\tif (!shared_int)\n\t\treturn;\n\n\t \n\tif (status) {\n\t\thandle_usb_error(status, __func__, NULL);\n\t\treturn;\n\t}\n\thso_dbg(0x8, \"--- Got intr callback 0x%02X ---\\n\", status);\n\n\t \n\tport_req = urb->transfer_buffer;\n\thso_dbg(0x8, \"port_req = 0x%.2X\\n\", *port_req);\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\t \n\t\tif (*port_req & (1 << i)) {\n\t\t\tserial = get_serial_by_shared_int_and_type(shared_int,\n\t\t\t\t\t\t\t\t   (1 << i));\n\t\t\tif (serial != NULL) {\n\t\t\t\thso_dbg(0x1, \"Pending read interrupt on port %d\\n\",\n\t\t\t\t\ti);\n\t\t\t\tspin_lock_irqsave(&serial->serial_lock, flags);\n\t\t\t\tif (serial->rx_state == RX_IDLE &&\n\t\t\t\t\tserial->port.count > 0) {\n\t\t\t\t\t \n\t\t\t\t\tif (!serial->rx_urb_filled[0]) {\n\t\t\t\t\t\tserial->rx_state = RX_SENT;\n\t\t\t\t\t\thso_mux_serial_read(serial);\n\t\t\t\t\t} else\n\t\t\t\t\t\tserial->rx_state = RX_PENDING;\n\t\t\t\t} else {\n\t\t\t\t\thso_dbg(0x1, \"Already a read pending on port %d or port not open\\n\",\n\t\t\t\t\t\ti);\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(&serial->serial_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t}\n\t\t}\n\t}\n\t \n\thso_mux_submit_intr_urb(shared_int, urb->dev, GFP_ATOMIC);\n}\n\n \nstatic int hso_mux_serial_write_data(struct hso_serial *serial)\n{\n\tif (NULL == serial)\n\t\treturn -EINVAL;\n\n\treturn mux_device_request(serial,\n\t\t\t\t  USB_CDC_SEND_ENCAPSULATED_COMMAND,\n\t\t\t\t  serial->parent->port_spec & HSO_PORT_MASK,\n\t\t\t\t  serial->tx_urb,\n\t\t\t\t  &serial->ctrl_req_tx,\n\t\t\t\t  serial->tx_data, serial->tx_data_count);\n}\n\n \nstatic void hso_std_serial_write_bulk_callback(struct urb *urb)\n{\n\tstruct hso_serial *serial = urb->context;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\t \n\tif (!serial) {\n\t\thso_dbg(0x1, \"serial == NULL\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&serial->serial_lock, flags);\n\tserial->tx_urb_used = 0;\n\tspin_unlock_irqrestore(&serial->serial_lock, flags);\n\tif (status) {\n\t\thandle_usb_error(status, __func__, serial->parent);\n\t\treturn;\n\t}\n\thso_put_activity(serial->parent);\n\ttty_port_tty_wakeup(&serial->port);\n\thso_kick_transmit(serial);\n\n\thso_dbg(0x1, \"\\n\");\n}\n\n \nstatic int hso_std_serial_write_data(struct hso_serial *serial)\n{\n\tint count = serial->tx_data_count;\n\tint result;\n\n\tusb_fill_bulk_urb(serial->tx_urb,\n\t\t\t  serial->parent->usb,\n\t\t\t  usb_sndbulkpipe(serial->parent->usb,\n\t\t\t\t\t  serial->out_endp->\n\t\t\t\t\t  bEndpointAddress & 0x7F),\n\t\t\t  serial->tx_data, serial->tx_data_count,\n\t\t\t  hso_std_serial_write_bulk_callback, serial);\n\n\tresult = usb_submit_urb(serial->tx_urb, GFP_ATOMIC);\n\tif (result) {\n\t\tdev_warn(&serial->parent->usb->dev,\n\t\t\t \"Failed to submit urb - res %d\\n\", result);\n\t\treturn result;\n\t}\n\n\treturn count;\n}\n\n \nstatic void ctrl_callback(struct urb *urb)\n{\n\tstruct hso_serial *serial = urb->context;\n\tstruct usb_ctrlrequest *req;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\t \n\tif (!serial)\n\t\treturn;\n\n\tspin_lock_irqsave(&serial->serial_lock, flags);\n\tserial->tx_urb_used = 0;\n\tspin_unlock_irqrestore(&serial->serial_lock, flags);\n\tif (status) {\n\t\thandle_usb_error(status, __func__, serial->parent);\n\t\treturn;\n\t}\n\n\t \n\treq = (struct usb_ctrlrequest *)(urb->setup_packet);\n\thso_dbg(0x8, \"--- Got muxed ctrl callback 0x%02X ---\\n\", status);\n\thso_dbg(0x8, \"Actual length of urb = %d\\n\", urb->actual_length);\n\tDUMP1(urb->transfer_buffer, urb->actual_length);\n\n\tif (req->bRequestType ==\n\t    (USB_DIR_IN | USB_TYPE_OPTION_VENDOR | USB_RECIP_INTERFACE)) {\n\t\t \n\t\tserial->rx_urb_filled[0] = 1;\n\t\tspin_lock_irqsave(&serial->serial_lock, flags);\n\t\tput_rxbuf_data_and_resubmit_ctrl_urb(serial);\n\t\tspin_unlock_irqrestore(&serial->serial_lock, flags);\n\t} else {\n\t\thso_put_activity(serial->parent);\n\t\ttty_port_tty_wakeup(&serial->port);\n\t\t \n\t\thso_kick_transmit(serial);\n\t}\n}\n\n \nstatic int put_rxbuf_data(struct urb *urb, struct hso_serial *serial)\n{\n\tstruct tty_struct *tty;\n\tint count;\n\n\t \n\tif (urb == NULL || serial == NULL) {\n\t\thso_dbg(0x1, \"serial = NULL\\n\");\n\t\treturn -2;\n\t}\n\n\ttty = tty_port_tty_get(&serial->port);\n\n\tif (tty && tty_throttled(tty)) {\n\t\ttty_kref_put(tty);\n\t\treturn -1;\n\t}\n\n\t \n\thso_dbg(0x1, \"data to push to tty\\n\");\n\tcount = tty_buffer_request_room(&serial->port, urb->actual_length);\n\tif (count >= urb->actual_length) {\n\t\ttty_insert_flip_string(&serial->port, urb->transfer_buffer,\n\t\t\t\t       urb->actual_length);\n\t\ttty_flip_buffer_push(&serial->port);\n\t} else {\n\t\tdev_warn(&serial->parent->usb->dev,\n\t\t\t \"dropping data, %d bytes lost\\n\", urb->actual_length);\n\t}\n\n\ttty_kref_put(tty);\n\n\tserial->rx_urb_filled[hso_urb_to_index(serial, urb)] = 0;\n\n\treturn 0;\n}\n\n\n \n\nstatic void hso_log_port(struct hso_device *hso_dev)\n{\n\tchar *port_type;\n\tchar port_dev[20];\n\n\tswitch (hso_dev->port_spec & HSO_PORT_MASK) {\n\tcase HSO_PORT_CONTROL:\n\t\tport_type = \"Control\";\n\t\tbreak;\n\tcase HSO_PORT_APP:\n\t\tport_type = \"Application\";\n\t\tbreak;\n\tcase HSO_PORT_GPS:\n\t\tport_type = \"GPS\";\n\t\tbreak;\n\tcase HSO_PORT_GPS_CONTROL:\n\t\tport_type = \"GPS control\";\n\t\tbreak;\n\tcase HSO_PORT_APP2:\n\t\tport_type = \"Application2\";\n\t\tbreak;\n\tcase HSO_PORT_PCSC:\n\t\tport_type = \"PCSC\";\n\t\tbreak;\n\tcase HSO_PORT_DIAG:\n\t\tport_type = \"Diagnostic\";\n\t\tbreak;\n\tcase HSO_PORT_DIAG2:\n\t\tport_type = \"Diagnostic2\";\n\t\tbreak;\n\tcase HSO_PORT_MODEM:\n\t\tport_type = \"Modem\";\n\t\tbreak;\n\tcase HSO_PORT_NETWORK:\n\t\tport_type = \"Network\";\n\t\tbreak;\n\tdefault:\n\t\tport_type = \"Unknown\";\n\t\tbreak;\n\t}\n\tif ((hso_dev->port_spec & HSO_PORT_MASK) == HSO_PORT_NETWORK) {\n\t\tsprintf(port_dev, \"%s\", dev2net(hso_dev)->net->name);\n\t} else\n\t\tsprintf(port_dev, \"/dev/%s%d\", tty_filename,\n\t\t\tdev2ser(hso_dev)->minor);\n\n\tdev_dbg(&hso_dev->interface->dev, \"HSO: Found %s port %s\\n\",\n\t\tport_type, port_dev);\n}\n\nstatic int hso_start_net_device(struct hso_device *hso_dev)\n{\n\tint i, result = 0;\n\tstruct hso_net *hso_net = dev2net(hso_dev);\n\n\tif (!hso_net)\n\t\treturn -ENODEV;\n\n\t \n\tfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\n\n\t\t \n\t\tusb_fill_bulk_urb(hso_net->mux_bulk_rx_urb_pool[i],\n\t\t\t\t  hso_dev->usb,\n\t\t\t\t  usb_rcvbulkpipe(hso_dev->usb,\n\t\t\t\t\t\t  hso_net->in_endp->\n\t\t\t\t\t\t  bEndpointAddress & 0x7F),\n\t\t\t\t  hso_net->mux_bulk_rx_buf_pool[i],\n\t\t\t\t  MUX_BULK_RX_BUF_SIZE, read_bulk_callback,\n\t\t\t\t  hso_net);\n\n\t\t \n\t\tresult = usb_submit_urb(hso_net->mux_bulk_rx_urb_pool[i],\n\t\t\t\t\tGFP_NOIO);\n\t\tif (result)\n\t\t\tdev_warn(&hso_dev->usb->dev,\n\t\t\t\t\"%s failed mux_bulk_rx_urb[%d] %d\\n\", __func__,\n\t\t\t\ti, result);\n\t}\n\n\treturn result;\n}\n\nstatic int hso_stop_net_device(struct hso_device *hso_dev)\n{\n\tint i;\n\tstruct hso_net *hso_net = dev2net(hso_dev);\n\n\tif (!hso_net)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\n\t\tif (hso_net->mux_bulk_rx_urb_pool[i])\n\t\t\tusb_kill_urb(hso_net->mux_bulk_rx_urb_pool[i]);\n\n\t}\n\tif (hso_net->mux_bulk_tx_urb)\n\t\tusb_kill_urb(hso_net->mux_bulk_tx_urb);\n\n\treturn 0;\n}\n\nstatic int hso_start_serial_device(struct hso_device *hso_dev, gfp_t flags)\n{\n\tint i, result = 0;\n\tstruct hso_serial *serial = dev2ser(hso_dev);\n\n\tif (!serial)\n\t\treturn -ENODEV;\n\n\t \n\tif (!(serial->parent->port_spec & HSO_INTF_MUX)) {\n\t\tfor (i = 0; i < serial->num_rx_urbs; i++) {\n\t\t\tusb_fill_bulk_urb(serial->rx_urb[i],\n\t\t\t\t\t  serial->parent->usb,\n\t\t\t\t\t  usb_rcvbulkpipe(serial->parent->usb,\n\t\t\t\t\t\t\t  serial->in_endp->\n\t\t\t\t\t\t\t  bEndpointAddress &\n\t\t\t\t\t\t\t  0x7F),\n\t\t\t\t\t  serial->rx_data[i],\n\t\t\t\t\t  serial->rx_data_length,\n\t\t\t\t\t  hso_std_serial_read_bulk_callback,\n\t\t\t\t\t  serial);\n\t\t\tresult = usb_submit_urb(serial->rx_urb[i], flags);\n\t\t\tif (result) {\n\t\t\t\tdev_warn(&serial->parent->usb->dev,\n\t\t\t\t\t \"Failed to submit urb - res %d\\n\",\n\t\t\t\t\t result);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmutex_lock(&serial->shared_int->shared_int_lock);\n\t\tif (!serial->shared_int->use_count) {\n\t\t\tresult =\n\t\t\t    hso_mux_submit_intr_urb(serial->shared_int,\n\t\t\t\t\t\t    hso_dev->usb, flags);\n\t\t}\n\t\tserial->shared_int->use_count++;\n\t\tmutex_unlock(&serial->shared_int->shared_int_lock);\n\t}\n\tif (serial->tiocmget)\n\t\ttiocmget_submit_urb(serial,\n\t\t\t\t    serial->tiocmget,\n\t\t\t\t    serial->parent->usb);\n\treturn result;\n}\n\nstatic int hso_stop_serial_device(struct hso_device *hso_dev)\n{\n\tint i;\n\tstruct hso_serial *serial = dev2ser(hso_dev);\n\tstruct hso_tiocmget  *tiocmget;\n\n\tif (!serial)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < serial->num_rx_urbs; i++) {\n\t\tif (serial->rx_urb[i]) {\n\t\t\tusb_kill_urb(serial->rx_urb[i]);\n\t\t\tserial->rx_urb_filled[i] = 0;\n\t\t}\n\t}\n\tserial->curr_rx_urb_idx = 0;\n\n\tif (serial->tx_urb)\n\t\tusb_kill_urb(serial->tx_urb);\n\n\tif (serial->shared_int) {\n\t\tmutex_lock(&serial->shared_int->shared_int_lock);\n\t\tif (serial->shared_int->use_count &&\n\t\t    (--serial->shared_int->use_count == 0)) {\n\t\t\tstruct urb *urb;\n\n\t\t\turb = serial->shared_int->shared_intr_urb;\n\t\t\tif (urb)\n\t\t\t\tusb_kill_urb(urb);\n\t\t}\n\t\tmutex_unlock(&serial->shared_int->shared_int_lock);\n\t}\n\ttiocmget = serial->tiocmget;\n\tif (tiocmget) {\n\t\twake_up_interruptible(&tiocmget->waitq);\n\t\tusb_kill_urb(tiocmget->urb);\n\t}\n\n\treturn 0;\n}\n\nstatic void hso_serial_tty_unregister(struct hso_serial *serial)\n{\n\ttty_unregister_device(tty_drv, serial->minor);\n\trelease_minor(serial);\n}\n\nstatic void hso_serial_common_free(struct hso_serial *serial)\n{\n\tint i;\n\n\tfor (i = 0; i < serial->num_rx_urbs; i++) {\n\t\t \n\t\tusb_free_urb(serial->rx_urb[i]);\n\t\t \n\t\tkfree(serial->rx_data[i]);\n\t}\n\n\t \n\tusb_free_urb(serial->tx_urb);\n\tkfree(serial->tx_buffer);\n\tkfree(serial->tx_data);\n\ttty_port_destroy(&serial->port);\n}\n\nstatic int hso_serial_common_create(struct hso_serial *serial, int num_urbs,\n\t\t\t\t    int rx_size, int tx_size)\n{\n\tint i;\n\n\ttty_port_init(&serial->port);\n\n\tif (obtain_minor(serial))\n\t\tgoto exit2;\n\n\t \n\tserial->parent->dev = tty_port_register_device_attr(&serial->port,\n\t\t\ttty_drv, serial->minor, &serial->parent->interface->dev,\n\t\t\tserial->parent, hso_serial_dev_groups);\n\tif (IS_ERR(serial->parent->dev)) {\n\t\trelease_minor(serial);\n\t\tgoto exit2;\n\t}\n\n\tserial->magic = HSO_SERIAL_MAGIC;\n\tspin_lock_init(&serial->serial_lock);\n\tserial->num_rx_urbs = num_urbs;\n\n\t \n\n\t \n\tserial->rx_data_length = rx_size;\n\tfor (i = 0; i < serial->num_rx_urbs; i++) {\n\t\tserial->rx_urb[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!serial->rx_urb[i])\n\t\t\tgoto exit;\n\t\tserial->rx_urb[i]->transfer_buffer = NULL;\n\t\tserial->rx_urb[i]->transfer_buffer_length = 0;\n\t\tserial->rx_data[i] = kzalloc(serial->rx_data_length,\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!serial->rx_data[i])\n\t\t\tgoto exit;\n\t}\n\n\t \n\tserial->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!serial->tx_urb)\n\t\tgoto exit;\n\tserial->tx_urb->transfer_buffer = NULL;\n\tserial->tx_urb->transfer_buffer_length = 0;\n\t \n\tserial->tx_data_count = 0;\n\tserial->tx_buffer_count = 0;\n\tserial->tx_data_length = tx_size;\n\tserial->tx_data = kzalloc(serial->tx_data_length, GFP_KERNEL);\n\tif (!serial->tx_data)\n\t\tgoto exit;\n\n\tserial->tx_buffer = kzalloc(serial->tx_data_length, GFP_KERNEL);\n\tif (!serial->tx_buffer)\n\t\tgoto exit;\n\n\treturn 0;\nexit:\n\thso_serial_tty_unregister(serial);\nexit2:\n\thso_serial_common_free(serial);\n\treturn -1;\n}\n\n \nstatic struct hso_device *hso_create_device(struct usb_interface *intf,\n\t\t\t\t\t    int port_spec)\n{\n\tstruct hso_device *hso_dev;\n\n\thso_dev = kzalloc(sizeof(*hso_dev), GFP_KERNEL);\n\tif (!hso_dev)\n\t\treturn NULL;\n\n\thso_dev->port_spec = port_spec;\n\thso_dev->usb = interface_to_usbdev(intf);\n\thso_dev->interface = intf;\n\tkref_init(&hso_dev->ref);\n\tmutex_init(&hso_dev->mutex);\n\n\tINIT_WORK(&hso_dev->async_get_intf, async_get_intf);\n\tINIT_WORK(&hso_dev->async_put_intf, async_put_intf);\n\n\treturn hso_dev;\n}\n\n \nstatic int remove_net_device(struct hso_device *hso_dev)\n{\n\tint i;\n\n\tfor (i = 0; i < HSO_MAX_NET_DEVICES; i++) {\n\t\tif (network_table[i] == hso_dev) {\n\t\t\tnetwork_table[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == HSO_MAX_NET_DEVICES)\n\t\treturn -1;\n\treturn 0;\n}\n\n \nstatic void hso_free_net_device(struct hso_device *hso_dev)\n{\n\tint i;\n\tstruct hso_net *hso_net = dev2net(hso_dev);\n\n\tif (!hso_net)\n\t\treturn;\n\n\tremove_net_device(hso_net->parent);\n\n\tif (hso_net->net)\n\t\tunregister_netdev(hso_net->net);\n\n\t \n\tfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\n\t\tusb_free_urb(hso_net->mux_bulk_rx_urb_pool[i]);\n\t\tkfree(hso_net->mux_bulk_rx_buf_pool[i]);\n\t\thso_net->mux_bulk_rx_buf_pool[i] = NULL;\n\t}\n\tusb_free_urb(hso_net->mux_bulk_tx_urb);\n\tkfree(hso_net->mux_bulk_tx_buf);\n\thso_net->mux_bulk_tx_buf = NULL;\n\n\tif (hso_net->net)\n\t\tfree_netdev(hso_net->net);\n\n\tkfree(hso_dev);\n}\n\nstatic const struct net_device_ops hso_netdev_ops = {\n\t.ndo_open\t= hso_net_open,\n\t.ndo_stop\t= hso_net_close,\n\t.ndo_start_xmit = hso_net_start_xmit,\n\t.ndo_tx_timeout = hso_net_tx_timeout,\n};\n\n \nstatic void hso_net_init(struct net_device *net)\n{\n\tstruct hso_net *hso_net = netdev_priv(net);\n\n\thso_dbg(0x1, \"sizeof hso_net is %zu\\n\", sizeof(*hso_net));\n\n\t \n\tnet->netdev_ops = &hso_netdev_ops;\n\tnet->watchdog_timeo = HSO_NET_TX_TIMEOUT;\n\tnet->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\tnet->type = ARPHRD_NONE;\n\tnet->mtu = DEFAULT_MTU - 14;\n\tnet->tx_queue_len = 10;\n\tnet->ethtool_ops = &ops;\n\n\t \n\tspin_lock_init(&hso_net->net_lock);\n}\n\n \nstatic int add_net_device(struct hso_device *hso_dev)\n{\n\tint i;\n\n\tfor (i = 0; i < HSO_MAX_NET_DEVICES; i++) {\n\t\tif (network_table[i] == NULL) {\n\t\t\tnetwork_table[i] = hso_dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == HSO_MAX_NET_DEVICES)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int hso_rfkill_set_block(void *data, bool blocked)\n{\n\tstruct hso_device *hso_dev = data;\n\tint enabled = !blocked;\n\tint rv;\n\n\tmutex_lock(&hso_dev->mutex);\n\tif (hso_dev->usb_gone)\n\t\trv = 0;\n\telse\n\t\trv = usb_control_msg(hso_dev->usb, usb_sndctrlpipe(hso_dev->usb, 0),\n\t\t\t\t       enabled ? 0x82 : 0x81, 0x40, 0, 0, NULL, 0,\n\t\t\t\t       USB_CTRL_SET_TIMEOUT);\n\tmutex_unlock(&hso_dev->mutex);\n\treturn rv;\n}\n\nstatic const struct rfkill_ops hso_rfkill_ops = {\n\t.set_block = hso_rfkill_set_block,\n};\n\n \nstatic void hso_create_rfkill(struct hso_device *hso_dev,\n\t\t\t     struct usb_interface *interface)\n{\n\tstruct hso_net *hso_net = dev2net(hso_dev);\n\tstruct device *dev = &hso_net->net->dev;\n\tstatic u32 rfkill_counter;\n\n\tsnprintf(hso_net->name, sizeof(hso_net->name), \"hso-%d\",\n\t\t rfkill_counter++);\n\n\thso_net->rfkill = rfkill_alloc(hso_net->name,\n\t\t\t\t       &interface_to_usbdev(interface)->dev,\n\t\t\t\t       RFKILL_TYPE_WWAN,\n\t\t\t\t       &hso_rfkill_ops, hso_dev);\n\tif (!hso_net->rfkill)\n\t\treturn;\n\n\tif (rfkill_register(hso_net->rfkill) < 0) {\n\t\trfkill_destroy(hso_net->rfkill);\n\t\thso_net->rfkill = NULL;\n\t\tdev_err(dev, \"%s - Failed to register rfkill\\n\", __func__);\n\t\treturn;\n\t}\n}\n\nstatic struct device_type hso_type = {\n\t.name\t= \"wwan\",\n};\n\n \nstatic struct hso_device *hso_create_net_device(struct usb_interface *interface,\n\t\t\t\t\t\tint port_spec)\n{\n\tint result, i;\n\tstruct net_device *net;\n\tstruct hso_net *hso_net;\n\tstruct hso_device *hso_dev;\n\n\thso_dev = hso_create_device(interface, port_spec);\n\tif (!hso_dev)\n\t\treturn NULL;\n\n\t \n\t \n\tnet = alloc_netdev(sizeof(struct hso_net), \"hso%d\", NET_NAME_UNKNOWN,\n\t\t\t   hso_net_init);\n\tif (!net) {\n\t\tdev_err(&interface->dev, \"Unable to create ethernet device\\n\");\n\t\tgoto err_hso_dev;\n\t}\n\n\thso_net = netdev_priv(net);\n\n\thso_dev->port_data.dev_net = hso_net;\n\thso_net->net = net;\n\thso_net->parent = hso_dev;\n\n\thso_net->in_endp = hso_get_ep(interface, USB_ENDPOINT_XFER_BULK,\n\t\t\t\t      USB_DIR_IN);\n\tif (!hso_net->in_endp) {\n\t\tdev_err(&interface->dev, \"Can't find BULK IN endpoint\\n\");\n\t\tgoto err_net;\n\t}\n\thso_net->out_endp = hso_get_ep(interface, USB_ENDPOINT_XFER_BULK,\n\t\t\t\t       USB_DIR_OUT);\n\tif (!hso_net->out_endp) {\n\t\tdev_err(&interface->dev, \"Can't find BULK OUT endpoint\\n\");\n\t\tgoto err_net;\n\t}\n\tSET_NETDEV_DEV(net, &interface->dev);\n\tSET_NETDEV_DEVTYPE(net, &hso_type);\n\n\t \n\tfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\n\t\thso_net->mux_bulk_rx_urb_pool[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!hso_net->mux_bulk_rx_urb_pool[i])\n\t\t\tgoto err_mux_bulk_rx;\n\t\thso_net->mux_bulk_rx_buf_pool[i] = kzalloc(MUX_BULK_RX_BUF_SIZE,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!hso_net->mux_bulk_rx_buf_pool[i])\n\t\t\tgoto err_mux_bulk_rx;\n\t}\n\thso_net->mux_bulk_tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!hso_net->mux_bulk_tx_urb)\n\t\tgoto err_mux_bulk_rx;\n\thso_net->mux_bulk_tx_buf = kzalloc(MUX_BULK_TX_BUF_SIZE, GFP_KERNEL);\n\tif (!hso_net->mux_bulk_tx_buf)\n\t\tgoto err_free_tx_urb;\n\n\tresult = add_net_device(hso_dev);\n\tif (result) {\n\t\tdev_err(&interface->dev, \"Failed to add net device\\n\");\n\t\tgoto err_free_tx_buf;\n\t}\n\n\t \n\tresult = register_netdev(net);\n\tif (result) {\n\t\tdev_err(&interface->dev, \"Failed to register device\\n\");\n\t\tgoto err_rmv_ndev;\n\t}\n\n\thso_log_port(hso_dev);\n\n\thso_create_rfkill(hso_dev, interface);\n\n\treturn hso_dev;\n\nerr_rmv_ndev:\n\tremove_net_device(hso_dev);\nerr_free_tx_buf:\n\tkfree(hso_net->mux_bulk_tx_buf);\nerr_free_tx_urb:\n\tusb_free_urb(hso_net->mux_bulk_tx_urb);\nerr_mux_bulk_rx:\n\tfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\n\t\tusb_free_urb(hso_net->mux_bulk_rx_urb_pool[i]);\n\t\tkfree(hso_net->mux_bulk_rx_buf_pool[i]);\n\t}\nerr_net:\n\tfree_netdev(net);\nerr_hso_dev:\n\tkfree(hso_dev);\n\treturn NULL;\n}\n\nstatic void hso_free_tiomget(struct hso_serial *serial)\n{\n\tstruct hso_tiocmget *tiocmget;\n\tif (!serial)\n\t\treturn;\n\ttiocmget = serial->tiocmget;\n\tif (tiocmget) {\n\t\tusb_free_urb(tiocmget->urb);\n\t\ttiocmget->urb = NULL;\n\t\tserial->tiocmget = NULL;\n\t\tkfree(tiocmget->serial_state_notification);\n\t\ttiocmget->serial_state_notification = NULL;\n\t\tkfree(tiocmget);\n\t}\n}\n\n \nstatic void hso_free_serial_device(struct hso_device *hso_dev)\n{\n\tstruct hso_serial *serial = dev2ser(hso_dev);\n\n\tif (!serial)\n\t\treturn;\n\n\thso_serial_common_free(serial);\n\n\tif (serial->shared_int) {\n\t\tmutex_lock(&serial->shared_int->shared_int_lock);\n\t\tif (--serial->shared_int->ref_count == 0)\n\t\t\thso_free_shared_int(serial->shared_int);\n\t\telse\n\t\t\tmutex_unlock(&serial->shared_int->shared_int_lock);\n\t}\n\thso_free_tiomget(serial);\n\tkfree(serial);\n\tkfree(hso_dev);\n}\n\n \nstatic struct hso_device *hso_create_bulk_serial_device(\n\t\t\tstruct usb_interface *interface, int port)\n{\n\tstruct hso_device *hso_dev;\n\tstruct hso_serial *serial;\n\tint num_urbs;\n\tstruct hso_tiocmget *tiocmget;\n\n\thso_dev = hso_create_device(interface, port);\n\tif (!hso_dev)\n\t\treturn NULL;\n\n\tserial = kzalloc(sizeof(*serial), GFP_KERNEL);\n\tif (!serial)\n\t\tgoto exit;\n\n\tserial->parent = hso_dev;\n\thso_dev->port_data.dev_serial = serial;\n\n\tif ((port & HSO_PORT_MASK) == HSO_PORT_MODEM) {\n\t\tnum_urbs = 2;\n\t\tserial->tiocmget = kzalloc(sizeof(struct hso_tiocmget),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!serial->tiocmget)\n\t\t\tgoto exit;\n\t\tserial->tiocmget->serial_state_notification\n\t\t\t= kzalloc(sizeof(struct hso_serial_state_notification),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!serial->tiocmget->serial_state_notification)\n\t\t\tgoto exit;\n\t\ttiocmget = serial->tiocmget;\n\t\ttiocmget->endp = hso_get_ep(interface,\n\t\t\t\t\t    USB_ENDPOINT_XFER_INT,\n\t\t\t\t\t    USB_DIR_IN);\n\t\tif (!tiocmget->endp) {\n\t\t\tdev_err(&interface->dev, \"Failed to find INT IN ep\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttiocmget->urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!tiocmget->urb)\n\t\t\tgoto exit;\n\n\t\tmutex_init(&tiocmget->mutex);\n\t\tinit_waitqueue_head(&tiocmget->waitq);\n\t} else {\n\t\tnum_urbs = 1;\n\t}\n\n\tif (hso_serial_common_create(serial, num_urbs, BULK_URB_RX_SIZE,\n\t\t\t\t     BULK_URB_TX_SIZE))\n\t\tgoto exit;\n\n\tserial->in_endp = hso_get_ep(interface, USB_ENDPOINT_XFER_BULK,\n\t\t\t\t     USB_DIR_IN);\n\tif (!serial->in_endp) {\n\t\tdev_err(&interface->dev, \"Failed to find BULK IN ep\\n\");\n\t\tgoto exit2;\n\t}\n\n\tif (!\n\t    (serial->out_endp =\n\t     hso_get_ep(interface, USB_ENDPOINT_XFER_BULK, USB_DIR_OUT))) {\n\t\tdev_err(&interface->dev, \"Failed to find BULK OUT ep\\n\");\n\t\tgoto exit2;\n\t}\n\n\tserial->write_data = hso_std_serial_write_data;\n\n\t \n\thso_log_port(hso_dev);\n\n\t \n\treturn hso_dev;\n\nexit2:\n\thso_serial_tty_unregister(serial);\n\thso_serial_common_free(serial);\nexit:\n\thso_free_tiomget(serial);\n\tkfree(serial);\n\tkfree(hso_dev);\n\treturn NULL;\n}\n\n \nstatic\nstruct hso_device *hso_create_mux_serial_device(struct usb_interface *interface,\n\t\t\t\t\t\tint port,\n\t\t\t\t\t\tstruct hso_shared_int *mux)\n{\n\tstruct hso_device *hso_dev;\n\tstruct hso_serial *serial;\n\tint port_spec;\n\n\tport_spec = HSO_INTF_MUX;\n\tport_spec &= ~HSO_PORT_MASK;\n\n\tport_spec |= hso_mux_to_port(port);\n\tif ((port_spec & HSO_PORT_MASK) == HSO_PORT_NO_PORT)\n\t\treturn NULL;\n\n\thso_dev = hso_create_device(interface, port_spec);\n\tif (!hso_dev)\n\t\treturn NULL;\n\n\tserial = kzalloc(sizeof(*serial), GFP_KERNEL);\n\tif (!serial)\n\t\tgoto err_free_dev;\n\n\thso_dev->port_data.dev_serial = serial;\n\tserial->parent = hso_dev;\n\n\tif (hso_serial_common_create\n\t    (serial, 1, CTRL_URB_RX_SIZE, CTRL_URB_TX_SIZE))\n\t\tgoto err_free_serial;\n\n\tserial->tx_data_length--;\n\tserial->write_data = hso_mux_serial_write_data;\n\n\tserial->shared_int = mux;\n\tmutex_lock(&serial->shared_int->shared_int_lock);\n\tserial->shared_int->ref_count++;\n\tmutex_unlock(&serial->shared_int->shared_int_lock);\n\n\t \n\thso_log_port(hso_dev);\n\n\t \n\treturn hso_dev;\n\nerr_free_serial:\n\tkfree(serial);\nerr_free_dev:\n\tkfree(hso_dev);\n\treturn NULL;\n\n}\n\nstatic void hso_free_shared_int(struct hso_shared_int *mux)\n{\n\tusb_free_urb(mux->shared_intr_urb);\n\tkfree(mux->shared_intr_buf);\n\tmutex_unlock(&mux->shared_int_lock);\n\tkfree(mux);\n}\n\nstatic\nstruct hso_shared_int *hso_create_shared_int(struct usb_interface *interface)\n{\n\tstruct hso_shared_int *mux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\n\tif (!mux)\n\t\treturn NULL;\n\n\tmux->intr_endp = hso_get_ep(interface, USB_ENDPOINT_XFER_INT,\n\t\t\t\t    USB_DIR_IN);\n\tif (!mux->intr_endp) {\n\t\tdev_err(&interface->dev, \"Can't find INT IN endpoint\\n\");\n\t\tgoto exit;\n\t}\n\n\tmux->shared_intr_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!mux->shared_intr_urb)\n\t\tgoto exit;\n\tmux->shared_intr_buf =\n\t\tkzalloc(le16_to_cpu(mux->intr_endp->wMaxPacketSize),\n\t\t\tGFP_KERNEL);\n\tif (!mux->shared_intr_buf)\n\t\tgoto exit;\n\n\tmutex_init(&mux->shared_int_lock);\n\n\treturn mux;\n\nexit:\n\tkfree(mux->shared_intr_buf);\n\tusb_free_urb(mux->shared_intr_urb);\n\tkfree(mux);\n\treturn NULL;\n}\n\n \nstatic int hso_get_config_data(struct usb_interface *interface)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(interface);\n\tu8 *config_data = kmalloc(17, GFP_KERNEL);\n\tu32 if_num = interface->cur_altsetting->desc.bInterfaceNumber;\n\ts32 result;\n\n\tif (!config_data)\n\t\treturn -ENOMEM;\n\tif (usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t    0x86, 0xC0, 0, 0, config_data, 17,\n\t\t\t    USB_CTRL_SET_TIMEOUT) != 0x11) {\n\t\tkfree(config_data);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (if_num > 16) {\n\t\tkfree(config_data);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (config_data[if_num]) {\n\tcase 0x0:\n\t\tresult = 0;\n\t\tbreak;\n\tcase 0x1:\n\t\tresult = HSO_PORT_DIAG;\n\t\tbreak;\n\tcase 0x2:\n\t\tresult = HSO_PORT_GPS;\n\t\tbreak;\n\tcase 0x3:\n\t\tresult = HSO_PORT_GPS_CONTROL;\n\t\tbreak;\n\tcase 0x4:\n\t\tresult = HSO_PORT_APP;\n\t\tbreak;\n\tcase 0x5:\n\t\tresult = HSO_PORT_APP2;\n\t\tbreak;\n\tcase 0x6:\n\t\tresult = HSO_PORT_CONTROL;\n\t\tbreak;\n\tcase 0x7:\n\t\tresult = HSO_PORT_NETWORK;\n\t\tbreak;\n\tcase 0x8:\n\t\tresult = HSO_PORT_MODEM;\n\t\tbreak;\n\tcase 0x9:\n\t\tresult = HSO_PORT_MSD;\n\t\tbreak;\n\tcase 0xa:\n\t\tresult = HSO_PORT_PCSC;\n\t\tbreak;\n\tcase 0xb:\n\t\tresult = HSO_PORT_VOICE;\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t}\n\n\tif (result)\n\t\tresult |= HSO_INTF_BULK;\n\n\tif (config_data[16] & 0x1)\n\t\tresult |= HSO_INFO_CRC_BUG;\n\n\tkfree(config_data);\n\treturn result;\n}\n\n \nstatic int hso_probe(struct usb_interface *interface,\n\t\t     const struct usb_device_id *id)\n{\n\tint mux, i, if_num, port_spec;\n\tunsigned char port_mask;\n\tstruct hso_device *hso_dev = NULL;\n\tstruct hso_shared_int *shared_int;\n\tstruct hso_device *tmp_dev = NULL;\n\n\tif (interface->cur_altsetting->desc.bInterfaceClass != 0xFF) {\n\t\tdev_err(&interface->dev, \"Not our interface\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif_num = interface->cur_altsetting->desc.bInterfaceNumber;\n\n\t \n\tif (id->driver_info) {\n\t\t \n\t\tfor (i = 0; i <= if_num; ++i)\n\t\t\tif (((u32 *)(id->driver_info))[i] == 0)\n\t\t\t\tgoto exit;\n\t\tport_spec = ((u32 *)(id->driver_info))[if_num];\n\t} else {\n\t\tport_spec = hso_get_config_data(interface);\n\t\tif (port_spec < 0)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tif (interface->num_altsetting > 1)\n\t\tusb_set_interface(interface_to_usbdev(interface), if_num, 1);\n\tinterface->needs_remote_wakeup = 1;\n\n\t \n\tswitch (port_spec & HSO_INTF_MASK) {\n\tcase HSO_INTF_MUX:\n\t\tif ((port_spec & HSO_PORT_MASK) == HSO_PORT_NETWORK) {\n\t\t\t \n\t\t\tif (!disable_net) {\n\t\t\t\thso_dev = hso_create_net_device(interface,\n\t\t\t\t\t\t\t\tport_spec);\n\t\t\t\tif (!hso_dev)\n\t\t\t\t\tgoto exit;\n\t\t\t\ttmp_dev = hso_dev;\n\t\t\t}\n\t\t}\n\n\t\tif (hso_get_mux_ports(interface, &port_mask))\n\t\t\t \n\t\t\tgoto exit;\n\n\t\tshared_int = hso_create_shared_int(interface);\n\t\tif (!shared_int)\n\t\t\tgoto exit;\n\n\t\tfor (i = 1, mux = 0; i < 0x100; i = i << 1, mux++) {\n\t\t\tif (port_mask & i) {\n\t\t\t\thso_dev = hso_create_mux_serial_device(\n\t\t\t\t\t\tinterface, i, shared_int);\n\t\t\t\tif (!hso_dev)\n\t\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp_dev)\n\t\t\thso_dev = tmp_dev;\n\t\tbreak;\n\n\tcase HSO_INTF_BULK:\n\t\t \n\t\tif ((port_spec & HSO_PORT_MASK) == HSO_PORT_NETWORK) {\n\t\t\tif (!disable_net)\n\t\t\t\thso_dev =\n\t\t\t\t    hso_create_net_device(interface, port_spec);\n\t\t} else {\n\t\t\thso_dev =\n\t\t\t    hso_create_bulk_serial_device(interface, port_spec);\n\t\t}\n\t\tif (!hso_dev)\n\t\t\tgoto exit;\n\t\tbreak;\n\tdefault:\n\t\tgoto exit;\n\t}\n\n\t \n\tusb_set_intfdata(interface, hso_dev);\n\n\t \n\treturn 0;\nexit:\n\thso_free_interface(interface);\n\treturn -ENODEV;\n}\n\n \nstatic void hso_disconnect(struct usb_interface *interface)\n{\n\thso_free_interface(interface);\n\n\t \n\tusb_set_intfdata(interface, NULL);\n}\n\nstatic void async_get_intf(struct work_struct *data)\n{\n\tstruct hso_device *hso_dev =\n\t    container_of(data, struct hso_device, async_get_intf);\n\tusb_autopm_get_interface(hso_dev->interface);\n}\n\nstatic void async_put_intf(struct work_struct *data)\n{\n\tstruct hso_device *hso_dev =\n\t    container_of(data, struct hso_device, async_put_intf);\n\tusb_autopm_put_interface(hso_dev->interface);\n}\n\nstatic int hso_get_activity(struct hso_device *hso_dev)\n{\n\tif (hso_dev->usb->state == USB_STATE_SUSPENDED) {\n\t\tif (!hso_dev->is_active) {\n\t\t\thso_dev->is_active = 1;\n\t\t\tschedule_work(&hso_dev->async_get_intf);\n\t\t}\n\t}\n\n\tif (hso_dev->usb->state != USB_STATE_CONFIGURED)\n\t\treturn -EAGAIN;\n\n\tusb_mark_last_busy(hso_dev->usb);\n\n\treturn 0;\n}\n\nstatic int hso_put_activity(struct hso_device *hso_dev)\n{\n\tif (hso_dev->usb->state != USB_STATE_SUSPENDED) {\n\t\tif (hso_dev->is_active) {\n\t\t\thso_dev->is_active = 0;\n\t\t\tschedule_work(&hso_dev->async_put_intf);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\thso_dev->is_active = 0;\n\treturn 0;\n}\n\n \nstatic int hso_suspend(struct usb_interface *iface, pm_message_t message)\n{\n\tint i, result;\n\n\t \n\tfor (i = 0; i < HSO_SERIAL_TTY_MINORS; i++) {\n\t\tif (serial_table[i] && (serial_table[i]->interface == iface)) {\n\t\t\tresult = hso_stop_serial_device(serial_table[i]);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < HSO_MAX_NET_DEVICES; i++) {\n\t\tif (network_table[i] &&\n\t\t    (network_table[i]->interface == iface)) {\n\t\t\tresult = hso_stop_net_device(network_table[i]);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn 0;\n}\n\n \nstatic int hso_resume(struct usb_interface *iface)\n{\n\tint i, result = 0;\n\tstruct hso_net *hso_net;\n\n\t \n\tfor (i = 0; i < HSO_SERIAL_TTY_MINORS; i++) {\n\t\tif (serial_table[i] && (serial_table[i]->interface == iface)) {\n\t\t\tif (dev2ser(serial_table[i])->port.count) {\n\t\t\t\tresult =\n\t\t\t\t    hso_start_serial_device(serial_table[i], GFP_NOIO);\n\t\t\t\thso_kick_transmit(dev2ser(serial_table[i]));\n\t\t\t\tif (result)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < HSO_MAX_NET_DEVICES; i++) {\n\t\tif (network_table[i] &&\n\t\t    (network_table[i]->interface == iface)) {\n\t\t\thso_net = dev2net(network_table[i]);\n\t\t\tif (hso_net->flags & IFF_UP) {\n\t\t\t\t \n\t\t\t\tif (hso_net->skb_tx_buf) {\n\t\t\t\t\tdev_dbg(&iface->dev,\n\t\t\t\t\t\t\"Transmitting\"\n\t\t\t\t\t\t\" lingering data\\n\");\n\t\t\t\t\thso_net_start_xmit(hso_net->skb_tx_buf,\n\t\t\t\t\t\t\t   hso_net->net);\n\t\t\t\t\thso_net->skb_tx_buf = NULL;\n\t\t\t\t}\n\t\t\t\tresult = hso_start_net_device(network_table[i]);\n\t\t\t\tif (result)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\treturn result;\n}\n\nstatic void hso_serial_ref_free(struct kref *ref)\n{\n\tstruct hso_device *hso_dev = container_of(ref, struct hso_device, ref);\n\n\thso_free_serial_device(hso_dev);\n}\n\nstatic void hso_free_interface(struct usb_interface *interface)\n{\n\tstruct hso_serial *serial;\n\tint i;\n\n\tfor (i = 0; i < HSO_SERIAL_TTY_MINORS; i++) {\n\t\tif (serial_table[i] &&\n\t\t    (serial_table[i]->interface == interface)) {\n\t\t\tserial = dev2ser(serial_table[i]);\n\t\t\ttty_port_tty_hangup(&serial->port, false);\n\t\t\tmutex_lock(&serial->parent->mutex);\n\t\t\tserial->parent->usb_gone = 1;\n\t\t\tmutex_unlock(&serial->parent->mutex);\n\t\t\tcancel_work_sync(&serial_table[i]->async_put_intf);\n\t\t\tcancel_work_sync(&serial_table[i]->async_get_intf);\n\t\t\thso_serial_tty_unregister(serial);\n\t\t\tkref_put(&serial->parent->ref, hso_serial_ref_free);\n\t\t}\n\t}\n\n\tfor (i = 0; i < HSO_MAX_NET_DEVICES; i++) {\n\t\tif (network_table[i] &&\n\t\t    (network_table[i]->interface == interface)) {\n\t\t\tstruct rfkill *rfk = dev2net(network_table[i])->rfkill;\n\t\t\t \n\t\t\tnetif_stop_queue(dev2net(network_table[i])->net);\n\t\t\thso_stop_net_device(network_table[i]);\n\t\t\tcancel_work_sync(&network_table[i]->async_put_intf);\n\t\t\tcancel_work_sync(&network_table[i]->async_get_intf);\n\t\t\tif (rfk) {\n\t\t\t\trfkill_unregister(rfk);\n\t\t\t\trfkill_destroy(rfk);\n\t\t\t}\n\t\t\thso_free_net_device(network_table[i]);\n\t\t}\n\t}\n}\n\n \n\n \nstatic struct usb_endpoint_descriptor *hso_get_ep(struct usb_interface *intf,\n\t\t\t\t\t\t  int type, int dir)\n{\n\tint i;\n\tstruct usb_host_interface *iface = intf->cur_altsetting;\n\tstruct usb_endpoint_descriptor *endp;\n\n\tfor (i = 0; i < iface->desc.bNumEndpoints; i++) {\n\t\tendp = &iface->endpoint[i].desc;\n\t\tif (((endp->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == dir) &&\n\t\t    (usb_endpoint_type(endp) == type))\n\t\t\treturn endp;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int hso_get_mux_ports(struct usb_interface *intf, unsigned char *ports)\n{\n\tint i;\n\tstruct usb_host_interface *iface = intf->cur_altsetting;\n\n\tif (iface->extralen == 3) {\n\t\t*ports = iface->extra[2];\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < iface->desc.bNumEndpoints; i++) {\n\t\tif (iface->endpoint[i].extralen == 3) {\n\t\t\t*ports = iface->endpoint[i].extra[2];\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n \nstatic int hso_mux_submit_intr_urb(struct hso_shared_int *shared_int,\n\t\t\t\t   struct usb_device *usb, gfp_t gfp)\n{\n\tint result;\n\n\tusb_fill_int_urb(shared_int->shared_intr_urb, usb,\n\t\t\t usb_rcvintpipe(usb,\n\t\t\t\tshared_int->intr_endp->bEndpointAddress & 0x7F),\n\t\t\t shared_int->shared_intr_buf,\n\t\t\t 1,\n\t\t\t intr_callback, shared_int,\n\t\t\t shared_int->intr_endp->bInterval);\n\n\tresult = usb_submit_urb(shared_int->shared_intr_urb, gfp);\n\tif (result)\n\t\tdev_warn(&usb->dev, \"%s failed mux_intr_urb %d\\n\", __func__,\n\t\t\tresult);\n\n\treturn result;\n}\n\n \nstatic const struct tty_operations hso_serial_ops = {\n\t.open = hso_serial_open,\n\t.close = hso_serial_close,\n\t.write = hso_serial_write,\n\t.write_room = hso_serial_write_room,\n\t.cleanup = hso_serial_cleanup,\n\t.ioctl = hso_serial_ioctl,\n\t.set_termios = hso_serial_set_termios,\n\t.chars_in_buffer = hso_serial_chars_in_buffer,\n\t.tiocmget = hso_serial_tiocmget,\n\t.tiocmset = hso_serial_tiocmset,\n\t.get_icount = hso_get_count,\n\t.unthrottle = hso_unthrottle\n};\n\nstatic struct usb_driver hso_driver = {\n\t.name = driver_name,\n\t.probe = hso_probe,\n\t.disconnect = hso_disconnect,\n\t.id_table = hso_ids,\n\t.suspend = hso_suspend,\n\t.resume = hso_resume,\n\t.reset_resume = hso_resume,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nstatic int __init hso_init(void)\n{\n\tint i;\n\tint result;\n\n\t \n\tpr_info(\"%s\\n\", version);\n\n\t \n\tfor (i = 0; i < HSO_SERIAL_TTY_MINORS; i++)\n\t\tserial_table[i] = NULL;\n\n\t \n\ttty_drv = tty_alloc_driver(HSO_SERIAL_TTY_MINORS, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(tty_drv))\n\t\treturn PTR_ERR(tty_drv);\n\n\t \n\ttty_drv->driver_name = driver_name;\n\ttty_drv->name = tty_filename;\n\n\t \n\tif (tty_major)\n\t\ttty_drv->major = tty_major;\n\n\ttty_drv->minor_start = 0;\n\ttty_drv->type = TTY_DRIVER_TYPE_SERIAL;\n\ttty_drv->subtype = SERIAL_TYPE_NORMAL;\n\ttty_drv->init_termios = tty_std_termios;\n\thso_init_termios(&tty_drv->init_termios);\n\ttty_set_operations(tty_drv, &hso_serial_ops);\n\n\t \n\tresult = tty_register_driver(tty_drv);\n\tif (result) {\n\t\tpr_err(\"%s - tty_register_driver failed(%d)\\n\",\n\t\t       __func__, result);\n\t\tgoto err_free_tty;\n\t}\n\n\t \n\tresult = usb_register(&hso_driver);\n\tif (result) {\n\t\tpr_err(\"Could not register hso driver - error: %d\\n\", result);\n\t\tgoto err_unreg_tty;\n\t}\n\n\t \n\treturn 0;\nerr_unreg_tty:\n\ttty_unregister_driver(tty_drv);\nerr_free_tty:\n\ttty_driver_kref_put(tty_drv);\n\treturn result;\n}\n\nstatic void __exit hso_exit(void)\n{\n\tpr_info(\"unloaded\\n\");\n\n\ttty_unregister_driver(tty_drv);\n\t \n\tusb_deregister(&hso_driver);\n\ttty_driver_kref_put(tty_drv);\n}\n\n \nmodule_init(hso_init);\nmodule_exit(hso_exit);\n\nMODULE_AUTHOR(MOD_AUTHOR);\nMODULE_DESCRIPTION(MOD_DESCRIPTION);\nMODULE_LICENSE(\"GPL\");\n\n \nMODULE_PARM_DESC(debug, \"debug level mask [0x01 | 0x02 | 0x04 | 0x08 | 0x10]\");\nmodule_param(debug, int, 0644);\n\n \nMODULE_PARM_DESC(tty_major, \"Set the major tty number\");\nmodule_param(tty_major, int, 0644);\n\n \nMODULE_PARM_DESC(disable_net, \"Disable the network interface\");\nmodule_param(disable_net, int, 0644);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}