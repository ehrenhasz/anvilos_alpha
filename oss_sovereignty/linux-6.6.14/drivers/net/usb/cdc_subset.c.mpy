{
  "module_name": "cdc_subset.c",
  "hash_id": "3cbe3eccb9d37b757983f016b020e6293fc0b096f138a06060fa575e14dcf853",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/cdc_subset.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/usbnet.h>\n\n\n \n\n#if defined(CONFIG_USB_EPSON2888) || defined(CONFIG_USB_ARMLINUX)\n \nstatic int always_connected (struct usbnet *dev)\n{\n\treturn 0;\n}\n#endif\n\n#ifdef\tCONFIG_USB_ALI_M5632\n#define\tHAVE_HARDWARE\n\n \n\nstatic void m5632_recover(struct usbnet *dev)\n{\n\tstruct usb_device\t*udev = dev->udev;\n\tstruct usb_interface\t*intf = dev->intf;\n\tint r;\n\n\tr = usb_lock_device_for_reset(udev, intf);\n\tif (r < 0)\n\t\treturn;\n\n\tusb_reset_device(udev);\n\tusb_unlock_device(udev);\n}\n\nstatic const struct driver_info\tali_m5632_info = {\n\t.description =\t\"ALi M5632\",\n\t.flags       = FLAG_POINTTOPOINT,\n\t.recover     = m5632_recover,\n};\n\n#endif\n\n#ifdef\tCONFIG_USB_AN2720\n#define\tHAVE_HARDWARE\n\n \n\nstatic const struct driver_info\tan2720_info = {\n\t.description =\t\"AnchorChips/Cypress 2720\",\n\t.flags       = FLAG_POINTTOPOINT,\n\t \n\t \n\n\t.in = 2, .out = 2,\t\t \n};\n\n#endif\t \n\n\n#ifdef\tCONFIG_USB_BELKIN\n#define\tHAVE_HARDWARE\n\n \n\nstatic const struct driver_info\tbelkin_info = {\n\t.description =\t\"Belkin, eTEK, or compatible\",\n\t.flags       = FLAG_POINTTOPOINT,\n};\n\n#endif\t \n\n\n\n#ifdef\tCONFIG_USB_EPSON2888\n#define\tHAVE_HARDWARE\n\n \n\nstatic const struct driver_info\tepson2888_info = {\n\t.description =\t\"Epson USB Device\",\n\t.check_connect = always_connected,\n\t.flags = FLAG_POINTTOPOINT,\n\n\t.in = 4, .out = 3,\n};\n\n#endif\t \n\n\n \n#ifdef CONFIG_USB_KC2190\n#define HAVE_HARDWARE\nstatic const struct driver_info kc2190_info = {\n\t.description =  \"KC Technology KC-190\",\n\t.flags = FLAG_POINTTOPOINT,\n};\n#endif  \n\n\n#ifdef\tCONFIG_USB_ARMLINUX\n#define\tHAVE_HARDWARE\n\n \n\nstatic const struct driver_info\tlinuxdev_info = {\n\t.description =\t\"Linux Device\",\n\t.check_connect = always_connected,\n\t.flags = FLAG_POINTTOPOINT,\n};\n\nstatic const struct driver_info\tyopy_info = {\n\t.description =\t\"Yopy\",\n\t.check_connect = always_connected,\n\t.flags = FLAG_POINTTOPOINT,\n};\n\nstatic const struct driver_info\tblob_info = {\n\t.description =\t\"Boot Loader OBject\",\n\t.check_connect = always_connected,\n\t.flags = FLAG_POINTTOPOINT,\n};\n\n#endif\t \n\n\n \n\n#ifndef\tHAVE_HARDWARE\n#warning You need to configure some hardware for this driver\n#endif\n\n \n\nstatic const struct usb_device_id\tproducts [] = {\n\n#ifdef\tCONFIG_USB_ALI_M5632\n{\n\tUSB_DEVICE (0x0402, 0x5632),\t \n\t.driver_info =\t(unsigned long) &ali_m5632_info,\n},\n{\n\tUSB_DEVICE (0x182d,0x207c),\t \n\t.driver_info =\t(unsigned long) &ali_m5632_info,\n},\n#endif\n\n#ifdef\tCONFIG_USB_AN2720\n{\n\tUSB_DEVICE (0x0547, 0x2720),\t \n\t.driver_info =\t(unsigned long) &an2720_info,\n}, {\n\tUSB_DEVICE (0x0547, 0x2727),\t \n\t.driver_info =\t(unsigned long) &an2720_info,\n},\n#endif\n\n#ifdef\tCONFIG_USB_BELKIN\n{\n\tUSB_DEVICE (0x050d, 0x0004),\t \n\t.driver_info =\t(unsigned long) &belkin_info,\n}, {\n\tUSB_DEVICE (0x056c, 0x8100),\t \n\t.driver_info =\t(unsigned long) &belkin_info,\n}, {\n\tUSB_DEVICE (0x0525, 0x9901),\t \n\t.driver_info =\t(unsigned long) &belkin_info,\n},\n#endif\n\n#ifdef\tCONFIG_USB_EPSON2888\n{\n\tUSB_DEVICE (0x0525, 0x2888),\t \n\t.driver_info\t= (unsigned long) &epson2888_info,\n},\n#endif\n\n#ifdef CONFIG_USB_KC2190\n{\n\tUSB_DEVICE (0x050f, 0x0190),\t \n\t.driver_info =\t(unsigned long) &kc2190_info,\n},\n#endif\n\n#ifdef\tCONFIG_USB_ARMLINUX\n \n{\n\t\n\t\n\tUSB_DEVICE (0x049F, 0x505A),\t\n\t.driver_info =\t(unsigned long) &linuxdev_info,\n}, {\n\tUSB_DEVICE (0x0E7E, 0x1001),\t\n\t.driver_info =\t(unsigned long) &yopy_info,\n}, {\n\tUSB_DEVICE (0x8086, 0x07d3),\t\n\t.driver_info =\t(unsigned long) &blob_info,\n}, {\n\tUSB_DEVICE (0x1286, 0x8001),    \n\t.driver_info =  (unsigned long) &blob_info,\n}, {\n\t\n\t\n\t\n\tUSB_DEVICE (0x0525, 0xa4a2),\n\t.driver_info =\t(unsigned long) &linuxdev_info,\n},\n#endif\n\n\t{ },\t\t\n};\nMODULE_DEVICE_TABLE(usb, products);\n\n \nstatic int dummy_prereset(struct usb_interface *intf)\n{\n        return 0;\n}\n\nstatic int dummy_postreset(struct usb_interface *intf)\n{\n        return 0;\n}\n\nstatic struct usb_driver cdc_subset_driver = {\n\t.name =\t\t\"cdc_subset\",\n\t.probe =\tusbnet_probe,\n\t.suspend =\tusbnet_suspend,\n\t.resume =\tusbnet_resume,\n\t.pre_reset =\tdummy_prereset,\n\t.post_reset =\tdummy_postreset,\n\t.disconnect =\tusbnet_disconnect,\n\t.id_table =\tproducts,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(cdc_subset_driver);\n\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_DESCRIPTION(\"Simple 'CDC Subset' USB networking links\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}