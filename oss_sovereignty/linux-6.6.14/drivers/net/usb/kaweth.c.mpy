{
  "module_name": "kaweth.c",
  "hash_id": "062dfe46a3cfe67f955f086cee5710e06507fa590aa36905c05908c201b126b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/kaweth.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/usb.h>\n#include <linux/types.h>\n#include <linux/ethtool.h>\n#include <linux/dma-mapping.h>\n#include <linux/wait.h>\n#include <linux/firmware.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n\n#undef DEBUG\n\n#define KAWETH_MTU\t\t\t1514\n#define KAWETH_BUF_SIZE\t\t\t1664\n#define KAWETH_TX_TIMEOUT\t\t(5 * HZ)\n#define KAWETH_SCRATCH_SIZE\t\t32\n#define KAWETH_FIRMWARE_BUF_SIZE\t4096\n#define KAWETH_CONTROL_TIMEOUT\t\t(30000)\n\n#define KAWETH_STATUS_BROKEN\t\t0x0000001\n#define KAWETH_STATUS_CLOSING\t\t0x0000002\n#define KAWETH_STATUS_SUSPENDING\t0x0000004\n\n#define KAWETH_STATUS_BLOCKED (KAWETH_STATUS_CLOSING | KAWETH_STATUS_SUSPENDING)\n\n#define KAWETH_PACKET_FILTER_PROMISCUOUS\t0x01\n#define KAWETH_PACKET_FILTER_ALL_MULTICAST\t0x02\n#define KAWETH_PACKET_FILTER_DIRECTED\t\t0x04\n#define KAWETH_PACKET_FILTER_BROADCAST\t\t0x08\n#define KAWETH_PACKET_FILTER_MULTICAST\t\t0x10\n\n \n#define KAWETH_COMMAND_GET_ETHERNET_DESC\t0x00\n#define KAWETH_COMMAND_MULTICAST_FILTERS        0x01\n#define KAWETH_COMMAND_SET_PACKET_FILTER\t0x02\n#define KAWETH_COMMAND_STATISTICS               0x03\n#define KAWETH_COMMAND_SET_TEMP_MAC     \t0x06\n#define KAWETH_COMMAND_GET_TEMP_MAC             0x07\n#define KAWETH_COMMAND_SET_URB_SIZE\t\t0x08\n#define KAWETH_COMMAND_SET_SOFS_WAIT\t\t0x09\n#define KAWETH_COMMAND_SCAN\t\t\t0xFF\n\n#define KAWETH_SOFS_TO_WAIT\t\t\t0x05\n\n#define INTBUFFERSIZE\t\t\t\t4\n\n#define STATE_OFFSET\t\t\t\t0\n#define STATE_MASK\t\t\t\t0x40\n#define\tSTATE_SHIFT\t\t\t\t5\n\n#define IS_BLOCKED(s) (s & KAWETH_STATUS_BLOCKED)\n\n\nMODULE_AUTHOR(\"Michael Zappe <zapman@interlan.net>, Stephane Alnet <stephane@u-picardie.fr>, Brad Hards <bhards@bigpond.net.au> and Oliver Neukum <oliver@neukum.org>\");\nMODULE_DESCRIPTION(\"KL5USB101 USB Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"kaweth/new_code.bin\");\nMODULE_FIRMWARE(\"kaweth/new_code_fix.bin\");\nMODULE_FIRMWARE(\"kaweth/trigger_code.bin\");\nMODULE_FIRMWARE(\"kaweth/trigger_code_fix.bin\");\n\nstatic const char driver_name[] = \"kaweth\";\n\nstatic int kaweth_probe(\n\t\tstruct usb_interface *intf,\n\t\tconst struct usb_device_id *id\t \n\t);\nstatic void kaweth_disconnect(struct usb_interface *intf);\nstatic int kaweth_suspend(struct usb_interface *intf, pm_message_t message);\nstatic int kaweth_resume(struct usb_interface *intf);\n\n \nstatic const struct usb_device_id usb_klsi_table[] = {\n\t{ USB_DEVICE(0x03e8, 0x0008) },  \n\t{ USB_DEVICE(0x04bb, 0x0901) },  \n\t{ USB_DEVICE(0x0506, 0x03e8) },  \n\t{ USB_DEVICE(0x0506, 0x11f8) },  \n\t{ USB_DEVICE(0x0557, 0x2002) },  \n\t{ USB_DEVICE(0x0557, 0x4000) },  \n\t{ USB_DEVICE(0x0565, 0x0002) },  \n\t{ USB_DEVICE(0x0565, 0x0003) },  \n\t{ USB_DEVICE(0x0565, 0x0005) },  \n\t{ USB_DEVICE(0x05e9, 0x0008) },  \n\t{ USB_DEVICE(0x05e9, 0x0009) },  \n\t{ USB_DEVICE(0x066b, 0x2202) },  \n\t{ USB_DEVICE(0x06e1, 0x0008) },  \n\t{ USB_DEVICE(0x06e1, 0x0009) },  \n\t{ USB_DEVICE(0x0707, 0x0100) },  \n\t{ USB_DEVICE(0x07aa, 0x0001) },  \n\t{ USB_DEVICE(0x07b8, 0x4000) },  \n\t{ USB_DEVICE(0x07c9, 0xb010) },  \n\t{ USB_DEVICE(0x0846, 0x1001) },  \n\t{ USB_DEVICE(0x0846, 0x1002) },  \n\t{ USB_DEVICE(0x085a, 0x0008) },  \n\t{ USB_DEVICE(0x085a, 0x0009) },  \n\t{ USB_DEVICE(0x087d, 0x5704) },  \n\t{ USB_DEVICE(0x0951, 0x0008) },  \n\t{ USB_DEVICE(0x095a, 0x3003) },  \n\t{ USB_DEVICE(0x10bd, 0x1427) },  \n\t{ USB_DEVICE(0x1342, 0x0204) },  \n\t{ USB_DEVICE(0x13d2, 0x0400) },  \n\t{ USB_DEVICE(0x1485, 0x0001) },\t \n\t{ USB_DEVICE(0x1485, 0x0002) },  \n\t{ USB_DEVICE(0x1645, 0x0005) },  \n\t{ USB_DEVICE(0x1645, 0x0008) },  \n\t{ USB_DEVICE(0x1645, 0x8005) },  \n\t{ USB_DEVICE(0x1668, 0x0323) },  \n\t{ USB_DEVICE(0x2001, 0x4000) },  \n\t{}  \n};\n\nMODULE_DEVICE_TABLE (usb, usb_klsi_table);\n\n \nstatic struct usb_driver kaweth_driver = {\n\t.name =\t\tdriver_name,\n\t.probe =\tkaweth_probe,\n\t.disconnect =\tkaweth_disconnect,\n\t.suspend =\tkaweth_suspend,\n\t.resume =\tkaweth_resume,\n\t.id_table =     usb_klsi_table,\n\t.supports_autosuspend =\t1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\ntypedef __u8 eth_addr_t[6];\n\n \nstruct usb_eth_dev {\n\tchar *name;\n\t__u16 vendor;\n\t__u16 device;\n\tvoid *pdata;\n};\n\n \nstruct kaweth_ethernet_configuration\n{\n\t__u8 size;\n\t__u8 reserved1;\n\t__u8 reserved2;\n\teth_addr_t hw_addr;\n\t__u32 statistics_mask;\n\t__le16 segment_size;\n\t__u16 max_multicast_filters;\n\t__u8 reserved3;\n} __packed;\n\n \nstruct kaweth_device\n{\n\tspinlock_t device_lock;\n\n\t__u32 status;\n\tint end;\n\tint suspend_lowmem_rx;\n\tint suspend_lowmem_ctrl;\n\tint linkstate;\n\tint opened;\n\tstruct delayed_work lowmem_work;\n\n\tstruct usb_device *dev;\n\tstruct usb_interface *intf;\n\tstruct net_device *net;\n\twait_queue_head_t term_wait;\n\n\tstruct urb *rx_urb;\n\tstruct urb *tx_urb;\n\tstruct urb *irq_urb;\n\n\tdma_addr_t intbufferhandle;\n\t__u8 *intbuffer;\n\tdma_addr_t rxbufferhandle;\n\t__u8 *rx_buf;\n\n\n\tstruct sk_buff *tx_skb;\n\n\t__u8 *firmware_buf;\n\t__u8 scratch[KAWETH_SCRATCH_SIZE];\n\t__u16 packet_filter_bitmap;\n\n\tstruct kaweth_ethernet_configuration configuration;\n};\n\n \nstatic int kaweth_read_configuration(struct kaweth_device *kaweth)\n{\n\treturn usb_control_msg(kaweth->dev, usb_rcvctrlpipe(kaweth->dev, 0),\n\t\t\t\tKAWETH_COMMAND_GET_ETHERNET_DESC,\n\t\t\t\tUSB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t0, 0,\n\t\t\t\t&kaweth->configuration,\n\t\t\t\tsizeof(kaweth->configuration),\n\t\t\t\tKAWETH_CONTROL_TIMEOUT);\n}\n\n \nstatic int kaweth_set_urb_size(struct kaweth_device *kaweth, __u16 urb_size)\n{\n\tnetdev_dbg(kaweth->net, \"Setting URB size to %d\\n\", (unsigned)urb_size);\n\n\treturn usb_control_msg(kaweth->dev, usb_sndctrlpipe(kaweth->dev, 0),\n\t\t\t       KAWETH_COMMAND_SET_URB_SIZE,\n\t\t\t       USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\n\t\t\t       urb_size, 0,\n\t\t\t       &kaweth->scratch, 0,\n\t\t\t       KAWETH_CONTROL_TIMEOUT);\n}\n\n \nstatic int kaweth_set_sofs_wait(struct kaweth_device *kaweth, __u16 sofs_wait)\n{\n\tnetdev_dbg(kaweth->net, \"Set SOFS wait to %d\\n\", (unsigned)sofs_wait);\n\n\treturn usb_control_msg(kaweth->dev, usb_sndctrlpipe(kaweth->dev, 0),\n\t\t\t       KAWETH_COMMAND_SET_SOFS_WAIT,\n\t\t\t       USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\n\t\t\t       sofs_wait, 0,\n\t\t\t       &kaweth->scratch, 0,\n\t\t\t       KAWETH_CONTROL_TIMEOUT);\n}\n\n \nstatic int kaweth_set_receive_filter(struct kaweth_device *kaweth,\n\t\t\t\t     __u16 receive_filter)\n{\n\tnetdev_dbg(kaweth->net, \"Set receive filter to %d\\n\",\n\t\t   (unsigned)receive_filter);\n\n\treturn usb_control_msg(kaweth->dev, usb_sndctrlpipe(kaweth->dev, 0),\n\t\t\t       KAWETH_COMMAND_SET_PACKET_FILTER,\n\t\t\t       USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\n\t\t\t       receive_filter, 0,\n\t\t\t       &kaweth->scratch, 0,\n\t\t\t       KAWETH_CONTROL_TIMEOUT);\n}\n\n \nstatic int kaweth_download_firmware(struct kaweth_device *kaweth,\n\t\t\t\t    const char *fwname,\n\t\t\t\t    __u8 interrupt,\n\t\t\t\t    __u8 type)\n{\n\tconst struct firmware *fw;\n\tint data_len;\n\tint ret;\n\n\tret = request_firmware(&fw, fwname, &kaweth->dev->dev);\n\tif (ret) {\n\t\tdev_err(&kaweth->intf->dev, \"Firmware request failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (fw->size > KAWETH_FIRMWARE_BUF_SIZE) {\n\t\tdev_err(&kaweth->intf->dev, \"Firmware too big: %zu\\n\",\n\t\t\tfw->size);\n\t\trelease_firmware(fw);\n\t\treturn -ENOSPC;\n\t}\n\tdata_len = fw->size;\n\tmemcpy(kaweth->firmware_buf, fw->data, fw->size);\n\n\trelease_firmware(fw);\n\n\tkaweth->firmware_buf[2] = (data_len & 0xFF) - 7;\n\tkaweth->firmware_buf[3] = data_len >> 8;\n\tkaweth->firmware_buf[4] = type;\n\tkaweth->firmware_buf[5] = interrupt;\n\n\tnetdev_dbg(kaweth->net, \"High: %i, Low:%i\\n\", kaweth->firmware_buf[3],\n\t\t   kaweth->firmware_buf[2]);\n\n\tnetdev_dbg(kaweth->net,\n\t\t   \"Downloading firmware at %p to kaweth device at %p\\n\",\n\t\t   kaweth->firmware_buf, kaweth);\n\tnetdev_dbg(kaweth->net, \"Firmware length: %d\\n\", data_len);\n\n\treturn usb_control_msg(kaweth->dev, usb_sndctrlpipe(kaweth->dev, 0),\n\t\t\t      KAWETH_COMMAND_SCAN,\n\t\t\t      USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\n\t\t\t      0, 0,\n\t\t\t      kaweth->firmware_buf, data_len,\n\t\t\t      KAWETH_CONTROL_TIMEOUT);\n}\n\n \nstatic int kaweth_trigger_firmware(struct kaweth_device *kaweth,\n\t\t\t\t   __u8 interrupt)\n{\n\tkaweth->firmware_buf[0] = 0xB6;\n\tkaweth->firmware_buf[1] = 0xC3;\n\tkaweth->firmware_buf[2] = 0x01;\n\tkaweth->firmware_buf[3] = 0x00;\n\tkaweth->firmware_buf[4] = 0x06;\n\tkaweth->firmware_buf[5] = interrupt;\n\tkaweth->firmware_buf[6] = 0x00;\n\tkaweth->firmware_buf[7] = 0x00;\n\n\treturn usb_control_msg(kaweth->dev, usb_sndctrlpipe(kaweth->dev, 0),\n\t\t\t       KAWETH_COMMAND_SCAN,\n\t\t\t       USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\n\t\t\t       0, 0,\n\t\t\t       (void *)kaweth->firmware_buf, 8,\n\t\t\t       KAWETH_CONTROL_TIMEOUT);\n}\n\n \nstatic int kaweth_reset(struct kaweth_device *kaweth)\n{\n\tint result;\n\n\tresult = usb_reset_configuration(kaweth->dev);\n\tmdelay(10);\n\n\tnetdev_dbg(kaweth->net, \"kaweth_reset() returns %d.\\n\", result);\n\n\treturn result;\n}\n\nstatic void kaweth_usb_receive(struct urb *);\nstatic int kaweth_resubmit_rx_urb(struct kaweth_device *, gfp_t);\n\n \n\nstatic void kaweth_resubmit_int_urb(struct kaweth_device *kaweth, gfp_t mf)\n{\n\tint status;\n\n\tstatus = usb_submit_urb (kaweth->irq_urb, mf);\n\tif (unlikely(status == -ENOMEM)) {\n\t\tkaweth->suspend_lowmem_ctrl = 1;\n\t\tschedule_delayed_work(&kaweth->lowmem_work, HZ/4);\n\t} else {\n\t\tkaweth->suspend_lowmem_ctrl = 0;\n\t}\n\n\tif (status)\n\t\tdev_err(&kaweth->intf->dev,\n\t\t\t\"can't resubmit intr, %s-%s, status %d\\n\",\n\t\t\tkaweth->dev->bus->bus_name,\n\t\t\tkaweth->dev->devpath, status);\n}\n\nstatic void int_callback(struct urb *u)\n{\n\tstruct kaweth_device *kaweth = u->context;\n\tint act_state;\n\tint status = u->status;\n\n\tswitch (status) {\n\tcase 0:\t\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\t \n\tdefault:\t\t \n\t\tgoto resubmit;\n\t}\n\n\t \n\tif (kaweth->linkstate != (act_state = ( kaweth->intbuffer[STATE_OFFSET] | STATE_MASK) >> STATE_SHIFT)) {\n\t\tif (act_state)\n\t\t\tnetif_carrier_on(kaweth->net);\n\t\telse\n\t\t\tnetif_carrier_off(kaweth->net);\n\n\t\tkaweth->linkstate = act_state;\n\t}\nresubmit:\n\tkaweth_resubmit_int_urb(kaweth, GFP_ATOMIC);\n}\n\nstatic void kaweth_resubmit_tl(struct work_struct *work)\n{\n\tstruct kaweth_device *kaweth =\n\t\tcontainer_of(work, struct kaweth_device, lowmem_work.work);\n\n\tif (IS_BLOCKED(kaweth->status))\n\t\treturn;\n\n\tif (kaweth->suspend_lowmem_rx)\n\t\tkaweth_resubmit_rx_urb(kaweth, GFP_NOIO);\n\n\tif (kaweth->suspend_lowmem_ctrl)\n\t\tkaweth_resubmit_int_urb(kaweth, GFP_NOIO);\n}\n\n\n \nstatic int kaweth_resubmit_rx_urb(struct kaweth_device *kaweth,\n\t\t\t\t\t\tgfp_t mem_flags)\n{\n\tint result;\n\n\tusb_fill_bulk_urb(kaweth->rx_urb,\n\t\t      kaweth->dev,\n\t\t      usb_rcvbulkpipe(kaweth->dev, 1),\n\t\t      kaweth->rx_buf,\n\t\t      KAWETH_BUF_SIZE,\n\t\t      kaweth_usb_receive,\n\t\t      kaweth);\n\tkaweth->rx_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tkaweth->rx_urb->transfer_dma = kaweth->rxbufferhandle;\n\n\tif((result = usb_submit_urb(kaweth->rx_urb, mem_flags))) {\n\t\tif (result == -ENOMEM) {\n\t\t\tkaweth->suspend_lowmem_rx = 1;\n\t\t\tschedule_delayed_work(&kaweth->lowmem_work, HZ/4);\n\t\t}\n\t\tdev_err(&kaweth->intf->dev, \"resubmitting rx_urb %d failed\\n\",\n\t\t\tresult);\n\t} else {\n\t\tkaweth->suspend_lowmem_rx = 0;\n\t}\n\n\treturn result;\n}\n\nstatic void kaweth_async_set_rx_mode(struct kaweth_device *kaweth,\n\t\t\t\t     bool may_sleep);\n\n \nstatic void kaweth_usb_receive(struct urb *urb)\n{\n\tstruct device *dev = &urb->dev->dev;\n\tstruct kaweth_device *kaweth = urb->context;\n\tstruct net_device *net = kaweth->net;\n\tint status = urb->status;\n\tunsigned long flags;\n\tint count = urb->actual_length;\n\tint count2 = urb->transfer_buffer_length;\n\n\t__u16 pkt_len = le16_to_cpup((__le16 *)kaweth->rx_buf);\n\n\tstruct sk_buff *skb;\n\n\tif (unlikely(status == -EPIPE)) {\n\t\tnet->stats.rx_errors++;\n\t\tkaweth->end = 1;\n\t\twake_up(&kaweth->term_wait);\n\t\tdev_dbg(dev, \"Status was -EPIPE.\\n\");\n\t\treturn;\n\t}\n\tif (unlikely(status == -ECONNRESET || status == -ESHUTDOWN)) {\n\t\t \n\t\tkaweth->end = 1;\n\t\twake_up(&kaweth->term_wait);\n\t\tdev_dbg(dev, \"Status was -ECONNRESET or -ESHUTDOWN.\\n\");\n\t\treturn;\n\t}\n\tif (unlikely(status == -EPROTO || status == -ETIME ||\n\t\t     status == -EILSEQ)) {\n\t\tnet->stats.rx_errors++;\n\t\tdev_dbg(dev, \"Status was -EPROTO, -ETIME, or -EILSEQ.\\n\");\n\t\treturn;\n\t}\n\tif (unlikely(status == -EOVERFLOW)) {\n\t\tnet->stats.rx_errors++;\n\t\tdev_dbg(dev, \"Status was -EOVERFLOW.\\n\");\n\t}\n\tspin_lock_irqsave(&kaweth->device_lock, flags);\n\tif (IS_BLOCKED(kaweth->status)) {\n\t\tspin_unlock_irqrestore(&kaweth->device_lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&kaweth->device_lock, flags);\n\n\tif(status && status != -EREMOTEIO && count != 1) {\n\t\tdev_err(&kaweth->intf->dev,\n\t\t\t\"%s RX status: %d count: %d packet_len: %d\\n\",\n\t\t\tnet->name, status, count, (int)pkt_len);\n\t\tkaweth_resubmit_rx_urb(kaweth, GFP_ATOMIC);\n                return;\n\t}\n\n\tif(kaweth->net && (count > 2)) {\n\t\tif(pkt_len > (count - 2)) {\n\t\t\tdev_err(&kaweth->intf->dev,\n\t\t\t\t\"Packet length too long for USB frame (pkt_len: %x, count: %x)\\n\",\n\t\t\t\tpkt_len, count);\n\t\t\tdev_err(&kaweth->intf->dev, \"Packet len & 2047: %x\\n\",\n\t\t\t\tpkt_len & 2047);\n\t\t\tdev_err(&kaweth->intf->dev, \"Count 2: %x\\n\", count2);\n\t\t        kaweth_resubmit_rx_urb(kaweth, GFP_ATOMIC);\n                        return;\n                }\n\n\t\tif(!(skb = dev_alloc_skb(pkt_len+2))) {\n\t\t        kaweth_resubmit_rx_urb(kaweth, GFP_ATOMIC);\n                        return;\n\t\t}\n\n\t\tskb_reserve(skb, 2);     \n\n\t\tskb_copy_to_linear_data(skb, kaweth->rx_buf + 2, pkt_len);\n\n\t\tskb_put(skb, pkt_len);\n\n\t\tskb->protocol = eth_type_trans(skb, net);\n\n\t\tnetif_rx(skb);\n\n\t\tnet->stats.rx_packets++;\n\t\tnet->stats.rx_bytes += pkt_len;\n\t}\n\n\tkaweth_resubmit_rx_urb(kaweth, GFP_ATOMIC);\n}\n\n \nstatic int kaweth_open(struct net_device *net)\n{\n\tstruct kaweth_device *kaweth = netdev_priv(net);\n\tint res;\n\n\tres = usb_autopm_get_interface(kaweth->intf);\n\tif (res) {\n\t\tdev_err(&kaweth->intf->dev, \"Interface cannot be resumed.\\n\");\n\t\treturn -EIO;\n\t}\n\tres = kaweth_resubmit_rx_urb(kaweth, GFP_KERNEL);\n\tif (res)\n\t\tgoto err_out;\n\n\tusb_fill_int_urb(\n\t\tkaweth->irq_urb,\n\t\tkaweth->dev,\n\t\tusb_rcvintpipe(kaweth->dev, 3),\n\t\tkaweth->intbuffer,\n\t\tINTBUFFERSIZE,\n\t\tint_callback,\n\t\tkaweth,\n\t\t250);  \n\tkaweth->irq_urb->transfer_dma = kaweth->intbufferhandle;\n\tkaweth->irq_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tres = usb_submit_urb(kaweth->irq_urb, GFP_KERNEL);\n\tif (res) {\n\t\tusb_kill_urb(kaweth->rx_urb);\n\t\tgoto err_out;\n\t}\n\tkaweth->opened = 1;\n\n\tnetif_start_queue(net);\n\n\tkaweth_async_set_rx_mode(kaweth, true);\n\treturn 0;\n\nerr_out:\n\tusb_autopm_put_interface(kaweth->intf);\n\treturn -EIO;\n}\n\n \nstatic void kaweth_kill_urbs(struct kaweth_device *kaweth)\n{\n\tusb_kill_urb(kaweth->irq_urb);\n\tusb_kill_urb(kaweth->rx_urb);\n\tusb_kill_urb(kaweth->tx_urb);\n\n\tcancel_delayed_work_sync(&kaweth->lowmem_work);\n\n\t \n\tusb_kill_urb(kaweth->irq_urb);\n\tusb_kill_urb(kaweth->rx_urb);\n}\n\n \nstatic int kaweth_close(struct net_device *net)\n{\n\tstruct kaweth_device *kaweth = netdev_priv(net);\n\n\tnetif_stop_queue(net);\n\tkaweth->opened = 0;\n\n\tkaweth->status |= KAWETH_STATUS_CLOSING;\n\n\tkaweth_kill_urbs(kaweth);\n\n\tkaweth->status &= ~KAWETH_STATUS_CLOSING;\n\n\tusb_autopm_put_interface(kaweth->intf);\n\n\treturn 0;\n}\n\nstatic u32 kaweth_get_link(struct net_device *dev)\n{\n\tstruct kaweth_device *kaweth = netdev_priv(dev);\n\n\treturn kaweth->linkstate;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_link\t= kaweth_get_link\n};\n\n \nstatic void kaweth_usb_transmit_complete(struct urb *urb)\n{\n\tstruct kaweth_device *kaweth = urb->context;\n\tstruct sk_buff *skb = kaweth->tx_skb;\n\tint status = urb->status;\n\n\tif (unlikely(status != 0))\n\t\tif (status != -ENOENT)\n\t\t\tdev_dbg(&urb->dev->dev, \"%s: TX status %d.\\n\",\n\t\t\t\tkaweth->net->name, status);\n\n\tnetif_wake_queue(kaweth->net);\n\tdev_kfree_skb_irq(skb);\n}\n\n \nstatic netdev_tx_t kaweth_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *net)\n{\n\tstruct kaweth_device *kaweth = netdev_priv(net);\n\t__le16 *private_header;\n\n\tint res;\n\n\tspin_lock_irq(&kaweth->device_lock);\n\n\tkaweth_async_set_rx_mode(kaweth, false);\n\tnetif_stop_queue(net);\n\tif (IS_BLOCKED(kaweth->status)) {\n\t\tgoto skip;\n\t}\n\n\t \n\tif (skb_cow_head(skb, 2)) {\n\t\tnet->stats.tx_errors++;\n\t\tnetif_start_queue(net);\n\t\tspin_unlock_irq(&kaweth->device_lock);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tprivate_header = __skb_push(skb, 2);\n\t*private_header = cpu_to_le16(skb->len-2);\n\tkaweth->tx_skb = skb;\n\n\tusb_fill_bulk_urb(kaweth->tx_urb,\n\t\t      kaweth->dev,\n\t\t      usb_sndbulkpipe(kaweth->dev, 2),\n\t\t      private_header,\n\t\t      skb->len,\n\t\t      kaweth_usb_transmit_complete,\n\t\t      kaweth);\n\tkaweth->end = 0;\n\n\tif((res = usb_submit_urb(kaweth->tx_urb, GFP_ATOMIC)))\n\t{\n\t\tdev_warn(&net->dev, \"kaweth failed tx_urb %d\\n\", res);\nskip:\n\t\tnet->stats.tx_errors++;\n\n\t\tnetif_start_queue(net);\n\t\tdev_kfree_skb_irq(skb);\n\t}\n\telse\n\t{\n\t\tnet->stats.tx_packets++;\n\t\tnet->stats.tx_bytes += skb->len;\n\t}\n\n\tspin_unlock_irq(&kaweth->device_lock);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void kaweth_set_rx_mode(struct net_device *net)\n{\n\tstruct kaweth_device *kaweth = netdev_priv(net);\n\n\t__u16 packet_filter_bitmap = KAWETH_PACKET_FILTER_DIRECTED |\n                                     KAWETH_PACKET_FILTER_BROADCAST |\n\t\t                     KAWETH_PACKET_FILTER_MULTICAST;\n\n\tnetdev_dbg(net, \"Setting Rx mode to %d\\n\", packet_filter_bitmap);\n\n\tnetif_stop_queue(net);\n\n\tif (net->flags & IFF_PROMISC) {\n\t\tpacket_filter_bitmap |= KAWETH_PACKET_FILTER_PROMISCUOUS;\n\t}\n\telse if (!netdev_mc_empty(net) || (net->flags & IFF_ALLMULTI)) {\n\t\tpacket_filter_bitmap |= KAWETH_PACKET_FILTER_ALL_MULTICAST;\n\t}\n\n\tkaweth->packet_filter_bitmap = packet_filter_bitmap;\n\tnetif_wake_queue(net);\n}\n\n \nstatic void kaweth_async_set_rx_mode(struct kaweth_device *kaweth,\n\t\t\t\t     bool may_sleep)\n{\n\tint ret;\n\t__u16 packet_filter_bitmap = kaweth->packet_filter_bitmap;\n\n\tkaweth->packet_filter_bitmap = 0;\n\tif (packet_filter_bitmap == 0)\n\t\treturn;\n\n\tif (!may_sleep)\n\t\treturn;\n\n\tret = usb_control_msg(kaweth->dev, usb_sndctrlpipe(kaweth->dev, 0),\n\t\t\t      KAWETH_COMMAND_SET_PACKET_FILTER,\n\t\t\t      USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\n\t\t\t      packet_filter_bitmap, 0,\n\t\t\t      &kaweth->scratch, 0,\n\t\t\t      KAWETH_CONTROL_TIMEOUT);\n\tif (ret < 0)\n\t\tdev_err(&kaweth->intf->dev, \"Failed to set Rx mode: %d\\n\",\n\t\t\tret);\n\telse\n\t\tnetdev_dbg(kaweth->net, \"Set Rx mode to %d\\n\",\n\t\t\t   packet_filter_bitmap);\n}\n\n \nstatic void kaweth_tx_timeout(struct net_device *net, unsigned int txqueue)\n{\n\tstruct kaweth_device *kaweth = netdev_priv(net);\n\n\tdev_warn(&net->dev, \"%s: Tx timed out. Resetting.\\n\", net->name);\n\tnet->stats.tx_errors++;\n\tnetif_trans_update(net);\n\n\tusb_unlink_urb(kaweth->tx_urb);\n}\n\n \nstatic int kaweth_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct kaweth_device *kaweth = usb_get_intfdata(intf);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kaweth->device_lock, flags);\n\tkaweth->status |= KAWETH_STATUS_SUSPENDING;\n\tspin_unlock_irqrestore(&kaweth->device_lock, flags);\n\n\tkaweth_kill_urbs(kaweth);\n\treturn 0;\n}\n\n \nstatic int kaweth_resume(struct usb_interface *intf)\n{\n\tstruct kaweth_device *kaweth = usb_get_intfdata(intf);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kaweth->device_lock, flags);\n\tkaweth->status &= ~KAWETH_STATUS_SUSPENDING;\n\tspin_unlock_irqrestore(&kaweth->device_lock, flags);\n\n\tif (!kaweth->opened)\n\t\treturn 0;\n\tkaweth_resubmit_rx_urb(kaweth, GFP_NOIO);\n\tkaweth_resubmit_int_urb(kaweth, GFP_NOIO);\n\n\treturn 0;\n}\n\n \n\n\nstatic const struct net_device_ops kaweth_netdev_ops = {\n\t.ndo_open =\t\t\tkaweth_open,\n\t.ndo_stop =\t\t\tkaweth_close,\n\t.ndo_start_xmit =\t\tkaweth_start_xmit,\n\t.ndo_tx_timeout =\t\tkaweth_tx_timeout,\n\t.ndo_set_rx_mode =\t\tkaweth_set_rx_mode,\n\t.ndo_set_mac_address =\t\teth_mac_addr,\n\t.ndo_validate_addr =\t\teth_validate_addr,\n};\n\nstatic int kaweth_probe(\n\t\tstruct usb_interface *intf,\n\t\tconst struct usb_device_id *id       \n\t)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct kaweth_device *kaweth;\n\tstruct net_device *netdev;\n\tconst eth_addr_t bcast_addr = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\tint result = 0;\n\tint rv = -EIO;\n\n\tdev_dbg(dev,\n\t\t\"Kawasaki Device Probe (Device number:%d): 0x%4.4x:0x%4.4x:0x%4.4x\\n\",\n\t\tudev->devnum, le16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\tle16_to_cpu(udev->descriptor.bcdDevice));\n\n\tdev_dbg(dev, \"Device at %p\\n\", udev);\n\n\tdev_dbg(dev, \"Descriptor length: %x type: %x\\n\",\n\t\t(int)udev->descriptor.bLength,\n\t\t(int)udev->descriptor.bDescriptorType);\n\n\tnetdev = alloc_etherdev(sizeof(*kaweth));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tkaweth = netdev_priv(netdev);\n\tkaweth->dev = udev;\n\tkaweth->net = netdev;\n\tkaweth->intf = intf;\n\n\tspin_lock_init(&kaweth->device_lock);\n\tinit_waitqueue_head(&kaweth->term_wait);\n\n\tdev_dbg(dev, \"Resetting.\\n\");\n\n\tkaweth_reset(kaweth);\n\n\t \n\n\tif (le16_to_cpu(udev->descriptor.bcdDevice) >> 8) {\n\t\tdev_info(dev, \"Firmware present in device.\\n\");\n\t} else {\n\t\t \n\t\tdev_info(dev, \"Downloading firmware...\\n\");\n\t\tkaweth->firmware_buf = (__u8 *)__get_free_page(GFP_KERNEL);\n\t\tif (!kaweth->firmware_buf) {\n\t\t\trv = -ENOMEM;\n\t\t\tgoto err_free_netdev;\n\t\t}\n\t\tif ((result = kaweth_download_firmware(kaweth,\n\t\t\t\t\t\t      \"kaweth/new_code.bin\",\n\t\t\t\t\t\t      100,\n\t\t\t\t\t\t      2)) < 0) {\n\t\t\tdev_err(dev, \"Error downloading firmware (%d)\\n\",\n\t\t\t\tresult);\n\t\t\tgoto err_fw;\n\t\t}\n\n\t\tif ((result = kaweth_download_firmware(kaweth,\n\t\t\t\t\t\t      \"kaweth/new_code_fix.bin\",\n\t\t\t\t\t\t      100,\n\t\t\t\t\t\t      3)) < 0) {\n\t\t\tdev_err(dev, \"Error downloading firmware fix (%d)\\n\",\n\t\t\t\tresult);\n\t\t\tgoto err_fw;\n\t\t}\n\n\t\tif ((result = kaweth_download_firmware(kaweth,\n\t\t\t\t\t\t      \"kaweth/trigger_code.bin\",\n\t\t\t\t\t\t      126,\n\t\t\t\t\t\t      2)) < 0) {\n\t\t\tdev_err(dev, \"Error downloading trigger code (%d)\\n\",\n\t\t\t\tresult);\n\t\t\tgoto err_fw;\n\n\t\t}\n\n\t\tif ((result = kaweth_download_firmware(kaweth,\n\t\t\t\t\t\t      \"kaweth/trigger_code_fix.bin\",\n\t\t\t\t\t\t      126,\n\t\t\t\t\t\t      3)) < 0) {\n\t\t\tdev_err(dev, \"Error downloading trigger code fix (%d)\\n\", result);\n\t\t\tgoto err_fw;\n\t\t}\n\n\n\t\tif ((result = kaweth_trigger_firmware(kaweth, 126)) < 0) {\n\t\t\tdev_err(dev, \"Error triggering firmware (%d)\\n\", result);\n\t\t\tgoto err_fw;\n\t\t}\n\n\t\t \n\t\tdev_info(dev, \"Firmware loaded.  I'll be back...\\n\");\nerr_fw:\n\t\tfree_page((unsigned long)kaweth->firmware_buf);\n\t\tfree_netdev(netdev);\n\t\treturn -EIO;\n\t}\n\n\tresult = kaweth_read_configuration(kaweth);\n\n\tif(result < 0) {\n\t\tdev_err(dev, \"Error reading configuration (%d), no net device created\\n\", result);\n\t\tgoto err_free_netdev;\n\t}\n\n\tdev_info(dev, \"Statistics collection: %x\\n\", kaweth->configuration.statistics_mask);\n\tdev_info(dev, \"Multicast filter limit: %x\\n\", kaweth->configuration.max_multicast_filters & ((1 << 15) - 1));\n\tdev_info(dev, \"MTU: %d\\n\", le16_to_cpu(kaweth->configuration.segment_size));\n\tdev_info(dev, \"Read MAC address %pM\\n\", kaweth->configuration.hw_addr);\n\n\tif(!memcmp(&kaweth->configuration.hw_addr,\n                   &bcast_addr,\n\t\t   sizeof(bcast_addr))) {\n\t\tdev_err(dev, \"Firmware not functioning properly, no net device created\\n\");\n\t\tgoto err_free_netdev;\n\t}\n\n\tif(kaweth_set_urb_size(kaweth, KAWETH_BUF_SIZE) < 0) {\n\t\tdev_dbg(dev, \"Error setting URB size\\n\");\n\t\tgoto err_free_netdev;\n\t}\n\n\tif(kaweth_set_sofs_wait(kaweth, KAWETH_SOFS_TO_WAIT) < 0) {\n\t\tdev_err(dev, \"Error setting SOFS wait\\n\");\n\t\tgoto err_free_netdev;\n\t}\n\n\tresult = kaweth_set_receive_filter(kaweth,\n                                           KAWETH_PACKET_FILTER_DIRECTED |\n                                           KAWETH_PACKET_FILTER_BROADCAST |\n                                           KAWETH_PACKET_FILTER_MULTICAST);\n\n\tif(result < 0) {\n\t\tdev_err(dev, \"Error setting receive filter\\n\");\n\t\tgoto err_free_netdev;\n\t}\n\n\tdev_dbg(dev, \"Initializing net device.\\n\");\n\n\tkaweth->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!kaweth->tx_urb)\n\t\tgoto err_free_netdev;\n\tkaweth->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!kaweth->rx_urb)\n\t\tgoto err_only_tx;\n\tkaweth->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!kaweth->irq_urb)\n\t\tgoto err_tx_and_rx;\n\n\tkaweth->intbuffer = usb_alloc_coherent(\tkaweth->dev,\n\t\t\t\t\t\tINTBUFFERSIZE,\n\t\t\t\t\t\tGFP_KERNEL,\n\t\t\t\t\t\t&kaweth->intbufferhandle);\n\tif (!kaweth->intbuffer)\n\t\tgoto err_tx_and_rx_and_irq;\n\tkaweth->rx_buf = usb_alloc_coherent(\tkaweth->dev,\n\t\t\t\t\t\tKAWETH_BUF_SIZE,\n\t\t\t\t\t\tGFP_KERNEL,\n\t\t\t\t\t\t&kaweth->rxbufferhandle);\n\tif (!kaweth->rx_buf)\n\t\tgoto err_all_but_rxbuf;\n\n\tmemcpy(netdev->broadcast, &bcast_addr, sizeof(bcast_addr));\n\teth_hw_addr_set(netdev, (u8 *)&kaweth->configuration.hw_addr);\n\n\tnetdev->netdev_ops = &kaweth_netdev_ops;\n\tnetdev->watchdog_timeo = KAWETH_TX_TIMEOUT;\n\tnetdev->mtu = le16_to_cpu(kaweth->configuration.segment_size);\n\tnetdev->ethtool_ops = &ops;\n\n\t \n\tINIT_DELAYED_WORK(&kaweth->lowmem_work, kaweth_resubmit_tl);\n\tusb_set_intfdata(intf, kaweth);\n\n\tSET_NETDEV_DEV(netdev, dev);\n\tif (register_netdev(netdev) != 0) {\n\t\tdev_err(dev, \"Error registering netdev.\\n\");\n\t\tgoto err_intfdata;\n\t}\n\n\tdev_info(dev, \"kaweth interface created at %s\\n\",\n\t\t kaweth->net->name);\n\n\treturn 0;\n\nerr_intfdata:\n\tusb_set_intfdata(intf, NULL);\n\tusb_free_coherent(kaweth->dev, KAWETH_BUF_SIZE, (void *)kaweth->rx_buf, kaweth->rxbufferhandle);\nerr_all_but_rxbuf:\n\tusb_free_coherent(kaweth->dev, INTBUFFERSIZE, (void *)kaweth->intbuffer, kaweth->intbufferhandle);\nerr_tx_and_rx_and_irq:\n\tusb_free_urb(kaweth->irq_urb);\nerr_tx_and_rx:\n\tusb_free_urb(kaweth->rx_urb);\nerr_only_tx:\n\tusb_free_urb(kaweth->tx_urb);\nerr_free_netdev:\n\tfree_netdev(netdev);\n\n\treturn rv;\n}\n\n \nstatic void kaweth_disconnect(struct usb_interface *intf)\n{\n\tstruct kaweth_device *kaweth = usb_get_intfdata(intf);\n\tstruct net_device *netdev;\n\n\tusb_set_intfdata(intf, NULL);\n\tif (!kaweth) {\n\t\tdev_warn(&intf->dev, \"unregistering non-existent device\\n\");\n\t\treturn;\n\t}\n\tnetdev = kaweth->net;\n\n\tnetdev_dbg(kaweth->net, \"Unregistering net device\\n\");\n\tunregister_netdev(netdev);\n\n\tusb_free_urb(kaweth->rx_urb);\n\tusb_free_urb(kaweth->tx_urb);\n\tusb_free_urb(kaweth->irq_urb);\n\n\tusb_free_coherent(kaweth->dev, KAWETH_BUF_SIZE, (void *)kaweth->rx_buf, kaweth->rxbufferhandle);\n\tusb_free_coherent(kaweth->dev, INTBUFFERSIZE, (void *)kaweth->intbuffer, kaweth->intbufferhandle);\n\n\tfree_netdev(netdev);\n}\n\n\nmodule_usb_driver(kaweth_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}