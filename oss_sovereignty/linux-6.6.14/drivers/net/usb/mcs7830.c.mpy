{
  "module_name": "mcs7830.c",
  "hash_id": "9b6bbdef7768219ad12bf2d84a9542157d945437680fe83d6de913c42ac39cf1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/mcs7830.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/usbnet.h>\n\n \n#define MCS7830_RD_BMREQ\t(USB_DIR_IN  | USB_TYPE_VENDOR | \\\n\t\t\t\t USB_RECIP_DEVICE)\n#define MCS7830_WR_BMREQ\t(USB_DIR_OUT | USB_TYPE_VENDOR | \\\n\t\t\t\t USB_RECIP_DEVICE)\n#define MCS7830_RD_BREQ\t\t0x0E\n#define MCS7830_WR_BREQ\t\t0x0D\n\n#define MCS7830_CTRL_TIMEOUT\t1000\n#define MCS7830_MAX_MCAST\t64\n\n#define MCS7830_VENDOR_ID\t0x9710\n#define MCS7832_PRODUCT_ID\t0x7832\n#define MCS7830_PRODUCT_ID\t0x7830\n#define MCS7730_PRODUCT_ID\t0x7730\n\n#define SITECOM_VENDOR_ID\t0x0DF6\n#define LN_030_PRODUCT_ID\t0x0021\n\n#define MCS7830_MII_ADVERTISE\t(ADVERTISE_PAUSE_CAP | ADVERTISE_100FULL | \\\n\t\t\t\t ADVERTISE_100HALF | ADVERTISE_10FULL | \\\n\t\t\t\t ADVERTISE_10HALF | ADVERTISE_CSMA)\n\n \nenum {\n\tHIF_REG_MULTICAST_HASH\t\t\t= 0x00,\n\tHIF_REG_PACKET_GAP1\t\t\t= 0x08,\n\tHIF_REG_PACKET_GAP2\t\t\t= 0x09,\n\tHIF_REG_PHY_DATA\t\t\t= 0x0a,\n\tHIF_REG_PHY_CMD1\t\t\t= 0x0c,\n\t   HIF_REG_PHY_CMD1_READ\t\t= 0x40,\n\t   HIF_REG_PHY_CMD1_WRITE\t\t= 0x20,\n\t   HIF_REG_PHY_CMD1_PHYADDR\t\t= 0x01,\n\tHIF_REG_PHY_CMD2\t\t\t= 0x0d,\n\t   HIF_REG_PHY_CMD2_PEND_FLAG_BIT\t= 0x80,\n\t   HIF_REG_PHY_CMD2_READY_FLAG_BIT\t= 0x40,\n\tHIF_REG_CONFIG\t\t\t\t= 0x0e,\n\t \n\t   HIF_REG_CONFIG_CFG\t\t\t= 0x80,\n\t   HIF_REG_CONFIG_SPEED100\t\t= 0x40,\n\t   HIF_REG_CONFIG_FULLDUPLEX_ENABLE\t= 0x20,\n\t   HIF_REG_CONFIG_RXENABLE\t\t= 0x10,\n\t   HIF_REG_CONFIG_TXENABLE\t\t= 0x08,\n\t   HIF_REG_CONFIG_SLEEPMODE\t\t= 0x04,\n\t   HIF_REG_CONFIG_ALLMULTICAST\t\t= 0x02,\n\t   HIF_REG_CONFIG_PROMISCUOUS\t\t= 0x01,\n\tHIF_REG_ETHERNET_ADDR\t\t\t= 0x0f,\n\tHIF_REG_FRAME_DROP_COUNTER\t\t= 0x15,  \n\tHIF_REG_PAUSE_THRESHOLD\t\t\t= 0x16,\n\t   HIF_REG_PAUSE_THRESHOLD_DEFAULT\t= 0,\n};\n\n \nenum {\n\tMCS7830_RX_SHORT_FRAME\t\t= 0x01,  \n\tMCS7830_RX_LENGTH_ERROR\t\t= 0x02,  \n\tMCS7830_RX_ALIGNMENT_ERROR\t= 0x04,  \n\tMCS7830_RX_CRC_ERROR\t\t= 0x08,\n\tMCS7830_RX_LARGE_FRAME\t\t= 0x10,  \n\tMCS7830_RX_FRAME_CORRECT\t= 0x20,  \n\t \n};\n\nstruct mcs7830_data {\n\tu8 multi_filter[8];\n\tu8 config;\n};\n\nstatic const char driver_name[] = \"MOSCHIP usb-ethernet driver\";\n\nstatic int mcs7830_get_reg(struct usbnet *dev, u16 index, u16 size, void *data)\n{\n\tint ret;\n\n\tret = usbnet_read_cmd(dev, MCS7830_RD_BREQ, MCS7830_RD_BMREQ,\n\t\t\t      0x0000, index, data, size);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret < size)\n\t\treturn -ENODATA;\n\n\treturn ret;\n}\n\nstatic int mcs7830_set_reg(struct usbnet *dev, u16 index, u16 size, const void *data)\n{\n\treturn usbnet_write_cmd(dev, MCS7830_WR_BREQ, MCS7830_WR_BMREQ,\n\t\t\t\t0x0000, index, data, size);\n}\n\nstatic void mcs7830_set_reg_async(struct usbnet *dev, u16 index, u16 size, void *data)\n{\n\tusbnet_write_cmd_async(dev, MCS7830_WR_BREQ, MCS7830_WR_BMREQ,\n\t\t\t\t0x0000, index, data, size);\n}\n\nstatic int mcs7830_hif_get_mac_address(struct usbnet *dev, unsigned char *addr)\n{\n\tint ret = mcs7830_get_reg(dev, HIF_REG_ETHERNET_ADDR, ETH_ALEN, addr);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int mcs7830_hif_set_mac_address(struct usbnet *dev,\n\t\t\t\t       const unsigned char *addr)\n{\n\tint ret = mcs7830_set_reg(dev, HIF_REG_ETHERNET_ADDR, ETH_ALEN, addr);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int mcs7830_set_mac_address(struct net_device *netdev, void *p)\n{\n\tint ret;\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tstruct sockaddr *addr = p;\n\n\tif (netif_running(netdev))\n\t\treturn -EBUSY;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tret = mcs7830_hif_set_mac_address(dev, addr->sa_data);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\teth_hw_addr_set(netdev, addr->sa_data);\n\n\treturn 0;\n}\n\nstatic int mcs7830_read_phy(struct usbnet *dev, u8 index)\n{\n\tint ret;\n\tint i;\n\t__le16 val;\n\n\tu8 cmd[2] = {\n\t\tHIF_REG_PHY_CMD1_READ | HIF_REG_PHY_CMD1_PHYADDR,\n\t\tHIF_REG_PHY_CMD2_PEND_FLAG_BIT | index,\n\t};\n\n\tmutex_lock(&dev->phy_mutex);\n\t \n\tret = mcs7830_set_reg(dev, HIF_REG_PHY_CMD1, 2, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tret = mcs7830_get_reg(dev, HIF_REG_PHY_CMD1, 2, cmd);\n\t\tif ((ret < 0) || (cmd[1] & HIF_REG_PHY_CMD2_READY_FLAG_BIT))\n\t\t\tbreak;\n\t\tret = -EIO;\n\t\tmsleep(1);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = mcs7830_get_reg(dev, HIF_REG_PHY_DATA, 2, &val);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = le16_to_cpu(val);\n\tdev_dbg(&dev->udev->dev, \"read PHY reg %02x: %04x (%d tries)\\n\",\n\t\tindex, val, i);\nout:\n\tmutex_unlock(&dev->phy_mutex);\n\treturn ret;\n}\n\nstatic int mcs7830_write_phy(struct usbnet *dev, u8 index, u16 val)\n{\n\tint ret;\n\tint i;\n\t__le16 le_val;\n\n\tu8 cmd[2] = {\n\t\tHIF_REG_PHY_CMD1_WRITE | HIF_REG_PHY_CMD1_PHYADDR,\n\t\tHIF_REG_PHY_CMD2_PEND_FLAG_BIT | (index & 0x1F),\n\t};\n\n\tmutex_lock(&dev->phy_mutex);\n\n\t \n\tle_val = cpu_to_le16(val);\n\tret = mcs7830_set_reg(dev, HIF_REG_PHY_DATA, 2, &le_val);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = mcs7830_set_reg(dev, HIF_REG_PHY_CMD1, 2, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tret = mcs7830_get_reg(dev, HIF_REG_PHY_CMD1, 2, cmd);\n\t\tif ((ret < 0) || (cmd[1] & HIF_REG_PHY_CMD2_READY_FLAG_BIT))\n\t\t\tbreak;\n\t\tret = -EIO;\n\t\tmsleep(1);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = 0;\n\tdev_dbg(&dev->udev->dev, \"write PHY reg %02x: %04x (%d tries)\\n\",\n\t\tindex, val, i);\nout:\n\tmutex_unlock(&dev->phy_mutex);\n\treturn ret;\n}\n\n \nstatic int mcs7830_set_autoneg(struct usbnet *dev, int ptrUserPhyMode)\n{\n\tint ret;\n\t \n\tret = mcs7830_write_phy(dev, MII_ADVERTISE, MCS7830_MII_ADVERTISE);\n\n\t \n\tif (!ret)\n\t\tret = mcs7830_write_phy(dev, MII_BMCR, 0x0000);\n\t \n\tif (!ret)\n\t\tret = mcs7830_write_phy(dev, MII_BMCR, BMCR_ANENABLE);\n\t \n\tif (!ret)\n\t\tret = mcs7830_write_phy(dev, MII_BMCR,\n\t\t\t\tBMCR_ANENABLE | BMCR_ANRESTART\t);\n\treturn ret;\n}\n\n\n \nstatic int mcs7830_get_rev(struct usbnet *dev)\n{\n\tu8 dummy[2];\n\tint ret;\n\tret = mcs7830_get_reg(dev, HIF_REG_FRAME_DROP_COUNTER, 2, dummy);\n\tif (ret > 0)\n\t\treturn 2;  \n\treturn 1;  \n}\n\n \nstatic void mcs7830_rev_C_fixup(struct usbnet *dev)\n{\n\tu8 pause_threshold = HIF_REG_PAUSE_THRESHOLD_DEFAULT;\n\tint retry;\n\n\tfor (retry = 0; retry < 2; retry++) {\n\t\tif (mcs7830_get_rev(dev) == 2) {\n\t\t\tdev_info(&dev->udev->dev, \"applying rev.C fixup\\n\");\n\t\t\tmcs7830_set_reg(dev, HIF_REG_PAUSE_THRESHOLD,\n\t\t\t\t\t1, &pause_threshold);\n\t\t}\n\t\tmsleep(1);\n\t}\n}\n\nstatic int mcs7830_mdio_read(struct net_device *netdev, int phy_id,\n\t\t\t     int location)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\treturn mcs7830_read_phy(dev, location);\n}\n\nstatic void mcs7830_mdio_write(struct net_device *netdev, int phy_id,\n\t\t\t\tint location, int val)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tmcs7830_write_phy(dev, location, val);\n}\n\nstatic int mcs7830_ioctl(struct net_device *net, struct ifreq *rq, int cmd)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\treturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\n}\n\nstatic inline struct mcs7830_data *mcs7830_get_data(struct usbnet *dev)\n{\n\treturn (struct mcs7830_data *)&dev->data;\n}\n\nstatic void mcs7830_hif_update_multicast_hash(struct usbnet *dev)\n{\n\tstruct mcs7830_data *data = mcs7830_get_data(dev);\n\tmcs7830_set_reg_async(dev, HIF_REG_MULTICAST_HASH,\n\t\t\t\tsizeof data->multi_filter,\n\t\t\t\tdata->multi_filter);\n}\n\nstatic void mcs7830_hif_update_config(struct usbnet *dev)\n{\n\t \n\tstruct mcs7830_data *data = mcs7830_get_data(dev);\n\tmcs7830_set_reg_async(dev, HIF_REG_CONFIG, 1, &data->config);\n}\n\nstatic void mcs7830_data_set_multicast(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct mcs7830_data *data = mcs7830_get_data(dev);\n\n\tmemset(data->multi_filter, 0, sizeof data->multi_filter);\n\n\tdata->config = HIF_REG_CONFIG_TXENABLE;\n\n\t \n\tdata->config |= HIF_REG_CONFIG_ALLMULTICAST;\n\n\tif (net->flags & IFF_PROMISC) {\n\t\tdata->config |= HIF_REG_CONFIG_PROMISCUOUS;\n\t} else if (net->flags & IFF_ALLMULTI ||\n\t\t   netdev_mc_count(net) > MCS7830_MAX_MCAST) {\n\t\tdata->config |= HIF_REG_CONFIG_ALLMULTICAST;\n\t} else if (netdev_mc_empty(net)) {\n\t\t \n\t} else {\n\t\t \n\t\tstruct netdev_hw_addr *ha;\n\t\tu32 crc_bits;\n\n\t\t \n\t\tnetdev_for_each_mc_addr(ha, net) {\n\t\t\tcrc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\t\t\tdata->multi_filter[crc_bits >> 3] |= 1 << (crc_bits & 7);\n\t\t}\n\t}\n}\n\nstatic int mcs7830_apply_base_config(struct usbnet *dev)\n{\n\tint ret;\n\n\t \n\tret = mcs7830_hif_set_mac_address(dev, dev->net->dev_addr);\n\tif (ret) {\n\t\tdev_info(&dev->udev->dev, \"Cannot set MAC address\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = mcs7830_set_autoneg(dev, 0);\n\tif (ret) {\n\t\tdev_info(&dev->udev->dev, \"Cannot set autoneg\\n\");\n\t\tgoto out;\n\t}\n\n\tmcs7830_hif_update_multicast_hash(dev);\n\tmcs7830_hif_update_config(dev);\n\n\tmcs7830_rev_C_fixup(dev);\n\tret = 0;\nout:\n\treturn ret;\n}\n\n \nstatic void mcs7830_set_multicast(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\tmcs7830_data_set_multicast(net);\n\n\tmcs7830_hif_update_multicast_hash(dev);\n\tmcs7830_hif_update_config(dev);\n}\n\nstatic int mcs7830_get_regs_len(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\tswitch (mcs7830_get_rev(dev)) {\n\tcase 1:\n\t\treturn 21;\n\tcase 2:\n\t\treturn 32;\n\t}\n\treturn 0;\n}\n\nstatic void mcs7830_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *drvinfo)\n{\n\tusbnet_get_drvinfo(net, drvinfo);\n}\n\nstatic void mcs7830_get_regs(struct net_device *net, struct ethtool_regs *regs, void *data)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\tregs->version = mcs7830_get_rev(dev);\n\tmcs7830_get_reg(dev, 0, regs->len, data);\n}\n\nstatic const struct ethtool_ops mcs7830_ethtool_ops = {\n\t.get_drvinfo\t\t= mcs7830_get_drvinfo,\n\t.get_regs_len\t\t= mcs7830_get_regs_len,\n\t.get_regs\t\t= mcs7830_get_regs,\n\n\t \n\t.get_link\t\t= usbnet_get_link,\n\t.get_msglevel\t\t= usbnet_get_msglevel,\n\t.set_msglevel\t\t= usbnet_set_msglevel,\n\t.nway_reset\t\t= usbnet_nway_reset,\n\t.get_link_ksettings\t= usbnet_get_link_ksettings_mii,\n\t.set_link_ksettings\t= usbnet_set_link_ksettings_mii,\n};\n\nstatic const struct net_device_ops mcs7830_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_change_mtu\t\t= usbnet_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= mcs7830_ioctl,\n\t.ndo_set_rx_mode\t= mcs7830_set_multicast,\n\t.ndo_set_mac_address\t= mcs7830_set_mac_address,\n};\n\nstatic int mcs7830_bind(struct usbnet *dev, struct usb_interface *udev)\n{\n\tstruct net_device *net = dev->net;\n\tu8 addr[ETH_ALEN];\n\tint ret;\n\tint retry;\n\n\t \n\tret = -EINVAL;\n\tfor (retry = 0; retry < 5 && ret; retry++)\n\t\tret = mcs7830_hif_get_mac_address(dev, addr);\n\tif (ret) {\n\t\tdev_warn(&dev->udev->dev, \"Cannot read MAC address\\n\");\n\t\tgoto out;\n\t}\n\teth_hw_addr_set(net, addr);\n\n\tmcs7830_data_set_multicast(net);\n\n\tret = mcs7830_apply_base_config(dev);\n\tif (ret)\n\t\tgoto out;\n\n\tnet->ethtool_ops = &mcs7830_ethtool_ops;\n\tnet->netdev_ops = &mcs7830_netdev_ops;\n\n\t \n\tdev->rx_urb_size = ETH_FRAME_LEN + 1;\n\n\tdev->mii.mdio_read = mcs7830_mdio_read;\n\tdev->mii.mdio_write = mcs7830_mdio_write;\n\tdev->mii.dev = net;\n\tdev->mii.phy_id_mask = 0x3f;\n\tdev->mii.reg_num_mask = 0x1f;\n\tdev->mii.phy_id = *((u8 *) net->dev_addr + 1);\n\n\tret = usbnet_get_endpoints(dev, udev);\nout:\n\treturn ret;\n}\n\n \nstatic int mcs7830_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tu8 status;\n\n\t \n\tif (skb->len < dev->net->hard_header_len) {\n\t\tdev_err(&dev->udev->dev, \"unexpected tiny rx frame\\n\");\n\t\treturn 0;\n\t}\n\n\tskb_trim(skb, skb->len - 1);\n\tstatus = skb->data[skb->len];\n\n\tif (status != MCS7830_RX_FRAME_CORRECT) {\n\t\tdev_dbg(&dev->udev->dev, \"rx fixup status %x\\n\", status);\n\n\t\t \n\t\tdev->net->stats.rx_errors++;\n\n\t\tif (status &\t(MCS7830_RX_SHORT_FRAME\n\t\t\t\t|MCS7830_RX_LENGTH_ERROR\n\t\t\t\t|MCS7830_RX_LARGE_FRAME))\n\t\t\tdev->net->stats.rx_length_errors++;\n\t\tif (status & MCS7830_RX_ALIGNMENT_ERROR)\n\t\t\tdev->net->stats.rx_frame_errors++;\n\t\tif (status & MCS7830_RX_CRC_ERROR)\n\t\t\tdev->net->stats.rx_crc_errors++;\n\t}\n\n\treturn skb->len > 0;\n}\n\nstatic void mcs7830_status(struct usbnet *dev, struct urb *urb)\n{\n\tu8 *buf = urb->transfer_buffer;\n\tbool link, link_changed;\n\n\tif (urb->actual_length < 16)\n\t\treturn;\n\n\tlink = !(buf[1] == 0x20);\n\tlink_changed = netif_carrier_ok(dev->net) != link;\n\tif (link_changed) {\n\t\tusbnet_link_change(dev, link, 0);\n\t\tnetdev_dbg(dev->net, \"Link Status is: %d\\n\", link);\n\t}\n}\n\nstatic const struct driver_info moschip_info = {\n\t.description\t= \"MOSCHIP 7830/7832/7730 usb-NET adapter\",\n\t.bind\t\t= mcs7830_bind,\n\t.rx_fixup\t= mcs7830_rx_fixup,\n\t.flags\t\t= FLAG_ETHER | FLAG_LINK_INTR,\n\t.status\t\t= mcs7830_status,\n\t.in\t\t= 1,\n\t.out\t\t= 2,\n};\n\nstatic const struct driver_info sitecom_info = {\n\t.description    = \"Sitecom LN-30 usb-NET adapter\",\n\t.bind\t\t= mcs7830_bind,\n\t.rx_fixup\t= mcs7830_rx_fixup,\n\t.flags\t\t= FLAG_ETHER | FLAG_LINK_INTR,\n\t.status\t\t= mcs7830_status,\n\t.in\t\t= 1,\n\t.out\t\t= 2,\n};\n\nstatic const struct usb_device_id products[] = {\n\t{\n\t\tUSB_DEVICE(MCS7830_VENDOR_ID, MCS7832_PRODUCT_ID),\n\t\t.driver_info = (unsigned long) &moschip_info,\n\t},\n\t{\n\t\tUSB_DEVICE(MCS7830_VENDOR_ID, MCS7830_PRODUCT_ID),\n\t\t.driver_info = (unsigned long) &moschip_info,\n\t},\n\t{\n\t\tUSB_DEVICE(MCS7830_VENDOR_ID, MCS7730_PRODUCT_ID),\n\t\t.driver_info = (unsigned long) &moschip_info,\n\t},\n\t{\n\t\tUSB_DEVICE(SITECOM_VENDOR_ID, LN_030_PRODUCT_ID),\n\t\t.driver_info = (unsigned long) &sitecom_info,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic int mcs7830_reset_resume (struct usb_interface *intf)\n{\n\t \n\n\tstruct usbnet\t\t*dev = usb_get_intfdata(intf);\n\n\tmcs7830_apply_base_config(dev);\n\n\tusbnet_resume(intf);\n\n\treturn 0;\n}\n\nstatic struct usb_driver mcs7830_driver = {\n\t.name = driver_name,\n\t.id_table = products,\n\t.probe = usbnet_probe,\n\t.disconnect = usbnet_disconnect,\n\t.suspend = usbnet_suspend,\n\t.resume = usbnet_resume,\n\t.reset_resume = mcs7830_reset_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(mcs7830_driver);\n\nMODULE_DESCRIPTION(\"USB to network adapter MCS7830)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}