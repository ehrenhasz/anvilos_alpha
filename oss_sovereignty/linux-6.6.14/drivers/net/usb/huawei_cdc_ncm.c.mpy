{
  "module_name": "huawei_cdc_ncm.c",
  "hash_id": "9361fa3f85713894e0a8db1a418ecef062ab436e21a3eba781f8be83be66b5dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/huawei_cdc_ncm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/usbnet.h>\n#include <linux/usb/cdc-wdm.h>\n#include <linux/usb/cdc_ncm.h>\n\n \nstruct huawei_cdc_ncm_state {\n\tstruct cdc_ncm_ctx *ctx;\n\tatomic_t pmcount;\n\tstruct usb_driver *subdriver;\n\tstruct usb_interface *control;\n\tstruct usb_interface *data;\n};\n\nstatic int huawei_cdc_ncm_manage_power(struct usbnet *usbnet_dev, int on)\n{\n\tstruct huawei_cdc_ncm_state *drvstate = (void *)&usbnet_dev->data;\n\tint rv;\n\n\tif ((on && atomic_add_return(1, &drvstate->pmcount) == 1) ||\n\t\t\t(!on && atomic_dec_and_test(&drvstate->pmcount))) {\n\t\trv = usb_autopm_get_interface(usbnet_dev->intf);\n\t\tusbnet_dev->intf->needs_remote_wakeup = on;\n\t\tif (!rv)\n\t\t\tusb_autopm_put_interface(usbnet_dev->intf);\n\t}\n\treturn 0;\n}\n\nstatic int huawei_cdc_ncm_wdm_manage_power(struct usb_interface *intf,\n\t\t\t\t\t   int status)\n{\n\tstruct usbnet *usbnet_dev = usb_get_intfdata(intf);\n\n\t \n\tif (!usbnet_dev)\n\t\treturn 0;\n\n\treturn huawei_cdc_ncm_manage_power(usbnet_dev, status);\n}\n\n\nstatic int huawei_cdc_ncm_bind(struct usbnet *usbnet_dev,\n\t\t\t       struct usb_interface *intf)\n{\n\tstruct cdc_ncm_ctx *ctx;\n\tstruct usb_driver *subdriver = ERR_PTR(-ENODEV);\n\tint ret;\n\tstruct huawei_cdc_ncm_state *drvstate = (void *)&usbnet_dev->data;\n\tint drvflags = 0;\n\n\t \n\tdrvflags |= CDC_NCM_FLAG_NDP_TO_END;\n\n\t \n\tdrvflags |= CDC_NCM_FLAG_PREFER_NTB32;\n\n\tret = cdc_ncm_bind_common(usbnet_dev, intf, 1, drvflags);\n\tif (ret)\n\t\tgoto err;\n\n\tctx = drvstate->ctx;\n\n\tif (usbnet_dev->status)\n\t\t \n\t\tsubdriver = usb_cdc_wdm_register(ctx->control,\n\t\t\t\t\t\t &usbnet_dev->status->desc,\n\t\t\t\t\t\t 1024,  \n\t\t\t\t\t\t WWAN_PORT_AT,\n\t\t\t\t\t\t huawei_cdc_ncm_wdm_manage_power);\n\tif (IS_ERR(subdriver)) {\n\t\tret = PTR_ERR(subdriver);\n\t\tcdc_ncm_unbind(usbnet_dev, intf);\n\t\tgoto err;\n\t}\n\n\t \n\tusbnet_dev->status = NULL;\n\n\tdrvstate->subdriver = subdriver;\n\nerr:\n\treturn ret;\n}\n\nstatic void huawei_cdc_ncm_unbind(struct usbnet *usbnet_dev,\n\t\t\t\t  struct usb_interface *intf)\n{\n\tstruct huawei_cdc_ncm_state *drvstate = (void *)&usbnet_dev->data;\n\tstruct cdc_ncm_ctx *ctx = drvstate->ctx;\n\n\tif (drvstate->subdriver && drvstate->subdriver->disconnect)\n\t\tdrvstate->subdriver->disconnect(ctx->control);\n\tdrvstate->subdriver = NULL;\n\n\tcdc_ncm_unbind(usbnet_dev, intf);\n}\n\nstatic int huawei_cdc_ncm_suspend(struct usb_interface *intf,\n\t\t\t\t  pm_message_t message)\n{\n\tint ret = 0;\n\tstruct usbnet *usbnet_dev = usb_get_intfdata(intf);\n\tstruct huawei_cdc_ncm_state *drvstate = (void *)&usbnet_dev->data;\n\tstruct cdc_ncm_ctx *ctx = drvstate->ctx;\n\n\tif (ctx == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tret = usbnet_suspend(intf, message);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (intf == ctx->control &&\n\t\tdrvstate->subdriver &&\n\t\tdrvstate->subdriver->suspend)\n\t\tret = drvstate->subdriver->suspend(intf, message);\n\tif (ret < 0)\n\t\tusbnet_resume(intf);\n\nerror:\n\treturn ret;\n}\n\nstatic int huawei_cdc_ncm_resume(struct usb_interface *intf)\n{\n\tint ret = 0;\n\tstruct usbnet *usbnet_dev = usb_get_intfdata(intf);\n\tstruct huawei_cdc_ncm_state *drvstate = (void *)&usbnet_dev->data;\n\tbool callsub;\n\tstruct cdc_ncm_ctx *ctx = drvstate->ctx;\n\n\t \n\tcallsub =\n\t\t(intf == ctx->control &&\n\t\tdrvstate->subdriver &&\n\t\tdrvstate->subdriver->resume);\n\n\tif (callsub)\n\t\tret = drvstate->subdriver->resume(intf);\n\tif (ret < 0)\n\t\tgoto err;\n\tret = usbnet_resume(intf);\n\tif (ret < 0 && callsub)\n\t\tdrvstate->subdriver->suspend(intf, PMSG_SUSPEND);\nerr:\n\treturn ret;\n}\n\nstatic const struct driver_info huawei_cdc_ncm_info = {\n\t.description = \"Huawei CDC NCM device\",\n\t.flags = FLAG_NO_SETINT | FLAG_MULTI_PACKET | FLAG_WWAN,\n\t.bind = huawei_cdc_ncm_bind,\n\t.unbind = huawei_cdc_ncm_unbind,\n\t.manage_power = huawei_cdc_ncm_manage_power,\n\t.rx_fixup = cdc_ncm_rx_fixup,\n\t.tx_fixup = cdc_ncm_tx_fixup,\n};\n\nstatic const struct usb_device_id huawei_cdc_ncm_devs[] = {\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x12d1, 0xff, 0x02, 0x16),\n\t  .driver_info = (unsigned long)&huawei_cdc_ncm_info,\n\t},\n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x12d1, 0xff, 0x02, 0x46),\n\t  .driver_info = (unsigned long)&huawei_cdc_ncm_info,\n\t},\n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x12d1, 0xff, 0x02, 0x76),\n\t  .driver_info = (unsigned long)&huawei_cdc_ncm_info,\n\t},\n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x12d1, 0xff, 0x03, 0x16),\n\t  .driver_info = (unsigned long)&huawei_cdc_ncm_info,\n\t},\n\n\t \n\t{\n\t},\n};\nMODULE_DEVICE_TABLE(usb, huawei_cdc_ncm_devs);\n\nstatic struct usb_driver huawei_cdc_ncm_driver = {\n\t.name = \"huawei_cdc_ncm\",\n\t.id_table = huawei_cdc_ncm_devs,\n\t.probe = usbnet_probe,\n\t.disconnect = usbnet_disconnect,\n\t.suspend = huawei_cdc_ncm_suspend,\n\t.resume = huawei_cdc_ncm_resume,\n\t.reset_resume = huawei_cdc_ncm_resume,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\nmodule_usb_driver(huawei_cdc_ncm_driver);\nMODULE_AUTHOR(\"Enrico Mioso <mrkiko.rs@gmail.com>\");\nMODULE_DESCRIPTION(\"USB CDC NCM host driver with encapsulated protocol support\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}