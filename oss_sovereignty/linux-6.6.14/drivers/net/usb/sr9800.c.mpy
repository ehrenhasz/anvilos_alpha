{
  "module_name": "sr9800.c",
  "hash_id": "1556a8df7d1c1ddb1eeb040d3e195b8e12282131ca6d7a820fe64697bd385e1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/sr9800.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/crc32.h>\n#include <linux/usb/usbnet.h>\n#include <linux/slab.h>\n#include <linux/if_vlan.h>\n\n#include \"sr9800.h\"\n\nstatic int sr_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\n\t\t\t    u16 size, void *data)\n{\n\tint err;\n\n\terr = usbnet_read_cmd(dev, cmd, SR_REQ_RD_REG, value, index,\n\t\t\t      data, size);\n\tif ((err != size) && (err >= 0))\n\t\terr = -EINVAL;\n\n\treturn err;\n}\n\nstatic int sr_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\n\t\t\t     u16 size, void *data)\n{\n\tint err;\n\n\terr = usbnet_write_cmd(dev, cmd, SR_REQ_WR_REG, value, index,\n\t\t\t      data, size);\n\tif ((err != size) && (err >= 0))\n\t\terr = -EINVAL;\n\n\treturn err;\n}\n\nstatic void\nsr_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value, u16 index,\n\t\t   u16 size, void *data)\n{\n\tusbnet_write_cmd_async(dev, cmd, SR_REQ_WR_REG, value, index, data,\n\t\t\t       size);\n}\n\nstatic int sr_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tint offset = 0;\n\n\t \n\tif (skb->len < dev->net->hard_header_len)\n\t\treturn 0;\n\n\twhile (offset + sizeof(u32) < skb->len) {\n\t\tstruct sk_buff *sr_skb;\n\t\tu16 size;\n\t\tu32 header = get_unaligned_le32(skb->data + offset);\n\n\t\toffset += sizeof(u32);\n\t\t \n\t\tsize = (u16) (header & 0x7ff);\n\t\tif (size != ((~header >> 16) & 0x07ff)) {\n\t\t\tnetdev_err(dev->net, \"%s : Bad Header Length\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((size > dev->net->mtu + ETH_HLEN + VLAN_HLEN) ||\n\t\t    (size + offset > skb->len)) {\n\t\t\tnetdev_err(dev->net, \"%s : Bad RX Length %d\\n\",\n\t\t\t\t   __func__, size);\n\t\t\treturn 0;\n\t\t}\n\t\tsr_skb = netdev_alloc_skb_ip_align(dev->net, size);\n\t\tif (!sr_skb)\n\t\t\treturn 0;\n\n\t\tskb_put(sr_skb, size);\n\t\tmemcpy(sr_skb->data, skb->data + offset, size);\n\t\tusbnet_skb_return(dev, sr_skb);\n\n\t\toffset += (size + 1) & 0xfffe;\n\t}\n\n\tif (skb->len != offset) {\n\t\tnetdev_err(dev->net, \"%s : Bad SKB Length %d\\n\", __func__,\n\t\t\t   skb->len);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic struct sk_buff *sr_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\n\t\t\t\t\tgfp_t flags)\n{\n\tint headroom = skb_headroom(skb);\n\tint tailroom = skb_tailroom(skb);\n\tu32 padbytes = 0xffff0000;\n\tu32 packet_len;\n\tint padlen;\n\tvoid *ptr;\n\n\tpadlen = ((skb->len + 4) % (dev->maxpacket - 1)) ? 0 : 4;\n\n\tif ((!skb_cloned(skb)) && ((headroom + tailroom) >= (4 + padlen))) {\n\t\tif ((headroom < 4) || (tailroom < padlen)) {\n\t\t\tskb->data = memmove(skb->head + 4, skb->data,\n\t\t\t\t\t    skb->len);\n\t\t\tskb_set_tail_pointer(skb, skb->len);\n\t\t}\n\t} else {\n\t\tstruct sk_buff *skb2;\n\t\tskb2 = skb_copy_expand(skb, 4, padlen, flags);\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = skb2;\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t}\n\n\tptr = skb_push(skb, 4);\n\tpacket_len = (((skb->len - 4) ^ 0x0000ffff) << 16) + (skb->len - 4);\n\tput_unaligned_le32(packet_len, ptr);\n\n\tif (padlen) {\n\t\tput_unaligned_le32(padbytes, skb_tail_pointer(skb));\n\t\tskb_put(skb, sizeof(padbytes));\n\t}\n\n\tusbnet_set_skb_tx_stats(skb, 1, 0);\n\treturn skb;\n}\n\nstatic void sr_status(struct usbnet *dev, struct urb *urb)\n{\n\tstruct sr9800_int_data *event;\n\tint link;\n\n\tif (urb->actual_length < 8)\n\t\treturn;\n\n\tevent = urb->transfer_buffer;\n\tlink = event->link & 0x01;\n\tif (netif_carrier_ok(dev->net) != link) {\n\t\tusbnet_link_change(dev, link, 1);\n\t\tnetdev_dbg(dev->net, \"Link Status is: %d\\n\", link);\n\t}\n\n\treturn;\n}\n\nstatic inline int sr_set_sw_mii(struct usbnet *dev)\n{\n\tint ret;\n\n\tret = sr_write_cmd(dev, SR_CMD_SET_SW_MII, 0x0000, 0, 0, NULL);\n\tif (ret < 0)\n\t\tnetdev_err(dev->net, \"Failed to enable software MII access\\n\");\n\treturn ret;\n}\n\nstatic inline int sr_set_hw_mii(struct usbnet *dev)\n{\n\tint ret;\n\n\tret = sr_write_cmd(dev, SR_CMD_SET_HW_MII, 0x0000, 0, 0, NULL);\n\tif (ret < 0)\n\t\tnetdev_err(dev->net, \"Failed to enable hardware MII access\\n\");\n\treturn ret;\n}\n\nstatic inline int sr_get_phy_addr(struct usbnet *dev)\n{\n\tu8 buf[2];\n\tint ret;\n\n\tret = sr_read_cmd(dev, SR_CMD_READ_PHY_ID, 0, 0, 2, buf);\n\tif (ret < 0) {\n\t\tnetdev_err(dev->net, \"%s : Error reading PHYID register:%02x\\n\",\n\t\t\t   __func__, ret);\n\t\tgoto out;\n\t}\n\tnetdev_dbg(dev->net, \"%s : returning 0x%04x\\n\", __func__,\n\t\t   *((__le16 *)buf));\n\n\tret = buf[1];\n\nout:\n\treturn ret;\n}\n\nstatic int sr_sw_reset(struct usbnet *dev, u8 flags)\n{\n\tint ret;\n\n\tret = sr_write_cmd(dev, SR_CMD_SW_RESET, flags, 0, 0, NULL);\n\tif (ret < 0)\n\t\tnetdev_err(dev->net, \"Failed to send software reset:%02x\\n\",\n\t\t\t   ret);\n\n\treturn ret;\n}\n\nstatic u16 sr_read_rx_ctl(struct usbnet *dev)\n{\n\t__le16 v;\n\tint ret;\n\n\tret = sr_read_cmd(dev, SR_CMD_READ_RX_CTL, 0, 0, 2, &v);\n\tif (ret < 0) {\n\t\tnetdev_err(dev->net, \"Error reading RX_CTL register:%02x\\n\",\n\t\t\t   ret);\n\t\tgoto out;\n\t}\n\n\tret = le16_to_cpu(v);\nout:\n\treturn ret;\n}\n\nstatic int sr_write_rx_ctl(struct usbnet *dev, u16 mode)\n{\n\tint ret;\n\n\tnetdev_dbg(dev->net, \"%s : mode = 0x%04x\\n\", __func__, mode);\n\tret = sr_write_cmd(dev, SR_CMD_WRITE_RX_CTL, mode, 0, 0, NULL);\n\tif (ret < 0)\n\t\tnetdev_err(dev->net,\n\t\t\t   \"Failed to write RX_CTL mode to 0x%04x:%02x\\n\",\n\t\t\t   mode, ret);\n\n\treturn ret;\n}\n\nstatic u16 sr_read_medium_status(struct usbnet *dev)\n{\n\t__le16 v;\n\tint ret;\n\n\tret = sr_read_cmd(dev, SR_CMD_READ_MEDIUM_STATUS, 0, 0, 2, &v);\n\tif (ret < 0) {\n\t\tnetdev_err(dev->net,\n\t\t\t   \"Error reading Medium Status register:%02x\\n\", ret);\n\t\treturn ret;\t \n\t}\n\n\treturn le16_to_cpu(v);\n}\n\nstatic int sr_write_medium_mode(struct usbnet *dev, u16 mode)\n{\n\tint ret;\n\n\tnetdev_dbg(dev->net, \"%s : mode = 0x%04x\\n\", __func__, mode);\n\tret = sr_write_cmd(dev, SR_CMD_WRITE_MEDIUM_MODE, mode, 0, 0, NULL);\n\tif (ret < 0)\n\t\tnetdev_err(dev->net,\n\t\t\t   \"Failed to write Medium Mode mode to 0x%04x:%02x\\n\",\n\t\t\t   mode, ret);\n\treturn ret;\n}\n\nstatic int sr_write_gpio(struct usbnet *dev, u16 value, int sleep)\n{\n\tint ret;\n\n\tnetdev_dbg(dev->net, \"%s : value = 0x%04x\\n\", __func__, value);\n\tret = sr_write_cmd(dev, SR_CMD_WRITE_GPIOS, value, 0, 0, NULL);\n\tif (ret < 0)\n\t\tnetdev_err(dev->net, \"Failed to write GPIO value 0x%04x:%02x\\n\",\n\t\t\t   value, ret);\n\tif (sleep)\n\t\tmsleep(sleep);\n\n\treturn ret;\n}\n\n \nstatic void sr_set_multicast(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct sr_data *data = (struct sr_data *)&dev->data;\n\tu16 rx_ctl = SR_DEFAULT_RX_CTL;\n\n\tif (net->flags & IFF_PROMISC) {\n\t\trx_ctl |= SR_RX_CTL_PRO;\n\t} else if (net->flags & IFF_ALLMULTI ||\n\t\t   netdev_mc_count(net) > SR_MAX_MCAST) {\n\t\trx_ctl |= SR_RX_CTL_AMALL;\n\t} else if (netdev_mc_empty(net)) {\n\t\t \n\t} else {\n\t\t \n\t\tstruct netdev_hw_addr *ha;\n\t\tu32 crc_bits;\n\n\t\tmemset(data->multi_filter, 0, SR_MCAST_FILTER_SIZE);\n\n\t\t \n\t\tnetdev_for_each_mc_addr(ha, net) {\n\t\t\tcrc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\t\t\tdata->multi_filter[crc_bits >> 3] |=\n\t\t\t    1 << (crc_bits & 7);\n\t\t}\n\n\t\tsr_write_cmd_async(dev, SR_CMD_WRITE_MULTI_FILTER, 0, 0,\n\t\t\t\t   SR_MCAST_FILTER_SIZE, data->multi_filter);\n\n\t\trx_ctl |= SR_RX_CTL_AM;\n\t}\n\n\tsr_write_cmd_async(dev, SR_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);\n}\n\nstatic int sr_mdio_read(struct net_device *net, int phy_id, int loc)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\t__le16 res = 0;\n\n\tmutex_lock(&dev->phy_mutex);\n\tsr_set_sw_mii(dev);\n\tsr_read_cmd(dev, SR_CMD_READ_MII_REG, phy_id, (__u16)loc, 2, &res);\n\tsr_set_hw_mii(dev);\n\tmutex_unlock(&dev->phy_mutex);\n\n\tnetdev_dbg(dev->net,\n\t\t   \"%s : phy_id=0x%02x, loc=0x%02x, returns=0x%04x\\n\", __func__,\n\t\t   phy_id, loc, le16_to_cpu(res));\n\n\treturn le16_to_cpu(res);\n}\n\nstatic void\nsr_mdio_write(struct net_device *net, int phy_id, int loc, int val)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\t__le16 res = cpu_to_le16(val);\n\n\tnetdev_dbg(dev->net,\n\t\t   \"%s : phy_id=0x%02x, loc=0x%02x, val=0x%04x\\n\", __func__,\n\t\t   phy_id, loc, val);\n\tmutex_lock(&dev->phy_mutex);\n\tsr_set_sw_mii(dev);\n\tsr_write_cmd(dev, SR_CMD_WRITE_MII_REG, phy_id, (__u16)loc, 2, &res);\n\tsr_set_hw_mii(dev);\n\tmutex_unlock(&dev->phy_mutex);\n}\n\n \nstatic u32 sr_get_phyid(struct usbnet *dev)\n{\n\tint phy_reg;\n\tu32 phy_id;\n\tint i;\n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\tphy_reg = sr_mdio_read(dev->net, dev->mii.phy_id, MII_PHYSID1);\n\t\tif (phy_reg != 0 && phy_reg != 0xFFFF)\n\t\t\tbreak;\n\t\tmdelay(1);\n\t}\n\n\tif (phy_reg <= 0 || phy_reg == 0xFFFF)\n\t\treturn 0;\n\n\tphy_id = (phy_reg & 0xffff) << 16;\n\n\tphy_reg = sr_mdio_read(dev->net, dev->mii.phy_id, MII_PHYSID2);\n\tif (phy_reg < 0)\n\t\treturn 0;\n\n\tphy_id |= (phy_reg & 0xffff);\n\n\treturn phy_id;\n}\n\nstatic void\nsr_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tu8 opt;\n\n\tif (sr_read_cmd(dev, SR_CMD_READ_MONITOR_MODE, 0, 0, 1, &opt) < 0) {\n\t\twolinfo->supported = 0;\n\t\twolinfo->wolopts = 0;\n\t\treturn;\n\t}\n\twolinfo->supported = WAKE_PHY | WAKE_MAGIC;\n\twolinfo->wolopts = 0;\n\tif (opt & SR_MONITOR_LINK)\n\t\twolinfo->wolopts |= WAKE_PHY;\n\tif (opt & SR_MONITOR_MAGIC)\n\t\twolinfo->wolopts |= WAKE_MAGIC;\n}\n\nstatic int\nsr_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tu8 opt = 0;\n\n\tif (wolinfo->wolopts & ~(WAKE_PHY | WAKE_MAGIC))\n\t\treturn -EINVAL;\n\n\tif (wolinfo->wolopts & WAKE_PHY)\n\t\topt |= SR_MONITOR_LINK;\n\tif (wolinfo->wolopts & WAKE_MAGIC)\n\t\topt |= SR_MONITOR_MAGIC;\n\n\tif (sr_write_cmd(dev, SR_CMD_WRITE_MONITOR_MODE,\n\t\t\t opt, 0, 0, NULL) < 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sr_get_eeprom_len(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct sr_data *data = (struct sr_data *)&dev->data;\n\n\treturn data->eeprom_len;\n}\n\nstatic int sr_get_eeprom(struct net_device *net,\n\t\t\t      struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\t__le16 *ebuf = (__le16 *)data;\n\tint ret;\n\tint i;\n\n\t \n\tif (eeprom->len % 2)\n\t\treturn -EINVAL;\n\n\teeprom->magic = SR_EEPROM_MAGIC;\n\n\t \n\tfor (i = 0; i < eeprom->len / 2; i++) {\n\t\tret = sr_read_cmd(dev, SR_CMD_READ_EEPROM, eeprom->offset + i,\n\t\t\t\t  0, 2, &ebuf[i]);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void sr_get_drvinfo(struct net_device *net,\n\t\t\t\t struct ethtool_drvinfo *info)\n{\n\t \n\tusbnet_get_drvinfo(net, info);\n\tstrncpy(info->driver, DRIVER_NAME, sizeof(info->driver));\n\tstrncpy(info->version, DRIVER_VERSION, sizeof(info->version));\n}\n\nstatic u32 sr_get_link(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\treturn mii_link_ok(&dev->mii);\n}\n\nstatic int sr_ioctl(struct net_device *net, struct ifreq *rq, int cmd)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\treturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\n}\n\nstatic int sr_set_mac_address(struct net_device *net, void *p)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct sr_data *data = (struct sr_data *)&dev->data;\n\tstruct sockaddr *addr = p;\n\n\tif (netif_running(net))\n\t\treturn -EBUSY;\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(net, addr->sa_data);\n\n\t \n\tmemcpy(data->mac_addr, addr->sa_data, ETH_ALEN);\n\tsr_write_cmd_async(dev, SR_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,\n\t\t\t   data->mac_addr);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops sr9800_ethtool_ops = {\n\t.get_drvinfo\t= sr_get_drvinfo,\n\t.get_link\t= sr_get_link,\n\t.get_msglevel\t= usbnet_get_msglevel,\n\t.set_msglevel\t= usbnet_set_msglevel,\n\t.get_wol\t= sr_get_wol,\n\t.set_wol\t= sr_set_wol,\n\t.get_eeprom_len\t= sr_get_eeprom_len,\n\t.get_eeprom\t= sr_get_eeprom,\n\t.nway_reset\t= usbnet_nway_reset,\n\t.get_link_ksettings\t= usbnet_get_link_ksettings_mii,\n\t.set_link_ksettings\t= usbnet_set_link_ksettings_mii,\n};\n\nstatic int sr9800_link_reset(struct usbnet *dev)\n{\n\tstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\n\tu16 mode;\n\n\tmii_check_media(&dev->mii, 1, 1);\n\tmii_ethtool_gset(&dev->mii, &ecmd);\n\tmode = SR9800_MEDIUM_DEFAULT;\n\n\tif (ethtool_cmd_speed(&ecmd) != SPEED_100)\n\t\tmode &= ~SR_MEDIUM_PS;\n\n\tif (ecmd.duplex != DUPLEX_FULL)\n\t\tmode &= ~SR_MEDIUM_FD;\n\n\tnetdev_dbg(dev->net, \"%s : speed: %u duplex: %d mode: 0x%04x\\n\",\n\t\t   __func__, ethtool_cmd_speed(&ecmd), ecmd.duplex, mode);\n\n\tsr_write_medium_mode(dev, mode);\n\n\treturn 0;\n}\n\n\nstatic int sr9800_set_default_mode(struct usbnet *dev)\n{\n\tu16 rx_ctl;\n\tint ret;\n\n\tsr_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);\n\tsr_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,\n\t\t      ADVERTISE_ALL | ADVERTISE_CSMA);\n\tmii_nway_restart(&dev->mii);\n\n\tret = sr_write_medium_mode(dev, SR9800_MEDIUM_DEFAULT);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = sr_write_cmd(dev, SR_CMD_WRITE_IPG012,\n\t\t\t\tSR9800_IPG0_DEFAULT | SR9800_IPG1_DEFAULT,\n\t\t\t\tSR9800_IPG2_DEFAULT, 0, NULL);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"Write IPG,IPG1,IPG2 failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = sr_write_rx_ctl(dev, SR_DEFAULT_RX_CTL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trx_ctl = sr_read_rx_ctl(dev);\n\tnetdev_dbg(dev->net, \"RX_CTL is 0x%04x after all initializations\\n\",\n\t\t   rx_ctl);\n\n\trx_ctl = sr_read_medium_status(dev);\n\tnetdev_dbg(dev->net, \"Medium Status:0x%04x after all initializations\\n\",\n\t\t   rx_ctl);\n\n\treturn 0;\nout:\n\treturn ret;\n}\n\nstatic int sr9800_reset(struct usbnet *dev)\n{\n\tstruct sr_data *data = (struct sr_data *)&dev->data;\n\tint ret, embd_phy;\n\tu16 rx_ctl;\n\n\tret = sr_write_gpio(dev,\n\t\t\tSR_GPIO_RSE | SR_GPIO_GPO_2 | SR_GPIO_GPO2EN, 5);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tembd_phy = ((sr_get_phy_addr(dev) & 0x1f) == 0x10 ? 1 : 0);\n\n\tret = sr_write_cmd(dev, SR_CMD_SW_PHY_SELECT, embd_phy, 0, 0, NULL);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"Select PHY #1 failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = sr_sw_reset(dev, SR_SWRESET_IPPD | SR_SWRESET_PRL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmsleep(150);\n\n\tret = sr_sw_reset(dev, SR_SWRESET_CLEAR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmsleep(150);\n\n\tif (embd_phy) {\n\t\tret = sr_sw_reset(dev, SR_SWRESET_IPRL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = sr_sw_reset(dev, SR_SWRESET_PRTE);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tmsleep(150);\n\trx_ctl = sr_read_rx_ctl(dev);\n\tnetdev_dbg(dev->net, \"RX_CTL is 0x%04x after software reset\\n\", rx_ctl);\n\tret = sr_write_rx_ctl(dev, 0x0000);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trx_ctl = sr_read_rx_ctl(dev);\n\tnetdev_dbg(dev->net, \"RX_CTL is 0x%04x setting to 0x0000\\n\", rx_ctl);\n\n\tret = sr_sw_reset(dev, SR_SWRESET_PRL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmsleep(150);\n\n\tret = sr_sw_reset(dev, SR_SWRESET_IPRL | SR_SWRESET_PRL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmsleep(150);\n\n\tret = sr9800_set_default_mode(dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tmemcpy(data->mac_addr, dev->net->dev_addr, ETH_ALEN);\n\tret = sr_write_cmd(dev, SR_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,\n\t\t\t\t\t\t\tdata->mac_addr);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic const struct net_device_ops sr9800_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_change_mtu\t\t= usbnet_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_set_mac_address\t= sr_set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= sr_ioctl,\n\t.ndo_set_rx_mode        = sr_set_multicast,\n};\n\nstatic int sr9800_phy_powerup(struct usbnet *dev)\n{\n\tint ret;\n\n\t \n\tret = sr_sw_reset(dev, SR_SWRESET_IPPD | SR_SWRESET_IPRL);\n\tif (ret < 0) {\n\t\tnetdev_err(dev->net, \"Failed to power down PHY : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmsleep(20);\n\n\t \n\tret = sr_sw_reset(dev, SR_SWRESET_IPRL);\n\tif (ret < 0) {\n\t\tnetdev_err(dev->net, \"Failed to reset PHY: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmsleep(600);\n\n\t \n\tret = sr_sw_reset(dev, SR_SWRESET_CLEAR);\n\tif (ret < 0) {\n\t\tnetdev_err(dev->net, \"Failed to power up PHY: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmsleep(20);\n\n\t \n\tret = sr_sw_reset(dev, SR_SWRESET_IPRL);\n\tif (ret < 0) {\n\t\tnetdev_err(dev->net, \"Failed to reset PHY: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sr9800_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct sr_data *data = (struct sr_data *)&dev->data;\n\tu16 led01_mux, led23_mux;\n\tint ret, embd_phy;\n\tu8 addr[ETH_ALEN];\n\tu32 phyid;\n\tu16 rx_ctl;\n\n\tdata->eeprom_len = SR9800_EEPROM_LEN;\n\n\tusbnet_get_endpoints(dev, intf);\n\n\t \n\tled01_mux = (SR_LED_MUX_LINK_ACTIVE << 8) | SR_LED_MUX_LINK;\n\tled23_mux = (SR_LED_MUX_LINK_ACTIVE << 8) | SR_LED_MUX_TX_ACTIVE;\n\tret = sr_write_cmd(dev, SR_CMD_LED_MUX, led01_mux, led23_mux, 0, NULL);\n\tif (ret < 0) {\n\t\t\tnetdev_err(dev->net, \"set LINK LED failed : %d\\n\", ret);\n\t\t\tgoto out;\n\t}\n\n\t \n\tret = sr_read_cmd(dev, SR_CMD_READ_NODE_ID, 0, 0, ETH_ALEN, addr);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"Failed to read MAC address: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\teth_hw_addr_set(dev->net, addr);\n\tnetdev_dbg(dev->net, \"mac addr : %pM\\n\", dev->net->dev_addr);\n\n\t \n\tdev->mii.dev = dev->net;\n\tdev->mii.mdio_read = sr_mdio_read;\n\tdev->mii.mdio_write = sr_mdio_write;\n\tdev->mii.phy_id_mask = 0x1f;\n\tdev->mii.reg_num_mask = 0x1f;\n\tdev->mii.phy_id = sr_get_phy_addr(dev);\n\n\tdev->net->netdev_ops = &sr9800_netdev_ops;\n\tdev->net->ethtool_ops = &sr9800_ethtool_ops;\n\n\tembd_phy = ((dev->mii.phy_id & 0x1f) == 0x10 ? 1 : 0);\n\t \n\tret = sr_write_cmd(dev, SR_CMD_SW_PHY_SELECT, embd_phy, 0, 0, NULL);\n\tif (ret < 0) {\n\t\tnetdev_dbg(dev->net, \"Select PHY #1 failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = sr9800_phy_powerup(dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trx_ctl = sr_read_rx_ctl(dev);\n\tnetdev_dbg(dev->net, \"RX_CTL is 0x%04x after software reset\\n\", rx_ctl);\n\tret = sr_write_rx_ctl(dev, 0x0000);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trx_ctl = sr_read_rx_ctl(dev);\n\tnetdev_dbg(dev->net, \"RX_CTL is 0x%04x setting to 0x0000\\n\", rx_ctl);\n\n\t \n\tphyid = sr_get_phyid(dev);\n\tnetdev_dbg(dev->net, \"PHYID=0x%08x\\n\", phyid);\n\n\t \n\tret = sr9800_set_default_mode(dev);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (dev->udev->speed == USB_SPEED_HIGH) {\n\t\tret = sr_write_cmd(dev, SR_CMD_BULKIN_SIZE,\n\t\t\tSR9800_BULKIN_SIZE[SR9800_MAX_BULKIN_4K].byte_cnt,\n\t\t\tSR9800_BULKIN_SIZE[SR9800_MAX_BULKIN_4K].threshold,\n\t\t\t0, NULL);\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(dev->net, \"Reset RX_CTL failed: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdev->rx_urb_size =\n\t\t\tSR9800_BULKIN_SIZE[SR9800_MAX_BULKIN_4K].size;\n\t} else {\n\t\tret = sr_write_cmd(dev, SR_CMD_BULKIN_SIZE,\n\t\t\tSR9800_BULKIN_SIZE[SR9800_MAX_BULKIN_2K].byte_cnt,\n\t\t\tSR9800_BULKIN_SIZE[SR9800_MAX_BULKIN_2K].threshold,\n\t\t\t0, NULL);\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(dev->net, \"Reset RX_CTL failed: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdev->rx_urb_size =\n\t\t\tSR9800_BULKIN_SIZE[SR9800_MAX_BULKIN_2K].size;\n\t}\n\tnetdev_dbg(dev->net, \"%s : setting rx_urb_size with : %zu\\n\", __func__,\n\t\t   dev->rx_urb_size);\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic const struct driver_info sr9800_driver_info = {\n\t.description\t= \"CoreChip SR9800 USB 2.0 Ethernet\",\n\t.bind\t\t= sr9800_bind,\n\t.status\t\t= sr_status,\n\t.link_reset\t= sr9800_link_reset,\n\t.reset\t\t= sr9800_reset,\n\t.flags\t\t= DRIVER_FLAG,\n\t.rx_fixup\t= sr_rx_fixup,\n\t.tx_fixup\t= sr_tx_fixup,\n};\n\nstatic const struct usb_device_id\tproducts[] = {\n\t{\n\t\tUSB_DEVICE(0x0fe6, 0x9800),\t \n\t\t.driver_info = (unsigned long) &sr9800_driver_info,\n\t},\n\t{},\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver sr_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.id_table\t= products,\n\t.probe\t\t= usbnet_probe,\n\t.suspend\t= usbnet_suspend,\n\t.resume\t\t= usbnet_resume,\n\t.disconnect\t= usbnet_disconnect,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(sr_driver);\n\nMODULE_AUTHOR(\"Liu Junliang <liujunliang_ljl@163.com\");\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_DESCRIPTION(\"SR9800 USB 2.0 USB2NET Dev : http://www.corechip-sz.com\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}