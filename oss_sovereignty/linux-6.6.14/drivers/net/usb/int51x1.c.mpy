{
  "module_name": "int51x1.c",
  "hash_id": "51f20840cc82ce2692e8ba7ab7b3ab07385e74a13f7fd9677976be073b79fa4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/int51x1.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/slab.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/usbnet.h>\n\n#define INT51X1_VENDOR_ID\t0x09e1\n#define INT51X1_PRODUCT_ID\t0x5121\n\n#define INT51X1_HEADER_SIZE\t2\t \n\n#define PACKET_TYPE_PROMISCUOUS\t\t(1 << 0)\n#define PACKET_TYPE_ALL_MULTICAST\t(1 << 1)  \n#define PACKET_TYPE_DIRECTED\t\t(1 << 2)\n#define PACKET_TYPE_BROADCAST\t\t(1 << 3)\n#define PACKET_TYPE_MULTICAST\t\t(1 << 4)  \n\n#define SET_ETHERNET_PACKET_FILTER\t0x43\n\nstatic int int51x1_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tint len;\n\n\tif (!(pskb_may_pull(skb, INT51X1_HEADER_SIZE))) {\n\t\tnetdev_err(dev->net, \"unexpected tiny rx frame\\n\");\n\t\treturn 0;\n\t}\n\n\tlen = le16_to_cpu(*(__le16 *)&skb->data[skb->len - 2]);\n\n\tskb_trim(skb, len);\n\n\treturn 1;\n}\n\nstatic struct sk_buff *int51x1_tx_fixup(struct usbnet *dev,\n\t\tstruct sk_buff *skb, gfp_t flags)\n{\n\tint pack_len = skb->len;\n\tint pack_with_header_len = pack_len + INT51X1_HEADER_SIZE;\n\tint headroom = skb_headroom(skb);\n\tint tailroom = skb_tailroom(skb);\n\tint need_tail = 0;\n\t__le16 *len;\n\n\t \n\tif ((pack_with_header_len) < dev->maxpacket)\n\t\tneed_tail = dev->maxpacket - pack_with_header_len + 1;\n\t \n\telse if (!(pack_with_header_len % dev->maxpacket))\n\t\tneed_tail = 1;\n\n\tif (!skb_cloned(skb) &&\n\t\t\t(headroom + tailroom >= need_tail + INT51X1_HEADER_SIZE)) {\n\t\tif (headroom < INT51X1_HEADER_SIZE || tailroom < need_tail) {\n\t\t\tskb->data = memmove(skb->head + INT51X1_HEADER_SIZE,\n\t\t\t\t\tskb->data, skb->len);\n\t\t\tskb_set_tail_pointer(skb, skb->len);\n\t\t}\n\t} else {\n\t\tstruct sk_buff *skb2;\n\n\t\tskb2 = skb_copy_expand(skb,\n\t\t\t\tINT51X1_HEADER_SIZE,\n\t\t\t\tneed_tail,\n\t\t\t\tflags);\n\t\tdev_kfree_skb_any(skb);\n\t\tif (!skb2)\n\t\t\treturn NULL;\n\t\tskb = skb2;\n\t}\n\n\tpack_len += need_tail;\n\tpack_len &= 0x07ff;\n\n\tlen = __skb_push(skb, INT51X1_HEADER_SIZE);\n\t*len = cpu_to_le16(pack_len);\n\n\tif(need_tail)\n\t\t__skb_put_zero(skb, need_tail);\n\n\treturn skb;\n}\n\nstatic void int51x1_set_multicast(struct net_device *netdev)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tu16 filter = PACKET_TYPE_DIRECTED | PACKET_TYPE_BROADCAST;\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\t \n\t\tfilter |= PACKET_TYPE_PROMISCUOUS;\n\t\tnetdev_info(dev->net, \"promiscuous mode enabled\\n\");\n\t} else if (!netdev_mc_empty(netdev) ||\n\t\t  (netdev->flags & IFF_ALLMULTI)) {\n\t\tfilter |= PACKET_TYPE_ALL_MULTICAST;\n\t\tnetdev_dbg(dev->net, \"receive all multicast enabled\\n\");\n\t} else {\n\t\t \n\t\tnetdev_dbg(dev->net, \"receive own packets only\\n\");\n\t}\n\n\tusbnet_write_cmd_async(dev, SET_ETHERNET_PACKET_FILTER,\n\t\t\t       USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t       filter, 0, NULL, 0);\n}\n\nstatic const struct net_device_ops int51x1_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_change_mtu\t\t= usbnet_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_rx_mode\t= int51x1_set_multicast,\n};\n\nstatic int int51x1_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint status = usbnet_get_ethernet_addr(dev, 3);\n\n\tif (status)\n\t\treturn status;\n\n\tdev->net->hard_header_len += INT51X1_HEADER_SIZE;\n\tdev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\n\tdev->net->netdev_ops = &int51x1_netdev_ops;\n\n\treturn usbnet_get_endpoints(dev, intf);\n}\n\nstatic const struct driver_info int51x1_info = {\n\t.description = \"Intellon usb powerline adapter\",\n\t.bind        = int51x1_bind,\n\t.rx_fixup    = int51x1_rx_fixup,\n\t.tx_fixup    = int51x1_tx_fixup,\n\t.in          = 1,\n\t.out         = 2,\n\t.flags       = FLAG_ETHER,\n};\n\nstatic const struct usb_device_id products[] = {\n\t{\n\tUSB_DEVICE(INT51X1_VENDOR_ID, INT51X1_PRODUCT_ID),\n\t\t.driver_info = (unsigned long) &int51x1_info,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver int51x1_driver = {\n\t.name       = \"int51x1\",\n\t.id_table   = products,\n\t.probe      = usbnet_probe,\n\t.disconnect = usbnet_disconnect,\n\t.suspend    = usbnet_suspend,\n\t.resume     = usbnet_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(int51x1_driver);\n\nMODULE_AUTHOR(\"Peter Holik\");\nMODULE_DESCRIPTION(\"Intellon usb powerline adapter\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}