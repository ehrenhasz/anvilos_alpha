{
  "module_name": "net1080.c",
  "hash_id": "7101097d2b20701892b824581a01cebae87886a02378725ff9536978b1291218",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/net1080.c",
  "human_readable_source": "\n \n\n\n\n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/usbnet.h>\n#include <linux/slab.h>\n\n#include <asm/unaligned.h>\n\n\n \n\n#define frame_errors\tdata[1]\n\n \n\nstruct nc_header {\t\t\n\t__le16\thdr_len;\t\t\n\t__le16\tpacket_len;\t\t\n\t__le16\tpacket_id;\t\t\n#define MIN_HEADER\t6\n\n\t\n\t\n\t\n} __packed;\n\n#define\tPAD_BYTE\t((unsigned char)0xAC)\n\nstruct nc_trailer {\n\t__le16\tpacket_id;\n} __packed;\n\n\n#define FRAMED_SIZE(mtu) (sizeof (struct nc_header) \\\n\t\t\t\t+ sizeof (struct ethhdr) \\\n\t\t\t\t+ (mtu) \\\n\t\t\t\t+ 1 \\\n\t\t\t\t+ sizeof (struct nc_trailer))\n\n#define MIN_FRAMED\tFRAMED_SIZE(0)\n\n \n#define NC_MAX_PACKET\t32767\n\n\n \n#define\tNC_READ_TTL_MS\t((u8)255)\t \n\n \n#define\tREG_USBCTL\t((u8)0x04)\n#define REG_TTL\t\t((u8)0x10)\n#define REG_STATUS\t((u8)0x11)\n\n \n#define\tREQUEST_REGISTER\t((u8)0x10)\n#define\tREQUEST_EEPROM\t\t((u8)0x11)\n\nstatic int\nnc_vendor_read(struct usbnet *dev, u8 req, u8 regnum, u16 *retval_ptr)\n{\n\tint status = usbnet_read_cmd(dev, req,\n\t\t\t\t     USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t\t     USB_RECIP_DEVICE,\n\t\t\t\t     0, regnum, retval_ptr,\n\t\t\t\t     sizeof *retval_ptr);\n\tif (status > 0)\n\t\tstatus = 0;\n\tif (!status)\n\t\tle16_to_cpus(retval_ptr);\n\treturn status;\n}\n\nstatic inline int\nnc_register_read(struct usbnet *dev, u8 regnum, u16 *retval_ptr)\n{\n\treturn nc_vendor_read(dev, REQUEST_REGISTER, regnum, retval_ptr);\n}\n\nstatic void\nnc_vendor_write(struct usbnet *dev, u8 req, u8 regnum, u16 value)\n{\n\tusbnet_write_cmd(dev, req,\n\t\t\t USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t value, regnum, NULL, 0);\n}\n\nstatic inline void\nnc_register_write(struct usbnet *dev, u8 regnum, u16 value)\n{\n\tnc_vendor_write(dev, REQUEST_REGISTER, regnum, value);\n}\n\n\n#if 0\nstatic void nc_dump_registers(struct usbnet *dev)\n{\n\tu8\treg;\n\tu16\t*vp = kmalloc(sizeof (u16));\n\n\tif (!vp)\n\t\treturn;\n\n\tnetdev_dbg(dev->net, \"registers:\\n\");\n\tfor (reg = 0; reg < 0x20; reg++) {\n\t\tint retval;\n\n\t\t \n\t\tif (reg >= 0x08 && reg <= 0xf)\n\t\t\tcontinue;\n\t\tif (reg >= 0x12 && reg <= 0x1e)\n\t\t\tcontinue;\n\n\t\tretval = nc_register_read(dev, reg, vp);\n\t\tif (retval < 0)\n\t\t\tnetdev_dbg(dev->net, \"reg [0x%x] ==> error %d\\n\",\n\t\t\t\t   reg, retval);\n\t\telse\n\t\t\tnetdev_dbg(dev->net, \"reg [0x%x] = 0x%x\\n\", reg, *vp);\n\t}\n\tkfree(vp);\n}\n#endif\n\n\n \n\n \n\n#define\tUSBCTL_WRITABLE_MASK\t0x1f0f\n \n#define\tUSBCTL_ENABLE_LANG\t(1 << 12)\n#define\tUSBCTL_ENABLE_MFGR\t(1 << 11)\n#define\tUSBCTL_ENABLE_PROD\t(1 << 10)\n#define\tUSBCTL_ENABLE_SERIAL\t(1 << 9)\n#define\tUSBCTL_ENABLE_DEFAULTS\t(1 << 8)\n \n#define\tUSBCTL_FLUSH_OTHER\t(1 << 3)\n#define\tUSBCTL_FLUSH_THIS\t(1 << 2)\n#define\tUSBCTL_DISCONN_OTHER\t(1 << 1)\n#define\tUSBCTL_DISCONN_THIS\t(1 << 0)\n\nstatic inline void nc_dump_usbctl(struct usbnet *dev, u16 usbctl)\n{\n\tnetif_dbg(dev, link, dev->net,\n\t\t  \"net1080 %s-%s usbctl 0x%x:%s%s%s%s%s; this%s%s; other%s%s; r/o 0x%x\\n\",\n\t\t  dev->udev->bus->bus_name, dev->udev->devpath,\n\t\t  usbctl,\n\t\t  (usbctl & USBCTL_ENABLE_LANG) ? \" lang\" : \"\",\n\t\t  (usbctl & USBCTL_ENABLE_MFGR) ? \" mfgr\" : \"\",\n\t\t  (usbctl & USBCTL_ENABLE_PROD) ? \" prod\" : \"\",\n\t\t  (usbctl & USBCTL_ENABLE_SERIAL) ? \" serial\" : \"\",\n\t\t  (usbctl & USBCTL_ENABLE_DEFAULTS) ? \" defaults\" : \"\",\n\n\t\t  (usbctl & USBCTL_FLUSH_THIS) ? \" FLUSH\" : \"\",\n\t\t  (usbctl & USBCTL_DISCONN_THIS) ? \" DIS\" : \"\",\n\n\t\t  (usbctl & USBCTL_FLUSH_OTHER) ? \" FLUSH\" : \"\",\n\t\t  (usbctl & USBCTL_DISCONN_OTHER) ? \" DIS\" : \"\",\n\n\t\t  usbctl & ~USBCTL_WRITABLE_MASK);\n}\n\n \n\n \n\n#define\tSTATUS_PORT_A\t\t(1 << 15)\n\n#define\tSTATUS_CONN_OTHER\t(1 << 14)\n#define\tSTATUS_SUSPEND_OTHER\t(1 << 13)\n#define\tSTATUS_MAILBOX_OTHER\t(1 << 12)\n#define\tSTATUS_PACKETS_OTHER(n)\t(((n) >> 8) & 0x03)\n\n#define\tSTATUS_CONN_THIS\t(1 << 6)\n#define\tSTATUS_SUSPEND_THIS\t(1 << 5)\n#define\tSTATUS_MAILBOX_THIS\t(1 << 4)\n#define\tSTATUS_PACKETS_THIS(n)\t(((n) >> 0) & 0x03)\n\n#define\tSTATUS_UNSPEC_MASK\t0x0c8c\n#define\tSTATUS_NOISE_MASK \t((u16)~(0x0303|STATUS_UNSPEC_MASK))\n\n\nstatic inline void nc_dump_status(struct usbnet *dev, u16 status)\n{\n\tnetif_dbg(dev, link, dev->net,\n\t\t  \"net1080 %s-%s status 0x%x: this (%c) PKT=%d%s%s%s; other PKT=%d%s%s%s; unspec 0x%x\\n\",\n\t\t  dev->udev->bus->bus_name, dev->udev->devpath,\n\t\t  status,\n\n\t\t   \n\t\t  \n\n\t\t  (status & STATUS_PORT_A) ? 'A' : 'B',\n\t\t  STATUS_PACKETS_THIS(status),\n\t\t  (status & STATUS_CONN_THIS) ? \" CON\" : \"\",\n\t\t  (status & STATUS_SUSPEND_THIS) ? \" SUS\" : \"\",\n\t\t  (status & STATUS_MAILBOX_THIS) ? \" MBOX\" : \"\",\n\n\t\t  STATUS_PACKETS_OTHER(status),\n\t\t  (status & STATUS_CONN_OTHER) ? \" CON\" : \"\",\n\t\t  (status & STATUS_SUSPEND_OTHER) ? \" SUS\" : \"\",\n\t\t  (status & STATUS_MAILBOX_OTHER) ? \" MBOX\" : \"\",\n\n\t\t  status & STATUS_UNSPEC_MASK);\n}\n\n \n\n \n\n#define\tTTL_OTHER(ttl)\t(0x00ff & (ttl >> 8))\n#define MK_TTL(this,other)\t((u16)(((other)<<8)|(0x00ff&(this))))\n\n \n\nstatic int net1080_reset(struct usbnet *dev)\n{\n\tu16\t\tusbctl, status, ttl;\n\tu16\t\tvp;\n\tint\t\tretval;\n\n\t\n\n\tif ((retval = nc_register_read(dev, REG_STATUS, &vp)) < 0) {\n\t\tnetdev_dbg(dev->net, \"can't read %s-%s status: %d\\n\",\n\t\t\t   dev->udev->bus->bus_name, dev->udev->devpath, retval);\n\t\tgoto done;\n\t}\n\tstatus = vp;\n\tnc_dump_status(dev, status);\n\n\tif ((retval = nc_register_read(dev, REG_USBCTL, &vp)) < 0) {\n\t\tnetdev_dbg(dev->net, \"can't read USBCTL, %d\\n\", retval);\n\t\tgoto done;\n\t}\n\tusbctl = vp;\n\tnc_dump_usbctl(dev, usbctl);\n\n\tnc_register_write(dev, REG_USBCTL,\n\t\t\tUSBCTL_FLUSH_THIS | USBCTL_FLUSH_OTHER);\n\n\tif ((retval = nc_register_read(dev, REG_TTL, &vp)) < 0) {\n\t\tnetdev_dbg(dev->net, \"can't read TTL, %d\\n\", retval);\n\t\tgoto done;\n\t}\n\tttl = vp;\n\n\tnc_register_write(dev, REG_TTL,\n\t\t\tMK_TTL(NC_READ_TTL_MS, TTL_OTHER(ttl)) );\n\tnetdev_dbg(dev->net, \"assigned TTL, %d ms\\n\", NC_READ_TTL_MS);\n\n\tnetif_info(dev, link, dev->net, \"port %c, peer %sconnected\\n\",\n\t\t   (status & STATUS_PORT_A) ? 'A' : 'B',\n\t\t   (status & STATUS_CONN_OTHER) ? \"\" : \"dis\");\n\tretval = 0;\n\ndone:\n\treturn retval;\n}\n\nstatic int net1080_check_connect(struct usbnet *dev)\n{\n\tint\t\t\tretval;\n\tu16\t\t\tstatus;\n\tu16\t\t\tvp;\n\n\tretval = nc_register_read(dev, REG_STATUS, &vp);\n\tstatus = vp;\n\tif (retval != 0) {\n\t\tnetdev_dbg(dev->net, \"net1080_check_conn read - %d\\n\", retval);\n\t\treturn retval;\n\t}\n\tif ((status & STATUS_CONN_OTHER) != STATUS_CONN_OTHER)\n\t\treturn -ENOLINK;\n\treturn 0;\n}\n\nstatic void nc_ensure_sync(struct usbnet *dev)\n{\n\tif (++dev->frame_errors <= 5)\n\t\treturn;\n\n\tif (usbnet_write_cmd_async(dev, REQUEST_REGISTER,\n\t\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t\tUSB_RECIP_DEVICE,\n\t\t\t\t\tUSBCTL_FLUSH_THIS |\n\t\t\t\t\tUSBCTL_FLUSH_OTHER,\n\t\t\t\t\tREG_USBCTL, NULL, 0))\n\t\treturn;\n\n\tnetif_dbg(dev, rx_err, dev->net,\n\t\t  \"flush net1080; too many framing errors\\n\");\n\tdev->frame_errors = 0;\n}\n\nstatic int net1080_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct nc_header\t*header;\n\tstruct nc_trailer\t*trailer;\n\tu16\t\t\thdr_len, packet_len;\n\n\t \n\tif (skb->len < dev->net->hard_header_len)\n\t\treturn 0;\n\n\tif (!(skb->len & 0x01)) {\n\t\tnetdev_dbg(dev->net, \"rx framesize %d range %d..%d mtu %d\\n\",\n\t\t\t   skb->len, dev->net->hard_header_len, dev->hard_mtu,\n\t\t\t   dev->net->mtu);\n\t\tdev->net->stats.rx_frame_errors++;\n\t\tnc_ensure_sync(dev);\n\t\treturn 0;\n\t}\n\n\theader = (struct nc_header *) skb->data;\n\thdr_len = le16_to_cpup(&header->hdr_len);\n\tpacket_len = le16_to_cpup(&header->packet_len);\n\tif (FRAMED_SIZE(packet_len) > NC_MAX_PACKET) {\n\t\tdev->net->stats.rx_frame_errors++;\n\t\tnetdev_dbg(dev->net, \"packet too big, %d\\n\", packet_len);\n\t\tnc_ensure_sync(dev);\n\t\treturn 0;\n\t} else if (hdr_len < MIN_HEADER) {\n\t\tdev->net->stats.rx_frame_errors++;\n\t\tnetdev_dbg(dev->net, \"header too short, %d\\n\", hdr_len);\n\t\tnc_ensure_sync(dev);\n\t\treturn 0;\n\t} else if (hdr_len > MIN_HEADER) {\n\t\t\n\t\tnetdev_dbg(dev->net, \"header OOB, %d bytes\\n\", hdr_len - MIN_HEADER);\n\t\tnc_ensure_sync(dev);\n\t\t\n\t}\n\tskb_pull(skb, hdr_len);\n\n\ttrailer = (struct nc_trailer *)\n\t\t(skb->data + skb->len - sizeof *trailer);\n\tskb_trim(skb, skb->len - sizeof *trailer);\n\n\tif ((packet_len & 0x01) == 0) {\n\t\tif (skb->data [packet_len] != PAD_BYTE) {\n\t\t\tdev->net->stats.rx_frame_errors++;\n\t\t\tnetdev_dbg(dev->net, \"bad pad\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tskb_trim(skb, skb->len - 1);\n\t}\n\tif (skb->len != packet_len) {\n\t\tdev->net->stats.rx_frame_errors++;\n\t\tnetdev_dbg(dev->net, \"bad packet len %d (expected %d)\\n\",\n\t\t\t   skb->len, packet_len);\n\t\tnc_ensure_sync(dev);\n\t\treturn 0;\n\t}\n\tif (header->packet_id != get_unaligned(&trailer->packet_id)) {\n\t\tdev->net->stats.rx_fifo_errors++;\n\t\tnetdev_dbg(dev->net, \"(2+ dropped) rx packet_id mismatch 0x%x 0x%x\\n\",\n\t\t\t   le16_to_cpu(header->packet_id),\n\t\t\t   le16_to_cpu(trailer->packet_id));\n\t\treturn 0;\n\t}\n#if 0\n\tnetdev_dbg(dev->net, \"frame <rx h %d p %d id %d\\n\", header->hdr_len,\n\t\t   header->packet_len, header->packet_id);\n#endif\n\tdev->frame_errors = 0;\n\treturn 1;\n}\n\nstatic struct sk_buff *\nnet1080_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\n{\n\tstruct sk_buff\t\t*skb2;\n\tstruct nc_header\t*header = NULL;\n\tstruct nc_trailer\t*trailer = NULL;\n\tint\t\t\tpadlen = sizeof (struct nc_trailer);\n\tint\t\t\tlen = skb->len;\n\n\tif (!((len + padlen + sizeof (struct nc_header)) & 0x01))\n\t\tpadlen++;\n\tif (!skb_cloned(skb)) {\n\t\tint\theadroom = skb_headroom(skb);\n\t\tint\ttailroom = skb_tailroom(skb);\n\n\t\tif (padlen <= tailroom &&\n\t\t    sizeof(struct nc_header) <= headroom)\n\t\t\t \n\t\t\tgoto encapsulate;\n\n\t\tif ((sizeof (struct nc_header) + padlen) <\n\t\t\t\t(headroom + tailroom)) {\n\t\t\t \n\t\t\tskb->data = memmove(skb->head\n\t\t\t\t\t\t+ sizeof (struct nc_header),\n\t\t\t\t\t    skb->data, skb->len);\n\t\t\tskb_set_tail_pointer(skb, len);\n\t\t\tgoto encapsulate;\n\t\t}\n\t}\n\n\t \n\tskb2 = skb_copy_expand(skb,\n\t\t\t\tsizeof (struct nc_header),\n\t\t\t\tpadlen,\n\t\t\t\tflags);\n\tdev_kfree_skb_any(skb);\n\tif (!skb2)\n\t\treturn skb2;\n\tskb = skb2;\n\nencapsulate:\n\t \n\theader = skb_push(skb, sizeof *header);\n\theader->hdr_len = cpu_to_le16(sizeof (*header));\n\theader->packet_len = cpu_to_le16(len);\n\theader->packet_id = cpu_to_le16((u16)dev->xid++);\n\n\t \n\tif (!((skb->len + sizeof *trailer) & 0x01))\n\t\tskb_put_u8(skb, PAD_BYTE);\n\ttrailer = skb_put(skb, sizeof *trailer);\n\tput_unaligned(header->packet_id, &trailer->packet_id);\n#if 0\n\tnetdev_dbg(dev->net, \"frame >tx h %d p %d id %d\\n\",\n\t\t   header->hdr_len, header->packet_len,\n\t\t   header->packet_id);\n#endif\n\treturn skb;\n}\n\nstatic int net1080_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tunsigned\textra = sizeof (struct nc_header)\n\t\t\t\t+ 1\n\t\t\t\t+ sizeof (struct nc_trailer);\n\n\tdev->net->hard_header_len += extra;\n\tdev->rx_urb_size = dev->net->hard_header_len + dev->net->mtu;\n\tdev->hard_mtu = NC_MAX_PACKET;\n\treturn usbnet_get_endpoints (dev, intf);\n}\n\nstatic const struct driver_info\tnet1080_info = {\n\t.description =\t\"NetChip TurboCONNECT\",\n\t.flags =\tFLAG_POINTTOPOINT | FLAG_FRAMING_NC,\n\t.bind =\t\tnet1080_bind,\n\t.reset =\tnet1080_reset,\n\t.check_connect = net1080_check_connect,\n\t.rx_fixup =\tnet1080_rx_fixup,\n\t.tx_fixup =\tnet1080_tx_fixup,\n};\n\nstatic const struct usb_device_id\tproducts [] = {\n{\n\tUSB_DEVICE(0x0525, 0x1080),\t\n\t.driver_info =\t(unsigned long) &net1080_info,\n}, {\n\tUSB_DEVICE(0x06D0, 0x0622),\t\n\t.driver_info =\t(unsigned long) &net1080_info,\n},\n\t{ },\t\t\n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver net1080_driver = {\n\t.name =\t\t\"net1080\",\n\t.id_table =\tproducts,\n\t.probe =\tusbnet_probe,\n\t.disconnect =\tusbnet_disconnect,\n\t.suspend =\tusbnet_suspend,\n\t.resume =\tusbnet_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(net1080_driver);\n\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_DESCRIPTION(\"NetChip 1080 based USB Host-to-Host Links\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}