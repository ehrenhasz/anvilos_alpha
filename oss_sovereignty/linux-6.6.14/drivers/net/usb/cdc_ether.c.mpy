{
  "module_name": "cdc_ether.c",
  "hash_id": "fd05dd87a50285f2774c135500f5d42104103cb609d238f6828f0596d220d110",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/cdc_ether.c",
  "human_readable_source": "\n \n\n\n\n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/usbnet.h>\n\n\n#if IS_ENABLED(CONFIG_USB_NET_RNDIS_HOST)\n\nstatic int is_rndis(struct usb_interface_descriptor *desc)\n{\n\treturn (desc->bInterfaceClass == USB_CLASS_COMM &&\n\t\tdesc->bInterfaceSubClass == 2 &&\n\t\tdesc->bInterfaceProtocol == 0xff);\n}\n\nstatic int is_activesync(struct usb_interface_descriptor *desc)\n{\n\treturn (desc->bInterfaceClass == USB_CLASS_MISC &&\n\t\tdesc->bInterfaceSubClass == 1 &&\n\t\tdesc->bInterfaceProtocol == 1);\n}\n\nstatic int is_wireless_rndis(struct usb_interface_descriptor *desc)\n{\n\treturn (desc->bInterfaceClass == USB_CLASS_WIRELESS_CONTROLLER &&\n\t\tdesc->bInterfaceSubClass == 1 &&\n\t\tdesc->bInterfaceProtocol == 3);\n}\n\nstatic int is_novatel_rndis(struct usb_interface_descriptor *desc)\n{\n\treturn (desc->bInterfaceClass == USB_CLASS_MISC &&\n\t\tdesc->bInterfaceSubClass == 4 &&\n\t\tdesc->bInterfaceProtocol == 1);\n}\n\n#else\n\n#define is_rndis(desc)\t\t0\n#define is_activesync(desc)\t0\n#define is_wireless_rndis(desc)\t0\n#define is_novatel_rndis(desc)\t0\n\n#endif\n\nstatic const u8 mbm_guid[16] = {\n\t0xa3, 0x17, 0xa8, 0x8b, 0x04, 0x5e, 0x4f, 0x01,\n\t0xa6, 0x07, 0xc0, 0xff, 0xcb, 0x7e, 0x39, 0x2a,\n};\n\nvoid usbnet_cdc_update_filter(struct usbnet *dev)\n{\n\tstruct net_device\t*net = dev->net;\n\n\tu16 cdc_filter = USB_CDC_PACKET_TYPE_DIRECTED\n\t\t\t| USB_CDC_PACKET_TYPE_BROADCAST;\n\n\t \n\tif (net->flags & IFF_PROMISC)\n\t\tcdc_filter |= USB_CDC_PACKET_TYPE_PROMISCUOUS;\n\tif (!netdev_mc_empty(net) || (net->flags & IFF_ALLMULTI))\n\t\tcdc_filter |= USB_CDC_PACKET_TYPE_ALL_MULTICAST;\n\n\tusb_control_msg(dev->udev,\n\t\t\tusb_sndctrlpipe(dev->udev, 0),\n\t\t\tUSB_CDC_SET_ETHERNET_PACKET_FILTER,\n\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tcdc_filter,\n\t\t\tdev->intf->cur_altsetting->desc.bInterfaceNumber,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\tUSB_CTRL_SET_TIMEOUT\n\t\t);\n}\nEXPORT_SYMBOL_GPL(usbnet_cdc_update_filter);\n\n \nstatic const struct ethtool_ops cdc_ether_ethtool_ops = {\n\t.get_link\t\t= usbnet_get_link,\n\t.nway_reset\t\t= usbnet_nway_reset,\n\t.get_drvinfo\t\t= usbnet_get_drvinfo,\n\t.get_msglevel\t\t= usbnet_get_msglevel,\n\t.set_msglevel\t\t= usbnet_set_msglevel,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_link_ksettings\t= usbnet_get_link_ksettings_internal,\n\t.set_link_ksettings\t= NULL,\n};\n\n \nint usbnet_generic_cdc_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tu8\t\t\t\t*buf = intf->cur_altsetting->extra;\n\tint\t\t\t\tlen = intf->cur_altsetting->extralen;\n\tstruct usb_interface_descriptor\t*d;\n\tstruct cdc_state\t\t*info = (void *) &dev->data;\n\tint\t\t\t\tstatus;\n\tint\t\t\t\trndis;\n\tbool\t\t\t\tandroid_rndis_quirk = false;\n\tstruct usb_driver\t\t*driver = driver_of(intf);\n\tstruct usb_cdc_parsed_header header;\n\n\tif (sizeof(dev->data) < sizeof(*info))\n\t\treturn -EDOM;\n\n\t \n\tif (len == 0 && dev->udev->actconfig->extralen) {\n\t\t \n\t\tbuf = dev->udev->actconfig->extra;\n\t\tlen = dev->udev->actconfig->extralen;\n\t\tdev_dbg(&intf->dev, \"CDC descriptors on config\\n\");\n\t}\n\n\t \n\tif (len == 0) {\n\t\tstruct usb_host_endpoint\t*hep;\n\n\t\thep = intf->cur_altsetting->endpoint;\n\t\tif (hep) {\n\t\t\tbuf = hep->extra;\n\t\t\tlen = hep->extralen;\n\t\t}\n\t\tif (len)\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"CDC descriptors on endpoint\\n\");\n\t}\n\n\t \n\trndis = (is_rndis(&intf->cur_altsetting->desc) ||\n\t\t is_activesync(&intf->cur_altsetting->desc) ||\n\t\t is_wireless_rndis(&intf->cur_altsetting->desc) ||\n\t\t is_novatel_rndis(&intf->cur_altsetting->desc));\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->control = intf;\n\n\tcdc_parse_cdc_header(&header, intf, buf, len);\n\n\tinfo->u = header.usb_cdc_union_desc;\n\tinfo->header = header.usb_cdc_header_desc;\n\tinfo->ether = header.usb_cdc_ether_desc;\n\tif (!info->u) {\n\t\tif (rndis)\n\t\t\tgoto skip;\n\t\telse  \n\t\t\tgoto bad_desc;\n\t}\n\t \n\tinfo->control = usb_ifnum_to_if(dev->udev, info->u->bMasterInterface0);\n\tinfo->data = usb_ifnum_to_if(dev->udev, info->u->bSlaveInterface0);\n\tif (!info->control || !info->data) {\n\t\tdev_dbg(&intf->dev,\n\t\t\t\"master #%u/%p slave #%u/%p\\n\",\n\t\t\tinfo->u->bMasterInterface0,\n\t\t\tinfo->control,\n\t\t\tinfo->u->bSlaveInterface0,\n\t\t\tinfo->data);\n\t\t \n\t\tif (rndis) {\n\t\t\tandroid_rndis_quirk = true;\n\t\t\tgoto skip;\n\t\t}\n\t\tgoto bad_desc;\n\t}\n\tif (info->control != intf) {\n\t\tdev_dbg(&intf->dev, \"bogus CDC Union\\n\");\n\t\t \n\t\tif (info->data == intf) {\n\t\t\tinfo->data = info->control;\n\t\t\tinfo->control = intf;\n\t\t} else\n\t\t\tgoto bad_desc;\n\t}\n\n\t \n\tif (info->control == info->data)\n\t\tgoto skip;\n\n\t \n\td = &info->data->cur_altsetting->desc;\n\tif (d->bInterfaceClass != USB_CLASS_CDC_DATA) {\n\t\tdev_dbg(&intf->dev, \"slave class %u\\n\", d->bInterfaceClass);\n\t\tgoto bad_desc;\n\t}\nskip:\n\t \n\tif (rndis && is_rndis(&intf->cur_altsetting->desc) &&\n\t    header.usb_cdc_acm_descriptor &&\n\t    header.usb_cdc_acm_descriptor->bmCapabilities) {\n\t\tdev_dbg(&intf->dev,\n\t\t\t\"ACM capabilities %02x, not really RNDIS?\\n\",\n\t\t\theader.usb_cdc_acm_descriptor->bmCapabilities);\n\t\tgoto bad_desc;\n\t}\n\n\tif (header.usb_cdc_ether_desc && info->ether->wMaxSegmentSize) {\n\t\tdev->hard_mtu = le16_to_cpu(info->ether->wMaxSegmentSize);\n\t\t \n\t}\n\n\tif (header.usb_cdc_mdlm_desc &&\n\t    memcmp(header.usb_cdc_mdlm_desc->bGUID, mbm_guid, 16)) {\n\t\tdev_dbg(&intf->dev, \"GUID doesn't match\\n\");\n\t\tgoto bad_desc;\n\t}\n\n\tif (header.usb_cdc_mdlm_detail_desc &&\n\t\theader.usb_cdc_mdlm_detail_desc->bLength <\n\t\t\t(sizeof(struct usb_cdc_mdlm_detail_desc) + 1)) {\n\t\tdev_dbg(&intf->dev, \"Descriptor too short\\n\");\n\t\tgoto bad_desc;\n\t}\n\n\n\n\t \n\tif (rndis && (!info->u || android_rndis_quirk)) {\n\t\tinfo->control = usb_ifnum_to_if(dev->udev, 0);\n\t\tinfo->data = usb_ifnum_to_if(dev->udev, 1);\n\t\tif (!info->control || !info->data || info->control != intf) {\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"rndis: master #0/%p slave #1/%p\\n\",\n\t\t\t\tinfo->control,\n\t\t\t\tinfo->data);\n\t\t\tgoto bad_desc;\n\t\t}\n\n\t} else if (!info->header || (!rndis && !info->ether)) {\n\t\tdev_dbg(&intf->dev, \"missing cdc %s%s%sdescriptor\\n\",\n\t\t\tinfo->header ? \"\" : \"header \",\n\t\t\tinfo->u ? \"\" : \"union \",\n\t\t\tinfo->ether ? \"\" : \"ether \");\n\t\tgoto bad_desc;\n\t}\n\n\t \n\tif (info->data != info->control) {\n\t\tstatus = usb_driver_claim_interface(driver, info->data, dev);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\tstatus = usbnet_get_endpoints(dev, info->data);\n\tif (status < 0) {\n\t\t \n\t\tusb_set_intfdata(info->data, NULL);\n\t\tif (info->data != info->control)\n\t\t\tusb_driver_release_interface(driver, info->data);\n\t\treturn status;\n\t}\n\n\t \n\tif (info->data != info->control)\n\t\tdev->status = NULL;\n\tif (info->control->cur_altsetting->desc.bNumEndpoints == 1) {\n\t\tstruct usb_endpoint_descriptor\t*desc;\n\n\t\tdev->status = &info->control->cur_altsetting->endpoint[0];\n\t\tdesc = &dev->status->desc;\n\t\tif (!usb_endpoint_is_int_in(desc) ||\n\t\t    (le16_to_cpu(desc->wMaxPacketSize)\n\t\t     < sizeof(struct usb_cdc_notification)) ||\n\t\t    !desc->bInterval) {\n\t\t\tdev_dbg(&intf->dev, \"bad notification endpoint\\n\");\n\t\t\tdev->status = NULL;\n\t\t}\n\t}\n\tif (rndis && !dev->status) {\n\t\tdev_dbg(&intf->dev, \"missing RNDIS status endpoint\\n\");\n\t\tusb_set_intfdata(info->data, NULL);\n\t\tusb_driver_release_interface(driver, info->data);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdev->net->ethtool_ops = &cdc_ether_ethtool_ops;\n\n\treturn 0;\n\nbad_desc:\n\tdev_info(&dev->udev->dev, \"bad CDC descriptors\\n\");\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(usbnet_generic_cdc_bind);\n\n\n \nint usbnet_ether_cdc_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint rv;\n\n\trv = usbnet_generic_cdc_bind(dev, intf);\n\tif (rv < 0)\n\t\tgoto bail_out;\n\n\t \n\tusbnet_cdc_update_filter(dev);\n\nbail_out:\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(usbnet_ether_cdc_bind);\n\nvoid usbnet_cdc_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct cdc_state\t\t*info = (void *) &dev->data;\n\tstruct usb_driver\t\t*driver = driver_of(intf);\n\n\t \n\tif (info->data == info->control)\n\t\treturn;\n\n\t \n\tif (intf == info->control && info->data) {\n\t\t \n\t\tusb_set_intfdata(info->data, NULL);\n\t\tusb_driver_release_interface(driver, info->data);\n\t\tinfo->data = NULL;\n\t}\n\n\t \n\telse if (intf == info->data && info->control) {\n\t\t \n\t\tusb_set_intfdata(info->control, NULL);\n\t\tusb_driver_release_interface(driver, info->control);\n\t\tinfo->control = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(usbnet_cdc_unbind);\n\n \n\nstatic void speed_change(struct usbnet *dev, __le32 *speeds)\n{\n\tdev->tx_speed = __le32_to_cpu(speeds[0]);\n\tdev->rx_speed = __le32_to_cpu(speeds[1]);\n}\n\nvoid usbnet_cdc_status(struct usbnet *dev, struct urb *urb)\n{\n\tstruct usb_cdc_notification\t*event;\n\n\tif (urb->actual_length < sizeof(*event))\n\t\treturn;\n\n\t \n\tif (test_and_clear_bit(EVENT_STS_SPLIT, &dev->flags)) {\n\t\tspeed_change(dev, (__le32 *) urb->transfer_buffer);\n\t\treturn;\n\t}\n\n\tevent = urb->transfer_buffer;\n\tswitch (event->bNotificationType) {\n\tcase USB_CDC_NOTIFY_NETWORK_CONNECTION:\n\t\tnetif_dbg(dev, timer, dev->net, \"CDC: carrier %s\\n\",\n\t\t\t  event->wValue ? \"on\" : \"off\");\n\t\tusbnet_link_change(dev, !!event->wValue, 0);\n\t\tbreak;\n\tcase USB_CDC_NOTIFY_SPEED_CHANGE:\t \n\t\tnetif_dbg(dev, timer, dev->net, \"CDC: speed change (len %d)\\n\",\n\t\t\t  urb->actual_length);\n\t\tif (urb->actual_length != (sizeof(*event) + 8))\n\t\t\tset_bit(EVENT_STS_SPLIT, &dev->flags);\n\t\telse\n\t\t\tspeed_change(dev, (__le32 *) &event[1]);\n\t\tbreak;\n\t \n\tdefault:\n\t\tnetdev_err(dev->net, \"CDC: unexpected notification %02x!\\n\",\n\t\t\t   event->bNotificationType);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(usbnet_cdc_status);\n\nint usbnet_cdc_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint\t\t\t\tstatus;\n\tstruct cdc_state\t\t*info = (void *) &dev->data;\n\n\tBUILD_BUG_ON((sizeof(((struct usbnet *)0)->data)\n\t\t\t< sizeof(struct cdc_state)));\n\n\tstatus = usbnet_ether_cdc_bind(dev, intf);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = usbnet_get_ethernet_addr(dev, info->ether->iMACAddress);\n\tif (status < 0) {\n\t\tusb_set_intfdata(info->data, NULL);\n\t\tusb_driver_release_interface(driver_of(intf), info->data);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usbnet_cdc_bind);\n\nstatic int usbnet_cdc_zte_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint status = usbnet_cdc_bind(dev, intf);\n\n\tif (!status && (dev->net->dev_addr[0] & 0x02))\n\t\teth_hw_addr_random(dev->net);\n\n\treturn status;\n}\n\n \nint usbnet_cdc_zte_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tif (skb->len < ETH_HLEN || !(skb->data[0] & 0x02))\n\t\treturn 1;\n\n\tskb_reset_mac_header(skb);\n\tether_addr_copy(eth_hdr(skb)->h_dest, dev->net->dev_addr);\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(usbnet_cdc_zte_rx_fixup);\n\n \nstatic void usbnet_cdc_zte_status(struct usbnet *dev, struct urb *urb)\n{\n\tstruct usb_cdc_notification *event;\n\n\tif (urb->actual_length < sizeof(*event))\n\t\treturn;\n\n\tevent = urb->transfer_buffer;\n\n\tif (event->bNotificationType != USB_CDC_NOTIFY_NETWORK_CONNECTION) {\n\t\tusbnet_cdc_status(dev, urb);\n\t\treturn;\n\t}\n\n\tnetif_dbg(dev, timer, dev->net, \"CDC: carrier %s\\n\",\n\t\t  event->wValue ? \"on\" : \"off\");\n\n\tif (event->wValue &&\n\t    netif_carrier_ok(dev->net))\n\t\tnetif_carrier_off(dev->net);\n\n\tusbnet_link_change(dev, !!event->wValue, 0);\n}\n\nstatic const struct driver_info\tcdc_info = {\n\t.description =\t\"CDC Ethernet Device\",\n\t.flags =\tFLAG_ETHER | FLAG_POINTTOPOINT,\n\t.bind =\t\tusbnet_cdc_bind,\n\t.unbind =\tusbnet_cdc_unbind,\n\t.status =\tusbnet_cdc_status,\n\t.set_rx_mode =\tusbnet_cdc_update_filter,\n\t.manage_power =\tusbnet_manage_power,\n};\n\nstatic const struct driver_info\tzte_cdc_info = {\n\t.description =\t\"ZTE CDC Ethernet Device\",\n\t.flags =\tFLAG_ETHER | FLAG_POINTTOPOINT,\n\t.bind =\t\tusbnet_cdc_zte_bind,\n\t.unbind =\tusbnet_cdc_unbind,\n\t.status =\tusbnet_cdc_zte_status,\n\t.set_rx_mode =\tusbnet_cdc_update_filter,\n\t.manage_power =\tusbnet_manage_power,\n\t.rx_fixup = usbnet_cdc_zte_rx_fixup,\n};\n\nstatic const struct driver_info wwan_info = {\n\t.description =\t\"Mobile Broadband Network Device\",\n\t.flags =\tFLAG_WWAN,\n\t.bind =\t\tusbnet_cdc_bind,\n\t.unbind =\tusbnet_cdc_unbind,\n\t.status =\tusbnet_cdc_status,\n\t.set_rx_mode =\tusbnet_cdc_update_filter,\n\t.manage_power =\tusbnet_manage_power,\n};\n\n \n\n#define HUAWEI_VENDOR_ID\t0x12D1\n#define NOVATEL_VENDOR_ID\t0x1410\n#define ZTE_VENDOR_ID\t\t0x19D2\n#define DELL_VENDOR_ID\t\t0x413C\n#define REALTEK_VENDOR_ID\t0x0bda\n#define SAMSUNG_VENDOR_ID\t0x04e8\n#define LENOVO_VENDOR_ID\t0x17ef\n#define LINKSYS_VENDOR_ID\t0x13b1\n#define NVIDIA_VENDOR_ID\t0x0955\n#define HP_VENDOR_ID\t\t0x03f0\n#define MICROSOFT_VENDOR_ID\t0x045e\n#define UBLOX_VENDOR_ID\t\t0x1546\n#define TPLINK_VENDOR_ID\t0x2357\n#define AQUANTIA_VENDOR_ID\t0x2eca\n#define ASIX_VENDOR_ID\t\t0x0b95\n\nstatic const struct usb_device_id\tproducts[] = {\n \n\n#define\tZAURUS_MASTER_INTERFACE \\\n\t.bInterfaceClass\t= USB_CLASS_COMM, \\\n\t.bInterfaceSubClass\t= USB_CDC_SUBCLASS_ETHERNET, \\\n\t.bInterfaceProtocol\t= USB_CDC_PROTO_NONE\n\n#define ZAURUS_FAKE_INTERFACE \\\n\t.bInterfaceClass\t= USB_CLASS_COMM, \\\n\t.bInterfaceSubClass\t= USB_CDC_SUBCLASS_MDLM, \\\n\t.bInterfaceProtocol\t= USB_CDC_PROTO_NONE\n\n \n{\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8004,\n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info\t\t= 0,\n},\n\n \n{\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8005,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info\t\t= 0,\n}, {\n\t.match_flags\t=   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8005,    \n\tZAURUS_FAKE_INTERFACE,\n\t.driver_info        = 0,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8006,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info\t\t= 0,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8006,    \n\tZAURUS_FAKE_INTERFACE,\n\t.driver_info        = 0,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8007,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info\t\t= 0,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t\t  | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor\t\t= 0x04DD,\n\t.idProduct\t\t= 0x8007,    \n\tZAURUS_FAKE_INTERFACE,\n\t.driver_info        = 0,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor               = 0x04DD,\n\t.idProduct              = 0x9031,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info\t\t= 0,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor               = 0x04DD,\n\t.idProduct              = 0x9032,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info\t\t= 0,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor               = 0x04DD,\n\t.idProduct              = 0x9032,\t \n\tZAURUS_FAKE_INTERFACE,\n\t.driver_info\t\t= 0,\n}, {\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor               = 0x04DD,\n\t \n\t.idProduct              = 0x9050,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info\t\t= 0,\n},\n\n \n{\n\t.match_flags    =   USB_DEVICE_ID_MATCH_INT_INFO\n\t\t | USB_DEVICE_ID_MATCH_DEVICE,\n\t.idVendor               = 0x07B4,\n\t.idProduct              = 0x0F02,\t \n\tZAURUS_MASTER_INTERFACE,\n\t.driver_info\t\t= 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(0x1004, 0x61aa, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(0x046d, 0xc11f, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_MDLM, USB_CDC_PROTO_NONE),\n\t.driver_info\t\t= 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(NOVATEL_VENDOR_ID, 0xB001, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(NOVATEL_VENDOR_ID, 0x9010, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(DELL_VENDOR_ID, 0x8195, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(DELL_VENDOR_ID, 0x8196, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(DELL_VENDOR_ID, 0x819b, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(NOVATEL_VENDOR_ID, 0x9011, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(HP_VENDOR_ID, 0x421d, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(0x16d5, 0x650a, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_INTERFACE_NUMBER(HUAWEI_VENDOR_ID, 0x14ac, 1),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(REALTEK_VENDOR_ID, 0x8153, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(LENOVO_VENDOR_ID, 0x721e, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(AQUANTIA_VENDOR_ID, 0xc101,\n\t\t\t\t      USB_CLASS_COMM, USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(ASIX_VENDOR_ID, 0x2790, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(ASIX_VENDOR_ID, 0x2791, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(0x20f4, 0xe05a, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\tUSB_DEVICE_AND_INTERFACE_INFO(0x1c04, 0x0015, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = 0,\n},\n\n \n{\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1003, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1015, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1173, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1177, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1181, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\t \n\tUSB_VENDOR_AND_INTERFACE_INFO(0x1bc7, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = (kernel_ulong_t) &wwan_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(DELL_VENDOR_ID, 0x81ba, USB_CLASS_COMM,\n\t\t\tUSB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t.driver_info = (kernel_ulong_t)&wwan_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0x15c1, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\t \n\tUSB_VENDOR_AND_INTERFACE_INFO(ZTE_VENDOR_ID, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&zte_cdc_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(UBLOX_VENDOR_ID, 0x1143, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(UBLOX_VENDOR_ID, 0x1104, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(UBLOX_VENDOR_ID, 0x1313, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(UBLOX_VENDOR_ID, 0x1343, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x1e2d, 0x0061, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x1e2d, 0x0055, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x1e2d, 0x005b, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\t \n\tUSB_DEVICE_AND_INTERFACE_INFO(0x1e2d, 0x0069, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t      USB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n}, {\n\tUSB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ETHERNET,\n\t\t\tUSB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long) &cdc_info,\n}, {\n\tUSB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_MDLM,\n\t\t\tUSB_CDC_PROTO_NONE),\n\t.driver_info = (unsigned long)&wwan_info,\n\n}, {\n\t \n\tUSB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_COMM,\n\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET, 255),\n\t.driver_info = (unsigned long)&wwan_info,\n},\n\t{ },\t\t \n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver cdc_driver = {\n\t.name =\t\t\"cdc_ether\",\n\t.id_table =\tproducts,\n\t.probe =\tusbnet_probe,\n\t.disconnect =\tusbnet_disconnect,\n\t.suspend =\tusbnet_suspend,\n\t.resume =\tusbnet_resume,\n\t.reset_resume =\tusbnet_resume,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(cdc_driver);\n\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_DESCRIPTION(\"USB CDC Ethernet devices\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}