{
  "module_name": "pegasus.c",
  "hash_id": "b7dc5a70abdaf2a536549c510c3e63d4328aad3f0a311981fa77b7d279fd9525",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/pegasus.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/module.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n#include \"pegasus.h\"\n\n \n#define DRIVER_AUTHOR \"Petko Manolov <petkan@nucleusys.com>\"\n#define DRIVER_DESC \"Pegasus/Pegasus II USB Ethernet driver\"\n\nstatic const char driver_name[] = \"pegasus\";\n\n#undef\tPEGASUS_WRITE_EEPROM\n#define\tBMSR_MEDIA\t(BMSR_10HALF | BMSR_10FULL | BMSR_100HALF | \\\n\t\t\tBMSR_100FULL | BMSR_ANEGCAPABLE)\n#define CARRIER_CHECK_DELAY (2 * HZ)\n\nstatic bool loopback;\nstatic bool mii_mode;\nstatic char *devid;\n\nstatic struct usb_eth_dev usb_dev_id[] = {\n#define\tPEGASUS_DEV(pn, vid, pid, flags)\t\\\n\t{.name = pn, .vendor = vid, .device = pid, .private = flags},\n#define PEGASUS_DEV_CLASS(pn, vid, pid, dclass, flags) \\\n\tPEGASUS_DEV(pn, vid, pid, flags)\n#include \"pegasus.h\"\n#undef\tPEGASUS_DEV\n#undef\tPEGASUS_DEV_CLASS\n\t{NULL, 0, 0, 0},\n\t{NULL, 0, 0, 0}\n};\n\nstatic struct usb_device_id pegasus_ids[] = {\n#define\tPEGASUS_DEV(pn, vid, pid, flags) \\\n\t{.match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = vid, .idProduct = pid},\n \n#define PEGASUS_DEV_CLASS(pn, vid, pid, dclass, flags) \\\n\t{.match_flags = (USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_CLASS), \\\n\t.idVendor = vid, .idProduct = pid, .bDeviceClass = dclass},\n#include \"pegasus.h\"\n#undef\tPEGASUS_DEV\n#undef\tPEGASUS_DEV_CLASS\n\t{},\n\t{}\n};\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nmodule_param(loopback, bool, 0);\nmodule_param(mii_mode, bool, 0);\nmodule_param(devid, charp, 0);\nMODULE_PARM_DESC(loopback, \"Enable MAC loopback mode (bit 0)\");\nMODULE_PARM_DESC(mii_mode, \"Enable HomePNA mode (bit 0),default=MII mode = 0\");\nMODULE_PARM_DESC(devid, \"The format is: 'DEV_name:VendorID:DeviceID:Flags'\");\n\n \nstatic int msg_level = -1;\nmodule_param(msg_level, int, 0);\nMODULE_PARM_DESC(msg_level, \"Override default message level\");\n\nMODULE_DEVICE_TABLE(usb, pegasus_ids);\nstatic const struct net_device_ops pegasus_netdev_ops;\n\n \n\nstatic void async_ctrl_callback(struct urb *urb)\n{\n\tstruct usb_ctrlrequest *req = (struct usb_ctrlrequest *)urb->context;\n\tint status = urb->status;\n\n\tif (status < 0)\n\t\tdev_dbg(&urb->dev->dev, \"%s failed with %d\", __func__, status);\n\tkfree(req);\n\tusb_free_urb(urb);\n}\n\nstatic int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\treturn usb_control_msg_recv(pegasus->usb, 0, PEGASUS_REQ_GET_REGS,\n\t\t\t\t   PEGASUS_REQT_READ, 0, indx, data, size,\n\t\t\t\t   1000, GFP_NOIO);\n}\n\nstatic int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,\n\t\t\t const void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg_send(pegasus->usb, 0, PEGASUS_REQ_SET_REGS,\n\t\t\t\t    PEGASUS_REQT_WRITE, 0, indx, data, size,\n\t\t\t\t    1000, GFP_NOIO);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net, \"%s failed with %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\n \nstatic int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tvoid *buf = &data;\n\tint ret;\n\n\tret = usb_control_msg_send(pegasus->usb, 0, PEGASUS_REQ_SET_REG,\n\t\t\t\t    PEGASUS_REQT_WRITE, data, indx, buf, 1,\n\t\t\t\t    1000, GFP_NOIO);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net, \"%s failed with %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic int update_eth_regs_async(pegasus_t *pegasus)\n{\n\tint ret = -ENOMEM;\n\tstruct urb *async_urb;\n\tstruct usb_ctrlrequest *req;\n\n\treq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);\n\tif (req == NULL)\n\t\treturn ret;\n\n\tasync_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (async_urb == NULL) {\n\t\tkfree(req);\n\t\treturn ret;\n\t}\n\treq->bRequestType = PEGASUS_REQT_WRITE;\n\treq->bRequest = PEGASUS_REQ_SET_REGS;\n\treq->wValue = cpu_to_le16(0);\n\treq->wIndex = cpu_to_le16(EthCtrl0);\n\treq->wLength = cpu_to_le16(3);\n\n\tusb_fill_control_urb(async_urb, pegasus->usb,\n\t\t\t     usb_sndctrlpipe(pegasus->usb, 0), (void *)req,\n\t\t\t     pegasus->eth_regs, 3, async_ctrl_callback, req);\n\n\tret = usb_submit_urb(async_urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tif (ret == -ENODEV)\n\t\t\tnetif_device_detach(pegasus->net);\n\t\tnetif_err(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\t}\n\treturn ret;\n}\n\nstatic int __mii_op(pegasus_t *p, __u8 phy, __u8 indx, __u16 *regd, __u8 cmd)\n{\n\tint i, ret;\n\t__le16 regdi;\n\t__u8 data[4] = { phy, 0, 0, indx };\n\n\tif (cmd & PHY_WRITE) {\n\t\t__le16 *t = (__le16 *) & data[1];\n\t\t*t = cpu_to_le16(*regd);\n\t}\n\tset_register(p, PhyCtrl, 0);\n\tset_registers(p, PhyAddr, sizeof(data), data);\n\tset_register(p, PhyCtrl, (indx | cmd));\n\tfor (i = 0; i < REG_TIMEOUT; i++) {\n\t\tret = get_registers(p, PhyCtrl, 1, data);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tif (data[0] & PHY_DONE)\n\t\t\tbreak;\n\t}\n\tif (i >= REG_TIMEOUT) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto fail;\n\t}\n\tif (cmd & PHY_READ) {\n\t\tret = get_registers(p, PhyData, 2, &regdi);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\t*regd = le16_to_cpu(regdi);\n\t}\n\treturn 0;\nfail:\n\tnetif_dbg(p, drv, p->net, \"%s failed\\n\", __func__);\n\treturn ret;\n}\n\n \nstatic int read_mii_word(pegasus_t *pegasus, __u8 phy, __u8 indx, __u16 *regd)\n{\n\treturn __mii_op(pegasus, phy, indx, regd, PHY_READ);\n}\n\n \nstatic int write_mii_word(pegasus_t *pegasus, __u8 phy, __u8 indx, __u16 *regd)\n{\n\treturn __mii_op(pegasus, phy, indx, regd, PHY_WRITE);\n}\n\nstatic int mdio_read(struct net_device *dev, int phy_id, int loc)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\tint ret;\n\tu16 res;\n\n\tret = read_mii_word(pegasus, phy_id, loc, &res);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (int)res;\n}\n\nstatic void mdio_write(struct net_device *dev, int phy_id, int loc, int val)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\tu16 data = val;\n\n\twrite_mii_word(pegasus, phy_id, loc, &data);\n}\n\nstatic int read_eprom_word(pegasus_t *pegasus, __u8 index, __u16 *retdata)\n{\n\tint ret, i;\n\t__le16 retdatai;\n\t__u8 tmp = 0;\n\n\tset_register(pegasus, EpromCtrl, 0);\n\tset_register(pegasus, EpromOffset, index);\n\tset_register(pegasus, EpromCtrl, EPROM_READ);\n\n\tfor (i = 0; i < REG_TIMEOUT; i++) {\n\t\tret = get_registers(pegasus, EpromCtrl, 1, &tmp);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tif (tmp & EPROM_DONE)\n\t\t\tbreak;\n\t}\n\tif (i >= REG_TIMEOUT) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto fail;\n\t}\n\n\tret = get_registers(pegasus, EpromData, 2, &retdatai);\n\tif (ret < 0)\n\t\tgoto fail;\n\t*retdata = le16_to_cpu(retdatai);\n\treturn ret;\n\nfail:\n\tnetif_dbg(pegasus, drv, pegasus->net, \"%s failed\\n\", __func__);\n\treturn ret;\n}\n\n#ifdef\tPEGASUS_WRITE_EEPROM\nstatic inline void enable_eprom_write(pegasus_t *pegasus)\n{\n\t__u8 tmp;\n\n\tget_registers(pegasus, EthCtrl2, 1, &tmp);\n\tset_register(pegasus, EthCtrl2, tmp | EPROM_WR_ENABLE);\n}\n\nstatic inline void disable_eprom_write(pegasus_t *pegasus)\n{\n\t__u8 tmp;\n\n\tget_registers(pegasus, EthCtrl2, 1, &tmp);\n\tset_register(pegasus, EpromCtrl, 0);\n\tset_register(pegasus, EthCtrl2, tmp & ~EPROM_WR_ENABLE);\n}\n\nstatic int write_eprom_word(pegasus_t *pegasus, __u8 index, __u16 data)\n{\n\tint i;\n\t__u8 tmp, d[4] = { 0x3f, 0, 0, EPROM_WRITE };\n\tint ret;\n\t__le16 le_data = cpu_to_le16(data);\n\n\tset_registers(pegasus, EpromOffset, 4, d);\n\tenable_eprom_write(pegasus);\n\tset_register(pegasus, EpromOffset, index);\n\tset_registers(pegasus, EpromData, 2, &le_data);\n\tset_register(pegasus, EpromCtrl, EPROM_WRITE);\n\n\tfor (i = 0; i < REG_TIMEOUT; i++) {\n\t\tret = get_registers(pegasus, EpromCtrl, 1, &tmp);\n\t\tif (ret == -ESHUTDOWN)\n\t\t\tgoto fail;\n\t\tif (tmp & EPROM_DONE)\n\t\t\tbreak;\n\t}\n\tdisable_eprom_write(pegasus);\n\tif (i >= REG_TIMEOUT)\n\t\tgoto fail;\n\n\treturn ret;\n\nfail:\n\tnetif_dbg(pegasus, drv, pegasus->net, \"%s failed\\n\", __func__);\n\treturn -ETIMEDOUT;\n}\n#endif\t \n\nstatic inline int get_node_id(pegasus_t *pegasus, u8 *id)\n{\n\tint i, ret;\n\tu16 w16;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = read_eprom_word(pegasus, i, &w16);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t((__le16 *) id)[i] = cpu_to_le16(w16);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_ethernet_addr(pegasus_t *pegasus)\n{\n\tint ret;\n\tu8 node_id[6];\n\n\tif (pegasus->features & PEGASUS_II) {\n\t\tret = get_registers(pegasus, 0x10, sizeof(node_id), node_id);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tret = get_node_id(pegasus, node_id);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tret = set_registers(pegasus, EthID, sizeof(node_id), node_id);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\teth_hw_addr_set(pegasus->net, node_id);\n\n\treturn;\nerr:\n\teth_hw_addr_random(pegasus->net);\n\tnetif_dbg(pegasus, drv, pegasus->net, \"software assigned MAC address.\\n\");\n\n\treturn;\n}\n\nstatic inline int reset_mac(pegasus_t *pegasus)\n{\n\tint ret, i;\n\t__u8 data = 0x8;\n\n\tset_register(pegasus, EthCtrl1, data);\n\tfor (i = 0; i < REG_TIMEOUT; i++) {\n\t\tret = get_registers(pegasus, EthCtrl1, 1, &data);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tif (~data & 0x08) {\n\t\t\tif (loopback)\n\t\t\t\tbreak;\n\t\t\tif (mii_mode && (pegasus->features & HAS_HOME_PNA))\n\t\t\t\tset_register(pegasus, Gpio1, 0x34);\n\t\t\telse\n\t\t\t\tset_register(pegasus, Gpio1, 0x26);\n\t\t\tset_register(pegasus, Gpio0, pegasus->features);\n\t\t\tset_register(pegasus, Gpio0, DEFAULT_GPIO_SET);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == REG_TIMEOUT)\n\t\treturn -ETIMEDOUT;\n\n\tif (usb_dev_id[pegasus->dev_index].vendor == VENDOR_LINKSYS ||\n\t    usb_dev_id[pegasus->dev_index].vendor == VENDOR_DLINK) {\n\t\tset_register(pegasus, Gpio0, 0x24);\n\t\tset_register(pegasus, Gpio0, 0x26);\n\t}\n\tif (usb_dev_id[pegasus->dev_index].vendor == VENDOR_ELCON) {\n\t\t__u16 auxmode;\n\t\tret = read_mii_word(pegasus, 3, 0x1b, &auxmode);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tauxmode |= 4;\n\t\twrite_mii_word(pegasus, 3, 0x1b, &auxmode);\n\t}\n\n\treturn 0;\nfail:\n\tnetif_dbg(pegasus, drv, pegasus->net, \"%s failed\\n\", __func__);\n\treturn ret;\n}\n\nstatic int enable_net_traffic(struct net_device *dev, struct usb_device *usb)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\tint ret;\n\t__u16 linkpart;\n\t__u8 data[4];\n\n\tret = read_mii_word(pegasus, pegasus->phy, MII_LPA, &linkpart);\n\tif (ret < 0)\n\t\tgoto fail;\n\tdata[0] = 0xc8;  \n\tdata[1] = 0;\n\tif (linkpart & (ADVERTISE_100FULL | ADVERTISE_10FULL))\n\t\tdata[1] |= 0x20;\t \n\tif (linkpart & (ADVERTISE_100FULL | ADVERTISE_100HALF))\n\t\tdata[1] |= 0x10;\t \n\tif (mii_mode)\n\t\tdata[1] = 0;\n\tdata[2] = loopback ? 0x09 : 0x01;\n\n\tmemcpy(pegasus->eth_regs, data, sizeof(data));\n\tret = set_registers(pegasus, EthCtrl0, 3, data);\n\n\tif (usb_dev_id[pegasus->dev_index].vendor == VENDOR_LINKSYS ||\n\t    usb_dev_id[pegasus->dev_index].vendor == VENDOR_LINKSYS2 ||\n\t    usb_dev_id[pegasus->dev_index].vendor == VENDOR_DLINK) {\n\t\tu16 auxmode;\n\t\tret = read_mii_word(pegasus, 0, 0x1b, &auxmode);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tauxmode |= 4;\n\t\twrite_mii_word(pegasus, 0, 0x1b, &auxmode);\n\t}\n\n\treturn ret;\nfail:\n\tnetif_dbg(pegasus, drv, pegasus->net, \"%s failed\\n\", __func__);\n\treturn ret;\n}\n\nstatic void read_bulk_callback(struct urb *urb)\n{\n\tpegasus_t *pegasus = urb->context;\n\tstruct net_device *net;\n\tu8 *buf = urb->transfer_buffer;\n\tint rx_status, count = urb->actual_length;\n\tint status = urb->status;\n\t__u16 pkt_len;\n\n\tif (!pegasus)\n\t\treturn;\n\n\tnet = pegasus->net;\n\tif (!netif_device_present(net) || !netif_running(net))\n\t\treturn;\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ETIME:\n\t\tnetif_dbg(pegasus, rx_err, net, \"reset MAC\\n\");\n\t\tpegasus->flags &= ~PEGASUS_RX_BUSY;\n\t\tbreak;\n\tcase -EPIPE:\t\t \n\t\t \n\t\tnetif_warn(pegasus, rx_err, net, \"no rx stall recovery\\n\");\n\t\treturn;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tnetif_dbg(pegasus, ifdown, net, \"rx unlink, %d\\n\", status);\n\t\treturn;\n\tdefault:\n\t\tnetif_dbg(pegasus, rx_err, net, \"RX status %d\\n\", status);\n\t\tgoto goon;\n\t}\n\n\tif (count < 4)\n\t\tgoto goon;\n\n\trx_status = buf[count - 2];\n\tif (rx_status & 0x1c) {\n\t\tnetif_dbg(pegasus, rx_err, net,\n\t\t\t  \"RX packet error %x\\n\", rx_status);\n\t\tnet->stats.rx_errors++;\n\t\tif (rx_status & 0x04)\t \n\t\t\tnet->stats.rx_length_errors++;\n\t\tif (rx_status & 0x08)\n\t\t\tnet->stats.rx_crc_errors++;\n\t\tif (rx_status & 0x10)\t \n\t\t\tnet->stats.rx_frame_errors++;\n\t\tgoto goon;\n\t}\n\tif (pegasus->chip == 0x8513) {\n\t\tpkt_len = le32_to_cpu(*(__le32 *)urb->transfer_buffer);\n\t\tpkt_len &= 0x0fff;\n\t\tpegasus->rx_skb->data += 2;\n\t} else {\n\t\tpkt_len = buf[count - 3] << 8;\n\t\tpkt_len += buf[count - 4];\n\t\tpkt_len &= 0xfff;\n\t\tpkt_len -= 4;\n\t}\n\n\t \n\tif (pkt_len > PEGASUS_MTU)\n\t\tgoto goon;\n\n\t \n\tskb_put(pegasus->rx_skb, pkt_len);\n\tpegasus->rx_skb->protocol = eth_type_trans(pegasus->rx_skb, net);\n\tnetif_rx(pegasus->rx_skb);\n\tnet->stats.rx_packets++;\n\tnet->stats.rx_bytes += pkt_len;\n\n\tif (pegasus->flags & PEGASUS_UNPLUG)\n\t\treturn;\n\n\tpegasus->rx_skb = __netdev_alloc_skb_ip_align(pegasus->net, PEGASUS_MTU,\n\t\t\t\t\t\t      GFP_ATOMIC);\n\n\tif (pegasus->rx_skb == NULL)\n\t\tgoto tl_sched;\ngoon:\n\tusb_fill_bulk_urb(pegasus->rx_urb, pegasus->usb,\n\t\t\t  usb_rcvbulkpipe(pegasus->usb, 1),\n\t\t\t  pegasus->rx_skb->data, PEGASUS_MTU,\n\t\t\t  read_bulk_callback, pegasus);\n\trx_status = usb_submit_urb(pegasus->rx_urb, GFP_ATOMIC);\n\tif (rx_status == -ENODEV)\n\t\tnetif_device_detach(pegasus->net);\n\telse if (rx_status) {\n\t\tpegasus->flags |= PEGASUS_RX_URB_FAIL;\n\t\tgoto tl_sched;\n\t} else {\n\t\tpegasus->flags &= ~PEGASUS_RX_URB_FAIL;\n\t}\n\n\treturn;\n\ntl_sched:\n\ttasklet_schedule(&pegasus->rx_tl);\n}\n\nstatic void rx_fixup(struct tasklet_struct *t)\n{\n\tpegasus_t *pegasus = from_tasklet(pegasus, t, rx_tl);\n\tint status;\n\n\tif (pegasus->flags & PEGASUS_UNPLUG)\n\t\treturn;\n\n\tif (pegasus->flags & PEGASUS_RX_URB_FAIL)\n\t\tif (pegasus->rx_skb)\n\t\t\tgoto try_again;\n\tif (pegasus->rx_skb == NULL)\n\t\tpegasus->rx_skb = __netdev_alloc_skb_ip_align(pegasus->net,\n\t\t\t\t\t\t\t      PEGASUS_MTU,\n\t\t\t\t\t\t\t      GFP_ATOMIC);\n\tif (pegasus->rx_skb == NULL) {\n\t\tnetif_warn(pegasus, rx_err, pegasus->net, \"low on memory\\n\");\n\t\ttasklet_schedule(&pegasus->rx_tl);\n\t\treturn;\n\t}\n\tusb_fill_bulk_urb(pegasus->rx_urb, pegasus->usb,\n\t\t\t  usb_rcvbulkpipe(pegasus->usb, 1),\n\t\t\t  pegasus->rx_skb->data, PEGASUS_MTU,\n\t\t\t  read_bulk_callback, pegasus);\ntry_again:\n\tstatus = usb_submit_urb(pegasus->rx_urb, GFP_ATOMIC);\n\tif (status == -ENODEV)\n\t\tnetif_device_detach(pegasus->net);\n\telse if (status) {\n\t\tpegasus->flags |= PEGASUS_RX_URB_FAIL;\n\t\ttasklet_schedule(&pegasus->rx_tl);\n\t} else {\n\t\tpegasus->flags &= ~PEGASUS_RX_URB_FAIL;\n\t}\n}\n\nstatic void write_bulk_callback(struct urb *urb)\n{\n\tpegasus_t *pegasus = urb->context;\n\tstruct net_device *net;\n\tint status = urb->status;\n\n\tif (!pegasus)\n\t\treturn;\n\n\tnet = pegasus->net;\n\n\tif (!netif_device_present(net) || !netif_running(net))\n\t\treturn;\n\n\tswitch (status) {\n\tcase -EPIPE:\n\t\t \n\t\tnetif_stop_queue(net);\n\t\tnetif_warn(pegasus, tx_err, net, \"no tx stall recovery\\n\");\n\t\treturn;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tnetif_dbg(pegasus, ifdown, net, \"tx unlink, %d\\n\", status);\n\t\treturn;\n\tdefault:\n\t\tnetif_info(pegasus, tx_err, net, \"TX status %d\\n\", status);\n\t\tfallthrough;\n\tcase 0:\n\t\tbreak;\n\t}\n\n\tnetif_trans_update(net);  \n\tnetif_wake_queue(net);\n}\n\nstatic void intr_callback(struct urb *urb)\n{\n\tpegasus_t *pegasus = urb->context;\n\tstruct net_device *net;\n\tint res, status = urb->status;\n\n\tif (!pegasus)\n\t\treturn;\n\tnet = pegasus->net;\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\t \n\t\tnetif_dbg(pegasus, timer, net, \"intr status %d\\n\", status);\n\t}\n\n\tif (urb->actual_length >= 6) {\n\t\tu8 *d = urb->transfer_buffer;\n\n\t\t \n\t\tif (d[0] & (TX_UNDERRUN|EXCESSIVE_COL\n\t\t\t\t\t|LATE_COL|JABBER_TIMEOUT)) {\n\t\t\tnet->stats.tx_errors++;\n\t\t\tif (d[0] & TX_UNDERRUN)\n\t\t\t\tnet->stats.tx_fifo_errors++;\n\t\t\tif (d[0] & (EXCESSIVE_COL | JABBER_TIMEOUT))\n\t\t\t\tnet->stats.tx_aborted_errors++;\n\t\t\tif (d[0] & LATE_COL)\n\t\t\t\tnet->stats.tx_window_errors++;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tnet->stats.rx_missed_errors += ((d[3] & 0x7f) << 8) | d[4];\n\t}\n\n\tres = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (res == -ENODEV)\n\t\tnetif_device_detach(pegasus->net);\n\tif (res)\n\t\tnetif_err(pegasus, timer, net,\n\t\t\t  \"can't resubmit interrupt urb, %d\\n\", res);\n}\n\nstatic void pegasus_tx_timeout(struct net_device *net, unsigned int txqueue)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\tnetif_warn(pegasus, timer, net, \"tx timeout\\n\");\n\tusb_unlink_urb(pegasus->tx_urb);\n\tnet->stats.tx_errors++;\n}\n\nstatic netdev_tx_t pegasus_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\tint count = ((skb->len + 2) & 0x3f) ? skb->len + 2 : skb->len + 3;\n\tint res;\n\t__u16 l16 = skb->len;\n\n\tnetif_stop_queue(net);\n\n\t((__le16 *) pegasus->tx_buff)[0] = cpu_to_le16(l16);\n\tskb_copy_from_linear_data(skb, pegasus->tx_buff + 2, skb->len);\n\tusb_fill_bulk_urb(pegasus->tx_urb, pegasus->usb,\n\t\t\t  usb_sndbulkpipe(pegasus->usb, 2),\n\t\t\t  pegasus->tx_buff, count,\n\t\t\t  write_bulk_callback, pegasus);\n\tif ((res = usb_submit_urb(pegasus->tx_urb, GFP_ATOMIC))) {\n\t\tnetif_warn(pegasus, tx_err, net, \"fail tx, %d\\n\", res);\n\t\tswitch (res) {\n\t\tcase -EPIPE:\t\t \n\t\t\t \n\t\t\tbreak;\n\t\tcase -ENODEV:\t\t \n\t\tcase -EPERM:\n\t\t\tnetif_device_detach(pegasus->net);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnet->stats.tx_errors++;\n\t\t\tnetif_start_queue(net);\n\t\t}\n\t} else {\n\t\tnet->stats.tx_packets++;\n\t\tnet->stats.tx_bytes += skb->len;\n\t}\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic inline void disable_net_traffic(pegasus_t *pegasus)\n{\n\t__le16 tmp = cpu_to_le16(0);\n\n\tset_registers(pegasus, EthCtrl0, sizeof(tmp), &tmp);\n}\n\nstatic inline int get_interrupt_interval(pegasus_t *pegasus)\n{\n\tu16 data;\n\tu8 interval;\n\tint ret;\n\n\tret = read_eprom_word(pegasus, 4, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinterval = data >> 8;\n\tif (pegasus->usb->speed != USB_SPEED_HIGH) {\n\t\tif (interval < 0x80) {\n\t\t\tnetif_info(pegasus, timer, pegasus->net,\n\t\t\t\t   \"intr interval changed from %ums to %ums\\n\",\n\t\t\t\t   interval, 0x80);\n\t\t\tinterval = 0x80;\n\t\t\tdata = (data & 0x00FF) | ((u16)interval << 8);\n#ifdef PEGASUS_WRITE_EEPROM\n\t\t\twrite_eprom_word(pegasus, 4, data);\n#endif\n\t\t}\n\t}\n\tpegasus->intr_interval = interval;\n\n\treturn 0;\n}\n\nstatic void set_carrier(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\tu16 tmp;\n\n\tif (read_mii_word(pegasus, pegasus->phy, MII_BMSR, &tmp))\n\t\treturn;\n\n\tif (tmp & BMSR_LSTATUS)\n\t\tnetif_carrier_on(net);\n\telse\n\t\tnetif_carrier_off(net);\n}\n\nstatic void free_all_urbs(pegasus_t *pegasus)\n{\n\tusb_free_urb(pegasus->intr_urb);\n\tusb_free_urb(pegasus->tx_urb);\n\tusb_free_urb(pegasus->rx_urb);\n}\n\nstatic void unlink_all_urbs(pegasus_t *pegasus)\n{\n\tusb_kill_urb(pegasus->intr_urb);\n\tusb_kill_urb(pegasus->tx_urb);\n\tusb_kill_urb(pegasus->rx_urb);\n}\n\nstatic int alloc_urbs(pegasus_t *pegasus)\n{\n\tint res = -ENOMEM;\n\n\tpegasus->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pegasus->rx_urb) {\n\t\treturn res;\n\t}\n\tpegasus->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pegasus->tx_urb) {\n\t\tusb_free_urb(pegasus->rx_urb);\n\t\treturn res;\n\t}\n\tpegasus->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pegasus->intr_urb) {\n\t\tusb_free_urb(pegasus->tx_urb);\n\t\tusb_free_urb(pegasus->rx_urb);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic int pegasus_open(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\tint res=-ENOMEM;\n\n\tif (pegasus->rx_skb == NULL)\n\t\tpegasus->rx_skb = __netdev_alloc_skb_ip_align(pegasus->net,\n\t\t\t\t\t\t\t      PEGASUS_MTU,\n\t\t\t\t\t\t\t      GFP_KERNEL);\n\tif (!pegasus->rx_skb)\n\t\tgoto exit;\n\n\tset_registers(pegasus, EthID, 6, net->dev_addr);\n\n\tusb_fill_bulk_urb(pegasus->rx_urb, pegasus->usb,\n\t\t\t  usb_rcvbulkpipe(pegasus->usb, 1),\n\t\t\t  pegasus->rx_skb->data, PEGASUS_MTU,\n\t\t\t  read_bulk_callback, pegasus);\n\tif ((res = usb_submit_urb(pegasus->rx_urb, GFP_KERNEL))) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(pegasus->net);\n\t\tnetif_dbg(pegasus, ifup, net, \"failed rx_urb, %d\\n\", res);\n\t\tgoto exit;\n\t}\n\n\tusb_fill_int_urb(pegasus->intr_urb, pegasus->usb,\n\t\t\t usb_rcvintpipe(pegasus->usb, 3),\n\t\t\t pegasus->intr_buff, sizeof(pegasus->intr_buff),\n\t\t\t intr_callback, pegasus, pegasus->intr_interval);\n\tif ((res = usb_submit_urb(pegasus->intr_urb, GFP_KERNEL))) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(pegasus->net);\n\t\tnetif_dbg(pegasus, ifup, net, \"failed intr_urb, %d\\n\", res);\n\t\tusb_kill_urb(pegasus->rx_urb);\n\t\tgoto exit;\n\t}\n\tres = enable_net_traffic(net, pegasus->usb);\n\tif (res < 0) {\n\t\tnetif_dbg(pegasus, ifup, net,\n\t\t\t  \"can't enable_net_traffic() - %d\\n\", res);\n\t\tres = -EIO;\n\t\tusb_kill_urb(pegasus->rx_urb);\n\t\tusb_kill_urb(pegasus->intr_urb);\n\t\tgoto exit;\n\t}\n\tset_carrier(net);\n\tnetif_start_queue(net);\n\tnetif_dbg(pegasus, ifup, net, \"open\\n\");\n\tres = 0;\nexit:\n\treturn res;\n}\n\nstatic int pegasus_close(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\n\tnetif_stop_queue(net);\n\tif (!(pegasus->flags & PEGASUS_UNPLUG))\n\t\tdisable_net_traffic(pegasus);\n\ttasklet_kill(&pegasus->rx_tl);\n\tunlink_all_urbs(pegasus);\n\n\treturn 0;\n}\n\nstatic void pegasus_get_drvinfo(struct net_device *dev,\n\t\t\t\tstruct ethtool_drvinfo *info)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\n\tstrscpy(info->driver, driver_name, sizeof(info->driver));\n\tusb_make_path(pegasus->usb, info->bus_info, sizeof(info->bus_info));\n}\n\n \n#define\tWOL_SUPPORTED\t(WAKE_MAGIC|WAKE_PHY)\n\nstatic void\npegasus_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tpegasus_t\t*pegasus = netdev_priv(dev);\n\n\twol->supported = WAKE_MAGIC | WAKE_PHY;\n\twol->wolopts = pegasus->wolopts;\n}\n\nstatic int\npegasus_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tpegasus_t\t*pegasus = netdev_priv(dev);\n\tu8\t\treg78 = 0x04;\n\tint\t\tret;\n\n\tif (wol->wolopts & ~WOL_SUPPORTED)\n\t\treturn -EINVAL;\n\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\treg78 |= 0x80;\n\tif (wol->wolopts & WAKE_PHY)\n\t\treg78 |= 0x40;\n\t \n\tif (wol->wolopts)\n\t\tpegasus->eth_regs[0] |= 0x10;\n\telse\n\t\tpegasus->eth_regs[0] &= ~0x10;\n\tpegasus->wolopts = wol->wolopts;\n\n\tret = set_register(pegasus, WakeupControl, reg78);\n\tif (!ret)\n\t\tret = device_set_wakeup_enable(&pegasus->usb->dev,\n\t\t\t\t\t\twol->wolopts);\n\treturn ret;\n}\n\nstatic inline void pegasus_reset_wol(struct net_device *dev)\n{\n\tstruct ethtool_wolinfo wol;\n\n\tmemset(&wol, 0, sizeof wol);\n\t(void) pegasus_set_wol(dev, &wol);\n}\n\nstatic int\npegasus_get_link_ksettings(struct net_device *dev,\n\t\t\t   struct ethtool_link_ksettings *ecmd)\n{\n\tpegasus_t *pegasus;\n\n\tpegasus = netdev_priv(dev);\n\tmii_ethtool_get_link_ksettings(&pegasus->mii, ecmd);\n\treturn 0;\n}\n\nstatic int\npegasus_set_link_ksettings(struct net_device *dev,\n\t\t\t   const struct ethtool_link_ksettings *ecmd)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn mii_ethtool_set_link_ksettings(&pegasus->mii, ecmd);\n}\n\nstatic int pegasus_nway_reset(struct net_device *dev)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn mii_nway_restart(&pegasus->mii);\n}\n\nstatic u32 pegasus_get_link(struct net_device *dev)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn mii_link_ok(&pegasus->mii);\n}\n\nstatic u32 pegasus_get_msglevel(struct net_device *dev)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\treturn pegasus->msg_enable;\n}\n\nstatic void pegasus_set_msglevel(struct net_device *dev, u32 v)\n{\n\tpegasus_t *pegasus = netdev_priv(dev);\n\tpegasus->msg_enable = v;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo = pegasus_get_drvinfo,\n\t.nway_reset = pegasus_nway_reset,\n\t.get_link = pegasus_get_link,\n\t.get_msglevel = pegasus_get_msglevel,\n\t.set_msglevel = pegasus_set_msglevel,\n\t.get_wol = pegasus_get_wol,\n\t.set_wol = pegasus_set_wol,\n\t.get_link_ksettings = pegasus_get_link_ksettings,\n\t.set_link_ksettings = pegasus_set_link_ksettings,\n};\n\nstatic int pegasus_siocdevprivate(struct net_device *net, struct ifreq *rq,\n\t\t\t\t  void __user *udata, int cmd)\n{\n\t__u16 *data = (__u16 *) &rq->ifr_ifru;\n\tpegasus_t *pegasus = netdev_priv(net);\n\tint res;\n\n\tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tdata[0] = pegasus->phy;\n\t\tfallthrough;\n\tcase SIOCDEVPRIVATE + 1:\n\t\tres = read_mii_word(pegasus, data[0], data[1] & 0x1f, &data[3]);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\twrite_mii_word(pegasus, pegasus->phy, data[1] & 0x1f, &data[2]);\n\t\tres = 0;\n\t\tbreak;\n\tdefault:\n\t\tres = -EOPNOTSUPP;\n\t}\n\treturn res;\n}\n\nstatic void pegasus_set_multicast(struct net_device *net)\n{\n\tpegasus_t *pegasus = netdev_priv(net);\n\n\tif (net->flags & IFF_PROMISC) {\n\t\tpegasus->eth_regs[EthCtrl2] |= RX_PROMISCUOUS;\n\t\tnetif_info(pegasus, link, net, \"Promiscuous mode enabled\\n\");\n\t} else if (!netdev_mc_empty(net) || (net->flags & IFF_ALLMULTI)) {\n\t\tpegasus->eth_regs[EthCtrl0] |= RX_MULTICAST;\n\t\tpegasus->eth_regs[EthCtrl2] &= ~RX_PROMISCUOUS;\n\t\tnetif_dbg(pegasus, link, net, \"set allmulti\\n\");\n\t} else {\n\t\tpegasus->eth_regs[EthCtrl0] &= ~RX_MULTICAST;\n\t\tpegasus->eth_regs[EthCtrl2] &= ~RX_PROMISCUOUS;\n\t}\n\tupdate_eth_regs_async(pegasus);\n}\n\nstatic __u8 mii_phy_probe(pegasus_t *pegasus)\n{\n\tint i, ret;\n\t__u16 tmp;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tret = read_mii_word(pegasus, i, MII_BMSR, &tmp);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tif (tmp == 0 || tmp == 0xffff || (tmp & BMSR_MEDIA) == 0)\n\t\t\tcontinue;\n\t\telse\n\t\t\treturn i;\n\t}\nfail:\n\treturn 0xff;\n}\n\nstatic inline void setup_pegasus_II(pegasus_t *pegasus)\n{\n\tint ret;\n\t__u8 data = 0xa5;\n\n\tset_register(pegasus, Reg1d, 0);\n\tset_register(pegasus, Reg7b, 1);\n\tmsleep(100);\n\tif ((pegasus->features & HAS_HOME_PNA) && mii_mode)\n\t\tset_register(pegasus, Reg7b, 0);\n\telse\n\t\tset_register(pegasus, Reg7b, 2);\n\n\tset_register(pegasus, 0x83, data);\n\tret = get_registers(pegasus, 0x83, 1, &data);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (data == 0xa5)\n\t\tpegasus->chip = 0x8513;\n\telse\n\t\tpegasus->chip = 0;\n\n\tset_register(pegasus, 0x80, 0xc0);\n\tset_register(pegasus, 0x83, 0xff);\n\tset_register(pegasus, 0x84, 0x01);\n\n\tif (pegasus->features & HAS_HOME_PNA && mii_mode)\n\t\tset_register(pegasus, Reg81, 6);\n\telse\n\t\tset_register(pegasus, Reg81, 2);\n\n\treturn;\nfail:\n\tnetif_dbg(pegasus, drv, pegasus->net, \"%s failed\\n\", __func__);\n}\n\nstatic void check_carrier(struct work_struct *work)\n{\n\tpegasus_t *pegasus = container_of(work, pegasus_t, carrier_check.work);\n\tset_carrier(pegasus->net);\n\tif (!(pegasus->flags & PEGASUS_UNPLUG)) {\n\t\tqueue_delayed_work(system_long_wq, &pegasus->carrier_check,\n\t\t\tCARRIER_CHECK_DELAY);\n\t}\n}\n\nstatic int pegasus_blacklisted(struct usb_device *udev)\n{\n\tstruct usb_device_descriptor *udd = &udev->descriptor;\n\n\t \n\tif ((udd->idVendor == cpu_to_le16(VENDOR_BELKIN)) &&\n\t    (udd->idProduct == cpu_to_le16(0x0121)) &&\n\t    (udd->bDeviceClass == USB_CLASS_WIRELESS_CONTROLLER) &&\n\t    (udd->bDeviceProtocol == 1))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int pegasus_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct net_device *net;\n\tpegasus_t *pegasus;\n\tint dev_index = id - pegasus_ids;\n\tint res = -ENOMEM;\n\n\tif (pegasus_blacklisted(dev))\n\t\treturn -ENODEV;\n\n\tnet = alloc_etherdev(sizeof(struct pegasus));\n\tif (!net)\n\t\tgoto out;\n\n\tpegasus = netdev_priv(net);\n\tpegasus->dev_index = dev_index;\n\n\tres = alloc_urbs(pegasus);\n\tif (res < 0) {\n\t\tdev_err(&intf->dev, \"can't allocate %s\\n\", \"urbs\");\n\t\tgoto out1;\n\t}\n\n\ttasklet_setup(&pegasus->rx_tl, rx_fixup);\n\n\tINIT_DELAYED_WORK(&pegasus->carrier_check, check_carrier);\n\n\tpegasus->intf = intf;\n\tpegasus->usb = dev;\n\tpegasus->net = net;\n\n\n\tnet->watchdog_timeo = PEGASUS_TX_TIMEOUT;\n\tnet->netdev_ops = &pegasus_netdev_ops;\n\tnet->ethtool_ops = &ops;\n\tpegasus->mii.dev = net;\n\tpegasus->mii.mdio_read = mdio_read;\n\tpegasus->mii.mdio_write = mdio_write;\n\tpegasus->mii.phy_id_mask = 0x1f;\n\tpegasus->mii.reg_num_mask = 0x1f;\n\tpegasus->msg_enable = netif_msg_init(msg_level, NETIF_MSG_DRV\n\t\t\t\t| NETIF_MSG_PROBE | NETIF_MSG_LINK);\n\n\tpegasus->features = usb_dev_id[dev_index].private;\n\tres = get_interrupt_interval(pegasus);\n\tif (res)\n\t\tgoto out2;\n\tif (reset_mac(pegasus)) {\n\t\tdev_err(&intf->dev, \"can't reset MAC\\n\");\n\t\tres = -EIO;\n\t\tgoto out2;\n\t}\n\tset_ethernet_addr(pegasus);\n\tif (pegasus->features & PEGASUS_II) {\n\t\tdev_info(&intf->dev, \"setup Pegasus II specific registers\\n\");\n\t\tsetup_pegasus_II(pegasus);\n\t}\n\tpegasus->phy = mii_phy_probe(pegasus);\n\tif (pegasus->phy == 0xff) {\n\t\tdev_warn(&intf->dev, \"can't locate MII phy, using default\\n\");\n\t\tpegasus->phy = 1;\n\t}\n\tpegasus->mii.phy_id = pegasus->phy;\n\tusb_set_intfdata(intf, pegasus);\n\tSET_NETDEV_DEV(net, &intf->dev);\n\tpegasus_reset_wol(net);\n\tres = register_netdev(net);\n\tif (res)\n\t\tgoto out3;\n\tqueue_delayed_work(system_long_wq, &pegasus->carrier_check,\n\t\t\t   CARRIER_CHECK_DELAY);\n\tdev_info(&intf->dev, \"%s, %s, %pM\\n\", net->name,\n\t\t usb_dev_id[dev_index].name, net->dev_addr);\n\treturn 0;\n\nout3:\n\tusb_set_intfdata(intf, NULL);\nout2:\n\tfree_all_urbs(pegasus);\nout1:\n\tfree_netdev(net);\nout:\n\treturn res;\n}\n\nstatic void pegasus_disconnect(struct usb_interface *intf)\n{\n\tstruct pegasus *pegasus = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tif (!pegasus) {\n\t\tdev_dbg(&intf->dev, \"unregistering non-bound device?\\n\");\n\t\treturn;\n\t}\n\n\tpegasus->flags |= PEGASUS_UNPLUG;\n\tcancel_delayed_work_sync(&pegasus->carrier_check);\n\tunregister_netdev(pegasus->net);\n\tunlink_all_urbs(pegasus);\n\tfree_all_urbs(pegasus);\n\tif (pegasus->rx_skb != NULL) {\n\t\tdev_kfree_skb(pegasus->rx_skb);\n\t\tpegasus->rx_skb = NULL;\n\t}\n\tfree_netdev(pegasus->net);\n}\n\nstatic int pegasus_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct pegasus *pegasus = usb_get_intfdata(intf);\n\n\tnetif_device_detach(pegasus->net);\n\tcancel_delayed_work_sync(&pegasus->carrier_check);\n\tif (netif_running(pegasus->net)) {\n\t\tusb_kill_urb(pegasus->rx_urb);\n\t\tusb_kill_urb(pegasus->intr_urb);\n\t}\n\treturn 0;\n}\n\nstatic int pegasus_resume(struct usb_interface *intf)\n{\n\tstruct pegasus *pegasus = usb_get_intfdata(intf);\n\n\tnetif_device_attach(pegasus->net);\n\tif (netif_running(pegasus->net)) {\n\t\tpegasus->rx_urb->status = 0;\n\t\tpegasus->rx_urb->actual_length = 0;\n\t\tread_bulk_callback(pegasus->rx_urb);\n\n\t\tpegasus->intr_urb->status = 0;\n\t\tpegasus->intr_urb->actual_length = 0;\n\t\tintr_callback(pegasus->intr_urb);\n\t}\n\tqueue_delayed_work(system_long_wq, &pegasus->carrier_check,\n\t\t\t\tCARRIER_CHECK_DELAY);\n\treturn 0;\n}\n\nstatic const struct net_device_ops pegasus_netdev_ops = {\n\t.ndo_open =\t\t\tpegasus_open,\n\t.ndo_stop =\t\t\tpegasus_close,\n\t.ndo_siocdevprivate =\t\tpegasus_siocdevprivate,\n\t.ndo_start_xmit =\t\tpegasus_start_xmit,\n\t.ndo_set_rx_mode =\t\tpegasus_set_multicast,\n\t.ndo_tx_timeout =\t\tpegasus_tx_timeout,\n\t.ndo_set_mac_address =\t\teth_mac_addr,\n\t.ndo_validate_addr =\t\teth_validate_addr,\n};\n\nstatic struct usb_driver pegasus_driver = {\n\t.name = driver_name,\n\t.probe = pegasus_probe,\n\t.disconnect = pegasus_disconnect,\n\t.id_table = pegasus_ids,\n\t.suspend = pegasus_suspend,\n\t.resume = pegasus_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nstatic void __init parse_id(char *id)\n{\n\tunsigned int vendor_id = 0, device_id = 0, flags = 0, i = 0;\n\tchar *token, *name = NULL;\n\n\tif ((token = strsep(&id, \":\")) != NULL)\n\t\tname = token;\n\t \n\tif ((token = strsep(&id, \":\")) != NULL)\n\t\tvendor_id = simple_strtoul(token, NULL, 16);\n\tif ((token = strsep(&id, \":\")) != NULL)\n\t\tdevice_id = simple_strtoul(token, NULL, 16);\n\tflags = simple_strtoul(id, NULL, 16);\n\tpr_info(\"%s: new device %s, vendor ID 0x%04x, device ID 0x%04x, flags: 0x%x\\n\",\n\t\tdriver_name, name, vendor_id, device_id, flags);\n\n\tif (vendor_id > 0x10000 || vendor_id == 0)\n\t\treturn;\n\tif (device_id > 0x10000 || device_id == 0)\n\t\treturn;\n\n\tfor (i = 0; usb_dev_id[i].name; i++);\n\tusb_dev_id[i].name = name;\n\tusb_dev_id[i].vendor = vendor_id;\n\tusb_dev_id[i].device = device_id;\n\tusb_dev_id[i].private = flags;\n\tpegasus_ids[i].match_flags = USB_DEVICE_ID_MATCH_DEVICE;\n\tpegasus_ids[i].idVendor = vendor_id;\n\tpegasus_ids[i].idProduct = device_id;\n}\n\nstatic int __init pegasus_init(void)\n{\n\tpr_info(\"%s: \" DRIVER_DESC \"\\n\", driver_name);\n\tif (devid)\n\t\tparse_id(devid);\n\treturn usb_register(&pegasus_driver);\n}\n\nstatic void __exit pegasus_exit(void)\n{\n\tusb_deregister(&pegasus_driver);\n}\n\nmodule_init(pegasus_init);\nmodule_exit(pegasus_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}