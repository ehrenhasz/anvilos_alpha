{
  "module_name": "kalmia.c",
  "hash_id": "d2c7eae671372af777a1e61001f02b978f5deb12c8eb61686695010a66dfff52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/kalmia.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ctype.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/crc32.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/usbnet.h>\n#include <linux/gfp.h>\n\n \n\n \n \n\n#define KALMIA_HEADER_LENGTH 6\n#define KALMIA_ALIGN_SIZE 4\n#define KALMIA_USB_TIMEOUT 10000\n\n \n\nstatic int\nkalmia_send_init_packet(struct usbnet *dev, u8 *init_msg, u8 init_msg_len,\n\tu8 *buffer, u8 expected_len)\n{\n\tint act_len;\n\tint status;\n\n\tnetdev_dbg(dev->net, \"Sending init packet\");\n\n\tstatus = usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, 0x02),\n\t\tinit_msg, init_msg_len, &act_len, KALMIA_USB_TIMEOUT);\n\tif (status != 0) {\n\t\tnetdev_err(dev->net,\n\t\t\t\"Error sending init packet. Status %i\\n\",\n\t\t\tstatus);\n\t\treturn status;\n\t}\n\telse if (act_len != init_msg_len) {\n\t\tnetdev_err(dev->net,\n\t\t\t\"Did not send all of init packet. Bytes sent: %i\",\n\t\t\tact_len);\n\t}\n\telse {\n\t\tnetdev_dbg(dev->net, \"Successfully sent init packet.\");\n\t}\n\n\tstatus = usb_bulk_msg(dev->udev, usb_rcvbulkpipe(dev->udev, 0x81),\n\t\tbuffer, expected_len, &act_len, KALMIA_USB_TIMEOUT);\n\n\tif (status != 0)\n\t\tnetdev_err(dev->net,\n\t\t\t\"Error receiving init result. Status %i\\n\",\n\t\t\tstatus);\n\telse if (act_len != expected_len)\n\t\tnetdev_err(dev->net, \"Unexpected init result length: %i\\n\",\n\t\t\tact_len);\n\n\treturn status;\n}\n\nstatic int\nkalmia_init_and_get_ethernet_addr(struct usbnet *dev, u8 *ethernet_addr)\n{\n\tstatic const char init_msg_1[] =\n\t\t{ 0x57, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,\n\t\t0x00, 0x00 };\n\tstatic const char init_msg_2[] =\n\t\t{ 0x57, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xf4,\n\t\t0x00, 0x00 };\n\tstatic const int buflen = 28;\n\tchar *usb_buf;\n\tint status;\n\n\tusb_buf = kmalloc(buflen, GFP_DMA | GFP_KERNEL);\n\tif (!usb_buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(usb_buf, init_msg_1, 12);\n\tstatus = kalmia_send_init_packet(dev, usb_buf, ARRAY_SIZE(init_msg_1),\n\t\t\t\t\t usb_buf, 24);\n\tif (status != 0)\n\t\tgoto out;\n\n\tmemcpy(usb_buf, init_msg_2, 12);\n\tstatus = kalmia_send_init_packet(dev, usb_buf, ARRAY_SIZE(init_msg_2),\n\t\t\t\t\t usb_buf, 28);\n\tif (status != 0)\n\t\tgoto out;\n\n\tmemcpy(ethernet_addr, usb_buf + 10, ETH_ALEN);\nout:\n\tkfree(usb_buf);\n\treturn status;\n}\n\nstatic int\nkalmia_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint status;\n\tu8 ethernet_addr[ETH_ALEN];\n\n\t \n\tif (intf->cur_altsetting->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC)\n\t\treturn -EINVAL;\n\n\tdev->in = usb_rcvbulkpipe(dev->udev, 0x81 & USB_ENDPOINT_NUMBER_MASK);\n\tdev->out = usb_sndbulkpipe(dev->udev, 0x02 & USB_ENDPOINT_NUMBER_MASK);\n\tdev->status = NULL;\n\n\tdev->net->hard_header_len += KALMIA_HEADER_LENGTH;\n\tdev->hard_mtu = 1400;\n\tdev->rx_urb_size = dev->hard_mtu * 10; \n\n\tstatus = kalmia_init_and_get_ethernet_addr(dev, ethernet_addr);\n\tif (status)\n\t\treturn status;\n\n\teth_hw_addr_set(dev->net, ethernet_addr);\n\n\treturn status;\n}\n\nstatic struct sk_buff *\nkalmia_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\n{\n\tstruct sk_buff *skb2 = NULL;\n\tu16 content_len;\n\tunsigned char *header_start;\n\tunsigned char ether_type_1, ether_type_2;\n\tu8 remainder, padlen = 0;\n\n\tif (!skb_cloned(skb)) {\n\t\tint headroom = skb_headroom(skb);\n\t\tint tailroom = skb_tailroom(skb);\n\n\t\tif ((tailroom >= KALMIA_ALIGN_SIZE) && (headroom\n\t\t\t>= KALMIA_HEADER_LENGTH))\n\t\t\tgoto done;\n\n\t\tif ((headroom + tailroom) > (KALMIA_HEADER_LENGTH\n\t\t\t+ KALMIA_ALIGN_SIZE)) {\n\t\t\tskb->data = memmove(skb->head + KALMIA_HEADER_LENGTH,\n\t\t\t\tskb->data, skb->len);\n\t\t\tskb_set_tail_pointer(skb, skb->len);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tskb2 = skb_copy_expand(skb, KALMIA_HEADER_LENGTH,\n\t\tKALMIA_ALIGN_SIZE, flags);\n\tif (!skb2)\n\t\treturn NULL;\n\n\tdev_kfree_skb_any(skb);\n\tskb = skb2;\n\ndone:\n\theader_start = skb_push(skb, KALMIA_HEADER_LENGTH);\n\tether_type_1 = header_start[KALMIA_HEADER_LENGTH + 12];\n\tether_type_2 = header_start[KALMIA_HEADER_LENGTH + 13];\n\n\tnetdev_dbg(dev->net, \"Sending etherType: %02x%02x\", ether_type_1,\n\t\tether_type_2);\n\n\t \n\theader_start[0] = 0x57;\n\theader_start[1] = 0x44;\n\tcontent_len = skb->len - KALMIA_HEADER_LENGTH;\n\n\tput_unaligned_le16(content_len, &header_start[2]);\n\theader_start[4] = ether_type_1;\n\theader_start[5] = ether_type_2;\n\n\t \n\tremainder = skb->len % KALMIA_ALIGN_SIZE;\n\tif (remainder > 0) {\n\t\tpadlen = KALMIA_ALIGN_SIZE - remainder;\n\t\tskb_put_zero(skb, padlen);\n\t}\n\n\tnetdev_dbg(dev->net,\n\t\t\"Sending package with length %i and padding %i. Header: %6phC.\",\n\t\tcontent_len, padlen, header_start);\n\n\treturn skb;\n}\n\nstatic int\nkalmia_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\t \n\tstatic const u8 HEADER_END_OF_USB_PACKET[] =\n\t\t{ 0x57, 0x5a, 0x00, 0x00, 0x08, 0x00 };\n\tstatic const u8 EXPECTED_UNKNOWN_HEADER_1[] =\n\t\t{ 0x57, 0x43, 0x1e, 0x00, 0x15, 0x02 };\n\tstatic const u8 EXPECTED_UNKNOWN_HEADER_2[] =\n\t\t{ 0x57, 0x50, 0x0e, 0x00, 0x00, 0x00 };\n\tint i = 0;\n\n\t \n\tif (skb->len < KALMIA_HEADER_LENGTH)\n\t\treturn 0;\n\n\tdo {\n\t\tstruct sk_buff *skb2 = NULL;\n\t\tu8 *header_start;\n\t\tu16 usb_packet_length, ether_packet_length;\n\t\tint is_last;\n\n\t\theader_start = skb->data;\n\n\t\tif (unlikely(header_start[0] != 0x57 || header_start[1] != 0x44)) {\n\t\t\tif (!memcmp(header_start, EXPECTED_UNKNOWN_HEADER_1,\n\t\t\t\tsizeof(EXPECTED_UNKNOWN_HEADER_1)) || !memcmp(\n\t\t\t\theader_start, EXPECTED_UNKNOWN_HEADER_2,\n\t\t\t\tsizeof(EXPECTED_UNKNOWN_HEADER_2))) {\n\t\t\t\tnetdev_dbg(dev->net,\n\t\t\t\t\t\"Received expected unknown frame header: %6phC. Package length: %i\\n\",\n\t\t\t\t\theader_start,\n\t\t\t\t\tskb->len - KALMIA_HEADER_LENGTH);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnetdev_err(dev->net,\n\t\t\t\t\t\"Received unknown frame header: %6phC. Package length: %i\\n\",\n\t\t\t\t\theader_start,\n\t\t\t\t\tskb->len - KALMIA_HEADER_LENGTH);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tnetdev_dbg(dev->net,\n\t\t\t\t\"Received header: %6phC. Package length: %i\\n\",\n\t\t\t\theader_start, skb->len - KALMIA_HEADER_LENGTH);\n\n\t\t \n\t\tusb_packet_length = skb->len - (2 * KALMIA_HEADER_LENGTH);\n\t\tether_packet_length = get_unaligned_le16(&header_start[2]);\n\t\tskb_pull(skb, KALMIA_HEADER_LENGTH);\n\n\t\t \n\t\tif (usb_packet_length < ether_packet_length) {\n\t\t\tether_packet_length = usb_packet_length\n\t\t\t\t+ KALMIA_HEADER_LENGTH;\n\t\t\tis_last = true;\n\t\t}\n\t\telse {\n\t\t\tnetdev_dbg(dev->net, \"Correct package length #%i\", i\n\t\t\t\t+ 1);\n\n\t\t\tis_last = (memcmp(skb->data + ether_packet_length,\n\t\t\t\tHEADER_END_OF_USB_PACKET,\n\t\t\t\tsizeof(HEADER_END_OF_USB_PACKET)) == 0);\n\t\t\tif (!is_last) {\n\t\t\t\theader_start = skb->data + ether_packet_length;\n\t\t\t\tnetdev_dbg(dev->net,\n\t\t\t\t\t\"End header: %6phC. Package length: %i\\n\",\n\t\t\t\t\theader_start,\n\t\t\t\t\tskb->len - KALMIA_HEADER_LENGTH);\n\t\t\t}\n\t\t}\n\n\t\tif (is_last) {\n\t\t\tskb2 = skb;\n\t\t}\n\t\telse {\n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (unlikely(!skb2))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tskb_trim(skb2, ether_packet_length);\n\n\t\tif (is_last) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\tusbnet_skb_return(dev, skb2);\n\t\t\tskb_pull(skb, ether_packet_length);\n\t\t}\n\n\t\ti++;\n\t}\n\twhile (skb->len);\n\n\treturn 1;\n}\n\nstatic const struct driver_info kalmia_info = {\n\t.description = \"Samsung Kalmia LTE USB dongle\",\n\t.flags = FLAG_WWAN,\n\t.bind = kalmia_bind,\n\t.rx_fixup = kalmia_rx_fixup,\n\t.tx_fixup = kalmia_tx_fixup\n};\n\n \n\nstatic const struct usb_device_id products[] = {\n\t \n\t{ USB_DEVICE(0x04e8, 0x689a) },\n\t \n\t{ USB_DEVICE(0x04e8, 0x6889),\n\t\t.driver_info = (unsigned long) &kalmia_info, },\n\t{  } };\nMODULE_DEVICE_TABLE( usb, products);\n\nstatic struct usb_driver kalmia_driver = {\n\t.name = \"kalmia\",\n\t.id_table = products,\n\t.probe = usbnet_probe,\n\t.disconnect = usbnet_disconnect,\n\t.suspend = usbnet_suspend,\n\t.resume = usbnet_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(kalmia_driver);\n\nMODULE_AUTHOR(\"Marius Bjoernstad Kotsbak <marius@kotsbak.com>\");\nMODULE_DESCRIPTION(\"Samsung Kalmia USB network driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}