{
  "module_name": "gl620a.c",
  "hash_id": "8b51ccbd1247d025f6f749c553a334282b0186749cd83c06acf0f62a91209db1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/gl620a.c",
  "human_readable_source": "\n \n\n\n\n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/usbnet.h>\n#include <linux/gfp.h>\n\n\n \n\n\n#define GENELINK_CONNECT_WRITE\t\t\t0xF0\n\n#define GENELINK_INTERRUPT_PIPE\t\t\t0x03\n\n#define INTERRUPT_BUFSIZE\t\t\t0x08\n\n#define GENELINK_INTERRUPT_INTERVAL\t\t0x10\n\n#define GL_MAX_TRANSMIT_PACKETS\t\t\t32\n\n#define GL_MAX_PACKET_LEN\t\t\t1514\n\n#define GL_RCV_BUF_SIZE\t\t\\\n\t(((GL_MAX_PACKET_LEN + 4) * GL_MAX_TRANSMIT_PACKETS) + 4)\n\nstruct gl_packet {\n\t__le32\t\tpacket_length;\n\tchar\t\tpacket_data[];\n};\n\nstruct gl_header {\n\t__le32\t\t\tpacket_count;\n\tstruct gl_packet\tpackets;\n};\n\nstatic int genelink_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct gl_header\t*header;\n\tstruct gl_packet\t*packet;\n\tstruct sk_buff\t\t*gl_skb;\n\tu32\t\t\tsize;\n\tu32\t\t\tcount;\n\n\t \n\tif (skb->len < dev->net->hard_header_len)\n\t\treturn 0;\n\n\theader = (struct gl_header *) skb->data;\n\n\t\n\tcount = le32_to_cpu(header->packet_count);\n\tif (count > GL_MAX_TRANSMIT_PACKETS) {\n\t\tnetdev_dbg(dev->net,\n\t\t\t   \"genelink: invalid received packet count %u\\n\",\n\t\t\t   count);\n\t\treturn 0;\n\t}\n\n\t\n\tpacket = &header->packets;\n\n\t\n\tskb_pull(skb, 4);\n\n\twhile (count > 1) {\n\t\t\n\t\tsize = le32_to_cpu(packet->packet_length);\n\n\t\t\n\t\tif (size > GL_MAX_PACKET_LEN) {\n\t\t\tnetdev_dbg(dev->net, \"genelink: invalid rx length %d\\n\",\n\t\t\t\t   size);\n\t\t\treturn 0;\n\t\t}\n\n\t\t\n\t\tgl_skb = alloc_skb(size, GFP_ATOMIC);\n\t\tif (gl_skb) {\n\n\t\t\t\n\t\t\tskb_put_data(gl_skb, packet->packet_data, size);\n\t\t\tusbnet_skb_return(dev, gl_skb);\n\t\t}\n\n\t\t\n\t\tpacket = (struct gl_packet *)&packet->packet_data[size];\n\t\tcount--;\n\n\t\t\n\t\tskb_pull(skb, size + 4);\n\t}\n\n\t\n\tskb_pull(skb, 4);\n\n\tif (skb->len > GL_MAX_PACKET_LEN) {\n\t\tnetdev_dbg(dev->net, \"genelink: invalid rx length %d\\n\",\n\t\t\t   skb->len);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic struct sk_buff *\ngenelink_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\n{\n\tint \tpadlen;\n\tint\tlength = skb->len;\n\tint\theadroom = skb_headroom(skb);\n\tint\ttailroom = skb_tailroom(skb);\n\t__le32\t*packet_count;\n\t__le32\t*packet_len;\n\n\t\n\tpadlen = ((skb->len + (4 + 4*1)) % 64) ? 0 : 1;\n\n\tif ((!skb_cloned(skb))\n\t\t\t&& ((headroom + tailroom) >= (padlen + (4 + 4*1)))) {\n\t\tif ((headroom < (4 + 4*1)) || (tailroom < padlen)) {\n\t\t\tskb->data = memmove(skb->head + (4 + 4*1),\n\t\t\t\t\t     skb->data, skb->len);\n\t\t\tskb_set_tail_pointer(skb, skb->len);\n\t\t}\n\t} else {\n\t\tstruct sk_buff\t*skb2;\n\t\tskb2 = skb_copy_expand(skb, (4 + 4*1) , padlen, flags);\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = skb2;\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t}\n\n\t\n\tpacket_count = skb_push(skb, (4 + 4 * 1));\n\tpacket_len = packet_count + 1;\n\n\t*packet_count = cpu_to_le32(1);\n\t*packet_len = cpu_to_le32(length);\n\n\t\n\tif ((skb->len % dev->maxpacket) == 0)\n\t\tskb_put(skb, 1);\n\n\treturn skb;\n}\n\nstatic int genelink_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tdev->hard_mtu = GL_RCV_BUF_SIZE;\n\tdev->net->hard_header_len += 4;\n\tdev->in = usb_rcvbulkpipe(dev->udev, dev->driver_info->in);\n\tdev->out = usb_sndbulkpipe(dev->udev, dev->driver_info->out);\n\treturn 0;\n}\n\nstatic const struct driver_info\tgenelink_info = {\n\t.description =\t\"Genesys GeneLink\",\n\t.flags =\tFLAG_POINTTOPOINT | FLAG_FRAMING_GL | FLAG_NO_SETINT,\n\t.bind =\t\tgenelink_bind,\n\t.rx_fixup =\tgenelink_rx_fixup,\n\t.tx_fixup =\tgenelink_tx_fixup,\n\n\t.in = 1, .out = 2,\n\n#ifdef\tGENELINK_ACK\n\t.check_connect =genelink_check_connect,\n#endif\n};\n\nstatic const struct usb_device_id\tproducts [] = {\n\n{\n\tUSB_DEVICE(0x05e3, 0x0502),\t\n\t.driver_info =\t(unsigned long) &genelink_info,\n},\n\t \n\t{ },\t\t\n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver gl620a_driver = {\n\t.name =\t\t\"gl620a\",\n\t.id_table =\tproducts,\n\t.probe =\tusbnet_probe,\n\t.disconnect =\tusbnet_disconnect,\n\t.suspend =\tusbnet_suspend,\n\t.resume =\tusbnet_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(gl620a_driver);\n\nMODULE_AUTHOR(\"Jiun-Jie Huang\");\nMODULE_DESCRIPTION(\"GL620-USB-A Host-to-Host Link cables\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}