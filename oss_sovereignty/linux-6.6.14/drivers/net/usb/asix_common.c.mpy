{
  "module_name": "asix_common.c",
  "hash_id": "96130efdf4501283ac1d782fe5db1981a8c1052cb94809ae803fb5e4ec39fb82",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/asix_common.c",
  "human_readable_source": "\n \n\n#include \"asix.h\"\n\n#define AX_HOST_EN_RETRIES\t30\n\nint __must_check asix_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\n\t\t\t       u16 size, void *data, int in_pm)\n{\n\tint ret;\n\tint (*fn)(struct usbnet *, u8, u8, u16, u16, void *, u16);\n\n\tBUG_ON(!dev);\n\n\tif (!in_pm)\n\t\tfn = usbnet_read_cmd;\n\telse\n\t\tfn = usbnet_read_cmd_nopm;\n\n\tret = fn(dev, cmd, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t value, index, data, size);\n\n\tif (unlikely(ret < size)) {\n\t\tret = ret < 0 ? ret : -ENODATA;\n\n\t\tnetdev_warn(dev->net, \"Failed to read reg index 0x%04x: %d\\n\",\n\t\t\t    index, ret);\n\t}\n\n\treturn ret;\n}\n\nint asix_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,\n\t\t   u16 size, void *data, int in_pm)\n{\n\tint ret;\n\tint (*fn)(struct usbnet *, u8, u8, u16, u16, const void *, u16);\n\n\tBUG_ON(!dev);\n\n\tif (!in_pm)\n\t\tfn = usbnet_write_cmd;\n\telse\n\t\tfn = usbnet_write_cmd_nopm;\n\n\tret = fn(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t value, index, data, size);\n\n\tif (unlikely(ret < 0))\n\t\tnetdev_warn(dev->net, \"Failed to write reg index 0x%04x: %d\\n\",\n\t\t\t    index, ret);\n\n\treturn ret;\n}\n\nvoid asix_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value, u16 index,\n\t\t\t  u16 size, void *data)\n{\n\tusbnet_write_cmd_async(dev, cmd,\n\t\t\t       USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t       value, index, data, size);\n}\n\nstatic int asix_set_sw_mii(struct usbnet *dev, int in_pm)\n{\n\tint ret;\n\n\tret = asix_write_cmd(dev, AX_CMD_SET_SW_MII, 0x0000, 0, 0, NULL, in_pm);\n\n\tif (ret < 0)\n\t\tnetdev_err(dev->net, \"Failed to enable software MII access\\n\");\n\treturn ret;\n}\n\nstatic int asix_set_hw_mii(struct usbnet *dev, int in_pm)\n{\n\tint ret;\n\n\tret = asix_write_cmd(dev, AX_CMD_SET_HW_MII, 0x0000, 0, 0, NULL, in_pm);\n\tif (ret < 0)\n\t\tnetdev_err(dev->net, \"Failed to enable hardware MII access\\n\");\n\treturn ret;\n}\n\nstatic int asix_check_host_enable(struct usbnet *dev, int in_pm)\n{\n\tint i, ret;\n\tu8 smsr;\n\n\tfor (i = 0; i < AX_HOST_EN_RETRIES; ++i) {\n\t\tret = asix_set_sw_mii(dev, in_pm);\n\t\tif (ret == -ENODEV || ret == -ETIMEDOUT)\n\t\t\tbreak;\n\t\tusleep_range(1000, 1100);\n\t\tret = asix_read_cmd(dev, AX_CMD_STATMNGSTS_REG,\n\t\t\t\t    0, 0, 1, &smsr, in_pm);\n\t\tif (ret == -ENODEV)\n\t\t\tbreak;\n\t\telse if (ret < 0)\n\t\t\tcontinue;\n\t\telse if (smsr & AX_HOST_EN)\n\t\t\tbreak;\n\t}\n\n\treturn i >= AX_HOST_EN_RETRIES ? -ETIMEDOUT : ret;\n}\n\nstatic void reset_asix_rx_fixup_info(struct asix_rx_fixup_info *rx)\n{\n\t \n\n\tif (rx->ax_skb) {\n\t\t \n\t\tkfree_skb(rx->ax_skb);\n\t\trx->ax_skb = NULL;\n\t}\n\n\t \n\trx->remaining = 0;\n\trx->split_head = false;\n\trx->header = 0;\n}\n\nint asix_rx_fixup_internal(struct usbnet *dev, struct sk_buff *skb,\n\t\t\t   struct asix_rx_fixup_info *rx)\n{\n\tint offset = 0;\n\tu16 size;\n\n\t \n\tif (rx->remaining && (rx->remaining + sizeof(u32) <= skb->len)) {\n\t\toffset = ((rx->remaining + 1) & 0xfffe);\n\t\trx->header = get_unaligned_le32(skb->data + offset);\n\t\toffset = 0;\n\n\t\tsize = (u16)(rx->header & 0x7ff);\n\t\tif (size != ((~rx->header >> 16) & 0x7ff)) {\n\t\t\tnetdev_err(dev->net, \"asix_rx_fixup() Data Header synchronisation was lost, remaining %d\\n\",\n\t\t\t\t   rx->remaining);\n\t\t\treset_asix_rx_fixup_info(rx);\n\t\t}\n\t}\n\n\twhile (offset + sizeof(u16) <= skb->len) {\n\t\tu16 copy_length;\n\n\t\tif (!rx->remaining) {\n\t\t\tif (skb->len - offset == sizeof(u16)) {\n\t\t\t\trx->header = get_unaligned_le16(\n\t\t\t\t\t\tskb->data + offset);\n\t\t\t\trx->split_head = true;\n\t\t\t\toffset += sizeof(u16);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (rx->split_head == true) {\n\t\t\t\trx->header |= (get_unaligned_le16(\n\t\t\t\t\t\tskb->data + offset) << 16);\n\t\t\t\trx->split_head = false;\n\t\t\t\toffset += sizeof(u16);\n\t\t\t} else {\n\t\t\t\trx->header = get_unaligned_le32(skb->data +\n\t\t\t\t\t\t\t\toffset);\n\t\t\t\toffset += sizeof(u32);\n\t\t\t}\n\n\t\t\t \n\t\t\tsize = (u16)(rx->header & 0x7ff);\n\t\t\tif (size != ((~rx->header >> 16) & 0x7ff)) {\n\t\t\t\tnetdev_err(dev->net, \"asix_rx_fixup() Bad Header Length 0x%x, offset %d\\n\",\n\t\t\t\t\t   rx->header, offset);\n\t\t\t\treset_asix_rx_fixup_info(rx);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (size > dev->net->mtu + ETH_HLEN + VLAN_HLEN) {\n\t\t\t\tnetdev_dbg(dev->net, \"asix_rx_fixup() Bad RX Length %d\\n\",\n\t\t\t\t\t   size);\n\t\t\t\treset_asix_rx_fixup_info(rx);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t \n\t\t\trx->ax_skb = netdev_alloc_skb_ip_align(dev->net, size);\n\n\t\t\trx->remaining = size;\n\t\t}\n\n\t\tif (rx->remaining > skb->len - offset) {\n\t\t\tcopy_length = skb->len - offset;\n\t\t\trx->remaining -= copy_length;\n\t\t} else {\n\t\t\tcopy_length = rx->remaining;\n\t\t\trx->remaining = 0;\n\t\t}\n\n\t\tif (rx->ax_skb) {\n\t\t\tskb_put_data(rx->ax_skb, skb->data + offset,\n\t\t\t\t     copy_length);\n\t\t\tif (!rx->remaining) {\n\t\t\t\tusbnet_skb_return(dev, rx->ax_skb);\n\t\t\t\trx->ax_skb = NULL;\n\t\t\t}\n\t\t}\n\n\t\toffset += (copy_length + 1) & 0xfffe;\n\t}\n\n\tif (skb->len != offset) {\n\t\tnetdev_err(dev->net, \"asix_rx_fixup() Bad SKB Length %d, %d\\n\",\n\t\t\t   skb->len, offset);\n\t\treset_asix_rx_fixup_info(rx);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint asix_rx_fixup_common(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct asix_common_private *dp = dev->driver_priv;\n\tstruct asix_rx_fixup_info *rx = &dp->rx_fixup_info;\n\n\treturn asix_rx_fixup_internal(dev, skb, rx);\n}\n\nvoid asix_rx_fixup_common_free(struct asix_common_private *dp)\n{\n\tstruct asix_rx_fixup_info *rx;\n\n\tif (!dp)\n\t\treturn;\n\n\trx = &dp->rx_fixup_info;\n\n\tif (rx->ax_skb) {\n\t\tkfree_skb(rx->ax_skb);\n\t\trx->ax_skb = NULL;\n\t}\n}\n\nstruct sk_buff *asix_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\n\t\t\t      gfp_t flags)\n{\n\tint padlen;\n\tint headroom = skb_headroom(skb);\n\tint tailroom = skb_tailroom(skb);\n\tu32 packet_len;\n\tu32 padbytes = 0xffff0000;\n\tvoid *ptr;\n\n\tpadlen = ((skb->len + 4) & (dev->maxpacket - 1)) ? 0 : 4;\n\n\t \n\tif (!skb_header_cloned(skb) &&\n\t    !(padlen && skb_cloned(skb)) &&\n\t    headroom + tailroom >= 4 + padlen) {\n\t\t \n\t\tif (headroom < 4 ||\n\t\t    tailroom < padlen) {\n\t\t\tskb->data = memmove(skb->head + 4, skb->data, skb->len);\n\t\t\tskb_set_tail_pointer(skb, skb->len);\n\t\t}\n\t} else {\n\t\tstruct sk_buff *skb2;\n\n\t\tskb2 = skb_copy_expand(skb, 4, padlen, flags);\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = skb2;\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t}\n\n\tpacket_len = ((skb->len ^ 0x0000ffff) << 16) + skb->len;\n\tptr = skb_push(skb, 4);\n\tput_unaligned_le32(packet_len, ptr);\n\n\tif (padlen) {\n\t\tput_unaligned_le32(padbytes, skb_tail_pointer(skb));\n\t\tskb_put(skb, sizeof(padbytes));\n\t}\n\n\tusbnet_set_skb_tx_stats(skb, 1, 0);\n\treturn skb;\n}\n\nint asix_read_phy_addr(struct usbnet *dev, bool internal)\n{\n\tint ret, offset;\n\tu8 buf[2];\n\n\tret = asix_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf, 0);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (ret < 2) {\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\n\toffset = (internal ? 1 : 0);\n\tret = buf[offset];\n\n\tnetdev_dbg(dev->net, \"%s PHY address 0x%x\\n\",\n\t\t   internal ? \"internal\" : \"external\", ret);\n\n\treturn ret;\n\nerror:\n\tnetdev_err(dev->net, \"Error reading PHY_ID register: %02x\\n\", ret);\n\n\treturn ret;\n}\n\nint asix_sw_reset(struct usbnet *dev, u8 flags, int in_pm)\n{\n\tint ret;\n\n\tret = asix_write_cmd(dev, AX_CMD_SW_RESET, flags, 0, 0, NULL, in_pm);\n\tif (ret < 0)\n\t\tnetdev_err(dev->net, \"Failed to send software reset: %02x\\n\", ret);\n\n\treturn ret;\n}\n\nu16 asix_read_rx_ctl(struct usbnet *dev, int in_pm)\n{\n\t__le16 v;\n\tint ret = asix_read_cmd(dev, AX_CMD_READ_RX_CTL, 0, 0, 2, &v, in_pm);\n\n\tif (ret < 0) {\n\t\tnetdev_err(dev->net, \"Error reading RX_CTL register: %02x\\n\", ret);\n\t\tgoto out;\n\t}\n\tret = le16_to_cpu(v);\nout:\n\treturn ret;\n}\n\nint asix_write_rx_ctl(struct usbnet *dev, u16 mode, int in_pm)\n{\n\tint ret;\n\n\tnetdev_dbg(dev->net, \"asix_write_rx_ctl() - mode = 0x%04x\\n\", mode);\n\tret = asix_write_cmd(dev, AX_CMD_WRITE_RX_CTL, mode, 0, 0, NULL, in_pm);\n\tif (ret < 0)\n\t\tnetdev_err(dev->net, \"Failed to write RX_CTL mode to 0x%04x: %02x\\n\",\n\t\t\t   mode, ret);\n\n\treturn ret;\n}\n\nu16 asix_read_medium_status(struct usbnet *dev, int in_pm)\n{\n\t__le16 v;\n\tint ret = asix_read_cmd(dev, AX_CMD_READ_MEDIUM_STATUS,\n\t\t\t\t0, 0, 2, &v, in_pm);\n\n\tif (ret < 0) {\n\t\tnetdev_err(dev->net, \"Error reading Medium Status register: %02x\\n\",\n\t\t\t   ret);\n\t\treturn ret;\t \n\t}\n\n\treturn le16_to_cpu(v);\n\n}\n\nint asix_write_medium_mode(struct usbnet *dev, u16 mode, int in_pm)\n{\n\tint ret;\n\n\tnetdev_dbg(dev->net, \"asix_write_medium_mode() - mode = 0x%04x\\n\", mode);\n\tret = asix_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,\n\t\t\t     mode, 0, 0, NULL, in_pm);\n\tif (ret < 0)\n\t\tnetdev_err(dev->net, \"Failed to write Medium Mode mode to 0x%04x: %02x\\n\",\n\t\t\t   mode, ret);\n\n\treturn ret;\n}\n\n \nvoid asix_adjust_link(struct net_device *netdev)\n{\n\tstruct phy_device *phydev = netdev->phydev;\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tu16 mode = 0;\n\n\tif (phydev->link) {\n\t\tmode = AX88772_MEDIUM_DEFAULT;\n\n\t\tif (phydev->duplex == DUPLEX_HALF)\n\t\t\tmode &= ~AX_MEDIUM_FD;\n\n\t\tif (phydev->speed != SPEED_100)\n\t\t\tmode &= ~AX_MEDIUM_PS;\n\t}\n\n\tasix_write_medium_mode(dev, mode, 0);\n\tphy_print_status(phydev);\n\tusbnet_link_change(dev, phydev->link, 0);\n}\n\nint asix_write_gpio(struct usbnet *dev, u16 value, int sleep, int in_pm)\n{\n\tint ret;\n\n\tnetdev_dbg(dev->net, \"asix_write_gpio() - value = 0x%04x\\n\", value);\n\tret = asix_write_cmd(dev, AX_CMD_WRITE_GPIOS, value, 0, 0, NULL, in_pm);\n\tif (ret < 0)\n\t\tnetdev_err(dev->net, \"Failed to write GPIO value 0x%04x: %02x\\n\",\n\t\t\t   value, ret);\n\n\tif (sleep)\n\t\tmsleep(sleep);\n\n\treturn ret;\n}\n\n \nvoid asix_set_multicast(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct asix_data *data = (struct asix_data *)&dev->data;\n\tu16 rx_ctl = AX_DEFAULT_RX_CTL;\n\n\tif (net->flags & IFF_PROMISC) {\n\t\trx_ctl |= AX_RX_CTL_PRO;\n\t} else if (net->flags & IFF_ALLMULTI ||\n\t\t   netdev_mc_count(net) > AX_MAX_MCAST) {\n\t\trx_ctl |= AX_RX_CTL_AMALL;\n\t} else if (netdev_mc_empty(net)) {\n\t\t \n\t} else {\n\t\t \n\t\tstruct netdev_hw_addr *ha;\n\t\tu32 crc_bits;\n\n\t\tmemset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);\n\n\t\t \n\t\tnetdev_for_each_mc_addr(ha, net) {\n\t\t\tcrc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\t\t\tdata->multi_filter[crc_bits >> 3] |=\n\t\t\t    1 << (crc_bits & 7);\n\t\t}\n\n\t\tasix_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,\n\t\t\t\t   AX_MCAST_FILTER_SIZE, data->multi_filter);\n\n\t\trx_ctl |= AX_RX_CTL_AM;\n\t}\n\n\tasix_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);\n}\n\nstatic int __asix_mdio_read(struct net_device *netdev, int phy_id, int loc,\n\t\t\t    bool in_pm)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\t__le16 res;\n\tint ret;\n\n\tmutex_lock(&dev->phy_mutex);\n\n\tret = asix_check_host_enable(dev, in_pm);\n\tif (ret == -ENODEV || ret == -ETIMEDOUT) {\n\t\tmutex_unlock(&dev->phy_mutex);\n\t\treturn ret;\n\t}\n\n\tret = asix_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id, (__u16)loc, 2,\n\t\t\t    &res, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = asix_set_hw_mii(dev, in_pm);\nout:\n\tmutex_unlock(&dev->phy_mutex);\n\n\tnetdev_dbg(dev->net, \"asix_mdio_read() phy_id=0x%02x, loc=0x%02x, returns=0x%04x\\n\",\n\t\t\tphy_id, loc, le16_to_cpu(res));\n\n\treturn ret < 0 ? ret : le16_to_cpu(res);\n}\n\nint asix_mdio_read(struct net_device *netdev, int phy_id, int loc)\n{\n\treturn __asix_mdio_read(netdev, phy_id, loc, false);\n}\n\nstatic int __asix_mdio_write(struct net_device *netdev, int phy_id, int loc,\n\t\t\t     int val, bool in_pm)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\t__le16 res = cpu_to_le16(val);\n\tint ret;\n\n\tnetdev_dbg(dev->net, \"asix_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\\n\",\n\t\t\tphy_id, loc, val);\n\n\tmutex_lock(&dev->phy_mutex);\n\n\tret = asix_check_host_enable(dev, in_pm);\n\tif (ret == -ENODEV)\n\t\tgoto out;\n\n\tret = asix_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id, (__u16)loc, 2,\n\t\t\t     &res, in_pm);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = asix_set_hw_mii(dev, in_pm);\nout:\n\tmutex_unlock(&dev->phy_mutex);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nvoid asix_mdio_write(struct net_device *netdev, int phy_id, int loc, int val)\n{\n\t__asix_mdio_write(netdev, phy_id, loc, val, false);\n}\n\n \nint asix_mdio_bus_read(struct mii_bus *bus, int phy_id, int regnum)\n{\n\tstruct usbnet *priv = bus->priv;\n\n\treturn __asix_mdio_read(priv->net, phy_id, regnum, false);\n}\n\nint asix_mdio_bus_write(struct mii_bus *bus, int phy_id, int regnum, u16 val)\n{\n\tstruct usbnet *priv = bus->priv;\n\n\treturn __asix_mdio_write(priv->net, phy_id, regnum, val, false);\n}\n\nint asix_mdio_read_nopm(struct net_device *netdev, int phy_id, int loc)\n{\n\treturn __asix_mdio_read(netdev, phy_id, loc, true);\n}\n\nvoid\nasix_mdio_write_nopm(struct net_device *netdev, int phy_id, int loc, int val)\n{\n\t__asix_mdio_write(netdev, phy_id, loc, val, true);\n}\n\nvoid asix_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tu8 opt;\n\n\tif (asix_read_cmd(dev, AX_CMD_READ_MONITOR_MODE,\n\t\t\t  0, 0, 1, &opt, 0) < 0) {\n\t\twolinfo->supported = 0;\n\t\twolinfo->wolopts = 0;\n\t\treturn;\n\t}\n\twolinfo->supported = WAKE_PHY | WAKE_MAGIC;\n\twolinfo->wolopts = 0;\n\tif (opt & AX_MONITOR_LINK)\n\t\twolinfo->wolopts |= WAKE_PHY;\n\tif (opt & AX_MONITOR_MAGIC)\n\t\twolinfo->wolopts |= WAKE_MAGIC;\n}\n\nint asix_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tu8 opt = 0;\n\n\tif (wolinfo->wolopts & ~(WAKE_PHY | WAKE_MAGIC))\n\t\treturn -EINVAL;\n\n\tif (wolinfo->wolopts & WAKE_PHY)\n\t\topt |= AX_MONITOR_LINK;\n\tif (wolinfo->wolopts & WAKE_MAGIC)\n\t\topt |= AX_MONITOR_MAGIC;\n\n\tif (asix_write_cmd(dev, AX_CMD_WRITE_MONITOR_MODE,\n\t\t\t      opt, 0, 0, NULL, 0) < 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint asix_get_eeprom_len(struct net_device *net)\n{\n\treturn AX_EEPROM_LEN;\n}\n\nint asix_get_eeprom(struct net_device *net, struct ethtool_eeprom *eeprom,\n\t\t    u8 *data)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tu16 *eeprom_buff;\n\tint first_word, last_word;\n\tint i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\teeprom->magic = AX_EEPROM_MAGIC;\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\n\teeprom_buff = kmalloc_array(last_word - first_word + 1, sizeof(u16),\n\t\t\t\t    GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = first_word; i <= last_word; i++) {\n\t\tif (asix_read_cmd(dev, AX_CMD_READ_EEPROM, i, 0, 2,\n\t\t\t\t  &eeprom_buff[i - first_word], 0) < 0) {\n\t\t\tkfree(eeprom_buff);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tmemcpy(data, (u8 *)eeprom_buff + (eeprom->offset & 1), eeprom->len);\n\tkfree(eeprom_buff);\n\treturn 0;\n}\n\nint asix_set_eeprom(struct net_device *net, struct ethtool_eeprom *eeprom,\n\t\t    u8 *data)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tu16 *eeprom_buff;\n\tint first_word, last_word;\n\tint i;\n\tint ret;\n\n\tnetdev_dbg(net, \"write EEPROM len %d, offset %d, magic 0x%x\\n\",\n\t\t   eeprom->len, eeprom->offset, eeprom->magic);\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\tif (eeprom->magic != AX_EEPROM_MAGIC)\n\t\treturn -EINVAL;\n\n\tfirst_word = eeprom->offset >> 1;\n\tlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\n\n\teeprom_buff = kmalloc_array(last_word - first_word + 1, sizeof(u16),\n\t\t\t\t    GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\t \n\tif (eeprom->offset & 1) {\n\t\tret = asix_read_cmd(dev, AX_CMD_READ_EEPROM, first_word, 0, 2,\n\t\t\t\t    &eeprom_buff[0], 0);\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(net, \"Failed to read EEPROM at offset 0x%02x.\\n\", first_word);\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif ((eeprom->offset + eeprom->len) & 1) {\n\t\tret = asix_read_cmd(dev, AX_CMD_READ_EEPROM, last_word, 0, 2,\n\t\t\t\t    &eeprom_buff[last_word - first_word], 0);\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(net, \"Failed to read EEPROM at offset 0x%02x.\\n\", last_word);\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tmemcpy((u8 *)eeprom_buff + (eeprom->offset & 1), data, eeprom->len);\n\n\t \n\tret = asix_write_cmd(dev, AX_CMD_WRITE_ENABLE, 0x0000, 0, 0, NULL, 0);\n\tif (ret < 0) {\n\t\tnetdev_err(net, \"Failed to enable EEPROM write\\n\");\n\t\tgoto free;\n\t}\n\tmsleep(20);\n\n\tfor (i = first_word; i <= last_word; i++) {\n\t\tnetdev_dbg(net, \"write to EEPROM at offset 0x%02x, data 0x%04x\\n\",\n\t\t\t   i, eeprom_buff[i - first_word]);\n\t\tret = asix_write_cmd(dev, AX_CMD_WRITE_EEPROM, i,\n\t\t\t\t     eeprom_buff[i - first_word], 0, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(net, \"Failed to write EEPROM at offset 0x%02x.\\n\",\n\t\t\t\t   i);\n\t\t\tgoto free;\n\t\t}\n\t\tmsleep(20);\n\t}\n\n\tret = asix_write_cmd(dev, AX_CMD_WRITE_DISABLE, 0x0000, 0, 0, NULL, 0);\n\tif (ret < 0) {\n\t\tnetdev_err(net, \"Failed to disable EEPROM write\\n\");\n\t\tgoto free;\n\t}\n\n\tret = 0;\nfree:\n\tkfree(eeprom_buff);\n\treturn ret;\n}\n\nvoid asix_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)\n{\n\t \n\tusbnet_get_drvinfo(net, info);\n\tstrscpy(info->driver, DRIVER_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRIVER_VERSION, sizeof(info->version));\n}\n\nint asix_set_mac_address(struct net_device *net, void *p)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct asix_data *data = (struct asix_data *)&dev->data;\n\tstruct sockaddr *addr = p;\n\n\tif (netif_running(net))\n\t\treturn -EBUSY;\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(net, addr->sa_data);\n\n\t \n\tmemcpy(data->mac_addr, addr->sa_data, ETH_ALEN);\n\tasix_write_cmd_async(dev, AX_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,\n\t\t\t\t\t\t\tdata->mac_addr);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}