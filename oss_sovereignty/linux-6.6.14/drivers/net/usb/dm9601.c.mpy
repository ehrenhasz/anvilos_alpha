{
  "module_name": "dm9601.c",
  "hash_id": "df09db72660dea358f9c1d72e83cc8a3114e00143987b02076646e79597d03be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/dm9601.c",
  "human_readable_source": " \n\n\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/stddef.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/crc32.h>\n#include <linux/usb/usbnet.h>\n#include <linux/slab.h>\n\n \n\n \n#define DM_READ_REGS\t0x00\n#define DM_WRITE_REGS\t0x01\n#define DM_READ_MEMS\t0x02\n#define DM_WRITE_REG\t0x03\n#define DM_WRITE_MEMS\t0x05\n#define DM_WRITE_MEM\t0x07\n\n \n#define DM_NET_CTRL\t0x00\n#define DM_RX_CTRL\t0x05\n#define DM_SHARED_CTRL\t0x0b\n#define DM_SHARED_ADDR\t0x0c\n#define DM_SHARED_DATA\t0x0d\t \n#define DM_PHY_ADDR\t0x10\t \n#define DM_MCAST_ADDR\t0x16\t \n#define DM_GPR_CTRL\t0x1e\n#define DM_GPR_DATA\t0x1f\n#define DM_CHIP_ID\t0x2c\n#define DM_MODE_CTRL\t0x91\t \n\n \n#define ID_DM9601\t0\n#define ID_DM9620\t1\n\n#define DM_MAX_MCAST\t64\n#define DM_MCAST_SIZE\t8\n#define DM_EEPROM_LEN\t256\n#define DM_TX_OVERHEAD\t2\t \n#define DM_RX_OVERHEAD\t7\t \n#define DM_TIMEOUT\t1000\n\nstatic int dm_read(struct usbnet *dev, u8 reg, u16 length, void *data)\n{\n\tint err;\n\terr = usbnet_read_cmd(dev, DM_READ_REGS,\n\t\t\t       USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t       0, reg, data, length);\n\tif(err != length && err >= 0)\n\t\terr = -EINVAL;\n\treturn err;\n}\n\nstatic int dm_read_reg(struct usbnet *dev, u8 reg, u8 *value)\n{\n\treturn dm_read(dev, reg, 1, value);\n}\n\nstatic int dm_write(struct usbnet *dev, u8 reg, u16 length, void *data)\n{\n\tint err;\n\terr = usbnet_write_cmd(dev, DM_WRITE_REGS,\n\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t0, reg, data, length);\n\n\tif (err >= 0 && err < length)\n\t\terr = -EINVAL;\n\treturn err;\n}\n\nstatic int dm_write_reg(struct usbnet *dev, u8 reg, u8 value)\n{\n\treturn usbnet_write_cmd(dev, DM_WRITE_REG,\n\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\tvalue, reg, NULL, 0);\n}\n\nstatic void dm_write_async(struct usbnet *dev, u8 reg, u16 length,\n\t\t\t   const void *data)\n{\n\tusbnet_write_cmd_async(dev, DM_WRITE_REGS,\n\t\t\t       USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t       0, reg, data, length);\n}\n\nstatic void dm_write_reg_async(struct usbnet *dev, u8 reg, u8 value)\n{\n\tusbnet_write_cmd_async(dev, DM_WRITE_REG,\n\t\t\t       USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t       value, reg, NULL, 0);\n}\n\nstatic int dm_read_shared_word(struct usbnet *dev, int phy, u8 reg, __le16 *value)\n{\n\tint ret, i;\n\n\tmutex_lock(&dev->phy_mutex);\n\n\tdm_write_reg(dev, DM_SHARED_ADDR, phy ? (reg | 0x40) : reg);\n\tdm_write_reg(dev, DM_SHARED_CTRL, phy ? 0xc : 0x4);\n\n\tfor (i = 0; i < DM_TIMEOUT; i++) {\n\t\tu8 tmp = 0;\n\n\t\tudelay(1);\n\t\tret = dm_read_reg(dev, DM_SHARED_CTRL, &tmp);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tif ((tmp & 1) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (i == DM_TIMEOUT) {\n\t\tnetdev_err(dev->net, \"%s read timed out!\\n\", phy ? \"phy\" : \"eeprom\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tdm_write_reg(dev, DM_SHARED_CTRL, 0x0);\n\tret = dm_read(dev, DM_SHARED_DATA, 2, value);\n\n\tnetdev_dbg(dev->net, \"read shared %d 0x%02x returned 0x%04x, %d\\n\",\n\t\t   phy, reg, *value, ret);\n\n out:\n\tmutex_unlock(&dev->phy_mutex);\n\treturn ret;\n}\n\nstatic int dm_write_shared_word(struct usbnet *dev, int phy, u8 reg, __le16 value)\n{\n\tint ret, i;\n\n\tmutex_lock(&dev->phy_mutex);\n\n\tret = dm_write(dev, DM_SHARED_DATA, 2, &value);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdm_write_reg(dev, DM_SHARED_ADDR, phy ? (reg | 0x40) : reg);\n\tdm_write_reg(dev, DM_SHARED_CTRL, phy ? 0x1a : 0x12);\n\n\tfor (i = 0; i < DM_TIMEOUT; i++) {\n\t\tu8 tmp = 0;\n\n\t\tudelay(1);\n\t\tret = dm_read_reg(dev, DM_SHARED_CTRL, &tmp);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tif ((tmp & 1) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (i == DM_TIMEOUT) {\n\t\tnetdev_err(dev->net, \"%s write timed out!\\n\", phy ? \"phy\" : \"eeprom\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tdm_write_reg(dev, DM_SHARED_CTRL, 0x0);\n\nout:\n\tmutex_unlock(&dev->phy_mutex);\n\treturn ret;\n}\n\nstatic int dm_read_eeprom_word(struct usbnet *dev, u8 offset, void *value)\n{\n\treturn dm_read_shared_word(dev, 0, offset, value);\n}\n\n\n\nstatic int dm9601_get_eeprom_len(struct net_device *dev)\n{\n\treturn DM_EEPROM_LEN;\n}\n\nstatic int dm9601_get_eeprom(struct net_device *net,\n\t\t\t     struct ethtool_eeprom *eeprom, u8 * data)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\t__le16 *ebuf = (__le16 *) data;\n\tint i;\n\n\t \n\tif ((eeprom->offset % 2) || (eeprom->len % 2))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < eeprom->len / 2; i++) {\n\t\tif (dm_read_eeprom_word(dev, eeprom->offset / 2 + i,\n\t\t\t\t\t&ebuf[i]) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int dm9601_mdio_read(struct net_device *netdev, int phy_id, int loc)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\n\t__le16 res;\n\tint err;\n\n\tif (phy_id) {\n\t\tnetdev_dbg(dev->net, \"Only internal phy supported\\n\");\n\t\treturn 0;\n\t}\n\n\terr = dm_read_shared_word(dev, 1, loc, &res);\n\tif (err < 0) {\n\t\tnetdev_err(dev->net, \"MDIO read error: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tnetdev_dbg(dev->net,\n\t\t   \"dm9601_mdio_read() phy_id=0x%02x, loc=0x%02x, returns=0x%04x\\n\",\n\t\t   phy_id, loc, le16_to_cpu(res));\n\n\treturn le16_to_cpu(res);\n}\n\nstatic void dm9601_mdio_write(struct net_device *netdev, int phy_id, int loc,\n\t\t\t      int val)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\t__le16 res = cpu_to_le16(val);\n\n\tif (phy_id) {\n\t\tnetdev_dbg(dev->net, \"Only internal phy supported\\n\");\n\t\treturn;\n\t}\n\n\tnetdev_dbg(dev->net, \"dm9601_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\\n\",\n\t\t   phy_id, loc, val);\n\n\tdm_write_shared_word(dev, 1, loc, res);\n}\n\nstatic void dm9601_get_drvinfo(struct net_device *net,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\t \n\tusbnet_get_drvinfo(net, info);\n}\n\nstatic u32 dm9601_get_link(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\treturn mii_link_ok(&dev->mii);\n}\n\nstatic int dm9601_ioctl(struct net_device *net, struct ifreq *rq, int cmd)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\treturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\n}\n\nstatic const struct ethtool_ops dm9601_ethtool_ops = {\n\t.get_drvinfo\t= dm9601_get_drvinfo,\n\t.get_link\t= dm9601_get_link,\n\t.get_msglevel\t= usbnet_get_msglevel,\n\t.set_msglevel\t= usbnet_set_msglevel,\n\t.get_eeprom_len\t= dm9601_get_eeprom_len,\n\t.get_eeprom\t= dm9601_get_eeprom,\n\t.nway_reset\t= usbnet_nway_reset,\n\t.get_link_ksettings\t= usbnet_get_link_ksettings_mii,\n\t.set_link_ksettings\t= usbnet_set_link_ksettings_mii,\n};\n\nstatic void dm9601_set_multicast(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\t \n\tu8 *hashes = (u8 *) & dev->data;\n\tu8 rx_ctl = 0x31;\n\n\tmemset(hashes, 0x00, DM_MCAST_SIZE);\n\thashes[DM_MCAST_SIZE - 1] |= 0x80;\t \n\n\tif (net->flags & IFF_PROMISC) {\n\t\trx_ctl |= 0x02;\n\t} else if (net->flags & IFF_ALLMULTI ||\n\t\t   netdev_mc_count(net) > DM_MAX_MCAST) {\n\t\trx_ctl |= 0x08;\n\t} else if (!netdev_mc_empty(net)) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tnetdev_for_each_mc_addr(ha, net) {\n\t\t\tu32 crc = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\t\t\thashes[crc >> 3] |= 1 << (crc & 0x7);\n\t\t}\n\t}\n\n\tdm_write_async(dev, DM_MCAST_ADDR, DM_MCAST_SIZE, hashes);\n\tdm_write_reg_async(dev, DM_RX_CTRL, rx_ctl);\n}\n\nstatic void __dm9601_set_mac_address(struct usbnet *dev)\n{\n\tdm_write_async(dev, DM_PHY_ADDR, ETH_ALEN, dev->net->dev_addr);\n}\n\nstatic int dm9601_set_mac_address(struct net_device *net, void *p)\n{\n\tstruct sockaddr *addr = p;\n\tstruct usbnet *dev = netdev_priv(net);\n\n\tif (!is_valid_ether_addr(addr->sa_data)) {\n\t\tdev_err(&net->dev, \"not setting invalid mac address %pM\\n\",\n\t\t\t\t\t\t\t\taddr->sa_data);\n\t\treturn -EINVAL;\n\t}\n\n\teth_hw_addr_set(net, addr->sa_data);\n\t__dm9601_set_mac_address(dev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops dm9601_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_change_mtu\t\t= usbnet_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= dm9601_ioctl,\n\t.ndo_set_rx_mode\t= dm9601_set_multicast,\n\t.ndo_set_mac_address\t= dm9601_set_mac_address,\n};\n\nstatic int dm9601_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tu8 mac[ETH_ALEN], id;\n\n\tret = usbnet_get_endpoints(dev, intf);\n\tif (ret)\n\t\tgoto out;\n\n\tdev->net->netdev_ops = &dm9601_netdev_ops;\n\tdev->net->ethtool_ops = &dm9601_ethtool_ops;\n\tdev->net->hard_header_len += DM_TX_OVERHEAD;\n\tdev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\n\n\t \n\tdev->rx_urb_size = dev->net->mtu + ETH_HLEN + DM_RX_OVERHEAD + 1;\n\n\tdev->mii.dev = dev->net;\n\tdev->mii.mdio_read = dm9601_mdio_read;\n\tdev->mii.mdio_write = dm9601_mdio_write;\n\tdev->mii.phy_id_mask = 0x1f;\n\tdev->mii.reg_num_mask = 0x1f;\n\n\t \n\tdm_write_reg(dev, DM_NET_CTRL, 1);\n\tudelay(20);\n\n\t \n\tif (dm_read(dev, DM_PHY_ADDR, ETH_ALEN, mac) < 0) {\n\t\tprintk(KERN_ERR \"Error reading MAC address\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tif (is_valid_ether_addr(mac))\n\t\teth_hw_addr_set(dev->net, mac);\n\telse {\n\t\tprintk(KERN_WARNING\n\t\t\t\"dm9601: No valid MAC address in EEPROM, using %pM\\n\",\n\t\t\tdev->net->dev_addr);\n\t\t__dm9601_set_mac_address(dev);\n\t}\n\n\tif (dm_read_reg(dev, DM_CHIP_ID, &id) < 0) {\n\t\tnetdev_err(dev->net, \"Error reading chip ID\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tif (id == ID_DM9620) {\n\t\tu8 mode;\n\n\t\tif (dm_read_reg(dev, DM_MODE_CTRL, &mode) < 0) {\n\t\t\tnetdev_err(dev->net, \"Error reading MODE_CTRL\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tdm_write_reg(dev, DM_MODE_CTRL, mode & 0x7f);\n\t}\n\n\t \n\tdm_write_reg(dev, DM_GPR_CTRL, 1);\n\tdm_write_reg(dev, DM_GPR_DATA, 0);\n\n\t \n\tdm9601_set_multicast(dev->net);\n\n\tdm9601_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);\n\tdm9601_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,\n\t\t\t  ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);\n\tmii_nway_restart(&dev->mii);\n\nout:\n\treturn ret;\n}\n\nstatic int dm9601_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tu8 status;\n\tint len;\n\n\t \n\n\tif (unlikely(skb->len < DM_RX_OVERHEAD)) {\n\t\tdev_err(&dev->udev->dev, \"unexpected tiny rx frame\\n\");\n\t\treturn 0;\n\t}\n\n\tstatus = skb->data[0];\n\tlen = (skb->data[1] | (skb->data[2] << 8)) - 4;\n\n\tif (unlikely(status & 0xbf)) {\n\t\tif (status & 0x01) dev->net->stats.rx_fifo_errors++;\n\t\tif (status & 0x02) dev->net->stats.rx_crc_errors++;\n\t\tif (status & 0x04) dev->net->stats.rx_frame_errors++;\n\t\tif (status & 0x20) dev->net->stats.rx_missed_errors++;\n\t\tif (status & 0x90) dev->net->stats.rx_length_errors++;\n\t\treturn 0;\n\t}\n\n\tskb_pull(skb, 3);\n\tskb_trim(skb, len);\n\n\treturn 1;\n}\n\nstatic struct sk_buff *dm9601_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\n\t\t\t\t       gfp_t flags)\n{\n\tint len, pad;\n\n\t \n\n\tlen = skb->len + DM_TX_OVERHEAD;\n\n\t \n\twhile ((len & 1) || !(len % dev->maxpacket))\n\t\tlen++;\n\n\tlen -= DM_TX_OVERHEAD;  \n\tpad = len - skb->len;\n\n\tif (skb_headroom(skb) < DM_TX_OVERHEAD || skb_tailroom(skb) < pad) {\n\t\tstruct sk_buff *skb2;\n\n\t\tskb2 = skb_copy_expand(skb, DM_TX_OVERHEAD, pad, flags);\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = skb2;\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t}\n\n\t__skb_push(skb, DM_TX_OVERHEAD);\n\n\tif (pad) {\n\t\tmemset(skb->data + skb->len, 0, pad);\n\t\t__skb_put(skb, pad);\n\t}\n\n\tskb->data[0] = len;\n\tskb->data[1] = len >> 8;\n\n\treturn skb;\n}\n\nstatic void dm9601_status(struct usbnet *dev, struct urb *urb)\n{\n\tint link;\n\tu8 *buf;\n\n\t \n\n\tif (urb->actual_length < 8)\n\t\treturn;\n\n\tbuf = urb->transfer_buffer;\n\n\tlink = !!(buf[0] & 0x40);\n\tif (netif_carrier_ok(dev->net) != link) {\n\t\tusbnet_link_change(dev, link, 1);\n\t\tnetdev_dbg(dev->net, \"Link Status is: %d\\n\", link);\n\t}\n}\n\nstatic int dm9601_link_reset(struct usbnet *dev)\n{\n\tstruct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };\n\n\tmii_check_media(&dev->mii, 1, 1);\n\tmii_ethtool_gset(&dev->mii, &ecmd);\n\n\tnetdev_dbg(dev->net, \"link_reset() speed: %u duplex: %d\\n\",\n\t\t   ethtool_cmd_speed(&ecmd), ecmd.duplex);\n\n\treturn 0;\n}\n\nstatic const struct driver_info dm9601_info = {\n\t.description\t= \"Davicom DM96xx USB 10/100 Ethernet\",\n\t.flags\t\t= FLAG_ETHER | FLAG_LINK_INTR,\n\t.bind\t\t= dm9601_bind,\n\t.rx_fixup\t= dm9601_rx_fixup,\n\t.tx_fixup\t= dm9601_tx_fixup,\n\t.status\t\t= dm9601_status,\n\t.link_reset\t= dm9601_link_reset,\n\t.reset\t\t= dm9601_link_reset,\n};\n\nstatic const struct usb_device_id products[] = {\n\t{\n\t USB_DEVICE(0x07aa, 0x9601),\t \n\t .driver_info = (unsigned long)&dm9601_info,\n\t },\n\t{\n\t USB_DEVICE(0x0a46, 0x9601),\t \n\t .driver_info = (unsigned long)&dm9601_info,\n\t },\n\t{\n\t USB_DEVICE(0x0a46, 0x6688),\t \n\t .driver_info = (unsigned long)&dm9601_info,\n\t },\n\t{\n\t USB_DEVICE(0x0a46, 0x0268),\t \n\t .driver_info = (unsigned long)&dm9601_info,\n\t },\n\t{\n\t USB_DEVICE(0x0a46, 0x8515),\t \n\t .driver_info = (unsigned long)&dm9601_info,\n\t },\n\t{\n\tUSB_DEVICE(0x0a47, 0x9601),\t \n\t.driver_info = (unsigned long)&dm9601_info,\n\t },\n\t{\n\tUSB_DEVICE(0x0fe6, 0x8101),\t \n\t.driver_info = (unsigned long)&dm9601_info,\n\t },\n\t{\n\t USB_DEVICE(0x0fe6, 0x9700),\t \n\t .driver_info = (unsigned long)&dm9601_info,\n\t },\n\t{\n\t USB_DEVICE(0x0a46, 0x9000),\t \n\t .driver_info = (unsigned long)&dm9601_info,\n\t },\n\t{\n\t USB_DEVICE(0x0a46, 0x9620),\t \n\t .driver_info = (unsigned long)&dm9601_info,\n\t },\n\t{\n\t USB_DEVICE(0x0a46, 0x9621),\t \n\t .driver_info = (unsigned long)&dm9601_info,\n\t},\n\t{\n\t USB_DEVICE(0x0a46, 0x9622),\t \n\t .driver_info = (unsigned long)&dm9601_info,\n\t},\n\t{\n\t USB_DEVICE(0x0a46, 0x0269),\t \n\t .driver_info = (unsigned long)&dm9601_info,\n\t},\n\t{\n\t USB_DEVICE(0x0a46, 0x1269),\t \n\t .driver_info = (unsigned long)&dm9601_info,\n\t},\n\t{\n\t USB_DEVICE(0x0586, 0x3427),\t \n\t .driver_info = (unsigned long)&dm9601_info,\n\t},\n\t{},\t\t\t\n};\n\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver dm9601_driver = {\n\t.name = \"dm9601\",\n\t.id_table = products,\n\t.probe = usbnet_probe,\n\t.disconnect = usbnet_disconnect,\n\t.suspend = usbnet_suspend,\n\t.resume = usbnet_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(dm9601_driver);\n\nMODULE_AUTHOR(\"Peter Korsgaard <jacmet@sunsite.dk>\");\nMODULE_DESCRIPTION(\"Davicom DM96xx USB 10/100 ethernet devices\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}