{
  "module_name": "rtl8150.c",
  "hash_id": "a8b80abf0fb5c8ee04abdea5becd15a4f892cae35c9f6de87f758caa5e40863b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/rtl8150.c",
  "human_readable_source": "\n \n\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/usb.h>\n#include <linux/uaccess.h>\n\n \n#define DRIVER_VERSION \"v0.6.2 (2004/08/27)\"\n#define DRIVER_AUTHOR \"Petko Manolov <petkan@users.sourceforge.net>\"\n#define DRIVER_DESC \"rtl8150 based usb-ethernet driver\"\n\n#define\tIDR\t\t\t0x0120\n#define\tMAR\t\t\t0x0126\n#define\tCR\t\t\t0x012e\n#define\tTCR\t\t\t0x012f\n#define\tRCR\t\t\t0x0130\n#define\tTSR\t\t\t0x0132\n#define\tRSR\t\t\t0x0133\n#define\tCON0\t\t\t0x0135\n#define\tCON1\t\t\t0x0136\n#define\tMSR\t\t\t0x0137\n#define\tPHYADD\t\t\t0x0138\n#define\tPHYDAT\t\t\t0x0139\n#define\tPHYCNT\t\t\t0x013b\n#define\tGPPC\t\t\t0x013d\n#define\tBMCR\t\t\t0x0140\n#define\tBMSR\t\t\t0x0142\n#define\tANAR\t\t\t0x0144\n#define\tANLP\t\t\t0x0146\n#define\tAER\t\t\t0x0148\n#define CSCR\t\t\t0x014C   \n#define CSCR_LINK_STATUS\t(1 << 3)\n\n#define\tIDR_EEPROM\t\t0x1202\n\n#define\tPHY_READ\t\t0\n#define\tPHY_WRITE\t\t0x20\n#define\tPHY_GO\t\t\t0x40\n\n#define\tMII_TIMEOUT\t\t10\n#define\tINTBUFSIZE\t\t8\n\n#define\tRTL8150_REQT_READ\t0xc0\n#define\tRTL8150_REQT_WRITE\t0x40\n#define\tRTL8150_REQ_GET_REGS\t0x05\n#define\tRTL8150_REQ_SET_REGS\t0x05\n\n\n \n#define TSR_ECOL\t\t(1<<5)\n#define TSR_LCOL\t\t(1<<4)\n#define TSR_LOSS_CRS\t\t(1<<3)\n#define TSR_JBR\t\t\t(1<<2)\n#define TSR_ERRORS\t\t(TSR_ECOL | TSR_LCOL | TSR_LOSS_CRS | TSR_JBR)\n \n#define RSR_CRC\t\t\t(1<<2)\n#define RSR_FAE\t\t\t(1<<1)\n#define RSR_ERRORS\t\t(RSR_CRC | RSR_FAE)\n\n \n#define MSR_DUPLEX\t\t(1<<4)\n#define MSR_SPEED\t\t(1<<3)\n#define MSR_LINK\t\t(1<<2)\n\n \n#define INT_TSR\t\t\t0x00\n#define INT_RSR\t\t\t0x01\n#define INT_MSR\t\t\t0x02\n#define INT_WAKSR\t\t0x03\n#define INT_TXOK_CNT\t\t0x04\n#define INT_RXLOST_CNT\t\t0x05\n#define INT_CRERR_CNT\t\t0x06\n#define INT_COL_CNT\t\t0x07\n\n\n#define\tRTL8150_MTU\t\t1540\n#define\tRTL8150_TX_TIMEOUT\t(HZ)\n#define\tRX_SKB_POOL_SIZE\t4\n\n \n#define\tRTL8150_HW_CRC\t\t0\n#define\tRX_REG_SET\t\t1\n#define\tRTL8150_UNPLUG\t\t2\n#define\tRX_URB_FAIL\t\t3\n\n \n#define\tVENDOR_ID_REALTEK\t\t0x0bda\n#define\tVENDOR_ID_MELCO\t\t\t0x0411\n#define\tVENDOR_ID_MICRONET\t\t0x3980\n#define\tVENDOR_ID_LONGSHINE\t\t0x07b8\n#define\tVENDOR_ID_OQO\t\t\t0x1557\n#define\tVENDOR_ID_ZYXEL\t\t\t0x0586\n\n#define PRODUCT_ID_RTL8150\t\t0x8150\n#define\tPRODUCT_ID_LUAKTX\t\t0x0012\n#define\tPRODUCT_ID_LCS8138TX\t\t0x401a\n#define PRODUCT_ID_SP128AR\t\t0x0003\n#define\tPRODUCT_ID_PRESTIGE\t\t0x401a\n\n#undef\tEEPROM_WRITE\n\n \nstatic const struct usb_device_id rtl8150_table[] = {\n\t{USB_DEVICE(VENDOR_ID_REALTEK, PRODUCT_ID_RTL8150)},\n\t{USB_DEVICE(VENDOR_ID_MELCO, PRODUCT_ID_LUAKTX)},\n\t{USB_DEVICE(VENDOR_ID_MICRONET, PRODUCT_ID_SP128AR)},\n\t{USB_DEVICE(VENDOR_ID_LONGSHINE, PRODUCT_ID_LCS8138TX)},\n\t{USB_DEVICE(VENDOR_ID_OQO, PRODUCT_ID_RTL8150)},\n\t{USB_DEVICE(VENDOR_ID_ZYXEL, PRODUCT_ID_PRESTIGE)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, rtl8150_table);\n\nstruct rtl8150 {\n\tunsigned long flags;\n\tstruct usb_device *udev;\n\tstruct tasklet_struct tl;\n\tstruct net_device *netdev;\n\tstruct urb *rx_urb, *tx_urb, *intr_urb;\n\tstruct sk_buff *tx_skb, *rx_skb;\n\tstruct sk_buff *rx_skb_pool[RX_SKB_POOL_SIZE];\n\tspinlock_t rx_pool_lock;\n\tstruct usb_ctrlrequest dr;\n\tint intr_interval;\n\tu8 *intr_buff;\n\tu8 phy;\n};\n\ntypedef struct rtl8150 rtl8150_t;\n\nstruct async_req {\n\tstruct usb_ctrlrequest dr;\n\tu16 rx_creg;\n};\n\nstatic const char driver_name [] = \"rtl8150\";\n\n \nstatic int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg_recv(dev->udev, 0, RTL8150_REQ_GET_REGS,\n\t\t\t\t    RTL8150_REQT_READ, indx, 0, data, size,\n\t\t\t\t    1000, GFP_NOIO);\n}\n\nstatic int set_registers(rtl8150_t * dev, u16 indx, u16 size, const void *data)\n{\n\treturn usb_control_msg_send(dev->udev, 0, RTL8150_REQ_SET_REGS,\n\t\t\t\t    RTL8150_REQT_WRITE, indx, 0, data, size,\n\t\t\t\t    1000, GFP_NOIO);\n}\n\nstatic void async_set_reg_cb(struct urb *urb)\n{\n\tstruct async_req *req = (struct async_req *)urb->context;\n\tint status = urb->status;\n\n\tif (status < 0)\n\t\tdev_dbg(&urb->dev->dev, \"%s failed with %d\", __func__, status);\n\tkfree(req);\n\tusb_free_urb(urb);\n}\n\nstatic int async_set_registers(rtl8150_t *dev, u16 indx, u16 size, u16 reg)\n{\n\tint res = -ENOMEM;\n\tstruct urb *async_urb;\n\tstruct async_req *req;\n\n\treq = kmalloc(sizeof(struct async_req), GFP_ATOMIC);\n\tif (req == NULL)\n\t\treturn res;\n\tasync_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (async_urb == NULL) {\n\t\tkfree(req);\n\t\treturn res;\n\t}\n\treq->rx_creg = cpu_to_le16(reg);\n\treq->dr.bRequestType = RTL8150_REQT_WRITE;\n\treq->dr.bRequest = RTL8150_REQ_SET_REGS;\n\treq->dr.wIndex = 0;\n\treq->dr.wValue = cpu_to_le16(indx);\n\treq->dr.wLength = cpu_to_le16(size);\n\tusb_fill_control_urb(async_urb, dev->udev,\n\t                     usb_sndctrlpipe(dev->udev, 0), (void *)&req->dr,\n\t\t\t     &req->rx_creg, size, async_set_reg_cb, req);\n\tres = usb_submit_urb(async_urb, GFP_ATOMIC);\n\tif (res) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\t\tdev_err(&dev->udev->dev, \"%s failed with %d\\n\", __func__, res);\n\t}\n\treturn res;\n}\n\nstatic int read_mii_word(rtl8150_t * dev, u8 phy, __u8 indx, u16 * reg)\n{\n\tint i;\n\tu8 data[3], tmp;\n\n\tdata[0] = phy;\n\tdata[1] = data[2] = 0;\n\ttmp = indx | PHY_READ | PHY_GO;\n\ti = 0;\n\n\tset_registers(dev, PHYADD, sizeof(data), data);\n\tset_registers(dev, PHYCNT, 1, &tmp);\n\tdo {\n\t\tget_registers(dev, PHYCNT, 1, data);\n\t} while ((data[0] & PHY_GO) && (i++ < MII_TIMEOUT));\n\n\tif (i <= MII_TIMEOUT) {\n\t\tget_registers(dev, PHYDAT, 2, data);\n\t\t*reg = data[0] | (data[1] << 8);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nstatic int write_mii_word(rtl8150_t * dev, u8 phy, __u8 indx, u16 reg)\n{\n\tint i;\n\tu8 data[3], tmp;\n\n\tdata[0] = phy;\n\tdata[1] = reg & 0xff;\n\tdata[2] = (reg >> 8) & 0xff;\n\ttmp = indx | PHY_WRITE | PHY_GO;\n\ti = 0;\n\n\tset_registers(dev, PHYADD, sizeof(data), data);\n\tset_registers(dev, PHYCNT, 1, &tmp);\n\tdo {\n\t\tget_registers(dev, PHYCNT, 1, data);\n\t} while ((data[0] & PHY_GO) && (i++ < MII_TIMEOUT));\n\n\tif (i <= MII_TIMEOUT)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic void set_ethernet_addr(rtl8150_t *dev)\n{\n\tu8 node_id[ETH_ALEN];\n\tint ret;\n\n\tret = get_registers(dev, IDR, sizeof(node_id), node_id);\n\n\tif (!ret) {\n\t\teth_hw_addr_set(dev->netdev, node_id);\n\t} else {\n\t\teth_hw_addr_random(dev->netdev);\n\t\tnetdev_notice(dev->netdev, \"Assigned a random MAC address: %pM\\n\",\n\t\t\t      dev->netdev->dev_addr);\n\t}\n}\n\nstatic int rtl8150_set_mac_address(struct net_device *netdev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\trtl8150_t *dev = netdev_priv(netdev);\n\n\tif (netif_running(netdev))\n\t\treturn -EBUSY;\n\n\teth_hw_addr_set(netdev, addr->sa_data);\n\tnetdev_dbg(netdev, \"Setting MAC address to %pM\\n\", netdev->dev_addr);\n\t \n\tset_registers(dev, IDR, netdev->addr_len, netdev->dev_addr);\n#ifdef EEPROM_WRITE\n\t{\n\tint i;\n\tu8 cr;\n\t \n\tget_registers(dev, CR, 1, &cr);\n\t \n\tcr |= 0x20;\n\tset_registers(dev, CR, 1, &cr);\n\t \n\tfor (i = 0; i * 2 < netdev->addr_len; i++) {\n\t\tset_registers(dev, IDR_EEPROM + (i * 2), 2,\n\t\tnetdev->dev_addr + (i * 2));\n\t}\n\t \n\tcr &= 0xdf;\n\tset_registers(dev, CR, 1, &cr);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int rtl8150_reset(rtl8150_t * dev)\n{\n\tu8 data = 0x10;\n\tint i = HZ;\n\n\tset_registers(dev, CR, 1, &data);\n\tdo {\n\t\tget_registers(dev, CR, 1, &data);\n\t} while ((data & 0x10) && --i);\n\n\treturn (i > 0) ? 1 : 0;\n}\n\nstatic int alloc_all_urbs(rtl8150_t * dev)\n{\n\tdev->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->rx_urb)\n\t\treturn 0;\n\tdev->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->tx_urb) {\n\t\tusb_free_urb(dev->rx_urb);\n\t\treturn 0;\n\t}\n\tdev->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->intr_urb) {\n\t\tusb_free_urb(dev->rx_urb);\n\t\tusb_free_urb(dev->tx_urb);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void free_all_urbs(rtl8150_t * dev)\n{\n\tusb_free_urb(dev->rx_urb);\n\tusb_free_urb(dev->tx_urb);\n\tusb_free_urb(dev->intr_urb);\n}\n\nstatic void unlink_all_urbs(rtl8150_t * dev)\n{\n\tusb_kill_urb(dev->rx_urb);\n\tusb_kill_urb(dev->tx_urb);\n\tusb_kill_urb(dev->intr_urb);\n}\n\nstatic inline struct sk_buff *pull_skb(rtl8150_t *dev)\n{\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < RX_SKB_POOL_SIZE; i++) {\n\t\tif (dev->rx_skb_pool[i]) {\n\t\t\tskb = dev->rx_skb_pool[i];\n\t\t\tdev->rx_skb_pool[i] = NULL;\n\t\t\treturn skb;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void read_bulk_callback(struct urb *urb)\n{\n\trtl8150_t *dev;\n\tunsigned pkt_len, res;\n\tstruct sk_buff *skb;\n\tstruct net_device *netdev;\n\tint status = urb->status;\n\tint result;\n\tunsigned long flags;\n\n\tdev = urb->context;\n\tif (!dev)\n\t\treturn;\n\tif (test_bit(RTL8150_UNPLUG, &dev->flags))\n\t\treturn;\n\tnetdev = dev->netdev;\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\t\treturn;\t \n\tcase -ETIME:\n\t\tif (printk_ratelimit())\n\t\t\tdev_warn(&urb->dev->dev, \"may be reset is needed?..\\n\");\n\t\tgoto goon;\n\tdefault:\n\t\tif (printk_ratelimit())\n\t\t\tdev_warn(&urb->dev->dev, \"Rx status %d\\n\", status);\n\t\tgoto goon;\n\t}\n\n\tif (!dev->rx_skb)\n\t\tgoto resched;\n\t \n\tif (urb->actual_length < 4)\n\t\tgoto goon;\n\n\tres = urb->actual_length;\n\tpkt_len = res - 4;\n\n\tskb_put(dev->rx_skb, pkt_len);\n\tdev->rx_skb->protocol = eth_type_trans(dev->rx_skb, netdev);\n\tnetif_rx(dev->rx_skb);\n\tnetdev->stats.rx_packets++;\n\tnetdev->stats.rx_bytes += pkt_len;\n\n\tspin_lock_irqsave(&dev->rx_pool_lock, flags);\n\tskb = pull_skb(dev);\n\tspin_unlock_irqrestore(&dev->rx_pool_lock, flags);\n\tif (!skb)\n\t\tgoto resched;\n\n\tdev->rx_skb = skb;\ngoon:\n\tusb_fill_bulk_urb(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\n\t\t      dev->rx_skb->data, RTL8150_MTU, read_bulk_callback, dev);\n\tresult = usb_submit_urb(dev->rx_urb, GFP_ATOMIC);\n\tif (result == -ENODEV)\n\t\tnetif_device_detach(dev->netdev);\n\telse if (result) {\n\t\tset_bit(RX_URB_FAIL, &dev->flags);\n\t\tgoto resched;\n\t} else {\n\t\tclear_bit(RX_URB_FAIL, &dev->flags);\n\t}\n\n\treturn;\nresched:\n\ttasklet_schedule(&dev->tl);\n}\n\nstatic void write_bulk_callback(struct urb *urb)\n{\n\trtl8150_t *dev;\n\tint status = urb->status;\n\n\tdev = urb->context;\n\tif (!dev)\n\t\treturn;\n\tdev_kfree_skb_irq(dev->tx_skb);\n\tif (!netif_device_present(dev->netdev))\n\t\treturn;\n\tif (status)\n\t\tdev_info(&urb->dev->dev, \"%s: Tx status %d\\n\",\n\t\t\t dev->netdev->name, status);\n\tnetif_trans_update(dev->netdev);\n\tnetif_wake_queue(dev->netdev);\n}\n\nstatic void intr_callback(struct urb *urb)\n{\n\trtl8150_t *dev;\n\t__u8 *d;\n\tint status = urb->status;\n\tint res;\n\n\tdev = urb->context;\n\tif (!dev)\n\t\treturn;\n\tswitch (status) {\n\tcase 0:\t\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\t \n\tdefault:\n\t\tdev_info(&urb->dev->dev, \"%s: intr status %d\\n\",\n\t\t\t dev->netdev->name, status);\n\t\tgoto resubmit;\n\t}\n\n\td = urb->transfer_buffer;\n\tif (d[0] & TSR_ERRORS) {\n\t\tdev->netdev->stats.tx_errors++;\n\t\tif (d[INT_TSR] & (TSR_ECOL | TSR_JBR))\n\t\t\tdev->netdev->stats.tx_aborted_errors++;\n\t\tif (d[INT_TSR] & TSR_LCOL)\n\t\t\tdev->netdev->stats.tx_window_errors++;\n\t\tif (d[INT_TSR] & TSR_LOSS_CRS)\n\t\t\tdev->netdev->stats.tx_carrier_errors++;\n\t}\n\t \n\tif ((d[INT_MSR] & MSR_LINK) == 0) {\n\t\tif (netif_carrier_ok(dev->netdev)) {\n\t\t\tnetif_carrier_off(dev->netdev);\n\t\t\tnetdev_dbg(dev->netdev, \"%s: LINK LOST\\n\", __func__);\n\t\t}\n\t} else {\n\t\tif (!netif_carrier_ok(dev->netdev)) {\n\t\t\tnetif_carrier_on(dev->netdev);\n\t\t\tnetdev_dbg(dev->netdev, \"%s: LINK CAME BACK\\n\", __func__);\n\t\t}\n\t}\n\nresubmit:\n\tres = usb_submit_urb (urb, GFP_ATOMIC);\n\tif (res == -ENODEV)\n\t\tnetif_device_detach(dev->netdev);\n\telse if (res)\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"can't resubmit intr, %s-%s/input0, status %d\\n\",\n\t\t\tdev->udev->bus->bus_name, dev->udev->devpath, res);\n}\n\nstatic int rtl8150_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\trtl8150_t *dev = usb_get_intfdata(intf);\n\n\tnetif_device_detach(dev->netdev);\n\n\tif (netif_running(dev->netdev)) {\n\t\tusb_kill_urb(dev->rx_urb);\n\t\tusb_kill_urb(dev->intr_urb);\n\t}\n\treturn 0;\n}\n\nstatic int rtl8150_resume(struct usb_interface *intf)\n{\n\trtl8150_t *dev = usb_get_intfdata(intf);\n\n\tnetif_device_attach(dev->netdev);\n\tif (netif_running(dev->netdev)) {\n\t\tdev->rx_urb->status = 0;\n\t\tdev->rx_urb->actual_length = 0;\n\t\tread_bulk_callback(dev->rx_urb);\n\n\t\tdev->intr_urb->status = 0;\n\t\tdev->intr_urb->actual_length = 0;\n\t\tintr_callback(dev->intr_urb);\n\t}\n\treturn 0;\n}\n\n \n\nstatic void fill_skb_pool(rtl8150_t *dev)\n{\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < RX_SKB_POOL_SIZE; i++) {\n\t\tif (dev->rx_skb_pool[i])\n\t\t\tcontinue;\n\t\tskb = dev_alloc_skb(RTL8150_MTU + 2);\n\t\tif (!skb) {\n\t\t\treturn;\n\t\t}\n\t\tskb_reserve(skb, 2);\n\t\tdev->rx_skb_pool[i] = skb;\n\t}\n}\n\nstatic void free_skb_pool(rtl8150_t *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < RX_SKB_POOL_SIZE; i++)\n\t\tdev_kfree_skb(dev->rx_skb_pool[i]);\n}\n\nstatic void rx_fixup(struct tasklet_struct *t)\n{\n\tstruct rtl8150 *dev = from_tasklet(dev, t, tl);\n\tstruct sk_buff *skb;\n\tint status;\n\n\tspin_lock_irq(&dev->rx_pool_lock);\n\tfill_skb_pool(dev);\n\tspin_unlock_irq(&dev->rx_pool_lock);\n\tif (test_bit(RX_URB_FAIL, &dev->flags))\n\t\tif (dev->rx_skb)\n\t\t\tgoto try_again;\n\tspin_lock_irq(&dev->rx_pool_lock);\n\tskb = pull_skb(dev);\n\tspin_unlock_irq(&dev->rx_pool_lock);\n\tif (skb == NULL)\n\t\tgoto tlsched;\n\tdev->rx_skb = skb;\n\tusb_fill_bulk_urb(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\n\t\t      dev->rx_skb->data, RTL8150_MTU, read_bulk_callback, dev);\ntry_again:\n\tstatus = usb_submit_urb(dev->rx_urb, GFP_ATOMIC);\n\tif (status == -ENODEV) {\n\t\tnetif_device_detach(dev->netdev);\n\t} else if (status) {\n\t\tset_bit(RX_URB_FAIL, &dev->flags);\n\t\tgoto tlsched;\n\t} else {\n\t\tclear_bit(RX_URB_FAIL, &dev->flags);\n\t}\n\n\treturn;\ntlsched:\n\ttasklet_schedule(&dev->tl);\n}\n\nstatic int enable_net_traffic(rtl8150_t * dev)\n{\n\tu8 cr, tcr, rcr, msr;\n\n\tif (!rtl8150_reset(dev)) {\n\t\tdev_warn(&dev->udev->dev, \"device reset failed\\n\");\n\t}\n\t \n\trcr = 0x9e;\n\ttcr = 0xd8;\n\tcr = 0x0c;\n\tif (!(rcr & 0x80))\n\t\tset_bit(RTL8150_HW_CRC, &dev->flags);\n\tset_registers(dev, RCR, 1, &rcr);\n\tset_registers(dev, TCR, 1, &tcr);\n\tset_registers(dev, CR, 1, &cr);\n\tget_registers(dev, MSR, 1, &msr);\n\n\treturn 0;\n}\n\nstatic void disable_net_traffic(rtl8150_t * dev)\n{\n\tu8 cr;\n\n\tget_registers(dev, CR, 1, &cr);\n\tcr &= 0xf3;\n\tset_registers(dev, CR, 1, &cr);\n}\n\nstatic void rtl8150_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tdev_warn(&netdev->dev, \"Tx timeout.\\n\");\n\tusb_unlink_urb(dev->tx_urb);\n\tnetdev->stats.tx_errors++;\n}\n\nstatic void rtl8150_set_multicast(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tu16 rx_creg = 0x9e;\n\n\tnetif_stop_queue(netdev);\n\tif (netdev->flags & IFF_PROMISC) {\n\t\trx_creg |= 0x0001;\n\t\tdev_info(&netdev->dev, \"%s: promiscuous mode\\n\", netdev->name);\n\t} else if (!netdev_mc_empty(netdev) ||\n\t\t   (netdev->flags & IFF_ALLMULTI)) {\n\t\trx_creg &= 0xfffe;\n\t\trx_creg |= 0x0002;\n\t\tdev_dbg(&netdev->dev, \"%s: allmulti set\\n\", netdev->name);\n\t} else {\n\t\t \n\t\trx_creg &= 0x00fc;\n\t}\n\tasync_set_registers(dev, RCR, sizeof(rx_creg), rx_creg);\n\tnetif_wake_queue(netdev);\n}\n\nstatic netdev_tx_t rtl8150_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tint count, res;\n\n\tnetif_stop_queue(netdev);\n\tcount = (skb->len < 60) ? 60 : skb->len;\n\tcount = (count & 0x3f) ? count : count + 1;\n\tdev->tx_skb = skb;\n\tusb_fill_bulk_urb(dev->tx_urb, dev->udev, usb_sndbulkpipe(dev->udev, 2),\n\t\t      skb->data, count, write_bulk_callback, dev);\n\tif ((res = usb_submit_urb(dev->tx_urb, GFP_ATOMIC))) {\n\t\t \n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\t\telse {\n\t\t\tdev_warn(&netdev->dev, \"failed tx_urb %d\\n\", res);\n\t\t\tnetdev->stats.tx_errors++;\n\t\t\tnetif_start_queue(netdev);\n\t\t}\n\t} else {\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += skb->len;\n\t\tnetif_trans_update(netdev);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n\nstatic void set_carrier(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tshort tmp;\n\n\tget_registers(dev, CSCR, 2, &tmp);\n\tif (tmp & CSCR_LINK_STATUS)\n\t\tnetif_carrier_on(netdev);\n\telse\n\t\tnetif_carrier_off(netdev);\n}\n\nstatic int rtl8150_open(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tint res;\n\n\tif (dev->rx_skb == NULL)\n\t\tdev->rx_skb = pull_skb(dev);\n\tif (!dev->rx_skb)\n\t\treturn -ENOMEM;\n\n\tset_registers(dev, IDR, 6, netdev->dev_addr);\n\n\tusb_fill_bulk_urb(dev->rx_urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\n\t\t      dev->rx_skb->data, RTL8150_MTU, read_bulk_callback, dev);\n\tif ((res = usb_submit_urb(dev->rx_urb, GFP_KERNEL))) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\t\tdev_warn(&netdev->dev, \"rx_urb submit failed: %d\\n\", res);\n\t\treturn res;\n\t}\n\tusb_fill_int_urb(dev->intr_urb, dev->udev, usb_rcvintpipe(dev->udev, 3),\n\t\t     dev->intr_buff, INTBUFSIZE, intr_callback,\n\t\t     dev, dev->intr_interval);\n\tif ((res = usb_submit_urb(dev->intr_urb, GFP_KERNEL))) {\n\t\tif (res == -ENODEV)\n\t\t\tnetif_device_detach(dev->netdev);\n\t\tdev_warn(&netdev->dev, \"intr_urb submit failed: %d\\n\", res);\n\t\tusb_kill_urb(dev->rx_urb);\n\t\treturn res;\n\t}\n\tenable_net_traffic(dev);\n\tset_carrier(netdev);\n\tnetif_start_queue(netdev);\n\n\treturn res;\n}\n\nstatic int rtl8150_close(struct net_device *netdev)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\n\tnetif_stop_queue(netdev);\n\tif (!test_bit(RTL8150_UNPLUG, &dev->flags))\n\t\tdisable_net_traffic(dev);\n\tunlink_all_urbs(dev);\n\n\treturn 0;\n}\n\nstatic void rtl8150_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *info)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\n\tstrscpy(info->driver, driver_name, sizeof(info->driver));\n\tstrscpy(info->version, DRIVER_VERSION, sizeof(info->version));\n\tusb_make_path(dev->udev, info->bus_info, sizeof(info->bus_info));\n}\n\nstatic int rtl8150_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t      struct ethtool_link_ksettings *ecmd)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tshort lpa, bmcr;\n\tu32 supported;\n\n\tsupported = (SUPPORTED_10baseT_Half |\n\t\t\t  SUPPORTED_10baseT_Full |\n\t\t\t  SUPPORTED_100baseT_Half |\n\t\t\t  SUPPORTED_100baseT_Full |\n\t\t\t  SUPPORTED_Autoneg |\n\t\t\t  SUPPORTED_TP | SUPPORTED_MII);\n\tecmd->base.port = PORT_TP;\n\tecmd->base.phy_address = dev->phy;\n\tget_registers(dev, BMCR, 2, &bmcr);\n\tget_registers(dev, ANLP, 2, &lpa);\n\tif (bmcr & BMCR_ANENABLE) {\n\t\tu32 speed = ((lpa & (LPA_100HALF | LPA_100FULL)) ?\n\t\t\t     SPEED_100 : SPEED_10);\n\t\tecmd->base.speed = speed;\n\t\tecmd->base.autoneg = AUTONEG_ENABLE;\n\t\tif (speed == SPEED_100)\n\t\t\tecmd->base.duplex = (lpa & LPA_100FULL) ?\n\t\t\t    DUPLEX_FULL : DUPLEX_HALF;\n\t\telse\n\t\t\tecmd->base.duplex = (lpa & LPA_10FULL) ?\n\t\t\t    DUPLEX_FULL : DUPLEX_HALF;\n\t} else {\n\t\tecmd->base.autoneg = AUTONEG_DISABLE;\n\t\tecmd->base.speed = ((bmcr & BMCR_SPEED100) ?\n\t\t\t\t\t     SPEED_100 : SPEED_10);\n\t\tecmd->base.duplex = (bmcr & BMCR_FULLDPLX) ?\n\t\t    DUPLEX_FULL : DUPLEX_HALF;\n\t}\n\n\tethtool_convert_legacy_u32_to_link_mode(ecmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo = rtl8150_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n\t.get_link_ksettings = rtl8150_get_link_ksettings,\n};\n\nstatic int rtl8150_siocdevprivate(struct net_device *netdev, struct ifreq *rq,\n\t\t\t\t  void __user *udata, int cmd)\n{\n\trtl8150_t *dev = netdev_priv(netdev);\n\tu16 *data = (u16 *) & rq->ifr_ifru;\n\tint res = 0;\n\n\tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tdata[0] = dev->phy;\n\t\tfallthrough;\n\tcase SIOCDEVPRIVATE + 1:\n\t\tread_mii_word(dev, dev->phy, (data[1] & 0x1f), &data[3]);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\twrite_mii_word(dev, dev->phy, (data[1] & 0x1f), data[2]);\n\t\tbreak;\n\tdefault:\n\t\tres = -EOPNOTSUPP;\n\t}\n\n\treturn res;\n}\n\nstatic const struct net_device_ops rtl8150_netdev_ops = {\n\t.ndo_open\t\t= rtl8150_open,\n\t.ndo_stop\t\t= rtl8150_close,\n\t.ndo_siocdevprivate\t= rtl8150_siocdevprivate,\n\t.ndo_start_xmit\t\t= rtl8150_start_xmit,\n\t.ndo_tx_timeout\t\t= rtl8150_tx_timeout,\n\t.ndo_set_rx_mode\t= rtl8150_set_multicast,\n\t.ndo_set_mac_address\t= rtl8150_set_mac_address,\n\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int rtl8150_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\trtl8150_t *dev;\n\tstruct net_device *netdev;\n\n\tnetdev = alloc_etherdev(sizeof(rtl8150_t));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tdev = netdev_priv(netdev);\n\n\tdev->intr_buff = kmalloc(INTBUFSIZE, GFP_KERNEL);\n\tif (!dev->intr_buff) {\n\t\tfree_netdev(netdev);\n\t\treturn -ENOMEM;\n\t}\n\n\ttasklet_setup(&dev->tl, rx_fixup);\n\tspin_lock_init(&dev->rx_pool_lock);\n\n\tdev->udev = udev;\n\tdev->netdev = netdev;\n\tnetdev->netdev_ops = &rtl8150_netdev_ops;\n\tnetdev->watchdog_timeo = RTL8150_TX_TIMEOUT;\n\tnetdev->ethtool_ops = &ops;\n\tdev->intr_interval = 100;\t \n\n\tif (!alloc_all_urbs(dev)) {\n\t\tdev_err(&intf->dev, \"out of memory\\n\");\n\t\tgoto out;\n\t}\n\tif (!rtl8150_reset(dev)) {\n\t\tdev_err(&intf->dev, \"couldn't reset the device\\n\");\n\t\tgoto out1;\n\t}\n\tfill_skb_pool(dev);\n\tset_ethernet_addr(dev);\n\n\tusb_set_intfdata(intf, dev);\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tif (register_netdev(netdev) != 0) {\n\t\tdev_err(&intf->dev, \"couldn't register the device\\n\");\n\t\tgoto out2;\n\t}\n\n\tdev_info(&intf->dev, \"%s: rtl8150 is detected\\n\", netdev->name);\n\n\treturn 0;\n\nout2:\n\tusb_set_intfdata(intf, NULL);\n\tfree_skb_pool(dev);\nout1:\n\tfree_all_urbs(dev);\nout:\n\tkfree(dev->intr_buff);\n\tfree_netdev(netdev);\n\treturn -EIO;\n}\n\nstatic void rtl8150_disconnect(struct usb_interface *intf)\n{\n\trtl8150_t *dev = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tif (dev) {\n\t\tset_bit(RTL8150_UNPLUG, &dev->flags);\n\t\ttasklet_kill(&dev->tl);\n\t\tunregister_netdev(dev->netdev);\n\t\tunlink_all_urbs(dev);\n\t\tfree_all_urbs(dev);\n\t\tfree_skb_pool(dev);\n\t\tdev_kfree_skb(dev->rx_skb);\n\t\tkfree(dev->intr_buff);\n\t\tfree_netdev(dev->netdev);\n\t}\n}\n\nstatic struct usb_driver rtl8150_driver = {\n\t.name\t\t= driver_name,\n\t.probe\t\t= rtl8150_probe,\n\t.disconnect\t= rtl8150_disconnect,\n\t.id_table\t= rtl8150_table,\n\t.suspend\t= rtl8150_suspend,\n\t.resume\t\t= rtl8150_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(rtl8150_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}