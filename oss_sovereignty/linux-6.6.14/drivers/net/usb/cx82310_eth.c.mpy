{
  "module_name": "cx82310_eth.c",
  "hash_id": "4a8cb39847d0e2c8ef76891e38a9412be319f99caf5edd06c9f0ee5dfd0e8534",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/cx82310_eth.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/usbnet.h>\n\nenum cx82310_cmd {\n\tCMD_START\t\t= 0x84,\t \n\tCMD_STOP\t\t= 0x85,\t \n\tCMD_GET_STATUS\t\t= 0x90,\t \n\tCMD_GET_MAC_ADDR\t= 0x91,\t \n\tCMD_GET_LINK_STATUS\t= 0x92,\t \n\tCMD_ETHERNET_MODE\t= 0x99,\t \n};\n\nenum cx82310_status {\n\tSTATUS_UNDEFINED,\n\tSTATUS_SUCCESS,\n\tSTATUS_ERROR,\n\tSTATUS_UNSUPPORTED,\n\tSTATUS_UNIMPLEMENTED,\n\tSTATUS_PARAMETER_ERROR,\n\tSTATUS_DBG_LOOPBACK,\n};\n\n#define CMD_PACKET_SIZE\t64\n#define CMD_TIMEOUT\t100\n#define CMD_REPLY_RETRY 5\n\n#define CX82310_MTU\t1514\n#define CMD_EP\t\t0x01\n\nstruct cx82310_priv {\n\tstruct work_struct reenable_work;\n\tstruct usbnet *dev;\n};\n\n \nstatic int cx82310_cmd(struct usbnet *dev, enum cx82310_cmd cmd, bool reply,\n\t\t       u8 *wdata, int wlen, u8 *rdata, int rlen)\n{\n\tint actual_len, retries, ret;\n\tstruct usb_device *udev = dev->udev;\n\tu8 *buf = kzalloc(CMD_PACKET_SIZE, GFP_KERNEL);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tbuf[0] = cmd;\n\tif (wdata)\n\t\tmemcpy(buf + 4, wdata, min_t(int, wlen, CMD_PACKET_SIZE - 4));\n\n\t \n\tret = usb_bulk_msg(udev, usb_sndbulkpipe(udev, CMD_EP), buf,\n\t\t\t   CMD_PACKET_SIZE, &actual_len, CMD_TIMEOUT);\n\tif (ret < 0) {\n\t\tif (cmd != CMD_GET_LINK_STATUS)\n\t\t\tnetdev_err(dev->net, \"send command %#x: error %d\\n\",\n\t\t\t\t   cmd, ret);\n\t\tgoto end;\n\t}\n\n\tif (reply) {\n\t\t \n\t\tfor (retries = 0; retries < CMD_REPLY_RETRY; retries++) {\n\t\t\tret = usb_bulk_msg(udev, usb_rcvbulkpipe(udev, CMD_EP),\n\t\t\t\t\t   buf, CMD_PACKET_SIZE, &actual_len,\n\t\t\t\t\t   CMD_TIMEOUT);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (cmd != CMD_GET_LINK_STATUS)\n\t\t\t\t\tnetdev_err(dev->net, \"reply receive error %d\\n\",\n\t\t\t\t\t\t   ret);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif (actual_len > 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (actual_len == 0) {\n\t\t\tnetdev_err(dev->net, \"no reply to command %#x\\n\", cmd);\n\t\t\tret = -EIO;\n\t\t\tgoto end;\n\t\t}\n\t\tif (buf[0] != cmd) {\n\t\t\tnetdev_err(dev->net, \"got reply to command %#x, expected: %#x\\n\",\n\t\t\t\t   buf[0], cmd);\n\t\t\tret = -EIO;\n\t\t\tgoto end;\n\t\t}\n\t\tif (buf[1] != STATUS_SUCCESS) {\n\t\t\tnetdev_err(dev->net, \"command %#x failed: %#x\\n\", cmd,\n\t\t\t\t   buf[1]);\n\t\t\tret = -EIO;\n\t\t\tgoto end;\n\t\t}\n\t\tif (rdata)\n\t\t\tmemcpy(rdata, buf + 4,\n\t\t\t       min_t(int, rlen, CMD_PACKET_SIZE - 4));\n\t}\nend:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int cx82310_enable_ethernet(struct usbnet *dev)\n{\n\tint ret = cx82310_cmd(dev, CMD_ETHERNET_MODE, true, \"\\x01\", 1, NULL, 0);\n\n\tif (ret)\n\t\tnetdev_err(dev->net, \"unable to enable ethernet mode: %d\\n\",\n\t\t\t   ret);\n\treturn ret;\n}\n\nstatic void cx82310_reenable_work(struct work_struct *work)\n{\n\tstruct cx82310_priv *priv = container_of(work, struct cx82310_priv,\n\t\t\t\t\t\t reenable_work);\n\tcx82310_enable_ethernet(priv->dev);\n}\n\n#define partial_len\tdata[0]\t\t \n#define partial_rem\tdata[1]\t\t \n#define partial_data\tdata[2]\t\t \n\nstatic int cx82310_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tchar buf[15];\n\tstruct usb_device *udev = dev->udev;\n\tu8 link[3];\n\tint timeout = 50;\n\tstruct cx82310_priv *priv;\n\tu8 addr[ETH_ALEN];\n\n\t \n\tif (usb_string(udev, udev->descriptor.iProduct, buf, sizeof(buf)) > 0\n\t    && strcmp(buf, \"USB NET CARD\")) {\n\t\tdev_info(&udev->dev, \"ignoring: probably an ADSL modem\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = usbnet_get_endpoints(dev, intf);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdev->net->hard_header_len = 0;\n\t \n\tdev->hard_mtu = CX82310_MTU + 2;\n\t \n\tdev->rx_urb_size = 4096;\n\n\tdev->partial_data = (unsigned long) kmalloc(dev->hard_mtu, GFP_KERNEL);\n\tif (!dev->partial_data)\n\t\treturn -ENOMEM;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tret = -ENOMEM;\n\t\tgoto err_partial;\n\t}\n\tdev->driver_priv = priv;\n\tINIT_WORK(&priv->reenable_work, cx82310_reenable_work);\n\tpriv->dev = dev;\n\n\t \n\twhile (--timeout) {\n\t\tret = cx82310_cmd(dev, CMD_GET_LINK_STATUS, true, NULL, 0,\n\t\t\t\t  link, sizeof(link));\n\t\t \n\t\tif (!ret && link[0] == 1 && link[2] == 1)\n\t\t\tbreak;\n\t\tmsleep(500);\n\t}\n\tif (!timeout) {\n\t\tnetdev_err(dev->net, \"firmware not ready in time\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto err;\n\t}\n\n\t \n\tret = cx82310_enable_ethernet(dev);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = cx82310_cmd(dev, CMD_GET_MAC_ADDR, true, NULL, 0, addr, ETH_ALEN);\n\tif (ret) {\n\t\tnetdev_err(dev->net, \"unable to read MAC address: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\teth_hw_addr_set(dev->net, addr);\n\n\t \n\tret = cx82310_cmd(dev, CMD_START, false, NULL, 0, NULL, 0);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tkfree(dev->driver_priv);\nerr_partial:\n\tkfree((void *)dev->partial_data);\n\treturn ret;\n}\n\nstatic void cx82310_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct cx82310_priv *priv = dev->driver_priv;\n\n\tkfree((void *)dev->partial_data);\n\tcancel_work_sync(&priv->reenable_work);\n\tkfree(dev->driver_priv);\n}\n\n \nstatic int cx82310_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tint len;\n\tstruct sk_buff *skb2;\n\tstruct cx82310_priv *priv = dev->driver_priv;\n\n\t \n\tif (dev->partial_rem) {\n\t\tlen = dev->partial_len + dev->partial_rem;\n\t\tskb2 = alloc_skb(len, GFP_ATOMIC);\n\t\tif (!skb2)\n\t\t\treturn 0;\n\t\tskb_put(skb2, len);\n\t\tmemcpy(skb2->data, (void *)dev->partial_data,\n\t\t       dev->partial_len);\n\t\tmemcpy(skb2->data + dev->partial_len, skb->data,\n\t\t       dev->partial_rem);\n\t\tusbnet_skb_return(dev, skb2);\n\t\tskb_pull(skb, (dev->partial_rem + 1) & ~1);\n\t\tdev->partial_rem = 0;\n\t\tif (skb->len < 2)\n\t\t\treturn 1;\n\t}\n\n\t \n\twhile (skb->len > 1) {\n\t\t \n\t\tlen = skb->data[0] | (skb->data[1] << 8);\n\t\tskb_pull(skb, 2);\n\n\t\t \n\t\tif (len == skb->len || len + 1 == skb->len) {\n\t\t\tskb_trim(skb, len);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (len == 0xffff) {\n\t\t\tnetdev_info(dev->net, \"router was rebooted, re-enabling ethernet mode\");\n\t\t\tschedule_work(&priv->reenable_work);\n\t\t} else if (len > CX82310_MTU) {\n\t\t\tnetdev_err(dev->net, \"RX packet too long: %d B\\n\", len);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (len > skb->len) {\n\t\t\tdev->partial_len = skb->len;\n\t\t\tdev->partial_rem = len - skb->len;\n\t\t\tmemcpy((void *)dev->partial_data, skb->data,\n\t\t\t       dev->partial_len);\n\t\t\tskb_pull(skb, skb->len);\n\t\t\tbreak;\n\t\t}\n\n\t\tskb2 = alloc_skb(len, GFP_ATOMIC);\n\t\tif (!skb2)\n\t\t\treturn 0;\n\t\tskb_put(skb2, len);\n\t\tmemcpy(skb2->data, skb->data, len);\n\t\t \n\t\tusbnet_skb_return(dev, skb2);\n\n\t\tskb_pull(skb, (len + 1) & ~1);\n\t}\n\n\t \n\treturn 1;\n}\n\n \nstatic struct sk_buff *cx82310_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\n\t\t\t\t       gfp_t flags)\n{\n\tint len = skb->len;\n\n\tif (skb_cow_head(skb, 2)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NULL;\n\t}\n\tskb_push(skb, 2);\n\n\tskb->data[0] = len;\n\tskb->data[1] = len >> 8;\n\n\treturn skb;\n}\n\n\nstatic const struct driver_info\tcx82310_info = {\n\t.description\t= \"Conexant CX82310 USB ethernet\",\n\t.flags\t\t= FLAG_ETHER,\n\t.bind\t\t= cx82310_bind,\n\t.unbind\t\t= cx82310_unbind,\n\t.rx_fixup\t= cx82310_rx_fixup,\n\t.tx_fixup\t= cx82310_tx_fixup,\n};\n\n#define USB_DEVICE_CLASS(vend, prod, cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_DEV_INFO, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bDeviceClass = (cl), \\\n\t.bDeviceSubClass = (sc), \\\n\t.bDeviceProtocol = (pr)\n\nstatic const struct usb_device_id products[] = {\n\t{\n\t\tUSB_DEVICE_CLASS(0x0572, 0xcb01, 0xff, 0, 0),\n\t\t.driver_info = (unsigned long) &cx82310_info\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver cx82310_driver = {\n\t.name\t\t= \"cx82310_eth\",\n\t.id_table\t= products,\n\t.probe\t\t= usbnet_probe,\n\t.disconnect\t= usbnet_disconnect,\n\t.suspend\t= usbnet_suspend,\n\t.resume\t\t= usbnet_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(cx82310_driver);\n\nMODULE_AUTHOR(\"Ondrej Zary\");\nMODULE_DESCRIPTION(\"Conexant CX82310-based ADSL router USB ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}