{
  "module_name": "lg-vl600.c",
  "hash_id": "2eefb8d84ca6a81c1f0f26945648ab44073b4e3a1b0c07ad19e40c1281e6bdb5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/lg-vl600.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/usbnet.h>\n#include <linux/if_ether.h>\n#include <linux/if_arp.h>\n#include <linux/inetdevice.h>\n#include <linux/module.h>\n\n \n\nstruct vl600_frame_hdr {\n\t__le32 len;\n\t__le32 serial;\n\t__le32 pkt_cnt;\n\t__le32 dummy_flags;\n\t__le32 dummy;\n\t__le32 magic;\n} __attribute__((packed));\n\nstruct vl600_pkt_hdr {\n\t__le32 dummy[2];\n\t__le32 len;\n\t__be16 h_proto;\n} __attribute__((packed));\n\nstruct vl600_state {\n\tstruct sk_buff *current_rx_buf;\n};\n\nstatic int vl600_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tstruct vl600_state *s = kzalloc(sizeof(struct vl600_state), GFP_KERNEL);\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tret = usbnet_cdc_bind(dev, intf);\n\tif (ret) {\n\t\tkfree(s);\n\t\treturn ret;\n\t}\n\n\tdev->driver_priv = s;\n\n\t \n\tdev->net->flags |= IFF_NOARP;\n\t \n\tdev->net->flags |= IFF_MULTICAST;\n\n\treturn ret;\n}\n\nstatic void vl600_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct vl600_state *s = dev->driver_priv;\n\n\tdev_kfree_skb(s->current_rx_buf);\n\tkfree(s);\n\n\treturn usbnet_cdc_unbind(dev, intf);\n}\n\nstatic int vl600_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct vl600_frame_hdr *frame;\n\tstruct vl600_pkt_hdr *packet;\n\tstruct ethhdr *ethhdr;\n\tint packet_len, count;\n\tstruct sk_buff *buf = skb;\n\tstruct sk_buff *clone;\n\tstruct vl600_state *s = dev->driver_priv;\n\n\t \n\n\t \n\tif (s->current_rx_buf) {\n\t\tframe = (struct vl600_frame_hdr *) s->current_rx_buf->data;\n\t\tif (skb->len + s->current_rx_buf->len >\n\t\t\t\tle32_to_cpup(&frame->len)) {\n\t\t\tnetif_err(dev, ifup, dev->net, \"Fragment too long\\n\");\n\t\t\tdev->net->stats.rx_length_errors++;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbuf = s->current_rx_buf;\n\t\tskb_put_data(buf, skb->data, skb->len);\n\t} else if (skb->len < 4) {\n\t\tnetif_err(dev, ifup, dev->net, \"Frame too short\\n\");\n\t\tdev->net->stats.rx_length_errors++;\n\t\tgoto error;\n\t}\n\n\tframe = (struct vl600_frame_hdr *) buf->data;\n\t \n\tif (ntohl(frame->magic) != 0x53544448 &&\n\t\t\tntohl(frame->magic) != 0x44544d48)\n\t\tgoto error;\n\n\tif (buf->len < sizeof(*frame) ||\n\t\t\tbuf->len != le32_to_cpup(&frame->len)) {\n\t\t \n\t\tif (s->current_rx_buf)\n\t\t\treturn 0;\n\n\t\ts->current_rx_buf = skb_copy_expand(skb, 0,\n\t\t\t\tle32_to_cpup(&frame->len), GFP_ATOMIC);\n\t\tif (!s->current_rx_buf)\n\t\t\tdev->net->stats.rx_errors++;\n\n\t\treturn 0;\n\t}\n\n\tcount = le32_to_cpup(&frame->pkt_cnt);\n\n\tskb_pull(buf, sizeof(*frame));\n\n\twhile (count--) {\n\t\tif (buf->len < sizeof(*packet)) {\n\t\t\tnetif_err(dev, ifup, dev->net, \"Packet too short\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tpacket = (struct vl600_pkt_hdr *) buf->data;\n\t\tpacket_len = sizeof(*packet) + le32_to_cpup(&packet->len);\n\t\tif (packet_len > buf->len) {\n\t\t\tnetif_err(dev, ifup, dev->net,\n\t\t\t\t\t\"Bad packet length stored in header\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tethhdr = (struct ethhdr *) skb->data;\n\t\tif (be16_to_cpup(&ethhdr->h_proto) == ETH_P_ARP &&\n\t\t\t\tbuf->len > 0x26) {\n\t\t\t \n\t\t\tmemcpy(ethhdr->h_source,\n\t\t\t\t\t&buf->data[sizeof(*ethhdr) + 0x8],\n\t\t\t\t\tETH_ALEN);\n\t\t\tmemcpy(ethhdr->h_dest,\n\t\t\t\t\t&buf->data[sizeof(*ethhdr) + 0x12],\n\t\t\t\t\tETH_ALEN);\n\t\t} else {\n\t\t\teth_zero_addr(ethhdr->h_source);\n\t\t\tmemcpy(ethhdr->h_dest, dev->net->dev_addr, ETH_ALEN);\n\n\t\t\t \n\t\t\tif ((buf->data[sizeof(*ethhdr)] & 0xf0) == 0x60)\n\t\t\t\tethhdr->h_proto = htons(ETH_P_IPV6);\n\t\t}\n\n\t\tif (count) {\n\t\t\t \n\t\t\tclone = skb_clone(buf, GFP_ATOMIC);\n\t\t\tif (!clone)\n\t\t\t\tgoto error;\n\n\t\t\tskb_trim(clone, packet_len);\n\t\t\tusbnet_skb_return(dev, clone);\n\n\t\t\tskb_pull(buf, (packet_len + 3) & ~3);\n\t\t} else {\n\t\t\tskb_trim(buf, packet_len);\n\n\t\t\tif (s->current_rx_buf) {\n\t\t\t\tusbnet_skb_return(dev, buf);\n\t\t\t\ts->current_rx_buf = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\nerror:\n\tif (s->current_rx_buf) {\n\t\tdev_kfree_skb_any(s->current_rx_buf);\n\t\ts->current_rx_buf = NULL;\n\t}\n\tdev->net->stats.rx_errors++;\n\treturn 0;\n}\n\nstatic struct sk_buff *vl600_tx_fixup(struct usbnet *dev,\n\t\tstruct sk_buff *skb, gfp_t flags)\n{\n\tstruct sk_buff *ret;\n\tstruct vl600_frame_hdr *frame;\n\tstruct vl600_pkt_hdr *packet;\n\tstatic uint32_t serial = 1;\n\tint orig_len = skb->len - sizeof(struct ethhdr);\n\tint full_len = (skb->len + sizeof(struct vl600_frame_hdr) + 3) & ~3;\n\n\tframe = (struct vl600_frame_hdr *) skb->data;\n\tif (skb->len > sizeof(*frame) && skb->len == le32_to_cpup(&frame->len))\n\t\treturn skb;  \n\n\tif (skb->len < sizeof(struct ethhdr))\n\t\t \n\t\treturn NULL;\n\n\tif (!skb_cloned(skb)) {\n\t\tint headroom = skb_headroom(skb);\n\t\tint tailroom = skb_tailroom(skb);\n\n\t\tif (tailroom >= full_len - skb->len - sizeof(*frame) &&\n\t\t\t\theadroom >= sizeof(*frame))\n\t\t\t \n\t\t\tgoto encapsulate;\n\n\t\tif (headroom + tailroom + skb->len >= full_len) {\n\t\t\t \n\t\t\tskb->data = memmove(skb->head + sizeof(*frame),\n\t\t\t\t\tskb->data, skb->len);\n\t\t\tskb_set_tail_pointer(skb, skb->len);\n\t\t\tgoto encapsulate;\n\t\t}\n\t}\n\n\t \n\tret = skb_copy_expand(skb, sizeof(struct vl600_frame_hdr), full_len -\n\t\t\tskb->len - sizeof(struct vl600_frame_hdr), flags);\n\tdev_kfree_skb_any(skb);\n\tif (!ret)\n\t\treturn ret;\n\tskb = ret;\n\nencapsulate:\n\t \n\tpacket = (struct vl600_pkt_hdr *) skb->data;\n\t \n\tpacket->h_proto = htons(ETH_P_IP);\n\tmemset(&packet->dummy, 0, sizeof(packet->dummy));\n\tpacket->len = cpu_to_le32(orig_len);\n\n\tframe = skb_push(skb, sizeof(*frame));\n\tmemset(frame, 0, sizeof(*frame));\n\tframe->len = cpu_to_le32(full_len);\n\tframe->serial = cpu_to_le32(serial++);\n\tframe->pkt_cnt = cpu_to_le32(1);\n\n\tif (skb->len < full_len)  \n\t\tskb_put(skb, full_len - skb->len);\n\n\treturn skb;\n}\n\nstatic const struct driver_info\tvl600_info = {\n\t.description\t= \"LG VL600 modem\",\n\t.flags\t\t= FLAG_RX_ASSEMBLE | FLAG_WWAN,\n\t.bind\t\t= vl600_bind,\n\t.unbind\t\t= vl600_unbind,\n\t.status\t\t= usbnet_cdc_status,\n\t.rx_fixup\t= vl600_rx_fixup,\n\t.tx_fixup\t= vl600_tx_fixup,\n};\n\nstatic const struct usb_device_id products[] = {\n\t{\n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x1004, 0x61aa, USB_CLASS_COMM,\n\t\t\t\tUSB_CDC_SUBCLASS_ETHERNET, USB_CDC_PROTO_NONE),\n\t\t.driver_info\t= (unsigned long) &vl600_info,\n\t},\n\t{},\t \n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver lg_vl600_driver = {\n\t.name\t\t= \"lg-vl600\",\n\t.id_table\t= products,\n\t.probe\t\t= usbnet_probe,\n\t.disconnect\t= usbnet_disconnect,\n\t.suspend\t= usbnet_suspend,\n\t.resume\t\t= usbnet_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(lg_vl600_driver);\n\nMODULE_AUTHOR(\"Anrzej Zaborowski\");\nMODULE_DESCRIPTION(\"LG-VL600 modem's ethernet link\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}