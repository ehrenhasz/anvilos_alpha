{
  "module_name": "qmi_wwan.c",
  "hash_id": "ee5cf53221b5223e8fc3b9d226a280191a8bb30b2564865f6c14c7049e7854b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/qmi_wwan.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sched/signal.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/kstrtox.h>\n#include <linux/mii.h>\n#include <linux/rtnetlink.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/usbnet.h>\n#include <linux/usb/cdc-wdm.h>\n#include <linux/u64_stats_sync.h>\n\n \n\n \nstruct qmi_wwan_state {\n\tstruct usb_driver *subdriver;\n\tatomic_t pmcount;\n\tunsigned long flags;\n\tstruct usb_interface *control;\n\tstruct usb_interface *data;\n};\n\nenum qmi_wwan_flags {\n\tQMI_WWAN_FLAG_RAWIP = 1 << 0,\n\tQMI_WWAN_FLAG_MUX = 1 << 1,\n\tQMI_WWAN_FLAG_PASS_THROUGH = 1 << 2,\n};\n\nenum qmi_wwan_quirks {\n\tQMI_WWAN_QUIRK_DTR = 1 << 0,\t \n};\n\nstruct qmimux_hdr {\n\tu8 pad;\n\tu8 mux_id;\n\t__be16 pkt_len;\n};\n\nstruct qmimux_priv {\n\tstruct net_device *real_dev;\n\tu8 mux_id;\n};\n\nstatic int qmimux_open(struct net_device *dev)\n{\n\tstruct qmimux_priv *priv = netdev_priv(dev);\n\tstruct net_device *real_dev = priv->real_dev;\n\n\tif (!(priv->real_dev->flags & IFF_UP))\n\t\treturn -ENETDOWN;\n\n\tif (netif_carrier_ok(real_dev))\n\t\tnetif_carrier_on(dev);\n\treturn 0;\n}\n\nstatic int qmimux_stop(struct net_device *dev)\n{\n\tnetif_carrier_off(dev);\n\treturn 0;\n}\n\nstatic netdev_tx_t qmimux_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct qmimux_priv *priv = netdev_priv(dev);\n\tunsigned int len = skb->len;\n\tstruct qmimux_hdr *hdr;\n\tnetdev_tx_t ret;\n\n\thdr = skb_push(skb, sizeof(struct qmimux_hdr));\n\thdr->pad = 0;\n\thdr->mux_id = priv->mux_id;\n\thdr->pkt_len = cpu_to_be16(len);\n\tskb->dev = priv->real_dev;\n\tret = dev_queue_xmit(skb);\n\n\tif (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN))\n\t\tdev_sw_netstats_tx_add(dev, 1, len);\n\telse\n\t\tdev->stats.tx_dropped++;\n\n\treturn ret;\n}\n\nstatic const struct net_device_ops qmimux_netdev_ops = {\n\t.ndo_open        = qmimux_open,\n\t.ndo_stop        = qmimux_stop,\n\t.ndo_start_xmit  = qmimux_start_xmit,\n\t.ndo_get_stats64 = dev_get_tstats64,\n};\n\nstatic void qmimux_setup(struct net_device *dev)\n{\n\tdev->header_ops      = NULL;   \n\tdev->type            = ARPHRD_NONE;\n\tdev->hard_header_len = 0;\n\tdev->addr_len        = 0;\n\tdev->flags           = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\tdev->netdev_ops      = &qmimux_netdev_ops;\n\tdev->mtu             = 1500;\n\tdev->needs_free_netdev = true;\n}\n\nstatic struct net_device *qmimux_find_dev(struct usbnet *dev, u8 mux_id)\n{\n\tstruct qmimux_priv *priv;\n\tstruct list_head *iter;\n\tstruct net_device *ldev;\n\n\trcu_read_lock();\n\tnetdev_for_each_upper_dev_rcu(dev->net, ldev, iter) {\n\t\tpriv = netdev_priv(ldev);\n\t\tif (priv->mux_id == mux_id) {\n\t\t\trcu_read_unlock();\n\t\t\treturn ldev;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}\n\nstatic bool qmimux_has_slaves(struct usbnet *dev)\n{\n\treturn !list_empty(&dev->net->adj_list.upper);\n}\n\nstatic int qmimux_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tunsigned int len, offset = 0, pad_len, pkt_len;\n\tstruct qmimux_hdr *hdr;\n\tstruct net_device *net;\n\tstruct sk_buff *skbn;\n\tu8 qmimux_hdr_sz = sizeof(*hdr);\n\n\twhile (offset + qmimux_hdr_sz < skb->len) {\n\t\thdr = (struct qmimux_hdr *)(skb->data + offset);\n\t\tlen = be16_to_cpu(hdr->pkt_len);\n\n\t\t \n\t\tif (offset + len + qmimux_hdr_sz > skb->len)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (hdr->pad & 0x80)\n\t\t\tgoto skip;\n\n\t\t \n\t\tpad_len = hdr->pad & 0x3f;\n\t\tif (len == 0 || pad_len >= len)\n\t\t\tgoto skip;\n\t\tpkt_len = len - pad_len;\n\n\t\tnet = qmimux_find_dev(dev, hdr->mux_id);\n\t\tif (!net)\n\t\t\tgoto skip;\n\t\tskbn = netdev_alloc_skb(net, pkt_len + LL_MAX_HEADER);\n\t\tif (!skbn)\n\t\t\treturn 0;\n\n\t\tswitch (skb->data[offset + qmimux_hdr_sz] & 0xf0) {\n\t\tcase 0x40:\n\t\t\tskbn->protocol = htons(ETH_P_IP);\n\t\t\tbreak;\n\t\tcase 0x60:\n\t\t\tskbn->protocol = htons(ETH_P_IPV6);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tgoto skip;\n\t\t}\n\n\t\tskb_reserve(skbn, LL_MAX_HEADER);\n\t\tskb_put_data(skbn, skb->data + offset + qmimux_hdr_sz, pkt_len);\n\t\tif (netif_rx(skbn) != NET_RX_SUCCESS) {\n\t\t\tnet->stats.rx_errors++;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tdev_sw_netstats_rx_add(net, pkt_len);\n\t\t}\n\nskip:\n\t\toffset += len + qmimux_hdr_sz;\n\t}\n\treturn 1;\n}\n\nstatic ssize_t mux_id_show(struct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct net_device *dev = to_net_dev(d);\n\tstruct qmimux_priv *priv;\n\n\tpriv = netdev_priv(dev);\n\n\treturn sysfs_emit(buf, \"0x%02x\\n\", priv->mux_id);\n}\n\nstatic DEVICE_ATTR_RO(mux_id);\n\nstatic struct attribute *qmi_wwan_sysfs_qmimux_attrs[] = {\n\t&dev_attr_mux_id.attr,\n\tNULL,\n};\n\nstatic struct attribute_group qmi_wwan_sysfs_qmimux_attr_group = {\n\t.name = \"qmap\",\n\t.attrs = qmi_wwan_sysfs_qmimux_attrs,\n};\n\nstatic int qmimux_register_device(struct net_device *real_dev, u8 mux_id)\n{\n\tstruct net_device *new_dev;\n\tstruct qmimux_priv *priv;\n\tint err;\n\n\tnew_dev = alloc_netdev(sizeof(struct qmimux_priv),\n\t\t\t       \"qmimux%d\", NET_NAME_UNKNOWN, qmimux_setup);\n\tif (!new_dev)\n\t\treturn -ENOBUFS;\n\n\tdev_net_set(new_dev, dev_net(real_dev));\n\tpriv = netdev_priv(new_dev);\n\tpriv->mux_id = mux_id;\n\tpriv->real_dev = real_dev;\n\n\tnew_dev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!new_dev->tstats) {\n\t\terr = -ENOBUFS;\n\t\tgoto out_free_newdev;\n\t}\n\n\tnew_dev->sysfs_groups[0] = &qmi_wwan_sysfs_qmimux_attr_group;\n\n\terr = register_netdevice(new_dev);\n\tif (err < 0)\n\t\tgoto out_free_newdev;\n\n\t \n\tdev_hold(real_dev);\n\n\terr = netdev_upper_dev_link(real_dev, new_dev, NULL);\n\tif (err)\n\t\tgoto out_unregister_netdev;\n\n\tnetif_stacked_transfer_operstate(real_dev, new_dev);\n\n\treturn 0;\n\nout_unregister_netdev:\n\tunregister_netdevice(new_dev);\n\tdev_put(real_dev);\n\nout_free_newdev:\n\tfree_netdev(new_dev);\n\treturn err;\n}\n\nstatic void qmimux_unregister_device(struct net_device *dev,\n\t\t\t\t     struct list_head *head)\n{\n\tstruct qmimux_priv *priv = netdev_priv(dev);\n\tstruct net_device *real_dev = priv->real_dev;\n\n\tfree_percpu(dev->tstats);\n\tnetdev_upper_dev_unlink(real_dev, dev);\n\tunregister_netdevice_queue(dev, head);\n\n\t \n\tdev_put(real_dev);\n}\n\nstatic void qmi_wwan_netdev_setup(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct qmi_wwan_state *info = (void *)&dev->data;\n\n\tif (info->flags & QMI_WWAN_FLAG_RAWIP) {\n\t\tnet->header_ops      = NULL;   \n\t\tnet->type            = ARPHRD_NONE;\n\t\tnet->hard_header_len = 0;\n\t\tnet->addr_len        = 0;\n\t\tnet->flags           = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tset_bit(EVENT_NO_IP_ALIGN, &dev->flags);\n\t\tnetdev_dbg(net, \"mode: raw IP\\n\");\n\t} else if (!net->header_ops) {  \n\t\tether_setup(net);\n\t\t \n\t\tnet->min_mtu = 0;\n\t\tnet->max_mtu = ETH_MAX_MTU;\n\t\tclear_bit(EVENT_NO_IP_ALIGN, &dev->flags);\n\t\tnetdev_dbg(net, \"mode: Ethernet\\n\");\n\t}\n\n\t \n\tusbnet_change_mtu(net, net->mtu);\n}\n\nstatic ssize_t raw_ip_show(struct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct qmi_wwan_state *info = (void *)&dev->data;\n\n\treturn sprintf(buf, \"%c\\n\", info->flags & QMI_WWAN_FLAG_RAWIP ? 'Y' : 'N');\n}\n\nstatic ssize_t raw_ip_store(struct device *d,  struct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct qmi_wwan_state *info = (void *)&dev->data;\n\tbool enable;\n\tint ret;\n\n\tif (kstrtobool(buf, &enable))\n\t\treturn -EINVAL;\n\n\t \n\tif (enable == (info->flags & QMI_WWAN_FLAG_RAWIP))\n\t\treturn len;\n\n\t \n\tif (!enable && (info->flags & QMI_WWAN_FLAG_PASS_THROUGH)) {\n\t\tnetdev_err(dev->net,\n\t\t\t   \"Cannot clear ip mode on pass through device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\t \n\tif (netif_running(dev->net)) {\n\t\tnetdev_err(dev->net, \"Cannot change a running device\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\t \n\tret = call_netdevice_notifiers(NETDEV_PRE_TYPE_CHANGE, dev->net);\n\tret = notifier_to_errno(ret);\n\tif (ret) {\n\t\tnetdev_err(dev->net, \"Type change was refused\\n\");\n\t\tgoto err;\n\t}\n\n\tif (enable)\n\t\tinfo->flags |= QMI_WWAN_FLAG_RAWIP;\n\telse\n\t\tinfo->flags &= ~QMI_WWAN_FLAG_RAWIP;\n\tqmi_wwan_netdev_setup(dev->net);\n\tcall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE, dev->net);\n\tret = len;\nerr:\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic ssize_t add_mux_show(struct device *d, struct device_attribute *attr, char *buf)\n{\n\tstruct net_device *dev = to_net_dev(d);\n\tstruct qmimux_priv *priv;\n\tstruct list_head *iter;\n\tstruct net_device *ldev;\n\tssize_t count = 0;\n\n\trcu_read_lock();\n\tnetdev_for_each_upper_dev_rcu(dev, ldev, iter) {\n\t\tpriv = netdev_priv(ldev);\n\t\tcount += scnprintf(&buf[count], PAGE_SIZE - count,\n\t\t\t\t   \"0x%02x\\n\", priv->mux_id);\n\t}\n\trcu_read_unlock();\n\treturn count;\n}\n\nstatic ssize_t add_mux_store(struct device *d,  struct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct qmi_wwan_state *info = (void *)&dev->data;\n\tu8 mux_id;\n\tint ret;\n\n\tif (kstrtou8(buf, 0, &mux_id))\n\t\treturn -EINVAL;\n\n\t \n\tif (mux_id < 1 || mux_id > 254)\n\t\treturn -EINVAL;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tif (qmimux_find_dev(dev, mux_id)) {\n\t\tnetdev_err(dev->net, \"mux_id already present\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = qmimux_register_device(dev->net, mux_id);\n\tif (!ret) {\n\t\tinfo->flags |= QMI_WWAN_FLAG_MUX;\n\t\tret = len;\n\t}\nerr:\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic ssize_t del_mux_show(struct device *d, struct device_attribute *attr, char *buf)\n{\n\treturn add_mux_show(d, attr, buf);\n}\n\nstatic ssize_t del_mux_store(struct device *d,  struct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct qmi_wwan_state *info = (void *)&dev->data;\n\tstruct net_device *del_dev;\n\tu8 mux_id;\n\tint ret = 0;\n\n\tif (kstrtou8(buf, 0, &mux_id))\n\t\treturn -EINVAL;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tdel_dev = qmimux_find_dev(dev, mux_id);\n\tif (!del_dev) {\n\t\tnetdev_err(dev->net, \"mux_id not present\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tqmimux_unregister_device(del_dev, NULL);\n\n\tif (!qmimux_has_slaves(dev))\n\t\tinfo->flags &= ~QMI_WWAN_FLAG_MUX;\n\tret = len;\nerr:\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic ssize_t pass_through_show(struct device *d,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct qmi_wwan_state *info;\n\n\tinfo = (void *)&dev->data;\n\treturn sprintf(buf, \"%c\\n\",\n\t\t       info->flags & QMI_WWAN_FLAG_PASS_THROUGH ? 'Y' : 'N');\n}\n\nstatic ssize_t pass_through_store(struct device *d,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t len)\n{\n\tstruct usbnet *dev = netdev_priv(to_net_dev(d));\n\tstruct qmi_wwan_state *info;\n\tbool enable;\n\n\tif (kstrtobool(buf, &enable))\n\t\treturn -EINVAL;\n\n\tinfo = (void *)&dev->data;\n\n\t \n\tif (enable == (info->flags & QMI_WWAN_FLAG_PASS_THROUGH))\n\t\treturn len;\n\n\t \n\tif (!(info->flags & QMI_WWAN_FLAG_RAWIP)) {\n\t\tnetdev_err(dev->net,\n\t\t\t   \"Cannot set pass through mode on non ip device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (enable)\n\t\tinfo->flags |= QMI_WWAN_FLAG_PASS_THROUGH;\n\telse\n\t\tinfo->flags &= ~QMI_WWAN_FLAG_PASS_THROUGH;\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RW(raw_ip);\nstatic DEVICE_ATTR_RW(add_mux);\nstatic DEVICE_ATTR_RW(del_mux);\nstatic DEVICE_ATTR_RW(pass_through);\n\nstatic struct attribute *qmi_wwan_sysfs_attrs[] = {\n\t&dev_attr_raw_ip.attr,\n\t&dev_attr_add_mux.attr,\n\t&dev_attr_del_mux.attr,\n\t&dev_attr_pass_through.attr,\n\tNULL,\n};\n\nstatic struct attribute_group qmi_wwan_sysfs_attr_group = {\n\t.name = \"qmi\",\n\t.attrs = qmi_wwan_sysfs_attrs,\n};\n\n \nstatic const u8 default_modem_addr[ETH_ALEN] = {0x02, 0x50, 0xf3};\n\nstatic const u8 buggy_fw_addr[ETH_ALEN] = {0x00, 0xa0, 0xc6, 0x00, 0x00, 0x00};\n\n \nstatic int qmi_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct qmi_wwan_state *info = (void *)&dev->data;\n\tbool rawip = info->flags & QMI_WWAN_FLAG_RAWIP;\n\t__be16 proto;\n\n\t \n\tif (skb->len < dev->net->hard_header_len)\n\t\treturn 0;\n\n\tif (info->flags & QMI_WWAN_FLAG_MUX)\n\t\treturn qmimux_rx_fixup(dev, skb);\n\n\tif (info->flags & QMI_WWAN_FLAG_PASS_THROUGH) {\n\t\tskb->protocol = htons(ETH_P_MAP);\n\t\treturn 1;\n\t}\n\n\tswitch (skb->data[0] & 0xf0) {\n\tcase 0x40:\n\t\tproto = htons(ETH_P_IP);\n\t\tbreak;\n\tcase 0x60:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tbreak;\n\tcase 0x00:\n\t\tif (rawip)\n\t\t\treturn 0;\n\t\tif (is_multicast_ether_addr(skb->data))\n\t\t\treturn 1;\n\t\t \n\t\tskb_reset_mac_header(skb);\n\t\tgoto fix_dest;\n\tdefault:\n\t\tif (rawip)\n\t\t\treturn 0;\n\t\t \n\t\treturn 1;\n\t}\n\tif (rawip) {\n\t\tskb_reset_mac_header(skb);\n\t\tskb->dev = dev->net;  \n\t\tskb->protocol = proto;\n\t\treturn 1;\n\t}\n\n\tif (skb_headroom(skb) < ETH_HLEN)\n\t\treturn 0;\n\tskb_push(skb, ETH_HLEN);\n\tskb_reset_mac_header(skb);\n\teth_hdr(skb)->h_proto = proto;\n\teth_zero_addr(eth_hdr(skb)->h_source);\nfix_dest:\n\tmemcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);\n\treturn 1;\n}\n\n \nstatic bool possibly_iphdr(const char *data)\n{\n\treturn (data[0] & 0xd0) == 0x40;\n}\n\n \nstatic int qmi_wwan_mac_addr(struct net_device *dev, void *p)\n{\n\tint ret;\n\tstruct sockaddr *addr = p;\n\n\tret = eth_prepare_mac_addr_change(dev, p);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (possibly_iphdr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\teth_commit_mac_addr_change(dev, p);\n\treturn 0;\n}\n\nstatic const struct net_device_ops qmi_wwan_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_change_mtu\t\t= usbnet_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_set_mac_address\t= qmi_wwan_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n \nstatic int qmi_wwan_manage_power(struct usbnet *dev, int on)\n{\n\tstruct qmi_wwan_state *info = (void *)&dev->data;\n\tint rv;\n\n\tdev_dbg(&dev->intf->dev, \"%s() pmcount=%d, on=%d\\n\", __func__,\n\t\tatomic_read(&info->pmcount), on);\n\n\tif ((on && atomic_add_return(1, &info->pmcount) == 1) ||\n\t    (!on && atomic_dec_and_test(&info->pmcount))) {\n\t\t \n\t\trv = usb_autopm_get_interface(dev->intf);\n\t\tdev->intf->needs_remote_wakeup = on;\n\t\tif (!rv)\n\t\t\tusb_autopm_put_interface(dev->intf);\n\t}\n\treturn 0;\n}\n\nstatic int qmi_wwan_cdc_wdm_manage_power(struct usb_interface *intf, int on)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\n\t \n\tif (!dev)\n\t\treturn 0;\n\treturn qmi_wwan_manage_power(dev, on);\n}\n\n \nstatic int qmi_wwan_register_subdriver(struct usbnet *dev)\n{\n\tint rv;\n\tstruct usb_driver *subdriver = NULL;\n\tstruct qmi_wwan_state *info = (void *)&dev->data;\n\n\t \n\trv = usbnet_get_endpoints(dev, info->data);\n\tif (rv < 0)\n\t\tgoto err;\n\n\t \n\tif (info->control != info->data)\n\t\tdev->status = &info->control->cur_altsetting->endpoint[0];\n\n\t \n\tif (!dev->status) {\n\t\trv = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tatomic_set(&info->pmcount, 0);\n\n\t \n\tsubdriver = usb_cdc_wdm_register(info->control, &dev->status->desc,\n\t\t\t\t\t 4096, WWAN_PORT_QMI,\n\t\t\t\t\t &qmi_wwan_cdc_wdm_manage_power);\n\tif (IS_ERR(subdriver)) {\n\t\tdev_err(&info->control->dev, \"subdriver registration failed\\n\");\n\t\trv = PTR_ERR(subdriver);\n\t\tgoto err;\n\t}\n\n\t \n\tdev->status = NULL;\n\n\t \n\tinfo->subdriver = subdriver;\n\nerr:\n\treturn rv;\n}\n\n \nstatic int qmi_wwan_change_dtr(struct usbnet *dev, bool on)\n{\n\tu8 intf = dev->intf->cur_altsetting->desc.bInterfaceNumber;\n\n\treturn usbnet_write_cmd(dev, USB_CDC_REQ_SET_CONTROL_LINE_STATE,\n\t\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t\ton ? 0x01 : 0x00, intf, NULL, 0);\n}\n\nstatic int qmi_wwan_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint status;\n\tu8 *buf = intf->cur_altsetting->extra;\n\tint len = intf->cur_altsetting->extralen;\n\tstruct usb_interface_descriptor *desc = &intf->cur_altsetting->desc;\n\tstruct usb_cdc_union_desc *cdc_union;\n\tstruct usb_cdc_ether_desc *cdc_ether;\n\tstruct usb_driver *driver = driver_of(intf);\n\tstruct qmi_wwan_state *info = (void *)&dev->data;\n\tstruct usb_cdc_parsed_header hdr;\n\n\tBUILD_BUG_ON((sizeof(((struct usbnet *)0)->data) <\n\t\t      sizeof(struct qmi_wwan_state)));\n\n\t \n\tinfo->control = intf;\n\tinfo->data = intf;\n\n\t \n\tcdc_parse_cdc_header(&hdr, intf, buf, len);\n\tcdc_union = hdr.usb_cdc_union_desc;\n\tcdc_ether = hdr.usb_cdc_ether_desc;\n\n\t \n\tif (cdc_union) {\n\t\tinfo->data = usb_ifnum_to_if(dev->udev,\n\t\t\t\t\t     cdc_union->bSlaveInterface0);\n\t\tif (desc->bInterfaceNumber != cdc_union->bMasterInterface0 ||\n\t\t    !info->data) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"bogus CDC Union: master=%u, slave=%u\\n\",\n\t\t\t\tcdc_union->bMasterInterface0,\n\t\t\t\tcdc_union->bSlaveInterface0);\n\n\t\t\t \n\t\t\tcdc_union = NULL;\n\t\t\tinfo->data = intf;\n\t\t}\n\t}\n\n\t \n\tif (cdc_ether && cdc_ether->wMaxSegmentSize) {\n\t\tdev->hard_mtu = le16_to_cpu(cdc_ether->wMaxSegmentSize);\n\t\tusbnet_get_ethernet_addr(dev, cdc_ether->iMACAddress);\n\t}\n\n\t \n\tif (info->control != info->data) {\n\t\tstatus = usb_driver_claim_interface(driver, info->data, dev);\n\t\tif (status < 0)\n\t\t\tgoto err;\n\t}\n\n\tstatus = qmi_wwan_register_subdriver(dev);\n\tif (status < 0 && info->control != info->data) {\n\t\tusb_set_intfdata(info->data, NULL);\n\t\tusb_driver_release_interface(driver, info->data);\n\t}\n\n\t \n\tif (dev->driver_info->data & QMI_WWAN_QUIRK_DTR ||\n\t    le16_to_cpu(dev->udev->descriptor.bcdUSB) >= 0x0201) {\n\t\tqmi_wwan_manage_power(dev, 1);\n\t\tqmi_wwan_change_dtr(dev, true);\n\t}\n\n\t \n\tif (ether_addr_equal(dev->net->dev_addr, default_modem_addr) ||\n\t    ether_addr_equal(dev->net->dev_addr, buggy_fw_addr))\n\t\teth_hw_addr_random(dev->net);\n\n\t \n\tif (possibly_iphdr(dev->net->dev_addr)) {\n\t\tu8 addr = dev->net->dev_addr[0];\n\n\t\taddr |= 0x02;\t \n\t\taddr &= 0xbf;\t \n\t\tdev_addr_mod(dev->net, 0, &addr, 1);\n\t}\n\tdev->net->netdev_ops = &qmi_wwan_netdev_ops;\n\tdev->net->sysfs_groups[0] = &qmi_wwan_sysfs_attr_group;\nerr:\n\treturn status;\n}\n\nstatic void qmi_wwan_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct qmi_wwan_state *info = (void *)&dev->data;\n\tstruct usb_driver *driver = driver_of(intf);\n\tstruct usb_interface *other;\n\n\tif (info->subdriver && info->subdriver->disconnect)\n\t\tinfo->subdriver->disconnect(info->control);\n\n\t \n\tif (le16_to_cpu(dev->udev->descriptor.bcdUSB) >= 0x0201) {\n\t\tqmi_wwan_change_dtr(dev, false);\n\t\tqmi_wwan_manage_power(dev, 0);\n\t}\n\n\t \n\tif (intf == info->control)\n\t\tother = info->data;\n\telse\n\t\tother = info->control;\n\n\t \n\tif (other && intf != other) {\n\t\tusb_set_intfdata(other, NULL);\n\t\tusb_driver_release_interface(driver, other);\n\t}\n\n\tinfo->subdriver = NULL;\n\tinfo->data = NULL;\n\tinfo->control = NULL;\n}\n\n \nstatic int qmi_wwan_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct qmi_wwan_state *info = (void *)&dev->data;\n\tint ret;\n\n\t \n\tret = usbnet_suspend(intf, message);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (intf == info->control && info->subdriver &&\n\t    info->subdriver->suspend)\n\t\tret = info->subdriver->suspend(intf, message);\n\tif (ret < 0)\n\t\tusbnet_resume(intf);\nerr:\n\treturn ret;\n}\n\nstatic int qmi_wwan_resume(struct usb_interface *intf)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct qmi_wwan_state *info = (void *)&dev->data;\n\tint ret = 0;\n\tbool callsub = (intf == info->control && info->subdriver &&\n\t\t\tinfo->subdriver->resume);\n\n\tif (callsub)\n\t\tret = info->subdriver->resume(intf);\n\tif (ret < 0)\n\t\tgoto err;\n\tret = usbnet_resume(intf);\n\tif (ret < 0 && callsub)\n\t\tinfo->subdriver->suspend(intf, PMSG_SUSPEND);\nerr:\n\treturn ret;\n}\n\nstatic const struct driver_info\tqmi_wwan_info = {\n\t.description\t= \"WWAN/QMI device\",\n\t.flags\t\t= FLAG_WWAN | FLAG_SEND_ZLP,\n\t.bind\t\t= qmi_wwan_bind,\n\t.unbind\t\t= qmi_wwan_unbind,\n\t.manage_power\t= qmi_wwan_manage_power,\n\t.rx_fixup       = qmi_wwan_rx_fixup,\n};\n\nstatic const struct driver_info\tqmi_wwan_info_quirk_dtr = {\n\t.description\t= \"WWAN/QMI device\",\n\t.flags\t\t= FLAG_WWAN | FLAG_SEND_ZLP,\n\t.bind\t\t= qmi_wwan_bind,\n\t.unbind\t\t= qmi_wwan_unbind,\n\t.manage_power\t= qmi_wwan_manage_power,\n\t.rx_fixup       = qmi_wwan_rx_fixup,\n\t.data           = QMI_WWAN_QUIRK_DTR,\n};\n\n#define HUAWEI_VENDOR_ID\t0x12D1\n\n \n#define QMI_FIXED_INTF(vend, prod, num) \\\n\tUSB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \\\n\t.driver_info = (unsigned long)&qmi_wwan_info\n\n \n#define QMI_QUIRK_SET_DTR(vend, prod, num) \\\n\tUSB_DEVICE_INTERFACE_NUMBER(vend, prod, num), \\\n\t.driver_info = (unsigned long)&qmi_wwan_info_quirk_dtr\n\n \n#define QMI_GOBI1K_DEVICE(vend, prod) \\\n\tQMI_FIXED_INTF(vend, prod, 3)\n\n \n#define QMI_GOBI_DEVICE(vend, prod) \\\n\tQMI_FIXED_INTF(vend, prod, 0)\n\n \n#define QMI_MATCH_FF_FF_FF(vend, prod) \\\n\tUSB_DEVICE_AND_INTERFACE_INFO(vend, prod, USB_CLASS_VENDOR_SPEC, \\\n\t\t\t\t      USB_SUBCLASS_VENDOR_SPEC, 0xff), \\\n\t.driver_info = (unsigned long)&qmi_wwan_info_quirk_dtr\n\nstatic const struct usb_device_id products[] = {\n\t \n\t{\t \n\t\tUSB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 1, 9),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 1, 57),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 0x01, 0x69),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_VENDOR_AND_INTERFACE_INFO(0x22b8, USB_CLASS_VENDOR_SPEC, 0xfb, 0xff),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\n\t \n\t{\t \n\t\tUSB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 1, 7),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 1, 17),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 0x01, 0x37),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 0x01, 0x67),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_VENDOR_AND_INTERFACE_INFO(0x106c, USB_CLASS_VENDOR_SPEC, 0xf0, 0xff),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_VENDOR_AND_INTERFACE_INFO(0x106c, USB_CLASS_VENDOR_SPEC, 0xf1, 0xff),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x1410, 0xb001,\n\t\t                              USB_CLASS_COMM,\n\t\t                              USB_CDC_SUBCLASS_ETHERNET,\n\t\t                              USB_CDC_PROTO_NONE),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x1410, 0x9010,\n\t\t                              USB_CLASS_COMM,\n\t\t                              USB_CDC_SUBCLASS_ETHERNET,\n\t\t                              USB_CDC_PROTO_NONE),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x1410, 0x9011,\n\t\t                              USB_CLASS_COMM,\n\t\t                              USB_CDC_SUBCLASS_ETHERNET,\n\t\t                              USB_CDC_PROTO_NONE),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x413C, 0x8195,\n\t\t\t\t\t      USB_CLASS_COMM,\n\t\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t\t      USB_CDC_PROTO_NONE),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x413C, 0x8196,\n\t\t\t\t\t      USB_CLASS_COMM,\n\t\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t\t      USB_CDC_PROTO_NONE),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x413C, 0x819b,\n\t\t\t\t\t      USB_CLASS_COMM,\n\t\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t\t      USB_CDC_PROTO_NONE),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x16d5, 0x650a,\n\t\t\t\t\t      USB_CLASS_COMM,\n\t\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t\t      USB_CDC_PROTO_NONE),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x03f0, 0x421d,\n\t\t\t\t\t      USB_CLASS_COMM,\n\t\t\t\t\t      USB_CDC_SUBCLASS_ETHERNET,\n\t\t\t\t\t      USB_CDC_PROTO_NONE),\n\t\t.driver_info        = (unsigned long)&qmi_wwan_info,\n\t},\n\t{\t \n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x03f0, 0x581d, USB_CLASS_VENDOR_SPEC, 1, 7),\n\t\t.driver_info = (unsigned long)&qmi_wwan_info,\n\t},\n\t{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0125)},\t \n\t{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0306)},\t \n\t{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0512)},\t \n\t{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0620)},\t \n\t{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0800)},\t \n\t{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0801)},\t \n\n\t \n\t{QMI_FIXED_INTF(0x0408, 0xea42, 4)},\t \n\t{QMI_FIXED_INTF(0x05c6, 0x6001, 3)},\t \n\t{QMI_FIXED_INTF(0x05c6, 0x7000, 0)},\n\t{QMI_FIXED_INTF(0x05c6, 0x7001, 1)},\n\t{QMI_FIXED_INTF(0x05c6, 0x7002, 1)},\n\t{QMI_FIXED_INTF(0x05c6, 0x7101, 1)},\n\t{QMI_FIXED_INTF(0x05c6, 0x7101, 2)},\n\t{QMI_FIXED_INTF(0x05c6, 0x7101, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x7102, 1)},\n\t{QMI_FIXED_INTF(0x05c6, 0x7102, 2)},\n\t{QMI_FIXED_INTF(0x05c6, 0x7102, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x8000, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x8001, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9000, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9003, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9005, 2)},\n\t{QMI_FIXED_INTF(0x05c6, 0x900a, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x900b, 2)},\n\t{QMI_FIXED_INTF(0x05c6, 0x900c, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x900c, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x900c, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x900d, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x900f, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x900f, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x900f, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9010, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9010, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9011, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9011, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9021, 1)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9022, 2)},\n\t{QMI_QUIRK_SET_DTR(0x05c6, 0x9025, 4)},\t \n\t{QMI_FIXED_INTF(0x05c6, 0x9026, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x902e, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9031, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9032, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9033, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9033, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9033, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9033, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9034, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9034, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9034, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9034, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9034, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9035, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9036, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9037, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9038, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x903b, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x903c, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x903d, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x903e, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9043, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9046, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9046, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9046, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9047, 2)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9047, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9047, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9048, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9048, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9048, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9048, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9048, 8)},\n\t{QMI_FIXED_INTF(0x05c6, 0x904c, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x904c, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x904c, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x904c, 8)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9050, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9052, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9053, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9053, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9054, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9054, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9055, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9055, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9055, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9055, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9055, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9056, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9062, 2)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9062, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9062, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9062, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9062, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9062, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9062, 8)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9062, 9)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9064, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9065, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9065, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9066, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9066, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9067, 1)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9068, 2)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9068, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9068, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9068, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9068, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9068, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9069, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9069, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9069, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9069, 8)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9070, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9070, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9075, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9076, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9076, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9076, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9076, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9076, 8)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9077, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9077, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9077, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9077, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9078, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9079, 4)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9079, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9079, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9079, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9079, 8)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9080, 5)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9080, 6)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9080, 7)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9080, 8)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9083, 3)},\n\t{QMI_FIXED_INTF(0x05c6, 0x9084, 4)},\n\t{QMI_QUIRK_SET_DTR(0x05c6, 0x9091, 2)},\t \n\t{QMI_FIXED_INTF(0x05c6, 0x90b2, 3)},     \n\t{QMI_QUIRK_SET_DTR(0x05c6, 0x90db, 2)},\t \n\t{QMI_FIXED_INTF(0x05c6, 0x920d, 0)},\n\t{QMI_FIXED_INTF(0x05c6, 0x920d, 5)},\n\t{QMI_QUIRK_SET_DTR(0x05c6, 0x9625, 4)},\t \n\t{QMI_FIXED_INTF(0x0846, 0x68a2, 8)},\n\t{QMI_FIXED_INTF(0x0846, 0x68d3, 8)},\t \n\t{QMI_FIXED_INTF(0x12d1, 0x140c, 1)},\t \n\t{QMI_FIXED_INTF(0x12d1, 0x14ac, 1)},\t \n\t{QMI_FIXED_INTF(0x1435, 0x0918, 3)},\t \n\t{QMI_FIXED_INTF(0x1435, 0x0918, 4)},\t \n\t{QMI_FIXED_INTF(0x1435, 0x0918, 5)},\t \n\t{QMI_FIXED_INTF(0x1435, 0x3185, 4)},\t \n\t{QMI_FIXED_INTF(0x1435, 0xd111, 4)},\t \n\t{QMI_FIXED_INTF(0x1435, 0xd181, 3)},\t \n\t{QMI_FIXED_INTF(0x1435, 0xd181, 4)},\t \n\t{QMI_FIXED_INTF(0x1435, 0xd181, 5)},\t \n\t{QMI_FIXED_INTF(0x1435, 0xd182, 4)},\t \n\t{QMI_FIXED_INTF(0x1435, 0xd182, 5)},\t \n\t{QMI_FIXED_INTF(0x1435, 0xd191, 4)},\t \n\t{QMI_QUIRK_SET_DTR(0x1508, 0x1001, 4)},\t \n\t{QMI_FIXED_INTF(0x1690, 0x7588, 4)},     \n\t{QMI_FIXED_INTF(0x16d8, 0x6003, 0)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x6007, 0)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x6008, 0)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x6280, 0)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x7001, 0)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x7002, 0)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x7003, 4)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x7004, 3)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x7006, 5)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x700a, 4)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x7211, 0)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x7212, 0)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x7213, 0)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x7251, 1)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x7252, 1)},\t \n\t{QMI_FIXED_INTF(0x16d8, 0x7253, 1)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0002, 1)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0012, 1)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0017, 3)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0019, 3)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0021, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0025, 1)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0031, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0042, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0049, 5)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0052, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0055, 1)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0058, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0063, 4)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0104, 4)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0113, 5)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0118, 5)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0121, 5)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0123, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0124, 5)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0125, 6)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0126, 5)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0130, 1)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0133, 3)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0141, 5)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0157, 5)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0158, 3)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0167, 4)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0168, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0176, 3)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0178, 3)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0189, 4)},     \n\t{QMI_FIXED_INTF(0x19d2, 0x0191, 4)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0199, 1)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0200, 1)},\n\t{QMI_FIXED_INTF(0x19d2, 0x0257, 3)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0265, 4)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0284, 4)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0326, 4)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0396, 3)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x0412, 4)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x1008, 4)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x1010, 4)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x1012, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x1018, 3)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x1021, 2)},\n\t{QMI_FIXED_INTF(0x19d2, 0x1245, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x1247, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x1252, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x1254, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x1255, 3)},\n\t{QMI_FIXED_INTF(0x19d2, 0x1255, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x1256, 4)},\n\t{QMI_FIXED_INTF(0x19d2, 0x1270, 5)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x1275, 3)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x1401, 2)},\n\t{QMI_FIXED_INTF(0x19d2, 0x1402, 2)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x1424, 2)},\n\t{QMI_FIXED_INTF(0x19d2, 0x1425, 2)},\n\t{QMI_FIXED_INTF(0x19d2, 0x1426, 2)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x1428, 2)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x1432, 3)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x1485, 5)},\t \n\t{QMI_FIXED_INTF(0x19d2, 0x2002, 4)},\t \n\t{QMI_FIXED_INTF(0x2001, 0x7e16, 3)},\t \n\t{QMI_FIXED_INTF(0x2001, 0x7e19, 4)},\t \n\t{QMI_FIXED_INTF(0x2001, 0x7e35, 4)},\t \n\t{QMI_FIXED_INTF(0x2001, 0x7e3d, 4)},\t \n\t{QMI_FIXED_INTF(0x2020, 0x2031, 4)},\t \n\t{QMI_FIXED_INTF(0x2020, 0x2033, 4)},\t \n\t{QMI_QUIRK_SET_DTR(0x2020, 0x2060, 4)},\t \n\t{QMI_FIXED_INTF(0x0f3d, 0x68a2, 8)},     \n\t{QMI_FIXED_INTF(0x114f, 0x68a2, 8)},     \n\t{QMI_FIXED_INTF(0x1199, 0x68a2, 8)},\t \n\t{QMI_FIXED_INTF(0x1199, 0x68a2, 19)},\t \n\t{QMI_QUIRK_SET_DTR(0x1199, 0x68c0, 8)},\t \n\t{QMI_QUIRK_SET_DTR(0x1199, 0x68c0, 10)}, \n\t{QMI_FIXED_INTF(0x1199, 0x901c, 8)},     \n\t{QMI_FIXED_INTF(0x1199, 0x901f, 8)},     \n\t{QMI_FIXED_INTF(0x1199, 0x9041, 8)},\t \n\t{QMI_FIXED_INTF(0x1199, 0x9041, 10)},\t \n\t{QMI_FIXED_INTF(0x1199, 0x9051, 8)},\t \n\t{QMI_FIXED_INTF(0x1199, 0x9053, 8)},\t \n\t{QMI_FIXED_INTF(0x1199, 0x9054, 8)},\t \n\t{QMI_FIXED_INTF(0x1199, 0x9055, 8)},\t \n\t{QMI_FIXED_INTF(0x1199, 0x9056, 8)},\t \n\t{QMI_FIXED_INTF(0x1199, 0x9057, 8)},\n\t{QMI_FIXED_INTF(0x1199, 0x9061, 8)},\t \n\t{QMI_FIXED_INTF(0x1199, 0x9063, 8)},\t \n\t{QMI_FIXED_INTF(0x1199, 0x9063, 10)},\t \n\t{QMI_QUIRK_SET_DTR(0x1199, 0x9071, 8)},\t \n\t{QMI_QUIRK_SET_DTR(0x1199, 0x9071, 10)}, \n\t{QMI_QUIRK_SET_DTR(0x1199, 0x9079, 8)},\t \n\t{QMI_QUIRK_SET_DTR(0x1199, 0x9079, 10)}, \n\t{QMI_QUIRK_SET_DTR(0x1199, 0x907b, 8)},\t \n\t{QMI_QUIRK_SET_DTR(0x1199, 0x907b, 10)}, \n\t{QMI_QUIRK_SET_DTR(0x1199, 0x9091, 8)},\t \n\t{QMI_QUIRK_SET_DTR(0x1199, 0xc081, 8)},\t \n\t{QMI_FIXED_INTF(0x1bbb, 0x011e, 4)},\t \n\t{QMI_FIXED_INTF(0x1bbb, 0x0203, 2)},\t \n\t{QMI_FIXED_INTF(0x2357, 0x0201, 4)},\t \n\t{QMI_FIXED_INTF(0x2357, 0x9000, 4)},\t \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x1031, 3)},  \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x103a, 0)},  \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x1040, 2)},\t \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x1050, 2)},\t \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x1057, 2)},\t \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x1060, 2)},\t \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x1070, 2)},\t \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x1080, 2)},  \n\t{QMI_FIXED_INTF(0x1bc7, 0x1100, 3)},\t \n\t{QMI_FIXED_INTF(0x1bc7, 0x1101, 3)},\t \n\t{QMI_FIXED_INTF(0x1bc7, 0x1200, 5)},\t \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x1201, 2)},\t \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x1230, 2)},\t \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x1250, 0)},\t \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x1260, 2)},\t \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x1261, 2)},\t \n\t{QMI_QUIRK_SET_DTR(0x1bc7, 0x1900, 1)},\t \n\t{QMI_FIXED_INTF(0x1c9e, 0x9801, 3)},\t \n\t{QMI_FIXED_INTF(0x1c9e, 0x9803, 4)},\t \n\t{QMI_FIXED_INTF(0x1c9e, 0x9b01, 3)},\t \n\t{QMI_FIXED_INTF(0x0b3c, 0xc000, 4)},\t \n\t{QMI_FIXED_INTF(0x0b3c, 0xc001, 4)},\t \n\t{QMI_FIXED_INTF(0x0b3c, 0xc002, 4)},\t \n\t{QMI_FIXED_INTF(0x0b3c, 0xc004, 6)},\t \n\t{QMI_FIXED_INTF(0x0b3c, 0xc005, 6)},\t \n\t{QMI_FIXED_INTF(0x0b3c, 0xc00a, 6)},\t \n\t{QMI_FIXED_INTF(0x0b3c, 0xc00b, 4)},\t \n\t{QMI_FIXED_INTF(0x1e2d, 0x0060, 4)},\t \n\t{QMI_QUIRK_SET_DTR(0x1e2d, 0x006f, 8)},  \n\t{QMI_FIXED_INTF(0x1e2d, 0x0053, 4)},\t \n\t{QMI_FIXED_INTF(0x1e2d, 0x0063, 10)},\t \n\t{QMI_FIXED_INTF(0x1e2d, 0x0082, 4)},\t \n\t{QMI_FIXED_INTF(0x1e2d, 0x0082, 5)},\t \n\t{QMI_FIXED_INTF(0x1e2d, 0x0083, 4)},\t \n\t{QMI_QUIRK_SET_DTR(0x1e2d, 0x00b0, 4)},\t \n\t{QMI_FIXED_INTF(0x1e2d, 0x00b7, 0)},\t \n\t{QMI_FIXED_INTF(0x1e2d, 0x00b9, 0)},\t \n\t{QMI_FIXED_INTF(0x1e2d, 0x00f3, 0)},\t \n\t{QMI_FIXED_INTF(0x1e2d, 0x00f4, 0)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81a2, 8)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81a3, 8)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81a4, 8)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81a8, 8)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81a9, 8)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81b1, 8)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81b3, 8)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81b6, 8)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81b6, 10)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81c2, 8)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81cc, 8)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81d7, 0)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81d7, 1)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81e0, 0)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81e4, 0)},\t \n\t{QMI_FIXED_INTF(0x413c, 0x81e6, 0)},\t \n\t{QMI_FIXED_INTF(0x03f0, 0x4e1d, 8)},\t \n\t{QMI_FIXED_INTF(0x03f0, 0x9d1d, 1)},\t \n\t{QMI_QUIRK_SET_DTR(0x22de, 0x9051, 2)},  \n\t{QMI_FIXED_INTF(0x22de, 0x9061, 3)},\t \n\t{QMI_QUIRK_SET_DTR(0x1e0e, 0x9001, 5)},\t \n\t{QMI_QUIRK_SET_DTR(0x2c7c, 0x0121, 4)},\t \n\t{QMI_QUIRK_SET_DTR(0x2c7c, 0x0191, 4)},\t \n\t{QMI_QUIRK_SET_DTR(0x2c7c, 0x0195, 4)},\t \n\t{QMI_FIXED_INTF(0x2c7c, 0x0296, 4)},\t \n\t{QMI_QUIRK_SET_DTR(0x2c7c, 0x030e, 4)},\t \n\t{QMI_QUIRK_SET_DTR(0x2cb7, 0x0104, 4)},\t \n\t{QMI_FIXED_INTF(0x0489, 0xe0b4, 0)},\t \n\t{QMI_FIXED_INTF(0x0489, 0xe0b5, 0)},\t \n\t{QMI_FIXED_INTF(0x2692, 0x9025, 4)},     \n\t{QMI_QUIRK_SET_DTR(0x1546, 0x1312, 4)},\t \n\t{QMI_QUIRK_SET_DTR(0x1546, 0x1342, 4)},\t \n\n\t \n\t{QMI_GOBI1K_DEVICE(0x05c6, 0x9212)},\t \n\t{QMI_GOBI1K_DEVICE(0x03f0, 0x1f1d)},\t \n\t{QMI_GOBI1K_DEVICE(0x04da, 0x250d)},\t \n\t{QMI_GOBI1K_DEVICE(0x413c, 0x8172)},\t \n\t{QMI_GOBI1K_DEVICE(0x1410, 0xa001)},\t \n\t{QMI_GOBI1K_DEVICE(0x1410, 0xa002)},\t \n\t{QMI_GOBI1K_DEVICE(0x1410, 0xa003)},\t \n\t{QMI_GOBI1K_DEVICE(0x1410, 0xa004)},\t \n\t{QMI_GOBI1K_DEVICE(0x1410, 0xa005)},\t \n\t{QMI_GOBI1K_DEVICE(0x1410, 0xa006)},\t \n\t{QMI_GOBI1K_DEVICE(0x1410, 0xa007)},\t \n\t{QMI_GOBI1K_DEVICE(0x0b05, 0x1776)},\t \n\t{QMI_GOBI1K_DEVICE(0x19d2, 0xfff3)},\t \n\t{QMI_GOBI1K_DEVICE(0x05c6, 0x9001)},\t \n\t{QMI_GOBI1K_DEVICE(0x05c6, 0x9002)},\t \n\t{QMI_GOBI1K_DEVICE(0x05c6, 0x9202)},\t \n\t{QMI_GOBI1K_DEVICE(0x05c6, 0x9203)},\t \n\t{QMI_GOBI1K_DEVICE(0x05c6, 0x9222)},\t \n\t{QMI_GOBI1K_DEVICE(0x05c6, 0x9009)},\t \n\n\t \n\t{QMI_GOBI_DEVICE(0x413c, 0x8186)},\t \n\t{QMI_GOBI_DEVICE(0x413c, 0x8194)},\t \n\t{QMI_GOBI_DEVICE(0x05c6, 0x920b)},\t \n\t{QMI_GOBI_DEVICE(0x05c6, 0x9225)},\t \n\t{QMI_GOBI_DEVICE(0x05c6, 0x9245)},\t \n\t{QMI_GOBI_DEVICE(0x03f0, 0x251d)},\t \n\t{QMI_GOBI_DEVICE(0x05c6, 0x9215)},\t \n\t{QMI_FIXED_INTF(0x05c6, 0x9215, 4)},\t \n\t{QMI_GOBI_DEVICE(0x05c6, 0x9265)},\t \n\t{QMI_GOBI_DEVICE(0x05c6, 0x9235)},\t \n\t{QMI_GOBI_DEVICE(0x05c6, 0x9275)},\t \n\t{QMI_GOBI_DEVICE(0x0af0, 0x8120)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x68a5)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x68a9)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x9001)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x9002)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x9003)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x9004)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x9005)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x9006)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x9007)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x9008)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x9009)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x900a)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x9011)},\t \n\t{QMI_GOBI_DEVICE(0x16d8, 0x8002)},\t \n\t{QMI_GOBI_DEVICE(0x05c6, 0x9205)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x9013)},\t \n\t{QMI_GOBI_DEVICE(0x03f0, 0x371d)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x9015)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x9019)},\t \n\t{QMI_GOBI_DEVICE(0x1199, 0x901b)},\t \n\t{QMI_GOBI_DEVICE(0x12d1, 0x14f1)},\t \n\t{QMI_GOBI_DEVICE(0x1410, 0xa021)},\t \n\n\t{ }\t\t\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic bool quectel_ec20_detected(struct usb_interface *intf)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\n\tif (dev->actconfig &&\n\t    le16_to_cpu(dev->descriptor.idVendor) == 0x05c6 &&\n\t    le16_to_cpu(dev->descriptor.idProduct) == 0x9215 &&\n\t    dev->actconfig->desc.bNumInterfaces == 5)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int qmi_wwan_probe(struct usb_interface *intf,\n\t\t\t  const struct usb_device_id *prod)\n{\n\tstruct usb_device_id *id = (struct usb_device_id *)prod;\n\tstruct usb_interface_descriptor *desc = &intf->cur_altsetting->desc;\n\n\t \n\tif (!id->driver_info) {\n\t\tdev_dbg(&intf->dev, \"setting defaults for dynamic device id\\n\");\n\t\tid->driver_info = (unsigned long)&qmi_wwan_info;\n\t}\n\n\t \n\tif (id->match_flags & USB_DEVICE_ID_MATCH_INT_NUMBER &&\n\t    desc->bInterfaceClass != USB_CLASS_VENDOR_SPEC) {\n\t\tdev_dbg(&intf->dev,\n\t\t\t\"Rejecting interface number match for class %02x\\n\",\n\t\t\tdesc->bInterfaceClass);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (quectel_ec20_detected(intf) && desc->bInterfaceNumber == 0) {\n\t\tdev_dbg(&intf->dev, \"Quectel EC20 quirk, skipping interface 0\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (desc->bNumEndpoints == 2)\n\t\treturn -ENODEV;\n\n\treturn usbnet_probe(intf, id);\n}\n\nstatic void qmi_wwan_disconnect(struct usb_interface *intf)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct qmi_wwan_state *info;\n\tstruct list_head *iter;\n\tstruct net_device *ldev;\n\tLIST_HEAD(list);\n\n\t \n\tif (!dev)\n\t\treturn;\n\tinfo = (void *)&dev->data;\n\tif (info->flags & QMI_WWAN_FLAG_MUX) {\n\t\tif (!rtnl_trylock()) {\n\t\t\trestart_syscall();\n\t\t\treturn;\n\t\t}\n\t\trcu_read_lock();\n\t\tnetdev_for_each_upper_dev_rcu(dev->net, ldev, iter)\n\t\t\tqmimux_unregister_device(ldev, &list);\n\t\trcu_read_unlock();\n\t\tunregister_netdevice_many(&list);\n\t\trtnl_unlock();\n\t\tinfo->flags &= ~QMI_WWAN_FLAG_MUX;\n\t}\n\tusbnet_disconnect(intf);\n}\n\nstatic struct usb_driver qmi_wwan_driver = {\n\t.name\t\t      = \"qmi_wwan\",\n\t.id_table\t      = products,\n\t.probe\t\t      = qmi_wwan_probe,\n\t.disconnect\t      = qmi_wwan_disconnect,\n\t.suspend\t      = qmi_wwan_suspend,\n\t.resume\t\t      =\tqmi_wwan_resume,\n\t.reset_resume         = qmi_wwan_resume,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(qmi_wwan_driver);\n\nMODULE_AUTHOR(\"Bj\u00f8rn Mork <bjorn@mork.no>\");\nMODULE_DESCRIPTION(\"Qualcomm MSM Interface (QMI) WWAN driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}