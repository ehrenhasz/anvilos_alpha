{
  "module_name": "smsc95xx.c",
  "hash_id": "76390069fbe8af751c10a24481f9c70803cbeb7ae0087a2bac83bb63e5469c63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/smsc95xx.c",
  "human_readable_source": "\n  \n\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/bitrev.h>\n#include <linux/crc16.h>\n#include <linux/crc32.h>\n#include <linux/usb/usbnet.h>\n#include <linux/slab.h>\n#include <linux/of_net.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/mdio.h>\n#include <linux/phy.h>\n#include <net/selftests.h>\n\n#include \"smsc95xx.h\"\n\n#define SMSC_CHIPNAME\t\t\t\"smsc95xx\"\n#define SMSC_DRIVER_VERSION\t\t\"2.0.0\"\n#define HS_USB_PKT_SIZE\t\t\t(512)\n#define FS_USB_PKT_SIZE\t\t\t(64)\n#define DEFAULT_HS_BURST_CAP_SIZE\t(16 * 1024 + 5 * HS_USB_PKT_SIZE)\n#define DEFAULT_FS_BURST_CAP_SIZE\t(6 * 1024 + 33 * FS_USB_PKT_SIZE)\n#define DEFAULT_BULK_IN_DELAY\t\t(0x00002000)\n#define MAX_SINGLE_PACKET_SIZE\t\t(2048)\n#define LAN95XX_EEPROM_MAGIC\t\t(0x9500)\n#define EEPROM_MAC_OFFSET\t\t(0x01)\n#define DEFAULT_TX_CSUM_ENABLE\t\t(true)\n#define DEFAULT_RX_CSUM_ENABLE\t\t(true)\n#define SMSC95XX_INTERNAL_PHY_ID\t(1)\n#define SMSC95XX_TX_OVERHEAD\t\t(8)\n#define SMSC95XX_TX_OVERHEAD_CSUM\t(12)\n#define SUPPORTED_WAKE\t\t\t(WAKE_PHY | WAKE_UCAST | WAKE_BCAST | \\\n\t\t\t\t\t WAKE_MCAST | WAKE_ARP | WAKE_MAGIC)\n\n#define FEATURE_8_WAKEUP_FILTERS\t(0x01)\n#define FEATURE_PHY_NLP_CROSSOVER\t(0x02)\n#define FEATURE_REMOTE_WAKEUP\t\t(0x04)\n\n#define SUSPEND_SUSPEND0\t\t(0x01)\n#define SUSPEND_SUSPEND1\t\t(0x02)\n#define SUSPEND_SUSPEND2\t\t(0x04)\n#define SUSPEND_SUSPEND3\t\t(0x08)\n#define SUSPEND_ALLMODES\t\t(SUSPEND_SUSPEND0 | SUSPEND_SUSPEND1 | \\\n\t\t\t\t\t SUSPEND_SUSPEND2 | SUSPEND_SUSPEND3)\n\n#define SMSC95XX_NR_IRQS\t\t(1)  \n#define PHY_HWIRQ\t\t\t(SMSC95XX_NR_IRQS - 1)\n\nstruct smsc95xx_priv {\n\tu32 mac_cr;\n\tu32 hash_hi;\n\tu32 hash_lo;\n\tu32 wolopts;\n\tspinlock_t mac_cr_lock;\n\tu8 features;\n\tu8 suspend_flags;\n\tbool is_internal_phy;\n\tstruct irq_chip irqchip;\n\tstruct irq_domain *irqdomain;\n\tstruct fwnode_handle *irqfwnode;\n\tstruct mii_bus *mdiobus;\n\tstruct phy_device *phydev;\n\tstruct task_struct *pm_task;\n};\n\nstatic bool turbo_mode = true;\nmodule_param(turbo_mode, bool, 0644);\nMODULE_PARM_DESC(turbo_mode, \"Enable multiple frames per Rx transaction\");\n\nstatic int __must_check smsc95xx_read_reg(struct usbnet *dev, u32 index,\n\t\t\t\t\t  u32 *data)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tu32 buf;\n\tint ret;\n\tint (*fn)(struct usbnet *, u8, u8, u16, u16, void *, u16);\n\n\tif (current != pdata->pm_task)\n\t\tfn = usbnet_read_cmd;\n\telse\n\t\tfn = usbnet_read_cmd_nopm;\n\n\tret = fn(dev, USB_VENDOR_REQUEST_READ_REGISTER, USB_DIR_IN\n\t\t | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t 0, index, &buf, 4);\n\tif (ret < 4) {\n\t\tret = ret < 0 ? ret : -ENODATA;\n\n\t\tif (ret != -ENODEV)\n\t\t\tnetdev_warn(dev->net, \"Failed to read reg index 0x%08x: %d\\n\",\n\t\t\t\t    index, ret);\n\t\treturn ret;\n\t}\n\n\tle32_to_cpus(&buf);\n\t*data = buf;\n\n\treturn ret;\n}\n\nstatic int __must_check smsc95xx_write_reg(struct usbnet *dev, u32 index,\n\t\t\t\t\t   u32 data)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tu32 buf;\n\tint ret;\n\tint (*fn)(struct usbnet *, u8, u8, u16, u16, const void *, u16);\n\n\tif (current != pdata->pm_task)\n\t\tfn = usbnet_write_cmd;\n\telse\n\t\tfn = usbnet_write_cmd_nopm;\n\n\tbuf = data;\n\tcpu_to_le32s(&buf);\n\n\tret = fn(dev, USB_VENDOR_REQUEST_WRITE_REGISTER, USB_DIR_OUT\n\t\t | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t 0, index, &buf, 4);\n\tif (ret < 0 && ret != -ENODEV)\n\t\tnetdev_warn(dev->net, \"Failed to write reg index 0x%08x: %d\\n\",\n\t\t\t    index, ret);\n\n\treturn ret;\n}\n\n \nstatic int __must_check smsc95xx_phy_wait_not_busy(struct usbnet *dev)\n{\n\tunsigned long start_time = jiffies;\n\tu32 val;\n\tint ret;\n\n\tdo {\n\t\tret = smsc95xx_read_reg(dev, MII_ADDR, &val);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tif (ret == -ENODEV)\n\t\t\t\treturn 0;\n\t\t\tnetdev_warn(dev->net, \"Error reading MII_ACCESS\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(val & MII_BUSY_))\n\t\t\treturn 0;\n\t} while (!time_after(jiffies, start_time + HZ));\n\n\treturn -EIO;\n}\n\nstatic u32 mii_address_cmd(int phy_id, int idx, u16 op)\n{\n\treturn (phy_id & 0x1f) << 11 | (idx & 0x1f) << 6 | op;\n}\n\nstatic int smsc95xx_mdio_read(struct usbnet *dev, int phy_id, int idx)\n{\n\tu32 val, addr;\n\tint ret;\n\n\tmutex_lock(&dev->phy_mutex);\n\n\t \n\tret = smsc95xx_phy_wait_not_busy(dev);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"%s: MII is busy\\n\", __func__);\n\t\tgoto done;\n\t}\n\n\t \n\taddr = mii_address_cmd(phy_id, idx, MII_READ_ | MII_BUSY_);\n\tret = smsc95xx_write_reg(dev, MII_ADDR, addr);\n\tif (ret < 0) {\n\t\tif (ret != -ENODEV)\n\t\t\tnetdev_warn(dev->net, \"Error writing MII_ADDR\\n\");\n\t\tgoto done;\n\t}\n\n\tret = smsc95xx_phy_wait_not_busy(dev);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Timed out reading MII reg %02X\\n\", idx);\n\t\tgoto done;\n\t}\n\n\tret = smsc95xx_read_reg(dev, MII_DATA, &val);\n\tif (ret < 0) {\n\t\tif (ret != -ENODEV)\n\t\t\tnetdev_warn(dev->net, \"Error reading MII_DATA\\n\");\n\t\tgoto done;\n\t}\n\n\tret = (u16)(val & 0xFFFF);\n\ndone:\n\tmutex_unlock(&dev->phy_mutex);\n\n\t \n\tif (ret == -ENODEV)\n\t\treturn 0;\n\treturn ret;\n}\n\nstatic void smsc95xx_mdio_write(struct usbnet *dev, int phy_id, int idx,\n\t\t\t\tint regval)\n{\n\tu32 val, addr;\n\tint ret;\n\n\tmutex_lock(&dev->phy_mutex);\n\n\t \n\tret = smsc95xx_phy_wait_not_busy(dev);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"%s: MII is busy\\n\", __func__);\n\t\tgoto done;\n\t}\n\n\tval = regval;\n\tret = smsc95xx_write_reg(dev, MII_DATA, val);\n\tif (ret < 0) {\n\t\tif (ret != -ENODEV)\n\t\t\tnetdev_warn(dev->net, \"Error writing MII_DATA\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\taddr = mii_address_cmd(phy_id, idx, MII_WRITE_ | MII_BUSY_);\n\tret = smsc95xx_write_reg(dev, MII_ADDR, addr);\n\tif (ret < 0) {\n\t\tif (ret != -ENODEV)\n\t\t\tnetdev_warn(dev->net, \"Error writing MII_ADDR\\n\");\n\t\tgoto done;\n\t}\n\n\tret = smsc95xx_phy_wait_not_busy(dev);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Timed out writing MII reg %02X\\n\", idx);\n\t\tgoto done;\n\t}\n\ndone:\n\tmutex_unlock(&dev->phy_mutex);\n}\n\nstatic int smsc95xx_mdiobus_reset(struct mii_bus *bus)\n{\n\tstruct smsc95xx_priv *pdata;\n\tstruct usbnet *dev;\n\tu32 val;\n\tint ret;\n\n\tdev = bus->priv;\n\tpdata = dev->driver_priv;\n\n\tif (pdata->is_internal_phy)\n\t\treturn 0;\n\n\tmutex_lock(&dev->phy_mutex);\n\n\tret = smsc95xx_read_reg(dev, PM_CTRL, &val);\n\tif (ret < 0)\n\t\tgoto reset_out;\n\n\tval |= PM_CTL_PHY_RST_;\n\n\tret = smsc95xx_write_reg(dev, PM_CTRL, val);\n\tif (ret < 0)\n\t\tgoto reset_out;\n\n\t \n\tfsleep(500000);\n\nreset_out:\n\tmutex_unlock(&dev->phy_mutex);\n\n\treturn 0;\n}\n\nstatic int smsc95xx_mdiobus_read(struct mii_bus *bus, int phy_id, int idx)\n{\n\tstruct usbnet *dev = bus->priv;\n\n\treturn smsc95xx_mdio_read(dev, phy_id, idx);\n}\n\nstatic int smsc95xx_mdiobus_write(struct mii_bus *bus, int phy_id, int idx,\n\t\t\t\t  u16 regval)\n{\n\tstruct usbnet *dev = bus->priv;\n\n\tsmsc95xx_mdio_write(dev, phy_id, idx, regval);\n\treturn 0;\n}\n\nstatic int __must_check smsc95xx_wait_eeprom(struct usbnet *dev)\n{\n\tunsigned long start_time = jiffies;\n\tu32 val;\n\tint ret;\n\n\tdo {\n\t\tret = smsc95xx_read_reg(dev, E2P_CMD, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading E2P_CMD\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(val & E2P_CMD_BUSY_) || (val & E2P_CMD_TIMEOUT_))\n\t\t\tbreak;\n\t\tudelay(40);\n\t} while (!time_after(jiffies, start_time + HZ));\n\n\tif (val & (E2P_CMD_TIMEOUT_ | E2P_CMD_BUSY_)) {\n\t\tnetdev_warn(dev->net, \"EEPROM read operation timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int __must_check smsc95xx_eeprom_confirm_not_busy(struct usbnet *dev)\n{\n\tunsigned long start_time = jiffies;\n\tu32 val;\n\tint ret;\n\n\tdo {\n\t\tret = smsc95xx_read_reg(dev, E2P_CMD, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading E2P_CMD\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(val & E2P_CMD_BUSY_))\n\t\t\treturn 0;\n\n\t\tudelay(40);\n\t} while (!time_after(jiffies, start_time + HZ));\n\n\tnetdev_warn(dev->net, \"EEPROM is busy\\n\");\n\treturn -EIO;\n}\n\nstatic int smsc95xx_read_eeprom(struct usbnet *dev, u32 offset, u32 length,\n\t\t\t\tu8 *data)\n{\n\tu32 val;\n\tint i, ret;\n\n\tBUG_ON(!dev);\n\tBUG_ON(!data);\n\n\tret = smsc95xx_eeprom_confirm_not_busy(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < length; i++) {\n\t\tval = E2P_CMD_BUSY_ | E2P_CMD_READ_ | (offset & E2P_CMD_ADDR_);\n\t\tret = smsc95xx_write_reg(dev, E2P_CMD, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing E2P_CMD\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = smsc95xx_wait_eeprom(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = smsc95xx_read_reg(dev, E2P_DATA, &val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error reading E2P_DATA\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata[i] = val & 0xFF;\n\t\toffset++;\n\t}\n\n\treturn 0;\n}\n\nstatic int smsc95xx_write_eeprom(struct usbnet *dev, u32 offset, u32 length,\n\t\t\t\t u8 *data)\n{\n\tu32 val;\n\tint i, ret;\n\n\tBUG_ON(!dev);\n\tBUG_ON(!data);\n\n\tret = smsc95xx_eeprom_confirm_not_busy(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = E2P_CMD_BUSY_ | E2P_CMD_EWEN_;\n\tret = smsc95xx_write_reg(dev, E2P_CMD, val);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Error writing E2P_DATA\\n\");\n\t\treturn ret;\n\t}\n\n\tret = smsc95xx_wait_eeprom(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < length; i++) {\n\n\t\t \n\t\tval = data[i];\n\t\tret = smsc95xx_write_reg(dev, E2P_DATA, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing E2P_DATA\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tval = E2P_CMD_BUSY_ | E2P_CMD_WRITE_ | (offset & E2P_CMD_ADDR_);\n\t\tret = smsc95xx_write_reg(dev, E2P_CMD, val);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(dev->net, \"Error writing E2P_CMD\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = smsc95xx_wait_eeprom(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\toffset++;\n\t}\n\n\treturn 0;\n}\n\nstatic int __must_check smsc95xx_write_reg_async(struct usbnet *dev, u16 index,\n\t\t\t\t\t\t u32 data)\n{\n\tconst u16 size = 4;\n\tu32 buf;\n\tint ret;\n\n\tbuf = data;\n\tcpu_to_le32s(&buf);\n\n\tret = usbnet_write_cmd_async(dev, USB_VENDOR_REQUEST_WRITE_REGISTER,\n\t\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t     USB_RECIP_DEVICE,\n\t\t\t\t     0, index, &buf, size);\n\tif (ret < 0)\n\t\tnetdev_warn(dev->net, \"Error write async cmd, sts=%d\\n\",\n\t\t\t    ret);\n\treturn ret;\n}\n\n \nstatic unsigned int smsc95xx_hash(char addr[ETH_ALEN])\n{\n\treturn (ether_crc(ETH_ALEN, addr) >> 26) & 0x3f;\n}\n\nstatic void smsc95xx_set_multicast(struct net_device *netdev)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tunsigned long flags;\n\tint ret;\n\n\tpdata->hash_hi = 0;\n\tpdata->hash_lo = 0;\n\n\tspin_lock_irqsave(&pdata->mac_cr_lock, flags);\n\n\tif (dev->net->flags & IFF_PROMISC) {\n\t\tnetif_dbg(dev, drv, dev->net, \"promiscuous mode enabled\\n\");\n\t\tpdata->mac_cr |= MAC_CR_PRMS_;\n\t\tpdata->mac_cr &= ~(MAC_CR_MCPAS_ | MAC_CR_HPFILT_);\n\t} else if (dev->net->flags & IFF_ALLMULTI) {\n\t\tnetif_dbg(dev, drv, dev->net, \"receive all multicast enabled\\n\");\n\t\tpdata->mac_cr |= MAC_CR_MCPAS_;\n\t\tpdata->mac_cr &= ~(MAC_CR_PRMS_ | MAC_CR_HPFILT_);\n\t} else if (!netdev_mc_empty(dev->net)) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tpdata->mac_cr |= MAC_CR_HPFILT_;\n\t\tpdata->mac_cr &= ~(MAC_CR_PRMS_ | MAC_CR_MCPAS_);\n\n\t\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\t\tu32 bitnum = smsc95xx_hash(ha->addr);\n\t\t\tu32 mask = 0x01 << (bitnum & 0x1F);\n\t\t\tif (bitnum & 0x20)\n\t\t\t\tpdata->hash_hi |= mask;\n\t\t\telse\n\t\t\t\tpdata->hash_lo |= mask;\n\t\t}\n\n\t\tnetif_dbg(dev, drv, dev->net, \"HASHH=0x%08X, HASHL=0x%08X\\n\",\n\t\t\t\t   pdata->hash_hi, pdata->hash_lo);\n\t} else {\n\t\tnetif_dbg(dev, drv, dev->net, \"receive own packets only\\n\");\n\t\tpdata->mac_cr &=\n\t\t\t~(MAC_CR_PRMS_ | MAC_CR_MCPAS_ | MAC_CR_HPFILT_);\n\t}\n\n\tspin_unlock_irqrestore(&pdata->mac_cr_lock, flags);\n\n\t \n\tret = smsc95xx_write_reg_async(dev, HASHH, pdata->hash_hi);\n\tif (ret < 0)\n\t\tnetdev_warn(dev->net, \"failed to initiate async write to HASHH\\n\");\n\n\tret = smsc95xx_write_reg_async(dev, HASHL, pdata->hash_lo);\n\tif (ret < 0)\n\t\tnetdev_warn(dev->net, \"failed to initiate async write to HASHL\\n\");\n\n\tret = smsc95xx_write_reg_async(dev, MAC_CR, pdata->mac_cr);\n\tif (ret < 0)\n\t\tnetdev_warn(dev->net, \"failed to initiate async write to MAC_CR\\n\");\n}\n\nstatic int smsc95xx_phy_update_flowcontrol(struct usbnet *dev)\n{\n\tu32 flow = 0, afc_cfg;\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tbool tx_pause, rx_pause;\n\n\tint ret = smsc95xx_read_reg(dev, AFC_CFG, &afc_cfg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pdata->phydev->duplex == DUPLEX_FULL) {\n\t\tphy_get_pause(pdata->phydev, &tx_pause, &rx_pause);\n\n\t\tif (rx_pause)\n\t\t\tflow = 0xFFFF0002;\n\n\t\tif (tx_pause) {\n\t\t\tafc_cfg |= 0xF;\n\t\t\tflow |= 0xFFFF0000;\n\t\t} else {\n\t\t\tafc_cfg &= ~0xF;\n\t\t}\n\n\t\tnetif_dbg(dev, link, dev->net, \"rx pause %s, tx pause %s\\n\",\n\t\t\t  rx_pause ? \"enabled\" : \"disabled\",\n\t\t\t  tx_pause ? \"enabled\" : \"disabled\");\n\t} else {\n\t\tnetif_dbg(dev, link, dev->net, \"half duplex\\n\");\n\t\tafc_cfg |= 0xF;\n\t}\n\n\tret = smsc95xx_write_reg(dev, FLOW, flow);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn smsc95xx_write_reg(dev, AFC_CFG, afc_cfg);\n}\n\nstatic void smsc95xx_mac_update_fullduplex(struct usbnet *dev)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pdata->mac_cr_lock, flags);\n\tif (pdata->phydev->duplex != DUPLEX_FULL) {\n\t\tpdata->mac_cr &= ~MAC_CR_FDPX_;\n\t\tpdata->mac_cr |= MAC_CR_RCVOWN_;\n\t} else {\n\t\tpdata->mac_cr &= ~MAC_CR_RCVOWN_;\n\t\tpdata->mac_cr |= MAC_CR_FDPX_;\n\t}\n\tspin_unlock_irqrestore(&pdata->mac_cr_lock, flags);\n\n\tret = smsc95xx_write_reg(dev, MAC_CR, pdata->mac_cr);\n\tif (ret < 0) {\n\t\tif (ret != -ENODEV)\n\t\t\tnetdev_warn(dev->net,\n\t\t\t\t    \"Error updating MAC full duplex mode\\n\");\n\t\treturn;\n\t}\n\n\tret = smsc95xx_phy_update_flowcontrol(dev);\n\tif (ret < 0)\n\t\tnetdev_warn(dev->net, \"Error updating PHY flow control\\n\");\n}\n\nstatic void smsc95xx_status(struct usbnet *dev, struct urb *urb)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tunsigned long flags;\n\tu32 intdata;\n\n\tif (urb->actual_length != 4) {\n\t\tnetdev_warn(dev->net, \"unexpected urb length %d\\n\",\n\t\t\t    urb->actual_length);\n\t\treturn;\n\t}\n\n\tintdata = get_unaligned_le32(urb->transfer_buffer);\n\tnetif_dbg(dev, link, dev->net, \"intdata: 0x%08X\\n\", intdata);\n\n\tlocal_irq_save(flags);\n\n\tif (intdata & INT_ENP_PHY_INT_)\n\t\tgeneric_handle_domain_irq(pdata->irqdomain, PHY_HWIRQ);\n\telse\n\t\tnetdev_warn(dev->net, \"unexpected interrupt, intdata=0x%08X\\n\",\n\t\t\t    intdata);\n\n\tlocal_irq_restore(flags);\n}\n\n \nstatic int smsc95xx_set_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tu32 read_buf;\n\tint ret;\n\n\tret = smsc95xx_read_reg(dev, COE_CR, &read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (features & NETIF_F_IP_CSUM)\n\t\tread_buf |= Tx_COE_EN_;\n\telse\n\t\tread_buf &= ~Tx_COE_EN_;\n\n\tif (features & NETIF_F_RXCSUM)\n\t\tread_buf |= Rx_COE_EN_;\n\telse\n\t\tread_buf &= ~Rx_COE_EN_;\n\n\tret = smsc95xx_write_reg(dev, COE_CR, read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnetif_dbg(dev, hw, dev->net, \"COE_CR = 0x%08x\\n\", read_buf);\n\treturn 0;\n}\n\nstatic int smsc95xx_ethtool_get_eeprom_len(struct net_device *net)\n{\n\treturn MAX_EEPROM_SIZE;\n}\n\nstatic int smsc95xx_ethtool_get_eeprom(struct net_device *netdev,\n\t\t\t\t       struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\n\tee->magic = LAN95XX_EEPROM_MAGIC;\n\n\treturn smsc95xx_read_eeprom(dev, ee->offset, ee->len, data);\n}\n\nstatic int smsc95xx_ethtool_set_eeprom(struct net_device *netdev,\n\t\t\t\t       struct ethtool_eeprom *ee, u8 *data)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\n\tif (ee->magic != LAN95XX_EEPROM_MAGIC) {\n\t\tnetdev_warn(dev->net, \"EEPROM: magic value mismatch, magic = 0x%x\\n\",\n\t\t\t    ee->magic);\n\t\treturn -EINVAL;\n\t}\n\n\treturn smsc95xx_write_eeprom(dev, ee->offset, ee->len, data);\n}\n\nstatic int smsc95xx_ethtool_getregslen(struct net_device *netdev)\n{\n\t \n\treturn COE_CR - ID_REV + sizeof(u32);\n}\n\nstatic void\nsmsc95xx_ethtool_getregs(struct net_device *netdev, struct ethtool_regs *regs,\n\t\t\t void *buf)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tunsigned int i, j;\n\tint retval;\n\tu32 *data = buf;\n\n\tretval = smsc95xx_read_reg(dev, ID_REV, &regs->version);\n\tif (retval < 0) {\n\t\tnetdev_warn(netdev, \"REGS: cannot read ID_REV\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = ID_REV, j = 0; i <= COE_CR; i += (sizeof(u32)), j++) {\n\t\tretval = smsc95xx_read_reg(dev, i, &data[j]);\n\t\tif (retval < 0) {\n\t\t\tnetdev_warn(netdev, \"REGS: cannot read reg[%x]\\n\", i);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void smsc95xx_ethtool_get_wol(struct net_device *net,\n\t\t\t\t     struct ethtool_wolinfo *wolinfo)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\n\twolinfo->supported = SUPPORTED_WAKE;\n\twolinfo->wolopts = pdata->wolopts;\n}\n\nstatic int smsc95xx_ethtool_set_wol(struct net_device *net,\n\t\t\t\t    struct ethtool_wolinfo *wolinfo)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tint ret;\n\n\tif (wolinfo->wolopts & ~SUPPORTED_WAKE)\n\t\treturn -EINVAL;\n\n\tpdata->wolopts = wolinfo->wolopts & SUPPORTED_WAKE;\n\n\tret = device_set_wakeup_enable(&dev->udev->dev, pdata->wolopts);\n\tif (ret < 0)\n\t\tnetdev_warn(dev->net, \"device_set_wakeup_enable error %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic u32 smsc95xx_get_link(struct net_device *net)\n{\n\tphy_read_status(net->phydev);\n\treturn net->phydev->link;\n}\n\nstatic void smsc95xx_ethtool_get_strings(struct net_device *netdev, u32 sset,\n\t\t\t\t\tu8 *data)\n{\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\tnet_selftest_get_strings(data);\n\t\tbreak;\n\t}\n}\n\nstatic int smsc95xx_ethtool_get_sset_count(struct net_device *ndev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn net_selftest_get_count();\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct ethtool_ops smsc95xx_ethtool_ops = {\n\t.get_link\t= smsc95xx_get_link,\n\t.nway_reset\t= phy_ethtool_nway_reset,\n\t.get_drvinfo\t= usbnet_get_drvinfo,\n\t.get_msglevel\t= usbnet_get_msglevel,\n\t.set_msglevel\t= usbnet_set_msglevel,\n\t.get_eeprom_len\t= smsc95xx_ethtool_get_eeprom_len,\n\t.get_eeprom\t= smsc95xx_ethtool_get_eeprom,\n\t.set_eeprom\t= smsc95xx_ethtool_set_eeprom,\n\t.get_regs_len\t= smsc95xx_ethtool_getregslen,\n\t.get_regs\t= smsc95xx_ethtool_getregs,\n\t.get_wol\t= smsc95xx_ethtool_get_wol,\n\t.set_wol\t= smsc95xx_ethtool_set_wol,\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n\t.get_ts_info\t= ethtool_op_get_ts_info,\n\t.self_test\t= net_selftest,\n\t.get_strings\t= smsc95xx_ethtool_get_strings,\n\t.get_sset_count\t= smsc95xx_ethtool_get_sset_count,\n};\n\nstatic int smsc95xx_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\n{\n\tif (!netif_running(netdev))\n\t\treturn -EINVAL;\n\n\treturn phy_mii_ioctl(netdev->phydev, rq, cmd);\n}\n\nstatic void smsc95xx_init_mac_address(struct usbnet *dev)\n{\n\tu8 addr[ETH_ALEN];\n\n\t \n\tif (!platform_get_ethdev_address(&dev->udev->dev, dev->net)) {\n\t\tif (is_valid_ether_addr(dev->net->dev_addr)) {\n\t\t\t \n\t\t\tnetif_dbg(dev, ifup, dev->net, \"MAC address read from the device tree\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (smsc95xx_read_eeprom(dev, EEPROM_MAC_OFFSET, ETH_ALEN, addr) == 0) {\n\t\teth_hw_addr_set(dev->net, addr);\n\t\tif (is_valid_ether_addr(dev->net->dev_addr)) {\n\t\t\t \n\t\t\tnetif_dbg(dev, ifup, dev->net, \"MAC address read from EEPROM\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\teth_hw_addr_random(dev->net);\n\tnetif_dbg(dev, ifup, dev->net, \"MAC address set to eth_random_addr\\n\");\n}\n\nstatic int smsc95xx_set_mac_address(struct usbnet *dev)\n{\n\tu32 addr_lo = dev->net->dev_addr[0] | dev->net->dev_addr[1] << 8 |\n\t\tdev->net->dev_addr[2] << 16 | dev->net->dev_addr[3] << 24;\n\tu32 addr_hi = dev->net->dev_addr[4] | dev->net->dev_addr[5] << 8;\n\tint ret;\n\n\tret = smsc95xx_write_reg(dev, ADDRL, addr_lo);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn smsc95xx_write_reg(dev, ADDRH, addr_hi);\n}\n\n \nstatic int smsc95xx_start_tx_path(struct usbnet *dev)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tspin_lock_irqsave(&pdata->mac_cr_lock, flags);\n\tpdata->mac_cr |= MAC_CR_TXEN_;\n\tspin_unlock_irqrestore(&pdata->mac_cr_lock, flags);\n\n\tret = smsc95xx_write_reg(dev, MAC_CR, pdata->mac_cr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn smsc95xx_write_reg(dev, TX_CFG, TX_CFG_ON_);\n}\n\n \nstatic int smsc95xx_start_rx_path(struct usbnet *dev)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdata->mac_cr_lock, flags);\n\tpdata->mac_cr |= MAC_CR_RXEN_;\n\tspin_unlock_irqrestore(&pdata->mac_cr_lock, flags);\n\n\treturn smsc95xx_write_reg(dev, MAC_CR, pdata->mac_cr);\n}\n\nstatic int smsc95xx_reset(struct usbnet *dev)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tu32 read_buf, write_buf, burst_cap;\n\tint ret = 0, timeout;\n\n\tnetif_dbg(dev, ifup, dev->net, \"entering smsc95xx_reset\\n\");\n\n\tret = smsc95xx_write_reg(dev, HW_CFG, HW_CFG_LRST_);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttimeout = 0;\n\tdo {\n\t\tmsleep(10);\n\t\tret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ttimeout++;\n\t} while ((read_buf & HW_CFG_LRST_) && (timeout < 100));\n\n\tif (timeout >= 100) {\n\t\tnetdev_warn(dev->net, \"timeout waiting for completion of Lite Reset\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tret = smsc95xx_set_mac_address(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnetif_dbg(dev, ifup, dev->net, \"MAC Address: %pM\\n\",\n\t\t  dev->net->dev_addr);\n\n\tret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnetif_dbg(dev, ifup, dev->net, \"Read Value from HW_CFG : 0x%08x\\n\",\n\t\t  read_buf);\n\n\tread_buf |= HW_CFG_BIR_;\n\n\tret = smsc95xx_write_reg(dev, HW_CFG, read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnetif_dbg(dev, ifup, dev->net,\n\t\t  \"Read Value from HW_CFG after writing HW_CFG_BIR_: 0x%08x\\n\",\n\t\t  read_buf);\n\n\tif (!turbo_mode) {\n\t\tburst_cap = 0;\n\t\tdev->rx_urb_size = MAX_SINGLE_PACKET_SIZE;\n\t} else if (dev->udev->speed == USB_SPEED_HIGH) {\n\t\tburst_cap = DEFAULT_HS_BURST_CAP_SIZE / HS_USB_PKT_SIZE;\n\t\tdev->rx_urb_size = DEFAULT_HS_BURST_CAP_SIZE;\n\t} else {\n\t\tburst_cap = DEFAULT_FS_BURST_CAP_SIZE / FS_USB_PKT_SIZE;\n\t\tdev->rx_urb_size = DEFAULT_FS_BURST_CAP_SIZE;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"rx_urb_size=%ld\\n\",\n\t\t  (ulong)dev->rx_urb_size);\n\n\tret = smsc95xx_write_reg(dev, BURST_CAP, burst_cap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = smsc95xx_read_reg(dev, BURST_CAP, &read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnetif_dbg(dev, ifup, dev->net,\n\t\t  \"Read Value from BURST_CAP after writing: 0x%08x\\n\",\n\t\t  read_buf);\n\n\tret = smsc95xx_write_reg(dev, BULK_IN_DLY, DEFAULT_BULK_IN_DELAY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = smsc95xx_read_reg(dev, BULK_IN_DLY, &read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnetif_dbg(dev, ifup, dev->net,\n\t\t  \"Read Value from BULK_IN_DLY after writing: 0x%08x\\n\",\n\t\t  read_buf);\n\n\tret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnetif_dbg(dev, ifup, dev->net, \"Read Value from HW_CFG: 0x%08x\\n\",\n\t\t  read_buf);\n\n\tif (turbo_mode)\n\t\tread_buf |= (HW_CFG_MEF_ | HW_CFG_BCE_);\n\n\tread_buf &= ~HW_CFG_RXDOFF_;\n\n\t \n\tread_buf |= NET_IP_ALIGN << 9;\n\n\tret = smsc95xx_write_reg(dev, HW_CFG, read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = smsc95xx_read_reg(dev, HW_CFG, &read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnetif_dbg(dev, ifup, dev->net,\n\t\t  \"Read Value from HW_CFG after writing: 0x%08x\\n\", read_buf);\n\n\tret = smsc95xx_write_reg(dev, INT_STS, INT_STS_CLEAR_ALL_);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = smsc95xx_read_reg(dev, ID_REV, &read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\tnetif_dbg(dev, ifup, dev->net, \"ID_REV = 0x%08x\\n\", read_buf);\n\n\t \n\twrite_buf = LED_GPIO_CFG_SPD_LED | LED_GPIO_CFG_LNK_LED |\n\t\tLED_GPIO_CFG_FDX_LED;\n\tret = smsc95xx_write_reg(dev, LED_GPIO_CFG, write_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = smsc95xx_write_reg(dev, FLOW, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = smsc95xx_write_reg(dev, AFC_CFG, AFC_CFG_DEFAULT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = smsc95xx_read_reg(dev, MAC_CR, &pdata->mac_cr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t \n\tret = smsc95xx_write_reg(dev, VLAN1, (u32)ETH_P_8021Q);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = smsc95xx_set_features(dev->net, dev->net->features);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to set checksum offload features\\n\");\n\t\treturn ret;\n\t}\n\n\tsmsc95xx_set_multicast(dev->net);\n\n\tret = smsc95xx_read_reg(dev, INT_EP_CTL, &read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tread_buf |= INT_EP_CTL_PHY_INT_;\n\n\tret = smsc95xx_write_reg(dev, INT_EP_CTL, read_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = smsc95xx_start_tx_path(dev);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to start TX path\\n\");\n\t\treturn ret;\n\t}\n\n\tret = smsc95xx_start_rx_path(dev);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"Failed to start RX path\\n\");\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(dev, ifup, dev->net, \"smsc95xx_reset, return 0\\n\");\n\treturn 0;\n}\n\nstatic const struct net_device_ops smsc95xx_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_change_mtu\t\t= usbnet_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= smsc95xx_ioctl,\n\t.ndo_set_rx_mode\t= smsc95xx_set_multicast,\n\t.ndo_set_features\t= smsc95xx_set_features,\n};\n\nstatic void smsc95xx_handle_link_change(struct net_device *net)\n{\n\tstruct usbnet *dev = netdev_priv(net);\n\n\tphy_print_status(net->phydev);\n\tsmsc95xx_mac_update_fullduplex(dev);\n\tusbnet_defer_kevent(dev, EVENT_LINK_CHANGE);\n}\n\nstatic int smsc95xx_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct smsc95xx_priv *pdata;\n\tchar usb_path[64];\n\tint ret, phy_irq;\n\tu32 val;\n\n\tprintk(KERN_INFO SMSC_CHIPNAME \" v\" SMSC_DRIVER_VERSION \"\\n\");\n\n\tret = usbnet_get_endpoints(dev, intf);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"usbnet_get_endpoints failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpdata = kzalloc(sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tdev->driver_priv = pdata;\n\n\tspin_lock_init(&pdata->mac_cr_lock);\n\n\t \n\tif (DEFAULT_TX_CSUM_ENABLE)\n\t\tdev->net->features |= NETIF_F_IP_CSUM;\n\tif (DEFAULT_RX_CSUM_ENABLE)\n\t\tdev->net->features |= NETIF_F_RXCSUM;\n\n\tdev->net->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM;\n\tset_bit(EVENT_NO_IP_ALIGN, &dev->flags);\n\n\tsmsc95xx_init_mac_address(dev);\n\n\t \n\tret = smsc95xx_reset(dev);\n\tif (ret)\n\t\tgoto free_pdata;\n\n\t \n\tusb_make_path(dev->udev, usb_path, sizeof(usb_path));\n\tpdata->irqfwnode = irq_domain_alloc_named_fwnode(usb_path);\n\tif (!pdata->irqfwnode) {\n\t\tret = -ENOMEM;\n\t\tgoto free_pdata;\n\t}\n\n\tpdata->irqdomain = irq_domain_create_linear(pdata->irqfwnode,\n\t\t\t\t\t\t    SMSC95XX_NR_IRQS,\n\t\t\t\t\t\t    &irq_domain_simple_ops,\n\t\t\t\t\t\t    pdata);\n\tif (!pdata->irqdomain) {\n\t\tret = -ENOMEM;\n\t\tgoto free_irqfwnode;\n\t}\n\n\tphy_irq = irq_create_mapping(pdata->irqdomain, PHY_HWIRQ);\n\tif (!phy_irq) {\n\t\tret = -ENOENT;\n\t\tgoto remove_irqdomain;\n\t}\n\n\tpdata->irqchip = dummy_irq_chip;\n\tpdata->irqchip.name = SMSC_CHIPNAME;\n\tirq_set_chip_and_handler_name(phy_irq, &pdata->irqchip,\n\t\t\t\t      handle_simple_irq, \"phy\");\n\n\tpdata->mdiobus = mdiobus_alloc();\n\tif (!pdata->mdiobus) {\n\t\tret = -ENOMEM;\n\t\tgoto dispose_irq;\n\t}\n\n\tret = smsc95xx_read_reg(dev, HW_CFG, &val);\n\tif (ret < 0)\n\t\tgoto free_mdio;\n\n\tpdata->is_internal_phy = !(val & HW_CFG_PSEL_);\n\tif (pdata->is_internal_phy)\n\t\tpdata->mdiobus->phy_mask = ~(1u << SMSC95XX_INTERNAL_PHY_ID);\n\n\tpdata->mdiobus->priv = dev;\n\tpdata->mdiobus->read = smsc95xx_mdiobus_read;\n\tpdata->mdiobus->write = smsc95xx_mdiobus_write;\n\tpdata->mdiobus->reset = smsc95xx_mdiobus_reset;\n\tpdata->mdiobus->name = \"smsc95xx-mdiobus\";\n\tpdata->mdiobus->parent = &dev->udev->dev;\n\n\tsnprintf(pdata->mdiobus->id, ARRAY_SIZE(pdata->mdiobus->id),\n\t\t \"usb-%03d:%03d\", dev->udev->bus->busnum, dev->udev->devnum);\n\n\tret = mdiobus_register(pdata->mdiobus);\n\tif (ret) {\n\t\tnetdev_err(dev->net, \"Could not register MDIO bus\\n\");\n\t\tgoto free_mdio;\n\t}\n\n\tpdata->phydev = phy_find_first(pdata->mdiobus);\n\tif (!pdata->phydev) {\n\t\tnetdev_err(dev->net, \"no PHY found\\n\");\n\t\tret = -ENODEV;\n\t\tgoto unregister_mdio;\n\t}\n\n\tpdata->phydev->irq = phy_irq;\n\tpdata->phydev->is_internal = pdata->is_internal_phy;\n\n\t \n\tret = smsc95xx_read_reg(dev, ID_REV, &val);\n\tif (ret < 0)\n\t\tgoto unregister_mdio;\n\n\tval >>= 16;\n\tif ((val == ID_REV_CHIP_ID_9500A_) || (val == ID_REV_CHIP_ID_9530_) ||\n\t    (val == ID_REV_CHIP_ID_89530_) || (val == ID_REV_CHIP_ID_9730_))\n\t\tpdata->features = (FEATURE_8_WAKEUP_FILTERS |\n\t\t\tFEATURE_PHY_NLP_CROSSOVER |\n\t\t\tFEATURE_REMOTE_WAKEUP);\n\telse if (val == ID_REV_CHIP_ID_9512_)\n\t\tpdata->features = FEATURE_8_WAKEUP_FILTERS;\n\n\tdev->net->netdev_ops = &smsc95xx_netdev_ops;\n\tdev->net->ethtool_ops = &smsc95xx_ethtool_ops;\n\tdev->net->flags |= IFF_MULTICAST;\n\tdev->net->hard_header_len += SMSC95XX_TX_OVERHEAD_CSUM;\n\tdev->net->min_mtu = ETH_MIN_MTU;\n\tdev->net->max_mtu = ETH_DATA_LEN;\n\tdev->hard_mtu = dev->net->mtu + dev->net->hard_header_len;\n\n\tret = phy_connect_direct(dev->net, pdata->phydev,\n\t\t\t\t &smsc95xx_handle_link_change,\n\t\t\t\t PHY_INTERFACE_MODE_MII);\n\tif (ret) {\n\t\tnetdev_err(dev->net, \"can't attach PHY to %s\\n\", pdata->mdiobus->id);\n\t\tgoto unregister_mdio;\n\t}\n\n\tphy_attached_info(dev->net->phydev);\n\n\treturn 0;\n\nunregister_mdio:\n\tmdiobus_unregister(pdata->mdiobus);\n\nfree_mdio:\n\tmdiobus_free(pdata->mdiobus);\n\ndispose_irq:\n\tirq_dispose_mapping(phy_irq);\n\nremove_irqdomain:\n\tirq_domain_remove(pdata->irqdomain);\n\nfree_irqfwnode:\n\tirq_domain_free_fwnode(pdata->irqfwnode);\n\nfree_pdata:\n\tkfree(pdata);\n\treturn ret;\n}\n\nstatic void smsc95xx_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\n\tphy_disconnect(dev->net->phydev);\n\tmdiobus_unregister(pdata->mdiobus);\n\tmdiobus_free(pdata->mdiobus);\n\tirq_dispose_mapping(irq_find_mapping(pdata->irqdomain, PHY_HWIRQ));\n\tirq_domain_remove(pdata->irqdomain);\n\tirq_domain_free_fwnode(pdata->irqfwnode);\n\tnetif_dbg(dev, ifdown, dev->net, \"free pdata\\n\");\n\tkfree(pdata);\n}\n\nstatic int smsc95xx_start_phy(struct usbnet *dev)\n{\n\tphy_start(dev->net->phydev);\n\n\treturn 0;\n}\n\nstatic int smsc95xx_stop(struct usbnet *dev)\n{\n\tphy_stop(dev->net->phydev);\n\n\treturn 0;\n}\n\nstatic u32 smsc_crc(const u8 *buffer, size_t len, int filter)\n{\n\tu32 crc = bitrev16(crc16(0xFFFF, buffer, len));\n\treturn crc << ((filter % 2) * 16);\n}\n\nstatic int smsc95xx_link_ok(struct usbnet *dev)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tint ret;\n\n\t \n\tret = smsc95xx_mdio_read(dev, pdata->phydev->mdio.addr, MII_BMSR);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = smsc95xx_mdio_read(dev, pdata->phydev->mdio.addr, MII_BMSR);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(ret & BMSR_LSTATUS);\n}\n\nstatic int smsc95xx_enter_suspend0(struct usbnet *dev)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tu32 val;\n\tint ret;\n\n\tret = smsc95xx_read_reg(dev, PM_CTRL, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval &= (~(PM_CTL_SUS_MODE_ | PM_CTL_WUPS_ | PM_CTL_PHY_RST_));\n\tval |= PM_CTL_SUS_MODE_0;\n\n\tret = smsc95xx_write_reg(dev, PM_CTRL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval &= ~PM_CTL_WUPS_;\n\tval |= PM_CTL_WUPS_WOL_;\n\n\t \n\tif (pdata->wolopts & WAKE_PHY)\n\t\tval |= PM_CTL_WUPS_ED_;\n\n\tret = smsc95xx_write_reg(dev, PM_CTRL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = smsc95xx_read_reg(dev, PM_CTRL, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpdata->suspend_flags |= SUSPEND_SUSPEND0;\n\n\treturn 0;\n}\n\nstatic int smsc95xx_enter_suspend1(struct usbnet *dev)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tint ret, phy_id = pdata->phydev->mdio.addr;\n\tu32 val;\n\n\t \n\tif (pdata->features & FEATURE_PHY_NLP_CROSSOVER)\n\t\tsmsc95xx_mdio_write(dev, phy_id, PHY_EDPD_CONFIG,\n\t\t\t\t    PHY_EDPD_CONFIG_DEFAULT);\n\n\t \n\tret = smsc95xx_mdio_read(dev, phy_id, PHY_MODE_CTRL_STS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret |= MODE_CTRL_STS_EDPWRDOWN_;\n\n\tsmsc95xx_mdio_write(dev, phy_id, PHY_MODE_CTRL_STS, ret);\n\n\t \n\tret = smsc95xx_read_reg(dev, PM_CTRL, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval &= ~(PM_CTL_SUS_MODE_ | PM_CTL_WUPS_ | PM_CTL_PHY_RST_);\n\tval |= PM_CTL_SUS_MODE_1;\n\n\tret = smsc95xx_write_reg(dev, PM_CTRL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval &= ~PM_CTL_WUPS_;\n\tval |= (PM_CTL_WUPS_ED_ | PM_CTL_ED_EN_);\n\n\tret = smsc95xx_write_reg(dev, PM_CTRL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpdata->suspend_flags |= SUSPEND_SUSPEND1;\n\n\treturn 0;\n}\n\nstatic int smsc95xx_enter_suspend2(struct usbnet *dev)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tu32 val;\n\tint ret;\n\n\tret = smsc95xx_read_reg(dev, PM_CTRL, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval &= ~(PM_CTL_SUS_MODE_ | PM_CTL_WUPS_ | PM_CTL_PHY_RST_);\n\tval |= PM_CTL_SUS_MODE_2;\n\n\tret = smsc95xx_write_reg(dev, PM_CTRL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpdata->suspend_flags |= SUSPEND_SUSPEND2;\n\n\treturn 0;\n}\n\nstatic int smsc95xx_enter_suspend3(struct usbnet *dev)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tu32 val;\n\tint ret;\n\n\tret = smsc95xx_read_reg(dev, RX_FIFO_INF, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val & RX_FIFO_INF_USED_) {\n\t\tnetdev_info(dev->net, \"rx fifo not empty in autosuspend\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = smsc95xx_read_reg(dev, PM_CTRL, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval &= ~(PM_CTL_SUS_MODE_ | PM_CTL_WUPS_ | PM_CTL_PHY_RST_);\n\tval |= PM_CTL_SUS_MODE_3 | PM_CTL_RES_CLR_WKP_STS;\n\n\tret = smsc95xx_write_reg(dev, PM_CTRL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval &= ~PM_CTL_WUPS_;\n\tval |= PM_CTL_WUPS_WOL_;\n\n\tret = smsc95xx_write_reg(dev, PM_CTRL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpdata->suspend_flags |= SUSPEND_SUSPEND3;\n\n\treturn 0;\n}\n\nstatic int smsc95xx_autosuspend(struct usbnet *dev, u32 link_up)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\n\tif (!netif_running(dev->net)) {\n\t\t \n\t\tnetdev_dbg(dev->net, \"autosuspend entering SUSPEND2\\n\");\n\t\treturn smsc95xx_enter_suspend2(dev);\n\t}\n\n\tif (!link_up) {\n\t\t \n\t\tif (!(pdata->features & FEATURE_PHY_NLP_CROSSOVER)) {\n\t\t\tnetdev_warn(dev->net, \"EDPD not supported\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tnetdev_dbg(dev->net, \"autosuspend entering SUSPEND1\\n\");\n\t\tnetdev_info(dev->net, \"entering SUSPEND1 mode\\n\");\n\t\treturn smsc95xx_enter_suspend1(dev);\n\t}\n\n\tnetdev_dbg(dev->net, \"autosuspend entering SUSPEND3\\n\");\n\treturn smsc95xx_enter_suspend3(dev);\n}\n\nstatic int smsc95xx_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tu32 val, link_up;\n\tint ret;\n\n\tpdata->pm_task = current;\n\n\tret = usbnet_suspend(intf, message);\n\tif (ret < 0) {\n\t\tnetdev_warn(dev->net, \"usbnet_suspend error\\n\");\n\t\tpdata->pm_task = NULL;\n\t\treturn ret;\n\t}\n\n\tif (pdata->suspend_flags) {\n\t\tnetdev_warn(dev->net, \"error during last resume\\n\");\n\t\tpdata->suspend_flags = 0;\n\t}\n\n\tlink_up = smsc95xx_link_ok(dev);\n\n\tif (message.event == PM_EVENT_AUTO_SUSPEND &&\n\t    (pdata->features & FEATURE_REMOTE_WAKEUP)) {\n\t\tret = smsc95xx_autosuspend(dev, link_up);\n\t\tgoto done;\n\t}\n\n\t \n\t \n\tif (!(pdata->wolopts & SUPPORTED_WAKE) ||\n\t\t!(link_up || (pdata->wolopts & WAKE_PHY))) {\n\t\tnetdev_info(dev->net, \"entering SUSPEND2 mode\\n\");\n\n\t\t \n\t\tret = smsc95xx_read_reg(dev, WUCSR, &val);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tval &= ~(WUCSR_MPEN_ | WUCSR_WAKE_EN_);\n\n\t\tret = smsc95xx_write_reg(dev, WUCSR, val);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tret = smsc95xx_read_reg(dev, PM_CTRL, &val);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tval &= ~(PM_CTL_ED_EN_ | PM_CTL_WOL_EN_);\n\n\t\tret = smsc95xx_write_reg(dev, PM_CTRL, val);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tret = smsc95xx_enter_suspend2(dev);\n\t\tgoto done;\n\t}\n\n\tif (pdata->wolopts & WAKE_PHY) {\n\t\t \n\t\tif (!link_up) {\n\t\t\tnetdev_info(dev->net, \"entering SUSPEND1 mode\\n\");\n\t\t\tret = smsc95xx_enter_suspend1(dev);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (pdata->wolopts & (WAKE_BCAST | WAKE_MCAST | WAKE_ARP | WAKE_UCAST)) {\n\t\tu32 *filter_mask = kcalloc(32, sizeof(u32), GFP_KERNEL);\n\t\tu32 command[2];\n\t\tu32 offset[2];\n\t\tu32 crc[4];\n\t\tint wuff_filter_count =\n\t\t\t(pdata->features & FEATURE_8_WAKEUP_FILTERS) ?\n\t\t\tLAN9500A_WUFF_NUM : LAN9500_WUFF_NUM;\n\t\tint i, filter = 0;\n\n\t\tif (!filter_mask) {\n\t\t\tnetdev_warn(dev->net, \"Unable to allocate filter_mask\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\n\t\tmemset(command, 0, sizeof(command));\n\t\tmemset(offset, 0, sizeof(offset));\n\t\tmemset(crc, 0, sizeof(crc));\n\n\t\tif (pdata->wolopts & WAKE_BCAST) {\n\t\t\tconst u8 bcast[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};\n\t\t\tnetdev_info(dev->net, \"enabling broadcast detection\\n\");\n\t\t\tfilter_mask[filter * 4] = 0x003F;\n\t\t\tfilter_mask[filter * 4 + 1] = 0x00;\n\t\t\tfilter_mask[filter * 4 + 2] = 0x00;\n\t\t\tfilter_mask[filter * 4 + 3] = 0x00;\n\t\t\tcommand[filter/4] |= 0x05UL << ((filter % 4) * 8);\n\t\t\toffset[filter/4] |= 0x00 << ((filter % 4) * 8);\n\t\t\tcrc[filter/2] |= smsc_crc(bcast, 6, filter);\n\t\t\tfilter++;\n\t\t}\n\n\t\tif (pdata->wolopts & WAKE_MCAST) {\n\t\t\tconst u8 mcast[] = {0x01, 0x00, 0x5E};\n\t\t\tnetdev_info(dev->net, \"enabling multicast detection\\n\");\n\t\t\tfilter_mask[filter * 4] = 0x0007;\n\t\t\tfilter_mask[filter * 4 + 1] = 0x00;\n\t\t\tfilter_mask[filter * 4 + 2] = 0x00;\n\t\t\tfilter_mask[filter * 4 + 3] = 0x00;\n\t\t\tcommand[filter/4] |= 0x09UL << ((filter % 4) * 8);\n\t\t\toffset[filter/4] |= 0x00  << ((filter % 4) * 8);\n\t\t\tcrc[filter/2] |= smsc_crc(mcast, 3, filter);\n\t\t\tfilter++;\n\t\t}\n\n\t\tif (pdata->wolopts & WAKE_ARP) {\n\t\t\tconst u8 arp[] = {0x08, 0x06};\n\t\t\tnetdev_info(dev->net, \"enabling ARP detection\\n\");\n\t\t\tfilter_mask[filter * 4] = 0x0003;\n\t\t\tfilter_mask[filter * 4 + 1] = 0x00;\n\t\t\tfilter_mask[filter * 4 + 2] = 0x00;\n\t\t\tfilter_mask[filter * 4 + 3] = 0x00;\n\t\t\tcommand[filter/4] |= 0x05UL << ((filter % 4) * 8);\n\t\t\toffset[filter/4] |= 0x0C << ((filter % 4) * 8);\n\t\t\tcrc[filter/2] |= smsc_crc(arp, 2, filter);\n\t\t\tfilter++;\n\t\t}\n\n\t\tif (pdata->wolopts & WAKE_UCAST) {\n\t\t\tnetdev_info(dev->net, \"enabling unicast detection\\n\");\n\t\t\tfilter_mask[filter * 4] = 0x003F;\n\t\t\tfilter_mask[filter * 4 + 1] = 0x00;\n\t\t\tfilter_mask[filter * 4 + 2] = 0x00;\n\t\t\tfilter_mask[filter * 4 + 3] = 0x00;\n\t\t\tcommand[filter/4] |= 0x01UL << ((filter % 4) * 8);\n\t\t\toffset[filter/4] |= 0x00 << ((filter % 4) * 8);\n\t\t\tcrc[filter/2] |= smsc_crc(dev->net->dev_addr, ETH_ALEN, filter);\n\t\t\tfilter++;\n\t\t}\n\n\t\tfor (i = 0; i < (wuff_filter_count * 4); i++) {\n\t\t\tret = smsc95xx_write_reg(dev, WUFF, filter_mask[i]);\n\t\t\tif (ret < 0) {\n\t\t\t\tkfree(filter_mask);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tkfree(filter_mask);\n\n\t\tfor (i = 0; i < (wuff_filter_count / 4); i++) {\n\t\t\tret = smsc95xx_write_reg(dev, WUFF, command[i]);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (wuff_filter_count / 4); i++) {\n\t\t\tret = smsc95xx_write_reg(dev, WUFF, offset[i]);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; i < (wuff_filter_count / 2); i++) {\n\t\t\tret = smsc95xx_write_reg(dev, WUFF, crc[i]);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tret = smsc95xx_read_reg(dev, WUCSR, &val);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tval |= WUCSR_WUFR_;\n\n\t\tret = smsc95xx_write_reg(dev, WUCSR, val);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (pdata->wolopts & WAKE_MAGIC) {\n\t\t \n\t\tret = smsc95xx_read_reg(dev, WUCSR, &val);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tval |= WUCSR_MPR_;\n\n\t\tret = smsc95xx_write_reg(dev, WUCSR, val);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\t \n\tret = smsc95xx_read_reg(dev, WUCSR, &val);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tif (pdata->wolopts & (WAKE_BCAST | WAKE_MCAST | WAKE_ARP | WAKE_UCAST)) {\n\t\tnetdev_info(dev->net, \"enabling pattern match wakeup\\n\");\n\t\tval |= WUCSR_WAKE_EN_;\n\t} else {\n\t\tnetdev_info(dev->net, \"disabling pattern match wakeup\\n\");\n\t\tval &= ~WUCSR_WAKE_EN_;\n\t}\n\n\tif (pdata->wolopts & WAKE_MAGIC) {\n\t\tnetdev_info(dev->net, \"enabling magic packet wakeup\\n\");\n\t\tval |= WUCSR_MPEN_;\n\t} else {\n\t\tnetdev_info(dev->net, \"disabling magic packet wakeup\\n\");\n\t\tval &= ~WUCSR_MPEN_;\n\t}\n\n\tret = smsc95xx_write_reg(dev, WUCSR, val);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t \n\tret = smsc95xx_read_reg(dev, PM_CTRL, &val);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tval |= PM_CTL_WOL_EN_;\n\n\t \n\tif (pdata->wolopts & WAKE_PHY)\n\t\tval |= PM_CTL_ED_EN_;\n\n\tret = smsc95xx_write_reg(dev, PM_CTRL, val);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t \n\tsmsc95xx_start_rx_path(dev);\n\n\t \n\tnetdev_info(dev->net, \"entering SUSPEND0 mode\\n\");\n\tret = smsc95xx_enter_suspend0(dev);\n\ndone:\n\t \n\tif (ret && PMSG_IS_AUTO(message))\n\t\tusbnet_resume(intf);\n\n\tpdata->pm_task = NULL;\n\treturn ret;\n}\n\nstatic int smsc95xx_resume(struct usb_interface *intf)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct smsc95xx_priv *pdata;\n\tu8 suspend_flags;\n\tint ret;\n\tu32 val;\n\n\tBUG_ON(!dev);\n\tpdata = dev->driver_priv;\n\tsuspend_flags = pdata->suspend_flags;\n\n\tnetdev_dbg(dev->net, \"resume suspend_flags=0x%02x\\n\", suspend_flags);\n\n\t \n\tpdata->suspend_flags = 0;\n\n\tpdata->pm_task = current;\n\n\tif (suspend_flags & SUSPEND_ALLMODES) {\n\t\t \n\t\tret = smsc95xx_read_reg(dev, WUCSR, &val);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tval &= ~(WUCSR_WAKE_EN_ | WUCSR_MPEN_);\n\n\t\tret = smsc95xx_write_reg(dev, WUCSR, val);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\t \n\t\tret = smsc95xx_read_reg(dev, PM_CTRL, &val);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tval &= ~PM_CTL_WOL_EN_;\n\t\tval |= PM_CTL_WUPS_;\n\n\t\tret = smsc95xx_write_reg(dev, PM_CTRL, val);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tphy_init_hw(pdata->phydev);\n\n\tret = usbnet_resume(intf);\n\tif (ret < 0)\n\t\tnetdev_warn(dev->net, \"usbnet_resume error\\n\");\n\ndone:\n\tpdata->pm_task = NULL;\n\treturn ret;\n}\n\nstatic int smsc95xx_reset_resume(struct usb_interface *intf)\n{\n\tstruct usbnet *dev = usb_get_intfdata(intf);\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\tint ret;\n\n\tpdata->pm_task = current;\n\tret = smsc95xx_reset(dev);\n\tpdata->pm_task = NULL;\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn smsc95xx_resume(intf);\n}\n\nstatic void smsc95xx_rx_csum_offload(struct sk_buff *skb)\n{\n\tskb->csum = *(u16 *)(skb_tail_pointer(skb) - 2);\n\tskb->ip_summed = CHECKSUM_COMPLETE;\n\tskb_trim(skb, skb->len - 2);\n}\n\nstatic int smsc95xx_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\t \n\tif (skb->len < dev->net->hard_header_len)\n\t\treturn 0;\n\n\twhile (skb->len > 0) {\n\t\tu32 header, align_count;\n\t\tstruct sk_buff *ax_skb;\n\t\tunsigned char *packet;\n\t\tu16 size;\n\n\t\theader = get_unaligned_le32(skb->data);\n\t\tskb_pull(skb, 4 + NET_IP_ALIGN);\n\t\tpacket = skb->data;\n\n\t\t \n\t\tsize = (u16)((header & RX_STS_FL_) >> 16);\n\t\talign_count = (4 - ((size + NET_IP_ALIGN) % 4)) % 4;\n\n\t\tif (unlikely(size > skb->len)) {\n\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t  \"size err header=0x%08x\\n\", header);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (unlikely(header & RX_STS_ES_)) {\n\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t  \"Error header=0x%08x\\n\", header);\n\t\t\tdev->net->stats.rx_errors++;\n\t\t\tdev->net->stats.rx_dropped++;\n\n\t\t\tif (header & RX_STS_CRC_) {\n\t\t\t\tdev->net->stats.rx_crc_errors++;\n\t\t\t} else {\n\t\t\t\tif (header & (RX_STS_TL_ | RX_STS_RF_))\n\t\t\t\t\tdev->net->stats.rx_frame_errors++;\n\n\t\t\t\tif ((header & RX_STS_LE_) &&\n\t\t\t\t\t(!(header & RX_STS_FT_)))\n\t\t\t\t\tdev->net->stats.rx_length_errors++;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (unlikely(size > (ETH_FRAME_LEN + 12))) {\n\t\t\t\tnetif_dbg(dev, rx_err, dev->net,\n\t\t\t\t\t  \"size err header=0x%08x\\n\", header);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (skb->len == size) {\n\t\t\t\tif (dev->net->features & NETIF_F_RXCSUM)\n\t\t\t\t\tsmsc95xx_rx_csum_offload(skb);\n\t\t\t\tskb_trim(skb, skb->len - 4);  \n\t\t\t\tskb->truesize = size + sizeof(struct sk_buff);\n\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tax_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (unlikely(!ax_skb)) {\n\t\t\t\tnetdev_warn(dev->net, \"Error allocating skb\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tax_skb->len = size;\n\t\t\tax_skb->data = packet;\n\t\t\tskb_set_tail_pointer(ax_skb, size);\n\n\t\t\tif (dev->net->features & NETIF_F_RXCSUM)\n\t\t\t\tsmsc95xx_rx_csum_offload(ax_skb);\n\t\t\tskb_trim(ax_skb, ax_skb->len - 4);  \n\t\t\tax_skb->truesize = size + sizeof(struct sk_buff);\n\n\t\t\tusbnet_skb_return(dev, ax_skb);\n\t\t}\n\n\t\tskb_pull(skb, size);\n\n\t\t \n\t\tif (skb->len)\n\t\t\tskb_pull(skb, align_count);\n\t}\n\n\treturn 1;\n}\n\nstatic u32 smsc95xx_calc_csum_preamble(struct sk_buff *skb)\n{\n\tu16 low_16 = (u16)skb_checksum_start_offset(skb);\n\tu16 high_16 = low_16 + skb->csum_offset;\n\treturn (high_16 << 16) | low_16;\n}\n\n \nstatic bool smsc95xx_can_tx_checksum(struct sk_buff *skb)\n{\n       unsigned int len = skb->len - skb_checksum_start_offset(skb);\n\n       if (skb->len <= 45)\n\t       return false;\n       return skb->csum_offset < (len - (4 + 1));\n}\n\nstatic struct sk_buff *smsc95xx_tx_fixup(struct usbnet *dev,\n\t\t\t\t\t struct sk_buff *skb, gfp_t flags)\n{\n\tbool csum = skb->ip_summed == CHECKSUM_PARTIAL;\n\tint overhead = csum ? SMSC95XX_TX_OVERHEAD_CSUM : SMSC95XX_TX_OVERHEAD;\n\tu32 tx_cmd_a, tx_cmd_b;\n\tvoid *ptr;\n\n\t \n\tBUG_ON(skb_shinfo(skb)->nr_frags);\n\n\t \n\tif (skb_cow_head(skb, overhead)) {\n\t\t \n\t\tdev_kfree_skb_any(skb);\n\t\treturn NULL;\n\t}\n\n\ttx_cmd_b = (u32)skb->len;\n\ttx_cmd_a = tx_cmd_b | TX_CMD_A_FIRST_SEG_ | TX_CMD_A_LAST_SEG_;\n\n\tif (csum) {\n\t\tif (!smsc95xx_can_tx_checksum(skb)) {\n\t\t\t \n\t\t\tlong csstart = skb_checksum_start_offset(skb);\n\t\t\t__wsum calc = csum_partial(skb->data + csstart,\n\t\t\t\tskb->len - csstart, 0);\n\t\t\t*((__sum16 *)(skb->data + csstart\n\t\t\t\t+ skb->csum_offset)) = csum_fold(calc);\n\n\t\t\tcsum = false;\n\t\t} else {\n\t\t\tu32 csum_preamble = smsc95xx_calc_csum_preamble(skb);\n\t\t\tptr = skb_push(skb, 4);\n\t\t\tput_unaligned_le32(csum_preamble, ptr);\n\n\t\t\ttx_cmd_a += 4;\n\t\t\ttx_cmd_b += 4;\n\t\t\ttx_cmd_b |= TX_CMD_B_CSUM_ENABLE;\n\t\t}\n\t}\n\n\tptr = skb_push(skb, 8);\n\tput_unaligned_le32(tx_cmd_a, ptr);\n\tput_unaligned_le32(tx_cmd_b, ptr+4);\n\n\treturn skb;\n}\n\nstatic int smsc95xx_manage_power(struct usbnet *dev, int on)\n{\n\tstruct smsc95xx_priv *pdata = dev->driver_priv;\n\n\tdev->intf->needs_remote_wakeup = on;\n\n\tif (pdata->features & FEATURE_REMOTE_WAKEUP)\n\t\treturn 0;\n\n\t \n\tnetdev_info(dev->net, \"hardware isn't capable of remote wakeup\\n\");\n\n\tif (on)\n\t\tusb_autopm_get_interface_no_resume(dev->intf);\n\telse\n\t\tusb_autopm_put_interface(dev->intf);\n\n\treturn 0;\n}\n\nstatic const struct driver_info smsc95xx_info = {\n\t.description\t= \"smsc95xx USB 2.0 Ethernet\",\n\t.bind\t\t= smsc95xx_bind,\n\t.unbind\t\t= smsc95xx_unbind,\n\t.reset\t\t= smsc95xx_reset,\n\t.check_connect\t= smsc95xx_start_phy,\n\t.stop\t\t= smsc95xx_stop,\n\t.rx_fixup\t= smsc95xx_rx_fixup,\n\t.tx_fixup\t= smsc95xx_tx_fixup,\n\t.status\t\t= smsc95xx_status,\n\t.manage_power\t= smsc95xx_manage_power,\n\t.flags\t\t= FLAG_ETHER | FLAG_SEND_ZLP | FLAG_LINK_INTR,\n};\n\nstatic const struct usb_device_id products[] = {\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9500),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9505),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9E00),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9E01),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0xec00),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9900),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9901),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9902),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9903),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9904),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9905),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9906),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9907),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9908),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9909),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9530),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9730),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x0424, 0x9E08),\n\t\t.driver_info = (unsigned long) &smsc95xx_info,\n\t},\n\t{\n\t\t \n\t\tUSB_DEVICE(0x184F, 0x0051),\n\t\t.driver_info = (unsigned long)&smsc95xx_info,\n\t},\n\t{ },\t\t \n};\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver smsc95xx_driver = {\n\t.name\t\t= \"smsc95xx\",\n\t.id_table\t= products,\n\t.probe\t\t= usbnet_probe,\n\t.suspend\t= smsc95xx_suspend,\n\t.resume\t\t= smsc95xx_resume,\n\t.reset_resume\t= smsc95xx_reset_resume,\n\t.disconnect\t= usbnet_disconnect,\n\t.disable_hub_initiated_lpm = 1,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(smsc95xx_driver);\n\nMODULE_AUTHOR(\"Nancy Lin\");\nMODULE_AUTHOR(\"Steve Glendinning <steve.glendinning@shawell.net>\");\nMODULE_DESCRIPTION(\"SMSC95XX USB 2.0 Ethernet Devices\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}