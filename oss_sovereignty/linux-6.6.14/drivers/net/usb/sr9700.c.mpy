{
  "module_name": "sr9700.c",
  "hash_id": "20d2d5f00cb0e6b3b9d4954ce16d7ce5a5398b1407bfe1ff2840b8a4bf98a7ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/sr9700.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/stddef.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/usb.h>\n#include <linux/crc32.h>\n#include <linux/usb/usbnet.h>\n\n#include \"sr9700.h\"\n\nstatic int sr_read(struct usbnet *dev, u8 reg, u16 length, void *data)\n{\n\tint err;\n\n\terr = usbnet_read_cmd(dev, SR_RD_REGS, SR_REQ_RD_REG, 0, reg, data,\n\t\t\t      length);\n\tif ((err != length) && (err >= 0))\n\t\terr = -EINVAL;\n\treturn err;\n}\n\nstatic int sr_write(struct usbnet *dev, u8 reg, u16 length, void *data)\n{\n\tint err;\n\n\terr = usbnet_write_cmd(dev, SR_WR_REGS, SR_REQ_WR_REG, 0, reg, data,\n\t\t\t       length);\n\tif ((err >= 0) && (err < length))\n\t\terr = -EINVAL;\n\treturn err;\n}\n\nstatic int sr_read_reg(struct usbnet *dev, u8 reg, u8 *value)\n{\n\treturn sr_read(dev, reg, 1, value);\n}\n\nstatic int sr_write_reg(struct usbnet *dev, u8 reg, u8 value)\n{\n\treturn usbnet_write_cmd(dev, SR_WR_REGS, SR_REQ_WR_REG,\n\t\t\t\tvalue, reg, NULL, 0);\n}\n\nstatic void sr_write_async(struct usbnet *dev, u8 reg, u16 length,\n\t\t\t   const void *data)\n{\n\tusbnet_write_cmd_async(dev, SR_WR_REGS, SR_REQ_WR_REG,\n\t\t\t       0, reg, data, length);\n}\n\nstatic void sr_write_reg_async(struct usbnet *dev, u8 reg, u8 value)\n{\n\tusbnet_write_cmd_async(dev, SR_WR_REGS, SR_REQ_WR_REG,\n\t\t\t       value, reg, NULL, 0);\n}\n\nstatic int wait_phy_eeprom_ready(struct usbnet *dev, int phy)\n{\n\tint i;\n\n\tfor (i = 0; i < SR_SHARE_TIMEOUT; i++) {\n\t\tu8 tmp = 0;\n\t\tint ret;\n\n\t\tudelay(1);\n\t\tret = sr_read_reg(dev, SR_EPCR, &tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!(tmp & EPCR_ERRE))\n\t\t\treturn 0;\n\t}\n\n\tnetdev_err(dev->net, \"%s write timed out!\\n\", phy ? \"phy\" : \"eeprom\");\n\n\treturn -EIO;\n}\n\nstatic int sr_share_read_word(struct usbnet *dev, int phy, u8 reg,\n\t\t\t      __le16 *value)\n{\n\tint ret;\n\n\tmutex_lock(&dev->phy_mutex);\n\n\tsr_write_reg(dev, SR_EPAR, phy ? (reg | EPAR_PHY_ADR) : reg);\n\tsr_write_reg(dev, SR_EPCR, phy ? (EPCR_EPOS | EPCR_ERPRR) : EPCR_ERPRR);\n\n\tret = wait_phy_eeprom_ready(dev, phy);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tsr_write_reg(dev, SR_EPCR, 0x0);\n\tret = sr_read(dev, SR_EPDR, 2, value);\n\n\tnetdev_dbg(dev->net, \"read shared %d 0x%02x returned 0x%04x, %d\\n\",\n\t\t   phy, reg, *value, ret);\n\nout_unlock:\n\tmutex_unlock(&dev->phy_mutex);\n\treturn ret;\n}\n\nstatic int sr_share_write_word(struct usbnet *dev, int phy, u8 reg,\n\t\t\t       __le16 value)\n{\n\tint ret;\n\n\tmutex_lock(&dev->phy_mutex);\n\n\tret = sr_write(dev, SR_EPDR, 2, &value);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tsr_write_reg(dev, SR_EPAR, phy ? (reg | EPAR_PHY_ADR) : reg);\n\tsr_write_reg(dev, SR_EPCR, phy ? (EPCR_WEP | EPCR_EPOS | EPCR_ERPRW) :\n\t\t    (EPCR_WEP | EPCR_ERPRW));\n\n\tret = wait_phy_eeprom_ready(dev, phy);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tsr_write_reg(dev, SR_EPCR, 0x0);\n\nout_unlock:\n\tmutex_unlock(&dev->phy_mutex);\n\treturn ret;\n}\n\nstatic int sr_read_eeprom_word(struct usbnet *dev, u8 offset, void *value)\n{\n\treturn sr_share_read_word(dev, 0, offset, value);\n}\n\nstatic int sr9700_get_eeprom_len(struct net_device *netdev)\n{\n\treturn SR_EEPROM_LEN;\n}\n\nstatic int sr9700_get_eeprom(struct net_device *netdev,\n\t\t\t     struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\t__le16 *buf = (__le16 *)data;\n\tint ret = 0;\n\tint i;\n\n\t \n\tif ((eeprom->offset & 0x01) || (eeprom->len & 0x01))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < eeprom->len / 2; i++) {\n\t\tret = sr_read_eeprom_word(dev, eeprom->offset / 2 + i, buf + i);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int sr_mdio_read(struct net_device *netdev, int phy_id, int loc)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\t__le16 res;\n\tint rc = 0;\n\n\tif (phy_id) {\n\t\tnetdev_dbg(netdev, \"Only internal phy supported\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (loc == MII_BMSR) {\n\t\tu8 value;\n\n\t\tsr_read_reg(dev, SR_NSR, &value);\n\t\tif (value & NSR_LINKST)\n\t\t\trc = 1;\n\t}\n\tsr_share_read_word(dev, 1, loc, &res);\n\tif (rc == 1)\n\t\tres = le16_to_cpu(res) | BMSR_LSTATUS;\n\telse\n\t\tres = le16_to_cpu(res) & ~BMSR_LSTATUS;\n\n\tnetdev_dbg(netdev, \"sr_mdio_read() phy_id=0x%02x, loc=0x%02x, returns=0x%04x\\n\",\n\t\t   phy_id, loc, res);\n\n\treturn res;\n}\n\nstatic void sr_mdio_write(struct net_device *netdev, int phy_id, int loc,\n\t\t\t  int val)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\t__le16 res = cpu_to_le16(val);\n\n\tif (phy_id) {\n\t\tnetdev_dbg(netdev, \"Only internal phy supported\\n\");\n\t\treturn;\n\t}\n\n\tnetdev_dbg(netdev, \"sr_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\\n\",\n\t\t   phy_id, loc, val);\n\n\tsr_share_write_word(dev, 1, loc, res);\n}\n\nstatic u32 sr9700_get_link(struct net_device *netdev)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tu8 value = 0;\n\tint rc = 0;\n\n\t \n\tsr_read_reg(dev, SR_NSR, &value);\n\tif (value & NSR_LINKST)\n\t\trc = 1;\n\n\treturn rc;\n}\n\nstatic int sr9700_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\n\treturn generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);\n}\n\nstatic const struct ethtool_ops sr9700_ethtool_ops = {\n\t.get_drvinfo\t= usbnet_get_drvinfo,\n\t.get_link\t= sr9700_get_link,\n\t.get_msglevel\t= usbnet_get_msglevel,\n\t.set_msglevel\t= usbnet_set_msglevel,\n\t.get_eeprom_len\t= sr9700_get_eeprom_len,\n\t.get_eeprom\t= sr9700_get_eeprom,\n\t.nway_reset\t= usbnet_nway_reset,\n\t.get_link_ksettings\t= usbnet_get_link_ksettings_mii,\n\t.set_link_ksettings\t= usbnet_set_link_ksettings_mii,\n};\n\nstatic void sr9700_set_multicast(struct net_device *netdev)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\t \n\tu8 *hashes = (u8 *)&dev->data;\n\t \n\tu8 rx_ctl = RCR_RXEN | RCR_DIS_CRC | RCR_DIS_LONG;\n\n\tmemset(hashes, 0x00, SR_MCAST_SIZE);\n\t \n\thashes[SR_MCAST_SIZE - 1] |= SR_MCAST_ADDR_FLAG;\n\tif (netdev->flags & IFF_PROMISC) {\n\t\trx_ctl |= RCR_PRMSC;\n\t} else if (netdev->flags & IFF_ALLMULTI ||\n\t\t   netdev_mc_count(netdev) > SR_MCAST_MAX) {\n\t\trx_ctl |= RCR_RUNT;\n\t} else if (!netdev_mc_empty(netdev)) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\t\tu32 crc = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\t\t\thashes[crc >> 3] |= 1 << (crc & 0x7);\n\t\t}\n\t}\n\n\tsr_write_async(dev, SR_MAR, SR_MCAST_SIZE, hashes);\n\tsr_write_reg_async(dev, SR_RCR, rx_ctl);\n}\n\nstatic int sr9700_set_mac_address(struct net_device *netdev, void *p)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data)) {\n\t\tnetdev_err(netdev, \"not setting invalid mac address %pM\\n\",\n\t\t\t   addr->sa_data);\n\t\treturn -EINVAL;\n\t}\n\n\teth_hw_addr_set(netdev, addr->sa_data);\n\tsr_write_async(dev, SR_PAR, 6, netdev->dev_addr);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops sr9700_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_change_mtu\t\t= usbnet_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= sr9700_ioctl,\n\t.ndo_set_rx_mode\t= sr9700_set_multicast,\n\t.ndo_set_mac_address\t= sr9700_set_mac_address,\n};\n\nstatic int sr9700_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct net_device *netdev;\n\tstruct mii_if_info *mii;\n\tu8 addr[ETH_ALEN];\n\tint ret;\n\n\tret = usbnet_get_endpoints(dev, intf);\n\tif (ret)\n\t\tgoto out;\n\n\tnetdev = dev->net;\n\n\tnetdev->netdev_ops = &sr9700_netdev_ops;\n\tnetdev->ethtool_ops = &sr9700_ethtool_ops;\n\tnetdev->hard_header_len += SR_TX_OVERHEAD;\n\tdev->hard_mtu = netdev->mtu + netdev->hard_header_len;\n\t \n\tdev->rx_urb_size = 3072;\n\n\tmii = &dev->mii;\n\tmii->dev = netdev;\n\tmii->mdio_read = sr_mdio_read;\n\tmii->mdio_write = sr_mdio_write;\n\tmii->phy_id_mask = 0x1f;\n\tmii->reg_num_mask = 0x1f;\n\n\tsr_write_reg(dev, SR_NCR, NCR_RST);\n\tudelay(20);\n\n\t \n\tif (sr_read(dev, SR_PAR, ETH_ALEN, addr) < 0) {\n\t\tnetdev_err(netdev, \"Error reading MAC address\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\teth_hw_addr_set(netdev, addr);\n\n\t \n\tsr_write_reg(dev, SR_PRR, PRR_PHY_RST);\n\t \n\tmsleep(20);\n\tsr_write_reg(dev, SR_PRR, 0);\n\t \n\tudelay(2 * 1000);\n\n\t \n\tsr9700_set_multicast(netdev);\n\n\tsr_mdio_write(netdev, mii->phy_id, MII_BMCR, BMCR_RESET);\n\tsr_mdio_write(netdev, mii->phy_id, MII_ADVERTISE, ADVERTISE_ALL |\n\t\t      ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);\n\tmii_nway_restart(mii);\n\nout:\n\treturn ret;\n}\n\nstatic int sr9700_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct sk_buff *sr_skb;\n\tint len;\n\n\t \n\tif (unlikely(skb->len < SR_RX_OVERHEAD)) {\n\t\tnetdev_err(dev->net, \"unexpected tiny rx frame\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\twhile (skb->len > SR_RX_OVERHEAD) {\n\t\tif (skb->data[0] != 0x40)\n\t\t\treturn 0;\n\n\t\t \n\t\tlen = (skb->data[1] | (skb->data[2] << 8)) - 4;\n\n\t\tif (len > ETH_FRAME_LEN || len > skb->len || len < 0)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (skb->len == (len + SR_RX_OVERHEAD))\t{\n\t\t\tskb_pull(skb, 3);\n\t\t\tskb->len = len;\n\t\t\tskb_set_tail_pointer(skb, len);\n\t\t\tskb->truesize = len + sizeof(struct sk_buff);\n\t\t\treturn 2;\n\t\t}\n\n\t\t \n\t\tsr_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!sr_skb)\n\t\t\treturn 0;\n\n\t\tsr_skb->len = len;\n\t\tsr_skb->data = skb->data + 3;\n\t\tskb_set_tail_pointer(sr_skb, len);\n\t\tsr_skb->truesize = len + sizeof(struct sk_buff);\n\t\tusbnet_skb_return(dev, sr_skb);\n\n\t\tskb_pull(skb, len + SR_RX_OVERHEAD);\n\t}\n\n\treturn 0;\n}\n\nstatic struct sk_buff *sr9700_tx_fixup(struct usbnet *dev, struct sk_buff *skb,\n\t\t\t\t       gfp_t flags)\n{\n\tint len;\n\n\t \n\n\tlen = skb->len;\n\n\tif (skb_cow_head(skb, SR_TX_OVERHEAD)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NULL;\n\t}\n\n\t__skb_push(skb, SR_TX_OVERHEAD);\n\n\t \n\tif ((skb->len % dev->maxpacket) == 0)\n\t\tlen++;\n\n\tskb->data[0] = len;\n\tskb->data[1] = len >> 8;\n\n\treturn skb;\n}\n\nstatic void sr9700_status(struct usbnet *dev, struct urb *urb)\n{\n\tint link;\n\tu8 *buf;\n\n\t \n\n\tif (urb->actual_length < 8)\n\t\treturn;\n\n\tbuf = urb->transfer_buffer;\n\n\tlink = !!(buf[0] & 0x40);\n\tif (netif_carrier_ok(dev->net) != link) {\n\t\tusbnet_link_change(dev, link, 1);\n\t\tnetdev_dbg(dev->net, \"Link Status is: %d\\n\", link);\n\t}\n}\n\nstatic int sr9700_link_reset(struct usbnet *dev)\n{\n\tstruct ethtool_cmd ecmd;\n\n\tmii_check_media(&dev->mii, 1, 1);\n\tmii_ethtool_gset(&dev->mii, &ecmd);\n\n\tnetdev_dbg(dev->net, \"link_reset() speed: %d duplex: %d\\n\",\n\t\t   ecmd.speed, ecmd.duplex);\n\n\treturn 0;\n}\n\nstatic const struct driver_info sr9700_driver_info = {\n\t.description\t= \"CoreChip SR9700 USB Ethernet\",\n\t.flags\t\t= FLAG_ETHER,\n\t.bind\t\t= sr9700_bind,\n\t.rx_fixup\t= sr9700_rx_fixup,\n\t.tx_fixup\t= sr9700_tx_fixup,\n\t.status\t\t= sr9700_status,\n\t.link_reset\t= sr9700_link_reset,\n\t.reset\t\t= sr9700_link_reset,\n};\n\nstatic const struct usb_device_id products[] = {\n\t{\n\t\tUSB_DEVICE(0x0fe6, 0x9700),\t \n\t\t.driver_info = (unsigned long)&sr9700_driver_info,\n\t},\n\t{},\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, products);\n\nstatic struct usb_driver sr9700_usb_driver = {\n\t.name\t\t= \"sr9700\",\n\t.id_table\t= products,\n\t.probe\t\t= usbnet_probe,\n\t.disconnect\t= usbnet_disconnect,\n\t.suspend\t= usbnet_suspend,\n\t.resume\t\t= usbnet_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(sr9700_usb_driver);\n\nMODULE_AUTHOR(\"liujl <liujunliang_ljl@163.com>\");\nMODULE_DESCRIPTION(\"SR9700 one chip USB 1.1 USB to Ethernet device from http://www.corechip-sz.com/\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}