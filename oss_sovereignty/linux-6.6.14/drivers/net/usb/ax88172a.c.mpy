{
  "module_name": "ax88172a.c",
  "hash_id": "61e802ecfdac792933389009e37195545054ac5851f5b75d0e9302facb102570",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/usb/ax88172a.c",
  "human_readable_source": "\n \n\n#include \"asix.h\"\n#include <linux/phy.h>\n\nstruct ax88172a_private {\n\tstruct mii_bus *mdio;\n\tstruct phy_device *phydev;\n\tchar phy_name[20];\n\tu16 phy_addr;\n\tu16 oldmode;\n\tint use_embdphy;\n\tstruct asix_rx_fixup_info rx_fixup_info;\n};\n\n \nstatic void ax88172a_adjust_link(struct net_device *netdev)\n{\n\tstruct phy_device *phydev = netdev->phydev;\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tstruct ax88172a_private *priv = dev->driver_priv;\n\tu16 mode = 0;\n\n\tif (phydev->link) {\n\t\tmode = AX88772_MEDIUM_DEFAULT;\n\n\t\tif (phydev->duplex == DUPLEX_HALF)\n\t\t\tmode &= ~AX_MEDIUM_FD;\n\n\t\tif (phydev->speed != SPEED_100)\n\t\t\tmode &= ~AX_MEDIUM_PS;\n\t}\n\n\tif (mode != priv->oldmode) {\n\t\tasix_write_medium_mode(dev, mode, 0);\n\t\tpriv->oldmode = mode;\n\t\tnetdev_dbg(netdev, \"speed %u duplex %d, setting mode to 0x%04x\\n\",\n\t\t\t   phydev->speed, phydev->duplex, mode);\n\t\tphy_print_status(phydev);\n\t}\n}\n\nstatic void ax88172a_status(struct usbnet *dev, struct urb *urb)\n{\n\t \n}\n\n \nstatic int ax88172a_init_mdio(struct usbnet *dev)\n{\n\tstruct ax88172a_private *priv = dev->driver_priv;\n\tint ret;\n\n\tpriv->mdio = mdiobus_alloc();\n\tif (!priv->mdio) {\n\t\tnetdev_err(dev->net, \"Could not allocate MDIO bus\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mdio->priv = (void *)dev;\n\tpriv->mdio->read = &asix_mdio_bus_read;\n\tpriv->mdio->write = &asix_mdio_bus_write;\n\tpriv->mdio->name = \"Asix MDIO Bus\";\n\t \n\tsnprintf(priv->mdio->id, MII_BUS_ID_SIZE, \"usb-%03d:%03d\",\n\t\t dev->udev->bus->busnum, dev->udev->devnum);\n\n\tret = mdiobus_register(priv->mdio);\n\tif (ret) {\n\t\tnetdev_err(dev->net, \"Could not register MDIO bus\\n\");\n\t\tgoto mfree;\n\t}\n\n\tnetdev_info(dev->net, \"registered mdio bus %s\\n\", priv->mdio->id);\n\treturn 0;\n\nmfree:\n\tmdiobus_free(priv->mdio);\n\treturn ret;\n}\n\nstatic void ax88172a_remove_mdio(struct usbnet *dev)\n{\n\tstruct ax88172a_private *priv = dev->driver_priv;\n\n\tnetdev_info(dev->net, \"deregistering mdio bus %s\\n\", priv->mdio->id);\n\tmdiobus_unregister(priv->mdio);\n\tmdiobus_free(priv->mdio);\n}\n\nstatic const struct net_device_ops ax88172a_netdev_ops = {\n\t.ndo_open\t\t= usbnet_open,\n\t.ndo_stop\t\t= usbnet_stop,\n\t.ndo_start_xmit\t\t= usbnet_start_xmit,\n\t.ndo_tx_timeout\t\t= usbnet_tx_timeout,\n\t.ndo_change_mtu\t\t= usbnet_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_set_mac_address\t= asix_set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_set_rx_mode        = asix_set_multicast,\n};\n\nstatic const struct ethtool_ops ax88172a_ethtool_ops = {\n\t.get_drvinfo\t\t= asix_get_drvinfo,\n\t.get_link\t\t= usbnet_get_link,\n\t.get_msglevel\t\t= usbnet_get_msglevel,\n\t.set_msglevel\t\t= usbnet_set_msglevel,\n\t.get_wol\t\t= asix_get_wol,\n\t.set_wol\t\t= asix_set_wol,\n\t.get_eeprom_len\t\t= asix_get_eeprom_len,\n\t.get_eeprom\t\t= asix_get_eeprom,\n\t.set_eeprom\t\t= asix_set_eeprom,\n\t.nway_reset\t\t= phy_ethtool_nway_reset,\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n};\n\nstatic int ax88172a_reset_phy(struct usbnet *dev, int embd_phy)\n{\n\tint ret;\n\n\tret = asix_sw_reset(dev, AX_SWRESET_IPPD, 0);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmsleep(150);\n\tret = asix_sw_reset(dev, AX_SWRESET_CLEAR, 0);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmsleep(150);\n\n\tret = asix_sw_reset(dev, embd_phy ? AX_SWRESET_IPRL : AX_SWRESET_IPPD,\n\t\t\t    0);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\n\nstatic int ax88172a_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tu8 buf[ETH_ALEN];\n\tstruct ax88172a_private *priv;\n\n\tret = usbnet_get_endpoints(dev, intf);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev->driver_priv = priv;\n\n\t \n\tret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID, 0, 0, ETH_ALEN, buf, 0);\n\tif (ret < ETH_ALEN) {\n\t\tnetdev_err(dev->net, \"Failed to read MAC address: %d\\n\", ret);\n\t\tret = -EIO;\n\t\tgoto free;\n\t}\n\teth_hw_addr_set(dev->net, buf);\n\n\tdev->net->netdev_ops = &ax88172a_netdev_ops;\n\tdev->net->ethtool_ops = &ax88172a_ethtool_ops;\n\n\t \n\tret = asix_read_cmd(dev, AX_CMD_SW_PHY_STATUS, 0, 0, 1, buf, 0);\n\tif (ret < 0) {\n\t\tnetdev_err(dev->net, \"Failed to read software interface selection register: %d\\n\",\n\t\t\t   ret);\n\t\tgoto free;\n\t}\n\n\tnetdev_dbg(dev->net, \"AX_CMD_SW_PHY_STATUS = 0x%02x\\n\", buf[0]);\n\tswitch (buf[0] & AX_PHY_SELECT_MASK) {\n\tcase AX_PHY_SELECT_INTERNAL:\n\t\tnetdev_dbg(dev->net, \"use internal phy\\n\");\n\t\tpriv->use_embdphy = 1;\n\t\tbreak;\n\tcase AX_PHY_SELECT_EXTERNAL:\n\t\tnetdev_dbg(dev->net, \"use external phy\\n\");\n\t\tpriv->use_embdphy = 0;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(dev->net, \"Interface mode not supported by driver\\n\");\n\t\tret = -ENOTSUPP;\n\t\tgoto free;\n\t}\n\n\tret = asix_read_phy_addr(dev, priv->use_embdphy);\n\tif (ret < 0)\n\t\tgoto free;\n\n\tpriv->phy_addr = ret;\n\n\tax88172a_reset_phy(dev, priv->use_embdphy);\n\n\t \n\tif (dev->driver_info->flags & FLAG_FRAMING_AX) {\n\t\t \n\t\tdev->rx_urb_size = 2048;\n\t}\n\n\t \n\tret = ax88172a_init_mdio(dev);\n\tif (ret)\n\t\tgoto free;\n\n\treturn 0;\n\nfree:\n\tkfree(priv);\n\treturn ret;\n}\n\nstatic int ax88172a_stop(struct usbnet *dev)\n{\n\tstruct ax88172a_private *priv = dev->driver_priv;\n\n\tnetdev_dbg(dev->net, \"Stopping interface\\n\");\n\n\tif (priv->phydev) {\n\t\tnetdev_info(dev->net, \"Disconnecting from phy %s\\n\",\n\t\t\t    priv->phy_name);\n\t\tphy_stop(priv->phydev);\n\t\tphy_disconnect(priv->phydev);\n\t}\n\n\treturn 0;\n}\n\nstatic void ax88172a_unbind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tstruct ax88172a_private *priv = dev->driver_priv;\n\n\tax88172a_remove_mdio(dev);\n\tkfree(priv);\n}\n\nstatic int ax88172a_reset(struct usbnet *dev)\n{\n\tstruct asix_data *data = (struct asix_data *)&dev->data;\n\tstruct ax88172a_private *priv = dev->driver_priv;\n\tint ret;\n\tu16 rx_ctl;\n\n\tax88172a_reset_phy(dev, priv->use_embdphy);\n\n\tmsleep(150);\n\trx_ctl = asix_read_rx_ctl(dev, 0);\n\tnetdev_dbg(dev->net, \"RX_CTL is 0x%04x after software reset\\n\", rx_ctl);\n\tret = asix_write_rx_ctl(dev, 0x0000, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trx_ctl = asix_read_rx_ctl(dev, 0);\n\tnetdev_dbg(dev->net, \"RX_CTL is 0x%04x setting to 0x0000\\n\", rx_ctl);\n\n\tmsleep(150);\n\n\tret = asix_write_cmd(dev, AX_CMD_WRITE_IPG0,\n\t\t\t     AX88772_IPG0_DEFAULT | AX88772_IPG1_DEFAULT,\n\t\t\t     AX88772_IPG2_DEFAULT, 0, NULL, 0);\n\tif (ret < 0) {\n\t\tnetdev_err(dev->net, \"Write IPG,IPG1,IPG2 failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(data->mac_addr, dev->net->dev_addr, ETH_ALEN);\n\tret = asix_write_cmd(dev, AX_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,\n\t\t\t     data->mac_addr, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trx_ctl = asix_read_rx_ctl(dev, 0);\n\tnetdev_dbg(dev->net, \"RX_CTL is 0x%04x after all initializations\\n\",\n\t\t   rx_ctl);\n\n\trx_ctl = asix_read_medium_status(dev, 0);\n\tnetdev_dbg(dev->net, \"Medium Status is 0x%04x after all initializations\\n\",\n\t\t   rx_ctl);\n\n\t \n\tsnprintf(priv->phy_name, 20, PHY_ID_FMT,\n\t\t priv->mdio->id, priv->phy_addr);\n\n\tpriv->phydev = phy_connect(dev->net, priv->phy_name,\n\t\t\t\t   &ax88172a_adjust_link,\n\t\t\t\t   PHY_INTERFACE_MODE_MII);\n\tif (IS_ERR(priv->phydev)) {\n\t\tnetdev_err(dev->net, \"Could not connect to PHY device %s\\n\",\n\t\t\t   priv->phy_name);\n\t\tret = PTR_ERR(priv->phydev);\n\t\tgoto out;\n\t}\n\n\tnetdev_info(dev->net, \"Connected to phy %s\\n\", priv->phy_name);\n\n\t \n\tgenphy_resume(priv->phydev);\n\tphy_start(priv->phydev);\n\n\treturn 0;\n\nout:\n\treturn ret;\n\n}\n\nstatic int ax88172a_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct ax88172a_private *dp = dev->driver_priv;\n\tstruct asix_rx_fixup_info *rx = &dp->rx_fixup_info;\n\n\treturn asix_rx_fixup_internal(dev, skb, rx);\n}\n\nconst struct driver_info ax88172a_info = {\n\t.description = \"ASIX AX88172A USB 2.0 Ethernet\",\n\t.bind = ax88172a_bind,\n\t.reset = ax88172a_reset,\n\t.stop = ax88172a_stop,\n\t.unbind = ax88172a_unbind,\n\t.status = ax88172a_status,\n\t.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR |\n\t\t FLAG_MULTI_PACKET,\n\t.rx_fixup = ax88172a_rx_fixup,\n\t.tx_fixup = asix_tx_fixup,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}