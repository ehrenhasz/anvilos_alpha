{
  "module_name": "mdio-thunder.c",
  "hash_id": "bd4c7963f9209f25385e56c9f0dcc7843bab74e37443a87bd60ab4989159d1c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-thunder.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/gfp.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_mdio.h>\n#include <linux/pci.h>\n#include <linux/phy.h>\n\n#include \"mdio-cavium.h\"\n\nstruct thunder_mdiobus_nexus {\n\tvoid __iomem *bar0;\n\tstruct cavium_mdiobus *buses[4];\n};\n\nstatic int thunder_mdiobus_pci_probe(struct pci_dev *pdev,\n\t\t\t\t     const struct pci_device_id *ent)\n{\n\tstruct device_node *node;\n\tstruct fwnode_handle *fwn;\n\tstruct thunder_mdiobus_nexus *nexus;\n\tint err;\n\tint i;\n\n\tnexus = devm_kzalloc(&pdev->dev, sizeof(*nexus), GFP_KERNEL);\n\tif (!nexus)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(pdev, nexus);\n\n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to enable PCI device\\n\");\n\t\tpci_set_drvdata(pdev, NULL);\n\t\treturn err;\n\t}\n\n\terr = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"pci_request_regions failed\\n\");\n\t\tgoto err_disable_device;\n\t}\n\n\tnexus->bar0 = pcim_iomap(pdev, 0, pci_resource_len(pdev, 0));\n\tif (!nexus->bar0) {\n\t\terr = -ENOMEM;\n\t\tgoto err_release_regions;\n\t}\n\n\ti = 0;\n\tdevice_for_each_child_node(&pdev->dev, fwn) {\n\t\tstruct resource r;\n\t\tstruct mii_bus *mii_bus;\n\t\tstruct cavium_mdiobus *bus;\n\t\tunion cvmx_smix_en smi_en;\n\n\t\t \n\t\tnode = to_of_node(fwn);\n\t\tif (!node)\n\t\t\tbreak;\n\n\t\terr = of_address_to_resource(node, 0, &r);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Couldn't translate address for \\\"%pOFn\\\"\\n\",\n\t\t\t\tnode);\n\t\t\tbreak;\n\t\t}\n\n\t\tmii_bus = devm_mdiobus_alloc_size(&pdev->dev, sizeof(*bus));\n\t\tif (!mii_bus)\n\t\t\tbreak;\n\t\tbus = mii_bus->priv;\n\t\tbus->mii_bus = mii_bus;\n\n\t\tnexus->buses[i] = bus;\n\t\ti++;\n\n\t\tbus->register_base = nexus->bar0 +\n\t\t\tr.start - pci_resource_start(pdev, 0);\n\n\t\tsmi_en.u64 = 0;\n\t\tsmi_en.s.en = 1;\n\t\toct_mdio_writeq(smi_en.u64, bus->register_base + SMI_EN);\n\t\tbus->mii_bus->name = KBUILD_MODNAME;\n\t\tsnprintf(bus->mii_bus->id, MII_BUS_ID_SIZE, \"%llx\", r.start);\n\t\tbus->mii_bus->parent = &pdev->dev;\n\t\tbus->mii_bus->read = cavium_mdiobus_read_c22;\n\t\tbus->mii_bus->write = cavium_mdiobus_write_c22;\n\t\tbus->mii_bus->read_c45 = cavium_mdiobus_read_c45;\n\t\tbus->mii_bus->write_c45 = cavium_mdiobus_write_c45;\n\n\t\terr = of_mdiobus_register(bus->mii_bus, node);\n\t\tif (err)\n\t\t\tdev_err(&pdev->dev, \"of_mdiobus_register failed\\n\");\n\n\t\tdev_info(&pdev->dev, \"Added bus at %llx\\n\", r.start);\n\t\tif (i >= ARRAY_SIZE(nexus->buses))\n\t\t\tbreak;\n\t}\n\tfwnode_handle_put(fwn);\n\treturn 0;\n\nerr_release_regions:\n\tpci_release_regions(pdev);\n\nerr_disable_device:\n\tpci_set_drvdata(pdev, NULL);\n\treturn err;\n}\n\nstatic void thunder_mdiobus_pci_remove(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct thunder_mdiobus_nexus *nexus = pci_get_drvdata(pdev);\n\n\tfor (i = 0; i < ARRAY_SIZE(nexus->buses); i++) {\n\t\tstruct cavium_mdiobus *bus = nexus->buses[i];\n\n\t\tif (!bus)\n\t\t\tcontinue;\n\n\t\tmdiobus_unregister(bus->mii_bus);\n\t\toct_mdio_writeq(0, bus->register_base + SMI_EN);\n\t}\n\tpci_release_regions(pdev);\n\tpci_set_drvdata(pdev, NULL);\n}\n\nstatic const struct pci_device_id thunder_mdiobus_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, 0xa02b) },\n\t{ 0, }  \n};\nMODULE_DEVICE_TABLE(pci, thunder_mdiobus_id_table);\n\nstatic struct pci_driver thunder_mdiobus_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = thunder_mdiobus_id_table,\n\t.probe = thunder_mdiobus_pci_probe,\n\t.remove = thunder_mdiobus_pci_remove,\n};\n\nmodule_pci_driver(thunder_mdiobus_driver);\n\nMODULE_DESCRIPTION(\"Cavium ThunderX MDIO bus driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}