{
  "module_name": "mdio-cavium.c",
  "hash_id": "d5d95d379712dc83acc657b3a11a234238a7023bb0b9c0eca1fe827842651273",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-cavium.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/phy.h>\n\n#include \"mdio-cavium.h\"\n\nstatic void cavium_mdiobus_set_mode(struct cavium_mdiobus *p,\n\t\t\t\t    enum cavium_mdiobus_mode m)\n{\n\tunion cvmx_smix_clk smi_clk;\n\n\tif (m == p->mode)\n\t\treturn;\n\n\tsmi_clk.u64 = oct_mdio_readq(p->register_base + SMI_CLK);\n\tsmi_clk.s.mode = (m == C45) ? 1 : 0;\n\tsmi_clk.s.preamble = 1;\n\toct_mdio_writeq(smi_clk.u64, p->register_base + SMI_CLK);\n\tp->mode = m;\n}\n\nstatic int cavium_mdiobus_c45_addr(struct cavium_mdiobus *p,\n\t\t\t\t   int phy_id, int devad, int regnum)\n{\n\tunion cvmx_smix_cmd smi_cmd;\n\tunion cvmx_smix_wr_dat smi_wr;\n\tint timeout = 1000;\n\n\tcavium_mdiobus_set_mode(p, C45);\n\n\tsmi_wr.u64 = 0;\n\tsmi_wr.s.dat = regnum & 0xffff;\n\toct_mdio_writeq(smi_wr.u64, p->register_base + SMI_WR_DAT);\n\n\tsmi_cmd.u64 = 0;\n\tsmi_cmd.s.phy_op = 0;  \n\tsmi_cmd.s.phy_adr = phy_id;\n\tsmi_cmd.s.reg_adr = devad;\n\toct_mdio_writeq(smi_cmd.u64, p->register_base + SMI_CMD);\n\n\tdo {\n\t\t \n\t\t__delay(1000);\n\t\tsmi_wr.u64 = oct_mdio_readq(p->register_base + SMI_WR_DAT);\n\t} while (smi_wr.s.pending && --timeout);\n\n\tif (timeout <= 0)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nint cavium_mdiobus_read_c22(struct mii_bus *bus, int phy_id, int regnum)\n{\n\tstruct cavium_mdiobus *p = bus->priv;\n\tunion cvmx_smix_cmd smi_cmd;\n\tunion cvmx_smix_rd_dat smi_rd;\n\tint timeout = 1000;\n\n\tcavium_mdiobus_set_mode(p, C22);\n\n\tsmi_cmd.u64 = 0;\n\tsmi_cmd.s.phy_op = 1;  \n\tsmi_cmd.s.phy_adr = phy_id;\n\tsmi_cmd.s.reg_adr = regnum;\n\toct_mdio_writeq(smi_cmd.u64, p->register_base + SMI_CMD);\n\n\tdo {\n\t\t \n\t\t__delay(1000);\n\t\tsmi_rd.u64 = oct_mdio_readq(p->register_base + SMI_RD_DAT);\n\t} while (smi_rd.s.pending && --timeout);\n\n\tif (smi_rd.s.val)\n\t\treturn smi_rd.s.dat;\n\telse\n\t\treturn -EIO;\n}\nEXPORT_SYMBOL(cavium_mdiobus_read_c22);\n\nint cavium_mdiobus_read_c45(struct mii_bus *bus, int phy_id, int devad,\n\t\t\t    int regnum)\n{\n\tstruct cavium_mdiobus *p = bus->priv;\n\tunion cvmx_smix_cmd smi_cmd;\n\tunion cvmx_smix_rd_dat smi_rd;\n\tint timeout = 1000;\n\tint r;\n\n\tr = cavium_mdiobus_c45_addr(p, phy_id, devad, regnum);\n\tif (r < 0)\n\t\treturn r;\n\n\tsmi_cmd.u64 = 0;\n\tsmi_cmd.s.phy_op = 3;  \n\tsmi_cmd.s.phy_adr = phy_id;\n\tsmi_cmd.s.reg_adr = regnum;\n\toct_mdio_writeq(smi_cmd.u64, p->register_base + SMI_CMD);\n\n\tdo {\n\t\t \n\t\t__delay(1000);\n\t\tsmi_rd.u64 = oct_mdio_readq(p->register_base + SMI_RD_DAT);\n\t} while (smi_rd.s.pending && --timeout);\n\n\tif (smi_rd.s.val)\n\t\treturn smi_rd.s.dat;\n\telse\n\t\treturn -EIO;\n}\nEXPORT_SYMBOL(cavium_mdiobus_read_c45);\n\nint cavium_mdiobus_write_c22(struct mii_bus *bus, int phy_id, int regnum,\n\t\t\t     u16 val)\n{\n\tstruct cavium_mdiobus *p = bus->priv;\n\tunion cvmx_smix_cmd smi_cmd;\n\tunion cvmx_smix_wr_dat smi_wr;\n\tint timeout = 1000;\n\n\tcavium_mdiobus_set_mode(p, C22);\n\n\tsmi_wr.u64 = 0;\n\tsmi_wr.s.dat = val;\n\toct_mdio_writeq(smi_wr.u64, p->register_base + SMI_WR_DAT);\n\n\tsmi_cmd.u64 = 0;\n\tsmi_cmd.s.phy_op = 0;  \n\tsmi_cmd.s.phy_adr = phy_id;\n\tsmi_cmd.s.reg_adr = regnum;\n\toct_mdio_writeq(smi_cmd.u64, p->register_base + SMI_CMD);\n\n\tdo {\n\t\t \n\t\t__delay(1000);\n\t\tsmi_wr.u64 = oct_mdio_readq(p->register_base + SMI_WR_DAT);\n\t} while (smi_wr.s.pending && --timeout);\n\n\tif (timeout <= 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cavium_mdiobus_write_c22);\n\nint cavium_mdiobus_write_c45(struct mii_bus *bus, int phy_id, int devad,\n\t\t\t     int regnum, u16 val)\n{\n\tstruct cavium_mdiobus *p = bus->priv;\n\tunion cvmx_smix_cmd smi_cmd;\n\tunion cvmx_smix_wr_dat smi_wr;\n\tint timeout = 1000;\n\tint r;\n\n\tr = cavium_mdiobus_c45_addr(p, phy_id, devad, regnum);\n\tif (r < 0)\n\t\treturn r;\n\n\tsmi_wr.u64 = 0;\n\tsmi_wr.s.dat = val;\n\toct_mdio_writeq(smi_wr.u64, p->register_base + SMI_WR_DAT);\n\n\tsmi_cmd.u64 = 0;\n\tsmi_cmd.s.phy_op = 1;  \n\tsmi_cmd.s.phy_adr = phy_id;\n\tsmi_cmd.s.reg_adr = devad;\n\toct_mdio_writeq(smi_cmd.u64, p->register_base + SMI_CMD);\n\n\tdo {\n\t\t \n\t\t__delay(1000);\n\t\tsmi_wr.u64 = oct_mdio_readq(p->register_base + SMI_WR_DAT);\n\t} while (smi_wr.s.pending && --timeout);\n\n\tif (timeout <= 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cavium_mdiobus_write_c45);\n\nMODULE_DESCRIPTION(\"Common code for OCTEON and Thunder MDIO bus drivers\");\nMODULE_AUTHOR(\"David Daney\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}