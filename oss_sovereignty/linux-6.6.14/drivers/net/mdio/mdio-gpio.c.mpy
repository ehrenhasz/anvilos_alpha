{
  "module_name": "mdio-gpio.c",
  "hash_id": "14280ee8781026a8ae462ccbab958d59e17788d956a8cbfdf29c55af868a7033",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/mdio-bitbang.h>\n#include <linux/mdio-gpio.h>\n#include <linux/module.h>\n#include <linux/of_mdio.h>\n#include <linux/platform_data/mdio-gpio.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\nstruct mdio_gpio_info {\n\tstruct mdiobb_ctrl ctrl;\n\tstruct gpio_desc *mdc, *mdio, *mdo;\n};\n\nstatic int mdio_gpio_get_data(struct device *dev,\n\t\t\t      struct mdio_gpio_info *bitbang)\n{\n\tbitbang->mdc = devm_gpiod_get_index(dev, NULL, MDIO_GPIO_MDC,\n\t\t\t\t\t    GPIOD_OUT_LOW);\n\tif (IS_ERR(bitbang->mdc))\n\t\treturn PTR_ERR(bitbang->mdc);\n\n\tbitbang->mdio = devm_gpiod_get_index(dev, NULL, MDIO_GPIO_MDIO,\n\t\t\t\t\t     GPIOD_IN);\n\tif (IS_ERR(bitbang->mdio))\n\t\treturn PTR_ERR(bitbang->mdio);\n\n\tbitbang->mdo = devm_gpiod_get_index_optional(dev, NULL, MDIO_GPIO_MDO,\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\treturn PTR_ERR_OR_ZERO(bitbang->mdo);\n}\n\nstatic void mdio_dir(struct mdiobb_ctrl *ctrl, int dir)\n{\n\tstruct mdio_gpio_info *bitbang =\n\t\tcontainer_of(ctrl, struct mdio_gpio_info, ctrl);\n\n\tif (bitbang->mdo) {\n\t\t \n\t\tgpiod_set_value_cansleep(bitbang->mdo, 1);\n\t\treturn;\n\t}\n\n\tif (dir)\n\t\tgpiod_direction_output(bitbang->mdio, 1);\n\telse\n\t\tgpiod_direction_input(bitbang->mdio);\n}\n\nstatic int mdio_get(struct mdiobb_ctrl *ctrl)\n{\n\tstruct mdio_gpio_info *bitbang =\n\t\tcontainer_of(ctrl, struct mdio_gpio_info, ctrl);\n\n\treturn gpiod_get_value_cansleep(bitbang->mdio);\n}\n\nstatic void mdio_set(struct mdiobb_ctrl *ctrl, int what)\n{\n\tstruct mdio_gpio_info *bitbang =\n\t\tcontainer_of(ctrl, struct mdio_gpio_info, ctrl);\n\n\tif (bitbang->mdo)\n\t\tgpiod_set_value_cansleep(bitbang->mdo, what);\n\telse\n\t\tgpiod_set_value_cansleep(bitbang->mdio, what);\n}\n\nstatic void mdc_set(struct mdiobb_ctrl *ctrl, int what)\n{\n\tstruct mdio_gpio_info *bitbang =\n\t\tcontainer_of(ctrl, struct mdio_gpio_info, ctrl);\n\n\tgpiod_set_value_cansleep(bitbang->mdc, what);\n}\n\nstatic const struct mdiobb_ops mdio_gpio_ops = {\n\t.owner = THIS_MODULE,\n\t.set_mdc = mdc_set,\n\t.set_mdio_dir = mdio_dir,\n\t.set_mdio_data = mdio_set,\n\t.get_mdio_data = mdio_get,\n};\n\nstatic struct mii_bus *mdio_gpio_bus_init(struct device *dev,\n\t\t\t\t\t  struct mdio_gpio_info *bitbang,\n\t\t\t\t\t  int bus_id)\n{\n\tstruct mdio_gpio_platform_data *pdata = dev_get_platdata(dev);\n\tstruct mii_bus *new_bus;\n\n\tbitbang->ctrl.ops = &mdio_gpio_ops;\n\n\tnew_bus = alloc_mdio_bitbang(&bitbang->ctrl);\n\tif (!new_bus)\n\t\treturn NULL;\n\n\tnew_bus->name = \"GPIO Bitbanged MDIO\";\n\tnew_bus->parent = dev;\n\n\tif (bus_id != -1)\n\t\tsnprintf(new_bus->id, MII_BUS_ID_SIZE, \"gpio-%x\", bus_id);\n\telse\n\t\tstrncpy(new_bus->id, \"gpio\", MII_BUS_ID_SIZE);\n\n\tif (pdata) {\n\t\tnew_bus->phy_mask = pdata->phy_mask;\n\t\tnew_bus->phy_ignore_ta_mask = pdata->phy_ignore_ta_mask;\n\t}\n\n\tif (dev->of_node &&\n\t    of_device_is_compatible(dev->of_node, \"microchip,mdio-smi0\")) {\n\t\tbitbang->ctrl.op_c22_read = 0;\n\t\tbitbang->ctrl.op_c22_write = 0;\n\t\tbitbang->ctrl.override_op_c22 = 1;\n\t}\n\n\tdev_set_drvdata(dev, new_bus);\n\n\treturn new_bus;\n}\n\nstatic void mdio_gpio_bus_deinit(struct device *dev)\n{\n\tstruct mii_bus *bus = dev_get_drvdata(dev);\n\n\tfree_mdio_bitbang(bus);\n}\n\nstatic void mdio_gpio_bus_destroy(struct device *dev)\n{\n\tstruct mii_bus *bus = dev_get_drvdata(dev);\n\n\tmdiobus_unregister(bus);\n\tmdio_gpio_bus_deinit(dev);\n}\n\nstatic int mdio_gpio_probe(struct platform_device *pdev)\n{\n\tstruct mdio_gpio_info *bitbang;\n\tstruct mii_bus *new_bus;\n\tint ret, bus_id;\n\n\tbitbang = devm_kzalloc(&pdev->dev, sizeof(*bitbang), GFP_KERNEL);\n\tif (!bitbang)\n\t\treturn -ENOMEM;\n\n\tret = mdio_gpio_get_data(&pdev->dev, bitbang);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pdev->dev.of_node) {\n\t\tbus_id = of_alias_get_id(pdev->dev.of_node, \"mdio-gpio\");\n\t\tif (bus_id < 0) {\n\t\t\tdev_warn(&pdev->dev, \"failed to get alias id\\n\");\n\t\t\tbus_id = 0;\n\t\t}\n\t} else {\n\t\tbus_id = pdev->id;\n\t}\n\n\tnew_bus = mdio_gpio_bus_init(&pdev->dev, bitbang, bus_id);\n\tif (!new_bus)\n\t\treturn -ENODEV;\n\n\tret = of_mdiobus_register(new_bus, pdev->dev.of_node);\n\tif (ret)\n\t\tmdio_gpio_bus_deinit(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic int mdio_gpio_remove(struct platform_device *pdev)\n{\n\tmdio_gpio_bus_destroy(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mdio_gpio_of_match[] = {\n\t{ .compatible = \"virtual,mdio-gpio\", },\n\t{ .compatible = \"microchip,mdio-smi0\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mdio_gpio_of_match);\n\nstatic struct platform_driver mdio_gpio_driver = {\n\t.probe = mdio_gpio_probe,\n\t.remove = mdio_gpio_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"mdio-gpio\",\n\t\t.of_match_table = mdio_gpio_of_match,\n\t},\n};\n\nmodule_platform_driver(mdio_gpio_driver);\n\nMODULE_ALIAS(\"platform:mdio-gpio\");\nMODULE_AUTHOR(\"Laurent Pinchart, Paulius Zaleckas\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Generic driver for MDIO bus emulation using GPIO\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}