{
  "module_name": "mdio-mux-mmioreg.c",
  "hash_id": "b07b4c95c230b083ebd4a89013d6c2642bc129ef013377829765715ec1f8f59e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-mux-mmioreg.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/mdio-mux.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n\nstruct mdio_mux_mmioreg_state {\n\tvoid *mux_handle;\n\tphys_addr_t phys;\n\tunsigned int iosize;\n\tunsigned int mask;\n};\n\n \nstatic int mdio_mux_mmioreg_switch_fn(int current_child, int desired_child,\n\t\t\t\t      void *data)\n{\n\tstruct mdio_mux_mmioreg_state *s = data;\n\n\tif (current_child ^ desired_child) {\n\t\tvoid __iomem *p = ioremap(s->phys, s->iosize);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\n\t\tswitch (s->iosize) {\n\t\tcase sizeof(uint8_t): {\n\t\t\tuint8_t x, y;\n\n\t\t\tx = ioread8(p);\n\t\t\ty = (x & ~s->mask) | desired_child;\n\t\t\tif (x != y) {\n\t\t\t\tiowrite8((x & ~s->mask) | desired_child, p);\n\t\t\t\tpr_debug(\"%s: %02x -> %02x\\n\", __func__, x, y);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\tcase sizeof(uint16_t): {\n\t\t\tuint16_t x, y;\n\n\t\t\tx = ioread16(p);\n\t\t\ty = (x & ~s->mask) | desired_child;\n\t\t\tif (x != y) {\n\t\t\t\tiowrite16((x & ~s->mask) | desired_child, p);\n\t\t\t\tpr_debug(\"%s: %04x -> %04x\\n\", __func__, x, y);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\tcase sizeof(uint32_t): {\n\t\t\tuint32_t x, y;\n\n\t\t\tx = ioread32(p);\n\t\t\ty = (x & ~s->mask) | desired_child;\n\t\t\tif (x != y) {\n\t\t\t\tiowrite32((x & ~s->mask) | desired_child, p);\n\t\t\t\tpr_debug(\"%s: %08x -> %08x\\n\", __func__, x, y);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\t}\n\n\t\tiounmap(p);\n\t}\n\n\treturn 0;\n}\n\nstatic int mdio_mux_mmioreg_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np2, *np = pdev->dev.of_node;\n\tstruct mdio_mux_mmioreg_state *s;\n\tstruct resource res;\n\tconst __be32 *iprop;\n\tint len, ret;\n\n\tdev_dbg(&pdev->dev, \"probing node %pOF\\n\", np);\n\n\ts = devm_kzalloc(&pdev->dev, sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tret = of_address_to_resource(np, 0, &res);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not obtain memory map for node %pOF\\n\",\n\t\t\tnp);\n\t\treturn ret;\n\t}\n\ts->phys = res.start;\n\n\ts->iosize = resource_size(&res);\n\tif (s->iosize != sizeof(uint8_t) &&\n\t    s->iosize != sizeof(uint16_t) &&\n\t    s->iosize != sizeof(uint32_t)) {\n\t\tdev_err(&pdev->dev, \"only 8/16/32-bit registers are supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tiprop = of_get_property(np, \"mux-mask\", &len);\n\tif (!iprop || len != sizeof(uint32_t)) {\n\t\tdev_err(&pdev->dev, \"missing or invalid mux-mask property\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (be32_to_cpup(iprop) >= BIT(s->iosize * 8)) {\n\t\tdev_err(&pdev->dev, \"only 8/16/32-bit registers are supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\ts->mask = be32_to_cpup(iprop);\n\n\t \n\tfor_each_available_child_of_node(np, np2) {\n\t\tu64 reg;\n\n\t\tif (of_property_read_reg(np2, 0, &reg, NULL)) {\n\t\t\tdev_err(&pdev->dev, \"mdio-mux child node %pOF is \"\n\t\t\t\t\"missing a 'reg' property\\n\", np2);\n\t\t\tof_node_put(np2);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif ((u32)reg & ~s->mask) {\n\t\t\tdev_err(&pdev->dev, \"mdio-mux child node %pOF has \"\n\t\t\t\t\"a 'reg' value with unmasked bits\\n\",\n\t\t\t\tnp2);\n\t\t\tof_node_put(np2);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tret = mdio_mux_init(&pdev->dev, pdev->dev.of_node,\n\t\t\t    mdio_mux_mmioreg_switch_fn,\n\t\t\t    &s->mux_handle, s, NULL);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"failed to register mdio-mux bus %pOF\\n\", np);\n\n\tpdev->dev.platform_data = s;\n\n\treturn 0;\n}\n\nstatic int mdio_mux_mmioreg_remove(struct platform_device *pdev)\n{\n\tstruct mdio_mux_mmioreg_state *s = dev_get_platdata(&pdev->dev);\n\n\tmdio_mux_uninit(s->mux_handle);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mdio_mux_mmioreg_match[] = {\n\t{\n\t\t.compatible = \"mdio-mux-mmioreg\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mdio_mux_mmioreg_match);\n\nstatic struct platform_driver mdio_mux_mmioreg_driver = {\n\t.driver = {\n\t\t.name\t\t= \"mdio-mux-mmioreg\",\n\t\t.of_match_table = mdio_mux_mmioreg_match,\n\t},\n\t.probe\t\t= mdio_mux_mmioreg_probe,\n\t.remove\t\t= mdio_mux_mmioreg_remove,\n};\n\nmodule_platform_driver(mdio_mux_mmioreg_driver);\n\nMODULE_AUTHOR(\"Timur Tabi <timur@freescale.com>\");\nMODULE_DESCRIPTION(\"Memory-mapped device MDIO MUX driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}