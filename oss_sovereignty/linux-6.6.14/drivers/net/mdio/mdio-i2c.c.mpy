{
  "module_name": "mdio-i2c.c",
  "hash_id": "4419ed4a17f6d2a3a3eb14db81cae671bda0d3d12343a05a673a21900fbf0518",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-i2c.c",
  "human_readable_source": "\n \n#include <linux/i2c.h>\n#include <linux/mdio/mdio-i2c.h>\n#include <linux/phy.h>\n#include <linux/sfp.h>\n\n \nstatic bool i2c_mii_valid_phy_id(int phy_id)\n{\n\treturn phy_id != 0x10 && phy_id != 0x11;\n}\n\nstatic unsigned int i2c_mii_phy_addr(int phy_id)\n{\n\treturn phy_id + 0x40;\n}\n\nstatic int i2c_mii_read_default_c45(struct mii_bus *bus, int phy_id, int devad,\n\t\t\t\t    int reg)\n{\n\tstruct i2c_adapter *i2c = bus->priv;\n\tstruct i2c_msg msgs[2];\n\tu8 addr[3], data[2], *p;\n\tint bus_addr, ret;\n\n\tif (!i2c_mii_valid_phy_id(phy_id))\n\t\treturn 0xffff;\n\n\tp = addr;\n\tif (devad >= 0) {\n\t\t*p++ = 0x20 | devad;\n\t\t*p++ = reg >> 8;\n\t}\n\t*p++ = reg;\n\n\tbus_addr = i2c_mii_phy_addr(phy_id);\n\tmsgs[0].addr = bus_addr;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = p - addr;\n\tmsgs[0].buf = addr;\n\tmsgs[1].addr = bus_addr;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[1].len = sizeof(data);\n\tmsgs[1].buf = data;\n\n\tret = i2c_transfer(i2c, msgs, ARRAY_SIZE(msgs));\n\tif (ret != ARRAY_SIZE(msgs))\n\t\treturn 0xffff;\n\n\treturn data[0] << 8 | data[1];\n}\n\nstatic int i2c_mii_write_default_c45(struct mii_bus *bus, int phy_id,\n\t\t\t\t     int devad, int reg, u16 val)\n{\n\tstruct i2c_adapter *i2c = bus->priv;\n\tstruct i2c_msg msg;\n\tint ret;\n\tu8 data[5], *p;\n\n\tif (!i2c_mii_valid_phy_id(phy_id))\n\t\treturn 0;\n\n\tp = data;\n\tif (devad >= 0) {\n\t\t*p++ = devad;\n\t\t*p++ = reg >> 8;\n\t}\n\t*p++ = reg;\n\t*p++ = val >> 8;\n\t*p++ = val;\n\n\tmsg.addr = i2c_mii_phy_addr(phy_id);\n\tmsg.flags = 0;\n\tmsg.len = p - data;\n\tmsg.buf = data;\n\n\tret = i2c_transfer(i2c, &msg, 1);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int i2c_mii_read_default_c22(struct mii_bus *bus, int phy_id, int reg)\n{\n\treturn i2c_mii_read_default_c45(bus, phy_id, -1, reg);\n}\n\nstatic int i2c_mii_write_default_c22(struct mii_bus *bus, int phy_id, int reg,\n\t\t\t\t     u16 val)\n{\n\treturn i2c_mii_write_default_c45(bus, phy_id, -1, reg, val);\n}\n\n \n#define ROLLBALL_PHY_I2C_ADDR\t\t0x51\n\n#define ROLLBALL_PASSWORD\t\t(SFP_VSL + 3)\n\n#define ROLLBALL_CMD_ADDR\t\t0x80\n#define ROLLBALL_DATA_ADDR\t\t0x81\n\n#define ROLLBALL_CMD_WRITE\t\t0x01\n#define ROLLBALL_CMD_READ\t\t0x02\n#define ROLLBALL_CMD_DONE\t\t0x04\n\n#define SFP_PAGE_ROLLBALL_MDIO\t\t3\n\nstatic int __i2c_transfer_err(struct i2c_adapter *i2c, struct i2c_msg *msgs,\n\t\t\t      int num)\n{\n\tint ret;\n\n\tret = __i2c_transfer(i2c, msgs, num);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != num)\n\t\treturn -EIO;\n\telse\n\t\treturn 0;\n}\n\nstatic int __i2c_rollball_get_page(struct i2c_adapter *i2c, int bus_addr,\n\t\t\t\t   u8 *page)\n{\n\tstruct i2c_msg msgs[2];\n\tu8 addr = SFP_PAGE;\n\n\tmsgs[0].addr = bus_addr;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = 1;\n\tmsgs[0].buf = &addr;\n\n\tmsgs[1].addr = bus_addr;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[1].len = 1;\n\tmsgs[1].buf = page;\n\n\treturn __i2c_transfer_err(i2c, msgs, 2);\n}\n\nstatic int __i2c_rollball_set_page(struct i2c_adapter *i2c, int bus_addr,\n\t\t\t\t   u8 page)\n{\n\tstruct i2c_msg msg;\n\tu8 buf[2];\n\n\tbuf[0] = SFP_PAGE;\n\tbuf[1] = page;\n\n\tmsg.addr = bus_addr;\n\tmsg.flags = 0;\n\tmsg.len = 2;\n\tmsg.buf = buf;\n\n\treturn __i2c_transfer_err(i2c, &msg, 1);\n}\n\n \nstatic int i2c_transfer_rollball(struct i2c_adapter *i2c,\n\t\t\t\t struct i2c_msg *msgs, int num)\n{\n\tint ret, main_err = 0;\n\tu8 saved_page;\n\n\ti2c_lock_bus(i2c, I2C_LOCK_SEGMENT);\n\n\t \n\tret = __i2c_rollball_get_page(i2c, msgs->addr, &saved_page);\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tret = __i2c_rollball_set_page(i2c, msgs->addr, SFP_PAGE_ROLLBALL_MDIO);\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tret = __i2c_transfer_err(i2c, msgs, num);\n\tif (ret)\n\t\tmain_err = ret;\n\n\t \n\tret = __i2c_rollball_set_page(i2c, msgs->addr, saved_page);\n\nunlock:\n\ti2c_unlock_bus(i2c, I2C_LOCK_SEGMENT);\n\n\treturn main_err ? : ret;\n}\n\nstatic int i2c_rollball_mii_poll(struct mii_bus *bus, int bus_addr, u8 *buf,\n\t\t\t\t size_t len)\n{\n\tstruct i2c_adapter *i2c = bus->priv;\n\tstruct i2c_msg msgs[2];\n\tu8 cmd_addr, tmp, *res;\n\tint i, ret;\n\n\tcmd_addr = ROLLBALL_CMD_ADDR;\n\n\tres = buf ? buf : &tmp;\n\tlen = buf ? len : 1;\n\n\tmsgs[0].addr = bus_addr;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = 1;\n\tmsgs[0].buf = &cmd_addr;\n\n\tmsgs[1].addr = bus_addr;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[1].len = len;\n\tmsgs[1].buf = res;\n\n\t \n\ti = 10;\n\tdo {\n\t\tmsleep(20);\n\n\t\tret = i2c_transfer_rollball(i2c, msgs, ARRAY_SIZE(msgs));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (*res == ROLLBALL_CMD_DONE)\n\t\t\treturn 0;\n\t} while (i-- > 0);\n\n\tdev_dbg(&bus->dev, \"poll timed out\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int i2c_rollball_mii_cmd(struct mii_bus *bus, int bus_addr, u8 cmd,\n\t\t\t\tu8 *data, size_t len)\n{\n\tstruct i2c_adapter *i2c = bus->priv;\n\tstruct i2c_msg msgs[2];\n\tu8 cmdbuf[2];\n\n\tcmdbuf[0] = ROLLBALL_CMD_ADDR;\n\tcmdbuf[1] = cmd;\n\n\tmsgs[0].addr = bus_addr;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = len;\n\tmsgs[0].buf = data;\n\n\tmsgs[1].addr = bus_addr;\n\tmsgs[1].flags = 0;\n\tmsgs[1].len = sizeof(cmdbuf);\n\tmsgs[1].buf = cmdbuf;\n\n\treturn i2c_transfer_rollball(i2c, msgs, ARRAY_SIZE(msgs));\n}\n\nstatic int i2c_mii_read_rollball(struct mii_bus *bus, int phy_id, int devad,\n\t\t\t\t int reg)\n{\n\tu8 buf[4], res[6];\n\tint bus_addr, ret;\n\tu16 val;\n\n\tbus_addr = i2c_mii_phy_addr(phy_id);\n\tif (bus_addr != ROLLBALL_PHY_I2C_ADDR)\n\t\treturn 0xffff;\n\n\tbuf[0] = ROLLBALL_DATA_ADDR;\n\tbuf[1] = devad;\n\tbuf[2] = (reg >> 8) & 0xff;\n\tbuf[3] = reg & 0xff;\n\n\tret = i2c_rollball_mii_cmd(bus, bus_addr, ROLLBALL_CMD_READ, buf,\n\t\t\t\t   sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_rollball_mii_poll(bus, bus_addr, res, sizeof(res));\n\tif (ret == -ETIMEDOUT)\n\t\treturn 0xffff;\n\telse if (ret < 0)\n\t\treturn ret;\n\n\tval = res[4] << 8 | res[5];\n\n\treturn val;\n}\n\nstatic int i2c_mii_write_rollball(struct mii_bus *bus, int phy_id, int devad,\n\t\t\t\t  int reg, u16 val)\n{\n\tint bus_addr, ret;\n\tu8 buf[6];\n\n\tbus_addr = i2c_mii_phy_addr(phy_id);\n\tif (bus_addr != ROLLBALL_PHY_I2C_ADDR)\n\t\treturn 0;\n\n\tbuf[0] = ROLLBALL_DATA_ADDR;\n\tbuf[1] = devad;\n\tbuf[2] = (reg >> 8) & 0xff;\n\tbuf[3] = reg & 0xff;\n\tbuf[4] = val >> 8;\n\tbuf[5] = val & 0xff;\n\n\tret = i2c_rollball_mii_cmd(bus, bus_addr, ROLLBALL_CMD_WRITE, buf,\n\t\t\t\t   sizeof(buf));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_rollball_mii_poll(bus, bus_addr, NULL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int i2c_mii_init_rollball(struct i2c_adapter *i2c)\n{\n\tstruct i2c_msg msg;\n\tu8 pw[5];\n\tint ret;\n\n\tpw[0] = ROLLBALL_PASSWORD;\n\tpw[1] = 0xff;\n\tpw[2] = 0xff;\n\tpw[3] = 0xff;\n\tpw[4] = 0xff;\n\n\tmsg.addr = ROLLBALL_PHY_I2C_ADDR;\n\tmsg.flags = 0;\n\tmsg.len = sizeof(pw);\n\tmsg.buf = pw;\n\n\tret = i2c_transfer(i2c, &msg, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != 1)\n\t\treturn -EIO;\n\telse\n\t\treturn 0;\n}\n\nstruct mii_bus *mdio_i2c_alloc(struct device *parent, struct i2c_adapter *i2c,\n\t\t\t       enum mdio_i2c_proto protocol)\n{\n\tstruct mii_bus *mii;\n\tint ret;\n\n\tif (!i2c_check_functionality(i2c, I2C_FUNC_I2C))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmii = mdiobus_alloc();\n\tif (!mii)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsnprintf(mii->id, MII_BUS_ID_SIZE, \"i2c:%s\", dev_name(parent));\n\tmii->parent = parent;\n\tmii->priv = i2c;\n\n\tswitch (protocol) {\n\tcase MDIO_I2C_ROLLBALL:\n\t\tret = i2c_mii_init_rollball(i2c);\n\t\tif (ret < 0) {\n\t\t\tdev_err(parent,\n\t\t\t\t\"Cannot initialize RollBall MDIO I2C protocol: %d\\n\",\n\t\t\t\tret);\n\t\t\tmdiobus_free(mii);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tmii->read_c45 = i2c_mii_read_rollball;\n\t\tmii->write_c45 = i2c_mii_write_rollball;\n\t\tbreak;\n\tdefault:\n\t\tmii->read = i2c_mii_read_default_c22;\n\t\tmii->write = i2c_mii_write_default_c22;\n\t\tmii->read_c45 = i2c_mii_read_default_c45;\n\t\tmii->write_c45 = i2c_mii_write_default_c45;\n\t\tbreak;\n\t}\n\n\treturn mii;\n}\nEXPORT_SYMBOL_GPL(mdio_i2c_alloc);\n\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"MDIO I2C bridge library\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}