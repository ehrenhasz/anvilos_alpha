{
  "module_name": "mdio-ipq4019.c",
  "hash_id": "25019fb750c6b3184bd7621809e03be8b14c665615b714d5e62550c7ab338e8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-ipq4019.c",
  "human_readable_source": "\n \n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n\n#define MDIO_MODE_REG\t\t\t\t0x40\n#define MDIO_ADDR_REG\t\t\t\t0x44\n#define MDIO_DATA_WRITE_REG\t\t\t0x48\n#define MDIO_DATA_READ_REG\t\t\t0x4c\n#define MDIO_CMD_REG\t\t\t\t0x50\n#define MDIO_CMD_ACCESS_BUSY\t\tBIT(16)\n#define MDIO_CMD_ACCESS_START\t\tBIT(8)\n#define MDIO_CMD_ACCESS_CODE_READ\t0\n#define MDIO_CMD_ACCESS_CODE_WRITE\t1\n#define MDIO_CMD_ACCESS_CODE_C45_ADDR\t0\n#define MDIO_CMD_ACCESS_CODE_C45_WRITE\t1\n#define MDIO_CMD_ACCESS_CODE_C45_READ\t2\n\n \n#define MDIO_MODE_C45\t\t\t\tBIT(8)\n\n#define IPQ4019_MDIO_TIMEOUT\t10000\n#define IPQ4019_MDIO_SLEEP\t\t10\n\n \n#define IPQ_MDIO_CLK_RATE\t100000000\n\n#define IPQ_PHY_SET_DELAY_US\t100000\n\nstruct ipq4019_mdio_data {\n\tvoid __iomem\t*membase;\n\tvoid __iomem *eth_ldo_rdy;\n\tstruct clk *mdio_clk;\n};\n\nstatic int ipq4019_mdio_wait_busy(struct mii_bus *bus)\n{\n\tstruct ipq4019_mdio_data *priv = bus->priv;\n\tunsigned int busy;\n\n\treturn readl_poll_timeout(priv->membase + MDIO_CMD_REG, busy,\n\t\t\t\t  (busy & MDIO_CMD_ACCESS_BUSY) == 0,\n\t\t\t\t  IPQ4019_MDIO_SLEEP, IPQ4019_MDIO_TIMEOUT);\n}\n\nstatic int ipq4019_mdio_read_c45(struct mii_bus *bus, int mii_id, int mmd,\n\t\t\t\t int reg)\n{\n\tstruct ipq4019_mdio_data *priv = bus->priv;\n\tunsigned int data;\n\tunsigned int cmd;\n\n\tif (ipq4019_mdio_wait_busy(bus))\n\t\treturn -ETIMEDOUT;\n\n\tdata = readl(priv->membase + MDIO_MODE_REG);\n\n\tdata |= MDIO_MODE_C45;\n\n\twritel(data, priv->membase + MDIO_MODE_REG);\n\n\t \n\twritel((mii_id << 8) | mmd, priv->membase + MDIO_ADDR_REG);\n\n\t \n\twritel(reg, priv->membase + MDIO_DATA_WRITE_REG);\n\n\tcmd = MDIO_CMD_ACCESS_START | MDIO_CMD_ACCESS_CODE_C45_ADDR;\n\n\t \n\twritel(cmd, priv->membase + MDIO_CMD_REG);\n\n\t \n\tif (ipq4019_mdio_wait_busy(bus))\n\t\treturn -ETIMEDOUT;\n\n\tcmd = MDIO_CMD_ACCESS_START | MDIO_CMD_ACCESS_CODE_C45_READ;\n\n\twritel(cmd, priv->membase + MDIO_CMD_REG);\n\n\tif (ipq4019_mdio_wait_busy(bus))\n\t\treturn -ETIMEDOUT;\n\n\t \n\treturn readl(priv->membase + MDIO_DATA_READ_REG);\n}\n\nstatic int ipq4019_mdio_read_c22(struct mii_bus *bus, int mii_id, int regnum)\n{\n\tstruct ipq4019_mdio_data *priv = bus->priv;\n\tunsigned int data;\n\tunsigned int cmd;\n\n\tif (ipq4019_mdio_wait_busy(bus))\n\t\treturn -ETIMEDOUT;\n\n\tdata = readl(priv->membase + MDIO_MODE_REG);\n\n\tdata &= ~MDIO_MODE_C45;\n\n\twritel(data, priv->membase + MDIO_MODE_REG);\n\n\t \n\twritel((mii_id << 8) | regnum, priv->membase + MDIO_ADDR_REG);\n\n\tcmd = MDIO_CMD_ACCESS_START | MDIO_CMD_ACCESS_CODE_READ;\n\n\t \n\twritel(cmd, priv->membase + MDIO_CMD_REG);\n\n\t \n\tif (ipq4019_mdio_wait_busy(bus))\n\t\treturn -ETIMEDOUT;\n\n\t \n\treturn readl(priv->membase + MDIO_DATA_READ_REG);\n}\n\nstatic int ipq4019_mdio_write_c45(struct mii_bus *bus, int mii_id, int mmd,\n\t\t\t\t  int reg, u16 value)\n{\n\tstruct ipq4019_mdio_data *priv = bus->priv;\n\tunsigned int data;\n\tunsigned int cmd;\n\n\tif (ipq4019_mdio_wait_busy(bus))\n\t\treturn -ETIMEDOUT;\n\n\tdata = readl(priv->membase + MDIO_MODE_REG);\n\n\tdata |= MDIO_MODE_C45;\n\n\twritel(data, priv->membase + MDIO_MODE_REG);\n\n\t \n\twritel((mii_id << 8) | mmd, priv->membase + MDIO_ADDR_REG);\n\n\t \n\twritel(reg, priv->membase + MDIO_DATA_WRITE_REG);\n\n\tcmd = MDIO_CMD_ACCESS_START | MDIO_CMD_ACCESS_CODE_C45_ADDR;\n\n\twritel(cmd, priv->membase + MDIO_CMD_REG);\n\n\tif (ipq4019_mdio_wait_busy(bus))\n\t\treturn -ETIMEDOUT;\n\n\t \n\twritel(value, priv->membase + MDIO_DATA_WRITE_REG);\n\n\tcmd = MDIO_CMD_ACCESS_START | MDIO_CMD_ACCESS_CODE_C45_WRITE;\n\twritel(cmd, priv->membase + MDIO_CMD_REG);\n\n\t \n\tif (ipq4019_mdio_wait_busy(bus))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int ipq4019_mdio_write_c22(struct mii_bus *bus, int mii_id, int regnum,\n\t\t\t\t  u16 value)\n{\n\tstruct ipq4019_mdio_data *priv = bus->priv;\n\tunsigned int data;\n\tunsigned int cmd;\n\n\tif (ipq4019_mdio_wait_busy(bus))\n\t\treturn -ETIMEDOUT;\n\n\t \n\tdata = readl(priv->membase + MDIO_MODE_REG);\n\n\tdata &= ~MDIO_MODE_C45;\n\n\twritel(data, priv->membase + MDIO_MODE_REG);\n\n\t \n\twritel((mii_id << 8) | regnum, priv->membase + MDIO_ADDR_REG);\n\n\t \n\twritel(value, priv->membase + MDIO_DATA_WRITE_REG);\n\n\t \n\tcmd = MDIO_CMD_ACCESS_START | MDIO_CMD_ACCESS_CODE_WRITE;\n\n\twritel(cmd, priv->membase + MDIO_CMD_REG);\n\n\t \n\tif (ipq4019_mdio_wait_busy(bus))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int ipq_mdio_reset(struct mii_bus *bus)\n{\n\tstruct ipq4019_mdio_data *priv = bus->priv;\n\tu32 val;\n\tint ret;\n\n\t \n\tif (priv->eth_ldo_rdy) {\n\t\tval = readl(priv->eth_ldo_rdy);\n\t\tval |= BIT(0);\n\t\twritel(val, priv->eth_ldo_rdy);\n\t\tfsleep(IPQ_PHY_SET_DELAY_US);\n\t}\n\n\t \n\tret = clk_set_rate(priv->mdio_clk, IPQ_MDIO_CLK_RATE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(priv->mdio_clk);\n\tif (ret == 0)\n\t\tmdelay(10);\n\n\treturn ret;\n}\n\nstatic int ipq4019_mdio_probe(struct platform_device *pdev)\n{\n\tstruct ipq4019_mdio_data *priv;\n\tstruct mii_bus *bus;\n\tstruct resource *res;\n\tint ret;\n\n\tbus = devm_mdiobus_alloc_size(&pdev->dev, sizeof(*priv));\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tpriv = bus->priv;\n\n\tpriv->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->membase))\n\t\treturn PTR_ERR(priv->membase);\n\n\tpriv->mdio_clk = devm_clk_get_optional(&pdev->dev, \"gcc_mdio_ahb_clk\");\n\tif (IS_ERR(priv->mdio_clk))\n\t\treturn PTR_ERR(priv->mdio_clk);\n\n\t \n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (res)\n\t\tpriv->eth_ldo_rdy = devm_ioremap_resource(&pdev->dev, res);\n\n\tbus->name = \"ipq4019_mdio\";\n\tbus->read = ipq4019_mdio_read_c22;\n\tbus->write = ipq4019_mdio_write_c22;\n\tbus->read_c45 = ipq4019_mdio_read_c45;\n\tbus->write_c45 = ipq4019_mdio_write_c45;\n\tbus->reset = ipq_mdio_reset;\n\tbus->parent = &pdev->dev;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, pdev->dev.of_node);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot register MDIO bus!\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, bus);\n\n\treturn 0;\n}\n\nstatic int ipq4019_mdio_remove(struct platform_device *pdev)\n{\n\tstruct mii_bus *bus = platform_get_drvdata(pdev);\n\n\tmdiobus_unregister(bus);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ipq4019_mdio_dt_ids[] = {\n\t{ .compatible = \"qcom,ipq4019-mdio\" },\n\t{ .compatible = \"qcom,ipq5018-mdio\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ipq4019_mdio_dt_ids);\n\nstatic struct platform_driver ipq4019_mdio_driver = {\n\t.probe = ipq4019_mdio_probe,\n\t.remove = ipq4019_mdio_remove,\n\t.driver = {\n\t\t.name = \"ipq4019-mdio\",\n\t\t.of_match_table = ipq4019_mdio_dt_ids,\n\t},\n};\n\nmodule_platform_driver(ipq4019_mdio_driver);\n\nMODULE_DESCRIPTION(\"ipq4019 MDIO interface driver\");\nMODULE_AUTHOR(\"Qualcomm Atheros\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}