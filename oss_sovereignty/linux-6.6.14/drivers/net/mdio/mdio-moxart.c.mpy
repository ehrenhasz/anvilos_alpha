{
  "module_name": "mdio-moxart.c",
  "hash_id": "d672c37489bbaba549a0b0464dba3264e5f1e8ef2b7c06c3ee0bc8225a9532b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-moxart.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_address.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n\n#define REG_PHY_CTRL            0\n#define REG_PHY_WRITE_DATA      4\n\n \n#define MIIWR                   BIT(27)  \n#define MIIRD                   BIT(26)\n#define REGAD_MASK              0x3e00000\n#define PHYAD_MASK              0x1f0000\n#define MIIRDATA_MASK           0xffff\n\n \n#define MIIWDATA_MASK           0xffff\n\nstruct moxart_mdio_data {\n\tvoid __iomem\t\t*base;\n};\n\nstatic int moxart_mdio_read(struct mii_bus *bus, int mii_id, int regnum)\n{\n\tstruct moxart_mdio_data *data = bus->priv;\n\tu32 ctrl = 0;\n\tunsigned int count = 5;\n\n\tdev_dbg(&bus->dev, \"%s\\n\", __func__);\n\n\tctrl |= MIIRD | ((mii_id << 16) & PHYAD_MASK) |\n\t\t((regnum << 21) & REGAD_MASK);\n\n\twritel(ctrl, data->base + REG_PHY_CTRL);\n\n\tdo {\n\t\tctrl = readl(data->base + REG_PHY_CTRL);\n\n\t\tif (!(ctrl & MIIRD))\n\t\t\treturn ctrl & MIIRDATA_MASK;\n\n\t\tmdelay(10);\n\t\tcount--;\n\t} while (count > 0);\n\n\tdev_dbg(&bus->dev, \"%s timed out\\n\", __func__);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int moxart_mdio_write(struct mii_bus *bus, int mii_id,\n\t\t\t     int regnum, u16 value)\n{\n\tstruct moxart_mdio_data *data = bus->priv;\n\tu32 ctrl = 0;\n\tunsigned int count = 5;\n\n\tdev_dbg(&bus->dev, \"%s\\n\", __func__);\n\n\tctrl |= MIIWR | ((mii_id << 16) & PHYAD_MASK) |\n\t\t((regnum << 21) & REGAD_MASK);\n\n\tvalue &= MIIWDATA_MASK;\n\n\twritel(value, data->base + REG_PHY_WRITE_DATA);\n\twritel(ctrl, data->base + REG_PHY_CTRL);\n\n\tdo {\n\t\tctrl = readl(data->base + REG_PHY_CTRL);\n\n\t\tif (!(ctrl & MIIWR))\n\t\t\treturn 0;\n\n\t\tmdelay(10);\n\t\tcount--;\n\t} while (count > 0);\n\n\tdev_dbg(&bus->dev, \"%s timed out\\n\", __func__);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int moxart_mdio_reset(struct mii_bus *bus)\n{\n\tint data, i;\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tdata = moxart_mdio_read(bus, i, MII_BMCR);\n\t\tif (data < 0)\n\t\t\tcontinue;\n\n\t\tdata |= BMCR_RESET;\n\t\tif (moxart_mdio_write(bus, i, MII_BMCR, data) < 0)\n\t\t\tcontinue;\n\t}\n\n\treturn 0;\n}\n\nstatic int moxart_mdio_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct mii_bus *bus;\n\tstruct moxart_mdio_data *data;\n\tint ret, i;\n\n\tbus = mdiobus_alloc_size(sizeof(*data));\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->name = \"MOXA ART Ethernet MII\";\n\tbus->read = &moxart_mdio_read;\n\tbus->write = &moxart_mdio_write;\n\tbus->reset = &moxart_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d-mii\", pdev->name, pdev->id);\n\tbus->parent = &pdev->dev;\n\n\t \n\tfor (i = 0; i < PHY_MAX_ADDR; i++)\n\t\tbus->irq[i] = PHY_MAC_INTERRUPT;\n\n\tdata = bus->priv;\n\tdata->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->base)) {\n\t\tret = PTR_ERR(data->base);\n\t\tgoto err_out_free_mdiobus;\n\t}\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret < 0)\n\t\tgoto err_out_free_mdiobus;\n\n\tplatform_set_drvdata(pdev, bus);\n\n\treturn 0;\n\nerr_out_free_mdiobus:\n\tmdiobus_free(bus);\n\treturn ret;\n}\n\nstatic int moxart_mdio_remove(struct platform_device *pdev)\n{\n\tstruct mii_bus *bus = platform_get_drvdata(pdev);\n\n\tmdiobus_unregister(bus);\n\tmdiobus_free(bus);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id moxart_mdio_dt_ids[] = {\n\t{ .compatible = \"moxa,moxart-mdio\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, moxart_mdio_dt_ids);\n\nstatic struct platform_driver moxart_mdio_driver = {\n\t.probe = moxart_mdio_probe,\n\t.remove = moxart_mdio_remove,\n\t.driver = {\n\t\t.name = \"moxart-mdio\",\n\t\t.of_match_table = moxart_mdio_dt_ids,\n\t},\n};\n\nmodule_platform_driver(moxart_mdio_driver);\n\nMODULE_DESCRIPTION(\"MOXA ART MDIO interface driver\");\nMODULE_AUTHOR(\"Jonas Jensen <jonas.jensen@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}