{
  "module_name": "mdio-bcm-iproc.c",
  "hash_id": "9d033a0d538c2321eefbae35249ead0b441a4427aa96623fc0ed4902d2ccc824",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-bcm-iproc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n\n#define IPROC_GPHY_MDCDIV    0x1a\n\n#define MII_CTRL_OFFSET      0x000\n\n#define MII_CTRL_DIV_SHIFT   0\n#define MII_CTRL_PRE_SHIFT   7\n#define MII_CTRL_BUSY_SHIFT  8\n\n#define MII_DATA_OFFSET      0x004\n#define MII_DATA_MASK        0xffff\n#define MII_DATA_TA_SHIFT    16\n#define MII_DATA_TA_VAL      2\n#define MII_DATA_RA_SHIFT    18\n#define MII_DATA_PA_SHIFT    23\n#define MII_DATA_OP_SHIFT    28\n#define MII_DATA_OP_WRITE    1\n#define MII_DATA_OP_READ     2\n#define MII_DATA_SB_SHIFT    30\n\nstruct iproc_mdio_priv {\n\tstruct mii_bus *mii_bus;\n\tvoid __iomem *base;\n};\n\nstatic inline int iproc_mdio_wait_for_idle(void __iomem *base)\n{\n\tu32 val;\n\tunsigned int timeout = 1000;  \n\n\tdo {\n\t\tval = readl(base + MII_CTRL_OFFSET);\n\t\tif ((val & BIT(MII_CTRL_BUSY_SHIFT)) == 0)\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t} while (timeout--);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic inline void iproc_mdio_config_clk(void __iomem *base)\n{\n\tu32 val;\n\n\tval = (IPROC_GPHY_MDCDIV << MII_CTRL_DIV_SHIFT) |\n\t\t  BIT(MII_CTRL_PRE_SHIFT);\n\twritel(val, base + MII_CTRL_OFFSET);\n}\n\nstatic int iproc_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tstruct iproc_mdio_priv *priv = bus->priv;\n\tu32 cmd;\n\tint rc;\n\n\trc = iproc_mdio_wait_for_idle(priv->base);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tcmd = (MII_DATA_TA_VAL << MII_DATA_TA_SHIFT) |\n\t\t(reg << MII_DATA_RA_SHIFT) |\n\t\t(phy_id << MII_DATA_PA_SHIFT) |\n\t\tBIT(MII_DATA_SB_SHIFT) |\n\t\t(MII_DATA_OP_READ << MII_DATA_OP_SHIFT);\n\n\twritel(cmd, priv->base + MII_DATA_OFFSET);\n\n\trc = iproc_mdio_wait_for_idle(priv->base);\n\tif (rc)\n\t\treturn rc;\n\n\tcmd = readl(priv->base + MII_DATA_OFFSET) & MII_DATA_MASK;\n\n\treturn cmd;\n}\n\nstatic int iproc_mdio_write(struct mii_bus *bus, int phy_id,\n\t\t\t    int reg, u16 val)\n{\n\tstruct iproc_mdio_priv *priv = bus->priv;\n\tu32 cmd;\n\tint rc;\n\n\trc = iproc_mdio_wait_for_idle(priv->base);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tcmd = (MII_DATA_TA_VAL << MII_DATA_TA_SHIFT) |\n\t\t(reg << MII_DATA_RA_SHIFT) |\n\t\t(phy_id << MII_DATA_PA_SHIFT) |\n\t\tBIT(MII_DATA_SB_SHIFT) |\n\t\t(MII_DATA_OP_WRITE << MII_DATA_OP_SHIFT) |\n\t\t((u32)(val) & MII_DATA_MASK);\n\n\twritel(cmd, priv->base + MII_DATA_OFFSET);\n\n\trc = iproc_mdio_wait_for_idle(priv->base);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int iproc_mdio_probe(struct platform_device *pdev)\n{\n\tstruct iproc_mdio_priv *priv;\n\tstruct mii_bus *bus;\n\tint rc;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base)) {\n\t\tdev_err(&pdev->dev, \"failed to ioremap register\\n\");\n\t\treturn PTR_ERR(priv->base);\n\t}\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus) {\n\t\tdev_err(&pdev->dev, \"MDIO bus alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tbus->name = \"iProc MDIO bus\";\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\tbus->parent = &pdev->dev;\n\tbus->read = iproc_mdio_read;\n\tbus->write = iproc_mdio_write;\n\n\tiproc_mdio_config_clk(priv->base);\n\n\trc = of_mdiobus_register(bus, pdev->dev.of_node);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto err_iproc_mdio;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom iProc MDIO bus registered\\n\");\n\n\treturn 0;\n\nerr_iproc_mdio:\n\tmdiobus_free(bus);\n\treturn rc;\n}\n\nstatic int iproc_mdio_remove(struct platform_device *pdev)\n{\n\tstruct iproc_mdio_priv *priv = platform_get_drvdata(pdev);\n\n\tmdiobus_unregister(priv->mii_bus);\n\tmdiobus_free(priv->mii_bus);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int iproc_mdio_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct iproc_mdio_priv *priv = platform_get_drvdata(pdev);\n\n\t \n\tiproc_mdio_config_clk(priv->base);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops iproc_mdio_pm_ops = {\n\t.resume = iproc_mdio_resume\n};\n#endif  \n\nstatic const struct of_device_id iproc_mdio_of_match[] = {\n\t{ .compatible = \"brcm,iproc-mdio\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, iproc_mdio_of_match);\n\nstatic struct platform_driver iproc_mdio_driver = {\n\t.driver = {\n\t\t.name = \"iproc-mdio\",\n\t\t.of_match_table = iproc_mdio_of_match,\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm = &iproc_mdio_pm_ops,\n#endif\n\t},\n\t.probe = iproc_mdio_probe,\n\t.remove = iproc_mdio_remove,\n};\n\nmodule_platform_driver(iproc_mdio_driver);\n\nMODULE_AUTHOR(\"Broadcom Corporation\");\nMODULE_DESCRIPTION(\"Broadcom iProc MDIO bus controller\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:iproc-mdio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}