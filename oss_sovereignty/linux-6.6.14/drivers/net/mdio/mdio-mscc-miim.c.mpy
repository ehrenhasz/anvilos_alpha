{
  "module_name": "mdio-mscc-miim.c",
  "hash_id": "0cd64468e43a6ee4e03721be550efbee51fc8842abe0d4a2d0daa86508c6d7dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-mscc-miim.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mdio/mdio-mscc-miim.h>\n#include <linux/mfd/ocelot.h>\n#include <linux/module.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n#define MSCC_MIIM_REG_STATUS\t\t0x0\n#define\t\tMSCC_MIIM_STATUS_STAT_PENDING\tBIT(2)\n#define\t\tMSCC_MIIM_STATUS_STAT_BUSY\tBIT(3)\n#define MSCC_MIIM_REG_CMD\t\t0x8\n#define\t\tMSCC_MIIM_CMD_OPR_WRITE\t\tBIT(1)\n#define\t\tMSCC_MIIM_CMD_OPR_READ\t\tBIT(2)\n#define\t\tMSCC_MIIM_CMD_WRDATA_SHIFT\t4\n#define\t\tMSCC_MIIM_CMD_REGAD_SHIFT\t20\n#define\t\tMSCC_MIIM_CMD_PHYAD_SHIFT\t25\n#define\t\tMSCC_MIIM_CMD_VLD\t\tBIT(31)\n#define MSCC_MIIM_REG_DATA\t\t0xC\n#define\t\tMSCC_MIIM_DATA_ERROR\t\t(BIT(16) | BIT(17))\n#define MSCC_MIIM_REG_CFG\t\t0x10\n#define\t\tMSCC_MIIM_CFG_PRESCALE_MASK\tGENMASK(7, 0)\n\n#define MSCC_PHY_REG_PHY_CFG\t0x0\n#define\t\tPHY_CFG_PHY_ENA\t\t(BIT(0) | BIT(1) | BIT(2) | BIT(3))\n#define\t\tPHY_CFG_PHY_COMMON_RESET BIT(4)\n#define\t\tPHY_CFG_PHY_RESET\t(BIT(5) | BIT(6) | BIT(7) | BIT(8))\n#define MSCC_PHY_REG_PHY_STATUS\t0x4\n\n#define LAN966X_CUPHY_COMMON_CFG\t0x0\n#define\t\tCUPHY_COMMON_CFG_RESET_N\tBIT(0)\n\nstruct mscc_miim_info {\n\tunsigned int phy_reset_offset;\n\tunsigned int phy_reset_bits;\n};\n\nstruct mscc_miim_dev {\n\tstruct regmap *regs;\n\tint mii_status_offset;\n\tbool ignore_read_errors;\n\tstruct regmap *phy_regs;\n\tconst struct mscc_miim_info *info;\n\tstruct clk *clk;\n\tu32 bus_freq;\n};\n\n \n#define mscc_readx_poll_timeout(op, addr, val, cond, delay_us, timeout_us)\\\n({\t\t\t\t\t\t\t\t\t  \\\n\tif (!IS_ENABLED(CONFIG_HIGH_RES_TIMERS))\t\t\t  \\\n\t\treadx_poll_timeout_atomic(op, addr, val, cond, delay_us,  \\\n\t\t\t\t\t  timeout_us);\t\t\t  \\\n\treadx_poll_timeout(op, addr, val, cond, delay_us, timeout_us);\t  \\\n})\n\nstatic int mscc_miim_status(struct mii_bus *bus)\n{\n\tstruct mscc_miim_dev *miim = bus->priv;\n\tint val, ret;\n\n\tret = regmap_read(miim->regs,\n\t\t\t  MSCC_MIIM_REG_STATUS + miim->mii_status_offset, &val);\n\tif (ret < 0) {\n\t\tWARN_ONCE(1, \"mscc miim status read error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn val;\n}\n\nstatic int mscc_miim_wait_ready(struct mii_bus *bus)\n{\n\tu32 val;\n\n\treturn mscc_readx_poll_timeout(mscc_miim_status, bus, val,\n\t\t\t\t       !(val & MSCC_MIIM_STATUS_STAT_BUSY), 50,\n\t\t\t\t       10000);\n}\n\nstatic int mscc_miim_wait_pending(struct mii_bus *bus)\n{\n\tu32 val;\n\n\treturn mscc_readx_poll_timeout(mscc_miim_status, bus, val,\n\t\t\t\t       !(val & MSCC_MIIM_STATUS_STAT_PENDING),\n\t\t\t\t       50, 10000);\n}\n\nstatic int mscc_miim_read(struct mii_bus *bus, int mii_id, int regnum)\n{\n\tstruct mscc_miim_dev *miim = bus->priv;\n\tu32 val;\n\tint ret;\n\n\tret = mscc_miim_wait_pending(bus);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_write(miim->regs,\n\t\t\t   MSCC_MIIM_REG_CMD + miim->mii_status_offset,\n\t\t\t   MSCC_MIIM_CMD_VLD |\n\t\t\t   (mii_id << MSCC_MIIM_CMD_PHYAD_SHIFT) |\n\t\t\t   (regnum << MSCC_MIIM_CMD_REGAD_SHIFT) |\n\t\t\t   MSCC_MIIM_CMD_OPR_READ);\n\n\tif (ret < 0) {\n\t\tWARN_ONCE(1, \"mscc miim write cmd reg error %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = mscc_miim_wait_ready(bus);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_read(miim->regs,\n\t\t\t  MSCC_MIIM_REG_DATA + miim->mii_status_offset, &val);\n\tif (ret < 0) {\n\t\tWARN_ONCE(1, \"mscc miim read data reg error %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (!miim->ignore_read_errors && !!(val & MSCC_MIIM_DATA_ERROR)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = val & 0xFFFF;\nout:\n\treturn ret;\n}\n\nstatic int mscc_miim_write(struct mii_bus *bus, int mii_id,\n\t\t\t   int regnum, u16 value)\n{\n\tstruct mscc_miim_dev *miim = bus->priv;\n\tint ret;\n\n\tret = mscc_miim_wait_pending(bus);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = regmap_write(miim->regs,\n\t\t\t   MSCC_MIIM_REG_CMD + miim->mii_status_offset,\n\t\t\t   MSCC_MIIM_CMD_VLD |\n\t\t\t   (mii_id << MSCC_MIIM_CMD_PHYAD_SHIFT) |\n\t\t\t   (regnum << MSCC_MIIM_CMD_REGAD_SHIFT) |\n\t\t\t   (value << MSCC_MIIM_CMD_WRDATA_SHIFT) |\n\t\t\t   MSCC_MIIM_CMD_OPR_WRITE);\n\n\tif (ret < 0)\n\t\tWARN_ONCE(1, \"mscc miim write error %d\\n\", ret);\nout:\n\treturn ret;\n}\n\nstatic int mscc_miim_reset(struct mii_bus *bus)\n{\n\tstruct mscc_miim_dev *miim = bus->priv;\n\tunsigned int offset, bits;\n\tint ret;\n\n\tif (!miim->phy_regs)\n\t\treturn 0;\n\n\toffset = miim->info->phy_reset_offset;\n\tbits = miim->info->phy_reset_bits;\n\n\tret = regmap_update_bits(miim->phy_regs, offset, bits, 0);\n\tif (ret < 0) {\n\t\tWARN_ONCE(1, \"mscc reset set error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(miim->phy_regs, offset, bits, bits);\n\tif (ret < 0) {\n\t\tWARN_ONCE(1, \"mscc reset clear error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmdelay(500);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config mscc_miim_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n};\n\nstatic const struct regmap_config mscc_miim_phy_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.name\t\t= \"phy\",\n};\n\nint mscc_miim_setup(struct device *dev, struct mii_bus **pbus, const char *name,\n\t\t    struct regmap *mii_regmap, int status_offset,\n\t\t    bool ignore_read_errors)\n{\n\tstruct mscc_miim_dev *miim;\n\tstruct mii_bus *bus;\n\n\tbus = devm_mdiobus_alloc_size(dev, sizeof(*miim));\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->name = name;\n\tbus->read = mscc_miim_read;\n\tbus->write = mscc_miim_write;\n\tbus->reset = mscc_miim_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-mii\", dev_name(dev));\n\tbus->parent = dev;\n\n\tmiim = bus->priv;\n\n\t*pbus = bus;\n\n\tmiim->regs = mii_regmap;\n\tmiim->mii_status_offset = status_offset;\n\tmiim->ignore_read_errors = ignore_read_errors;\n\n\t*pbus = bus;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mscc_miim_setup);\n\nstatic int mscc_miim_clk_set(struct mii_bus *bus)\n{\n\tstruct mscc_miim_dev *miim = bus->priv;\n\tunsigned long rate;\n\tu32 div;\n\n\t \n\tif (!miim->bus_freq)\n\t\treturn 0;\n\n\trate = clk_get_rate(miim->clk);\n\n\tdiv = DIV_ROUND_UP(rate, 2 * miim->bus_freq) - 1;\n\tif (div == 0 || div & ~MSCC_MIIM_CFG_PRESCALE_MASK) {\n\t\tdev_err(&bus->dev, \"Incorrect MDIO clock frequency\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(miim->regs, MSCC_MIIM_REG_CFG,\n\t\t\t\t  MSCC_MIIM_CFG_PRESCALE_MASK, div);\n}\n\nstatic int mscc_miim_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct regmap *mii_regmap, *phy_regmap;\n\tstruct device *dev = &pdev->dev;\n\tstruct mscc_miim_dev *miim;\n\tstruct mii_bus *bus;\n\tint ret;\n\n\tmii_regmap = ocelot_regmap_from_resource(pdev, 0,\n\t\t\t\t\t\t &mscc_miim_regmap_config);\n\tif (IS_ERR(mii_regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(mii_regmap),\n\t\t\t\t     \"Unable to create MIIM regmap\\n\");\n\n\t \n\tphy_regmap = ocelot_regmap_from_resource_optional(pdev, 1,\n\t\t\t\t\t\t &mscc_miim_phy_regmap_config);\n\tif (IS_ERR(phy_regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(phy_regmap),\n\t\t\t\t     \"Unable to create phy register regmap\\n\");\n\n\tret = mscc_miim_setup(dev, &bus, \"mscc_miim\", mii_regmap, 0, false);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Unable to setup the MDIO bus\\n\");\n\t\treturn ret;\n\t}\n\n\tmiim = bus->priv;\n\tmiim->phy_regs = phy_regmap;\n\n\tmiim->info = device_get_match_data(dev);\n\tif (!miim->info)\n\t\treturn -EINVAL;\n\n\tmiim->clk = devm_clk_get_optional(dev, NULL);\n\tif (IS_ERR(miim->clk))\n\t\treturn PTR_ERR(miim->clk);\n\n\tof_property_read_u32(np, \"clock-frequency\", &miim->bus_freq);\n\n\tif (miim->bus_freq && !miim->clk) {\n\t\tdev_err(dev, \"cannot use clock-frequency without a clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = clk_prepare_enable(miim->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mscc_miim_clk_set(bus);\n\tif (ret)\n\t\tgoto out_disable_clk;\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Cannot register MDIO bus (%d)\\n\", ret);\n\t\tgoto out_disable_clk;\n\t}\n\n\tplatform_set_drvdata(pdev, bus);\n\n\treturn 0;\n\nout_disable_clk:\n\tclk_disable_unprepare(miim->clk);\n\treturn ret;\n}\n\nstatic int mscc_miim_remove(struct platform_device *pdev)\n{\n\tstruct mii_bus *bus = platform_get_drvdata(pdev);\n\tstruct mscc_miim_dev *miim = bus->priv;\n\n\tclk_disable_unprepare(miim->clk);\n\tmdiobus_unregister(bus);\n\n\treturn 0;\n}\n\nstatic const struct mscc_miim_info mscc_ocelot_miim_info = {\n\t.phy_reset_offset = MSCC_PHY_REG_PHY_CFG,\n\t.phy_reset_bits = PHY_CFG_PHY_ENA | PHY_CFG_PHY_COMMON_RESET |\n\t\t\t  PHY_CFG_PHY_RESET,\n};\n\nstatic const struct mscc_miim_info microchip_lan966x_miim_info = {\n\t.phy_reset_offset = LAN966X_CUPHY_COMMON_CFG,\n\t.phy_reset_bits = CUPHY_COMMON_CFG_RESET_N,\n};\n\nstatic const struct of_device_id mscc_miim_match[] = {\n\t{\n\t\t.compatible = \"mscc,ocelot-miim\",\n\t\t.data = &mscc_ocelot_miim_info\n\t}, {\n\t\t.compatible = \"microchip,lan966x-miim\",\n\t\t.data = &microchip_lan966x_miim_info\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mscc_miim_match);\n\nstatic struct platform_driver mscc_miim_driver = {\n\t.probe = mscc_miim_probe,\n\t.remove = mscc_miim_remove,\n\t.driver = {\n\t\t.name = \"mscc-miim\",\n\t\t.of_match_table = mscc_miim_match,\n\t},\n};\n\nmodule_platform_driver(mscc_miim_driver);\n\nMODULE_DESCRIPTION(\"Microsemi MIIM driver\");\nMODULE_AUTHOR(\"Alexandre Belloni <alexandre.belloni@bootlin.com>\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}