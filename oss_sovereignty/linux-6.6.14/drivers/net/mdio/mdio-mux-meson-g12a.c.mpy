{
  "module_name": "mdio-mux-meson-g12a.c",
  "hash_id": "d613e4f3e8fab8f4ab9b73e37d67dd614339da1bcd8c1107d7776283920185b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-mux-meson-g12a.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mdio-mux.h>\n#include <linux/module.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n\n#define ETH_PLL_STS\t\t0x40\n#define ETH_PLL_CTL0\t\t0x44\n#define  PLL_CTL0_LOCK_DIG\tBIT(30)\n#define  PLL_CTL0_RST\t\tBIT(29)\n#define  PLL_CTL0_EN\t\tBIT(28)\n#define  PLL_CTL0_SEL\t\tBIT(23)\n#define  PLL_CTL0_N\t\tGENMASK(14, 10)\n#define  PLL_CTL0_M\t\tGENMASK(8, 0)\n#define  PLL_LOCK_TIMEOUT\t1000000\n#define  PLL_MUX_NUM_PARENT\t2\n#define ETH_PLL_CTL1\t\t0x48\n#define ETH_PLL_CTL2\t\t0x4c\n#define ETH_PLL_CTL3\t\t0x50\n#define ETH_PLL_CTL4\t\t0x54\n#define ETH_PLL_CTL5\t\t0x58\n#define ETH_PLL_CTL6\t\t0x5c\n#define ETH_PLL_CTL7\t\t0x60\n\n#define ETH_PHY_CNTL0\t\t0x80\n#define   EPHY_G12A_ID\t\t0x33010180\n#define ETH_PHY_CNTL1\t\t0x84\n#define  PHY_CNTL1_ST_MODE\tGENMASK(2, 0)\n#define  PHY_CNTL1_ST_PHYADD\tGENMASK(7, 3)\n#define   EPHY_DFLT_ADD\t\t8\n#define  PHY_CNTL1_MII_MODE\tGENMASK(15, 14)\n#define   EPHY_MODE_RMII\t0x1\n#define  PHY_CNTL1_CLK_EN\tBIT(16)\n#define  PHY_CNTL1_CLKFREQ\tBIT(17)\n#define  PHY_CNTL1_PHY_ENB\tBIT(18)\n#define ETH_PHY_CNTL2\t\t0x88\n#define  PHY_CNTL2_USE_INTERNAL\tBIT(5)\n#define  PHY_CNTL2_SMI_SRC_MAC\tBIT(6)\n#define  PHY_CNTL2_RX_CLK_EPHY\tBIT(9)\n\n#define MESON_G12A_MDIO_EXTERNAL_ID 0\n#define MESON_G12A_MDIO_INTERNAL_ID 1\n\nstruct g12a_mdio_mux {\n\tvoid __iomem *regs;\n\tvoid *mux_handle;\n\tstruct clk *pll;\n};\n\nstruct g12a_ephy_pll {\n\tvoid __iomem *base;\n\tstruct clk_hw hw;\n};\n\n#define g12a_ephy_pll_to_dev(_hw)\t\t\t\\\n\tcontainer_of(_hw, struct g12a_ephy_pll, hw)\n\nstatic unsigned long g12a_ephy_pll_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct g12a_ephy_pll *pll = g12a_ephy_pll_to_dev(hw);\n\tu32 val, m, n;\n\n\tval = readl(pll->base + ETH_PLL_CTL0);\n\tm = FIELD_GET(PLL_CTL0_M, val);\n\tn = FIELD_GET(PLL_CTL0_N, val);\n\n\treturn parent_rate * m / n;\n}\n\nstatic int g12a_ephy_pll_enable(struct clk_hw *hw)\n{\n\tstruct g12a_ephy_pll *pll = g12a_ephy_pll_to_dev(hw);\n\tu32 val = readl(pll->base + ETH_PLL_CTL0);\n\n\t \n\tval |= PLL_CTL0_RST | PLL_CTL0_EN;\n\twritel(val, pll->base + ETH_PLL_CTL0);\n\n\t \n\tval &= ~PLL_CTL0_RST;\n\twritel(val, pll->base + ETH_PLL_CTL0);\n\n\t \n\treturn readl_poll_timeout(pll->base + ETH_PLL_CTL0, val,\n\t\t\t\t  val & PLL_CTL0_LOCK_DIG, 0, PLL_LOCK_TIMEOUT);\n}\n\nstatic void g12a_ephy_pll_disable(struct clk_hw *hw)\n{\n\tstruct g12a_ephy_pll *pll = g12a_ephy_pll_to_dev(hw);\n\tu32 val;\n\n\tval = readl(pll->base + ETH_PLL_CTL0);\n\tval &= ~PLL_CTL0_EN;\n\tval |= PLL_CTL0_RST;\n\twritel(val, pll->base + ETH_PLL_CTL0);\n}\n\nstatic int g12a_ephy_pll_is_enabled(struct clk_hw *hw)\n{\n\tstruct g12a_ephy_pll *pll = g12a_ephy_pll_to_dev(hw);\n\tunsigned int val;\n\n\tval = readl(pll->base + ETH_PLL_CTL0);\n\n\treturn (val & PLL_CTL0_LOCK_DIG) ? 1 : 0;\n}\n\nstatic int g12a_ephy_pll_init(struct clk_hw *hw)\n{\n\tstruct g12a_ephy_pll *pll = g12a_ephy_pll_to_dev(hw);\n\n\t \n\twritel(0x29c0040a, pll->base + ETH_PLL_CTL0);\n\twritel(0x927e0000, pll->base + ETH_PLL_CTL1);\n\twritel(0xac5f49e5, pll->base + ETH_PLL_CTL2);\n\twritel(0x00000000, pll->base + ETH_PLL_CTL3);\n\twritel(0x00000000, pll->base + ETH_PLL_CTL4);\n\twritel(0x20200000, pll->base + ETH_PLL_CTL5);\n\twritel(0x0000c002, pll->base + ETH_PLL_CTL6);\n\twritel(0x00000023, pll->base + ETH_PLL_CTL7);\n\n\treturn 0;\n}\n\nstatic const struct clk_ops g12a_ephy_pll_ops = {\n\t.recalc_rate\t= g12a_ephy_pll_recalc_rate,\n\t.is_enabled\t= g12a_ephy_pll_is_enabled,\n\t.enable\t\t= g12a_ephy_pll_enable,\n\t.disable\t= g12a_ephy_pll_disable,\n\t.init\t\t= g12a_ephy_pll_init,\n};\n\nstatic int g12a_enable_internal_mdio(struct g12a_mdio_mux *priv)\n{\n\tu32 value;\n\tint ret;\n\n\t \n\tif (!__clk_is_enabled(priv->pll)) {\n\t\tret = clk_prepare_enable(priv->pll);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\twritel(EPHY_G12A_ID, priv->regs + ETH_PHY_CNTL0);\n\n\t \n\tvalue = FIELD_PREP(PHY_CNTL1_ST_MODE, 3) |\n\t\tFIELD_PREP(PHY_CNTL1_ST_PHYADD, EPHY_DFLT_ADD) |\n\t\tFIELD_PREP(PHY_CNTL1_MII_MODE, EPHY_MODE_RMII) |\n\t\tPHY_CNTL1_CLK_EN |\n\t\tPHY_CNTL1_CLKFREQ;\n\twritel(value, priv->regs + ETH_PHY_CNTL1);\n\twritel(PHY_CNTL2_USE_INTERNAL |\n\t       PHY_CNTL2_SMI_SRC_MAC |\n\t       PHY_CNTL2_RX_CLK_EPHY,\n\t       priv->regs + ETH_PHY_CNTL2);\n\n\tvalue |= PHY_CNTL1_PHY_ENB;\n\twritel(value, priv->regs + ETH_PHY_CNTL1);\n\n\t \n\tmdelay(10);\n\n\treturn 0;\n}\n\nstatic int g12a_enable_external_mdio(struct g12a_mdio_mux *priv)\n{\n\t \n\twritel_relaxed(0x0, priv->regs + ETH_PHY_CNTL2);\n\n\t \n\tif (__clk_is_enabled(priv->pll))\n\t\tclk_disable_unprepare(priv->pll);\n\n\treturn 0;\n}\n\nstatic int g12a_mdio_switch_fn(int current_child, int desired_child,\n\t\t\t       void *data)\n{\n\tstruct g12a_mdio_mux *priv = dev_get_drvdata(data);\n\n\tif (current_child == desired_child)\n\t\treturn 0;\n\n\tswitch (desired_child) {\n\tcase MESON_G12A_MDIO_EXTERNAL_ID:\n\t\treturn g12a_enable_external_mdio(priv);\n\tcase MESON_G12A_MDIO_INTERNAL_ID:\n\t\treturn g12a_enable_internal_mdio(priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct of_device_id g12a_mdio_mux_match[] = {\n\t{ .compatible = \"amlogic,g12a-mdio-mux\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, g12a_mdio_mux_match);\n\nstatic int g12a_ephy_glue_clk_register(struct device *dev)\n{\n\tstruct g12a_mdio_mux *priv = dev_get_drvdata(dev);\n\tconst char *parent_names[PLL_MUX_NUM_PARENT];\n\tstruct clk_init_data init;\n\tstruct g12a_ephy_pll *pll;\n\tstruct clk_mux *mux;\n\tstruct clk *clk;\n\tchar *name;\n\tint i;\n\n\t \n\tfor (i = 0; i < PLL_MUX_NUM_PARENT; i++) {\n\t\tchar in_name[8];\n\n\t\tsnprintf(in_name, sizeof(in_name), \"clkin%d\", i);\n\t\tclk = devm_clk_get(dev, in_name);\n\t\tif (IS_ERR(clk))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(clk),\n\t\t\t\t\t     \"Missing clock %s\\n\", in_name);\n\n\t\tparent_names[i] = __clk_get_name(clk);\n\t}\n\n\t \n\tmux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn -ENOMEM;\n\n\tname = kasprintf(GFP_KERNEL, \"%s#mux\", dev_name(dev));\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tinit.name = name;\n\tinit.ops = &clk_mux_ro_ops;\n\tinit.flags = 0;\n\tinit.parent_names = parent_names;\n\tinit.num_parents = PLL_MUX_NUM_PARENT;\n\n\tmux->reg = priv->regs + ETH_PLL_CTL0;\n\tmux->shift = __ffs(PLL_CTL0_SEL);\n\tmux->mask = PLL_CTL0_SEL >> mux->shift;\n\tmux->hw.init = &init;\n\n\tclk = devm_clk_register(dev, &mux->hw);\n\tkfree(name);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"failed to register input mux\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\t \n\tpll = devm_kzalloc(dev, sizeof(*pll), GFP_KERNEL);\n\tif (!pll)\n\t\treturn -ENOMEM;\n\n\tname = kasprintf(GFP_KERNEL, \"%s#pll\", dev_name(dev));\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tinit.name = name;\n\tinit.ops = &g12a_ephy_pll_ops;\n\tinit.flags = 0;\n\tparent_names[0] = __clk_get_name(clk);\n\tinit.parent_names = parent_names;\n\tinit.num_parents = 1;\n\n\tpll->base = priv->regs;\n\tpll->hw.init = &init;\n\n\tclk = devm_clk_register(dev, &pll->hw);\n\tkfree(name);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"failed to register input mux\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tpriv->pll = clk;\n\n\treturn 0;\n}\n\nstatic int g12a_mdio_mux_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct g12a_mdio_mux *priv;\n\tstruct clk *pclk;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->regs))\n\t\treturn PTR_ERR(priv->regs);\n\n\tpclk = devm_clk_get_enabled(dev, \"pclk\");\n\tif (IS_ERR(pclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(pclk),\n\t\t\t\t     \"failed to get peripheral clock\\n\");\n\n\t \n\tret = g12a_ephy_glue_clk_register(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mdio_mux_init(dev, dev->of_node, g12a_mdio_switch_fn,\n\t\t\t    &priv->mux_handle, dev, NULL);\n\tif (ret)\n\t\tdev_err_probe(dev, ret, \"mdio multiplexer init failed\\n\");\n\n\treturn ret;\n}\n\nstatic int g12a_mdio_mux_remove(struct platform_device *pdev)\n{\n\tstruct g12a_mdio_mux *priv = platform_get_drvdata(pdev);\n\n\tmdio_mux_uninit(priv->mux_handle);\n\n\tif (__clk_is_enabled(priv->pll))\n\t\tclk_disable_unprepare(priv->pll);\n\n\treturn 0;\n}\n\nstatic struct platform_driver g12a_mdio_mux_driver = {\n\t.probe\t\t= g12a_mdio_mux_probe,\n\t.remove\t\t= g12a_mdio_mux_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"g12a-mdio_mux\",\n\t\t.of_match_table = g12a_mdio_mux_match,\n\t},\n};\nmodule_platform_driver(g12a_mdio_mux_driver);\n\nMODULE_DESCRIPTION(\"Amlogic G12a MDIO multiplexer driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}