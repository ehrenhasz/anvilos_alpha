{
  "module_name": "fwnode_mdio.c",
  "hash_id": "364d65c26b0006a51ea1441e8d523f038058fc827ee8623cc665063c9d6b7e3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/fwnode_mdio.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/fwnode_mdio.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/pse-pd/pse.h>\n\nMODULE_AUTHOR(\"Calvin Johnson <calvin.johnson@oss.nxp.com>\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct pse_control *\nfwnode_find_pse_control(struct fwnode_handle *fwnode)\n{\n\tstruct pse_control *psec;\n\tstruct device_node *np;\n\n\tif (!IS_ENABLED(CONFIG_PSE_CONTROLLER))\n\t\treturn NULL;\n\n\tnp = to_of_node(fwnode);\n\tif (!np)\n\t\treturn NULL;\n\n\tpsec = of_pse_control_get(np);\n\tif (PTR_ERR(psec) == -ENOENT)\n\t\treturn NULL;\n\n\treturn psec;\n}\n\nstatic struct mii_timestamper *\nfwnode_find_mii_timestamper(struct fwnode_handle *fwnode)\n{\n\tstruct of_phandle_args arg;\n\tint err;\n\n\tif (is_acpi_node(fwnode))\n\t\treturn NULL;\n\n\terr = of_parse_phandle_with_fixed_args(to_of_node(fwnode),\n\t\t\t\t\t       \"timestamper\", 1, 0, &arg);\n\tif (err == -ENOENT)\n\t\treturn NULL;\n\telse if (err)\n\t\treturn ERR_PTR(err);\n\n\tif (arg.args_count != 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn register_mii_timestamper(arg.np, arg.args[0]);\n}\n\nint fwnode_mdiobus_phy_device_register(struct mii_bus *mdio,\n\t\t\t\t       struct phy_device *phy,\n\t\t\t\t       struct fwnode_handle *child, u32 addr)\n{\n\tint rc;\n\n\trc = fwnode_irq_get(child, 0);\n\t \n\tif (rc == -EPROBE_DEFER)\n\t\trc = driver_deferred_probe_check_state(&phy->mdio.dev);\n\tif (rc == -EPROBE_DEFER)\n\t\treturn rc;\n\n\tif (rc > 0) {\n\t\tphy->irq = rc;\n\t\tmdio->irq[addr] = rc;\n\t} else {\n\t\tphy->irq = mdio->irq[addr];\n\t}\n\n\tif (fwnode_property_read_bool(child, \"broken-turn-around\"))\n\t\tmdio->phy_ignore_ta_mask |= 1 << addr;\n\n\tfwnode_property_read_u32(child, \"reset-assert-us\",\n\t\t\t\t &phy->mdio.reset_assert_delay);\n\tfwnode_property_read_u32(child, \"reset-deassert-us\",\n\t\t\t\t &phy->mdio.reset_deassert_delay);\n\n\t \n\tfwnode_handle_get(child);\n\tdevice_set_node(&phy->mdio.dev, child);\n\n\t \n\trc = phy_device_register(phy);\n\tif (rc) {\n\t\tdevice_set_node(&phy->mdio.dev, NULL);\n\t\tfwnode_handle_put(child);\n\t\treturn rc;\n\t}\n\n\tdev_dbg(&mdio->dev, \"registered phy %p fwnode at address %i\\n\",\n\t\tchild, addr);\n\treturn 0;\n}\nEXPORT_SYMBOL(fwnode_mdiobus_phy_device_register);\n\nint fwnode_mdiobus_register_phy(struct mii_bus *bus,\n\t\t\t\tstruct fwnode_handle *child, u32 addr)\n{\n\tstruct mii_timestamper *mii_ts = NULL;\n\tstruct pse_control *psec = NULL;\n\tstruct phy_device *phy;\n\tbool is_c45;\n\tu32 phy_id;\n\tint rc;\n\n\tpsec = fwnode_find_pse_control(child);\n\tif (IS_ERR(psec))\n\t\treturn PTR_ERR(psec);\n\n\tmii_ts = fwnode_find_mii_timestamper(child);\n\tif (IS_ERR(mii_ts)) {\n\t\trc = PTR_ERR(mii_ts);\n\t\tgoto clean_pse;\n\t}\n\n\tis_c45 = fwnode_device_is_compatible(child, \"ethernet-phy-ieee802.3-c45\");\n\tif (is_c45 || fwnode_get_phy_id(child, &phy_id))\n\t\tphy = get_phy_device(bus, addr, is_c45);\n\telse\n\t\tphy = phy_device_create(bus, addr, phy_id, 0, NULL);\n\tif (IS_ERR(phy)) {\n\t\trc = PTR_ERR(phy);\n\t\tgoto clean_mii_ts;\n\t}\n\n\tif (is_acpi_node(child)) {\n\t\tphy->irq = bus->irq[addr];\n\n\t\t \n\t\tphy->mdio.dev.fwnode = fwnode_handle_get(child);\n\n\t\t \n\t\trc = phy_device_register(phy);\n\t\tif (rc) {\n\t\t\tphy->mdio.dev.fwnode = NULL;\n\t\t\tfwnode_handle_put(child);\n\t\t\tgoto clean_phy;\n\t\t}\n\t} else if (is_of_node(child)) {\n\t\trc = fwnode_mdiobus_phy_device_register(bus, phy, child, addr);\n\t\tif (rc)\n\t\t\tgoto clean_phy;\n\t}\n\n\tphy->psec = psec;\n\n\t \n\tif (mii_ts)\n\t\tphy->mii_ts = mii_ts;\n\n\treturn 0;\n\nclean_phy:\n\tphy_device_free(phy);\nclean_mii_ts:\n\tunregister_mii_timestamper(mii_ts);\nclean_pse:\n\tpse_control_put(psec);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(fwnode_mdiobus_register_phy);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}