{
  "module_name": "of_mdio.c",
  "hash_id": "a2a5a5b617bd43f68ec675a0804ea76d8b8da332151ed2d64aa3c41b888eed07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/of_mdio.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/fwnode_mdio.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/phy_fixed.h>\n\n#define DEFAULT_GPIO_RESET_DELAY\t10\t \n\nMODULE_AUTHOR(\"Grant Likely <grant.likely@secretlab.ca>\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic int of_get_phy_id(struct device_node *device, u32 *phy_id)\n{\n\treturn fwnode_get_phy_id(of_fwnode_handle(device), phy_id);\n}\n\nint of_mdiobus_phy_device_register(struct mii_bus *mdio, struct phy_device *phy,\n\t\t\t\t   struct device_node *child, u32 addr)\n{\n\treturn fwnode_mdiobus_phy_device_register(mdio, phy,\n\t\t\t\t\t\t  of_fwnode_handle(child),\n\t\t\t\t\t\t  addr);\n}\nEXPORT_SYMBOL(of_mdiobus_phy_device_register);\n\nstatic int of_mdiobus_register_phy(struct mii_bus *mdio,\n\t\t\t\t    struct device_node *child, u32 addr)\n{\n\treturn fwnode_mdiobus_register_phy(mdio, of_fwnode_handle(child), addr);\n}\n\nstatic int of_mdiobus_register_device(struct mii_bus *mdio,\n\t\t\t\t      struct device_node *child, u32 addr)\n{\n\tstruct fwnode_handle *fwnode = of_fwnode_handle(child);\n\tstruct mdio_device *mdiodev;\n\tint rc;\n\n\tmdiodev = mdio_device_create(mdio, addr);\n\tif (IS_ERR(mdiodev))\n\t\treturn PTR_ERR(mdiodev);\n\n\t \n\tfwnode_handle_get(fwnode);\n\tdevice_set_node(&mdiodev->dev, fwnode);\n\n\t \n\trc = mdio_device_register(mdiodev);\n\tif (rc) {\n\t\tdevice_set_node(&mdiodev->dev, NULL);\n\t\tfwnode_handle_put(fwnode);\n\t\tmdio_device_free(mdiodev);\n\t\treturn rc;\n\t}\n\n\tdev_dbg(&mdio->dev, \"registered mdio device %pOFn at address %i\\n\",\n\t\tchild, addr);\n\treturn 0;\n}\n\n \nstatic const struct of_device_id whitelist_phys[] = {\n\t{ .compatible = \"brcm,40nm-ephy\" },\n\t{ .compatible = \"broadcom,bcm5241\" },\n\t{ .compatible = \"marvell,88E1111\", },\n\t{ .compatible = \"marvell,88e1116\", },\n\t{ .compatible = \"marvell,88e1118\", },\n\t{ .compatible = \"marvell,88e1145\", },\n\t{ .compatible = \"marvell,88e1149r\", },\n\t{ .compatible = \"marvell,88e1310\", },\n\t{ .compatible = \"marvell,88E1510\", },\n\t{ .compatible = \"marvell,88E1514\", },\n\t{ .compatible = \"moxa,moxart-rtl8201cp\", },\n\t{}\n};\n\n \nbool of_mdiobus_child_is_phy(struct device_node *child)\n{\n\tu32 phy_id;\n\n\tif (of_get_phy_id(child, &phy_id) != -EINVAL)\n\t\treturn true;\n\n\tif (of_device_is_compatible(child, \"ethernet-phy-ieee802.3-c45\"))\n\t\treturn true;\n\n\tif (of_device_is_compatible(child, \"ethernet-phy-ieee802.3-c22\"))\n\t\treturn true;\n\n\tif (of_match_node(whitelist_phys, child)) {\n\t\tpr_warn(FW_WARN\n\t\t\t\"%pOF: Whitelisted compatible string. Please remove\\n\",\n\t\t\tchild);\n\t\treturn true;\n\t}\n\n\tif (!of_property_present(child, \"compatible\"))\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(of_mdiobus_child_is_phy);\n\n \nint __of_mdiobus_register(struct mii_bus *mdio, struct device_node *np,\n\t\t\t  struct module *owner)\n{\n\tstruct device_node *child;\n\tbool scanphys = false;\n\tint addr, rc;\n\n\tif (!np)\n\t\treturn __mdiobus_register(mdio, owner);\n\n\t \n\tif (!of_device_is_available(np))\n\t\treturn -ENODEV;\n\n\t \n\tmdio->phy_mask = ~0;\n\n\tdevice_set_node(&mdio->dev, of_fwnode_handle(np));\n\n\t \n\tmdio->reset_delay_us = DEFAULT_GPIO_RESET_DELAY;\n\tof_property_read_u32(np, \"reset-delay-us\", &mdio->reset_delay_us);\n\tmdio->reset_post_delay_us = 0;\n\tof_property_read_u32(np, \"reset-post-delay-us\", &mdio->reset_post_delay_us);\n\n\t \n\trc = __mdiobus_register(mdio, owner);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tfor_each_available_child_of_node(np, child) {\n\t\taddr = of_mdio_parse_addr(&mdio->dev, child);\n\t\tif (addr < 0) {\n\t\t\tscanphys = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (of_mdiobus_child_is_phy(child))\n\t\t\trc = of_mdiobus_register_phy(mdio, child, addr);\n\t\telse\n\t\t\trc = of_mdiobus_register_device(mdio, child, addr);\n\n\t\tif (rc == -ENODEV)\n\t\t\tdev_err(&mdio->dev,\n\t\t\t\t\"MDIO device at address %d is missing.\\n\",\n\t\t\t\taddr);\n\t\telse if (rc)\n\t\t\tgoto unregister;\n\t}\n\n\tif (!scanphys)\n\t\treturn 0;\n\n\t \n\tfor_each_available_child_of_node(np, child) {\n\t\t \n\t\tif (of_property_present(child, \"reg\"))\n\t\t\tcontinue;\n\n\t\tfor (addr = 0; addr < PHY_MAX_ADDR; addr++) {\n\t\t\t \n\t\t\tif (mdiobus_is_registered_device(mdio, addr))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tdev_info(&mdio->dev, \"scan phy %pOFn at address %i\\n\",\n\t\t\t\t child, addr);\n\n\t\t\tif (of_mdiobus_child_is_phy(child)) {\n\t\t\t\t \n\t\t\t\trc = of_mdiobus_register_phy(mdio, child, addr);\n\t\t\t\tif (!rc)\n\t\t\t\t\tbreak;\n\t\t\t\tif (rc != -ENODEV)\n\t\t\t\t\tgoto unregister;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nunregister:\n\tof_node_put(child);\n\tmdiobus_unregister(mdio);\n\treturn rc;\n}\nEXPORT_SYMBOL(__of_mdiobus_register);\n\n \nstruct mdio_device *of_mdio_find_device(struct device_node *np)\n{\n\treturn fwnode_mdio_find_device(of_fwnode_handle(np));\n}\nEXPORT_SYMBOL(of_mdio_find_device);\n\n \nstruct phy_device *of_phy_find_device(struct device_node *phy_np)\n{\n\treturn fwnode_phy_find_device(of_fwnode_handle(phy_np));\n}\nEXPORT_SYMBOL(of_phy_find_device);\n\n \nstruct phy_device *of_phy_connect(struct net_device *dev,\n\t\t\t\t  struct device_node *phy_np,\n\t\t\t\t  void (*hndlr)(struct net_device *), u32 flags,\n\t\t\t\t  phy_interface_t iface)\n{\n\tstruct phy_device *phy = of_phy_find_device(phy_np);\n\tint ret;\n\n\tif (!phy)\n\t\treturn NULL;\n\n\tphy->dev_flags |= flags;\n\n\tret = phy_connect_direct(dev, phy, hndlr, iface);\n\n\t \n\tput_device(&phy->mdio.dev);\n\n\treturn ret ? NULL : phy;\n}\nEXPORT_SYMBOL(of_phy_connect);\n\n \nstruct phy_device *of_phy_get_and_connect(struct net_device *dev,\n\t\t\t\t\t  struct device_node *np,\n\t\t\t\t\t  void (*hndlr)(struct net_device *))\n{\n\tphy_interface_t iface;\n\tstruct device_node *phy_np;\n\tstruct phy_device *phy;\n\tint ret;\n\n\tret = of_get_phy_mode(np, &iface);\n\tif (ret)\n\t\treturn NULL;\n\tif (of_phy_is_fixed_link(np)) {\n\t\tret = of_phy_register_fixed_link(np);\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(dev, \"broken fixed-link specification\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tphy_np = of_node_get(np);\n\t} else {\n\t\tphy_np = of_parse_phandle(np, \"phy-handle\", 0);\n\t\tif (!phy_np)\n\t\t\treturn NULL;\n\t}\n\n\tphy = of_phy_connect(dev, phy_np, hndlr, 0, iface);\n\n\tof_node_put(phy_np);\n\n\treturn phy;\n}\nEXPORT_SYMBOL(of_phy_get_and_connect);\n\n \nbool of_phy_is_fixed_link(struct device_node *np)\n{\n\tstruct device_node *dn;\n\tint len, err;\n\tconst char *managed;\n\n\t \n\tdn = of_get_child_by_name(np, \"fixed-link\");\n\tif (dn) {\n\t\tof_node_put(dn);\n\t\treturn true;\n\t}\n\n\terr = of_property_read_string(np, \"managed\", &managed);\n\tif (err == 0 && strcmp(managed, \"auto\") != 0)\n\t\treturn true;\n\n\t \n\tif (of_get_property(np, \"fixed-link\", &len) &&\n\t    len == (5 * sizeof(__be32)))\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(of_phy_is_fixed_link);\n\nint of_phy_register_fixed_link(struct device_node *np)\n{\n\tstruct fixed_phy_status status = {};\n\tstruct device_node *fixed_link_node;\n\tu32 fixed_link_prop[5];\n\tconst char *managed;\n\n\tif (of_property_read_string(np, \"managed\", &managed) == 0 &&\n\t    strcmp(managed, \"in-band-status\") == 0) {\n\t\t \n\t\tgoto register_phy;\n\t}\n\n\t \n\tfixed_link_node = of_get_child_by_name(np, \"fixed-link\");\n\tif (fixed_link_node) {\n\t\tstatus.link = 1;\n\t\tstatus.duplex = of_property_read_bool(fixed_link_node,\n\t\t\t\t\t\t      \"full-duplex\");\n\t\tif (of_property_read_u32(fixed_link_node, \"speed\",\n\t\t\t\t\t &status.speed)) {\n\t\t\tof_node_put(fixed_link_node);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstatus.pause = of_property_read_bool(fixed_link_node, \"pause\");\n\t\tstatus.asym_pause = of_property_read_bool(fixed_link_node,\n\t\t\t\t\t\t\t  \"asym-pause\");\n\t\tof_node_put(fixed_link_node);\n\n\t\tgoto register_phy;\n\t}\n\n\t \n\tif (of_property_read_u32_array(np, \"fixed-link\", fixed_link_prop,\n\t\t\t\t       ARRAY_SIZE(fixed_link_prop)) == 0) {\n\t\tstatus.link = 1;\n\t\tstatus.duplex = fixed_link_prop[1];\n\t\tstatus.speed  = fixed_link_prop[2];\n\t\tstatus.pause  = fixed_link_prop[3];\n\t\tstatus.asym_pause = fixed_link_prop[4];\n\t\tgoto register_phy;\n\t}\n\n\treturn -ENODEV;\n\nregister_phy:\n\treturn PTR_ERR_OR_ZERO(fixed_phy_register(PHY_POLL, &status, np));\n}\nEXPORT_SYMBOL(of_phy_register_fixed_link);\n\nvoid of_phy_deregister_fixed_link(struct device_node *np)\n{\n\tstruct phy_device *phydev;\n\n\tphydev = of_phy_find_device(np);\n\tif (!phydev)\n\t\treturn;\n\n\tfixed_phy_unregister(phydev);\n\n\tput_device(&phydev->mdio.dev);\t \n\tphy_device_free(phydev);\t \n}\nEXPORT_SYMBOL(of_phy_deregister_fixed_link);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}