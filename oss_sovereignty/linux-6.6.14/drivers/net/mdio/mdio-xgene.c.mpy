{
  "module_name": "mdio-xgene.c",
  "hash_id": "13589615f9c5a0aa2ba4e9bc9571fdc4786cde36be881b8bb90434f41a996715",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-xgene.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/efi.h>\n#include <linux/if_vlan.h>\n#include <linux/io.h>\n#include <linux/mdio/mdio-xgene.h>\n#include <linux/module.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_platform.h>\n#include <linux/phy.h>\n#include <linux/prefetch.h>\n#include <net/ip.h>\n\nu32 xgene_mdio_rd_mac(struct xgene_mdio_pdata *pdata, u32 rd_addr)\n{\n\tvoid __iomem *addr, *rd, *cmd, *cmd_done;\n\tu32 done, rd_data = BUSY_MASK;\n\tu8 wait = 10;\n\n\taddr = pdata->mac_csr_addr + MAC_ADDR_REG_OFFSET;\n\trd = pdata->mac_csr_addr + MAC_READ_REG_OFFSET;\n\tcmd = pdata->mac_csr_addr + MAC_COMMAND_REG_OFFSET;\n\tcmd_done = pdata->mac_csr_addr + MAC_COMMAND_DONE_REG_OFFSET;\n\n\tspin_lock(&pdata->mac_lock);\n\tiowrite32(rd_addr, addr);\n\tiowrite32(XGENE_ENET_RD_CMD, cmd);\n\n\twhile (!(done = ioread32(cmd_done)) && wait--)\n\t\tudelay(1);\n\n\tif (done)\n\t\trd_data = ioread32(rd);\n\n\tiowrite32(0, cmd);\n\tspin_unlock(&pdata->mac_lock);\n\n\treturn rd_data;\n}\nEXPORT_SYMBOL(xgene_mdio_rd_mac);\n\nvoid xgene_mdio_wr_mac(struct xgene_mdio_pdata *pdata, u32 wr_addr, u32 data)\n{\n\tvoid __iomem *addr, *wr, *cmd, *cmd_done;\n\tu8 wait = 10;\n\tu32 done;\n\n\taddr = pdata->mac_csr_addr + MAC_ADDR_REG_OFFSET;\n\twr = pdata->mac_csr_addr + MAC_WRITE_REG_OFFSET;\n\tcmd = pdata->mac_csr_addr + MAC_COMMAND_REG_OFFSET;\n\tcmd_done = pdata->mac_csr_addr + MAC_COMMAND_DONE_REG_OFFSET;\n\n\tspin_lock(&pdata->mac_lock);\n\tiowrite32(wr_addr, addr);\n\tiowrite32(data, wr);\n\tiowrite32(XGENE_ENET_WR_CMD, cmd);\n\n\twhile (!(done = ioread32(cmd_done)) && wait--)\n\t\tudelay(1);\n\n\tif (!done)\n\t\tpr_err(\"MCX mac write failed, addr: 0x%04x\\n\", wr_addr);\n\n\tiowrite32(0, cmd);\n\tspin_unlock(&pdata->mac_lock);\n}\nEXPORT_SYMBOL(xgene_mdio_wr_mac);\n\nint xgene_mdio_rgmii_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tstruct xgene_mdio_pdata *pdata = bus->priv;\n\tu32 data, done;\n\tu8 wait = 10;\n\n\tdata = SET_VAL(PHY_ADDR, phy_id) | SET_VAL(REG_ADDR, reg);\n\txgene_mdio_wr_mac(pdata, MII_MGMT_ADDRESS_ADDR, data);\n\txgene_mdio_wr_mac(pdata, MII_MGMT_COMMAND_ADDR, READ_CYCLE_MASK);\n\tdo {\n\t\tusleep_range(5, 10);\n\t\tdone = xgene_mdio_rd_mac(pdata, MII_MGMT_INDICATORS_ADDR);\n\t} while ((done & BUSY_MASK) && wait--);\n\n\tif (done & BUSY_MASK) {\n\t\tdev_err(&bus->dev, \"MII_MGMT read failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tdata = xgene_mdio_rd_mac(pdata, MII_MGMT_STATUS_ADDR);\n\txgene_mdio_wr_mac(pdata, MII_MGMT_COMMAND_ADDR, 0);\n\n\treturn data;\n}\nEXPORT_SYMBOL(xgene_mdio_rgmii_read);\n\nint xgene_mdio_rgmii_write(struct mii_bus *bus, int phy_id, int reg, u16 data)\n{\n\tstruct xgene_mdio_pdata *pdata = bus->priv;\n\tu32 val, done;\n\tu8 wait = 10;\n\n\tval = SET_VAL(PHY_ADDR, phy_id) | SET_VAL(REG_ADDR, reg);\n\txgene_mdio_wr_mac(pdata, MII_MGMT_ADDRESS_ADDR, val);\n\n\txgene_mdio_wr_mac(pdata, MII_MGMT_CONTROL_ADDR, data);\n\tdo {\n\t\tusleep_range(5, 10);\n\t\tdone = xgene_mdio_rd_mac(pdata, MII_MGMT_INDICATORS_ADDR);\n\t} while ((done & BUSY_MASK) && wait--);\n\n\tif (done & BUSY_MASK) {\n\t\tdev_err(&bus->dev, \"MII_MGMT write failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(xgene_mdio_rgmii_write);\n\nstatic u32 xgene_menet_rd_diag_csr(struct xgene_mdio_pdata *pdata, u32 offset)\n{\n\treturn ioread32(pdata->diag_csr_addr + offset);\n}\n\nstatic void xgene_menet_wr_diag_csr(struct xgene_mdio_pdata *pdata,\n\t\t\t\t    u32 offset, u32 val)\n{\n\tiowrite32(val, pdata->diag_csr_addr + offset);\n}\n\nstatic int xgene_enet_ecc_init(struct xgene_mdio_pdata *pdata)\n{\n\tu32 data;\n\tu8 wait = 10;\n\n\txgene_menet_wr_diag_csr(pdata, MENET_CFG_MEM_RAM_SHUTDOWN_ADDR, 0x0);\n\tdo {\n\t\tusleep_range(100, 110);\n\t\tdata = xgene_menet_rd_diag_csr(pdata, MENET_BLOCK_MEM_RDY_ADDR);\n\t} while ((data != 0xffffffff) && wait--);\n\n\tif (data != 0xffffffff) {\n\t\tdev_err(pdata->dev, \"Failed to release memory from shutdown\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void xgene_gmac_reset(struct xgene_mdio_pdata *pdata)\n{\n\txgene_mdio_wr_mac(pdata, MAC_CONFIG_1_ADDR, SOFT_RESET);\n\txgene_mdio_wr_mac(pdata, MAC_CONFIG_1_ADDR, 0);\n}\n\nstatic int xgene_mdio_reset(struct xgene_mdio_pdata *pdata)\n{\n\tint ret;\n\n\tif (pdata->dev->of_node) {\n\t\tclk_prepare_enable(pdata->clk);\n\t\tudelay(5);\n\t\tclk_disable_unprepare(pdata->clk);\n\t\tudelay(5);\n\t\tclk_prepare_enable(pdata->clk);\n\t\tudelay(5);\n\t} else {\n#ifdef CONFIG_ACPI\n\t\tacpi_evaluate_object(ACPI_HANDLE(pdata->dev),\n\t\t\t\t     \"_RST\", NULL, NULL);\n#endif\n\t}\n\n\tret = xgene_enet_ecc_init(pdata);\n\tif (ret) {\n\t\tif (pdata->dev->of_node)\n\t\t\tclk_disable_unprepare(pdata->clk);\n\t\treturn ret;\n\t}\n\txgene_gmac_reset(pdata);\n\n\treturn 0;\n}\n\nstatic void xgene_enet_rd_mdio_csr(void __iomem *base_addr,\n\t\t\t\t   u32 offset, u32 *val)\n{\n\tvoid __iomem *addr = base_addr  + offset;\n\n\t*val = ioread32(addr);\n}\n\nstatic void xgene_enet_wr_mdio_csr(void __iomem *base_addr,\n\t\t\t\t   u32 offset, u32 val)\n{\n\tvoid __iomem *addr = base_addr  + offset;\n\n\tiowrite32(val, addr);\n}\n\nstatic int xgene_xfi_mdio_write(struct mii_bus *bus, int phy_id,\n\t\t\t\tint reg, u16 data)\n{\n\tvoid __iomem *addr = (void __iomem *)bus->priv;\n\tint timeout = 100;\n\tu32 status, val;\n\n\tval = SET_VAL(HSTPHYADX, phy_id) | SET_VAL(HSTREGADX, reg) |\n\t      SET_VAL(HSTMIIMWRDAT, data);\n\txgene_enet_wr_mdio_csr(addr, MIIM_FIELD_ADDR, val);\n\n\tval = HSTLDCMD | SET_VAL(HSTMIIMCMD, MIIM_CMD_LEGACY_WRITE);\n\txgene_enet_wr_mdio_csr(addr, MIIM_COMMAND_ADDR, val);\n\n\tdo {\n\t\tusleep_range(5, 10);\n\t\txgene_enet_rd_mdio_csr(addr, MIIM_INDICATOR_ADDR, &status);\n\t} while ((status & BUSY_MASK) && timeout--);\n\n\txgene_enet_wr_mdio_csr(addr, MIIM_COMMAND_ADDR, 0);\n\n\treturn 0;\n}\n\nstatic int xgene_xfi_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tvoid __iomem *addr = (void __iomem *)bus->priv;\n\tu32 data, status, val;\n\tint timeout = 100;\n\n\tval = SET_VAL(HSTPHYADX, phy_id) | SET_VAL(HSTREGADX, reg);\n\txgene_enet_wr_mdio_csr(addr, MIIM_FIELD_ADDR, val);\n\n\tval = HSTLDCMD | SET_VAL(HSTMIIMCMD, MIIM_CMD_LEGACY_READ);\n\txgene_enet_wr_mdio_csr(addr, MIIM_COMMAND_ADDR, val);\n\n\tdo {\n\t\tusleep_range(5, 10);\n\t\txgene_enet_rd_mdio_csr(addr, MIIM_INDICATOR_ADDR, &status);\n\t} while ((status & BUSY_MASK) && timeout--);\n\n\tif (status & BUSY_MASK) {\n\t\tpr_err(\"XGENET_MII_MGMT write failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\txgene_enet_rd_mdio_csr(addr, MIIMRD_FIELD_ADDR, &data);\n\txgene_enet_wr_mdio_csr(addr, MIIM_COMMAND_ADDR, 0);\n\n\treturn data;\n}\n\nstruct phy_device *xgene_enet_phy_register(struct mii_bus *bus, int phy_addr)\n{\n\tstruct phy_device *phy_dev;\n\n\tphy_dev = get_phy_device(bus, phy_addr, false);\n\tif (!phy_dev || IS_ERR(phy_dev))\n\t\treturn NULL;\n\n\tif (phy_device_register(phy_dev))\n\t\tphy_device_free(phy_dev);\n\n\treturn phy_dev;\n}\nEXPORT_SYMBOL(xgene_enet_phy_register);\n\n#ifdef CONFIG_ACPI\nstatic acpi_status acpi_register_phy(acpi_handle handle, u32 lvl,\n\t\t\t\t     void *context, void **ret)\n{\n\tstruct mii_bus *mdio = context;\n\tstruct acpi_device *adev;\n\tstruct phy_device *phy_dev;\n\tconst union acpi_object *obj;\n\tu32 phy_addr;\n\n\tadev = acpi_fetch_acpi_dev(handle);\n\tif (!adev)\n\t\treturn AE_OK;\n\n\tif (acpi_dev_get_property(adev, \"phy-channel\", ACPI_TYPE_INTEGER, &obj))\n\t\treturn AE_OK;\n\tphy_addr = obj->integer.value;\n\n\tphy_dev = xgene_enet_phy_register(mdio, phy_addr);\n\tadev->driver_data = phy_dev;\n\n\treturn AE_OK;\n}\n#endif\n\nstatic const struct of_device_id xgene_mdio_of_match[] = {\n\t{\n\t\t.compatible = \"apm,xgene-mdio-rgmii\",\n\t\t.data = (void *)XGENE_MDIO_RGMII\n\t},\n\t{\n\t\t.compatible = \"apm,xgene-mdio-xfi\",\n\t\t.data = (void *)XGENE_MDIO_XFI\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xgene_mdio_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id xgene_mdio_acpi_match[] = {\n\t{ \"APMC0D65\", XGENE_MDIO_RGMII },\n\t{ \"APMC0D66\", XGENE_MDIO_XFI },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(acpi, xgene_mdio_acpi_match);\n#endif\n\n\nstatic int xgene_mdio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mii_bus *mdio_bus;\n\tconst struct of_device_id *of_id;\n\tstruct xgene_mdio_pdata *pdata;\n\tvoid __iomem *csr_base;\n\tint mdio_id = 0, ret = 0;\n\n\tof_id = of_match_device(xgene_mdio_of_match, &pdev->dev);\n\tif (of_id) {\n\t\tmdio_id = (uintptr_t)of_id->data;\n\t} else {\n#ifdef CONFIG_ACPI\n\t\tconst struct acpi_device_id *acpi_id;\n\n\t\tacpi_id = acpi_match_device(xgene_mdio_acpi_match, &pdev->dev);\n\t\tif (acpi_id)\n\t\t\tmdio_id = (enum xgene_mdio_id)acpi_id->driver_data;\n#endif\n\t}\n\n\tif (!mdio_id)\n\t\treturn -ENODEV;\n\n\tpdata = devm_kzalloc(dev, sizeof(struct xgene_mdio_pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\tpdata->mdio_id = mdio_id;\n\tpdata->dev = dev;\n\n\tcsr_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(csr_base))\n\t\treturn PTR_ERR(csr_base);\n\tpdata->mac_csr_addr = csr_base;\n\tpdata->mdio_csr_addr = csr_base + BLOCK_XG_MDIO_CSR_OFFSET;\n\tpdata->diag_csr_addr = csr_base + BLOCK_DIAG_CSR_OFFSET;\n\n\tif (mdio_id == XGENE_MDIO_RGMII)\n\t\tspin_lock_init(&pdata->mac_lock);\n\n\tif (dev->of_node) {\n\t\tpdata->clk = devm_clk_get(dev, NULL);\n\t\tif (IS_ERR(pdata->clk)) {\n\t\t\tdev_err(dev, \"Unable to retrieve clk\\n\");\n\t\t\treturn PTR_ERR(pdata->clk);\n\t\t}\n\t}\n\n\tret = xgene_mdio_reset(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tmdio_bus = mdiobus_alloc();\n\tif (!mdio_bus) {\n\t\tret = -ENOMEM;\n\t\tgoto out_clk;\n\t}\n\n\tmdio_bus->name = \"APM X-Gene MDIO bus\";\n\n\tif (mdio_id == XGENE_MDIO_RGMII) {\n\t\tmdio_bus->read = xgene_mdio_rgmii_read;\n\t\tmdio_bus->write = xgene_mdio_rgmii_write;\n\t\tmdio_bus->priv = (void __force *)pdata;\n\t\tsnprintf(mdio_bus->id, MII_BUS_ID_SIZE, \"%s\",\n\t\t\t \"xgene-mii-rgmii\");\n\t} else {\n\t\tmdio_bus->read = xgene_xfi_mdio_read;\n\t\tmdio_bus->write = xgene_xfi_mdio_write;\n\t\tmdio_bus->priv = (void __force *)pdata->mdio_csr_addr;\n\t\tsnprintf(mdio_bus->id, MII_BUS_ID_SIZE, \"%s\",\n\t\t\t \"xgene-mii-xfi\");\n\t}\n\n\tmdio_bus->parent = dev;\n\tplatform_set_drvdata(pdev, pdata);\n\n\tif (dev->of_node) {\n\t\tret = of_mdiobus_register(mdio_bus, dev->of_node);\n\t} else {\n#ifdef CONFIG_ACPI\n\t\t \n\t\tmdio_bus->phy_mask = ~0;\n\t\tret = mdiobus_register(mdio_bus);\n\t\tif (ret)\n\t\t\tgoto out_mdiobus;\n\n\t\tacpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_HANDLE(dev), 1,\n\t\t\t\t    acpi_register_phy, NULL, mdio_bus, NULL);\n#endif\n\t}\n\n\tif (ret)\n\t\tgoto out_mdiobus;\n\n\tpdata->mdio_bus = mdio_bus;\n\n\treturn 0;\n\nout_mdiobus:\n\tmdiobus_free(mdio_bus);\n\nout_clk:\n\tif (dev->of_node)\n\t\tclk_disable_unprepare(pdata->clk);\n\n\treturn ret;\n}\n\nstatic int xgene_mdio_remove(struct platform_device *pdev)\n{\n\tstruct xgene_mdio_pdata *pdata = platform_get_drvdata(pdev);\n\tstruct mii_bus *mdio_bus = pdata->mdio_bus;\n\tstruct device *dev = &pdev->dev;\n\n\tmdiobus_unregister(mdio_bus);\n\tmdiobus_free(mdio_bus);\n\n\tif (dev->of_node)\n\t\tclk_disable_unprepare(pdata->clk);\n\n\treturn 0;\n}\n\nstatic struct platform_driver xgene_mdio_driver = {\n\t.driver = {\n\t\t.name = \"xgene-mdio\",\n\t\t.of_match_table = of_match_ptr(xgene_mdio_of_match),\n\t\t.acpi_match_table = ACPI_PTR(xgene_mdio_acpi_match),\n\t},\n\t.probe = xgene_mdio_probe,\n\t.remove = xgene_mdio_remove,\n};\n\nmodule_platform_driver(xgene_mdio_driver);\n\nMODULE_DESCRIPTION(\"APM X-Gene SoC MDIO driver\");\nMODULE_AUTHOR(\"Iyappan Subramanian <isubramanian@apm.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}