{
  "module_name": "mdio-mux.c",
  "hash_id": "c87fe9b2b78effd486e714401e6fcf361c9c959aeb1c8e6a7df6041f96e16bed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-mux.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/mdio-mux.h>\n#include <linux/module.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n\n#define DRV_DESCRIPTION \"MDIO bus multiplexer driver\"\n\nstruct mdio_mux_child_bus;\n\nstruct mdio_mux_parent_bus {\n\tstruct mii_bus *mii_bus;\n\tint current_child;\n\tint parent_id;\n\tvoid *switch_data;\n\tint (*switch_fn)(int current_child, int desired_child, void *data);\n\n\t \n\tstruct mdio_mux_child_bus *children;\n};\n\nstruct mdio_mux_child_bus {\n\tstruct mii_bus *mii_bus;\n\tstruct mdio_mux_parent_bus *parent;\n\tstruct mdio_mux_child_bus *next;\n\tint bus_number;\n};\n\n \nstatic int mdio_mux_read(struct mii_bus *bus, int phy_id, int regnum)\n{\n\tstruct mdio_mux_child_bus *cb = bus->priv;\n\tstruct mdio_mux_parent_bus *pb = cb->parent;\n\tint r;\n\n\tmutex_lock_nested(&pb->mii_bus->mdio_lock, MDIO_MUTEX_MUX);\n\tr = pb->switch_fn(pb->current_child, cb->bus_number, pb->switch_data);\n\tif (r)\n\t\tgoto out;\n\n\tpb->current_child = cb->bus_number;\n\n\tr = pb->mii_bus->read(pb->mii_bus, phy_id, regnum);\nout:\n\tmutex_unlock(&pb->mii_bus->mdio_lock);\n\n\treturn r;\n}\n\nstatic int mdio_mux_read_c45(struct mii_bus *bus, int phy_id, int dev_addr,\n\t\t\t     int regnum)\n{\n\tstruct mdio_mux_child_bus *cb = bus->priv;\n\tstruct mdio_mux_parent_bus *pb = cb->parent;\n\tint r;\n\n\tmutex_lock_nested(&pb->mii_bus->mdio_lock, MDIO_MUTEX_MUX);\n\tr = pb->switch_fn(pb->current_child, cb->bus_number, pb->switch_data);\n\tif (r)\n\t\tgoto out;\n\n\tpb->current_child = cb->bus_number;\n\n\tr = pb->mii_bus->read_c45(pb->mii_bus, phy_id, dev_addr, regnum);\nout:\n\tmutex_unlock(&pb->mii_bus->mdio_lock);\n\n\treturn r;\n}\n\n \nstatic int mdio_mux_write(struct mii_bus *bus, int phy_id,\n\t\t\t  int regnum, u16 val)\n{\n\tstruct mdio_mux_child_bus *cb = bus->priv;\n\tstruct mdio_mux_parent_bus *pb = cb->parent;\n\n\tint r;\n\n\tmutex_lock_nested(&pb->mii_bus->mdio_lock, MDIO_MUTEX_MUX);\n\tr = pb->switch_fn(pb->current_child, cb->bus_number, pb->switch_data);\n\tif (r)\n\t\tgoto out;\n\n\tpb->current_child = cb->bus_number;\n\n\tr = pb->mii_bus->write(pb->mii_bus, phy_id, regnum, val);\nout:\n\tmutex_unlock(&pb->mii_bus->mdio_lock);\n\n\treturn r;\n}\n\nstatic int mdio_mux_write_c45(struct mii_bus *bus, int phy_id, int dev_addr,\n\t\t\t      int regnum, u16 val)\n{\n\tstruct mdio_mux_child_bus *cb = bus->priv;\n\tstruct mdio_mux_parent_bus *pb = cb->parent;\n\n\tint r;\n\n\tmutex_lock_nested(&pb->mii_bus->mdio_lock, MDIO_MUTEX_MUX);\n\tr = pb->switch_fn(pb->current_child, cb->bus_number, pb->switch_data);\n\tif (r)\n\t\tgoto out;\n\n\tpb->current_child = cb->bus_number;\n\n\tr = pb->mii_bus->write_c45(pb->mii_bus, phy_id, dev_addr, regnum, val);\nout:\n\tmutex_unlock(&pb->mii_bus->mdio_lock);\n\n\treturn r;\n}\n\nstatic int parent_count;\n\nstatic void mdio_mux_uninit_children(struct mdio_mux_parent_bus *pb)\n{\n\tstruct mdio_mux_child_bus *cb = pb->children;\n\n\twhile (cb) {\n\t\tmdiobus_unregister(cb->mii_bus);\n\t\tmdiobus_free(cb->mii_bus);\n\t\tcb = cb->next;\n\t}\n}\n\nint mdio_mux_init(struct device *dev,\n\t\t  struct device_node *mux_node,\n\t\t  int (*switch_fn)(int cur, int desired, void *data),\n\t\t  void **mux_handle,\n\t\t  void *data,\n\t\t  struct mii_bus *mux_bus)\n{\n\tstruct device_node *parent_bus_node;\n\tstruct device_node *child_bus_node;\n\tint r, ret_val;\n\tstruct mii_bus *parent_bus;\n\tstruct mdio_mux_parent_bus *pb;\n\tstruct mdio_mux_child_bus *cb;\n\n\tif (!mux_node)\n\t\treturn -ENODEV;\n\n\tif (!mux_bus) {\n\t\tparent_bus_node = of_parse_phandle(mux_node,\n\t\t\t\t\t\t   \"mdio-parent-bus\", 0);\n\n\t\tif (!parent_bus_node)\n\t\t\treturn -ENODEV;\n\n\t\tparent_bus = of_mdio_find_bus(parent_bus_node);\n\t\tif (!parent_bus) {\n\t\t\tret_val = -EPROBE_DEFER;\n\t\t\tgoto err_parent_bus;\n\t\t}\n\t} else {\n\t\tparent_bus_node = NULL;\n\t\tparent_bus = mux_bus;\n\t\tget_device(&parent_bus->dev);\n\t}\n\n\tpb = devm_kzalloc(dev, sizeof(*pb), GFP_KERNEL);\n\tif (!pb) {\n\t\tret_val = -ENOMEM;\n\t\tgoto err_pb_kz;\n\t}\n\n\tpb->switch_data = data;\n\tpb->switch_fn = switch_fn;\n\tpb->current_child = -1;\n\tpb->parent_id = parent_count++;\n\tpb->mii_bus = parent_bus;\n\n\tret_val = -ENODEV;\n\tfor_each_available_child_of_node(mux_node, child_bus_node) {\n\t\tint v;\n\n\t\tr = of_property_read_u32(child_bus_node, \"reg\", &v);\n\t\tif (r) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Error: Failed to find reg for child %pOF\\n\",\n\t\t\t\tchild_bus_node);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcb = devm_kzalloc(dev, sizeof(*cb), GFP_KERNEL);\n\t\tif (!cb) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto err_loop;\n\t\t}\n\t\tcb->bus_number = v;\n\t\tcb->parent = pb;\n\n\t\tcb->mii_bus = mdiobus_alloc();\n\t\tif (!cb->mii_bus) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto err_loop;\n\t\t}\n\t\tcb->mii_bus->priv = cb;\n\n\t\tcb->mii_bus->name = \"mdio_mux\";\n\t\tsnprintf(cb->mii_bus->id, MII_BUS_ID_SIZE, \"%s-%x.%x\",\n\t\t\t cb->mii_bus->name, pb->parent_id, v);\n\t\tcb->mii_bus->parent = dev;\n\t\tcb->mii_bus->read = mdio_mux_read;\n\t\tcb->mii_bus->write = mdio_mux_write;\n\t\tif (parent_bus->read_c45)\n\t\t\tcb->mii_bus->read_c45 = mdio_mux_read_c45;\n\t\tif (parent_bus->write_c45)\n\t\t\tcb->mii_bus->write_c45 = mdio_mux_write_c45;\n\t\tr = of_mdiobus_register(cb->mii_bus, child_bus_node);\n\t\tif (r) {\n\t\t\tmdiobus_free(cb->mii_bus);\n\t\t\tif (r == -EPROBE_DEFER) {\n\t\t\t\tret_val = r;\n\t\t\t\tgoto err_loop;\n\t\t\t}\n\t\t\tdevm_kfree(dev, cb);\n\t\t\tdev_err(dev,\n\t\t\t\t\"Error: Failed to register MDIO bus for child %pOF\\n\",\n\t\t\t\tchild_bus_node);\n\t\t} else {\n\t\t\tcb->next = pb->children;\n\t\t\tpb->children = cb;\n\t\t}\n\t}\n\tif (pb->children) {\n\t\t*mux_handle = pb;\n\t\treturn 0;\n\t}\n\n\tdev_err(dev, \"Error: No acceptable child buses found\\n\");\n\nerr_loop:\n\tmdio_mux_uninit_children(pb);\n\tof_node_put(child_bus_node);\nerr_pb_kz:\n\tput_device(&parent_bus->dev);\nerr_parent_bus:\n\tof_node_put(parent_bus_node);\n\treturn ret_val;\n}\nEXPORT_SYMBOL_GPL(mdio_mux_init);\n\nvoid mdio_mux_uninit(void *mux_handle)\n{\n\tstruct mdio_mux_parent_bus *pb = mux_handle;\n\n\tmdio_mux_uninit_children(pb);\n\tput_device(&pb->mii_bus->dev);\n}\nEXPORT_SYMBOL_GPL(mdio_mux_uninit);\n\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_AUTHOR(\"David Daney\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}