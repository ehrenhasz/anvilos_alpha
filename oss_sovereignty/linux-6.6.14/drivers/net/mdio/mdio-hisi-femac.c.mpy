{
  "module_name": "mdio-hisi-femac.c",
  "hash_id": "b8abc3e44d512aab0e79e506fba05c2572b88ba6366f51a3d06c5185817906f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-hisi-femac.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_mdio.h>\n#include <linux/platform_device.h>\n\n#define MDIO_RWCTRL\t\t0x00\n#define MDIO_RO_DATA\t\t0x04\n#define MDIO_WRITE\t\tBIT(13)\n#define MDIO_RW_FINISH\t\tBIT(15)\n#define BIT_PHY_ADDR_OFFSET\t8\n#define BIT_WR_DATA_OFFSET\t16\n\nstruct hisi_femac_mdio_data {\n\tstruct clk *clk;\n\tvoid __iomem *membase;\n};\n\nstatic int hisi_femac_mdio_wait_ready(struct hisi_femac_mdio_data *data)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(data->membase + MDIO_RWCTRL,\n\t\t\t\t  val, val & MDIO_RW_FINISH, 20, 10000);\n}\n\nstatic int hisi_femac_mdio_read(struct mii_bus *bus, int mii_id, int regnum)\n{\n\tstruct hisi_femac_mdio_data *data = bus->priv;\n\tint ret;\n\n\tret = hisi_femac_mdio_wait_ready(data);\n\tif (ret)\n\t\treturn ret;\n\n\twritel((mii_id << BIT_PHY_ADDR_OFFSET) | regnum,\n\t       data->membase + MDIO_RWCTRL);\n\n\tret = hisi_femac_mdio_wait_ready(data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn readl(data->membase + MDIO_RO_DATA) & 0xFFFF;\n}\n\nstatic int hisi_femac_mdio_write(struct mii_bus *bus, int mii_id, int regnum,\n\t\t\t\t u16 value)\n{\n\tstruct hisi_femac_mdio_data *data = bus->priv;\n\tint ret;\n\n\tret = hisi_femac_mdio_wait_ready(data);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(MDIO_WRITE | (value << BIT_WR_DATA_OFFSET) |\n\t       (mii_id << BIT_PHY_ADDR_OFFSET) | regnum,\n\t       data->membase + MDIO_RWCTRL);\n\n\treturn hisi_femac_mdio_wait_ready(data);\n}\n\nstatic int hisi_femac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct mii_bus *bus;\n\tstruct hisi_femac_mdio_data *data;\n\tint ret;\n\n\tbus = mdiobus_alloc_size(sizeof(*data));\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->name = \"hisi_femac_mii_bus\";\n\tbus->read = &hisi_femac_mdio_read;\n\tbus->write = &hisi_femac_mdio_write;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s\", pdev->name);\n\tbus->parent = &pdev->dev;\n\n\tdata = bus->priv;\n\tdata->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->membase)) {\n\t\tret = PTR_ERR(data->membase);\n\t\tgoto err_out_free_mdiobus;\n\t}\n\n\tdata->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(data->clk)) {\n\t\tret = PTR_ERR(data->clk);\n\t\tgoto err_out_free_mdiobus;\n\t}\n\n\tret = clk_prepare_enable(data->clk);\n\tif (ret)\n\t\tgoto err_out_free_mdiobus;\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret)\n\t\tgoto err_out_disable_clk;\n\n\tplatform_set_drvdata(pdev, bus);\n\n\treturn 0;\n\nerr_out_disable_clk:\n\tclk_disable_unprepare(data->clk);\nerr_out_free_mdiobus:\n\tmdiobus_free(bus);\n\treturn ret;\n}\n\nstatic int hisi_femac_mdio_remove(struct platform_device *pdev)\n{\n\tstruct mii_bus *bus = platform_get_drvdata(pdev);\n\tstruct hisi_femac_mdio_data *data = bus->priv;\n\n\tmdiobus_unregister(bus);\n\tclk_disable_unprepare(data->clk);\n\tmdiobus_free(bus);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id hisi_femac_mdio_dt_ids[] = {\n\t{ .compatible = \"hisilicon,hisi-femac-mdio\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, hisi_femac_mdio_dt_ids);\n\nstatic struct platform_driver hisi_femac_mdio_driver = {\n\t.probe = hisi_femac_mdio_probe,\n\t.remove = hisi_femac_mdio_remove,\n\t.driver = {\n\t\t.name = \"hisi-femac-mdio\",\n\t\t.of_match_table = hisi_femac_mdio_dt_ids,\n\t},\n};\n\nmodule_platform_driver(hisi_femac_mdio_driver);\n\nMODULE_DESCRIPTION(\"Hisilicon Fast Ethernet MAC MDIO interface driver\");\nMODULE_AUTHOR(\"Dongpo Li <lidongpo@hisilicon.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}