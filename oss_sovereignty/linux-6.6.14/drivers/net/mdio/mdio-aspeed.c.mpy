{
  "module_name": "mdio-aspeed.c",
  "hash_id": "05727083a4a6b688a24dbf15d6ae0fced8f0a0f6e4fed2b5850ce56d4ceec488",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-aspeed.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/reset.h>\n#include <linux/iopoll.h>\n#include <linux/mdio.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n\n#define DRV_NAME \"mdio-aspeed\"\n\n#define ASPEED_MDIO_CTRL\t\t0x0\n#define   ASPEED_MDIO_CTRL_FIRE\t\tBIT(31)\n#define   ASPEED_MDIO_CTRL_ST\t\tBIT(28)\n#define     ASPEED_MDIO_CTRL_ST_C45\t0\n#define     ASPEED_MDIO_CTRL_ST_C22\t1\n#define   ASPEED_MDIO_CTRL_OP\t\tGENMASK(27, 26)\n#define     MDIO_C22_OP_WRITE\t\t0b01\n#define     MDIO_C22_OP_READ\t\t0b10\n#define     MDIO_C45_OP_ADDR\t\t0b00\n#define     MDIO_C45_OP_WRITE\t\t0b01\n#define     MDIO_C45_OP_PREAD\t\t0b10\n#define     MDIO_C45_OP_READ\t\t0b11\n#define   ASPEED_MDIO_CTRL_PHYAD\tGENMASK(25, 21)\n#define   ASPEED_MDIO_CTRL_REGAD\tGENMASK(20, 16)\n#define   ASPEED_MDIO_CTRL_MIIWDATA\tGENMASK(15, 0)\n\n#define ASPEED_MDIO_DATA\t\t0x4\n#define   ASPEED_MDIO_DATA_MDC_THRES\tGENMASK(31, 24)\n#define   ASPEED_MDIO_DATA_MDIO_EDGE\tBIT(23)\n#define   ASPEED_MDIO_DATA_MDIO_LATCH\tGENMASK(22, 20)\n#define   ASPEED_MDIO_DATA_IDLE\t\tBIT(16)\n#define   ASPEED_MDIO_DATA_MIIRDATA\tGENMASK(15, 0)\n\n#define ASPEED_MDIO_INTERVAL_US\t\t100\n#define ASPEED_MDIO_TIMEOUT_US\t\t(ASPEED_MDIO_INTERVAL_US * 10)\n\nstruct aspeed_mdio {\n\tvoid __iomem *base;\n\tstruct reset_control *reset;\n};\n\nstatic int aspeed_mdio_op(struct mii_bus *bus, u8 st, u8 op, u8 phyad, u8 regad,\n\t\t\t  u16 data)\n{\n\tstruct aspeed_mdio *ctx = bus->priv;\n\tu32 ctrl;\n\n\tdev_dbg(&bus->dev, \"%s: st: %u op: %u, phyad: %u, regad: %u, data: %u\\n\",\n\t\t__func__, st, op, phyad, regad, data);\n\n\tctrl = ASPEED_MDIO_CTRL_FIRE\n\t\t| FIELD_PREP(ASPEED_MDIO_CTRL_ST, st)\n\t\t| FIELD_PREP(ASPEED_MDIO_CTRL_OP, op)\n\t\t| FIELD_PREP(ASPEED_MDIO_CTRL_PHYAD, phyad)\n\t\t| FIELD_PREP(ASPEED_MDIO_CTRL_REGAD, regad)\n\t\t| FIELD_PREP(ASPEED_MDIO_DATA_MIIRDATA, data);\n\n\tiowrite32(ctrl, ctx->base + ASPEED_MDIO_CTRL);\n\n\treturn readl_poll_timeout(ctx->base + ASPEED_MDIO_CTRL, ctrl,\n\t\t\t\t!(ctrl & ASPEED_MDIO_CTRL_FIRE),\n\t\t\t\tASPEED_MDIO_INTERVAL_US,\n\t\t\t\tASPEED_MDIO_TIMEOUT_US);\n}\n\nstatic int aspeed_mdio_get_data(struct mii_bus *bus)\n{\n\tstruct aspeed_mdio *ctx = bus->priv;\n\tu32 data;\n\tint rc;\n\n\trc = readl_poll_timeout(ctx->base + ASPEED_MDIO_DATA, data,\n\t\t\t\tdata & ASPEED_MDIO_DATA_IDLE,\n\t\t\t\tASPEED_MDIO_INTERVAL_US,\n\t\t\t\tASPEED_MDIO_TIMEOUT_US);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn FIELD_GET(ASPEED_MDIO_DATA_MIIRDATA, data);\n}\n\nstatic int aspeed_mdio_read_c22(struct mii_bus *bus, int addr, int regnum)\n{\n\tint rc;\n\n\trc = aspeed_mdio_op(bus, ASPEED_MDIO_CTRL_ST_C22, MDIO_C22_OP_READ,\n\t\t\t    addr, regnum, 0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn aspeed_mdio_get_data(bus);\n}\n\nstatic int aspeed_mdio_write_c22(struct mii_bus *bus, int addr, int regnum,\n\t\t\t\t u16 val)\n{\n\treturn aspeed_mdio_op(bus, ASPEED_MDIO_CTRL_ST_C22, MDIO_C22_OP_WRITE,\n\t\t\t      addr, regnum, val);\n}\n\nstatic int aspeed_mdio_read_c45(struct mii_bus *bus, int addr, int devad,\n\t\t\t\tint regnum)\n{\n\tint rc;\n\n\trc = aspeed_mdio_op(bus, ASPEED_MDIO_CTRL_ST_C45, MDIO_C45_OP_ADDR,\n\t\t\t    addr, devad, regnum);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = aspeed_mdio_op(bus, ASPEED_MDIO_CTRL_ST_C45, MDIO_C45_OP_READ,\n\t\t\t    addr, devad, 0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn aspeed_mdio_get_data(bus);\n}\n\nstatic int aspeed_mdio_write_c45(struct mii_bus *bus, int addr, int devad,\n\t\t\t\t int regnum, u16 val)\n{\n\tint rc;\n\n\trc = aspeed_mdio_op(bus, ASPEED_MDIO_CTRL_ST_C45, MDIO_C45_OP_ADDR,\n\t\t\t    addr, devad, regnum);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn aspeed_mdio_op(bus, ASPEED_MDIO_CTRL_ST_C45, MDIO_C45_OP_WRITE,\n\t\t\t      addr, devad, val);\n}\n\nstatic int aspeed_mdio_probe(struct platform_device *pdev)\n{\n\tstruct aspeed_mdio *ctx;\n\tstruct mii_bus *bus;\n\tint rc;\n\n\tbus = devm_mdiobus_alloc_size(&pdev->dev, sizeof(*ctx));\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tctx = bus->priv;\n\tctx->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctx->base))\n\t\treturn PTR_ERR(ctx->base);\n\n\tctx->reset = devm_reset_control_get_optional_shared(&pdev->dev, NULL);\n\tif (IS_ERR(ctx->reset))\n\t\treturn PTR_ERR(ctx->reset);\n\n\treset_control_deassert(ctx->reset);\n\n\tbus->name = DRV_NAME;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s%d\", pdev->name, pdev->id);\n\tbus->parent = &pdev->dev;\n\tbus->read = aspeed_mdio_read_c22;\n\tbus->write = aspeed_mdio_write_c22;\n\tbus->read_c45 = aspeed_mdio_read_c45;\n\tbus->write_c45 = aspeed_mdio_write_c45;\n\n\trc = of_mdiobus_register(bus, pdev->dev.of_node);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Cannot register MDIO bus!\\n\");\n\t\treset_control_assert(ctx->reset);\n\t\treturn rc;\n\t}\n\n\tplatform_set_drvdata(pdev, bus);\n\n\treturn 0;\n}\n\nstatic int aspeed_mdio_remove(struct platform_device *pdev)\n{\n\tstruct mii_bus *bus = (struct mii_bus *)platform_get_drvdata(pdev);\n\tstruct aspeed_mdio *ctx = bus->priv;\n\n\treset_control_assert(ctx->reset);\n\tmdiobus_unregister(bus);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id aspeed_mdio_of_match[] = {\n\t{ .compatible = \"aspeed,ast2600-mdio\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, aspeed_mdio_of_match);\n\nstatic struct platform_driver aspeed_mdio_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = aspeed_mdio_of_match,\n\t},\n\t.probe = aspeed_mdio_probe,\n\t.remove = aspeed_mdio_remove,\n};\n\nmodule_platform_driver(aspeed_mdio_driver);\n\nMODULE_AUTHOR(\"Andrew Jeffery <andrew@aj.id.au>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}