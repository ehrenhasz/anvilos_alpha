{
  "module_name": "mdio-bcm-unimac.c",
  "hash_id": "c1c31d9e7514abd33eae30aef7bb1c004af4567bda5dd3e5f7342af1152748c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-bcm-unimac.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_platform.h>\n#include <linux/phy.h>\n#include <linux/platform_data/mdio-bcm-unimac.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n\n#define MDIO_CMD\t\t0x00\n#define  MDIO_START_BUSY\t(1 << 29)\n#define  MDIO_READ_FAIL\t\t(1 << 28)\n#define  MDIO_RD\t\t(2 << 26)\n#define  MDIO_WR\t\t(1 << 26)\n#define  MDIO_PMD_SHIFT\t\t21\n#define  MDIO_PMD_MASK\t\t0x1F\n#define  MDIO_REG_SHIFT\t\t16\n#define  MDIO_REG_MASK\t\t0x1F\n\n#define MDIO_CFG\t\t0x04\n#define  MDIO_C22\t\t(1 << 0)\n#define  MDIO_C45\t\t0\n#define  MDIO_CLK_DIV_SHIFT\t4\n#define  MDIO_CLK_DIV_MASK\t0x3F\n#define  MDIO_SUPP_PREAMBLE\t(1 << 12)\n\nstruct unimac_mdio_priv {\n\tstruct mii_bus\t\t*mii_bus;\n\tvoid __iomem\t\t*base;\n\tint (*wait_func)\t(void *wait_func_data);\n\tvoid\t\t\t*wait_func_data;\n\tstruct clk\t\t*clk;\n\tu32\t\t\tclk_freq;\n};\n\nstatic inline u32 unimac_mdio_readl(struct unimac_mdio_priv *priv, u32 offset)\n{\n\t \n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\treturn __raw_readl(priv->base + offset);\n\telse\n\t\treturn readl_relaxed(priv->base + offset);\n}\n\nstatic inline void unimac_mdio_writel(struct unimac_mdio_priv *priv, u32 val,\n\t\t\t\t      u32 offset)\n{\n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\t__raw_writel(val, priv->base + offset);\n\telse\n\t\twritel_relaxed(val, priv->base + offset);\n}\n\nstatic inline void unimac_mdio_start(struct unimac_mdio_priv *priv)\n{\n\tu32 reg;\n\n\treg = unimac_mdio_readl(priv, MDIO_CMD);\n\treg |= MDIO_START_BUSY;\n\tunimac_mdio_writel(priv, reg, MDIO_CMD);\n}\n\nstatic inline unsigned int unimac_mdio_busy(struct unimac_mdio_priv *priv)\n{\n\treturn unimac_mdio_readl(priv, MDIO_CMD) & MDIO_START_BUSY;\n}\n\nstatic int unimac_mdio_poll(void *wait_func_data)\n{\n\tstruct unimac_mdio_priv *priv = wait_func_data;\n\tunsigned int timeout = 1000;\n\n\tdo {\n\t\tif (!unimac_mdio_busy(priv))\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t} while (--timeout);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int unimac_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tstruct unimac_mdio_priv *priv = bus->priv;\n\tint ret;\n\tu32 cmd;\n\n\t \n\tcmd = MDIO_RD | (phy_id << MDIO_PMD_SHIFT) | (reg << MDIO_REG_SHIFT);\n\tunimac_mdio_writel(priv, cmd, MDIO_CMD);\n\n\t \n\tunimac_mdio_start(priv);\n\n\tret = priv->wait_func(priv->wait_func_data);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd = unimac_mdio_readl(priv, MDIO_CMD);\n\n\t \n\tif (!(bus->phy_ignore_ta_mask & 1 << phy_id) && (cmd & MDIO_READ_FAIL))\n\t\treturn -EIO;\n\n\treturn cmd & 0xffff;\n}\n\nstatic int unimac_mdio_write(struct mii_bus *bus, int phy_id,\n\t\t\t     int reg, u16 val)\n{\n\tstruct unimac_mdio_priv *priv = bus->priv;\n\tu32 cmd;\n\n\t \n\tcmd = MDIO_WR | (phy_id << MDIO_PMD_SHIFT) |\n\t\t(reg << MDIO_REG_SHIFT) | (0xffff & val);\n\tunimac_mdio_writel(priv, cmd, MDIO_CMD);\n\n\tunimac_mdio_start(priv);\n\n\treturn priv->wait_func(priv->wait_func_data);\n}\n\n \nstatic int unimac_mdio_reset(struct mii_bus *bus)\n{\n\tstruct device_node *np = bus->dev.of_node;\n\tstruct device_node *child;\n\tu32 read_mask = 0;\n\tint addr;\n\n\tif (!np) {\n\t\tread_mask = ~bus->phy_mask;\n\t} else {\n\t\tfor_each_available_child_of_node(np, child) {\n\t\t\taddr = of_mdio_parse_addr(&bus->dev, child);\n\t\t\tif (addr < 0)\n\t\t\t\tcontinue;\n\n\t\t\tread_mask |= 1 << addr;\n\t\t}\n\t}\n\n\tfor (addr = 0; addr < PHY_MAX_ADDR; addr++) {\n\t\tif (read_mask & 1 << addr) {\n\t\t\tdev_dbg(&bus->dev, \"Workaround for PHY @ %d\\n\", addr);\n\t\t\tmdiobus_read(bus, addr, MII_BMSR);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void unimac_mdio_clk_set(struct unimac_mdio_priv *priv)\n{\n\tunsigned long rate;\n\tu32 reg, div;\n\n\t \n\tif (!priv->clk_freq)\n\t\treturn;\n\n\tif (!priv->clk)\n\t\trate = 250000000;\n\telse\n\t\trate = clk_get_rate(priv->clk);\n\n\tdiv = (rate / (2 * priv->clk_freq)) - 1;\n\tif (div & ~MDIO_CLK_DIV_MASK) {\n\t\tpr_warn(\"Incorrect MDIO clock frequency, ignoring\\n\");\n\t\treturn;\n\t}\n\n\t \n\treg = unimac_mdio_readl(priv, MDIO_CFG);\n\treg &= ~(MDIO_CLK_DIV_MASK << MDIO_CLK_DIV_SHIFT);\n\treg |= div << MDIO_CLK_DIV_SHIFT;\n\tunimac_mdio_writel(priv, reg, MDIO_CFG);\n}\n\nstatic int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r)\n\t\treturn -EINVAL;\n\n\t \n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->clk = devm_clk_get_optional(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (of_property_read_u32(np, \"clock-frequency\", &priv->clk_freq))\n\t\tpriv->clk_freq = 0;\n\n\tunimac_mdio_clk_set(priv);\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus) {\n\t\tret = -ENOMEM;\n\t\tgoto out_clk_disable;\n\t}\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus\\n\");\n\n\treturn 0;\n\nout_mdio_free:\n\tmdiobus_free(bus);\nout_clk_disable:\n\tclk_disable_unprepare(priv->clk);\n\treturn ret;\n}\n\nstatic int unimac_mdio_remove(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_priv *priv = platform_get_drvdata(pdev);\n\n\tmdiobus_unregister(priv->mii_bus);\n\tmdiobus_free(priv->mii_bus);\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused unimac_mdio_suspend(struct device *d)\n{\n\tstruct unimac_mdio_priv *priv = dev_get_drvdata(d);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused unimac_mdio_resume(struct device *d)\n{\n\tstruct unimac_mdio_priv *priv = dev_get_drvdata(d);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tunimac_mdio_clk_set(priv);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(unimac_mdio_pm_ops,\n\t\t\t unimac_mdio_suspend, unimac_mdio_resume);\n\nstatic const struct of_device_id unimac_mdio_ids[] = {\n\t{ .compatible = \"brcm,asp-v2.1-mdio\", },\n\t{ .compatible = \"brcm,asp-v2.0-mdio\", },\n\t{ .compatible = \"brcm,genet-mdio-v5\", },\n\t{ .compatible = \"brcm,genet-mdio-v4\", },\n\t{ .compatible = \"brcm,genet-mdio-v3\", },\n\t{ .compatible = \"brcm,genet-mdio-v2\", },\n\t{ .compatible = \"brcm,genet-mdio-v1\", },\n\t{ .compatible = \"brcm,unimac-mdio\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, unimac_mdio_ids);\n\nstatic struct platform_driver unimac_mdio_driver = {\n\t.driver = {\n\t\t.name = UNIMAC_MDIO_DRV_NAME,\n\t\t.of_match_table = unimac_mdio_ids,\n\t\t.pm = &unimac_mdio_pm_ops,\n\t},\n\t.probe\t= unimac_mdio_probe,\n\t.remove\t= unimac_mdio_remove,\n};\nmodule_platform_driver(unimac_mdio_driver);\n\nMODULE_AUTHOR(\"Broadcom Corporation\");\nMODULE_DESCRIPTION(\"Broadcom UniMAC MDIO bus controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" UNIMAC_MDIO_DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}