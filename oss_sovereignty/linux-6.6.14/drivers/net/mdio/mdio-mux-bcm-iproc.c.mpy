{
  "module_name": "mdio-mux-bcm-iproc.c",
  "hash_id": "e2a549381a4b7d220d856cc7ff880219fb65cf5b81dec7216b68e785facb2f41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mdio/mdio-mux-bcm-iproc.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/iopoll.h>\n#include <linux/mdio-mux.h>\n#include <linux/module.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n\n#define MDIO_RATE_ADJ_EXT_OFFSET\t0x000\n#define MDIO_RATE_ADJ_INT_OFFSET\t0x004\n#define MDIO_RATE_ADJ_DIVIDENT_SHIFT\t16\n\n#define MDIO_SCAN_CTRL_OFFSET\t\t0x008\n#define MDIO_SCAN_CTRL_OVRIDE_EXT_MSTR\t28\n\n#define MDIO_PARAM_OFFSET\t\t0x23c\n#define MDIO_PARAM_MIIM_CYCLE\t\t29\n#define MDIO_PARAM_INTERNAL_SEL\t\t25\n#define MDIO_PARAM_BUS_ID\t\t22\n#define MDIO_PARAM_C45_SEL\t\t21\n#define MDIO_PARAM_PHY_ID\t\t16\n#define MDIO_PARAM_PHY_DATA\t\t0\n\n#define MDIO_READ_OFFSET\t\t0x240\n#define MDIO_READ_DATA_MASK\t\t0xffff\n#define MDIO_ADDR_OFFSET\t\t0x244\n\n#define MDIO_CTRL_OFFSET\t\t0x248\n#define MDIO_CTRL_WRITE_OP\t\t0x1\n#define MDIO_CTRL_READ_OP\t\t0x2\n\n#define MDIO_STAT_OFFSET\t\t0x24c\n#define MDIO_STAT_DONE\t\t\t1\n\n#define BUS_MAX_ADDR\t\t\t32\n#define EXT_BUS_START_ADDR\t\t16\n\n#define MDIO_REG_ADDR_SPACE_SIZE\t0x250\n\n#define MDIO_OPERATING_FREQUENCY\t11000000\n#define MDIO_RATE_ADJ_DIVIDENT\t\t1\n\nstruct iproc_mdiomux_desc {\n\tvoid *mux_handle;\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct mii_bus *mii_bus;\n\tstruct clk *core_clk;\n};\n\nstatic void mdio_mux_iproc_config(struct iproc_mdiomux_desc *md)\n{\n\tu32 divisor;\n\tu32 val;\n\n\t \n\tval = readl(md->base + MDIO_SCAN_CTRL_OFFSET);\n\tval |= BIT(MDIO_SCAN_CTRL_OVRIDE_EXT_MSTR);\n\twritel(val, md->base + MDIO_SCAN_CTRL_OFFSET);\n\n\tif (md->core_clk) {\n\t\t \n\t\tdivisor = clk_get_rate(md->core_clk) / MDIO_OPERATING_FREQUENCY;\n\t\tdivisor = divisor / (MDIO_RATE_ADJ_DIVIDENT + 1);\n\t\tval = divisor;\n\t\tval |= MDIO_RATE_ADJ_DIVIDENT << MDIO_RATE_ADJ_DIVIDENT_SHIFT;\n\t\twritel(val, md->base + MDIO_RATE_ADJ_EXT_OFFSET);\n\t\twritel(val, md->base + MDIO_RATE_ADJ_INT_OFFSET);\n\t}\n}\n\nstatic int iproc_mdio_wait_for_idle(void __iomem *base, bool result)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout(base + MDIO_STAT_OFFSET, val,\n\t\t\t\t  (val & MDIO_STAT_DONE) == result,\n\t\t\t\t  2000, 1000000);\n}\n\n \nstatic int start_miim_ops(void __iomem *base, bool c45,\n\t\t\t  u16 phyid, u32 reg, u16 val, u32 op)\n{\n\tu32 param;\n\tint ret;\n\n\twritel(0, base + MDIO_CTRL_OFFSET);\n\tret = iproc_mdio_wait_for_idle(base, 0);\n\tif (ret)\n\t\tgoto err;\n\n\tparam = readl(base + MDIO_PARAM_OFFSET);\n\tparam |= phyid << MDIO_PARAM_PHY_ID;\n\tparam |= val << MDIO_PARAM_PHY_DATA;\n\tif (c45)\n\t\tparam |= BIT(MDIO_PARAM_C45_SEL);\n\n\twritel(param, base + MDIO_PARAM_OFFSET);\n\n\twritel(reg, base + MDIO_ADDR_OFFSET);\n\n\twritel(op, base + MDIO_CTRL_OFFSET);\n\n\tret = iproc_mdio_wait_for_idle(base, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tif (op == MDIO_CTRL_READ_OP)\n\t\tret = readl(base + MDIO_READ_OFFSET) & MDIO_READ_DATA_MASK;\nerr:\n\treturn ret;\n}\n\nstatic int iproc_mdiomux_read_c22(struct mii_bus *bus, int phyid, int reg)\n{\n\tstruct iproc_mdiomux_desc *md = bus->priv;\n\tint ret;\n\n\tret = start_miim_ops(md->base, false, phyid, reg, 0, MDIO_CTRL_READ_OP);\n\tif (ret < 0)\n\t\tdev_err(&bus->dev, \"mdiomux c22 read operation failed!!!\");\n\n\treturn ret;\n}\n\nstatic int iproc_mdiomux_read_c45(struct mii_bus *bus, int phyid, int devad,\n\t\t\t\t  int reg)\n{\n\tstruct iproc_mdiomux_desc *md = bus->priv;\n\tint ret;\n\n\tret = start_miim_ops(md->base, true, phyid, reg | devad << 16, 0,\n\t\t\t     MDIO_CTRL_READ_OP);\n\tif (ret < 0)\n\t\tdev_err(&bus->dev, \"mdiomux read c45 operation failed!!!\");\n\n\treturn ret;\n}\n\nstatic int iproc_mdiomux_write_c22(struct mii_bus *bus,\n\t\t\t\t   int phyid, int reg, u16 val)\n{\n\tstruct iproc_mdiomux_desc *md = bus->priv;\n\tint ret;\n\n\t \n\tret = start_miim_ops(md->base, false, phyid, reg, val,\n\t\t\t     MDIO_CTRL_WRITE_OP);\n\tif (ret < 0)\n\t\tdev_err(&bus->dev, \"mdiomux write c22 operation failed!!!\");\n\n\treturn ret;\n}\n\nstatic int iproc_mdiomux_write_c45(struct mii_bus *bus,\n\t\t\t\t   int phyid, int devad, int reg, u16 val)\n{\n\tstruct iproc_mdiomux_desc *md = bus->priv;\n\tint ret;\n\n\t \n\tret = start_miim_ops(md->base, true, phyid, reg | devad << 16, val,\n\t\t\t     MDIO_CTRL_WRITE_OP);\n\tif (ret < 0)\n\t\tdev_err(&bus->dev, \"mdiomux write c45 operation failed!!!\");\n\n\treturn ret;\n}\n\nstatic int mdio_mux_iproc_switch_fn(int current_child, int desired_child,\n\t\t\t\t    void *data)\n{\n\tstruct iproc_mdiomux_desc *md = data;\n\tu32 param, bus_id;\n\tbool bus_dir;\n\n\t \n\tbus_dir = (desired_child < EXT_BUS_START_ADDR);\n\tbus_id = bus_dir ? desired_child : (desired_child - EXT_BUS_START_ADDR);\n\n\tparam = (bus_dir ? 1 : 0) << MDIO_PARAM_INTERNAL_SEL;\n\tparam |= (bus_id << MDIO_PARAM_BUS_ID);\n\n\twritel(param, md->base + MDIO_PARAM_OFFSET);\n\treturn 0;\n}\n\nstatic int mdio_mux_iproc_probe(struct platform_device *pdev)\n{\n\tstruct iproc_mdiomux_desc *md;\n\tstruct mii_bus *bus;\n\tstruct resource *res;\n\tint rc;\n\n\tmd = devm_kzalloc(&pdev->dev, sizeof(*md), GFP_KERNEL);\n\tif (!md)\n\t\treturn -ENOMEM;\n\tmd->dev = &pdev->dev;\n\n\tmd->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(md->base))\n\t\treturn PTR_ERR(md->base);\n\tif (res->start & 0xfff) {\n\t\t \n\t\tdev_info(&pdev->dev, \"fix base address in dt-blob\\n\");\n\t\tres->start &= ~0xfff;\n\t\tres->end = res->start + MDIO_REG_ADDR_SPACE_SIZE - 1;\n\t}\n\n\tmd->mii_bus = devm_mdiobus_alloc(&pdev->dev);\n\tif (!md->mii_bus) {\n\t\tdev_err(&pdev->dev, \"mdiomux bus alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmd->core_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (md->core_clk == ERR_PTR(-ENOENT) ||\n\t    md->core_clk == ERR_PTR(-EINVAL))\n\t\tmd->core_clk = NULL;\n\telse if (IS_ERR(md->core_clk))\n\t\treturn PTR_ERR(md->core_clk);\n\n\trc = clk_prepare_enable(md->core_clk);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"failed to enable core clk\\n\");\n\t\treturn rc;\n\t}\n\n\tbus = md->mii_bus;\n\tbus->priv = md;\n\tbus->name = \"iProc MDIO mux bus\";\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\tbus->parent = &pdev->dev;\n\tbus->read = iproc_mdiomux_read_c22;\n\tbus->write = iproc_mdiomux_write_c22;\n\tbus->read_c45 = iproc_mdiomux_read_c45;\n\tbus->write_c45 = iproc_mdiomux_write_c45;\n\n\tbus->phy_mask = ~0;\n\tbus->dev.of_node = pdev->dev.of_node;\n\trc = mdiobus_register(bus);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"mdiomux registration failed\\n\");\n\t\tgoto out_clk;\n\t}\n\n\tplatform_set_drvdata(pdev, md);\n\n\trc = mdio_mux_init(md->dev, md->dev->of_node, mdio_mux_iproc_switch_fn,\n\t\t\t   &md->mux_handle, md, md->mii_bus);\n\tif (rc) {\n\t\tdev_info(md->dev, \"mdiomux initialization failed\\n\");\n\t\tgoto out_register;\n\t}\n\n\tmdio_mux_iproc_config(md);\n\n\tdev_info(md->dev, \"iProc mdiomux registered\\n\");\n\treturn 0;\n\nout_register:\n\tmdiobus_unregister(bus);\nout_clk:\n\tclk_disable_unprepare(md->core_clk);\n\treturn rc;\n}\n\nstatic int mdio_mux_iproc_remove(struct platform_device *pdev)\n{\n\tstruct iproc_mdiomux_desc *md = platform_get_drvdata(pdev);\n\n\tmdio_mux_uninit(md->mux_handle);\n\tmdiobus_unregister(md->mii_bus);\n\tclk_disable_unprepare(md->core_clk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mdio_mux_iproc_suspend(struct device *dev)\n{\n\tstruct iproc_mdiomux_desc *md = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(md->core_clk);\n\n\treturn 0;\n}\n\nstatic int mdio_mux_iproc_resume(struct device *dev)\n{\n\tstruct iproc_mdiomux_desc *md = dev_get_drvdata(dev);\n\tint rc;\n\n\trc = clk_prepare_enable(md->core_clk);\n\tif (rc) {\n\t\tdev_err(md->dev, \"failed to enable core clk\\n\");\n\t\treturn rc;\n\t}\n\tmdio_mux_iproc_config(md);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(mdio_mux_iproc_pm_ops,\n\t\t\t mdio_mux_iproc_suspend, mdio_mux_iproc_resume);\n\nstatic const struct of_device_id mdio_mux_iproc_match[] = {\n\t{\n\t\t.compatible = \"brcm,mdio-mux-iproc\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mdio_mux_iproc_match);\n\nstatic struct platform_driver mdiomux_iproc_driver = {\n\t.driver = {\n\t\t.name\t\t= \"mdio-mux-iproc\",\n\t\t.of_match_table = mdio_mux_iproc_match,\n\t\t.pm\t\t= &mdio_mux_iproc_pm_ops,\n\t},\n\t.probe\t\t= mdio_mux_iproc_probe,\n\t.remove\t\t= mdio_mux_iproc_remove,\n};\n\nmodule_platform_driver(mdiomux_iproc_driver);\n\nMODULE_DESCRIPTION(\"iProc MDIO Mux Bus Driver\");\nMODULE_AUTHOR(\"Pramod Kumar <pramod.kumar@broadcom.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}