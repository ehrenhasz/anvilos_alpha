{
  "module_name": "icc-rpmh.c",
  "hash_id": "3a775da933411b5bf0f30355803c572321727e3648da941568896ebfb7fa0f26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/interconnect/qcom/icc-rpmh.c",
  "human_readable_source": "\n \n\n#include <linux/interconnect.h>\n#include <linux/interconnect-provider.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/slab.h>\n\n#include \"bcm-voter.h\"\n#include \"icc-common.h\"\n#include \"icc-rpmh.h\"\n\n \nvoid qcom_icc_pre_aggregate(struct icc_node *node)\n{\n\tsize_t i;\n\tstruct qcom_icc_node *qn;\n\tstruct qcom_icc_provider *qp;\n\n\tqn = node->data;\n\tqp = to_qcom_provider(node->provider);\n\n\tfor (i = 0; i < QCOM_ICC_NUM_BUCKETS; i++) {\n\t\tqn->sum_avg[i] = 0;\n\t\tqn->max_peak[i] = 0;\n\t}\n\n\tfor (i = 0; i < qn->num_bcms; i++)\n\t\tqcom_icc_bcm_voter_add(qp->voter, qn->bcms[i]);\n}\nEXPORT_SYMBOL_GPL(qcom_icc_pre_aggregate);\n\n \nint qcom_icc_aggregate(struct icc_node *node, u32 tag, u32 avg_bw,\n\t\t       u32 peak_bw, u32 *agg_avg, u32 *agg_peak)\n{\n\tsize_t i;\n\tstruct qcom_icc_node *qn;\n\n\tqn = node->data;\n\n\tif (!tag)\n\t\ttag = QCOM_ICC_TAG_ALWAYS;\n\n\tfor (i = 0; i < QCOM_ICC_NUM_BUCKETS; i++) {\n\t\tif (tag & BIT(i)) {\n\t\t\tqn->sum_avg[i] += avg_bw;\n\t\t\tqn->max_peak[i] = max_t(u32, qn->max_peak[i], peak_bw);\n\t\t}\n\n\t\tif (node->init_avg || node->init_peak) {\n\t\t\tqn->sum_avg[i] = max_t(u64, qn->sum_avg[i], node->init_avg);\n\t\t\tqn->max_peak[i] = max_t(u64, qn->max_peak[i], node->init_peak);\n\t\t}\n\t}\n\n\t*agg_avg += avg_bw;\n\t*agg_peak = max_t(u32, *agg_peak, peak_bw);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qcom_icc_aggregate);\n\n \nint qcom_icc_set(struct icc_node *src, struct icc_node *dst)\n{\n\tstruct qcom_icc_provider *qp;\n\tstruct icc_node *node;\n\n\tif (!src)\n\t\tnode = dst;\n\telse\n\t\tnode = src;\n\n\tqp = to_qcom_provider(node->provider);\n\n\tqcom_icc_bcm_voter_commit(qp->voter);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qcom_icc_set);\n\n \nint qcom_icc_bcm_init(struct qcom_icc_bcm *bcm, struct device *dev)\n{\n\tstruct qcom_icc_node *qn;\n\tconst struct bcm_db *data;\n\tsize_t data_count;\n\tint i;\n\n\t \n\tif (bcm->addr)\n\t\treturn 0;\n\n\tbcm->addr = cmd_db_read_addr(bcm->name);\n\tif (!bcm->addr) {\n\t\tdev_err(dev, \"%s could not find RPMh address\\n\",\n\t\t\tbcm->name);\n\t\treturn -EINVAL;\n\t}\n\n\tdata = cmd_db_read_aux_data(bcm->name, &data_count);\n\tif (IS_ERR(data)) {\n\t\tdev_err(dev, \"%s command db read error (%ld)\\n\",\n\t\t\tbcm->name, PTR_ERR(data));\n\t\treturn PTR_ERR(data);\n\t}\n\tif (!data_count) {\n\t\tdev_err(dev, \"%s command db missing or partial aux data\\n\",\n\t\t\tbcm->name);\n\t\treturn -EINVAL;\n\t}\n\n\tbcm->aux_data.unit = le32_to_cpu(data->unit);\n\tbcm->aux_data.width = le16_to_cpu(data->width);\n\tbcm->aux_data.vcd = data->vcd;\n\tbcm->aux_data.reserved = data->reserved;\n\tINIT_LIST_HEAD(&bcm->list);\n\tINIT_LIST_HEAD(&bcm->ws_list);\n\n\tif (!bcm->vote_scale)\n\t\tbcm->vote_scale = 1000;\n\n\t \n\tfor (i = 0; i < bcm->num_nodes; i++) {\n\t\tqn = bcm->nodes[i];\n\t\tqn->bcms[qn->num_bcms] = bcm;\n\t\tqn->num_bcms++;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qcom_icc_bcm_init);\n\nint qcom_icc_rpmh_probe(struct platform_device *pdev)\n{\n\tconst struct qcom_icc_desc *desc;\n\tstruct device *dev = &pdev->dev;\n\tstruct icc_onecell_data *data;\n\tstruct icc_provider *provider;\n\tstruct qcom_icc_node * const *qnodes, *qn;\n\tstruct qcom_icc_provider *qp;\n\tstruct icc_node *node;\n\tsize_t num_nodes, i, j;\n\tint ret;\n\n\tdesc = of_device_get_match_data(dev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tqnodes = desc->nodes;\n\tnum_nodes = desc->num_nodes;\n\n\tqp = devm_kzalloc(dev, sizeof(*qp), GFP_KERNEL);\n\tif (!qp)\n\t\treturn -ENOMEM;\n\n\tdata = devm_kzalloc(dev, struct_size(data, nodes, num_nodes), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->num_nodes = num_nodes;\n\n\tprovider = &qp->provider;\n\tprovider->dev = dev;\n\tprovider->set = qcom_icc_set;\n\tprovider->pre_aggregate = qcom_icc_pre_aggregate;\n\tprovider->aggregate = qcom_icc_aggregate;\n\tprovider->xlate_extended = qcom_icc_xlate_extended;\n\tprovider->data = data;\n\n\ticc_provider_init(provider);\n\n\tqp->dev = dev;\n\tqp->bcms = desc->bcms;\n\tqp->num_bcms = desc->num_bcms;\n\n\tqp->voter = of_bcm_voter_get(qp->dev, NULL);\n\tif (IS_ERR(qp->voter))\n\t\treturn PTR_ERR(qp->voter);\n\n\tfor (i = 0; i < qp->num_bcms; i++)\n\t\tqcom_icc_bcm_init(qp->bcms[i], dev);\n\n\tfor (i = 0; i < num_nodes; i++) {\n\t\tqn = qnodes[i];\n\t\tif (!qn)\n\t\t\tcontinue;\n\n\t\tnode = icc_node_create(qn->id);\n\t\tif (IS_ERR(node)) {\n\t\t\tret = PTR_ERR(node);\n\t\t\tgoto err_remove_nodes;\n\t\t}\n\n\t\tnode->name = qn->name;\n\t\tnode->data = qn;\n\t\ticc_node_add(node, provider);\n\n\t\tfor (j = 0; j < qn->num_links; j++)\n\t\t\ticc_link_create(node, qn->links[j]);\n\n\t\tdata->nodes[i] = node;\n\t}\n\n\tret = icc_provider_register(provider);\n\tif (ret)\n\t\tgoto err_remove_nodes;\n\n\tplatform_set_drvdata(pdev, qp);\n\n\t \n\tif (of_get_child_count(dev->of_node) > 0) {\n\t\tret = of_platform_populate(dev->of_node, NULL, NULL, dev);\n\t\tif (ret)\n\t\t\tgoto err_deregister_provider;\n\t}\n\n\treturn 0;\n\nerr_deregister_provider:\n\ticc_provider_deregister(provider);\nerr_remove_nodes:\n\ticc_nodes_remove(provider);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(qcom_icc_rpmh_probe);\n\nint qcom_icc_rpmh_remove(struct platform_device *pdev)\n{\n\tstruct qcom_icc_provider *qp = platform_get_drvdata(pdev);\n\n\ticc_provider_deregister(&qp->provider);\n\ticc_nodes_remove(&qp->provider);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qcom_icc_rpmh_remove);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}