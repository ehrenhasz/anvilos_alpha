{
  "module_name": "bcm-voter.c",
  "hash_id": "8d48e3492ebfd2254df2ddcbd251fb548142a919388d824b30348774394e9b74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/interconnect/qcom/bcm-voter.c",
  "human_readable_source": "\n \n\n#include <asm/div64.h>\n#include <linux/interconnect-provider.h>\n#include <linux/list_sort.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <soc/qcom/rpmh.h>\n#include <soc/qcom/tcs.h>\n\n#include \"bcm-voter.h\"\n#include \"icc-rpmh.h\"\n\nstatic LIST_HEAD(bcm_voters);\nstatic DEFINE_MUTEX(bcm_voter_lock);\n\n \nstruct bcm_voter {\n\tstruct device *dev;\n\tstruct device_node *np;\n\tstruct mutex lock;\n\tstruct list_head commit_list;\n\tstruct list_head ws_list;\n\tstruct list_head voter_node;\n\tu32 tcs_wait;\n};\n\nstatic int cmp_vcd(void *priv, const struct list_head *a, const struct list_head *b)\n{\n\tconst struct qcom_icc_bcm *bcm_a = list_entry(a, struct qcom_icc_bcm, list);\n\tconst struct qcom_icc_bcm *bcm_b = list_entry(b, struct qcom_icc_bcm, list);\n\n\treturn bcm_a->aux_data.vcd - bcm_b->aux_data.vcd;\n}\n\nstatic u64 bcm_div(u64 num, u32 base)\n{\n\t \n\tif (num && num < base)\n\t\treturn 1;\n\n\tdo_div(num, base);\n\n\treturn num;\n}\n\n \nstatic void bcm_aggregate_mask(struct qcom_icc_bcm *bcm)\n{\n\tstruct qcom_icc_node *node;\n\tint bucket, i;\n\n\tfor (bucket = 0; bucket < QCOM_ICC_NUM_BUCKETS; bucket++) {\n\t\tbcm->vote_x[bucket] = 0;\n\t\tbcm->vote_y[bucket] = 0;\n\n\t\tfor (i = 0; i < bcm->num_nodes; i++) {\n\t\t\tnode = bcm->nodes[i];\n\n\t\t\t \n\t\t\tif (node->sum_avg[bucket] || node->max_peak[bucket]) {\n\t\t\t\tbcm->vote_x[bucket] = 0;\n\t\t\t\tbcm->vote_y[bucket] = bcm->enable_mask;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bcm->keepalive) {\n\t\tbcm->vote_x[QCOM_ICC_BUCKET_AMC] = bcm->enable_mask;\n\t\tbcm->vote_x[QCOM_ICC_BUCKET_WAKE] = bcm->enable_mask;\n\t\tbcm->vote_y[QCOM_ICC_BUCKET_AMC] = bcm->enable_mask;\n\t\tbcm->vote_y[QCOM_ICC_BUCKET_WAKE] = bcm->enable_mask;\n\t}\n}\n\nstatic void bcm_aggregate(struct qcom_icc_bcm *bcm)\n{\n\tstruct qcom_icc_node *node;\n\tsize_t i, bucket;\n\tu64 agg_avg[QCOM_ICC_NUM_BUCKETS] = {0};\n\tu64 agg_peak[QCOM_ICC_NUM_BUCKETS] = {0};\n\tu64 temp;\n\n\tfor (bucket = 0; bucket < QCOM_ICC_NUM_BUCKETS; bucket++) {\n\t\tfor (i = 0; i < bcm->num_nodes; i++) {\n\t\t\tnode = bcm->nodes[i];\n\t\t\ttemp = bcm_div(node->sum_avg[bucket] * bcm->aux_data.width,\n\t\t\t\t       node->buswidth * node->channels);\n\t\t\tagg_avg[bucket] = max(agg_avg[bucket], temp);\n\n\t\t\ttemp = bcm_div(node->max_peak[bucket] * bcm->aux_data.width,\n\t\t\t\t       node->buswidth);\n\t\t\tagg_peak[bucket] = max(agg_peak[bucket], temp);\n\t\t}\n\n\t\ttemp = agg_avg[bucket] * bcm->vote_scale;\n\t\tbcm->vote_x[bucket] = bcm_div(temp, bcm->aux_data.unit);\n\n\t\ttemp = agg_peak[bucket] * bcm->vote_scale;\n\t\tbcm->vote_y[bucket] = bcm_div(temp, bcm->aux_data.unit);\n\t}\n\n\tif (bcm->keepalive && bcm->vote_x[QCOM_ICC_BUCKET_AMC] == 0 &&\n\t    bcm->vote_y[QCOM_ICC_BUCKET_AMC] == 0) {\n\t\tbcm->vote_x[QCOM_ICC_BUCKET_AMC] = 1;\n\t\tbcm->vote_x[QCOM_ICC_BUCKET_WAKE] = 1;\n\t\tbcm->vote_y[QCOM_ICC_BUCKET_AMC] = 1;\n\t\tbcm->vote_y[QCOM_ICC_BUCKET_WAKE] = 1;\n\t}\n}\n\nstatic inline void tcs_cmd_gen(struct tcs_cmd *cmd, u64 vote_x, u64 vote_y,\n\t\t\t       u32 addr, bool commit, bool wait)\n{\n\tbool valid = true;\n\n\tif (!cmd)\n\t\treturn;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\n\tif (vote_x == 0 && vote_y == 0)\n\t\tvalid = false;\n\n\tif (vote_x > BCM_TCS_CMD_VOTE_MASK)\n\t\tvote_x = BCM_TCS_CMD_VOTE_MASK;\n\n\tif (vote_y > BCM_TCS_CMD_VOTE_MASK)\n\t\tvote_y = BCM_TCS_CMD_VOTE_MASK;\n\n\tcmd->addr = addr;\n\tcmd->data = BCM_TCS_CMD(commit, valid, vote_x, vote_y);\n\n\t \n\tcmd->wait = wait;\n}\n\nstatic void tcs_list_gen(struct bcm_voter *voter, int bucket,\n\t\t\t struct tcs_cmd tcs_list[MAX_VCD],\n\t\t\t int n[MAX_VCD + 1])\n{\n\tstruct list_head *bcm_list = &voter->commit_list;\n\tstruct qcom_icc_bcm *bcm;\n\tbool commit, wait;\n\tsize_t idx = 0, batch = 0, cur_vcd_size = 0;\n\n\tmemset(n, 0, sizeof(int) * (MAX_VCD + 1));\n\n\tlist_for_each_entry(bcm, bcm_list, list) {\n\t\tcommit = false;\n\t\tcur_vcd_size++;\n\t\tif ((list_is_last(&bcm->list, bcm_list)) ||\n\t\t    bcm->aux_data.vcd != list_next_entry(bcm, list)->aux_data.vcd) {\n\t\t\tcommit = true;\n\t\t\tcur_vcd_size = 0;\n\t\t}\n\n\t\twait = commit && (voter->tcs_wait & BIT(bucket));\n\n\t\ttcs_cmd_gen(&tcs_list[idx], bcm->vote_x[bucket],\n\t\t\t    bcm->vote_y[bucket], bcm->addr, commit, wait);\n\t\tidx++;\n\t\tn[batch]++;\n\t\t \n\t\tif (n[batch] >= MAX_RPMH_PAYLOAD) {\n\t\t\tif (!commit) {\n\t\t\t\tn[batch] -= cur_vcd_size;\n\t\t\t\tn[batch + 1] = cur_vcd_size;\n\t\t\t}\n\t\t\tbatch++;\n\t\t}\n\t}\n}\n\n \nstruct bcm_voter *of_bcm_voter_get(struct device *dev, const char *name)\n{\n\tstruct bcm_voter *voter = ERR_PTR(-EPROBE_DEFER);\n\tstruct bcm_voter *temp;\n\tstruct device_node *np, *node;\n\tint idx = 0;\n\n\tif (!dev || !dev->of_node)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tnp = dev->of_node;\n\n\tif (name) {\n\t\tidx = of_property_match_string(np, \"qcom,bcm-voter-names\", name);\n\t\tif (idx < 0)\n\t\t\treturn ERR_PTR(idx);\n\t}\n\n\tnode = of_parse_phandle(np, \"qcom,bcm-voters\", idx);\n\n\tmutex_lock(&bcm_voter_lock);\n\tlist_for_each_entry(temp, &bcm_voters, voter_node) {\n\t\tif (temp->np == node) {\n\t\t\tvoter = temp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&bcm_voter_lock);\n\n\tof_node_put(node);\n\treturn voter;\n}\nEXPORT_SYMBOL_GPL(of_bcm_voter_get);\n\n \nvoid qcom_icc_bcm_voter_add(struct bcm_voter *voter, struct qcom_icc_bcm *bcm)\n{\n\tif (!voter)\n\t\treturn;\n\n\tmutex_lock(&voter->lock);\n\tif (list_empty(&bcm->list))\n\t\tlist_add_tail(&bcm->list, &voter->commit_list);\n\n\tif (list_empty(&bcm->ws_list))\n\t\tlist_add_tail(&bcm->ws_list, &voter->ws_list);\n\n\tmutex_unlock(&voter->lock);\n}\nEXPORT_SYMBOL_GPL(qcom_icc_bcm_voter_add);\n\n \nint qcom_icc_bcm_voter_commit(struct bcm_voter *voter)\n{\n\tstruct qcom_icc_bcm *bcm;\n\tstruct qcom_icc_bcm *bcm_tmp;\n\tint commit_idx[MAX_VCD + 1];\n\tstruct tcs_cmd cmds[MAX_BCMS];\n\tint ret = 0;\n\n\tif (!voter)\n\t\treturn 0;\n\n\tmutex_lock(&voter->lock);\n\tlist_for_each_entry(bcm, &voter->commit_list, list) {\n\t\tif (bcm->enable_mask)\n\t\t\tbcm_aggregate_mask(bcm);\n\t\telse\n\t\t\tbcm_aggregate(bcm);\n\t}\n\n\t \n\tlist_sort(NULL, &voter->commit_list, cmp_vcd);\n\n\t \n\ttcs_list_gen(voter, QCOM_ICC_BUCKET_AMC, cmds, commit_idx);\n\tif (!commit_idx[0])\n\t\tgoto out;\n\n\trpmh_invalidate(voter->dev);\n\n\tret = rpmh_write_batch(voter->dev, RPMH_ACTIVE_ONLY_STATE,\n\t\t\t       cmds, commit_idx);\n\tif (ret) {\n\t\tpr_err(\"Error sending AMC RPMH requests (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(bcm, bcm_tmp, &voter->commit_list, list)\n\t\tlist_del_init(&bcm->list);\n\n\tlist_for_each_entry_safe(bcm, bcm_tmp, &voter->ws_list, ws_list) {\n\t\t \n\t\tif (bcm->vote_x[QCOM_ICC_BUCKET_WAKE] !=\n\t\t    bcm->vote_x[QCOM_ICC_BUCKET_SLEEP] ||\n\t\t    bcm->vote_y[QCOM_ICC_BUCKET_WAKE] !=\n\t\t    bcm->vote_y[QCOM_ICC_BUCKET_SLEEP])\n\t\t\tlist_add_tail(&bcm->list, &voter->commit_list);\n\t\telse\n\t\t\tlist_del_init(&bcm->ws_list);\n\t}\n\n\tif (list_empty(&voter->commit_list))\n\t\tgoto out;\n\n\tlist_sort(NULL, &voter->commit_list, cmp_vcd);\n\n\ttcs_list_gen(voter, QCOM_ICC_BUCKET_WAKE, cmds, commit_idx);\n\n\tret = rpmh_write_batch(voter->dev, RPMH_WAKE_ONLY_STATE, cmds, commit_idx);\n\tif (ret) {\n\t\tpr_err(\"Error sending WAKE RPMH requests (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\ttcs_list_gen(voter, QCOM_ICC_BUCKET_SLEEP, cmds, commit_idx);\n\n\tret = rpmh_write_batch(voter->dev, RPMH_SLEEP_STATE, cmds, commit_idx);\n\tif (ret) {\n\t\tpr_err(\"Error sending SLEEP RPMH requests (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tlist_for_each_entry_safe(bcm, bcm_tmp, &voter->commit_list, list)\n\t\tlist_del_init(&bcm->list);\n\n\tmutex_unlock(&voter->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(qcom_icc_bcm_voter_commit);\n\nstatic int qcom_icc_bcm_voter_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct bcm_voter *voter;\n\n\tvoter = devm_kzalloc(&pdev->dev, sizeof(*voter), GFP_KERNEL);\n\tif (!voter)\n\t\treturn -ENOMEM;\n\n\tvoter->dev = &pdev->dev;\n\tvoter->np = np;\n\n\tif (of_property_read_u32(np, \"qcom,tcs-wait\", &voter->tcs_wait))\n\t\tvoter->tcs_wait = QCOM_ICC_TAG_ACTIVE_ONLY;\n\n\tmutex_init(&voter->lock);\n\tINIT_LIST_HEAD(&voter->commit_list);\n\tINIT_LIST_HEAD(&voter->ws_list);\n\n\tmutex_lock(&bcm_voter_lock);\n\tlist_add_tail(&voter->voter_node, &bcm_voters);\n\tmutex_unlock(&bcm_voter_lock);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm_voter_of_match[] = {\n\t{ .compatible = \"qcom,bcm-voter\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, bcm_voter_of_match);\n\nstatic struct platform_driver qcom_icc_bcm_voter_driver = {\n\t.probe = qcom_icc_bcm_voter_probe,\n\t.driver = {\n\t\t.name\t\t= \"bcm_voter\",\n\t\t.of_match_table = bcm_voter_of_match,\n\t},\n};\nmodule_platform_driver(qcom_icc_bcm_voter_driver);\n\nMODULE_AUTHOR(\"David Dai <daidavid1@codeaurora.org>\");\nMODULE_DESCRIPTION(\"Qualcomm BCM Voter interconnect driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}