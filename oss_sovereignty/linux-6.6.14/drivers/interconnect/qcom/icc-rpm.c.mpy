{
  "module_name": "icc-rpm.c",
  "hash_id": "aead8f766351fe5290b92966418f9ffa484754fe0ab927348907d15098c73239",
  "original_prompt": "Ingested from linux-6.6.14/drivers/interconnect/qcom/icc-rpm.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/interconnect-provider.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"icc-common.h\"\n#include \"icc-rpm.h\"\n\n \n#define QNOC_QOS_MCTL_LOWn_ADDR(n)\t(0x8 + (n * 0x1000))\n#define QNOC_QOS_MCTL_DFLT_PRIO_MASK\t0x70\n#define QNOC_QOS_MCTL_DFLT_PRIO_SHIFT\t4\n#define QNOC_QOS_MCTL_URGFWD_EN_MASK\t0x8\n#define QNOC_QOS_MCTL_URGFWD_EN_SHIFT\t3\n\n \n#define M_BKE_REG_BASE(n)\t\t(0x300 + (0x4000 * n))\n#define M_BKE_EN_ADDR(n)\t\t(M_BKE_REG_BASE(n))\n#define M_BKE_HEALTH_CFG_ADDR(i, n)\t(M_BKE_REG_BASE(n) + 0x40 + (0x4 * i))\n\n#define M_BKE_HEALTH_CFG_LIMITCMDS_MASK\t0x80000000\n#define M_BKE_HEALTH_CFG_AREQPRIO_MASK\t0x300\n#define M_BKE_HEALTH_CFG_PRIOLVL_MASK\t0x3\n#define M_BKE_HEALTH_CFG_AREQPRIO_SHIFT\t0x8\n#define M_BKE_HEALTH_CFG_LIMITCMDS_SHIFT 0x1f\n\n#define M_BKE_EN_EN_BMASK\t\t0x1\n\n \n#define NOC_QOS_PRIORITYn_ADDR(n)\t(0x8 + (n * 0x1000))\n#define NOC_QOS_PRIORITY_P1_MASK\t0xc\n#define NOC_QOS_PRIORITY_P0_MASK\t0x3\n#define NOC_QOS_PRIORITY_P1_SHIFT\t0x2\n\n#define NOC_QOS_MODEn_ADDR(n)\t\t(0xc + (n * 0x1000))\n#define NOC_QOS_MODEn_MASK\t\t0x3\n\n#define NOC_QOS_MODE_FIXED_VAL\t\t0x0\n#define NOC_QOS_MODE_BYPASS_VAL\t\t0x2\n\n#define ICC_BUS_CLK_MIN_RATE\t\t19200ULL  \n\nstatic int qcom_icc_set_qnoc_qos(struct icc_node *src)\n{\n\tstruct icc_provider *provider = src->provider;\n\tstruct qcom_icc_provider *qp = to_qcom_provider(provider);\n\tstruct qcom_icc_node *qn = src->data;\n\tstruct qcom_icc_qos *qos = &qn->qos;\n\tint rc;\n\n\trc = regmap_update_bits(qp->regmap,\n\t\t\tqp->qos_offset + QNOC_QOS_MCTL_LOWn_ADDR(qos->qos_port),\n\t\t\tQNOC_QOS_MCTL_DFLT_PRIO_MASK,\n\t\t\tqos->areq_prio << QNOC_QOS_MCTL_DFLT_PRIO_SHIFT);\n\tif (rc)\n\t\treturn rc;\n\n\treturn regmap_update_bits(qp->regmap,\n\t\t\tqp->qos_offset + QNOC_QOS_MCTL_LOWn_ADDR(qos->qos_port),\n\t\t\tQNOC_QOS_MCTL_URGFWD_EN_MASK,\n\t\t\t!!qos->urg_fwd_en << QNOC_QOS_MCTL_URGFWD_EN_SHIFT);\n}\n\nstatic int qcom_icc_bimc_set_qos_health(struct qcom_icc_provider *qp,\n\t\t\t\t\tstruct qcom_icc_qos *qos,\n\t\t\t\t\tint regnum)\n{\n\tu32 val;\n\tu32 mask;\n\n\tval = qos->prio_level;\n\tmask = M_BKE_HEALTH_CFG_PRIOLVL_MASK;\n\n\tval |= qos->areq_prio << M_BKE_HEALTH_CFG_AREQPRIO_SHIFT;\n\tmask |= M_BKE_HEALTH_CFG_AREQPRIO_MASK;\n\n\t \n\tif (regnum != 3) {\n\t\tval |= qos->limit_commands << M_BKE_HEALTH_CFG_LIMITCMDS_SHIFT;\n\t\tmask |= M_BKE_HEALTH_CFG_LIMITCMDS_MASK;\n\t}\n\n\treturn regmap_update_bits(qp->regmap,\n\t\t\t\t  qp->qos_offset + M_BKE_HEALTH_CFG_ADDR(regnum, qos->qos_port),\n\t\t\t\t  mask, val);\n}\n\nstatic int qcom_icc_set_bimc_qos(struct icc_node *src)\n{\n\tstruct qcom_icc_provider *qp;\n\tstruct qcom_icc_node *qn;\n\tstruct icc_provider *provider;\n\tu32 mode = NOC_QOS_MODE_BYPASS;\n\tu32 val = 0;\n\tint i, rc = 0;\n\n\tqn = src->data;\n\tprovider = src->provider;\n\tqp = to_qcom_provider(provider);\n\n\tif (qn->qos.qos_mode != NOC_QOS_MODE_INVALID)\n\t\tmode = qn->qos.qos_mode;\n\n\t \n\tif (mode != NOC_QOS_MODE_BYPASS) {\n\t\tfor (i = 3; i >= 0; i--) {\n\t\t\trc = qcom_icc_bimc_set_qos_health(qp,\n\t\t\t\t\t\t\t  &qn->qos, i);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\t \n\t\tval = 1;\n\t}\n\n\treturn regmap_update_bits(qp->regmap,\n\t\t\t\t  qp->qos_offset + M_BKE_EN_ADDR(qn->qos.qos_port),\n\t\t\t\t  M_BKE_EN_EN_BMASK, val);\n}\n\nstatic int qcom_icc_noc_set_qos_priority(struct qcom_icc_provider *qp,\n\t\t\t\t\t struct qcom_icc_qos *qos)\n{\n\tu32 val;\n\tint rc;\n\n\t \n\tval = qos->areq_prio << NOC_QOS_PRIORITY_P1_SHIFT;\n\trc = regmap_update_bits(qp->regmap,\n\t\t\t\tqp->qos_offset + NOC_QOS_PRIORITYn_ADDR(qos->qos_port),\n\t\t\t\tNOC_QOS_PRIORITY_P1_MASK, val);\n\tif (rc)\n\t\treturn rc;\n\n\treturn regmap_update_bits(qp->regmap,\n\t\t\t\t  qp->qos_offset + NOC_QOS_PRIORITYn_ADDR(qos->qos_port),\n\t\t\t\t  NOC_QOS_PRIORITY_P0_MASK, qos->prio_level);\n}\n\nstatic int qcom_icc_set_noc_qos(struct icc_node *src)\n{\n\tstruct qcom_icc_provider *qp;\n\tstruct qcom_icc_node *qn;\n\tstruct icc_provider *provider;\n\tu32 mode = NOC_QOS_MODE_BYPASS_VAL;\n\tint rc = 0;\n\n\tqn = src->data;\n\tprovider = src->provider;\n\tqp = to_qcom_provider(provider);\n\n\tif (qn->qos.qos_port < 0) {\n\t\tdev_dbg(src->provider->dev,\n\t\t\t\"NoC QoS: Skipping %s: vote aggregated on parent.\\n\",\n\t\t\tqn->name);\n\t\treturn 0;\n\t}\n\n\tif (qn->qos.qos_mode == NOC_QOS_MODE_FIXED) {\n\t\tdev_dbg(src->provider->dev, \"NoC QoS: %s: Set Fixed mode\\n\", qn->name);\n\t\tmode = NOC_QOS_MODE_FIXED_VAL;\n\t\trc = qcom_icc_noc_set_qos_priority(qp, &qn->qos);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else if (qn->qos.qos_mode == NOC_QOS_MODE_BYPASS) {\n\t\tdev_dbg(src->provider->dev, \"NoC QoS: %s: Set Bypass mode\\n\", qn->name);\n\t\tmode = NOC_QOS_MODE_BYPASS_VAL;\n\t} else {\n\t\t \n\t}\n\n\treturn regmap_update_bits(qp->regmap,\n\t\t\t\t  qp->qos_offset + NOC_QOS_MODEn_ADDR(qn->qos.qos_port),\n\t\t\t\t  NOC_QOS_MODEn_MASK, mode);\n}\n\nstatic int qcom_icc_qos_set(struct icc_node *node)\n{\n\tstruct qcom_icc_provider *qp = to_qcom_provider(node->provider);\n\tstruct qcom_icc_node *qn = node->data;\n\n\tdev_dbg(node->provider->dev, \"Setting QoS for %s\\n\", qn->name);\n\n\tswitch (qp->type) {\n\tcase QCOM_ICC_BIMC:\n\t\treturn qcom_icc_set_bimc_qos(node);\n\tcase QCOM_ICC_QNOC:\n\t\treturn qcom_icc_set_qnoc_qos(node);\n\tdefault:\n\t\treturn qcom_icc_set_noc_qos(node);\n\t}\n}\n\nstatic int qcom_icc_rpm_set(struct qcom_icc_node *qn, u64 *bw)\n{\n\tint ret, rpm_ctx = 0;\n\tu64 bw_bps;\n\n\tif (qn->qos.ap_owned)\n\t\treturn 0;\n\n\tfor (rpm_ctx = 0; rpm_ctx < QCOM_SMD_RPM_STATE_NUM; rpm_ctx++) {\n\t\tbw_bps = icc_units_to_bps(bw[rpm_ctx]);\n\n\t\tif (qn->mas_rpm_id != -1) {\n\t\t\tret = qcom_icc_rpm_smd_send(rpm_ctx,\n\t\t\t\t\t\t    RPM_BUS_MASTER_REQ,\n\t\t\t\t\t\t    qn->mas_rpm_id,\n\t\t\t\t\t\t    bw_bps);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"qcom_icc_rpm_smd_send mas %d error %d\\n\",\n\t\t\t\tqn->mas_rpm_id, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (qn->slv_rpm_id != -1) {\n\t\t\tret = qcom_icc_rpm_smd_send(rpm_ctx,\n\t\t\t\t\t\t    RPM_BUS_SLAVE_REQ,\n\t\t\t\t\t\t    qn->slv_rpm_id,\n\t\t\t\t\t\t    bw_bps);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"qcom_icc_rpm_smd_send slv %d error %d\\n\",\n\t\t\t\tqn->slv_rpm_id, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void qcom_icc_pre_bw_aggregate(struct icc_node *node)\n{\n\tstruct qcom_icc_node *qn;\n\tsize_t i;\n\n\tqn = node->data;\n\tfor (i = 0; i < QCOM_SMD_RPM_STATE_NUM; i++) {\n\t\tqn->sum_avg[i] = 0;\n\t\tqn->max_peak[i] = 0;\n\t}\n}\n\n \nstatic int qcom_icc_bw_aggregate(struct icc_node *node, u32 tag, u32 avg_bw,\n\t\t\t\t u32 peak_bw, u32 *agg_avg, u32 *agg_peak)\n{\n\tsize_t i;\n\tstruct qcom_icc_node *qn;\n\n\tqn = node->data;\n\n\tif (!tag)\n\t\ttag = RPM_ALWAYS_TAG;\n\n\tfor (i = 0; i < QCOM_SMD_RPM_STATE_NUM; i++) {\n\t\tif (tag & BIT(i)) {\n\t\t\tqn->sum_avg[i] += avg_bw;\n\t\t\tqn->max_peak[i] = max_t(u32, qn->max_peak[i], peak_bw);\n\t\t}\n\t}\n\n\t*agg_avg += avg_bw;\n\t*agg_peak = max_t(u32, *agg_peak, peak_bw);\n\treturn 0;\n}\n\n \nstatic void qcom_icc_bus_aggregate(struct icc_provider *provider, u64 *agg_clk_rate)\n{\n\tu64 agg_avg_rate, agg_rate;\n\tstruct qcom_icc_node *qn;\n\tstruct icc_node *node;\n\tint i;\n\n\t \n\tlist_for_each_entry(node, &provider->nodes, node_list) {\n\t\tqn = node->data;\n\t\tfor (i = 0; i < QCOM_SMD_RPM_STATE_NUM; i++) {\n\t\t\tif (qn->channels)\n\t\t\t\tagg_avg_rate = div_u64(qn->sum_avg[i], qn->channels);\n\t\t\telse\n\t\t\t\tagg_avg_rate = qn->sum_avg[i];\n\n\t\t\tagg_rate = max_t(u64, agg_avg_rate, qn->max_peak[i]);\n\t\t\tdo_div(agg_rate, qn->buswidth);\n\n\t\t\tagg_clk_rate[i] = max_t(u64, agg_clk_rate[i], agg_rate);\n\t\t}\n\t}\n}\n\nstatic int qcom_icc_set(struct icc_node *src, struct icc_node *dst)\n{\n\tstruct qcom_icc_node *src_qn = NULL, *dst_qn = NULL;\n\tu64 agg_clk_rate[QCOM_SMD_RPM_STATE_NUM] = { 0 };\n\tstruct icc_provider *provider;\n\tstruct qcom_icc_provider *qp;\n\tu64 active_rate, sleep_rate;\n\tint ret;\n\n\tsrc_qn = src->data;\n\tif (dst)\n\t\tdst_qn = dst->data;\n\tprovider = src->provider;\n\tqp = to_qcom_provider(provider);\n\n\tqcom_icc_bus_aggregate(provider, agg_clk_rate);\n\tactive_rate = agg_clk_rate[QCOM_SMD_RPM_ACTIVE_STATE];\n\tsleep_rate = agg_clk_rate[QCOM_SMD_RPM_SLEEP_STATE];\n\n\tret = qcom_icc_rpm_set(src_qn, src_qn->sum_avg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dst_qn) {\n\t\tret = qcom_icc_rpm_set(dst_qn, dst_qn->sum_avg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (!qp->bus_clk_desc && !qp->bus_clk)\n\t\treturn 0;\n\n\t \n\tif (qp->keep_alive)\n\t\tactive_rate = max(ICC_BUS_CLK_MIN_RATE, active_rate);\n\n\t \n\tif (qp->bus_clk) {\n\t\tactive_rate = max_t(u64, active_rate, sleep_rate);\n\t\t \n\t\tactive_rate = min_t(u64, 1000ULL * active_rate, ULONG_MAX);\n\t\treturn clk_set_rate(qp->bus_clk, active_rate);\n\t}\n\n\t \n\tactive_rate = min_t(u64, active_rate, INT_MAX);\n\tsleep_rate = min_t(u64, sleep_rate, INT_MAX);\n\n\tif (active_rate != qp->bus_clk_rate[QCOM_SMD_RPM_ACTIVE_STATE]) {\n\t\tret = qcom_icc_rpm_set_bus_rate(qp->bus_clk_desc, QCOM_SMD_RPM_ACTIVE_STATE,\n\t\t\t\t\t\tactive_rate);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tqp->bus_clk_rate[QCOM_SMD_RPM_ACTIVE_STATE] = active_rate;\n\t}\n\n\tif (sleep_rate != qp->bus_clk_rate[QCOM_SMD_RPM_SLEEP_STATE]) {\n\t\tret = qcom_icc_rpm_set_bus_rate(qp->bus_clk_desc, QCOM_SMD_RPM_SLEEP_STATE,\n\t\t\t\t\t\tsleep_rate);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tqp->bus_clk_rate[QCOM_SMD_RPM_SLEEP_STATE] = sleep_rate;\n\t}\n\n\treturn 0;\n}\n\nint qnoc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct qcom_icc_desc *desc;\n\tstruct icc_onecell_data *data;\n\tstruct icc_provider *provider;\n\tstruct qcom_icc_node * const *qnodes;\n\tstruct qcom_icc_provider *qp;\n\tstruct icc_node *node;\n\tsize_t num_nodes, i;\n\tconst char * const *cds = NULL;\n\tint cd_num;\n\tint ret;\n\n\t \n\tif (!qcom_icc_rpm_smd_available())\n\t\treturn -EPROBE_DEFER;\n\n\tdesc = of_device_get_match_data(dev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tqnodes = desc->nodes;\n\tnum_nodes = desc->num_nodes;\n\n\tif (desc->num_intf_clocks) {\n\t\tcds = desc->intf_clocks;\n\t\tcd_num = desc->num_intf_clocks;\n\t} else {\n\t\t \n\t\tcd_num = 0;\n\t}\n\n\tqp = devm_kzalloc(dev, sizeof(*qp), GFP_KERNEL);\n\tif (!qp)\n\t\treturn -ENOMEM;\n\n\tqp->intf_clks = devm_kcalloc(dev, cd_num, sizeof(*qp->intf_clks), GFP_KERNEL);\n\tif (!qp->intf_clks)\n\t\treturn -ENOMEM;\n\n\tif (desc->bus_clk_desc) {\n\t\tqp->bus_clk_desc = devm_kzalloc(dev, sizeof(*qp->bus_clk_desc),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!qp->bus_clk_desc)\n\t\t\treturn -ENOMEM;\n\n\t\tqp->bus_clk_desc = desc->bus_clk_desc;\n\t} else {\n\t\t \n\t\tqp->bus_clk = devm_clk_get_optional(dev, \"bus\");\n\t\tif (IS_ERR(qp->bus_clk))\n\t\t\treturn PTR_ERR(qp->bus_clk);\n\t}\n\n\tdata = devm_kzalloc(dev, struct_size(data, nodes, num_nodes),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tqp->num_intf_clks = cd_num;\n\tfor (i = 0; i < cd_num; i++)\n\t\tqp->intf_clks[i].id = cds[i];\n\n\tqp->keep_alive = desc->keep_alive;\n\tqp->type = desc->type;\n\tqp->qos_offset = desc->qos_offset;\n\n\tif (desc->regmap_cfg) {\n\t\tstruct resource *res;\n\t\tvoid __iomem *mmio;\n\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t\tif (!res) {\n\t\t\t \n\t\t\tqp->regmap = dev_get_regmap(dev->parent, NULL);\n\t\t\tif (qp->regmap)\n\t\t\t\tgoto regmap_done;\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tmmio = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(mmio))\n\t\t\treturn PTR_ERR(mmio);\n\n\t\tqp->regmap = devm_regmap_init_mmio(dev, mmio, desc->regmap_cfg);\n\t\tif (IS_ERR(qp->regmap)) {\n\t\t\tdev_err(dev, \"Cannot regmap interconnect bus resource\\n\");\n\t\t\treturn PTR_ERR(qp->regmap);\n\t\t}\n\t}\n\nregmap_done:\n\tret = clk_prepare_enable(qp->bus_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_clk_bulk_get(dev, qp->num_intf_clks, qp->intf_clks);\n\tif (ret)\n\t\tgoto err_disable_unprepare_clk;\n\n\tprovider = &qp->provider;\n\tprovider->dev = dev;\n\tprovider->set = qcom_icc_set;\n\tprovider->pre_aggregate = qcom_icc_pre_bw_aggregate;\n\tprovider->aggregate = qcom_icc_bw_aggregate;\n\tprovider->xlate_extended = qcom_icc_xlate_extended;\n\tprovider->data = data;\n\n\ticc_provider_init(provider);\n\n\t \n\tret = clk_bulk_prepare_enable(qp->num_intf_clks, qp->intf_clks);\n\tif (ret)\n\t\tgoto err_disable_unprepare_clk;\n\n\tfor (i = 0; i < num_nodes; i++) {\n\t\tsize_t j;\n\n\t\tnode = icc_node_create(qnodes[i]->id);\n\t\tif (IS_ERR(node)) {\n\t\t\tclk_bulk_disable_unprepare(qp->num_intf_clks,\n\t\t\t\t\t\t   qp->intf_clks);\n\t\t\tret = PTR_ERR(node);\n\t\t\tgoto err_remove_nodes;\n\t\t}\n\n\t\tnode->name = qnodes[i]->name;\n\t\tnode->data = qnodes[i];\n\t\ticc_node_add(node, provider);\n\n\t\tfor (j = 0; j < qnodes[i]->num_links; j++)\n\t\t\ticc_link_create(node, qnodes[i]->links[j]);\n\n\t\t \n\t\tif (qnodes[i]->qos.ap_owned &&\n\t\t    qnodes[i]->qos.qos_mode != NOC_QOS_MODE_INVALID) {\n\t\t\tret = qcom_icc_qos_set(node);\n\t\t\tif (ret) {\n\t\t\t\tclk_bulk_disable_unprepare(qp->num_intf_clks,\n\t\t\t\t\t\t\t   qp->intf_clks);\n\t\t\t\tgoto err_remove_nodes;\n\t\t\t}\n\t\t}\n\n\t\tdata->nodes[i] = node;\n\t}\n\tdata->num_nodes = num_nodes;\n\n\tclk_bulk_disable_unprepare(qp->num_intf_clks, qp->intf_clks);\n\n\tret = icc_provider_register(provider);\n\tif (ret)\n\t\tgoto err_remove_nodes;\n\n\tplatform_set_drvdata(pdev, qp);\n\n\t \n\tif (of_get_child_count(dev->of_node) > 0) {\n\t\tret = of_platform_populate(dev->of_node, NULL, NULL, dev);\n\t\tif (ret)\n\t\t\tgoto err_deregister_provider;\n\t}\n\n\treturn 0;\n\nerr_deregister_provider:\n\ticc_provider_deregister(provider);\nerr_remove_nodes:\n\ticc_nodes_remove(provider);\nerr_disable_unprepare_clk:\n\tclk_disable_unprepare(qp->bus_clk);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(qnoc_probe);\n\nint qnoc_remove(struct platform_device *pdev)\n{\n\tstruct qcom_icc_provider *qp = platform_get_drvdata(pdev);\n\n\ticc_provider_deregister(&qp->provider);\n\ticc_nodes_remove(&qp->provider);\n\tclk_disable_unprepare(qp->bus_clk);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(qnoc_remove);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}