{
  "module_name": "icc-rpm.h",
  "hash_id": "4a116fd33e74e90f9dc9838b3dbb3c81dc8fc5c6e7a070c320eb4eed233d5bbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/interconnect/qcom/icc-rpm.h",
  "human_readable_source": " \n \n\n#ifndef __DRIVERS_INTERCONNECT_QCOM_ICC_RPM_H\n#define __DRIVERS_INTERCONNECT_QCOM_ICC_RPM_H\n\n#include <linux/soc/qcom/smd-rpm.h>\n\n#include <dt-bindings/interconnect/qcom,rpm-icc.h>\n#include <linux/clk.h>\n#include <linux/interconnect-provider.h>\n#include <linux/platform_device.h>\n\n#define RPM_BUS_MASTER_REQ\t0x73616d62\n#define RPM_BUS_SLAVE_REQ\t0x766c7362\n\n#define to_qcom_provider(_provider) \\\n\tcontainer_of(_provider, struct qcom_icc_provider, provider)\n\nenum qcom_icc_type {\n\tQCOM_ICC_NOC,\n\tQCOM_ICC_BIMC,\n\tQCOM_ICC_QNOC,\n};\n\n \nstruct rpm_clk_resource {\n\tu32 resource_type;\n\tu32 clock_id;\n\tbool branch;\n};\n\n \nstruct qcom_icc_provider {\n\tstruct icc_provider provider;\n\tint num_intf_clks;\n\tenum qcom_icc_type type;\n\tstruct regmap *regmap;\n\tunsigned int qos_offset;\n\tu32 bus_clk_rate[QCOM_SMD_RPM_STATE_NUM];\n\tconst struct rpm_clk_resource *bus_clk_desc;\n\tstruct clk *bus_clk;\n\tstruct clk_bulk_data *intf_clks;\n\tbool keep_alive;\n\tbool is_on;\n};\n\n \nstruct qcom_icc_qos {\n\tu32 areq_prio;\n\tu32 prio_level;\n\tbool limit_commands;\n\tbool ap_owned;\n\tint qos_mode;\n\tint qos_port;\n\tbool urg_fwd_en;\n};\n\n \nstruct qcom_icc_node {\n\tunsigned char *name;\n\tu16 id;\n\tconst u16 *links;\n\tu16 num_links;\n\tu16 channels;\n\tu16 buswidth;\n\tu64 sum_avg[QCOM_SMD_RPM_STATE_NUM];\n\tu64 max_peak[QCOM_SMD_RPM_STATE_NUM];\n\tint mas_rpm_id;\n\tint slv_rpm_id;\n\tstruct qcom_icc_qos qos;\n};\n\nstruct qcom_icc_desc {\n\tstruct qcom_icc_node * const *nodes;\n\tsize_t num_nodes;\n\tconst struct rpm_clk_resource *bus_clk_desc;\n\tconst char * const *intf_clocks;\n\tsize_t num_intf_clocks;\n\tbool keep_alive;\n\tenum qcom_icc_type type;\n\tconst struct regmap_config *regmap_cfg;\n\tunsigned int qos_offset;\n};\n\n \nenum qos_mode {\n\tNOC_QOS_MODE_INVALID = 0,\n\tNOC_QOS_MODE_FIXED,\n\tNOC_QOS_MODE_BYPASS,\n};\n\nextern const struct rpm_clk_resource aggre1_clk;\nextern const struct rpm_clk_resource aggre2_clk;\nextern const struct rpm_clk_resource bimc_clk;\nextern const struct rpm_clk_resource bus_0_clk;\nextern const struct rpm_clk_resource bus_1_clk;\nextern const struct rpm_clk_resource bus_2_clk;\nextern const struct rpm_clk_resource mmaxi_0_clk;\nextern const struct rpm_clk_resource mmaxi_1_clk;\nextern const struct rpm_clk_resource qup_clk;\n\nextern const struct rpm_clk_resource aggre1_branch_clk;\nextern const struct rpm_clk_resource aggre2_branch_clk;\n\nint qnoc_probe(struct platform_device *pdev);\nint qnoc_remove(struct platform_device *pdev);\n\nbool qcom_icc_rpm_smd_available(void);\nint qcom_icc_rpm_smd_send(int ctx, int rsc_type, int id, u32 val);\nint qcom_icc_rpm_set_bus_rate(const struct rpm_clk_resource *clk, int ctx, u32 rate);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}