{
  "module_name": "osm-l3.c",
  "hash_id": "4ce5bfd44a4555c5c4495a31adea3265ab32337b7cae963436c2103acffd0ce1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/interconnect/qcom/osm-l3.c",
  "human_readable_source": "\n \n\n#include <linux/args.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/interconnect-provider.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <dt-bindings/interconnect/qcom,osm-l3.h>\n\n#define LUT_MAX_ENTRIES\t\t\t40U\n#define LUT_SRC\t\t\t\tGENMASK(31, 30)\n#define LUT_L_VAL\t\t\tGENMASK(7, 0)\n#define CLK_HW_DIV\t\t\t2\n\n \n#define REG_ENABLE\t\t\t0x0\n#define OSM_LUT_ROW_SIZE\t\t32\n#define OSM_REG_FREQ_LUT\t\t0x110\n#define OSM_REG_PERF_STATE\t\t0x920\n\n \n#define EPSS_LUT_ROW_SIZE\t\t4\n#define EPSS_REG_L3_VOTE\t\t0x90\n#define EPSS_REG_FREQ_LUT\t\t0x100\n#define EPSS_REG_PERF_STATE\t\t0x320\n\n#define OSM_L3_MAX_LINKS\t\t1\n\n#define to_osm_l3_provider(_provider) \\\n\tcontainer_of(_provider, struct qcom_osm_l3_icc_provider, provider)\n\nstruct qcom_osm_l3_icc_provider {\n\tvoid __iomem *base;\n\tunsigned int max_state;\n\tunsigned int reg_perf_state;\n\tunsigned long lut_tables[LUT_MAX_ENTRIES];\n\tstruct icc_provider provider;\n};\n\n \nstruct qcom_osm_l3_node {\n\tconst char *name;\n\tu16 links[OSM_L3_MAX_LINKS];\n\tu16 id;\n\tu16 num_links;\n\tu16 buswidth;\n};\n\nstruct qcom_osm_l3_desc {\n\tconst struct qcom_osm_l3_node * const *nodes;\n\tsize_t num_nodes;\n\tunsigned int lut_row_size;\n\tunsigned int reg_freq_lut;\n\tunsigned int reg_perf_state;\n};\n\nenum {\n\tOSM_L3_MASTER_NODE = 10000,\n\tOSM_L3_SLAVE_NODE,\n};\n\n#define DEFINE_QNODE(_name, _id, _buswidth, ...)\t\t\t\\\n\tstatic const struct qcom_osm_l3_node _name = {\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\t\\\n\t\t.id = _id,\t\t\t\t\t\t\\\n\t\t.buswidth = _buswidth,\t\t\t\t\t\\\n\t\t.num_links = COUNT_ARGS(__VA_ARGS__),\t\t\t\\\n\t\t.links = { __VA_ARGS__ },\t\t\t\t\\\n\t}\n\nDEFINE_QNODE(osm_l3_master, OSM_L3_MASTER_NODE, 16, OSM_L3_SLAVE_NODE);\nDEFINE_QNODE(osm_l3_slave, OSM_L3_SLAVE_NODE, 16);\n\nstatic const struct qcom_osm_l3_node * const osm_l3_nodes[] = {\n\t[MASTER_OSM_L3_APPS] = &osm_l3_master,\n\t[SLAVE_OSM_L3] = &osm_l3_slave,\n};\n\nDEFINE_QNODE(epss_l3_master, OSM_L3_MASTER_NODE, 32, OSM_L3_SLAVE_NODE);\nDEFINE_QNODE(epss_l3_slave, OSM_L3_SLAVE_NODE, 32);\n\nstatic const struct qcom_osm_l3_node * const epss_l3_nodes[] = {\n\t[MASTER_EPSS_L3_APPS] = &epss_l3_master,\n\t[SLAVE_EPSS_L3_SHARED] = &epss_l3_slave,\n};\n\nstatic const struct qcom_osm_l3_desc osm_l3 = {\n\t.nodes = osm_l3_nodes,\n\t.num_nodes = ARRAY_SIZE(osm_l3_nodes),\n\t.lut_row_size = OSM_LUT_ROW_SIZE,\n\t.reg_freq_lut = OSM_REG_FREQ_LUT,\n\t.reg_perf_state = OSM_REG_PERF_STATE,\n};\n\nstatic const struct qcom_osm_l3_desc epss_l3_perf_state = {\n\t.nodes = epss_l3_nodes,\n\t.num_nodes = ARRAY_SIZE(epss_l3_nodes),\n\t.lut_row_size = EPSS_LUT_ROW_SIZE,\n\t.reg_freq_lut = EPSS_REG_FREQ_LUT,\n\t.reg_perf_state = EPSS_REG_PERF_STATE,\n};\n\nstatic const struct qcom_osm_l3_desc epss_l3_l3_vote = {\n\t.nodes = epss_l3_nodes,\n\t.num_nodes = ARRAY_SIZE(epss_l3_nodes),\n\t.lut_row_size = EPSS_LUT_ROW_SIZE,\n\t.reg_freq_lut = EPSS_REG_FREQ_LUT,\n\t.reg_perf_state = EPSS_REG_L3_VOTE,\n};\n\nstatic int qcom_osm_l3_set(struct icc_node *src, struct icc_node *dst)\n{\n\tstruct qcom_osm_l3_icc_provider *qp;\n\tstruct icc_provider *provider;\n\tconst struct qcom_osm_l3_node *qn;\n\tunsigned int index;\n\tu64 rate;\n\n\tqn = src->data;\n\tprovider = src->provider;\n\tqp = to_osm_l3_provider(provider);\n\n\trate = icc_units_to_bps(dst->peak_bw);\n\tdo_div(rate, qn->buswidth);\n\n\tfor (index = 0; index < qp->max_state - 1; index++) {\n\t\tif (qp->lut_tables[index] >= rate)\n\t\t\tbreak;\n\t}\n\n\twritel_relaxed(index, qp->base + qp->reg_perf_state);\n\n\treturn 0;\n}\n\nstatic int qcom_osm_l3_remove(struct platform_device *pdev)\n{\n\tstruct qcom_osm_l3_icc_provider *qp = platform_get_drvdata(pdev);\n\n\ticc_provider_deregister(&qp->provider);\n\ticc_nodes_remove(&qp->provider);\n\n\treturn 0;\n}\n\nstatic int qcom_osm_l3_probe(struct platform_device *pdev)\n{\n\tu32 info, src, lval, i, prev_freq = 0, freq;\n\tstatic unsigned long hw_rate, xo_rate;\n\tstruct qcom_osm_l3_icc_provider *qp;\n\tconst struct qcom_osm_l3_desc *desc;\n\tstruct icc_onecell_data *data;\n\tstruct icc_provider *provider;\n\tconst struct qcom_osm_l3_node * const *qnodes;\n\tstruct icc_node *node;\n\tsize_t num_nodes;\n\tstruct clk *clk;\n\tint ret;\n\n\tclk = clk_get(&pdev->dev, \"xo\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\txo_rate = clk_get_rate(clk);\n\tclk_put(clk);\n\n\tclk = clk_get(&pdev->dev, \"alternate\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\thw_rate = clk_get_rate(clk) / CLK_HW_DIV;\n\tclk_put(clk);\n\n\tqp = devm_kzalloc(&pdev->dev, sizeof(*qp), GFP_KERNEL);\n\tif (!qp)\n\t\treturn -ENOMEM;\n\n\tqp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(qp->base))\n\t\treturn PTR_ERR(qp->base);\n\n\t \n\tif (!(readl_relaxed(qp->base + REG_ENABLE) & 0x1)) {\n\t\tdev_err(&pdev->dev, \"error hardware not enabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdesc = device_get_match_data(&pdev->dev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tqp->reg_perf_state = desc->reg_perf_state;\n\n\tfor (i = 0; i < LUT_MAX_ENTRIES; i++) {\n\t\tinfo = readl_relaxed(qp->base + desc->reg_freq_lut +\n\t\t\t\t     i * desc->lut_row_size);\n\t\tsrc = FIELD_GET(LUT_SRC, info);\n\t\tlval = FIELD_GET(LUT_L_VAL, info);\n\t\tif (src)\n\t\t\tfreq = xo_rate * lval;\n\t\telse\n\t\t\tfreq = hw_rate;\n\n\t\t \n\t\tif (i > 0 && prev_freq == freq)\n\t\t\tbreak;\n\n\t\tdev_dbg(&pdev->dev, \"index=%d freq=%d\\n\", i, freq);\n\n\t\tqp->lut_tables[i] = freq;\n\t\tprev_freq = freq;\n\t}\n\tqp->max_state = i;\n\n\tqnodes = desc->nodes;\n\tnum_nodes = desc->num_nodes;\n\n\tdata = devm_kzalloc(&pdev->dev, struct_size(data, nodes, num_nodes), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->num_nodes = num_nodes;\n\n\tprovider = &qp->provider;\n\tprovider->dev = &pdev->dev;\n\tprovider->set = qcom_osm_l3_set;\n\tprovider->aggregate = icc_std_aggregate;\n\tprovider->xlate = of_icc_xlate_onecell;\n\tprovider->data = data;\n\n\ticc_provider_init(provider);\n\n\tfor (i = 0; i < num_nodes; i++) {\n\t\tsize_t j;\n\n\t\tnode = icc_node_create(qnodes[i]->id);\n\t\tif (IS_ERR(node)) {\n\t\t\tret = PTR_ERR(node);\n\t\t\tgoto err;\n\t\t}\n\n\t\tnode->name = qnodes[i]->name;\n\t\t \n\t\tnode->data = (void *)qnodes[i];\n\t\ticc_node_add(node, provider);\n\n\t\tfor (j = 0; j < qnodes[i]->num_links; j++)\n\t\t\ticc_link_create(node, qnodes[i]->links[j]);\n\n\t\tdata->nodes[i] = node;\n\t}\n\n\tret = icc_provider_register(provider);\n\tif (ret)\n\t\tgoto err;\n\n\tplatform_set_drvdata(pdev, qp);\n\n\treturn 0;\nerr:\n\ticc_nodes_remove(provider);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id osm_l3_of_match[] = {\n\t{ .compatible = \"qcom,epss-l3\", .data = &epss_l3_l3_vote },\n\t{ .compatible = \"qcom,osm-l3\", .data = &osm_l3 },\n\t{ .compatible = \"qcom,sc7180-osm-l3\", .data = &osm_l3 },\n\t{ .compatible = \"qcom,sc7280-epss-l3\", .data = &epss_l3_perf_state },\n\t{ .compatible = \"qcom,sdm845-osm-l3\", .data = &osm_l3 },\n\t{ .compatible = \"qcom,sm8150-osm-l3\", .data = &osm_l3 },\n\t{ .compatible = \"qcom,sc8180x-osm-l3\", .data = &osm_l3 },\n\t{ .compatible = \"qcom,sm8250-epss-l3\", .data = &epss_l3_perf_state },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, osm_l3_of_match);\n\nstatic struct platform_driver osm_l3_driver = {\n\t.probe = qcom_osm_l3_probe,\n\t.remove = qcom_osm_l3_remove,\n\t.driver = {\n\t\t.name = \"osm-l3\",\n\t\t.of_match_table = osm_l3_of_match,\n\t\t.sync_state = icc_sync_state,\n\t},\n};\nmodule_platform_driver(osm_l3_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm OSM L3 interconnect driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}