{
  "module_name": "imx.c",
  "hash_id": "31f590a5c72cfcc55a07cb92167ac5521fb60330897a935e6536983dea309f9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/interconnect/imx/imx.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/interconnect-provider.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_qos.h>\n\n#include \"imx.h\"\n\n \nstruct imx_icc_node {\n\tconst struct imx_icc_node_desc *desc;\n\tconst struct imx_icc_noc_setting *setting;\n\tstruct device *qos_dev;\n\tstruct dev_pm_qos_request qos_req;\n\tstruct imx_icc_provider *imx_provider;\n};\n\nstatic int imx_icc_get_bw(struct icc_node *node, u32 *avg, u32 *peak)\n{\n\t*avg = 0;\n\t*peak = 0;\n\n\treturn 0;\n}\n\nstatic int imx_icc_node_set(struct icc_node *node)\n{\n\tstruct device *dev = node->provider->dev;\n\tstruct imx_icc_node *node_data = node->data;\n\tvoid __iomem *base;\n\tu32 prio;\n\tu64 freq;\n\n\tif (node_data->setting && node->peak_bw) {\n\t\tbase = node_data->setting->reg + node_data->imx_provider->noc_base;\n\t\tif (node_data->setting->mode == IMX_NOC_MODE_FIXED) {\n\t\t\tprio = node_data->setting->prio_level;\n\t\t\tprio = PRIORITY_COMP_MARK | (prio << 8) | prio;\n\t\t\twritel(prio, base + IMX_NOC_PRIO_REG);\n\t\t\twritel(node_data->setting->mode, base + IMX_NOC_MODE_REG);\n\t\t\twritel(node_data->setting->ext_control, base + IMX_NOC_EXT_CTL_REG);\n\t\t\tdev_dbg(dev, \"%s: mode: 0x%x, prio: 0x%x, ext_control: 0x%x\\n\",\n\t\t\t\tnode_data->desc->name, node_data->setting->mode, prio,\n\t\t\t\tnode_data->setting->ext_control);\n\t\t} else if (node_data->setting->mode == IMX_NOC_MODE_UNCONFIGURED) {\n\t\t\tdev_dbg(dev, \"%s: mode not unconfigured\\n\", node_data->desc->name);\n\t\t} else {\n\t\t\tdev_info(dev, \"%s: mode: %d not supported\\n\",\n\t\t\t\t node_data->desc->name, node_data->setting->mode);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (!node_data->qos_dev)\n\t\treturn 0;\n\n\tfreq = (node->avg_bw + node->peak_bw) * node_data->desc->adj->bw_mul;\n\tdo_div(freq, node_data->desc->adj->bw_div);\n\tdev_dbg(dev, \"node %s device %s avg_bw %ukBps peak_bw %ukBps min_freq %llukHz\\n\",\n\t\tnode->name, dev_name(node_data->qos_dev),\n\t\tnode->avg_bw, node->peak_bw, freq);\n\n\tif (freq > S32_MAX) {\n\t\tdev_err(dev, \"%s can't request more than S32_MAX freq\\n\",\n\t\t\t\tnode->name);\n\t\treturn -ERANGE;\n\t}\n\n\tdev_pm_qos_update_request(&node_data->qos_req, freq);\n\n\treturn 0;\n}\n\nstatic int imx_icc_set(struct icc_node *src, struct icc_node *dst)\n{\n\tint ret;\n\n\tret = imx_icc_node_set(src);\n\tif (ret)\n\t\treturn ret;\n\n\treturn imx_icc_node_set(dst);\n}\n\n \nstatic void imx_icc_node_destroy(struct icc_node *node)\n{\n\tstruct imx_icc_node *node_data = node->data;\n\tint ret;\n\n\tif (dev_pm_qos_request_active(&node_data->qos_req)) {\n\t\tret = dev_pm_qos_remove_request(&node_data->qos_req);\n\t\tif (ret)\n\t\t\tdev_warn(node->provider->dev,\n\t\t\t\t \"failed to remove qos request for %s\\n\",\n\t\t\t\t dev_name(node_data->qos_dev));\n\t}\n\n\tput_device(node_data->qos_dev);\n\ticc_node_del(node);\n\ticc_node_destroy(node->id);\n}\n\nstatic int imx_icc_node_init_qos(struct icc_provider *provider,\n\t\t\t\t struct icc_node *node)\n{\n\tstruct imx_icc_node *node_data = node->data;\n\tconst struct imx_icc_node_adj_desc *adj = node_data->desc->adj;\n\tstruct device *dev = provider->dev;\n\tstruct device_node *dn = NULL;\n\tstruct platform_device *pdev;\n\n\tif (adj->main_noc) {\n\t\tnode_data->qos_dev = dev;\n\t\tdev_dbg(dev, \"icc node %s[%d] is main noc itself\\n\",\n\t\t\tnode->name, node->id);\n\t} else {\n\t\tdn = of_parse_phandle(dev->of_node, adj->phandle_name, 0);\n\t\tif (!dn) {\n\t\t\tdev_warn(dev, \"Failed to parse %s\\n\",\n\t\t\t\t adj->phandle_name);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t \n\t\tif (!of_device_is_available(dn)) {\n\t\t\tdev_warn(dev, \"Missing property %s, skip scaling %s\\n\",\n\t\t\t\t adj->phandle_name, node->name);\n\t\t\tof_node_put(dn);\n\t\t\treturn 0;\n\t\t}\n\n\t\tpdev = of_find_device_by_node(dn);\n\t\tof_node_put(dn);\n\t\tif (!pdev) {\n\t\t\tdev_warn(dev, \"node %s[%d] missing device for %pOF\\n\",\n\t\t\t\t node->name, node->id, dn);\n\t\t\treturn -EPROBE_DEFER;\n\t\t}\n\t\tnode_data->qos_dev = &pdev->dev;\n\t\tdev_dbg(dev, \"node %s[%d] has device node %pOF\\n\",\n\t\t\tnode->name, node->id, dn);\n\t}\n\n\treturn dev_pm_qos_add_request(node_data->qos_dev,\n\t\t\t\t      &node_data->qos_req,\n\t\t\t\t      DEV_PM_QOS_MIN_FREQUENCY, 0);\n}\n\nstatic struct icc_node *imx_icc_node_add(struct imx_icc_provider *imx_provider,\n\t\t\t\t\t const struct imx_icc_node_desc *node_desc,\n\t\t\t\t\t const struct imx_icc_noc_setting *setting)\n{\n\tstruct icc_provider *provider = &imx_provider->provider;\n\tstruct device *dev = provider->dev;\n\tstruct imx_icc_node *node_data;\n\tstruct icc_node *node;\n\tint ret;\n\n\tnode = icc_node_create(node_desc->id);\n\tif (IS_ERR(node)) {\n\t\tdev_err(dev, \"failed to create node %d\\n\", node_desc->id);\n\t\treturn node;\n\t}\n\n\tif (node->data) {\n\t\tdev_err(dev, \"already created node %s id=%d\\n\",\n\t\t\tnode_desc->name, node_desc->id);\n\t\treturn ERR_PTR(-EEXIST);\n\t}\n\n\tnode_data = devm_kzalloc(dev, sizeof(*node_data), GFP_KERNEL);\n\tif (!node_data) {\n\t\ticc_node_destroy(node->id);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tnode->name = node_desc->name;\n\tnode->data = node_data;\n\tnode_data->desc = node_desc;\n\tnode_data->setting = setting;\n\tnode_data->imx_provider = imx_provider;\n\ticc_node_add(node, provider);\n\n\tif (node_desc->adj) {\n\t\tret = imx_icc_node_init_qos(provider, node);\n\t\tif (ret < 0) {\n\t\t\timx_icc_node_destroy(node);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn node;\n}\n\nstatic void imx_icc_unregister_nodes(struct icc_provider *provider)\n{\n\tstruct icc_node *node, *tmp;\n\n\tlist_for_each_entry_safe(node, tmp, &provider->nodes, node_list)\n\t\timx_icc_node_destroy(node);\n}\n\nstatic int imx_icc_register_nodes(struct imx_icc_provider *imx_provider,\n\t\t\t\t  const struct imx_icc_node_desc *descs,\n\t\t\t\t  int count,\n\t\t\t\t  const struct imx_icc_noc_setting *settings)\n{\n\tstruct icc_provider *provider = &imx_provider->provider;\n\tstruct icc_onecell_data *provider_data = provider->data;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct icc_node *node;\n\t\tconst struct imx_icc_node_desc *node_desc = &descs[i];\n\t\tsize_t j;\n\n\t\tnode = imx_icc_node_add(imx_provider, node_desc,\n\t\t\t\t\tsettings ? &settings[node_desc->id] : NULL);\n\t\tif (IS_ERR(node)) {\n\t\t\tret = dev_err_probe(provider->dev, PTR_ERR(node),\n\t\t\t\t\t    \"failed to add %s\\n\", node_desc->name);\n\t\t\tgoto err;\n\t\t}\n\t\tprovider_data->nodes[node->id] = node;\n\n\t\tfor (j = 0; j < node_desc->num_links; j++) {\n\t\t\tret = icc_link_create(node, node_desc->links[j]);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(provider->dev, \"failed to link node %d to %d: %d\\n\",\n\t\t\t\t\tnode->id, node_desc->links[j], ret);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\timx_icc_unregister_nodes(provider);\n\n\treturn ret;\n}\n\nstatic int get_max_node_id(struct imx_icc_node_desc *nodes, int nodes_count)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < nodes_count; ++i)\n\t\tif (nodes[i].id > ret)\n\t\t\tret = nodes[i].id;\n\n\treturn ret;\n}\n\nint imx_icc_register(struct platform_device *pdev,\n\t\t     struct imx_icc_node_desc *nodes, int nodes_count,\n\t\t     struct imx_icc_noc_setting *settings)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct icc_onecell_data *data;\n\tstruct imx_icc_provider *imx_provider;\n\tstruct icc_provider *provider;\n\tint num_nodes;\n\tint ret;\n\n\t \n\tnum_nodes = get_max_node_id(nodes, nodes_count) + 1;\n\tdata = devm_kzalloc(dev, struct_size(data, nodes, num_nodes),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->num_nodes = num_nodes;\n\n\timx_provider = devm_kzalloc(dev, sizeof(*imx_provider), GFP_KERNEL);\n\tif (!imx_provider)\n\t\treturn -ENOMEM;\n\tprovider = &imx_provider->provider;\n\tprovider->set = imx_icc_set;\n\tprovider->get_bw = imx_icc_get_bw;\n\tprovider->aggregate = icc_std_aggregate;\n\tprovider->xlate = of_icc_xlate_onecell;\n\tprovider->data = data;\n\tprovider->dev = dev->parent;\n\n\ticc_provider_init(provider);\n\n\tplatform_set_drvdata(pdev, imx_provider);\n\n\tif (settings) {\n\t\timx_provider->noc_base = devm_of_iomap(dev, provider->dev->of_node, 0, NULL);\n\t\tif (IS_ERR(imx_provider->noc_base)) {\n\t\t\tret = PTR_ERR(imx_provider->noc_base);\n\t\t\tdev_err(dev, \"Error mapping NoC: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = imx_icc_register_nodes(imx_provider, nodes, nodes_count, settings);\n\tif (ret)\n\t\treturn ret;\n\n\tret = icc_provider_register(provider);\n\tif (ret)\n\t\tgoto err_unregister_nodes;\n\n\treturn 0;\n\nerr_unregister_nodes:\n\timx_icc_unregister_nodes(&imx_provider->provider);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(imx_icc_register);\n\nvoid imx_icc_unregister(struct platform_device *pdev)\n{\n\tstruct imx_icc_provider *imx_provider = platform_get_drvdata(pdev);\n\n\ticc_provider_deregister(&imx_provider->provider);\n\timx_icc_unregister_nodes(&imx_provider->provider);\n}\nEXPORT_SYMBOL_GPL(imx_icc_unregister);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}