{
  "module_name": "exynos.c",
  "hash_id": "fe487434f7a6b787e001fbd81580ee142603950e2fbce4fa151c104545aeb891",
  "original_prompt": "Ingested from linux-6.6.14/drivers/interconnect/samsung/exynos.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/interconnect-provider.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_qos.h>\n#include <linux/slab.h>\n\n#define EXYNOS_ICC_DEFAULT_BUS_CLK_RATIO\t8\n\nstruct exynos_icc_priv {\n\tstruct device *dev;\n\n\t \n\tstruct icc_provider provider;\n\tstruct icc_node *node;\n\n\tstruct dev_pm_qos_request qos_req;\n\tu32 bus_clk_ratio;\n};\n\nstatic struct icc_node *exynos_icc_get_parent(struct device_node *np)\n{\n\tstruct of_phandle_args args;\n\tstruct icc_node_data *icc_node_data;\n\tstruct icc_node *icc_node;\n\tint num, ret;\n\n\tnum = of_count_phandle_with_args(np, \"interconnects\",\n\t\t\t\t\t \"#interconnect-cells\");\n\tif (num < 1)\n\t\treturn NULL;  \n\n\t \n\tret = of_parse_phandle_with_args(np, \"interconnects\",\n\t\t\t\t\t\"#interconnect-cells\", 0, &args);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\ticc_node_data = of_icc_get_from_provider(&args);\n\tof_node_put(args.np);\n\n\tif (IS_ERR(icc_node_data))\n\t\treturn ERR_CAST(icc_node_data);\n\n\ticc_node = icc_node_data->node;\n\tkfree(icc_node_data);\n\n\treturn icc_node;\n}\n\nstatic int exynos_generic_icc_set(struct icc_node *src, struct icc_node *dst)\n{\n\tstruct exynos_icc_priv *src_priv = src->data, *dst_priv = dst->data;\n\ts32 src_freq = max(src->avg_bw, src->peak_bw) / src_priv->bus_clk_ratio;\n\ts32 dst_freq = max(dst->avg_bw, dst->peak_bw) / dst_priv->bus_clk_ratio;\n\tint ret;\n\n\tret = dev_pm_qos_update_request(&src_priv->qos_req, src_freq);\n\tif (ret < 0) {\n\t\tdev_err(src_priv->dev, \"failed to update PM QoS of %s (src)\\n\",\n\t\t\tsrc->name);\n\t\treturn ret;\n\t}\n\n\tret = dev_pm_qos_update_request(&dst_priv->qos_req, dst_freq);\n\tif (ret < 0) {\n\t\tdev_err(dst_priv->dev, \"failed to update PM QoS of %s (dst)\\n\",\n\t\t\tdst->name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct icc_node *exynos_generic_icc_xlate(struct of_phandle_args *spec,\n\t\t\t\t\t\t void *data)\n{\n\tstruct exynos_icc_priv *priv = data;\n\n\tif (spec->np != priv->dev->parent->of_node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn priv->node;\n}\n\nstatic int exynos_generic_icc_remove(struct platform_device *pdev)\n{\n\tstruct exynos_icc_priv *priv = platform_get_drvdata(pdev);\n\n\ticc_provider_deregister(&priv->provider);\n\ticc_nodes_remove(&priv->provider);\n\n\treturn 0;\n}\n\nstatic int exynos_generic_icc_probe(struct platform_device *pdev)\n{\n\tstruct device *bus_dev = pdev->dev.parent;\n\tstruct exynos_icc_priv *priv;\n\tstruct icc_provider *provider;\n\tstruct icc_node *icc_node, *icc_parent_node;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, priv);\n\n\tprovider = &priv->provider;\n\n\tprovider->set = exynos_generic_icc_set;\n\tprovider->aggregate = icc_std_aggregate;\n\tprovider->xlate = exynos_generic_icc_xlate;\n\tprovider->dev = bus_dev;\n\tprovider->inter_set = true;\n\tprovider->data = priv;\n\n\ticc_provider_init(provider);\n\n\ticc_node = icc_node_create(pdev->id);\n\tif (IS_ERR(icc_node))\n\t\treturn PTR_ERR(icc_node);\n\n\tpriv->node = icc_node;\n\ticc_node->name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"%pOFn\",\n\t\t\t\t\tbus_dev->of_node);\n\tif (of_property_read_u32(bus_dev->of_node, \"samsung,data-clock-ratio\",\n\t\t\t\t &priv->bus_clk_ratio))\n\t\tpriv->bus_clk_ratio = EXYNOS_ICC_DEFAULT_BUS_CLK_RATIO;\n\n\ticc_node->data = priv;\n\ticc_node_add(icc_node, provider);\n\n\t \n\tret = dev_pm_qos_add_request(bus_dev, &priv->qos_req,\n\t\t\t\t     DEV_PM_QOS_MIN_FREQUENCY, 0);\n\tif (ret < 0)\n\t\tgoto err_node_del;\n\n\ticc_parent_node = exynos_icc_get_parent(bus_dev->of_node);\n\tif (IS_ERR(icc_parent_node)) {\n\t\tret = PTR_ERR(icc_parent_node);\n\t\tgoto err_pmqos_del;\n\t}\n\tif (icc_parent_node) {\n\t\tret = icc_link_create(icc_node, icc_parent_node->id);\n\t\tif (ret < 0)\n\t\t\tgoto err_pmqos_del;\n\t}\n\n\tret = icc_provider_register(provider);\n\tif (ret < 0)\n\t\tgoto err_pmqos_del;\n\n\treturn 0;\n\nerr_pmqos_del:\n\tdev_pm_qos_remove_request(&priv->qos_req);\nerr_node_del:\n\ticc_nodes_remove(provider);\n\n\treturn ret;\n}\n\nstatic struct platform_driver exynos_generic_icc_driver = {\n\t.driver = {\n\t\t.name = \"exynos-generic-icc\",\n\t\t.sync_state = icc_sync_state,\n\t},\n\t.probe = exynos_generic_icc_probe,\n\t.remove = exynos_generic_icc_remove,\n};\nmodule_platform_driver(exynos_generic_icc_driver);\n\nMODULE_DESCRIPTION(\"Exynos generic interconnect driver\");\nMODULE_AUTHOR(\"Artur \u015awigo\u0144 <a.swigon@samsung.com>\");\nMODULE_AUTHOR(\"Sylwester Nawrocki <s.nawrocki@samsung.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:exynos-generic-icc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}