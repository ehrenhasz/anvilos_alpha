{
  "module_name": "core.c",
  "hash_id": "aa9d76e580ff3dc2d98b21760a1a8a1f031d27e8cc8440a97e54b78a131df4c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/interconnect/core.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/interconnect.h>\n#include <linux/interconnect-provider.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/overflow.h>\n\n#include \"internal.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\nstatic DEFINE_IDR(icc_idr);\nstatic LIST_HEAD(icc_providers);\nstatic int providers_count;\nstatic bool synced_state;\nstatic DEFINE_MUTEX(icc_lock);\nstatic DEFINE_MUTEX(icc_bw_lock);\nstatic struct dentry *icc_debugfs_dir;\n\nstatic void icc_summary_show_one(struct seq_file *s, struct icc_node *n)\n{\n\tif (!n)\n\t\treturn;\n\n\tseq_printf(s, \"%-42s %12u %12u\\n\",\n\t\t   n->name, n->avg_bw, n->peak_bw);\n}\n\nstatic int icc_summary_show(struct seq_file *s, void *data)\n{\n\tstruct icc_provider *provider;\n\n\tseq_puts(s, \" node                                  tag          avg         peak\\n\");\n\tseq_puts(s, \"--------------------------------------------------------------------\\n\");\n\n\tmutex_lock(&icc_lock);\n\n\tlist_for_each_entry(provider, &icc_providers, provider_list) {\n\t\tstruct icc_node *n;\n\n\t\tlist_for_each_entry(n, &provider->nodes, node_list) {\n\t\t\tstruct icc_req *r;\n\n\t\t\ticc_summary_show_one(s, n);\n\t\t\thlist_for_each_entry(r, &n->req_list, req_node) {\n\t\t\t\tu32 avg_bw = 0, peak_bw = 0;\n\n\t\t\t\tif (!r->dev)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (r->enabled) {\n\t\t\t\t\tavg_bw = r->avg_bw;\n\t\t\t\t\tpeak_bw = r->peak_bw;\n\t\t\t\t}\n\n\t\t\t\tseq_printf(s, \"  %-27s %12u %12u %12u\\n\",\n\t\t\t\t\t   dev_name(r->dev), r->tag, avg_bw, peak_bw);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&icc_lock);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(icc_summary);\n\nstatic void icc_graph_show_link(struct seq_file *s, int level,\n\t\t\t\tstruct icc_node *n, struct icc_node *m)\n{\n\tseq_printf(s, \"%s\\\"%d:%s\\\" -> \\\"%d:%s\\\"\\n\",\n\t\t   level == 2 ? \"\\t\\t\" : \"\\t\",\n\t\t   n->id, n->name, m->id, m->name);\n}\n\nstatic void icc_graph_show_node(struct seq_file *s, struct icc_node *n)\n{\n\tseq_printf(s, \"\\t\\t\\\"%d:%s\\\" [label=\\\"%d:%s\",\n\t\t   n->id, n->name, n->id, n->name);\n\tseq_printf(s, \"\\n\\t\\t\\t|avg_bw=%ukBps\", n->avg_bw);\n\tseq_printf(s, \"\\n\\t\\t\\t|peak_bw=%ukBps\", n->peak_bw);\n\tseq_puts(s, \"\\\"]\\n\");\n}\n\nstatic int icc_graph_show(struct seq_file *s, void *data)\n{\n\tstruct icc_provider *provider;\n\tstruct icc_node *n;\n\tint cluster_index = 0;\n\tint i;\n\n\tseq_puts(s, \"digraph {\\n\\trankdir = LR\\n\\tnode [shape = record]\\n\");\n\tmutex_lock(&icc_lock);\n\n\t \n\tcluster_index = 0;\n\tlist_for_each_entry(provider, &icc_providers, provider_list) {\n\t\tseq_printf(s, \"\\tsubgraph cluster_%d {\\n\", ++cluster_index);\n\t\tif (provider->dev)\n\t\t\tseq_printf(s, \"\\t\\tlabel = \\\"%s\\\"\\n\",\n\t\t\t\t   dev_name(provider->dev));\n\n\t\t \n\t\tlist_for_each_entry(n, &provider->nodes, node_list)\n\t\t\ticc_graph_show_node(s, n);\n\n\t\t \n\t\tlist_for_each_entry(n, &provider->nodes, node_list)\n\t\t\tfor (i = 0; i < n->num_links; ++i)\n\t\t\t\tif (n->provider == n->links[i]->provider)\n\t\t\t\t\ticc_graph_show_link(s, 2, n,\n\t\t\t\t\t\t\t    n->links[i]);\n\n\t\tseq_puts(s, \"\\t}\\n\");\n\t}\n\n\t \n\tlist_for_each_entry(provider, &icc_providers, provider_list)\n\t\tlist_for_each_entry(n, &provider->nodes, node_list)\n\t\t\tfor (i = 0; i < n->num_links; ++i)\n\t\t\t\tif (n->provider != n->links[i]->provider)\n\t\t\t\t\ticc_graph_show_link(s, 1, n,\n\t\t\t\t\t\t\t    n->links[i]);\n\n\tmutex_unlock(&icc_lock);\n\tseq_puts(s, \"}\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(icc_graph);\n\nstatic struct icc_node *node_find(const int id)\n{\n\treturn idr_find(&icc_idr, id);\n}\n\nstatic struct icc_node *node_find_by_name(const char *name)\n{\n\tstruct icc_provider *provider;\n\tstruct icc_node *n;\n\n\tlist_for_each_entry(provider, &icc_providers, provider_list) {\n\t\tlist_for_each_entry(n, &provider->nodes, node_list) {\n\t\t\tif (!strcmp(n->name, name))\n\t\t\t\treturn n;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct icc_path *path_init(struct device *dev, struct icc_node *dst,\n\t\t\t\t  ssize_t num_nodes)\n{\n\tstruct icc_node *node = dst;\n\tstruct icc_path *path;\n\tint i;\n\n\tpath = kzalloc(struct_size(path, reqs, num_nodes), GFP_KERNEL);\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpath->num_nodes = num_nodes;\n\n\tfor (i = num_nodes - 1; i >= 0; i--) {\n\t\tnode->provider->users++;\n\t\thlist_add_head(&path->reqs[i].req_node, &node->req_list);\n\t\tpath->reqs[i].node = node;\n\t\tpath->reqs[i].dev = dev;\n\t\tpath->reqs[i].enabled = true;\n\t\t \n\t\tnode = node->reverse;\n\t}\n\n\treturn path;\n}\n\nstatic struct icc_path *path_find(struct device *dev, struct icc_node *src,\n\t\t\t\t  struct icc_node *dst)\n{\n\tstruct icc_path *path = ERR_PTR(-EPROBE_DEFER);\n\tstruct icc_node *n, *node = NULL;\n\tstruct list_head traverse_list;\n\tstruct list_head edge_list;\n\tstruct list_head visited_list;\n\tsize_t i, depth = 1;\n\tbool found = false;\n\n\tINIT_LIST_HEAD(&traverse_list);\n\tINIT_LIST_HEAD(&edge_list);\n\tINIT_LIST_HEAD(&visited_list);\n\n\tlist_add(&src->search_list, &traverse_list);\n\tsrc->reverse = NULL;\n\n\tdo {\n\t\tlist_for_each_entry_safe(node, n, &traverse_list, search_list) {\n\t\t\tif (node == dst) {\n\t\t\t\tfound = true;\n\t\t\t\tlist_splice_init(&edge_list, &visited_list);\n\t\t\t\tlist_splice_init(&traverse_list, &visited_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (i = 0; i < node->num_links; i++) {\n\t\t\t\tstruct icc_node *tmp = node->links[i];\n\n\t\t\t\tif (!tmp) {\n\t\t\t\t\tpath = ERR_PTR(-ENOENT);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (tmp->is_traversed)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmp->is_traversed = true;\n\t\t\t\ttmp->reverse = node;\n\t\t\t\tlist_add_tail(&tmp->search_list, &edge_list);\n\t\t\t}\n\t\t}\n\n\t\tif (found)\n\t\t\tbreak;\n\n\t\tlist_splice_init(&traverse_list, &visited_list);\n\t\tlist_splice_init(&edge_list, &traverse_list);\n\n\t\t \n\t\tdepth++;\n\n\t} while (!list_empty(&traverse_list));\n\nout:\n\n\t \n\tlist_for_each_entry_reverse(n, &visited_list, search_list)\n\t\tn->is_traversed = false;\n\n\tif (found)\n\t\tpath = path_init(dev, dst, depth);\n\n\treturn path;\n}\n\n \n\nstatic int aggregate_requests(struct icc_node *node)\n{\n\tstruct icc_provider *p = node->provider;\n\tstruct icc_req *r;\n\tu32 avg_bw, peak_bw;\n\n\tnode->avg_bw = 0;\n\tnode->peak_bw = 0;\n\n\tif (p->pre_aggregate)\n\t\tp->pre_aggregate(node);\n\n\thlist_for_each_entry(r, &node->req_list, req_node) {\n\t\tif (r->enabled) {\n\t\t\tavg_bw = r->avg_bw;\n\t\t\tpeak_bw = r->peak_bw;\n\t\t} else {\n\t\t\tavg_bw = 0;\n\t\t\tpeak_bw = 0;\n\t\t}\n\t\tp->aggregate(node, r->tag, avg_bw, peak_bw,\n\t\t\t     &node->avg_bw, &node->peak_bw);\n\n\t\t \n\t\tif (!synced_state) {\n\t\t\tnode->avg_bw = max(node->avg_bw, node->init_avg);\n\t\t\tnode->peak_bw = max(node->peak_bw, node->init_peak);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int apply_constraints(struct icc_path *path)\n{\n\tstruct icc_node *next, *prev = NULL;\n\tstruct icc_provider *p;\n\tint ret = -EINVAL;\n\tint i;\n\n\tfor (i = 0; i < path->num_nodes; i++) {\n\t\tnext = path->reqs[i].node;\n\t\tp = next->provider;\n\n\t\t \n\t\tif (!prev || (p != prev->provider && !p->inter_set)) {\n\t\t\tprev = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = p->set(prev, next);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tprev = next;\n\t}\nout:\n\treturn ret;\n}\n\nint icc_std_aggregate(struct icc_node *node, u32 tag, u32 avg_bw,\n\t\t      u32 peak_bw, u32 *agg_avg, u32 *agg_peak)\n{\n\t*agg_avg += avg_bw;\n\t*agg_peak = max(*agg_peak, peak_bw);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(icc_std_aggregate);\n\n \nstruct icc_node *of_icc_xlate_onecell(struct of_phandle_args *spec,\n\t\t\t\t      void *data)\n{\n\tstruct icc_onecell_data *icc_data = data;\n\tunsigned int idx = spec->args[0];\n\n\tif (idx >= icc_data->num_nodes) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn icc_data->nodes[idx];\n}\nEXPORT_SYMBOL_GPL(of_icc_xlate_onecell);\n\n \nstruct icc_node_data *of_icc_get_from_provider(struct of_phandle_args *spec)\n{\n\tstruct icc_node *node = ERR_PTR(-EPROBE_DEFER);\n\tstruct icc_node_data *data = NULL;\n\tstruct icc_provider *provider;\n\n\tif (!spec)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmutex_lock(&icc_lock);\n\tlist_for_each_entry(provider, &icc_providers, provider_list) {\n\t\tif (provider->dev->of_node == spec->np) {\n\t\t\tif (provider->xlate_extended) {\n\t\t\t\tdata = provider->xlate_extended(spec, provider->data);\n\t\t\t\tif (!IS_ERR(data)) {\n\t\t\t\t\tnode = data->node;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = provider->xlate(spec, provider->data);\n\t\t\t\tif (!IS_ERR(node))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&icc_lock);\n\n\tif (!node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (IS_ERR(node))\n\t\treturn ERR_CAST(node);\n\n\tif (!data) {\n\t\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tdata->node = node;\n\t}\n\n\treturn data;\n}\nEXPORT_SYMBOL_GPL(of_icc_get_from_provider);\n\nstatic void devm_icc_release(struct device *dev, void *res)\n{\n\ticc_put(*(struct icc_path **)res);\n}\n\nstruct icc_path *devm_of_icc_get(struct device *dev, const char *name)\n{\n\tstruct icc_path **ptr, *path;\n\n\tptr = devres_alloc(devm_icc_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpath = of_icc_get(dev, name);\n\tif (!IS_ERR(path)) {\n\t\t*ptr = path;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn path;\n}\nEXPORT_SYMBOL_GPL(devm_of_icc_get);\n\n \nstruct icc_path *of_icc_get_by_index(struct device *dev, int idx)\n{\n\tstruct icc_path *path;\n\tstruct icc_node_data *src_data, *dst_data;\n\tstruct device_node *np;\n\tstruct of_phandle_args src_args, dst_args;\n\tint ret;\n\n\tif (!dev || !dev->of_node)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tnp = dev->of_node;\n\n\t \n\tif (!of_property_present(np, \"interconnects\"))\n\t\treturn NULL;\n\n\t \n\tret = of_parse_phandle_with_args(np, \"interconnects\",\n\t\t\t\t\t \"#interconnect-cells\", idx * 2,\n\t\t\t\t\t &src_args);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tof_node_put(src_args.np);\n\n\tret = of_parse_phandle_with_args(np, \"interconnects\",\n\t\t\t\t\t \"#interconnect-cells\", idx * 2 + 1,\n\t\t\t\t\t &dst_args);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tof_node_put(dst_args.np);\n\n\tsrc_data = of_icc_get_from_provider(&src_args);\n\n\tif (IS_ERR(src_data)) {\n\t\tdev_err_probe(dev, PTR_ERR(src_data), \"error finding src node\\n\");\n\t\treturn ERR_CAST(src_data);\n\t}\n\n\tdst_data = of_icc_get_from_provider(&dst_args);\n\n\tif (IS_ERR(dst_data)) {\n\t\tdev_err_probe(dev, PTR_ERR(dst_data), \"error finding dst node\\n\");\n\t\tkfree(src_data);\n\t\treturn ERR_CAST(dst_data);\n\t}\n\n\tmutex_lock(&icc_lock);\n\tpath = path_find(dev, src_data->node, dst_data->node);\n\tmutex_unlock(&icc_lock);\n\tif (IS_ERR(path)) {\n\t\tdev_err(dev, \"%s: invalid path=%ld\\n\", __func__, PTR_ERR(path));\n\t\tgoto free_icc_data;\n\t}\n\n\tif (src_data->tag && src_data->tag == dst_data->tag)\n\t\ticc_set_tag(path, src_data->tag);\n\n\tpath->name = kasprintf(GFP_KERNEL, \"%s-%s\",\n\t\t\t       src_data->node->name, dst_data->node->name);\n\tif (!path->name) {\n\t\tkfree(path);\n\t\tpath = ERR_PTR(-ENOMEM);\n\t}\n\nfree_icc_data:\n\tkfree(src_data);\n\tkfree(dst_data);\n\treturn path;\n}\nEXPORT_SYMBOL_GPL(of_icc_get_by_index);\n\n \nstruct icc_path *of_icc_get(struct device *dev, const char *name)\n{\n\tstruct device_node *np;\n\tint idx = 0;\n\n\tif (!dev || !dev->of_node)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tnp = dev->of_node;\n\n\t \n\tif (!of_property_present(np, \"interconnects\"))\n\t\treturn NULL;\n\n\t \n\tif (name) {\n\t\tidx = of_property_match_string(np, \"interconnect-names\", name);\n\t\tif (idx < 0)\n\t\t\treturn ERR_PTR(idx);\n\t}\n\n\treturn of_icc_get_by_index(dev, idx);\n}\nEXPORT_SYMBOL_GPL(of_icc_get);\n\n \nstruct icc_path *icc_get(struct device *dev, const char *src, const char *dst)\n{\n\tstruct icc_node *src_node, *dst_node;\n\tstruct icc_path *path = ERR_PTR(-EPROBE_DEFER);\n\n\tmutex_lock(&icc_lock);\n\n\tsrc_node = node_find_by_name(src);\n\tif (!src_node) {\n\t\tdev_err(dev, \"%s: invalid src=%s\\n\", __func__, src);\n\t\tgoto out;\n\t}\n\n\tdst_node = node_find_by_name(dst);\n\tif (!dst_node) {\n\t\tdev_err(dev, \"%s: invalid dst=%s\\n\", __func__, dst);\n\t\tgoto out;\n\t}\n\n\tpath = path_find(dev, src_node, dst_node);\n\tif (IS_ERR(path)) {\n\t\tdev_err(dev, \"%s: invalid path=%ld\\n\", __func__, PTR_ERR(path));\n\t\tgoto out;\n\t}\n\n\tpath->name = kasprintf(GFP_KERNEL, \"%s-%s\", src_node->name, dst_node->name);\n\tif (!path->name) {\n\t\tkfree(path);\n\t\tpath = ERR_PTR(-ENOMEM);\n\t}\nout:\n\tmutex_unlock(&icc_lock);\n\treturn path;\n}\n\n \nvoid icc_set_tag(struct icc_path *path, u32 tag)\n{\n\tint i;\n\n\tif (!path)\n\t\treturn;\n\n\tmutex_lock(&icc_lock);\n\n\tfor (i = 0; i < path->num_nodes; i++)\n\t\tpath->reqs[i].tag = tag;\n\n\tmutex_unlock(&icc_lock);\n}\nEXPORT_SYMBOL_GPL(icc_set_tag);\n\n \nconst char *icc_get_name(struct icc_path *path)\n{\n\tif (!path)\n\t\treturn NULL;\n\n\treturn path->name;\n}\nEXPORT_SYMBOL_GPL(icc_get_name);\n\n \nint icc_set_bw(struct icc_path *path, u32 avg_bw, u32 peak_bw)\n{\n\tstruct icc_node *node;\n\tu32 old_avg, old_peak;\n\tsize_t i;\n\tint ret;\n\n\tif (!path)\n\t\treturn 0;\n\n\tif (WARN_ON(IS_ERR(path) || !path->num_nodes))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&icc_bw_lock);\n\n\told_avg = path->reqs[0].avg_bw;\n\told_peak = path->reqs[0].peak_bw;\n\n\tfor (i = 0; i < path->num_nodes; i++) {\n\t\tnode = path->reqs[i].node;\n\n\t\t \n\t\tpath->reqs[i].avg_bw = avg_bw;\n\t\tpath->reqs[i].peak_bw = peak_bw;\n\n\t\t \n\t\taggregate_requests(node);\n\n\t\ttrace_icc_set_bw(path, node, i, avg_bw, peak_bw);\n\t}\n\n\tret = apply_constraints(path);\n\tif (ret) {\n\t\tpr_debug(\"interconnect: error applying constraints (%d)\\n\",\n\t\t\t ret);\n\n\t\tfor (i = 0; i < path->num_nodes; i++) {\n\t\t\tnode = path->reqs[i].node;\n\t\t\tpath->reqs[i].avg_bw = old_avg;\n\t\t\tpath->reqs[i].peak_bw = old_peak;\n\t\t\taggregate_requests(node);\n\t\t}\n\t\tapply_constraints(path);\n\t}\n\n\tmutex_unlock(&icc_bw_lock);\n\n\ttrace_icc_set_bw_end(path, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(icc_set_bw);\n\nstatic int __icc_enable(struct icc_path *path, bool enable)\n{\n\tint i;\n\n\tif (!path)\n\t\treturn 0;\n\n\tif (WARN_ON(IS_ERR(path) || !path->num_nodes))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&icc_lock);\n\n\tfor (i = 0; i < path->num_nodes; i++)\n\t\tpath->reqs[i].enabled = enable;\n\n\tmutex_unlock(&icc_lock);\n\n\treturn icc_set_bw(path, path->reqs[0].avg_bw,\n\t\t\t  path->reqs[0].peak_bw);\n}\n\nint icc_enable(struct icc_path *path)\n{\n\treturn __icc_enable(path, true);\n}\nEXPORT_SYMBOL_GPL(icc_enable);\n\nint icc_disable(struct icc_path *path)\n{\n\treturn __icc_enable(path, false);\n}\nEXPORT_SYMBOL_GPL(icc_disable);\n\n \nvoid icc_put(struct icc_path *path)\n{\n\tstruct icc_node *node;\n\tsize_t i;\n\tint ret;\n\n\tif (!path || WARN_ON(IS_ERR(path)))\n\t\treturn;\n\n\tret = icc_set_bw(path, 0, 0);\n\tif (ret)\n\t\tpr_err(\"%s: error (%d)\\n\", __func__, ret);\n\n\tmutex_lock(&icc_lock);\n\tfor (i = 0; i < path->num_nodes; i++) {\n\t\tnode = path->reqs[i].node;\n\t\thlist_del(&path->reqs[i].req_node);\n\t\tif (!WARN_ON(!node->provider->users))\n\t\t\tnode->provider->users--;\n\t}\n\tmutex_unlock(&icc_lock);\n\n\tkfree_const(path->name);\n\tkfree(path);\n}\nEXPORT_SYMBOL_GPL(icc_put);\n\nstatic struct icc_node *icc_node_create_nolock(int id)\n{\n\tstruct icc_node *node;\n\n\t \n\tnode = node_find(id);\n\tif (node)\n\t\treturn node;\n\n\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tid = idr_alloc(&icc_idr, node, id, id + 1, GFP_KERNEL);\n\tif (id < 0) {\n\t\tWARN(1, \"%s: couldn't get idr\\n\", __func__);\n\t\tkfree(node);\n\t\treturn ERR_PTR(id);\n\t}\n\n\tnode->id = id;\n\n\treturn node;\n}\n\n \nstruct icc_node *icc_node_create(int id)\n{\n\tstruct icc_node *node;\n\n\tmutex_lock(&icc_lock);\n\n\tnode = icc_node_create_nolock(id);\n\n\tmutex_unlock(&icc_lock);\n\n\treturn node;\n}\nEXPORT_SYMBOL_GPL(icc_node_create);\n\n \nvoid icc_node_destroy(int id)\n{\n\tstruct icc_node *node;\n\n\tmutex_lock(&icc_lock);\n\n\tnode = node_find(id);\n\tif (node) {\n\t\tidr_remove(&icc_idr, node->id);\n\t\tWARN_ON(!hlist_empty(&node->req_list));\n\t}\n\n\tmutex_unlock(&icc_lock);\n\n\tif (!node)\n\t\treturn;\n\n\tkfree(node->links);\n\tkfree(node);\n}\nEXPORT_SYMBOL_GPL(icc_node_destroy);\n\n \nint icc_link_create(struct icc_node *node, const int dst_id)\n{\n\tstruct icc_node *dst;\n\tstruct icc_node **new;\n\tint ret = 0;\n\n\tif (!node->provider)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&icc_lock);\n\n\tdst = node_find(dst_id);\n\tif (!dst) {\n\t\tdst = icc_node_create_nolock(dst_id);\n\n\t\tif (IS_ERR(dst)) {\n\t\t\tret = PTR_ERR(dst);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnew = krealloc(node->links,\n\t\t       (node->num_links + 1) * sizeof(*node->links),\n\t\t       GFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnode->links = new;\n\tnode->links[node->num_links++] = dst;\n\nout:\n\tmutex_unlock(&icc_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(icc_link_create);\n\n \nvoid icc_node_add(struct icc_node *node, struct icc_provider *provider)\n{\n\tif (WARN_ON(node->provider))\n\t\treturn;\n\n\tmutex_lock(&icc_lock);\n\tmutex_lock(&icc_bw_lock);\n\n\tnode->provider = provider;\n\tlist_add_tail(&node->node_list, &provider->nodes);\n\n\t \n\tif (provider->get_bw) {\n\t\tprovider->get_bw(node, &node->init_avg, &node->init_peak);\n\t} else {\n\t\tnode->init_avg = INT_MAX;\n\t\tnode->init_peak = INT_MAX;\n\t}\n\tnode->avg_bw = node->init_avg;\n\tnode->peak_bw = node->init_peak;\n\n\tif (node->avg_bw || node->peak_bw) {\n\t\tif (provider->pre_aggregate)\n\t\t\tprovider->pre_aggregate(node);\n\n\t\tif (provider->aggregate)\n\t\t\tprovider->aggregate(node, 0, node->init_avg, node->init_peak,\n\t\t\t\t\t    &node->avg_bw, &node->peak_bw);\n\t\tif (provider->set)\n\t\t\tprovider->set(node, node);\n\t}\n\n\tnode->avg_bw = 0;\n\tnode->peak_bw = 0;\n\n\tmutex_unlock(&icc_bw_lock);\n\tmutex_unlock(&icc_lock);\n}\nEXPORT_SYMBOL_GPL(icc_node_add);\n\n \nvoid icc_node_del(struct icc_node *node)\n{\n\tmutex_lock(&icc_lock);\n\n\tlist_del(&node->node_list);\n\n\tmutex_unlock(&icc_lock);\n}\nEXPORT_SYMBOL_GPL(icc_node_del);\n\n \nint icc_nodes_remove(struct icc_provider *provider)\n{\n\tstruct icc_node *n, *tmp;\n\n\tif (WARN_ON(IS_ERR_OR_NULL(provider)))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry_safe_reverse(n, tmp, &provider->nodes, node_list) {\n\t\ticc_node_del(n);\n\t\ticc_node_destroy(n->id);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(icc_nodes_remove);\n\n \nvoid icc_provider_init(struct icc_provider *provider)\n{\n\tWARN_ON(!provider->set);\n\n\tINIT_LIST_HEAD(&provider->nodes);\n}\nEXPORT_SYMBOL_GPL(icc_provider_init);\n\n \nint icc_provider_register(struct icc_provider *provider)\n{\n\tif (WARN_ON(!provider->xlate && !provider->xlate_extended))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&icc_lock);\n\tlist_add_tail(&provider->provider_list, &icc_providers);\n\tmutex_unlock(&icc_lock);\n\n\tdev_dbg(provider->dev, \"interconnect provider registered\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(icc_provider_register);\n\n \nvoid icc_provider_deregister(struct icc_provider *provider)\n{\n\tmutex_lock(&icc_lock);\n\tWARN_ON(provider->users);\n\n\tlist_del(&provider->provider_list);\n\tmutex_unlock(&icc_lock);\n}\nEXPORT_SYMBOL_GPL(icc_provider_deregister);\n\nstatic const struct of_device_id __maybe_unused ignore_list[] = {\n\t{ .compatible = \"qcom,sc7180-ipa-virt\" },\n\t{ .compatible = \"qcom,sc8180x-ipa-virt\" },\n\t{ .compatible = \"qcom,sdx55-ipa-virt\" },\n\t{ .compatible = \"qcom,sm8150-ipa-virt\" },\n\t{ .compatible = \"qcom,sm8250-ipa-virt\" },\n\t{}\n};\n\nstatic int of_count_icc_providers(struct device_node *np)\n{\n\tstruct device_node *child;\n\tint count = 0;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tif (of_property_read_bool(child, \"#interconnect-cells\") &&\n\t\t    likely(!of_match_node(ignore_list, child)))\n\t\t\tcount++;\n\t\tcount += of_count_icc_providers(child);\n\t}\n\n\treturn count;\n}\n\nvoid icc_sync_state(struct device *dev)\n{\n\tstruct icc_provider *p;\n\tstruct icc_node *n;\n\tstatic int count;\n\n\tcount++;\n\n\tif (count < providers_count)\n\t\treturn;\n\n\tmutex_lock(&icc_lock);\n\tmutex_lock(&icc_bw_lock);\n\tsynced_state = true;\n\tlist_for_each_entry(p, &icc_providers, provider_list) {\n\t\tdev_dbg(p->dev, \"interconnect provider is in synced state\\n\");\n\t\tlist_for_each_entry(n, &p->nodes, node_list) {\n\t\t\tif (n->init_avg || n->init_peak) {\n\t\t\t\tn->init_avg = 0;\n\t\t\t\tn->init_peak = 0;\n\t\t\t\taggregate_requests(n);\n\t\t\t\tp->set(n, n);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&icc_bw_lock);\n\tmutex_unlock(&icc_lock);\n}\nEXPORT_SYMBOL_GPL(icc_sync_state);\n\nstatic int __init icc_init(void)\n{\n\tstruct device_node *root;\n\n\t \n\tfs_reclaim_acquire(GFP_KERNEL);\n\tmight_lock(&icc_bw_lock);\n\tfs_reclaim_release(GFP_KERNEL);\n\n\troot = of_find_node_by_path(\"/\");\n\n\tproviders_count = of_count_icc_providers(root);\n\tof_node_put(root);\n\n\ticc_debugfs_dir = debugfs_create_dir(\"interconnect\", NULL);\n\tdebugfs_create_file(\"interconnect_summary\", 0444,\n\t\t\t    icc_debugfs_dir, NULL, &icc_summary_fops);\n\tdebugfs_create_file(\"interconnect_graph\", 0444,\n\t\t\t    icc_debugfs_dir, NULL, &icc_graph_fops);\n\n\ticc_debugfs_client_init(icc_debugfs_dir);\n\n\treturn 0;\n}\n\ndevice_initcall(icc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}