{
  "module_name": "bulk.c",
  "hash_id": "b5e4ca8728a4ffb826a8bb3029387115020a202f7634bf40bb2eb5daacbfe5a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/interconnect/bulk.c",
  "human_readable_source": "\n\n#include <linux/interconnect-provider.h>\n#include <linux/device.h>\n#include <linux/export.h>\n\n \nint __must_check of_icc_bulk_get(struct device *dev, int num_paths,\n\t\t\t\t struct icc_bulk_data *paths)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < num_paths; i++) {\n\t\tpaths[i].path = of_icc_get(dev, paths[i].name);\n\t\tif (IS_ERR(paths[i].path)) {\n\t\t\tret = PTR_ERR(paths[i].path);\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"of_icc_get() failed on path %s (%d)\\n\",\n\t\t\t\t\tpaths[i].name, ret);\n\t\t\tpaths[i].path = NULL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\ticc_bulk_put(i, paths);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_icc_bulk_get);\n\n \nvoid icc_bulk_put(int num_paths, struct icc_bulk_data *paths)\n{\n\twhile (--num_paths >= 0) {\n\t\ticc_put(paths[num_paths].path);\n\t\tpaths[num_paths].path = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(icc_bulk_put);\n\n \nint icc_bulk_set_bw(int num_paths, const struct icc_bulk_data *paths)\n{\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < num_paths; i++) {\n\t\tret = icc_set_bw(paths[i].path, paths[i].avg_bw, paths[i].peak_bw);\n\t\tif (ret) {\n\t\t\tpr_err(\"icc_set_bw() failed on path %s (%d)\\n\", paths[i].name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(icc_bulk_set_bw);\n\n \nint icc_bulk_enable(int num_paths, const struct icc_bulk_data *paths)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < num_paths; i++) {\n\t\tret = icc_enable(paths[i].path);\n\t\tif (ret) {\n\t\t\tpr_err(\"icc_enable() failed on path %s (%d)\\n\", paths[i].name, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\ticc_bulk_disable(i, paths);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(icc_bulk_enable);\n\n \nvoid icc_bulk_disable(int num_paths, const struct icc_bulk_data *paths)\n{\n\twhile (--num_paths >= 0)\n\t\ticc_disable(paths[num_paths].path);\n}\nEXPORT_SYMBOL_GPL(icc_bulk_disable);\n\nstruct icc_bulk_devres {\n\tstruct icc_bulk_data *paths;\n\tint num_paths;\n};\n\nstatic void devm_icc_bulk_release(struct device *dev, void *res)\n{\n\tstruct icc_bulk_devres *devres = res;\n\n\ticc_bulk_put(devres->num_paths, devres->paths);\n}\n\n \nint devm_of_icc_bulk_get(struct device *dev, int num_paths, struct icc_bulk_data *paths)\n{\n\tstruct icc_bulk_devres *devres;\n\tint ret;\n\n\tdevres = devres_alloc(devm_icc_bulk_release, sizeof(*devres), GFP_KERNEL);\n\tif (!devres)\n\t\treturn -ENOMEM;\n\n\tret = of_icc_bulk_get(dev, num_paths, paths);\n\tif (!ret) {\n\t\tdevres->paths = paths;\n\t\tdevres->num_paths = num_paths;\n\t\tdevres_add(dev, devres);\n\t} else {\n\t\tdevres_free(devres);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_of_icc_bulk_get);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}