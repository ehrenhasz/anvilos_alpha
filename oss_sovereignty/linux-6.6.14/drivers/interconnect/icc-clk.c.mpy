{
  "module_name": "icc-clk.c",
  "hash_id": "ae889ad0461c6abb5612af93eb0b142cf738c88c9b015f52869ef15210165d4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/interconnect/icc-clk.c",
  "human_readable_source": " \n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/interconnect-clk.h>\n#include <linux/interconnect-provider.h>\n\nstruct icc_clk_node {\n\tstruct clk *clk;\n\tbool enabled;\n};\n\nstruct icc_clk_provider {\n\tstruct icc_provider provider;\n\tint num_clocks;\n\tstruct icc_clk_node clocks[] __counted_by(num_clocks);\n};\n\n#define to_icc_clk_provider(_provider) \\\n\tcontainer_of(_provider, struct icc_clk_provider, provider)\n\nstatic int icc_clk_set(struct icc_node *src, struct icc_node *dst)\n{\n\tstruct icc_clk_node *qn = src->data;\n\tint ret;\n\n\tif (!qn || !qn->clk)\n\t\treturn 0;\n\n\tif (!src->peak_bw) {\n\t\tif (qn->enabled)\n\t\t\tclk_disable_unprepare(qn->clk);\n\t\tqn->enabled = false;\n\n\t\treturn 0;\n\t}\n\n\tif (!qn->enabled) {\n\t\tret = clk_prepare_enable(qn->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tqn->enabled = true;\n\t}\n\n\treturn clk_set_rate(qn->clk, icc_units_to_bps(src->peak_bw));\n}\n\nstatic int icc_clk_get_bw(struct icc_node *node, u32 *avg, u32 *peak)\n{\n\tstruct icc_clk_node *qn = node->data;\n\n\tif (!qn || !qn->clk)\n\t\t*peak = INT_MAX;\n\telse\n\t\t*peak = Bps_to_icc(clk_get_rate(qn->clk));\n\n\treturn 0;\n}\n\n \nstruct icc_provider *icc_clk_register(struct device *dev,\n\t\t\t\t      unsigned int first_id,\n\t\t\t\t      unsigned int num_clocks,\n\t\t\t\t      const struct icc_clk_data *data)\n{\n\tstruct icc_clk_provider *qp;\n\tstruct icc_provider *provider;\n\tstruct icc_onecell_data *onecell;\n\tstruct icc_node *node;\n\tint ret, i, j;\n\n\tonecell = devm_kzalloc(dev, struct_size(onecell, nodes, 2 * num_clocks), GFP_KERNEL);\n\tif (!onecell)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqp = devm_kzalloc(dev, struct_size(qp, clocks, num_clocks), GFP_KERNEL);\n\tif (!qp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqp->num_clocks = num_clocks;\n\n\tprovider = &qp->provider;\n\tprovider->dev = dev;\n\tprovider->get_bw = icc_clk_get_bw;\n\tprovider->set = icc_clk_set;\n\tprovider->aggregate = icc_std_aggregate;\n\tprovider->xlate = of_icc_xlate_onecell;\n\tINIT_LIST_HEAD(&provider->nodes);\n\tprovider->data = onecell;\n\n\ticc_provider_init(provider);\n\n\tfor (i = 0, j = 0; i < num_clocks; i++) {\n\t\tqp->clocks[i].clk = data[i].clk;\n\n\t\tnode = icc_node_create(first_id + j);\n\t\tif (IS_ERR(node)) {\n\t\t\tret = PTR_ERR(node);\n\t\t\tgoto err;\n\t\t}\n\n\t\tnode->name = devm_kasprintf(dev, GFP_KERNEL, \"%s_master\", data[i].name);\n\t\tnode->data = &qp->clocks[i];\n\t\ticc_node_add(node, provider);\n\t\t \n\t\ticc_link_create(node, first_id + j + 1);\n\t\tonecell->nodes[j++] = node;\n\n\t\tnode = icc_node_create(first_id + j);\n\t\tif (IS_ERR(node)) {\n\t\t\tret = PTR_ERR(node);\n\t\t\tgoto err;\n\t\t}\n\n\t\tnode->name = devm_kasprintf(dev, GFP_KERNEL, \"%s_slave\", data[i].name);\n\t\t \n\t\ticc_node_add(node, provider);\n\t\tonecell->nodes[j++] = node;\n\t}\n\n\tonecell->num_nodes = j;\n\n\tret = icc_provider_register(provider);\n\tif (ret)\n\t\tgoto err;\n\n\treturn provider;\n\nerr:\n\ticc_nodes_remove(provider);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(icc_clk_register);\n\n \nvoid icc_clk_unregister(struct icc_provider *provider)\n{\n\tstruct icc_clk_provider *qp = container_of(provider, struct icc_clk_provider, provider);\n\tint i;\n\n\ticc_provider_deregister(&qp->provider);\n\ticc_nodes_remove(&qp->provider);\n\n\tfor (i = 0; i < qp->num_clocks; i++) {\n\t\tstruct icc_clk_node *qn = &qp->clocks[i];\n\n\t\tif (qn->enabled)\n\t\t\tclk_disable_unprepare(qn->clk);\n\t}\n}\nEXPORT_SYMBOL_GPL(icc_clk_unregister);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Interconnect wrapper for clocks\");\nMODULE_AUTHOR(\"Dmitry Baryshkov <dmitry.baryshkov@linaro.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}