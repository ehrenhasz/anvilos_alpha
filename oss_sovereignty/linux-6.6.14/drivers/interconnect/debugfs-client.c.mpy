{
  "module_name": "debugfs-client.c",
  "hash_id": "8a5b7cb7a4fccee7ff67a41ca9ed28163194bb80a3d09e9c3f51d7a471ef3c02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/interconnect/debugfs-client.c",
  "human_readable_source": "\n \n#include <linux/debugfs.h>\n#include <linux/interconnect.h>\n#include <linux/platform_device.h>\n\n#include \"internal.h\"\n\n \n#undef INTERCONNECT_ALLOW_WRITE_DEBUGFS\n\n#if defined(INTERCONNECT_ALLOW_WRITE_DEBUGFS) && defined(CONFIG_DEBUG_FS)\n\nstatic LIST_HEAD(debugfs_paths);\nstatic DEFINE_MUTEX(debugfs_lock);\n\nstatic struct platform_device *pdev;\nstatic struct icc_path *cur_path;\n\nstatic char *src_node;\nstatic char *dst_node;\nstatic u32 avg_bw;\nstatic u32 peak_bw;\nstatic u32 tag;\n\nstruct debugfs_path {\n\tconst char *src;\n\tconst char *dst;\n\tstruct icc_path *path;\n\tstruct list_head list;\n};\n\nstatic struct icc_path *get_path(const char *src, const char *dst)\n{\n\tstruct debugfs_path *path;\n\n\tlist_for_each_entry(path, &debugfs_paths, list) {\n\t\tif (!strcmp(path->src, src) && !strcmp(path->dst, dst))\n\t\t\treturn path->path;\n\t}\n\n\treturn NULL;\n}\n\nstatic int icc_get_set(void *data, u64 val)\n{\n\tstruct debugfs_path *debugfs_path;\n\tchar *src, *dst;\n\tint ret = 0;\n\n\tmutex_lock(&debugfs_lock);\n\n\trcu_read_lock();\n\tsrc = rcu_dereference(src_node);\n\tdst = rcu_dereference(dst_node);\n\n\t \n\tcur_path = get_path(src, dst);\n\tif (cur_path) {\n\t\trcu_read_unlock();\n\t\tgoto out;\n\t}\n\n\tsrc = kstrdup(src, GFP_ATOMIC);\n\tdst = kstrdup(dst, GFP_ATOMIC);\n\trcu_read_unlock();\n\n\tif (!src || !dst) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tcur_path = icc_get(&pdev->dev, src, dst);\n\tif (IS_ERR(cur_path)) {\n\t\tret = PTR_ERR(cur_path);\n\t\tgoto err_free;\n\t}\n\n\tdebugfs_path = kzalloc(sizeof(*debugfs_path), GFP_KERNEL);\n\tif (!debugfs_path) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put;\n\t}\n\n\tdebugfs_path->path = cur_path;\n\tdebugfs_path->src = src;\n\tdebugfs_path->dst = dst;\n\tlist_add_tail(&debugfs_path->list, &debugfs_paths);\n\n\tgoto out;\n\nerr_put:\n\ticc_put(cur_path);\nerr_free:\n\tkfree(src);\n\tkfree(dst);\nout:\n\tmutex_unlock(&debugfs_lock);\n\treturn ret;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(icc_get_fops, NULL, icc_get_set, \"%llu\\n\");\n\nstatic int icc_commit_set(void *data, u64 val)\n{\n\tint ret;\n\n\tmutex_lock(&debugfs_lock);\n\n\tif (IS_ERR_OR_NULL(cur_path)) {\n\t\tret = PTR_ERR(cur_path);\n\t\tgoto out;\n\t}\n\n\ticc_set_tag(cur_path, tag);\n\tret = icc_set_bw(cur_path, avg_bw, peak_bw);\nout:\n\tmutex_unlock(&debugfs_lock);\n\treturn ret;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(icc_commit_fops, NULL, icc_commit_set, \"%llu\\n\");\n\nint icc_debugfs_client_init(struct dentry *icc_dir)\n{\n\tstruct dentry *client_dir;\n\tint ret;\n\n\tpdev = platform_device_alloc(\"icc-debugfs-client\", PLATFORM_DEVID_NONE);\n\n\tret = platform_device_add(pdev);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to add platform device: %d\\n\", __func__, ret);\n\t\tplatform_device_put(pdev);\n\t\treturn ret;\n\t}\n\n\tclient_dir = debugfs_create_dir(\"test_client\", icc_dir);\n\n\tdebugfs_create_str(\"src_node\", 0600, client_dir, &src_node);\n\tdebugfs_create_str(\"dst_node\", 0600, client_dir, &dst_node);\n\tdebugfs_create_file(\"get\", 0200, client_dir, NULL, &icc_get_fops);\n\tdebugfs_create_u32(\"avg_bw\", 0600, client_dir, &avg_bw);\n\tdebugfs_create_u32(\"peak_bw\", 0600, client_dir, &peak_bw);\n\tdebugfs_create_u32(\"tag\", 0600, client_dir, &tag);\n\tdebugfs_create_file(\"commit\", 0200, client_dir, NULL, &icc_commit_fops);\n\n\treturn 0;\n}\n\n#else\n\nint icc_debugfs_client_init(struct dentry *icc_dir)\n{\n\treturn 0;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}