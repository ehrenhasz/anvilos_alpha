{
  "module_name": "extcon-adc-jack.c",
  "hash_id": "895eac6e38999c018639496d3d9da99803131af00dd121889a77d0da6036dd7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-adc-jack.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/iio/consumer.h>\n#include <linux/extcon/extcon-adc-jack.h>\n#include <linux/extcon-provider.h>\n\n \nstruct adc_jack_data {\n\tstruct device *dev;\n\tstruct extcon_dev *edev;\n\n\tconst unsigned int **cable_names;\n\tstruct adc_jack_cond *adc_conditions;\n\tint num_conditions;\n\n\tint irq;\n\tunsigned long handling_delay;  \n\tstruct delayed_work handler;\n\n\tstruct iio_channel *chan;\n\tbool wakeup_source;\n};\n\nstatic void adc_jack_handler(struct work_struct *work)\n{\n\tstruct adc_jack_data *data = container_of(to_delayed_work(work),\n\t\t\tstruct adc_jack_data,\n\t\t\thandler);\n\tstruct adc_jack_cond *def;\n\tint ret, adc_val;\n\tint i;\n\n\tret = iio_read_channel_raw(data->chan, &adc_val);\n\tif (ret < 0) {\n\t\tdev_err(data->dev, \"read channel() error: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < data->num_conditions; i++) {\n\t\tdef = &data->adc_conditions[i];\n\t\tif (def->min_adc <= adc_val && def->max_adc >= adc_val) {\n\t\t\textcon_set_state_sync(data->edev, def->id, true);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < data->num_conditions; i++) {\n\t\tdef = &data->adc_conditions[i];\n\t\textcon_set_state_sync(data->edev, def->id, false);\n\t}\n}\n\nstatic irqreturn_t adc_jack_irq_thread(int irq, void *_data)\n{\n\tstruct adc_jack_data *data = _data;\n\n\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t   &data->handler, data->handling_delay);\n\treturn IRQ_HANDLED;\n}\n\nstatic int adc_jack_probe(struct platform_device *pdev)\n{\n\tstruct adc_jack_data *data;\n\tstruct adc_jack_pdata *pdata = dev_get_platdata(&pdev->dev);\n\tint i, err = 0;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (!pdata->cable_names) {\n\t\tdev_err(&pdev->dev, \"error: cable_names not defined.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata->dev = &pdev->dev;\n\tdata->edev = devm_extcon_dev_allocate(&pdev->dev, pdata->cable_names);\n\tif (IS_ERR(data->edev)) {\n\t\tdev_err(&pdev->dev, \"failed to allocate extcon device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!pdata->adc_conditions) {\n\t\tdev_err(&pdev->dev, \"error: adc_conditions not defined.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdata->adc_conditions = pdata->adc_conditions;\n\n\t \n\tfor (i = 0; data->adc_conditions[i].id != EXTCON_NONE; i++);\n\tdata->num_conditions = i;\n\n\tdata->chan = devm_iio_channel_get(&pdev->dev, pdata->consumer_channel);\n\tif (IS_ERR(data->chan))\n\t\treturn PTR_ERR(data->chan);\n\n\tdata->handling_delay = msecs_to_jiffies(pdata->handling_delay_ms);\n\tdata->wakeup_source = pdata->wakeup_source;\n\n\tINIT_DEFERRABLE_WORK(&data->handler, adc_jack_handler);\n\n\tplatform_set_drvdata(pdev, data);\n\n\terr = devm_extcon_dev_register(&pdev->dev, data->edev);\n\tif (err)\n\t\treturn err;\n\n\tdata->irq = platform_get_irq(pdev, 0);\n\tif (data->irq < 0)\n\t\treturn -ENODEV;\n\n\terr = request_any_context_irq(data->irq, adc_jack_irq_thread,\n\t\t\tpdata->irq_flags, pdata->name, data);\n\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"error: irq %d\\n\", data->irq);\n\t\treturn err;\n\t}\n\n\tif (data->wakeup_source)\n\t\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tadc_jack_handler(&data->handler.work);\n\treturn 0;\n}\n\nstatic int adc_jack_remove(struct platform_device *pdev)\n{\n\tstruct adc_jack_data *data = platform_get_drvdata(pdev);\n\n\tfree_irq(data->irq, data);\n\tcancel_work_sync(&data->handler.work);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int adc_jack_suspend(struct device *dev)\n{\n\tstruct adc_jack_data *data = dev_get_drvdata(dev);\n\n\tcancel_delayed_work_sync(&data->handler);\n\tif (device_may_wakeup(data->dev))\n\t\tenable_irq_wake(data->irq);\n\n\treturn 0;\n}\n\nstatic int adc_jack_resume(struct device *dev)\n{\n\tstruct adc_jack_data *data = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(data->dev))\n\t\tdisable_irq_wake(data->irq);\n\n\treturn 0;\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(adc_jack_pm_ops,\n\t\tadc_jack_suspend, adc_jack_resume);\n\nstatic struct platform_driver adc_jack_driver = {\n\t.probe          = adc_jack_probe,\n\t.remove         = adc_jack_remove,\n\t.driver         = {\n\t\t.name   = \"adc-jack\",\n\t\t.pm = &adc_jack_pm_ops,\n\t},\n};\n\nmodule_platform_driver(adc_jack_driver);\n\nMODULE_AUTHOR(\"MyungJoo Ham <myungjoo.ham@samsung.com>\");\nMODULE_DESCRIPTION(\"ADC Jack extcon driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}