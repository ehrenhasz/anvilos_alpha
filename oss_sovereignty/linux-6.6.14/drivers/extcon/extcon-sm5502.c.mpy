{
  "module_name": "extcon-sm5502.c",
  "hash_id": "4798a698f3c2759a21486ba160b2b4ecaea982953a886ab716466d8759bd8c4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-sm5502.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/extcon-provider.h>\n\n#include \"extcon-sm5502.h\"\n\n#define\tDELAY_MS_DEFAULT\t\t17000\t \n\nstruct muic_irq {\n\tunsigned int irq;\n\tconst char *name;\n\tunsigned int virq;\n};\n\nstruct reg_data {\n\tu8 reg;\n\tunsigned int val;\n\tbool invert;\n};\n\nstruct sm5502_muic_info {\n\tstruct device *dev;\n\tstruct extcon_dev *edev;\n\n\tstruct i2c_client *i2c;\n\tstruct regmap *regmap;\n\n\tconst struct sm5502_type *type;\n\tstruct regmap_irq_chip_data *irq_data;\n\tint irq;\n\tbool irq_attach;\n\tbool irq_detach;\n\tstruct work_struct irq_work;\n\n\tstruct mutex mutex;\n\n\t \n\tstruct delayed_work wq_detcable;\n};\n\nstruct sm5502_type {\n\tstruct muic_irq *muic_irqs;\n\tunsigned int num_muic_irqs;\n\tconst struct regmap_irq_chip *irq_chip;\n\n\tstruct reg_data *reg_data;\n\tunsigned int num_reg_data;\n\n\tunsigned int otg_dev_type1;\n\tint (*parse_irq)(struct sm5502_muic_info *info, int irq_type);\n};\n\n \nstatic struct reg_data sm5502_reg_data[] = {\n\t{\n\t\t.reg = SM5502_REG_RESET,\n\t\t.val = SM5502_REG_RESET_MASK,\n\t\t.invert = true,\n\t}, {\n\t\t.reg = SM5502_REG_CONTROL,\n\t\t.val = SM5502_REG_CONTROL_MASK_INT_MASK,\n\t\t.invert = false,\n\t}, {\n\t\t.reg = SM5502_REG_INTMASK1,\n\t\t.val = SM5502_REG_INTM1_KP_MASK\n\t\t\t| SM5502_REG_INTM1_LKP_MASK\n\t\t\t| SM5502_REG_INTM1_LKR_MASK,\n\t\t.invert = true,\n\t}, {\n\t\t.reg = SM5502_REG_INTMASK2,\n\t\t.val = SM5502_REG_INTM2_VBUS_DET_MASK\n\t\t\t| SM5502_REG_INTM2_REV_ACCE_MASK\n\t\t\t| SM5502_REG_INTM2_ADC_CHG_MASK\n\t\t\t| SM5502_REG_INTM2_STUCK_KEY_MASK\n\t\t\t| SM5502_REG_INTM2_STUCK_KEY_RCV_MASK\n\t\t\t| SM5502_REG_INTM2_MHL_MASK,\n\t\t.invert = true,\n\t},\n};\n\n \nstatic struct reg_data sm5504_reg_data[] = {\n\t{\n\t\t.reg = SM5502_REG_RESET,\n\t\t.val = SM5502_REG_RESET_MASK,\n\t\t.invert = true,\n\t}, {\n\t\t.reg = SM5502_REG_INTMASK1,\n\t\t.val = SM5504_REG_INTM1_ATTACH_MASK\n\t\t\t| SM5504_REG_INTM1_DETACH_MASK,\n\t\t.invert = false,\n\t}, {\n\t\t.reg = SM5502_REG_INTMASK2,\n\t\t.val = SM5504_REG_INTM2_RID_CHG_MASK\n\t\t\t| SM5504_REG_INTM2_UVLO_MASK\n\t\t\t| SM5504_REG_INTM2_POR_MASK,\n\t\t.invert = true,\n\t}, {\n\t\t.reg = SM5502_REG_CONTROL,\n\t\t.val = SM5502_REG_CONTROL_MANUAL_SW_MASK\n\t\t\t| SM5504_REG_CONTROL_CHGTYP_MASK\n\t\t\t| SM5504_REG_CONTROL_USBCHDEN_MASK\n\t\t\t| SM5504_REG_CONTROL_ADC_EN_MASK,\n\t\t.invert = true,\n\t},\n};\n\n \nstatic const unsigned int sm5502_extcon_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_CHG_USB_SDP,\n\tEXTCON_CHG_USB_DCP,\n\tEXTCON_NONE,\n};\n\n \nenum sm5502_muic_acc_type {\n\tSM5502_MUIC_ADC_GROUND = 0x0,\n\tSM5502_MUIC_ADC_SEND_END_BUTTON,\n\tSM5502_MUIC_ADC_REMOTE_S1_BUTTON,\n\tSM5502_MUIC_ADC_REMOTE_S2_BUTTON,\n\tSM5502_MUIC_ADC_REMOTE_S3_BUTTON,\n\tSM5502_MUIC_ADC_REMOTE_S4_BUTTON,\n\tSM5502_MUIC_ADC_REMOTE_S5_BUTTON,\n\tSM5502_MUIC_ADC_REMOTE_S6_BUTTON,\n\tSM5502_MUIC_ADC_REMOTE_S7_BUTTON,\n\tSM5502_MUIC_ADC_REMOTE_S8_BUTTON,\n\tSM5502_MUIC_ADC_REMOTE_S9_BUTTON,\n\tSM5502_MUIC_ADC_REMOTE_S10_BUTTON,\n\tSM5502_MUIC_ADC_REMOTE_S11_BUTTON,\n\tSM5502_MUIC_ADC_REMOTE_S12_BUTTON,\n\tSM5502_MUIC_ADC_RESERVED_ACC_1,\n\tSM5502_MUIC_ADC_RESERVED_ACC_2,\n\tSM5502_MUIC_ADC_RESERVED_ACC_3,\n\tSM5502_MUIC_ADC_RESERVED_ACC_4,\n\tSM5502_MUIC_ADC_RESERVED_ACC_5,\n\tSM5502_MUIC_ADC_AUDIO_TYPE2,\n\tSM5502_MUIC_ADC_PHONE_POWERED_DEV,\n\tSM5502_MUIC_ADC_TTY_CONVERTER,\n\tSM5502_MUIC_ADC_UART_CABLE,\n\tSM5502_MUIC_ADC_TYPE1_CHARGER,\n\tSM5502_MUIC_ADC_FACTORY_MODE_BOOT_OFF_USB,\n\tSM5502_MUIC_ADC_FACTORY_MODE_BOOT_ON_USB,\n\tSM5502_MUIC_ADC_AUDIO_VIDEO_CABLE,\n\tSM5502_MUIC_ADC_TYPE2_CHARGER,\n\tSM5502_MUIC_ADC_FACTORY_MODE_BOOT_OFF_UART,\n\tSM5502_MUIC_ADC_FACTORY_MODE_BOOT_ON_UART,\n\tSM5502_MUIC_ADC_AUDIO_TYPE1,\n\tSM5502_MUIC_ADC_OPEN = 0x1f,\n\n\t \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n\tSM5502_MUIC_ADC_AUDIO_TYPE1_FULL_REMOTE = 0x3e,\t \n\tSM5502_MUIC_ADC_AUDIO_TYPE1_SEND_END = 0x5e,\t \n\t\t\t\t\t\t\t \n\tSM5502_MUIC_ADC_GROUND_USB_OTG = 0x80,\t\t \n\tSM5502_MUIC_ADC_OPEN_USB = 0x5f,\t\t \n\tSM5502_MUIC_ADC_OPEN_TA = 0xdf,\t\t\t \n\tSM5502_MUIC_ADC_OPEN_USB_OTG = 0xff,\t\t \n};\n\n \nstatic struct muic_irq sm5502_muic_irqs[] = {\n\t{ SM5502_IRQ_INT1_ATTACH,\t\"muic-attach\" },\n\t{ SM5502_IRQ_INT1_DETACH,\t\"muic-detach\" },\n\t{ SM5502_IRQ_INT1_KP,\t\t\"muic-kp\" },\n\t{ SM5502_IRQ_INT1_LKP,\t\t\"muic-lkp\" },\n\t{ SM5502_IRQ_INT1_LKR,\t\t\"muic-lkr\" },\n\t{ SM5502_IRQ_INT1_OVP_EVENT,\t\"muic-ovp-event\" },\n\t{ SM5502_IRQ_INT1_OCP_EVENT,\t\"muic-ocp-event\" },\n\t{ SM5502_IRQ_INT1_OVP_OCP_DIS,\t\"muic-ovp-ocp-dis\" },\n\t{ SM5502_IRQ_INT2_VBUS_DET,\t\"muic-vbus-det\" },\n\t{ SM5502_IRQ_INT2_REV_ACCE,\t\"muic-rev-acce\" },\n\t{ SM5502_IRQ_INT2_ADC_CHG,\t\"muic-adc-chg\" },\n\t{ SM5502_IRQ_INT2_STUCK_KEY,\t\"muic-stuck-key\" },\n\t{ SM5502_IRQ_INT2_STUCK_KEY_RCV, \"muic-stuck-key-rcv\" },\n\t{ SM5502_IRQ_INT2_MHL,\t\t\"muic-mhl\" },\n};\n\n \nstatic const struct regmap_irq sm5502_irqs[] = {\n\t \n\t{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_ATTACH_MASK, },\n\t{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_DETACH_MASK, },\n\t{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_KP_MASK, },\n\t{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_LKP_MASK, },\n\t{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_LKR_MASK, },\n\t{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_OVP_EVENT_MASK, },\n\t{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_OCP_EVENT_MASK, },\n\t{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_OVP_OCP_DIS_MASK, },\n\n\t \n\t{ .reg_offset = 1, .mask = SM5502_IRQ_INT2_VBUS_DET_MASK,},\n\t{ .reg_offset = 1, .mask = SM5502_IRQ_INT2_REV_ACCE_MASK, },\n\t{ .reg_offset = 1, .mask = SM5502_IRQ_INT2_ADC_CHG_MASK, },\n\t{ .reg_offset = 1, .mask = SM5502_IRQ_INT2_STUCK_KEY_MASK, },\n\t{ .reg_offset = 1, .mask = SM5502_IRQ_INT2_STUCK_KEY_RCV_MASK, },\n\t{ .reg_offset = 1, .mask = SM5502_IRQ_INT2_MHL_MASK, },\n};\n\nstatic const struct regmap_irq_chip sm5502_muic_irq_chip = {\n\t.name\t\t\t= \"sm5502\",\n\t.status_base\t\t= SM5502_REG_INT1,\n\t.mask_base\t\t= SM5502_REG_INTMASK1,\n\t.num_regs\t\t= 2,\n\t.irqs\t\t\t= sm5502_irqs,\n\t.num_irqs\t\t= ARRAY_SIZE(sm5502_irqs),\n};\n\n \nstatic struct muic_irq sm5504_muic_irqs[] = {\n\t{ SM5504_IRQ_INT1_ATTACH,\t\"muic-attach\" },\n\t{ SM5504_IRQ_INT1_DETACH,\t\"muic-detach\" },\n\t{ SM5504_IRQ_INT1_CHG_DET,\t\"muic-chg-det\" },\n\t{ SM5504_IRQ_INT1_DCD_OUT,\t\"muic-dcd-out\" },\n\t{ SM5504_IRQ_INT1_OVP_EVENT,\t\"muic-ovp-event\" },\n\t{ SM5504_IRQ_INT1_CONNECT,\t\"muic-connect\" },\n\t{ SM5504_IRQ_INT1_ADC_CHG,\t\"muic-adc-chg\" },\n\t{ SM5504_IRQ_INT2_RID_CHG,\t\"muic-rid-chg\" },\n\t{ SM5504_IRQ_INT2_UVLO,\t\t\"muic-uvlo\" },\n\t{ SM5504_IRQ_INT2_POR,\t\t\"muic-por\" },\n\t{ SM5504_IRQ_INT2_OVP_FET,\t\"muic-ovp-fet\" },\n\t{ SM5504_IRQ_INT2_OCP_LATCH,\t\"muic-ocp-latch\" },\n\t{ SM5504_IRQ_INT2_OCP_EVENT,\t\"muic-ocp-event\" },\n\t{ SM5504_IRQ_INT2_OVP_OCP_EVENT, \"muic-ovp-ocp-event\" },\n};\n\n \nstatic const struct regmap_irq sm5504_irqs[] = {\n\t \n\t{ .reg_offset = 0, .mask = SM5504_IRQ_INT1_ATTACH_MASK, },\n\t{ .reg_offset = 0, .mask = SM5504_IRQ_INT1_DETACH_MASK, },\n\t{ .reg_offset = 0, .mask = SM5504_IRQ_INT1_CHG_DET_MASK, },\n\t{ .reg_offset = 0, .mask = SM5504_IRQ_INT1_DCD_OUT_MASK, },\n\t{ .reg_offset = 0, .mask = SM5504_IRQ_INT1_OVP_MASK, },\n\t{ .reg_offset = 0, .mask = SM5504_IRQ_INT1_CONNECT_MASK, },\n\t{ .reg_offset = 0, .mask = SM5504_IRQ_INT1_ADC_CHG_MASK, },\n\n\t \n\t{ .reg_offset = 1, .mask = SM5504_IRQ_INT2_RID_CHG_MASK,},\n\t{ .reg_offset = 1, .mask = SM5504_IRQ_INT2_UVLO_MASK, },\n\t{ .reg_offset = 1, .mask = SM5504_IRQ_INT2_POR_MASK, },\n\t{ .reg_offset = 1, .mask = SM5504_IRQ_INT2_OVP_FET_MASK, },\n\t{ .reg_offset = 1, .mask = SM5504_IRQ_INT2_OCP_LATCH_MASK, },\n\t{ .reg_offset = 1, .mask = SM5504_IRQ_INT2_OCP_EVENT_MASK, },\n\t{ .reg_offset = 1, .mask = SM5504_IRQ_INT2_OVP_OCP_EVENT_MASK, },\n};\n\nstatic const struct regmap_irq_chip sm5504_muic_irq_chip = {\n\t.name\t\t\t= \"sm5504\",\n\t.status_base\t\t= SM5502_REG_INT1,\n\t.mask_base\t\t= SM5502_REG_INTMASK1,\n\t.num_regs\t\t= 2,\n\t.irqs\t\t\t= sm5504_irqs,\n\t.num_irqs\t\t= ARRAY_SIZE(sm5504_irqs),\n};\n\n \nstatic bool sm5502_muic_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SM5502_REG_INTMASK1:\n\tcase SM5502_REG_INTMASK2:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic const struct regmap_config sm5502_muic_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.volatile_reg\t= sm5502_muic_volatile_reg,\n\t.max_register\t= SM5502_REG_END,\n};\n\n \nstatic int sm5502_muic_set_path(struct sm5502_muic_info *info,\n\t\t\t\tunsigned int con_sw, unsigned int vbus_sw,\n\t\t\t\tbool attached)\n{\n\tint ret;\n\n\tif (!attached) {\n\t\tcon_sw\t= DM_DP_SWITCH_OPEN;\n\t\tvbus_sw\t= VBUSIN_SWITCH_OPEN;\n\t}\n\n\tswitch (con_sw) {\n\tcase DM_DP_SWITCH_OPEN:\n\tcase DM_DP_SWITCH_USB:\n\tcase DM_DP_SWITCH_AUDIO:\n\tcase DM_DP_SWITCH_UART:\n\t\tret = regmap_update_bits(info->regmap, SM5502_REG_MANUAL_SW1,\n\t\t\t\t\t SM5502_REG_MANUAL_SW1_DP_MASK |\n\t\t\t\t\t SM5502_REG_MANUAL_SW1_DM_MASK,\n\t\t\t\t\t con_sw);\n\t\tif (ret < 0) {\n\t\t\tdev_err(info->dev,\n\t\t\t\t\"cannot update DM_CON/DP_CON switch\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(info->dev, \"Unknown DM_CON/DP_CON switch type (%d)\\n\",\n\t\t\t\tcon_sw);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (vbus_sw) {\n\tcase VBUSIN_SWITCH_OPEN:\n\tcase VBUSIN_SWITCH_VBUSOUT:\n\tcase VBUSIN_SWITCH_MIC:\n\tcase VBUSIN_SWITCH_VBUSOUT_WITH_USB:\n\t\tret = regmap_update_bits(info->regmap, SM5502_REG_MANUAL_SW1,\n\t\t\t\t\t SM5502_REG_MANUAL_SW1_VBUSIN_MASK,\n\t\t\t\t\t vbus_sw);\n\t\tif (ret < 0) {\n\t\t\tdev_err(info->dev,\n\t\t\t\t\"cannot update VBUSIN switch\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(info->dev, \"Unknown VBUS switch type (%d)\\n\", vbus_sw);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic unsigned int sm5502_muic_get_cable_type(struct sm5502_muic_info *info)\n{\n\tunsigned int cable_type, adc, dev_type1;\n\tint ret;\n\n\t \n\tret = regmap_read(info->regmap, SM5502_REG_ADC, &adc);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed to read ADC register\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tcable_type = adc & SM5502_REG_ADC_MASK;\n\n\tswitch (cable_type) {\n\tcase SM5502_MUIC_ADC_GROUND:\n\t\tret = regmap_read(info->regmap, SM5502_REG_DEV_TYPE1,\n\t\t\t\t  &dev_type1);\n\t\tif (ret) {\n\t\t\tdev_err(info->dev, \"failed to read DEV_TYPE1 reg\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (dev_type1 == info->type->otg_dev_type1) {\n\t\t\tcable_type = SM5502_MUIC_ADC_GROUND_USB_OTG;\n\t\t} else {\n\t\t\tdev_dbg(info->dev,\n\t\t\t\t\"cannot identify the cable type: adc(0x%x), dev_type1(0x%x)\\n\",\n\t\t\t\tadc, dev_type1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SM5502_MUIC_ADC_SEND_END_BUTTON:\n\tcase SM5502_MUIC_ADC_REMOTE_S1_BUTTON:\n\tcase SM5502_MUIC_ADC_REMOTE_S2_BUTTON:\n\tcase SM5502_MUIC_ADC_REMOTE_S3_BUTTON:\n\tcase SM5502_MUIC_ADC_REMOTE_S4_BUTTON:\n\tcase SM5502_MUIC_ADC_REMOTE_S5_BUTTON:\n\tcase SM5502_MUIC_ADC_REMOTE_S6_BUTTON:\n\tcase SM5502_MUIC_ADC_REMOTE_S7_BUTTON:\n\tcase SM5502_MUIC_ADC_REMOTE_S8_BUTTON:\n\tcase SM5502_MUIC_ADC_REMOTE_S9_BUTTON:\n\tcase SM5502_MUIC_ADC_REMOTE_S10_BUTTON:\n\tcase SM5502_MUIC_ADC_REMOTE_S11_BUTTON:\n\tcase SM5502_MUIC_ADC_REMOTE_S12_BUTTON:\n\tcase SM5502_MUIC_ADC_RESERVED_ACC_1:\n\tcase SM5502_MUIC_ADC_RESERVED_ACC_2:\n\tcase SM5502_MUIC_ADC_RESERVED_ACC_3:\n\tcase SM5502_MUIC_ADC_RESERVED_ACC_4:\n\tcase SM5502_MUIC_ADC_RESERVED_ACC_5:\n\tcase SM5502_MUIC_ADC_AUDIO_TYPE2:\n\tcase SM5502_MUIC_ADC_PHONE_POWERED_DEV:\n\tcase SM5502_MUIC_ADC_TTY_CONVERTER:\n\tcase SM5502_MUIC_ADC_UART_CABLE:\n\tcase SM5502_MUIC_ADC_TYPE1_CHARGER:\n\tcase SM5502_MUIC_ADC_FACTORY_MODE_BOOT_OFF_USB:\n\tcase SM5502_MUIC_ADC_FACTORY_MODE_BOOT_ON_USB:\n\tcase SM5502_MUIC_ADC_AUDIO_VIDEO_CABLE:\n\tcase SM5502_MUIC_ADC_TYPE2_CHARGER:\n\tcase SM5502_MUIC_ADC_FACTORY_MODE_BOOT_OFF_UART:\n\tcase SM5502_MUIC_ADC_FACTORY_MODE_BOOT_ON_UART:\n\t\tbreak;\n\tcase SM5502_MUIC_ADC_AUDIO_TYPE1:\n\t\t \n\t\tbreak;\n\tcase SM5502_MUIC_ADC_OPEN:\n\t\tret = regmap_read(info->regmap, SM5502_REG_DEV_TYPE1,\n\t\t\t\t  &dev_type1);\n\t\tif (ret) {\n\t\t\tdev_err(info->dev, \"failed to read DEV_TYPE1 reg\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (dev_type1 == info->type->otg_dev_type1) {\n\t\t\tcable_type = SM5502_MUIC_ADC_OPEN_USB_OTG;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (dev_type1) {\n\t\tcase SM5502_REG_DEV_TYPE1_USB_SDP_MASK:\n\t\t\tcable_type = SM5502_MUIC_ADC_OPEN_USB;\n\t\t\tbreak;\n\t\tcase SM5502_REG_DEV_TYPE1_DEDICATED_CHG_MASK:\n\t\t\tcable_type = SM5502_MUIC_ADC_OPEN_TA;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(info->dev,\n\t\t\t\t\"cannot identify the cable type: adc(0x%x)\\n\",\n\t\t\t\tadc);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(info->dev,\n\t\t\t\"failed to identify the cable type: adc(0x%x)\\n\", adc);\n\t\treturn -EINVAL;\n\t}\n\n\treturn cable_type;\n}\n\nstatic int sm5502_muic_cable_handler(struct sm5502_muic_info *info,\n\t\t\t\t     bool attached)\n{\n\tstatic unsigned int prev_cable_type = SM5502_MUIC_ADC_GROUND;\n\tunsigned int cable_type = SM5502_MUIC_ADC_GROUND;\n\tunsigned int con_sw = DM_DP_SWITCH_OPEN;\n\tunsigned int vbus_sw = VBUSIN_SWITCH_OPEN;\n\tunsigned int id;\n\tint ret;\n\n\t \n\tif (attached)\n\t\tcable_type = sm5502_muic_get_cable_type(info);\n\telse\n\t\tcable_type = prev_cable_type;\n\tprev_cable_type = cable_type;\n\n\tswitch (cable_type) {\n\tcase SM5502_MUIC_ADC_OPEN_USB:\n\t\tid\t= EXTCON_USB;\n\t\tcon_sw\t= DM_DP_SWITCH_USB;\n\t\tvbus_sw\t= VBUSIN_SWITCH_VBUSOUT_WITH_USB;\n\t\tbreak;\n\tcase SM5502_MUIC_ADC_OPEN_TA:\n\t\tid\t= EXTCON_CHG_USB_DCP;\n\t\tcon_sw\t= DM_DP_SWITCH_OPEN;\n\t\tvbus_sw\t= VBUSIN_SWITCH_VBUSOUT;\n\t\tbreak;\n\tcase SM5502_MUIC_ADC_GROUND_USB_OTG:\n\tcase SM5502_MUIC_ADC_OPEN_USB_OTG:\n\t\tid\t= EXTCON_USB_HOST;\n\t\tcon_sw\t= DM_DP_SWITCH_USB;\n\t\tvbus_sw\t= VBUSIN_SWITCH_OPEN;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(info->dev,\n\t\t\t\"cannot handle this cable_type (0x%x)\\n\", cable_type);\n\t\treturn 0;\n\t}\n\n\t \n\tret = sm5502_muic_set_path(info, con_sw, vbus_sw, attached);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\textcon_set_state_sync(info->edev, id, attached);\n\tif (id == EXTCON_USB)\n\t\textcon_set_state_sync(info->edev, EXTCON_CHG_USB_SDP,\n\t\t\t\t\tattached);\n\n\treturn 0;\n}\n\nstatic void sm5502_muic_irq_work(struct work_struct *work)\n{\n\tstruct sm5502_muic_info *info = container_of(work,\n\t\t\tstruct sm5502_muic_info, irq_work);\n\tint ret = 0;\n\n\tif (!info->edev)\n\t\treturn;\n\n\tmutex_lock(&info->mutex);\n\n\t \n\tif (info->irq_attach) {\n\t\tret = sm5502_muic_cable_handler(info, true);\n\t\tinfo->irq_attach = false;\n\t}\n\tif (info->irq_detach) {\n\t\tret = sm5502_muic_cable_handler(info, false);\n\t\tinfo->irq_detach = false;\n\t}\n\n\tif (ret < 0)\n\t\tdev_err(info->dev, \"failed to handle MUIC interrupt\\n\");\n\n\tmutex_unlock(&info->mutex);\n}\n\n \nstatic int sm5502_parse_irq(struct sm5502_muic_info *info, int irq_type)\n{\n\tswitch (irq_type) {\n\tcase SM5502_IRQ_INT1_ATTACH:\n\t\tinfo->irq_attach = true;\n\t\tbreak;\n\tcase SM5502_IRQ_INT1_DETACH:\n\t\tinfo->irq_detach = true;\n\t\tbreak;\n\tcase SM5502_IRQ_INT1_KP:\n\tcase SM5502_IRQ_INT1_LKP:\n\tcase SM5502_IRQ_INT1_LKR:\n\tcase SM5502_IRQ_INT1_OVP_EVENT:\n\tcase SM5502_IRQ_INT1_OCP_EVENT:\n\tcase SM5502_IRQ_INT1_OVP_OCP_DIS:\n\tcase SM5502_IRQ_INT2_VBUS_DET:\n\tcase SM5502_IRQ_INT2_REV_ACCE:\n\tcase SM5502_IRQ_INT2_ADC_CHG:\n\tcase SM5502_IRQ_INT2_STUCK_KEY:\n\tcase SM5502_IRQ_INT2_STUCK_KEY_RCV:\n\tcase SM5502_IRQ_INT2_MHL:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int sm5504_parse_irq(struct sm5502_muic_info *info, int irq_type)\n{\n\tswitch (irq_type) {\n\tcase SM5504_IRQ_INT1_ATTACH:\n\t\tinfo->irq_attach = true;\n\t\tbreak;\n\tcase SM5504_IRQ_INT1_DETACH:\n\t\tinfo->irq_detach = true;\n\t\tbreak;\n\tcase SM5504_IRQ_INT1_CHG_DET:\n\tcase SM5504_IRQ_INT1_DCD_OUT:\n\tcase SM5504_IRQ_INT1_OVP_EVENT:\n\tcase SM5504_IRQ_INT1_CONNECT:\n\tcase SM5504_IRQ_INT1_ADC_CHG:\n\tcase SM5504_IRQ_INT2_RID_CHG:\n\tcase SM5504_IRQ_INT2_UVLO:\n\tcase SM5504_IRQ_INT2_POR:\n\tcase SM5504_IRQ_INT2_OVP_FET:\n\tcase SM5504_IRQ_INT2_OCP_LATCH:\n\tcase SM5504_IRQ_INT2_OCP_EVENT:\n\tcase SM5504_IRQ_INT2_OVP_OCP_EVENT:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t sm5502_muic_irq_handler(int irq, void *data)\n{\n\tstruct sm5502_muic_info *info = data;\n\tint i, irq_type = -1, ret;\n\n\tfor (i = 0; i < info->type->num_muic_irqs; i++)\n\t\tif (irq == info->type->muic_irqs[i].virq)\n\t\t\tirq_type = info->type->muic_irqs[i].irq;\n\n\tret = info->type->parse_irq(info, irq_type);\n\tif (ret < 0) {\n\t\tdev_warn(info->dev, \"cannot handle is interrupt:%d\\n\",\n\t\t\t\t    irq_type);\n\t\treturn IRQ_HANDLED;\n\t}\n\tschedule_work(&info->irq_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void sm5502_muic_detect_cable_wq(struct work_struct *work)\n{\n\tstruct sm5502_muic_info *info = container_of(to_delayed_work(work),\n\t\t\t\tstruct sm5502_muic_info, wq_detcable);\n\tint ret;\n\n\t \n\tret = sm5502_muic_cable_handler(info, true);\n\tif (ret < 0)\n\t\tdev_warn(info->dev, \"failed to detect cable state\\n\");\n}\n\nstatic void sm5502_init_dev_type(struct sm5502_muic_info *info)\n{\n\tunsigned int reg_data, vendor_id, version_id;\n\tint i, ret;\n\n\t \n\tret = regmap_read(info->regmap, SM5502_REG_DEVICE_ID, &reg_data);\n\tif (ret) {\n\t\tdev_err(info->dev,\n\t\t\t\"failed to read DEVICE_ID register: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tvendor_id = ((reg_data & SM5502_REG_DEVICE_ID_VENDOR_MASK) >>\n\t\t\t\tSM5502_REG_DEVICE_ID_VENDOR_SHIFT);\n\tversion_id = ((reg_data & SM5502_REG_DEVICE_ID_VERSION_MASK) >>\n\t\t\t\tSM5502_REG_DEVICE_ID_VERSION_SHIFT);\n\n\tdev_info(info->dev, \"Device type: version: 0x%x, vendor: 0x%x\\n\",\n\t\t\t    version_id, vendor_id);\n\n\t \n\tfor (i = 0; i < info->type->num_reg_data; i++) {\n\t\tunsigned int val = 0;\n\n\t\tif (!info->type->reg_data[i].invert)\n\t\t\tval |= ~info->type->reg_data[i].val;\n\t\telse\n\t\t\tval = info->type->reg_data[i].val;\n\t\tregmap_write(info->regmap, info->type->reg_data[i].reg, val);\n\t}\n}\n\nstatic int sm5022_muic_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device_node *np = i2c->dev.of_node;\n\tstruct sm5502_muic_info *info;\n\tint i, ret, irq_flags;\n\n\tif (!np)\n\t\treturn -EINVAL;\n\n\tinfo = devm_kzalloc(&i2c->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\ti2c_set_clientdata(i2c, info);\n\n\tinfo->dev = &i2c->dev;\n\tinfo->i2c = i2c;\n\tinfo->irq = i2c->irq;\n\tinfo->type = device_get_match_data(info->dev);\n\tif (!info->type)\n\t\treturn -EINVAL;\n\tif (!info->type->parse_irq) {\n\t\tdev_err(info->dev, \"parse_irq missing in struct sm5502_type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&info->mutex);\n\n\tINIT_WORK(&info->irq_work, sm5502_muic_irq_work);\n\n\tinfo->regmap = devm_regmap_init_i2c(i2c, &sm5502_muic_regmap_config);\n\tif (IS_ERR(info->regmap)) {\n\t\tret = PTR_ERR(info->regmap);\n\t\tdev_err(info->dev, \"failed to allocate register map: %d\\n\",\n\t\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\t \n\tirq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT | IRQF_SHARED;\n\tret = devm_regmap_add_irq_chip(info->dev, info->regmap, info->irq,\n\t\t\t\t       irq_flags, 0, info->type->irq_chip,\n\t\t\t\t       &info->irq_data);\n\tif (ret != 0) {\n\t\tdev_err(info->dev, \"failed to request IRQ %d: %d\\n\",\n\t\t\t\t    info->irq, ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < info->type->num_muic_irqs; i++) {\n\t\tstruct muic_irq *muic_irq = &info->type->muic_irqs[i];\n\t\tint virq = 0;\n\n\t\tvirq = regmap_irq_get_virq(info->irq_data, muic_irq->irq);\n\t\tif (virq <= 0)\n\t\t\treturn -EINVAL;\n\t\tmuic_irq->virq = virq;\n\n\t\tret = devm_request_threaded_irq(info->dev, virq, NULL,\n\t\t\t\t\t\tsm5502_muic_irq_handler,\n\t\t\t\t\t\tIRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\t\t\t\tmuic_irq->name, info);\n\t\tif (ret) {\n\t\t\tdev_err(info->dev,\n\t\t\t\t\"failed: irq request (IRQ: %d, error :%d)\\n\",\n\t\t\t\tmuic_irq->irq, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tinfo->edev = devm_extcon_dev_allocate(info->dev, sm5502_extcon_cable);\n\tif (IS_ERR(info->edev)) {\n\t\tdev_err(info->dev, \"failed to allocate memory for extcon\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = devm_extcon_dev_register(info->dev, info->edev);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed to register extcon device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tINIT_DELAYED_WORK(&info->wq_detcable, sm5502_muic_detect_cable_wq);\n\tqueue_delayed_work(system_power_efficient_wq, &info->wq_detcable,\n\t\t\tmsecs_to_jiffies(DELAY_MS_DEFAULT));\n\n\t \n\tsm5502_init_dev_type(info);\n\n\treturn 0;\n}\n\nstatic const struct sm5502_type sm5502_data = {\n\t.muic_irqs = sm5502_muic_irqs,\n\t.num_muic_irqs = ARRAY_SIZE(sm5502_muic_irqs),\n\t.irq_chip = &sm5502_muic_irq_chip,\n\t.reg_data = sm5502_reg_data,\n\t.num_reg_data = ARRAY_SIZE(sm5502_reg_data),\n\t.otg_dev_type1 = SM5502_REG_DEV_TYPE1_USB_OTG_MASK,\n\t.parse_irq = sm5502_parse_irq,\n};\n\nstatic const struct sm5502_type sm5504_data = {\n\t.muic_irqs = sm5504_muic_irqs,\n\t.num_muic_irqs = ARRAY_SIZE(sm5504_muic_irqs),\n\t.irq_chip = &sm5504_muic_irq_chip,\n\t.reg_data = sm5504_reg_data,\n\t.num_reg_data = ARRAY_SIZE(sm5504_reg_data),\n\t.otg_dev_type1 = SM5504_REG_DEV_TYPE1_USB_OTG_MASK,\n\t.parse_irq = sm5504_parse_irq,\n};\n\nstatic const struct of_device_id sm5502_dt_match[] = {\n\t{ .compatible = \"siliconmitus,sm5502-muic\", .data = &sm5502_data },\n\t{ .compatible = \"siliconmitus,sm5504-muic\", .data = &sm5504_data },\n\t{ .compatible = \"siliconmitus,sm5703-muic\", .data = &sm5502_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sm5502_dt_match);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sm5502_muic_suspend(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct sm5502_muic_info *info = i2c_get_clientdata(i2c);\n\n\tenable_irq_wake(info->irq);\n\n\treturn 0;\n}\n\nstatic int sm5502_muic_resume(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct sm5502_muic_info *info = i2c_get_clientdata(i2c);\n\n\tdisable_irq_wake(info->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(sm5502_muic_pm_ops,\n\t\t\t sm5502_muic_suspend, sm5502_muic_resume);\n\nstatic const struct i2c_device_id sm5502_i2c_id[] = {\n\t{ \"sm5502\", (kernel_ulong_t)&sm5502_data },\n\t{ \"sm5504\", (kernel_ulong_t)&sm5504_data },\n\t{ \"sm5703-muic\", (kernel_ulong_t)&sm5502_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sm5502_i2c_id);\n\nstatic struct i2c_driver sm5502_muic_i2c_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"sm5502\",\n\t\t.pm\t= &sm5502_muic_pm_ops,\n\t\t.of_match_table = sm5502_dt_match,\n\t},\n\t.probe = sm5022_muic_i2c_probe,\n\t.id_table = sm5502_i2c_id,\n};\n\nstatic int __init sm5502_muic_i2c_init(void)\n{\n\treturn i2c_add_driver(&sm5502_muic_i2c_driver);\n}\nsubsys_initcall(sm5502_muic_i2c_init);\n\nMODULE_DESCRIPTION(\"Silicon Mitus SM5502 Extcon driver\");\nMODULE_AUTHOR(\"Chanwoo Choi <cw00.choi@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}