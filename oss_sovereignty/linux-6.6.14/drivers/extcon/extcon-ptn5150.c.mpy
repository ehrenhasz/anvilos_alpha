{
  "module_name": "extcon-ptn5150.c",
  "hash_id": "aeee2fc35a5becbf6aa7bc21532fc6a5a9cf11bac90dcfa921e9dd4bba13145f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-ptn5150.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/extcon-provider.h>\n#include <linux/gpio/consumer.h>\n#include <linux/usb/role.h>\n\n \n#define PTN5150_REG_DEVICE_ID\t\t\t0x01\n#define PTN5150_REG_CONTROL\t\t\t0x02\n#define PTN5150_REG_INT_STATUS\t\t\t0x03\n#define PTN5150_REG_CC_STATUS\t\t\t0x04\n#define PTN5150_REG_CON_DET\t\t\t0x09\n#define PTN5150_REG_VCONN_STATUS\t\t0x0a\n#define PTN5150_REG_RESET\t\t\t0x0b\n#define PTN5150_REG_INT_MASK\t\t\t0x18\n#define PTN5150_REG_INT_REG_STATUS\t\t0x19\n#define PTN5150_REG_END\t\t\t\tPTN5150_REG_INT_REG_STATUS\n\n#define PTN5150_DFP_ATTACHED\t\t\t0x1\n#define PTN5150_UFP_ATTACHED\t\t\t0x2\n\n \n#define PTN5150_REG_DEVICE_ID_VERSION\t\tGENMASK(7, 3)\n#define PTN5150_REG_DEVICE_ID_VENDOR\t\tGENMASK(2, 0)\n\n#define PTN5150_REG_CC_PORT_ATTACHMENT\t\tGENMASK(4, 2)\n#define PTN5150_REG_CC_VBUS_DETECTION\t\tBIT(7)\n#define PTN5150_REG_INT_CABLE_ATTACH_MASK\tBIT(0)\n#define PTN5150_REG_INT_CABLE_DETACH_MASK\tBIT(1)\n\nstruct ptn5150_info {\n\tstruct device *dev;\n\tstruct extcon_dev *edev;\n\tstruct i2c_client *i2c;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *int_gpiod;\n\tstruct gpio_desc *vbus_gpiod;\n\tint irq;\n\tstruct work_struct irq_work;\n\tstruct mutex mutex;\n\tstruct usb_role_switch *role_sw;\n};\n\n \nstatic const unsigned int ptn5150_extcon_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_NONE,\n};\n\nstatic const struct regmap_config ptn5150_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= PTN5150_REG_END,\n};\n\nstatic void ptn5150_check_state(struct ptn5150_info *info)\n{\n\tunsigned int port_status, reg_data, vbus;\n\tenum usb_role usb_role = USB_ROLE_NONE;\n\tint ret;\n\n\tret = regmap_read(info->regmap, PTN5150_REG_CC_STATUS, &reg_data);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed to read CC STATUS %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tport_status = FIELD_GET(PTN5150_REG_CC_PORT_ATTACHMENT, reg_data);\n\n\tswitch (port_status) {\n\tcase PTN5150_DFP_ATTACHED:\n\t\textcon_set_state_sync(info->edev, EXTCON_USB_HOST, false);\n\t\tgpiod_set_value_cansleep(info->vbus_gpiod, 0);\n\t\textcon_set_state_sync(info->edev, EXTCON_USB, true);\n\t\tusb_role = USB_ROLE_DEVICE;\n\t\tbreak;\n\tcase PTN5150_UFP_ATTACHED:\n\t\textcon_set_state_sync(info->edev, EXTCON_USB, false);\n\t\tvbus = FIELD_GET(PTN5150_REG_CC_VBUS_DETECTION, reg_data);\n\t\tif (vbus)\n\t\t\tgpiod_set_value_cansleep(info->vbus_gpiod, 0);\n\t\telse\n\t\t\tgpiod_set_value_cansleep(info->vbus_gpiod, 1);\n\n\t\textcon_set_state_sync(info->edev, EXTCON_USB_HOST, true);\n\t\tusb_role = USB_ROLE_HOST;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (usb_role) {\n\t\tret = usb_role_switch_set_role(info->role_sw, usb_role);\n\t\tif (ret)\n\t\t\tdev_err(info->dev, \"failed to set %s role: %d\\n\",\n\t\t\t\tusb_role_string(usb_role), ret);\n\t}\n}\n\nstatic void ptn5150_irq_work(struct work_struct *work)\n{\n\tstruct ptn5150_info *info = container_of(work,\n\t\t\tstruct ptn5150_info, irq_work);\n\tint ret = 0;\n\tunsigned int int_status;\n\n\tif (!info->edev)\n\t\treturn;\n\n\tmutex_lock(&info->mutex);\n\n\t \n\tret = regmap_read(info->regmap, PTN5150_REG_INT_STATUS, &int_status);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed to read INT STATUS %d\\n\", ret);\n\t\tmutex_unlock(&info->mutex);\n\t\treturn;\n\t}\n\n\tif (int_status) {\n\t\tunsigned int cable_attach;\n\n\t\tcable_attach = int_status & PTN5150_REG_INT_CABLE_ATTACH_MASK;\n\t\tif (cable_attach) {\n\t\t\tptn5150_check_state(info);\n\t\t} else {\n\t\t\textcon_set_state_sync(info->edev,\n\t\t\t\t\tEXTCON_USB_HOST, false);\n\t\t\textcon_set_state_sync(info->edev,\n\t\t\t\t\tEXTCON_USB, false);\n\t\t\tgpiod_set_value_cansleep(info->vbus_gpiod, 0);\n\n\t\t\tret = usb_role_switch_set_role(info->role_sw,\n\t\t\t\t\t\t       USB_ROLE_NONE);\n\t\t\tif (ret)\n\t\t\t\tdev_err(info->dev,\n\t\t\t\t\t\"failed to set none role: %d\\n\",\n\t\t\t\t\tret);\n\t\t}\n\t}\n\n\t \n\tret = regmap_read(info->regmap, PTN5150_REG_INT_REG_STATUS,\n\t\t\t&int_status);\n\tif (ret) {\n\t\tdev_err(info->dev,\n\t\t\t\"failed to read INT REG STATUS %d\\n\", ret);\n\t\tmutex_unlock(&info->mutex);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&info->mutex);\n}\n\n\nstatic irqreturn_t ptn5150_irq_handler(int irq, void *data)\n{\n\tstruct ptn5150_info *info = data;\n\n\tschedule_work(&info->irq_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ptn5150_init_dev_type(struct ptn5150_info *info)\n{\n\tunsigned int reg_data, vendor_id, version_id;\n\tint ret;\n\n\tret = regmap_read(info->regmap, PTN5150_REG_DEVICE_ID, &reg_data);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed to read DEVICE_ID %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tvendor_id = FIELD_GET(PTN5150_REG_DEVICE_ID_VENDOR, reg_data);\n\tversion_id = FIELD_GET(PTN5150_REG_DEVICE_ID_VERSION, reg_data);\n\tdev_dbg(info->dev, \"Device type: version: 0x%x, vendor: 0x%x\\n\",\n\t\tversion_id, vendor_id);\n\n\t \n\tret = regmap_read(info->regmap, PTN5150_REG_INT_STATUS, &reg_data);\n\tif (ret) {\n\t\tdev_err(info->dev,\n\t\t\t\"failed to read PTN5150_REG_INT_STATUS %d\\n\",\n\t\t\tret);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_read(info->regmap, PTN5150_REG_INT_REG_STATUS, &reg_data);\n\tif (ret) {\n\t\tdev_err(info->dev,\n\t\t\t\"failed to read PTN5150_REG_INT_REG_STATUS %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void ptn5150_work_sync_and_put(void *data)\n{\n\tstruct ptn5150_info *info = data;\n\n\tcancel_work_sync(&info->irq_work);\n\tusb_role_switch_put(info->role_sw);\n}\n\nstatic int ptn5150_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct device_node *np = i2c->dev.of_node;\n\tstruct ptn5150_info *info;\n\tint ret;\n\n\tif (!np)\n\t\treturn -EINVAL;\n\n\tinfo = devm_kzalloc(&i2c->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\ti2c_set_clientdata(i2c, info);\n\n\tinfo->dev = &i2c->dev;\n\tinfo->i2c = i2c;\n\tinfo->vbus_gpiod = devm_gpiod_get(&i2c->dev, \"vbus\", GPIOD_OUT_LOW);\n\tif (IS_ERR(info->vbus_gpiod)) {\n\t\tret = PTR_ERR(info->vbus_gpiod);\n\t\tif (ret == -ENOENT) {\n\t\t\tdev_info(dev, \"No VBUS GPIO, ignoring VBUS control\\n\");\n\t\t\tinfo->vbus_gpiod = NULL;\n\t\t} else {\n\t\t\treturn dev_err_probe(dev, ret, \"failed to get VBUS GPIO\\n\");\n\t\t}\n\t}\n\n\tmutex_init(&info->mutex);\n\n\tINIT_WORK(&info->irq_work, ptn5150_irq_work);\n\n\tinfo->regmap = devm_regmap_init_i2c(i2c, &ptn5150_regmap_config);\n\tif (IS_ERR(info->regmap)) {\n\t\treturn dev_err_probe(info->dev, PTR_ERR(info->regmap),\n\t\t\t\t     \"failed to allocate register map\\n\");\n\t}\n\n\tif (i2c->irq > 0) {\n\t\tinfo->irq = i2c->irq;\n\t} else {\n\t\tinfo->int_gpiod = devm_gpiod_get(&i2c->dev, \"int\", GPIOD_IN);\n\t\tif (IS_ERR(info->int_gpiod)) {\n\t\t\treturn dev_err_probe(dev, PTR_ERR(info->int_gpiod),\n\t\t\t\t\t     \"failed to get INT GPIO\\n\");\n\t\t}\n\n\t\tinfo->irq = gpiod_to_irq(info->int_gpiod);\n\t\tif (info->irq < 0) {\n\t\t\tdev_err(dev, \"failed to get INTB IRQ\\n\");\n\t\t\treturn info->irq;\n\t\t}\n\t}\n\n\tret = devm_request_threaded_irq(dev, info->irq, NULL,\n\t\t\t\t\tptn5150_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\ti2c->name, info);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to request handler for INTB IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tinfo->edev = devm_extcon_dev_allocate(info->dev, ptn5150_extcon_cable);\n\tif (IS_ERR(info->edev)) {\n\t\tdev_err(info->dev, \"failed to allocate memory for extcon\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = devm_extcon_dev_register(info->dev, info->edev);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed to register extcon device\\n\");\n\t\treturn ret;\n\t}\n\n\textcon_set_property_capability(info->edev, EXTCON_USB,\n\t\t\t\t\tEXTCON_PROP_USB_VBUS);\n\textcon_set_property_capability(info->edev, EXTCON_USB_HOST,\n\t\t\t\t\tEXTCON_PROP_USB_VBUS);\n\textcon_set_property_capability(info->edev, EXTCON_USB_HOST,\n\t\t\t\t\tEXTCON_PROP_USB_TYPEC_POLARITY);\n\n\t \n\tret = ptn5150_init_dev_type(info);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tinfo->role_sw = usb_role_switch_get(info->dev);\n\tif (IS_ERR(info->role_sw))\n\t\treturn dev_err_probe(info->dev, PTR_ERR(info->role_sw),\n\t\t\t\t     \"failed to get role switch\\n\");\n\n\tret = devm_add_action_or_reset(dev, ptn5150_work_sync_and_put, info);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmutex_lock(&info->mutex);\n\tptn5150_check_state(info);\n\tmutex_unlock(&info->mutex);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ptn5150_dt_match[] = {\n\t{ .compatible = \"nxp,ptn5150\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ptn5150_dt_match);\n\nstatic const struct i2c_device_id ptn5150_i2c_id[] = {\n\t{ \"ptn5150\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ptn5150_i2c_id);\n\nstatic struct i2c_driver ptn5150_i2c_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"ptn5150\",\n\t\t.of_match_table = ptn5150_dt_match,\n\t},\n\t.probe\t\t= ptn5150_i2c_probe,\n\t.id_table = ptn5150_i2c_id,\n};\nmodule_i2c_driver(ptn5150_i2c_driver);\n\nMODULE_DESCRIPTION(\"NXP PTN5150 CC logic Extcon driver\");\nMODULE_AUTHOR(\"Vijai Kumar K <vijaikumar.kanagarajan@gmail.com>\");\nMODULE_AUTHOR(\"Krzysztof Kozlowski <krzk@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}