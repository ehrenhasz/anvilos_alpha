{
  "module_name": "extcon-usbc-tusb320.c",
  "hash_id": "2a72c6fec65934d930e6a967efe2cf6f6099f183483a97c184c557263010985b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-usbc-tusb320.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/extcon-provider.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/usb/typec.h>\n#include <linux/usb/typec_altmode.h>\n#include <linux/usb/role.h>\n\n#define TUSB320_REG8\t\t\t\t0x8\n#define TUSB320_REG8_CURRENT_MODE_ADVERTISE\tGENMASK(7, 6)\n#define TUSB320_REG8_CURRENT_MODE_ADVERTISE_USB\t0x0\n#define TUSB320_REG8_CURRENT_MODE_ADVERTISE_15A\t0x1\n#define TUSB320_REG8_CURRENT_MODE_ADVERTISE_30A\t0x2\n#define TUSB320_REG8_CURRENT_MODE_DETECT\tGENMASK(5, 4)\n#define TUSB320_REG8_CURRENT_MODE_DETECT_DEF\t0x0\n#define TUSB320_REG8_CURRENT_MODE_DETECT_MED\t0x1\n#define TUSB320_REG8_CURRENT_MODE_DETECT_ACC\t0x2\n#define TUSB320_REG8_CURRENT_MODE_DETECT_HI\t0x3\n#define TUSB320_REG8_ACCESSORY_CONNECTED\tGENMASK(3, 1)\n#define TUSB320_REG8_ACCESSORY_CONNECTED_NONE\t0x0\n#define TUSB320_REG8_ACCESSORY_CONNECTED_AUDIO\t0x4\n#define TUSB320_REG8_ACCESSORY_CONNECTED_ACHRG\t0x5\n#define TUSB320_REG8_ACCESSORY_CONNECTED_DBGDFP\t0x6\n#define TUSB320_REG8_ACCESSORY_CONNECTED_DBGUFP\t0x7\n#define TUSB320_REG8_ACTIVE_CABLE_DETECTION\tBIT(0)\n\n#define TUSB320_REG9\t\t\t\t0x9\n#define TUSB320_REG9_ATTACHED_STATE\t\tGENMASK(7, 6)\n#define TUSB320_REG9_CABLE_DIRECTION\t\tBIT(5)\n#define TUSB320_REG9_INTERRUPT_STATUS\t\tBIT(4)\n\n#define TUSB320_REGA\t\t\t\t0xa\n#define TUSB320L_REGA_DISABLE_TERM\t\tBIT(0)\n#define TUSB320_REGA_I2C_SOFT_RESET\t\tBIT(3)\n#define TUSB320_REGA_MODE_SELECT_SHIFT\t\t4\n#define TUSB320_REGA_MODE_SELECT_MASK\t\t0x3\n\n#define TUSB320L_REGA0_REVISION\t\t\t0xa0\n\nenum tusb320_attached_state {\n\tTUSB320_ATTACHED_STATE_NONE,\n\tTUSB320_ATTACHED_STATE_DFP,\n\tTUSB320_ATTACHED_STATE_UFP,\n\tTUSB320_ATTACHED_STATE_ACC,\n};\n\nenum tusb320_mode {\n\tTUSB320_MODE_PORT,\n\tTUSB320_MODE_UFP,\n\tTUSB320_MODE_DFP,\n\tTUSB320_MODE_DRP,\n};\n\nstruct tusb320_priv;\n\nstruct tusb320_ops {\n\tint (*set_mode)(struct tusb320_priv *priv, enum tusb320_mode mode);\n\tint (*get_revision)(struct tusb320_priv *priv, unsigned int *revision);\n};\n\nstruct tusb320_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct extcon_dev *edev;\n\tstruct tusb320_ops *ops;\n\tenum tusb320_attached_state state;\n\tstruct typec_port *port;\n\tstruct typec_capability\tcap;\n\tenum typec_port_type port_type;\n\tenum typec_pwr_opmode pwr_opmode;\n\tstruct fwnode_handle *connector_fwnode;\n\tstruct usb_role_switch *role_sw;\n};\n\nstatic const char * const tusb_attached_states[] = {\n\t[TUSB320_ATTACHED_STATE_NONE] = \"not attached\",\n\t[TUSB320_ATTACHED_STATE_DFP]  = \"downstream facing port\",\n\t[TUSB320_ATTACHED_STATE_UFP]  = \"upstream facing port\",\n\t[TUSB320_ATTACHED_STATE_ACC]  = \"accessory\",\n};\n\nstatic const unsigned int tusb320_extcon_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_NONE,\n};\n\nstatic int tusb320_check_signature(struct tusb320_priv *priv)\n{\n\tstatic const char sig[] = { '\\0', 'T', 'U', 'S', 'B', '3', '2', '0' };\n\tunsigned val;\n\tint i, ret;\n\n\tfor (i = 0; i < sizeof(sig); i++) {\n\t\tret = regmap_read(priv->regmap, sizeof(sig) - 1 - i, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (val != sig[i]) {\n\t\t\tdev_err(priv->dev, \"signature mismatch!\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tusb320_set_mode(struct tusb320_priv *priv, enum tusb320_mode mode)\n{\n\tint ret;\n\n\t \n\tif (priv->state != TUSB320_ATTACHED_STATE_NONE)\n\t\treturn -EBUSY;\n\n\t \n\tret = regmap_write_bits(priv->regmap, TUSB320_REGA,\n\t\tTUSB320_REGA_MODE_SELECT_MASK << TUSB320_REGA_MODE_SELECT_SHIFT,\n\t\tmode << TUSB320_REGA_MODE_SELECT_SHIFT);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to write mode: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tusb320l_set_mode(struct tusb320_priv *priv, enum tusb320_mode mode)\n{\n\tint ret;\n\n\t \n\tret = regmap_write_bits(priv->regmap, TUSB320_REGA,\n\t\tTUSB320L_REGA_DISABLE_TERM, 1);\n\tif (ret) {\n\t\tdev_err(priv->dev,\n\t\t\t\"failed to disable CC state machine: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write_bits(priv->regmap, TUSB320_REGA,\n\t\tTUSB320_REGA_MODE_SELECT_MASK << TUSB320_REGA_MODE_SELECT_SHIFT,\n\t\tmode << TUSB320_REGA_MODE_SELECT_SHIFT);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to write mode: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tmsleep(5);\nerr:\n\t \n\tret = regmap_write_bits(priv->regmap, TUSB320_REGA,\n\t\tTUSB320L_REGA_DISABLE_TERM, 0);\n\tif (ret)\n\t\tdev_err(priv->dev,\n\t\t\t\"failed to re-enable CC state machine: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int tusb320_reset(struct tusb320_priv *priv)\n{\n\tint ret;\n\n\t \n\tret = priv->ops->set_mode(priv, TUSB320_MODE_PORT);\n\tif (ret && ret != -EBUSY) {\n\t\tdev_err(priv->dev,\n\t\t\t\"failed to set mode to PORT: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write_bits(priv->regmap, TUSB320_REGA,\n\t\t\tTUSB320_REGA_I2C_SOFT_RESET, 1);\n\tif (ret) {\n\t\tdev_err(priv->dev,\n\t\t\t\"failed to write soft reset bit: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmsleep(95);\n\n\treturn 0;\n}\n\nstatic int tusb320l_get_revision(struct tusb320_priv *priv, unsigned int *revision)\n{\n\treturn regmap_read(priv->regmap, TUSB320L_REGA0_REVISION, revision);\n}\n\nstatic struct tusb320_ops tusb320_ops = {\n\t.set_mode = tusb320_set_mode,\n};\n\nstatic struct tusb320_ops tusb320l_ops = {\n\t.set_mode = tusb320l_set_mode,\n\t.get_revision = tusb320l_get_revision,\n};\n\nstatic int tusb320_set_adv_pwr_mode(struct tusb320_priv *priv)\n{\n\tu8 mode;\n\n\tif (priv->pwr_opmode == TYPEC_PWR_MODE_USB)\n\t\tmode = TUSB320_REG8_CURRENT_MODE_ADVERTISE_USB;\n\telse if (priv->pwr_opmode == TYPEC_PWR_MODE_1_5A)\n\t\tmode = TUSB320_REG8_CURRENT_MODE_ADVERTISE_15A;\n\telse if (priv->pwr_opmode == TYPEC_PWR_MODE_3_0A)\n\t\tmode = TUSB320_REG8_CURRENT_MODE_ADVERTISE_30A;\n\telse\t \n\t\treturn -EINVAL;\n\n\treturn regmap_write_bits(priv->regmap, TUSB320_REG8,\n\t\t\t\t TUSB320_REG8_CURRENT_MODE_ADVERTISE,\n\t\t\t\t FIELD_PREP(TUSB320_REG8_CURRENT_MODE_ADVERTISE,\n\t\t\t\t\t    mode));\n}\n\nstatic int tusb320_port_type_set(struct typec_port *port,\n\t\t\t\t enum typec_port_type type)\n{\n\tstruct tusb320_priv *priv = typec_get_drvdata(port);\n\n\tif (type == TYPEC_PORT_SRC)\n\t\treturn priv->ops->set_mode(priv, TUSB320_MODE_DFP);\n\telse if (type == TYPEC_PORT_SNK)\n\t\treturn priv->ops->set_mode(priv, TUSB320_MODE_UFP);\n\telse if (type == TYPEC_PORT_DRP)\n\t\treturn priv->ops->set_mode(priv, TUSB320_MODE_DRP);\n\telse\n\t\treturn priv->ops->set_mode(priv, TUSB320_MODE_PORT);\n}\n\nstatic const struct typec_operations tusb320_typec_ops = {\n\t.port_type_set\t= tusb320_port_type_set,\n};\n\nstatic void tusb320_extcon_irq_handler(struct tusb320_priv *priv, u8 reg)\n{\n\tint state, polarity;\n\n\tstate = FIELD_GET(TUSB320_REG9_ATTACHED_STATE, reg);\n\tpolarity = !!(reg & TUSB320_REG9_CABLE_DIRECTION);\n\n\tdev_dbg(priv->dev, \"attached state: %s, polarity: %d\\n\",\n\t\ttusb_attached_states[state], polarity);\n\n\textcon_set_state(priv->edev, EXTCON_USB,\n\t\t\t state == TUSB320_ATTACHED_STATE_UFP);\n\textcon_set_state(priv->edev, EXTCON_USB_HOST,\n\t\t\t state == TUSB320_ATTACHED_STATE_DFP);\n\textcon_set_property(priv->edev, EXTCON_USB,\n\t\t\t    EXTCON_PROP_USB_TYPEC_POLARITY,\n\t\t\t    (union extcon_property_value)polarity);\n\textcon_set_property(priv->edev, EXTCON_USB_HOST,\n\t\t\t    EXTCON_PROP_USB_TYPEC_POLARITY,\n\t\t\t    (union extcon_property_value)polarity);\n\textcon_sync(priv->edev, EXTCON_USB);\n\textcon_sync(priv->edev, EXTCON_USB_HOST);\n\n\tpriv->state = state;\n}\n\nstatic void tusb320_typec_irq_handler(struct tusb320_priv *priv, u8 reg9)\n{\n\tstruct typec_port *port = priv->port;\n\tstruct device *dev = priv->dev;\n\tint typec_mode;\n\tenum usb_role usb_role;\n\tenum typec_role pwr_role;\n\tenum typec_data_role data_role;\n\tu8 state, mode, accessory;\n\tint ret, reg8;\n\tbool ori;\n\n\tret = regmap_read(priv->regmap, TUSB320_REG8, &reg8);\n\tif (ret) {\n\t\tdev_err(dev, \"error during reg8 i2c read, ret=%d!\\n\", ret);\n\t\treturn;\n\t}\n\n\tori = reg9 & TUSB320_REG9_CABLE_DIRECTION;\n\ttypec_set_orientation(port, ori ? TYPEC_ORIENTATION_REVERSE :\n\t\t\t\t\t  TYPEC_ORIENTATION_NORMAL);\n\n\tstate = FIELD_GET(TUSB320_REG9_ATTACHED_STATE, reg9);\n\taccessory = FIELD_GET(TUSB320_REG8_ACCESSORY_CONNECTED, reg8);\n\n\tswitch (state) {\n\tcase TUSB320_ATTACHED_STATE_DFP:\n\t\ttypec_mode = TYPEC_MODE_USB2;\n\t\tusb_role = USB_ROLE_HOST;\n\t\tpwr_role = TYPEC_SOURCE;\n\t\tdata_role = TYPEC_HOST;\n\t\tbreak;\n\tcase TUSB320_ATTACHED_STATE_UFP:\n\t\ttypec_mode = TYPEC_MODE_USB2;\n\t\tusb_role = USB_ROLE_DEVICE;\n\t\tpwr_role = TYPEC_SINK;\n\t\tdata_role = TYPEC_DEVICE;\n\t\tbreak;\n\tcase TUSB320_ATTACHED_STATE_ACC:\n\t\t \n\t\tif (accessory == TUSB320_REG8_ACCESSORY_CONNECTED_AUDIO ||\n\t\t    accessory == TUSB320_REG8_ACCESSORY_CONNECTED_ACHRG) {\n\t\t\ttypec_mode = TYPEC_MODE_AUDIO;\n\t\t\tusb_role = USB_ROLE_NONE;\n\t\t\tpwr_role = TYPEC_SINK;\n\t\t\tdata_role = TYPEC_DEVICE;\n\t\t\tbreak;\n\t\t} else if (accessory ==\n\t\t\t   TUSB320_REG8_ACCESSORY_CONNECTED_DBGDFP) {\n\t\t\ttypec_mode = TYPEC_MODE_DEBUG;\n\t\t\tpwr_role = TYPEC_SOURCE;\n\t\t\tusb_role = USB_ROLE_HOST;\n\t\t\tdata_role = TYPEC_HOST;\n\t\t\tbreak;\n\t\t} else if (accessory ==\n\t\t\t   TUSB320_REG8_ACCESSORY_CONNECTED_DBGUFP) {\n\t\t\ttypec_mode = TYPEC_MODE_DEBUG;\n\t\t\tpwr_role = TYPEC_SINK;\n\t\t\tusb_role = USB_ROLE_DEVICE;\n\t\t\tdata_role = TYPEC_DEVICE;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_warn(priv->dev, \"unexpected ACCESSORY_CONNECTED state %d\\n\",\n\t\t\t accessory);\n\n\t\tfallthrough;\n\tdefault:\n\t\ttypec_mode = TYPEC_MODE_USB2;\n\t\tusb_role = USB_ROLE_NONE;\n\t\tpwr_role = TYPEC_SINK;\n\t\tdata_role = TYPEC_DEVICE;\n\t\tbreak;\n\t}\n\n\ttypec_set_vconn_role(port, pwr_role);\n\ttypec_set_pwr_role(port, pwr_role);\n\ttypec_set_data_role(port, data_role);\n\ttypec_set_mode(port, typec_mode);\n\tusb_role_switch_set_role(priv->role_sw, usb_role);\n\n\tmode = FIELD_GET(TUSB320_REG8_CURRENT_MODE_DETECT, reg8);\n\tif (mode == TUSB320_REG8_CURRENT_MODE_DETECT_DEF)\n\t\ttypec_set_pwr_opmode(port, TYPEC_PWR_MODE_USB);\n\telse if (mode == TUSB320_REG8_CURRENT_MODE_DETECT_MED)\n\t\ttypec_set_pwr_opmode(port, TYPEC_PWR_MODE_1_5A);\n\telse if (mode == TUSB320_REG8_CURRENT_MODE_DETECT_HI)\n\t\ttypec_set_pwr_opmode(port, TYPEC_PWR_MODE_3_0A);\n\telse\t \n\t\ttypec_set_pwr_opmode(port, TYPEC_PWR_MODE_USB);\n}\n\nstatic irqreturn_t tusb320_state_update_handler(struct tusb320_priv *priv,\n\t\t\t\t\t\tbool force_update)\n{\n\tunsigned int reg;\n\n\tif (regmap_read(priv->regmap, TUSB320_REG9, &reg)) {\n\t\tdev_err(priv->dev, \"error during i2c read!\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!force_update && !(reg & TUSB320_REG9_INTERRUPT_STATUS))\n\t\treturn IRQ_NONE;\n\n\ttusb320_extcon_irq_handler(priv, reg);\n\n\t \n\tif (priv->port)\n\t\ttusb320_typec_irq_handler(priv, reg);\n\n\tregmap_write(priv->regmap, TUSB320_REG9, reg);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t tusb320_irq_handler(int irq, void *dev_id)\n{\n\tstruct tusb320_priv *priv = dev_id;\n\n\treturn tusb320_state_update_handler(priv, false);\n}\n\nstatic const struct regmap_config tusb320_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int tusb320_extcon_probe(struct tusb320_priv *priv)\n{\n\tint ret;\n\n\tpriv->edev = devm_extcon_dev_allocate(priv->dev, tusb320_extcon_cable);\n\tif (IS_ERR(priv->edev)) {\n\t\tdev_err(priv->dev, \"failed to allocate extcon device\\n\");\n\t\treturn PTR_ERR(priv->edev);\n\t}\n\n\tret = devm_extcon_dev_register(priv->dev, priv->edev);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"failed to register extcon device\\n\");\n\t\treturn ret;\n\t}\n\n\textcon_set_property_capability(priv->edev, EXTCON_USB,\n\t\t\t\t       EXTCON_PROP_USB_TYPEC_POLARITY);\n\textcon_set_property_capability(priv->edev, EXTCON_USB_HOST,\n\t\t\t\t       EXTCON_PROP_USB_TYPEC_POLARITY);\n\n\treturn 0;\n}\n\nstatic int tusb320_typec_probe(struct i2c_client *client,\n\t\t\t       struct tusb320_priv *priv)\n{\n\tstruct fwnode_handle *connector;\n\tconst char *cap_str;\n\tint ret;\n\n\t \n\tconnector = device_get_named_child_node(&client->dev, \"connector\");\n\tif (!connector)\n\t\treturn 0;\n\n\t \n\tret = typec_get_fw_cap(&priv->cap, connector);\n\tif (ret)\n\t\tgoto err_put;\n\n\tpriv->port_type = priv->cap.type;\n\n\t \n\tret = fwnode_property_read_string(connector, \"typec-power-opmode\", &cap_str);\n\tif (ret)\n\t\tgoto err_put;\n\n\tret = typec_find_pwr_opmode(cap_str);\n\tif (ret < 0)\n\t\tgoto err_put;\n\n\tpriv->pwr_opmode = ret;\n\n\t \n\tret = tusb320_set_adv_pwr_mode(priv);\n\tif (ret)\n\t\tgoto err_put;\n\n\tpriv->cap.revision\t\t= USB_TYPEC_REV_1_1;\n\tpriv->cap.accessory[0]\t\t= TYPEC_ACCESSORY_AUDIO;\n\tpriv->cap.accessory[1]\t\t= TYPEC_ACCESSORY_DEBUG;\n\tpriv->cap.orientation_aware\t= true;\n\tpriv->cap.driver_data\t\t= priv;\n\tpriv->cap.ops\t\t\t= &tusb320_typec_ops;\n\tpriv->cap.fwnode\t\t= connector;\n\n\tpriv->port = typec_register_port(&client->dev, &priv->cap);\n\tif (IS_ERR(priv->port)) {\n\t\tret = PTR_ERR(priv->port);\n\t\tgoto err_put;\n\t}\n\n\t \n\tpriv->role_sw = fwnode_usb_role_switch_get(connector);\n\tif (IS_ERR(priv->role_sw)) {\n\t\tret = PTR_ERR(priv->role_sw);\n\t\tgoto err_unreg;\n\t}\n\n\tpriv->connector_fwnode = connector;\n\n\treturn 0;\n\nerr_unreg:\n\ttypec_unregister_port(priv->port);\n\nerr_put:\n\tfwnode_handle_put(connector);\n\n\treturn ret;\n}\n\nstatic void tusb320_typec_remove(struct tusb320_priv *priv)\n{\n\tusb_role_switch_put(priv->role_sw);\n\ttypec_unregister_port(priv->port);\n\tfwnode_handle_put(priv->connector_fwnode);\n}\n\nstatic int tusb320_probe(struct i2c_client *client)\n{\n\tstruct tusb320_priv *priv;\n\tconst void *match_data;\n\tunsigned int revision;\n\tint ret;\n\n\tpriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &client->dev;\n\ti2c_set_clientdata(client, priv);\n\n\tpriv->regmap = devm_regmap_init_i2c(client, &tusb320_regmap_config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tret = tusb320_check_signature(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tmatch_data = device_get_match_data(&client->dev);\n\tif (!match_data)\n\t\treturn -EINVAL;\n\n\tpriv->ops = (struct tusb320_ops*)match_data;\n\n\tif (priv->ops->get_revision) {\n\t\tret = priv->ops->get_revision(priv, &revision);\n\t\tif (ret)\n\t\t\tdev_warn(priv->dev,\n\t\t\t\t\"failed to read revision register: %d\\n\", ret);\n\t\telse\n\t\t\tdev_info(priv->dev, \"chip revision %d\\n\", revision);\n\t}\n\n\tret = tusb320_extcon_probe(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tusb320_typec_probe(client, priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttusb320_state_update_handler(priv, true);\n\n\t \n\tret = tusb320_reset(priv);\n\tif (ret)\n\t\tdev_warn(priv->dev, \"failed to reset chip: %d\\n\", ret);\n\telse\n\t\t \n\t\ttusb320_state_update_handler(priv, true);\n\n\tret = devm_request_threaded_irq(priv->dev, client->irq, NULL,\n\t\t\t\t\ttusb320_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\tclient->name, priv);\n\tif (ret)\n\t\ttusb320_typec_remove(priv);\n\n\treturn ret;\n}\n\nstatic void tusb320_remove(struct i2c_client *client)\n{\n\tstruct tusb320_priv *priv = i2c_get_clientdata(client);\n\n\ttusb320_typec_remove(priv);\n}\n\nstatic const struct of_device_id tusb320_extcon_dt_match[] = {\n\t{ .compatible = \"ti,tusb320\", .data = &tusb320_ops, },\n\t{ .compatible = \"ti,tusb320l\", .data = &tusb320l_ops, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tusb320_extcon_dt_match);\n\nstatic struct i2c_driver tusb320_extcon_driver = {\n\t.probe\t\t= tusb320_probe,\n\t.remove\t\t= tusb320_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"extcon-tusb320\",\n\t\t.of_match_table = tusb320_extcon_dt_match,\n\t},\n};\n\nstatic int __init tusb320_init(void)\n{\n\treturn i2c_add_driver(&tusb320_extcon_driver);\n}\nsubsys_initcall(tusb320_init);\n\nstatic void __exit tusb320_exit(void)\n{\n\ti2c_del_driver(&tusb320_extcon_driver);\n}\nmodule_exit(tusb320_exit);\n\nMODULE_AUTHOR(\"Michael Auchter <michael.auchter@ni.com>\");\nMODULE_DESCRIPTION(\"TI TUSB320 extcon driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}