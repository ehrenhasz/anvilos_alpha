{
  "module_name": "extcon-rt8973a.c",
  "hash_id": "babc9dd2e7ddb22c3bf9f7413acae972e9f19d22cdf786ed518aaba24fa09e29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-rt8973a.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/extcon-provider.h>\n\n#include \"extcon-rt8973a.h\"\n\n#define\tDELAY_MS_DEFAULT\t\t20000\t \n\nstruct muic_irq {\n\tunsigned int irq;\n\tconst char *name;\n\tunsigned int virq;\n};\n\nstruct reg_data {\n\tu8 reg;\n\tu8 mask;\n\tu8 val;\n\tbool invert;\n};\n\nstruct rt8973a_muic_info {\n\tstruct device *dev;\n\tstruct extcon_dev *edev;\n\n\tstruct i2c_client *i2c;\n\tstruct regmap *regmap;\n\n\tstruct regmap_irq_chip_data *irq_data;\n\tstruct muic_irq *muic_irqs;\n\tunsigned int num_muic_irqs;\n\tint irq;\n\tbool irq_attach;\n\tbool irq_detach;\n\tbool irq_ovp;\n\tbool irq_otp;\n\tstruct work_struct irq_work;\n\n\tstruct reg_data *reg_data;\n\tunsigned int num_reg_data;\n\tbool auto_config;\n\n\tstruct mutex mutex;\n\n\t \n\tstruct delayed_work wq_detcable;\n};\n\n \nstatic struct reg_data rt8973a_reg_data[] = {\n\t{\n\t\t.reg = RT8973A_REG_CONTROL1,\n\t\t.mask = RT8973A_REG_CONTROL1_ADC_EN_MASK\n\t\t\t| RT8973A_REG_CONTROL1_USB_CHD_EN_MASK\n\t\t\t| RT8973A_REG_CONTROL1_CHGTYP_MASK\n\t\t\t| RT8973A_REG_CONTROL1_SWITCH_OPEN_MASK\n\t\t\t| RT8973A_REG_CONTROL1_AUTO_CONFIG_MASK\n\t\t\t| RT8973A_REG_CONTROL1_INTM_MASK,\n\t\t.val = RT8973A_REG_CONTROL1_ADC_EN_MASK\n\t\t\t| RT8973A_REG_CONTROL1_USB_CHD_EN_MASK\n\t\t\t| RT8973A_REG_CONTROL1_CHGTYP_MASK,\n\t\t.invert = false,\n\t},\n\t{   }\n};\n\n \nstatic const unsigned int rt8973a_extcon_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_CHG_USB_SDP,\n\tEXTCON_CHG_USB_DCP,\n\tEXTCON_JIG,\n\tEXTCON_NONE,\n};\n\n \nenum rt8973a_event_type {\n\tRT8973A_EVENT_ATTACH = 1,\n\tRT8973A_EVENT_DETACH,\n\tRT8973A_EVENT_OVP,\n\tRT8973A_EVENT_OTP,\n};\n\n \nenum rt8973a_muic_acc_type {\n\tRT8973A_MUIC_ADC_OTG = 0x0,\n\tRT8973A_MUIC_ADC_AUDIO_SEND_END_BUTTON,\n\tRT8973A_MUIC_ADC_AUDIO_REMOTE_S1_BUTTON,\n\tRT8973A_MUIC_ADC_AUDIO_REMOTE_S2_BUTTON,\n\tRT8973A_MUIC_ADC_AUDIO_REMOTE_S3_BUTTON,\n\tRT8973A_MUIC_ADC_AUDIO_REMOTE_S4_BUTTON,\n\tRT8973A_MUIC_ADC_AUDIO_REMOTE_S5_BUTTON,\n\tRT8973A_MUIC_ADC_AUDIO_REMOTE_S6_BUTTON,\n\tRT8973A_MUIC_ADC_AUDIO_REMOTE_S7_BUTTON,\n\tRT8973A_MUIC_ADC_AUDIO_REMOTE_S8_BUTTON,\n\tRT8973A_MUIC_ADC_AUDIO_REMOTE_S9_BUTTON,\n\tRT8973A_MUIC_ADC_AUDIO_REMOTE_S10_BUTTON,\n\tRT8973A_MUIC_ADC_AUDIO_REMOTE_S11_BUTTON,\n\tRT8973A_MUIC_ADC_AUDIO_REMOTE_S12_BUTTON,\n\tRT8973A_MUIC_ADC_RESERVED_ACC_1,\n\tRT8973A_MUIC_ADC_RESERVED_ACC_2,\n\tRT8973A_MUIC_ADC_RESERVED_ACC_3,\n\tRT8973A_MUIC_ADC_RESERVED_ACC_4,\n\tRT8973A_MUIC_ADC_RESERVED_ACC_5,\n\tRT8973A_MUIC_ADC_AUDIO_TYPE2,\n\tRT8973A_MUIC_ADC_PHONE_POWERED_DEV,\n\tRT8973A_MUIC_ADC_UNKNOWN_ACC_1,\n\tRT8973A_MUIC_ADC_UNKNOWN_ACC_2,\n\tRT8973A_MUIC_ADC_TA,\n\tRT8973A_MUIC_ADC_FACTORY_MODE_BOOT_OFF_USB,\n\tRT8973A_MUIC_ADC_FACTORY_MODE_BOOT_ON_USB,\n\tRT8973A_MUIC_ADC_UNKNOWN_ACC_3,\n\tRT8973A_MUIC_ADC_UNKNOWN_ACC_4,\n\tRT8973A_MUIC_ADC_FACTORY_MODE_BOOT_OFF_UART,\n\tRT8973A_MUIC_ADC_FACTORY_MODE_BOOT_ON_UART,\n\tRT8973A_MUIC_ADC_UNKNOWN_ACC_5,\n\tRT8973A_MUIC_ADC_OPEN = 0x1f,\n\n\t \n\t\t\t\t\t \n\t\t\t\t\t \n\tRT8973A_MUIC_ADC_USB = 0x3f,\t \n};\n\n \nstatic struct muic_irq rt8973a_muic_irqs[] = {\n\t{ RT8973A_INT1_ATTACH,\t\t\"muic-attach\" },\n\t{ RT8973A_INT1_DETACH,\t\t\"muic-detach\" },\n\t{ RT8973A_INT1_CHGDET,\t\t\"muic-chgdet\" },\n\t{ RT8973A_INT1_DCD_T,\t\t\"muic-dcd-t\" },\n\t{ RT8973A_INT1_OVP,\t\t\"muic-ovp\" },\n\t{ RT8973A_INT1_CONNECT,\t\t\"muic-connect\" },\n\t{ RT8973A_INT1_ADC_CHG,\t\t\"muic-adc-chg\" },\n\t{ RT8973A_INT1_OTP,\t\t\"muic-otp\" },\n\t{ RT8973A_INT2_UVLO,\t\t\"muic-uvlo\" },\n\t{ RT8973A_INT2_POR,\t\t\"muic-por\" },\n\t{ RT8973A_INT2_OTP_FET,\t\t\"muic-otp-fet\" },\n\t{ RT8973A_INT2_OVP_FET,\t\t\"muic-ovp-fet\" },\n\t{ RT8973A_INT2_OCP_LATCH,\t\"muic-ocp-latch\" },\n\t{ RT8973A_INT2_OCP,\t\t\"muic-ocp\" },\n\t{ RT8973A_INT2_OVP_OCP,\t\t\"muic-ovp-ocp\" },\n};\n\n \nstatic const struct regmap_irq rt8973a_irqs[] = {\n\t \n\t{ .reg_offset = 0, .mask = RT8973A_INT1_ATTACH_MASK, },\n\t{ .reg_offset = 0, .mask = RT8973A_INT1_DETACH_MASK, },\n\t{ .reg_offset = 0, .mask = RT8973A_INT1_CHGDET_MASK, },\n\t{ .reg_offset = 0, .mask = RT8973A_INT1_DCD_T_MASK, },\n\t{ .reg_offset = 0, .mask = RT8973A_INT1_OVP_MASK, },\n\t{ .reg_offset = 0, .mask = RT8973A_INT1_CONNECT_MASK, },\n\t{ .reg_offset = 0, .mask = RT8973A_INT1_ADC_CHG_MASK, },\n\t{ .reg_offset = 0, .mask = RT8973A_INT1_OTP_MASK, },\n\n\t \n\t{ .reg_offset = 1, .mask = RT8973A_INT2_UVLOT_MASK,},\n\t{ .reg_offset = 1, .mask = RT8973A_INT2_POR_MASK, },\n\t{ .reg_offset = 1, .mask = RT8973A_INT2_OTP_FET_MASK, },\n\t{ .reg_offset = 1, .mask = RT8973A_INT2_OVP_FET_MASK, },\n\t{ .reg_offset = 1, .mask = RT8973A_INT2_OCP_LATCH_MASK, },\n\t{ .reg_offset = 1, .mask = RT8973A_INT2_OCP_MASK, },\n\t{ .reg_offset = 1, .mask = RT8973A_INT2_OVP_OCP_MASK, },\n};\n\nstatic const struct regmap_irq_chip rt8973a_muic_irq_chip = {\n\t.name\t\t\t= \"rt8973a\",\n\t.status_base\t\t= RT8973A_REG_INT1,\n\t.mask_base\t\t= RT8973A_REG_INTM1,\n\t.num_regs\t\t= 2,\n\t.irqs\t\t\t= rt8973a_irqs,\n\t.num_irqs\t\t= ARRAY_SIZE(rt8973a_irqs),\n};\n\n \nstatic bool rt8973a_muic_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RT8973A_REG_INTM1:\n\tcase RT8973A_REG_INTM2:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic const struct regmap_config rt8973a_muic_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.volatile_reg\t= rt8973a_muic_volatile_reg,\n\t.max_register\t= RT8973A_REG_END,\n};\n\n \nstatic int rt8973a_muic_set_path(struct rt8973a_muic_info *info,\n\t\t\t\tunsigned int con_sw, bool attached)\n{\n\tint ret;\n\n\t \n\tif (info->auto_config)\n\t\treturn 0;\n\n\tif (!attached)\n\t\tcon_sw\t= DM_DP_SWITCH_UART;\n\n\tswitch (con_sw) {\n\tcase DM_DP_SWITCH_OPEN:\n\tcase DM_DP_SWITCH_USB:\n\tcase DM_DP_SWITCH_UART:\n\t\tret = regmap_update_bits(info->regmap, RT8973A_REG_MANUAL_SW1,\n\t\t\t\t\tRT8973A_REG_MANUAL_SW1_DP_MASK |\n\t\t\t\t\tRT8973A_REG_MANUAL_SW1_DM_MASK,\n\t\t\t\t\tcon_sw);\n\t\tif (ret < 0) {\n\t\t\tdev_err(info->dev,\n\t\t\t\t\"cannot update DM_CON/DP_CON switch\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(info->dev, \"Unknown DM_CON/DP_CON switch type (%d)\\n\",\n\t\t\t\tcon_sw);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt8973a_muic_get_cable_type(struct rt8973a_muic_info *info)\n{\n\tunsigned int adc, dev1;\n\tint ret, cable_type;\n\n\t \n\tret = regmap_read(info->regmap, RT8973A_REG_ADC, &adc);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed to read ADC register\\n\");\n\t\treturn ret;\n\t}\n\tcable_type = adc & RT8973A_REG_ADC_MASK;\n\n\t \n\tret = regmap_read(info->regmap, RT8973A_REG_DEV1, &dev1);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed to read DEV1 register\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (adc) {\n\tcase RT8973A_MUIC_ADC_OPEN:\n\t\tif (dev1 & RT8973A_REG_DEV1_USB_MASK)\n\t\t\tcable_type = RT8973A_MUIC_ADC_USB;\n\t\telse if (dev1 & RT8973A_REG_DEV1_DCPORT_MASK)\n\t\t\tcable_type = RT8973A_MUIC_ADC_TA;\n\t\telse\n\t\t\tcable_type = RT8973A_MUIC_ADC_OPEN;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn cable_type;\n}\n\nstatic int rt8973a_muic_cable_handler(struct rt8973a_muic_info *info,\n\t\t\t\t\tenum rt8973a_event_type event)\n{\n\tstatic unsigned int prev_cable_type;\n\tunsigned int con_sw = DM_DP_SWITCH_UART;\n\tint ret, cable_type;\n\tunsigned int id;\n\tbool attached = false;\n\n\tswitch (event) {\n\tcase RT8973A_EVENT_ATTACH:\n\t\tcable_type = rt8973a_muic_get_cable_type(info);\n\t\tattached = true;\n\t\tbreak;\n\tcase RT8973A_EVENT_DETACH:\n\t\tcable_type = prev_cable_type;\n\t\tattached = false;\n\t\tbreak;\n\tcase RT8973A_EVENT_OVP:\n\tcase RT8973A_EVENT_OTP:\n\t\tdev_warn(info->dev,\n\t\t\t\"happen Over %s issue. Need to disconnect all cables\\n\",\n\t\t\tevent == RT8973A_EVENT_OVP ? \"Voltage\" : \"Temperature\");\n\t\tcable_type = prev_cable_type;\n\t\tattached = false;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(info->dev,\n\t\t\t\"Cannot handle this event (event:%d)\\n\", event);\n\t\treturn -EINVAL;\n\t}\n\tprev_cable_type = cable_type;\n\n\tswitch (cable_type) {\n\tcase RT8973A_MUIC_ADC_OTG:\n\t\tid = EXTCON_USB_HOST;\n\t\tcon_sw = DM_DP_SWITCH_USB;\n\t\tbreak;\n\tcase RT8973A_MUIC_ADC_TA:\n\t\tid = EXTCON_CHG_USB_DCP;\n\t\tcon_sw = DM_DP_SWITCH_OPEN;\n\t\tbreak;\n\tcase RT8973A_MUIC_ADC_FACTORY_MODE_BOOT_OFF_USB:\n\tcase RT8973A_MUIC_ADC_FACTORY_MODE_BOOT_ON_USB:\n\t\tid = EXTCON_JIG;\n\t\tcon_sw = DM_DP_SWITCH_USB;\n\t\tbreak;\n\tcase RT8973A_MUIC_ADC_FACTORY_MODE_BOOT_OFF_UART:\n\tcase RT8973A_MUIC_ADC_FACTORY_MODE_BOOT_ON_UART:\n\t\tid = EXTCON_JIG;\n\t\tcon_sw = DM_DP_SWITCH_UART;\n\t\tbreak;\n\tcase RT8973A_MUIC_ADC_USB:\n\t\tid = EXTCON_USB;\n\t\tcon_sw = DM_DP_SWITCH_USB;\n\t\tbreak;\n\tcase RT8973A_MUIC_ADC_OPEN:\n\t\treturn 0;\n\tcase RT8973A_MUIC_ADC_UNKNOWN_ACC_1:\n\tcase RT8973A_MUIC_ADC_UNKNOWN_ACC_2:\n\tcase RT8973A_MUIC_ADC_UNKNOWN_ACC_3:\n\tcase RT8973A_MUIC_ADC_UNKNOWN_ACC_4:\n\tcase RT8973A_MUIC_ADC_UNKNOWN_ACC_5:\n\t\tdev_warn(info->dev,\n\t\t\t\"Unknown accessory type (adc:0x%x)\\n\", cable_type);\n\t\treturn 0;\n\tcase RT8973A_MUIC_ADC_AUDIO_SEND_END_BUTTON:\n\tcase RT8973A_MUIC_ADC_AUDIO_REMOTE_S1_BUTTON:\n\tcase RT8973A_MUIC_ADC_AUDIO_REMOTE_S2_BUTTON:\n\tcase RT8973A_MUIC_ADC_AUDIO_REMOTE_S3_BUTTON:\n\tcase RT8973A_MUIC_ADC_AUDIO_REMOTE_S4_BUTTON:\n\tcase RT8973A_MUIC_ADC_AUDIO_REMOTE_S5_BUTTON:\n\tcase RT8973A_MUIC_ADC_AUDIO_REMOTE_S6_BUTTON:\n\tcase RT8973A_MUIC_ADC_AUDIO_REMOTE_S7_BUTTON:\n\tcase RT8973A_MUIC_ADC_AUDIO_REMOTE_S8_BUTTON:\n\tcase RT8973A_MUIC_ADC_AUDIO_REMOTE_S9_BUTTON:\n\tcase RT8973A_MUIC_ADC_AUDIO_REMOTE_S10_BUTTON:\n\tcase RT8973A_MUIC_ADC_AUDIO_REMOTE_S11_BUTTON:\n\tcase RT8973A_MUIC_ADC_AUDIO_REMOTE_S12_BUTTON:\n\tcase RT8973A_MUIC_ADC_AUDIO_TYPE2:\n\t\tdev_warn(info->dev,\n\t\t\t\"Audio device/button type (adc:0x%x)\\n\", cable_type);\n\t\treturn 0;\n\tcase RT8973A_MUIC_ADC_RESERVED_ACC_1:\n\tcase RT8973A_MUIC_ADC_RESERVED_ACC_2:\n\tcase RT8973A_MUIC_ADC_RESERVED_ACC_3:\n\tcase RT8973A_MUIC_ADC_RESERVED_ACC_4:\n\tcase RT8973A_MUIC_ADC_RESERVED_ACC_5:\n\tcase RT8973A_MUIC_ADC_PHONE_POWERED_DEV:\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(info->dev,\n\t\t\t\"Cannot handle this cable_type (adc:0x%x)\\n\",\n\t\t\tcable_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = rt8973a_muic_set_path(info, con_sw, attached);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\textcon_set_state_sync(info->edev, id, attached);\n\tif (id == EXTCON_USB)\n\t\textcon_set_state_sync(info->edev, EXTCON_CHG_USB_SDP,\n\t\t\t\t\tattached);\n\n\treturn 0;\n}\n\nstatic void rt8973a_muic_irq_work(struct work_struct *work)\n{\n\tstruct rt8973a_muic_info *info = container_of(work,\n\t\t\tstruct rt8973a_muic_info, irq_work);\n\tint ret = 0;\n\n\tif (!info->edev)\n\t\treturn;\n\n\tmutex_lock(&info->mutex);\n\n\t \n\tif (info->irq_attach) {\n\t\tret = rt8973a_muic_cable_handler(info, RT8973A_EVENT_ATTACH);\n\t\tinfo->irq_attach = false;\n\t}\n\n\tif (info->irq_detach) {\n\t\tret = rt8973a_muic_cable_handler(info, RT8973A_EVENT_DETACH);\n\t\tinfo->irq_detach = false;\n\t}\n\n\tif (info->irq_ovp) {\n\t\tret = rt8973a_muic_cable_handler(info, RT8973A_EVENT_OVP);\n\t\tinfo->irq_ovp = false;\n\t}\n\n\tif (info->irq_otp) {\n\t\tret = rt8973a_muic_cable_handler(info, RT8973A_EVENT_OTP);\n\t\tinfo->irq_otp = false;\n\t}\n\n\tif (ret < 0)\n\t\tdev_err(info->dev, \"failed to handle MUIC interrupt\\n\");\n\n\tmutex_unlock(&info->mutex);\n}\n\nstatic irqreturn_t rt8973a_muic_irq_handler(int irq, void *data)\n{\n\tstruct rt8973a_muic_info *info = data;\n\tint i, irq_type = -1;\n\n\tfor (i = 0; i < info->num_muic_irqs; i++)\n\t\tif (irq == info->muic_irqs[i].virq)\n\t\t\tirq_type = info->muic_irqs[i].irq;\n\n\tswitch (irq_type) {\n\tcase RT8973A_INT1_ATTACH:\n\t\tinfo->irq_attach = true;\n\t\tbreak;\n\tcase RT8973A_INT1_DETACH:\n\t\tinfo->irq_detach = true;\n\t\tbreak;\n\tcase RT8973A_INT1_OVP:\n\t\tinfo->irq_ovp = true;\n\t\tbreak;\n\tcase RT8973A_INT1_OTP:\n\t\tinfo->irq_otp = true;\n\t\tbreak;\n\tcase RT8973A_INT1_CHGDET:\n\tcase RT8973A_INT1_DCD_T:\n\tcase RT8973A_INT1_CONNECT:\n\tcase RT8973A_INT1_ADC_CHG:\n\tcase RT8973A_INT2_UVLO:\n\tcase RT8973A_INT2_POR:\n\tcase RT8973A_INT2_OTP_FET:\n\tcase RT8973A_INT2_OVP_FET:\n\tcase RT8973A_INT2_OCP_LATCH:\n\tcase RT8973A_INT2_OCP:\n\tcase RT8973A_INT2_OVP_OCP:\n\tdefault:\n\t\tdev_dbg(info->dev,\n\t\t\t\"Cannot handle this interrupt (%d)\\n\", irq_type);\n\t\tbreak;\n\t}\n\n\tschedule_work(&info->irq_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rt8973a_muic_detect_cable_wq(struct work_struct *work)\n{\n\tstruct rt8973a_muic_info *info = container_of(to_delayed_work(work),\n\t\t\t\tstruct rt8973a_muic_info, wq_detcable);\n\tint ret;\n\n\t \n\tret = rt8973a_muic_cable_handler(info, RT8973A_EVENT_ATTACH);\n\tif (ret < 0)\n\t\tdev_warn(info->dev, \"failed to detect cable state\\n\");\n}\n\nstatic void rt8973a_init_dev_type(struct rt8973a_muic_info *info)\n{\n\tunsigned int data, vendor_id, version_id;\n\tint i, ret;\n\n\t \n\tret = regmap_read(info->regmap, RT8973A_REG_DEVICE_ID, &data);\n\tif (ret) {\n\t\tdev_err(info->dev,\n\t\t\t\"failed to read DEVICE_ID register: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tvendor_id = ((data & RT8973A_REG_DEVICE_ID_VENDOR_MASK) >>\n\t\t\t\tRT8973A_REG_DEVICE_ID_VENDOR_SHIFT);\n\tversion_id = ((data & RT8973A_REG_DEVICE_ID_VERSION_MASK) >>\n\t\t\t\tRT8973A_REG_DEVICE_ID_VERSION_SHIFT);\n\n\tdev_info(info->dev, \"Device type: version: 0x%x, vendor: 0x%x\\n\",\n\t\t\t    version_id, vendor_id);\n\n\t \n\tfor (i = 0; i < info->num_reg_data; i++) {\n\t\tu8 reg = info->reg_data[i].reg;\n\t\tu8 mask = info->reg_data[i].mask;\n\t\tu8 val = 0;\n\n\t\tif (info->reg_data[i].invert)\n\t\t\tval = ~info->reg_data[i].val;\n\t\telse\n\t\t\tval = info->reg_data[i].val;\n\n\t\tregmap_update_bits(info->regmap, reg, mask, val);\n\t}\n\n\t \n\tret = regmap_read(info->regmap, RT8973A_REG_CONTROL1, &data);\n\tif (ret) {\n\t\tdev_err(info->dev,\n\t\t\t\"failed to read CONTROL1 register: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tdata &= RT8973A_REG_CONTROL1_AUTO_CONFIG_MASK;\n\tif (data) {\n\t\tinfo->auto_config = true;\n\t\tdev_info(info->dev,\n\t\t\t\"Enable Auto-configuration for internal path\\n\");\n\t}\n}\n\nstatic int rt8973a_muic_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device_node *np = i2c->dev.of_node;\n\tstruct rt8973a_muic_info *info;\n\tint i, ret, irq_flags;\n\n\tif (!np)\n\t\treturn -EINVAL;\n\n\tinfo = devm_kzalloc(&i2c->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\ti2c_set_clientdata(i2c, info);\n\n\tinfo->dev = &i2c->dev;\n\tinfo->i2c = i2c;\n\tinfo->irq = i2c->irq;\n\tinfo->muic_irqs = rt8973a_muic_irqs;\n\tinfo->num_muic_irqs = ARRAY_SIZE(rt8973a_muic_irqs);\n\tinfo->reg_data = rt8973a_reg_data;\n\tinfo->num_reg_data = ARRAY_SIZE(rt8973a_reg_data);\n\n\tmutex_init(&info->mutex);\n\n\tINIT_WORK(&info->irq_work, rt8973a_muic_irq_work);\n\n\tinfo->regmap = devm_regmap_init_i2c(i2c, &rt8973a_muic_regmap_config);\n\tif (IS_ERR(info->regmap)) {\n\t\tret = PTR_ERR(info->regmap);\n\t\tdev_err(info->dev, \"failed to allocate register map: %d\\n\",\n\t\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\t \n\tirq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT | IRQF_SHARED;\n\tret = regmap_add_irq_chip(info->regmap, info->irq, irq_flags, 0,\n\t\t\t\t  &rt8973a_muic_irq_chip, &info->irq_data);\n\tif (ret != 0) {\n\t\tdev_err(info->dev, \"failed to add irq_chip (irq:%d, err:%d)\\n\",\n\t\t\t\t    info->irq, ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < info->num_muic_irqs; i++) {\n\t\tstruct muic_irq *muic_irq = &info->muic_irqs[i];\n\t\tint virq = 0;\n\n\t\tvirq = regmap_irq_get_virq(info->irq_data, muic_irq->irq);\n\t\tif (virq <= 0)\n\t\t\treturn -EINVAL;\n\t\tmuic_irq->virq = virq;\n\n\t\tret = devm_request_threaded_irq(info->dev, virq, NULL,\n\t\t\t\t\t\trt8973a_muic_irq_handler,\n\t\t\t\t\t\tIRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\t\t\t\tmuic_irq->name, info);\n\t\tif (ret) {\n\t\t\tdev_err(info->dev,\n\t\t\t\t\"failed: irq request (IRQ: %d, error :%d)\\n\",\n\t\t\t\tmuic_irq->irq, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tinfo->edev = devm_extcon_dev_allocate(info->dev, rt8973a_extcon_cable);\n\tif (IS_ERR(info->edev)) {\n\t\tdev_err(info->dev, \"failed to allocate memory for extcon\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = devm_extcon_dev_register(info->dev, info->edev);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed to register extcon device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tINIT_DELAYED_WORK(&info->wq_detcable, rt8973a_muic_detect_cable_wq);\n\tqueue_delayed_work(system_power_efficient_wq, &info->wq_detcable,\n\t\t\tmsecs_to_jiffies(DELAY_MS_DEFAULT));\n\n\t \n\trt8973a_init_dev_type(info);\n\n\treturn 0;\n}\n\nstatic void rt8973a_muic_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct rt8973a_muic_info *info = i2c_get_clientdata(i2c);\n\n\tregmap_del_irq_chip(info->irq, info->irq_data);\n}\n\nstatic const struct of_device_id rt8973a_dt_match[] = {\n\t{ .compatible = \"richtek,rt8973a-muic\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rt8973a_dt_match);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int rt8973a_muic_suspend(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct rt8973a_muic_info *info = i2c_get_clientdata(i2c);\n\n\tenable_irq_wake(info->irq);\n\n\treturn 0;\n}\n\nstatic int rt8973a_muic_resume(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct rt8973a_muic_info *info = i2c_get_clientdata(i2c);\n\n\tdisable_irq_wake(info->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(rt8973a_muic_pm_ops,\n\t\t\t rt8973a_muic_suspend, rt8973a_muic_resume);\n\nstatic const struct i2c_device_id rt8973a_i2c_id[] = {\n\t{ \"rt8973a\", TYPE_RT8973A },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rt8973a_i2c_id);\n\nstatic struct i2c_driver rt8973a_muic_i2c_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rt8973a\",\n\t\t.pm\t= &rt8973a_muic_pm_ops,\n\t\t.of_match_table = rt8973a_dt_match,\n\t},\n\t.probe = rt8973a_muic_i2c_probe,\n\t.remove\t= rt8973a_muic_i2c_remove,\n\t.id_table = rt8973a_i2c_id,\n};\n\nstatic int __init rt8973a_muic_i2c_init(void)\n{\n\treturn i2c_add_driver(&rt8973a_muic_i2c_driver);\n}\nsubsys_initcall(rt8973a_muic_i2c_init);\n\nMODULE_DESCRIPTION(\"Richtek RT8973A Extcon driver\");\nMODULE_AUTHOR(\"Chanwoo Choi <cw00.choi@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}