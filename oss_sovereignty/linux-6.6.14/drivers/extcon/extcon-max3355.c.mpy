{
  "module_name": "extcon-max3355.c",
  "hash_id": "91fc74f70df4716b1b5ab4b667f34b730220fb5c4e2a231d4a48cb212fdb9753",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-max3355.c",
  "human_readable_source": "\n \n\n#include <linux/extcon-provider.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n\nstruct max3355_data {\n\tstruct extcon_dev *edev;\n\tstruct gpio_desc *id_gpiod;\n\tstruct gpio_desc *shdn_gpiod;\n};\n\nstatic const unsigned int max3355_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_NONE,\n};\n\nstatic irqreturn_t max3355_id_irq(int irq, void *dev_id)\n{\n\tstruct max3355_data *data = dev_id;\n\tint id = gpiod_get_value_cansleep(data->id_gpiod);\n\n\tif (id) {\n\t\t \n\t\textcon_set_state_sync(data->edev, EXTCON_USB_HOST, false);\n\t\textcon_set_state_sync(data->edev, EXTCON_USB, true);\n\t} else {\n\t\t \n\t\textcon_set_state_sync(data->edev, EXTCON_USB, false);\n\t\textcon_set_state_sync(data->edev, EXTCON_USB_HOST, true);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int max3355_probe(struct platform_device *pdev)\n{\n\tstruct max3355_data *data;\n\tstruct gpio_desc *gpiod;\n\tint irq, err;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct max3355_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tgpiod = devm_gpiod_get(&pdev->dev, \"id\", GPIOD_IN);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(&pdev->dev, \"failed to get ID_OUT GPIO\\n\");\n\t\treturn PTR_ERR(gpiod);\n\t}\n\tdata->id_gpiod = gpiod;\n\n\tgpiod = devm_gpiod_get(&pdev->dev, \"maxim,shdn\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(gpiod)) {\n\t\tdev_err(&pdev->dev, \"failed to get SHDN# GPIO\\n\");\n\t\treturn PTR_ERR(gpiod);\n\t}\n\tdata->shdn_gpiod = gpiod;\n\n\tdata->edev = devm_extcon_dev_allocate(&pdev->dev, max3355_cable);\n\tif (IS_ERR(data->edev)) {\n\t\tdev_err(&pdev->dev, \"failed to allocate extcon device\\n\");\n\t\treturn PTR_ERR(data->edev);\n\t}\n\n\terr = devm_extcon_dev_register(&pdev->dev, data->edev);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register extcon device\\n\");\n\t\treturn err;\n\t}\n\n\tirq = gpiod_to_irq(data->id_gpiod);\n\tif (irq < 0) {\n\t\tdev_err(&pdev->dev, \"failed to translate ID_OUT GPIO to IRQ\\n\");\n\t\treturn irq;\n\t}\n\n\terr = devm_request_threaded_irq(&pdev->dev, irq, NULL, max3355_id_irq,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_NO_SUSPEND |\n\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\tIRQF_TRIGGER_FALLING,\n\t\t\t\t\tpdev->name, data);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request ID_OUT IRQ\\n\");\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\t \n\tmax3355_id_irq(irq, data);\n\n\treturn 0;\n}\n\nstatic int max3355_remove(struct platform_device *pdev)\n{\n\tstruct max3355_data *data = platform_get_drvdata(pdev);\n\n\tgpiod_set_value_cansleep(data->shdn_gpiod, 0);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id max3355_match_table[] = {\n\t{ .compatible = \"maxim,max3355\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max3355_match_table);\n\nstatic struct platform_driver max3355_driver = {\n\t.probe\t\t= max3355_probe,\n\t.remove\t\t= max3355_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"extcon-max3355\",\n\t\t.of_match_table = max3355_match_table,\n\t},\n};\n\nmodule_platform_driver(max3355_driver);\n\nMODULE_AUTHOR(\"Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>\");\nMODULE_DESCRIPTION(\"Maxim MAX3355 extcon driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}