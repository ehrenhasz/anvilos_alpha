{
  "module_name": "extcon-qcom-spmi-misc.c",
  "hash_id": "6cd5caeed730b1bc9bbc56e73f12dee8cf716e60cfd802f637a24923e1fbe2b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-qcom-spmi-misc.c",
  "human_readable_source": "\n \n\n#include <linux/devm-helpers.h>\n#include <linux/extcon-provider.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#define USB_ID_DEBOUNCE_MS\t5\t \n\nstruct qcom_usb_extcon_info {\n\tstruct extcon_dev *edev;\n\tint id_irq;\n\tint vbus_irq;\n\tstruct delayed_work wq_detcable;\n\tunsigned long debounce_jiffies;\n};\n\nstatic const unsigned int qcom_usb_extcon_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_NONE,\n};\n\nstatic void qcom_usb_extcon_detect_cable(struct work_struct *work)\n{\n\tbool state = false;\n\tint ret;\n\tunion extcon_property_value val;\n\tstruct qcom_usb_extcon_info *info = container_of(to_delayed_work(work),\n\t\t\t\t\t\t    struct qcom_usb_extcon_info,\n\t\t\t\t\t\t    wq_detcable);\n\n\tif (info->id_irq > 0) {\n\t\t \n\t\tret = irq_get_irqchip_state(info->id_irq,\n\t\t\t\tIRQCHIP_STATE_LINE_LEVEL, &state);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tif (!state) {\n\t\t\tval.intval = true;\n\t\t\textcon_set_property(info->edev, EXTCON_USB_HOST,\n\t\t\t\t\t\tEXTCON_PROP_USB_SS, val);\n\t\t}\n\t\textcon_set_state_sync(info->edev, EXTCON_USB_HOST, !state);\n\t}\n\n\tif (info->vbus_irq > 0) {\n\t\t \n\t\tret = irq_get_irqchip_state(info->vbus_irq,\n\t\t\t\tIRQCHIP_STATE_LINE_LEVEL, &state);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tif (state) {\n\t\t\tval.intval = true;\n\t\t\textcon_set_property(info->edev, EXTCON_USB,\n\t\t\t\t\t\tEXTCON_PROP_USB_SS, val);\n\t\t}\n\t\textcon_set_state_sync(info->edev, EXTCON_USB, state);\n\t}\n}\n\nstatic irqreturn_t qcom_usb_irq_handler(int irq, void *dev_id)\n{\n\tstruct qcom_usb_extcon_info *info = dev_id;\n\n\tqueue_delayed_work(system_power_efficient_wq, &info->wq_detcable,\n\t\t\t   info->debounce_jiffies);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int qcom_usb_extcon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct qcom_usb_extcon_info *info;\n\tint ret;\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->edev = devm_extcon_dev_allocate(dev, qcom_usb_extcon_cable);\n\tif (IS_ERR(info->edev)) {\n\t\tdev_err(dev, \"failed to allocate extcon device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = devm_extcon_dev_register(dev, info->edev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register extcon device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = extcon_set_property_capability(info->edev,\n\t\t\tEXTCON_USB, EXTCON_PROP_USB_SS);\n\tret |= extcon_set_property_capability(info->edev,\n\t\t\tEXTCON_USB_HOST, EXTCON_PROP_USB_SS);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register extcon props rc=%d\\n\",\n\t\t\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tinfo->debounce_jiffies = msecs_to_jiffies(USB_ID_DEBOUNCE_MS);\n\n\tret = devm_delayed_work_autocancel(dev, &info->wq_detcable,\n\t\t\t\t\t   qcom_usb_extcon_detect_cable);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo->id_irq = platform_get_irq_byname_optional(pdev, \"usb_id\");\n\tif (info->id_irq > 0) {\n\t\tret = devm_request_threaded_irq(dev, info->id_irq, NULL,\n\t\t\t\t\tqcom_usb_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\tpdev->name, info);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to request handler for ID IRQ\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tinfo->vbus_irq = platform_get_irq_byname_optional(pdev, \"usb_vbus\");\n\tif (info->vbus_irq > 0) {\n\t\tret = devm_request_threaded_irq(dev, info->vbus_irq, NULL,\n\t\t\t\t\tqcom_usb_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\tpdev->name, info);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to request handler for VBUS IRQ\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (info->id_irq < 0 && info->vbus_irq < 0) {\n\t\tdev_err(dev, \"ID and VBUS IRQ not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tplatform_set_drvdata(pdev, info);\n\tdevice_init_wakeup(dev, 1);\n\n\t \n\tqcom_usb_extcon_detect_cable(&info->wq_detcable.work);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int qcom_usb_extcon_suspend(struct device *dev)\n{\n\tstruct qcom_usb_extcon_info *info = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (device_may_wakeup(dev)) {\n\t\tif (info->id_irq > 0)\n\t\t\tret = enable_irq_wake(info->id_irq);\n\t\tif (info->vbus_irq > 0)\n\t\t\tret = enable_irq_wake(info->vbus_irq);\n\t}\n\n\treturn ret;\n}\n\nstatic int qcom_usb_extcon_resume(struct device *dev)\n{\n\tstruct qcom_usb_extcon_info *info = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (device_may_wakeup(dev)) {\n\t\tif (info->id_irq > 0)\n\t\t\tret = disable_irq_wake(info->id_irq);\n\t\tif (info->vbus_irq > 0)\n\t\t\tret = disable_irq_wake(info->vbus_irq);\n\t}\n\n\treturn ret;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(qcom_usb_extcon_pm_ops,\n\t\t\t qcom_usb_extcon_suspend, qcom_usb_extcon_resume);\n\nstatic const struct of_device_id qcom_usb_extcon_dt_match[] = {\n\t{ .compatible = \"qcom,pm8941-misc\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_usb_extcon_dt_match);\n\nstatic struct platform_driver qcom_usb_extcon_driver = {\n\t.probe\t\t= qcom_usb_extcon_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"extcon-pm8941-misc\",\n\t\t.pm\t= &qcom_usb_extcon_pm_ops,\n\t\t.of_match_table = qcom_usb_extcon_dt_match,\n\t},\n};\nmodule_platform_driver(qcom_usb_extcon_driver);\n\nMODULE_DESCRIPTION(\"QCOM USB ID extcon driver\");\nMODULE_AUTHOR(\"Stephen Boyd <stephen.boyd@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}