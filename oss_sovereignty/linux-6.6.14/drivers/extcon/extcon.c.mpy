{
  "module_name": "extcon.c",
  "hash_id": "73f3a5ad56b625158817e3135359438735df23dc208a2390b9246b463e32b337",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n\n#include \"extcon.h\"\n\n#define SUPPORTED_CABLE_MAX\t32\n\nstatic const struct __extcon_info {\n\tunsigned int type;\n\tunsigned int id;\n\tconst char *name;\n\n} extcon_info[] = {\n\t[EXTCON_NONE] = {\n\t\t.type = EXTCON_TYPE_MISC,\n\t\t.id = EXTCON_NONE,\n\t\t.name = \"NONE\",\n\t},\n\n\t \n\t[EXTCON_USB] = {\n\t\t.type = EXTCON_TYPE_USB,\n\t\t.id = EXTCON_USB,\n\t\t.name = \"USB\",\n\t},\n\t[EXTCON_USB_HOST] = {\n\t\t.type = EXTCON_TYPE_USB,\n\t\t.id = EXTCON_USB_HOST,\n\t\t.name = \"USB-HOST\",\n\t},\n\n\t \n\t[EXTCON_CHG_USB_SDP] = {\n\t\t.type = EXTCON_TYPE_CHG | EXTCON_TYPE_USB,\n\t\t.id = EXTCON_CHG_USB_SDP,\n\t\t.name = \"SDP\",\n\t},\n\t[EXTCON_CHG_USB_DCP] = {\n\t\t.type = EXTCON_TYPE_CHG | EXTCON_TYPE_USB,\n\t\t.id = EXTCON_CHG_USB_DCP,\n\t\t.name = \"DCP\",\n\t},\n\t[EXTCON_CHG_USB_CDP] = {\n\t\t.type = EXTCON_TYPE_CHG | EXTCON_TYPE_USB,\n\t\t.id = EXTCON_CHG_USB_CDP,\n\t\t.name = \"CDP\",\n\t},\n\t[EXTCON_CHG_USB_ACA] = {\n\t\t.type = EXTCON_TYPE_CHG | EXTCON_TYPE_USB,\n\t\t.id = EXTCON_CHG_USB_ACA,\n\t\t.name = \"ACA\",\n\t},\n\t[EXTCON_CHG_USB_FAST] = {\n\t\t.type = EXTCON_TYPE_CHG | EXTCON_TYPE_USB,\n\t\t.id = EXTCON_CHG_USB_FAST,\n\t\t.name = \"FAST-CHARGER\",\n\t},\n\t[EXTCON_CHG_USB_SLOW] = {\n\t\t.type = EXTCON_TYPE_CHG | EXTCON_TYPE_USB,\n\t\t.id = EXTCON_CHG_USB_SLOW,\n\t\t.name = \"SLOW-CHARGER\",\n\t},\n\t[EXTCON_CHG_WPT] = {\n\t\t.type = EXTCON_TYPE_CHG,\n\t\t.id = EXTCON_CHG_WPT,\n\t\t.name = \"WPT\",\n\t},\n\t[EXTCON_CHG_USB_PD] = {\n\t\t.type = EXTCON_TYPE_CHG | EXTCON_TYPE_USB,\n\t\t.id = EXTCON_CHG_USB_PD,\n\t\t.name = \"PD\",\n\t},\n\n\t \n\t[EXTCON_JACK_MICROPHONE] = {\n\t\t.type = EXTCON_TYPE_JACK,\n\t\t.id = EXTCON_JACK_MICROPHONE,\n\t\t.name = \"MICROPHONE\",\n\t},\n\t[EXTCON_JACK_HEADPHONE] = {\n\t\t.type = EXTCON_TYPE_JACK,\n\t\t.id = EXTCON_JACK_HEADPHONE,\n\t\t.name = \"HEADPHONE\",\n\t},\n\t[EXTCON_JACK_LINE_IN] = {\n\t\t.type = EXTCON_TYPE_JACK,\n\t\t.id = EXTCON_JACK_LINE_IN,\n\t\t.name = \"LINE-IN\",\n\t},\n\t[EXTCON_JACK_LINE_OUT] = {\n\t\t.type = EXTCON_TYPE_JACK,\n\t\t.id = EXTCON_JACK_LINE_OUT,\n\t\t.name = \"LINE-OUT\",\n\t},\n\t[EXTCON_JACK_VIDEO_IN] = {\n\t\t.type = EXTCON_TYPE_JACK,\n\t\t.id = EXTCON_JACK_VIDEO_IN,\n\t\t.name = \"VIDEO-IN\",\n\t},\n\t[EXTCON_JACK_VIDEO_OUT] = {\n\t\t.type = EXTCON_TYPE_JACK,\n\t\t.id = EXTCON_JACK_VIDEO_OUT,\n\t\t.name = \"VIDEO-OUT\",\n\t},\n\t[EXTCON_JACK_SPDIF_IN] = {\n\t\t.type = EXTCON_TYPE_JACK,\n\t\t.id = EXTCON_JACK_SPDIF_IN,\n\t\t.name = \"SPDIF-IN\",\n\t},\n\t[EXTCON_JACK_SPDIF_OUT] = {\n\t\t.type = EXTCON_TYPE_JACK,\n\t\t.id = EXTCON_JACK_SPDIF_OUT,\n\t\t.name = \"SPDIF-OUT\",\n\t},\n\n\t \n\t[EXTCON_DISP_HDMI] = {\n\t\t.type = EXTCON_TYPE_DISP,\n\t\t.id = EXTCON_DISP_HDMI,\n\t\t.name = \"HDMI\",\n\t},\n\t[EXTCON_DISP_MHL] = {\n\t\t.type = EXTCON_TYPE_DISP,\n\t\t.id = EXTCON_DISP_MHL,\n\t\t.name = \"MHL\",\n\t},\n\t[EXTCON_DISP_DVI] = {\n\t\t.type = EXTCON_TYPE_DISP,\n\t\t.id = EXTCON_DISP_DVI,\n\t\t.name = \"DVI\",\n\t},\n\t[EXTCON_DISP_VGA] = {\n\t\t.type = EXTCON_TYPE_DISP,\n\t\t.id = EXTCON_DISP_VGA,\n\t\t.name = \"VGA\",\n\t},\n\t[EXTCON_DISP_DP] = {\n\t\t.type = EXTCON_TYPE_DISP | EXTCON_TYPE_USB,\n\t\t.id = EXTCON_DISP_DP,\n\t\t.name = \"DP\",\n\t},\n\t[EXTCON_DISP_HMD] = {\n\t\t.type = EXTCON_TYPE_DISP | EXTCON_TYPE_USB,\n\t\t.id = EXTCON_DISP_HMD,\n\t\t.name = \"HMD\",\n\t},\n\t[EXTCON_DISP_CVBS] = {\n\t\t.type = EXTCON_TYPE_DISP,\n\t\t.id = EXTCON_DISP_CVBS,\n\t\t.name = \"CVBS\",\n\t},\n\t[EXTCON_DISP_EDP] = {\n\t\t.type = EXTCON_TYPE_DISP,\n\t\t.id = EXTCON_DISP_EDP,\n\t\t.name = \"EDP\",\n\t},\n\n\t \n\t[EXTCON_DOCK] = {\n\t\t.type = EXTCON_TYPE_MISC,\n\t\t.id = EXTCON_DOCK,\n\t\t.name = \"DOCK\",\n\t},\n\t[EXTCON_JIG] = {\n\t\t.type = EXTCON_TYPE_MISC,\n\t\t.id = EXTCON_JIG,\n\t\t.name = \"JIG\",\n\t},\n\t[EXTCON_MECHANICAL] = {\n\t\t.type = EXTCON_TYPE_MISC,\n\t\t.id = EXTCON_MECHANICAL,\n\t\t.name = \"MECHANICAL\",\n\t},\n\n\t{   }\n};\n\n \nstruct extcon_cable {\n\tstruct extcon_dev *edev;\n\tint cable_index;\n\n\tstruct attribute_group attr_g;\n\tstruct device_attribute attr_name;\n\tstruct device_attribute attr_state;\n\n\tstruct attribute *attrs[3];  \n\n\tunion extcon_property_value usb_propval[EXTCON_PROP_USB_CNT];\n\tunion extcon_property_value chg_propval[EXTCON_PROP_CHG_CNT];\n\tunion extcon_property_value jack_propval[EXTCON_PROP_JACK_CNT];\n\tunion extcon_property_value disp_propval[EXTCON_PROP_DISP_CNT];\n\n\tDECLARE_BITMAP(usb_bits, EXTCON_PROP_USB_CNT);\n\tDECLARE_BITMAP(chg_bits, EXTCON_PROP_CHG_CNT);\n\tDECLARE_BITMAP(jack_bits, EXTCON_PROP_JACK_CNT);\n\tDECLARE_BITMAP(disp_bits, EXTCON_PROP_DISP_CNT);\n};\n\nstatic struct class *extcon_class;\n\nstatic DEFINE_IDA(extcon_dev_ids);\nstatic LIST_HEAD(extcon_dev_list);\nstatic DEFINE_MUTEX(extcon_dev_list_lock);\n\nstatic int check_mutually_exclusive(struct extcon_dev *edev, u32 new_state)\n{\n\tint i;\n\n\tif (!edev->mutually_exclusive)\n\t\treturn 0;\n\n\tfor (i = 0; edev->mutually_exclusive[i]; i++) {\n\t\tint weight;\n\t\tu32 correspondants = new_state & edev->mutually_exclusive[i];\n\n\t\t \n\t\tweight = hweight32(correspondants);\n\t\tif (weight > 1)\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int find_cable_index_by_id(struct extcon_dev *edev, const unsigned int id)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < edev->max_supported; i++) {\n\t\tif (edev->supported_cable[i] == id)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int get_extcon_type(unsigned int prop)\n{\n\tswitch (prop) {\n\tcase EXTCON_PROP_USB_MIN ... EXTCON_PROP_USB_MAX:\n\t\treturn EXTCON_TYPE_USB;\n\tcase EXTCON_PROP_CHG_MIN ... EXTCON_PROP_CHG_MAX:\n\t\treturn EXTCON_TYPE_CHG;\n\tcase EXTCON_PROP_JACK_MIN ... EXTCON_PROP_JACK_MAX:\n\t\treturn EXTCON_TYPE_JACK;\n\tcase EXTCON_PROP_DISP_MIN ... EXTCON_PROP_DISP_MAX:\n\t\treturn EXTCON_TYPE_DISP;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic bool is_extcon_attached(struct extcon_dev *edev, unsigned int index)\n{\n\treturn !!(edev->state & BIT(index));\n}\n\nstatic bool is_extcon_changed(struct extcon_dev *edev, int index,\n\t\t\t\tbool new_state)\n{\n\tint state = !!(edev->state & BIT(index));\n\treturn (state != new_state);\n}\n\nstatic bool is_extcon_property_supported(unsigned int id, unsigned int prop)\n{\n\tint type;\n\n\t \n\ttype = get_extcon_type(prop);\n\tif (type < 0)\n\t\treturn false;\n\n\t \n\treturn !!(extcon_info[id].type & type);\n}\n\nstatic int is_extcon_property_capability(struct extcon_dev *edev,\n\t\t\t\tunsigned int id, int index,unsigned int prop)\n{\n\tstruct extcon_cable *cable;\n\tint type, ret;\n\n\t \n\ttype = get_extcon_type(prop);\n\tif (type < 0)\n\t\treturn type;\n\n\tcable = &edev->cables[index];\n\n\tswitch (type) {\n\tcase EXTCON_TYPE_USB:\n\t\tret = test_bit(prop - EXTCON_PROP_USB_MIN, cable->usb_bits);\n\t\tbreak;\n\tcase EXTCON_TYPE_CHG:\n\t\tret = test_bit(prop - EXTCON_PROP_CHG_MIN, cable->chg_bits);\n\t\tbreak;\n\tcase EXTCON_TYPE_JACK:\n\t\tret = test_bit(prop - EXTCON_PROP_JACK_MIN, cable->jack_bits);\n\t\tbreak;\n\tcase EXTCON_TYPE_DISP:\n\t\tret = test_bit(prop - EXTCON_PROP_DISP_MIN, cable->disp_bits);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void init_property(struct extcon_dev *edev, unsigned int id, int index)\n{\n\tunsigned int type = extcon_info[id].type;\n\tstruct extcon_cable *cable = &edev->cables[index];\n\n\tif (EXTCON_TYPE_USB & type)\n\t\tmemset(cable->usb_propval, 0, sizeof(cable->usb_propval));\n\tif (EXTCON_TYPE_CHG & type)\n\t\tmemset(cable->chg_propval, 0, sizeof(cable->chg_propval));\n\tif (EXTCON_TYPE_JACK & type)\n\t\tmemset(cable->jack_propval, 0, sizeof(cable->jack_propval));\n\tif (EXTCON_TYPE_DISP & type)\n\t\tmemset(cable->disp_propval, 0, sizeof(cable->disp_propval));\n}\n\nstatic ssize_t state_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint i, count = 0;\n\tstruct extcon_dev *edev = dev_get_drvdata(dev);\n\n\tif (edev->max_supported == 0)\n\t\treturn sysfs_emit(buf, \"%u\\n\", edev->state);\n\n\tfor (i = 0; i < edev->max_supported; i++) {\n\t\tcount += sysfs_emit_at(buf, count, \"%s=%d\\n\",\n\t\t\t\t       extcon_info[edev->supported_cable[i]].name,\n\t\t\t\t       !!(edev->state & BIT(i)));\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RO(state);\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct extcon_dev *edev = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", edev->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t cable_name_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct extcon_cable *cable = container_of(attr, struct extcon_cable,\n\t\t\t\t\t\t  attr_name);\n\tint i = cable->cable_index;\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t  extcon_info[cable->edev->supported_cable[i]].name);\n}\n\nstatic ssize_t cable_state_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct extcon_cable *cable = container_of(attr, struct extcon_cable,\n\t\t\t\t\t\t  attr_state);\n\n\tint i = cable->cable_index;\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  extcon_get_state(cable->edev, cable->edev->supported_cable[i]));\n}\n\n \nint extcon_sync(struct extcon_dev *edev, unsigned int id)\n{\n\tchar name_buf[120];\n\tchar state_buf[120];\n\tchar *prop_buf;\n\tchar *envp[3];\n\tint env_offset = 0;\n\tint length;\n\tint index;\n\tint state;\n\tunsigned long flags;\n\n\tif (!edev)\n\t\treturn -EINVAL;\n\n\tindex = find_cable_index_by_id(edev, id);\n\tif (index < 0)\n\t\treturn index;\n\n\tspin_lock_irqsave(&edev->lock, flags);\n\tstate = !!(edev->state & BIT(index));\n\tspin_unlock_irqrestore(&edev->lock, flags);\n\n\t \n\traw_notifier_call_chain(&edev->nh[index], state, edev);\n\n\t \n\traw_notifier_call_chain(&edev->nh_all, state, edev);\n\n\tspin_lock_irqsave(&edev->lock, flags);\n\t \n\tprop_buf = (char *)get_zeroed_page(GFP_ATOMIC);\n\tif (!prop_buf) {\n\t\t \n\t\tspin_unlock_irqrestore(&edev->lock, flags);\n\n\t\tdev_err(&edev->dev, \"out of memory in extcon_set_state\\n\");\n\t\tkobject_uevent(&edev->dev.kobj, KOBJ_CHANGE);\n\n\t\treturn -ENOMEM;\n\t}\n\n\tlength = name_show(&edev->dev, NULL, prop_buf);\n\tif (length > 0) {\n\t\tif (prop_buf[length - 1] == '\\n')\n\t\t\tprop_buf[length - 1] = 0;\n\t\tsnprintf(name_buf, sizeof(name_buf), \"NAME=%s\", prop_buf);\n\t\tenvp[env_offset++] = name_buf;\n\t}\n\n\tlength = state_show(&edev->dev, NULL, prop_buf);\n\tif (length > 0) {\n\t\tif (prop_buf[length - 1] == '\\n')\n\t\t\tprop_buf[length - 1] = 0;\n\t\tsnprintf(state_buf, sizeof(state_buf), \"STATE=%s\", prop_buf);\n\t\tenvp[env_offset++] = state_buf;\n\t}\n\tenvp[env_offset] = NULL;\n\n\t \n\tspin_unlock_irqrestore(&edev->lock, flags);\n\tkobject_uevent_env(&edev->dev.kobj, KOBJ_CHANGE, envp);\n\tfree_page((unsigned long)prop_buf);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(extcon_sync);\n\n \nint extcon_get_state(struct extcon_dev *edev, const unsigned int id)\n{\n\tint index, state;\n\tunsigned long flags;\n\n\tif (!edev)\n\t\treturn -EINVAL;\n\n\tindex = find_cable_index_by_id(edev, id);\n\tif (index < 0)\n\t\treturn index;\n\n\tspin_lock_irqsave(&edev->lock, flags);\n\tstate = is_extcon_attached(edev, index);\n\tspin_unlock_irqrestore(&edev->lock, flags);\n\n\treturn state;\n}\nEXPORT_SYMBOL_GPL(extcon_get_state);\n\n \nint extcon_set_state(struct extcon_dev *edev, unsigned int id, bool state)\n{\n\tunsigned long flags;\n\tint index, ret = 0;\n\n\tif (!edev)\n\t\treturn -EINVAL;\n\n\tindex = find_cable_index_by_id(edev, id);\n\tif (index < 0)\n\t\treturn index;\n\n\tspin_lock_irqsave(&edev->lock, flags);\n\n\t \n\tif (!is_extcon_changed(edev, index, state))\n\t\tgoto out;\n\n\tif (check_mutually_exclusive(edev,\n\t\t(edev->state & ~BIT(index)) | (state & BIT(index)))) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!state)\n\t\tinit_property(edev, id, index);\n\n\t \n\tif (state)\n\t\tedev->state |= BIT(index);\n\telse\n\t\tedev->state &= ~(BIT(index));\nout:\n\tspin_unlock_irqrestore(&edev->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(extcon_set_state);\n\n \nint extcon_set_state_sync(struct extcon_dev *edev, unsigned int id, bool state)\n{\n\tint ret;\n\n\tret = extcon_set_state(edev, id, state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn extcon_sync(edev, id);\n}\nEXPORT_SYMBOL_GPL(extcon_set_state_sync);\n\n \nint extcon_get_property(struct extcon_dev *edev, unsigned int id,\n\t\t\t\tunsigned int prop,\n\t\t\t\tunion extcon_property_value *prop_val)\n{\n\tstruct extcon_cable *cable;\n\tunsigned long flags;\n\tint index, ret = 0;\n\n\t*prop_val = (union extcon_property_value){0};\n\n\tif (!edev)\n\t\treturn -EINVAL;\n\n\t \n\tif (!is_extcon_property_supported(id, prop))\n\t\treturn -EINVAL;\n\n\t \n\tindex = find_cable_index_by_id(edev, id);\n\tif (index < 0)\n\t\treturn index;\n\n\tspin_lock_irqsave(&edev->lock, flags);\n\n\t \n\tif (!is_extcon_property_capability(edev, id, index, prop)) {\n\t\tspin_unlock_irqrestore(&edev->lock, flags);\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (!is_extcon_attached(edev, index)) {\n\t\tspin_unlock_irqrestore(&edev->lock, flags);\n\t\treturn 0;\n\t}\n\n\tcable = &edev->cables[index];\n\n\t \n\tswitch (prop) {\n\tcase EXTCON_PROP_USB_MIN ... EXTCON_PROP_USB_MAX:\n\t\t*prop_val = cable->usb_propval[prop - EXTCON_PROP_USB_MIN];\n\t\tbreak;\n\tcase EXTCON_PROP_CHG_MIN ... EXTCON_PROP_CHG_MAX:\n\t\t*prop_val = cable->chg_propval[prop - EXTCON_PROP_CHG_MIN];\n\t\tbreak;\n\tcase EXTCON_PROP_JACK_MIN ... EXTCON_PROP_JACK_MAX:\n\t\t*prop_val = cable->jack_propval[prop - EXTCON_PROP_JACK_MIN];\n\t\tbreak;\n\tcase EXTCON_PROP_DISP_MIN ... EXTCON_PROP_DISP_MAX:\n\t\t*prop_val = cable->disp_propval[prop - EXTCON_PROP_DISP_MIN];\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&edev->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(extcon_get_property);\n\n \nint extcon_set_property(struct extcon_dev *edev, unsigned int id,\n\t\t\t\tunsigned int prop,\n\t\t\t\tunion extcon_property_value prop_val)\n{\n\tstruct extcon_cable *cable;\n\tunsigned long flags;\n\tint index, ret = 0;\n\n\tif (!edev)\n\t\treturn -EINVAL;\n\n\t \n\tif (!is_extcon_property_supported(id, prop))\n\t\treturn -EINVAL;\n\n\t \n\tindex = find_cable_index_by_id(edev, id);\n\tif (index < 0)\n\t\treturn index;\n\n\tspin_lock_irqsave(&edev->lock, flags);\n\n\t \n\tif (!is_extcon_property_capability(edev, id, index, prop)) {\n\t\tspin_unlock_irqrestore(&edev->lock, flags);\n\t\treturn -EPERM;\n\t}\n\n\tcable = &edev->cables[index];\n\n\t \n\tswitch (prop) {\n\tcase EXTCON_PROP_USB_MIN ... EXTCON_PROP_USB_MAX:\n\t\tcable->usb_propval[prop - EXTCON_PROP_USB_MIN] = prop_val;\n\t\tbreak;\n\tcase EXTCON_PROP_CHG_MIN ... EXTCON_PROP_CHG_MAX:\n\t\tcable->chg_propval[prop - EXTCON_PROP_CHG_MIN] = prop_val;\n\t\tbreak;\n\tcase EXTCON_PROP_JACK_MIN ... EXTCON_PROP_JACK_MAX:\n\t\tcable->jack_propval[prop - EXTCON_PROP_JACK_MIN] = prop_val;\n\t\tbreak;\n\tcase EXTCON_PROP_DISP_MIN ... EXTCON_PROP_DISP_MAX:\n\t\tcable->disp_propval[prop - EXTCON_PROP_DISP_MIN] = prop_val;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&edev->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(extcon_set_property);\n\n \nint extcon_set_property_sync(struct extcon_dev *edev, unsigned int id,\n\t\t\t\tunsigned int prop,\n\t\t\t\tunion extcon_property_value prop_val)\n{\n\tint ret;\n\n\tret = extcon_set_property(edev, id, prop, prop_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn extcon_sync(edev, id);\n}\nEXPORT_SYMBOL_GPL(extcon_set_property_sync);\n\n \nint extcon_get_property_capability(struct extcon_dev *edev, unsigned int id,\n\t\t\t\t\tunsigned int prop)\n{\n\tint index;\n\n\tif (!edev)\n\t\treturn -EINVAL;\n\n\t \n\tif (!is_extcon_property_supported(id, prop))\n\t\treturn -EINVAL;\n\n\t \n\tindex = find_cable_index_by_id(edev, id);\n\tif (index < 0)\n\t\treturn index;\n\n\treturn is_extcon_property_capability(edev, id, index, prop);\n}\nEXPORT_SYMBOL_GPL(extcon_get_property_capability);\n\n \nint extcon_set_property_capability(struct extcon_dev *edev, unsigned int id,\n\t\t\t\t\tunsigned int prop)\n{\n\tstruct extcon_cable *cable;\n\tint index, type, ret = 0;\n\n\tif (!edev)\n\t\treturn -EINVAL;\n\n\t \n\tif (!is_extcon_property_supported(id, prop))\n\t\treturn -EINVAL;\n\n\t \n\tindex = find_cable_index_by_id(edev, id);\n\tif (index < 0)\n\t\treturn index;\n\n\ttype = get_extcon_type(prop);\n\tif (type < 0)\n\t\treturn type;\n\n\tcable = &edev->cables[index];\n\n\tswitch (type) {\n\tcase EXTCON_TYPE_USB:\n\t\t__set_bit(prop - EXTCON_PROP_USB_MIN, cable->usb_bits);\n\t\tbreak;\n\tcase EXTCON_TYPE_CHG:\n\t\t__set_bit(prop - EXTCON_PROP_CHG_MIN, cable->chg_bits);\n\t\tbreak;\n\tcase EXTCON_TYPE_JACK:\n\t\t__set_bit(prop - EXTCON_PROP_JACK_MIN, cable->jack_bits);\n\t\tbreak;\n\tcase EXTCON_TYPE_DISP:\n\t\t__set_bit(prop - EXTCON_PROP_DISP_MIN, cable->disp_bits);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(extcon_set_property_capability);\n\n \nstruct extcon_dev *extcon_get_extcon_dev(const char *extcon_name)\n{\n\tstruct extcon_dev *sd;\n\n\tif (!extcon_name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmutex_lock(&extcon_dev_list_lock);\n\tlist_for_each_entry(sd, &extcon_dev_list, entry) {\n\t\tif (!strcmp(sd->name, extcon_name))\n\t\t\tgoto out;\n\t}\n\tsd = ERR_PTR(-EPROBE_DEFER);\nout:\n\tmutex_unlock(&extcon_dev_list_lock);\n\treturn sd;\n}\nEXPORT_SYMBOL_GPL(extcon_get_extcon_dev);\n\n \nint extcon_register_notifier(struct extcon_dev *edev, unsigned int id,\n\t\t\t     struct notifier_block *nb)\n{\n\tunsigned long flags;\n\tint ret, idx;\n\n\tif (!edev || !nb)\n\t\treturn -EINVAL;\n\n\tidx = find_cable_index_by_id(edev, id);\n\tif (idx < 0)\n\t\treturn idx;\n\n\tspin_lock_irqsave(&edev->lock, flags);\n\tret = raw_notifier_chain_register(&edev->nh[idx], nb);\n\tspin_unlock_irqrestore(&edev->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(extcon_register_notifier);\n\n \nint extcon_unregister_notifier(struct extcon_dev *edev, unsigned int id,\n\t\t\t\tstruct notifier_block *nb)\n{\n\tunsigned long flags;\n\tint ret, idx;\n\n\tif (!edev || !nb)\n\t\treturn -EINVAL;\n\n\tidx = find_cable_index_by_id(edev, id);\n\tif (idx < 0)\n\t\treturn idx;\n\n\tspin_lock_irqsave(&edev->lock, flags);\n\tret = raw_notifier_chain_unregister(&edev->nh[idx], nb);\n\tspin_unlock_irqrestore(&edev->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(extcon_unregister_notifier);\n\n \nint extcon_register_notifier_all(struct extcon_dev *edev,\n\t\t\t\tstruct notifier_block *nb)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tif (!edev || !nb)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&edev->lock, flags);\n\tret = raw_notifier_chain_register(&edev->nh_all, nb);\n\tspin_unlock_irqrestore(&edev->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(extcon_register_notifier_all);\n\n \nint extcon_unregister_notifier_all(struct extcon_dev *edev,\n\t\t\t\tstruct notifier_block *nb)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tif (!edev || !nb)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&edev->lock, flags);\n\tret = raw_notifier_chain_unregister(&edev->nh_all, nb);\n\tspin_unlock_irqrestore(&edev->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(extcon_unregister_notifier_all);\n\nstatic struct attribute *extcon_attrs[] = {\n\t&dev_attr_state.attr,\n\t&dev_attr_name.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(extcon);\n\nstatic int create_extcon_class(void)\n{\n\tif (extcon_class)\n\t\treturn 0;\n\n\textcon_class = class_create(\"extcon\");\n\tif (IS_ERR(extcon_class))\n\t\treturn PTR_ERR(extcon_class);\n\textcon_class->dev_groups = extcon_groups;\n\n\treturn 0;\n}\n\nstatic void extcon_dev_release(struct device *dev)\n{\n}\n\nstatic const char *muex_name = \"mutually_exclusive\";\nstatic void dummy_sysfs_dev_release(struct device *dev)\n{\n}\n\n \nstruct extcon_dev *extcon_dev_allocate(const unsigned int *supported_cable)\n{\n\tstruct extcon_dev *edev;\n\n\tif (!supported_cable)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tedev = kzalloc(sizeof(*edev), GFP_KERNEL);\n\tif (!edev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tedev->max_supported = 0;\n\tedev->supported_cable = supported_cable;\n\n\treturn edev;\n}\n\n \nvoid extcon_dev_free(struct extcon_dev *edev)\n{\n\tkfree(edev);\n}\nEXPORT_SYMBOL_GPL(extcon_dev_free);\n\n \nstatic int extcon_alloc_cables(struct extcon_dev *edev)\n{\n\tint index;\n\tchar *str;\n\tstruct extcon_cable *cable;\n\n\tif (!edev)\n\t\treturn -EINVAL;\n\n\tif (!edev->max_supported)\n\t\treturn 0;\n\n\tedev->cables = kcalloc(edev->max_supported, sizeof(*edev->cables),\n\t\t\t       GFP_KERNEL);\n\tif (!edev->cables)\n\t\treturn -ENOMEM;\n\n\tfor (index = 0; index < edev->max_supported; index++) {\n\t\tcable = &edev->cables[index];\n\n\t\tstr = kasprintf(GFP_KERNEL, \"cable.%d\", index);\n\t\tif (!str) {\n\t\t\tfor (index--; index >= 0; index--) {\n\t\t\t\tcable = &edev->cables[index];\n\t\t\t\tkfree(cable->attr_g.name);\n\t\t\t}\n\n\t\t\tkfree(edev->cables);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcable->edev = edev;\n\t\tcable->cable_index = index;\n\t\tcable->attrs[0] = &cable->attr_name.attr;\n\t\tcable->attrs[1] = &cable->attr_state.attr;\n\t\tcable->attrs[2] = NULL;\n\t\tcable->attr_g.name = str;\n\t\tcable->attr_g.attrs = cable->attrs;\n\n\t\tsysfs_attr_init(&cable->attr_name.attr);\n\t\tcable->attr_name.attr.name = \"name\";\n\t\tcable->attr_name.attr.mode = 0444;\n\t\tcable->attr_name.show = cable_name_show;\n\n\t\tsysfs_attr_init(&cable->attr_state.attr);\n\t\tcable->attr_state.attr.name = \"state\";\n\t\tcable->attr_state.attr.mode = 0444;\n\t\tcable->attr_state.show = cable_state_show;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int extcon_alloc_muex(struct extcon_dev *edev)\n{\n\tchar *name;\n\tint index;\n\n\tif (!edev)\n\t\treturn -EINVAL;\n\n\tif (!(edev->max_supported && edev->mutually_exclusive))\n\t\treturn 0;\n\n\t \n\tfor (index = 0; edev->mutually_exclusive[index]; index++)\n\t\t;\n\n\tedev->attrs_muex = kcalloc(index + 1, sizeof(*edev->attrs_muex),\n\t\t\t\t   GFP_KERNEL);\n\tif (!edev->attrs_muex)\n\t\treturn -ENOMEM;\n\n\tedev->d_attrs_muex = kcalloc(index, sizeof(*edev->d_attrs_muex),\n\t\t\t\t     GFP_KERNEL);\n\tif (!edev->d_attrs_muex) {\n\t\tkfree(edev->attrs_muex);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (index = 0; edev->mutually_exclusive[index]; index++) {\n\t\tname = kasprintf(GFP_KERNEL, \"0x%x\",\n\t\t\t\t edev->mutually_exclusive[index]);\n\t\tif (!name) {\n\t\t\tfor (index--; index >= 0; index--)\n\t\t\t\tkfree(edev->d_attrs_muex[index].attr.name);\n\n\t\t\tkfree(edev->d_attrs_muex);\n\t\t\tkfree(edev->attrs_muex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsysfs_attr_init(&edev->d_attrs_muex[index].attr);\n\t\tedev->d_attrs_muex[index].attr.name = name;\n\t\tedev->d_attrs_muex[index].attr.mode = 0000;\n\t\tedev->attrs_muex[index] = &edev->d_attrs_muex[index].attr;\n\t}\n\tedev->attr_g_muex.name = muex_name;\n\tedev->attr_g_muex.attrs = edev->attrs_muex;\n\n\treturn 0;\n}\n\n \nstatic int extcon_alloc_groups(struct extcon_dev *edev)\n{\n\tint index;\n\n\tif (!edev)\n\t\treturn -EINVAL;\n\n\tif (!edev->max_supported)\n\t\treturn 0;\n\n\tedev->extcon_dev_type.groups = kcalloc(edev->max_supported + 2,\n\t\t\t\t\t  sizeof(*edev->extcon_dev_type.groups),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!edev->extcon_dev_type.groups)\n\t\treturn -ENOMEM;\n\n\tedev->extcon_dev_type.name = dev_name(&edev->dev);\n\tedev->extcon_dev_type.release = dummy_sysfs_dev_release;\n\n\tfor (index = 0; index < edev->max_supported; index++)\n\t\tedev->extcon_dev_type.groups[index] = &edev->cables[index].attr_g;\n\n\tif (edev->mutually_exclusive)\n\t\tedev->extcon_dev_type.groups[index] = &edev->attr_g_muex;\n\n\tedev->dev.type = &edev->extcon_dev_type;\n\n\treturn 0;\n}\n\n \nint extcon_dev_register(struct extcon_dev *edev)\n{\n\tint ret, index;\n\n\tret = create_extcon_class();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!edev || !edev->supported_cable)\n\t\treturn -EINVAL;\n\n\tfor (index = 0; edev->supported_cable[index] != EXTCON_NONE; index++);\n\n\tedev->max_supported = index;\n\tif (index > SUPPORTED_CABLE_MAX) {\n\t\tdev_err(&edev->dev,\n\t\t\t\"exceed the maximum number of supported cables\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tedev->dev.class = extcon_class;\n\tedev->dev.release = extcon_dev_release;\n\n\tedev->name = dev_name(edev->dev.parent);\n\tif (IS_ERR_OR_NULL(edev->name)) {\n\t\tdev_err(&edev->dev,\n\t\t\t\"extcon device name is null\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = ida_alloc(&extcon_dev_ids, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tedev->id = ret;\n\n\tdev_set_name(&edev->dev, \"extcon%d\", edev->id);\n\n\tret = extcon_alloc_cables(edev);\n\tif (ret < 0)\n\t\tgoto err_alloc_cables;\n\n\tret = extcon_alloc_muex(edev);\n\tif (ret < 0)\n\t\tgoto err_alloc_muex;\n\n\tret = extcon_alloc_groups(edev);\n\tif (ret < 0)\n\t\tgoto err_alloc_groups;\n\n\tspin_lock_init(&edev->lock);\n\tif (edev->max_supported) {\n\t\tedev->nh = kcalloc(edev->max_supported, sizeof(*edev->nh),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!edev->nh) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_alloc_nh;\n\t\t}\n\t}\n\n\tfor (index = 0; index < edev->max_supported; index++)\n\t\tRAW_INIT_NOTIFIER_HEAD(&edev->nh[index]);\n\n\tRAW_INIT_NOTIFIER_HEAD(&edev->nh_all);\n\n\tdev_set_drvdata(&edev->dev, edev);\n\tedev->state = 0;\n\n\tret = device_register(&edev->dev);\n\tif (ret) {\n\t\tput_device(&edev->dev);\n\t\tgoto err_dev;\n\t}\n\n\tmutex_lock(&extcon_dev_list_lock);\n\tlist_add(&edev->entry, &extcon_dev_list);\n\tmutex_unlock(&extcon_dev_list_lock);\n\n\treturn 0;\n\nerr_dev:\n\tif (edev->max_supported)\n\t\tkfree(edev->nh);\nerr_alloc_nh:\n\tif (edev->max_supported)\n\t\tkfree(edev->extcon_dev_type.groups);\nerr_alloc_groups:\n\tif (edev->max_supported && edev->mutually_exclusive) {\n\t\tfor (index = 0; edev->mutually_exclusive[index]; index++)\n\t\t\tkfree(edev->d_attrs_muex[index].attr.name);\n\t\tkfree(edev->d_attrs_muex);\n\t\tkfree(edev->attrs_muex);\n\t}\nerr_alloc_muex:\n\tfor (index = 0; index < edev->max_supported; index++)\n\t\tkfree(edev->cables[index].attr_g.name);\n\tif (edev->max_supported)\n\t\tkfree(edev->cables);\nerr_alloc_cables:\n\tida_free(&extcon_dev_ids, edev->id);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(extcon_dev_register);\n\n \nvoid extcon_dev_unregister(struct extcon_dev *edev)\n{\n\tint index;\n\n\tif (!edev)\n\t\treturn;\n\n\tmutex_lock(&extcon_dev_list_lock);\n\tlist_del(&edev->entry);\n\tmutex_unlock(&extcon_dev_list_lock);\n\n\tif (!get_device(&edev->dev)) {\n\t\tdev_err(&edev->dev, \"Failed to unregister extcon_dev\\n\");\n\t\treturn;\n\t}\n\n\tida_free(&extcon_dev_ids, edev->id);\n\n\tdevice_unregister(&edev->dev);\n\n\tif (edev->mutually_exclusive && edev->max_supported) {\n\t\tfor (index = 0; edev->mutually_exclusive[index];\n\t\t\t\tindex++)\n\t\t\tkfree(edev->d_attrs_muex[index].attr.name);\n\t\tkfree(edev->d_attrs_muex);\n\t\tkfree(edev->attrs_muex);\n\t}\n\n\tfor (index = 0; index < edev->max_supported; index++)\n\t\tkfree(edev->cables[index].attr_g.name);\n\n\tif (edev->max_supported) {\n\t\tkfree(edev->extcon_dev_type.groups);\n\t\tkfree(edev->cables);\n\t\tkfree(edev->nh);\n\t}\n\n\tput_device(&edev->dev);\n}\nEXPORT_SYMBOL_GPL(extcon_dev_unregister);\n\n#ifdef CONFIG_OF\n\n \nstruct extcon_dev *extcon_find_edev_by_node(struct device_node *node)\n{\n\tstruct extcon_dev *edev;\n\n\tmutex_lock(&extcon_dev_list_lock);\n\tlist_for_each_entry(edev, &extcon_dev_list, entry)\n\t\tif (edev->dev.parent && device_match_of_node(edev->dev.parent, node))\n\t\t\tgoto out;\n\tedev = ERR_PTR(-EPROBE_DEFER);\nout:\n\tmutex_unlock(&extcon_dev_list_lock);\n\n\treturn edev;\n}\n\n \nstruct extcon_dev *extcon_get_edev_by_phandle(struct device *dev, int index)\n{\n\tstruct device_node *node, *np = dev_of_node(dev);\n\tstruct extcon_dev *edev;\n\n\tif (!np) {\n\t\tdev_dbg(dev, \"device does not have a device node entry\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tnode = of_parse_phandle(np, \"extcon\", index);\n\tif (!node) {\n\t\tdev_dbg(dev, \"failed to get phandle in %pOF node\\n\", np);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tedev = extcon_find_edev_by_node(node);\n\tof_node_put(node);\n\n\treturn edev;\n}\n\n#else\n\nstruct extcon_dev *extcon_find_edev_by_node(struct device_node *node)\n{\n\treturn ERR_PTR(-ENOSYS);\n}\n\nstruct extcon_dev *extcon_get_edev_by_phandle(struct device *dev, int index)\n{\n\treturn ERR_PTR(-ENOSYS);\n}\n\n#endif  \n\nEXPORT_SYMBOL_GPL(extcon_find_edev_by_node);\nEXPORT_SYMBOL_GPL(extcon_get_edev_by_phandle);\n\n \nconst char *extcon_get_edev_name(struct extcon_dev *edev)\n{\n\treturn !edev ? NULL : edev->name;\n}\nEXPORT_SYMBOL_GPL(extcon_get_edev_name);\n\nstatic int __init extcon_class_init(void)\n{\n\treturn create_extcon_class();\n}\nmodule_init(extcon_class_init);\n\nstatic void __exit extcon_class_exit(void)\n{\n\tclass_destroy(extcon_class);\n}\nmodule_exit(extcon_class_exit);\n\nMODULE_AUTHOR(\"Chanwoo Choi <cw00.choi@samsung.com>\");\nMODULE_AUTHOR(\"MyungJoo Ham <myungjoo.ham@samsung.com>\");\nMODULE_DESCRIPTION(\"External Connector (extcon) framework\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}