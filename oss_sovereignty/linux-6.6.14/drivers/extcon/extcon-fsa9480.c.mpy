{
  "module_name": "extcon-fsa9480.c",
  "hash_id": "f4390206948ce9f3849e9e5c063d60204de796323dff74e3521ee36fd9e69055",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-fsa9480.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/kobject.h>\n#include <linux/extcon-provider.h>\n#include <linux/irqdomain.h>\n#include <linux/regmap.h>\n\n \n#define FSA9480_REG_DEVID               0x01\n#define FSA9480_REG_CTRL                0x02\n#define FSA9480_REG_INT1                0x03\n#define FSA9480_REG_INT2                0x04\n#define FSA9480_REG_INT1_MASK           0x05\n#define FSA9480_REG_INT2_MASK           0x06\n#define FSA9480_REG_ADC                 0x07\n#define FSA9480_REG_TIMING1             0x08\n#define FSA9480_REG_TIMING2             0x09\n#define FSA9480_REG_DEV_T1              0x0a\n#define FSA9480_REG_DEV_T2              0x0b\n#define FSA9480_REG_BTN1                0x0c\n#define FSA9480_REG_BTN2                0x0d\n#define FSA9480_REG_CK                  0x0e\n#define FSA9480_REG_CK_INT1             0x0f\n#define FSA9480_REG_CK_INT2             0x10\n#define FSA9480_REG_CK_INTMASK1         0x11\n#define FSA9480_REG_CK_INTMASK2         0x12\n#define FSA9480_REG_MANSW1              0x13\n#define FSA9480_REG_MANSW2              0x14\n#define FSA9480_REG_END                 0x15\n\n \n#define CON_SWITCH_OPEN         (1 << 4)\n#define CON_RAW_DATA            (1 << 3)\n#define CON_MANUAL_SW           (1 << 2)\n#define CON_WAIT                (1 << 1)\n#define CON_INT_MASK            (1 << 0)\n#define CON_MASK                (CON_SWITCH_OPEN | CON_RAW_DATA | \\\n\t\t\t\t CON_MANUAL_SW | CON_WAIT)\n\n \n#define DEV_USB_OTG             7\n#define DEV_DEDICATED_CHG       6\n#define DEV_USB_CHG             5\n#define DEV_CAR_KIT             4\n#define DEV_UART                3\n#define DEV_USB                 2\n#define DEV_AUDIO_2             1\n#define DEV_AUDIO_1             0\n\n#define DEV_T1_USB_MASK         (DEV_USB_OTG | DEV_USB)\n#define DEV_T1_UART_MASK        (DEV_UART)\n#define DEV_T1_CHARGER_MASK     (DEV_DEDICATED_CHG | DEV_USB_CHG)\n\n \n#define DEV_AV                  14\n#define DEV_TTY                 13\n#define DEV_PPD                 12\n#define DEV_JIG_UART_OFF        11\n#define DEV_JIG_UART_ON         10\n#define DEV_JIG_USB_OFF         9\n#define DEV_JIG_USB_ON          8\n\n#define DEV_T2_USB_MASK         (DEV_JIG_USB_OFF | DEV_JIG_USB_ON)\n#define DEV_T2_UART_MASK        (DEV_JIG_UART_OFF | DEV_JIG_UART_ON)\n#define DEV_T2_JIG_MASK         (DEV_JIG_USB_OFF | DEV_JIG_USB_ON | \\\n\t\t\t\t DEV_JIG_UART_OFF | DEV_JIG_UART_ON)\n\n \n#define SW_VAUDIO               ((4 << 5) | (4 << 2))\n#define SW_UART                 ((3 << 5) | (3 << 2))\n#define SW_AUDIO                ((2 << 5) | (2 << 2))\n#define SW_DHOST                ((1 << 5) | (1 << 2))\n#define SW_AUTO                 ((0 << 5) | (0 << 2))\n\n \n#define INT1_MASK               (0xff << 0)\n#define INT_DETACH              (1 << 1)\n#define INT_ATTACH              (1 << 0)\n\n \n#define INT2_MASK               (0x1f << 0)\n\n \n#define TIMING1_ADC_500MS       (0x6 << 0)\n\nstruct fsa9480_usbsw {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct extcon_dev *edev;\n\tu16 cable;\n};\n\nstatic const unsigned int fsa9480_extcon_cable[] = {\n\tEXTCON_USB_HOST,\n\tEXTCON_USB,\n\tEXTCON_CHG_USB_DCP,\n\tEXTCON_CHG_USB_SDP,\n\tEXTCON_CHG_USB_ACA,\n\tEXTCON_JACK_LINE_OUT,\n\tEXTCON_JACK_VIDEO_OUT,\n\tEXTCON_JIG,\n\n\tEXTCON_NONE,\n};\n\nstatic const u64 cable_types[] = {\n\t[DEV_USB_OTG] = BIT_ULL(EXTCON_USB_HOST),\n\t[DEV_DEDICATED_CHG] = BIT_ULL(EXTCON_USB) | BIT_ULL(EXTCON_CHG_USB_DCP),\n\t[DEV_USB_CHG] = BIT_ULL(EXTCON_USB) | BIT_ULL(EXTCON_CHG_USB_SDP),\n\t[DEV_CAR_KIT] = BIT_ULL(EXTCON_USB) | BIT_ULL(EXTCON_CHG_USB_SDP)\n\t\t\t| BIT_ULL(EXTCON_JACK_LINE_OUT),\n\t[DEV_UART] = BIT_ULL(EXTCON_JIG),\n\t[DEV_USB] = BIT_ULL(EXTCON_USB) | BIT_ULL(EXTCON_CHG_USB_SDP),\n\t[DEV_AUDIO_2] = BIT_ULL(EXTCON_JACK_LINE_OUT),\n\t[DEV_AUDIO_1] = BIT_ULL(EXTCON_JACK_LINE_OUT),\n\t[DEV_AV] = BIT_ULL(EXTCON_JACK_LINE_OUT)\n\t\t   | BIT_ULL(EXTCON_JACK_VIDEO_OUT),\n\t[DEV_TTY] = BIT_ULL(EXTCON_JIG),\n\t[DEV_PPD] = BIT_ULL(EXTCON_JACK_LINE_OUT) | BIT_ULL(EXTCON_CHG_USB_ACA),\n\t[DEV_JIG_UART_OFF] = BIT_ULL(EXTCON_JIG),\n\t[DEV_JIG_UART_ON] = BIT_ULL(EXTCON_JIG),\n\t[DEV_JIG_USB_OFF] = BIT_ULL(EXTCON_USB) | BIT_ULL(EXTCON_JIG),\n\t[DEV_JIG_USB_ON] = BIT_ULL(EXTCON_USB) | BIT_ULL(EXTCON_JIG),\n};\n\n \nstatic bool fsa9480_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase FSA9480_REG_INT1_MASK:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic const struct regmap_config fsa9480_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.volatile_reg\t= fsa9480_volatile_reg,\n\t.max_register\t= FSA9480_REG_END,\n};\n\nstatic int fsa9480_write_reg(struct fsa9480_usbsw *usbsw, int reg, int value)\n{\n\tint ret;\n\n\tret = regmap_write(usbsw->regmap, reg, value);\n\tif (ret < 0)\n\t\tdev_err(usbsw->dev, \"%s: err %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic int fsa9480_read_reg(struct fsa9480_usbsw *usbsw, int reg)\n{\n\tint ret, val;\n\n\tret = regmap_read(usbsw->regmap, reg, &val);\n\tif (ret < 0) {\n\t\tdev_err(usbsw->dev, \"%s: err %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn val;\n}\n\nstatic int fsa9480_read_irq(struct fsa9480_usbsw *usbsw, int *value)\n{\n\tu8 regs[2];\n\tint ret;\n\n\tret = regmap_bulk_read(usbsw->regmap, FSA9480_REG_INT1, regs, 2);\n\tif (ret < 0)\n\t\tdev_err(usbsw->dev, \"%s: err %d\\n\", __func__, ret);\n\n\t*value = regs[1] << 8 | regs[0];\n\treturn ret;\n}\n\nstatic void fsa9480_handle_change(struct fsa9480_usbsw *usbsw,\n\t\t\t\t  u16 mask, bool attached)\n{\n\twhile (mask) {\n\t\tint dev = fls64(mask) - 1;\n\t\tu64 cables = cable_types[dev];\n\n\t\twhile (cables) {\n\t\t\tint cable = fls64(cables) - 1;\n\n\t\t\textcon_set_state_sync(usbsw->edev, cable, attached);\n\t\t\tcables &= ~BIT_ULL(cable);\n\t\t}\n\n\t\tmask &= ~BIT_ULL(dev);\n\t}\n}\n\nstatic void fsa9480_detect_dev(struct fsa9480_usbsw *usbsw)\n{\n\tint val1, val2;\n\tu16 val;\n\n\tval1 = fsa9480_read_reg(usbsw, FSA9480_REG_DEV_T1);\n\tval2 = fsa9480_read_reg(usbsw, FSA9480_REG_DEV_T2);\n\tif (val1 < 0 || val2 < 0) {\n\t\tdev_err(usbsw->dev, \"%s: failed to read registers\", __func__);\n\t\treturn;\n\t}\n\tval = val2 << 8 | val1;\n\n\tdev_info(usbsw->dev, \"dev1: 0x%x, dev2: 0x%x\\n\", val1, val2);\n\n\t \n\tfsa9480_handle_change(usbsw, usbsw->cable & ~val, false);\n\n\t \n\tfsa9480_handle_change(usbsw, val & ~usbsw->cable, true);\n\n\tusbsw->cable = val;\n}\n\nstatic irqreturn_t fsa9480_irq_handler(int irq, void *data)\n{\n\tstruct fsa9480_usbsw *usbsw = data;\n\tint intr = 0;\n\n\t \n\tfsa9480_read_irq(usbsw, &intr);\n\tif (!intr)\n\t\treturn IRQ_NONE;\n\n\t \n\tfsa9480_detect_dev(usbsw);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int fsa9480_probe(struct i2c_client *client)\n{\n\tstruct fsa9480_usbsw *info;\n\tint ret;\n\n\tif (!client->irq) {\n\t\tdev_err(&client->dev, \"no interrupt provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = devm_kzalloc(&client->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->dev = &client->dev;\n\n\ti2c_set_clientdata(client, info);\n\n\t \n\tinfo->edev = devm_extcon_dev_allocate(info->dev,\n\t\t\t\t\t      fsa9480_extcon_cable);\n\tif (IS_ERR(info->edev)) {\n\t\tdev_err(info->dev, \"failed to allocate memory for extcon\\n\");\n\t\tret = -ENOMEM;\n\t\treturn ret;\n\t}\n\n\tret = devm_extcon_dev_register(info->dev, info->edev);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed to register extcon device\\n\");\n\t\treturn ret;\n\t}\n\n\tinfo->regmap = devm_regmap_init_i2c(client, &fsa9480_regmap_config);\n\tif (IS_ERR(info->regmap)) {\n\t\tret = PTR_ERR(info->regmap);\n\t\tdev_err(info->dev, \"failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tfsa9480_write_reg(info, FSA9480_REG_TIMING1, TIMING1_ADC_500MS);\n\n\t \n\tfsa9480_write_reg(info, FSA9480_REG_CTRL, CON_MASK);\n\n\t \n\tfsa9480_write_reg(info, FSA9480_REG_INT1_MASK,\n\t\t\t  INT1_MASK & ~(INT_ATTACH | INT_DETACH));\n\tfsa9480_write_reg(info, FSA9480_REG_INT2_MASK, INT2_MASK);\n\n\tret = devm_request_threaded_irq(info->dev, client->irq, NULL,\n\t\t\t\t\tfsa9480_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t\"fsa9480\", info);\n\tif (ret) {\n\t\tdev_err(info->dev, \"failed to request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tdevice_init_wakeup(info->dev, true);\n\tfsa9480_detect_dev(info);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int fsa9480_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tif (device_may_wakeup(&client->dev) && client->irq)\n\t\tenable_irq_wake(client->irq);\n\n\treturn 0;\n}\n\nstatic int fsa9480_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tif (device_may_wakeup(&client->dev) && client->irq)\n\t\tdisable_irq_wake(client->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops fsa9480_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(fsa9480_suspend, fsa9480_resume)\n};\n\nstatic const struct i2c_device_id fsa9480_id[] = {\n\t{ \"fsa9480\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, fsa9480_id);\n\nstatic const struct of_device_id fsa9480_of_match[] = {\n\t{ .compatible = \"fcs,fsa9480\", },\n\t{ .compatible = \"fcs,fsa880\", },\n\t{ .compatible = \"ti,tsu6111\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, fsa9480_of_match);\n\nstatic struct i2c_driver fsa9480_i2c_driver = {\n\t.driver\t\t\t= {\n\t\t.name\t\t= \"fsa9480\",\n\t\t.pm\t\t= &fsa9480_pm_ops,\n\t\t.of_match_table = fsa9480_of_match,\n\t},\n\t.probe\t\t\t= fsa9480_probe,\n\t.id_table\t\t= fsa9480_id,\n};\n\nstatic int __init fsa9480_module_init(void)\n{\n\treturn i2c_add_driver(&fsa9480_i2c_driver);\n}\nsubsys_initcall(fsa9480_module_init);\n\nstatic void __exit fsa9480_module_exit(void)\n{\n\ti2c_del_driver(&fsa9480_i2c_driver);\n}\nmodule_exit(fsa9480_module_exit);\n\nMODULE_DESCRIPTION(\"Fairchild Semiconductor FSA9480 extcon driver\");\nMODULE_AUTHOR(\"Tomasz Figa <tomasz.figa@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}