{
  "module_name": "extcon-gpio.c",
  "hash_id": "5f8fc560074d51c6794409a81335593a1655efcc7b19cac100b4fd78f69e3f5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/devm-helpers.h>\n#include <linux/extcon-provider.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n \nstruct gpio_extcon_data {\n\tstruct extcon_dev *edev;\n\tstruct delayed_work work;\n\tunsigned long debounce_jiffies;\n\tstruct gpio_desc *gpiod;\n\tunsigned int extcon_id;\n\tunsigned long debounce;\n\tbool check_on_resume;\n};\n\nstatic void gpio_extcon_work(struct work_struct *work)\n{\n\tint state;\n\tstruct gpio_extcon_data\t*data =\n\t\tcontainer_of(to_delayed_work(work), struct gpio_extcon_data,\n\t\t\t     work);\n\n\tstate = gpiod_get_value_cansleep(data->gpiod);\n\textcon_set_state_sync(data->edev, data->extcon_id, state);\n}\n\nstatic irqreturn_t gpio_irq_handler(int irq, void *dev_id)\n{\n\tstruct gpio_extcon_data *data = dev_id;\n\n\tqueue_delayed_work(system_power_efficient_wq, &data->work,\n\t\t\t      data->debounce_jiffies);\n\treturn IRQ_HANDLED;\n}\n\nstatic int gpio_extcon_probe(struct platform_device *pdev)\n{\n\tstruct gpio_extcon_data *data;\n\tstruct device *dev = &pdev->dev;\n\tunsigned long irq_flags;\n\tint irq;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(struct gpio_extcon_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tif (data->extcon_id > EXTCON_NONE)\n\t\treturn -EINVAL;\n\n\tdata->gpiod = devm_gpiod_get(dev, \"extcon\", GPIOD_IN);\n\tif (IS_ERR(data->gpiod))\n\t\treturn PTR_ERR(data->gpiod);\n\tirq = gpiod_to_irq(data->gpiod);\n\tif (irq <= 0)\n\t\treturn irq;\n\n\t \n\tif (gpiod_is_active_low(data->gpiod))\n\t\tirq_flags = IRQF_TRIGGER_FALLING;\n\telse\n\t\tirq_flags = IRQF_TRIGGER_RISING;\n\n\t \n\tdata->edev = devm_extcon_dev_allocate(dev, &data->extcon_id);\n\tif (IS_ERR(data->edev)) {\n\t\tdev_err(dev, \"failed to allocate extcon device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = devm_extcon_dev_register(dev, data->edev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_delayed_work_autocancel(dev, &data->work, gpio_extcon_work);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = devm_request_any_context_irq(dev, irq,\n\t\t\t\t\tgpio_irq_handler, irq_flags,\n\t\t\t\t\tpdev->name, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, data);\n\t \n\tgpio_extcon_work(&data->work.work);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int gpio_extcon_resume(struct device *dev)\n{\n\tstruct gpio_extcon_data *data;\n\n\tdata = dev_get_drvdata(dev);\n\tif (data->check_on_resume)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t&data->work, data->debounce_jiffies);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(gpio_extcon_pm_ops, NULL, gpio_extcon_resume);\n\nstatic struct platform_driver gpio_extcon_driver = {\n\t.probe\t\t= gpio_extcon_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"extcon-gpio\",\n\t\t.pm\t= &gpio_extcon_pm_ops,\n\t},\n};\n\nmodule_platform_driver(gpio_extcon_driver);\n\nMODULE_AUTHOR(\"Mike Lockwood <lockwood@android.com>\");\nMODULE_DESCRIPTION(\"GPIO extcon driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}