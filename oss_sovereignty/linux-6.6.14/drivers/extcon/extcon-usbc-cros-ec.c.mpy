{
  "module_name": "extcon-usbc-cros-ec.c",
  "hash_id": "4acc564212d3b41adc927497c3550e6b885d628ab8f606a51b516c86e2aecba5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-usbc-cros-ec.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/extcon-provider.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/of.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct cros_ec_extcon_info {\n\tstruct device *dev;\n\tstruct extcon_dev *edev;\n\n\tint port_id;\n\n\tstruct cros_ec_device *ec;\n\n\tstruct notifier_block notifier;\n\n\tunsigned int dr;  \n\tbool pr;  \n\tbool dp;  \n\tbool mux;  \n\tunsigned int power_type;\n};\n\nstatic const unsigned int usb_type_c_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_DISP_DP,\n\tEXTCON_NONE,\n};\n\nenum usb_data_roles {\n\tDR_NONE,\n\tDR_HOST,\n\tDR_DEVICE,\n};\n\n \nstatic int cros_ec_pd_command(struct cros_ec_extcon_info *info,\n\t\t\t      unsigned int command,\n\t\t\t      unsigned int version,\n\t\t\t      void *outdata,\n\t\t\t      unsigned int outsize,\n\t\t\t      void *indata,\n\t\t\t      unsigned int insize)\n{\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = kzalloc(struct_size(msg, data, max(outsize, insize)), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->version = version;\n\tmsg->command = command;\n\tmsg->outsize = outsize;\n\tmsg->insize = insize;\n\n\tif (outsize)\n\t\tmemcpy(msg->data, outdata, outsize);\n\n\tret = cros_ec_cmd_xfer_status(info->ec, msg);\n\tif (ret >= 0 && insize)\n\t\tmemcpy(indata, msg->data, insize);\n\n\tkfree(msg);\n\treturn ret;\n}\n\n \nstatic int cros_ec_usb_get_power_type(struct cros_ec_extcon_info *info)\n{\n\tstruct ec_params_usb_pd_power_info req;\n\tstruct ec_response_usb_pd_power_info resp;\n\tint ret;\n\n\treq.port = info->port_id;\n\tret = cros_ec_pd_command(info, EC_CMD_USB_PD_POWER_INFO, 0,\n\t\t\t\t &req, sizeof(req), &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn resp.type;\n}\n\n \nstatic int cros_ec_usb_get_pd_mux_state(struct cros_ec_extcon_info *info)\n{\n\tstruct ec_params_usb_pd_mux_info req;\n\tstruct ec_response_usb_pd_mux_info resp;\n\tint ret;\n\n\treq.port = info->port_id;\n\tret = cros_ec_pd_command(info, EC_CMD_USB_PD_MUX_INFO, 0,\n\t\t\t\t &req, sizeof(req),\n\t\t\t\t &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn resp.flags;\n}\n\n \nstatic int cros_ec_usb_get_role(struct cros_ec_extcon_info *info,\n\t\t\t\tbool *polarity)\n{\n\tstruct ec_params_usb_pd_control pd_control;\n\tstruct ec_response_usb_pd_control_v1 resp;\n\tint ret;\n\n\tpd_control.port = info->port_id;\n\tpd_control.role = USB_PD_CTRL_ROLE_NO_CHANGE;\n\tpd_control.mux = USB_PD_CTRL_MUX_NO_CHANGE;\n\tpd_control.swap = USB_PD_CTRL_SWAP_NONE;\n\tret = cros_ec_pd_command(info, EC_CMD_USB_PD_CONTROL, 1,\n\t\t\t\t &pd_control, sizeof(pd_control),\n\t\t\t\t &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(resp.enabled & PD_CTRL_RESP_ENABLED_CONNECTED))\n\t\treturn -ENOTCONN;\n\n\t*polarity = resp.polarity;\n\n\treturn resp.role;\n}\n\n \nstatic int cros_ec_pd_get_num_ports(struct cros_ec_extcon_info *info)\n{\n\tstruct ec_response_usb_pd_ports resp;\n\tint ret;\n\n\tret = cros_ec_pd_command(info, EC_CMD_USB_PD_PORTS,\n\t\t\t\t 0, NULL, 0, &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn resp.num_ports;\n}\n\nstatic const char *cros_ec_usb_role_string(unsigned int role)\n{\n\treturn role == DR_NONE ? \"DISCONNECTED\" :\n\t\t(role == DR_HOST ? \"DFP\" : \"UFP\");\n}\n\nstatic const char *cros_ec_usb_power_type_string(unsigned int type)\n{\n\tswitch (type) {\n\tcase USB_CHG_TYPE_NONE:\n\t\treturn \"USB_CHG_TYPE_NONE\";\n\tcase USB_CHG_TYPE_PD:\n\t\treturn \"USB_CHG_TYPE_PD\";\n\tcase USB_CHG_TYPE_PROPRIETARY:\n\t\treturn \"USB_CHG_TYPE_PROPRIETARY\";\n\tcase USB_CHG_TYPE_C:\n\t\treturn \"USB_CHG_TYPE_C\";\n\tcase USB_CHG_TYPE_BC12_DCP:\n\t\treturn \"USB_CHG_TYPE_BC12_DCP\";\n\tcase USB_CHG_TYPE_BC12_CDP:\n\t\treturn \"USB_CHG_TYPE_BC12_CDP\";\n\tcase USB_CHG_TYPE_BC12_SDP:\n\t\treturn \"USB_CHG_TYPE_BC12_SDP\";\n\tcase USB_CHG_TYPE_OTHER:\n\t\treturn \"USB_CHG_TYPE_OTHER\";\n\tcase USB_CHG_TYPE_VBUS:\n\t\treturn \"USB_CHG_TYPE_VBUS\";\n\tcase USB_CHG_TYPE_UNKNOWN:\n\t\treturn \"USB_CHG_TYPE_UNKNOWN\";\n\tdefault:\n\t\treturn \"USB_CHG_TYPE_UNKNOWN\";\n\t}\n}\n\nstatic bool cros_ec_usb_power_type_is_wall_wart(unsigned int type,\n\t\t\t\t\t\tunsigned int role)\n{\n\tswitch (type) {\n\t \n\tcase USB_CHG_TYPE_PROPRIETARY:\n\tcase USB_CHG_TYPE_BC12_DCP:\n\t\treturn true;\n\tcase USB_CHG_TYPE_PD:\n\tcase USB_CHG_TYPE_C:\n\tcase USB_CHG_TYPE_BC12_CDP:\n\tcase USB_CHG_TYPE_BC12_SDP:\n\tcase USB_CHG_TYPE_OTHER:\n\tcase USB_CHG_TYPE_VBUS:\n\tcase USB_CHG_TYPE_UNKNOWN:\n\tcase USB_CHG_TYPE_NONE:\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int extcon_cros_ec_detect_cable(struct cros_ec_extcon_info *info,\n\t\t\t\t       bool force)\n{\n\tstruct device *dev = info->dev;\n\tint role, power_type;\n\tunsigned int dr = DR_NONE;\n\tbool pr = false;\n\tbool polarity = false;\n\tbool dp = false;\n\tbool mux = false;\n\tbool hpd = false;\n\n\tpower_type = cros_ec_usb_get_power_type(info);\n\tif (power_type < 0) {\n\t\tdev_err(dev, \"failed getting power type err = %d\\n\",\n\t\t\tpower_type);\n\t\treturn power_type;\n\t}\n\n\trole = cros_ec_usb_get_role(info, &polarity);\n\tif (role < 0) {\n\t\tif (role != -ENOTCONN) {\n\t\t\tdev_err(dev, \"failed getting role err = %d\\n\", role);\n\t\t\treturn role;\n\t\t}\n\t\tdev_dbg(dev, \"disconnected\\n\");\n\t} else {\n\t\tint pd_mux_state;\n\n\t\tdr = (role & PD_CTRL_RESP_ROLE_DATA) ? DR_HOST : DR_DEVICE;\n\t\tpr = (role & PD_CTRL_RESP_ROLE_POWER);\n\t\tpd_mux_state = cros_ec_usb_get_pd_mux_state(info);\n\t\tif (pd_mux_state < 0)\n\t\t\tpd_mux_state = USB_PD_MUX_USB_ENABLED;\n\n\t\tdp = pd_mux_state & USB_PD_MUX_DP_ENABLED;\n\t\tmux = pd_mux_state & USB_PD_MUX_USB_ENABLED;\n\t\thpd = pd_mux_state & USB_PD_MUX_HPD_IRQ;\n\n\t\tdev_dbg(dev,\n\t\t\t\"connected role 0x%x pwr type %d dr %d pr %d pol %d mux %d dp %d hpd %d\\n\",\n\t\t\trole, power_type, dr, pr, polarity, mux, dp, hpd);\n\t}\n\n\t \n\tif (dr == DR_DEVICE &&\n\t    cros_ec_usb_power_type_is_wall_wart(power_type, role))\n\t\tdr = DR_NONE;\n\n\tif (force || info->dr != dr || info->pr != pr || info->dp != dp ||\n\t    info->mux != mux || info->power_type != power_type) {\n\t\tbool host_connected = false, device_connected = false;\n\n\t\tdev_dbg(dev, \"Type/Role switch! type = %s role = %s\\n\",\n\t\t\tcros_ec_usb_power_type_string(power_type),\n\t\t\tcros_ec_usb_role_string(dr));\n\t\tinfo->dr = dr;\n\t\tinfo->pr = pr;\n\t\tinfo->dp = dp;\n\t\tinfo->mux = mux;\n\t\tinfo->power_type = power_type;\n\n\t\tif (dr == DR_DEVICE)\n\t\t\tdevice_connected = true;\n\t\telse if (dr == DR_HOST)\n\t\t\thost_connected = true;\n\n\t\textcon_set_state(info->edev, EXTCON_USB, device_connected);\n\t\textcon_set_state(info->edev, EXTCON_USB_HOST, host_connected);\n\t\textcon_set_state(info->edev, EXTCON_DISP_DP, dp);\n\t\textcon_set_property(info->edev, EXTCON_USB,\n\t\t\t\t    EXTCON_PROP_USB_VBUS,\n\t\t\t\t    (union extcon_property_value)(int)pr);\n\t\textcon_set_property(info->edev, EXTCON_USB_HOST,\n\t\t\t\t    EXTCON_PROP_USB_VBUS,\n\t\t\t\t    (union extcon_property_value)(int)pr);\n\t\textcon_set_property(info->edev, EXTCON_USB,\n\t\t\t\t    EXTCON_PROP_USB_TYPEC_POLARITY,\n\t\t\t\t    (union extcon_property_value)(int)polarity);\n\t\textcon_set_property(info->edev, EXTCON_USB_HOST,\n\t\t\t\t    EXTCON_PROP_USB_TYPEC_POLARITY,\n\t\t\t\t    (union extcon_property_value)(int)polarity);\n\t\textcon_set_property(info->edev, EXTCON_DISP_DP,\n\t\t\t\t    EXTCON_PROP_USB_TYPEC_POLARITY,\n\t\t\t\t    (union extcon_property_value)(int)polarity);\n\t\textcon_set_property(info->edev, EXTCON_USB,\n\t\t\t\t    EXTCON_PROP_USB_SS,\n\t\t\t\t    (union extcon_property_value)(int)mux);\n\t\textcon_set_property(info->edev, EXTCON_USB_HOST,\n\t\t\t\t    EXTCON_PROP_USB_SS,\n\t\t\t\t    (union extcon_property_value)(int)mux);\n\t\textcon_set_property(info->edev, EXTCON_DISP_DP,\n\t\t\t\t    EXTCON_PROP_USB_SS,\n\t\t\t\t    (union extcon_property_value)(int)mux);\n\t\textcon_set_property(info->edev, EXTCON_DISP_DP,\n\t\t\t\t    EXTCON_PROP_DISP_HPD,\n\t\t\t\t    (union extcon_property_value)(int)hpd);\n\n\t\textcon_sync(info->edev, EXTCON_USB);\n\t\textcon_sync(info->edev, EXTCON_USB_HOST);\n\t\textcon_sync(info->edev, EXTCON_DISP_DP);\n\n\t} else if (hpd) {\n\t\textcon_set_property(info->edev, EXTCON_DISP_DP,\n\t\t\t\t    EXTCON_PROP_DISP_HPD,\n\t\t\t\t    (union extcon_property_value)(int)hpd);\n\t\textcon_sync(info->edev, EXTCON_DISP_DP);\n\t}\n\n\treturn 0;\n}\n\nstatic int extcon_cros_ec_event(struct notifier_block *nb,\n\t\t\t\tunsigned long queued_during_suspend,\n\t\t\t\tvoid *_notify)\n{\n\tstruct cros_ec_extcon_info *info;\n\tstruct cros_ec_device *ec;\n\tu32 host_event;\n\n\tinfo = container_of(nb, struct cros_ec_extcon_info, notifier);\n\tec = info->ec;\n\n\thost_event = cros_ec_get_host_event(ec);\n\tif (host_event & (EC_HOST_EVENT_MASK(EC_HOST_EVENT_PD_MCU) |\n\t\t\t  EC_HOST_EVENT_MASK(EC_HOST_EVENT_USB_MUX))) {\n\t\textcon_cros_ec_detect_cable(info, false);\n\t\treturn NOTIFY_OK;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int extcon_cros_ec_probe(struct platform_device *pdev)\n{\n\tstruct cros_ec_extcon_info *info;\n\tstruct cros_ec_device *ec = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tint numports, ret;\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = dev;\n\tinfo->ec = ec;\n\n\tif (np) {\n\t\tu32 port;\n\n\t\tret = of_property_read_u32(np, \"google,usb-port-id\", &port);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Missing google,usb-port-id property\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tinfo->port_id = port;\n\t} else {\n\t\tinfo->port_id = pdev->id;\n\t}\n\n\tnumports = cros_ec_pd_get_num_ports(info);\n\tif (numports < 0) {\n\t\tdev_err(dev, \"failed getting number of ports! ret = %d\\n\",\n\t\t\tnumports);\n\t\treturn numports;\n\t}\n\n\tif (info->port_id >= numports) {\n\t\tdev_err(dev, \"This system only supports %d ports\\n\", numports);\n\t\treturn -ENODEV;\n\t}\n\n\tinfo->edev = devm_extcon_dev_allocate(dev, usb_type_c_cable);\n\tif (IS_ERR(info->edev)) {\n\t\tdev_err(dev, \"failed to allocate extcon device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = devm_extcon_dev_register(dev, info->edev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register extcon device\\n\");\n\t\treturn ret;\n\t}\n\n\textcon_set_property_capability(info->edev, EXTCON_USB,\n\t\t\t\t       EXTCON_PROP_USB_VBUS);\n\textcon_set_property_capability(info->edev, EXTCON_USB_HOST,\n\t\t\t\t       EXTCON_PROP_USB_VBUS);\n\textcon_set_property_capability(info->edev, EXTCON_USB,\n\t\t\t\t       EXTCON_PROP_USB_TYPEC_POLARITY);\n\textcon_set_property_capability(info->edev, EXTCON_USB_HOST,\n\t\t\t\t       EXTCON_PROP_USB_TYPEC_POLARITY);\n\textcon_set_property_capability(info->edev, EXTCON_DISP_DP,\n\t\t\t\t       EXTCON_PROP_USB_TYPEC_POLARITY);\n\textcon_set_property_capability(info->edev, EXTCON_USB,\n\t\t\t\t       EXTCON_PROP_USB_SS);\n\textcon_set_property_capability(info->edev, EXTCON_USB_HOST,\n\t\t\t\t       EXTCON_PROP_USB_SS);\n\textcon_set_property_capability(info->edev, EXTCON_DISP_DP,\n\t\t\t\t       EXTCON_PROP_USB_SS);\n\textcon_set_property_capability(info->edev, EXTCON_DISP_DP,\n\t\t\t\t       EXTCON_PROP_DISP_HPD);\n\n\tinfo->dr = DR_NONE;\n\tinfo->pr = false;\n\n\tplatform_set_drvdata(pdev, info);\n\n\t \n\tinfo->notifier.notifier_call = extcon_cros_ec_event;\n\tret = blocking_notifier_chain_register(&info->ec->event_notifier,\n\t\t\t\t\t       &info->notifier);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register notifier\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = extcon_cros_ec_detect_cable(info, true);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to detect initial cable state\\n\");\n\t\tgoto unregister_notifier;\n\t}\n\n\treturn 0;\n\nunregister_notifier:\n\tblocking_notifier_chain_unregister(&info->ec->event_notifier,\n\t\t\t\t\t   &info->notifier);\n\treturn ret;\n}\n\nstatic int extcon_cros_ec_remove(struct platform_device *pdev)\n{\n\tstruct cros_ec_extcon_info *info = platform_get_drvdata(pdev);\n\n\tblocking_notifier_chain_unregister(&info->ec->event_notifier,\n\t\t\t\t\t   &info->notifier);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int extcon_cros_ec_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int extcon_cros_ec_resume(struct device *dev)\n{\n\tint ret;\n\tstruct cros_ec_extcon_info *info = dev_get_drvdata(dev);\n\n\tret = extcon_cros_ec_detect_cable(info, true);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to detect cable state on resume\\n\");\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops extcon_cros_ec_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(extcon_cros_ec_suspend, extcon_cros_ec_resume)\n};\n\n#define DEV_PM_OPS\t(&extcon_cros_ec_dev_pm_ops)\n#else\n#define DEV_PM_OPS\tNULL\n#endif  \n\n#ifdef CONFIG_OF\nstatic const struct of_device_id extcon_cros_ec_of_match[] = {\n\t{ .compatible = \"google,extcon-usbc-cros-ec\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, extcon_cros_ec_of_match);\n#endif  \n\nstatic struct platform_driver extcon_cros_ec_driver = {\n\t.driver = {\n\t\t.name  = \"extcon-usbc-cros-ec\",\n\t\t.of_match_table = of_match_ptr(extcon_cros_ec_of_match),\n\t\t.pm = DEV_PM_OPS,\n\t},\n\t.remove  = extcon_cros_ec_remove,\n\t.probe   = extcon_cros_ec_probe,\n};\n\nmodule_platform_driver(extcon_cros_ec_driver);\n\nMODULE_DESCRIPTION(\"ChromeOS Embedded Controller extcon driver\");\nMODULE_AUTHOR(\"Benson Leung <bleung@chromium.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}