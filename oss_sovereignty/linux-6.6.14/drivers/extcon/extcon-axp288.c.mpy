{
  "module_name": "extcon-axp288.c",
  "hash_id": "74cee7c891232899f9e6cbc669d3ab347b3d26019eada5b6b9eac02b0d2f68bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-axp288.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/notifier.h>\n#include <linux/extcon-provider.h>\n#include <linux/regmap.h>\n#include <linux/mfd/axp20x.h>\n#include <linux/usb/role.h>\n#include <linux/workqueue.h>\n\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n#include <asm/iosf_mbi.h>\n\n \n#define PS_STAT_VBUS_TRIGGER\t\tBIT(0)\n#define PS_STAT_BAT_CHRG_DIR\t\tBIT(2)\n#define PS_STAT_VBUS_ABOVE_VHOLD\tBIT(3)\n#define PS_STAT_VBUS_VALID\t\tBIT(4)\n#define PS_STAT_VBUS_PRESENT\t\tBIT(5)\n\n \n#define BC_GLOBAL_RUN\t\t\tBIT(0)\n#define BC_GLOBAL_DET_STAT\t\tBIT(2)\n#define BC_GLOBAL_DBP_TOUT\t\tBIT(3)\n#define BC_GLOBAL_VLGC_COM_SEL\t\tBIT(4)\n#define BC_GLOBAL_DCD_TOUT_MASK\t\t(BIT(6)|BIT(5))\n#define BC_GLOBAL_DCD_TOUT_300MS\t0\n#define BC_GLOBAL_DCD_TOUT_100MS\t1\n#define BC_GLOBAL_DCD_TOUT_500MS\t2\n#define BC_GLOBAL_DCD_TOUT_900MS\t3\n#define BC_GLOBAL_DCD_DET_SEL\t\tBIT(7)\n\n \n#define VBUS_CNTL_DPDM_PD_EN\t\tBIT(4)\n#define VBUS_CNTL_DPDM_FD_EN\t\tBIT(5)\n#define VBUS_CNTL_FIRST_PO_STAT\t\tBIT(6)\n\n \n#define USB_STAT_BUS_STAT_MASK\t\t(BIT(3)|BIT(2)|BIT(1)|BIT(0))\n#define USB_STAT_BUS_STAT_SHIFT\t\t0\n#define USB_STAT_BUS_STAT_ATHD\t\t0\n#define USB_STAT_BUS_STAT_CONN\t\t1\n#define USB_STAT_BUS_STAT_SUSP\t\t2\n#define USB_STAT_BUS_STAT_CONF\t\t3\n#define USB_STAT_USB_SS_MODE\t\tBIT(4)\n#define USB_STAT_DEAD_BAT_DET\t\tBIT(6)\n#define USB_STAT_DBP_UNCFG\t\tBIT(7)\n\n \n#define DET_STAT_MASK\t\t\t(BIT(7)|BIT(6)|BIT(5))\n#define DET_STAT_SHIFT\t\t\t5\n#define DET_STAT_SDP\t\t\t1\n#define DET_STAT_CDP\t\t\t2\n#define DET_STAT_DCP\t\t\t3\n\nenum axp288_extcon_reg {\n\tAXP288_PS_STAT_REG\t\t= 0x00,\n\tAXP288_PS_BOOT_REASON_REG\t= 0x02,\n\tAXP288_BC_GLOBAL_REG\t\t= 0x2c,\n\tAXP288_BC_VBUS_CNTL_REG\t\t= 0x2d,\n\tAXP288_BC_USB_STAT_REG\t\t= 0x2e,\n\tAXP288_BC_DET_STAT_REG\t\t= 0x2f,\n};\n\nenum axp288_extcon_irq {\n\tVBUS_FALLING_IRQ = 0,\n\tVBUS_RISING_IRQ,\n\tMV_CHNG_IRQ,\n\tBC_USB_CHNG_IRQ,\n\tEXTCON_IRQ_END,\n};\n\nstatic const unsigned int axp288_extcon_cables[] = {\n\tEXTCON_CHG_USB_SDP,\n\tEXTCON_CHG_USB_CDP,\n\tEXTCON_CHG_USB_DCP,\n\tEXTCON_USB,\n\tEXTCON_NONE,\n};\n\nstruct axp288_extcon_info {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regmap_irq_chip_data *regmap_irqc;\n\tstruct usb_role_switch *role_sw;\n\tstruct work_struct role_work;\n\tint irq[EXTCON_IRQ_END];\n\tstruct extcon_dev *edev;\n\tstruct extcon_dev *id_extcon;\n\tstruct notifier_block id_nb;\n\tunsigned int previous_cable;\n\tbool vbus_attach;\n};\n\nstatic const struct x86_cpu_id cherry_trail_cpu_ids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT,\tNULL),\n\t{}\n};\n\n \nstatic const char * const axp288_pwr_up_down_info[] = {\n\t\"Last wake caused by user pressing the power button\",\n\t\"Last wake caused by a charger insertion\",\n\t\"Last wake caused by a battery insertion\",\n\t\"Last wake caused by SOC initiated global reset\",\n\t\"Last wake caused by cold reset\",\n\t\"Last shutdown caused by PMIC UVLO threshold\",\n\t\"Last shutdown caused by SOC initiated cold off\",\n\t\"Last shutdown caused by user pressing the power button\",\n};\n\n \nstatic void axp288_extcon_log_rsi(struct axp288_extcon_info *info)\n{\n\tunsigned int val, i, clear_mask = 0;\n\tunsigned long bits;\n\tint ret;\n\n\tret = regmap_read(info->regmap, AXP288_PS_BOOT_REASON_REG, &val);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"failed to read reset source indicator\\n\");\n\t\treturn;\n\t}\n\n\tbits = val & GENMASK(ARRAY_SIZE(axp288_pwr_up_down_info) - 1, 0);\n\tfor_each_set_bit(i, &bits, ARRAY_SIZE(axp288_pwr_up_down_info))\n\t\tdev_dbg(info->dev, \"%s\\n\", axp288_pwr_up_down_info[i]);\n\tclear_mask = bits;\n\n\t \n\tregmap_write(info->regmap, AXP288_PS_BOOT_REASON_REG, clear_mask);\n}\n\n \n\n \nstatic bool axp288_get_id_pin(struct axp288_extcon_info *info)\n{\n\tenum usb_role role;\n\n\tif (info->id_extcon)\n\t\treturn extcon_get_state(info->id_extcon, EXTCON_USB_HOST) <= 0;\n\n\t \n\trole = usb_role_switch_get_role(info->role_sw);\n\treturn role != USB_ROLE_HOST;\n}\n\nstatic void axp288_usb_role_work(struct work_struct *work)\n{\n\tstruct axp288_extcon_info *info =\n\t\tcontainer_of(work, struct axp288_extcon_info, role_work);\n\tenum usb_role role;\n\tbool id_pin;\n\tint ret;\n\n\tid_pin = axp288_get_id_pin(info);\n\tif (!id_pin)\n\t\trole = USB_ROLE_HOST;\n\telse if (info->vbus_attach)\n\t\trole = USB_ROLE_DEVICE;\n\telse\n\t\trole = USB_ROLE_NONE;\n\n\tret = usb_role_switch_set_role(info->role_sw, role);\n\tif (ret)\n\t\tdev_err(info->dev, \"failed to set role: %d\\n\", ret);\n}\n\nstatic bool axp288_get_vbus_attach(struct axp288_extcon_info *info)\n{\n\tint ret, pwr_stat;\n\n\tret = regmap_read(info->regmap, AXP288_PS_STAT_REG, &pwr_stat);\n\tif (ret < 0) {\n\t\tdev_err(info->dev, \"failed to read vbus status\\n\");\n\t\treturn false;\n\t}\n\n\treturn !!(pwr_stat & PS_STAT_VBUS_VALID);\n}\n\nstatic int axp288_handle_chrg_det_event(struct axp288_extcon_info *info)\n{\n\tint ret, stat, cfg;\n\tu8 chrg_type;\n\tunsigned int cable = info->previous_cable;\n\tbool vbus_attach = false;\n\n\tret = iosf_mbi_block_punit_i2c_access();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvbus_attach = axp288_get_vbus_attach(info);\n\tif (!vbus_attach)\n\t\tgoto no_vbus;\n\n\t \n\tret = regmap_read(info->regmap, AXP288_BC_GLOBAL_REG, &cfg);\n\tif (ret < 0)\n\t\tgoto dev_det_ret;\n\tif (cfg & BC_GLOBAL_DET_STAT) {\n\t\tdev_dbg(info->dev, \"can't complete the charger detection\\n\");\n\t\tgoto dev_det_ret;\n\t}\n\n\tret = regmap_read(info->regmap, AXP288_BC_DET_STAT_REG, &stat);\n\tif (ret < 0)\n\t\tgoto dev_det_ret;\n\n\tchrg_type = (stat & DET_STAT_MASK) >> DET_STAT_SHIFT;\n\n\tswitch (chrg_type) {\n\tcase DET_STAT_SDP:\n\t\tdev_dbg(info->dev, \"sdp cable is connected\\n\");\n\t\tcable = EXTCON_CHG_USB_SDP;\n\t\tbreak;\n\tcase DET_STAT_CDP:\n\t\tdev_dbg(info->dev, \"cdp cable is connected\\n\");\n\t\tcable = EXTCON_CHG_USB_CDP;\n\t\tbreak;\n\tcase DET_STAT_DCP:\n\t\tdev_dbg(info->dev, \"dcp cable is connected\\n\");\n\t\tcable = EXTCON_CHG_USB_DCP;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(info->dev, \"unknown (reserved) bc detect result\\n\");\n\t\tcable = EXTCON_CHG_USB_SDP;\n\t}\n\nno_vbus:\n\tiosf_mbi_unblock_punit_i2c_access();\n\n\textcon_set_state_sync(info->edev, info->previous_cable, false);\n\tif (info->previous_cable == EXTCON_CHG_USB_SDP)\n\t\textcon_set_state_sync(info->edev, EXTCON_USB, false);\n\n\tif (vbus_attach) {\n\t\textcon_set_state_sync(info->edev, cable, vbus_attach);\n\t\tif (cable == EXTCON_CHG_USB_SDP)\n\t\t\textcon_set_state_sync(info->edev, EXTCON_USB,\n\t\t\t\t\t\tvbus_attach);\n\n\t\tinfo->previous_cable = cable;\n\t}\n\n\tif (info->role_sw && info->vbus_attach != vbus_attach) {\n\t\tinfo->vbus_attach = vbus_attach;\n\t\t \n\t\tqueue_work(system_long_wq, &info->role_work);\n\t}\n\n\treturn 0;\n\ndev_det_ret:\n\tiosf_mbi_unblock_punit_i2c_access();\n\n\tif (ret < 0)\n\t\tdev_err(info->dev, \"failed to detect BC Mod\\n\");\n\n\treturn ret;\n}\n\nstatic int axp288_extcon_id_evt(struct notifier_block *nb,\n\t\t\t\tunsigned long event, void *param)\n{\n\tstruct axp288_extcon_info *info =\n\t\tcontainer_of(nb, struct axp288_extcon_info, id_nb);\n\n\t \n\tqueue_work(system_long_wq, &info->role_work);\n\n\treturn NOTIFY_OK;\n}\n\nstatic irqreturn_t axp288_extcon_isr(int irq, void *data)\n{\n\tstruct axp288_extcon_info *info = data;\n\tint ret;\n\n\tret = axp288_handle_chrg_det_event(info);\n\tif (ret < 0)\n\t\tdev_err(info->dev, \"failed to handle the interrupt\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int axp288_extcon_enable(struct axp288_extcon_info *info)\n{\n\tint ret = 0;\n\n\tret = iosf_mbi_block_punit_i2c_access();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregmap_update_bits(info->regmap, AXP288_BC_GLOBAL_REG,\n\t\t\t\t\t\tBC_GLOBAL_RUN, 0);\n\t \n\tregmap_update_bits(info->regmap, AXP288_BC_GLOBAL_REG,\n\t\t\t\t\tBC_GLOBAL_RUN, BC_GLOBAL_RUN);\n\n\tiosf_mbi_unblock_punit_i2c_access();\n\n\treturn ret;\n}\n\nstatic void axp288_put_role_sw(void *data)\n{\n\tstruct axp288_extcon_info *info = data;\n\n\tcancel_work_sync(&info->role_work);\n\tusb_role_switch_put(info->role_sw);\n}\n\nstatic int axp288_extcon_find_role_sw(struct axp288_extcon_info *info)\n{\n\tconst struct software_node *swnode;\n\tstruct fwnode_handle *fwnode;\n\n\tif (!x86_match_cpu(cherry_trail_cpu_ids))\n\t\treturn 0;\n\n\tswnode = software_node_find_by_name(NULL, \"intel-xhci-usb-sw\");\n\tif (!swnode)\n\t\treturn -EPROBE_DEFER;\n\n\tfwnode = software_node_fwnode(swnode);\n\tinfo->role_sw = usb_role_switch_find_by_fwnode(fwnode);\n\tfwnode_handle_put(fwnode);\n\n\treturn info->role_sw ? 0 : -EPROBE_DEFER;\n}\n\nstatic int axp288_extcon_probe(struct platform_device *pdev)\n{\n\tstruct axp288_extcon_info *info;\n\tstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tstruct acpi_device *adev;\n\tint ret, i, pirq;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = &pdev->dev;\n\tinfo->regmap = axp20x->regmap;\n\tinfo->regmap_irqc = axp20x->regmap_irqc;\n\tinfo->previous_cable = EXTCON_NONE;\n\tINIT_WORK(&info->role_work, axp288_usb_role_work);\n\tinfo->id_nb.notifier_call = axp288_extcon_id_evt;\n\n\tplatform_set_drvdata(pdev, info);\n\n\tret = axp288_extcon_find_role_sw(info);\n\tif (ret)\n\t\treturn ret;\n\n\tif (info->role_sw) {\n\t\tret = devm_add_action_or_reset(dev, axp288_put_role_sw, info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tadev = acpi_dev_get_first_match_dev(\"INT3496\", NULL, -1);\n\t\tif (adev) {\n\t\t\tinfo->id_extcon = extcon_get_extcon_dev(acpi_dev_name(adev));\n\t\t\tacpi_dev_put(adev);\n\t\t\tif (IS_ERR(info->id_extcon))\n\t\t\t\treturn PTR_ERR(info->id_extcon);\n\n\t\t\tdev_info(dev, \"controlling USB role\\n\");\n\t\t} else {\n\t\t\tdev_info(dev, \"controlling USB role based on Vbus presence\\n\");\n\t\t}\n\t}\n\n\tret = iosf_mbi_block_punit_i2c_access();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinfo->vbus_attach = axp288_get_vbus_attach(info);\n\n\taxp288_extcon_log_rsi(info);\n\n\tiosf_mbi_unblock_punit_i2c_access();\n\n\t \n\tinfo->edev = devm_extcon_dev_allocate(&pdev->dev,\n\t\t\t\t\t      axp288_extcon_cables);\n\tif (IS_ERR(info->edev)) {\n\t\tdev_err(&pdev->dev, \"failed to allocate memory for extcon\\n\");\n\t\treturn PTR_ERR(info->edev);\n\t}\n\n\t \n\tret = devm_extcon_dev_register(&pdev->dev, info->edev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register extcon device\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < EXTCON_IRQ_END; i++) {\n\t\tpirq = platform_get_irq(pdev, i);\n\t\tif (pirq < 0)\n\t\t\treturn pirq;\n\n\t\tinfo->irq[i] = regmap_irq_get_virq(info->regmap_irqc, pirq);\n\t\tif (info->irq[i] < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to get virtual interrupt=%d\\n\", pirq);\n\t\t\tret = info->irq[i];\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, info->irq[i],\n\t\t\t\tNULL, axp288_extcon_isr,\n\t\t\t\tIRQF_ONESHOT | IRQF_NO_SUSPEND,\n\t\t\t\tpdev->name, info);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to request interrupt=%d\\n\",\n\t\t\t\t\t\t\tinfo->irq[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (info->id_extcon) {\n\t\tret = devm_extcon_register_notifier_all(dev, info->id_extcon,\n\t\t\t\t\t\t\t&info->id_nb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (info->role_sw) {\n\t\tqueue_work(system_long_wq, &info->role_work);\n\t\tflush_work(&info->role_work);\n\t}\n\n\t \n\tret = axp288_extcon_enable(info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdevice_init_wakeup(dev, true);\n\tplatform_set_drvdata(pdev, info);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused axp288_extcon_suspend(struct device *dev)\n{\n\tstruct axp288_extcon_info *info = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(info->irq[VBUS_RISING_IRQ]);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused axp288_extcon_resume(struct device *dev)\n{\n\tstruct axp288_extcon_info *info = dev_get_drvdata(dev);\n\n\t \n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(info->irq[VBUS_RISING_IRQ]);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(axp288_extcon_pm_ops, axp288_extcon_suspend,\n\t\t\t axp288_extcon_resume);\n\nstatic const struct platform_device_id axp288_extcon_table[] = {\n\t{ .name = \"axp288_extcon\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, axp288_extcon_table);\n\nstatic struct platform_driver axp288_extcon_driver = {\n\t.probe = axp288_extcon_probe,\n\t.id_table = axp288_extcon_table,\n\t.driver = {\n\t\t.name = \"axp288_extcon\",\n\t\t.pm = &axp288_extcon_pm_ops,\n\t},\n};\nmodule_platform_driver(axp288_extcon_driver);\n\nMODULE_AUTHOR(\"Ramakrishna Pallala <ramakrishna.pallala@intel.com>\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"X-Powers AXP288 extcon driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}