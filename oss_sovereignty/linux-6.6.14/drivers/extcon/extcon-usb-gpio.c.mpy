{
  "module_name": "extcon-usb-gpio.c",
  "hash_id": "0460ac6b8988ff4d1a7ee5b985adaeb765d4da89beb6d77f9e18a20659f36dce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-usb-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/extcon-provider.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/mod_devicetable.h>\n\n#define USB_GPIO_DEBOUNCE_MS\t20\t \n\nstruct usb_extcon_info {\n\tstruct device *dev;\n\tstruct extcon_dev *edev;\n\n\tstruct gpio_desc *id_gpiod;\n\tstruct gpio_desc *vbus_gpiod;\n\tint id_irq;\n\tint vbus_irq;\n\n\tunsigned long debounce_jiffies;\n\tstruct delayed_work wq_detcable;\n};\n\nstatic const unsigned int usb_extcon_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_NONE,\n};\n\n \nstatic void usb_extcon_detect_cable(struct work_struct *work)\n{\n\tint id, vbus;\n\tstruct usb_extcon_info *info = container_of(to_delayed_work(work),\n\t\t\t\t\t\t    struct usb_extcon_info,\n\t\t\t\t\t\t    wq_detcable);\n\n\t \n\tid = info->id_gpiod ?\n\t\tgpiod_get_value_cansleep(info->id_gpiod) : 1;\n\tvbus = info->vbus_gpiod ?\n\t\tgpiod_get_value_cansleep(info->vbus_gpiod) : id;\n\n\t \n\tif (id)\n\t\textcon_set_state_sync(info->edev, EXTCON_USB_HOST, false);\n\tif (!vbus)\n\t\textcon_set_state_sync(info->edev, EXTCON_USB, false);\n\n\tif (!id) {\n\t\textcon_set_state_sync(info->edev, EXTCON_USB_HOST, true);\n\t} else {\n\t\tif (vbus)\n\t\t\textcon_set_state_sync(info->edev, EXTCON_USB, true);\n\t}\n}\n\nstatic irqreturn_t usb_irq_handler(int irq, void *dev_id)\n{\n\tstruct usb_extcon_info *info = dev_id;\n\n\tqueue_delayed_work(system_power_efficient_wq, &info->wq_detcable,\n\t\t\t   info->debounce_jiffies);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int usb_extcon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct usb_extcon_info *info;\n\tint ret;\n\n\tif (!np)\n\t\treturn -EINVAL;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = dev;\n\tinfo->id_gpiod = devm_gpiod_get_optional(&pdev->dev, \"id\", GPIOD_IN);\n\tinfo->vbus_gpiod = devm_gpiod_get_optional(&pdev->dev, \"vbus\",\n\t\t\t\t\t\t   GPIOD_IN);\n\n\tif (!info->id_gpiod && !info->vbus_gpiod) {\n\t\tdev_err(dev, \"failed to get gpios\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (IS_ERR(info->id_gpiod))\n\t\treturn PTR_ERR(info->id_gpiod);\n\n\tif (IS_ERR(info->vbus_gpiod))\n\t\treturn PTR_ERR(info->vbus_gpiod);\n\n\tinfo->edev = devm_extcon_dev_allocate(dev, usb_extcon_cable);\n\tif (IS_ERR(info->edev)) {\n\t\tdev_err(dev, \"failed to allocate extcon device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = devm_extcon_dev_register(dev, info->edev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register extcon device\\n\");\n\t\treturn ret;\n\t}\n\n\tif (info->id_gpiod)\n\t\tret = gpiod_set_debounce(info->id_gpiod,\n\t\t\t\t\t USB_GPIO_DEBOUNCE_MS * 1000);\n\tif (!ret && info->vbus_gpiod)\n\t\tret = gpiod_set_debounce(info->vbus_gpiod,\n\t\t\t\t\t USB_GPIO_DEBOUNCE_MS * 1000);\n\n\tif (ret < 0)\n\t\tinfo->debounce_jiffies = msecs_to_jiffies(USB_GPIO_DEBOUNCE_MS);\n\n\tINIT_DELAYED_WORK(&info->wq_detcable, usb_extcon_detect_cable);\n\n\tif (info->id_gpiod) {\n\t\tinfo->id_irq = gpiod_to_irq(info->id_gpiod);\n\t\tif (info->id_irq < 0) {\n\t\t\tdev_err(dev, \"failed to get ID IRQ\\n\");\n\t\t\treturn info->id_irq;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(dev, info->id_irq, NULL,\n\t\t\t\t\t\tusb_irq_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t\tpdev->name, info);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to request handler for ID IRQ\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (info->vbus_gpiod) {\n\t\tinfo->vbus_irq = gpiod_to_irq(info->vbus_gpiod);\n\t\tif (info->vbus_irq < 0) {\n\t\t\tdev_err(dev, \"failed to get VBUS IRQ\\n\");\n\t\t\treturn info->vbus_irq;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(dev, info->vbus_irq, NULL,\n\t\t\t\t\t\tusb_irq_handler,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t\tpdev->name, info);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to request handler for VBUS IRQ\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, info);\n\tdevice_set_wakeup_capable(&pdev->dev, true);\n\n\t \n\tusb_extcon_detect_cable(&info->wq_detcable.work);\n\n\treturn 0;\n}\n\nstatic int usb_extcon_remove(struct platform_device *pdev)\n{\n\tstruct usb_extcon_info *info = platform_get_drvdata(pdev);\n\n\tcancel_delayed_work_sync(&info->wq_detcable);\n\tdevice_init_wakeup(&pdev->dev, false);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int usb_extcon_suspend(struct device *dev)\n{\n\tstruct usb_extcon_info *info = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (device_may_wakeup(dev)) {\n\t\tif (info->id_gpiod) {\n\t\t\tret = enable_irq_wake(info->id_irq);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (info->vbus_gpiod) {\n\t\t\tret = enable_irq_wake(info->vbus_irq);\n\t\t\tif (ret) {\n\t\t\t\tif (info->id_gpiod)\n\t\t\t\t\tdisable_irq_wake(info->id_irq);\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!device_may_wakeup(dev))\n\t\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn ret;\n}\n\nstatic int usb_extcon_resume(struct device *dev)\n{\n\tstruct usb_extcon_info *info = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (!device_may_wakeup(dev))\n\t\tpinctrl_pm_select_default_state(dev);\n\n\tif (device_may_wakeup(dev)) {\n\t\tif (info->id_gpiod) {\n\t\t\tret = disable_irq_wake(info->id_irq);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (info->vbus_gpiod) {\n\t\t\tret = disable_irq_wake(info->vbus_irq);\n\t\t\tif (ret) {\n\t\t\t\tif (info->id_gpiod)\n\t\t\t\t\tenable_irq_wake(info->id_irq);\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t   &info->wq_detcable, 0);\n\n\treturn ret;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(usb_extcon_pm_ops,\n\t\t\t usb_extcon_suspend, usb_extcon_resume);\n\nstatic const struct of_device_id usb_extcon_dt_match[] = {\n\t{ .compatible = \"linux,extcon-usb-gpio\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, usb_extcon_dt_match);\n\nstatic const struct platform_device_id usb_extcon_platform_ids[] = {\n\t{ .name = \"extcon-usb-gpio\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, usb_extcon_platform_ids);\n\nstatic struct platform_driver usb_extcon_driver = {\n\t.probe\t\t= usb_extcon_probe,\n\t.remove\t\t= usb_extcon_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"extcon-usb-gpio\",\n\t\t.pm\t= &usb_extcon_pm_ops,\n\t\t.of_match_table = usb_extcon_dt_match,\n\t},\n\t.id_table = usb_extcon_platform_ids,\n};\n\nmodule_platform_driver(usb_extcon_driver);\n\nMODULE_AUTHOR(\"Roger Quadros <rogerq@ti.com>\");\nMODULE_DESCRIPTION(\"USB GPIO extcon driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}