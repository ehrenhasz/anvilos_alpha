{
  "module_name": "extcon-intel-int3496.c",
  "hash_id": "aaf0e8e8bca34fe598680ae0c6a3dc2912a35db27bb4cf17acd6a8c5c8f3e01d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-intel-int3496.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/devm-helpers.h>\n#include <linux/extcon-provider.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#define INT3496_GPIO_USB_ID\t0\n#define INT3496_GPIO_VBUS_EN\t1\n#define INT3496_GPIO_USB_MUX\t2\n#define DEBOUNCE_TIME\t\tmsecs_to_jiffies(50)\n\nstruct int3496_data {\n\tstruct device *dev;\n\tstruct extcon_dev *edev;\n\tstruct delayed_work work;\n\tstruct gpio_desc *gpio_usb_id;\n\tstruct gpio_desc *gpio_vbus_en;\n\tstruct gpio_desc *gpio_usb_mux;\n\tstruct regulator *vbus_boost;\n\tint usb_id_irq;\n\tbool vbus_boost_enabled;\n};\n\nstatic const unsigned int int3496_cable[] = {\n\tEXTCON_USB_HOST,\n\tEXTCON_NONE,\n};\n\nstatic const struct acpi_gpio_params id_gpios = { INT3496_GPIO_USB_ID, 0, false };\nstatic const struct acpi_gpio_params vbus_gpios = { INT3496_GPIO_VBUS_EN, 0, false };\nstatic const struct acpi_gpio_params mux_gpios = { INT3496_GPIO_USB_MUX, 0, false };\n\nstatic const struct acpi_gpio_mapping acpi_int3496_default_gpios[] = {\n\t \n\t{ \"id-gpios\", &id_gpios, 1, ACPI_GPIO_QUIRK_NO_IO_RESTRICTION },\n\t{ \"vbus-gpios\", &vbus_gpios, 1 },\n\t{ \"mux-gpios\", &mux_gpios, 1 },\n\t{ },\n};\n\nstatic void int3496_set_vbus_boost(struct int3496_data *data, bool enable)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(data->vbus_boost))\n\t\treturn;\n\n\tif (data->vbus_boost_enabled == enable)\n\t\treturn;\n\n\tif (enable)\n\t\tret = regulator_enable(data->vbus_boost);\n\telse\n\t\tret = regulator_disable(data->vbus_boost);\n\n\tif (ret == 0)\n\t\tdata->vbus_boost_enabled = enable;\n\telse\n\t\tdev_err(data->dev, \"Error updating Vbus boost regulator: %d\\n\", ret);\n}\n\nstatic void int3496_do_usb_id(struct work_struct *work)\n{\n\tstruct int3496_data *data =\n\t\tcontainer_of(work, struct int3496_data, work.work);\n\tint id = gpiod_get_value_cansleep(data->gpio_usb_id);\n\n\t \n\tdev_dbg(data->dev, \"Connected %s cable\\n\", id ? \"PERIPHERAL\" : \"HOST\");\n\n\t \n\tif (!IS_ERR(data->gpio_usb_mux))\n\t\tgpiod_direction_output(data->gpio_usb_mux, id);\n\n\tif (!IS_ERR(data->gpio_vbus_en))\n\t\tgpiod_direction_output(data->gpio_vbus_en, !id);\n\telse\n\t\tint3496_set_vbus_boost(data, !id);\n\n\textcon_set_state_sync(data->edev, EXTCON_USB_HOST, !id);\n}\n\nstatic irqreturn_t int3496_thread_isr(int irq, void *priv)\n{\n\tstruct int3496_data *data = priv;\n\n\t \n\tmod_delayed_work(system_wq, &data->work, DEBOUNCE_TIME);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int int3496_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct int3496_data *data;\n\tint ret;\n\n\tif (has_acpi_companion(dev)) {\n\t\tret = devm_acpi_dev_add_driver_gpios(dev, acpi_int3496_default_gpios);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"can't add GPIO ACPI mapping\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->dev = dev;\n\tret = devm_delayed_work_autocancel(dev, &data->work, int3496_do_usb_id);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->gpio_usb_id =\n\t\tdevm_gpiod_get(dev, \"id\", GPIOD_IN | GPIOD_FLAGS_BIT_NONEXCLUSIVE);\n\tif (IS_ERR(data->gpio_usb_id)) {\n\t\tret = PTR_ERR(data->gpio_usb_id);\n\t\tdev_err(dev, \"can't request USB ID GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata->usb_id_irq = gpiod_to_irq(data->gpio_usb_id);\n\tif (data->usb_id_irq < 0) {\n\t\tdev_err(dev, \"can't get USB ID IRQ: %d\\n\", data->usb_id_irq);\n\t\treturn data->usb_id_irq;\n\t}\n\n\tdata->gpio_vbus_en = devm_gpiod_get(dev, \"vbus\", GPIOD_ASIS);\n\tif (IS_ERR(data->gpio_vbus_en)) {\n\t\tdev_dbg(dev, \"can't request VBUS EN GPIO\\n\");\n\t\tdata->vbus_boost = devm_regulator_get_optional(dev, \"vbus\");\n\t}\n\n\tdata->gpio_usb_mux = devm_gpiod_get(dev, \"mux\", GPIOD_ASIS);\n\tif (IS_ERR(data->gpio_usb_mux))\n\t\tdev_dbg(dev, \"can't request USB MUX GPIO\\n\");\n\n\t \n\tdata->edev = devm_extcon_dev_allocate(dev, int3496_cable);\n\tif (IS_ERR(data->edev))\n\t\treturn -ENOMEM;\n\n\tret = devm_extcon_dev_register(dev, data->edev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't register extcon device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(dev, data->usb_id_irq,\n\t\t\t\t\tNULL, int3496_thread_isr,\n\t\t\t\t\tIRQF_SHARED | IRQF_ONESHOT |\n\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\tIRQF_TRIGGER_FALLING,\n\t\t\t\t\tdev_name(dev), data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't request IRQ for USB ID GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tqueue_delayed_work(system_wq, &data->work, 0);\n\tflush_delayed_work(&data->work);\n\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id int3496_acpi_match[] = {\n\t{ \"INT3496\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, int3496_acpi_match);\n\nstatic const struct platform_device_id int3496_ids[] = {\n\t{ .name = \"intel-int3496\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, int3496_ids);\n\nstatic struct platform_driver int3496_driver = {\n\t.driver = {\n\t\t.name = \"intel-int3496\",\n\t\t.acpi_match_table = int3496_acpi_match,\n\t},\n\t.probe = int3496_probe,\n\t.id_table = int3496_ids,\n};\n\nmodule_platform_driver(int3496_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"Intel INT3496 ACPI device extcon driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}