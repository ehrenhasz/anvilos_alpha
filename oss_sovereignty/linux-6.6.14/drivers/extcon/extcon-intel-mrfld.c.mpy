{
  "module_name": "extcon-intel-mrfld.c",
  "hash_id": "151dbc0d6177efab8dad53376285d650d6fd3a291585725f0a64d93c52834d6e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-intel-mrfld.c",
  "human_readable_source": "\n \n\n#include <linux/extcon-provider.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/mfd/intel_soc_pmic_mrfld.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include \"extcon-intel.h\"\n\n#define BCOVE_USBIDCTRL\t\t\t0x19\n#define BCOVE_USBIDCTRL_ID\t\tBIT(0)\n#define BCOVE_USBIDCTRL_ACA\t\tBIT(1)\n#define BCOVE_USBIDCTRL_ALL\t(BCOVE_USBIDCTRL_ID | BCOVE_USBIDCTRL_ACA)\n\n#define BCOVE_USBIDSTS\t\t\t0x1a\n#define BCOVE_USBIDSTS_GND\t\tBIT(0)\n#define BCOVE_USBIDSTS_RARBRC_MASK\tGENMASK(2, 1)\n#define BCOVE_USBIDSTS_RARBRC_SHIFT\t1\n#define BCOVE_USBIDSTS_NO_ACA\t\t0\n#define BCOVE_USBIDSTS_R_ID_A\t\t1\n#define BCOVE_USBIDSTS_R_ID_B\t\t2\n#define BCOVE_USBIDSTS_R_ID_C\t\t3\n#define BCOVE_USBIDSTS_FLOAT\t\tBIT(3)\n#define BCOVE_USBIDSTS_SHORT\t\tBIT(4)\n\n#define BCOVE_CHGRIRQ_ALL\t(BCOVE_CHGRIRQ_VBUSDET | BCOVE_CHGRIRQ_DCDET | \\\n\t\t\t\t BCOVE_CHGRIRQ_BATTDET | BCOVE_CHGRIRQ_USBIDDET)\n\n#define BCOVE_CHGRCTRL0\t\t\t0x4b\n#define BCOVE_CHGRCTRL0_CHGRRESET\tBIT(0)\n#define BCOVE_CHGRCTRL0_EMRGCHREN\tBIT(1)\n#define BCOVE_CHGRCTRL0_EXTCHRDIS\tBIT(2)\n#define BCOVE_CHGRCTRL0_SWCONTROL\tBIT(3)\n#define BCOVE_CHGRCTRL0_TTLCK\t\tBIT(4)\n#define BCOVE_CHGRCTRL0_BIT_5\t\tBIT(5)\n#define BCOVE_CHGRCTRL0_BIT_6\t\tBIT(6)\n#define BCOVE_CHGRCTRL0_CHR_WDT_NOKICK\tBIT(7)\n\nstruct mrfld_extcon_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct extcon_dev *edev;\n\tunsigned int status;\n\tunsigned int id;\n};\n\nstatic const unsigned int mrfld_extcon_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_CHG_USB_SDP,\n\tEXTCON_CHG_USB_CDP,\n\tEXTCON_CHG_USB_DCP,\n\tEXTCON_CHG_USB_ACA,\n\tEXTCON_NONE,\n};\n\nstatic int mrfld_extcon_clear(struct mrfld_extcon_data *data, unsigned int reg,\n\t\t\t      unsigned int mask)\n{\n\treturn regmap_update_bits(data->regmap, reg, mask, 0x00);\n}\n\nstatic int mrfld_extcon_set(struct mrfld_extcon_data *data, unsigned int reg,\n\t\t\t    unsigned int mask)\n{\n\treturn regmap_update_bits(data->regmap, reg, mask, 0xff);\n}\n\nstatic int mrfld_extcon_sw_control(struct mrfld_extcon_data *data, bool enable)\n{\n\tunsigned int mask = BCOVE_CHGRCTRL0_SWCONTROL;\n\tstruct device *dev = data->dev;\n\tint ret;\n\n\tif (enable)\n\t\tret = mrfld_extcon_set(data, BCOVE_CHGRCTRL0, mask);\n\telse\n\t\tret = mrfld_extcon_clear(data, BCOVE_CHGRCTRL0, mask);\n\tif (ret)\n\t\tdev_err(dev, \"can't set SW control: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int mrfld_extcon_get_id(struct mrfld_extcon_data *data)\n{\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int id;\n\tbool ground;\n\tint ret;\n\n\tret = regmap_read(regmap, BCOVE_USBIDSTS, &id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (id & BCOVE_USBIDSTS_FLOAT)\n\t\treturn INTEL_USB_ID_FLOAT;\n\n\tswitch ((id & BCOVE_USBIDSTS_RARBRC_MASK) >> BCOVE_USBIDSTS_RARBRC_SHIFT) {\n\tcase BCOVE_USBIDSTS_R_ID_A:\n\t\treturn INTEL_USB_RID_A;\n\tcase BCOVE_USBIDSTS_R_ID_B:\n\t\treturn INTEL_USB_RID_B;\n\tcase BCOVE_USBIDSTS_R_ID_C:\n\t\treturn INTEL_USB_RID_C;\n\t}\n\n\t \n\tground = id & BCOVE_USBIDSTS_GND;\n\tswitch ('A' + BCOVE_MAJOR(data->id)) {\n\tcase 'A':\n\t\treturn ground ? INTEL_USB_ID_GND : INTEL_USB_ID_FLOAT;\n\tcase 'B':\n\t\treturn ground ? INTEL_USB_ID_FLOAT : INTEL_USB_ID_GND;\n\t}\n\n\t \n\treturn INTEL_USB_ID_FLOAT;\n}\n\nstatic int mrfld_extcon_role_detect(struct mrfld_extcon_data *data)\n{\n\tunsigned int id;\n\tbool usb_host;\n\tint ret;\n\n\tret = mrfld_extcon_get_id(data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tid = ret;\n\n\tusb_host = (id == INTEL_USB_ID_GND) || (id == INTEL_USB_RID_A);\n\textcon_set_state_sync(data->edev, EXTCON_USB_HOST, usb_host);\n\n\treturn 0;\n}\n\nstatic int mrfld_extcon_cable_detect(struct mrfld_extcon_data *data)\n{\n\tstruct regmap *regmap = data->regmap;\n\tunsigned int status, change;\n\tint ret;\n\n\t \n\tret = regmap_read(regmap, BCOVE_SCHGRIRQ1, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tchange = status ^ data->status;\n\tif (!change)\n\t\treturn -ENODATA;\n\n\tif (change & BCOVE_CHGRIRQ_USBIDDET) {\n\t\tret = mrfld_extcon_role_detect(data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdata->status = status;\n\n\treturn 0;\n}\n\nstatic irqreturn_t mrfld_extcon_interrupt(int irq, void *dev_id)\n{\n\tstruct mrfld_extcon_data *data = dev_id;\n\tint ret;\n\n\tret = mrfld_extcon_cable_detect(data);\n\n\tmrfld_extcon_clear(data, BCOVE_MIRQLVL1, BCOVE_LVL1_CHGR);\n\n\treturn ret ? IRQ_NONE: IRQ_HANDLED;\n}\n\nstatic int mrfld_extcon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(dev->parent);\n\tstruct regmap *regmap = pmic->regmap;\n\tstruct mrfld_extcon_data *data;\n\tunsigned int status;\n\tunsigned int id;\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->dev = dev;\n\tdata->regmap = regmap;\n\n\tdata->edev = devm_extcon_dev_allocate(dev, mrfld_extcon_cable);\n\tif (IS_ERR(data->edev))\n\t\treturn -ENOMEM;\n\n\tret = devm_extcon_dev_register(dev, data->edev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't register extcon device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(dev, irq, NULL, mrfld_extcon_interrupt,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED, pdev->name,\n\t\t\t\t\tdata);\n\tif (ret) {\n\t\tdev_err(dev, \"can't register IRQ handler: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(regmap, BCOVE_ID, &id);\n\tif (ret) {\n\t\tdev_err(dev, \"can't read PMIC ID: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata->id = id;\n\n\tret = mrfld_extcon_sw_control(data, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmrfld_extcon_role_detect(data);\n\n\t \n\tregmap_read(regmap, BCOVE_SCHGRIRQ1, &status);\n\tdata->status = status;\n\n\tmrfld_extcon_clear(data, BCOVE_MIRQLVL1, BCOVE_LVL1_CHGR);\n\tmrfld_extcon_clear(data, BCOVE_MCHGRIRQ1, BCOVE_CHGRIRQ_ALL);\n\n\tmrfld_extcon_set(data, BCOVE_USBIDCTRL, BCOVE_USBIDCTRL_ALL);\n\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n}\n\nstatic int mrfld_extcon_remove(struct platform_device *pdev)\n{\n\tstruct mrfld_extcon_data *data = platform_get_drvdata(pdev);\n\n\tmrfld_extcon_sw_control(data, false);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id mrfld_extcon_id_table[] = {\n\t{ .name = \"mrfld_bcove_pwrsrc\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(platform, mrfld_extcon_id_table);\n\nstatic struct platform_driver mrfld_extcon_driver = {\n\t.driver = {\n\t\t.name\t= \"mrfld_bcove_pwrsrc\",\n\t},\n\t.probe\t\t= mrfld_extcon_probe,\n\t.remove\t\t= mrfld_extcon_remove,\n\t.id_table\t= mrfld_extcon_id_table,\n};\nmodule_platform_driver(mrfld_extcon_driver);\n\nMODULE_AUTHOR(\"Andy Shevchenko <andriy.shevchenko@linux.intel.com>\");\nMODULE_DESCRIPTION(\"extcon driver for Intel Merrifield Basin Cove PMIC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}