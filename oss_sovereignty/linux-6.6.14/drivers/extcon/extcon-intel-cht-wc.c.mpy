{
  "module_name": "extcon-intel-cht-wc.c",
  "hash_id": "b089ee9cf2b027e6d4e97f643867ffa7e7a807888368fb9b3c5dc6bd51fbfc46",
  "original_prompt": "Ingested from linux-6.6.14/drivers/extcon/extcon-intel-cht-wc.c",
  "human_readable_source": "\n \n\n#include <linux/extcon-provider.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/usb/role.h>\n\n#include \"extcon-intel.h\"\n\n#define CHT_WC_PHYCTRL\t\t\t0x5e07\n\n#define CHT_WC_CHGRCTRL0\t\t0x5e16\n#define CHT_WC_CHGRCTRL0_CHGRRESET\tBIT(0)\n#define CHT_WC_CHGRCTRL0_EMRGCHREN\tBIT(1)\n#define CHT_WC_CHGRCTRL0_EXTCHRDIS\tBIT(2)\n#define CHT_WC_CHGRCTRL0_SWCONTROL\tBIT(3)\n#define CHT_WC_CHGRCTRL0_TTLCK\t\tBIT(4)\n#define CHT_WC_CHGRCTRL0_CCSM_OFF\tBIT(5)\n#define CHT_WC_CHGRCTRL0_DBPOFF\t\tBIT(6)\n#define CHT_WC_CHGRCTRL0_CHR_WDT_NOKICK\tBIT(7)\n\n#define CHT_WC_CHGRCTRL1\t\t\t0x5e17\n#define CHT_WC_CHGRCTRL1_FUSB_INLMT_100\t\tBIT(0)\n#define CHT_WC_CHGRCTRL1_FUSB_INLMT_150\t\tBIT(1)\n#define CHT_WC_CHGRCTRL1_FUSB_INLMT_500\t\tBIT(2)\n#define CHT_WC_CHGRCTRL1_FUSB_INLMT_900\t\tBIT(3)\n#define CHT_WC_CHGRCTRL1_FUSB_INLMT_1500\tBIT(4)\n#define CHT_WC_CHGRCTRL1_FTEMP_EVENT\t\tBIT(5)\n#define CHT_WC_CHGRCTRL1_OTGMODE\t\tBIT(6)\n#define CHT_WC_CHGRCTRL1_DBPEN\t\t\tBIT(7)\n\n#define CHT_WC_USBSRC\t\t\t0x5e29\n#define CHT_WC_USBSRC_STS_MASK\t\tGENMASK(1, 0)\n#define CHT_WC_USBSRC_STS_SUCCESS\t2\n#define CHT_WC_USBSRC_STS_FAIL\t\t3\n#define CHT_WC_USBSRC_TYPE_SHIFT\t2\n#define CHT_WC_USBSRC_TYPE_MASK\t\tGENMASK(5, 2)\n#define CHT_WC_USBSRC_TYPE_NONE\t\t0\n#define CHT_WC_USBSRC_TYPE_SDP\t\t1\n#define CHT_WC_USBSRC_TYPE_DCP\t\t2\n#define CHT_WC_USBSRC_TYPE_CDP\t\t3\n#define CHT_WC_USBSRC_TYPE_ACA\t\t4\n#define CHT_WC_USBSRC_TYPE_SE1\t\t5\n#define CHT_WC_USBSRC_TYPE_MHL\t\t6\n#define CHT_WC_USBSRC_TYPE_FLOATING\t7\n#define CHT_WC_USBSRC_TYPE_OTHER\t8\n#define CHT_WC_USBSRC_TYPE_DCP_EXTPHY\t9\n\n#define CHT_WC_CHGDISCTRL\t\t0x5e2f\n#define CHT_WC_CHGDISCTRL_OUT\t\tBIT(0)\n \n#define CHT_WC_CHGDISCTRL_DRV\t\tBIT(4)\n \n#define CHT_WC_CHGDISCTRL_FN\t\tBIT(6)\n\n#define CHT_WC_PWRSRC_IRQ\t\t0x6e03\n#define CHT_WC_PWRSRC_IRQ_MASK\t\t0x6e0f\n#define CHT_WC_PWRSRC_STS\t\t0x6e1e\n#define CHT_WC_PWRSRC_VBUS\t\tBIT(0)\n#define CHT_WC_PWRSRC_DC\t\tBIT(1)\n#define CHT_WC_PWRSRC_BATT\t\tBIT(2)\n#define CHT_WC_PWRSRC_USBID_MASK\tGENMASK(4, 3)\n#define CHT_WC_PWRSRC_USBID_SHIFT\t3\n#define CHT_WC_PWRSRC_RID_ACA\t\t0\n#define CHT_WC_PWRSRC_RID_GND\t\t1\n#define CHT_WC_PWRSRC_RID_FLOAT\t\t2\n\n#define CHT_WC_VBUS_GPIO_CTLO\t\t0x6e2d\n#define CHT_WC_VBUS_GPIO_CTLO_OUTPUT\tBIT(0)\n#define CHT_WC_VBUS_GPIO_CTLO_DRV_OD\tBIT(4)\n#define CHT_WC_VBUS_GPIO_CTLO_DIR_OUT\tBIT(5)\n\nenum cht_wc_mux_select {\n\tMUX_SEL_PMIC = 0,\n\tMUX_SEL_SOC,\n};\n\nstatic const unsigned int cht_wc_extcon_cables[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_CHG_USB_SDP,\n\tEXTCON_CHG_USB_CDP,\n\tEXTCON_CHG_USB_DCP,\n\tEXTCON_CHG_USB_ACA,\n\tEXTCON_NONE,\n};\n\nstruct cht_wc_extcon_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct extcon_dev *edev;\n\tstruct usb_role_switch *role_sw;\n\tstruct regulator *vbus_boost;\n\tstruct power_supply *psy;\n\tenum power_supply_usb_type usb_type;\n\tunsigned int previous_cable;\n\tbool usb_host;\n\tbool vbus_boost_enabled;\n};\n\nstatic int cht_wc_extcon_get_id(struct cht_wc_extcon_data *ext, int pwrsrc_sts)\n{\n\tswitch ((pwrsrc_sts & CHT_WC_PWRSRC_USBID_MASK) >> CHT_WC_PWRSRC_USBID_SHIFT) {\n\tcase CHT_WC_PWRSRC_RID_GND:\n\t\treturn INTEL_USB_ID_GND;\n\tcase CHT_WC_PWRSRC_RID_FLOAT:\n\t\treturn INTEL_USB_ID_FLOAT;\n\t \n\tcase CHT_WC_PWRSRC_RID_ACA:\n\t\treturn INTEL_USB_RID_A;\n\tdefault:\n\t\treturn INTEL_USB_ID_FLOAT;\n\t}\n}\n\nstatic int cht_wc_extcon_get_charger(struct cht_wc_extcon_data *ext,\n\t\t\t\t     bool ignore_errors)\n{\n\tint ret, usbsrc, status;\n\tunsigned long timeout;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(800);\n\tdo {\n\t\tret = regmap_read(ext->regmap, CHT_WC_USBSRC, &usbsrc);\n\t\tif (ret) {\n\t\t\tdev_err(ext->dev, \"Error reading usbsrc: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tstatus = usbsrc & CHT_WC_USBSRC_STS_MASK;\n\t\tif (status == CHT_WC_USBSRC_STS_SUCCESS ||\n\t\t    status == CHT_WC_USBSRC_STS_FAIL)\n\t\t\tbreak;\n\n\t\tmsleep(50);  \n\t} while (time_before(jiffies, timeout));\n\n\tif (status != CHT_WC_USBSRC_STS_SUCCESS) {\n\t\tif (!ignore_errors) {\n\t\t\tif (status == CHT_WC_USBSRC_STS_FAIL)\n\t\t\t\tdev_warn(ext->dev, \"Could not detect charger type\\n\");\n\t\t\telse\n\t\t\t\tdev_warn(ext->dev, \"Timeout detecting charger type\\n\");\n\t\t}\n\n\t\t \n\t\tusbsrc = CHT_WC_USBSRC_TYPE_SDP << CHT_WC_USBSRC_TYPE_SHIFT;\n\t}\n\n\tusbsrc = (usbsrc & CHT_WC_USBSRC_TYPE_MASK) >> CHT_WC_USBSRC_TYPE_SHIFT;\n\tswitch (usbsrc) {\n\tdefault:\n\t\tdev_warn(ext->dev,\n\t\t\t\"Unhandled charger type %d, defaulting to SDP\\n\",\n\t\t\t ret);\n\t\text->usb_type = POWER_SUPPLY_USB_TYPE_SDP;\n\t\treturn EXTCON_CHG_USB_SDP;\n\tcase CHT_WC_USBSRC_TYPE_SDP:\n\tcase CHT_WC_USBSRC_TYPE_FLOATING:\n\tcase CHT_WC_USBSRC_TYPE_OTHER:\n\t\text->usb_type = POWER_SUPPLY_USB_TYPE_SDP;\n\t\treturn EXTCON_CHG_USB_SDP;\n\tcase CHT_WC_USBSRC_TYPE_CDP:\n\t\text->usb_type = POWER_SUPPLY_USB_TYPE_CDP;\n\t\treturn EXTCON_CHG_USB_CDP;\n\tcase CHT_WC_USBSRC_TYPE_DCP:\n\tcase CHT_WC_USBSRC_TYPE_DCP_EXTPHY:\n\tcase CHT_WC_USBSRC_TYPE_MHL:  \n\t\text->usb_type = POWER_SUPPLY_USB_TYPE_DCP;\n\t\treturn EXTCON_CHG_USB_DCP;\n\tcase CHT_WC_USBSRC_TYPE_ACA:\n\t\text->usb_type = POWER_SUPPLY_USB_TYPE_ACA;\n\t\treturn EXTCON_CHG_USB_ACA;\n\t}\n}\n\nstatic void cht_wc_extcon_set_phymux(struct cht_wc_extcon_data *ext, u8 state)\n{\n\tint ret;\n\n\tret = regmap_write(ext->regmap, CHT_WC_PHYCTRL, state);\n\tif (ret)\n\t\tdev_err(ext->dev, \"Error writing phyctrl: %d\\n\", ret);\n}\n\nstatic void cht_wc_extcon_set_5v_boost(struct cht_wc_extcon_data *ext,\n\t\t\t\t       bool enable)\n{\n\tint ret, val;\n\n\t \n\tval = CHT_WC_VBUS_GPIO_CTLO_DRV_OD | CHT_WC_VBUS_GPIO_CTLO_DIR_OUT;\n\tif (enable)\n\t\tval |= CHT_WC_VBUS_GPIO_CTLO_OUTPUT;\n\n\tret = regmap_write(ext->regmap, CHT_WC_VBUS_GPIO_CTLO, val);\n\tif (ret)\n\t\tdev_err(ext->dev, \"Error writing Vbus GPIO CTLO: %d\\n\", ret);\n}\n\nstatic void cht_wc_extcon_set_otgmode(struct cht_wc_extcon_data *ext,\n\t\t\t\t      bool enable)\n{\n\tunsigned int val = enable ? CHT_WC_CHGRCTRL1_OTGMODE : 0;\n\tint ret;\n\n\tret = regmap_update_bits(ext->regmap, CHT_WC_CHGRCTRL1,\n\t\t\t\t CHT_WC_CHGRCTRL1_OTGMODE, val);\n\tif (ret)\n\t\tdev_err(ext->dev, \"Error updating CHGRCTRL1 reg: %d\\n\", ret);\n\n\tif (ext->vbus_boost && ext->vbus_boost_enabled != enable) {\n\t\tif (enable)\n\t\t\tret = regulator_enable(ext->vbus_boost);\n\t\telse\n\t\t\tret = regulator_disable(ext->vbus_boost);\n\n\t\tif (ret)\n\t\t\tdev_err(ext->dev, \"Error updating Vbus boost regulator: %d\\n\", ret);\n\t\telse\n\t\t\text->vbus_boost_enabled = enable;\n\t}\n}\n\nstatic void cht_wc_extcon_enable_charging(struct cht_wc_extcon_data *ext,\n\t\t\t\t\t  bool enable)\n{\n\tunsigned int val = enable ? 0 : CHT_WC_CHGDISCTRL_OUT;\n\tint ret;\n\n\tret = regmap_update_bits(ext->regmap, CHT_WC_CHGDISCTRL,\n\t\t\t\t CHT_WC_CHGDISCTRL_OUT, val);\n\tif (ret)\n\t\tdev_err(ext->dev, \"Error updating CHGDISCTRL reg: %d\\n\", ret);\n}\n\n \nstatic void cht_wc_extcon_set_state(struct cht_wc_extcon_data *ext,\n\t\t\t\t    unsigned int cable, bool state)\n{\n\textcon_set_state_sync(ext->edev, cable, state);\n\tif (cable == EXTCON_CHG_USB_SDP)\n\t\textcon_set_state_sync(ext->edev, EXTCON_USB, state);\n}\n\nstatic void cht_wc_extcon_pwrsrc_event(struct cht_wc_extcon_data *ext)\n{\n\tint ret, pwrsrc_sts, id;\n\tunsigned int cable = EXTCON_NONE;\n\t \n\tbool ignore_get_charger_errors = ext->usb_host;\n\tenum usb_role role;\n\n\text->usb_type = POWER_SUPPLY_USB_TYPE_UNKNOWN;\n\n\tret = regmap_read(ext->regmap, CHT_WC_PWRSRC_STS, &pwrsrc_sts);\n\tif (ret) {\n\t\tdev_err(ext->dev, \"Error reading pwrsrc status: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tid = cht_wc_extcon_get_id(ext, pwrsrc_sts);\n\tif (id == INTEL_USB_ID_GND) {\n\t\tcht_wc_extcon_enable_charging(ext, false);\n\t\tcht_wc_extcon_set_otgmode(ext, true);\n\n\t\t \n\t\tgoto charger_det_done;\n\t}\n\n\tcht_wc_extcon_set_otgmode(ext, false);\n\tcht_wc_extcon_enable_charging(ext, true);\n\n\t \n\tif (!(pwrsrc_sts & CHT_WC_PWRSRC_VBUS)) {\n\t\t \n\t\tcht_wc_extcon_set_phymux(ext, MUX_SEL_PMIC);\n\t\tgoto set_state;\n\t}\n\n\tret = cht_wc_extcon_get_charger(ext, ignore_get_charger_errors);\n\tif (ret >= 0)\n\t\tcable = ret;\n\ncharger_det_done:\n\t \n\tcht_wc_extcon_set_phymux(ext, MUX_SEL_SOC);\n\nset_state:\n\tif (cable != ext->previous_cable) {\n\t\tcht_wc_extcon_set_state(ext, cable, true);\n\t\tcht_wc_extcon_set_state(ext, ext->previous_cable, false);\n\t\text->previous_cable = cable;\n\t}\n\n\text->usb_host = ((id == INTEL_USB_ID_GND) || (id == INTEL_USB_RID_A));\n\textcon_set_state_sync(ext->edev, EXTCON_USB_HOST, ext->usb_host);\n\n\tif (ext->usb_host)\n\t\trole = USB_ROLE_HOST;\n\telse if (pwrsrc_sts & CHT_WC_PWRSRC_VBUS)\n\t\trole = USB_ROLE_DEVICE;\n\telse\n\t\trole = USB_ROLE_NONE;\n\n\t \n\tret = usb_role_switch_set_role(ext->role_sw, role);\n\tif (ret)\n\t\tdev_err(ext->dev, \"Error setting USB-role: %d\\n\", ret);\n\n\tif (ext->psy)\n\t\tpower_supply_changed(ext->psy);\n}\n\nstatic irqreturn_t cht_wc_extcon_isr(int irq, void *data)\n{\n\tstruct cht_wc_extcon_data *ext = data;\n\tint ret, irqs;\n\n\tret = regmap_read(ext->regmap, CHT_WC_PWRSRC_IRQ, &irqs);\n\tif (ret) {\n\t\tdev_err(ext->dev, \"Error reading irqs: %d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tcht_wc_extcon_pwrsrc_event(ext);\n\n\tret = regmap_write(ext->regmap, CHT_WC_PWRSRC_IRQ, irqs);\n\tif (ret) {\n\t\tdev_err(ext->dev, \"Error writing irqs: %d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cht_wc_extcon_sw_control(struct cht_wc_extcon_data *ext, bool enable)\n{\n\tint ret, mask, val;\n\n\tval = enable ? 0 : CHT_WC_CHGDISCTRL_FN;\n\tret = regmap_update_bits(ext->regmap, CHT_WC_CHGDISCTRL,\n\t\t\t\t CHT_WC_CHGDISCTRL_FN, val);\n\tif (ret)\n\t\tdev_err(ext->dev,\n\t\t\t\"Error setting sw control for CHGDIS pin: %d\\n\",\n\t\t\tret);\n\n\tmask = CHT_WC_CHGRCTRL0_SWCONTROL | CHT_WC_CHGRCTRL0_CCSM_OFF;\n\tval = enable ? mask : 0;\n\tret = regmap_update_bits(ext->regmap, CHT_WC_CHGRCTRL0, mask, val);\n\tif (ret)\n\t\tdev_err(ext->dev, \"Error setting sw control: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int cht_wc_extcon_find_role_sw(struct cht_wc_extcon_data *ext)\n{\n\tconst struct software_node *swnode;\n\tstruct fwnode_handle *fwnode;\n\n\tswnode = software_node_find_by_name(NULL, \"intel-xhci-usb-sw\");\n\tif (!swnode)\n\t\treturn -EPROBE_DEFER;\n\n\tfwnode = software_node_fwnode(swnode);\n\text->role_sw = usb_role_switch_find_by_fwnode(fwnode);\n\tfwnode_handle_put(fwnode);\n\n\treturn ext->role_sw ? 0 : -EPROBE_DEFER;\n}\n\nstatic void cht_wc_extcon_put_role_sw(void *data)\n{\n\tstruct cht_wc_extcon_data *ext = data;\n\n\tusb_role_switch_put(ext->role_sw);\n}\n\n \nstatic int cht_wc_extcon_get_role_sw_and_regulator(struct cht_wc_extcon_data *ext)\n{\n\tint ret;\n\n\tret = cht_wc_extcon_find_role_sw(ext);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(ext->dev, cht_wc_extcon_put_role_sw, ext);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\text->vbus_boost = devm_regulator_get_optional(ext->dev, \"vbus\");\n\tif (IS_ERR(ext->vbus_boost)) {\n\t\tret = PTR_ERR(ext->vbus_boost);\n\t\tif (ret == -ENODEV)\n\t\t\tret = -EPROBE_DEFER;\n\n\t\treturn dev_err_probe(ext->dev, ret, \"getting Vbus regulator\");\n\t}\n\n\treturn 0;\n}\n\nstatic int cht_wc_extcon_psy_get_prop(struct power_supply *psy,\n\t\t\t\t      enum power_supply_property psp,\n\t\t\t\t      union power_supply_propval *val)\n{\n\tstruct cht_wc_extcon_data *ext = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\tval->intval = ext->usb_type;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = ext->usb_type ? 1 : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const enum power_supply_usb_type cht_wc_extcon_psy_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_SDP,\n\tPOWER_SUPPLY_USB_TYPE_CDP,\n\tPOWER_SUPPLY_USB_TYPE_DCP,\n\tPOWER_SUPPLY_USB_TYPE_ACA,\n\tPOWER_SUPPLY_USB_TYPE_UNKNOWN,\n};\n\nstatic const enum power_supply_property cht_wc_extcon_psy_props[] = {\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic const struct power_supply_desc cht_wc_extcon_psy_desc = {\n\t.name = \"cht_wcove_pwrsrc\",\n\t.type = POWER_SUPPLY_TYPE_USB,\n\t.usb_types = cht_wc_extcon_psy_usb_types,\n\t.num_usb_types = ARRAY_SIZE(cht_wc_extcon_psy_usb_types),\n\t.properties = cht_wc_extcon_psy_props,\n\t.num_properties = ARRAY_SIZE(cht_wc_extcon_psy_props),\n\t.get_property = cht_wc_extcon_psy_get_prop,\n};\n\nstatic int cht_wc_extcon_register_psy(struct cht_wc_extcon_data *ext)\n{\n\tstruct power_supply_config psy_cfg = { .drv_data = ext };\n\n\text->psy = devm_power_supply_register(ext->dev,\n\t\t\t\t\t      &cht_wc_extcon_psy_desc,\n\t\t\t\t\t      &psy_cfg);\n\treturn PTR_ERR_OR_ZERO(ext->psy);\n}\n\nstatic int cht_wc_extcon_probe(struct platform_device *pdev)\n{\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(pdev->dev.parent);\n\tstruct cht_wc_extcon_data *ext;\n\tunsigned long mask = ~(CHT_WC_PWRSRC_VBUS | CHT_WC_PWRSRC_USBID_MASK);\n\tint pwrsrc_sts, id;\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\text = devm_kzalloc(&pdev->dev, sizeof(*ext), GFP_KERNEL);\n\tif (!ext)\n\t\treturn -ENOMEM;\n\n\text->dev = &pdev->dev;\n\text->regmap = pmic->regmap;\n\text->previous_cable = EXTCON_NONE;\n\n\t \n\text->edev = devm_extcon_dev_allocate(ext->dev, cht_wc_extcon_cables);\n\tif (IS_ERR(ext->edev))\n\t\treturn PTR_ERR(ext->edev);\n\n\tswitch (pmic->cht_wc_model) {\n\tcase INTEL_CHT_WC_GPD_WIN_POCKET:\n\t\t \n\t\tcht_wc_extcon_set_5v_boost(ext, false);\n\t\tbreak;\n\tcase INTEL_CHT_WC_LENOVO_YOGABOOK1:\n\tcase INTEL_CHT_WC_LENOVO_YT3_X90:\n\t\t \n\t\tret = cht_wc_extcon_get_role_sw_and_regulator(ext);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tret = cht_wc_extcon_register_psy(ext);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase INTEL_CHT_WC_XIAOMI_MIPAD2:\n\t\tret = cht_wc_extcon_get_role_sw_and_regulator(ext);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tret = cht_wc_extcon_sw_control(ext, true);\n\tif (ret)\n\t\tgoto disable_sw_control;\n\n\t \n\tcht_wc_extcon_enable_charging(ext, false);\n\n\t \n\tret = devm_extcon_dev_register(ext->dev, ext->edev);\n\tif (ret) {\n\t\tdev_err(ext->dev, \"Error registering extcon device: %d\\n\", ret);\n\t\tgoto disable_sw_control;\n\t}\n\n\tret = regmap_read(ext->regmap, CHT_WC_PWRSRC_STS, &pwrsrc_sts);\n\tif (ret) {\n\t\tdev_err(ext->dev, \"Error reading pwrsrc status: %d\\n\", ret);\n\t\tgoto disable_sw_control;\n\t}\n\n\t \n\tid = cht_wc_extcon_get_id(ext, pwrsrc_sts);\n\tif (id != INTEL_USB_ID_GND)\n\t\tcht_wc_extcon_set_phymux(ext, MUX_SEL_PMIC);\n\n\t \n\tcht_wc_extcon_pwrsrc_event(ext);\n\n\tret = devm_request_threaded_irq(ext->dev, irq, NULL, cht_wc_extcon_isr,\n\t\t\t\t\tIRQF_ONESHOT, pdev->name, ext);\n\tif (ret) {\n\t\tdev_err(ext->dev, \"Error requesting interrupt: %d\\n\", ret);\n\t\tgoto disable_sw_control;\n\t}\n\n\t \n\tret = regmap_write(ext->regmap, CHT_WC_PWRSRC_IRQ_MASK, mask);\n\tif (ret) {\n\t\tdev_err(ext->dev, \"Error writing irq-mask: %d\\n\", ret);\n\t\tgoto disable_sw_control;\n\t}\n\n\tplatform_set_drvdata(pdev, ext);\n\n\treturn 0;\n\ndisable_sw_control:\n\tcht_wc_extcon_sw_control(ext, false);\n\treturn ret;\n}\n\nstatic int cht_wc_extcon_remove(struct platform_device *pdev)\n{\n\tstruct cht_wc_extcon_data *ext = platform_get_drvdata(pdev);\n\n\tcht_wc_extcon_sw_control(ext, false);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id cht_wc_extcon_table[] = {\n\t{ .name = \"cht_wcove_pwrsrc\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, cht_wc_extcon_table);\n\nstatic struct platform_driver cht_wc_extcon_driver = {\n\t.probe = cht_wc_extcon_probe,\n\t.remove = cht_wc_extcon_remove,\n\t.id_table = cht_wc_extcon_table,\n\t.driver = {\n\t\t.name = \"cht_wcove_pwrsrc\",\n\t},\n};\nmodule_platform_driver(cht_wc_extcon_driver);\n\nMODULE_DESCRIPTION(\"Intel Cherrytrail Whiskey Cove PMIC extcon driver\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}