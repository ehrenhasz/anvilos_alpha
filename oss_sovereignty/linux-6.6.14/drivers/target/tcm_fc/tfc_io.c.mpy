{
  "module_name": "tfc_io.c",
  "hash_id": "5216f962e4cea2b534c39504f561514de344e6c650d7f69dd562c65186934302",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/tcm_fc/tfc_io.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/configfs.h>\n#include <linux/ctype.h>\n#include <linux/hash.h>\n#include <linux/ratelimit.h>\n#include <asm/unaligned.h>\n#include <scsi/libfc.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include \"tcm_fc.h\"\n\n \nint ft_queue_data_in(struct se_cmd *se_cmd)\n{\n\tstruct ft_cmd *cmd = container_of(se_cmd, struct ft_cmd, se_cmd);\n\tstruct fc_frame *fp = NULL;\n\tstruct fc_exch *ep;\n\tstruct fc_lport *lport;\n\tstruct scatterlist *sg = NULL;\n\tsize_t remaining;\n\tu32 f_ctl = FC_FC_EX_CTX | FC_FC_REL_OFF;\n\tu32 mem_off = 0;\n\tu32 fh_off = 0;\n\tu32 frame_off = 0;\n\tsize_t frame_len = 0;\n\tsize_t mem_len = 0;\n\tsize_t tlen;\n\tsize_t off_in_page;\n\tstruct page *page = NULL;\n\tint use_sg;\n\tint error;\n\tvoid *page_addr;\n\tvoid *from;\n\tvoid *to = NULL;\n\n\tif (cmd->aborted)\n\t\treturn 0;\n\n\tif (se_cmd->scsi_status == SAM_STAT_TASK_SET_FULL)\n\t\tgoto queue_status;\n\n\tep = fc_seq_exch(cmd->seq);\n\tlport = ep->lp;\n\tcmd->seq = fc_seq_start_next(cmd->seq);\n\n\tremaining = se_cmd->data_length;\n\n\t \n\tBUG_ON(remaining && !se_cmd->t_data_sg);\n\tif (remaining) {\n\t\tsg = se_cmd->t_data_sg;\n\t\tmem_len = sg->length;\n\t\tmem_off = sg->offset;\n\t\tpage = sg_page(sg);\n\t}\n\n\t \n\tuse_sg = !(remaining % 4);\n\n\twhile (remaining) {\n\t\tstruct fc_seq *seq = cmd->seq;\n\n\t\tif (!seq) {\n\t\t\tpr_debug(\"%s: Command aborted, xid 0x%x\\n\",\n\t\t\t\t __func__, ep->xid);\n\t\t\tbreak;\n\t\t}\n\t\tif (!mem_len) {\n\t\t\tsg = sg_next(sg);\n\t\t\tmem_len = min((size_t)sg->length, remaining);\n\t\t\tmem_off = sg->offset;\n\t\t\tpage = sg_page(sg);\n\t\t}\n\t\tif (!frame_len) {\n\t\t\t \n\t\t\tframe_len = (lport->seq_offload) ? lport->lso_max :\n\t\t\t\t\t\t\t  cmd->sess->max_frame;\n\t\t\tframe_len = min(frame_len, remaining);\n\t\t\tfp = fc_frame_alloc(lport, use_sg ? 0 : frame_len);\n\t\t\tif (!fp)\n\t\t\t\treturn -ENOMEM;\n\t\t\tto = fc_frame_payload_get(fp, 0);\n\t\t\tfh_off = frame_off;\n\t\t\tframe_off += frame_len;\n\t\t\t \n\t\t\tfr_max_payload(fp) = cmd->sess->max_frame;\n\t\t}\n\t\ttlen = min(mem_len, frame_len);\n\n\t\tif (use_sg) {\n\t\t\toff_in_page = mem_off;\n\t\t\tBUG_ON(!page);\n\t\t\tget_page(page);\n\t\t\tskb_fill_page_desc(fp_skb(fp),\n\t\t\t\t\t   skb_shinfo(fp_skb(fp))->nr_frags,\n\t\t\t\t\t   page, off_in_page, tlen);\n\t\t\tfr_len(fp) += tlen;\n\t\t\tfp_skb(fp)->data_len += tlen;\n\t\t\tfp_skb(fp)->truesize += page_size(page);\n\t\t} else {\n\t\t\tBUG_ON(!page);\n\t\t\tfrom = kmap_atomic(page + (mem_off >> PAGE_SHIFT));\n\t\t\tpage_addr = from;\n\t\t\tfrom += offset_in_page(mem_off);\n\t\t\ttlen = min(tlen, (size_t)(PAGE_SIZE -\n\t\t\t\t\t\toffset_in_page(mem_off)));\n\t\t\tmemcpy(to, from, tlen);\n\t\t\tkunmap_atomic(page_addr);\n\t\t\tto += tlen;\n\t\t}\n\n\t\tmem_off += tlen;\n\t\tmem_len -= tlen;\n\t\tframe_len -= tlen;\n\t\tremaining -= tlen;\n\n\t\tif (frame_len &&\n\t\t    (skb_shinfo(fp_skb(fp))->nr_frags < FC_FRAME_SG_LEN))\n\t\t\tcontinue;\n\t\tif (!remaining)\n\t\t\tf_ctl |= FC_FC_END_SEQ;\n\t\tfc_fill_fc_hdr(fp, FC_RCTL_DD_SOL_DATA, ep->did, ep->sid,\n\t\t\t       FC_TYPE_FCP, f_ctl, fh_off);\n\t\terror = fc_seq_send(lport, seq, fp);\n\t\tif (error) {\n\t\t\tpr_info_ratelimited(\"%s: Failed to send frame %p, \"\n\t\t\t\t\t\t\"xid <0x%x>, remaining %zu, \"\n\t\t\t\t\t\t\"lso_max <0x%x>\\n\",\n\t\t\t\t\t\t__func__, fp, ep->xid,\n\t\t\t\t\t\tremaining, lport->lso_max);\n\t\t\t \n\t\t\tse_cmd->scsi_status = SAM_STAT_TASK_SET_FULL;\n\t\t\tbreak;\n\t\t}\n\t}\nqueue_status:\n\treturn ft_queue_status(se_cmd);\n}\n\nstatic void ft_execute_work(struct work_struct *work)\n{\n\tstruct ft_cmd *cmd = container_of(work, struct ft_cmd, work);\n\n\ttarget_execute_cmd(&cmd->se_cmd);\n}\n\n \nvoid ft_recv_write_data(struct ft_cmd *cmd, struct fc_frame *fp)\n{\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct fc_seq *seq = cmd->seq;\n\tstruct fc_exch *ep;\n\tstruct fc_lport *lport;\n\tstruct fc_frame_header *fh;\n\tstruct scatterlist *sg = NULL;\n\tu32 mem_off = 0;\n\tu32 rel_off;\n\tsize_t frame_len;\n\tsize_t mem_len = 0;\n\tsize_t tlen;\n\tstruct page *page = NULL;\n\tvoid *page_addr;\n\tvoid *from;\n\tvoid *to;\n\tu32 f_ctl;\n\tvoid *buf;\n\n\tfh = fc_frame_header_get(fp);\n\tif (!(ntoh24(fh->fh_f_ctl) & FC_FC_REL_OFF))\n\t\tgoto drop;\n\n\tf_ctl = ntoh24(fh->fh_f_ctl);\n\tep = fc_seq_exch(seq);\n\tlport = ep->lp;\n\tif (cmd->was_ddp_setup) {\n\t\tBUG_ON(!lport);\n\t\t \n\t\tbuf = fc_frame_payload_get(fp, 1);\n\t\tif (buf)\n\t\t\tpr_err(\"%s: xid 0x%x, f_ctl 0x%x, cmd->sg %p, \"\n\t\t\t\t\"cmd->sg_cnt 0x%x. DDP was setup\"\n\t\t\t\t\" hence not expected to receive frame with \"\n\t\t\t\t\"payload, Frame will be dropped if\"\n\t\t\t\t\"'Sequence Initiative' bit in f_ctl is\"\n\t\t\t\t\"not set\\n\", __func__, ep->xid, f_ctl,\n\t\t\t\tse_cmd->t_data_sg, se_cmd->t_data_nents);\n\t\t \n\t\tft_invl_hw_context(cmd);\n\n\t\t \n\t\tif (f_ctl & FC_FC_SEQ_INIT)\n\t\t\tgoto last_frame;\n\t\telse\n\t\t\tgoto drop;\n\t}\n\n\trel_off = ntohl(fh->fh_parm_offset);\n\tframe_len = fr_len(fp);\n\tif (frame_len <= sizeof(*fh))\n\t\tgoto drop;\n\tframe_len -= sizeof(*fh);\n\tfrom = fc_frame_payload_get(fp, 0);\n\tif (rel_off >= se_cmd->data_length)\n\t\tgoto drop;\n\tif (frame_len + rel_off > se_cmd->data_length)\n\t\tframe_len = se_cmd->data_length - rel_off;\n\n\t \n\tBUG_ON(frame_len && !se_cmd->t_data_sg);\n\tif (frame_len) {\n\t\tsg = se_cmd->t_data_sg;\n\t\tmem_len = sg->length;\n\t\tmem_off = sg->offset;\n\t\tpage = sg_page(sg);\n\t}\n\n\twhile (frame_len) {\n\t\tif (!mem_len) {\n\t\t\tsg = sg_next(sg);\n\t\t\tmem_len = sg->length;\n\t\t\tmem_off = sg->offset;\n\t\t\tpage = sg_page(sg);\n\t\t}\n\t\tif (rel_off >= mem_len) {\n\t\t\trel_off -= mem_len;\n\t\t\tmem_len = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tmem_off += rel_off;\n\t\tmem_len -= rel_off;\n\t\trel_off = 0;\n\n\t\ttlen = min(mem_len, frame_len);\n\n\t\tto = kmap_atomic(page + (mem_off >> PAGE_SHIFT));\n\t\tpage_addr = to;\n\t\tto += offset_in_page(mem_off);\n\t\ttlen = min(tlen, (size_t)(PAGE_SIZE -\n\t\t\t\t\t  offset_in_page(mem_off)));\n\t\tmemcpy(to, from, tlen);\n\t\tkunmap_atomic(page_addr);\n\n\t\tfrom += tlen;\n\t\tframe_len -= tlen;\n\t\tmem_off += tlen;\n\t\tmem_len -= tlen;\n\t\tcmd->write_data_len += tlen;\n\t}\nlast_frame:\n\tif (cmd->write_data_len == se_cmd->data_length) {\n\t\tINIT_WORK(&cmd->work, ft_execute_work);\n\t\tqueue_work(cmd->sess->tport->tpg->workqueue, &cmd->work);\n\t}\ndrop:\n\tfc_frame_free(fp);\n}\n\n \nvoid ft_invl_hw_context(struct ft_cmd *cmd)\n{\n\tstruct fc_seq *seq;\n\tstruct fc_exch *ep = NULL;\n\tstruct fc_lport *lport = NULL;\n\n\tBUG_ON(!cmd);\n\tseq = cmd->seq;\n\n\t \n\tif (cmd->was_ddp_setup && seq) {\n\t\tep = fc_seq_exch(seq);\n\t\tif (ep) {\n\t\t\tlport = ep->lp;\n\t\t\tif (lport && (ep->xid <= lport->lro_xid)) {\n\t\t\t\t \n\t\t\t\tcmd->write_data_len = lport->tt.ddp_done(lport,\n\t\t\t\t\t\t\t\t      ep->xid);\n\n\t\t\t\t \n\t\t\t\tcmd->was_ddp_setup = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}