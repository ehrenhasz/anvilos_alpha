{
  "module_name": "tfc_conf.c",
  "hash_id": "76fa39f584856b52e30167b1dfe6e5e24f7f6294d795302aebb9af08a071039e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/tcm_fc/tfc_conf.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <generated/utsrelease.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/configfs.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n#include <scsi/libfc.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include \"tcm_fc.h\"\n\nstatic LIST_HEAD(ft_wwn_list);\nDEFINE_MUTEX(ft_lport_lock);\n\nunsigned int ft_debug_logging;\nmodule_param_named(debug_logging, ft_debug_logging, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(debug_logging, \"a bit mask of logging levels\");\n\n \nstatic ssize_t ft_parse_wwn(const char *name, u64 *wwn, int strict)\n{\n\tconst char *cp;\n\tchar c;\n\tu32 byte = 0;\n\tu32 pos = 0;\n\tu32 err;\n\tint val;\n\n\t*wwn = 0;\n\tfor (cp = name; cp < &name[FT_NAMELEN - 1]; cp++) {\n\t\tc = *cp;\n\t\tif (c == '\\n' && cp[1] == '\\0')\n\t\t\tcontinue;\n\t\tif (strict && pos++ == 2 && byte++ < 7) {\n\t\t\tpos = 0;\n\t\t\tif (c == ':')\n\t\t\t\tcontinue;\n\t\t\terr = 1;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (c == '\\0') {\n\t\t\terr = 2;\n\t\t\tif (strict && byte != 8)\n\t\t\t\tgoto fail;\n\t\t\treturn cp - name;\n\t\t}\n\t\terr = 3;\n\t\tval = hex_to_bin(c);\n\t\tif (val < 0 || (strict && isupper(c)))\n\t\t\tgoto fail;\n\t\t*wwn = (*wwn << 4) | val;\n\t}\n\terr = 4;\nfail:\n\tpr_debug(\"err %u len %zu pos %u byte %u\\n\",\n\t\t    err, cp - name, pos, byte);\n\treturn -1;\n}\n\nssize_t ft_format_wwn(char *buf, size_t len, u64 wwn)\n{\n\tu8 b[8];\n\n\tput_unaligned_be64(wwn, b);\n\treturn snprintf(buf, len,\n\t\t \"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\",\n\t\t b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\n}\n\nstatic ssize_t ft_wwn_show(void *arg, char *buf)\n{\n\tu64 *wwn = arg;\n\tssize_t len;\n\n\tlen = ft_format_wwn(buf, PAGE_SIZE - 2, *wwn);\n\tbuf[len++] = '\\n';\n\treturn len;\n}\n\nstatic ssize_t ft_wwn_store(void *arg, const char *buf, size_t len)\n{\n\tssize_t ret;\n\tu64 wwn;\n\n\tret = ft_parse_wwn(buf, &wwn, 0);\n\tif (ret > 0)\n\t\t*(u64 *)arg = wwn;\n\treturn ret;\n}\n\n \n\nstatic ssize_t ft_nacl_port_name_show(struct config_item *item, char *page)\n{\n\tstruct se_node_acl *se_nacl = acl_to_nacl(item);\n\tstruct ft_node_acl *acl = container_of(se_nacl,\n\t\t\tstruct ft_node_acl, se_node_acl);\n\n\treturn ft_wwn_show(&acl->node_auth.port_name, page);\n}\n\nstatic ssize_t ft_nacl_port_name_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_node_acl *se_nacl = acl_to_nacl(item);\n\tstruct ft_node_acl *acl = container_of(se_nacl,\n\t\t\tstruct ft_node_acl, se_node_acl);\n\n\treturn ft_wwn_store(&acl->node_auth.port_name, page, count);\n}\n\nstatic ssize_t ft_nacl_node_name_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct se_node_acl *se_nacl = acl_to_nacl(item);\n\tstruct ft_node_acl *acl = container_of(se_nacl,\n\t\t\tstruct ft_node_acl, se_node_acl);\n\n\treturn ft_wwn_show(&acl->node_auth.node_name, page);\n}\n\nstatic ssize_t ft_nacl_node_name_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_node_acl *se_nacl = acl_to_nacl(item);\n\tstruct ft_node_acl *acl = container_of(se_nacl,\n\t\t\tstruct ft_node_acl, se_node_acl);\n\n\treturn ft_wwn_store(&acl->node_auth.node_name, page, count);\n}\n\nCONFIGFS_ATTR(ft_nacl_, node_name);\nCONFIGFS_ATTR(ft_nacl_, port_name);\n\nstatic ssize_t ft_nacl_tag_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%s\", acl_to_nacl(item)->acl_tag);\n}\n\nstatic ssize_t ft_nacl_tag_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_node_acl *se_nacl = acl_to_nacl(item);\n\tint ret;\n\n\tret = core_tpg_set_initiator_node_tag(se_nacl->se_tpg, se_nacl, page);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\nCONFIGFS_ATTR(ft_nacl_, tag);\n\nstatic struct configfs_attribute *ft_nacl_base_attrs[] = {\n\t&ft_nacl_attr_port_name,\n\t&ft_nacl_attr_node_name,\n\t&ft_nacl_attr_tag,\n\tNULL,\n};\n\n \n\n \nstatic int ft_init_nodeacl(struct se_node_acl *nacl, const char *name)\n{\n\tstruct ft_node_acl *acl =\n\t\tcontainer_of(nacl, struct ft_node_acl, se_node_acl);\n\tu64 wwpn;\n\n\tif (ft_parse_wwn(name, &wwpn, 1) < 0)\n\t\treturn -EINVAL;\n\n\tacl->node_auth.port_name = wwpn;\n\treturn 0;\n}\n\n \nstatic struct se_portal_group *ft_add_tpg(struct se_wwn *wwn, const char *name)\n{\n\tstruct ft_lport_wwn *ft_wwn;\n\tstruct ft_tpg *tpg;\n\tstruct workqueue_struct *wq;\n\tunsigned long index;\n\tint ret;\n\n\tpr_debug(\"tcm_fc: add tpg %s\\n\", name);\n\n\t \n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn NULL;\n\n\tret = kstrtoul(name + 5, 10, &index);\n\tif (ret)\n\t\treturn NULL;\n\tif (index > UINT_MAX)\n\t\treturn NULL;\n\n\tif ((index != 1)) {\n\t\tpr_err(\"Error, a single TPG=1 is used for HW port mappings\\n\");\n\t\treturn ERR_PTR(-ENOSYS);\n\t}\n\n\tft_wwn = container_of(wwn, struct ft_lport_wwn, se_wwn);\n\ttpg = kzalloc(sizeof(*tpg), GFP_KERNEL);\n\tif (!tpg)\n\t\treturn NULL;\n\ttpg->index = index;\n\ttpg->lport_wwn = ft_wwn;\n\tINIT_LIST_HEAD(&tpg->lun_list);\n\n\twq = alloc_workqueue(\"tcm_fc\", 0, 1);\n\tif (!wq) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\n\tret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);\n\tif (ret < 0) {\n\t\tdestroy_workqueue(wq);\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\ttpg->workqueue = wq;\n\n\tmutex_lock(&ft_lport_lock);\n\tft_wwn->tpg = tpg;\n\tmutex_unlock(&ft_lport_lock);\n\n\treturn &tpg->se_tpg;\n}\n\nstatic void ft_del_tpg(struct se_portal_group *se_tpg)\n{\n\tstruct ft_tpg *tpg = container_of(se_tpg, struct ft_tpg, se_tpg);\n\tstruct ft_lport_wwn *ft_wwn = tpg->lport_wwn;\n\n\tpr_debug(\"del tpg %s\\n\",\n\t\t    config_item_name(&tpg->se_tpg.tpg_group.cg_item));\n\n\tdestroy_workqueue(tpg->workqueue);\n\n\t \n\tsynchronize_rcu();\n\n\tmutex_lock(&ft_lport_lock);\n\tft_wwn->tpg = NULL;\n\tif (tpg->tport) {\n\t\ttpg->tport->tpg = NULL;\n\t\ttpg->tport = NULL;\n\t}\n\tmutex_unlock(&ft_lport_lock);\n\n\tcore_tpg_deregister(se_tpg);\n\tkfree(tpg);\n}\n\n \nstruct ft_tpg *ft_lport_find_tpg(struct fc_lport *lport)\n{\n\tstruct ft_lport_wwn *ft_wwn;\n\n\tlist_for_each_entry(ft_wwn, &ft_wwn_list, ft_wwn_node) {\n\t\tif (ft_wwn->wwpn == lport->wwpn)\n\t\t\treturn ft_wwn->tpg;\n\t}\n\treturn NULL;\n}\n\n \n\n \nstatic struct se_wwn *ft_add_wwn(\n\tstruct target_fabric_configfs *tf,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct ft_lport_wwn *ft_wwn;\n\tstruct ft_lport_wwn *old_ft_wwn;\n\tu64 wwpn;\n\n\tpr_debug(\"add wwn %s\\n\", name);\n\tif (ft_parse_wwn(name, &wwpn, 1) < 0)\n\t\treturn NULL;\n\tft_wwn = kzalloc(sizeof(*ft_wwn), GFP_KERNEL);\n\tif (!ft_wwn)\n\t\treturn NULL;\n\tft_wwn->wwpn = wwpn;\n\n\tmutex_lock(&ft_lport_lock);\n\tlist_for_each_entry(old_ft_wwn, &ft_wwn_list, ft_wwn_node) {\n\t\tif (old_ft_wwn->wwpn == wwpn) {\n\t\t\tmutex_unlock(&ft_lport_lock);\n\t\t\tkfree(ft_wwn);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tlist_add_tail(&ft_wwn->ft_wwn_node, &ft_wwn_list);\n\tft_format_wwn(ft_wwn->name, sizeof(ft_wwn->name), wwpn);\n\tmutex_unlock(&ft_lport_lock);\n\n\treturn &ft_wwn->se_wwn;\n}\n\nstatic void ft_del_wwn(struct se_wwn *wwn)\n{\n\tstruct ft_lport_wwn *ft_wwn = container_of(wwn,\n\t\t\t\tstruct ft_lport_wwn, se_wwn);\n\n\tpr_debug(\"del wwn %s\\n\", ft_wwn->name);\n\tmutex_lock(&ft_lport_lock);\n\tlist_del(&ft_wwn->ft_wwn_node);\n\tmutex_unlock(&ft_lport_lock);\n\n\tkfree(ft_wwn);\n}\n\nstatic ssize_t ft_wwn_version_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"TCM FC \" FT_VERSION \" on %s/%s on \"\n\t\t\"\"UTS_RELEASE\"\\n\",  utsname()->sysname, utsname()->machine);\n}\n\nCONFIGFS_ATTR_RO(ft_wwn_, version);\n\nstatic struct configfs_attribute *ft_wwn_attrs[] = {\n\t&ft_wwn_attr_version,\n\tNULL,\n};\n\nstatic inline struct ft_tpg *ft_tpg(struct se_portal_group *se_tpg)\n{\n\treturn container_of(se_tpg, struct ft_tpg, se_tpg);\n}\n\nstatic char *ft_get_fabric_wwn(struct se_portal_group *se_tpg)\n{\n\treturn ft_tpg(se_tpg)->lport_wwn->name;\n}\n\nstatic u16 ft_get_tag(struct se_portal_group *se_tpg)\n{\n\t \n\treturn ft_tpg(se_tpg)->index;\n}\n\nstatic u32 ft_tpg_get_inst_index(struct se_portal_group *se_tpg)\n{\n\treturn ft_tpg(se_tpg)->index;\n}\n\nstatic const struct target_core_fabric_ops ft_fabric_ops = {\n\t.module =\t\t\tTHIS_MODULE,\n\t.fabric_name =\t\t\t\"fc\",\n\t.node_acl_size =\t\tsizeof(struct ft_node_acl),\n\t.tpg_get_wwn =\t\t\tft_get_fabric_wwn,\n\t.tpg_get_tag =\t\t\tft_get_tag,\n\t.tpg_get_inst_index =\t\tft_tpg_get_inst_index,\n\t.check_stop_free =\t\tft_check_stop_free,\n\t.release_cmd =\t\t\tft_release_cmd,\n\t.close_session =\t\tft_sess_close,\n\t.sess_get_index =\t\tft_sess_get_index,\n\t.sess_get_initiator_sid =\tNULL,\n\t.write_pending =\t\tft_write_pending,\n\t.queue_data_in =\t\tft_queue_data_in,\n\t.queue_status =\t\t\tft_queue_status,\n\t.queue_tm_rsp =\t\t\tft_queue_tm_resp,\n\t.aborted_task =\t\t\tft_aborted_task,\n\t \n\t.fabric_make_wwn =\t\t&ft_add_wwn,\n\t.fabric_drop_wwn =\t\t&ft_del_wwn,\n\t.fabric_make_tpg =\t\t&ft_add_tpg,\n\t.fabric_drop_tpg =\t\t&ft_del_tpg,\n\t.fabric_init_nodeacl =\t\t&ft_init_nodeacl,\n\n\t.tfc_wwn_attrs\t\t\t= ft_wwn_attrs,\n\t.tfc_tpg_nacl_base_attrs\t= ft_nacl_base_attrs,\n};\n\nstatic struct notifier_block ft_notifier = {\n\t.notifier_call = ft_lport_notify\n};\n\nstatic int __init ft_init(void)\n{\n\tint ret;\n\n\tret = target_register_template(&ft_fabric_ops);\n\tif (ret)\n\t\tgoto out;\n\n\tret = fc_fc4_register_provider(FC_TYPE_FCP, &ft_prov);\n\tif (ret)\n\t\tgoto out_unregister_template;\n\n\tblocking_notifier_chain_register(&fc_lport_notifier_head, &ft_notifier);\n\tfc_lport_iterate(ft_lport_add, NULL);\n\treturn 0;\n\nout_unregister_template:\n\ttarget_unregister_template(&ft_fabric_ops);\nout:\n\treturn ret;\n}\n\nstatic void __exit ft_exit(void)\n{\n\tblocking_notifier_chain_unregister(&fc_lport_notifier_head,\n\t\t\t\t\t   &ft_notifier);\n\tfc_fc4_deregister_provider(FC_TYPE_FCP, &ft_prov);\n\tfc_lport_iterate(ft_lport_del, NULL);\n\ttarget_unregister_template(&ft_fabric_ops);\n\tsynchronize_rcu();\n}\n\nMODULE_DESCRIPTION(\"FC TCM fabric driver \" FT_VERSION);\nMODULE_LICENSE(\"GPL\");\nmodule_init(ft_init);\nmodule_exit(ft_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}