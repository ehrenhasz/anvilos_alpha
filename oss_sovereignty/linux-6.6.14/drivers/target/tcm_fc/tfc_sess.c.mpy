{
  "module_name": "tfc_sess.c",
  "hash_id": "471bd240a95db78724cb11e1e159b65b15c0852de8e690d780d8962117e5b140",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/tcm_fc/tfc_sess.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/configfs.h>\n#include <linux/ctype.h>\n#include <linux/hash.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/kref.h>\n#include <asm/unaligned.h>\n#include <scsi/libfc.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include \"tcm_fc.h\"\n\n#define TFC_SESS_DBG(lport, fmt, args...) \\\n\tpr_debug(\"host%u: rport %6.6x: \" fmt,\t   \\\n\t\t (lport)->host->host_no,\t   \\\n\t\t (lport)->port_id, ##args )\n\nstatic void ft_sess_delete_all(struct ft_tport *);\n\n \nstatic struct ft_tport *ft_tport_get(struct fc_lport *lport)\n{\n\tstruct ft_tpg *tpg;\n\tstruct ft_tport *tport;\n\tint i;\n\n\ttport = rcu_dereference_protected(lport->prov[FC_TYPE_FCP],\n\t\t\t\t\t  lockdep_is_held(&ft_lport_lock));\n\tif (tport && tport->tpg)\n\t\treturn tport;\n\n\ttpg = ft_lport_find_tpg(lport);\n\tif (!tpg)\n\t\treturn NULL;\n\n\tif (tport) {\n\t\ttport->tpg = tpg;\n\t\ttpg->tport = tport;\n\t\treturn tport;\n\t}\n\n\ttport = kzalloc(sizeof(*tport), GFP_KERNEL);\n\tif (!tport)\n\t\treturn NULL;\n\n\ttport->lport = lport;\n\ttport->tpg = tpg;\n\ttpg->tport = tport;\n\tfor (i = 0; i < FT_SESS_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&tport->hash[i]);\n\n\trcu_assign_pointer(lport->prov[FC_TYPE_FCP], tport);\n\treturn tport;\n}\n\n \nstatic void ft_tport_delete(struct ft_tport *tport)\n{\n\tstruct fc_lport *lport;\n\tstruct ft_tpg *tpg;\n\n\tft_sess_delete_all(tport);\n\tlport = tport->lport;\n\tlport->service_params &= ~FCP_SPPF_TARG_FCN;\n\tBUG_ON(tport != lport->prov[FC_TYPE_FCP]);\n\tRCU_INIT_POINTER(lport->prov[FC_TYPE_FCP], NULL);\n\n\ttpg = tport->tpg;\n\tif (tpg) {\n\t\ttpg->tport = NULL;\n\t\ttport->tpg = NULL;\n\t}\n\tkfree_rcu(tport, rcu);\n}\n\n \nvoid ft_lport_add(struct fc_lport *lport, void *arg)\n{\n\tmutex_lock(&ft_lport_lock);\n\tft_tport_get(lport);\n\tlport->service_params |= FCP_SPPF_TARG_FCN;\n\tmutex_unlock(&ft_lport_lock);\n}\n\n \nvoid ft_lport_del(struct fc_lport *lport, void *arg)\n{\n\tstruct ft_tport *tport;\n\n\tmutex_lock(&ft_lport_lock);\n\ttport = lport->prov[FC_TYPE_FCP];\n\tif (tport)\n\t\tft_tport_delete(tport);\n\tmutex_unlock(&ft_lport_lock);\n}\n\n \nint ft_lport_notify(struct notifier_block *nb, unsigned long event, void *arg)\n{\n\tstruct fc_lport *lport = arg;\n\n\tswitch (event) {\n\tcase FC_LPORT_EV_ADD:\n\t\tft_lport_add(lport, NULL);\n\t\tbreak;\n\tcase FC_LPORT_EV_DEL:\n\t\tft_lport_del(lport, NULL);\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\n \nstatic u32 ft_sess_hash(u32 port_id)\n{\n\treturn hash_32(port_id, FT_SESS_HASH_BITS);\n}\n\n \nstatic struct ft_sess *ft_sess_get(struct fc_lport *lport, u32 port_id)\n{\n\tstruct ft_tport *tport;\n\tstruct hlist_head *head;\n\tstruct ft_sess *sess;\n\tchar *reason = \"no session created\";\n\n\trcu_read_lock();\n\ttport = rcu_dereference(lport->prov[FC_TYPE_FCP]);\n\tif (!tport) {\n\t\treason = \"not an FCP port\";\n\t\tgoto out;\n\t}\n\n\thead = &tport->hash[ft_sess_hash(port_id)];\n\thlist_for_each_entry_rcu(sess, head, hash) {\n\t\tif (sess->port_id == port_id) {\n\t\t\tkref_get(&sess->kref);\n\t\t\trcu_read_unlock();\n\t\t\tTFC_SESS_DBG(lport, \"port_id %x found %p\\n\",\n\t\t\t\t     port_id, sess);\n\t\t\treturn sess;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\tTFC_SESS_DBG(lport, \"port_id %x not found, %s\\n\",\n\t\t     port_id, reason);\n\treturn NULL;\n}\n\nstatic int ft_sess_alloc_cb(struct se_portal_group *se_tpg,\n\t\t\t    struct se_session *se_sess, void *p)\n{\n\tstruct ft_sess *sess = p;\n\tstruct ft_tport *tport = sess->tport;\n\tstruct hlist_head *head = &tport->hash[ft_sess_hash(sess->port_id)];\n\n\tTFC_SESS_DBG(tport->lport, \"port_id %x sess %p\\n\", sess->port_id, sess);\n\thlist_add_head_rcu(&sess->hash, head);\n\ttport->sess_count++;\n\n\treturn 0;\n}\n\n \nstatic struct ft_sess *ft_sess_create(struct ft_tport *tport, u32 port_id,\n\t\t\t\t      struct fc_rport_priv *rdata)\n{\n\tstruct se_portal_group *se_tpg = &tport->tpg->se_tpg;\n\tstruct ft_sess *sess;\n\tstruct hlist_head *head;\n\tunsigned char initiatorname[TRANSPORT_IQN_LEN];\n\n\tft_format_wwn(&initiatorname[0], TRANSPORT_IQN_LEN, rdata->ids.port_name);\n\n\thead = &tport->hash[ft_sess_hash(port_id)];\n\thlist_for_each_entry_rcu(sess, head, hash)\n\t\tif (sess->port_id == port_id)\n\t\t\treturn sess;\n\n\tsess = kzalloc(sizeof(*sess), GFP_KERNEL);\n\tif (!sess)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkref_init(&sess->kref);  \n\tsess->tport = tport;\n\tsess->port_id = port_id;\n\n\tsess->se_sess = target_setup_session(se_tpg, TCM_FC_DEFAULT_TAGS,\n\t\t\t\t\t     sizeof(struct ft_cmd),\n\t\t\t\t\t     TARGET_PROT_NORMAL, &initiatorname[0],\n\t\t\t\t\t     sess, ft_sess_alloc_cb);\n\tif (IS_ERR(sess->se_sess)) {\n\t\tint rc = PTR_ERR(sess->se_sess);\n\t\tkfree(sess);\n\t\tsess = ERR_PTR(rc);\n\t}\n\treturn sess;\n}\n\n \nstatic void ft_sess_unhash(struct ft_sess *sess)\n{\n\tstruct ft_tport *tport = sess->tport;\n\n\thlist_del_rcu(&sess->hash);\n\tBUG_ON(!tport->sess_count);\n\ttport->sess_count--;\n\tsess->port_id = -1;\n\tsess->params = 0;\n}\n\n \nstatic struct ft_sess *ft_sess_delete(struct ft_tport *tport, u32 port_id)\n{\n\tstruct hlist_head *head;\n\tstruct ft_sess *sess;\n\n\thead = &tport->hash[ft_sess_hash(port_id)];\n\thlist_for_each_entry_rcu(sess, head, hash) {\n\t\tif (sess->port_id == port_id) {\n\t\t\tft_sess_unhash(sess);\n\t\t\treturn sess;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void ft_close_sess(struct ft_sess *sess)\n{\n\ttarget_stop_session(sess->se_sess);\n\ttarget_wait_for_sess_cmds(sess->se_sess);\n\tft_sess_put(sess);\n}\n\n \nstatic void ft_sess_delete_all(struct ft_tport *tport)\n{\n\tstruct hlist_head *head;\n\tstruct ft_sess *sess;\n\n\tfor (head = tport->hash;\n\t     head < &tport->hash[FT_SESS_HASH_SIZE]; head++) {\n\t\thlist_for_each_entry_rcu(sess, head, hash) {\n\t\t\tft_sess_unhash(sess);\n\t\t\tft_close_sess(sess);\t \n\t\t}\n\t}\n}\n\n \n\n \nvoid ft_sess_close(struct se_session *se_sess)\n{\n\tstruct ft_sess *sess = se_sess->fabric_sess_ptr;\n\tu32 port_id;\n\n\tmutex_lock(&ft_lport_lock);\n\tport_id = sess->port_id;\n\tif (port_id == -1) {\n\t\tmutex_unlock(&ft_lport_lock);\n\t\treturn;\n\t}\n\tTFC_SESS_DBG(sess->tport->lport, \"port_id %x close session\\n\", port_id);\n\tft_sess_unhash(sess);\n\tmutex_unlock(&ft_lport_lock);\n\tft_close_sess(sess);\n\t \n\tsynchronize_rcu();\t\t \n}\n\nu32 ft_sess_get_index(struct se_session *se_sess)\n{\n\tstruct ft_sess *sess = se_sess->fabric_sess_ptr;\n\n\treturn sess->port_id;\t \n}\n\nu32 ft_sess_get_port_name(struct se_session *se_sess,\n\t\t\t  unsigned char *buf, u32 len)\n{\n\tstruct ft_sess *sess = se_sess->fabric_sess_ptr;\n\n\treturn ft_format_wwn(buf, len, sess->port_name);\n}\n\n \n\nstatic int ft_prli_locked(struct fc_rport_priv *rdata, u32 spp_len,\n\t\t\t  const struct fc_els_spp *rspp, struct fc_els_spp *spp)\n{\n\tstruct ft_tport *tport;\n\tstruct ft_sess *sess;\n\tu32 fcp_parm;\n\n\ttport = ft_tport_get(rdata->local_port);\n\tif (!tport)\n\t\tgoto not_target;\t \n\n\tif (!rspp)\n\t\tgoto fill;\n\n\tif (rspp->spp_flags & (FC_SPP_OPA_VAL | FC_SPP_RPA_VAL))\n\t\treturn FC_SPP_RESP_NO_PA;\n\n\t \n\tfcp_parm = ntohl(rspp->spp_params);\n\tif (!(fcp_parm & (FCP_SPPF_INIT_FCN | FCP_SPPF_TARG_FCN)))\n\t\treturn FC_SPP_RESP_INVL;\n\n\t \n\tif (rspp->spp_flags & FC_SPP_EST_IMG_PAIR) {\n\t\tspp->spp_flags |= FC_SPP_EST_IMG_PAIR;\n\t\tif (!(fcp_parm & FCP_SPPF_INIT_FCN))\n\t\t\treturn FC_SPP_RESP_CONF;\n\t\tsess = ft_sess_create(tport, rdata->ids.port_id, rdata);\n\t\tif (IS_ERR(sess)) {\n\t\t\tif (PTR_ERR(sess) == -EACCES) {\n\t\t\t\tspp->spp_flags &= ~FC_SPP_EST_IMG_PAIR;\n\t\t\t\treturn FC_SPP_RESP_CONF;\n\t\t\t} else\n\t\t\t\treturn FC_SPP_RESP_RES;\n\t\t}\n\t\tif (!sess->params)\n\t\t\trdata->prli_count++;\n\t\tsess->params = fcp_parm;\n\t\tsess->port_name = rdata->ids.port_name;\n\t\tsess->max_frame = rdata->maxframe_size;\n\n\t\t \n\t}\n\n\t \nfill:\n\tfcp_parm = ntohl(spp->spp_params);\n\tfcp_parm &= ~FCP_SPPF_RETRY;\n\tspp->spp_params = htonl(fcp_parm | FCP_SPPF_TARG_FCN);\n\treturn FC_SPP_RESP_ACK;\n\nnot_target:\n\tfcp_parm = ntohl(spp->spp_params);\n\tfcp_parm &= ~FCP_SPPF_TARG_FCN;\n\tspp->spp_params = htonl(fcp_parm);\n\treturn 0;\n}\n\n \nstatic int ft_prli(struct fc_rport_priv *rdata, u32 spp_len,\n\t\t   const struct fc_els_spp *rspp, struct fc_els_spp *spp)\n{\n\tint ret;\n\n\tmutex_lock(&ft_lport_lock);\n\tret = ft_prli_locked(rdata, spp_len, rspp, spp);\n\tmutex_unlock(&ft_lport_lock);\n\tTFC_SESS_DBG(rdata->local_port, \"port_id %x flags %x ret %x\\n\",\n\t\t     rdata->ids.port_id, rspp ? rspp->spp_flags : 0, ret);\n\treturn ret;\n}\n\nstatic void ft_sess_free(struct kref *kref)\n{\n\tstruct ft_sess *sess = container_of(kref, struct ft_sess, kref);\n\n\ttarget_remove_session(sess->se_sess);\n\tkfree_rcu(sess, rcu);\n}\n\nvoid ft_sess_put(struct ft_sess *sess)\n{\n\tint sess_held = kref_read(&sess->kref);\n\n\tBUG_ON(!sess_held);\n\tkref_put(&sess->kref, ft_sess_free);\n}\n\nstatic void ft_prlo(struct fc_rport_priv *rdata)\n{\n\tstruct ft_sess *sess;\n\tstruct ft_tport *tport;\n\n\tmutex_lock(&ft_lport_lock);\n\ttport = rcu_dereference_protected(rdata->local_port->prov[FC_TYPE_FCP],\n\t\t\t\t\t  lockdep_is_held(&ft_lport_lock));\n\n\tif (!tport) {\n\t\tmutex_unlock(&ft_lport_lock);\n\t\treturn;\n\t}\n\tsess = ft_sess_delete(tport, rdata->ids.port_id);\n\tif (!sess) {\n\t\tmutex_unlock(&ft_lport_lock);\n\t\treturn;\n\t}\n\tmutex_unlock(&ft_lport_lock);\n\tft_close_sess(sess);\t\t \n\trdata->prli_count--;\n\t \n}\n\n \nstatic void ft_recv(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct ft_sess *sess;\n\tu32 sid = fc_frame_sid(fp);\n\n\tTFC_SESS_DBG(lport, \"recv sid %x\\n\", sid);\n\n\tsess = ft_sess_get(lport, sid);\n\tif (!sess) {\n\t\tTFC_SESS_DBG(lport, \"sid %x sess lookup failed\\n\", sid);\n\t\t \n\t\tfc_frame_free(fp);\n\t\treturn;\n\t}\n\tft_recv_req(sess, fp);\t \n}\n\n \nstruct fc4_prov ft_prov = {\n\t.prli = ft_prli,\n\t.prlo = ft_prlo,\n\t.recv = ft_recv,\n\t.module = THIS_MODULE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}