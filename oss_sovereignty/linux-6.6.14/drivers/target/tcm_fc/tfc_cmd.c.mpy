{
  "module_name": "tfc_cmd.c",
  "hash_id": "dbd1e49428a5ec2016456a4cd7aab01b0a7f51ef9152eaffdb44794184b86b80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/tcm_fc/tfc_cmd.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/configfs.h>\n#include <linux/ctype.h>\n#include <linux/hash.h>\n#include <asm/unaligned.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/libfc.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include \"tcm_fc.h\"\n\n \nstatic void _ft_dump_cmd(struct ft_cmd *cmd, const char *caller)\n{\n\tstruct fc_exch *ep;\n\tstruct fc_seq *sp;\n\tstruct se_cmd *se_cmd;\n\tstruct scatterlist *sg;\n\tint count;\n\n\tse_cmd = &cmd->se_cmd;\n\tpr_debug(\"%s: cmd %p sess %p seq %p se_cmd %p\\n\",\n\t\tcaller, cmd, cmd->sess, cmd->seq, se_cmd);\n\n\tpr_debug(\"%s: cmd %p data_nents %u len %u se_cmd_flags <0x%x>\\n\",\n\t\tcaller, cmd, se_cmd->t_data_nents,\n\t       se_cmd->data_length, se_cmd->se_cmd_flags);\n\n\tfor_each_sg(se_cmd->t_data_sg, sg, se_cmd->t_data_nents, count)\n\t\tpr_debug(\"%s: cmd %p sg %p page %p \"\n\t\t\t\"len 0x%x off 0x%x\\n\",\n\t\t\tcaller, cmd, sg,\n\t\t\tsg_page(sg), sg->length, sg->offset);\n\n\tsp = cmd->seq;\n\tif (sp) {\n\t\tep = fc_seq_exch(sp);\n\t\tpr_debug(\"%s: cmd %p sid %x did %x \"\n\t\t\t\"ox_id %x rx_id %x seq_id %x e_stat %x\\n\",\n\t\t\tcaller, cmd, ep->sid, ep->did, ep->oxid, ep->rxid,\n\t\t\tsp->id, ep->esb_stat);\n\t}\n}\n\nvoid ft_dump_cmd(struct ft_cmd *cmd, const char *caller)\n{\n\tif (unlikely(ft_debug_logging))\n\t\t_ft_dump_cmd(cmd, caller);\n}\n\nstatic void ft_free_cmd(struct ft_cmd *cmd)\n{\n\tstruct fc_frame *fp;\n\tstruct ft_sess *sess;\n\n\tif (!cmd)\n\t\treturn;\n\tsess = cmd->sess;\n\tfp = cmd->req_frame;\n\tif (fr_seq(fp))\n\t\tfc_seq_release(fr_seq(fp));\n\tfc_frame_free(fp);\n\ttarget_free_tag(sess->se_sess, &cmd->se_cmd);\n\tft_sess_put(sess);\t \n}\n\nvoid ft_release_cmd(struct se_cmd *se_cmd)\n{\n\tstruct ft_cmd *cmd = container_of(se_cmd, struct ft_cmd, se_cmd);\n\n\tft_free_cmd(cmd);\n}\n\nint ft_check_stop_free(struct se_cmd *se_cmd)\n{\n\treturn transport_generic_free_cmd(se_cmd, 0);\n}\n\n \nint ft_queue_status(struct se_cmd *se_cmd)\n{\n\tstruct ft_cmd *cmd = container_of(se_cmd, struct ft_cmd, se_cmd);\n\tstruct fc_frame *fp;\n\tstruct fcp_resp_with_ext *fcp;\n\tstruct fc_lport *lport;\n\tstruct fc_exch *ep;\n\tsize_t len;\n\tint rc;\n\n\tif (cmd->aborted)\n\t\treturn 0;\n\tft_dump_cmd(cmd, __func__);\n\tep = fc_seq_exch(cmd->seq);\n\tlport = ep->lp;\n\tlen = sizeof(*fcp) + se_cmd->scsi_sense_length;\n\tfp = fc_frame_alloc(lport, len);\n\tif (!fp) {\n\t\tse_cmd->scsi_status = SAM_STAT_TASK_SET_FULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tfcp = fc_frame_payload_get(fp, len);\n\tmemset(fcp, 0, len);\n\tfcp->resp.fr_status = se_cmd->scsi_status;\n\n\tlen = se_cmd->scsi_sense_length;\n\tif (len) {\n\t\tfcp->resp.fr_flags |= FCP_SNS_LEN_VAL;\n\t\tfcp->ext.fr_sns_len = htonl(len);\n\t\tmemcpy((fcp + 1), se_cmd->sense_buffer, len);\n\t}\n\n\t \n\tif (se_cmd->se_cmd_flags & (SCF_OVERFLOW_BIT | SCF_UNDERFLOW_BIT)) {\n\t\tif (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT)\n\t\t\tfcp->resp.fr_flags |= FCP_RESID_OVER;\n\t\telse\n\t\t\tfcp->resp.fr_flags |= FCP_RESID_UNDER;\n\t\tfcp->ext.fr_resid = cpu_to_be32(se_cmd->residual_count);\n\t}\n\n\t \n\tcmd->seq = fc_seq_start_next(cmd->seq);\n\tfc_fill_fc_hdr(fp, FC_RCTL_DD_CMD_STATUS, ep->did, ep->sid, FC_TYPE_FCP,\n\t\t       FC_FC_EX_CTX | FC_FC_LAST_SEQ | FC_FC_END_SEQ, 0);\n\n\trc = fc_seq_send(lport, cmd->seq, fp);\n\tif (rc) {\n\t\tpr_info_ratelimited(\"%s: Failed to send response frame %p, \"\n\t\t\t\t    \"xid <0x%x>\\n\", __func__, fp, ep->xid);\n\t\t \n\t\tse_cmd->scsi_status = SAM_STAT_TASK_SET_FULL;\n\t\treturn -ENOMEM;\n\t}\n\tfc_exch_done(cmd->seq);\n\t \n\ttarget_put_sess_cmd(&cmd->se_cmd);\n\treturn 0;\n}\n\n \nint ft_write_pending(struct se_cmd *se_cmd)\n{\n\tstruct ft_cmd *cmd = container_of(se_cmd, struct ft_cmd, se_cmd);\n\tstruct fc_frame *fp;\n\tstruct fcp_txrdy *txrdy;\n\tstruct fc_lport *lport;\n\tstruct fc_exch *ep;\n\tstruct fc_frame_header *fh;\n\tu32 f_ctl;\n\n\tft_dump_cmd(cmd, __func__);\n\n\tif (cmd->aborted)\n\t\treturn 0;\n\tep = fc_seq_exch(cmd->seq);\n\tlport = ep->lp;\n\tfp = fc_frame_alloc(lport, sizeof(*txrdy));\n\tif (!fp)\n\t\treturn -ENOMEM;  \n\n\ttxrdy = fc_frame_payload_get(fp, sizeof(*txrdy));\n\tmemset(txrdy, 0, sizeof(*txrdy));\n\ttxrdy->ft_burst_len = htonl(se_cmd->data_length);\n\n\tcmd->seq = fc_seq_start_next(cmd->seq);\n\tfc_fill_fc_hdr(fp, FC_RCTL_DD_DATA_DESC, ep->did, ep->sid, FC_TYPE_FCP,\n\t\t       FC_FC_EX_CTX | FC_FC_END_SEQ | FC_FC_SEQ_INIT, 0);\n\n\tfh = fc_frame_header_get(fp);\n\tf_ctl = ntoh24(fh->fh_f_ctl);\n\n\t \n\tif (f_ctl & FC_FC_EX_CTX) {\n\t\t \n\t\tif ((ep->xid <= lport->lro_xid) &&\n\t\t    (fh->fh_r_ctl == FC_RCTL_DD_DATA_DESC)) {\n\t\t\tif ((se_cmd->se_cmd_flags & SCF_SCSI_DATA_CDB) &&\n\t\t\t    lport->tt.ddp_target(lport, ep->xid,\n\t\t\t\t\t\t se_cmd->t_data_sg,\n\t\t\t\t\t\t se_cmd->t_data_nents))\n\t\t\t\tcmd->was_ddp_setup = 1;\n\t\t}\n\t}\n\tfc_seq_send(lport, cmd->seq, fp);\n\treturn 0;\n}\n\n \nstatic void ft_recv_seq(struct fc_seq *sp, struct fc_frame *fp, void *arg)\n{\n\tstruct ft_cmd *cmd = arg;\n\tstruct fc_frame_header *fh;\n\n\tif (IS_ERR(fp)) {\n\t\t \n\t\tcmd->seq = NULL;\n\t\tcmd->aborted = true;\n\t\treturn;\n\t}\n\n\tfh = fc_frame_header_get(fp);\n\n\tswitch (fh->fh_r_ctl) {\n\tcase FC_RCTL_DD_SOL_DATA:\t \n\t\tft_recv_write_data(cmd, fp);\n\t\tbreak;\n\tcase FC_RCTL_DD_UNSOL_CTL:\t \n\tcase FC_RCTL_DD_SOL_CTL:\t \n\tcase FC_RCTL_DD_DATA_DESC:\t \n\tdefault:\n\t\tpr_debug(\"%s: unhandled frame r_ctl %x\\n\",\n\t\t       __func__, fh->fh_r_ctl);\n\t\tft_invl_hw_context(cmd);\n\t\tfc_frame_free(fp);\n\t\ttransport_generic_free_cmd(&cmd->se_cmd, 0);\n\t\tbreak;\n\t}\n}\n\n \nstatic void ft_send_resp_status(struct fc_lport *lport,\n\t\t\t\tconst struct fc_frame *rx_fp,\n\t\t\t\tu32 status, enum fcp_resp_rsp_codes code)\n{\n\tstruct fc_frame *fp;\n\tstruct fc_seq *sp;\n\tconst struct fc_frame_header *fh;\n\tsize_t len;\n\tstruct fcp_resp_with_ext *fcp;\n\tstruct fcp_resp_rsp_info *info;\n\n\tfh = fc_frame_header_get(rx_fp);\n\tpr_debug(\"FCP error response: did %x oxid %x status %x code %x\\n\",\n\t\t  ntoh24(fh->fh_s_id), ntohs(fh->fh_ox_id), status, code);\n\tlen = sizeof(*fcp);\n\tif (status == SAM_STAT_GOOD)\n\t\tlen += sizeof(*info);\n\tfp = fc_frame_alloc(lport, len);\n\tif (!fp)\n\t\treturn;\n\tfcp = fc_frame_payload_get(fp, len);\n\tmemset(fcp, 0, len);\n\tfcp->resp.fr_status = status;\n\tif (status == SAM_STAT_GOOD) {\n\t\tfcp->ext.fr_rsp_len = htonl(sizeof(*info));\n\t\tfcp->resp.fr_flags |= FCP_RSP_LEN_VAL;\n\t\tinfo = (struct fcp_resp_rsp_info *)(fcp + 1);\n\t\tinfo->rsp_code = code;\n\t}\n\n\tfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_DD_CMD_STATUS, 0);\n\tsp = fr_seq(fp);\n\tif (sp) {\n\t\tfc_seq_send(lport, sp, fp);\n\t\tfc_exch_done(sp);\n\t} else {\n\t\tlport->tt.frame_send(lport, fp);\n\t}\n}\n\n \nstatic void ft_send_resp_code(struct ft_cmd *cmd,\n\t\t\t      enum fcp_resp_rsp_codes code)\n{\n\tft_send_resp_status(cmd->sess->tport->lport,\n\t\t\t    cmd->req_frame, SAM_STAT_GOOD, code);\n}\n\n\n \nstatic void ft_send_resp_code_and_free(struct ft_cmd *cmd,\n\t\t\t\t      enum fcp_resp_rsp_codes code)\n{\n\tft_send_resp_code(cmd, code);\n\tft_free_cmd(cmd);\n}\n\n \nstatic void ft_send_tm(struct ft_cmd *cmd)\n{\n\tstruct fcp_cmnd *fcp;\n\tint rc;\n\tu8 tm_func;\n\n\tfcp = fc_frame_payload_get(cmd->req_frame, sizeof(*fcp));\n\n\tswitch (fcp->fc_tm_flags) {\n\tcase FCP_TMF_LUN_RESET:\n\t\ttm_func = TMR_LUN_RESET;\n\t\tbreak;\n\tcase FCP_TMF_TGT_RESET:\n\t\ttm_func = TMR_TARGET_WARM_RESET;\n\t\tbreak;\n\tcase FCP_TMF_CLR_TASK_SET:\n\t\ttm_func = TMR_CLEAR_TASK_SET;\n\t\tbreak;\n\tcase FCP_TMF_ABT_TASK_SET:\n\t\ttm_func = TMR_ABORT_TASK_SET;\n\t\tbreak;\n\tcase FCP_TMF_CLR_ACA:\n\t\ttm_func = TMR_CLEAR_ACA;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tpr_debug(\"invalid FCP tm_flags %x\\n\", fcp->fc_tm_flags);\n\t\tft_send_resp_code_and_free(cmd, FCP_CMND_FIELDS_INVALID);\n\t\treturn;\n\t}\n\n\t \n\trc = target_submit_tmr(&cmd->se_cmd, cmd->sess->se_sess,\n\t\t&cmd->ft_sense_buffer[0], scsilun_to_int(&fcp->fc_lun),\n\t\tcmd, tm_func, GFP_KERNEL, 0, TARGET_SCF_ACK_KREF);\n\tif (rc < 0)\n\t\tft_send_resp_code_and_free(cmd, FCP_TMF_FAILED);\n}\n\n \nvoid ft_queue_tm_resp(struct se_cmd *se_cmd)\n{\n\tstruct ft_cmd *cmd = container_of(se_cmd, struct ft_cmd, se_cmd);\n\tstruct se_tmr_req *tmr = se_cmd->se_tmr_req;\n\tenum fcp_resp_rsp_codes code;\n\n\tif (cmd->aborted)\n\t\treturn;\n\tswitch (tmr->response) {\n\tcase TMR_FUNCTION_COMPLETE:\n\t\tcode = FCP_TMF_CMPL;\n\t\tbreak;\n\tcase TMR_LUN_DOES_NOT_EXIST:\n\t\tcode = FCP_TMF_INVALID_LUN;\n\t\tbreak;\n\tcase TMR_FUNCTION_REJECTED:\n\t\tcode = FCP_TMF_REJECTED;\n\t\tbreak;\n\tcase TMR_TASK_DOES_NOT_EXIST:\n\tcase TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED:\n\tdefault:\n\t\tcode = FCP_TMF_FAILED;\n\t\tbreak;\n\t}\n\tpr_debug(\"tmr fn %d resp %d fcp code %d\\n\",\n\t\t  tmr->function, tmr->response, code);\n\tft_send_resp_code(cmd, code);\n\t \n\ttarget_put_sess_cmd(&cmd->se_cmd);\n}\n\nvoid ft_aborted_task(struct se_cmd *se_cmd)\n{\n\treturn;\n}\n\nstatic void ft_send_work(struct work_struct *work);\n\n \nstatic void ft_recv_cmd(struct ft_sess *sess, struct fc_frame *fp)\n{\n\tstruct ft_cmd *cmd;\n\tstruct fc_lport *lport = sess->tport->lport;\n\tstruct se_session *se_sess = sess->se_sess;\n\tint tag, cpu;\n\n\ttag = sbitmap_queue_get(&se_sess->sess_tag_pool, &cpu);\n\tif (tag < 0)\n\t\tgoto busy;\n\n\tcmd = &((struct ft_cmd *)se_sess->sess_cmd_map)[tag];\n\tmemset(cmd, 0, sizeof(struct ft_cmd));\n\n\tcmd->se_cmd.map_tag = tag;\n\tcmd->se_cmd.map_cpu = cpu;\n\tcmd->sess = sess;\n\tcmd->seq = fc_seq_assign(lport, fp);\n\tif (!cmd->seq) {\n\t\ttarget_free_tag(se_sess, &cmd->se_cmd);\n\t\tgoto busy;\n\t}\n\tcmd->req_frame = fp;\t\t \n\n\tINIT_WORK(&cmd->work, ft_send_work);\n\tqueue_work(sess->tport->tpg->workqueue, &cmd->work);\n\treturn;\n\nbusy:\n\tpr_debug(\"cmd or seq allocation failure - sending BUSY\\n\");\n\tft_send_resp_status(lport, fp, SAM_STAT_BUSY, 0);\n\tfc_frame_free(fp);\n\tft_sess_put(sess);\t\t \n}\n\n\n \nvoid ft_recv_req(struct ft_sess *sess, struct fc_frame *fp)\n{\n\tstruct fc_frame_header *fh = fc_frame_header_get(fp);\n\n\tswitch (fh->fh_r_ctl) {\n\tcase FC_RCTL_DD_UNSOL_CMD:\t \n\t\tft_recv_cmd(sess, fp);\n\t\tbreak;\n\tcase FC_RCTL_DD_SOL_DATA:\t \n\tcase FC_RCTL_DD_UNSOL_CTL:\n\tcase FC_RCTL_DD_SOL_CTL:\n\tcase FC_RCTL_DD_DATA_DESC:\t \n\tcase FC_RCTL_ELS4_REQ:\t\t \n\tdefault:\n\t\tpr_debug(\"%s: unhandled frame r_ctl %x\\n\",\n\t\t       __func__, fh->fh_r_ctl);\n\t\tfc_frame_free(fp);\n\t\tft_sess_put(sess);\t \n\t\tbreak;\n\t}\n}\n\n \nstatic void ft_send_work(struct work_struct *work)\n{\n\tstruct ft_cmd *cmd = container_of(work, struct ft_cmd, work);\n\tstruct fc_frame_header *fh = fc_frame_header_get(cmd->req_frame);\n\tstruct fcp_cmnd *fcp;\n\tint data_dir = 0;\n\tint task_attr;\n\n\tfcp = fc_frame_payload_get(cmd->req_frame, sizeof(*fcp));\n\tif (!fcp)\n\t\tgoto err;\n\n\tif (fcp->fc_flags & FCP_CFL_LEN_MASK)\n\t\tgoto err;\t\t \n\n\t \n\tif (fcp->fc_tm_flags) {\n\t\tft_send_tm(cmd);\n\t\treturn;\n\t}\n\n\tswitch (fcp->fc_flags & (FCP_CFL_RDDATA | FCP_CFL_WRDATA)) {\n\tcase 0:\n\t\tdata_dir = DMA_NONE;\n\t\tbreak;\n\tcase FCP_CFL_RDDATA:\n\t\tdata_dir = DMA_FROM_DEVICE;\n\t\tbreak;\n\tcase FCP_CFL_WRDATA:\n\t\tdata_dir = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase FCP_CFL_WRDATA | FCP_CFL_RDDATA:\n\t\tgoto err;\t \n\t}\n\t \n\tswitch (fcp->fc_pri_ta & FCP_PTA_MASK) {\n\tcase FCP_PTA_HEADQ:\n\t\ttask_attr = TCM_HEAD_TAG;\n\t\tbreak;\n\tcase FCP_PTA_ORDERED:\n\t\ttask_attr = TCM_ORDERED_TAG;\n\t\tbreak;\n\tcase FCP_PTA_ACA:\n\t\ttask_attr = TCM_ACA_TAG;\n\t\tbreak;\n\tcase FCP_PTA_SIMPLE:\n\tdefault:\n\t\ttask_attr = TCM_SIMPLE_TAG;\n\t}\n\n\tfc_seq_set_resp(cmd->seq, ft_recv_seq, cmd);\n\tcmd->se_cmd.tag = fc_seq_exch(cmd->seq)->rxid;\n\n\t \n\tif (target_init_cmd(&cmd->se_cmd, cmd->sess->se_sess,\n\t\t\t    &cmd->ft_sense_buffer[0],\n\t\t\t    scsilun_to_int(&fcp->fc_lun), ntohl(fcp->fc_dl),\n\t\t\t    task_attr, data_dir, TARGET_SCF_ACK_KREF))\n\t\tgoto err;\n\n\tif (target_submit_prep(&cmd->se_cmd, fcp->fc_cdb, NULL, 0, NULL, 0,\n\t\t\t       NULL, 0, GFP_KERNEL))\n\t\treturn;\n\n\ttarget_submit(&cmd->se_cmd);\n\tpr_debug(\"r_ctl %x target_submit_cmd %p\\n\", fh->fh_r_ctl, cmd);\n\treturn;\n\nerr:\n\tft_send_resp_code_and_free(cmd, FCP_CMND_FIELDS_INVALID);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}