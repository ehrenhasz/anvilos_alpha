{
  "module_name": "iscsi_target_datain_values.c",
  "hash_id": "d2b4dc4360fa3808bc7355436776f7441c98fc082ac404741cf761948d0e2404",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target_datain_values.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <scsi/iscsi_proto.h>\n#include <target/iscsi/iscsi_target_core.h>\n#include \"iscsi_target_seq_pdu_list.h\"\n#include \"iscsi_target_erl1.h\"\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target.h\"\n#include \"iscsi_target_datain_values.h\"\n\nstruct iscsi_datain_req *iscsit_allocate_datain_req(void)\n{\n\tstruct iscsi_datain_req *dr;\n\n\tdr = kmem_cache_zalloc(lio_dr_cache, GFP_ATOMIC);\n\tif (!dr) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\t\" struct iscsi_datain_req\\n\");\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&dr->cmd_datain_node);\n\n\treturn dr;\n}\n\nvoid iscsit_attach_datain_req(struct iscsit_cmd *cmd, struct iscsi_datain_req *dr)\n{\n\tspin_lock(&cmd->datain_lock);\n\tlist_add_tail(&dr->cmd_datain_node, &cmd->datain_list);\n\tspin_unlock(&cmd->datain_lock);\n}\n\nvoid iscsit_free_datain_req(struct iscsit_cmd *cmd, struct iscsi_datain_req *dr)\n{\n\tspin_lock(&cmd->datain_lock);\n\tlist_del(&dr->cmd_datain_node);\n\tspin_unlock(&cmd->datain_lock);\n\n\tkmem_cache_free(lio_dr_cache, dr);\n}\n\nvoid iscsit_free_all_datain_reqs(struct iscsit_cmd *cmd)\n{\n\tstruct iscsi_datain_req *dr, *dr_tmp;\n\n\tspin_lock(&cmd->datain_lock);\n\tlist_for_each_entry_safe(dr, dr_tmp, &cmd->datain_list, cmd_datain_node) {\n\t\tlist_del(&dr->cmd_datain_node);\n\t\tkmem_cache_free(lio_dr_cache, dr);\n\t}\n\tspin_unlock(&cmd->datain_lock);\n}\n\nstruct iscsi_datain_req *iscsit_get_datain_req(struct iscsit_cmd *cmd)\n{\n\tif (list_empty(&cmd->datain_list)) {\n\t\tpr_err(\"cmd->datain_list is empty for ITT:\"\n\t\t\t\" 0x%08x\\n\", cmd->init_task_tag);\n\t\treturn NULL;\n\t}\n\n\treturn list_first_entry(&cmd->datain_list, struct iscsi_datain_req,\n\t\t\t\tcmd_datain_node);\n}\n\n \nstatic struct iscsi_datain_req *iscsit_set_datain_values_yes_and_yes(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsi_datain *datain)\n{\n\tu32 next_burst_len, read_data_done, read_data_left;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_datain_req *dr;\n\n\tdr = iscsit_get_datain_req(cmd);\n\tif (!dr)\n\t\treturn NULL;\n\n\tif (dr->recovery && dr->generate_recovery_values) {\n\t\tif (iscsit_create_recovery_datain_values_datasequenceinorder_yes(\n\t\t\t\t\tcmd, dr) < 0)\n\t\t\treturn NULL;\n\n\t\tdr->generate_recovery_values = 0;\n\t}\n\n\tnext_burst_len = (!dr->recovery) ?\n\t\t\tcmd->next_burst_len : dr->next_burst_len;\n\tread_data_done = (!dr->recovery) ?\n\t\t\tcmd->read_data_done : dr->read_data_done;\n\n\tread_data_left = (cmd->se_cmd.data_length - read_data_done);\n\tif (!read_data_left) {\n\t\tpr_err(\"ITT: 0x%08x read_data_left is zero!\\n\",\n\t\t\t\tcmd->init_task_tag);\n\t\treturn NULL;\n\t}\n\n\tif ((read_data_left <= conn->conn_ops->MaxRecvDataSegmentLength) &&\n\t    (read_data_left <= (conn->sess->sess_ops->MaxBurstLength -\n\t     next_burst_len))) {\n\t\tdatain->length = read_data_left;\n\n\t\tdatain->flags |= (ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS);\n\t\tif (conn->sess->sess_ops->ErrorRecoveryLevel > 0)\n\t\t\tdatain->flags |= ISCSI_FLAG_DATA_ACK;\n\t} else {\n\t\tif ((next_burst_len +\n\t\t     conn->conn_ops->MaxRecvDataSegmentLength) <\n\t\t     conn->sess->sess_ops->MaxBurstLength) {\n\t\t\tdatain->length =\n\t\t\t\tconn->conn_ops->MaxRecvDataSegmentLength;\n\t\t\tnext_burst_len += datain->length;\n\t\t} else {\n\t\t\tdatain->length = (conn->sess->sess_ops->MaxBurstLength -\n\t\t\t\t\t  next_burst_len);\n\t\t\tnext_burst_len = 0;\n\n\t\t\tdatain->flags |= ISCSI_FLAG_CMD_FINAL;\n\t\t\tif (conn->sess->sess_ops->ErrorRecoveryLevel > 0)\n\t\t\t\tdatain->flags |= ISCSI_FLAG_DATA_ACK;\n\t\t}\n\t}\n\n\tdatain->data_sn = (!dr->recovery) ? cmd->data_sn++ : dr->data_sn++;\n\tdatain->offset = read_data_done;\n\n\tif (!dr->recovery) {\n\t\tcmd->next_burst_len = next_burst_len;\n\t\tcmd->read_data_done += datain->length;\n\t} else {\n\t\tdr->next_burst_len = next_burst_len;\n\t\tdr->read_data_done += datain->length;\n\t}\n\n\tif (!dr->recovery) {\n\t\tif (datain->flags & ISCSI_FLAG_DATA_STATUS)\n\t\t\tdr->dr_complete = DATAIN_COMPLETE_NORMAL;\n\n\t\treturn dr;\n\t}\n\n\tif (!dr->runlength) {\n\t\tif (datain->flags & ISCSI_FLAG_DATA_STATUS) {\n\t\t\tdr->dr_complete =\n\t\t\t    (dr->recovery == DATAIN_WITHIN_COMMAND_RECOVERY) ?\n\t\t\t\tDATAIN_COMPLETE_WITHIN_COMMAND_RECOVERY :\n\t\t\t\tDATAIN_COMPLETE_CONNECTION_RECOVERY;\n\t\t}\n\t} else {\n\t\tif ((dr->begrun + dr->runlength) == dr->data_sn) {\n\t\t\tdr->dr_complete =\n\t\t\t    (dr->recovery == DATAIN_WITHIN_COMMAND_RECOVERY) ?\n\t\t\t\tDATAIN_COMPLETE_WITHIN_COMMAND_RECOVERY :\n\t\t\t\tDATAIN_COMPLETE_CONNECTION_RECOVERY;\n\t\t}\n\t}\n\n\treturn dr;\n}\n\n \nstatic struct iscsi_datain_req *iscsit_set_datain_values_no_and_yes(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsi_datain *datain)\n{\n\tu32 offset, read_data_done, read_data_left, seq_send_order;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_datain_req *dr;\n\tstruct iscsi_seq *seq;\n\n\tdr = iscsit_get_datain_req(cmd);\n\tif (!dr)\n\t\treturn NULL;\n\n\tif (dr->recovery && dr->generate_recovery_values) {\n\t\tif (iscsit_create_recovery_datain_values_datasequenceinorder_no(\n\t\t\t\t\tcmd, dr) < 0)\n\t\t\treturn NULL;\n\n\t\tdr->generate_recovery_values = 0;\n\t}\n\n\tread_data_done = (!dr->recovery) ?\n\t\t\tcmd->read_data_done : dr->read_data_done;\n\tseq_send_order = (!dr->recovery) ?\n\t\t\tcmd->seq_send_order : dr->seq_send_order;\n\n\tread_data_left = (cmd->se_cmd.data_length - read_data_done);\n\tif (!read_data_left) {\n\t\tpr_err(\"ITT: 0x%08x read_data_left is zero!\\n\",\n\t\t\t\tcmd->init_task_tag);\n\t\treturn NULL;\n\t}\n\n\tseq = iscsit_get_seq_holder_for_datain(cmd, seq_send_order);\n\tif (!seq)\n\t\treturn NULL;\n\n\tseq->sent = 1;\n\n\tif (!dr->recovery && !seq->next_burst_len)\n\t\tseq->first_datasn = cmd->data_sn;\n\n\toffset = (seq->offset + seq->next_burst_len);\n\n\tif ((offset + conn->conn_ops->MaxRecvDataSegmentLength) >=\n\t     cmd->se_cmd.data_length) {\n\t\tdatain->length = (cmd->se_cmd.data_length - offset);\n\t\tdatain->offset = offset;\n\n\t\tdatain->flags |= ISCSI_FLAG_CMD_FINAL;\n\t\tif (conn->sess->sess_ops->ErrorRecoveryLevel > 0)\n\t\t\tdatain->flags |= ISCSI_FLAG_DATA_ACK;\n\n\t\tseq->next_burst_len = 0;\n\t\tseq_send_order++;\n\t} else {\n\t\tif ((seq->next_burst_len +\n\t\t     conn->conn_ops->MaxRecvDataSegmentLength) <\n\t\t     conn->sess->sess_ops->MaxBurstLength) {\n\t\t\tdatain->length =\n\t\t\t\tconn->conn_ops->MaxRecvDataSegmentLength;\n\t\t\tdatain->offset = (seq->offset + seq->next_burst_len);\n\n\t\t\tseq->next_burst_len += datain->length;\n\t\t} else {\n\t\t\tdatain->length = (conn->sess->sess_ops->MaxBurstLength -\n\t\t\t\t\t  seq->next_burst_len);\n\t\t\tdatain->offset = (seq->offset + seq->next_burst_len);\n\n\t\t\tdatain->flags |= ISCSI_FLAG_CMD_FINAL;\n\t\t\tif (conn->sess->sess_ops->ErrorRecoveryLevel > 0)\n\t\t\t\tdatain->flags |= ISCSI_FLAG_DATA_ACK;\n\n\t\t\tseq->next_burst_len = 0;\n\t\t\tseq_send_order++;\n\t\t}\n\t}\n\n\tif ((read_data_done + datain->length) == cmd->se_cmd.data_length)\n\t\tdatain->flags |= ISCSI_FLAG_DATA_STATUS;\n\n\tdatain->data_sn = (!dr->recovery) ? cmd->data_sn++ : dr->data_sn++;\n\tif (!dr->recovery) {\n\t\tcmd->seq_send_order = seq_send_order;\n\t\tcmd->read_data_done += datain->length;\n\t} else {\n\t\tdr->seq_send_order = seq_send_order;\n\t\tdr->read_data_done += datain->length;\n\t}\n\n\tif (!dr->recovery) {\n\t\tif (datain->flags & ISCSI_FLAG_CMD_FINAL)\n\t\t\tseq->last_datasn = datain->data_sn;\n\t\tif (datain->flags & ISCSI_FLAG_DATA_STATUS)\n\t\t\tdr->dr_complete = DATAIN_COMPLETE_NORMAL;\n\n\t\treturn dr;\n\t}\n\n\tif (!dr->runlength) {\n\t\tif (datain->flags & ISCSI_FLAG_DATA_STATUS) {\n\t\t\tdr->dr_complete =\n\t\t\t    (dr->recovery == DATAIN_WITHIN_COMMAND_RECOVERY) ?\n\t\t\t\tDATAIN_COMPLETE_WITHIN_COMMAND_RECOVERY :\n\t\t\t\tDATAIN_COMPLETE_CONNECTION_RECOVERY;\n\t\t}\n\t} else {\n\t\tif ((dr->begrun + dr->runlength) == dr->data_sn) {\n\t\t\tdr->dr_complete =\n\t\t\t    (dr->recovery == DATAIN_WITHIN_COMMAND_RECOVERY) ?\n\t\t\t\tDATAIN_COMPLETE_WITHIN_COMMAND_RECOVERY :\n\t\t\t\tDATAIN_COMPLETE_CONNECTION_RECOVERY;\n\t\t}\n\t}\n\n\treturn dr;\n}\n\n \nstatic struct iscsi_datain_req *iscsit_set_datain_values_yes_and_no(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsi_datain *datain)\n{\n\tu32 next_burst_len, read_data_done, read_data_left;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_datain_req *dr;\n\tstruct iscsi_pdu *pdu;\n\n\tdr = iscsit_get_datain_req(cmd);\n\tif (!dr)\n\t\treturn NULL;\n\n\tif (dr->recovery && dr->generate_recovery_values) {\n\t\tif (iscsit_create_recovery_datain_values_datasequenceinorder_yes(\n\t\t\t\t\tcmd, dr) < 0)\n\t\t\treturn NULL;\n\n\t\tdr->generate_recovery_values = 0;\n\t}\n\n\tnext_burst_len = (!dr->recovery) ?\n\t\t\tcmd->next_burst_len : dr->next_burst_len;\n\tread_data_done = (!dr->recovery) ?\n\t\t\tcmd->read_data_done : dr->read_data_done;\n\n\tread_data_left = (cmd->se_cmd.data_length - read_data_done);\n\tif (!read_data_left) {\n\t\tpr_err(\"ITT: 0x%08x read_data_left is zero!\\n\",\n\t\t\t\tcmd->init_task_tag);\n\t\treturn dr;\n\t}\n\n\tpdu = iscsit_get_pdu_holder_for_seq(cmd, NULL);\n\tif (!pdu)\n\t\treturn dr;\n\n\tif ((read_data_done + pdu->length) == cmd->se_cmd.data_length) {\n\t\tpdu->flags |= (ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS);\n\t\tif (conn->sess->sess_ops->ErrorRecoveryLevel > 0)\n\t\t\tpdu->flags |= ISCSI_FLAG_DATA_ACK;\n\n\t\tnext_burst_len = 0;\n\t} else {\n\t\tif ((next_burst_len + conn->conn_ops->MaxRecvDataSegmentLength) <\n\t\t     conn->sess->sess_ops->MaxBurstLength)\n\t\t\tnext_burst_len += pdu->length;\n\t\telse {\n\t\t\tpdu->flags |= ISCSI_FLAG_CMD_FINAL;\n\t\t\tif (conn->sess->sess_ops->ErrorRecoveryLevel > 0)\n\t\t\t\tpdu->flags |= ISCSI_FLAG_DATA_ACK;\n\n\t\t\tnext_burst_len = 0;\n\t\t}\n\t}\n\n\tpdu->data_sn = (!dr->recovery) ? cmd->data_sn++ : dr->data_sn++;\n\tif (!dr->recovery) {\n\t\tcmd->next_burst_len = next_burst_len;\n\t\tcmd->read_data_done += pdu->length;\n\t} else {\n\t\tdr->next_burst_len = next_burst_len;\n\t\tdr->read_data_done += pdu->length;\n\t}\n\n\tdatain->flags = pdu->flags;\n\tdatain->length = pdu->length;\n\tdatain->offset = pdu->offset;\n\tdatain->data_sn = pdu->data_sn;\n\n\tif (!dr->recovery) {\n\t\tif (datain->flags & ISCSI_FLAG_DATA_STATUS)\n\t\t\tdr->dr_complete = DATAIN_COMPLETE_NORMAL;\n\n\t\treturn dr;\n\t}\n\n\tif (!dr->runlength) {\n\t\tif (datain->flags & ISCSI_FLAG_DATA_STATUS) {\n\t\t\tdr->dr_complete =\n\t\t\t    (dr->recovery == DATAIN_WITHIN_COMMAND_RECOVERY) ?\n\t\t\t\tDATAIN_COMPLETE_WITHIN_COMMAND_RECOVERY :\n\t\t\t\tDATAIN_COMPLETE_CONNECTION_RECOVERY;\n\t\t}\n\t} else {\n\t\tif ((dr->begrun + dr->runlength) == dr->data_sn) {\n\t\t\tdr->dr_complete =\n\t\t\t    (dr->recovery == DATAIN_WITHIN_COMMAND_RECOVERY) ?\n\t\t\t\tDATAIN_COMPLETE_WITHIN_COMMAND_RECOVERY :\n\t\t\t\tDATAIN_COMPLETE_CONNECTION_RECOVERY;\n\t\t}\n\t}\n\n\treturn dr;\n}\n\n \nstatic struct iscsi_datain_req *iscsit_set_datain_values_no_and_no(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsi_datain *datain)\n{\n\tu32 read_data_done, read_data_left, seq_send_order;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_datain_req *dr;\n\tstruct iscsi_pdu *pdu;\n\tstruct iscsi_seq *seq = NULL;\n\n\tdr = iscsit_get_datain_req(cmd);\n\tif (!dr)\n\t\treturn NULL;\n\n\tif (dr->recovery && dr->generate_recovery_values) {\n\t\tif (iscsit_create_recovery_datain_values_datasequenceinorder_no(\n\t\t\t\t\tcmd, dr) < 0)\n\t\t\treturn NULL;\n\n\t\tdr->generate_recovery_values = 0;\n\t}\n\n\tread_data_done = (!dr->recovery) ?\n\t\t\tcmd->read_data_done : dr->read_data_done;\n\tseq_send_order = (!dr->recovery) ?\n\t\t\tcmd->seq_send_order : dr->seq_send_order;\n\n\tread_data_left = (cmd->se_cmd.data_length - read_data_done);\n\tif (!read_data_left) {\n\t\tpr_err(\"ITT: 0x%08x read_data_left is zero!\\n\",\n\t\t\t\tcmd->init_task_tag);\n\t\treturn NULL;\n\t}\n\n\tseq = iscsit_get_seq_holder_for_datain(cmd, seq_send_order);\n\tif (!seq)\n\t\treturn NULL;\n\n\tseq->sent = 1;\n\n\tif (!dr->recovery && !seq->next_burst_len)\n\t\tseq->first_datasn = cmd->data_sn;\n\n\tpdu = iscsit_get_pdu_holder_for_seq(cmd, seq);\n\tif (!pdu)\n\t\treturn NULL;\n\n\tif (seq->pdu_send_order == seq->pdu_count) {\n\t\tpdu->flags |= ISCSI_FLAG_CMD_FINAL;\n\t\tif (conn->sess->sess_ops->ErrorRecoveryLevel > 0)\n\t\t\tpdu->flags |= ISCSI_FLAG_DATA_ACK;\n\n\t\tseq->next_burst_len = 0;\n\t\tseq_send_order++;\n\t} else\n\t\tseq->next_burst_len += pdu->length;\n\n\tif ((read_data_done + pdu->length) == cmd->se_cmd.data_length)\n\t\tpdu->flags |= ISCSI_FLAG_DATA_STATUS;\n\n\tpdu->data_sn = (!dr->recovery) ? cmd->data_sn++ : dr->data_sn++;\n\tif (!dr->recovery) {\n\t\tcmd->seq_send_order = seq_send_order;\n\t\tcmd->read_data_done += pdu->length;\n\t} else {\n\t\tdr->seq_send_order = seq_send_order;\n\t\tdr->read_data_done += pdu->length;\n\t}\n\n\tdatain->flags = pdu->flags;\n\tdatain->length = pdu->length;\n\tdatain->offset = pdu->offset;\n\tdatain->data_sn = pdu->data_sn;\n\n\tif (!dr->recovery) {\n\t\tif (datain->flags & ISCSI_FLAG_CMD_FINAL)\n\t\t\tseq->last_datasn = datain->data_sn;\n\t\tif (datain->flags & ISCSI_FLAG_DATA_STATUS)\n\t\t\tdr->dr_complete = DATAIN_COMPLETE_NORMAL;\n\n\t\treturn dr;\n\t}\n\n\tif (!dr->runlength) {\n\t\tif (datain->flags & ISCSI_FLAG_DATA_STATUS) {\n\t\t\tdr->dr_complete =\n\t\t\t    (dr->recovery == DATAIN_WITHIN_COMMAND_RECOVERY) ?\n\t\t\t\tDATAIN_COMPLETE_WITHIN_COMMAND_RECOVERY :\n\t\t\t\tDATAIN_COMPLETE_CONNECTION_RECOVERY;\n\t\t}\n\t} else {\n\t\tif ((dr->begrun + dr->runlength) == dr->data_sn) {\n\t\t\tdr->dr_complete =\n\t\t\t    (dr->recovery == DATAIN_WITHIN_COMMAND_RECOVERY) ?\n\t\t\t\tDATAIN_COMPLETE_WITHIN_COMMAND_RECOVERY :\n\t\t\t\tDATAIN_COMPLETE_CONNECTION_RECOVERY;\n\t\t}\n\t}\n\n\treturn dr;\n}\n\nstruct iscsi_datain_req *iscsit_get_datain_values(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsi_datain *datain)\n{\n\tstruct iscsit_conn *conn = cmd->conn;\n\n\tif (conn->sess->sess_ops->DataSequenceInOrder &&\n\t    conn->sess->sess_ops->DataPDUInOrder)\n\t\treturn iscsit_set_datain_values_yes_and_yes(cmd, datain);\n\telse if (!conn->sess->sess_ops->DataSequenceInOrder &&\n\t\t  conn->sess->sess_ops->DataPDUInOrder)\n\t\treturn iscsit_set_datain_values_no_and_yes(cmd, datain);\n\telse if (conn->sess->sess_ops->DataSequenceInOrder &&\n\t\t !conn->sess->sess_ops->DataPDUInOrder)\n\t\treturn iscsit_set_datain_values_yes_and_no(cmd, datain);\n\telse if (!conn->sess->sess_ops->DataSequenceInOrder &&\n\t\t   !conn->sess->sess_ops->DataPDUInOrder)\n\t\treturn iscsit_set_datain_values_no_and_no(cmd, datain);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(iscsit_get_datain_values);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}