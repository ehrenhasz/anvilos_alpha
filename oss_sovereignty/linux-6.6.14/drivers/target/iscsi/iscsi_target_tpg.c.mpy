{
  "module_name": "iscsi_target_tpg.c",
  "hash_id": "f6d4b616d3c1d54fe2c61a68c17337c4370ef4d641a8cb53c12b70924607a477",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target_tpg.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n#include <target/iscsi/iscsi_target_core.h>\n#include \"iscsi_target_erl0.h\"\n#include \"iscsi_target_login.h\"\n#include \"iscsi_target_nodeattrib.h\"\n#include \"iscsi_target_tpg.h\"\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target.h\"\n#include \"iscsi_target_parameters.h\"\n\n#include <target/iscsi/iscsi_transport.h>\n\nstruct iscsi_portal_group *iscsit_alloc_portal_group(struct iscsi_tiqn *tiqn, u16 tpgt)\n{\n\tstruct iscsi_portal_group *tpg;\n\n\ttpg = kzalloc(sizeof(struct iscsi_portal_group), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct iscsi_portal_group\\n\");\n\t\treturn NULL;\n\t}\n\n\ttpg->tpgt = tpgt;\n\ttpg->tpg_state = TPG_STATE_FREE;\n\ttpg->tpg_tiqn = tiqn;\n\tINIT_LIST_HEAD(&tpg->tpg_gnp_list);\n\tINIT_LIST_HEAD(&tpg->tpg_list);\n\tmutex_init(&tpg->tpg_access_lock);\n\tsema_init(&tpg->np_login_sem, 1);\n\tspin_lock_init(&tpg->tpg_state_lock);\n\tspin_lock_init(&tpg->tpg_np_lock);\n\n\treturn tpg;\n}\n\nstatic void iscsit_set_default_tpg_attribs(struct iscsi_portal_group *);\n\nint iscsit_load_discovery_tpg(void)\n{\n\tstruct iscsi_param *param;\n\tstruct iscsi_portal_group *tpg;\n\tint ret;\n\n\ttpg = iscsit_alloc_portal_group(NULL, 1);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct iscsi_portal_group\\n\");\n\t\treturn -1;\n\t}\n\t \n\ttpg->tpg_se_tpg.se_tpg_tfo = &iscsi_ops;\n\tret = core_tpg_register(NULL, &tpg->tpg_se_tpg, -1);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn -1;\n\t}\n\n\ttpg->sid = 1;  \n\tiscsit_set_default_tpg_attribs(tpg);\n\n\tif (iscsi_create_default_params(&tpg->param_list) < 0)\n\t\tgoto out;\n\t \n\tparam = iscsi_find_param_from_key(AUTHMETHOD, tpg->param_list);\n\tif (!param)\n\t\tgoto free_pl_out;\n\n\tif (iscsi_update_param_value(param, \"CHAP,None\") < 0)\n\t\tgoto free_pl_out;\n\n\ttpg->tpg_attrib.authentication = 0;\n\n\tspin_lock(&tpg->tpg_state_lock);\n\ttpg->tpg_state  = TPG_STATE_ACTIVE;\n\tspin_unlock(&tpg->tpg_state_lock);\n\n\tiscsit_global->discovery_tpg = tpg;\n\tpr_debug(\"CORE[0] - Allocated Discovery TPG\\n\");\n\n\treturn 0;\nfree_pl_out:\n\tiscsi_release_param_list(tpg->param_list);\nout:\n\tif (tpg->sid == 1)\n\t\tcore_tpg_deregister(&tpg->tpg_se_tpg);\n\tkfree(tpg);\n\treturn -1;\n}\n\nvoid iscsit_release_discovery_tpg(void)\n{\n\tstruct iscsi_portal_group *tpg = iscsit_global->discovery_tpg;\n\n\tif (!tpg)\n\t\treturn;\n\n\tiscsi_release_param_list(tpg->param_list);\n\tcore_tpg_deregister(&tpg->tpg_se_tpg);\n\n\tkfree(tpg);\n\tiscsit_global->discovery_tpg = NULL;\n}\n\nstruct iscsi_portal_group *iscsit_get_tpg_from_np(\n\tstruct iscsi_tiqn *tiqn,\n\tstruct iscsi_np *np,\n\tstruct iscsi_tpg_np **tpg_np_out)\n{\n\tstruct iscsi_portal_group *tpg = NULL;\n\tstruct iscsi_tpg_np *tpg_np;\n\n\tspin_lock(&tiqn->tiqn_tpg_lock);\n\tlist_for_each_entry(tpg, &tiqn->tiqn_tpg_list, tpg_list) {\n\n\t\tspin_lock(&tpg->tpg_state_lock);\n\t\tif (tpg->tpg_state != TPG_STATE_ACTIVE) {\n\t\t\tspin_unlock(&tpg->tpg_state_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&tpg->tpg_state_lock);\n\n\t\tspin_lock(&tpg->tpg_np_lock);\n\t\tlist_for_each_entry(tpg_np, &tpg->tpg_gnp_list, tpg_np_list) {\n\t\t\tif (tpg_np->tpg_np == np) {\n\t\t\t\t*tpg_np_out = tpg_np;\n\t\t\t\tkref_get(&tpg_np->tpg_np_kref);\n\t\t\t\tspin_unlock(&tpg->tpg_np_lock);\n\t\t\t\tspin_unlock(&tiqn->tiqn_tpg_lock);\n\t\t\t\treturn tpg;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&tpg->tpg_np_lock);\n\t}\n\tspin_unlock(&tiqn->tiqn_tpg_lock);\n\n\treturn NULL;\n}\n\nint iscsit_get_tpg(\n\tstruct iscsi_portal_group *tpg)\n{\n\treturn mutex_lock_interruptible(&tpg->tpg_access_lock);\n}\n\nvoid iscsit_put_tpg(struct iscsi_portal_group *tpg)\n{\n\tmutex_unlock(&tpg->tpg_access_lock);\n}\n\nstatic void iscsit_clear_tpg_np_login_thread(\n\tstruct iscsi_tpg_np *tpg_np,\n\tstruct iscsi_portal_group *tpg,\n\tbool shutdown)\n{\n\tif (!tpg_np->tpg_np) {\n\t\tpr_err(\"struct iscsi_tpg_np->tpg_np is NULL!\\n\");\n\t\treturn;\n\t}\n\n\tif (shutdown)\n\t\ttpg_np->tpg_np->enabled = false;\n\tiscsit_reset_np_thread(tpg_np->tpg_np, tpg_np, tpg, shutdown);\n}\n\nstatic void iscsit_clear_tpg_np_login_threads(\n\tstruct iscsi_portal_group *tpg,\n\tbool shutdown)\n{\n\tstruct iscsi_tpg_np *tpg_np;\n\n\tspin_lock(&tpg->tpg_np_lock);\n\tlist_for_each_entry(tpg_np, &tpg->tpg_gnp_list, tpg_np_list) {\n\t\tif (!tpg_np->tpg_np) {\n\t\t\tpr_err(\"struct iscsi_tpg_np->tpg_np is NULL!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&tpg->tpg_np_lock);\n\t\tiscsit_clear_tpg_np_login_thread(tpg_np, tpg, shutdown);\n\t\tspin_lock(&tpg->tpg_np_lock);\n\t}\n\tspin_unlock(&tpg->tpg_np_lock);\n}\n\nvoid iscsit_tpg_dump_params(struct iscsi_portal_group *tpg)\n{\n\tiscsi_print_params(tpg->param_list);\n}\n\nstatic void iscsit_set_default_tpg_attribs(struct iscsi_portal_group *tpg)\n{\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\ta->authentication = TA_AUTHENTICATION;\n\ta->login_timeout = TA_LOGIN_TIMEOUT;\n\ta->default_cmdsn_depth = TA_DEFAULT_CMDSN_DEPTH;\n\ta->generate_node_acls = TA_GENERATE_NODE_ACLS;\n\ta->cache_dynamic_acls = TA_CACHE_DYNAMIC_ACLS;\n\ta->demo_mode_write_protect = TA_DEMO_MODE_WRITE_PROTECT;\n\ta->prod_mode_write_protect = TA_PROD_MODE_WRITE_PROTECT;\n\ta->demo_mode_discovery = TA_DEMO_MODE_DISCOVERY;\n\ta->default_erl = TA_DEFAULT_ERL;\n\ta->t10_pi = TA_DEFAULT_T10_PI;\n\ta->fabric_prot_type = TA_DEFAULT_FABRIC_PROT_TYPE;\n\ta->tpg_enabled_sendtargets = TA_DEFAULT_TPG_ENABLED_SENDTARGETS;\n\ta->login_keys_workaround = TA_DEFAULT_LOGIN_KEYS_WORKAROUND;\n}\n\nint iscsit_tpg_add_portal_group(struct iscsi_tiqn *tiqn, struct iscsi_portal_group *tpg)\n{\n\tif (tpg->tpg_state != TPG_STATE_FREE) {\n\t\tpr_err(\"Unable to add iSCSI Target Portal Group: %d\"\n\t\t\t\" while not in TPG_STATE_FREE state.\\n\", tpg->tpgt);\n\t\treturn -EEXIST;\n\t}\n\tiscsit_set_default_tpg_attribs(tpg);\n\n\tif (iscsi_create_default_params(&tpg->param_list) < 0)\n\t\tgoto err_out;\n\n\ttpg->tpg_attrib.tpg = tpg;\n\n\tspin_lock(&tpg->tpg_state_lock);\n\ttpg->tpg_state\t= TPG_STATE_INACTIVE;\n\tspin_unlock(&tpg->tpg_state_lock);\n\n\tspin_lock(&tiqn->tiqn_tpg_lock);\n\tlist_add_tail(&tpg->tpg_list, &tiqn->tiqn_tpg_list);\n\ttiqn->tiqn_ntpgs++;\n\tpr_debug(\"CORE[%s]_TPG[%hu] - Added iSCSI Target Portal Group\\n\",\n\t\t\ttiqn->tiqn, tpg->tpgt);\n\tspin_unlock(&tiqn->tiqn_tpg_lock);\n\n\treturn 0;\nerr_out:\n\tif (tpg->param_list) {\n\t\tiscsi_release_param_list(tpg->param_list);\n\t\ttpg->param_list = NULL;\n\t}\n\treturn -ENOMEM;\n}\n\nint iscsit_tpg_del_portal_group(\n\tstruct iscsi_tiqn *tiqn,\n\tstruct iscsi_portal_group *tpg,\n\tint force)\n{\n\tu8 old_state = tpg->tpg_state;\n\n\tspin_lock(&tpg->tpg_state_lock);\n\ttpg->tpg_state = TPG_STATE_INACTIVE;\n\tspin_unlock(&tpg->tpg_state_lock);\n\n\tif (iscsit_release_sessions_for_tpg(tpg, force) < 0) {\n\t\tpr_err(\"Unable to delete iSCSI Target Portal Group:\"\n\t\t\t\" %hu while active sessions exist, and force=0\\n\",\n\t\t\ttpg->tpgt);\n\t\ttpg->tpg_state = old_state;\n\t\treturn -EPERM;\n\t}\n\n\tif (tpg->param_list) {\n\t\tiscsi_release_param_list(tpg->param_list);\n\t\ttpg->param_list = NULL;\n\t}\n\n\tcore_tpg_deregister(&tpg->tpg_se_tpg);\n\n\tspin_lock(&tpg->tpg_state_lock);\n\ttpg->tpg_state = TPG_STATE_FREE;\n\tspin_unlock(&tpg->tpg_state_lock);\n\n\tspin_lock(&tiqn->tiqn_tpg_lock);\n\ttiqn->tiqn_ntpgs--;\n\tlist_del(&tpg->tpg_list);\n\tspin_unlock(&tiqn->tiqn_tpg_lock);\n\n\tpr_debug(\"CORE[%s]_TPG[%hu] - Deleted iSCSI Target Portal Group\\n\",\n\t\t\ttiqn->tiqn, tpg->tpgt);\n\n\tkfree(tpg);\n\treturn 0;\n}\n\nint iscsit_tpg_enable_portal_group(struct iscsi_portal_group *tpg)\n{\n\tstruct iscsi_param *param;\n\tstruct iscsi_tiqn *tiqn = tpg->tpg_tiqn;\n\tint ret;\n\n\tif (tpg->tpg_state == TPG_STATE_ACTIVE) {\n\t\tpr_err(\"iSCSI target portal group: %hu is already\"\n\t\t\t\" active, ignoring request.\\n\", tpg->tpgt);\n\t\treturn -EINVAL;\n\t}\n\t \n\tparam = iscsi_find_param_from_key(AUTHMETHOD, tpg->param_list);\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (tpg->tpg_attrib.authentication) {\n\t\tif (!strcmp(param->value, NONE)) {\n\t\t\tret = iscsi_update_param_value(param, CHAP);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tret = iscsit_ta_authentication(tpg, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tspin_lock(&tpg->tpg_state_lock);\n\ttpg->tpg_state = TPG_STATE_ACTIVE;\n\tspin_unlock(&tpg->tpg_state_lock);\n\n\tspin_lock(&tiqn->tiqn_tpg_lock);\n\ttiqn->tiqn_active_tpgs++;\n\tpr_debug(\"iSCSI_TPG[%hu] - Enabled iSCSI Target Portal Group\\n\",\n\t\t\ttpg->tpgt);\n\tspin_unlock(&tiqn->tiqn_tpg_lock);\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nint iscsit_tpg_disable_portal_group(struct iscsi_portal_group *tpg, int force)\n{\n\tstruct iscsi_tiqn *tiqn;\n\tu8 old_state = tpg->tpg_state;\n\n\tspin_lock(&tpg->tpg_state_lock);\n\tif (tpg->tpg_state == TPG_STATE_INACTIVE) {\n\t\tpr_err(\"iSCSI Target Portal Group: %hu is already\"\n\t\t\t\" inactive, ignoring request.\\n\", tpg->tpgt);\n\t\tspin_unlock(&tpg->tpg_state_lock);\n\t\treturn -EINVAL;\n\t}\n\ttpg->tpg_state = TPG_STATE_INACTIVE;\n\tspin_unlock(&tpg->tpg_state_lock);\n\n\tiscsit_clear_tpg_np_login_threads(tpg, false);\n\n\tif (iscsit_release_sessions_for_tpg(tpg, force) < 0) {\n\t\tspin_lock(&tpg->tpg_state_lock);\n\t\ttpg->tpg_state = old_state;\n\t\tspin_unlock(&tpg->tpg_state_lock);\n\t\tpr_err(\"Unable to disable iSCSI Target Portal Group:\"\n\t\t\t\" %hu while active sessions exist, and force=0\\n\",\n\t\t\ttpg->tpgt);\n\t\treturn -EPERM;\n\t}\n\n\ttiqn = tpg->tpg_tiqn;\n\tif (!tiqn || (tpg == iscsit_global->discovery_tpg))\n\t\treturn 0;\n\n\tspin_lock(&tiqn->tiqn_tpg_lock);\n\ttiqn->tiqn_active_tpgs--;\n\tpr_debug(\"iSCSI_TPG[%hu] - Disabled iSCSI Target Portal Group\\n\",\n\t\t\ttpg->tpgt);\n\tspin_unlock(&tiqn->tiqn_tpg_lock);\n\n\treturn 0;\n}\n\nstruct iscsi_node_attrib *iscsit_tpg_get_node_attrib(\n\tstruct iscsit_session *sess)\n{\n\tstruct se_session *se_sess = sess->se_sess;\n\tstruct se_node_acl *se_nacl = se_sess->se_node_acl;\n\tstruct iscsi_node_acl *acl = to_iscsi_nacl(se_nacl);\n\n\treturn &acl->node_attrib;\n}\n\nstruct iscsi_tpg_np *iscsit_tpg_locate_child_np(\n\tstruct iscsi_tpg_np *tpg_np,\n\tint network_transport)\n{\n\tstruct iscsi_tpg_np *tpg_np_child, *tpg_np_child_tmp;\n\n\tspin_lock(&tpg_np->tpg_np_parent_lock);\n\tlist_for_each_entry_safe(tpg_np_child, tpg_np_child_tmp,\n\t\t\t&tpg_np->tpg_np_parent_list, tpg_np_child_list) {\n\t\tif (tpg_np_child->tpg_np->np_network_transport ==\n\t\t\t\tnetwork_transport) {\n\t\t\tspin_unlock(&tpg_np->tpg_np_parent_lock);\n\t\t\treturn tpg_np_child;\n\t\t}\n\t}\n\tspin_unlock(&tpg_np->tpg_np_parent_lock);\n\n\treturn NULL;\n}\n\nstatic bool iscsit_tpg_check_network_portal(\n\tstruct iscsi_tiqn *tiqn,\n\tstruct sockaddr_storage *sockaddr,\n\tint network_transport)\n{\n\tstruct iscsi_portal_group *tpg;\n\tstruct iscsi_tpg_np *tpg_np;\n\tstruct iscsi_np *np;\n\tbool match = false;\n\n\tspin_lock(&tiqn->tiqn_tpg_lock);\n\tlist_for_each_entry(tpg, &tiqn->tiqn_tpg_list, tpg_list) {\n\n\t\tspin_lock(&tpg->tpg_np_lock);\n\t\tlist_for_each_entry(tpg_np, &tpg->tpg_gnp_list, tpg_np_list) {\n\t\t\tnp = tpg_np->tpg_np;\n\n\t\t\tmatch = iscsit_check_np_match(sockaddr, np,\n\t\t\t\t\t\tnetwork_transport);\n\t\t\tif (match)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&tpg->tpg_np_lock);\n\n\t\tif (match)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&tiqn->tiqn_tpg_lock);\n\n\treturn match;\n}\n\nstruct iscsi_tpg_np *iscsit_tpg_add_network_portal(\n\tstruct iscsi_portal_group *tpg,\n\tstruct sockaddr_storage *sockaddr,\n\tstruct iscsi_tpg_np *tpg_np_parent,\n\tint network_transport)\n{\n\tstruct iscsi_np *np;\n\tstruct iscsi_tpg_np *tpg_np;\n\n\tif (!tpg_np_parent) {\n\t\tif (iscsit_tpg_check_network_portal(tpg->tpg_tiqn, sockaddr,\n\t\t\t\tnetwork_transport)) {\n\t\t\tpr_err(\"Network Portal: %pISc already exists on a\"\n\t\t\t\t\" different TPG on %s\\n\", sockaddr,\n\t\t\t\ttpg->tpg_tiqn->tiqn);\n\t\t\treturn ERR_PTR(-EEXIST);\n\t\t}\n\t}\n\n\ttpg_np = kzalloc(sizeof(struct iscsi_tpg_np), GFP_KERNEL);\n\tif (!tpg_np) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\t\" struct iscsi_tpg_np.\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tnp = iscsit_add_np(sockaddr, network_transport);\n\tif (IS_ERR(np)) {\n\t\tkfree(tpg_np);\n\t\treturn ERR_CAST(np);\n\t}\n\n\tINIT_LIST_HEAD(&tpg_np->tpg_np_list);\n\tINIT_LIST_HEAD(&tpg_np->tpg_np_child_list);\n\tINIT_LIST_HEAD(&tpg_np->tpg_np_parent_list);\n\tspin_lock_init(&tpg_np->tpg_np_parent_lock);\n\tinit_completion(&tpg_np->tpg_np_comp);\n\tkref_init(&tpg_np->tpg_np_kref);\n\ttpg_np->tpg_np\t\t= np;\n\ttpg_np->tpg\t\t= tpg;\n\n\tspin_lock(&tpg->tpg_np_lock);\n\tlist_add_tail(&tpg_np->tpg_np_list, &tpg->tpg_gnp_list);\n\ttpg->num_tpg_nps++;\n\tif (tpg->tpg_tiqn)\n\t\ttpg->tpg_tiqn->tiqn_num_tpg_nps++;\n\tspin_unlock(&tpg->tpg_np_lock);\n\n\tif (tpg_np_parent) {\n\t\ttpg_np->tpg_np_parent = tpg_np_parent;\n\t\tspin_lock(&tpg_np_parent->tpg_np_parent_lock);\n\t\tlist_add_tail(&tpg_np->tpg_np_child_list,\n\t\t\t&tpg_np_parent->tpg_np_parent_list);\n\t\tspin_unlock(&tpg_np_parent->tpg_np_parent_lock);\n\t}\n\n\tpr_debug(\"CORE[%s] - Added Network Portal: %pISpc,%hu on %s\\n\",\n\t\ttpg->tpg_tiqn->tiqn, &np->np_sockaddr, tpg->tpgt,\n\t\tnp->np_transport->name);\n\n\treturn tpg_np;\n}\n\nstatic int iscsit_tpg_release_np(\n\tstruct iscsi_tpg_np *tpg_np,\n\tstruct iscsi_portal_group *tpg,\n\tstruct iscsi_np *np)\n{\n\tiscsit_clear_tpg_np_login_thread(tpg_np, tpg, true);\n\n\tpr_debug(\"CORE[%s] - Removed Network Portal: %pISpc,%hu on %s\\n\",\n\t\ttpg->tpg_tiqn->tiqn, &np->np_sockaddr, tpg->tpgt,\n\t\tnp->np_transport->name);\n\n\ttpg_np->tpg_np = NULL;\n\ttpg_np->tpg = NULL;\n\tkfree(tpg_np);\n\t \n\treturn iscsit_del_np(np);\n}\n\nint iscsit_tpg_del_network_portal(\n\tstruct iscsi_portal_group *tpg,\n\tstruct iscsi_tpg_np *tpg_np)\n{\n\tstruct iscsi_np *np;\n\tstruct iscsi_tpg_np *tpg_np_child, *tpg_np_child_tmp;\n\tint ret = 0;\n\n\tnp = tpg_np->tpg_np;\n\tif (!np) {\n\t\tpr_err(\"Unable to locate struct iscsi_np from\"\n\t\t\t\t\" struct iscsi_tpg_np\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tpg_np->tpg_np_parent) {\n\t\t \n\t\tlist_for_each_entry_safe(tpg_np_child, tpg_np_child_tmp,\n\t\t\t\t&tpg_np->tpg_np_parent_list,\n\t\t\t\ttpg_np_child_list) {\n\t\t\tret = iscsit_tpg_del_network_portal(tpg, tpg_np_child);\n\t\t\tif (ret < 0)\n\t\t\t\tpr_err(\"iscsit_tpg_del_network_portal()\"\n\t\t\t\t\t\" failed: %d\\n\", ret);\n\t\t}\n\t} else {\n\t\t \n\t\tspin_lock(&tpg_np->tpg_np_parent->tpg_np_parent_lock);\n\t\tlist_del(&tpg_np->tpg_np_child_list);\n\t\tspin_unlock(&tpg_np->tpg_np_parent->tpg_np_parent_lock);\n\t}\n\n\tspin_lock(&tpg->tpg_np_lock);\n\tlist_del(&tpg_np->tpg_np_list);\n\ttpg->num_tpg_nps--;\n\tif (tpg->tpg_tiqn)\n\t\ttpg->tpg_tiqn->tiqn_num_tpg_nps--;\n\tspin_unlock(&tpg->tpg_np_lock);\n\n\treturn iscsit_tpg_release_np(tpg_np, tpg, np);\n}\n\nint iscsit_ta_authentication(struct iscsi_portal_group *tpg, u32 authentication)\n{\n\tunsigned char buf1[256], buf2[256], *none = NULL;\n\tint len;\n\tstruct iscsi_param *param;\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\tif ((authentication != 1) && (authentication != 0)) {\n\t\tpr_err(\"Illegal value for authentication parameter:\"\n\t\t\t\" %u, ignoring request.\\n\", authentication);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(buf1, 0, sizeof(buf1));\n\tmemset(buf2, 0, sizeof(buf2));\n\n\tparam = iscsi_find_param_from_key(AUTHMETHOD, tpg->param_list);\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (authentication) {\n\t\tsnprintf(buf1, sizeof(buf1), \"%s\", param->value);\n\t\tnone = strstr(buf1, NONE);\n\t\tif (!none)\n\t\t\tgoto out;\n\t\tif (!strncmp(none + 4, \",\", 1)) {\n\t\t\tif (!strcmp(buf1, none))\n\t\t\t\tsprintf(buf2, \"%s\", none+5);\n\t\t\telse {\n\t\t\t\tnone--;\n\t\t\t\t*none = '\\0';\n\t\t\t\tlen = sprintf(buf2, \"%s\", buf1);\n\t\t\t\tnone += 5;\n\t\t\t\tsprintf(buf2 + len, \"%s\", none);\n\t\t\t}\n\t\t} else {\n\t\t\tnone--;\n\t\t\t*none = '\\0';\n\t\t\tsprintf(buf2, \"%s\", buf1);\n\t\t}\n\t\tif (iscsi_update_param_value(param, buf2) < 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tsnprintf(buf1, sizeof(buf1), \"%s\", param->value);\n\t\tnone = strstr(buf1, NONE);\n\t\tif (none)\n\t\t\tgoto out;\n\t\tstrlcat(buf1, \",\" NONE, sizeof(buf1));\n\t\tif (iscsi_update_param_value(param, buf1) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\nout:\n\ta->authentication = authentication;\n\tpr_debug(\"%s iSCSI Authentication Methods for TPG: %hu.\\n\",\n\t\ta->authentication ? \"Enforcing\" : \"Disabling\", tpg->tpgt);\n\n\treturn 0;\n}\n\nint iscsit_ta_login_timeout(\n\tstruct iscsi_portal_group *tpg,\n\tu32 login_timeout)\n{\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\tif (login_timeout > TA_LOGIN_TIMEOUT_MAX) {\n\t\tpr_err(\"Requested Login Timeout %u larger than maximum\"\n\t\t\t\" %u\\n\", login_timeout, TA_LOGIN_TIMEOUT_MAX);\n\t\treturn -EINVAL;\n\t} else if (login_timeout < TA_LOGIN_TIMEOUT_MIN) {\n\t\tpr_err(\"Requested Logout Timeout %u smaller than\"\n\t\t\t\" minimum %u\\n\", login_timeout, TA_LOGIN_TIMEOUT_MIN);\n\t\treturn -EINVAL;\n\t}\n\n\ta->login_timeout = login_timeout;\n\tpr_debug(\"Set Logout Timeout to %u for Target Portal Group\"\n\t\t\" %hu\\n\", a->login_timeout, tpg->tpgt);\n\n\treturn 0;\n}\n\nint iscsit_ta_generate_node_acls(\n\tstruct iscsi_portal_group *tpg,\n\tu32 flag)\n{\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\tif ((flag != 0) && (flag != 1)) {\n\t\tpr_err(\"Illegal value %d\\n\", flag);\n\t\treturn -EINVAL;\n\t}\n\n\ta->generate_node_acls = flag;\n\tpr_debug(\"iSCSI_TPG[%hu] - Generate Initiator Portal Group ACLs: %s\\n\",\n\t\ttpg->tpgt, (a->generate_node_acls) ? \"Enabled\" : \"Disabled\");\n\n\tif (flag == 1 && a->cache_dynamic_acls == 0) {\n\t\tpr_debug(\"Explicitly setting cache_dynamic_acls=1 when \"\n\t\t\t\"generate_node_acls=1\\n\");\n\t\ta->cache_dynamic_acls = 1;\n\t}\n\n\treturn 0;\n}\n\nint iscsit_ta_default_cmdsn_depth(\n\tstruct iscsi_portal_group *tpg,\n\tu32 tcq_depth)\n{\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\tif (tcq_depth > TA_DEFAULT_CMDSN_DEPTH_MAX) {\n\t\tpr_err(\"Requested Default Queue Depth: %u larger\"\n\t\t\t\" than maximum %u\\n\", tcq_depth,\n\t\t\t\tTA_DEFAULT_CMDSN_DEPTH_MAX);\n\t\treturn -EINVAL;\n\t} else if (tcq_depth < TA_DEFAULT_CMDSN_DEPTH_MIN) {\n\t\tpr_err(\"Requested Default Queue Depth: %u smaller\"\n\t\t\t\" than minimum %u\\n\", tcq_depth,\n\t\t\t\tTA_DEFAULT_CMDSN_DEPTH_MIN);\n\t\treturn -EINVAL;\n\t}\n\n\ta->default_cmdsn_depth = tcq_depth;\n\tpr_debug(\"iSCSI_TPG[%hu] - Set Default CmdSN TCQ Depth to %u\\n\",\n\t\ttpg->tpgt, a->default_cmdsn_depth);\n\n\treturn 0;\n}\n\nint iscsit_ta_cache_dynamic_acls(\n\tstruct iscsi_portal_group *tpg,\n\tu32 flag)\n{\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\tif ((flag != 0) && (flag != 1)) {\n\t\tpr_err(\"Illegal value %d\\n\", flag);\n\t\treturn -EINVAL;\n\t}\n\n\tif (a->generate_node_acls == 1 && flag == 0) {\n\t\tpr_debug(\"Skipping cache_dynamic_acls=0 when\"\n\t\t\t\" generate_node_acls=1\\n\");\n\t\treturn 0;\n\t}\n\n\ta->cache_dynamic_acls = flag;\n\tpr_debug(\"iSCSI_TPG[%hu] - Cache Dynamic Initiator Portal Group\"\n\t\t\" ACLs %s\\n\", tpg->tpgt, (a->cache_dynamic_acls) ?\n\t\t\"Enabled\" : \"Disabled\");\n\n\treturn 0;\n}\n\nint iscsit_ta_demo_mode_write_protect(\n\tstruct iscsi_portal_group *tpg,\n\tu32 flag)\n{\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\tif ((flag != 0) && (flag != 1)) {\n\t\tpr_err(\"Illegal value %d\\n\", flag);\n\t\treturn -EINVAL;\n\t}\n\n\ta->demo_mode_write_protect = flag;\n\tpr_debug(\"iSCSI_TPG[%hu] - Demo Mode Write Protect bit: %s\\n\",\n\t\ttpg->tpgt, (a->demo_mode_write_protect) ? \"ON\" : \"OFF\");\n\n\treturn 0;\n}\n\nint iscsit_ta_prod_mode_write_protect(\n\tstruct iscsi_portal_group *tpg,\n\tu32 flag)\n{\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\tif ((flag != 0) && (flag != 1)) {\n\t\tpr_err(\"Illegal value %d\\n\", flag);\n\t\treturn -EINVAL;\n\t}\n\n\ta->prod_mode_write_protect = flag;\n\tpr_debug(\"iSCSI_TPG[%hu] - Production Mode Write Protect bit:\"\n\t\t\" %s\\n\", tpg->tpgt, (a->prod_mode_write_protect) ?\n\t\t\"ON\" : \"OFF\");\n\n\treturn 0;\n}\n\nint iscsit_ta_demo_mode_discovery(\n\tstruct iscsi_portal_group *tpg,\n\tu32 flag)\n{\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\tif ((flag != 0) && (flag != 1)) {\n\t\tpr_err(\"Illegal value %d\\n\", flag);\n\t\treturn -EINVAL;\n\t}\n\n\ta->demo_mode_discovery = flag;\n\tpr_debug(\"iSCSI_TPG[%hu] - Demo Mode Discovery bit:\"\n\t\t\" %s\\n\", tpg->tpgt, (a->demo_mode_discovery) ?\n\t\t\"ON\" : \"OFF\");\n\n\treturn 0;\n}\n\nint iscsit_ta_default_erl(\n\tstruct iscsi_portal_group *tpg,\n\tu32 default_erl)\n{\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\tif ((default_erl != 0) && (default_erl != 1) && (default_erl != 2)) {\n\t\tpr_err(\"Illegal value for default_erl: %u\\n\", default_erl);\n\t\treturn -EINVAL;\n\t}\n\n\ta->default_erl = default_erl;\n\tpr_debug(\"iSCSI_TPG[%hu] - DefaultERL: %u\\n\", tpg->tpgt, a->default_erl);\n\n\treturn 0;\n}\n\nint iscsit_ta_t10_pi(\n\tstruct iscsi_portal_group *tpg,\n\tu32 flag)\n{\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\tif ((flag != 0) && (flag != 1)) {\n\t\tpr_err(\"Illegal value %d\\n\", flag);\n\t\treturn -EINVAL;\n\t}\n\n\ta->t10_pi = flag;\n\tpr_debug(\"iSCSI_TPG[%hu] - T10 Protection information bit:\"\n\t\t\" %s\\n\", tpg->tpgt, (a->t10_pi) ?\n\t\t\"ON\" : \"OFF\");\n\n\treturn 0;\n}\n\nint iscsit_ta_fabric_prot_type(\n\tstruct iscsi_portal_group *tpg,\n\tu32 prot_type)\n{\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\tif ((prot_type != 0) && (prot_type != 1) && (prot_type != 3)) {\n\t\tpr_err(\"Illegal value for fabric_prot_type: %u\\n\", prot_type);\n\t\treturn -EINVAL;\n\t}\n\n\ta->fabric_prot_type = prot_type;\n\tpr_debug(\"iSCSI_TPG[%hu] - T10 Fabric Protection Type: %u\\n\",\n\t\t tpg->tpgt, prot_type);\n\n\treturn 0;\n}\n\nint iscsit_ta_tpg_enabled_sendtargets(\n\tstruct iscsi_portal_group *tpg,\n\tu32 flag)\n{\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\tif ((flag != 0) && (flag != 1)) {\n\t\tpr_err(\"Illegal value %d\\n\", flag);\n\t\treturn -EINVAL;\n\t}\n\n\ta->tpg_enabled_sendtargets = flag;\n\tpr_debug(\"iSCSI_TPG[%hu] - TPG enabled bit required for SendTargets:\"\n\t\t\" %s\\n\", tpg->tpgt, (a->tpg_enabled_sendtargets) ? \"ON\" : \"OFF\");\n\n\treturn 0;\n}\n\nint iscsit_ta_login_keys_workaround(\n\tstruct iscsi_portal_group *tpg,\n\tu32 flag)\n{\n\tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\n\n\tif ((flag != 0) && (flag != 1)) {\n\t\tpr_err(\"Illegal value %d\\n\", flag);\n\t\treturn -EINVAL;\n\t}\n\n\ta->login_keys_workaround = flag;\n\tpr_debug(\"iSCSI_TPG[%hu] - TPG enabled bit for login keys workaround: %s \",\n\t\ttpg->tpgt, (a->login_keys_workaround) ? \"ON\" : \"OFF\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}