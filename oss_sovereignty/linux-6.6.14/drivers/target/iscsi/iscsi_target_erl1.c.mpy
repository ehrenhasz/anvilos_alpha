{
  "module_name": "iscsi_target_erl1.c",
  "hash_id": "359c53ca60af9a683a6241ea720ca9bb467ddfbabd0bbd56cf0613d2e5366f97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target_erl1.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <scsi/iscsi_proto.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n#include <target/iscsi/iscsi_transport.h>\n\n#include <target/iscsi/iscsi_target_core.h>\n#include \"iscsi_target_seq_pdu_list.h\"\n#include \"iscsi_target_datain_values.h\"\n#include \"iscsi_target_device.h\"\n#include \"iscsi_target_tpg.h\"\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target_erl0.h\"\n#include \"iscsi_target_erl1.h\"\n#include \"iscsi_target_erl2.h\"\n#include \"iscsi_target.h\"\n\n#define OFFLOAD_BUF_SIZE\t32768U\n\n \nint iscsit_dump_data_payload(\n\tstruct iscsit_conn *conn,\n\tu32 buf_len,\n\tint dump_padding_digest)\n{\n\tchar *buf;\n\tint ret = DATAOUT_WITHIN_COMMAND_RECOVERY, rx_got;\n\tu32 length, offset = 0, size;\n\tstruct kvec iov;\n\n\tif (conn->sess->sess_ops->RDMAExtensions)\n\t\treturn 0;\n\n\tif (dump_padding_digest) {\n\t\tbuf_len = ALIGN(buf_len, 4);\n\t\tif (conn->conn_ops->DataDigest)\n\t\t\tbuf_len += ISCSI_CRC_LEN;\n\t}\n\n\tlength = min(buf_len, OFFLOAD_BUF_SIZE);\n\n\tbuf = kzalloc(length, GFP_ATOMIC);\n\tif (!buf) {\n\t\tpr_err(\"Unable to allocate %u bytes for offload\"\n\t\t\t\t\" buffer.\\n\", length);\n\t\treturn -1;\n\t}\n\tmemset(&iov, 0, sizeof(struct kvec));\n\n\twhile (offset < buf_len) {\n\t\tsize = min(buf_len - offset, length);\n\n\t\tiov.iov_len = size;\n\t\tiov.iov_base = buf;\n\n\t\trx_got = rx_data(conn, &iov, 1, size);\n\t\tif (rx_got != size) {\n\t\t\tret = DATAOUT_CANNOT_RECOVER;\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += size;\n\t}\n\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic int iscsit_send_recovery_r2t_for_snack(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsi_r2t *r2t)\n{\n\t \n\tspin_lock_bh(&cmd->r2t_lock);\n\tif (!r2t->sent_r2t) {\n\t\tspin_unlock_bh(&cmd->r2t_lock);\n\t\treturn 0;\n\t}\n\tr2t->sent_r2t = 0;\n\tspin_unlock_bh(&cmd->r2t_lock);\n\n\tiscsit_add_cmd_to_immediate_queue(cmd, cmd->conn, ISTATE_SEND_R2T);\n\n\treturn 0;\n}\n\nstatic int iscsit_handle_r2t_snack(\n\tstruct iscsit_cmd *cmd,\n\tunsigned char *buf,\n\tu32 begrun,\n\tu32 runlength)\n{\n\tu32 last_r2tsn;\n\tstruct iscsi_r2t *r2t;\n\n\t \n\tif ((cmd->cmd_flags & ICF_GOT_DATACK_SNACK) &&\n\t    (begrun <= cmd->acked_data_sn)) {\n\t\tpr_err(\"ITT: 0x%08x, R2T SNACK requesting\"\n\t\t\t\" retransmission of R2TSN: 0x%08x to 0x%08x but already\"\n\t\t\t\" acked to  R2TSN: 0x%08x by TMR TASK_REASSIGN,\"\n\t\t\t\" protocol error.\\n\", cmd->init_task_tag, begrun,\n\t\t\t(begrun + runlength), cmd->acked_data_sn);\n\n\t\treturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR, buf);\n\t}\n\n\tif (runlength) {\n\t\tif ((begrun + runlength) > cmd->r2t_sn) {\n\t\t\tpr_err(\"Command ITT: 0x%08x received R2T SNACK\"\n\t\t\t\" with BegRun: 0x%08x, RunLength: 0x%08x, exceeds\"\n\t\t\t\" current R2TSN: 0x%08x, protocol error.\\n\",\n\t\t\tcmd->init_task_tag, begrun, runlength, cmd->r2t_sn);\n\t\t\treturn iscsit_reject_cmd(cmd,\n\t\t\t\t\tISCSI_REASON_BOOKMARK_INVALID, buf);\n\t\t}\n\t\tlast_r2tsn = (begrun + runlength);\n\t} else\n\t\tlast_r2tsn = cmd->r2t_sn;\n\n\twhile (begrun < last_r2tsn) {\n\t\tr2t = iscsit_get_holder_for_r2tsn(cmd, begrun);\n\t\tif (!r2t)\n\t\t\treturn -1;\n\t\tif (iscsit_send_recovery_r2t_for_snack(cmd, r2t) < 0)\n\t\t\treturn -1;\n\n\t\tbegrun++;\n\t}\n\n\treturn 0;\n}\n\n \nint iscsit_create_recovery_datain_values_datasequenceinorder_yes(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsi_datain_req *dr)\n{\n\tu32 data_sn = 0, data_sn_count = 0;\n\tu32 pdu_start = 0, seq_no = 0;\n\tu32 begrun = dr->begrun;\n\tstruct iscsit_conn *conn = cmd->conn;\n\n\twhile (begrun > data_sn++) {\n\t\tdata_sn_count++;\n\t\tif ((dr->next_burst_len +\n\t\t     conn->conn_ops->MaxRecvDataSegmentLength) <\n\t\t     conn->sess->sess_ops->MaxBurstLength) {\n\t\t\tdr->read_data_done +=\n\t\t\t\tconn->conn_ops->MaxRecvDataSegmentLength;\n\t\t\tdr->next_burst_len +=\n\t\t\t\tconn->conn_ops->MaxRecvDataSegmentLength;\n\t\t} else {\n\t\t\tdr->read_data_done +=\n\t\t\t\t(conn->sess->sess_ops->MaxBurstLength -\n\t\t\t\t dr->next_burst_len);\n\t\t\tdr->next_burst_len = 0;\n\t\t\tpdu_start += data_sn_count;\n\t\t\tdata_sn_count = 0;\n\t\t\tseq_no++;\n\t\t}\n\t}\n\n\tif (!conn->sess->sess_ops->DataPDUInOrder) {\n\t\tcmd->seq_no = seq_no;\n\t\tcmd->pdu_start = pdu_start;\n\t\tcmd->pdu_send_order = data_sn_count;\n\t}\n\n\treturn 0;\n}\n\n \nint iscsit_create_recovery_datain_values_datasequenceinorder_no(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsi_datain_req *dr)\n{\n\tint found_seq = 0, i;\n\tu32 data_sn, read_data_done = 0, seq_send_order = 0;\n\tu32 begrun = dr->begrun;\n\tu32 runlength = dr->runlength;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_seq *first_seq = NULL, *seq = NULL;\n\n\tif (!cmd->seq_list) {\n\t\tpr_err(\"struct iscsit_cmd->seq_list is NULL!\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tfor (i = 0; i < cmd->seq_count; i++) {\n\t\tseq = &cmd->seq_list[i];\n\n\t\tif (!seq->seq_send_order)\n\t\t\tfirst_seq = seq;\n\n\t\t \n\t\tif (!seq->sent) {\n\t\t\tpr_err(\"Ignoring non-sent sequence 0x%08x ->\"\n\t\t\t\t\" 0x%08x\\n\\n\", seq->first_datasn,\n\t\t\t\tseq->last_datasn);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((seq->first_datasn < begrun) &&\n\t\t\t\t(seq->last_datasn < begrun)) {\n\t\t\tpr_err(\"Pre BegRun sequence 0x%08x ->\"\n\t\t\t\t\" 0x%08x\\n\", seq->first_datasn,\n\t\t\t\tseq->last_datasn);\n\n\t\t\tread_data_done += cmd->seq_list[i].xfer_len;\n\t\t\tseq->next_burst_len = seq->pdu_send_order = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((seq->first_datasn <= begrun) &&\n\t\t\t\t(seq->last_datasn >= begrun)) {\n\t\t\tpr_err(\"Found sequence begrun: 0x%08x in\"\n\t\t\t\t\" 0x%08x -> 0x%08x\\n\", begrun,\n\t\t\t\tseq->first_datasn, seq->last_datasn);\n\n\t\t\tseq_send_order = seq->seq_send_order;\n\t\t\tdata_sn = seq->first_datasn;\n\t\t\tseq->next_burst_len = seq->pdu_send_order = 0;\n\t\t\tfound_seq = 1;\n\n\t\t\t \n\t\t\tif (conn->sess->sess_ops->DataPDUInOrder) {\n\t\t\t\twhile (data_sn < begrun) {\n\t\t\t\t\tseq->pdu_send_order++;\n\t\t\t\t\tread_data_done +=\n\t\t\t\t\t\tconn->conn_ops->MaxRecvDataSegmentLength;\n\t\t\t\t\tseq->next_burst_len +=\n\t\t\t\t\t\tconn->conn_ops->MaxRecvDataSegmentLength;\n\t\t\t\t\tdata_sn++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint j;\n\t\t\t\tstruct iscsi_pdu *pdu;\n\n\t\t\t\twhile (data_sn < begrun) {\n\t\t\t\t\tseq->pdu_send_order++;\n\n\t\t\t\t\tfor (j = 0; j < seq->pdu_count; j++) {\n\t\t\t\t\t\tpdu = &cmd->pdu_list[\n\t\t\t\t\t\t\tseq->pdu_start + j];\n\t\t\t\t\t\tif (pdu->data_sn == data_sn) {\n\t\t\t\t\t\t\tread_data_done +=\n\t\t\t\t\t\t\t\tpdu->length;\n\t\t\t\t\t\t\tseq->next_burst_len +=\n\t\t\t\t\t\t\t\tpdu->length;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata_sn++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((seq->first_datasn > begrun) ||\n\t\t\t\t(seq->last_datasn > begrun)) {\n\t\t\tpr_err(\"Post BegRun sequence 0x%08x -> 0x%08x\\n\",\n\t\t\t\t\tseq->first_datasn, seq->last_datasn);\n\n\t\t\tseq->next_burst_len = seq->pdu_send_order = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!found_seq) {\n\t\tif (!begrun) {\n\t\t\tif (!first_seq) {\n\t\t\t\tpr_err(\"ITT: 0x%08x, Begrun: 0x%08x\"\n\t\t\t\t\t\" but first_seq is NULL\\n\",\n\t\t\t\t\tcmd->init_task_tag, begrun);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tseq_send_order = first_seq->seq_send_order;\n\t\t\tseq->next_burst_len = seq->pdu_send_order = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\tpr_err(\"Unable to locate struct iscsi_seq for ITT: 0x%08x,\"\n\t\t\t\" BegRun: 0x%08x, RunLength: 0x%08x while\"\n\t\t\t\" DataSequenceInOrder=No and DataPDUInOrder=%s.\\n\",\n\t\t\t\tcmd->init_task_tag, begrun, runlength,\n\t\t\t(conn->sess->sess_ops->DataPDUInOrder) ? \"Yes\" : \"No\");\n\t\treturn -1;\n\t}\n\ndone:\n\tdr->read_data_done = read_data_done;\n\tdr->seq_send_order = seq_send_order;\n\n\treturn 0;\n}\n\nstatic int iscsit_handle_recovery_datain(\n\tstruct iscsit_cmd *cmd,\n\tunsigned char *buf,\n\tu32 begrun,\n\tu32 runlength)\n{\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_datain_req *dr;\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\n\tif (!(se_cmd->transport_state & CMD_T_COMPLETE)) {\n\t\tpr_err(\"Ignoring ITT: 0x%08x Data SNACK\\n\",\n\t\t\t\tcmd->init_task_tag);\n\t\treturn 0;\n\t}\n\n\t \n\tif ((cmd->cmd_flags & ICF_GOT_DATACK_SNACK) &&\n\t    (begrun <= cmd->acked_data_sn)) {\n\t\tpr_err(\"ITT: 0x%08x, Data SNACK requesting\"\n\t\t\t\" retransmission of DataSN: 0x%08x to 0x%08x but\"\n\t\t\t\" already acked to DataSN: 0x%08x by Data ACK SNACK,\"\n\t\t\t\" protocol error.\\n\", cmd->init_task_tag, begrun,\n\t\t\t(begrun + runlength), cmd->acked_data_sn);\n\n\t\treturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR, buf);\n\t}\n\n\t \n\tif ((begrun + runlength) > (cmd->data_sn - 1)) {\n\t\tpr_err(\"Initiator requesting BegRun: 0x%08x, RunLength\"\n\t\t\t\": 0x%08x greater than maximum DataSN: 0x%08x.\\n\",\n\t\t\t\tbegrun, runlength, (cmd->data_sn - 1));\n\t\treturn iscsit_reject_cmd(cmd, ISCSI_REASON_BOOKMARK_INVALID,\n\t\t\t\t\t buf);\n\t}\n\n\tdr = iscsit_allocate_datain_req();\n\tif (!dr)\n\t\treturn iscsit_reject_cmd(cmd, ISCSI_REASON_BOOKMARK_NO_RESOURCES,\n\t\t\t\t\t buf);\n\n\tdr->data_sn = dr->begrun = begrun;\n\tdr->runlength = runlength;\n\tdr->generate_recovery_values = 1;\n\tdr->recovery = DATAIN_WITHIN_COMMAND_RECOVERY;\n\n\tiscsit_attach_datain_req(cmd, dr);\n\n\tcmd->i_state = ISTATE_SEND_DATAIN;\n\tiscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\n\n\treturn 0;\n}\n\nint iscsit_handle_recovery_datain_or_r2t(\n\tstruct iscsit_conn *conn,\n\tunsigned char *buf,\n\titt_t init_task_tag,\n\tu32 targ_xfer_tag,\n\tu32 begrun,\n\tu32 runlength)\n{\n\tstruct iscsit_cmd *cmd;\n\n\tcmd = iscsit_find_cmd_from_itt(conn, init_task_tag);\n\tif (!cmd)\n\t\treturn 0;\n\n\t \n\tswitch (cmd->data_direction) {\n\tcase DMA_TO_DEVICE:\n\t\treturn iscsit_handle_r2t_snack(cmd, buf, begrun, runlength);\n\tcase DMA_FROM_DEVICE:\n\t\treturn iscsit_handle_recovery_datain(cmd, buf, begrun,\n\t\t\t\trunlength);\n\tdefault:\n\t\tpr_err(\"Unknown cmd->data_direction: 0x%02x\\n\",\n\t\t\t\tcmd->data_direction);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nint iscsit_handle_status_snack(\n\tstruct iscsit_conn *conn,\n\titt_t init_task_tag,\n\tu32 targ_xfer_tag,\n\tu32 begrun,\n\tu32 runlength)\n{\n\tstruct iscsit_cmd *cmd = NULL;\n\tu32 last_statsn;\n\tint found_cmd;\n\n\tif (!begrun) {\n\t\tbegrun = conn->exp_statsn;\n\t} else if (conn->exp_statsn > begrun) {\n\t\tpr_err(\"Got Status SNACK Begrun: 0x%08x, RunLength:\"\n\t\t\t\" 0x%08x but already got ExpStatSN: 0x%08x on CID:\"\n\t\t\t\" %hu.\\n\", begrun, runlength, conn->exp_statsn,\n\t\t\tconn->cid);\n\t\treturn 0;\n\t}\n\n\tlast_statsn = (!runlength) ? conn->stat_sn : (begrun + runlength);\n\n\twhile (begrun < last_statsn) {\n\t\tfound_cmd = 0;\n\n\t\tspin_lock_bh(&conn->cmd_lock);\n\t\tlist_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {\n\t\t\tif (cmd->stat_sn == begrun) {\n\t\t\t\tfound_cmd = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&conn->cmd_lock);\n\n\t\tif (!found_cmd) {\n\t\t\tpr_err(\"Unable to find StatSN: 0x%08x for\"\n\t\t\t\t\" a Status SNACK, assuming this was a\"\n\t\t\t\t\" protactic SNACK for an untransmitted\"\n\t\t\t\t\" StatSN, ignoring.\\n\", begrun);\n\t\t\tbegrun++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_lock_bh(&cmd->istate_lock);\n\t\tif (cmd->i_state == ISTATE_SEND_DATAIN) {\n\t\t\tspin_unlock_bh(&cmd->istate_lock);\n\t\t\tpr_err(\"Ignoring Status SNACK for BegRun:\"\n\t\t\t\t\" 0x%08x, RunLength: 0x%08x, assuming this was\"\n\t\t\t\t\" a protactic SNACK for an untransmitted\"\n\t\t\t\t\" StatSN\\n\", begrun, runlength);\n\t\t\tbegrun++;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock_bh(&cmd->istate_lock);\n\n\t\tcmd->i_state = ISTATE_SEND_STATUS_RECOVERY;\n\t\tiscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\n\t\tbegrun++;\n\t}\n\n\treturn 0;\n}\n\nint iscsit_handle_data_ack(\n\tstruct iscsit_conn *conn,\n\tu32 targ_xfer_tag,\n\tu32 begrun,\n\tu32 runlength)\n{\n\tstruct iscsit_cmd *cmd = NULL;\n\n\tcmd = iscsit_find_cmd_from_ttt(conn, targ_xfer_tag);\n\tif (!cmd) {\n\t\tpr_err(\"Data ACK SNACK for TTT: 0x%08x is\"\n\t\t\t\" invalid.\\n\", targ_xfer_tag);\n\t\treturn -1;\n\t}\n\n\tif (begrun <= cmd->acked_data_sn) {\n\t\tpr_err(\"ITT: 0x%08x Data ACK SNACK BegRUN: 0x%08x is\"\n\t\t\t\" less than the already acked DataSN: 0x%08x.\\n\",\n\t\t\tcmd->init_task_tag, begrun, cmd->acked_data_sn);\n\t\treturn -1;\n\t}\n\n\t \n\tcmd->cmd_flags |= ICF_GOT_DATACK_SNACK;\n\tcmd->acked_data_sn = (begrun - 1);\n\n\tpr_debug(\"Received Data ACK SNACK for ITT: 0x%08x,\"\n\t\t\" updated acked DataSN to 0x%08x.\\n\",\n\t\t\tcmd->init_task_tag, cmd->acked_data_sn);\n\n\treturn 0;\n}\n\nstatic int iscsit_send_recovery_r2t(\n\tstruct iscsit_cmd *cmd,\n\tu32 offset,\n\tu32 xfer_len)\n{\n\tint ret;\n\n\tspin_lock_bh(&cmd->r2t_lock);\n\tret = iscsit_add_r2t_to_list(cmd, offset, xfer_len, 1, 0);\n\tspin_unlock_bh(&cmd->r2t_lock);\n\n\treturn ret;\n}\n\nint iscsit_dataout_datapduinorder_no_fbit(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsi_pdu *pdu)\n{\n\tint i, send_recovery_r2t = 0, recovery = 0;\n\tu32 length = 0, offset = 0, pdu_count = 0, xfer_len = 0;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_pdu *first_pdu = NULL;\n\n\t \n\tif (conn->sess->sess_ops->DataSequenceInOrder) {\n\t\tfor (i = 0; i < cmd->pdu_count; i++) {\n\t\t\tif (cmd->pdu_list[i].seq_no == pdu->seq_no) {\n\t\t\t\tif (!first_pdu)\n\t\t\t\t\tfirst_pdu = &cmd->pdu_list[i];\n\t\t\t\txfer_len += cmd->pdu_list[i].length;\n\t\t\t\tpdu_count++;\n\t\t\t} else if (pdu_count)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tstruct iscsi_seq *seq = cmd->seq_ptr;\n\n\t\tfirst_pdu = &cmd->pdu_list[seq->pdu_start];\n\t\tpdu_count = seq->pdu_count;\n\t}\n\n\tif (!first_pdu || !pdu_count)\n\t\treturn DATAOUT_CANNOT_RECOVER;\n\n\t \n\tfor (i = 0; i < pdu_count; i++) {\n\t\tif (first_pdu[i].status == ISCSI_PDU_RECEIVED_OK) {\n\t\t\tif (!send_recovery_r2t)\n\t\t\t\tcontinue;\n\n\t\t\tif (iscsit_send_recovery_r2t(cmd, offset, length) < 0)\n\t\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\n\t\t\tsend_recovery_r2t = length = offset = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\trecovery = 1;\n\n\t\tif (first_pdu[i].status != ISCSI_PDU_NOT_RECEIVED)\n\t\t\tcontinue;\n\n\t\tif (!offset)\n\t\t\toffset = first_pdu[i].offset;\n\t\tlength += first_pdu[i].length;\n\n\t\tsend_recovery_r2t = 1;\n\t}\n\n\tif (send_recovery_r2t)\n\t\tif (iscsit_send_recovery_r2t(cmd, offset, length) < 0)\n\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\n\treturn (!recovery) ? DATAOUT_NORMAL : DATAOUT_WITHIN_COMMAND_RECOVERY;\n}\n\nstatic int iscsit_recalculate_dataout_values(\n\tstruct iscsit_cmd *cmd,\n\tu32 pdu_offset,\n\tu32 pdu_length,\n\tu32 *r2t_offset,\n\tu32 *r2t_length)\n{\n\tint i;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_pdu *pdu = NULL;\n\n\tif (conn->sess->sess_ops->DataSequenceInOrder) {\n\t\tcmd->data_sn = 0;\n\n\t\tif (conn->sess->sess_ops->DataPDUInOrder) {\n\t\t\t*r2t_offset = cmd->write_data_done;\n\t\t\t*r2t_length = (cmd->seq_end_offset -\n\t\t\t\t\tcmd->write_data_done);\n\t\t\treturn 0;\n\t\t}\n\n\t\t*r2t_offset = cmd->seq_start_offset;\n\t\t*r2t_length = (cmd->seq_end_offset - cmd->seq_start_offset);\n\n\t\tfor (i = 0; i < cmd->pdu_count; i++) {\n\t\t\tpdu = &cmd->pdu_list[i];\n\n\t\t\tif (pdu->status != ISCSI_PDU_RECEIVED_OK)\n\t\t\t\tcontinue;\n\n\t\t\tif ((pdu->offset >= cmd->seq_start_offset) &&\n\t\t\t   ((pdu->offset + pdu->length) <=\n\t\t\t     cmd->seq_end_offset)) {\n\t\t\t\tif (!cmd->unsolicited_data)\n\t\t\t\t\tcmd->next_burst_len -= pdu->length;\n\t\t\t\telse\n\t\t\t\t\tcmd->first_burst_len -= pdu->length;\n\n\t\t\t\tcmd->write_data_done -= pdu->length;\n\t\t\t\tpdu->status = ISCSI_PDU_NOT_RECEIVED;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct iscsi_seq *seq = NULL;\n\n\t\tseq = iscsit_get_seq_holder(cmd, pdu_offset, pdu_length);\n\t\tif (!seq)\n\t\t\treturn -1;\n\n\t\t*r2t_offset = seq->orig_offset;\n\t\t*r2t_length = seq->xfer_len;\n\n\t\tcmd->write_data_done -= (seq->offset - seq->orig_offset);\n\t\tif (cmd->immediate_data)\n\t\t\tcmd->first_burst_len = cmd->write_data_done;\n\n\t\tseq->data_sn = 0;\n\t\tseq->offset = seq->orig_offset;\n\t\tseq->next_burst_len = 0;\n\t\tseq->status = DATAOUT_SEQUENCE_WITHIN_COMMAND_RECOVERY;\n\n\t\tif (conn->sess->sess_ops->DataPDUInOrder)\n\t\t\treturn 0;\n\n\t\tfor (i = 0; i < seq->pdu_count; i++) {\n\t\t\tpdu = &cmd->pdu_list[i+seq->pdu_start];\n\n\t\t\tif (pdu->status != ISCSI_PDU_RECEIVED_OK)\n\t\t\t\tcontinue;\n\n\t\t\tpdu->status = ISCSI_PDU_NOT_RECEIVED;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint iscsit_recover_dataout_sequence(\n\tstruct iscsit_cmd *cmd,\n\tu32 pdu_offset,\n\tu32 pdu_length)\n{\n\tu32 r2t_length = 0, r2t_offset = 0;\n\n\tspin_lock_bh(&cmd->istate_lock);\n\tcmd->cmd_flags |= ICF_WITHIN_COMMAND_RECOVERY;\n\tspin_unlock_bh(&cmd->istate_lock);\n\n\tif (iscsit_recalculate_dataout_values(cmd, pdu_offset, pdu_length,\n\t\t\t&r2t_offset, &r2t_length) < 0)\n\t\treturn DATAOUT_CANNOT_RECOVER;\n\n\tiscsit_send_recovery_r2t(cmd, r2t_offset, r2t_length);\n\n\treturn DATAOUT_WITHIN_COMMAND_RECOVERY;\n}\n\nstatic struct iscsi_ooo_cmdsn *iscsit_allocate_ooo_cmdsn(void)\n{\n\tstruct iscsi_ooo_cmdsn *ooo_cmdsn = NULL;\n\n\tooo_cmdsn = kmem_cache_zalloc(lio_ooo_cache, GFP_ATOMIC);\n\tif (!ooo_cmdsn) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_ooo_cmdsn.\\n\");\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&ooo_cmdsn->ooo_list);\n\n\treturn ooo_cmdsn;\n}\n\nstatic int iscsit_attach_ooo_cmdsn(\n\tstruct iscsit_session *sess,\n\tstruct iscsi_ooo_cmdsn *ooo_cmdsn)\n{\n\tstruct iscsi_ooo_cmdsn *ooo_tail, *ooo_tmp;\n\n\tlockdep_assert_held(&sess->cmdsn_mutex);\n\n\t \n\tif (list_empty(&sess->sess_ooo_cmdsn_list))\n\t\tlist_add_tail(&ooo_cmdsn->ooo_list,\n\t\t\t\t&sess->sess_ooo_cmdsn_list);\n\telse {\n\t\tooo_tail = list_entry(sess->sess_ooo_cmdsn_list.prev,\n\t\t\t\ttypeof(*ooo_tail), ooo_list);\n\t\t \n\t\tif (iscsi_sna_lt(ooo_tail->cmdsn, ooo_cmdsn->cmdsn))\n\t\t\tlist_add_tail(&ooo_cmdsn->ooo_list,\n\t\t\t\t\t&sess->sess_ooo_cmdsn_list);\n\t\telse {\n\t\t\t \n\t\t\tlist_for_each_entry(ooo_tmp, &sess->sess_ooo_cmdsn_list,\n\t\t\t\t\t\tooo_list) {\n\t\t\t\tif (iscsi_sna_lt(ooo_tmp->cmdsn, ooo_cmdsn->cmdsn))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tlist_add(&ooo_cmdsn->ooo_list,\n\t\t\t\t\tooo_tmp->ooo_list.prev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nvoid iscsit_remove_ooo_cmdsn(\n\tstruct iscsit_session *sess,\n\tstruct iscsi_ooo_cmdsn *ooo_cmdsn)\n{\n\tlist_del(&ooo_cmdsn->ooo_list);\n\tkmem_cache_free(lio_ooo_cache, ooo_cmdsn);\n}\n\nvoid iscsit_clear_ooo_cmdsns_for_conn(struct iscsit_conn *conn)\n{\n\tstruct iscsi_ooo_cmdsn *ooo_cmdsn;\n\tstruct iscsit_session *sess = conn->sess;\n\n\tmutex_lock(&sess->cmdsn_mutex);\n\tlist_for_each_entry(ooo_cmdsn, &sess->sess_ooo_cmdsn_list, ooo_list) {\n\t\tif (ooo_cmdsn->cid != conn->cid)\n\t\t\tcontinue;\n\n\t\tooo_cmdsn->cmd = NULL;\n\t}\n\tmutex_unlock(&sess->cmdsn_mutex);\n}\n\nint iscsit_execute_ooo_cmdsns(struct iscsit_session *sess)\n{\n\tint ooo_count = 0;\n\tstruct iscsit_cmd *cmd = NULL;\n\tstruct iscsi_ooo_cmdsn *ooo_cmdsn, *ooo_cmdsn_tmp;\n\n\tlockdep_assert_held(&sess->cmdsn_mutex);\n\n\tlist_for_each_entry_safe(ooo_cmdsn, ooo_cmdsn_tmp,\n\t\t\t\t&sess->sess_ooo_cmdsn_list, ooo_list) {\n\t\tif (ooo_cmdsn->cmdsn != sess->exp_cmd_sn)\n\t\t\tcontinue;\n\n\t\tif (!ooo_cmdsn->cmd) {\n\t\t\tsess->exp_cmd_sn++;\n\t\t\tiscsit_remove_ooo_cmdsn(sess, ooo_cmdsn);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmd = ooo_cmdsn->cmd;\n\t\tcmd->i_state = cmd->deferred_i_state;\n\t\tooo_count++;\n\t\tsess->exp_cmd_sn++;\n\t\tpr_debug(\"Executing out of order CmdSN: 0x%08x,\"\n\t\t\t\" incremented ExpCmdSN to 0x%08x.\\n\",\n\t\t\tcmd->cmd_sn, sess->exp_cmd_sn);\n\n\t\tiscsit_remove_ooo_cmdsn(sess, ooo_cmdsn);\n\n\t\tif (iscsit_execute_cmd(cmd, 1) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn ooo_count;\n}\n\n \nint iscsit_execute_cmd(struct iscsit_cmd *cmd, int ooo)\n{\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tint lr = 0;\n\n\tspin_lock_bh(&cmd->istate_lock);\n\tif (ooo)\n\t\tcmd->cmd_flags &= ~ICF_OOO_CMDSN;\n\n\tswitch (cmd->iscsi_opcode) {\n\tcase ISCSI_OP_SCSI_CMD:\n\t\t \n\t\tif (cmd->sense_reason) {\n\t\t\tif (cmd->sense_reason == TCM_RESERVATION_CONFLICT) {\n\t\t\t\tcmd->i_state = ISTATE_SEND_STATUS;\n\t\t\t\tspin_unlock_bh(&cmd->istate_lock);\n\t\t\t\tiscsit_add_cmd_to_response_queue(cmd, cmd->conn,\n\t\t\t\t\t\tcmd->i_state);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tspin_unlock_bh(&cmd->istate_lock);\n\t\t\tif (cmd->se_cmd.transport_state & CMD_T_ABORTED)\n\t\t\t\treturn 0;\n\t\t\treturn transport_send_check_condition_and_sense(se_cmd,\n\t\t\t\t\tcmd->sense_reason, 0);\n\t\t}\n\t\t \n\t\tif (cmd->immediate_data) {\n\t\t\tif (cmd->cmd_flags & ICF_GOT_LAST_DATAOUT) {\n\t\t\t\tspin_unlock_bh(&cmd->istate_lock);\n\t\t\t\ttarget_execute_cmd(&cmd->se_cmd);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tspin_unlock_bh(&cmd->istate_lock);\n\n\t\t\tif (!(cmd->cmd_flags &\n\t\t\t\t\tICF_NON_IMMEDIATE_UNSOLICITED_DATA)) {\n\t\t\t\tif (cmd->se_cmd.transport_state & CMD_T_ABORTED)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tiscsit_set_dataout_sequence_values(cmd);\n\t\t\t\tconn->conn_transport->iscsit_get_dataout(conn, cmd, false);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tspin_unlock_bh(&cmd->istate_lock);\n\n\t\tif ((cmd->data_direction == DMA_TO_DEVICE) &&\n\t\t    !(cmd->cmd_flags & ICF_NON_IMMEDIATE_UNSOLICITED_DATA)) {\n\t\t\tif (cmd->se_cmd.transport_state & CMD_T_ABORTED)\n\t\t\t\treturn 0;\n\n\t\t\tiscsit_set_unsolicited_dataout(cmd);\n\t\t}\n\t\treturn transport_handle_cdb_direct(&cmd->se_cmd);\n\n\tcase ISCSI_OP_NOOP_OUT:\n\tcase ISCSI_OP_TEXT:\n\t\tspin_unlock_bh(&cmd->istate_lock);\n\t\tiscsit_add_cmd_to_response_queue(cmd, cmd->conn, cmd->i_state);\n\t\tbreak;\n\tcase ISCSI_OP_SCSI_TMFUNC:\n\t\tif (cmd->se_cmd.se_tmr_req->response) {\n\t\t\tspin_unlock_bh(&cmd->istate_lock);\n\t\t\tiscsit_add_cmd_to_response_queue(cmd, cmd->conn,\n\t\t\t\t\tcmd->i_state);\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock_bh(&cmd->istate_lock);\n\n\t\treturn transport_generic_handle_tmr(&cmd->se_cmd);\n\tcase ISCSI_OP_LOGOUT:\n\t\tspin_unlock_bh(&cmd->istate_lock);\n\t\tswitch (cmd->logout_reason) {\n\t\tcase ISCSI_LOGOUT_REASON_CLOSE_SESSION:\n\t\t\tlr = iscsit_logout_closesession(cmd, cmd->conn);\n\t\t\tbreak;\n\t\tcase ISCSI_LOGOUT_REASON_CLOSE_CONNECTION:\n\t\t\tlr = iscsit_logout_closeconnection(cmd, cmd->conn);\n\t\t\tbreak;\n\t\tcase ISCSI_LOGOUT_REASON_RECOVERY:\n\t\t\tlr = iscsit_logout_removeconnforrecovery(cmd, cmd->conn);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unknown iSCSI Logout Request Code:\"\n\t\t\t\t\" 0x%02x\\n\", cmd->logout_reason);\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn lr;\n\tdefault:\n\t\tspin_unlock_bh(&cmd->istate_lock);\n\t\tpr_err(\"Cannot perform out of order execution for\"\n\t\t\" unknown iSCSI Opcode: 0x%02x\\n\", cmd->iscsi_opcode);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid iscsit_free_all_ooo_cmdsns(struct iscsit_session *sess)\n{\n\tstruct iscsi_ooo_cmdsn *ooo_cmdsn, *ooo_cmdsn_tmp;\n\n\tmutex_lock(&sess->cmdsn_mutex);\n\tlist_for_each_entry_safe(ooo_cmdsn, ooo_cmdsn_tmp,\n\t\t\t&sess->sess_ooo_cmdsn_list, ooo_list) {\n\n\t\tlist_del(&ooo_cmdsn->ooo_list);\n\t\tkmem_cache_free(lio_ooo_cache, ooo_cmdsn);\n\t}\n\tmutex_unlock(&sess->cmdsn_mutex);\n}\n\nint iscsit_handle_ooo_cmdsn(\n\tstruct iscsit_session *sess,\n\tstruct iscsit_cmd *cmd,\n\tu32 cmdsn)\n{\n\tint batch = 0;\n\tstruct iscsi_ooo_cmdsn *ooo_cmdsn = NULL, *ooo_tail = NULL;\n\n\tcmd->deferred_i_state\t\t= cmd->i_state;\n\tcmd->i_state\t\t\t= ISTATE_DEFERRED_CMD;\n\tcmd->cmd_flags\t\t\t|= ICF_OOO_CMDSN;\n\n\tif (list_empty(&sess->sess_ooo_cmdsn_list))\n\t\tbatch = 1;\n\telse {\n\t\tooo_tail = list_entry(sess->sess_ooo_cmdsn_list.prev,\n\t\t\t\ttypeof(*ooo_tail), ooo_list);\n\t\tif (ooo_tail->cmdsn != (cmdsn - 1))\n\t\t\tbatch = 1;\n\t}\n\n\tooo_cmdsn = iscsit_allocate_ooo_cmdsn();\n\tif (!ooo_cmdsn)\n\t\treturn -ENOMEM;\n\n\tooo_cmdsn->cmd\t\t\t= cmd;\n\tooo_cmdsn->batch_count\t\t= (batch) ?\n\t\t\t\t\t  (cmdsn - sess->exp_cmd_sn) : 1;\n\tooo_cmdsn->cid\t\t\t= cmd->conn->cid;\n\tooo_cmdsn->exp_cmdsn\t\t= sess->exp_cmd_sn;\n\tooo_cmdsn->cmdsn\t\t= cmdsn;\n\n\tif (iscsit_attach_ooo_cmdsn(sess, ooo_cmdsn) < 0) {\n\t\tkmem_cache_free(lio_ooo_cache, ooo_cmdsn);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsit_set_dataout_timeout_values(\n\tstruct iscsit_cmd *cmd,\n\tu32 *offset,\n\tu32 *length)\n{\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_r2t *r2t;\n\n\tif (cmd->unsolicited_data) {\n\t\t*offset = 0;\n\t\t*length = (conn->sess->sess_ops->FirstBurstLength >\n\t\t\t   cmd->se_cmd.data_length) ?\n\t\t\t   cmd->se_cmd.data_length :\n\t\t\t   conn->sess->sess_ops->FirstBurstLength;\n\t\treturn 0;\n\t}\n\n\tspin_lock_bh(&cmd->r2t_lock);\n\tif (list_empty(&cmd->cmd_r2t_list)) {\n\t\tpr_err(\"cmd->cmd_r2t_list is empty!\\n\");\n\t\tspin_unlock_bh(&cmd->r2t_lock);\n\t\treturn -1;\n\t}\n\n\tlist_for_each_entry(r2t, &cmd->cmd_r2t_list, r2t_list) {\n\t\tif (r2t->sent_r2t && !r2t->recovery_r2t && !r2t->seq_complete) {\n\t\t\t*offset = r2t->offset;\n\t\t\t*length = r2t->xfer_len;\n\t\t\tspin_unlock_bh(&cmd->r2t_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock_bh(&cmd->r2t_lock);\n\n\tpr_err(\"Unable to locate any incomplete DataOUT\"\n\t\t\" sequences for ITT: 0x%08x.\\n\", cmd->init_task_tag);\n\n\treturn -1;\n}\n\n \nvoid iscsit_handle_dataout_timeout(struct timer_list *t)\n{\n\tu32 pdu_length = 0, pdu_offset = 0;\n\tu32 r2t_length = 0, r2t_offset = 0;\n\tstruct iscsit_cmd *cmd = from_timer(cmd, t, dataout_timer);\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsit_session *sess = NULL;\n\tstruct iscsi_node_attrib *na;\n\n\tiscsit_inc_conn_usage_count(conn);\n\n\tspin_lock_bh(&cmd->dataout_timeout_lock);\n\tif (cmd->dataout_timer_flags & ISCSI_TF_STOP) {\n\t\tspin_unlock_bh(&cmd->dataout_timeout_lock);\n\t\tiscsit_dec_conn_usage_count(conn);\n\t\treturn;\n\t}\n\tcmd->dataout_timer_flags &= ~ISCSI_TF_RUNNING;\n\tsess = conn->sess;\n\tna = iscsit_tpg_get_node_attrib(sess);\n\n\tif (!sess->sess_ops->ErrorRecoveryLevel) {\n\t\tpr_err(\"Unable to recover from DataOut timeout while\"\n\t\t\t\" in ERL=0, closing iSCSI connection for I_T Nexus\"\n\t\t\t\" %s,i,0x%6phN,%s,t,0x%02x\\n\",\n\t\t\tsess->sess_ops->InitiatorName, sess->isid,\n\t\t\tsess->tpg->tpg_tiqn->tiqn, (u32)sess->tpg->tpgt);\n\t\tgoto failure;\n\t}\n\n\tif (++cmd->dataout_timeout_retries == na->dataout_timeout_retries) {\n\t\tpr_err(\"Command ITT: 0x%08x exceeded max retries\"\n\t\t\t\" for DataOUT timeout %u, closing iSCSI connection for\"\n\t\t\t\" I_T Nexus %s,i,0x%6phN,%s,t,0x%02x\\n\",\n\t\t\tcmd->init_task_tag, na->dataout_timeout_retries,\n\t\t\tsess->sess_ops->InitiatorName, sess->isid,\n\t\t\tsess->tpg->tpg_tiqn->tiqn, (u32)sess->tpg->tpgt);\n\t\tgoto failure;\n\t}\n\n\tcmd->cmd_flags |= ICF_WITHIN_COMMAND_RECOVERY;\n\n\tif (conn->sess->sess_ops->DataSequenceInOrder) {\n\t\tif (conn->sess->sess_ops->DataPDUInOrder) {\n\t\t\tpdu_offset = cmd->write_data_done;\n\t\t\tif ((pdu_offset + (conn->sess->sess_ops->MaxBurstLength -\n\t\t\t     cmd->next_burst_len)) > cmd->se_cmd.data_length)\n\t\t\t\tpdu_length = (cmd->se_cmd.data_length -\n\t\t\t\t\tcmd->write_data_done);\n\t\t\telse\n\t\t\t\tpdu_length = (conn->sess->sess_ops->MaxBurstLength -\n\t\t\t\t\t\tcmd->next_burst_len);\n\t\t} else {\n\t\t\tpdu_offset = cmd->seq_start_offset;\n\t\t\tpdu_length = (cmd->seq_end_offset -\n\t\t\t\tcmd->seq_start_offset);\n\t\t}\n\t} else {\n\t\tif (iscsit_set_dataout_timeout_values(cmd, &pdu_offset,\n\t\t\t\t&pdu_length) < 0)\n\t\t\tgoto failure;\n\t}\n\n\tif (iscsit_recalculate_dataout_values(cmd, pdu_offset, pdu_length,\n\t\t\t&r2t_offset, &r2t_length) < 0)\n\t\tgoto failure;\n\n\tpr_debug(\"Command ITT: 0x%08x timed out waiting for\"\n\t\t\" completion of %sDataOUT Sequence Offset: %u, Length: %u\\n\",\n\t\tcmd->init_task_tag, (cmd->unsolicited_data) ? \"Unsolicited \" :\n\t\t\"\", r2t_offset, r2t_length);\n\n\tif (iscsit_send_recovery_r2t(cmd, r2t_offset, r2t_length) < 0)\n\t\tgoto failure;\n\n\tiscsit_start_dataout_timer(cmd, conn);\n\tspin_unlock_bh(&cmd->dataout_timeout_lock);\n\tiscsit_dec_conn_usage_count(conn);\n\n\treturn;\n\nfailure:\n\tspin_unlock_bh(&cmd->dataout_timeout_lock);\n\tiscsit_fill_cxn_timeout_err_stats(sess);\n\tiscsit_cause_connection_reinstatement(conn, 0);\n\tiscsit_dec_conn_usage_count(conn);\n}\n\nvoid iscsit_mod_dataout_timer(struct iscsit_cmd *cmd)\n{\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsit_session *sess = conn->sess;\n\tstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\n\n\tspin_lock_bh(&cmd->dataout_timeout_lock);\n\tif (!(cmd->dataout_timer_flags & ISCSI_TF_RUNNING)) {\n\t\tspin_unlock_bh(&cmd->dataout_timeout_lock);\n\t\treturn;\n\t}\n\n\tmod_timer(&cmd->dataout_timer,\n\t\t(get_jiffies_64() + na->dataout_timeout * HZ));\n\tpr_debug(\"Updated DataOUT timer for ITT: 0x%08x\",\n\t\t\tcmd->init_task_tag);\n\tspin_unlock_bh(&cmd->dataout_timeout_lock);\n}\n\nvoid iscsit_start_dataout_timer(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_conn *conn)\n{\n\tstruct iscsit_session *sess = conn->sess;\n\tstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\n\n\tlockdep_assert_held(&cmd->dataout_timeout_lock);\n\n\tif (cmd->dataout_timer_flags & ISCSI_TF_RUNNING)\n\t\treturn;\n\n\tpr_debug(\"Starting DataOUT timer for ITT: 0x%08x on\"\n\t\t\" CID: %hu.\\n\", cmd->init_task_tag, conn->cid);\n\n\tcmd->dataout_timer_flags &= ~ISCSI_TF_STOP;\n\tcmd->dataout_timer_flags |= ISCSI_TF_RUNNING;\n\tmod_timer(&cmd->dataout_timer, jiffies + na->dataout_timeout * HZ);\n}\n\nvoid iscsit_stop_dataout_timer(struct iscsit_cmd *cmd)\n{\n\tspin_lock_bh(&cmd->dataout_timeout_lock);\n\tif (!(cmd->dataout_timer_flags & ISCSI_TF_RUNNING)) {\n\t\tspin_unlock_bh(&cmd->dataout_timeout_lock);\n\t\treturn;\n\t}\n\tcmd->dataout_timer_flags |= ISCSI_TF_STOP;\n\tspin_unlock_bh(&cmd->dataout_timeout_lock);\n\n\tdel_timer_sync(&cmd->dataout_timer);\n\n\tspin_lock_bh(&cmd->dataout_timeout_lock);\n\tcmd->dataout_timer_flags &= ~ISCSI_TF_RUNNING;\n\tpr_debug(\"Stopped DataOUT Timer for ITT: 0x%08x\\n\",\n\t\t\tcmd->init_task_tag);\n\tspin_unlock_bh(&cmd->dataout_timeout_lock);\n}\nEXPORT_SYMBOL(iscsit_stop_dataout_timer);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}