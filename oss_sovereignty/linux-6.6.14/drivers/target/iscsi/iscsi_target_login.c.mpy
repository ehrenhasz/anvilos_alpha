{
  "module_name": "iscsi_target_login.c",
  "hash_id": "9835a51af168f150dae64a74e1c50b8e661b3caa8b5371dcf7bfe72cd4f7874e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target_login.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/kthread.h>\n#include <linux/sched/signal.h>\n#include <linux/idr.h>\n#include <linux/tcp.h>         \n#include <net/ip.h>\n#include <net/ipv6.h>          \n#include <scsi/iscsi_proto.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include <target/iscsi/iscsi_target_core.h>\n#include <target/iscsi/iscsi_target_stat.h>\n#include \"iscsi_target_device.h\"\n#include \"iscsi_target_nego.h\"\n#include \"iscsi_target_erl0.h\"\n#include \"iscsi_target_erl2.h\"\n#include \"iscsi_target_login.h\"\n#include \"iscsi_target_tpg.h\"\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target.h\"\n#include \"iscsi_target_parameters.h\"\n\n#include <target/iscsi/iscsi_transport.h>\n\nstatic struct iscsi_login *iscsi_login_init_conn(struct iscsit_conn *conn)\n{\n\tstruct iscsi_login *login;\n\n\tlogin = kzalloc(sizeof(struct iscsi_login), GFP_KERNEL);\n\tif (!login) {\n\t\tpr_err(\"Unable to allocate memory for struct iscsi_login.\\n\");\n\t\treturn NULL;\n\t}\n\tconn->login = login;\n\tlogin->conn = conn;\n\tlogin->first_request = 1;\n\n\tlogin->req_buf = kzalloc(MAX_KEY_VALUE_PAIRS, GFP_KERNEL);\n\tif (!login->req_buf) {\n\t\tpr_err(\"Unable to allocate memory for response buffer.\\n\");\n\t\tgoto out_login;\n\t}\n\n\tlogin->rsp_buf = kzalloc(MAX_KEY_VALUE_PAIRS, GFP_KERNEL);\n\tif (!login->rsp_buf) {\n\t\tpr_err(\"Unable to allocate memory for request buffer.\\n\");\n\t\tgoto out_req_buf;\n\t}\n\n\tconn->conn_login = login;\n\n\treturn login;\n\nout_req_buf:\n\tkfree(login->req_buf);\nout_login:\n\tkfree(login);\n\treturn NULL;\n}\n\n \nint iscsi_login_setup_crypto(struct iscsit_conn *conn)\n{\n\tstruct crypto_ahash *tfm;\n\n\t \n\ttfm = crypto_alloc_ahash(\"crc32c\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"crypto_alloc_ahash() failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tconn->conn_rx_hash = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!conn->conn_rx_hash) {\n\t\tpr_err(\"ahash_request_alloc() failed for conn_rx_hash\\n\");\n\t\tcrypto_free_ahash(tfm);\n\t\treturn -ENOMEM;\n\t}\n\tahash_request_set_callback(conn->conn_rx_hash, 0, NULL, NULL);\n\n\tconn->conn_tx_hash = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!conn->conn_tx_hash) {\n\t\tpr_err(\"ahash_request_alloc() failed for conn_tx_hash\\n\");\n\t\tahash_request_free(conn->conn_rx_hash);\n\t\tconn->conn_rx_hash = NULL;\n\t\tcrypto_free_ahash(tfm);\n\t\treturn -ENOMEM;\n\t}\n\tahash_request_set_callback(conn->conn_tx_hash, 0, NULL, NULL);\n\n\treturn 0;\n}\n\nstatic int iscsi_login_check_initiator_version(\n\tstruct iscsit_conn *conn,\n\tu8 version_max,\n\tu8 version_min)\n{\n\tif ((version_max != 0x00) || (version_min != 0x00)) {\n\t\tpr_err(\"Unsupported iSCSI IETF Pre-RFC Revision,\"\n\t\t\t\" version Min/Max 0x%02x/0x%02x, rejecting login.\\n\",\n\t\t\tversion_min, version_max);\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_VERSION);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint iscsi_check_for_session_reinstatement(struct iscsit_conn *conn)\n{\n\tint sessiontype;\n\tstruct iscsi_param *initiatorname_param = NULL, *sessiontype_param = NULL;\n\tstruct iscsi_portal_group *tpg = conn->tpg;\n\tstruct iscsit_session *sess = NULL, *sess_p = NULL;\n\tstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\n\tstruct se_session *se_sess, *se_sess_tmp;\n\n\tinitiatorname_param = iscsi_find_param_from_key(\n\t\t\tINITIATORNAME, conn->param_list);\n\tsessiontype_param = iscsi_find_param_from_key(\n\t\t\tSESSIONTYPE, conn->param_list);\n\tif (!initiatorname_param || !sessiontype_param) {\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\tISCSI_LOGIN_STATUS_MISSING_FIELDS);\n\t\treturn -1;\n\t}\n\n\tsessiontype = (strncmp(sessiontype_param->value, NORMAL, 6)) ? 1 : 0;\n\n\tspin_lock_bh(&se_tpg->session_lock);\n\tlist_for_each_entry_safe(se_sess, se_sess_tmp, &se_tpg->tpg_sess_list,\n\t\t\tsess_list) {\n\n\t\tsess_p = se_sess->fabric_sess_ptr;\n\t\tspin_lock(&sess_p->conn_lock);\n\t\tif (atomic_read(&sess_p->session_fall_back_to_erl0) ||\n\t\t    atomic_read(&sess_p->session_logout) ||\n\t\t    atomic_read(&sess_p->session_close) ||\n\t\t    (sess_p->time2retain_timer_flags & ISCSI_TF_EXPIRED)) {\n\t\t\tspin_unlock(&sess_p->conn_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!memcmp(sess_p->isid, conn->sess->isid, 6) &&\n\t\t   (!strcmp(sess_p->sess_ops->InitiatorName,\n\t\t\t    initiatorname_param->value) &&\n\t\t   (sess_p->sess_ops->SessionType == sessiontype))) {\n\t\t\tatomic_set(&sess_p->session_reinstatement, 1);\n\t\t\tatomic_set(&sess_p->session_fall_back_to_erl0, 1);\n\t\t\tatomic_set(&sess_p->session_close, 1);\n\t\t\tspin_unlock(&sess_p->conn_lock);\n\t\t\tiscsit_inc_session_usage_count(sess_p);\n\t\t\tiscsit_stop_time2retain_timer(sess_p);\n\t\t\tsess = sess_p;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&sess_p->conn_lock);\n\t}\n\tspin_unlock_bh(&se_tpg->session_lock);\n\t \n\tif (!sess)\n\t\treturn 0;\n\n\tpr_debug(\"%s iSCSI Session SID %u is still active for %s,\"\n\t\t\" performing session reinstatement.\\n\", (sessiontype) ?\n\t\t\"Discovery\" : \"Normal\", sess->sid,\n\t\tsess->sess_ops->InitiatorName);\n\n\tspin_lock_bh(&sess->conn_lock);\n\tif (sess->session_state == TARG_SESS_STATE_FAILED) {\n\t\tspin_unlock_bh(&sess->conn_lock);\n\t\tiscsit_dec_session_usage_count(sess);\n\t\treturn 0;\n\t}\n\tspin_unlock_bh(&sess->conn_lock);\n\n\tiscsit_stop_session(sess, 1, 1);\n\tiscsit_dec_session_usage_count(sess);\n\n\treturn 0;\n}\n\nstatic int iscsi_login_set_conn_values(\n\tstruct iscsit_session *sess,\n\tstruct iscsit_conn *conn,\n\t__be16 cid)\n{\n\tint ret;\n\tconn->sess\t\t= sess;\n\tconn->cid\t\t= be16_to_cpu(cid);\n\t \n\tret = get_random_bytes_wait(&conn->stat_sn, sizeof(u32));\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tmutex_lock(&auth_id_lock);\n\tconn->auth_id\t\t= iscsit_global->auth_id++;\n\tmutex_unlock(&auth_id_lock);\n\treturn 0;\n}\n\n__printf(2, 3) int iscsi_change_param_sprintf(\n\tstruct iscsit_conn *conn,\n\tconst char *fmt, ...)\n{\n\tva_list args;\n\tunsigned char buf[64];\n\n\tmemset(buf, 0, sizeof buf);\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof buf, fmt, args);\n\tva_end(args);\n\n\tif (iscsi_change_param_value(buf, conn->param_list, 0) < 0) {\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iscsi_change_param_sprintf);\n\n \nstatic int iscsi_login_zero_tsih_s1(\n\tstruct iscsit_conn *conn,\n\tunsigned char *buf)\n{\n\tstruct iscsit_session *sess = NULL;\n\tstruct iscsi_login_req *pdu = (struct iscsi_login_req *)buf;\n\tint ret;\n\n\tsess = kzalloc(sizeof(struct iscsit_session), GFP_KERNEL);\n\tif (!sess) {\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\tpr_err(\"Could not allocate memory for session\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (iscsi_login_set_conn_values(sess, conn, pdu->cid))\n\t\tgoto free_sess;\n\n\tsess->init_task_tag\t= pdu->itt;\n\tmemcpy(&sess->isid, pdu->isid, 6);\n\tsess->exp_cmd_sn\t= be32_to_cpu(pdu->cmdsn);\n\tINIT_LIST_HEAD(&sess->sess_conn_list);\n\tINIT_LIST_HEAD(&sess->sess_ooo_cmdsn_list);\n\tINIT_LIST_HEAD(&sess->cr_active_list);\n\tINIT_LIST_HEAD(&sess->cr_inactive_list);\n\tinit_completion(&sess->async_msg_comp);\n\tinit_completion(&sess->reinstatement_comp);\n\tinit_completion(&sess->session_wait_comp);\n\tinit_completion(&sess->session_waiting_on_uc_comp);\n\tmutex_init(&sess->cmdsn_mutex);\n\tspin_lock_init(&sess->conn_lock);\n\tspin_lock_init(&sess->cr_a_lock);\n\tspin_lock_init(&sess->cr_i_lock);\n\tspin_lock_init(&sess->session_usage_lock);\n\tspin_lock_init(&sess->ttt_lock);\n\n\ttimer_setup(&sess->time2retain_timer,\n\t\t    iscsit_handle_time2retain_timeout, 0);\n\n\tret = ida_alloc(&sess_ida, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tpr_err(\"Session ID allocation failed %d\\n\", ret);\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\tgoto free_sess;\n\t}\n\n\tsess->session_index = ret;\n\tsess->creation_time = get_jiffies_64();\n\t \n\tatomic_set(&sess->max_cmd_sn, be32_to_cpu(pdu->cmdsn));\n\n\tsess->sess_ops = kzalloc(sizeof(struct iscsi_sess_ops), GFP_KERNEL);\n\tif (!sess->sess_ops) {\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\t\" struct iscsi_sess_ops.\\n\");\n\t\tgoto free_id;\n\t}\n\n\tsess->se_sess = transport_alloc_session(TARGET_PROT_NORMAL);\n\tif (IS_ERR(sess->se_sess)) {\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\tgoto free_ops;\n\t}\n\n\treturn 0;\n\nfree_ops:\n\tkfree(sess->sess_ops);\nfree_id:\n\tida_free(&sess_ida, sess->session_index);\nfree_sess:\n\tkfree(sess);\n\tconn->sess = NULL;\n\treturn -ENOMEM;\n}\n\nstatic int iscsi_login_zero_tsih_s2(\n\tstruct iscsit_conn *conn)\n{\n\tstruct iscsi_node_attrib *na;\n\tstruct iscsit_session *sess = conn->sess;\n\tstruct iscsi_param *param;\n\tbool iser = false;\n\n\tsess->tpg = conn->tpg;\n\n\t \n\tsess->tsih = ++sess->tpg->ntsih;\n\tif (!sess->tsih)\n\t\tsess->tsih = ++sess->tpg->ntsih;\n\n\t \n\tif (iscsi_copy_param_list(&conn->param_list,\n\t\t\t\tconn->tpg->param_list, 1) < 0) {\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\treturn -1;\n\t}\n\n\tif (conn->conn_transport->transport_type == ISCSI_INFINIBAND)\n\t\tiser = true;\n\n\tiscsi_set_keys_to_negotiate(conn->param_list, iser);\n\n\tif (sess->sess_ops->SessionType)\n\t\treturn iscsi_set_keys_irrelevant_for_discovery(\n\t\t\t\tconn->param_list);\n\n\tna = iscsit_tpg_get_node_attrib(sess);\n\n\t \n\tparam = iscsi_find_param_from_key(AUTHMETHOD, conn->param_list);\n\tif (param && !strstr(param->value, NONE)) {\n\t\tif (!iscsi_conn_auth_required(conn))\n\t\t\tif (iscsi_change_param_sprintf(conn, \"AuthMethod=%s\",\n\t\t\t\t\t\t       NONE))\n\t\t\t\treturn -1;\n\t}\n\n\t \n\tif (iscsi_change_param_sprintf(conn, \"TargetPortalGroupTag=%hu\", sess->tpg->tpgt))\n\t\treturn -1;\n\n\t \n\tif (iscsi_change_param_sprintf(conn, \"ErrorRecoveryLevel=%d\", na->default_erl))\n\t\treturn -1;\n\n\t \n\tif (iser) {\n\t\tstruct iscsi_param *param;\n\t\tunsigned long mrdsl, off;\n\t\tint rc;\n\n\t\tif (iscsi_change_param_sprintf(conn, \"RDMAExtensions=Yes\"))\n\t\t\treturn -1;\n\n\t\t \n\t\tparam = iscsi_find_param_from_key(\"MaxRecvDataSegmentLength\",\n\t\t\t\t\t\t  conn->param_list);\n\t\tif (!param) {\n\t\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\t\treturn -1;\n\t\t}\n\t\trc = kstrtoul(param->value, 0, &mrdsl);\n\t\tif (rc < 0) {\n\t\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\t\treturn -1;\n\t\t}\n\t\toff = mrdsl % PAGE_SIZE;\n\t\tif (!off)\n\t\t\tgoto check_prot;\n\n\t\tif (mrdsl < PAGE_SIZE)\n\t\t\tmrdsl = PAGE_SIZE;\n\t\telse\n\t\t\tmrdsl -= off;\n\n\t\tpr_warn(\"Aligning ISER MaxRecvDataSegmentLength: %lu down\"\n\t\t\t\" to PAGE_SIZE\\n\", mrdsl);\n\n\t\tif (iscsi_change_param_sprintf(conn, \"MaxRecvDataSegmentLength=%lu\\n\", mrdsl))\n\t\t\treturn -1;\n\t\t \ncheck_prot:\n\t\tif (sess->se_sess->sup_prot_ops &\n\t\t   (TARGET_PROT_DOUT_STRIP | TARGET_PROT_DOUT_PASS |\n\t\t    TARGET_PROT_DOUT_INSERT)) {\n\n\t\t\tif (iscsi_change_param_sprintf(conn, \"ImmediateData=No\"))\n\t\t\t\treturn -1;\n\n\t\t\tif (iscsi_change_param_sprintf(conn, \"InitialR2T=Yes\"))\n\t\t\t\treturn -1;\n\n\t\t\tpr_debug(\"Forcing ImmediateData=No + InitialR2T=Yes for\"\n\t\t\t\t \" T10-PI enabled ISER session\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_login_non_zero_tsih_s1(\n\tstruct iscsit_conn *conn,\n\tunsigned char *buf)\n{\n\tstruct iscsi_login_req *pdu = (struct iscsi_login_req *)buf;\n\n\treturn iscsi_login_set_conn_values(NULL, conn, pdu->cid);\n}\n\n \nstatic int iscsi_login_non_zero_tsih_s2(\n\tstruct iscsit_conn *conn,\n\tunsigned char *buf)\n{\n\tstruct iscsi_portal_group *tpg = conn->tpg;\n\tstruct iscsit_session *sess = NULL, *sess_p = NULL;\n\tstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\n\tstruct se_session *se_sess, *se_sess_tmp;\n\tstruct iscsi_login_req *pdu = (struct iscsi_login_req *)buf;\n\tbool iser = false;\n\n\tspin_lock_bh(&se_tpg->session_lock);\n\tlist_for_each_entry_safe(se_sess, se_sess_tmp, &se_tpg->tpg_sess_list,\n\t\t\tsess_list) {\n\n\t\tsess_p = (struct iscsit_session *)se_sess->fabric_sess_ptr;\n\t\tif (atomic_read(&sess_p->session_fall_back_to_erl0) ||\n\t\t    atomic_read(&sess_p->session_logout) ||\n\t\t    atomic_read(&sess_p->session_close) ||\n\t\t   (sess_p->time2retain_timer_flags & ISCSI_TF_EXPIRED))\n\t\t\tcontinue;\n\t\tif (!memcmp(sess_p->isid, pdu->isid, 6) &&\n\t\t     (sess_p->tsih == be16_to_cpu(pdu->tsih))) {\n\t\t\tiscsit_inc_session_usage_count(sess_p);\n\t\t\tiscsit_stop_time2retain_timer(sess_p);\n\t\t\tsess = sess_p;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&se_tpg->session_lock);\n\n\t \n\tif (!sess) {\n\t\tpr_err(\"Initiator attempting to add a connection to\"\n\t\t\t\" a non-existent session, rejecting iSCSI Login.\\n\");\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_SESSION);\n\t\treturn -1;\n\t}\n\n\t \n\tspin_lock_bh(&sess->conn_lock);\n\tif (sess->session_state == TARG_SESS_STATE_FAILED)\n\t\tatomic_set(&sess->session_continuation, 1);\n\tspin_unlock_bh(&sess->conn_lock);\n\n\tif (iscsi_login_set_conn_values(sess, conn, pdu->cid) < 0 ||\n\t    iscsi_copy_param_list(&conn->param_list,\n\t\t\tconn->tpg->param_list, 0) < 0) {\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\treturn -1;\n\t}\n\n\tif (conn->conn_transport->transport_type == ISCSI_INFINIBAND)\n\t\tiser = true;\n\n\tiscsi_set_keys_to_negotiate(conn->param_list, iser);\n\t \n\tif (iscsi_change_param_sprintf(conn, \"TargetPortalGroupTag=%hu\", sess->tpg->tpgt))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint iscsi_login_post_auth_non_zero_tsih(\n\tstruct iscsit_conn *conn,\n\tu16 cid,\n\tu32 exp_statsn)\n{\n\tstruct iscsit_conn *conn_ptr = NULL;\n\tstruct iscsi_conn_recovery *cr = NULL;\n\tstruct iscsit_session *sess = conn->sess;\n\n\t \n\tconn_ptr = iscsit_get_conn_from_cid_rcfr(sess, cid);\n\tif (conn_ptr) {\n\t\tpr_err(\"Connection exists with CID %hu for %s,\"\n\t\t\t\" performing connection reinstatement.\\n\",\n\t\t\tconn_ptr->cid, sess->sess_ops->InitiatorName);\n\n\t\tiscsit_connection_reinstatement_rcfr(conn_ptr);\n\t\tiscsit_dec_conn_usage_count(conn_ptr);\n\t}\n\n\t \n\tif (sess->sess_ops->ErrorRecoveryLevel == 2) {\n\t\tcr = iscsit_get_inactive_connection_recovery_entry(\n\t\t\t\tsess, cid);\n\t\tif (cr) {\n\t\t\tpr_debug(\"Performing implicit logout\"\n\t\t\t\t\" for connection recovery on CID: %hu\\n\",\n\t\t\t\t\tconn->cid);\n\t\t\tiscsit_discard_cr_cmds_by_expstatsn(cr, exp_statsn);\n\t\t}\n\t}\n\n\t \n\tpr_debug(\"Adding CID %hu to existing session for %s.\\n\",\n\t\t\tcid, sess->sess_ops->InitiatorName);\n\n\tif ((atomic_read(&sess->nconn) + 1) > sess->sess_ops->MaxConnections) {\n\t\tpr_err(\"Adding additional connection to this session\"\n\t\t\t\" would exceed MaxConnections %d, login failed.\\n\",\n\t\t\t\tsess->sess_ops->MaxConnections);\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_ISID_ERROR);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void iscsi_post_login_start_timers(struct iscsit_conn *conn)\n{\n\tstruct iscsit_session *sess = conn->sess;\n\t \n\tif (conn->conn_transport->transport_type == ISCSI_INFINIBAND)\n\t\treturn;\n\n\tif (!sess->sess_ops->SessionType)\n\t\tiscsit_start_nopin_timer(conn);\n}\n\nint iscsit_start_kthreads(struct iscsit_conn *conn)\n{\n\tint ret = 0;\n\n\tspin_lock(&iscsit_global->ts_bitmap_lock);\n\tconn->bitmap_id = bitmap_find_free_region(iscsit_global->ts_bitmap,\n\t\t\t\t\tISCSIT_BITMAP_BITS, get_order(1));\n\tspin_unlock(&iscsit_global->ts_bitmap_lock);\n\n\tif (conn->bitmap_id < 0) {\n\t\tpr_err(\"bitmap_find_free_region() failed for\"\n\t\t       \" iscsit_start_kthreads()\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tconn->tx_thread = kthread_run(iscsi_target_tx_thread, conn,\n\t\t\t\t      \"%s\", ISCSI_TX_THREAD_NAME);\n\tif (IS_ERR(conn->tx_thread)) {\n\t\tpr_err(\"Unable to start iscsi_target_tx_thread\\n\");\n\t\tret = PTR_ERR(conn->tx_thread);\n\t\tgoto out_bitmap;\n\t}\n\tconn->tx_thread_active = true;\n\n\tconn->rx_thread = kthread_run(iscsi_target_rx_thread, conn,\n\t\t\t\t      \"%s\", ISCSI_RX_THREAD_NAME);\n\tif (IS_ERR(conn->rx_thread)) {\n\t\tpr_err(\"Unable to start iscsi_target_rx_thread\\n\");\n\t\tret = PTR_ERR(conn->rx_thread);\n\t\tgoto out_tx;\n\t}\n\tconn->rx_thread_active = true;\n\n\treturn 0;\nout_tx:\n\tsend_sig(SIGINT, conn->tx_thread, 1);\n\tkthread_stop(conn->tx_thread);\n\tconn->tx_thread_active = false;\nout_bitmap:\n\tspin_lock(&iscsit_global->ts_bitmap_lock);\n\tbitmap_release_region(iscsit_global->ts_bitmap, conn->bitmap_id,\n\t\t\t      get_order(1));\n\tspin_unlock(&iscsit_global->ts_bitmap_lock);\n\treturn ret;\n}\n\nvoid iscsi_post_login_handler(\n\tstruct iscsi_np *np,\n\tstruct iscsit_conn *conn,\n\tu8 zero_tsih)\n{\n\tint stop_timer = 0;\n\tstruct iscsit_session *sess = conn->sess;\n\tstruct se_session *se_sess = sess->se_sess;\n\tstruct iscsi_portal_group *tpg = sess->tpg;\n\tstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\n\n\tiscsit_inc_conn_usage_count(conn);\n\n\tiscsit_collect_login_stats(conn, ISCSI_STATUS_CLS_SUCCESS,\n\t\t\tISCSI_LOGIN_STATUS_ACCEPT);\n\n\tpr_debug(\"Moving to TARG_CONN_STATE_LOGGED_IN.\\n\");\n\tconn->conn_state = TARG_CONN_STATE_LOGGED_IN;\n\n\tiscsi_set_connection_parameters(conn->conn_ops, conn->param_list);\n\t \n\tif (!zero_tsih) {\n\t\tiscsi_set_session_parameters(sess->sess_ops,\n\t\t\t\tconn->param_list, 0);\n\t\tiscsi_release_param_list(conn->param_list);\n\t\tconn->param_list = NULL;\n\n\t\tspin_lock_bh(&sess->conn_lock);\n\t\tatomic_set(&sess->session_continuation, 0);\n\t\tif (sess->session_state == TARG_SESS_STATE_FAILED) {\n\t\t\tpr_debug(\"Moving to\"\n\t\t\t\t\t\" TARG_SESS_STATE_LOGGED_IN.\\n\");\n\t\t\tsess->session_state = TARG_SESS_STATE_LOGGED_IN;\n\t\t\tstop_timer = 1;\n\t\t}\n\n\t\tpr_debug(\"iSCSI Login successful on CID: %hu from %pISpc to\"\n\t\t\t\" %pISpc,%hu\\n\", conn->cid, &conn->login_sockaddr,\n\t\t\t&conn->local_sockaddr, tpg->tpgt);\n\n\t\tlist_add_tail(&conn->conn_list, &sess->sess_conn_list);\n\t\tatomic_inc(&sess->nconn);\n\t\tpr_debug(\"Incremented iSCSI Connection count to %d\"\n\t\t\t\" from node: %s\\n\", atomic_read(&sess->nconn),\n\t\t\tsess->sess_ops->InitiatorName);\n\t\tspin_unlock_bh(&sess->conn_lock);\n\n\t\tiscsi_post_login_start_timers(conn);\n\t\t \n\t\tiscsit_thread_get_cpumask(conn);\n\t\tconn->conn_rx_reset_cpumask = 1;\n\t\tconn->conn_tx_reset_cpumask = 1;\n\t\t \n\t\tcomplete(&conn->rx_login_comp);\n\t\tiscsit_dec_conn_usage_count(conn);\n\n\t\tif (stop_timer) {\n\t\t\tspin_lock_bh(&se_tpg->session_lock);\n\t\t\tiscsit_stop_time2retain_timer(sess);\n\t\t\tspin_unlock_bh(&se_tpg->session_lock);\n\t\t}\n\t\tiscsit_dec_session_usage_count(sess);\n\t\treturn;\n\t}\n\n\tiscsi_set_session_parameters(sess->sess_ops, conn->param_list, 1);\n\tiscsi_release_param_list(conn->param_list);\n\tconn->param_list = NULL;\n\n\tiscsit_determine_maxcmdsn(sess);\n\n\tspin_lock_bh(&se_tpg->session_lock);\n\t__transport_register_session(&sess->tpg->tpg_se_tpg,\n\t\t\tse_sess->se_node_acl, se_sess, sess);\n\tpr_debug(\"Moving to TARG_SESS_STATE_LOGGED_IN.\\n\");\n\tsess->session_state = TARG_SESS_STATE_LOGGED_IN;\n\n\tpr_debug(\"iSCSI Login successful on CID: %hu from %pISpc to %pISpc,%hu\\n\",\n\t\tconn->cid, &conn->login_sockaddr, &conn->local_sockaddr,\n\t\ttpg->tpgt);\n\n\tspin_lock_bh(&sess->conn_lock);\n\tlist_add_tail(&conn->conn_list, &sess->sess_conn_list);\n\tatomic_inc(&sess->nconn);\n\tpr_debug(\"Incremented iSCSI Connection count to %d from node:\"\n\t\t\" %s\\n\", atomic_read(&sess->nconn),\n\t\tsess->sess_ops->InitiatorName);\n\tspin_unlock_bh(&sess->conn_lock);\n\n\tsess->sid = tpg->sid++;\n\tif (!sess->sid)\n\t\tsess->sid = tpg->sid++;\n\tpr_debug(\"Established iSCSI session from node: %s\\n\",\n\t\t\tsess->sess_ops->InitiatorName);\n\n\ttpg->nsessions++;\n\tif (tpg->tpg_tiqn)\n\t\ttpg->tpg_tiqn->tiqn_nsessions++;\n\n\tpr_debug(\"Incremented number of active iSCSI sessions to %u on\"\n\t\t\" iSCSI Target Portal Group: %hu\\n\", tpg->nsessions, tpg->tpgt);\n\tspin_unlock_bh(&se_tpg->session_lock);\n\n\tiscsi_post_login_start_timers(conn);\n\t \n\tiscsit_thread_get_cpumask(conn);\n\tconn->conn_rx_reset_cpumask = 1;\n\tconn->conn_tx_reset_cpumask = 1;\n\t \n\tcomplete(&conn->rx_login_comp);\n\tiscsit_dec_conn_usage_count(conn);\n}\n\nint iscsit_setup_np(\n\tstruct iscsi_np *np,\n\tstruct sockaddr_storage *sockaddr)\n{\n\tstruct socket *sock = NULL;\n\tint backlog = ISCSIT_TCP_BACKLOG, ret, len;\n\n\tswitch (np->np_network_transport) {\n\tcase ISCSI_TCP:\n\t\tnp->np_ip_proto = IPPROTO_TCP;\n\t\tnp->np_sock_type = SOCK_STREAM;\n\t\tbreak;\n\tcase ISCSI_SCTP_TCP:\n\t\tnp->np_ip_proto = IPPROTO_SCTP;\n\t\tnp->np_sock_type = SOCK_STREAM;\n\t\tbreak;\n\tcase ISCSI_SCTP_UDP:\n\t\tnp->np_ip_proto = IPPROTO_SCTP;\n\t\tnp->np_sock_type = SOCK_SEQPACKET;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unsupported network_transport: %d\\n\",\n\t\t\t\tnp->np_network_transport);\n\t\treturn -EINVAL;\n\t}\n\n\tret = sock_create(sockaddr->ss_family, np->np_sock_type,\n\t\t\tnp->np_ip_proto, &sock);\n\tif (ret < 0) {\n\t\tpr_err(\"sock_create() failed.\\n\");\n\t\treturn ret;\n\t}\n\tnp->np_socket = sock;\n\t \n\tmemcpy(&np->np_sockaddr, sockaddr,\n\t\t\tsizeof(struct sockaddr_storage));\n\n\tif (sockaddr->ss_family == AF_INET6)\n\t\tlen = sizeof(struct sockaddr_in6);\n\telse\n\t\tlen = sizeof(struct sockaddr_in);\n\t \n\tif (np->np_network_transport == ISCSI_TCP)\n\t\ttcp_sock_set_nodelay(sock->sk);\n\tsock_set_reuseaddr(sock->sk);\n\tip_sock_set_freebind(sock->sk);\n\n\tret = kernel_bind(sock, (struct sockaddr *)&np->np_sockaddr, len);\n\tif (ret < 0) {\n\t\tpr_err(\"kernel_bind() failed: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tret = kernel_listen(sock, backlog);\n\tif (ret != 0) {\n\t\tpr_err(\"kernel_listen() failed: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tnp->np_socket = NULL;\n\tsock_release(sock);\n\treturn ret;\n}\n\nint iscsi_target_setup_login_socket(\n\tstruct iscsi_np *np,\n\tstruct sockaddr_storage *sockaddr)\n{\n\tstruct iscsit_transport *t;\n\tint rc;\n\n\tt = iscsit_get_transport(np->np_network_transport);\n\tif (!t)\n\t\treturn -EINVAL;\n\n\trc = t->iscsit_setup_np(np, sockaddr);\n\tif (rc < 0) {\n\t\tiscsit_put_transport(t);\n\t\treturn rc;\n\t}\n\n\tnp->np_transport = t;\n\tnp->enabled = true;\n\treturn 0;\n}\n\nint iscsit_accept_np(struct iscsi_np *np, struct iscsit_conn *conn)\n{\n\tstruct socket *new_sock, *sock = np->np_socket;\n\tstruct sockaddr_in sock_in;\n\tstruct sockaddr_in6 sock_in6;\n\tint rc;\n\n\trc = kernel_accept(sock, &new_sock, 0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tconn->sock = new_sock;\n\tconn->login_family = np->np_sockaddr.ss_family;\n\n\tif (np->np_sockaddr.ss_family == AF_INET6) {\n\t\tmemset(&sock_in6, 0, sizeof(struct sockaddr_in6));\n\n\t\trc = conn->sock->ops->getname(conn->sock,\n\t\t\t\t(struct sockaddr *)&sock_in6, 1);\n\t\tif (rc >= 0) {\n\t\t\tif (!ipv6_addr_v4mapped(&sock_in6.sin6_addr)) {\n\t\t\t\tmemcpy(&conn->login_sockaddr, &sock_in6, sizeof(sock_in6));\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsock_in.sin_family = AF_INET;\n\t\t\t\tsock_in.sin_port = sock_in6.sin6_port;\n\t\t\t\tmemcpy(&sock_in.sin_addr, &sock_in6.sin6_addr.s6_addr32[3], 4);\n\t\t\t\tmemcpy(&conn->login_sockaddr, &sock_in, sizeof(sock_in));\n\t\t\t}\n\t\t}\n\n\t\trc = conn->sock->ops->getname(conn->sock,\n\t\t\t\t(struct sockaddr *)&sock_in6, 0);\n\t\tif (rc >= 0) {\n\t\t\tif (!ipv6_addr_v4mapped(&sock_in6.sin6_addr)) {\n\t\t\t\tmemcpy(&conn->local_sockaddr, &sock_in6, sizeof(sock_in6));\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsock_in.sin_family = AF_INET;\n\t\t\t\tsock_in.sin_port = sock_in6.sin6_port;\n\t\t\t\tmemcpy(&sock_in.sin_addr, &sock_in6.sin6_addr.s6_addr32[3], 4);\n\t\t\t\tmemcpy(&conn->local_sockaddr, &sock_in, sizeof(sock_in));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmemset(&sock_in, 0, sizeof(struct sockaddr_in));\n\n\t\trc = conn->sock->ops->getname(conn->sock,\n\t\t\t\t(struct sockaddr *)&sock_in, 1);\n\t\tif (rc >= 0)\n\t\t\tmemcpy(&conn->login_sockaddr, &sock_in, sizeof(sock_in));\n\n\t\trc = conn->sock->ops->getname(conn->sock,\n\t\t\t\t(struct sockaddr *)&sock_in, 0);\n\t\tif (rc >= 0)\n\t\t\tmemcpy(&conn->local_sockaddr, &sock_in, sizeof(sock_in));\n\t}\n\n\treturn 0;\n}\n\nint iscsit_get_login_rx(struct iscsit_conn *conn, struct iscsi_login *login)\n{\n\tstruct iscsi_login_req *login_req;\n\tu32 padding = 0, payload_length;\n\n\tif (iscsi_login_rx_data(conn, login->req, ISCSI_HDR_LEN) < 0)\n\t\treturn -1;\n\n\tlogin_req = (struct iscsi_login_req *)login->req;\n\tpayload_length\t= ntoh24(login_req->dlength);\n\tpadding = ((-payload_length) & 3);\n\n\tpr_debug(\"Got Login Command, Flags 0x%02x, ITT: 0x%08x,\"\n\t\t\" CmdSN: 0x%08x, ExpStatSN: 0x%08x, CID: %hu, Length: %u\\n\",\n\t\tlogin_req->flags, login_req->itt, login_req->cmdsn,\n\t\tlogin_req->exp_statsn, login_req->cid, payload_length);\n\t \n\tif (login->first_request) {\n\t\tlogin_req = (struct iscsi_login_req *)login->req;\n\t\tlogin->leading_connection = (!login_req->tsih) ? 1 : 0;\n\t\tlogin->current_stage\t= ISCSI_LOGIN_CURRENT_STAGE(login_req->flags);\n\t\tlogin->version_min\t= login_req->min_version;\n\t\tlogin->version_max\t= login_req->max_version;\n\t\tmemcpy(login->isid, login_req->isid, 6);\n\t\tlogin->cmd_sn\t\t= be32_to_cpu(login_req->cmdsn);\n\t\tlogin->init_task_tag\t= login_req->itt;\n\t\tlogin->initial_exp_statsn = be32_to_cpu(login_req->exp_statsn);\n\t\tlogin->cid\t\t= be16_to_cpu(login_req->cid);\n\t\tlogin->tsih\t\t= be16_to_cpu(login_req->tsih);\n\t}\n\n\tif (iscsi_target_check_login_request(conn, login) < 0)\n\t\treturn -1;\n\n\tmemset(login->req_buf, 0, MAX_KEY_VALUE_PAIRS);\n\tif (iscsi_login_rx_data(conn, login->req_buf,\n\t\t\t\tpayload_length + padding) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint iscsit_put_login_tx(struct iscsit_conn *conn, struct iscsi_login *login,\n\t\t\tu32 length)\n{\n\tif (iscsi_login_tx_data(conn, login->rsp, login->rsp_buf, length) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int\niscsit_conn_set_transport(struct iscsit_conn *conn, struct iscsit_transport *t)\n{\n\tint rc;\n\n\tif (!t->owner) {\n\t\tconn->conn_transport = t;\n\t\treturn 0;\n\t}\n\n\trc = try_module_get(t->owner);\n\tif (!rc) {\n\t\tpr_err(\"try_module_get() failed for %s\\n\", t->name);\n\t\treturn -EINVAL;\n\t}\n\n\tconn->conn_transport = t;\n\treturn 0;\n}\n\nstatic struct iscsit_conn *iscsit_alloc_conn(struct iscsi_np *np)\n{\n\tstruct iscsit_conn *conn;\n\n\tconn = kzalloc(sizeof(struct iscsit_conn), GFP_KERNEL);\n\tif (!conn) {\n\t\tpr_err(\"Could not allocate memory for new connection\\n\");\n\t\treturn NULL;\n\t}\n\tpr_debug(\"Moving to TARG_CONN_STATE_FREE.\\n\");\n\tconn->conn_state = TARG_CONN_STATE_FREE;\n\n\tinit_waitqueue_head(&conn->queues_wq);\n\tINIT_LIST_HEAD(&conn->conn_list);\n\tINIT_LIST_HEAD(&conn->conn_cmd_list);\n\tINIT_LIST_HEAD(&conn->immed_queue_list);\n\tINIT_LIST_HEAD(&conn->response_queue_list);\n\tinit_completion(&conn->conn_post_wait_comp);\n\tinit_completion(&conn->conn_wait_comp);\n\tinit_completion(&conn->conn_wait_rcfr_comp);\n\tinit_completion(&conn->conn_waiting_on_uc_comp);\n\tinit_completion(&conn->conn_logout_comp);\n\tinit_completion(&conn->rx_half_close_comp);\n\tinit_completion(&conn->tx_half_close_comp);\n\tinit_completion(&conn->rx_login_comp);\n\tspin_lock_init(&conn->cmd_lock);\n\tspin_lock_init(&conn->conn_usage_lock);\n\tspin_lock_init(&conn->immed_queue_lock);\n\tspin_lock_init(&conn->nopin_timer_lock);\n\tspin_lock_init(&conn->response_queue_lock);\n\tspin_lock_init(&conn->state_lock);\n\tspin_lock_init(&conn->login_worker_lock);\n\tspin_lock_init(&conn->login_timer_lock);\n\n\ttimer_setup(&conn->nopin_response_timer,\n\t\t    iscsit_handle_nopin_response_timeout, 0);\n\ttimer_setup(&conn->nopin_timer, iscsit_handle_nopin_timeout, 0);\n\ttimer_setup(&conn->login_timer, iscsit_login_timeout, 0);\n\n\tif (iscsit_conn_set_transport(conn, np->np_transport) < 0)\n\t\tgoto free_conn;\n\n\tconn->conn_ops = kzalloc(sizeof(struct iscsi_conn_ops), GFP_KERNEL);\n\tif (!conn->conn_ops) {\n\t\tpr_err(\"Unable to allocate memory for struct iscsi_conn_ops.\\n\");\n\t\tgoto put_transport;\n\t}\n\n\tif (!zalloc_cpumask_var(&conn->conn_cpumask, GFP_KERNEL)) {\n\t\tpr_err(\"Unable to allocate conn->conn_cpumask\\n\");\n\t\tgoto free_conn_ops;\n\t}\n\n\tif (!zalloc_cpumask_var(&conn->allowed_cpumask, GFP_KERNEL)) {\n\t\tpr_err(\"Unable to allocate conn->allowed_cpumask\\n\");\n\t\tgoto free_conn_cpumask;\n\t}\n\n\tconn->cmd_cnt = target_alloc_cmd_counter();\n\tif (!conn->cmd_cnt)\n\t\tgoto free_conn_allowed_cpumask;\n\n\treturn conn;\n\nfree_conn_allowed_cpumask:\n\tfree_cpumask_var(conn->allowed_cpumask);\nfree_conn_cpumask:\n\tfree_cpumask_var(conn->conn_cpumask);\nfree_conn_ops:\n\tkfree(conn->conn_ops);\nput_transport:\n\tiscsit_put_transport(conn->conn_transport);\nfree_conn:\n\tkfree(conn);\n\treturn NULL;\n}\n\nvoid iscsit_free_conn(struct iscsit_conn *conn)\n{\n\ttarget_free_cmd_counter(conn->cmd_cnt);\n\tfree_cpumask_var(conn->allowed_cpumask);\n\tfree_cpumask_var(conn->conn_cpumask);\n\tkfree(conn->conn_ops);\n\tiscsit_put_transport(conn->conn_transport);\n\tkfree(conn);\n}\n\nvoid iscsi_target_login_sess_out(struct iscsit_conn *conn,\n\t\t\t\t bool zero_tsih, bool new_sess)\n{\n\tif (!new_sess)\n\t\tgoto old_sess_out;\n\n\tpr_err(\"iSCSI Login negotiation failed.\\n\");\n\tiscsit_collect_login_stats(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\t   ISCSI_LOGIN_STATUS_INIT_ERR);\n\tif (!zero_tsih || !conn->sess)\n\t\tgoto old_sess_out;\n\n\ttransport_free_session(conn->sess->se_sess);\n\tida_free(&sess_ida, conn->sess->session_index);\n\tkfree(conn->sess->sess_ops);\n\tkfree(conn->sess);\n\tconn->sess = NULL;\n\nold_sess_out:\n\t \n\tif (!zero_tsih && conn->sess) {\n\t\tspin_lock_bh(&conn->sess->conn_lock);\n\t\tif (conn->sess->session_state == TARG_SESS_STATE_FAILED) {\n\t\t\tstruct se_portal_group *se_tpg =\n\t\t\t\t\t&conn->tpg->tpg_se_tpg;\n\n\t\t\tatomic_set(&conn->sess->session_continuation, 0);\n\t\t\tspin_unlock_bh(&conn->sess->conn_lock);\n\t\t\tspin_lock_bh(&se_tpg->session_lock);\n\t\t\tiscsit_start_time2retain_handler(conn->sess);\n\t\t\tspin_unlock_bh(&se_tpg->session_lock);\n\t\t} else\n\t\t\tspin_unlock_bh(&conn->sess->conn_lock);\n\t\tiscsit_dec_session_usage_count(conn->sess);\n\t}\n\n\tahash_request_free(conn->conn_tx_hash);\n\tif (conn->conn_rx_hash) {\n\t\tstruct crypto_ahash *tfm;\n\n\t\ttfm = crypto_ahash_reqtfm(conn->conn_rx_hash);\n\t\tahash_request_free(conn->conn_rx_hash);\n\t\tcrypto_free_ahash(tfm);\n\t}\n\n\tif (conn->param_list) {\n\t\tiscsi_release_param_list(conn->param_list);\n\t\tconn->param_list = NULL;\n\t}\n\tiscsi_target_nego_release(conn);\n\n\tif (conn->sock) {\n\t\tsock_release(conn->sock);\n\t\tconn->sock = NULL;\n\t}\n\n\tif (conn->conn_transport->iscsit_wait_conn)\n\t\tconn->conn_transport->iscsit_wait_conn(conn);\n\n\tif (conn->conn_transport->iscsit_free_conn)\n\t\tconn->conn_transport->iscsit_free_conn(conn);\n\n\tiscsit_free_conn(conn);\n}\n\nstatic int __iscsi_target_login_thread(struct iscsi_np *np)\n{\n\tu8 *buffer, zero_tsih = 0;\n\tint ret = 0, rc;\n\tstruct iscsit_conn *conn = NULL;\n\tstruct iscsi_login *login;\n\tstruct iscsi_portal_group *tpg = NULL;\n\tstruct iscsi_login_req *pdu;\n\tstruct iscsi_tpg_np *tpg_np;\n\tbool new_sess = false;\n\n\tflush_signals(current);\n\n\tspin_lock_bh(&np->np_thread_lock);\n\tif (atomic_dec_if_positive(&np->np_reset_count) >= 0) {\n\t\tnp->np_thread_state = ISCSI_NP_THREAD_ACTIVE;\n\t\tspin_unlock_bh(&np->np_thread_lock);\n\t\tcomplete(&np->np_restart_comp);\n\t\treturn 1;\n\t} else if (np->np_thread_state == ISCSI_NP_THREAD_SHUTDOWN) {\n\t\tspin_unlock_bh(&np->np_thread_lock);\n\t\tgoto exit;\n\t} else {\n\t\tnp->np_thread_state = ISCSI_NP_THREAD_ACTIVE;\n\t}\n\tspin_unlock_bh(&np->np_thread_lock);\n\n\tconn = iscsit_alloc_conn(np);\n\tif (!conn) {\n\t\t \n\t\treturn 1;\n\t}\n\n\trc = np->np_transport->iscsit_accept_np(np, conn);\n\tif (rc == -ENOSYS) {\n\t\tcomplete(&np->np_restart_comp);\n\t\tiscsit_free_conn(conn);\n\t\tgoto exit;\n\t} else if (rc < 0) {\n\t\tspin_lock_bh(&np->np_thread_lock);\n\t\tif (atomic_dec_if_positive(&np->np_reset_count) >= 0) {\n\t\t\tnp->np_thread_state = ISCSI_NP_THREAD_ACTIVE;\n\t\t\tspin_unlock_bh(&np->np_thread_lock);\n\t\t\tcomplete(&np->np_restart_comp);\n\t\t\tiscsit_free_conn(conn);\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\t\tspin_unlock_bh(&np->np_thread_lock);\n\t\tiscsit_free_conn(conn);\n\t\treturn 1;\n\t}\n\t \n\tlogin = iscsi_login_init_conn(conn);\n\tif (!login) {\n\t\tgoto new_sess_out;\n\t}\n\n\tiscsit_start_login_timer(conn, current);\n\n\tpr_debug(\"Moving to TARG_CONN_STATE_XPT_UP.\\n\");\n\tconn->conn_state = TARG_CONN_STATE_XPT_UP;\n\t \n\trc = np->np_transport->iscsit_get_login_rx(conn, login);\n\tif (rc == 1)\n\t\treturn 1;\n\telse if (rc < 0)\n\t\tgoto new_sess_out;\n\n\tbuffer = &login->req[0];\n\tpdu = (struct iscsi_login_req *)buffer;\n\t \n\tconn->login_itt\t= pdu->itt;\n\n\tspin_lock_bh(&np->np_thread_lock);\n\tif (np->np_thread_state != ISCSI_NP_THREAD_ACTIVE) {\n\t\tspin_unlock_bh(&np->np_thread_lock);\n\t\tpr_err(\"iSCSI Network Portal on %pISpc currently not\"\n\t\t\t\" active.\\n\", &np->np_sockaddr);\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_SVC_UNAVAILABLE);\n\t\tgoto new_sess_out;\n\t}\n\tspin_unlock_bh(&np->np_thread_lock);\n\n\tconn->network_transport = np->np_network_transport;\n\n\tpr_debug(\"Received iSCSI login request from %pISpc on %s Network\"\n\t\t\" Portal %pISpc\\n\", &conn->login_sockaddr, np->np_transport->name,\n\t\t&conn->local_sockaddr);\n\n\tpr_debug(\"Moving to TARG_CONN_STATE_IN_LOGIN.\\n\");\n\tconn->conn_state\t= TARG_CONN_STATE_IN_LOGIN;\n\n\tif (iscsi_login_check_initiator_version(conn, pdu->max_version,\n\t\t\tpdu->min_version) < 0)\n\t\tgoto new_sess_out;\n\n\tzero_tsih = (pdu->tsih == 0x0000);\n\tif (zero_tsih) {\n\t\t \n\t\tif (iscsi_login_zero_tsih_s1(conn, buffer) < 0)\n\t\t\tgoto new_sess_out;\n\t} else {\n\t\t \n\t\tif (iscsi_login_non_zero_tsih_s1(conn, buffer) < 0)\n\t\t\tgoto new_sess_out;\n\t}\n\t \n\trc = iscsi_target_locate_portal(np, conn, login);\n\tif (rc < 0) {\n\t\ttpg = conn->tpg;\n\t\tgoto new_sess_out;\n\t}\n\tlogin->zero_tsih = zero_tsih;\n\n\tif (conn->sess)\n\t\tconn->sess->se_sess->sup_prot_ops =\n\t\t\tconn->conn_transport->iscsit_get_sup_prot_ops(conn);\n\n\ttpg = conn->tpg;\n\tif (!tpg) {\n\t\tpr_err(\"Unable to locate struct iscsit_conn->tpg\\n\");\n\t\tgoto new_sess_out;\n\t}\n\n\tif (zero_tsih) {\n\t\tif (iscsi_login_zero_tsih_s2(conn) < 0)\n\t\t\tgoto new_sess_out;\n\t} else {\n\t\tif (iscsi_login_non_zero_tsih_s2(conn, buffer) < 0)\n\t\t\tgoto old_sess_out;\n\t}\n\n\tif (conn->conn_transport->iscsit_validate_params) {\n\t\tret = conn->conn_transport->iscsit_validate_params(conn);\n\t\tif (ret < 0) {\n\t\t\tif (zero_tsih)\n\t\t\t\tgoto new_sess_out;\n\t\t\telse\n\t\t\t\tgoto old_sess_out;\n\t\t}\n\t}\n\n\tret = iscsi_target_start_negotiation(login, conn);\n\tif (ret < 0)\n\t\tgoto new_sess_out;\n\n\tif (ret == 1) {\n\t\ttpg_np = conn->tpg_np;\n\n\t\tiscsi_post_login_handler(np, conn, zero_tsih);\n\t\tiscsit_deaccess_np(np, tpg, tpg_np);\n\t}\n\n\ttpg = NULL;\n\ttpg_np = NULL;\n\t \n\treturn 1;\n\nnew_sess_out:\n\tnew_sess = true;\nold_sess_out:\n\tiscsit_stop_login_timer(conn);\n\ttpg_np = conn->tpg_np;\n\tiscsi_target_login_sess_out(conn, zero_tsih, new_sess);\n\tnew_sess = false;\n\n\tif (tpg) {\n\t\tiscsit_deaccess_np(np, tpg, tpg_np);\n\t\ttpg = NULL;\n\t\ttpg_np = NULL;\n\t}\n\n\treturn 1;\n\nexit:\n\tspin_lock_bh(&np->np_thread_lock);\n\tnp->np_thread_state = ISCSI_NP_THREAD_EXIT;\n\tspin_unlock_bh(&np->np_thread_lock);\n\n\treturn 0;\n}\n\nint iscsi_target_login_thread(void *arg)\n{\n\tstruct iscsi_np *np = arg;\n\tint ret;\n\n\tallow_signal(SIGINT);\n\n\twhile (1) {\n\t\tret = __iscsi_target_login_thread(np);\n\t\t \n\t\tif (ret != 1)\n\t\t\tbreak;\n\t}\n\n\twhile (!kthread_should_stop()) {\n\t\tmsleep(100);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}