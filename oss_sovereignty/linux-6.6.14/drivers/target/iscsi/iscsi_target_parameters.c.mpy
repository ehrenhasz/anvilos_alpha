{
  "module_name": "iscsi_target_parameters.c",
  "hash_id": "b05724653eacd2ab9d9a04a2b6f7d21d7ceb7df6b9793e3def413de30be7790f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target_parameters.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/uio.h>  \n#include <target/iscsi/iscsi_target_core.h>\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target_parameters.h\"\n\nint iscsi_login_rx_data(\n\tstruct iscsit_conn *conn,\n\tchar *buf,\n\tint length)\n{\n\tint rx_got;\n\tstruct kvec iov;\n\n\tmemset(&iov, 0, sizeof(struct kvec));\n\tiov.iov_len\t= length;\n\tiov.iov_base\t= buf;\n\n\trx_got = rx_data(conn, &iov, 1, length);\n\tif (rx_got != length) {\n\t\tpr_err(\"rx_data returned %d, expecting %d.\\n\",\n\t\t\t\trx_got, length);\n\t\treturn -1;\n\t}\n\n\treturn 0 ;\n}\n\nint iscsi_login_tx_data(\n\tstruct iscsit_conn *conn,\n\tchar *pdu_buf,\n\tchar *text_buf,\n\tint text_length)\n{\n\tint length, tx_sent, iov_cnt = 1;\n\tstruct kvec iov[2];\n\n\tlength = (ISCSI_HDR_LEN + text_length);\n\n\tmemset(&iov[0], 0, 2 * sizeof(struct kvec));\n\tiov[0].iov_len\t\t= ISCSI_HDR_LEN;\n\tiov[0].iov_base\t\t= pdu_buf;\n\n\tif (text_buf && text_length) {\n\t\tiov[1].iov_len\t= text_length;\n\t\tiov[1].iov_base\t= text_buf;\n\t\tiov_cnt++;\n\t}\n\n\ttx_sent = tx_data(conn, &iov[0], iov_cnt, length);\n\tif (tx_sent != length) {\n\t\tpr_err(\"tx_data returned %d, expecting %d.\\n\",\n\t\t\t\ttx_sent, length);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nvoid iscsi_dump_conn_ops(struct iscsi_conn_ops *conn_ops)\n{\n\tpr_debug(\"HeaderDigest: %s\\n\", (conn_ops->HeaderDigest) ?\n\t\t\t\t\"CRC32C\" : \"None\");\n\tpr_debug(\"DataDigest: %s\\n\", (conn_ops->DataDigest) ?\n\t\t\t\t\"CRC32C\" : \"None\");\n\tpr_debug(\"MaxRecvDataSegmentLength: %u\\n\",\n\t\t\t\tconn_ops->MaxRecvDataSegmentLength);\n}\n\nvoid iscsi_dump_sess_ops(struct iscsi_sess_ops *sess_ops)\n{\n\tpr_debug(\"InitiatorName: %s\\n\", sess_ops->InitiatorName);\n\tpr_debug(\"InitiatorAlias: %s\\n\", sess_ops->InitiatorAlias);\n\tpr_debug(\"TargetName: %s\\n\", sess_ops->TargetName);\n\tpr_debug(\"TargetAlias: %s\\n\", sess_ops->TargetAlias);\n\tpr_debug(\"TargetPortalGroupTag: %hu\\n\",\n\t\t\tsess_ops->TargetPortalGroupTag);\n\tpr_debug(\"MaxConnections: %hu\\n\", sess_ops->MaxConnections);\n\tpr_debug(\"InitialR2T: %s\\n\",\n\t\t\t(sess_ops->InitialR2T) ? \"Yes\" : \"No\");\n\tpr_debug(\"ImmediateData: %s\\n\", (sess_ops->ImmediateData) ?\n\t\t\t\"Yes\" : \"No\");\n\tpr_debug(\"MaxBurstLength: %u\\n\", sess_ops->MaxBurstLength);\n\tpr_debug(\"FirstBurstLength: %u\\n\", sess_ops->FirstBurstLength);\n\tpr_debug(\"DefaultTime2Wait: %hu\\n\", sess_ops->DefaultTime2Wait);\n\tpr_debug(\"DefaultTime2Retain: %hu\\n\",\n\t\t\tsess_ops->DefaultTime2Retain);\n\tpr_debug(\"MaxOutstandingR2T: %hu\\n\",\n\t\t\tsess_ops->MaxOutstandingR2T);\n\tpr_debug(\"DataPDUInOrder: %s\\n\",\n\t\t\t(sess_ops->DataPDUInOrder) ? \"Yes\" : \"No\");\n\tpr_debug(\"DataSequenceInOrder: %s\\n\",\n\t\t\t(sess_ops->DataSequenceInOrder) ? \"Yes\" : \"No\");\n\tpr_debug(\"ErrorRecoveryLevel: %hu\\n\",\n\t\t\tsess_ops->ErrorRecoveryLevel);\n\tpr_debug(\"SessionType: %s\\n\", (sess_ops->SessionType) ?\n\t\t\t\"Discovery\" : \"Normal\");\n}\n\nvoid iscsi_print_params(struct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list)\n\t\tpr_debug(\"%s: %s\\n\", param->name, param->value);\n}\n\nstatic struct iscsi_param *iscsi_set_default_param(struct iscsi_param_list *param_list,\n\t\tchar *name, char *value, u8 phase, u8 scope, u8 sender,\n\t\tu16 type_range, u8 use)\n{\n\tstruct iscsi_param *param = NULL;\n\n\tparam = kzalloc(sizeof(struct iscsi_param), GFP_KERNEL);\n\tif (!param) {\n\t\tpr_err(\"Unable to allocate memory for parameter.\\n\");\n\t\tgoto out;\n\t}\n\tINIT_LIST_HEAD(&param->p_list);\n\n\tparam->name = kstrdup(name, GFP_KERNEL);\n\tif (!param->name) {\n\t\tpr_err(\"Unable to allocate memory for parameter name.\\n\");\n\t\tgoto out;\n\t}\n\n\tparam->value = kstrdup(value, GFP_KERNEL);\n\tif (!param->value) {\n\t\tpr_err(\"Unable to allocate memory for parameter value.\\n\");\n\t\tgoto out;\n\t}\n\n\tparam->phase\t\t= phase;\n\tparam->scope\t\t= scope;\n\tparam->sender\t\t= sender;\n\tparam->use\t\t= use;\n\tparam->type_range\t= type_range;\n\n\tswitch (param->type_range) {\n\tcase TYPERANGE_BOOL_AND:\n\t\tparam->type = TYPE_BOOL_AND;\n\t\tbreak;\n\tcase TYPERANGE_BOOL_OR:\n\t\tparam->type = TYPE_BOOL_OR;\n\t\tbreak;\n\tcase TYPERANGE_0_TO_2:\n\tcase TYPERANGE_0_TO_3600:\n\tcase TYPERANGE_0_TO_32767:\n\tcase TYPERANGE_0_TO_65535:\n\tcase TYPERANGE_1_TO_65535:\n\tcase TYPERANGE_2_TO_3600:\n\tcase TYPERANGE_512_TO_16777215:\n\t\tparam->type = TYPE_NUMBER;\n\t\tbreak;\n\tcase TYPERANGE_AUTH:\n\tcase TYPERANGE_DIGEST:\n\t\tparam->type = TYPE_VALUE_LIST | TYPE_STRING;\n\t\tbreak;\n\tcase TYPERANGE_ISCSINAME:\n\tcase TYPERANGE_SESSIONTYPE:\n\tcase TYPERANGE_TARGETADDRESS:\n\tcase TYPERANGE_UTF8:\n\t\tparam->type = TYPE_STRING;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown type_range 0x%02x\\n\",\n\t\t\t\tparam->type_range);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&param->p_list, &param_list->param_list);\n\n\treturn param;\nout:\n\tif (param) {\n\t\tkfree(param->value);\n\t\tkfree(param->name);\n\t\tkfree(param);\n\t}\n\n\treturn NULL;\n}\n\n \nint iscsi_create_default_params(struct iscsi_param_list **param_list_ptr)\n{\n\tstruct iscsi_param *param = NULL;\n\tstruct iscsi_param_list *pl;\n\n\tpl = kzalloc(sizeof(struct iscsi_param_list), GFP_KERNEL);\n\tif (!pl) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\t\" struct iscsi_param_list.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tINIT_LIST_HEAD(&pl->param_list);\n\tINIT_LIST_HEAD(&pl->extra_response_list);\n\n\t \n\tparam = iscsi_set_default_param(pl, AUTHMETHOD, INITIAL_AUTHMETHOD,\n\t\t\tPHASE_SECURITY, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_AUTH, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, HEADERDIGEST, INITIAL_HEADERDIGEST,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_DIGEST, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DATADIGEST, INITIAL_DATADIGEST,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_DIGEST, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXCONNECTIONS,\n\t\t\tINITIAL_MAXCONNECTIONS, PHASE_OPERATIONAL,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_1_TO_65535, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, SENDTARGETS, INITIAL_SENDTARGETS,\n\t\t\tPHASE_FFP0, SCOPE_SESSION_WIDE, SENDER_INITIATOR,\n\t\t\tTYPERANGE_UTF8, 0);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETNAME, INITIAL_TARGETNAME,\n\t\t\tPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_ISCSINAME, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, INITIATORNAME,\n\t\t\tINITIAL_INITIATORNAME, PHASE_DECLARATIVE,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_INITIATOR,\n\t\t\tTYPERANGE_ISCSINAME, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETALIAS, INITIAL_TARGETALIAS,\n\t\t\tPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_TARGET,\n\t\t\tTYPERANGE_UTF8, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, INITIATORALIAS,\n\t\t\tINITIAL_INITIATORALIAS, PHASE_DECLARATIVE,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_INITIATOR, TYPERANGE_UTF8,\n\t\t\tUSE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETADDRESS,\n\t\t\tINITIAL_TARGETADDRESS, PHASE_DECLARATIVE,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_TARGET,\n\t\t\tTYPERANGE_TARGETADDRESS, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETPORTALGROUPTAG,\n\t\t\tINITIAL_TARGETPORTALGROUPTAG,\n\t\t\tPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_TARGET,\n\t\t\tTYPERANGE_0_TO_65535, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, INITIALR2T, INITIAL_INITIALR2T,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_OR, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, IMMEDIATEDATA,\n\t\t\tINITIAL_IMMEDIATEDATA, PHASE_OPERATIONAL,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_BOTH, TYPERANGE_BOOL_AND,\n\t\t\tUSE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXXMITDATASEGMENTLENGTH,\n\t\t\tINITIAL_MAXXMITDATASEGMENTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXRECVDATASEGMENTLENGTH,\n\t\t\tINITIAL_MAXRECVDATASEGMENTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXBURSTLENGTH,\n\t\t\tINITIAL_MAXBURSTLENGTH, PHASE_OPERATIONAL,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, FIRSTBURSTLENGTH,\n\t\t\tINITIAL_FIRSTBURSTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DEFAULTTIME2WAIT,\n\t\t\tINITIAL_DEFAULTTIME2WAIT,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_0_TO_3600, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DEFAULTTIME2RETAIN,\n\t\t\tINITIAL_DEFAULTTIME2RETAIN,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_0_TO_3600, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, MAXOUTSTANDINGR2T,\n\t\t\tINITIAL_MAXOUTSTANDINGR2T,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_1_TO_65535, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DATAPDUINORDER,\n\t\t\tINITIAL_DATAPDUINORDER, PHASE_OPERATIONAL,\n\t\t\tSCOPE_SESSION_WIDE, SENDER_BOTH, TYPERANGE_BOOL_OR,\n\t\t\tUSE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, DATASEQUENCEINORDER,\n\t\t\tINITIAL_DATASEQUENCEINORDER,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_OR, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, ERRORRECOVERYLEVEL,\n\t\t\tINITIAL_ERRORRECOVERYLEVEL,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_0_TO_2, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, SESSIONTYPE, INITIAL_SESSIONTYPE,\n\t\t\tPHASE_DECLARATIVE, SCOPE_SESSION_WIDE, SENDER_INITIATOR,\n\t\t\tTYPERANGE_SESSIONTYPE, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, IFMARKER, INITIAL_IFMARKER,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_AND, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, OFMARKER, INITIAL_OFMARKER,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_AND, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, IFMARKINT, INITIAL_IFMARKINT,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_UTF8, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, OFMARKINT, INITIAL_OFMARKINT,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_UTF8, USE_INITIAL_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\t \n\tparam = iscsi_set_default_param(pl, RDMAEXTENSIONS, INITIAL_RDMAEXTENSIONS,\n\t\t\tPHASE_OPERATIONAL, SCOPE_SESSION_WIDE, SENDER_BOTH,\n\t\t\tTYPERANGE_BOOL_AND, USE_LEADING_ONLY);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, INITIATORRECVDATASEGMENTLENGTH,\n\t\t\tINITIAL_INITIATORRECVDATASEGMENTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\tparam = iscsi_set_default_param(pl, TARGETRECVDATASEGMENTLENGTH,\n\t\t\tINITIAL_TARGETRECVDATASEGMENTLENGTH,\n\t\t\tPHASE_OPERATIONAL, SCOPE_CONNECTION_ONLY, SENDER_BOTH,\n\t\t\tTYPERANGE_512_TO_16777215, USE_ALL);\n\tif (!param)\n\t\tgoto out;\n\n\t*param_list_ptr = pl;\n\treturn 0;\nout:\n\tiscsi_release_param_list(pl);\n\treturn -1;\n}\n\nint iscsi_set_keys_to_negotiate(\n\tstruct iscsi_param_list *param_list,\n\tbool iser)\n{\n\tstruct iscsi_param *param;\n\n\tparam_list->iser = iser;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tparam->state = 0;\n\t\tif (!strcmp(param->name, AUTHMETHOD)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, HEADERDIGEST)) {\n\t\t\tif (!iser)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DATADIGEST)) {\n\t\t\tif (!iser)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, MAXCONNECTIONS)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, TARGETNAME)) {\n\t\t\tcontinue;\n\t\t} else if (!strcmp(param->name, INITIATORNAME)) {\n\t\t\tcontinue;\n\t\t} else if (!strcmp(param->name, TARGETALIAS)) {\n\t\t\tif (param->value)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, INITIATORALIAS)) {\n\t\t\tcontinue;\n\t\t} else if (!strcmp(param->name, TARGETPORTALGROUPTAG)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, INITIALR2T)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, IMMEDIATEDATA)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH)) {\n\t\t\tif (!iser)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, MAXXMITDATASEGMENTLENGTH)) {\n\t\t\tcontinue;\n\t\t} else if (!strcmp(param->name, MAXBURSTLENGTH)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, FIRSTBURSTLENGTH)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2WAIT)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2RETAIN)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, MAXOUTSTANDINGR2T)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DATAPDUINORDER)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, DATASEQUENCEINORDER)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, ERRORRECOVERYLEVEL)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, SESSIONTYPE)) {\n\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, IFMARKER)) {\n\t\t\tSET_PSTATE_REJECT(param);\n\t\t} else if (!strcmp(param->name, OFMARKER)) {\n\t\t\tSET_PSTATE_REJECT(param);\n\t\t} else if (!strcmp(param->name, IFMARKINT)) {\n\t\t\tSET_PSTATE_REJECT(param);\n\t\t} else if (!strcmp(param->name, OFMARKINT)) {\n\t\t\tSET_PSTATE_REJECT(param);\n\t\t} else if (!strcmp(param->name, RDMAEXTENSIONS)) {\n\t\t\tif (iser)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, INITIATORRECVDATASEGMENTLENGTH)) {\n\t\t\tif (iser)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t} else if (!strcmp(param->name, TARGETRECVDATASEGMENTLENGTH)) {\n\t\t\tif (iser)\n\t\t\t\tSET_PSTATE_NEGOTIATE(param);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint iscsi_set_keys_irrelevant_for_discovery(\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!strcmp(param->name, MAXCONNECTIONS))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, INITIALR2T))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, IMMEDIATEDATA))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, MAXBURSTLENGTH))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, FIRSTBURSTLENGTH))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, MAXOUTSTANDINGR2T))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, DATAPDUINORDER))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, DATASEQUENCEINORDER))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, ERRORRECOVERYLEVEL))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, DEFAULTTIME2WAIT))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, DEFAULTTIME2RETAIN))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, IFMARKER))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, OFMARKER))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, IFMARKINT))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, OFMARKINT))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, RDMAEXTENSIONS))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, INITIATORRECVDATASEGMENTLENGTH))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t\telse if (!strcmp(param->name, TARGETRECVDATASEGMENTLENGTH))\n\t\t\tparam->state &= ~PSTATE_NEGOTIATE;\n\t}\n\n\treturn 0;\n}\n\nint iscsi_copy_param_list(\n\tstruct iscsi_param_list **dst_param_list,\n\tstruct iscsi_param_list *src_param_list,\n\tint leading)\n{\n\tstruct iscsi_param *param = NULL;\n\tstruct iscsi_param *new_param = NULL;\n\tstruct iscsi_param_list *param_list = NULL;\n\n\tparam_list = kzalloc(sizeof(struct iscsi_param_list), GFP_KERNEL);\n\tif (!param_list) {\n\t\tpr_err(\"Unable to allocate memory for struct iscsi_param_list.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tINIT_LIST_HEAD(&param_list->param_list);\n\tINIT_LIST_HEAD(&param_list->extra_response_list);\n\n\tlist_for_each_entry(param, &src_param_list->param_list, p_list) {\n\t\tif (!leading && (param->scope & SCOPE_SESSION_WIDE)) {\n\t\t\tif ((strcmp(param->name, \"TargetName\") != 0) &&\n\t\t\t    (strcmp(param->name, \"InitiatorName\") != 0) &&\n\t\t\t    (strcmp(param->name, \"TargetPortalGroupTag\") != 0))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tnew_param = kzalloc(sizeof(struct iscsi_param), GFP_KERNEL);\n\t\tif (!new_param) {\n\t\t\tpr_err(\"Unable to allocate memory for struct iscsi_param.\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tnew_param->name = kstrdup(param->name, GFP_KERNEL);\n\t\tnew_param->value = kstrdup(param->value, GFP_KERNEL);\n\t\tif (!new_param->value || !new_param->name) {\n\t\t\tkfree(new_param->value);\n\t\t\tkfree(new_param->name);\n\t\t\tkfree(new_param);\n\t\t\tpr_err(\"Unable to allocate memory for parameter name/value.\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tnew_param->set_param = param->set_param;\n\t\tnew_param->phase = param->phase;\n\t\tnew_param->scope = param->scope;\n\t\tnew_param->sender = param->sender;\n\t\tnew_param->type = param->type;\n\t\tnew_param->use = param->use;\n\t\tnew_param->type_range = param->type_range;\n\n\t\tlist_add_tail(&new_param->p_list, &param_list->param_list);\n\t}\n\n\tif (!list_empty(&param_list->param_list)) {\n\t\t*dst_param_list = param_list;\n\t} else {\n\t\tpr_err(\"No parameters allocated.\\n\");\n\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tiscsi_release_param_list(param_list);\n\treturn -ENOMEM;\n}\n\nstatic void iscsi_release_extra_responses(struct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *er, *er_tmp;\n\n\tlist_for_each_entry_safe(er, er_tmp, &param_list->extra_response_list,\n\t\t\ter_list) {\n\t\tlist_del(&er->er_list);\n\t\tkfree(er);\n\t}\n}\n\nvoid iscsi_release_param_list(struct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param, *param_tmp;\n\n\tlist_for_each_entry_safe(param, param_tmp, &param_list->param_list,\n\t\t\tp_list) {\n\t\tlist_del(&param->p_list);\n\n\t\tkfree(param->name);\n\t\tkfree(param->value);\n\t\tkfree(param);\n\t}\n\n\tiscsi_release_extra_responses(param_list);\n\n\tkfree(param_list);\n}\n\nstruct iscsi_param *iscsi_find_param_from_key(\n\tchar *key,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tif (!key || !param_list) {\n\t\tpr_err(\"Key or parameter list pointer is NULL.\\n\");\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!strcmp(key, param->name))\n\t\t\treturn param;\n\t}\n\n\tpr_err(\"Unable to locate key \\\"%s\\\".\\n\", key);\n\treturn NULL;\n}\nEXPORT_SYMBOL(iscsi_find_param_from_key);\n\nint iscsi_extract_key_value(char *textbuf, char **key, char **value)\n{\n\t*value = strchr(textbuf, '=');\n\tif (!*value) {\n\t\tpr_err(\"Unable to locate \\\"=\\\" separator for key,\"\n\t\t\t\t\" ignoring request.\\n\");\n\t\treturn -1;\n\t}\n\n\t*key = textbuf;\n\t**value = '\\0';\n\t*value = *value + 1;\n\n\treturn 0;\n}\n\nint iscsi_update_param_value(struct iscsi_param *param, char *value)\n{\n\tkfree(param->value);\n\n\tparam->value = kstrdup(value, GFP_KERNEL);\n\tif (!param->value) {\n\t\tpr_err(\"Unable to allocate memory for value.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"iSCSI Parameter updated to %s=%s\\n\",\n\t\t\tparam->name, param->value);\n\treturn 0;\n}\n\nstatic int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrscpy(extra_response->key, key, sizeof(extra_response->key));\n\tstrscpy(extra_response->value, NOTUNDERSTOOD,\n\t\tsizeof(extra_response->value));\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}\n\nstatic int iscsi_check_for_auth_key(char *key)\n{\n\t \n\tif (!strcmp(key, \"CHAP_A\") || !strcmp(key, \"CHAP_I\") ||\n\t    !strcmp(key, \"CHAP_C\") || !strcmp(key, \"CHAP_N\") ||\n\t    !strcmp(key, \"CHAP_R\"))\n\t\treturn 1;\n\n\t \n\tif (!strcmp(key, \"SRP_U\") || !strcmp(key, \"SRP_N\") ||\n\t    !strcmp(key, \"SRP_g\") || !strcmp(key, \"SRP_s\") ||\n\t    !strcmp(key, \"SRP_A\") || !strcmp(key, \"SRP_B\") ||\n\t    !strcmp(key, \"SRP_M\") || !strcmp(key, \"SRP_HM\"))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void iscsi_check_proposer_for_optional_reply(struct iscsi_param *param,\n\t\t\t\t\t\t    bool keys_workaround)\n{\n\tif (IS_TYPE_BOOL_AND(param)) {\n\t\tif (!strcmp(param->value, NO))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t} else if (IS_TYPE_BOOL_OR(param)) {\n\t\tif (!strcmp(param->value, YES))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\n\t\tif (keys_workaround) {\n\t\t\t \n\t\t\tif (!strcmp(param->name, IMMEDIATEDATA))\n\t\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t}\n\t} else if (IS_TYPE_NUMBER(param)) {\n\t\tif (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH))\n\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\n\t\tif (keys_workaround) {\n\t\t\t \n\t\t\tif (!strcmp(param->name, FIRSTBURSTLENGTH))\n\t\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\n\t\t\t \n\t\t\tif (!strcmp(param->name, MAXCONNECTIONS))\n\t\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t}\n\t} else if (IS_PHASE_DECLARATIVE(param))\n\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n}\n\nstatic int iscsi_check_boolean_value(struct iscsi_param *param, char *value)\n{\n\tif (strcmp(value, YES) && strcmp(value, NO)) {\n\t\tpr_err(\"Illegal value for \\\"%s\\\", must be either\"\n\t\t\t\" \\\"%s\\\" or \\\"%s\\\".\\n\", param->name, YES, NO);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_check_numerical_value(struct iscsi_param *param, char *value_ptr)\n{\n\tchar *tmpptr;\n\tint value = 0;\n\n\tvalue = simple_strtoul(value_ptr, &tmpptr, 0);\n\n\tif (IS_TYPERANGE_0_TO_2(param)) {\n\t\tif ((value < 0) || (value > 2)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 0 and 2.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_0_TO_3600(param)) {\n\t\tif ((value < 0) || (value > 3600)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 0 and 3600.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_0_TO_32767(param)) {\n\t\tif ((value < 0) || (value > 32767)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 0 and 32767.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_0_TO_65535(param)) {\n\t\tif ((value < 0) || (value > 65535)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 0 and 65535.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_1_TO_65535(param)) {\n\t\tif ((value < 1) || (value > 65535)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 1 and 65535.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_2_TO_3600(param)) {\n\t\tif ((value < 2) || (value > 3600)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 2 and 3600.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (IS_TYPERANGE_512_TO_16777215(param)) {\n\t\tif ((value < 512) || (value > 16777215)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" between 512 and 16777215.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_check_string_or_list_value(struct iscsi_param *param, char *value)\n{\n\tif (IS_PSTATE_PROPOSER(param))\n\t\treturn 0;\n\n\tif (IS_TYPERANGE_AUTH_PARAM(param)) {\n\t\tif (strcmp(value, KRB5) && strcmp(value, SPKM1) &&\n\t\t    strcmp(value, SPKM2) && strcmp(value, SRP) &&\n\t\t    strcmp(value, CHAP) && strcmp(value, NONE)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\"\"\n\t\t\t\t\" or \\\"%s\\\".\\n\", param->name, KRB5,\n\t\t\t\t\tSPKM1, SPKM2, SRP, CHAP, NONE);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (IS_TYPERANGE_DIGEST_PARAM(param)) {\n\t\tif (strcmp(value, CRC32C) && strcmp(value, NONE)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" \\\"%s\\\" or \\\"%s\\\".\\n\", param->name,\n\t\t\t\t\tCRC32C, NONE);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (IS_TYPERANGE_SESSIONTYPE(param)) {\n\t\tif (strcmp(value, DISCOVERY) && strcmp(value, NORMAL)) {\n\t\t\tpr_err(\"Illegal value for \\\"%s\\\", must be\"\n\t\t\t\t\" \\\"%s\\\" or \\\"%s\\\".\\n\", param->name,\n\t\t\t\t\tDISCOVERY, NORMAL);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic char *iscsi_check_valuelist_for_support(\n\tstruct iscsi_param *param,\n\tchar *value)\n{\n\tchar *tmp1 = NULL, *tmp2 = NULL;\n\tchar *acceptor_values = NULL, *proposer_values = NULL;\n\n\tacceptor_values = param->value;\n\tproposer_values = value;\n\n\tdo {\n\t\tif (!proposer_values)\n\t\t\treturn NULL;\n\t\ttmp1 = strchr(proposer_values, ',');\n\t\tif (tmp1)\n\t\t\t*tmp1 = '\\0';\n\t\tacceptor_values = param->value;\n\t\tdo {\n\t\t\tif (!acceptor_values) {\n\t\t\t\tif (tmp1)\n\t\t\t\t\t*tmp1 = ',';\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttmp2 = strchr(acceptor_values, ',');\n\t\t\tif (tmp2)\n\t\t\t\t*tmp2 = '\\0';\n\t\t\tif (!strcmp(acceptor_values, proposer_values)) {\n\t\t\t\tif (tmp2)\n\t\t\t\t\t*tmp2 = ',';\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (tmp2)\n\t\t\t\t*tmp2++ = ',';\n\n\t\t\tacceptor_values = tmp2;\n\t\t} while (acceptor_values);\n\t\tif (tmp1)\n\t\t\t*tmp1++ = ',';\n\t\tproposer_values = tmp1;\n\t} while (proposer_values);\n\nout:\n\treturn proposer_values;\n}\n\nstatic int iscsi_check_acceptor_state(struct iscsi_param *param, char *value,\n\t\t\t\tstruct iscsit_conn *conn)\n{\n\tu8 acceptor_boolean_value = 0, proposer_boolean_value = 0;\n\tchar *negotiated_value = NULL;\n\n\tif (IS_PSTATE_ACCEPTOR(param)) {\n\t\tpr_err(\"Received key \\\"%s\\\" twice, protocol error.\\n\",\n\t\t\t\tparam->name);\n\t\treturn -1;\n\t}\n\n\tif (IS_PSTATE_REJECT(param))\n\t\treturn 0;\n\n\tif (IS_TYPE_BOOL_AND(param)) {\n\t\tif (!strcmp(value, YES))\n\t\t\tproposer_boolean_value = 1;\n\t\tif (!strcmp(param->value, YES))\n\t\t\tacceptor_boolean_value = 1;\n\t\tif (acceptor_boolean_value && proposer_boolean_value)\n\t\t\tdo {} while (0);\n\t\telse {\n\t\t\tif (iscsi_update_param_value(param, NO) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (!proposer_boolean_value)\n\t\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t}\n\t} else if (IS_TYPE_BOOL_OR(param)) {\n\t\tif (!strcmp(value, YES))\n\t\t\tproposer_boolean_value = 1;\n\t\tif (!strcmp(param->value, YES))\n\t\t\tacceptor_boolean_value = 1;\n\t\tif (acceptor_boolean_value || proposer_boolean_value) {\n\t\t\tif (iscsi_update_param_value(param, YES) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (proposer_boolean_value)\n\t\t\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t\t}\n\t} else if (IS_TYPE_NUMBER(param)) {\n\t\tchar *tmpptr, buf[11];\n\t\tu32 acceptor_value = simple_strtoul(param->value, &tmpptr, 0);\n\t\tu32 proposer_value = simple_strtoul(value, &tmpptr, 0);\n\n\t\tmemset(buf, 0, sizeof(buf));\n\n\t\tif (!strcmp(param->name, MAXCONNECTIONS) ||\n\t\t    !strcmp(param->name, MAXBURSTLENGTH) ||\n\t\t    !strcmp(param->name, FIRSTBURSTLENGTH) ||\n\t\t    !strcmp(param->name, MAXOUTSTANDINGR2T) ||\n\t\t    !strcmp(param->name, DEFAULTTIME2RETAIN) ||\n\t\t    !strcmp(param->name, ERRORRECOVERYLEVEL)) {\n\t\t\tif (proposer_value > acceptor_value) {\n\t\t\t\tsprintf(buf, \"%u\", acceptor_value);\n\t\t\t\tif (iscsi_update_param_value(param,\n\t\t\t\t\t\t&buf[0]) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2WAIT)) {\n\t\t\tif (acceptor_value > proposer_value) {\n\t\t\t\tsprintf(buf, \"%u\", acceptor_value);\n\t\t\t\tif (iscsi_update_param_value(param,\n\t\t\t\t\t\t&buf[0]) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH)) {\n\t\t\tstruct iscsi_param *param_mxdsl;\n\t\t\tunsigned long long tmp;\n\t\t\tint rc;\n\n\t\t\trc = kstrtoull(param->value, 0, &tmp);\n\t\t\tif (rc < 0)\n\t\t\t\treturn -1;\n\n\t\t\tconn->conn_ops->MaxRecvDataSegmentLength = tmp;\n\t\t\tpr_debug(\"Saving op->MaxRecvDataSegmentLength from\"\n\t\t\t\t\" original initiator received value: %u\\n\",\n\t\t\t\tconn->conn_ops->MaxRecvDataSegmentLength);\n\n\t\t\tparam_mxdsl = iscsi_find_param_from_key(\n\t\t\t\t\t\tMAXXMITDATASEGMENTLENGTH,\n\t\t\t\t\t\tconn->param_list);\n\t\t\tif (!param_mxdsl)\n\t\t\t\treturn -1;\n\n\t\t\trc = iscsi_update_param_value(param,\n\t\t\t\t\t\tparam_mxdsl->value);\n\t\t\tif (rc < 0)\n\t\t\t\treturn -1;\n\n\t\t\tpr_debug(\"Updated %s to target MXDSL value: %s\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t}\n\t} else if (IS_TYPE_VALUE_LIST(param)) {\n\t\tnegotiated_value = iscsi_check_valuelist_for_support(\n\t\t\t\t\tparam, value);\n\t\tif (!negotiated_value) {\n\t\t\tpr_err(\"Proposer's value list \\\"%s\\\" contains\"\n\t\t\t\t\" no valid values from Acceptor's value list\"\n\t\t\t\t\" \\\"%s\\\".\\n\", value, param->value);\n\t\t\treturn -1;\n\t\t}\n\t\tif (iscsi_update_param_value(param, negotiated_value) < 0)\n\t\t\treturn -1;\n\t} else if (IS_PHASE_DECLARATIVE(param)) {\n\t\tif (iscsi_update_param_value(param, value) < 0)\n\t\t\treturn -1;\n\t\tSET_PSTATE_REPLY_OPTIONAL(param);\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_check_proposer_state(struct iscsi_param *param, char *value)\n{\n\tif (IS_PSTATE_RESPONSE_GOT(param)) {\n\t\tpr_err(\"Received key \\\"%s\\\" twice, protocol error.\\n\",\n\t\t\t\tparam->name);\n\t\treturn -1;\n\t}\n\n\tif (IS_TYPE_VALUE_LIST(param)) {\n\t\tchar *comma_ptr = NULL, *tmp_ptr = NULL;\n\n\t\tcomma_ptr = strchr(value, ',');\n\t\tif (comma_ptr) {\n\t\t\tpr_err(\"Illegal \\\",\\\" in response for \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name);\n\t\t\treturn -1;\n\t\t}\n\n\t\ttmp_ptr = iscsi_check_valuelist_for_support(param, value);\n\t\tif (!tmp_ptr)\n\t\t\treturn -1;\n\t}\n\n\tif (iscsi_update_param_value(param, value) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int iscsi_check_value(struct iscsi_param *param, char *value)\n{\n\tchar *comma_ptr = NULL;\n\n\tif (!strcmp(value, REJECT)) {\n\t\tif (!strcmp(param->name, IFMARKINT) ||\n\t\t    !strcmp(param->name, OFMARKINT)) {\n\t\t\t \n\t\t\tSET_PSTATE_REJECT(param);\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"Received %s=%s\\n\", param->name, value);\n\t\treturn -1;\n\t}\n\tif (!strcmp(value, IRRELEVANT)) {\n\t\tpr_debug(\"Received %s=%s\\n\", param->name, value);\n\t\tSET_PSTATE_IRRELEVANT(param);\n\t\treturn 0;\n\t}\n\tif (!strcmp(value, NOTUNDERSTOOD)) {\n\t\tif (!IS_PSTATE_PROPOSER(param)) {\n\t\t\tpr_err(\"Received illegal offer %s=%s\\n\",\n\t\t\t\tparam->name, value);\n\t\t\treturn -1;\n\t\t}\n\n \n\t\tpr_err(\"Standard iSCSI key \\\"%s\\\" cannot be answered\"\n\t\t\t\" with \\\"%s\\\", protocol error.\\n\", param->name, value);\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\tcomma_ptr = NULL;\n\t\tcomma_ptr = strchr(value, ',');\n\n\t\tif (comma_ptr && !IS_TYPE_VALUE_LIST(param)) {\n\t\t\tpr_err(\"Detected value separator \\\",\\\", but\"\n\t\t\t\t\" key \\\"%s\\\" does not allow a value list,\"\n\t\t\t\t\" protocol error.\\n\", param->name);\n\t\t\treturn -1;\n\t\t}\n\t\tif (comma_ptr)\n\t\t\t*comma_ptr = '\\0';\n\n\t\tif (strlen(value) > VALUE_MAXLEN) {\n\t\t\tpr_err(\"Value for key \\\"%s\\\" exceeds %d,\"\n\t\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t\tVALUE_MAXLEN);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (IS_TYPE_BOOL_AND(param) || IS_TYPE_BOOL_OR(param)) {\n\t\t\tif (iscsi_check_boolean_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t} else if (IS_TYPE_NUMBER(param)) {\n\t\t\tif (iscsi_check_numerical_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t} else if (IS_TYPE_STRING(param) || IS_TYPE_VALUE_LIST(param)) {\n\t\t\tif (iscsi_check_string_or_list_value(param, value) < 0)\n\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tpr_err(\"Huh? 0x%02x\\n\", param->type);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (comma_ptr)\n\t\t\t*comma_ptr++ = ',';\n\n\t\tvalue = comma_ptr;\n\t} while (value);\n\n\treturn 0;\n}\n\nstatic struct iscsi_param *__iscsi_check_key(\n\tchar *key,\n\tint sender,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\n\tif (strlen(key) > KEY_MAXLEN) {\n\t\tpr_err(\"Length of key name \\\"%s\\\" exceeds %d.\\n\",\n\t\t\tkey, KEY_MAXLEN);\n\t\treturn NULL;\n\t}\n\n\tparam = iscsi_find_param_from_key(key, param_list);\n\tif (!param)\n\t\treturn NULL;\n\n\tif ((sender & SENDER_INITIATOR) && !IS_SENDER_INITIATOR(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be sent to %s,\"\n\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t(sender & SENDER_RECEIVER) ? \"target\" : \"initiator\");\n\t\treturn NULL;\n\t}\n\n\tif ((sender & SENDER_TARGET) && !IS_SENDER_TARGET(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be sent to %s,\"\n\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t(sender & SENDER_RECEIVER) ? \"initiator\" : \"target\");\n\t\treturn NULL;\n\t}\n\n\treturn param;\n}\n\nstatic struct iscsi_param *iscsi_check_key(\n\tchar *key,\n\tint phase,\n\tint sender,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_param *param;\n\t \n\tif (strlen(key) > KEY_MAXLEN) {\n\t\tpr_err(\"Length of key name \\\"%s\\\" exceeds %d.\\n\",\n\t\t\tkey, KEY_MAXLEN);\n\t\treturn NULL;\n\t}\n\n\tparam = iscsi_find_param_from_key(key, param_list);\n\tif (!param)\n\t\treturn NULL;\n\n\tif ((sender & SENDER_INITIATOR) && !IS_SENDER_INITIATOR(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be sent to %s,\"\n\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t(sender & SENDER_RECEIVER) ? \"target\" : \"initiator\");\n\t\treturn NULL;\n\t}\n\tif ((sender & SENDER_TARGET) && !IS_SENDER_TARGET(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" may not be sent to %s,\"\n\t\t\t\t\" protocol error.\\n\", param->name,\n\t\t\t(sender & SENDER_RECEIVER) ? \"initiator\" : \"target\");\n\t\treturn NULL;\n\t}\n\n\tif (IS_PSTATE_ACCEPTOR(param)) {\n\t\tpr_err(\"Key \\\"%s\\\" received twice, protocol error.\\n\",\n\t\t\t\tkey);\n\t\treturn NULL;\n\t}\n\n\tif (!phase)\n\t\treturn param;\n\n\tif (!(param->phase & phase)) {\n\t\tchar *phase_name;\n\n\t\tswitch (phase) {\n\t\tcase PHASE_SECURITY:\n\t\t\tphase_name = \"Security\";\n\t\t\tbreak;\n\t\tcase PHASE_OPERATIONAL:\n\t\t\tphase_name = \"Operational\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphase_name = \"Unknown\";\n\t\t}\n\t\tpr_err(\"Key \\\"%s\\\" may not be negotiated during %s phase.\\n\",\n\t\t\t\tparam->name, phase_name);\n\t\treturn NULL;\n\t}\n\n\treturn param;\n}\n\nstatic int iscsi_enforce_integrity_rules(\n\tu8 phase,\n\tstruct iscsi_param_list *param_list)\n{\n\tchar *tmpptr;\n\tu8 DataSequenceInOrder = 0;\n\tu8 ErrorRecoveryLevel = 0, SessionType = 0;\n\tu32 FirstBurstLength = 0, MaxBurstLength = 0;\n\tstruct iscsi_param *param = NULL;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!(param->phase & phase))\n\t\t\tcontinue;\n\t\tif (!strcmp(param->name, SESSIONTYPE))\n\t\t\tif (!strcmp(param->value, NORMAL))\n\t\t\t\tSessionType = 1;\n\t\tif (!strcmp(param->name, ERRORRECOVERYLEVEL))\n\t\t\tErrorRecoveryLevel = simple_strtoul(param->value,\n\t\t\t\t\t&tmpptr, 0);\n\t\tif (!strcmp(param->name, DATASEQUENCEINORDER))\n\t\t\tif (!strcmp(param->value, YES))\n\t\t\t\tDataSequenceInOrder = 1;\n\t\tif (!strcmp(param->name, MAXBURSTLENGTH))\n\t\t\tMaxBurstLength = simple_strtoul(param->value,\n\t\t\t\t\t&tmpptr, 0);\n\t}\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!(param->phase & phase))\n\t\t\tcontinue;\n\t\tif (!SessionType && !IS_PSTATE_ACCEPTOR(param))\n\t\t\tcontinue;\n\t\tif (!strcmp(param->name, MAXOUTSTANDINGR2T) &&\n\t\t    DataSequenceInOrder && (ErrorRecoveryLevel > 0)) {\n\t\t\tif (strcmp(param->value, \"1\")) {\n\t\t\t\tif (iscsi_update_param_value(param, \"1\") < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(param->name, MAXCONNECTIONS) && !SessionType) {\n\t\t\tif (strcmp(param->value, \"1\")) {\n\t\t\t\tif (iscsi_update_param_value(param, \"1\") < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t\t}\n\t\t}\n\t\tif (!strcmp(param->name, FIRSTBURSTLENGTH)) {\n\t\t\tFirstBurstLength = simple_strtoul(param->value,\n\t\t\t\t\t&tmpptr, 0);\n\t\t\tif (FirstBurstLength > MaxBurstLength) {\n\t\t\t\tchar tmpbuf[11];\n\t\t\t\tmemset(tmpbuf, 0, sizeof(tmpbuf));\n\t\t\t\tsprintf(tmpbuf, \"%u\", MaxBurstLength);\n\t\t\t\tif (iscsi_update_param_value(param, tmpbuf))\n\t\t\t\t\treturn -1;\n\t\t\t\tpr_debug(\"Reset \\\"%s\\\" to \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name, param->value);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsit_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\n\ttmpbuf = kmemdup_nul(textbuf, length, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate %u + 1 bytes for tmpbuf.\\n\", length);\n\t\treturn -ENOMEM;\n\t}\n\n\tstart = tmpbuf;\n\tend = (start + length);\n\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0)\n\t\t\tgoto free_buffer;\n\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key, value,\n\t\t\t\t\t\t\t     param_list) < 0)\n\t\t\t\tgoto free_buffer;\n\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0)\n\t\t\tgoto free_buffer;\n\n\t\tstart += strlen(key) + strlen(value) + 2;\n\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0)\n\t\t\t\tgoto free_buffer;\n\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0)\n\t\t\t\tgoto free_buffer;\n\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\n\tkfree(tmpbuf);\n\treturn 0;\n\nfree_buffer:\n\tkfree(tmpbuf);\n\treturn -1;\n}\n\nint iscsi_encode_text_output(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 *length,\n\tstruct iscsi_param_list *param_list,\n\tbool keys_workaround)\n{\n\tchar *output_buf = NULL;\n\tstruct iscsi_extra_response *er;\n\tstruct iscsi_param *param;\n\n\toutput_buf = textbuf + *length;\n\n\tif (iscsi_enforce_integrity_rules(phase, param_list) < 0)\n\t\treturn -1;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!(param->sender & sender))\n\t\t\tcontinue;\n\t\tif (IS_PSTATE_ACCEPTOR(param) &&\n\t\t    !IS_PSTATE_RESPONSE_SENT(param) &&\n\t\t    !IS_PSTATE_REPLY_OPTIONAL(param) &&\n\t\t    (param->phase & phase)) {\n\t\t\t*length += sprintf(output_buf, \"%s=%s\",\n\t\t\t\tparam->name, param->value);\n\t\t\t*length += 1;\n\t\t\toutput_buf = textbuf + *length;\n\t\t\tSET_PSTATE_RESPONSE_SENT(param);\n\t\t\tpr_debug(\"Sending key: %s=%s\\n\",\n\t\t\t\tparam->name, param->value);\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_PSTATE_NEGOTIATE(param) &&\n\t\t    !IS_PSTATE_ACCEPTOR(param) &&\n\t\t    !IS_PSTATE_PROPOSER(param) &&\n\t\t    (param->phase & phase)) {\n\t\t\t*length += sprintf(output_buf, \"%s=%s\",\n\t\t\t\tparam->name, param->value);\n\t\t\t*length += 1;\n\t\t\toutput_buf = textbuf + *length;\n\t\t\tSET_PSTATE_PROPOSER(param);\n\t\t\tiscsi_check_proposer_for_optional_reply(param,\n\t\t\t\t\t\t\t        keys_workaround);\n\t\t\tpr_debug(\"Sending key: %s=%s\\n\",\n\t\t\t\tparam->name, param->value);\n\t\t}\n\t}\n\n\tlist_for_each_entry(er, &param_list->extra_response_list, er_list) {\n\t\t*length += sprintf(output_buf, \"%s=%s\", er->key, er->value);\n\t\t*length += 1;\n\t\toutput_buf = textbuf + *length;\n\t\tpr_debug(\"Sending key: %s=%s\\n\", er->key, er->value);\n\t}\n\tiscsi_release_extra_responses(param_list);\n\n\treturn 0;\n}\n\nint iscsi_check_negotiated_keys(struct iscsi_param_list *param_list)\n{\n\tint ret = 0;\n\tstruct iscsi_param *param;\n\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (IS_PSTATE_NEGOTIATE(param) &&\n\t\t    IS_PSTATE_PROPOSER(param) &&\n\t\t    !IS_PSTATE_RESPONSE_GOT(param) &&\n\t\t    !IS_PSTATE_REPLY_OPTIONAL(param) &&\n\t\t    !IS_PHASE_DECLARATIVE(param)) {\n\t\t\tpr_err(\"No response for proposed key \\\"%s\\\".\\n\",\n\t\t\t\t\tparam->name);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint iscsi_change_param_value(\n\tchar *keyvalue,\n\tstruct iscsi_param_list *param_list,\n\tint check_key)\n{\n\tchar *key = NULL, *value = NULL;\n\tstruct iscsi_param *param;\n\tint sender = 0;\n\n\tif (iscsi_extract_key_value(keyvalue, &key, &value) < 0)\n\t\treturn -1;\n\n\tif (!check_key) {\n\t\tparam = __iscsi_check_key(keyvalue, sender, param_list);\n\t\tif (!param)\n\t\t\treturn -1;\n\t} else {\n\t\tparam = iscsi_check_key(keyvalue, 0, sender, param_list);\n\t\tif (!param)\n\t\t\treturn -1;\n\n\t\tparam->set_param = 1;\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tparam->set_param = 0;\n\t\t\treturn -1;\n\t\t}\n\t\tparam->set_param = 0;\n\t}\n\n\tif (iscsi_update_param_value(param, value) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nvoid iscsi_set_connection_parameters(\n\tstruct iscsi_conn_ops *ops,\n\tstruct iscsi_param_list *param_list)\n{\n\tchar *tmpptr;\n\tstruct iscsi_param *param;\n\n\tpr_debug(\"---------------------------------------------------\"\n\t\t\t\"---------------\\n\");\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\t \n\t\tif (!strcmp(param->name, MAXXMITDATASEGMENTLENGTH)) {\n\t\t\tops->MaxXmitDataSegmentLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"MaxXmitDataSegmentLength:     %s\\n\",\n\t\t\t\tparam->value);\n\t\t}\n\n\t\tif (!IS_PSTATE_ACCEPTOR(param) && !IS_PSTATE_PROPOSER(param))\n\t\t\tcontinue;\n\t\tif (!strcmp(param->name, AUTHMETHOD)) {\n\t\t\tpr_debug(\"AuthMethod:                   %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, HEADERDIGEST)) {\n\t\t\tops->HeaderDigest = !strcmp(param->value, CRC32C);\n\t\t\tpr_debug(\"HeaderDigest:                 %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DATADIGEST)) {\n\t\t\tops->DataDigest = !strcmp(param->value, CRC32C);\n\t\t\tpr_debug(\"DataDigest:                   %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, MAXRECVDATASEGMENTLENGTH)) {\n\t\t\t \n\t\t\tpr_debug(\"MaxRecvDataSegmentLength:     %u\\n\",\n\t\t\t\tops->MaxRecvDataSegmentLength);\n\t\t} else if (!strcmp(param->name, INITIATORRECVDATASEGMENTLENGTH)) {\n\t\t\tops->InitiatorRecvDataSegmentLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"InitiatorRecvDataSegmentLength: %s\\n\",\n\t\t\t\tparam->value);\n\t\t\tops->MaxRecvDataSegmentLength =\n\t\t\t\t\tops->InitiatorRecvDataSegmentLength;\n\t\t\tpr_debug(\"Set MRDSL from InitiatorRecvDataSegmentLength\\n\");\n\t\t} else if (!strcmp(param->name, TARGETRECVDATASEGMENTLENGTH)) {\n\t\t\tops->TargetRecvDataSegmentLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"TargetRecvDataSegmentLength:  %s\\n\",\n\t\t\t\tparam->value);\n\t\t\tops->MaxXmitDataSegmentLength =\n\t\t\t\t\tops->TargetRecvDataSegmentLength;\n\t\t\tpr_debug(\"Set MXDSL from TargetRecvDataSegmentLength\\n\");\n\t\t}\n\t}\n\tpr_debug(\"----------------------------------------------------\"\n\t\t\t\"--------------\\n\");\n}\n\nvoid iscsi_set_session_parameters(\n\tstruct iscsi_sess_ops *ops,\n\tstruct iscsi_param_list *param_list,\n\tint leading)\n{\n\tchar *tmpptr;\n\tstruct iscsi_param *param;\n\n\tpr_debug(\"----------------------------------------------------\"\n\t\t\t\"--------------\\n\");\n\tlist_for_each_entry(param, &param_list->param_list, p_list) {\n\t\tif (!IS_PSTATE_ACCEPTOR(param) && !IS_PSTATE_PROPOSER(param))\n\t\t\tcontinue;\n\t\tif (!strcmp(param->name, INITIATORNAME)) {\n\t\t\tif (!param->value)\n\t\t\t\tcontinue;\n\t\t\tif (leading)\n\t\t\t\tsnprintf(ops->InitiatorName,\n\t\t\t\t\t\tsizeof(ops->InitiatorName),\n\t\t\t\t\t\t\"%s\", param->value);\n\t\t\tpr_debug(\"InitiatorName:                %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, INITIATORALIAS)) {\n\t\t\tif (!param->value)\n\t\t\t\tcontinue;\n\t\t\tsnprintf(ops->InitiatorAlias,\n\t\t\t\t\t\tsizeof(ops->InitiatorAlias),\n\t\t\t\t\t\t\"%s\", param->value);\n\t\t\tpr_debug(\"InitiatorAlias:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, TARGETNAME)) {\n\t\t\tif (!param->value)\n\t\t\t\tcontinue;\n\t\t\tif (leading)\n\t\t\t\tsnprintf(ops->TargetName,\n\t\t\t\t\t\tsizeof(ops->TargetName),\n\t\t\t\t\t\t\"%s\", param->value);\n\t\t\tpr_debug(\"TargetName:                   %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, TARGETALIAS)) {\n\t\t\tif (!param->value)\n\t\t\t\tcontinue;\n\t\t\tsnprintf(ops->TargetAlias, sizeof(ops->TargetAlias),\n\t\t\t\t\t\"%s\", param->value);\n\t\t\tpr_debug(\"TargetAlias:                  %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, TARGETPORTALGROUPTAG)) {\n\t\t\tops->TargetPortalGroupTag =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"TargetPortalGroupTag:         %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, MAXCONNECTIONS)) {\n\t\t\tops->MaxConnections =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"MaxConnections:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, INITIALR2T)) {\n\t\t\tops->InitialR2T = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"InitialR2T:                   %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, IMMEDIATEDATA)) {\n\t\t\tops->ImmediateData = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"ImmediateData:                %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, MAXBURSTLENGTH)) {\n\t\t\tops->MaxBurstLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"MaxBurstLength:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, FIRSTBURSTLENGTH)) {\n\t\t\tops->FirstBurstLength =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"FirstBurstLength:             %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2WAIT)) {\n\t\t\tops->DefaultTime2Wait =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"DefaultTime2Wait:             %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DEFAULTTIME2RETAIN)) {\n\t\t\tops->DefaultTime2Retain =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"DefaultTime2Retain:           %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, MAXOUTSTANDINGR2T)) {\n\t\t\tops->MaxOutstandingR2T =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"MaxOutstandingR2T:            %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DATAPDUINORDER)) {\n\t\t\tops->DataPDUInOrder = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"DataPDUInOrder:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, DATASEQUENCEINORDER)) {\n\t\t\tops->DataSequenceInOrder = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"DataSequenceInOrder:          %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, ERRORRECOVERYLEVEL)) {\n\t\t\tops->ErrorRecoveryLevel =\n\t\t\t\tsimple_strtoul(param->value, &tmpptr, 0);\n\t\t\tpr_debug(\"ErrorRecoveryLevel:           %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, SESSIONTYPE)) {\n\t\t\tops->SessionType = !strcmp(param->value, DISCOVERY);\n\t\t\tpr_debug(\"SessionType:                  %s\\n\",\n\t\t\t\tparam->value);\n\t\t} else if (!strcmp(param->name, RDMAEXTENSIONS)) {\n\t\t\tops->RDMAExtensions = !strcmp(param->value, YES);\n\t\t\tpr_debug(\"RDMAExtensions:               %s\\n\",\n\t\t\t\tparam->value);\n\t\t}\n\t}\n\tpr_debug(\"----------------------------------------------------\"\n\t\t\t\"--------------\\n\");\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}