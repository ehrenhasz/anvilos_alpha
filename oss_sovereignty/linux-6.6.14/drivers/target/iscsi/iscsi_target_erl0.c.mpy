{
  "module_name": "iscsi_target_erl0.c",
  "hash_id": "85653336692743a41b643af77acfbd9e74d83d1d42cb53883d9a8fd5b3088f61",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target_erl0.c",
  "human_readable_source": "\n \n\n#include <linux/sched/signal.h>\n\n#include <scsi/iscsi_proto.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include <target/iscsi/iscsi_target_core.h>\n#include \"iscsi_target_seq_pdu_list.h\"\n#include \"iscsi_target_erl0.h\"\n#include \"iscsi_target_erl1.h\"\n#include \"iscsi_target_erl2.h\"\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target.h\"\n\n \nvoid iscsit_set_dataout_sequence_values(\n\tstruct iscsit_cmd *cmd)\n{\n\tstruct iscsit_conn *conn = cmd->conn;\n\t \n\tif (cmd->unsolicited_data) {\n\t\tcmd->seq_start_offset = cmd->write_data_done;\n\t\tcmd->seq_end_offset = min(cmd->se_cmd.data_length,\n\t\t\t\t\tconn->sess->sess_ops->FirstBurstLength);\n\t\treturn;\n\t}\n\n\tif (!conn->sess->sess_ops->DataSequenceInOrder)\n\t\treturn;\n\n\tif (!cmd->seq_start_offset && !cmd->seq_end_offset) {\n\t\tcmd->seq_start_offset = cmd->write_data_done;\n\t\tcmd->seq_end_offset = (cmd->se_cmd.data_length >\n\t\t\tconn->sess->sess_ops->MaxBurstLength) ?\n\t\t\t(cmd->write_data_done +\n\t\t\tconn->sess->sess_ops->MaxBurstLength) : cmd->se_cmd.data_length;\n\t} else {\n\t\tcmd->seq_start_offset = cmd->seq_end_offset;\n\t\tcmd->seq_end_offset = ((cmd->seq_end_offset +\n\t\t\tconn->sess->sess_ops->MaxBurstLength) >=\n\t\t\tcmd->se_cmd.data_length) ? cmd->se_cmd.data_length :\n\t\t\t(cmd->seq_end_offset +\n\t\t\t conn->sess->sess_ops->MaxBurstLength);\n\t}\n}\n\nstatic int iscsit_dataout_within_command_recovery_check(\n\tstruct iscsit_cmd *cmd,\n\tunsigned char *buf)\n{\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_data *hdr = (struct iscsi_data *) buf;\n\tu32 payload_length = ntoh24(hdr->dlength);\n\n\t \n\tif (conn->sess->sess_ops->DataSequenceInOrder) {\n\t\tif ((cmd->cmd_flags & ICF_WITHIN_COMMAND_RECOVERY) &&\n\t\t    cmd->write_data_done != be32_to_cpu(hdr->offset))\n\t\t\tgoto dump;\n\n\t\tcmd->cmd_flags &= ~ICF_WITHIN_COMMAND_RECOVERY;\n\t} else {\n\t\tstruct iscsi_seq *seq;\n\n\t\tseq = iscsit_get_seq_holder(cmd, be32_to_cpu(hdr->offset),\n\t\t\t\t\t    payload_length);\n\t\tif (!seq)\n\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t \n\t\tcmd->seq_ptr = seq;\n\n\t\tif (conn->sess->sess_ops->DataPDUInOrder) {\n\t\t\tif (seq->status ==\n\t\t\t    DATAOUT_SEQUENCE_WITHIN_COMMAND_RECOVERY &&\n\t\t\t   (seq->offset != be32_to_cpu(hdr->offset) ||\n\t\t\t    seq->data_sn != be32_to_cpu(hdr->datasn)))\n\t\t\t\tgoto dump;\n\t\t} else {\n\t\t\tif (seq->status ==\n\t\t\t     DATAOUT_SEQUENCE_WITHIN_COMMAND_RECOVERY &&\n\t\t\t    seq->data_sn != be32_to_cpu(hdr->datasn))\n\t\t\t\tgoto dump;\n\t\t}\n\n\t\tif (seq->status == DATAOUT_SEQUENCE_COMPLETE)\n\t\t\tgoto dump;\n\n\t\tif (seq->status != DATAOUT_SEQUENCE_COMPLETE)\n\t\t\tseq->status = 0;\n\t}\n\n\treturn DATAOUT_NORMAL;\n\ndump:\n\tpr_err(\"Dumping DataOUT PDU Offset: %u Length: %d DataSN:\"\n\t\t\" 0x%08x\\n\", hdr->offset, payload_length, hdr->datasn);\n\treturn iscsit_dump_data_payload(conn, payload_length, 1);\n}\n\nstatic int iscsit_dataout_check_unsolicited_sequence(\n\tstruct iscsit_cmd *cmd,\n\tunsigned char *buf)\n{\n\tu32 first_burst_len;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_data *hdr = (struct iscsi_data *) buf;\n\tu32 payload_length = ntoh24(hdr->dlength);\n\n\n\tif ((be32_to_cpu(hdr->offset) < cmd->seq_start_offset) ||\n\t   ((be32_to_cpu(hdr->offset) + payload_length) > cmd->seq_end_offset)) {\n\t\tpr_err(\"Command ITT: 0x%08x with Offset: %u,\"\n\t\t\" Length: %u outside of Unsolicited Sequence %u:%u while\"\n\t\t\" DataSequenceInOrder=Yes.\\n\", cmd->init_task_tag,\n\t\tbe32_to_cpu(hdr->offset), payload_length, cmd->seq_start_offset,\n\t\t\tcmd->seq_end_offset);\n\t\treturn DATAOUT_CANNOT_RECOVER;\n\t}\n\n\tfirst_burst_len = (cmd->first_burst_len + payload_length);\n\n\tif (first_burst_len > conn->sess->sess_ops->FirstBurstLength) {\n\t\tpr_err(\"Total %u bytes exceeds FirstBurstLength: %u\"\n\t\t\t\" for this Unsolicited DataOut Burst.\\n\",\n\t\t\tfirst_burst_len, conn->sess->sess_ops->FirstBurstLength);\n\t\ttransport_send_check_condition_and_sense(&cmd->se_cmd,\n\t\t\t\tTCM_INCORRECT_AMOUNT_OF_DATA, 0);\n\t\treturn DATAOUT_CANNOT_RECOVER;\n\t}\n\n\t \n\tif (hdr->flags & ISCSI_FLAG_CMD_FINAL) {\n\t\t \n\t\tif (!conn->sess->sess_ops->DataPDUInOrder)\n\t\t\tgoto out;\n\n\t\tif ((first_burst_len != cmd->se_cmd.data_length) &&\n\t\t    (first_burst_len != conn->sess->sess_ops->FirstBurstLength)) {\n\t\t\tpr_err(\"Unsolicited non-immediate data\"\n\t\t\t\" received %u does not equal FirstBurstLength: %u, and\"\n\t\t\t\" does not equal ExpXferLen %u.\\n\", first_burst_len,\n\t\t\t\tconn->sess->sess_ops->FirstBurstLength,\n\t\t\t\tcmd->se_cmd.data_length);\n\t\t\ttransport_send_check_condition_and_sense(&cmd->se_cmd,\n\t\t\t\t\tTCM_INCORRECT_AMOUNT_OF_DATA, 0);\n\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t}\n\t} else {\n\t\tif (first_burst_len == conn->sess->sess_ops->FirstBurstLength) {\n\t\t\tpr_err(\"Command ITT: 0x%08x reached\"\n\t\t\t\" FirstBurstLength: %u, but ISCSI_FLAG_CMD_FINAL is not set. protocol\"\n\t\t\t\t\" error.\\n\", cmd->init_task_tag,\n\t\t\t\tconn->sess->sess_ops->FirstBurstLength);\n\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t}\n\t\tif (first_burst_len == cmd->se_cmd.data_length) {\n\t\t\tpr_err(\"Command ITT: 0x%08x reached\"\n\t\t\t\" ExpXferLen: %u, but ISCSI_FLAG_CMD_FINAL is not set. protocol\"\n\t\t\t\" error.\\n\", cmd->init_task_tag, cmd->se_cmd.data_length);\n\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t}\n\t}\n\nout:\n\treturn DATAOUT_NORMAL;\n}\n\nstatic int iscsit_dataout_check_sequence(\n\tstruct iscsit_cmd *cmd,\n\tunsigned char *buf)\n{\n\tu32 next_burst_len;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_seq *seq = NULL;\n\tstruct iscsi_data *hdr = (struct iscsi_data *) buf;\n\tu32 payload_length = ntoh24(hdr->dlength);\n\n\t \n\tif (conn->sess->sess_ops->DataSequenceInOrder) {\n\t\t \n\t\tif ((be32_to_cpu(hdr->offset) < cmd->seq_start_offset) ||\n\t\t   ((be32_to_cpu(hdr->offset) + payload_length) > cmd->seq_end_offset)) {\n\t\t\tpr_err(\"Command ITT: 0x%08x with Offset: %u,\"\n\t\t\t\" Length: %u outside of Sequence %u:%u while\"\n\t\t\t\" DataSequenceInOrder=Yes.\\n\", cmd->init_task_tag,\n\t\t\tbe32_to_cpu(hdr->offset), payload_length, cmd->seq_start_offset,\n\t\t\t\tcmd->seq_end_offset);\n\n\t\t\tif (iscsit_dump_data_payload(conn, payload_length, 1) < 0)\n\t\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t\treturn DATAOUT_WITHIN_COMMAND_RECOVERY;\n\t\t}\n\n\t\tnext_burst_len = (cmd->next_burst_len + payload_length);\n\t} else {\n\t\tseq = iscsit_get_seq_holder(cmd, be32_to_cpu(hdr->offset),\n\t\t\t\t\t    payload_length);\n\t\tif (!seq)\n\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t \n\t\tcmd->seq_ptr = seq;\n\n\t\tif (seq->status == DATAOUT_SEQUENCE_COMPLETE) {\n\t\t\tif (iscsit_dump_data_payload(conn, payload_length, 1) < 0)\n\t\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t\treturn DATAOUT_WITHIN_COMMAND_RECOVERY;\n\t\t}\n\n\t\tnext_burst_len = (seq->next_burst_len + payload_length);\n\t}\n\n\tif (next_burst_len > conn->sess->sess_ops->MaxBurstLength) {\n\t\tpr_err(\"Command ITT: 0x%08x, NextBurstLength: %u and\"\n\t\t\t\" Length: %u exceeds MaxBurstLength: %u. protocol\"\n\t\t\t\" error.\\n\", cmd->init_task_tag,\n\t\t\t(next_burst_len - payload_length),\n\t\t\tpayload_length, conn->sess->sess_ops->MaxBurstLength);\n\t\treturn DATAOUT_CANNOT_RECOVER;\n\t}\n\n\t \n\tif (hdr->flags & ISCSI_FLAG_CMD_FINAL) {\n\t\t \n\t\tif (!conn->sess->sess_ops->DataPDUInOrder)\n\t\t\tgoto out;\n\n\t\tif (conn->sess->sess_ops->DataSequenceInOrder) {\n\t\t\tif ((next_burst_len <\n\t\t\t     conn->sess->sess_ops->MaxBurstLength) &&\n\t\t\t   ((cmd->write_data_done + payload_length) <\n\t\t\t     cmd->se_cmd.data_length)) {\n\t\t\t\tpr_err(\"Command ITT: 0x%08x set ISCSI_FLAG_CMD_FINAL\"\n\t\t\t\t\" before end of DataOUT sequence, protocol\"\n\t\t\t\t\" error.\\n\", cmd->init_task_tag);\n\t\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t\t}\n\t\t} else {\n\t\t\tif (next_burst_len < seq->xfer_len) {\n\t\t\t\tpr_err(\"Command ITT: 0x%08x set ISCSI_FLAG_CMD_FINAL\"\n\t\t\t\t\" before end of DataOUT sequence, protocol\"\n\t\t\t\t\" error.\\n\", cmd->init_task_tag);\n\t\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (conn->sess->sess_ops->DataSequenceInOrder) {\n\t\t\tif (next_burst_len ==\n\t\t\t\t\tconn->sess->sess_ops->MaxBurstLength) {\n\t\t\t\tpr_err(\"Command ITT: 0x%08x reached\"\n\t\t\t\t\" MaxBurstLength: %u, but ISCSI_FLAG_CMD_FINAL is\"\n\t\t\t\t\" not set, protocol error.\", cmd->init_task_tag,\n\t\t\t\t\tconn->sess->sess_ops->MaxBurstLength);\n\t\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t\t}\n\t\t\tif ((cmd->write_data_done + payload_length) ==\n\t\t\t\t\tcmd->se_cmd.data_length) {\n\t\t\t\tpr_err(\"Command ITT: 0x%08x reached\"\n\t\t\t\t\" last DataOUT PDU in sequence but ISCSI_FLAG_\"\n\t\t\t\t\"CMD_FINAL is not set, protocol error.\\n\",\n\t\t\t\t\tcmd->init_task_tag);\n\t\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t\t}\n\t\t} else {\n\t\t\tif (next_burst_len == seq->xfer_len) {\n\t\t\t\tpr_err(\"Command ITT: 0x%08x reached\"\n\t\t\t\t\" last DataOUT PDU in sequence but ISCSI_FLAG_\"\n\t\t\t\t\"CMD_FINAL is not set, protocol error.\\n\",\n\t\t\t\t\tcmd->init_task_tag);\n\t\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\treturn DATAOUT_NORMAL;\n}\n\nstatic int iscsit_dataout_check_datasn(\n\tstruct iscsit_cmd *cmd,\n\tunsigned char *buf)\n{\n\tu32 data_sn = 0;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_data *hdr = (struct iscsi_data *) buf;\n\tu32 payload_length = ntoh24(hdr->dlength);\n\n\t \n\tif (conn->sess->sess_ops->DataSequenceInOrder)\n\t\tdata_sn = cmd->data_sn;\n\telse {\n\t\tstruct iscsi_seq *seq = cmd->seq_ptr;\n\t\tdata_sn = seq->data_sn;\n\t}\n\n\tif (be32_to_cpu(hdr->datasn) > data_sn) {\n\t\tpr_err(\"Command ITT: 0x%08x, received DataSN: 0x%08x\"\n\t\t\t\" higher than expected 0x%08x.\\n\", cmd->init_task_tag,\n\t\t\t\tbe32_to_cpu(hdr->datasn), data_sn);\n\t\tgoto recover;\n\t} else if (be32_to_cpu(hdr->datasn) < data_sn) {\n\t\tpr_err(\"Command ITT: 0x%08x, received DataSN: 0x%08x\"\n\t\t\t\" lower than expected 0x%08x, discarding payload.\\n\",\n\t\t\tcmd->init_task_tag, be32_to_cpu(hdr->datasn), data_sn);\n\t\tgoto dump;\n\t}\n\n\treturn DATAOUT_NORMAL;\n\nrecover:\n\tif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\n\t\tpr_err(\"Unable to perform within-command recovery\"\n\t\t\t\t\" while ERL=0.\\n\");\n\t\treturn DATAOUT_CANNOT_RECOVER;\n\t}\ndump:\n\tif (iscsit_dump_data_payload(conn, payload_length, 1) < 0)\n\t\treturn DATAOUT_CANNOT_RECOVER;\n\n\treturn DATAOUT_WITHIN_COMMAND_RECOVERY;\n}\n\nstatic int iscsit_dataout_pre_datapduinorder_yes(\n\tstruct iscsit_cmd *cmd,\n\tunsigned char *buf)\n{\n\tint dump = 0, recovery = 0;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_data *hdr = (struct iscsi_data *) buf;\n\tu32 payload_length = ntoh24(hdr->dlength);\n\n\t \n\tif (conn->sess->sess_ops->DataSequenceInOrder) {\n\t\tif (be32_to_cpu(hdr->offset) != cmd->write_data_done) {\n\t\t\tpr_err(\"Command ITT: 0x%08x, received offset\"\n\t\t\t\" %u different than expected %u.\\n\", cmd->init_task_tag,\n\t\t\t\tbe32_to_cpu(hdr->offset), cmd->write_data_done);\n\t\t\trecovery = 1;\n\t\t\tgoto recover;\n\t\t}\n\t} else {\n\t\tstruct iscsi_seq *seq = cmd->seq_ptr;\n\n\t\tif (be32_to_cpu(hdr->offset) > seq->offset) {\n\t\t\tpr_err(\"Command ITT: 0x%08x, received offset\"\n\t\t\t\" %u greater than expected %u.\\n\", cmd->init_task_tag,\n\t\t\t\tbe32_to_cpu(hdr->offset), seq->offset);\n\t\t\trecovery = 1;\n\t\t\tgoto recover;\n\t\t} else if (be32_to_cpu(hdr->offset) < seq->offset) {\n\t\t\tpr_err(\"Command ITT: 0x%08x, received offset\"\n\t\t\t\" %u less than expected %u, discarding payload.\\n\",\n\t\t\t\tcmd->init_task_tag, be32_to_cpu(hdr->offset),\n\t\t\t\tseq->offset);\n\t\t\tdump = 1;\n\t\t\tgoto dump;\n\t\t}\n\t}\n\n\treturn DATAOUT_NORMAL;\n\nrecover:\n\tif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\n\t\tpr_err(\"Unable to perform within-command recovery\"\n\t\t\t\t\" while ERL=0.\\n\");\n\t\treturn DATAOUT_CANNOT_RECOVER;\n\t}\ndump:\n\tif (iscsit_dump_data_payload(conn, payload_length, 1) < 0)\n\t\treturn DATAOUT_CANNOT_RECOVER;\n\n\treturn (recovery) ? iscsit_recover_dataout_sequence(cmd,\n\t\tbe32_to_cpu(hdr->offset), payload_length) :\n\t       (dump) ? DATAOUT_WITHIN_COMMAND_RECOVERY : DATAOUT_NORMAL;\n}\n\nstatic int iscsit_dataout_pre_datapduinorder_no(\n\tstruct iscsit_cmd *cmd,\n\tunsigned char *buf)\n{\n\tstruct iscsi_pdu *pdu;\n\tstruct iscsi_data *hdr = (struct iscsi_data *) buf;\n\tu32 payload_length = ntoh24(hdr->dlength);\n\n\tpdu = iscsit_get_pdu_holder(cmd, be32_to_cpu(hdr->offset),\n\t\t\t\t    payload_length);\n\tif (!pdu)\n\t\treturn DATAOUT_CANNOT_RECOVER;\n\n\tcmd->pdu_ptr = pdu;\n\n\tswitch (pdu->status) {\n\tcase ISCSI_PDU_NOT_RECEIVED:\n\tcase ISCSI_PDU_CRC_FAILED:\n\tcase ISCSI_PDU_TIMED_OUT:\n\t\tbreak;\n\tcase ISCSI_PDU_RECEIVED_OK:\n\t\tpr_err(\"Command ITT: 0x%08x received already gotten\"\n\t\t\t\" Offset: %u, Length: %u\\n\", cmd->init_task_tag,\n\t\t\t\tbe32_to_cpu(hdr->offset), payload_length);\n\t\treturn iscsit_dump_data_payload(cmd->conn, payload_length, 1);\n\tdefault:\n\t\treturn DATAOUT_CANNOT_RECOVER;\n\t}\n\n\treturn DATAOUT_NORMAL;\n}\n\nstatic int iscsit_dataout_update_r2t(struct iscsit_cmd *cmd, u32 offset, u32 length)\n{\n\tstruct iscsi_r2t *r2t;\n\n\tif (cmd->unsolicited_data)\n\t\treturn 0;\n\n\tr2t = iscsit_get_r2t_for_eos(cmd, offset, length);\n\tif (!r2t)\n\t\treturn -1;\n\n\tspin_lock_bh(&cmd->r2t_lock);\n\tr2t->seq_complete = 1;\n\tcmd->outstanding_r2ts--;\n\tspin_unlock_bh(&cmd->r2t_lock);\n\n\treturn 0;\n}\n\nstatic int iscsit_dataout_update_datapduinorder_no(\n\tstruct iscsit_cmd *cmd,\n\tu32 data_sn,\n\tint f_bit)\n{\n\tint ret = 0;\n\tstruct iscsi_pdu *pdu = cmd->pdu_ptr;\n\n\tpdu->data_sn = data_sn;\n\n\tswitch (pdu->status) {\n\tcase ISCSI_PDU_NOT_RECEIVED:\n\t\tpdu->status = ISCSI_PDU_RECEIVED_OK;\n\t\tbreak;\n\tcase ISCSI_PDU_CRC_FAILED:\n\t\tpdu->status = ISCSI_PDU_RECEIVED_OK;\n\t\tbreak;\n\tcase ISCSI_PDU_TIMED_OUT:\n\t\tpdu->status = ISCSI_PDU_RECEIVED_OK;\n\t\tbreak;\n\tdefault:\n\t\treturn DATAOUT_CANNOT_RECOVER;\n\t}\n\n\tif (f_bit) {\n\t\tret = iscsit_dataout_datapduinorder_no_fbit(cmd, pdu);\n\t\tif (ret == DATAOUT_CANNOT_RECOVER)\n\t\t\treturn ret;\n\t}\n\n\treturn DATAOUT_NORMAL;\n}\n\nstatic int iscsit_dataout_post_crc_passed(\n\tstruct iscsit_cmd *cmd,\n\tunsigned char *buf)\n{\n\tint ret, send_r2t = 0;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_seq *seq = NULL;\n\tstruct iscsi_data *hdr = (struct iscsi_data *) buf;\n\tu32 payload_length = ntoh24(hdr->dlength);\n\n\tif (cmd->unsolicited_data) {\n\t\tif ((cmd->first_burst_len + payload_length) ==\n\t\t     conn->sess->sess_ops->FirstBurstLength) {\n\t\t\tif (iscsit_dataout_update_r2t(cmd, be32_to_cpu(hdr->offset),\n\t\t\t\t\tpayload_length) < 0)\n\t\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t\tsend_r2t = 1;\n\t\t}\n\n\t\tif (!conn->sess->sess_ops->DataPDUInOrder) {\n\t\t\tret = iscsit_dataout_update_datapduinorder_no(cmd,\n\t\t\t\tbe32_to_cpu(hdr->datasn),\n\t\t\t\t(hdr->flags & ISCSI_FLAG_CMD_FINAL));\n\t\t\tif (ret == DATAOUT_CANNOT_RECOVER)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tcmd->first_burst_len += payload_length;\n\n\t\tif (conn->sess->sess_ops->DataSequenceInOrder)\n\t\t\tcmd->data_sn++;\n\t\telse {\n\t\t\tseq = cmd->seq_ptr;\n\t\t\tseq->data_sn++;\n\t\t\tseq->offset += payload_length;\n\t\t}\n\n\t\tif (send_r2t) {\n\t\t\tif (seq)\n\t\t\t\tseq->status = DATAOUT_SEQUENCE_COMPLETE;\n\t\t\tcmd->first_burst_len = 0;\n\t\t\tcmd->unsolicited_data = 0;\n\t\t}\n\t} else {\n\t\tif (conn->sess->sess_ops->DataSequenceInOrder) {\n\t\t\tif ((cmd->next_burst_len + payload_length) ==\n\t\t\t     conn->sess->sess_ops->MaxBurstLength) {\n\t\t\t\tif (iscsit_dataout_update_r2t(cmd,\n\t\t\t\t\t\tbe32_to_cpu(hdr->offset),\n\t\t\t\t\t\tpayload_length) < 0)\n\t\t\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t\t\tsend_r2t = 1;\n\t\t\t}\n\n\t\t\tif (!conn->sess->sess_ops->DataPDUInOrder) {\n\t\t\t\tret = iscsit_dataout_update_datapduinorder_no(\n\t\t\t\t\t\tcmd, be32_to_cpu(hdr->datasn),\n\t\t\t\t\t\t(hdr->flags & ISCSI_FLAG_CMD_FINAL));\n\t\t\t\tif (ret == DATAOUT_CANNOT_RECOVER)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tcmd->next_burst_len += payload_length;\n\t\t\tcmd->data_sn++;\n\n\t\t\tif (send_r2t)\n\t\t\t\tcmd->next_burst_len = 0;\n\t\t} else {\n\t\t\tseq = cmd->seq_ptr;\n\n\t\t\tif ((seq->next_burst_len + payload_length) ==\n\t\t\t     seq->xfer_len) {\n\t\t\t\tif (iscsit_dataout_update_r2t(cmd,\n\t\t\t\t\t\tbe32_to_cpu(hdr->offset),\n\t\t\t\t\t\tpayload_length) < 0)\n\t\t\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t\t\tsend_r2t = 1;\n\t\t\t}\n\n\t\t\tif (!conn->sess->sess_ops->DataPDUInOrder) {\n\t\t\t\tret = iscsit_dataout_update_datapduinorder_no(\n\t\t\t\t\t\tcmd, be32_to_cpu(hdr->datasn),\n\t\t\t\t\t\t(hdr->flags & ISCSI_FLAG_CMD_FINAL));\n\t\t\t\tif (ret == DATAOUT_CANNOT_RECOVER)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tseq->data_sn++;\n\t\t\tseq->offset += payload_length;\n\t\t\tseq->next_burst_len += payload_length;\n\n\t\t\tif (send_r2t) {\n\t\t\t\tseq->next_burst_len = 0;\n\t\t\t\tseq->status = DATAOUT_SEQUENCE_COMPLETE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (send_r2t && conn->sess->sess_ops->DataSequenceInOrder)\n\t\tcmd->data_sn = 0;\n\n\tcmd->write_data_done += payload_length;\n\n\tif (cmd->write_data_done == cmd->se_cmd.data_length)\n\t\treturn DATAOUT_SEND_TO_TRANSPORT;\n\telse if (send_r2t)\n\t\treturn DATAOUT_SEND_R2T;\n\telse\n\t\treturn DATAOUT_NORMAL;\n}\n\nstatic int iscsit_dataout_post_crc_failed(\n\tstruct iscsit_cmd *cmd,\n\tunsigned char *buf)\n{\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_pdu *pdu;\n\tstruct iscsi_data *hdr = (struct iscsi_data *) buf;\n\tu32 payload_length = ntoh24(hdr->dlength);\n\n\tif (conn->sess->sess_ops->DataPDUInOrder)\n\t\tgoto recover;\n\t \n\tpdu = cmd->pdu_ptr;\n\n\tswitch (pdu->status) {\n\tcase ISCSI_PDU_NOT_RECEIVED:\n\t\tpdu->status = ISCSI_PDU_CRC_FAILED;\n\t\tbreak;\n\tcase ISCSI_PDU_CRC_FAILED:\n\t\tbreak;\n\tcase ISCSI_PDU_TIMED_OUT:\n\t\tpdu->status = ISCSI_PDU_CRC_FAILED;\n\t\tbreak;\n\tdefault:\n\t\treturn DATAOUT_CANNOT_RECOVER;\n\t}\n\nrecover:\n\treturn iscsit_recover_dataout_sequence(cmd, be32_to_cpu(hdr->offset),\n\t\t\t\t\t\tpayload_length);\n}\n\n \nint iscsit_check_pre_dataout(\n\tstruct iscsit_cmd *cmd,\n\tunsigned char *buf)\n{\n\tint ret;\n\tstruct iscsit_conn *conn = cmd->conn;\n\n\tret = iscsit_dataout_within_command_recovery_check(cmd, buf);\n\tif ((ret == DATAOUT_WITHIN_COMMAND_RECOVERY) ||\n\t    (ret == DATAOUT_CANNOT_RECOVER))\n\t\treturn ret;\n\n\tret = iscsit_dataout_check_datasn(cmd, buf);\n\tif ((ret == DATAOUT_WITHIN_COMMAND_RECOVERY) ||\n\t    (ret == DATAOUT_CANNOT_RECOVER))\n\t\treturn ret;\n\n\tif (cmd->unsolicited_data) {\n\t\tret = iscsit_dataout_check_unsolicited_sequence(cmd, buf);\n\t\tif ((ret == DATAOUT_WITHIN_COMMAND_RECOVERY) ||\n\t\t    (ret == DATAOUT_CANNOT_RECOVER))\n\t\t\treturn ret;\n\t} else {\n\t\tret = iscsit_dataout_check_sequence(cmd, buf);\n\t\tif ((ret == DATAOUT_WITHIN_COMMAND_RECOVERY) ||\n\t\t    (ret == DATAOUT_CANNOT_RECOVER))\n\t\t\treturn ret;\n\t}\n\n\treturn (conn->sess->sess_ops->DataPDUInOrder) ?\n\t\tiscsit_dataout_pre_datapduinorder_yes(cmd, buf) :\n\t\tiscsit_dataout_pre_datapduinorder_no(cmd, buf);\n}\n\n \nint iscsit_check_post_dataout(\n\tstruct iscsit_cmd *cmd,\n\tunsigned char *buf,\n\tu8 data_crc_failed)\n{\n\tstruct iscsit_conn *conn = cmd->conn;\n\n\tcmd->dataout_timeout_retries = 0;\n\n\tif (!data_crc_failed)\n\t\treturn iscsit_dataout_post_crc_passed(cmd, buf);\n\telse {\n\t\tif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\n\t\t\tpr_err(\"Unable to recover from DataOUT CRC\"\n\t\t\t\t\" failure while ERL=0, closing session.\\n\");\n\t\t\tiscsit_reject_cmd(cmd, ISCSI_REASON_DATA_DIGEST_ERROR,\n\t\t\t\t\t  buf);\n\t\t\treturn DATAOUT_CANNOT_RECOVER;\n\t\t}\n\n\t\tiscsit_reject_cmd(cmd, ISCSI_REASON_DATA_DIGEST_ERROR, buf);\n\t\treturn iscsit_dataout_post_crc_failed(cmd, buf);\n\t}\n}\n\nvoid iscsit_handle_time2retain_timeout(struct timer_list *t)\n{\n\tstruct iscsit_session *sess = from_timer(sess, t, time2retain_timer);\n\tstruct iscsi_portal_group *tpg = sess->tpg;\n\tstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\n\n\tspin_lock_bh(&se_tpg->session_lock);\n\tif (sess->time2retain_timer_flags & ISCSI_TF_STOP) {\n\t\tspin_unlock_bh(&se_tpg->session_lock);\n\t\treturn;\n\t}\n\tif (atomic_read(&sess->session_reinstatement)) {\n\t\tpr_err(\"Exiting Time2Retain handler because\"\n\t\t\t\t\" session_reinstatement=1\\n\");\n\t\tspin_unlock_bh(&se_tpg->session_lock);\n\t\treturn;\n\t}\n\tsess->time2retain_timer_flags |= ISCSI_TF_EXPIRED;\n\n\tpr_err(\"Time2Retain timer expired for SID: %u, cleaning up\"\n\t\t\t\" iSCSI session.\\n\", sess->sid);\n\n\tiscsit_fill_cxn_timeout_err_stats(sess);\n\tspin_unlock_bh(&se_tpg->session_lock);\n\tiscsit_close_session(sess, false);\n}\n\nvoid iscsit_start_time2retain_handler(struct iscsit_session *sess)\n{\n\tint tpg_active;\n\t \n\tspin_lock(&sess->tpg->tpg_state_lock);\n\ttpg_active = (sess->tpg->tpg_state == TPG_STATE_ACTIVE);\n\tspin_unlock(&sess->tpg->tpg_state_lock);\n\n\tif (!tpg_active)\n\t\treturn;\n\n\tif (sess->time2retain_timer_flags & ISCSI_TF_RUNNING)\n\t\treturn;\n\n\tpr_debug(\"Starting Time2Retain timer for %u seconds on\"\n\t\t\" SID: %u\\n\", sess->sess_ops->DefaultTime2Retain, sess->sid);\n\n\tsess->time2retain_timer_flags &= ~ISCSI_TF_STOP;\n\tsess->time2retain_timer_flags |= ISCSI_TF_RUNNING;\n\tmod_timer(&sess->time2retain_timer,\n\t\t  jiffies + sess->sess_ops->DefaultTime2Retain * HZ);\n}\n\nint iscsit_stop_time2retain_timer(struct iscsit_session *sess)\n{\n\tstruct iscsi_portal_group *tpg = sess->tpg;\n\tstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\n\n\tlockdep_assert_held(&se_tpg->session_lock);\n\n\tif (sess->time2retain_timer_flags & ISCSI_TF_EXPIRED)\n\t\treturn -1;\n\n\tif (!(sess->time2retain_timer_flags & ISCSI_TF_RUNNING))\n\t\treturn 0;\n\n\tsess->time2retain_timer_flags |= ISCSI_TF_STOP;\n\tspin_unlock(&se_tpg->session_lock);\n\n\tdel_timer_sync(&sess->time2retain_timer);\n\n\tspin_lock(&se_tpg->session_lock);\n\tsess->time2retain_timer_flags &= ~ISCSI_TF_RUNNING;\n\tpr_debug(\"Stopped Time2Retain Timer for SID: %u\\n\",\n\t\t\tsess->sid);\n\treturn 0;\n}\n\nvoid iscsit_connection_reinstatement_rcfr(struct iscsit_conn *conn)\n{\n\tspin_lock_bh(&conn->state_lock);\n\tif (atomic_read(&conn->connection_exit)) {\n\t\tspin_unlock_bh(&conn->state_lock);\n\t\tgoto sleep;\n\t}\n\n\tif (atomic_read(&conn->transport_failed)) {\n\t\tspin_unlock_bh(&conn->state_lock);\n\t\tgoto sleep;\n\t}\n\tspin_unlock_bh(&conn->state_lock);\n\n\tif (conn->tx_thread && conn->tx_thread_active)\n\t\tsend_sig(SIGINT, conn->tx_thread, 1);\n\tif (conn->rx_thread && conn->rx_thread_active)\n\t\tsend_sig(SIGINT, conn->rx_thread, 1);\n\nsleep:\n\twait_for_completion(&conn->conn_wait_rcfr_comp);\n\tcomplete(&conn->conn_post_wait_comp);\n}\n\nvoid iscsit_cause_connection_reinstatement(struct iscsit_conn *conn, int sleep)\n{\n\tspin_lock_bh(&conn->state_lock);\n\tif (atomic_read(&conn->connection_exit)) {\n\t\tspin_unlock_bh(&conn->state_lock);\n\t\treturn;\n\t}\n\n\tif (atomic_read(&conn->transport_failed)) {\n\t\tspin_unlock_bh(&conn->state_lock);\n\t\treturn;\n\t}\n\n\tif (atomic_read(&conn->connection_reinstatement)) {\n\t\tspin_unlock_bh(&conn->state_lock);\n\t\treturn;\n\t}\n\n\tif (conn->tx_thread && conn->tx_thread_active)\n\t\tsend_sig(SIGINT, conn->tx_thread, 1);\n\tif (conn->rx_thread && conn->rx_thread_active)\n\t\tsend_sig(SIGINT, conn->rx_thread, 1);\n\n\tatomic_set(&conn->connection_reinstatement, 1);\n\tif (!sleep) {\n\t\tspin_unlock_bh(&conn->state_lock);\n\t\treturn;\n\t}\n\n\tatomic_set(&conn->sleep_on_conn_wait_comp, 1);\n\tspin_unlock_bh(&conn->state_lock);\n\n\twait_for_completion(&conn->conn_wait_comp);\n\tcomplete(&conn->conn_post_wait_comp);\n}\nEXPORT_SYMBOL(iscsit_cause_connection_reinstatement);\n\nvoid iscsit_fall_back_to_erl0(struct iscsit_session *sess)\n{\n\tpr_debug(\"Falling back to ErrorRecoveryLevel=0 for SID:\"\n\t\t\t\" %u\\n\", sess->sid);\n\n\tatomic_set(&sess->session_fall_back_to_erl0, 1);\n}\n\nstatic void iscsit_handle_connection_cleanup(struct iscsit_conn *conn)\n{\n\tstruct iscsit_session *sess = conn->sess;\n\n\tif ((sess->sess_ops->ErrorRecoveryLevel == 2) &&\n\t    !atomic_read(&sess->session_reinstatement) &&\n\t    !atomic_read(&sess->session_fall_back_to_erl0))\n\t\tiscsit_connection_recovery_transport_reset(conn);\n\telse {\n\t\tpr_debug(\"Performing cleanup for failed iSCSI\"\n\t\t\t\" Connection ID: %hu from %s\\n\", conn->cid,\n\t\t\tsess->sess_ops->InitiatorName);\n\t\tiscsit_close_connection(conn);\n\t}\n}\n\nvoid iscsit_take_action_for_connection_exit(struct iscsit_conn *conn, bool *conn_freed)\n{\n\t*conn_freed = false;\n\n\tspin_lock_bh(&conn->state_lock);\n\tif (atomic_read(&conn->connection_exit)) {\n\t\tspin_unlock_bh(&conn->state_lock);\n\t\treturn;\n\t}\n\tatomic_set(&conn->connection_exit, 1);\n\n\tif (conn->conn_state == TARG_CONN_STATE_IN_LOGOUT) {\n\t\tspin_unlock_bh(&conn->state_lock);\n\t\tiscsit_close_connection(conn);\n\t\t*conn_freed = true;\n\t\treturn;\n\t}\n\n\tif (conn->conn_state == TARG_CONN_STATE_CLEANUP_WAIT) {\n\t\tspin_unlock_bh(&conn->state_lock);\n\t\treturn;\n\t}\n\n\tpr_debug(\"Moving to TARG_CONN_STATE_CLEANUP_WAIT.\\n\");\n\tconn->conn_state = TARG_CONN_STATE_CLEANUP_WAIT;\n\tspin_unlock_bh(&conn->state_lock);\n\n\tiscsit_handle_connection_cleanup(conn);\n\t*conn_freed = true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}