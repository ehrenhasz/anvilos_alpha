{
  "module_name": "iscsi_target_auth.c",
  "hash_id": "68ba8d07b0336b4944e0a57148e8d473911cb4802c54ed6cd5d7a984390e2de2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target_auth.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <target/iscsi/iscsi_target_core.h>\n#include \"iscsi_target_nego.h\"\n#include \"iscsi_target_auth.h\"\n\nstatic char *chap_get_digest_name(const int digest_type)\n{\n\tswitch (digest_type) {\n\tcase CHAP_DIGEST_MD5:\n\t\treturn \"md5\";\n\tcase CHAP_DIGEST_SHA1:\n\t\treturn \"sha1\";\n\tcase CHAP_DIGEST_SHA256:\n\t\treturn \"sha256\";\n\tcase CHAP_DIGEST_SHA3_256:\n\t\treturn \"sha3-256\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int chap_gen_challenge(\n\tstruct iscsit_conn *conn,\n\tint caller,\n\tchar *c_str,\n\tunsigned int *c_len)\n{\n\tint ret;\n\tunsigned char *challenge_asciihex;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\n\tchallenge_asciihex = kzalloc(chap->challenge_len * 2 + 1, GFP_KERNEL);\n\tif (!challenge_asciihex)\n\t\treturn -ENOMEM;\n\n\tmemset(chap->challenge, 0, MAX_CHAP_CHALLENGE_LEN);\n\n\tret = get_random_bytes_wait(chap->challenge, chap->challenge_len);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tbin2hex(challenge_asciihex, chap->challenge,\n\t\t\t\tchap->challenge_len);\n\t \n\t*c_len += sprintf(c_str + *c_len, \"CHAP_C=0x%s\", challenge_asciihex);\n\t*c_len += 1;\n\n\tpr_debug(\"[%s] Sending CHAP_C=0x%s\\n\\n\", (caller) ? \"server\" : \"client\",\n\t\t\tchallenge_asciihex);\n\nout:\n\tkfree(challenge_asciihex);\n\treturn ret;\n}\n\nstatic int chap_test_algorithm(const char *name)\n{\n\tstruct crypto_shash *tfm;\n\n\ttfm = crypto_alloc_shash(name, 0, 0);\n\tif (IS_ERR(tfm))\n\t\treturn -1;\n\n\tcrypto_free_shash(tfm);\n\treturn 0;\n}\n\nstatic int chap_check_algorithm(const char *a_str)\n{\n\tchar *tmp, *orig, *token, *digest_name;\n\tlong digest_type;\n\tint r = CHAP_DIGEST_UNKNOWN;\n\n\ttmp = kstrdup(a_str, GFP_KERNEL);\n\tif (!tmp) {\n\t\tpr_err(\"Memory allocation failed for CHAP_A temporary buffer\\n\");\n\t\treturn CHAP_DIGEST_UNKNOWN;\n\t}\n\torig = tmp;\n\n\ttoken = strsep(&tmp, \"=\");\n\tif (!token)\n\t\tgoto out;\n\n\tif (strcmp(token, \"CHAP_A\")) {\n\t\tpr_err(\"Unable to locate CHAP_A key\\n\");\n\t\tgoto out;\n\t}\n\twhile (token) {\n\t\ttoken = strsep(&tmp, \",\");\n\t\tif (!token)\n\t\t\tgoto out;\n\n\t\tif (kstrtol(token, 10, &digest_type))\n\t\t\tcontinue;\n\n\t\tdigest_name = chap_get_digest_name(digest_type);\n\t\tif (!digest_name)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"Selected %s Algorithm\\n\", digest_name);\n\t\tif (chap_test_algorithm(digest_name) < 0) {\n\t\t\tpr_err(\"failed to allocate %s algo\\n\", digest_name);\n\t\t} else {\n\t\t\tr = digest_type;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tkfree(orig);\n\treturn r;\n}\n\nstatic void chap_close(struct iscsit_conn *conn)\n{\n\tkfree(conn->auth_protocol);\n\tconn->auth_protocol = NULL;\n}\n\nstatic struct iscsi_chap *chap_server_open(\n\tstruct iscsit_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tconst char *a_str,\n\tchar *aic_str,\n\tunsigned int *aic_len)\n{\n\tint digest_type;\n\tstruct iscsi_chap *chap;\n\n\tif (!(auth->naf_flags & NAF_USERID_SET) ||\n\t    !(auth->naf_flags & NAF_PASSWORD_SET)) {\n\t\tpr_err(\"CHAP user or password not set for\"\n\t\t\t\t\" Initiator ACL\\n\");\n\t\treturn NULL;\n\t}\n\n\tconn->auth_protocol = kzalloc(sizeof(struct iscsi_chap), GFP_KERNEL);\n\tif (!conn->auth_protocol)\n\t\treturn NULL;\n\n\tchap = conn->auth_protocol;\n\tdigest_type = chap_check_algorithm(a_str);\n\tswitch (digest_type) {\n\tcase CHAP_DIGEST_MD5:\n\t\tchap->digest_size = MD5_SIGNATURE_SIZE;\n\t\tbreak;\n\tcase CHAP_DIGEST_SHA1:\n\t\tchap->digest_size = SHA1_SIGNATURE_SIZE;\n\t\tbreak;\n\tcase CHAP_DIGEST_SHA256:\n\t\tchap->digest_size = SHA256_SIGNATURE_SIZE;\n\t\tbreak;\n\tcase CHAP_DIGEST_SHA3_256:\n\t\tchap->digest_size = SHA3_256_SIGNATURE_SIZE;\n\t\tbreak;\n\tcase CHAP_DIGEST_UNKNOWN:\n\tdefault:\n\t\tpr_err(\"Unsupported CHAP_A value\\n\");\n\t\tchap_close(conn);\n\t\treturn NULL;\n\t}\n\n\tchap->digest_name = chap_get_digest_name(digest_type);\n\n\t \n\tchap->challenge_len = chap->digest_size;\n\n\tpr_debug(\"[server] Got CHAP_A=%d\\n\", digest_type);\n\t*aic_len = sprintf(aic_str, \"CHAP_A=%d\", digest_type);\n\t*aic_len += 1;\n\tpr_debug(\"[server] Sending CHAP_A=%d\\n\", digest_type);\n\n\t \n\tchap->id = conn->tpg->tpg_chap_id++;\n\t*aic_len += sprintf(aic_str + *aic_len, \"CHAP_I=%d\", chap->id);\n\t*aic_len += 1;\n\tpr_debug(\"[server] Sending CHAP_I=%d\\n\", chap->id);\n\t \n\tif (chap_gen_challenge(conn, 1, aic_str, aic_len) < 0) {\n\t\tchap_close(conn);\n\t\treturn NULL;\n\t}\n\n\treturn chap;\n}\n\nstatic const char base64_lookup_table[] =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nstatic int chap_base64_decode(u8 *dst, const char *src, size_t len)\n{\n\tint i, bits = 0, ac = 0;\n\tconst char *p;\n\tu8 *cp = dst;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (src[i] == '=')\n\t\t\treturn cp - dst;\n\n\t\tp = strchr(base64_lookup_table, src[i]);\n\t\tif (p == NULL || src[i] == 0)\n\t\t\treturn -2;\n\n\t\tac <<= 6;\n\t\tac += (p - base64_lookup_table);\n\t\tbits += 6;\n\t\tif (bits >= 8) {\n\t\t\t*cp++ = (ac >> (bits - 8)) & 0xff;\n\t\t\tac &= ~(BIT(16) - BIT(bits - 8));\n\t\t\tbits -= 8;\n\t\t}\n\t}\n\tif (ac)\n\t\treturn -1;\n\n\treturn cp - dst;\n}\n\nstatic int chap_server_compute_hash(\n\tstruct iscsit_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char type;\n\tunsigned char identifier[10], *initiatorchg = NULL;\n\tunsigned char *initiatorchg_binhex = NULL;\n\tunsigned char *digest = NULL;\n\tunsigned char *response = NULL;\n\tunsigned char *client_digest = NULL;\n\tunsigned char *server_digest = NULL;\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, initiatorchg_len;\n\n\tdigest = kzalloc(chap->digest_size, GFP_KERNEL);\n\tif (!digest) {\n\t\tpr_err(\"Unable to allocate the digest buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tresponse = kzalloc(chap->digest_size * 2 + 2, GFP_KERNEL);\n\tif (!response) {\n\t\tpr_err(\"Unable to allocate the response buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tclient_digest = kzalloc(chap->digest_size, GFP_KERNEL);\n\tif (!client_digest) {\n\t\tpr_err(\"Unable to allocate the client_digest buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tserver_digest = kzalloc(chap->digest_size, GFP_KERNEL);\n\tif (!server_digest) {\n\t\tpr_err(\"Unable to allocate the server_digest buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\n\tinitiatorchg = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!initiatorchg) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tinitiatorchg_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!initiatorchg_binhex) {\n\t\tpr_err(\"Unable to allocate initiatorchg_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t \n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t \n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase HEX:\n\t\tif (strlen(chap_r) != chap->digest_size * 2) {\n\t\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (hex2bin(client_digest, chap_r, chap->digest_size) < 0) {\n\t\t\tpr_err(\"Malformed CHAP_R: invalid HEX\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase BASE64:\n\t\tif (chap_base64_decode(client_digest, chap_r, strlen(chap_r)) !=\n\t\t    chap->digest_size) {\n\t\t\tpr_err(\"Malformed CHAP_R: invalid BASE64\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Could not find CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\n\ttfm = crypto_alloc_shash(chap->digest_name, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t chap->challenge_len, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tbin2hex(response, server_digest, chap->digest_size);\n\tpr_debug(\"[server] %s Server Digest: %s\\n\",\n\t\tchap->digest_name, response);\n\n\tif (memcmp(server_digest, client_digest, chap->digest_size) != 0) {\n\t\tpr_debug(\"[server] %s Digests do not match!\\n\\n\",\n\t\t\tchap->digest_name);\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] %s Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\", chap->digest_name);\n\t \n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t \n\tret = extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type);\n\tif (ret == -ENOENT) {\n\t\tpr_debug(\"Could not find CHAP_I. Initiator uses One way authentication.\\n\");\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\tif (ret < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t \n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t \n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tinitiatorchg, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase HEX:\n\t\tinitiatorchg_len = DIV_ROUND_UP(strlen(initiatorchg), 2);\n\t\tif (!initiatorchg_len) {\n\t\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (initiatorchg_len > 1024) {\n\t\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (hex2bin(initiatorchg_binhex, initiatorchg,\n\t\t\t    initiatorchg_len) < 0) {\n\t\t\tpr_err(\"Malformed CHAP_C: invalid HEX\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase BASE64:\n\t\tinitiatorchg_len = chap_base64_decode(initiatorchg_binhex,\n\t\t\t\t\t\t      initiatorchg,\n\t\t\t\t\t\t      strlen(initiatorchg));\n\t\tif (initiatorchg_len < 0) {\n\t\t\tpr_err(\"Malformed CHAP_C: invalid BASE64\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (!initiatorchg_len) {\n\t\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (initiatorchg_len > 1024) {\n\t\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", initiatorchg);\n\t \n\tif (initiatorchg_len == chap->challenge_len &&\n\t\t\t\t!memcmp(initiatorchg_binhex, chap->challenge,\n\t\t\t\tinitiatorchg_len)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t \n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t \n\tret = crypto_shash_finup(desc, initiatorchg_binhex, initiatorchg_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t \n\tbin2hex(response, digest, chap->digest_size);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkfree_sensitive(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(initiatorchg);\n\tkfree(initiatorchg_binhex);\n\tkfree(digest);\n\tkfree(response);\n\tkfree(server_digest);\n\tkfree(client_digest);\n\treturn auth_ret;\n}\n\nu32 chap_main_loop(\n\tstruct iscsit_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *in_text,\n\tchar *out_text,\n\tint *in_len,\n\tint *out_len)\n{\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\n\tif (!chap) {\n\t\tchap = chap_server_open(conn, auth, in_text, out_text, out_len);\n\t\tif (!chap)\n\t\t\treturn 2;\n\t\tchap->chap_state = CHAP_STAGE_SERVER_AIC;\n\t\treturn 0;\n\t} else if (chap->chap_state == CHAP_STAGE_SERVER_AIC) {\n\t\tconvert_null_to_semi(in_text, *in_len);\n\t\tif (chap_server_compute_hash(conn, auth, in_text, out_text,\n\t\t\t\tout_len) < 0) {\n\t\t\tchap_close(conn);\n\t\t\treturn 2;\n\t\t}\n\t\tif (auth->authenticate_target)\n\t\t\tchap->chap_state = CHAP_STAGE_SERVER_NR;\n\t\telse\n\t\t\t*out_len = 0;\n\t\tchap_close(conn);\n\t\treturn 1;\n\t}\n\n\treturn 2;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}