{
  "module_name": "iscsi_target_nego.c",
  "hash_id": "74980e70dc93c01866aac326dcb8eb83e3af0ed7707df2ef684360054531877f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target_nego.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <net/sock.h>\n#include <trace/events/sock.h>\n#include <scsi/iscsi_proto.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n#include <target/iscsi/iscsi_transport.h>\n\n#include <target/iscsi/iscsi_target_core.h>\n#include \"iscsi_target_parameters.h\"\n#include \"iscsi_target_login.h\"\n#include \"iscsi_target_nego.h\"\n#include \"iscsi_target_tpg.h\"\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target.h\"\n#include \"iscsi_target_auth.h\"\n\n#define MAX_LOGIN_PDUS  7\n\nvoid convert_null_to_semi(char *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (buf[i] == '\\0')\n\t\t\tbuf[i] = ';';\n}\n\nstatic int strlen_semi(char *buf)\n{\n\tint i = 0;\n\n\twhile (buf[i] != '\\0') {\n\t\tif (buf[i] == ';')\n\t\t\treturn i;\n\t\ti++;\n\t}\n\n\treturn -1;\n}\n\nint extract_param(\n\tconst char *in_buf,\n\tconst char *pattern,\n\tunsigned int max_length,\n\tchar *out_buf,\n\tunsigned char *type)\n{\n\tchar *ptr;\n\tint len;\n\n\tif (!in_buf || !pattern || !out_buf || !type)\n\t\treturn -EINVAL;\n\n\tptr = strstr(in_buf, pattern);\n\tif (!ptr)\n\t\treturn -ENOENT;\n\n\tptr = strstr(ptr, \"=\");\n\tif (!ptr)\n\t\treturn -EINVAL;\n\n\tptr += 1;\n\tif (*ptr == '0' && (*(ptr+1) == 'x' || *(ptr+1) == 'X')) {\n\t\tptr += 2;  \n\t\t*type = HEX;\n\t} else if (*ptr == '0' && (*(ptr+1) == 'b' || *(ptr+1) == 'B')) {\n\t\tptr += 2;  \n\t\t*type = BASE64;\n\t} else\n\t\t*type = DECIMAL;\n\n\tlen = strlen_semi(ptr);\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tif (len >= max_length) {\n\t\tpr_err(\"Length of input: %d exceeds max_length:\"\n\t\t\t\" %d\\n\", len, max_length);\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(out_buf, ptr, len);\n\tout_buf[len] = '\\0';\n\n\treturn 0;\n}\n\nstatic struct iscsi_node_auth *iscsi_get_node_auth(struct iscsit_conn *conn)\n{\n\tstruct iscsi_portal_group *tpg;\n\tstruct iscsi_node_acl *nacl;\n\tstruct se_node_acl *se_nacl;\n\n\tif (conn->sess->sess_ops->SessionType)\n\t\treturn &iscsit_global->discovery_acl.node_auth;\n\n\tse_nacl = conn->sess->se_sess->se_node_acl;\n\tif (!se_nacl) {\n\t\tpr_err(\"Unable to locate struct se_node_acl for CHAP auth\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (se_nacl->dynamic_node_acl) {\n\t\ttpg = to_iscsi_tpg(se_nacl->se_tpg);\n\t\treturn &tpg->tpg_demo_auth;\n\t}\n\n\tnacl = to_iscsi_nacl(se_nacl);\n\n\treturn &nacl->node_auth;\n}\n\nstatic u32 iscsi_handle_authentication(\n\tstruct iscsit_conn *conn,\n\tchar *in_buf,\n\tchar *out_buf,\n\tint in_length,\n\tint *out_length,\n\tunsigned char *authtype)\n{\n\tstruct iscsi_node_auth *auth;\n\n\tauth = iscsi_get_node_auth(conn);\n\tif (!auth)\n\t\treturn -1;\n\n\tif (strstr(\"CHAP\", authtype))\n\t\tstrcpy(conn->sess->auth_type, \"CHAP\");\n\telse\n\t\tstrcpy(conn->sess->auth_type, NONE);\n\n\tif (strstr(\"None\", authtype))\n\t\treturn 1;\n\telse if (strstr(\"CHAP\", authtype))\n\t\treturn chap_main_loop(conn, auth, in_buf, out_buf,\n\t\t\t\t&in_length, out_length);\n\t \n\treturn 2;\n}\n\nstatic void iscsi_remove_failed_auth_entry(struct iscsit_conn *conn)\n{\n\tkfree(conn->auth_protocol);\n}\n\nint iscsi_target_check_login_request(\n\tstruct iscsit_conn *conn,\n\tstruct iscsi_login *login)\n{\n\tint req_csg, req_nsg;\n\tu32 payload_length;\n\tstruct iscsi_login_req *login_req;\n\n\tlogin_req = (struct iscsi_login_req *) login->req;\n\tpayload_length = ntoh24(login_req->dlength);\n\n\tswitch (login_req->opcode & ISCSI_OPCODE_MASK) {\n\tcase ISCSI_OP_LOGIN:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Received unknown opcode 0x%02x.\\n\",\n\t\t\t\tlogin_req->opcode & ISCSI_OPCODE_MASK);\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_INIT_ERR);\n\t\treturn -1;\n\t}\n\n\tif ((login_req->flags & ISCSI_FLAG_LOGIN_CONTINUE) &&\n\t    (login_req->flags & ISCSI_FLAG_LOGIN_TRANSIT)) {\n\t\tpr_err(\"Login request has both ISCSI_FLAG_LOGIN_CONTINUE\"\n\t\t\t\" and ISCSI_FLAG_LOGIN_TRANSIT set, protocol error.\\n\");\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_INIT_ERR);\n\t\treturn -1;\n\t}\n\n\treq_csg = ISCSI_LOGIN_CURRENT_STAGE(login_req->flags);\n\treq_nsg = ISCSI_LOGIN_NEXT_STAGE(login_req->flags);\n\n\tif (req_csg != login->current_stage) {\n\t\tpr_err(\"Initiator unexpectedly changed login stage\"\n\t\t\t\" from %d to %d, login failed.\\n\", login->current_stage,\n\t\t\treq_csg);\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_INIT_ERR);\n\t\treturn -1;\n\t}\n\n\tif ((req_nsg == 2) || (req_csg >= 2) ||\n\t   ((login_req->flags & ISCSI_FLAG_LOGIN_TRANSIT) &&\n\t    (req_nsg <= req_csg))) {\n\t\tpr_err(\"Illegal login_req->flags Combination, CSG: %d,\"\n\t\t\t\" NSG: %d, ISCSI_FLAG_LOGIN_TRANSIT: %d.\\n\", req_csg,\n\t\t\treq_nsg, (login_req->flags & ISCSI_FLAG_LOGIN_TRANSIT));\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_INIT_ERR);\n\t\treturn -1;\n\t}\n\n\tif ((login_req->max_version != login->version_max) ||\n\t    (login_req->min_version != login->version_min)) {\n\t\tpr_err(\"Login request changed Version Max/Nin\"\n\t\t\t\" unexpectedly to 0x%02x/0x%02x, protocol error\\n\",\n\t\t\tlogin_req->max_version, login_req->min_version);\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_INIT_ERR);\n\t\treturn -1;\n\t}\n\n\tif (memcmp(login_req->isid, login->isid, 6) != 0) {\n\t\tpr_err(\"Login request changed ISID unexpectedly,\"\n\t\t\t\t\" protocol error.\\n\");\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_INIT_ERR);\n\t\treturn -1;\n\t}\n\n\tif (login_req->itt != login->init_task_tag) {\n\t\tpr_err(\"Login request changed ITT unexpectedly to\"\n\t\t\t\" 0x%08x, protocol error.\\n\", login_req->itt);\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_INIT_ERR);\n\t\treturn -1;\n\t}\n\n\tif (payload_length > MAX_KEY_VALUE_PAIRS) {\n\t\tpr_err(\"Login request payload exceeds default\"\n\t\t\t\" MaxRecvDataSegmentLength: %u, protocol error.\\n\",\n\t\t\t\tMAX_KEY_VALUE_PAIRS);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iscsi_target_check_login_request);\n\nstatic int iscsi_target_check_first_request(\n\tstruct iscsit_conn *conn,\n\tstruct iscsi_login *login)\n{\n\tstruct iscsi_param *param = NULL;\n\tstruct se_node_acl *se_nacl;\n\n\tlogin->first_request = 0;\n\n\tlist_for_each_entry(param, &conn->param_list->param_list, p_list) {\n\t\tif (!strncmp(param->name, SESSIONTYPE, 11)) {\n\t\t\tif (!IS_PSTATE_ACCEPTOR(param)) {\n\t\t\t\tpr_err(\"SessionType key not received\"\n\t\t\t\t\t\" in first login request.\\n\");\n\t\t\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\t\tISCSI_LOGIN_STATUS_MISSING_FIELDS);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!strncmp(param->value, DISCOVERY, 9))\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tif (!strncmp(param->name, INITIATORNAME, 13)) {\n\t\t\tif (!IS_PSTATE_ACCEPTOR(param)) {\n\t\t\t\tif (!login->leading_connection)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tpr_err(\"InitiatorName key not received\"\n\t\t\t\t\t\" in first login request.\\n\");\n\t\t\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\t\tISCSI_LOGIN_STATUS_MISSING_FIELDS);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!login->leading_connection) {\n\t\t\t\tse_nacl = conn->sess->se_sess->se_node_acl;\n\t\t\t\tif (!se_nacl) {\n\t\t\t\t\tpr_err(\"Unable to locate\"\n\t\t\t\t\t\t\" struct se_node_acl\\n\");\n\t\t\t\t\tiscsit_tx_login_rsp(conn,\n\t\t\t\t\t\t\tISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\t\t\t\tISCSI_LOGIN_STATUS_TGT_NOT_FOUND);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (strcmp(param->value,\n\t\t\t\t\t\tse_nacl->initiatorname)) {\n\t\t\t\t\tpr_err(\"Incorrect\"\n\t\t\t\t\t\t\" InitiatorName: %s for this\"\n\t\t\t\t\t\t\" iSCSI Initiator Node.\\n\",\n\t\t\t\t\t\tparam->value);\n\t\t\t\t\tiscsit_tx_login_rsp(conn,\n\t\t\t\t\t\t\tISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\t\t\t\tISCSI_LOGIN_STATUS_TGT_NOT_FOUND);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsi_target_do_tx_login_io(struct iscsit_conn *conn, struct iscsi_login *login)\n{\n\tu32 padding = 0;\n\tstruct iscsi_login_rsp *login_rsp;\n\n\tlogin_rsp = (struct iscsi_login_rsp *) login->rsp;\n\n\tlogin_rsp->opcode\t\t= ISCSI_OP_LOGIN_RSP;\n\thton24(login_rsp->dlength, login->rsp_length);\n\tmemcpy(login_rsp->isid, login->isid, 6);\n\tlogin_rsp->tsih\t\t\t= cpu_to_be16(login->tsih);\n\tlogin_rsp->itt\t\t\t= login->init_task_tag;\n\tlogin_rsp->statsn\t\t= cpu_to_be32(conn->stat_sn++);\n\tlogin_rsp->exp_cmdsn\t\t= cpu_to_be32(conn->sess->exp_cmd_sn);\n\tlogin_rsp->max_cmdsn\t\t= cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\n\n\tpr_debug(\"Sending Login Response, Flags: 0x%02x, ITT: 0x%08x,\"\n\t\t\" ExpCmdSN; 0x%08x, MaxCmdSN: 0x%08x, StatSN: 0x%08x, Length:\"\n\t\t\" %u\\n\", login_rsp->flags, (__force u32)login_rsp->itt,\n\t\tntohl(login_rsp->exp_cmdsn), ntohl(login_rsp->max_cmdsn),\n\t\tntohl(login_rsp->statsn), login->rsp_length);\n\n\tpadding = ((-login->rsp_length) & 3);\n\t \n\tif (login->login_complete) {\n\t\tint rc = iscsit_start_kthreads(conn);\n\t\tif (rc) {\n\t\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\t\t    ISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (conn->conn_transport->iscsit_put_login_tx(conn, login,\n\t\t\t\t\tlogin->rsp_length + padding) < 0)\n\t\tgoto err;\n\n\tlogin->rsp_length\t\t= 0;\n\n\treturn 0;\n\nerr:\n\tif (login->login_complete) {\n\t\tif (conn->rx_thread && conn->rx_thread_active) {\n\t\t\tsend_sig(SIGINT, conn->rx_thread, 1);\n\t\t\tcomplete(&conn->rx_login_comp);\n\t\t\tkthread_stop(conn->rx_thread);\n\t\t}\n\t\tif (conn->tx_thread && conn->tx_thread_active) {\n\t\t\tsend_sig(SIGINT, conn->tx_thread, 1);\n\t\t\tkthread_stop(conn->tx_thread);\n\t\t}\n\t\tspin_lock(&iscsit_global->ts_bitmap_lock);\n\t\tbitmap_release_region(iscsit_global->ts_bitmap, conn->bitmap_id,\n\t\t\t\t      get_order(1));\n\t\tspin_unlock(&iscsit_global->ts_bitmap_lock);\n\t}\n\treturn -1;\n}\n\nstatic void iscsi_target_sk_data_ready(struct sock *sk)\n{\n\tstruct iscsit_conn *conn = sk->sk_user_data;\n\tbool rc;\n\n\ttrace_sk_data_ready(sk);\n\tpr_debug(\"Entering iscsi_target_sk_data_ready: conn: %p\\n\", conn);\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tif (!sk->sk_user_data) {\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\treturn;\n\t}\n\tif (!test_bit(LOGIN_FLAGS_READY, &conn->login_flags)) {\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\tpr_debug(\"Got LOGIN_FLAGS_READY=0, conn: %p >>>>\\n\", conn);\n\t\treturn;\n\t}\n\tif (test_bit(LOGIN_FLAGS_CLOSED, &conn->login_flags)) {\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\tpr_debug(\"Got LOGIN_FLAGS_CLOSED=1, conn: %p >>>>\\n\", conn);\n\t\treturn;\n\t}\n\tif (test_and_set_bit(LOGIN_FLAGS_READ_ACTIVE, &conn->login_flags)) {\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\tpr_debug(\"Got LOGIN_FLAGS_READ_ACTIVE=1, conn: %p >>>>\\n\", conn);\n\t\tif (iscsi_target_sk_data_ready == conn->orig_data_ready)\n\t\t\treturn;\n\t\tconn->orig_data_ready(sk);\n\t\treturn;\n\t}\n\n\trc = schedule_delayed_work(&conn->login_work, 0);\n\tif (!rc) {\n\t\tpr_debug(\"iscsi_target_sk_data_ready, schedule_delayed_work\"\n\t\t\t \" got false\\n\");\n\t}\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic void iscsi_target_sk_state_change(struct sock *);\n\nstatic void iscsi_target_set_sock_callbacks(struct iscsit_conn *conn)\n{\n\tstruct sock *sk;\n\n\tif (!conn->sock)\n\t\treturn;\n\n\tsk = conn->sock->sk;\n\tpr_debug(\"Entering iscsi_target_set_sock_callbacks: conn: %p\\n\", conn);\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tsk->sk_user_data = conn;\n\tconn->orig_data_ready = sk->sk_data_ready;\n\tconn->orig_state_change = sk->sk_state_change;\n\tsk->sk_data_ready = iscsi_target_sk_data_ready;\n\tsk->sk_state_change = iscsi_target_sk_state_change;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\n\tsk->sk_sndtimeo = TA_LOGIN_TIMEOUT * HZ;\n\tsk->sk_rcvtimeo = TA_LOGIN_TIMEOUT * HZ;\n}\n\nstatic void iscsi_target_restore_sock_callbacks(struct iscsit_conn *conn)\n{\n\tstruct sock *sk;\n\n\tif (!conn->sock)\n\t\treturn;\n\n\tsk = conn->sock->sk;\n\tpr_debug(\"Entering iscsi_target_restore_sock_callbacks: conn: %p\\n\", conn);\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tif (!sk->sk_user_data) {\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\treturn;\n\t}\n\tsk->sk_user_data = NULL;\n\tsk->sk_data_ready = conn->orig_data_ready;\n\tsk->sk_state_change = conn->orig_state_change;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\n\tsk->sk_sndtimeo = MAX_SCHEDULE_TIMEOUT;\n\tsk->sk_rcvtimeo = MAX_SCHEDULE_TIMEOUT;\n}\n\nstatic int iscsi_target_do_login(struct iscsit_conn *, struct iscsi_login *);\n\nstatic bool __iscsi_target_sk_check_close(struct sock *sk)\n{\n\tif (sk->sk_state == TCP_CLOSE_WAIT || sk->sk_state == TCP_CLOSE) {\n\t\tpr_debug(\"__iscsi_target_sk_check_close: TCP_CLOSE_WAIT|TCP_CLOSE,\"\n\t\t\t\"returning TRUE\\n\");\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool iscsi_target_sk_check_close(struct iscsit_conn *conn)\n{\n\tbool state = false;\n\n\tif (conn->sock) {\n\t\tstruct sock *sk = conn->sock->sk;\n\n\t\tread_lock_bh(&sk->sk_callback_lock);\n\t\tstate = (__iscsi_target_sk_check_close(sk) ||\n\t\t\t test_bit(LOGIN_FLAGS_CLOSED, &conn->login_flags));\n\t\tread_unlock_bh(&sk->sk_callback_lock);\n\t}\n\treturn state;\n}\n\nstatic bool iscsi_target_sk_check_flag(struct iscsit_conn *conn, unsigned int flag)\n{\n\tbool state = false;\n\n\tif (conn->sock) {\n\t\tstruct sock *sk = conn->sock->sk;\n\n\t\tread_lock_bh(&sk->sk_callback_lock);\n\t\tstate = test_bit(flag, &conn->login_flags);\n\t\tread_unlock_bh(&sk->sk_callback_lock);\n\t}\n\treturn state;\n}\n\nstatic bool iscsi_target_sk_check_and_clear(struct iscsit_conn *conn, unsigned int flag)\n{\n\tbool state = false;\n\n\tif (conn->sock) {\n\t\tstruct sock *sk = conn->sock->sk;\n\n\t\twrite_lock_bh(&sk->sk_callback_lock);\n\t\tstate = (__iscsi_target_sk_check_close(sk) ||\n\t\t\t test_bit(LOGIN_FLAGS_CLOSED, &conn->login_flags));\n\t\tif (!state)\n\t\t\tclear_bit(flag, &conn->login_flags);\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t}\n\treturn state;\n}\n\nstatic void iscsi_target_login_drop(struct iscsit_conn *conn, struct iscsi_login *login)\n{\n\tbool zero_tsih = login->zero_tsih;\n\n\tiscsi_remove_failed_auth_entry(conn);\n\tiscsi_target_nego_release(conn);\n\tiscsi_target_login_sess_out(conn, zero_tsih, true);\n}\n\nstatic void iscsi_target_do_login_rx(struct work_struct *work)\n{\n\tstruct iscsit_conn *conn = container_of(work,\n\t\t\t\tstruct iscsit_conn, login_work.work);\n\tstruct iscsi_login *login = conn->login;\n\tstruct iscsi_np *np = login->np;\n\tstruct iscsi_portal_group *tpg = conn->tpg;\n\tstruct iscsi_tpg_np *tpg_np = conn->tpg_np;\n\tint rc, zero_tsih = login->zero_tsih;\n\tbool state;\n\n\tpr_debug(\"entering iscsi_target_do_login_rx, conn: %p, %s:%d\\n\",\n\t\t\tconn, current->comm, current->pid);\n\n\tspin_lock(&conn->login_worker_lock);\n\tset_bit(LOGIN_FLAGS_WORKER_RUNNING, &conn->login_flags);\n\tspin_unlock(&conn->login_worker_lock);\n\t \n\tif (iscsi_target_sk_check_flag(conn, LOGIN_FLAGS_INITIAL_PDU)) {\n\t\tschedule_delayed_work(&conn->login_work, msecs_to_jiffies(10));\n\t\treturn;\n\t}\n\n\tspin_lock(&tpg->tpg_state_lock);\n\tstate = (tpg->tpg_state == TPG_STATE_ACTIVE);\n\tspin_unlock(&tpg->tpg_state_lock);\n\n\tif (!state) {\n\t\tpr_debug(\"iscsi_target_do_login_rx: tpg_state != TPG_STATE_ACTIVE\\n\");\n\t\tgoto err;\n\t}\n\n\tif (iscsi_target_sk_check_close(conn)) {\n\t\tpr_debug(\"iscsi_target_do_login_rx, TCP state CLOSE\\n\");\n\t\tgoto err;\n\t}\n\n\tallow_signal(SIGINT);\n\trc = iscsit_set_login_timer_kworker(conn, current);\n\tif (rc < 0) {\n\t\t \n\t\tpr_debug(\"iscsi_target_do_login_rx, login failed\\n\");\n\t\tgoto err;\n\t}\n\n\trc = conn->conn_transport->iscsit_get_login_rx(conn, login);\n\tflush_signals(current);\n\n\tif (rc < 0)\n\t\tgoto err;\n\n\tpr_debug(\"iscsi_target_do_login_rx after rx_login_io, %p, %s:%d\\n\",\n\t\t\tconn, current->comm, current->pid);\n\n\t \n\tif (conn->sock) {\n\t\tstruct sock *sk = conn->sock->sk;\n\n\t\twrite_lock_bh(&sk->sk_callback_lock);\n\t\tif (!test_bit(LOGIN_FLAGS_INITIAL_PDU, &conn->login_flags)) {\n\t\t\tclear_bit(LOGIN_FLAGS_READ_ACTIVE, &conn->login_flags);\n\t\t\tset_bit(LOGIN_FLAGS_WRITE_ACTIVE, &conn->login_flags);\n\t\t}\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t}\n\n\trc = iscsi_target_do_login(conn, login);\n\tif (rc < 0) {\n\t\tgoto err;\n\t} else if (!rc) {\n\t\tif (iscsi_target_sk_check_and_clear(conn,\n\t\t\t\t\t\t    LOGIN_FLAGS_WRITE_ACTIVE))\n\t\t\tgoto err;\n\n\t\t \n\t\trc = iscsit_set_login_timer_kworker(conn, NULL);\n\t\tif (rc < 0)\n\t\t\tgoto err;\n\t} else if (rc == 1) {\n\t\tiscsit_stop_login_timer(conn);\n\t\tcancel_delayed_work(&conn->login_work);\n\t\tiscsi_target_nego_release(conn);\n\t\tiscsi_post_login_handler(np, conn, zero_tsih);\n\t\tiscsit_deaccess_np(np, tpg, tpg_np);\n\t}\n\treturn;\n\nerr:\n\tiscsi_target_restore_sock_callbacks(conn);\n\tiscsit_stop_login_timer(conn);\n\tcancel_delayed_work(&conn->login_work);\n\tiscsi_target_login_drop(conn, login);\n\tiscsit_deaccess_np(np, tpg, tpg_np);\n}\n\nstatic void iscsi_target_sk_state_change(struct sock *sk)\n{\n\tstruct iscsit_conn *conn;\n\tvoid (*orig_state_change)(struct sock *);\n\tbool state;\n\n\tpr_debug(\"Entering iscsi_target_sk_state_change\\n\");\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tconn = sk->sk_user_data;\n\tif (!conn) {\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\treturn;\n\t}\n\torig_state_change = conn->orig_state_change;\n\n\tif (!test_bit(LOGIN_FLAGS_READY, &conn->login_flags)) {\n\t\tpr_debug(\"Got LOGIN_FLAGS_READY=0 sk_state_change conn: %p\\n\",\n\t\t\t conn);\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\torig_state_change(sk);\n\t\treturn;\n\t}\n\tstate = __iscsi_target_sk_check_close(sk);\n\tpr_debug(\"__iscsi_target_sk_close_change: state: %d\\n\", state);\n\n\tif (test_bit(LOGIN_FLAGS_READ_ACTIVE, &conn->login_flags) ||\n\t    test_bit(LOGIN_FLAGS_WRITE_ACTIVE, &conn->login_flags)) {\n\t\tpr_debug(\"Got LOGIN_FLAGS_{READ|WRITE}_ACTIVE=1\"\n\t\t\t \" sk_state_change conn: %p\\n\", conn);\n\t\tif (state)\n\t\t\tset_bit(LOGIN_FLAGS_CLOSED, &conn->login_flags);\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\torig_state_change(sk);\n\t\treturn;\n\t}\n\tif (test_bit(LOGIN_FLAGS_CLOSED, &conn->login_flags)) {\n\t\tpr_debug(\"Got LOGIN_FLAGS_CLOSED=1 sk_state_change conn: %p\\n\",\n\t\t\t conn);\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t\torig_state_change(sk);\n\t\treturn;\n\t}\n\t \n\tif (state) {\n\t\tpr_debug(\"iscsi_target_sk_state_change got failed state\\n\");\n\t\tset_bit(LOGIN_FLAGS_CLOSED, &conn->login_flags);\n\t\tstate = test_bit(LOGIN_FLAGS_INITIAL_PDU, &conn->login_flags);\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\n\t\torig_state_change(sk);\n\n\t\tif (!state)\n\t\t\tschedule_delayed_work(&conn->login_work, 0);\n\t\treturn;\n\t}\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\n\torig_state_change(sk);\n}\n\n \nstatic int iscsi_target_check_for_existing_instances(\n\tstruct iscsit_conn *conn,\n\tstruct iscsi_login *login)\n{\n\tif (login->checked_for_existing)\n\t\treturn 0;\n\n\tlogin->checked_for_existing = 1;\n\n\tif (!login->tsih)\n\t\treturn iscsi_check_for_session_reinstatement(conn);\n\telse\n\t\treturn iscsi_login_post_auth_non_zero_tsih(conn, login->cid,\n\t\t\t\tlogin->initial_exp_statsn);\n}\n\nstatic int iscsi_target_do_authentication(\n\tstruct iscsit_conn *conn,\n\tstruct iscsi_login *login)\n{\n\tint authret;\n\tu32 payload_length;\n\tstruct iscsi_param *param;\n\tstruct iscsi_login_req *login_req;\n\tstruct iscsi_login_rsp *login_rsp;\n\n\tlogin_req = (struct iscsi_login_req *) login->req;\n\tlogin_rsp = (struct iscsi_login_rsp *) login->rsp;\n\tpayload_length = ntoh24(login_req->dlength);\n\n\tparam = iscsi_find_param_from_key(AUTHMETHOD, conn->param_list);\n\tif (!param)\n\t\treturn -1;\n\n\tauthret = iscsi_handle_authentication(\n\t\t\tconn,\n\t\t\tlogin->req_buf,\n\t\t\tlogin->rsp_buf,\n\t\t\tpayload_length,\n\t\t\t&login->rsp_length,\n\t\t\tparam->value);\n\tswitch (authret) {\n\tcase 0:\n\t\tpr_debug(\"Received OK response\"\n\t\t\" from LIO Authentication, continuing.\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tpr_debug(\"iSCSI security negotiation\"\n\t\t\t\" completed successfully.\\n\");\n\t\tlogin->auth_complete = 1;\n\t\tif ((login_req->flags & ISCSI_FLAG_LOGIN_NEXT_STAGE1) &&\n\t\t    (login_req->flags & ISCSI_FLAG_LOGIN_TRANSIT)) {\n\t\t\tlogin_rsp->flags |= (ISCSI_FLAG_LOGIN_NEXT_STAGE1 |\n\t\t\t\t\t     ISCSI_FLAG_LOGIN_TRANSIT);\n\t\t\tlogin->current_stage = 1;\n\t\t}\n\t\treturn iscsi_target_check_for_existing_instances(\n\t\t\t\tconn, login);\n\tcase 2:\n\t\tpr_err(\"Security negotiation\"\n\t\t\t\" failed.\\n\");\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_AUTH_FAILED);\n\t\treturn -1;\n\tdefault:\n\t\tpr_err(\"Received unknown error %d from LIO\"\n\t\t\t\t\" Authentication\\n\", authret);\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_TARGET_ERROR);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nbool iscsi_conn_auth_required(struct iscsit_conn *conn)\n{\n\tstruct iscsi_node_acl *nacl;\n\tstruct se_node_acl *se_nacl;\n\n\tif (conn->sess->sess_ops->SessionType) {\n\t\t \n\t\treturn conn->tpg->tpg_attrib.authentication;\n\t}\n\t \n\tse_nacl = conn->sess->se_sess->se_node_acl;\n\tif (!se_nacl) {\n\t\tpr_debug(\"Unknown ACL is trying to connect\\n\");\n\t\treturn true;\n\t}\n\n\tif (se_nacl->dynamic_node_acl) {\n\t\tpr_debug(\"Dynamic ACL %s is trying to connect\\n\",\n\t\t\t se_nacl->initiatorname);\n\t\treturn conn->tpg->tpg_attrib.authentication;\n\t}\n\n\tpr_debug(\"Known ACL %s is trying to connect\\n\",\n\t\t se_nacl->initiatorname);\n\n\tnacl = to_iscsi_nacl(se_nacl);\n\tif (nacl->node_attrib.authentication == NA_AUTHENTICATION_INHERITED)\n\t\treturn conn->tpg->tpg_attrib.authentication;\n\n\treturn nacl->node_attrib.authentication;\n}\n\nstatic int iscsi_target_handle_csg_zero(\n\tstruct iscsit_conn *conn,\n\tstruct iscsi_login *login)\n{\n\tint ret;\n\tu32 payload_length;\n\tstruct iscsi_param *param;\n\tstruct iscsi_login_req *login_req;\n\tstruct iscsi_login_rsp *login_rsp;\n\n\tlogin_req = (struct iscsi_login_req *) login->req;\n\tlogin_rsp = (struct iscsi_login_rsp *) login->rsp;\n\tpayload_length = ntoh24(login_req->dlength);\n\n\tparam = iscsi_find_param_from_key(AUTHMETHOD, conn->param_list);\n\tif (!param)\n\t\treturn -1;\n\n\tret = iscsi_decode_text_input(\n\t\t\tPHASE_SECURITY|PHASE_DECLARATIVE,\n\t\t\tSENDER_INITIATOR|SENDER_RECEIVER,\n\t\t\tlogin->req_buf,\n\t\t\tpayload_length,\n\t\t\tconn);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tif (ret > 0) {\n\t\tif (login->auth_complete) {\n\t\t\tpr_err(\"Initiator has already been\"\n\t\t\t\t\" successfully authenticated, but is still\"\n\t\t\t\t\" sending %s keys.\\n\", param->value);\n\t\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\t\tISCSI_LOGIN_STATUS_INIT_ERR);\n\t\t\treturn -1;\n\t\t}\n\n\t\tgoto do_auth;\n\t} else if (!payload_length) {\n\t\tpr_err(\"Initiator sent zero length security payload,\"\n\t\t       \" login failed\\n\");\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\t    ISCSI_LOGIN_STATUS_AUTH_FAILED);\n\t\treturn -1;\n\t}\n\n\tif (login->first_request)\n\t\tif (iscsi_target_check_first_request(conn, login) < 0)\n\t\t\treturn -1;\n\n\tret = iscsi_encode_text_output(\n\t\t\tPHASE_SECURITY|PHASE_DECLARATIVE,\n\t\t\tSENDER_TARGET,\n\t\t\tlogin->rsp_buf,\n\t\t\t&login->rsp_length,\n\t\t\tconn->param_list,\n\t\t\tconn->tpg->tpg_attrib.login_keys_workaround);\n\tif (ret < 0)\n\t\treturn -1;\n\n\tif (!iscsi_check_negotiated_keys(conn->param_list)) {\n\t\tbool auth_required = iscsi_conn_auth_required(conn);\n\n\t\tif (auth_required) {\n\t\t\tif (!strncmp(param->value, NONE, 4)) {\n\t\t\t\tpr_err(\"Initiator sent AuthMethod=None but\"\n\t\t\t\t       \" Target is enforcing iSCSI Authentication,\"\n\t\t\t\t       \" login failed.\\n\");\n\t\t\t\tiscsit_tx_login_rsp(conn,\n\t\t\t\t\t\tISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\t\t\tISCSI_LOGIN_STATUS_AUTH_FAILED);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!login->auth_complete)\n\t\t\t\treturn 0;\n\n\t\t\tif (strncmp(param->value, NONE, 4) &&\n\t\t\t    !login->auth_complete)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tif ((login_req->flags & ISCSI_FLAG_LOGIN_NEXT_STAGE1) &&\n\t\t    (login_req->flags & ISCSI_FLAG_LOGIN_TRANSIT)) {\n\t\t\tlogin_rsp->flags |= ISCSI_FLAG_LOGIN_NEXT_STAGE1 |\n\t\t\t\t\t    ISCSI_FLAG_LOGIN_TRANSIT;\n\t\t\tlogin->current_stage = 1;\n\t\t}\n\t}\n\n\treturn 0;\ndo_auth:\n\treturn iscsi_target_do_authentication(conn, login);\n}\n\nstatic bool iscsi_conn_authenticated(struct iscsit_conn *conn,\n\t\t\t\t     struct iscsi_login *login)\n{\n\tif (!iscsi_conn_auth_required(conn))\n\t\treturn true;\n\n\tif (login->auth_complete)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int iscsi_target_handle_csg_one(struct iscsit_conn *conn, struct iscsi_login *login)\n{\n\tint ret;\n\tu32 payload_length;\n\tstruct iscsi_login_req *login_req;\n\tstruct iscsi_login_rsp *login_rsp;\n\n\tlogin_req = (struct iscsi_login_req *) login->req;\n\tlogin_rsp = (struct iscsi_login_rsp *) login->rsp;\n\tpayload_length = ntoh24(login_req->dlength);\n\n\tret = iscsi_decode_text_input(\n\t\t\tPHASE_OPERATIONAL|PHASE_DECLARATIVE,\n\t\t\tSENDER_INITIATOR|SENDER_RECEIVER,\n\t\t\tlogin->req_buf,\n\t\t\tpayload_length,\n\t\t\tconn);\n\tif (ret < 0) {\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_INIT_ERR);\n\t\treturn -1;\n\t}\n\n\tif (login->first_request)\n\t\tif (iscsi_target_check_first_request(conn, login) < 0)\n\t\t\treturn -1;\n\n\tif (iscsi_target_check_for_existing_instances(conn, login) < 0)\n\t\treturn -1;\n\n\tret = iscsi_encode_text_output(\n\t\t\tPHASE_OPERATIONAL|PHASE_DECLARATIVE,\n\t\t\tSENDER_TARGET,\n\t\t\tlogin->rsp_buf,\n\t\t\t&login->rsp_length,\n\t\t\tconn->param_list,\n\t\t\tconn->tpg->tpg_attrib.login_keys_workaround);\n\tif (ret < 0) {\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_INIT_ERR);\n\t\treturn -1;\n\t}\n\n\tif (!iscsi_conn_authenticated(conn, login)) {\n\t\tpr_err(\"Initiator is requesting CSG: 1, has not been\"\n\t\t       \" successfully authenticated, and the Target is\"\n\t\t       \" enforcing iSCSI Authentication, login failed.\\n\");\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_AUTH_FAILED);\n\t\treturn -1;\n\t}\n\n\tif (!iscsi_check_negotiated_keys(conn->param_list))\n\t\tif ((login_req->flags & ISCSI_FLAG_LOGIN_NEXT_STAGE3) &&\n\t\t    (login_req->flags & ISCSI_FLAG_LOGIN_TRANSIT))\n\t\t\tlogin_rsp->flags |= ISCSI_FLAG_LOGIN_NEXT_STAGE3 |\n\t\t\t\t\t    ISCSI_FLAG_LOGIN_TRANSIT;\n\n\treturn 0;\n}\n\n \nstatic int iscsi_target_do_login(struct iscsit_conn *conn, struct iscsi_login *login)\n{\n\tint pdu_count = 0;\n\tstruct iscsi_login_req *login_req;\n\tstruct iscsi_login_rsp *login_rsp;\n\n\tlogin_req = (struct iscsi_login_req *) login->req;\n\tlogin_rsp = (struct iscsi_login_rsp *) login->rsp;\n\n\twhile (1) {\n\t\tif (++pdu_count > MAX_LOGIN_PDUS) {\n\t\t\tpr_err(\"MAX_LOGIN_PDUS count reached.\\n\");\n\t\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\t\tISCSI_LOGIN_STATUS_TARGET_ERROR);\n\t\t\treturn -1;\n\t\t}\n\n\t\tswitch (ISCSI_LOGIN_CURRENT_STAGE(login_req->flags)) {\n\t\tcase 0:\n\t\t\tlogin_rsp->flags &= ~ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK;\n\t\t\tif (iscsi_target_handle_csg_zero(conn, login) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tlogin_rsp->flags |= ISCSI_FLAG_LOGIN_CURRENT_STAGE1;\n\t\t\tif (iscsi_target_handle_csg_one(conn, login) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (login_rsp->flags & ISCSI_FLAG_LOGIN_TRANSIT) {\n\t\t\t\t \n\t\t\t\tif (iscsi_target_sk_check_close(conn))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tlogin->tsih = conn->sess->tsih;\n\t\t\t\tlogin->login_complete = 1;\n\t\t\t\tiscsi_target_restore_sock_callbacks(conn);\n\t\t\t\tif (iscsi_target_do_tx_login_io(conn,\n\t\t\t\t\t\tlogin) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Illegal CSG: %d received from\"\n\t\t\t\t\" Initiator, protocol error.\\n\",\n\t\t\t\tISCSI_LOGIN_CURRENT_STAGE(login_req->flags));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (iscsi_target_do_tx_login_io(conn, login) < 0)\n\t\t\treturn -1;\n\n\t\tif (login_rsp->flags & ISCSI_FLAG_LOGIN_TRANSIT) {\n\t\t\tlogin_rsp->flags &= ~ISCSI_FLAG_LOGIN_TRANSIT;\n\t\t\tlogin_rsp->flags &= ~ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void iscsi_initiatorname_tolower(\n\tchar *param_buf)\n{\n\tchar *c;\n\tu32 iqn_size = strlen(param_buf), i;\n\n\tfor (i = 0; i < iqn_size; i++) {\n\t\tc = &param_buf[i];\n\t\tif (!isupper(*c))\n\t\t\tcontinue;\n\n\t\t*c = tolower(*c);\n\t}\n}\n\n \nint iscsi_target_locate_portal(\n\tstruct iscsi_np *np,\n\tstruct iscsit_conn *conn,\n\tstruct iscsi_login *login)\n{\n\tchar *i_buf = NULL, *s_buf = NULL, *t_buf = NULL;\n\tchar *tmpbuf, *start = NULL, *end = NULL, *key, *value;\n\tstruct iscsit_session *sess = conn->sess;\n\tstruct iscsi_tiqn *tiqn;\n\tstruct iscsi_tpg_np *tpg_np = NULL;\n\tstruct iscsi_login_req *login_req;\n\tstruct se_node_acl *se_nacl;\n\tu32 payload_length, queue_depth = 0;\n\tint sessiontype = 0, ret = 0, tag_num, tag_size;\n\n\tINIT_DELAYED_WORK(&conn->login_work, iscsi_target_do_login_rx);\n\tiscsi_target_set_sock_callbacks(conn);\n\n\tlogin->np = np;\n\tconn->tpg = NULL;\n\n\tlogin_req = (struct iscsi_login_req *) login->req;\n\tpayload_length = ntoh24(login_req->dlength);\n\n\ttmpbuf = kmemdup_nul(login->req_buf, payload_length, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\n\tstart = tmpbuf;\n\tend = (start + payload_length);\n\n\t \n\twhile (start < end) {\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!strncmp(key, \"InitiatorName\", 13))\n\t\t\ti_buf = value;\n\t\telse if (!strncmp(key, \"SessionType\", 11))\n\t\t\ts_buf = value;\n\t\telse if (!strncmp(key, \"TargetName\", 10))\n\t\t\tt_buf = value;\n\n\t\tstart += strlen(key) + strlen(value) + 2;\n\t}\n\t \n\tif (!i_buf) {\n\t\tpr_err(\"InitiatorName key not received\"\n\t\t\t\" in first login request.\\n\");\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\tISCSI_LOGIN_STATUS_MISSING_FIELDS);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\t \n\tiscsi_initiatorname_tolower(i_buf);\n\n\tif (!s_buf) {\n\t\tif (!login->leading_connection)\n\t\t\tgoto get_target;\n\n\t\tpr_err(\"SessionType key not received\"\n\t\t\t\" in first login request.\\n\");\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\tISCSI_LOGIN_STATUS_MISSING_FIELDS);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tsessiontype = strncmp(s_buf, DISCOVERY, 9);\n\tif (!sessiontype) {\n\t\tif (!login->leading_connection)\n\t\t\tgoto get_target;\n\n\t\tsess->sess_ops->SessionType = 1;\n\t\t \n\t\tif (iscsi_login_setup_crypto(conn) < 0) {\n\t\t\tpr_err(\"iscsi_login_setup_crypto() failed\\n\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tconn->tpg = iscsit_global->discovery_tpg;\n\t\tif (iscsit_access_np(np, conn->tpg) < 0) {\n\t\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_SVC_UNAVAILABLE);\n\t\t\tconn->tpg = NULL;\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tret = 0;\n\t\tgoto alloc_tags;\n\t}\n\nget_target:\n\tif (!t_buf) {\n\t\tpr_err(\"TargetName key not received\"\n\t\t\t\" in first login request while\"\n\t\t\t\" SessionType=Normal.\\n\");\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\tISCSI_LOGIN_STATUS_MISSING_FIELDS);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t \n\ttiqn = iscsit_get_tiqn_for_login(t_buf);\n\tif (!tiqn) {\n\t\tpr_err(\"Unable to locate Target IQN: %s in\"\n\t\t\t\" Storage Node\\n\", t_buf);\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_SVC_UNAVAILABLE);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tpr_debug(\"Located Storage Object: %s\\n\", tiqn->tiqn);\n\n\t \n\tconn->tpg = iscsit_get_tpg_from_np(tiqn, np, &tpg_np);\n\tif (!conn->tpg) {\n\t\tpr_err(\"Unable to locate Target Portal Group\"\n\t\t\t\t\" on %s\\n\", tiqn->tiqn);\n\t\tiscsit_put_tiqn_for_login(tiqn);\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_SVC_UNAVAILABLE);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tconn->tpg_np = tpg_np;\n\tpr_debug(\"Located Portal Group Object: %hu\\n\", conn->tpg->tpgt);\n\t \n\tif (iscsi_login_setup_crypto(conn) < 0) {\n\t\tpr_err(\"iscsi_login_setup_crypto() failed\\n\");\n\t\tkref_put(&tpg_np->tpg_np_kref, iscsit_login_kref_put);\n\t\tiscsit_put_tiqn_for_login(tiqn);\n\t\tconn->tpg = NULL;\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\t \n\tif (iscsit_access_np(np, conn->tpg) < 0) {\n\t\tkref_put(&tpg_np->tpg_np_kref, iscsit_login_kref_put);\n\t\tiscsit_put_tiqn_for_login(tiqn);\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_SVC_UNAVAILABLE);\n\t\tconn->tpg = NULL;\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!login->leading_connection) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tsess->sess_ops->SessionType = 0;\n\n\t \n\tsess->se_sess->se_node_acl = core_tpg_check_initiator_node_acl(\n\t\t\t&conn->tpg->tpg_se_tpg, i_buf);\n\tif (!sess->se_sess->se_node_acl) {\n\t\tpr_err(\"iSCSI Initiator Node: %s is not authorized to\"\n\t\t\t\" access iSCSI target portal group: %hu.\\n\",\n\t\t\t\ti_buf, conn->tpg->tpgt);\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,\n\t\t\t\tISCSI_LOGIN_STATUS_TGT_FORBIDDEN);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tse_nacl = sess->se_sess->se_node_acl;\n\tqueue_depth = se_nacl->queue_depth;\n\t \nalloc_tags:\n\ttag_num = max_t(u32, ISCSIT_MIN_TAGS, queue_depth);\n\ttag_num = (tag_num * 2) + ISCSIT_EXTRA_TAGS;\n\ttag_size = sizeof(struct iscsit_cmd) + conn->conn_transport->priv_size;\n\n\tret = transport_alloc_session_tags(sess->se_sess, tag_num, tag_size);\n\tif (ret < 0) {\n\t\tiscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,\n\t\t\t\t    ISCSI_LOGIN_STATUS_NO_RESOURCES);\n\t\tret = -1;\n\t}\nout:\n\tkfree(tmpbuf);\n\treturn ret;\n}\n\nint iscsi_target_start_negotiation(\n\tstruct iscsi_login *login,\n\tstruct iscsit_conn *conn)\n{\n\tint ret;\n\n\tif (conn->sock) {\n\t\tstruct sock *sk = conn->sock->sk;\n\n\t\twrite_lock_bh(&sk->sk_callback_lock);\n\t\tset_bit(LOGIN_FLAGS_READY, &conn->login_flags);\n\t\tset_bit(LOGIN_FLAGS_INITIAL_PDU, &conn->login_flags);\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t}\n\t \n\tret = iscsi_target_do_login(conn, login);\n\tif (!ret) {\n\t\tspin_lock(&conn->login_worker_lock);\n\n\t\tif (iscsi_target_sk_check_and_clear(conn, LOGIN_FLAGS_INITIAL_PDU))\n\t\t\tret = -1;\n\t\telse if (!test_bit(LOGIN_FLAGS_WORKER_RUNNING, &conn->login_flags)) {\n\t\t\tif (iscsit_set_login_timer_kworker(conn, NULL) < 0) {\n\t\t\t\t \n\t\t\t\tschedule_delayed_work(&conn->login_work, 0);\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock(&conn->login_worker_lock);\n\t}\n\n\tif (ret < 0) {\n\t\tiscsi_target_restore_sock_callbacks(conn);\n\t\tiscsi_remove_failed_auth_entry(conn);\n\t}\n\tif (ret != 0) {\n\t\tiscsit_stop_login_timer(conn);\n\t\tcancel_delayed_work_sync(&conn->login_work);\n\t\tiscsi_target_nego_release(conn);\n\t}\n\n\treturn ret;\n}\n\nvoid iscsi_target_nego_release(struct iscsit_conn *conn)\n{\n\tstruct iscsi_login *login = conn->conn_login;\n\n\tif (!login)\n\t\treturn;\n\n\tkfree(login->req_buf);\n\tkfree(login->rsp_buf);\n\tkfree(login);\n\n\tconn->conn_login = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}