{
  "module_name": "iscsi_target_seq_pdu_list.c",
  "hash_id": "5acf040f6069958008edb7a1b401714424a0a57b86e8932c333a47b288b8a166",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target_seq_pdu_list.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/random.h>\n\n#include <target/iscsi/iscsi_target_core.h>\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target_tpg.h\"\n#include \"iscsi_target_seq_pdu_list.h\"\n\n#ifdef DEBUG\nstatic void iscsit_dump_seq_list(struct iscsit_cmd *cmd)\n{\n\tint i;\n\tstruct iscsi_seq *seq;\n\n\tpr_debug(\"Dumping Sequence List for ITT: 0x%08x:\\n\",\n\t\t\tcmd->init_task_tag);\n\n\tfor (i = 0; i < cmd->seq_count; i++) {\n\t\tseq = &cmd->seq_list[i];\n\t\tpr_debug(\"i: %d, pdu_start: %d, pdu_count: %d,\"\n\t\t\t\" offset: %d, xfer_len: %d, seq_send_order: %d,\"\n\t\t\t\" seq_no: %d\\n\", i, seq->pdu_start, seq->pdu_count,\n\t\t\tseq->offset, seq->xfer_len, seq->seq_send_order,\n\t\t\tseq->seq_no);\n\t}\n}\n\nstatic void iscsit_dump_pdu_list(struct iscsit_cmd *cmd)\n{\n\tint i;\n\tstruct iscsi_pdu *pdu;\n\n\tpr_debug(\"Dumping PDU List for ITT: 0x%08x:\\n\",\n\t\t\tcmd->init_task_tag);\n\n\tfor (i = 0; i < cmd->pdu_count; i++) {\n\t\tpdu = &cmd->pdu_list[i];\n\t\tpr_debug(\"i: %d, offset: %d, length: %d,\"\n\t\t\t\" pdu_send_order: %d, seq_no: %d\\n\", i, pdu->offset,\n\t\t\tpdu->length, pdu->pdu_send_order, pdu->seq_no);\n\t}\n}\n#else\nstatic void iscsit_dump_seq_list(struct iscsit_cmd *cmd) {}\nstatic void iscsit_dump_pdu_list(struct iscsit_cmd *cmd) {}\n#endif\n\nstatic void iscsit_ordered_seq_lists(\n\tstruct iscsit_cmd *cmd,\n\tu8 type)\n{\n\tu32 i, seq_count = 0;\n\n\tfor (i = 0; i < cmd->seq_count; i++) {\n\t\tif (cmd->seq_list[i].type != SEQTYPE_NORMAL)\n\t\t\tcontinue;\n\t\tcmd->seq_list[i].seq_send_order = seq_count++;\n\t}\n}\n\nstatic void iscsit_ordered_pdu_lists(\n\tstruct iscsit_cmd *cmd,\n\tu8 type)\n{\n\tu32 i, pdu_send_order = 0, seq_no = 0;\n\n\tfor (i = 0; i < cmd->pdu_count; i++) {\nredo:\n\t\tif (cmd->pdu_list[i].seq_no == seq_no) {\n\t\t\tcmd->pdu_list[i].pdu_send_order = pdu_send_order++;\n\t\t\tcontinue;\n\t\t}\n\t\tseq_no++;\n\t\tpdu_send_order = 0;\n\t\tgoto redo;\n\t}\n}\n\n \nstatic void iscsit_create_random_array(u32 *array, u32 count)\n{\n\tint i, j, k;\n\n\tif (count == 1) {\n\t\tarray[0] = 0;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < count; i++) {\nredo:\n\t\tget_random_bytes(&j, sizeof(u32));\n\t\tj = (1 + (int) (9999 + 1) - j) % count;\n\t\tfor (k = 0; k < i + 1; k++) {\n\t\t\tj |= 0x80000000;\n\t\t\tif ((array[k] & 0x80000000) && (array[k] == j))\n\t\t\t\tgoto redo;\n\t\t}\n\t\tarray[i] = j;\n\t}\n\n\tfor (i = 0; i < count; i++)\n\t\tarray[i] &= ~0x80000000;\n}\n\nstatic int iscsit_randomize_pdu_lists(\n\tstruct iscsit_cmd *cmd,\n\tu8 type)\n{\n\tint i = 0;\n\tu32 *array, pdu_count, seq_count = 0, seq_no = 0, seq_offset = 0;\n\n\tfor (pdu_count = 0; pdu_count < cmd->pdu_count; pdu_count++) {\nredo:\n\t\tif (cmd->pdu_list[pdu_count].seq_no == seq_no) {\n\t\t\tseq_count++;\n\t\t\tcontinue;\n\t\t}\n\t\tarray = kcalloc(seq_count, sizeof(u32), GFP_KERNEL);\n\t\tif (!array) {\n\t\t\tpr_err(\"Unable to allocate memory\"\n\t\t\t\t\" for random array.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tiscsit_create_random_array(array, seq_count);\n\n\t\tfor (i = 0; i < seq_count; i++)\n\t\t\tcmd->pdu_list[seq_offset+i].pdu_send_order = array[i];\n\n\t\tkfree(array);\n\n\t\tseq_offset += seq_count;\n\t\tseq_count = 0;\n\t\tseq_no++;\n\t\tgoto redo;\n\t}\n\n\tif (seq_count) {\n\t\tarray = kcalloc(seq_count, sizeof(u32), GFP_KERNEL);\n\t\tif (!array) {\n\t\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\t\" random array.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tiscsit_create_random_array(array, seq_count);\n\n\t\tfor (i = 0; i < seq_count; i++)\n\t\t\tcmd->pdu_list[seq_offset+i].pdu_send_order = array[i];\n\n\t\tkfree(array);\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsit_randomize_seq_lists(\n\tstruct iscsit_cmd *cmd,\n\tu8 type)\n{\n\tint i, j = 0;\n\tu32 *array, seq_count = cmd->seq_count;\n\n\tif ((type == PDULIST_IMMEDIATE) || (type == PDULIST_UNSOLICITED))\n\t\tseq_count--;\n\telse if (type == PDULIST_IMMEDIATE_AND_UNSOLICITED)\n\t\tseq_count -= 2;\n\n\tif (!seq_count)\n\t\treturn 0;\n\n\tarray = kcalloc(seq_count, sizeof(u32), GFP_KERNEL);\n\tif (!array) {\n\t\tpr_err(\"Unable to allocate memory for random array.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tiscsit_create_random_array(array, seq_count);\n\n\tfor (i = 0; i < cmd->seq_count; i++) {\n\t\tif (cmd->seq_list[i].type != SEQTYPE_NORMAL)\n\t\t\tcontinue;\n\t\tcmd->seq_list[i].seq_send_order = array[j++];\n\t}\n\n\tkfree(array);\n\treturn 0;\n}\n\nstatic void iscsit_determine_counts_for_list(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsi_build_list *bl,\n\tu32 *seq_count,\n\tu32 *pdu_count)\n{\n\tint check_immediate = 0;\n\tu32 burstlength = 0, offset = 0;\n\tu32 unsolicited_data_length = 0;\n\tu32 mdsl;\n\tstruct iscsit_conn *conn = cmd->conn;\n\n\tif (cmd->se_cmd.data_direction == DMA_TO_DEVICE)\n\t\tmdsl = cmd->conn->conn_ops->MaxXmitDataSegmentLength;\n\telse\n\t\tmdsl = cmd->conn->conn_ops->MaxRecvDataSegmentLength;\n\n\tif ((bl->type == PDULIST_IMMEDIATE) ||\n\t    (bl->type == PDULIST_IMMEDIATE_AND_UNSOLICITED))\n\t\tcheck_immediate = 1;\n\n\tif ((bl->type == PDULIST_UNSOLICITED) ||\n\t    (bl->type == PDULIST_IMMEDIATE_AND_UNSOLICITED))\n\t\tunsolicited_data_length = min(cmd->se_cmd.data_length,\n\t\t\tconn->sess->sess_ops->FirstBurstLength);\n\n\twhile (offset < cmd->se_cmd.data_length) {\n\t\t*pdu_count += 1;\n\n\t\tif (check_immediate) {\n\t\t\tcheck_immediate = 0;\n\t\t\toffset += bl->immediate_data_length;\n\t\t\t*seq_count += 1;\n\t\t\tif (unsolicited_data_length)\n\t\t\t\tunsolicited_data_length -=\n\t\t\t\t\tbl->immediate_data_length;\n\t\t\tcontinue;\n\t\t}\n\t\tif (unsolicited_data_length > 0) {\n\t\t\tif ((offset + mdsl) >= cmd->se_cmd.data_length) {\n\t\t\t\tunsolicited_data_length -=\n\t\t\t\t\t(cmd->se_cmd.data_length - offset);\n\t\t\t\toffset += (cmd->se_cmd.data_length - offset);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((offset + mdsl)\n\t\t\t\t\t>= conn->sess->sess_ops->FirstBurstLength) {\n\t\t\t\tunsolicited_data_length -=\n\t\t\t\t\t(conn->sess->sess_ops->FirstBurstLength -\n\t\t\t\t\toffset);\n\t\t\t\toffset += (conn->sess->sess_ops->FirstBurstLength -\n\t\t\t\t\toffset);\n\t\t\t\tburstlength = 0;\n\t\t\t\t*seq_count += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toffset += mdsl;\n\t\t\tunsolicited_data_length -= mdsl;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((offset + mdsl) >= cmd->se_cmd.data_length) {\n\t\t\toffset += (cmd->se_cmd.data_length - offset);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((burstlength + mdsl) >=\n\t\t     conn->sess->sess_ops->MaxBurstLength) {\n\t\t\toffset += (conn->sess->sess_ops->MaxBurstLength -\n\t\t\t\t\tburstlength);\n\t\t\tburstlength = 0;\n\t\t\t*seq_count += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tburstlength += mdsl;\n\t\toffset += mdsl;\n\t}\n}\n\n\n \nstatic int iscsit_do_build_pdu_and_seq_lists(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsi_build_list *bl)\n{\n\tint check_immediate = 0, datapduinorder, datasequenceinorder;\n\tu32 burstlength = 0, offset = 0, i = 0, mdsl;\n\tu32 pdu_count = 0, seq_no = 0, unsolicited_data_length = 0;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_pdu *pdu = cmd->pdu_list;\n\tstruct iscsi_seq *seq = cmd->seq_list;\n\n\tif (cmd->se_cmd.data_direction == DMA_TO_DEVICE)\n\t\tmdsl = cmd->conn->conn_ops->MaxXmitDataSegmentLength;\n\telse\n\t\tmdsl = cmd->conn->conn_ops->MaxRecvDataSegmentLength;\n\n\tdatapduinorder = conn->sess->sess_ops->DataPDUInOrder;\n\tdatasequenceinorder = conn->sess->sess_ops->DataSequenceInOrder;\n\n\tif ((bl->type == PDULIST_IMMEDIATE) ||\n\t    (bl->type == PDULIST_IMMEDIATE_AND_UNSOLICITED))\n\t\tcheck_immediate = 1;\n\n\tif ((bl->type == PDULIST_UNSOLICITED) ||\n\t    (bl->type == PDULIST_IMMEDIATE_AND_UNSOLICITED))\n\t\tunsolicited_data_length = min(cmd->se_cmd.data_length,\n\t\t\tconn->sess->sess_ops->FirstBurstLength);\n\n\twhile (offset < cmd->se_cmd.data_length) {\n\t\tpdu_count++;\n\t\tif (!datapduinorder) {\n\t\t\tpdu[i].offset = offset;\n\t\t\tpdu[i].seq_no = seq_no;\n\t\t}\n\t\tif (!datasequenceinorder && (pdu_count == 1)) {\n\t\t\tseq[seq_no].pdu_start = i;\n\t\t\tseq[seq_no].seq_no = seq_no;\n\t\t\tseq[seq_no].offset = offset;\n\t\t\tseq[seq_no].orig_offset = offset;\n\t\t}\n\n\t\tif (check_immediate) {\n\t\t\tcheck_immediate = 0;\n\t\t\tif (!datapduinorder) {\n\t\t\t\tpdu[i].type = PDUTYPE_IMMEDIATE;\n\t\t\t\tpdu[i++].length = bl->immediate_data_length;\n\t\t\t}\n\t\t\tif (!datasequenceinorder) {\n\t\t\t\tseq[seq_no].type = SEQTYPE_IMMEDIATE;\n\t\t\t\tseq[seq_no].pdu_count = 1;\n\t\t\t\tseq[seq_no].xfer_len =\n\t\t\t\t\tbl->immediate_data_length;\n\t\t\t}\n\t\t\toffset += bl->immediate_data_length;\n\t\t\tpdu_count = 0;\n\t\t\tseq_no++;\n\t\t\tif (unsolicited_data_length)\n\t\t\t\tunsolicited_data_length -=\n\t\t\t\t\tbl->immediate_data_length;\n\t\t\tcontinue;\n\t\t}\n\t\tif (unsolicited_data_length > 0) {\n\t\t\tif ((offset + mdsl) >= cmd->se_cmd.data_length) {\n\t\t\t\tif (!datapduinorder) {\n\t\t\t\t\tpdu[i].type = PDUTYPE_UNSOLICITED;\n\t\t\t\t\tpdu[i].length =\n\t\t\t\t\t\t(cmd->se_cmd.data_length - offset);\n\t\t\t\t}\n\t\t\t\tif (!datasequenceinorder) {\n\t\t\t\t\tseq[seq_no].type = SEQTYPE_UNSOLICITED;\n\t\t\t\t\tseq[seq_no].pdu_count = pdu_count;\n\t\t\t\t\tseq[seq_no].xfer_len = (burstlength +\n\t\t\t\t\t\t(cmd->se_cmd.data_length - offset));\n\t\t\t\t}\n\t\t\t\tunsolicited_data_length -=\n\t\t\t\t\t\t(cmd->se_cmd.data_length - offset);\n\t\t\t\toffset += (cmd->se_cmd.data_length - offset);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((offset + mdsl) >=\n\t\t\t\t\tconn->sess->sess_ops->FirstBurstLength) {\n\t\t\t\tif (!datapduinorder) {\n\t\t\t\t\tpdu[i].type = PDUTYPE_UNSOLICITED;\n\t\t\t\t\tpdu[i++].length =\n\t\t\t\t\t   (conn->sess->sess_ops->FirstBurstLength -\n\t\t\t\t\t\toffset);\n\t\t\t\t}\n\t\t\t\tif (!datasequenceinorder) {\n\t\t\t\t\tseq[seq_no].type = SEQTYPE_UNSOLICITED;\n\t\t\t\t\tseq[seq_no].pdu_count = pdu_count;\n\t\t\t\t\tseq[seq_no].xfer_len = (burstlength +\n\t\t\t\t\t   (conn->sess->sess_ops->FirstBurstLength -\n\t\t\t\t\t\toffset));\n\t\t\t\t}\n\t\t\t\tunsolicited_data_length -=\n\t\t\t\t\t(conn->sess->sess_ops->FirstBurstLength -\n\t\t\t\t\t\toffset);\n\t\t\t\toffset += (conn->sess->sess_ops->FirstBurstLength -\n\t\t\t\t\t\toffset);\n\t\t\t\tburstlength = 0;\n\t\t\t\tpdu_count = 0;\n\t\t\t\tseq_no++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!datapduinorder) {\n\t\t\t\tpdu[i].type = PDUTYPE_UNSOLICITED;\n\t\t\t\tpdu[i++].length = mdsl;\n\t\t\t}\n\t\t\tburstlength += mdsl;\n\t\t\toffset += mdsl;\n\t\t\tunsolicited_data_length -= mdsl;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((offset + mdsl) >= cmd->se_cmd.data_length) {\n\t\t\tif (!datapduinorder) {\n\t\t\t\tpdu[i].type = PDUTYPE_NORMAL;\n\t\t\t\tpdu[i].length = (cmd->se_cmd.data_length - offset);\n\t\t\t}\n\t\t\tif (!datasequenceinorder) {\n\t\t\t\tseq[seq_no].type = SEQTYPE_NORMAL;\n\t\t\t\tseq[seq_no].pdu_count = pdu_count;\n\t\t\t\tseq[seq_no].xfer_len = (burstlength +\n\t\t\t\t\t(cmd->se_cmd.data_length - offset));\n\t\t\t}\n\t\t\toffset += (cmd->se_cmd.data_length - offset);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((burstlength + mdsl) >=\n\t\t     conn->sess->sess_ops->MaxBurstLength) {\n\t\t\tif (!datapduinorder) {\n\t\t\t\tpdu[i].type = PDUTYPE_NORMAL;\n\t\t\t\tpdu[i++].length =\n\t\t\t\t\t(conn->sess->sess_ops->MaxBurstLength -\n\t\t\t\t\t\tburstlength);\n\t\t\t}\n\t\t\tif (!datasequenceinorder) {\n\t\t\t\tseq[seq_no].type = SEQTYPE_NORMAL;\n\t\t\t\tseq[seq_no].pdu_count = pdu_count;\n\t\t\t\tseq[seq_no].xfer_len = (burstlength +\n\t\t\t\t\t(conn->sess->sess_ops->MaxBurstLength -\n\t\t\t\t\tburstlength));\n\t\t\t}\n\t\t\toffset += (conn->sess->sess_ops->MaxBurstLength -\n\t\t\t\t\tburstlength);\n\t\t\tburstlength = 0;\n\t\t\tpdu_count = 0;\n\t\t\tseq_no++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!datapduinorder) {\n\t\t\tpdu[i].type = PDUTYPE_NORMAL;\n\t\t\tpdu[i++].length = mdsl;\n\t\t}\n\t\tburstlength += mdsl;\n\t\toffset += mdsl;\n\t}\n\n\tif (!datasequenceinorder) {\n\t\tif (bl->data_direction & ISCSI_PDU_WRITE) {\n\t\t\tif (bl->randomize & RANDOM_R2T_OFFSETS) {\n\t\t\t\tif (iscsit_randomize_seq_lists(cmd, bl->type)\n\t\t\t\t\t\t< 0)\n\t\t\t\t\treturn -1;\n\t\t\t} else\n\t\t\t\tiscsit_ordered_seq_lists(cmd, bl->type);\n\t\t} else if (bl->data_direction & ISCSI_PDU_READ) {\n\t\t\tif (bl->randomize & RANDOM_DATAIN_SEQ_OFFSETS) {\n\t\t\t\tif (iscsit_randomize_seq_lists(cmd, bl->type)\n\t\t\t\t\t\t< 0)\n\t\t\t\t\treturn -1;\n\t\t\t} else\n\t\t\t\tiscsit_ordered_seq_lists(cmd, bl->type);\n\t\t}\n\n\t\tiscsit_dump_seq_list(cmd);\n\t}\n\tif (!datapduinorder) {\n\t\tif (bl->data_direction & ISCSI_PDU_WRITE) {\n\t\t\tif (bl->randomize & RANDOM_DATAOUT_PDU_OFFSETS) {\n\t\t\t\tif (iscsit_randomize_pdu_lists(cmd, bl->type)\n\t\t\t\t\t\t< 0)\n\t\t\t\t\treturn -1;\n\t\t\t} else\n\t\t\t\tiscsit_ordered_pdu_lists(cmd, bl->type);\n\t\t} else if (bl->data_direction & ISCSI_PDU_READ) {\n\t\t\tif (bl->randomize & RANDOM_DATAIN_PDU_OFFSETS) {\n\t\t\t\tif (iscsit_randomize_pdu_lists(cmd, bl->type)\n\t\t\t\t\t\t< 0)\n\t\t\t\t\treturn -1;\n\t\t\t} else\n\t\t\t\tiscsit_ordered_pdu_lists(cmd, bl->type);\n\t\t}\n\n\t\tiscsit_dump_pdu_list(cmd);\n\t}\n\n\treturn 0;\n}\n\nint iscsit_build_pdu_and_seq_lists(\n\tstruct iscsit_cmd *cmd,\n\tu32 immediate_data_length)\n{\n\tstruct iscsi_build_list bl;\n\tu32 pdu_count = 0, seq_count = 1;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_pdu *pdu = NULL;\n\tstruct iscsi_seq *seq = NULL;\n\n\tstruct iscsit_session *sess = conn->sess;\n\tstruct iscsi_node_attrib *na;\n\n\t \n\tif (sess->sess_ops->DataSequenceInOrder &&\n\t    sess->sess_ops->DataPDUInOrder)\n\t\treturn 0;\n\n\tif (cmd->data_direction == DMA_NONE)\n\t\treturn 0;\n\n\tna = iscsit_tpg_get_node_attrib(sess);\n\tmemset(&bl, 0, sizeof(struct iscsi_build_list));\n\n\tif (cmd->data_direction == DMA_FROM_DEVICE) {\n\t\tbl.data_direction = ISCSI_PDU_READ;\n\t\tbl.type = PDULIST_NORMAL;\n\t\tif (na->random_datain_pdu_offsets)\n\t\t\tbl.randomize |= RANDOM_DATAIN_PDU_OFFSETS;\n\t\tif (na->random_datain_seq_offsets)\n\t\t\tbl.randomize |= RANDOM_DATAIN_SEQ_OFFSETS;\n\t} else {\n\t\tbl.data_direction = ISCSI_PDU_WRITE;\n\t\tbl.immediate_data_length = immediate_data_length;\n\t\tif (na->random_r2t_offsets)\n\t\t\tbl.randomize |= RANDOM_R2T_OFFSETS;\n\n\t\tif (!cmd->immediate_data && !cmd->unsolicited_data)\n\t\t\tbl.type = PDULIST_NORMAL;\n\t\telse if (cmd->immediate_data && !cmd->unsolicited_data)\n\t\t\tbl.type = PDULIST_IMMEDIATE;\n\t\telse if (!cmd->immediate_data && cmd->unsolicited_data)\n\t\t\tbl.type = PDULIST_UNSOLICITED;\n\t\telse if (cmd->immediate_data && cmd->unsolicited_data)\n\t\t\tbl.type = PDULIST_IMMEDIATE_AND_UNSOLICITED;\n\t}\n\n\tiscsit_determine_counts_for_list(cmd, &bl, &seq_count, &pdu_count);\n\n\tif (!conn->sess->sess_ops->DataSequenceInOrder) {\n\t\tseq = kcalloc(seq_count, sizeof(struct iscsi_seq), GFP_ATOMIC);\n\t\tif (!seq) {\n\t\t\tpr_err(\"Unable to allocate struct iscsi_seq list\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcmd->seq_list = seq;\n\t\tcmd->seq_count = seq_count;\n\t}\n\n\tif (!conn->sess->sess_ops->DataPDUInOrder) {\n\t\tpdu = kcalloc(pdu_count, sizeof(struct iscsi_pdu), GFP_ATOMIC);\n\t\tif (!pdu) {\n\t\t\tpr_err(\"Unable to allocate struct iscsi_pdu list.\\n\");\n\t\t\tkfree(seq);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcmd->pdu_list = pdu;\n\t\tcmd->pdu_count = pdu_count;\n\t}\n\n\treturn iscsit_do_build_pdu_and_seq_lists(cmd, &bl);\n}\n\nstruct iscsi_pdu *iscsit_get_pdu_holder(\n\tstruct iscsit_cmd *cmd,\n\tu32 offset,\n\tu32 length)\n{\n\tu32 i;\n\tstruct iscsi_pdu *pdu = NULL;\n\n\tif (!cmd->pdu_list) {\n\t\tpr_err(\"struct iscsit_cmd->pdu_list is NULL!\\n\");\n\t\treturn NULL;\n\t}\n\n\tpdu = &cmd->pdu_list[0];\n\n\tfor (i = 0; i < cmd->pdu_count; i++)\n\t\tif ((pdu[i].offset == offset) && (pdu[i].length == length))\n\t\t\treturn &pdu[i];\n\n\tpr_err(\"Unable to locate PDU holder for ITT: 0x%08x, Offset:\"\n\t\t\" %u, Length: %u\\n\", cmd->init_task_tag, offset, length);\n\treturn NULL;\n}\n\nstruct iscsi_pdu *iscsit_get_pdu_holder_for_seq(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsi_seq *seq)\n{\n\tu32 i;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_pdu *pdu = NULL;\n\n\tif (!cmd->pdu_list) {\n\t\tpr_err(\"struct iscsit_cmd->pdu_list is NULL!\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (conn->sess->sess_ops->DataSequenceInOrder) {\nredo:\n\t\tpdu = &cmd->pdu_list[cmd->pdu_start];\n\n\t\tfor (i = 0; pdu[i].seq_no != cmd->seq_no; i++) {\n\t\t\tpr_debug(\"pdu[i].seq_no: %d, pdu[i].pdu\"\n\t\t\t\t\"_send_order: %d, pdu[i].offset: %d,\"\n\t\t\t\t\" pdu[i].length: %d\\n\", pdu[i].seq_no,\n\t\t\t\tpdu[i].pdu_send_order, pdu[i].offset,\n\t\t\t\tpdu[i].length);\n\n\t\t\tif (pdu[i].pdu_send_order == cmd->pdu_send_order) {\n\t\t\t\tcmd->pdu_send_order++;\n\t\t\t\treturn &pdu[i];\n\t\t\t}\n\t\t}\n\n\t\tcmd->pdu_start += cmd->pdu_send_order;\n\t\tcmd->pdu_send_order = 0;\n\t\tcmd->seq_no++;\n\n\t\tif (cmd->pdu_start < cmd->pdu_count)\n\t\t\tgoto redo;\n\n\t\tpr_err(\"Command ITT: 0x%08x unable to locate\"\n\t\t\t\" struct iscsi_pdu for cmd->pdu_send_order: %u.\\n\",\n\t\t\tcmd->init_task_tag, cmd->pdu_send_order);\n\t\treturn NULL;\n\t} else {\n\t\tif (!seq) {\n\t\t\tpr_err(\"struct iscsi_seq is NULL!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tpr_debug(\"seq->pdu_start: %d, seq->pdu_count: %d,\"\n\t\t\t\" seq->seq_no: %d\\n\", seq->pdu_start, seq->pdu_count,\n\t\t\tseq->seq_no);\n\n\t\tpdu = &cmd->pdu_list[seq->pdu_start];\n\n\t\tif (seq->pdu_send_order == seq->pdu_count) {\n\t\t\tpr_err(\"Command ITT: 0x%08x seq->pdu_send\"\n\t\t\t\t\"_order: %u equals seq->pdu_count: %u\\n\",\n\t\t\t\tcmd->init_task_tag, seq->pdu_send_order,\n\t\t\t\tseq->pdu_count);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (i = 0; i < seq->pdu_count; i++) {\n\t\t\tif (pdu[i].pdu_send_order == seq->pdu_send_order) {\n\t\t\t\tseq->pdu_send_order++;\n\t\t\t\treturn &pdu[i];\n\t\t\t}\n\t\t}\n\n\t\tpr_err(\"Command ITT: 0x%08x unable to locate iscsi\"\n\t\t\t\"_pdu_t for seq->pdu_send_order: %u.\\n\",\n\t\t\tcmd->init_task_tag, seq->pdu_send_order);\n\t\treturn NULL;\n\t}\n\n\treturn NULL;\n}\n\nstruct iscsi_seq *iscsit_get_seq_holder(\n\tstruct iscsit_cmd *cmd,\n\tu32 offset,\n\tu32 length)\n{\n\tu32 i;\n\n\tif (!cmd->seq_list) {\n\t\tpr_err(\"struct iscsit_cmd->seq_list is NULL!\\n\");\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < cmd->seq_count; i++) {\n\t\tpr_debug(\"seq_list[i].orig_offset: %d, seq_list[i].\"\n\t\t\t\"xfer_len: %d, seq_list[i].seq_no %u\\n\",\n\t\t\tcmd->seq_list[i].orig_offset, cmd->seq_list[i].xfer_len,\n\t\t\tcmd->seq_list[i].seq_no);\n\n\t\tif ((cmd->seq_list[i].orig_offset +\n\t\t\t\tcmd->seq_list[i].xfer_len) >=\n\t\t\t\t(offset + length))\n\t\t\treturn &cmd->seq_list[i];\n\t}\n\n\tpr_err(\"Unable to locate Sequence holder for ITT: 0x%08x,\"\n\t\t\" Offset: %u, Length: %u\\n\", cmd->init_task_tag, offset,\n\t\tlength);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}