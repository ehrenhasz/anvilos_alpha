{
  "module_name": "iscsi_target_nodeattrib.c",
  "hash_id": "d5f0ea073ba90aa0d7962ebaebc3a98813b1505af5c7e861e13e3a38bb0d2c26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target_nodeattrib.c",
  "human_readable_source": "\n \n\n#include <target/target_core_base.h>\n\n#include <target/iscsi/iscsi_target_core.h>\n#include \"iscsi_target_device.h\"\n#include \"iscsi_target_tpg.h\"\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target_nodeattrib.h\"\n\nstatic inline char *iscsit_na_get_initiatorname(\n\tstruct iscsi_node_acl *nacl)\n{\n\tstruct se_node_acl *se_nacl = &nacl->se_node_acl;\n\n\treturn &se_nacl->initiatorname[0];\n}\n\nvoid iscsit_set_default_node_attribues(\n\tstruct iscsi_node_acl *acl,\n\tstruct iscsi_portal_group *tpg)\n{\n\tstruct iscsi_node_attrib *a = &acl->node_attrib;\n\n\ta->authentication = NA_AUTHENTICATION_INHERITED;\n\ta->dataout_timeout = NA_DATAOUT_TIMEOUT;\n\ta->dataout_timeout_retries = NA_DATAOUT_TIMEOUT_RETRIES;\n\ta->nopin_timeout = NA_NOPIN_TIMEOUT;\n\ta->nopin_response_timeout = NA_NOPIN_RESPONSE_TIMEOUT;\n\ta->random_datain_pdu_offsets = NA_RANDOM_DATAIN_PDU_OFFSETS;\n\ta->random_datain_seq_offsets = NA_RANDOM_DATAIN_SEQ_OFFSETS;\n\ta->random_r2t_offsets = NA_RANDOM_R2T_OFFSETS;\n\ta->default_erl = tpg->tpg_attrib.default_erl;\n}\n\nint iscsit_na_dataout_timeout(\n\tstruct iscsi_node_acl *acl,\n\tu32 dataout_timeout)\n{\n\tstruct iscsi_node_attrib *a = &acl->node_attrib;\n\n\tif (dataout_timeout > NA_DATAOUT_TIMEOUT_MAX) {\n\t\tpr_err(\"Requested DataOut Timeout %u larger than\"\n\t\t\t\" maximum %u\\n\", dataout_timeout,\n\t\t\tNA_DATAOUT_TIMEOUT_MAX);\n\t\treturn -EINVAL;\n\t} else if (dataout_timeout < NA_DATAOUT_TIMEOUT_MIX) {\n\t\tpr_err(\"Requested DataOut Timeout %u smaller than\"\n\t\t\t\" minimum %u\\n\", dataout_timeout,\n\t\t\tNA_DATAOUT_TIMEOUT_MIX);\n\t\treturn -EINVAL;\n\t}\n\n\ta->dataout_timeout = dataout_timeout;\n\tpr_debug(\"Set DataOut Timeout to %u for Initiator Node\"\n\t\t\" %s\\n\", a->dataout_timeout, iscsit_na_get_initiatorname(acl));\n\n\treturn 0;\n}\n\nint iscsit_na_dataout_timeout_retries(\n\tstruct iscsi_node_acl *acl,\n\tu32 dataout_timeout_retries)\n{\n\tstruct iscsi_node_attrib *a = &acl->node_attrib;\n\n\tif (dataout_timeout_retries > NA_DATAOUT_TIMEOUT_RETRIES_MAX) {\n\t\tpr_err(\"Requested DataOut Timeout Retries %u larger\"\n\t\t\t\" than maximum %u\", dataout_timeout_retries,\n\t\t\t\tNA_DATAOUT_TIMEOUT_RETRIES_MAX);\n\t\treturn -EINVAL;\n\t} else if (dataout_timeout_retries < NA_DATAOUT_TIMEOUT_RETRIES_MIN) {\n\t\tpr_err(\"Requested DataOut Timeout Retries %u smaller\"\n\t\t\t\" than minimum %u\", dataout_timeout_retries,\n\t\t\t\tNA_DATAOUT_TIMEOUT_RETRIES_MIN);\n\t\treturn -EINVAL;\n\t}\n\n\ta->dataout_timeout_retries = dataout_timeout_retries;\n\tpr_debug(\"Set DataOut Timeout Retries to %u for\"\n\t\t\" Initiator Node %s\\n\", a->dataout_timeout_retries,\n\t\tiscsit_na_get_initiatorname(acl));\n\n\treturn 0;\n}\n\nint iscsit_na_nopin_timeout(\n\tstruct iscsi_node_acl *acl,\n\tu32 nopin_timeout)\n{\n\tstruct iscsi_node_attrib *a = &acl->node_attrib;\n\tstruct iscsit_session *sess;\n\tstruct iscsit_conn *conn;\n\tstruct se_node_acl *se_nacl = &a->nacl->se_node_acl;\n\tstruct se_session *se_sess;\n\tu32 orig_nopin_timeout = a->nopin_timeout;\n\n\tif (nopin_timeout > NA_NOPIN_TIMEOUT_MAX) {\n\t\tpr_err(\"Requested NopIn Timeout %u larger than maximum\"\n\t\t\t\" %u\\n\", nopin_timeout, NA_NOPIN_TIMEOUT_MAX);\n\t\treturn -EINVAL;\n\t} else if ((nopin_timeout < NA_NOPIN_TIMEOUT_MIN) &&\n\t\t   (nopin_timeout != 0)) {\n\t\tpr_err(\"Requested NopIn Timeout %u smaller than\"\n\t\t\t\" minimum %u and not 0\\n\", nopin_timeout,\n\t\t\tNA_NOPIN_TIMEOUT_MIN);\n\t\treturn -EINVAL;\n\t}\n\n\ta->nopin_timeout = nopin_timeout;\n\tpr_debug(\"Set NopIn Timeout to %u for Initiator\"\n\t\t\" Node %s\\n\", a->nopin_timeout,\n\t\tiscsit_na_get_initiatorname(acl));\n\t \n\tif (!orig_nopin_timeout) {\n\t\tspin_lock_bh(&se_nacl->nacl_sess_lock);\n\t\tse_sess = se_nacl->nacl_sess;\n\t\tif (se_sess) {\n\t\t\tsess = se_sess->fabric_sess_ptr;\n\n\t\t\tspin_lock(&sess->conn_lock);\n\t\t\tlist_for_each_entry(conn, &sess->sess_conn_list,\n\t\t\t\t\tconn_list) {\n\t\t\t\tif (conn->conn_state !=\n\t\t\t\t\t\tTARG_CONN_STATE_LOGGED_IN)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tspin_lock(&conn->nopin_timer_lock);\n\t\t\t\t__iscsit_start_nopin_timer(conn);\n\t\t\t\tspin_unlock(&conn->nopin_timer_lock);\n\t\t\t}\n\t\t\tspin_unlock(&sess->conn_lock);\n\t\t}\n\t\tspin_unlock_bh(&se_nacl->nacl_sess_lock);\n\t}\n\n\treturn 0;\n}\n\nint iscsit_na_nopin_response_timeout(\n\tstruct iscsi_node_acl *acl,\n\tu32 nopin_response_timeout)\n{\n\tstruct iscsi_node_attrib *a = &acl->node_attrib;\n\n\tif (nopin_response_timeout > NA_NOPIN_RESPONSE_TIMEOUT_MAX) {\n\t\tpr_err(\"Requested NopIn Response Timeout %u larger\"\n\t\t\t\" than maximum %u\\n\", nopin_response_timeout,\n\t\t\t\tNA_NOPIN_RESPONSE_TIMEOUT_MAX);\n\t\treturn -EINVAL;\n\t} else if (nopin_response_timeout < NA_NOPIN_RESPONSE_TIMEOUT_MIN) {\n\t\tpr_err(\"Requested NopIn Response Timeout %u smaller\"\n\t\t\t\" than minimum %u\\n\", nopin_response_timeout,\n\t\t\t\tNA_NOPIN_RESPONSE_TIMEOUT_MIN);\n\t\treturn -EINVAL;\n\t}\n\n\ta->nopin_response_timeout = nopin_response_timeout;\n\tpr_debug(\"Set NopIn Response Timeout to %u for\"\n\t\t\" Initiator Node %s\\n\", a->nopin_timeout,\n\t\tiscsit_na_get_initiatorname(acl));\n\n\treturn 0;\n}\n\nint iscsit_na_random_datain_pdu_offsets(\n\tstruct iscsi_node_acl *acl,\n\tu32 random_datain_pdu_offsets)\n{\n\tstruct iscsi_node_attrib *a = &acl->node_attrib;\n\n\tif (random_datain_pdu_offsets != 0 && random_datain_pdu_offsets != 1) {\n\t\tpr_err(\"Requested Random DataIN PDU Offsets: %u not\"\n\t\t\t\" 0 or 1\\n\", random_datain_pdu_offsets);\n\t\treturn -EINVAL;\n\t}\n\n\ta->random_datain_pdu_offsets = random_datain_pdu_offsets;\n\tpr_debug(\"Set Random DataIN PDU Offsets to %u for\"\n\t\t\" Initiator Node %s\\n\", a->random_datain_pdu_offsets,\n\t\tiscsit_na_get_initiatorname(acl));\n\n\treturn 0;\n}\n\nint iscsit_na_random_datain_seq_offsets(\n\tstruct iscsi_node_acl *acl,\n\tu32 random_datain_seq_offsets)\n{\n\tstruct iscsi_node_attrib *a = &acl->node_attrib;\n\n\tif (random_datain_seq_offsets != 0 && random_datain_seq_offsets != 1) {\n\t\tpr_err(\"Requested Random DataIN Sequence Offsets: %u\"\n\t\t\t\" not 0 or 1\\n\", random_datain_seq_offsets);\n\t\treturn -EINVAL;\n\t}\n\n\ta->random_datain_seq_offsets = random_datain_seq_offsets;\n\tpr_debug(\"Set Random DataIN Sequence Offsets to %u for\"\n\t\t\" Initiator Node %s\\n\", a->random_datain_seq_offsets,\n\t\tiscsit_na_get_initiatorname(acl));\n\n\treturn 0;\n}\n\nint iscsit_na_random_r2t_offsets(\n\tstruct iscsi_node_acl *acl,\n\tu32 random_r2t_offsets)\n{\n\tstruct iscsi_node_attrib *a = &acl->node_attrib;\n\n\tif (random_r2t_offsets != 0 && random_r2t_offsets != 1) {\n\t\tpr_err(\"Requested Random R2T Offsets: %u not\"\n\t\t\t\" 0 or 1\\n\", random_r2t_offsets);\n\t\treturn -EINVAL;\n\t}\n\n\ta->random_r2t_offsets = random_r2t_offsets;\n\tpr_debug(\"Set Random R2T Offsets to %u for\"\n\t\t\" Initiator Node %s\\n\", a->random_r2t_offsets,\n\t\tiscsit_na_get_initiatorname(acl));\n\n\treturn 0;\n}\n\nint iscsit_na_default_erl(\n\tstruct iscsi_node_acl *acl,\n\tu32 default_erl)\n{\n\tstruct iscsi_node_attrib *a = &acl->node_attrib;\n\n\tif (default_erl != 0 && default_erl != 1 && default_erl != 2) {\n\t\tpr_err(\"Requested default ERL: %u not 0, 1, or 2\\n\",\n\t\t\t\tdefault_erl);\n\t\treturn -EINVAL;\n\t}\n\n\ta->default_erl = default_erl;\n\tpr_debug(\"Set use ERL0 flag to %u for Initiator\"\n\t\t\" Node %s\\n\", a->default_erl,\n\t\tiscsit_na_get_initiatorname(acl));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}