{
  "module_name": "cxgbit.h",
  "hash_id": "f5e7106cd3b4cd635222aabea13e5aeb2702b5292647940d0f2bb9e68232ef0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/cxgbit/cxgbit.h",
  "human_readable_source": " \n \n\n#ifndef __CXGBIT_H__\n#define __CXGBIT_H__\n\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/idr.h>\n#include <linux/completion.h>\n#include <linux/netdevice.h>\n#include <linux/sched.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/inet.h>\n#include <linux/wait.h>\n#include <linux/kref.h>\n#include <linux/timer.h>\n#include <linux/io.h>\n\n#include <asm/byteorder.h>\n\n#include <net/net_namespace.h>\n\n#include <target/iscsi/iscsi_transport.h>\n#include <iscsi_target_parameters.h>\n#include <iscsi_target_login.h>\n\n#include \"t4_regs.h\"\n#include \"t4_msg.h\"\n#include \"cxgb4.h\"\n#include \"cxgb4_uld.h\"\n#include \"l2t.h\"\n#include \"libcxgb_ppm.h\"\n#include \"cxgbit_lro.h\"\n\nextern struct mutex cdev_list_lock;\nextern struct list_head cdev_list_head;\nstruct cxgbit_np;\n\nstruct cxgbit_sock;\n\nstruct cxgbit_cmd {\n\tstruct scatterlist sg;\n\tstruct cxgbi_task_tag_info ttinfo;\n\tbool setup_ddp;\n\tbool release;\n};\n\n#define CXGBIT_MAX_ISO_PAYLOAD\t\\\n\tmin_t(u32, MAX_SKB_FRAGS * PAGE_SIZE, 65535)\n\nstruct cxgbit_iso_info {\n\tu8 flags;\n\tu32 mpdu;\n\tu32 len;\n\tu32 burst_len;\n};\n\nenum cxgbit_skcb_flags {\n\tSKCBF_TX_NEED_HDR\t= (1 << 0),  \n\tSKCBF_TX_FLAG_COMPL\t= (1 << 1),  \n\tSKCBF_TX_ISO\t\t= (1 << 2),  \n\tSKCBF_RX_LRO\t\t= (1 << 3),  \n};\n\nstruct cxgbit_skb_rx_cb {\n\tu8 opcode;\n\tvoid *pdu_cb;\n\tvoid (*backlog_fn)(struct cxgbit_sock *, struct sk_buff *);\n};\n\nstruct cxgbit_skb_tx_cb {\n\tu8 submode;\n\tu32 extra_len;\n};\n\nunion cxgbit_skb_cb {\n\tstruct {\n\t\tu8 flags;\n\t\tunion {\n\t\t\tstruct cxgbit_skb_tx_cb tx;\n\t\t\tstruct cxgbit_skb_rx_cb rx;\n\t\t};\n\t};\n\n\tstruct {\n\t\t \n\t\tstruct l2t_skb_cb l2t;\n\t\tstruct sk_buff *wr_next;\n\t};\n};\n\n#define CXGBIT_SKB_CB(skb)\t((union cxgbit_skb_cb *)&((skb)->cb[0]))\n#define cxgbit_skcb_flags(skb)\t\t(CXGBIT_SKB_CB(skb)->flags)\n#define cxgbit_skcb_submode(skb)\t(CXGBIT_SKB_CB(skb)->tx.submode)\n#define cxgbit_skcb_tx_wr_next(skb)\t(CXGBIT_SKB_CB(skb)->wr_next)\n#define cxgbit_skcb_tx_extralen(skb)\t(CXGBIT_SKB_CB(skb)->tx.extra_len)\n#define cxgbit_skcb_rx_opcode(skb)\t(CXGBIT_SKB_CB(skb)->rx.opcode)\n#define cxgbit_skcb_rx_backlog_fn(skb)\t(CXGBIT_SKB_CB(skb)->rx.backlog_fn)\n#define cxgbit_rx_pdu_cb(skb)\t\t(CXGBIT_SKB_CB(skb)->rx.pdu_cb)\n\nstatic inline void *cplhdr(struct sk_buff *skb)\n{\n\treturn skb->data;\n}\n\nenum cxgbit_cdev_flags {\n\tCDEV_STATE_UP = 0,\n\tCDEV_ISO_ENABLE,\n\tCDEV_DDP_ENABLE,\n};\n\n#define NP_INFO_HASH_SIZE 32\n\nstruct np_info {\n\tstruct np_info *next;\n\tstruct cxgbit_np *cnp;\n\tunsigned int stid;\n};\n\nstruct cxgbit_list_head {\n\tstruct list_head list;\n\t \n\tspinlock_t lock;\n};\n\nstruct cxgbit_device {\n\tstruct list_head list;\n\tstruct cxgb4_lld_info lldi;\n\tstruct np_info *np_hash_tab[NP_INFO_HASH_SIZE];\n\t \n\tspinlock_t np_lock;\n\tu8 selectq[MAX_NPORTS][2];\n\tstruct cxgbit_list_head cskq;\n\tu32 mdsl;\n\tstruct kref kref;\n\tunsigned long flags;\n};\n\nstruct cxgbit_wr_wait {\n\tstruct completion completion;\n\tint ret;\n};\n\nenum cxgbit_csk_state {\n\tCSK_STATE_IDLE = 0,\n\tCSK_STATE_LISTEN,\n\tCSK_STATE_CONNECTING,\n\tCSK_STATE_ESTABLISHED,\n\tCSK_STATE_ABORTING,\n\tCSK_STATE_CLOSING,\n\tCSK_STATE_MORIBUND,\n\tCSK_STATE_DEAD,\n};\n\nenum cxgbit_csk_flags {\n\tCSK_TX_DATA_SENT = 0,\n\tCSK_LOGIN_PDU_DONE,\n\tCSK_LOGIN_DONE,\n\tCSK_DDP_ENABLE,\n\tCSK_ABORT_RPL_WAIT,\n};\n\nstruct cxgbit_sock_common {\n\tstruct cxgbit_device *cdev;\n\tstruct sockaddr_storage local_addr;\n\tstruct sockaddr_storage remote_addr;\n\tstruct cxgbit_wr_wait wr_wait;\n\tenum cxgbit_csk_state state;\n\tunsigned long flags;\n};\n\nstruct cxgbit_np {\n\tstruct cxgbit_sock_common com;\n\twait_queue_head_t accept_wait;\n\tstruct iscsi_np *np;\n\tstruct completion accept_comp;\n\tstruct list_head np_accept_list;\n\t \n\tspinlock_t np_accept_lock;\n\tstruct kref kref;\n\tunsigned int stid;\n};\n\nstruct cxgbit_sock {\n\tstruct cxgbit_sock_common com;\n\tstruct cxgbit_np *cnp;\n\tstruct iscsit_conn *conn;\n\tstruct l2t_entry *l2t;\n\tstruct dst_entry *dst;\n\tstruct list_head list;\n\tstruct sk_buff_head rxq;\n\tstruct sk_buff_head txq;\n\tstruct sk_buff_head ppodq;\n\tstruct sk_buff_head backlogq;\n\tstruct sk_buff_head skbq;\n\tstruct sk_buff *wr_pending_head;\n\tstruct sk_buff *wr_pending_tail;\n\tstruct sk_buff *skb;\n\tstruct sk_buff *lro_skb;\n\tstruct sk_buff *lro_hskb;\n\tstruct list_head accept_node;\n\t \n\tspinlock_t lock;\n\twait_queue_head_t waitq;\n\tbool lock_owner;\n\tstruct kref kref;\n\tu32 max_iso_npdu;\n\tu32 wr_cred;\n\tu32 wr_una_cred;\n\tu32 wr_max_cred;\n\tu32 snd_una;\n\tu32 tid;\n\tu32 snd_nxt;\n\tu32 rcv_nxt;\n\tu32 smac_idx;\n\tu32 tx_chan;\n\tu32 mtu;\n\tu32 write_seq;\n\tu32 rx_credits;\n\tu32 snd_win;\n\tu32 rcv_win;\n\tu16 mss;\n\tu16 emss;\n\tu16 plen;\n\tu16 rss_qid;\n\tu16 txq_idx;\n\tu16 ctrlq_idx;\n\tu8 tos;\n\tu8 port_id;\n#define CXGBIT_SUBMODE_HCRC 0x1\n#define CXGBIT_SUBMODE_DCRC 0x2\n\tu8 submode;\n#ifdef CONFIG_CHELSIO_T4_DCB\n\tu8 dcb_priority;\n#endif\n\tu8 snd_wscale;\n};\n\nvoid _cxgbit_free_cdev(struct kref *kref);\nvoid _cxgbit_free_csk(struct kref *kref);\nvoid _cxgbit_free_cnp(struct kref *kref);\n\nstatic inline void cxgbit_get_cdev(struct cxgbit_device *cdev)\n{\n\tkref_get(&cdev->kref);\n}\n\nstatic inline void cxgbit_put_cdev(struct cxgbit_device *cdev)\n{\n\tkref_put(&cdev->kref, _cxgbit_free_cdev);\n}\n\nstatic inline void cxgbit_get_csk(struct cxgbit_sock *csk)\n{\n\tkref_get(&csk->kref);\n}\n\nstatic inline void cxgbit_put_csk(struct cxgbit_sock *csk)\n{\n\tkref_put(&csk->kref, _cxgbit_free_csk);\n}\n\nstatic inline void cxgbit_get_cnp(struct cxgbit_np *cnp)\n{\n\tkref_get(&cnp->kref);\n}\n\nstatic inline void cxgbit_put_cnp(struct cxgbit_np *cnp)\n{\n\tkref_put(&cnp->kref, _cxgbit_free_cnp);\n}\n\nstatic inline void cxgbit_sock_reset_wr_list(struct cxgbit_sock *csk)\n{\n\tcsk->wr_pending_tail = NULL;\n\tcsk->wr_pending_head = NULL;\n}\n\nstatic inline struct sk_buff *cxgbit_sock_peek_wr(const struct cxgbit_sock *csk)\n{\n\treturn csk->wr_pending_head;\n}\n\nstatic inline void\ncxgbit_sock_enqueue_wr(struct cxgbit_sock *csk, struct sk_buff *skb)\n{\n\tcxgbit_skcb_tx_wr_next(skb) = NULL;\n\n\tskb_get(skb);\n\n\tif (!csk->wr_pending_head)\n\t\tcsk->wr_pending_head = skb;\n\telse\n\t\tcxgbit_skcb_tx_wr_next(csk->wr_pending_tail) = skb;\n\tcsk->wr_pending_tail = skb;\n}\n\nstatic inline struct sk_buff *cxgbit_sock_dequeue_wr(struct cxgbit_sock *csk)\n{\n\tstruct sk_buff *skb = csk->wr_pending_head;\n\n\tif (likely(skb)) {\n\t\tcsk->wr_pending_head = cxgbit_skcb_tx_wr_next(skb);\n\t\tcxgbit_skcb_tx_wr_next(skb) = NULL;\n\t}\n\treturn skb;\n}\n\ntypedef void (*cxgbit_cplhandler_func)(struct cxgbit_device *,\n\t\t\t\t       struct sk_buff *);\n\nint cxgbit_setup_np(struct iscsi_np *, struct sockaddr_storage *);\nint cxgbit_setup_conn_digest(struct cxgbit_sock *);\nint cxgbit_accept_np(struct iscsi_np *, struct iscsit_conn *);\nvoid cxgbit_free_np(struct iscsi_np *);\nvoid cxgbit_abort_conn(struct cxgbit_sock *csk);\nvoid cxgbit_free_conn(struct iscsit_conn *);\nextern cxgbit_cplhandler_func cxgbit_cplhandlers[NUM_CPL_CMDS];\nint cxgbit_get_login_rx(struct iscsit_conn *, struct iscsi_login *);\nint cxgbit_rx_data_ack(struct cxgbit_sock *);\nint cxgbit_l2t_send(struct cxgbit_device *, struct sk_buff *,\n\t\t    struct l2t_entry *);\nvoid cxgbit_push_tx_frames(struct cxgbit_sock *);\nint cxgbit_put_login_tx(struct iscsit_conn *, struct iscsi_login *, u32);\nint cxgbit_xmit_pdu(struct iscsit_conn *, struct iscsit_cmd *,\n\t\t    struct iscsi_datain_req *, const void *, u32);\nvoid cxgbit_get_r2t_ttt(struct iscsit_conn *, struct iscsit_cmd *,\n\t\t\tstruct iscsi_r2t *);\nu32 cxgbit_send_tx_flowc_wr(struct cxgbit_sock *);\nint cxgbit_ofld_send(struct cxgbit_device *, struct sk_buff *);\nvoid cxgbit_get_rx_pdu(struct iscsit_conn *);\nint cxgbit_validate_params(struct iscsit_conn *);\nstruct cxgbit_device *cxgbit_find_device(struct net_device *, u8 *);\n\n \nint cxgbit_ddp_init(struct cxgbit_device *);\nint cxgbit_setup_conn_pgidx(struct cxgbit_sock *, u32);\nint cxgbit_reserve_ttt(struct cxgbit_sock *, struct iscsit_cmd *);\nvoid cxgbit_unmap_cmd(struct iscsit_conn *, struct iscsit_cmd *);\n\nstatic inline\nstruct cxgbi_ppm *cdev2ppm(struct cxgbit_device *cdev)\n{\n\treturn (struct cxgbi_ppm *)(*cdev->lldi.iscsi_ppm);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}