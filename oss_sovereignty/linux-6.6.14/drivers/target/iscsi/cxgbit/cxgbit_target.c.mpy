{
  "module_name": "cxgbit_target.c",
  "hash_id": "745c2a89f764e55451421fd2130a05288cdb59bec4101dc1ca3da76c7ff5626c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/cxgbit/cxgbit_target.c",
  "human_readable_source": "\n \n\n#include <linux/workqueue.h>\n#include <linux/kthread.h>\n#include <linux/sched/signal.h>\n\n#include <asm/unaligned.h>\n#include <net/tcp.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n#include \"cxgbit.h\"\n\nstruct sge_opaque_hdr {\n\tvoid *dev;\n\tdma_addr_t addr[MAX_SKB_FRAGS + 1];\n};\n\nstatic const u8 cxgbit_digest_len[] = {0, 4, 4, 8};\n\n#define TX_HDR_LEN (sizeof(struct sge_opaque_hdr) + \\\n\t\t    sizeof(struct fw_ofld_tx_data_wr))\n\nstatic struct sk_buff *\n__cxgbit_alloc_skb(struct cxgbit_sock *csk, u32 len, bool iso)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 submode = 0;\n\tint errcode;\n\tstatic const u32 hdr_len = TX_HDR_LEN + ISCSI_HDR_LEN;\n\n\tif (len) {\n\t\tskb = alloc_skb_with_frags(hdr_len, len,\n\t\t\t\t\t   0, &errcode,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\n\t\tskb_reserve(skb, TX_HDR_LEN);\n\t\tskb_reset_transport_header(skb);\n\t\t__skb_put(skb, ISCSI_HDR_LEN);\n\t\tskb->data_len = len;\n\t\tskb->len += len;\n\t\tsubmode |= (csk->submode & CXGBIT_SUBMODE_DCRC);\n\n\t} else {\n\t\tu32 iso_len = iso ? sizeof(struct cpl_tx_data_iso) : 0;\n\n\t\tskb = alloc_skb(hdr_len + iso_len, GFP_KERNEL);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\n\t\tskb_reserve(skb, TX_HDR_LEN + iso_len);\n\t\tskb_reset_transport_header(skb);\n\t\t__skb_put(skb, ISCSI_HDR_LEN);\n\t}\n\n\tsubmode |= (csk->submode & CXGBIT_SUBMODE_HCRC);\n\tcxgbit_skcb_submode(skb) = submode;\n\tcxgbit_skcb_tx_extralen(skb) = cxgbit_digest_len[submode];\n\tcxgbit_skcb_flags(skb) |= SKCBF_TX_NEED_HDR;\n\treturn skb;\n}\n\nstatic struct sk_buff *cxgbit_alloc_skb(struct cxgbit_sock *csk, u32 len)\n{\n\treturn __cxgbit_alloc_skb(csk, len, false);\n}\n\n \nstatic int cxgbit_is_ofld_imm(const struct sk_buff *skb)\n{\n\tint length = skb->len;\n\n\tif (likely(cxgbit_skcb_flags(skb) & SKCBF_TX_NEED_HDR))\n\t\tlength += sizeof(struct fw_ofld_tx_data_wr);\n\n\tif (likely(cxgbit_skcb_flags(skb) & SKCBF_TX_ISO))\n\t\tlength += sizeof(struct cpl_tx_data_iso);\n\n\treturn length <= MAX_IMM_OFLD_TX_DATA_WR_LEN;\n}\n\n \nstatic inline unsigned int cxgbit_sgl_len(unsigned int n)\n{\n\tn--;\n\treturn (3 * n) / 2 + (n & 1) + 2;\n}\n\n \nstatic unsigned int cxgbit_calc_tx_flits_ofld(const struct sk_buff *skb)\n{\n\tunsigned int flits, cnt;\n\n\tif (cxgbit_is_ofld_imm(skb))\n\t\treturn DIV_ROUND_UP(skb->len, 8);\n\tflits = skb_transport_offset(skb) / 8;\n\tcnt = skb_shinfo(skb)->nr_frags;\n\tif (skb_tail_pointer(skb) != skb_transport_header(skb))\n\t\tcnt++;\n\treturn flits + cxgbit_sgl_len(cnt);\n}\n\n#define CXGBIT_ISO_FSLICE 0x1\n#define CXGBIT_ISO_LSLICE 0x2\nstatic void\ncxgbit_cpl_tx_data_iso(struct sk_buff *skb, struct cxgbit_iso_info *iso_info)\n{\n\tstruct cpl_tx_data_iso *cpl;\n\tunsigned int submode = cxgbit_skcb_submode(skb);\n\tunsigned int fslice = !!(iso_info->flags & CXGBIT_ISO_FSLICE);\n\tunsigned int lslice = !!(iso_info->flags & CXGBIT_ISO_LSLICE);\n\n\tcpl = __skb_push(skb, sizeof(*cpl));\n\n\tcpl->op_to_scsi = htonl(CPL_TX_DATA_ISO_OP_V(CPL_TX_DATA_ISO) |\n\t\t\tCPL_TX_DATA_ISO_FIRST_V(fslice) |\n\t\t\tCPL_TX_DATA_ISO_LAST_V(lslice) |\n\t\t\tCPL_TX_DATA_ISO_CPLHDRLEN_V(0) |\n\t\t\tCPL_TX_DATA_ISO_HDRCRC_V(submode & 1) |\n\t\t\tCPL_TX_DATA_ISO_PLDCRC_V(((submode >> 1) & 1)) |\n\t\t\tCPL_TX_DATA_ISO_IMMEDIATE_V(0) |\n\t\t\tCPL_TX_DATA_ISO_SCSI_V(2));\n\n\tcpl->ahs_len = 0;\n\tcpl->mpdu = htons(DIV_ROUND_UP(iso_info->mpdu, 4));\n\tcpl->burst_size = htonl(DIV_ROUND_UP(iso_info->burst_len, 4));\n\tcpl->len = htonl(iso_info->len);\n\tcpl->reserved2_seglen_offset = htonl(0);\n\tcpl->datasn_offset = htonl(0);\n\tcpl->buffer_offset = htonl(0);\n\tcpl->reserved3 = 0;\n\n\t__skb_pull(skb, sizeof(*cpl));\n}\n\nstatic void\ncxgbit_tx_data_wr(struct cxgbit_sock *csk, struct sk_buff *skb, u32 dlen,\n\t\t  u32 len, u32 credits, u32 compl)\n{\n\tstruct fw_ofld_tx_data_wr *req;\n\tconst struct cxgb4_lld_info *lldi = &csk->com.cdev->lldi;\n\tu32 submode = cxgbit_skcb_submode(skb);\n\tu32 wr_ulp_mode = 0;\n\tu32 hdr_size = sizeof(*req);\n\tu32 opcode = FW_OFLD_TX_DATA_WR;\n\tu32 immlen = 0;\n\tu32 force = is_t5(lldi->adapter_type) ? TX_FORCE_V(!submode) :\n\t\t    T6_TX_FORCE_F;\n\n\tif (cxgbit_skcb_flags(skb) & SKCBF_TX_ISO) {\n\t\topcode = FW_ISCSI_TX_DATA_WR;\n\t\timmlen += sizeof(struct cpl_tx_data_iso);\n\t\thdr_size += sizeof(struct cpl_tx_data_iso);\n\t\tsubmode |= 8;\n\t}\n\n\tif (cxgbit_is_ofld_imm(skb))\n\t\timmlen += dlen;\n\n\treq = __skb_push(skb, hdr_size);\n\treq->op_to_immdlen = cpu_to_be32(FW_WR_OP_V(opcode) |\n\t\t\t\t\tFW_WR_COMPL_V(compl) |\n\t\t\t\t\tFW_WR_IMMDLEN_V(immlen));\n\treq->flowid_len16 = cpu_to_be32(FW_WR_FLOWID_V(csk->tid) |\n\t\t\t\t\tFW_WR_LEN16_V(credits));\n\treq->plen = htonl(len);\n\twr_ulp_mode = FW_OFLD_TX_DATA_WR_ULPMODE_V(ULP_MODE_ISCSI) |\n\t\t\t\tFW_OFLD_TX_DATA_WR_ULPSUBMODE_V(submode);\n\n\treq->tunnel_to_proxy = htonl(wr_ulp_mode | force |\n\t\t\t\t     FW_OFLD_TX_DATA_WR_SHOVE_F);\n}\n\nstatic void cxgbit_arp_failure_skb_discard(void *handle, struct sk_buff *skb)\n{\n\tkfree_skb(skb);\n}\n\nvoid cxgbit_push_tx_frames(struct cxgbit_sock *csk)\n{\n\tstruct sk_buff *skb;\n\n\twhile (csk->wr_cred && ((skb = skb_peek(&csk->txq)) != NULL)) {\n\t\tu32 dlen = skb->len;\n\t\tu32 len = skb->len;\n\t\tu32 credits_needed;\n\t\tu32 compl = 0;\n\t\tu32 flowclen16 = 0;\n\t\tu32 iso_cpl_len = 0;\n\n\t\tif (cxgbit_skcb_flags(skb) & SKCBF_TX_ISO)\n\t\t\tiso_cpl_len = sizeof(struct cpl_tx_data_iso);\n\n\t\tif (cxgbit_is_ofld_imm(skb))\n\t\t\tcredits_needed = DIV_ROUND_UP(dlen + iso_cpl_len, 16);\n\t\telse\n\t\t\tcredits_needed = DIV_ROUND_UP((8 *\n\t\t\t\t\tcxgbit_calc_tx_flits_ofld(skb)) +\n\t\t\t\t\tiso_cpl_len, 16);\n\n\t\tif (likely(cxgbit_skcb_flags(skb) & SKCBF_TX_NEED_HDR))\n\t\t\tcredits_needed += DIV_ROUND_UP(\n\t\t\t\tsizeof(struct fw_ofld_tx_data_wr), 16);\n\t\t \n\n\t\tif (!test_and_set_bit(CSK_TX_DATA_SENT, &csk->com.flags)) {\n\t\t\tflowclen16 = cxgbit_send_tx_flowc_wr(csk);\n\t\t\tcsk->wr_cred -= flowclen16;\n\t\t\tcsk->wr_una_cred += flowclen16;\n\t\t}\n\n\t\tif (csk->wr_cred < credits_needed) {\n\t\t\tpr_debug(\"csk 0x%p, skb %u/%u, wr %d < %u.\\n\",\n\t\t\t\t csk, skb->len, skb->data_len,\n\t\t\t\t credits_needed, csk->wr_cred);\n\t\t\tbreak;\n\t\t}\n\t\t__skb_unlink(skb, &csk->txq);\n\t\tset_wr_txq(skb, CPL_PRIORITY_DATA, csk->txq_idx);\n\t\tskb->csum = (__force __wsum)(credits_needed + flowclen16);\n\t\tcsk->wr_cred -= credits_needed;\n\t\tcsk->wr_una_cred += credits_needed;\n\n\t\tpr_debug(\"csk 0x%p, skb %u/%u, wr %d, left %u, unack %u.\\n\",\n\t\t\t csk, skb->len, skb->data_len, credits_needed,\n\t\t\t csk->wr_cred, csk->wr_una_cred);\n\n\t\tif (likely(cxgbit_skcb_flags(skb) & SKCBF_TX_NEED_HDR)) {\n\t\t\tlen += cxgbit_skcb_tx_extralen(skb);\n\n\t\t\tif ((csk->wr_una_cred >= (csk->wr_max_cred / 2)) ||\n\t\t\t    (!before(csk->write_seq,\n\t\t\t\t     csk->snd_una + csk->snd_win))) {\n\t\t\t\tcompl = 1;\n\t\t\t\tcsk->wr_una_cred = 0;\n\t\t\t}\n\n\t\t\tcxgbit_tx_data_wr(csk, skb, dlen, len, credits_needed,\n\t\t\t\t\t  compl);\n\t\t\tcsk->snd_nxt += len;\n\n\t\t} else if ((cxgbit_skcb_flags(skb) & SKCBF_TX_FLAG_COMPL) ||\n\t\t\t   (csk->wr_una_cred >= (csk->wr_max_cred / 2))) {\n\t\t\tstruct cpl_close_con_req *req =\n\t\t\t\t(struct cpl_close_con_req *)skb->data;\n\t\t\treq->wr.wr_hi |= htonl(FW_WR_COMPL_F);\n\t\t\tcsk->wr_una_cred = 0;\n\t\t}\n\n\t\tcxgbit_sock_enqueue_wr(csk, skb);\n\t\tt4_set_arp_err_handler(skb, csk,\n\t\t\t\t       cxgbit_arp_failure_skb_discard);\n\n\t\tpr_debug(\"csk 0x%p,%u, skb 0x%p, %u.\\n\",\n\t\t\t csk, csk->tid, skb, len);\n\n\t\tcxgbit_l2t_send(csk->com.cdev, skb, csk->l2t);\n\t}\n}\n\nstatic void cxgbit_unlock_sock(struct cxgbit_sock *csk)\n{\n\tstruct sk_buff_head backlogq;\n\tstruct sk_buff *skb;\n\tvoid (*fn)(struct cxgbit_sock *, struct sk_buff *);\n\n\tskb_queue_head_init(&backlogq);\n\n\tspin_lock_bh(&csk->lock);\n\twhile (skb_queue_len(&csk->backlogq)) {\n\t\tskb_queue_splice_init(&csk->backlogq, &backlogq);\n\t\tspin_unlock_bh(&csk->lock);\n\n\t\twhile ((skb = __skb_dequeue(&backlogq))) {\n\t\t\tfn = cxgbit_skcb_rx_backlog_fn(skb);\n\t\t\tfn(csk, skb);\n\t\t}\n\n\t\tspin_lock_bh(&csk->lock);\n\t}\n\n\tcsk->lock_owner = false;\n\tspin_unlock_bh(&csk->lock);\n}\n\nstatic int cxgbit_queue_skb(struct cxgbit_sock *csk, struct sk_buff *skb)\n{\n\tint ret = 0;\n\n\tspin_lock_bh(&csk->lock);\n\tcsk->lock_owner = true;\n\tspin_unlock_bh(&csk->lock);\n\n\tif (unlikely((csk->com.state != CSK_STATE_ESTABLISHED) ||\n\t\t     signal_pending(current))) {\n\t\t__kfree_skb(skb);\n\t\t__skb_queue_purge(&csk->ppodq);\n\t\tret = -1;\n\t\tgoto unlock;\n\t}\n\n\tcsk->write_seq += skb->len +\n\t\t\t  cxgbit_skcb_tx_extralen(skb);\n\n\tskb_queue_splice_tail_init(&csk->ppodq, &csk->txq);\n\t__skb_queue_tail(&csk->txq, skb);\n\tcxgbit_push_tx_frames(csk);\n\nunlock:\n\tcxgbit_unlock_sock(csk);\n\treturn ret;\n}\n\nstatic int\ncxgbit_map_skb(struct iscsit_cmd *cmd, struct sk_buff *skb, u32 data_offset,\n\t       u32 data_length)\n{\n\tu32 i = 0, nr_frags = MAX_SKB_FRAGS;\n\tu32 padding = ((-data_length) & 3);\n\tstruct scatterlist *sg;\n\tstruct page *page;\n\tunsigned int page_off;\n\n\tif (padding)\n\t\tnr_frags--;\n\n\t \n\tsg = &cmd->se_cmd.t_data_sg[data_offset / PAGE_SIZE];\n\tpage_off = (data_offset % PAGE_SIZE);\n\n\twhile (data_length && (i < nr_frags)) {\n\t\tu32 cur_len = min_t(u32, data_length, sg->length - page_off);\n\n\t\tpage = sg_page(sg);\n\n\t\tget_page(page);\n\t\tskb_fill_page_desc(skb, i, page, sg->offset + page_off,\n\t\t\t\t   cur_len);\n\t\tskb->data_len += cur_len;\n\t\tskb->len += cur_len;\n\t\tskb->truesize += cur_len;\n\n\t\tdata_length -= cur_len;\n\t\tpage_off = 0;\n\t\tsg = sg_next(sg);\n\t\ti++;\n\t}\n\n\tif (data_length)\n\t\treturn -1;\n\n\tif (padding) {\n\t\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn -1;\n\t\tskb_fill_page_desc(skb, i, page, 0, padding);\n\t\tskb->data_len += padding;\n\t\tskb->len += padding;\n\t\tskb->truesize += padding;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncxgbit_tx_datain_iso(struct cxgbit_sock *csk, struct iscsit_cmd *cmd,\n\t\t     struct iscsi_datain_req *dr)\n{\n\tstruct iscsit_conn *conn = csk->conn;\n\tstruct sk_buff *skb;\n\tstruct iscsi_datain datain;\n\tstruct cxgbit_iso_info iso_info;\n\tu32 data_length = cmd->se_cmd.data_length;\n\tu32 mrdsl = conn->conn_ops->MaxRecvDataSegmentLength;\n\tu32 num_pdu, plen, tx_data = 0;\n\tbool task_sense = !!(cmd->se_cmd.se_cmd_flags &\n\t\tSCF_TRANSPORT_TASK_SENSE);\n\tbool set_statsn = false;\n\tint ret = -1;\n\n\twhile (data_length) {\n\t\tnum_pdu = (data_length + mrdsl - 1) / mrdsl;\n\t\tif (num_pdu > csk->max_iso_npdu)\n\t\t\tnum_pdu = csk->max_iso_npdu;\n\n\t\tplen = num_pdu * mrdsl;\n\t\tif (plen > data_length)\n\t\t\tplen = data_length;\n\n\t\tskb = __cxgbit_alloc_skb(csk, 0, true);\n\t\tif (unlikely(!skb))\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(skb->data, 0, ISCSI_HDR_LEN);\n\t\tcxgbit_skcb_flags(skb) |= SKCBF_TX_ISO;\n\t\tcxgbit_skcb_submode(skb) |= (csk->submode &\n\t\t\t\tCXGBIT_SUBMODE_DCRC);\n\t\tcxgbit_skcb_tx_extralen(skb) = (num_pdu *\n\t\t\t\tcxgbit_digest_len[cxgbit_skcb_submode(skb)]) +\n\t\t\t\t\t\t((num_pdu - 1) * ISCSI_HDR_LEN);\n\n\t\tmemset(&datain, 0, sizeof(struct iscsi_datain));\n\t\tmemset(&iso_info, 0, sizeof(iso_info));\n\n\t\tif (!tx_data)\n\t\t\tiso_info.flags |= CXGBIT_ISO_FSLICE;\n\n\t\tif (!(data_length - plen)) {\n\t\t\tiso_info.flags |= CXGBIT_ISO_LSLICE;\n\t\t\tif (!task_sense) {\n\t\t\t\tdatain.flags = ISCSI_FLAG_DATA_STATUS;\n\t\t\t\tiscsit_increment_maxcmdsn(cmd, conn->sess);\n\t\t\t\tcmd->stat_sn = conn->stat_sn++;\n\t\t\t\tset_statsn = true;\n\t\t\t}\n\t\t}\n\n\t\tiso_info.burst_len = num_pdu * mrdsl;\n\t\tiso_info.mpdu = mrdsl;\n\t\tiso_info.len = ISCSI_HDR_LEN + plen;\n\n\t\tcxgbit_cpl_tx_data_iso(skb, &iso_info);\n\n\t\tdatain.offset = tx_data;\n\t\tdatain.data_sn = cmd->data_sn - 1;\n\n\t\tiscsit_build_datain_pdu(cmd, conn, &datain,\n\t\t\t\t\t(struct iscsi_data_rsp *)skb->data,\n\t\t\t\t\tset_statsn);\n\n\t\tret = cxgbit_map_skb(cmd, skb, tx_data, plen);\n\t\tif (unlikely(ret)) {\n\t\t\t__kfree_skb(skb);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = cxgbit_queue_skb(csk, skb);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\n\t\ttx_data += plen;\n\t\tdata_length -= plen;\n\n\t\tcmd->read_data_done += plen;\n\t\tcmd->data_sn += num_pdu;\n\t}\n\n\tdr->dr_complete = DATAIN_COMPLETE_NORMAL;\n\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic int\ncxgbit_tx_datain(struct cxgbit_sock *csk, struct iscsit_cmd *cmd,\n\t\t const struct iscsi_datain *datain)\n{\n\tstruct sk_buff *skb;\n\tint ret = 0;\n\n\tskb = cxgbit_alloc_skb(csk, 0);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tmemcpy(skb->data, cmd->pdu, ISCSI_HDR_LEN);\n\n\tif (datain->length) {\n\t\tcxgbit_skcb_submode(skb) |= (csk->submode &\n\t\t\t\tCXGBIT_SUBMODE_DCRC);\n\t\tcxgbit_skcb_tx_extralen(skb) =\n\t\t\t\tcxgbit_digest_len[cxgbit_skcb_submode(skb)];\n\t}\n\n\tret = cxgbit_map_skb(cmd, skb, datain->offset, datain->length);\n\tif (ret < 0) {\n\t\t__kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\treturn cxgbit_queue_skb(csk, skb);\n}\n\nstatic int\ncxgbit_xmit_datain_pdu(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t       struct iscsi_datain_req *dr,\n\t\t       const struct iscsi_datain *datain)\n{\n\tstruct cxgbit_sock *csk = conn->context;\n\tu32 data_length = cmd->se_cmd.data_length;\n\tu32 padding = ((-data_length) & 3);\n\tu32 mrdsl = conn->conn_ops->MaxRecvDataSegmentLength;\n\n\tif ((data_length > mrdsl) && (!dr->recovery) &&\n\t    (!padding) && (!datain->offset) && csk->max_iso_npdu) {\n\t\tatomic_long_add(data_length - datain->length,\n\t\t\t\t&conn->sess->tx_data_octets);\n\t\treturn cxgbit_tx_datain_iso(csk, cmd, dr);\n\t}\n\n\treturn cxgbit_tx_datain(csk, cmd, datain);\n}\n\nstatic int\ncxgbit_xmit_nondatain_pdu(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t\t  const void *data_buf, u32 data_buf_len)\n{\n\tstruct cxgbit_sock *csk = conn->context;\n\tstruct sk_buff *skb;\n\tu32 padding = ((-data_buf_len) & 3);\n\n\tskb = cxgbit_alloc_skb(csk, data_buf_len + padding);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tmemcpy(skb->data, cmd->pdu, ISCSI_HDR_LEN);\n\n\tif (data_buf_len) {\n\t\tu32 pad_bytes = 0;\n\n\t\tskb_store_bits(skb, ISCSI_HDR_LEN, data_buf, data_buf_len);\n\n\t\tif (padding)\n\t\t\tskb_store_bits(skb, ISCSI_HDR_LEN + data_buf_len,\n\t\t\t\t       &pad_bytes, padding);\n\t}\n\n\tcxgbit_skcb_tx_extralen(skb) = cxgbit_digest_len[\n\t\t\t\t       cxgbit_skcb_submode(skb)];\n\n\treturn cxgbit_queue_skb(csk, skb);\n}\n\nint\ncxgbit_xmit_pdu(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\tstruct iscsi_datain_req *dr, const void *buf, u32 buf_len)\n{\n\tif (dr)\n\t\treturn cxgbit_xmit_datain_pdu(conn, cmd, dr, buf);\n\telse\n\t\treturn cxgbit_xmit_nondatain_pdu(conn, cmd, buf, buf_len);\n}\n\nint cxgbit_validate_params(struct iscsit_conn *conn)\n{\n\tstruct cxgbit_sock *csk = conn->context;\n\tstruct cxgbit_device *cdev = csk->com.cdev;\n\tstruct iscsi_param *param;\n\tu32 max_xmitdsl;\n\n\tparam = iscsi_find_param_from_key(MAXXMITDATASEGMENTLENGTH,\n\t\t\t\t\t  conn->param_list);\n\tif (!param)\n\t\treturn -1;\n\n\tif (kstrtou32(param->value, 0, &max_xmitdsl) < 0)\n\t\treturn -1;\n\n\tif (max_xmitdsl > cdev->mdsl) {\n\t\tif (iscsi_change_param_sprintf(\n\t\t\tconn, \"MaxXmitDataSegmentLength=%u\", cdev->mdsl))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxgbit_set_digest(struct cxgbit_sock *csk)\n{\n\tstruct iscsit_conn *conn = csk->conn;\n\tstruct iscsi_param *param;\n\n\tparam = iscsi_find_param_from_key(HEADERDIGEST, conn->param_list);\n\tif (!param) {\n\t\tpr_err(\"param not found key %s\\n\", HEADERDIGEST);\n\t\treturn -1;\n\t}\n\n\tif (!strcmp(param->value, CRC32C))\n\t\tcsk->submode |= CXGBIT_SUBMODE_HCRC;\n\n\tparam = iscsi_find_param_from_key(DATADIGEST, conn->param_list);\n\tif (!param) {\n\t\tcsk->submode = 0;\n\t\tpr_err(\"param not found key %s\\n\", DATADIGEST);\n\t\treturn -1;\n\t}\n\n\tif (!strcmp(param->value, CRC32C))\n\t\tcsk->submode |= CXGBIT_SUBMODE_DCRC;\n\n\tif (cxgbit_setup_conn_digest(csk)) {\n\t\tcsk->submode = 0;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxgbit_set_iso_npdu(struct cxgbit_sock *csk)\n{\n\tstruct iscsit_conn *conn = csk->conn;\n\tstruct iscsi_conn_ops *conn_ops = conn->conn_ops;\n\tstruct iscsi_param *param;\n\tu32 mrdsl, mbl;\n\tu32 max_npdu, max_iso_npdu;\n\tu32 max_iso_payload;\n\n\tif (conn->login->leading_connection) {\n\t\tparam = iscsi_find_param_from_key(MAXBURSTLENGTH,\n\t\t\t\t\t\t  conn->param_list);\n\t\tif (!param) {\n\t\t\tpr_err(\"param not found key %s\\n\", MAXBURSTLENGTH);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (kstrtou32(param->value, 0, &mbl) < 0)\n\t\t\treturn -1;\n\t} else {\n\t\tmbl = conn->sess->sess_ops->MaxBurstLength;\n\t}\n\n\tmrdsl = conn_ops->MaxRecvDataSegmentLength;\n\tmax_npdu = mbl / mrdsl;\n\n\tmax_iso_payload = rounddown(CXGBIT_MAX_ISO_PAYLOAD, csk->emss);\n\n\tmax_iso_npdu = max_iso_payload /\n\t\t       (ISCSI_HDR_LEN + mrdsl +\n\t\t\tcxgbit_digest_len[csk->submode]);\n\n\tcsk->max_iso_npdu = min(max_npdu, max_iso_npdu);\n\n\tif (csk->max_iso_npdu <= 1)\n\t\tcsk->max_iso_npdu = 0;\n\n\treturn 0;\n}\n\n \nstatic int cxgbit_seq_pdu_inorder(struct cxgbit_sock *csk)\n{\n\tstruct iscsit_conn *conn = csk->conn;\n\tstruct iscsi_param *param;\n\n\tif (conn->login->leading_connection) {\n\t\tparam = iscsi_find_param_from_key(DATASEQUENCEINORDER,\n\t\t\t\t\t\t  conn->param_list);\n\t\tif (!param) {\n\t\t\tpr_err(\"param not found key %s\\n\", DATASEQUENCEINORDER);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (strcmp(param->value, YES))\n\t\t\treturn 1;\n\n\t\tparam = iscsi_find_param_from_key(DATAPDUINORDER,\n\t\t\t\t\t\t  conn->param_list);\n\t\tif (!param) {\n\t\t\tpr_err(\"param not found key %s\\n\", DATAPDUINORDER);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (strcmp(param->value, YES))\n\t\t\treturn 1;\n\n\t} else {\n\t\tif (!conn->sess->sess_ops->DataSequenceInOrder)\n\t\t\treturn 1;\n\t\tif (!conn->sess->sess_ops->DataPDUInOrder)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxgbit_set_params(struct iscsit_conn *conn)\n{\n\tstruct cxgbit_sock *csk = conn->context;\n\tstruct cxgbit_device *cdev = csk->com.cdev;\n\tstruct cxgbi_ppm *ppm = *csk->com.cdev->lldi.iscsi_ppm;\n\tstruct iscsi_conn_ops *conn_ops = conn->conn_ops;\n\tstruct iscsi_param *param;\n\tu8 erl;\n\n\tif (conn_ops->MaxRecvDataSegmentLength > cdev->mdsl)\n\t\tconn_ops->MaxRecvDataSegmentLength = cdev->mdsl;\n\n\tif (cxgbit_set_digest(csk))\n\t\treturn -1;\n\n\tif (conn->login->leading_connection) {\n\t\tparam = iscsi_find_param_from_key(ERRORRECOVERYLEVEL,\n\t\t\t\t\t\t  conn->param_list);\n\t\tif (!param) {\n\t\t\tpr_err(\"param not found key %s\\n\", ERRORRECOVERYLEVEL);\n\t\t\treturn -1;\n\t\t}\n\t\tif (kstrtou8(param->value, 0, &erl) < 0)\n\t\t\treturn -1;\n\t} else {\n\t\terl = conn->sess->sess_ops->ErrorRecoveryLevel;\n\t}\n\n\tif (!erl) {\n\t\tint ret;\n\n\t\tret = cxgbit_seq_pdu_inorder(csk);\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t} else if (ret > 0) {\n\t\t\tif (is_t5(cdev->lldi.adapter_type))\n\t\t\t\tgoto enable_ddp;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tif (test_bit(CDEV_ISO_ENABLE, &cdev->flags)) {\n\t\t\tif (cxgbit_set_iso_npdu(csk))\n\t\t\t\treturn -1;\n\t\t}\n\nenable_ddp:\n\t\tif (test_bit(CDEV_DDP_ENABLE, &cdev->flags)) {\n\t\t\tif (cxgbit_setup_conn_pgidx(csk,\n\t\t\t\t\t\t    ppm->tformat.pgsz_idx_dflt))\n\t\t\t\treturn -1;\n\t\t\tset_bit(CSK_DDP_ENABLE, &csk->com.flags);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint\ncxgbit_put_login_tx(struct iscsit_conn *conn, struct iscsi_login *login,\n\t\t    u32 length)\n{\n\tstruct cxgbit_sock *csk = conn->context;\n\tstruct sk_buff *skb;\n\tu32 padding_buf = 0;\n\tu8 padding = ((-length) & 3);\n\n\tskb = cxgbit_alloc_skb(csk, length + padding);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_store_bits(skb, 0, login->rsp, ISCSI_HDR_LEN);\n\tskb_store_bits(skb, ISCSI_HDR_LEN, login->rsp_buf, length);\n\n\tif (padding)\n\t\tskb_store_bits(skb, ISCSI_HDR_LEN + length,\n\t\t\t       &padding_buf, padding);\n\n\tif (login->login_complete) {\n\t\tif (cxgbit_set_params(conn)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\n\t\tset_bit(CSK_LOGIN_DONE, &csk->com.flags);\n\t}\n\n\tif (cxgbit_queue_skb(csk, skb))\n\t\treturn -1;\n\n\tif ((!login->login_complete) && (!login->login_failed))\n\t\tschedule_delayed_work(&conn->login_work, 0);\n\n\treturn 0;\n}\n\nstatic void\ncxgbit_skb_copy_to_sg(struct sk_buff *skb, struct scatterlist *sg,\n\t\t      unsigned int nents, u32 skip)\n{\n\tstruct skb_seq_state st;\n\tconst u8 *buf;\n\tunsigned int consumed = 0, buf_len;\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_rx_pdu_cb(skb);\n\n\tskb_prepare_seq_read(skb, pdu_cb->doffset,\n\t\t\t     pdu_cb->doffset + pdu_cb->dlen,\n\t\t\t     &st);\n\n\twhile (true) {\n\t\tbuf_len = skb_seq_read(consumed, &buf, &st);\n\t\tif (!buf_len) {\n\t\t\tskb_abort_seq_read(&st);\n\t\t\tbreak;\n\t\t}\n\n\t\tconsumed += sg_pcopy_from_buffer(sg, nents, (void *)buf,\n\t\t\t\t\t\t buf_len, skip + consumed);\n\t}\n}\n\nstatic struct iscsit_cmd *cxgbit_allocate_cmd(struct cxgbit_sock *csk)\n{\n\tstruct iscsit_conn *conn = csk->conn;\n\tstruct cxgbi_ppm *ppm = cdev2ppm(csk->com.cdev);\n\tstruct cxgbit_cmd *ccmd;\n\tstruct iscsit_cmd *cmd;\n\n\tcmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\n\tif (!cmd) {\n\t\tpr_err(\"Unable to allocate iscsit_cmd + cxgbit_cmd\\n\");\n\t\treturn NULL;\n\t}\n\n\tccmd = iscsit_priv_cmd(cmd);\n\tccmd->ttinfo.tag = ppm->tformat.no_ddp_mask;\n\tccmd->setup_ddp = true;\n\n\treturn cmd;\n}\n\nstatic int\ncxgbit_handle_immediate_data(struct iscsit_cmd *cmd, struct iscsi_scsi_req *hdr,\n\t\t\t     u32 length)\n{\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct cxgbit_sock *csk = conn->context;\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_rx_pdu_cb(csk->skb);\n\n\tif (pdu_cb->flags & PDUCBF_RX_DCRC_ERR) {\n\t\tpr_err(\"ImmediateData CRC32C DataDigest error\\n\");\n\t\tif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\n\t\t\tpr_err(\"Unable to recover from\"\n\t\t\t       \" Immediate Data digest failure while\"\n\t\t\t       \" in ERL=0.\\n\");\n\t\t\tiscsit_reject_cmd(cmd, ISCSI_REASON_DATA_DIGEST_ERROR,\n\t\t\t\t\t  (unsigned char *)hdr);\n\t\t\treturn IMMEDIATE_DATA_CANNOT_RECOVER;\n\t\t}\n\n\t\tiscsit_reject_cmd(cmd, ISCSI_REASON_DATA_DIGEST_ERROR,\n\t\t\t\t  (unsigned char *)hdr);\n\t\treturn IMMEDIATE_DATA_ERL1_CRC_FAILURE;\n\t}\n\n\tif (cmd->se_cmd.se_cmd_flags & SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) {\n\t\tstruct cxgbit_cmd *ccmd = iscsit_priv_cmd(cmd);\n\t\tstruct skb_shared_info *ssi = skb_shinfo(csk->skb);\n\t\tskb_frag_t *dfrag = &ssi->frags[pdu_cb->dfrag_idx];\n\n\t\tsg_init_table(&ccmd->sg, 1);\n\t\tsg_set_page(&ccmd->sg, skb_frag_page(dfrag),\n\t\t\t\tskb_frag_size(dfrag), skb_frag_off(dfrag));\n\t\tget_page(skb_frag_page(dfrag));\n\n\t\tcmd->se_cmd.t_data_sg = &ccmd->sg;\n\t\tcmd->se_cmd.t_data_nents = 1;\n\n\t\tccmd->release = true;\n\t} else {\n\t\tstruct scatterlist *sg = &cmd->se_cmd.t_data_sg[0];\n\t\tu32 sg_nents = max(1UL, DIV_ROUND_UP(pdu_cb->dlen, PAGE_SIZE));\n\n\t\tcxgbit_skb_copy_to_sg(csk->skb, sg, sg_nents, 0);\n\t}\n\n\tcmd->write_data_done += pdu_cb->dlen;\n\n\tif (cmd->write_data_done == cmd->se_cmd.data_length) {\n\t\tspin_lock_bh(&cmd->istate_lock);\n\t\tcmd->cmd_flags |= ICF_GOT_LAST_DATAOUT;\n\t\tcmd->i_state = ISTATE_RECEIVED_LAST_DATAOUT;\n\t\tspin_unlock_bh(&cmd->istate_lock);\n\t}\n\n\treturn IMMEDIATE_DATA_NORMAL_OPERATION;\n}\n\nstatic int\ncxgbit_get_immediate_data(struct iscsit_cmd *cmd, struct iscsi_scsi_req *hdr,\n\t\t\t  bool dump_payload)\n{\n\tstruct iscsit_conn *conn = cmd->conn;\n\tint cmdsn_ret = 0, immed_ret = IMMEDIATE_DATA_NORMAL_OPERATION;\n\t \n\tif (dump_payload)\n\t\tgoto after_immediate_data;\n\n\timmed_ret = cxgbit_handle_immediate_data(cmd, hdr,\n\t\t\t\t\t\t cmd->first_burst_len);\nafter_immediate_data:\n\tif (immed_ret == IMMEDIATE_DATA_NORMAL_OPERATION) {\n\t\t \n\t\tcmdsn_ret = iscsit_sequence_cmd(conn, cmd,\n\t\t\t\t\t\t(unsigned char *)hdr,\n\t\t\t\t\t\thdr->cmdsn);\n\t\tif (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)\n\t\t\treturn -1;\n\n\t\tif (cmd->sense_reason || cmdsn_ret == CMDSN_LOWER_THAN_EXP) {\n\t\t\ttarget_put_sess_cmd(&cmd->se_cmd);\n\t\t\treturn 0;\n\t\t} else if (cmd->unsolicited_data) {\n\t\t\tiscsit_set_unsolicited_dataout(cmd);\n\t\t}\n\n\t} else if (immed_ret == IMMEDIATE_DATA_ERL1_CRC_FAILURE) {\n\t\t \n\t\tcmd->i_state = ISTATE_REMOVE;\n\t\tiscsit_add_cmd_to_immediate_queue(cmd, conn, cmd->i_state);\n\t} else  \n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int\ncxgbit_handle_scsi_cmd(struct cxgbit_sock *csk, struct iscsit_cmd *cmd)\n{\n\tstruct iscsit_conn *conn = csk->conn;\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_rx_pdu_cb(csk->skb);\n\tstruct iscsi_scsi_req *hdr = (struct iscsi_scsi_req *)pdu_cb->hdr;\n\tint rc;\n\tbool dump_payload = false;\n\n\trc = iscsit_setup_scsi_cmd(conn, cmd, (unsigned char *)hdr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (pdu_cb->dlen && (pdu_cb->dlen == cmd->se_cmd.data_length) &&\n\t    (pdu_cb->nr_dfrags == 1))\n\t\tcmd->se_cmd.se_cmd_flags |= SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\n\n\trc = iscsit_process_scsi_cmd(conn, cmd, hdr);\n\tif (rc < 0)\n\t\treturn 0;\n\telse if (rc > 0)\n\t\tdump_payload = true;\n\n\tif (!pdu_cb->dlen)\n\t\treturn 0;\n\n\treturn cxgbit_get_immediate_data(cmd, hdr, dump_payload);\n}\n\nstatic int cxgbit_handle_iscsi_dataout(struct cxgbit_sock *csk)\n{\n\tstruct scatterlist *sg_start;\n\tstruct iscsit_conn *conn = csk->conn;\n\tstruct iscsit_cmd *cmd = NULL;\n\tstruct cxgbit_cmd *ccmd;\n\tstruct cxgbi_task_tag_info *ttinfo;\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_rx_pdu_cb(csk->skb);\n\tstruct iscsi_data *hdr = (struct iscsi_data *)pdu_cb->hdr;\n\tu32 data_offset = be32_to_cpu(hdr->offset);\n\tu32 data_len = ntoh24(hdr->dlength);\n\tint rc, sg_nents, sg_off;\n\tbool dcrc_err = false;\n\n\tif (pdu_cb->flags & PDUCBF_RX_DDP_CMP) {\n\t\tu32 offset = be32_to_cpu(hdr->offset);\n\t\tu32 ddp_data_len;\n\t\tbool success = false;\n\n\t\tcmd = iscsit_find_cmd_from_itt_or_dump(conn, hdr->itt, 0);\n\t\tif (!cmd)\n\t\t\treturn 0;\n\n\t\tddp_data_len = offset - cmd->write_data_done;\n\t\tatomic_long_add(ddp_data_len, &conn->sess->rx_data_octets);\n\n\t\tcmd->write_data_done = offset;\n\t\tcmd->next_burst_len = ddp_data_len;\n\t\tcmd->data_sn = be32_to_cpu(hdr->datasn);\n\n\t\trc = __iscsit_check_dataout_hdr(conn, (unsigned char *)hdr,\n\t\t\t\t\t\tcmd, data_len, &success);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\telse if (!success)\n\t\t\treturn 0;\n\t} else {\n\t\trc = iscsit_check_dataout_hdr(conn, (unsigned char *)hdr, &cmd);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\telse if (!cmd)\n\t\t\treturn 0;\n\t}\n\n\tif (pdu_cb->flags & PDUCBF_RX_DCRC_ERR) {\n\t\tpr_err(\"ITT: 0x%08x, Offset: %u, Length: %u,\"\n\t\t       \" DataSN: 0x%08x\\n\",\n\t\t       hdr->itt, hdr->offset, data_len,\n\t\t       hdr->datasn);\n\n\t\tdcrc_err = true;\n\t\tgoto check_payload;\n\t}\n\n\tpr_debug(\"DataOut data_len: %u, \"\n\t\t\"write_data_done: %u, data_length: %u\\n\",\n\t\t  data_len,  cmd->write_data_done,\n\t\t  cmd->se_cmd.data_length);\n\n\tif (!(pdu_cb->flags & PDUCBF_RX_DATA_DDPD)) {\n\t\tu32 skip = data_offset % PAGE_SIZE;\n\n\t\tsg_off = data_offset / PAGE_SIZE;\n\t\tsg_start = &cmd->se_cmd.t_data_sg[sg_off];\n\t\tsg_nents = max(1UL, DIV_ROUND_UP(skip + data_len, PAGE_SIZE));\n\n\t\tcxgbit_skb_copy_to_sg(csk->skb, sg_start, sg_nents, skip);\n\t}\n\n\tccmd = iscsit_priv_cmd(cmd);\n\tttinfo = &ccmd->ttinfo;\n\n\tif (ccmd->release && ttinfo->sgl &&\n\t    (cmd->se_cmd.data_length ==\t(cmd->write_data_done + data_len))) {\n\t\tstruct cxgbit_device *cdev = csk->com.cdev;\n\t\tstruct cxgbi_ppm *ppm = cdev2ppm(cdev);\n\n\t\tdma_unmap_sg(&ppm->pdev->dev, ttinfo->sgl, ttinfo->nents,\n\t\t\t     DMA_FROM_DEVICE);\n\t\tttinfo->nents = 0;\n\t\tttinfo->sgl = NULL;\n\t}\n\ncheck_payload:\n\n\trc = iscsit_check_dataout_payload(cmd, hdr, dcrc_err);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int cxgbit_handle_nop_out(struct cxgbit_sock *csk, struct iscsit_cmd *cmd)\n{\n\tstruct iscsit_conn *conn = csk->conn;\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_rx_pdu_cb(csk->skb);\n\tstruct iscsi_nopout *hdr = (struct iscsi_nopout *)pdu_cb->hdr;\n\tunsigned char *ping_data = NULL;\n\tu32 payload_length = pdu_cb->dlen;\n\tint ret;\n\n\tret = iscsit_setup_nop_out(conn, cmd, hdr);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (pdu_cb->flags & PDUCBF_RX_DCRC_ERR) {\n\t\tif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\n\t\t\tpr_err(\"Unable to recover from\"\n\t\t\t       \" NOPOUT Ping DataCRC failure while in\"\n\t\t\t       \" ERL=0.\\n\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\t \n\t\t\tpr_info(\"Dropping NOPOUT\"\n\t\t\t\t\" Command CmdSN: 0x%08x due to\"\n\t\t\t\t\" DataCRC error.\\n\", hdr->cmdsn);\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (payload_length && hdr->ttt == cpu_to_be32(0xFFFFFFFF)) {\n\t\tping_data = kzalloc(payload_length + 1, GFP_KERNEL);\n\t\tif (!ping_data) {\n\t\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\t\" NOPOUT ping data.\\n\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tskb_copy_bits(csk->skb, pdu_cb->doffset,\n\t\t\t      ping_data, payload_length);\n\n\t\tping_data[payload_length] = '\\0';\n\t\t \n\t\tcmd->buf_ptr = ping_data;\n\t\tcmd->buf_ptr_size = payload_length;\n\n\t\tpr_debug(\"Got %u bytes of NOPOUT ping\"\n\t\t\t\" data.\\n\", payload_length);\n\t\tpr_debug(\"Ping Data: \\\"%s\\\"\\n\", ping_data);\n\t}\n\n\treturn iscsit_process_nop_out(conn, cmd, hdr);\nout:\n\tif (cmd)\n\t\tiscsit_free_cmd(cmd, false);\n\treturn ret;\n}\n\nstatic int\ncxgbit_handle_text_cmd(struct cxgbit_sock *csk, struct iscsit_cmd *cmd)\n{\n\tstruct iscsit_conn *conn = csk->conn;\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_rx_pdu_cb(csk->skb);\n\tstruct iscsi_text *hdr = (struct iscsi_text *)pdu_cb->hdr;\n\tu32 payload_length = pdu_cb->dlen;\n\tint rc;\n\tunsigned char *text_in = NULL;\n\n\trc = iscsit_setup_text_cmd(conn, cmd, hdr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (pdu_cb->flags & PDUCBF_RX_DCRC_ERR) {\n\t\tif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\n\t\t\tpr_err(\"Unable to recover from\"\n\t\t\t       \" Text Data digest failure while in\"\n\t\t\t       \" ERL=0.\\n\");\n\t\t\tgoto reject;\n\t\t} else {\n\t\t\t \n\t\t\tpr_info(\"Dropping Text\"\n\t\t\t\t\" Command CmdSN: 0x%08x due to\"\n\t\t\t\t\" DataCRC error.\\n\", hdr->cmdsn);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (payload_length) {\n\t\ttext_in = kzalloc(payload_length, GFP_KERNEL);\n\t\tif (!text_in) {\n\t\t\tpr_err(\"Unable to allocate text_in of payload_length: %u\\n\",\n\t\t\t       payload_length);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_copy_bits(csk->skb, pdu_cb->doffset,\n\t\t\t      text_in, payload_length);\n\n\t\ttext_in[payload_length - 1] = '\\0';\n\n\t\tcmd->text_in_ptr = text_in;\n\t}\n\n\treturn iscsit_process_text_cmd(conn, cmd, hdr);\n\nreject:\n\treturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t pdu_cb->hdr);\n}\n\nstatic int cxgbit_target_rx_opcode(struct cxgbit_sock *csk)\n{\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_rx_pdu_cb(csk->skb);\n\tstruct iscsi_hdr *hdr = (struct iscsi_hdr *)pdu_cb->hdr;\n\tstruct iscsit_conn *conn = csk->conn;\n\tstruct iscsit_cmd *cmd = NULL;\n\tu8 opcode = (hdr->opcode & ISCSI_OPCODE_MASK);\n\tint ret = -EINVAL;\n\n\tswitch (opcode) {\n\tcase ISCSI_OP_SCSI_CMD:\n\t\tcmd = cxgbit_allocate_cmd(csk);\n\t\tif (!cmd)\n\t\t\tgoto reject;\n\n\t\tret = cxgbit_handle_scsi_cmd(csk, cmd);\n\t\tbreak;\n\tcase ISCSI_OP_SCSI_DATA_OUT:\n\t\tret = cxgbit_handle_iscsi_dataout(csk);\n\t\tbreak;\n\tcase ISCSI_OP_NOOP_OUT:\n\t\tif (hdr->ttt == cpu_to_be32(0xFFFFFFFF)) {\n\t\t\tcmd = cxgbit_allocate_cmd(csk);\n\t\t\tif (!cmd)\n\t\t\t\tgoto reject;\n\t\t}\n\n\t\tret = cxgbit_handle_nop_out(csk, cmd);\n\t\tbreak;\n\tcase ISCSI_OP_SCSI_TMFUNC:\n\t\tcmd = cxgbit_allocate_cmd(csk);\n\t\tif (!cmd)\n\t\t\tgoto reject;\n\n\t\tret = iscsit_handle_task_mgt_cmd(conn, cmd,\n\t\t\t\t\t\t (unsigned char *)hdr);\n\t\tbreak;\n\tcase ISCSI_OP_TEXT:\n\t\tif (hdr->ttt != cpu_to_be32(0xFFFFFFFF)) {\n\t\t\tcmd = iscsit_find_cmd_from_itt(conn, hdr->itt);\n\t\t\tif (!cmd)\n\t\t\t\tgoto reject;\n\t\t} else {\n\t\t\tcmd = cxgbit_allocate_cmd(csk);\n\t\t\tif (!cmd)\n\t\t\t\tgoto reject;\n\t\t}\n\n\t\tret = cxgbit_handle_text_cmd(csk, cmd);\n\t\tbreak;\n\tcase ISCSI_OP_LOGOUT:\n\t\tcmd = cxgbit_allocate_cmd(csk);\n\t\tif (!cmd)\n\t\t\tgoto reject;\n\n\t\tret = iscsit_handle_logout_cmd(conn, cmd, (unsigned char *)hdr);\n\t\tif (ret > 0)\n\t\t\twait_for_completion_timeout(&conn->conn_logout_comp,\n\t\t\t\t\t\t    SECONDS_FOR_LOGOUT_COMP\n\t\t\t\t\t\t    * HZ);\n\t\tbreak;\n\tcase ISCSI_OP_SNACK:\n\t\tret = iscsit_handle_snack(conn, (unsigned char *)hdr);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Got unknown iSCSI OpCode: 0x%02x\\n\", opcode);\n\t\tdump_stack();\n\t\tbreak;\n\t}\n\n\treturn ret;\n\nreject:\n\treturn iscsit_add_reject(conn, ISCSI_REASON_BOOKMARK_NO_RESOURCES,\n\t\t\t\t (unsigned char *)hdr);\n\treturn ret;\n}\n\nstatic int cxgbit_rx_opcode(struct cxgbit_sock *csk)\n{\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_rx_pdu_cb(csk->skb);\n\tstruct iscsit_conn *conn = csk->conn;\n\tstruct iscsi_hdr *hdr = pdu_cb->hdr;\n\tu8 opcode;\n\n\tif (pdu_cb->flags & PDUCBF_RX_HCRC_ERR) {\n\t\tatomic_long_inc(&conn->sess->conn_digest_errors);\n\t\tgoto transport_err;\n\t}\n\n\tif (conn->conn_state == TARG_CONN_STATE_IN_LOGOUT)\n\t\tgoto transport_err;\n\n\topcode = hdr->opcode & ISCSI_OPCODE_MASK;\n\n\tif (conn->sess->sess_ops->SessionType &&\n\t    ((!(opcode & ISCSI_OP_TEXT)) ||\n\t     (!(opcode & ISCSI_OP_LOGOUT)))) {\n\t\tpr_err(\"Received illegal iSCSI Opcode: 0x%02x\"\n\t\t\t\" while in Discovery Session, rejecting.\\n\", opcode);\n\t\tiscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t  (unsigned char *)hdr);\n\t\tgoto transport_err;\n\t}\n\n\tif (cxgbit_target_rx_opcode(csk) < 0)\n\t\tgoto transport_err;\n\n\treturn 0;\n\ntransport_err:\n\treturn -1;\n}\n\nstatic int cxgbit_rx_login_pdu(struct cxgbit_sock *csk)\n{\n\tstruct iscsit_conn *conn = csk->conn;\n\tstruct iscsi_login *login = conn->login;\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_rx_pdu_cb(csk->skb);\n\tstruct iscsi_login_req *login_req;\n\n\tlogin_req = (struct iscsi_login_req *)login->req;\n\tmemcpy(login_req, pdu_cb->hdr, sizeof(*login_req));\n\n\tpr_debug(\"Got Login Command, Flags 0x%02x, ITT: 0x%08x,\"\n\t\t\" CmdSN: 0x%08x, ExpStatSN: 0x%08x, CID: %hu, Length: %u\\n\",\n\t\tlogin_req->flags, login_req->itt, login_req->cmdsn,\n\t\tlogin_req->exp_statsn, login_req->cid, pdu_cb->dlen);\n\t \n\tif (login->first_request) {\n\t\tlogin_req = (struct iscsi_login_req *)login->req;\n\t\tlogin->leading_connection = (!login_req->tsih) ? 1 : 0;\n\t\tlogin->current_stage\t= ISCSI_LOGIN_CURRENT_STAGE(\n\t\t\t\tlogin_req->flags);\n\t\tlogin->version_min\t= login_req->min_version;\n\t\tlogin->version_max\t= login_req->max_version;\n\t\tmemcpy(login->isid, login_req->isid, 6);\n\t\tlogin->cmd_sn\t\t= be32_to_cpu(login_req->cmdsn);\n\t\tlogin->init_task_tag\t= login_req->itt;\n\t\tlogin->initial_exp_statsn = be32_to_cpu(login_req->exp_statsn);\n\t\tlogin->cid\t\t= be16_to_cpu(login_req->cid);\n\t\tlogin->tsih\t\t= be16_to_cpu(login_req->tsih);\n\t}\n\n\tif (iscsi_target_check_login_request(conn, login) < 0)\n\t\treturn -1;\n\n\tmemset(login->req_buf, 0, MAX_KEY_VALUE_PAIRS);\n\tskb_copy_bits(csk->skb, pdu_cb->doffset, login->req_buf, pdu_cb->dlen);\n\n\treturn 0;\n}\n\nstatic int\ncxgbit_process_iscsi_pdu(struct cxgbit_sock *csk, struct sk_buff *skb, int idx)\n{\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_skb_lro_pdu_cb(skb, idx);\n\tint ret;\n\n\tcxgbit_rx_pdu_cb(skb) = pdu_cb;\n\n\tcsk->skb = skb;\n\n\tif (!test_bit(CSK_LOGIN_DONE, &csk->com.flags)) {\n\t\tret = cxgbit_rx_login_pdu(csk);\n\t\tset_bit(CSK_LOGIN_PDU_DONE, &csk->com.flags);\n\t} else {\n\t\tret = cxgbit_rx_opcode(csk);\n\t}\n\n\treturn ret;\n}\n\nstatic void cxgbit_lro_skb_dump(struct sk_buff *skb)\n{\n\tstruct skb_shared_info *ssi = skb_shinfo(skb);\n\tstruct cxgbit_lro_cb *lro_cb = cxgbit_skb_lro_cb(skb);\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_skb_lro_pdu_cb(skb, 0);\n\tu8 i;\n\n\tpr_info(\"skb 0x%p, head 0x%p, 0x%p, len %u,%u, frags %u.\\n\",\n\t\tskb, skb->head, skb->data, skb->len, skb->data_len,\n\t\tssi->nr_frags);\n\tpr_info(\"skb 0x%p, lro_cb, csk 0x%p, pdu %u, %u.\\n\",\n\t\tskb, lro_cb->csk, lro_cb->pdu_idx, lro_cb->pdu_totallen);\n\n\tfor (i = 0; i < lro_cb->pdu_idx; i++, pdu_cb++)\n\t\tpr_info(\"skb 0x%p, pdu %d, %u, f 0x%x, seq 0x%x, dcrc 0x%x, \"\n\t\t\t\"frags %u.\\n\",\n\t\t\tskb, i, pdu_cb->pdulen, pdu_cb->flags, pdu_cb->seq,\n\t\t\tpdu_cb->ddigest, pdu_cb->frags);\n\tfor (i = 0; i < ssi->nr_frags; i++)\n\t\tpr_info(\"skb 0x%p, frag %d, off %u, sz %u.\\n\",\n\t\t\tskb, i, skb_frag_off(&ssi->frags[i]),\n\t\t\tskb_frag_size(&ssi->frags[i]));\n}\n\nstatic void cxgbit_lro_hskb_reset(struct cxgbit_sock *csk)\n{\n\tstruct sk_buff *skb = csk->lro_hskb;\n\tstruct skb_shared_info *ssi = skb_shinfo(skb);\n\tu8 i;\n\n\tmemset(skb->data, 0, LRO_SKB_MIN_HEADROOM);\n\tfor (i = 0; i < ssi->nr_frags; i++)\n\t\tput_page(skb_frag_page(&ssi->frags[i]));\n\tssi->nr_frags = 0;\n\tskb->data_len = 0;\n\tskb->truesize -= skb->len;\n\tskb->len = 0;\n}\n\nstatic void\ncxgbit_lro_skb_merge(struct cxgbit_sock *csk, struct sk_buff *skb, u8 pdu_idx)\n{\n\tstruct sk_buff *hskb = csk->lro_hskb;\n\tstruct cxgbit_lro_pdu_cb *hpdu_cb = cxgbit_skb_lro_pdu_cb(hskb, 0);\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_skb_lro_pdu_cb(skb, pdu_idx);\n\tstruct skb_shared_info *hssi = skb_shinfo(hskb);\n\tstruct skb_shared_info *ssi = skb_shinfo(skb);\n\tunsigned int len = 0;\n\n\tif (pdu_cb->flags & PDUCBF_RX_HDR) {\n\t\tu8 hfrag_idx = hssi->nr_frags;\n\n\t\thpdu_cb->flags |= pdu_cb->flags;\n\t\thpdu_cb->seq = pdu_cb->seq;\n\t\thpdu_cb->hdr = pdu_cb->hdr;\n\t\thpdu_cb->hlen = pdu_cb->hlen;\n\n\t\tmemcpy(&hssi->frags[hfrag_idx], &ssi->frags[pdu_cb->hfrag_idx],\n\t\t       sizeof(skb_frag_t));\n\n\t\tget_page(skb_frag_page(&hssi->frags[hfrag_idx]));\n\t\thssi->nr_frags++;\n\t\thpdu_cb->frags++;\n\t\thpdu_cb->hfrag_idx = hfrag_idx;\n\n\t\tlen = skb_frag_size(&hssi->frags[hfrag_idx]);\n\t\thskb->len += len;\n\t\thskb->data_len += len;\n\t\thskb->truesize += len;\n\t}\n\n\tif (pdu_cb->flags & PDUCBF_RX_DATA) {\n\t\tu8 dfrag_idx = hssi->nr_frags, i;\n\n\t\thpdu_cb->flags |= pdu_cb->flags;\n\t\thpdu_cb->dfrag_idx = dfrag_idx;\n\n\t\tlen = 0;\n\t\tfor (i = 0; i < pdu_cb->nr_dfrags; dfrag_idx++, i++) {\n\t\t\tmemcpy(&hssi->frags[dfrag_idx],\n\t\t\t       &ssi->frags[pdu_cb->dfrag_idx + i],\n\t\t\t       sizeof(skb_frag_t));\n\n\t\t\tget_page(skb_frag_page(&hssi->frags[dfrag_idx]));\n\n\t\t\tlen += skb_frag_size(&hssi->frags[dfrag_idx]);\n\n\t\t\thssi->nr_frags++;\n\t\t\thpdu_cb->frags++;\n\t\t}\n\n\t\thpdu_cb->dlen = pdu_cb->dlen;\n\t\thpdu_cb->doffset = hpdu_cb->hlen;\n\t\thpdu_cb->nr_dfrags = pdu_cb->nr_dfrags;\n\t\thskb->len += len;\n\t\thskb->data_len += len;\n\t\thskb->truesize += len;\n\t}\n\n\tif (pdu_cb->flags & PDUCBF_RX_STATUS) {\n\t\thpdu_cb->flags |= pdu_cb->flags;\n\n\t\tif (hpdu_cb->flags & PDUCBF_RX_DATA)\n\t\t\thpdu_cb->flags &= ~PDUCBF_RX_DATA_DDPD;\n\n\t\thpdu_cb->ddigest = pdu_cb->ddigest;\n\t\thpdu_cb->pdulen = pdu_cb->pdulen;\n\t}\n}\n\nstatic int cxgbit_process_lro_skb(struct cxgbit_sock *csk, struct sk_buff *skb)\n{\n\tstruct cxgbit_lro_cb *lro_cb = cxgbit_skb_lro_cb(skb);\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_skb_lro_pdu_cb(skb, 0);\n\tu8 pdu_idx = 0, last_idx = 0;\n\tint ret = 0;\n\n\tif (!pdu_cb->complete) {\n\t\tcxgbit_lro_skb_merge(csk, skb, 0);\n\n\t\tif (pdu_cb->flags & PDUCBF_RX_STATUS) {\n\t\t\tstruct sk_buff *hskb = csk->lro_hskb;\n\n\t\t\tret = cxgbit_process_iscsi_pdu(csk, hskb, 0);\n\n\t\t\tcxgbit_lro_hskb_reset(csk);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tpdu_idx = 1;\n\t}\n\n\tif (lro_cb->pdu_idx)\n\t\tlast_idx = lro_cb->pdu_idx - 1;\n\n\tfor (; pdu_idx <= last_idx; pdu_idx++) {\n\t\tret = cxgbit_process_iscsi_pdu(csk, skb, pdu_idx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif ((!lro_cb->complete) && lro_cb->pdu_idx)\n\t\tcxgbit_lro_skb_merge(csk, skb, lro_cb->pdu_idx);\n\nout:\n\treturn ret;\n}\n\nstatic int cxgbit_t5_rx_lro_skb(struct cxgbit_sock *csk, struct sk_buff *skb)\n{\n\tstruct cxgbit_lro_cb *lro_cb = cxgbit_skb_lro_cb(skb);\n\tstruct cxgbit_lro_pdu_cb *pdu_cb = cxgbit_skb_lro_pdu_cb(skb, 0);\n\tint ret = -1;\n\n\tif ((pdu_cb->flags & PDUCBF_RX_HDR) &&\n\t    (pdu_cb->seq != csk->rcv_nxt)) {\n\t\tpr_info(\"csk 0x%p, tid 0x%x, seq 0x%x != 0x%x.\\n\",\n\t\t\tcsk, csk->tid, pdu_cb->seq, csk->rcv_nxt);\n\t\tcxgbit_lro_skb_dump(skb);\n\t\treturn ret;\n\t}\n\n\tcsk->rcv_nxt += lro_cb->pdu_totallen;\n\n\tret = cxgbit_process_lro_skb(csk, skb);\n\n\tcsk->rx_credits += lro_cb->pdu_totallen;\n\n\tif (csk->rx_credits >= (csk->rcv_win / 4))\n\t\tcxgbit_rx_data_ack(csk);\n\n\treturn ret;\n}\n\nstatic int cxgbit_rx_lro_skb(struct cxgbit_sock *csk, struct sk_buff *skb)\n{\n\tstruct cxgbit_lro_cb *lro_cb = cxgbit_skb_lro_cb(skb);\n\tint ret;\n\n\tret = cxgbit_process_lro_skb(csk, skb);\n\tif (ret)\n\t\treturn ret;\n\n\tcsk->rx_credits += lro_cb->pdu_totallen;\n\tif (csk->rx_credits >= csk->rcv_win) {\n\t\tcsk->rx_credits = 0;\n\t\tcxgbit_rx_data_ack(csk);\n\t}\n\n\treturn 0;\n}\n\nstatic int cxgbit_rx_skb(struct cxgbit_sock *csk, struct sk_buff *skb)\n{\n\tstruct cxgb4_lld_info *lldi = &csk->com.cdev->lldi;\n\tint ret = -1;\n\n\tif (likely(cxgbit_skcb_flags(skb) & SKCBF_RX_LRO)) {\n\t\tif (is_t5(lldi->adapter_type))\n\t\t\tret = cxgbit_t5_rx_lro_skb(csk, skb);\n\t\telse\n\t\t\tret = cxgbit_rx_lro_skb(csk, skb);\n\t}\n\n\t__kfree_skb(skb);\n\treturn ret;\n}\n\nstatic bool cxgbit_rxq_len(struct cxgbit_sock *csk, struct sk_buff_head *rxq)\n{\n\tspin_lock_bh(&csk->rxq.lock);\n\tif (skb_queue_len(&csk->rxq)) {\n\t\tskb_queue_splice_init(&csk->rxq, rxq);\n\t\tspin_unlock_bh(&csk->rxq.lock);\n\t\treturn true;\n\t}\n\tspin_unlock_bh(&csk->rxq.lock);\n\treturn false;\n}\n\nstatic int cxgbit_wait_rxq(struct cxgbit_sock *csk)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head rxq;\n\n\tskb_queue_head_init(&rxq);\n\n\twait_event_interruptible(csk->waitq, cxgbit_rxq_len(csk, &rxq));\n\n\tif (signal_pending(current))\n\t\tgoto out;\n\n\twhile ((skb = __skb_dequeue(&rxq))) {\n\t\tif (cxgbit_rx_skb(csk, skb))\n\t\t\tgoto out;\n\t}\n\n\treturn 0;\nout:\n\t__skb_queue_purge(&rxq);\n\treturn -1;\n}\n\nint cxgbit_get_login_rx(struct iscsit_conn *conn, struct iscsi_login *login)\n{\n\tstruct cxgbit_sock *csk = conn->context;\n\tint ret = -1;\n\n\twhile (!test_and_clear_bit(CSK_LOGIN_PDU_DONE, &csk->com.flags)) {\n\t\tret = cxgbit_wait_rxq(csk);\n\t\tif (ret) {\n\t\t\tclear_bit(CSK_LOGIN_PDU_DONE, &csk->com.flags);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid cxgbit_get_rx_pdu(struct iscsit_conn *conn)\n{\n\tstruct cxgbit_sock *csk = conn->context;\n\n\twhile (!kthread_should_stop()) {\n\t\tiscsit_thread_check_cpumask(conn, current, 0);\n\t\tif (cxgbit_wait_rxq(csk))\n\t\t\treturn;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}