{
  "module_name": "iscsi_target_erl2.c",
  "hash_id": "a707642f0a0e2c67a097ec46b27506e4823f1770faa5d93b81f78c4f438329bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target_erl2.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <scsi/iscsi_proto.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include <target/iscsi/iscsi_target_core.h>\n#include \"iscsi_target_datain_values.h\"\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target_erl0.h\"\n#include \"iscsi_target_erl1.h\"\n#include \"iscsi_target_erl2.h\"\n#include \"iscsi_target.h\"\n\n \nvoid iscsit_create_conn_recovery_datain_values(\n\tstruct iscsit_cmd *cmd,\n\t__be32 exp_data_sn)\n{\n\tu32 data_sn = 0;\n\tstruct iscsit_conn *conn = cmd->conn;\n\n\tcmd->next_burst_len = 0;\n\tcmd->read_data_done = 0;\n\n\twhile (be32_to_cpu(exp_data_sn) > data_sn) {\n\t\tif ((cmd->next_burst_len +\n\t\t     conn->conn_ops->MaxRecvDataSegmentLength) <\n\t\t     conn->sess->sess_ops->MaxBurstLength) {\n\t\t\tcmd->read_data_done +=\n\t\t\t       conn->conn_ops->MaxRecvDataSegmentLength;\n\t\t\tcmd->next_burst_len +=\n\t\t\t       conn->conn_ops->MaxRecvDataSegmentLength;\n\t\t} else {\n\t\t\tcmd->read_data_done +=\n\t\t\t\t(conn->sess->sess_ops->MaxBurstLength -\n\t\t\t\tcmd->next_burst_len);\n\t\t\tcmd->next_burst_len = 0;\n\t\t}\n\t\tdata_sn++;\n\t}\n}\n\nvoid iscsit_create_conn_recovery_dataout_values(\n\tstruct iscsit_cmd *cmd)\n{\n\tu32 write_data_done = 0;\n\tstruct iscsit_conn *conn = cmd->conn;\n\n\tcmd->data_sn = 0;\n\tcmd->next_burst_len = 0;\n\n\twhile (cmd->write_data_done > write_data_done) {\n\t\tif ((write_data_done + conn->sess->sess_ops->MaxBurstLength) <=\n\t\t     cmd->write_data_done)\n\t\t\twrite_data_done += conn->sess->sess_ops->MaxBurstLength;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tcmd->write_data_done = write_data_done;\n}\n\nstatic int iscsit_attach_active_connection_recovery_entry(\n\tstruct iscsit_session *sess,\n\tstruct iscsi_conn_recovery *cr)\n{\n\tspin_lock(&sess->cr_a_lock);\n\tlist_add_tail(&cr->cr_list, &sess->cr_active_list);\n\tspin_unlock(&sess->cr_a_lock);\n\n\treturn 0;\n}\n\nstatic int iscsit_attach_inactive_connection_recovery_entry(\n\tstruct iscsit_session *sess,\n\tstruct iscsi_conn_recovery *cr)\n{\n\tspin_lock(&sess->cr_i_lock);\n\tlist_add_tail(&cr->cr_list, &sess->cr_inactive_list);\n\n\tsess->conn_recovery_count++;\n\tpr_debug(\"Incremented connection recovery count to %u for\"\n\t\t\" SID: %u\\n\", sess->conn_recovery_count, sess->sid);\n\tspin_unlock(&sess->cr_i_lock);\n\n\treturn 0;\n}\n\nstruct iscsi_conn_recovery *iscsit_get_inactive_connection_recovery_entry(\n\tstruct iscsit_session *sess,\n\tu16 cid)\n{\n\tstruct iscsi_conn_recovery *cr;\n\n\tspin_lock(&sess->cr_i_lock);\n\tlist_for_each_entry(cr, &sess->cr_inactive_list, cr_list) {\n\t\tif (cr->cid == cid) {\n\t\t\tspin_unlock(&sess->cr_i_lock);\n\t\t\treturn cr;\n\t\t}\n\t}\n\tspin_unlock(&sess->cr_i_lock);\n\n\treturn NULL;\n}\n\nvoid iscsit_free_connection_recovery_entries(struct iscsit_session *sess)\n{\n\tstruct iscsit_cmd *cmd, *cmd_tmp;\n\tstruct iscsi_conn_recovery *cr, *cr_tmp;\n\n\tspin_lock(&sess->cr_a_lock);\n\tlist_for_each_entry_safe(cr, cr_tmp, &sess->cr_active_list, cr_list) {\n\t\tlist_del(&cr->cr_list);\n\t\tspin_unlock(&sess->cr_a_lock);\n\n\t\tspin_lock(&cr->conn_recovery_cmd_lock);\n\t\tlist_for_each_entry_safe(cmd, cmd_tmp,\n\t\t\t\t&cr->conn_recovery_cmd_list, i_conn_node) {\n\n\t\t\tlist_del_init(&cmd->i_conn_node);\n\t\t\tcmd->conn = NULL;\n\t\t\tspin_unlock(&cr->conn_recovery_cmd_lock);\n\t\t\tiscsit_free_cmd(cmd, true);\n\t\t\tspin_lock(&cr->conn_recovery_cmd_lock);\n\t\t}\n\t\tspin_unlock(&cr->conn_recovery_cmd_lock);\n\t\tspin_lock(&sess->cr_a_lock);\n\n\t\tkfree(cr);\n\t}\n\tspin_unlock(&sess->cr_a_lock);\n\n\tspin_lock(&sess->cr_i_lock);\n\tlist_for_each_entry_safe(cr, cr_tmp, &sess->cr_inactive_list, cr_list) {\n\t\tlist_del(&cr->cr_list);\n\t\tspin_unlock(&sess->cr_i_lock);\n\n\t\tspin_lock(&cr->conn_recovery_cmd_lock);\n\t\tlist_for_each_entry_safe(cmd, cmd_tmp,\n\t\t\t\t&cr->conn_recovery_cmd_list, i_conn_node) {\n\n\t\t\tlist_del_init(&cmd->i_conn_node);\n\t\t\tcmd->conn = NULL;\n\t\t\tspin_unlock(&cr->conn_recovery_cmd_lock);\n\t\t\tiscsit_free_cmd(cmd, true);\n\t\t\tspin_lock(&cr->conn_recovery_cmd_lock);\n\t\t}\n\t\tspin_unlock(&cr->conn_recovery_cmd_lock);\n\t\tspin_lock(&sess->cr_i_lock);\n\n\t\tkfree(cr);\n\t}\n\tspin_unlock(&sess->cr_i_lock);\n}\n\nint iscsit_remove_active_connection_recovery_entry(\n\tstruct iscsi_conn_recovery *cr,\n\tstruct iscsit_session *sess)\n{\n\tspin_lock(&sess->cr_a_lock);\n\tlist_del(&cr->cr_list);\n\n\tsess->conn_recovery_count--;\n\tpr_debug(\"Decremented connection recovery count to %u for\"\n\t\t\" SID: %u\\n\", sess->conn_recovery_count, sess->sid);\n\tspin_unlock(&sess->cr_a_lock);\n\n\tkfree(cr);\n\n\treturn 0;\n}\n\nstatic void iscsit_remove_inactive_connection_recovery_entry(\n\tstruct iscsi_conn_recovery *cr,\n\tstruct iscsit_session *sess)\n{\n\tspin_lock(&sess->cr_i_lock);\n\tlist_del(&cr->cr_list);\n\tspin_unlock(&sess->cr_i_lock);\n}\n\n \nint iscsit_remove_cmd_from_connection_recovery(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_session *sess)\n{\n\tstruct iscsi_conn_recovery *cr;\n\n\tif (!cmd->cr) {\n\t\tpr_err(\"struct iscsi_conn_recovery pointer for ITT: 0x%08x\"\n\t\t\t\" is NULL!\\n\", cmd->init_task_tag);\n\t\tBUG();\n\t}\n\tcr = cmd->cr;\n\n\tlist_del_init(&cmd->i_conn_node);\n\treturn --cr->cmd_count;\n}\n\nvoid iscsit_discard_cr_cmds_by_expstatsn(\n\tstruct iscsi_conn_recovery *cr,\n\tu32 exp_statsn)\n{\n\tu32 dropped_count = 0;\n\tstruct iscsit_cmd *cmd, *cmd_tmp;\n\tstruct iscsit_session *sess = cr->sess;\n\n\tspin_lock(&cr->conn_recovery_cmd_lock);\n\tlist_for_each_entry_safe(cmd, cmd_tmp,\n\t\t\t&cr->conn_recovery_cmd_list, i_conn_node) {\n\n\t\tif (((cmd->deferred_i_state != ISTATE_SENT_STATUS) &&\n\t\t     (cmd->deferred_i_state != ISTATE_REMOVE)) ||\n\t\t     (cmd->stat_sn >= exp_statsn)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdropped_count++;\n\t\tpr_debug(\"Dropping Acknowledged ITT: 0x%08x, StatSN:\"\n\t\t\t\" 0x%08x, CID: %hu.\\n\", cmd->init_task_tag,\n\t\t\t\tcmd->stat_sn, cr->cid);\n\n\t\tiscsit_remove_cmd_from_connection_recovery(cmd, sess);\n\n\t\tspin_unlock(&cr->conn_recovery_cmd_lock);\n\t\tiscsit_free_cmd(cmd, true);\n\t\tspin_lock(&cr->conn_recovery_cmd_lock);\n\t}\n\tspin_unlock(&cr->conn_recovery_cmd_lock);\n\n\tpr_debug(\"Dropped %u total acknowledged commands on\"\n\t\t\" CID: %hu less than old ExpStatSN: 0x%08x\\n\",\n\t\t\tdropped_count, cr->cid, exp_statsn);\n\n\tif (!cr->cmd_count) {\n\t\tpr_debug(\"No commands to be reassigned for failed\"\n\t\t\t\" connection CID: %hu on SID: %u\\n\",\n\t\t\tcr->cid, sess->sid);\n\t\tiscsit_remove_inactive_connection_recovery_entry(cr, sess);\n\t\tiscsit_attach_active_connection_recovery_entry(sess, cr);\n\t\tpr_debug(\"iSCSI connection recovery successful for CID:\"\n\t\t\t\" %hu on SID: %u\\n\", cr->cid, sess->sid);\n\t\tiscsit_remove_active_connection_recovery_entry(cr, sess);\n\t} else {\n\t\tiscsit_remove_inactive_connection_recovery_entry(cr, sess);\n\t\tiscsit_attach_active_connection_recovery_entry(sess, cr);\n\t}\n}\n\nint iscsit_discard_unacknowledged_ooo_cmdsns_for_conn(struct iscsit_conn *conn)\n{\n\tu32 dropped_count = 0;\n\tstruct iscsit_cmd *cmd, *cmd_tmp;\n\tstruct iscsi_ooo_cmdsn *ooo_cmdsn, *ooo_cmdsn_tmp;\n\tstruct iscsit_session *sess = conn->sess;\n\n\tmutex_lock(&sess->cmdsn_mutex);\n\tlist_for_each_entry_safe(ooo_cmdsn, ooo_cmdsn_tmp,\n\t\t\t&sess->sess_ooo_cmdsn_list, ooo_list) {\n\n\t\tif (ooo_cmdsn->cid != conn->cid)\n\t\t\tcontinue;\n\n\t\tdropped_count++;\n\t\tpr_debug(\"Dropping unacknowledged CmdSN:\"\n\t\t\" 0x%08x during connection recovery on CID: %hu\\n\",\n\t\t\tooo_cmdsn->cmdsn, conn->cid);\n\t\tiscsit_remove_ooo_cmdsn(sess, ooo_cmdsn);\n\t}\n\tmutex_unlock(&sess->cmdsn_mutex);\n\n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_for_each_entry_safe(cmd, cmd_tmp, &conn->conn_cmd_list, i_conn_node) {\n\t\tif (!(cmd->cmd_flags & ICF_OOO_CMDSN))\n\t\t\tcontinue;\n\n\t\tlist_del_init(&cmd->i_conn_node);\n\n\t\tspin_unlock_bh(&conn->cmd_lock);\n\t\tiscsit_free_cmd(cmd, true);\n\t\tspin_lock_bh(&conn->cmd_lock);\n\t}\n\tspin_unlock_bh(&conn->cmd_lock);\n\n\tpr_debug(\"Dropped %u total unacknowledged commands on CID:\"\n\t\t\" %hu for ExpCmdSN: 0x%08x.\\n\", dropped_count, conn->cid,\n\t\t\t\tsess->exp_cmd_sn);\n\treturn 0;\n}\n\nint iscsit_prepare_cmds_for_reallegiance(struct iscsit_conn *conn)\n{\n\tu32 cmd_count = 0;\n\tstruct iscsit_cmd *cmd, *cmd_tmp;\n\tstruct iscsi_conn_recovery *cr;\n\n\t \n\tcr = kzalloc(sizeof(struct iscsi_conn_recovery), GFP_KERNEL);\n\tif (!cr) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_conn_recovery.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&cr->cr_list);\n\tINIT_LIST_HEAD(&cr->conn_recovery_cmd_list);\n\tspin_lock_init(&cr->conn_recovery_cmd_lock);\n\t \n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_for_each_entry_safe(cmd, cmd_tmp, &conn->conn_cmd_list, i_conn_node) {\n\n\t\tif ((cmd->iscsi_opcode != ISCSI_OP_SCSI_CMD) &&\n\t\t    (cmd->iscsi_opcode != ISCSI_OP_NOOP_OUT)) {\n\t\t\tpr_debug(\"Not performing reallegiance on\"\n\t\t\t\t\" Opcode: 0x%02x, ITT: 0x%08x, CmdSN: 0x%08x,\"\n\t\t\t\t\" CID: %hu\\n\", cmd->iscsi_opcode,\n\t\t\t\tcmd->init_task_tag, cmd->cmd_sn, conn->cid);\n\n\t\t\tlist_del_init(&cmd->i_conn_node);\n\t\t\tspin_unlock_bh(&conn->cmd_lock);\n\t\t\tiscsit_free_cmd(cmd, true);\n\t\t\tspin_lock_bh(&conn->cmd_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!(cmd->cmd_flags & ICF_OOO_CMDSN) && !cmd->immediate_cmd &&\n\t\t     iscsi_sna_gte(cmd->cmd_sn, conn->sess->exp_cmd_sn)) {\n\t\t\tlist_del_init(&cmd->i_conn_node);\n\t\t\tspin_unlock_bh(&conn->cmd_lock);\n\t\t\tiscsit_free_cmd(cmd, true);\n\t\t\tspin_lock_bh(&conn->cmd_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmd_count++;\n\t\tpr_debug(\"Preparing Opcode: 0x%02x, ITT: 0x%08x,\"\n\t\t\t\" CmdSN: 0x%08x, StatSN: 0x%08x, CID: %hu for\"\n\t\t\t\" reallegiance.\\n\", cmd->iscsi_opcode,\n\t\t\tcmd->init_task_tag, cmd->cmd_sn, cmd->stat_sn,\n\t\t\tconn->cid);\n\n\t\tcmd->deferred_i_state = cmd->i_state;\n\t\tcmd->i_state = ISTATE_IN_CONNECTION_RECOVERY;\n\n\t\tif (cmd->data_direction == DMA_TO_DEVICE)\n\t\t\tiscsit_stop_dataout_timer(cmd);\n\n\t\tcmd->sess = conn->sess;\n\n\t\tlist_del_init(&cmd->i_conn_node);\n\t\tspin_unlock_bh(&conn->cmd_lock);\n\n\t\tiscsit_free_all_datain_reqs(cmd);\n\n\t\ttransport_wait_for_tasks(&cmd->se_cmd);\n\t\t \n\t\tspin_lock(&cr->conn_recovery_cmd_lock);\n\t\tlist_add_tail(&cmd->i_conn_node, &cr->conn_recovery_cmd_list);\n\t\tspin_unlock(&cr->conn_recovery_cmd_lock);\n\n\t\tspin_lock_bh(&conn->cmd_lock);\n\t\tcmd->cr = cr;\n\t\tcmd->conn = NULL;\n\t}\n\tspin_unlock_bh(&conn->cmd_lock);\n\t \n\tcr->cid = conn->cid;\n\tcr->cmd_count = cmd_count;\n\tcr->maxrecvdatasegmentlength = conn->conn_ops->MaxRecvDataSegmentLength;\n\tcr->maxxmitdatasegmentlength = conn->conn_ops->MaxXmitDataSegmentLength;\n\tcr->sess = conn->sess;\n\n\tiscsit_attach_inactive_connection_recovery_entry(conn->sess, cr);\n\n\treturn 0;\n}\n\nint iscsit_connection_recovery_transport_reset(struct iscsit_conn *conn)\n{\n\tatomic_set(&conn->connection_recovery, 1);\n\n\tif (iscsit_close_connection(conn) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}