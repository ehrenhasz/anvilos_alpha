{
  "module_name": "iscsi_target_util.c",
  "hash_id": "bd063283ff9c6f0793afbece21caba6f1d7584f61fdd4a42de35ffafb358e866",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target_util.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/sched/signal.h>\n#include <net/ipv6.h>          \n#include <scsi/scsi_tcq.h>\n#include <scsi/iscsi_proto.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n#include <target/iscsi/iscsi_transport.h>\n\n#include <target/iscsi/iscsi_target_core.h>\n#include \"iscsi_target_parameters.h\"\n#include \"iscsi_target_seq_pdu_list.h\"\n#include \"iscsi_target_datain_values.h\"\n#include \"iscsi_target_erl0.h\"\n#include \"iscsi_target_erl1.h\"\n#include \"iscsi_target_erl2.h\"\n#include \"iscsi_target_tpg.h\"\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target.h\"\n\nextern struct list_head g_tiqn_list;\nextern spinlock_t tiqn_lock;\n\nint iscsit_add_r2t_to_list(\n\tstruct iscsit_cmd *cmd,\n\tu32 offset,\n\tu32 xfer_len,\n\tint recovery,\n\tu32 r2t_sn)\n{\n\tstruct iscsi_r2t *r2t;\n\n\tlockdep_assert_held(&cmd->r2t_lock);\n\n\tWARN_ON_ONCE((s32)xfer_len < 0);\n\n\tr2t = kmem_cache_zalloc(lio_r2t_cache, GFP_ATOMIC);\n\tif (!r2t) {\n\t\tpr_err(\"Unable to allocate memory for struct iscsi_r2t.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&r2t->r2t_list);\n\n\tr2t->recovery_r2t = recovery;\n\tr2t->r2t_sn = (!r2t_sn) ? cmd->r2t_sn++ : r2t_sn;\n\tr2t->offset = offset;\n\tr2t->xfer_len = xfer_len;\n\tlist_add_tail(&r2t->r2t_list, &cmd->cmd_r2t_list);\n\tspin_unlock_bh(&cmd->r2t_lock);\n\n\tiscsit_add_cmd_to_immediate_queue(cmd, cmd->conn, ISTATE_SEND_R2T);\n\n\tspin_lock_bh(&cmd->r2t_lock);\n\treturn 0;\n}\n\nstruct iscsi_r2t *iscsit_get_r2t_for_eos(\n\tstruct iscsit_cmd *cmd,\n\tu32 offset,\n\tu32 length)\n{\n\tstruct iscsi_r2t *r2t;\n\n\tspin_lock_bh(&cmd->r2t_lock);\n\tlist_for_each_entry(r2t, &cmd->cmd_r2t_list, r2t_list) {\n\t\tif ((r2t->offset <= offset) &&\n\t\t    (r2t->offset + r2t->xfer_len) >= (offset + length)) {\n\t\t\tspin_unlock_bh(&cmd->r2t_lock);\n\t\t\treturn r2t;\n\t\t}\n\t}\n\tspin_unlock_bh(&cmd->r2t_lock);\n\n\tpr_err(\"Unable to locate R2T for Offset: %u, Length:\"\n\t\t\t\" %u\\n\", offset, length);\n\treturn NULL;\n}\n\nstruct iscsi_r2t *iscsit_get_r2t_from_list(struct iscsit_cmd *cmd)\n{\n\tstruct iscsi_r2t *r2t;\n\n\tspin_lock_bh(&cmd->r2t_lock);\n\tlist_for_each_entry(r2t, &cmd->cmd_r2t_list, r2t_list) {\n\t\tif (!r2t->sent_r2t) {\n\t\t\tspin_unlock_bh(&cmd->r2t_lock);\n\t\t\treturn r2t;\n\t\t}\n\t}\n\tspin_unlock_bh(&cmd->r2t_lock);\n\n\tpr_err(\"Unable to locate next R2T to send for ITT:\"\n\t\t\t\" 0x%08x.\\n\", cmd->init_task_tag);\n\treturn NULL;\n}\n\nvoid iscsit_free_r2t(struct iscsi_r2t *r2t, struct iscsit_cmd *cmd)\n{\n\tlockdep_assert_held(&cmd->r2t_lock);\n\n\tlist_del(&r2t->r2t_list);\n\tkmem_cache_free(lio_r2t_cache, r2t);\n}\n\nvoid iscsit_free_r2ts_from_list(struct iscsit_cmd *cmd)\n{\n\tstruct iscsi_r2t *r2t, *r2t_tmp;\n\n\tspin_lock_bh(&cmd->r2t_lock);\n\tlist_for_each_entry_safe(r2t, r2t_tmp, &cmd->cmd_r2t_list, r2t_list)\n\t\tiscsit_free_r2t(r2t, cmd);\n\tspin_unlock_bh(&cmd->r2t_lock);\n}\n\nstatic int iscsit_wait_for_tag(struct se_session *se_sess, int state, int *cpup)\n{\n\tint tag = -1;\n\tDEFINE_SBQ_WAIT(wait);\n\tstruct sbq_wait_state *ws;\n\tstruct sbitmap_queue *sbq;\n\n\tif (state == TASK_RUNNING)\n\t\treturn tag;\n\n\tsbq = &se_sess->sess_tag_pool;\n\tws = &sbq->ws[0];\n\tfor (;;) {\n\t\tsbitmap_prepare_to_wait(sbq, ws, &wait, state);\n\t\tif (signal_pending_state(state, current))\n\t\t\tbreak;\n\t\ttag = sbitmap_queue_get(sbq, cpup);\n\t\tif (tag >= 0)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\n\tsbitmap_finish_wait(sbq, ws, &wait);\n\treturn tag;\n}\n\n \nstruct iscsit_cmd *iscsit_allocate_cmd(struct iscsit_conn *conn, int state)\n{\n\tstruct iscsit_cmd *cmd;\n\tstruct se_session *se_sess = conn->sess->se_sess;\n\tint size, tag, cpu;\n\n\ttag = sbitmap_queue_get(&se_sess->sess_tag_pool, &cpu);\n\tif (tag < 0)\n\t\ttag = iscsit_wait_for_tag(se_sess, state, &cpu);\n\tif (tag < 0)\n\t\treturn NULL;\n\n\tsize = sizeof(struct iscsit_cmd) + conn->conn_transport->priv_size;\n\tcmd = (struct iscsit_cmd *)(se_sess->sess_cmd_map + (tag * size));\n\tmemset(cmd, 0, size);\n\n\tcmd->se_cmd.map_tag = tag;\n\tcmd->se_cmd.map_cpu = cpu;\n\tcmd->conn = conn;\n\tcmd->data_direction = DMA_NONE;\n\tINIT_LIST_HEAD(&cmd->i_conn_node);\n\tINIT_LIST_HEAD(&cmd->datain_list);\n\tINIT_LIST_HEAD(&cmd->cmd_r2t_list);\n\tspin_lock_init(&cmd->datain_lock);\n\tspin_lock_init(&cmd->dataout_timeout_lock);\n\tspin_lock_init(&cmd->istate_lock);\n\tspin_lock_init(&cmd->error_lock);\n\tspin_lock_init(&cmd->r2t_lock);\n\ttimer_setup(&cmd->dataout_timer, iscsit_handle_dataout_timeout, 0);\n\n\treturn cmd;\n}\nEXPORT_SYMBOL(iscsit_allocate_cmd);\n\nstruct iscsi_seq *iscsit_get_seq_holder_for_datain(\n\tstruct iscsit_cmd *cmd,\n\tu32 seq_send_order)\n{\n\tu32 i;\n\n\tfor (i = 0; i < cmd->seq_count; i++)\n\t\tif (cmd->seq_list[i].seq_send_order == seq_send_order)\n\t\t\treturn &cmd->seq_list[i];\n\n\treturn NULL;\n}\n\nstruct iscsi_seq *iscsit_get_seq_holder_for_r2t(struct iscsit_cmd *cmd)\n{\n\tu32 i;\n\n\tif (!cmd->seq_list) {\n\t\tpr_err(\"struct iscsit_cmd->seq_list is NULL!\\n\");\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < cmd->seq_count; i++) {\n\t\tif (cmd->seq_list[i].type != SEQTYPE_NORMAL)\n\t\t\tcontinue;\n\t\tif (cmd->seq_list[i].seq_send_order == cmd->seq_send_order) {\n\t\t\tcmd->seq_send_order++;\n\t\t\treturn &cmd->seq_list[i];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstruct iscsi_r2t *iscsit_get_holder_for_r2tsn(\n\tstruct iscsit_cmd *cmd,\n\tu32 r2t_sn)\n{\n\tstruct iscsi_r2t *r2t;\n\n\tspin_lock_bh(&cmd->r2t_lock);\n\tlist_for_each_entry(r2t, &cmd->cmd_r2t_list, r2t_list) {\n\t\tif (r2t->r2t_sn == r2t_sn) {\n\t\t\tspin_unlock_bh(&cmd->r2t_lock);\n\t\t\treturn r2t;\n\t\t}\n\t}\n\tspin_unlock_bh(&cmd->r2t_lock);\n\n\treturn NULL;\n}\n\nstatic inline int iscsit_check_received_cmdsn(struct iscsit_session *sess, u32 cmdsn)\n{\n\tu32 max_cmdsn;\n\tint ret;\n\n\t \n\tmax_cmdsn = atomic_read(&sess->max_cmd_sn);\n\tif (iscsi_sna_gt(cmdsn, max_cmdsn)) {\n\t\tpr_err(\"Received CmdSN: 0x%08x is greater than\"\n\t\t       \" MaxCmdSN: 0x%08x, ignoring.\\n\", cmdsn, max_cmdsn);\n\t\tret = CMDSN_MAXCMDSN_OVERRUN;\n\n\t} else if (cmdsn == sess->exp_cmd_sn) {\n\t\tsess->exp_cmd_sn++;\n\t\tpr_debug(\"Received CmdSN matches ExpCmdSN,\"\n\t\t      \" incremented ExpCmdSN to: 0x%08x\\n\",\n\t\t      sess->exp_cmd_sn);\n\t\tret = CMDSN_NORMAL_OPERATION;\n\n\t} else if (iscsi_sna_gt(cmdsn, sess->exp_cmd_sn)) {\n\t\tpr_debug(\"Received CmdSN: 0x%08x is greater\"\n\t\t      \" than ExpCmdSN: 0x%08x, not acknowledging.\\n\",\n\t\t      cmdsn, sess->exp_cmd_sn);\n\t\tret = CMDSN_HIGHER_THAN_EXP;\n\n\t} else {\n\t\tpr_err(\"Received CmdSN: 0x%08x is less than\"\n\t\t       \" ExpCmdSN: 0x%08x, ignoring.\\n\", cmdsn,\n\t\t       sess->exp_cmd_sn);\n\t\tret = CMDSN_LOWER_THAN_EXP;\n\t}\n\n\treturn ret;\n}\n\n \nint iscsit_sequence_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t\tunsigned char *buf, __be32 cmdsn)\n{\n\tint ret, cmdsn_ret;\n\tbool reject = false;\n\tu8 reason = ISCSI_REASON_BOOKMARK_NO_RESOURCES;\n\n\tmutex_lock(&conn->sess->cmdsn_mutex);\n\n\tcmdsn_ret = iscsit_check_received_cmdsn(conn->sess, be32_to_cpu(cmdsn));\n\tswitch (cmdsn_ret) {\n\tcase CMDSN_NORMAL_OPERATION:\n\t\tret = iscsit_execute_cmd(cmd, 0);\n\t\tif ((ret >= 0) && !list_empty(&conn->sess->sess_ooo_cmdsn_list))\n\t\t\tiscsit_execute_ooo_cmdsns(conn->sess);\n\t\telse if (ret < 0) {\n\t\t\treject = true;\n\t\t\tret = CMDSN_ERROR_CANNOT_RECOVER;\n\t\t}\n\t\tbreak;\n\tcase CMDSN_HIGHER_THAN_EXP:\n\t\tret = iscsit_handle_ooo_cmdsn(conn->sess, cmd, be32_to_cpu(cmdsn));\n\t\tif (ret < 0) {\n\t\t\treject = true;\n\t\t\tret = CMDSN_ERROR_CANNOT_RECOVER;\n\t\t\tbreak;\n\t\t}\n\t\tret = CMDSN_HIGHER_THAN_EXP;\n\t\tbreak;\n\tcase CMDSN_LOWER_THAN_EXP:\n\tcase CMDSN_MAXCMDSN_OVERRUN:\n\tdefault:\n\t\tcmd->i_state = ISTATE_REMOVE;\n\t\tiscsit_add_cmd_to_immediate_queue(cmd, conn, cmd->i_state);\n\t\t \n\t\tret = CMDSN_LOWER_THAN_EXP;\n\t\tbreak;\n\t}\n\tmutex_unlock(&conn->sess->cmdsn_mutex);\n\n\tif (reject)\n\t\tiscsit_reject_cmd(cmd, reason, buf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(iscsit_sequence_cmd);\n\nint iscsit_check_unsolicited_dataout(struct iscsit_cmd *cmd, unsigned char *buf)\n{\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct iscsi_data *hdr = (struct iscsi_data *) buf;\n\tu32 payload_length = ntoh24(hdr->dlength);\n\n\tif (conn->sess->sess_ops->InitialR2T) {\n\t\tpr_err(\"Received unexpected unsolicited data\"\n\t\t\t\" while InitialR2T=Yes, protocol error.\\n\");\n\t\ttransport_send_check_condition_and_sense(se_cmd,\n\t\t\t\tTCM_UNEXPECTED_UNSOLICITED_DATA, 0);\n\t\treturn -1;\n\t}\n\n\tif ((cmd->first_burst_len + payload_length) >\n\t     conn->sess->sess_ops->FirstBurstLength) {\n\t\tpr_err(\"Total %u bytes exceeds FirstBurstLength: %u\"\n\t\t\t\" for this Unsolicited DataOut Burst.\\n\",\n\t\t\t(cmd->first_burst_len + payload_length),\n\t\t\t\tconn->sess->sess_ops->FirstBurstLength);\n\t\ttransport_send_check_condition_and_sense(se_cmd,\n\t\t\t\tTCM_INCORRECT_AMOUNT_OF_DATA, 0);\n\t\treturn -1;\n\t}\n\n\tif (!(hdr->flags & ISCSI_FLAG_CMD_FINAL))\n\t\treturn 0;\n\n\tif (((cmd->first_burst_len + payload_length) != cmd->se_cmd.data_length) &&\n\t    ((cmd->first_burst_len + payload_length) !=\n\t      conn->sess->sess_ops->FirstBurstLength)) {\n\t\tpr_err(\"Unsolicited non-immediate data received %u\"\n\t\t\t\" does not equal FirstBurstLength: %u, and does\"\n\t\t\t\" not equal ExpXferLen %u.\\n\",\n\t\t\t(cmd->first_burst_len + payload_length),\n\t\t\tconn->sess->sess_ops->FirstBurstLength, cmd->se_cmd.data_length);\n\t\ttransport_send_check_condition_and_sense(se_cmd,\n\t\t\t\tTCM_INCORRECT_AMOUNT_OF_DATA, 0);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstruct iscsit_cmd *iscsit_find_cmd_from_itt(\n\tstruct iscsit_conn *conn,\n\titt_t init_task_tag)\n{\n\tstruct iscsit_cmd *cmd;\n\n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {\n\t\tif (cmd->init_task_tag == init_task_tag) {\n\t\t\tspin_unlock_bh(&conn->cmd_lock);\n\t\t\treturn cmd;\n\t\t}\n\t}\n\tspin_unlock_bh(&conn->cmd_lock);\n\n\tpr_err(\"Unable to locate ITT: 0x%08x on CID: %hu\",\n\t\t\tinit_task_tag, conn->cid);\n\treturn NULL;\n}\nEXPORT_SYMBOL(iscsit_find_cmd_from_itt);\n\nstruct iscsit_cmd *iscsit_find_cmd_from_itt_or_dump(\n\tstruct iscsit_conn *conn,\n\titt_t init_task_tag,\n\tu32 length)\n{\n\tstruct iscsit_cmd *cmd;\n\n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {\n\t\tif (cmd->cmd_flags & ICF_GOT_LAST_DATAOUT)\n\t\t\tcontinue;\n\t\tif (cmd->init_task_tag == init_task_tag) {\n\t\t\tspin_unlock_bh(&conn->cmd_lock);\n\t\t\treturn cmd;\n\t\t}\n\t}\n\tspin_unlock_bh(&conn->cmd_lock);\n\n\tpr_err(\"Unable to locate ITT: 0x%08x on CID: %hu,\"\n\t\t\t\" dumping payload\\n\", init_task_tag, conn->cid);\n\tif (length)\n\t\tiscsit_dump_data_payload(conn, length, 1);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(iscsit_find_cmd_from_itt_or_dump);\n\nstruct iscsit_cmd *iscsit_find_cmd_from_ttt(\n\tstruct iscsit_conn *conn,\n\tu32 targ_xfer_tag)\n{\n\tstruct iscsit_cmd *cmd = NULL;\n\n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {\n\t\tif (cmd->targ_xfer_tag == targ_xfer_tag) {\n\t\t\tspin_unlock_bh(&conn->cmd_lock);\n\t\t\treturn cmd;\n\t\t}\n\t}\n\tspin_unlock_bh(&conn->cmd_lock);\n\n\tpr_err(\"Unable to locate TTT: 0x%08x on CID: %hu\\n\",\n\t\t\ttarg_xfer_tag, conn->cid);\n\treturn NULL;\n}\n\nint iscsit_find_cmd_for_recovery(\n\tstruct iscsit_session *sess,\n\tstruct iscsit_cmd **cmd_ptr,\n\tstruct iscsi_conn_recovery **cr_ptr,\n\titt_t init_task_tag)\n{\n\tstruct iscsit_cmd *cmd = NULL;\n\tstruct iscsi_conn_recovery *cr;\n\t \n\tspin_lock(&sess->cr_i_lock);\n\tlist_for_each_entry(cr, &sess->cr_inactive_list, cr_list) {\n\t\tspin_lock(&cr->conn_recovery_cmd_lock);\n\t\tlist_for_each_entry(cmd, &cr->conn_recovery_cmd_list, i_conn_node) {\n\t\t\tif (cmd->init_task_tag == init_task_tag) {\n\t\t\t\tspin_unlock(&cr->conn_recovery_cmd_lock);\n\t\t\t\tspin_unlock(&sess->cr_i_lock);\n\n\t\t\t\t*cr_ptr = cr;\n\t\t\t\t*cmd_ptr = cmd;\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cr->conn_recovery_cmd_lock);\n\t}\n\tspin_unlock(&sess->cr_i_lock);\n\t \n\tspin_lock(&sess->cr_a_lock);\n\tlist_for_each_entry(cr, &sess->cr_active_list, cr_list) {\n\t\tspin_lock(&cr->conn_recovery_cmd_lock);\n\t\tlist_for_each_entry(cmd, &cr->conn_recovery_cmd_list, i_conn_node) {\n\t\t\tif (cmd->init_task_tag == init_task_tag) {\n\t\t\t\tspin_unlock(&cr->conn_recovery_cmd_lock);\n\t\t\t\tspin_unlock(&sess->cr_a_lock);\n\n\t\t\t\t*cr_ptr = cr;\n\t\t\t\t*cmd_ptr = cmd;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&cr->conn_recovery_cmd_lock);\n\t}\n\tspin_unlock(&sess->cr_a_lock);\n\n\treturn -1;\n}\n\nvoid iscsit_add_cmd_to_immediate_queue(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_conn *conn,\n\tu8 state)\n{\n\tstruct iscsi_queue_req *qr;\n\n\tqr = kmem_cache_zalloc(lio_qr_cache, GFP_ATOMIC);\n\tif (!qr) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\t\" struct iscsi_queue_req\\n\");\n\t\treturn;\n\t}\n\tINIT_LIST_HEAD(&qr->qr_list);\n\tqr->cmd = cmd;\n\tqr->state = state;\n\n\tspin_lock_bh(&conn->immed_queue_lock);\n\tlist_add_tail(&qr->qr_list, &conn->immed_queue_list);\n\tatomic_inc(&cmd->immed_queue_count);\n\tatomic_set(&conn->check_immediate_queue, 1);\n\tspin_unlock_bh(&conn->immed_queue_lock);\n\n\twake_up(&conn->queues_wq);\n}\nEXPORT_SYMBOL(iscsit_add_cmd_to_immediate_queue);\n\nstruct iscsi_queue_req *iscsit_get_cmd_from_immediate_queue(struct iscsit_conn *conn)\n{\n\tstruct iscsi_queue_req *qr;\n\n\tspin_lock_bh(&conn->immed_queue_lock);\n\tif (list_empty(&conn->immed_queue_list)) {\n\t\tspin_unlock_bh(&conn->immed_queue_lock);\n\t\treturn NULL;\n\t}\n\tqr = list_first_entry(&conn->immed_queue_list,\n\t\t\t      struct iscsi_queue_req, qr_list);\n\n\tlist_del(&qr->qr_list);\n\tif (qr->cmd)\n\t\tatomic_dec(&qr->cmd->immed_queue_count);\n\tspin_unlock_bh(&conn->immed_queue_lock);\n\n\treturn qr;\n}\n\nstatic void iscsit_remove_cmd_from_immediate_queue(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_conn *conn)\n{\n\tstruct iscsi_queue_req *qr, *qr_tmp;\n\n\tspin_lock_bh(&conn->immed_queue_lock);\n\tif (!atomic_read(&cmd->immed_queue_count)) {\n\t\tspin_unlock_bh(&conn->immed_queue_lock);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe(qr, qr_tmp, &conn->immed_queue_list, qr_list) {\n\t\tif (qr->cmd != cmd)\n\t\t\tcontinue;\n\n\t\tatomic_dec(&qr->cmd->immed_queue_count);\n\t\tlist_del(&qr->qr_list);\n\t\tkmem_cache_free(lio_qr_cache, qr);\n\t}\n\tspin_unlock_bh(&conn->immed_queue_lock);\n\n\tif (atomic_read(&cmd->immed_queue_count)) {\n\t\tpr_err(\"ITT: 0x%08x immed_queue_count: %d\\n\",\n\t\t\tcmd->init_task_tag,\n\t\t\tatomic_read(&cmd->immed_queue_count));\n\t}\n}\n\nint iscsit_add_cmd_to_response_queue(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_conn *conn,\n\tu8 state)\n{\n\tstruct iscsi_queue_req *qr;\n\n\tqr = kmem_cache_zalloc(lio_qr_cache, GFP_ATOMIC);\n\tif (!qr) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_queue_req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tINIT_LIST_HEAD(&qr->qr_list);\n\tqr->cmd = cmd;\n\tqr->state = state;\n\n\tspin_lock_bh(&conn->response_queue_lock);\n\tlist_add_tail(&qr->qr_list, &conn->response_queue_list);\n\tatomic_inc(&cmd->response_queue_count);\n\tspin_unlock_bh(&conn->response_queue_lock);\n\n\twake_up(&conn->queues_wq);\n\treturn 0;\n}\n\nstruct iscsi_queue_req *iscsit_get_cmd_from_response_queue(struct iscsit_conn *conn)\n{\n\tstruct iscsi_queue_req *qr;\n\n\tspin_lock_bh(&conn->response_queue_lock);\n\tif (list_empty(&conn->response_queue_list)) {\n\t\tspin_unlock_bh(&conn->response_queue_lock);\n\t\treturn NULL;\n\t}\n\n\tqr = list_first_entry(&conn->response_queue_list,\n\t\t\t      struct iscsi_queue_req, qr_list);\n\n\tlist_del(&qr->qr_list);\n\tif (qr->cmd)\n\t\tatomic_dec(&qr->cmd->response_queue_count);\n\tspin_unlock_bh(&conn->response_queue_lock);\n\n\treturn qr;\n}\n\nstatic void iscsit_remove_cmd_from_response_queue(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_conn *conn)\n{\n\tstruct iscsi_queue_req *qr, *qr_tmp;\n\n\tspin_lock_bh(&conn->response_queue_lock);\n\tif (!atomic_read(&cmd->response_queue_count)) {\n\t\tspin_unlock_bh(&conn->response_queue_lock);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe(qr, qr_tmp, &conn->response_queue_list,\n\t\t\t\tqr_list) {\n\t\tif (qr->cmd != cmd)\n\t\t\tcontinue;\n\n\t\tatomic_dec(&qr->cmd->response_queue_count);\n\t\tlist_del(&qr->qr_list);\n\t\tkmem_cache_free(lio_qr_cache, qr);\n\t}\n\tspin_unlock_bh(&conn->response_queue_lock);\n\n\tif (atomic_read(&cmd->response_queue_count)) {\n\t\tpr_err(\"ITT: 0x%08x response_queue_count: %d\\n\",\n\t\t\tcmd->init_task_tag,\n\t\t\tatomic_read(&cmd->response_queue_count));\n\t}\n}\n\nbool iscsit_conn_all_queues_empty(struct iscsit_conn *conn)\n{\n\tbool empty;\n\n\tspin_lock_bh(&conn->immed_queue_lock);\n\tempty = list_empty(&conn->immed_queue_list);\n\tspin_unlock_bh(&conn->immed_queue_lock);\n\n\tif (!empty)\n\t\treturn empty;\n\n\tspin_lock_bh(&conn->response_queue_lock);\n\tempty = list_empty(&conn->response_queue_list);\n\tspin_unlock_bh(&conn->response_queue_lock);\n\n\treturn empty;\n}\n\nvoid iscsit_free_queue_reqs_for_conn(struct iscsit_conn *conn)\n{\n\tstruct iscsi_queue_req *qr, *qr_tmp;\n\n\tspin_lock_bh(&conn->immed_queue_lock);\n\tlist_for_each_entry_safe(qr, qr_tmp, &conn->immed_queue_list, qr_list) {\n\t\tlist_del(&qr->qr_list);\n\t\tif (qr->cmd)\n\t\t\tatomic_dec(&qr->cmd->immed_queue_count);\n\n\t\tkmem_cache_free(lio_qr_cache, qr);\n\t}\n\tspin_unlock_bh(&conn->immed_queue_lock);\n\n\tspin_lock_bh(&conn->response_queue_lock);\n\tlist_for_each_entry_safe(qr, qr_tmp, &conn->response_queue_list,\n\t\t\tqr_list) {\n\t\tlist_del(&qr->qr_list);\n\t\tif (qr->cmd)\n\t\t\tatomic_dec(&qr->cmd->response_queue_count);\n\n\t\tkmem_cache_free(lio_qr_cache, qr);\n\t}\n\tspin_unlock_bh(&conn->response_queue_lock);\n}\n\nvoid iscsit_release_cmd(struct iscsit_cmd *cmd)\n{\n\tstruct iscsit_session *sess;\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\n\tWARN_ON(!list_empty(&cmd->i_conn_node));\n\n\tif (cmd->conn)\n\t\tsess = cmd->conn->sess;\n\telse\n\t\tsess = cmd->sess;\n\n\tBUG_ON(!sess || !sess->se_sess);\n\n\tkfree(cmd->buf_ptr);\n\tkfree(cmd->pdu_list);\n\tkfree(cmd->seq_list);\n\tkfree(cmd->tmr_req);\n\tkfree(cmd->overflow_buf);\n\tkfree(cmd->iov_data);\n\tkfree(cmd->text_in_ptr);\n\n\ttarget_free_tag(sess->se_sess, se_cmd);\n}\nEXPORT_SYMBOL(iscsit_release_cmd);\n\nvoid __iscsit_free_cmd(struct iscsit_cmd *cmd, bool check_queues)\n{\n\tstruct iscsit_conn *conn = cmd->conn;\n\n\tWARN_ON(!list_empty(&cmd->i_conn_node));\n\n\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\tiscsit_stop_dataout_timer(cmd);\n\t\tiscsit_free_r2ts_from_list(cmd);\n\t}\n\tif (cmd->data_direction == DMA_FROM_DEVICE)\n\t\tiscsit_free_all_datain_reqs(cmd);\n\n\tif (conn && check_queues) {\n\t\tiscsit_remove_cmd_from_immediate_queue(cmd, conn);\n\t\tiscsit_remove_cmd_from_response_queue(cmd, conn);\n\t}\n\n\tif (conn && conn->conn_transport->iscsit_unmap_cmd)\n\t\tconn->conn_transport->iscsit_unmap_cmd(conn, cmd);\n}\n\nvoid iscsit_free_cmd(struct iscsit_cmd *cmd, bool shutdown)\n{\n\tstruct se_cmd *se_cmd = cmd->se_cmd.se_tfo ? &cmd->se_cmd : NULL;\n\tint rc;\n\n\tWARN_ON(!list_empty(&cmd->i_conn_node));\n\n\t__iscsit_free_cmd(cmd, shutdown);\n\tif (se_cmd) {\n\t\trc = transport_generic_free_cmd(se_cmd, shutdown);\n\t\tif (!rc && shutdown && se_cmd->se_sess) {\n\t\t\t__iscsit_free_cmd(cmd, shutdown);\n\t\t\ttarget_put_sess_cmd(se_cmd);\n\t\t}\n\t} else {\n\t\tiscsit_release_cmd(cmd);\n\t}\n}\nEXPORT_SYMBOL(iscsit_free_cmd);\n\nbool iscsit_check_session_usage_count(struct iscsit_session *sess,\n\t\t\t\t      bool can_sleep)\n{\n\tspin_lock_bh(&sess->session_usage_lock);\n\tif (sess->session_usage_count != 0) {\n\t\tsess->session_waiting_on_uc = 1;\n\t\tspin_unlock_bh(&sess->session_usage_lock);\n\t\tif (!can_sleep)\n\t\t\treturn true;\n\n\t\twait_for_completion(&sess->session_waiting_on_uc_comp);\n\t\treturn false;\n\t}\n\tspin_unlock_bh(&sess->session_usage_lock);\n\n\treturn false;\n}\n\nvoid iscsit_dec_session_usage_count(struct iscsit_session *sess)\n{\n\tspin_lock_bh(&sess->session_usage_lock);\n\tsess->session_usage_count--;\n\n\tif (!sess->session_usage_count && sess->session_waiting_on_uc)\n\t\tcomplete(&sess->session_waiting_on_uc_comp);\n\n\tspin_unlock_bh(&sess->session_usage_lock);\n}\n\nvoid iscsit_inc_session_usage_count(struct iscsit_session *sess)\n{\n\tspin_lock_bh(&sess->session_usage_lock);\n\tsess->session_usage_count++;\n\tspin_unlock_bh(&sess->session_usage_lock);\n}\n\nstruct iscsit_conn *iscsit_get_conn_from_cid(struct iscsit_session *sess, u16 cid)\n{\n\tstruct iscsit_conn *conn;\n\n\tspin_lock_bh(&sess->conn_lock);\n\tlist_for_each_entry(conn, &sess->sess_conn_list, conn_list) {\n\t\tif ((conn->cid == cid) &&\n\t\t    (conn->conn_state == TARG_CONN_STATE_LOGGED_IN)) {\n\t\t\tiscsit_inc_conn_usage_count(conn);\n\t\t\tspin_unlock_bh(&sess->conn_lock);\n\t\t\treturn conn;\n\t\t}\n\t}\n\tspin_unlock_bh(&sess->conn_lock);\n\n\treturn NULL;\n}\n\nstruct iscsit_conn *iscsit_get_conn_from_cid_rcfr(struct iscsit_session *sess, u16 cid)\n{\n\tstruct iscsit_conn *conn;\n\n\tspin_lock_bh(&sess->conn_lock);\n\tlist_for_each_entry(conn, &sess->sess_conn_list, conn_list) {\n\t\tif (conn->cid == cid) {\n\t\t\tiscsit_inc_conn_usage_count(conn);\n\t\t\tspin_lock(&conn->state_lock);\n\t\t\tatomic_set(&conn->connection_wait_rcfr, 1);\n\t\t\tspin_unlock(&conn->state_lock);\n\t\t\tspin_unlock_bh(&sess->conn_lock);\n\t\t\treturn conn;\n\t\t}\n\t}\n\tspin_unlock_bh(&sess->conn_lock);\n\n\treturn NULL;\n}\n\nvoid iscsit_check_conn_usage_count(struct iscsit_conn *conn)\n{\n\tspin_lock_bh(&conn->conn_usage_lock);\n\tif (conn->conn_usage_count != 0) {\n\t\tconn->conn_waiting_on_uc = 1;\n\t\tspin_unlock_bh(&conn->conn_usage_lock);\n\n\t\twait_for_completion(&conn->conn_waiting_on_uc_comp);\n\t\treturn;\n\t}\n\tspin_unlock_bh(&conn->conn_usage_lock);\n}\n\nvoid iscsit_dec_conn_usage_count(struct iscsit_conn *conn)\n{\n\tspin_lock_bh(&conn->conn_usage_lock);\n\tconn->conn_usage_count--;\n\n\tif (!conn->conn_usage_count && conn->conn_waiting_on_uc)\n\t\tcomplete(&conn->conn_waiting_on_uc_comp);\n\n\tspin_unlock_bh(&conn->conn_usage_lock);\n}\n\nvoid iscsit_inc_conn_usage_count(struct iscsit_conn *conn)\n{\n\tspin_lock_bh(&conn->conn_usage_lock);\n\tconn->conn_usage_count++;\n\tspin_unlock_bh(&conn->conn_usage_lock);\n}\n\nstatic int iscsit_add_nopin(struct iscsit_conn *conn, int want_response)\n{\n\tu8 state;\n\tstruct iscsit_cmd *cmd;\n\n\tcmd = iscsit_allocate_cmd(conn, TASK_RUNNING);\n\tif (!cmd)\n\t\treturn -1;\n\n\tcmd->iscsi_opcode = ISCSI_OP_NOOP_IN;\n\tstate = (want_response) ? ISTATE_SEND_NOPIN_WANT_RESPONSE :\n\t\t\t\tISTATE_SEND_NOPIN_NO_RESPONSE;\n\tcmd->init_task_tag = RESERVED_ITT;\n\tcmd->targ_xfer_tag = (want_response) ?\n\t\t\t     session_get_next_ttt(conn->sess) : 0xFFFFFFFF;\n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\n\tspin_unlock_bh(&conn->cmd_lock);\n\n\tif (want_response)\n\t\tiscsit_start_nopin_response_timer(conn);\n\tiscsit_add_cmd_to_immediate_queue(cmd, conn, state);\n\n\treturn 0;\n}\n\nvoid iscsit_handle_nopin_response_timeout(struct timer_list *t)\n{\n\tstruct iscsit_conn *conn = from_timer(conn, t, nopin_response_timer);\n\tstruct iscsit_session *sess = conn->sess;\n\n\tiscsit_inc_conn_usage_count(conn);\n\n\tspin_lock_bh(&conn->nopin_timer_lock);\n\tif (conn->nopin_response_timer_flags & ISCSI_TF_STOP) {\n\t\tspin_unlock_bh(&conn->nopin_timer_lock);\n\t\tiscsit_dec_conn_usage_count(conn);\n\t\treturn;\n\t}\n\n\tpr_err(\"Did not receive response to NOPIN on CID: %hu, failing\"\n\t\t\" connection for I_T Nexus %s,i,0x%6phN,%s,t,0x%02x\\n\",\n\t\tconn->cid, sess->sess_ops->InitiatorName, sess->isid,\n\t\tsess->tpg->tpg_tiqn->tiqn, (u32)sess->tpg->tpgt);\n\tconn->nopin_response_timer_flags &= ~ISCSI_TF_RUNNING;\n\tspin_unlock_bh(&conn->nopin_timer_lock);\n\n\tiscsit_fill_cxn_timeout_err_stats(sess);\n\tiscsit_cause_connection_reinstatement(conn, 0);\n\tiscsit_dec_conn_usage_count(conn);\n}\n\nvoid iscsit_mod_nopin_response_timer(struct iscsit_conn *conn)\n{\n\tstruct iscsit_session *sess = conn->sess;\n\tstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\n\n\tspin_lock_bh(&conn->nopin_timer_lock);\n\tif (!(conn->nopin_response_timer_flags & ISCSI_TF_RUNNING)) {\n\t\tspin_unlock_bh(&conn->nopin_timer_lock);\n\t\treturn;\n\t}\n\n\tmod_timer(&conn->nopin_response_timer,\n\t\t(get_jiffies_64() + na->nopin_response_timeout * HZ));\n\tspin_unlock_bh(&conn->nopin_timer_lock);\n}\n\nvoid iscsit_start_nopin_response_timer(struct iscsit_conn *conn)\n{\n\tstruct iscsit_session *sess = conn->sess;\n\tstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\n\n\tspin_lock_bh(&conn->nopin_timer_lock);\n\tif (conn->nopin_response_timer_flags & ISCSI_TF_RUNNING) {\n\t\tspin_unlock_bh(&conn->nopin_timer_lock);\n\t\treturn;\n\t}\n\n\tconn->nopin_response_timer_flags &= ~ISCSI_TF_STOP;\n\tconn->nopin_response_timer_flags |= ISCSI_TF_RUNNING;\n\tmod_timer(&conn->nopin_response_timer,\n\t\t  jiffies + na->nopin_response_timeout * HZ);\n\n\tpr_debug(\"Started NOPIN Response Timer on CID: %d to %u\"\n\t\t\" seconds\\n\", conn->cid, na->nopin_response_timeout);\n\tspin_unlock_bh(&conn->nopin_timer_lock);\n}\n\nvoid iscsit_stop_nopin_response_timer(struct iscsit_conn *conn)\n{\n\tspin_lock_bh(&conn->nopin_timer_lock);\n\tif (!(conn->nopin_response_timer_flags & ISCSI_TF_RUNNING)) {\n\t\tspin_unlock_bh(&conn->nopin_timer_lock);\n\t\treturn;\n\t}\n\tconn->nopin_response_timer_flags |= ISCSI_TF_STOP;\n\tspin_unlock_bh(&conn->nopin_timer_lock);\n\n\tdel_timer_sync(&conn->nopin_response_timer);\n\n\tspin_lock_bh(&conn->nopin_timer_lock);\n\tconn->nopin_response_timer_flags &= ~ISCSI_TF_RUNNING;\n\tspin_unlock_bh(&conn->nopin_timer_lock);\n}\n\nvoid iscsit_handle_nopin_timeout(struct timer_list *t)\n{\n\tstruct iscsit_conn *conn = from_timer(conn, t, nopin_timer);\n\n\tiscsit_inc_conn_usage_count(conn);\n\n\tspin_lock_bh(&conn->nopin_timer_lock);\n\tif (conn->nopin_timer_flags & ISCSI_TF_STOP) {\n\t\tspin_unlock_bh(&conn->nopin_timer_lock);\n\t\tiscsit_dec_conn_usage_count(conn);\n\t\treturn;\n\t}\n\tconn->nopin_timer_flags &= ~ISCSI_TF_RUNNING;\n\tspin_unlock_bh(&conn->nopin_timer_lock);\n\n\tiscsit_add_nopin(conn, 1);\n\tiscsit_dec_conn_usage_count(conn);\n}\n\nvoid __iscsit_start_nopin_timer(struct iscsit_conn *conn)\n{\n\tstruct iscsit_session *sess = conn->sess;\n\tstruct iscsi_node_attrib *na = iscsit_tpg_get_node_attrib(sess);\n\n\tlockdep_assert_held(&conn->nopin_timer_lock);\n\n\t \n\tif (!na->nopin_timeout)\n\t\treturn;\n\n\tif (conn->nopin_timer_flags & ISCSI_TF_RUNNING)\n\t\treturn;\n\n\tconn->nopin_timer_flags &= ~ISCSI_TF_STOP;\n\tconn->nopin_timer_flags |= ISCSI_TF_RUNNING;\n\tmod_timer(&conn->nopin_timer, jiffies + na->nopin_timeout * HZ);\n\n\tpr_debug(\"Started NOPIN Timer on CID: %d at %u second\"\n\t\t\" interval\\n\", conn->cid, na->nopin_timeout);\n}\n\nvoid iscsit_start_nopin_timer(struct iscsit_conn *conn)\n{\n\tspin_lock_bh(&conn->nopin_timer_lock);\n\t__iscsit_start_nopin_timer(conn);\n\tspin_unlock_bh(&conn->nopin_timer_lock);\n}\n\nvoid iscsit_stop_nopin_timer(struct iscsit_conn *conn)\n{\n\tspin_lock_bh(&conn->nopin_timer_lock);\n\tif (!(conn->nopin_timer_flags & ISCSI_TF_RUNNING)) {\n\t\tspin_unlock_bh(&conn->nopin_timer_lock);\n\t\treturn;\n\t}\n\tconn->nopin_timer_flags |= ISCSI_TF_STOP;\n\tspin_unlock_bh(&conn->nopin_timer_lock);\n\n\tdel_timer_sync(&conn->nopin_timer);\n\n\tspin_lock_bh(&conn->nopin_timer_lock);\n\tconn->nopin_timer_flags &= ~ISCSI_TF_RUNNING;\n\tspin_unlock_bh(&conn->nopin_timer_lock);\n}\n\nvoid iscsit_login_timeout(struct timer_list *t)\n{\n\tstruct iscsit_conn *conn = from_timer(conn, t, login_timer);\n\tstruct iscsi_login *login = conn->login;\n\n\tpr_debug(\"Entering iscsi_target_login_timeout >>>>>>>>>>>>>>>>>>>\\n\");\n\n\tspin_lock_bh(&conn->login_timer_lock);\n\tlogin->login_failed = 1;\n\n\tif (conn->login_kworker) {\n\t\tpr_debug(\"Sending SIGINT to conn->login_kworker %s/%d\\n\",\n\t\t\t conn->login_kworker->comm, conn->login_kworker->pid);\n\t\tsend_sig(SIGINT, conn->login_kworker, 1);\n\t} else {\n\t\tschedule_delayed_work(&conn->login_work, 0);\n\t}\n\tspin_unlock_bh(&conn->login_timer_lock);\n}\n\nvoid iscsit_start_login_timer(struct iscsit_conn *conn, struct task_struct *kthr)\n{\n\tpr_debug(\"Login timer started\\n\");\n\n\tconn->login_kworker = kthr;\n\tmod_timer(&conn->login_timer, jiffies + TA_LOGIN_TIMEOUT * HZ);\n}\n\nint iscsit_set_login_timer_kworker(struct iscsit_conn *conn, struct task_struct *kthr)\n{\n\tstruct iscsi_login *login = conn->login;\n\tint ret = 0;\n\n\tspin_lock_bh(&conn->login_timer_lock);\n\tif (login->login_failed) {\n\t\t \n\t\tret = -1;\n\t} else {\n\t\tconn->login_kworker = kthr;\n\t}\n\tspin_unlock_bh(&conn->login_timer_lock);\n\n\treturn ret;\n}\n\nvoid iscsit_stop_login_timer(struct iscsit_conn *conn)\n{\n\tpr_debug(\"Login timer stopped\\n\");\n\ttimer_delete_sync(&conn->login_timer);\n}\n\nint iscsit_send_tx_data(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_conn *conn,\n\tint use_misc)\n{\n\tint tx_sent, tx_size;\n\tu32 iov_count;\n\tstruct kvec *iov;\n\nsend_data:\n\ttx_size = cmd->tx_size;\n\n\tif (!use_misc) {\n\t\tiov = &cmd->iov_data[0];\n\t\tiov_count = cmd->iov_data_count;\n\t} else {\n\t\tiov = &cmd->iov_misc[0];\n\t\tiov_count = cmd->iov_misc_count;\n\t}\n\n\ttx_sent = tx_data(conn, &iov[0], iov_count, tx_size);\n\tif (tx_size != tx_sent) {\n\t\tif (tx_sent == -EAGAIN) {\n\t\t\tpr_err(\"tx_data() returned -EAGAIN\\n\");\n\t\t\tgoto send_data;\n\t\t} else\n\t\t\treturn -1;\n\t}\n\tcmd->tx_size = 0;\n\n\treturn 0;\n}\n\nint iscsit_fe_sendpage_sg(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_conn *conn)\n{\n\tstruct scatterlist *sg = cmd->first_data_sg;\n\tstruct bio_vec bvec;\n\tstruct msghdr msghdr = { .msg_flags = MSG_SPLICE_PAGES,\t};\n\tstruct kvec iov;\n\tu32 tx_hdr_size, data_len;\n\tu32 offset = cmd->first_data_sg_off;\n\tint tx_sent, iov_off;\n\nsend_hdr:\n\ttx_hdr_size = ISCSI_HDR_LEN;\n\tif (conn->conn_ops->HeaderDigest)\n\t\ttx_hdr_size += ISCSI_CRC_LEN;\n\n\tiov.iov_base = cmd->pdu;\n\tiov.iov_len = tx_hdr_size;\n\n\ttx_sent = tx_data(conn, &iov, 1, tx_hdr_size);\n\tif (tx_hdr_size != tx_sent) {\n\t\tif (tx_sent == -EAGAIN) {\n\t\t\tpr_err(\"tx_data() returned -EAGAIN\\n\");\n\t\t\tgoto send_hdr;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tdata_len = cmd->tx_size - tx_hdr_size - cmd->padding;\n\t \n\tif (conn->conn_ops->DataDigest) {\n\t\tdata_len -= ISCSI_CRC_LEN;\n\t\tif (cmd->padding)\n\t\t\tiov_off = (cmd->iov_data_count - 2);\n\t\telse\n\t\t\tiov_off = (cmd->iov_data_count - 1);\n\t} else {\n\t\tiov_off = (cmd->iov_data_count - 1);\n\t}\n\t \n\twhile (data_len) {\n\t\tu32 space = (sg->length - offset);\n\t\tu32 sub_len = min_t(u32, data_len, space);\nsend_pg:\n\t\tbvec_set_page(&bvec, sg_page(sg), sub_len, sg->offset + offset);\n\t\tiov_iter_bvec(&msghdr.msg_iter, ITER_SOURCE, &bvec, 1, sub_len);\n\n\t\ttx_sent = conn->sock->ops->sendmsg(conn->sock, &msghdr,\n\t\t\t\t\t\t   sub_len);\n\t\tif (tx_sent != sub_len) {\n\t\t\tif (tx_sent == -EAGAIN) {\n\t\t\t\tpr_err(\"sendmsg/splice returned -EAGAIN\\n\");\n\t\t\t\tgoto send_pg;\n\t\t\t}\n\n\t\t\tpr_err(\"sendmsg/splice failure: %d\\n\", tx_sent);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdata_len -= sub_len;\n\t\toffset = 0;\n\t\tsg = sg_next(sg);\n\t}\n\nsend_padding:\n\tif (cmd->padding) {\n\t\tstruct kvec *iov_p = &cmd->iov_data[iov_off++];\n\n\t\ttx_sent = tx_data(conn, iov_p, 1, cmd->padding);\n\t\tif (cmd->padding != tx_sent) {\n\t\t\tif (tx_sent == -EAGAIN) {\n\t\t\t\tpr_err(\"tx_data() returned -EAGAIN\\n\");\n\t\t\t\tgoto send_padding;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\nsend_datacrc:\n\tif (conn->conn_ops->DataDigest) {\n\t\tstruct kvec *iov_d = &cmd->iov_data[iov_off];\n\n\t\ttx_sent = tx_data(conn, iov_d, 1, ISCSI_CRC_LEN);\n\t\tif (ISCSI_CRC_LEN != tx_sent) {\n\t\t\tif (tx_sent == -EAGAIN) {\n\t\t\t\tpr_err(\"tx_data() returned -EAGAIN\\n\");\n\t\t\t\tgoto send_datacrc;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint iscsit_tx_login_rsp(struct iscsit_conn *conn, u8 status_class, u8 status_detail)\n{\n\tstruct iscsi_login_rsp *hdr;\n\tstruct iscsi_login *login = conn->conn_login;\n\n\tlogin->login_failed = 1;\n\tiscsit_collect_login_stats(conn, status_class, status_detail);\n\n\tmemset(&login->rsp[0], 0, ISCSI_HDR_LEN);\n\n\thdr\t= (struct iscsi_login_rsp *)&login->rsp[0];\n\thdr->opcode\t\t= ISCSI_OP_LOGIN_RSP;\n\thdr->status_class\t= status_class;\n\thdr->status_detail\t= status_detail;\n\thdr->itt\t\t= conn->login_itt;\n\n\treturn conn->conn_transport->iscsit_put_login_tx(conn, login, 0);\n}\n\nvoid iscsit_print_session_params(struct iscsit_session *sess)\n{\n\tstruct iscsit_conn *conn;\n\n\tpr_debug(\"-----------------------------[Session Params for\"\n\t\t\" SID: %u]-----------------------------\\n\", sess->sid);\n\tspin_lock_bh(&sess->conn_lock);\n\tlist_for_each_entry(conn, &sess->sess_conn_list, conn_list)\n\t\tiscsi_dump_conn_ops(conn->conn_ops);\n\tspin_unlock_bh(&sess->conn_lock);\n\n\tiscsi_dump_sess_ops(sess->sess_ops);\n}\n\nint rx_data(\n\tstruct iscsit_conn *conn,\n\tstruct kvec *iov,\n\tint iov_count,\n\tint data)\n{\n\tint rx_loop = 0, total_rx = 0;\n\tstruct msghdr msg;\n\n\tif (!conn || !conn->sock || !conn->conn_ops)\n\t\treturn -1;\n\n\tmemset(&msg, 0, sizeof(struct msghdr));\n\tiov_iter_kvec(&msg.msg_iter, ITER_DEST, iov, iov_count, data);\n\n\twhile (msg_data_left(&msg)) {\n\t\trx_loop = sock_recvmsg(conn->sock, &msg, MSG_WAITALL);\n\t\tif (rx_loop <= 0) {\n\t\t\tpr_debug(\"rx_loop: %d total_rx: %d\\n\",\n\t\t\t\trx_loop, total_rx);\n\t\t\treturn rx_loop;\n\t\t}\n\t\ttotal_rx += rx_loop;\n\t\tpr_debug(\"rx_loop: %d, total_rx: %d, data: %d\\n\",\n\t\t\t\trx_loop, total_rx, data);\n\t}\n\n\treturn total_rx;\n}\n\nint tx_data(\n\tstruct iscsit_conn *conn,\n\tstruct kvec *iov,\n\tint iov_count,\n\tint data)\n{\n\tstruct msghdr msg;\n\tint total_tx = 0;\n\n\tif (!conn || !conn->sock || !conn->conn_ops)\n\t\treturn -1;\n\n\tif (data <= 0) {\n\t\tpr_err(\"Data length is: %d\\n\", data);\n\t\treturn -1;\n\t}\n\n\tmemset(&msg, 0, sizeof(struct msghdr));\n\n\tiov_iter_kvec(&msg.msg_iter, ITER_SOURCE, iov, iov_count, data);\n\n\twhile (msg_data_left(&msg)) {\n\t\tint tx_loop = sock_sendmsg(conn->sock, &msg);\n\t\tif (tx_loop <= 0) {\n\t\t\tpr_debug(\"tx_loop: %d total_tx %d\\n\",\n\t\t\t\ttx_loop, total_tx);\n\t\t\treturn tx_loop;\n\t\t}\n\t\ttotal_tx += tx_loop;\n\t\tpr_debug(\"tx_loop: %d, total_tx: %d, data: %d\\n\",\n\t\t\t\t\ttx_loop, total_tx, data);\n\t}\n\n\treturn total_tx;\n}\n\nvoid iscsit_collect_login_stats(\n\tstruct iscsit_conn *conn,\n\tu8 status_class,\n\tu8 status_detail)\n{\n\tstruct iscsi_param *intrname = NULL;\n\tstruct iscsi_tiqn *tiqn;\n\tstruct iscsi_login_stats *ls;\n\n\ttiqn = iscsit_snmp_get_tiqn(conn);\n\tif (!tiqn)\n\t\treturn;\n\n\tls = &tiqn->login_stats;\n\n\tspin_lock(&ls->lock);\n\tif (status_class == ISCSI_STATUS_CLS_SUCCESS)\n\t\tls->accepts++;\n\telse if (status_class == ISCSI_STATUS_CLS_REDIRECT) {\n\t\tls->redirects++;\n\t\tls->last_fail_type = ISCSI_LOGIN_FAIL_REDIRECT;\n\t} else if ((status_class == ISCSI_STATUS_CLS_INITIATOR_ERR)  &&\n\t\t (status_detail == ISCSI_LOGIN_STATUS_AUTH_FAILED)) {\n\t\tls->authenticate_fails++;\n\t\tls->last_fail_type =  ISCSI_LOGIN_FAIL_AUTHENTICATE;\n\t} else if ((status_class == ISCSI_STATUS_CLS_INITIATOR_ERR)  &&\n\t\t (status_detail == ISCSI_LOGIN_STATUS_TGT_FORBIDDEN)) {\n\t\tls->authorize_fails++;\n\t\tls->last_fail_type = ISCSI_LOGIN_FAIL_AUTHORIZE;\n\t} else if ((status_class == ISCSI_STATUS_CLS_INITIATOR_ERR) &&\n\t\t (status_detail == ISCSI_LOGIN_STATUS_INIT_ERR)) {\n\t\tls->negotiate_fails++;\n\t\tls->last_fail_type = ISCSI_LOGIN_FAIL_NEGOTIATE;\n\t} else {\n\t\tls->other_fails++;\n\t\tls->last_fail_type = ISCSI_LOGIN_FAIL_OTHER;\n\t}\n\n\t \n\tif (status_class != ISCSI_STATUS_CLS_SUCCESS) {\n\t\tif (conn->param_list)\n\t\t\tintrname = iscsi_find_param_from_key(INITIATORNAME,\n\t\t\t\t\t\t\t     conn->param_list);\n\t\tstrscpy(ls->last_intr_fail_name,\n\t\t       (intrname ? intrname->value : \"Unknown\"),\n\t\t       sizeof(ls->last_intr_fail_name));\n\n\t\tls->last_intr_fail_ip_family = conn->login_family;\n\n\t\tls->last_intr_fail_sockaddr = conn->login_sockaddr;\n\t\tls->last_fail_time = get_jiffies_64();\n\t}\n\n\tspin_unlock(&ls->lock);\n}\n\nstruct iscsi_tiqn *iscsit_snmp_get_tiqn(struct iscsit_conn *conn)\n{\n\tstruct iscsi_portal_group *tpg;\n\n\tif (!conn)\n\t\treturn NULL;\n\n\ttpg = conn->tpg;\n\tif (!tpg)\n\t\treturn NULL;\n\n\tif (!tpg->tpg_tiqn)\n\t\treturn NULL;\n\n\treturn tpg->tpg_tiqn;\n}\n\nvoid iscsit_fill_cxn_timeout_err_stats(struct iscsit_session *sess)\n{\n\tstruct iscsi_portal_group *tpg = sess->tpg;\n\tstruct iscsi_tiqn *tiqn = tpg->tpg_tiqn;\n\n\tif (!tiqn)\n\t\treturn;\n\n\tspin_lock_bh(&tiqn->sess_err_stats.lock);\n\tstrscpy(tiqn->sess_err_stats.last_sess_fail_rem_name,\n\t\t\tsess->sess_ops->InitiatorName,\n\t\t\tsizeof(tiqn->sess_err_stats.last_sess_fail_rem_name));\n\ttiqn->sess_err_stats.last_sess_failure_type =\n\t\t\tISCSI_SESS_ERR_CXN_TIMEOUT;\n\ttiqn->sess_err_stats.cxn_timeout_errors++;\n\tatomic_long_inc(&sess->conn_timeout_errors);\n\tspin_unlock_bh(&tiqn->sess_err_stats.lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}