{
  "module_name": "iscsi_target.c",
  "hash_id": "8005c099db012ac41202d678c52a31ce9c832fa744340d5e9af15bad1911ceed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <linux/string.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/idr.h>\n#include <linux/delay.h>\n#include <linux/sched/signal.h>\n#include <asm/unaligned.h>\n#include <linux/inet.h>\n#include <net/ipv6.h>\n#include <scsi/scsi_proto.h>\n#include <scsi/iscsi_proto.h>\n#include <scsi/scsi_tcq.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include <target/target_core_backend.h>\n#include <target/iscsi/iscsi_target_core.h>\n#include \"iscsi_target_parameters.h\"\n#include \"iscsi_target_seq_pdu_list.h\"\n#include \"iscsi_target_datain_values.h\"\n#include \"iscsi_target_erl0.h\"\n#include \"iscsi_target_erl1.h\"\n#include \"iscsi_target_erl2.h\"\n#include \"iscsi_target_login.h\"\n#include \"iscsi_target_tmr.h\"\n#include \"iscsi_target_tpg.h\"\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target.h\"\n#include \"iscsi_target_device.h\"\n#include <target/iscsi/iscsi_target_stat.h>\n\n#include <target/iscsi/iscsi_transport.h>\n\nstatic LIST_HEAD(g_tiqn_list);\nstatic LIST_HEAD(g_np_list);\nstatic DEFINE_SPINLOCK(tiqn_lock);\nstatic DEFINE_MUTEX(np_lock);\n\nstatic struct idr tiqn_idr;\nDEFINE_IDA(sess_ida);\nstruct mutex auth_id_lock;\n\nstruct iscsit_global *iscsit_global;\n\nstruct kmem_cache *lio_qr_cache;\nstruct kmem_cache *lio_dr_cache;\nstruct kmem_cache *lio_ooo_cache;\nstruct kmem_cache *lio_r2t_cache;\n\nstatic int iscsit_handle_immediate_data(struct iscsit_cmd *,\n\t\t\tstruct iscsi_scsi_req *, u32);\n\nstruct iscsi_tiqn *iscsit_get_tiqn_for_login(unsigned char *buf)\n{\n\tstruct iscsi_tiqn *tiqn = NULL;\n\n\tspin_lock(&tiqn_lock);\n\tlist_for_each_entry(tiqn, &g_tiqn_list, tiqn_list) {\n\t\tif (!strcmp(tiqn->tiqn, buf)) {\n\n\t\t\tspin_lock(&tiqn->tiqn_state_lock);\n\t\t\tif (tiqn->tiqn_state == TIQN_STATE_ACTIVE) {\n\t\t\t\ttiqn->tiqn_access_count++;\n\t\t\t\tspin_unlock(&tiqn->tiqn_state_lock);\n\t\t\t\tspin_unlock(&tiqn_lock);\n\t\t\t\treturn tiqn;\n\t\t\t}\n\t\t\tspin_unlock(&tiqn->tiqn_state_lock);\n\t\t}\n\t}\n\tspin_unlock(&tiqn_lock);\n\n\treturn NULL;\n}\n\nstatic int iscsit_set_tiqn_shutdown(struct iscsi_tiqn *tiqn)\n{\n\tspin_lock(&tiqn->tiqn_state_lock);\n\tif (tiqn->tiqn_state == TIQN_STATE_ACTIVE) {\n\t\ttiqn->tiqn_state = TIQN_STATE_SHUTDOWN;\n\t\tspin_unlock(&tiqn->tiqn_state_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&tiqn->tiqn_state_lock);\n\n\treturn -1;\n}\n\nvoid iscsit_put_tiqn_for_login(struct iscsi_tiqn *tiqn)\n{\n\tspin_lock(&tiqn->tiqn_state_lock);\n\ttiqn->tiqn_access_count--;\n\tspin_unlock(&tiqn->tiqn_state_lock);\n}\n\n \nstruct iscsi_tiqn *iscsit_add_tiqn(unsigned char *buf)\n{\n\tstruct iscsi_tiqn *tiqn = NULL;\n\tint ret;\n\n\tif (strlen(buf) >= ISCSI_IQN_LEN) {\n\t\tpr_err(\"Target IQN exceeds %d bytes\\n\",\n\t\t\t\tISCSI_IQN_LEN);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\ttiqn = kzalloc(sizeof(*tiqn), GFP_KERNEL);\n\tif (!tiqn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsprintf(tiqn->tiqn, \"%s\", buf);\n\tINIT_LIST_HEAD(&tiqn->tiqn_list);\n\tINIT_LIST_HEAD(&tiqn->tiqn_tpg_list);\n\tspin_lock_init(&tiqn->tiqn_state_lock);\n\tspin_lock_init(&tiqn->tiqn_tpg_lock);\n\tspin_lock_init(&tiqn->sess_err_stats.lock);\n\tspin_lock_init(&tiqn->login_stats.lock);\n\tspin_lock_init(&tiqn->logout_stats.lock);\n\n\ttiqn->tiqn_state = TIQN_STATE_ACTIVE;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&tiqn_lock);\n\n\tret = idr_alloc(&tiqn_idr, NULL, 0, 0, GFP_NOWAIT);\n\tif (ret < 0) {\n\t\tpr_err(\"idr_alloc() failed for tiqn->tiqn_index\\n\");\n\t\tspin_unlock(&tiqn_lock);\n\t\tidr_preload_end();\n\t\tkfree(tiqn);\n\t\treturn ERR_PTR(ret);\n\t}\n\ttiqn->tiqn_index = ret;\n\tlist_add_tail(&tiqn->tiqn_list, &g_tiqn_list);\n\n\tspin_unlock(&tiqn_lock);\n\tidr_preload_end();\n\n\tpr_debug(\"CORE[0] - Added iSCSI Target IQN: %s\\n\", tiqn->tiqn);\n\n\treturn tiqn;\n\n}\n\nstatic void iscsit_wait_for_tiqn(struct iscsi_tiqn *tiqn)\n{\n\t \n\tspin_lock(&tiqn->tiqn_state_lock);\n\twhile (tiqn->tiqn_access_count != 0) {\n\t\tspin_unlock(&tiqn->tiqn_state_lock);\n\t\tmsleep(10);\n\t\tspin_lock(&tiqn->tiqn_state_lock);\n\t}\n\tspin_unlock(&tiqn->tiqn_state_lock);\n}\n\nvoid iscsit_del_tiqn(struct iscsi_tiqn *tiqn)\n{\n\t \n\tif (iscsit_set_tiqn_shutdown(tiqn) < 0) {\n\t\tpr_err(\"iscsit_set_tiqn_shutdown() failed\\n\");\n\t\treturn;\n\t}\n\n\tiscsit_wait_for_tiqn(tiqn);\n\n\tspin_lock(&tiqn_lock);\n\tlist_del(&tiqn->tiqn_list);\n\tidr_remove(&tiqn_idr, tiqn->tiqn_index);\n\tspin_unlock(&tiqn_lock);\n\n\tpr_debug(\"CORE[0] - Deleted iSCSI Target IQN: %s\\n\",\n\t\t\ttiqn->tiqn);\n\tkfree(tiqn);\n}\n\nint iscsit_access_np(struct iscsi_np *np, struct iscsi_portal_group *tpg)\n{\n\tint ret;\n\t \n\tspin_lock_bh(&np->np_thread_lock);\n\tif (np->np_thread_state != ISCSI_NP_THREAD_ACTIVE) {\n\t\tspin_unlock_bh(&np->np_thread_lock);\n\t\treturn -1;\n\t}\n\tspin_unlock_bh(&np->np_thread_lock);\n\t \n\tspin_lock_bh(&tpg->tpg_state_lock);\n\tif (tpg->tpg_state != TPG_STATE_ACTIVE) {\n\t\tspin_unlock_bh(&tpg->tpg_state_lock);\n\t\treturn -1;\n\t}\n\tspin_unlock_bh(&tpg->tpg_state_lock);\n\n\t \n\tret = down_interruptible(&tpg->np_login_sem);\n\tif (ret != 0)\n\t\treturn -1;\n\n\tspin_lock_bh(&tpg->tpg_state_lock);\n\tif (tpg->tpg_state != TPG_STATE_ACTIVE) {\n\t\tspin_unlock_bh(&tpg->tpg_state_lock);\n\t\tup(&tpg->np_login_sem);\n\t\treturn -1;\n\t}\n\tspin_unlock_bh(&tpg->tpg_state_lock);\n\n\treturn 0;\n}\n\nvoid iscsit_login_kref_put(struct kref *kref)\n{\n\tstruct iscsi_tpg_np *tpg_np = container_of(kref,\n\t\t\t\tstruct iscsi_tpg_np, tpg_np_kref);\n\n\tcomplete(&tpg_np->tpg_np_comp);\n}\n\nint iscsit_deaccess_np(struct iscsi_np *np, struct iscsi_portal_group *tpg,\n\t\t       struct iscsi_tpg_np *tpg_np)\n{\n\tstruct iscsi_tiqn *tiqn = tpg->tpg_tiqn;\n\n\tup(&tpg->np_login_sem);\n\n\tif (tpg_np)\n\t\tkref_put(&tpg_np->tpg_np_kref, iscsit_login_kref_put);\n\n\tif (tiqn)\n\t\tiscsit_put_tiqn_for_login(tiqn);\n\n\treturn 0;\n}\n\nbool iscsit_check_np_match(\n\tstruct sockaddr_storage *sockaddr,\n\tstruct iscsi_np *np,\n\tint network_transport)\n{\n\tstruct sockaddr_in *sock_in, *sock_in_e;\n\tstruct sockaddr_in6 *sock_in6, *sock_in6_e;\n\tbool ip_match = false;\n\tu16 port, port_e;\n\n\tif (sockaddr->ss_family == AF_INET6) {\n\t\tsock_in6 = (struct sockaddr_in6 *)sockaddr;\n\t\tsock_in6_e = (struct sockaddr_in6 *)&np->np_sockaddr;\n\n\t\tif (!memcmp(&sock_in6->sin6_addr.in6_u,\n\t\t\t    &sock_in6_e->sin6_addr.in6_u,\n\t\t\t    sizeof(struct in6_addr)))\n\t\t\tip_match = true;\n\n\t\tport = ntohs(sock_in6->sin6_port);\n\t\tport_e = ntohs(sock_in6_e->sin6_port);\n\t} else {\n\t\tsock_in = (struct sockaddr_in *)sockaddr;\n\t\tsock_in_e = (struct sockaddr_in *)&np->np_sockaddr;\n\n\t\tif (sock_in->sin_addr.s_addr == sock_in_e->sin_addr.s_addr)\n\t\t\tip_match = true;\n\n\t\tport = ntohs(sock_in->sin_port);\n\t\tport_e = ntohs(sock_in_e->sin_port);\n\t}\n\n\tif (ip_match && (port_e == port) &&\n\t    (np->np_network_transport == network_transport))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct iscsi_np *iscsit_get_np(\n\tstruct sockaddr_storage *sockaddr,\n\tint network_transport)\n{\n\tstruct iscsi_np *np;\n\tbool match;\n\n\tlockdep_assert_held(&np_lock);\n\n\tlist_for_each_entry(np, &g_np_list, np_list) {\n\t\tspin_lock_bh(&np->np_thread_lock);\n\t\tif (np->np_thread_state != ISCSI_NP_THREAD_ACTIVE) {\n\t\t\tspin_unlock_bh(&np->np_thread_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch = iscsit_check_np_match(sockaddr, np, network_transport);\n\t\tif (match) {\n\t\t\t \n\t\t\tnp->np_exports++;\n\t\t\tspin_unlock_bh(&np->np_thread_lock);\n\t\t\treturn np;\n\t\t}\n\t\tspin_unlock_bh(&np->np_thread_lock);\n\t}\n\n\treturn NULL;\n}\n\nstruct iscsi_np *iscsit_add_np(\n\tstruct sockaddr_storage *sockaddr,\n\tint network_transport)\n{\n\tstruct iscsi_np *np;\n\tint ret;\n\n\tmutex_lock(&np_lock);\n\n\t \n\tnp = iscsit_get_np(sockaddr, network_transport);\n\tif (np) {\n\t\tmutex_unlock(&np_lock);\n\t\treturn np;\n\t}\n\n\tnp = kzalloc(sizeof(*np), GFP_KERNEL);\n\tif (!np) {\n\t\tmutex_unlock(&np_lock);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tnp->np_flags |= NPF_IP_NETWORK;\n\tnp->np_network_transport = network_transport;\n\tspin_lock_init(&np->np_thread_lock);\n\tinit_completion(&np->np_restart_comp);\n\tINIT_LIST_HEAD(&np->np_list);\n\n\tret = iscsi_target_setup_login_socket(np, sockaddr);\n\tif (ret != 0) {\n\t\tkfree(np);\n\t\tmutex_unlock(&np_lock);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tnp->np_thread = kthread_run(iscsi_target_login_thread, np, \"iscsi_np\");\n\tif (IS_ERR(np->np_thread)) {\n\t\tpr_err(\"Unable to create kthread: iscsi_np\\n\");\n\t\tret = PTR_ERR(np->np_thread);\n\t\tkfree(np);\n\t\tmutex_unlock(&np_lock);\n\t\treturn ERR_PTR(ret);\n\t}\n\t \n\tnp->np_exports = 1;\n\tnp->np_thread_state = ISCSI_NP_THREAD_ACTIVE;\n\n\tlist_add_tail(&np->np_list, &g_np_list);\n\tmutex_unlock(&np_lock);\n\n\tpr_debug(\"CORE[0] - Added Network Portal: %pISpc on %s\\n\",\n\t\t&np->np_sockaddr, np->np_transport->name);\n\n\treturn np;\n}\n\nint iscsit_reset_np_thread(\n\tstruct iscsi_np *np,\n\tstruct iscsi_tpg_np *tpg_np,\n\tstruct iscsi_portal_group *tpg,\n\tbool shutdown)\n{\n\tspin_lock_bh(&np->np_thread_lock);\n\tif (np->np_thread_state == ISCSI_NP_THREAD_INACTIVE) {\n\t\tspin_unlock_bh(&np->np_thread_lock);\n\t\treturn 0;\n\t}\n\tnp->np_thread_state = ISCSI_NP_THREAD_RESET;\n\tatomic_inc(&np->np_reset_count);\n\n\tif (np->np_thread) {\n\t\tspin_unlock_bh(&np->np_thread_lock);\n\t\tsend_sig(SIGINT, np->np_thread, 1);\n\t\twait_for_completion(&np->np_restart_comp);\n\t\tspin_lock_bh(&np->np_thread_lock);\n\t}\n\tspin_unlock_bh(&np->np_thread_lock);\n\n\tif (tpg_np && shutdown) {\n\t\tkref_put(&tpg_np->tpg_np_kref, iscsit_login_kref_put);\n\n\t\twait_for_completion(&tpg_np->tpg_np_comp);\n\t}\n\n\treturn 0;\n}\n\nstatic void iscsit_free_np(struct iscsi_np *np)\n{\n\tif (np->np_socket)\n\t\tsock_release(np->np_socket);\n}\n\nint iscsit_del_np(struct iscsi_np *np)\n{\n\tspin_lock_bh(&np->np_thread_lock);\n\tnp->np_exports--;\n\tif (np->np_exports) {\n\t\tnp->enabled = true;\n\t\tspin_unlock_bh(&np->np_thread_lock);\n\t\treturn 0;\n\t}\n\tnp->np_thread_state = ISCSI_NP_THREAD_SHUTDOWN;\n\tspin_unlock_bh(&np->np_thread_lock);\n\n\tif (np->np_thread) {\n\t\t \n\t\tsend_sig(SIGINT, np->np_thread, 1);\n\t\tkthread_stop(np->np_thread);\n\t\tnp->np_thread = NULL;\n\t}\n\n\tnp->np_transport->iscsit_free_np(np);\n\n\tmutex_lock(&np_lock);\n\tlist_del(&np->np_list);\n\tmutex_unlock(&np_lock);\n\n\tpr_debug(\"CORE[0] - Removed Network Portal: %pISpc on %s\\n\",\n\t\t&np->np_sockaddr, np->np_transport->name);\n\n\tiscsit_put_transport(np->np_transport);\n\tkfree(np);\n\treturn 0;\n}\n\nstatic void iscsit_get_rx_pdu(struct iscsit_conn *);\n\nint iscsit_queue_rsp(struct iscsit_conn *conn, struct iscsit_cmd *cmd)\n{\n\treturn iscsit_add_cmd_to_response_queue(cmd, cmd->conn, cmd->i_state);\n}\nEXPORT_SYMBOL(iscsit_queue_rsp);\n\nvoid iscsit_aborted_task(struct iscsit_conn *conn, struct iscsit_cmd *cmd)\n{\n\tspin_lock_bh(&conn->cmd_lock);\n\tif (!list_empty(&cmd->i_conn_node))\n\t\tlist_del_init(&cmd->i_conn_node);\n\tspin_unlock_bh(&conn->cmd_lock);\n\n\t__iscsit_free_cmd(cmd, true);\n}\nEXPORT_SYMBOL(iscsit_aborted_task);\n\nstatic void iscsit_do_crypto_hash_buf(struct ahash_request *, const void *,\n\t\t\t\t      u32, u32, const void *, void *);\nstatic void iscsit_tx_thread_wait_for_tcp(struct iscsit_conn *);\n\nstatic int\niscsit_xmit_nondatain_pdu(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t\t  const void *data_buf, u32 data_buf_len)\n{\n\tstruct iscsi_hdr *hdr = (struct iscsi_hdr *)cmd->pdu;\n\tstruct kvec *iov;\n\tu32 niov = 0, tx_size = ISCSI_HDR_LEN;\n\tint ret;\n\n\tiov = &cmd->iov_misc[0];\n\tiov[niov].iov_base\t= cmd->pdu;\n\tiov[niov++].iov_len\t= ISCSI_HDR_LEN;\n\n\tif (conn->conn_ops->HeaderDigest) {\n\t\tu32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];\n\n\t\tiscsit_do_crypto_hash_buf(conn->conn_tx_hash, hdr,\n\t\t\t\t\t  ISCSI_HDR_LEN, 0, NULL,\n\t\t\t\t\t  header_digest);\n\n\t\tiov[0].iov_len += ISCSI_CRC_LEN;\n\t\ttx_size += ISCSI_CRC_LEN;\n\t\tpr_debug(\"Attaching CRC32C HeaderDigest\"\n\t\t\t \" to opcode 0x%x 0x%08x\\n\",\n\t\t\t hdr->opcode, *header_digest);\n\t}\n\n\tif (data_buf_len) {\n\t\tu32 padding = ((-data_buf_len) & 3);\n\n\t\tiov[niov].iov_base\t= (void *)data_buf;\n\t\tiov[niov++].iov_len\t= data_buf_len;\n\t\ttx_size += data_buf_len;\n\n\t\tif (padding != 0) {\n\t\t\tiov[niov].iov_base = &cmd->pad_bytes;\n\t\t\tiov[niov++].iov_len = padding;\n\t\t\ttx_size += padding;\n\t\t\tpr_debug(\"Attaching %u additional\"\n\t\t\t\t \" padding bytes.\\n\", padding);\n\t\t}\n\n\t\tif (conn->conn_ops->DataDigest) {\n\t\t\tiscsit_do_crypto_hash_buf(conn->conn_tx_hash,\n\t\t\t\t\t\t  data_buf, data_buf_len,\n\t\t\t\t\t\t  padding, &cmd->pad_bytes,\n\t\t\t\t\t\t  &cmd->data_crc);\n\n\t\t\tiov[niov].iov_base = &cmd->data_crc;\n\t\t\tiov[niov++].iov_len = ISCSI_CRC_LEN;\n\t\t\ttx_size += ISCSI_CRC_LEN;\n\t\t\tpr_debug(\"Attached DataDigest for %u\"\n\t\t\t\t \" bytes opcode 0x%x, CRC 0x%08x\\n\",\n\t\t\t\t data_buf_len, hdr->opcode, cmd->data_crc);\n\t\t}\n\t}\n\n\tcmd->iov_misc_count = niov;\n\tcmd->tx_size = tx_size;\n\n\tret = iscsit_send_tx_data(cmd, conn, 1);\n\tif (ret < 0) {\n\t\tiscsit_tx_thread_wait_for_tcp(conn);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsit_map_iovec(struct iscsit_cmd *cmd, struct kvec *iov, int nvec,\n\t\t\t    u32 data_offset, u32 data_length);\nstatic void iscsit_unmap_iovec(struct iscsit_cmd *);\nstatic u32 iscsit_do_crypto_hash_sg(struct ahash_request *, struct iscsit_cmd *,\n\t\t\t\t    u32, u32, u32, u8 *);\nstatic int\niscsit_xmit_datain_pdu(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t       const struct iscsi_datain *datain)\n{\n\tstruct kvec *iov;\n\tu32 iov_count = 0, tx_size = 0;\n\tint ret, iov_ret;\n\n\tiov = &cmd->iov_data[0];\n\tiov[iov_count].iov_base\t= cmd->pdu;\n\tiov[iov_count++].iov_len = ISCSI_HDR_LEN;\n\ttx_size += ISCSI_HDR_LEN;\n\n\tif (conn->conn_ops->HeaderDigest) {\n\t\tu32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];\n\n\t\tiscsit_do_crypto_hash_buf(conn->conn_tx_hash, cmd->pdu,\n\t\t\t\t\t  ISCSI_HDR_LEN, 0, NULL,\n\t\t\t\t\t  header_digest);\n\n\t\tiov[0].iov_len += ISCSI_CRC_LEN;\n\t\ttx_size += ISCSI_CRC_LEN;\n\n\t\tpr_debug(\"Attaching CRC32 HeaderDigest for DataIN PDU 0x%08x\\n\",\n\t\t\t *header_digest);\n\t}\n\n\tiov_ret = iscsit_map_iovec(cmd, &cmd->iov_data[iov_count],\n\t\t\t\t   cmd->orig_iov_data_count - (iov_count + 2),\n\t\t\t\t   datain->offset, datain->length);\n\tif (iov_ret < 0)\n\t\treturn -1;\n\n\tiov_count += iov_ret;\n\ttx_size += datain->length;\n\n\tcmd->padding = ((-datain->length) & 3);\n\tif (cmd->padding) {\n\t\tiov[iov_count].iov_base\t\t= cmd->pad_bytes;\n\t\tiov[iov_count++].iov_len\t= cmd->padding;\n\t\ttx_size += cmd->padding;\n\n\t\tpr_debug(\"Attaching %u padding bytes\\n\", cmd->padding);\n\t}\n\n\tif (conn->conn_ops->DataDigest) {\n\t\tcmd->data_crc = iscsit_do_crypto_hash_sg(conn->conn_tx_hash,\n\t\t\t\t\t\t\t cmd, datain->offset,\n\t\t\t\t\t\t\t datain->length,\n\t\t\t\t\t\t\t cmd->padding,\n\t\t\t\t\t\t\t cmd->pad_bytes);\n\n\t\tiov[iov_count].iov_base\t= &cmd->data_crc;\n\t\tiov[iov_count++].iov_len = ISCSI_CRC_LEN;\n\t\ttx_size += ISCSI_CRC_LEN;\n\n\t\tpr_debug(\"Attached CRC32C DataDigest %d bytes, crc 0x%08x\\n\",\n\t\t\t datain->length + cmd->padding, cmd->data_crc);\n\t}\n\n\tcmd->iov_data_count = iov_count;\n\tcmd->tx_size = tx_size;\n\n\tret = iscsit_fe_sendpage_sg(cmd, conn);\n\n\tiscsit_unmap_iovec(cmd);\n\n\tif (ret < 0) {\n\t\tiscsit_tx_thread_wait_for_tcp(conn);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int iscsit_xmit_pdu(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t\t   struct iscsi_datain_req *dr, const void *buf,\n\t\t\t   u32 buf_len)\n{\n\tif (dr)\n\t\treturn iscsit_xmit_datain_pdu(conn, cmd, buf);\n\telse\n\t\treturn iscsit_xmit_nondatain_pdu(conn, cmd, buf, buf_len);\n}\n\nstatic enum target_prot_op iscsit_get_sup_prot_ops(struct iscsit_conn *conn)\n{\n\treturn TARGET_PROT_NORMAL;\n}\n\nstatic struct iscsit_transport iscsi_target_transport = {\n\t.name\t\t\t= \"iSCSI/TCP\",\n\t.transport_type\t\t= ISCSI_TCP,\n\t.rdma_shutdown\t\t= false,\n\t.owner\t\t\t= NULL,\n\t.iscsit_setup_np\t= iscsit_setup_np,\n\t.iscsit_accept_np\t= iscsit_accept_np,\n\t.iscsit_free_np\t\t= iscsit_free_np,\n\t.iscsit_get_login_rx\t= iscsit_get_login_rx,\n\t.iscsit_put_login_tx\t= iscsit_put_login_tx,\n\t.iscsit_get_dataout\t= iscsit_build_r2ts_for_cmd,\n\t.iscsit_immediate_queue\t= iscsit_immediate_queue,\n\t.iscsit_response_queue\t= iscsit_response_queue,\n\t.iscsit_queue_data_in\t= iscsit_queue_rsp,\n\t.iscsit_queue_status\t= iscsit_queue_rsp,\n\t.iscsit_aborted_task\t= iscsit_aborted_task,\n\t.iscsit_xmit_pdu\t= iscsit_xmit_pdu,\n\t.iscsit_get_rx_pdu\t= iscsit_get_rx_pdu,\n\t.iscsit_get_sup_prot_ops = iscsit_get_sup_prot_ops,\n};\n\nstatic int __init iscsi_target_init_module(void)\n{\n\tint ret = 0, size;\n\n\tpr_debug(\"iSCSI-Target \"ISCSIT_VERSION\"\\n\");\n\tiscsit_global = kzalloc(sizeof(*iscsit_global), GFP_KERNEL);\n\tif (!iscsit_global)\n\t\treturn -1;\n\n\tspin_lock_init(&iscsit_global->ts_bitmap_lock);\n\tmutex_init(&auth_id_lock);\n\tidr_init(&tiqn_idr);\n\n\tret = target_register_template(&iscsi_ops);\n\tif (ret)\n\t\tgoto out;\n\n\tsize = BITS_TO_LONGS(ISCSIT_BITMAP_BITS) * sizeof(long);\n\tiscsit_global->ts_bitmap = vzalloc(size);\n\tif (!iscsit_global->ts_bitmap)\n\t\tgoto configfs_out;\n\n\tif (!zalloc_cpumask_var(&iscsit_global->allowed_cpumask, GFP_KERNEL)) {\n\t\tpr_err(\"Unable to allocate iscsit_global->allowed_cpumask\\n\");\n\t\tgoto bitmap_out;\n\t}\n\tcpumask_setall(iscsit_global->allowed_cpumask);\n\n\tlio_qr_cache = kmem_cache_create(\"lio_qr_cache\",\n\t\t\tsizeof(struct iscsi_queue_req),\n\t\t\t__alignof__(struct iscsi_queue_req), 0, NULL);\n\tif (!lio_qr_cache) {\n\t\tpr_err(\"Unable to kmem_cache_create() for\"\n\t\t\t\t\" lio_qr_cache\\n\");\n\t\tgoto cpumask_out;\n\t}\n\n\tlio_dr_cache = kmem_cache_create(\"lio_dr_cache\",\n\t\t\tsizeof(struct iscsi_datain_req),\n\t\t\t__alignof__(struct iscsi_datain_req), 0, NULL);\n\tif (!lio_dr_cache) {\n\t\tpr_err(\"Unable to kmem_cache_create() for\"\n\t\t\t\t\" lio_dr_cache\\n\");\n\t\tgoto qr_out;\n\t}\n\n\tlio_ooo_cache = kmem_cache_create(\"lio_ooo_cache\",\n\t\t\tsizeof(struct iscsi_ooo_cmdsn),\n\t\t\t__alignof__(struct iscsi_ooo_cmdsn), 0, NULL);\n\tif (!lio_ooo_cache) {\n\t\tpr_err(\"Unable to kmem_cache_create() for\"\n\t\t\t\t\" lio_ooo_cache\\n\");\n\t\tgoto dr_out;\n\t}\n\n\tlio_r2t_cache = kmem_cache_create(\"lio_r2t_cache\",\n\t\t\tsizeof(struct iscsi_r2t), __alignof__(struct iscsi_r2t),\n\t\t\t0, NULL);\n\tif (!lio_r2t_cache) {\n\t\tpr_err(\"Unable to kmem_cache_create() for\"\n\t\t\t\t\" lio_r2t_cache\\n\");\n\t\tgoto ooo_out;\n\t}\n\n\tiscsit_register_transport(&iscsi_target_transport);\n\n\tif (iscsit_load_discovery_tpg() < 0)\n\t\tgoto r2t_out;\n\n\treturn ret;\nr2t_out:\n\tiscsit_unregister_transport(&iscsi_target_transport);\n\tkmem_cache_destroy(lio_r2t_cache);\nooo_out:\n\tkmem_cache_destroy(lio_ooo_cache);\ndr_out:\n\tkmem_cache_destroy(lio_dr_cache);\nqr_out:\n\tkmem_cache_destroy(lio_qr_cache);\ncpumask_out:\n\tfree_cpumask_var(iscsit_global->allowed_cpumask);\nbitmap_out:\n\tvfree(iscsit_global->ts_bitmap);\nconfigfs_out:\n\t \n\tif (iscsit_global->discovery_tpg)\n\t\tiscsit_tpg_disable_portal_group(iscsit_global->discovery_tpg, 1);\n\ttarget_unregister_template(&iscsi_ops);\nout:\n\tkfree(iscsit_global);\n\treturn -ENOMEM;\n}\n\nstatic void __exit iscsi_target_cleanup_module(void)\n{\n\tiscsit_release_discovery_tpg();\n\tiscsit_unregister_transport(&iscsi_target_transport);\n\tkmem_cache_destroy(lio_qr_cache);\n\tkmem_cache_destroy(lio_dr_cache);\n\tkmem_cache_destroy(lio_ooo_cache);\n\tkmem_cache_destroy(lio_r2t_cache);\n\n\t \n\tif (iscsit_global->discovery_tpg)\n\t\tiscsit_tpg_disable_portal_group(iscsit_global->discovery_tpg, 1);\n\n\ttarget_unregister_template(&iscsi_ops);\n\n\tfree_cpumask_var(iscsit_global->allowed_cpumask);\n\tvfree(iscsit_global->ts_bitmap);\n\tkfree(iscsit_global);\n}\n\nint iscsit_add_reject(\n\tstruct iscsit_conn *conn,\n\tu8 reason,\n\tunsigned char *buf)\n{\n\tstruct iscsit_cmd *cmd;\n\n\tcmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\n\tif (!cmd)\n\t\treturn -1;\n\n\tcmd->iscsi_opcode = ISCSI_OP_REJECT;\n\tcmd->reject_reason = reason;\n\n\tcmd->buf_ptr = kmemdup(buf, ISCSI_HDR_LEN, GFP_KERNEL);\n\tif (!cmd->buf_ptr) {\n\t\tpr_err(\"Unable to allocate memory for cmd->buf_ptr\\n\");\n\t\tiscsit_free_cmd(cmd, false);\n\t\treturn -1;\n\t}\n\n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\n\tspin_unlock_bh(&conn->cmd_lock);\n\n\tcmd->i_state = ISTATE_SEND_REJECT;\n\tiscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\n\n\treturn -1;\n}\nEXPORT_SYMBOL(iscsit_add_reject);\n\nstatic int iscsit_add_reject_from_cmd(\n\tstruct iscsit_cmd *cmd,\n\tu8 reason,\n\tbool add_to_conn,\n\tunsigned char *buf)\n{\n\tstruct iscsit_conn *conn;\n\tconst bool do_put = cmd->se_cmd.se_tfo != NULL;\n\n\tif (!cmd->conn) {\n\t\tpr_err(\"cmd->conn is NULL for ITT: 0x%08x\\n\",\n\t\t\t\tcmd->init_task_tag);\n\t\treturn -1;\n\t}\n\tconn = cmd->conn;\n\n\tcmd->iscsi_opcode = ISCSI_OP_REJECT;\n\tcmd->reject_reason = reason;\n\n\tcmd->buf_ptr = kmemdup(buf, ISCSI_HDR_LEN, GFP_KERNEL);\n\tif (!cmd->buf_ptr) {\n\t\tpr_err(\"Unable to allocate memory for cmd->buf_ptr\\n\");\n\t\tiscsit_free_cmd(cmd, false);\n\t\treturn -1;\n\t}\n\n\tif (add_to_conn) {\n\t\tspin_lock_bh(&conn->cmd_lock);\n\t\tlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\n\t\tspin_unlock_bh(&conn->cmd_lock);\n\t}\n\n\tcmd->i_state = ISTATE_SEND_REJECT;\n\tiscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\n\t \n\tif (do_put) {\n\t\tpr_debug(\"iscsi reject: calling target_put_sess_cmd >>>>>>\\n\");\n\t\ttarget_put_sess_cmd(&cmd->se_cmd);\n\t}\n\treturn -1;\n}\n\nstatic int iscsit_add_reject_cmd(struct iscsit_cmd *cmd, u8 reason,\n\t\t\t\t unsigned char *buf)\n{\n\treturn iscsit_add_reject_from_cmd(cmd, reason, true, buf);\n}\n\nint iscsit_reject_cmd(struct iscsit_cmd *cmd, u8 reason, unsigned char *buf)\n{\n\treturn iscsit_add_reject_from_cmd(cmd, reason, false, buf);\n}\nEXPORT_SYMBOL(iscsit_reject_cmd);\n\n \nstatic int iscsit_map_iovec(struct iscsit_cmd *cmd, struct kvec *iov, int nvec,\n\t\t\t    u32 data_offset, u32 data_length)\n{\n\tu32 i = 0, orig_data_length = data_length;\n\tstruct scatterlist *sg;\n\tunsigned int page_off;\n\n\t \n\tu32 ent = data_offset / PAGE_SIZE;\n\n\tif (!data_length)\n\t\treturn 0;\n\n\tif (ent >= cmd->se_cmd.t_data_nents) {\n\t\tpr_err(\"Initial page entry out-of-bounds\\n\");\n\t\tgoto overflow;\n\t}\n\n\tsg = &cmd->se_cmd.t_data_sg[ent];\n\tpage_off = (data_offset % PAGE_SIZE);\n\n\tcmd->first_data_sg = sg;\n\tcmd->first_data_sg_off = page_off;\n\n\twhile (data_length) {\n\t\tu32 cur_len;\n\n\t\tif (WARN_ON_ONCE(!sg || i >= nvec))\n\t\t\tgoto overflow;\n\n\t\tcur_len = min_t(u32, data_length, sg->length - page_off);\n\n\t\tiov[i].iov_base = kmap(sg_page(sg)) + sg->offset + page_off;\n\t\tiov[i].iov_len = cur_len;\n\n\t\tdata_length -= cur_len;\n\t\tpage_off = 0;\n\t\tsg = sg_next(sg);\n\t\ti++;\n\t}\n\n\tcmd->kmapped_nents = i;\n\n\treturn i;\n\noverflow:\n\tpr_err(\"offset %d + length %d overflow; %d/%d; sg-list:\\n\",\n\t       data_offset, orig_data_length, i, nvec);\n\tfor_each_sg(cmd->se_cmd.t_data_sg, sg,\n\t\t    cmd->se_cmd.t_data_nents, i) {\n\t\tpr_err(\"[%d] off %d len %d\\n\",\n\t\t       i, sg->offset, sg->length);\n\t}\n\treturn -1;\n}\n\nstatic void iscsit_unmap_iovec(struct iscsit_cmd *cmd)\n{\n\tu32 i;\n\tstruct scatterlist *sg;\n\n\tsg = cmd->first_data_sg;\n\n\tfor (i = 0; i < cmd->kmapped_nents; i++)\n\t\tkunmap(sg_page(&sg[i]));\n}\n\nstatic void iscsit_ack_from_expstatsn(struct iscsit_conn *conn, u32 exp_statsn)\n{\n\tLIST_HEAD(ack_list);\n\tstruct iscsit_cmd *cmd, *cmd_p;\n\n\tconn->exp_statsn = exp_statsn;\n\n\tif (conn->sess->sess_ops->RDMAExtensions)\n\t\treturn;\n\n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_for_each_entry_safe(cmd, cmd_p, &conn->conn_cmd_list, i_conn_node) {\n\t\tspin_lock(&cmd->istate_lock);\n\t\tif ((cmd->i_state == ISTATE_SENT_STATUS) &&\n\t\t    iscsi_sna_lt(cmd->stat_sn, exp_statsn)) {\n\t\t\tcmd->i_state = ISTATE_REMOVE;\n\t\t\tspin_unlock(&cmd->istate_lock);\n\t\t\tlist_move_tail(&cmd->i_conn_node, &ack_list);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&cmd->istate_lock);\n\t}\n\tspin_unlock_bh(&conn->cmd_lock);\n\n\tlist_for_each_entry_safe(cmd, cmd_p, &ack_list, i_conn_node) {\n\t\tlist_del_init(&cmd->i_conn_node);\n\t\tiscsit_free_cmd(cmd, false);\n\t}\n}\n\nstatic int iscsit_allocate_iovecs(struct iscsit_cmd *cmd)\n{\n\tu32 iov_count = max(1UL, DIV_ROUND_UP(cmd->se_cmd.data_length, PAGE_SIZE));\n\n\tiov_count += ISCSI_IOV_DATA_BUFFER;\n\tcmd->iov_data = kcalloc(iov_count, sizeof(*cmd->iov_data), GFP_KERNEL);\n\tif (!cmd->iov_data)\n\t\treturn -ENOMEM;\n\n\tcmd->orig_iov_data_count = iov_count;\n\treturn 0;\n}\n\nint iscsit_setup_scsi_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t\t  unsigned char *buf)\n{\n\tint data_direction, payload_length;\n\tstruct iscsi_ecdb_ahdr *ecdb_ahdr;\n\tstruct iscsi_scsi_req *hdr;\n\tint iscsi_task_attr;\n\tunsigned char *cdb;\n\tint sam_task_attr;\n\n\tatomic_long_inc(&conn->sess->cmd_pdus);\n\n\thdr\t\t\t= (struct iscsi_scsi_req *) buf;\n\tpayload_length\t\t= ntoh24(hdr->dlength);\n\n\t \n\n\tif (!(hdr->flags & ISCSI_FLAG_CMD_WRITE) &&\n\t    !(hdr->flags & ISCSI_FLAG_CMD_FINAL)) {\n\t\tpr_err(\"ISCSI_FLAG_CMD_WRITE & ISCSI_FLAG_CMD_FINAL\"\n\t\t\t\t\" not set. Bad iSCSI Initiator.\\n\");\n\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\t\t     ISCSI_REASON_BOOKMARK_INVALID, buf);\n\t}\n\n\tif (((hdr->flags & ISCSI_FLAG_CMD_READ) ||\n\t     (hdr->flags & ISCSI_FLAG_CMD_WRITE)) && !hdr->data_length) {\n\t\t \n\t\thdr->flags &= ~ISCSI_FLAG_CMD_READ;\n\t\thdr->flags &= ~ISCSI_FLAG_CMD_WRITE;\n\n\t\tpr_warn(\"ISCSI_FLAG_CMD_READ or ISCSI_FLAG_CMD_WRITE\"\n\t\t\t\" set when Expected Data Transfer Length is 0 for\"\n\t\t\t\" CDB: 0x%02x, Fixing up flags\\n\", hdr->cdb[0]);\n\t}\n\n\tif (!(hdr->flags & ISCSI_FLAG_CMD_READ) &&\n\t    !(hdr->flags & ISCSI_FLAG_CMD_WRITE) && (hdr->data_length != 0)) {\n\t\tpr_err(\"ISCSI_FLAG_CMD_READ and/or ISCSI_FLAG_CMD_WRITE\"\n\t\t\t\" MUST be set if Expected Data Transfer Length is not 0.\"\n\t\t\t\" Bad iSCSI Initiator\\n\");\n\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\t\t     ISCSI_REASON_BOOKMARK_INVALID, buf);\n\t}\n\n\tif ((hdr->flags & ISCSI_FLAG_CMD_READ) &&\n\t    (hdr->flags & ISCSI_FLAG_CMD_WRITE)) {\n\t\tpr_err(\"Bidirectional operations not supported!\\n\");\n\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\t\t     ISCSI_REASON_BOOKMARK_INVALID, buf);\n\t}\n\n\tif (hdr->opcode & ISCSI_OP_IMMEDIATE) {\n\t\tpr_err(\"Illegally set Immediate Bit in iSCSI Initiator\"\n\t\t\t\t\" Scsi Command PDU.\\n\");\n\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\t\t     ISCSI_REASON_BOOKMARK_INVALID, buf);\n\t}\n\n\tif (payload_length && !conn->sess->sess_ops->ImmediateData) {\n\t\tpr_err(\"ImmediateData=No but DataSegmentLength=%u,\"\n\t\t\t\" protocol error.\\n\", payload_length);\n\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\t\t     ISCSI_REASON_PROTOCOL_ERROR, buf);\n\t}\n\n\tif ((be32_to_cpu(hdr->data_length) == payload_length) &&\n\t    (!(hdr->flags & ISCSI_FLAG_CMD_FINAL))) {\n\t\tpr_err(\"Expected Data Transfer Length and Length of\"\n\t\t\t\" Immediate Data are the same, but ISCSI_FLAG_CMD_FINAL\"\n\t\t\t\" bit is not set protocol error\\n\");\n\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\t\t     ISCSI_REASON_PROTOCOL_ERROR, buf);\n\t}\n\n\tif (payload_length > be32_to_cpu(hdr->data_length)) {\n\t\tpr_err(\"DataSegmentLength: %u is greater than\"\n\t\t\t\" EDTL: %u, protocol error.\\n\", payload_length,\n\t\t\t\thdr->data_length);\n\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\t\t     ISCSI_REASON_PROTOCOL_ERROR, buf);\n\t}\n\n\tif (payload_length > conn->conn_ops->MaxXmitDataSegmentLength) {\n\t\tpr_err(\"DataSegmentLength: %u is greater than\"\n\t\t\t\" MaxXmitDataSegmentLength: %u, protocol error.\\n\",\n\t\t\tpayload_length, conn->conn_ops->MaxXmitDataSegmentLength);\n\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\t\t     ISCSI_REASON_PROTOCOL_ERROR, buf);\n\t}\n\n\tif (payload_length > conn->sess->sess_ops->FirstBurstLength) {\n\t\tpr_err(\"DataSegmentLength: %u is greater than\"\n\t\t\t\" FirstBurstLength: %u, protocol error.\\n\",\n\t\t\tpayload_length, conn->sess->sess_ops->FirstBurstLength);\n\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\t\t     ISCSI_REASON_BOOKMARK_INVALID, buf);\n\t}\n\n\tcdb = hdr->cdb;\n\n\tif (hdr->hlength) {\n\t\tecdb_ahdr = (struct iscsi_ecdb_ahdr *) (hdr + 1);\n\t\tif (ecdb_ahdr->ahstype != ISCSI_AHSTYPE_CDB) {\n\t\t\tpr_err(\"Additional Header Segment type %d not supported!\\n\",\n\t\t\t       ecdb_ahdr->ahstype);\n\t\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\tISCSI_REASON_CMD_NOT_SUPPORTED, buf);\n\t\t}\n\n\t\tcdb = kmalloc(be16_to_cpu(ecdb_ahdr->ahslength) + 15,\n\t\t\t      GFP_KERNEL);\n\t\tif (cdb == NULL)\n\t\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\tISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\n\t\tmemcpy(cdb, hdr->cdb, ISCSI_CDB_SIZE);\n\t\tmemcpy(cdb + ISCSI_CDB_SIZE, ecdb_ahdr->ecdb,\n\t\t       be16_to_cpu(ecdb_ahdr->ahslength) - 1);\n\t}\n\n\tdata_direction = (hdr->flags & ISCSI_FLAG_CMD_WRITE) ? DMA_TO_DEVICE :\n\t\t\t (hdr->flags & ISCSI_FLAG_CMD_READ) ? DMA_FROM_DEVICE :\n\t\t\t  DMA_NONE;\n\n\tcmd->data_direction = data_direction;\n\tiscsi_task_attr = hdr->flags & ISCSI_FLAG_CMD_ATTR_MASK;\n\t \n\tif ((iscsi_task_attr == ISCSI_ATTR_UNTAGGED) ||\n\t    (iscsi_task_attr == ISCSI_ATTR_SIMPLE))\n\t\tsam_task_attr = TCM_SIMPLE_TAG;\n\telse if (iscsi_task_attr == ISCSI_ATTR_ORDERED)\n\t\tsam_task_attr = TCM_ORDERED_TAG;\n\telse if (iscsi_task_attr == ISCSI_ATTR_HEAD_OF_QUEUE)\n\t\tsam_task_attr = TCM_HEAD_TAG;\n\telse if (iscsi_task_attr == ISCSI_ATTR_ACA)\n\t\tsam_task_attr = TCM_ACA_TAG;\n\telse {\n\t\tpr_debug(\"Unknown iSCSI Task Attribute: 0x%02x, using\"\n\t\t\t\" TCM_SIMPLE_TAG\\n\", iscsi_task_attr);\n\t\tsam_task_attr = TCM_SIMPLE_TAG;\n\t}\n\n\tcmd->iscsi_opcode\t= ISCSI_OP_SCSI_CMD;\n\tcmd->i_state\t\t= ISTATE_NEW_CMD;\n\tcmd->immediate_cmd\t= ((hdr->opcode & ISCSI_OP_IMMEDIATE) ? 1 : 0);\n\tcmd->immediate_data\t= (payload_length) ? 1 : 0;\n\tcmd->unsolicited_data\t= ((!(hdr->flags & ISCSI_FLAG_CMD_FINAL) &&\n\t\t\t\t     (hdr->flags & ISCSI_FLAG_CMD_WRITE)) ? 1 : 0);\n\tif (cmd->unsolicited_data)\n\t\tcmd->cmd_flags |= ICF_NON_IMMEDIATE_UNSOLICITED_DATA;\n\n\tconn->sess->init_task_tag = cmd->init_task_tag = hdr->itt;\n\tif (hdr->flags & ISCSI_FLAG_CMD_READ)\n\t\tcmd->targ_xfer_tag = session_get_next_ttt(conn->sess);\n\telse\n\t\tcmd->targ_xfer_tag = 0xFFFFFFFF;\n\tcmd->cmd_sn\t\t= be32_to_cpu(hdr->cmdsn);\n\tcmd->exp_stat_sn\t= be32_to_cpu(hdr->exp_statsn);\n\tcmd->first_burst_len\t= payload_length;\n\n\tif (!conn->sess->sess_ops->RDMAExtensions &&\n\t     cmd->data_direction == DMA_FROM_DEVICE) {\n\t\tstruct iscsi_datain_req *dr;\n\n\t\tdr = iscsit_allocate_datain_req();\n\t\tif (!dr) {\n\t\t\tif (cdb != hdr->cdb)\n\t\t\t\tkfree(cdb);\n\t\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\t\tISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\n\t\t}\n\n\t\tiscsit_attach_datain_req(cmd, dr);\n\t}\n\n\t \n\t__target_init_cmd(&cmd->se_cmd, &iscsi_ops,\n\t\t\t  conn->sess->se_sess, be32_to_cpu(hdr->data_length),\n\t\t\t  cmd->data_direction, sam_task_attr,\n\t\t\t  cmd->sense_buffer + 2, scsilun_to_int(&hdr->lun),\n\t\t\t  conn->cmd_cnt);\n\n\tpr_debug(\"Got SCSI Command, ITT: 0x%08x, CmdSN: 0x%08x,\"\n\t\t\" ExpXferLen: %u, Length: %u, CID: %hu\\n\", hdr->itt,\n\t\thdr->cmdsn, be32_to_cpu(hdr->data_length), payload_length,\n\t\tconn->cid);\n\n\ttarget_get_sess_cmd(&cmd->se_cmd, true);\n\n\tcmd->se_cmd.tag = (__force u32)cmd->init_task_tag;\n\tcmd->sense_reason = target_cmd_init_cdb(&cmd->se_cmd, cdb,\n\t\t\t\t\t\tGFP_KERNEL);\n\n\tif (cdb != hdr->cdb)\n\t\tkfree(cdb);\n\n\tif (cmd->sense_reason) {\n\t\tif (cmd->sense_reason == TCM_OUT_OF_RESOURCES) {\n\t\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\tISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\n\t\t}\n\n\t\tgoto attach_cmd;\n\t}\n\n\tcmd->sense_reason = transport_lookup_cmd_lun(&cmd->se_cmd);\n\tif (cmd->sense_reason)\n\t\tgoto attach_cmd;\n\n\tcmd->sense_reason = target_cmd_parse_cdb(&cmd->se_cmd);\n\tif (cmd->sense_reason)\n\t\tgoto attach_cmd;\n\n\tif (iscsit_build_pdu_and_seq_lists(cmd, payload_length) < 0) {\n\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\tISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\n\t}\n\nattach_cmd:\n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\n\tspin_unlock_bh(&conn->cmd_lock);\n\t \n\tcore_alua_check_nonop_delay(&cmd->se_cmd);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iscsit_setup_scsi_cmd);\n\nvoid iscsit_set_unsolicited_dataout(struct iscsit_cmd *cmd)\n{\n\tiscsit_set_dataout_sequence_values(cmd);\n\n\tspin_lock_bh(&cmd->dataout_timeout_lock);\n\tiscsit_start_dataout_timer(cmd, cmd->conn);\n\tspin_unlock_bh(&cmd->dataout_timeout_lock);\n}\nEXPORT_SYMBOL(iscsit_set_unsolicited_dataout);\n\nint iscsit_process_scsi_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t\t    struct iscsi_scsi_req *hdr)\n{\n\tint cmdsn_ret = 0;\n\t \n\tif (!cmd->immediate_data) {\n\t\tcmdsn_ret = iscsit_sequence_cmd(conn, cmd,\n\t\t\t\t\t(unsigned char *)hdr, hdr->cmdsn);\n\t\tif (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)\n\t\t\treturn -1;\n\t\telse if (cmdsn_ret == CMDSN_LOWER_THAN_EXP) {\n\t\t\ttarget_put_sess_cmd(&cmd->se_cmd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tiscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));\n\n\t \n\tif (!cmd->immediate_data) {\n\t\tif (!cmd->sense_reason && cmd->unsolicited_data)\n\t\t\tiscsit_set_unsolicited_dataout(cmd);\n\t\tif (!cmd->sense_reason)\n\t\t\treturn 0;\n\n\t\ttarget_put_sess_cmd(&cmd->se_cmd);\n\t\treturn 0;\n\t}\n\n\t \n\tif (cmd->sense_reason)\n\t\treturn 1;\n\t \n\tcmd->sense_reason = transport_generic_new_cmd(&cmd->se_cmd);\n\tif (cmd->sense_reason)\n\t\treturn 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iscsit_process_scsi_cmd);\n\nstatic int\niscsit_get_immediate_data(struct iscsit_cmd *cmd, struct iscsi_scsi_req *hdr,\n\t\t\t  bool dump_payload)\n{\n\tint cmdsn_ret = 0, immed_ret = IMMEDIATE_DATA_NORMAL_OPERATION;\n\tint rc;\n\n\t \n\tif (dump_payload) {\n\t\tu32 length = min(cmd->se_cmd.data_length - cmd->write_data_done,\n\t\t\t\t cmd->first_burst_len);\n\n\t\tpr_debug(\"Dumping min(%d - %d, %d) = %d bytes of immediate data\\n\",\n\t\t\t cmd->se_cmd.data_length, cmd->write_data_done,\n\t\t\t cmd->first_burst_len, length);\n\t\trc = iscsit_dump_data_payload(cmd->conn, length, 1);\n\t\tpr_debug(\"Finished dumping immediate data\\n\");\n\t\tif (rc < 0)\n\t\t\timmed_ret = IMMEDIATE_DATA_CANNOT_RECOVER;\n\t} else {\n\t\timmed_ret = iscsit_handle_immediate_data(cmd, hdr,\n\t\t\t\t\t\t\t cmd->first_burst_len);\n\t}\n\n\tif (immed_ret == IMMEDIATE_DATA_NORMAL_OPERATION) {\n\t\t \n\t\tcmdsn_ret = iscsit_sequence_cmd(cmd->conn, cmd,\n\t\t\t\t\t(unsigned char *)hdr, hdr->cmdsn);\n\t\tif (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)\n\t\t\treturn -1;\n\n\t\tif (cmd->sense_reason || cmdsn_ret == CMDSN_LOWER_THAN_EXP) {\n\t\t\ttarget_put_sess_cmd(&cmd->se_cmd);\n\n\t\t\treturn 0;\n\t\t} else if (cmd->unsolicited_data)\n\t\t\tiscsit_set_unsolicited_dataout(cmd);\n\n\t} else if (immed_ret == IMMEDIATE_DATA_ERL1_CRC_FAILURE) {\n\t\t \n\t\tcmd->i_state = ISTATE_REMOVE;\n\t\tiscsit_add_cmd_to_immediate_queue(cmd, cmd->conn, cmd->i_state);\n\t} else  \n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int\niscsit_handle_scsi_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t\t   unsigned char *buf)\n{\n\tstruct iscsi_scsi_req *hdr = (struct iscsi_scsi_req *)buf;\n\tint rc, immed_data;\n\tbool dump_payload = false;\n\n\trc = iscsit_setup_scsi_cmd(conn, cmd, buf);\n\tif (rc < 0)\n\t\treturn 0;\n\t \n\tif (iscsit_allocate_iovecs(cmd) < 0) {\n\t\treturn iscsit_reject_cmd(cmd,\n\t\t\t\tISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\n\t}\n\timmed_data = cmd->immediate_data;\n\n\trc = iscsit_process_scsi_cmd(conn, cmd, hdr);\n\tif (rc < 0)\n\t\treturn rc;\n\telse if (rc > 0)\n\t\tdump_payload = true;\n\n\tif (!immed_data)\n\t\treturn 0;\n\n\treturn iscsit_get_immediate_data(cmd, hdr, dump_payload);\n}\n\nstatic u32 iscsit_do_crypto_hash_sg(\n\tstruct ahash_request *hash,\n\tstruct iscsit_cmd *cmd,\n\tu32 data_offset,\n\tu32 data_length,\n\tu32 padding,\n\tu8 *pad_bytes)\n{\n\tu32 data_crc;\n\tstruct scatterlist *sg;\n\tunsigned int page_off;\n\n\tcrypto_ahash_init(hash);\n\n\tsg = cmd->first_data_sg;\n\tpage_off = cmd->first_data_sg_off;\n\n\tif (data_length && page_off) {\n\t\tstruct scatterlist first_sg;\n\t\tu32 len = min_t(u32, data_length, sg->length - page_off);\n\n\t\tsg_init_table(&first_sg, 1);\n\t\tsg_set_page(&first_sg, sg_page(sg), len, sg->offset + page_off);\n\n\t\tahash_request_set_crypt(hash, &first_sg, NULL, len);\n\t\tcrypto_ahash_update(hash);\n\n\t\tdata_length -= len;\n\t\tsg = sg_next(sg);\n\t}\n\n\twhile (data_length) {\n\t\tu32 cur_len = min_t(u32, data_length, sg->length);\n\n\t\tahash_request_set_crypt(hash, sg, NULL, cur_len);\n\t\tcrypto_ahash_update(hash);\n\n\t\tdata_length -= cur_len;\n\t\t \n\t\tsg = sg_next(sg);\n\t}\n\n\tif (padding) {\n\t\tstruct scatterlist pad_sg;\n\n\t\tsg_init_one(&pad_sg, pad_bytes, padding);\n\t\tahash_request_set_crypt(hash, &pad_sg, (u8 *)&data_crc,\n\t\t\t\t\tpadding);\n\t\tcrypto_ahash_finup(hash);\n\t} else {\n\t\tahash_request_set_crypt(hash, NULL, (u8 *)&data_crc, 0);\n\t\tcrypto_ahash_final(hash);\n\t}\n\n\treturn data_crc;\n}\n\nstatic void iscsit_do_crypto_hash_buf(struct ahash_request *hash,\n\tconst void *buf, u32 payload_length, u32 padding,\n\tconst void *pad_bytes, void *data_crc)\n{\n\tstruct scatterlist sg[2];\n\n\tsg_init_table(sg, ARRAY_SIZE(sg));\n\tsg_set_buf(sg, buf, payload_length);\n\tif (padding)\n\t\tsg_set_buf(sg + 1, pad_bytes, padding);\n\n\tahash_request_set_crypt(hash, sg, data_crc, payload_length + padding);\n\n\tcrypto_ahash_digest(hash);\n}\n\nint\n__iscsit_check_dataout_hdr(struct iscsit_conn *conn, void *buf,\n\t\t\t   struct iscsit_cmd *cmd, u32 payload_length,\n\t\t\t   bool *success)\n{\n\tstruct iscsi_data *hdr = buf;\n\tstruct se_cmd *se_cmd;\n\tint rc;\n\n\t \n\tatomic_long_add(payload_length, &conn->sess->rx_data_octets);\n\n\tpr_debug(\"Got DataOut ITT: 0x%08x, TTT: 0x%08x,\"\n\t\t\" DataSN: 0x%08x, Offset: %u, Length: %u, CID: %hu\\n\",\n\t\thdr->itt, hdr->ttt, hdr->datasn, ntohl(hdr->offset),\n\t\tpayload_length, conn->cid);\n\n\tif (cmd->cmd_flags & ICF_GOT_LAST_DATAOUT) {\n\t\tpr_err(\"Command ITT: 0x%08x received DataOUT after\"\n\t\t\t\" last DataOUT received, dumping payload\\n\",\n\t\t\tcmd->init_task_tag);\n\t\treturn iscsit_dump_data_payload(conn, payload_length, 1);\n\t}\n\n\tif (cmd->data_direction != DMA_TO_DEVICE) {\n\t\tpr_err(\"Command ITT: 0x%08x received DataOUT for a\"\n\t\t\t\" NON-WRITE command.\\n\", cmd->init_task_tag);\n\t\treturn iscsit_dump_data_payload(conn, payload_length, 1);\n\t}\n\tse_cmd = &cmd->se_cmd;\n\tiscsit_mod_dataout_timer(cmd);\n\n\tif ((be32_to_cpu(hdr->offset) + payload_length) > cmd->se_cmd.data_length) {\n\t\tpr_err(\"DataOut Offset: %u, Length %u greater than iSCSI Command EDTL %u, protocol error.\\n\",\n\t\t       be32_to_cpu(hdr->offset), payload_length,\n\t\t       cmd->se_cmd.data_length);\n\t\treturn iscsit_reject_cmd(cmd, ISCSI_REASON_BOOKMARK_INVALID, buf);\n\t}\n\n\tif (cmd->unsolicited_data) {\n\t\tint dump_unsolicited_data = 0;\n\n\t\tif (conn->sess->sess_ops->InitialR2T) {\n\t\t\tpr_err(\"Received unexpected unsolicited data\"\n\t\t\t\t\" while InitialR2T=Yes, protocol error.\\n\");\n\t\t\ttransport_send_check_condition_and_sense(&cmd->se_cmd,\n\t\t\t\t\tTCM_UNEXPECTED_UNSOLICITED_DATA, 0);\n\t\t\treturn -1;\n\t\t}\n\t\t \n\n\t\t \n\t\tWARN_ON(se_cmd->t_state != TRANSPORT_WRITE_PENDING);\n\t\tif (!(se_cmd->se_cmd_flags & SCF_SUPPORTED_SAM_OPCODE))\n\t\t\tdump_unsolicited_data = 1;\n\n\t\tif (dump_unsolicited_data) {\n\t\t\t \n\t\t\tif (hdr->flags & ISCSI_FLAG_CMD_FINAL)\n\t\t\t\tiscsit_stop_dataout_timer(cmd);\n\n\t\t\treturn iscsit_dump_data_payload(conn, payload_length, 1);\n\t\t}\n\t} else {\n\t\t \n\t\tif (se_cmd->transport_state & CMD_T_ABORTED) {\n\t\t\tif (hdr->flags & ISCSI_FLAG_CMD_FINAL &&\n\t\t\t    --cmd->outstanding_r2ts < 1)\n\t\t\t\tiscsit_stop_dataout_timer(cmd);\n\n\t\t\treturn iscsit_dump_data_payload(conn, payload_length, 1);\n\t\t}\n\t}\n\t \n\trc = iscsit_check_pre_dataout(cmd, buf);\n\tif (rc == DATAOUT_WITHIN_COMMAND_RECOVERY)\n\t\treturn 0;\n\telse if (rc == DATAOUT_CANNOT_RECOVER)\n\t\treturn -1;\n\t*success = true;\n\treturn 0;\n}\nEXPORT_SYMBOL(__iscsit_check_dataout_hdr);\n\nint\niscsit_check_dataout_hdr(struct iscsit_conn *conn, void *buf,\n\t\t\t struct iscsit_cmd **out_cmd)\n{\n\tstruct iscsi_data *hdr = buf;\n\tstruct iscsit_cmd *cmd;\n\tu32 payload_length = ntoh24(hdr->dlength);\n\tint rc;\n\tbool success = false;\n\n\tif (!payload_length) {\n\t\tpr_warn_ratelimited(\"DataOUT payload is ZERO, ignoring.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (payload_length > conn->conn_ops->MaxXmitDataSegmentLength) {\n\t\tpr_err_ratelimited(\"DataSegmentLength: %u is greater than\"\n\t\t\t\" MaxXmitDataSegmentLength: %u\\n\", payload_length,\n\t\t\tconn->conn_ops->MaxXmitDataSegmentLength);\n\t\treturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR, buf);\n\t}\n\n\tcmd = iscsit_find_cmd_from_itt_or_dump(conn, hdr->itt, payload_length);\n\tif (!cmd)\n\t\treturn 0;\n\n\trc = __iscsit_check_dataout_hdr(conn, buf, cmd, payload_length, &success);\n\n\tif (success)\n\t\t*out_cmd = cmd;\n\n\treturn rc;\n}\nEXPORT_SYMBOL(iscsit_check_dataout_hdr);\n\nstatic int\niscsit_get_dataout(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t   struct iscsi_data *hdr)\n{\n\tstruct kvec *iov;\n\tu32 checksum, iov_count = 0, padding = 0, rx_got = 0, rx_size = 0;\n\tu32 payload_length;\n\tint iov_ret, data_crc_failed = 0;\n\n\tpayload_length = min_t(u32, cmd->se_cmd.data_length,\n\t\t\t       ntoh24(hdr->dlength));\n\trx_size += payload_length;\n\tiov = &cmd->iov_data[0];\n\n\tiov_ret = iscsit_map_iovec(cmd, iov, cmd->orig_iov_data_count - 2,\n\t\t\t\t   be32_to_cpu(hdr->offset), payload_length);\n\tif (iov_ret < 0)\n\t\treturn -1;\n\n\tiov_count += iov_ret;\n\n\tpadding = ((-payload_length) & 3);\n\tif (padding != 0) {\n\t\tiov[iov_count].iov_base\t= cmd->pad_bytes;\n\t\tiov[iov_count++].iov_len = padding;\n\t\trx_size += padding;\n\t\tpr_debug(\"Receiving %u padding bytes.\\n\", padding);\n\t}\n\n\tif (conn->conn_ops->DataDigest) {\n\t\tiov[iov_count].iov_base = &checksum;\n\t\tiov[iov_count++].iov_len = ISCSI_CRC_LEN;\n\t\trx_size += ISCSI_CRC_LEN;\n\t}\n\n\tWARN_ON_ONCE(iov_count > cmd->orig_iov_data_count);\n\trx_got = rx_data(conn, &cmd->iov_data[0], iov_count, rx_size);\n\n\tiscsit_unmap_iovec(cmd);\n\n\tif (rx_got != rx_size)\n\t\treturn -1;\n\n\tif (conn->conn_ops->DataDigest) {\n\t\tu32 data_crc;\n\n\t\tdata_crc = iscsit_do_crypto_hash_sg(conn->conn_rx_hash, cmd,\n\t\t\t\t\t\t    be32_to_cpu(hdr->offset),\n\t\t\t\t\t\t    payload_length, padding,\n\t\t\t\t\t\t    cmd->pad_bytes);\n\n\t\tif (checksum != data_crc) {\n\t\t\tpr_err(\"ITT: 0x%08x, Offset: %u, Length: %u,\"\n\t\t\t\t\" DataSN: 0x%08x, CRC32C DataDigest 0x%08x\"\n\t\t\t\t\" does not match computed 0x%08x\\n\",\n\t\t\t\thdr->itt, hdr->offset, payload_length,\n\t\t\t\thdr->datasn, checksum, data_crc);\n\t\t\tdata_crc_failed = 1;\n\t\t} else {\n\t\t\tpr_debug(\"Got CRC32C DataDigest 0x%08x for\"\n\t\t\t\t\" %u bytes of Data Out\\n\", checksum,\n\t\t\t\tpayload_length);\n\t\t}\n\t}\n\n\treturn data_crc_failed;\n}\n\nint\niscsit_check_dataout_payload(struct iscsit_cmd *cmd, struct iscsi_data *hdr,\n\t\t\t     bool data_crc_failed)\n{\n\tstruct iscsit_conn *conn = cmd->conn;\n\tint rc, ooo_cmdsn;\n\t \n\trc = iscsit_check_post_dataout(cmd, (unsigned char *)hdr, data_crc_failed);\n\tif ((rc == DATAOUT_NORMAL) || (rc == DATAOUT_WITHIN_COMMAND_RECOVERY))\n\t\treturn 0;\n\telse if (rc == DATAOUT_SEND_R2T) {\n\t\tiscsit_set_dataout_sequence_values(cmd);\n\t\tconn->conn_transport->iscsit_get_dataout(conn, cmd, false);\n\t} else if (rc == DATAOUT_SEND_TO_TRANSPORT) {\n\t\t \n\t\tspin_lock_bh(&cmd->istate_lock);\n\t\tooo_cmdsn = (cmd->cmd_flags & ICF_OOO_CMDSN);\n\t\tcmd->cmd_flags |= ICF_GOT_LAST_DATAOUT;\n\t\tcmd->i_state = ISTATE_RECEIVED_LAST_DATAOUT;\n\t\tspin_unlock_bh(&cmd->istate_lock);\n\n\t\tiscsit_stop_dataout_timer(cmd);\n\t\tif (ooo_cmdsn)\n\t\t\treturn 0;\n\t\ttarget_execute_cmd(&cmd->se_cmd);\n\t\treturn 0;\n\t} else  \n\t\treturn -1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iscsit_check_dataout_payload);\n\nstatic int iscsit_handle_data_out(struct iscsit_conn *conn, unsigned char *buf)\n{\n\tstruct iscsit_cmd *cmd = NULL;\n\tstruct iscsi_data *hdr = (struct iscsi_data *)buf;\n\tint rc;\n\tbool data_crc_failed = false;\n\n\trc = iscsit_check_dataout_hdr(conn, buf, &cmd);\n\tif (rc < 0)\n\t\treturn 0;\n\telse if (!cmd)\n\t\treturn 0;\n\n\trc = iscsit_get_dataout(conn, cmd, hdr);\n\tif (rc < 0)\n\t\treturn rc;\n\telse if (rc > 0)\n\t\tdata_crc_failed = true;\n\n\treturn iscsit_check_dataout_payload(cmd, hdr, data_crc_failed);\n}\n\nint iscsit_setup_nop_out(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t\t struct iscsi_nopout *hdr)\n{\n\tu32 payload_length = ntoh24(hdr->dlength);\n\n\tif (!(hdr->flags & ISCSI_FLAG_CMD_FINAL)) {\n\t\tpr_err(\"NopOUT Flag's, Left Most Bit not set, protocol error.\\n\");\n\t\tif (!cmd)\n\t\t\treturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t\t\t (unsigned char *)hdr);\n\t\t\n\t\treturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t\t (unsigned char *)hdr);\n\t}\n\n\tif (hdr->itt == RESERVED_ITT && !(hdr->opcode & ISCSI_OP_IMMEDIATE)) {\n\t\tpr_err(\"NOPOUT ITT is reserved, but Immediate Bit is\"\n\t\t\t\" not set, protocol error.\\n\");\n\t\tif (!cmd)\n\t\t\treturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t\t\t (unsigned char *)hdr);\n\n\t\treturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t\t (unsigned char *)hdr);\n\t}\n\n\tif (payload_length > conn->conn_ops->MaxXmitDataSegmentLength) {\n\t\tpr_err(\"NOPOUT Ping Data DataSegmentLength: %u is\"\n\t\t\t\" greater than MaxXmitDataSegmentLength: %u, protocol\"\n\t\t\t\" error.\\n\", payload_length,\n\t\t\tconn->conn_ops->MaxXmitDataSegmentLength);\n\t\tif (!cmd)\n\t\t\treturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t\t\t (unsigned char *)hdr);\n\n\t\treturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t\t (unsigned char *)hdr);\n\t}\n\n\tpr_debug(\"Got NOPOUT Ping %s ITT: 0x%08x, TTT: 0x%08x,\"\n\t\t\" CmdSN: 0x%08x, ExpStatSN: 0x%08x, Length: %u\\n\",\n\t\thdr->itt == RESERVED_ITT ? \"Response\" : \"Request\",\n\t\thdr->itt, hdr->ttt, hdr->cmdsn, hdr->exp_statsn,\n\t\tpayload_length);\n\t \n\tif (hdr->ttt == cpu_to_be32(0xFFFFFFFF)) {\n\t\tcmd->iscsi_opcode\t= ISCSI_OP_NOOP_OUT;\n\t\tcmd->i_state\t\t= ISTATE_SEND_NOPIN;\n\t\tcmd->immediate_cmd\t= ((hdr->opcode & ISCSI_OP_IMMEDIATE) ?\n\t\t\t\t\t\t1 : 0);\n\t\tconn->sess->init_task_tag = cmd->init_task_tag = hdr->itt;\n\t\tcmd->targ_xfer_tag\t= 0xFFFFFFFF;\n\t\tcmd->cmd_sn\t\t= be32_to_cpu(hdr->cmdsn);\n\t\tcmd->exp_stat_sn\t= be32_to_cpu(hdr->exp_statsn);\n\t\tcmd->data_direction\t= DMA_NONE;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iscsit_setup_nop_out);\n\nint iscsit_process_nop_out(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t\t   struct iscsi_nopout *hdr)\n{\n\tstruct iscsit_cmd *cmd_p = NULL;\n\tint cmdsn_ret = 0;\n\t \n\tif (hdr->itt != RESERVED_ITT) {\n\t\tif (!cmd)\n\t\t\treturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t\t\t(unsigned char *)hdr);\n\n\t\tspin_lock_bh(&conn->cmd_lock);\n\t\tlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\n\t\tspin_unlock_bh(&conn->cmd_lock);\n\n\t\tiscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));\n\n\t\tif (hdr->opcode & ISCSI_OP_IMMEDIATE) {\n\t\t\tiscsit_add_cmd_to_response_queue(cmd, conn,\n\t\t\t\t\t\t\t cmd->i_state);\n\t\t\treturn 0;\n\t\t}\n\n\t\tcmdsn_ret = iscsit_sequence_cmd(conn, cmd,\n\t\t\t\t(unsigned char *)hdr, hdr->cmdsn);\n                if (cmdsn_ret == CMDSN_LOWER_THAN_EXP)\n\t\t\treturn 0;\n\t\tif (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)\n\t\t\treturn -1;\n\n\t\treturn 0;\n\t}\n\t \n\tif (hdr->ttt != cpu_to_be32(0xFFFFFFFF)) {\n\t\tcmd_p = iscsit_find_cmd_from_ttt(conn, be32_to_cpu(hdr->ttt));\n\t\tif (!cmd_p)\n\t\t\treturn -EINVAL;\n\n\t\tiscsit_stop_nopin_response_timer(conn);\n\n\t\tcmd_p->i_state = ISTATE_REMOVE;\n\t\tiscsit_add_cmd_to_immediate_queue(cmd_p, conn, cmd_p->i_state);\n\n\t\tiscsit_start_nopin_timer(conn);\n\t\treturn 0;\n\t}\n\t \n\n\tif (cmd)\n\t\tiscsit_free_cmd(cmd, false);\n\n        return 0;\n}\nEXPORT_SYMBOL(iscsit_process_nop_out);\n\nstatic int iscsit_handle_nop_out(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t\t\t unsigned char *buf)\n{\n\tunsigned char *ping_data = NULL;\n\tstruct iscsi_nopout *hdr = (struct iscsi_nopout *)buf;\n\tstruct kvec *iov = NULL;\n\tu32 payload_length = ntoh24(hdr->dlength);\n\tint ret;\n\n\tret = iscsit_setup_nop_out(conn, cmd, hdr);\n\tif (ret < 0)\n\t\treturn 0;\n\t \n\tif (payload_length && hdr->ttt == cpu_to_be32(0xFFFFFFFF)) {\n\t\tu32 checksum, data_crc, padding = 0;\n\t\tint niov = 0, rx_got, rx_size = payload_length;\n\n\t\tping_data = kzalloc(payload_length + 1, GFP_KERNEL);\n\t\tif (!ping_data) {\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tiov = &cmd->iov_misc[0];\n\t\tiov[niov].iov_base\t= ping_data;\n\t\tiov[niov++].iov_len\t= payload_length;\n\n\t\tpadding = ((-payload_length) & 3);\n\t\tif (padding != 0) {\n\t\t\tpr_debug(\"Receiving %u additional bytes\"\n\t\t\t\t\" for padding.\\n\", padding);\n\t\t\tiov[niov].iov_base\t= &cmd->pad_bytes;\n\t\t\tiov[niov++].iov_len\t= padding;\n\t\t\trx_size += padding;\n\t\t}\n\t\tif (conn->conn_ops->DataDigest) {\n\t\t\tiov[niov].iov_base\t= &checksum;\n\t\t\tiov[niov++].iov_len\t= ISCSI_CRC_LEN;\n\t\t\trx_size += ISCSI_CRC_LEN;\n\t\t}\n\n\t\tWARN_ON_ONCE(niov > ARRAY_SIZE(cmd->iov_misc));\n\t\trx_got = rx_data(conn, &cmd->iov_misc[0], niov, rx_size);\n\t\tif (rx_got != rx_size) {\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (conn->conn_ops->DataDigest) {\n\t\t\tiscsit_do_crypto_hash_buf(conn->conn_rx_hash, ping_data,\n\t\t\t\t\t\t  payload_length, padding,\n\t\t\t\t\t\t  cmd->pad_bytes, &data_crc);\n\n\t\t\tif (checksum != data_crc) {\n\t\t\t\tpr_err(\"Ping data CRC32C DataDigest\"\n\t\t\t\t\" 0x%08x does not match computed 0x%08x\\n\",\n\t\t\t\t\tchecksum, data_crc);\n\t\t\t\tif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\n\t\t\t\t\tpr_err(\"Unable to recover from\"\n\t\t\t\t\t\" NOPOUT Ping DataCRC failure while in\"\n\t\t\t\t\t\t\" ERL=0.\\n\");\n\t\t\t\t\tret = -1;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tpr_debug(\"Dropping NOPOUT\"\n\t\t\t\t\t\" Command CmdSN: 0x%08x due to\"\n\t\t\t\t\t\" DataCRC error.\\n\", hdr->cmdsn);\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpr_debug(\"Got CRC32C DataDigest\"\n\t\t\t\t\" 0x%08x for %u bytes of ping data.\\n\",\n\t\t\t\t\tchecksum, payload_length);\n\t\t\t}\n\t\t}\n\n\t\tping_data[payload_length] = '\\0';\n\t\t \n\t\tcmd->buf_ptr = ping_data;\n\t\tcmd->buf_ptr_size = payload_length;\n\n\t\tpr_debug(\"Got %u bytes of NOPOUT ping\"\n\t\t\t\" data.\\n\", payload_length);\n\t\tpr_debug(\"Ping Data: \\\"%s\\\"\\n\", ping_data);\n\t}\n\n\treturn iscsit_process_nop_out(conn, cmd, hdr);\nout:\n\tif (cmd)\n\t\tiscsit_free_cmd(cmd, false);\n\n\tkfree(ping_data);\n\treturn ret;\n}\n\nstatic enum tcm_tmreq_table iscsit_convert_tmf(u8 iscsi_tmf)\n{\n\tswitch (iscsi_tmf) {\n\tcase ISCSI_TM_FUNC_ABORT_TASK:\n\t\treturn TMR_ABORT_TASK;\n\tcase ISCSI_TM_FUNC_ABORT_TASK_SET:\n\t\treturn TMR_ABORT_TASK_SET;\n\tcase ISCSI_TM_FUNC_CLEAR_ACA:\n\t\treturn TMR_CLEAR_ACA;\n\tcase ISCSI_TM_FUNC_CLEAR_TASK_SET:\n\t\treturn TMR_CLEAR_TASK_SET;\n\tcase ISCSI_TM_FUNC_LOGICAL_UNIT_RESET:\n\t\treturn TMR_LUN_RESET;\n\tcase ISCSI_TM_FUNC_TARGET_WARM_RESET:\n\t\treturn TMR_TARGET_WARM_RESET;\n\tcase ISCSI_TM_FUNC_TARGET_COLD_RESET:\n\t\treturn TMR_TARGET_COLD_RESET;\n\tdefault:\n\t\treturn TMR_UNKNOWN;\n\t}\n}\n\nint\niscsit_handle_task_mgt_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t\t   unsigned char *buf)\n{\n\tstruct se_tmr_req *se_tmr;\n\tstruct iscsi_tmr_req *tmr_req;\n\tstruct iscsi_tm *hdr;\n\tint out_of_order_cmdsn = 0, ret;\n\tu8 function, tcm_function = TMR_UNKNOWN;\n\n\thdr\t\t\t= (struct iscsi_tm *) buf;\n\thdr->flags &= ~ISCSI_FLAG_CMD_FINAL;\n\tfunction = hdr->flags;\n\n\tpr_debug(\"Got Task Management Request ITT: 0x%08x, CmdSN:\"\n\t\t\" 0x%08x, Function: 0x%02x, RefTaskTag: 0x%08x, RefCmdSN:\"\n\t\t\" 0x%08x, CID: %hu\\n\", hdr->itt, hdr->cmdsn, function,\n\t\thdr->rtt, hdr->refcmdsn, conn->cid);\n\n\tif ((function != ISCSI_TM_FUNC_ABORT_TASK) &&\n\t    ((function != ISCSI_TM_FUNC_TASK_REASSIGN) &&\n\t     hdr->rtt != RESERVED_ITT)) {\n\t\tpr_err(\"RefTaskTag should be set to 0xFFFFFFFF.\\n\");\n\t\thdr->rtt = RESERVED_ITT;\n\t}\n\n\tif ((function == ISCSI_TM_FUNC_TASK_REASSIGN) &&\n\t\t\t!(hdr->opcode & ISCSI_OP_IMMEDIATE)) {\n\t\tpr_err(\"Task Management Request TASK_REASSIGN not\"\n\t\t\t\" issued as immediate command, bad iSCSI Initiator\"\n\t\t\t\t\"implementation\\n\");\n\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\t\t     ISCSI_REASON_PROTOCOL_ERROR, buf);\n\t}\n\tif ((function != ISCSI_TM_FUNC_ABORT_TASK) &&\n\t    be32_to_cpu(hdr->refcmdsn) != ISCSI_RESERVED_TAG)\n\t\thdr->refcmdsn = cpu_to_be32(ISCSI_RESERVED_TAG);\n\n\tcmd->data_direction = DMA_NONE;\n\tcmd->tmr_req = kzalloc(sizeof(*cmd->tmr_req), GFP_KERNEL);\n\tif (!cmd->tmr_req) {\n\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\t\t     ISCSI_REASON_BOOKMARK_NO_RESOURCES,\n\t\t\t\t\t     buf);\n\t}\n\n\t__target_init_cmd(&cmd->se_cmd, &iscsi_ops,\n\t\t\t  conn->sess->se_sess, 0, DMA_NONE,\n\t\t\t  TCM_SIMPLE_TAG, cmd->sense_buffer + 2,\n\t\t\t  scsilun_to_int(&hdr->lun),\n\t\t\t  conn->cmd_cnt);\n\n\ttarget_get_sess_cmd(&cmd->se_cmd, true);\n\n\t \n\tif (function != ISCSI_TM_FUNC_TASK_REASSIGN) {\n\t\ttcm_function = iscsit_convert_tmf(function);\n\t\tif (tcm_function == TMR_UNKNOWN) {\n\t\t\tpr_err(\"Unknown iSCSI TMR Function:\"\n\t\t\t       \" 0x%02x\\n\", function);\n\t\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\tISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\n\t\t}\n\t}\n\tret = core_tmr_alloc_req(&cmd->se_cmd, cmd->tmr_req, tcm_function,\n\t\t\t\t GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\tISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\n\n\tcmd->tmr_req->se_tmr_req = cmd->se_cmd.se_tmr_req;\n\n\tcmd->iscsi_opcode\t= ISCSI_OP_SCSI_TMFUNC;\n\tcmd->i_state\t\t= ISTATE_SEND_TASKMGTRSP;\n\tcmd->immediate_cmd\t= ((hdr->opcode & ISCSI_OP_IMMEDIATE) ? 1 : 0);\n\tcmd->init_task_tag\t= hdr->itt;\n\tcmd->targ_xfer_tag\t= 0xFFFFFFFF;\n\tcmd->cmd_sn\t\t= be32_to_cpu(hdr->cmdsn);\n\tcmd->exp_stat_sn\t= be32_to_cpu(hdr->exp_statsn);\n\tse_tmr\t\t\t= cmd->se_cmd.se_tmr_req;\n\ttmr_req\t\t\t= cmd->tmr_req;\n\t \n\tif (function != ISCSI_TM_FUNC_TASK_REASSIGN) {\n\t\tret = transport_lookup_tmr_lun(&cmd->se_cmd);\n\t\tif (ret < 0) {\n\t\t\tse_tmr->response = ISCSI_TMF_RSP_NO_LUN;\n\t\t\tgoto attach;\n\t\t}\n\t}\n\n\tswitch (function) {\n\tcase ISCSI_TM_FUNC_ABORT_TASK:\n\t\tse_tmr->response = iscsit_tmr_abort_task(cmd, buf);\n\t\tif (se_tmr->response)\n\t\t\tgoto attach;\n\t\tbreak;\n\tcase ISCSI_TM_FUNC_ABORT_TASK_SET:\n\tcase ISCSI_TM_FUNC_CLEAR_ACA:\n\tcase ISCSI_TM_FUNC_CLEAR_TASK_SET:\n\tcase ISCSI_TM_FUNC_LOGICAL_UNIT_RESET:\n\t\tbreak;\n\tcase ISCSI_TM_FUNC_TARGET_WARM_RESET:\n\t\tif (iscsit_tmr_task_warm_reset(conn, tmr_req, buf) < 0) {\n\t\t\tse_tmr->response = ISCSI_TMF_RSP_AUTH_FAILED;\n\t\t\tgoto attach;\n\t\t}\n\t\tbreak;\n\tcase ISCSI_TM_FUNC_TARGET_COLD_RESET:\n\t\tif (iscsit_tmr_task_cold_reset(conn, tmr_req, buf) < 0) {\n\t\t\tse_tmr->response = ISCSI_TMF_RSP_AUTH_FAILED;\n\t\t\tgoto attach;\n\t\t}\n\t\tbreak;\n\tcase ISCSI_TM_FUNC_TASK_REASSIGN:\n\t\tse_tmr->response = iscsit_tmr_task_reassign(cmd, buf);\n\t\t \n\t\tif (se_tmr->response)\n\t\t\tbreak;\n\n\t\tif (iscsit_check_task_reassign_expdatasn(tmr_req, conn) < 0)\n\t\t\treturn iscsit_add_reject_cmd(cmd,\n\t\t\t\t\tISCSI_REASON_BOOKMARK_INVALID, buf);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown TMR function: 0x%02x, protocol\"\n\t\t\t\" error.\\n\", function);\n\t\tse_tmr->response = ISCSI_TMF_RSP_NOT_SUPPORTED;\n\t\tgoto attach;\n\t}\n\n\tif ((function != ISCSI_TM_FUNC_TASK_REASSIGN) &&\n\t    (se_tmr->response == ISCSI_TMF_RSP_COMPLETE))\n\t\tse_tmr->call_transport = 1;\nattach:\n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\n\tspin_unlock_bh(&conn->cmd_lock);\n\n\tif (!(hdr->opcode & ISCSI_OP_IMMEDIATE)) {\n\t\tint cmdsn_ret = iscsit_sequence_cmd(conn, cmd, buf, hdr->cmdsn);\n\t\tif (cmdsn_ret == CMDSN_HIGHER_THAN_EXP) {\n\t\t\tout_of_order_cmdsn = 1;\n\t\t} else if (cmdsn_ret == CMDSN_LOWER_THAN_EXP) {\n\t\t\ttarget_put_sess_cmd(&cmd->se_cmd);\n\t\t\treturn 0;\n\t\t} else if (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tiscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));\n\n\tif (out_of_order_cmdsn || !(hdr->opcode & ISCSI_OP_IMMEDIATE))\n\t\treturn 0;\n\t \n\tif (se_tmr->call_transport)\n\t\treturn transport_generic_handle_tmr(&cmd->se_cmd);\n\n\t \n\tiscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\n\ttarget_put_sess_cmd(&cmd->se_cmd);\n\treturn 0;\n}\nEXPORT_SYMBOL(iscsit_handle_task_mgt_cmd);\n\n \nint\niscsit_setup_text_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t      struct iscsi_text *hdr)\n{\n\tu32 payload_length = ntoh24(hdr->dlength);\n\n\tif (payload_length > conn->conn_ops->MaxXmitDataSegmentLength) {\n\t\tpr_err(\"Unable to accept text parameter length: %u\"\n\t\t\t\"greater than MaxXmitDataSegmentLength %u.\\n\",\n\t\t       payload_length, conn->conn_ops->MaxXmitDataSegmentLength);\n\t\treturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t\t (unsigned char *)hdr);\n\t}\n\n\tif (!(hdr->flags & ISCSI_FLAG_CMD_FINAL) ||\n\t     (hdr->flags & ISCSI_FLAG_TEXT_CONTINUE)) {\n\t\tpr_err(\"Multi sequence text commands currently not supported\\n\");\n\t\treturn iscsit_reject_cmd(cmd, ISCSI_REASON_CMD_NOT_SUPPORTED,\n\t\t\t\t\t(unsigned char *)hdr);\n\t}\n\n\tpr_debug(\"Got Text Request: ITT: 0x%08x, CmdSN: 0x%08x,\"\n\t\t\" ExpStatSN: 0x%08x, Length: %u\\n\", hdr->itt, hdr->cmdsn,\n\t\thdr->exp_statsn, payload_length);\n\n\tcmd->iscsi_opcode\t= ISCSI_OP_TEXT;\n\tcmd->i_state\t\t= ISTATE_SEND_TEXTRSP;\n\tcmd->immediate_cmd\t= ((hdr->opcode & ISCSI_OP_IMMEDIATE) ? 1 : 0);\n\tconn->sess->init_task_tag = cmd->init_task_tag  = hdr->itt;\n\tcmd->targ_xfer_tag\t= 0xFFFFFFFF;\n\tcmd->cmd_sn\t\t= be32_to_cpu(hdr->cmdsn);\n\tcmd->exp_stat_sn\t= be32_to_cpu(hdr->exp_statsn);\n\tcmd->data_direction\t= DMA_NONE;\n\tkfree(cmd->text_in_ptr);\n\tcmd->text_in_ptr\t= NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iscsit_setup_text_cmd);\n\nint\niscsit_process_text_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t\tstruct iscsi_text *hdr)\n{\n\tunsigned char *text_in = cmd->text_in_ptr, *text_ptr;\n\tint cmdsn_ret;\n\n\tif (!text_in) {\n\t\tcmd->targ_xfer_tag = be32_to_cpu(hdr->ttt);\n\t\tif (cmd->targ_xfer_tag == 0xFFFFFFFF) {\n\t\t\tpr_err(\"Unable to locate text_in buffer for sendtargets\"\n\t\t\t       \" discovery\\n\");\n\t\t\tgoto reject;\n\t\t}\n\t\tgoto empty_sendtargets;\n\t}\n\tif (strncmp(\"SendTargets=\", text_in, 12) != 0) {\n\t\tpr_err(\"Received Text Data that is not\"\n\t\t\t\" SendTargets, cannot continue.\\n\");\n\t\tgoto reject;\n\t}\n\t \n\ttext_ptr = strchr(text_in, '=');\n\tBUG_ON(!text_ptr);\n\tif (!strncmp(\"=All\", text_ptr, 5)) {\n\t\tcmd->cmd_flags |= ICF_SENDTARGETS_ALL;\n\t} else if (!strncmp(\"=iqn.\", text_ptr, 5) ||\n\t\t   !strncmp(\"=eui.\", text_ptr, 5)) {\n\t\tcmd->cmd_flags |= ICF_SENDTARGETS_SINGLE;\n\t} else {\n\t\tpr_err(\"Unable to locate valid SendTargets%s value\\n\",\n\t\t       text_ptr);\n\t\tgoto reject;\n\t}\n\n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\n\tspin_unlock_bh(&conn->cmd_lock);\n\nempty_sendtargets:\n\tiscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));\n\n\tif (!(hdr->opcode & ISCSI_OP_IMMEDIATE)) {\n\t\tcmdsn_ret = iscsit_sequence_cmd(conn, cmd,\n\t\t\t\t(unsigned char *)hdr, hdr->cmdsn);\n\t\tif (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)\n\t\t\treturn -1;\n\n\t\treturn 0;\n\t}\n\n\treturn iscsit_execute_cmd(cmd, 0);\n\nreject:\n\treturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t (unsigned char *)hdr);\n}\nEXPORT_SYMBOL(iscsit_process_text_cmd);\n\nstatic int\niscsit_handle_text_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t       unsigned char *buf)\n{\n\tstruct iscsi_text *hdr = (struct iscsi_text *)buf;\n\tchar *text_in = NULL;\n\tu32 payload_length = ntoh24(hdr->dlength);\n\tint rx_size, rc;\n\n\trc = iscsit_setup_text_cmd(conn, cmd, hdr);\n\tif (rc < 0)\n\t\treturn 0;\n\n\trx_size = payload_length;\n\tif (payload_length) {\n\t\tu32 checksum = 0, data_crc = 0;\n\t\tu32 padding = 0;\n\t\tint niov = 0, rx_got;\n\t\tstruct kvec iov[2];\n\n\t\trx_size = ALIGN(payload_length, 4);\n\t\ttext_in = kzalloc(rx_size, GFP_KERNEL);\n\t\tif (!text_in)\n\t\t\tgoto reject;\n\n\t\tcmd->text_in_ptr = text_in;\n\n\t\tmemset(iov, 0, sizeof(iov));\n\t\tiov[niov].iov_base\t= text_in;\n\t\tiov[niov++].iov_len\t= rx_size;\n\n\t\tpadding = rx_size - payload_length;\n\t\tif (padding)\n\t\t\tpr_debug(\"Receiving %u additional bytes\"\n\t\t\t\t\t\" for padding.\\n\", padding);\n\t\tif (conn->conn_ops->DataDigest) {\n\t\t\tiov[niov].iov_base\t= &checksum;\n\t\t\tiov[niov++].iov_len\t= ISCSI_CRC_LEN;\n\t\t\trx_size += ISCSI_CRC_LEN;\n\t\t}\n\n\t\tWARN_ON_ONCE(niov > ARRAY_SIZE(iov));\n\t\trx_got = rx_data(conn, &iov[0], niov, rx_size);\n\t\tif (rx_got != rx_size)\n\t\t\tgoto reject;\n\n\t\tif (conn->conn_ops->DataDigest) {\n\t\t\tiscsit_do_crypto_hash_buf(conn->conn_rx_hash,\n\t\t\t\t\t\t  text_in, rx_size, 0, NULL,\n\t\t\t\t\t\t  &data_crc);\n\n\t\t\tif (checksum != data_crc) {\n\t\t\t\tpr_err(\"Text data CRC32C DataDigest\"\n\t\t\t\t\t\" 0x%08x does not match computed\"\n\t\t\t\t\t\" 0x%08x\\n\", checksum, data_crc);\n\t\t\t\tif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\n\t\t\t\t\tpr_err(\"Unable to recover from\"\n\t\t\t\t\t\" Text Data digest failure while in\"\n\t\t\t\t\t\t\" ERL=0.\\n\");\n\t\t\t\t\tgoto reject;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tpr_debug(\"Dropping Text\"\n\t\t\t\t\t\" Command CmdSN: 0x%08x due to\"\n\t\t\t\t\t\" DataCRC error.\\n\", hdr->cmdsn);\n\t\t\t\t\tkfree(text_in);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpr_debug(\"Got CRC32C DataDigest\"\n\t\t\t\t\t\" 0x%08x for %u bytes of text data.\\n\",\n\t\t\t\t\t\tchecksum, payload_length);\n\t\t\t}\n\t\t}\n\t\ttext_in[payload_length - 1] = '\\0';\n\t\tpr_debug(\"Successfully read %d bytes of text\"\n\t\t\t\t\" data.\\n\", payload_length);\n\t}\n\n\treturn iscsit_process_text_cmd(conn, cmd, hdr);\n\nreject:\n\tkfree(cmd->text_in_ptr);\n\tcmd->text_in_ptr = NULL;\n\treturn iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR, buf);\n}\n\nint iscsit_logout_closesession(struct iscsit_cmd *cmd, struct iscsit_conn *conn)\n{\n\tstruct iscsit_conn *conn_p;\n\tstruct iscsit_session *sess = conn->sess;\n\n\tpr_debug(\"Received logout request CLOSESESSION on CID: %hu\"\n\t\t\" for SID: %u.\\n\", conn->cid, conn->sess->sid);\n\n\tatomic_set(&sess->session_logout, 1);\n\tatomic_set(&conn->conn_logout_remove, 1);\n\tconn->conn_logout_reason = ISCSI_LOGOUT_REASON_CLOSE_SESSION;\n\n\tiscsit_inc_conn_usage_count(conn);\n\tiscsit_inc_session_usage_count(sess);\n\n\tspin_lock_bh(&sess->conn_lock);\n\tlist_for_each_entry(conn_p, &sess->sess_conn_list, conn_list) {\n\t\tif (conn_p->conn_state != TARG_CONN_STATE_LOGGED_IN)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"Moving to TARG_CONN_STATE_IN_LOGOUT.\\n\");\n\t\tconn_p->conn_state = TARG_CONN_STATE_IN_LOGOUT;\n\t}\n\tspin_unlock_bh(&sess->conn_lock);\n\n\tiscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\n\n\treturn 0;\n}\n\nint iscsit_logout_closeconnection(struct iscsit_cmd *cmd, struct iscsit_conn *conn)\n{\n\tstruct iscsit_conn *l_conn;\n\tstruct iscsit_session *sess = conn->sess;\n\n\tpr_debug(\"Received logout request CLOSECONNECTION for CID:\"\n\t\t\" %hu on CID: %hu.\\n\", cmd->logout_cid, conn->cid);\n\n\t \n\tif (conn->cid == cmd->logout_cid) {\n\t\tspin_lock_bh(&conn->state_lock);\n\t\tpr_debug(\"Moving to TARG_CONN_STATE_IN_LOGOUT.\\n\");\n\t\tconn->conn_state = TARG_CONN_STATE_IN_LOGOUT;\n\n\t\tatomic_set(&conn->conn_logout_remove, 1);\n\t\tconn->conn_logout_reason = ISCSI_LOGOUT_REASON_CLOSE_CONNECTION;\n\t\tiscsit_inc_conn_usage_count(conn);\n\n\t\tspin_unlock_bh(&conn->state_lock);\n\t} else {\n\t\t \n\t\tl_conn = iscsit_get_conn_from_cid(sess,\n\t\t\t\tcmd->logout_cid);\n\t\tif (!l_conn) {\n\t\t\tcmd->logout_response = ISCSI_LOGOUT_CID_NOT_FOUND;\n\t\t\tiscsit_add_cmd_to_response_queue(cmd, conn,\n\t\t\t\t\tcmd->i_state);\n\t\t\treturn 0;\n\t\t}\n\n\t\tiscsit_dec_conn_usage_count(l_conn);\n\t}\n\n\tiscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\n\n\treturn 0;\n}\n\nint iscsit_logout_removeconnforrecovery(struct iscsit_cmd *cmd, struct iscsit_conn *conn)\n{\n\tstruct iscsit_session *sess = conn->sess;\n\n\tpr_debug(\"Received explicit REMOVECONNFORRECOVERY logout for\"\n\t\t\" CID: %hu on CID: %hu.\\n\", cmd->logout_cid, conn->cid);\n\n\tif (sess->sess_ops->ErrorRecoveryLevel != 2) {\n\t\tpr_err(\"Received Logout Request REMOVECONNFORRECOVERY\"\n\t\t\t\" while ERL!=2.\\n\");\n\t\tcmd->logout_response = ISCSI_LOGOUT_RECOVERY_UNSUPPORTED;\n\t\tiscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\n\t\treturn 0;\n\t}\n\n\tif (conn->cid == cmd->logout_cid) {\n\t\tpr_err(\"Received Logout Request REMOVECONNFORRECOVERY\"\n\t\t\t\" with CID: %hu on CID: %hu, implementation error.\\n\",\n\t\t\t\tcmd->logout_cid, conn->cid);\n\t\tcmd->logout_response = ISCSI_LOGOUT_CLEANUP_FAILED;\n\t\tiscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\n\t\treturn 0;\n\t}\n\n\tiscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\n\n\treturn 0;\n}\n\nint\niscsit_handle_logout_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd,\n\t\t\tunsigned char *buf)\n{\n\tint cmdsn_ret, logout_remove = 0;\n\tu8 reason_code = 0;\n\tstruct iscsi_logout *hdr;\n\tstruct iscsi_tiqn *tiqn = iscsit_snmp_get_tiqn(conn);\n\n\thdr\t\t\t= (struct iscsi_logout *) buf;\n\treason_code\t\t= (hdr->flags & 0x7f);\n\n\tif (tiqn) {\n\t\tspin_lock(&tiqn->logout_stats.lock);\n\t\tif (reason_code == ISCSI_LOGOUT_REASON_CLOSE_SESSION)\n\t\t\ttiqn->logout_stats.normal_logouts++;\n\t\telse\n\t\t\ttiqn->logout_stats.abnormal_logouts++;\n\t\tspin_unlock(&tiqn->logout_stats.lock);\n\t}\n\n\tpr_debug(\"Got Logout Request ITT: 0x%08x CmdSN: 0x%08x\"\n\t\t\" ExpStatSN: 0x%08x Reason: 0x%02x CID: %hu on CID: %hu\\n\",\n\t\thdr->itt, hdr->cmdsn, hdr->exp_statsn, reason_code,\n\t\thdr->cid, conn->cid);\n\n\tif (conn->conn_state != TARG_CONN_STATE_LOGGED_IN) {\n\t\tpr_err(\"Received logout request on connection that\"\n\t\t\t\" is not in logged in state, ignoring request.\\n\");\n\t\tiscsit_free_cmd(cmd, false);\n\t\treturn 0;\n\t}\n\n\tcmd->iscsi_opcode       = ISCSI_OP_LOGOUT;\n\tcmd->i_state            = ISTATE_SEND_LOGOUTRSP;\n\tcmd->immediate_cmd      = ((hdr->opcode & ISCSI_OP_IMMEDIATE) ? 1 : 0);\n\tconn->sess->init_task_tag = cmd->init_task_tag  = hdr->itt;\n\tcmd->targ_xfer_tag      = 0xFFFFFFFF;\n\tcmd->cmd_sn             = be32_to_cpu(hdr->cmdsn);\n\tcmd->exp_stat_sn        = be32_to_cpu(hdr->exp_statsn);\n\tcmd->logout_cid         = be16_to_cpu(hdr->cid);\n\tcmd->logout_reason      = reason_code;\n\tcmd->data_direction     = DMA_NONE;\n\n\t \n\tif ((reason_code == ISCSI_LOGOUT_REASON_CLOSE_SESSION) ||\n\t   ((reason_code == ISCSI_LOGOUT_REASON_CLOSE_CONNECTION) &&\n\t    be16_to_cpu(hdr->cid) == conn->cid))\n\t\tlogout_remove = 1;\n\n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);\n\tspin_unlock_bh(&conn->cmd_lock);\n\n\tif (reason_code != ISCSI_LOGOUT_REASON_RECOVERY)\n\t\tiscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));\n\n\t \n\tif (cmd->immediate_cmd) {\n\t\tint ret = iscsit_execute_cmd(cmd, 0);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tcmdsn_ret = iscsit_sequence_cmd(conn, cmd, buf, hdr->cmdsn);\n\t\tif (cmdsn_ret == CMDSN_LOWER_THAN_EXP)\n\t\t\tlogout_remove = 0;\n\t\telse if (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)\n\t\t\treturn -1;\n\t}\n\n\treturn logout_remove;\n}\nEXPORT_SYMBOL(iscsit_handle_logout_cmd);\n\nint iscsit_handle_snack(\n\tstruct iscsit_conn *conn,\n\tunsigned char *buf)\n{\n\tstruct iscsi_snack *hdr;\n\n\thdr\t\t\t= (struct iscsi_snack *) buf;\n\thdr->flags\t\t&= ~ISCSI_FLAG_CMD_FINAL;\n\n\tpr_debug(\"Got ISCSI_INIT_SNACK, ITT: 0x%08x, ExpStatSN:\"\n\t\t\" 0x%08x, Type: 0x%02x, BegRun: 0x%08x, RunLength: 0x%08x,\"\n\t\t\" CID: %hu\\n\", hdr->itt, hdr->exp_statsn, hdr->flags,\n\t\t\thdr->begrun, hdr->runlength, conn->cid);\n\n\tif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\n\t\tpr_err(\"Initiator sent SNACK request while in\"\n\t\t\t\" ErrorRecoveryLevel=0.\\n\");\n\t\treturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t\t buf);\n\t}\n\t \n\tswitch (hdr->flags & ISCSI_FLAG_SNACK_TYPE_MASK) {\n\tcase 0:\n\t\treturn iscsit_handle_recovery_datain_or_r2t(conn, buf,\n\t\t\thdr->itt,\n\t\t\tbe32_to_cpu(hdr->ttt),\n\t\t\tbe32_to_cpu(hdr->begrun),\n\t\t\tbe32_to_cpu(hdr->runlength));\n\tcase ISCSI_FLAG_SNACK_TYPE_STATUS:\n\t\treturn iscsit_handle_status_snack(conn, hdr->itt,\n\t\t\tbe32_to_cpu(hdr->ttt),\n\t\t\tbe32_to_cpu(hdr->begrun), be32_to_cpu(hdr->runlength));\n\tcase ISCSI_FLAG_SNACK_TYPE_DATA_ACK:\n\t\treturn iscsit_handle_data_ack(conn, be32_to_cpu(hdr->ttt),\n\t\t\tbe32_to_cpu(hdr->begrun),\n\t\t\tbe32_to_cpu(hdr->runlength));\n\tcase ISCSI_FLAG_SNACK_TYPE_RDATA:\n\t\t \n\t\tpr_err(\"R-Data SNACK Not Supported.\\n\");\n\t\treturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t\t buf);\n\tdefault:\n\t\tpr_err(\"Unknown SNACK type 0x%02x, protocol\"\n\t\t\t\" error.\\n\", hdr->flags & 0x0f);\n\t\treturn iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t\t buf);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iscsit_handle_snack);\n\nstatic void iscsit_rx_thread_wait_for_tcp(struct iscsit_conn *conn)\n{\n\tif ((conn->sock->sk->sk_shutdown & SEND_SHUTDOWN) ||\n\t    (conn->sock->sk->sk_shutdown & RCV_SHUTDOWN)) {\n\t\twait_for_completion_interruptible_timeout(\n\t\t\t\t\t&conn->rx_half_close_comp,\n\t\t\t\t\tISCSI_RX_THREAD_TCP_TIMEOUT * HZ);\n\t}\n}\n\nstatic int iscsit_handle_immediate_data(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsi_scsi_req *hdr,\n\tu32 length)\n{\n\tint iov_ret, rx_got = 0, rx_size = 0;\n\tu32 checksum, iov_count = 0, padding = 0;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct kvec *iov;\n\tvoid *overflow_buf = NULL;\n\n\tBUG_ON(cmd->write_data_done > cmd->se_cmd.data_length);\n\trx_size = min(cmd->se_cmd.data_length - cmd->write_data_done, length);\n\tiov_ret = iscsit_map_iovec(cmd, cmd->iov_data,\n\t\t\t\t   cmd->orig_iov_data_count - 2,\n\t\t\t\t   cmd->write_data_done, rx_size);\n\tif (iov_ret < 0)\n\t\treturn IMMEDIATE_DATA_CANNOT_RECOVER;\n\n\tiov_count = iov_ret;\n\tiov = &cmd->iov_data[0];\n\tif (rx_size < length) {\n\t\t \n\t\toverflow_buf = kmalloc(length - rx_size, GFP_KERNEL);\n\t\tif (!overflow_buf) {\n\t\t\tiscsit_unmap_iovec(cmd);\n\t\t\treturn IMMEDIATE_DATA_CANNOT_RECOVER;\n\t\t}\n\t\tcmd->overflow_buf = overflow_buf;\n\t\tiov[iov_count].iov_base = overflow_buf;\n\t\tiov[iov_count].iov_len = length - rx_size;\n\t\tiov_count++;\n\t\trx_size = length;\n\t}\n\n\tpadding = ((-length) & 3);\n\tif (padding != 0) {\n\t\tiov[iov_count].iov_base\t= cmd->pad_bytes;\n\t\tiov[iov_count++].iov_len = padding;\n\t\trx_size += padding;\n\t}\n\n\tif (conn->conn_ops->DataDigest) {\n\t\tiov[iov_count].iov_base\t\t= &checksum;\n\t\tiov[iov_count++].iov_len\t= ISCSI_CRC_LEN;\n\t\trx_size += ISCSI_CRC_LEN;\n\t}\n\n\tWARN_ON_ONCE(iov_count > cmd->orig_iov_data_count);\n\trx_got = rx_data(conn, &cmd->iov_data[0], iov_count, rx_size);\n\n\tiscsit_unmap_iovec(cmd);\n\n\tif (rx_got != rx_size) {\n\t\tiscsit_rx_thread_wait_for_tcp(conn);\n\t\treturn IMMEDIATE_DATA_CANNOT_RECOVER;\n\t}\n\n\tif (conn->conn_ops->DataDigest) {\n\t\tu32 data_crc;\n\n\t\tdata_crc = iscsit_do_crypto_hash_sg(conn->conn_rx_hash, cmd,\n\t\t\t\t\t\t    cmd->write_data_done, length, padding,\n\t\t\t\t\t\t    cmd->pad_bytes);\n\n\t\tif (checksum != data_crc) {\n\t\t\tpr_err(\"ImmediateData CRC32C DataDigest 0x%08x\"\n\t\t\t\t\" does not match computed 0x%08x\\n\", checksum,\n\t\t\t\tdata_crc);\n\n\t\t\tif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\n\t\t\t\tpr_err(\"Unable to recover from\"\n\t\t\t\t\t\" Immediate Data digest failure while\"\n\t\t\t\t\t\" in ERL=0.\\n\");\n\t\t\t\tiscsit_reject_cmd(cmd,\n\t\t\t\t\t\tISCSI_REASON_DATA_DIGEST_ERROR,\n\t\t\t\t\t\t(unsigned char *)hdr);\n\t\t\t\treturn IMMEDIATE_DATA_CANNOT_RECOVER;\n\t\t\t} else {\n\t\t\t\tiscsit_reject_cmd(cmd,\n\t\t\t\t\t\tISCSI_REASON_DATA_DIGEST_ERROR,\n\t\t\t\t\t\t(unsigned char *)hdr);\n\t\t\t\treturn IMMEDIATE_DATA_ERL1_CRC_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tpr_debug(\"Got CRC32C DataDigest 0x%08x for\"\n\t\t\t\t\" %u bytes of Immediate Data\\n\", checksum,\n\t\t\t\tlength);\n\t\t}\n\t}\n\n\tcmd->write_data_done += length;\n\n\tif (cmd->write_data_done == cmd->se_cmd.data_length) {\n\t\tspin_lock_bh(&cmd->istate_lock);\n\t\tcmd->cmd_flags |= ICF_GOT_LAST_DATAOUT;\n\t\tcmd->i_state = ISTATE_RECEIVED_LAST_DATAOUT;\n\t\tspin_unlock_bh(&cmd->istate_lock);\n\t}\n\n\treturn IMMEDIATE_DATA_NORMAL_OPERATION;\n}\n\n \nstatic void iscsit_build_conn_drop_async_message(struct iscsit_conn *conn)\n{\n\tstruct iscsit_cmd *cmd;\n\tstruct iscsit_conn *conn_p;\n\tbool found = false;\n\n\tlockdep_assert_held(&conn->sess->conn_lock);\n\n\t \n\tlist_for_each_entry(conn_p, &conn->sess->sess_conn_list, conn_list) {\n\t\tif (conn_p->conn_state == TARG_CONN_STATE_LOGGED_IN) {\n\t\t\tiscsit_inc_conn_usage_count(conn_p);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\tcmd = iscsit_allocate_cmd(conn_p, TASK_RUNNING);\n\tif (!cmd) {\n\t\tiscsit_dec_conn_usage_count(conn_p);\n\t\treturn;\n\t}\n\n\tcmd->logout_cid = conn->cid;\n\tcmd->iscsi_opcode = ISCSI_OP_ASYNC_EVENT;\n\tcmd->i_state = ISTATE_SEND_ASYNCMSG;\n\n\tspin_lock_bh(&conn_p->cmd_lock);\n\tlist_add_tail(&cmd->i_conn_node, &conn_p->conn_cmd_list);\n\tspin_unlock_bh(&conn_p->cmd_lock);\n\n\tiscsit_add_cmd_to_response_queue(cmd, conn_p, cmd->i_state);\n\tiscsit_dec_conn_usage_count(conn_p);\n}\n\nstatic int iscsit_send_conn_drop_async_message(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_conn *conn)\n{\n\tstruct iscsi_async *hdr;\n\n\tcmd->iscsi_opcode = ISCSI_OP_ASYNC_EVENT;\n\n\thdr\t\t\t= (struct iscsi_async *) cmd->pdu;\n\thdr->opcode\t\t= ISCSI_OP_ASYNC_EVENT;\n\thdr->flags\t\t= ISCSI_FLAG_CMD_FINAL;\n\tcmd->init_task_tag\t= RESERVED_ITT;\n\tcmd->targ_xfer_tag\t= 0xFFFFFFFF;\n\tput_unaligned_be64(0xFFFFFFFFFFFFFFFFULL, &hdr->rsvd4[0]);\n\tcmd->stat_sn\t\t= conn->stat_sn++;\n\thdr->statsn\t\t= cpu_to_be32(cmd->stat_sn);\n\thdr->exp_cmdsn\t\t= cpu_to_be32(conn->sess->exp_cmd_sn);\n\thdr->max_cmdsn\t\t= cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\n\thdr->async_event\t= ISCSI_ASYNC_MSG_DROPPING_CONNECTION;\n\thdr->param1\t\t= cpu_to_be16(cmd->logout_cid);\n\thdr->param2\t\t= cpu_to_be16(conn->sess->sess_ops->DefaultTime2Wait);\n\thdr->param3\t\t= cpu_to_be16(conn->sess->sess_ops->DefaultTime2Retain);\n\n\tpr_debug(\"Sending Connection Dropped Async Message StatSN:\"\n\t\t\" 0x%08x, for CID: %hu on CID: %hu\\n\", cmd->stat_sn,\n\t\t\tcmd->logout_cid, conn->cid);\n\n\treturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, NULL, 0);\n}\n\nstatic void iscsit_tx_thread_wait_for_tcp(struct iscsit_conn *conn)\n{\n\tif ((conn->sock->sk->sk_shutdown & SEND_SHUTDOWN) ||\n\t    (conn->sock->sk->sk_shutdown & RCV_SHUTDOWN)) {\n\t\twait_for_completion_interruptible_timeout(\n\t\t\t\t\t&conn->tx_half_close_comp,\n\t\t\t\t\tISCSI_TX_THREAD_TCP_TIMEOUT * HZ);\n\t}\n}\n\nvoid\niscsit_build_datain_pdu(struct iscsit_cmd *cmd, struct iscsit_conn *conn,\n\t\t\tstruct iscsi_datain *datain, struct iscsi_data_rsp *hdr,\n\t\t\tbool set_statsn)\n{\n\thdr->opcode\t\t= ISCSI_OP_SCSI_DATA_IN;\n\thdr->flags\t\t= datain->flags;\n\tif (hdr->flags & ISCSI_FLAG_DATA_STATUS) {\n\t\tif (cmd->se_cmd.se_cmd_flags & SCF_OVERFLOW_BIT) {\n\t\t\thdr->flags |= ISCSI_FLAG_DATA_OVERFLOW;\n\t\t\thdr->residual_count = cpu_to_be32(cmd->se_cmd.residual_count);\n\t\t} else if (cmd->se_cmd.se_cmd_flags & SCF_UNDERFLOW_BIT) {\n\t\t\thdr->flags |= ISCSI_FLAG_DATA_UNDERFLOW;\n\t\t\thdr->residual_count = cpu_to_be32(cmd->se_cmd.residual_count);\n\t\t}\n\t}\n\thton24(hdr->dlength, datain->length);\n\tif (hdr->flags & ISCSI_FLAG_DATA_ACK)\n\t\tint_to_scsilun(cmd->se_cmd.orig_fe_lun,\n\t\t\t\t(struct scsi_lun *)&hdr->lun);\n\telse\n\t\tput_unaligned_le64(0xFFFFFFFFFFFFFFFFULL, &hdr->lun);\n\n\thdr->itt\t\t= cmd->init_task_tag;\n\n\tif (hdr->flags & ISCSI_FLAG_DATA_ACK)\n\t\thdr->ttt\t\t= cpu_to_be32(cmd->targ_xfer_tag);\n\telse\n\t\thdr->ttt\t\t= cpu_to_be32(0xFFFFFFFF);\n\tif (set_statsn)\n\t\thdr->statsn\t\t= cpu_to_be32(cmd->stat_sn);\n\telse\n\t\thdr->statsn\t\t= cpu_to_be32(0xFFFFFFFF);\n\n\thdr->exp_cmdsn\t\t= cpu_to_be32(conn->sess->exp_cmd_sn);\n\thdr->max_cmdsn\t\t= cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\n\thdr->datasn\t\t= cpu_to_be32(datain->data_sn);\n\thdr->offset\t\t= cpu_to_be32(datain->offset);\n\n\tpr_debug(\"Built DataIN ITT: 0x%08x, StatSN: 0x%08x,\"\n\t\t\" DataSN: 0x%08x, Offset: %u, Length: %u, CID: %hu\\n\",\n\t\tcmd->init_task_tag, ntohl(hdr->statsn), ntohl(hdr->datasn),\n\t\tntohl(hdr->offset), datain->length, conn->cid);\n}\nEXPORT_SYMBOL(iscsit_build_datain_pdu);\n\nstatic int iscsit_send_datain(struct iscsit_cmd *cmd, struct iscsit_conn *conn)\n{\n\tstruct iscsi_data_rsp *hdr = (struct iscsi_data_rsp *)&cmd->pdu[0];\n\tstruct iscsi_datain datain;\n\tstruct iscsi_datain_req *dr;\n\tint eodr = 0, ret;\n\tbool set_statsn = false;\n\n\tmemset(&datain, 0, sizeof(struct iscsi_datain));\n\tdr = iscsit_get_datain_values(cmd, &datain);\n\tif (!dr) {\n\t\tpr_err(\"iscsit_get_datain_values failed for ITT: 0x%08x\\n\",\n\t\t\t\tcmd->init_task_tag);\n\t\treturn -1;\n\t}\n\t \n\tif ((datain.offset + datain.length) > cmd->se_cmd.data_length) {\n\t\tpr_err(\"Command ITT: 0x%08x, datain.offset: %u and\"\n\t\t\t\" datain.length: %u exceeds cmd->data_length: %u\\n\",\n\t\t\tcmd->init_task_tag, datain.offset, datain.length,\n\t\t\tcmd->se_cmd.data_length);\n\t\treturn -1;\n\t}\n\n\tatomic_long_add(datain.length, &conn->sess->tx_data_octets);\n\t \n\tif ((datain.flags & ISCSI_FLAG_DATA_STATUS) &&\n\t    (cmd->se_cmd.se_cmd_flags & SCF_TRANSPORT_TASK_SENSE))\n\t\tdatain.flags &= ~ISCSI_FLAG_DATA_STATUS;\n\telse {\n\t\tif ((dr->dr_complete == DATAIN_COMPLETE_NORMAL) ||\n\t\t    (dr->dr_complete == DATAIN_COMPLETE_CONNECTION_RECOVERY)) {\n\t\t\tiscsit_increment_maxcmdsn(cmd, conn->sess);\n\t\t\tcmd->stat_sn = conn->stat_sn++;\n\t\t\tset_statsn = true;\n\t\t} else if (dr->dr_complete ==\n\t\t\t   DATAIN_COMPLETE_WITHIN_COMMAND_RECOVERY)\n\t\t\tset_statsn = true;\n\t}\n\n\tiscsit_build_datain_pdu(cmd, conn, &datain, hdr, set_statsn);\n\n\tret = conn->conn_transport->iscsit_xmit_pdu(conn, cmd, dr, &datain, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dr->dr_complete) {\n\t\teodr = (cmd->se_cmd.se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ?\n\t\t\t\t2 : 1;\n\t\tiscsit_free_datain_req(cmd, dr);\n\t}\n\n\treturn eodr;\n}\n\nint\niscsit_build_logout_rsp(struct iscsit_cmd *cmd, struct iscsit_conn *conn,\n\t\t\tstruct iscsi_logout_rsp *hdr)\n{\n\tstruct iscsit_conn *logout_conn = NULL;\n\tstruct iscsi_conn_recovery *cr = NULL;\n\tstruct iscsit_session *sess = conn->sess;\n\t \n\tswitch (cmd->logout_reason) {\n\tcase ISCSI_LOGOUT_REASON_CLOSE_SESSION:\n\t\tpr_debug(\"iSCSI session logout successful, setting\"\n\t\t\t\" logout response to ISCSI_LOGOUT_SUCCESS.\\n\");\n\t\tcmd->logout_response = ISCSI_LOGOUT_SUCCESS;\n\t\tbreak;\n\tcase ISCSI_LOGOUT_REASON_CLOSE_CONNECTION:\n\t\tif (cmd->logout_response == ISCSI_LOGOUT_CID_NOT_FOUND)\n\t\t\tbreak;\n\t\t \n\n\t\tpr_debug(\"iSCSI CID: %hu logout on CID: %hu\"\n\t\t\t\" successful.\\n\", cmd->logout_cid, conn->cid);\n\t\tcmd->logout_response = ISCSI_LOGOUT_SUCCESS;\n\t\tbreak;\n\tcase ISCSI_LOGOUT_REASON_RECOVERY:\n\t\tif ((cmd->logout_response == ISCSI_LOGOUT_RECOVERY_UNSUPPORTED) ||\n\t\t    (cmd->logout_response == ISCSI_LOGOUT_CLEANUP_FAILED))\n\t\t\tbreak;\n\t\t \n\t\tlogout_conn = iscsit_get_conn_from_cid_rcfr(sess,\n\t\t\t\tcmd->logout_cid);\n\t\tif (logout_conn) {\n\t\t\tiscsit_connection_reinstatement_rcfr(logout_conn);\n\t\t\tiscsit_dec_conn_usage_count(logout_conn);\n\t\t}\n\n\t\tcr = iscsit_get_inactive_connection_recovery_entry(\n\t\t\t\tconn->sess, cmd->logout_cid);\n\t\tif (!cr) {\n\t\t\tpr_err(\"Unable to locate CID: %hu for\"\n\t\t\t\" REMOVECONNFORRECOVERY Logout Request.\\n\",\n\t\t\t\tcmd->logout_cid);\n\t\t\tcmd->logout_response = ISCSI_LOGOUT_CID_NOT_FOUND;\n\t\t\tbreak;\n\t\t}\n\n\t\tiscsit_discard_cr_cmds_by_expstatsn(cr, cmd->exp_stat_sn);\n\n\t\tpr_debug(\"iSCSI REMOVECONNFORRECOVERY logout\"\n\t\t\t\" for recovery for CID: %hu on CID: %hu successful.\\n\",\n\t\t\t\tcmd->logout_cid, conn->cid);\n\t\tcmd->logout_response = ISCSI_LOGOUT_SUCCESS;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown cmd->logout_reason: 0x%02x\\n\",\n\t\t\t\tcmd->logout_reason);\n\t\treturn -1;\n\t}\n\n\thdr->opcode\t\t= ISCSI_OP_LOGOUT_RSP;\n\thdr->flags\t\t|= ISCSI_FLAG_CMD_FINAL;\n\thdr->response\t\t= cmd->logout_response;\n\thdr->itt\t\t= cmd->init_task_tag;\n\tcmd->stat_sn\t\t= conn->stat_sn++;\n\thdr->statsn\t\t= cpu_to_be32(cmd->stat_sn);\n\n\tiscsit_increment_maxcmdsn(cmd, conn->sess);\n\thdr->exp_cmdsn\t\t= cpu_to_be32(conn->sess->exp_cmd_sn);\n\thdr->max_cmdsn\t\t= cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\n\n\tpr_debug(\"Built Logout Response ITT: 0x%08x StatSN:\"\n\t\t\" 0x%08x Response: 0x%02x CID: %hu on CID: %hu\\n\",\n\t\tcmd->init_task_tag, cmd->stat_sn, hdr->response,\n\t\tcmd->logout_cid, conn->cid);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iscsit_build_logout_rsp);\n\nstatic int\niscsit_send_logout(struct iscsit_cmd *cmd, struct iscsit_conn *conn)\n{\n\tint rc;\n\n\trc = iscsit_build_logout_rsp(cmd, conn,\n\t\t\t(struct iscsi_logout_rsp *)&cmd->pdu[0]);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, NULL, 0);\n}\n\nvoid\niscsit_build_nopin_rsp(struct iscsit_cmd *cmd, struct iscsit_conn *conn,\n\t\t       struct iscsi_nopin *hdr, bool nopout_response)\n{\n\thdr->opcode\t\t= ISCSI_OP_NOOP_IN;\n\thdr->flags\t\t|= ISCSI_FLAG_CMD_FINAL;\n        hton24(hdr->dlength, cmd->buf_ptr_size);\n\tif (nopout_response)\n\t\tput_unaligned_le64(0xFFFFFFFFFFFFFFFFULL, &hdr->lun);\n\thdr->itt\t\t= cmd->init_task_tag;\n\thdr->ttt\t\t= cpu_to_be32(cmd->targ_xfer_tag);\n\tcmd->stat_sn\t\t= (nopout_response) ? conn->stat_sn++ :\n\t\t\t\t  conn->stat_sn;\n\thdr->statsn\t\t= cpu_to_be32(cmd->stat_sn);\n\n\tif (nopout_response)\n\t\tiscsit_increment_maxcmdsn(cmd, conn->sess);\n\n\thdr->exp_cmdsn\t\t= cpu_to_be32(conn->sess->exp_cmd_sn);\n\thdr->max_cmdsn\t\t= cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\n\n\tpr_debug(\"Built NOPIN %s Response ITT: 0x%08x, TTT: 0x%08x,\"\n\t\t\" StatSN: 0x%08x, Length %u\\n\", (nopout_response) ?\n\t\t\"Solicited\" : \"Unsolicited\", cmd->init_task_tag,\n\t\tcmd->targ_xfer_tag, cmd->stat_sn, cmd->buf_ptr_size);\n}\nEXPORT_SYMBOL(iscsit_build_nopin_rsp);\n\n \nstatic int iscsit_send_unsolicited_nopin(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_conn *conn,\n\tint want_response)\n{\n\tstruct iscsi_nopin *hdr = (struct iscsi_nopin *)&cmd->pdu[0];\n\tint ret;\n\n\tiscsit_build_nopin_rsp(cmd, conn, hdr, false);\n\n\tpr_debug(\"Sending Unsolicited NOPIN TTT: 0x%08x StatSN:\"\n\t\t\" 0x%08x CID: %hu\\n\", hdr->ttt, cmd->stat_sn, conn->cid);\n\n\tret = conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, NULL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tspin_lock_bh(&cmd->istate_lock);\n\tcmd->i_state = want_response ?\n\t\tISTATE_SENT_NOPIN_WANT_RESPONSE : ISTATE_SENT_STATUS;\n\tspin_unlock_bh(&cmd->istate_lock);\n\n\treturn 0;\n}\n\nstatic int\niscsit_send_nopin(struct iscsit_cmd *cmd, struct iscsit_conn *conn)\n{\n\tstruct iscsi_nopin *hdr = (struct iscsi_nopin *)&cmd->pdu[0];\n\n\tiscsit_build_nopin_rsp(cmd, conn, hdr, true);\n\n\t \n\tpr_debug(\"Echoing back %u bytes of ping data.\\n\", cmd->buf_ptr_size);\n\n\treturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL,\n\t\t\t\t\t\t     cmd->buf_ptr,\n\t\t\t\t\t\t     cmd->buf_ptr_size);\n}\n\nstatic int iscsit_send_r2t(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_conn *conn)\n{\n\tstruct iscsi_r2t *r2t;\n\tstruct iscsi_r2t_rsp *hdr;\n\tint ret;\n\n\tr2t = iscsit_get_r2t_from_list(cmd);\n\tif (!r2t)\n\t\treturn -1;\n\n\thdr\t\t\t= (struct iscsi_r2t_rsp *) cmd->pdu;\n\tmemset(hdr, 0, ISCSI_HDR_LEN);\n\thdr->opcode\t\t= ISCSI_OP_R2T;\n\thdr->flags\t\t|= ISCSI_FLAG_CMD_FINAL;\n\tint_to_scsilun(cmd->se_cmd.orig_fe_lun,\n\t\t\t(struct scsi_lun *)&hdr->lun);\n\thdr->itt\t\t= cmd->init_task_tag;\n\tif (conn->conn_transport->iscsit_get_r2t_ttt)\n\t\tconn->conn_transport->iscsit_get_r2t_ttt(conn, cmd, r2t);\n\telse\n\t\tr2t->targ_xfer_tag = session_get_next_ttt(conn->sess);\n\thdr->ttt\t\t= cpu_to_be32(r2t->targ_xfer_tag);\n\thdr->statsn\t\t= cpu_to_be32(conn->stat_sn);\n\thdr->exp_cmdsn\t\t= cpu_to_be32(conn->sess->exp_cmd_sn);\n\thdr->max_cmdsn\t\t= cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\n\thdr->r2tsn\t\t= cpu_to_be32(r2t->r2t_sn);\n\thdr->data_offset\t= cpu_to_be32(r2t->offset);\n\thdr->data_length\t= cpu_to_be32(r2t->xfer_len);\n\n\tpr_debug(\"Built %sR2T, ITT: 0x%08x, TTT: 0x%08x, StatSN:\"\n\t\t\" 0x%08x, R2TSN: 0x%08x, Offset: %u, DDTL: %u, CID: %hu\\n\",\n\t\t(!r2t->recovery_r2t) ? \"\" : \"Recovery \", cmd->init_task_tag,\n\t\tr2t->targ_xfer_tag, ntohl(hdr->statsn), r2t->r2t_sn,\n\t\t\tr2t->offset, r2t->xfer_len, conn->cid);\n\n\tspin_lock_bh(&cmd->r2t_lock);\n\tr2t->sent_r2t = 1;\n\tspin_unlock_bh(&cmd->r2t_lock);\n\n\tret = conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, NULL, 0);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tspin_lock_bh(&cmd->dataout_timeout_lock);\n\tiscsit_start_dataout_timer(cmd, conn);\n\tspin_unlock_bh(&cmd->dataout_timeout_lock);\n\n\treturn 0;\n}\n\n \nint iscsit_build_r2ts_for_cmd(\n\tstruct iscsit_conn *conn,\n\tstruct iscsit_cmd *cmd,\n\tbool recovery)\n{\n\tint first_r2t = 1;\n\tu32 offset = 0, xfer_len = 0;\n\n\tspin_lock_bh(&cmd->r2t_lock);\n\tif (cmd->cmd_flags & ICF_SENT_LAST_R2T) {\n\t\tspin_unlock_bh(&cmd->r2t_lock);\n\t\treturn 0;\n\t}\n\n\tif (conn->sess->sess_ops->DataSequenceInOrder &&\n\t    !recovery)\n\t\tcmd->r2t_offset = max(cmd->r2t_offset, cmd->write_data_done);\n\n\twhile (cmd->outstanding_r2ts < conn->sess->sess_ops->MaxOutstandingR2T) {\n\t\tif (conn->sess->sess_ops->DataSequenceInOrder) {\n\t\t\toffset = cmd->r2t_offset;\n\n\t\t\tif (first_r2t && recovery) {\n\t\t\t\tint new_data_end = offset +\n\t\t\t\t\tconn->sess->sess_ops->MaxBurstLength -\n\t\t\t\t\tcmd->next_burst_len;\n\n\t\t\t\tif (new_data_end > cmd->se_cmd.data_length)\n\t\t\t\t\txfer_len = cmd->se_cmd.data_length - offset;\n\t\t\t\telse\n\t\t\t\t\txfer_len =\n\t\t\t\t\t\tconn->sess->sess_ops->MaxBurstLength -\n\t\t\t\t\t\tcmd->next_burst_len;\n\t\t\t} else {\n\t\t\t\tint new_data_end = offset +\n\t\t\t\t\tconn->sess->sess_ops->MaxBurstLength;\n\n\t\t\t\tif (new_data_end > cmd->se_cmd.data_length)\n\t\t\t\t\txfer_len = cmd->se_cmd.data_length - offset;\n\t\t\t\telse\n\t\t\t\t\txfer_len = conn->sess->sess_ops->MaxBurstLength;\n\t\t\t}\n\n\t\t\tif ((s32)xfer_len < 0) {\n\t\t\t\tcmd->cmd_flags |= ICF_SENT_LAST_R2T;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcmd->r2t_offset += xfer_len;\n\n\t\t\tif (cmd->r2t_offset == cmd->se_cmd.data_length)\n\t\t\t\tcmd->cmd_flags |= ICF_SENT_LAST_R2T;\n\t\t} else {\n\t\t\tstruct iscsi_seq *seq;\n\n\t\t\tseq = iscsit_get_seq_holder_for_r2t(cmd);\n\t\t\tif (!seq) {\n\t\t\t\tspin_unlock_bh(&cmd->r2t_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\toffset = seq->offset;\n\t\t\txfer_len = seq->xfer_len;\n\n\t\t\tif (cmd->seq_send_order == cmd->seq_count)\n\t\t\t\tcmd->cmd_flags |= ICF_SENT_LAST_R2T;\n\t\t}\n\t\tcmd->outstanding_r2ts++;\n\t\tfirst_r2t = 0;\n\n\t\tif (iscsit_add_r2t_to_list(cmd, offset, xfer_len, 0, 0) < 0) {\n\t\t\tspin_unlock_bh(&cmd->r2t_lock);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (cmd->cmd_flags & ICF_SENT_LAST_R2T)\n\t\t\tbreak;\n\t}\n\tspin_unlock_bh(&cmd->r2t_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iscsit_build_r2ts_for_cmd);\n\nvoid iscsit_build_rsp_pdu(struct iscsit_cmd *cmd, struct iscsit_conn *conn,\n\t\t\tbool inc_stat_sn, struct iscsi_scsi_rsp *hdr)\n{\n\tif (inc_stat_sn)\n\t\tcmd->stat_sn = conn->stat_sn++;\n\n\tatomic_long_inc(&conn->sess->rsp_pdus);\n\n\tmemset(hdr, 0, ISCSI_HDR_LEN);\n\thdr->opcode\t\t= ISCSI_OP_SCSI_CMD_RSP;\n\thdr->flags\t\t|= ISCSI_FLAG_CMD_FINAL;\n\tif (cmd->se_cmd.se_cmd_flags & SCF_OVERFLOW_BIT) {\n\t\thdr->flags |= ISCSI_FLAG_CMD_OVERFLOW;\n\t\thdr->residual_count = cpu_to_be32(cmd->se_cmd.residual_count);\n\t} else if (cmd->se_cmd.se_cmd_flags & SCF_UNDERFLOW_BIT) {\n\t\thdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;\n\t\thdr->residual_count = cpu_to_be32(cmd->se_cmd.residual_count);\n\t}\n\thdr->response\t\t= cmd->iscsi_response;\n\thdr->cmd_status\t\t= cmd->se_cmd.scsi_status;\n\thdr->itt\t\t= cmd->init_task_tag;\n\thdr->statsn\t\t= cpu_to_be32(cmd->stat_sn);\n\n\tiscsit_increment_maxcmdsn(cmd, conn->sess);\n\thdr->exp_cmdsn\t\t= cpu_to_be32(conn->sess->exp_cmd_sn);\n\thdr->max_cmdsn\t\t= cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\n\n\tpr_debug(\"Built SCSI Response, ITT: 0x%08x, StatSN: 0x%08x,\"\n\t\t\" Response: 0x%02x, SAM Status: 0x%02x, CID: %hu\\n\",\n\t\tcmd->init_task_tag, cmd->stat_sn, cmd->se_cmd.scsi_status,\n\t\tcmd->se_cmd.scsi_status, conn->cid);\n}\nEXPORT_SYMBOL(iscsit_build_rsp_pdu);\n\nstatic int iscsit_send_response(struct iscsit_cmd *cmd, struct iscsit_conn *conn)\n{\n\tstruct iscsi_scsi_rsp *hdr = (struct iscsi_scsi_rsp *)&cmd->pdu[0];\n\tbool inc_stat_sn = (cmd->i_state == ISTATE_SEND_STATUS);\n\tvoid *data_buf = NULL;\n\tu32 padding = 0, data_buf_len = 0;\n\n\tiscsit_build_rsp_pdu(cmd, conn, inc_stat_sn, hdr);\n\n\t \n\tif (cmd->se_cmd.sense_buffer &&\n\t   ((cmd->se_cmd.se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ||\n\t    (cmd->se_cmd.se_cmd_flags & SCF_EMULATED_TASK_SENSE))) {\n\t\tput_unaligned_be16(cmd->se_cmd.scsi_sense_length, cmd->sense_buffer);\n\t\tcmd->se_cmd.scsi_sense_length += sizeof (__be16);\n\n\t\tpadding\t\t= -(cmd->se_cmd.scsi_sense_length) & 3;\n\t\thton24(hdr->dlength, (u32)cmd->se_cmd.scsi_sense_length);\n\t\tdata_buf = cmd->sense_buffer;\n\t\tdata_buf_len = cmd->se_cmd.scsi_sense_length + padding;\n\n\t\tif (padding) {\n\t\t\tmemset(cmd->sense_buffer +\n\t\t\t\tcmd->se_cmd.scsi_sense_length, 0, padding);\n\t\t\tpr_debug(\"Adding %u bytes of padding to\"\n\t\t\t\t\" SENSE.\\n\", padding);\n\t\t}\n\n\t\tpr_debug(\"Attaching SENSE DATA: %u bytes to iSCSI\"\n\t\t\t\t\" Response PDU\\n\",\n\t\t\t\tcmd->se_cmd.scsi_sense_length);\n\t}\n\n\treturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, data_buf,\n\t\t\t\t\t\t     data_buf_len);\n}\n\nstatic u8 iscsit_convert_tcm_tmr_rsp(struct se_tmr_req *se_tmr)\n{\n\tswitch (se_tmr->response) {\n\tcase TMR_FUNCTION_COMPLETE:\n\t\treturn ISCSI_TMF_RSP_COMPLETE;\n\tcase TMR_TASK_DOES_NOT_EXIST:\n\t\treturn ISCSI_TMF_RSP_NO_TASK;\n\tcase TMR_LUN_DOES_NOT_EXIST:\n\t\treturn ISCSI_TMF_RSP_NO_LUN;\n\tcase TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED:\n\t\treturn ISCSI_TMF_RSP_NOT_SUPPORTED;\n\tcase TMR_FUNCTION_REJECTED:\n\tdefault:\n\t\treturn ISCSI_TMF_RSP_REJECTED;\n\t}\n}\n\nvoid\niscsit_build_task_mgt_rsp(struct iscsit_cmd *cmd, struct iscsit_conn *conn,\n\t\t\t  struct iscsi_tm_rsp *hdr)\n{\n\tstruct se_tmr_req *se_tmr = cmd->se_cmd.se_tmr_req;\n\n\thdr->opcode\t\t= ISCSI_OP_SCSI_TMFUNC_RSP;\n\thdr->flags\t\t= ISCSI_FLAG_CMD_FINAL;\n\thdr->response\t\t= iscsit_convert_tcm_tmr_rsp(se_tmr);\n\thdr->itt\t\t= cmd->init_task_tag;\n\tcmd->stat_sn\t\t= conn->stat_sn++;\n\thdr->statsn\t\t= cpu_to_be32(cmd->stat_sn);\n\n\tiscsit_increment_maxcmdsn(cmd, conn->sess);\n\thdr->exp_cmdsn\t\t= cpu_to_be32(conn->sess->exp_cmd_sn);\n\thdr->max_cmdsn\t\t= cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\n\n\tpr_debug(\"Built Task Management Response ITT: 0x%08x,\"\n\t\t\" StatSN: 0x%08x, Response: 0x%02x, CID: %hu\\n\",\n\t\tcmd->init_task_tag, cmd->stat_sn, hdr->response, conn->cid);\n}\nEXPORT_SYMBOL(iscsit_build_task_mgt_rsp);\n\nstatic int\niscsit_send_task_mgt_rsp(struct iscsit_cmd *cmd, struct iscsit_conn *conn)\n{\n\tstruct iscsi_tm_rsp *hdr = (struct iscsi_tm_rsp *)&cmd->pdu[0];\n\n\tiscsit_build_task_mgt_rsp(cmd, conn, hdr);\n\n\treturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL, NULL, 0);\n}\n\n#define SENDTARGETS_BUF_LIMIT 32768U\n\nstatic int\niscsit_build_sendtargets_response(struct iscsit_cmd *cmd,\n\t\t\t\t  enum iscsit_transport_type network_transport,\n\t\t\t\t  int skip_bytes, bool *completed)\n{\n\tchar *payload = NULL;\n\tstruct iscsit_conn *conn = cmd->conn;\n\tstruct iscsi_portal_group *tpg;\n\tstruct iscsi_tiqn *tiqn;\n\tstruct iscsi_tpg_np *tpg_np;\n\tint buffer_len, end_of_buf = 0, len = 0, payload_len = 0;\n\tint target_name_printed;\n\tunsigned char buf[ISCSI_IQN_LEN+12];  \n\tunsigned char *text_in = cmd->text_in_ptr, *text_ptr = NULL;\n\tbool active;\n\n\tbuffer_len = min(conn->conn_ops->MaxRecvDataSegmentLength,\n\t\t\t SENDTARGETS_BUF_LIMIT);\n\n\tpayload = kzalloc(buffer_len, GFP_KERNEL);\n\tif (!payload)\n\t\treturn -ENOMEM;\n\n\t \n\tif (cmd->cmd_flags & ICF_SENDTARGETS_SINGLE) {\n\t\ttext_ptr = strchr(text_in, '=');\n\t\tif (!text_ptr) {\n\t\t\tpr_err(\"Unable to locate '=' string in text_in:\"\n\t\t\t       \" %s\\n\", text_in);\n\t\t\tkfree(payload);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\ttext_ptr += 1;\n\t}\n\n\tspin_lock(&tiqn_lock);\n\tlist_for_each_entry(tiqn, &g_tiqn_list, tiqn_list) {\n\t\tif ((cmd->cmd_flags & ICF_SENDTARGETS_SINGLE) &&\n\t\t     strcmp(tiqn->tiqn, text_ptr)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ttarget_name_printed = 0;\n\n\t\tspin_lock(&tiqn->tiqn_tpg_lock);\n\t\tlist_for_each_entry(tpg, &tiqn->tiqn_tpg_list, tpg_list) {\n\n\t\t\t \n\n\t\t\tif ((tpg->tpg_attrib.generate_node_acls == 0) &&\n\t\t\t    (tpg->tpg_attrib.demo_mode_discovery == 0) &&\n\t\t\t    (!target_tpg_has_node_acl(&tpg->tpg_se_tpg,\n\t\t\t\tcmd->conn->sess->sess_ops->InitiatorName))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspin_lock(&tpg->tpg_state_lock);\n\t\t\tactive = (tpg->tpg_state == TPG_STATE_ACTIVE);\n\t\t\tspin_unlock(&tpg->tpg_state_lock);\n\n\t\t\tif (!active && tpg->tpg_attrib.tpg_enabled_sendtargets)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock(&tpg->tpg_np_lock);\n\t\t\tlist_for_each_entry(tpg_np, &tpg->tpg_gnp_list,\n\t\t\t\t\t\ttpg_np_list) {\n\t\t\t\tstruct iscsi_np *np = tpg_np->tpg_np;\n\t\t\t\tstruct sockaddr_storage *sockaddr;\n\n\t\t\t\tif (np->np_network_transport != network_transport)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!target_name_printed) {\n\t\t\t\t\tlen = sprintf(buf, \"TargetName=%s\",\n\t\t\t\t\t\t      tiqn->tiqn);\n\t\t\t\t\tlen += 1;\n\n\t\t\t\t\tif ((len + payload_len) > buffer_len) {\n\t\t\t\t\t\tspin_unlock(&tpg->tpg_np_lock);\n\t\t\t\t\t\tspin_unlock(&tiqn->tiqn_tpg_lock);\n\t\t\t\t\t\tend_of_buf = 1;\n\t\t\t\t\t\tgoto eob;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (skip_bytes && len <= skip_bytes) {\n\t\t\t\t\t\tskip_bytes -= len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmemcpy(payload + payload_len, buf, len);\n\t\t\t\t\t\tpayload_len += len;\n\t\t\t\t\t\ttarget_name_printed = 1;\n\t\t\t\t\t\tif (len > skip_bytes)\n\t\t\t\t\t\t\tskip_bytes = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (inet_addr_is_any((struct sockaddr *)&np->np_sockaddr))\n\t\t\t\t\tsockaddr = &conn->local_sockaddr;\n\t\t\t\telse\n\t\t\t\t\tsockaddr = &np->np_sockaddr;\n\n\t\t\t\tlen = sprintf(buf, \"TargetAddress=\"\n\t\t\t\t\t      \"%pISpc,%hu\",\n\t\t\t\t\t      sockaddr,\n\t\t\t\t\t      tpg->tpgt);\n\t\t\t\tlen += 1;\n\n\t\t\t\tif ((len + payload_len) > buffer_len) {\n\t\t\t\t\tspin_unlock(&tpg->tpg_np_lock);\n\t\t\t\t\tspin_unlock(&tiqn->tiqn_tpg_lock);\n\t\t\t\t\tend_of_buf = 1;\n\t\t\t\t\tgoto eob;\n\t\t\t\t}\n\n\t\t\t\tif (skip_bytes && len <= skip_bytes) {\n\t\t\t\t\tskip_bytes -= len;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(payload + payload_len, buf, len);\n\t\t\t\t\tpayload_len += len;\n\t\t\t\t\tif (len > skip_bytes)\n\t\t\t\t\t\tskip_bytes = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&tpg->tpg_np_lock);\n\t\t}\n\t\tspin_unlock(&tiqn->tiqn_tpg_lock);\neob:\n\t\tif (end_of_buf) {\n\t\t\t*completed = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd->cmd_flags & ICF_SENDTARGETS_SINGLE)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&tiqn_lock);\n\n\tcmd->buf_ptr = payload;\n\n\treturn payload_len;\n}\n\nint\niscsit_build_text_rsp(struct iscsit_cmd *cmd, struct iscsit_conn *conn,\n\t\t      struct iscsi_text_rsp *hdr,\n\t\t      enum iscsit_transport_type network_transport)\n{\n\tint text_length, padding;\n\tbool completed = true;\n\n\ttext_length = iscsit_build_sendtargets_response(cmd, network_transport,\n\t\t\t\t\t\t\tcmd->read_data_done,\n\t\t\t\t\t\t\t&completed);\n\tif (text_length < 0)\n\t\treturn text_length;\n\n\tif (completed) {\n\t\thdr->flags = ISCSI_FLAG_CMD_FINAL;\n\t} else {\n\t\thdr->flags = ISCSI_FLAG_TEXT_CONTINUE;\n\t\tcmd->read_data_done += text_length;\n\t\tif (cmd->targ_xfer_tag == 0xFFFFFFFF)\n\t\t\tcmd->targ_xfer_tag = session_get_next_ttt(conn->sess);\n\t}\n\thdr->opcode = ISCSI_OP_TEXT_RSP;\n\tpadding = ((-text_length) & 3);\n\thton24(hdr->dlength, text_length);\n\thdr->itt = cmd->init_task_tag;\n\thdr->ttt = cpu_to_be32(cmd->targ_xfer_tag);\n\tcmd->stat_sn = conn->stat_sn++;\n\thdr->statsn = cpu_to_be32(cmd->stat_sn);\n\n\tiscsit_increment_maxcmdsn(cmd, conn->sess);\n\t \n\tcmd->maxcmdsn_inc = 0;\n\thdr->exp_cmdsn = cpu_to_be32(conn->sess->exp_cmd_sn);\n\thdr->max_cmdsn = cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\n\n\tpr_debug(\"Built Text Response: ITT: 0x%08x, TTT: 0x%08x, StatSN: 0x%08x,\"\n\t\t\" Length: %u, CID: %hu F: %d C: %d\\n\", cmd->init_task_tag,\n\t\tcmd->targ_xfer_tag, cmd->stat_sn, text_length, conn->cid,\n\t\t!!(hdr->flags & ISCSI_FLAG_CMD_FINAL),\n\t\t!!(hdr->flags & ISCSI_FLAG_TEXT_CONTINUE));\n\n\treturn text_length + padding;\n}\nEXPORT_SYMBOL(iscsit_build_text_rsp);\n\nstatic int iscsit_send_text_rsp(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_conn *conn)\n{\n\tstruct iscsi_text_rsp *hdr = (struct iscsi_text_rsp *)cmd->pdu;\n\tint text_length;\n\n\ttext_length = iscsit_build_text_rsp(cmd, conn, hdr,\n\t\t\t\tconn->conn_transport->transport_type);\n\tif (text_length < 0)\n\t\treturn text_length;\n\n\treturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL,\n\t\t\t\t\t\t     cmd->buf_ptr,\n\t\t\t\t\t\t     text_length);\n}\n\nvoid\niscsit_build_reject(struct iscsit_cmd *cmd, struct iscsit_conn *conn,\n\t\t    struct iscsi_reject *hdr)\n{\n\thdr->opcode\t\t= ISCSI_OP_REJECT;\n\thdr->reason\t\t= cmd->reject_reason;\n\thdr->flags\t\t|= ISCSI_FLAG_CMD_FINAL;\n\thton24(hdr->dlength, ISCSI_HDR_LEN);\n\thdr->ffffffff\t\t= cpu_to_be32(0xffffffff);\n\tcmd->stat_sn\t\t= conn->stat_sn++;\n\thdr->statsn\t\t= cpu_to_be32(cmd->stat_sn);\n\thdr->exp_cmdsn\t\t= cpu_to_be32(conn->sess->exp_cmd_sn);\n\thdr->max_cmdsn\t\t= cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn));\n\n}\nEXPORT_SYMBOL(iscsit_build_reject);\n\nstatic int iscsit_send_reject(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_conn *conn)\n{\n\tstruct iscsi_reject *hdr = (struct iscsi_reject *)&cmd->pdu[0];\n\n\tiscsit_build_reject(cmd, conn, hdr);\n\n\tpr_debug(\"Built Reject PDU StatSN: 0x%08x, Reason: 0x%02x,\"\n\t\t\" CID: %hu\\n\", ntohl(hdr->statsn), hdr->reason, conn->cid);\n\n\treturn conn->conn_transport->iscsit_xmit_pdu(conn, cmd, NULL,\n\t\t\t\t\t\t     cmd->buf_ptr,\n\t\t\t\t\t\t     ISCSI_HDR_LEN);\n}\n\nvoid iscsit_thread_get_cpumask(struct iscsit_conn *conn)\n{\n\tint ord, cpu;\n\tcpumask_var_t conn_allowed_cpumask;\n\n\t \n\tif (!zalloc_cpumask_var(&conn_allowed_cpumask, GFP_KERNEL)) {\n\t\tord = conn->bitmap_id % cpumask_weight(cpu_online_mask);\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tif (ord-- == 0) {\n\t\t\t\tcpumask_set_cpu(cpu, conn->conn_cpumask);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcpumask_and(conn_allowed_cpumask, iscsit_global->allowed_cpumask,\n\t\t\tcpu_online_mask);\n\n\t\tcpumask_clear(conn->conn_cpumask);\n\t\tord = conn->bitmap_id % cpumask_weight(conn_allowed_cpumask);\n\t\tfor_each_cpu(cpu, conn_allowed_cpumask) {\n\t\t\tif (ord-- == 0) {\n\t\t\t\tcpumask_set_cpu(cpu, conn->conn_cpumask);\n\t\t\t\tfree_cpumask_var(conn_allowed_cpumask);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfree_cpumask_var(conn_allowed_cpumask);\n\t}\n\t \n\tdump_stack();\n\tcpumask_setall(conn->conn_cpumask);\n}\n\nstatic void iscsit_thread_reschedule(struct iscsit_conn *conn)\n{\n\t \n\tif (!cpumask_equal(iscsit_global->allowed_cpumask,\n\t\t\t   conn->allowed_cpumask)) {\n\t\tiscsit_thread_get_cpumask(conn);\n\t\tconn->conn_tx_reset_cpumask = 1;\n\t\tconn->conn_rx_reset_cpumask = 1;\n\t\tcpumask_copy(conn->allowed_cpumask,\n\t\t\t     iscsit_global->allowed_cpumask);\n\t}\n}\n\nvoid iscsit_thread_check_cpumask(\n\tstruct iscsit_conn *conn,\n\tstruct task_struct *p,\n\tint mode)\n{\n\t \n\tiscsit_thread_reschedule(conn);\n\n\t \n\tif (mode == 1) {\n\t\tif (!conn->conn_tx_reset_cpumask)\n\t\t\treturn;\n\t} else {\n\t\tif (!conn->conn_rx_reset_cpumask)\n\t\t\treturn;\n\t}\n\n\t \n\tset_cpus_allowed_ptr(p, conn->conn_cpumask);\n\tif (mode == 1)\n\t\tconn->conn_tx_reset_cpumask = 0;\n\telse\n\t\tconn->conn_rx_reset_cpumask = 0;\n}\nEXPORT_SYMBOL(iscsit_thread_check_cpumask);\n\nint\niscsit_immediate_queue(struct iscsit_conn *conn, struct iscsit_cmd *cmd, int state)\n{\n\tint ret;\n\n\tswitch (state) {\n\tcase ISTATE_SEND_R2T:\n\t\tret = iscsit_send_r2t(cmd, conn);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase ISTATE_REMOVE:\n\t\tspin_lock_bh(&conn->cmd_lock);\n\t\tlist_del_init(&cmd->i_conn_node);\n\t\tspin_unlock_bh(&conn->cmd_lock);\n\n\t\tiscsit_free_cmd(cmd, false);\n\t\tbreak;\n\tcase ISTATE_SEND_NOPIN_WANT_RESPONSE:\n\t\tiscsit_mod_nopin_response_timer(conn);\n\t\tret = iscsit_send_unsolicited_nopin(cmd, conn, 1);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase ISTATE_SEND_NOPIN_NO_RESPONSE:\n\t\tret = iscsit_send_unsolicited_nopin(cmd, conn, 0);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown Opcode: 0x%02x ITT:\"\n\t\t       \" 0x%08x, i_state: %d on CID: %hu\\n\",\n\t\t       cmd->iscsi_opcode, cmd->init_task_tag, state,\n\t\t       conn->cid);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\treturn -1;\n}\nEXPORT_SYMBOL(iscsit_immediate_queue);\n\nstatic int\niscsit_handle_immediate_queue(struct iscsit_conn *conn)\n{\n\tstruct iscsit_transport *t = conn->conn_transport;\n\tstruct iscsi_queue_req *qr;\n\tstruct iscsit_cmd *cmd;\n\tu8 state;\n\tint ret;\n\n\twhile ((qr = iscsit_get_cmd_from_immediate_queue(conn))) {\n\t\tatomic_set(&conn->check_immediate_queue, 0);\n\t\tcmd = qr->cmd;\n\t\tstate = qr->state;\n\t\tkmem_cache_free(lio_qr_cache, qr);\n\n\t\tret = t->iscsit_immediate_queue(conn, cmd, state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint\niscsit_response_queue(struct iscsit_conn *conn, struct iscsit_cmd *cmd, int state)\n{\n\tint ret;\n\ncheck_rsp_state:\n\tswitch (state) {\n\tcase ISTATE_SEND_DATAIN:\n\t\tret = iscsit_send_datain(cmd, conn);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\telse if (!ret)\n\t\t\t \n\t\t\tgoto check_rsp_state;\n\t\telse if (ret == 1) {\n\t\t\t \n\t\t\tspin_lock_bh(&cmd->istate_lock);\n\t\t\tcmd->i_state = ISTATE_SENT_STATUS;\n\t\t\tspin_unlock_bh(&cmd->istate_lock);\n\n\t\t\tif (atomic_read(&conn->check_immediate_queue))\n\t\t\t\treturn 1;\n\n\t\t\treturn 0;\n\t\t} else if (ret == 2) {\n\t\t\t \n\t\t\tspin_lock_bh(&cmd->istate_lock);\n\t\t\tcmd->i_state = ISTATE_SEND_STATUS;\n\t\t\tspin_unlock_bh(&cmd->istate_lock);\n\t\t\tstate = ISTATE_SEND_STATUS;\n\t\t\tgoto check_rsp_state;\n\t\t}\n\n\t\tbreak;\n\tcase ISTATE_SEND_STATUS:\n\tcase ISTATE_SEND_STATUS_RECOVERY:\n\t\tret = iscsit_send_response(cmd, conn);\n\t\tbreak;\n\tcase ISTATE_SEND_LOGOUTRSP:\n\t\tret = iscsit_send_logout(cmd, conn);\n\t\tbreak;\n\tcase ISTATE_SEND_ASYNCMSG:\n\t\tret = iscsit_send_conn_drop_async_message(\n\t\t\tcmd, conn);\n\t\tbreak;\n\tcase ISTATE_SEND_NOPIN:\n\t\tret = iscsit_send_nopin(cmd, conn);\n\t\tbreak;\n\tcase ISTATE_SEND_REJECT:\n\t\tret = iscsit_send_reject(cmd, conn);\n\t\tbreak;\n\tcase ISTATE_SEND_TASKMGTRSP:\n\t\tret = iscsit_send_task_mgt_rsp(cmd, conn);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tret = iscsit_tmr_post_handler(cmd, conn);\n\t\tif (ret != 0)\n\t\t\tiscsit_fall_back_to_erl0(conn->sess);\n\t\tbreak;\n\tcase ISTATE_SEND_TEXTRSP:\n\t\tret = iscsit_send_text_rsp(cmd, conn);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown Opcode: 0x%02x ITT:\"\n\t\t       \" 0x%08x, i_state: %d on CID: %hu\\n\",\n\t\t       cmd->iscsi_opcode, cmd->init_task_tag,\n\t\t       state, conn->cid);\n\t\tgoto err;\n\t}\n\tif (ret < 0)\n\t\tgoto err;\n\n\tswitch (state) {\n\tcase ISTATE_SEND_LOGOUTRSP:\n\t\tif (!iscsit_logout_post_handler(cmd, conn))\n\t\t\treturn -ECONNRESET;\n\t\tfallthrough;\n\tcase ISTATE_SEND_STATUS:\n\tcase ISTATE_SEND_ASYNCMSG:\n\tcase ISTATE_SEND_NOPIN:\n\tcase ISTATE_SEND_STATUS_RECOVERY:\n\tcase ISTATE_SEND_TEXTRSP:\n\tcase ISTATE_SEND_TASKMGTRSP:\n\tcase ISTATE_SEND_REJECT:\n\t\tspin_lock_bh(&cmd->istate_lock);\n\t\tcmd->i_state = ISTATE_SENT_STATUS;\n\t\tspin_unlock_bh(&cmd->istate_lock);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown Opcode: 0x%02x ITT:\"\n\t\t       \" 0x%08x, i_state: %d on CID: %hu\\n\",\n\t\t       cmd->iscsi_opcode, cmd->init_task_tag,\n\t\t       cmd->i_state, conn->cid);\n\t\tgoto err;\n\t}\n\n\tif (atomic_read(&conn->check_immediate_queue))\n\t\treturn 1;\n\n\treturn 0;\n\nerr:\n\treturn -1;\n}\nEXPORT_SYMBOL(iscsit_response_queue);\n\nstatic int iscsit_handle_response_queue(struct iscsit_conn *conn)\n{\n\tstruct iscsit_transport *t = conn->conn_transport;\n\tstruct iscsi_queue_req *qr;\n\tstruct iscsit_cmd *cmd;\n\tu8 state;\n\tint ret;\n\n\twhile ((qr = iscsit_get_cmd_from_response_queue(conn))) {\n\t\tcmd = qr->cmd;\n\t\tstate = qr->state;\n\t\tkmem_cache_free(lio_qr_cache, qr);\n\n\t\tret = t->iscsit_response_queue(conn, cmd, state);\n\t\tif (ret == 1 || ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint iscsi_target_tx_thread(void *arg)\n{\n\tint ret = 0;\n\tstruct iscsit_conn *conn = arg;\n\tbool conn_freed = false;\n\n\t \n\tallow_signal(SIGINT);\n\n\twhile (!kthread_should_stop()) {\n\t\t \n\t\tiscsit_thread_check_cpumask(conn, current, 1);\n\n\t\twait_event_interruptible(conn->queues_wq,\n\t\t\t\t\t !iscsit_conn_all_queues_empty(conn));\n\n\t\tif (signal_pending(current))\n\t\t\tgoto transport_err;\n\nget_immediate:\n\t\tret = iscsit_handle_immediate_queue(conn);\n\t\tif (ret < 0)\n\t\t\tgoto transport_err;\n\n\t\tret = iscsit_handle_response_queue(conn);\n\t\tif (ret == 1) {\n\t\t\tgoto get_immediate;\n\t\t} else if (ret == -ECONNRESET) {\n\t\t\tconn_freed = true;\n\t\t\tgoto out;\n\t\t} else if (ret < 0) {\n\t\t\tgoto transport_err;\n\t\t}\n\t}\n\ntransport_err:\n\t \n\tif (conn->conn_state != TARG_CONN_STATE_IN_LOGIN)\n\t\tiscsit_take_action_for_connection_exit(conn, &conn_freed);\nout:\n\tif (!conn_freed) {\n\t\twhile (!kthread_should_stop()) {\n\t\t\tmsleep(100);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int iscsi_target_rx_opcode(struct iscsit_conn *conn, unsigned char *buf)\n{\n\tstruct iscsi_hdr *hdr = (struct iscsi_hdr *)buf;\n\tstruct iscsit_cmd *cmd;\n\tint ret = 0;\n\n\tswitch (hdr->opcode & ISCSI_OPCODE_MASK) {\n\tcase ISCSI_OP_SCSI_CMD:\n\t\tcmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\n\t\tif (!cmd)\n\t\t\tgoto reject;\n\n\t\tret = iscsit_handle_scsi_cmd(conn, cmd, buf);\n\t\tbreak;\n\tcase ISCSI_OP_SCSI_DATA_OUT:\n\t\tret = iscsit_handle_data_out(conn, buf);\n\t\tbreak;\n\tcase ISCSI_OP_NOOP_OUT:\n\t\tcmd = NULL;\n\t\tif (hdr->ttt == cpu_to_be32(0xFFFFFFFF)) {\n\t\t\tcmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\n\t\t\tif (!cmd)\n\t\t\t\tgoto reject;\n\t\t}\n\t\tret = iscsit_handle_nop_out(conn, cmd, buf);\n\t\tbreak;\n\tcase ISCSI_OP_SCSI_TMFUNC:\n\t\tcmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\n\t\tif (!cmd)\n\t\t\tgoto reject;\n\n\t\tret = iscsit_handle_task_mgt_cmd(conn, cmd, buf);\n\t\tbreak;\n\tcase ISCSI_OP_TEXT:\n\t\tif (hdr->ttt != cpu_to_be32(0xFFFFFFFF)) {\n\t\t\tcmd = iscsit_find_cmd_from_itt(conn, hdr->itt);\n\t\t\tif (!cmd)\n\t\t\t\tgoto reject;\n\t\t} else {\n\t\t\tcmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\n\t\t\tif (!cmd)\n\t\t\t\tgoto reject;\n\t\t}\n\n\t\tret = iscsit_handle_text_cmd(conn, cmd, buf);\n\t\tbreak;\n\tcase ISCSI_OP_LOGOUT:\n\t\tcmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\n\t\tif (!cmd)\n\t\t\tgoto reject;\n\n\t\tret = iscsit_handle_logout_cmd(conn, cmd, buf);\n\t\tif (ret > 0)\n\t\t\twait_for_completion_timeout(&conn->conn_logout_comp,\n\t\t\t\t\tSECONDS_FOR_LOGOUT_COMP * HZ);\n\t\tbreak;\n\tcase ISCSI_OP_SNACK:\n\t\tret = iscsit_handle_snack(conn, buf);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Got unknown iSCSI OpCode: 0x%02x\\n\", hdr->opcode);\n\t\tif (!conn->sess->sess_ops->ErrorRecoveryLevel) {\n\t\t\tpr_err(\"Cannot recover from unknown\"\n\t\t\t\" opcode while ERL=0, closing iSCSI connection.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tpr_err(\"Unable to recover from unknown opcode while OFMarker=No,\"\n\t\t       \" closing iSCSI connection.\\n\");\n\t\tret = -1;\n\t\tbreak;\n\t}\n\n\treturn ret;\nreject:\n\treturn iscsit_add_reject(conn, ISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);\n}\n\nstatic bool iscsi_target_check_conn_state(struct iscsit_conn *conn)\n{\n\tbool ret;\n\n\tspin_lock_bh(&conn->state_lock);\n\tret = (conn->conn_state != TARG_CONN_STATE_LOGGED_IN);\n\tspin_unlock_bh(&conn->state_lock);\n\n\treturn ret;\n}\n\nstatic void iscsit_get_rx_pdu(struct iscsit_conn *conn)\n{\n\tint ret;\n\tu8 *buffer, *tmp_buf, opcode;\n\tu32 checksum = 0, digest = 0;\n\tstruct iscsi_hdr *hdr;\n\tstruct kvec iov;\n\n\tbuffer = kcalloc(ISCSI_HDR_LEN, sizeof(*buffer), GFP_KERNEL);\n\tif (!buffer)\n\t\treturn;\n\n\twhile (!kthread_should_stop()) {\n\t\t \n\t\tiscsit_thread_check_cpumask(conn, current, 0);\n\n\t\tmemset(&iov, 0, sizeof(struct kvec));\n\n\t\tiov.iov_base\t= buffer;\n\t\tiov.iov_len\t= ISCSI_HDR_LEN;\n\n\t\tret = rx_data(conn, &iov, 1, ISCSI_HDR_LEN);\n\t\tif (ret != ISCSI_HDR_LEN) {\n\t\t\tiscsit_rx_thread_wait_for_tcp(conn);\n\t\t\tbreak;\n\t\t}\n\n\t\thdr = (struct iscsi_hdr *) buffer;\n\t\tif (hdr->hlength) {\n\t\t\tiov.iov_len = hdr->hlength * 4;\n\t\t\ttmp_buf = krealloc(buffer,\n\t\t\t\t\t  ISCSI_HDR_LEN + iov.iov_len,\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!tmp_buf)\n\t\t\t\tbreak;\n\n\t\t\tbuffer = tmp_buf;\n\t\t\tiov.iov_base = &buffer[ISCSI_HDR_LEN];\n\n\t\t\tret = rx_data(conn, &iov, 1, iov.iov_len);\n\t\t\tif (ret != iov.iov_len) {\n\t\t\t\tiscsit_rx_thread_wait_for_tcp(conn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (conn->conn_ops->HeaderDigest) {\n\t\t\tiov.iov_base\t= &digest;\n\t\t\tiov.iov_len\t= ISCSI_CRC_LEN;\n\n\t\t\tret = rx_data(conn, &iov, 1, ISCSI_CRC_LEN);\n\t\t\tif (ret != ISCSI_CRC_LEN) {\n\t\t\t\tiscsit_rx_thread_wait_for_tcp(conn);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tiscsit_do_crypto_hash_buf(conn->conn_rx_hash, buffer,\n\t\t\t\t\t\t  ISCSI_HDR_LEN, 0, NULL,\n\t\t\t\t\t\t  &checksum);\n\n\t\t\tif (digest != checksum) {\n\t\t\t\tpr_err(\"HeaderDigest CRC32C failed,\"\n\t\t\t\t\t\" received 0x%08x, computed 0x%08x\\n\",\n\t\t\t\t\tdigest, checksum);\n\t\t\t\t \n\t\t\t\tmemset(buffer, 0xff, ISCSI_HDR_LEN);\n\t\t\t\tatomic_long_inc(&conn->sess->conn_digest_errors);\n\t\t\t} else {\n\t\t\t\tpr_debug(\"Got HeaderDigest CRC32C\"\n\t\t\t\t\t\t\" 0x%08x\\n\", checksum);\n\t\t\t}\n\t\t}\n\n\t\tif (conn->conn_state == TARG_CONN_STATE_IN_LOGOUT)\n\t\t\tbreak;\n\n\t\topcode = buffer[0] & ISCSI_OPCODE_MASK;\n\n\t\tif (conn->sess->sess_ops->SessionType &&\n\t\t   ((!(opcode & ISCSI_OP_TEXT)) ||\n\t\t    (!(opcode & ISCSI_OP_LOGOUT)))) {\n\t\t\tpr_err(\"Received illegal iSCSI Opcode: 0x%02x\"\n\t\t\t\" while in Discovery Session, rejecting.\\n\", opcode);\n\t\t\tiscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,\n\t\t\t\t\t  buffer);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = iscsi_target_rx_opcode(conn, buffer);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tkfree(buffer);\n}\n\nint iscsi_target_rx_thread(void *arg)\n{\n\tint rc;\n\tstruct iscsit_conn *conn = arg;\n\tbool conn_freed = false;\n\n\t \n\tallow_signal(SIGINT);\n\t \n\trc = wait_for_completion_interruptible(&conn->rx_login_comp);\n\tif (rc < 0 || iscsi_target_check_conn_state(conn))\n\t\tgoto out;\n\n\tif (!conn->conn_transport->iscsit_get_rx_pdu)\n\t\treturn 0;\n\n\tconn->conn_transport->iscsit_get_rx_pdu(conn);\n\n\tif (!signal_pending(current))\n\t\tatomic_set(&conn->transport_failed, 1);\n\tiscsit_take_action_for_connection_exit(conn, &conn_freed);\n\nout:\n\tif (!conn_freed) {\n\t\twhile (!kthread_should_stop()) {\n\t\t\tmsleep(100);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void iscsit_release_commands_from_conn(struct iscsit_conn *conn)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct iscsit_cmd *cmd = NULL, *cmd_tmp = NULL;\n\tstruct iscsit_session *sess = conn->sess;\n\t \n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_splice_init(&conn->conn_cmd_list, &tmp_list);\n\n\tlist_for_each_entry_safe(cmd, cmd_tmp, &tmp_list, i_conn_node) {\n\t\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\n\t\tif (!se_cmd->se_tfo)\n\t\t\tcontinue;\n\n\t\tspin_lock_irq(&se_cmd->t_state_lock);\n\t\tif (se_cmd->transport_state & CMD_T_ABORTED) {\n\t\t\tif (!(se_cmd->transport_state & CMD_T_TAS))\n\t\t\t\t \n\t\t\t\tlist_move_tail(&cmd->i_conn_node,\n\t\t\t\t\t       &conn->conn_cmd_list);\n\t\t} else {\n\t\t\tse_cmd->transport_state |= CMD_T_FABRIC_STOP;\n\t\t}\n\n\t\tif (cmd->se_cmd.t_state == TRANSPORT_WRITE_PENDING) {\n\t\t\t \n\t\t\tspin_unlock_irq(&se_cmd->t_state_lock);\n\t\t\ttarget_complete_cmd(&cmd->se_cmd, SAM_STAT_TASK_ABORTED);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock_irq(&se_cmd->t_state_lock);\n\t}\n\tspin_unlock_bh(&conn->cmd_lock);\n\n\tlist_for_each_entry_safe(cmd, cmd_tmp, &tmp_list, i_conn_node) {\n\t\tlist_del_init(&cmd->i_conn_node);\n\n\t\tiscsit_increment_maxcmdsn(cmd, sess);\n\t\tiscsit_free_cmd(cmd, true);\n\n\t}\n\n\t \n\tif (!conn->conn_transport->iscsit_wait_conn) {\n\t\ttarget_stop_cmd_counter(conn->cmd_cnt);\n\t\ttarget_wait_for_cmds(conn->cmd_cnt);\n\t}\n}\n\nstatic void iscsit_stop_timers_for_cmds(\n\tstruct iscsit_conn *conn)\n{\n\tstruct iscsit_cmd *cmd;\n\n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {\n\t\tif (cmd->data_direction == DMA_TO_DEVICE)\n\t\t\tiscsit_stop_dataout_timer(cmd);\n\t}\n\tspin_unlock_bh(&conn->cmd_lock);\n}\n\nint iscsit_close_connection(\n\tstruct iscsit_conn *conn)\n{\n\tint conn_logout = (conn->conn_state == TARG_CONN_STATE_IN_LOGOUT);\n\tstruct iscsit_session\t*sess = conn->sess;\n\n\tpr_debug(\"Closing iSCSI connection CID %hu on SID:\"\n\t\t\" %u\\n\", conn->cid, sess->sid);\n\t \n\tif (!conn->conn_transport->rdma_shutdown)\n\t\tcomplete(&conn->conn_logout_comp);\n\n\tif (!strcmp(current->comm, ISCSI_RX_THREAD_NAME)) {\n\t\tif (conn->tx_thread &&\n\t\t    cmpxchg(&conn->tx_thread_active, true, false)) {\n\t\t\tsend_sig(SIGINT, conn->tx_thread, 1);\n\t\t\tkthread_stop(conn->tx_thread);\n\t\t}\n\t} else if (!strcmp(current->comm, ISCSI_TX_THREAD_NAME)) {\n\t\tif (conn->rx_thread &&\n\t\t    cmpxchg(&conn->rx_thread_active, true, false)) {\n\t\t\tsend_sig(SIGINT, conn->rx_thread, 1);\n\t\t\tkthread_stop(conn->rx_thread);\n\t\t}\n\t}\n\n\tspin_lock(&iscsit_global->ts_bitmap_lock);\n\tbitmap_release_region(iscsit_global->ts_bitmap, conn->bitmap_id,\n\t\t\t      get_order(1));\n\tspin_unlock(&iscsit_global->ts_bitmap_lock);\n\n\tiscsit_stop_timers_for_cmds(conn);\n\tiscsit_stop_nopin_response_timer(conn);\n\tiscsit_stop_nopin_timer(conn);\n\n\tif (conn->conn_transport->iscsit_wait_conn)\n\t\tconn->conn_transport->iscsit_wait_conn(conn);\n\n\t \n\tif (atomic_read(&conn->connection_recovery)) {\n\t\tiscsit_discard_unacknowledged_ooo_cmdsns_for_conn(conn);\n\t\tiscsit_prepare_cmds_for_reallegiance(conn);\n\t} else {\n\t\tiscsit_clear_ooo_cmdsns_for_conn(conn);\n\t\tiscsit_release_commands_from_conn(conn);\n\t}\n\tiscsit_free_queue_reqs_for_conn(conn);\n\n\t \n\tif (atomic_read(&conn->conn_logout_remove)) {\n\t\tif (conn->conn_logout_reason == ISCSI_LOGOUT_REASON_CLOSE_SESSION) {\n\t\t\tiscsit_dec_conn_usage_count(conn);\n\t\t\tiscsit_dec_session_usage_count(sess);\n\t\t}\n\t\tif (conn->conn_logout_reason == ISCSI_LOGOUT_REASON_CLOSE_CONNECTION)\n\t\t\tiscsit_dec_conn_usage_count(conn);\n\n\t\tatomic_set(&conn->conn_logout_remove, 0);\n\t\tatomic_set(&sess->session_reinstatement, 0);\n\t\tatomic_set(&sess->session_fall_back_to_erl0, 1);\n\t}\n\n\tspin_lock_bh(&sess->conn_lock);\n\tlist_del(&conn->conn_list);\n\n\t \n\tif (atomic_read(&conn->connection_recovery))\n\t\tiscsit_build_conn_drop_async_message(conn);\n\n\tspin_unlock_bh(&sess->conn_lock);\n\n\t \n\tspin_lock_bh(&conn->state_lock);\n\tif (atomic_read(&conn->sleep_on_conn_wait_comp)) {\n\t\tspin_unlock_bh(&conn->state_lock);\n\t\tcomplete(&conn->conn_wait_comp);\n\t\twait_for_completion(&conn->conn_post_wait_comp);\n\t\tspin_lock_bh(&conn->state_lock);\n\t}\n\n\t \n\tif (atomic_read(&conn->connection_wait_rcfr)) {\n\t\tspin_unlock_bh(&conn->state_lock);\n\t\tcomplete(&conn->conn_wait_rcfr_comp);\n\t\twait_for_completion(&conn->conn_post_wait_comp);\n\t\tspin_lock_bh(&conn->state_lock);\n\t}\n\tatomic_set(&conn->connection_reinstatement, 1);\n\tspin_unlock_bh(&conn->state_lock);\n\n\t \n\tiscsit_check_conn_usage_count(conn);\n\n\tahash_request_free(conn->conn_tx_hash);\n\tif (conn->conn_rx_hash) {\n\t\tstruct crypto_ahash *tfm;\n\n\t\ttfm = crypto_ahash_reqtfm(conn->conn_rx_hash);\n\t\tahash_request_free(conn->conn_rx_hash);\n\t\tcrypto_free_ahash(tfm);\n\t}\n\n\tif (conn->sock)\n\t\tsock_release(conn->sock);\n\n\tif (conn->conn_transport->iscsit_free_conn)\n\t\tconn->conn_transport->iscsit_free_conn(conn);\n\n\tpr_debug(\"Moving to TARG_CONN_STATE_FREE.\\n\");\n\tconn->conn_state = TARG_CONN_STATE_FREE;\n\tiscsit_free_conn(conn);\n\n\tspin_lock_bh(&sess->conn_lock);\n\tatomic_dec(&sess->nconn);\n\tpr_debug(\"Decremented iSCSI connection count to %d from node:\"\n\t\t\" %s\\n\", atomic_read(&sess->nconn),\n\t\tsess->sess_ops->InitiatorName);\n\t \n\tif ((sess->sess_ops->ErrorRecoveryLevel != 2) && !conn_logout &&\n\t     !atomic_read(&sess->session_logout))\n\t\tatomic_set(&sess->session_fall_back_to_erl0, 1);\n\n\t \n\tif (atomic_read(&sess->nconn)) {\n\t\tif (!atomic_read(&sess->session_reinstatement) &&\n\t\t    !atomic_read(&sess->session_fall_back_to_erl0)) {\n\t\t\tspin_unlock_bh(&sess->conn_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!atomic_read(&sess->session_stop_active)) {\n\t\t\tatomic_set(&sess->session_stop_active, 1);\n\t\t\tspin_unlock_bh(&sess->conn_lock);\n\t\t\tiscsit_stop_session(sess, 0, 0);\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock_bh(&sess->conn_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!atomic_read(&sess->session_reinstatement) &&\n\t     atomic_read(&sess->session_fall_back_to_erl0)) {\n\t\tspin_unlock_bh(&sess->conn_lock);\n\t\tcomplete_all(&sess->session_wait_comp);\n\t\tiscsit_close_session(sess, true);\n\n\t\treturn 0;\n\t} else if (atomic_read(&sess->session_logout)) {\n\t\tpr_debug(\"Moving to TARG_SESS_STATE_FREE.\\n\");\n\t\tsess->session_state = TARG_SESS_STATE_FREE;\n\n\t\tif (atomic_read(&sess->session_close)) {\n\t\t\tspin_unlock_bh(&sess->conn_lock);\n\t\t\tcomplete_all(&sess->session_wait_comp);\n\t\t\tiscsit_close_session(sess, true);\n\t\t} else {\n\t\t\tspin_unlock_bh(&sess->conn_lock);\n\t\t}\n\n\t\treturn 0;\n\t} else {\n\t\tpr_debug(\"Moving to TARG_SESS_STATE_FAILED.\\n\");\n\t\tsess->session_state = TARG_SESS_STATE_FAILED;\n\n\t\tif (!atomic_read(&sess->session_continuation))\n\t\t\tiscsit_start_time2retain_handler(sess);\n\n\t\tif (atomic_read(&sess->session_close)) {\n\t\t\tspin_unlock_bh(&sess->conn_lock);\n\t\t\tcomplete_all(&sess->session_wait_comp);\n\t\t\tiscsit_close_session(sess, true);\n\t\t} else {\n\t\t\tspin_unlock_bh(&sess->conn_lock);\n\t\t}\n\n\t\treturn 0;\n\t}\n}\n\n \nint iscsit_close_session(struct iscsit_session *sess, bool can_sleep)\n{\n\tstruct iscsi_portal_group *tpg = sess->tpg;\n\tstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\n\n\tif (atomic_read(&sess->nconn)) {\n\t\tpr_err(\"%d connection(s) still exist for iSCSI session\"\n\t\t\t\" to %s\\n\", atomic_read(&sess->nconn),\n\t\t\tsess->sess_ops->InitiatorName);\n\t\tBUG();\n\t}\n\n\tspin_lock_bh(&se_tpg->session_lock);\n\tatomic_set(&sess->session_logout, 1);\n\tatomic_set(&sess->session_reinstatement, 1);\n\tiscsit_stop_time2retain_timer(sess);\n\tspin_unlock_bh(&se_tpg->session_lock);\n\n\tif (sess->sess_ops->ErrorRecoveryLevel == 2)\n\t\tiscsit_free_connection_recovery_entries(sess);\n\n\t \n\ttransport_deregister_session_configfs(sess->se_sess);\n\n\t \n\tif (iscsit_check_session_usage_count(sess, can_sleep)) {\n\t\tatomic_set(&sess->session_logout, 0);\n\t\tiscsit_start_time2retain_handler(sess);\n\t\treturn 0;\n\t}\n\n\ttransport_deregister_session(sess->se_sess);\n\n\tiscsit_free_all_ooo_cmdsns(sess);\n\n\tspin_lock_bh(&se_tpg->session_lock);\n\tpr_debug(\"Moving to TARG_SESS_STATE_FREE.\\n\");\n\tsess->session_state = TARG_SESS_STATE_FREE;\n\tpr_debug(\"Released iSCSI session from node: %s\\n\",\n\t\t\tsess->sess_ops->InitiatorName);\n\ttpg->nsessions--;\n\tif (tpg->tpg_tiqn)\n\t\ttpg->tpg_tiqn->tiqn_nsessions--;\n\n\tpr_debug(\"Decremented number of active iSCSI Sessions on\"\n\t\t\" iSCSI TPG: %hu to %u\\n\", tpg->tpgt, tpg->nsessions);\n\n\tida_free(&sess_ida, sess->session_index);\n\tkfree(sess->sess_ops);\n\tsess->sess_ops = NULL;\n\tspin_unlock_bh(&se_tpg->session_lock);\n\n\tkfree(sess);\n\treturn 0;\n}\n\nstatic void iscsit_logout_post_handler_closesession(\n\tstruct iscsit_conn *conn)\n{\n\tstruct iscsit_session *sess = conn->sess;\n\tint sleep = 1;\n\t \n\tif (!conn->conn_transport->rdma_shutdown) {\n\t\tsleep = cmpxchg(&conn->tx_thread_active, true, false);\n\t\tif (!sleep)\n\t\t\treturn;\n\t}\n\n\tatomic_set(&conn->conn_logout_remove, 0);\n\tcomplete(&conn->conn_logout_comp);\n\n\tiscsit_dec_conn_usage_count(conn);\n\tatomic_set(&sess->session_close, 1);\n\tiscsit_stop_session(sess, sleep, sleep);\n\tiscsit_dec_session_usage_count(sess);\n}\n\nstatic void iscsit_logout_post_handler_samecid(\n\tstruct iscsit_conn *conn)\n{\n\tint sleep = 1;\n\n\tif (!conn->conn_transport->rdma_shutdown) {\n\t\tsleep = cmpxchg(&conn->tx_thread_active, true, false);\n\t\tif (!sleep)\n\t\t\treturn;\n\t}\n\n\tatomic_set(&conn->conn_logout_remove, 0);\n\tcomplete(&conn->conn_logout_comp);\n\n\tiscsit_cause_connection_reinstatement(conn, sleep);\n\tiscsit_dec_conn_usage_count(conn);\n}\n\nstatic void iscsit_logout_post_handler_diffcid(\n\tstruct iscsit_conn *conn,\n\tu16 cid)\n{\n\tstruct iscsit_conn *l_conn;\n\tstruct iscsit_session *sess = conn->sess;\n\tbool conn_found = false;\n\n\tif (!sess)\n\t\treturn;\n\n\tspin_lock_bh(&sess->conn_lock);\n\tlist_for_each_entry(l_conn, &sess->sess_conn_list, conn_list) {\n\t\tif (l_conn->cid == cid) {\n\t\t\tiscsit_inc_conn_usage_count(l_conn);\n\t\t\tconn_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&sess->conn_lock);\n\n\tif (!conn_found)\n\t\treturn;\n\n\tif (l_conn->sock)\n\t\tl_conn->sock->ops->shutdown(l_conn->sock, RCV_SHUTDOWN);\n\n\tspin_lock_bh(&l_conn->state_lock);\n\tpr_debug(\"Moving to TARG_CONN_STATE_IN_LOGOUT.\\n\");\n\tl_conn->conn_state = TARG_CONN_STATE_IN_LOGOUT;\n\tspin_unlock_bh(&l_conn->state_lock);\n\n\tiscsit_cause_connection_reinstatement(l_conn, 1);\n\tiscsit_dec_conn_usage_count(l_conn);\n}\n\n \nint iscsit_logout_post_handler(\n\tstruct iscsit_cmd *cmd,\n\tstruct iscsit_conn *conn)\n{\n\tint ret = 0;\n\n\tswitch (cmd->logout_reason) {\n\tcase ISCSI_LOGOUT_REASON_CLOSE_SESSION:\n\t\tswitch (cmd->logout_response) {\n\t\tcase ISCSI_LOGOUT_SUCCESS:\n\t\tcase ISCSI_LOGOUT_CLEANUP_FAILED:\n\t\tdefault:\n\t\t\tiscsit_logout_post_handler_closesession(conn);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ISCSI_LOGOUT_REASON_CLOSE_CONNECTION:\n\t\tif (conn->cid == cmd->logout_cid) {\n\t\t\tswitch (cmd->logout_response) {\n\t\t\tcase ISCSI_LOGOUT_SUCCESS:\n\t\t\tcase ISCSI_LOGOUT_CLEANUP_FAILED:\n\t\t\tdefault:\n\t\t\t\tiscsit_logout_post_handler_samecid(conn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (cmd->logout_response) {\n\t\t\tcase ISCSI_LOGOUT_SUCCESS:\n\t\t\t\tiscsit_logout_post_handler_diffcid(conn,\n\t\t\t\t\tcmd->logout_cid);\n\t\t\t\tbreak;\n\t\t\tcase ISCSI_LOGOUT_CID_NOT_FOUND:\n\t\t\tcase ISCSI_LOGOUT_CLEANUP_FAILED:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\tcase ISCSI_LOGOUT_REASON_RECOVERY:\n\t\tswitch (cmd->logout_response) {\n\t\tcase ISCSI_LOGOUT_SUCCESS:\n\t\tcase ISCSI_LOGOUT_CID_NOT_FOUND:\n\t\tcase ISCSI_LOGOUT_RECOVERY_UNSUPPORTED:\n\t\tcase ISCSI_LOGOUT_CLEANUP_FAILED:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(iscsit_logout_post_handler);\n\nvoid iscsit_fail_session(struct iscsit_session *sess)\n{\n\tstruct iscsit_conn *conn;\n\n\tspin_lock_bh(&sess->conn_lock);\n\tlist_for_each_entry(conn, &sess->sess_conn_list, conn_list) {\n\t\tpr_debug(\"Moving to TARG_CONN_STATE_CLEANUP_WAIT.\\n\");\n\t\tconn->conn_state = TARG_CONN_STATE_CLEANUP_WAIT;\n\t}\n\tspin_unlock_bh(&sess->conn_lock);\n\n\tpr_debug(\"Moving to TARG_SESS_STATE_FAILED.\\n\");\n\tsess->session_state = TARG_SESS_STATE_FAILED;\n}\n\nvoid iscsit_stop_session(\n\tstruct iscsit_session *sess,\n\tint session_sleep,\n\tint connection_sleep)\n{\n\tu16 conn_count = atomic_read(&sess->nconn);\n\tstruct iscsit_conn *conn, *conn_tmp = NULL;\n\tint is_last;\n\n\tspin_lock_bh(&sess->conn_lock);\n\n\tif (connection_sleep) {\n\t\tlist_for_each_entry_safe(conn, conn_tmp, &sess->sess_conn_list,\n\t\t\t\tconn_list) {\n\t\t\tif (conn_count == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (list_is_last(&conn->conn_list, &sess->sess_conn_list)) {\n\t\t\t\tis_last = 1;\n\t\t\t} else {\n\t\t\t\tiscsit_inc_conn_usage_count(conn_tmp);\n\t\t\t\tis_last = 0;\n\t\t\t}\n\t\t\tiscsit_inc_conn_usage_count(conn);\n\n\t\t\tspin_unlock_bh(&sess->conn_lock);\n\t\t\tiscsit_cause_connection_reinstatement(conn, 1);\n\t\t\tspin_lock_bh(&sess->conn_lock);\n\n\t\t\tiscsit_dec_conn_usage_count(conn);\n\t\t\tif (is_last == 0)\n\t\t\t\tiscsit_dec_conn_usage_count(conn_tmp);\n\t\t\tconn_count--;\n\t\t}\n\t} else {\n\t\tlist_for_each_entry(conn, &sess->sess_conn_list, conn_list)\n\t\t\tiscsit_cause_connection_reinstatement(conn, 0);\n\t}\n\n\tif (session_sleep && atomic_read(&sess->nconn)) {\n\t\tspin_unlock_bh(&sess->conn_lock);\n\t\twait_for_completion(&sess->session_wait_comp);\n\t} else\n\t\tspin_unlock_bh(&sess->conn_lock);\n}\n\nint iscsit_release_sessions_for_tpg(struct iscsi_portal_group *tpg, int force)\n{\n\tstruct iscsit_session *sess;\n\tstruct se_portal_group *se_tpg = &tpg->tpg_se_tpg;\n\tstruct se_session *se_sess, *se_sess_tmp;\n\tLIST_HEAD(free_list);\n\tint session_count = 0;\n\n\tspin_lock_bh(&se_tpg->session_lock);\n\tif (tpg->nsessions && !force) {\n\t\tspin_unlock_bh(&se_tpg->session_lock);\n\t\treturn -1;\n\t}\n\n\tlist_for_each_entry_safe(se_sess, se_sess_tmp, &se_tpg->tpg_sess_list,\n\t\t\tsess_list) {\n\t\tsess = (struct iscsit_session *)se_sess->fabric_sess_ptr;\n\n\t\tspin_lock(&sess->conn_lock);\n\t\tif (atomic_read(&sess->session_fall_back_to_erl0) ||\n\t\t    atomic_read(&sess->session_logout) ||\n\t\t    atomic_read(&sess->session_close) ||\n\t\t    (sess->time2retain_timer_flags & ISCSI_TF_EXPIRED)) {\n\t\t\tspin_unlock(&sess->conn_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tiscsit_inc_session_usage_count(sess);\n\t\tatomic_set(&sess->session_reinstatement, 1);\n\t\tatomic_set(&sess->session_fall_back_to_erl0, 1);\n\t\tatomic_set(&sess->session_close, 1);\n\t\tspin_unlock(&sess->conn_lock);\n\n\t\tlist_move_tail(&se_sess->sess_list, &free_list);\n\t}\n\tspin_unlock_bh(&se_tpg->session_lock);\n\n\tlist_for_each_entry_safe(se_sess, se_sess_tmp, &free_list, sess_list) {\n\t\tsess = (struct iscsit_session *)se_sess->fabric_sess_ptr;\n\n\t\tlist_del_init(&se_sess->sess_list);\n\t\tiscsit_stop_session(sess, 1, 1);\n\t\tiscsit_dec_session_usage_count(sess);\n\t\tsession_count++;\n\t}\n\n\tpr_debug(\"Released %d iSCSI Session(s) from Target Portal\"\n\t\t\t\" Group: %hu\\n\", session_count, tpg->tpgt);\n\treturn 0;\n}\n\nMODULE_DESCRIPTION(\"iSCSI-Target Driver for mainline target infrastructure\");\nMODULE_VERSION(\"4.1.x\");\nMODULE_AUTHOR(\"nab@Linux-iSCSI.org\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(iscsi_target_init_module);\nmodule_exit(iscsi_target_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}