{
  "module_name": "iscsi_target_configfs.c",
  "hash_id": "5c6cf48423abfe8d80101b03b6bbef8fa8dfe5ed31ebb418326cf1d76f5c5d25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/iscsi/iscsi_target_configfs.c",
  "human_readable_source": "\n \n\n#include <linux/configfs.h>\n#include <linux/ctype.h>\n#include <linux/export.h>\n#include <linux/inet.h>\n#include <linux/module.h>\n#include <net/ipv6.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n#include <target/iscsi/iscsi_transport.h>\n#include <target/iscsi/iscsi_target_core.h>\n#include \"iscsi_target_parameters.h\"\n#include \"iscsi_target_device.h\"\n#include \"iscsi_target_erl0.h\"\n#include \"iscsi_target_nodeattrib.h\"\n#include \"iscsi_target_tpg.h\"\n#include \"iscsi_target_util.h\"\n#include \"iscsi_target.h\"\n#include <target/iscsi/iscsi_target_stat.h>\n\n\n \n\nstatic inline struct iscsi_tpg_np *to_iscsi_tpg_np(struct config_item *item)\n{\n\treturn container_of(to_tpg_np(item), struct iscsi_tpg_np, se_tpg_np);\n}\n\nstatic ssize_t lio_target_np_driver_show(struct config_item *item, char *page,\n\t\t\t\t\t enum iscsit_transport_type type)\n{\n\tstruct iscsi_tpg_np *tpg_np = to_iscsi_tpg_np(item);\n\tstruct iscsi_tpg_np *tpg_np_new;\n\tssize_t rb;\n\n\ttpg_np_new = iscsit_tpg_locate_child_np(tpg_np, type);\n\tif (tpg_np_new)\n\t\trb = sysfs_emit(page, \"1\\n\");\n\telse\n\t\trb = sysfs_emit(page, \"0\\n\");\n\n\treturn rb;\n}\n\nstatic ssize_t lio_target_np_driver_store(struct config_item *item,\n\t\tconst char *page, size_t count, enum iscsit_transport_type type,\n\t\tconst char *mod_name)\n{\n\tstruct iscsi_tpg_np *tpg_np = to_iscsi_tpg_np(item);\n\tstruct iscsi_np *np;\n\tstruct iscsi_portal_group *tpg;\n\tstruct iscsi_tpg_np *tpg_np_new = NULL;\n\tu32 op;\n\tint rc;\n\n\trc = kstrtou32(page, 0, &op);\n\tif (rc)\n\t\treturn rc;\n\tif ((op != 1) && (op != 0)) {\n\t\tpr_err(\"Illegal value for tpg_enable: %u\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\tnp = tpg_np->tpg_np;\n\tif (!np) {\n\t\tpr_err(\"Unable to locate struct iscsi_np from\"\n\t\t\t\t\" struct iscsi_tpg_np\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttpg = tpg_np->tpg;\n\tif (iscsit_get_tpg(tpg) < 0)\n\t\treturn -EINVAL;\n\n\tif (op) {\n\t\tif (strlen(mod_name)) {\n\t\t\trc = request_module(mod_name);\n\t\t\tif (rc != 0) {\n\t\t\t\tpr_warn(\"Unable to request_module for %s\\n\",\n\t\t\t\t\tmod_name);\n\t\t\t\trc = 0;\n\t\t\t}\n\t\t}\n\n\t\ttpg_np_new = iscsit_tpg_add_network_portal(tpg,\n\t\t\t\t\t&np->np_sockaddr, tpg_np, type);\n\t\tif (IS_ERR(tpg_np_new)) {\n\t\t\trc = PTR_ERR(tpg_np_new);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\ttpg_np_new = iscsit_tpg_locate_child_np(tpg_np, type);\n\t\tif (tpg_np_new) {\n\t\t\trc = iscsit_tpg_del_network_portal(tpg, tpg_np_new);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tiscsit_put_tpg(tpg);\n\treturn count;\nout:\n\tiscsit_put_tpg(tpg);\n\treturn rc;\n}\n\nstatic ssize_t lio_target_np_iser_show(struct config_item *item, char *page)\n{\n\treturn lio_target_np_driver_show(item, page, ISCSI_INFINIBAND);\n}\n\nstatic ssize_t lio_target_np_iser_store(struct config_item *item,\n\t\t\t\t\tconst char *page, size_t count)\n{\n\treturn lio_target_np_driver_store(item, page, count,\n\t\t\t\t\t  ISCSI_INFINIBAND, \"ib_isert\");\n}\nCONFIGFS_ATTR(lio_target_np_, iser);\n\nstatic ssize_t lio_target_np_cxgbit_show(struct config_item *item, char *page)\n{\n\treturn lio_target_np_driver_show(item, page, ISCSI_CXGBIT);\n}\n\nstatic ssize_t lio_target_np_cxgbit_store(struct config_item *item,\n\t\t\t\t\t  const char *page, size_t count)\n{\n\treturn lio_target_np_driver_store(item, page, count,\n\t\t\t\t\t  ISCSI_CXGBIT, \"cxgbit\");\n}\nCONFIGFS_ATTR(lio_target_np_, cxgbit);\n\nstatic struct configfs_attribute *lio_target_portal_attrs[] = {\n\t&lio_target_np_attr_iser,\n\t&lio_target_np_attr_cxgbit,\n\tNULL,\n};\n\n \n\n \n\n#define MAX_PORTAL_LEN\t\t256\n\nstatic struct se_tpg_np *lio_target_call_addnptotpg(\n\tstruct se_portal_group *se_tpg,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct iscsi_portal_group *tpg;\n\tstruct iscsi_tpg_np *tpg_np;\n\tchar *str, *str2, *ip_str, *port_str;\n\tstruct sockaddr_storage sockaddr = { };\n\tint ret;\n\tchar buf[MAX_PORTAL_LEN + 1] = { };\n\n\tif (strlen(name) > MAX_PORTAL_LEN) {\n\t\tpr_err(\"strlen(name): %d exceeds MAX_PORTAL_LEN: %d\\n\",\n\t\t\t(int)strlen(name), MAX_PORTAL_LEN);\n\t\treturn ERR_PTR(-EOVERFLOW);\n\t}\n\tsnprintf(buf, MAX_PORTAL_LEN + 1, \"%s\", name);\n\n\tstr = strstr(buf, \"[\");\n\tif (str) {\n\t\tstr2 = strstr(str, \"]\");\n\t\tif (!str2) {\n\t\t\tpr_err(\"Unable to locate trailing \\\"]\\\"\"\n\t\t\t\t\" in IPv6 iSCSI network portal address\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tip_str = str + 1;  \n\t\t*str2 = '\\0';  \n\t\tstr2++;  \n\n\t\tport_str = strstr(str2, \":\");\n\t\tif (!port_str) {\n\t\t\tpr_err(\"Unable to locate \\\":port\\\"\"\n\t\t\t\t\" in IPv6 iSCSI network portal address\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\t*port_str = '\\0';  \n\t\tport_str++;  \n\t} else {\n\t\tip_str = &buf[0];\n\t\tport_str = strstr(ip_str, \":\");\n\t\tif (!port_str) {\n\t\t\tpr_err(\"Unable to locate \\\":port\\\"\"\n\t\t\t\t\" in IPv4 iSCSI network portal address\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\t*port_str = '\\0';  \n\t\tport_str++;  \n\t}\n\n\tret = inet_pton_with_scope(&init_net, AF_UNSPEC, ip_str,\n\t\t\tport_str, &sockaddr);\n\tif (ret) {\n\t\tpr_err(\"malformed ip/port passed: %s\\n\", name);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\ttpg = to_iscsi_tpg(se_tpg);\n\tret = iscsit_get_tpg(tpg);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpr_debug(\"LIO_Target_ConfigFS: REGISTER -> %s TPGT: %hu\"\n\t\t\" PORTAL: %s\\n\",\n\t\tconfig_item_name(&se_tpg->se_tpg_wwn->wwn_group.cg_item),\n\t\ttpg->tpgt, name);\n\t \n\ttpg_np = iscsit_tpg_add_network_portal(tpg, &sockaddr, NULL,\n\t\t\t\tISCSI_TCP);\n\tif (IS_ERR(tpg_np)) {\n\t\tiscsit_put_tpg(tpg);\n\t\treturn ERR_CAST(tpg_np);\n\t}\n\tpr_debug(\"LIO_Target_ConfigFS: addnptotpg done!\\n\");\n\n\tiscsit_put_tpg(tpg);\n\treturn &tpg_np->se_tpg_np;\n}\n\nstatic void lio_target_call_delnpfromtpg(\n\tstruct se_tpg_np *se_tpg_np)\n{\n\tstruct iscsi_portal_group *tpg;\n\tstruct iscsi_tpg_np *tpg_np;\n\tstruct se_portal_group *se_tpg;\n\tint ret;\n\n\ttpg_np = container_of(se_tpg_np, struct iscsi_tpg_np, se_tpg_np);\n\ttpg = tpg_np->tpg;\n\tret = iscsit_get_tpg(tpg);\n\tif (ret < 0)\n\t\treturn;\n\n\tse_tpg = &tpg->tpg_se_tpg;\n\tpr_debug(\"LIO_Target_ConfigFS: DEREGISTER -> %s TPGT: %hu\"\n\t\t\" PORTAL: %pISpc\\n\", config_item_name(&se_tpg->se_tpg_wwn->wwn_group.cg_item),\n\t\ttpg->tpgt, &tpg_np->tpg_np->np_sockaddr);\n\n\tret = iscsit_tpg_del_network_portal(tpg, tpg_np);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpr_debug(\"LIO_Target_ConfigFS: delnpfromtpg done!\\n\");\nout:\n\tiscsit_put_tpg(tpg);\n}\n\n \n\n \n\n#define ISCSI_NACL_ATTR(name)\t\t\t\t\t\t\\\nstatic ssize_t iscsi_nacl_attrib_##name##_show(struct config_item *item,\\\n\t\tchar *page)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_node_acl *se_nacl = attrib_to_nacl(item);\t\t\\\n\tstruct iscsi_node_acl *nacl = to_iscsi_nacl(se_nacl);\t\t\\\n\treturn sysfs_emit(page, \"%u\\n\", nacl->node_attrib.name);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t iscsi_nacl_attrib_##name##_store(struct config_item *item,\\\n\t\tconst char *page, size_t count)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_node_acl *se_nacl = attrib_to_nacl(item);\t\t\\\n\tstruct iscsi_node_acl *nacl = to_iscsi_nacl(se_nacl);\t\t\\\n\tu32 val;\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou32(page, 0, &val);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\tret = iscsit_na_##name(nacl, val);\t\t\t\t\\\n\tif (ret < 0)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(iscsi_nacl_attrib_, name)\n\nISCSI_NACL_ATTR(dataout_timeout);\nISCSI_NACL_ATTR(dataout_timeout_retries);\nISCSI_NACL_ATTR(default_erl);\nISCSI_NACL_ATTR(nopin_timeout);\nISCSI_NACL_ATTR(nopin_response_timeout);\nISCSI_NACL_ATTR(random_datain_pdu_offsets);\nISCSI_NACL_ATTR(random_datain_seq_offsets);\nISCSI_NACL_ATTR(random_r2t_offsets);\n\nstatic ssize_t iscsi_nacl_attrib_authentication_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct se_node_acl *se_nacl = attrib_to_nacl(item);\n\tstruct iscsi_node_acl *nacl = to_iscsi_nacl(se_nacl);\n\n\treturn sysfs_emit(page, \"%d\\n\", nacl->node_attrib.authentication);\n}\n\nstatic ssize_t iscsi_nacl_attrib_authentication_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_node_acl *se_nacl = attrib_to_nacl(item);\n\tstruct iscsi_node_acl *nacl = to_iscsi_nacl(se_nacl);\n\ts32 val;\n\tint ret;\n\n\tret = kstrtos32(page, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val != 0 && val != 1 && val != NA_AUTHENTICATION_INHERITED)\n\t\treturn -EINVAL;\n\n\tnacl->node_attrib.authentication = val;\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(iscsi_nacl_attrib_, authentication);\n\nstatic struct configfs_attribute *lio_target_nacl_attrib_attrs[] = {\n\t&iscsi_nacl_attrib_attr_dataout_timeout,\n\t&iscsi_nacl_attrib_attr_dataout_timeout_retries,\n\t&iscsi_nacl_attrib_attr_default_erl,\n\t&iscsi_nacl_attrib_attr_nopin_timeout,\n\t&iscsi_nacl_attrib_attr_nopin_response_timeout,\n\t&iscsi_nacl_attrib_attr_random_datain_pdu_offsets,\n\t&iscsi_nacl_attrib_attr_random_datain_seq_offsets,\n\t&iscsi_nacl_attrib_attr_random_r2t_offsets,\n\t&iscsi_nacl_attrib_attr_authentication,\n\tNULL,\n};\n\n \n\n \n\n#define __DEF_NACL_AUTH_STR(prefix, name, flags)\t\t\t\\\nstatic ssize_t __iscsi_##prefix##_##name##_show(\t\t\t\\\n\tstruct iscsi_node_acl *nacl,\t\t\t\t\t\\\n\tchar *page)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_node_auth *auth = &nacl->node_auth;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!capable(CAP_SYS_ADMIN))\t\t\t\t\t\\\n\t\treturn -EPERM;\t\t\t\t\t\t\\\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", auth->name);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t __iscsi_##prefix##_##name##_store(\t\t\t\\\n\tstruct iscsi_node_acl *nacl,\t\t\t\t\t\\\n\tconst char *page,\t\t\t\t\t\t\\\n\tsize_t count)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_node_auth *auth = &nacl->node_auth;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!capable(CAP_SYS_ADMIN))\t\t\t\t\t\\\n\t\treturn -EPERM;\t\t\t\t\t\t\\\n\tif (count >= sizeof(auth->name))\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\tsnprintf(auth->name, sizeof(auth->name), \"%s\", page);\t\t\\\n\tif (!strncmp(\"NULL\", auth->name, 4))\t\t\t\t\\\n\t\tauth->naf_flags &= ~flags;\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tauth->naf_flags |= flags;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif ((auth->naf_flags & NAF_USERID_IN_SET) &&\t\t\t\\\n\t    (auth->naf_flags & NAF_PASSWORD_IN_SET))\t\t\t\\\n\t\tauth->authenticate_target = 1;\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tauth->authenticate_target = 0;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define DEF_NACL_AUTH_STR(name, flags)\t\t\t\t\t\\\n\t__DEF_NACL_AUTH_STR(nacl_auth, name, flags)\t\t\t\\\nstatic ssize_t iscsi_nacl_auth_##name##_show(struct config_item *item,\t\\\n\t\tchar *page)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_node_acl *nacl = auth_to_nacl(item);\t\t\t\\\n\treturn __iscsi_nacl_auth_##name##_show(to_iscsi_nacl(nacl), page);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t iscsi_nacl_auth_##name##_store(struct config_item *item,\t\\\n\t\tconst char *page, size_t count)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_node_acl *nacl = auth_to_nacl(item);\t\t\t\\\n\treturn __iscsi_nacl_auth_##name##_store(to_iscsi_nacl(nacl),\t\\\n\t\t\t\t\t\tpage, count); \\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(iscsi_nacl_auth_, name)\n\n \nDEF_NACL_AUTH_STR(userid, NAF_USERID_SET);\nDEF_NACL_AUTH_STR(password, NAF_PASSWORD_SET);\nDEF_NACL_AUTH_STR(userid_mutual, NAF_USERID_IN_SET);\nDEF_NACL_AUTH_STR(password_mutual, NAF_PASSWORD_IN_SET);\n\n#define __DEF_NACL_AUTH_INT(prefix, name)\t\t\t\t\\\nstatic ssize_t __iscsi_##prefix##_##name##_show(\t\t\t\t\\\n\tstruct iscsi_node_acl *nacl,\t\t\t\t\t\\\n\tchar *page)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_node_auth *auth = &nacl->node_auth;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!capable(CAP_SYS_ADMIN))\t\t\t\t\t\\\n\t\treturn -EPERM;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\", auth->name);\t\t\\\n}\n\n#define DEF_NACL_AUTH_INT(name)\t\t\t\t\t\t\\\n\t__DEF_NACL_AUTH_INT(nacl_auth, name)\t\t\t\t\\\nstatic ssize_t iscsi_nacl_auth_##name##_show(struct config_item *item,\t\\\n\t\tchar *page)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_node_acl *nacl = auth_to_nacl(item);\t\t\t\\\n\treturn __iscsi_nacl_auth_##name##_show(to_iscsi_nacl(nacl), page);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR_RO(iscsi_nacl_auth_, name)\n\nDEF_NACL_AUTH_INT(authenticate_target);\n\nstatic struct configfs_attribute *lio_target_nacl_auth_attrs[] = {\n\t&iscsi_nacl_auth_attr_userid,\n\t&iscsi_nacl_auth_attr_password,\n\t&iscsi_nacl_auth_attr_authenticate_target,\n\t&iscsi_nacl_auth_attr_userid_mutual,\n\t&iscsi_nacl_auth_attr_password_mutual,\n\tNULL,\n};\n\n \n\n \n\n#define ISCSI_NACL_PARAM(name)\t\t\t\t\t\t\\\nstatic ssize_t iscsi_nacl_param_##name##_show(struct config_item *item,\t\\\n\t\tchar *page)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_node_acl *se_nacl = param_to_nacl(item);\t\t\\\n\tstruct iscsit_session *sess;\t\t\t\t\t\\\n\tstruct se_session *se_sess;\t\t\t\t\t\\\n\tssize_t rb;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tspin_lock_bh(&se_nacl->nacl_sess_lock);\t\t\t\t\\\n\tse_sess = se_nacl->nacl_sess;\t\t\t\t\t\\\n\tif (!se_sess) {\t\t\t\t\t\t\t\\\n\t\trb = snprintf(page, PAGE_SIZE,\t\t\t\t\\\n\t\t\t\"No Active iSCSI Session\\n\");\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tsess = se_sess->fabric_sess_ptr;\t\t\t\\\n\t\trb = snprintf(page, PAGE_SIZE, \"%u\\n\",\t\t\t\\\n\t\t\t(u32)sess->sess_ops->name);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tspin_unlock_bh(&se_nacl->nacl_sess_lock);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn rb;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR_RO(iscsi_nacl_param_, name)\n\nISCSI_NACL_PARAM(MaxConnections);\nISCSI_NACL_PARAM(InitialR2T);\nISCSI_NACL_PARAM(ImmediateData);\nISCSI_NACL_PARAM(MaxBurstLength);\nISCSI_NACL_PARAM(FirstBurstLength);\nISCSI_NACL_PARAM(DefaultTime2Wait);\nISCSI_NACL_PARAM(DefaultTime2Retain);\nISCSI_NACL_PARAM(MaxOutstandingR2T);\nISCSI_NACL_PARAM(DataPDUInOrder);\nISCSI_NACL_PARAM(DataSequenceInOrder);\nISCSI_NACL_PARAM(ErrorRecoveryLevel);\n\nstatic struct configfs_attribute *lio_target_nacl_param_attrs[] = {\n\t&iscsi_nacl_param_attr_MaxConnections,\n\t&iscsi_nacl_param_attr_InitialR2T,\n\t&iscsi_nacl_param_attr_ImmediateData,\n\t&iscsi_nacl_param_attr_MaxBurstLength,\n\t&iscsi_nacl_param_attr_FirstBurstLength,\n\t&iscsi_nacl_param_attr_DefaultTime2Wait,\n\t&iscsi_nacl_param_attr_DefaultTime2Retain,\n\t&iscsi_nacl_param_attr_MaxOutstandingR2T,\n\t&iscsi_nacl_param_attr_DataPDUInOrder,\n\t&iscsi_nacl_param_attr_DataSequenceInOrder,\n\t&iscsi_nacl_param_attr_ErrorRecoveryLevel,\n\tNULL,\n};\n\n \n\n \n\nstatic ssize_t lio_target_nacl_info_show(struct config_item *item, char *page)\n{\n\tstruct se_node_acl *se_nacl = acl_to_nacl(item);\n\tstruct iscsit_session *sess;\n\tstruct iscsit_conn *conn;\n\tstruct se_session *se_sess;\n\tssize_t rb = 0;\n\tu32 max_cmd_sn;\n\n\tspin_lock_bh(&se_nacl->nacl_sess_lock);\n\tse_sess = se_nacl->nacl_sess;\n\tif (!se_sess) {\n\t\trb += sysfs_emit_at(page, rb, \"No active iSCSI Session for Initiator\"\n\t\t\t\" Endpoint: %s\\n\", se_nacl->initiatorname);\n\t} else {\n\t\tsess = se_sess->fabric_sess_ptr;\n\n\t\trb += sysfs_emit_at(page, rb, \"InitiatorName: %s\\n\",\n\t\t\tsess->sess_ops->InitiatorName);\n\t\trb += sysfs_emit_at(page, rb, \"InitiatorAlias: %s\\n\",\n\t\t\tsess->sess_ops->InitiatorAlias);\n\n\t\trb += sysfs_emit_at(page, rb,\n\t\t\t      \"LIO Session ID: %u   ISID: 0x%6ph  TSIH: %hu  \",\n\t\t\t      sess->sid, sess->isid, sess->tsih);\n\t\trb += sysfs_emit_at(page, rb, \"SessionType: %s\\n\",\n\t\t\t\t(sess->sess_ops->SessionType) ?\n\t\t\t\t\"Discovery\" : \"Normal\");\n\t\trb += sysfs_emit_at(page, rb, \"Session State: \");\n\t\tswitch (sess->session_state) {\n\t\tcase TARG_SESS_STATE_FREE:\n\t\t\trb += sysfs_emit_at(page, rb, \"TARG_SESS_FREE\\n\");\n\t\t\tbreak;\n\t\tcase TARG_SESS_STATE_ACTIVE:\n\t\t\trb += sysfs_emit_at(page, rb, \"TARG_SESS_STATE_ACTIVE\\n\");\n\t\t\tbreak;\n\t\tcase TARG_SESS_STATE_LOGGED_IN:\n\t\t\trb += sysfs_emit_at(page, rb, \"TARG_SESS_STATE_LOGGED_IN\\n\");\n\t\t\tbreak;\n\t\tcase TARG_SESS_STATE_FAILED:\n\t\t\trb += sysfs_emit_at(page, rb, \"TARG_SESS_STATE_FAILED\\n\");\n\t\t\tbreak;\n\t\tcase TARG_SESS_STATE_IN_CONTINUE:\n\t\t\trb += sysfs_emit_at(page, rb, \"TARG_SESS_STATE_IN_CONTINUE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trb += sysfs_emit_at(page, rb, \"ERROR: Unknown Session\"\n\t\t\t\t\t\" State!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\trb += sysfs_emit_at(page, rb, \"---------------------[iSCSI Session\"\n\t\t\t\t\" Values]-----------------------\\n\");\n\t\trb += sysfs_emit_at(page, rb, \"  CmdSN/WR  :  CmdSN/WC  :  ExpCmdSN\"\n\t\t\t\t\"  :  MaxCmdSN  :     ITT    :     TTT\\n\");\n\t\tmax_cmd_sn = (u32) atomic_read(&sess->max_cmd_sn);\n\t\trb += sysfs_emit_at(page, rb, \" 0x%08x   0x%08x   0x%08x   0x%08x\"\n\t\t\t\t\"   0x%08x   0x%08x\\n\",\n\t\t\tsess->cmdsn_window,\n\t\t\t(max_cmd_sn - sess->exp_cmd_sn) + 1,\n\t\t\tsess->exp_cmd_sn, max_cmd_sn,\n\t\t\tsess->init_task_tag, sess->targ_xfer_tag);\n\t\trb += sysfs_emit_at(page, rb, \"----------------------[iSCSI\"\n\t\t\t\t\" Connections]-------------------------\\n\");\n\n\t\tspin_lock(&sess->conn_lock);\n\t\tlist_for_each_entry(conn, &sess->sess_conn_list, conn_list) {\n\t\t\trb += sysfs_emit_at(page, rb, \"CID: %hu  Connection\"\n\t\t\t\t\t\" State: \", conn->cid);\n\t\t\tswitch (conn->conn_state) {\n\t\t\tcase TARG_CONN_STATE_FREE:\n\t\t\t\trb += sysfs_emit_at(page, rb,\n\t\t\t\t\t\"TARG_CONN_STATE_FREE\\n\");\n\t\t\t\tbreak;\n\t\t\tcase TARG_CONN_STATE_XPT_UP:\n\t\t\t\trb += sysfs_emit_at(page, rb,\n\t\t\t\t\t\"TARG_CONN_STATE_XPT_UP\\n\");\n\t\t\t\tbreak;\n\t\t\tcase TARG_CONN_STATE_IN_LOGIN:\n\t\t\t\trb += sysfs_emit_at(page, rb,\n\t\t\t\t\t\"TARG_CONN_STATE_IN_LOGIN\\n\");\n\t\t\t\tbreak;\n\t\t\tcase TARG_CONN_STATE_LOGGED_IN:\n\t\t\t\trb += sysfs_emit_at(page, rb,\n\t\t\t\t\t\"TARG_CONN_STATE_LOGGED_IN\\n\");\n\t\t\t\tbreak;\n\t\t\tcase TARG_CONN_STATE_IN_LOGOUT:\n\t\t\t\trb += sysfs_emit_at(page, rb,\n\t\t\t\t\t\"TARG_CONN_STATE_IN_LOGOUT\\n\");\n\t\t\t\tbreak;\n\t\t\tcase TARG_CONN_STATE_LOGOUT_REQUESTED:\n\t\t\t\trb += sysfs_emit_at(page, rb,\n\t\t\t\t\t\"TARG_CONN_STATE_LOGOUT_REQUESTED\\n\");\n\t\t\t\tbreak;\n\t\t\tcase TARG_CONN_STATE_CLEANUP_WAIT:\n\t\t\t\trb += sysfs_emit_at(page, rb,\n\t\t\t\t\t\"TARG_CONN_STATE_CLEANUP_WAIT\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trb += sysfs_emit_at(page, rb,\n\t\t\t\t\t\"ERROR: Unknown Connection State!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trb += sysfs_emit_at(page, rb, \"   Address %pISc %s\", &conn->login_sockaddr,\n\t\t\t\t(conn->network_transport == ISCSI_TCP) ?\n\t\t\t\t\"TCP\" : \"SCTP\");\n\t\t\trb += sysfs_emit_at(page, rb, \"  StatSN: 0x%08x\\n\",\n\t\t\t\tconn->stat_sn);\n\t\t}\n\t\tspin_unlock(&sess->conn_lock);\n\t}\n\tspin_unlock_bh(&se_nacl->nacl_sess_lock);\n\n\treturn rb;\n}\n\nstatic ssize_t lio_target_nacl_cmdsn_depth_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sysfs_emit(page, \"%u\\n\", acl_to_nacl(item)->queue_depth);\n}\n\nstatic ssize_t lio_target_nacl_cmdsn_depth_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_node_acl *se_nacl = acl_to_nacl(item);\n\tstruct se_portal_group *se_tpg = se_nacl->se_tpg;\n\tstruct iscsi_portal_group *tpg = to_iscsi_tpg(se_tpg);\n\tstruct config_item *acl_ci, *tpg_ci, *wwn_ci;\n\tu32 cmdsn_depth = 0;\n\tint ret;\n\n\tret = kstrtou32(page, 0, &cmdsn_depth);\n\tif (ret)\n\t\treturn ret;\n\tif (cmdsn_depth > TA_DEFAULT_CMDSN_DEPTH_MAX) {\n\t\tpr_err(\"Passed cmdsn_depth: %u exceeds\"\n\t\t\t\" TA_DEFAULT_CMDSN_DEPTH_MAX: %u\\n\", cmdsn_depth,\n\t\t\tTA_DEFAULT_CMDSN_DEPTH_MAX);\n\t\treturn -EINVAL;\n\t}\n\tacl_ci = &se_nacl->acl_group.cg_item;\n\tif (!acl_ci) {\n\t\tpr_err(\"Unable to locatel acl_ci\\n\");\n\t\treturn -EINVAL;\n\t}\n\ttpg_ci = &acl_ci->ci_parent->ci_group->cg_item;\n\tif (!tpg_ci) {\n\t\tpr_err(\"Unable to locate tpg_ci\\n\");\n\t\treturn -EINVAL;\n\t}\n\twwn_ci = &tpg_ci->ci_group->cg_item;\n\tif (!wwn_ci) {\n\t\tpr_err(\"Unable to locate config_item wwn_ci\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (iscsit_get_tpg(tpg) < 0)\n\t\treturn -EINVAL;\n\n\tret = core_tpg_set_initiator_node_queue_depth(se_nacl, cmdsn_depth);\n\n\tpr_debug(\"LIO_Target_ConfigFS: %s/%s Set CmdSN Window: %u for\"\n\t\t\"InitiatorName: %s\\n\", config_item_name(wwn_ci),\n\t\tconfig_item_name(tpg_ci), cmdsn_depth,\n\t\tconfig_item_name(acl_ci));\n\n\tiscsit_put_tpg(tpg);\n\treturn (!ret) ? count : (ssize_t)ret;\n}\n\nstatic ssize_t lio_target_nacl_tag_show(struct config_item *item, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%s\", acl_to_nacl(item)->acl_tag);\n}\n\nstatic ssize_t lio_target_nacl_tag_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_node_acl *se_nacl = acl_to_nacl(item);\n\tint ret;\n\n\tret = core_tpg_set_initiator_node_tag(se_nacl->se_tpg, se_nacl, page);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\nCONFIGFS_ATTR_RO(lio_target_nacl_, info);\nCONFIGFS_ATTR(lio_target_nacl_, cmdsn_depth);\nCONFIGFS_ATTR(lio_target_nacl_, tag);\n\nstatic struct configfs_attribute *lio_target_initiator_attrs[] = {\n\t&lio_target_nacl_attr_info,\n\t&lio_target_nacl_attr_cmdsn_depth,\n\t&lio_target_nacl_attr_tag,\n\tNULL,\n};\n\nstatic int lio_target_init_nodeacl(struct se_node_acl *se_nacl,\n\t\tconst char *name)\n{\n\tstruct iscsi_node_acl *acl = to_iscsi_nacl(se_nacl);\n\n\tconfig_group_init_type_name(&acl->node_stat_grps.iscsi_sess_stats_group,\n\t\t\t\"iscsi_sess_stats\", &iscsi_stat_sess_cit);\n\tconfigfs_add_default_group(&acl->node_stat_grps.iscsi_sess_stats_group,\n\t\t\t&se_nacl->acl_fabric_stat_group);\n\treturn 0;\n}\n\n \n\n \n\n#define DEF_TPG_ATTRIB(name)\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t iscsi_tpg_attrib_##name##_show(struct config_item *item,\t\\\n\t\tchar *page)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\t\t\\\n\tstruct iscsi_portal_group *tpg = to_iscsi_tpg(se_tpg);\t\t\\\n\tssize_t rb;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (iscsit_get_tpg(tpg) < 0)\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\trb = sysfs_emit(page, \"%u\\n\", tpg->tpg_attrib.name);\t\t\\\n\tiscsit_put_tpg(tpg);\t\t\t\t\t\t\\\n\treturn rb;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t iscsi_tpg_attrib_##name##_store(struct config_item *item,\\\n\t\tconst char *page, size_t count)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\t\t\\\n\tstruct iscsi_portal_group *tpg = to_iscsi_tpg(se_tpg);\t\t\\\n\tu32 val;\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (iscsit_get_tpg(tpg) < 0)\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou32(page, 0, &val);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\\\n\tret = iscsit_ta_##name(tpg, val);\t\t\t\t\\\n\tif (ret < 0)\t\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tiscsit_put_tpg(tpg);\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\nout:\t\t\t\t\t\t\t\t\t\\\n\tiscsit_put_tpg(tpg);\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(iscsi_tpg_attrib_, name)\n\nDEF_TPG_ATTRIB(authentication);\nDEF_TPG_ATTRIB(login_timeout);\nDEF_TPG_ATTRIB(generate_node_acls);\nDEF_TPG_ATTRIB(default_cmdsn_depth);\nDEF_TPG_ATTRIB(cache_dynamic_acls);\nDEF_TPG_ATTRIB(demo_mode_write_protect);\nDEF_TPG_ATTRIB(prod_mode_write_protect);\nDEF_TPG_ATTRIB(demo_mode_discovery);\nDEF_TPG_ATTRIB(default_erl);\nDEF_TPG_ATTRIB(t10_pi);\nDEF_TPG_ATTRIB(fabric_prot_type);\nDEF_TPG_ATTRIB(tpg_enabled_sendtargets);\nDEF_TPG_ATTRIB(login_keys_workaround);\n\nstatic struct configfs_attribute *lio_target_tpg_attrib_attrs[] = {\n\t&iscsi_tpg_attrib_attr_authentication,\n\t&iscsi_tpg_attrib_attr_login_timeout,\n\t&iscsi_tpg_attrib_attr_generate_node_acls,\n\t&iscsi_tpg_attrib_attr_default_cmdsn_depth,\n\t&iscsi_tpg_attrib_attr_cache_dynamic_acls,\n\t&iscsi_tpg_attrib_attr_demo_mode_write_protect,\n\t&iscsi_tpg_attrib_attr_prod_mode_write_protect,\n\t&iscsi_tpg_attrib_attr_demo_mode_discovery,\n\t&iscsi_tpg_attrib_attr_default_erl,\n\t&iscsi_tpg_attrib_attr_t10_pi,\n\t&iscsi_tpg_attrib_attr_fabric_prot_type,\n\t&iscsi_tpg_attrib_attr_tpg_enabled_sendtargets,\n\t&iscsi_tpg_attrib_attr_login_keys_workaround,\n\tNULL,\n};\n\n \n\n \n\n#define __DEF_TPG_AUTH_STR(prefix, name, flags)\t\t\t\t\t\\\nstatic ssize_t __iscsi_##prefix##_##name##_show(struct se_portal_group *se_tpg,\t\\\n\t\tchar *page)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_portal_group *tpg = to_iscsi_tpg(se_tpg);\t\t\t\\\n\tstruct iscsi_node_auth *auth = &tpg->tpg_demo_auth;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (!capable(CAP_SYS_ADMIN))\t\t\t\t\t\t\\\n\t\treturn -EPERM;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", auth->name);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t __iscsi_##prefix##_##name##_store(struct se_portal_group *se_tpg,\\\n\t\tconst char *page, size_t count)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_portal_group *tpg = to_iscsi_tpg(se_tpg);\t\t\t\\\n\tstruct iscsi_node_auth *auth = &tpg->tpg_demo_auth;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (!capable(CAP_SYS_ADMIN))\t\t\t\t\t\t\\\n\t\treturn -EPERM;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tsnprintf(auth->name, sizeof(auth->name), \"%s\", page);\t\t\t\\\n\tif (!(strncmp(\"NULL\", auth->name, 4)))\t\t\t\t\t\\\n\t\tauth->naf_flags &= ~flags;\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\t\\\n\t\tauth->naf_flags |= flags;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif ((auth->naf_flags & NAF_USERID_IN_SET) &&\t\t\t\t\\\n\t    (auth->naf_flags & NAF_PASSWORD_IN_SET))\t\t\t\t\\\n\t\tauth->authenticate_target = 1;\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\t\\\n\t\tauth->authenticate_target = 0;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\t\\\n}\n\n#define DEF_TPG_AUTH_STR(name, flags)\t\t\t\t\t\t\\\n\t__DEF_TPG_AUTH_STR(tpg_auth, name, flags)\t\t\t\t\\\nstatic ssize_t iscsi_tpg_auth_##name##_show(struct config_item *item,\t\t\\\n\t\tchar *page)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn __iscsi_tpg_auth_##name##_show(auth_to_tpg(item), page);\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t iscsi_tpg_auth_##name##_store(struct config_item *item,\t\t\\\n\t\tconst char *page, size_t count)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn __iscsi_tpg_auth_##name##_store(auth_to_tpg(item), page, count);\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(iscsi_tpg_auth_, name);\n\n\nDEF_TPG_AUTH_STR(userid, NAF_USERID_SET);\nDEF_TPG_AUTH_STR(password, NAF_PASSWORD_SET);\nDEF_TPG_AUTH_STR(userid_mutual, NAF_USERID_IN_SET);\nDEF_TPG_AUTH_STR(password_mutual, NAF_PASSWORD_IN_SET);\n\n#define __DEF_TPG_AUTH_INT(prefix, name)\t\t\t\t\t\\\nstatic ssize_t __iscsi_##prefix##_##name##_show(struct se_portal_group *se_tpg,\t\\\n\t\tchar *page)\t\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct iscsi_portal_group *tpg = to_iscsi_tpg(se_tpg);\t\t\t\\\n\tstruct iscsi_node_auth *auth = &tpg->tpg_demo_auth;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (!capable(CAP_SYS_ADMIN))\t\t\t\t\t\t\\\n\t\treturn -EPERM;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\", auth->name);\t\t\t\\\n}\n\n#define DEF_TPG_AUTH_INT(name)\t\t\t\t\t\t\t\\\n\t__DEF_TPG_AUTH_INT(tpg_auth, name)\t\t\t\t\t\\\nstatic ssize_t iscsi_tpg_auth_##name##_show(struct config_item *item,\t\t\\\n\t\tchar *page) \\\n{\t\t\t\t\t\t\t\t\t\t\\\n\treturn __iscsi_tpg_auth_##name##_show(auth_to_tpg(item), page);\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR_RO(iscsi_tpg_auth_, name);\n\nDEF_TPG_AUTH_INT(authenticate_target);\n\nstatic struct configfs_attribute *lio_target_tpg_auth_attrs[] = {\n\t&iscsi_tpg_auth_attr_userid,\n\t&iscsi_tpg_auth_attr_password,\n\t&iscsi_tpg_auth_attr_authenticate_target,\n\t&iscsi_tpg_auth_attr_userid_mutual,\n\t&iscsi_tpg_auth_attr_password_mutual,\n\tNULL,\n};\n\n \n\n \n\n#define DEF_TPG_PARAM(name)\t\t\t\t\t\t\\\nstatic ssize_t iscsi_tpg_param_##name##_show(struct config_item *item,\t\\\n\t\tchar *page)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_portal_group *se_tpg = param_to_tpg(item);\t\t\\\n\tstruct iscsi_portal_group *tpg = to_iscsi_tpg(se_tpg);\t\t\\\n\tstruct iscsi_param *param;\t\t\t\t\t\\\n\tssize_t rb;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (iscsit_get_tpg(tpg) < 0)\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tparam = iscsi_find_param_from_key(__stringify(name),\t\t\\\n\t\t\t\ttpg->param_list);\t\t\t\\\n\tif (!param) {\t\t\t\t\t\t\t\\\n\t\tiscsit_put_tpg(tpg);\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\trb = snprintf(page, PAGE_SIZE, \"%s\\n\", param->value);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tiscsit_put_tpg(tpg);\t\t\t\t\t\t\\\n\treturn rb;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t iscsi_tpg_param_##name##_store(struct config_item *item, \\\n\t\tconst char *page, size_t count)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_portal_group *se_tpg = param_to_tpg(item);\t\t\\\n\tstruct iscsi_portal_group *tpg = to_iscsi_tpg(se_tpg);\t\t\\\n\tchar *buf;\t\t\t\t\t\t\t\\\n\tint ret, len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tbuf = kzalloc(PAGE_SIZE, GFP_KERNEL);\t\t\t\t\\\n\tif (!buf)\t\t\t\t\t\t\t\\\n\t\treturn -ENOMEM;\t\t\t\t\t\t\\\n\tlen = snprintf(buf, PAGE_SIZE, \"%s=%s\", __stringify(name), page);\t\\\n\tif (isspace(buf[len-1]))\t\t\t\t\t\\\n\t\tbuf[len-1] = '\\0';  \t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (iscsit_get_tpg(tpg) < 0) {\t\t\t\t\t\\\n\t\tkfree(buf);\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = iscsi_change_param_value(buf, tpg->param_list, 1);\t\\\n\tif (ret < 0)\t\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tkfree(buf);\t\t\t\t\t\t\t\\\n\tiscsit_put_tpg(tpg);\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\nout:\t\t\t\t\t\t\t\t\t\\\n\tkfree(buf);\t\t\t\t\t\t\t\\\n\tiscsit_put_tpg(tpg);\t\t\t\t\t\t\\\n\treturn -EINVAL;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(iscsi_tpg_param_, name)\n\nDEF_TPG_PARAM(AuthMethod);\nDEF_TPG_PARAM(HeaderDigest);\nDEF_TPG_PARAM(DataDigest);\nDEF_TPG_PARAM(MaxConnections);\nDEF_TPG_PARAM(TargetAlias);\nDEF_TPG_PARAM(InitialR2T);\nDEF_TPG_PARAM(ImmediateData);\nDEF_TPG_PARAM(MaxRecvDataSegmentLength);\nDEF_TPG_PARAM(MaxXmitDataSegmentLength);\nDEF_TPG_PARAM(MaxBurstLength);\nDEF_TPG_PARAM(FirstBurstLength);\nDEF_TPG_PARAM(DefaultTime2Wait);\nDEF_TPG_PARAM(DefaultTime2Retain);\nDEF_TPG_PARAM(MaxOutstandingR2T);\nDEF_TPG_PARAM(DataPDUInOrder);\nDEF_TPG_PARAM(DataSequenceInOrder);\nDEF_TPG_PARAM(ErrorRecoveryLevel);\nDEF_TPG_PARAM(IFMarker);\nDEF_TPG_PARAM(OFMarker);\nDEF_TPG_PARAM(IFMarkInt);\nDEF_TPG_PARAM(OFMarkInt);\n\nstatic struct configfs_attribute *lio_target_tpg_param_attrs[] = {\n\t&iscsi_tpg_param_attr_AuthMethod,\n\t&iscsi_tpg_param_attr_HeaderDigest,\n\t&iscsi_tpg_param_attr_DataDigest,\n\t&iscsi_tpg_param_attr_MaxConnections,\n\t&iscsi_tpg_param_attr_TargetAlias,\n\t&iscsi_tpg_param_attr_InitialR2T,\n\t&iscsi_tpg_param_attr_ImmediateData,\n\t&iscsi_tpg_param_attr_MaxRecvDataSegmentLength,\n\t&iscsi_tpg_param_attr_MaxXmitDataSegmentLength,\n\t&iscsi_tpg_param_attr_MaxBurstLength,\n\t&iscsi_tpg_param_attr_FirstBurstLength,\n\t&iscsi_tpg_param_attr_DefaultTime2Wait,\n\t&iscsi_tpg_param_attr_DefaultTime2Retain,\n\t&iscsi_tpg_param_attr_MaxOutstandingR2T,\n\t&iscsi_tpg_param_attr_DataPDUInOrder,\n\t&iscsi_tpg_param_attr_DataSequenceInOrder,\n\t&iscsi_tpg_param_attr_ErrorRecoveryLevel,\n\t&iscsi_tpg_param_attr_IFMarker,\n\t&iscsi_tpg_param_attr_OFMarker,\n\t&iscsi_tpg_param_attr_IFMarkInt,\n\t&iscsi_tpg_param_attr_OFMarkInt,\n\tNULL,\n};\n\n \n\n \n\nstatic ssize_t lio_target_tpg_dynamic_sessions_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn target_show_dynamic_sessions(to_tpg(item), page);\n}\n\nCONFIGFS_ATTR_RO(lio_target_tpg_, dynamic_sessions);\n\nstatic struct configfs_attribute *lio_target_tpg_attrs[] = {\n\t&lio_target_tpg_attr_dynamic_sessions,\n\tNULL,\n};\n\n \n\n \n\nstatic struct se_portal_group *lio_target_tiqn_addtpg(struct se_wwn *wwn,\n\t\t\t\t\t\t      const char *name)\n{\n\tstruct iscsi_portal_group *tpg;\n\tstruct iscsi_tiqn *tiqn;\n\tchar *tpgt_str;\n\tint ret;\n\tu16 tpgt;\n\n\ttiqn = container_of(wwn, struct iscsi_tiqn, tiqn_wwn);\n\t \n\ttpgt_str = strstr(name, \"tpgt_\");\n\tif (!tpgt_str) {\n\t\tpr_err(\"Unable to locate \\\"tpgt_#\\\" directory\"\n\t\t\t\t\" group\\n\");\n\t\treturn NULL;\n\t}\n\ttpgt_str += 5;  \n\tret = kstrtou16(tpgt_str, 0, &tpgt);\n\tif (ret)\n\t\treturn NULL;\n\n\ttpg = iscsit_alloc_portal_group(tiqn, tpgt);\n\tif (!tpg)\n\t\treturn NULL;\n\n\tret = core_tpg_register(wwn, &tpg->tpg_se_tpg, SCSI_PROTOCOL_ISCSI);\n\tif (ret < 0)\n\t\tgoto free_out;\n\n\tret = iscsit_tpg_add_portal_group(tiqn, tpg);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tpr_debug(\"LIO_Target_ConfigFS: REGISTER -> %s\\n\", tiqn->tiqn);\n\tpr_debug(\"LIO_Target_ConfigFS: REGISTER -> Allocated TPG: %s\\n\",\n\t\t\tname);\n\treturn &tpg->tpg_se_tpg;\nout:\n\tcore_tpg_deregister(&tpg->tpg_se_tpg);\nfree_out:\n\tkfree(tpg);\n\treturn NULL;\n}\n\nstatic int lio_target_tiqn_enabletpg(struct se_portal_group *se_tpg,\n\t\t\t\t     bool enable)\n{\n\tstruct iscsi_portal_group *tpg = to_iscsi_tpg(se_tpg);\n\tint ret;\n\n\tret = iscsit_get_tpg(tpg);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tif (enable) {\n\t\tret = iscsit_tpg_enable_portal_group(tpg);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\t \n\t\tret = iscsit_tpg_disable_portal_group(tpg, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tiscsit_put_tpg(tpg);\n\treturn 0;\nout:\n\tiscsit_put_tpg(tpg);\n\treturn -EINVAL;\n}\n\nstatic void lio_target_tiqn_deltpg(struct se_portal_group *se_tpg)\n{\n\tstruct iscsi_portal_group *tpg;\n\tstruct iscsi_tiqn *tiqn;\n\n\ttpg = to_iscsi_tpg(se_tpg);\n\ttiqn = tpg->tpg_tiqn;\n\t \n\tpr_debug(\"LIO_Target_ConfigFS: DEREGISTER -> Releasing TPG\\n\");\n\tiscsit_tpg_del_portal_group(tiqn, tpg, 1);\n}\n\n \n\n \n\nstatic ssize_t lio_target_wwn_lio_version_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sysfs_emit(page, \"Datera Inc. iSCSI Target %s\\n\", ISCSIT_VERSION);\n}\n\nCONFIGFS_ATTR_RO(lio_target_wwn_, lio_version);\n\nstatic ssize_t lio_target_wwn_cpus_allowed_list_show(\n\t\tstruct config_item *item, char *page)\n{\n\treturn sysfs_emit(page, \"%*pbl\\n\",\n\t\t       cpumask_pr_args(iscsit_global->allowed_cpumask));\n}\n\nstatic ssize_t lio_target_wwn_cpus_allowed_list_store(\n\t\tstruct config_item *item, const char *page, size_t count)\n{\n\tint ret = -ENOMEM;\n\tchar *orig;\n\tcpumask_var_t new_allowed_cpumask;\n\n\tif (!zalloc_cpumask_var(&new_allowed_cpumask, GFP_KERNEL))\n\t\tgoto out;\n\n\torig = kstrdup(page, GFP_KERNEL);\n\tif (!orig)\n\t\tgoto out_free_cpumask;\n\n\tret = cpulist_parse(orig, new_allowed_cpumask);\n\tif (!ret)\n\t\tcpumask_copy(iscsit_global->allowed_cpumask,\n\t\t\t     new_allowed_cpumask);\n\n\tkfree(orig);\nout_free_cpumask:\n\tfree_cpumask_var(new_allowed_cpumask);\nout:\n\treturn ret ? ret : count;\n}\n\nCONFIGFS_ATTR(lio_target_wwn_, cpus_allowed_list);\n\nstatic struct configfs_attribute *lio_target_wwn_attrs[] = {\n\t&lio_target_wwn_attr_lio_version,\n\t&lio_target_wwn_attr_cpus_allowed_list,\n\tNULL,\n};\n\nstatic struct se_wwn *lio_target_call_coreaddtiqn(\n\tstruct target_fabric_configfs *tf,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct iscsi_tiqn *tiqn;\n\n\ttiqn = iscsit_add_tiqn((unsigned char *)name);\n\tif (IS_ERR(tiqn))\n\t\treturn ERR_CAST(tiqn);\n\n\tpr_debug(\"LIO_Target_ConfigFS: REGISTER -> %s\\n\", tiqn->tiqn);\n\tpr_debug(\"LIO_Target_ConfigFS: REGISTER -> Allocated Node:\"\n\t\t\t\" %s\\n\", name);\n\treturn &tiqn->tiqn_wwn;\n}\n\nstatic void lio_target_add_wwn_groups(struct se_wwn *wwn)\n{\n\tstruct iscsi_tiqn *tiqn = container_of(wwn, struct iscsi_tiqn, tiqn_wwn);\n\n\tconfig_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_instance_group,\n\t\t\t\"iscsi_instance\", &iscsi_stat_instance_cit);\n\tconfigfs_add_default_group(&tiqn->tiqn_stat_grps.iscsi_instance_group,\n\t\t\t&tiqn->tiqn_wwn.fabric_stat_group);\n\n\tconfig_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_sess_err_group,\n\t\t\t\"iscsi_sess_err\", &iscsi_stat_sess_err_cit);\n\tconfigfs_add_default_group(&tiqn->tiqn_stat_grps.iscsi_sess_err_group,\n\t\t\t&tiqn->tiqn_wwn.fabric_stat_group);\n\n\tconfig_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_tgt_attr_group,\n\t\t\t\"iscsi_tgt_attr\", &iscsi_stat_tgt_attr_cit);\n\tconfigfs_add_default_group(&tiqn->tiqn_stat_grps.iscsi_tgt_attr_group,\n\t\t\t&tiqn->tiqn_wwn.fabric_stat_group);\n\n\tconfig_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_login_stats_group,\n\t\t\t\"iscsi_login_stats\", &iscsi_stat_login_cit);\n\tconfigfs_add_default_group(&tiqn->tiqn_stat_grps.iscsi_login_stats_group,\n\t\t\t&tiqn->tiqn_wwn.fabric_stat_group);\n\n\tconfig_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_logout_stats_group,\n\t\t\t\"iscsi_logout_stats\", &iscsi_stat_logout_cit);\n\tconfigfs_add_default_group(&tiqn->tiqn_stat_grps.iscsi_logout_stats_group,\n\t\t\t&tiqn->tiqn_wwn.fabric_stat_group);\n}\n\nstatic void lio_target_call_coredeltiqn(\n\tstruct se_wwn *wwn)\n{\n\tstruct iscsi_tiqn *tiqn = container_of(wwn, struct iscsi_tiqn, tiqn_wwn);\n\n\tpr_debug(\"LIO_Target_ConfigFS: DEREGISTER -> %s\\n\",\n\t\t\ttiqn->tiqn);\n\tiscsit_del_tiqn(tiqn);\n}\n\n \n\n \n\n#define DEF_DISC_AUTH_STR(name, flags)\t\t\t\t\t\\\n\t__DEF_NACL_AUTH_STR(disc, name, flags)\t\t\t\t\\\nstatic ssize_t iscsi_disc_##name##_show(struct config_item *item, char *page) \\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn __iscsi_disc_##name##_show(&iscsit_global->discovery_acl,\\\n\t\tpage);\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t iscsi_disc_##name##_store(struct config_item *item,\t\\\n\t\tconst char *page, size_t count)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn __iscsi_disc_##name##_store(&iscsit_global->discovery_acl,\t\\\n\t\tpage, count);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(iscsi_disc_, name)\n\nDEF_DISC_AUTH_STR(userid, NAF_USERID_SET);\nDEF_DISC_AUTH_STR(password, NAF_PASSWORD_SET);\nDEF_DISC_AUTH_STR(userid_mutual, NAF_USERID_IN_SET);\nDEF_DISC_AUTH_STR(password_mutual, NAF_PASSWORD_IN_SET);\n\n#define DEF_DISC_AUTH_INT(name)\t\t\t\t\t\t\\\n\t__DEF_NACL_AUTH_INT(disc, name)\t\t\t\t\t\\\nstatic ssize_t iscsi_disc_##name##_show(struct config_item *item, char *page) \\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn __iscsi_disc_##name##_show(&iscsit_global->discovery_acl, \\\n\t\t\tpage);\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR_RO(iscsi_disc_, name)\n\nDEF_DISC_AUTH_INT(authenticate_target);\n\n\nstatic ssize_t iscsi_disc_enforce_discovery_auth_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct iscsi_node_auth *discovery_auth = &iscsit_global->discovery_acl.node_auth;\n\n\treturn sysfs_emit(page, \"%d\\n\", discovery_auth->enforce_discovery_auth);\n}\n\nstatic ssize_t iscsi_disc_enforce_discovery_auth_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct iscsi_param *param;\n\tstruct iscsi_portal_group *discovery_tpg = iscsit_global->discovery_tpg;\n\tu32 op;\n\tint err;\n\n\terr = kstrtou32(page, 0, &op);\n\tif (err)\n\t\treturn -EINVAL;\n\tif ((op != 1) && (op != 0)) {\n\t\tpr_err(\"Illegal value for enforce_discovery_auth:\"\n\t\t\t\t\" %u\\n\", op);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!discovery_tpg) {\n\t\tpr_err(\"iscsit_global->discovery_tpg is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tparam = iscsi_find_param_from_key(AUTHMETHOD,\n\t\t\t\tdiscovery_tpg->param_list);\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (op) {\n\t\t \n\t\tif (iscsi_update_param_value(param, CHAP) < 0)\n\t\t\treturn -EINVAL;\n\n\t\tdiscovery_tpg->tpg_attrib.authentication = 1;\n\t\tiscsit_global->discovery_acl.node_auth.enforce_discovery_auth = 1;\n\t\tpr_debug(\"LIO-CORE[0] Successfully enabled\"\n\t\t\t\" authentication enforcement for iSCSI\"\n\t\t\t\" Discovery TPG\\n\");\n\t} else {\n\t\t \n\t\tif (iscsi_update_param_value(param, \"CHAP,None\") < 0)\n\t\t\treturn -EINVAL;\n\n\t\tdiscovery_tpg->tpg_attrib.authentication = 0;\n\t\tiscsit_global->discovery_acl.node_auth.enforce_discovery_auth = 0;\n\t\tpr_debug(\"LIO-CORE[0] Successfully disabled\"\n\t\t\t\" authentication enforcement for iSCSI\"\n\t\t\t\" Discovery TPG\\n\");\n\t}\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(iscsi_disc_, enforce_discovery_auth);\n\nstatic struct configfs_attribute *lio_target_discovery_auth_attrs[] = {\n\t&iscsi_disc_attr_userid,\n\t&iscsi_disc_attr_password,\n\t&iscsi_disc_attr_authenticate_target,\n\t&iscsi_disc_attr_userid_mutual,\n\t&iscsi_disc_attr_password_mutual,\n\t&iscsi_disc_attr_enforce_discovery_auth,\n\tNULL,\n};\n\n \n\n \n\nstatic int iscsi_get_cmd_state(struct se_cmd *se_cmd)\n{\n\tstruct iscsit_cmd *cmd = container_of(se_cmd, struct iscsit_cmd, se_cmd);\n\n\treturn cmd->i_state;\n}\n\nstatic u32 lio_sess_get_index(struct se_session *se_sess)\n{\n\tstruct iscsit_session *sess = se_sess->fabric_sess_ptr;\n\n\treturn sess->session_index;\n}\n\nstatic u32 lio_sess_get_initiator_sid(\n\tstruct se_session *se_sess,\n\tunsigned char *buf,\n\tu32 size)\n{\n\tstruct iscsit_session *sess = se_sess->fabric_sess_ptr;\n\t \n\treturn snprintf(buf, size, \"%6phN\", sess->isid);\n}\n\nstatic int lio_queue_data_in(struct se_cmd *se_cmd)\n{\n\tstruct iscsit_cmd *cmd = container_of(se_cmd, struct iscsit_cmd, se_cmd);\n\tstruct iscsit_conn *conn = cmd->conn;\n\n\tcmd->i_state = ISTATE_SEND_DATAIN;\n\treturn conn->conn_transport->iscsit_queue_data_in(conn, cmd);\n}\n\nstatic int lio_write_pending(struct se_cmd *se_cmd)\n{\n\tstruct iscsit_cmd *cmd = container_of(se_cmd, struct iscsit_cmd, se_cmd);\n\tstruct iscsit_conn *conn = cmd->conn;\n\n\tif (!cmd->immediate_data && !cmd->unsolicited_data)\n\t\treturn conn->conn_transport->iscsit_get_dataout(conn, cmd, false);\n\n\treturn 0;\n}\n\nstatic int lio_queue_status(struct se_cmd *se_cmd)\n{\n\tstruct iscsit_cmd *cmd = container_of(se_cmd, struct iscsit_cmd, se_cmd);\n\tstruct iscsit_conn *conn = cmd->conn;\n\n\tcmd->i_state = ISTATE_SEND_STATUS;\n\n\tif (cmd->se_cmd.scsi_status || cmd->sense_reason) {\n\t\treturn iscsit_add_cmd_to_response_queue(cmd, conn, cmd->i_state);\n\t}\n\treturn conn->conn_transport->iscsit_queue_status(conn, cmd);\n}\n\nstatic void lio_queue_tm_rsp(struct se_cmd *se_cmd)\n{\n\tstruct iscsit_cmd *cmd = container_of(se_cmd, struct iscsit_cmd, se_cmd);\n\n\tcmd->i_state = ISTATE_SEND_TASKMGTRSP;\n\tiscsit_add_cmd_to_response_queue(cmd, cmd->conn, cmd->i_state);\n}\n\nstatic void lio_aborted_task(struct se_cmd *se_cmd)\n{\n\tstruct iscsit_cmd *cmd = container_of(se_cmd, struct iscsit_cmd, se_cmd);\n\n\tcmd->conn->conn_transport->iscsit_aborted_task(cmd->conn, cmd);\n}\n\nstatic char *lio_tpg_get_endpoint_wwn(struct se_portal_group *se_tpg)\n{\n\treturn to_iscsi_tpg(se_tpg)->tpg_tiqn->tiqn;\n}\n\nstatic u16 lio_tpg_get_tag(struct se_portal_group *se_tpg)\n{\n\treturn to_iscsi_tpg(se_tpg)->tpgt;\n}\n\nstatic u32 lio_tpg_get_default_depth(struct se_portal_group *se_tpg)\n{\n\treturn to_iscsi_tpg(se_tpg)->tpg_attrib.default_cmdsn_depth;\n}\n\nstatic int lio_tpg_check_demo_mode(struct se_portal_group *se_tpg)\n{\n\treturn to_iscsi_tpg(se_tpg)->tpg_attrib.generate_node_acls;\n}\n\nstatic int lio_tpg_check_demo_mode_cache(struct se_portal_group *se_tpg)\n{\n\treturn to_iscsi_tpg(se_tpg)->tpg_attrib.cache_dynamic_acls;\n}\n\nstatic int lio_tpg_check_demo_mode_write_protect(\n\tstruct se_portal_group *se_tpg)\n{\n\treturn to_iscsi_tpg(se_tpg)->tpg_attrib.demo_mode_write_protect;\n}\n\nstatic int lio_tpg_check_prod_mode_write_protect(\n\tstruct se_portal_group *se_tpg)\n{\n\treturn to_iscsi_tpg(se_tpg)->tpg_attrib.prod_mode_write_protect;\n}\n\nstatic int lio_tpg_check_prot_fabric_only(\n\tstruct se_portal_group *se_tpg)\n{\n\t \n\tif (!to_iscsi_tpg(se_tpg)->tpg_attrib.t10_pi)\n\t\treturn 0;\n\treturn to_iscsi_tpg(se_tpg)->tpg_attrib.fabric_prot_type;\n}\n\n \nstatic void lio_tpg_close_session(struct se_session *se_sess)\n{\n\tstruct iscsit_session *sess = se_sess->fabric_sess_ptr;\n\tstruct se_portal_group *se_tpg = &sess->tpg->tpg_se_tpg;\n\n\tspin_lock_bh(&se_tpg->session_lock);\n\tspin_lock(&sess->conn_lock);\n\tif (atomic_read(&sess->session_fall_back_to_erl0) ||\n\t    atomic_read(&sess->session_logout) ||\n\t    atomic_read(&sess->session_close) ||\n\t    (sess->time2retain_timer_flags & ISCSI_TF_EXPIRED)) {\n\t\tspin_unlock(&sess->conn_lock);\n\t\tspin_unlock_bh(&se_tpg->session_lock);\n\t\treturn;\n\t}\n\tiscsit_inc_session_usage_count(sess);\n\tatomic_set(&sess->session_reinstatement, 1);\n\tatomic_set(&sess->session_fall_back_to_erl0, 1);\n\tatomic_set(&sess->session_close, 1);\n\tspin_unlock(&sess->conn_lock);\n\n\tiscsit_stop_time2retain_timer(sess);\n\tspin_unlock_bh(&se_tpg->session_lock);\n\n\tiscsit_stop_session(sess, 1, 1);\n\tiscsit_dec_session_usage_count(sess);\n}\n\nstatic u32 lio_tpg_get_inst_index(struct se_portal_group *se_tpg)\n{\n\treturn to_iscsi_tpg(se_tpg)->tpg_tiqn->tiqn_index;\n}\n\nstatic void lio_set_default_node_attributes(struct se_node_acl *se_acl)\n{\n\tstruct iscsi_node_acl *acl = to_iscsi_nacl(se_acl);\n\tstruct se_portal_group *se_tpg = se_acl->se_tpg;\n\tstruct iscsi_portal_group *tpg = to_iscsi_tpg(se_tpg);\n\n\tacl->node_attrib.nacl = acl;\n\tiscsit_set_default_node_attribues(acl, tpg);\n}\n\nstatic int lio_check_stop_free(struct se_cmd *se_cmd)\n{\n\treturn target_put_sess_cmd(se_cmd);\n}\n\nstatic void lio_release_cmd(struct se_cmd *se_cmd)\n{\n\tstruct iscsit_cmd *cmd = container_of(se_cmd, struct iscsit_cmd, se_cmd);\n\n\tpr_debug(\"Entering lio_release_cmd for se_cmd: %p\\n\", se_cmd);\n\tiscsit_release_cmd(cmd);\n}\n\nconst struct target_core_fabric_ops iscsi_ops = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.fabric_alias\t\t\t= \"iscsi\",\n\t.fabric_name\t\t\t= \"iSCSI\",\n\t.node_acl_size\t\t\t= sizeof(struct iscsi_node_acl),\n\t.tpg_get_wwn\t\t\t= lio_tpg_get_endpoint_wwn,\n\t.tpg_get_tag\t\t\t= lio_tpg_get_tag,\n\t.tpg_get_default_depth\t\t= lio_tpg_get_default_depth,\n\t.tpg_check_demo_mode\t\t= lio_tpg_check_demo_mode,\n\t.tpg_check_demo_mode_cache\t= lio_tpg_check_demo_mode_cache,\n\t.tpg_check_demo_mode_write_protect =\n\t\t\tlio_tpg_check_demo_mode_write_protect,\n\t.tpg_check_prod_mode_write_protect =\n\t\t\tlio_tpg_check_prod_mode_write_protect,\n\t.tpg_check_prot_fabric_only\t= &lio_tpg_check_prot_fabric_only,\n\t.tpg_get_inst_index\t\t= lio_tpg_get_inst_index,\n\t.check_stop_free\t\t= lio_check_stop_free,\n\t.release_cmd\t\t\t= lio_release_cmd,\n\t.close_session\t\t\t= lio_tpg_close_session,\n\t.sess_get_index\t\t\t= lio_sess_get_index,\n\t.sess_get_initiator_sid\t\t= lio_sess_get_initiator_sid,\n\t.write_pending\t\t\t= lio_write_pending,\n\t.set_default_node_attributes\t= lio_set_default_node_attributes,\n\t.get_cmd_state\t\t\t= iscsi_get_cmd_state,\n\t.queue_data_in\t\t\t= lio_queue_data_in,\n\t.queue_status\t\t\t= lio_queue_status,\n\t.queue_tm_rsp\t\t\t= lio_queue_tm_rsp,\n\t.aborted_task\t\t\t= lio_aborted_task,\n\t.fabric_make_wwn\t\t= lio_target_call_coreaddtiqn,\n\t.fabric_drop_wwn\t\t= lio_target_call_coredeltiqn,\n\t.add_wwn_groups\t\t\t= lio_target_add_wwn_groups,\n\t.fabric_make_tpg\t\t= lio_target_tiqn_addtpg,\n\t.fabric_enable_tpg\t\t= lio_target_tiqn_enabletpg,\n\t.fabric_drop_tpg\t\t= lio_target_tiqn_deltpg,\n\t.fabric_make_np\t\t\t= lio_target_call_addnptotpg,\n\t.fabric_drop_np\t\t\t= lio_target_call_delnpfromtpg,\n\t.fabric_init_nodeacl\t\t= lio_target_init_nodeacl,\n\n\t.tfc_discovery_attrs\t\t= lio_target_discovery_auth_attrs,\n\t.tfc_wwn_attrs\t\t\t= lio_target_wwn_attrs,\n\t.tfc_tpg_base_attrs\t\t= lio_target_tpg_attrs,\n\t.tfc_tpg_attrib_attrs\t\t= lio_target_tpg_attrib_attrs,\n\t.tfc_tpg_auth_attrs\t\t= lio_target_tpg_auth_attrs,\n\t.tfc_tpg_param_attrs\t\t= lio_target_tpg_param_attrs,\n\t.tfc_tpg_np_base_attrs\t\t= lio_target_portal_attrs,\n\t.tfc_tpg_nacl_base_attrs\t= lio_target_initiator_attrs,\n\t.tfc_tpg_nacl_attrib_attrs\t= lio_target_nacl_attrib_attrs,\n\t.tfc_tpg_nacl_auth_attrs\t= lio_target_nacl_auth_attrs,\n\t.tfc_tpg_nacl_param_attrs\t= lio_target_nacl_param_attrs,\n\n\t.write_pending_must_be_called\t= true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}