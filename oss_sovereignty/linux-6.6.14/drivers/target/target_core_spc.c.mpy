{
  "module_name": "target_core_spc.c",
  "hash_id": "b0a2330f567f01041347d73ae4ae7a534b0426109c82ae29790d75fcc6d7bc30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_spc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <asm/unaligned.h>\n\n#include <scsi/scsi_proto.h>\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_tcq.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n#include <target/target_core_fabric.h>\n\n#include \"target_core_internal.h\"\n#include \"target_core_alua.h\"\n#include \"target_core_pr.h\"\n#include \"target_core_ua.h\"\n#include \"target_core_xcopy.h\"\n\nstatic void spc_fill_alua_data(struct se_lun *lun, unsigned char *buf)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp;\n\n\t \n\tbuf[5]\t= 0x80;\n\n\t \n\trcu_read_lock();\n\ttg_pt_gp = rcu_dereference(lun->lun_tg_pt_gp);\n\tif (tg_pt_gp)\n\t\tbuf[5] |= tg_pt_gp->tg_pt_gp_alua_access_type;\n\trcu_read_unlock();\n}\n\nstatic u16\nspc_find_scsi_transport_vd(int proto_id)\n{\n\tswitch (proto_id) {\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn SCSI_VERSION_DESCRIPTOR_FCP4;\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn SCSI_VERSION_DESCRIPTOR_ISCSI;\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn SCSI_VERSION_DESCRIPTOR_SAS3;\n\tcase SCSI_PROTOCOL_SBP:\n\t\treturn SCSI_VERSION_DESCRIPTOR_SBP3;\n\tcase SCSI_PROTOCOL_SRP:\n\t\treturn SCSI_VERSION_DESCRIPTOR_SRP;\n\tdefault:\n\t\tpr_warn(\"Cannot find VERSION DESCRIPTOR value for unknown SCSI\"\n\t\t\t\" transport PROTOCOL IDENTIFIER %#x\\n\", proto_id);\n\t\treturn 0;\n\t}\n}\n\nsense_reason_t\nspc_emulate_inquiry_std(struct se_cmd *cmd, unsigned char *buf)\n{\n\tstruct se_lun *lun = cmd->se_lun;\n\tstruct se_portal_group *tpg = lun->lun_tpg;\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_session *sess = cmd->se_sess;\n\n\t \n\tif (dev->transport->get_device_type(dev) == TYPE_TAPE)\n\t\tbuf[1] = 0x80;\n\n\tbuf[2] = 0x06;  \n\n\t \n\tbuf[3] = 2;\n\n\t \n\tspc_fill_alua_data(lun, buf);\n\n\t \n\tif (dev->dev_attrib.emulate_3pc)\n\t\tbuf[5] |= 0x8;\n\t \n\tif (sess->sup_prot_ops & (TARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS)) {\n\t\tif (dev->dev_attrib.pi_prot_type || cmd->se_sess->sess_prot_type)\n\t\t\tbuf[5] |= 0x1;\n\t}\n\n\t \n\tif (dev->export_count > 1)\n\t\tbuf[6] |= 0x10;\n\n\tbuf[7] = 0x2;  \n\n\t \n\tmemset(&buf[8], 0x20,\n\t       INQUIRY_VENDOR_LEN + INQUIRY_MODEL_LEN + INQUIRY_REVISION_LEN);\n\tmemcpy(&buf[8], dev->t10_wwn.vendor,\n\t       strnlen(dev->t10_wwn.vendor, INQUIRY_VENDOR_LEN));\n\tmemcpy(&buf[16], dev->t10_wwn.model,\n\t       strnlen(dev->t10_wwn.model, INQUIRY_MODEL_LEN));\n\tmemcpy(&buf[32], dev->t10_wwn.revision,\n\t       strnlen(dev->t10_wwn.revision, INQUIRY_REVISION_LEN));\n\n\t \n\tput_unaligned_be16(SCSI_VERSION_DESCRIPTOR_SAM5, &buf[58]);\n\tput_unaligned_be16(spc_find_scsi_transport_vd(tpg->proto_id), &buf[60]);\n\tput_unaligned_be16(SCSI_VERSION_DESCRIPTOR_SPC4, &buf[62]);\n\tif (cmd->se_dev->transport->get_device_type(dev) == TYPE_DISK)\n\t\tput_unaligned_be16(SCSI_VERSION_DESCRIPTOR_SBC3, &buf[64]);\n\n\tbuf[4] = 91;  \n\n\treturn 0;\n}\nEXPORT_SYMBOL(spc_emulate_inquiry_std);\n\n \nstatic sense_reason_t\nspc_emulate_evpd_80(struct se_cmd *cmd, unsigned char *buf)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tu16 len;\n\n\tif (dev->dev_flags & DF_EMULATED_VPD_UNIT_SERIAL) {\n\t\tlen = sprintf(&buf[4], \"%s\", dev->t10_wwn.unit_serial);\n\t\tlen++;  \n\t\tbuf[3] = len;\n\t}\n\treturn 0;\n}\n\n \nvoid spc_gen_naa_6h_vendor_specific(struct se_device *dev,\n\t\t\t\t    unsigned char *buf)\n{\n\tunsigned char *p = &dev->t10_wwn.unit_serial[0];\n\tu32 company_id = dev->t10_wwn.company_id;\n\tint cnt, off = 0;\n\tbool next = true;\n\n\t \n\tbuf[off] = 0x6 << 4;\n\n\t \n\tbuf[off++] |= (company_id >> 20) & 0xf;\n\tbuf[off++] = (company_id >> 12) & 0xff;\n\tbuf[off++] = (company_id >> 4) & 0xff;\n\tbuf[off] = (company_id & 0xf) << 4;\n\n\t \n\tfor (cnt = off + 13; *p && off < cnt; p++) {\n\t\tint val = hex_to_bin(*p);\n\n\t\tif (val < 0)\n\t\t\tcontinue;\n\n\t\tif (next) {\n\t\t\tnext = false;\n\t\t\tbuf[off++] |= val;\n\t\t} else {\n\t\t\tnext = true;\n\t\t\tbuf[off] = val << 4;\n\t\t}\n\t}\n}\n\n \nsense_reason_t\nspc_emulate_evpd_83(struct se_cmd *cmd, unsigned char *buf)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_lun *lun = cmd->se_lun;\n\tstruct se_portal_group *tpg = NULL;\n\tstruct t10_alua_lu_gp_member *lu_gp_mem;\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp;\n\tunsigned char *prod = &dev->t10_wwn.model[0];\n\tu32 off = 0;\n\tu16 len = 0, id_len;\n\n\toff = 4;\n\n\t \n\tif (!(dev->dev_flags & DF_EMULATED_VPD_UNIT_SERIAL))\n\t\tgoto check_t10_vend_desc;\n\n\t \n\tbuf[off++] = 0x1;\n\n\t \n\tbuf[off] = 0x00;\n\n\t \n\tbuf[off++] |= 0x3;\n\toff++;\n\n\t \n\tbuf[off++] = 0x10;\n\n\t \n\tspc_gen_naa_6h_vendor_specific(dev, &buf[off]);\n\n\tlen = 20;\n\toff = (len + 4);\n\ncheck_t10_vend_desc:\n\t \n\tid_len = 8;  \n\n\tif (dev->dev_flags & DF_EMULATED_VPD_UNIT_SERIAL)\n\t\tid_len += sprintf(&buf[off+12], \"%s:%s\", prod,\n\t\t\t\t&dev->t10_wwn.unit_serial[0]);\n\tbuf[off] = 0x2;  \n\tbuf[off+1] = 0x1;  \n\tbuf[off+2] = 0x0;\n\t \n\tmemset(&buf[off+4], 0x20, INQUIRY_VENDOR_LEN);\n\tmemcpy(&buf[off+4], dev->t10_wwn.vendor,\n\t       strnlen(dev->t10_wwn.vendor, INQUIRY_VENDOR_LEN));\n\t \n\tid_len++;\n\t \n\tbuf[off+3] = id_len;\n\t \n\tlen += (id_len + 4);\n\toff += (id_len + 4);\n\n\tif (1) {\n\t\tstruct t10_alua_lu_gp *lu_gp;\n\t\tu32 padding, scsi_name_len, scsi_target_len;\n\t\tu16 lu_gp_id = 0;\n\t\tu16 tg_pt_gp_id = 0;\n\t\tu16 tpgt;\n\n\t\ttpg = lun->lun_tpg;\n\t\t \n\t\tbuf[off] = tpg->proto_id << 4;\n\t\tbuf[off++] |= 0x1;  \n\t\tbuf[off] = 0x80;  \n\t\t \n\t\tbuf[off] |= 0x10;\n\t\t \n\t\tbuf[off++] |= 0x4;\n\t\toff++;  \n\t\tbuf[off++] = 4;  \n\t\t \n\t\toff += 2;\n\t\tput_unaligned_be16(lun->lun_tpg->tpg_rtpi, &buf[off]);\n\t\toff += 2;\n\t\tlen += 8;  \n\t\t \n\t\trcu_read_lock();\n\t\ttg_pt_gp = rcu_dereference(lun->lun_tg_pt_gp);\n\t\tif (!tg_pt_gp) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto check_lu_gp;\n\t\t}\n\t\ttg_pt_gp_id = tg_pt_gp->tg_pt_gp_id;\n\t\trcu_read_unlock();\n\n\t\tbuf[off] = tpg->proto_id << 4;\n\t\tbuf[off++] |= 0x1;  \n\t\tbuf[off] = 0x80;  \n\t\t \n\t\tbuf[off] |= 0x10;\n\t\t \n\t\tbuf[off++] |= 0x5;\n\t\toff++;  \n\t\tbuf[off++] = 4;  \n\t\toff += 2;  \n\t\tput_unaligned_be16(tg_pt_gp_id, &buf[off]);\n\t\toff += 2;\n\t\tlen += 8;  \n\t\t \ncheck_lu_gp:\n\t\tlu_gp_mem = dev->dev_alua_lu_gp_mem;\n\t\tif (!lu_gp_mem)\n\t\t\tgoto check_scsi_name;\n\n\t\tspin_lock(&lu_gp_mem->lu_gp_mem_lock);\n\t\tlu_gp = lu_gp_mem->lu_gp;\n\t\tif (!lu_gp) {\n\t\t\tspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\n\t\t\tgoto check_scsi_name;\n\t\t}\n\t\tlu_gp_id = lu_gp->lu_gp_id;\n\t\tspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\n\n\t\tbuf[off++] |= 0x1;  \n\t\t \n\t\tbuf[off++] |= 0x6;\n\t\toff++;  \n\t\tbuf[off++] = 4;  \n\t\toff += 2;  \n\t\tput_unaligned_be16(lu_gp_id, &buf[off]);\n\t\toff += 2;\n\t\tlen += 8;  \n\t\t \ncheck_scsi_name:\n\t\tbuf[off] = tpg->proto_id << 4;\n\t\tbuf[off++] |= 0x3;  \n\t\tbuf[off] = 0x80;  \n\t\t \n\t\tbuf[off] |= 0x10;\n\t\t \n\t\tbuf[off++] |= 0x8;\n\t\toff += 2;  \n\t\t \n\t\ttpgt = tpg->se_tpg_tfo->tpg_get_tag(tpg);\n\t\tscsi_name_len = sprintf(&buf[off], \"%s,t,0x%04x\",\n\t\t\t\t\ttpg->se_tpg_tfo->tpg_get_wwn(tpg), tpgt);\n\t\tscsi_name_len += 1  ;\n\t\t \n\t\tpadding = ((-scsi_name_len) & 3);\n\t\tif (padding)\n\t\t\tscsi_name_len += padding;\n\t\tif (scsi_name_len > 256)\n\t\t\tscsi_name_len = 256;\n\n\t\tbuf[off-1] = scsi_name_len;\n\t\toff += scsi_name_len;\n\t\t \n\t\tlen += (scsi_name_len + 4);\n\n\t\t \n\t\tbuf[off] = tpg->proto_id << 4;\n\t\tbuf[off++] |= 0x3;  \n\t\tbuf[off] = 0x80;  \n\t\t \n\t\tbuf[off] |= 0x20;\n\t\t \n\t\tbuf[off++] |= 0x8;\n\t\toff += 2;  \n\t\t \n\t\tscsi_target_len = sprintf(&buf[off], \"%s\",\n\t\t\t\t\t  tpg->se_tpg_tfo->tpg_get_wwn(tpg));\n\t\tscsi_target_len += 1  ;\n\t\t \n\t\tpadding = ((-scsi_target_len) & 3);\n\t\tif (padding)\n\t\t\tscsi_target_len += padding;\n\t\tif (scsi_target_len > 256)\n\t\t\tscsi_target_len = 256;\n\n\t\tbuf[off-1] = scsi_target_len;\n\t\toff += scsi_target_len;\n\n\t\t \n\t\tlen += (scsi_target_len + 4);\n\t}\n\tput_unaligned_be16(len, &buf[2]);  \n\treturn 0;\n}\nEXPORT_SYMBOL(spc_emulate_evpd_83);\n\n \nstatic sense_reason_t\nspc_emulate_evpd_86(struct se_cmd *cmd, unsigned char *buf)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_session *sess = cmd->se_sess;\n\n\tbuf[3] = 0x3c;\n\t \n\tif (sess->sup_prot_ops & (TARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS)) {\n\t\tif (dev->dev_attrib.pi_prot_type == TARGET_DIF_TYPE1_PROT ||\n\t\t    cmd->se_sess->sess_prot_type == TARGET_DIF_TYPE1_PROT)\n\t\t\tbuf[4] = 0x5;\n\t\telse if (dev->dev_attrib.pi_prot_type == TARGET_DIF_TYPE3_PROT ||\n\t\t\t cmd->se_sess->sess_prot_type == TARGET_DIF_TYPE3_PROT)\n\t\t\tbuf[4] = 0x4;\n\t}\n\n\t \n\tif ((dev->transport->get_device_type(dev) == TYPE_DISK) &&\n\t    (sess->sup_prot_ops & (TARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS)) &&\n\t    (dev->dev_attrib.pi_prot_type || cmd->se_sess->sess_prot_type)) {\n\t\tbuf[4] |= (0x3 << 3);\n\t}\n\n\t \n\tbuf[5] = 0x07;\n\n\t \n\tif (target_check_wce(dev))\n\t\tbuf[6] = 0x01;\n\t \n\tspin_lock(&cmd->se_dev->t10_alua.lba_map_lock);\n\tif (!list_empty(&dev->t10_alua.lba_map_list))\n\t\tbuf[8] = 0x10;\n\tspin_unlock(&cmd->se_dev->t10_alua.lba_map_lock);\n\treturn 0;\n}\n\n \nstatic sense_reason_t\nspc_emulate_evpd_b0(struct se_cmd *cmd, unsigned char *buf)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tu32 mtl = 0;\n\tint have_tp = 0, opt, min;\n\tu32 io_max_blocks;\n\n\t \n\tif (dev->dev_attrib.emulate_tpu || dev->dev_attrib.emulate_tpws)\n\t\thave_tp = 1;\n\n\tbuf[0] = dev->transport->get_device_type(dev);\n\tbuf[3] = have_tp ? 0x3c : 0x10;\n\n\t \n\tbuf[4] = 0x01;\n\t \n\tif (dev->dev_attrib.emulate_caw)\n\t\tbuf[5] = 0x01;\n\n\t \n\tif (dev->transport->get_io_min && (min = dev->transport->get_io_min(dev)))\n\t\tput_unaligned_be16(min / dev->dev_attrib.block_size, &buf[6]);\n\telse\n\t\tput_unaligned_be16(1, &buf[6]);\n\n\t \n\tif (cmd->se_tfo->max_data_sg_nents) {\n\t\tmtl = (cmd->se_tfo->max_data_sg_nents * PAGE_SIZE) /\n\t\t       dev->dev_attrib.block_size;\n\t}\n\tio_max_blocks = mult_frac(dev->dev_attrib.hw_max_sectors,\n\t\t\tdev->dev_attrib.hw_block_size,\n\t\t\tdev->dev_attrib.block_size);\n\tput_unaligned_be32(min_not_zero(mtl, io_max_blocks), &buf[8]);\n\n\t \n\tif (dev->transport->get_io_opt && (opt = dev->transport->get_io_opt(dev)))\n\t\tput_unaligned_be32(opt / dev->dev_attrib.block_size, &buf[12]);\n\telse\n\t\tput_unaligned_be32(dev->dev_attrib.optimal_sectors, &buf[12]);\n\n\t \n\tif (!have_tp)\n\t\tgoto max_write_same;\n\n\t \n\tput_unaligned_be32(dev->dev_attrib.max_unmap_lba_count, &buf[20]);\n\n\t \n\tput_unaligned_be32(dev->dev_attrib.max_unmap_block_desc_count,\n\t\t\t   &buf[24]);\n\n\t \n\tput_unaligned_be32(dev->dev_attrib.unmap_granularity, &buf[28]);\n\n\t \n\tput_unaligned_be32(dev->dev_attrib.unmap_granularity_alignment,\n\t\t\t   &buf[32]);\n\tif (dev->dev_attrib.unmap_granularity_alignment != 0)\n\t\tbuf[32] |= 0x80;  \n\n\t \nmax_write_same:\n\tput_unaligned_be64(dev->dev_attrib.max_write_same_len, &buf[36]);\n\n\treturn 0;\n}\n\n \nstatic sense_reason_t\nspc_emulate_evpd_b1(struct se_cmd *cmd, unsigned char *buf)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\tbuf[0] = dev->transport->get_device_type(dev);\n\tbuf[3] = 0x3c;\n\tbuf[5] = dev->dev_attrib.is_nonrot ? 1 : 0;\n\n\treturn 0;\n}\n\n \nstatic sense_reason_t\nspc_emulate_evpd_b2(struct se_cmd *cmd, unsigned char *buf)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\t \n\tbuf[0] = dev->transport->get_device_type(dev);\n\n\t \n\tput_unaligned_be16(0x0004, &buf[2]);\n\n\t \n\tbuf[4] = 0x00;\n\n\t \n\tif (dev->dev_attrib.emulate_tpu != 0)\n\t\tbuf[5] = 0x80;\n\n\t \n\tif (dev->dev_attrib.emulate_tpws != 0)\n\t\tbuf[5] |= 0x40 | 0x20;\n\n\t \n\tif (((dev->dev_attrib.emulate_tpu != 0) ||\n\t     (dev->dev_attrib.emulate_tpws != 0)) &&\n\t     (dev->dev_attrib.unmap_zeroes_data != 0))\n\t\tbuf[5] |= 0x04;\n\n\treturn 0;\n}\n\n \nstatic sense_reason_t\nspc_emulate_evpd_b3(struct se_cmd *cmd, unsigned char *buf)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\tbuf[0] = dev->transport->get_device_type(dev);\n\tbuf[3] = 0x0c;\n\tput_unaligned_be32(dev->t10_alua.lba_map_segment_size, &buf[8]);\n\tput_unaligned_be32(dev->t10_alua.lba_map_segment_multiplier, &buf[12]);\n\n\treturn 0;\n}\n\nstatic sense_reason_t\nspc_emulate_evpd_00(struct se_cmd *cmd, unsigned char *buf);\n\nstatic struct {\n\tuint8_t\t\tpage;\n\tsense_reason_t\t(*emulate)(struct se_cmd *, unsigned char *);\n} evpd_handlers[] = {\n\t{ .page = 0x00, .emulate = spc_emulate_evpd_00 },\n\t{ .page = 0x80, .emulate = spc_emulate_evpd_80 },\n\t{ .page = 0x83, .emulate = spc_emulate_evpd_83 },\n\t{ .page = 0x86, .emulate = spc_emulate_evpd_86 },\n\t{ .page = 0xb0, .emulate = spc_emulate_evpd_b0 },\n\t{ .page = 0xb1, .emulate = spc_emulate_evpd_b1 },\n\t{ .page = 0xb2, .emulate = spc_emulate_evpd_b2 },\n\t{ .page = 0xb3, .emulate = spc_emulate_evpd_b3 },\n};\n\n \nstatic sense_reason_t\nspc_emulate_evpd_00(struct se_cmd *cmd, unsigned char *buf)\n{\n\tint p;\n\n\t \n\tif (cmd->se_dev->dev_flags & DF_EMULATED_VPD_UNIT_SERIAL) {\n\t\tbuf[3] = ARRAY_SIZE(evpd_handlers);\n\t\tfor (p = 0; p < ARRAY_SIZE(evpd_handlers); ++p)\n\t\t\tbuf[p + 4] = evpd_handlers[p].page;\n\t}\n\n\treturn 0;\n}\n\nstatic sense_reason_t\nspc_emulate_inquiry(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tunsigned char *rbuf;\n\tunsigned char *cdb = cmd->t_task_cdb;\n\tunsigned char *buf;\n\tsense_reason_t ret;\n\tint p;\n\tint len = 0;\n\n\tbuf = kzalloc(SE_INQUIRY_BUF, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"Unable to allocate response buffer for INQUIRY\\n\");\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\n\tbuf[0] = dev->transport->get_device_type(dev);\n\n\tif (!(cdb[1] & 0x1)) {\n\t\tif (cdb[2]) {\n\t\t\tpr_err(\"INQUIRY with EVPD==0 but PAGE CODE=%02x\\n\",\n\t\t\t       cdb[2]);\n\t\t\tret = TCM_INVALID_CDB_FIELD;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = spc_emulate_inquiry_std(cmd, buf);\n\t\tlen = buf[4] + 5;\n\t\tgoto out;\n\t}\n\n\tfor (p = 0; p < ARRAY_SIZE(evpd_handlers); ++p) {\n\t\tif (cdb[2] == evpd_handlers[p].page) {\n\t\t\tbuf[1] = cdb[2];\n\t\t\tret = evpd_handlers[p].emulate(cmd, buf);\n\t\t\tlen = get_unaligned_be16(&buf[2]) + 4;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpr_debug(\"Unknown VPD Code: 0x%02x\\n\", cdb[2]);\n\tret = TCM_INVALID_CDB_FIELD;\n\nout:\n\trbuf = transport_kmap_data_sg(cmd);\n\tif (rbuf) {\n\t\tmemcpy(rbuf, buf, min_t(u32, SE_INQUIRY_BUF, cmd->data_length));\n\t\ttransport_kunmap_data_sg(cmd);\n\t}\n\tkfree(buf);\n\n\tif (!ret)\n\t\ttarget_complete_cmd_with_length(cmd, SAM_STAT_GOOD, len);\n\treturn ret;\n}\n\nstatic int spc_modesense_rwrecovery(struct se_cmd *cmd, u8 pc, u8 *p)\n{\n\tp[0] = 0x01;\n\tp[1] = 0x0a;\n\n\t \n\tif (pc == 1)\n\t\tgoto out;\n\nout:\n\treturn 12;\n}\n\nstatic int spc_modesense_control(struct se_cmd *cmd, u8 pc, u8 *p)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_session *sess = cmd->se_sess;\n\n\tp[0] = 0x0a;\n\tp[1] = 0x0a;\n\n\t \n\tif (pc == 1)\n\t\tgoto out;\n\n\t \n\tp[2] = (1 << 1);\n\tif (target_sense_desc_format(dev))\n\t\t \n\t\tp[2] |= (1 << 2);\n\n\t \n\tp[3] = (dev->dev_attrib.emulate_rest_reord == 1) ? 0x00 : 0x10;\n\t \n\tswitch (dev->dev_attrib.emulate_ua_intlck_ctrl) {\n\tcase TARGET_UA_INTLCK_CTRL_ESTABLISH_UA:\n\t\tp[4] = 0x30;\n\t\tbreak;\n\tcase TARGET_UA_INTLCK_CTRL_NO_CLEAR:\n\t\tp[4] = 0x20;\n\t\tbreak;\n\tdefault:\t \n\t\tp[4] = 0x00;\n\t\tbreak;\n\t}\n\t \n\tp[5] = (dev->dev_attrib.emulate_tas) ? 0x40 : 0x00;\n\t \n\tif (sess->sup_prot_ops & (TARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS)) {\n\t\tif (dev->dev_attrib.pi_prot_type || sess->sess_prot_type)\n\t\t\tp[5] |= 0x80;\n\t}\n\n\tp[8] = 0xff;\n\tp[9] = 0xff;\n\tp[11] = 30;\n\nout:\n\treturn 12;\n}\n\nstatic int spc_modesense_caching(struct se_cmd *cmd, u8 pc, u8 *p)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\tp[0] = 0x08;\n\tp[1] = 0x12;\n\n\t \n\tif (pc == 1)\n\t\tgoto out;\n\n\tif (target_check_wce(dev))\n\t\tp[2] = 0x04;  \n\tp[12] = 0x20;  \n\nout:\n\treturn 20;\n}\n\nstatic int spc_modesense_informational_exceptions(struct se_cmd *cmd, u8 pc, unsigned char *p)\n{\n\tp[0] = 0x1c;\n\tp[1] = 0x0a;\n\n\t \n\tif (pc == 1)\n\t\tgoto out;\n\nout:\n\treturn 12;\n}\n\nstatic struct {\n\tuint8_t\t\tpage;\n\tuint8_t\t\tsubpage;\n\tint\t\t(*emulate)(struct se_cmd *, u8, unsigned char *);\n} modesense_handlers[] = {\n\t{ .page = 0x01, .subpage = 0x00, .emulate = spc_modesense_rwrecovery },\n\t{ .page = 0x08, .subpage = 0x00, .emulate = spc_modesense_caching },\n\t{ .page = 0x0a, .subpage = 0x00, .emulate = spc_modesense_control },\n\t{ .page = 0x1c, .subpage = 0x00, .emulate = spc_modesense_informational_exceptions },\n};\n\nstatic void spc_modesense_write_protect(unsigned char *buf, int type)\n{\n\t \n\tswitch (type) {\n\tcase TYPE_DISK:\n\tcase TYPE_TAPE:\n\tdefault:\n\t\tbuf[0] |= 0x80;  \n\t\tbreak;\n\t}\n}\n\nstatic void spc_modesense_dpofua(unsigned char *buf, int type)\n{\n\tswitch (type) {\n\tcase TYPE_DISK:\n\t\tbuf[0] |= 0x10;  \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int spc_modesense_blockdesc(unsigned char *buf, u64 blocks, u32 block_size)\n{\n\t*buf++ = 8;\n\tput_unaligned_be32(min(blocks, 0xffffffffull), buf);\n\tbuf += 4;\n\tput_unaligned_be32(block_size, buf);\n\treturn 9;\n}\n\nstatic int spc_modesense_long_blockdesc(unsigned char *buf, u64 blocks, u32 block_size)\n{\n\tif (blocks <= 0xffffffff)\n\t\treturn spc_modesense_blockdesc(buf + 3, blocks, block_size) + 3;\n\n\t*buf++ = 1;\t\t \n\tbuf += 2;\n\t*buf++ = 16;\n\tput_unaligned_be64(blocks, buf);\n\tbuf += 12;\n\tput_unaligned_be32(block_size, buf);\n\n\treturn 17;\n}\n\nstatic sense_reason_t spc_emulate_modesense(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tchar *cdb = cmd->t_task_cdb;\n\tunsigned char buf[SE_MODE_PAGE_BUF], *rbuf;\n\tint type = dev->transport->get_device_type(dev);\n\tint ten = (cmd->t_task_cdb[0] == MODE_SENSE_10);\n\tbool dbd = !!(cdb[1] & 0x08);\n\tbool llba = ten ? !!(cdb[1] & 0x10) : false;\n\tu8 pc = cdb[2] >> 6;\n\tu8 page = cdb[2] & 0x3f;\n\tu8 subpage = cdb[3];\n\tint length = 0;\n\tint ret;\n\tint i;\n\n\tmemset(buf, 0, SE_MODE_PAGE_BUF);\n\n\t \n\tlength = ten ? 3 : 2;\n\n\t \n\tif (cmd->se_lun->lun_access_ro || target_lun_is_rdonly(cmd))\n\t\tspc_modesense_write_protect(&buf[length], type);\n\n\t \n\tif (target_check_fua(dev))\n\t\tspc_modesense_dpofua(&buf[length], type);\n\n\t++length;\n\n\t \n\n\t \n\tif (!dbd && type == TYPE_DISK) {\n\t\tu64 blocks = dev->transport->get_blocks(dev);\n\t\tu32 block_size = dev->dev_attrib.block_size;\n\n\t\tif (ten) {\n\t\t\tif (llba) {\n\t\t\t\tlength += spc_modesense_long_blockdesc(&buf[length],\n\t\t\t\t\t\t\t\t       blocks, block_size);\n\t\t\t} else {\n\t\t\t\tlength += 3;\n\t\t\t\tlength += spc_modesense_blockdesc(&buf[length],\n\t\t\t\t\t\t\t\t  blocks, block_size);\n\t\t\t}\n\t\t} else {\n\t\t\tlength += spc_modesense_blockdesc(&buf[length], blocks,\n\t\t\t\t\t\t\t  block_size);\n\t\t}\n\t} else {\n\t\tif (ten)\n\t\t\tlength += 4;\n\t\telse\n\t\t\tlength += 1;\n\t}\n\n\tif (page == 0x3f) {\n\t\tif (subpage != 0x00 && subpage != 0xff) {\n\t\t\tpr_warn(\"MODE_SENSE: Invalid subpage code: 0x%02x\\n\", subpage);\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(modesense_handlers); ++i) {\n\t\t\t \n\t\t\tif ((modesense_handlers[i].subpage & ~subpage) == 0) {\n\t\t\t\tret = modesense_handlers[i].emulate(cmd, pc, &buf[length]);\n\t\t\t\tif (!ten && length + ret >= 255)\n\t\t\t\t\tbreak;\n\t\t\t\tlength += ret;\n\t\t\t}\n\t\t}\n\n\t\tgoto set_length;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(modesense_handlers); ++i)\n\t\tif (modesense_handlers[i].page == page &&\n\t\t    modesense_handlers[i].subpage == subpage) {\n\t\t\tlength += modesense_handlers[i].emulate(cmd, pc, &buf[length]);\n\t\t\tgoto set_length;\n\t\t}\n\n\t \n\tif (page != 0x03)\n\t\tpr_err(\"MODE SENSE: unimplemented page/subpage: 0x%02x/0x%02x\\n\",\n\t\t       page, subpage);\n\n\treturn TCM_UNKNOWN_MODE_PAGE;\n\nset_length:\n\tif (ten)\n\t\tput_unaligned_be16(length - 2, buf);\n\telse\n\t\tbuf[0] = length - 1;\n\n\trbuf = transport_kmap_data_sg(cmd);\n\tif (rbuf) {\n\t\tmemcpy(rbuf, buf, min_t(u32, SE_MODE_PAGE_BUF, cmd->data_length));\n\t\ttransport_kunmap_data_sg(cmd);\n\t}\n\n\ttarget_complete_cmd_with_length(cmd, SAM_STAT_GOOD, length);\n\treturn 0;\n}\n\nstatic sense_reason_t spc_emulate_modeselect(struct se_cmd *cmd)\n{\n\tchar *cdb = cmd->t_task_cdb;\n\tbool ten = cdb[0] == MODE_SELECT_10;\n\tint off = ten ? 8 : 4;\n\tbool pf = !!(cdb[1] & 0x10);\n\tu8 page, subpage;\n\tunsigned char *buf;\n\tunsigned char tbuf[SE_MODE_PAGE_BUF];\n\tint length;\n\tsense_reason_t ret = 0;\n\tint i;\n\n\tif (!cmd->data_length) {\n\t\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\t\treturn 0;\n\t}\n\n\tif (cmd->data_length < off + 2)\n\t\treturn TCM_PARAMETER_LIST_LENGTH_ERROR;\n\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tif (!pf) {\n\t\tret = TCM_INVALID_CDB_FIELD;\n\t\tgoto out;\n\t}\n\n\tpage = buf[off] & 0x3f;\n\tsubpage = buf[off] & 0x40 ? buf[off + 1] : 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(modesense_handlers); ++i)\n\t\tif (modesense_handlers[i].page == page &&\n\t\t    modesense_handlers[i].subpage == subpage) {\n\t\t\tmemset(tbuf, 0, SE_MODE_PAGE_BUF);\n\t\t\tlength = modesense_handlers[i].emulate(cmd, 0, tbuf);\n\t\t\tgoto check_contents;\n\t\t}\n\n\tret = TCM_UNKNOWN_MODE_PAGE;\n\tgoto out;\n\ncheck_contents:\n\tif (cmd->data_length < off + length) {\n\t\tret = TCM_PARAMETER_LIST_LENGTH_ERROR;\n\t\tgoto out;\n\t}\n\n\tif (memcmp(buf + off, tbuf, length))\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\nout:\n\ttransport_kunmap_data_sg(cmd);\n\n\tif (!ret)\n\t\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn ret;\n}\n\nstatic sense_reason_t spc_emulate_request_sense(struct se_cmd *cmd)\n{\n\tunsigned char *cdb = cmd->t_task_cdb;\n\tunsigned char *rbuf;\n\tu8 ua_asc = 0, ua_ascq = 0;\n\tunsigned char buf[SE_SENSE_BUF];\n\tbool desc_format = target_sense_desc_format(cmd->se_dev);\n\n\tmemset(buf, 0, SE_SENSE_BUF);\n\n\tif (cdb[1] & 0x01) {\n\t\tpr_err(\"REQUEST_SENSE description emulation not\"\n\t\t\t\" supported\\n\");\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\trbuf = transport_kmap_data_sg(cmd);\n\tif (!rbuf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tif (!core_scsi3_ua_clear_for_request_sense(cmd, &ua_asc, &ua_ascq))\n\t\tscsi_build_sense_buffer(desc_format, buf, UNIT_ATTENTION,\n\t\t\t\t\tua_asc, ua_ascq);\n\telse\n\t\tscsi_build_sense_buffer(desc_format, buf, NO_SENSE, 0x0, 0x0);\n\n\tmemcpy(rbuf, buf, min_t(u32, sizeof(buf), cmd->data_length));\n\ttransport_kunmap_data_sg(cmd);\n\n\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn 0;\n}\n\nsense_reason_t spc_emulate_report_luns(struct se_cmd *cmd)\n{\n\tstruct se_dev_entry *deve;\n\tstruct se_session *sess = cmd->se_sess;\n\tstruct se_node_acl *nacl;\n\tstruct scsi_lun slun;\n\tunsigned char *buf;\n\tu32 lun_count = 0, offset = 8;\n\t__be32 len;\n\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (cmd->data_length && !buf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\t \n\tif (!sess)\n\t\tgoto done;\n\n\tnacl = sess->se_node_acl;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(deve, &nacl->lun_entry_hlist, link) {\n\t\t \n\t\tlun_count++;\n\t\tif (offset >= cmd->data_length)\n\t\t\tcontinue;\n\n\t\tint_to_scsilun(deve->mapped_lun, &slun);\n\t\tmemcpy(buf + offset, &slun,\n\t\t       min(8u, cmd->data_length - offset));\n\t\toffset += 8;\n\t}\n\trcu_read_unlock();\n\n\t \ndone:\n\t \n\tif (lun_count == 0) {\n\t\tint_to_scsilun(0, &slun);\n\t\tif (cmd->data_length > 8)\n\t\t\tmemcpy(buf + offset, &slun,\n\t\t\t       min(8u, cmd->data_length - offset));\n\t\tlun_count = 1;\n\t}\n\n\tif (buf) {\n\t\tlen = cpu_to_be32(lun_count * 8);\n\t\tmemcpy(buf, &len, min_t(int, sizeof len, cmd->data_length));\n\t\ttransport_kunmap_data_sg(cmd);\n\t}\n\n\ttarget_complete_cmd_with_length(cmd, SAM_STAT_GOOD, 8 + lun_count * 8);\n\treturn 0;\n}\nEXPORT_SYMBOL(spc_emulate_report_luns);\n\nstatic sense_reason_t\nspc_emulate_testunitready(struct se_cmd *cmd)\n{\n\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn 0;\n}\n\nstatic void set_dpofua_usage_bits(u8 *usage_bits, struct se_device *dev)\n{\n\tif (!target_check_fua(dev))\n\t\tusage_bits[1] &= ~0x18;\n\telse\n\t\tusage_bits[1] |= 0x18;\n}\n\nstatic void set_dpofua_usage_bits32(u8 *usage_bits, struct se_device *dev)\n{\n\tif (!target_check_fua(dev))\n\t\tusage_bits[10] &= ~0x18;\n\telse\n\t\tusage_bits[10] |= 0x18;\n}\n\nstatic struct target_opcode_descriptor tcm_opcode_read6 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = READ_6,\n\t.cdb_size = 6,\n\t.usage_bits = {READ_6, 0x1f, 0xff, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_read10 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = READ_10,\n\t.cdb_size = 10,\n\t.usage_bits = {READ_10, 0xf8, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.update_usage_bits = set_dpofua_usage_bits,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_read12 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = READ_12,\n\t.cdb_size = 12,\n\t.usage_bits = {READ_12, 0xf8, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, SCSI_CONTROL_MASK},\n\t.update_usage_bits = set_dpofua_usage_bits,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_read16 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = READ_16,\n\t.cdb_size = 16,\n\t.usage_bits = {READ_16, 0xf8, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, SCSI_CONTROL_MASK},\n\t.update_usage_bits = set_dpofua_usage_bits,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_write6 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = WRITE_6,\n\t.cdb_size = 6,\n\t.usage_bits = {WRITE_6, 0x1f, 0xff, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_write10 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = WRITE_10,\n\t.cdb_size = 10,\n\t.usage_bits = {WRITE_10, 0xf8, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.update_usage_bits = set_dpofua_usage_bits,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_write_verify10 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = WRITE_VERIFY,\n\t.cdb_size = 10,\n\t.usage_bits = {WRITE_VERIFY, 0xf0, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.update_usage_bits = set_dpofua_usage_bits,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_write12 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = WRITE_12,\n\t.cdb_size = 12,\n\t.usage_bits = {WRITE_12, 0xf8, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, SCSI_CONTROL_MASK},\n\t.update_usage_bits = set_dpofua_usage_bits,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_write16 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = WRITE_16,\n\t.cdb_size = 16,\n\t.usage_bits = {WRITE_16, 0xf8, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, SCSI_CONTROL_MASK},\n\t.update_usage_bits = set_dpofua_usage_bits,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_write_verify16 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = WRITE_VERIFY_16,\n\t.cdb_size = 16,\n\t.usage_bits = {WRITE_VERIFY_16, 0xf0, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, SCSI_CONTROL_MASK},\n\t.update_usage_bits = set_dpofua_usage_bits,\n};\n\nstatic bool tcm_is_ws_enabled(struct target_opcode_descriptor *descr,\n\t\t\t      struct se_cmd *cmd)\n{\n\tstruct exec_cmd_ops *ops = cmd->protocol_data;\n\tstruct se_device *dev = cmd->se_dev;\n\n\treturn (dev->dev_attrib.emulate_tpws && !!ops->execute_unmap) ||\n\t       !!ops->execute_write_same;\n}\n\nstatic struct target_opcode_descriptor tcm_opcode_write_same32 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = VARIABLE_LENGTH_CMD,\n\t.service_action = WRITE_SAME_32,\n\t.cdb_size = 32,\n\t.usage_bits = {VARIABLE_LENGTH_CMD, SCSI_CONTROL_MASK, 0x00, 0x00,\n\t\t       0x00, 0x00, SCSI_GROUP_NUMBER_MASK, 0x18,\n\t\t       0x00, WRITE_SAME_32, 0xe8, 0x00,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0x00, 0x00, 0x00, 0x00,\n\t\t       0x00, 0x00, 0x00, 0x00,\n\t\t       0xff, 0xff, 0xff, 0xff},\n\t.enabled = tcm_is_ws_enabled,\n\t.update_usage_bits = set_dpofua_usage_bits32,\n};\n\nstatic bool tcm_is_caw_enabled(struct target_opcode_descriptor *descr,\n\t\t\t       struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\treturn dev->dev_attrib.emulate_caw;\n}\n\nstatic struct target_opcode_descriptor tcm_opcode_compare_write = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = COMPARE_AND_WRITE,\n\t.cdb_size = 16,\n\t.usage_bits = {COMPARE_AND_WRITE, 0x18, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, 0x00, 0x00,\n\t\t       0x00, 0xff, SCSI_GROUP_NUMBER_MASK, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_caw_enabled,\n\t.update_usage_bits = set_dpofua_usage_bits,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_read_capacity = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = READ_CAPACITY,\n\t.cdb_size = 10,\n\t.usage_bits = {READ_CAPACITY, 0x00, 0xff, 0xff,\n\t\t       0xff, 0xff, 0x00, 0x00,\n\t\t       0x01, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_read_capacity16 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = SERVICE_ACTION_IN_16,\n\t.service_action = SAI_READ_CAPACITY_16,\n\t.cdb_size = 16,\n\t.usage_bits = {SERVICE_ACTION_IN_16, SAI_READ_CAPACITY_16, 0x00, 0x00,\n\t\t       0x00, 0x00, 0x00, 0x00,\n\t\t       0x00, 0x00, 0xff, 0xff,\n\t\t       0xff, 0xff, 0x00, SCSI_CONTROL_MASK},\n};\n\nstatic bool tcm_is_rep_ref_enabled(struct target_opcode_descriptor *descr,\n\t\t\t\t   struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\tspin_lock(&dev->t10_alua.lba_map_lock);\n\tif (list_empty(&dev->t10_alua.lba_map_list)) {\n\t\tspin_unlock(&dev->t10_alua.lba_map_lock);\n\t\treturn false;\n\t}\n\tspin_unlock(&dev->t10_alua.lba_map_lock);\n\treturn true;\n}\n\nstatic struct target_opcode_descriptor tcm_opcode_read_report_refferals = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = SERVICE_ACTION_IN_16,\n\t.service_action = SAI_REPORT_REFERRALS,\n\t.cdb_size = 16,\n\t.usage_bits = {SERVICE_ACTION_IN_16, SAI_REPORT_REFERRALS, 0x00, 0x00,\n\t\t       0x00, 0x00, 0x00, 0x00,\n\t\t       0x00, 0x00, 0xff, 0xff,\n\t\t       0xff, 0xff, 0x00, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_rep_ref_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_sync_cache = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = SYNCHRONIZE_CACHE,\n\t.cdb_size = 10,\n\t.usage_bits = {SYNCHRONIZE_CACHE, 0x02, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_sync_cache16 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = SYNCHRONIZE_CACHE_16,\n\t.cdb_size = 16,\n\t.usage_bits = {SYNCHRONIZE_CACHE_16, 0x02, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, SCSI_CONTROL_MASK},\n};\n\nstatic bool tcm_is_unmap_enabled(struct target_opcode_descriptor *descr,\n\t\t\t\t struct se_cmd *cmd)\n{\n\tstruct exec_cmd_ops *ops = cmd->protocol_data;\n\tstruct se_device *dev = cmd->se_dev;\n\n\treturn ops->execute_unmap && dev->dev_attrib.emulate_tpu;\n}\n\nstatic struct target_opcode_descriptor tcm_opcode_unmap = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = UNMAP,\n\t.cdb_size = 10,\n\t.usage_bits = {UNMAP, 0x00, 0x00, 0x00,\n\t\t       0x00, 0x00, SCSI_GROUP_NUMBER_MASK, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_unmap_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_write_same = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = WRITE_SAME,\n\t.cdb_size = 10,\n\t.usage_bits = {WRITE_SAME, 0xe8, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_ws_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_write_same16 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = WRITE_SAME_16,\n\t.cdb_size = 16,\n\t.usage_bits = {WRITE_SAME_16, 0xe8, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_ws_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_verify = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = VERIFY,\n\t.cdb_size = 10,\n\t.usage_bits = {VERIFY, 0x00, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_verify16 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = VERIFY_16,\n\t.cdb_size = 16,\n\t.usage_bits = {VERIFY_16, 0x00, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, SCSI_GROUP_NUMBER_MASK, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_start_stop = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = START_STOP,\n\t.cdb_size = 6,\n\t.usage_bits = {START_STOP, 0x01, 0x00, 0x00,\n\t\t       0x01, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_mode_select = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = MODE_SELECT,\n\t.cdb_size = 6,\n\t.usage_bits = {MODE_SELECT, 0x10, 0x00, 0x00,\n\t\t       0xff, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_mode_select10 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = MODE_SELECT_10,\n\t.cdb_size = 10,\n\t.usage_bits = {MODE_SELECT_10, 0x10, 0x00, 0x00,\n\t\t       0x00, 0x00, 0x00, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_mode_sense = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = MODE_SENSE,\n\t.cdb_size = 6,\n\t.usage_bits = {MODE_SENSE, 0x08, 0xff, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_mode_sense10 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = MODE_SENSE_10,\n\t.cdb_size = 10,\n\t.usage_bits = {MODE_SENSE_10, 0x18, 0xff, 0xff,\n\t\t       0x00, 0x00, 0x00, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_pri_read_keys = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = PERSISTENT_RESERVE_IN,\n\t.service_action = PRI_READ_KEYS,\n\t.cdb_size = 10,\n\t.usage_bits = {PERSISTENT_RESERVE_IN, PRI_READ_KEYS, 0x00, 0x00,\n\t\t       0x00, 0x00, 0x00, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_pri_read_resrv = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = PERSISTENT_RESERVE_IN,\n\t.service_action = PRI_READ_RESERVATION,\n\t.cdb_size = 10,\n\t.usage_bits = {PERSISTENT_RESERVE_IN, PRI_READ_RESERVATION, 0x00, 0x00,\n\t\t       0x00, 0x00, 0x00, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n};\n\nstatic bool tcm_is_pr_enabled(struct target_opcode_descriptor *descr,\n\t\t\t      struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\tif (!dev->dev_attrib.emulate_pr)\n\t\treturn false;\n\n\tif (!(dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_PGR))\n\t\treturn true;\n\n\tswitch (descr->opcode) {\n\tcase RESERVE:\n\tcase RESERVE_10:\n\tcase RELEASE:\n\tcase RELEASE_10:\n\t\t \n\t\treturn false;\n\tcase PERSISTENT_RESERVE_OUT:\n\t\tswitch (descr->service_action) {\n\t\tcase PRO_REGISTER_AND_MOVE:\n\t\tcase PRO_REPLACE_LOST_RESERVATION:\n\t\t\t \n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase PERSISTENT_RESERVE_IN:\n\t\tif (descr->service_action == PRI_READ_FULL_STATUS)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic struct target_opcode_descriptor tcm_opcode_pri_read_caps = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = PERSISTENT_RESERVE_IN,\n\t.service_action = PRI_REPORT_CAPABILITIES,\n\t.cdb_size = 10,\n\t.usage_bits = {PERSISTENT_RESERVE_IN, PRI_REPORT_CAPABILITIES, 0x00, 0x00,\n\t\t       0x00, 0x00, 0x00, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_pri_read_full_status = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = PERSISTENT_RESERVE_IN,\n\t.service_action = PRI_READ_FULL_STATUS,\n\t.cdb_size = 10,\n\t.usage_bits = {PERSISTENT_RESERVE_IN, PRI_READ_FULL_STATUS, 0x00, 0x00,\n\t\t       0x00, 0x00, 0x00, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_pro_register = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = PERSISTENT_RESERVE_OUT,\n\t.service_action = PRO_REGISTER,\n\t.cdb_size = 10,\n\t.usage_bits = {PERSISTENT_RESERVE_OUT, PRO_REGISTER, 0xff, 0x00,\n\t\t       0x00, 0xff, 0xff, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_pro_reserve = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = PERSISTENT_RESERVE_OUT,\n\t.service_action = PRO_RESERVE,\n\t.cdb_size = 10,\n\t.usage_bits = {PERSISTENT_RESERVE_OUT, PRO_RESERVE, 0xff, 0x00,\n\t\t       0x00, 0xff, 0xff, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_pro_release = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = PERSISTENT_RESERVE_OUT,\n\t.service_action = PRO_RELEASE,\n\t.cdb_size = 10,\n\t.usage_bits = {PERSISTENT_RESERVE_OUT, PRO_RELEASE, 0xff, 0x00,\n\t\t       0x00, 0xff, 0xff, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_pro_clear = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = PERSISTENT_RESERVE_OUT,\n\t.service_action = PRO_CLEAR,\n\t.cdb_size = 10,\n\t.usage_bits = {PERSISTENT_RESERVE_OUT, PRO_CLEAR, 0xff, 0x00,\n\t\t       0x00, 0xff, 0xff, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_pro_preempt = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = PERSISTENT_RESERVE_OUT,\n\t.service_action = PRO_PREEMPT,\n\t.cdb_size = 10,\n\t.usage_bits = {PERSISTENT_RESERVE_OUT, PRO_PREEMPT, 0xff, 0x00,\n\t\t       0x00, 0xff, 0xff, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_pro_preempt_abort = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = PERSISTENT_RESERVE_OUT,\n\t.service_action = PRO_PREEMPT_AND_ABORT,\n\t.cdb_size = 10,\n\t.usage_bits = {PERSISTENT_RESERVE_OUT, PRO_PREEMPT_AND_ABORT, 0xff, 0x00,\n\t\t       0x00, 0xff, 0xff, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_pro_reg_ign_exist = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = PERSISTENT_RESERVE_OUT,\n\t.service_action = PRO_REGISTER_AND_IGNORE_EXISTING_KEY,\n\t.cdb_size = 10,\n\t.usage_bits = {\n\t\tPERSISTENT_RESERVE_OUT, PRO_REGISTER_AND_IGNORE_EXISTING_KEY,\n\t\t0xff, 0x00,\n\t\t0x00, 0xff, 0xff, 0xff,\n\t\t0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_pro_register_move = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = PERSISTENT_RESERVE_OUT,\n\t.service_action = PRO_REGISTER_AND_MOVE,\n\t.cdb_size = 10,\n\t.usage_bits = {PERSISTENT_RESERVE_OUT, PRO_REGISTER_AND_MOVE, 0xff, 0x00,\n\t\t       0x00, 0xff, 0xff, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_release = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = RELEASE,\n\t.cdb_size = 6,\n\t.usage_bits = {RELEASE, 0x00, 0x00, 0x00,\n\t\t       0x00, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_release10 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = RELEASE_10,\n\t.cdb_size = 10,\n\t.usage_bits = {RELEASE_10, 0x00, 0x00, 0x00,\n\t\t       0x00, 0x00, 0x00, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_reserve = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = RESERVE,\n\t.cdb_size = 6,\n\t.usage_bits = {RESERVE, 0x00, 0x00, 0x00,\n\t\t       0x00, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_reserve10 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = RESERVE_10,\n\t.cdb_size = 10,\n\t.usage_bits = {RESERVE_10, 0x00, 0x00, 0x00,\n\t\t       0x00, 0x00, 0x00, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_pr_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_request_sense = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = REQUEST_SENSE,\n\t.cdb_size = 6,\n\t.usage_bits = {REQUEST_SENSE, 0x00, 0x00, 0x00,\n\t\t       0xff, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_inquiry = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = INQUIRY,\n\t.cdb_size = 6,\n\t.usage_bits = {INQUIRY, 0x01, 0xff, 0xff,\n\t\t       0xff, SCSI_CONTROL_MASK},\n};\n\nstatic bool tcm_is_3pc_enabled(struct target_opcode_descriptor *descr,\n\t\t\t       struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\treturn dev->dev_attrib.emulate_3pc;\n}\n\nstatic struct target_opcode_descriptor tcm_opcode_extended_copy_lid1 = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = EXTENDED_COPY,\n\t.cdb_size = 16,\n\t.usage_bits = {EXTENDED_COPY, 0x00, 0x00, 0x00,\n\t\t       0x00, 0x00, 0x00, 0x00,\n\t\t       0x00, 0x00, 0xff, 0xff,\n\t\t       0xff, 0xff, 0x00, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_3pc_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_rcv_copy_res_op_params = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = RECEIVE_COPY_RESULTS,\n\t.service_action = RCR_SA_OPERATING_PARAMETERS,\n\t.cdb_size = 16,\n\t.usage_bits = {RECEIVE_COPY_RESULTS, RCR_SA_OPERATING_PARAMETERS,\n\t\t       0x00, 0x00,\n\t\t       0x00, 0x00, 0x00, 0x00,\n\t\t       0x00, 0x00, 0xff, 0xff,\n\t\t       0xff, 0xff, 0x00, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_3pc_enabled,\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_report_luns = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = REPORT_LUNS,\n\t.cdb_size = 12,\n\t.usage_bits = {REPORT_LUNS, 0x00, 0xff, 0x00,\n\t\t       0x00, 0x00, 0xff, 0xff,\n\t\t       0xff, 0xff, 0x00, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_test_unit_ready = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.opcode = TEST_UNIT_READY,\n\t.cdb_size = 6,\n\t.usage_bits = {TEST_UNIT_READY, 0x00, 0x00, 0x00,\n\t\t       0x00, SCSI_CONTROL_MASK},\n};\n\nstatic struct target_opcode_descriptor tcm_opcode_report_target_pgs = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = MAINTENANCE_IN,\n\t.service_action = MI_REPORT_TARGET_PGS,\n\t.cdb_size = 12,\n\t.usage_bits = {MAINTENANCE_IN, 0xE0 | MI_REPORT_TARGET_PGS, 0x00, 0x00,\n\t\t       0x00, 0x00, 0xff, 0xff,\n\t\t       0xff, 0xff, 0x00, SCSI_CONTROL_MASK},\n};\n\nstatic bool spc_rsoc_enabled(struct target_opcode_descriptor *descr,\n\t\t\t     struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\treturn dev->dev_attrib.emulate_rsoc;\n}\n\nstatic struct target_opcode_descriptor tcm_opcode_report_supp_opcodes = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = MAINTENANCE_IN,\n\t.service_action = MI_REPORT_SUPPORTED_OPERATION_CODES,\n\t.cdb_size = 12,\n\t.usage_bits = {MAINTENANCE_IN, MI_REPORT_SUPPORTED_OPERATION_CODES,\n\t\t       0x87, 0xff,\n\t\t       0xff, 0xff, 0xff, 0xff,\n\t\t       0xff, 0xff, 0x00, SCSI_CONTROL_MASK},\n\t.enabled = spc_rsoc_enabled,\n};\n\nstatic bool tcm_is_set_tpg_enabled(struct target_opcode_descriptor *descr,\n\t\t\t\t   struct se_cmd *cmd)\n{\n\tstruct t10_alua_tg_pt_gp *l_tg_pt_gp;\n\tstruct se_lun *l_lun = cmd->se_lun;\n\n\trcu_read_lock();\n\tl_tg_pt_gp = rcu_dereference(l_lun->lun_tg_pt_gp);\n\tif (!l_tg_pt_gp) {\n\t\trcu_read_unlock();\n\t\treturn false;\n\t}\n\tif (!(l_tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICIT_ALUA)) {\n\t\trcu_read_unlock();\n\t\treturn false;\n\t}\n\trcu_read_unlock();\n\n\treturn true;\n}\n\nstatic struct target_opcode_descriptor tcm_opcode_set_tpg = {\n\t.support = SCSI_SUPPORT_FULL,\n\t.serv_action_valid = 1,\n\t.opcode = MAINTENANCE_OUT,\n\t.service_action = MO_SET_TARGET_PGS,\n\t.cdb_size = 12,\n\t.usage_bits = {MAINTENANCE_OUT, MO_SET_TARGET_PGS, 0x00, 0x00,\n\t\t       0x00, 0x00, 0xff, 0xff,\n\t\t       0xff, 0xff, 0x00, SCSI_CONTROL_MASK},\n\t.enabled = tcm_is_set_tpg_enabled,\n};\n\nstatic struct target_opcode_descriptor *tcm_supported_opcodes[] = {\n\t&tcm_opcode_read6,\n\t&tcm_opcode_read10,\n\t&tcm_opcode_read12,\n\t&tcm_opcode_read16,\n\t&tcm_opcode_write6,\n\t&tcm_opcode_write10,\n\t&tcm_opcode_write_verify10,\n\t&tcm_opcode_write12,\n\t&tcm_opcode_write16,\n\t&tcm_opcode_write_verify16,\n\t&tcm_opcode_write_same32,\n\t&tcm_opcode_compare_write,\n\t&tcm_opcode_read_capacity,\n\t&tcm_opcode_read_capacity16,\n\t&tcm_opcode_read_report_refferals,\n\t&tcm_opcode_sync_cache,\n\t&tcm_opcode_sync_cache16,\n\t&tcm_opcode_unmap,\n\t&tcm_opcode_write_same,\n\t&tcm_opcode_write_same16,\n\t&tcm_opcode_verify,\n\t&tcm_opcode_verify16,\n\t&tcm_opcode_start_stop,\n\t&tcm_opcode_mode_select,\n\t&tcm_opcode_mode_select10,\n\t&tcm_opcode_mode_sense,\n\t&tcm_opcode_mode_sense10,\n\t&tcm_opcode_pri_read_keys,\n\t&tcm_opcode_pri_read_resrv,\n\t&tcm_opcode_pri_read_caps,\n\t&tcm_opcode_pri_read_full_status,\n\t&tcm_opcode_pro_register,\n\t&tcm_opcode_pro_reserve,\n\t&tcm_opcode_pro_release,\n\t&tcm_opcode_pro_clear,\n\t&tcm_opcode_pro_preempt,\n\t&tcm_opcode_pro_preempt_abort,\n\t&tcm_opcode_pro_reg_ign_exist,\n\t&tcm_opcode_pro_register_move,\n\t&tcm_opcode_release,\n\t&tcm_opcode_release10,\n\t&tcm_opcode_reserve,\n\t&tcm_opcode_reserve10,\n\t&tcm_opcode_request_sense,\n\t&tcm_opcode_inquiry,\n\t&tcm_opcode_extended_copy_lid1,\n\t&tcm_opcode_rcv_copy_res_op_params,\n\t&tcm_opcode_report_luns,\n\t&tcm_opcode_test_unit_ready,\n\t&tcm_opcode_report_target_pgs,\n\t&tcm_opcode_report_supp_opcodes,\n\t&tcm_opcode_set_tpg,\n};\n\nstatic int\nspc_rsoc_encode_command_timeouts_descriptor(unsigned char *buf, u8 ctdp,\n\t\t\t\tstruct target_opcode_descriptor *descr)\n{\n\tif (!ctdp)\n\t\treturn 0;\n\n\tput_unaligned_be16(0xa, buf);\n\tbuf[3] = descr->specific_timeout;\n\tput_unaligned_be32(descr->nominal_timeout, &buf[4]);\n\tput_unaligned_be32(descr->recommended_timeout, &buf[8]);\n\n\treturn 12;\n}\n\nstatic int\nspc_rsoc_encode_command_descriptor(unsigned char *buf, u8 ctdp,\n\t\t\t\t   struct target_opcode_descriptor *descr)\n{\n\tint td_size = 0;\n\n\tbuf[0] = descr->opcode;\n\n\tput_unaligned_be16(descr->service_action, &buf[2]);\n\n\tbuf[5] = (ctdp << 1) | descr->serv_action_valid;\n\tput_unaligned_be16(descr->cdb_size, &buf[6]);\n\n\ttd_size = spc_rsoc_encode_command_timeouts_descriptor(&buf[8], ctdp,\n\t\t\t\t\t\t\t      descr);\n\n\treturn 8 + td_size;\n}\n\nstatic int\nspc_rsoc_encode_one_command_descriptor(unsigned char *buf, u8 ctdp,\n\t\t\t\t       struct target_opcode_descriptor *descr,\n\t\t\t\t       struct se_device *dev)\n{\n\tint td_size = 0;\n\n\tif (!descr) {\n\t\tbuf[1] = (ctdp << 7) | SCSI_SUPPORT_NOT_SUPPORTED;\n\t\treturn 2;\n\t}\n\n\tbuf[1] = (ctdp << 7) | SCSI_SUPPORT_FULL;\n\tput_unaligned_be16(descr->cdb_size, &buf[2]);\n\tmemcpy(&buf[4], descr->usage_bits, descr->cdb_size);\n\tif (descr->update_usage_bits)\n\t\tdescr->update_usage_bits(&buf[4], dev);\n\n\ttd_size = spc_rsoc_encode_command_timeouts_descriptor(\n\t\t\t&buf[4 + descr->cdb_size], ctdp, descr);\n\n\treturn 4 + descr->cdb_size + td_size;\n}\n\nstatic sense_reason_t\nspc_rsoc_get_descr(struct se_cmd *cmd, struct target_opcode_descriptor **opcode)\n{\n\tstruct target_opcode_descriptor *descr;\n\tstruct se_session *sess = cmd->se_sess;\n\tunsigned char *cdb = cmd->t_task_cdb;\n\tu8 opts = cdb[2] & 0x3;\n\tu8 requested_opcode;\n\tu16 requested_sa;\n\tint i;\n\n\trequested_opcode = cdb[3];\n\trequested_sa = ((u16)cdb[4]) << 8 | cdb[5];\n\t*opcode = NULL;\n\n\tif (opts > 3) {\n\t\tpr_debug(\"TARGET_CORE[%s]: Invalid REPORT SUPPORTED OPERATION CODES\"\n\t\t\t\" with unsupported REPORTING OPTIONS %#x for 0x%08llx from %s\\n\",\n\t\t\tcmd->se_tfo->fabric_name, opts,\n\t\t\tcmd->se_lun->unpacked_lun,\n\t\t\tsess->se_node_acl->initiatorname);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tcm_supported_opcodes); i++) {\n\t\tdescr = tcm_supported_opcodes[i];\n\t\tif (descr->opcode != requested_opcode)\n\t\t\tcontinue;\n\n\t\tswitch (opts) {\n\t\tcase 0x1:\n\t\t\t \n\t\t\tif (descr->serv_action_valid)\n\t\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\t\tif (!descr->enabled || descr->enabled(descr, cmd))\n\t\t\t\t*opcode = descr;\n\t\t\tbreak;\n\t\tcase 0x2:\n\t\t\t \n\t\t\tif (descr->serv_action_valid &&\n\t\t\t    descr->service_action == requested_sa) {\n\t\t\t\tif (!descr->enabled || descr->enabled(descr,\n\t\t\t\t\t\t\t\t      cmd))\n\t\t\t\t\t*opcode = descr;\n\t\t\t} else if (!descr->serv_action_valid)\n\t\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t\tbreak;\n\t\tcase 0x3:\n\t\t\t \n\t\t\tif (descr->service_action == requested_sa)\n\t\t\t\tif (!descr->enabled || descr->enabled(descr,\n\t\t\t\t\t\t\t\t      cmd))\n\t\t\t\t\t*opcode = descr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic sense_reason_t\nspc_emulate_report_supp_op_codes(struct se_cmd *cmd)\n{\n\tint descr_num = ARRAY_SIZE(tcm_supported_opcodes);\n\tstruct target_opcode_descriptor *descr = NULL;\n\tunsigned char *cdb = cmd->t_task_cdb;\n\tu8 rctd = (cdb[2] >> 7) & 0x1;\n\tunsigned char *buf = NULL;\n\tint response_length = 0;\n\tu8 opts = cdb[2] & 0x3;\n\tunsigned char *rbuf;\n\tsense_reason_t ret = 0;\n\tint i;\n\n\tif (!cmd->se_dev->dev_attrib.emulate_rsoc)\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\n\trbuf = transport_kmap_data_sg(cmd);\n\tif (cmd->data_length && !rbuf) {\n\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\tgoto out;\n\t}\n\n\tif (opts == 0)\n\t\tresponse_length = 4 + (8 + rctd * 12) * descr_num;\n\telse {\n\t\tret = spc_rsoc_get_descr(cmd, &descr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (descr)\n\t\t\tresponse_length = 4 + descr->cdb_size + rctd * 12;\n\t\telse\n\t\t\tresponse_length = 2;\n\t}\n\n\tbuf = kzalloc(response_length, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\tgoto out;\n\t}\n\tresponse_length = 0;\n\n\tif (opts == 0) {\n\t\tresponse_length += 4;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(tcm_supported_opcodes); i++) {\n\t\t\tdescr = tcm_supported_opcodes[i];\n\t\t\tif (descr->enabled && !descr->enabled(descr, cmd))\n\t\t\t\tcontinue;\n\n\t\t\tresponse_length += spc_rsoc_encode_command_descriptor(\n\t\t\t\t\t&buf[response_length], rctd, descr);\n\t\t}\n\t\tput_unaligned_be32(response_length - 3, buf);\n\t} else {\n\t\tresponse_length = spc_rsoc_encode_one_command_descriptor(\n\t\t\t\t&buf[response_length], rctd, descr,\n\t\t\t\tcmd->se_dev);\n\t}\n\n\tmemcpy(rbuf, buf, min_t(u32, response_length, cmd->data_length));\nout:\n\tkfree(buf);\n\ttransport_kunmap_data_sg(cmd);\n\n\tif (!ret)\n\t\ttarget_complete_cmd_with_length(cmd, SAM_STAT_GOOD, response_length);\n\treturn ret;\n}\n\nsense_reason_t\nspc_parse_cdb(struct se_cmd *cmd, unsigned int *size)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tunsigned char *cdb = cmd->t_task_cdb;\n\n\tswitch (cdb[0]) {\n\tcase RESERVE:\n\tcase RESERVE_10:\n\tcase RELEASE:\n\tcase RELEASE_10:\n\t\tif (!dev->dev_attrib.emulate_pr)\n\t\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\n\t\tif (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_PGR)\n\t\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t\tbreak;\n\tcase PERSISTENT_RESERVE_IN:\n\tcase PERSISTENT_RESERVE_OUT:\n\t\tif (!dev->dev_attrib.emulate_pr)\n\t\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t\tbreak;\n\t}\n\n\tswitch (cdb[0]) {\n\tcase MODE_SELECT:\n\t\t*size = cdb[4];\n\t\tcmd->execute_cmd = spc_emulate_modeselect;\n\t\tbreak;\n\tcase MODE_SELECT_10:\n\t\t*size = get_unaligned_be16(&cdb[7]);\n\t\tcmd->execute_cmd = spc_emulate_modeselect;\n\t\tbreak;\n\tcase MODE_SENSE:\n\t\t*size = cdb[4];\n\t\tcmd->execute_cmd = spc_emulate_modesense;\n\t\tbreak;\n\tcase MODE_SENSE_10:\n\t\t*size = get_unaligned_be16(&cdb[7]);\n\t\tcmd->execute_cmd = spc_emulate_modesense;\n\t\tbreak;\n\tcase LOG_SELECT:\n\tcase LOG_SENSE:\n\t\t*size = get_unaligned_be16(&cdb[7]);\n\t\tbreak;\n\tcase PERSISTENT_RESERVE_IN:\n\t\t*size = get_unaligned_be16(&cdb[7]);\n\t\tcmd->execute_cmd = target_scsi3_emulate_pr_in;\n\t\tbreak;\n\tcase PERSISTENT_RESERVE_OUT:\n\t\t*size = get_unaligned_be32(&cdb[5]);\n\t\tcmd->execute_cmd = target_scsi3_emulate_pr_out;\n\t\tbreak;\n\tcase RELEASE:\n\tcase RELEASE_10:\n\t\tif (cdb[0] == RELEASE_10)\n\t\t\t*size = get_unaligned_be16(&cdb[7]);\n\t\telse\n\t\t\t*size = cmd->data_length;\n\n\t\tcmd->execute_cmd = target_scsi2_reservation_release;\n\t\tbreak;\n\tcase RESERVE:\n\tcase RESERVE_10:\n\t\t \n\t\tif (cdb[0] == RESERVE_10)\n\t\t\t*size = get_unaligned_be16(&cdb[7]);\n\t\telse\n\t\t\t*size = cmd->data_length;\n\n\t\tcmd->execute_cmd = target_scsi2_reservation_reserve;\n\t\tbreak;\n\tcase REQUEST_SENSE:\n\t\t*size = cdb[4];\n\t\tcmd->execute_cmd = spc_emulate_request_sense;\n\t\tbreak;\n\tcase INQUIRY:\n\t\t*size = get_unaligned_be16(&cdb[3]);\n\n\t\t \n\t\tcmd->sam_task_attr = TCM_HEAD_TAG;\n\t\tcmd->execute_cmd = spc_emulate_inquiry;\n\t\tbreak;\n\tcase SECURITY_PROTOCOL_IN:\n\tcase SECURITY_PROTOCOL_OUT:\n\t\t*size = get_unaligned_be32(&cdb[6]);\n\t\tbreak;\n\tcase EXTENDED_COPY:\n\t\t*size = get_unaligned_be32(&cdb[10]);\n\t\tcmd->execute_cmd = target_do_xcopy;\n\t\tbreak;\n\tcase RECEIVE_COPY_RESULTS:\n\t\t*size = get_unaligned_be32(&cdb[10]);\n\t\tcmd->execute_cmd = target_do_receive_copy_results;\n\t\tbreak;\n\tcase READ_ATTRIBUTE:\n\tcase WRITE_ATTRIBUTE:\n\t\t*size = get_unaligned_be32(&cdb[10]);\n\t\tbreak;\n\tcase RECEIVE_DIAGNOSTIC:\n\tcase SEND_DIAGNOSTIC:\n\t\t*size = get_unaligned_be16(&cdb[3]);\n\t\tbreak;\n\tcase WRITE_BUFFER:\n\t\t*size = get_unaligned_be24(&cdb[6]);\n\t\tbreak;\n\tcase REPORT_LUNS:\n\t\tcmd->execute_cmd = spc_emulate_report_luns;\n\t\t*size = get_unaligned_be32(&cdb[6]);\n\t\t \n\t\tcmd->sam_task_attr = TCM_HEAD_TAG;\n\t\tbreak;\n\tcase TEST_UNIT_READY:\n\t\tcmd->execute_cmd = spc_emulate_testunitready;\n\t\t*size = 0;\n\t\tbreak;\n\tcase MAINTENANCE_IN:\n\t\tif (dev->transport->get_device_type(dev) != TYPE_ROM) {\n\t\t\t \n\t\t\tif ((cdb[1] & 0x1f) == MI_REPORT_TARGET_PGS) {\n\t\t\t\tcmd->execute_cmd =\n\t\t\t\t\ttarget_emulate_report_target_port_groups;\n\t\t\t}\n\t\t\tif ((cdb[1] & 0x1f) ==\n\t\t\t    MI_REPORT_SUPPORTED_OPERATION_CODES)\n\t\t\t\tcmd->execute_cmd =\n\t\t\t\t\tspc_emulate_report_supp_op_codes;\n\t\t\t*size = get_unaligned_be32(&cdb[6]);\n\t\t} else {\n\t\t\t \n\t\t\t*size = get_unaligned_be16(&cdb[8]);\n\t\t}\n\t\tbreak;\n\tcase MAINTENANCE_OUT:\n\t\tif (dev->transport->get_device_type(dev) != TYPE_ROM) {\n\t\t\t \n\t\t\tif (cdb[1] == MO_SET_TARGET_PGS) {\n\t\t\t\tcmd->execute_cmd =\n\t\t\t\t\ttarget_emulate_set_target_port_groups;\n\t\t\t}\n\t\t\t*size = get_unaligned_be32(&cdb[6]);\n\t\t} else {\n\t\t\t \n\t\t\t*size = get_unaligned_be16(&cdb[8]);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(spc_parse_cdb);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}