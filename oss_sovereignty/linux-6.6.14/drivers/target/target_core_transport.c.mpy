{
  "module_name": "target_core_transport.c",
  "hash_id": "aa0c1bbd8a356a1c3cfe8b7151f1eb5dcad712b241271694de46380b74031873",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_transport.c",
  "human_readable_source": "\n \n\n#include <linux/net.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/kthread.h>\n#include <linux/in.h>\n#include <linux/cdrom.h>\n#include <linux/module.h>\n#include <linux/ratelimit.h>\n#include <linux/vmalloc.h>\n#include <asm/unaligned.h>\n#include <net/sock.h>\n#include <net/tcp.h>\n#include <scsi/scsi_proto.h>\n#include <scsi/scsi_common.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n#include <target/target_core_fabric.h>\n\n#include \"target_core_internal.h\"\n#include \"target_core_alua.h\"\n#include \"target_core_pr.h\"\n#include \"target_core_ua.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/target.h>\n\nstatic struct workqueue_struct *target_completion_wq;\nstatic struct workqueue_struct *target_submission_wq;\nstatic struct kmem_cache *se_sess_cache;\nstruct kmem_cache *se_ua_cache;\nstruct kmem_cache *t10_pr_reg_cache;\nstruct kmem_cache *t10_alua_lu_gp_cache;\nstruct kmem_cache *t10_alua_lu_gp_mem_cache;\nstruct kmem_cache *t10_alua_tg_pt_gp_cache;\nstruct kmem_cache *t10_alua_lba_map_cache;\nstruct kmem_cache *t10_alua_lba_map_mem_cache;\n\nstatic void transport_complete_task_attr(struct se_cmd *cmd);\nstatic void translate_sense_reason(struct se_cmd *cmd, sense_reason_t reason);\nstatic void transport_handle_queue_full(struct se_cmd *cmd,\n\t\tstruct se_device *dev, int err, bool write_pending);\nstatic void target_complete_ok_work(struct work_struct *work);\n\nint init_se_kmem_caches(void)\n{\n\tse_sess_cache = kmem_cache_create(\"se_sess_cache\",\n\t\t\tsizeof(struct se_session), __alignof__(struct se_session),\n\t\t\t0, NULL);\n\tif (!se_sess_cache) {\n\t\tpr_err(\"kmem_cache_create() for struct se_session\"\n\t\t\t\t\" failed\\n\");\n\t\tgoto out;\n\t}\n\tse_ua_cache = kmem_cache_create(\"se_ua_cache\",\n\t\t\tsizeof(struct se_ua), __alignof__(struct se_ua),\n\t\t\t0, NULL);\n\tif (!se_ua_cache) {\n\t\tpr_err(\"kmem_cache_create() for struct se_ua failed\\n\");\n\t\tgoto out_free_sess_cache;\n\t}\n\tt10_pr_reg_cache = kmem_cache_create(\"t10_pr_reg_cache\",\n\t\t\tsizeof(struct t10_pr_registration),\n\t\t\t__alignof__(struct t10_pr_registration), 0, NULL);\n\tif (!t10_pr_reg_cache) {\n\t\tpr_err(\"kmem_cache_create() for struct t10_pr_registration\"\n\t\t\t\t\" failed\\n\");\n\t\tgoto out_free_ua_cache;\n\t}\n\tt10_alua_lu_gp_cache = kmem_cache_create(\"t10_alua_lu_gp_cache\",\n\t\t\tsizeof(struct t10_alua_lu_gp), __alignof__(struct t10_alua_lu_gp),\n\t\t\t0, NULL);\n\tif (!t10_alua_lu_gp_cache) {\n\t\tpr_err(\"kmem_cache_create() for t10_alua_lu_gp_cache\"\n\t\t\t\t\" failed\\n\");\n\t\tgoto out_free_pr_reg_cache;\n\t}\n\tt10_alua_lu_gp_mem_cache = kmem_cache_create(\"t10_alua_lu_gp_mem_cache\",\n\t\t\tsizeof(struct t10_alua_lu_gp_member),\n\t\t\t__alignof__(struct t10_alua_lu_gp_member), 0, NULL);\n\tif (!t10_alua_lu_gp_mem_cache) {\n\t\tpr_err(\"kmem_cache_create() for t10_alua_lu_gp_mem_\"\n\t\t\t\t\"cache failed\\n\");\n\t\tgoto out_free_lu_gp_cache;\n\t}\n\tt10_alua_tg_pt_gp_cache = kmem_cache_create(\"t10_alua_tg_pt_gp_cache\",\n\t\t\tsizeof(struct t10_alua_tg_pt_gp),\n\t\t\t__alignof__(struct t10_alua_tg_pt_gp), 0, NULL);\n\tif (!t10_alua_tg_pt_gp_cache) {\n\t\tpr_err(\"kmem_cache_create() for t10_alua_tg_pt_gp_\"\n\t\t\t\t\"cache failed\\n\");\n\t\tgoto out_free_lu_gp_mem_cache;\n\t}\n\tt10_alua_lba_map_cache = kmem_cache_create(\n\t\t\t\"t10_alua_lba_map_cache\",\n\t\t\tsizeof(struct t10_alua_lba_map),\n\t\t\t__alignof__(struct t10_alua_lba_map), 0, NULL);\n\tif (!t10_alua_lba_map_cache) {\n\t\tpr_err(\"kmem_cache_create() for t10_alua_lba_map_\"\n\t\t\t\t\"cache failed\\n\");\n\t\tgoto out_free_tg_pt_gp_cache;\n\t}\n\tt10_alua_lba_map_mem_cache = kmem_cache_create(\n\t\t\t\"t10_alua_lba_map_mem_cache\",\n\t\t\tsizeof(struct t10_alua_lba_map_member),\n\t\t\t__alignof__(struct t10_alua_lba_map_member), 0, NULL);\n\tif (!t10_alua_lba_map_mem_cache) {\n\t\tpr_err(\"kmem_cache_create() for t10_alua_lba_map_mem_\"\n\t\t\t\t\"cache failed\\n\");\n\t\tgoto out_free_lba_map_cache;\n\t}\n\n\ttarget_completion_wq = alloc_workqueue(\"target_completion\",\n\t\t\t\t\t       WQ_MEM_RECLAIM, 0);\n\tif (!target_completion_wq)\n\t\tgoto out_free_lba_map_mem_cache;\n\n\ttarget_submission_wq = alloc_workqueue(\"target_submission\",\n\t\t\t\t\t       WQ_MEM_RECLAIM, 0);\n\tif (!target_submission_wq)\n\t\tgoto out_free_completion_wq;\n\n\treturn 0;\n\nout_free_completion_wq:\n\tdestroy_workqueue(target_completion_wq);\nout_free_lba_map_mem_cache:\n\tkmem_cache_destroy(t10_alua_lba_map_mem_cache);\nout_free_lba_map_cache:\n\tkmem_cache_destroy(t10_alua_lba_map_cache);\nout_free_tg_pt_gp_cache:\n\tkmem_cache_destroy(t10_alua_tg_pt_gp_cache);\nout_free_lu_gp_mem_cache:\n\tkmem_cache_destroy(t10_alua_lu_gp_mem_cache);\nout_free_lu_gp_cache:\n\tkmem_cache_destroy(t10_alua_lu_gp_cache);\nout_free_pr_reg_cache:\n\tkmem_cache_destroy(t10_pr_reg_cache);\nout_free_ua_cache:\n\tkmem_cache_destroy(se_ua_cache);\nout_free_sess_cache:\n\tkmem_cache_destroy(se_sess_cache);\nout:\n\treturn -ENOMEM;\n}\n\nvoid release_se_kmem_caches(void)\n{\n\tdestroy_workqueue(target_submission_wq);\n\tdestroy_workqueue(target_completion_wq);\n\tkmem_cache_destroy(se_sess_cache);\n\tkmem_cache_destroy(se_ua_cache);\n\tkmem_cache_destroy(t10_pr_reg_cache);\n\tkmem_cache_destroy(t10_alua_lu_gp_cache);\n\tkmem_cache_destroy(t10_alua_lu_gp_mem_cache);\n\tkmem_cache_destroy(t10_alua_tg_pt_gp_cache);\n\tkmem_cache_destroy(t10_alua_lba_map_cache);\n\tkmem_cache_destroy(t10_alua_lba_map_mem_cache);\n}\n\n \nstatic DEFINE_SPINLOCK(scsi_mib_index_lock);\nstatic u32 scsi_mib_index[SCSI_INDEX_TYPE_MAX];\n\n \nu32 scsi_get_new_index(scsi_index_t type)\n{\n\tu32 new_index;\n\n\tBUG_ON((type < 0) || (type >= SCSI_INDEX_TYPE_MAX));\n\n\tspin_lock(&scsi_mib_index_lock);\n\tnew_index = ++scsi_mib_index[type];\n\tspin_unlock(&scsi_mib_index_lock);\n\n\treturn new_index;\n}\n\nvoid transport_subsystem_check_init(void)\n{\n\tint ret;\n\tstatic int sub_api_initialized;\n\n\tif (sub_api_initialized)\n\t\treturn;\n\n\tret = IS_ENABLED(CONFIG_TCM_IBLOCK) && request_module(\"target_core_iblock\");\n\tif (ret != 0)\n\t\tpr_err(\"Unable to load target_core_iblock\\n\");\n\n\tret = IS_ENABLED(CONFIG_TCM_FILEIO) && request_module(\"target_core_file\");\n\tif (ret != 0)\n\t\tpr_err(\"Unable to load target_core_file\\n\");\n\n\tret = IS_ENABLED(CONFIG_TCM_PSCSI) && request_module(\"target_core_pscsi\");\n\tif (ret != 0)\n\t\tpr_err(\"Unable to load target_core_pscsi\\n\");\n\n\tret = IS_ENABLED(CONFIG_TCM_USER2) && request_module(\"target_core_user\");\n\tif (ret != 0)\n\t\tpr_err(\"Unable to load target_core_user\\n\");\n\n\tsub_api_initialized = 1;\n}\n\nstatic void target_release_cmd_refcnt(struct percpu_ref *ref)\n{\n\tstruct target_cmd_counter *cmd_cnt  = container_of(ref,\n\t\t\t\t\t\t\t   typeof(*cmd_cnt),\n\t\t\t\t\t\t\t   refcnt);\n\twake_up(&cmd_cnt->refcnt_wq);\n}\n\nstruct target_cmd_counter *target_alloc_cmd_counter(void)\n{\n\tstruct target_cmd_counter *cmd_cnt;\n\tint rc;\n\n\tcmd_cnt = kzalloc(sizeof(*cmd_cnt), GFP_KERNEL);\n\tif (!cmd_cnt)\n\t\treturn NULL;\n\n\tinit_completion(&cmd_cnt->stop_done);\n\tinit_waitqueue_head(&cmd_cnt->refcnt_wq);\n\tatomic_set(&cmd_cnt->stopped, 0);\n\n\trc = percpu_ref_init(&cmd_cnt->refcnt, target_release_cmd_refcnt, 0,\n\t\t\t     GFP_KERNEL);\n\tif (rc)\n\t\tgoto free_cmd_cnt;\n\n\treturn cmd_cnt;\n\nfree_cmd_cnt:\n\tkfree(cmd_cnt);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(target_alloc_cmd_counter);\n\nvoid target_free_cmd_counter(struct target_cmd_counter *cmd_cnt)\n{\n\t \n\tif (!atomic_read(&cmd_cnt->stopped))\n\t\tpercpu_ref_put(&cmd_cnt->refcnt);\n\n\tpercpu_ref_exit(&cmd_cnt->refcnt);\n\tkfree(cmd_cnt);\n}\nEXPORT_SYMBOL_GPL(target_free_cmd_counter);\n\n \nvoid transport_init_session(struct se_session *se_sess)\n{\n\tINIT_LIST_HEAD(&se_sess->sess_list);\n\tINIT_LIST_HEAD(&se_sess->sess_acl_list);\n\tspin_lock_init(&se_sess->sess_cmd_lock);\n}\nEXPORT_SYMBOL(transport_init_session);\n\n \nstruct se_session *transport_alloc_session(enum target_prot_op sup_prot_ops)\n{\n\tstruct se_session *se_sess;\n\n\tse_sess = kmem_cache_zalloc(se_sess_cache, GFP_KERNEL);\n\tif (!se_sess) {\n\t\tpr_err(\"Unable to allocate struct se_session from\"\n\t\t\t\t\" se_sess_cache\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\ttransport_init_session(se_sess);\n\tse_sess->sup_prot_ops = sup_prot_ops;\n\n\treturn se_sess;\n}\nEXPORT_SYMBOL(transport_alloc_session);\n\n \nint transport_alloc_session_tags(struct se_session *se_sess,\n\t\t\t         unsigned int tag_num, unsigned int tag_size)\n{\n\tint rc;\n\n\tse_sess->sess_cmd_map = kvcalloc(tag_size, tag_num,\n\t\t\t\t\t GFP_KERNEL | __GFP_RETRY_MAYFAIL);\n\tif (!se_sess->sess_cmd_map) {\n\t\tpr_err(\"Unable to allocate se_sess->sess_cmd_map\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trc = sbitmap_queue_init_node(&se_sess->sess_tag_pool, tag_num, -1,\n\t\t\tfalse, GFP_KERNEL, NUMA_NO_NODE);\n\tif (rc < 0) {\n\t\tpr_err(\"Unable to init se_sess->sess_tag_pool,\"\n\t\t\t\" tag_num: %u\\n\", tag_num);\n\t\tkvfree(se_sess->sess_cmd_map);\n\t\tse_sess->sess_cmd_map = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(transport_alloc_session_tags);\n\n \nstatic struct se_session *\ntransport_init_session_tags(unsigned int tag_num, unsigned int tag_size,\n\t\t\t    enum target_prot_op sup_prot_ops)\n{\n\tstruct se_session *se_sess;\n\tint rc;\n\n\tif (tag_num != 0 && !tag_size) {\n\t\tpr_err(\"init_session_tags called with percpu-ida tag_num:\"\n\t\t       \" %u, but zero tag_size\\n\", tag_num);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (!tag_num && tag_size) {\n\t\tpr_err(\"init_session_tags called with percpu-ida tag_size:\"\n\t\t       \" %u, but zero tag_num\\n\", tag_size);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tse_sess = transport_alloc_session(sup_prot_ops);\n\tif (IS_ERR(se_sess))\n\t\treturn se_sess;\n\n\trc = transport_alloc_session_tags(se_sess, tag_num, tag_size);\n\tif (rc < 0) {\n\t\ttransport_free_session(se_sess);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn se_sess;\n}\n\n \nvoid __transport_register_session(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_node_acl *se_nacl,\n\tstruct se_session *se_sess,\n\tvoid *fabric_sess_ptr)\n{\n\tconst struct target_core_fabric_ops *tfo = se_tpg->se_tpg_tfo;\n\tunsigned char buf[PR_REG_ISID_LEN];\n\tunsigned long flags;\n\n\tse_sess->se_tpg = se_tpg;\n\tse_sess->fabric_sess_ptr = fabric_sess_ptr;\n\t \n\tif (se_nacl) {\n\t\t \n\t\tif (se_nacl->saved_prot_type)\n\t\t\tse_sess->sess_prot_type = se_nacl->saved_prot_type;\n\t\telse if (tfo->tpg_check_prot_fabric_only)\n\t\t\tse_sess->sess_prot_type = se_nacl->saved_prot_type =\n\t\t\t\t\ttfo->tpg_check_prot_fabric_only(se_tpg);\n\t\t \n\t\tif (se_tpg->se_tpg_tfo->sess_get_initiator_sid != NULL) {\n\t\t\tmemset(&buf[0], 0, PR_REG_ISID_LEN);\n\t\t\tse_tpg->se_tpg_tfo->sess_get_initiator_sid(se_sess,\n\t\t\t\t\t&buf[0], PR_REG_ISID_LEN);\n\t\t\tse_sess->sess_bin_isid = get_unaligned_be64(&buf[0]);\n\t\t}\n\n\t\tspin_lock_irqsave(&se_nacl->nacl_sess_lock, flags);\n\t\t \n\t\tse_nacl->nacl_sess = se_sess;\n\n\t\tlist_add_tail(&se_sess->sess_acl_list,\n\t\t\t      &se_nacl->acl_sess_list);\n\t\tspin_unlock_irqrestore(&se_nacl->nacl_sess_lock, flags);\n\t}\n\tlist_add_tail(&se_sess->sess_list, &se_tpg->tpg_sess_list);\n\n\tpr_debug(\"TARGET_CORE[%s]: Registered fabric_sess_ptr: %p\\n\",\n\t\tse_tpg->se_tpg_tfo->fabric_name, se_sess->fabric_sess_ptr);\n}\nEXPORT_SYMBOL(__transport_register_session);\n\nvoid transport_register_session(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_node_acl *se_nacl,\n\tstruct se_session *se_sess,\n\tvoid *fabric_sess_ptr)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&se_tpg->session_lock, flags);\n\t__transport_register_session(se_tpg, se_nacl, se_sess, fabric_sess_ptr);\n\tspin_unlock_irqrestore(&se_tpg->session_lock, flags);\n}\nEXPORT_SYMBOL(transport_register_session);\n\nstruct se_session *\ntarget_setup_session(struct se_portal_group *tpg,\n\t\t     unsigned int tag_num, unsigned int tag_size,\n\t\t     enum target_prot_op prot_op,\n\t\t     const char *initiatorname, void *private,\n\t\t     int (*callback)(struct se_portal_group *,\n\t\t\t\t     struct se_session *, void *))\n{\n\tstruct target_cmd_counter *cmd_cnt;\n\tstruct se_session *sess;\n\tint rc;\n\n\tcmd_cnt = target_alloc_cmd_counter();\n\tif (!cmd_cnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\t \n\tif (tag_num != 0)\n\t\tsess = transport_init_session_tags(tag_num, tag_size, prot_op);\n\telse\n\t\tsess = transport_alloc_session(prot_op);\n\n\tif (IS_ERR(sess)) {\n\t\trc = PTR_ERR(sess);\n\t\tgoto free_cnt;\n\t}\n\tsess->cmd_cnt = cmd_cnt;\n\n\tsess->se_node_acl = core_tpg_check_initiator_node_acl(tpg,\n\t\t\t\t\t(unsigned char *)initiatorname);\n\tif (!sess->se_node_acl) {\n\t\trc = -EACCES;\n\t\tgoto free_sess;\n\t}\n\t \n\tif (callback != NULL) {\n\t\trc = callback(tpg, sess, private);\n\t\tif (rc)\n\t\t\tgoto free_sess;\n\t}\n\n\ttransport_register_session(tpg, sess->se_node_acl, sess, private);\n\treturn sess;\n\nfree_sess:\n\ttransport_free_session(sess);\n\treturn ERR_PTR(rc);\n\nfree_cnt:\n\ttarget_free_cmd_counter(cmd_cnt);\n\treturn ERR_PTR(rc);\n}\nEXPORT_SYMBOL(target_setup_session);\n\nssize_t target_show_dynamic_sessions(struct se_portal_group *se_tpg, char *page)\n{\n\tstruct se_session *se_sess;\n\tssize_t len = 0;\n\n\tspin_lock_bh(&se_tpg->session_lock);\n\tlist_for_each_entry(se_sess, &se_tpg->tpg_sess_list, sess_list) {\n\t\tif (!se_sess->se_node_acl)\n\t\t\tcontinue;\n\t\tif (!se_sess->se_node_acl->dynamic_node_acl)\n\t\t\tcontinue;\n\t\tif (strlen(se_sess->se_node_acl->initiatorname) + 1 + len > PAGE_SIZE)\n\t\t\tbreak;\n\n\t\tlen += snprintf(page + len, PAGE_SIZE - len, \"%s\\n\",\n\t\t\t\tse_sess->se_node_acl->initiatorname);\n\t\tlen += 1;  \n\t}\n\tspin_unlock_bh(&se_tpg->session_lock);\n\n\treturn len;\n}\nEXPORT_SYMBOL(target_show_dynamic_sessions);\n\nstatic void target_complete_nacl(struct kref *kref)\n{\n\tstruct se_node_acl *nacl = container_of(kref,\n\t\t\t\tstruct se_node_acl, acl_kref);\n\tstruct se_portal_group *se_tpg = nacl->se_tpg;\n\n\tif (!nacl->dynamic_stop) {\n\t\tcomplete(&nacl->acl_free_comp);\n\t\treturn;\n\t}\n\n\tmutex_lock(&se_tpg->acl_node_mutex);\n\tlist_del_init(&nacl->acl_list);\n\tmutex_unlock(&se_tpg->acl_node_mutex);\n\n\tcore_tpg_wait_for_nacl_pr_ref(nacl);\n\tcore_free_device_list_for_node(nacl, se_tpg);\n\tkfree(nacl);\n}\n\nvoid target_put_nacl(struct se_node_acl *nacl)\n{\n\tkref_put(&nacl->acl_kref, target_complete_nacl);\n}\nEXPORT_SYMBOL(target_put_nacl);\n\nvoid transport_deregister_session_configfs(struct se_session *se_sess)\n{\n\tstruct se_node_acl *se_nacl;\n\tunsigned long flags;\n\t \n\tse_nacl = se_sess->se_node_acl;\n\tif (se_nacl) {\n\t\tspin_lock_irqsave(&se_nacl->nacl_sess_lock, flags);\n\t\tif (!list_empty(&se_sess->sess_acl_list))\n\t\t\tlist_del_init(&se_sess->sess_acl_list);\n\t\t \n\t\tif (list_empty(&se_nacl->acl_sess_list))\n\t\t\tse_nacl->nacl_sess = NULL;\n\t\telse {\n\t\t\tse_nacl->nacl_sess = container_of(\n\t\t\t\t\tse_nacl->acl_sess_list.prev,\n\t\t\t\t\tstruct se_session, sess_acl_list);\n\t\t}\n\t\tspin_unlock_irqrestore(&se_nacl->nacl_sess_lock, flags);\n\t}\n}\nEXPORT_SYMBOL(transport_deregister_session_configfs);\n\nvoid transport_free_session(struct se_session *se_sess)\n{\n\tstruct se_node_acl *se_nacl = se_sess->se_node_acl;\n\n\t \n\tif (se_nacl) {\n\t\tstruct se_portal_group *se_tpg = se_nacl->se_tpg;\n\t\tconst struct target_core_fabric_ops *se_tfo = se_tpg->se_tpg_tfo;\n\t\tunsigned long flags;\n\n\t\tse_sess->se_node_acl = NULL;\n\n\t\t \n\t\tmutex_lock(&se_tpg->acl_node_mutex);\n\t\tif (se_nacl->dynamic_node_acl &&\n\t\t    !se_tfo->tpg_check_demo_mode_cache(se_tpg)) {\n\t\t\tspin_lock_irqsave(&se_nacl->nacl_sess_lock, flags);\n\t\t\tif (list_empty(&se_nacl->acl_sess_list))\n\t\t\t\tse_nacl->dynamic_stop = true;\n\t\t\tspin_unlock_irqrestore(&se_nacl->nacl_sess_lock, flags);\n\n\t\t\tif (se_nacl->dynamic_stop)\n\t\t\t\tlist_del_init(&se_nacl->acl_list);\n\t\t}\n\t\tmutex_unlock(&se_tpg->acl_node_mutex);\n\n\t\tif (se_nacl->dynamic_stop)\n\t\t\ttarget_put_nacl(se_nacl);\n\n\t\ttarget_put_nacl(se_nacl);\n\t}\n\tif (se_sess->sess_cmd_map) {\n\t\tsbitmap_queue_free(&se_sess->sess_tag_pool);\n\t\tkvfree(se_sess->sess_cmd_map);\n\t}\n\tif (se_sess->cmd_cnt)\n\t\ttarget_free_cmd_counter(se_sess->cmd_cnt);\n\tkmem_cache_free(se_sess_cache, se_sess);\n}\nEXPORT_SYMBOL(transport_free_session);\n\nstatic int target_release_res(struct se_device *dev, void *data)\n{\n\tstruct se_session *sess = data;\n\n\tif (dev->reservation_holder == sess)\n\t\ttarget_release_reservation(dev);\n\treturn 0;\n}\n\nvoid transport_deregister_session(struct se_session *se_sess)\n{\n\tstruct se_portal_group *se_tpg = se_sess->se_tpg;\n\tunsigned long flags;\n\n\tif (!se_tpg) {\n\t\ttransport_free_session(se_sess);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&se_tpg->session_lock, flags);\n\tlist_del(&se_sess->sess_list);\n\tse_sess->se_tpg = NULL;\n\tse_sess->fabric_sess_ptr = NULL;\n\tspin_unlock_irqrestore(&se_tpg->session_lock, flags);\n\n\t \n\ttarget_for_each_device(target_release_res, se_sess);\n\n\tpr_debug(\"TARGET_CORE[%s]: Deregistered fabric_sess\\n\",\n\t\tse_tpg->se_tpg_tfo->fabric_name);\n\t \n\n\ttransport_free_session(se_sess);\n}\nEXPORT_SYMBOL(transport_deregister_session);\n\nvoid target_remove_session(struct se_session *se_sess)\n{\n\ttransport_deregister_session_configfs(se_sess);\n\ttransport_deregister_session(se_sess);\n}\nEXPORT_SYMBOL(target_remove_session);\n\nstatic void target_remove_from_state_list(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tunsigned long flags;\n\n\tif (!dev)\n\t\treturn;\n\n\tspin_lock_irqsave(&dev->queues[cmd->cpuid].lock, flags);\n\tif (cmd->state_active) {\n\t\tlist_del(&cmd->state_list);\n\t\tcmd->state_active = false;\n\t}\n\tspin_unlock_irqrestore(&dev->queues[cmd->cpuid].lock, flags);\n}\n\nstatic void target_remove_from_tmr_list(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = NULL;\n\tunsigned long flags;\n\n\tif (cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)\n\t\tdev = cmd->se_tmr_req->tmr_dev;\n\n\tif (dev) {\n\t\tspin_lock_irqsave(&dev->se_tmr_lock, flags);\n\t\tif (cmd->se_tmr_req->tmr_dev)\n\t\t\tlist_del_init(&cmd->se_tmr_req->tmr_list);\n\t\tspin_unlock_irqrestore(&dev->se_tmr_lock, flags);\n\t}\n}\n \nstatic int transport_cmd_check_stop_to_fabric(struct se_cmd *cmd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cmd->t_state_lock, flags);\n\t \n\tif (cmd->transport_state & CMD_T_STOP) {\n\t\tpr_debug(\"%s:%d CMD_T_STOP for ITT: 0x%08llx\\n\",\n\t\t\t__func__, __LINE__, cmd->tag);\n\n\t\tspin_unlock_irqrestore(&cmd->t_state_lock, flags);\n\n\t\tcomplete_all(&cmd->t_transport_stop_comp);\n\t\treturn 1;\n\t}\n\tcmd->transport_state &= ~CMD_T_ACTIVE;\n\tspin_unlock_irqrestore(&cmd->t_state_lock, flags);\n\n\t \n\treturn cmd->se_tfo->check_stop_free(cmd);\n}\n\nstatic void transport_lun_remove_cmd(struct se_cmd *cmd)\n{\n\tstruct se_lun *lun = cmd->se_lun;\n\n\tif (!lun)\n\t\treturn;\n\n\ttarget_remove_from_state_list(cmd);\n\ttarget_remove_from_tmr_list(cmd);\n\n\tif (cmpxchg(&cmd->lun_ref_active, true, false))\n\t\tpercpu_ref_put(&lun->lun_ref);\n\n\t \n\tcmd->se_lun = NULL;\n}\n\nstatic void target_complete_failure_work(struct work_struct *work)\n{\n\tstruct se_cmd *cmd = container_of(work, struct se_cmd, work);\n\n\ttransport_generic_request_failure(cmd, cmd->sense_reason);\n}\n\n \nstatic unsigned char *transport_get_sense_buffer(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\tWARN_ON(!cmd->se_lun);\n\n\tif (!dev)\n\t\treturn NULL;\n\n\tif (cmd->se_cmd_flags & SCF_SENT_CHECK_CONDITION)\n\t\treturn NULL;\n\n\tcmd->scsi_sense_length = TRANSPORT_SENSE_BUFFER;\n\n\tpr_debug(\"HBA_[%u]_PLUG[%s]: Requesting sense for SAM STATUS: 0x%02x\\n\",\n\t\tdev->se_hba->hba_id, dev->transport->name, cmd->scsi_status);\n\treturn cmd->sense_buffer;\n}\n\nvoid transport_copy_sense_to_cmd(struct se_cmd *cmd, unsigned char *sense)\n{\n\tunsigned char *cmd_sense_buf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cmd->t_state_lock, flags);\n\tcmd_sense_buf = transport_get_sense_buffer(cmd);\n\tif (!cmd_sense_buf) {\n\t\tspin_unlock_irqrestore(&cmd->t_state_lock, flags);\n\t\treturn;\n\t}\n\n\tcmd->se_cmd_flags |= SCF_TRANSPORT_TASK_SENSE;\n\tmemcpy(cmd_sense_buf, sense, cmd->scsi_sense_length);\n\tspin_unlock_irqrestore(&cmd->t_state_lock, flags);\n}\nEXPORT_SYMBOL(transport_copy_sense_to_cmd);\n\nstatic void target_handle_abort(struct se_cmd *cmd)\n{\n\tbool tas = cmd->transport_state & CMD_T_TAS;\n\tbool ack_kref = cmd->se_cmd_flags & SCF_ACK_KREF;\n\tint ret;\n\n\tpr_debug(\"tag %#llx: send_abort_response = %d\\n\", cmd->tag, tas);\n\n\tif (tas) {\n\t\tif (!(cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)) {\n\t\t\tcmd->scsi_status = SAM_STAT_TASK_ABORTED;\n\t\t\tpr_debug(\"Setting SAM_STAT_TASK_ABORTED status for CDB: 0x%02x, ITT: 0x%08llx\\n\",\n\t\t\t\t cmd->t_task_cdb[0], cmd->tag);\n\t\t\ttrace_target_cmd_complete(cmd);\n\t\t\tret = cmd->se_tfo->queue_status(cmd);\n\t\t\tif (ret) {\n\t\t\t\ttransport_handle_queue_full(cmd, cmd->se_dev,\n\t\t\t\t\t\t\t    ret, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tcmd->se_tmr_req->response = TMR_FUNCTION_REJECTED;\n\t\t\tcmd->se_tfo->queue_tm_rsp(cmd);\n\t\t}\n\t} else {\n\t\t \n\t\tcmd->se_tfo->aborted_task(cmd);\n\t\tif (ack_kref)\n\t\t\tWARN_ON_ONCE(target_put_sess_cmd(cmd) != 0);\n\t\t \n\t}\n\n\tWARN_ON_ONCE(kref_read(&cmd->cmd_kref) == 0);\n\n\ttransport_lun_remove_cmd(cmd);\n\n\ttransport_cmd_check_stop_to_fabric(cmd);\n}\n\nstatic void target_abort_work(struct work_struct *work)\n{\n\tstruct se_cmd *cmd = container_of(work, struct se_cmd, work);\n\n\ttarget_handle_abort(cmd);\n}\n\nstatic bool target_cmd_interrupted(struct se_cmd *cmd)\n{\n\tint post_ret;\n\n\tif (cmd->transport_state & CMD_T_ABORTED) {\n\t\tif (cmd->transport_complete_callback)\n\t\t\tcmd->transport_complete_callback(cmd, false, &post_ret);\n\t\tINIT_WORK(&cmd->work, target_abort_work);\n\t\tqueue_work(target_completion_wq, &cmd->work);\n\t\treturn true;\n\t} else if (cmd->transport_state & CMD_T_STOP) {\n\t\tif (cmd->transport_complete_callback)\n\t\t\tcmd->transport_complete_callback(cmd, false, &post_ret);\n\t\tcomplete_all(&cmd->t_transport_stop_comp);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nvoid target_complete_cmd_with_sense(struct se_cmd *cmd, u8 scsi_status,\n\t\t\t\t    sense_reason_t sense_reason)\n{\n\tstruct se_wwn *wwn = cmd->se_sess->se_tpg->se_tpg_wwn;\n\tint success, cpu;\n\tunsigned long flags;\n\n\tif (target_cmd_interrupted(cmd))\n\t\treturn;\n\n\tcmd->scsi_status = scsi_status;\n\tcmd->sense_reason = sense_reason;\n\n\tspin_lock_irqsave(&cmd->t_state_lock, flags);\n\tswitch (cmd->scsi_status) {\n\tcase SAM_STAT_CHECK_CONDITION:\n\t\tif (cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE)\n\t\t\tsuccess = 1;\n\t\telse\n\t\t\tsuccess = 0;\n\t\tbreak;\n\tdefault:\n\t\tsuccess = 1;\n\t\tbreak;\n\t}\n\n\tcmd->t_state = TRANSPORT_COMPLETE;\n\tcmd->transport_state |= (CMD_T_COMPLETE | CMD_T_ACTIVE);\n\tspin_unlock_irqrestore(&cmd->t_state_lock, flags);\n\n\tINIT_WORK(&cmd->work, success ? target_complete_ok_work :\n\t\t  target_complete_failure_work);\n\n\tif (!wwn || wwn->cmd_compl_affinity == SE_COMPL_AFFINITY_CPUID)\n\t\tcpu = cmd->cpuid;\n\telse\n\t\tcpu = wwn->cmd_compl_affinity;\n\n\tqueue_work_on(cpu, target_completion_wq, &cmd->work);\n}\nEXPORT_SYMBOL(target_complete_cmd_with_sense);\n\nvoid target_complete_cmd(struct se_cmd *cmd, u8 scsi_status)\n{\n\ttarget_complete_cmd_with_sense(cmd, scsi_status, scsi_status ?\n\t\t\t      TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE :\n\t\t\t      TCM_NO_SENSE);\n}\nEXPORT_SYMBOL(target_complete_cmd);\n\nvoid target_set_cmd_data_length(struct se_cmd *cmd, int length)\n{\n\tif (length < cmd->data_length) {\n\t\tif (cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\n\t\t\tcmd->residual_count += cmd->data_length - length;\n\t\t} else {\n\t\t\tcmd->se_cmd_flags |= SCF_UNDERFLOW_BIT;\n\t\t\tcmd->residual_count = cmd->data_length - length;\n\t\t}\n\n\t\tcmd->data_length = length;\n\t}\n}\nEXPORT_SYMBOL(target_set_cmd_data_length);\n\nvoid target_complete_cmd_with_length(struct se_cmd *cmd, u8 scsi_status, int length)\n{\n\tif (scsi_status == SAM_STAT_GOOD ||\n\t    cmd->se_cmd_flags & SCF_TREAT_READ_AS_NORMAL) {\n\t\ttarget_set_cmd_data_length(cmd, length);\n\t}\n\n\ttarget_complete_cmd(cmd, scsi_status);\n}\nEXPORT_SYMBOL(target_complete_cmd_with_length);\n\nstatic void target_add_to_state_list(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->queues[cmd->cpuid].lock, flags);\n\tif (!cmd->state_active) {\n\t\tlist_add_tail(&cmd->state_list,\n\t\t\t      &dev->queues[cmd->cpuid].state_list);\n\t\tcmd->state_active = true;\n\t}\n\tspin_unlock_irqrestore(&dev->queues[cmd->cpuid].lock, flags);\n}\n\n \nstatic void transport_write_pending_qf(struct se_cmd *cmd);\nstatic void transport_complete_qf(struct se_cmd *cmd);\n\nvoid target_qf_do_work(struct work_struct *work)\n{\n\tstruct se_device *dev = container_of(work, struct se_device,\n\t\t\t\t\tqf_work_queue);\n\tLIST_HEAD(qf_cmd_list);\n\tstruct se_cmd *cmd, *cmd_tmp;\n\n\tspin_lock_irq(&dev->qf_cmd_lock);\n\tlist_splice_init(&dev->qf_cmd_list, &qf_cmd_list);\n\tspin_unlock_irq(&dev->qf_cmd_lock);\n\n\tlist_for_each_entry_safe(cmd, cmd_tmp, &qf_cmd_list, se_qf_node) {\n\t\tlist_del(&cmd->se_qf_node);\n\t\tatomic_dec_mb(&dev->dev_qf_count);\n\n\t\tpr_debug(\"Processing %s cmd: %p QUEUE_FULL in work queue\"\n\t\t\t\" context: %s\\n\", cmd->se_tfo->fabric_name, cmd,\n\t\t\t(cmd->t_state == TRANSPORT_COMPLETE_QF_OK) ? \"COMPLETE_OK\" :\n\t\t\t(cmd->t_state == TRANSPORT_COMPLETE_QF_WP) ? \"WRITE_PENDING\"\n\t\t\t: \"UNKNOWN\");\n\n\t\tif (cmd->t_state == TRANSPORT_COMPLETE_QF_WP)\n\t\t\ttransport_write_pending_qf(cmd);\n\t\telse if (cmd->t_state == TRANSPORT_COMPLETE_QF_OK ||\n\t\t\t cmd->t_state == TRANSPORT_COMPLETE_QF_ERR)\n\t\t\ttransport_complete_qf(cmd);\n\t}\n}\n\nunsigned char *transport_dump_cmd_direction(struct se_cmd *cmd)\n{\n\tswitch (cmd->data_direction) {\n\tcase DMA_NONE:\n\t\treturn \"NONE\";\n\tcase DMA_FROM_DEVICE:\n\t\treturn \"READ\";\n\tcase DMA_TO_DEVICE:\n\t\treturn \"WRITE\";\n\tcase DMA_BIDIRECTIONAL:\n\t\treturn \"BIDI\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"UNKNOWN\";\n}\n\nvoid transport_dump_dev_state(\n\tstruct se_device *dev,\n\tchar *b,\n\tint *bl)\n{\n\t*bl += sprintf(b + *bl, \"Status: \");\n\tif (dev->export_count)\n\t\t*bl += sprintf(b + *bl, \"ACTIVATED\");\n\telse\n\t\t*bl += sprintf(b + *bl, \"DEACTIVATED\");\n\n\t*bl += sprintf(b + *bl, \"  Max Queue Depth: %d\", dev->queue_depth);\n\t*bl += sprintf(b + *bl, \"  SectorSize: %u  HwMaxSectors: %u\\n\",\n\t\tdev->dev_attrib.block_size,\n\t\tdev->dev_attrib.hw_max_sectors);\n\t*bl += sprintf(b + *bl, \"        \");\n}\n\nvoid transport_dump_vpd_proto_id(\n\tstruct t10_vpd *vpd,\n\tunsigned char *p_buf,\n\tint p_buf_len)\n{\n\tunsigned char buf[VPD_TMP_BUF_SIZE];\n\tint len;\n\n\tmemset(buf, 0, VPD_TMP_BUF_SIZE);\n\tlen = sprintf(buf, \"T10 VPD Protocol Identifier: \");\n\n\tswitch (vpd->protocol_identifier) {\n\tcase 0x00:\n\t\tsprintf(buf+len, \"Fibre Channel\\n\");\n\t\tbreak;\n\tcase 0x10:\n\t\tsprintf(buf+len, \"Parallel SCSI\\n\");\n\t\tbreak;\n\tcase 0x20:\n\t\tsprintf(buf+len, \"SSA\\n\");\n\t\tbreak;\n\tcase 0x30:\n\t\tsprintf(buf+len, \"IEEE 1394\\n\");\n\t\tbreak;\n\tcase 0x40:\n\t\tsprintf(buf+len, \"SCSI Remote Direct Memory Access\"\n\t\t\t\t\" Protocol\\n\");\n\t\tbreak;\n\tcase 0x50:\n\t\tsprintf(buf+len, \"Internet SCSI (iSCSI)\\n\");\n\t\tbreak;\n\tcase 0x60:\n\t\tsprintf(buf+len, \"SAS Serial SCSI Protocol\\n\");\n\t\tbreak;\n\tcase 0x70:\n\t\tsprintf(buf+len, \"Automation/Drive Interface Transport\"\n\t\t\t\t\" Protocol\\n\");\n\t\tbreak;\n\tcase 0x80:\n\t\tsprintf(buf+len, \"AT Attachment Interface ATA/ATAPI\\n\");\n\t\tbreak;\n\tdefault:\n\t\tsprintf(buf+len, \"Unknown 0x%02x\\n\",\n\t\t\t\tvpd->protocol_identifier);\n\t\tbreak;\n\t}\n\n\tif (p_buf)\n\t\tstrncpy(p_buf, buf, p_buf_len);\n\telse\n\t\tpr_debug(\"%s\", buf);\n}\n\nvoid\ntransport_set_vpd_proto_id(struct t10_vpd *vpd, unsigned char *page_83)\n{\n\t \n\t if (page_83[1] & 0x80) {\n\t\tvpd->protocol_identifier = (page_83[0] & 0xf0);\n\t\tvpd->protocol_identifier_set = 1;\n\t\ttransport_dump_vpd_proto_id(vpd, NULL, 0);\n\t}\n}\nEXPORT_SYMBOL(transport_set_vpd_proto_id);\n\nint transport_dump_vpd_assoc(\n\tstruct t10_vpd *vpd,\n\tunsigned char *p_buf,\n\tint p_buf_len)\n{\n\tunsigned char buf[VPD_TMP_BUF_SIZE];\n\tint ret = 0;\n\tint len;\n\n\tmemset(buf, 0, VPD_TMP_BUF_SIZE);\n\tlen = sprintf(buf, \"T10 VPD Identifier Association: \");\n\n\tswitch (vpd->association) {\n\tcase 0x00:\n\t\tsprintf(buf+len, \"addressed logical unit\\n\");\n\t\tbreak;\n\tcase 0x10:\n\t\tsprintf(buf+len, \"target port\\n\");\n\t\tbreak;\n\tcase 0x20:\n\t\tsprintf(buf+len, \"SCSI target device\\n\");\n\t\tbreak;\n\tdefault:\n\t\tsprintf(buf+len, \"Unknown 0x%02x\\n\", vpd->association);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (p_buf)\n\t\tstrncpy(p_buf, buf, p_buf_len);\n\telse\n\t\tpr_debug(\"%s\", buf);\n\n\treturn ret;\n}\n\nint transport_set_vpd_assoc(struct t10_vpd *vpd, unsigned char *page_83)\n{\n\t \n\tvpd->association = (page_83[1] & 0x30);\n\treturn transport_dump_vpd_assoc(vpd, NULL, 0);\n}\nEXPORT_SYMBOL(transport_set_vpd_assoc);\n\nint transport_dump_vpd_ident_type(\n\tstruct t10_vpd *vpd,\n\tunsigned char *p_buf,\n\tint p_buf_len)\n{\n\tunsigned char buf[VPD_TMP_BUF_SIZE];\n\tint ret = 0;\n\tint len;\n\n\tmemset(buf, 0, VPD_TMP_BUF_SIZE);\n\tlen = sprintf(buf, \"T10 VPD Identifier Type: \");\n\n\tswitch (vpd->device_identifier_type) {\n\tcase 0x00:\n\t\tsprintf(buf+len, \"Vendor specific\\n\");\n\t\tbreak;\n\tcase 0x01:\n\t\tsprintf(buf+len, \"T10 Vendor ID based\\n\");\n\t\tbreak;\n\tcase 0x02:\n\t\tsprintf(buf+len, \"EUI-64 based\\n\");\n\t\tbreak;\n\tcase 0x03:\n\t\tsprintf(buf+len, \"NAA\\n\");\n\t\tbreak;\n\tcase 0x04:\n\t\tsprintf(buf+len, \"Relative target port identifier\\n\");\n\t\tbreak;\n\tcase 0x08:\n\t\tsprintf(buf+len, \"SCSI name string\\n\");\n\t\tbreak;\n\tdefault:\n\t\tsprintf(buf+len, \"Unsupported: 0x%02x\\n\",\n\t\t\t\tvpd->device_identifier_type);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (p_buf) {\n\t\tif (p_buf_len < strlen(buf)+1)\n\t\t\treturn -EINVAL;\n\t\tstrncpy(p_buf, buf, p_buf_len);\n\t} else {\n\t\tpr_debug(\"%s\", buf);\n\t}\n\n\treturn ret;\n}\n\nint transport_set_vpd_ident_type(struct t10_vpd *vpd, unsigned char *page_83)\n{\n\t \n\tvpd->device_identifier_type = (page_83[1] & 0x0f);\n\treturn transport_dump_vpd_ident_type(vpd, NULL, 0);\n}\nEXPORT_SYMBOL(transport_set_vpd_ident_type);\n\nint transport_dump_vpd_ident(\n\tstruct t10_vpd *vpd,\n\tunsigned char *p_buf,\n\tint p_buf_len)\n{\n\tunsigned char buf[VPD_TMP_BUF_SIZE];\n\tint ret = 0;\n\n\tmemset(buf, 0, VPD_TMP_BUF_SIZE);\n\n\tswitch (vpd->device_identifier_code_set) {\n\tcase 0x01:  \n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\"T10 VPD Binary Device Identifier: %s\\n\",\n\t\t\t&vpd->device_identifier[0]);\n\t\tbreak;\n\tcase 0x02:  \n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\"T10 VPD ASCII Device Identifier: %s\\n\",\n\t\t\t&vpd->device_identifier[0]);\n\t\tbreak;\n\tcase 0x03:  \n\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\"T10 VPD UTF-8 Device Identifier: %s\\n\",\n\t\t\t&vpd->device_identifier[0]);\n\t\tbreak;\n\tdefault:\n\t\tsprintf(buf, \"T10 VPD Device Identifier encoding unsupported:\"\n\t\t\t\" 0x%02x\", vpd->device_identifier_code_set);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (p_buf)\n\t\tstrncpy(p_buf, buf, p_buf_len);\n\telse\n\t\tpr_debug(\"%s\", buf);\n\n\treturn ret;\n}\n\nint\ntransport_set_vpd_ident(struct t10_vpd *vpd, unsigned char *page_83)\n{\n\tstatic const char hex_str[] = \"0123456789abcdef\";\n\tint j = 0, i = 4;  \n\n\t \n\tvpd->device_identifier_code_set = (page_83[0] & 0x0f);\n\tswitch (vpd->device_identifier_code_set) {\n\tcase 0x01:  \n\t\tvpd->device_identifier[j++] =\n\t\t\t\thex_str[vpd->device_identifier_type];\n\t\twhile (i < (4 + page_83[3])) {\n\t\t\tvpd->device_identifier[j++] =\n\t\t\t\thex_str[(page_83[i] & 0xf0) >> 4];\n\t\t\tvpd->device_identifier[j++] =\n\t\t\t\thex_str[page_83[i] & 0x0f];\n\t\t\ti++;\n\t\t}\n\t\tbreak;\n\tcase 0x02:  \n\tcase 0x03:  \n\t\twhile (i < (4 + page_83[3]))\n\t\t\tvpd->device_identifier[j++] = page_83[i++];\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn transport_dump_vpd_ident(vpd, NULL, 0);\n}\nEXPORT_SYMBOL(transport_set_vpd_ident);\n\nstatic sense_reason_t\ntarget_check_max_data_sg_nents(struct se_cmd *cmd, struct se_device *dev,\n\t\t\t       unsigned int size)\n{\n\tu32 mtl;\n\n\tif (!cmd->se_tfo->max_data_sg_nents)\n\t\treturn TCM_NO_SENSE;\n\t \n\tmtl = (cmd->se_tfo->max_data_sg_nents * PAGE_SIZE);\n\tif (cmd->data_length > mtl) {\n\t\t \n\t\tif (cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\n\t\t\tcmd->residual_count = (size - mtl);\n\t\t} else if (cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\n\t\t\tu32 orig_dl = size + cmd->residual_count;\n\t\t\tcmd->residual_count = (orig_dl - mtl);\n\t\t} else {\n\t\t\tcmd->se_cmd_flags |= SCF_UNDERFLOW_BIT;\n\t\t\tcmd->residual_count = (cmd->data_length - mtl);\n\t\t}\n\t\tcmd->data_length = mtl;\n\t\t \n\t\tif (cmd->prot_length) {\n\t\t\tu32 sectors = (mtl / dev->dev_attrib.block_size);\n\t\t\tcmd->prot_length = dev->prot_length * sectors;\n\t\t}\n\t}\n\treturn TCM_NO_SENSE;\n}\n\n \nsense_reason_t\ntarget_cmd_size_check(struct se_cmd *cmd, unsigned int size)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\tif (cmd->unknown_data_length) {\n\t\tcmd->data_length = size;\n\t} else if (size != cmd->data_length) {\n\t\tpr_warn_ratelimited(\"TARGET_CORE[%s]: Expected Transfer Length:\"\n\t\t\t\" %u does not match SCSI CDB Length: %u for SAM Opcode:\"\n\t\t\t\" 0x%02x\\n\", cmd->se_tfo->fabric_name,\n\t\t\t\tcmd->data_length, size, cmd->t_task_cdb[0]);\n\t\t \n\t\tif (size > cmd->data_length) {\n\t\t\tcmd->se_cmd_flags |= SCF_OVERFLOW_BIT;\n\t\t\tcmd->residual_count = (size - cmd->data_length);\n\t\t} else {\n\t\t\tcmd->se_cmd_flags |= SCF_UNDERFLOW_BIT;\n\t\t\tcmd->residual_count = (cmd->data_length - size);\n\t\t\t \n\t\t\tif (cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t\tcmd->data_length = size;\n\t\t\t}\n\t\t}\n\n\t\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\tif (cmd->se_cmd_flags & SCF_SCSI_DATA_CDB) {\n\t\t\t\tpr_err_ratelimited(\"Rejecting underflow/overflow\"\n\t\t\t\t\t\t   \" for WRITE data CDB\\n\");\n\t\t\t\treturn TCM_INVALID_FIELD_IN_COMMAND_IU;\n\t\t\t}\n\t\t\t \n\t\t\tif (size > cmd->data_length) {\n\t\t\t\tpr_err_ratelimited(\"Rejecting overflow for\"\n\t\t\t\t\t\t   \" WRITE control CDB\\n\");\n\t\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn target_check_max_data_sg_nents(cmd, dev, size);\n\n}\n\n \nvoid __target_init_cmd(struct se_cmd *cmd,\n\t\t       const struct target_core_fabric_ops *tfo,\n\t\t       struct se_session *se_sess, u32 data_length,\n\t\t       int data_direction, int task_attr,\n\t\t       unsigned char *sense_buffer, u64 unpacked_lun,\n\t\t       struct target_cmd_counter *cmd_cnt)\n{\n\tINIT_LIST_HEAD(&cmd->se_delayed_node);\n\tINIT_LIST_HEAD(&cmd->se_qf_node);\n\tINIT_LIST_HEAD(&cmd->state_list);\n\tinit_completion(&cmd->t_transport_stop_comp);\n\tcmd->free_compl = NULL;\n\tcmd->abrt_compl = NULL;\n\tspin_lock_init(&cmd->t_state_lock);\n\tINIT_WORK(&cmd->work, NULL);\n\tkref_init(&cmd->cmd_kref);\n\n\tcmd->t_task_cdb = &cmd->__t_task_cdb[0];\n\tcmd->se_tfo = tfo;\n\tcmd->se_sess = se_sess;\n\tcmd->data_length = data_length;\n\tcmd->data_direction = data_direction;\n\tcmd->sam_task_attr = task_attr;\n\tcmd->sense_buffer = sense_buffer;\n\tcmd->orig_fe_lun = unpacked_lun;\n\tcmd->cmd_cnt = cmd_cnt;\n\n\tif (!(cmd->se_cmd_flags & SCF_USE_CPUID))\n\t\tcmd->cpuid = raw_smp_processor_id();\n\n\tcmd->state_active = false;\n}\nEXPORT_SYMBOL(__target_init_cmd);\n\nstatic sense_reason_t\ntransport_check_alloc_task_attr(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\t \n\tif (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH)\n\t\treturn 0;\n\n\tif (cmd->sam_task_attr == TCM_ACA_TAG) {\n\t\tpr_debug(\"SAM Task Attribute ACA\"\n\t\t\t\" emulation is not supported\\n\");\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\treturn 0;\n}\n\nsense_reason_t\ntarget_cmd_init_cdb(struct se_cmd *cmd, unsigned char *cdb, gfp_t gfp)\n{\n\tsense_reason_t ret;\n\n\t \n\tif (scsi_command_size(cdb) > SCSI_MAX_VARLEN_CDB_SIZE) {\n\t\tpr_err(\"Received SCSI CDB with command_size: %d that\"\n\t\t\t\" exceeds SCSI_MAX_VARLEN_CDB_SIZE: %d\\n\",\n\t\t\tscsi_command_size(cdb), SCSI_MAX_VARLEN_CDB_SIZE);\n\t\tret = TCM_INVALID_CDB_FIELD;\n\t\tgoto err;\n\t}\n\t \n\tif (scsi_command_size(cdb) > sizeof(cmd->__t_task_cdb)) {\n\t\tcmd->t_task_cdb = kzalloc(scsi_command_size(cdb), gfp);\n\t\tif (!cmd->t_task_cdb) {\n\t\t\tpr_err(\"Unable to allocate cmd->t_task_cdb\"\n\t\t\t\t\" %u > sizeof(cmd->__t_task_cdb): %lu ops\\n\",\n\t\t\t\tscsi_command_size(cdb),\n\t\t\t\t(unsigned long)sizeof(cmd->__t_task_cdb));\n\t\t\tret = TCM_OUT_OF_RESOURCES;\n\t\t\tgoto err;\n\t\t}\n\t}\n\t \n\tmemcpy(cmd->t_task_cdb, cdb, scsi_command_size(cdb));\n\n\ttrace_target_sequencer_start(cmd);\n\treturn 0;\n\nerr:\n\t \n\tmemcpy(cmd->t_task_cdb, cdb, min(scsi_command_size(cdb),\n\t\t\t\t\t (unsigned int)TCM_MAX_COMMAND_SIZE));\n\treturn ret;\n}\nEXPORT_SYMBOL(target_cmd_init_cdb);\n\nsense_reason_t\ntarget_cmd_parse_cdb(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tsense_reason_t ret;\n\n\tret = dev->transport->parse_cdb(cmd);\n\tif (ret == TCM_UNSUPPORTED_SCSI_OPCODE)\n\t\tpr_debug_ratelimited(\"%s/%s: Unsupported SCSI Opcode 0x%02x, sending CHECK_CONDITION.\\n\",\n\t\t\t\t     cmd->se_tfo->fabric_name,\n\t\t\t\t     cmd->se_sess->se_node_acl->initiatorname,\n\t\t\t\t     cmd->t_task_cdb[0]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = transport_check_alloc_task_attr(cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd->se_cmd_flags |= SCF_SUPPORTED_SAM_OPCODE;\n\tatomic_long_inc(&cmd->se_lun->lun_stats.cmd_pdus);\n\treturn 0;\n}\nEXPORT_SYMBOL(target_cmd_parse_cdb);\n\n \nint transport_handle_cdb_direct(\n\tstruct se_cmd *cmd)\n{\n\tsense_reason_t ret;\n\n\tmight_sleep();\n\n\tif (!cmd->se_lun) {\n\t\tdump_stack();\n\t\tpr_err(\"cmd->se_lun is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcmd->t_state = TRANSPORT_NEW_CMD;\n\tcmd->transport_state |= CMD_T_ACTIVE;\n\n\t \n\tret = transport_generic_new_cmd(cmd);\n\tif (ret)\n\t\ttransport_generic_request_failure(cmd, ret);\n\treturn 0;\n}\nEXPORT_SYMBOL(transport_handle_cdb_direct);\n\nsense_reason_t\ntransport_generic_map_mem_to_cmd(struct se_cmd *cmd, struct scatterlist *sgl,\n\t\tu32 sgl_count, struct scatterlist *sgl_bidi, u32 sgl_bidi_count)\n{\n\tif (!sgl || !sgl_count)\n\t\treturn 0;\n\n\t \n\tif (cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\n\t\tpr_warn(\"Rejecting SCSI DATA overflow for fabric using\"\n\t\t\t\" SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC\\n\");\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tcmd->t_data_sg = sgl;\n\tcmd->t_data_nents = sgl_count;\n\tcmd->t_bidi_data_sg = sgl_bidi;\n\tcmd->t_bidi_data_nents = sgl_bidi_count;\n\n\tcmd->se_cmd_flags |= SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\n\treturn 0;\n}\n\n \nint target_init_cmd(struct se_cmd *se_cmd, struct se_session *se_sess,\n\t\t    unsigned char *sense, u64 unpacked_lun,\n\t\t    u32 data_length, int task_attr, int data_dir, int flags)\n{\n\tstruct se_portal_group *se_tpg;\n\n\tse_tpg = se_sess->se_tpg;\n\tBUG_ON(!se_tpg);\n\tBUG_ON(se_cmd->se_tfo || se_cmd->se_sess);\n\n\tif (flags & TARGET_SCF_USE_CPUID)\n\t\tse_cmd->se_cmd_flags |= SCF_USE_CPUID;\n\t \n\tif (flags & TARGET_SCF_BIDI_OP)\n\t\tse_cmd->se_cmd_flags |= SCF_BIDI;\n\n\tif (flags & TARGET_SCF_UNKNOWN_SIZE)\n\t\tse_cmd->unknown_data_length = 1;\n\t \n\t__target_init_cmd(se_cmd, se_tpg->se_tpg_tfo, se_sess, data_length,\n\t\t\t  data_dir, task_attr, sense, unpacked_lun,\n\t\t\t  se_sess->cmd_cnt);\n\n\t \n\treturn target_get_sess_cmd(se_cmd, flags & TARGET_SCF_ACK_KREF);\n}\nEXPORT_SYMBOL_GPL(target_init_cmd);\n\n \nint target_submit_prep(struct se_cmd *se_cmd, unsigned char *cdb,\n\t\t       struct scatterlist *sgl, u32 sgl_count,\n\t\t       struct scatterlist *sgl_bidi, u32 sgl_bidi_count,\n\t\t       struct scatterlist *sgl_prot, u32 sgl_prot_count,\n\t\t       gfp_t gfp)\n{\n\tsense_reason_t rc;\n\n\trc = target_cmd_init_cdb(se_cmd, cdb, gfp);\n\tif (rc)\n\t\tgoto send_cc_direct;\n\n\t \n\trc = transport_lookup_cmd_lun(se_cmd);\n\tif (rc)\n\t\tgoto send_cc_direct;\n\n\trc = target_cmd_parse_cdb(se_cmd);\n\tif (rc != 0)\n\t\tgoto generic_fail;\n\n\t \n\tif (sgl_prot_count) {\n\t\tse_cmd->t_prot_sg = sgl_prot;\n\t\tse_cmd->t_prot_nents = sgl_prot_count;\n\t\tse_cmd->se_cmd_flags |= SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC;\n\t}\n\n\t \n\tif (sgl_count != 0) {\n\t\tBUG_ON(!sgl);\n\n\t\trc = transport_generic_map_mem_to_cmd(se_cmd, sgl, sgl_count,\n\t\t\t\tsgl_bidi, sgl_bidi_count);\n\t\tif (rc != 0)\n\t\t\tgoto generic_fail;\n\t}\n\n\treturn 0;\n\nsend_cc_direct:\n\ttransport_send_check_condition_and_sense(se_cmd, rc, 0);\n\ttarget_put_sess_cmd(se_cmd);\n\treturn -EIO;\n\ngeneric_fail:\n\ttransport_generic_request_failure(se_cmd, rc);\n\treturn -EIO;\n}\nEXPORT_SYMBOL_GPL(target_submit_prep);\n\n \nvoid target_submit(struct se_cmd *se_cmd)\n{\n\tstruct scatterlist *sgl = se_cmd->t_data_sg;\n\tunsigned char *buf = NULL;\n\n\tmight_sleep();\n\n\tif (se_cmd->t_data_nents != 0) {\n\t\tBUG_ON(!sgl);\n\t\t \n\t\tif (!(se_cmd->se_cmd_flags & SCF_SCSI_DATA_CDB) &&\n\t\t     se_cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\tif (sgl)\n\t\t\t\tbuf = kmap(sg_page(sgl)) + sgl->offset;\n\n\t\t\tif (buf) {\n\t\t\t\tmemset(buf, 0, sgl->length);\n\t\t\t\tkunmap(sg_page(sgl));\n\t\t\t}\n\t\t}\n\n\t}\n\n\t \n\tcore_alua_check_nonop_delay(se_cmd);\n\n\ttransport_handle_cdb_direct(se_cmd);\n}\nEXPORT_SYMBOL_GPL(target_submit);\n\n \nvoid target_submit_cmd(struct se_cmd *se_cmd, struct se_session *se_sess,\n\t\tunsigned char *cdb, unsigned char *sense, u64 unpacked_lun,\n\t\tu32 data_length, int task_attr, int data_dir, int flags)\n{\n\tint rc;\n\n\trc = target_init_cmd(se_cmd, se_sess, sense, unpacked_lun, data_length,\n\t\t\t     task_attr, data_dir, flags);\n\tWARN(rc, \"Invalid target_submit_cmd use. Driver must not use target_stop_session or call target_init_cmd directly.\\n\");\n\tif (rc)\n\t\treturn;\n\n\tif (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0, NULL, 0,\n\t\t\t       GFP_KERNEL))\n\t\treturn;\n\n\ttarget_submit(se_cmd);\n}\nEXPORT_SYMBOL(target_submit_cmd);\n\n\nstatic struct se_dev_plug *target_plug_device(struct se_device *se_dev)\n{\n\tstruct se_dev_plug *se_plug;\n\n\tif (!se_dev->transport->plug_device)\n\t\treturn NULL;\n\n\tse_plug = se_dev->transport->plug_device(se_dev);\n\tif (!se_plug)\n\t\treturn NULL;\n\n\tse_plug->se_dev = se_dev;\n\t \n\tconfig_group_get(&se_dev->dev_group);\n\treturn se_plug;\n}\n\nstatic void target_unplug_device(struct se_dev_plug *se_plug)\n{\n\tstruct se_device *se_dev = se_plug->se_dev;\n\n\tse_dev->transport->unplug_device(se_plug);\n\tconfig_group_put(&se_dev->dev_group);\n}\n\nvoid target_queued_submit_work(struct work_struct *work)\n{\n\tstruct se_cmd_queue *sq = container_of(work, struct se_cmd_queue, work);\n\tstruct se_cmd *se_cmd, *next_cmd;\n\tstruct se_dev_plug *se_plug = NULL;\n\tstruct se_device *se_dev = NULL;\n\tstruct llist_node *cmd_list;\n\n\tcmd_list = llist_del_all(&sq->cmd_list);\n\tif (!cmd_list)\n\t\t \n\t\treturn;\n\n\tcmd_list = llist_reverse_order(cmd_list);\n\tllist_for_each_entry_safe(se_cmd, next_cmd, cmd_list, se_cmd_list) {\n\t\tif (!se_dev) {\n\t\t\tse_dev = se_cmd->se_dev;\n\t\t\tse_plug = target_plug_device(se_dev);\n\t\t}\n\n\t\ttarget_submit(se_cmd);\n\t}\n\n\tif (se_plug)\n\t\ttarget_unplug_device(se_plug);\n}\n\n \nvoid target_queue_submission(struct se_cmd *se_cmd)\n{\n\tstruct se_device *se_dev = se_cmd->se_dev;\n\tint cpu = se_cmd->cpuid;\n\tstruct se_cmd_queue *sq;\n\n\tsq = &se_dev->queues[cpu].sq;\n\tllist_add(&se_cmd->se_cmd_list, &sq->cmd_list);\n\tqueue_work_on(cpu, target_submission_wq, &sq->work);\n}\nEXPORT_SYMBOL_GPL(target_queue_submission);\n\nstatic void target_complete_tmr_failure(struct work_struct *work)\n{\n\tstruct se_cmd *se_cmd = container_of(work, struct se_cmd, work);\n\n\tse_cmd->se_tmr_req->response = TMR_LUN_DOES_NOT_EXIST;\n\tse_cmd->se_tfo->queue_tm_rsp(se_cmd);\n\n\ttransport_lun_remove_cmd(se_cmd);\n\ttransport_cmd_check_stop_to_fabric(se_cmd);\n}\n\n \n\nint target_submit_tmr(struct se_cmd *se_cmd, struct se_session *se_sess,\n\t\tunsigned char *sense, u64 unpacked_lun,\n\t\tvoid *fabric_tmr_ptr, unsigned char tm_type,\n\t\tgfp_t gfp, u64 tag, int flags)\n{\n\tstruct se_portal_group *se_tpg;\n\tint ret;\n\n\tse_tpg = se_sess->se_tpg;\n\tBUG_ON(!se_tpg);\n\n\t__target_init_cmd(se_cmd, se_tpg->se_tpg_tfo, se_sess,\n\t\t\t  0, DMA_NONE, TCM_SIMPLE_TAG, sense, unpacked_lun,\n\t\t\t  se_sess->cmd_cnt);\n\t \n\tret = core_tmr_alloc_req(se_cmd, fabric_tmr_ptr, tm_type, gfp);\n\tif (ret < 0)\n\t\treturn -ENOMEM;\n\n\tif (tm_type == TMR_ABORT_TASK)\n\t\tse_cmd->se_tmr_req->ref_task_tag = tag;\n\n\t \n\tret = target_get_sess_cmd(se_cmd, flags & TARGET_SCF_ACK_KREF);\n\tif (ret) {\n\t\tcore_tmr_release_req(se_cmd->se_tmr_req);\n\t\treturn ret;\n\t}\n\n\tret = transport_lookup_tmr_lun(se_cmd);\n\tif (ret)\n\t\tgoto failure;\n\n\ttransport_generic_handle_tmr(se_cmd);\n\treturn 0;\n\n\t \nfailure:\n\tINIT_WORK(&se_cmd->work, target_complete_tmr_failure);\n\tschedule_work(&se_cmd->work);\n\treturn 0;\n}\nEXPORT_SYMBOL(target_submit_tmr);\n\n \nvoid transport_generic_request_failure(struct se_cmd *cmd,\n\t\tsense_reason_t sense_reason)\n{\n\tint ret = 0, post_ret;\n\n\tpr_debug(\"-----[ Storage Engine Exception; sense_reason %d\\n\",\n\t\t sense_reason);\n\ttarget_show_cmd(\"-----[ \", cmd);\n\n\t \n\ttransport_complete_task_attr(cmd);\n\n\tif (cmd->transport_complete_callback)\n\t\tcmd->transport_complete_callback(cmd, false, &post_ret);\n\n\tif (cmd->transport_state & CMD_T_ABORTED) {\n\t\tINIT_WORK(&cmd->work, target_abort_work);\n\t\tqueue_work(target_completion_wq, &cmd->work);\n\t\treturn;\n\t}\n\n\tswitch (sense_reason) {\n\tcase TCM_NON_EXISTENT_LUN:\n\tcase TCM_UNSUPPORTED_SCSI_OPCODE:\n\tcase TCM_INVALID_CDB_FIELD:\n\tcase TCM_INVALID_PARAMETER_LIST:\n\tcase TCM_PARAMETER_LIST_LENGTH_ERROR:\n\tcase TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE:\n\tcase TCM_UNKNOWN_MODE_PAGE:\n\tcase TCM_WRITE_PROTECTED:\n\tcase TCM_ADDRESS_OUT_OF_RANGE:\n\tcase TCM_CHECK_CONDITION_ABORT_CMD:\n\tcase TCM_CHECK_CONDITION_UNIT_ATTENTION:\n\tcase TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED:\n\tcase TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED:\n\tcase TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED:\n\tcase TCM_COPY_TARGET_DEVICE_NOT_REACHABLE:\n\tcase TCM_TOO_MANY_TARGET_DESCS:\n\tcase TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE:\n\tcase TCM_TOO_MANY_SEGMENT_DESCS:\n\tcase TCM_UNSUPPORTED_SEGMENT_DESC_TYPE_CODE:\n\tcase TCM_INVALID_FIELD_IN_COMMAND_IU:\n\tcase TCM_ALUA_TG_PT_STANDBY:\n\tcase TCM_ALUA_TG_PT_UNAVAILABLE:\n\tcase TCM_ALUA_STATE_TRANSITION:\n\tcase TCM_ALUA_OFFLINE:\n\t\tbreak;\n\tcase TCM_OUT_OF_RESOURCES:\n\t\tcmd->scsi_status = SAM_STAT_TASK_SET_FULL;\n\t\tgoto queue_status;\n\tcase TCM_LUN_BUSY:\n\t\tcmd->scsi_status = SAM_STAT_BUSY;\n\t\tgoto queue_status;\n\tcase TCM_RESERVATION_CONFLICT:\n\t\t \n\t\tcmd->scsi_status = SAM_STAT_RESERVATION_CONFLICT;\n\t\t \n\t\tif (cmd->se_sess &&\n\t\t    cmd->se_dev->dev_attrib.emulate_ua_intlck_ctrl\n\t\t\t\t\t== TARGET_UA_INTLCK_CTRL_ESTABLISH_UA) {\n\t\t\ttarget_ua_allocate_lun(cmd->se_sess->se_node_acl,\n\t\t\t\t\t       cmd->orig_fe_lun, 0x2C,\n\t\t\t\t\tASCQ_2CH_PREVIOUS_RESERVATION_CONFLICT_STATUS);\n\t\t}\n\n\t\tgoto queue_status;\n\tdefault:\n\t\tpr_err(\"Unknown transport error for CDB 0x%02x: %d\\n\",\n\t\t\tcmd->t_task_cdb[0], sense_reason);\n\t\tsense_reason = TCM_UNSUPPORTED_SCSI_OPCODE;\n\t\tbreak;\n\t}\n\n\tret = transport_send_check_condition_and_sense(cmd, sense_reason, 0);\n\tif (ret)\n\t\tgoto queue_full;\n\ncheck_stop:\n\ttransport_lun_remove_cmd(cmd);\n\ttransport_cmd_check_stop_to_fabric(cmd);\n\treturn;\n\nqueue_status:\n\ttrace_target_cmd_complete(cmd);\n\tret = cmd->se_tfo->queue_status(cmd);\n\tif (!ret)\n\t\tgoto check_stop;\nqueue_full:\n\ttransport_handle_queue_full(cmd, cmd->se_dev, ret, false);\n}\nEXPORT_SYMBOL(transport_generic_request_failure);\n\nvoid __target_execute_cmd(struct se_cmd *cmd, bool do_checks)\n{\n\tsense_reason_t ret;\n\n\tif (!cmd->execute_cmd) {\n\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\tgoto err;\n\t}\n\tif (do_checks) {\n\t\t \n\t\tret = target_scsi3_ua_check(cmd);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = target_alua_state_check(cmd);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = target_check_reservation(cmd);\n\t\tif (ret) {\n\t\t\tcmd->scsi_status = SAM_STAT_RESERVATION_CONFLICT;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = cmd->execute_cmd(cmd);\n\tif (!ret)\n\t\treturn;\nerr:\n\tspin_lock_irq(&cmd->t_state_lock);\n\tcmd->transport_state &= ~CMD_T_SENT;\n\tspin_unlock_irq(&cmd->t_state_lock);\n\n\ttransport_generic_request_failure(cmd, ret);\n}\n\nstatic int target_write_prot_action(struct se_cmd *cmd)\n{\n\tu32 sectors;\n\t \n\tswitch (cmd->prot_op) {\n\tcase TARGET_PROT_DOUT_INSERT:\n\t\tif (!(cmd->se_sess->sup_prot_ops & TARGET_PROT_DOUT_INSERT))\n\t\t\tsbc_dif_generate(cmd);\n\t\tbreak;\n\tcase TARGET_PROT_DOUT_STRIP:\n\t\tif (cmd->se_sess->sup_prot_ops & TARGET_PROT_DOUT_STRIP)\n\t\t\tbreak;\n\n\t\tsectors = cmd->data_length >> ilog2(cmd->se_dev->dev_attrib.block_size);\n\t\tcmd->pi_err = sbc_dif_verify(cmd, cmd->t_task_lba,\n\t\t\t\t\t     sectors, 0, cmd->t_prot_sg, 0);\n\t\tif (unlikely(cmd->pi_err)) {\n\t\t\tspin_lock_irq(&cmd->t_state_lock);\n\t\t\tcmd->transport_state &= ~CMD_T_SENT;\n\t\t\tspin_unlock_irq(&cmd->t_state_lock);\n\t\t\ttransport_generic_request_failure(cmd, cmd->pi_err);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic bool target_handle_task_attr(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\tif (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH)\n\t\treturn false;\n\n\tcmd->se_cmd_flags |= SCF_TASK_ATTR_SET;\n\n\t \n\tswitch (cmd->sam_task_attr) {\n\tcase TCM_HEAD_TAG:\n\t\tatomic_inc_mb(&dev->non_ordered);\n\t\tpr_debug(\"Added HEAD_OF_QUEUE for CDB: 0x%02x\\n\",\n\t\t\t cmd->t_task_cdb[0]);\n\t\treturn false;\n\tcase TCM_ORDERED_TAG:\n\t\tatomic_inc_mb(&dev->delayed_cmd_count);\n\n\t\tpr_debug(\"Added ORDERED for CDB: 0x%02x to ordered list\\n\",\n\t\t\t cmd->t_task_cdb[0]);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tatomic_inc_mb(&dev->non_ordered);\n\n\t\tif (atomic_read(&dev->delayed_cmd_count) == 0)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\tif (cmd->sam_task_attr != TCM_ORDERED_TAG) {\n\t\tatomic_inc_mb(&dev->delayed_cmd_count);\n\t\t \n\t\tatomic_dec_mb(&dev->non_ordered);\n\t}\n\n\tspin_lock_irq(&cmd->t_state_lock);\n\tcmd->transport_state &= ~CMD_T_SENT;\n\tspin_unlock_irq(&cmd->t_state_lock);\n\n\tspin_lock(&dev->delayed_cmd_lock);\n\tlist_add_tail(&cmd->se_delayed_node, &dev->delayed_cmd_list);\n\tspin_unlock(&dev->delayed_cmd_lock);\n\n\tpr_debug(\"Added CDB: 0x%02x Task Attr: 0x%02x to delayed CMD listn\",\n\t\tcmd->t_task_cdb[0], cmd->sam_task_attr);\n\t \n\tschedule_work(&dev->delayed_cmd_work);\n\treturn true;\n}\n\nvoid target_execute_cmd(struct se_cmd *cmd)\n{\n\t \n\tif (target_cmd_interrupted(cmd))\n\t\treturn;\n\n\tspin_lock_irq(&cmd->t_state_lock);\n\tcmd->t_state = TRANSPORT_PROCESSING;\n\tcmd->transport_state |= CMD_T_ACTIVE | CMD_T_SENT;\n\tspin_unlock_irq(&cmd->t_state_lock);\n\n\tif (target_write_prot_action(cmd))\n\t\treturn;\n\n\tif (target_handle_task_attr(cmd))\n\t\treturn;\n\n\t__target_execute_cmd(cmd, true);\n}\nEXPORT_SYMBOL(target_execute_cmd);\n\n \nvoid target_do_delayed_work(struct work_struct *work)\n{\n\tstruct se_device *dev = container_of(work, struct se_device,\n\t\t\t\t\t     delayed_cmd_work);\n\n\tspin_lock(&dev->delayed_cmd_lock);\n\twhile (!dev->ordered_sync_in_progress) {\n\t\tstruct se_cmd *cmd;\n\n\t\tif (list_empty(&dev->delayed_cmd_list))\n\t\t\tbreak;\n\n\t\tcmd = list_entry(dev->delayed_cmd_list.next,\n\t\t\t\t struct se_cmd, se_delayed_node);\n\n\t\tif (cmd->sam_task_attr == TCM_ORDERED_TAG) {\n\t\t\t \n\t\t\tif (atomic_read(&dev->non_ordered) > 0)\n\t\t\t\tbreak;\n\n\t\t\tdev->ordered_sync_in_progress = true;\n\t\t}\n\n\t\tlist_del(&cmd->se_delayed_node);\n\t\tatomic_dec_mb(&dev->delayed_cmd_count);\n\t\tspin_unlock(&dev->delayed_cmd_lock);\n\n\t\tif (cmd->sam_task_attr != TCM_ORDERED_TAG)\n\t\t\tatomic_inc_mb(&dev->non_ordered);\n\n\t\tcmd->transport_state |= CMD_T_SENT;\n\n\t\t__target_execute_cmd(cmd, true);\n\n\t\tspin_lock(&dev->delayed_cmd_lock);\n\t}\n\tspin_unlock(&dev->delayed_cmd_lock);\n}\n\n \nstatic void transport_complete_task_attr(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\n\tif (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH)\n\t\treturn;\n\n\tif (!(cmd->se_cmd_flags & SCF_TASK_ATTR_SET))\n\t\tgoto restart;\n\n\tif (cmd->sam_task_attr == TCM_SIMPLE_TAG) {\n\t\tatomic_dec_mb(&dev->non_ordered);\n\t\tdev->dev_cur_ordered_id++;\n\t} else if (cmd->sam_task_attr == TCM_HEAD_TAG) {\n\t\tatomic_dec_mb(&dev->non_ordered);\n\t\tdev->dev_cur_ordered_id++;\n\t\tpr_debug(\"Incremented dev_cur_ordered_id: %u for HEAD_OF_QUEUE\\n\",\n\t\t\t dev->dev_cur_ordered_id);\n\t} else if (cmd->sam_task_attr == TCM_ORDERED_TAG) {\n\t\tspin_lock(&dev->delayed_cmd_lock);\n\t\tdev->ordered_sync_in_progress = false;\n\t\tspin_unlock(&dev->delayed_cmd_lock);\n\n\t\tdev->dev_cur_ordered_id++;\n\t\tpr_debug(\"Incremented dev_cur_ordered_id: %u for ORDERED\\n\",\n\t\t\t dev->dev_cur_ordered_id);\n\t}\n\tcmd->se_cmd_flags &= ~SCF_TASK_ATTR_SET;\n\nrestart:\n\tif (atomic_read(&dev->delayed_cmd_count) > 0)\n\t\tschedule_work(&dev->delayed_cmd_work);\n}\n\nstatic void transport_complete_qf(struct se_cmd *cmd)\n{\n\tint ret = 0;\n\n\ttransport_complete_task_attr(cmd);\n\t \n\tif (cmd->t_state == TRANSPORT_COMPLETE_QF_ERR) {\n\t\tif (cmd->scsi_status)\n\t\t\tgoto queue_status;\n\n\t\ttranslate_sense_reason(cmd, TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE);\n\t\tgoto queue_status;\n\t}\n\n\t \n\tif (!(cmd->se_cmd_flags & SCF_TREAT_READ_AS_NORMAL) &&\n\t    cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE)\n\t\tgoto queue_status;\n\n\tswitch (cmd->data_direction) {\n\tcase DMA_FROM_DEVICE:\n\t\t \n\t\tif (cmd->scsi_status &&\n\t\t    !(cmd->se_cmd_flags & SCF_TREAT_READ_AS_NORMAL))\n\t\t\tgoto queue_status;\n\n\t\ttrace_target_cmd_complete(cmd);\n\t\tret = cmd->se_tfo->queue_data_in(cmd);\n\t\tbreak;\n\tcase DMA_TO_DEVICE:\n\t\tif (cmd->se_cmd_flags & SCF_BIDI) {\n\t\t\tret = cmd->se_tfo->queue_data_in(cmd);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase DMA_NONE:\nqueue_status:\n\t\ttrace_target_cmd_complete(cmd);\n\t\tret = cmd->se_tfo->queue_status(cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ret < 0) {\n\t\ttransport_handle_queue_full(cmd, cmd->se_dev, ret, false);\n\t\treturn;\n\t}\n\ttransport_lun_remove_cmd(cmd);\n\ttransport_cmd_check_stop_to_fabric(cmd);\n}\n\nstatic void transport_handle_queue_full(struct se_cmd *cmd, struct se_device *dev,\n\t\t\t\t\tint err, bool write_pending)\n{\n\t \n\tif (err == -EAGAIN || err == -ENOMEM) {\n\t\tcmd->t_state = (write_pending) ? TRANSPORT_COMPLETE_QF_WP :\n\t\t\t\t\t\t TRANSPORT_COMPLETE_QF_OK;\n\t} else {\n\t\tpr_warn_ratelimited(\"Got unknown fabric queue status: %d\\n\", err);\n\t\tcmd->t_state = TRANSPORT_COMPLETE_QF_ERR;\n\t}\n\n\tspin_lock_irq(&dev->qf_cmd_lock);\n\tlist_add_tail(&cmd->se_qf_node, &cmd->se_dev->qf_cmd_list);\n\tatomic_inc_mb(&dev->dev_qf_count);\n\tspin_unlock_irq(&cmd->se_dev->qf_cmd_lock);\n\n\tschedule_work(&cmd->se_dev->qf_work_queue);\n}\n\nstatic bool target_read_prot_action(struct se_cmd *cmd)\n{\n\tswitch (cmd->prot_op) {\n\tcase TARGET_PROT_DIN_STRIP:\n\t\tif (!(cmd->se_sess->sup_prot_ops & TARGET_PROT_DIN_STRIP)) {\n\t\t\tu32 sectors = cmd->data_length >>\n\t\t\t\t  ilog2(cmd->se_dev->dev_attrib.block_size);\n\n\t\t\tcmd->pi_err = sbc_dif_verify(cmd, cmd->t_task_lba,\n\t\t\t\t\t\t     sectors, 0, cmd->t_prot_sg,\n\t\t\t\t\t\t     0);\n\t\t\tif (cmd->pi_err)\n\t\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase TARGET_PROT_DIN_INSERT:\n\t\tif (cmd->se_sess->sup_prot_ops & TARGET_PROT_DIN_INSERT)\n\t\t\tbreak;\n\n\t\tsbc_dif_generate(cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic void target_complete_ok_work(struct work_struct *work)\n{\n\tstruct se_cmd *cmd = container_of(work, struct se_cmd, work);\n\tint ret;\n\n\t \n\ttransport_complete_task_attr(cmd);\n\n\t \n\tif (atomic_read(&cmd->se_dev->dev_qf_count) != 0)\n\t\tschedule_work(&cmd->se_dev->qf_work_queue);\n\n\t \n\tif (!(cmd->se_cmd_flags & SCF_TREAT_READ_AS_NORMAL) &&\n\t    cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) {\n\t\tWARN_ON(!cmd->scsi_status);\n\t\tret = transport_send_check_condition_and_sense(\n\t\t\t\t\tcmd, 0, 1);\n\t\tif (ret)\n\t\t\tgoto queue_full;\n\n\t\ttransport_lun_remove_cmd(cmd);\n\t\ttransport_cmd_check_stop_to_fabric(cmd);\n\t\treturn;\n\t}\n\t \n\tif (cmd->transport_complete_callback) {\n\t\tsense_reason_t rc;\n\t\tbool caw = (cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE);\n\t\tbool zero_dl = !(cmd->data_length);\n\t\tint post_ret = 0;\n\n\t\trc = cmd->transport_complete_callback(cmd, true, &post_ret);\n\t\tif (!rc && !post_ret) {\n\t\t\tif (caw && zero_dl)\n\t\t\t\tgoto queue_rsp;\n\n\t\t\treturn;\n\t\t} else if (rc) {\n\t\t\tret = transport_send_check_condition_and_sense(cmd,\n\t\t\t\t\t\trc, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto queue_full;\n\n\t\t\ttransport_lun_remove_cmd(cmd);\n\t\t\ttransport_cmd_check_stop_to_fabric(cmd);\n\t\t\treturn;\n\t\t}\n\t}\n\nqueue_rsp:\n\tswitch (cmd->data_direction) {\n\tcase DMA_FROM_DEVICE:\n\t\t \n\t\tif (cmd->scsi_status &&\n\t\t    !(cmd->se_cmd_flags & SCF_TREAT_READ_AS_NORMAL))\n\t\t\tgoto queue_status;\n\n\t\tatomic_long_add(cmd->data_length,\n\t\t\t\t&cmd->se_lun->lun_stats.tx_data_octets);\n\t\t \n\t\tif (target_read_prot_action(cmd)) {\n\t\t\tret = transport_send_check_condition_and_sense(cmd,\n\t\t\t\t\t\tcmd->pi_err, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto queue_full;\n\n\t\t\ttransport_lun_remove_cmd(cmd);\n\t\t\ttransport_cmd_check_stop_to_fabric(cmd);\n\t\t\treturn;\n\t\t}\n\n\t\ttrace_target_cmd_complete(cmd);\n\t\tret = cmd->se_tfo->queue_data_in(cmd);\n\t\tif (ret)\n\t\t\tgoto queue_full;\n\t\tbreak;\n\tcase DMA_TO_DEVICE:\n\t\tatomic_long_add(cmd->data_length,\n\t\t\t\t&cmd->se_lun->lun_stats.rx_data_octets);\n\t\t \n\t\tif (cmd->se_cmd_flags & SCF_BIDI) {\n\t\t\tatomic_long_add(cmd->data_length,\n\t\t\t\t\t&cmd->se_lun->lun_stats.tx_data_octets);\n\t\t\tret = cmd->se_tfo->queue_data_in(cmd);\n\t\t\tif (ret)\n\t\t\t\tgoto queue_full;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase DMA_NONE:\nqueue_status:\n\t\ttrace_target_cmd_complete(cmd);\n\t\tret = cmd->se_tfo->queue_status(cmd);\n\t\tif (ret)\n\t\t\tgoto queue_full;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttransport_lun_remove_cmd(cmd);\n\ttransport_cmd_check_stop_to_fabric(cmd);\n\treturn;\n\nqueue_full:\n\tpr_debug(\"Handling complete_ok QUEUE_FULL: se_cmd: %p,\"\n\t\t\" data_direction: %d\\n\", cmd, cmd->data_direction);\n\n\ttransport_handle_queue_full(cmd, cmd->se_dev, ret, false);\n}\n\nvoid target_free_sgl(struct scatterlist *sgl, int nents)\n{\n\tsgl_free_n_order(sgl, nents, 0);\n}\nEXPORT_SYMBOL(target_free_sgl);\n\nstatic inline void transport_reset_sgl_orig(struct se_cmd *cmd)\n{\n\t \n\tif (!cmd->t_data_sg_orig)\n\t\treturn;\n\n\tkfree(cmd->t_data_sg);\n\tcmd->t_data_sg = cmd->t_data_sg_orig;\n\tcmd->t_data_sg_orig = NULL;\n\tcmd->t_data_nents = cmd->t_data_nents_orig;\n\tcmd->t_data_nents_orig = 0;\n}\n\nstatic inline void transport_free_pages(struct se_cmd *cmd)\n{\n\tif (!(cmd->se_cmd_flags & SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC)) {\n\t\ttarget_free_sgl(cmd->t_prot_sg, cmd->t_prot_nents);\n\t\tcmd->t_prot_sg = NULL;\n\t\tcmd->t_prot_nents = 0;\n\t}\n\n\tif (cmd->se_cmd_flags & SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) {\n\t\t \n\t\tif (cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE) {\n\t\t\ttarget_free_sgl(cmd->t_bidi_data_sg,\n\t\t\t\t\t   cmd->t_bidi_data_nents);\n\t\t\tcmd->t_bidi_data_sg = NULL;\n\t\t\tcmd->t_bidi_data_nents = 0;\n\t\t}\n\t\ttransport_reset_sgl_orig(cmd);\n\t\treturn;\n\t}\n\ttransport_reset_sgl_orig(cmd);\n\n\ttarget_free_sgl(cmd->t_data_sg, cmd->t_data_nents);\n\tcmd->t_data_sg = NULL;\n\tcmd->t_data_nents = 0;\n\n\ttarget_free_sgl(cmd->t_bidi_data_sg, cmd->t_bidi_data_nents);\n\tcmd->t_bidi_data_sg = NULL;\n\tcmd->t_bidi_data_nents = 0;\n}\n\nvoid *transport_kmap_data_sg(struct se_cmd *cmd)\n{\n\tstruct scatterlist *sg = cmd->t_data_sg;\n\tstruct page **pages;\n\tint i;\n\n\t \n\tif (!cmd->t_data_nents)\n\t\treturn NULL;\n\n\tBUG_ON(!sg);\n\tif (cmd->t_data_nents == 1)\n\t\treturn kmap(sg_page(sg)) + sg->offset;\n\n\t \n\tpages = kmalloc_array(cmd->t_data_nents, sizeof(*pages), GFP_KERNEL);\n\tif (!pages)\n\t\treturn NULL;\n\n\t \n\tfor_each_sg(cmd->t_data_sg, sg, cmd->t_data_nents, i) {\n\t\tpages[i] = sg_page(sg);\n\t}\n\n\tcmd->t_data_vmap = vmap(pages, cmd->t_data_nents,  VM_MAP, PAGE_KERNEL);\n\tkfree(pages);\n\tif (!cmd->t_data_vmap)\n\t\treturn NULL;\n\n\treturn cmd->t_data_vmap + cmd->t_data_sg[0].offset;\n}\nEXPORT_SYMBOL(transport_kmap_data_sg);\n\nvoid transport_kunmap_data_sg(struct se_cmd *cmd)\n{\n\tif (!cmd->t_data_nents) {\n\t\treturn;\n\t} else if (cmd->t_data_nents == 1) {\n\t\tkunmap(sg_page(cmd->t_data_sg));\n\t\treturn;\n\t}\n\n\tvunmap(cmd->t_data_vmap);\n\tcmd->t_data_vmap = NULL;\n}\nEXPORT_SYMBOL(transport_kunmap_data_sg);\n\nint\ntarget_alloc_sgl(struct scatterlist **sgl, unsigned int *nents, u32 length,\n\t\t bool zero_page, bool chainable)\n{\n\tgfp_t gfp = GFP_KERNEL | (zero_page ? __GFP_ZERO : 0);\n\n\t*sgl = sgl_alloc_order(length, 0, chainable, gfp, nents);\n\treturn *sgl ? 0 : -ENOMEM;\n}\nEXPORT_SYMBOL(target_alloc_sgl);\n\n \nsense_reason_t\ntransport_generic_new_cmd(struct se_cmd *cmd)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\tbool zero_flag = !(cmd->se_cmd_flags & SCF_SCSI_DATA_CDB);\n\n\tif (cmd->prot_op != TARGET_PROT_NORMAL &&\n\t    !(cmd->se_cmd_flags & SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC)) {\n\t\tret = target_alloc_sgl(&cmd->t_prot_sg, &cmd->t_prot_nents,\n\t\t\t\t       cmd->prot_length, true, false);\n\t\tif (ret < 0)\n\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\n\t \n\tif (!(cmd->se_cmd_flags & SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) &&\n\t    cmd->data_length) {\n\n\t\tif ((cmd->se_cmd_flags & SCF_BIDI) ||\n\t\t    (cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE)) {\n\t\t\tu32 bidi_length;\n\n\t\t\tif (cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE)\n\t\t\t\tbidi_length = cmd->t_task_nolb *\n\t\t\t\t\t      cmd->se_dev->dev_attrib.block_size;\n\t\t\telse\n\t\t\t\tbidi_length = cmd->data_length;\n\n\t\t\tret = target_alloc_sgl(&cmd->t_bidi_data_sg,\n\t\t\t\t\t       &cmd->t_bidi_data_nents,\n\t\t\t\t\t       bidi_length, zero_flag, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\t}\n\n\t\tret = target_alloc_sgl(&cmd->t_data_sg, &cmd->t_data_nents,\n\t\t\t\t       cmd->data_length, zero_flag, false);\n\t\tif (ret < 0)\n\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t} else if ((cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE) &&\n\t\t    cmd->data_length) {\n\t\t \n\t\tu32 caw_length = cmd->t_task_nolb *\n\t\t\t\t cmd->se_dev->dev_attrib.block_size;\n\n\t\tret = target_alloc_sgl(&cmd->t_bidi_data_sg,\n\t\t\t\t       &cmd->t_bidi_data_nents,\n\t\t\t\t       caw_length, zero_flag, false);\n\t\tif (ret < 0)\n\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\t \n\ttarget_add_to_state_list(cmd);\n\tif (cmd->data_direction != DMA_TO_DEVICE || cmd->data_length == 0) {\n\t\ttarget_execute_cmd(cmd);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&cmd->t_state_lock, flags);\n\tcmd->t_state = TRANSPORT_WRITE_PENDING;\n\t \n\tif (cmd->transport_state & CMD_T_STOP &&\n\t    !cmd->se_tfo->write_pending_must_be_called) {\n\t\tpr_debug(\"%s:%d CMD_T_STOP for ITT: 0x%08llx\\n\",\n\t\t\t __func__, __LINE__, cmd->tag);\n\n\t\tspin_unlock_irqrestore(&cmd->t_state_lock, flags);\n\n\t\tcomplete_all(&cmd->t_transport_stop_comp);\n\t\treturn 0;\n\t}\n\tcmd->transport_state &= ~CMD_T_ACTIVE;\n\tspin_unlock_irqrestore(&cmd->t_state_lock, flags);\n\n\tret = cmd->se_tfo->write_pending(cmd);\n\tif (ret)\n\t\tgoto queue_full;\n\n\treturn 0;\n\nqueue_full:\n\tpr_debug(\"Handling write_pending QUEUE__FULL: se_cmd: %p\\n\", cmd);\n\ttransport_handle_queue_full(cmd, cmd->se_dev, ret, true);\n\treturn 0;\n}\nEXPORT_SYMBOL(transport_generic_new_cmd);\n\nstatic void transport_write_pending_qf(struct se_cmd *cmd)\n{\n\tunsigned long flags;\n\tint ret;\n\tbool stop;\n\n\tspin_lock_irqsave(&cmd->t_state_lock, flags);\n\tstop = (cmd->transport_state & (CMD_T_STOP | CMD_T_ABORTED));\n\tspin_unlock_irqrestore(&cmd->t_state_lock, flags);\n\n\tif (stop) {\n\t\tpr_debug(\"%s:%d CMD_T_STOP|CMD_T_ABORTED for ITT: 0x%08llx\\n\",\n\t\t\t__func__, __LINE__, cmd->tag);\n\t\tcomplete_all(&cmd->t_transport_stop_comp);\n\t\treturn;\n\t}\n\n\tret = cmd->se_tfo->write_pending(cmd);\n\tif (ret) {\n\t\tpr_debug(\"Handling write_pending QUEUE__FULL: se_cmd: %p\\n\",\n\t\t\t cmd);\n\t\ttransport_handle_queue_full(cmd, cmd->se_dev, ret, true);\n\t}\n}\n\nstatic bool\n__transport_wait_for_tasks(struct se_cmd *, bool, bool *, bool *,\n\t\t\t   unsigned long *flags);\n\nstatic void target_wait_free_cmd(struct se_cmd *cmd, bool *aborted, bool *tas)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cmd->t_state_lock, flags);\n\t__transport_wait_for_tasks(cmd, true, aborted, tas, &flags);\n\tspin_unlock_irqrestore(&cmd->t_state_lock, flags);\n}\n\n \nvoid target_put_cmd_and_wait(struct se_cmd *cmd)\n{\n\tDECLARE_COMPLETION_ONSTACK(compl);\n\n\tWARN_ON_ONCE(cmd->abrt_compl);\n\tcmd->abrt_compl = &compl;\n\ttarget_put_sess_cmd(cmd);\n\twait_for_completion(&compl);\n}\n\n \nint transport_generic_free_cmd(struct se_cmd *cmd, int wait_for_tasks)\n{\n\tDECLARE_COMPLETION_ONSTACK(compl);\n\tint ret = 0;\n\tbool aborted = false, tas = false;\n\n\tif (wait_for_tasks)\n\t\ttarget_wait_free_cmd(cmd, &aborted, &tas);\n\n\tif (cmd->se_cmd_flags & SCF_SE_LUN_CMD) {\n\t\t \n\t\tif (cmd->state_active)\n\t\t\ttarget_remove_from_state_list(cmd);\n\n\t\tif (cmd->se_lun)\n\t\t\ttransport_lun_remove_cmd(cmd);\n\t}\n\tif (aborted)\n\t\tcmd->free_compl = &compl;\n\tret = target_put_sess_cmd(cmd);\n\tif (aborted) {\n\t\tpr_debug(\"Detected CMD_T_ABORTED for ITT: %llu\\n\", cmd->tag);\n\t\twait_for_completion(&compl);\n\t\tret = 1;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(transport_generic_free_cmd);\n\n \nint target_get_sess_cmd(struct se_cmd *se_cmd, bool ack_kref)\n{\n\tint ret = 0;\n\n\t \n\tif (ack_kref) {\n\t\tkref_get(&se_cmd->cmd_kref);\n\t\tse_cmd->se_cmd_flags |= SCF_ACK_KREF;\n\t}\n\n\t \n\tif (se_cmd->cmd_cnt) {\n\t\tif (!percpu_ref_tryget_live(&se_cmd->cmd_cnt->refcnt))\n\t\t\tret = -ESHUTDOWN;\n\t}\n\tif (ret && ack_kref)\n\t\ttarget_put_sess_cmd(se_cmd);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(target_get_sess_cmd);\n\nstatic void target_free_cmd_mem(struct se_cmd *cmd)\n{\n\ttransport_free_pages(cmd);\n\n\tif (cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)\n\t\tcore_tmr_release_req(cmd->se_tmr_req);\n\tif (cmd->t_task_cdb != cmd->__t_task_cdb)\n\t\tkfree(cmd->t_task_cdb);\n}\n\nstatic void target_release_cmd_kref(struct kref *kref)\n{\n\tstruct se_cmd *se_cmd = container_of(kref, struct se_cmd, cmd_kref);\n\tstruct target_cmd_counter *cmd_cnt = se_cmd->cmd_cnt;\n\tstruct completion *free_compl = se_cmd->free_compl;\n\tstruct completion *abrt_compl = se_cmd->abrt_compl;\n\n\ttarget_free_cmd_mem(se_cmd);\n\tse_cmd->se_tfo->release_cmd(se_cmd);\n\tif (free_compl)\n\t\tcomplete(free_compl);\n\tif (abrt_compl)\n\t\tcomplete(abrt_compl);\n\n\tif (cmd_cnt)\n\t\tpercpu_ref_put(&cmd_cnt->refcnt);\n}\n\n \nint target_put_sess_cmd(struct se_cmd *se_cmd)\n{\n\treturn kref_put(&se_cmd->cmd_kref, target_release_cmd_kref);\n}\nEXPORT_SYMBOL(target_put_sess_cmd);\n\nstatic const char *data_dir_name(enum dma_data_direction d)\n{\n\tswitch (d) {\n\tcase DMA_BIDIRECTIONAL:\treturn \"BIDI\";\n\tcase DMA_TO_DEVICE:\treturn \"WRITE\";\n\tcase DMA_FROM_DEVICE:\treturn \"READ\";\n\tcase DMA_NONE:\t\treturn \"NONE\";\n\t}\n\n\treturn \"(?)\";\n}\n\nstatic const char *cmd_state_name(enum transport_state_table t)\n{\n\tswitch (t) {\n\tcase TRANSPORT_NO_STATE:\treturn \"NO_STATE\";\n\tcase TRANSPORT_NEW_CMD:\t\treturn \"NEW_CMD\";\n\tcase TRANSPORT_WRITE_PENDING:\treturn \"WRITE_PENDING\";\n\tcase TRANSPORT_PROCESSING:\treturn \"PROCESSING\";\n\tcase TRANSPORT_COMPLETE:\treturn \"COMPLETE\";\n\tcase TRANSPORT_ISTATE_PROCESSING:\n\t\t\t\t\treturn \"ISTATE_PROCESSING\";\n\tcase TRANSPORT_COMPLETE_QF_WP:\treturn \"COMPLETE_QF_WP\";\n\tcase TRANSPORT_COMPLETE_QF_OK:\treturn \"COMPLETE_QF_OK\";\n\tcase TRANSPORT_COMPLETE_QF_ERR:\treturn \"COMPLETE_QF_ERR\";\n\t}\n\n\treturn \"(?)\";\n}\n\nstatic void target_append_str(char **str, const char *txt)\n{\n\tchar *prev = *str;\n\n\t*str = *str ? kasprintf(GFP_ATOMIC, \"%s,%s\", *str, txt) :\n\t\tkstrdup(txt, GFP_ATOMIC);\n\tkfree(prev);\n}\n\n \nstatic char *target_ts_to_str(u32 ts)\n{\n\tchar *str = NULL;\n\n\tif (ts & CMD_T_ABORTED)\n\t\ttarget_append_str(&str, \"aborted\");\n\tif (ts & CMD_T_ACTIVE)\n\t\ttarget_append_str(&str, \"active\");\n\tif (ts & CMD_T_COMPLETE)\n\t\ttarget_append_str(&str, \"complete\");\n\tif (ts & CMD_T_SENT)\n\t\ttarget_append_str(&str, \"sent\");\n\tif (ts & CMD_T_STOP)\n\t\ttarget_append_str(&str, \"stop\");\n\tif (ts & CMD_T_FABRIC_STOP)\n\t\ttarget_append_str(&str, \"fabric_stop\");\n\n\treturn str;\n}\n\nstatic const char *target_tmf_name(enum tcm_tmreq_table tmf)\n{\n\tswitch (tmf) {\n\tcase TMR_ABORT_TASK:\t\treturn \"ABORT_TASK\";\n\tcase TMR_ABORT_TASK_SET:\treturn \"ABORT_TASK_SET\";\n\tcase TMR_CLEAR_ACA:\t\treturn \"CLEAR_ACA\";\n\tcase TMR_CLEAR_TASK_SET:\treturn \"CLEAR_TASK_SET\";\n\tcase TMR_LUN_RESET:\t\treturn \"LUN_RESET\";\n\tcase TMR_TARGET_WARM_RESET:\treturn \"TARGET_WARM_RESET\";\n\tcase TMR_TARGET_COLD_RESET:\treturn \"TARGET_COLD_RESET\";\n\tcase TMR_LUN_RESET_PRO:\t\treturn \"LUN_RESET_PRO\";\n\tcase TMR_UNKNOWN:\t\tbreak;\n\t}\n\treturn \"(?)\";\n}\n\nvoid target_show_cmd(const char *pfx, struct se_cmd *cmd)\n{\n\tchar *ts_str = target_ts_to_str(cmd->transport_state);\n\tconst u8 *cdb = cmd->t_task_cdb;\n\tstruct se_tmr_req *tmf = cmd->se_tmr_req;\n\n\tif (!(cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)) {\n\t\tpr_debug(\"%scmd %#02x:%#02x with tag %#llx dir %s i_state %d t_state %s len %d refcnt %d transport_state %s\\n\",\n\t\t\t pfx, cdb[0], cdb[1], cmd->tag,\n\t\t\t data_dir_name(cmd->data_direction),\n\t\t\t cmd->se_tfo->get_cmd_state(cmd),\n\t\t\t cmd_state_name(cmd->t_state), cmd->data_length,\n\t\t\t kref_read(&cmd->cmd_kref), ts_str);\n\t} else {\n\t\tpr_debug(\"%stmf %s with tag %#llx ref_task_tag %#llx i_state %d t_state %s refcnt %d transport_state %s\\n\",\n\t\t\t pfx, target_tmf_name(tmf->function), cmd->tag,\n\t\t\t tmf->ref_task_tag, cmd->se_tfo->get_cmd_state(cmd),\n\t\t\t cmd_state_name(cmd->t_state),\n\t\t\t kref_read(&cmd->cmd_kref), ts_str);\n\t}\n\tkfree(ts_str);\n}\nEXPORT_SYMBOL(target_show_cmd);\n\nstatic void target_stop_cmd_counter_confirm(struct percpu_ref *ref)\n{\n\tstruct target_cmd_counter *cmd_cnt = container_of(ref,\n\t\t\t\t\t\tstruct target_cmd_counter,\n\t\t\t\t\t\trefcnt);\n\tcomplete_all(&cmd_cnt->stop_done);\n}\n\n \nvoid target_stop_cmd_counter(struct target_cmd_counter *cmd_cnt)\n{\n\tpr_debug(\"Stopping command counter.\\n\");\n\tif (!atomic_cmpxchg(&cmd_cnt->stopped, 0, 1))\n\t\tpercpu_ref_kill_and_confirm(&cmd_cnt->refcnt,\n\t\t\t\t\t    target_stop_cmd_counter_confirm);\n}\nEXPORT_SYMBOL_GPL(target_stop_cmd_counter);\n\n \nvoid target_stop_session(struct se_session *se_sess)\n{\n\ttarget_stop_cmd_counter(se_sess->cmd_cnt);\n}\nEXPORT_SYMBOL(target_stop_session);\n\n \nvoid target_wait_for_cmds(struct target_cmd_counter *cmd_cnt)\n{\n\tint ret;\n\n\tWARN_ON_ONCE(!atomic_read(&cmd_cnt->stopped));\n\n\tdo {\n\t\tpr_debug(\"Waiting for running cmds to complete.\\n\");\n\t\tret = wait_event_timeout(cmd_cnt->refcnt_wq,\n\t\t\t\t\t percpu_ref_is_zero(&cmd_cnt->refcnt),\n\t\t\t\t\t 180 * HZ);\n\t} while (ret <= 0);\n\n\twait_for_completion(&cmd_cnt->stop_done);\n\tpr_debug(\"Waiting for cmds done.\\n\");\n}\nEXPORT_SYMBOL_GPL(target_wait_for_cmds);\n\n \nvoid target_wait_for_sess_cmds(struct se_session *se_sess)\n{\n\ttarget_wait_for_cmds(se_sess->cmd_cnt);\n}\nEXPORT_SYMBOL(target_wait_for_sess_cmds);\n\n \nvoid transport_clear_lun_ref(struct se_lun *lun)\n{\n\tpercpu_ref_kill(&lun->lun_ref);\n\twait_for_completion(&lun->lun_shutdown_comp);\n}\n\nstatic bool\n__transport_wait_for_tasks(struct se_cmd *cmd, bool fabric_stop,\n\t\t\t   bool *aborted, bool *tas, unsigned long *flags)\n\t__releases(&cmd->t_state_lock)\n\t__acquires(&cmd->t_state_lock)\n{\n\tlockdep_assert_held(&cmd->t_state_lock);\n\n\tif (fabric_stop)\n\t\tcmd->transport_state |= CMD_T_FABRIC_STOP;\n\n\tif (cmd->transport_state & CMD_T_ABORTED)\n\t\t*aborted = true;\n\n\tif (cmd->transport_state & CMD_T_TAS)\n\t\t*tas = true;\n\n\tif (!(cmd->se_cmd_flags & SCF_SE_LUN_CMD) &&\n\t    !(cmd->se_cmd_flags & SCF_SCSI_TMR_CDB))\n\t\treturn false;\n\n\tif (!(cmd->se_cmd_flags & SCF_SUPPORTED_SAM_OPCODE) &&\n\t    !(cmd->se_cmd_flags & SCF_SCSI_TMR_CDB))\n\t\treturn false;\n\n\tif (!(cmd->transport_state & CMD_T_ACTIVE))\n\t\treturn false;\n\n\tif (fabric_stop && *aborted)\n\t\treturn false;\n\n\tcmd->transport_state |= CMD_T_STOP;\n\n\ttarget_show_cmd(\"wait_for_tasks: Stopping \", cmd);\n\n\tspin_unlock_irqrestore(&cmd->t_state_lock, *flags);\n\n\twhile (!wait_for_completion_timeout(&cmd->t_transport_stop_comp,\n\t\t\t\t\t    180 * HZ))\n\t\ttarget_show_cmd(\"wait for tasks: \", cmd);\n\n\tspin_lock_irqsave(&cmd->t_state_lock, *flags);\n\tcmd->transport_state &= ~(CMD_T_ACTIVE | CMD_T_STOP);\n\n\tpr_debug(\"wait_for_tasks: Stopped wait_for_completion(&cmd->\"\n\t\t \"t_transport_stop_comp) for ITT: 0x%08llx\\n\", cmd->tag);\n\n\treturn true;\n}\n\n \nbool transport_wait_for_tasks(struct se_cmd *cmd)\n{\n\tunsigned long flags;\n\tbool ret, aborted = false, tas = false;\n\n\tspin_lock_irqsave(&cmd->t_state_lock, flags);\n\tret = __transport_wait_for_tasks(cmd, false, &aborted, &tas, &flags);\n\tspin_unlock_irqrestore(&cmd->t_state_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(transport_wait_for_tasks);\n\nstruct sense_detail {\n\tu8 key;\n\tu8 asc;\n\tu8 ascq;\n\tbool add_sense_info;\n};\n\nstatic const struct sense_detail sense_detail_table[] = {\n\t[TCM_NO_SENSE] = {\n\t\t.key = NOT_READY\n\t},\n\t[TCM_NON_EXISTENT_LUN] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x25  \n\t},\n\t[TCM_UNSUPPORTED_SCSI_OPCODE] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x20,  \n\t},\n\t[TCM_SECTOR_COUNT_TOO_MANY] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x20,  \n\t},\n\t[TCM_UNKNOWN_MODE_PAGE] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x24,  \n\t},\n\t[TCM_CHECK_CONDITION_ABORT_CMD] = {\n\t\t.key = ABORTED_COMMAND,\n\t\t.asc = 0x29,  \n\t\t.ascq = 0x03,\n\t},\n\t[TCM_INCORRECT_AMOUNT_OF_DATA] = {\n\t\t.key = ABORTED_COMMAND,\n\t\t.asc = 0x0c,  \n\t\t.ascq = 0x0d,  \n\t},\n\t[TCM_INVALID_CDB_FIELD] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x24,  \n\t},\n\t[TCM_INVALID_PARAMETER_LIST] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x26,  \n\t},\n\t[TCM_TOO_MANY_TARGET_DESCS] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x26,\n\t\t.ascq = 0x06,  \n\t},\n\t[TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x26,\n\t\t.ascq = 0x07,  \n\t},\n\t[TCM_TOO_MANY_SEGMENT_DESCS] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x26,\n\t\t.ascq = 0x08,  \n\t},\n\t[TCM_UNSUPPORTED_SEGMENT_DESC_TYPE_CODE] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x26,\n\t\t.ascq = 0x09,  \n\t},\n\t[TCM_PARAMETER_LIST_LENGTH_ERROR] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x1a,  \n\t},\n\t[TCM_UNEXPECTED_UNSOLICITED_DATA] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x0c,  \n\t\t.ascq = 0x0c,  \n\t},\n\t[TCM_SERVICE_CRC_ERROR] = {\n\t\t.key = ABORTED_COMMAND,\n\t\t.asc = 0x47,  \n\t\t.ascq = 0x05,  \n\t},\n\t[TCM_SNACK_REJECTED] = {\n\t\t.key = ABORTED_COMMAND,\n\t\t.asc = 0x11,  \n\t\t.ascq = 0x13,  \n\t},\n\t[TCM_WRITE_PROTECTED] = {\n\t\t.key = DATA_PROTECT,\n\t\t.asc = 0x27,  \n\t},\n\t[TCM_ADDRESS_OUT_OF_RANGE] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x21,  \n\t},\n\t[TCM_CHECK_CONDITION_UNIT_ATTENTION] = {\n\t\t.key = UNIT_ATTENTION,\n\t},\n\t[TCM_MISCOMPARE_VERIFY] = {\n\t\t.key = MISCOMPARE,\n\t\t.asc = 0x1d,  \n\t\t.ascq = 0x00,\n\t\t.add_sense_info = true,\n\t},\n\t[TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED] = {\n\t\t.key = ABORTED_COMMAND,\n\t\t.asc = 0x10,\n\t\t.ascq = 0x01,  \n\t\t.add_sense_info = true,\n\t},\n\t[TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED] = {\n\t\t.key = ABORTED_COMMAND,\n\t\t.asc = 0x10,\n\t\t.ascq = 0x02,  \n\t\t.add_sense_info = true,\n\t},\n\t[TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED] = {\n\t\t.key = ABORTED_COMMAND,\n\t\t.asc = 0x10,\n\t\t.ascq = 0x03,  \n\t\t.add_sense_info = true,\n\t},\n\t[TCM_COPY_TARGET_DEVICE_NOT_REACHABLE] = {\n\t\t.key = COPY_ABORTED,\n\t\t.asc = 0x0d,\n\t\t.ascq = 0x02,  \n\n\t},\n\t[TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE] = {\n\t\t \n\t\t.key = NOT_READY,\n\t\t.asc = 0x08,  \n\t},\n\t[TCM_INSUFFICIENT_REGISTRATION_RESOURCES] = {\n\t\t \n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x55,\n\t\t.ascq = 0x04,  \n\t},\n\t[TCM_INVALID_FIELD_IN_COMMAND_IU] = {\n\t\t.key = ILLEGAL_REQUEST,\n\t\t.asc = 0x0e,\n\t\t.ascq = 0x03,  \n\t},\n\t[TCM_ALUA_TG_PT_STANDBY] = {\n\t\t.key = NOT_READY,\n\t\t.asc = 0x04,\n\t\t.ascq = ASCQ_04H_ALUA_TG_PT_STANDBY,\n\t},\n\t[TCM_ALUA_TG_PT_UNAVAILABLE] = {\n\t\t.key = NOT_READY,\n\t\t.asc = 0x04,\n\t\t.ascq = ASCQ_04H_ALUA_TG_PT_UNAVAILABLE,\n\t},\n\t[TCM_ALUA_STATE_TRANSITION] = {\n\t\t.key = NOT_READY,\n\t\t.asc = 0x04,\n\t\t.ascq = ASCQ_04H_ALUA_STATE_TRANSITION,\n\t},\n\t[TCM_ALUA_OFFLINE] = {\n\t\t.key = NOT_READY,\n\t\t.asc = 0x04,\n\t\t.ascq = ASCQ_04H_ALUA_OFFLINE,\n\t},\n};\n\n \nstatic void translate_sense_reason(struct se_cmd *cmd, sense_reason_t reason)\n{\n\tconst struct sense_detail *sd;\n\tu8 *buffer = cmd->sense_buffer;\n\tint r = (__force int)reason;\n\tu8 key, asc, ascq;\n\tbool desc_format = target_sense_desc_format(cmd->se_dev);\n\n\tif (r < ARRAY_SIZE(sense_detail_table) && sense_detail_table[r].key)\n\t\tsd = &sense_detail_table[r];\n\telse\n\t\tsd = &sense_detail_table[(__force int)\n\t\t\t\t       TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE];\n\n\tkey = sd->key;\n\tif (reason == TCM_CHECK_CONDITION_UNIT_ATTENTION) {\n\t\tif (!core_scsi3_ua_for_check_condition(cmd, &key, &asc,\n\t\t\t\t\t\t       &ascq)) {\n\t\t\tcmd->scsi_status = SAM_STAT_BUSY;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tWARN_ON_ONCE(sd->asc == 0);\n\t\tasc = sd->asc;\n\t\tascq = sd->ascq;\n\t}\n\n\tcmd->se_cmd_flags |= SCF_EMULATED_TASK_SENSE;\n\tcmd->scsi_status = SAM_STAT_CHECK_CONDITION;\n\tcmd->scsi_sense_length  = TRANSPORT_SENSE_BUFFER;\n\tscsi_build_sense_buffer(desc_format, buffer, key, asc, ascq);\n\tif (sd->add_sense_info)\n\t\tWARN_ON_ONCE(scsi_set_sense_information(buffer,\n\t\t\t\t\t\t\tcmd->scsi_sense_length,\n\t\t\t\t\t\t\tcmd->sense_info) < 0);\n}\n\nint\ntransport_send_check_condition_and_sense(struct se_cmd *cmd,\n\t\tsense_reason_t reason, int from_transport)\n{\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(cmd->se_cmd_flags & SCF_SCSI_TMR_CDB);\n\n\tspin_lock_irqsave(&cmd->t_state_lock, flags);\n\tif (cmd->se_cmd_flags & SCF_SENT_CHECK_CONDITION) {\n\t\tspin_unlock_irqrestore(&cmd->t_state_lock, flags);\n\t\treturn 0;\n\t}\n\tcmd->se_cmd_flags |= SCF_SENT_CHECK_CONDITION;\n\tspin_unlock_irqrestore(&cmd->t_state_lock, flags);\n\n\tif (!from_transport)\n\t\ttranslate_sense_reason(cmd, reason);\n\n\ttrace_target_cmd_complete(cmd);\n\treturn cmd->se_tfo->queue_status(cmd);\n}\nEXPORT_SYMBOL(transport_send_check_condition_and_sense);\n\n \nint target_send_busy(struct se_cmd *cmd)\n{\n\tWARN_ON_ONCE(cmd->se_cmd_flags & SCF_SCSI_TMR_CDB);\n\n\tcmd->scsi_status = SAM_STAT_BUSY;\n\ttrace_target_cmd_complete(cmd);\n\treturn cmd->se_tfo->queue_status(cmd);\n}\nEXPORT_SYMBOL(target_send_busy);\n\nstatic void target_tmr_work(struct work_struct *work)\n{\n\tstruct se_cmd *cmd = container_of(work, struct se_cmd, work);\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_tmr_req *tmr = cmd->se_tmr_req;\n\tint ret;\n\n\tif (cmd->transport_state & CMD_T_ABORTED)\n\t\tgoto aborted;\n\n\tswitch (tmr->function) {\n\tcase TMR_ABORT_TASK:\n\t\tcore_tmr_abort_task(dev, tmr, cmd->se_sess);\n\t\tbreak;\n\tcase TMR_ABORT_TASK_SET:\n\tcase TMR_CLEAR_ACA:\n\tcase TMR_CLEAR_TASK_SET:\n\t\ttmr->response = TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n\t\tbreak;\n\tcase TMR_LUN_RESET:\n\t\tret = core_tmr_lun_reset(dev, tmr, NULL, NULL);\n\t\ttmr->response = (!ret) ? TMR_FUNCTION_COMPLETE :\n\t\t\t\t\t TMR_FUNCTION_REJECTED;\n\t\tif (tmr->response == TMR_FUNCTION_COMPLETE) {\n\t\t\ttarget_dev_ua_allocate(dev, 0x29,\n\t\t\t\t\t       ASCQ_29H_BUS_DEVICE_RESET_FUNCTION_OCCURRED);\n\t\t}\n\t\tbreak;\n\tcase TMR_TARGET_WARM_RESET:\n\t\ttmr->response = TMR_FUNCTION_REJECTED;\n\t\tbreak;\n\tcase TMR_TARGET_COLD_RESET:\n\t\ttmr->response = TMR_FUNCTION_REJECTED;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown TMR function: 0x%02x.\\n\",\n\t\t\t\ttmr->function);\n\t\ttmr->response = TMR_FUNCTION_REJECTED;\n\t\tbreak;\n\t}\n\n\tif (cmd->transport_state & CMD_T_ABORTED)\n\t\tgoto aborted;\n\n\tcmd->se_tfo->queue_tm_rsp(cmd);\n\n\ttransport_lun_remove_cmd(cmd);\n\ttransport_cmd_check_stop_to_fabric(cmd);\n\treturn;\n\naborted:\n\ttarget_handle_abort(cmd);\n}\n\nint transport_generic_handle_tmr(\n\tstruct se_cmd *cmd)\n{\n\tunsigned long flags;\n\tbool aborted = false;\n\n\tspin_lock_irqsave(&cmd->t_state_lock, flags);\n\tif (cmd->transport_state & CMD_T_ABORTED) {\n\t\taborted = true;\n\t} else {\n\t\tcmd->t_state = TRANSPORT_ISTATE_PROCESSING;\n\t\tcmd->transport_state |= CMD_T_ACTIVE;\n\t}\n\tspin_unlock_irqrestore(&cmd->t_state_lock, flags);\n\n\tif (aborted) {\n\t\tpr_warn_ratelimited(\"handle_tmr caught CMD_T_ABORTED TMR %d ref_tag: %llu tag: %llu\\n\",\n\t\t\t\t    cmd->se_tmr_req->function,\n\t\t\t\t    cmd->se_tmr_req->ref_task_tag, cmd->tag);\n\t\ttarget_handle_abort(cmd);\n\t\treturn 0;\n\t}\n\n\tINIT_WORK(&cmd->work, target_tmr_work);\n\tschedule_work(&cmd->work);\n\treturn 0;\n}\nEXPORT_SYMBOL(transport_generic_handle_tmr);\n\nbool\ntarget_check_wce(struct se_device *dev)\n{\n\tbool wce = false;\n\n\tif (dev->transport->get_write_cache)\n\t\twce = dev->transport->get_write_cache(dev);\n\telse if (dev->dev_attrib.emulate_write_cache > 0)\n\t\twce = true;\n\n\treturn wce;\n}\n\nbool\ntarget_check_fua(struct se_device *dev)\n{\n\treturn target_check_wce(dev) && dev->dev_attrib.emulate_fua_write > 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}