{
  "module_name": "target_core_hba.c",
  "hash_id": "77f0836d2b4c72ce4fd93b5bbe3d36e9db90117d36f39e5ae2f2952786746fff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_hba.c",
  "human_readable_source": "\n \n\n#include <linux/net.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/module.h>\n#include <net/sock.h>\n#include <net/tcp.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n#include <target/target_core_fabric.h>\n\n#include \"target_core_internal.h\"\n\nstatic LIST_HEAD(backend_list);\nstatic DEFINE_MUTEX(backend_mutex);\n\nstatic u32 hba_id_counter;\n\nstatic DEFINE_SPINLOCK(hba_lock);\nstatic LIST_HEAD(hba_list);\n\n\nint transport_backend_register(const struct target_backend_ops *ops)\n{\n\tstruct target_backend *tb, *old;\n\n\ttb = kzalloc(sizeof(*tb), GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\ttb->ops = ops;\n\n\tmutex_lock(&backend_mutex);\n\tlist_for_each_entry(old, &backend_list, list) {\n\t\tif (!strcmp(old->ops->name, ops->name)) {\n\t\t\tpr_err(\"backend %s already registered.\\n\", ops->name);\n\t\t\tmutex_unlock(&backend_mutex);\n\t\t\tkfree(tb);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\ttarget_setup_backend_cits(tb);\n\tlist_add_tail(&tb->list, &backend_list);\n\tmutex_unlock(&backend_mutex);\n\n\tpr_debug(\"TCM: Registered subsystem plugin: %s struct module: %p\\n\",\n\t\t\tops->name, ops->owner);\n\treturn 0;\n}\nEXPORT_SYMBOL(transport_backend_register);\n\nvoid target_backend_unregister(const struct target_backend_ops *ops)\n{\n\tstruct target_backend *tb;\n\n\tmutex_lock(&backend_mutex);\n\tlist_for_each_entry(tb, &backend_list, list) {\n\t\tif (tb->ops == ops) {\n\t\t\tlist_del(&tb->list);\n\t\t\tmutex_unlock(&backend_mutex);\n\t\t\t \n\t\t\trcu_barrier();\n\t\t\tkfree(tb);\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&backend_mutex);\n}\nEXPORT_SYMBOL(target_backend_unregister);\n\nstatic struct target_backend *core_get_backend(const char *name)\n{\n\tstruct target_backend *tb;\n\n\tmutex_lock(&backend_mutex);\n\tlist_for_each_entry(tb, &backend_list, list) {\n\t\tif (!strcmp(tb->ops->name, name))\n\t\t\tgoto found;\n\t}\n\tmutex_unlock(&backend_mutex);\n\treturn NULL;\nfound:\n\tif (tb->ops->owner && !try_module_get(tb->ops->owner))\n\t\ttb = NULL;\n\tmutex_unlock(&backend_mutex);\n\treturn tb;\n}\n\nstruct se_hba *\ncore_alloc_hba(const char *plugin_name, u32 plugin_dep_id, u32 hba_flags)\n{\n\tstruct se_hba *hba;\n\tint ret = 0;\n\n\thba = kzalloc(sizeof(*hba), GFP_KERNEL);\n\tif (!hba) {\n\t\tpr_err(\"Unable to allocate struct se_hba\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tspin_lock_init(&hba->device_lock);\n\tmutex_init(&hba->hba_access_mutex);\n\n\thba->hba_index = scsi_get_new_index(SCSI_INST_INDEX);\n\thba->hba_flags |= hba_flags;\n\n\thba->backend = core_get_backend(plugin_name);\n\tif (!hba->backend) {\n\t\tret = -EINVAL;\n\t\tgoto out_free_hba;\n\t}\n\n\tret = hba->backend->ops->attach_hba(hba, plugin_dep_id);\n\tif (ret < 0)\n\t\tgoto out_module_put;\n\n\tspin_lock(&hba_lock);\n\thba->hba_id = hba_id_counter++;\n\tlist_add_tail(&hba->hba_node, &hba_list);\n\tspin_unlock(&hba_lock);\n\n\tpr_debug(\"CORE_HBA[%d] - Attached HBA to Generic Target\"\n\t\t\t\" Core\\n\", hba->hba_id);\n\n\treturn hba;\n\nout_module_put:\n\tmodule_put(hba->backend->ops->owner);\n\thba->backend = NULL;\nout_free_hba:\n\tkfree(hba);\n\treturn ERR_PTR(ret);\n}\n\nint\ncore_delete_hba(struct se_hba *hba)\n{\n\tWARN_ON(hba->dev_count);\n\n\thba->backend->ops->detach_hba(hba);\n\n\tspin_lock(&hba_lock);\n\tlist_del(&hba->hba_node);\n\tspin_unlock(&hba_lock);\n\n\tpr_debug(\"CORE_HBA[%d] - Detached HBA from Generic Target\"\n\t\t\t\" Core\\n\", hba->hba_id);\n\n\tmodule_put(hba->backend->ops->owner);\n\n\thba->backend = NULL;\n\tkfree(hba);\n\treturn 0;\n}\n\nbool target_sense_desc_format(struct se_device *dev)\n{\n\treturn (dev) ? dev->transport->get_blocks(dev) > U32_MAX : false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}