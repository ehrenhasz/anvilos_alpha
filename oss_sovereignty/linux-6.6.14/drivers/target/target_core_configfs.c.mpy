{
  "module_name": "target_core_configfs.c",
  "hash_id": "7687ff3803a6e11cfbea2eaba59824a7cbc008faff52eb07e37d4e2f39e42047",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_configfs.c",
  "human_readable_source": "\n \n\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <generated/utsrelease.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/unistd.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/syscalls.h>\n#include <linux/configfs.h>\n#include <linux/spinlock.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n#include <target/target_core_fabric.h>\n\n#include \"target_core_internal.h\"\n#include \"target_core_alua.h\"\n#include \"target_core_pr.h\"\n#include \"target_core_rd.h\"\n#include \"target_core_xcopy.h\"\n\n#define TB_CIT_SETUP(_name, _item_ops, _group_ops, _attrs)\t\t\\\nstatic void target_core_setup_##_name##_cit(struct target_backend *tb)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_item_type *cit = &tb->tb_##_name##_cit;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tcit->ct_item_ops = _item_ops;\t\t\t\t\t\\\n\tcit->ct_group_ops = _group_ops;\t\t\t\t\t\\\n\tcit->ct_attrs = _attrs;\t\t\t\t\t\t\\\n\tcit->ct_owner = tb->ops->owner;\t\t\t\t\t\\\n\tpr_debug(\"Setup generic %s\\n\", __stringify(_name));\t\t\\\n}\n\n#define TB_CIT_SETUP_DRV(_name, _item_ops, _group_ops)\t\t\t\\\nstatic void target_core_setup_##_name##_cit(struct target_backend *tb)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_item_type *cit = &tb->tb_##_name##_cit;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tcit->ct_item_ops = _item_ops;\t\t\t\t\t\\\n\tcit->ct_group_ops = _group_ops;\t\t\t\t\t\\\n\tcit->ct_attrs = tb->ops->tb_##_name##_attrs;\t\t\t\\\n\tcit->ct_owner = tb->ops->owner;\t\t\t\t\t\\\n\tpr_debug(\"Setup generic %s\\n\", __stringify(_name));\t\t\\\n}\n\nextern struct t10_alua_lu_gp *default_lu_gp;\n\nstatic LIST_HEAD(g_tf_list);\nstatic DEFINE_MUTEX(g_tf_lock);\n\nstatic struct config_group target_core_hbagroup;\nstatic struct config_group alua_group;\nstatic struct config_group alua_lu_gps_group;\n\nstatic unsigned int target_devices;\nstatic DEFINE_MUTEX(target_devices_lock);\n\nstatic inline struct se_hba *\nitem_to_hba(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_hba, hba_group);\n}\n\n \nstatic ssize_t target_core_item_version_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page, \"Target Engine Core ConfigFS Infrastructure %s\"\n\t\t\" on %s/%s on \"UTS_RELEASE\"\\n\", TARGET_CORE_VERSION,\n\t\tutsname()->sysname, utsname()->machine);\n}\n\nCONFIGFS_ATTR_RO(target_core_item_, version);\n\nchar db_root[DB_ROOT_LEN] = DB_ROOT_DEFAULT;\nstatic char db_root_stage[DB_ROOT_LEN];\n\nstatic ssize_t target_core_item_dbroot_show(struct config_item *item,\n\t\t\t\t\t    char *page)\n{\n\treturn sprintf(page, \"%s\\n\", db_root);\n}\n\nstatic ssize_t target_core_item_dbroot_store(struct config_item *item,\n\t\t\t\t\tconst char *page, size_t count)\n{\n\tssize_t read_bytes;\n\tstruct file *fp;\n\tssize_t r = -EINVAL;\n\n\tmutex_lock(&target_devices_lock);\n\tif (target_devices) {\n\t\tpr_err(\"db_root: cannot be changed because it's in use\\n\");\n\t\tgoto unlock;\n\t}\n\n\tif (count > (DB_ROOT_LEN - 1)) {\n\t\tpr_err(\"db_root: count %d exceeds DB_ROOT_LEN-1: %u\\n\",\n\t\t       (int)count, DB_ROOT_LEN - 1);\n\t\tgoto unlock;\n\t}\n\n\tread_bytes = snprintf(db_root_stage, DB_ROOT_LEN, \"%s\", page);\n\tif (!read_bytes)\n\t\tgoto unlock;\n\n\tif (db_root_stage[read_bytes - 1] == '\\n')\n\t\tdb_root_stage[read_bytes - 1] = '\\0';\n\n\t \n\tfp = filp_open(db_root_stage, O_RDONLY, 0);\n\tif (IS_ERR(fp)) {\n\t\tpr_err(\"db_root: cannot open: %s\\n\", db_root_stage);\n\t\tgoto unlock;\n\t}\n\tif (!S_ISDIR(file_inode(fp)->i_mode)) {\n\t\tfilp_close(fp, NULL);\n\t\tpr_err(\"db_root: not a directory: %s\\n\", db_root_stage);\n\t\tgoto unlock;\n\t}\n\tfilp_close(fp, NULL);\n\n\tstrncpy(db_root, db_root_stage, read_bytes);\n\tpr_debug(\"Target_Core_ConfigFS: db_root set to %s\\n\", db_root);\n\n\tr = read_bytes;\n\nunlock:\n\tmutex_unlock(&target_devices_lock);\n\treturn r;\n}\n\nCONFIGFS_ATTR(target_core_item_, dbroot);\n\nstatic struct target_fabric_configfs *target_core_get_fabric(\n\tconst char *name)\n{\n\tstruct target_fabric_configfs *tf;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tmutex_lock(&g_tf_lock);\n\tlist_for_each_entry(tf, &g_tf_list, tf_list) {\n\t\tconst char *cmp_name = tf->tf_ops->fabric_alias;\n\t\tif (!cmp_name)\n\t\t\tcmp_name = tf->tf_ops->fabric_name;\n\t\tif (!strcmp(cmp_name, name)) {\n\t\t\tatomic_inc(&tf->tf_access_cnt);\n\t\t\tmutex_unlock(&g_tf_lock);\n\t\t\treturn tf;\n\t\t}\n\t}\n\tmutex_unlock(&g_tf_lock);\n\n\treturn NULL;\n}\n\n \nstatic struct config_group *target_core_register_fabric(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct target_fabric_configfs *tf;\n\tint ret;\n\n\tpr_debug(\"Target_Core_ConfigFS: REGISTER -> group: %p name:\"\n\t\t\t\" %s\\n\", group, name);\n\n\ttf = target_core_get_fabric(name);\n\tif (!tf) {\n\t\tpr_debug(\"target_core_register_fabric() trying autoload for %s\\n\",\n\t\t\t name);\n\n\t\t \n\n\t\tif (!strncmp(name, \"iscsi\", 5)) {\n\t\t\t \n\t\t\tret = request_module(\"iscsi_target_mod\");\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_debug(\"request_module() failed for\"\n\t\t\t\t         \" iscsi_target_mod.ko: %d\\n\", ret);\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t} else if (!strncmp(name, \"loopback\", 8)) {\n\t\t\t \n\t\t\tret = request_module(\"tcm_loop\");\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_debug(\"request_module() failed for\"\n\t\t\t\t         \" tcm_loop.ko: %d\\n\", ret);\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t}\n\n\t\ttf = target_core_get_fabric(name);\n\t}\n\n\tif (!tf) {\n\t\tpr_debug(\"target_core_get_fabric() failed for %s\\n\",\n\t\t         name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tpr_debug(\"Target_Core_ConfigFS: REGISTER -> Located fabric:\"\n\t\t\t\" %s\\n\", tf->tf_ops->fabric_name);\n\t \n\tpr_debug(\"Target_Core_ConfigFS: REGISTER tfc_wwn_cit -> %p\\n\",\n\t\t\t&tf->tf_wwn_cit);\n\n\tconfig_group_init_type_name(&tf->tf_group, name, &tf->tf_wwn_cit);\n\n\tconfig_group_init_type_name(&tf->tf_disc_group, \"discovery_auth\",\n\t\t\t&tf->tf_discovery_cit);\n\tconfigfs_add_default_group(&tf->tf_disc_group, &tf->tf_group);\n\n\tpr_debug(\"Target_Core_ConfigFS: REGISTER -> Allocated Fabric: %s\\n\",\n\t\t config_item_name(&tf->tf_group.cg_item));\n\treturn &tf->tf_group;\n}\n\n \nstatic void target_core_deregister_fabric(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\tstruct target_fabric_configfs *tf = container_of(\n\t\tto_config_group(item), struct target_fabric_configfs, tf_group);\n\n\tpr_debug(\"Target_Core_ConfigFS: DEREGISTER -> Looking up %s in\"\n\t\t\" tf list\\n\", config_item_name(item));\n\n\tpr_debug(\"Target_Core_ConfigFS: DEREGISTER -> located fabric:\"\n\t\t\t\" %s\\n\", tf->tf_ops->fabric_name);\n\tatomic_dec(&tf->tf_access_cnt);\n\n\tpr_debug(\"Target_Core_ConfigFS: DEREGISTER -> Releasing ci\"\n\t\t\t\" %s\\n\", config_item_name(item));\n\n\tconfigfs_remove_default_groups(&tf->tf_group);\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations target_core_fabric_group_ops = {\n\t.make_group\t= &target_core_register_fabric,\n\t.drop_item\t= &target_core_deregister_fabric,\n};\n\n \nstatic struct configfs_attribute *target_core_fabric_item_attrs[] = {\n\t&target_core_item_attr_version,\n\t&target_core_item_attr_dbroot,\n\tNULL,\n};\n\n \nstatic const struct config_item_type target_core_fabrics_item = {\n\t.ct_group_ops\t= &target_core_fabric_group_ops,\n\t.ct_attrs\t= target_core_fabric_item_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct configfs_subsystem target_core_fabrics = {\n\t.su_group = {\n\t\t.cg_item = {\n\t\t\t.ci_namebuf = \"target\",\n\t\t\t.ci_type = &target_core_fabrics_item,\n\t\t},\n\t},\n};\n\nint target_depend_item(struct config_item *item)\n{\n\treturn configfs_depend_item(&target_core_fabrics, item);\n}\nEXPORT_SYMBOL(target_depend_item);\n\nvoid target_undepend_item(struct config_item *item)\n{\n\treturn configfs_undepend_item(item);\n}\nEXPORT_SYMBOL(target_undepend_item);\n\n \n\tif (!tfo->fabric_make_wwn) {\n\t\tpr_err(\"Missing tfo->fabric_make_wwn()\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!tfo->fabric_drop_wwn) {\n\t\tpr_err(\"Missing tfo->fabric_drop_wwn()\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!tfo->fabric_make_tpg) {\n\t\tpr_err(\"Missing tfo->fabric_make_tpg()\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!tfo->fabric_drop_tpg) {\n\t\tpr_err(\"Missing tfo->fabric_drop_tpg()\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void target_set_default_ops(struct target_core_fabric_ops *tfo)\n{\n\tif (!tfo->tpg_check_demo_mode)\n\t\ttfo->tpg_check_demo_mode = target_disable_feature;\n\n\tif (!tfo->tpg_check_demo_mode_cache)\n\t\ttfo->tpg_check_demo_mode_cache = target_disable_feature;\n\n\tif (!tfo->tpg_check_demo_mode_write_protect)\n\t\ttfo->tpg_check_demo_mode_write_protect = target_disable_feature;\n\n\tif (!tfo->tpg_check_prod_mode_write_protect)\n\t\ttfo->tpg_check_prod_mode_write_protect = target_disable_feature;\n\n\tif (!tfo->tpg_get_inst_index)\n\t\ttfo->tpg_get_inst_index = target_default_get_inst_index;\n\n\tif (!tfo->sess_get_index)\n\t\ttfo->sess_get_index = target_default_sess_get_index;\n\n\tif (!tfo->set_default_node_attributes)\n\t\ttfo->set_default_node_attributes = target_set_default_node_attributes;\n\n\tif (!tfo->get_cmd_state)\n\t\ttfo->get_cmd_state = target_default_get_cmd_state;\n}\n\nint target_register_template(const struct target_core_fabric_ops *fo)\n{\n\tstruct target_core_fabric_ops *tfo;\n\tstruct target_fabric_configfs *tf;\n\tint ret;\n\n\tret = target_fabric_tf_ops_check(fo);\n\tif (ret)\n\t\treturn ret;\n\n\ttf = kzalloc(sizeof(struct target_fabric_configfs), GFP_KERNEL);\n\tif (!tf) {\n\t\tpr_err(\"%s: could not allocate memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\ttfo = kzalloc(sizeof(struct target_core_fabric_ops), GFP_KERNEL);\n\tif (!tfo) {\n\t\tkfree(tf);\n\t\tpr_err(\"%s: could not allocate memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(tfo, fo, sizeof(*tfo));\n\ttarget_set_default_ops(tfo);\n\n\tINIT_LIST_HEAD(&tf->tf_list);\n\tatomic_set(&tf->tf_access_cnt, 0);\n\ttf->tf_ops = tfo;\n\ttarget_fabric_setup_cits(tf);\n\n\tmutex_lock(&g_tf_lock);\n\tlist_add_tail(&tf->tf_list, &g_tf_list);\n\tmutex_unlock(&g_tf_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(target_register_template);\n\nvoid target_unregister_template(const struct target_core_fabric_ops *fo)\n{\n\tstruct target_fabric_configfs *t;\n\n\tmutex_lock(&g_tf_lock);\n\tlist_for_each_entry(t, &g_tf_list, tf_list) {\n\t\tif (!strcmp(t->tf_ops->fabric_name, fo->fabric_name)) {\n\t\t\tBUG_ON(atomic_read(&t->tf_access_cnt));\n\t\t\tlist_del(&t->tf_list);\n\t\t\tmutex_unlock(&g_tf_lock);\n\t\t\t \n\t\t\trcu_barrier();\n\t\t\tkfree(t->tf_tpg_base_cit.ct_attrs);\n\t\t\tkfree(t->tf_ops);\n\t\t\tkfree(t);\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&g_tf_lock);\n}\nEXPORT_SYMBOL(target_unregister_template);\n\n \n#define DEF_CONFIGFS_ATTRIB_SHOW(_name)\t\t\t\t\t\\\nstatic ssize_t _name##_show(struct config_item *item, char *page)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn snprintf(page, PAGE_SIZE, \"%u\\n\", to_attrib(item)->_name); \\\n}\n\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_model_alias);\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_dpo);\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_fua_write);\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_fua_read);\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_write_cache);\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_ua_intlck_ctrl);\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_tas);\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_tpu);\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_tpws);\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_caw);\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_3pc);\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_pr);\nDEF_CONFIGFS_ATTRIB_SHOW(pi_prot_type);\nDEF_CONFIGFS_ATTRIB_SHOW(hw_pi_prot_type);\nDEF_CONFIGFS_ATTRIB_SHOW(pi_prot_verify);\nDEF_CONFIGFS_ATTRIB_SHOW(enforce_pr_isids);\nDEF_CONFIGFS_ATTRIB_SHOW(is_nonrot);\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_rest_reord);\nDEF_CONFIGFS_ATTRIB_SHOW(force_pr_aptpl);\nDEF_CONFIGFS_ATTRIB_SHOW(hw_block_size);\nDEF_CONFIGFS_ATTRIB_SHOW(block_size);\nDEF_CONFIGFS_ATTRIB_SHOW(hw_max_sectors);\nDEF_CONFIGFS_ATTRIB_SHOW(optimal_sectors);\nDEF_CONFIGFS_ATTRIB_SHOW(hw_queue_depth);\nDEF_CONFIGFS_ATTRIB_SHOW(queue_depth);\nDEF_CONFIGFS_ATTRIB_SHOW(max_unmap_lba_count);\nDEF_CONFIGFS_ATTRIB_SHOW(max_unmap_block_desc_count);\nDEF_CONFIGFS_ATTRIB_SHOW(unmap_granularity);\nDEF_CONFIGFS_ATTRIB_SHOW(unmap_granularity_alignment);\nDEF_CONFIGFS_ATTRIB_SHOW(unmap_zeroes_data);\nDEF_CONFIGFS_ATTRIB_SHOW(max_write_same_len);\nDEF_CONFIGFS_ATTRIB_SHOW(emulate_rsoc);\n\n#define DEF_CONFIGFS_ATTRIB_STORE_U32(_name)\t\t\t\t\\\nstatic ssize_t _name##_store(struct config_item *item, const char *page,\\\n\t\tsize_t count)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_dev_attrib *da = to_attrib(item);\t\t\t\\\n\tu32 val;\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou32(page, 0, &val);\t\t\t\t\t\\\n\tif (ret < 0)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\tda->_name = val;\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\nDEF_CONFIGFS_ATTRIB_STORE_U32(max_unmap_lba_count);\nDEF_CONFIGFS_ATTRIB_STORE_U32(max_unmap_block_desc_count);\nDEF_CONFIGFS_ATTRIB_STORE_U32(unmap_granularity);\nDEF_CONFIGFS_ATTRIB_STORE_U32(unmap_granularity_alignment);\nDEF_CONFIGFS_ATTRIB_STORE_U32(max_write_same_len);\n\n#define DEF_CONFIGFS_ATTRIB_STORE_BOOL(_name)\t\t\t\t\\\nstatic ssize_t _name##_store(struct config_item *item, const char *page,\t\\\n\t\tsize_t count)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_dev_attrib *da = to_attrib(item);\t\t\t\\\n\tbool flag;\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtobool(page, &flag);\t\t\t\t\t\\\n\tif (ret < 0)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\tda->_name = flag;\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\nDEF_CONFIGFS_ATTRIB_STORE_BOOL(emulate_fua_write);\nDEF_CONFIGFS_ATTRIB_STORE_BOOL(emulate_caw);\nDEF_CONFIGFS_ATTRIB_STORE_BOOL(emulate_3pc);\nDEF_CONFIGFS_ATTRIB_STORE_BOOL(emulate_pr);\nDEF_CONFIGFS_ATTRIB_STORE_BOOL(enforce_pr_isids);\nDEF_CONFIGFS_ATTRIB_STORE_BOOL(is_nonrot);\n\n#define DEF_CONFIGFS_ATTRIB_STORE_STUB(_name)\t\t\t\t\\\nstatic ssize_t _name##_store(struct config_item *item, const char *page,\\\n\t\tsize_t count)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tprintk_once(KERN_WARNING\t\t\t\t\t\\\n\t\t\"ignoring deprecated %s attribute\\n\",\t\t\t\\\n\t\t__stringify(_name));\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\nDEF_CONFIGFS_ATTRIB_STORE_STUB(emulate_dpo);\nDEF_CONFIGFS_ATTRIB_STORE_STUB(emulate_fua_read);\n\nstatic void dev_set_t10_wwn_model_alias(struct se_device *dev)\n{\n\tconst char *configname;\n\n\tconfigname = config_item_name(&dev->dev_group.cg_item);\n\tif (strlen(configname) >= INQUIRY_MODEL_LEN) {\n\t\tpr_warn(\"dev[%p]: Backstore name '%s' is too long for \"\n\t\t\t\"INQUIRY_MODEL, truncating to 15 characters\\n\", dev,\n\t\t\tconfigname);\n\t}\n\t \n\tstrscpy(dev->t10_wwn.model, configname, INQUIRY_MODEL_LEN);\n}\n\nstatic ssize_t emulate_model_alias_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tstruct se_device *dev = da->da_dev;\n\tbool flag;\n\tint ret;\n\n\tif (dev->export_count) {\n\t\tpr_err(\"dev[%p]: Unable to change model alias\"\n\t\t\t\" while export_count is %d\\n\",\n\t\t\tdev, dev->export_count);\n\t\treturn -EINVAL;\n\t}\n\n\tret = kstrtobool(page, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tBUILD_BUG_ON(sizeof(dev->t10_wwn.model) != INQUIRY_MODEL_LEN + 1);\n\tif (flag) {\n\t\tdev_set_t10_wwn_model_alias(dev);\n\t} else {\n\t\tstrscpy(dev->t10_wwn.model, dev->transport->inquiry_prod,\n\t\t\tsizeof(dev->t10_wwn.model));\n\t}\n\tda->emulate_model_alias = flag;\n\treturn count;\n}\n\nstatic ssize_t emulate_write_cache_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tbool flag;\n\tint ret;\n\n\tret = kstrtobool(page, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (flag && da->da_dev->transport->get_write_cache) {\n\t\tpr_err(\"emulate_write_cache not supported for this device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tda->emulate_write_cache = flag;\n\tpr_debug(\"dev[%p]: SE Device WRITE_CACHE_EMULATION flag: %d\\n\",\n\t\t\tda->da_dev, flag);\n\treturn count;\n}\n\nstatic ssize_t emulate_ua_intlck_ctrl_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tu32 val;\n\tint ret;\n\n\tret = kstrtou32(page, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val != TARGET_UA_INTLCK_CTRL_CLEAR\n\t && val != TARGET_UA_INTLCK_CTRL_NO_CLEAR\n\t && val != TARGET_UA_INTLCK_CTRL_ESTABLISH_UA) {\n\t\tpr_err(\"Illegal value %d\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tif (da->da_dev->export_count) {\n\t\tpr_err(\"dev[%p]: Unable to change SE Device\"\n\t\t\t\" UA_INTRLCK_CTRL while export_count is %d\\n\",\n\t\t\tda->da_dev, da->da_dev->export_count);\n\t\treturn -EINVAL;\n\t}\n\tda->emulate_ua_intlck_ctrl = val;\n\tpr_debug(\"dev[%p]: SE Device UA_INTRLCK_CTRL flag: %d\\n\",\n\t\tda->da_dev, val);\n\treturn count;\n}\n\nstatic ssize_t emulate_tas_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tbool flag;\n\tint ret;\n\n\tret = kstrtobool(page, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (da->da_dev->export_count) {\n\t\tpr_err(\"dev[%p]: Unable to change SE Device TAS while\"\n\t\t\t\" export_count is %d\\n\",\n\t\t\tda->da_dev, da->da_dev->export_count);\n\t\treturn -EINVAL;\n\t}\n\tda->emulate_tas = flag;\n\tpr_debug(\"dev[%p]: SE Device TASK_ABORTED status bit: %s\\n\",\n\t\tda->da_dev, flag ? \"Enabled\" : \"Disabled\");\n\n\treturn count;\n}\n\nstatic ssize_t emulate_tpu_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tstruct se_device *dev = da->da_dev;\n\tbool flag;\n\tint ret;\n\n\tret = kstrtobool(page, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (flag && !da->max_unmap_block_desc_count) {\n\t\tif (!dev->transport->configure_unmap ||\n\t\t    !dev->transport->configure_unmap(dev)) {\n\t\t\tpr_err(\"Generic Block Discard not supported\\n\");\n\t\t\treturn -ENOSYS;\n\t\t}\n\t}\n\n\tda->emulate_tpu = flag;\n\tpr_debug(\"dev[%p]: SE Device Thin Provisioning UNMAP bit: %d\\n\",\n\t\tda->da_dev, flag);\n\treturn count;\n}\n\nstatic ssize_t emulate_tpws_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tstruct se_device *dev = da->da_dev;\n\tbool flag;\n\tint ret;\n\n\tret = kstrtobool(page, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (flag && !da->max_unmap_block_desc_count) {\n\t\tif (!dev->transport->configure_unmap ||\n\t\t    !dev->transport->configure_unmap(dev)) {\n\t\t\tpr_err(\"Generic Block Discard not supported\\n\");\n\t\t\treturn -ENOSYS;\n\t\t}\n\t}\n\n\tda->emulate_tpws = flag;\n\tpr_debug(\"dev[%p]: SE Device Thin Provisioning WRITE_SAME: %d\\n\",\n\t\t\t\tda->da_dev, flag);\n\treturn count;\n}\n\nstatic ssize_t pi_prot_type_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tint old_prot = da->pi_prot_type, ret;\n\tstruct se_device *dev = da->da_dev;\n\tu32 flag;\n\n\tret = kstrtou32(page, 0, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (flag != 0 && flag != 1 && flag != 2 && flag != 3) {\n\t\tpr_err(\"Illegal value %d for pi_prot_type\\n\", flag);\n\t\treturn -EINVAL;\n\t}\n\tif (flag == 2) {\n\t\tpr_err(\"DIF TYPE2 protection currently not supported\\n\");\n\t\treturn -ENOSYS;\n\t}\n\tif (da->hw_pi_prot_type) {\n\t\tpr_warn(\"DIF protection enabled on underlying hardware,\"\n\t\t\t\" ignoring\\n\");\n\t\treturn count;\n\t}\n\tif (!dev->transport->init_prot || !dev->transport->free_prot) {\n\t\t \n\t\tif (flag == 0)\n\t\t\treturn count;\n\n\t\tpr_err(\"DIF protection not supported by backend: %s\\n\",\n\t\t       dev->transport->name);\n\t\treturn -ENOSYS;\n\t}\n\tif (!target_dev_configured(dev)) {\n\t\tpr_err(\"DIF protection requires device to be configured\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (dev->export_count) {\n\t\tpr_err(\"dev[%p]: Unable to change SE Device PROT type while\"\n\t\t       \" export_count is %d\\n\", dev, dev->export_count);\n\t\treturn -EINVAL;\n\t}\n\n\tda->pi_prot_type = flag;\n\n\tif (flag && !old_prot) {\n\t\tret = dev->transport->init_prot(dev);\n\t\tif (ret) {\n\t\t\tda->pi_prot_type = old_prot;\n\t\t\tda->pi_prot_verify = (bool) da->pi_prot_type;\n\t\t\treturn ret;\n\t\t}\n\n\t} else if (!flag && old_prot) {\n\t\tdev->transport->free_prot(dev);\n\t}\n\n\tda->pi_prot_verify = (bool) da->pi_prot_type;\n\tpr_debug(\"dev[%p]: SE Device Protection Type: %d\\n\", dev, flag);\n\treturn count;\n}\n\n \nstatic ssize_t pi_prot_format_show(struct config_item *item, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"0\\n\");\n}\n\nstatic ssize_t pi_prot_format_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tstruct se_device *dev = da->da_dev;\n\tbool flag;\n\tint ret;\n\n\tret = kstrtobool(page, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!flag)\n\t\treturn count;\n\n\tif (!dev->transport->format_prot) {\n\t\tpr_err(\"DIF protection format not supported by backend %s\\n\",\n\t\t       dev->transport->name);\n\t\treturn -ENOSYS;\n\t}\n\tif (!target_dev_configured(dev)) {\n\t\tpr_err(\"DIF protection format requires device to be configured\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (dev->export_count) {\n\t\tpr_err(\"dev[%p]: Unable to format SE Device PROT type while\"\n\t\t       \" export_count is %d\\n\", dev, dev->export_count);\n\t\treturn -EINVAL;\n\t}\n\n\tret = dev->transport->format_prot(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_debug(\"dev[%p]: SE Device Protection Format complete\\n\", dev);\n\treturn count;\n}\n\nstatic ssize_t pi_prot_verify_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tbool flag;\n\tint ret;\n\n\tret = kstrtobool(page, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!flag) {\n\t\tda->pi_prot_verify = flag;\n\t\treturn count;\n\t}\n\tif (da->hw_pi_prot_type) {\n\t\tpr_warn(\"DIF protection enabled on underlying hardware,\"\n\t\t\t\" ignoring\\n\");\n\t\treturn count;\n\t}\n\tif (!da->pi_prot_type) {\n\t\tpr_warn(\"DIF protection not supported by backend, ignoring\\n\");\n\t\treturn count;\n\t}\n\tda->pi_prot_verify = flag;\n\n\treturn count;\n}\n\nstatic ssize_t force_pr_aptpl_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tbool flag;\n\tint ret;\n\n\tret = kstrtobool(page, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (da->da_dev->export_count) {\n\t\tpr_err(\"dev[%p]: Unable to set force_pr_aptpl while\"\n\t\t       \" export_count is %d\\n\",\n\t\t       da->da_dev, da->da_dev->export_count);\n\t\treturn -EINVAL;\n\t}\n\n\tda->force_pr_aptpl = flag;\n\tpr_debug(\"dev[%p]: SE Device force_pr_aptpl: %d\\n\", da->da_dev, flag);\n\treturn count;\n}\n\nstatic ssize_t emulate_rest_reord_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tbool flag;\n\tint ret;\n\n\tret = kstrtobool(page, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (flag != 0) {\n\t\tprintk(KERN_ERR \"dev[%p]: SE Device emulation of restricted\"\n\t\t\t\" reordering not implemented\\n\", da->da_dev);\n\t\treturn -ENOSYS;\n\t}\n\tda->emulate_rest_reord = flag;\n\tpr_debug(\"dev[%p]: SE Device emulate_rest_reord: %d\\n\",\n\t\tda->da_dev, flag);\n\treturn count;\n}\n\nstatic ssize_t unmap_zeroes_data_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tstruct se_device *dev = da->da_dev;\n\tbool flag;\n\tint ret;\n\n\tret = kstrtobool(page, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (da->da_dev->export_count) {\n\t\tpr_err(\"dev[%p]: Unable to change SE Device\"\n\t\t       \" unmap_zeroes_data while export_count is %d\\n\",\n\t\t       da->da_dev, da->da_dev->export_count);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (flag && !da->max_unmap_block_desc_count) {\n\t\tif (!dev->transport->configure_unmap ||\n\t\t    !dev->transport->configure_unmap(dev)) {\n\t\t\tpr_err(\"dev[%p]: Thin Provisioning LBPRZ will not be set because max_unmap_block_desc_count is zero\\n\",\n\t\t\t       da->da_dev);\n\t\t\treturn -ENOSYS;\n\t\t}\n\t}\n\tda->unmap_zeroes_data = flag;\n\tpr_debug(\"dev[%p]: SE Device Thin Provisioning LBPRZ bit: %d\\n\",\n\t\t da->da_dev, flag);\n\treturn count;\n}\n\n \nstatic ssize_t queue_depth_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tstruct se_device *dev = da->da_dev;\n\tu32 val;\n\tint ret;\n\n\tret = kstrtou32(page, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dev->export_count) {\n\t\tpr_err(\"dev[%p]: Unable to change SE Device TCQ while\"\n\t\t\t\" export_count is %d\\n\",\n\t\t\tdev, dev->export_count);\n\t\treturn -EINVAL;\n\t}\n\tif (!val) {\n\t\tpr_err(\"dev[%p]: Illegal ZERO value for queue_depth\\n\", dev);\n\t\treturn -EINVAL;\n\t}\n\n\tif (val > dev->dev_attrib.queue_depth) {\n\t\tif (val > dev->dev_attrib.hw_queue_depth) {\n\t\t\tpr_err(\"dev[%p]: Passed queue_depth:\"\n\t\t\t\t\" %u exceeds TCM/SE_Device MAX\"\n\t\t\t\t\" TCQ: %u\\n\", dev, val,\n\t\t\t\tdev->dev_attrib.hw_queue_depth);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tda->queue_depth = dev->queue_depth = val;\n\tpr_debug(\"dev[%p]: SE Device TCQ Depth changed to: %u\\n\", dev, val);\n\treturn count;\n}\n\nstatic ssize_t optimal_sectors_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tu32 val;\n\tint ret;\n\n\tret = kstrtou32(page, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (da->da_dev->export_count) {\n\t\tpr_err(\"dev[%p]: Unable to change SE Device\"\n\t\t\t\" optimal_sectors while export_count is %d\\n\",\n\t\t\tda->da_dev, da->da_dev->export_count);\n\t\treturn -EINVAL;\n\t}\n\tif (val > da->hw_max_sectors) {\n\t\tpr_err(\"dev[%p]: Passed optimal_sectors %u cannot be\"\n\t\t\t\" greater than hw_max_sectors: %u\\n\",\n\t\t\tda->da_dev, val, da->hw_max_sectors);\n\t\treturn -EINVAL;\n\t}\n\n\tda->optimal_sectors = val;\n\tpr_debug(\"dev[%p]: SE Device optimal_sectors changed to %u\\n\",\n\t\t\tda->da_dev, val);\n\treturn count;\n}\n\nstatic ssize_t block_size_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tu32 val;\n\tint ret;\n\n\tret = kstrtou32(page, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (da->da_dev->export_count) {\n\t\tpr_err(\"dev[%p]: Unable to change SE Device block_size\"\n\t\t\t\" while export_count is %d\\n\",\n\t\t\tda->da_dev, da->da_dev->export_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (val != 512 && val != 1024 && val != 2048 && val != 4096) {\n\t\tpr_err(\"dev[%p]: Illegal value for block_device: %u\"\n\t\t\t\" for SE device, must be 512, 1024, 2048 or 4096\\n\",\n\t\t\tda->da_dev, val);\n\t\treturn -EINVAL;\n\t}\n\n\tda->block_size = val;\n\n\tpr_debug(\"dev[%p]: SE Device block_size changed to %u\\n\",\n\t\t\tda->da_dev, val);\n\treturn count;\n}\n\nstatic ssize_t alua_support_show(struct config_item *item, char *page)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tu8 flags = da->da_dev->transport_flags;\n\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\",\n\t\t\tflags & TRANSPORT_FLAG_PASSTHROUGH_ALUA ? 0 : 1);\n}\n\nstatic ssize_t alua_support_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tstruct se_device *dev = da->da_dev;\n\tbool flag, oldflag;\n\tint ret;\n\n\tret = kstrtobool(page, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\n\toldflag = !(dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_ALUA);\n\tif (flag == oldflag)\n\t\treturn count;\n\n\tif (!(dev->transport->transport_flags_changeable &\n\t      TRANSPORT_FLAG_PASSTHROUGH_ALUA)) {\n\t\tpr_err(\"dev[%p]: Unable to change SE Device alua_support:\"\n\t\t\t\" alua_support has fixed value\\n\", dev);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (flag)\n\t\tdev->transport_flags &= ~TRANSPORT_FLAG_PASSTHROUGH_ALUA;\n\telse\n\t\tdev->transport_flags |= TRANSPORT_FLAG_PASSTHROUGH_ALUA;\n\treturn count;\n}\n\nstatic ssize_t pgr_support_show(struct config_item *item, char *page)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tu8 flags = da->da_dev->transport_flags;\n\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\",\n\t\t\tflags & TRANSPORT_FLAG_PASSTHROUGH_PGR ? 0 : 1);\n}\n\nstatic ssize_t pgr_support_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tstruct se_device *dev = da->da_dev;\n\tbool flag, oldflag;\n\tint ret;\n\n\tret = kstrtobool(page, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\n\toldflag = !(dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_PGR);\n\tif (flag == oldflag)\n\t\treturn count;\n\n\tif (!(dev->transport->transport_flags_changeable &\n\t      TRANSPORT_FLAG_PASSTHROUGH_PGR)) {\n\t\tpr_err(\"dev[%p]: Unable to change SE Device pgr_support:\"\n\t\t\t\" pgr_support has fixed value\\n\", dev);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (flag)\n\t\tdev->transport_flags &= ~TRANSPORT_FLAG_PASSTHROUGH_PGR;\n\telse\n\t\tdev->transport_flags |= TRANSPORT_FLAG_PASSTHROUGH_PGR;\n\treturn count;\n}\n\nstatic ssize_t emulate_rsoc_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_dev_attrib *da = to_attrib(item);\n\tbool flag;\n\tint ret;\n\n\tret = kstrtobool(page, &flag);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tda->emulate_rsoc = flag;\n\tpr_debug(\"dev[%p]: SE Device REPORT_SUPPORTED_OPERATION_CODES_EMULATION flag: %d\\n\",\n\t\t\tda->da_dev, flag);\n\treturn count;\n}\n\nCONFIGFS_ATTR(, emulate_model_alias);\nCONFIGFS_ATTR(, emulate_dpo);\nCONFIGFS_ATTR(, emulate_fua_write);\nCONFIGFS_ATTR(, emulate_fua_read);\nCONFIGFS_ATTR(, emulate_write_cache);\nCONFIGFS_ATTR(, emulate_ua_intlck_ctrl);\nCONFIGFS_ATTR(, emulate_tas);\nCONFIGFS_ATTR(, emulate_tpu);\nCONFIGFS_ATTR(, emulate_tpws);\nCONFIGFS_ATTR(, emulate_caw);\nCONFIGFS_ATTR(, emulate_3pc);\nCONFIGFS_ATTR(, emulate_pr);\nCONFIGFS_ATTR(, emulate_rsoc);\nCONFIGFS_ATTR(, pi_prot_type);\nCONFIGFS_ATTR_RO(, hw_pi_prot_type);\nCONFIGFS_ATTR(, pi_prot_format);\nCONFIGFS_ATTR(, pi_prot_verify);\nCONFIGFS_ATTR(, enforce_pr_isids);\nCONFIGFS_ATTR(, is_nonrot);\nCONFIGFS_ATTR(, emulate_rest_reord);\nCONFIGFS_ATTR(, force_pr_aptpl);\nCONFIGFS_ATTR_RO(, hw_block_size);\nCONFIGFS_ATTR(, block_size);\nCONFIGFS_ATTR_RO(, hw_max_sectors);\nCONFIGFS_ATTR(, optimal_sectors);\nCONFIGFS_ATTR_RO(, hw_queue_depth);\nCONFIGFS_ATTR(, queue_depth);\nCONFIGFS_ATTR(, max_unmap_lba_count);\nCONFIGFS_ATTR(, max_unmap_block_desc_count);\nCONFIGFS_ATTR(, unmap_granularity);\nCONFIGFS_ATTR(, unmap_granularity_alignment);\nCONFIGFS_ATTR(, unmap_zeroes_data);\nCONFIGFS_ATTR(, max_write_same_len);\nCONFIGFS_ATTR(, alua_support);\nCONFIGFS_ATTR(, pgr_support);\n\n \nstruct configfs_attribute *sbc_attrib_attrs[] = {\n\t&attr_emulate_model_alias,\n\t&attr_emulate_dpo,\n\t&attr_emulate_fua_write,\n\t&attr_emulate_fua_read,\n\t&attr_emulate_write_cache,\n\t&attr_emulate_ua_intlck_ctrl,\n\t&attr_emulate_tas,\n\t&attr_emulate_tpu,\n\t&attr_emulate_tpws,\n\t&attr_emulate_caw,\n\t&attr_emulate_3pc,\n\t&attr_emulate_pr,\n\t&attr_pi_prot_type,\n\t&attr_hw_pi_prot_type,\n\t&attr_pi_prot_format,\n\t&attr_pi_prot_verify,\n\t&attr_enforce_pr_isids,\n\t&attr_is_nonrot,\n\t&attr_emulate_rest_reord,\n\t&attr_force_pr_aptpl,\n\t&attr_hw_block_size,\n\t&attr_block_size,\n\t&attr_hw_max_sectors,\n\t&attr_optimal_sectors,\n\t&attr_hw_queue_depth,\n\t&attr_queue_depth,\n\t&attr_max_unmap_lba_count,\n\t&attr_max_unmap_block_desc_count,\n\t&attr_unmap_granularity,\n\t&attr_unmap_granularity_alignment,\n\t&attr_unmap_zeroes_data,\n\t&attr_max_write_same_len,\n\t&attr_alua_support,\n\t&attr_pgr_support,\n\t&attr_emulate_rsoc,\n\tNULL,\n};\nEXPORT_SYMBOL(sbc_attrib_attrs);\n\n \nstruct configfs_attribute *passthrough_attrib_attrs[] = {\n\t&attr_hw_pi_prot_type,\n\t&attr_hw_block_size,\n\t&attr_hw_max_sectors,\n\t&attr_hw_queue_depth,\n\t&attr_emulate_pr,\n\t&attr_alua_support,\n\t&attr_pgr_support,\n\tNULL,\n};\nEXPORT_SYMBOL(passthrough_attrib_attrs);\n\n \nstruct configfs_attribute *passthrough_pr_attrib_attrs[] = {\n\t&attr_enforce_pr_isids,\n\t&attr_force_pr_aptpl,\n\tNULL,\n};\nEXPORT_SYMBOL(passthrough_pr_attrib_attrs);\n\nTB_CIT_SETUP_DRV(dev_attrib, NULL, NULL);\nTB_CIT_SETUP_DRV(dev_action, NULL, NULL);\n\n \n\n \n\nstatic struct t10_wwn *to_t10_wwn(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct t10_wwn, t10_wwn_group);\n}\n\nstatic ssize_t target_check_inquiry_data(char *buf)\n{\n\tsize_t len;\n\tint i;\n\n\tlen = strlen(buf);\n\n\t \n\tfor (i = 0; i < len; i++) {\n\t\tif (buf[i] < 0x20 || buf[i] > 0x7E) {\n\t\t\tpr_err(\"Emulated T10 Inquiry Data contains non-ASCII-printable characters\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n \nstatic ssize_t target_wwn_vendor_id_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page, \"%s\\n\", &to_t10_wwn(item)->vendor[0]);\n}\n\nstatic ssize_t target_wwn_vendor_id_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct t10_wwn *t10_wwn = to_t10_wwn(item);\n\tstruct se_device *dev = t10_wwn->t10_dev;\n\t \n\tunsigned char buf[INQUIRY_VENDOR_LEN + 2];\n\tchar *stripped = NULL;\n\tssize_t len;\n\tssize_t ret;\n\n\tlen = strscpy(buf, page, sizeof(buf));\n\tif (len > 0) {\n\t\t \n\t\tstripped = strstrip(buf);\n\t\tlen = strlen(stripped);\n\t}\n\tif (len < 0 || len > INQUIRY_VENDOR_LEN) {\n\t\tpr_err(\"Emulated T10 Vendor Identification exceeds\"\n\t\t\t\" INQUIRY_VENDOR_LEN: \" __stringify(INQUIRY_VENDOR_LEN)\n\t\t\t\"\\n\");\n\t\treturn -EOVERFLOW;\n\t}\n\n\tret = target_check_inquiry_data(stripped);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (dev->export_count) {\n\t\tpr_err(\"Unable to set T10 Vendor Identification while\"\n\t\t\t\" active %d exports exist\\n\", dev->export_count);\n\t\treturn -EINVAL;\n\t}\n\n\tBUILD_BUG_ON(sizeof(dev->t10_wwn.vendor) != INQUIRY_VENDOR_LEN + 1);\n\tstrscpy(dev->t10_wwn.vendor, stripped, sizeof(dev->t10_wwn.vendor));\n\n\tpr_debug(\"Target_Core_ConfigFS: Set emulated T10 Vendor Identification:\"\n\t\t \" %s\\n\", dev->t10_wwn.vendor);\n\n\treturn count;\n}\n\nstatic ssize_t target_wwn_product_id_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page, \"%s\\n\", &to_t10_wwn(item)->model[0]);\n}\n\nstatic ssize_t target_wwn_product_id_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct t10_wwn *t10_wwn = to_t10_wwn(item);\n\tstruct se_device *dev = t10_wwn->t10_dev;\n\t \n\tunsigned char buf[INQUIRY_MODEL_LEN + 2];\n\tchar *stripped = NULL;\n\tssize_t len;\n\tssize_t ret;\n\n\tlen = strscpy(buf, page, sizeof(buf));\n\tif (len > 0) {\n\t\t \n\t\tstripped = strstrip(buf);\n\t\tlen = strlen(stripped);\n\t}\n\tif (len < 0 || len > INQUIRY_MODEL_LEN) {\n\t\tpr_err(\"Emulated T10 Vendor exceeds INQUIRY_MODEL_LEN: \"\n\t\t\t __stringify(INQUIRY_MODEL_LEN)\n\t\t\t\"\\n\");\n\t\treturn -EOVERFLOW;\n\t}\n\n\tret = target_check_inquiry_data(stripped);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (dev->export_count) {\n\t\tpr_err(\"Unable to set T10 Model while active %d exports exist\\n\",\n\t\t\tdev->export_count);\n\t\treturn -EINVAL;\n\t}\n\n\tBUILD_BUG_ON(sizeof(dev->t10_wwn.model) != INQUIRY_MODEL_LEN + 1);\n\tstrscpy(dev->t10_wwn.model, stripped, sizeof(dev->t10_wwn.model));\n\n\tpr_debug(\"Target_Core_ConfigFS: Set emulated T10 Model Identification: %s\\n\",\n\t\t dev->t10_wwn.model);\n\n\treturn count;\n}\n\nstatic ssize_t target_wwn_revision_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page, \"%s\\n\", &to_t10_wwn(item)->revision[0]);\n}\n\nstatic ssize_t target_wwn_revision_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct t10_wwn *t10_wwn = to_t10_wwn(item);\n\tstruct se_device *dev = t10_wwn->t10_dev;\n\t \n\tunsigned char buf[INQUIRY_REVISION_LEN + 2];\n\tchar *stripped = NULL;\n\tssize_t len;\n\tssize_t ret;\n\n\tlen = strscpy(buf, page, sizeof(buf));\n\tif (len > 0) {\n\t\t \n\t\tstripped = strstrip(buf);\n\t\tlen = strlen(stripped);\n\t}\n\tif (len < 0 || len > INQUIRY_REVISION_LEN) {\n\t\tpr_err(\"Emulated T10 Revision exceeds INQUIRY_REVISION_LEN: \"\n\t\t\t __stringify(INQUIRY_REVISION_LEN)\n\t\t\t\"\\n\");\n\t\treturn -EOVERFLOW;\n\t}\n\n\tret = target_check_inquiry_data(stripped);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (dev->export_count) {\n\t\tpr_err(\"Unable to set T10 Revision while active %d exports exist\\n\",\n\t\t\tdev->export_count);\n\t\treturn -EINVAL;\n\t}\n\n\tBUILD_BUG_ON(sizeof(dev->t10_wwn.revision) != INQUIRY_REVISION_LEN + 1);\n\tstrscpy(dev->t10_wwn.revision, stripped, sizeof(dev->t10_wwn.revision));\n\n\tpr_debug(\"Target_Core_ConfigFS: Set emulated T10 Revision: %s\\n\",\n\t\t dev->t10_wwn.revision);\n\n\treturn count;\n}\n\nstatic ssize_t\ntarget_wwn_company_id_show(struct config_item *item,\n\t\t\t\tchar *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%#08x\\n\",\n\t\t\tto_t10_wwn(item)->company_id);\n}\n\nstatic ssize_t\ntarget_wwn_company_id_store(struct config_item *item,\n\t\t\t\t const char *page, size_t count)\n{\n\tstruct t10_wwn *t10_wwn = to_t10_wwn(item);\n\tstruct se_device *dev = t10_wwn->t10_dev;\n\tu32 val;\n\tint ret;\n\n\t \n\tret = kstrtou32(page, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val >= 0x1000000)\n\t\treturn -EOVERFLOW;\n\n\t \n\tif (dev->export_count) {\n\t\tpr_err(\"Unable to set Company ID while %u exports exist\\n\",\n\t\t       dev->export_count);\n\t\treturn -EINVAL;\n\t}\n\n\tt10_wwn->company_id = val;\n\n\tpr_debug(\"Target_Core_ConfigFS: Set IEEE Company ID: %#08x\\n\",\n\t\t t10_wwn->company_id);\n\n\treturn count;\n}\n\n \nstatic ssize_t target_wwn_vpd_unit_serial_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page, \"T10 VPD Unit Serial Number: %s\\n\",\n\t\t&to_t10_wwn(item)->unit_serial[0]);\n}\n\nstatic ssize_t target_wwn_vpd_unit_serial_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct t10_wwn *t10_wwn = to_t10_wwn(item);\n\tstruct se_device *dev = t10_wwn->t10_dev;\n\tunsigned char buf[INQUIRY_VPD_SERIAL_LEN] = { };\n\n\t \n\tif (dev->dev_flags & DF_FIRMWARE_VPD_UNIT_SERIAL) {\n\t\tpr_err(\"Underlying SCSI device firmware provided VPD\"\n\t\t\t\" Unit Serial, ignoring request\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (strlen(page) >= INQUIRY_VPD_SERIAL_LEN) {\n\t\tpr_err(\"Emulated VPD Unit Serial exceeds\"\n\t\t\" INQUIRY_VPD_SERIAL_LEN: %d\\n\", INQUIRY_VPD_SERIAL_LEN);\n\t\treturn -EOVERFLOW;\n\t}\n\t \n\tif (dev->export_count) {\n\t\tpr_err(\"Unable to set VPD Unit Serial while\"\n\t\t\t\" active %d $FABRIC_MOD exports exist\\n\",\n\t\t\tdev->export_count);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnprintf(buf, INQUIRY_VPD_SERIAL_LEN, \"%s\", page);\n\tsnprintf(dev->t10_wwn.unit_serial, INQUIRY_VPD_SERIAL_LEN,\n\t\t\t\"%s\", strstrip(buf));\n\tdev->dev_flags |= DF_EMULATED_VPD_UNIT_SERIAL;\n\n\tpr_debug(\"Target_Core_ConfigFS: Set emulated VPD Unit Serial:\"\n\t\t\t\" %s\\n\", dev->t10_wwn.unit_serial);\n\n\treturn count;\n}\n\n \nstatic ssize_t target_wwn_vpd_protocol_identifier_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct t10_wwn *t10_wwn = to_t10_wwn(item);\n\tstruct t10_vpd *vpd;\n\tunsigned char buf[VPD_TMP_BUF_SIZE] = { };\n\tssize_t len = 0;\n\n\tspin_lock(&t10_wwn->t10_vpd_lock);\n\tlist_for_each_entry(vpd, &t10_wwn->t10_vpd_list, vpd_list) {\n\t\tif (!vpd->protocol_identifier_set)\n\t\t\tcontinue;\n\n\t\ttransport_dump_vpd_proto_id(vpd, buf, VPD_TMP_BUF_SIZE);\n\n\t\tif (len + strlen(buf) >= PAGE_SIZE)\n\t\t\tbreak;\n\n\t\tlen += sprintf(page+len, \"%s\", buf);\n\t}\n\tspin_unlock(&t10_wwn->t10_vpd_lock);\n\n\treturn len;\n}\n\n \n#define DEF_DEV_WWN_ASSOC_SHOW(_name, _assoc)\t\t\t\t\\\nstatic ssize_t target_wwn_##_name##_show(struct config_item *item,\t\\\n\t\tchar *page)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct t10_wwn *t10_wwn = to_t10_wwn(item);\t\t\t\\\n\tstruct t10_vpd *vpd;\t\t\t\t\t\t\\\n\tunsigned char buf[VPD_TMP_BUF_SIZE];\t\t\t\t\\\n\tssize_t len = 0;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tspin_lock(&t10_wwn->t10_vpd_lock);\t\t\t\t\\\n\tlist_for_each_entry(vpd, &t10_wwn->t10_vpd_list, vpd_list) {\t\\\n\t\tif (vpd->association != _assoc)\t\t\t\t\\\n\t\t\tcontinue;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tmemset(buf, 0, VPD_TMP_BUF_SIZE);\t\t\t\\\n\t\ttransport_dump_vpd_assoc(vpd, buf, VPD_TMP_BUF_SIZE);\t\\\n\t\tif (len + strlen(buf) >= PAGE_SIZE)\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tlen += sprintf(page+len, \"%s\", buf);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tmemset(buf, 0, VPD_TMP_BUF_SIZE);\t\t\t\\\n\t\ttransport_dump_vpd_ident_type(vpd, buf, VPD_TMP_BUF_SIZE); \\\n\t\tif (len + strlen(buf) >= PAGE_SIZE)\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tlen += sprintf(page+len, \"%s\", buf);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tmemset(buf, 0, VPD_TMP_BUF_SIZE);\t\t\t\\\n\t\ttransport_dump_vpd_ident(vpd, buf, VPD_TMP_BUF_SIZE); \\\n\t\tif (len + strlen(buf) >= PAGE_SIZE)\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tlen += sprintf(page+len, \"%s\", buf);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tspin_unlock(&t10_wwn->t10_vpd_lock);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn len;\t\t\t\t\t\t\t\\\n}\n\n \nDEF_DEV_WWN_ASSOC_SHOW(vpd_assoc_logical_unit, 0x00);\n \nDEF_DEV_WWN_ASSOC_SHOW(vpd_assoc_target_port, 0x10);\n \nDEF_DEV_WWN_ASSOC_SHOW(vpd_assoc_scsi_target_device, 0x20);\n\nCONFIGFS_ATTR(target_wwn_, vendor_id);\nCONFIGFS_ATTR(target_wwn_, product_id);\nCONFIGFS_ATTR(target_wwn_, revision);\nCONFIGFS_ATTR(target_wwn_, company_id);\nCONFIGFS_ATTR(target_wwn_, vpd_unit_serial);\nCONFIGFS_ATTR_RO(target_wwn_, vpd_protocol_identifier);\nCONFIGFS_ATTR_RO(target_wwn_, vpd_assoc_logical_unit);\nCONFIGFS_ATTR_RO(target_wwn_, vpd_assoc_target_port);\nCONFIGFS_ATTR_RO(target_wwn_, vpd_assoc_scsi_target_device);\n\nstatic struct configfs_attribute *target_core_dev_wwn_attrs[] = {\n\t&target_wwn_attr_vendor_id,\n\t&target_wwn_attr_product_id,\n\t&target_wwn_attr_revision,\n\t&target_wwn_attr_company_id,\n\t&target_wwn_attr_vpd_unit_serial,\n\t&target_wwn_attr_vpd_protocol_identifier,\n\t&target_wwn_attr_vpd_assoc_logical_unit,\n\t&target_wwn_attr_vpd_assoc_target_port,\n\t&target_wwn_attr_vpd_assoc_scsi_target_device,\n\tNULL,\n};\n\nTB_CIT_SETUP(dev_wwn, NULL, NULL, target_core_dev_wwn_attrs);\n\n \n\n \n\nstatic struct se_device *pr_to_dev(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_device,\n\t\t\tdev_pr_group);\n}\n\nstatic ssize_t target_core_dev_pr_show_spc3_res(struct se_device *dev,\n\t\tchar *page)\n{\n\tstruct se_node_acl *se_nacl;\n\tstruct t10_pr_registration *pr_reg;\n\tchar i_buf[PR_REG_ISID_ID_LEN] = { };\n\n\tpr_reg = dev->dev_pr_res_holder;\n\tif (!pr_reg)\n\t\treturn sprintf(page, \"No SPC-3 Reservation holder\\n\");\n\n\tse_nacl = pr_reg->pr_reg_nacl;\n\tcore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\n\n\treturn sprintf(page, \"SPC-3 Reservation: %s Initiator: %s%s\\n\",\n\t\tse_nacl->se_tpg->se_tpg_tfo->fabric_name,\n\t\tse_nacl->initiatorname, i_buf);\n}\n\nstatic ssize_t target_core_dev_pr_show_spc2_res(struct se_device *dev,\n\t\tchar *page)\n{\n\tstruct se_session *sess = dev->reservation_holder;\n\tstruct se_node_acl *se_nacl;\n\tssize_t len;\n\n\tif (sess) {\n\t\tse_nacl = sess->se_node_acl;\n\t\tlen = sprintf(page,\n\t\t\t      \"SPC-2 Reservation: %s Initiator: %s\\n\",\n\t\t\t      se_nacl->se_tpg->se_tpg_tfo->fabric_name,\n\t\t\t      se_nacl->initiatorname);\n\t} else {\n\t\tlen = sprintf(page, \"No SPC-2 Reservation holder\\n\");\n\t}\n\treturn len;\n}\n\nstatic ssize_t target_pr_res_holder_show(struct config_item *item, char *page)\n{\n\tstruct se_device *dev = pr_to_dev(item);\n\tint ret;\n\n\tif (!dev->dev_attrib.emulate_pr)\n\t\treturn sprintf(page, \"SPC_RESERVATIONS_DISABLED\\n\");\n\n\tif (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_PGR)\n\t\treturn sprintf(page, \"Passthrough\\n\");\n\n\tspin_lock(&dev->dev_reservation_lock);\n\tif (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS)\n\t\tret = target_core_dev_pr_show_spc2_res(dev, page);\n\telse\n\t\tret = target_core_dev_pr_show_spc3_res(dev, page);\n\tspin_unlock(&dev->dev_reservation_lock);\n\treturn ret;\n}\n\nstatic ssize_t target_pr_res_pr_all_tgt_pts_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct se_device *dev = pr_to_dev(item);\n\tssize_t len = 0;\n\n\tspin_lock(&dev->dev_reservation_lock);\n\tif (!dev->dev_pr_res_holder) {\n\t\tlen = sprintf(page, \"No SPC-3 Reservation holder\\n\");\n\t} else if (dev->dev_pr_res_holder->pr_reg_all_tg_pt) {\n\t\tlen = sprintf(page, \"SPC-3 Reservation: All Target\"\n\t\t\t\" Ports registration\\n\");\n\t} else {\n\t\tlen = sprintf(page, \"SPC-3 Reservation: Single\"\n\t\t\t\" Target Port registration\\n\");\n\t}\n\n\tspin_unlock(&dev->dev_reservation_lock);\n\treturn len;\n}\n\nstatic ssize_t target_pr_res_pr_generation_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page, \"0x%08x\\n\", pr_to_dev(item)->t10_pr.pr_generation);\n}\n\n\nstatic ssize_t target_pr_res_pr_holder_tg_port_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct se_device *dev = pr_to_dev(item);\n\tstruct se_node_acl *se_nacl;\n\tstruct se_portal_group *se_tpg;\n\tstruct t10_pr_registration *pr_reg;\n\tconst struct target_core_fabric_ops *tfo;\n\tssize_t len = 0;\n\n\tspin_lock(&dev->dev_reservation_lock);\n\tpr_reg = dev->dev_pr_res_holder;\n\tif (!pr_reg) {\n\t\tlen = sprintf(page, \"No SPC-3 Reservation holder\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tse_nacl = pr_reg->pr_reg_nacl;\n\tse_tpg = se_nacl->se_tpg;\n\ttfo = se_tpg->se_tpg_tfo;\n\n\tlen += sprintf(page+len, \"SPC-3 Reservation: %s\"\n\t\t\" Target Node Endpoint: %s\\n\", tfo->fabric_name,\n\t\ttfo->tpg_get_wwn(se_tpg));\n\tlen += sprintf(page+len, \"SPC-3 Reservation: Relative Port\"\n\t\t\" Identifier Tag: %hu %s Portal Group Tag: %hu\"\n\t\t\" %s Logical Unit: %llu\\n\", pr_reg->tg_pt_sep_rtpi,\n\t\ttfo->fabric_name, tfo->tpg_get_tag(se_tpg),\n\t\ttfo->fabric_name, pr_reg->pr_aptpl_target_lun);\n\nout_unlock:\n\tspin_unlock(&dev->dev_reservation_lock);\n\treturn len;\n}\n\n\nstatic ssize_t target_pr_res_pr_registered_i_pts_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct se_device *dev = pr_to_dev(item);\n\tconst struct target_core_fabric_ops *tfo;\n\tstruct t10_pr_registration *pr_reg;\n\tunsigned char buf[384];\n\tchar i_buf[PR_REG_ISID_ID_LEN];\n\tssize_t len = 0;\n\tint reg_count = 0;\n\n\tlen += sprintf(page+len, \"SPC-3 PR Registrations:\\n\");\n\n\tspin_lock(&dev->t10_pr.registration_lock);\n\tlist_for_each_entry(pr_reg, &dev->t10_pr.registration_list,\n\t\t\tpr_reg_list) {\n\n\t\tmemset(buf, 0, 384);\n\t\tmemset(i_buf, 0, PR_REG_ISID_ID_LEN);\n\t\ttfo = pr_reg->pr_reg_nacl->se_tpg->se_tpg_tfo;\n\t\tcore_pr_dump_initiator_port(pr_reg, i_buf,\n\t\t\t\t\tPR_REG_ISID_ID_LEN);\n\t\tsprintf(buf, \"%s Node: %s%s Key: 0x%016Lx PRgen: 0x%08x\\n\",\n\t\t\ttfo->fabric_name,\n\t\t\tpr_reg->pr_reg_nacl->initiatorname, i_buf, pr_reg->pr_res_key,\n\t\t\tpr_reg->pr_res_generation);\n\n\t\tif (len + strlen(buf) >= PAGE_SIZE)\n\t\t\tbreak;\n\n\t\tlen += sprintf(page+len, \"%s\", buf);\n\t\treg_count++;\n\t}\n\tspin_unlock(&dev->t10_pr.registration_lock);\n\n\tif (!reg_count)\n\t\tlen += sprintf(page+len, \"None\\n\");\n\n\treturn len;\n}\n\nstatic ssize_t target_pr_res_pr_type_show(struct config_item *item, char *page)\n{\n\tstruct se_device *dev = pr_to_dev(item);\n\tstruct t10_pr_registration *pr_reg;\n\tssize_t len = 0;\n\n\tspin_lock(&dev->dev_reservation_lock);\n\tpr_reg = dev->dev_pr_res_holder;\n\tif (pr_reg) {\n\t\tlen = sprintf(page, \"SPC-3 Reservation Type: %s\\n\",\n\t\t\tcore_scsi3_pr_dump_type(pr_reg->pr_res_type));\n\t} else {\n\t\tlen = sprintf(page, \"No SPC-3 Reservation holder\\n\");\n\t}\n\n\tspin_unlock(&dev->dev_reservation_lock);\n\treturn len;\n}\n\nstatic ssize_t target_pr_res_type_show(struct config_item *item, char *page)\n{\n\tstruct se_device *dev = pr_to_dev(item);\n\n\tif (!dev->dev_attrib.emulate_pr)\n\t\treturn sprintf(page, \"SPC_RESERVATIONS_DISABLED\\n\");\n\tif (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_PGR)\n\t\treturn sprintf(page, \"SPC_PASSTHROUGH\\n\");\n\tif (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS)\n\t\treturn sprintf(page, \"SPC2_RESERVATIONS\\n\");\n\n\treturn sprintf(page, \"SPC3_PERSISTENT_RESERVATIONS\\n\");\n}\n\nstatic ssize_t target_pr_res_aptpl_active_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct se_device *dev = pr_to_dev(item);\n\n\tif (!dev->dev_attrib.emulate_pr ||\n\t    (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_PGR))\n\t\treturn 0;\n\n\treturn sprintf(page, \"APTPL Bit Status: %s\\n\",\n\t\t(dev->t10_pr.pr_aptpl_active) ? \"Activated\" : \"Disabled\");\n}\n\nstatic ssize_t target_pr_res_aptpl_metadata_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct se_device *dev = pr_to_dev(item);\n\n\tif (!dev->dev_attrib.emulate_pr ||\n\t    (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_PGR))\n\t\treturn 0;\n\n\treturn sprintf(page, \"Ready to process PR APTPL metadata..\\n\");\n}\n\nenum {\n\tOpt_initiator_fabric, Opt_initiator_node, Opt_initiator_sid,\n\tOpt_sa_res_key, Opt_res_holder, Opt_res_type, Opt_res_scope,\n\tOpt_res_all_tg_pt, Opt_mapped_lun, Opt_target_fabric,\n\tOpt_target_node, Opt_tpgt, Opt_port_rtpi, Opt_target_lun, Opt_err\n};\n\nstatic match_table_t tokens = {\n\t{Opt_initiator_fabric, \"initiator_fabric=%s\"},\n\t{Opt_initiator_node, \"initiator_node=%s\"},\n\t{Opt_initiator_sid, \"initiator_sid=%s\"},\n\t{Opt_sa_res_key, \"sa_res_key=%s\"},\n\t{Opt_res_holder, \"res_holder=%d\"},\n\t{Opt_res_type, \"res_type=%d\"},\n\t{Opt_res_scope, \"res_scope=%d\"},\n\t{Opt_res_all_tg_pt, \"res_all_tg_pt=%d\"},\n\t{Opt_mapped_lun, \"mapped_lun=%u\"},\n\t{Opt_target_fabric, \"target_fabric=%s\"},\n\t{Opt_target_node, \"target_node=%s\"},\n\t{Opt_tpgt, \"tpgt=%d\"},\n\t{Opt_port_rtpi, \"port_rtpi=%d\"},\n\t{Opt_target_lun, \"target_lun=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic ssize_t target_pr_res_aptpl_metadata_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_device *dev = pr_to_dev(item);\n\tunsigned char *i_fabric = NULL, *i_port = NULL, *isid = NULL;\n\tunsigned char *t_fabric = NULL, *t_port = NULL;\n\tchar *orig, *ptr, *opts;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tunsigned long long tmp_ll;\n\tu64 sa_res_key = 0;\n\tu64 mapped_lun = 0, target_lun = 0;\n\tint ret = -1, res_holder = 0, all_tg_pt = 0, arg, token;\n\tu16 tpgt = 0;\n\tu8 type = 0;\n\n\tif (!dev->dev_attrib.emulate_pr ||\n\t    (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_PGR))\n\t\treturn count;\n\tif (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS)\n\t\treturn count;\n\n\tif (dev->export_count) {\n\t\tpr_debug(\"Unable to process APTPL metadata while\"\n\t\t\t\" active fabric exports exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\topts = kstrdup(page, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\n\torig = opts;\n\twhile ((ptr = strsep(&opts, \",\\n\")) != NULL) {\n\t\tif (!*ptr)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(ptr, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_initiator_fabric:\n\t\t\ti_fabric = match_strdup(args);\n\t\t\tif (!i_fabric) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_initiator_node:\n\t\t\ti_port = match_strdup(args);\n\t\t\tif (!i_port) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strlen(i_port) >= PR_APTPL_MAX_IPORT_LEN) {\n\t\t\t\tpr_err(\"APTPL metadata initiator_node=\"\n\t\t\t\t\t\" exceeds PR_APTPL_MAX_IPORT_LEN: %d\\n\",\n\t\t\t\t\tPR_APTPL_MAX_IPORT_LEN);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_initiator_sid:\n\t\t\tisid = match_strdup(args);\n\t\t\tif (!isid) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strlen(isid) >= PR_REG_ISID_LEN) {\n\t\t\t\tpr_err(\"APTPL metadata initiator_isid\"\n\t\t\t\t\t\"= exceeds PR_REG_ISID_LEN: %d\\n\",\n\t\t\t\t\tPR_REG_ISID_LEN);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_sa_res_key:\n\t\t\tret = match_u64(args,  &tmp_ll);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"kstrtoull() failed for sa_res_key=\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsa_res_key = (u64)tmp_ll;\n\t\t\tbreak;\n\t\t \n\t\tcase Opt_res_holder:\n\t\t\tret = match_int(args, &arg);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tres_holder = arg;\n\t\t\tbreak;\n\t\tcase Opt_res_type:\n\t\t\tret = match_int(args, &arg);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\ttype = (u8)arg;\n\t\t\tbreak;\n\t\tcase Opt_res_scope:\n\t\t\tret = match_int(args, &arg);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase Opt_res_all_tg_pt:\n\t\t\tret = match_int(args, &arg);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tall_tg_pt = (int)arg;\n\t\t\tbreak;\n\t\tcase Opt_mapped_lun:\n\t\t\tret = match_u64(args, &tmp_ll);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tmapped_lun = (u64)tmp_ll;\n\t\t\tbreak;\n\t\t \n\t\tcase Opt_target_fabric:\n\t\t\tt_fabric = match_strdup(args);\n\t\t\tif (!t_fabric) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_target_node:\n\t\t\tt_port = match_strdup(args);\n\t\t\tif (!t_port) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strlen(t_port) >= PR_APTPL_MAX_TPORT_LEN) {\n\t\t\t\tpr_err(\"APTPL metadata target_node=\"\n\t\t\t\t\t\" exceeds PR_APTPL_MAX_TPORT_LEN: %d\\n\",\n\t\t\t\t\tPR_APTPL_MAX_TPORT_LEN);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_tpgt:\n\t\t\tret = match_int(args, &arg);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\ttpgt = (u16)arg;\n\t\t\tbreak;\n\t\tcase Opt_port_rtpi:\n\t\t\tret = match_int(args, &arg);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase Opt_target_lun:\n\t\t\tret = match_u64(args, &tmp_ll);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\ttarget_lun = (u64)tmp_ll;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!i_port || !t_port || !sa_res_key) {\n\t\tpr_err(\"Illegal parameters for APTPL registration\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (res_holder && !(type)) {\n\t\tpr_err(\"Illegal PR type: 0x%02x for reservation\"\n\t\t\t\t\" holder\\n\", type);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = core_scsi3_alloc_aptpl_registration(&dev->t10_pr, sa_res_key,\n\t\t\ti_port, isid, mapped_lun, t_port, tpgt, target_lun,\n\t\t\tres_holder, all_tg_pt, type);\nout:\n\tkfree(i_fabric);\n\tkfree(i_port);\n\tkfree(isid);\n\tkfree(t_fabric);\n\tkfree(t_port);\n\tkfree(orig);\n\treturn (ret == 0) ? count : ret;\n}\n\n\nCONFIGFS_ATTR_RO(target_pr_, res_holder);\nCONFIGFS_ATTR_RO(target_pr_, res_pr_all_tgt_pts);\nCONFIGFS_ATTR_RO(target_pr_, res_pr_generation);\nCONFIGFS_ATTR_RO(target_pr_, res_pr_holder_tg_port);\nCONFIGFS_ATTR_RO(target_pr_, res_pr_registered_i_pts);\nCONFIGFS_ATTR_RO(target_pr_, res_pr_type);\nCONFIGFS_ATTR_RO(target_pr_, res_type);\nCONFIGFS_ATTR_RO(target_pr_, res_aptpl_active);\nCONFIGFS_ATTR(target_pr_, res_aptpl_metadata);\n\nstatic struct configfs_attribute *target_core_dev_pr_attrs[] = {\n\t&target_pr_attr_res_holder,\n\t&target_pr_attr_res_pr_all_tgt_pts,\n\t&target_pr_attr_res_pr_generation,\n\t&target_pr_attr_res_pr_holder_tg_port,\n\t&target_pr_attr_res_pr_registered_i_pts,\n\t&target_pr_attr_res_pr_type,\n\t&target_pr_attr_res_type,\n\t&target_pr_attr_res_aptpl_active,\n\t&target_pr_attr_res_aptpl_metadata,\n\tNULL,\n};\n\nTB_CIT_SETUP(dev_pr, NULL, NULL, target_core_dev_pr_attrs);\n\n \n\n \n\nstatic inline struct se_device *to_device(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_device, dev_group);\n}\n\nstatic ssize_t target_dev_info_show(struct config_item *item, char *page)\n{\n\tstruct se_device *dev = to_device(item);\n\tint bl = 0;\n\tssize_t read_bytes = 0;\n\n\ttransport_dump_dev_state(dev, page, &bl);\n\tread_bytes += bl;\n\tread_bytes += dev->transport->show_configfs_dev_params(dev,\n\t\t\tpage+read_bytes);\n\treturn read_bytes;\n}\n\nstatic ssize_t target_dev_control_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_device *dev = to_device(item);\n\n\treturn dev->transport->set_configfs_dev_params(dev, page, count);\n}\n\nstatic ssize_t target_dev_alias_show(struct config_item *item, char *page)\n{\n\tstruct se_device *dev = to_device(item);\n\n\tif (!(dev->dev_flags & DF_USING_ALIAS))\n\t\treturn 0;\n\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", dev->dev_alias);\n}\n\nstatic ssize_t target_dev_alias_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_device *dev = to_device(item);\n\tstruct se_hba *hba = dev->se_hba;\n\tssize_t read_bytes;\n\n\tif (count > (SE_DEV_ALIAS_LEN-1)) {\n\t\tpr_err(\"alias count: %d exceeds\"\n\t\t\t\" SE_DEV_ALIAS_LEN-1: %u\\n\", (int)count,\n\t\t\tSE_DEV_ALIAS_LEN-1);\n\t\treturn -EINVAL;\n\t}\n\n\tread_bytes = snprintf(&dev->dev_alias[0], SE_DEV_ALIAS_LEN, \"%s\", page);\n\tif (!read_bytes)\n\t\treturn -EINVAL;\n\tif (dev->dev_alias[read_bytes - 1] == '\\n')\n\t\tdev->dev_alias[read_bytes - 1] = '\\0';\n\n\tdev->dev_flags |= DF_USING_ALIAS;\n\n\tpr_debug(\"Target_Core_ConfigFS: %s/%s set alias: %s\\n\",\n\t\tconfig_item_name(&hba->hba_group.cg_item),\n\t\tconfig_item_name(&dev->dev_group.cg_item),\n\t\tdev->dev_alias);\n\n\treturn read_bytes;\n}\n\nstatic ssize_t target_dev_udev_path_show(struct config_item *item, char *page)\n{\n\tstruct se_device *dev = to_device(item);\n\n\tif (!(dev->dev_flags & DF_USING_UDEV_PATH))\n\t\treturn 0;\n\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", dev->udev_path);\n}\n\nstatic ssize_t target_dev_udev_path_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_device *dev = to_device(item);\n\tstruct se_hba *hba = dev->se_hba;\n\tssize_t read_bytes;\n\n\tif (count > (SE_UDEV_PATH_LEN-1)) {\n\t\tpr_err(\"udev_path count: %d exceeds\"\n\t\t\t\" SE_UDEV_PATH_LEN-1: %u\\n\", (int)count,\n\t\t\tSE_UDEV_PATH_LEN-1);\n\t\treturn -EINVAL;\n\t}\n\n\tread_bytes = snprintf(&dev->udev_path[0], SE_UDEV_PATH_LEN,\n\t\t\t\"%s\", page);\n\tif (!read_bytes)\n\t\treturn -EINVAL;\n\tif (dev->udev_path[read_bytes - 1] == '\\n')\n\t\tdev->udev_path[read_bytes - 1] = '\\0';\n\n\tdev->dev_flags |= DF_USING_UDEV_PATH;\n\n\tpr_debug(\"Target_Core_ConfigFS: %s/%s set udev_path: %s\\n\",\n\t\tconfig_item_name(&hba->hba_group.cg_item),\n\t\tconfig_item_name(&dev->dev_group.cg_item),\n\t\tdev->udev_path);\n\n\treturn read_bytes;\n}\n\nstatic ssize_t target_dev_enable_show(struct config_item *item, char *page)\n{\n\tstruct se_device *dev = to_device(item);\n\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\", target_dev_configured(dev));\n}\n\nstatic ssize_t target_dev_enable_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_device *dev = to_device(item);\n\tchar *ptr;\n\tint ret;\n\n\tptr = strstr(page, \"1\");\n\tif (!ptr) {\n\t\tpr_err(\"For dev_enable ops, only valid value\"\n\t\t\t\t\" is \\\"1\\\"\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = target_configure_device(dev);\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic ssize_t target_dev_alua_lu_gp_show(struct config_item *item, char *page)\n{\n\tstruct se_device *dev = to_device(item);\n\tstruct config_item *lu_ci;\n\tstruct t10_alua_lu_gp *lu_gp;\n\tstruct t10_alua_lu_gp_member *lu_gp_mem;\n\tssize_t len = 0;\n\n\tlu_gp_mem = dev->dev_alua_lu_gp_mem;\n\tif (!lu_gp_mem)\n\t\treturn 0;\n\n\tspin_lock(&lu_gp_mem->lu_gp_mem_lock);\n\tlu_gp = lu_gp_mem->lu_gp;\n\tif (lu_gp) {\n\t\tlu_ci = &lu_gp->lu_gp_group.cg_item;\n\t\tlen += sprintf(page, \"LU Group Alias: %s\\nLU Group ID: %hu\\n\",\n\t\t\tconfig_item_name(lu_ci), lu_gp->lu_gp_id);\n\t}\n\tspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\n\n\treturn len;\n}\n\nstatic ssize_t target_dev_alua_lu_gp_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_device *dev = to_device(item);\n\tstruct se_hba *hba = dev->se_hba;\n\tstruct t10_alua_lu_gp *lu_gp = NULL, *lu_gp_new = NULL;\n\tstruct t10_alua_lu_gp_member *lu_gp_mem;\n\tunsigned char buf[LU_GROUP_NAME_BUF] = { };\n\tint move = 0;\n\n\tlu_gp_mem = dev->dev_alua_lu_gp_mem;\n\tif (!lu_gp_mem)\n\t\treturn count;\n\n\tif (count > LU_GROUP_NAME_BUF) {\n\t\tpr_err(\"ALUA LU Group Alias too large!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(buf, page, count);\n\t \n\tif (strcmp(strstrip(buf), \"NULL\")) {\n\t\t \n\t\tlu_gp_new = core_alua_get_lu_gp_by_name(strstrip(buf));\n\t\tif (!lu_gp_new)\n\t\t\treturn -ENODEV;\n\t}\n\n\tspin_lock(&lu_gp_mem->lu_gp_mem_lock);\n\tlu_gp = lu_gp_mem->lu_gp;\n\tif (lu_gp) {\n\t\t \n\t\tif (!lu_gp_new) {\n\t\t\tpr_debug(\"Target_Core_ConfigFS: Releasing %s/%s\"\n\t\t\t\t\" from ALUA LU Group: core/alua/lu_gps/%s, ID:\"\n\t\t\t\t\" %hu\\n\",\n\t\t\t\tconfig_item_name(&hba->hba_group.cg_item),\n\t\t\t\tconfig_item_name(&dev->dev_group.cg_item),\n\t\t\t\tconfig_item_name(&lu_gp->lu_gp_group.cg_item),\n\t\t\t\tlu_gp->lu_gp_id);\n\n\t\t\t__core_alua_drop_lu_gp_mem(lu_gp_mem, lu_gp);\n\t\t\tspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\n\n\t\t\treturn count;\n\t\t}\n\t\t \n\t\t__core_alua_drop_lu_gp_mem(lu_gp_mem, lu_gp);\n\t\tmove = 1;\n\t}\n\t \n\t__core_alua_attach_lu_gp_mem(lu_gp_mem, lu_gp_new);\n\tspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\n\n\tpr_debug(\"Target_Core_ConfigFS: %s %s/%s to ALUA LU Group:\"\n\t\t\" core/alua/lu_gps/%s, ID: %hu\\n\",\n\t\t(move) ? \"Moving\" : \"Adding\",\n\t\tconfig_item_name(&hba->hba_group.cg_item),\n\t\tconfig_item_name(&dev->dev_group.cg_item),\n\t\tconfig_item_name(&lu_gp_new->lu_gp_group.cg_item),\n\t\tlu_gp_new->lu_gp_id);\n\n\tcore_alua_put_lu_gp_from_name(lu_gp_new);\n\treturn count;\n}\n\nstatic ssize_t target_dev_lba_map_show(struct config_item *item, char *page)\n{\n\tstruct se_device *dev = to_device(item);\n\tstruct t10_alua_lba_map *map;\n\tstruct t10_alua_lba_map_member *mem;\n\tchar *b = page;\n\tint bl = 0;\n\tchar state;\n\n\tspin_lock(&dev->t10_alua.lba_map_lock);\n\tif (!list_empty(&dev->t10_alua.lba_map_list))\n\t    bl += sprintf(b + bl, \"%u %u\\n\",\n\t\t\t  dev->t10_alua.lba_map_segment_size,\n\t\t\t  dev->t10_alua.lba_map_segment_multiplier);\n\tlist_for_each_entry(map, &dev->t10_alua.lba_map_list, lba_map_list) {\n\t\tbl += sprintf(b + bl, \"%llu %llu\",\n\t\t\t      map->lba_map_first_lba, map->lba_map_last_lba);\n\t\tlist_for_each_entry(mem, &map->lba_map_mem_list,\n\t\t\t\t    lba_map_mem_list) {\n\t\t\tswitch (mem->lba_map_mem_alua_state) {\n\t\t\tcase ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED:\n\t\t\t\tstate = 'O';\n\t\t\t\tbreak;\n\t\t\tcase ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED:\n\t\t\t\tstate = 'A';\n\t\t\t\tbreak;\n\t\t\tcase ALUA_ACCESS_STATE_STANDBY:\n\t\t\t\tstate = 'S';\n\t\t\t\tbreak;\n\t\t\tcase ALUA_ACCESS_STATE_UNAVAILABLE:\n\t\t\t\tstate = 'U';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstate = '.';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbl += sprintf(b + bl, \" %d:%c\",\n\t\t\t\t      mem->lba_map_mem_alua_pg_id, state);\n\t\t}\n\t\tbl += sprintf(b + bl, \"\\n\");\n\t}\n\tspin_unlock(&dev->t10_alua.lba_map_lock);\n\treturn bl;\n}\n\nstatic ssize_t target_dev_lba_map_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_device *dev = to_device(item);\n\tstruct t10_alua_lba_map *lba_map = NULL;\n\tstruct list_head lba_list;\n\tchar *map_entries, *orig, *ptr;\n\tchar state;\n\tint pg_num = -1, pg;\n\tint ret = 0, num = 0, pg_id, alua_state;\n\tunsigned long start_lba = -1, end_lba = -1;\n\tunsigned long segment_size = -1, segment_mult = -1;\n\n\torig = map_entries = kstrdup(page, GFP_KERNEL);\n\tif (!map_entries)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&lba_list);\n\twhile ((ptr = strsep(&map_entries, \"\\n\")) != NULL) {\n\t\tif (!*ptr)\n\t\t\tcontinue;\n\n\t\tif (num == 0) {\n\t\t\tif (sscanf(ptr, \"%lu %lu\\n\",\n\t\t\t\t   &segment_size, &segment_mult) != 2) {\n\t\t\t\tpr_err(\"Invalid line %d\\n\", num);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnum++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (sscanf(ptr, \"%lu %lu\", &start_lba, &end_lba) != 2) {\n\t\t\tpr_err(\"Invalid line %d\\n\", num);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tptr = strchr(ptr, ' ');\n\t\tif (!ptr) {\n\t\t\tpr_err(\"Invalid line %d, missing end lba\\n\", num);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tptr++;\n\t\tptr = strchr(ptr, ' ');\n\t\tif (!ptr) {\n\t\t\tpr_err(\"Invalid line %d, missing state definitions\\n\",\n\t\t\t       num);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tptr++;\n\t\tlba_map = core_alua_allocate_lba_map(&lba_list,\n\t\t\t\t\t\t     start_lba, end_lba);\n\t\tif (IS_ERR(lba_map)) {\n\t\t\tret = PTR_ERR(lba_map);\n\t\t\tbreak;\n\t\t}\n\t\tpg = 0;\n\t\twhile (sscanf(ptr, \"%d:%c\", &pg_id, &state) == 2) {\n\t\t\tswitch (state) {\n\t\t\tcase 'O':\n\t\t\t\talua_state = ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED;\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\t\talua_state = ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\talua_state = ALUA_ACCESS_STATE_STANDBY;\n\t\t\t\tbreak;\n\t\t\tcase 'U':\n\t\t\t\talua_state = ALUA_ACCESS_STATE_UNAVAILABLE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_err(\"Invalid ALUA state '%c'\\n\", state);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = core_alua_allocate_lba_map_mem(lba_map,\n\t\t\t\t\t\t\t     pg_id, alua_state);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"Invalid target descriptor %d:%c \"\n\t\t\t\t       \"at line %d\\n\",\n\t\t\t\t       pg_id, state, num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpg++;\n\t\t\tptr = strchr(ptr, ' ');\n\t\t\tif (ptr)\n\t\t\t\tptr++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pg_num == -1)\n\t\t    pg_num = pg;\n\t\telse if (pg != pg_num) {\n\t\t\tpr_err(\"Only %d from %d port groups definitions \"\n\t\t\t       \"at line %d\\n\", pg, pg_num, num);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\nout:\n\tif (ret) {\n\t\tcore_alua_free_lba_map(&lba_list);\n\t\tcount = ret;\n\t} else\n\t\tcore_alua_set_lba_map(dev, &lba_list,\n\t\t\t\t      segment_size, segment_mult);\n\tkfree(orig);\n\treturn count;\n}\n\nCONFIGFS_ATTR_RO(target_dev_, info);\nCONFIGFS_ATTR_WO(target_dev_, control);\nCONFIGFS_ATTR(target_dev_, alias);\nCONFIGFS_ATTR(target_dev_, udev_path);\nCONFIGFS_ATTR(target_dev_, enable);\nCONFIGFS_ATTR(target_dev_, alua_lu_gp);\nCONFIGFS_ATTR(target_dev_, lba_map);\n\nstatic struct configfs_attribute *target_core_dev_attrs[] = {\n\t&target_dev_attr_info,\n\t&target_dev_attr_control,\n\t&target_dev_attr_alias,\n\t&target_dev_attr_udev_path,\n\t&target_dev_attr_enable,\n\t&target_dev_attr_alua_lu_gp,\n\t&target_dev_attr_lba_map,\n\tNULL,\n};\n\nstatic void target_core_dev_release(struct config_item *item)\n{\n\tstruct config_group *dev_cg = to_config_group(item);\n\tstruct se_device *dev =\n\t\tcontainer_of(dev_cg, struct se_device, dev_group);\n\n\ttarget_free_device(dev);\n}\n\n \nstruct configfs_item_operations target_core_dev_item_ops = {\n\t.release\t\t= target_core_dev_release,\n};\n\nTB_CIT_SETUP(dev, &target_core_dev_item_ops, NULL, target_core_dev_attrs);\n\n \n\n \n\nstatic inline struct t10_alua_lu_gp *to_lu_gp(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct t10_alua_lu_gp,\n\t\t\tlu_gp_group);\n}\n\nstatic ssize_t target_lu_gp_lu_gp_id_show(struct config_item *item, char *page)\n{\n\tstruct t10_alua_lu_gp *lu_gp = to_lu_gp(item);\n\n\tif (!lu_gp->lu_gp_valid_id)\n\t\treturn 0;\n\treturn sprintf(page, \"%hu\\n\", lu_gp->lu_gp_id);\n}\n\nstatic ssize_t target_lu_gp_lu_gp_id_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct t10_alua_lu_gp *lu_gp = to_lu_gp(item);\n\tstruct config_group *alua_lu_gp_cg = &lu_gp->lu_gp_group;\n\tunsigned long lu_gp_id;\n\tint ret;\n\n\tret = kstrtoul(page, 0, &lu_gp_id);\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() returned %d for\"\n\t\t\t\" lu_gp_id\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (lu_gp_id > 0x0000ffff) {\n\t\tpr_err(\"ALUA lu_gp_id: %lu exceeds maximum:\"\n\t\t\t\" 0x0000ffff\\n\", lu_gp_id);\n\t\treturn -EINVAL;\n\t}\n\n\tret = core_alua_set_lu_gp_id(lu_gp, (u16)lu_gp_id);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"Target_Core_ConfigFS: Set ALUA Logical Unit\"\n\t\t\" Group: core/alua/lu_gps/%s to ID: %hu\\n\",\n\t\tconfig_item_name(&alua_lu_gp_cg->cg_item),\n\t\tlu_gp->lu_gp_id);\n\n\treturn count;\n}\n\nstatic ssize_t target_lu_gp_members_show(struct config_item *item, char *page)\n{\n\tstruct t10_alua_lu_gp *lu_gp = to_lu_gp(item);\n\tstruct se_device *dev;\n\tstruct se_hba *hba;\n\tstruct t10_alua_lu_gp_member *lu_gp_mem;\n\tssize_t len = 0, cur_len;\n\tunsigned char buf[LU_GROUP_NAME_BUF] = { };\n\n\tspin_lock(&lu_gp->lu_gp_lock);\n\tlist_for_each_entry(lu_gp_mem, &lu_gp->lu_gp_mem_list, lu_gp_mem_list) {\n\t\tdev = lu_gp_mem->lu_gp_mem_dev;\n\t\thba = dev->se_hba;\n\n\t\tcur_len = snprintf(buf, LU_GROUP_NAME_BUF, \"%s/%s\\n\",\n\t\t\tconfig_item_name(&hba->hba_group.cg_item),\n\t\t\tconfig_item_name(&dev->dev_group.cg_item));\n\t\tcur_len++;  \n\n\t\tif ((cur_len + len) > PAGE_SIZE) {\n\t\t\tpr_warn(\"Ran out of lu_gp_show_attr\"\n\t\t\t\t\"_members buffer\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(page+len, buf, cur_len);\n\t\tlen += cur_len;\n\t}\n\tspin_unlock(&lu_gp->lu_gp_lock);\n\n\treturn len;\n}\n\nCONFIGFS_ATTR(target_lu_gp_, lu_gp_id);\nCONFIGFS_ATTR_RO(target_lu_gp_, members);\n\nstatic struct configfs_attribute *target_core_alua_lu_gp_attrs[] = {\n\t&target_lu_gp_attr_lu_gp_id,\n\t&target_lu_gp_attr_members,\n\tNULL,\n};\n\nstatic void target_core_alua_lu_gp_release(struct config_item *item)\n{\n\tstruct t10_alua_lu_gp *lu_gp = container_of(to_config_group(item),\n\t\t\tstruct t10_alua_lu_gp, lu_gp_group);\n\n\tcore_alua_free_lu_gp(lu_gp);\n}\n\nstatic struct configfs_item_operations target_core_alua_lu_gp_ops = {\n\t.release\t\t= target_core_alua_lu_gp_release,\n};\n\nstatic const struct config_item_type target_core_alua_lu_gp_cit = {\n\t.ct_item_ops\t\t= &target_core_alua_lu_gp_ops,\n\t.ct_attrs\t\t= target_core_alua_lu_gp_attrs,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\n \n\n \n\nstatic struct config_group *target_core_alua_create_lu_gp(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct t10_alua_lu_gp *lu_gp;\n\tstruct config_group *alua_lu_gp_cg = NULL;\n\tstruct config_item *alua_lu_gp_ci = NULL;\n\n\tlu_gp = core_alua_allocate_lu_gp(name, 0);\n\tif (IS_ERR(lu_gp))\n\t\treturn NULL;\n\n\talua_lu_gp_cg = &lu_gp->lu_gp_group;\n\talua_lu_gp_ci = &alua_lu_gp_cg->cg_item;\n\n\tconfig_group_init_type_name(alua_lu_gp_cg, name,\n\t\t\t&target_core_alua_lu_gp_cit);\n\n\tpr_debug(\"Target_Core_ConfigFS: Allocated ALUA Logical Unit\"\n\t\t\" Group: core/alua/lu_gps/%s\\n\",\n\t\tconfig_item_name(alua_lu_gp_ci));\n\n\treturn alua_lu_gp_cg;\n\n}\n\nstatic void target_core_alua_drop_lu_gp(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\tstruct t10_alua_lu_gp *lu_gp = container_of(to_config_group(item),\n\t\t\tstruct t10_alua_lu_gp, lu_gp_group);\n\n\tpr_debug(\"Target_Core_ConfigFS: Releasing ALUA Logical Unit\"\n\t\t\" Group: core/alua/lu_gps/%s, ID: %hu\\n\",\n\t\tconfig_item_name(item), lu_gp->lu_gp_id);\n\t \n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations target_core_alua_lu_gps_group_ops = {\n\t.make_group\t\t= &target_core_alua_create_lu_gp,\n\t.drop_item\t\t= &target_core_alua_drop_lu_gp,\n};\n\nstatic const struct config_item_type target_core_alua_lu_gps_cit = {\n\t.ct_item_ops\t\t= NULL,\n\t.ct_group_ops\t\t= &target_core_alua_lu_gps_group_ops,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\n \n\n \n\nstatic inline struct t10_alua_tg_pt_gp *to_tg_pt_gp(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct t10_alua_tg_pt_gp,\n\t\t\ttg_pt_gp_group);\n}\n\nstatic ssize_t target_tg_pt_gp_alua_access_state_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page, \"%d\\n\",\n\t\t       to_tg_pt_gp(item)->tg_pt_gp_alua_access_state);\n}\n\nstatic ssize_t target_tg_pt_gp_alua_access_state_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\n\tstruct se_device *dev = tg_pt_gp->tg_pt_gp_dev;\n\tunsigned long tmp;\n\tint new_state, ret;\n\n\tif (!tg_pt_gp->tg_pt_gp_valid_id) {\n\t\tpr_err(\"Unable to do implicit ALUA on invalid tg_pt_gp ID\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!target_dev_configured(dev)) {\n\t\tpr_err(\"Unable to set alua_access_state while device is\"\n\t\t       \" not configured\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = kstrtoul(page, 0, &tmp);\n\tif (ret < 0) {\n\t\tpr_err(\"Unable to extract new ALUA access state from\"\n\t\t\t\t\" %s\\n\", page);\n\t\treturn ret;\n\t}\n\tnew_state = (int)tmp;\n\n\tif (!(tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_IMPLICIT_ALUA)) {\n\t\tpr_err(\"Unable to process implicit configfs ALUA\"\n\t\t\t\" transition while TPGS_IMPLICIT_ALUA is disabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICIT_ALUA &&\n\t    new_state == ALUA_ACCESS_STATE_LBA_DEPENDENT) {\n\t\t \n\t\tpr_err(\"Unable to process implicit configfs ALUA transition\"\n\t\t       \" while explicit ALUA management is enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = core_alua_do_port_transition(tg_pt_gp, dev,\n\t\t\t\t\tNULL, NULL, new_state, 0);\n\treturn (!ret) ? count : -EINVAL;\n}\n\nstatic ssize_t target_tg_pt_gp_alua_access_status_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\n\treturn sprintf(page, \"%s\\n\",\n\t\tcore_alua_dump_status(tg_pt_gp->tg_pt_gp_alua_access_status));\n}\n\nstatic ssize_t target_tg_pt_gp_alua_access_status_store(\n\t\tstruct config_item *item, const char *page, size_t count)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\n\tunsigned long tmp;\n\tint new_status, ret;\n\n\tif (!tg_pt_gp->tg_pt_gp_valid_id) {\n\t\tpr_err(\"Unable to set ALUA access status on invalid tg_pt_gp ID\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = kstrtoul(page, 0, &tmp);\n\tif (ret < 0) {\n\t\tpr_err(\"Unable to extract new ALUA access status\"\n\t\t\t\t\" from %s\\n\", page);\n\t\treturn ret;\n\t}\n\tnew_status = (int)tmp;\n\n\tif ((new_status != ALUA_STATUS_NONE) &&\n\t    (new_status != ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG) &&\n\t    (new_status != ALUA_STATUS_ALTERED_BY_IMPLICIT_ALUA)) {\n\t\tpr_err(\"Illegal ALUA access status: 0x%02x\\n\",\n\t\t\t\tnew_status);\n\t\treturn -EINVAL;\n\t}\n\n\ttg_pt_gp->tg_pt_gp_alua_access_status = new_status;\n\treturn count;\n}\n\nstatic ssize_t target_tg_pt_gp_alua_access_type_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn core_alua_show_access_type(to_tg_pt_gp(item), page);\n}\n\nstatic ssize_t target_tg_pt_gp_alua_access_type_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\treturn core_alua_store_access_type(to_tg_pt_gp(item), page, count);\n}\n\n#define ALUA_SUPPORTED_STATE_ATTR(_name, _bit)\t\t\t\t\\\nstatic ssize_t target_tg_pt_gp_alua_support_##_name##_show(\t\t\\\n\t\tstruct config_item *item, char *p)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct t10_alua_tg_pt_gp *t = to_tg_pt_gp(item);\t\t\\\n\treturn sprintf(p, \"%d\\n\",\t\t\t\t\t\\\n\t\t!!(t->tg_pt_gp_alua_supported_states & _bit));\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t target_tg_pt_gp_alua_support_##_name##_store(\t\t\\\n\t\tstruct config_item *item, const char *p, size_t c)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct t10_alua_tg_pt_gp *t = to_tg_pt_gp(item);\t\t\\\n\tunsigned long tmp;\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!t->tg_pt_gp_valid_id) {\t\t\t\t\t\\\n\t\tpr_err(\"Unable to set \" #_name \" ALUA state on invalid tg_pt_gp ID\\n\"); \\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtoul(p, 0, &tmp);\t\t\t\t\t\\\n\tif (ret < 0) {\t\t\t\t\t\t\t\\\n\t\tpr_err(\"Invalid value '%s', must be '0' or '1'\\n\", p);\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (tmp > 1) {\t\t\t\t\t\t\t\\\n\t\tpr_err(\"Invalid value '%ld', must be '0' or '1'\\n\", tmp); \\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (tmp)\t\t\t\t\t\t\t\\\n\t\tt->tg_pt_gp_alua_supported_states |= _bit;\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\tt->tg_pt_gp_alua_supported_states &= ~_bit;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn c;\t\t\t\t\t\t\t\\\n}\n\nALUA_SUPPORTED_STATE_ATTR(transitioning, ALUA_T_SUP);\nALUA_SUPPORTED_STATE_ATTR(offline, ALUA_O_SUP);\nALUA_SUPPORTED_STATE_ATTR(lba_dependent, ALUA_LBD_SUP);\nALUA_SUPPORTED_STATE_ATTR(unavailable, ALUA_U_SUP);\nALUA_SUPPORTED_STATE_ATTR(standby, ALUA_S_SUP);\nALUA_SUPPORTED_STATE_ATTR(active_optimized, ALUA_AO_SUP);\nALUA_SUPPORTED_STATE_ATTR(active_nonoptimized, ALUA_AN_SUP);\n\nstatic ssize_t target_tg_pt_gp_alua_write_metadata_show(\n\t\tstruct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\",\n\t\tto_tg_pt_gp(item)->tg_pt_gp_write_metadata);\n}\n\nstatic ssize_t target_tg_pt_gp_alua_write_metadata_store(\n\t\tstruct config_item *item, const char *page, size_t count)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\n\tunsigned long tmp;\n\tint ret;\n\n\tret = kstrtoul(page, 0, &tmp);\n\tif (ret < 0) {\n\t\tpr_err(\"Unable to extract alua_write_metadata\\n\");\n\t\treturn ret;\n\t}\n\n\tif ((tmp != 0) && (tmp != 1)) {\n\t\tpr_err(\"Illegal value for alua_write_metadata:\"\n\t\t\t\" %lu\\n\", tmp);\n\t\treturn -EINVAL;\n\t}\n\ttg_pt_gp->tg_pt_gp_write_metadata = (int)tmp;\n\n\treturn count;\n}\n\nstatic ssize_t target_tg_pt_gp_nonop_delay_msecs_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn core_alua_show_nonop_delay_msecs(to_tg_pt_gp(item), page);\n}\n\nstatic ssize_t target_tg_pt_gp_nonop_delay_msecs_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\treturn core_alua_store_nonop_delay_msecs(to_tg_pt_gp(item), page,\n\t\t\tcount);\n}\n\nstatic ssize_t target_tg_pt_gp_trans_delay_msecs_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn core_alua_show_trans_delay_msecs(to_tg_pt_gp(item), page);\n}\n\nstatic ssize_t target_tg_pt_gp_trans_delay_msecs_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\treturn core_alua_store_trans_delay_msecs(to_tg_pt_gp(item), page,\n\t\t\tcount);\n}\n\nstatic ssize_t target_tg_pt_gp_implicit_trans_secs_show(\n\t\tstruct config_item *item, char *page)\n{\n\treturn core_alua_show_implicit_trans_secs(to_tg_pt_gp(item), page);\n}\n\nstatic ssize_t target_tg_pt_gp_implicit_trans_secs_store(\n\t\tstruct config_item *item, const char *page, size_t count)\n{\n\treturn core_alua_store_implicit_trans_secs(to_tg_pt_gp(item), page,\n\t\t\tcount);\n}\n\nstatic ssize_t target_tg_pt_gp_preferred_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn core_alua_show_preferred_bit(to_tg_pt_gp(item), page);\n}\n\nstatic ssize_t target_tg_pt_gp_preferred_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\treturn core_alua_store_preferred_bit(to_tg_pt_gp(item), page, count);\n}\n\nstatic ssize_t target_tg_pt_gp_tg_pt_gp_id_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\n\n\tif (!tg_pt_gp->tg_pt_gp_valid_id)\n\t\treturn 0;\n\treturn sprintf(page, \"%hu\\n\", tg_pt_gp->tg_pt_gp_id);\n}\n\nstatic ssize_t target_tg_pt_gp_tg_pt_gp_id_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\n\tstruct config_group *alua_tg_pt_gp_cg = &tg_pt_gp->tg_pt_gp_group;\n\tunsigned long tg_pt_gp_id;\n\tint ret;\n\n\tret = kstrtoul(page, 0, &tg_pt_gp_id);\n\tif (ret < 0) {\n\t\tpr_err(\"ALUA tg_pt_gp_id: invalid value '%s' for tg_pt_gp_id\\n\",\n\t\t       page);\n\t\treturn ret;\n\t}\n\tif (tg_pt_gp_id > 0x0000ffff) {\n\t\tpr_err(\"ALUA tg_pt_gp_id: %lu exceeds maximum: 0x0000ffff\\n\",\n\t\t       tg_pt_gp_id);\n\t\treturn -EINVAL;\n\t}\n\n\tret = core_alua_set_tg_pt_gp_id(tg_pt_gp, (u16)tg_pt_gp_id);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"Target_Core_ConfigFS: Set ALUA Target Port Group: \"\n\t\t\"core/alua/tg_pt_gps/%s to ID: %hu\\n\",\n\t\tconfig_item_name(&alua_tg_pt_gp_cg->cg_item),\n\t\ttg_pt_gp->tg_pt_gp_id);\n\n\treturn count;\n}\n\nstatic ssize_t target_tg_pt_gp_members_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp = to_tg_pt_gp(item);\n\tstruct se_lun *lun;\n\tssize_t len = 0, cur_len;\n\tunsigned char buf[TG_PT_GROUP_NAME_BUF] = { };\n\n\tspin_lock(&tg_pt_gp->tg_pt_gp_lock);\n\tlist_for_each_entry(lun, &tg_pt_gp->tg_pt_gp_lun_list,\n\t\t\tlun_tg_pt_gp_link) {\n\t\tstruct se_portal_group *tpg = lun->lun_tpg;\n\n\t\tcur_len = snprintf(buf, TG_PT_GROUP_NAME_BUF, \"%s/%s/tpgt_%hu\"\n\t\t\t\"/%s\\n\", tpg->se_tpg_tfo->fabric_name,\n\t\t\ttpg->se_tpg_tfo->tpg_get_wwn(tpg),\n\t\t\ttpg->se_tpg_tfo->tpg_get_tag(tpg),\n\t\t\tconfig_item_name(&lun->lun_group.cg_item));\n\t\tcur_len++;  \n\n\t\tif ((cur_len + len) > PAGE_SIZE) {\n\t\t\tpr_warn(\"Ran out of lu_gp_show_attr\"\n\t\t\t\t\"_members buffer\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(page+len, buf, cur_len);\n\t\tlen += cur_len;\n\t}\n\tspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\n\n\treturn len;\n}\n\nCONFIGFS_ATTR(target_tg_pt_gp_, alua_access_state);\nCONFIGFS_ATTR(target_tg_pt_gp_, alua_access_status);\nCONFIGFS_ATTR(target_tg_pt_gp_, alua_access_type);\nCONFIGFS_ATTR(target_tg_pt_gp_, alua_support_transitioning);\nCONFIGFS_ATTR(target_tg_pt_gp_, alua_support_offline);\nCONFIGFS_ATTR(target_tg_pt_gp_, alua_support_lba_dependent);\nCONFIGFS_ATTR(target_tg_pt_gp_, alua_support_unavailable);\nCONFIGFS_ATTR(target_tg_pt_gp_, alua_support_standby);\nCONFIGFS_ATTR(target_tg_pt_gp_, alua_support_active_optimized);\nCONFIGFS_ATTR(target_tg_pt_gp_, alua_support_active_nonoptimized);\nCONFIGFS_ATTR(target_tg_pt_gp_, alua_write_metadata);\nCONFIGFS_ATTR(target_tg_pt_gp_, nonop_delay_msecs);\nCONFIGFS_ATTR(target_tg_pt_gp_, trans_delay_msecs);\nCONFIGFS_ATTR(target_tg_pt_gp_, implicit_trans_secs);\nCONFIGFS_ATTR(target_tg_pt_gp_, preferred);\nCONFIGFS_ATTR(target_tg_pt_gp_, tg_pt_gp_id);\nCONFIGFS_ATTR_RO(target_tg_pt_gp_, members);\n\nstatic struct configfs_attribute *target_core_alua_tg_pt_gp_attrs[] = {\n\t&target_tg_pt_gp_attr_alua_access_state,\n\t&target_tg_pt_gp_attr_alua_access_status,\n\t&target_tg_pt_gp_attr_alua_access_type,\n\t&target_tg_pt_gp_attr_alua_support_transitioning,\n\t&target_tg_pt_gp_attr_alua_support_offline,\n\t&target_tg_pt_gp_attr_alua_support_lba_dependent,\n\t&target_tg_pt_gp_attr_alua_support_unavailable,\n\t&target_tg_pt_gp_attr_alua_support_standby,\n\t&target_tg_pt_gp_attr_alua_support_active_nonoptimized,\n\t&target_tg_pt_gp_attr_alua_support_active_optimized,\n\t&target_tg_pt_gp_attr_alua_write_metadata,\n\t&target_tg_pt_gp_attr_nonop_delay_msecs,\n\t&target_tg_pt_gp_attr_trans_delay_msecs,\n\t&target_tg_pt_gp_attr_implicit_trans_secs,\n\t&target_tg_pt_gp_attr_preferred,\n\t&target_tg_pt_gp_attr_tg_pt_gp_id,\n\t&target_tg_pt_gp_attr_members,\n\tNULL,\n};\n\nstatic void target_core_alua_tg_pt_gp_release(struct config_item *item)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp = container_of(to_config_group(item),\n\t\t\tstruct t10_alua_tg_pt_gp, tg_pt_gp_group);\n\n\tcore_alua_free_tg_pt_gp(tg_pt_gp);\n}\n\nstatic struct configfs_item_operations target_core_alua_tg_pt_gp_ops = {\n\t.release\t\t= target_core_alua_tg_pt_gp_release,\n};\n\nstatic const struct config_item_type target_core_alua_tg_pt_gp_cit = {\n\t.ct_item_ops\t\t= &target_core_alua_tg_pt_gp_ops,\n\t.ct_attrs\t\t= target_core_alua_tg_pt_gp_attrs,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\n \n\n \n\nstatic struct config_group *target_core_alua_create_tg_pt_gp(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct t10_alua *alua = container_of(group, struct t10_alua,\n\t\t\t\t\talua_tg_pt_gps_group);\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp;\n\tstruct config_group *alua_tg_pt_gp_cg = NULL;\n\tstruct config_item *alua_tg_pt_gp_ci = NULL;\n\n\ttg_pt_gp = core_alua_allocate_tg_pt_gp(alua->t10_dev, name, 0);\n\tif (!tg_pt_gp)\n\t\treturn NULL;\n\n\talua_tg_pt_gp_cg = &tg_pt_gp->tg_pt_gp_group;\n\talua_tg_pt_gp_ci = &alua_tg_pt_gp_cg->cg_item;\n\n\tconfig_group_init_type_name(alua_tg_pt_gp_cg, name,\n\t\t\t&target_core_alua_tg_pt_gp_cit);\n\n\tpr_debug(\"Target_Core_ConfigFS: Allocated ALUA Target Port\"\n\t\t\" Group: alua/tg_pt_gps/%s\\n\",\n\t\tconfig_item_name(alua_tg_pt_gp_ci));\n\n\treturn alua_tg_pt_gp_cg;\n}\n\nstatic void target_core_alua_drop_tg_pt_gp(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp = container_of(to_config_group(item),\n\t\t\tstruct t10_alua_tg_pt_gp, tg_pt_gp_group);\n\n\tpr_debug(\"Target_Core_ConfigFS: Releasing ALUA Target Port\"\n\t\t\" Group: alua/tg_pt_gps/%s, ID: %hu\\n\",\n\t\tconfig_item_name(item), tg_pt_gp->tg_pt_gp_id);\n\t \n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations target_core_alua_tg_pt_gps_group_ops = {\n\t.make_group\t\t= &target_core_alua_create_tg_pt_gp,\n\t.drop_item\t\t= &target_core_alua_drop_tg_pt_gp,\n};\n\nTB_CIT_SETUP(dev_alua_tg_pt_gps, NULL, &target_core_alua_tg_pt_gps_group_ops, NULL);\n\n \n\n \n\n \nstatic const struct config_item_type target_core_alua_cit = {\n\t.ct_item_ops\t\t= NULL,\n\t.ct_attrs\t\t= NULL,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\n \n\n \n\nstatic struct config_group *target_core_stat_mkdir(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\treturn ERR_PTR(-ENOSYS);\n}\n\nstatic void target_core_stat_rmdir(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\treturn;\n}\n\nstatic struct configfs_group_operations target_core_stat_group_ops = {\n\t.make_group\t\t= &target_core_stat_mkdir,\n\t.drop_item\t\t= &target_core_stat_rmdir,\n};\n\nTB_CIT_SETUP(dev_stat, NULL, &target_core_stat_group_ops, NULL);\n\n \n\n \n\nstatic struct config_group *target_core_make_subdev(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp;\n\tstruct config_item *hba_ci = &group->cg_item;\n\tstruct se_hba *hba = item_to_hba(hba_ci);\n\tstruct target_backend *tb = hba->backend;\n\tstruct se_device *dev;\n\tint errno = -ENOMEM, ret;\n\n\tret = mutex_lock_interruptible(&hba->hba_access_mutex);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdev = target_alloc_device(hba, name);\n\tif (!dev)\n\t\tgoto out_unlock;\n\n\tconfig_group_init_type_name(&dev->dev_group, name, &tb->tb_dev_cit);\n\n\tconfig_group_init_type_name(&dev->dev_action_group, \"action\",\n\t\t\t&tb->tb_dev_action_cit);\n\tconfigfs_add_default_group(&dev->dev_action_group, &dev->dev_group);\n\n\tconfig_group_init_type_name(&dev->dev_attrib.da_group, \"attrib\",\n\t\t\t&tb->tb_dev_attrib_cit);\n\tconfigfs_add_default_group(&dev->dev_attrib.da_group, &dev->dev_group);\n\n\tconfig_group_init_type_name(&dev->dev_pr_group, \"pr\",\n\t\t\t&tb->tb_dev_pr_cit);\n\tconfigfs_add_default_group(&dev->dev_pr_group, &dev->dev_group);\n\n\tconfig_group_init_type_name(&dev->t10_wwn.t10_wwn_group, \"wwn\",\n\t\t\t&tb->tb_dev_wwn_cit);\n\tconfigfs_add_default_group(&dev->t10_wwn.t10_wwn_group,\n\t\t\t&dev->dev_group);\n\n\tconfig_group_init_type_name(&dev->t10_alua.alua_tg_pt_gps_group,\n\t\t\t\"alua\", &tb->tb_dev_alua_tg_pt_gps_cit);\n\tconfigfs_add_default_group(&dev->t10_alua.alua_tg_pt_gps_group,\n\t\t\t&dev->dev_group);\n\n\tconfig_group_init_type_name(&dev->dev_stat_grps.stat_group,\n\t\t\t\"statistics\", &tb->tb_dev_stat_cit);\n\tconfigfs_add_default_group(&dev->dev_stat_grps.stat_group,\n\t\t\t&dev->dev_group);\n\n\t \n\ttg_pt_gp = core_alua_allocate_tg_pt_gp(dev, \"default_tg_pt_gp\", 1);\n\tif (!tg_pt_gp)\n\t\tgoto out_free_device;\n\tdev->t10_alua.default_tg_pt_gp = tg_pt_gp;\n\n\tconfig_group_init_type_name(&tg_pt_gp->tg_pt_gp_group,\n\t\t\t\"default_tg_pt_gp\", &target_core_alua_tg_pt_gp_cit);\n\tconfigfs_add_default_group(&tg_pt_gp->tg_pt_gp_group,\n\t\t\t&dev->t10_alua.alua_tg_pt_gps_group);\n\n\t \n\ttarget_stat_setup_dev_default_groups(dev);\n\n\tmutex_lock(&target_devices_lock);\n\ttarget_devices++;\n\tmutex_unlock(&target_devices_lock);\n\n\tmutex_unlock(&hba->hba_access_mutex);\n\treturn &dev->dev_group;\n\nout_free_device:\n\ttarget_free_device(dev);\nout_unlock:\n\tmutex_unlock(&hba->hba_access_mutex);\n\treturn ERR_PTR(errno);\n}\n\nstatic void target_core_drop_subdev(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\tstruct config_group *dev_cg = to_config_group(item);\n\tstruct se_device *dev =\n\t\tcontainer_of(dev_cg, struct se_device, dev_group);\n\tstruct se_hba *hba;\n\n\thba = item_to_hba(&dev->se_hba->hba_group.cg_item);\n\n\tmutex_lock(&hba->hba_access_mutex);\n\n\tconfigfs_remove_default_groups(&dev->dev_stat_grps.stat_group);\n\tconfigfs_remove_default_groups(&dev->t10_alua.alua_tg_pt_gps_group);\n\n\t \n\tdev->t10_alua.default_tg_pt_gp = NULL;\n\n\tconfigfs_remove_default_groups(dev_cg);\n\n\t \n\tconfig_item_put(item);\n\n\tmutex_lock(&target_devices_lock);\n\ttarget_devices--;\n\tmutex_unlock(&target_devices_lock);\n\n\tmutex_unlock(&hba->hba_access_mutex);\n}\n\nstatic struct configfs_group_operations target_core_hba_group_ops = {\n\t.make_group\t\t= target_core_make_subdev,\n\t.drop_item\t\t= target_core_drop_subdev,\n};\n\n\nstatic inline struct se_hba *to_hba(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_hba, hba_group);\n}\n\nstatic ssize_t target_hba_info_show(struct config_item *item, char *page)\n{\n\tstruct se_hba *hba = to_hba(item);\n\n\treturn sprintf(page, \"HBA Index: %d plugin: %s version: %s\\n\",\n\t\t\thba->hba_id, hba->backend->ops->name,\n\t\t\tTARGET_CORE_VERSION);\n}\n\nstatic ssize_t target_hba_mode_show(struct config_item *item, char *page)\n{\n\tstruct se_hba *hba = to_hba(item);\n\tint hba_mode = 0;\n\n\tif (hba->hba_flags & HBA_FLAGS_PSCSI_MODE)\n\t\thba_mode = 1;\n\n\treturn sprintf(page, \"%d\\n\", hba_mode);\n}\n\nstatic ssize_t target_hba_mode_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_hba *hba = to_hba(item);\n\tunsigned long mode_flag;\n\tint ret;\n\n\tif (hba->backend->ops->pmode_enable_hba == NULL)\n\t\treturn -EINVAL;\n\n\tret = kstrtoul(page, 0, &mode_flag);\n\tif (ret < 0) {\n\t\tpr_err(\"Unable to extract hba mode flag: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (hba->dev_count) {\n\t\tpr_err(\"Unable to set hba_mode with active devices\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = hba->backend->ops->pmode_enable_hba(hba, mode_flag);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tif (ret > 0)\n\t\thba->hba_flags |= HBA_FLAGS_PSCSI_MODE;\n\telse if (ret == 0)\n\t\thba->hba_flags &= ~HBA_FLAGS_PSCSI_MODE;\n\n\treturn count;\n}\n\nCONFIGFS_ATTR_RO(target_, hba_info);\nCONFIGFS_ATTR(target_, hba_mode);\n\nstatic void target_core_hba_release(struct config_item *item)\n{\n\tstruct se_hba *hba = container_of(to_config_group(item),\n\t\t\t\tstruct se_hba, hba_group);\n\tcore_delete_hba(hba);\n}\n\nstatic struct configfs_attribute *target_core_hba_attrs[] = {\n\t&target_attr_hba_info,\n\t&target_attr_hba_mode,\n\tNULL,\n};\n\nstatic struct configfs_item_operations target_core_hba_item_ops = {\n\t.release\t\t= target_core_hba_release,\n};\n\nstatic const struct config_item_type target_core_hba_cit = {\n\t.ct_item_ops\t\t= &target_core_hba_item_ops,\n\t.ct_group_ops\t\t= &target_core_hba_group_ops,\n\t.ct_attrs\t\t= target_core_hba_attrs,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\nstatic struct config_group *target_core_call_addhbatotarget(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tchar *se_plugin_str, *str, *str2;\n\tstruct se_hba *hba;\n\tchar buf[TARGET_CORE_NAME_MAX_LEN] = { };\n\tunsigned long plugin_dep_id = 0;\n\tint ret;\n\n\tif (strlen(name) >= TARGET_CORE_NAME_MAX_LEN) {\n\t\tpr_err(\"Passed *name strlen(): %d exceeds\"\n\t\t\t\" TARGET_CORE_NAME_MAX_LEN: %d\\n\", (int)strlen(name),\n\t\t\tTARGET_CORE_NAME_MAX_LEN);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tsnprintf(buf, TARGET_CORE_NAME_MAX_LEN, \"%s\", name);\n\n\tstr = strstr(buf, \"_\");\n\tif (!str) {\n\t\tpr_err(\"Unable to locate \\\"_\\\" for $SUBSYSTEM_PLUGIN_$HOST_ID\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tse_plugin_str = buf;\n\t \n\tstr2 = strstr(str+1, \"_\");\n\tif (str2) {\n\t\t*str2 = '\\0';  \n\t\tstr2++;  \n\t\tstr = str2;\n\t} else {\n\t\t*str = '\\0';  \n\t\tstr++;  \n\t}\n\n\tret = kstrtoul(str, 0, &plugin_dep_id);\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() returned %d for\"\n\t\t\t\t\" plugin_dep_id\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\t \n\ttransport_subsystem_check_init();\n\n\thba = core_alloc_hba(se_plugin_str, plugin_dep_id, 0);\n\tif (IS_ERR(hba))\n\t\treturn ERR_CAST(hba);\n\n\tconfig_group_init_type_name(&hba->hba_group, name,\n\t\t\t&target_core_hba_cit);\n\n\treturn &hba->hba_group;\n}\n\nstatic void target_core_call_delhbafromtarget(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\t \n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations target_core_group_ops = {\n\t.make_group\t= target_core_call_addhbatotarget,\n\t.drop_item\t= target_core_call_delhbafromtarget,\n};\n\nstatic const struct config_item_type target_core_cit = {\n\t.ct_item_ops\t= NULL,\n\t.ct_group_ops\t= &target_core_group_ops,\n\t.ct_attrs\t= NULL,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \n\nvoid target_setup_backend_cits(struct target_backend *tb)\n{\n\ttarget_core_setup_dev_cit(tb);\n\ttarget_core_setup_dev_action_cit(tb);\n\ttarget_core_setup_dev_attrib_cit(tb);\n\ttarget_core_setup_dev_pr_cit(tb);\n\ttarget_core_setup_dev_wwn_cit(tb);\n\ttarget_core_setup_dev_alua_tg_pt_gps_cit(tb);\n\ttarget_core_setup_dev_stat_cit(tb);\n}\n\nstatic void target_init_dbroot(void)\n{\n\tstruct file *fp;\n\n\tsnprintf(db_root_stage, DB_ROOT_LEN, DB_ROOT_PREFERRED);\n\tfp = filp_open(db_root_stage, O_RDONLY, 0);\n\tif (IS_ERR(fp)) {\n\t\tpr_err(\"db_root: cannot open: %s\\n\", db_root_stage);\n\t\treturn;\n\t}\n\tif (!S_ISDIR(file_inode(fp)->i_mode)) {\n\t\tfilp_close(fp, NULL);\n\t\tpr_err(\"db_root: not a valid directory: %s\\n\", db_root_stage);\n\t\treturn;\n\t}\n\tfilp_close(fp, NULL);\n\n\tstrncpy(db_root, db_root_stage, DB_ROOT_LEN);\n\tpr_debug(\"Target_Core_ConfigFS: db_root set to %s\\n\", db_root);\n}\n\nstatic int __init target_core_init_configfs(void)\n{\n\tstruct configfs_subsystem *subsys = &target_core_fabrics;\n\tstruct t10_alua_lu_gp *lu_gp;\n\tint ret;\n\n\tpr_debug(\"TARGET_CORE[0]: Loading Generic Kernel Storage\"\n\t\t\" Engine: %s on %s/%s on \"UTS_RELEASE\"\\n\",\n\t\tTARGET_CORE_VERSION, utsname()->sysname, utsname()->machine);\n\n\tconfig_group_init(&subsys->su_group);\n\tmutex_init(&subsys->su_mutex);\n\n\tret = init_se_kmem_caches();\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tconfig_group_init_type_name(&target_core_hbagroup, \"core\",\n\t\t\t&target_core_cit);\n\tconfigfs_add_default_group(&target_core_hbagroup, &subsys->su_group);\n\n\t \n\tconfig_group_init_type_name(&alua_group, \"alua\", &target_core_alua_cit);\n\tconfigfs_add_default_group(&alua_group, &target_core_hbagroup);\n\n\t \n\tconfig_group_init_type_name(&alua_lu_gps_group, \"lu_gps\",\n\t\t\t&target_core_alua_lu_gps_cit);\n\tconfigfs_add_default_group(&alua_lu_gps_group, &alua_group);\n\n\t \n\tlu_gp = core_alua_allocate_lu_gp(\"default_lu_gp\", 1);\n\tif (IS_ERR(lu_gp)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_global;\n\t}\n\n\tconfig_group_init_type_name(&lu_gp->lu_gp_group, \"default_lu_gp\",\n\t\t\t\t&target_core_alua_lu_gp_cit);\n\tconfigfs_add_default_group(&lu_gp->lu_gp_group, &alua_lu_gps_group);\n\n\tdefault_lu_gp = lu_gp;\n\n\t \n\tret = configfs_register_subsystem(subsys);\n\tif (ret < 0) {\n\t\tpr_err(\"Error %d while registering subsystem %s\\n\",\n\t\t\tret, subsys->su_group.cg_item.ci_namebuf);\n\t\tgoto out_global;\n\t}\n\tpr_debug(\"TARGET_CORE[0]: Initialized ConfigFS Fabric\"\n\t\t\" Infrastructure: \"TARGET_CORE_VERSION\" on %s/%s\"\n\t\t\" on \"UTS_RELEASE\"\\n\", utsname()->sysname, utsname()->machine);\n\t \n\tret = rd_module_init();\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = core_dev_setup_virtual_lun0();\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = target_xcopy_setup_pt();\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttarget_init_dbroot();\n\n\treturn 0;\n\nout:\n\tconfigfs_unregister_subsystem(subsys);\n\tcore_dev_release_virtual_lun0();\n\trd_module_exit();\nout_global:\n\tif (default_lu_gp) {\n\t\tcore_alua_free_lu_gp(default_lu_gp);\n\t\tdefault_lu_gp = NULL;\n\t}\n\trelease_se_kmem_caches();\n\treturn ret;\n}\n\nstatic void __exit target_core_exit_configfs(void)\n{\n\tconfigfs_remove_default_groups(&alua_lu_gps_group);\n\tconfigfs_remove_default_groups(&alua_group);\n\tconfigfs_remove_default_groups(&target_core_hbagroup);\n\n\t \n\tconfigfs_unregister_subsystem(&target_core_fabrics);\n\n\tcore_alua_free_lu_gp(default_lu_gp);\n\tdefault_lu_gp = NULL;\n\n\tpr_debug(\"TARGET_CORE[0]: Released ConfigFS Fabric\"\n\t\t\t\" Infrastructure\\n\");\n\n\tcore_dev_release_virtual_lun0();\n\trd_module_exit();\n\ttarget_xcopy_release_pt();\n\trelease_se_kmem_caches();\n}\n\nMODULE_DESCRIPTION(\"Target_Core_Mod/ConfigFS\");\nMODULE_AUTHOR(\"nab@Linux-iSCSI.org\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(target_core_init_configfs);\nmodule_exit(target_core_exit_configfs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}