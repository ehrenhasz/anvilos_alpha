{
  "module_name": "target_core_ua.c",
  "hash_id": "180f949a8b2a4d0401a634606052462148075e3f5fa58f3f35bc44e8503948ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_ua.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <scsi/scsi_proto.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include \"target_core_internal.h\"\n#include \"target_core_alua.h\"\n#include \"target_core_pr.h\"\n#include \"target_core_ua.h\"\n\nsense_reason_t\ntarget_scsi3_ua_check(struct se_cmd *cmd)\n{\n\tstruct se_dev_entry *deve;\n\tstruct se_session *sess = cmd->se_sess;\n\tstruct se_node_acl *nacl;\n\n\tif (!sess)\n\t\treturn 0;\n\n\tnacl = sess->se_node_acl;\n\tif (!nacl)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tdeve = target_nacl_find_deve(nacl, cmd->orig_fe_lun);\n\tif (!deve) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\tif (list_empty_careful(&deve->ua_list)) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\t \n\tswitch (cmd->t_task_cdb[0]) {\n\tcase INQUIRY:\n\tcase REPORT_LUNS:\n\tcase REQUEST_SENSE:\n\t\treturn 0;\n\tdefault:\n\t\treturn TCM_CHECK_CONDITION_UNIT_ATTENTION;\n\t}\n}\n\nint core_scsi3_ua_allocate(\n\tstruct se_dev_entry *deve,\n\tu8 asc,\n\tu8 ascq)\n{\n\tstruct se_ua *ua, *ua_p, *ua_tmp;\n\n\tua = kmem_cache_zalloc(se_ua_cache, GFP_ATOMIC);\n\tif (!ua) {\n\t\tpr_err(\"Unable to allocate struct se_ua\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tINIT_LIST_HEAD(&ua->ua_nacl_list);\n\n\tua->ua_asc = asc;\n\tua->ua_ascq = ascq;\n\n\tspin_lock(&deve->ua_lock);\n\tlist_for_each_entry_safe(ua_p, ua_tmp, &deve->ua_list, ua_nacl_list) {\n\t\t \n\t\tif ((ua_p->ua_asc == asc) && (ua_p->ua_ascq == ascq)) {\n\t\t\tspin_unlock(&deve->ua_lock);\n\t\t\tkmem_cache_free(se_ua_cache, ua);\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tif (ua_p->ua_asc == 0x29) {\n\t\t\tif ((asc == 0x29) && (ascq > ua_p->ua_ascq))\n\t\t\t\tlist_add(&ua->ua_nacl_list,\n\t\t\t\t\t\t&deve->ua_list);\n\t\t\telse\n\t\t\t\tlist_add_tail(&ua->ua_nacl_list,\n\t\t\t\t\t\t&deve->ua_list);\n\t\t} else if (ua_p->ua_asc == 0x2a) {\n\t\t\t \n\t\t\tif ((asc == 0x29) || (ascq > ua_p->ua_asc))\n\t\t\t\tlist_add(&ua->ua_nacl_list,\n\t\t\t\t\t&deve->ua_list);\n\t\t\telse\n\t\t\t\tlist_add_tail(&ua->ua_nacl_list,\n\t\t\t\t\t\t&deve->ua_list);\n\t\t} else\n\t\t\tlist_add_tail(&ua->ua_nacl_list,\n\t\t\t\t&deve->ua_list);\n\t\tspin_unlock(&deve->ua_lock);\n\n\t\treturn 0;\n\t}\n\tlist_add_tail(&ua->ua_nacl_list, &deve->ua_list);\n\tspin_unlock(&deve->ua_lock);\n\n\tpr_debug(\"Allocated UNIT ATTENTION, mapped LUN: %llu, ASC:\"\n\t\t\" 0x%02x, ASCQ: 0x%02x\\n\", deve->mapped_lun,\n\t\tasc, ascq);\n\n\treturn 0;\n}\n\nvoid target_ua_allocate_lun(struct se_node_acl *nacl,\n\t\t\t    u32 unpacked_lun, u8 asc, u8 ascq)\n{\n\tstruct se_dev_entry *deve;\n\n\tif (!nacl)\n\t\treturn;\n\n\trcu_read_lock();\n\tdeve = target_nacl_find_deve(nacl, unpacked_lun);\n\tif (!deve) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tcore_scsi3_ua_allocate(deve, asc, ascq);\n\trcu_read_unlock();\n}\n\nvoid core_scsi3_ua_release_all(\n\tstruct se_dev_entry *deve)\n{\n\tstruct se_ua *ua, *ua_p;\n\n\tspin_lock(&deve->ua_lock);\n\tlist_for_each_entry_safe(ua, ua_p, &deve->ua_list, ua_nacl_list) {\n\t\tlist_del(&ua->ua_nacl_list);\n\t\tkmem_cache_free(se_ua_cache, ua);\n\t}\n\tspin_unlock(&deve->ua_lock);\n}\n\n \nbool core_scsi3_ua_for_check_condition(struct se_cmd *cmd, u8 *key, u8 *asc,\n\t\t\t\t       u8 *ascq)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_dev_entry *deve;\n\tstruct se_session *sess = cmd->se_sess;\n\tstruct se_node_acl *nacl;\n\tstruct se_ua *ua = NULL, *ua_p;\n\tint head = 1;\n\tbool dev_ua_intlck_clear = (dev->dev_attrib.emulate_ua_intlck_ctrl\n\t\t\t\t\t\t== TARGET_UA_INTLCK_CTRL_CLEAR);\n\n\tif (WARN_ON_ONCE(!sess))\n\t\treturn false;\n\n\tnacl = sess->se_node_acl;\n\tif (WARN_ON_ONCE(!nacl))\n\t\treturn false;\n\n\trcu_read_lock();\n\tdeve = target_nacl_find_deve(nacl, cmd->orig_fe_lun);\n\tif (!deve) {\n\t\trcu_read_unlock();\n\t\t*key = ILLEGAL_REQUEST;\n\t\t*asc = 0x25;  \n\t\t*ascq = 0;\n\t\treturn true;\n\t}\n\t*key = UNIT_ATTENTION;\n\t \n\tspin_lock(&deve->ua_lock);\n\tlist_for_each_entry_safe(ua, ua_p, &deve->ua_list, ua_nacl_list) {\n\t\t \n\t\tif (!dev_ua_intlck_clear) {\n\t\t\t*asc = ua->ua_asc;\n\t\t\t*ascq = ua->ua_ascq;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (head) {\n\t\t\t*asc = ua->ua_asc;\n\t\t\t*ascq = ua->ua_ascq;\n\t\t\thead = 0;\n\t\t}\n\t\tlist_del(&ua->ua_nacl_list);\n\t\tkmem_cache_free(se_ua_cache, ua);\n\t}\n\tspin_unlock(&deve->ua_lock);\n\trcu_read_unlock();\n\n\tpr_debug(\"[%s]: %s UNIT ATTENTION condition with\"\n\t\t\" INTLCK_CTRL: %d, mapped LUN: %llu, got CDB: 0x%02x\"\n\t\t\" reported ASC: 0x%02x, ASCQ: 0x%02x\\n\",\n\t\tnacl->se_tpg->se_tpg_tfo->fabric_name,\n\t\tdev_ua_intlck_clear ? \"Releasing\" : \"Reporting\",\n\t\tdev->dev_attrib.emulate_ua_intlck_ctrl,\n\t\tcmd->orig_fe_lun, cmd->t_task_cdb[0], *asc, *ascq);\n\n\treturn head == 0;\n}\n\nint core_scsi3_ua_clear_for_request_sense(\n\tstruct se_cmd *cmd,\n\tu8 *asc,\n\tu8 *ascq)\n{\n\tstruct se_dev_entry *deve;\n\tstruct se_session *sess = cmd->se_sess;\n\tstruct se_node_acl *nacl;\n\tstruct se_ua *ua = NULL, *ua_p;\n\tint head = 1;\n\n\tif (!sess)\n\t\treturn -EINVAL;\n\n\tnacl = sess->se_node_acl;\n\tif (!nacl)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tdeve = target_nacl_find_deve(nacl, cmd->orig_fe_lun);\n\tif (!deve) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\tif (list_empty_careful(&deve->ua_list)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\t \n\tspin_lock(&deve->ua_lock);\n\tlist_for_each_entry_safe(ua, ua_p, &deve->ua_list, ua_nacl_list) {\n\t\tif (head) {\n\t\t\t*asc = ua->ua_asc;\n\t\t\t*ascq = ua->ua_ascq;\n\t\t\thead = 0;\n\t\t}\n\t\tlist_del(&ua->ua_nacl_list);\n\t\tkmem_cache_free(se_ua_cache, ua);\n\t}\n\tspin_unlock(&deve->ua_lock);\n\trcu_read_unlock();\n\n\tpr_debug(\"[%s]: Released UNIT ATTENTION condition, mapped\"\n\t\t\" LUN: %llu, got REQUEST_SENSE reported ASC: 0x%02x,\"\n\t\t\" ASCQ: 0x%02x\\n\", nacl->se_tpg->se_tpg_tfo->fabric_name,\n\t\tcmd->orig_fe_lun, *asc, *ascq);\n\n\treturn (head) ? -EPERM : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}