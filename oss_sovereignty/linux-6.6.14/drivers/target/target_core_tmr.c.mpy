{
  "module_name": "target_core_tmr.c",
  "hash_id": "26c90200c8f42896bc7a2d7758baf3f2ae377f198a6d120adf7b931364e5650b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_tmr.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/export.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n#include <target/target_core_fabric.h>\n\n#include \"target_core_internal.h\"\n#include \"target_core_alua.h\"\n#include \"target_core_pr.h\"\n\nint core_tmr_alloc_req(\n\tstruct se_cmd *se_cmd,\n\tvoid *fabric_tmr_ptr,\n\tu8 function,\n\tgfp_t gfp_flags)\n{\n\tstruct se_tmr_req *tmr;\n\n\ttmr = kzalloc(sizeof(struct se_tmr_req), gfp_flags);\n\tif (!tmr) {\n\t\tpr_err(\"Unable to allocate struct se_tmr_req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tse_cmd->se_cmd_flags |= SCF_SCSI_TMR_CDB;\n\tse_cmd->se_tmr_req = tmr;\n\ttmr->task_cmd = se_cmd;\n\ttmr->fabric_tmr_ptr = fabric_tmr_ptr;\n\ttmr->function = function;\n\tINIT_LIST_HEAD(&tmr->tmr_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(core_tmr_alloc_req);\n\nvoid core_tmr_release_req(struct se_tmr_req *tmr)\n{\n\tkfree(tmr);\n}\n\nstatic int target_check_cdb_and_preempt(struct list_head *list,\n\t\tstruct se_cmd *cmd)\n{\n\tstruct t10_pr_registration *reg;\n\n\tif (!list)\n\t\treturn 0;\n\tlist_for_each_entry(reg, list, pr_reg_abort_list) {\n\t\tif (reg->pr_res_key == cmd->pr_res_key)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic bool __target_check_io_state(struct se_cmd *se_cmd,\n\t\t\t\t    struct se_session *tmr_sess, bool tas)\n{\n\tstruct se_session *sess = se_cmd->se_sess;\n\n\tlockdep_assert_held(&sess->sess_cmd_lock);\n\n\t \n\tspin_lock(&se_cmd->t_state_lock);\n\tif (se_cmd->transport_state & (CMD_T_COMPLETE | CMD_T_FABRIC_STOP)) {\n\t\tpr_debug(\"Attempted to abort io tag: %llu already complete or\"\n\t\t\t\" fabric stop, skipping\\n\", se_cmd->tag);\n\t\tspin_unlock(&se_cmd->t_state_lock);\n\t\treturn false;\n\t}\n\tse_cmd->transport_state |= CMD_T_ABORTED;\n\n\tif ((tmr_sess != se_cmd->se_sess) && tas)\n\t\tse_cmd->transport_state |= CMD_T_TAS;\n\n\tspin_unlock(&se_cmd->t_state_lock);\n\n\treturn kref_get_unless_zero(&se_cmd->cmd_kref);\n}\n\nvoid core_tmr_abort_task(\n\tstruct se_device *dev,\n\tstruct se_tmr_req *tmr,\n\tstruct se_session *se_sess)\n{\n\tLIST_HEAD(aborted_list);\n\tstruct se_cmd *se_cmd, *next;\n\tunsigned long flags;\n\tbool rc;\n\tu64 ref_tag;\n\tint i;\n\n\tfor (i = 0; i < dev->queue_cnt; i++) {\n\t\tflush_work(&dev->queues[i].sq.work);\n\n\t\tspin_lock_irqsave(&dev->queues[i].lock, flags);\n\t\tlist_for_each_entry_safe(se_cmd, next, &dev->queues[i].state_list,\n\t\t\t\t\t state_list) {\n\t\t\tif (se_sess != se_cmd->se_sess)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)\n\t\t\t\tcontinue;\n\n\t\t\tref_tag = se_cmd->tag;\n\t\t\tif (tmr->ref_task_tag != ref_tag)\n\t\t\t\tcontinue;\n\n\t\t\tpr_err(\"ABORT_TASK: Found referenced %s task_tag: %llu\\n\",\n\t\t\t       se_cmd->se_tfo->fabric_name, ref_tag);\n\n\t\t\tspin_lock(&se_sess->sess_cmd_lock);\n\t\t\trc = __target_check_io_state(se_cmd, se_sess, 0);\n\t\t\tspin_unlock(&se_sess->sess_cmd_lock);\n\t\t\tif (!rc)\n\t\t\t\tcontinue;\n\n\t\t\tlist_move_tail(&se_cmd->state_list, &aborted_list);\n\t\t\tse_cmd->state_active = false;\n\t\t\tspin_unlock_irqrestore(&dev->queues[i].lock, flags);\n\n\t\t\tif (dev->transport->tmr_notify)\n\t\t\t\tdev->transport->tmr_notify(dev, TMR_ABORT_TASK,\n\t\t\t\t\t\t\t   &aborted_list);\n\n\t\t\tlist_del_init(&se_cmd->state_list);\n\t\t\ttarget_put_cmd_and_wait(se_cmd);\n\n\t\t\tpr_err(\"ABORT_TASK: Sending TMR_FUNCTION_COMPLETE for ref_tag: %llu\\n\",\n\t\t\t       ref_tag);\n\t\t\ttmr->response = TMR_FUNCTION_COMPLETE;\n\t\t\tatomic_long_inc(&dev->aborts_complete);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&dev->queues[i].lock, flags);\n\t}\n\n\tif (dev->transport->tmr_notify)\n\t\tdev->transport->tmr_notify(dev, TMR_ABORT_TASK, &aborted_list);\n\n\tprintk(\"ABORT_TASK: Sending TMR_TASK_DOES_NOT_EXIST for ref_tag: %lld\\n\",\n\t\t\ttmr->ref_task_tag);\n\ttmr->response = TMR_TASK_DOES_NOT_EXIST;\n\tatomic_long_inc(&dev->aborts_no_task);\n}\n\nstatic void core_tmr_drain_tmr_list(\n\tstruct se_device *dev,\n\tstruct se_tmr_req *tmr,\n\tstruct list_head *preempt_and_abort_list)\n{\n\tLIST_HEAD(drain_tmr_list);\n\tstruct se_session *sess;\n\tstruct se_tmr_req *tmr_p, *tmr_pp;\n\tstruct se_cmd *cmd;\n\tunsigned long flags;\n\tbool rc;\n\t \n\tspin_lock_irqsave(&dev->se_tmr_lock, flags);\n\tlist_for_each_entry_safe(tmr_p, tmr_pp, &dev->dev_tmr_list, tmr_list) {\n\t\tif (tmr_p == tmr)\n\t\t\tcontinue;\n\n\t\tcmd = tmr_p->task_cmd;\n\t\tif (!cmd) {\n\t\t\tpr_err(\"Unable to locate struct se_cmd for TMR\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (tmr_p->function == TMR_LUN_RESET)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (target_check_cdb_and_preempt(preempt_and_abort_list, cmd))\n\t\t\tcontinue;\n\n\t\tsess = cmd->se_sess;\n\t\tif (WARN_ON_ONCE(!sess))\n\t\t\tcontinue;\n\n\t\tspin_lock(&sess->sess_cmd_lock);\n\t\trc = __target_check_io_state(cmd, sess, 0);\n\t\tspin_unlock(&sess->sess_cmd_lock);\n\n\t\tif (!rc) {\n\t\t\tprintk(\"LUN_RESET TMR: non-zero kref_get_unless_zero\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_move_tail(&tmr_p->tmr_list, &drain_tmr_list);\n\t\ttmr_p->tmr_dev = NULL;\n\t}\n\tspin_unlock_irqrestore(&dev->se_tmr_lock, flags);\n\n\tlist_for_each_entry_safe(tmr_p, tmr_pp, &drain_tmr_list, tmr_list) {\n\t\tlist_del_init(&tmr_p->tmr_list);\n\t\tcmd = tmr_p->task_cmd;\n\n\t\tpr_debug(\"LUN_RESET: %s releasing TMR %p Function: 0x%02x,\"\n\t\t\t\" Response: 0x%02x, t_state: %d\\n\",\n\t\t\t(preempt_and_abort_list) ? \"Preempt\" : \"\", tmr_p,\n\t\t\ttmr_p->function, tmr_p->response, cmd->t_state);\n\n\t\ttarget_put_cmd_and_wait(cmd);\n\t}\n}\n\n \nstatic void core_tmr_drain_state_list(\n\tstruct se_device *dev,\n\tstruct se_cmd *prout_cmd,\n\tstruct se_session *tmr_sess,\n\tbool tas,\n\tstruct list_head *preempt_and_abort_list)\n{\n\tLIST_HEAD(drain_task_list);\n\tstruct se_session *sess;\n\tstruct se_cmd *cmd, *next;\n\tunsigned long flags;\n\tint rc, i;\n\n\t \n\tfor (i = 0; i < dev->queue_cnt; i++) {\n\t\tflush_work(&dev->queues[i].sq.work);\n\n\t\tspin_lock_irqsave(&dev->queues[i].lock, flags);\n\t\tlist_for_each_entry_safe(cmd, next, &dev->queues[i].state_list,\n\t\t\t\t\t state_list) {\n\t\t\t \n\t\t\tif (target_check_cdb_and_preempt(preempt_and_abort_list,\n\t\t\t\t\t\t\t cmd))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (prout_cmd == cmd)\n\t\t\t\tcontinue;\n\n\t\t\tsess = cmd->se_sess;\n\t\t\tif (WARN_ON_ONCE(!sess))\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock(&sess->sess_cmd_lock);\n\t\t\trc = __target_check_io_state(cmd, tmr_sess, tas);\n\t\t\tspin_unlock(&sess->sess_cmd_lock);\n\t\t\tif (!rc)\n\t\t\t\tcontinue;\n\n\t\t\tlist_move_tail(&cmd->state_list, &drain_task_list);\n\t\t\tcmd->state_active = false;\n\t\t}\n\t\tspin_unlock_irqrestore(&dev->queues[i].lock, flags);\n\t}\n\n\tif (dev->transport->tmr_notify)\n\t\tdev->transport->tmr_notify(dev, preempt_and_abort_list ?\n\t\t\t\t\t   TMR_LUN_RESET_PRO : TMR_LUN_RESET,\n\t\t\t\t\t   &drain_task_list);\n\n\twhile (!list_empty(&drain_task_list)) {\n\t\tcmd = list_entry(drain_task_list.next, struct se_cmd, state_list);\n\t\tlist_del_init(&cmd->state_list);\n\n\t\ttarget_show_cmd(\"LUN_RESET: \", cmd);\n\t\tpr_debug(\"LUN_RESET: ITT[0x%08llx] - %s pr_res_key: 0x%016Lx\\n\",\n\t\t\t cmd->tag, (preempt_and_abort_list) ? \"preempt\" : \"\",\n\t\t\t cmd->pr_res_key);\n\n\t\ttarget_put_cmd_and_wait(cmd);\n\t}\n}\n\nint core_tmr_lun_reset(\n        struct se_device *dev,\n        struct se_tmr_req *tmr,\n        struct list_head *preempt_and_abort_list,\n        struct se_cmd *prout_cmd)\n{\n\tstruct se_node_acl *tmr_nacl = NULL;\n\tstruct se_portal_group *tmr_tpg = NULL;\n\tstruct se_session *tmr_sess = NULL;\n\tbool tas;\n         \n\ttas = dev->dev_attrib.emulate_tas;\n\t \n\tif (tmr && tmr->task_cmd && tmr->task_cmd->se_sess) {\n\t\ttmr_sess = tmr->task_cmd->se_sess;\n\t\ttmr_nacl = tmr_sess->se_node_acl;\n\t\ttmr_tpg = tmr_sess->se_tpg;\n\t\tif (tmr_nacl && tmr_tpg) {\n\t\t\tpr_debug(\"LUN_RESET: TMR caller fabric: %s\"\n\t\t\t\t\" initiator port %s\\n\",\n\t\t\t\ttmr_tpg->se_tpg_tfo->fabric_name,\n\t\t\t\ttmr_nacl->initiatorname);\n\t\t}\n\t}\n\n\n\t \n\tmutex_lock(&dev->lun_reset_mutex);\n\n\tpr_debug(\"LUN_RESET: %s starting for [%s], tas: %d\\n\",\n\t\t(preempt_and_abort_list) ? \"Preempt\" : \"TMR\",\n\t\tdev->transport->name, tas);\n\tcore_tmr_drain_tmr_list(dev, tmr, preempt_and_abort_list);\n\tcore_tmr_drain_state_list(dev, prout_cmd, tmr_sess, tas,\n\t\t\t\tpreempt_and_abort_list);\n\n\tmutex_unlock(&dev->lun_reset_mutex);\n\n\t \n\tif (!preempt_and_abort_list &&\n\t     (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS)) {\n\t\tspin_lock(&dev->dev_reservation_lock);\n\t\tdev->reservation_holder = NULL;\n\t\tdev->dev_reservation_flags &= ~DRF_SPC2_RESERVATIONS;\n\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\tpr_debug(\"LUN_RESET: SCSI-2 Released reservation\\n\");\n\t}\n\n\tatomic_long_inc(&dev->num_resets);\n\n\tpr_debug(\"LUN_RESET: %s for [%s] Complete\\n\",\n\t\t\t(preempt_and_abort_list) ? \"Preempt\" : \"TMR\",\n\t\t\tdev->transport->name);\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}