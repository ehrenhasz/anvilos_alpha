{
  "module_name": "sbp_target.c",
  "hash_id": "8e66e86ac51f496fa533ac83699ada8d5c5738789bda66dad9c52a769d8da0b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/sbp/sbp_target.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"sbp_target\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/configfs.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <scsi/scsi_proto.h>\n#include <scsi/scsi_tcq.h>\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n#include <target/target_core_fabric.h>\n#include <asm/unaligned.h>\n\n#include \"sbp_target.h\"\n\n \nstatic const struct fw_address_region sbp_register_region = {\n\t.start\t= CSR_REGISTER_BASE + 0x10000,\n\t.end\t= 0x1000000000000ULL,\n};\n\nstatic const u32 sbp_unit_directory_template[] = {\n\t0x1200609e,  \n\t0x13010483,  \n\t0x3800609e,  \n\t0x390104d8,  \n\t0x3b000000,  \n\t0x3c000001,  \n};\n\n#define SESSION_MAINTENANCE_INTERVAL HZ\n\nstatic atomic_t login_id = ATOMIC_INIT(0);\n\nstatic void session_maintenance_work(struct work_struct *);\nstatic int sbp_run_transaction(struct fw_card *, int, int, int, int,\n\t\tunsigned long long, void *, size_t);\n\nstatic int read_peer_guid(u64 *guid, const struct sbp_management_request *req)\n{\n\tint ret;\n\t__be32 high, low;\n\n\tret = sbp_run_transaction(req->card, TCODE_READ_QUADLET_REQUEST,\n\t\t\treq->node_addr, req->generation, req->speed,\n\t\t\t(CSR_REGISTER_BASE | CSR_CONFIG_ROM) + 3 * 4,\n\t\t\t&high, sizeof(high));\n\tif (ret != RCODE_COMPLETE)\n\t\treturn ret;\n\n\tret = sbp_run_transaction(req->card, TCODE_READ_QUADLET_REQUEST,\n\t\t\treq->node_addr, req->generation, req->speed,\n\t\t\t(CSR_REGISTER_BASE | CSR_CONFIG_ROM) + 4 * 4,\n\t\t\t&low, sizeof(low));\n\tif (ret != RCODE_COMPLETE)\n\t\treturn ret;\n\n\t*guid = (u64)be32_to_cpu(high) << 32 | be32_to_cpu(low);\n\n\treturn RCODE_COMPLETE;\n}\n\nstatic struct sbp_session *sbp_session_find_by_guid(\n\tstruct sbp_tpg *tpg, u64 guid)\n{\n\tstruct se_session *se_sess;\n\tstruct sbp_session *sess, *found = NULL;\n\n\tspin_lock_bh(&tpg->se_tpg.session_lock);\n\tlist_for_each_entry(se_sess, &tpg->se_tpg.tpg_sess_list, sess_list) {\n\t\tsess = se_sess->fabric_sess_ptr;\n\t\tif (sess->guid == guid)\n\t\t\tfound = sess;\n\t}\n\tspin_unlock_bh(&tpg->se_tpg.session_lock);\n\n\treturn found;\n}\n\nstatic struct sbp_login_descriptor *sbp_login_find_by_lun(\n\t\tstruct sbp_session *session, u32 unpacked_lun)\n{\n\tstruct sbp_login_descriptor *login, *found = NULL;\n\n\tspin_lock_bh(&session->lock);\n\tlist_for_each_entry(login, &session->login_list, link) {\n\t\tif (login->login_lun == unpacked_lun)\n\t\t\tfound = login;\n\t}\n\tspin_unlock_bh(&session->lock);\n\n\treturn found;\n}\n\nstatic int sbp_login_count_all_by_lun(\n\t\tstruct sbp_tpg *tpg,\n\t\tu32 unpacked_lun,\n\t\tint exclusive)\n{\n\tstruct se_session *se_sess;\n\tstruct sbp_session *sess;\n\tstruct sbp_login_descriptor *login;\n\tint count = 0;\n\n\tspin_lock_bh(&tpg->se_tpg.session_lock);\n\tlist_for_each_entry(se_sess, &tpg->se_tpg.tpg_sess_list, sess_list) {\n\t\tsess = se_sess->fabric_sess_ptr;\n\n\t\tspin_lock_bh(&sess->lock);\n\t\tlist_for_each_entry(login, &sess->login_list, link) {\n\t\t\tif (login->login_lun != unpacked_lun)\n\t\t\t\tcontinue;\n\n\t\t\tif (!exclusive || login->exclusive)\n\t\t\t\tcount++;\n\t\t}\n\t\tspin_unlock_bh(&sess->lock);\n\t}\n\tspin_unlock_bh(&tpg->se_tpg.session_lock);\n\n\treturn count;\n}\n\nstatic struct sbp_login_descriptor *sbp_login_find_by_id(\n\tstruct sbp_tpg *tpg, int login_id)\n{\n\tstruct se_session *se_sess;\n\tstruct sbp_session *sess;\n\tstruct sbp_login_descriptor *login, *found = NULL;\n\n\tspin_lock_bh(&tpg->se_tpg.session_lock);\n\tlist_for_each_entry(se_sess, &tpg->se_tpg.tpg_sess_list, sess_list) {\n\t\tsess = se_sess->fabric_sess_ptr;\n\n\t\tspin_lock_bh(&sess->lock);\n\t\tlist_for_each_entry(login, &sess->login_list, link) {\n\t\t\tif (login->login_id == login_id)\n\t\t\t\tfound = login;\n\t\t}\n\t\tspin_unlock_bh(&sess->lock);\n\t}\n\tspin_unlock_bh(&tpg->se_tpg.session_lock);\n\n\treturn found;\n}\n\nstatic u32 sbp_get_lun_from_tpg(struct sbp_tpg *tpg, u32 login_lun, int *err)\n{\n\tstruct se_portal_group *se_tpg = &tpg->se_tpg;\n\tstruct se_lun *se_lun;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(se_lun, &se_tpg->tpg_lun_hlist, link) {\n\t\tif (se_lun->unpacked_lun == login_lun) {\n\t\t\trcu_read_unlock();\n\t\t\t*err = 0;\n\t\t\treturn login_lun;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t*err = -ENODEV;\n\treturn login_lun;\n}\n\nstatic struct sbp_session *sbp_session_create(\n\t\tstruct sbp_tpg *tpg,\n\t\tu64 guid)\n{\n\tstruct sbp_session *sess;\n\tint ret;\n\tchar guid_str[17];\n\n\tsnprintf(guid_str, sizeof(guid_str), \"%016llx\", guid);\n\n\tsess = kmalloc(sizeof(*sess), GFP_KERNEL);\n\tif (!sess)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&sess->lock);\n\tINIT_LIST_HEAD(&sess->login_list);\n\tINIT_DELAYED_WORK(&sess->maint_work, session_maintenance_work);\n\tsess->guid = guid;\n\n\tsess->se_sess = target_setup_session(&tpg->se_tpg, 128,\n\t\t\t\t\t     sizeof(struct sbp_target_request),\n\t\t\t\t\t     TARGET_PROT_NORMAL, guid_str,\n\t\t\t\t\t     sess, NULL);\n\tif (IS_ERR(sess->se_sess)) {\n\t\tpr_err(\"failed to init se_session\\n\");\n\t\tret = PTR_ERR(sess->se_sess);\n\t\tkfree(sess);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn sess;\n}\n\nstatic void sbp_session_release(struct sbp_session *sess, bool cancel_work)\n{\n\tspin_lock_bh(&sess->lock);\n\tif (!list_empty(&sess->login_list)) {\n\t\tspin_unlock_bh(&sess->lock);\n\t\treturn;\n\t}\n\tspin_unlock_bh(&sess->lock);\n\n\tif (cancel_work)\n\t\tcancel_delayed_work_sync(&sess->maint_work);\n\n\ttarget_remove_session(sess->se_sess);\n\n\tif (sess->card)\n\t\tfw_card_put(sess->card);\n\n\tkfree(sess);\n}\n\nstatic void sbp_target_agent_unregister(struct sbp_target_agent *);\n\nstatic void sbp_login_release(struct sbp_login_descriptor *login,\n\tbool cancel_work)\n{\n\tstruct sbp_session *sess = login->sess;\n\n\t \n\n\tsbp_target_agent_unregister(login->tgt_agt);\n\n\tif (sess) {\n\t\tspin_lock_bh(&sess->lock);\n\t\tlist_del(&login->link);\n\t\tspin_unlock_bh(&sess->lock);\n\n\t\tsbp_session_release(sess, cancel_work);\n\t}\n\n\tkfree(login);\n}\n\nstatic struct sbp_target_agent *sbp_target_agent_register(\n\tstruct sbp_login_descriptor *);\n\nstatic void sbp_management_request_login(\n\tstruct sbp_management_agent *agent, struct sbp_management_request *req,\n\tint *status_data_size)\n{\n\tstruct sbp_tport *tport = agent->tport;\n\tstruct sbp_tpg *tpg = tport->tpg;\n\tstruct sbp_session *sess;\n\tstruct sbp_login_descriptor *login;\n\tstruct sbp_login_response_block *response;\n\tu64 guid;\n\tu32 unpacked_lun;\n\tint login_response_len, ret;\n\n\tunpacked_lun = sbp_get_lun_from_tpg(tpg,\n\t\t\tLOGIN_ORB_LUN(be32_to_cpu(req->orb.misc)), &ret);\n\tif (ret) {\n\t\tpr_notice(\"login to unknown LUN: %d\\n\",\n\t\t\tLOGIN_ORB_LUN(be32_to_cpu(req->orb.misc)));\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_LUN_NOTSUPP));\n\t\treturn;\n\t}\n\n\tret = read_peer_guid(&guid, req);\n\tif (ret != RCODE_COMPLETE) {\n\t\tpr_warn(\"failed to read peer GUID: %d\\n\", ret);\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_TRANSPORT_FAILURE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_UNSPECIFIED_ERROR));\n\t\treturn;\n\t}\n\n\tpr_notice(\"mgt_agent LOGIN to LUN %d from %016llx\\n\",\n\t\tunpacked_lun, guid);\n\n\tsess = sbp_session_find_by_guid(tpg, guid);\n\tif (sess) {\n\t\tlogin = sbp_login_find_by_lun(sess, unpacked_lun);\n\t\tif (login) {\n\t\t\tpr_notice(\"initiator already logged-in\\n\");\n\n\t\t\t \n\n\t\t\tgoto already_logged_in;\n\t\t}\n\t}\n\n\t \n\tif (LOGIN_ORB_EXCLUSIVE(be32_to_cpu(req->orb.misc)) &&\n\t\t\tsbp_login_count_all_by_lun(tpg, unpacked_lun, 0)) {\n\t\tpr_warn(\"refusing exclusive login with other active logins\\n\");\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_ACCESS_DENIED));\n\t\treturn;\n\t}\n\n\t \n\tif (sbp_login_count_all_by_lun(tpg, unpacked_lun, 1)) {\n\t\tpr_warn(\"refusing login while another exclusive login present\\n\");\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_ACCESS_DENIED));\n\t\treturn;\n\t}\n\n\t \n\tif (sbp_login_count_all_by_lun(tpg, unpacked_lun, 0) >=\n\t\t\ttport->max_logins_per_lun) {\n\t\tpr_warn(\"max number of logins reached\\n\");\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_RESOURCES_UNAVAIL));\n\t\treturn;\n\t}\n\n\tif (!sess) {\n\t\tsess = sbp_session_create(tpg, guid);\n\t\tif (IS_ERR(sess)) {\n\t\t\tswitch (PTR_ERR(sess)) {\n\t\t\tcase -EPERM:\n\t\t\t\tret = SBP_STATUS_ACCESS_DENIED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = SBP_STATUS_RESOURCES_UNAVAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treq->status.status = cpu_to_be32(\n\t\t\t\tSTATUS_BLOCK_RESP(\n\t\t\t\t\tSTATUS_RESP_REQUEST_COMPLETE) |\n\t\t\t\tSTATUS_BLOCK_SBP_STATUS(ret));\n\t\t\treturn;\n\t\t}\n\n\t\tsess->node_id = req->node_addr;\n\t\tsess->card = fw_card_get(req->card);\n\t\tsess->generation = req->generation;\n\t\tsess->speed = req->speed;\n\n\t\tschedule_delayed_work(&sess->maint_work,\n\t\t\t\tSESSION_MAINTENANCE_INTERVAL);\n\t}\n\n\t \n\tsess->reconnect_hold = min(\n\t\t1 << LOGIN_ORB_RECONNECT(be32_to_cpu(req->orb.misc)),\n\t\ttport->max_reconnect_timeout) - 1;\n\n\tlogin = kmalloc(sizeof(*login), GFP_KERNEL);\n\tif (!login) {\n\t\tpr_err(\"failed to allocate login descriptor\\n\");\n\n\t\tsbp_session_release(sess, true);\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_RESOURCES_UNAVAIL));\n\t\treturn;\n\t}\n\n\tlogin->sess = sess;\n\tlogin->login_lun = unpacked_lun;\n\tlogin->status_fifo_addr = sbp2_pointer_to_addr(&req->orb.status_fifo);\n\tlogin->exclusive = LOGIN_ORB_EXCLUSIVE(be32_to_cpu(req->orb.misc));\n\tlogin->login_id = atomic_inc_return(&login_id);\n\n\tlogin->tgt_agt = sbp_target_agent_register(login);\n\tif (IS_ERR(login->tgt_agt)) {\n\t\tret = PTR_ERR(login->tgt_agt);\n\t\tpr_err(\"failed to map command block handler: %d\\n\", ret);\n\n\t\tsbp_session_release(sess, true);\n\t\tkfree(login);\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_RESOURCES_UNAVAIL));\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&sess->lock);\n\tlist_add_tail(&login->link, &sess->login_list);\n\tspin_unlock_bh(&sess->lock);\n\nalready_logged_in:\n\tresponse = kzalloc(sizeof(*response), GFP_KERNEL);\n\tif (!response) {\n\t\tpr_err(\"failed to allocate login response block\\n\");\n\n\t\tsbp_login_release(login, true);\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_RESOURCES_UNAVAIL));\n\t\treturn;\n\t}\n\n\tlogin_response_len = clamp_val(\n\t\t\tLOGIN_ORB_RESPONSE_LENGTH(be32_to_cpu(req->orb.length)),\n\t\t\t12, sizeof(*response));\n\tresponse->misc = cpu_to_be32(\n\t\t((login_response_len & 0xffff) << 16) |\n\t\t(login->login_id & 0xffff));\n\tresponse->reconnect_hold = cpu_to_be32(sess->reconnect_hold & 0xffff);\n\taddr_to_sbp2_pointer(login->tgt_agt->handler.offset,\n\t\t&response->command_block_agent);\n\n\tret = sbp_run_transaction(sess->card, TCODE_WRITE_BLOCK_REQUEST,\n\t\tsess->node_id, sess->generation, sess->speed,\n\t\tsbp2_pointer_to_addr(&req->orb.ptr2), response,\n\t\tlogin_response_len);\n\tif (ret != RCODE_COMPLETE) {\n\t\tpr_debug(\"failed to write login response block: %x\\n\", ret);\n\n\t\tkfree(response);\n\t\tsbp_login_release(login, true);\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_TRANSPORT_FAILURE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_UNSPECIFIED_ERROR));\n\t\treturn;\n\t}\n\n\tkfree(response);\n\n\treq->status.status = cpu_to_be32(\n\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_OK));\n}\n\nstatic void sbp_management_request_query_logins(\n\tstruct sbp_management_agent *agent, struct sbp_management_request *req,\n\tint *status_data_size)\n{\n\tpr_notice(\"QUERY LOGINS not implemented\\n\");\n\t \n\n\treq->status.status = cpu_to_be32(\n\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\n}\n\nstatic void sbp_management_request_reconnect(\n\tstruct sbp_management_agent *agent, struct sbp_management_request *req,\n\tint *status_data_size)\n{\n\tstruct sbp_tport *tport = agent->tport;\n\tstruct sbp_tpg *tpg = tport->tpg;\n\tint ret;\n\tu64 guid;\n\tstruct sbp_login_descriptor *login;\n\n\tret = read_peer_guid(&guid, req);\n\tif (ret != RCODE_COMPLETE) {\n\t\tpr_warn(\"failed to read peer GUID: %d\\n\", ret);\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_TRANSPORT_FAILURE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_UNSPECIFIED_ERROR));\n\t\treturn;\n\t}\n\n\tpr_notice(\"mgt_agent RECONNECT from %016llx\\n\", guid);\n\n\tlogin = sbp_login_find_by_id(tpg,\n\t\tRECONNECT_ORB_LOGIN_ID(be32_to_cpu(req->orb.misc)));\n\n\tif (!login) {\n\t\tpr_err(\"mgt_agent RECONNECT unknown login ID\\n\");\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_ACCESS_DENIED));\n\t\treturn;\n\t}\n\n\tif (login->sess->guid != guid) {\n\t\tpr_err(\"mgt_agent RECONNECT login GUID doesn't match\\n\");\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_ACCESS_DENIED));\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&login->sess->lock);\n\tif (login->sess->card)\n\t\tfw_card_put(login->sess->card);\n\n\t \n\tlogin->sess->generation = req->generation;\n\tlogin->sess->node_id = req->node_addr;\n\tlogin->sess->card = fw_card_get(req->card);\n\tlogin->sess->speed = req->speed;\n\tspin_unlock_bh(&login->sess->lock);\n\n\treq->status.status = cpu_to_be32(\n\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_OK));\n}\n\nstatic void sbp_management_request_logout(\n\tstruct sbp_management_agent *agent, struct sbp_management_request *req,\n\tint *status_data_size)\n{\n\tstruct sbp_tport *tport = agent->tport;\n\tstruct sbp_tpg *tpg = tport->tpg;\n\tint id;\n\tstruct sbp_login_descriptor *login;\n\n\tid = LOGOUT_ORB_LOGIN_ID(be32_to_cpu(req->orb.misc));\n\n\tlogin = sbp_login_find_by_id(tpg, id);\n\tif (!login) {\n\t\tpr_warn(\"cannot find login: %d\\n\", id);\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_LOGIN_ID_UNKNOWN));\n\t\treturn;\n\t}\n\n\tpr_info(\"mgt_agent LOGOUT from LUN %d session %d\\n\",\n\t\tlogin->login_lun, login->login_id);\n\n\tif (req->node_addr != login->sess->node_id) {\n\t\tpr_warn(\"logout from different node ID\\n\");\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_ACCESS_DENIED));\n\t\treturn;\n\t}\n\n\tsbp_login_release(login, true);\n\n\treq->status.status = cpu_to_be32(\n\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_OK));\n}\n\nstatic void session_check_for_reset(struct sbp_session *sess)\n{\n\tbool card_valid = false;\n\n\tspin_lock_bh(&sess->lock);\n\n\tif (sess->card) {\n\t\tspin_lock_irq(&sess->card->lock);\n\t\tcard_valid = (sess->card->local_node != NULL);\n\t\tspin_unlock_irq(&sess->card->lock);\n\n\t\tif (!card_valid) {\n\t\t\tfw_card_put(sess->card);\n\t\t\tsess->card = NULL;\n\t\t}\n\t}\n\n\tif (!card_valid || (sess->generation != sess->card->generation)) {\n\t\tpr_info(\"Waiting for reconnect from node: %016llx\\n\",\n\t\t\t\tsess->guid);\n\n\t\tsess->node_id = -1;\n\t\tsess->reconnect_expires = get_jiffies_64() +\n\t\t\t((sess->reconnect_hold + 1) * HZ);\n\t}\n\n\tspin_unlock_bh(&sess->lock);\n}\n\nstatic void session_reconnect_expired(struct sbp_session *sess)\n{\n\tstruct sbp_login_descriptor *login, *temp;\n\tLIST_HEAD(login_list);\n\n\tpr_info(\"Reconnect timer expired for node: %016llx\\n\", sess->guid);\n\n\tspin_lock_bh(&sess->lock);\n\tlist_for_each_entry_safe(login, temp, &sess->login_list, link) {\n\t\tlogin->sess = NULL;\n\t\tlist_move_tail(&login->link, &login_list);\n\t}\n\tspin_unlock_bh(&sess->lock);\n\n\tlist_for_each_entry_safe(login, temp, &login_list, link) {\n\t\tlist_del(&login->link);\n\t\tsbp_login_release(login, false);\n\t}\n\n\tsbp_session_release(sess, false);\n}\n\nstatic void session_maintenance_work(struct work_struct *work)\n{\n\tstruct sbp_session *sess = container_of(work, struct sbp_session,\n\t\t\tmaint_work.work);\n\n\t \n\tspin_lock_bh(&sess->lock);\n\tif (list_empty(&sess->login_list)) {\n\t\tspin_unlock_bh(&sess->lock);\n\t\treturn;\n\t}\n\tspin_unlock_bh(&sess->lock);\n\n\tif (sess->node_id != -1) {\n\t\t \n\t\tsession_check_for_reset(sess);\n\n\t\tschedule_delayed_work(&sess->maint_work,\n\t\t\t\tSESSION_MAINTENANCE_INTERVAL);\n\t} else if (!time_after64(get_jiffies_64(), sess->reconnect_expires)) {\n\t\t \n\t\tschedule_delayed_work(&sess->maint_work,\n\t\t\t\tSESSION_MAINTENANCE_INTERVAL);\n\t} else {\n\t\t \n\t\tsession_reconnect_expired(sess);\n\t}\n}\n\nstatic int tgt_agent_rw_agent_state(struct fw_card *card, int tcode, void *data,\n\t\tstruct sbp_target_agent *agent)\n{\n\tint state;\n\n\tswitch (tcode) {\n\tcase TCODE_READ_QUADLET_REQUEST:\n\t\tpr_debug(\"tgt_agent AGENT_STATE READ\\n\");\n\n\t\tspin_lock_bh(&agent->lock);\n\t\tstate = agent->state;\n\t\tspin_unlock_bh(&agent->lock);\n\n\t\t*(__be32 *)data = cpu_to_be32(state);\n\n\t\treturn RCODE_COMPLETE;\n\n\tcase TCODE_WRITE_QUADLET_REQUEST:\n\t\t \n\t\treturn RCODE_COMPLETE;\n\n\tdefault:\n\t\treturn RCODE_TYPE_ERROR;\n\t}\n}\n\nstatic int tgt_agent_rw_agent_reset(struct fw_card *card, int tcode, void *data,\n\t\tstruct sbp_target_agent *agent)\n{\n\tswitch (tcode) {\n\tcase TCODE_WRITE_QUADLET_REQUEST:\n\t\tpr_debug(\"tgt_agent AGENT_RESET\\n\");\n\t\tspin_lock_bh(&agent->lock);\n\t\tagent->state = AGENT_STATE_RESET;\n\t\tspin_unlock_bh(&agent->lock);\n\t\treturn RCODE_COMPLETE;\n\n\tdefault:\n\t\treturn RCODE_TYPE_ERROR;\n\t}\n}\n\nstatic int tgt_agent_rw_orb_pointer(struct fw_card *card, int tcode, void *data,\n\t\tstruct sbp_target_agent *agent)\n{\n\tstruct sbp2_pointer *ptr = data;\n\n\tswitch (tcode) {\n\tcase TCODE_WRITE_BLOCK_REQUEST:\n\t\tspin_lock_bh(&agent->lock);\n\t\tif (agent->state != AGENT_STATE_SUSPENDED &&\n\t\t\t\tagent->state != AGENT_STATE_RESET) {\n\t\t\tspin_unlock_bh(&agent->lock);\n\t\t\tpr_notice(\"Ignoring ORB_POINTER write while active.\\n\");\n\t\t\treturn RCODE_CONFLICT_ERROR;\n\t\t}\n\t\tagent->state = AGENT_STATE_ACTIVE;\n\t\tspin_unlock_bh(&agent->lock);\n\n\t\tagent->orb_pointer = sbp2_pointer_to_addr(ptr);\n\t\tagent->doorbell = false;\n\n\t\tpr_debug(\"tgt_agent ORB_POINTER write: 0x%llx\\n\",\n\t\t\t\tagent->orb_pointer);\n\n\t\tqueue_work(system_unbound_wq, &agent->work);\n\n\t\treturn RCODE_COMPLETE;\n\n\tcase TCODE_READ_BLOCK_REQUEST:\n\t\tpr_debug(\"tgt_agent ORB_POINTER READ\\n\");\n\t\tspin_lock_bh(&agent->lock);\n\t\taddr_to_sbp2_pointer(agent->orb_pointer, ptr);\n\t\tspin_unlock_bh(&agent->lock);\n\t\treturn RCODE_COMPLETE;\n\n\tdefault:\n\t\treturn RCODE_TYPE_ERROR;\n\t}\n}\n\nstatic int tgt_agent_rw_doorbell(struct fw_card *card, int tcode, void *data,\n\t\tstruct sbp_target_agent *agent)\n{\n\tswitch (tcode) {\n\tcase TCODE_WRITE_QUADLET_REQUEST:\n\t\tspin_lock_bh(&agent->lock);\n\t\tif (agent->state != AGENT_STATE_SUSPENDED) {\n\t\t\tspin_unlock_bh(&agent->lock);\n\t\t\tpr_debug(\"Ignoring DOORBELL while active.\\n\");\n\t\t\treturn RCODE_CONFLICT_ERROR;\n\t\t}\n\t\tagent->state = AGENT_STATE_ACTIVE;\n\t\tspin_unlock_bh(&agent->lock);\n\n\t\tagent->doorbell = true;\n\n\t\tpr_debug(\"tgt_agent DOORBELL\\n\");\n\n\t\tqueue_work(system_unbound_wq, &agent->work);\n\n\t\treturn RCODE_COMPLETE;\n\n\tcase TCODE_READ_QUADLET_REQUEST:\n\t\treturn RCODE_COMPLETE;\n\n\tdefault:\n\t\treturn RCODE_TYPE_ERROR;\n\t}\n}\n\nstatic int tgt_agent_rw_unsolicited_status_enable(struct fw_card *card,\n\t\tint tcode, void *data, struct sbp_target_agent *agent)\n{\n\tswitch (tcode) {\n\tcase TCODE_WRITE_QUADLET_REQUEST:\n\t\tpr_debug(\"tgt_agent UNSOLICITED_STATUS_ENABLE\\n\");\n\t\t \n\t\treturn RCODE_COMPLETE;\n\n\tcase TCODE_READ_QUADLET_REQUEST:\n\t\treturn RCODE_COMPLETE;\n\n\tdefault:\n\t\treturn RCODE_TYPE_ERROR;\n\t}\n}\n\nstatic void tgt_agent_rw(struct fw_card *card, struct fw_request *request,\n\t\tint tcode, int destination, int source, int generation,\n\t\tunsigned long long offset, void *data, size_t length,\n\t\tvoid *callback_data)\n{\n\tstruct sbp_target_agent *agent = callback_data;\n\tstruct sbp_session *sess = agent->login->sess;\n\tint sess_gen, sess_node, rcode;\n\n\tspin_lock_bh(&sess->lock);\n\tsess_gen = sess->generation;\n\tsess_node = sess->node_id;\n\tspin_unlock_bh(&sess->lock);\n\n\tif (generation != sess_gen) {\n\t\tpr_notice(\"ignoring request with wrong generation\\n\");\n\t\trcode = RCODE_TYPE_ERROR;\n\t\tgoto out;\n\t}\n\n\tif (source != sess_node) {\n\t\tpr_notice(\"ignoring request from foreign node (%x != %x)\\n\",\n\t\t\t\tsource, sess_node);\n\t\trcode = RCODE_TYPE_ERROR;\n\t\tgoto out;\n\t}\n\n\t \n\toffset -= agent->handler.offset;\n\n\tif (offset == 0x00 && length == 4) {\n\t\t \n\t\trcode = tgt_agent_rw_agent_state(card, tcode, data, agent);\n\t} else if (offset == 0x04 && length == 4) {\n\t\t \n\t\trcode = tgt_agent_rw_agent_reset(card, tcode, data, agent);\n\t} else if (offset == 0x08 && length == 8) {\n\t\t \n\t\trcode = tgt_agent_rw_orb_pointer(card, tcode, data, agent);\n\t} else if (offset == 0x10 && length == 4) {\n\t\t \n\t\trcode = tgt_agent_rw_doorbell(card, tcode, data, agent);\n\t} else if (offset == 0x14 && length == 4) {\n\t\t \n\t\trcode = tgt_agent_rw_unsolicited_status_enable(card, tcode,\n\t\t\t\tdata, agent);\n\t} else {\n\t\trcode = RCODE_ADDRESS_ERROR;\n\t}\n\nout:\n\tfw_send_response(card, request, rcode);\n}\n\nstatic void sbp_handle_command(struct sbp_target_request *);\nstatic int sbp_send_status(struct sbp_target_request *);\nstatic void sbp_free_request(struct sbp_target_request *);\n\nstatic void tgt_agent_process_work(struct work_struct *work)\n{\n\tstruct sbp_target_request *req =\n\t\tcontainer_of(work, struct sbp_target_request, work);\n\n\tpr_debug(\"tgt_orb ptr:0x%llx next_ORB:0x%llx data_descriptor:0x%llx misc:0x%x\\n\",\n\t\t\treq->orb_pointer,\n\t\t\tsbp2_pointer_to_addr(&req->orb.next_orb),\n\t\t\tsbp2_pointer_to_addr(&req->orb.data_descriptor),\n\t\t\tbe32_to_cpu(req->orb.misc));\n\n\tif (req->orb_pointer >> 32)\n\t\tpr_debug(\"ORB with high bits set\\n\");\n\n\tswitch (ORB_REQUEST_FORMAT(be32_to_cpu(req->orb.misc))) {\n\t\tcase 0: \n\t\t\tsbp_handle_command(req);\n\t\t\treturn;\n\t\tcase 1:  \n\t\tcase 2:  \n\t\t\treq->status.status |= cpu_to_be32(\n\t\t\t\t\tSTATUS_BLOCK_RESP(\n\t\t\t\t\t\tSTATUS_RESP_REQUEST_COMPLETE) |\n\t\t\t\t\tSTATUS_BLOCK_DEAD(0) |\n\t\t\t\t\tSTATUS_BLOCK_LEN(1) |\n\t\t\t\t\tSTATUS_BLOCK_SBP_STATUS(\n\t\t\t\t\t\tSBP_STATUS_REQ_TYPE_NOTSUPP));\n\t\t\tsbp_send_status(req);\n\t\t\treturn;\n\t\tcase 3:  \n\t\t\treq->status.status |= cpu_to_be32(\n\t\t\t\t\tSTATUS_BLOCK_RESP(\n\t\t\t\t\t\tSTATUS_RESP_REQUEST_COMPLETE) |\n\t\t\t\t\tSTATUS_BLOCK_DEAD(0) |\n\t\t\t\t\tSTATUS_BLOCK_LEN(1) |\n\t\t\t\t\tSTATUS_BLOCK_SBP_STATUS(\n\t\t\t\t\t\tSBP_STATUS_DUMMY_ORB_COMPLETE));\n\t\t\tsbp_send_status(req);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n}\n\n \nstatic inline bool tgt_agent_check_active(struct sbp_target_agent *agent)\n{\n\tbool active;\n\n\tspin_lock_bh(&agent->lock);\n\tactive = (agent->state == AGENT_STATE_ACTIVE);\n\tspin_unlock_bh(&agent->lock);\n\n\treturn active;\n}\n\nstatic struct sbp_target_request *sbp_mgt_get_req(struct sbp_session *sess,\n\tstruct fw_card *card, u64 next_orb)\n{\n\tstruct se_session *se_sess = sess->se_sess;\n\tstruct sbp_target_request *req;\n\tint tag, cpu;\n\n\ttag = sbitmap_queue_get(&se_sess->sess_tag_pool, &cpu);\n\tif (tag < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treq = &((struct sbp_target_request *)se_sess->sess_cmd_map)[tag];\n\tmemset(req, 0, sizeof(*req));\n\treq->se_cmd.map_tag = tag;\n\treq->se_cmd.map_cpu = cpu;\n\treq->se_cmd.tag = next_orb;\n\n\treturn req;\n}\n\nstatic void tgt_agent_fetch_work(struct work_struct *work)\n{\n\tstruct sbp_target_agent *agent =\n\t\tcontainer_of(work, struct sbp_target_agent, work);\n\tstruct sbp_session *sess = agent->login->sess;\n\tstruct sbp_target_request *req;\n\tint ret;\n\tbool doorbell = agent->doorbell;\n\tu64 next_orb = agent->orb_pointer;\n\n\twhile (next_orb && tgt_agent_check_active(agent)) {\n\t\treq = sbp_mgt_get_req(sess, sess->card, next_orb);\n\t\tif (IS_ERR(req)) {\n\t\t\tspin_lock_bh(&agent->lock);\n\t\t\tagent->state = AGENT_STATE_DEAD;\n\t\t\tspin_unlock_bh(&agent->lock);\n\t\t\treturn;\n\t\t}\n\n\t\treq->login = agent->login;\n\t\treq->orb_pointer = next_orb;\n\n\t\treq->status.status = cpu_to_be32(STATUS_BLOCK_ORB_OFFSET_HIGH(\n\t\t\t\t\treq->orb_pointer >> 32));\n\t\treq->status.orb_low = cpu_to_be32(\n\t\t\t\treq->orb_pointer & 0xfffffffc);\n\n\t\t \n\t\tret = sbp_run_transaction(sess->card, TCODE_READ_BLOCK_REQUEST,\n\t\t\t\tsess->node_id, sess->generation, sess->speed,\n\t\t\t\treq->orb_pointer, &req->orb, sizeof(req->orb));\n\t\tif (ret != RCODE_COMPLETE) {\n\t\t\tpr_debug(\"tgt_orb fetch failed: %x\\n\", ret);\n\t\t\treq->status.status |= cpu_to_be32(\n\t\t\t\t\tSTATUS_BLOCK_SRC(\n\t\t\t\t\t\tSTATUS_SRC_ORB_FINISHED) |\n\t\t\t\t\tSTATUS_BLOCK_RESP(\n\t\t\t\t\t\tSTATUS_RESP_TRANSPORT_FAILURE) |\n\t\t\t\t\tSTATUS_BLOCK_DEAD(1) |\n\t\t\t\t\tSTATUS_BLOCK_LEN(1) |\n\t\t\t\t\tSTATUS_BLOCK_SBP_STATUS(\n\t\t\t\t\t\tSBP_STATUS_UNSPECIFIED_ERROR));\n\t\t\tspin_lock_bh(&agent->lock);\n\t\t\tagent->state = AGENT_STATE_DEAD;\n\t\t\tspin_unlock_bh(&agent->lock);\n\n\t\t\tsbp_send_status(req);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (be32_to_cpu(req->orb.next_orb.high) & 0x80000000) {\n\t\t\tnext_orb = 0;\n\t\t\treq->status.status |= cpu_to_be32(STATUS_BLOCK_SRC(\n\t\t\t\t\t\tSTATUS_SRC_ORB_FINISHED));\n\t\t} else {\n\t\t\tnext_orb = sbp2_pointer_to_addr(&req->orb.next_orb);\n\t\t\treq->status.status |= cpu_to_be32(STATUS_BLOCK_SRC(\n\t\t\t\t\t\tSTATUS_SRC_ORB_CONTINUING));\n\t\t}\n\n\t\tif (tgt_agent_check_active(agent) && !doorbell) {\n\t\t\tINIT_WORK(&req->work, tgt_agent_process_work);\n\t\t\tqueue_work(system_unbound_wq, &req->work);\n\t\t} else {\n\t\t\t \n\t\t\tsbp_free_request(req);\n\t\t}\n\n\t\tspin_lock_bh(&agent->lock);\n\t\tdoorbell = agent->doorbell = false;\n\n\t\t \n\t\tif (next_orb)\n\t\t\tagent->orb_pointer = next_orb;\n\t\telse\n\t\t\tagent->state = AGENT_STATE_SUSPENDED;\n\n\t\tspin_unlock_bh(&agent->lock);\n\t}\n}\n\nstatic struct sbp_target_agent *sbp_target_agent_register(\n\t\tstruct sbp_login_descriptor *login)\n{\n\tstruct sbp_target_agent *agent;\n\tint ret;\n\n\tagent = kmalloc(sizeof(*agent), GFP_KERNEL);\n\tif (!agent)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&agent->lock);\n\n\tagent->handler.length = 0x20;\n\tagent->handler.address_callback = tgt_agent_rw;\n\tagent->handler.callback_data = agent;\n\n\tagent->login = login;\n\tagent->state = AGENT_STATE_RESET;\n\tINIT_WORK(&agent->work, tgt_agent_fetch_work);\n\tagent->orb_pointer = 0;\n\tagent->doorbell = false;\n\n\tret = fw_core_add_address_handler(&agent->handler,\n\t\t\t&sbp_register_region);\n\tif (ret < 0) {\n\t\tkfree(agent);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn agent;\n}\n\nstatic void sbp_target_agent_unregister(struct sbp_target_agent *agent)\n{\n\tfw_core_remove_address_handler(&agent->handler);\n\tcancel_work_sync(&agent->work);\n\tkfree(agent);\n}\n\n \nstatic int sbp_run_transaction(struct fw_card *card, int tcode, int destination_id,\n\t\tint generation, int speed, unsigned long long offset,\n\t\tvoid *payload, size_t length)\n{\n\tint attempt, ret, delay;\n\n\tfor (attempt = 1; attempt <= 5; attempt++) {\n\t\tret = fw_run_transaction(card, tcode, destination_id,\n\t\t\t\tgeneration, speed, offset, payload, length);\n\n\t\tswitch (ret) {\n\t\tcase RCODE_COMPLETE:\n\t\tcase RCODE_TYPE_ERROR:\n\t\tcase RCODE_ADDRESS_ERROR:\n\t\tcase RCODE_GENERATION:\n\t\t\treturn ret;\n\n\t\tdefault:\n\t\t\tdelay = 5 * attempt * attempt;\n\t\t\tusleep_range(delay, delay * 2);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int sbp_run_request_transaction(struct sbp_target_request *req,\n\t\tint tcode, unsigned long long offset, void *payload,\n\t\tsize_t length)\n{\n\tstruct sbp_login_descriptor *login = req->login;\n\tstruct sbp_session *sess = login->sess;\n\tstruct fw_card *card;\n\tint node_id, generation, speed, ret;\n\n\tspin_lock_bh(&sess->lock);\n\tcard = fw_card_get(sess->card);\n\tnode_id = sess->node_id;\n\tgeneration = sess->generation;\n\tspeed = sess->speed;\n\tspin_unlock_bh(&sess->lock);\n\n\tret = sbp_run_transaction(card, tcode, node_id, generation, speed,\n\t\t\toffset, payload, length);\n\n\tfw_card_put(card);\n\n\treturn ret;\n}\n\nstatic int sbp_fetch_command(struct sbp_target_request *req)\n{\n\tint ret, cmd_len, copy_len;\n\n\tcmd_len = scsi_command_size(req->orb.command_block);\n\n\treq->cmd_buf = kmalloc(cmd_len, GFP_KERNEL);\n\tif (!req->cmd_buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(req->cmd_buf, req->orb.command_block,\n\t\tmin_t(int, cmd_len, sizeof(req->orb.command_block)));\n\n\tif (cmd_len > sizeof(req->orb.command_block)) {\n\t\tpr_debug(\"sbp_fetch_command: filling in long command\\n\");\n\t\tcopy_len = cmd_len - sizeof(req->orb.command_block);\n\n\t\tret = sbp_run_request_transaction(req,\n\t\t\t\tTCODE_READ_BLOCK_REQUEST,\n\t\t\t\treq->orb_pointer + sizeof(req->orb),\n\t\t\t\treq->cmd_buf + sizeof(req->orb.command_block),\n\t\t\t\tcopy_len);\n\t\tif (ret != RCODE_COMPLETE)\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int sbp_fetch_page_table(struct sbp_target_request *req)\n{\n\tint pg_tbl_sz, ret;\n\tstruct sbp_page_table_entry *pg_tbl;\n\n\tif (!CMDBLK_ORB_PG_TBL_PRESENT(be32_to_cpu(req->orb.misc)))\n\t\treturn 0;\n\n\tpg_tbl_sz = CMDBLK_ORB_DATA_SIZE(be32_to_cpu(req->orb.misc)) *\n\t\tsizeof(struct sbp_page_table_entry);\n\n\tpg_tbl = kmalloc(pg_tbl_sz, GFP_KERNEL);\n\tif (!pg_tbl)\n\t\treturn -ENOMEM;\n\n\tret = sbp_run_request_transaction(req, TCODE_READ_BLOCK_REQUEST,\n\t\t\tsbp2_pointer_to_addr(&req->orb.data_descriptor),\n\t\t\tpg_tbl, pg_tbl_sz);\n\tif (ret != RCODE_COMPLETE) {\n\t\tkfree(pg_tbl);\n\t\treturn -EIO;\n\t}\n\n\treq->pg_tbl = pg_tbl;\n\treturn 0;\n}\n\nstatic void sbp_calc_data_length_direction(struct sbp_target_request *req,\n\tu32 *data_len, enum dma_data_direction *data_dir)\n{\n\tint data_size, direction, idx;\n\n\tdata_size = CMDBLK_ORB_DATA_SIZE(be32_to_cpu(req->orb.misc));\n\tdirection = CMDBLK_ORB_DIRECTION(be32_to_cpu(req->orb.misc));\n\n\tif (!data_size) {\n\t\t*data_len = 0;\n\t\t*data_dir = DMA_NONE;\n\t\treturn;\n\t}\n\n\t*data_dir = direction ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\n\n\tif (req->pg_tbl) {\n\t\t*data_len = 0;\n\t\tfor (idx = 0; idx < data_size; idx++) {\n\t\t\t*data_len += be16_to_cpu(\n\t\t\t\t\treq->pg_tbl[idx].segment_length);\n\t\t}\n\t} else {\n\t\t*data_len = data_size;\n\t}\n}\n\nstatic void sbp_handle_command(struct sbp_target_request *req)\n{\n\tstruct sbp_login_descriptor *login = req->login;\n\tstruct sbp_session *sess = login->sess;\n\tint ret, unpacked_lun;\n\tu32 data_length;\n\tenum dma_data_direction data_dir;\n\n\tret = sbp_fetch_command(req);\n\tif (ret) {\n\t\tpr_debug(\"sbp_handle_command: fetch command failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = sbp_fetch_page_table(req);\n\tif (ret) {\n\t\tpr_debug(\"sbp_handle_command: fetch page table failed: %d\\n\",\n\t\t\tret);\n\t\tgoto err;\n\t}\n\n\tunpacked_lun = req->login->login_lun;\n\tsbp_calc_data_length_direction(req, &data_length, &data_dir);\n\n\tpr_debug(\"sbp_handle_command ORB:0x%llx unpacked_lun:%d data_len:%d data_dir:%d\\n\",\n\t\t\treq->orb_pointer, unpacked_lun, data_length, data_dir);\n\n\t \n\treq->se_cmd.tag = req->orb_pointer;\n\ttarget_submit_cmd(&req->se_cmd, sess->se_sess, req->cmd_buf,\n\t\t\t  req->sense_buf, unpacked_lun, data_length,\n\t\t\t  TCM_SIMPLE_TAG, data_dir, TARGET_SCF_ACK_KREF);\n\treturn;\n\nerr:\n\treq->status.status |= cpu_to_be32(\n\t\tSTATUS_BLOCK_RESP(STATUS_RESP_TRANSPORT_FAILURE) |\n\t\tSTATUS_BLOCK_DEAD(0) |\n\t\tSTATUS_BLOCK_LEN(1) |\n\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_UNSPECIFIED_ERROR));\n\tsbp_send_status(req);\n}\n\n \nstatic int sbp_rw_data(struct sbp_target_request *req)\n{\n\tstruct sbp_session *sess = req->login->sess;\n\tint tcode, sg_miter_flags, max_payload, pg_size, speed, node_id,\n\t\tgeneration, num_pte, length, tfr_length,\n\t\trcode = RCODE_COMPLETE;\n\tstruct sbp_page_table_entry *pte;\n\tunsigned long long offset;\n\tstruct fw_card *card;\n\tstruct sg_mapping_iter iter;\n\n\tif (req->se_cmd.data_direction == DMA_FROM_DEVICE) {\n\t\ttcode = TCODE_WRITE_BLOCK_REQUEST;\n\t\tsg_miter_flags = SG_MITER_FROM_SG;\n\t} else {\n\t\ttcode = TCODE_READ_BLOCK_REQUEST;\n\t\tsg_miter_flags = SG_MITER_TO_SG;\n\t}\n\n\tmax_payload = 4 << CMDBLK_ORB_MAX_PAYLOAD(be32_to_cpu(req->orb.misc));\n\tspeed = CMDBLK_ORB_SPEED(be32_to_cpu(req->orb.misc));\n\n\tpg_size = CMDBLK_ORB_PG_SIZE(be32_to_cpu(req->orb.misc));\n\tif (pg_size) {\n\t\tpr_err(\"sbp_run_transaction: page size ignored\\n\");\n\t}\n\n\tspin_lock_bh(&sess->lock);\n\tcard = fw_card_get(sess->card);\n\tnode_id = sess->node_id;\n\tgeneration = sess->generation;\n\tspin_unlock_bh(&sess->lock);\n\n\tif (req->pg_tbl) {\n\t\tpte = req->pg_tbl;\n\t\tnum_pte = CMDBLK_ORB_DATA_SIZE(be32_to_cpu(req->orb.misc));\n\n\t\toffset = 0;\n\t\tlength = 0;\n\t} else {\n\t\tpte = NULL;\n\t\tnum_pte = 0;\n\n\t\toffset = sbp2_pointer_to_addr(&req->orb.data_descriptor);\n\t\tlength = req->se_cmd.data_length;\n\t}\n\n\tsg_miter_start(&iter, req->se_cmd.t_data_sg, req->se_cmd.t_data_nents,\n\t\tsg_miter_flags);\n\n\twhile (length || num_pte) {\n\t\tif (!length) {\n\t\t\toffset = (u64)be16_to_cpu(pte->segment_base_hi) << 32 |\n\t\t\t\tbe32_to_cpu(pte->segment_base_lo);\n\t\t\tlength = be16_to_cpu(pte->segment_length);\n\n\t\t\tpte++;\n\t\t\tnum_pte--;\n\t\t}\n\n\t\tsg_miter_next(&iter);\n\n\t\ttfr_length = min3(length, max_payload, (int)iter.length);\n\n\t\t \n\n\t\trcode = sbp_run_transaction(card, tcode, node_id,\n\t\t\t\tgeneration, speed,\n\t\t\t\toffset, iter.addr, tfr_length);\n\n\t\tif (rcode != RCODE_COMPLETE)\n\t\t\tbreak;\n\n\t\tlength -= tfr_length;\n\t\toffset += tfr_length;\n\t\titer.consumed = tfr_length;\n\t}\n\n\tsg_miter_stop(&iter);\n\tfw_card_put(card);\n\n\tif (rcode == RCODE_COMPLETE) {\n\t\tWARN_ON(length != 0);\n\t\treturn 0;\n\t} else {\n\t\treturn -EIO;\n\t}\n}\n\nstatic int sbp_send_status(struct sbp_target_request *req)\n{\n\tint rc, ret = 0, length;\n\tstruct sbp_login_descriptor *login = req->login;\n\n\tlength = (((be32_to_cpu(req->status.status) >> 24) & 0x07) + 1) * 4;\n\n\trc = sbp_run_request_transaction(req, TCODE_WRITE_BLOCK_REQUEST,\n\t\t\tlogin->status_fifo_addr, &req->status, length);\n\tif (rc != RCODE_COMPLETE) {\n\t\tpr_debug(\"sbp_send_status: write failed: 0x%x\\n\", rc);\n\t\tret = -EIO;\n\t\tgoto put_ref;\n\t}\n\n\tpr_debug(\"sbp_send_status: status write complete for ORB: 0x%llx\\n\",\n\t\t\treq->orb_pointer);\n\t \nput_ref:\n\ttarget_put_sess_cmd(&req->se_cmd);\n\treturn ret;\n}\n\nstatic void sbp_sense_mangle(struct sbp_target_request *req)\n{\n\tstruct se_cmd *se_cmd = &req->se_cmd;\n\tu8 *sense = req->sense_buf;\n\tu8 *status = req->status.data;\n\n\tWARN_ON(se_cmd->scsi_sense_length < 18);\n\n\tswitch (sense[0] & 0x7f) { \t\t \n\tcase 0x70:  \n\t\tstatus[0] = 0 << 6;\n\t\tbreak;\n\tcase 0x71:  \n\t\tstatus[0] = 1 << 6;\n\t\tbreak;\n\tcase 0x72:  \n\tcase 0x73:  \n\tdefault:\n\t\t \n\t\tpr_err(\"sbp_send_sense: unknown sense format: 0x%x\\n\",\n\t\t\tsense[0]);\n\t\treq->status.status |= cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_DEAD(0) |\n\t\t\tSTATUS_BLOCK_LEN(1) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQUEST_ABORTED));\n\t\treturn;\n\t}\n\n\tstatus[0] |= se_cmd->scsi_status & 0x3f; \n\tstatus[1] =\n\t\t(sense[0] & 0x80) |\t\t \n\t\t((sense[2] & 0xe0) >> 1) |\t \n\t\t(sense[2] & 0x0f);\t\t \n\tstatus[2] = 0;\t\t\t\t \n\tstatus[3] = 0;\t\t\t\t \n\n\t \n\tstatus[4] = sense[3];\n\tstatus[5] = sense[4];\n\tstatus[6] = sense[5];\n\tstatus[7] = sense[6];\n\n\t \n\tstatus[8] = sense[8];\n\tstatus[9] = sense[9];\n\tstatus[10] = sense[10];\n\tstatus[11] = sense[11];\n\n\t \n\tstatus[12] = sense[14];\n\n\t \n\tstatus[13] = sense[15];\n\tstatus[14] = sense[16];\n\tstatus[15] = sense[17];\n\n\treq->status.status |= cpu_to_be32(\n\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\tSTATUS_BLOCK_DEAD(0) |\n\t\tSTATUS_BLOCK_LEN(5) |\n\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_OK));\n}\n\nstatic int sbp_send_sense(struct sbp_target_request *req)\n{\n\tstruct se_cmd *se_cmd = &req->se_cmd;\n\n\tif (se_cmd->scsi_sense_length) {\n\t\tsbp_sense_mangle(req);\n\t} else {\n\t\treq->status.status |= cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_DEAD(0) |\n\t\t\tSTATUS_BLOCK_LEN(1) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_OK));\n\t}\n\n\treturn sbp_send_status(req);\n}\n\nstatic void sbp_free_request(struct sbp_target_request *req)\n{\n\tstruct se_cmd *se_cmd = &req->se_cmd;\n\tstruct se_session *se_sess = se_cmd->se_sess;\n\n\tkfree(req->pg_tbl);\n\tkfree(req->cmd_buf);\n\n\ttarget_free_tag(se_sess, se_cmd);\n}\n\nstatic void sbp_mgt_agent_process(struct work_struct *work)\n{\n\tstruct sbp_management_agent *agent =\n\t\tcontainer_of(work, struct sbp_management_agent, work);\n\tstruct sbp_management_request *req = agent->request;\n\tint ret;\n\tint status_data_len = 0;\n\n\t \n\tret = sbp_run_transaction(req->card, TCODE_READ_BLOCK_REQUEST,\n\t\treq->node_addr, req->generation, req->speed,\n\t\tagent->orb_offset, &req->orb, sizeof(req->orb));\n\tif (ret != RCODE_COMPLETE) {\n\t\tpr_debug(\"mgt_orb fetch failed: %x\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"mgt_orb ptr1:0x%llx ptr2:0x%llx misc:0x%x len:0x%x status_fifo:0x%llx\\n\",\n\t\tsbp2_pointer_to_addr(&req->orb.ptr1),\n\t\tsbp2_pointer_to_addr(&req->orb.ptr2),\n\t\tbe32_to_cpu(req->orb.misc), be32_to_cpu(req->orb.length),\n\t\tsbp2_pointer_to_addr(&req->orb.status_fifo));\n\n\tif (!ORB_NOTIFY(be32_to_cpu(req->orb.misc)) ||\n\t\tORB_REQUEST_FORMAT(be32_to_cpu(req->orb.misc)) != 0) {\n\t\tpr_err(\"mgt_orb bad request\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch (MANAGEMENT_ORB_FUNCTION(be32_to_cpu(req->orb.misc))) {\n\tcase MANAGEMENT_ORB_FUNCTION_LOGIN:\n\t\tsbp_management_request_login(agent, req, &status_data_len);\n\t\tbreak;\n\n\tcase MANAGEMENT_ORB_FUNCTION_QUERY_LOGINS:\n\t\tsbp_management_request_query_logins(agent, req,\n\t\t\t\t&status_data_len);\n\t\tbreak;\n\n\tcase MANAGEMENT_ORB_FUNCTION_RECONNECT:\n\t\tsbp_management_request_reconnect(agent, req, &status_data_len);\n\t\tbreak;\n\n\tcase MANAGEMENT_ORB_FUNCTION_SET_PASSWORD:\n\t\tpr_notice(\"SET PASSWORD not implemented\\n\");\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\n\n\t\tbreak;\n\n\tcase MANAGEMENT_ORB_FUNCTION_LOGOUT:\n\t\tsbp_management_request_logout(agent, req, &status_data_len);\n\t\tbreak;\n\n\tcase MANAGEMENT_ORB_FUNCTION_ABORT_TASK:\n\t\tpr_notice(\"ABORT TASK not implemented\\n\");\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\n\n\t\tbreak;\n\n\tcase MANAGEMENT_ORB_FUNCTION_ABORT_TASK_SET:\n\t\tpr_notice(\"ABORT TASK SET not implemented\\n\");\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\n\n\t\tbreak;\n\n\tcase MANAGEMENT_ORB_FUNCTION_LOGICAL_UNIT_RESET:\n\t\tpr_notice(\"LOGICAL UNIT RESET not implemented\\n\");\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\n\n\t\tbreak;\n\n\tcase MANAGEMENT_ORB_FUNCTION_TARGET_RESET:\n\t\tpr_notice(\"TARGET RESET not implemented\\n\");\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\n\n\t\tbreak;\n\n\tdefault:\n\t\tpr_notice(\"unknown management function 0x%x\\n\",\n\t\t\tMANAGEMENT_ORB_FUNCTION(be32_to_cpu(req->orb.misc)));\n\n\t\treq->status.status = cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_REQUEST_COMPLETE) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_REQ_TYPE_NOTSUPP));\n\n\t\tbreak;\n\t}\n\n\treq->status.status |= cpu_to_be32(\n\t\tSTATUS_BLOCK_SRC(1) |  \n\t\tSTATUS_BLOCK_LEN(DIV_ROUND_UP(status_data_len, 4) + 1) |\n\t\tSTATUS_BLOCK_ORB_OFFSET_HIGH(agent->orb_offset >> 32));\n\treq->status.orb_low = cpu_to_be32(agent->orb_offset);\n\n\t \n\tret = sbp_run_transaction(req->card, TCODE_WRITE_BLOCK_REQUEST,\n\t\treq->node_addr, req->generation, req->speed,\n\t\tsbp2_pointer_to_addr(&req->orb.status_fifo),\n\t\t&req->status, 8 + status_data_len);\n\tif (ret != RCODE_COMPLETE) {\n\t\tpr_debug(\"mgt_orb status write failed: %x\\n\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tfw_card_put(req->card);\n\tkfree(req);\n\n\tspin_lock_bh(&agent->lock);\n\tagent->state = MANAGEMENT_AGENT_STATE_IDLE;\n\tspin_unlock_bh(&agent->lock);\n}\n\nstatic void sbp_mgt_agent_rw(struct fw_card *card,\n\tstruct fw_request *request, int tcode, int destination, int source,\n\tint generation, unsigned long long offset, void *data, size_t length,\n\tvoid *callback_data)\n{\n\tstruct sbp_management_agent *agent = callback_data;\n\tstruct sbp2_pointer *ptr = data;\n\tint rcode = RCODE_ADDRESS_ERROR;\n\n\tif (!agent->tport->enable)\n\t\tgoto out;\n\n\tif ((offset != agent->handler.offset) || (length != 8))\n\t\tgoto out;\n\n\tif (tcode == TCODE_WRITE_BLOCK_REQUEST) {\n\t\tstruct sbp_management_request *req;\n\t\tint prev_state;\n\n\t\tspin_lock_bh(&agent->lock);\n\t\tprev_state = agent->state;\n\t\tagent->state = MANAGEMENT_AGENT_STATE_BUSY;\n\t\tspin_unlock_bh(&agent->lock);\n\n\t\tif (prev_state == MANAGEMENT_AGENT_STATE_BUSY) {\n\t\t\tpr_notice(\"ignoring management request while busy\\n\");\n\t\t\trcode = RCODE_CONFLICT_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\treq = kzalloc(sizeof(*req), GFP_ATOMIC);\n\t\tif (!req) {\n\t\t\trcode = RCODE_CONFLICT_ERROR;\n\t\t\tgoto out;\n\t\t}\n\n\t\treq->card = fw_card_get(card);\n\t\treq->generation = generation;\n\t\treq->node_addr = source;\n\t\treq->speed = fw_get_request_speed(request);\n\n\t\tagent->orb_offset = sbp2_pointer_to_addr(ptr);\n\t\tagent->request = req;\n\n\t\tqueue_work(system_unbound_wq, &agent->work);\n\t\trcode = RCODE_COMPLETE;\n\t} else if (tcode == TCODE_READ_BLOCK_REQUEST) {\n\t\taddr_to_sbp2_pointer(agent->orb_offset, ptr);\n\t\trcode = RCODE_COMPLETE;\n\t} else {\n\t\trcode = RCODE_TYPE_ERROR;\n\t}\n\nout:\n\tfw_send_response(card, request, rcode);\n}\n\nstatic struct sbp_management_agent *sbp_management_agent_register(\n\t\tstruct sbp_tport *tport)\n{\n\tint ret;\n\tstruct sbp_management_agent *agent;\n\n\tagent = kmalloc(sizeof(*agent), GFP_KERNEL);\n\tif (!agent)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&agent->lock);\n\tagent->tport = tport;\n\tagent->handler.length = 0x08;\n\tagent->handler.address_callback = sbp_mgt_agent_rw;\n\tagent->handler.callback_data = agent;\n\tagent->state = MANAGEMENT_AGENT_STATE_IDLE;\n\tINIT_WORK(&agent->work, sbp_mgt_agent_process);\n\tagent->orb_offset = 0;\n\tagent->request = NULL;\n\n\tret = fw_core_add_address_handler(&agent->handler,\n\t\t\t&sbp_register_region);\n\tif (ret < 0) {\n\t\tkfree(agent);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn agent;\n}\n\nstatic void sbp_management_agent_unregister(struct sbp_management_agent *agent)\n{\n\tfw_core_remove_address_handler(&agent->handler);\n\tcancel_work_sync(&agent->work);\n\tkfree(agent);\n}\n\nstatic int sbp_check_true(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic char *sbp_get_fabric_wwn(struct se_portal_group *se_tpg)\n{\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\tstruct sbp_tport *tport = tpg->tport;\n\n\treturn &tport->tport_name[0];\n}\n\nstatic u16 sbp_get_tag(struct se_portal_group *se_tpg)\n{\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\treturn tpg->tport_tpgt;\n}\n\nstatic void sbp_release_cmd(struct se_cmd *se_cmd)\n{\n\tstruct sbp_target_request *req = container_of(se_cmd,\n\t\t\tstruct sbp_target_request, se_cmd);\n\n\tsbp_free_request(req);\n}\n\nstatic int sbp_write_pending(struct se_cmd *se_cmd)\n{\n\tstruct sbp_target_request *req = container_of(se_cmd,\n\t\t\tstruct sbp_target_request, se_cmd);\n\tint ret;\n\n\tret = sbp_rw_data(req);\n\tif (ret) {\n\t\treq->status.status |= cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(\n\t\t\t\tSTATUS_RESP_TRANSPORT_FAILURE) |\n\t\t\tSTATUS_BLOCK_DEAD(0) |\n\t\t\tSTATUS_BLOCK_LEN(1) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(\n\t\t\t\tSBP_STATUS_UNSPECIFIED_ERROR));\n\t\tsbp_send_status(req);\n\t\treturn ret;\n\t}\n\n\ttarget_execute_cmd(se_cmd);\n\treturn 0;\n}\n\nstatic int sbp_queue_data_in(struct se_cmd *se_cmd)\n{\n\tstruct sbp_target_request *req = container_of(se_cmd,\n\t\t\tstruct sbp_target_request, se_cmd);\n\tint ret;\n\n\tret = sbp_rw_data(req);\n\tif (ret) {\n\t\treq->status.status |= cpu_to_be32(\n\t\t\tSTATUS_BLOCK_RESP(STATUS_RESP_TRANSPORT_FAILURE) |\n\t\t\tSTATUS_BLOCK_DEAD(0) |\n\t\t\tSTATUS_BLOCK_LEN(1) |\n\t\t\tSTATUS_BLOCK_SBP_STATUS(SBP_STATUS_UNSPECIFIED_ERROR));\n\t\tsbp_send_status(req);\n\t\treturn ret;\n\t}\n\n\treturn sbp_send_sense(req);\n}\n\n \nstatic int sbp_queue_status(struct se_cmd *se_cmd)\n{\n\tstruct sbp_target_request *req = container_of(se_cmd,\n\t\t\tstruct sbp_target_request, se_cmd);\n\n\treturn sbp_send_sense(req);\n}\n\nstatic void sbp_queue_tm_rsp(struct se_cmd *se_cmd)\n{\n}\n\nstatic void sbp_aborted_task(struct se_cmd *se_cmd)\n{\n\treturn;\n}\n\nstatic int sbp_check_stop_free(struct se_cmd *se_cmd)\n{\n\tstruct sbp_target_request *req = container_of(se_cmd,\n\t\t\tstruct sbp_target_request, se_cmd);\n\n\treturn transport_generic_free_cmd(&req->se_cmd, 0);\n}\n\nstatic int sbp_count_se_tpg_luns(struct se_portal_group *tpg)\n{\n\tstruct se_lun *lun;\n\tint count = 0;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(lun, &tpg->tpg_lun_hlist, link)\n\t\tcount++;\n\trcu_read_unlock();\n\n\treturn count;\n}\n\nstatic int sbp_update_unit_directory(struct sbp_tport *tport)\n{\n\tstruct se_lun *lun;\n\tint num_luns, num_entries, idx = 0, mgt_agt_addr, ret;\n\tu32 *data;\n\n\tif (tport->unit_directory.data) {\n\t\tfw_core_remove_descriptor(&tport->unit_directory);\n\t\tkfree(tport->unit_directory.data);\n\t\ttport->unit_directory.data = NULL;\n\t}\n\n\tif (!tport->enable || !tport->tpg)\n\t\treturn 0;\n\n\tnum_luns = sbp_count_se_tpg_luns(&tport->tpg->se_tpg);\n\n\t \n\tnum_entries = ARRAY_SIZE(sbp_unit_directory_template) + 4 + num_luns;\n\n\tif (tport->directory_id != -1)\n\t\tnum_entries++;\n\n\t \n\tdata = kcalloc((num_entries + 4), sizeof(u32), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tdata[idx++] = num_entries << 16;\n\n\t \n\tif (tport->directory_id != -1)\n\t\tdata[idx++] = (CSR_DIRECTORY_ID << 24) | tport->directory_id;\n\n\t \n\tmemcpy(&data[idx], sbp_unit_directory_template,\n\t\t\tsizeof(sbp_unit_directory_template));\n\tidx += ARRAY_SIZE(sbp_unit_directory_template);\n\n\t \n\tmgt_agt_addr = (tport->mgt_agt->handler.offset - CSR_REGISTER_BASE) / 4;\n\tdata[idx++] = 0x54000000 | (mgt_agt_addr & 0x00ffffff);\n\n\t \n\tdata[idx++] = 0x3a000000 |\n\t\t(((tport->mgt_orb_timeout * 2) << 8) & 0xff00) |\n\t\tSBP_ORB_FETCH_SIZE;\n\n\t \n\tdata[idx++] = 0x3d000000 | (tport->max_reconnect_timeout & 0xffff);\n\n\t \n\tdata[idx++] = 0x8d000000 | (num_luns + 1);\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(lun, &tport->tpg->se_tpg.tpg_lun_hlist, link) {\n\t\tstruct se_device *dev;\n\t\tint type;\n\t\t \n\t\tdev = rcu_dereference_raw(lun->lun_se_dev);\n\t\ttype = dev->transport->get_device_type(dev);\n\n\t\t \n\t\tdata[idx++] = 0x14000000 |\n\t\t\t((type << 16) & 0x1f0000) |\n\t\t\t(lun->unpacked_lun & 0xffff);\n\t}\n\trcu_read_unlock();\n\n\t \n\tdata[idx++] = 2 << 16;\n\tdata[idx++] = tport->guid >> 32;\n\tdata[idx++] = tport->guid;\n\n\ttport->unit_directory.length = idx;\n\ttport->unit_directory.key = (CSR_DIRECTORY | CSR_UNIT) << 24;\n\ttport->unit_directory.data = data;\n\n\tret = fw_core_add_descriptor(&tport->unit_directory);\n\tif (ret < 0) {\n\t\tkfree(tport->unit_directory.data);\n\t\ttport->unit_directory.data = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t sbp_parse_wwn(const char *name, u64 *wwn)\n{\n\tconst char *cp;\n\tchar c, nibble;\n\tint pos = 0, err;\n\n\t*wwn = 0;\n\tfor (cp = name; cp < &name[SBP_NAMELEN - 1]; cp++) {\n\t\tc = *cp;\n\t\tif (c == '\\n' && cp[1] == '\\0')\n\t\t\tcontinue;\n\t\tif (c == '\\0') {\n\t\t\terr = 2;\n\t\t\tif (pos != 16)\n\t\t\t\tgoto fail;\n\t\t\treturn cp - name;\n\t\t}\n\t\terr = 3;\n\t\tif (isdigit(c))\n\t\t\tnibble = c - '0';\n\t\telse if (isxdigit(c))\n\t\t\tnibble = tolower(c) - 'a' + 10;\n\t\telse\n\t\t\tgoto fail;\n\t\t*wwn = (*wwn << 4) | nibble;\n\t\tpos++;\n\t}\n\terr = 4;\nfail:\n\tprintk(KERN_INFO \"err %u len %zu pos %u\\n\",\n\t\t\terr, cp - name, pos);\n\treturn -1;\n}\n\nstatic ssize_t sbp_format_wwn(char *buf, size_t len, u64 wwn)\n{\n\treturn snprintf(buf, len, \"%016llx\", wwn);\n}\n\nstatic int sbp_init_nodeacl(struct se_node_acl *se_nacl, const char *name)\n{\n\tu64 guid = 0;\n\n\tif (sbp_parse_wwn(name, &guid) < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int sbp_post_link_lun(\n\t\tstruct se_portal_group *se_tpg,\n\t\tstruct se_lun *se_lun)\n{\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\n\treturn sbp_update_unit_directory(tpg->tport);\n}\n\nstatic void sbp_pre_unlink_lun(\n\t\tstruct se_portal_group *se_tpg,\n\t\tstruct se_lun *se_lun)\n{\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\tstruct sbp_tport *tport = tpg->tport;\n\tint ret;\n\n\tif (sbp_count_se_tpg_luns(&tpg->se_tpg) == 0)\n\t\ttport->enable = 0;\n\n\tret = sbp_update_unit_directory(tport);\n\tif (ret < 0)\n\t\tpr_err(\"unlink LUN: failed to update unit directory\\n\");\n}\n\nstatic struct se_portal_group *sbp_make_tpg(struct se_wwn *wwn,\n\t\t\t\t\t    const char *name)\n{\n\tstruct sbp_tport *tport =\n\t\tcontainer_of(wwn, struct sbp_tport, tport_wwn);\n\n\tstruct sbp_tpg *tpg;\n\tunsigned long tpgt;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tport->tpg) {\n\t\tpr_err(\"Only one TPG per Unit is possible.\\n\");\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\ttpg = kzalloc(sizeof(*tpg), GFP_KERNEL);\n\tif (!tpg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\ttport->tpg = tpg;\n\n\t \n\ttport->enable = 0;\n\ttport->directory_id = -1;\n\ttport->mgt_orb_timeout = 15;\n\ttport->max_reconnect_timeout = 5;\n\ttport->max_logins_per_lun = 1;\n\n\ttport->mgt_agt = sbp_management_agent_register(tport);\n\tif (IS_ERR(tport->mgt_agt)) {\n\t\tret = PTR_ERR(tport->mgt_agt);\n\t\tgoto out_free_tpg;\n\t}\n\n\tret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_SBP);\n\tif (ret < 0)\n\t\tgoto out_unreg_mgt_agt;\n\n\treturn &tpg->se_tpg;\n\nout_unreg_mgt_agt:\n\tsbp_management_agent_unregister(tport->mgt_agt);\nout_free_tpg:\n\ttport->tpg = NULL;\n\tkfree(tpg);\n\treturn ERR_PTR(ret);\n}\n\nstatic void sbp_drop_tpg(struct se_portal_group *se_tpg)\n{\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\tstruct sbp_tport *tport = tpg->tport;\n\n\tcore_tpg_deregister(se_tpg);\n\tsbp_management_agent_unregister(tport->mgt_agt);\n\ttport->tpg = NULL;\n\tkfree(tpg);\n}\n\nstatic struct se_wwn *sbp_make_tport(\n\t\tstruct target_fabric_configfs *tf,\n\t\tstruct config_group *group,\n\t\tconst char *name)\n{\n\tstruct sbp_tport *tport;\n\tu64 guid = 0;\n\n\tif (sbp_parse_wwn(name, &guid) < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttport = kzalloc(sizeof(*tport), GFP_KERNEL);\n\tif (!tport)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttport->guid = guid;\n\tsbp_format_wwn(tport->tport_name, SBP_NAMELEN, guid);\n\n\treturn &tport->tport_wwn;\n}\n\nstatic void sbp_drop_tport(struct se_wwn *wwn)\n{\n\tstruct sbp_tport *tport =\n\t\tcontainer_of(wwn, struct sbp_tport, tport_wwn);\n\n\tkfree(tport);\n}\n\nstatic ssize_t sbp_wwn_version_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"FireWire SBP fabric module %s\\n\", SBP_VERSION);\n}\n\nCONFIGFS_ATTR_RO(sbp_wwn_, version);\n\nstatic struct configfs_attribute *sbp_wwn_attrs[] = {\n\t&sbp_wwn_attr_version,\n\tNULL,\n};\n\nstatic ssize_t sbp_tpg_directory_id_show(struct config_item *item, char *page)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\tstruct sbp_tport *tport = tpg->tport;\n\n\tif (tport->directory_id == -1)\n\t\treturn sprintf(page, \"implicit\\n\");\n\telse\n\t\treturn sprintf(page, \"%06x\\n\", tport->directory_id);\n}\n\nstatic ssize_t sbp_tpg_directory_id_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\tstruct sbp_tport *tport = tpg->tport;\n\tunsigned long val;\n\n\tif (tport->enable) {\n\t\tpr_err(\"Cannot change the directory_id on an active target.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (strstr(page, \"implicit\") == page) {\n\t\ttport->directory_id = -1;\n\t} else {\n\t\tif (kstrtoul(page, 16, &val) < 0)\n\t\t\treturn -EINVAL;\n\t\tif (val > 0xffffff)\n\t\t\treturn -EINVAL;\n\n\t\ttport->directory_id = val;\n\t}\n\n\treturn count;\n}\n\nstatic int sbp_enable_tpg(struct se_portal_group *se_tpg, bool enable)\n{\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\tstruct sbp_tport *tport = tpg->tport;\n\tint ret;\n\n\tif (enable) {\n\t\tif (sbp_count_se_tpg_luns(&tpg->se_tpg) == 0) {\n\t\t\tpr_err(\"Cannot enable a target with no LUNs!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tspin_lock_bh(&se_tpg->session_lock);\n\t\tif (!list_empty(&se_tpg->tpg_sess_list)) {\n\t\t\tspin_unlock_bh(&se_tpg->session_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tspin_unlock_bh(&se_tpg->session_lock);\n\t}\n\n\ttport->enable = enable;\n\n\tret = sbp_update_unit_directory(tport);\n\tif (ret < 0) {\n\t\tpr_err(\"Could not update Config ROM\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nCONFIGFS_ATTR(sbp_tpg_, directory_id);\n\nstatic struct configfs_attribute *sbp_tpg_base_attrs[] = {\n\t&sbp_tpg_attr_directory_id,\n\tNULL,\n};\n\nstatic ssize_t sbp_tpg_attrib_mgt_orb_timeout_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\tstruct sbp_tport *tport = tpg->tport;\n\treturn sprintf(page, \"%d\\n\", tport->mgt_orb_timeout);\n}\n\nstatic ssize_t sbp_tpg_attrib_mgt_orb_timeout_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\tstruct sbp_tport *tport = tpg->tport;\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(page, 0, &val) < 0)\n\t\treturn -EINVAL;\n\tif ((val < 1) || (val > 127))\n\t\treturn -EINVAL;\n\n\tif (tport->mgt_orb_timeout == val)\n\t\treturn count;\n\n\ttport->mgt_orb_timeout = val;\n\n\tret = sbp_update_unit_directory(tport);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t sbp_tpg_attrib_max_reconnect_timeout_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\tstruct sbp_tport *tport = tpg->tport;\n\treturn sprintf(page, \"%d\\n\", tport->max_reconnect_timeout);\n}\n\nstatic ssize_t sbp_tpg_attrib_max_reconnect_timeout_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\tstruct sbp_tport *tport = tpg->tport;\n\tunsigned long val;\n\tint ret;\n\n\tif (kstrtoul(page, 0, &val) < 0)\n\t\treturn -EINVAL;\n\tif ((val < 1) || (val > 32767))\n\t\treturn -EINVAL;\n\n\tif (tport->max_reconnect_timeout == val)\n\t\treturn count;\n\n\ttport->max_reconnect_timeout = val;\n\n\tret = sbp_update_unit_directory(tport);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t sbp_tpg_attrib_max_logins_per_lun_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\tstruct sbp_tport *tport = tpg->tport;\n\treturn sprintf(page, \"%d\\n\", tport->max_logins_per_lun);\n}\n\nstatic ssize_t sbp_tpg_attrib_max_logins_per_lun_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\n\tstruct sbp_tpg *tpg = container_of(se_tpg, struct sbp_tpg, se_tpg);\n\tstruct sbp_tport *tport = tpg->tport;\n\tunsigned long val;\n\n\tif (kstrtoul(page, 0, &val) < 0)\n\t\treturn -EINVAL;\n\tif ((val < 1) || (val > 127))\n\t\treturn -EINVAL;\n\n\t \n\n\ttport->max_logins_per_lun = val;\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(sbp_tpg_attrib_, mgt_orb_timeout);\nCONFIGFS_ATTR(sbp_tpg_attrib_, max_reconnect_timeout);\nCONFIGFS_ATTR(sbp_tpg_attrib_, max_logins_per_lun);\n\nstatic struct configfs_attribute *sbp_tpg_attrib_attrs[] = {\n\t&sbp_tpg_attrib_attr_mgt_orb_timeout,\n\t&sbp_tpg_attrib_attr_max_reconnect_timeout,\n\t&sbp_tpg_attrib_attr_max_logins_per_lun,\n\tNULL,\n};\n\nstatic const struct target_core_fabric_ops sbp_ops = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.fabric_name\t\t\t= \"sbp\",\n\t.tpg_get_wwn\t\t\t= sbp_get_fabric_wwn,\n\t.tpg_get_tag\t\t\t= sbp_get_tag,\n\t.tpg_check_demo_mode\t\t= sbp_check_true,\n\t.tpg_check_demo_mode_cache\t= sbp_check_true,\n\t.release_cmd\t\t\t= sbp_release_cmd,\n\t.write_pending\t\t\t= sbp_write_pending,\n\t.queue_data_in\t\t\t= sbp_queue_data_in,\n\t.queue_status\t\t\t= sbp_queue_status,\n\t.queue_tm_rsp\t\t\t= sbp_queue_tm_rsp,\n\t.aborted_task\t\t\t= sbp_aborted_task,\n\t.check_stop_free\t\t= sbp_check_stop_free,\n\n\t.fabric_make_wwn\t\t= sbp_make_tport,\n\t.fabric_drop_wwn\t\t= sbp_drop_tport,\n\t.fabric_make_tpg\t\t= sbp_make_tpg,\n\t.fabric_enable_tpg\t\t= sbp_enable_tpg,\n\t.fabric_drop_tpg\t\t= sbp_drop_tpg,\n\t.fabric_post_link\t\t= sbp_post_link_lun,\n\t.fabric_pre_unlink\t\t= sbp_pre_unlink_lun,\n\t.fabric_make_np\t\t\t= NULL,\n\t.fabric_drop_np\t\t\t= NULL,\n\t.fabric_init_nodeacl\t\t= sbp_init_nodeacl,\n\n\t.tfc_wwn_attrs\t\t\t= sbp_wwn_attrs,\n\t.tfc_tpg_base_attrs\t\t= sbp_tpg_base_attrs,\n\t.tfc_tpg_attrib_attrs\t\t= sbp_tpg_attrib_attrs,\n};\n\nstatic int __init sbp_init(void)\n{\n\treturn target_register_template(&sbp_ops);\n};\n\nstatic void __exit sbp_exit(void)\n{\n\ttarget_unregister_template(&sbp_ops);\n};\n\nMODULE_DESCRIPTION(\"FireWire SBP fabric driver\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(sbp_init);\nmodule_exit(sbp_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}