{
  "module_name": "target_core_rd.c",
  "hash_id": "c8f791c6b49d777727b563666878ca360c959fc5e89e101cb38ccd42465480d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_rd.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/highmem.h>\n#include <linux/timer.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <scsi/scsi_proto.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n\n#include \"target_core_rd.h\"\n\nstatic inline struct rd_dev *RD_DEV(struct se_device *dev)\n{\n\treturn container_of(dev, struct rd_dev, dev);\n}\n\nstatic int rd_attach_hba(struct se_hba *hba, u32 host_id)\n{\n\tstruct rd_host *rd_host;\n\n\trd_host = kzalloc(sizeof(*rd_host), GFP_KERNEL);\n\tif (!rd_host)\n\t\treturn -ENOMEM;\n\n\trd_host->rd_host_id = host_id;\n\n\thba->hba_ptr = rd_host;\n\n\tpr_debug(\"CORE_HBA[%d] - TCM Ramdisk HBA Driver %s on\"\n\t\t\" Generic Target Core Stack %s\\n\", hba->hba_id,\n\t\tRD_HBA_VERSION, TARGET_CORE_VERSION);\n\n\treturn 0;\n}\n\nstatic void rd_detach_hba(struct se_hba *hba)\n{\n\tstruct rd_host *rd_host = hba->hba_ptr;\n\n\tpr_debug(\"CORE_HBA[%d] - Detached Ramdisk HBA: %u from\"\n\t\t\" Generic Target Core\\n\", hba->hba_id, rd_host->rd_host_id);\n\n\tkfree(rd_host);\n\thba->hba_ptr = NULL;\n}\n\nstatic u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 sg_table_count)\n{\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tu32 i, j, page_count = 0, sg_per_table;\n\n\tfor (i = 0; i < sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\n\tkfree(sg_table);\n\treturn page_count;\n}\n\nstatic void rd_release_device_space(struct rd_dev *rd_dev)\n{\n\tu32 page_count;\n\n\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n\t\treturn;\n\n\tpage_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,\n\t\t\t\t\t  rd_dev->sg_table_count);\n\n\tpr_debug(\"CORE_RD[%u] - Released device space for Ramdisk\"\n\t\t\" Device ID: %u, pages %u in %u tables total bytes %lu\\n\",\n\t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n\t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n\n\trd_dev->sg_table_array = NULL;\n\trd_dev->sg_table_count = 0;\n}\n\n\n \nstatic int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 total_sg_needed, unsigned char init_payload)\n{\n\tu32 i = 0, j, page_offset = 0, sg_per_table;\n\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tunsigned char *p;\n\n\twhile (total_sg_needed) {\n\t\tunsigned int chain_entry = 0;\n\n\t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n\t\t\tmax_sg_per_table : total_sg_needed;\n\n\t\t \n\t\tif (sg_per_table < total_sg_needed)\n\t\t\tchain_entry = 1;\n\n\t\tsg = kmalloc_array(sg_per_table + chain_entry, sizeof(*sg),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!sg)\n\t\t\treturn -ENOMEM;\n\n\t\tsg_init_table(sg, sg_per_table + chain_entry);\n\n\t\tif (i > 0) {\n\t\t\tsg_chain(sg_table[i - 1].sg_table,\n\t\t\t\t max_sg_per_table + 1, sg);\n\t\t}\n\n\t\tsg_table[i].sg_table = sg;\n\t\tsg_table[i].rd_sg_count = sg_per_table;\n\t\tsg_table[i].page_start_offset = page_offset;\n\t\tsg_table[i++].page_end_offset = (page_offset + sg_per_table)\n\t\t\t\t\t\t- 1;\n\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = alloc_pages(GFP_KERNEL, 0);\n\t\t\tif (!pg) {\n\t\t\t\tpr_err(\"Unable to allocate scatterlist\"\n\t\t\t\t\t\" pages for struct rd_dev_sg_table\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsg_assign_page(&sg[j], pg);\n\t\t\tsg[j].length = PAGE_SIZE;\n\n\t\t\tp = kmap(pg);\n\t\t\tmemset(p, init_payload, PAGE_SIZE);\n\t\t\tkunmap(pg);\n\t\t}\n\n\t\tpage_offset += sg_per_table;\n\t\ttotal_sg_needed -= sg_per_table;\n\t}\n\n\treturn 0;\n}\n\nstatic int rd_build_device_space(struct rd_dev *rd_dev)\n{\n\tstruct rd_dev_sg_table *sg_table;\n\tu32 sg_tables, total_sg_needed;\n\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\tint rc;\n\n\tif (rd_dev->rd_page_count <= 0) {\n\t\tpr_err(\"Illegal page count: %u for Ramdisk device\\n\",\n\t\t       rd_dev->rd_page_count);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rd_dev->rd_flags & RDF_NULLIO)\n\t\treturn 0;\n\n\ttotal_sg_needed = rd_dev->rd_page_count;\n\n\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n\tsg_table = kcalloc(sg_tables, sizeof(*sg_table), GFP_KERNEL);\n\tif (!sg_table)\n\t\treturn -ENOMEM;\n\n\trd_dev->sg_table_array = sg_table;\n\trd_dev->sg_table_count = sg_tables;\n\n\trc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);\n\tif (rc)\n\t\treturn rc;\n\n\tpr_debug(\"CORE_RD[%u] - Built Ramdisk Device ID: %u space of\"\n\t\t \" %u pages in %u tables\\n\", rd_dev->rd_host->rd_host_id,\n\t\t rd_dev->rd_dev_id, rd_dev->rd_page_count,\n\t\t rd_dev->sg_table_count);\n\n\treturn 0;\n}\n\nstatic void rd_release_prot_space(struct rd_dev *rd_dev)\n{\n\tu32 page_count;\n\n\tif (!rd_dev->sg_prot_array || !rd_dev->sg_prot_count)\n\t\treturn;\n\n\tpage_count = rd_release_sgl_table(rd_dev, rd_dev->sg_prot_array,\n\t\t\t\t\t  rd_dev->sg_prot_count);\n\n\tpr_debug(\"CORE_RD[%u] - Released protection space for Ramdisk\"\n\t\t \" Device ID: %u, pages %u in %u tables total bytes %lu\\n\",\n\t\t rd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n\t\t rd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n\n\trd_dev->sg_prot_array = NULL;\n\trd_dev->sg_prot_count = 0;\n}\n\nstatic int rd_build_prot_space(struct rd_dev *rd_dev, int prot_length, int block_size)\n{\n\tstruct rd_dev_sg_table *sg_table;\n\tu32 total_sg_needed, sg_tables;\n\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\tint rc;\n\n\tif (rd_dev->rd_flags & RDF_NULLIO)\n\t\treturn 0;\n\t \n\ttotal_sg_needed = (rd_dev->rd_page_count * prot_length / block_size) + 1;\n\n\tsg_tables = (total_sg_needed / max_sg_per_table) + 1;\n\tsg_table = kcalloc(sg_tables, sizeof(*sg_table), GFP_KERNEL);\n\tif (!sg_table)\n\t\treturn -ENOMEM;\n\n\trd_dev->sg_prot_array = sg_table;\n\trd_dev->sg_prot_count = sg_tables;\n\n\trc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0xff);\n\tif (rc)\n\t\treturn rc;\n\n\tpr_debug(\"CORE_RD[%u] - Built Ramdisk Device ID: %u prot space of\"\n\t\t \" %u pages in %u tables\\n\", rd_dev->rd_host->rd_host_id,\n\t\t rd_dev->rd_dev_id, total_sg_needed, rd_dev->sg_prot_count);\n\n\treturn 0;\n}\n\nstatic struct se_device *rd_alloc_device(struct se_hba *hba, const char *name)\n{\n\tstruct rd_dev *rd_dev;\n\tstruct rd_host *rd_host = hba->hba_ptr;\n\n\trd_dev = kzalloc(sizeof(*rd_dev), GFP_KERNEL);\n\tif (!rd_dev)\n\t\treturn NULL;\n\n\trd_dev->rd_host = rd_host;\n\n\treturn &rd_dev->dev;\n}\n\nstatic int rd_configure_device(struct se_device *dev)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\tstruct rd_host *rd_host = dev->se_hba->hba_ptr;\n\tint ret;\n\n\tif (!(rd_dev->rd_flags & RDF_HAS_PAGE_COUNT)) {\n\t\tpr_debug(\"Missing rd_pages= parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = rd_build_device_space(rd_dev);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tdev->dev_attrib.hw_block_size = RD_BLOCKSIZE;\n\tdev->dev_attrib.hw_max_sectors = UINT_MAX;\n\tdev->dev_attrib.hw_queue_depth = RD_MAX_DEVICE_QUEUE_DEPTH;\n\tdev->dev_attrib.is_nonrot = 1;\n\n\trd_dev->rd_dev_id = rd_host->rd_host_dev_id_count++;\n\n\tpr_debug(\"CORE_RD[%u] - Added TCM MEMCPY Ramdisk Device ID: %u of\"\n\t\t\" %u pages in %u tables, %lu total bytes\\n\",\n\t\trd_host->rd_host_id, rd_dev->rd_dev_id, rd_dev->rd_page_count,\n\t\trd_dev->sg_table_count,\n\t\t(unsigned long)(rd_dev->rd_page_count * PAGE_SIZE));\n\n\treturn 0;\n\nfail:\n\trd_release_device_space(rd_dev);\n\treturn ret;\n}\n\nstatic void rd_dev_call_rcu(struct rcu_head *p)\n{\n\tstruct se_device *dev = container_of(p, struct se_device, rcu_head);\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\n\tkfree(rd_dev);\n}\n\nstatic void rd_free_device(struct se_device *dev)\n{\n\tcall_rcu(&dev->rcu_head, rd_dev_call_rcu);\n}\n\nstatic void rd_destroy_device(struct se_device *dev)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\n\trd_release_device_space(rd_dev);\n}\n\nstatic struct rd_dev_sg_table *rd_get_sg_table(struct rd_dev *rd_dev, u32 page)\n{\n\tstruct rd_dev_sg_table *sg_table;\n\tu32 i, sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\n\ti = page / sg_per_table;\n\tif (i < rd_dev->sg_table_count) {\n\t\tsg_table = &rd_dev->sg_table_array[i];\n\t\tif ((sg_table->page_start_offset <= page) &&\n\t\t    (sg_table->page_end_offset >= page))\n\t\t\treturn sg_table;\n\t}\n\n\tpr_err(\"Unable to locate struct rd_dev_sg_table for page: %u\\n\",\n\t\t\tpage);\n\n\treturn NULL;\n}\n\nstatic struct rd_dev_sg_table *rd_get_prot_table(struct rd_dev *rd_dev, u32 page)\n{\n\tstruct rd_dev_sg_table *sg_table;\n\tu32 i, sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\n\ti = page / sg_per_table;\n\tif (i < rd_dev->sg_prot_count) {\n\t\tsg_table = &rd_dev->sg_prot_array[i];\n\t\tif ((sg_table->page_start_offset <= page) &&\n\t\t     (sg_table->page_end_offset >= page))\n\t\t\treturn sg_table;\n\t}\n\n\tpr_err(\"Unable to locate struct prot rd_dev_sg_table for page: %u\\n\",\n\t\t\tpage);\n\n\treturn NULL;\n}\n\nstatic sense_reason_t rd_do_prot_rw(struct se_cmd *cmd, bool is_read)\n{\n\tstruct se_device *se_dev = cmd->se_dev;\n\tstruct rd_dev *dev = RD_DEV(se_dev);\n\tstruct rd_dev_sg_table *prot_table;\n\tstruct scatterlist *prot_sg;\n\tu32 sectors = cmd->data_length / se_dev->dev_attrib.block_size;\n\tu32 prot_offset, prot_page;\n\tu32 prot_npages __maybe_unused;\n\tu64 tmp;\n\tsense_reason_t rc = 0;\n\n\ttmp = cmd->t_task_lba * se_dev->prot_length;\n\tprot_offset = do_div(tmp, PAGE_SIZE);\n\tprot_page = tmp;\n\n\tprot_table = rd_get_prot_table(dev, prot_page);\n\tif (!prot_table)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tprot_sg = &prot_table->sg_table[prot_page -\n\t\t\t\t\tprot_table->page_start_offset];\n\n\tif (se_dev->dev_attrib.pi_prot_verify) {\n\t\tif (is_read)\n\t\t\trc = sbc_dif_verify(cmd, cmd->t_task_lba, sectors, 0,\n\t\t\t\t\t    prot_sg, prot_offset);\n\t\telse\n\t\t\trc = sbc_dif_verify(cmd, cmd->t_task_lba, sectors, 0,\n\t\t\t\t\t    cmd->t_prot_sg, 0);\n\t}\n\tif (!rc)\n\t\tsbc_dif_copy_prot(cmd, sectors, is_read, prot_sg, prot_offset);\n\n\treturn rc;\n}\n\nstatic sense_reason_t\nrd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,\n\t      enum dma_data_direction data_direction)\n{\n\tstruct se_device *se_dev = cmd->se_dev;\n\tstruct rd_dev *dev = RD_DEV(se_dev);\n\tstruct rd_dev_sg_table *table;\n\tstruct scatterlist *rd_sg;\n\tstruct sg_mapping_iter m;\n\tu32 rd_offset;\n\tu32 rd_size;\n\tu32 rd_page;\n\tu32 src_len;\n\tu64 tmp;\n\tsense_reason_t rc;\n\n\tif (dev->rd_flags & RDF_NULLIO) {\n\t\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\t\treturn 0;\n\t}\n\n\ttmp = cmd->t_task_lba * se_dev->dev_attrib.block_size;\n\trd_offset = do_div(tmp, PAGE_SIZE);\n\trd_page = tmp;\n\trd_size = cmd->data_length;\n\n\ttable = rd_get_sg_table(dev, rd_page);\n\tif (!table)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\trd_sg = &table->sg_table[rd_page - table->page_start_offset];\n\n\tpr_debug(\"RD[%u]: %s LBA: %llu, Size: %u Page: %u, Offset: %u\\n\",\n\t\t\tdev->rd_dev_id,\n\t\t\tdata_direction == DMA_FROM_DEVICE ? \"Read\" : \"Write\",\n\t\t\tcmd->t_task_lba, rd_size, rd_page, rd_offset);\n\n\tif (cmd->prot_type && se_dev->dev_attrib.pi_prot_type &&\n\t    data_direction == DMA_TO_DEVICE) {\n\t\trc = rd_do_prot_rw(cmd, false);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tsrc_len = PAGE_SIZE - rd_offset;\n\tsg_miter_start(&m, sgl, sgl_nents,\n\t\t\tdata_direction == DMA_FROM_DEVICE ?\n\t\t\t\tSG_MITER_TO_SG : SG_MITER_FROM_SG);\n\twhile (rd_size) {\n\t\tu32 len;\n\t\tvoid *rd_addr;\n\n\t\tsg_miter_next(&m);\n\t\tif (!(u32)m.length) {\n\t\t\tpr_debug(\"RD[%u]: invalid sgl %p len %zu\\n\",\n\t\t\t\t dev->rd_dev_id, m.addr, m.length);\n\t\t\tsg_miter_stop(&m);\n\t\t\treturn TCM_INCORRECT_AMOUNT_OF_DATA;\n\t\t}\n\t\tlen = min((u32)m.length, src_len);\n\t\tif (len > rd_size) {\n\t\t\tpr_debug(\"RD[%u]: size underrun page %d offset %d \"\n\t\t\t\t \"size %d\\n\", dev->rd_dev_id,\n\t\t\t\t rd_page, rd_offset, rd_size);\n\t\t\tlen = rd_size;\n\t\t}\n\t\tm.consumed = len;\n\n\t\trd_addr = sg_virt(rd_sg) + rd_offset;\n\n\t\tif (data_direction == DMA_FROM_DEVICE)\n\t\t\tmemcpy(m.addr, rd_addr, len);\n\t\telse\n\t\t\tmemcpy(rd_addr, m.addr, len);\n\n\t\trd_size -= len;\n\t\tif (!rd_size)\n\t\t\tcontinue;\n\n\t\tsrc_len -= len;\n\t\tif (src_len) {\n\t\t\trd_offset += len;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\trd_page++;\n\t\trd_offset = 0;\n\t\tsrc_len = PAGE_SIZE;\n\t\tif (rd_page <= table->page_end_offset) {\n\t\t\trd_sg++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttable = rd_get_sg_table(dev, rd_page);\n\t\tif (!table) {\n\t\t\tsg_miter_stop(&m);\n\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\t}\n\n\t\t \n\t\trd_sg = table->sg_table;\n\t}\n\tsg_miter_stop(&m);\n\n\tif (cmd->prot_type && se_dev->dev_attrib.pi_prot_type &&\n\t    data_direction == DMA_FROM_DEVICE) {\n\t\trc = rd_do_prot_rw(cmd, true);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn 0;\n}\n\nenum {\n\tOpt_rd_pages, Opt_rd_nullio, Opt_rd_dummy, Opt_err\n};\n\nstatic match_table_t tokens = {\n\t{Opt_rd_pages, \"rd_pages=%d\"},\n\t{Opt_rd_nullio, \"rd_nullio=%d\"},\n\t{Opt_rd_dummy, \"rd_dummy=%d\"},\n\t{Opt_err, NULL}\n};\n\nstatic ssize_t rd_set_configfs_dev_params(struct se_device *dev,\n\t\tconst char *page, ssize_t count)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\tchar *orig, *ptr, *opts;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint arg, token;\n\n\topts = kstrdup(page, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\n\torig = opts;\n\n\twhile ((ptr = strsep(&opts, \",\\n\")) != NULL) {\n\t\tif (!*ptr)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(ptr, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_rd_pages:\n\t\t\tmatch_int(args, &arg);\n\t\t\trd_dev->rd_page_count = arg;\n\t\t\tpr_debug(\"RAMDISK: Referencing Page\"\n\t\t\t\t\" Count: %u\\n\", rd_dev->rd_page_count);\n\t\t\trd_dev->rd_flags |= RDF_HAS_PAGE_COUNT;\n\t\t\tbreak;\n\t\tcase Opt_rd_nullio:\n\t\t\tmatch_int(args, &arg);\n\t\t\tif (arg != 1)\n\t\t\t\tbreak;\n\n\t\t\tpr_debug(\"RAMDISK: Setting NULLIO flag: %d\\n\", arg);\n\t\t\trd_dev->rd_flags |= RDF_NULLIO;\n\t\t\tbreak;\n\t\tcase Opt_rd_dummy:\n\t\t\tmatch_int(args, &arg);\n\t\t\tif (arg != 1)\n\t\t\t\tbreak;\n\n\t\t\tpr_debug(\"RAMDISK: Setting DUMMY flag: %d\\n\", arg);\n\t\t\trd_dev->rd_flags |= RDF_DUMMY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(orig);\n\treturn count;\n}\n\nstatic ssize_t rd_show_configfs_dev_params(struct se_device *dev, char *b)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\n\tssize_t bl = sprintf(b, \"TCM RamDisk ID: %u  RamDisk Makeup: rd_mcp\\n\",\n\t\t\trd_dev->rd_dev_id);\n\tbl += sprintf(b + bl, \"        PAGES/PAGE_SIZE: %u*%lu\"\n\t\t\t\"  SG_table_count: %u  nullio: %d dummy: %d\\n\",\n\t\t\trd_dev->rd_page_count,\n\t\t\tPAGE_SIZE, rd_dev->sg_table_count,\n\t\t\t!!(rd_dev->rd_flags & RDF_NULLIO),\n\t\t\t!!(rd_dev->rd_flags & RDF_DUMMY));\n\treturn bl;\n}\n\nstatic u32 rd_get_device_type(struct se_device *dev)\n{\n\tif (RD_DEV(dev)->rd_flags & RDF_DUMMY)\n\t\treturn 0x3f;  \n\telse\n\t\treturn sbc_get_device_type(dev);\n}\n\nstatic sector_t rd_get_blocks(struct se_device *dev)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\n\tunsigned long long blocks_long = ((rd_dev->rd_page_count * PAGE_SIZE) /\n\t\t\tdev->dev_attrib.block_size) - 1;\n\n\treturn blocks_long;\n}\n\nstatic int rd_init_prot(struct se_device *dev)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\n        if (!dev->dev_attrib.pi_prot_type)\n\t\treturn 0;\n\n\treturn rd_build_prot_space(rd_dev, dev->prot_length,\n\t\t\t\t   dev->dev_attrib.block_size);\n}\n\nstatic void rd_free_prot(struct se_device *dev)\n{\n\tstruct rd_dev *rd_dev = RD_DEV(dev);\n\n\trd_release_prot_space(rd_dev);\n}\n\nstatic struct exec_cmd_ops rd_exec_cmd_ops = {\n\t.execute_rw\t\t= rd_execute_rw,\n};\n\nstatic sense_reason_t\nrd_parse_cdb(struct se_cmd *cmd)\n{\n\treturn sbc_parse_cdb(cmd, &rd_exec_cmd_ops);\n}\n\nstatic const struct target_backend_ops rd_mcp_ops = {\n\t.name\t\t\t= \"rd_mcp\",\n\t.inquiry_prod\t\t= \"RAMDISK-MCP\",\n\t.inquiry_rev\t\t= RD_MCP_VERSION,\n\t.attach_hba\t\t= rd_attach_hba,\n\t.detach_hba\t\t= rd_detach_hba,\n\t.alloc_device\t\t= rd_alloc_device,\n\t.configure_device\t= rd_configure_device,\n\t.destroy_device\t\t= rd_destroy_device,\n\t.free_device\t\t= rd_free_device,\n\t.parse_cdb\t\t= rd_parse_cdb,\n\t.set_configfs_dev_params = rd_set_configfs_dev_params,\n\t.show_configfs_dev_params = rd_show_configfs_dev_params,\n\t.get_device_type\t= rd_get_device_type,\n\t.get_blocks\t\t= rd_get_blocks,\n\t.init_prot\t\t= rd_init_prot,\n\t.free_prot\t\t= rd_free_prot,\n\t.tb_dev_attrib_attrs\t= sbc_attrib_attrs,\n};\n\nint __init rd_module_init(void)\n{\n\treturn transport_backend_register(&rd_mcp_ops);\n}\n\nvoid rd_module_exit(void)\n{\n\ttarget_backend_unregister(&rd_mcp_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}