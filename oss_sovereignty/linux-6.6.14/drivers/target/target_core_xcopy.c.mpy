{
  "module_name": "target_core_xcopy.c",
  "hash_id": "11330d462bf6714bf5705aaef8abd7779e7057bcaab8cac35c8081debb937189",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_xcopy.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/configfs.h>\n#include <linux/ratelimit.h>\n#include <scsi/scsi_proto.h>\n#include <asm/unaligned.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n#include <target/target_core_fabric.h>\n\n#include \"target_core_internal.h\"\n#include \"target_core_pr.h\"\n#include \"target_core_ua.h\"\n#include \"target_core_xcopy.h\"\n\nstatic struct workqueue_struct *xcopy_wq = NULL;\n\nstatic sense_reason_t target_parse_xcopy_cmd(struct xcopy_op *xop);\n\n \nstatic int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\n\t\t\t\t\t      const unsigned char *dev_wwn)\n{\n\tunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tint rc;\n\n\tif (!se_dev->dev_attrib.emulate_3pc) {\n\t\tpr_debug(\"XCOPY: emulate_3pc disabled on se_dev %p\\n\", se_dev);\n\t\treturn 0;\n\t}\n\n\tmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\tspc_gen_naa_6h_vendor_specific(se_dev, &tmp_dev_wwn[0]);\n\n\trc = memcmp(&tmp_dev_wwn[0], dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n\tif (rc != 0) {\n\t\tpr_debug(\"XCOPY: skip non-matching: %*ph\\n\",\n\t\t\t XCOPY_NAA_IEEE_REGEX_LEN, tmp_dev_wwn);\n\t\treturn 0;\n\t}\n\tpr_debug(\"XCOPY 0xe4: located se_dev: %p\\n\", se_dev);\n\n\treturn 1;\n}\n\nstatic int target_xcopy_locate_se_dev_e4(struct se_session *sess,\n\t\t\t\t\tconst unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **_found_dev,\n\t\t\t\t\tstruct percpu_ref **_found_lun_ref)\n{\n\tstruct se_dev_entry *deve;\n\tstruct se_node_acl *nacl;\n\tstruct se_lun *this_lun = NULL;\n\tstruct se_device *found_dev = NULL;\n\n\t \n\tif (!sess)\n\t\tgoto err_out;\n\n\tpr_debug(\"XCOPY 0xe4: searching for: %*ph\\n\",\n\t\t XCOPY_NAA_IEEE_REGEX_LEN, dev_wwn);\n\n\tnacl = sess->se_node_acl;\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(deve, &nacl->lun_entry_hlist, link) {\n\t\tstruct se_device *this_dev;\n\t\tint rc;\n\n\t\tthis_lun = deve->se_lun;\n\t\tthis_dev = rcu_dereference_raw(this_lun->lun_se_dev);\n\n\t\trc = target_xcopy_locate_se_dev_e4_iter(this_dev, dev_wwn);\n\t\tif (rc) {\n\t\t\tif (percpu_ref_tryget_live(&this_lun->lun_ref))\n\t\t\t\tfound_dev = this_dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (found_dev == NULL)\n\t\tgoto err_out;\n\n\tpr_debug(\"lun_ref held for se_dev: %p se_dev->se_dev_group: %p\\n\",\n\t\t found_dev, &found_dev->dev_group);\n\t*_found_dev = found_dev;\n\t*_found_lun_ref = &this_lun->lun_ref;\n\treturn 0;\nerr_out:\n\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\treturn -EINVAL;\n}\n\nstatic int target_xcopy_parse_tiddesc_e4(struct se_cmd *se_cmd, struct xcopy_op *xop,\n\t\t\t\tunsigned char *p, unsigned short cscd_index)\n{\n\tunsigned char *desc = p;\n\tunsigned short ript;\n\tu8 desig_len;\n\t \n\tript = get_unaligned_be16(&desc[2]);\n\tpr_debug(\"XCOPY 0xe4: RELATIVE INITIATOR PORT IDENTIFIER: %hu\\n\", ript);\n\t \n\tif ((desc[4] & 0x0f) != 0x1) {\n\t\tpr_err(\"XCOPY 0xe4: code set of non binary type not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((desc[5] & 0x30) != 0x00) {\n\t\tpr_err(\"XCOPY 0xe4: association other than LUN not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((desc[5] & 0x0f) != 0x3) {\n\t\tpr_err(\"XCOPY 0xe4: designator type unsupported: 0x%02x\\n\",\n\t\t\t\t(desc[5] & 0x0f));\n\t\treturn -EINVAL;\n\t}\n\t \n\tdesig_len = desc[7];\n\tif (desig_len != XCOPY_NAA_IEEE_REGEX_LEN) {\n\t\tpr_err(\"XCOPY 0xe4: invalid desig_len: %d\\n\", (int)desig_len);\n\t\treturn -EINVAL;\n\t}\n\tpr_debug(\"XCOPY 0xe4: desig_len: %d\\n\", (int)desig_len);\n\t \n\tif ((desc[8] & 0xf0) != 0x60) {\n\t\tpr_err(\"XCOPY 0xe4: Unsupported DESIGNATOR TYPE: 0x%02x\\n\",\n\t\t\t\t\t(desc[8] & 0xf0));\n\t\treturn -EINVAL;\n\t}\n\n\tif (cscd_index != xop->stdi && cscd_index != xop->dtdi) {\n\t\tpr_debug(\"XCOPY 0xe4: ignoring CSCD entry %d - neither src nor \"\n\t\t\t \"dest\\n\", cscd_index);\n\t\treturn 0;\n\t}\n\n\tif (cscd_index == xop->stdi) {\n\t\tmemcpy(&xop->src_tid_wwn[0], &desc[8], XCOPY_NAA_IEEE_REGEX_LEN);\n\t\t \n\t\tif (!memcmp(&xop->local_dev_wwn[0], &xop->src_tid_wwn[0],\n\t\t\t\tXCOPY_NAA_IEEE_REGEX_LEN)) {\n\t\t\txop->op_origin = XCOL_SOURCE_RECV_OP;\n\t\t\txop->src_dev = se_cmd->se_dev;\n\t\t\tpr_debug(\"XCOPY 0xe4: Set xop->src_dev %p from source\"\n\t\t\t\t\t\" received xop\\n\", xop->src_dev);\n\t\t}\n\t}\n\n\tif (cscd_index == xop->dtdi) {\n\t\tmemcpy(&xop->dst_tid_wwn[0], &desc[8], XCOPY_NAA_IEEE_REGEX_LEN);\n\t\t \n\t\tif (!memcmp(&xop->local_dev_wwn[0], &xop->dst_tid_wwn[0],\n\t\t\t\tXCOPY_NAA_IEEE_REGEX_LEN)) {\n\t\t\txop->op_origin = XCOL_DEST_RECV_OP;\n\t\t\txop->dst_dev = se_cmd->se_dev;\n\t\t\tpr_debug(\"XCOPY 0xe4: Set xop->dst_dev: %p from destination\"\n\t\t\t\t\" received xop\\n\", xop->dst_dev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,\n\t\t\t\tstruct xcopy_op *xop, unsigned char *p,\n\t\t\t\tunsigned short tdll, sense_reason_t *sense_ret)\n{\n\tstruct se_device *local_dev = se_cmd->se_dev;\n\tunsigned char *desc = p;\n\tint offset = tdll % XCOPY_TARGET_DESC_LEN, rc;\n\tunsigned short cscd_index = 0;\n\tunsigned short start = 0;\n\n\t*sense_ret = TCM_INVALID_PARAMETER_LIST;\n\n\tif (offset != 0) {\n\t\tpr_err(\"XCOPY target descriptor list length is not\"\n\t\t\t\" multiple of %d\\n\", XCOPY_TARGET_DESC_LEN);\n\t\t*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\n\t\treturn -EINVAL;\n\t}\n\tif (tdll > RCR_OP_MAX_TARGET_DESC_COUNT * XCOPY_TARGET_DESC_LEN) {\n\t\tpr_err(\"XCOPY target descriptor supports a maximum\"\n\t\t\t\" two src/dest descriptors, tdll: %hu too large..\\n\", tdll);\n\t\t \n\t\t*sense_ret = TCM_TOO_MANY_TARGET_DESCS;\n\t\treturn -EINVAL;\n\t}\n\t \n\tmemset(&xop->local_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\tspc_gen_naa_6h_vendor_specific(local_dev, &xop->local_dev_wwn[0]);\n\n\twhile (start < tdll) {\n\t\t \n\t\tswitch (desc[0]) {\n\t\tcase 0xe4:\n\t\t\trc = target_xcopy_parse_tiddesc_e4(se_cmd, xop,\n\t\t\t\t\t\t\t&desc[0], cscd_index);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto out;\n\t\t\tstart += XCOPY_TARGET_DESC_LEN;\n\t\t\tdesc += XCOPY_TARGET_DESC_LEN;\n\t\t\tcscd_index++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"XCOPY unsupported descriptor type code:\"\n\t\t\t\t\t\" 0x%02x\\n\", desc[0]);\n\t\t\t*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (xop->op_origin) {\n\tcase XCOL_SOURCE_RECV_OP:\n\t\trc = target_xcopy_locate_se_dev_e4(se_cmd->se_sess,\n\t\t\t\t\t\txop->dst_tid_wwn,\n\t\t\t\t\t\t&xop->dst_dev,\n\t\t\t\t\t\t&xop->remote_lun_ref);\n\t\tbreak;\n\tcase XCOL_DEST_RECV_OP:\n\t\trc = target_xcopy_locate_se_dev_e4(se_cmd->se_sess,\n\t\t\t\t\t\txop->src_tid_wwn,\n\t\t\t\t\t\t&xop->src_dev,\n\t\t\t\t\t\t&xop->remote_lun_ref);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"XCOPY CSCD descriptor IDs not found in CSCD list - \"\n\t\t\t\"stdi: %hu dtdi: %hu\\n\", xop->stdi, xop->dtdi);\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\t \n\tif (rc < 0) {\n\t\t*sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\\n\",\n\t\t xop->src_dev, &xop->src_tid_wwn[0]);\n\tpr_debug(\"XCOPY TGT desc: Dest dev: %p NAA IEEE WWN: 0x%16phN\\n\",\n\t\t xop->dst_dev, &xop->dst_tid_wwn[0]);\n\n\treturn cscd_index;\n\nout:\n\treturn -EINVAL;\n}\n\nstatic int target_xcopy_parse_segdesc_02(struct xcopy_op *xop, unsigned char *p)\n{\n\tunsigned char *desc = p;\n\tint dc = (desc[1] & 0x02);\n\tunsigned short desc_len;\n\n\tdesc_len = get_unaligned_be16(&desc[2]);\n\tif (desc_len != 0x18) {\n\t\tpr_err(\"XCOPY segment desc 0x02: Illegal desc_len:\"\n\t\t\t\t\" %hu\\n\", desc_len);\n\t\treturn -EINVAL;\n\t}\n\n\txop->stdi = get_unaligned_be16(&desc[4]);\n\txop->dtdi = get_unaligned_be16(&desc[6]);\n\n\tif (xop->stdi > XCOPY_CSCD_DESC_ID_LIST_OFF_MAX ||\n\t    xop->dtdi > XCOPY_CSCD_DESC_ID_LIST_OFF_MAX) {\n\t\tpr_err(\"XCOPY segment desc 0x02: unsupported CSCD ID > 0x%x; stdi: %hu dtdi: %hu\\n\",\n\t\t\tXCOPY_CSCD_DESC_ID_LIST_OFF_MAX, xop->stdi, xop->dtdi);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"XCOPY seg desc 0x02: desc_len: %hu stdi: %hu dtdi: %hu, DC: %d\\n\",\n\t\tdesc_len, xop->stdi, xop->dtdi, dc);\n\n\txop->nolb = get_unaligned_be16(&desc[10]);\n\txop->src_lba = get_unaligned_be64(&desc[12]);\n\txop->dst_lba = get_unaligned_be64(&desc[20]);\n\tpr_debug(\"XCOPY seg desc 0x02: nolb: %hu src_lba: %llu dst_lba: %llu\\n\",\n\t\txop->nolb, (unsigned long long)xop->src_lba,\n\t\t(unsigned long long)xop->dst_lba);\n\n\treturn 0;\n}\n\nstatic int target_xcopy_parse_segment_descriptors(struct xcopy_op *xop,\n\t\t\t\tunsigned char *p, unsigned int sdll,\n\t\t\t\tsense_reason_t *sense_ret)\n{\n\tunsigned char *desc = p;\n\tunsigned int start = 0;\n\tint offset = sdll % XCOPY_SEGMENT_DESC_LEN, rc, ret = 0;\n\n\t*sense_ret = TCM_INVALID_PARAMETER_LIST;\n\n\tif (offset != 0) {\n\t\tpr_err(\"XCOPY segment descriptor list length is not\"\n\t\t\t\" multiple of %d\\n\", XCOPY_SEGMENT_DESC_LEN);\n\t\t*sense_ret = TCM_UNSUPPORTED_SEGMENT_DESC_TYPE_CODE;\n\t\treturn -EINVAL;\n\t}\n\tif (sdll > RCR_OP_MAX_SG_DESC_COUNT * XCOPY_SEGMENT_DESC_LEN) {\n\t\tpr_err(\"XCOPY supports %u segment descriptor(s), sdll: %u too\"\n\t\t\t\" large..\\n\", RCR_OP_MAX_SG_DESC_COUNT, sdll);\n\t\t \n\t\t*sense_ret = TCM_TOO_MANY_SEGMENT_DESCS;\n\t\treturn -EINVAL;\n\t}\n\n\twhile (start < sdll) {\n\t\t \n\t\tswitch (desc[0]) {\n\t\tcase 0x02:\n\t\t\trc = target_xcopy_parse_segdesc_02(xop, desc);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\n\t\t\tret++;\n\t\t\tstart += XCOPY_SEGMENT_DESC_LEN;\n\t\t\tdesc += XCOPY_SEGMENT_DESC_LEN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"XCOPY unsupported segment descriptor\"\n\t\t\t\t\"type: 0x%02x\\n\", desc[0]);\n\t\t\t*sense_ret = TCM_UNSUPPORTED_SEGMENT_DESC_TYPE_CODE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn ret;\n\nout:\n\treturn -EINVAL;\n}\n\n \n\nstruct xcopy_pt_cmd {\n\tstruct se_cmd se_cmd;\n\tstruct completion xpt_passthrough_sem;\n\tunsigned char sense_buffer[TRANSPORT_SENSE_BUFFER];\n};\n\nstruct se_portal_group xcopy_pt_tpg;\nstatic struct se_session xcopy_pt_sess;\nstatic struct se_node_acl xcopy_pt_nacl;\n\nstatic int xcopy_pt_get_cmd_state(struct se_cmd *se_cmd)\n{\n        return 0;\n}\n\nstatic void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tpr_debug(\"putting dst lun_ref for %p\\n\", xop->dst_dev);\n\telse\n\t\tpr_debug(\"putting src lun_ref for %p\\n\", xop->src_dev);\n\n\tpercpu_ref_put(xop->remote_lun_ref);\n}\n\nstatic void xcopy_pt_release_cmd(struct se_cmd *se_cmd)\n{\n\tstruct xcopy_pt_cmd *xpt_cmd = container_of(se_cmd,\n\t\t\t\tstruct xcopy_pt_cmd, se_cmd);\n\n\t \n\tpr_debug(\"xpt_cmd done: %p\\n\", xpt_cmd);\n}\n\nstatic int xcopy_pt_check_stop_free(struct se_cmd *se_cmd)\n{\n\tstruct xcopy_pt_cmd *xpt_cmd = container_of(se_cmd,\n\t\t\t\tstruct xcopy_pt_cmd, se_cmd);\n\n\tcomplete(&xpt_cmd->xpt_passthrough_sem);\n\treturn 0;\n}\n\nstatic int xcopy_pt_write_pending(struct se_cmd *se_cmd)\n{\n\treturn 0;\n}\n\nstatic int xcopy_pt_queue_data_in(struct se_cmd *se_cmd)\n{\n\treturn 0;\n}\n\nstatic int xcopy_pt_queue_status(struct se_cmd *se_cmd)\n{\n\treturn 0;\n}\n\nstatic const struct target_core_fabric_ops xcopy_pt_tfo = {\n\t.fabric_name\t\t= \"xcopy-pt\",\n\t.get_cmd_state\t\t= xcopy_pt_get_cmd_state,\n\t.release_cmd\t\t= xcopy_pt_release_cmd,\n\t.check_stop_free\t= xcopy_pt_check_stop_free,\n\t.write_pending\t\t= xcopy_pt_write_pending,\n\t.queue_data_in\t\t= xcopy_pt_queue_data_in,\n\t.queue_status\t\t= xcopy_pt_queue_status,\n};\n\n \n\nint target_xcopy_setup_pt(void)\n{\n\txcopy_wq = alloc_workqueue(\"xcopy_wq\", WQ_MEM_RECLAIM, 0);\n\tif (!xcopy_wq) {\n\t\tpr_err(\"Unable to allocate xcopy_wq\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(&xcopy_pt_tpg, 0, sizeof(struct se_portal_group));\n\tINIT_LIST_HEAD(&xcopy_pt_tpg.acl_node_list);\n\tINIT_LIST_HEAD(&xcopy_pt_tpg.tpg_sess_list);\n\n\txcopy_pt_tpg.se_tpg_tfo = &xcopy_pt_tfo;\n\n\tmemset(&xcopy_pt_nacl, 0, sizeof(struct se_node_acl));\n\tINIT_LIST_HEAD(&xcopy_pt_nacl.acl_list);\n\tINIT_LIST_HEAD(&xcopy_pt_nacl.acl_sess_list);\n\tmemset(&xcopy_pt_sess, 0, sizeof(struct se_session));\n\ttransport_init_session(&xcopy_pt_sess);\n\n\txcopy_pt_nacl.se_tpg = &xcopy_pt_tpg;\n\txcopy_pt_nacl.nacl_sess = &xcopy_pt_sess;\n\n\txcopy_pt_sess.se_tpg = &xcopy_pt_tpg;\n\txcopy_pt_sess.se_node_acl = &xcopy_pt_nacl;\n\n\treturn 0;\n}\n\nvoid target_xcopy_release_pt(void)\n{\n\tif (xcopy_wq)\n\t\tdestroy_workqueue(xcopy_wq);\n}\n\n \nstatic int target_xcopy_setup_pt_cmd(\n\tstruct xcopy_pt_cmd *xpt_cmd,\n\tstruct xcopy_op *xop,\n\tstruct se_device *se_dev,\n\tunsigned char *cdb,\n\tbool remote_port)\n{\n\tstruct se_cmd *cmd = &xpt_cmd->se_cmd;\n\n\t \n\tif (remote_port) {\n\t\tcmd->se_lun = &se_dev->xcopy_lun;\n\t\tcmd->se_dev = se_dev;\n\t} else {\n\t\tcmd->se_lun = xop->xop_se_cmd->se_lun;\n\t\tcmd->se_dev = xop->xop_se_cmd->se_dev;\n\t}\n\tcmd->se_cmd_flags |= SCF_SE_LUN_CMD;\n\n\tif (target_cmd_init_cdb(cmd, cdb, GFP_KERNEL))\n\t\treturn -EINVAL;\n\n\tcmd->tag = 0;\n\tif (target_cmd_parse_cdb(cmd))\n\t\treturn -EINVAL;\n\n\tif (transport_generic_map_mem_to_cmd(cmd, xop->xop_data_sg,\n\t\t\t\t\txop->xop_data_nents, NULL, 0))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"Setup PASSTHROUGH_NOALLOC t_data_sg: %p t_data_nents:\"\n\t\t \" %u\\n\", cmd->t_data_sg, cmd->t_data_nents);\n\n\treturn 0;\n}\n\nstatic int target_xcopy_issue_pt_cmd(struct xcopy_pt_cmd *xpt_cmd)\n{\n\tstruct se_cmd *se_cmd = &xpt_cmd->se_cmd;\n\tsense_reason_t sense_rc;\n\n\tsense_rc = transport_generic_new_cmd(se_cmd);\n\tif (sense_rc)\n\t\treturn -EINVAL;\n\n\tif (se_cmd->data_direction == DMA_TO_DEVICE)\n\t\ttarget_execute_cmd(se_cmd);\n\n\twait_for_completion_interruptible(&xpt_cmd->xpt_passthrough_sem);\n\n\tpr_debug(\"target_xcopy_issue_pt_cmd(): SCSI status: 0x%02x\\n\",\n\t\t\tse_cmd->scsi_status);\n\n\treturn (se_cmd->scsi_status) ? -EINVAL : 0;\n}\n\nstatic int target_xcopy_read_source(\n\tstruct se_cmd *ec_cmd,\n\tstruct xcopy_op *xop,\n\tstruct se_device *src_dev,\n\tsector_t src_lba,\n\tu32 src_bytes)\n{\n\tstruct xcopy_pt_cmd xpt_cmd;\n\tstruct se_cmd *se_cmd = &xpt_cmd.se_cmd;\n\tu32 transfer_length_block = src_bytes / src_dev->dev_attrib.block_size;\n\tint rc;\n\tunsigned char cdb[16];\n\tbool remote_port = (xop->op_origin == XCOL_DEST_RECV_OP);\n\n\tmemset(&xpt_cmd, 0, sizeof(xpt_cmd));\n\tinit_completion(&xpt_cmd.xpt_passthrough_sem);\n\n\tmemset(&cdb[0], 0, 16);\n\tcdb[0] = READ_16;\n\tput_unaligned_be64(src_lba, &cdb[2]);\n\tput_unaligned_be32(transfer_length_block, &cdb[10]);\n\tpr_debug(\"XCOPY: Built READ_16: LBA: %llu Blocks: %u Length: %u\\n\",\n\t\t(unsigned long long)src_lba, transfer_length_block, src_bytes);\n\n\t__target_init_cmd(se_cmd, &xcopy_pt_tfo, &xcopy_pt_sess, src_bytes,\n\t\t\t  DMA_FROM_DEVICE, 0, &xpt_cmd.sense_buffer[0], 0,\n\t\t\t  NULL);\n\trc = target_xcopy_setup_pt_cmd(&xpt_cmd, xop, src_dev, &cdb[0],\n\t\t\t\tremote_port);\n\tif (rc < 0) {\n\t\tec_cmd->scsi_status = se_cmd->scsi_status;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"XCOPY-READ: Saved xop->xop_data_sg: %p, num: %u for READ\"\n\t\t\" memory\\n\", xop->xop_data_sg, xop->xop_data_nents);\n\n\trc = target_xcopy_issue_pt_cmd(&xpt_cmd);\n\tif (rc < 0)\n\t\tec_cmd->scsi_status = se_cmd->scsi_status;\nout:\n\ttransport_generic_free_cmd(se_cmd, 0);\n\treturn rc;\n}\n\nstatic int target_xcopy_write_destination(\n\tstruct se_cmd *ec_cmd,\n\tstruct xcopy_op *xop,\n\tstruct se_device *dst_dev,\n\tsector_t dst_lba,\n\tu32 dst_bytes)\n{\n\tstruct xcopy_pt_cmd xpt_cmd;\n\tstruct se_cmd *se_cmd = &xpt_cmd.se_cmd;\n\tu32 transfer_length_block = dst_bytes / dst_dev->dev_attrib.block_size;\n\tint rc;\n\tunsigned char cdb[16];\n\tbool remote_port = (xop->op_origin == XCOL_SOURCE_RECV_OP);\n\n\tmemset(&xpt_cmd, 0, sizeof(xpt_cmd));\n\tinit_completion(&xpt_cmd.xpt_passthrough_sem);\n\n\tmemset(&cdb[0], 0, 16);\n\tcdb[0] = WRITE_16;\n\tput_unaligned_be64(dst_lba, &cdb[2]);\n\tput_unaligned_be32(transfer_length_block, &cdb[10]);\n\tpr_debug(\"XCOPY: Built WRITE_16: LBA: %llu Blocks: %u Length: %u\\n\",\n\t\t(unsigned long long)dst_lba, transfer_length_block, dst_bytes);\n\n\t__target_init_cmd(se_cmd, &xcopy_pt_tfo, &xcopy_pt_sess, dst_bytes,\n\t\t\t  DMA_TO_DEVICE, 0, &xpt_cmd.sense_buffer[0], 0,\n\t\t\t  NULL);\n\trc = target_xcopy_setup_pt_cmd(&xpt_cmd, xop, dst_dev, &cdb[0],\n\t\t\t\tremote_port);\n\tif (rc < 0) {\n\t\tec_cmd->scsi_status = se_cmd->scsi_status;\n\t\tgoto out;\n\t}\n\n\trc = target_xcopy_issue_pt_cmd(&xpt_cmd);\n\tif (rc < 0)\n\t\tec_cmd->scsi_status = se_cmd->scsi_status;\nout:\n\ttransport_generic_free_cmd(se_cmd, 0);\n\treturn rc;\n}\n\nstatic void target_xcopy_do_work(struct work_struct *work)\n{\n\tstruct xcopy_op *xop = container_of(work, struct xcopy_op, xop_work);\n\tstruct se_cmd *ec_cmd = xop->xop_se_cmd;\n\tstruct se_device *src_dev, *dst_dev;\n\tsector_t src_lba, dst_lba, end_lba;\n\tunsigned long long max_bytes, max_bytes_src, max_bytes_dst, max_blocks;\n\tint rc = 0;\n\tunsigned short nolb;\n\tunsigned int copied_bytes = 0;\n\tsense_reason_t sense_rc;\n\n\tsense_rc = target_parse_xcopy_cmd(xop);\n\tif (sense_rc != TCM_NO_SENSE)\n\t\tgoto err_free;\n\n\tif (WARN_ON_ONCE(!xop->src_dev) || WARN_ON_ONCE(!xop->dst_dev)) {\n\t\tsense_rc = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto err_free;\n\t}\n\n\tsrc_dev = xop->src_dev;\n\tdst_dev = xop->dst_dev;\n\tsrc_lba = xop->src_lba;\n\tdst_lba = xop->dst_lba;\n\tnolb = xop->nolb;\n\tend_lba = src_lba + nolb;\n\t \n\tmax_bytes_src = (unsigned long long) src_dev->dev_attrib.hw_max_sectors *\n\t\t\tsrc_dev->dev_attrib.hw_block_size;\n\tmax_bytes_dst = (unsigned long long) dst_dev->dev_attrib.hw_max_sectors *\n\t\t\tdst_dev->dev_attrib.hw_block_size;\n\n\tmax_bytes = min_t(u64, max_bytes_src, max_bytes_dst);\n\tmax_bytes = min_t(u64, max_bytes, XCOPY_MAX_BYTES);\n\n\t \n\tmax_blocks = max_bytes >> ilog2(src_dev->dev_attrib.block_size);\n\n\tpr_debug(\"%s: nolb: %u, max_blocks: %llu end_lba: %llu\\n\", __func__,\n\t\t\tnolb, max_blocks, (unsigned long long)end_lba);\n\tpr_debug(\"%s: Starting src_lba: %llu, dst_lba: %llu\\n\", __func__,\n\t\t\t(unsigned long long)src_lba, (unsigned long long)dst_lba);\n\n\twhile (nolb) {\n\t\tu32 cur_bytes = min_t(u64, max_bytes, nolb * src_dev->dev_attrib.block_size);\n\t\tunsigned short cur_nolb = cur_bytes / src_dev->dev_attrib.block_size;\n\n\t\tif (cur_bytes != xop->xop_data_bytes) {\n\t\t\t \n\t\t\ttarget_free_sgl(xop->xop_data_sg, xop->xop_data_nents);\n\t\t\trc = target_alloc_sgl(&xop->xop_data_sg,\n\t\t\t\t\t      &xop->xop_data_nents,\n\t\t\t\t\t      cur_bytes,\n\t\t\t\t\t      false, false);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\txop->xop_data_bytes = cur_bytes;\n\t\t}\n\n\t\tpr_debug(\"%s: Calling read src_dev: %p src_lba: %llu, cur_nolb: %hu\\n\",\n\t\t\t\t__func__, src_dev, (unsigned long long)src_lba, cur_nolb);\n\n\t\trc = target_xcopy_read_source(ec_cmd, xop, src_dev, src_lba, cur_bytes);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\tsrc_lba += cur_bytes / src_dev->dev_attrib.block_size;\n\t\tpr_debug(\"%s: Incremented READ src_lba to %llu\\n\", __func__,\n\t\t\t\t(unsigned long long)src_lba);\n\n\t\tpr_debug(\"%s: Calling write dst_dev: %p dst_lba: %llu, cur_nolb: %u\\n\",\n\t\t\t\t__func__, dst_dev, (unsigned long long)dst_lba, cur_nolb);\n\n\t\trc = target_xcopy_write_destination(ec_cmd, xop, dst_dev,\n\t\t\t\t\t\tdst_lba, cur_bytes);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\tdst_lba += cur_bytes / dst_dev->dev_attrib.block_size;\n\t\tpr_debug(\"%s: Incremented WRITE dst_lba to %llu\\n\", __func__,\n\t\t\t\t(unsigned long long)dst_lba);\n\n\t\tcopied_bytes += cur_bytes;\n\t\tnolb -= cur_bytes / src_dev->dev_attrib.block_size;\n\t}\n\n\txcopy_pt_undepend_remotedev(xop);\n\ttarget_free_sgl(xop->xop_data_sg, xop->xop_data_nents);\n\tkfree(xop);\n\n\tpr_debug(\"%s: Final src_lba: %llu, dst_lba: %llu\\n\", __func__,\n\t\t(unsigned long long)src_lba, (unsigned long long)dst_lba);\n\tpr_debug(\"%s: Blocks copied: %u, Bytes Copied: %u\\n\", __func__,\n\t\tcopied_bytes / dst_dev->dev_attrib.block_size, copied_bytes);\n\n\tpr_debug(\"%s: Setting X-COPY GOOD status -> sending response\\n\", __func__);\n\ttarget_complete_cmd(ec_cmd, SAM_STAT_GOOD);\n\treturn;\n\nout:\n\t \n\tsense_rc = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE;\n\txcopy_pt_undepend_remotedev(xop);\n\ttarget_free_sgl(xop->xop_data_sg, xop->xop_data_nents);\n\nerr_free:\n\tkfree(xop);\n\tpr_warn_ratelimited(\"%s: rc: %d, sense: %u, XCOPY operation failed\\n\",\n\t\t\t   __func__, rc, sense_rc);\n\ttarget_complete_cmd_with_sense(ec_cmd, SAM_STAT_CHECK_CONDITION, sense_rc);\n}\n\n \nstatic sense_reason_t target_parse_xcopy_cmd(struct xcopy_op *xop)\n{\n\tstruct se_cmd *se_cmd = xop->xop_se_cmd;\n\tunsigned char *p = NULL, *seg_desc;\n\tunsigned int list_id, list_id_usage, sdll, inline_dl;\n\tsense_reason_t ret = TCM_INVALID_PARAMETER_LIST;\n\tint rc;\n\tunsigned short tdll;\n\n\tp = transport_kmap_data_sg(se_cmd);\n\tif (!p) {\n\t\tpr_err(\"transport_kmap_data_sg() failed in target_do_xcopy\\n\");\n\t\treturn TCM_OUT_OF_RESOURCES;\n\t}\n\n\tlist_id = p[0];\n\tlist_id_usage = (p[1] & 0x18) >> 3;\n\n\t \n\ttdll = get_unaligned_be16(&p[2]);\n\tsdll = get_unaligned_be32(&p[8]);\n\tif (tdll + sdll > RCR_OP_MAX_DESC_LIST_LEN) {\n\t\tpr_err(\"XCOPY descriptor list length %u exceeds maximum %u\\n\",\n\t\t       tdll + sdll, RCR_OP_MAX_DESC_LIST_LEN);\n\t\tret = TCM_PARAMETER_LIST_LENGTH_ERROR;\n\t\tgoto out;\n\t}\n\n\tinline_dl = get_unaligned_be32(&p[12]);\n\tif (inline_dl != 0) {\n\t\tpr_err(\"XCOPY with non zero inline data length\\n\");\n\t\tgoto out;\n\t}\n\n\tif (se_cmd->data_length < (XCOPY_HDR_LEN + tdll + sdll + inline_dl)) {\n\t\tpr_err(\"XCOPY parameter truncation: data length %u too small \"\n\t\t\t\"for tdll: %hu sdll: %u inline_dl: %u\\n\",\n\t\t\tse_cmd->data_length, tdll, sdll, inline_dl);\n\t\tret = TCM_PARAMETER_LIST_LENGTH_ERROR;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"Processing XCOPY with list_id: 0x%02x list_id_usage: 0x%02x\"\n\t\t\" tdll: %hu sdll: %u inline_dl: %u\\n\", list_id, list_id_usage,\n\t\ttdll, sdll, inline_dl);\n\n\t \n\tseg_desc = &p[16] + tdll;\n\n\trc = target_xcopy_parse_segment_descriptors(xop, seg_desc, sdll, &ret);\n\tif (rc <= 0)\n\t\tgoto out;\n\n\tpr_debug(\"XCOPY: Processed %d segment descriptors, length: %u\\n\", rc,\n\t\t\t\trc * XCOPY_SEGMENT_DESC_LEN);\n\n\trc = target_xcopy_parse_target_descriptors(se_cmd, xop, &p[16], tdll, &ret);\n\tif (rc <= 0)\n\t\tgoto out;\n\n\tif (xop->src_dev->dev_attrib.block_size !=\n\t    xop->dst_dev->dev_attrib.block_size) {\n\t\tpr_err(\"XCOPY: Non matching src_dev block_size: %u + dst_dev\"\n\t\t       \" block_size: %u currently unsupported\\n\",\n\t\t\txop->src_dev->dev_attrib.block_size,\n\t\t\txop->dst_dev->dev_attrib.block_size);\n\t\txcopy_pt_undepend_remotedev(xop);\n\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"XCOPY: Processed %d target descriptors, length: %u\\n\", rc,\n\t\t\t\trc * XCOPY_TARGET_DESC_LEN);\n\ttransport_kunmap_data_sg(se_cmd);\n\treturn TCM_NO_SENSE;\n\nout:\n\tif (p)\n\t\ttransport_kunmap_data_sg(se_cmd);\n\treturn ret;\n}\n\nsense_reason_t target_do_xcopy(struct se_cmd *se_cmd)\n{\n\tstruct se_device *dev = se_cmd->se_dev;\n\tstruct xcopy_op *xop;\n\tunsigned int sa;\n\n\tif (!dev->dev_attrib.emulate_3pc) {\n\t\tpr_err(\"EXTENDED_COPY operation explicitly disabled\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\tsa = se_cmd->t_task_cdb[1] & 0x1f;\n\tif (sa != 0x00) {\n\t\tpr_err(\"EXTENDED_COPY(LID4) not supported\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\tif (se_cmd->data_length == 0) {\n\t\ttarget_complete_cmd(se_cmd, SAM_STAT_GOOD);\n\t\treturn TCM_NO_SENSE;\n\t}\n\tif (se_cmd->data_length < XCOPY_HDR_LEN) {\n\t\tpr_err(\"XCOPY parameter truncation: length %u < hdr_len %u\\n\",\n\t\t\t\tse_cmd->data_length, XCOPY_HDR_LEN);\n\t\treturn TCM_PARAMETER_LIST_LENGTH_ERROR;\n\t}\n\n\txop = kzalloc(sizeof(struct xcopy_op), GFP_KERNEL);\n\tif (!xop)\n\t\tgoto err;\n\txop->xop_se_cmd = se_cmd;\n\tINIT_WORK(&xop->xop_work, target_xcopy_do_work);\n\tif (WARN_ON_ONCE(!queue_work(xcopy_wq, &xop->xop_work)))\n\t\tgoto free;\n\treturn TCM_NO_SENSE;\n\nfree:\n\tkfree(xop);\n\nerr:\n\treturn TCM_OUT_OF_RESOURCES;\n}\n\nstatic sense_reason_t target_rcr_operating_parameters(struct se_cmd *se_cmd)\n{\n\tunsigned char *p;\n\n\tp = transport_kmap_data_sg(se_cmd);\n\tif (!p) {\n\t\tpr_err(\"transport_kmap_data_sg failed in\"\n\t\t       \" target_rcr_operating_parameters\\n\");\n\t\treturn TCM_OUT_OF_RESOURCES;\n\t}\n\n\tif (se_cmd->data_length < 54) {\n\t\tpr_err(\"Receive Copy Results Op Parameters length\"\n\t\t       \" too small: %u\\n\", se_cmd->data_length);\n\t\ttransport_kunmap_data_sg(se_cmd);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\t \n\tp[4] = 0x1;\n\t \n\tput_unaligned_be16(RCR_OP_MAX_TARGET_DESC_COUNT, &p[8]);\n\t \n\tput_unaligned_be16(RCR_OP_MAX_SG_DESC_COUNT, &p[10]);\n\t \n\tput_unaligned_be32(RCR_OP_MAX_DESC_LIST_LEN, &p[12]);\n\t \n\tput_unaligned_be32(RCR_OP_MAX_SEGMENT_LEN, &p[16]);\n\t \n\tput_unaligned_be32(0x0, &p[20]);\n\t \n\tput_unaligned_be32(0x0, &p[24]);\n\t \n\tput_unaligned_be32(0x0, &p[28]);\n\t \n\tput_unaligned_be16(RCR_OP_TOTAL_CONCURR_COPIES, &p[34]);\n\t \n\tp[36] = RCR_OP_MAX_CONCURR_COPIES;\n\t \n\tp[37] = RCR_OP_DATA_SEG_GRAN_LOG2;\n\t \n\tp[38] = RCR_OP_INLINE_DATA_GRAN_LOG2;\n\t \n\tp[39] = RCR_OP_HELD_DATA_GRAN_LOG2;\n\t \n\tp[43] = 0x2;\n\t \n\tp[44] = 0x02;  \n\tp[45] = 0xe4;  \n\n\t \n\tput_unaligned_be32(42, &p[0]);\n\n\ttransport_kunmap_data_sg(se_cmd);\n\ttarget_complete_cmd(se_cmd, SAM_STAT_GOOD);\n\n\treturn TCM_NO_SENSE;\n}\n\nsense_reason_t target_do_receive_copy_results(struct se_cmd *se_cmd)\n{\n\tunsigned char *cdb = &se_cmd->t_task_cdb[0];\n\tint sa = (cdb[1] & 0x1f), list_id = cdb[2];\n\tstruct se_device *dev = se_cmd->se_dev;\n\tsense_reason_t rc = TCM_NO_SENSE;\n\n\tif (!dev->dev_attrib.emulate_3pc) {\n\t\tpr_debug(\"Third-party copy operations explicitly disabled\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\tpr_debug(\"Entering target_do_receive_copy_results: SA: 0x%02x, List ID:\"\n\t\t\" 0x%02x, AL: %u\\n\", sa, list_id, se_cmd->data_length);\n\n\tif (list_id != 0) {\n\t\tpr_err(\"Receive Copy Results with non zero list identifier\"\n\t\t       \" not supported\\n\");\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tswitch (sa) {\n\tcase RCR_SA_OPERATING_PARAMETERS:\n\t\trc = target_rcr_operating_parameters(se_cmd);\n\t\tbreak;\n\tcase RCR_SA_COPY_STATUS:\n\tcase RCR_SA_RECEIVE_DATA:\n\tcase RCR_SA_FAILED_SEGMENT_DETAILS:\n\tdefault:\n\t\tpr_err(\"Unsupported SA for receive copy results: 0x%02x\\n\", sa);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}