{
  "module_name": "target_core_pr.c",
  "hash_id": "19b5aa2f1cca059ee6001932ebfca83cd999d15f9a51869c887460a2b29231b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_pr.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <scsi/scsi_proto.h>\n#include <asm/unaligned.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n#include <target/target_core_fabric.h>\n\n#include \"target_core_internal.h\"\n#include \"target_core_pr.h\"\n#include \"target_core_ua.h\"\n\n \nstruct pr_transport_id_holder {\n\tstruct t10_pr_registration *dest_pr_reg;\n\tstruct se_portal_group *dest_tpg;\n\tstruct se_node_acl *dest_node_acl;\n\tstruct se_dev_entry *dest_se_deve;\n\tstruct list_head dest_list;\n};\n\nvoid core_pr_dump_initiator_port(\n\tstruct t10_pr_registration *pr_reg,\n\tchar *buf,\n\tu32 size)\n{\n\tif (!pr_reg->isid_present_at_reg) {\n\t\tbuf[0] = '\\0';\n\t\treturn;\n\t}\n\n\tsnprintf(buf, size, \",i,0x%s\", pr_reg->pr_reg_isid);\n}\n\nenum register_type {\n\tREGISTER,\n\tREGISTER_AND_IGNORE_EXISTING_KEY,\n\tREGISTER_AND_MOVE,\n};\n\nenum preempt_type {\n\tPREEMPT,\n\tPREEMPT_AND_ABORT,\n};\n\nstatic void __core_scsi3_complete_pro_release(struct se_device *, struct se_node_acl *,\n\t\t\t\t\t      struct t10_pr_registration *, int, int);\n\nstatic int is_reservation_holder(\n\tstruct t10_pr_registration *pr_res_holder,\n\tstruct t10_pr_registration *pr_reg)\n{\n\tint pr_res_type;\n\n\tif (pr_res_holder) {\n\t\tpr_res_type = pr_res_holder->pr_res_type;\n\n\t\treturn pr_res_holder == pr_reg ||\n\t\t       pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG ||\n\t\t       pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG;\n\t}\n\treturn 0;\n}\n\nstatic sense_reason_t\ntarget_scsi2_reservation_check(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_session *sess = cmd->se_sess;\n\n\tswitch (cmd->t_task_cdb[0]) {\n\tcase INQUIRY:\n\tcase RELEASE:\n\tcase RELEASE_10:\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!dev->reservation_holder || !sess)\n\t\treturn 0;\n\n\tif (dev->reservation_holder->se_node_acl != sess->se_node_acl)\n\t\treturn TCM_RESERVATION_CONFLICT;\n\n\tif (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS_WITH_ISID) {\n\t\tif (dev->dev_res_bin_isid != sess->sess_bin_isid)\n\t\t\treturn TCM_RESERVATION_CONFLICT;\n\t}\n\n\treturn 0;\n}\n\nstatic struct t10_pr_registration *core_scsi3_locate_pr_reg(struct se_device *,\n\t\t\t\t\tstruct se_node_acl *, struct se_session *);\nstatic void core_scsi3_put_pr_reg(struct t10_pr_registration *);\n\nstatic int target_check_scsi2_reservation_conflict(struct se_cmd *cmd)\n{\n\tstruct se_session *se_sess = cmd->se_sess;\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct t10_pr_registration *pr_reg;\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tint conflict = 0;\n\n\tpr_reg = core_scsi3_locate_pr_reg(cmd->se_dev, se_sess->se_node_acl,\n\t\t\tse_sess);\n\tif (pr_reg) {\n\t\t \n\t\tif (pr_reg->pr_res_holder) {\n\t\t\tcore_scsi3_put_pr_reg(pr_reg);\n\t\t\treturn 1;\n\t\t}\n\t\tif ((pr_reg->pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_REGONLY) ||\n\t\t    (pr_reg->pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_REGONLY) ||\n\t\t    (pr_reg->pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG) ||\n\t\t    (pr_reg->pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG)) {\n\t\t\tcore_scsi3_put_pr_reg(pr_reg);\n\t\t\treturn 1;\n\t\t}\n\t\tcore_scsi3_put_pr_reg(pr_reg);\n\t\tconflict = 1;\n\t} else {\n\t\t \n\t\tspin_lock(&pr_tmpl->registration_lock);\n\t\tconflict = (list_empty(&pr_tmpl->registration_list)) ? 0 : 1;\n\t\tspin_unlock(&pr_tmpl->registration_lock);\n\t}\n\n\tif (conflict) {\n\t\tpr_err(\"Received legacy SPC-2 RESERVE/RELEASE\"\n\t\t\t\" while active SPC-3 registrations exist,\"\n\t\t\t\" returning RESERVATION_CONFLICT\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nvoid target_release_reservation(struct se_device *dev)\n{\n\tdev->reservation_holder = NULL;\n\tdev->dev_reservation_flags &= ~DRF_SPC2_RESERVATIONS;\n\tif (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS_WITH_ISID) {\n\t\tdev->dev_res_bin_isid = 0;\n\t\tdev->dev_reservation_flags &= ~DRF_SPC2_RESERVATIONS_WITH_ISID;\n\t}\n}\n\nsense_reason_t\ntarget_scsi2_reservation_release(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_session *sess = cmd->se_sess;\n\tstruct se_portal_group *tpg;\n\tint rc;\n\n\tif (!sess || !sess->se_tpg)\n\t\tgoto out;\n\trc = target_check_scsi2_reservation_conflict(cmd);\n\tif (rc == 1)\n\t\tgoto out;\n\tif (rc < 0)\n\t\treturn TCM_RESERVATION_CONFLICT;\n\n\tspin_lock(&dev->dev_reservation_lock);\n\tif (!dev->reservation_holder || !sess)\n\t\tgoto out_unlock;\n\n\tif (dev->reservation_holder->se_node_acl != sess->se_node_acl)\n\t\tgoto out_unlock;\n\n\tif (dev->dev_res_bin_isid != sess->sess_bin_isid)\n\t\tgoto out_unlock;\n\n\ttarget_release_reservation(dev);\n\ttpg = sess->se_tpg;\n\tpr_debug(\"SCSI-2 Released reservation for %s LUN: %llu ->\"\n\t\t\" MAPPED LUN: %llu for %s\\n\",\n\t\ttpg->se_tpg_tfo->fabric_name,\n\t\tcmd->se_lun->unpacked_lun, cmd->orig_fe_lun,\n\t\tsess->se_node_acl->initiatorname);\n\nout_unlock:\n\tspin_unlock(&dev->dev_reservation_lock);\nout:\n\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn 0;\n}\n\nsense_reason_t\ntarget_scsi2_reservation_reserve(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_session *sess = cmd->se_sess;\n\tstruct se_portal_group *tpg;\n\tsense_reason_t ret = 0;\n\tint rc;\n\n\tif ((cmd->t_task_cdb[1] & 0x01) &&\n\t    (cmd->t_task_cdb[1] & 0x02)) {\n\t\tpr_err(\"LongIO and Obsolete Bits set, returning ILLEGAL_REQUEST\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\t \n\tif (!sess || !sess->se_tpg)\n\t\tgoto out;\n\trc = target_check_scsi2_reservation_conflict(cmd);\n\tif (rc == 1)\n\t\tgoto out;\n\n\tif (rc < 0)\n\t\treturn TCM_RESERVATION_CONFLICT;\n\n\ttpg = sess->se_tpg;\n\tspin_lock(&dev->dev_reservation_lock);\n\tif (dev->reservation_holder &&\n\t    dev->reservation_holder->se_node_acl != sess->se_node_acl) {\n\t\tpr_err(\"SCSI-2 RESERVATION CONFLICT for %s fabric\\n\",\n\t\t\ttpg->se_tpg_tfo->fabric_name);\n\t\tpr_err(\"Original reserver LUN: %llu %s\\n\",\n\t\t\tcmd->se_lun->unpacked_lun,\n\t\t\tdev->reservation_holder->se_node_acl->initiatorname);\n\t\tpr_err(\"Current attempt - LUN: %llu -> MAPPED LUN: %llu\"\n\t\t\t\" from %s \\n\", cmd->se_lun->unpacked_lun,\n\t\t\tcmd->orig_fe_lun,\n\t\t\tsess->se_node_acl->initiatorname);\n\t\tret = TCM_RESERVATION_CONFLICT;\n\t\tgoto out_unlock;\n\t}\n\n\tdev->reservation_holder = sess;\n\tdev->dev_reservation_flags |= DRF_SPC2_RESERVATIONS;\n\tif (sess->sess_bin_isid != 0) {\n\t\tdev->dev_res_bin_isid = sess->sess_bin_isid;\n\t\tdev->dev_reservation_flags |= DRF_SPC2_RESERVATIONS_WITH_ISID;\n\t}\n\tpr_debug(\"SCSI-2 Reserved %s LUN: %llu -> MAPPED LUN: %llu\"\n\t\t\" for %s\\n\", tpg->se_tpg_tfo->fabric_name,\n\t\tcmd->se_lun->unpacked_lun, cmd->orig_fe_lun,\n\t\tsess->se_node_acl->initiatorname);\n\nout_unlock:\n\tspin_unlock(&dev->dev_reservation_lock);\nout:\n\tif (!ret)\n\t\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn ret;\n}\n\n\n \nstatic int core_scsi3_pr_seq_non_holder(struct se_cmd *cmd, u32 pr_reg_type,\n\t\t\t\t\tbool isid_mismatch)\n{\n\tunsigned char *cdb = cmd->t_task_cdb;\n\tstruct se_session *se_sess = cmd->se_sess;\n\tstruct se_node_acl *nacl = se_sess->se_node_acl;\n\tint other_cdb = 0;\n\tint registered_nexus = 0, ret = 1;  \n\tint all_reg = 0, reg_only = 0;  \n\tint we = 0;  \n\tint legacy = 0;  \n\n\tif (isid_mismatch) {\n\t\tregistered_nexus = 0;\n\t} else {\n\t\tstruct se_dev_entry *se_deve;\n\n\t\trcu_read_lock();\n\t\tse_deve = target_nacl_find_deve(nacl, cmd->orig_fe_lun);\n\t\tif (se_deve)\n\t\t\tregistered_nexus = test_bit(DEF_PR_REG_ACTIVE,\n\t\t\t\t\t\t    &se_deve->deve_flags);\n\t\trcu_read_unlock();\n\t}\n\n\tswitch (pr_reg_type) {\n\tcase PR_TYPE_WRITE_EXCLUSIVE:\n\t\twe = 1;\n\t\tfallthrough;\n\tcase PR_TYPE_EXCLUSIVE_ACCESS:\n\t\t \n\t\tbreak;\n\tcase PR_TYPE_WRITE_EXCLUSIVE_REGONLY:\n\t\twe = 1;\n\t\tfallthrough;\n\tcase PR_TYPE_EXCLUSIVE_ACCESS_REGONLY:\n\t\t \n\t\treg_only = 1;\n\t\tbreak;\n\tcase PR_TYPE_WRITE_EXCLUSIVE_ALLREG:\n\t\twe = 1;\n\t\tfallthrough;\n\tcase PR_TYPE_EXCLUSIVE_ACCESS_ALLREG:\n\t\t \n\t\tall_reg = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t \n\tswitch (cdb[0]) {\n\tcase SECURITY_PROTOCOL_IN:\n\t\tif (registered_nexus)\n\t\t\treturn 0;\n\t\tret = (we) ? 0 : 1;\n\t\tbreak;\n\tcase MODE_SENSE:\n\tcase MODE_SENSE_10:\n\tcase READ_ATTRIBUTE:\n\tcase READ_BUFFER:\n\tcase RECEIVE_DIAGNOSTIC:\n\t\tif (legacy) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (registered_nexus) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tret = (we) ? 0 : 1;  \n\t\tbreak;\n\tcase PERSISTENT_RESERVE_OUT:\n\t\t \n\t\tswitch (cdb[1] & 0x1f) {\n\t\tcase PRO_CLEAR:\n\t\tcase PRO_PREEMPT:\n\t\tcase PRO_PREEMPT_AND_ABORT:\n\t\t\tret = (registered_nexus) ? 0 : 1;\n\t\t\tbreak;\n\t\tcase PRO_REGISTER:\n\t\tcase PRO_REGISTER_AND_IGNORE_EXISTING_KEY:\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase PRO_REGISTER_AND_MOVE:\n\t\tcase PRO_RESERVE:\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase PRO_RELEASE:\n\t\t\tret = (registered_nexus) ? 0 : 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unknown PERSISTENT_RESERVE_OUT service\"\n\t\t\t\t\" action: 0x%02x\\n\", cdb[1] & 0x1f);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase RELEASE:\n\tcase RELEASE_10:\n\t\t \n\t\tret = 0;\n\t\tbreak;\n\tcase RESERVE:\n\tcase RESERVE_10:\n\t\t \n\t\tret = 0;\n\t\tbreak;\n\tcase TEST_UNIT_READY:\n\t\tret = (legacy) ? 1 : 0;  \n\t\tbreak;\n\tcase MAINTENANCE_IN:\n\t\tswitch (cdb[1] & 0x1f) {\n\t\tcase MI_MANAGEMENT_PROTOCOL_IN:\n\t\t\tif (registered_nexus) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = (we) ? 0 : 1;  \n\t\t\tbreak;\n\t\tcase MI_REPORT_SUPPORTED_OPERATION_CODES:\n\t\tcase MI_REPORT_SUPPORTED_TASK_MANAGEMENT_FUNCTIONS:\n\t\t\tif (legacy) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (registered_nexus) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = (we) ? 0 : 1;  \n\t\t\tbreak;\n\t\tcase MI_REPORT_ALIASES:\n\t\tcase MI_REPORT_IDENTIFYING_INFORMATION:\n\t\tcase MI_REPORT_PRIORITY:\n\t\tcase MI_REPORT_TARGET_PGS:\n\t\tcase MI_REPORT_TIMESTAMP:\n\t\t\tret = 0;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unknown MI Service Action: 0x%02x\\n\",\n\t\t\t\t(cdb[1] & 0x1f));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase ACCESS_CONTROL_IN:\n\tcase ACCESS_CONTROL_OUT:\n\tcase INQUIRY:\n\tcase LOG_SENSE:\n\tcase SERVICE_ACTION_IN_12:\n\tcase REPORT_LUNS:\n\tcase REQUEST_SENSE:\n\tcase PERSISTENT_RESERVE_IN:\n\t\tret = 0;  \n\t\tbreak;\n\tdefault:\n\t\tother_cdb = 1;\n\t\tbreak;\n\t}\n\t \n\tif (!ret && !other_cdb) {\n\t\tpr_debug(\"Allowing explicit CDB: 0x%02x for %s\"\n\t\t\t\" reservation holder\\n\", cdb[0],\n\t\t\tcore_scsi3_pr_dump_type(pr_reg_type));\n\n\t\treturn ret;\n\t}\n\t \n\tif (we && !registered_nexus) {\n\t\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\t \n\t\t\tpr_debug(\"%s Conflict for unregistered nexus\"\n\t\t\t\t\" %s CDB: 0x%02x to %s reservation\\n\",\n\t\t\t\ttransport_dump_cmd_direction(cmd),\n\t\t\t\tse_sess->se_node_acl->initiatorname, cdb[0],\n\t\t\t\tcore_scsi3_pr_dump_type(pr_reg_type));\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t \n\n\t\t\tif (!registered_nexus) {\n\t\t\t\tpr_debug(\"Allowing implicit CDB: 0x%02x\"\n\t\t\t\t\t\" for %s reservation on unregistered\"\n\t\t\t\t\t\" nexus\\n\", cdb[0],\n\t\t\t\t\tcore_scsi3_pr_dump_type(pr_reg_type));\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t} else if ((reg_only) || (all_reg)) {\n\t\tif (registered_nexus) {\n\t\t\t \n\n\t\t\tpr_debug(\"Allowing implicit CDB: 0x%02x for %s\"\n\t\t\t\t\" reservation\\n\", cdb[0],\n\t\t\t\tcore_scsi3_pr_dump_type(pr_reg_type));\n\n\t\t\treturn 0;\n\t\t}\n       } else if (we && registered_nexus) {\n                \n               if (cmd->data_direction == DMA_FROM_DEVICE) {\n                       pr_debug(\"Allowing READ CDB: 0x%02x for %s\"\n                               \" reservation\\n\", cdb[0],\n                               core_scsi3_pr_dump_type(pr_reg_type));\n\n                       return 0;\n               }\n\t}\n\tpr_debug(\"%s Conflict for %sregistered nexus %s CDB: 0x%2x\"\n\t\t\" for %s reservation\\n\", transport_dump_cmd_direction(cmd),\n\t\t(registered_nexus) ? \"\" : \"un\",\n\t\tse_sess->se_node_acl->initiatorname, cdb[0],\n\t\tcore_scsi3_pr_dump_type(pr_reg_type));\n\n\treturn 1;  \n}\n\nstatic sense_reason_t\ntarget_scsi3_pr_reservation_check(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_session *sess = cmd->se_sess;\n\tu32 pr_reg_type;\n\tbool isid_mismatch = false;\n\n\tif (!dev->dev_pr_res_holder)\n\t\treturn 0;\n\n\tpr_reg_type = dev->dev_pr_res_holder->pr_res_type;\n\tcmd->pr_res_key = dev->dev_pr_res_holder->pr_res_key;\n\tif (dev->dev_pr_res_holder->pr_reg_nacl != sess->se_node_acl)\n\t\tgoto check_nonholder;\n\n\tif (dev->dev_pr_res_holder->isid_present_at_reg) {\n\t\tif (dev->dev_pr_res_holder->pr_reg_bin_isid !=\n\t\t    sess->sess_bin_isid) {\n\t\t\tisid_mismatch = true;\n\t\t\tgoto check_nonholder;\n\t\t}\n\t}\n\n\treturn 0;\n\ncheck_nonholder:\n\tif (core_scsi3_pr_seq_non_holder(cmd, pr_reg_type, isid_mismatch))\n\t\treturn TCM_RESERVATION_CONFLICT;\n\treturn 0;\n}\n\nstatic u32 core_scsi3_pr_generation(struct se_device *dev)\n{\n\tu32 prg;\n\n\t \n\tspin_lock(&dev->dev_reservation_lock);\n\tprg = dev->t10_pr.pr_generation++;\n\tspin_unlock(&dev->dev_reservation_lock);\n\n\treturn prg;\n}\n\nstatic struct t10_pr_registration *__core_scsi3_do_alloc_registration(\n\tstruct se_device *dev,\n\tstruct se_node_acl *nacl,\n\tstruct se_lun *lun,\n\tstruct se_dev_entry *dest_deve,\n\tu64 mapped_lun,\n\tunsigned char *isid,\n\tu64 sa_res_key,\n\tint all_tg_pt,\n\tint aptpl)\n{\n\tstruct t10_pr_registration *pr_reg;\n\n\tpr_reg = kmem_cache_zalloc(t10_pr_reg_cache, GFP_ATOMIC);\n\tif (!pr_reg) {\n\t\tpr_err(\"Unable to allocate struct t10_pr_registration\\n\");\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&pr_reg->pr_reg_list);\n\tINIT_LIST_HEAD(&pr_reg->pr_reg_abort_list);\n\tINIT_LIST_HEAD(&pr_reg->pr_reg_aptpl_list);\n\tINIT_LIST_HEAD(&pr_reg->pr_reg_atp_list);\n\tINIT_LIST_HEAD(&pr_reg->pr_reg_atp_mem_list);\n\tatomic_set(&pr_reg->pr_res_holders, 0);\n\tpr_reg->pr_reg_nacl = nacl;\n\t \n\tif (dest_deve) {\n\t\tpr_reg->pr_reg_deve = dest_deve;\n\t} else {\n\t\trcu_read_lock();\n\t\tpr_reg->pr_reg_deve = target_nacl_find_deve(nacl, mapped_lun);\n\t\tif (!pr_reg->pr_reg_deve) {\n\t\t\trcu_read_unlock();\n\t\t\tpr_err(\"Unable to locate PR deve %s mapped_lun: %llu\\n\",\n\t\t\t\tnacl->initiatorname, mapped_lun);\n\t\t\tkmem_cache_free(t10_pr_reg_cache, pr_reg);\n\t\t\treturn NULL;\n\t\t}\n\t\tkref_get(&pr_reg->pr_reg_deve->pr_kref);\n\t\trcu_read_unlock();\n\t}\n\tpr_reg->pr_res_mapped_lun = mapped_lun;\n\tpr_reg->pr_aptpl_target_lun = lun->unpacked_lun;\n\tpr_reg->tg_pt_sep_rtpi = lun->lun_tpg->tpg_rtpi;\n\tpr_reg->pr_res_key = sa_res_key;\n\tpr_reg->pr_reg_all_tg_pt = all_tg_pt;\n\tpr_reg->pr_reg_aptpl = aptpl;\n\t \n\tif (isid != NULL) {\n\t\tpr_reg->pr_reg_bin_isid = get_unaligned_be64(isid);\n\t\tsnprintf(pr_reg->pr_reg_isid, PR_REG_ISID_LEN, \"%s\", isid);\n\t\tpr_reg->isid_present_at_reg = 1;\n\t}\n\n\treturn pr_reg;\n}\n\nstatic int core_scsi3_lunacl_depend_item(struct se_dev_entry *);\nstatic void core_scsi3_lunacl_undepend_item(struct se_dev_entry *);\n\n \nstatic struct t10_pr_registration *__core_scsi3_alloc_registration(\n\tstruct se_device *dev,\n\tstruct se_node_acl *nacl,\n\tstruct se_lun *lun,\n\tstruct se_dev_entry *deve,\n\tu64 mapped_lun,\n\tunsigned char *isid,\n\tu64 sa_res_key,\n\tint all_tg_pt,\n\tint aptpl)\n{\n\tstruct se_dev_entry *deve_tmp;\n\tstruct se_node_acl *nacl_tmp;\n\tstruct se_lun_acl *lacl_tmp;\n\tstruct se_lun *lun_tmp, *next, *dest_lun;\n\tconst struct target_core_fabric_ops *tfo = nacl->se_tpg->se_tpg_tfo;\n\tstruct t10_pr_registration *pr_reg, *pr_reg_atp, *pr_reg_tmp, *pr_reg_tmp_safe;\n\tint ret;\n\t \n\tpr_reg = __core_scsi3_do_alloc_registration(dev, nacl, lun, deve, mapped_lun,\n\t\t\t\t\t\t    isid, sa_res_key, all_tg_pt,\n\t\t\t\t\t\t    aptpl);\n\tif (!pr_reg)\n\t\treturn NULL;\n\t \n\tif (!all_tg_pt)\n\t\treturn pr_reg;\n\t \n\tspin_lock(&dev->se_port_lock);\n\tlist_for_each_entry_safe(lun_tmp, next, &dev->dev_sep_list, lun_dev_link) {\n\t\tif (!percpu_ref_tryget_live(&lun_tmp->lun_ref))\n\t\t\tcontinue;\n\t\tspin_unlock(&dev->se_port_lock);\n\n\t\tspin_lock(&lun_tmp->lun_deve_lock);\n\t\tlist_for_each_entry(deve_tmp, &lun_tmp->lun_deve_list, lun_link) {\n\t\t\t \n\t\t\tif (!deve_tmp->se_lun_acl)\n\t\t\t\tcontinue;\n\n\t\t\tlacl_tmp = deve_tmp->se_lun_acl;\n\t\t\tnacl_tmp = lacl_tmp->se_lun_nacl;\n\t\t\t \n\t\t\tif (nacl == nacl_tmp)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (tfo != nacl_tmp->se_tpg->se_tpg_tfo)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (strcmp(nacl->initiatorname, nacl_tmp->initiatorname))\n\t\t\t\tcontinue;\n\n\t\t\tkref_get(&deve_tmp->pr_kref);\n\t\t\tspin_unlock(&lun_tmp->lun_deve_lock);\n\t\t\t \n\t\t\tret = core_scsi3_lunacl_depend_item(deve_tmp);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"core_scsi3_lunacl_depend\"\n\t\t\t\t\t\t\"_item() failed\\n\");\n\t\t\t\tpercpu_ref_put(&lun_tmp->lun_ref);\n\t\t\t\tkref_put(&deve_tmp->pr_kref, target_pr_kref_release);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tdest_lun = deve_tmp->se_lun;\n\n\t\t\tpr_reg_atp = __core_scsi3_do_alloc_registration(dev,\n\t\t\t\t\t\tnacl_tmp, dest_lun, deve_tmp,\n\t\t\t\t\t\tdeve_tmp->mapped_lun, NULL,\n\t\t\t\t\t\tsa_res_key, all_tg_pt, aptpl);\n\t\t\tif (!pr_reg_atp) {\n\t\t\t\tpercpu_ref_put(&lun_tmp->lun_ref);\n\t\t\t\tcore_scsi3_lunacl_undepend_item(deve_tmp);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlist_add_tail(&pr_reg_atp->pr_reg_atp_mem_list,\n\t\t\t\t      &pr_reg->pr_reg_atp_list);\n\t\t\tspin_lock(&lun_tmp->lun_deve_lock);\n\t\t}\n\t\tspin_unlock(&lun_tmp->lun_deve_lock);\n\n\t\tspin_lock(&dev->se_port_lock);\n\t\tpercpu_ref_put(&lun_tmp->lun_ref);\n\t}\n\tspin_unlock(&dev->se_port_lock);\n\n\treturn pr_reg;\nout:\n\tlist_for_each_entry_safe(pr_reg_tmp, pr_reg_tmp_safe,\n\t\t\t&pr_reg->pr_reg_atp_list, pr_reg_atp_mem_list) {\n\t\tlist_del(&pr_reg_tmp->pr_reg_atp_mem_list);\n\t\tcore_scsi3_lunacl_undepend_item(pr_reg_tmp->pr_reg_deve);\n\t\tkmem_cache_free(t10_pr_reg_cache, pr_reg_tmp);\n\t}\n\tkmem_cache_free(t10_pr_reg_cache, pr_reg);\n\treturn NULL;\n}\n\nint core_scsi3_alloc_aptpl_registration(\n\tstruct t10_reservation *pr_tmpl,\n\tu64 sa_res_key,\n\tunsigned char *i_port,\n\tunsigned char *isid,\n\tu64 mapped_lun,\n\tunsigned char *t_port,\n\tu16 tpgt,\n\tu64 target_lun,\n\tint res_holder,\n\tint all_tg_pt,\n\tu8 type)\n{\n\tstruct t10_pr_registration *pr_reg;\n\n\tif (!i_port || !t_port || !sa_res_key) {\n\t\tpr_err(\"Illegal parameters for APTPL registration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_reg = kmem_cache_zalloc(t10_pr_reg_cache, GFP_KERNEL);\n\tif (!pr_reg) {\n\t\tpr_err(\"Unable to allocate struct t10_pr_registration\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&pr_reg->pr_reg_list);\n\tINIT_LIST_HEAD(&pr_reg->pr_reg_abort_list);\n\tINIT_LIST_HEAD(&pr_reg->pr_reg_aptpl_list);\n\tINIT_LIST_HEAD(&pr_reg->pr_reg_atp_list);\n\tINIT_LIST_HEAD(&pr_reg->pr_reg_atp_mem_list);\n\tatomic_set(&pr_reg->pr_res_holders, 0);\n\tpr_reg->pr_reg_nacl = NULL;\n\tpr_reg->pr_reg_deve = NULL;\n\tpr_reg->pr_res_mapped_lun = mapped_lun;\n\tpr_reg->pr_aptpl_target_lun = target_lun;\n\tpr_reg->pr_res_key = sa_res_key;\n\tpr_reg->pr_reg_all_tg_pt = all_tg_pt;\n\tpr_reg->pr_reg_aptpl = 1;\n\tpr_reg->pr_res_scope = 0;  \n\tpr_reg->pr_res_type = type;\n\t \n\tif (isid != NULL) {\n\t\tpr_reg->pr_reg_bin_isid = get_unaligned_be64(isid);\n\t\tsnprintf(pr_reg->pr_reg_isid, PR_REG_ISID_LEN, \"%s\", isid);\n\t\tpr_reg->isid_present_at_reg = 1;\n\t}\n\t \n\tsnprintf(pr_reg->pr_iport, PR_APTPL_MAX_IPORT_LEN, \"%s\", i_port);\n\tsnprintf(pr_reg->pr_tport, PR_APTPL_MAX_TPORT_LEN, \"%s\", t_port);\n\tpr_reg->pr_reg_tpgt = tpgt;\n\t \n\tpr_reg->pr_res_holder = res_holder;\n\n\tlist_add_tail(&pr_reg->pr_reg_aptpl_list, &pr_tmpl->aptpl_reg_list);\n\tpr_debug(\"SPC-3 PR APTPL Successfully added registration%s from\"\n\t\t\t\" metadata\\n\", (res_holder) ? \"+reservation\" : \"\");\n\treturn 0;\n}\n\nstatic void core_scsi3_aptpl_reserve(\n\tstruct se_device *dev,\n\tstruct se_portal_group *tpg,\n\tstruct se_node_acl *node_acl,\n\tstruct t10_pr_registration *pr_reg)\n{\n\tchar i_buf[PR_REG_ISID_ID_LEN] = { };\n\n\tcore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\n\n\tspin_lock(&dev->dev_reservation_lock);\n\tdev->dev_pr_res_holder = pr_reg;\n\tspin_unlock(&dev->dev_reservation_lock);\n\n\tpr_debug(\"SPC-3 PR [%s] Service Action: APTPL RESERVE created\"\n\t\t\" new reservation holder TYPE: %s ALL_TG_PT: %d\\n\",\n\t\ttpg->se_tpg_tfo->fabric_name,\n\t\tcore_scsi3_pr_dump_type(pr_reg->pr_res_type),\n\t\t(pr_reg->pr_reg_all_tg_pt) ? 1 : 0);\n\tpr_debug(\"SPC-3 PR [%s] RESERVE Node: %s%s\\n\",\n\t\ttpg->se_tpg_tfo->fabric_name, node_acl->initiatorname,\n\t\ti_buf);\n}\n\nstatic void __core_scsi3_add_registration(struct se_device *, struct se_node_acl *,\n\t\t\t\tstruct t10_pr_registration *, enum register_type, int);\n\nstatic int __core_scsi3_check_aptpl_registration(\n\tstruct se_device *dev,\n\tstruct se_portal_group *tpg,\n\tstruct se_lun *lun,\n\tu64 target_lun,\n\tstruct se_node_acl *nacl,\n\tu64 mapped_lun)\n{\n\tstruct t10_pr_registration *pr_reg, *pr_reg_tmp;\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tunsigned char i_port[PR_APTPL_MAX_IPORT_LEN] = { };\n\tunsigned char t_port[PR_APTPL_MAX_TPORT_LEN] = { };\n\tu16 tpgt;\n\n\t \n\tsnprintf(i_port, PR_APTPL_MAX_IPORT_LEN, \"%s\", nacl->initiatorname);\n\tsnprintf(t_port, PR_APTPL_MAX_TPORT_LEN, \"%s\",\n\t\t\ttpg->se_tpg_tfo->tpg_get_wwn(tpg));\n\ttpgt = tpg->se_tpg_tfo->tpg_get_tag(tpg);\n\t \n\tspin_lock(&pr_tmpl->aptpl_reg_lock);\n\tlist_for_each_entry_safe(pr_reg, pr_reg_tmp, &pr_tmpl->aptpl_reg_list,\n\t\t\t\tpr_reg_aptpl_list) {\n\n\t\tif (!strcmp(pr_reg->pr_iport, i_port) &&\n\t\t     (pr_reg->pr_res_mapped_lun == mapped_lun) &&\n\t\t    !(strcmp(pr_reg->pr_tport, t_port)) &&\n\t\t     (pr_reg->pr_reg_tpgt == tpgt) &&\n\t\t     (pr_reg->pr_aptpl_target_lun == target_lun)) {\n\t\t\t \n\t\t\trcu_read_lock();\n\t\t\tpr_reg->pr_reg_deve = target_nacl_find_deve(nacl, mapped_lun);\n\t\t\tif (!pr_reg->pr_reg_deve) {\n\t\t\t\tpr_err(\"Unable to locate PR APTPL %s mapped_lun:\"\n\t\t\t\t\t\" %llu\\n\", nacl->initiatorname, mapped_lun);\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tkref_get(&pr_reg->pr_reg_deve->pr_kref);\n\t\t\trcu_read_unlock();\n\n\t\t\tpr_reg->pr_reg_nacl = nacl;\n\t\t\tpr_reg->tg_pt_sep_rtpi = lun->lun_tpg->tpg_rtpi;\n\t\t\tlist_del(&pr_reg->pr_reg_aptpl_list);\n\t\t\tspin_unlock(&pr_tmpl->aptpl_reg_lock);\n\t\t\t \n\t\t\t__core_scsi3_add_registration(dev, nacl, pr_reg, 0, 0);\n\t\t\t \n\t\t\tif (pr_reg->pr_res_holder)\n\t\t\t\tcore_scsi3_aptpl_reserve(dev, tpg,\n\t\t\t\t\t\tnacl, pr_reg);\n\t\t\t \n\t\t\tspin_lock(&pr_tmpl->aptpl_reg_lock);\n\t\t\tpr_tmpl->pr_aptpl_active = 1;\n\t\t}\n\t}\n\tspin_unlock(&pr_tmpl->aptpl_reg_lock);\n\n\treturn 0;\n}\n\nint core_scsi3_check_aptpl_registration(\n\tstruct se_device *dev,\n\tstruct se_portal_group *tpg,\n\tstruct se_lun *lun,\n\tstruct se_node_acl *nacl,\n\tu64 mapped_lun)\n{\n\tif (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS)\n\t\treturn 0;\n\n\treturn __core_scsi3_check_aptpl_registration(dev, tpg, lun,\n\t\t\t\t\t\t     lun->unpacked_lun, nacl,\n\t\t\t\t\t\t     mapped_lun);\n}\n\nstatic void __core_scsi3_dump_registration(\n\tconst struct target_core_fabric_ops *tfo,\n\tstruct se_device *dev,\n\tstruct se_node_acl *nacl,\n\tstruct t10_pr_registration *pr_reg,\n\tenum register_type register_type)\n{\n\tstruct se_portal_group *se_tpg = nacl->se_tpg;\n\tchar i_buf[PR_REG_ISID_ID_LEN] = { };\n\n\tcore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\n\n\tpr_debug(\"SPC-3 PR [%s] Service Action: REGISTER%s Initiator\"\n\t\t\" Node: %s%s\\n\", tfo->fabric_name, (register_type == REGISTER_AND_MOVE) ?\n\t\t\"_AND_MOVE\" : (register_type == REGISTER_AND_IGNORE_EXISTING_KEY) ?\n\t\t\"_AND_IGNORE_EXISTING_KEY\" : \"\", nacl->initiatorname,\n\t\ti_buf);\n\tpr_debug(\"SPC-3 PR [%s] registration on Target Port: %s,0x%04x\\n\",\n\t\t tfo->fabric_name, tfo->tpg_get_wwn(se_tpg),\n\t\ttfo->tpg_get_tag(se_tpg));\n\tpr_debug(\"SPC-3 PR [%s] for %s TCM Subsystem %s Object Target\"\n\t\t\" Port(s)\\n\",  tfo->fabric_name,\n\t\t(pr_reg->pr_reg_all_tg_pt) ? \"ALL\" : \"SINGLE\",\n\t\tdev->transport->name);\n\tpr_debug(\"SPC-3 PR [%s] SA Res Key: 0x%016Lx PRgeneration:\"\n\t\t\" 0x%08x  APTPL: %d\\n\", tfo->fabric_name,\n\t\tpr_reg->pr_res_key, pr_reg->pr_res_generation,\n\t\tpr_reg->pr_reg_aptpl);\n}\n\nstatic void __core_scsi3_add_registration(\n\tstruct se_device *dev,\n\tstruct se_node_acl *nacl,\n\tstruct t10_pr_registration *pr_reg,\n\tenum register_type register_type,\n\tint register_move)\n{\n\tconst struct target_core_fabric_ops *tfo = nacl->se_tpg->se_tpg_tfo;\n\tstruct t10_pr_registration *pr_reg_tmp, *pr_reg_tmp_safe;\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tstruct se_dev_entry *deve;\n\n\t \n\tpr_reg->pr_res_generation = (register_move) ?\n\t\t\tdev->t10_pr.pr_generation++ :\n\t\t\tcore_scsi3_pr_generation(dev);\n\n\tspin_lock(&pr_tmpl->registration_lock);\n\tlist_add_tail(&pr_reg->pr_reg_list, &pr_tmpl->registration_list);\n\n\t__core_scsi3_dump_registration(tfo, dev, nacl, pr_reg, register_type);\n\tspin_unlock(&pr_tmpl->registration_lock);\n\t \n\tif (!pr_reg->pr_reg_all_tg_pt || register_move)\n\t\tgoto out;\n\t \n\tlist_for_each_entry_safe(pr_reg_tmp, pr_reg_tmp_safe,\n\t\t\t&pr_reg->pr_reg_atp_list, pr_reg_atp_mem_list) {\n\t\tstruct se_node_acl *nacl_tmp = pr_reg_tmp->pr_reg_nacl;\n\n\t\tlist_del(&pr_reg_tmp->pr_reg_atp_mem_list);\n\n\t\tpr_reg_tmp->pr_res_generation = core_scsi3_pr_generation(dev);\n\n\t\tspin_lock(&pr_tmpl->registration_lock);\n\t\tlist_add_tail(&pr_reg_tmp->pr_reg_list,\n\t\t\t      &pr_tmpl->registration_list);\n\n\t\t__core_scsi3_dump_registration(tfo, dev, nacl_tmp, pr_reg_tmp,\n\t\t\t\t\t       register_type);\n\t\tspin_unlock(&pr_tmpl->registration_lock);\n\t\t \n\t\trcu_read_lock();\n\t\tdeve = pr_reg_tmp->pr_reg_deve;\n\t\tif (deve) {\n\t\t\tset_bit(DEF_PR_REG_ACTIVE, &deve->deve_flags);\n\t\t\tcore_scsi3_lunacl_undepend_item(deve);\n\t\t\tpr_reg_tmp->pr_reg_deve = NULL;\n\t\t}\n\t\trcu_read_unlock();\n\t}\nout:\n\t \n\trcu_read_lock();\n\tdeve = pr_reg->pr_reg_deve;\n\tif (deve) {\n\t\tset_bit(DEF_PR_REG_ACTIVE, &deve->deve_flags);\n\t\tkref_put(&deve->pr_kref, target_pr_kref_release);\n\t\tpr_reg->pr_reg_deve = NULL;\n\t}\n\trcu_read_unlock();\n}\n\nstatic int core_scsi3_alloc_registration(\n\tstruct se_device *dev,\n\tstruct se_node_acl *nacl,\n\tstruct se_lun *lun,\n\tstruct se_dev_entry *deve,\n\tu64 mapped_lun,\n\tunsigned char *isid,\n\tu64 sa_res_key,\n\tint all_tg_pt,\n\tint aptpl,\n\tenum register_type register_type,\n\tint register_move)\n{\n\tstruct t10_pr_registration *pr_reg;\n\n\tpr_reg = __core_scsi3_alloc_registration(dev, nacl, lun, deve, mapped_lun,\n\t\t\t\t\t\t isid, sa_res_key, all_tg_pt,\n\t\t\t\t\t\t aptpl);\n\tif (!pr_reg)\n\t\treturn -EPERM;\n\n\t__core_scsi3_add_registration(dev, nacl, pr_reg,\n\t\t\tregister_type, register_move);\n\treturn 0;\n}\n\nstatic struct t10_pr_registration *__core_scsi3_locate_pr_reg(\n\tstruct se_device *dev,\n\tstruct se_node_acl *nacl,\n\tunsigned char *isid)\n{\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tstruct t10_pr_registration *pr_reg, *pr_reg_tmp;\n\n\tspin_lock(&pr_tmpl->registration_lock);\n\tlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\n\t\t\t&pr_tmpl->registration_list, pr_reg_list) {\n\t\t \n\t\tif (pr_reg->pr_reg_nacl != nacl)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!pr_reg->isid_present_at_reg) {\n\t\t\tatomic_inc_mb(&pr_reg->pr_res_holders);\n\t\t\tspin_unlock(&pr_tmpl->registration_lock);\n\t\t\treturn pr_reg;\n\t\t}\n\t\t \n\t\tif (!isid)\n\t\t\tcontinue;\n\t\tif (strcmp(isid, pr_reg->pr_reg_isid))\n\t\t\tcontinue;\n\n\t\tatomic_inc_mb(&pr_reg->pr_res_holders);\n\t\tspin_unlock(&pr_tmpl->registration_lock);\n\t\treturn pr_reg;\n\t}\n\tspin_unlock(&pr_tmpl->registration_lock);\n\n\treturn NULL;\n}\n\nstatic struct t10_pr_registration *core_scsi3_locate_pr_reg(\n\tstruct se_device *dev,\n\tstruct se_node_acl *nacl,\n\tstruct se_session *sess)\n{\n\tstruct se_portal_group *tpg = nacl->se_tpg;\n\tunsigned char buf[PR_REG_ISID_LEN] = { };\n\tunsigned char *isid_ptr = NULL;\n\n\tif (tpg->se_tpg_tfo->sess_get_initiator_sid != NULL) {\n\t\ttpg->se_tpg_tfo->sess_get_initiator_sid(sess, &buf[0],\n\t\t\t\t\tPR_REG_ISID_LEN);\n\t\tisid_ptr = &buf[0];\n\t}\n\n\treturn __core_scsi3_locate_pr_reg(dev, nacl, isid_ptr);\n}\n\nstatic void core_scsi3_put_pr_reg(struct t10_pr_registration *pr_reg)\n{\n\tatomic_dec_mb(&pr_reg->pr_res_holders);\n}\n\nstatic int core_scsi3_check_implicit_release(\n\tstruct se_device *dev,\n\tstruct t10_pr_registration *pr_reg)\n{\n\tstruct se_node_acl *nacl = pr_reg->pr_reg_nacl;\n\tstruct t10_pr_registration *pr_res_holder;\n\tint ret = 0;\n\n\tspin_lock(&dev->dev_reservation_lock);\n\tpr_res_holder = dev->dev_pr_res_holder;\n\tif (!pr_res_holder) {\n\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\treturn ret;\n\t}\n\tif (pr_res_holder == pr_reg) {\n\t\t \n\t\t__core_scsi3_complete_pro_release(dev, nacl, pr_reg, 0, 1);\n\t\tret = 1;\n\t\t \n\t} else if (pr_reg->pr_reg_all_tg_pt &&\n\t\t  (!strcmp(pr_res_holder->pr_reg_nacl->initiatorname,\n\t\t\t  pr_reg->pr_reg_nacl->initiatorname)) &&\n\t\t  (pr_res_holder->pr_res_key == pr_reg->pr_res_key)) {\n\t\tpr_err(\"SPC-3 PR: Unable to perform ALL_TG_PT=1\"\n\t\t\t\" UNREGISTER while existing reservation with matching\"\n\t\t\t\" key 0x%016Lx is present from another SCSI Initiator\"\n\t\t\t\" Port\\n\", pr_reg->pr_res_key);\n\t\tret = -EPERM;\n\t}\n\tspin_unlock(&dev->dev_reservation_lock);\n\n\treturn ret;\n}\n\nstatic void __core_scsi3_free_registration(\n\tstruct se_device *dev,\n\tstruct t10_pr_registration *pr_reg,\n\tstruct list_head *preempt_and_abort_list,\n\tint dec_holders)\n\t__releases(&pr_tmpl->registration_lock)\n\t__acquires(&pr_tmpl->registration_lock)\n{\n\tconst struct target_core_fabric_ops *tfo =\n\t\t\tpr_reg->pr_reg_nacl->se_tpg->se_tpg_tfo;\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tstruct se_node_acl *nacl = pr_reg->pr_reg_nacl;\n\tstruct se_dev_entry *deve;\n\tchar i_buf[PR_REG_ISID_ID_LEN] = { };\n\n\tlockdep_assert_held(&pr_tmpl->registration_lock);\n\n\tcore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\n\n\tif (!list_empty(&pr_reg->pr_reg_list))\n\t\tlist_del(&pr_reg->pr_reg_list);\n\t \n\tif (dec_holders)\n\t\tcore_scsi3_put_pr_reg(pr_reg);\n\n\tspin_unlock(&pr_tmpl->registration_lock);\n\t \n\twhile (atomic_read(&pr_reg->pr_res_holders) != 0) {\n\t\tpr_debug(\"SPC-3 PR [%s] waiting for pr_res_holders\\n\",\n\t\t\t\ttfo->fabric_name);\n\t\tcpu_relax();\n\t}\n\n\trcu_read_lock();\n\tdeve = target_nacl_find_deve(nacl, pr_reg->pr_res_mapped_lun);\n\tif (deve)\n\t\tclear_bit(DEF_PR_REG_ACTIVE, &deve->deve_flags);\n\trcu_read_unlock();\n\n\tspin_lock(&pr_tmpl->registration_lock);\n\tpr_debug(\"SPC-3 PR [%s] Service Action: UNREGISTER Initiator\"\n\t\t\" Node: %s%s\\n\", tfo->fabric_name,\n\t\tpr_reg->pr_reg_nacl->initiatorname,\n\t\ti_buf);\n\tpr_debug(\"SPC-3 PR [%s] for %s TCM Subsystem %s Object Target\"\n\t\t\" Port(s)\\n\", tfo->fabric_name,\n\t\t(pr_reg->pr_reg_all_tg_pt) ? \"ALL\" : \"SINGLE\",\n\t\tdev->transport->name);\n\tpr_debug(\"SPC-3 PR [%s] SA Res Key: 0x%016Lx PRgeneration:\"\n\t\t\" 0x%08x\\n\", tfo->fabric_name, pr_reg->pr_res_key,\n\t\tpr_reg->pr_res_generation);\n\n\tif (!preempt_and_abort_list) {\n\t\tpr_reg->pr_reg_deve = NULL;\n\t\tpr_reg->pr_reg_nacl = NULL;\n\t\tkmem_cache_free(t10_pr_reg_cache, pr_reg);\n\t\treturn;\n\t}\n\t \n\tlist_add_tail(&pr_reg->pr_reg_abort_list, preempt_and_abort_list);\n}\n\nvoid core_scsi3_free_pr_reg_from_nacl(\n\tstruct se_device *dev,\n\tstruct se_node_acl *nacl)\n{\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tstruct t10_pr_registration *pr_reg, *pr_reg_tmp, *pr_res_holder;\n\tbool free_reg = false;\n\t \n\tspin_lock(&dev->dev_reservation_lock);\n\tpr_res_holder = dev->dev_pr_res_holder;\n\tif ((pr_res_holder != NULL) &&\n\t    (pr_res_holder->pr_reg_nacl == nacl)) {\n\t\t__core_scsi3_complete_pro_release(dev, nacl, pr_res_holder, 0, 1);\n\t\tfree_reg = true;\n\t}\n\tspin_unlock(&dev->dev_reservation_lock);\n\t \n\tspin_lock(&pr_tmpl->registration_lock);\n\tif (pr_res_holder && free_reg)\n\t\t__core_scsi3_free_registration(dev, pr_res_holder, NULL, 0);\n\n\tlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\n\t\t\t&pr_tmpl->registration_list, pr_reg_list) {\n\n\t\tif (pr_reg->pr_reg_nacl != nacl)\n\t\t\tcontinue;\n\n\t\t__core_scsi3_free_registration(dev, pr_reg, NULL, 0);\n\t}\n\tspin_unlock(&pr_tmpl->registration_lock);\n}\n\nvoid core_scsi3_free_all_registrations(\n\tstruct se_device *dev)\n{\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tstruct t10_pr_registration *pr_reg, *pr_reg_tmp, *pr_res_holder;\n\n\tspin_lock(&dev->dev_reservation_lock);\n\tpr_res_holder = dev->dev_pr_res_holder;\n\tif (pr_res_holder != NULL) {\n\t\tstruct se_node_acl *pr_res_nacl = pr_res_holder->pr_reg_nacl;\n\t\t__core_scsi3_complete_pro_release(dev, pr_res_nacl,\n\t\t\t\t\t\t  pr_res_holder, 0, 0);\n\t}\n\tspin_unlock(&dev->dev_reservation_lock);\n\n\tspin_lock(&pr_tmpl->registration_lock);\n\tlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\n\t\t\t&pr_tmpl->registration_list, pr_reg_list) {\n\n\t\t__core_scsi3_free_registration(dev, pr_reg, NULL, 0);\n\t}\n\tspin_unlock(&pr_tmpl->registration_lock);\n\n\tspin_lock(&pr_tmpl->aptpl_reg_lock);\n\tlist_for_each_entry_safe(pr_reg, pr_reg_tmp, &pr_tmpl->aptpl_reg_list,\n\t\t\t\tpr_reg_aptpl_list) {\n\t\tlist_del(&pr_reg->pr_reg_aptpl_list);\n\t\tkmem_cache_free(t10_pr_reg_cache, pr_reg);\n\t}\n\tspin_unlock(&pr_tmpl->aptpl_reg_lock);\n}\n\nstatic int core_scsi3_tpg_depend_item(struct se_portal_group *tpg)\n{\n\treturn target_depend_item(&tpg->tpg_group.cg_item);\n}\n\nstatic void core_scsi3_tpg_undepend_item(struct se_portal_group *tpg)\n{\n\ttarget_undepend_item(&tpg->tpg_group.cg_item);\n\tatomic_dec_mb(&tpg->tpg_pr_ref_count);\n}\n\nstatic int core_scsi3_nodeacl_depend_item(struct se_node_acl *nacl)\n{\n\tif (nacl->dynamic_node_acl)\n\t\treturn 0;\n\treturn target_depend_item(&nacl->acl_group.cg_item);\n}\n\nstatic void core_scsi3_nodeacl_undepend_item(struct se_node_acl *nacl)\n{\n\tif (!nacl->dynamic_node_acl)\n\t\ttarget_undepend_item(&nacl->acl_group.cg_item);\n\tatomic_dec_mb(&nacl->acl_pr_ref_count);\n}\n\nstatic int core_scsi3_lunacl_depend_item(struct se_dev_entry *se_deve)\n{\n\t \n\tif (!se_deve->se_lun_acl)\n\t\treturn 0;\n\n\treturn target_depend_item(&se_deve->se_lun_acl->se_lun_group.cg_item);\n}\n\nstatic void core_scsi3_lunacl_undepend_item(struct se_dev_entry *se_deve)\n{\n\t \n\tif (!se_deve->se_lun_acl) {\n\t\tkref_put(&se_deve->pr_kref, target_pr_kref_release);\n\t\treturn;\n\t}\n\n\ttarget_undepend_item(&se_deve->se_lun_acl->se_lun_group.cg_item);\n\tkref_put(&se_deve->pr_kref, target_pr_kref_release);\n}\n\nstatic sense_reason_t\ncore_scsi3_decode_spec_i_port(\n\tstruct se_cmd *cmd,\n\tstruct se_portal_group *tpg,\n\tunsigned char *l_isid,\n\tu64 sa_res_key,\n\tint all_tg_pt,\n\tint aptpl)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_portal_group *dest_tpg = NULL, *tmp_tpg;\n\tstruct se_session *se_sess = cmd->se_sess;\n\tstruct se_node_acl *dest_node_acl = NULL;\n\tstruct se_dev_entry *dest_se_deve = NULL;\n\tstruct t10_pr_registration *dest_pr_reg, *local_pr_reg, *pr_reg_e;\n\tstruct t10_pr_registration *pr_reg_tmp, *pr_reg_tmp_safe;\n\tLIST_HEAD(tid_dest_list);\n\tstruct pr_transport_id_holder *tidh_new, *tidh, *tidh_tmp;\n\tunsigned char *buf, *ptr, proto_ident;\n\tconst unsigned char *i_str = NULL;\n\tchar *iport_ptr = NULL, i_buf[PR_REG_ISID_ID_LEN];\n\tsense_reason_t ret;\n\tu32 tpdl, tid_len = 0;\n\tu32 dest_rtpi = 0;\n\n\t \n\ttidh_new = kzalloc(sizeof(struct pr_transport_id_holder), GFP_KERNEL);\n\tif (!tidh_new) {\n\t\tpr_err(\"Unable to allocate tidh_new\\n\");\n\t\treturn TCM_INSUFFICIENT_REGISTRATION_RESOURCES;\n\t}\n\tINIT_LIST_HEAD(&tidh_new->dest_list);\n\ttidh_new->dest_tpg = tpg;\n\ttidh_new->dest_node_acl = se_sess->se_node_acl;\n\n\tlocal_pr_reg = __core_scsi3_alloc_registration(cmd->se_dev,\n\t\t\t\tse_sess->se_node_acl, cmd->se_lun,\n\t\t\t\tNULL, cmd->orig_fe_lun, l_isid,\n\t\t\t\tsa_res_key, all_tg_pt, aptpl);\n\tif (!local_pr_reg) {\n\t\tkfree(tidh_new);\n\t\treturn TCM_INSUFFICIENT_REGISTRATION_RESOURCES;\n\t}\n\n\tif (core_scsi3_lunacl_depend_item(local_pr_reg->pr_reg_deve)) {\n\t\tkfree(tidh_new);\n\t\tkref_put(&local_pr_reg->pr_reg_deve->pr_kref,\n\t\t\t target_pr_kref_release);\n\t\tkmem_cache_free(t10_pr_reg_cache, local_pr_reg);\n\t\treturn TCM_INSUFFICIENT_REGISTRATION_RESOURCES;\n\t}\n\n\ttidh_new->dest_pr_reg = local_pr_reg;\n\tlist_add_tail(&tidh_new->dest_list, &tid_dest_list);\n\n\tif (cmd->data_length < 28) {\n\t\tpr_warn(\"SPC-PR: Received PR OUT parameter list\"\n\t\t\t\" length too small: %u\\n\", cmd->data_length);\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out;\n\t}\n\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf) {\n\t\tret = TCM_INSUFFICIENT_REGISTRATION_RESOURCES;\n\t\tgoto out;\n\t}\n\n\t \n\ttpdl = get_unaligned_be32(&buf[24]);\n\n\tif ((tpdl + 28) != cmd->data_length) {\n\t\tpr_err(\"SPC-3 PR: Illegal tpdl: %u + 28 byte header\"\n\t\t\t\" does not equal CDB data_length: %u\\n\", tpdl,\n\t\t\tcmd->data_length);\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out_unmap;\n\t}\n\t \n\tptr = &buf[28];\n\n\twhile (tpdl > 0) {\n\t\tstruct se_lun *dest_lun, *tmp_lun;\n\n\t\tproto_ident = (ptr[0] & 0x0f);\n\t\tdest_tpg = NULL;\n\n\t\tspin_lock(&dev->se_port_lock);\n\t\tlist_for_each_entry(tmp_lun, &dev->dev_sep_list, lun_dev_link) {\n\t\t\ttmp_tpg = tmp_lun->lun_tpg;\n\n\t\t\t \n\t\t\tif (tmp_tpg->proto_id != proto_ident)\n\t\t\t\tcontinue;\n\t\t\tdest_rtpi = tmp_lun->lun_tpg->tpg_rtpi;\n\n\t\t\tiport_ptr = NULL;\n\t\t\ti_str = target_parse_pr_out_transport_id(tmp_tpg,\n\t\t\t\t\tptr, &tid_len, &iport_ptr);\n\t\t\tif (!i_str)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (tpg->se_tpg_tfo->sess_get_initiator_sid &&\n\t\t\t    dev->dev_attrib.enforce_pr_isids &&\n\t\t\t    !iport_ptr) {\n\t\t\t\tpr_warn(\"SPC-PR: enforce_pr_isids is set but a isid has not been sent in the SPEC_I_PT data for %s.\",\n\t\t\t\t\ti_str);\n\t\t\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\t\t\tspin_unlock(&dev->se_port_lock);\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\n\t\t\tatomic_inc_mb(&tmp_tpg->tpg_pr_ref_count);\n\t\t\tspin_unlock(&dev->se_port_lock);\n\n\t\t\tif (core_scsi3_tpg_depend_item(tmp_tpg)) {\n\t\t\t\tpr_err(\" core_scsi3_tpg_depend_item()\"\n\t\t\t\t\t\" for tmp_tpg\\n\");\n\t\t\t\tatomic_dec_mb(&tmp_tpg->tpg_pr_ref_count);\n\t\t\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\t\t\t \n\t\t\tmutex_lock(&tmp_tpg->acl_node_mutex);\n\t\t\tdest_node_acl = __core_tpg_get_initiator_node_acl(\n\t\t\t\t\t\ttmp_tpg, i_str);\n\t\t\tif (dest_node_acl)\n\t\t\t\tatomic_inc_mb(&dest_node_acl->acl_pr_ref_count);\n\t\t\tmutex_unlock(&tmp_tpg->acl_node_mutex);\n\n\t\t\tif (!dest_node_acl) {\n\t\t\t\tcore_scsi3_tpg_undepend_item(tmp_tpg);\n\t\t\t\tspin_lock(&dev->se_port_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (core_scsi3_nodeacl_depend_item(dest_node_acl)) {\n\t\t\t\tpr_err(\"configfs_depend_item() failed\"\n\t\t\t\t\t\" for dest_node_acl->acl_group\\n\");\n\t\t\t\tatomic_dec_mb(&dest_node_acl->acl_pr_ref_count);\n\t\t\t\tcore_scsi3_tpg_undepend_item(tmp_tpg);\n\t\t\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\t\t\tgoto out_unmap;\n\t\t\t}\n\n\t\t\tdest_tpg = tmp_tpg;\n\t\t\tpr_debug(\"SPC-3 PR SPEC_I_PT: Located %s Node: %s Port RTPI: %u\\n\",\n\t\t\t\tdest_tpg->se_tpg_tfo->fabric_name,\n\t\t\t\tdest_node_acl->initiatorname, dest_rtpi);\n\n\t\t\tspin_lock(&dev->se_port_lock);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&dev->se_port_lock);\n\n\t\tif (!dest_tpg) {\n\t\t\tpr_err(\"SPC-3 PR SPEC_I_PT: Unable to locate\"\n\t\t\t\t\t\" dest_tpg\\n\");\n\t\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\tpr_debug(\"SPC-3 PR SPEC_I_PT: Got %s data_length: %u tpdl: %u\"\n\t\t\t\" tid_len: %d for %s + %s\\n\",\n\t\t\tdest_tpg->se_tpg_tfo->fabric_name, cmd->data_length,\n\t\t\ttpdl, tid_len, i_str, iport_ptr);\n\n\t\tif (tid_len > tpdl) {\n\t\t\tpr_err(\"SPC-3 PR SPEC_I_PT: Illegal tid_len:\"\n\t\t\t\t\" %u for Transport ID: %s\\n\", tid_len, ptr);\n\t\t\tcore_scsi3_nodeacl_undepend_item(dest_node_acl);\n\t\t\tcore_scsi3_tpg_undepend_item(dest_tpg);\n\t\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\t \n\t\tdest_se_deve = core_get_se_deve_from_rtpi(dest_node_acl,\n\t\t\t\t\tdest_rtpi);\n\t\tif (!dest_se_deve) {\n\t\t\tpr_err(\"Unable to locate %s dest_se_deve from destination RTPI: %u\\n\",\n\t\t\t\tdest_tpg->se_tpg_tfo->fabric_name,\n\t\t\t\tdest_rtpi);\n\n\t\t\tcore_scsi3_nodeacl_undepend_item(dest_node_acl);\n\t\t\tcore_scsi3_tpg_undepend_item(dest_tpg);\n\t\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\tif (core_scsi3_lunacl_depend_item(dest_se_deve)) {\n\t\t\tpr_err(\"core_scsi3_lunacl_depend_item()\"\n\t\t\t\t\t\" failed\\n\");\n\t\t\tkref_put(&dest_se_deve->pr_kref, target_pr_kref_release);\n\t\t\tcore_scsi3_nodeacl_undepend_item(dest_node_acl);\n\t\t\tcore_scsi3_tpg_undepend_item(dest_tpg);\n\t\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\tpr_debug(\"SPC-3 PR SPEC_I_PT: Located %s Node: %s\"\n\t\t\t\" dest_se_deve mapped_lun: %llu\\n\",\n\t\t\tdest_tpg->se_tpg_tfo->fabric_name,\n\t\t\tdest_node_acl->initiatorname, dest_se_deve->mapped_lun);\n\n\t\t \n\t\tpr_reg_e = __core_scsi3_locate_pr_reg(dev, dest_node_acl,\n\t\t\t\t\tiport_ptr);\n\t\tif (pr_reg_e) {\n\t\t\tcore_scsi3_put_pr_reg(pr_reg_e);\n\t\t\tcore_scsi3_lunacl_undepend_item(dest_se_deve);\n\t\t\tcore_scsi3_nodeacl_undepend_item(dest_node_acl);\n\t\t\tcore_scsi3_tpg_undepend_item(dest_tpg);\n\t\t\tptr += tid_len;\n\t\t\ttpdl -= tid_len;\n\t\t\ttid_len = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\ttidh_new = kzalloc(sizeof(struct pr_transport_id_holder),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!tidh_new) {\n\t\t\tpr_err(\"Unable to allocate tidh_new\\n\");\n\t\t\tcore_scsi3_lunacl_undepend_item(dest_se_deve);\n\t\t\tcore_scsi3_nodeacl_undepend_item(dest_node_acl);\n\t\t\tcore_scsi3_tpg_undepend_item(dest_tpg);\n\t\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\tINIT_LIST_HEAD(&tidh_new->dest_list);\n\t\ttidh_new->dest_tpg = dest_tpg;\n\t\ttidh_new->dest_node_acl = dest_node_acl;\n\t\ttidh_new->dest_se_deve = dest_se_deve;\n\n\t\t \n\t\tdest_lun = dest_se_deve->se_lun;\n\n\t\tdest_pr_reg = __core_scsi3_alloc_registration(cmd->se_dev,\n\t\t\t\t\tdest_node_acl, dest_lun, dest_se_deve,\n\t\t\t\t\tdest_se_deve->mapped_lun, iport_ptr,\n\t\t\t\t\tsa_res_key, all_tg_pt, aptpl);\n\t\tif (!dest_pr_reg) {\n\t\t\tcore_scsi3_lunacl_undepend_item(dest_se_deve);\n\t\t\tcore_scsi3_nodeacl_undepend_item(dest_node_acl);\n\t\t\tcore_scsi3_tpg_undepend_item(dest_tpg);\n\t\t\tkfree(tidh_new);\n\t\t\tret = TCM_INSUFFICIENT_REGISTRATION_RESOURCES;\n\t\t\tgoto out_unmap;\n\t\t}\n\t\ttidh_new->dest_pr_reg = dest_pr_reg;\n\t\tlist_add_tail(&tidh_new->dest_list, &tid_dest_list);\n\n\t\tptr += tid_len;\n\t\ttpdl -= tid_len;\n\t\ttid_len = 0;\n\n\t}\n\n\ttransport_kunmap_data_sg(cmd);\n\n\t \n\tlist_for_each_entry_safe(tidh, tidh_tmp, &tid_dest_list, dest_list) {\n\t\tdest_tpg = tidh->dest_tpg;\n\t\tdest_node_acl = tidh->dest_node_acl;\n\t\tdest_se_deve = tidh->dest_se_deve;\n\t\tdest_pr_reg = tidh->dest_pr_reg;\n\n\t\tlist_del(&tidh->dest_list);\n\t\tkfree(tidh);\n\n\t\tmemset(i_buf, 0, PR_REG_ISID_ID_LEN);\n\t\tcore_pr_dump_initiator_port(dest_pr_reg, i_buf, PR_REG_ISID_ID_LEN);\n\n\t\t__core_scsi3_add_registration(cmd->se_dev, dest_node_acl,\n\t\t\t\t\tdest_pr_reg, 0, 0);\n\n\t\tpr_debug(\"SPC-3 PR [%s] SPEC_I_PT: Successfully\"\n\t\t\t\" registered Transport ID for Node: %s%s Mapped LUN:\"\n\t\t\t\" %llu\\n\", dest_tpg->se_tpg_tfo->fabric_name,\n\t\t\tdest_node_acl->initiatorname, i_buf, (dest_se_deve) ?\n\t\t\tdest_se_deve->mapped_lun : 0);\n\n\t\tif (dest_pr_reg == local_pr_reg)\n\t\t\tcontinue;\n\n\t\tcore_scsi3_nodeacl_undepend_item(dest_node_acl);\n\t\tcore_scsi3_tpg_undepend_item(dest_tpg);\n\t}\n\n\treturn 0;\nout_unmap:\n\ttransport_kunmap_data_sg(cmd);\nout:\n\t \n\tlist_for_each_entry_safe(tidh, tidh_tmp, &tid_dest_list, dest_list) {\n\t\tbool is_local = false;\n\n\t\tdest_tpg = tidh->dest_tpg;\n\t\tdest_node_acl = tidh->dest_node_acl;\n\t\tdest_se_deve = tidh->dest_se_deve;\n\t\tdest_pr_reg = tidh->dest_pr_reg;\n\n\t\tif (dest_pr_reg == local_pr_reg)\n\t\t\tis_local = true;\n\n\t\tlist_del(&tidh->dest_list);\n\t\tkfree(tidh);\n\t\t \n\t\tlist_for_each_entry_safe(pr_reg_tmp, pr_reg_tmp_safe,\n\t\t\t\t&dest_pr_reg->pr_reg_atp_list,\n\t\t\t\tpr_reg_atp_mem_list) {\n\t\t\tlist_del(&pr_reg_tmp->pr_reg_atp_mem_list);\n\t\t\tcore_scsi3_lunacl_undepend_item(pr_reg_tmp->pr_reg_deve);\n\t\t\tkmem_cache_free(t10_pr_reg_cache, pr_reg_tmp);\n\t\t}\n\n\t\tkmem_cache_free(t10_pr_reg_cache, dest_pr_reg);\n\t\tcore_scsi3_lunacl_undepend_item(dest_se_deve);\n\n\t\tif (is_local)\n\t\t\tcontinue;\n\n\t\tcore_scsi3_nodeacl_undepend_item(dest_node_acl);\n\t\tcore_scsi3_tpg_undepend_item(dest_tpg);\n\t}\n\treturn ret;\n}\n\nstatic int core_scsi3_update_aptpl_buf(\n\tstruct se_device *dev,\n\tunsigned char *buf,\n\tu32 pr_aptpl_buf_len)\n{\n\tstruct se_portal_group *tpg;\n\tstruct t10_pr_registration *pr_reg;\n\tunsigned char tmp[512], isid_buf[32];\n\tssize_t len = 0;\n\tint reg_count = 0;\n\tint ret = 0;\n\n\tspin_lock(&dev->dev_reservation_lock);\n\tspin_lock(&dev->t10_pr.registration_lock);\n\t \n\tlist_for_each_entry(pr_reg, &dev->t10_pr.registration_list,\n\t\t\tpr_reg_list) {\n\n\t\ttmp[0] = '\\0';\n\t\tisid_buf[0] = '\\0';\n\t\ttpg = pr_reg->pr_reg_nacl->se_tpg;\n\t\t \n\t\tif (pr_reg->isid_present_at_reg)\n\t\t\tsnprintf(isid_buf, 32, \"initiator_sid=%s\\n\",\n\t\t\t\t\tpr_reg->pr_reg_isid);\n\t\t \n\t\tif (dev->dev_pr_res_holder == pr_reg) {\n\t\t\tsnprintf(tmp, 512, \"PR_REG_START: %d\"\n\t\t\t\t\"\\ninitiator_fabric=%s\\n\"\n\t\t\t\t\"initiator_node=%s\\n%s\"\n\t\t\t\t\"sa_res_key=%llu\\n\"\n\t\t\t\t\"res_holder=1\\nres_type=%02x\\n\"\n\t\t\t\t\"res_scope=%02x\\nres_all_tg_pt=%d\\n\"\n\t\t\t\t\"mapped_lun=%llu\\n\", reg_count,\n\t\t\t\ttpg->se_tpg_tfo->fabric_name,\n\t\t\t\tpr_reg->pr_reg_nacl->initiatorname, isid_buf,\n\t\t\t\tpr_reg->pr_res_key, pr_reg->pr_res_type,\n\t\t\t\tpr_reg->pr_res_scope, pr_reg->pr_reg_all_tg_pt,\n\t\t\t\tpr_reg->pr_res_mapped_lun);\n\t\t} else {\n\t\t\tsnprintf(tmp, 512, \"PR_REG_START: %d\\n\"\n\t\t\t\t\"initiator_fabric=%s\\ninitiator_node=%s\\n%s\"\n\t\t\t\t\"sa_res_key=%llu\\nres_holder=0\\n\"\n\t\t\t\t\"res_all_tg_pt=%d\\nmapped_lun=%llu\\n\",\n\t\t\t\treg_count, tpg->se_tpg_tfo->fabric_name,\n\t\t\t\tpr_reg->pr_reg_nacl->initiatorname, isid_buf,\n\t\t\t\tpr_reg->pr_res_key, pr_reg->pr_reg_all_tg_pt,\n\t\t\t\tpr_reg->pr_res_mapped_lun);\n\t\t}\n\n\t\tif ((len + strlen(tmp) >= pr_aptpl_buf_len)) {\n\t\t\tpr_err(\"Unable to update renaming APTPL metadata,\"\n\t\t\t       \" reallocating larger buffer\\n\");\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto out;\n\t\t}\n\t\tlen += sprintf(buf+len, \"%s\", tmp);\n\n\t\t \n\t\tsnprintf(tmp, 512, \"target_fabric=%s\\ntarget_node=%s\\n\"\n\t\t\t\"tpgt=%hu\\nport_rtpi=%hu\\ntarget_lun=%llu\\nPR_REG_END:\"\n\t\t\t\" %d\\n\", tpg->se_tpg_tfo->fabric_name,\n\t\t\ttpg->se_tpg_tfo->tpg_get_wwn(tpg),\n\t\t\ttpg->se_tpg_tfo->tpg_get_tag(tpg),\n\t\t\tpr_reg->tg_pt_sep_rtpi, pr_reg->pr_aptpl_target_lun,\n\t\t\treg_count);\n\n\t\tif ((len + strlen(tmp) >= pr_aptpl_buf_len)) {\n\t\t\tpr_err(\"Unable to update renaming APTPL metadata,\"\n\t\t\t       \" reallocating larger buffer\\n\");\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto out;\n\t\t}\n\t\tlen += sprintf(buf+len, \"%s\", tmp);\n\t\treg_count++;\n\t}\n\n\tif (!reg_count)\n\t\tlen += sprintf(buf+len, \"No Registrations or Reservations\");\n\nout:\n\tspin_unlock(&dev->t10_pr.registration_lock);\n\tspin_unlock(&dev->dev_reservation_lock);\n\n\treturn ret;\n}\n\nstatic int __core_scsi3_write_aptpl_to_file(\n\tstruct se_device *dev,\n\tunsigned char *buf)\n{\n\tstruct t10_wwn *wwn = &dev->t10_wwn;\n\tstruct file *file;\n\tint flags = O_RDWR | O_CREAT | O_TRUNC;\n\tchar *path;\n\tu32 pr_aptpl_buf_len;\n\tint ret;\n\tloff_t pos = 0;\n\n\tpath = kasprintf(GFP_KERNEL, \"%s/pr/aptpl_%s\", db_root,\n\t\t\t&wwn->unit_serial[0]);\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tfile = filp_open(path, flags, 0600);\n\tif (IS_ERR(file)) {\n\t\tpr_err(\"filp_open(%s) for APTPL metadata\"\n\t\t\t\" failed\\n\", path);\n\t\tkfree(path);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tpr_aptpl_buf_len = (strlen(buf) + 1);  \n\n\tret = kernel_write(file, buf, pr_aptpl_buf_len, &pos);\n\n\tif (ret < 0)\n\t\tpr_debug(\"Error writing APTPL metadata file: %s\\n\", path);\n\tfput(file);\n\tkfree(path);\n\n\treturn (ret < 0) ? -EIO : 0;\n}\n\n \nstatic sense_reason_t core_scsi3_update_and_write_aptpl(struct se_device *dev, bool aptpl)\n{\n\tunsigned char *buf;\n\tint rc, len = PR_APTPL_BUF_LEN;\n\n\tif (!aptpl) {\n\t\tchar *null_buf = \"No Registrations or Reservations\\n\";\n\n\t\trc = __core_scsi3_write_aptpl_to_file(dev, null_buf);\n\t\tdev->t10_pr.pr_aptpl_active = 0;\n\t\tpr_debug(\"SPC-3 PR: Set APTPL Bit Deactivated\\n\");\n\n\t\tif (rc)\n\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\t\treturn 0;\n\t}\nretry:\n\tbuf = vzalloc(len);\n\tif (!buf)\n\t\treturn TCM_OUT_OF_RESOURCES;\n\n\trc = core_scsi3_update_aptpl_buf(dev, buf, len);\n\tif (rc < 0) {\n\t\tvfree(buf);\n\t\tlen *= 2;\n\t\tgoto retry;\n\t}\n\n\trc = __core_scsi3_write_aptpl_to_file(dev, buf);\n\tif (rc != 0) {\n\t\tpr_err(\"SPC-3 PR: Could not update APTPL\\n\");\n\t\tvfree(buf);\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\tdev->t10_pr.pr_aptpl_active = 1;\n\tvfree(buf);\n\tpr_debug(\"SPC-3 PR: Set APTPL Bit Activated\\n\");\n\treturn 0;\n}\n\nstatic sense_reason_t\ncore_scsi3_emulate_pro_register(struct se_cmd *cmd, u64 res_key, u64 sa_res_key,\n\t\tbool aptpl, bool all_tg_pt, bool spec_i_pt, enum register_type register_type)\n{\n\tstruct se_session *se_sess = cmd->se_sess;\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_lun *se_lun = cmd->se_lun;\n\tstruct se_portal_group *se_tpg;\n\tstruct t10_pr_registration *pr_reg, *pr_reg_p, *pr_reg_tmp;\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tunsigned char isid_buf[PR_REG_ISID_LEN] = { };\n\tunsigned char *isid_ptr = NULL;\n\tsense_reason_t ret = TCM_NO_SENSE;\n\tint pr_holder = 0, type;\n\n\tif (!se_sess || !se_lun) {\n\t\tpr_err(\"SPC-3 PR: se_sess || struct se_lun is NULL!\\n\");\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\tse_tpg = se_sess->se_tpg;\n\n\tif (se_tpg->se_tpg_tfo->sess_get_initiator_sid) {\n\t\tse_tpg->se_tpg_tfo->sess_get_initiator_sid(se_sess, &isid_buf[0],\n\t\t\t\tPR_REG_ISID_LEN);\n\t\tisid_ptr = &isid_buf[0];\n\t}\n\t \n\tpr_reg = core_scsi3_locate_pr_reg(dev, se_sess->se_node_acl, se_sess);\n\tif (!pr_reg) {\n\t\tif (res_key) {\n\t\t\tpr_warn(\"SPC-3 PR: Reservation Key non-zero\"\n\t\t\t\t\" for SA REGISTER, returning CONFLICT\\n\");\n\t\t\treturn TCM_RESERVATION_CONFLICT;\n\t\t}\n\t\t \n\t\tif (!sa_res_key)\n\t\t\treturn 0;\n\n\t\tif (!spec_i_pt) {\n\t\t\t \n\t\t\tif (core_scsi3_alloc_registration(cmd->se_dev,\n\t\t\t\t\tse_sess->se_node_acl, cmd->se_lun,\n\t\t\t\t\tNULL, cmd->orig_fe_lun, isid_ptr,\n\t\t\t\t\tsa_res_key, all_tg_pt, aptpl,\n\t\t\t\t\tregister_type, 0)) {\n\t\t\t\tpr_err(\"Unable to allocate\"\n\t\t\t\t\t\" struct t10_pr_registration\\n\");\n\t\t\t\treturn TCM_INSUFFICIENT_REGISTRATION_RESOURCES;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tret = core_scsi3_decode_spec_i_port(cmd, se_tpg,\n\t\t\t\t\tisid_ptr, sa_res_key, all_tg_pt, aptpl);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\treturn core_scsi3_update_and_write_aptpl(dev, aptpl);\n\t}\n\n\t \n\n\tif ((register_type == REGISTER) && (res_key != pr_reg->pr_res_key)) {\n\t\tpr_err(\"SPC-3 PR REGISTER: Received\"\n\t\t       \" res_key: 0x%016Lx does not match\"\n\t\t       \" existing SA REGISTER res_key:\"\n\t\t       \" 0x%016Lx\\n\", res_key,\n\t\t       pr_reg->pr_res_key);\n\t\tret = TCM_RESERVATION_CONFLICT;\n\t\tgoto out;\n\t}\n\n\tif (spec_i_pt) {\n\t\tpr_err(\"SPC-3 PR REGISTER: SPEC_I_PT\"\n\t\t\t\" set on a registered nexus\\n\");\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out;\n\t}\n\n\t \n\tif (pr_reg->pr_reg_all_tg_pt && !all_tg_pt) {\n\t\tpr_err(\"SPC-3 PR REGISTER: ALL_TG_PT=1\"\n\t\t\t\" registration exists, but ALL_TG_PT=1 bit not\"\n\t\t\t\" present in received PROUT\\n\");\n\t\tret = TCM_INVALID_CDB_FIELD;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sa_res_key) {\n\t\t \n\t\tpr_reg->pr_res_generation = core_scsi3_pr_generation(cmd->se_dev);\n\t\tpr_reg->pr_res_key = sa_res_key;\n\t\tpr_debug(\"SPC-3 PR [%s] REGISTER%s: Changed Reservation\"\n\t\t\t \" Key for %s to: 0x%016Lx PRgeneration:\"\n\t\t\t \" 0x%08x\\n\", cmd->se_tfo->fabric_name,\n\t\t\t (register_type == REGISTER_AND_IGNORE_EXISTING_KEY) ? \"_AND_IGNORE_EXISTING_KEY\" : \"\",\n\t\t\t pr_reg->pr_reg_nacl->initiatorname,\n\t\t\t pr_reg->pr_res_key, pr_reg->pr_res_generation);\n\n\t} else {\n\t\t \n\t\ttype = pr_reg->pr_res_type;\n\t\tpr_holder = core_scsi3_check_implicit_release(cmd->se_dev,\n\t\t\t\t\t\t\t      pr_reg);\n\t\tif (pr_holder < 0) {\n\t\t\tret = TCM_RESERVATION_CONFLICT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&pr_tmpl->registration_lock);\n\t\t \n\t\tif (pr_reg->pr_reg_all_tg_pt) {\n\t\t\tlist_for_each_entry_safe(pr_reg_p, pr_reg_tmp,\n\t\t\t\t\t&pr_tmpl->registration_list,\n\t\t\t\t\tpr_reg_list) {\n\n\t\t\t\tif (!pr_reg_p->pr_reg_all_tg_pt)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (pr_reg_p->pr_res_key != res_key)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (pr_reg == pr_reg_p)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (strcmp(pr_reg->pr_reg_nacl->initiatorname,\n\t\t\t\t\t   pr_reg_p->pr_reg_nacl->initiatorname))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t__core_scsi3_free_registration(dev,\n\t\t\t\t\t\tpr_reg_p, NULL, 0);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\t__core_scsi3_free_registration(cmd->se_dev, pr_reg, NULL, 1);\n\t\tpr_reg = NULL;\n\n\t\t \n\t\tif (pr_holder &&\n\t\t    (type == PR_TYPE_WRITE_EXCLUSIVE_REGONLY ||\n\t\t     type == PR_TYPE_EXCLUSIVE_ACCESS_REGONLY)) {\n\t\t\tlist_for_each_entry(pr_reg_p,\n\t\t\t\t\t&pr_tmpl->registration_list,\n\t\t\t\t\tpr_reg_list) {\n\n\t\t\t\ttarget_ua_allocate_lun(\n\t\t\t\t\tpr_reg_p->pr_reg_nacl,\n\t\t\t\t\tpr_reg_p->pr_res_mapped_lun,\n\t\t\t\t\t0x2A,\n\t\t\t\t\tASCQ_2AH_RESERVATIONS_RELEASED);\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock(&pr_tmpl->registration_lock);\n\t}\n\n\tret = core_scsi3_update_and_write_aptpl(dev, aptpl);\n\nout:\n\tif (pr_reg)\n\t\tcore_scsi3_put_pr_reg(pr_reg);\n\treturn ret;\n}\n\nunsigned char *core_scsi3_pr_dump_type(int type)\n{\n\tswitch (type) {\n\tcase PR_TYPE_WRITE_EXCLUSIVE:\n\t\treturn \"Write Exclusive Access\";\n\tcase PR_TYPE_EXCLUSIVE_ACCESS:\n\t\treturn \"Exclusive Access\";\n\tcase PR_TYPE_WRITE_EXCLUSIVE_REGONLY:\n\t\treturn \"Write Exclusive Access, Registrants Only\";\n\tcase PR_TYPE_EXCLUSIVE_ACCESS_REGONLY:\n\t\treturn \"Exclusive Access, Registrants Only\";\n\tcase PR_TYPE_WRITE_EXCLUSIVE_ALLREG:\n\t\treturn \"Write Exclusive Access, All Registrants\";\n\tcase PR_TYPE_EXCLUSIVE_ACCESS_ALLREG:\n\t\treturn \"Exclusive Access, All Registrants\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"Unknown SPC-3 PR Type\";\n}\n\nstatic sense_reason_t\ncore_scsi3_pro_reserve(struct se_cmd *cmd, int type, int scope, u64 res_key)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_session *se_sess = cmd->se_sess;\n\tstruct se_lun *se_lun = cmd->se_lun;\n\tstruct t10_pr_registration *pr_reg, *pr_res_holder;\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tchar i_buf[PR_REG_ISID_ID_LEN] = { };\n\tsense_reason_t ret;\n\n\tif (!se_sess || !se_lun) {\n\t\tpr_err(\"SPC-3 PR: se_sess || struct se_lun is NULL!\\n\");\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\t \n\tpr_reg = core_scsi3_locate_pr_reg(cmd->se_dev, se_sess->se_node_acl,\n\t\t\t\tse_sess);\n\tif (!pr_reg) {\n\t\tpr_err(\"SPC-3 PR: Unable to locate\"\n\t\t\t\" PR_REGISTERED *pr_reg for RESERVE\\n\");\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\t \n\tif (res_key != pr_reg->pr_res_key) {\n\t\tpr_err(\"SPC-3 PR RESERVE: Received res_key: 0x%016Lx\"\n\t\t\t\" does not match existing SA REGISTER res_key:\"\n\t\t\t\" 0x%016Lx\\n\", res_key, pr_reg->pr_res_key);\n\t\tret = TCM_RESERVATION_CONFLICT;\n\t\tgoto out_put_pr_reg;\n\t}\n\t \n\tif (scope != PR_SCOPE_LU_SCOPE) {\n\t\tpr_err(\"SPC-3 PR: Illegal SCOPE: 0x%02x\\n\", scope);\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out_put_pr_reg;\n\t}\n\t \n\tspin_lock(&dev->dev_reservation_lock);\n\tpr_res_holder = dev->dev_pr_res_holder;\n\tif (pr_res_holder) {\n\t\t \n\t\tif (!is_reservation_holder(pr_res_holder, pr_reg)) {\n\t\t\tstruct se_node_acl *pr_res_nacl = pr_res_holder->pr_reg_nacl;\n\t\t\tpr_err(\"SPC-3 PR: Attempted RESERVE from\"\n\t\t\t\t\" [%s]: %s while reservation already held by\"\n\t\t\t\t\" [%s]: %s, returning RESERVATION_CONFLICT\\n\",\n\t\t\t\tcmd->se_tfo->fabric_name,\n\t\t\t\tse_sess->se_node_acl->initiatorname,\n\t\t\t\tpr_res_nacl->se_tpg->se_tpg_tfo->fabric_name,\n\t\t\t\tpr_res_holder->pr_reg_nacl->initiatorname);\n\n\t\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\t\tret = TCM_RESERVATION_CONFLICT;\n\t\t\tgoto out_put_pr_reg;\n\t\t}\n\t\t \n\t\tif ((pr_res_holder->pr_res_type != type) ||\n\t\t    (pr_res_holder->pr_res_scope != scope)) {\n\t\t\tstruct se_node_acl *pr_res_nacl = pr_res_holder->pr_reg_nacl;\n\t\t\tpr_err(\"SPC-3 PR: Attempted RESERVE from\"\n\t\t\t\t\" [%s]: %s trying to change TYPE and/or SCOPE,\"\n\t\t\t\t\" while reservation already held by [%s]: %s,\"\n\t\t\t\t\" returning RESERVATION_CONFLICT\\n\",\n\t\t\t\tcmd->se_tfo->fabric_name,\n\t\t\t\tse_sess->se_node_acl->initiatorname,\n\t\t\t\tpr_res_nacl->se_tpg->se_tpg_tfo->fabric_name,\n\t\t\t\tpr_res_holder->pr_reg_nacl->initiatorname);\n\n\t\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\t\tret = TCM_RESERVATION_CONFLICT;\n\t\t\tgoto out_put_pr_reg;\n\t\t}\n\t\t \n\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\tret = 0;\n\t\tgoto out_put_pr_reg;\n\t}\n\t \n\tpr_reg->pr_res_scope = scope;\n\tpr_reg->pr_res_type = type;\n\tpr_reg->pr_res_holder = 1;\n\tdev->dev_pr_res_holder = pr_reg;\n\tcore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\n\n\tpr_debug(\"SPC-3 PR [%s] Service Action: RESERVE created new\"\n\t\t\" reservation holder TYPE: %s ALL_TG_PT: %d\\n\",\n\t\tcmd->se_tfo->fabric_name, core_scsi3_pr_dump_type(type),\n\t\t(pr_reg->pr_reg_all_tg_pt) ? 1 : 0);\n\tpr_debug(\"SPC-3 PR [%s] RESERVE Node: %s%s\\n\",\n\t\t\tcmd->se_tfo->fabric_name,\n\t\t\tse_sess->se_node_acl->initiatorname,\n\t\t\ti_buf);\n\tspin_unlock(&dev->dev_reservation_lock);\n\n\tif (pr_tmpl->pr_aptpl_active)\n\t\tcore_scsi3_update_and_write_aptpl(cmd->se_dev, true);\n\n\tret = 0;\nout_put_pr_reg:\n\tcore_scsi3_put_pr_reg(pr_reg);\n\treturn ret;\n}\n\nstatic sense_reason_t\ncore_scsi3_emulate_pro_reserve(struct se_cmd *cmd, int type, int scope,\n\t\tu64 res_key)\n{\n\tswitch (type) {\n\tcase PR_TYPE_WRITE_EXCLUSIVE:\n\tcase PR_TYPE_EXCLUSIVE_ACCESS:\n\tcase PR_TYPE_WRITE_EXCLUSIVE_REGONLY:\n\tcase PR_TYPE_EXCLUSIVE_ACCESS_REGONLY:\n\tcase PR_TYPE_WRITE_EXCLUSIVE_ALLREG:\n\tcase PR_TYPE_EXCLUSIVE_ACCESS_ALLREG:\n\t\treturn core_scsi3_pro_reserve(cmd, type, scope, res_key);\n\tdefault:\n\t\tpr_err(\"SPC-3 PR: Unknown Service Action RESERVE Type:\"\n\t\t\t\" 0x%02x\\n\", type);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n}\n\nstatic void __core_scsi3_complete_pro_release(\n\tstruct se_device *dev,\n\tstruct se_node_acl *se_nacl,\n\tstruct t10_pr_registration *pr_reg,\n\tint explicit,\n\tint unreg)\n{\n\tconst struct target_core_fabric_ops *tfo = se_nacl->se_tpg->se_tpg_tfo;\n\tchar i_buf[PR_REG_ISID_ID_LEN] = { };\n\tint pr_res_type = 0, pr_res_scope = 0;\n\n\tlockdep_assert_held(&dev->dev_reservation_lock);\n\n\tcore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\n\t \n\tif (dev->dev_pr_res_holder) {\n\t\tpr_res_type = dev->dev_pr_res_holder->pr_res_type;\n\t\tpr_res_scope = dev->dev_pr_res_holder->pr_res_scope;\n\t\tdev->dev_pr_res_holder->pr_res_type = 0;\n\t\tdev->dev_pr_res_holder->pr_res_scope = 0;\n\t\tdev->dev_pr_res_holder->pr_res_holder = 0;\n\t\tdev->dev_pr_res_holder = NULL;\n\t}\n\tif (!unreg)\n\t\tgoto out;\n\n\tspin_lock(&dev->t10_pr.registration_lock);\n\tlist_del_init(&pr_reg->pr_reg_list);\n\t \n\tif (!list_empty(&dev->t10_pr.registration_list) &&\n\t    ((pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG) ||\n\t     (pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG))) {\n\t\tdev->dev_pr_res_holder =\n\t\t\tlist_entry(dev->t10_pr.registration_list.next,\n\t\t\t\t   struct t10_pr_registration, pr_reg_list);\n\t\tdev->dev_pr_res_holder->pr_res_type = pr_res_type;\n\t\tdev->dev_pr_res_holder->pr_res_scope = pr_res_scope;\n\t\tdev->dev_pr_res_holder->pr_res_holder = 1;\n\t}\n\tspin_unlock(&dev->t10_pr.registration_lock);\nout:\n\tif (!dev->dev_pr_res_holder) {\n\t\tpr_debug(\"SPC-3 PR [%s] Service Action: %s RELEASE cleared\"\n\t\t\t\" reservation holder TYPE: %s ALL_TG_PT: %d\\n\",\n\t\t\ttfo->fabric_name, (explicit) ? \"explicit\" :\n\t\t\t\"implicit\", core_scsi3_pr_dump_type(pr_res_type),\n\t\t\t(pr_reg->pr_reg_all_tg_pt) ? 1 : 0);\n\t}\n\tpr_debug(\"SPC-3 PR [%s] RELEASE Node: %s%s\\n\",\n\t\ttfo->fabric_name, se_nacl->initiatorname,\n\t\ti_buf);\n\t \n\tpr_reg->pr_res_holder = pr_reg->pr_res_type = pr_reg->pr_res_scope = 0;\n}\n\nstatic sense_reason_t\ncore_scsi3_emulate_pro_release(struct se_cmd *cmd, int type, int scope,\n\t\tu64 res_key)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_session *se_sess = cmd->se_sess;\n\tstruct se_lun *se_lun = cmd->se_lun;\n\tstruct t10_pr_registration *pr_reg, *pr_reg_p, *pr_res_holder;\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tsense_reason_t ret = 0;\n\n\tif (!se_sess || !se_lun) {\n\t\tpr_err(\"SPC-3 PR: se_sess || struct se_lun is NULL!\\n\");\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\t \n\tpr_reg = core_scsi3_locate_pr_reg(dev, se_sess->se_node_acl, se_sess);\n\tif (!pr_reg) {\n\t\tpr_err(\"SPC-3 PR: Unable to locate\"\n\t\t\t\" PR_REGISTERED *pr_reg for RELEASE\\n\");\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\t \n\tspin_lock(&dev->dev_reservation_lock);\n\tpr_res_holder = dev->dev_pr_res_holder;\n\tif (!pr_res_holder) {\n\t\t \n\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\tgoto out_put_pr_reg;\n\t}\n\n\tif (!is_reservation_holder(pr_res_holder, pr_reg)) {\n\t\t \n\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\tgoto out_put_pr_reg;\n\t}\n\n\t \n\tif (res_key != pr_reg->pr_res_key) {\n\t\tpr_err(\"SPC-3 PR RELEASE: Received res_key: 0x%016Lx\"\n\t\t\t\" does not match existing SA REGISTER res_key:\"\n\t\t\t\" 0x%016Lx\\n\", res_key, pr_reg->pr_res_key);\n\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\tret = TCM_RESERVATION_CONFLICT;\n\t\tgoto out_put_pr_reg;\n\t}\n\t \n\tif ((pr_res_holder->pr_res_type != type) ||\n\t    (pr_res_holder->pr_res_scope != scope)) {\n\t\tstruct se_node_acl *pr_res_nacl = pr_res_holder->pr_reg_nacl;\n\t\tpr_err(\"SPC-3 PR RELEASE: Attempted to release\"\n\t\t\t\" reservation from [%s]: %s with different TYPE \"\n\t\t\t\"and/or SCOPE  while reservation already held by\"\n\t\t\t\" [%s]: %s, returning RESERVATION_CONFLICT\\n\",\n\t\t\tcmd->se_tfo->fabric_name,\n\t\t\tse_sess->se_node_acl->initiatorname,\n\t\t\tpr_res_nacl->se_tpg->se_tpg_tfo->fabric_name,\n\t\t\tpr_res_holder->pr_reg_nacl->initiatorname);\n\n\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\tret = TCM_RESERVATION_CONFLICT;\n\t\tgoto out_put_pr_reg;\n\t}\n\t \n\t__core_scsi3_complete_pro_release(dev, se_sess->se_node_acl,\n\t\t\t\t\t  pr_reg, 1, 0);\n\n\tspin_unlock(&dev->dev_reservation_lock);\n\n\tif ((type != PR_TYPE_WRITE_EXCLUSIVE_REGONLY) &&\n\t    (type != PR_TYPE_EXCLUSIVE_ACCESS_REGONLY) &&\n\t    (type != PR_TYPE_WRITE_EXCLUSIVE_ALLREG) &&\n\t    (type != PR_TYPE_EXCLUSIVE_ACCESS_ALLREG)) {\n\t\t \n\t\tgoto write_aptpl;\n\t}\n\n\tspin_lock(&pr_tmpl->registration_lock);\n\tlist_for_each_entry(pr_reg_p, &pr_tmpl->registration_list,\n\t\t\tpr_reg_list) {\n\t\t \n\t\tif (pr_reg_p == pr_reg)\n\t\t\tcontinue;\n\n\t\ttarget_ua_allocate_lun(pr_reg_p->pr_reg_nacl,\n\t\t\t\tpr_reg_p->pr_res_mapped_lun,\n\t\t\t\t0x2A, ASCQ_2AH_RESERVATIONS_RELEASED);\n\t}\n\tspin_unlock(&pr_tmpl->registration_lock);\n\nwrite_aptpl:\n\tif (pr_tmpl->pr_aptpl_active)\n\t\tcore_scsi3_update_and_write_aptpl(cmd->se_dev, true);\n\nout_put_pr_reg:\n\tcore_scsi3_put_pr_reg(pr_reg);\n\treturn ret;\n}\n\nstatic sense_reason_t\ncore_scsi3_emulate_pro_clear(struct se_cmd *cmd, u64 res_key)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_node_acl *pr_reg_nacl;\n\tstruct se_session *se_sess = cmd->se_sess;\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tstruct t10_pr_registration *pr_reg, *pr_reg_tmp, *pr_reg_n, *pr_res_holder;\n\tu64 pr_res_mapped_lun = 0;\n\tint calling_it_nexus = 0;\n\t \n\tpr_reg_n = core_scsi3_locate_pr_reg(cmd->se_dev,\n\t\t\tse_sess->se_node_acl, se_sess);\n\tif (!pr_reg_n) {\n\t\tpr_err(\"SPC-3 PR: Unable to locate\"\n\t\t\t\" PR_REGISTERED *pr_reg for CLEAR\\n\");\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\t \n\tif (res_key != pr_reg_n->pr_res_key) {\n\t\tpr_err(\"SPC-3 PR REGISTER: Received\"\n\t\t\t\" res_key: 0x%016Lx does not match\"\n\t\t\t\" existing SA REGISTER res_key:\"\n\t\t\t\" 0x%016Lx\\n\", res_key, pr_reg_n->pr_res_key);\n\t\tcore_scsi3_put_pr_reg(pr_reg_n);\n\t\treturn TCM_RESERVATION_CONFLICT;\n\t}\n\t \n\tspin_lock(&dev->dev_reservation_lock);\n\tpr_res_holder = dev->dev_pr_res_holder;\n\tif (pr_res_holder) {\n\t\tstruct se_node_acl *pr_res_nacl = pr_res_holder->pr_reg_nacl;\n\t\t__core_scsi3_complete_pro_release(dev, pr_res_nacl,\n\t\t\t\t\t\t  pr_res_holder, 0, 0);\n\t}\n\tspin_unlock(&dev->dev_reservation_lock);\n\t \n\tspin_lock(&pr_tmpl->registration_lock);\n\tlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\n\t\t\t&pr_tmpl->registration_list, pr_reg_list) {\n\n\t\tcalling_it_nexus = (pr_reg_n == pr_reg) ? 1 : 0;\n\t\tpr_reg_nacl = pr_reg->pr_reg_nacl;\n\t\tpr_res_mapped_lun = pr_reg->pr_res_mapped_lun;\n\t\t__core_scsi3_free_registration(dev, pr_reg, NULL,\n\t\t\t\t\tcalling_it_nexus);\n\t\t \n\t\tif (!calling_it_nexus)\n\t\t\ttarget_ua_allocate_lun(pr_reg_nacl, pr_res_mapped_lun,\n\t\t\t\t0x2A, ASCQ_2AH_RESERVATIONS_PREEMPTED);\n\t}\n\tspin_unlock(&pr_tmpl->registration_lock);\n\n\tpr_debug(\"SPC-3 PR [%s] Service Action: CLEAR complete\\n\",\n\t\tcmd->se_tfo->fabric_name);\n\n\tcore_scsi3_update_and_write_aptpl(cmd->se_dev, false);\n\n\tcore_scsi3_pr_generation(dev);\n\treturn 0;\n}\n\nstatic void __core_scsi3_complete_pro_preempt(\n\tstruct se_device *dev,\n\tstruct t10_pr_registration *pr_reg,\n\tstruct list_head *preempt_and_abort_list,\n\tint type,\n\tint scope,\n\tenum preempt_type preempt_type)\n{\n\tstruct se_node_acl *nacl = pr_reg->pr_reg_nacl;\n\tconst struct target_core_fabric_ops *tfo = nacl->se_tpg->se_tpg_tfo;\n\tchar i_buf[PR_REG_ISID_ID_LEN] = { };\n\n\tlockdep_assert_held(&dev->dev_reservation_lock);\n\n\tcore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\n\t \n\tif (dev->dev_pr_res_holder)\n\t\t__core_scsi3_complete_pro_release(dev, nacl,\n\t\t\t\t\t\t  dev->dev_pr_res_holder, 0, 0);\n\n\tdev->dev_pr_res_holder = pr_reg;\n\tpr_reg->pr_res_holder = 1;\n\tpr_reg->pr_res_type = type;\n\tpr_reg->pr_res_scope = scope;\n\n\tpr_debug(\"SPC-3 PR [%s] Service Action: PREEMPT%s created new\"\n\t\t\" reservation holder TYPE: %s ALL_TG_PT: %d\\n\",\n\t\ttfo->fabric_name, (preempt_type == PREEMPT_AND_ABORT) ? \"_AND_ABORT\" : \"\",\n\t\tcore_scsi3_pr_dump_type(type),\n\t\t(pr_reg->pr_reg_all_tg_pt) ? 1 : 0);\n\tpr_debug(\"SPC-3 PR [%s] PREEMPT%s from Node: %s%s\\n\",\n\t\ttfo->fabric_name, (preempt_type == PREEMPT_AND_ABORT) ? \"_AND_ABORT\" : \"\",\n\t\tnacl->initiatorname, i_buf);\n\t \n\tif (preempt_and_abort_list)\n\t\tlist_add_tail(&pr_reg->pr_reg_abort_list,\n\t\t\t\tpreempt_and_abort_list);\n}\n\nstatic void core_scsi3_release_preempt_and_abort(\n\tstruct list_head *preempt_and_abort_list,\n\tstruct t10_pr_registration *pr_reg_holder)\n{\n\tstruct t10_pr_registration *pr_reg, *pr_reg_tmp;\n\n\tlist_for_each_entry_safe(pr_reg, pr_reg_tmp, preempt_and_abort_list,\n\t\t\t\tpr_reg_abort_list) {\n\n\t\tlist_del(&pr_reg->pr_reg_abort_list);\n\t\tif (pr_reg_holder == pr_reg)\n\t\t\tcontinue;\n\t\tif (pr_reg->pr_res_holder) {\n\t\t\tpr_warn(\"pr_reg->pr_res_holder still set\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_reg->pr_reg_deve = NULL;\n\t\tpr_reg->pr_reg_nacl = NULL;\n\t\tkmem_cache_free(t10_pr_reg_cache, pr_reg);\n\t}\n}\n\nstatic sense_reason_t\ncore_scsi3_pro_preempt(struct se_cmd *cmd, int type, int scope, u64 res_key,\n\t\tu64 sa_res_key, enum preempt_type preempt_type)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_node_acl *pr_reg_nacl;\n\tstruct se_session *se_sess = cmd->se_sess;\n\tLIST_HEAD(preempt_and_abort_list);\n\tstruct t10_pr_registration *pr_reg, *pr_reg_tmp, *pr_reg_n, *pr_res_holder;\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tu64 pr_res_mapped_lun = 0;\n\tint all_reg = 0, calling_it_nexus = 0;\n\tbool sa_res_key_unmatched = sa_res_key != 0;\n\tint prh_type = 0, prh_scope = 0;\n\n\tif (!se_sess)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tpr_reg_n = core_scsi3_locate_pr_reg(cmd->se_dev, se_sess->se_node_acl,\n\t\t\t\tse_sess);\n\tif (!pr_reg_n) {\n\t\tpr_err(\"SPC-3 PR: Unable to locate\"\n\t\t\t\" PR_REGISTERED *pr_reg for PREEMPT%s\\n\",\n\t\t\t(preempt_type == PREEMPT_AND_ABORT) ? \"_AND_ABORT\" : \"\");\n\t\treturn TCM_RESERVATION_CONFLICT;\n\t}\n\tif (pr_reg_n->pr_res_key != res_key) {\n\t\tcore_scsi3_put_pr_reg(pr_reg_n);\n\t\treturn TCM_RESERVATION_CONFLICT;\n\t}\n\tif (scope != PR_SCOPE_LU_SCOPE) {\n\t\tpr_err(\"SPC-3 PR: Illegal SCOPE: 0x%02x\\n\", scope);\n\t\tcore_scsi3_put_pr_reg(pr_reg_n);\n\t\treturn TCM_INVALID_PARAMETER_LIST;\n\t}\n\n\tspin_lock(&dev->dev_reservation_lock);\n\tpr_res_holder = dev->dev_pr_res_holder;\n\tif (pr_res_holder &&\n\t   ((pr_res_holder->pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG) ||\n\t    (pr_res_holder->pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG)))\n\t\tall_reg = 1;\n\n\tif (!all_reg && !sa_res_key) {\n\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\tcore_scsi3_put_pr_reg(pr_reg_n);\n\t\treturn TCM_INVALID_PARAMETER_LIST;\n\t}\n\t \n\tif (!pr_res_holder || (pr_res_holder->pr_res_key != sa_res_key)) {\n\t\t \n\t\tspin_lock(&pr_tmpl->registration_lock);\n\t\tlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\n\t\t\t\t&pr_tmpl->registration_list, pr_reg_list) {\n\t\t\t \n\t\t\tif (!all_reg) {\n\t\t\t\tif (pr_reg->pr_res_key != sa_res_key)\n\t\t\t\t\tcontinue;\n\t\t\t\tsa_res_key_unmatched = false;\n\n\t\t\t\tcalling_it_nexus = (pr_reg_n == pr_reg) ? 1 : 0;\n\t\t\t\tpr_reg_nacl = pr_reg->pr_reg_nacl;\n\t\t\t\tpr_res_mapped_lun = pr_reg->pr_res_mapped_lun;\n\t\t\t\t__core_scsi3_free_registration(dev, pr_reg,\n\t\t\t\t\t(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list :\n\t\t\t\t\t\tNULL, calling_it_nexus);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif ((sa_res_key) &&\n\t\t\t\t     (pr_reg->pr_res_key != sa_res_key))\n\t\t\t\t\tcontinue;\n\t\t\t\tsa_res_key_unmatched = false;\n\n\t\t\t\tcalling_it_nexus = (pr_reg_n == pr_reg) ? 1 : 0;\n\t\t\t\tif (calling_it_nexus)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tpr_reg_nacl = pr_reg->pr_reg_nacl;\n\t\t\t\tpr_res_mapped_lun = pr_reg->pr_res_mapped_lun;\n\t\t\t\t__core_scsi3_free_registration(dev, pr_reg,\n\t\t\t\t\t(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list :\n\t\t\t\t\t\tNULL, 0);\n\t\t\t}\n\t\t\tif (!calling_it_nexus)\n\t\t\t\ttarget_ua_allocate_lun(pr_reg_nacl,\n\t\t\t\t\tpr_res_mapped_lun, 0x2A,\n\t\t\t\t\tASCQ_2AH_REGISTRATIONS_PREEMPTED);\n\t\t}\n\t\tspin_unlock(&pr_tmpl->registration_lock);\n\t\t \n\t\tif (sa_res_key_unmatched) {\n\t\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\t\tcore_scsi3_put_pr_reg(pr_reg_n);\n\t\t\treturn TCM_RESERVATION_CONFLICT;\n\t\t}\n\t\t \n\t\tif (pr_res_holder && all_reg && !(sa_res_key)) {\n\t\t\t__core_scsi3_complete_pro_preempt(dev, pr_reg_n,\n\t\t\t\t(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list : NULL,\n\t\t\t\ttype, scope, preempt_type);\n\t\t}\n\n\t\tspin_unlock(&dev->dev_reservation_lock);\n\n\t\t \n\t\tif (preempt_type == PREEMPT_AND_ABORT) {\n\t\t\tcore_tmr_lun_reset(dev, NULL, &preempt_and_abort_list,\n\t\t\t\t\t   cmd);\n\t\t\tcore_scsi3_release_preempt_and_abort(\n\t\t\t\t&preempt_and_abort_list, pr_reg_n);\n\t\t}\n\n\t\tif (pr_tmpl->pr_aptpl_active)\n\t\t\tcore_scsi3_update_and_write_aptpl(cmd->se_dev, true);\n\n\t\tcore_scsi3_put_pr_reg(pr_reg_n);\n\t\tcore_scsi3_pr_generation(cmd->se_dev);\n\t\treturn 0;\n\t}\n\t \n\tprh_type = pr_res_holder->pr_res_type;\n\tprh_scope = pr_res_holder->pr_res_scope;\n\t \n\tif (pr_reg_n != pr_res_holder)\n\t\t__core_scsi3_complete_pro_release(dev,\n\t\t\t\t\t\t  pr_res_holder->pr_reg_nacl,\n\t\t\t\t\t\t  dev->dev_pr_res_holder, 0, 0);\n\t \n\tspin_lock(&pr_tmpl->registration_lock);\n\tlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\n\t\t\t&pr_tmpl->registration_list, pr_reg_list) {\n\n\t\tcalling_it_nexus = (pr_reg_n == pr_reg) ? 1 : 0;\n\t\tif (calling_it_nexus)\n\t\t\tcontinue;\n\n\t\tif (sa_res_key && pr_reg->pr_res_key != sa_res_key)\n\t\t\tcontinue;\n\n\t\tpr_reg_nacl = pr_reg->pr_reg_nacl;\n\t\tpr_res_mapped_lun = pr_reg->pr_res_mapped_lun;\n\t\t__core_scsi3_free_registration(dev, pr_reg,\n\t\t\t\t(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list : NULL,\n\t\t\t\tcalling_it_nexus);\n\t\t \n\t\ttarget_ua_allocate_lun(pr_reg_nacl, pr_res_mapped_lun, 0x2A,\n\t\t\t\tASCQ_2AH_REGISTRATIONS_PREEMPTED);\n\t}\n\tspin_unlock(&pr_tmpl->registration_lock);\n\t \n\t__core_scsi3_complete_pro_preempt(dev, pr_reg_n,\n\t\t\t(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list : NULL,\n\t\t\ttype, scope, preempt_type);\n\t \n\tif ((prh_type != type) || (prh_scope != scope)) {\n\t\tspin_lock(&pr_tmpl->registration_lock);\n\t\tlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\n\t\t\t\t&pr_tmpl->registration_list, pr_reg_list) {\n\n\t\t\tcalling_it_nexus = (pr_reg_n == pr_reg) ? 1 : 0;\n\t\t\tif (calling_it_nexus)\n\t\t\t\tcontinue;\n\n\t\t\ttarget_ua_allocate_lun(pr_reg->pr_reg_nacl,\n\t\t\t\t\tpr_reg->pr_res_mapped_lun, 0x2A,\n\t\t\t\t\tASCQ_2AH_RESERVATIONS_RELEASED);\n\t\t}\n\t\tspin_unlock(&pr_tmpl->registration_lock);\n\t}\n\tspin_unlock(&dev->dev_reservation_lock);\n\t \n\tif (preempt_type == PREEMPT_AND_ABORT) {\n\t\tcore_tmr_lun_reset(dev, NULL, &preempt_and_abort_list, cmd);\n\t\tcore_scsi3_release_preempt_and_abort(&preempt_and_abort_list,\n\t\t\t\t\t\tpr_reg_n);\n\t}\n\n\tif (pr_tmpl->pr_aptpl_active)\n\t\tcore_scsi3_update_and_write_aptpl(cmd->se_dev, true);\n\n\tcore_scsi3_put_pr_reg(pr_reg_n);\n\tcore_scsi3_pr_generation(cmd->se_dev);\n\treturn 0;\n}\n\nstatic sense_reason_t\ncore_scsi3_emulate_pro_preempt(struct se_cmd *cmd, int type, int scope,\n\t\tu64 res_key, u64 sa_res_key, enum preempt_type preempt_type)\n{\n\tswitch (type) {\n\tcase PR_TYPE_WRITE_EXCLUSIVE:\n\tcase PR_TYPE_EXCLUSIVE_ACCESS:\n\tcase PR_TYPE_WRITE_EXCLUSIVE_REGONLY:\n\tcase PR_TYPE_EXCLUSIVE_ACCESS_REGONLY:\n\tcase PR_TYPE_WRITE_EXCLUSIVE_ALLREG:\n\tcase PR_TYPE_EXCLUSIVE_ACCESS_ALLREG:\n\t\treturn core_scsi3_pro_preempt(cmd, type, scope, res_key,\n\t\t\t\t\t      sa_res_key, preempt_type);\n\tdefault:\n\t\tpr_err(\"SPC-3 PR: Unknown Service Action PREEMPT%s\"\n\t\t\t\" Type: 0x%02x\\n\", (preempt_type == PREEMPT_AND_ABORT) ? \"_AND_ABORT\" : \"\", type);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n}\n\n\nstatic sense_reason_t\ncore_scsi3_emulate_pro_register_and_move(struct se_cmd *cmd, u64 res_key,\n\t\tu64 sa_res_key, int aptpl, int unreg)\n{\n\tstruct se_session *se_sess = cmd->se_sess;\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_dev_entry *dest_se_deve = NULL;\n\tstruct se_lun *se_lun = cmd->se_lun, *tmp_lun;\n\tstruct se_node_acl *pr_res_nacl, *pr_reg_nacl, *dest_node_acl = NULL;\n\tstruct se_portal_group *se_tpg, *dest_se_tpg = NULL;\n\tconst struct target_core_fabric_ops *dest_tf_ops = NULL, *tf_ops;\n\tstruct t10_pr_registration *pr_reg, *pr_res_holder, *dest_pr_reg;\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tunsigned char *buf;\n\tconst unsigned char *initiator_str;\n\tchar *iport_ptr = NULL, i_buf[PR_REG_ISID_ID_LEN] = { };\n\tu32 tid_len, tmp_tid_len;\n\tint new_reg = 0, type, scope, matching_iname;\n\tsense_reason_t ret;\n\tunsigned short rtpi;\n\tunsigned char proto_ident;\n\n\tif (!se_sess || !se_lun) {\n\t\tpr_err(\"SPC-3 PR: se_sess || struct se_lun is NULL!\\n\");\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\n\tse_tpg = se_sess->se_tpg;\n\ttf_ops = se_tpg->se_tpg_tfo;\n\t \n\tpr_reg = core_scsi3_locate_pr_reg(cmd->se_dev, se_sess->se_node_acl,\n\t\t\t\tse_sess);\n\tif (!pr_reg) {\n\t\tpr_err(\"SPC-3 PR: Unable to locate PR_REGISTERED\"\n\t\t\t\" *pr_reg for REGISTER_AND_MOVE\\n\");\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\t \n\tif (res_key != pr_reg->pr_res_key) {\n\t\tpr_warn(\"SPC-3 PR REGISTER_AND_MOVE: Received\"\n\t\t\t\" res_key: 0x%016Lx does not match existing SA REGISTER\"\n\t\t\t\" res_key: 0x%016Lx\\n\", res_key, pr_reg->pr_res_key);\n\t\tret = TCM_RESERVATION_CONFLICT;\n\t\tgoto out_put_pr_reg;\n\t}\n\t \n\tif (!sa_res_key) {\n\t\tpr_warn(\"SPC-3 PR REGISTER_AND_MOVE: Received zero\"\n\t\t\t\" sa_res_key\\n\");\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out_put_pr_reg;\n\t}\n\n\t \n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf) {\n\t\tret = TCM_INSUFFICIENT_REGISTRATION_RESOURCES;\n\t\tgoto out_put_pr_reg;\n\t}\n\n\trtpi = get_unaligned_be16(&buf[18]);\n\ttid_len = get_unaligned_be32(&buf[20]);\n\ttransport_kunmap_data_sg(cmd);\n\tbuf = NULL;\n\n\tif ((tid_len + 24) != cmd->data_length) {\n\t\tpr_err(\"SPC-3 PR: Illegal tid_len: %u + 24 byte header\"\n\t\t\t\" does not equal CDB data_length: %u\\n\", tid_len,\n\t\t\tcmd->data_length);\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out_put_pr_reg;\n\t}\n\n\tspin_lock(&dev->se_port_lock);\n\tlist_for_each_entry(tmp_lun, &dev->dev_sep_list, lun_dev_link) {\n\t\tif (tmp_lun->lun_tpg->tpg_rtpi != rtpi)\n\t\t\tcontinue;\n\t\tdest_se_tpg = tmp_lun->lun_tpg;\n\t\tdest_tf_ops = dest_se_tpg->se_tpg_tfo;\n\t\tif (!dest_tf_ops)\n\t\t\tcontinue;\n\n\t\tatomic_inc_mb(&dest_se_tpg->tpg_pr_ref_count);\n\t\tspin_unlock(&dev->se_port_lock);\n\n\t\tif (core_scsi3_tpg_depend_item(dest_se_tpg)) {\n\t\t\tpr_err(\"core_scsi3_tpg_depend_item() failed\"\n\t\t\t\t\" for dest_se_tpg\\n\");\n\t\t\tatomic_dec_mb(&dest_se_tpg->tpg_pr_ref_count);\n\t\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\t\tgoto out_put_pr_reg;\n\t\t}\n\n\t\tspin_lock(&dev->se_port_lock);\n\t\tbreak;\n\t}\n\tspin_unlock(&dev->se_port_lock);\n\n\tif (!dest_se_tpg || !dest_tf_ops) {\n\t\tpr_err(\"SPC-3 PR REGISTER_AND_MOVE: Unable to locate\"\n\t\t\t\" fabric ops from Relative Target Port Identifier:\"\n\t\t\t\" %hu\\n\", rtpi);\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out_put_pr_reg;\n\t}\n\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf) {\n\t\tret = TCM_INSUFFICIENT_REGISTRATION_RESOURCES;\n\t\tgoto out_put_pr_reg;\n\t}\n\tproto_ident = (buf[24] & 0x0f);\n\n\tpr_debug(\"SPC-3 PR REGISTER_AND_MOVE: Extracted Protocol Identifier:\"\n\t\t\t\" 0x%02x\\n\", proto_ident);\n\n\tif (proto_ident != dest_se_tpg->proto_id) {\n\t\tpr_err(\"SPC-3 PR REGISTER_AND_MOVE: Received\"\n\t\t\t\" proto_ident: 0x%02x does not match ident: 0x%02x\"\n\t\t\t\" from fabric: %s\\n\", proto_ident,\n\t\t\tdest_se_tpg->proto_id,\n\t\t\tdest_tf_ops->fabric_name);\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out;\n\t}\n\tinitiator_str = target_parse_pr_out_transport_id(dest_se_tpg,\n\t\t\t&buf[24], &tmp_tid_len, &iport_ptr);\n\tif (!initiator_str) {\n\t\tpr_err(\"SPC-3 PR REGISTER_AND_MOVE: Unable to locate\"\n\t\t\t\" initiator_str from Transport ID\\n\");\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out;\n\t}\n\n\ttransport_kunmap_data_sg(cmd);\n\tbuf = NULL;\n\n\tpr_debug(\"SPC-3 PR [%s] Extracted initiator %s identifier: %s\"\n\t\t\" %s\\n\", dest_tf_ops->fabric_name, (iport_ptr != NULL) ?\n\t\t\"port\" : \"device\", initiator_str, (iport_ptr != NULL) ?\n\t\tiport_ptr : \"\");\n\t \n\tpr_reg_nacl = pr_reg->pr_reg_nacl;\n\tmatching_iname = (!strcmp(initiator_str,\n\t\t\t\t  pr_reg_nacl->initiatorname)) ? 1 : 0;\n\tif (!matching_iname)\n\t\tgoto after_iport_check;\n\n\tif (!iport_ptr || !pr_reg->isid_present_at_reg) {\n\t\tpr_err(\"SPC-3 PR REGISTER_AND_MOVE: TransportID: %s\"\n\t\t\t\" matches: %s on received I_T Nexus\\n\", initiator_str,\n\t\t\tpr_reg_nacl->initiatorname);\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out;\n\t}\n\tif (!strcmp(iport_ptr, pr_reg->pr_reg_isid)) {\n\t\tpr_err(\"SPC-3 PR REGISTER_AND_MOVE: TransportID: %s %s\"\n\t\t\t\" matches: %s %s on received I_T Nexus\\n\",\n\t\t\tinitiator_str, iport_ptr, pr_reg_nacl->initiatorname,\n\t\t\tpr_reg->pr_reg_isid);\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out;\n\t}\nafter_iport_check:\n\t \n\tmutex_lock(&dest_se_tpg->acl_node_mutex);\n\tdest_node_acl = __core_tpg_get_initiator_node_acl(dest_se_tpg,\n\t\t\t\tinitiator_str);\n\tif (dest_node_acl)\n\t\tatomic_inc_mb(&dest_node_acl->acl_pr_ref_count);\n\tmutex_unlock(&dest_se_tpg->acl_node_mutex);\n\n\tif (!dest_node_acl) {\n\t\tpr_err(\"Unable to locate %s dest_node_acl for\"\n\t\t\t\" TransportID%s\\n\", dest_tf_ops->fabric_name,\n\t\t\tinitiator_str);\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out;\n\t}\n\n\tif (core_scsi3_nodeacl_depend_item(dest_node_acl)) {\n\t\tpr_err(\"core_scsi3_nodeacl_depend_item() for\"\n\t\t\t\" dest_node_acl\\n\");\n\t\tatomic_dec_mb(&dest_node_acl->acl_pr_ref_count);\n\t\tdest_node_acl = NULL;\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"SPC-3 PR REGISTER_AND_MOVE: Found %s dest_node_acl:\"\n\t\t\" %s from TransportID\\n\", dest_tf_ops->fabric_name,\n\t\tdest_node_acl->initiatorname);\n\n\t \n\tdest_se_deve = core_get_se_deve_from_rtpi(dest_node_acl, rtpi);\n\tif (!dest_se_deve) {\n\t\tpr_err(\"Unable to locate %s dest_se_deve from RTPI:\"\n\t\t\t\" %hu\\n\",  dest_tf_ops->fabric_name, rtpi);\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto out;\n\t}\n\n\tif (core_scsi3_lunacl_depend_item(dest_se_deve)) {\n\t\tpr_err(\"core_scsi3_lunacl_depend_item() failed\\n\");\n\t\tkref_put(&dest_se_deve->pr_kref, target_pr_kref_release);\n\t\tdest_se_deve = NULL;\n\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"SPC-3 PR REGISTER_AND_MOVE: Located %s node %s LUN\"\n\t\t\" ACL for dest_se_deve->mapped_lun: %llu\\n\",\n\t\tdest_tf_ops->fabric_name, dest_node_acl->initiatorname,\n\t\tdest_se_deve->mapped_lun);\n\n\t \n\tspin_lock(&dev->dev_reservation_lock);\n\tpr_res_holder = dev->dev_pr_res_holder;\n\tif (!pr_res_holder) {\n\t\tpr_warn(\"SPC-3 PR REGISTER_AND_MOVE: No reservation\"\n\t\t\t\" currently held\\n\");\n\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\tret = TCM_INVALID_CDB_FIELD;\n\t\tgoto out;\n\t}\n\t \n\tif (!is_reservation_holder(pr_res_holder, pr_reg)) {\n\t\tpr_warn(\"SPC-3 PR REGISTER_AND_MOVE: Calling I_T\"\n\t\t\t\" Nexus is not reservation holder\\n\");\n\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\tret = TCM_RESERVATION_CONFLICT;\n\t\tgoto out;\n\t}\n\t \n\tif ((pr_res_holder->pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG) ||\n\t    (pr_res_holder->pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG)) {\n\t\tpr_warn(\"SPC-3 PR REGISTER_AND_MOVE: Unable to move\"\n\t\t\t\" reservation for type: %s\\n\",\n\t\t\tcore_scsi3_pr_dump_type(pr_res_holder->pr_res_type));\n\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\tret = TCM_RESERVATION_CONFLICT;\n\t\tgoto out;\n\t}\n\tpr_res_nacl = pr_res_holder->pr_reg_nacl;\n\t \n\ttype = pr_res_holder->pr_res_type;\n\tscope = pr_res_holder->pr_res_type;\n\t \n\tdest_pr_reg = __core_scsi3_locate_pr_reg(dev, dest_node_acl,\n\t\t\t\t\tiport_ptr);\n\tif (!dest_pr_reg) {\n\t\tstruct se_lun *dest_lun = dest_se_deve->se_lun;\n\n\t\tspin_unlock(&dev->dev_reservation_lock);\n\t\tif (core_scsi3_alloc_registration(cmd->se_dev, dest_node_acl,\n\t\t\t\t\tdest_lun, dest_se_deve, dest_se_deve->mapped_lun,\n\t\t\t\t\tiport_ptr, sa_res_key, 0, aptpl, 2, 1)) {\n\t\t\tret = TCM_INSUFFICIENT_REGISTRATION_RESOURCES;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_lock(&dev->dev_reservation_lock);\n\t\tdest_pr_reg = __core_scsi3_locate_pr_reg(dev, dest_node_acl,\n\t\t\t\t\t\tiport_ptr);\n\t\tnew_reg = 1;\n\t} else {\n\t\t \n\t\tdest_pr_reg->pr_res_key = sa_res_key;\n\t}\n\t \n\t__core_scsi3_complete_pro_release(dev, pr_res_nacl,\n\t\t\t\t\t  dev->dev_pr_res_holder, 0, 0);\n\t \n\tdev->dev_pr_res_holder = dest_pr_reg;\n\tdest_pr_reg->pr_res_holder = 1;\n\tdest_pr_reg->pr_res_type = type;\n\tpr_reg->pr_res_scope = scope;\n\tcore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\n\t \n\tif (!new_reg)\n\t\tdest_pr_reg->pr_res_generation = pr_tmpl->pr_generation++;\n\tspin_unlock(&dev->dev_reservation_lock);\n\n\tpr_debug(\"SPC-3 PR [%s] Service Action: REGISTER_AND_MOVE\"\n\t\t\" created new reservation holder TYPE: %s on object RTPI:\"\n\t\t\" %hu  PRGeneration: 0x%08x\\n\", dest_tf_ops->fabric_name,\n\t\tcore_scsi3_pr_dump_type(type), rtpi,\n\t\tdest_pr_reg->pr_res_generation);\n\tpr_debug(\"SPC-3 PR Successfully moved reservation from\"\n\t\t\" %s Fabric Node: %s%s -> %s Fabric Node: %s %s\\n\",\n\t\ttf_ops->fabric_name, pr_reg_nacl->initiatorname,\n\t\ti_buf, dest_tf_ops->fabric_name,\n\t\tdest_node_acl->initiatorname, (iport_ptr != NULL) ?\n\t\tiport_ptr : \"\");\n\t \n\tcore_scsi3_lunacl_undepend_item(dest_se_deve);\n\tcore_scsi3_nodeacl_undepend_item(dest_node_acl);\n\tcore_scsi3_tpg_undepend_item(dest_se_tpg);\n\t \n\tif (unreg) {\n\t\tspin_lock(&pr_tmpl->registration_lock);\n\t\t__core_scsi3_free_registration(dev, pr_reg, NULL, 1);\n\t\tspin_unlock(&pr_tmpl->registration_lock);\n\t} else\n\t\tcore_scsi3_put_pr_reg(pr_reg);\n\n\tcore_scsi3_update_and_write_aptpl(cmd->se_dev, aptpl);\n\n\tcore_scsi3_put_pr_reg(dest_pr_reg);\n\treturn 0;\nout:\n\tif (buf)\n\t\ttransport_kunmap_data_sg(cmd);\n\tif (dest_se_deve)\n\t\tcore_scsi3_lunacl_undepend_item(dest_se_deve);\n\tif (dest_node_acl)\n\t\tcore_scsi3_nodeacl_undepend_item(dest_node_acl);\n\tcore_scsi3_tpg_undepend_item(dest_se_tpg);\n\nout_put_pr_reg:\n\tcore_scsi3_put_pr_reg(pr_reg);\n\treturn ret;\n}\n\nstatic sense_reason_t\ntarget_try_pr_out_pt(struct se_cmd *cmd, u8 sa, u64 res_key, u64 sa_res_key,\n\t\t     u8 type, bool aptpl, bool all_tg_pt, bool spec_i_pt)\n{\n\tstruct exec_cmd_ops *ops = cmd->protocol_data;\n\n\tif (!cmd->se_sess || !cmd->se_lun) {\n\t\tpr_err(\"SPC-3 PR: se_sess || struct se_lun is NULL!\\n\");\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\n\tif (!ops->execute_pr_out) {\n\t\tpr_err(\"SPC-3 PR: Device has been configured for PR passthrough but it's not supported by the backend.\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\tswitch (sa) {\n\tcase PRO_REGISTER_AND_MOVE:\n\tcase PRO_REPLACE_LOST_RESERVATION:\n\t\tpr_err(\"SPC-3 PR: PRO_REGISTER_AND_MOVE and PRO_REPLACE_LOST_RESERVATION are not supported by PR passthrough.\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\tif (spec_i_pt || all_tg_pt) {\n\t\tpr_err(\"SPC-3 PR: SPEC_I_PT and ALL_TG_PT are not supported by PR passthrough.\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\treturn ops->execute_pr_out(cmd, sa, res_key, sa_res_key, type, aptpl);\n}\n\n \nsense_reason_t\ntarget_scsi3_emulate_pr_out(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tunsigned char *cdb = &cmd->t_task_cdb[0];\n\tunsigned char *buf;\n\tu64 res_key, sa_res_key;\n\tint sa, scope, type, aptpl;\n\tint spec_i_pt = 0, all_tg_pt = 0, unreg = 0;\n\tsense_reason_t ret;\n\n\t \n\tif (cmd->se_dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS) {\n\t\tpr_err(\"Received PERSISTENT_RESERVE CDB while legacy\"\n\t\t\t\" SPC-2 reservation is held, returning\"\n\t\t\t\" RESERVATION_CONFLICT\\n\");\n\t\treturn TCM_RESERVATION_CONFLICT;\n\t}\n\n\t \n\tif (!cmd->se_sess)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tif (cmd->data_length < 24) {\n\t\tpr_warn(\"SPC-PR: Received PR OUT parameter list\"\n\t\t\t\" length too small: %u\\n\", cmd->data_length);\n\t\treturn TCM_PARAMETER_LIST_LENGTH_ERROR;\n\t}\n\n\t \n\tsa = (cdb[1] & 0x1f);\n\tscope = (cdb[2] & 0xf0);\n\ttype = (cdb[2] & 0x0f);\n\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\t \n\tres_key = get_unaligned_be64(&buf[0]);\n\tsa_res_key = get_unaligned_be64(&buf[8]);\n\t \n\tif (sa != PRO_REGISTER_AND_MOVE) {\n\t\tspec_i_pt = (buf[20] & 0x08);\n\t\tall_tg_pt = (buf[20] & 0x04);\n\t\taptpl = (buf[20] & 0x01);\n\t} else {\n\t\taptpl = (buf[17] & 0x01);\n\t\tunreg = (buf[17] & 0x02);\n\t}\n\t \n\tif (dev->dev_attrib.force_pr_aptpl)\n\t\taptpl = 1;\n\n\ttransport_kunmap_data_sg(cmd);\n\tbuf = NULL;\n\n\t \n\tif (spec_i_pt && (sa != PRO_REGISTER))\n\t\treturn TCM_INVALID_PARAMETER_LIST;\n\n\t \n\tif (!spec_i_pt && (sa != PRO_REGISTER_AND_MOVE) &&\n\t    (cmd->data_length != 24)) {\n\t\tpr_warn(\"SPC-PR: Received PR OUT illegal parameter\"\n\t\t\t\" list length: %u\\n\", cmd->data_length);\n\t\treturn TCM_PARAMETER_LIST_LENGTH_ERROR;\n\t}\n\n\tif (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_PGR) {\n\t\tret = target_try_pr_out_pt(cmd, sa, res_key, sa_res_key, type,\n\t\t\t\t\t   aptpl, all_tg_pt, spec_i_pt);\n\t\tgoto done;\n\t}\n\n\t \n\tswitch (sa) {\n\tcase PRO_REGISTER:\n\t\tret = core_scsi3_emulate_pro_register(cmd,\n\t\t\tres_key, sa_res_key, aptpl, all_tg_pt, spec_i_pt, REGISTER);\n\t\tbreak;\n\tcase PRO_RESERVE:\n\t\tret = core_scsi3_emulate_pro_reserve(cmd, type, scope, res_key);\n\t\tbreak;\n\tcase PRO_RELEASE:\n\t\tret = core_scsi3_emulate_pro_release(cmd, type, scope, res_key);\n\t\tbreak;\n\tcase PRO_CLEAR:\n\t\tret = core_scsi3_emulate_pro_clear(cmd, res_key);\n\t\tbreak;\n\tcase PRO_PREEMPT:\n\t\tret = core_scsi3_emulate_pro_preempt(cmd, type, scope,\n\t\t\t\t\tres_key, sa_res_key, PREEMPT);\n\t\tbreak;\n\tcase PRO_PREEMPT_AND_ABORT:\n\t\tret = core_scsi3_emulate_pro_preempt(cmd, type, scope,\n\t\t\t\t\tres_key, sa_res_key, PREEMPT_AND_ABORT);\n\t\tbreak;\n\tcase PRO_REGISTER_AND_IGNORE_EXISTING_KEY:\n\t\tret = core_scsi3_emulate_pro_register(cmd,\n\t\t\t0, sa_res_key, aptpl, all_tg_pt, spec_i_pt, REGISTER_AND_IGNORE_EXISTING_KEY);\n\t\tbreak;\n\tcase PRO_REGISTER_AND_MOVE:\n\t\tret = core_scsi3_emulate_pro_register_and_move(cmd, res_key,\n\t\t\t\tsa_res_key, aptpl, unreg);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown PERSISTENT_RESERVE_OUT service\"\n\t\t\t\" action: 0x%02x\\n\", sa);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\ndone:\n\tif (!ret)\n\t\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn ret;\n}\n\n \nstatic sense_reason_t\ncore_scsi3_pri_read_keys(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct t10_pr_registration *pr_reg;\n\tunsigned char *buf;\n\tu32 add_len = 0, off = 8;\n\n\tif (cmd->data_length < 8) {\n\t\tpr_err(\"PRIN SA READ_KEYS SCSI Data Length: %u\"\n\t\t\t\" too small\\n\", cmd->data_length);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tput_unaligned_be32(dev->t10_pr.pr_generation, buf);\n\n\tspin_lock(&dev->t10_pr.registration_lock);\n\tlist_for_each_entry(pr_reg, &dev->t10_pr.registration_list,\n\t\t\tpr_reg_list) {\n\t\t \n\t\tif (off + 8 <= cmd->data_length) {\n\t\t\tput_unaligned_be64(pr_reg->pr_res_key, &buf[off]);\n\t\t\toff += 8;\n\t\t}\n\t\t \n\t\tadd_len += 8;\n\t}\n\tspin_unlock(&dev->t10_pr.registration_lock);\n\n\tput_unaligned_be32(add_len, &buf[4]);\n\ttarget_set_cmd_data_length(cmd, 8 + add_len);\n\n\ttransport_kunmap_data_sg(cmd);\n\n\treturn 0;\n}\n\n \nstatic sense_reason_t\ncore_scsi3_pri_read_reservation(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct t10_pr_registration *pr_reg;\n\tunsigned char *buf;\n\tu64 pr_res_key;\n\tu32 add_len = 0;\n\n\tif (cmd->data_length < 8) {\n\t\tpr_err(\"PRIN SA READ_RESERVATIONS SCSI Data Length: %u\"\n\t\t\t\" too small\\n\", cmd->data_length);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tput_unaligned_be32(dev->t10_pr.pr_generation, &buf[0]);\n\n\tspin_lock(&dev->dev_reservation_lock);\n\tpr_reg = dev->dev_pr_res_holder;\n\tif (pr_reg) {\n\t\t \n\t\tadd_len = 16;\n\t\tput_unaligned_be32(add_len, &buf[4]);\n\n\t\tif (cmd->data_length < 22)\n\t\t\tgoto err;\n\n\t\t \n\t\tif ((pr_reg->pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG) ||\n\t\t    (pr_reg->pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG))\n\t\t\tpr_res_key = 0;\n\t\telse\n\t\t\tpr_res_key = pr_reg->pr_res_key;\n\n\t\tput_unaligned_be64(pr_res_key, &buf[8]);\n\t\t \n\t\tbuf[21] = (pr_reg->pr_res_scope & 0xf0) |\n\t\t\t  (pr_reg->pr_res_type & 0x0f);\n\t}\n\n\ttarget_set_cmd_data_length(cmd, 8 + add_len);\n\nerr:\n\tspin_unlock(&dev->dev_reservation_lock);\n\ttransport_kunmap_data_sg(cmd);\n\n\treturn 0;\n}\n\n \nstatic sense_reason_t\ncore_scsi3_pri_report_capabilities(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tunsigned char *buf;\n\tu16 len = 8;  \n\n\tif (cmd->data_length < 6) {\n\t\tpr_err(\"PRIN SA REPORT_CAPABILITIES SCSI Data Length:\"\n\t\t\t\" %u too small\\n\", cmd->data_length);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tput_unaligned_be16(len, &buf[0]);\n\tbuf[2] |= 0x10;  \n\tbuf[2] |= 0x08;  \n\tbuf[2] |= 0x04;  \n\tbuf[2] |= 0x01;  \n\t \n\tbuf[3] |= 0x80;\n\t \n\tbuf[3] |= 0x10;  \n\t \n\tif (pr_tmpl->pr_aptpl_active)\n\t\tbuf[3] |= 0x01;\n\t \n\tbuf[4] |= 0x80;  \n\tbuf[4] |= 0x40;  \n\tbuf[4] |= 0x20;  \n\tbuf[4] |= 0x08;  \n\tbuf[4] |= 0x02;  \n\tbuf[5] |= 0x01;  \n\n\ttarget_set_cmd_data_length(cmd, len);\n\n\ttransport_kunmap_data_sg(cmd);\n\n\treturn 0;\n}\n\n \nstatic sense_reason_t\ncore_scsi3_pri_read_full_status(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_node_acl *se_nacl;\n\tstruct se_portal_group *se_tpg;\n\tstruct t10_pr_registration *pr_reg, *pr_reg_tmp;\n\tstruct t10_reservation *pr_tmpl = &dev->t10_pr;\n\tunsigned char *buf;\n\tu32 add_desc_len = 0, add_len = 0;\n\tu32 off = 8;  \n\tint format_code = 0, pr_res_type = 0, pr_res_scope = 0;\n\tint exp_desc_len, desc_len;\n\tbool all_reg = false;\n\n\tif (cmd->data_length < 8) {\n\t\tpr_err(\"PRIN SA READ_FULL_STATUS SCSI Data Length: %u\"\n\t\t\t\" too small\\n\", cmd->data_length);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tput_unaligned_be32(dev->t10_pr.pr_generation, &buf[0]);\n\n\tspin_lock(&dev->dev_reservation_lock);\n\tif (dev->dev_pr_res_holder) {\n\t\tstruct t10_pr_registration *pr_holder = dev->dev_pr_res_holder;\n\n\t\tif (pr_holder->pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG ||\n\t\t    pr_holder->pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG) {\n\t\t\tall_reg = true;\n\t\t\tpr_res_type = pr_holder->pr_res_type;\n\t\t\tpr_res_scope = pr_holder->pr_res_scope;\n\t\t}\n\t}\n\tspin_unlock(&dev->dev_reservation_lock);\n\n\tspin_lock(&pr_tmpl->registration_lock);\n\tlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\n\t\t\t&pr_tmpl->registration_list, pr_reg_list) {\n\n\t\tse_nacl = pr_reg->pr_reg_nacl;\n\t\tse_tpg = pr_reg->pr_reg_nacl->se_tpg;\n\t\tadd_desc_len = 0;\n\n\t\tatomic_inc_mb(&pr_reg->pr_res_holders);\n\t\tspin_unlock(&pr_tmpl->registration_lock);\n\t\t \n\t\texp_desc_len = target_get_pr_transport_id_len(se_nacl, pr_reg,\n\t\t\t\t\t&format_code);\n\t\tif (exp_desc_len < 0 ||\n\t\t    exp_desc_len + add_len > cmd->data_length) {\n\t\t\tpr_warn(\"SPC-3 PRIN READ_FULL_STATUS ran\"\n\t\t\t\t\" out of buffer: %d\\n\", cmd->data_length);\n\t\t\tspin_lock(&pr_tmpl->registration_lock);\n\t\t\tatomic_dec_mb(&pr_reg->pr_res_holders);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tput_unaligned_be64(pr_reg->pr_res_key, &buf[off]);\n\t\toff += 8;\n\t\toff += 4;  \n\n\t\t \n\t\tif (pr_reg->pr_reg_all_tg_pt)\n\t\t\tbuf[off] = 0x02;\n\t\t \n\t\tif (pr_reg->pr_res_holder) {\n\t\t\tbuf[off++] |= 0x01;\n\t\t\tbuf[off++] = (pr_reg->pr_res_scope & 0xf0) |\n\t\t\t\t     (pr_reg->pr_res_type & 0x0f);\n\t\t} else if (all_reg) {\n\t\t\tbuf[off++] |= 0x01;\n\t\t\tbuf[off++] = (pr_res_scope & 0xf0) |\n\t\t\t\t     (pr_res_type & 0x0f);\n\t\t} else {\n\t\t\toff += 2;\n\t\t}\n\n\t\toff += 4;  \n\t\t \n\t\tif (!pr_reg->pr_reg_all_tg_pt) {\n\t\t\tu16 sep_rtpi = pr_reg->tg_pt_sep_rtpi;\n\n\t\t\tput_unaligned_be16(sep_rtpi, &buf[off]);\n\t\t\toff += 2;\n\t\t} else\n\t\t\toff += 2;  \n\n\t\tbuf[off+4] = se_tpg->proto_id;\n\n\t\t \n\t\tdesc_len = target_get_pr_transport_id(se_nacl, pr_reg,\n\t\t\t\t&format_code, &buf[off+4]);\n\n\t\tspin_lock(&pr_tmpl->registration_lock);\n\t\tatomic_dec_mb(&pr_reg->pr_res_holders);\n\n\t\tif (desc_len < 0)\n\t\t\tbreak;\n\t\t \n\t\tput_unaligned_be32(desc_len, &buf[off]);\n\t\toff += 4;\n\t\t \n\t\tadd_desc_len = (24 + desc_len);\n\n\t\toff += desc_len;\n\t\tadd_len += add_desc_len;\n\t}\n\tspin_unlock(&pr_tmpl->registration_lock);\n\t \n\tput_unaligned_be32(add_len, &buf[4]);\n\ttarget_set_cmd_data_length(cmd, 8 + add_len);\n\n\ttransport_kunmap_data_sg(cmd);\n\n\treturn 0;\n}\n\nstatic sense_reason_t target_try_pr_in_pt(struct se_cmd *cmd, u8 sa)\n{\n\tstruct exec_cmd_ops *ops = cmd->protocol_data;\n\tunsigned char *buf;\n\tsense_reason_t ret;\n\n\tif (cmd->data_length < 8) {\n\t\tpr_err(\"PRIN SA SCSI Data Length: %u too small\\n\",\n\t\t       cmd->data_length);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tif (!ops->execute_pr_in) {\n\t\tpr_err(\"SPC-3 PR: Device has been configured for PR passthrough but it's not supported by the backend.\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\tif (sa == PRI_READ_FULL_STATUS) {\n\t\tpr_err(\"SPC-3 PR: PRI_READ_FULL_STATUS is not supported by PR passthrough.\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tret = ops->execute_pr_in(cmd, sa, buf);\n\n\ttransport_kunmap_data_sg(cmd);\n\treturn ret;\n}\n\nsense_reason_t\ntarget_scsi3_emulate_pr_in(struct se_cmd *cmd)\n{\n\tu8 sa = cmd->t_task_cdb[1] & 0x1f;\n\tsense_reason_t ret;\n\n\t \n\tif (cmd->se_dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS) {\n\t\tpr_err(\"Received PERSISTENT_RESERVE CDB while legacy\"\n\t\t\t\" SPC-2 reservation is held, returning\"\n\t\t\t\" RESERVATION_CONFLICT\\n\");\n\t\treturn TCM_RESERVATION_CONFLICT;\n\t}\n\n\tif (cmd->se_dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_PGR) {\n\t\tret = target_try_pr_in_pt(cmd, sa);\n\t\tgoto done;\n\t}\n\n\tswitch (sa) {\n\tcase PRI_READ_KEYS:\n\t\tret = core_scsi3_pri_read_keys(cmd);\n\t\tbreak;\n\tcase PRI_READ_RESERVATION:\n\t\tret = core_scsi3_pri_read_reservation(cmd);\n\t\tbreak;\n\tcase PRI_REPORT_CAPABILITIES:\n\t\tret = core_scsi3_pri_report_capabilities(cmd);\n\t\tbreak;\n\tcase PRI_READ_FULL_STATUS:\n\t\tret = core_scsi3_pri_read_full_status(cmd);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown PERSISTENT_RESERVE_IN service\"\n\t\t\t\" action: 0x%02x\\n\", cmd->t_task_cdb[1] & 0x1f);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\ndone:\n\tif (!ret)\n\t\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn ret;\n}\n\nsense_reason_t\ntarget_check_reservation(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tsense_reason_t ret;\n\n\tif (!cmd->se_sess)\n\t\treturn 0;\n\tif (dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE)\n\t\treturn 0;\n\tif (!dev->dev_attrib.emulate_pr)\n\t\treturn 0;\n\tif (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_PGR)\n\t\treturn 0;\n\n\tspin_lock(&dev->dev_reservation_lock);\n\tif (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS)\n\t\tret = target_scsi2_reservation_check(cmd);\n\telse\n\t\tret = target_scsi3_pr_reservation_check(cmd);\n\tspin_unlock(&dev->dev_reservation_lock);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}