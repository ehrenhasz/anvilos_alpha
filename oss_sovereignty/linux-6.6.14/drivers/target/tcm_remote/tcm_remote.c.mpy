{
  "module_name": "tcm_remote.c",
  "hash_id": "3777690a80ec4abe4cfc871c2e65070bd1dc576c26255af708000ef8f84358a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/tcm_remote/tcm_remote.c",
  "human_readable_source": "\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/configfs.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include \"tcm_remote.h\"\n\nstatic inline struct tcm_remote_tpg *remote_tpg(struct se_portal_group *se_tpg)\n{\n\treturn container_of(se_tpg, struct tcm_remote_tpg, remote_se_tpg);\n}\n\nstatic char *tcm_remote_get_endpoint_wwn(struct se_portal_group *se_tpg)\n{\n\t \n\treturn &remote_tpg(se_tpg)->remote_hba->remote_wwn_address[0];\n}\n\nstatic u16 tcm_remote_get_tag(struct se_portal_group *se_tpg)\n{\n\t \n\treturn remote_tpg(se_tpg)->remote_tpgt;\n}\n\nstatic int tcm_remote_dummy_cmd_fn(struct se_cmd *se_cmd)\n{\n\treturn 0;\n}\n\nstatic void tcm_remote_dummy_cmd_void_fn(struct se_cmd *se_cmd)\n{\n\n}\n\nstatic char *tcm_remote_dump_proto_id(struct tcm_remote_hba *remote_hba)\n{\n\tswitch (remote_hba->remote_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn \"SAS\";\n\tcase SCSI_PROTOCOL_SRP:\n\t\treturn \"SRP\";\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn \"FCP\";\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn \"iSCSI\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"Unknown\";\n}\n\nstatic int tcm_remote_port_link(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_lun *lun)\n{\n\tpr_debug(\"TCM_Remote_ConfigFS: Port Link LUN %lld Successful\\n\",\n\t\t lun->unpacked_lun);\n\treturn 0;\n}\n\nstatic void tcm_remote_port_unlink(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_lun *lun)\n{\n\tpr_debug(\"TCM_Remote_ConfigFS: Port Unlink LUN %lld Successful\\n\",\n\t\t lun->unpacked_lun);\n}\n\nstatic struct se_portal_group *tcm_remote_make_tpg(\n\tstruct se_wwn *wwn,\n\tconst char *name)\n{\n\tstruct tcm_remote_hba *remote_hba = container_of(wwn,\n\t\t\tstruct tcm_remote_hba, remote_hba_wwn);\n\tstruct tcm_remote_tpg *remote_tpg;\n\tunsigned long tpgt;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name) {\n\t\tpr_err(\"Unable to locate \\\"tpgt_#\\\" directory group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (kstrtoul(name + 5, 10, &tpgt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tpgt >= TL_TPGS_PER_HBA) {\n\t\tpr_err(\"Passed tpgt: %lu exceeds TL_TPGS_PER_HBA: %u\\n\",\n\t\t       tpgt, TL_TPGS_PER_HBA);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tremote_tpg = &remote_hba->remote_hba_tpgs[tpgt];\n\tremote_tpg->remote_hba = remote_hba;\n\tremote_tpg->remote_tpgt = tpgt;\n\t \n\tret = core_tpg_register(wwn, &remote_tpg->remote_se_tpg,\n\t\t\t\tremote_hba->remote_proto_id);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpr_debug(\"TCM_Remote_ConfigFS: Allocated Emulated %s Target Port %s,t,0x%04lx\\n\",\n\t\t tcm_remote_dump_proto_id(remote_hba),\n\t\t config_item_name(&wwn->wwn_group.cg_item), tpgt);\n\treturn &remote_tpg->remote_se_tpg;\n}\n\nstatic void tcm_remote_drop_tpg(struct se_portal_group *se_tpg)\n{\n\tstruct se_wwn *wwn = se_tpg->se_tpg_wwn;\n\tstruct tcm_remote_tpg *remote_tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_remote_tpg, remote_se_tpg);\n\tstruct tcm_remote_hba *remote_hba;\n\tunsigned short tpgt;\n\n\tremote_hba = remote_tpg->remote_hba;\n\ttpgt = remote_tpg->remote_tpgt;\n\n\t \n\tcore_tpg_deregister(se_tpg);\n\n\tremote_tpg->remote_hba = NULL;\n\tremote_tpg->remote_tpgt = 0;\n\n\tpr_debug(\"TCM_Remote_ConfigFS: Deallocated Emulated %s Target Port %s,t,0x%04x\\n\",\n\t\t tcm_remote_dump_proto_id(remote_hba),\n\t\t config_item_name(&wwn->wwn_group.cg_item), tpgt);\n}\n\nstatic struct se_wwn *tcm_remote_make_wwn(\n\tstruct target_fabric_configfs *tf,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_remote_hba *remote_hba;\n\tchar *ptr;\n\tint ret, off = 0;\n\n\tremote_hba = kzalloc(sizeof(*remote_hba), GFP_KERNEL);\n\tif (!remote_hba)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tptr = strstr(name, \"naa.\");\n\tif (ptr) {\n\t\tremote_hba->remote_proto_id = SCSI_PROTOCOL_SAS;\n\t\tgoto check_len;\n\t}\n\tptr = strstr(name, \"fc.\");\n\tif (ptr) {\n\t\tremote_hba->remote_proto_id = SCSI_PROTOCOL_FCP;\n\t\toff = 3;  \n\t\tgoto check_len;\n\t}\n\tptr = strstr(name, \"0x\");\n\tif (ptr) {\n\t\tremote_hba->remote_proto_id = SCSI_PROTOCOL_SRP;\n\t\toff = 2;  \n\t\tgoto check_len;\n\t}\n\tptr = strstr(name, \"iqn.\");\n\tif (!ptr) {\n\t\tpr_err(\"Unable to locate prefix for emulated Target Port: %s\\n\",\n\t\t       name);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tremote_hba->remote_proto_id = SCSI_PROTOCOL_ISCSI;\n\ncheck_len:\n\tif (strlen(name) >= TL_WWN_ADDR_LEN) {\n\t\tpr_err(\"Emulated NAA %s Address: %s, exceeds max: %d\\n\",\n\t\t       name, tcm_remote_dump_proto_id(remote_hba), TL_WWN_ADDR_LEN);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tsnprintf(&remote_hba->remote_wwn_address[0], TL_WWN_ADDR_LEN, \"%s\", &name[off]);\n\n\tpr_debug(\"TCM_Remote_ConfigFS: Allocated emulated Target %s Address: %s\\n\",\n\t\t tcm_remote_dump_proto_id(remote_hba), name);\n\treturn &remote_hba->remote_hba_wwn;\nout:\n\tkfree(remote_hba);\n\treturn ERR_PTR(ret);\n}\n\nstatic void tcm_remote_drop_wwn(struct se_wwn *wwn)\n{\n\tstruct tcm_remote_hba *remote_hba = container_of(wwn,\n\t\t\t\tstruct tcm_remote_hba, remote_hba_wwn);\n\n\tpr_debug(\"TCM_Remote_ConfigFS: Deallocating emulated Target %s Address: %s\\n\",\n\t\t tcm_remote_dump_proto_id(remote_hba),\n\t\t remote_hba->remote_wwn_address);\n\tkfree(remote_hba);\n}\n\nstatic ssize_t tcm_remote_wwn_version_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"TCM Remote Fabric module %s\\n\", TCM_REMOTE_VERSION);\n}\n\nCONFIGFS_ATTR_RO(tcm_remote_wwn_, version);\n\nstatic struct configfs_attribute *tcm_remote_wwn_attrs[] = {\n\t&tcm_remote_wwn_attr_version,\n\tNULL,\n};\n\nstatic const struct target_core_fabric_ops remote_ops = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.fabric_name\t\t\t= \"remote\",\n\t.tpg_get_wwn\t\t\t= tcm_remote_get_endpoint_wwn,\n\t.tpg_get_tag\t\t\t= tcm_remote_get_tag,\n\t.check_stop_free\t\t= tcm_remote_dummy_cmd_fn,\n\t.release_cmd\t\t\t= tcm_remote_dummy_cmd_void_fn,\n\t.write_pending\t\t\t= tcm_remote_dummy_cmd_fn,\n\t.queue_data_in\t\t\t= tcm_remote_dummy_cmd_fn,\n\t.queue_status\t\t\t= tcm_remote_dummy_cmd_fn,\n\t.queue_tm_rsp\t\t\t= tcm_remote_dummy_cmd_void_fn,\n\t.aborted_task\t\t\t= tcm_remote_dummy_cmd_void_fn,\n\t.fabric_make_wwn\t\t= tcm_remote_make_wwn,\n\t.fabric_drop_wwn\t\t= tcm_remote_drop_wwn,\n\t.fabric_make_tpg\t\t= tcm_remote_make_tpg,\n\t.fabric_drop_tpg\t\t= tcm_remote_drop_tpg,\n\t.fabric_post_link\t\t= tcm_remote_port_link,\n\t.fabric_pre_unlink\t\t= tcm_remote_port_unlink,\n\t.tfc_wwn_attrs\t\t\t= tcm_remote_wwn_attrs,\n};\n\nstatic int __init tcm_remote_fabric_init(void)\n{\n\treturn target_register_template(&remote_ops);\n}\n\nstatic void __exit tcm_remote_fabric_exit(void)\n{\n\ttarget_unregister_template(&remote_ops);\n}\n\nMODULE_DESCRIPTION(\"TCM virtual remote target\");\nMODULE_AUTHOR(\"Dmitry Bogdanov <d.bogdanov@yadro.com>\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(tcm_remote_fabric_init);\nmodule_exit(tcm_remote_fabric_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}