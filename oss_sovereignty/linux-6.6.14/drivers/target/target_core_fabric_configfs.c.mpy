{
  "module_name": "target_core_fabric_configfs.c",
  "hash_id": "6852fd40bfb0785a30f02b19c1b1bf2097990c80e4f8b5b4ebc3fb9a99a245f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_fabric_configfs.c",
  "human_readable_source": "\n \n\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/unistd.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n#include <linux/configfs.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n#include <target/target_core_fabric.h>\n\n#include \"target_core_internal.h\"\n#include \"target_core_alua.h\"\n#include \"target_core_pr.h\"\n\n#define TF_CIT_SETUP(_name, _item_ops, _group_ops, _attrs)\t\t\\\nstatic void target_fabric_setup_##_name##_cit(struct target_fabric_configfs *tf) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_item_type *cit = &tf->tf_##_name##_cit;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tcit->ct_item_ops = _item_ops;\t\t\t\t\t\\\n\tcit->ct_group_ops = _group_ops;\t\t\t\t\t\\\n\tcit->ct_attrs = _attrs;\t\t\t\t\t\t\\\n\tcit->ct_owner = tf->tf_ops->module;\t\t\t\t\\\n\tpr_debug(\"Setup generic %s\\n\", __stringify(_name));\t\t\\\n}\n\n#define TF_CIT_SETUP_DRV(_name, _item_ops, _group_ops)\t\t\\\nstatic void target_fabric_setup_##_name##_cit(struct target_fabric_configfs *tf) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_item_type *cit = &tf->tf_##_name##_cit;\t\t\\\n\tstruct configfs_attribute **attrs = tf->tf_ops->tfc_##_name##_attrs; \\\n\t\t\t\t\t\t\t\t\t\\\n\tcit->ct_item_ops = _item_ops;\t\t\t\t\t\\\n\tcit->ct_group_ops = _group_ops;\t\t\t\t\t\\\n\tcit->ct_attrs = attrs;\t\t\t\t\t\t\\\n\tcit->ct_owner = tf->tf_ops->module;\t\t\t\t\\\n\tpr_debug(\"Setup generic %s\\n\", __stringify(_name));\t\t\\\n}\n\nstatic struct configfs_item_operations target_fabric_port_item_ops;\n\n \n\nstatic int target_fabric_mappedlun_link(\n\tstruct config_item *lun_acl_ci,\n\tstruct config_item *lun_ci)\n{\n\tstruct se_dev_entry *deve;\n\tstruct se_lun *lun;\n\tstruct se_lun_acl *lacl = container_of(to_config_group(lun_acl_ci),\n\t\t\tstruct se_lun_acl, se_lun_group);\n\tstruct se_portal_group *se_tpg;\n\tstruct config_item *nacl_ci, *tpg_ci, *tpg_ci_s, *wwn_ci, *wwn_ci_s;\n\tbool lun_access_ro;\n\n\tif (!lun_ci->ci_type ||\n\t    lun_ci->ci_type->ct_item_ops != &target_fabric_port_item_ops) {\n\t\tpr_err(\"Bad lun_ci, not a valid lun_ci pointer: %p\\n\", lun_ci);\n\t\treturn -EFAULT;\n\t}\n\tlun = container_of(to_config_group(lun_ci), struct se_lun, lun_group);\n\n\t \n\tif (!lun->lun_se_dev) {\n\t\tpr_err(\"Source se_lun->lun_se_dev does not exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (lun->lun_shutdown) {\n\t\tpr_err(\"Unable to create mappedlun symlink because\"\n\t\t\t\" lun->lun_shutdown=true\\n\");\n\t\treturn -EINVAL;\n\t}\n\tse_tpg = lun->lun_tpg;\n\n\tnacl_ci = &lun_acl_ci->ci_parent->ci_group->cg_item;\n\ttpg_ci = &nacl_ci->ci_group->cg_item;\n\twwn_ci = &tpg_ci->ci_group->cg_item;\n\ttpg_ci_s = &lun_ci->ci_parent->ci_group->cg_item;\n\twwn_ci_s = &tpg_ci_s->ci_group->cg_item;\n\t \n\tif (strcmp(config_item_name(wwn_ci), config_item_name(wwn_ci_s))) {\n\t\tpr_err(\"Illegal Initiator ACL SymLink outside of %s\\n\",\n\t\t\tconfig_item_name(wwn_ci));\n\t\treturn -EINVAL;\n\t}\n\tif (strcmp(config_item_name(tpg_ci), config_item_name(tpg_ci_s))) {\n\t\tpr_err(\"Illegal Initiator ACL Symlink outside of %s\"\n\t\t\t\" TPGT: %s\\n\", config_item_name(wwn_ci),\n\t\t\tconfig_item_name(tpg_ci));\n\t\treturn -EINVAL;\n\t}\n\t \n\trcu_read_lock();\n\tdeve = target_nacl_find_deve(lacl->se_lun_nacl, lacl->mapped_lun);\n\tif (deve)\n\t\tlun_access_ro = deve->lun_access_ro;\n\telse\n\t\tlun_access_ro =\n\t\t\t(se_tpg->se_tpg_tfo->tpg_check_prod_mode_write_protect(\n\t\t\t\tse_tpg)) ? true : false;\n\trcu_read_unlock();\n\t \n\treturn core_dev_add_initiator_node_lun_acl(se_tpg, lacl, lun, lun_access_ro);\n}\n\nstatic void target_fabric_mappedlun_unlink(\n\tstruct config_item *lun_acl_ci,\n\tstruct config_item *lun_ci)\n{\n\tstruct se_lun_acl *lacl = container_of(to_config_group(lun_acl_ci),\n\t\t\tstruct se_lun_acl, se_lun_group);\n\tstruct se_lun *lun = container_of(to_config_group(lun_ci),\n\t\t\tstruct se_lun, lun_group);\n\n\tcore_dev_del_initiator_node_lun_acl(lun, lacl);\n}\n\nstatic struct se_lun_acl *item_to_lun_acl(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_lun_acl,\n\t\t\tse_lun_group);\n}\n\nstatic ssize_t target_fabric_mappedlun_write_protect_show(\n\t\tstruct config_item *item, char *page)\n{\n\tstruct se_lun_acl *lacl = item_to_lun_acl(item);\n\tstruct se_node_acl *se_nacl = lacl->se_lun_nacl;\n\tstruct se_dev_entry *deve;\n\tssize_t len = 0;\n\n\trcu_read_lock();\n\tdeve = target_nacl_find_deve(se_nacl, lacl->mapped_lun);\n\tif (deve) {\n\t\tlen = sprintf(page, \"%d\\n\", deve->lun_access_ro);\n\t}\n\trcu_read_unlock();\n\n\treturn len;\n}\n\nstatic ssize_t target_fabric_mappedlun_write_protect_store(\n\t\tstruct config_item *item, const char *page, size_t count)\n{\n\tstruct se_lun_acl *lacl = item_to_lun_acl(item);\n\tstruct se_node_acl *se_nacl = lacl->se_lun_nacl;\n\tstruct se_portal_group *se_tpg = se_nacl->se_tpg;\n\tunsigned long wp;\n\tint ret;\n\n\tret = kstrtoul(page, 0, &wp);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((wp != 1) && (wp != 0))\n\t\treturn -EINVAL;\n\n\t \n\tcore_update_device_list_access(lacl->mapped_lun, wp, lacl->se_lun_nacl);\n\n\tpr_debug(\"%s_ConfigFS: Changed Initiator ACL: %s\"\n\t\t\" Mapped LUN: %llu Write Protect bit to %s\\n\",\n\t\tse_tpg->se_tpg_tfo->fabric_name,\n\t\tse_nacl->initiatorname, lacl->mapped_lun, (wp) ? \"ON\" : \"OFF\");\n\n\treturn count;\n\n}\n\nCONFIGFS_ATTR(target_fabric_mappedlun_, write_protect);\n\nstatic struct configfs_attribute *target_fabric_mappedlun_attrs[] = {\n\t&target_fabric_mappedlun_attr_write_protect,\n\tNULL,\n};\n\nstatic void target_fabric_mappedlun_release(struct config_item *item)\n{\n\tstruct se_lun_acl *lacl = container_of(to_config_group(item),\n\t\t\t\tstruct se_lun_acl, se_lun_group);\n\tstruct se_portal_group *se_tpg = lacl->se_lun_nacl->se_tpg;\n\n\tcore_dev_free_initiator_node_lun_acl(se_tpg, lacl);\n}\n\nstatic struct configfs_item_operations target_fabric_mappedlun_item_ops = {\n\t.release\t\t= target_fabric_mappedlun_release,\n\t.allow_link\t\t= target_fabric_mappedlun_link,\n\t.drop_link\t\t= target_fabric_mappedlun_unlink,\n};\n\nTF_CIT_SETUP(tpg_mappedlun, &target_fabric_mappedlun_item_ops, NULL,\n\t\ttarget_fabric_mappedlun_attrs);\n\n \n\n \n\nstatic struct config_group *target_core_mappedlun_stat_mkdir(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\treturn ERR_PTR(-ENOSYS);\n}\n\nstatic void target_core_mappedlun_stat_rmdir(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\treturn;\n}\n\nstatic struct configfs_group_operations target_fabric_mappedlun_stat_group_ops = {\n\t.make_group\t\t= target_core_mappedlun_stat_mkdir,\n\t.drop_item\t\t= target_core_mappedlun_stat_rmdir,\n};\n\nTF_CIT_SETUP(tpg_mappedlun_stat, NULL, &target_fabric_mappedlun_stat_group_ops,\n\t\tNULL);\n\n \n\nTF_CIT_SETUP_DRV(tpg_nacl_attrib, NULL, NULL);\nTF_CIT_SETUP_DRV(tpg_nacl_auth, NULL, NULL);\nTF_CIT_SETUP_DRV(tpg_nacl_param, NULL, NULL);\n\n \n\nstatic struct config_group *target_fabric_make_mappedlun(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct se_node_acl *se_nacl = container_of(group,\n\t\t\tstruct se_node_acl, acl_group);\n\tstruct se_portal_group *se_tpg = se_nacl->se_tpg;\n\tstruct target_fabric_configfs *tf = se_tpg->se_tpg_wwn->wwn_tf;\n\tstruct se_lun_acl *lacl = NULL;\n\tchar *buf;\n\tunsigned long long mapped_lun;\n\tint ret = 0;\n\n\tbuf = kzalloc(strlen(name) + 1, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"Unable to allocate memory for name buf\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tsnprintf(buf, strlen(name) + 1, \"%s\", name);\n\t \n\tif (strstr(buf, \"lun_\") != buf) {\n\t\tpr_err(\"Unable to locate \\\"lun_\\\" from buf: %s\"\n\t\t\t\" name: %s\\n\", buf, name);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tret = kstrtoull(buf + 4, 0, &mapped_lun);\n\tif (ret)\n\t\tgoto out;\n\n\tlacl = core_dev_init_initiator_node_lun_acl(se_tpg, se_nacl,\n\t\t\tmapped_lun, &ret);\n\tif (!lacl) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tconfig_group_init_type_name(&lacl->se_lun_group, name,\n\t\t\t&tf->tf_tpg_mappedlun_cit);\n\n\tconfig_group_init_type_name(&lacl->ml_stat_grps.stat_group,\n\t\t\t\"statistics\", &tf->tf_tpg_mappedlun_stat_cit);\n\tconfigfs_add_default_group(&lacl->ml_stat_grps.stat_group,\n\t\t\t&lacl->se_lun_group);\n\n\ttarget_stat_setup_mappedlun_default_groups(lacl);\n\n\tkfree(buf);\n\treturn &lacl->se_lun_group;\nout:\n\tkfree(lacl);\n\tkfree(buf);\n\treturn ERR_PTR(ret);\n}\n\nstatic void target_fabric_drop_mappedlun(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\tstruct se_lun_acl *lacl = container_of(to_config_group(item),\n\t\t\tstruct se_lun_acl, se_lun_group);\n\n\tconfigfs_remove_default_groups(&lacl->ml_stat_grps.stat_group);\n\tconfigfs_remove_default_groups(&lacl->se_lun_group);\n\n\tconfig_item_put(item);\n}\n\nstatic void target_fabric_nacl_base_release(struct config_item *item)\n{\n\tstruct se_node_acl *se_nacl = container_of(to_config_group(item),\n\t\t\tstruct se_node_acl, acl_group);\n\n\tconfigfs_remove_default_groups(&se_nacl->acl_fabric_stat_group);\n\tcore_tpg_del_initiator_node_acl(se_nacl);\n}\n\nstatic struct configfs_item_operations target_fabric_nacl_base_item_ops = {\n\t.release\t\t= target_fabric_nacl_base_release,\n};\n\nstatic struct configfs_group_operations target_fabric_nacl_base_group_ops = {\n\t.make_group\t\t= target_fabric_make_mappedlun,\n\t.drop_item\t\t= target_fabric_drop_mappedlun,\n};\n\nTF_CIT_SETUP_DRV(tpg_nacl_base, &target_fabric_nacl_base_item_ops,\n\t\t&target_fabric_nacl_base_group_ops);\n\n \n\n \n \nTF_CIT_SETUP(tpg_nacl_stat, NULL, NULL, NULL);\n\n \n\n \n\nstatic struct config_group *target_fabric_make_nodeacl(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct se_portal_group *se_tpg = container_of(group,\n\t\t\tstruct se_portal_group, tpg_acl_group);\n\tstruct target_fabric_configfs *tf = se_tpg->se_tpg_wwn->wwn_tf;\n\tstruct se_node_acl *se_nacl;\n\n\tse_nacl = core_tpg_add_initiator_node_acl(se_tpg, name);\n\tif (IS_ERR(se_nacl))\n\t\treturn ERR_CAST(se_nacl);\n\n\tconfig_group_init_type_name(&se_nacl->acl_group, name,\n\t\t\t&tf->tf_tpg_nacl_base_cit);\n\n\tconfig_group_init_type_name(&se_nacl->acl_attrib_group, \"attrib\",\n\t\t\t&tf->tf_tpg_nacl_attrib_cit);\n\tconfigfs_add_default_group(&se_nacl->acl_attrib_group,\n\t\t\t&se_nacl->acl_group);\n\n\tconfig_group_init_type_name(&se_nacl->acl_auth_group, \"auth\",\n\t\t\t&tf->tf_tpg_nacl_auth_cit);\n\tconfigfs_add_default_group(&se_nacl->acl_auth_group,\n\t\t\t&se_nacl->acl_group);\n\n\tconfig_group_init_type_name(&se_nacl->acl_param_group, \"param\",\n\t\t\t&tf->tf_tpg_nacl_param_cit);\n\tconfigfs_add_default_group(&se_nacl->acl_param_group,\n\t\t\t&se_nacl->acl_group);\n\n\tconfig_group_init_type_name(&se_nacl->acl_fabric_stat_group,\n\t\t\t\"fabric_statistics\", &tf->tf_tpg_nacl_stat_cit);\n\tconfigfs_add_default_group(&se_nacl->acl_fabric_stat_group,\n\t\t\t&se_nacl->acl_group);\n\n\tif (tf->tf_ops->fabric_init_nodeacl) {\n\t\tint ret = tf->tf_ops->fabric_init_nodeacl(se_nacl, name);\n\t\tif (ret) {\n\t\t\tconfigfs_remove_default_groups(&se_nacl->acl_fabric_stat_group);\n\t\t\tcore_tpg_del_initiator_node_acl(se_nacl);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn &se_nacl->acl_group;\n}\n\nstatic void target_fabric_drop_nodeacl(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\tstruct se_node_acl *se_nacl = container_of(to_config_group(item),\n\t\t\tstruct se_node_acl, acl_group);\n\n\tconfigfs_remove_default_groups(&se_nacl->acl_group);\n\n\t \n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations target_fabric_nacl_group_ops = {\n\t.make_group\t= target_fabric_make_nodeacl,\n\t.drop_item\t= target_fabric_drop_nodeacl,\n};\n\nTF_CIT_SETUP(tpg_nacl, NULL, &target_fabric_nacl_group_ops, NULL);\n\n \n\n \n\nstatic void target_fabric_np_base_release(struct config_item *item)\n{\n\tstruct se_tpg_np *se_tpg_np = container_of(to_config_group(item),\n\t\t\t\tstruct se_tpg_np, tpg_np_group);\n\tstruct se_portal_group *se_tpg = se_tpg_np->tpg_np_parent;\n\tstruct target_fabric_configfs *tf = se_tpg->se_tpg_wwn->wwn_tf;\n\n\ttf->tf_ops->fabric_drop_np(se_tpg_np);\n}\n\nstatic struct configfs_item_operations target_fabric_np_base_item_ops = {\n\t.release\t\t= target_fabric_np_base_release,\n};\n\nTF_CIT_SETUP_DRV(tpg_np_base, &target_fabric_np_base_item_ops, NULL);\n\n \n\n \n\nstatic struct config_group *target_fabric_make_np(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct se_portal_group *se_tpg = container_of(group,\n\t\t\t\tstruct se_portal_group, tpg_np_group);\n\tstruct target_fabric_configfs *tf = se_tpg->se_tpg_wwn->wwn_tf;\n\tstruct se_tpg_np *se_tpg_np;\n\n\tif (!tf->tf_ops->fabric_make_np) {\n\t\tpr_err(\"tf->tf_ops.fabric_make_np is NULL\\n\");\n\t\treturn ERR_PTR(-ENOSYS);\n\t}\n\n\tse_tpg_np = tf->tf_ops->fabric_make_np(se_tpg, group, name);\n\tif (!se_tpg_np || IS_ERR(se_tpg_np))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tse_tpg_np->tpg_np_parent = se_tpg;\n\tconfig_group_init_type_name(&se_tpg_np->tpg_np_group, name,\n\t\t\t&tf->tf_tpg_np_base_cit);\n\n\treturn &se_tpg_np->tpg_np_group;\n}\n\nstatic void target_fabric_drop_np(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\t \n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations target_fabric_np_group_ops = {\n\t.make_group\t= &target_fabric_make_np,\n\t.drop_item\t= &target_fabric_drop_np,\n};\n\nTF_CIT_SETUP(tpg_np, NULL, &target_fabric_np_group_ops, NULL);\n\n \n\n \n\nstatic struct se_lun *item_to_lun(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct se_lun,\n\t\t\tlun_group);\n}\n\nstatic ssize_t target_fabric_port_alua_tg_pt_gp_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct se_lun *lun = item_to_lun(item);\n\n\tif (!lun->lun_se_dev)\n\t\treturn -ENODEV;\n\n\treturn core_alua_show_tg_pt_gp_info(lun, page);\n}\n\nstatic ssize_t target_fabric_port_alua_tg_pt_gp_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_lun *lun = item_to_lun(item);\n\n\tif (!lun->lun_se_dev)\n\t\treturn -ENODEV;\n\n\treturn core_alua_store_tg_pt_gp_info(lun, page, count);\n}\n\nstatic ssize_t target_fabric_port_alua_tg_pt_offline_show(\n\t\tstruct config_item *item, char *page)\n{\n\tstruct se_lun *lun = item_to_lun(item);\n\n\tif (!lun->lun_se_dev)\n\t\treturn -ENODEV;\n\n\treturn core_alua_show_offline_bit(lun, page);\n}\n\nstatic ssize_t target_fabric_port_alua_tg_pt_offline_store(\n\t\tstruct config_item *item, const char *page, size_t count)\n{\n\tstruct se_lun *lun = item_to_lun(item);\n\n\tif (!lun->lun_se_dev)\n\t\treturn -ENODEV;\n\n\treturn core_alua_store_offline_bit(lun, page, count);\n}\n\nstatic ssize_t target_fabric_port_alua_tg_pt_status_show(\n\t\tstruct config_item *item, char *page)\n{\n\tstruct se_lun *lun = item_to_lun(item);\n\n\tif (!lun->lun_se_dev)\n\t\treturn -ENODEV;\n\n\treturn core_alua_show_secondary_status(lun, page);\n}\n\nstatic ssize_t target_fabric_port_alua_tg_pt_status_store(\n\t\tstruct config_item *item, const char *page, size_t count)\n{\n\tstruct se_lun *lun = item_to_lun(item);\n\n\tif (!lun->lun_se_dev)\n\t\treturn -ENODEV;\n\n\treturn core_alua_store_secondary_status(lun, page, count);\n}\n\nstatic ssize_t target_fabric_port_alua_tg_pt_write_md_show(\n\t\tstruct config_item *item, char *page)\n{\n\tstruct se_lun *lun = item_to_lun(item);\n\n\tif (!lun->lun_se_dev)\n\t\treturn -ENODEV;\n\n\treturn core_alua_show_secondary_write_metadata(lun, page);\n}\n\nstatic ssize_t target_fabric_port_alua_tg_pt_write_md_store(\n\t\tstruct config_item *item, const char *page, size_t count)\n{\n\tstruct se_lun *lun = item_to_lun(item);\n\n\tif (!lun->lun_se_dev)\n\t\treturn -ENODEV;\n\n\treturn core_alua_store_secondary_write_metadata(lun, page, count);\n}\n\nCONFIGFS_ATTR(target_fabric_port_, alua_tg_pt_gp);\nCONFIGFS_ATTR(target_fabric_port_, alua_tg_pt_offline);\nCONFIGFS_ATTR(target_fabric_port_, alua_tg_pt_status);\nCONFIGFS_ATTR(target_fabric_port_, alua_tg_pt_write_md);\n\nstatic struct configfs_attribute *target_fabric_port_attrs[] = {\n\t&target_fabric_port_attr_alua_tg_pt_gp,\n\t&target_fabric_port_attr_alua_tg_pt_offline,\n\t&target_fabric_port_attr_alua_tg_pt_status,\n\t&target_fabric_port_attr_alua_tg_pt_write_md,\n\tNULL,\n};\n\nstatic int target_fabric_port_link(\n\tstruct config_item *lun_ci,\n\tstruct config_item *se_dev_ci)\n{\n\tstruct config_item *tpg_ci;\n\tstruct se_lun *lun = container_of(to_config_group(lun_ci),\n\t\t\t\tstruct se_lun, lun_group);\n\tstruct se_portal_group *se_tpg;\n\tstruct se_device *dev;\n\tstruct target_fabric_configfs *tf;\n\tint ret;\n\n\tif (!se_dev_ci->ci_type ||\n\t    se_dev_ci->ci_type->ct_item_ops != &target_core_dev_item_ops) {\n\t\tpr_err(\"Bad se_dev_ci, not a valid se_dev_ci pointer: %p\\n\", se_dev_ci);\n\t\treturn -EFAULT;\n\t}\n\tdev = container_of(to_config_group(se_dev_ci), struct se_device, dev_group);\n\n\tif (!target_dev_configured(dev)) {\n\t\tpr_err(\"se_device not configured yet, cannot port link\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttpg_ci = &lun_ci->ci_parent->ci_group->cg_item;\n\tse_tpg = container_of(to_config_group(tpg_ci),\n\t\t\t\tstruct se_portal_group, tpg_group);\n\ttf = se_tpg->se_tpg_wwn->wwn_tf;\n\n\tif (lun->lun_se_dev !=  NULL) {\n\t\tpr_err(\"Port Symlink already exists\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\tret = core_dev_add_lun(se_tpg, dev, lun);\n\tif (ret) {\n\t\tpr_err(\"core_dev_add_lun() failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (tf->tf_ops->fabric_post_link) {\n\t\t \n\t\ttf->tf_ops->fabric_post_link(se_tpg, lun);\n\t}\n\n\treturn 0;\nout:\n\treturn ret;\n}\n\nstatic void target_fabric_port_unlink(\n\tstruct config_item *lun_ci,\n\tstruct config_item *se_dev_ci)\n{\n\tstruct se_lun *lun = container_of(to_config_group(lun_ci),\n\t\t\t\tstruct se_lun, lun_group);\n\tstruct se_portal_group *se_tpg = lun->lun_tpg;\n\tstruct target_fabric_configfs *tf = se_tpg->se_tpg_wwn->wwn_tf;\n\n\tif (tf->tf_ops->fabric_pre_unlink) {\n\t\t \n\t\ttf->tf_ops->fabric_pre_unlink(se_tpg, lun);\n\t}\n\n\tcore_dev_del_lun(se_tpg, lun);\n}\n\nstatic void target_fabric_port_release(struct config_item *item)\n{\n\tstruct se_lun *lun = container_of(to_config_group(item),\n\t\t\t\t\t  struct se_lun, lun_group);\n\n\tkfree_rcu(lun, rcu_head);\n}\n\nstatic struct configfs_item_operations target_fabric_port_item_ops = {\n\t.release\t\t= target_fabric_port_release,\n\t.allow_link\t\t= target_fabric_port_link,\n\t.drop_link\t\t= target_fabric_port_unlink,\n};\n\nTF_CIT_SETUP(tpg_port, &target_fabric_port_item_ops, NULL, target_fabric_port_attrs);\n\n \n\n \n\nstatic struct config_group *target_core_port_stat_mkdir(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\treturn ERR_PTR(-ENOSYS);\n}\n\nstatic void target_core_port_stat_rmdir(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\treturn;\n}\n\nstatic struct configfs_group_operations target_fabric_port_stat_group_ops = {\n\t.make_group\t\t= target_core_port_stat_mkdir,\n\t.drop_item\t\t= target_core_port_stat_rmdir,\n};\n\nTF_CIT_SETUP(tpg_port_stat, NULL, &target_fabric_port_stat_group_ops, NULL);\n\n \n\n \n\nstatic struct config_group *target_fabric_make_lun(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct se_lun *lun;\n\tstruct se_portal_group *se_tpg = container_of(group,\n\t\t\tstruct se_portal_group, tpg_lun_group);\n\tstruct target_fabric_configfs *tf = se_tpg->se_tpg_wwn->wwn_tf;\n\tunsigned long long unpacked_lun;\n\tint errno;\n\n\tif (strstr(name, \"lun_\") != name) {\n\t\tpr_err(\"Unable to locate \\'_\\\" in\"\n\t\t\t\t\" \\\"lun_$LUN_NUMBER\\\"\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\terrno = kstrtoull(name + 4, 0, &unpacked_lun);\n\tif (errno)\n\t\treturn ERR_PTR(errno);\n\n\tlun = core_tpg_alloc_lun(se_tpg, unpacked_lun);\n\tif (IS_ERR(lun))\n\t\treturn ERR_CAST(lun);\n\n\tconfig_group_init_type_name(&lun->lun_group, name,\n\t\t\t&tf->tf_tpg_port_cit);\n\n\tconfig_group_init_type_name(&lun->port_stat_grps.stat_group,\n\t\t\t\"statistics\", &tf->tf_tpg_port_stat_cit);\n\tconfigfs_add_default_group(&lun->port_stat_grps.stat_group,\n\t\t\t&lun->lun_group);\n\n\ttarget_stat_setup_port_default_groups(lun);\n\n\treturn &lun->lun_group;\n}\n\nstatic void target_fabric_drop_lun(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\tstruct se_lun *lun = container_of(to_config_group(item),\n\t\t\t\tstruct se_lun, lun_group);\n\n\tconfigfs_remove_default_groups(&lun->port_stat_grps.stat_group);\n\tconfigfs_remove_default_groups(&lun->lun_group);\n\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations target_fabric_lun_group_ops = {\n\t.make_group\t= &target_fabric_make_lun,\n\t.drop_item\t= &target_fabric_drop_lun,\n};\n\nTF_CIT_SETUP(tpg_lun, NULL, &target_fabric_lun_group_ops, NULL);\n\n \n\nTF_CIT_SETUP_DRV(tpg_attrib, NULL, NULL);\nTF_CIT_SETUP_DRV(tpg_auth, NULL, NULL);\nTF_CIT_SETUP_DRV(tpg_param, NULL, NULL);\n\n \n\nstatic void target_fabric_tpg_release(struct config_item *item)\n{\n\tstruct se_portal_group *se_tpg = container_of(to_config_group(item),\n\t\t\tstruct se_portal_group, tpg_group);\n\tstruct se_wwn *wwn = se_tpg->se_tpg_wwn;\n\tstruct target_fabric_configfs *tf = wwn->wwn_tf;\n\n\ttf->tf_ops->fabric_drop_tpg(se_tpg);\n}\n\nstatic struct configfs_item_operations target_fabric_tpg_base_item_ops = {\n\t.release\t\t= target_fabric_tpg_release,\n};\n\nstatic ssize_t target_fabric_tpg_base_enable_show(struct config_item *item,\n\t\t\t\t\t\t  char *page)\n{\n\treturn sysfs_emit(page, \"%d\\n\", to_tpg(item)->enabled);\n}\n\nstatic ssize_t target_fabric_tpg_base_enable_store(struct config_item *item,\n\t\t\t\t\t\t   const char *page,\n\t\t\t\t\t\t   size_t count)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tint ret;\n\tbool op;\n\n\tret = kstrtobool(page, &op);\n\tif (ret)\n\t\treturn ret;\n\n\tif (se_tpg->enabled == op)\n\t\treturn count;\n\tif (op)\n\t\tret = target_tpg_enable(se_tpg);\n\telse\n\t\tret = target_tpg_disable(se_tpg);\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\nstatic ssize_t target_fabric_tpg_base_rtpi_show(struct config_item *item, char *page)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\n\treturn sysfs_emit(page, \"%#x\\n\", se_tpg->tpg_rtpi);\n}\n\nstatic ssize_t target_fabric_tpg_base_rtpi_store(struct config_item *item,\n\t\t\t\t   const char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tu16 val;\n\tint ret;\n\n\tret = kstrtou16(page, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (val == 0)\n\t\treturn -EINVAL;\n\n\tif (se_tpg->enabled) {\n\t\tpr_info(\"%s_TPG[%hu] - Can not change RTPI on enabled TPG\",\n\t\t\tse_tpg->se_tpg_tfo->fabric_name,\n\t\t\tse_tpg->se_tpg_tfo->tpg_get_tag(se_tpg));\n\t\treturn -EINVAL;\n\t}\n\n\tse_tpg->tpg_rtpi = val;\n\tse_tpg->rtpi_manual = true;\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(target_fabric_tpg_base_, enable);\nCONFIGFS_ATTR(target_fabric_tpg_base_, rtpi);\n\nstatic int\ntarget_fabric_setup_tpg_base_cit(struct target_fabric_configfs *tf)\n{\n\tstruct config_item_type *cit = &tf->tf_tpg_base_cit;\n\tstruct configfs_attribute **attrs = NULL;\n\tsize_t nr_attrs = 0;\n\tint i = 0;\n\n\tif (tf->tf_ops->tfc_tpg_base_attrs)\n\t\twhile (tf->tf_ops->tfc_tpg_base_attrs[nr_attrs] != NULL)\n\t\t\tnr_attrs++;\n\n\tif (tf->tf_ops->fabric_enable_tpg)\n\t\tnr_attrs++;\n\n\t \n\tnr_attrs++;\n\n\t \n\tattrs = kcalloc(nr_attrs + 1, sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn -ENOMEM;\n\n\tif (tf->tf_ops->tfc_tpg_base_attrs)\n\t\tfor (; tf->tf_ops->tfc_tpg_base_attrs[i] != NULL; i++)\n\t\t\tattrs[i] = tf->tf_ops->tfc_tpg_base_attrs[i];\n\n\tif (tf->tf_ops->fabric_enable_tpg)\n\t\tattrs[i++] = &target_fabric_tpg_base_attr_enable;\n\n\tattrs[i++] = &target_fabric_tpg_base_attr_rtpi;\n\n\tcit->ct_item_ops = &target_fabric_tpg_base_item_ops;\n\tcit->ct_attrs = attrs;\n\tcit->ct_owner = tf->tf_ops->module;\n\tpr_debug(\"Setup generic tpg_base\\n\");\n\n\treturn 0;\n}\n \n\n \n\nstatic struct config_group *target_fabric_make_tpg(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct se_wwn *wwn = container_of(group, struct se_wwn, wwn_group);\n\tstruct target_fabric_configfs *tf = wwn->wwn_tf;\n\tstruct se_portal_group *se_tpg;\n\n\tif (!tf->tf_ops->fabric_make_tpg) {\n\t\tpr_err(\"tf->tf_ops->fabric_make_tpg is NULL\\n\");\n\t\treturn ERR_PTR(-ENOSYS);\n\t}\n\n\tse_tpg = tf->tf_ops->fabric_make_tpg(wwn, name);\n\tif (!se_tpg || IS_ERR(se_tpg))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tconfig_group_init_type_name(&se_tpg->tpg_group, name,\n\t\t\t&tf->tf_tpg_base_cit);\n\n\tconfig_group_init_type_name(&se_tpg->tpg_lun_group, \"lun\",\n\t\t\t&tf->tf_tpg_lun_cit);\n\tconfigfs_add_default_group(&se_tpg->tpg_lun_group,\n\t\t\t&se_tpg->tpg_group);\n\n\tconfig_group_init_type_name(&se_tpg->tpg_np_group, \"np\",\n\t\t\t&tf->tf_tpg_np_cit);\n\tconfigfs_add_default_group(&se_tpg->tpg_np_group,\n\t\t\t&se_tpg->tpg_group);\n\n\tconfig_group_init_type_name(&se_tpg->tpg_acl_group, \"acls\",\n\t\t\t&tf->tf_tpg_nacl_cit);\n\tconfigfs_add_default_group(&se_tpg->tpg_acl_group,\n\t\t\t&se_tpg->tpg_group);\n\n\tconfig_group_init_type_name(&se_tpg->tpg_attrib_group, \"attrib\",\n\t\t\t&tf->tf_tpg_attrib_cit);\n\tconfigfs_add_default_group(&se_tpg->tpg_attrib_group,\n\t\t\t&se_tpg->tpg_group);\n\n\tconfig_group_init_type_name(&se_tpg->tpg_auth_group, \"auth\",\n\t\t\t&tf->tf_tpg_auth_cit);\n\tconfigfs_add_default_group(&se_tpg->tpg_auth_group,\n\t\t\t&se_tpg->tpg_group);\n\n\tconfig_group_init_type_name(&se_tpg->tpg_param_group, \"param\",\n\t\t\t&tf->tf_tpg_param_cit);\n\tconfigfs_add_default_group(&se_tpg->tpg_param_group,\n\t\t\t&se_tpg->tpg_group);\n\n\treturn &se_tpg->tpg_group;\n}\n\nstatic void target_fabric_drop_tpg(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\tstruct se_portal_group *se_tpg = container_of(to_config_group(item),\n\t\t\t\tstruct se_portal_group, tpg_group);\n\n\tconfigfs_remove_default_groups(&se_tpg->tpg_group);\n\tconfig_item_put(item);\n}\n\nstatic void target_fabric_release_wwn(struct config_item *item)\n{\n\tstruct se_wwn *wwn = container_of(to_config_group(item),\n\t\t\t\tstruct se_wwn, wwn_group);\n\tstruct target_fabric_configfs *tf = wwn->wwn_tf;\n\n\tconfigfs_remove_default_groups(&wwn->fabric_stat_group);\n\tconfigfs_remove_default_groups(&wwn->param_group);\n\ttf->tf_ops->fabric_drop_wwn(wwn);\n}\n\nstatic struct configfs_item_operations target_fabric_tpg_item_ops = {\n\t.release\t= target_fabric_release_wwn,\n};\n\nstatic struct configfs_group_operations target_fabric_tpg_group_ops = {\n\t.make_group\t= target_fabric_make_tpg,\n\t.drop_item\t= target_fabric_drop_tpg,\n};\n\nTF_CIT_SETUP(tpg, &target_fabric_tpg_item_ops, &target_fabric_tpg_group_ops,\n\t\tNULL);\n\n \n\n \n \nTF_CIT_SETUP(wwn_fabric_stats, NULL, NULL, NULL);\n\n \n\nstatic ssize_t\ntarget_fabric_wwn_cmd_completion_affinity_show(struct config_item *item,\n\t\t\t\t\t       char *page)\n{\n\tstruct se_wwn *wwn = container_of(to_config_group(item), struct se_wwn,\n\t\t\t\t\t  param_group);\n\treturn sprintf(page, \"%d\\n\",\n\t\t       wwn->cmd_compl_affinity == WORK_CPU_UNBOUND ?\n\t\t       SE_COMPL_AFFINITY_CURR_CPU : wwn->cmd_compl_affinity);\n}\n\nstatic ssize_t\ntarget_fabric_wwn_cmd_completion_affinity_store(struct config_item *item,\n\t\t\t\t\t\tconst char *page, size_t count)\n{\n\tstruct se_wwn *wwn = container_of(to_config_group(item), struct se_wwn,\n\t\t\t\t\t  param_group);\n\tint compl_val;\n\n\tif (kstrtoint(page, 0, &compl_val))\n\t\treturn -EINVAL;\n\n\tswitch (compl_val) {\n\tcase SE_COMPL_AFFINITY_CPUID:\n\t\twwn->cmd_compl_affinity = compl_val;\n\t\tbreak;\n\tcase SE_COMPL_AFFINITY_CURR_CPU:\n\t\twwn->cmd_compl_affinity = WORK_CPU_UNBOUND;\n\t\tbreak;\n\tdefault:\n\t\tif (compl_val < 0 || compl_val >= nr_cpu_ids ||\n\t\t    !cpu_online(compl_val)) {\n\t\t\tpr_err(\"Command completion value must be between %d and %d or an online CPU.\\n\",\n\t\t\t       SE_COMPL_AFFINITY_CPUID,\n\t\t\t       SE_COMPL_AFFINITY_CURR_CPU);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\twwn->cmd_compl_affinity = compl_val;\n\t}\n\n\treturn count;\n}\nCONFIGFS_ATTR(target_fabric_wwn_, cmd_completion_affinity);\n\nstatic struct configfs_attribute *target_fabric_wwn_param_attrs[] = {\n\t&target_fabric_wwn_attr_cmd_completion_affinity,\n\tNULL,\n};\n\nTF_CIT_SETUP(wwn_param, NULL, NULL, target_fabric_wwn_param_attrs);\n\n \n\nstatic struct config_group *target_fabric_make_wwn(\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct target_fabric_configfs *tf = container_of(group,\n\t\t\t\tstruct target_fabric_configfs, tf_group);\n\tstruct se_wwn *wwn;\n\n\tif (!tf->tf_ops->fabric_make_wwn) {\n\t\tpr_err(\"tf->tf_ops.fabric_make_wwn is NULL\\n\");\n\t\treturn ERR_PTR(-ENOSYS);\n\t}\n\n\twwn = tf->tf_ops->fabric_make_wwn(tf, group, name);\n\tif (!wwn || IS_ERR(wwn))\n\t\treturn ERR_PTR(-EINVAL);\n\n\twwn->cmd_compl_affinity = SE_COMPL_AFFINITY_CPUID;\n\twwn->wwn_tf = tf;\n\n\tconfig_group_init_type_name(&wwn->wwn_group, name, &tf->tf_tpg_cit);\n\n\tconfig_group_init_type_name(&wwn->fabric_stat_group, \"fabric_statistics\",\n\t\t\t&tf->tf_wwn_fabric_stats_cit);\n\tconfigfs_add_default_group(&wwn->fabric_stat_group, &wwn->wwn_group);\n\n\tconfig_group_init_type_name(&wwn->param_group, \"param\",\n\t\t\t&tf->tf_wwn_param_cit);\n\tconfigfs_add_default_group(&wwn->param_group, &wwn->wwn_group);\n\n\tif (tf->tf_ops->add_wwn_groups)\n\t\ttf->tf_ops->add_wwn_groups(wwn);\n\treturn &wwn->wwn_group;\n}\n\nstatic void target_fabric_drop_wwn(\n\tstruct config_group *group,\n\tstruct config_item *item)\n{\n\tstruct se_wwn *wwn = container_of(to_config_group(item),\n\t\t\t\tstruct se_wwn, wwn_group);\n\n\tconfigfs_remove_default_groups(&wwn->wwn_group);\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations target_fabric_wwn_group_ops = {\n\t.make_group\t= target_fabric_make_wwn,\n\t.drop_item\t= target_fabric_drop_wwn,\n};\n\nTF_CIT_SETUP_DRV(wwn, NULL, &target_fabric_wwn_group_ops);\nTF_CIT_SETUP_DRV(discovery, NULL, NULL);\n\nint target_fabric_setup_cits(struct target_fabric_configfs *tf)\n{\n\tint ret;\n\n\ttarget_fabric_setup_discovery_cit(tf);\n\ttarget_fabric_setup_wwn_cit(tf);\n\ttarget_fabric_setup_wwn_fabric_stats_cit(tf);\n\ttarget_fabric_setup_wwn_param_cit(tf);\n\ttarget_fabric_setup_tpg_cit(tf);\n\n\tret = target_fabric_setup_tpg_base_cit(tf);\n\tif (ret)\n\t\treturn ret;\n\n\ttarget_fabric_setup_tpg_port_cit(tf);\n\ttarget_fabric_setup_tpg_port_stat_cit(tf);\n\ttarget_fabric_setup_tpg_lun_cit(tf);\n\ttarget_fabric_setup_tpg_np_cit(tf);\n\ttarget_fabric_setup_tpg_np_base_cit(tf);\n\ttarget_fabric_setup_tpg_attrib_cit(tf);\n\ttarget_fabric_setup_tpg_auth_cit(tf);\n\ttarget_fabric_setup_tpg_param_cit(tf);\n\ttarget_fabric_setup_tpg_nacl_cit(tf);\n\ttarget_fabric_setup_tpg_nacl_base_cit(tf);\n\ttarget_fabric_setup_tpg_nacl_attrib_cit(tf);\n\ttarget_fabric_setup_tpg_nacl_auth_cit(tf);\n\ttarget_fabric_setup_tpg_nacl_param_cit(tf);\n\ttarget_fabric_setup_tpg_nacl_stat_cit(tf);\n\ttarget_fabric_setup_tpg_mappedlun_cit(tf);\n\ttarget_fabric_setup_tpg_mappedlun_stat_cit(tf);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}