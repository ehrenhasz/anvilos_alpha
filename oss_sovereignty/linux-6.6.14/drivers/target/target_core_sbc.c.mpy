{
  "module_name": "target_core_sbc.c",
  "hash_id": "401ed7630e1fe54d33407b5876bc2799ddf156a642d9276495333b02fd6d10fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_sbc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/ratelimit.h>\n#include <linux/crc-t10dif.h>\n#include <linux/t10-pi.h>\n#include <asm/unaligned.h>\n#include <scsi/scsi_proto.h>\n#include <scsi/scsi_tcq.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n#include <target/target_core_fabric.h>\n\n#include \"target_core_internal.h\"\n#include \"target_core_ua.h\"\n#include \"target_core_alua.h\"\n\nstatic sense_reason_t\nsbc_check_prot(struct se_device *, struct se_cmd *, unsigned char, u32, bool);\nstatic sense_reason_t sbc_execute_unmap(struct se_cmd *cmd);\n\nstatic sense_reason_t\nsbc_emulate_readcapacity(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tunsigned char *cdb = cmd->t_task_cdb;\n\tunsigned long long blocks_long = dev->transport->get_blocks(dev);\n\tunsigned char *rbuf;\n\tunsigned char buf[8];\n\tu32 blocks;\n\n\t \n\tif (!(cdb[8] & 1) && !!(cdb[2] | cdb[3] | cdb[4] | cdb[5]))\n\t\treturn TCM_INVALID_CDB_FIELD;\n\n\tif (blocks_long >= 0x00000000ffffffff)\n\t\tblocks = 0xffffffff;\n\telse\n\t\tblocks = (u32)blocks_long;\n\n\tput_unaligned_be32(blocks, &buf[0]);\n\tput_unaligned_be32(dev->dev_attrib.block_size, &buf[4]);\n\n\trbuf = transport_kmap_data_sg(cmd);\n\tif (rbuf) {\n\t\tmemcpy(rbuf, buf, min_t(u32, sizeof(buf), cmd->data_length));\n\t\ttransport_kunmap_data_sg(cmd);\n\t}\n\n\ttarget_complete_cmd_with_length(cmd, SAM_STAT_GOOD, 8);\n\treturn 0;\n}\n\nstatic sense_reason_t\nsbc_emulate_readcapacity_16(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_session *sess = cmd->se_sess;\n\tint pi_prot_type = dev->dev_attrib.pi_prot_type;\n\n\tunsigned char *rbuf;\n\tunsigned char buf[32];\n\tunsigned long long blocks = dev->transport->get_blocks(dev);\n\n\tmemset(buf, 0, sizeof(buf));\n\tput_unaligned_be64(blocks, &buf[0]);\n\tput_unaligned_be32(dev->dev_attrib.block_size, &buf[8]);\n\t \n\tif (sess->sup_prot_ops & (TARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS)) {\n\t\t \n\t\tif (!pi_prot_type)\n\t\t\tpi_prot_type = sess->sess_prot_type;\n\n\t\tif (pi_prot_type)\n\t\t\tbuf[12] = (pi_prot_type - 1) << 1 | 0x1;\n\t}\n\n\tif (dev->transport->get_lbppbe)\n\t\tbuf[13] = dev->transport->get_lbppbe(dev) & 0x0f;\n\n\tif (dev->transport->get_alignment_offset_lbas) {\n\t\tu16 lalba = dev->transport->get_alignment_offset_lbas(dev);\n\n\t\tput_unaligned_be16(lalba, &buf[14]);\n\t}\n\n\t \n\tif (dev->dev_attrib.emulate_tpu || dev->dev_attrib.emulate_tpws) {\n\t\tbuf[14] |= 0x80;\n\n\t\t \n\t\tif (dev->dev_attrib.unmap_zeroes_data)\n\t\t\tbuf[14] |= 0x40;\n\t}\n\n\trbuf = transport_kmap_data_sg(cmd);\n\tif (rbuf) {\n\t\tmemcpy(rbuf, buf, min_t(u32, sizeof(buf), cmd->data_length));\n\t\ttransport_kunmap_data_sg(cmd);\n\t}\n\n\ttarget_complete_cmd_with_length(cmd, SAM_STAT_GOOD, 32);\n\treturn 0;\n}\n\nstatic sense_reason_t\nsbc_emulate_startstop(struct se_cmd *cmd)\n{\n\tunsigned char *cdb = cmd->t_task_cdb;\n\n\t \n\tif (!(cdb[1] & 1) || cdb[2] || cdb[3])\n\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t \n\tif (cdb[4] >> 4 & 0xf)\n\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t \n\tif (!(cdb[4] & 1) || (cdb[4] & 2) || (cdb[4] & 4))\n\t\treturn TCM_INVALID_CDB_FIELD;\n\n\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn 0;\n}\n\nsector_t sbc_get_write_same_sectors(struct se_cmd *cmd)\n{\n\tu32 num_blocks;\n\n\tif (cmd->t_task_cdb[0] == WRITE_SAME)\n\t\tnum_blocks = get_unaligned_be16(&cmd->t_task_cdb[7]);\n\telse if (cmd->t_task_cdb[0] == WRITE_SAME_16)\n\t\tnum_blocks = get_unaligned_be32(&cmd->t_task_cdb[10]);\n\telse  \n\t\tnum_blocks = get_unaligned_be32(&cmd->t_task_cdb[28]);\n\n\t \n\tif (num_blocks)\n\t\treturn num_blocks;\n\n\treturn cmd->se_dev->transport->get_blocks(cmd->se_dev) -\n\t\tcmd->t_task_lba + 1;\n}\nEXPORT_SYMBOL(sbc_get_write_same_sectors);\n\nstatic sense_reason_t\nsbc_execute_write_same_unmap(struct se_cmd *cmd)\n{\n\tstruct exec_cmd_ops *ops = cmd->protocol_data;\n\tsector_t nolb = sbc_get_write_same_sectors(cmd);\n\tsense_reason_t ret;\n\n\tif (nolb) {\n\t\tret = ops->execute_unmap(cmd, cmd->t_task_lba, nolb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn 0;\n}\n\nstatic sense_reason_t\nsbc_emulate_noop(struct se_cmd *cmd)\n{\n\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn 0;\n}\n\nstatic inline u32 sbc_get_size(struct se_cmd *cmd, u32 sectors)\n{\n\treturn cmd->se_dev->dev_attrib.block_size * sectors;\n}\n\nstatic inline u32 transport_get_sectors_6(unsigned char *cdb)\n{\n\t \n\treturn cdb[4] ? : 256;\n}\n\nstatic inline u32 transport_get_sectors_10(unsigned char *cdb)\n{\n\treturn get_unaligned_be16(&cdb[7]);\n}\n\nstatic inline u32 transport_get_sectors_12(unsigned char *cdb)\n{\n\treturn get_unaligned_be32(&cdb[6]);\n}\n\nstatic inline u32 transport_get_sectors_16(unsigned char *cdb)\n{\n\treturn get_unaligned_be32(&cdb[10]);\n}\n\n \nstatic inline u32 transport_get_sectors_32(unsigned char *cdb)\n{\n\treturn get_unaligned_be32(&cdb[28]);\n\n}\n\nstatic inline u32 transport_lba_21(unsigned char *cdb)\n{\n\treturn get_unaligned_be24(&cdb[1]) & 0x1fffff;\n}\n\nstatic inline u32 transport_lba_32(unsigned char *cdb)\n{\n\treturn get_unaligned_be32(&cdb[2]);\n}\n\nstatic inline unsigned long long transport_lba_64(unsigned char *cdb)\n{\n\treturn get_unaligned_be64(&cdb[2]);\n}\n\nstatic sense_reason_t\nsbc_setup_write_same(struct se_cmd *cmd, unsigned char flags,\n\t\t     struct exec_cmd_ops *ops)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tsector_t end_lba = dev->transport->get_blocks(dev) + 1;\n\tunsigned int sectors = sbc_get_write_same_sectors(cmd);\n\tsense_reason_t ret;\n\n\tif ((flags & 0x04) || (flags & 0x02)) {\n\t\tpr_err(\"WRITE_SAME PBDATA and LBDATA\"\n\t\t\t\" bits not supported for Block Discard\"\n\t\t\t\" Emulation\\n\");\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\tif (sectors > cmd->se_dev->dev_attrib.max_write_same_len) {\n\t\tpr_warn(\"WRITE_SAME sectors: %u exceeds max_write_same_len: %u\\n\",\n\t\t\tsectors, cmd->se_dev->dev_attrib.max_write_same_len);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\t \n\tif (((cmd->t_task_lba + sectors) < cmd->t_task_lba) ||\n\t    ((cmd->t_task_lba + sectors) > end_lba)) {\n\t\tpr_err(\"WRITE_SAME exceeds last lba %llu (lba %llu, sectors %u)\\n\",\n\t\t       (unsigned long long)end_lba, cmd->t_task_lba, sectors);\n\t\treturn TCM_ADDRESS_OUT_OF_RANGE;\n\t}\n\n\t \n\tif (flags & 0x10) {\n\t\tpr_warn(\"WRITE SAME with ANCHOR not supported\\n\");\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tif (flags & 0x01) {\n\t\tpr_warn(\"WRITE SAME with NDOB not supported\\n\");\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\t \n\tif (flags & 0x08) {\n\t\tif (!ops->execute_unmap)\n\t\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\n\t\tif (!dev->dev_attrib.emulate_tpws) {\n\t\t\tpr_err(\"Got WRITE_SAME w/ UNMAP=1, but backend device\"\n\t\t\t       \" has emulate_tpws disabled\\n\");\n\t\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t\t}\n\t\tcmd->execute_cmd = sbc_execute_write_same_unmap;\n\t\treturn 0;\n\t}\n\tif (!ops->execute_write_same)\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\n\tret = sbc_check_prot(dev, cmd, flags >> 5, sectors, true);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd->execute_cmd = ops->execute_write_same;\n\treturn 0;\n}\n\nstatic sense_reason_t\nsbc_execute_rw(struct se_cmd *cmd)\n{\n\tstruct exec_cmd_ops *ops = cmd->protocol_data;\n\n\treturn ops->execute_rw(cmd, cmd->t_data_sg, cmd->t_data_nents,\n\t\t\t       cmd->data_direction);\n}\n\nstatic sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success,\n\t\t\t\t\t     int *post_ret)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tsense_reason_t ret = TCM_NO_SENSE;\n\n\tspin_lock_irq(&cmd->t_state_lock);\n\tif (success) {\n\t\t*post_ret = 1;\n\n\t\tif (cmd->scsi_status == SAM_STAT_CHECK_CONDITION)\n\t\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\tspin_unlock_irq(&cmd->t_state_lock);\n\n\t \n\tup(&dev->caw_sem);\n\n\treturn ret;\n}\n\n \nstatic sense_reason_t\ncompare_and_write_do_cmp(struct scatterlist *read_sgl, unsigned int read_nents,\n\t\t\t struct scatterlist *cmp_sgl, unsigned int cmp_nents,\n\t\t\t unsigned int cmp_len, unsigned int *miscmp_off)\n{\n\tunsigned char *buf = NULL;\n\tstruct scatterlist *sg;\n\tsense_reason_t ret;\n\tunsigned int offset;\n\tsize_t rc;\n\tint sg_cnt;\n\n\tbuf = kzalloc(cmp_len, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = TCM_OUT_OF_RESOURCES;\n\t\tgoto out;\n\t}\n\n\trc = sg_copy_to_buffer(cmp_sgl, cmp_nents, buf, cmp_len);\n\tif (!rc) {\n\t\tpr_err(\"sg_copy_to_buffer() failed for compare_and_write\\n\");\n\t\tret = TCM_OUT_OF_RESOURCES;\n\t\tgoto out;\n\t}\n\t \n\toffset = 0;\n\tret = TCM_NO_SENSE;\n\tfor_each_sg(read_sgl, sg, read_nents, sg_cnt) {\n\t\tunsigned int len = min(sg->length, cmp_len);\n\t\tunsigned char *addr = kmap_atomic(sg_page(sg));\n\n\t\tif (memcmp(addr, buf + offset, len)) {\n\t\t\tunsigned int i;\n\n\t\t\tfor (i = 0; i < len && addr[i] == buf[offset + i]; i++)\n\t\t\t\t;\n\t\t\t*miscmp_off = offset + i;\n\t\t\tpr_warn(\"Detected MISCOMPARE at offset %u\\n\",\n\t\t\t\t*miscmp_off);\n\t\t\tret = TCM_MISCOMPARE_VERIFY;\n\t\t}\n\t\tkunmap_atomic(addr);\n\t\tif (ret != TCM_NO_SENSE)\n\t\t\tgoto out;\n\n\t\toffset += len;\n\t\tcmp_len -= len;\n\t\tif (!cmp_len)\n\t\t\tbreak;\n\t}\n\tpr_debug(\"COMPARE AND WRITE read data matches compare data\\n\");\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success,\n\t\t\t\t\t\t int *post_ret)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct sg_table write_tbl = { };\n\tstruct scatterlist *write_sg;\n\tstruct sg_mapping_iter m;\n\tunsigned int len;\n\tunsigned int block_size = dev->dev_attrib.block_size;\n\tunsigned int compare_len = (cmd->t_task_nolb * block_size);\n\tunsigned int miscmp_off = 0;\n\tsense_reason_t ret = TCM_NO_SENSE;\n\tint i;\n\n\tif (!success) {\n\t\t \n\t\tif (!cmd->t_data_sg || !cmd->t_bidi_data_sg)\n\t\t\treturn TCM_NO_SENSE;\n\n\t\t \n\t\tWARN_ON(!(cmd->transport_state &\n\t\t\t(CMD_T_ABORTED | CMD_T_STOP)));\n\t\tgoto out;\n\t}\n\t \n\tif (!cmd->data_length)\n\t\tgoto out;\n\t \n\tif (cmd->scsi_status) {\n\t\tpr_debug(\"compare_and_write_callback: non zero scsi_status:\"\n\t\t\t\" 0x%02x\\n\", cmd->scsi_status);\n\t\t*post_ret = 1;\n\t\tif (cmd->scsi_status == SAM_STAT_CHECK_CONDITION)\n\t\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\tgoto out;\n\t}\n\n\tret = compare_and_write_do_cmp(cmd->t_bidi_data_sg,\n\t\t\t\t       cmd->t_bidi_data_nents,\n\t\t\t\t       cmd->t_data_sg,\n\t\t\t\t       cmd->t_data_nents,\n\t\t\t\t       compare_len,\n\t\t\t\t       &miscmp_off);\n\tif (ret == TCM_MISCOMPARE_VERIFY) {\n\t\t \n\t\tcmd->sense_info = miscmp_off;\n\t\tgoto out;\n\t} else if (ret)\n\t\tgoto out;\n\n\tif (sg_alloc_table(&write_tbl, cmd->t_data_nents, GFP_KERNEL) < 0) {\n\t\tpr_err(\"Unable to allocate compare_and_write sg\\n\");\n\t\tret = TCM_OUT_OF_RESOURCES;\n\t\tgoto out;\n\t}\n\twrite_sg = write_tbl.sgl;\n\n\ti = 0;\n\tlen = compare_len;\n\tsg_miter_start(&m, cmd->t_data_sg, cmd->t_data_nents, SG_MITER_TO_SG);\n\t \n\twhile (len) {\n\t\tsg_miter_next(&m);\n\n\t\tif (block_size < PAGE_SIZE) {\n\t\t\tsg_set_page(&write_sg[i], m.page, block_size,\n\t\t\t\t    m.piter.sg->offset + block_size);\n\t\t} else {\n\t\t\tsg_miter_next(&m);\n\t\t\tsg_set_page(&write_sg[i], m.page, block_size,\n\t\t\t\t    m.piter.sg->offset);\n\t\t}\n\t\tlen -= block_size;\n\t\ti++;\n\t}\n\tsg_miter_stop(&m);\n\t \n\tcmd->t_data_sg_orig = cmd->t_data_sg;\n\tcmd->t_data_sg = write_sg;\n\tcmd->t_data_nents_orig = cmd->t_data_nents;\n\tcmd->t_data_nents = 1;\n\n\tcmd->sam_task_attr = TCM_HEAD_TAG;\n\tcmd->transport_complete_callback = compare_and_write_post;\n\t \n\tcmd->execute_cmd = sbc_execute_rw;\n\n\tspin_lock_irq(&cmd->t_state_lock);\n\tcmd->t_state = TRANSPORT_PROCESSING;\n\tcmd->transport_state |= CMD_T_ACTIVE | CMD_T_SENT;\n\tspin_unlock_irq(&cmd->t_state_lock);\n\n\t__target_execute_cmd(cmd, false);\n\n\treturn ret;\n\nout:\n\t \n\tup(&dev->caw_sem);\n\tsg_free_table(&write_tbl);\n\treturn ret;\n}\n\nstatic sense_reason_t\nsbc_compare_and_write(struct se_cmd *cmd)\n{\n\tstruct exec_cmd_ops *ops = cmd->protocol_data;\n\tstruct se_device *dev = cmd->se_dev;\n\tsense_reason_t ret;\n\tint rc;\n\t \n\trc = down_interruptible(&dev->caw_sem);\n\tif (rc != 0) {\n\t\tcmd->transport_complete_callback = NULL;\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\t \n\tcmd->data_length = cmd->t_task_nolb * dev->dev_attrib.block_size;\n\n\tret = ops->execute_rw(cmd, cmd->t_bidi_data_sg, cmd->t_bidi_data_nents,\n\t\t\t      DMA_FROM_DEVICE);\n\tif (ret) {\n\t\tcmd->transport_complete_callback = NULL;\n\t\tup(&dev->caw_sem);\n\t\treturn ret;\n\t}\n\t \n\treturn TCM_NO_SENSE;\n}\n\nstatic int\nsbc_set_prot_op_checks(u8 protect, bool fabric_prot, enum target_prot_type prot_type,\n\t\t       bool is_write, struct se_cmd *cmd)\n{\n\tif (is_write) {\n\t\tcmd->prot_op = fabric_prot ? TARGET_PROT_DOUT_STRIP :\n\t\t\t       protect ? TARGET_PROT_DOUT_PASS :\n\t\t\t       TARGET_PROT_DOUT_INSERT;\n\t\tswitch (protect) {\n\t\tcase 0x0:\n\t\tcase 0x3:\n\t\t\tcmd->prot_checks = 0;\n\t\t\tbreak;\n\t\tcase 0x1:\n\t\tcase 0x5:\n\t\t\tcmd->prot_checks = TARGET_DIF_CHECK_GUARD;\n\t\t\tif (prot_type == TARGET_DIF_TYPE1_PROT)\n\t\t\t\tcmd->prot_checks |= TARGET_DIF_CHECK_REFTAG;\n\t\t\tbreak;\n\t\tcase 0x2:\n\t\t\tif (prot_type == TARGET_DIF_TYPE1_PROT)\n\t\t\t\tcmd->prot_checks = TARGET_DIF_CHECK_REFTAG;\n\t\t\tbreak;\n\t\tcase 0x4:\n\t\t\tcmd->prot_checks = TARGET_DIF_CHECK_GUARD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unsupported protect field %d\\n\", protect);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tcmd->prot_op = fabric_prot ? TARGET_PROT_DIN_INSERT :\n\t\t\t       protect ? TARGET_PROT_DIN_PASS :\n\t\t\t       TARGET_PROT_DIN_STRIP;\n\t\tswitch (protect) {\n\t\tcase 0x0:\n\t\tcase 0x1:\n\t\tcase 0x5:\n\t\t\tcmd->prot_checks = TARGET_DIF_CHECK_GUARD;\n\t\t\tif (prot_type == TARGET_DIF_TYPE1_PROT)\n\t\t\t\tcmd->prot_checks |= TARGET_DIF_CHECK_REFTAG;\n\t\t\tbreak;\n\t\tcase 0x2:\n\t\t\tif (prot_type == TARGET_DIF_TYPE1_PROT)\n\t\t\t\tcmd->prot_checks = TARGET_DIF_CHECK_REFTAG;\n\t\t\tbreak;\n\t\tcase 0x3:\n\t\t\tcmd->prot_checks = 0;\n\t\t\tbreak;\n\t\tcase 0x4:\n\t\t\tcmd->prot_checks = TARGET_DIF_CHECK_GUARD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unsupported protect field %d\\n\", protect);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic sense_reason_t\nsbc_check_prot(struct se_device *dev, struct se_cmd *cmd, unsigned char protect,\n\t       u32 sectors, bool is_write)\n{\n\tint sp_ops = cmd->se_sess->sup_prot_ops;\n\tint pi_prot_type = dev->dev_attrib.pi_prot_type;\n\tbool fabric_prot = false;\n\n\tif (!cmd->t_prot_sg || !cmd->t_prot_nents) {\n\t\tif (unlikely(protect &&\n\t\t    !dev->dev_attrib.pi_prot_type && !cmd->se_sess->sess_prot_type)) {\n\t\t\tpr_err(\"CDB contains protect bit, but device + fabric does\"\n\t\t\t       \" not advertise PROTECT=1 feature bit\\n\");\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t}\n\t\tif (cmd->prot_pto)\n\t\t\treturn TCM_NO_SENSE;\n\t}\n\n\tswitch (dev->dev_attrib.pi_prot_type) {\n\tcase TARGET_DIF_TYPE3_PROT:\n\t\tcmd->reftag_seed = 0xffffffff;\n\t\tbreak;\n\tcase TARGET_DIF_TYPE2_PROT:\n\t\tif (protect)\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tcmd->reftag_seed = cmd->t_task_lba;\n\t\tbreak;\n\tcase TARGET_DIF_TYPE1_PROT:\n\t\tcmd->reftag_seed = cmd->t_task_lba;\n\t\tbreak;\n\tcase TARGET_DIF_TYPE0_PROT:\n\t\t \n\t\tfabric_prot = is_write ?\n\t\t\t      !!(sp_ops & (TARGET_PROT_DOUT_PASS | TARGET_PROT_DOUT_STRIP)) :\n\t\t\t      !!(sp_ops & (TARGET_PROT_DIN_PASS | TARGET_PROT_DIN_INSERT));\n\n\t\tif (fabric_prot && cmd->se_sess->sess_prot_type) {\n\t\t\tpi_prot_type = cmd->se_sess->sess_prot_type;\n\t\t\tbreak;\n\t\t}\n\t\tif (!protect)\n\t\t\treturn TCM_NO_SENSE;\n\t\tfallthrough;\n\tdefault:\n\t\tpr_err(\"Unable to determine pi_prot_type for CDB: 0x%02x \"\n\t\t       \"PROTECT: 0x%02x\\n\", cmd->t_task_cdb[0], protect);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tif (sbc_set_prot_op_checks(protect, fabric_prot, pi_prot_type, is_write, cmd))\n\t\treturn TCM_INVALID_CDB_FIELD;\n\n\tcmd->prot_type = pi_prot_type;\n\tcmd->prot_length = dev->prot_length * sectors;\n\n\t \n\tif (protect)\n\t\tcmd->data_length = sectors * dev->dev_attrib.block_size;\n\n\tpr_debug(\"%s: prot_type=%d, data_length=%d, prot_length=%d \"\n\t\t \"prot_op=%d prot_checks=%d\\n\",\n\t\t __func__, cmd->prot_type, cmd->data_length, cmd->prot_length,\n\t\t cmd->prot_op, cmd->prot_checks);\n\n\treturn TCM_NO_SENSE;\n}\n\nstatic int\nsbc_check_dpofua(struct se_device *dev, struct se_cmd *cmd, unsigned char *cdb)\n{\n\tif (cdb[1] & 0x10) {\n\t\t \n\t\tif (!target_check_fua(dev)) {\n\t\t\tpr_err(\"Got CDB: 0x%02x with DPO bit set, but device\"\n\t\t\t       \" does not advertise support for DPO\\n\", cdb[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (cdb[1] & 0x8) {\n\t\tif (!target_check_fua(dev)) {\n\t\t\tpr_err(\"Got CDB: 0x%02x with FUA bit set, but device\"\n\t\t\t       \" does not advertise support for FUA write\\n\",\n\t\t\t       cdb[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcmd->se_cmd_flags |= SCF_FUA;\n\t}\n\treturn 0;\n}\n\nsense_reason_t\nsbc_parse_cdb(struct se_cmd *cmd, struct exec_cmd_ops *ops)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tunsigned char *cdb = cmd->t_task_cdb;\n\tunsigned int size;\n\tu32 sectors = 0;\n\tsense_reason_t ret;\n\n\tcmd->protocol_data = ops;\n\n\tswitch (cdb[0]) {\n\tcase READ_6:\n\t\tsectors = transport_get_sectors_6(cdb);\n\t\tcmd->t_task_lba = transport_lba_21(cdb);\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase READ_10:\n\t\tsectors = transport_get_sectors_10(cdb);\n\t\tcmd->t_task_lba = transport_lba_32(cdb);\n\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tret = sbc_check_prot(dev, cmd, cdb[1] >> 5, sectors, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase READ_12:\n\t\tsectors = transport_get_sectors_12(cdb);\n\t\tcmd->t_task_lba = transport_lba_32(cdb);\n\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tret = sbc_check_prot(dev, cmd, cdb[1] >> 5, sectors, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase READ_16:\n\t\tsectors = transport_get_sectors_16(cdb);\n\t\tcmd->t_task_lba = transport_lba_64(cdb);\n\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tret = sbc_check_prot(dev, cmd, cdb[1] >> 5, sectors, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase WRITE_6:\n\t\tsectors = transport_get_sectors_6(cdb);\n\t\tcmd->t_task_lba = transport_lba_21(cdb);\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase WRITE_10:\n\tcase WRITE_VERIFY:\n\t\tsectors = transport_get_sectors_10(cdb);\n\t\tcmd->t_task_lba = transport_lba_32(cdb);\n\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tret = sbc_check_prot(dev, cmd, cdb[1] >> 5, sectors, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase WRITE_12:\n\t\tsectors = transport_get_sectors_12(cdb);\n\t\tcmd->t_task_lba = transport_lba_32(cdb);\n\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tret = sbc_check_prot(dev, cmd, cdb[1] >> 5, sectors, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase WRITE_16:\n\tcase WRITE_VERIFY_16:\n\t\tsectors = transport_get_sectors_16(cdb);\n\t\tcmd->t_task_lba = transport_lba_64(cdb);\n\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\tret = sbc_check_prot(dev, cmd, cdb[1] >> 5, sectors, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;\n\t\tcmd->execute_cmd = sbc_execute_rw;\n\t\tbreak;\n\tcase VARIABLE_LENGTH_CMD:\n\t{\n\t\tu16 service_action = get_unaligned_be16(&cdb[8]);\n\t\tswitch (service_action) {\n\t\tcase WRITE_SAME_32:\n\t\t\tsectors = transport_get_sectors_32(cdb);\n\t\t\tif (!sectors) {\n\t\t\t\tpr_err(\"WSNZ=1, WRITE_SAME w/sectors=0 not\"\n\t\t\t\t       \" supported\\n\");\n\t\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t\t}\n\n\t\t\tsize = sbc_get_size(cmd, 1);\n\t\t\tcmd->t_task_lba = get_unaligned_be64(&cdb[12]);\n\n\t\t\tret = sbc_setup_write_same(cmd, cdb[10], ops);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"VARIABLE_LENGTH_CMD service action\"\n\t\t\t\t\" 0x%04x not supported\\n\", service_action);\n\t\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t\t}\n\t\tbreak;\n\t}\n\tcase COMPARE_AND_WRITE:\n\t\tif (!dev->dev_attrib.emulate_caw) {\n\t\t\tpr_err_ratelimited(\"se_device %s/%s (vpd_unit_serial %s) reject COMPARE_AND_WRITE\\n\",\n\t\t\t\t\t   dev->se_hba->backend->ops->name,\n\t\t\t\t\t   config_item_name(&dev->dev_group.cg_item),\n\t\t\t\t\t   dev->t10_wwn.unit_serial);\n\t\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t\t}\n\t\tsectors = cdb[13];\n\t\t \n\t\tif (sectors > 1) {\n\t\t\tpr_err(\"COMPARE_AND_WRITE contains NoLB: %u greater\"\n\t\t\t       \" than 1\\n\", sectors);\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t}\n\t\tif (sbc_check_dpofua(dev, cmd, cdb))\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\n\t\t \n\t\tsize = 2 * sbc_get_size(cmd, sectors);\n\t\tcmd->t_task_lba = get_unaligned_be64(&cdb[2]);\n\t\tcmd->t_task_nolb = sectors;\n\t\tcmd->se_cmd_flags |= SCF_SCSI_DATA_CDB | SCF_COMPARE_AND_WRITE;\n\t\tcmd->execute_cmd = sbc_compare_and_write;\n\t\tcmd->transport_complete_callback = compare_and_write_callback;\n\t\tbreak;\n\tcase READ_CAPACITY:\n\t\tsize = READ_CAP_LEN;\n\t\tcmd->execute_cmd = sbc_emulate_readcapacity;\n\t\tbreak;\n\tcase SERVICE_ACTION_IN_16:\n\t\tswitch (cmd->t_task_cdb[1] & 0x1f) {\n\t\tcase SAI_READ_CAPACITY_16:\n\t\t\tcmd->execute_cmd = sbc_emulate_readcapacity_16;\n\t\t\tbreak;\n\t\tcase SAI_REPORT_REFERRALS:\n\t\t\tcmd->execute_cmd = target_emulate_report_referrals;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unsupported SA: 0x%02x\\n\",\n\t\t\t\tcmd->t_task_cdb[1] & 0x1f);\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t}\n\t\tsize = get_unaligned_be32(&cdb[10]);\n\t\tbreak;\n\tcase SYNCHRONIZE_CACHE:\n\tcase SYNCHRONIZE_CACHE_16:\n\t\tif (cdb[0] == SYNCHRONIZE_CACHE) {\n\t\t\tsectors = transport_get_sectors_10(cdb);\n\t\t\tcmd->t_task_lba = transport_lba_32(cdb);\n\t\t} else {\n\t\t\tsectors = transport_get_sectors_16(cdb);\n\t\t\tcmd->t_task_lba = transport_lba_64(cdb);\n\t\t}\n\t\tif (ops->execute_sync_cache) {\n\t\t\tcmd->execute_cmd = ops->execute_sync_cache;\n\t\t\tgoto check_lba;\n\t\t}\n\t\tsize = 0;\n\t\tcmd->execute_cmd = sbc_emulate_noop;\n\t\tbreak;\n\tcase UNMAP:\n\t\tif (!ops->execute_unmap)\n\t\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\n\t\tif (!dev->dev_attrib.emulate_tpu) {\n\t\t\tpr_err(\"Got UNMAP, but backend device has\"\n\t\t\t       \" emulate_tpu disabled\\n\");\n\t\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t\t}\n\t\tsize = get_unaligned_be16(&cdb[7]);\n\t\tcmd->execute_cmd = sbc_execute_unmap;\n\t\tbreak;\n\tcase WRITE_SAME_16:\n\t\tsectors = transport_get_sectors_16(cdb);\n\t\tif (!sectors) {\n\t\t\tpr_err(\"WSNZ=1, WRITE_SAME w/sectors=0 not supported\\n\");\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t}\n\n\t\tsize = sbc_get_size(cmd, 1);\n\t\tcmd->t_task_lba = get_unaligned_be64(&cdb[2]);\n\n\t\tret = sbc_setup_write_same(cmd, cdb[1], ops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase WRITE_SAME:\n\t\tsectors = transport_get_sectors_10(cdb);\n\t\tif (!sectors) {\n\t\t\tpr_err(\"WSNZ=1, WRITE_SAME w/sectors=0 not supported\\n\");\n\t\t\treturn TCM_INVALID_CDB_FIELD;\n\t\t}\n\n\t\tsize = sbc_get_size(cmd, 1);\n\t\tcmd->t_task_lba = get_unaligned_be32(&cdb[2]);\n\n\t\t \n\t\tret = sbc_setup_write_same(cmd, cdb[1], ops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase VERIFY:\n\tcase VERIFY_16:\n\t\tsize = 0;\n\t\tif (cdb[0] == VERIFY) {\n\t\t\tsectors = transport_get_sectors_10(cdb);\n\t\t\tcmd->t_task_lba = transport_lba_32(cdb);\n\t\t} else {\n\t\t\tsectors = transport_get_sectors_16(cdb);\n\t\t\tcmd->t_task_lba = transport_lba_64(cdb);\n\t\t}\n\t\tcmd->execute_cmd = sbc_emulate_noop;\n\t\tgoto check_lba;\n\tcase REZERO_UNIT:\n\tcase SEEK_6:\n\tcase SEEK_10:\n\t\t \n\t\tsize = 0;\n\t\tcmd->execute_cmd = sbc_emulate_noop;\n\t\tbreak;\n\tcase START_STOP:\n\t\tsize = 0;\n\t\tcmd->execute_cmd = sbc_emulate_startstop;\n\t\tbreak;\n\tdefault:\n\t\tret = spc_parse_cdb(cmd, &size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (!cmd->execute_cmd)\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\n\tif (cmd->se_cmd_flags & SCF_SCSI_DATA_CDB) {\n\t\tunsigned long long end_lba;\ncheck_lba:\n\t\tend_lba = dev->transport->get_blocks(dev) + 1;\n\t\tif (((cmd->t_task_lba + sectors) < cmd->t_task_lba) ||\n\t\t    ((cmd->t_task_lba + sectors) > end_lba)) {\n\t\t\tpr_err(\"cmd exceeds last lba %llu \"\n\t\t\t\t\"(lba %llu, sectors %u)\\n\",\n\t\t\t\tend_lba, cmd->t_task_lba, sectors);\n\t\t\treturn TCM_ADDRESS_OUT_OF_RANGE;\n\t\t}\n\n\t\tif (!(cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE))\n\t\t\tsize = sbc_get_size(cmd, sectors);\n\t}\n\n\treturn target_cmd_size_check(cmd, size);\n}\nEXPORT_SYMBOL(sbc_parse_cdb);\n\nu32 sbc_get_device_type(struct se_device *dev)\n{\n\treturn TYPE_DISK;\n}\nEXPORT_SYMBOL(sbc_get_device_type);\n\nstatic sense_reason_t\nsbc_execute_unmap(struct se_cmd *cmd)\n{\n\tstruct exec_cmd_ops *ops = cmd->protocol_data;\n\tstruct se_device *dev = cmd->se_dev;\n\tunsigned char *buf, *ptr = NULL;\n\tsector_t lba;\n\tint size;\n\tu32 range;\n\tsense_reason_t ret = 0;\n\tint dl, bd_dl;\n\n\t \n\tif (cmd->t_task_cdb[1])\n\t\treturn TCM_INVALID_CDB_FIELD;\n\n\tif (cmd->data_length == 0) {\n\t\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\t\treturn 0;\n\t}\n\n\tif (cmd->data_length < 8) {\n\t\tpr_warn(\"UNMAP parameter list length %u too small\\n\",\n\t\t\tcmd->data_length);\n\t\treturn TCM_PARAMETER_LIST_LENGTH_ERROR;\n\t}\n\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tdl = get_unaligned_be16(&buf[0]);\n\tbd_dl = get_unaligned_be16(&buf[2]);\n\n\tsize = cmd->data_length - 8;\n\tif (bd_dl > size)\n\t\tpr_warn(\"UNMAP parameter list length %u too small, ignoring bd_dl %u\\n\",\n\t\t\tcmd->data_length, bd_dl);\n\telse\n\t\tsize = bd_dl;\n\n\tif (size / 16 > dev->dev_attrib.max_unmap_block_desc_count) {\n\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\tgoto err;\n\t}\n\n\t \n\tptr = &buf[8];\n\tpr_debug(\"UNMAP: Sub: %s Using dl: %u bd_dl: %u size: %u\"\n\t\t\" ptr: %p\\n\", dev->transport->name, dl, bd_dl, size, ptr);\n\n\twhile (size >= 16) {\n\t\tlba = get_unaligned_be64(&ptr[0]);\n\t\trange = get_unaligned_be32(&ptr[8]);\n\t\tpr_debug(\"UNMAP: Using lba: %llu and range: %u\\n\",\n\t\t\t\t (unsigned long long)lba, range);\n\n\t\tif (range > dev->dev_attrib.max_unmap_lba_count) {\n\t\t\tret = TCM_INVALID_PARAMETER_LIST;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (lba + range > dev->transport->get_blocks(dev) + 1) {\n\t\t\tret = TCM_ADDRESS_OUT_OF_RANGE;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (range) {\n\t\t\tret = ops->execute_unmap(cmd, lba, range);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tptr += 16;\n\t\tsize -= 16;\n\t}\n\nerr:\n\ttransport_kunmap_data_sg(cmd);\n\tif (!ret)\n\t\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn ret;\n}\n\nvoid\nsbc_dif_generate(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct t10_pi_tuple *sdt;\n\tstruct scatterlist *dsg = cmd->t_data_sg, *psg;\n\tsector_t sector = cmd->t_task_lba;\n\tvoid *daddr, *paddr;\n\tint i, j, offset = 0;\n\tunsigned int block_size = dev->dev_attrib.block_size;\n\n\tfor_each_sg(cmd->t_prot_sg, psg, cmd->t_prot_nents, i) {\n\t\tpaddr = kmap_atomic(sg_page(psg)) + psg->offset;\n\t\tdaddr = kmap_atomic(sg_page(dsg)) + dsg->offset;\n\n\t\tfor (j = 0; j < psg->length;\n\t\t\t\tj += sizeof(*sdt)) {\n\t\t\t__u16 crc;\n\t\t\tunsigned int avail;\n\n\t\t\tif (offset >= dsg->length) {\n\t\t\t\toffset -= dsg->length;\n\t\t\t\tkunmap_atomic(daddr - dsg->offset);\n\t\t\t\tdsg = sg_next(dsg);\n\t\t\t\tif (!dsg) {\n\t\t\t\t\tkunmap_atomic(paddr - psg->offset);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdaddr = kmap_atomic(sg_page(dsg)) + dsg->offset;\n\t\t\t}\n\n\t\t\tsdt = paddr + j;\n\t\t\tavail = min(block_size, dsg->length - offset);\n\t\t\tcrc = crc_t10dif(daddr + offset, avail);\n\t\t\tif (avail < block_size) {\n\t\t\t\tkunmap_atomic(daddr - dsg->offset);\n\t\t\t\tdsg = sg_next(dsg);\n\t\t\t\tif (!dsg) {\n\t\t\t\t\tkunmap_atomic(paddr - psg->offset);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdaddr = kmap_atomic(sg_page(dsg)) + dsg->offset;\n\t\t\t\toffset = block_size - avail;\n\t\t\t\tcrc = crc_t10dif_update(crc, daddr, offset);\n\t\t\t} else {\n\t\t\t\toffset += block_size;\n\t\t\t}\n\n\t\t\tsdt->guard_tag = cpu_to_be16(crc);\n\t\t\tif (cmd->prot_type == TARGET_DIF_TYPE1_PROT)\n\t\t\t\tsdt->ref_tag = cpu_to_be32(sector & 0xffffffff);\n\t\t\tsdt->app_tag = 0;\n\n\t\t\tpr_debug(\"DIF %s INSERT sector: %llu guard_tag: 0x%04x\"\n\t\t\t\t \" app_tag: 0x%04x ref_tag: %u\\n\",\n\t\t\t\t (cmd->data_direction == DMA_TO_DEVICE) ?\n\t\t\t\t \"WRITE\" : \"READ\", (unsigned long long)sector,\n\t\t\t\t sdt->guard_tag, sdt->app_tag,\n\t\t\t\t be32_to_cpu(sdt->ref_tag));\n\n\t\t\tsector++;\n\t\t}\n\n\t\tkunmap_atomic(daddr - dsg->offset);\n\t\tkunmap_atomic(paddr - psg->offset);\n\t}\n}\n\nstatic sense_reason_t\nsbc_dif_v1_verify(struct se_cmd *cmd, struct t10_pi_tuple *sdt,\n\t\t  __u16 crc, sector_t sector, unsigned int ei_lba)\n{\n\t__be16 csum;\n\n\tif (!(cmd->prot_checks & TARGET_DIF_CHECK_GUARD))\n\t\tgoto check_ref;\n\n\tcsum = cpu_to_be16(crc);\n\n\tif (sdt->guard_tag != csum) {\n\t\tpr_err(\"DIFv1 checksum failed on sector %llu guard tag 0x%04x\"\n\t\t\t\" csum 0x%04x\\n\", (unsigned long long)sector,\n\t\t\tbe16_to_cpu(sdt->guard_tag), be16_to_cpu(csum));\n\t\treturn TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED;\n\t}\n\ncheck_ref:\n\tif (!(cmd->prot_checks & TARGET_DIF_CHECK_REFTAG))\n\t\treturn 0;\n\n\tif (cmd->prot_type == TARGET_DIF_TYPE1_PROT &&\n\t    be32_to_cpu(sdt->ref_tag) != (sector & 0xffffffff)) {\n\t\tpr_err(\"DIFv1 Type 1 reference failed on sector: %llu tag: 0x%08x\"\n\t\t       \" sector MSB: 0x%08x\\n\", (unsigned long long)sector,\n\t\t       be32_to_cpu(sdt->ref_tag), (u32)(sector & 0xffffffff));\n\t\treturn TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;\n\t}\n\n\tif (cmd->prot_type == TARGET_DIF_TYPE2_PROT &&\n\t    be32_to_cpu(sdt->ref_tag) != ei_lba) {\n\t\tpr_err(\"DIFv1 Type 2 reference failed on sector: %llu tag: 0x%08x\"\n\t\t       \" ei_lba: 0x%08x\\n\", (unsigned long long)sector,\n\t\t\tbe32_to_cpu(sdt->ref_tag), ei_lba);\n\t\treturn TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;\n\t}\n\n\treturn 0;\n}\n\nvoid sbc_dif_copy_prot(struct se_cmd *cmd, unsigned int sectors, bool read,\n\t\t       struct scatterlist *sg, int sg_off)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct scatterlist *psg;\n\tvoid *paddr, *addr;\n\tunsigned int i, len, left;\n\tunsigned int offset = sg_off;\n\n\tif (!sg)\n\t\treturn;\n\n\tleft = sectors * dev->prot_length;\n\n\tfor_each_sg(cmd->t_prot_sg, psg, cmd->t_prot_nents, i) {\n\t\tunsigned int psg_len, copied = 0;\n\n\t\tpaddr = kmap_atomic(sg_page(psg)) + psg->offset;\n\t\tpsg_len = min(left, psg->length);\n\t\twhile (psg_len) {\n\t\t\tlen = min(psg_len, sg->length - offset);\n\t\t\taddr = kmap_atomic(sg_page(sg)) + sg->offset + offset;\n\n\t\t\tif (read)\n\t\t\t\tmemcpy(paddr + copied, addr, len);\n\t\t\telse\n\t\t\t\tmemcpy(addr, paddr + copied, len);\n\n\t\t\tleft -= len;\n\t\t\toffset += len;\n\t\t\tcopied += len;\n\t\t\tpsg_len -= len;\n\n\t\t\tkunmap_atomic(addr - sg->offset - offset);\n\n\t\t\tif (offset >= sg->length) {\n\t\t\t\tsg = sg_next(sg);\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t}\n\t\tkunmap_atomic(paddr - psg->offset);\n\t}\n}\nEXPORT_SYMBOL(sbc_dif_copy_prot);\n\nsense_reason_t\nsbc_dif_verify(struct se_cmd *cmd, sector_t start, unsigned int sectors,\n\t       unsigned int ei_lba, struct scatterlist *psg, int psg_off)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct t10_pi_tuple *sdt;\n\tstruct scatterlist *dsg = cmd->t_data_sg;\n\tsector_t sector = start;\n\tvoid *daddr, *paddr;\n\tint i;\n\tsense_reason_t rc;\n\tint dsg_off = 0;\n\tunsigned int block_size = dev->dev_attrib.block_size;\n\n\tfor (; psg && sector < start + sectors; psg = sg_next(psg)) {\n\t\tpaddr = kmap_atomic(sg_page(psg)) + psg->offset;\n\t\tdaddr = kmap_atomic(sg_page(dsg)) + dsg->offset;\n\n\t\tfor (i = psg_off; i < psg->length &&\n\t\t\t\tsector < start + sectors;\n\t\t\t\ti += sizeof(*sdt)) {\n\t\t\t__u16 crc;\n\t\t\tunsigned int avail;\n\n\t\t\tif (dsg_off >= dsg->length) {\n\t\t\t\tdsg_off -= dsg->length;\n\t\t\t\tkunmap_atomic(daddr - dsg->offset);\n\t\t\t\tdsg = sg_next(dsg);\n\t\t\t\tif (!dsg) {\n\t\t\t\t\tkunmap_atomic(paddr - psg->offset);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tdaddr = kmap_atomic(sg_page(dsg)) + dsg->offset;\n\t\t\t}\n\n\t\t\tsdt = paddr + i;\n\n\t\t\tpr_debug(\"DIF READ sector: %llu guard_tag: 0x%04x\"\n\t\t\t\t \" app_tag: 0x%04x ref_tag: %u\\n\",\n\t\t\t\t (unsigned long long)sector, sdt->guard_tag,\n\t\t\t\t sdt->app_tag, be32_to_cpu(sdt->ref_tag));\n\n\t\t\tif (sdt->app_tag == T10_PI_APP_ESCAPE) {\n\t\t\t\tdsg_off += block_size;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tavail = min(block_size, dsg->length - dsg_off);\n\t\t\tcrc = crc_t10dif(daddr + dsg_off, avail);\n\t\t\tif (avail < block_size) {\n\t\t\t\tkunmap_atomic(daddr - dsg->offset);\n\t\t\t\tdsg = sg_next(dsg);\n\t\t\t\tif (!dsg) {\n\t\t\t\t\tkunmap_atomic(paddr - psg->offset);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tdaddr = kmap_atomic(sg_page(dsg)) + dsg->offset;\n\t\t\t\tdsg_off = block_size - avail;\n\t\t\t\tcrc = crc_t10dif_update(crc, daddr, dsg_off);\n\t\t\t} else {\n\t\t\t\tdsg_off += block_size;\n\t\t\t}\n\n\t\t\trc = sbc_dif_v1_verify(cmd, sdt, crc, sector, ei_lba);\n\t\t\tif (rc) {\n\t\t\t\tkunmap_atomic(daddr - dsg->offset);\n\t\t\t\tkunmap_atomic(paddr - psg->offset);\n\t\t\t\tcmd->sense_info = sector;\n\t\t\t\treturn rc;\n\t\t\t}\nnext:\n\t\t\tsector++;\n\t\t\tei_lba++;\n\t\t}\n\n\t\tpsg_off = 0;\n\t\tkunmap_atomic(daddr - dsg->offset);\n\t\tkunmap_atomic(paddr - psg->offset);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sbc_dif_verify);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}