{
  "module_name": "target_core_file.c",
  "hash_id": "3caa53c1f7547ea677beea5c3b9584f69c48461d1a55d010f3ed8c3050553b61",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_file.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/timer.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/falloc.h>\n#include <linux/uio.h>\n#include <linux/scatterlist.h>\n#include <scsi/scsi_proto.h>\n#include <asm/unaligned.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n\n#include \"target_core_file.h\"\n\nstatic inline struct fd_dev *FD_DEV(struct se_device *dev)\n{\n\treturn container_of(dev, struct fd_dev, dev);\n}\n\nstatic int fd_attach_hba(struct se_hba *hba, u32 host_id)\n{\n\tstruct fd_host *fd_host;\n\n\tfd_host = kzalloc(sizeof(struct fd_host), GFP_KERNEL);\n\tif (!fd_host) {\n\t\tpr_err(\"Unable to allocate memory for struct fd_host\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfd_host->fd_host_id = host_id;\n\n\thba->hba_ptr = fd_host;\n\n\tpr_debug(\"CORE_HBA[%d] - TCM FILEIO HBA Driver %s on Generic\"\n\t\t\" Target Core Stack %s\\n\", hba->hba_id, FD_VERSION,\n\t\tTARGET_CORE_VERSION);\n\tpr_debug(\"CORE_HBA[%d] - Attached FILEIO HBA: %u to Generic\\n\",\n\t\thba->hba_id, fd_host->fd_host_id);\n\n\treturn 0;\n}\n\nstatic void fd_detach_hba(struct se_hba *hba)\n{\n\tstruct fd_host *fd_host = hba->hba_ptr;\n\n\tpr_debug(\"CORE_HBA[%d] - Detached FILEIO HBA: %u from Generic\"\n\t\t\" Target Core\\n\", hba->hba_id, fd_host->fd_host_id);\n\n\tkfree(fd_host);\n\thba->hba_ptr = NULL;\n}\n\nstatic struct se_device *fd_alloc_device(struct se_hba *hba, const char *name)\n{\n\tstruct fd_dev *fd_dev;\n\tstruct fd_host *fd_host = hba->hba_ptr;\n\n\tfd_dev = kzalloc(sizeof(struct fd_dev), GFP_KERNEL);\n\tif (!fd_dev) {\n\t\tpr_err(\"Unable to allocate memory for struct fd_dev\\n\");\n\t\treturn NULL;\n\t}\n\n\tfd_dev->fd_host = fd_host;\n\n\tpr_debug(\"FILEIO: Allocated fd_dev for %p\\n\", name);\n\n\treturn &fd_dev->dev;\n}\n\nstatic bool fd_configure_unmap(struct se_device *dev)\n{\n\tstruct file *file = FD_DEV(dev)->fd_file;\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (S_ISBLK(inode->i_mode))\n\t\treturn target_configure_unmap_from_queue(&dev->dev_attrib,\n\t\t\t\t\t\t\t I_BDEV(inode));\n\n\t \n\tdev->dev_attrib.max_unmap_lba_count = 0x2000;\n\t \n\tdev->dev_attrib.max_unmap_block_desc_count = 1;\n\tdev->dev_attrib.unmap_granularity = 1;\n\tdev->dev_attrib.unmap_granularity_alignment = 0;\n\treturn true;\n}\n\nstatic int fd_configure_device(struct se_device *dev)\n{\n\tstruct fd_dev *fd_dev = FD_DEV(dev);\n\tstruct fd_host *fd_host = dev->se_hba->hba_ptr;\n\tstruct file *file;\n\tstruct inode *inode = NULL;\n\tint flags, ret = -EINVAL;\n\n\tif (!(fd_dev->fbd_flags & FBDF_HAS_PATH)) {\n\t\tpr_err(\"Missing fd_dev_name=\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tflags = O_RDWR | O_CREAT | O_LARGEFILE | O_DSYNC;\n\n\t \n\tif (fd_dev->fbd_flags & FDBD_HAS_BUFFERED_IO_WCE) {\n\t\tpr_debug(\"FILEIO: Disabling O_DSYNC, using buffered FILEIO\\n\");\n\t\tflags &= ~O_DSYNC;\n\t}\n\n\tfile = filp_open(fd_dev->fd_dev_name, flags, 0600);\n\tif (IS_ERR(file)) {\n\t\tpr_err(\"filp_open(%s) failed\\n\", fd_dev->fd_dev_name);\n\t\tret = PTR_ERR(file);\n\t\tgoto fail;\n\t}\n\tfd_dev->fd_file = file;\n\t \n\tinode = file->f_mapping->host;\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tstruct block_device *bdev = I_BDEV(inode);\n\t\tunsigned long long dev_size;\n\n\t\tfd_dev->fd_block_size = bdev_logical_block_size(bdev);\n\t\t \n\t\tdev_size = (i_size_read(file->f_mapping->host) -\n\t\t\t\t       fd_dev->fd_block_size);\n\n\t\tpr_debug(\"FILEIO: Using size: %llu bytes from struct\"\n\t\t\t\" block_device blocks: %llu logical_block_size: %d\\n\",\n\t\t\tdev_size, div_u64(dev_size, fd_dev->fd_block_size),\n\t\t\tfd_dev->fd_block_size);\n\t\t \n\t\tdev->dev_attrib.max_write_same_len = 0xFFFF;\n\n\t\tif (bdev_nonrot(bdev))\n\t\t\tdev->dev_attrib.is_nonrot = 1;\n\t} else {\n\t\tif (!(fd_dev->fbd_flags & FBDF_HAS_SIZE)) {\n\t\t\tpr_err(\"FILEIO: Missing fd_dev_size=\"\n\t\t\t\t\" parameter, and no backing struct\"\n\t\t\t\t\" block_device\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfd_dev->fd_block_size = FD_BLOCKSIZE;\n\n\t\t \n\t\tdev->dev_attrib.max_write_same_len = 0x1000;\n\t}\n\n\tdev->dev_attrib.hw_block_size = fd_dev->fd_block_size;\n\tdev->dev_attrib.hw_max_sectors = FD_MAX_BYTES / fd_dev->fd_block_size;\n\tdev->dev_attrib.hw_queue_depth = FD_MAX_DEVICE_QUEUE_DEPTH;\n\n\tif (fd_dev->fbd_flags & FDBD_HAS_BUFFERED_IO_WCE) {\n\t\tpr_debug(\"FILEIO: Forcing setting of emulate_write_cache=1\"\n\t\t\t\" with FDBD_HAS_BUFFERED_IO_WCE\\n\");\n\t\tdev->dev_attrib.emulate_write_cache = 1;\n\t}\n\n\tfd_dev->fd_dev_id = fd_host->fd_host_dev_id_count++;\n\tfd_dev->fd_queue_depth = dev->queue_depth;\n\n\tpr_debug(\"CORE_FILE[%u] - Added TCM FILEIO Device ID: %u at %s,\"\n\t\t\" %llu total bytes\\n\", fd_host->fd_host_id, fd_dev->fd_dev_id,\n\t\t\tfd_dev->fd_dev_name, fd_dev->fd_dev_size);\n\n\treturn 0;\nfail:\n\tif (fd_dev->fd_file) {\n\t\tfilp_close(fd_dev->fd_file, NULL);\n\t\tfd_dev->fd_file = NULL;\n\t}\n\treturn ret;\n}\n\nstatic void fd_dev_call_rcu(struct rcu_head *p)\n{\n\tstruct se_device *dev = container_of(p, struct se_device, rcu_head);\n\tstruct fd_dev *fd_dev = FD_DEV(dev);\n\n\tkfree(fd_dev);\n}\n\nstatic void fd_free_device(struct se_device *dev)\n{\n\tcall_rcu(&dev->rcu_head, fd_dev_call_rcu);\n}\n\nstatic void fd_destroy_device(struct se_device *dev)\n{\n\tstruct fd_dev *fd_dev = FD_DEV(dev);\n\n\tif (fd_dev->fd_file) {\n\t\tfilp_close(fd_dev->fd_file, NULL);\n\t\tfd_dev->fd_file = NULL;\n\t}\n}\n\nstruct target_core_file_cmd {\n\tunsigned long\tlen;\n\tstruct se_cmd\t*cmd;\n\tstruct kiocb\tiocb;\n\tstruct bio_vec\tbvecs[];\n};\n\nstatic void cmd_rw_aio_complete(struct kiocb *iocb, long ret)\n{\n\tstruct target_core_file_cmd *cmd;\n\n\tcmd = container_of(iocb, struct target_core_file_cmd, iocb);\n\n\tif (ret != cmd->len)\n\t\ttarget_complete_cmd(cmd->cmd, SAM_STAT_CHECK_CONDITION);\n\telse\n\t\ttarget_complete_cmd(cmd->cmd, SAM_STAT_GOOD);\n\n\tkfree(cmd);\n}\n\nstatic sense_reason_t\nfd_execute_rw_aio(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,\n\t      enum dma_data_direction data_direction)\n{\n\tint is_write = !(data_direction == DMA_FROM_DEVICE);\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct fd_dev *fd_dev = FD_DEV(dev);\n\tstruct file *file = fd_dev->fd_file;\n\tstruct target_core_file_cmd *aio_cmd;\n\tstruct iov_iter iter;\n\tstruct scatterlist *sg;\n\tssize_t len = 0;\n\tint ret = 0, i;\n\n\taio_cmd = kmalloc(struct_size(aio_cmd, bvecs, sgl_nents), GFP_KERNEL);\n\tif (!aio_cmd)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tfor_each_sg(sgl, sg, sgl_nents, i) {\n\t\tbvec_set_page(&aio_cmd->bvecs[i], sg_page(sg), sg->length,\n\t\t\t      sg->offset);\n\t\tlen += sg->length;\n\t}\n\n\tiov_iter_bvec(&iter, is_write, aio_cmd->bvecs, sgl_nents, len);\n\n\taio_cmd->cmd = cmd;\n\taio_cmd->len = len;\n\taio_cmd->iocb.ki_pos = cmd->t_task_lba * dev->dev_attrib.block_size;\n\taio_cmd->iocb.ki_filp = file;\n\taio_cmd->iocb.ki_complete = cmd_rw_aio_complete;\n\taio_cmd->iocb.ki_flags = IOCB_DIRECT;\n\n\tif (is_write && (cmd->se_cmd_flags & SCF_FUA))\n\t\taio_cmd->iocb.ki_flags |= IOCB_DSYNC;\n\n\tif (is_write)\n\t\tret = call_write_iter(file, &aio_cmd->iocb, &iter);\n\telse\n\t\tret = call_read_iter(file, &aio_cmd->iocb, &iter);\n\n\tif (ret != -EIOCBQUEUED)\n\t\tcmd_rw_aio_complete(&aio_cmd->iocb, ret);\n\n\treturn 0;\n}\n\nstatic int fd_do_rw(struct se_cmd *cmd, struct file *fd,\n\t\t    u32 block_size, struct scatterlist *sgl,\n\t\t    u32 sgl_nents, u32 data_length, int is_write)\n{\n\tstruct scatterlist *sg;\n\tstruct iov_iter iter;\n\tstruct bio_vec *bvec;\n\tssize_t len = 0;\n\tloff_t pos = (cmd->t_task_lba * block_size);\n\tint ret = 0, i;\n\n\tbvec = kcalloc(sgl_nents, sizeof(struct bio_vec), GFP_KERNEL);\n\tif (!bvec) {\n\t\tpr_err(\"Unable to allocate fd_do_readv iov[]\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor_each_sg(sgl, sg, sgl_nents, i) {\n\t\tbvec_set_page(&bvec[i], sg_page(sg), sg->length, sg->offset);\n\t\tlen += sg->length;\n\t}\n\n\tiov_iter_bvec(&iter, is_write, bvec, sgl_nents, len);\n\tif (is_write) {\n\t\tfile_start_write(fd);\n\t\tret = vfs_iter_write(fd, &iter, &pos, 0);\n\t\tfile_end_write(fd);\n\t} else {\n\t\tret = vfs_iter_read(fd, &iter, &pos, 0);\n\t}\n\tif (is_write) {\n\t\tif (ret < 0 || ret != data_length) {\n\t\t\tpr_err(\"%s() write returned %d\\n\", __func__, ret);\n\t\t\tif (ret >= 0)\n\t\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tif (S_ISBLK(file_inode(fd)->i_mode)) {\n\t\t\tif (ret < 0 || ret != data_length) {\n\t\t\t\tpr_err(\"%s() returned %d, expecting %u for \"\n\t\t\t\t\t\t\"S_ISBLK\\n\", __func__, ret,\n\t\t\t\t\t\tdata_length);\n\t\t\t\tif (ret >= 0)\n\t\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"%s() returned %d for non S_ISBLK\\n\",\n\t\t\t\t\t\t__func__, ret);\n\t\t\t} else if (ret != data_length) {\n\t\t\t\t \n\t\t\t\tif (ret < data_length)\n\t\t\t\t\tret += iov_iter_zero(data_length - ret, &iter);\n\t\t\t\telse\n\t\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\tkfree(bvec);\n\treturn ret;\n}\n\nstatic sense_reason_t\nfd_execute_sync_cache(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct fd_dev *fd_dev = FD_DEV(dev);\n\tint immed = (cmd->t_task_cdb[1] & 0x2);\n\tloff_t start, end;\n\tint ret;\n\n\t \n\tif (immed)\n\t\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\n\t \n\tif (cmd->t_task_lba == 0 && cmd->data_length == 0) {\n\t\tstart = 0;\n\t\tend = LLONG_MAX;\n\t} else {\n\t\tstart = cmd->t_task_lba * dev->dev_attrib.block_size;\n\t\tif (cmd->data_length)\n\t\t\tend = start + cmd->data_length - 1;\n\t\telse\n\t\t\tend = LLONG_MAX;\n\t}\n\n\tret = vfs_fsync_range(fd_dev->fd_file, start, end, 1);\n\tif (ret != 0)\n\t\tpr_err(\"FILEIO: vfs_fsync_range() failed: %d\\n\", ret);\n\n\tif (immed)\n\t\treturn 0;\n\n\tif (ret)\n\t\ttarget_complete_cmd(cmd, SAM_STAT_CHECK_CONDITION);\n\telse\n\t\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\n\treturn 0;\n}\n\nstatic sense_reason_t\nfd_execute_write_same(struct se_cmd *cmd)\n{\n\tstruct se_device *se_dev = cmd->se_dev;\n\tstruct fd_dev *fd_dev = FD_DEV(se_dev);\n\tloff_t pos = cmd->t_task_lba * se_dev->dev_attrib.block_size;\n\tsector_t nolb = sbc_get_write_same_sectors(cmd);\n\tstruct iov_iter iter;\n\tstruct bio_vec *bvec;\n\tunsigned int len = 0, i;\n\tssize_t ret;\n\n\tif (cmd->prot_op) {\n\t\tpr_err(\"WRITE_SAME: Protection information with FILEIO\"\n\t\t       \" backends not supported\\n\");\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\n\tif (!cmd->t_data_nents)\n\t\treturn TCM_INVALID_CDB_FIELD;\n\n\tif (cmd->t_data_nents > 1 ||\n\t    cmd->t_data_sg[0].length != cmd->se_dev->dev_attrib.block_size) {\n\t\tpr_err(\"WRITE_SAME: Illegal SGL t_data_nents: %u length: %u\"\n\t\t\t\" block_size: %u\\n\",\n\t\t\tcmd->t_data_nents,\n\t\t\tcmd->t_data_sg[0].length,\n\t\t\tcmd->se_dev->dev_attrib.block_size);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tbvec = kcalloc(nolb, sizeof(struct bio_vec), GFP_KERNEL);\n\tif (!bvec)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tfor (i = 0; i < nolb; i++) {\n\t\tbvec_set_page(&bvec[i], sg_page(&cmd->t_data_sg[0]),\n\t\t\t      cmd->t_data_sg[0].length,\n\t\t\t      cmd->t_data_sg[0].offset);\n\t\tlen += se_dev->dev_attrib.block_size;\n\t}\n\n\tiov_iter_bvec(&iter, ITER_SOURCE, bvec, nolb, len);\n\tfile_start_write(fd_dev->fd_file);\n\tret = vfs_iter_write(fd_dev->fd_file, &iter, &pos, 0);\n\tfile_end_write(fd_dev->fd_file);\n\n\tkfree(bvec);\n\tif (ret < 0 || ret != len) {\n\t\tpr_err(\"vfs_iter_write() returned %zd for write same\\n\", ret);\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\n\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn 0;\n}\n\nstatic int\nfd_do_prot_fill(struct se_device *se_dev, sector_t lba, sector_t nolb,\n\t\tvoid *buf, size_t bufsize)\n{\n\tstruct fd_dev *fd_dev = FD_DEV(se_dev);\n\tstruct file *prot_fd = fd_dev->fd_prot_file;\n\tsector_t prot_length, prot;\n\tloff_t pos = lba * se_dev->prot_length;\n\n\tif (!prot_fd) {\n\t\tpr_err(\"Unable to locate fd_dev->fd_prot_file\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tprot_length = nolb * se_dev->prot_length;\n\n\tmemset(buf, 0xff, bufsize);\n\tfor (prot = 0; prot < prot_length;) {\n\t\tsector_t len = min_t(sector_t, bufsize, prot_length - prot);\n\t\tssize_t ret = kernel_write(prot_fd, buf, len, &pos);\n\n\t\tif (ret != len) {\n\t\t\tpr_err(\"vfs_write to prot file failed: %zd\\n\", ret);\n\t\t\treturn ret < 0 ? ret : -ENODEV;\n\t\t}\n\t\tprot += ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nfd_do_prot_unmap(struct se_cmd *cmd, sector_t lba, sector_t nolb)\n{\n\tvoid *buf;\n\tint rc;\n\n\tbuf = (void *)__get_free_page(GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"Unable to allocate FILEIO prot buf\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trc = fd_do_prot_fill(cmd->se_dev, lba, nolb, buf, PAGE_SIZE);\n\n\tfree_page((unsigned long)buf);\n\n\treturn rc;\n}\n\nstatic sense_reason_t\nfd_execute_unmap(struct se_cmd *cmd, sector_t lba, sector_t nolb)\n{\n\tstruct file *file = FD_DEV(cmd->se_dev)->fd_file;\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\tif (!nolb) {\n\t\treturn 0;\n\t}\n\n\tif (cmd->se_dev->dev_attrib.pi_prot_type) {\n\t\tret = fd_do_prot_unmap(cmd, lba, nolb);\n\t\tif (ret)\n\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\n\tif (S_ISBLK(inode->i_mode)) {\n\t\t \n\t\tstruct block_device *bdev = I_BDEV(inode);\n\t\tstruct se_device *dev = cmd->se_dev;\n\n\t\tret = blkdev_issue_discard(bdev,\n\t\t\t\t\t   target_to_linux_sector(dev, lba),\n\t\t\t\t\t   target_to_linux_sector(dev,  nolb),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"FILEIO: blkdev_issue_discard() failed: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\t}\n\t} else {\n\t\t \n\t\tstruct se_device *se_dev = cmd->se_dev;\n\t\tloff_t pos = lba * se_dev->dev_attrib.block_size;\n\t\tunsigned int len = nolb * se_dev->dev_attrib.block_size;\n\t\tint mode = FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE;\n\n\t\tif (!file->f_op->fallocate)\n\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\t\tret = file->f_op->fallocate(file, mode, pos, len);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"FILEIO: fallocate() failed: %d\\n\", ret);\n\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic sense_reason_t\nfd_execute_rw_buffered(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,\n\t      enum dma_data_direction data_direction)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct fd_dev *fd_dev = FD_DEV(dev);\n\tstruct file *file = fd_dev->fd_file;\n\tstruct file *pfile = fd_dev->fd_prot_file;\n\tsense_reason_t rc;\n\tint ret = 0;\n\t \n\tif (data_direction == DMA_FROM_DEVICE) {\n\t\tif (cmd->prot_type && dev->dev_attrib.pi_prot_type) {\n\t\t\tret = fd_do_rw(cmd, pfile, dev->prot_length,\n\t\t\t\t       cmd->t_prot_sg, cmd->t_prot_nents,\n\t\t\t\t       cmd->prot_length, 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\t}\n\n\t\tret = fd_do_rw(cmd, file, dev->dev_attrib.block_size,\n\t\t\t       sgl, sgl_nents, cmd->data_length, 0);\n\n\t\tif (ret > 0 && cmd->prot_type && dev->dev_attrib.pi_prot_type &&\n\t\t    dev->dev_attrib.pi_prot_verify) {\n\t\t\tu32 sectors = cmd->data_length >>\n\t\t\t\t\tilog2(dev->dev_attrib.block_size);\n\n\t\t\trc = sbc_dif_verify(cmd, cmd->t_task_lba, sectors,\n\t\t\t\t\t    0, cmd->t_prot_sg, 0);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tif (cmd->prot_type && dev->dev_attrib.pi_prot_type &&\n\t\t    dev->dev_attrib.pi_prot_verify) {\n\t\t\tu32 sectors = cmd->data_length >>\n\t\t\t\t\tilog2(dev->dev_attrib.block_size);\n\n\t\t\trc = sbc_dif_verify(cmd, cmd->t_task_lba, sectors,\n\t\t\t\t\t    0, cmd->t_prot_sg, 0);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tret = fd_do_rw(cmd, file, dev->dev_attrib.block_size,\n\t\t\t       sgl, sgl_nents, cmd->data_length, 1);\n\t\t \n\t\tif (ret > 0 && (cmd->se_cmd_flags & SCF_FUA)) {\n\t\t\tloff_t start = cmd->t_task_lba *\n\t\t\t\tdev->dev_attrib.block_size;\n\t\t\tloff_t end;\n\n\t\t\tif (cmd->data_length)\n\t\t\t\tend = start + cmd->data_length - 1;\n\t\t\telse\n\t\t\t\tend = LLONG_MAX;\n\n\t\t\tvfs_fsync_range(fd_dev->fd_file, start, end, 1);\n\t\t}\n\n\t\tif (ret > 0 && cmd->prot_type && dev->dev_attrib.pi_prot_type) {\n\t\t\tret = fd_do_rw(cmd, pfile, dev->prot_length,\n\t\t\t\t       cmd->t_prot_sg, cmd->t_prot_nents,\n\t\t\t\t       cmd->prot_length, 1);\n\t\t\tif (ret < 0)\n\t\t\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn 0;\n}\n\nstatic sense_reason_t\nfd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,\n\t      enum dma_data_direction data_direction)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct fd_dev *fd_dev = FD_DEV(dev);\n\n\t \n\tif (cmd->data_length > FD_MAX_BYTES) {\n\t\tpr_err(\"FILEIO: Not able to process I/O of %u bytes due to\"\n\t\t       \"FD_MAX_BYTES: %u iovec count limitation\\n\",\n\t\t\tcmd->data_length, FD_MAX_BYTES);\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t}\n\n\tif (fd_dev->fbd_flags & FDBD_HAS_ASYNC_IO)\n\t\treturn fd_execute_rw_aio(cmd, sgl, sgl_nents, data_direction);\n\treturn fd_execute_rw_buffered(cmd, sgl, sgl_nents, data_direction);\n}\n\nenum {\n\tOpt_fd_dev_name, Opt_fd_dev_size, Opt_fd_buffered_io,\n\tOpt_fd_async_io, Opt_err\n};\n\nstatic match_table_t tokens = {\n\t{Opt_fd_dev_name, \"fd_dev_name=%s\"},\n\t{Opt_fd_dev_size, \"fd_dev_size=%s\"},\n\t{Opt_fd_buffered_io, \"fd_buffered_io=%d\"},\n\t{Opt_fd_async_io, \"fd_async_io=%d\"},\n\t{Opt_err, NULL}\n};\n\nstatic ssize_t fd_set_configfs_dev_params(struct se_device *dev,\n\t\tconst char *page, ssize_t count)\n{\n\tstruct fd_dev *fd_dev = FD_DEV(dev);\n\tchar *orig, *ptr, *arg_p, *opts;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = 0, arg, token;\n\n\topts = kstrdup(page, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\n\torig = opts;\n\n\twhile ((ptr = strsep(&opts, \",\\n\")) != NULL) {\n\t\tif (!*ptr)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(ptr, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_fd_dev_name:\n\t\t\tif (match_strlcpy(fd_dev->fd_dev_name, &args[0],\n\t\t\t\tFD_MAX_DEV_NAME) == 0) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpr_debug(\"FILEIO: Referencing Path: %s\\n\",\n\t\t\t\t\tfd_dev->fd_dev_name);\n\t\t\tfd_dev->fbd_flags |= FBDF_HAS_PATH;\n\t\t\tbreak;\n\t\tcase Opt_fd_dev_size:\n\t\t\targ_p = match_strdup(&args[0]);\n\t\t\tif (!arg_p) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = kstrtoull(arg_p, 0, &fd_dev->fd_dev_size);\n\t\t\tkfree(arg_p);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"kstrtoull() failed for\"\n\t\t\t\t\t\t\" fd_dev_size=\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpr_debug(\"FILEIO: Referencing Size: %llu\"\n\t\t\t\t\t\" bytes\\n\", fd_dev->fd_dev_size);\n\t\t\tfd_dev->fbd_flags |= FBDF_HAS_SIZE;\n\t\t\tbreak;\n\t\tcase Opt_fd_buffered_io:\n\t\t\tret = match_int(args, &arg);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (arg != 1) {\n\t\t\t\tpr_err(\"bogus fd_buffered_io=%d value\\n\", arg);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tpr_debug(\"FILEIO: Using buffered I/O\"\n\t\t\t\t\" operations for struct fd_dev\\n\");\n\n\t\t\tfd_dev->fbd_flags |= FDBD_HAS_BUFFERED_IO_WCE;\n\t\t\tbreak;\n\t\tcase Opt_fd_async_io:\n\t\t\tret = match_int(args, &arg);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (arg != 1) {\n\t\t\t\tpr_err(\"bogus fd_async_io=%d value\\n\", arg);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tpr_debug(\"FILEIO: Using async I/O\"\n\t\t\t\t\" operations for struct fd_dev\\n\");\n\n\t\t\tfd_dev->fbd_flags |= FDBD_HAS_ASYNC_IO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(orig);\n\treturn (!ret) ? count : ret;\n}\n\nstatic ssize_t fd_show_configfs_dev_params(struct se_device *dev, char *b)\n{\n\tstruct fd_dev *fd_dev = FD_DEV(dev);\n\tssize_t bl = 0;\n\n\tbl = sprintf(b + bl, \"TCM FILEIO ID: %u\", fd_dev->fd_dev_id);\n\tbl += sprintf(b + bl, \"        File: %s  Size: %llu  Mode: %s Async: %d\\n\",\n\t\tfd_dev->fd_dev_name, fd_dev->fd_dev_size,\n\t\t(fd_dev->fbd_flags & FDBD_HAS_BUFFERED_IO_WCE) ?\n\t\t\"Buffered-WCE\" : \"O_DSYNC\",\n\t\t!!(fd_dev->fbd_flags & FDBD_HAS_ASYNC_IO));\n\treturn bl;\n}\n\nstatic sector_t fd_get_blocks(struct se_device *dev)\n{\n\tstruct fd_dev *fd_dev = FD_DEV(dev);\n\tstruct file *f = fd_dev->fd_file;\n\tstruct inode *i = f->f_mapping->host;\n\tunsigned long long dev_size;\n\t \n\tif (S_ISBLK(i->i_mode))\n\t\tdev_size = i_size_read(i);\n\telse\n\t\tdev_size = fd_dev->fd_dev_size;\n\n\treturn div_u64(dev_size - dev->dev_attrib.block_size,\n\t\t       dev->dev_attrib.block_size);\n}\n\nstatic int fd_init_prot(struct se_device *dev)\n{\n\tstruct fd_dev *fd_dev = FD_DEV(dev);\n\tstruct file *prot_file, *file = fd_dev->fd_file;\n\tstruct inode *inode;\n\tint ret, flags = O_RDWR | O_CREAT | O_LARGEFILE | O_DSYNC;\n\tchar buf[FD_MAX_DEV_PROT_NAME];\n\n\tif (!file) {\n\t\tpr_err(\"Unable to locate fd_dev->fd_file\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tinode = file->f_mapping->host;\n\tif (S_ISBLK(inode->i_mode)) {\n\t\tpr_err(\"FILEIO Protection emulation only supported on\"\n\t\t       \" !S_ISBLK\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tif (fd_dev->fbd_flags & FDBD_HAS_BUFFERED_IO_WCE)\n\t\tflags &= ~O_DSYNC;\n\n\tsnprintf(buf, FD_MAX_DEV_PROT_NAME, \"%s.protection\",\n\t\t fd_dev->fd_dev_name);\n\n\tprot_file = filp_open(buf, flags, 0600);\n\tif (IS_ERR(prot_file)) {\n\t\tpr_err(\"filp_open(%s) failed\\n\", buf);\n\t\tret = PTR_ERR(prot_file);\n\t\treturn ret;\n\t}\n\tfd_dev->fd_prot_file = prot_file;\n\n\treturn 0;\n}\n\nstatic int fd_format_prot(struct se_device *dev)\n{\n\tunsigned char *buf;\n\tint unit_size = FDBD_FORMAT_UNIT_SIZE * dev->dev_attrib.block_size;\n\tint ret;\n\n\tif (!dev->dev_attrib.pi_prot_type) {\n\t\tpr_err(\"Unable to format_prot while pi_prot_type == 0\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbuf = vzalloc(unit_size);\n\tif (!buf) {\n\t\tpr_err(\"Unable to allocate FILEIO prot buf\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"Using FILEIO prot_length: %llu\\n\",\n\t\t (unsigned long long)(dev->transport->get_blocks(dev) + 1) *\n\t\t\t\t\tdev->prot_length);\n\n\tret = fd_do_prot_fill(dev, 0, dev->transport->get_blocks(dev) + 1,\n\t\t\t      buf, unit_size);\n\tvfree(buf);\n\treturn ret;\n}\n\nstatic void fd_free_prot(struct se_device *dev)\n{\n\tstruct fd_dev *fd_dev = FD_DEV(dev);\n\n\tif (!fd_dev->fd_prot_file)\n\t\treturn;\n\n\tfilp_close(fd_dev->fd_prot_file, NULL);\n\tfd_dev->fd_prot_file = NULL;\n}\n\nstatic struct exec_cmd_ops fd_exec_cmd_ops = {\n\t.execute_rw\t\t= fd_execute_rw,\n\t.execute_sync_cache\t= fd_execute_sync_cache,\n\t.execute_write_same\t= fd_execute_write_same,\n\t.execute_unmap\t\t= fd_execute_unmap,\n};\n\nstatic sense_reason_t\nfd_parse_cdb(struct se_cmd *cmd)\n{\n\treturn sbc_parse_cdb(cmd, &fd_exec_cmd_ops);\n}\n\nstatic const struct target_backend_ops fileio_ops = {\n\t.name\t\t\t= \"fileio\",\n\t.inquiry_prod\t\t= \"FILEIO\",\n\t.inquiry_rev\t\t= FD_VERSION,\n\t.owner\t\t\t= THIS_MODULE,\n\t.attach_hba\t\t= fd_attach_hba,\n\t.detach_hba\t\t= fd_detach_hba,\n\t.alloc_device\t\t= fd_alloc_device,\n\t.configure_device\t= fd_configure_device,\n\t.destroy_device\t\t= fd_destroy_device,\n\t.free_device\t\t= fd_free_device,\n\t.configure_unmap\t= fd_configure_unmap,\n\t.parse_cdb\t\t= fd_parse_cdb,\n\t.set_configfs_dev_params = fd_set_configfs_dev_params,\n\t.show_configfs_dev_params = fd_show_configfs_dev_params,\n\t.get_device_type\t= sbc_get_device_type,\n\t.get_blocks\t\t= fd_get_blocks,\n\t.init_prot\t\t= fd_init_prot,\n\t.format_prot\t\t= fd_format_prot,\n\t.free_prot\t\t= fd_free_prot,\n\t.tb_dev_attrib_attrs\t= sbc_attrib_attrs,\n};\n\nstatic int __init fileio_module_init(void)\n{\n\treturn transport_backend_register(&fileio_ops);\n}\n\nstatic void __exit fileio_module_exit(void)\n{\n\ttarget_backend_unregister(&fileio_ops);\n}\n\nMODULE_DESCRIPTION(\"TCM FILEIO subsystem plugin\");\nMODULE_AUTHOR(\"nab@Linux-iSCSI.org\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(fileio_module_init);\nmodule_exit(fileio_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}