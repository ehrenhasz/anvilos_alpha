{
  "module_name": "target_core_alua.c",
  "hash_id": "0d782d38bbd1285974f0422f9989dc216ddfae5eace7fea7b404fa1ae0bed217",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_alua.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/configfs.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <scsi/scsi_proto.h>\n#include <asm/unaligned.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n#include <target/target_core_fabric.h>\n\n#include \"target_core_internal.h\"\n#include \"target_core_alua.h\"\n#include \"target_core_ua.h\"\n\nstatic sense_reason_t core_alua_check_transition(int state, int valid,\n\t\t\t\t\t\t int *primary, int explicit);\nstatic int core_alua_set_tg_pt_secondary_state(\n\t\tstruct se_lun *lun, int explicit, int offline);\n\nstatic char *core_alua_dump_state(int state);\n\nstatic void __target_attach_tg_pt_gp(struct se_lun *lun,\n\t\tstruct t10_alua_tg_pt_gp *tg_pt_gp);\n\nstatic u16 alua_lu_gps_counter;\nstatic u32 alua_lu_gps_count;\n\nstatic DEFINE_SPINLOCK(lu_gps_lock);\nstatic LIST_HEAD(lu_gps_list);\n\nstruct t10_alua_lu_gp *default_lu_gp;\n\n \nsense_reason_t\ntarget_emulate_report_referrals(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct t10_alua_lba_map *map;\n\tstruct t10_alua_lba_map_member *map_mem;\n\tunsigned char *buf;\n\tu32 rd_len = 0, off;\n\n\tif (cmd->data_length < 4) {\n\t\tpr_warn(\"REPORT REFERRALS allocation length %u too\"\n\t\t\t\" small\\n\", cmd->data_length);\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\toff = 4;\n\tspin_lock(&dev->t10_alua.lba_map_lock);\n\tif (list_empty(&dev->t10_alua.lba_map_list)) {\n\t\tspin_unlock(&dev->t10_alua.lba_map_lock);\n\t\ttransport_kunmap_data_sg(cmd);\n\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\t}\n\n\tlist_for_each_entry(map, &dev->t10_alua.lba_map_list,\n\t\t\t    lba_map_list) {\n\t\tint desc_num = off + 3;\n\t\tint pg_num;\n\n\t\toff += 4;\n\t\tif (cmd->data_length > off)\n\t\t\tput_unaligned_be64(map->lba_map_first_lba, &buf[off]);\n\t\toff += 8;\n\t\tif (cmd->data_length > off)\n\t\t\tput_unaligned_be64(map->lba_map_last_lba, &buf[off]);\n\t\toff += 8;\n\t\trd_len += 20;\n\t\tpg_num = 0;\n\t\tlist_for_each_entry(map_mem, &map->lba_map_mem_list,\n\t\t\t\t    lba_map_mem_list) {\n\t\t\tint alua_state = map_mem->lba_map_mem_alua_state;\n\t\t\tint alua_pg_id = map_mem->lba_map_mem_alua_pg_id;\n\n\t\t\tif (cmd->data_length > off)\n\t\t\t\tbuf[off] = alua_state & 0x0f;\n\t\t\toff += 2;\n\t\t\tif (cmd->data_length > off)\n\t\t\t\tbuf[off] = (alua_pg_id >> 8) & 0xff;\n\t\t\toff++;\n\t\t\tif (cmd->data_length > off)\n\t\t\t\tbuf[off] = (alua_pg_id & 0xff);\n\t\t\toff++;\n\t\t\trd_len += 4;\n\t\t\tpg_num++;\n\t\t}\n\t\tif (cmd->data_length > desc_num)\n\t\t\tbuf[desc_num] = pg_num;\n\t}\n\tspin_unlock(&dev->t10_alua.lba_map_lock);\n\n\t \n\tput_unaligned_be16(rd_len, &buf[2]);\n\n\ttransport_kunmap_data_sg(cmd);\n\n\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn 0;\n}\n\n \nsense_reason_t\ntarget_emulate_report_target_port_groups(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp;\n\tstruct se_lun *lun;\n\tunsigned char *buf;\n\tu32 rd_len = 0, off;\n\tint ext_hdr = (cmd->t_task_cdb[1] & 0x20);\n\n\t \n\tif (ext_hdr != 0)\n\t\toff = 8;\n\telse\n\t\toff = 4;\n\n\tif (cmd->data_length < off) {\n\t\tpr_warn(\"REPORT TARGET PORT GROUPS allocation length %u too\"\n\t\t\t\" small for %s header\\n\", cmd->data_length,\n\t\t\t(ext_hdr) ? \"extended\" : \"normal\");\n\t\treturn TCM_INVALID_CDB_FIELD;\n\t}\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tspin_lock(&dev->t10_alua.tg_pt_gps_lock);\n\tlist_for_each_entry(tg_pt_gp, &dev->t10_alua.tg_pt_gps_list,\n\t\t\ttg_pt_gp_list) {\n\t\t \n\t\tif (!tg_pt_gp->tg_pt_gp_members)\n\t\t\tcontinue;\n\t\t \n\t\tif ((off + 8 + (tg_pt_gp->tg_pt_gp_members * 4)) >\n\t\t     cmd->data_length) {\n\t\t\trd_len += 8 + (tg_pt_gp->tg_pt_gp_members * 4);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (tg_pt_gp->tg_pt_gp_pref)\n\t\t\tbuf[off] = 0x80;\n\t\t \n\t\tbuf[off++] |= tg_pt_gp->tg_pt_gp_alua_access_state & 0xff;\n\t\t \n\t\tbuf[off++] |= tg_pt_gp->tg_pt_gp_alua_supported_states;\n\t\t \n\t\tput_unaligned_be16(tg_pt_gp->tg_pt_gp_id, &buf[off]);\n\t\toff += 2;\n\n\t\toff++;  \n\t\t \n\t\tbuf[off++] = (tg_pt_gp->tg_pt_gp_alua_access_status & 0xff);\n\t\t \n\t\tbuf[off++] = 0x00;\n\t\t \n\t\tbuf[off++] = (tg_pt_gp->tg_pt_gp_members & 0xff);\n\t\trd_len += 8;\n\n\t\tspin_lock(&tg_pt_gp->tg_pt_gp_lock);\n\t\tlist_for_each_entry(lun, &tg_pt_gp->tg_pt_gp_lun_list,\n\t\t\t\tlun_tg_pt_gp_link) {\n\t\t\t \n\t\t\toff += 2;  \n\t\t\t \n\t\t\tput_unaligned_be16(lun->lun_tpg->tpg_rtpi, &buf[off]);\n\t\t\toff += 2;\n\t\t\trd_len += 4;\n\t\t}\n\t\tspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\n\t}\n\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n\t \n\tput_unaligned_be32(rd_len, &buf[0]);\n\n\t \n\tif (ext_hdr != 0) {\n\t\tbuf[4] = 0x10;\n\t\t \n\t\trcu_read_lock();\n\t\ttg_pt_gp = rcu_dereference(cmd->se_lun->lun_tg_pt_gp);\n\t\tif (tg_pt_gp)\n\t\t\tbuf[5] = tg_pt_gp->tg_pt_gp_implicit_trans_secs;\n\t\trcu_read_unlock();\n\t}\n\ttransport_kunmap_data_sg(cmd);\n\n\ttarget_complete_cmd_with_length(cmd, SAM_STAT_GOOD, rd_len + 4);\n\treturn 0;\n}\n\n \nsense_reason_t\ntarget_emulate_set_target_port_groups(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tstruct se_lun *l_lun = cmd->se_lun;\n\tstruct se_node_acl *nacl = cmd->se_sess->se_node_acl;\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp = NULL, *l_tg_pt_gp;\n\tunsigned char *buf;\n\tunsigned char *ptr;\n\tsense_reason_t rc = TCM_NO_SENSE;\n\tu32 len = 4;  \n\tint alua_access_state, primary = 0, valid_states;\n\tu16 tg_pt_id, rtpi;\n\n\tif (cmd->data_length < 4) {\n\t\tpr_warn(\"SET TARGET PORT GROUPS parameter list length %u too\"\n\t\t\t\" small\\n\", cmd->data_length);\n\t\treturn TCM_INVALID_PARAMETER_LIST;\n\t}\n\n\tbuf = transport_kmap_data_sg(cmd);\n\tif (!buf)\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\t \n\trcu_read_lock();\n\tl_tg_pt_gp = rcu_dereference(l_lun->lun_tg_pt_gp);\n\tif (!l_tg_pt_gp) {\n\t\trcu_read_unlock();\n\t\tpr_err(\"Unable to access l_lun->tg_pt_gp\\n\");\n\t\trc = TCM_UNSUPPORTED_SCSI_OPCODE;\n\t\tgoto out;\n\t}\n\n\tif (!(l_tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICIT_ALUA)) {\n\t\trcu_read_unlock();\n\t\tpr_debug(\"Unable to process SET_TARGET_PORT_GROUPS\"\n\t\t\t\t\" while TPGS_EXPLICIT_ALUA is disabled\\n\");\n\t\trc = TCM_UNSUPPORTED_SCSI_OPCODE;\n\t\tgoto out;\n\t}\n\tvalid_states = l_tg_pt_gp->tg_pt_gp_alua_supported_states;\n\trcu_read_unlock();\n\n\tptr = &buf[4];  \n\n\twhile (len < cmd->data_length) {\n\t\tbool found = false;\n\t\talua_access_state = (ptr[0] & 0x0f);\n\t\t \n\t\trc = core_alua_check_transition(alua_access_state, valid_states,\n\t\t\t\t\t\t&primary, 1);\n\t\tif (rc) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (primary) {\n\t\t\ttg_pt_id = get_unaligned_be16(ptr + 2);\n\t\t\t \n\t\t\tspin_lock(&dev->t10_alua.tg_pt_gps_lock);\n\t\t\tlist_for_each_entry(tg_pt_gp,\n\t\t\t\t\t&dev->t10_alua.tg_pt_gps_list,\n\t\t\t\t\ttg_pt_gp_list) {\n\t\t\t\tif (!tg_pt_gp->tg_pt_gp_valid_id)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (tg_pt_id != tg_pt_gp->tg_pt_gp_id)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tatomic_inc_mb(&tg_pt_gp->tg_pt_gp_ref_cnt);\n\n\t\t\t\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n\n\t\t\t\tif (!core_alua_do_port_transition(tg_pt_gp,\n\t\t\t\t\t\tdev, l_lun, nacl,\n\t\t\t\t\t\talua_access_state, 1))\n\t\t\t\t\tfound = true;\n\n\t\t\t\tspin_lock(&dev->t10_alua.tg_pt_gps_lock);\n\t\t\t\tatomic_dec_mb(&tg_pt_gp->tg_pt_gp_ref_cnt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n\t\t} else {\n\t\t\tstruct se_lun *lun;\n\n\t\t\t \n\t\t\trtpi = get_unaligned_be16(ptr + 2);\n\t\t\t \n\t\t\tspin_lock(&dev->se_port_lock);\n\t\t\tlist_for_each_entry(lun, &dev->dev_sep_list,\n\t\t\t\t\t\t\tlun_dev_link) {\n\t\t\t\tif (lun->lun_tpg->tpg_rtpi != rtpi)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tspin_unlock(&dev->se_port_lock);\n\n\t\t\t\tif (!core_alua_set_tg_pt_secondary_state(\n\t\t\t\t\t\tlun, 1, 1))\n\t\t\t\t\tfound = true;\n\n\t\t\t\tspin_lock(&dev->se_port_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock(&dev->se_port_lock);\n\t\t}\n\n\t\tif (!found) {\n\t\t\trc = TCM_INVALID_PARAMETER_LIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tptr += 4;\n\t\tlen += 4;\n\t}\n\nout:\n\ttransport_kunmap_data_sg(cmd);\n\tif (!rc)\n\t\ttarget_complete_cmd(cmd, SAM_STAT_GOOD);\n\treturn rc;\n}\n\nstatic inline void core_alua_state_nonoptimized(\n\tstruct se_cmd *cmd,\n\tunsigned char *cdb,\n\tint nonop_delay_msecs)\n{\n\t \n\tcmd->se_cmd_flags |= SCF_ALUA_NON_OPTIMIZED;\n\tcmd->alua_nonop_delay = nonop_delay_msecs;\n}\n\nstatic inline sense_reason_t core_alua_state_lba_dependent(\n\tstruct se_cmd *cmd,\n\tu16 tg_pt_gp_id)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tu64 segment_size, segment_mult, sectors, lba;\n\n\t \n\tif (!(cmd->se_cmd_flags & SCF_SCSI_DATA_CDB))\n\t\treturn 0;\n\n\tspin_lock(&dev->t10_alua.lba_map_lock);\n\tsegment_size = dev->t10_alua.lba_map_segment_size;\n\tsegment_mult = dev->t10_alua.lba_map_segment_multiplier;\n\tsectors = cmd->data_length / dev->dev_attrib.block_size;\n\n\tlba = cmd->t_task_lba;\n\twhile (lba < cmd->t_task_lba + sectors) {\n\t\tstruct t10_alua_lba_map *cur_map = NULL, *map;\n\t\tstruct t10_alua_lba_map_member *map_mem;\n\n\t\tlist_for_each_entry(map, &dev->t10_alua.lba_map_list,\n\t\t\t\t    lba_map_list) {\n\t\t\tu64 start_lba, last_lba;\n\t\t\tu64 first_lba = map->lba_map_first_lba;\n\n\t\t\tif (segment_mult) {\n\t\t\t\tu64 tmp = lba;\n\t\t\t\tstart_lba = do_div(tmp, segment_size * segment_mult);\n\n\t\t\t\tlast_lba = first_lba + segment_size - 1;\n\t\t\t\tif (start_lba >= first_lba &&\n\t\t\t\t    start_lba <= last_lba) {\n\t\t\t\t\tlba += segment_size;\n\t\t\t\t\tcur_map = map;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlast_lba = map->lba_map_last_lba;\n\t\t\t\tif (lba >= first_lba && lba <= last_lba) {\n\t\t\t\t\tlba = last_lba + 1;\n\t\t\t\t\tcur_map = map;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!cur_map) {\n\t\t\tspin_unlock(&dev->t10_alua.lba_map_lock);\n\t\t\treturn TCM_ALUA_TG_PT_UNAVAILABLE;\n\t\t}\n\t\tlist_for_each_entry(map_mem, &cur_map->lba_map_mem_list,\n\t\t\t\t    lba_map_mem_list) {\n\t\t\tif (map_mem->lba_map_mem_alua_pg_id != tg_pt_gp_id)\n\t\t\t\tcontinue;\n\t\t\tswitch(map_mem->lba_map_mem_alua_state) {\n\t\t\tcase ALUA_ACCESS_STATE_STANDBY:\n\t\t\t\tspin_unlock(&dev->t10_alua.lba_map_lock);\n\t\t\t\treturn TCM_ALUA_TG_PT_STANDBY;\n\t\t\tcase ALUA_ACCESS_STATE_UNAVAILABLE:\n\t\t\t\tspin_unlock(&dev->t10_alua.lba_map_lock);\n\t\t\t\treturn TCM_ALUA_TG_PT_UNAVAILABLE;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&dev->t10_alua.lba_map_lock);\n\treturn 0;\n}\n\nstatic inline sense_reason_t core_alua_state_standby(\n\tstruct se_cmd *cmd,\n\tunsigned char *cdb)\n{\n\t \n\tswitch (cdb[0]) {\n\tcase INQUIRY:\n\tcase LOG_SELECT:\n\tcase LOG_SENSE:\n\tcase MODE_SELECT:\n\tcase MODE_SENSE:\n\tcase REPORT_LUNS:\n\tcase RECEIVE_DIAGNOSTIC:\n\tcase SEND_DIAGNOSTIC:\n\tcase READ_CAPACITY:\n\t\treturn 0;\n\tcase SERVICE_ACTION_IN_16:\n\t\tswitch (cdb[1] & 0x1f) {\n\t\tcase SAI_READ_CAPACITY_16:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn TCM_ALUA_TG_PT_STANDBY;\n\t\t}\n\tcase MAINTENANCE_IN:\n\t\tswitch (cdb[1] & 0x1f) {\n\t\tcase MI_REPORT_TARGET_PGS:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn TCM_ALUA_TG_PT_STANDBY;\n\t\t}\n\tcase MAINTENANCE_OUT:\n\t\tswitch (cdb[1]) {\n\t\tcase MO_SET_TARGET_PGS:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn TCM_ALUA_TG_PT_STANDBY;\n\t\t}\n\tcase REQUEST_SENSE:\n\tcase PERSISTENT_RESERVE_IN:\n\tcase PERSISTENT_RESERVE_OUT:\n\tcase READ_BUFFER:\n\tcase WRITE_BUFFER:\n\t\treturn 0;\n\tdefault:\n\t\treturn TCM_ALUA_TG_PT_STANDBY;\n\t}\n\n\treturn 0;\n}\n\nstatic inline sense_reason_t core_alua_state_unavailable(\n\tstruct se_cmd *cmd,\n\tunsigned char *cdb)\n{\n\t \n\tswitch (cdb[0]) {\n\tcase INQUIRY:\n\tcase REPORT_LUNS:\n\t\treturn 0;\n\tcase MAINTENANCE_IN:\n\t\tswitch (cdb[1] & 0x1f) {\n\t\tcase MI_REPORT_TARGET_PGS:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn TCM_ALUA_TG_PT_UNAVAILABLE;\n\t\t}\n\tcase MAINTENANCE_OUT:\n\t\tswitch (cdb[1]) {\n\t\tcase MO_SET_TARGET_PGS:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn TCM_ALUA_TG_PT_UNAVAILABLE;\n\t\t}\n\tcase REQUEST_SENSE:\n\tcase READ_BUFFER:\n\tcase WRITE_BUFFER:\n\t\treturn 0;\n\tdefault:\n\t\treturn TCM_ALUA_TG_PT_UNAVAILABLE;\n\t}\n\n\treturn 0;\n}\n\nstatic inline sense_reason_t core_alua_state_transition(\n\tstruct se_cmd *cmd,\n\tunsigned char *cdb)\n{\n\t \n\tswitch (cdb[0]) {\n\tcase INQUIRY:\n\tcase REPORT_LUNS:\n\t\treturn 0;\n\tcase MAINTENANCE_IN:\n\t\tswitch (cdb[1] & 0x1f) {\n\t\tcase MI_REPORT_TARGET_PGS:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn TCM_ALUA_STATE_TRANSITION;\n\t\t}\n\tcase REQUEST_SENSE:\n\tcase READ_BUFFER:\n\tcase WRITE_BUFFER:\n\t\treturn 0;\n\tdefault:\n\t\treturn TCM_ALUA_STATE_TRANSITION;\n\t}\n\n\treturn 0;\n}\n\n \nsense_reason_t\ntarget_alua_state_check(struct se_cmd *cmd)\n{\n\tstruct se_device *dev = cmd->se_dev;\n\tunsigned char *cdb = cmd->t_task_cdb;\n\tstruct se_lun *lun = cmd->se_lun;\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp;\n\tint out_alua_state, nonop_delay_msecs;\n\tu16 tg_pt_gp_id;\n\tsense_reason_t rc = TCM_NO_SENSE;\n\n\tif (dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE)\n\t\treturn 0;\n\tif (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_ALUA)\n\t\treturn 0;\n\n\t \n\tif (atomic_read(&lun->lun_tg_pt_secondary_offline)) {\n\t\tpr_debug(\"ALUA: Got secondary offline status for local\"\n\t\t\t\t\" target port\\n\");\n\t\treturn TCM_ALUA_OFFLINE;\n\t}\n\trcu_read_lock();\n\ttg_pt_gp = rcu_dereference(lun->lun_tg_pt_gp);\n\tif (!tg_pt_gp) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tout_alua_state = tg_pt_gp->tg_pt_gp_alua_access_state;\n\tnonop_delay_msecs = tg_pt_gp->tg_pt_gp_nonop_delay_msecs;\n\ttg_pt_gp_id = tg_pt_gp->tg_pt_gp_id;\n\trcu_read_unlock();\n\t \n\tif (out_alua_state == ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED)\n\t\treturn 0;\n\n\tswitch (out_alua_state) {\n\tcase ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED:\n\t\tcore_alua_state_nonoptimized(cmd, cdb, nonop_delay_msecs);\n\t\tbreak;\n\tcase ALUA_ACCESS_STATE_STANDBY:\n\t\trc = core_alua_state_standby(cmd, cdb);\n\t\tbreak;\n\tcase ALUA_ACCESS_STATE_UNAVAILABLE:\n\t\trc = core_alua_state_unavailable(cmd, cdb);\n\t\tbreak;\n\tcase ALUA_ACCESS_STATE_TRANSITION:\n\t\trc = core_alua_state_transition(cmd, cdb);\n\t\tbreak;\n\tcase ALUA_ACCESS_STATE_LBA_DEPENDENT:\n\t\trc = core_alua_state_lba_dependent(cmd, tg_pt_gp_id);\n\t\tbreak;\n\t \n\tcase ALUA_ACCESS_STATE_OFFLINE:\n\tdefault:\n\t\tpr_err(\"Unknown ALUA access state: 0x%02x\\n\",\n\t\t\t\tout_alua_state);\n\t\trc = TCM_INVALID_CDB_FIELD;\n\t}\n\n\tif (rc && rc != TCM_INVALID_CDB_FIELD) {\n\t\tpr_debug(\"[%s]: ALUA TG Port not available, \"\n\t\t\t\"SenseKey: NOT_READY, ASC/rc: 0x04/%d\\n\",\n\t\t\tcmd->se_tfo->fabric_name, rc);\n\t}\n\n\treturn rc;\n}\n\n \nstatic sense_reason_t\ncore_alua_check_transition(int state, int valid, int *primary, int explicit)\n{\n\t \n\tswitch (state) {\n\tcase ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED:\n\t\tif (!(valid & ALUA_AO_SUP))\n\t\t\tgoto not_supported;\n\t\t*primary = 1;\n\t\tbreak;\n\tcase ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED:\n\t\tif (!(valid & ALUA_AN_SUP))\n\t\t\tgoto not_supported;\n\t\t*primary = 1;\n\t\tbreak;\n\tcase ALUA_ACCESS_STATE_STANDBY:\n\t\tif (!(valid & ALUA_S_SUP))\n\t\t\tgoto not_supported;\n\t\t*primary = 1;\n\t\tbreak;\n\tcase ALUA_ACCESS_STATE_UNAVAILABLE:\n\t\tif (!(valid & ALUA_U_SUP))\n\t\t\tgoto not_supported;\n\t\t*primary = 1;\n\t\tbreak;\n\tcase ALUA_ACCESS_STATE_LBA_DEPENDENT:\n\t\tif (!(valid & ALUA_LBD_SUP))\n\t\t\tgoto not_supported;\n\t\t*primary = 1;\n\t\tbreak;\n\tcase ALUA_ACCESS_STATE_OFFLINE:\n\t\t \n\t\tif (!(valid & ALUA_O_SUP))\n\t\t\tgoto not_supported;\n\t\t*primary = 0;\n\t\tbreak;\n\tcase ALUA_ACCESS_STATE_TRANSITION:\n\t\tif (!(valid & ALUA_T_SUP) || explicit)\n\t\t\t \n\t\t\tgoto not_supported;\n\t\t*primary = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown ALUA access state: 0x%02x\\n\", state);\n\t\treturn TCM_INVALID_PARAMETER_LIST;\n\t}\n\n\treturn 0;\n\nnot_supported:\n\tpr_err(\"ALUA access state %s not supported\",\n\t       core_alua_dump_state(state));\n\treturn TCM_INVALID_PARAMETER_LIST;\n}\n\nstatic char *core_alua_dump_state(int state)\n{\n\tswitch (state) {\n\tcase ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED:\n\t\treturn \"Active/Optimized\";\n\tcase ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED:\n\t\treturn \"Active/NonOptimized\";\n\tcase ALUA_ACCESS_STATE_LBA_DEPENDENT:\n\t\treturn \"LBA Dependent\";\n\tcase ALUA_ACCESS_STATE_STANDBY:\n\t\treturn \"Standby\";\n\tcase ALUA_ACCESS_STATE_UNAVAILABLE:\n\t\treturn \"Unavailable\";\n\tcase ALUA_ACCESS_STATE_OFFLINE:\n\t\treturn \"Offline\";\n\tcase ALUA_ACCESS_STATE_TRANSITION:\n\t\treturn \"Transitioning\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n\n\treturn NULL;\n}\n\nchar *core_alua_dump_status(int status)\n{\n\tswitch (status) {\n\tcase ALUA_STATUS_NONE:\n\t\treturn \"None\";\n\tcase ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG:\n\t\treturn \"Altered by Explicit STPG\";\n\tcase ALUA_STATUS_ALTERED_BY_IMPLICIT_ALUA:\n\t\treturn \"Altered by Implicit ALUA\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n\n\treturn NULL;\n}\n\n \nint core_alua_check_nonop_delay(\n\tstruct se_cmd *cmd)\n{\n\tif (!(cmd->se_cmd_flags & SCF_ALUA_NON_OPTIMIZED))\n\t\treturn 0;\n\t \n\tif (!cmd->alua_nonop_delay)\n\t\treturn 0;\n\t \n\tmsleep_interruptible(cmd->alua_nonop_delay);\n\treturn 0;\n}\nEXPORT_SYMBOL(core_alua_check_nonop_delay);\n\nstatic int core_alua_write_tpg_metadata(\n\tconst char *path,\n\tunsigned char *md_buf,\n\tu32 md_buf_len)\n{\n\tstruct file *file = filp_open(path, O_RDWR | O_CREAT | O_TRUNC, 0600);\n\tloff_t pos = 0;\n\tint ret;\n\n\tif (IS_ERR(file)) {\n\t\tpr_err(\"filp_open(%s) for ALUA metadata failed\\n\", path);\n\t\treturn -ENODEV;\n\t}\n\tret = kernel_write(file, md_buf, md_buf_len, &pos);\n\tif (ret < 0)\n\t\tpr_err(\"Error writing ALUA metadata file: %s\\n\", path);\n\tfput(file);\n\treturn (ret < 0) ? -EIO : 0;\n}\n\nstatic int core_alua_update_tpg_primary_metadata(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp)\n{\n\tunsigned char *md_buf;\n\tstruct t10_wwn *wwn = &tg_pt_gp->tg_pt_gp_dev->t10_wwn;\n\tchar *path;\n\tint len, rc;\n\n\tlockdep_assert_held(&tg_pt_gp->tg_pt_gp_transition_mutex);\n\n\tmd_buf = kzalloc(ALUA_MD_BUF_LEN, GFP_KERNEL);\n\tif (!md_buf) {\n\t\tpr_err(\"Unable to allocate buf for ALUA metadata\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlen = snprintf(md_buf, ALUA_MD_BUF_LEN,\n\t\t\t\"tg_pt_gp_id=%hu\\n\"\n\t\t\t\"alua_access_state=0x%02x\\n\"\n\t\t\t\"alua_access_status=0x%02x\\n\",\n\t\t\ttg_pt_gp->tg_pt_gp_id,\n\t\t\ttg_pt_gp->tg_pt_gp_alua_access_state,\n\t\t\ttg_pt_gp->tg_pt_gp_alua_access_status);\n\n\trc = -ENOMEM;\n\tpath = kasprintf(GFP_KERNEL, \"%s/alua/tpgs_%s/%s\", db_root,\n\t\t\t&wwn->unit_serial[0],\n\t\t\tconfig_item_name(&tg_pt_gp->tg_pt_gp_group.cg_item));\n\tif (path) {\n\t\trc = core_alua_write_tpg_metadata(path, md_buf, len);\n\t\tkfree(path);\n\t}\n\tkfree(md_buf);\n\treturn rc;\n}\n\nstatic void core_alua_queue_state_change_ua(struct t10_alua_tg_pt_gp *tg_pt_gp)\n{\n\tstruct se_dev_entry *se_deve;\n\tstruct se_lun *lun;\n\tstruct se_lun_acl *lacl;\n\n\tspin_lock(&tg_pt_gp->tg_pt_gp_lock);\n\tlist_for_each_entry(lun, &tg_pt_gp->tg_pt_gp_lun_list,\n\t\t\t\tlun_tg_pt_gp_link) {\n\t\t \n\t\tif (!percpu_ref_tryget_live(&lun->lun_ref))\n\t\t\tcontinue;\n\t\tspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\n\n\t\tspin_lock(&lun->lun_deve_lock);\n\t\tlist_for_each_entry(se_deve, &lun->lun_deve_list, lun_link) {\n\t\t\tlacl = se_deve->se_lun_acl;\n\n\t\t\t \n\t\t\tif ((tg_pt_gp->tg_pt_gp_alua_access_status ==\n\t\t\t     ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG) &&\n\t\t\t   (tg_pt_gp->tg_pt_gp_alua_lun != NULL) &&\n\t\t\t    (tg_pt_gp->tg_pt_gp_alua_lun == lun))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (lacl && (tg_pt_gp->tg_pt_gp_alua_nacl != NULL) &&\n\t\t\t    (tg_pt_gp->tg_pt_gp_alua_nacl == lacl->se_lun_nacl))\n\t\t\t\tcontinue;\n\n\t\t\tcore_scsi3_ua_allocate(se_deve, 0x2A,\n\t\t\t\tASCQ_2AH_ASYMMETRIC_ACCESS_STATE_CHANGED);\n\t\t}\n\t\tspin_unlock(&lun->lun_deve_lock);\n\n\t\tspin_lock(&tg_pt_gp->tg_pt_gp_lock);\n\t\tpercpu_ref_put(&lun->lun_ref);\n\t}\n\tspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\n}\n\nstatic int core_alua_do_transition_tg_pt(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp,\n\tint new_state,\n\tint explicit)\n{\n\tint prev_state;\n\n\tmutex_lock(&tg_pt_gp->tg_pt_gp_transition_mutex);\n\t \n\tif (tg_pt_gp->tg_pt_gp_alua_access_state == new_state) {\n\t\tmutex_unlock(&tg_pt_gp->tg_pt_gp_transition_mutex);\n\t\treturn 0;\n\t}\n\n\tif (explicit && new_state == ALUA_ACCESS_STATE_TRANSITION) {\n\t\tmutex_unlock(&tg_pt_gp->tg_pt_gp_transition_mutex);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tprev_state = tg_pt_gp->tg_pt_gp_alua_access_state;\n\ttg_pt_gp->tg_pt_gp_alua_access_state = ALUA_ACCESS_STATE_TRANSITION;\n\ttg_pt_gp->tg_pt_gp_alua_access_status = (explicit) ?\n\t\t\t\tALUA_STATUS_ALTERED_BY_EXPLICIT_STPG :\n\t\t\t\tALUA_STATUS_ALTERED_BY_IMPLICIT_ALUA;\n\n\tcore_alua_queue_state_change_ua(tg_pt_gp);\n\n\tif (new_state == ALUA_ACCESS_STATE_TRANSITION) {\n\t\tmutex_unlock(&tg_pt_gp->tg_pt_gp_transition_mutex);\n\t\treturn 0;\n\t}\n\n\t \n\tif (tg_pt_gp->tg_pt_gp_trans_delay_msecs != 0)\n\t\tmsleep_interruptible(tg_pt_gp->tg_pt_gp_trans_delay_msecs);\n\n\t \n\ttg_pt_gp->tg_pt_gp_alua_access_state = new_state;\n\n\t \n\tif (tg_pt_gp->tg_pt_gp_write_metadata) {\n\t\tcore_alua_update_tpg_primary_metadata(tg_pt_gp);\n\t}\n\n\tpr_debug(\"Successful %s ALUA transition TG PT Group: %s ID: %hu\"\n\t\t\" from primary access state %s to %s\\n\", (explicit) ? \"explicit\" :\n\t\t\"implicit\", config_item_name(&tg_pt_gp->tg_pt_gp_group.cg_item),\n\t\ttg_pt_gp->tg_pt_gp_id,\n\t\tcore_alua_dump_state(prev_state),\n\t\tcore_alua_dump_state(new_state));\n\n\tcore_alua_queue_state_change_ua(tg_pt_gp);\n\n\tmutex_unlock(&tg_pt_gp->tg_pt_gp_transition_mutex);\n\treturn 0;\n}\n\nint core_alua_do_port_transition(\n\tstruct t10_alua_tg_pt_gp *l_tg_pt_gp,\n\tstruct se_device *l_dev,\n\tstruct se_lun *l_lun,\n\tstruct se_node_acl *l_nacl,\n\tint new_state,\n\tint explicit)\n{\n\tstruct se_device *dev;\n\tstruct t10_alua_lu_gp *lu_gp;\n\tstruct t10_alua_lu_gp_member *lu_gp_mem, *local_lu_gp_mem;\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp;\n\tint primary, valid_states, rc = 0;\n\n\tif (l_dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_ALUA)\n\t\treturn -ENODEV;\n\n\tvalid_states = l_tg_pt_gp->tg_pt_gp_alua_supported_states;\n\tif (core_alua_check_transition(new_state, valid_states, &primary,\n\t\t\t\t       explicit) != 0)\n\t\treturn -EINVAL;\n\n\tlocal_lu_gp_mem = l_dev->dev_alua_lu_gp_mem;\n\tspin_lock(&local_lu_gp_mem->lu_gp_mem_lock);\n\tlu_gp = local_lu_gp_mem->lu_gp;\n\tatomic_inc(&lu_gp->lu_gp_ref_cnt);\n\tspin_unlock(&local_lu_gp_mem->lu_gp_mem_lock);\n\t \n\tif (!lu_gp->lu_gp_id) {\n\t\t \n\t\tl_tg_pt_gp->tg_pt_gp_alua_lun = l_lun;\n\t\tl_tg_pt_gp->tg_pt_gp_alua_nacl = l_nacl;\n\t\trc = core_alua_do_transition_tg_pt(l_tg_pt_gp,\n\t\t\t\t\t\t   new_state, explicit);\n\t\tatomic_dec_mb(&lu_gp->lu_gp_ref_cnt);\n\t\treturn rc;\n\t}\n\t \n\tspin_lock(&lu_gp->lu_gp_lock);\n\tlist_for_each_entry(lu_gp_mem, &lu_gp->lu_gp_mem_list,\n\t\t\t\tlu_gp_mem_list) {\n\n\t\tdev = lu_gp_mem->lu_gp_mem_dev;\n\t\tatomic_inc_mb(&lu_gp_mem->lu_gp_mem_ref_cnt);\n\t\tspin_unlock(&lu_gp->lu_gp_lock);\n\n\t\tspin_lock(&dev->t10_alua.tg_pt_gps_lock);\n\t\tlist_for_each_entry(tg_pt_gp,\n\t\t\t\t&dev->t10_alua.tg_pt_gps_list,\n\t\t\t\ttg_pt_gp_list) {\n\n\t\t\tif (!tg_pt_gp->tg_pt_gp_valid_id)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (l_tg_pt_gp->tg_pt_gp_id != tg_pt_gp->tg_pt_gp_id)\n\t\t\t\tcontinue;\n\n\t\t\tif (l_tg_pt_gp == tg_pt_gp) {\n\t\t\t\ttg_pt_gp->tg_pt_gp_alua_lun = l_lun;\n\t\t\t\ttg_pt_gp->tg_pt_gp_alua_nacl = l_nacl;\n\t\t\t} else {\n\t\t\t\ttg_pt_gp->tg_pt_gp_alua_lun = NULL;\n\t\t\t\ttg_pt_gp->tg_pt_gp_alua_nacl = NULL;\n\t\t\t}\n\t\t\tatomic_inc_mb(&tg_pt_gp->tg_pt_gp_ref_cnt);\n\t\t\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n\t\t\t \n\t\t\trc = core_alua_do_transition_tg_pt(tg_pt_gp,\n\t\t\t\t\tnew_state, explicit);\n\n\t\t\tspin_lock(&dev->t10_alua.tg_pt_gps_lock);\n\t\t\tatomic_dec_mb(&tg_pt_gp->tg_pt_gp_ref_cnt);\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n\n\t\tspin_lock(&lu_gp->lu_gp_lock);\n\t\tatomic_dec_mb(&lu_gp_mem->lu_gp_mem_ref_cnt);\n\t}\n\tspin_unlock(&lu_gp->lu_gp_lock);\n\n\tif (!rc) {\n\t\tpr_debug(\"Successfully processed LU Group: %s all ALUA TG PT\"\n\t\t\t \" Group IDs: %hu %s transition to primary state: %s\\n\",\n\t\t\t config_item_name(&lu_gp->lu_gp_group.cg_item),\n\t\t\t l_tg_pt_gp->tg_pt_gp_id,\n\t\t\t (explicit) ? \"explicit\" : \"implicit\",\n\t\t\t core_alua_dump_state(new_state));\n\t}\n\n\tatomic_dec_mb(&lu_gp->lu_gp_ref_cnt);\n\treturn rc;\n}\n\nstatic int core_alua_update_tpg_secondary_metadata(struct se_lun *lun)\n{\n\tstruct se_portal_group *se_tpg = lun->lun_tpg;\n\tunsigned char *md_buf;\n\tchar *path;\n\tint len, rc;\n\n\tmutex_lock(&lun->lun_tg_pt_md_mutex);\n\n\tmd_buf = kzalloc(ALUA_MD_BUF_LEN, GFP_KERNEL);\n\tif (!md_buf) {\n\t\tpr_err(\"Unable to allocate buf for ALUA metadata\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tlen = snprintf(md_buf, ALUA_MD_BUF_LEN, \"alua_tg_pt_offline=%d\\n\"\n\t\t\t\"alua_tg_pt_status=0x%02x\\n\",\n\t\t\tatomic_read(&lun->lun_tg_pt_secondary_offline),\n\t\t\tlun->lun_tg_pt_secondary_stat);\n\n\tif (se_tpg->se_tpg_tfo->tpg_get_tag != NULL) {\n\t\tpath = kasprintf(GFP_KERNEL, \"%s/alua/%s/%s+%hu/lun_%llu\",\n\t\t\t\tdb_root, se_tpg->se_tpg_tfo->fabric_name,\n\t\t\t\tse_tpg->se_tpg_tfo->tpg_get_wwn(se_tpg),\n\t\t\t\tse_tpg->se_tpg_tfo->tpg_get_tag(se_tpg),\n\t\t\t\tlun->unpacked_lun);\n\t} else {\n\t\tpath = kasprintf(GFP_KERNEL, \"%s/alua/%s/%s/lun_%llu\",\n\t\t\t\tdb_root, se_tpg->se_tpg_tfo->fabric_name,\n\t\t\t\tse_tpg->se_tpg_tfo->tpg_get_wwn(se_tpg),\n\t\t\t\tlun->unpacked_lun);\n\t}\n\tif (!path) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\trc = core_alua_write_tpg_metadata(path, md_buf, len);\n\tkfree(path);\nout_free:\n\tkfree(md_buf);\nout_unlock:\n\tmutex_unlock(&lun->lun_tg_pt_md_mutex);\n\treturn rc;\n}\n\nstatic int core_alua_set_tg_pt_secondary_state(\n\tstruct se_lun *lun,\n\tint explicit,\n\tint offline)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp;\n\tint trans_delay_msecs;\n\n\trcu_read_lock();\n\ttg_pt_gp = rcu_dereference(lun->lun_tg_pt_gp);\n\tif (!tg_pt_gp) {\n\t\trcu_read_unlock();\n\t\tpr_err(\"Unable to complete secondary state\"\n\t\t\t\t\" transition\\n\");\n\t\treturn -EINVAL;\n\t}\n\ttrans_delay_msecs = tg_pt_gp->tg_pt_gp_trans_delay_msecs;\n\t \n\tif (offline)\n\t\tatomic_set(&lun->lun_tg_pt_secondary_offline, 1);\n\telse\n\t\tatomic_set(&lun->lun_tg_pt_secondary_offline, 0);\n\n\tlun->lun_tg_pt_secondary_stat = (explicit) ?\n\t\t\tALUA_STATUS_ALTERED_BY_EXPLICIT_STPG :\n\t\t\tALUA_STATUS_ALTERED_BY_IMPLICIT_ALUA;\n\n\tpr_debug(\"Successful %s ALUA transition TG PT Group: %s ID: %hu\"\n\t\t\" to secondary access state: %s\\n\", (explicit) ? \"explicit\" :\n\t\t\"implicit\", config_item_name(&tg_pt_gp->tg_pt_gp_group.cg_item),\n\t\ttg_pt_gp->tg_pt_gp_id, (offline) ? \"OFFLINE\" : \"ONLINE\");\n\n\trcu_read_unlock();\n\t \n\tif (trans_delay_msecs != 0)\n\t\tmsleep_interruptible(trans_delay_msecs);\n\t \n\tif (lun->lun_tg_pt_secondary_write_md)\n\t\tcore_alua_update_tpg_secondary_metadata(lun);\n\n\treturn 0;\n}\n\nstruct t10_alua_lba_map *\ncore_alua_allocate_lba_map(struct list_head *list,\n\t\t\t   u64 first_lba, u64 last_lba)\n{\n\tstruct t10_alua_lba_map *lba_map;\n\n\tlba_map = kmem_cache_zalloc(t10_alua_lba_map_cache, GFP_KERNEL);\n\tif (!lba_map) {\n\t\tpr_err(\"Unable to allocate struct t10_alua_lba_map\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tINIT_LIST_HEAD(&lba_map->lba_map_mem_list);\n\tlba_map->lba_map_first_lba = first_lba;\n\tlba_map->lba_map_last_lba = last_lba;\n\n\tlist_add_tail(&lba_map->lba_map_list, list);\n\treturn lba_map;\n}\n\nint\ncore_alua_allocate_lba_map_mem(struct t10_alua_lba_map *lba_map,\n\t\t\t       int pg_id, int state)\n{\n\tstruct t10_alua_lba_map_member *lba_map_mem;\n\n\tlist_for_each_entry(lba_map_mem, &lba_map->lba_map_mem_list,\n\t\t\t    lba_map_mem_list) {\n\t\tif (lba_map_mem->lba_map_mem_alua_pg_id == pg_id) {\n\t\t\tpr_err(\"Duplicate pg_id %d in lba_map\\n\", pg_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tlba_map_mem = kmem_cache_zalloc(t10_alua_lba_map_mem_cache, GFP_KERNEL);\n\tif (!lba_map_mem) {\n\t\tpr_err(\"Unable to allocate struct t10_alua_lba_map_mem\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tlba_map_mem->lba_map_mem_alua_state = state;\n\tlba_map_mem->lba_map_mem_alua_pg_id = pg_id;\n\n\tlist_add_tail(&lba_map_mem->lba_map_mem_list,\n\t\t      &lba_map->lba_map_mem_list);\n\treturn 0;\n}\n\nvoid\ncore_alua_free_lba_map(struct list_head *lba_list)\n{\n\tstruct t10_alua_lba_map *lba_map, *lba_map_tmp;\n\tstruct t10_alua_lba_map_member *lba_map_mem, *lba_map_mem_tmp;\n\n\tlist_for_each_entry_safe(lba_map, lba_map_tmp, lba_list,\n\t\t\t\t lba_map_list) {\n\t\tlist_for_each_entry_safe(lba_map_mem, lba_map_mem_tmp,\n\t\t\t\t\t &lba_map->lba_map_mem_list,\n\t\t\t\t\t lba_map_mem_list) {\n\t\t\tlist_del(&lba_map_mem->lba_map_mem_list);\n\t\t\tkmem_cache_free(t10_alua_lba_map_mem_cache,\n\t\t\t\t\tlba_map_mem);\n\t\t}\n\t\tlist_del(&lba_map->lba_map_list);\n\t\tkmem_cache_free(t10_alua_lba_map_cache, lba_map);\n\t}\n}\n\nvoid\ncore_alua_set_lba_map(struct se_device *dev, struct list_head *lba_map_list,\n\t\t      int segment_size, int segment_mult)\n{\n\tstruct list_head old_lba_map_list;\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp;\n\tint activate = 0, supported;\n\n\tINIT_LIST_HEAD(&old_lba_map_list);\n\tspin_lock(&dev->t10_alua.lba_map_lock);\n\tdev->t10_alua.lba_map_segment_size = segment_size;\n\tdev->t10_alua.lba_map_segment_multiplier = segment_mult;\n\tlist_splice_init(&dev->t10_alua.lba_map_list, &old_lba_map_list);\n\tif (lba_map_list) {\n\t\tlist_splice_init(lba_map_list, &dev->t10_alua.lba_map_list);\n\t\tactivate = 1;\n\t}\n\tspin_unlock(&dev->t10_alua.lba_map_lock);\n\tspin_lock(&dev->t10_alua.tg_pt_gps_lock);\n\tlist_for_each_entry(tg_pt_gp, &dev->t10_alua.tg_pt_gps_list,\n\t\t\t    tg_pt_gp_list) {\n\n\t\tif (!tg_pt_gp->tg_pt_gp_valid_id)\n\t\t\tcontinue;\n\t\tsupported = tg_pt_gp->tg_pt_gp_alua_supported_states;\n\t\tif (activate)\n\t\t\tsupported |= ALUA_LBD_SUP;\n\t\telse\n\t\t\tsupported &= ~ALUA_LBD_SUP;\n\t\ttg_pt_gp->tg_pt_gp_alua_supported_states = supported;\n\t}\n\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n\tcore_alua_free_lba_map(&old_lba_map_list);\n}\n\nstruct t10_alua_lu_gp *\ncore_alua_allocate_lu_gp(const char *name, int def_group)\n{\n\tstruct t10_alua_lu_gp *lu_gp;\n\n\tlu_gp = kmem_cache_zalloc(t10_alua_lu_gp_cache, GFP_KERNEL);\n\tif (!lu_gp) {\n\t\tpr_err(\"Unable to allocate struct t10_alua_lu_gp\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tINIT_LIST_HEAD(&lu_gp->lu_gp_node);\n\tINIT_LIST_HEAD(&lu_gp->lu_gp_mem_list);\n\tspin_lock_init(&lu_gp->lu_gp_lock);\n\tatomic_set(&lu_gp->lu_gp_ref_cnt, 0);\n\n\tif (def_group) {\n\t\tlu_gp->lu_gp_id = alua_lu_gps_counter++;\n\t\tlu_gp->lu_gp_valid_id = 1;\n\t\talua_lu_gps_count++;\n\t}\n\n\treturn lu_gp;\n}\n\nint core_alua_set_lu_gp_id(struct t10_alua_lu_gp *lu_gp, u16 lu_gp_id)\n{\n\tstruct t10_alua_lu_gp *lu_gp_tmp;\n\tu16 lu_gp_id_tmp;\n\t \n\tif (lu_gp->lu_gp_valid_id) {\n\t\tpr_warn(\"ALUA LU Group already has a valid ID,\"\n\t\t\t\" ignoring request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&lu_gps_lock);\n\tif (alua_lu_gps_count == 0x0000ffff) {\n\t\tpr_err(\"Maximum ALUA alua_lu_gps_count:\"\n\t\t\t\t\" 0x0000ffff reached\\n\");\n\t\tspin_unlock(&lu_gps_lock);\n\t\tkmem_cache_free(t10_alua_lu_gp_cache, lu_gp);\n\t\treturn -ENOSPC;\n\t}\nagain:\n\tlu_gp_id_tmp = (lu_gp_id != 0) ? lu_gp_id :\n\t\t\t\talua_lu_gps_counter++;\n\n\tlist_for_each_entry(lu_gp_tmp, &lu_gps_list, lu_gp_node) {\n\t\tif (lu_gp_tmp->lu_gp_id == lu_gp_id_tmp) {\n\t\t\tif (!lu_gp_id)\n\t\t\t\tgoto again;\n\n\t\t\tpr_warn(\"ALUA Logical Unit Group ID: %hu\"\n\t\t\t\t\" already exists, ignoring request\\n\",\n\t\t\t\tlu_gp_id);\n\t\t\tspin_unlock(&lu_gps_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tlu_gp->lu_gp_id = lu_gp_id_tmp;\n\tlu_gp->lu_gp_valid_id = 1;\n\tlist_add_tail(&lu_gp->lu_gp_node, &lu_gps_list);\n\talua_lu_gps_count++;\n\tspin_unlock(&lu_gps_lock);\n\n\treturn 0;\n}\n\nstatic struct t10_alua_lu_gp_member *\ncore_alua_allocate_lu_gp_mem(struct se_device *dev)\n{\n\tstruct t10_alua_lu_gp_member *lu_gp_mem;\n\n\tlu_gp_mem = kmem_cache_zalloc(t10_alua_lu_gp_mem_cache, GFP_KERNEL);\n\tif (!lu_gp_mem) {\n\t\tpr_err(\"Unable to allocate struct t10_alua_lu_gp_member\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tINIT_LIST_HEAD(&lu_gp_mem->lu_gp_mem_list);\n\tspin_lock_init(&lu_gp_mem->lu_gp_mem_lock);\n\tatomic_set(&lu_gp_mem->lu_gp_mem_ref_cnt, 0);\n\n\tlu_gp_mem->lu_gp_mem_dev = dev;\n\tdev->dev_alua_lu_gp_mem = lu_gp_mem;\n\n\treturn lu_gp_mem;\n}\n\nvoid core_alua_free_lu_gp(struct t10_alua_lu_gp *lu_gp)\n{\n\tstruct t10_alua_lu_gp_member *lu_gp_mem, *lu_gp_mem_tmp;\n\t \n\tspin_lock(&lu_gps_lock);\n\tlist_del(&lu_gp->lu_gp_node);\n\talua_lu_gps_count--;\n\tspin_unlock(&lu_gps_lock);\n\t \n\twhile (atomic_read(&lu_gp->lu_gp_ref_cnt))\n\t\tcpu_relax();\n\t \n\tspin_lock(&lu_gp->lu_gp_lock);\n\tlist_for_each_entry_safe(lu_gp_mem, lu_gp_mem_tmp,\n\t\t\t\t&lu_gp->lu_gp_mem_list, lu_gp_mem_list) {\n\t\tif (lu_gp_mem->lu_gp_assoc) {\n\t\t\tlist_del(&lu_gp_mem->lu_gp_mem_list);\n\t\t\tlu_gp->lu_gp_members--;\n\t\t\tlu_gp_mem->lu_gp_assoc = 0;\n\t\t}\n\t\tspin_unlock(&lu_gp->lu_gp_lock);\n\t\t \n\t\tspin_lock(&lu_gp_mem->lu_gp_mem_lock);\n\t\tif (lu_gp != default_lu_gp)\n\t\t\t__core_alua_attach_lu_gp_mem(lu_gp_mem,\n\t\t\t\t\tdefault_lu_gp);\n\t\telse\n\t\t\tlu_gp_mem->lu_gp = NULL;\n\t\tspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\n\n\t\tspin_lock(&lu_gp->lu_gp_lock);\n\t}\n\tspin_unlock(&lu_gp->lu_gp_lock);\n\n\tkmem_cache_free(t10_alua_lu_gp_cache, lu_gp);\n}\n\nvoid core_alua_free_lu_gp_mem(struct se_device *dev)\n{\n\tstruct t10_alua_lu_gp *lu_gp;\n\tstruct t10_alua_lu_gp_member *lu_gp_mem;\n\n\tlu_gp_mem = dev->dev_alua_lu_gp_mem;\n\tif (!lu_gp_mem)\n\t\treturn;\n\n\twhile (atomic_read(&lu_gp_mem->lu_gp_mem_ref_cnt))\n\t\tcpu_relax();\n\n\tspin_lock(&lu_gp_mem->lu_gp_mem_lock);\n\tlu_gp = lu_gp_mem->lu_gp;\n\tif (lu_gp) {\n\t\tspin_lock(&lu_gp->lu_gp_lock);\n\t\tif (lu_gp_mem->lu_gp_assoc) {\n\t\t\tlist_del(&lu_gp_mem->lu_gp_mem_list);\n\t\t\tlu_gp->lu_gp_members--;\n\t\t\tlu_gp_mem->lu_gp_assoc = 0;\n\t\t}\n\t\tspin_unlock(&lu_gp->lu_gp_lock);\n\t\tlu_gp_mem->lu_gp = NULL;\n\t}\n\tspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\n\n\tkmem_cache_free(t10_alua_lu_gp_mem_cache, lu_gp_mem);\n}\n\nstruct t10_alua_lu_gp *core_alua_get_lu_gp_by_name(const char *name)\n{\n\tstruct t10_alua_lu_gp *lu_gp;\n\tstruct config_item *ci;\n\n\tspin_lock(&lu_gps_lock);\n\tlist_for_each_entry(lu_gp, &lu_gps_list, lu_gp_node) {\n\t\tif (!lu_gp->lu_gp_valid_id)\n\t\t\tcontinue;\n\t\tci = &lu_gp->lu_gp_group.cg_item;\n\t\tif (!strcmp(config_item_name(ci), name)) {\n\t\t\tatomic_inc(&lu_gp->lu_gp_ref_cnt);\n\t\t\tspin_unlock(&lu_gps_lock);\n\t\t\treturn lu_gp;\n\t\t}\n\t}\n\tspin_unlock(&lu_gps_lock);\n\n\treturn NULL;\n}\n\nvoid core_alua_put_lu_gp_from_name(struct t10_alua_lu_gp *lu_gp)\n{\n\tspin_lock(&lu_gps_lock);\n\tatomic_dec(&lu_gp->lu_gp_ref_cnt);\n\tspin_unlock(&lu_gps_lock);\n}\n\n \nvoid __core_alua_attach_lu_gp_mem(\n\tstruct t10_alua_lu_gp_member *lu_gp_mem,\n\tstruct t10_alua_lu_gp *lu_gp)\n{\n\tspin_lock(&lu_gp->lu_gp_lock);\n\tlu_gp_mem->lu_gp = lu_gp;\n\tlu_gp_mem->lu_gp_assoc = 1;\n\tlist_add_tail(&lu_gp_mem->lu_gp_mem_list, &lu_gp->lu_gp_mem_list);\n\tlu_gp->lu_gp_members++;\n\tspin_unlock(&lu_gp->lu_gp_lock);\n}\n\n \nvoid __core_alua_drop_lu_gp_mem(\n\tstruct t10_alua_lu_gp_member *lu_gp_mem,\n\tstruct t10_alua_lu_gp *lu_gp)\n{\n\tspin_lock(&lu_gp->lu_gp_lock);\n\tlist_del(&lu_gp_mem->lu_gp_mem_list);\n\tlu_gp_mem->lu_gp = NULL;\n\tlu_gp_mem->lu_gp_assoc = 0;\n\tlu_gp->lu_gp_members--;\n\tspin_unlock(&lu_gp->lu_gp_lock);\n}\n\nstruct t10_alua_tg_pt_gp *core_alua_allocate_tg_pt_gp(struct se_device *dev,\n\t\tconst char *name, int def_group)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp;\n\n\ttg_pt_gp = kmem_cache_zalloc(t10_alua_tg_pt_gp_cache, GFP_KERNEL);\n\tif (!tg_pt_gp) {\n\t\tpr_err(\"Unable to allocate struct t10_alua_tg_pt_gp\\n\");\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&tg_pt_gp->tg_pt_gp_list);\n\tINIT_LIST_HEAD(&tg_pt_gp->tg_pt_gp_lun_list);\n\tmutex_init(&tg_pt_gp->tg_pt_gp_transition_mutex);\n\tspin_lock_init(&tg_pt_gp->tg_pt_gp_lock);\n\tatomic_set(&tg_pt_gp->tg_pt_gp_ref_cnt, 0);\n\ttg_pt_gp->tg_pt_gp_dev = dev;\n\ttg_pt_gp->tg_pt_gp_alua_access_state =\n\t\t\tALUA_ACCESS_STATE_ACTIVE_OPTIMIZED;\n\t \n\ttg_pt_gp->tg_pt_gp_alua_access_type =\n\t\t\tTPGS_EXPLICIT_ALUA | TPGS_IMPLICIT_ALUA;\n\t \n\ttg_pt_gp->tg_pt_gp_nonop_delay_msecs = ALUA_DEFAULT_NONOP_DELAY_MSECS;\n\ttg_pt_gp->tg_pt_gp_trans_delay_msecs = ALUA_DEFAULT_TRANS_DELAY_MSECS;\n\ttg_pt_gp->tg_pt_gp_implicit_trans_secs = ALUA_DEFAULT_IMPLICIT_TRANS_SECS;\n\n\t \n\ttg_pt_gp->tg_pt_gp_alua_supported_states =\n\t    ALUA_T_SUP | ALUA_O_SUP |\n\t    ALUA_U_SUP | ALUA_S_SUP | ALUA_AN_SUP | ALUA_AO_SUP;\n\n\tif (def_group) {\n\t\tspin_lock(&dev->t10_alua.tg_pt_gps_lock);\n\t\ttg_pt_gp->tg_pt_gp_id =\n\t\t\t\tdev->t10_alua.alua_tg_pt_gps_counter++;\n\t\ttg_pt_gp->tg_pt_gp_valid_id = 1;\n\t\tdev->t10_alua.alua_tg_pt_gps_count++;\n\t\tlist_add_tail(&tg_pt_gp->tg_pt_gp_list,\n\t\t\t      &dev->t10_alua.tg_pt_gps_list);\n\t\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n\t}\n\n\treturn tg_pt_gp;\n}\n\nint core_alua_set_tg_pt_gp_id(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp,\n\tu16 tg_pt_gp_id)\n{\n\tstruct se_device *dev = tg_pt_gp->tg_pt_gp_dev;\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp_tmp;\n\tu16 tg_pt_gp_id_tmp;\n\n\t \n\tif (tg_pt_gp->tg_pt_gp_valid_id) {\n\t\tpr_warn(\"ALUA TG PT Group already has a valid ID,\"\n\t\t\t\" ignoring request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&dev->t10_alua.tg_pt_gps_lock);\n\tif (dev->t10_alua.alua_tg_pt_gps_count == 0x0000ffff) {\n\t\tpr_err(\"Maximum ALUA alua_tg_pt_gps_count:\"\n\t\t\t\" 0x0000ffff reached\\n\");\n\t\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n\t\treturn -ENOSPC;\n\t}\nagain:\n\ttg_pt_gp_id_tmp = (tg_pt_gp_id != 0) ? tg_pt_gp_id :\n\t\t\tdev->t10_alua.alua_tg_pt_gps_counter++;\n\n\tlist_for_each_entry(tg_pt_gp_tmp, &dev->t10_alua.tg_pt_gps_list,\n\t\t\ttg_pt_gp_list) {\n\t\tif (tg_pt_gp_tmp->tg_pt_gp_id == tg_pt_gp_id_tmp) {\n\t\t\tif (!tg_pt_gp_id)\n\t\t\t\tgoto again;\n\n\t\t\tpr_err(\"ALUA Target Port Group ID: %hu already\"\n\t\t\t\t\" exists, ignoring request\\n\", tg_pt_gp_id);\n\t\t\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ttg_pt_gp->tg_pt_gp_id = tg_pt_gp_id_tmp;\n\ttg_pt_gp->tg_pt_gp_valid_id = 1;\n\tlist_add_tail(&tg_pt_gp->tg_pt_gp_list,\n\t\t\t&dev->t10_alua.tg_pt_gps_list);\n\tdev->t10_alua.alua_tg_pt_gps_count++;\n\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n\n\treturn 0;\n}\n\nvoid core_alua_free_tg_pt_gp(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp)\n{\n\tstruct se_device *dev = tg_pt_gp->tg_pt_gp_dev;\n\tstruct se_lun *lun, *next;\n\n\t \n\tspin_lock(&dev->t10_alua.tg_pt_gps_lock);\n\tif (tg_pt_gp->tg_pt_gp_valid_id) {\n\t\tlist_del(&tg_pt_gp->tg_pt_gp_list);\n\t\tdev->t10_alua.alua_tg_pt_gps_count--;\n\t}\n\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n\n\t \n\twhile (atomic_read(&tg_pt_gp->tg_pt_gp_ref_cnt))\n\t\tcpu_relax();\n\n\t \n\tspin_lock(&tg_pt_gp->tg_pt_gp_lock);\n\tlist_for_each_entry_safe(lun, next,\n\t\t\t&tg_pt_gp->tg_pt_gp_lun_list, lun_tg_pt_gp_link) {\n\t\tlist_del_init(&lun->lun_tg_pt_gp_link);\n\t\ttg_pt_gp->tg_pt_gp_members--;\n\n\t\tspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\n\t\t \n\t\tspin_lock(&lun->lun_tg_pt_gp_lock);\n\t\tif (tg_pt_gp != dev->t10_alua.default_tg_pt_gp) {\n\t\t\t__target_attach_tg_pt_gp(lun,\n\t\t\t\t\tdev->t10_alua.default_tg_pt_gp);\n\t\t} else\n\t\t\trcu_assign_pointer(lun->lun_tg_pt_gp, NULL);\n\t\tspin_unlock(&lun->lun_tg_pt_gp_lock);\n\n\t\tspin_lock(&tg_pt_gp->tg_pt_gp_lock);\n\t}\n\tspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\n\n\tsynchronize_rcu();\n\tkmem_cache_free(t10_alua_tg_pt_gp_cache, tg_pt_gp);\n}\n\nstatic struct t10_alua_tg_pt_gp *core_alua_get_tg_pt_gp_by_name(\n\t\tstruct se_device *dev, const char *name)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp;\n\tstruct config_item *ci;\n\n\tspin_lock(&dev->t10_alua.tg_pt_gps_lock);\n\tlist_for_each_entry(tg_pt_gp, &dev->t10_alua.tg_pt_gps_list,\n\t\t\ttg_pt_gp_list) {\n\t\tif (!tg_pt_gp->tg_pt_gp_valid_id)\n\t\t\tcontinue;\n\t\tci = &tg_pt_gp->tg_pt_gp_group.cg_item;\n\t\tif (!strcmp(config_item_name(ci), name)) {\n\t\t\tatomic_inc(&tg_pt_gp->tg_pt_gp_ref_cnt);\n\t\t\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n\t\t\treturn tg_pt_gp;\n\t\t}\n\t}\n\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n\n\treturn NULL;\n}\n\nstatic void core_alua_put_tg_pt_gp_from_name(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp)\n{\n\tstruct se_device *dev = tg_pt_gp->tg_pt_gp_dev;\n\n\tspin_lock(&dev->t10_alua.tg_pt_gps_lock);\n\tatomic_dec(&tg_pt_gp->tg_pt_gp_ref_cnt);\n\tspin_unlock(&dev->t10_alua.tg_pt_gps_lock);\n}\n\nstatic void __target_attach_tg_pt_gp(struct se_lun *lun,\n\t\tstruct t10_alua_tg_pt_gp *tg_pt_gp)\n{\n\tstruct se_dev_entry *se_deve;\n\n\tassert_spin_locked(&lun->lun_tg_pt_gp_lock);\n\n\tspin_lock(&tg_pt_gp->tg_pt_gp_lock);\n\trcu_assign_pointer(lun->lun_tg_pt_gp, tg_pt_gp);\n\tlist_add_tail(&lun->lun_tg_pt_gp_link, &tg_pt_gp->tg_pt_gp_lun_list);\n\ttg_pt_gp->tg_pt_gp_members++;\n\tspin_lock(&lun->lun_deve_lock);\n\tlist_for_each_entry(se_deve, &lun->lun_deve_list, lun_link)\n\t\tcore_scsi3_ua_allocate(se_deve, 0x3f,\n\t\t\t\t       ASCQ_3FH_INQUIRY_DATA_HAS_CHANGED);\n\tspin_unlock(&lun->lun_deve_lock);\n\tspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\n}\n\nvoid target_attach_tg_pt_gp(struct se_lun *lun,\n\t\tstruct t10_alua_tg_pt_gp *tg_pt_gp)\n{\n\tspin_lock(&lun->lun_tg_pt_gp_lock);\n\t__target_attach_tg_pt_gp(lun, tg_pt_gp);\n\tspin_unlock(&lun->lun_tg_pt_gp_lock);\n\tsynchronize_rcu();\n}\n\nstatic void __target_detach_tg_pt_gp(struct se_lun *lun,\n\t\tstruct t10_alua_tg_pt_gp *tg_pt_gp)\n{\n\tassert_spin_locked(&lun->lun_tg_pt_gp_lock);\n\n\tspin_lock(&tg_pt_gp->tg_pt_gp_lock);\n\tlist_del_init(&lun->lun_tg_pt_gp_link);\n\ttg_pt_gp->tg_pt_gp_members--;\n\tspin_unlock(&tg_pt_gp->tg_pt_gp_lock);\n}\n\nvoid target_detach_tg_pt_gp(struct se_lun *lun)\n{\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp;\n\n\tspin_lock(&lun->lun_tg_pt_gp_lock);\n\ttg_pt_gp = rcu_dereference_check(lun->lun_tg_pt_gp,\n\t\t\t\tlockdep_is_held(&lun->lun_tg_pt_gp_lock));\n\tif (tg_pt_gp) {\n\t\t__target_detach_tg_pt_gp(lun, tg_pt_gp);\n\t\trcu_assign_pointer(lun->lun_tg_pt_gp, NULL);\n\t}\n\tspin_unlock(&lun->lun_tg_pt_gp_lock);\n\tsynchronize_rcu();\n}\n\nstatic void target_swap_tg_pt_gp(struct se_lun *lun,\n\t\t\t\t struct t10_alua_tg_pt_gp *old_tg_pt_gp,\n\t\t\t\t struct t10_alua_tg_pt_gp *new_tg_pt_gp)\n{\n\tassert_spin_locked(&lun->lun_tg_pt_gp_lock);\n\n\tif (old_tg_pt_gp)\n\t\t__target_detach_tg_pt_gp(lun, old_tg_pt_gp);\n\t__target_attach_tg_pt_gp(lun, new_tg_pt_gp);\n}\n\nssize_t core_alua_show_tg_pt_gp_info(struct se_lun *lun, char *page)\n{\n\tstruct config_item *tg_pt_ci;\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp;\n\tssize_t len = 0;\n\n\trcu_read_lock();\n\ttg_pt_gp = rcu_dereference(lun->lun_tg_pt_gp);\n\tif (tg_pt_gp) {\n\t\ttg_pt_ci = &tg_pt_gp->tg_pt_gp_group.cg_item;\n\t\tlen += sprintf(page, \"TG Port Alias: %s\\nTG Port Group ID:\"\n\t\t\t\" %hu\\nTG Port Primary Access State: %s\\nTG Port \"\n\t\t\t\"Primary Access Status: %s\\nTG Port Secondary Access\"\n\t\t\t\" State: %s\\nTG Port Secondary Access Status: %s\\n\",\n\t\t\tconfig_item_name(tg_pt_ci), tg_pt_gp->tg_pt_gp_id,\n\t\t\tcore_alua_dump_state(\n\t\t\t\ttg_pt_gp->tg_pt_gp_alua_access_state),\n\t\t\tcore_alua_dump_status(\n\t\t\t\ttg_pt_gp->tg_pt_gp_alua_access_status),\n\t\t\tatomic_read(&lun->lun_tg_pt_secondary_offline) ?\n\t\t\t\"Offline\" : \"None\",\n\t\t\tcore_alua_dump_status(lun->lun_tg_pt_secondary_stat));\n\t}\n\trcu_read_unlock();\n\n\treturn len;\n}\n\nssize_t core_alua_store_tg_pt_gp_info(\n\tstruct se_lun *lun,\n\tconst char *page,\n\tsize_t count)\n{\n\tstruct se_portal_group *tpg = lun->lun_tpg;\n\t \n\tstruct se_device *dev = rcu_dereference_raw(lun->lun_se_dev);\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp = NULL, *tg_pt_gp_new = NULL;\n\tunsigned char buf[TG_PT_GROUP_NAME_BUF];\n\tint move = 0;\n\n\tif (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_ALUA ||\n\t    (dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE))\n\t\treturn -ENODEV;\n\n\tif (count > TG_PT_GROUP_NAME_BUF) {\n\t\tpr_err(\"ALUA Target Port Group alias too large!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemset(buf, 0, TG_PT_GROUP_NAME_BUF);\n\tmemcpy(buf, page, count);\n\t \n\tif (strcmp(strstrip(buf), \"NULL\")) {\n\t\t \n\t\ttg_pt_gp_new = core_alua_get_tg_pt_gp_by_name(dev,\n\t\t\t\t\tstrstrip(buf));\n\t\tif (!tg_pt_gp_new)\n\t\t\treturn -ENODEV;\n\t}\n\n\tspin_lock(&lun->lun_tg_pt_gp_lock);\n\ttg_pt_gp = rcu_dereference_check(lun->lun_tg_pt_gp,\n\t\t\t\tlockdep_is_held(&lun->lun_tg_pt_gp_lock));\n\tif (tg_pt_gp) {\n\t\t \n\t\tif (!tg_pt_gp_new) {\n\t\t\tpr_debug(\"Target_Core_ConfigFS: Moving\"\n\t\t\t\t\" %s/tpgt_%hu/%s from ALUA Target Port Group:\"\n\t\t\t\t\" alua/%s, ID: %hu back to\"\n\t\t\t\t\" default_tg_pt_gp\\n\",\n\t\t\t\ttpg->se_tpg_tfo->tpg_get_wwn(tpg),\n\t\t\t\ttpg->se_tpg_tfo->tpg_get_tag(tpg),\n\t\t\t\tconfig_item_name(&lun->lun_group.cg_item),\n\t\t\t\tconfig_item_name(\n\t\t\t\t\t&tg_pt_gp->tg_pt_gp_group.cg_item),\n\t\t\t\ttg_pt_gp->tg_pt_gp_id);\n\n\t\t\ttarget_swap_tg_pt_gp(lun, tg_pt_gp,\n\t\t\t\t\tdev->t10_alua.default_tg_pt_gp);\n\t\t\tspin_unlock(&lun->lun_tg_pt_gp_lock);\n\n\t\t\tgoto sync_rcu;\n\t\t}\n\t\tmove = 1;\n\t}\n\n\ttarget_swap_tg_pt_gp(lun, tg_pt_gp, tg_pt_gp_new);\n\tspin_unlock(&lun->lun_tg_pt_gp_lock);\n\tpr_debug(\"Target_Core_ConfigFS: %s %s/tpgt_%hu/%s to ALUA\"\n\t\t\" Target Port Group: alua/%s, ID: %hu\\n\", (move) ?\n\t\t\"Moving\" : \"Adding\", tpg->se_tpg_tfo->tpg_get_wwn(tpg),\n\t\ttpg->se_tpg_tfo->tpg_get_tag(tpg),\n\t\tconfig_item_name(&lun->lun_group.cg_item),\n\t\tconfig_item_name(&tg_pt_gp_new->tg_pt_gp_group.cg_item),\n\t\ttg_pt_gp_new->tg_pt_gp_id);\n\n\tcore_alua_put_tg_pt_gp_from_name(tg_pt_gp_new);\nsync_rcu:\n\tsynchronize_rcu();\n\treturn count;\n}\n\nssize_t core_alua_show_access_type(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp,\n\tchar *page)\n{\n\tif ((tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICIT_ALUA) &&\n\t    (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_IMPLICIT_ALUA))\n\t\treturn sprintf(page, \"Implicit and Explicit\\n\");\n\telse if (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_IMPLICIT_ALUA)\n\t\treturn sprintf(page, \"Implicit\\n\");\n\telse if (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICIT_ALUA)\n\t\treturn sprintf(page, \"Explicit\\n\");\n\telse\n\t\treturn sprintf(page, \"None\\n\");\n}\n\nssize_t core_alua_store_access_type(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp,\n\tconst char *page,\n\tsize_t count)\n{\n\tunsigned long tmp;\n\tint ret;\n\n\tret = kstrtoul(page, 0, &tmp);\n\tif (ret < 0) {\n\t\tpr_err(\"Unable to extract alua_access_type\\n\");\n\t\treturn ret;\n\t}\n\tif ((tmp != 0) && (tmp != 1) && (tmp != 2) && (tmp != 3)) {\n\t\tpr_err(\"Illegal value for alua_access_type:\"\n\t\t\t\t\" %lu\\n\", tmp);\n\t\treturn -EINVAL;\n\t}\n\tif (tmp == 3)\n\t\ttg_pt_gp->tg_pt_gp_alua_access_type =\n\t\t\tTPGS_IMPLICIT_ALUA | TPGS_EXPLICIT_ALUA;\n\telse if (tmp == 2)\n\t\ttg_pt_gp->tg_pt_gp_alua_access_type = TPGS_EXPLICIT_ALUA;\n\telse if (tmp == 1)\n\t\ttg_pt_gp->tg_pt_gp_alua_access_type = TPGS_IMPLICIT_ALUA;\n\telse\n\t\ttg_pt_gp->tg_pt_gp_alua_access_type = 0;\n\n\treturn count;\n}\n\nssize_t core_alua_show_nonop_delay_msecs(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp,\n\tchar *page)\n{\n\treturn sprintf(page, \"%d\\n\", tg_pt_gp->tg_pt_gp_nonop_delay_msecs);\n}\n\nssize_t core_alua_store_nonop_delay_msecs(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp,\n\tconst char *page,\n\tsize_t count)\n{\n\tunsigned long tmp;\n\tint ret;\n\n\tret = kstrtoul(page, 0, &tmp);\n\tif (ret < 0) {\n\t\tpr_err(\"Unable to extract nonop_delay_msecs\\n\");\n\t\treturn ret;\n\t}\n\tif (tmp > ALUA_MAX_NONOP_DELAY_MSECS) {\n\t\tpr_err(\"Passed nonop_delay_msecs: %lu, exceeds\"\n\t\t\t\" ALUA_MAX_NONOP_DELAY_MSECS: %d\\n\", tmp,\n\t\t\tALUA_MAX_NONOP_DELAY_MSECS);\n\t\treturn -EINVAL;\n\t}\n\ttg_pt_gp->tg_pt_gp_nonop_delay_msecs = (int)tmp;\n\n\treturn count;\n}\n\nssize_t core_alua_show_trans_delay_msecs(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp,\n\tchar *page)\n{\n\treturn sprintf(page, \"%d\\n\", tg_pt_gp->tg_pt_gp_trans_delay_msecs);\n}\n\nssize_t core_alua_store_trans_delay_msecs(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp,\n\tconst char *page,\n\tsize_t count)\n{\n\tunsigned long tmp;\n\tint ret;\n\n\tret = kstrtoul(page, 0, &tmp);\n\tif (ret < 0) {\n\t\tpr_err(\"Unable to extract trans_delay_msecs\\n\");\n\t\treturn ret;\n\t}\n\tif (tmp > ALUA_MAX_TRANS_DELAY_MSECS) {\n\t\tpr_err(\"Passed trans_delay_msecs: %lu, exceeds\"\n\t\t\t\" ALUA_MAX_TRANS_DELAY_MSECS: %d\\n\", tmp,\n\t\t\tALUA_MAX_TRANS_DELAY_MSECS);\n\t\treturn -EINVAL;\n\t}\n\ttg_pt_gp->tg_pt_gp_trans_delay_msecs = (int)tmp;\n\n\treturn count;\n}\n\nssize_t core_alua_show_implicit_trans_secs(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp,\n\tchar *page)\n{\n\treturn sprintf(page, \"%d\\n\", tg_pt_gp->tg_pt_gp_implicit_trans_secs);\n}\n\nssize_t core_alua_store_implicit_trans_secs(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp,\n\tconst char *page,\n\tsize_t count)\n{\n\tunsigned long tmp;\n\tint ret;\n\n\tret = kstrtoul(page, 0, &tmp);\n\tif (ret < 0) {\n\t\tpr_err(\"Unable to extract implicit_trans_secs\\n\");\n\t\treturn ret;\n\t}\n\tif (tmp > ALUA_MAX_IMPLICIT_TRANS_SECS) {\n\t\tpr_err(\"Passed implicit_trans_secs: %lu, exceeds\"\n\t\t\t\" ALUA_MAX_IMPLICIT_TRANS_SECS: %d\\n\", tmp,\n\t\t\tALUA_MAX_IMPLICIT_TRANS_SECS);\n\t\treturn  -EINVAL;\n\t}\n\ttg_pt_gp->tg_pt_gp_implicit_trans_secs = (int)tmp;\n\n\treturn count;\n}\n\nssize_t core_alua_show_preferred_bit(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp,\n\tchar *page)\n{\n\treturn sprintf(page, \"%d\\n\", tg_pt_gp->tg_pt_gp_pref);\n}\n\nssize_t core_alua_store_preferred_bit(\n\tstruct t10_alua_tg_pt_gp *tg_pt_gp,\n\tconst char *page,\n\tsize_t count)\n{\n\tunsigned long tmp;\n\tint ret;\n\n\tret = kstrtoul(page, 0, &tmp);\n\tif (ret < 0) {\n\t\tpr_err(\"Unable to extract preferred ALUA value\\n\");\n\t\treturn ret;\n\t}\n\tif ((tmp != 0) && (tmp != 1)) {\n\t\tpr_err(\"Illegal value for preferred ALUA: %lu\\n\", tmp);\n\t\treturn -EINVAL;\n\t}\n\ttg_pt_gp->tg_pt_gp_pref = (int)tmp;\n\n\treturn count;\n}\n\nssize_t core_alua_show_offline_bit(struct se_lun *lun, char *page)\n{\n\treturn sprintf(page, \"%d\\n\",\n\t\tatomic_read(&lun->lun_tg_pt_secondary_offline));\n}\n\nssize_t core_alua_store_offline_bit(\n\tstruct se_lun *lun,\n\tconst char *page,\n\tsize_t count)\n{\n\t \n\tstruct se_device *dev = rcu_dereference_raw(lun->lun_se_dev);\n\tunsigned long tmp;\n\tint ret;\n\n\tif (dev->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_ALUA ||\n\t    (dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE))\n\t\treturn -ENODEV;\n\n\tret = kstrtoul(page, 0, &tmp);\n\tif (ret < 0) {\n\t\tpr_err(\"Unable to extract alua_tg_pt_offline value\\n\");\n\t\treturn ret;\n\t}\n\tif ((tmp != 0) && (tmp != 1)) {\n\t\tpr_err(\"Illegal value for alua_tg_pt_offline: %lu\\n\",\n\t\t\t\ttmp);\n\t\treturn -EINVAL;\n\t}\n\n\tret = core_alua_set_tg_pt_secondary_state(lun, 0, (int)tmp);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nssize_t core_alua_show_secondary_status(\n\tstruct se_lun *lun,\n\tchar *page)\n{\n\treturn sprintf(page, \"%d\\n\", lun->lun_tg_pt_secondary_stat);\n}\n\nssize_t core_alua_store_secondary_status(\n\tstruct se_lun *lun,\n\tconst char *page,\n\tsize_t count)\n{\n\tunsigned long tmp;\n\tint ret;\n\n\tret = kstrtoul(page, 0, &tmp);\n\tif (ret < 0) {\n\t\tpr_err(\"Unable to extract alua_tg_pt_status\\n\");\n\t\treturn ret;\n\t}\n\tif ((tmp != ALUA_STATUS_NONE) &&\n\t    (tmp != ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG) &&\n\t    (tmp != ALUA_STATUS_ALTERED_BY_IMPLICIT_ALUA)) {\n\t\tpr_err(\"Illegal value for alua_tg_pt_status: %lu\\n\",\n\t\t\t\ttmp);\n\t\treturn -EINVAL;\n\t}\n\tlun->lun_tg_pt_secondary_stat = (int)tmp;\n\n\treturn count;\n}\n\nssize_t core_alua_show_secondary_write_metadata(\n\tstruct se_lun *lun,\n\tchar *page)\n{\n\treturn sprintf(page, \"%d\\n\", lun->lun_tg_pt_secondary_write_md);\n}\n\nssize_t core_alua_store_secondary_write_metadata(\n\tstruct se_lun *lun,\n\tconst char *page,\n\tsize_t count)\n{\n\tunsigned long tmp;\n\tint ret;\n\n\tret = kstrtoul(page, 0, &tmp);\n\tif (ret < 0) {\n\t\tpr_err(\"Unable to extract alua_tg_pt_write_md\\n\");\n\t\treturn ret;\n\t}\n\tif ((tmp != 0) && (tmp != 1)) {\n\t\tpr_err(\"Illegal value for alua_tg_pt_write_md:\"\n\t\t\t\t\" %lu\\n\", tmp);\n\t\treturn -EINVAL;\n\t}\n\tlun->lun_tg_pt_secondary_write_md = (int)tmp;\n\n\treturn count;\n}\n\nint core_setup_alua(struct se_device *dev)\n{\n\tif (!(dev->transport_flags &\n\t     TRANSPORT_FLAG_PASSTHROUGH_ALUA) &&\n\t    !(dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE)) {\n\t\tstruct t10_alua_lu_gp_member *lu_gp_mem;\n\n\t\t \n\t\tlu_gp_mem = core_alua_allocate_lu_gp_mem(dev);\n\t\tif (IS_ERR(lu_gp_mem))\n\t\t\treturn PTR_ERR(lu_gp_mem);\n\n\t\tspin_lock(&lu_gp_mem->lu_gp_mem_lock);\n\t\t__core_alua_attach_lu_gp_mem(lu_gp_mem,\n\t\t\t\tdefault_lu_gp);\n\t\tspin_unlock(&lu_gp_mem->lu_gp_mem_lock);\n\n\t\tpr_debug(\"%s: Adding to default ALUA LU Group:\"\n\t\t\t\" core/alua/lu_gps/default_lu_gp\\n\",\n\t\t\tdev->transport->name);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}