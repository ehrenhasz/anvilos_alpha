{
  "module_name": "tcm_loop.c",
  "hash_id": "36eea603f35f49e95049bb889741f5369a1771501f7ca8f72d167251c80f6de1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/loopback/tcm_loop.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/configfs.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include \"tcm_loop.h\"\n\n#define to_tcm_loop_hba(hba)\tcontainer_of(hba, struct tcm_loop_hba, dev)\n\nstatic struct kmem_cache *tcm_loop_cmd_cache;\n\nstatic int tcm_loop_hba_no_cnt;\n\nstatic int tcm_loop_queue_status(struct se_cmd *se_cmd);\n\nstatic unsigned int tcm_loop_nr_hw_queues = 1;\nmodule_param_named(nr_hw_queues, tcm_loop_nr_hw_queues, uint, 0644);\n\nstatic unsigned int tcm_loop_can_queue = 1024;\nmodule_param_named(can_queue, tcm_loop_can_queue, uint, 0644);\n\nstatic unsigned int tcm_loop_cmd_per_lun = 1024;\nmodule_param_named(cmd_per_lun, tcm_loop_cmd_per_lun, uint, 0644);\n\n \nstatic int tcm_loop_check_stop_free(struct se_cmd *se_cmd)\n{\n\treturn transport_generic_free_cmd(se_cmd, 0);\n}\n\nstatic void tcm_loop_release_cmd(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\tstruct scsi_cmnd *sc = tl_cmd->sc;\n\n\tif (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)\n\t\tkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\n\telse\n\t\tscsi_done(sc);\n}\n\nstatic int tcm_loop_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tseq_puts(m, \"tcm_loop_proc_info()\\n\");\n\treturn 0;\n}\n\nstatic int tcm_loop_driver_probe(struct device *);\nstatic void tcm_loop_driver_remove(struct device *);\n\nstatic struct bus_type tcm_loop_lld_bus = {\n\t.name\t\t\t= \"tcm_loop_bus\",\n\t.probe\t\t\t= tcm_loop_driver_probe,\n\t.remove\t\t\t= tcm_loop_driver_remove,\n};\n\nstatic struct device_driver tcm_loop_driverfs = {\n\t.name\t\t\t= \"tcm_loop\",\n\t.bus\t\t\t= &tcm_loop_lld_bus,\n};\n \nstatic struct device *tcm_loop_primary;\n\nstatic void tcm_loop_target_queue_cmd(struct tcm_loop_cmd *tl_cmd)\n{\n\tstruct se_cmd *se_cmd = &tl_cmd->tl_se_cmd;\n\tstruct scsi_cmnd *sc = tl_cmd->sc;\n\tstruct tcm_loop_nexus *tl_nexus;\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct tcm_loop_tpg *tl_tpg;\n\tstruct scatterlist *sgl_bidi = NULL;\n\tu32 sgl_bidi_count = 0, transfer_length;\n\n\ttl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\n\ttl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\n\n\t \n\tif (!tl_tpg->tl_hba) {\n\t\tset_host_byte(sc, DID_NO_CONNECT);\n\t\tgoto out_done;\n\t}\n\tif (tl_tpg->tl_transport_status == TCM_TRANSPORT_OFFLINE) {\n\t\tset_host_byte(sc, DID_TRANSPORT_DISRUPTED);\n\t\tgoto out_done;\n\t}\n\ttl_nexus = tl_tpg->tl_nexus;\n\tif (!tl_nexus) {\n\t\tscmd_printk(KERN_ERR, sc,\n\t\t\t    \"TCM_Loop I_T Nexus does not exist\\n\");\n\t\tset_host_byte(sc, DID_ERROR);\n\t\tgoto out_done;\n\t}\n\n\ttransfer_length = scsi_transfer_length(sc);\n\tif (!scsi_prot_sg_count(sc) &&\n\t    scsi_get_prot_op(sc) != SCSI_PROT_NORMAL) {\n\t\tse_cmd->prot_pto = true;\n\t\t \n\t\ttransfer_length = scsi_bufflen(sc);\n\t}\n\n\tse_cmd->tag = tl_cmd->sc_cmd_tag;\n\ttarget_init_cmd(se_cmd, tl_nexus->se_sess, &tl_cmd->tl_sense_buf[0],\n\t\t\ttl_cmd->sc->device->lun, transfer_length,\n\t\t\tTCM_SIMPLE_TAG, sc->sc_data_direction, 0);\n\n\tif (target_submit_prep(se_cmd, sc->cmnd, scsi_sglist(sc),\n\t\t\t       scsi_sg_count(sc), sgl_bidi, sgl_bidi_count,\n\t\t\t       scsi_prot_sglist(sc), scsi_prot_sg_count(sc),\n\t\t\t       GFP_ATOMIC))\n\t\treturn;\n\n\ttarget_queue_submission(se_cmd);\n\treturn;\n\nout_done:\n\tscsi_done(sc);\n}\n\n \nstatic int tcm_loop_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *sc)\n{\n\tstruct tcm_loop_cmd *tl_cmd = scsi_cmd_priv(sc);\n\n\tpr_debug(\"%s() %d:%d:%d:%llu got CDB: 0x%02x scsi_buf_len: %u\\n\",\n\t\t __func__, sc->device->host->host_no, sc->device->id,\n\t\t sc->device->channel, sc->device->lun, sc->cmnd[0],\n\t\t scsi_bufflen(sc));\n\n\tmemset(tl_cmd, 0, sizeof(*tl_cmd));\n\ttl_cmd->sc = sc;\n\ttl_cmd->sc_cmd_tag = scsi_cmd_to_rq(sc)->tag;\n\n\ttcm_loop_target_queue_cmd(tl_cmd);\n\treturn 0;\n}\n\n \nstatic int tcm_loop_issue_tmr(struct tcm_loop_tpg *tl_tpg,\n\t\t\t      u64 lun, int task, enum tcm_tmreq_table tmr)\n{\n\tstruct se_cmd *se_cmd;\n\tstruct se_session *se_sess;\n\tstruct tcm_loop_nexus *tl_nexus;\n\tstruct tcm_loop_cmd *tl_cmd;\n\tint ret = TMR_FUNCTION_FAILED, rc;\n\n\t \n\ttl_nexus = tl_tpg->tl_nexus;\n\tif (!tl_nexus) {\n\t\tpr_err(\"Unable to perform device reset without active I_T Nexus\\n\");\n\t\treturn ret;\n\t}\n\n\ttl_cmd = kmem_cache_zalloc(tcm_loop_cmd_cache, GFP_KERNEL);\n\tif (!tl_cmd)\n\t\treturn ret;\n\n\tinit_completion(&tl_cmd->tmr_done);\n\n\tse_cmd = &tl_cmd->tl_se_cmd;\n\tse_sess = tl_tpg->tl_nexus->se_sess;\n\n\trc = target_submit_tmr(se_cmd, se_sess, tl_cmd->tl_sense_buf, lun,\n\t\t\t       NULL, tmr, GFP_KERNEL, task,\n\t\t\t       TARGET_SCF_ACK_KREF);\n\tif (rc < 0)\n\t\tgoto release;\n\twait_for_completion(&tl_cmd->tmr_done);\n\tret = se_cmd->se_tmr_req->response;\n\ttarget_put_sess_cmd(se_cmd);\n\nout:\n\treturn ret;\n\nrelease:\n\tkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\n\tgoto out;\n}\n\nstatic int tcm_loop_abort_task(struct scsi_cmnd *sc)\n{\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct tcm_loop_tpg *tl_tpg;\n\tint ret;\n\n\t \n\ttl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\n\ttl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\n\tret = tcm_loop_issue_tmr(tl_tpg, sc->device->lun,\n\t\t\t\t scsi_cmd_to_rq(sc)->tag, TMR_ABORT_TASK);\n\treturn (ret == TMR_FUNCTION_COMPLETE) ? SUCCESS : FAILED;\n}\n\n \nstatic int tcm_loop_device_reset(struct scsi_cmnd *sc)\n{\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct tcm_loop_tpg *tl_tpg;\n\tint ret;\n\n\t \n\ttl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\n\ttl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\n\n\tret = tcm_loop_issue_tmr(tl_tpg, sc->device->lun,\n\t\t\t\t 0, TMR_LUN_RESET);\n\treturn (ret == TMR_FUNCTION_COMPLETE) ? SUCCESS : FAILED;\n}\n\nstatic int tcm_loop_target_reset(struct scsi_cmnd *sc)\n{\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct tcm_loop_tpg *tl_tpg;\n\n\t \n\ttl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\n\tif (!tl_hba) {\n\t\tpr_err(\"Unable to perform device reset without active I_T Nexus\\n\");\n\t\treturn FAILED;\n\t}\n\t \n\ttl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\n\tif (tl_tpg) {\n\t\ttl_tpg->tl_transport_status = TCM_TRANSPORT_ONLINE;\n\t\treturn SUCCESS;\n\t}\n\treturn FAILED;\n}\n\nstatic const struct scsi_host_template tcm_loop_driver_template = {\n\t.show_info\t\t= tcm_loop_show_info,\n\t.proc_name\t\t= \"tcm_loopback\",\n\t.name\t\t\t= \"TCM_Loopback\",\n\t.queuecommand\t\t= tcm_loop_queuecommand,\n\t.change_queue_depth\t= scsi_change_queue_depth,\n\t.eh_abort_handler = tcm_loop_abort_task,\n\t.eh_device_reset_handler = tcm_loop_device_reset,\n\t.eh_target_reset_handler = tcm_loop_target_reset,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= 256,\n\t.max_sectors\t\t= 0xFFFF,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n\t.module\t\t\t= THIS_MODULE,\n\t.track_queue_depth\t= 1,\n\t.cmd_size\t\t= sizeof(struct tcm_loop_cmd),\n};\n\nstatic int tcm_loop_driver_probe(struct device *dev)\n{\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct Scsi_Host *sh;\n\tint error, host_prot;\n\n\ttl_hba = to_tcm_loop_hba(dev);\n\n\tsh = scsi_host_alloc(&tcm_loop_driver_template,\n\t\t\tsizeof(struct tcm_loop_hba));\n\tif (!sh) {\n\t\tpr_err(\"Unable to allocate struct scsi_host\\n\");\n\t\treturn -ENODEV;\n\t}\n\ttl_hba->sh = sh;\n\n\t \n\t*((struct tcm_loop_hba **)sh->hostdata) = tl_hba;\n\t \n\tsh->max_id = 2;\n\tsh->max_lun = 0;\n\tsh->max_channel = 0;\n\tsh->max_cmd_len = SCSI_MAX_VARLEN_CDB_SIZE;\n\tsh->nr_hw_queues = tcm_loop_nr_hw_queues;\n\tsh->can_queue = tcm_loop_can_queue;\n\tsh->cmd_per_lun = tcm_loop_cmd_per_lun;\n\n\thost_prot = SHOST_DIF_TYPE1_PROTECTION | SHOST_DIF_TYPE2_PROTECTION |\n\t\t    SHOST_DIF_TYPE3_PROTECTION | SHOST_DIX_TYPE1_PROTECTION |\n\t\t    SHOST_DIX_TYPE2_PROTECTION | SHOST_DIX_TYPE3_PROTECTION;\n\n\tscsi_host_set_prot(sh, host_prot);\n\tscsi_host_set_guard(sh, SHOST_DIX_GUARD_CRC);\n\n\terror = scsi_add_host(sh, &tl_hba->dev);\n\tif (error) {\n\t\tpr_err(\"%s: scsi_add_host failed\\n\", __func__);\n\t\tscsi_host_put(sh);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void tcm_loop_driver_remove(struct device *dev)\n{\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct Scsi_Host *sh;\n\n\ttl_hba = to_tcm_loop_hba(dev);\n\tsh = tl_hba->sh;\n\n\tscsi_remove_host(sh);\n\tscsi_host_put(sh);\n}\n\nstatic void tcm_loop_release_adapter(struct device *dev)\n{\n\tstruct tcm_loop_hba *tl_hba = to_tcm_loop_hba(dev);\n\n\tkfree(tl_hba);\n}\n\n \nstatic int tcm_loop_setup_hba_bus(struct tcm_loop_hba *tl_hba, int tcm_loop_host_id)\n{\n\tint ret;\n\n\ttl_hba->dev.bus = &tcm_loop_lld_bus;\n\ttl_hba->dev.parent = tcm_loop_primary;\n\ttl_hba->dev.release = &tcm_loop_release_adapter;\n\tdev_set_name(&tl_hba->dev, \"tcm_loop_adapter_%d\", tcm_loop_host_id);\n\n\tret = device_register(&tl_hba->dev);\n\tif (ret) {\n\t\tpr_err(\"device_register() failed for tl_hba->dev: %d\\n\", ret);\n\t\tput_device(&tl_hba->dev);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int tcm_loop_alloc_core_bus(void)\n{\n\tint ret;\n\n\ttcm_loop_primary = root_device_register(\"tcm_loop_0\");\n\tif (IS_ERR(tcm_loop_primary)) {\n\t\tpr_err(\"Unable to allocate tcm_loop_primary\\n\");\n\t\treturn PTR_ERR(tcm_loop_primary);\n\t}\n\n\tret = bus_register(&tcm_loop_lld_bus);\n\tif (ret) {\n\t\tpr_err(\"bus_register() failed for tcm_loop_lld_bus\\n\");\n\t\tgoto dev_unreg;\n\t}\n\n\tret = driver_register(&tcm_loop_driverfs);\n\tif (ret) {\n\t\tpr_err(\"driver_register() failed for tcm_loop_driverfs\\n\");\n\t\tgoto bus_unreg;\n\t}\n\n\tpr_debug(\"Initialized TCM Loop Core Bus\\n\");\n\treturn ret;\n\nbus_unreg:\n\tbus_unregister(&tcm_loop_lld_bus);\ndev_unreg:\n\troot_device_unregister(tcm_loop_primary);\n\treturn ret;\n}\n\nstatic void tcm_loop_release_core_bus(void)\n{\n\tdriver_unregister(&tcm_loop_driverfs);\n\tbus_unregister(&tcm_loop_lld_bus);\n\troot_device_unregister(tcm_loop_primary);\n\n\tpr_debug(\"Releasing TCM Loop Core BUS\\n\");\n}\n\nstatic inline struct tcm_loop_tpg *tl_tpg(struct se_portal_group *se_tpg)\n{\n\treturn container_of(se_tpg, struct tcm_loop_tpg, tl_se_tpg);\n}\n\nstatic char *tcm_loop_get_endpoint_wwn(struct se_portal_group *se_tpg)\n{\n\t \n\treturn &tl_tpg(se_tpg)->tl_hba->tl_wwn_address[0];\n}\n\nstatic u16 tcm_loop_get_tag(struct se_portal_group *se_tpg)\n{\n\t \n\treturn tl_tpg(se_tpg)->tl_tpgt;\n}\n\n \nstatic int tcm_loop_check_demo_mode(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic int tcm_loop_check_prot_fabric_only(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg, struct tcm_loop_tpg,\n\t\t\t\t\t\t   tl_se_tpg);\n\treturn tl_tpg->tl_fabric_prot_type;\n}\n\nstatic u32 tcm_loop_sess_get_index(struct se_session *se_sess)\n{\n\treturn 1;\n}\n\nstatic int tcm_loop_get_cmd_state(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\n\treturn tl_cmd->sc_cmd_state;\n}\n\nstatic int tcm_loop_write_pending(struct se_cmd *se_cmd)\n{\n\t \n\ttarget_execute_cmd(se_cmd);\n\treturn 0;\n}\n\nstatic int tcm_loop_queue_data_or_status(const char *func,\n\t\tstruct se_cmd *se_cmd, u8 scsi_status)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\tstruct scsi_cmnd *sc = tl_cmd->sc;\n\n\tpr_debug(\"%s() called for scsi_cmnd: %p cdb: 0x%02x\\n\",\n\t\t func, sc, sc->cmnd[0]);\n\n\tif (se_cmd->sense_buffer &&\n\t   ((se_cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ||\n\t    (se_cmd->se_cmd_flags & SCF_EMULATED_TASK_SENSE))) {\n\n\t\tmemcpy(sc->sense_buffer, se_cmd->sense_buffer,\n\t\t\t\tSCSI_SENSE_BUFFERSIZE);\n\t\tsc->result = SAM_STAT_CHECK_CONDITION;\n\t} else\n\t\tsc->result = scsi_status;\n\n\tset_host_byte(sc, DID_OK);\n\tif ((se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) ||\n\t    (se_cmd->se_cmd_flags & SCF_UNDERFLOW_BIT))\n\t\tscsi_set_resid(sc, se_cmd->residual_count);\n\treturn 0;\n}\n\nstatic int tcm_loop_queue_data_in(struct se_cmd *se_cmd)\n{\n\treturn tcm_loop_queue_data_or_status(__func__, se_cmd, SAM_STAT_GOOD);\n}\n\nstatic int tcm_loop_queue_status(struct se_cmd *se_cmd)\n{\n\treturn tcm_loop_queue_data_or_status(__func__,\n\t\t\t\t\t     se_cmd, se_cmd->scsi_status);\n}\n\nstatic void tcm_loop_queue_tm_rsp(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\n\t \n\tcomplete(&tl_cmd->tmr_done);\n}\n\nstatic void tcm_loop_aborted_task(struct se_cmd *se_cmd)\n{\n\treturn;\n}\n\nstatic char *tcm_loop_dump_proto_id(struct tcm_loop_hba *tl_hba)\n{\n\tswitch (tl_hba->tl_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn \"SAS\";\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn \"FCP\";\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn \"iSCSI\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"Unknown\";\n}\n\n \n\nstatic int tcm_loop_port_link(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_lun *lun)\n{\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\n\tatomic_inc_mb(&tl_tpg->tl_tpg_port_count);\n\t \n\tscsi_add_device(tl_hba->sh, 0, tl_tpg->tl_tpgt, lun->unpacked_lun);\n\n\tpr_debug(\"TCM_Loop_ConfigFS: Port Link Successful\\n\");\n\treturn 0;\n}\n\nstatic void tcm_loop_port_unlink(\n\tstruct se_portal_group *se_tpg,\n\tstruct se_lun *se_lun)\n{\n\tstruct scsi_device *sd;\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct tcm_loop_tpg *tl_tpg;\n\n\ttl_tpg = container_of(se_tpg, struct tcm_loop_tpg, tl_se_tpg);\n\ttl_hba = tl_tpg->tl_hba;\n\n\tsd = scsi_device_lookup(tl_hba->sh, 0, tl_tpg->tl_tpgt,\n\t\t\t\tse_lun->unpacked_lun);\n\tif (!sd) {\n\t\tpr_err(\"Unable to locate struct scsi_device for %d:%d:%llu\\n\",\n\t\t       0, tl_tpg->tl_tpgt, se_lun->unpacked_lun);\n\t\treturn;\n\t}\n\t \n\tscsi_remove_device(sd);\n\tscsi_device_put(sd);\n\n\tatomic_dec_mb(&tl_tpg->tl_tpg_port_count);\n\n\tpr_debug(\"TCM_Loop_ConfigFS: Port Unlink Successful\\n\");\n}\n\n \n\nstatic ssize_t tcm_loop_tpg_attrib_fabric_prot_type_show(\n\t\tstruct config_item *item, char *page)\n{\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg, struct tcm_loop_tpg,\n\t\t\t\t\t\t   tl_se_tpg);\n\n\treturn sprintf(page, \"%d\\n\", tl_tpg->tl_fabric_prot_type);\n}\n\nstatic ssize_t tcm_loop_tpg_attrib_fabric_prot_type_store(\n\t\tstruct config_item *item, const char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg, struct tcm_loop_tpg,\n\t\t\t\t\t\t   tl_se_tpg);\n\tunsigned long val;\n\tint ret = kstrtoul(page, 0, &val);\n\n\tif (ret) {\n\t\tpr_err(\"kstrtoul() returned %d for fabric_prot_type\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (val != 0 && val != 1 && val != 3) {\n\t\tpr_err(\"Invalid qla2xxx fabric_prot_type: %lu\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\ttl_tpg->tl_fabric_prot_type = val;\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(tcm_loop_tpg_attrib_, fabric_prot_type);\n\nstatic struct configfs_attribute *tcm_loop_tpg_attrib_attrs[] = {\n\t&tcm_loop_tpg_attrib_attr_fabric_prot_type,\n\tNULL,\n};\n\n \n\nstatic int tcm_loop_alloc_sess_cb(struct se_portal_group *se_tpg,\n\t\t\t\t  struct se_session *se_sess, void *p)\n{\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\n\ttl_tpg->tl_nexus = p;\n\treturn 0;\n}\n\nstatic int tcm_loop_make_nexus(\n\tstruct tcm_loop_tpg *tl_tpg,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\tstruct tcm_loop_nexus *tl_nexus;\n\tint ret;\n\n\tif (tl_tpg->tl_nexus) {\n\t\tpr_debug(\"tl_tpg->tl_nexus already exists\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\ttl_nexus = kzalloc(sizeof(*tl_nexus), GFP_KERNEL);\n\tif (!tl_nexus)\n\t\treturn -ENOMEM;\n\n\ttl_nexus->se_sess = target_setup_session(&tl_tpg->tl_se_tpg, 0, 0,\n\t\t\t\t\tTARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS,\n\t\t\t\t\tname, tl_nexus, tcm_loop_alloc_sess_cb);\n\tif (IS_ERR(tl_nexus->se_sess)) {\n\t\tret = PTR_ERR(tl_nexus->se_sess);\n\t\tkfree(tl_nexus);\n\t\treturn ret;\n\t}\n\n\tpr_debug(\"TCM_Loop_ConfigFS: Established I_T Nexus to emulated %s Initiator Port: %s\\n\",\n\t\t tcm_loop_dump_proto_id(tl_hba), name);\n\treturn 0;\n}\n\nstatic int tcm_loop_drop_nexus(\n\tstruct tcm_loop_tpg *tpg)\n{\n\tstruct se_session *se_sess;\n\tstruct tcm_loop_nexus *tl_nexus;\n\n\ttl_nexus = tpg->tl_nexus;\n\tif (!tl_nexus)\n\t\treturn -ENODEV;\n\n\tse_sess = tl_nexus->se_sess;\n\tif (!se_sess)\n\t\treturn -ENODEV;\n\n\tif (atomic_read(&tpg->tl_tpg_port_count)) {\n\t\tpr_err(\"Unable to remove TCM_Loop I_T Nexus with active TPG port count: %d\\n\",\n\t\t       atomic_read(&tpg->tl_tpg_port_count));\n\t\treturn -EPERM;\n\t}\n\n\tpr_debug(\"TCM_Loop_ConfigFS: Removing I_T Nexus to emulated %s Initiator Port: %s\\n\",\n\t\t tcm_loop_dump_proto_id(tpg->tl_hba),\n\t\t tl_nexus->se_sess->se_node_acl->initiatorname);\n\t \n\ttarget_remove_session(se_sess);\n\ttpg->tl_nexus = NULL;\n\tkfree(tl_nexus);\n\treturn 0;\n}\n\n \n\nstatic ssize_t tcm_loop_tpg_nexus_show(struct config_item *item, char *page)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tstruct tcm_loop_nexus *tl_nexus;\n\tssize_t ret;\n\n\ttl_nexus = tl_tpg->tl_nexus;\n\tif (!tl_nexus)\n\t\treturn -ENODEV;\n\n\tret = snprintf(page, PAGE_SIZE, \"%s\\n\",\n\t\ttl_nexus->se_sess->se_node_acl->initiatorname);\n\n\treturn ret;\n}\n\nstatic ssize_t tcm_loop_tpg_nexus_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\tunsigned char i_port[TL_WWN_ADDR_LEN], *ptr, *port_ptr;\n\tint ret;\n\t \n\tif (!strncmp(page, \"NULL\", 4)) {\n\t\tret = tcm_loop_drop_nexus(tl_tpg);\n\t\treturn (!ret) ? count : ret;\n\t}\n\t \n\tif (strlen(page) >= TL_WWN_ADDR_LEN) {\n\t\tpr_err(\"Emulated NAA Sas Address: %s, exceeds max: %d\\n\",\n\t\t       page, TL_WWN_ADDR_LEN);\n\t\treturn -EINVAL;\n\t}\n\tsnprintf(&i_port[0], TL_WWN_ADDR_LEN, \"%s\", page);\n\n\tptr = strstr(i_port, \"naa.\");\n\tif (ptr) {\n\t\tif (tl_hba->tl_proto_id != SCSI_PROTOCOL_SAS) {\n\t\t\tpr_err(\"Passed SAS Initiator Port %s does not match target port protoid: %s\\n\",\n\t\t\t       i_port, tcm_loop_dump_proto_id(tl_hba));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[0];\n\t\tgoto check_newline;\n\t}\n\tptr = strstr(i_port, \"fc.\");\n\tif (ptr) {\n\t\tif (tl_hba->tl_proto_id != SCSI_PROTOCOL_FCP) {\n\t\t\tpr_err(\"Passed FCP Initiator Port %s does not match target port protoid: %s\\n\",\n\t\t\t       i_port, tcm_loop_dump_proto_id(tl_hba));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[3];  \n\t\tgoto check_newline;\n\t}\n\tptr = strstr(i_port, \"iqn.\");\n\tif (ptr) {\n\t\tif (tl_hba->tl_proto_id != SCSI_PROTOCOL_ISCSI) {\n\t\t\tpr_err(\"Passed iSCSI Initiator Port %s does not match target port protoid: %s\\n\",\n\t\t\t       i_port, tcm_loop_dump_proto_id(tl_hba));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[0];\n\t\tgoto check_newline;\n\t}\n\tpr_err(\"Unable to locate prefix for emulated Initiator Port: %s\\n\",\n\t       i_port);\n\treturn -EINVAL;\n\t \ncheck_newline:\n\tif (i_port[strlen(i_port)-1] == '\\n')\n\t\ti_port[strlen(i_port)-1] = '\\0';\n\n\tret = tcm_loop_make_nexus(tl_tpg, port_ptr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t tcm_loop_tpg_transport_status_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tconst char *status = NULL;\n\tssize_t ret = -EINVAL;\n\n\tswitch (tl_tpg->tl_transport_status) {\n\tcase TCM_TRANSPORT_ONLINE:\n\t\tstatus = \"online\";\n\t\tbreak;\n\tcase TCM_TRANSPORT_OFFLINE:\n\t\tstatus = \"offline\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (status)\n\t\tret = snprintf(page, PAGE_SIZE, \"%s\\n\", status);\n\n\treturn ret;\n}\n\nstatic ssize_t tcm_loop_tpg_transport_status_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\n\tif (!strncmp(page, \"online\", 6)) {\n\t\ttl_tpg->tl_transport_status = TCM_TRANSPORT_ONLINE;\n\t\treturn count;\n\t}\n\tif (!strncmp(page, \"offline\", 7)) {\n\t\ttl_tpg->tl_transport_status = TCM_TRANSPORT_OFFLINE;\n\t\tif (tl_tpg->tl_nexus) {\n\t\t\tstruct se_session *tl_sess = tl_tpg->tl_nexus->se_sess;\n\n\t\t\tcore_allocate_nexus_loss_ua(tl_sess->se_node_acl);\n\t\t}\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\n\nstatic ssize_t tcm_loop_tpg_address_show(struct config_item *item,\n\t\t\t\t\t char *page)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\n\n\treturn snprintf(page, PAGE_SIZE, \"%d:0:%d\\n\",\n\t\t\ttl_hba->sh->host_no, tl_tpg->tl_tpgt);\n}\n\nCONFIGFS_ATTR(tcm_loop_tpg_, nexus);\nCONFIGFS_ATTR(tcm_loop_tpg_, transport_status);\nCONFIGFS_ATTR_RO(tcm_loop_tpg_, address);\n\nstatic struct configfs_attribute *tcm_loop_tpg_attrs[] = {\n\t&tcm_loop_tpg_attr_nexus,\n\t&tcm_loop_tpg_attr_transport_status,\n\t&tcm_loop_tpg_attr_address,\n\tNULL,\n};\n\n \n\nstatic struct se_portal_group *tcm_loop_make_naa_tpg(struct se_wwn *wwn,\n\t\t\t\t\t\t     const char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tint ret;\n\tunsigned long tpgt;\n\n\tif (strstr(name, \"tpgt_\") != name) {\n\t\tpr_err(\"Unable to locate \\\"tpgt_#\\\" directory group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (kstrtoul(name+5, 10, &tpgt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tpgt >= TL_TPGS_PER_HBA) {\n\t\tpr_err(\"Passed tpgt: %lu exceeds TL_TPGS_PER_HBA: %u\\n\",\n\t\t       tpgt, TL_TPGS_PER_HBA);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\t \n\tret = core_tpg_register(wwn, &tl_tpg->tl_se_tpg, tl_hba->tl_proto_id);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpr_debug(\"TCM_Loop_ConfigFS: Allocated Emulated %s Target Port %s,t,0x%04lx\\n\",\n\t\t tcm_loop_dump_proto_id(tl_hba),\n\t\t config_item_name(&wwn->wwn_group.cg_item), tpgt);\n\treturn &tl_tpg->tl_se_tpg;\n}\n\nstatic void tcm_loop_drop_naa_tpg(\n\tstruct se_portal_group *se_tpg)\n{\n\tstruct se_wwn *wwn = se_tpg->se_tpg_wwn;\n\tstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_loop_tpg, tl_se_tpg);\n\tstruct tcm_loop_hba *tl_hba;\n\tunsigned short tpgt;\n\n\ttl_hba = tl_tpg->tl_hba;\n\ttpgt = tl_tpg->tl_tpgt;\n\t \n\ttcm_loop_drop_nexus(tl_tpg);\n\t \n\tcore_tpg_deregister(se_tpg);\n\n\ttl_tpg->tl_hba = NULL;\n\ttl_tpg->tl_tpgt = 0;\n\n\tpr_debug(\"TCM_Loop_ConfigFS: Deallocated Emulated %s Target Port %s,t,0x%04x\\n\",\n\t\t tcm_loop_dump_proto_id(tl_hba),\n\t\t config_item_name(&wwn->wwn_group.cg_item), tpgt);\n}\n\n \n\n \n\nstatic struct se_wwn *tcm_loop_make_scsi_hba(\n\tstruct target_fabric_configfs *tf,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba;\n\tstruct Scsi_Host *sh;\n\tchar *ptr;\n\tint ret, off = 0;\n\n\ttl_hba = kzalloc(sizeof(*tl_hba), GFP_KERNEL);\n\tif (!tl_hba)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tptr = strstr(name, \"naa.\");\n\tif (ptr) {\n\t\ttl_hba->tl_proto_id = SCSI_PROTOCOL_SAS;\n\t\tgoto check_len;\n\t}\n\tptr = strstr(name, \"fc.\");\n\tif (ptr) {\n\t\ttl_hba->tl_proto_id = SCSI_PROTOCOL_FCP;\n\t\toff = 3;  \n\t\tgoto check_len;\n\t}\n\tptr = strstr(name, \"iqn.\");\n\tif (!ptr) {\n\t\tpr_err(\"Unable to locate prefix for emulated Target Port: %s\\n\",\n\t\t       name);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\ttl_hba->tl_proto_id = SCSI_PROTOCOL_ISCSI;\n\ncheck_len:\n\tif (strlen(name) >= TL_WWN_ADDR_LEN) {\n\t\tpr_err(\"Emulated NAA %s Address: %s, exceeds max: %d\\n\",\n\t\t       name, tcm_loop_dump_proto_id(tl_hba), TL_WWN_ADDR_LEN);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tsnprintf(&tl_hba->tl_wwn_address[0], TL_WWN_ADDR_LEN, \"%s\", &name[off]);\n\n\t \n\tret = tcm_loop_setup_hba_bus(tl_hba, tcm_loop_hba_no_cnt);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tsh = tl_hba->sh;\n\ttcm_loop_hba_no_cnt++;\n\tpr_debug(\"TCM_Loop_ConfigFS: Allocated emulated Target %s Address: %s at Linux/SCSI Host ID: %d\\n\",\n\t\t tcm_loop_dump_proto_id(tl_hba), name, sh->host_no);\n\treturn &tl_hba->tl_hba_wwn;\nout:\n\tkfree(tl_hba);\n\treturn ERR_PTR(ret);\n}\n\nstatic void tcm_loop_drop_scsi_hba(\n\tstruct se_wwn *wwn)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\n\tpr_debug(\"TCM_Loop_ConfigFS: Deallocating emulated Target %s Address: %s at Linux/SCSI Host ID: %d\\n\",\n\t\t tcm_loop_dump_proto_id(tl_hba), tl_hba->tl_wwn_address,\n\t\t tl_hba->sh->host_no);\n\t \n\tdevice_unregister(&tl_hba->dev);\n}\n\n \nstatic ssize_t tcm_loop_wwn_version_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"TCM Loopback Fabric module %s\\n\", TCM_LOOP_VERSION);\n}\n\nCONFIGFS_ATTR_RO(tcm_loop_wwn_, version);\n\nstatic struct configfs_attribute *tcm_loop_wwn_attrs[] = {\n\t&tcm_loop_wwn_attr_version,\n\tNULL,\n};\n\n \n\nstatic const struct target_core_fabric_ops loop_ops = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.fabric_name\t\t\t= \"loopback\",\n\t.tpg_get_wwn\t\t\t= tcm_loop_get_endpoint_wwn,\n\t.tpg_get_tag\t\t\t= tcm_loop_get_tag,\n\t.tpg_check_demo_mode\t\t= tcm_loop_check_demo_mode,\n\t.tpg_check_prot_fabric_only\t= tcm_loop_check_prot_fabric_only,\n\t.check_stop_free\t\t= tcm_loop_check_stop_free,\n\t.release_cmd\t\t\t= tcm_loop_release_cmd,\n\t.sess_get_index\t\t\t= tcm_loop_sess_get_index,\n\t.write_pending\t\t\t= tcm_loop_write_pending,\n\t.get_cmd_state\t\t\t= tcm_loop_get_cmd_state,\n\t.queue_data_in\t\t\t= tcm_loop_queue_data_in,\n\t.queue_status\t\t\t= tcm_loop_queue_status,\n\t.queue_tm_rsp\t\t\t= tcm_loop_queue_tm_rsp,\n\t.aborted_task\t\t\t= tcm_loop_aborted_task,\n\t.fabric_make_wwn\t\t= tcm_loop_make_scsi_hba,\n\t.fabric_drop_wwn\t\t= tcm_loop_drop_scsi_hba,\n\t.fabric_make_tpg\t\t= tcm_loop_make_naa_tpg,\n\t.fabric_drop_tpg\t\t= tcm_loop_drop_naa_tpg,\n\t.fabric_post_link\t\t= tcm_loop_port_link,\n\t.fabric_pre_unlink\t\t= tcm_loop_port_unlink,\n\t.tfc_wwn_attrs\t\t\t= tcm_loop_wwn_attrs,\n\t.tfc_tpg_base_attrs\t\t= tcm_loop_tpg_attrs,\n\t.tfc_tpg_attrib_attrs\t\t= tcm_loop_tpg_attrib_attrs,\n};\n\nstatic int __init tcm_loop_fabric_init(void)\n{\n\tint ret = -ENOMEM;\n\n\ttcm_loop_cmd_cache = kmem_cache_create(\"tcm_loop_cmd_cache\",\n\t\t\t\tsizeof(struct tcm_loop_cmd),\n\t\t\t\t__alignof__(struct tcm_loop_cmd),\n\t\t\t\t0, NULL);\n\tif (!tcm_loop_cmd_cache) {\n\t\tpr_debug(\"kmem_cache_create() for tcm_loop_cmd_cache failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = tcm_loop_alloc_core_bus();\n\tif (ret)\n\t\tgoto out_destroy_cache;\n\n\tret = target_register_template(&loop_ops);\n\tif (ret)\n\t\tgoto out_release_core_bus;\n\n\treturn 0;\n\nout_release_core_bus:\n\ttcm_loop_release_core_bus();\nout_destroy_cache:\n\tkmem_cache_destroy(tcm_loop_cmd_cache);\nout:\n\treturn ret;\n}\n\nstatic void __exit tcm_loop_fabric_exit(void)\n{\n\ttarget_unregister_template(&loop_ops);\n\ttcm_loop_release_core_bus();\n\tkmem_cache_destroy(tcm_loop_cmd_cache);\n}\n\nMODULE_DESCRIPTION(\"TCM loopback virtual Linux/SCSI fabric module\");\nMODULE_AUTHOR(\"Nicholas A. Bellinger <nab@risingtidesystems.com>\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(tcm_loop_fabric_init);\nmodule_exit(tcm_loop_fabric_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}