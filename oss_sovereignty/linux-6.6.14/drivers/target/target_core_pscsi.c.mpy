{
  "module_name": "target_core_pscsi.c",
  "hash_id": "861b0ba6febddbfe25d1031387ce1e6efeca0b07b03f8f2d021d1e457ee32b52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/target/target_core_pscsi.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/timer.h>\n#include <linux/blkdev.h>\n#include <linux/blk_types.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/cdrom.h>\n#include <linux/ratelimit.h>\n#include <linux/module.h>\n#include <asm/unaligned.h>\n\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n\n#include <target/target_core_base.h>\n#include <target/target_core_backend.h>\n\n#include \"target_core_alua.h\"\n#include \"target_core_internal.h\"\n#include \"target_core_pscsi.h\"\n\nstatic inline struct pscsi_dev_virt *PSCSI_DEV(struct se_device *dev)\n{\n\treturn container_of(dev, struct pscsi_dev_virt, dev);\n}\n\nstatic sense_reason_t pscsi_execute_cmd(struct se_cmd *cmd);\nstatic enum rq_end_io_ret pscsi_req_done(struct request *, blk_status_t);\n\n \nstatic int pscsi_attach_hba(struct se_hba *hba, u32 host_id)\n{\n\tstruct pscsi_hba_virt *phv;\n\n\tphv = kzalloc(sizeof(struct pscsi_hba_virt), GFP_KERNEL);\n\tif (!phv) {\n\t\tpr_err(\"Unable to allocate struct pscsi_hba_virt\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tphv->phv_host_id = host_id;\n\tphv->phv_mode = PHV_VIRTUAL_HOST_ID;\n\n\thba->hba_ptr = phv;\n\n\tpr_debug(\"CORE_HBA[%d] - TCM SCSI HBA Driver %s on\"\n\t\t\" Generic Target Core Stack %s\\n\", hba->hba_id,\n\t\tPSCSI_VERSION, TARGET_CORE_VERSION);\n\tpr_debug(\"CORE_HBA[%d] - Attached SCSI HBA to Generic\\n\",\n\t       hba->hba_id);\n\n\treturn 0;\n}\n\nstatic void pscsi_detach_hba(struct se_hba *hba)\n{\n\tstruct pscsi_hba_virt *phv = hba->hba_ptr;\n\tstruct Scsi_Host *scsi_host = phv->phv_lld_host;\n\n\tif (scsi_host) {\n\t\tscsi_host_put(scsi_host);\n\n\t\tpr_debug(\"CORE_HBA[%d] - Detached SCSI HBA: %s from\"\n\t\t\t\" Generic Target Core\\n\", hba->hba_id,\n\t\t\t(scsi_host->hostt->name) ? (scsi_host->hostt->name) :\n\t\t\t\"Unknown\");\n\t} else\n\t\tpr_debug(\"CORE_HBA[%d] - Detached Virtual SCSI HBA\"\n\t\t\t\" from Generic Target Core\\n\", hba->hba_id);\n\n\tkfree(phv);\n\thba->hba_ptr = NULL;\n}\n\nstatic int pscsi_pmode_enable_hba(struct se_hba *hba, unsigned long mode_flag)\n{\n\tstruct pscsi_hba_virt *phv = hba->hba_ptr;\n\tstruct Scsi_Host *sh = phv->phv_lld_host;\n\t \n\tif (!mode_flag) {\n\t\tif (!sh)\n\t\t\treturn 0;\n\n\t\tphv->phv_lld_host = NULL;\n\t\tphv->phv_mode = PHV_VIRTUAL_HOST_ID;\n\n\t\tpr_debug(\"CORE_HBA[%d] - Disabled pSCSI HBA Passthrough\"\n\t\t\t\" %s\\n\", hba->hba_id, (sh->hostt->name) ?\n\t\t\t(sh->hostt->name) : \"Unknown\");\n\n\t\tscsi_host_put(sh);\n\t\treturn 0;\n\t}\n\t \n\tsh = scsi_host_lookup(phv->phv_host_id);\n\tif (!sh) {\n\t\tpr_err(\"pSCSI: Unable to locate SCSI Host for\"\n\t\t\t\" phv_host_id: %d\\n\", phv->phv_host_id);\n\t\treturn -EINVAL;\n\t}\n\n\tphv->phv_lld_host = sh;\n\tphv->phv_mode = PHV_LLD_SCSI_HOST_NO;\n\n\tpr_debug(\"CORE_HBA[%d] - Enabled pSCSI HBA Passthrough %s\\n\",\n\t\thba->hba_id, (sh->hostt->name) ? (sh->hostt->name) : \"Unknown\");\n\n\treturn 1;\n}\n\nstatic void pscsi_tape_read_blocksize(struct se_device *dev,\n\t\tstruct scsi_device *sdev)\n{\n\tunsigned char cdb[MAX_COMMAND_SIZE], *buf;\n\tint ret;\n\n\tbuf = kzalloc(12, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out_free;\n\n\tmemset(cdb, 0, MAX_COMMAND_SIZE);\n\tcdb[0] = MODE_SENSE;\n\tcdb[4] = 0x0c;  \n\n\tret = scsi_execute_cmd(sdev, cdb, REQ_OP_DRV_IN, buf, 12, HZ, 1, NULL);\n\tif (ret)\n\t\tgoto out_free;\n\n\t \n\tsdev->sector_size = get_unaligned_be24(&buf[9]);\nout_free:\n\tif (!sdev->sector_size)\n\t\tsdev->sector_size = 1024;\n\n\tkfree(buf);\n}\n\nstatic void\npscsi_set_inquiry_info(struct scsi_device *sdev, struct t10_wwn *wwn)\n{\n\tif (sdev->inquiry_len < INQUIRY_LEN)\n\t\treturn;\n\t \n\tBUILD_BUG_ON(sizeof(wwn->vendor) != INQUIRY_VENDOR_LEN + 1);\n\tsnprintf(wwn->vendor, sizeof(wwn->vendor),\n\t\t \"%.\" __stringify(INQUIRY_VENDOR_LEN) \"s\", sdev->vendor);\n\tBUILD_BUG_ON(sizeof(wwn->model) != INQUIRY_MODEL_LEN + 1);\n\tsnprintf(wwn->model, sizeof(wwn->model),\n\t\t \"%.\" __stringify(INQUIRY_MODEL_LEN) \"s\", sdev->model);\n\tBUILD_BUG_ON(sizeof(wwn->revision) != INQUIRY_REVISION_LEN + 1);\n\tsnprintf(wwn->revision, sizeof(wwn->revision),\n\t\t \"%.\" __stringify(INQUIRY_REVISION_LEN) \"s\", sdev->rev);\n}\n\nstatic int\npscsi_get_inquiry_vpd_serial(struct scsi_device *sdev, struct t10_wwn *wwn)\n{\n\tunsigned char cdb[MAX_COMMAND_SIZE], *buf;\n\tint ret;\n\n\tbuf = kzalloc(INQUIRY_VPD_SERIAL_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemset(cdb, 0, MAX_COMMAND_SIZE);\n\tcdb[0] = INQUIRY;\n\tcdb[1] = 0x01;  \n\tcdb[2] = 0x80;  \n\tput_unaligned_be16(INQUIRY_VPD_SERIAL_LEN, &cdb[3]);\n\n\tret = scsi_execute_cmd(sdev, cdb, REQ_OP_DRV_IN, buf,\n\t\t\t       INQUIRY_VPD_SERIAL_LEN, HZ, 1, NULL);\n\tif (ret)\n\t\tgoto out_free;\n\n\tsnprintf(&wwn->unit_serial[0], INQUIRY_VPD_SERIAL_LEN, \"%s\", &buf[4]);\n\n\twwn->t10_dev->dev_flags |= DF_FIRMWARE_VPD_UNIT_SERIAL;\n\n\tkfree(buf);\n\treturn 0;\n\nout_free:\n\tkfree(buf);\n\treturn -EPERM;\n}\n\nstatic void\npscsi_get_inquiry_vpd_device_ident(struct scsi_device *sdev,\n\t\tstruct t10_wwn *wwn)\n{\n\tunsigned char cdb[MAX_COMMAND_SIZE], *buf, *page_83;\n\tint ident_len, page_len, off = 4, ret;\n\tstruct t10_vpd *vpd;\n\n\tbuf = kzalloc(INQUIRY_VPD_SERIAL_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tmemset(cdb, 0, MAX_COMMAND_SIZE);\n\tcdb[0] = INQUIRY;\n\tcdb[1] = 0x01;  \n\tcdb[2] = 0x83;  \n\tput_unaligned_be16(INQUIRY_VPD_DEVICE_IDENTIFIER_LEN, &cdb[3]);\n\n\tret = scsi_execute_cmd(sdev, cdb, REQ_OP_DRV_IN, buf,\n\t\t\t       INQUIRY_VPD_DEVICE_IDENTIFIER_LEN, HZ, 1, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tpage_len = get_unaligned_be16(&buf[2]);\n\twhile (page_len > 0) {\n\t\t \n\t\tpage_83 = &buf[off];\n\t\tident_len = page_83[3];\n\t\tif (!ident_len) {\n\t\t\tpr_err(\"page_83[3]: identifier\"\n\t\t\t\t\t\" length zero!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tpr_debug(\"T10 VPD Identifier Length: %d\\n\", ident_len);\n\n\t\tvpd = kzalloc(sizeof(struct t10_vpd), GFP_KERNEL);\n\t\tif (!vpd) {\n\t\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\t\t\" struct t10_vpd\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tINIT_LIST_HEAD(&vpd->vpd_list);\n\n\t\ttransport_set_vpd_proto_id(vpd, page_83);\n\t\ttransport_set_vpd_assoc(vpd, page_83);\n\n\t\tif (transport_set_vpd_ident_type(vpd, page_83) < 0) {\n\t\t\toff += (ident_len + 4);\n\t\t\tpage_len -= (ident_len + 4);\n\t\t\tkfree(vpd);\n\t\t\tcontinue;\n\t\t}\n\t\tif (transport_set_vpd_ident(vpd, page_83) < 0) {\n\t\t\toff += (ident_len + 4);\n\t\t\tpage_len -= (ident_len + 4);\n\t\t\tkfree(vpd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_add_tail(&vpd->vpd_list, &wwn->t10_vpd_list);\n\t\toff += (ident_len + 4);\n\t\tpage_len -= (ident_len + 4);\n\t}\n\nout:\n\tkfree(buf);\n}\n\nstatic int pscsi_add_device_to_list(struct se_device *dev,\n\t\tstruct scsi_device *sd)\n{\n\tstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\n\tstruct request_queue *q = sd->request_queue;\n\n\tpdv->pdv_sd = sd;\n\n\tif (!sd->queue_depth) {\n\t\tsd->queue_depth = PSCSI_DEFAULT_QUEUEDEPTH;\n\n\t\tpr_err(\"Set broken SCSI Device %d:%d:%llu\"\n\t\t\t\" queue_depth to %d\\n\", sd->channel, sd->id,\n\t\t\t\tsd->lun, sd->queue_depth);\n\t}\n\n\tdev->dev_attrib.hw_block_size =\n\t\tmin_not_zero((int)sd->sector_size, 512);\n\tdev->dev_attrib.hw_max_sectors =\n\t\tmin_not_zero(sd->host->max_sectors, queue_max_hw_sectors(q));\n\tdev->dev_attrib.hw_queue_depth = sd->queue_depth;\n\n\t \n\tpscsi_set_inquiry_info(sd, &dev->t10_wwn);\n\n\t \n\tif (!pscsi_get_inquiry_vpd_serial(sd, &dev->t10_wwn)) {\n\t\t \n\t\tpscsi_get_inquiry_vpd_device_ident(sd, &dev->t10_wwn);\n\t}\n\n\t \n\tif (sd->type == TYPE_TAPE) {\n\t\tpscsi_tape_read_blocksize(dev, sd);\n\t\tdev->dev_attrib.hw_block_size = sd->sector_size;\n\t}\n\treturn 0;\n}\n\nstatic struct se_device *pscsi_alloc_device(struct se_hba *hba,\n\t\tconst char *name)\n{\n\tstruct pscsi_dev_virt *pdv;\n\n\tpdv = kzalloc(sizeof(struct pscsi_dev_virt), GFP_KERNEL);\n\tif (!pdv) {\n\t\tpr_err(\"Unable to allocate memory for struct pscsi_dev_virt\\n\");\n\t\treturn NULL;\n\t}\n\n\tpr_debug(\"PSCSI: Allocated pdv: %p for %s\\n\", pdv, name);\n\treturn &pdv->dev;\n}\n\n \nstatic int pscsi_create_type_disk(struct se_device *dev, struct scsi_device *sd)\n\t__releases(sh->host_lock)\n{\n\tstruct pscsi_hba_virt *phv = dev->se_hba->hba_ptr;\n\tstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\n\tstruct Scsi_Host *sh = sd->host;\n\tstruct block_device *bd;\n\tint ret;\n\n\tif (scsi_device_get(sd)) {\n\t\tpr_err(\"scsi_device_get() failed for %d:%d:%d:%llu\\n\",\n\t\t\tsh->host_no, sd->channel, sd->id, sd->lun);\n\t\tspin_unlock_irq(sh->host_lock);\n\t\treturn -EIO;\n\t}\n\tspin_unlock_irq(sh->host_lock);\n\t \n\tbd = blkdev_get_by_path(dev->udev_path, BLK_OPEN_WRITE | BLK_OPEN_READ,\n\t\t\t\tpdv, NULL);\n\tif (IS_ERR(bd)) {\n\t\tpr_err(\"pSCSI: blkdev_get_by_path() failed\\n\");\n\t\tscsi_device_put(sd);\n\t\treturn PTR_ERR(bd);\n\t}\n\tpdv->pdv_bd = bd;\n\n\tret = pscsi_add_device_to_list(dev, sd);\n\tif (ret) {\n\t\tblkdev_put(pdv->pdv_bd, pdv);\n\t\tscsi_device_put(sd);\n\t\treturn ret;\n\t}\n\n\tpr_debug(\"CORE_PSCSI[%d] - Added TYPE_%s for %d:%d:%d:%llu\\n\",\n\t\tphv->phv_host_id, sd->type == TYPE_DISK ? \"DISK\" : \"ZBC\",\n\t\tsh->host_no, sd->channel, sd->id, sd->lun);\n\treturn 0;\n}\n\n \nstatic int pscsi_create_type_nondisk(struct se_device *dev, struct scsi_device *sd)\n\t__releases(sh->host_lock)\n{\n\tstruct pscsi_hba_virt *phv = dev->se_hba->hba_ptr;\n\tstruct Scsi_Host *sh = sd->host;\n\tint ret;\n\n\tif (scsi_device_get(sd)) {\n\t\tpr_err(\"scsi_device_get() failed for %d:%d:%d:%llu\\n\",\n\t\t\tsh->host_no, sd->channel, sd->id, sd->lun);\n\t\tspin_unlock_irq(sh->host_lock);\n\t\treturn -EIO;\n\t}\n\tspin_unlock_irq(sh->host_lock);\n\n\tret = pscsi_add_device_to_list(dev, sd);\n\tif (ret) {\n\t\tscsi_device_put(sd);\n\t\treturn ret;\n\t}\n\tpr_debug(\"CORE_PSCSI[%d] - Added Type: %s for %d:%d:%d:%llu\\n\",\n\t\tphv->phv_host_id, scsi_device_type(sd->type), sh->host_no,\n\t\tsd->channel, sd->id, sd->lun);\n\n\treturn 0;\n}\n\nstatic int pscsi_configure_device(struct se_device *dev)\n{\n\tstruct se_hba *hba = dev->se_hba;\n\tstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\n\tstruct scsi_device *sd;\n\tstruct pscsi_hba_virt *phv = dev->se_hba->hba_ptr;\n\tstruct Scsi_Host *sh = phv->phv_lld_host;\n\tint legacy_mode_enable = 0;\n\tint ret;\n\n\tif (!(pdv->pdv_flags & PDF_HAS_CHANNEL_ID) ||\n\t    !(pdv->pdv_flags & PDF_HAS_TARGET_ID) ||\n\t    !(pdv->pdv_flags & PDF_HAS_LUN_ID)) {\n\t\tpr_err(\"Missing scsi_channel_id=, scsi_target_id= and\"\n\t\t\t\" scsi_lun_id= parameters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!sh) {\n\t\tif (phv->phv_mode == PHV_LLD_SCSI_HOST_NO) {\n\t\t\tpr_err(\"pSCSI: Unable to locate struct\"\n\t\t\t\t\" Scsi_Host for PHV_LLD_SCSI_HOST_NO\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t \n\t\tif (!(dev->dev_flags & DF_USING_UDEV_PATH)) {\n\t\t\tpr_err(\"pSCSI: udev_path attribute has not\"\n\t\t\t\t\" been set before ENABLE=1\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (!(pdv->pdv_flags & PDF_HAS_VIRT_HOST_ID)) {\n\t\t\tif (hba->dev_count) {\n\t\t\t\tpr_err(\"pSCSI: Unable to set hba_mode\"\n\t\t\t\t\t\" with active devices\\n\");\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\n\t\t\tif (pscsi_pmode_enable_hba(hba, 1) != 1)\n\t\t\t\treturn -ENODEV;\n\n\t\t\tlegacy_mode_enable = 1;\n\t\t\thba->hba_flags |= HBA_FLAGS_PSCSI_MODE;\n\t\t\tsh = phv->phv_lld_host;\n\t\t} else {\n\t\t\tsh = scsi_host_lookup(pdv->pdv_host_id);\n\t\t\tif (!sh) {\n\t\t\t\tpr_err(\"pSCSI: Unable to locate\"\n\t\t\t\t\t\" pdv_host_id: %d\\n\", pdv->pdv_host_id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpdv->pdv_lld_host = sh;\n\t\t}\n\t} else {\n\t\tif (phv->phv_mode == PHV_VIRTUAL_HOST_ID) {\n\t\t\tpr_err(\"pSCSI: PHV_VIRTUAL_HOST_ID set while\"\n\t\t\t\t\" struct Scsi_Host exists\\n\");\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tspin_lock_irq(sh->host_lock);\n\tlist_for_each_entry(sd, &sh->__devices, siblings) {\n\t\tif ((pdv->pdv_channel_id != sd->channel) ||\n\t\t    (pdv->pdv_target_id != sd->id) ||\n\t\t    (pdv->pdv_lun_id != sd->lun))\n\t\t\tcontinue;\n\t\t \n\t\tswitch (sd->type) {\n\t\tcase TYPE_DISK:\n\t\tcase TYPE_ZBC:\n\t\t\tret = pscsi_create_type_disk(dev, sd);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = pscsi_create_type_nondisk(dev, sd);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tif (phv->phv_mode == PHV_VIRTUAL_HOST_ID)\n\t\t\t\tscsi_host_put(sh);\n\t\t\telse if (legacy_mode_enable) {\n\t\t\t\tpscsi_pmode_enable_hba(hba, 0);\n\t\t\t\thba->hba_flags &= ~HBA_FLAGS_PSCSI_MODE;\n\t\t\t}\n\t\t\tpdv->pdv_sd = NULL;\n\t\t\treturn ret;\n\t\t}\n\t\treturn 0;\n\t}\n\tspin_unlock_irq(sh->host_lock);\n\n\tpr_err(\"pSCSI: Unable to locate %d:%d:%d:%d\\n\", sh->host_no,\n\t\tpdv->pdv_channel_id,  pdv->pdv_target_id, pdv->pdv_lun_id);\n\n\tif (phv->phv_mode == PHV_VIRTUAL_HOST_ID)\n\t\tscsi_host_put(sh);\n\telse if (legacy_mode_enable) {\n\t\tpscsi_pmode_enable_hba(hba, 0);\n\t\thba->hba_flags &= ~HBA_FLAGS_PSCSI_MODE;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic void pscsi_dev_call_rcu(struct rcu_head *p)\n{\n\tstruct se_device *dev = container_of(p, struct se_device, rcu_head);\n\tstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\n\n\tkfree(pdv);\n}\n\nstatic void pscsi_free_device(struct se_device *dev)\n{\n\tcall_rcu(&dev->rcu_head, pscsi_dev_call_rcu);\n}\n\nstatic void pscsi_destroy_device(struct se_device *dev)\n{\n\tstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\n\tstruct pscsi_hba_virt *phv = dev->se_hba->hba_ptr;\n\tstruct scsi_device *sd = pdv->pdv_sd;\n\n\tif (sd) {\n\t\t \n\t\tif ((sd->type == TYPE_DISK || sd->type == TYPE_ZBC) &&\n\t\t    pdv->pdv_bd) {\n\t\t\tblkdev_put(pdv->pdv_bd, pdv);\n\t\t\tpdv->pdv_bd = NULL;\n\t\t}\n\t\t \n\t\tif ((phv->phv_mode == PHV_LLD_SCSI_HOST_NO) &&\n\t\t    (phv->phv_lld_host != NULL))\n\t\t\tscsi_host_put(phv->phv_lld_host);\n\t\telse if (pdv->pdv_lld_host)\n\t\t\tscsi_host_put(pdv->pdv_lld_host);\n\n\t\tscsi_device_put(sd);\n\n\t\tpdv->pdv_sd = NULL;\n\t}\n}\n\nstatic void pscsi_complete_cmd(struct se_cmd *cmd, u8 scsi_status,\n\t\t\t       unsigned char *req_sense, int valid_data)\n{\n\tstruct pscsi_dev_virt *pdv = PSCSI_DEV(cmd->se_dev);\n\tstruct scsi_device *sd = pdv->pdv_sd;\n\tunsigned char *cdb = cmd->priv;\n\n\t \n\tif (!cdb)\n\t\treturn;\n\n\t \n\tif (!cmd->data_length)\n\t\tgoto after_mode_sense;\n\n\tif (((cdb[0] == MODE_SENSE) || (cdb[0] == MODE_SENSE_10)) &&\n\t    scsi_status == SAM_STAT_GOOD) {\n\t\tbool read_only = target_lun_is_rdonly(cmd);\n\n\t\tif (read_only) {\n\t\t\tunsigned char *buf;\n\n\t\t\tbuf = transport_kmap_data_sg(cmd);\n\t\t\tif (!buf) {\n\t\t\t\t;  \n\t\t\t} else {\n\t\t\t\tif (cdb[0] == MODE_SENSE_10) {\n\t\t\t\t\tif (!(buf[3] & 0x80))\n\t\t\t\t\t\tbuf[3] |= 0x80;\n\t\t\t\t} else {\n\t\t\t\t\tif (!(buf[2] & 0x80))\n\t\t\t\t\t\tbuf[2] |= 0x80;\n\t\t\t\t}\n\n\t\t\t\ttransport_kunmap_data_sg(cmd);\n\t\t\t}\n\t\t}\n\t}\nafter_mode_sense:\n\n\tif (sd->type != TYPE_TAPE || !cmd->data_length)\n\t\tgoto after_mode_select;\n\n\t \n\tif (((cdb[0] == MODE_SELECT) || (cdb[0] == MODE_SELECT_10)) &&\n\t     scsi_status == SAM_STAT_GOOD) {\n\t\tunsigned char *buf;\n\t\tu16 bdl;\n\t\tu32 blocksize;\n\n\t\tbuf = sg_virt(&cmd->t_data_sg[0]);\n\t\tif (!buf) {\n\t\t\tpr_err(\"Unable to get buf for scatterlist\\n\");\n\t\t\tgoto after_mode_select;\n\t\t}\n\n\t\tif (cdb[0] == MODE_SELECT)\n\t\t\tbdl = buf[3];\n\t\telse\n\t\t\tbdl = get_unaligned_be16(&buf[6]);\n\n\t\tif (!bdl)\n\t\t\tgoto after_mode_select;\n\n\t\tif (cdb[0] == MODE_SELECT)\n\t\t\tblocksize = get_unaligned_be24(&buf[9]);\n\t\telse\n\t\t\tblocksize = get_unaligned_be24(&buf[13]);\n\n\t\tsd->sector_size = blocksize;\n\t}\nafter_mode_select:\n\n\tif (scsi_status == SAM_STAT_CHECK_CONDITION) {\n\t\ttransport_copy_sense_to_cmd(cmd, req_sense);\n\n\t\t \n\t\tif (sd->type == TYPE_TAPE && valid_data &&\n\t\t    cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t \n\t\t\tif (req_sense[0] == 0xf0 &&\t \n\t\t\t    req_sense[2] & 0xe0 &&\t \n\t\t\t    (req_sense[2] & 0xf) == 0) {  \n\t\t\t\tpr_debug(\"Tape FM/EOM/ILI status detected. Treat as normal read.\\n\");\n\t\t\t\tcmd->se_cmd_flags |= SCF_TREAT_READ_AS_NORMAL;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum {\n\tOpt_scsi_host_id, Opt_scsi_channel_id, Opt_scsi_target_id,\n\tOpt_scsi_lun_id, Opt_err\n};\n\nstatic match_table_t tokens = {\n\t{Opt_scsi_host_id, \"scsi_host_id=%d\"},\n\t{Opt_scsi_channel_id, \"scsi_channel_id=%d\"},\n\t{Opt_scsi_target_id, \"scsi_target_id=%d\"},\n\t{Opt_scsi_lun_id, \"scsi_lun_id=%d\"},\n\t{Opt_err, NULL}\n};\n\nstatic ssize_t pscsi_set_configfs_dev_params(struct se_device *dev,\n\t\tconst char *page, ssize_t count)\n{\n\tstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\n\tstruct pscsi_hba_virt *phv = dev->se_hba->hba_ptr;\n\tchar *orig, *ptr, *opts;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = 0, arg, token;\n\n\topts = kstrdup(page, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\n\torig = opts;\n\n\twhile ((ptr = strsep(&opts, \",\\n\")) != NULL) {\n\t\tif (!*ptr)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(ptr, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_scsi_host_id:\n\t\t\tif (phv->phv_mode == PHV_LLD_SCSI_HOST_NO) {\n\t\t\t\tpr_err(\"PSCSI[%d]: Unable to accept\"\n\t\t\t\t\t\" scsi_host_id while phv_mode ==\"\n\t\t\t\t\t\" PHV_LLD_SCSI_HOST_NO\\n\",\n\t\t\t\t\tphv->phv_host_id);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = match_int(args, &arg);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tpdv->pdv_host_id = arg;\n\t\t\tpr_debug(\"PSCSI[%d]: Referencing SCSI Host ID:\"\n\t\t\t\t\" %d\\n\", phv->phv_host_id, pdv->pdv_host_id);\n\t\t\tpdv->pdv_flags |= PDF_HAS_VIRT_HOST_ID;\n\t\t\tbreak;\n\t\tcase Opt_scsi_channel_id:\n\t\t\tret = match_int(args, &arg);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tpdv->pdv_channel_id = arg;\n\t\t\tpr_debug(\"PSCSI[%d]: Referencing SCSI Channel\"\n\t\t\t\t\" ID: %d\\n\",  phv->phv_host_id,\n\t\t\t\tpdv->pdv_channel_id);\n\t\t\tpdv->pdv_flags |= PDF_HAS_CHANNEL_ID;\n\t\t\tbreak;\n\t\tcase Opt_scsi_target_id:\n\t\t\tret = match_int(args, &arg);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tpdv->pdv_target_id = arg;\n\t\t\tpr_debug(\"PSCSI[%d]: Referencing SCSI Target\"\n\t\t\t\t\" ID: %d\\n\", phv->phv_host_id,\n\t\t\t\tpdv->pdv_target_id);\n\t\t\tpdv->pdv_flags |= PDF_HAS_TARGET_ID;\n\t\t\tbreak;\n\t\tcase Opt_scsi_lun_id:\n\t\t\tret = match_int(args, &arg);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tpdv->pdv_lun_id = arg;\n\t\t\tpr_debug(\"PSCSI[%d]: Referencing SCSI LUN ID:\"\n\t\t\t\t\" %d\\n\", phv->phv_host_id, pdv->pdv_lun_id);\n\t\t\tpdv->pdv_flags |= PDF_HAS_LUN_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(orig);\n\treturn (!ret) ? count : ret;\n}\n\nstatic ssize_t pscsi_show_configfs_dev_params(struct se_device *dev, char *b)\n{\n\tstruct pscsi_hba_virt *phv = dev->se_hba->hba_ptr;\n\tstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\n\tstruct scsi_device *sd = pdv->pdv_sd;\n\tunsigned char host_id[16];\n\tssize_t bl;\n\n\tif (phv->phv_mode == PHV_VIRTUAL_HOST_ID)\n\t\tsnprintf(host_id, 16, \"%d\", pdv->pdv_host_id);\n\telse\n\t\tsnprintf(host_id, 16, \"PHBA Mode\");\n\n\tbl = sprintf(b, \"SCSI Device Bus Location:\"\n\t\t\" Channel ID: %d Target ID: %d LUN: %d Host ID: %s\\n\",\n\t\tpdv->pdv_channel_id, pdv->pdv_target_id, pdv->pdv_lun_id,\n\t\thost_id);\n\n\tif (sd) {\n\t\tbl += sprintf(b + bl, \"        Vendor: %.\"\n\t\t\t__stringify(INQUIRY_VENDOR_LEN) \"s\", sd->vendor);\n\t\tbl += sprintf(b + bl, \" Model: %.\"\n\t\t\t__stringify(INQUIRY_MODEL_LEN) \"s\", sd->model);\n\t\tbl += sprintf(b + bl, \" Rev: %.\"\n\t\t\t__stringify(INQUIRY_REVISION_LEN) \"s\\n\", sd->rev);\n\t}\n\treturn bl;\n}\n\nstatic void pscsi_bi_endio(struct bio *bio)\n{\n\tbio_uninit(bio);\n\tkfree(bio);\n}\n\nstatic sense_reason_t\npscsi_map_sg(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,\n\t\tstruct request *req)\n{\n\tstruct pscsi_dev_virt *pdv = PSCSI_DEV(cmd->se_dev);\n\tstruct bio *bio = NULL;\n\tstruct page *page;\n\tstruct scatterlist *sg;\n\tu32 data_len = cmd->data_length, i, len, bytes, off;\n\tint nr_pages = (cmd->data_length + sgl[0].offset +\n\t\t\tPAGE_SIZE - 1) >> PAGE_SHIFT;\n\tint nr_vecs = 0, rc;\n\tint rw = (cmd->data_direction == DMA_TO_DEVICE);\n\n\tBUG_ON(!cmd->data_length);\n\n\tpr_debug(\"PSCSI: nr_pages: %d\\n\", nr_pages);\n\n\tfor_each_sg(sgl, sg, sgl_nents, i) {\n\t\tpage = sg_page(sg);\n\t\toff = sg->offset;\n\t\tlen = sg->length;\n\n\t\tpr_debug(\"PSCSI: i: %d page: %p len: %d off: %d\\n\", i,\n\t\t\tpage, len, off);\n\n\t\t \n\t\tif (off + len > PAGE_SIZE)\n\t\t\tgoto fail;\n\n\t\tif (len > 0 && data_len > 0) {\n\t\t\tbytes = min_t(unsigned int, len, PAGE_SIZE - off);\n\t\t\tbytes = min(bytes, data_len);\n\n\t\t\tif (!bio) {\nnew_bio:\n\t\t\t\tnr_vecs = bio_max_segs(nr_pages);\n\t\t\t\tbio = bio_kmalloc(nr_vecs, GFP_KERNEL);\n\t\t\t\tif (!bio)\n\t\t\t\t\tgoto fail;\n\t\t\t\tbio_init(bio, NULL, bio->bi_inline_vecs, nr_vecs,\n\t\t\t\t\t rw ? REQ_OP_WRITE : REQ_OP_READ);\n\t\t\t\tbio->bi_end_io = pscsi_bi_endio;\n\n\t\t\t\tpr_debug(\"PSCSI: Allocated bio: %p,\"\n\t\t\t\t\t\" dir: %s nr_vecs: %d\\n\", bio,\n\t\t\t\t\t(rw) ? \"rw\" : \"r\", nr_vecs);\n\t\t\t}\n\n\t\t\tpr_debug(\"PSCSI: Calling bio_add_pc_page() i: %d\"\n\t\t\t\t\" bio: %p page: %p len: %d off: %d\\n\", i, bio,\n\t\t\t\tpage, len, off);\n\n\t\t\trc = bio_add_pc_page(pdv->pdv_sd->request_queue,\n\t\t\t\t\tbio, page, bytes, off);\n\t\t\tpr_debug(\"PSCSI: bio->bi_vcnt: %d nr_vecs: %d\\n\",\n\t\t\t\tbio_segments(bio), nr_vecs);\n\t\t\tif (rc != bytes) {\n\t\t\t\tpr_debug(\"PSCSI: Reached bio->bi_vcnt max:\"\n\t\t\t\t\t\" %d i: %d bio: %p, allocating another\"\n\t\t\t\t\t\" bio\\n\", bio->bi_vcnt, i, bio);\n\n\t\t\t\trc = blk_rq_append_bio(req, bio);\n\t\t\t\tif (rc) {\n\t\t\t\t\tpr_err(\"pSCSI: failed to append bio\\n\");\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\n\t\t\t\tgoto new_bio;\n\t\t\t}\n\n\t\t\tdata_len -= bytes;\n\t\t}\n\t}\n\n\tif (bio) {\n\t\trc = blk_rq_append_bio(req, bio);\n\t\tif (rc) {\n\t\t\tpr_err(\"pSCSI: failed to append bio\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn 0;\nfail:\n\tif (bio)\n\t\tbio_put(bio);\n\twhile (req->bio) {\n\t\tbio = req->bio;\n\t\treq->bio = bio->bi_next;\n\t\tbio_put(bio);\n\t}\n\treq->biotail = NULL;\n\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n}\n\nstatic sense_reason_t\npscsi_parse_cdb(struct se_cmd *cmd)\n{\n\tif (cmd->se_cmd_flags & SCF_BIDI)\n\t\treturn TCM_UNSUPPORTED_SCSI_OPCODE;\n\n\treturn passthrough_parse_cdb(cmd, pscsi_execute_cmd);\n}\n\nstatic sense_reason_t\npscsi_execute_cmd(struct se_cmd *cmd)\n{\n\tstruct scatterlist *sgl = cmd->t_data_sg;\n\tu32 sgl_nents = cmd->t_data_nents;\n\tstruct pscsi_dev_virt *pdv = PSCSI_DEV(cmd->se_dev);\n\tstruct scsi_cmnd *scmd;\n\tstruct request *req;\n\tsense_reason_t ret;\n\n\treq = scsi_alloc_request(pdv->pdv_sd->request_queue,\n\t\t\tcmd->data_direction == DMA_TO_DEVICE ?\n\t\t\tREQ_OP_DRV_OUT : REQ_OP_DRV_IN, 0);\n\tif (IS_ERR(req))\n\t\treturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\n\tif (sgl) {\n\t\tret = pscsi_map_sg(cmd, sgl, sgl_nents, req);\n\t\tif (ret)\n\t\t\tgoto fail_put_request;\n\t}\n\n\treq->end_io = pscsi_req_done;\n\treq->end_io_data = cmd;\n\n\tscmd = blk_mq_rq_to_pdu(req);\n\tscmd->cmd_len = scsi_command_size(cmd->t_task_cdb);\n\tif (scmd->cmd_len > sizeof(scmd->cmnd)) {\n\t\tret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\n\t\tgoto fail_put_request;\n\t}\n\tmemcpy(scmd->cmnd, cmd->t_task_cdb, scmd->cmd_len);\n\n\tif (pdv->pdv_sd->type == TYPE_DISK ||\n\t    pdv->pdv_sd->type == TYPE_ZBC)\n\t\treq->timeout = PS_TIMEOUT_DISK;\n\telse\n\t\treq->timeout = PS_TIMEOUT_OTHER;\n\tscmd->allowed = PS_RETRY;\n\n\tcmd->priv = scmd->cmnd;\n\n\tblk_execute_rq_nowait(req, cmd->sam_task_attr == TCM_HEAD_TAG);\n\n\treturn 0;\n\nfail_put_request:\n\tblk_mq_free_request(req);\n\treturn ret;\n}\n\n \nstatic u32 pscsi_get_device_type(struct se_device *dev)\n{\n\tstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\n\tstruct scsi_device *sd = pdv->pdv_sd;\n\n\treturn (sd) ? sd->type : TYPE_NO_LUN;\n}\n\nstatic sector_t pscsi_get_blocks(struct se_device *dev)\n{\n\tstruct pscsi_dev_virt *pdv = PSCSI_DEV(dev);\n\n\tif (pdv->pdv_bd)\n\t\treturn bdev_nr_sectors(pdv->pdv_bd);\n\treturn 0;\n}\n\nstatic enum rq_end_io_ret pscsi_req_done(struct request *req,\n\t\t\t\t\t blk_status_t status)\n{\n\tstruct se_cmd *cmd = req->end_io_data;\n\tstruct scsi_cmnd *scmd = blk_mq_rq_to_pdu(req);\n\tenum sam_status scsi_status = scmd->result & 0xff;\n\tint valid_data = cmd->data_length - scmd->resid_len;\n\tu8 *cdb = cmd->priv;\n\n\tif (scsi_status != SAM_STAT_GOOD) {\n\t\tpr_debug(\"PSCSI Status Byte exception at cmd: %p CDB:\"\n\t\t\t\" 0x%02x Result: 0x%08x\\n\", cmd, cdb[0], scmd->result);\n\t}\n\n\tpscsi_complete_cmd(cmd, scsi_status, scmd->sense_buffer, valid_data);\n\n\tswitch (host_byte(scmd->result)) {\n\tcase DID_OK:\n\t\ttarget_complete_cmd_with_length(cmd, scsi_status, valid_data);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"PSCSI Host Byte exception at cmd: %p CDB:\"\n\t\t\t\" 0x%02x Result: 0x%08x\\n\", cmd, cdb[0], scmd->result);\n\t\ttarget_complete_cmd(cmd, SAM_STAT_CHECK_CONDITION);\n\t\tbreak;\n\t}\n\n\tblk_mq_free_request(req);\n\treturn RQ_END_IO_NONE;\n}\n\nstatic const struct target_backend_ops pscsi_ops = {\n\t.name\t\t\t= \"pscsi\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.transport_flags_default = TRANSPORT_FLAG_PASSTHROUGH |\n\t\t\t\t   TRANSPORT_FLAG_PASSTHROUGH_ALUA |\n\t\t\t\t   TRANSPORT_FLAG_PASSTHROUGH_PGR,\n\t.attach_hba\t\t= pscsi_attach_hba,\n\t.detach_hba\t\t= pscsi_detach_hba,\n\t.pmode_enable_hba\t= pscsi_pmode_enable_hba,\n\t.alloc_device\t\t= pscsi_alloc_device,\n\t.configure_device\t= pscsi_configure_device,\n\t.destroy_device\t\t= pscsi_destroy_device,\n\t.free_device\t\t= pscsi_free_device,\n\t.parse_cdb\t\t= pscsi_parse_cdb,\n\t.set_configfs_dev_params = pscsi_set_configfs_dev_params,\n\t.show_configfs_dev_params = pscsi_show_configfs_dev_params,\n\t.get_device_type\t= pscsi_get_device_type,\n\t.get_blocks\t\t= pscsi_get_blocks,\n\t.tb_dev_attrib_attrs\t= passthrough_attrib_attrs,\n};\n\nstatic int __init pscsi_module_init(void)\n{\n\treturn transport_backend_register(&pscsi_ops);\n}\n\nstatic void __exit pscsi_module_exit(void)\n{\n\ttarget_backend_unregister(&pscsi_ops);\n}\n\nMODULE_DESCRIPTION(\"TCM PSCSI subsystem plugin\");\nMODULE_AUTHOR(\"nab@Linux-iSCSI.org\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(pscsi_module_init);\nmodule_exit(pscsi_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}