{
  "module_name": "braille_console.c",
  "hash_id": "25502b6e2233926d5b2aa682497c7f13b463f213770858462db66fd39b9c02f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/braille/braille_console.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/console.h>\n#include <linux/notifier.h>\n\n#include <linux/selection.h>\n#include <linux/vt_kern.h>\n#include <linux/consolemap.h>\n\n#include <linux/keyboard.h>\n#include <linux/kbd_kern.h>\n#include <linux/input.h>\n\nMODULE_AUTHOR(\"samuel.thibault@ens-lyon.org\");\nMODULE_DESCRIPTION(\"braille device\");\n\n \n\n \nstatic bool sound;\nmodule_param(sound, bool, 0);\nMODULE_PARM_DESC(sound, \"emit sounds\");\n\nstatic void beep(unsigned int freq)\n{\n\tif (sound)\n\t\tkd_mksound(freq, HZ/10);\n}\n\n \n#define WIDTH 40\n#define BRAILLE_KEY KEY_INSERT\nstatic u16 console_buf[WIDTH];\nstatic int console_cursor;\n\n \nstatic int vc_x, vc_y, lastvc_x, lastvc_y;\n\n \nstatic int console_show = 1;\n \nstatic int console_newline = 1;\nstatic int lastVC = -1;\n\nstatic struct console *braille_co;\n\n \nstatic void braille_write(u16 *buf)\n{\n\tstatic u16 lastwrite[WIDTH];\n\tunsigned char data[1 + 1 + 2*WIDTH + 2 + 1], csum = 0, *c;\n\tu16 out;\n\tint i;\n\n\tif (!braille_co)\n\t\treturn;\n\n\tif (!memcmp(lastwrite, buf, WIDTH * sizeof(*buf)))\n\t\treturn;\n\tmemcpy(lastwrite, buf, WIDTH * sizeof(*buf));\n\n#define SOH 1\n#define STX 2\n#define ETX 2\n#define EOT 4\n#define ENQ 5\n\tdata[0] = STX;\n\tdata[1] = '>';\n\tcsum ^= '>';\n\tc = &data[2];\n\tfor (i = 0; i < WIDTH; i++) {\n\t\tout = buf[i];\n\t\tif (out >= 0x100)\n\t\t\tout = '?';\n\t\telse if (out == 0x00)\n\t\t\tout = ' ';\n\t\tcsum ^= out;\n\t\tif (out <= 0x05) {\n\t\t\t*c++ = SOH;\n\t\t\tout |= 0x40;\n\t\t}\n\t\t*c++ = out;\n\t}\n\n\tif (csum <= 0x05) {\n\t\t*c++ = SOH;\n\t\tcsum |= 0x40;\n\t}\n\t*c++ = csum;\n\t*c++ = ETX;\n\n\tbraille_co->write(braille_co, data, c - data);\n}\n\n \nstatic void vc_follow_cursor(struct vc_data *vc)\n{\n\tvc_x = vc->state.x - (vc->state.x % WIDTH);\n\tvc_y = vc->state.y;\n\tlastvc_x = vc->state.x;\n\tlastvc_y = vc->state.y;\n}\n\n \nstatic void vc_maybe_cursor_moved(struct vc_data *vc)\n{\n\tif (vc->state.x != lastvc_x || vc->state.y != lastvc_y)\n\t\tvc_follow_cursor(vc);\n}\n\n \nstatic void vc_refresh(struct vc_data *vc)\n{\n\tu16 buf[WIDTH];\n\tint i;\n\n\tfor (i = 0; i < WIDTH; i++) {\n\t\tu16 glyph = screen_glyph(vc,\n\t\t\t\t2 * (vc_x + i) + vc_y * vc->vc_size_row);\n\t\tbuf[i] = inverse_translate(vc, glyph, true);\n\t}\n\tbraille_write(buf);\n}\n\n \n\nstatic int keyboard_notifier_call(struct notifier_block *blk,\n\t\t\t\t  unsigned long code, void *_param)\n{\n\tstruct keyboard_notifier_param *param = _param;\n\tstruct vc_data *vc = param->vc;\n\tint ret = NOTIFY_OK;\n\n\tif (!param->down)\n\t\treturn ret;\n\n\tswitch (code) {\n\tcase KBD_KEYCODE:\n\t\tif (console_show) {\n\t\t\tif (param->value == BRAILLE_KEY) {\n\t\t\t\tconsole_show = 0;\n\t\t\t\tbeep(880);\n\t\t\t\tvc_maybe_cursor_moved(vc);\n\t\t\t\tvc_refresh(vc);\n\t\t\t\tret = NOTIFY_STOP;\n\t\t\t}\n\t\t} else {\n\t\t\tret = NOTIFY_STOP;\n\t\t\tswitch (param->value) {\n\t\t\tcase KEY_INSERT:\n\t\t\t\tbeep(440);\n\t\t\t\tconsole_show = 1;\n\t\t\t\tlastVC = -1;\n\t\t\t\tbraille_write(console_buf);\n\t\t\t\tbreak;\n\t\t\tcase KEY_LEFT:\n\t\t\t\tif (vc_x > 0) {\n\t\t\t\t\tvc_x -= WIDTH;\n\t\t\t\t\tif (vc_x < 0)\n\t\t\t\t\t\tvc_x = 0;\n\t\t\t\t} else if (vc_y >= 1) {\n\t\t\t\t\tbeep(880);\n\t\t\t\t\tvc_y--;\n\t\t\t\t\tvc_x = vc->vc_cols-WIDTH;\n\t\t\t\t} else\n\t\t\t\t\tbeep(220);\n\t\t\t\tbreak;\n\t\t\tcase KEY_RIGHT:\n\t\t\t\tif (vc_x + WIDTH < vc->vc_cols) {\n\t\t\t\t\tvc_x += WIDTH;\n\t\t\t\t} else if (vc_y + 1 < vc->vc_rows) {\n\t\t\t\t\tbeep(880);\n\t\t\t\t\tvc_y++;\n\t\t\t\t\tvc_x = 0;\n\t\t\t\t} else\n\t\t\t\t\tbeep(220);\n\t\t\t\tbreak;\n\t\t\tcase KEY_DOWN:\n\t\t\t\tif (vc_y + 1 < vc->vc_rows)\n\t\t\t\t\tvc_y++;\n\t\t\t\telse\n\t\t\t\t\tbeep(220);\n\t\t\t\tbreak;\n\t\t\tcase KEY_UP:\n\t\t\t\tif (vc_y >= 1)\n\t\t\t\t\tvc_y--;\n\t\t\t\telse\n\t\t\t\t\tbeep(220);\n\t\t\t\tbreak;\n\t\t\tcase KEY_HOME:\n\t\t\t\tvc_follow_cursor(vc);\n\t\t\t\tbreak;\n\t\t\tcase KEY_PAGEUP:\n\t\t\t\tvc_x = 0;\n\t\t\t\tvc_y = 0;\n\t\t\t\tbreak;\n\t\t\tcase KEY_PAGEDOWN:\n\t\t\t\tvc_x = 0;\n\t\t\t\tvc_y = vc->vc_rows-1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = NOTIFY_OK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret == NOTIFY_STOP)\n\t\t\t\tvc_refresh(vc);\n\t\t}\n\t\tbreak;\n\tcase KBD_POST_KEYSYM:\n\t{\n\t\tunsigned char type = KTYP(param->value) - 0xf0;\n\n\t\tif (type == KT_SPEC) {\n\t\t\tunsigned char val = KVAL(param->value);\n\t\t\tint on_off = -1;\n\n\t\t\tswitch (val) {\n\t\t\tcase KVAL(K_CAPS):\n\t\t\t\ton_off = vt_get_leds(fg_console, VC_CAPSLOCK);\n\t\t\t\tbreak;\n\t\t\tcase KVAL(K_NUM):\n\t\t\t\ton_off = vt_get_leds(fg_console, VC_NUMLOCK);\n\t\t\t\tbreak;\n\t\t\tcase KVAL(K_HOLD):\n\t\t\t\ton_off = vt_get_leds(fg_console, VC_SCROLLOCK);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (on_off == 1)\n\t\t\t\tbeep(880);\n\t\t\telse if (on_off == 0)\n\t\t\t\tbeep(440);\n\t\t}\n\t}\n\t\tbreak;\n\tcase KBD_UNBOUND_KEYCODE:\n\tcase KBD_UNICODE:\n\tcase KBD_KEYSYM:\n\t\t \n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic struct notifier_block keyboard_notifier_block = {\n\t.notifier_call = keyboard_notifier_call,\n};\n\nstatic int vt_notifier_call(struct notifier_block *blk,\n\t\t\t    unsigned long code, void *_param)\n{\n\tstruct vt_notifier_param *param = _param;\n\tstruct vc_data *vc = param->vc;\n\n\tswitch (code) {\n\tcase VT_ALLOCATE:\n\t\tbreak;\n\tcase VT_DEALLOCATE:\n\t\tbreak;\n\tcase VT_WRITE:\n\t{\n\t\tunsigned char c = param->c;\n\n\t\tif (vc->vc_num != fg_console)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\tcase '\\b':\n\t\tcase 127:\n\t\t\tif (console_cursor > 0) {\n\t\t\t\tconsole_cursor--;\n\t\t\t\tconsole_buf[console_cursor] = ' ';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\tcase '\\v':\n\t\tcase '\\f':\n\t\tcase '\\r':\n\t\t\tconsole_newline = 1;\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tc = ' ';\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tif (c < 32)\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tif (console_newline) {\n\t\t\t\tmemset(console_buf, 0, sizeof(console_buf));\n\t\t\t\tconsole_cursor = 0;\n\t\t\t\tconsole_newline = 0;\n\t\t\t}\n\t\t\tif (console_cursor == WIDTH)\n\t\t\t\tmemmove(console_buf, &console_buf[1],\n\t\t\t\t\t(WIDTH-1) * sizeof(*console_buf));\n\t\t\telse\n\t\t\t\tconsole_cursor++;\n\t\t\tconsole_buf[console_cursor-1] = c;\n\t\t\tbreak;\n\t\t}\n\t\tif (console_show)\n\t\t\tbraille_write(console_buf);\n\t\telse {\n\t\t\tvc_maybe_cursor_moved(vc);\n\t\t\tvc_refresh(vc);\n\t\t}\n\t\tbreak;\n\t}\n\tcase VT_UPDATE:\n\t\t \n\t\tif (console_show) {\n\t\t\tif (vc->vc_num != lastVC) {\n\t\t\t\tlastVC = vc->vc_num;\n\t\t\t\tmemset(console_buf, 0, sizeof(console_buf));\n\t\t\t\tconsole_cursor = 0;\n\t\t\t\tbraille_write(console_buf);\n\t\t\t}\n\t\t} else {\n\t\t\tvc_maybe_cursor_moved(vc);\n\t\t\tvc_refresh(vc);\n\t\t}\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block vt_notifier_block = {\n\t.notifier_call = vt_notifier_call,\n};\n\n \n\nint braille_register_console(struct console *console, int index,\n\t\tchar *console_options, char *braille_options)\n{\n\tint ret;\n\n\tif (!console_options)\n\t\t \n\t\tconsole_options = \"57600o8\";\n\tif (braille_co)\n\t\treturn -ENODEV;\n\tif (console->setup) {\n\t\tret = console->setup(console, console_options);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\tconsole->flags |= CON_ENABLED;\n\tconsole->index = index;\n\tbraille_co = console;\n\tregister_keyboard_notifier(&keyboard_notifier_block);\n\tregister_vt_notifier(&vt_notifier_block);\n\treturn 1;\n}\n\nint braille_unregister_console(struct console *console)\n{\n\tif (braille_co != console)\n\t\treturn -EINVAL;\n\tunregister_keyboard_notifier(&keyboard_notifier_block);\n\tunregister_vt_notifier(&vt_notifier_block);\n\tbraille_co = NULL;\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}