{
  "module_name": "genmap.c",
  "hash_id": "dac0a91c97b66d847ddcb1a395f2a1d4bec34a0156cd8d995ff21c4bfb9efd4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/speakup/genmap.c",
  "human_readable_source": "\n \n\n#include <stdlib.h>\n#include <stdio.h>\n#include <libgen.h>\n#include <string.h>\n#include <linux/version.h>\n#include <ctype.h>\n#include \"utils.h\"\n\nstruct st_key_init {\n\tchar *name;\n\tint value, shift;\n};\n\nstatic unsigned char key_data[MAXKEYVAL][16], *kp;\n\n#include \"mapdata.h\"\n\nstatic const char delims[] = \"\\t\\n \";\nstatic char *cp;\nstatic int map_ver = 119;  \nstatic int shift_table[17];\nstatic int max_states = 1, flags;\n \n\nstatic int get_shift_value(int state)\n{\n\tint i;\n\n\tfor (i = 0; shift_table[i] != state; i++) {\n\t\tif (shift_table[i] == -1) {\n\t\t\tif (i >= 16)\n\t\t\t\toops(\"too many shift states\", NULL);\n\t\t\tshift_table[i] = state;\n\t\t\tmax_states = i+1;\n\t\tbreak;\n\t}\n\t}\n\treturn i;\n}\n\nint\nmain(int argc, char *argv[])\n{\n\tint value, shift_state, i, spk_val = 0, lock_val = 0;\n\tint max_key_used = 0, num_keys_used = 0;\n\tstruct st_key *this;\n\tstruct st_key_init *p_init;\n\tchar buffer[256];\n\n\tbzero(key_table, sizeof(key_table));\n\tbzero(key_data, sizeof(key_data));\n\n\tshift_table[0] = 0;\n\tfor (i = 1; i <= 16; i++)\n\t\tshift_table[i] = -1;\n\n\tif (argc < 2) {\n\t\tfputs(\"usage: genmap filename\\n\", stderr);\n\t\texit(1);\n\t}\n\n\tfor (p_init = init_key_data; p_init->name[0] != '.'; p_init++)\n\t\tadd_key(p_init->name, p_init->value, p_init->shift);\n\n\topen_input(NULL, argv[1]);\n\twhile (fgets(buffer, sizeof(buffer), infile)) {\n\t\tlc++;\n\t\tvalue = shift_state = 0;\n\n\t\tcp = strtok(buffer, delims);\n\t\tif (*cp == '#')\n\t\t\tcontinue;\n\n\t\twhile (cp) {\n\t\t\tif (*cp == '=')\n\t\t\t\tbreak;\n\t\t\tthis = find_key(cp);\n\t\t\tif (this == NULL)\n\t\t\t\toops(\"unknown key/modifier\", cp);\n\t\t\tif (this->shift == is_shift) {\n\t\t\t\tif (value)\n\t\t\t\t\toops(\"modifiers must come first\", cp);\n\t\t\t\tshift_state += this->value;\n\t\t\t} else if (this->shift == is_input)\n\t\t\t\tvalue = this->value;\n\t\t\telse\n\t\t\t\toops(\"bad modifier or key\", cp);\n\t\t\tcp = strtok(0, delims);\n\t\t}\n\t\tif (!cp)\n\t\t\toops(\"no = found\", NULL);\n\n\t\tcp = strtok(0, delims);\n\t\tif (!cp)\n\t\t\toops(\"no speakup function after =\", NULL);\n\n\t\tthis = find_key(cp);\n\t\tif (this == NULL || this->shift != is_spk)\n\t\t\toops(\"invalid speakup function\", cp);\n\n\t\ti = get_shift_value(shift_state);\n\t\tif (key_data[value][i]) {\n\t\t\twhile (--cp > buffer)\n\t\t\t\tif (!*cp)\n\t\t\t\t\t*cp = ' ';\n\t\t\toops(\"two functions on same key combination\", cp);\n\t\t}\n\t\tkey_data[value][i] = (char)this->value;\n\t\tif (value > max_key_used)\n\t\t\tmax_key_used = value;\n\t}\n\tfclose(infile);\n\n\tthis = find_key(\"spk_key\");\n\tif (this)\n\t\tspk_val = this->value;\n\n\tthis = find_key(\"spk_lock\");\n\tif (this)\n\t\tlock_val = this->value;\n\n\tfor (lc = 1; lc <= max_key_used; lc++) {\n\t\tkp = key_data[lc];\n\t\tif (!memcmp(key_data[0], kp, 16))\n\t\t\tcontinue;\n\t\tnum_keys_used++;\n\t\tfor (i = 0; i < max_states; i++) {\n\t\t\tif (kp[i] != spk_val && kp[i] != lock_val)\n\t\t\t\tcontinue;\n\t\t\tshift_state = shift_table[i];\n\t\t\tif (shift_state&16)\n\t\t\t\tcontinue;\n\t\t\tshift_state = get_shift_value(shift_state+16);\n\t\t\tkp[shift_state] = kp[i];\n\t\t\t \n\t\t}\n\t}\n\n\tprintf(\"\\t%d, %d, %d,\\n\\t\", map_ver, num_keys_used, max_states);\n\tfor (i = 0; i < max_states; i++)\n\t\tprintf(\"%d, \", shift_table[i]);\n\tprintf(\"%d,\", flags);\n\tfor (lc = 1; lc <= max_key_used; lc++) {\n\t\tkp = key_data[lc];\n\t\tif (!memcmp(key_data[0], kp, 16))\n\t\t\tcontinue;\n\t\tprintf(\"\\n\\t%d,\", lc);\n\t\tfor (i = 0; i < max_states; i++)\n\t\t\tprintf(\" %d,\", (unsigned int)kp[i]);\n\t}\n\tprintf(\"\\n\\t0, %d\\n\", map_ver);\n\n\texit(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}