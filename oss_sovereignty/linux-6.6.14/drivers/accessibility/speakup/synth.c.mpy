{
  "module_name": "synth.c",
  "hash_id": "0ffb5e0cc935e1016ec68b834301fd8d03ed0e7466ab1b64bbe036911b83cdb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/speakup/synth.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/ctype.h>\t \n#include <linux/fs.h>\n#include <linux/mm.h>\t\t \n#include <linux/errno.h>\t \n#include <linux/ioport.h>\t \n#include <linux/interrupt.h>\n#include <linux/delay.h>\t \n#include <linux/kmod.h>\n#include <linux/jiffies.h>\n#include <linux/uaccess.h>\t \n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/kthread.h>\n\n#include \"spk_priv.h\"\n#include \"speakup.h\"\n#include \"serialio.h\"\n\nstatic LIST_HEAD(synths);\nstruct spk_synth *synth;\nchar spk_pitch_buff[32] = \"\";\nstatic int module_status;\nbool spk_quiet_boot;\n\nstruct speakup_info_t speakup_info = {\n\t \n\t.spinlock = __SPIN_LOCK_UNLOCKED(speakup_info.spinlock),\n\t.flushing = 0,\n};\nEXPORT_SYMBOL_GPL(speakup_info);\n\nstatic int do_synth_init(struct spk_synth *in_synth);\n\n \nstatic void _spk_do_catch_up(struct spk_synth *synth, int unicode)\n{\n\tu16 ch;\n\tunsigned long flags;\n\tunsigned long jiff_max;\n\tstruct var_t *delay_time;\n\tstruct var_t *full_time;\n\tstruct var_t *jiffy_delta;\n\tint jiffy_delta_val;\n\tint delay_time_val;\n\tint full_time_val;\n\tint ret;\n\n\tjiffy_delta = spk_get_var(JIFFY);\n\tfull_time = spk_get_var(FULL);\n\tdelay_time = spk_get_var(DELAY);\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tjiffy_delta_val = jiffy_delta->u.n.value;\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\n\tjiff_max = jiffies + jiffy_delta_val;\n\twhile (!kthread_should_stop()) {\n\t\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\t\tif (speakup_info.flushing) {\n\t\t\tspeakup_info.flushing = 0;\n\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\t\tsynth->flush(synth);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!unicode)\n\t\t\tsynth_buffer_skip_nonlatin1();\n\t\tif (synth_buffer_empty()) {\n\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tch = synth_buffer_peek();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tfull_time_val = full_time->u.n.value;\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\tif (ch == '\\n')\n\t\t\tch = synth->procspeech;\n\t\tif (unicode)\n\t\t\tret = synth->io_ops->synth_out_unicode(synth, ch);\n\t\telse\n\t\t\tret = synth->io_ops->synth_out(synth, ch);\n\t\tif (!ret) {\n\t\t\tschedule_timeout(msecs_to_jiffies(full_time_val));\n\t\t\tcontinue;\n\t\t}\n\t\tif (time_after_eq(jiffies, jiff_max) && (ch == SPACE)) {\n\t\t\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\t\t\tjiffy_delta_val = jiffy_delta->u.n.value;\n\t\t\tdelay_time_val = delay_time->u.n.value;\n\t\t\tfull_time_val = full_time->u.n.value;\n\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\t\tif (synth->io_ops->synth_out(synth, synth->procspeech))\n\t\t\t\tschedule_timeout(\n\t\t\t\t\tmsecs_to_jiffies(delay_time_val));\n\t\t\telse\n\t\t\t\tschedule_timeout(\n\t\t\t\t\tmsecs_to_jiffies(full_time_val));\n\t\t\tjiff_max = jiffies + jiffy_delta_val;\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\t\tsynth_buffer_getc();\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t}\n\tsynth->io_ops->synth_out(synth, synth->procspeech);\n}\n\nvoid spk_do_catch_up(struct spk_synth *synth)\n{\n\t_spk_do_catch_up(synth, 0);\n}\nEXPORT_SYMBOL_GPL(spk_do_catch_up);\n\nvoid spk_do_catch_up_unicode(struct spk_synth *synth)\n{\n\t_spk_do_catch_up(synth, 1);\n}\nEXPORT_SYMBOL_GPL(spk_do_catch_up_unicode);\n\nvoid spk_synth_flush(struct spk_synth *synth)\n{\n\tsynth->io_ops->flush_buffer(synth);\n\tsynth->io_ops->synth_out(synth, synth->clear);\n}\nEXPORT_SYMBOL_GPL(spk_synth_flush);\n\nunsigned char spk_synth_get_index(struct spk_synth *synth)\n{\n\treturn synth->io_ops->synth_in_nowait(synth);\n}\nEXPORT_SYMBOL_GPL(spk_synth_get_index);\n\nint spk_synth_is_alive_nop(struct spk_synth *synth)\n{\n\tsynth->alive = 1;\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(spk_synth_is_alive_nop);\n\nint spk_synth_is_alive_restart(struct spk_synth *synth)\n{\n\tif (synth->alive)\n\t\treturn 1;\n\tif (synth->io_ops->wait_for_xmitr(synth) > 0) {\n\t\t \n\t\tsynth->alive = 1;\n\t\tsynth_printf(\"%s\", synth->init);\n\t\treturn 2;  \n\t}\n\tpr_warn(\"%s: can't restart synth\\n\", synth->long_name);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(spk_synth_is_alive_restart);\n\nstatic void thread_wake_up(struct timer_list *unused)\n{\n\twake_up_interruptible_all(&speakup_event);\n}\n\nstatic DEFINE_TIMER(thread_timer, thread_wake_up);\n\nvoid synth_start(void)\n{\n\tstruct var_t *trigger_time;\n\n\tif (!synth->alive) {\n\t\tsynth_buffer_clear();\n\t\treturn;\n\t}\n\ttrigger_time = spk_get_var(TRIGGER);\n\tif (!timer_pending(&thread_timer))\n\t\tmod_timer(&thread_timer, jiffies +\n\t\t\tmsecs_to_jiffies(trigger_time->u.n.value));\n}\n\nvoid spk_do_flush(void)\n{\n\tif (!synth)\n\t\treturn;\n\n\tspeakup_info.flushing = 1;\n\tsynth_buffer_clear();\n\tif (synth->alive) {\n\t\tif (spk_pitch_shift) {\n\t\t\tsynth_printf(\"%s\", spk_pitch_buff);\n\t\t\tspk_pitch_shift = 0;\n\t\t}\n\t}\n\twake_up_interruptible_all(&speakup_event);\n\twake_up_process(speakup_task);\n}\n\nvoid synth_write(const char *buf, size_t count)\n{\n\twhile (count--)\n\t\tsynth_buffer_add(*buf++);\n\tsynth_start();\n}\n\nvoid synth_printf(const char *fmt, ...)\n{\n\tva_list args;\n\tunsigned char buf[160], *p;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tif (r > sizeof(buf) - 1)\n\t\tr = sizeof(buf) - 1;\n\n\tp = buf;\n\twhile (r--)\n\t\tsynth_buffer_add(*p++);\n\tsynth_start();\n}\nEXPORT_SYMBOL_GPL(synth_printf);\n\nvoid synth_putwc(u16 wc)\n{\n\tsynth_buffer_add(wc);\n}\nEXPORT_SYMBOL_GPL(synth_putwc);\n\nvoid synth_putwc_s(u16 wc)\n{\n\tsynth_buffer_add(wc);\n\tsynth_start();\n}\nEXPORT_SYMBOL_GPL(synth_putwc_s);\n\nvoid synth_putws(const u16 *buf)\n{\n\tconst u16 *p;\n\n\tfor (p = buf; *p; p++)\n\t\tsynth_buffer_add(*p);\n}\nEXPORT_SYMBOL_GPL(synth_putws);\n\nvoid synth_putws_s(const u16 *buf)\n{\n\tsynth_putws(buf);\n\tsynth_start();\n}\nEXPORT_SYMBOL_GPL(synth_putws_s);\n\nstatic int index_count;\nstatic int sentence_count;\n\nvoid spk_reset_index_count(int sc)\n{\n\tstatic int first = 1;\n\n\tif (first)\n\t\tfirst = 0;\n\telse\n\t\tsynth->get_index(synth);\n\tindex_count = 0;\n\tsentence_count = sc;\n}\n\nint synth_supports_indexing(void)\n{\n\tif (synth->get_index)\n\t\treturn 1;\n\treturn 0;\n}\n\nvoid synth_insert_next_index(int sent_num)\n{\n\tint out;\n\n\tif (synth->alive) {\n\t\tif (sent_num == 0) {\n\t\t\tsynth->indexing.currindex++;\n\t\t\tindex_count++;\n\t\t\tif (synth->indexing.currindex >\n\t\t\t\t\tsynth->indexing.highindex)\n\t\t\t\tsynth->indexing.currindex =\n\t\t\t\t\tsynth->indexing.lowindex;\n\t\t}\n\n\t\tout = synth->indexing.currindex * 10 + sent_num;\n\t\tsynth_printf(synth->indexing.command, out, out);\n\t}\n}\n\nvoid spk_get_index_count(int *linecount, int *sentcount)\n{\n\tint ind = synth->get_index(synth);\n\n\tif (ind) {\n\t\tsentence_count = ind % 10;\n\n\t\tif ((ind / 10) <= synth->indexing.currindex)\n\t\t\tindex_count = synth->indexing.currindex - (ind / 10);\n\t\telse\n\t\t\tindex_count = synth->indexing.currindex\n\t\t\t\t- synth->indexing.lowindex\n\t\t\t\t+ synth->indexing.highindex - (ind / 10) + 1;\n\t}\n\t*sentcount = sentence_count;\n\t*linecount = index_count;\n}\n\nstatic struct resource synth_res;\n\nint synth_request_region(unsigned long start, unsigned long n)\n{\n\tstruct resource *parent = &ioport_resource;\n\n\tmemset(&synth_res, 0, sizeof(synth_res));\n\tsynth_res.name = synth->name;\n\tsynth_res.start = start;\n\tsynth_res.end = start + n - 1;\n\tsynth_res.flags = IORESOURCE_BUSY;\n\treturn request_resource(parent, &synth_res);\n}\nEXPORT_SYMBOL_GPL(synth_request_region);\n\nint synth_release_region(unsigned long start, unsigned long n)\n{\n\treturn release_resource(&synth_res);\n}\nEXPORT_SYMBOL_GPL(synth_release_region);\n\nstruct var_t synth_time_vars[] = {\n\t{ DELAY, .u.n = {NULL, 100, 100, 2000, 0, 0, NULL } },\n\t{ TRIGGER, .u.n = {NULL, 20, 10, 2000, 0, 0, NULL } },\n\t{ JIFFY, .u.n = {NULL, 50, 20, 200, 0, 0, NULL } },\n\t{ FULL, .u.n = {NULL, 400, 200, 60000, 0, 0, NULL } },\n\t{ FLUSH, .u.n = {NULL, 4000, 10, 4000, 0, 0, NULL } },\n\tV_LAST_VAR\n};\n\n \nint synth_init(char *synth_name)\n{\n\tint ret = 0;\n\tstruct spk_synth *tmp, *synth = NULL;\n\n\tif (!synth_name)\n\t\treturn 0;\n\n\tif (strcmp(synth_name, \"none\") == 0) {\n\t\tmutex_lock(&spk_mutex);\n\t\tsynth_release();\n\t\tmutex_unlock(&spk_mutex);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&spk_mutex);\n\t \n\tlist_for_each_entry(tmp, &synths, node) {\n\t\tif (strcmp(tmp->name, synth_name) == 0)\n\t\t\tsynth = tmp;\n\t}\n\n\t \n\tif (synth)\n\t\tret = do_synth_init(synth);\n\telse\n\t\tret = -ENODEV;\n\tmutex_unlock(&spk_mutex);\n\n\treturn ret;\n}\n\n \nstatic int do_synth_init(struct spk_synth *in_synth)\n{\n\tstruct var_t *var;\n\n\tsynth_release();\n\tif (in_synth->checkval != SYNTH_CHECK)\n\t\treturn -EINVAL;\n\tsynth = in_synth;\n\tsynth->alive = 0;\n\tpr_warn(\"synth probe\\n\");\n\tif (synth->probe(synth) < 0) {\n\t\tpr_warn(\"%s: device probe failed\\n\", in_synth->name);\n\t\tsynth = NULL;\n\t\treturn -ENODEV;\n\t}\n\tsynth_time_vars[0].u.n.value =\n\t\tsynth_time_vars[0].u.n.default_val = synth->delay;\n\tsynth_time_vars[1].u.n.value =\n\t\tsynth_time_vars[1].u.n.default_val = synth->trigger;\n\tsynth_time_vars[2].u.n.value =\n\t\tsynth_time_vars[2].u.n.default_val = synth->jiffies;\n\tsynth_time_vars[3].u.n.value =\n\t\tsynth_time_vars[3].u.n.default_val = synth->full;\n\tsynth_time_vars[4].u.n.value =\n\t\tsynth_time_vars[4].u.n.default_val = synth->flush_time;\n\tsynth_printf(\"%s\", synth->init);\n\tfor (var = synth->vars;\n\t\t(var->var_id >= 0) && (var->var_id < MAXVARS); var++)\n\t\tspeakup_register_var(var);\n\tif (!spk_quiet_boot)\n\t\tsynth_printf(\"%s found\\n\", synth->long_name);\n\tif (synth->attributes.name &&\n\t    sysfs_create_group(speakup_kobj, &synth->attributes) < 0)\n\t\treturn -ENOMEM;\n\tsynth_flags = synth->flags;\n\twake_up_interruptible_all(&speakup_event);\n\tif (speakup_task)\n\t\twake_up_process(speakup_task);\n\treturn 0;\n}\n\nvoid synth_release(void)\n{\n\tstruct var_t *var;\n\tunsigned long flags;\n\n\tif (!synth)\n\t\treturn;\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tpr_info(\"releasing synth %s\\n\", synth->name);\n\tsynth->alive = 0;\n\tdel_timer(&thread_timer);\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\tif (synth->attributes.name)\n\t\tsysfs_remove_group(speakup_kobj, &synth->attributes);\n\tfor (var = synth->vars; var->var_id != MAXVARS; var++)\n\t\tspeakup_unregister_var(var->var_id);\n\tsynth->release(synth);\n\tsynth = NULL;\n}\n\n \nint synth_add(struct spk_synth *in_synth)\n{\n\tint status = 0;\n\tstruct spk_synth *tmp;\n\n\tmutex_lock(&spk_mutex);\n\n\tlist_for_each_entry(tmp, &synths, node) {\n\t\tif (tmp == in_synth) {\n\t\t\tmutex_unlock(&spk_mutex);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (in_synth->startup)\n\t\tstatus = do_synth_init(in_synth);\n\n\tif (!status)\n\t\tlist_add_tail(&in_synth->node, &synths);\n\n\tmutex_unlock(&spk_mutex);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(synth_add);\n\nvoid synth_remove(struct spk_synth *in_synth)\n{\n\tmutex_lock(&spk_mutex);\n\tif (synth == in_synth)\n\t\tsynth_release();\n\tlist_del(&in_synth->node);\n\tmodule_status = 0;\n\tmutex_unlock(&spk_mutex);\n}\nEXPORT_SYMBOL_GPL(synth_remove);\n\nstruct spk_synth *synth_current(void)\n{\n\treturn synth;\n}\nEXPORT_SYMBOL_GPL(synth_current);\n\nshort spk_punc_masks[] = { 0, SOME, MOST, PUNC, PUNC | B_SYM };\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}