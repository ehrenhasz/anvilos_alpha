{
  "module_name": "speakup_audptr.c",
  "hash_id": "d69fb61aec274790b6570be3a947845eb75d64d8ff82e23cd872ca678fc0b984",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/speakup/speakup_audptr.c",
  "human_readable_source": "\n \n#include \"spk_priv.h\"\n#include \"speakup.h\"\n\n#define DRV_VERSION \"2.11\"\n#define SYNTH_CLEAR 0x18  \n#define PROCSPEECH '\\r'  \n\nstatic int synth_probe(struct spk_synth *synth);\nstatic void synth_flush(struct spk_synth *synth);\n\n\nenum default_vars_id {\n\tCAPS_START_ID = 0, CAPS_STOP_ID,\n\tRATE_ID, PITCH_ID,\n\tVOL_ID, TONE_ID, PUNCT_ID,\n\tDIRECT_ID, V_LAST_VAR_ID,\n\tNB_ID\n};\n\nstatic struct var_t vars[NB_ID] = {\n\t[CAPS_START_ID] = { CAPS_START, .u.s = {\"\\x05[f99]\" } },\n\t[CAPS_STOP_ID] = { CAPS_STOP, .u.s = {\"\\x05[f80]\" } },\n\t[RATE_ID] = { RATE, .u.n = {\"\\x05[r%d]\", 10, 0, 20, 100, -10, NULL } },\n\t[PITCH_ID] = { PITCH, .u.n = {\"\\x05[f%d]\", 80, 39, 4500, 0, 0, NULL } },\n\t[VOL_ID] = { VOL, .u.n = {\"\\x05[g%d]\", 21, 0, 40, 0, 0, NULL } },\n\t[TONE_ID] = { TONE, .u.n = {\"\\x05[s%d]\", 9, 0, 63, 0, 0, NULL } },\n\t[PUNCT_ID] = { PUNCT, .u.n = {\"\\x05[A%c]\", 0, 0, 3, 0, 0, \"nmsa\" } },\n\t[DIRECT_ID] = { DIRECT, .u.n = {NULL, 0, 0, 1, 0, 0, NULL } },\n\tV_LAST_VAR\n};\n\n \nstatic struct kobj_attribute caps_start_attribute =\n\t__ATTR(caps_start, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute caps_stop_attribute =\n\t__ATTR(caps_stop, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute pitch_attribute =\n\t__ATTR(pitch, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute punct_attribute =\n\t__ATTR(punct, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute rate_attribute =\n\t__ATTR(rate, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute tone_attribute =\n\t__ATTR(tone, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute vol_attribute =\n\t__ATTR(vol, 0644, spk_var_show, spk_var_store);\n\nstatic struct kobj_attribute delay_time_attribute =\n\t__ATTR(delay_time, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute direct_attribute =\n\t__ATTR(direct, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute full_time_attribute =\n\t__ATTR(full_time, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute jiffy_delta_attribute =\n\t__ATTR(jiffy_delta, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute trigger_time_attribute =\n\t__ATTR(trigger_time, 0644, spk_var_show, spk_var_store);\n\n \nstatic struct attribute *synth_attrs[] = {\n\t&caps_start_attribute.attr,\n\t&caps_stop_attribute.attr,\n\t&pitch_attribute.attr,\n\t&punct_attribute.attr,\n\t&rate_attribute.attr,\n\t&tone_attribute.attr,\n\t&vol_attribute.attr,\n\t&delay_time_attribute.attr,\n\t&direct_attribute.attr,\n\t&full_time_attribute.attr,\n\t&jiffy_delta_attribute.attr,\n\t&trigger_time_attribute.attr,\n\tNULL,\t \n};\n\nstatic struct spk_synth synth_audptr = {\n\t.name = \"audptr\",\n\t.version = DRV_VERSION,\n\t.long_name = \"Audapter\",\n\t.init = \"\\x05[D1]\\x05[Ol]\",\n\t.procspeech = PROCSPEECH,\n\t.clear = SYNTH_CLEAR,\n\t.delay = 400,\n\t.trigger = 50,\n\t.jiffies = 30,\n\t.full = 18000,\n\t.dev_name = SYNTH_DEFAULT_DEV,\n\t.startup = SYNTH_START,\n\t.checkval = SYNTH_CHECK,\n\t.vars = vars,\n\t.io_ops = &spk_ttyio_ops,\n\t.probe = synth_probe,\n\t.release = spk_ttyio_release,\n\t.synth_immediate = spk_ttyio_synth_immediate,\n\t.catch_up = spk_do_catch_up,\n\t.flush = synth_flush,\n\t.is_alive = spk_synth_is_alive_restart,\n\t.synth_adjust = NULL,\n\t.read_buff_add = NULL,\n\t.get_index = NULL,\n\t.indexing = {\n\t\t.command = NULL,\n\t\t.lowindex = 0,\n\t\t.highindex = 0,\n\t\t.currindex = 0,\n\t},\n\t.attributes = {\n\t\t.attrs = synth_attrs,\n\t\t.name = \"audptr\",\n\t},\n};\n\nstatic void synth_flush(struct spk_synth *synth)\n{\n\tsynth->io_ops->flush_buffer(synth);\n\tsynth->io_ops->send_xchar(synth, SYNTH_CLEAR);\n\tsynth->io_ops->synth_out(synth, PROCSPEECH);\n}\n\nstatic void synth_version(struct spk_synth *synth)\n{\n\tunsigned i;\n\tchar synth_id[33];\n\n\tsynth->synth_immediate(synth, \"\\x05[Q]\");\n\tsynth_id[0] = synth->io_ops->synth_in(synth);\n\tif (synth_id[0] != 'A')\n\t\treturn;\n\n\tfor (i = 1; i < sizeof(synth_id) - 1; i++) {\n\t\t \n\t\tsynth_id[i] = synth->io_ops->synth_in(synth);\n\t\tif (synth_id[i] == '\\n')\n\t\t\tbreak;\n\t}\n\tsynth_id[i] = '\\0';\n\tpr_info(\"%s version: %s\", synth->long_name, synth_id);\n}\n\nstatic int synth_probe(struct spk_synth *synth)\n{\n\tint failed;\n\n\tfailed = spk_ttyio_synth_probe(synth);\n\tif (failed == 0)\n\t\tsynth_version(synth);\n\tsynth->alive = !failed;\n\treturn 0;\n}\n\nmodule_param_named(ser, synth_audptr.ser, int, 0444);\nmodule_param_named(dev, synth_audptr.dev_name, charp, 0444);\nmodule_param_named(start, synth_audptr.startup, short, 0444);\nmodule_param_named(rate, vars[RATE_ID].u.n.default_val, int, 0444);\nmodule_param_named(pitch, vars[PITCH_ID].u.n.default_val, int, 0444);\nmodule_param_named(vol, vars[VOL_ID].u.n.default_val, int, 0444);\nmodule_param_named(tone, vars[TONE_ID].u.n.default_val, int, 0444);\nmodule_param_named(punct, vars[PUNCT_ID].u.n.default_val, int, 0444);\nmodule_param_named(direct, vars[DIRECT_ID].u.n.default_val, int, 0444);\n\n\n\nMODULE_PARM_DESC(ser, \"Set the serial port for the synthesizer (0-based).\");\nMODULE_PARM_DESC(dev, \"Set the device e.g. ttyUSB0, for the synthesizer.\");\nMODULE_PARM_DESC(start, \"Start the synthesizer once it is loaded.\");\nMODULE_PARM_DESC(rate, \"Set the rate variable on load.\");\nMODULE_PARM_DESC(pitch, \"Set the pitch variable on load.\");\nMODULE_PARM_DESC(vol, \"Set the vol variable on load.\");\nMODULE_PARM_DESC(tone, \"Set the tone variable on load.\");\nMODULE_PARM_DESC(punct, \"Set the punct variable on load.\");\nMODULE_PARM_DESC(direct, \"Set the direct variable on load.\");\n\n\nmodule_spk_synth(synth_audptr);\n\nMODULE_AUTHOR(\"Kirk Reiser <kirk@braille.uwo.ca>\");\nMODULE_AUTHOR(\"David Borowski\");\nMODULE_DESCRIPTION(\"Speakup support for Audapter synthesizer\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}