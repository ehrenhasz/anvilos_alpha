{
  "module_name": "speakup_decpc.c",
  "hash_id": "45015cc61fe1223f98fe98d7e48b9375cbda6f0c4a89d4db48e431805b0c02b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/speakup/speakup_decpc.c",
  "human_readable_source": "\n \n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/kthread.h>\n\n#include \"spk_priv.h\"\n#include \"speakup.h\"\n\n#define\tMODULE_init\t\t0x0dec\t \n#define\tMODULE_self_test\t0x8800\t \n#define\tMODULE_reset\t\t0xffff\t \n\n#define\tMODE_mask\t\t0xf000\t \n#define\tMODE_null\t\t0x0000\n#define\tMODE_test\t\t0x2000\t \n#define\tMODE_status\t\t0x8000\n#define\tSTAT_int\t\t0x0001\t \n#define\tSTAT_tr_char\t\t0x0002\t \n#define\tSTAT_rr_char\t\t0x0004\t \n#define\tSTAT_cmd_ready\t\t0x0008\t \n#define\tSTAT_dma_ready\t\t0x0010\t \n#define\tSTAT_digitized\t\t0x0020\t \n#define\tSTAT_new_index\t\t0x0040\t \n#define\tSTAT_new_status\t\t0x0080\t \n#define\tSTAT_dma_state\t\t0x0100\t \n#define\tSTAT_index_valid\t0x0200\t \n#define\tSTAT_flushing\t\t0x0400\t \n#define\tSTAT_self_test\t\t0x0800\t \n#define\tMODE_ready\t\t0xc000\t \n#define\tREADY_boot\t\t0x0000\n#define\tREADY_kernel\t\t0x0001\n#define\tMODE_error\t\t0xf000\n\n#define\tCMD_mask\t\t0xf000\t \n#define\tCMD_null\t\t0x0000\t \n#define\tCMD_control\t\t0x1000\t \n#define\tCTRL_mask\t\t0x0F00\t \n#define\tCTRL_data\t\t0x00FF\t \n#define\tCTRL_null\t\t0x0000\t \n#define\tCTRL_vol_up\t\t0x0100\t \n#define\tCTRL_vol_down\t\t0x0200\t \n#define\tCTRL_vol_set\t\t0x0300\t \n#define\tCTRL_pause\t\t0x0400\t \n#define\tCTRL_resume\t\t0x0500\t \n#define\tCTRL_resume_spc\t\t0x0001\t \n#define\tCTRL_flush\t\t0x0600\t \n#define\tCTRL_int_enable\t\t0x0700\t \n#define\tCTRL_buff_free\t\t0x0800\t \n#define\tCTRL_buff_used\t\t0x0900\t \n#define\tCTRL_speech\t\t0x0a00\t \n#define\tCTRL_SP_voice\t\t0x0001\t \n#define\tCTRL_SP_rate\t\t0x0002\t \n#define\tCTRL_SP_comma\t\t0x0003\t \n#define\tCTRL_SP_period\t\t0x0004\t \n#define\tCTRL_SP_rate_delta\t0x0005\t \n#define\tCTRL_SP_get_param\t0x0006\t \n#define\tCTRL_last_index\t\t0x0b00\t \n#define\tCTRL_io_priority\t0x0c00\t \n#define\tCTRL_free_mem\t\t0x0d00\t \n#define\tCTRL_get_lang\t\t0x0e00\t \n#define\tCMD_test\t\t0x2000\t \n#define\tTEST_mask\t\t0x0F00\t \n#define\tTEST_null\t\t0x0000\t \n#define\tTEST_isa_int\t\t0x0100\t \n#define\tTEST_echo\t\t0x0200\t \n#define\tTEST_seg\t\t0x0300\t \n#define\tTEST_off\t\t0x0400\t \n#define\tTEST_peek\t\t0x0500\t \n#define\tTEST_poke\t\t0x0600\t \n#define\tTEST_sub_code\t\t0x00FF\t \n#define\tCMD_id\t\t\t0x3000\t \n#define\tID_null\t\t\t0x0000\t \n#define\tID_kernel\t\t0x0100\t \n#define\tID_boot\t\t\t0x0200\t \n#define\tCMD_dma\t\t\t0x4000\t \n#define\tCMD_reset\t\t0x5000\t \n#define\tCMD_sync\t\t0x6000\t \n#define\tCMD_char_in\t\t0x7000\t \n#define\tCMD_char_out\t\t0x8000\t \n#define\tCHAR_count_1\t\t0x0100\t \n#define\tCHAR_count_2\t\t0x0200\t \n#define\tCHAR_count_3\t\t0x0300\t \n#define\tCMD_spc_mode\t\t0x9000\t \n#define\tCMD_spc_to_text\t\t0x0100\t \n#define\tCMD_spc_to_digit\t0x0200\t \n#define\tCMD_spc_rate\t\t0x0400\t \n#define\tCMD_error\t\t0xf000\t \n\nenum {\tPRIMARY_DIC\t= 0, USER_DIC, COMMAND_DIC, ABBREV_DIC };\n\n#define\tDMA_single_in\t\t0x01\n#define\tDMA_single_out\t\t0x02\n#define\tDMA_buff_in\t\t0x03\n#define\tDMA_buff_out\t\t0x04\n#define\tDMA_control\t\t0x05\n#define\tDT_MEM_ALLOC\t\t0x03\n#define\tDT_SET_DIC\t\t0x04\n#define\tDT_START_TASK\t\t0x05\n#define\tDT_LOAD_MEM\t\t0x06\n#define\tDT_READ_MEM\t\t0x07\n#define\tDT_DIGITAL_IN\t\t0x08\n#define\tDMA_sync\t\t0x06\n#define\tDMA_sync_char\t\t0x07\n\n#define DRV_VERSION \"2.12\"\n#define PROCSPEECH 0x0b\n#define SYNTH_IO_EXTENT 8\n\nstatic int synth_probe(struct spk_synth *synth);\nstatic void dtpc_release(struct spk_synth *synth);\nstatic const char *synth_immediate(struct spk_synth *synth, const char *buf);\nstatic void do_catch_up(struct spk_synth *synth);\nstatic void synth_flush(struct spk_synth *synth);\n\nstatic int synth_portlist[] = { 0x340, 0x350, 0x240, 0x250, 0 };\nstatic int in_escape, is_flushing;\nstatic int dt_stat, dma_state;\n\n\nenum default_vars_id {\n\tCAPS_START_ID = 0, CAPS_STOP_ID,\n\tRATE_ID, PITCH_ID, INFLECTION_ID,\n\tVOL_ID, PUNCT_ID, VOICE_ID,\n\tDIRECT_ID, V_LAST_VAR_ID,\n\tNB_ID,\n};\n\n\n\nstatic struct var_t vars[NB_ID] = {\n\t[CAPS_START_ID] = { CAPS_START, .u.s = {\"[:dv ap 200]\" } },\n\t[CAPS_STOP_ID] = { CAPS_STOP, .u.s = {\"[:dv ap 100]\" } },\n\t[RATE_ID] = { RATE, .u.n = {\"[:ra %d]\", 9, 0, 18, 150, 25, NULL } },\n\t[PITCH_ID] = { PITCH, .u.n = {\"[:dv ap %d]\", 80, 0, 100, 20, 0, NULL } },\n\t[INFLECTION_ID] = { INFLECTION, .u.n = {\"[:dv pr %d] \", 100, 0, 10000, 0, 0, NULL } },\n\t[VOL_ID] = { VOL, .u.n = {\"[:vo se %d]\", 5, 0, 9, 5, 10, NULL } },\n\t[PUNCT_ID] = { PUNCT, .u.n = {\"[:pu %c]\", 0, 0, 2, 0, 0, \"nsa\" } },\n\t[VOICE_ID] = { VOICE, .u.n = {\"[:n%c]\", 0, 0, 9, 0, 0, \"phfdburwkv\" } },\n\t[DIRECT_ID] = { DIRECT, .u.n = {NULL, 0, 0, 1, 0, 0, NULL } },\n\tV_LAST_VAR\n};\n\n \nstatic struct kobj_attribute caps_start_attribute =\n\t__ATTR(caps_start, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute caps_stop_attribute =\n\t__ATTR(caps_stop, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute pitch_attribute =\n\t__ATTR(pitch, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute inflection_attribute =\n\t__ATTR(inflection, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute punct_attribute =\n\t__ATTR(punct, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute rate_attribute =\n\t__ATTR(rate, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute voice_attribute =\n\t__ATTR(voice, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute vol_attribute =\n\t__ATTR(vol, 0644, spk_var_show, spk_var_store);\n\nstatic struct kobj_attribute delay_time_attribute =\n\t__ATTR(delay_time, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute direct_attribute =\n\t__ATTR(direct, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute full_time_attribute =\n\t__ATTR(full_time, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute jiffy_delta_attribute =\n\t__ATTR(jiffy_delta, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute trigger_time_attribute =\n\t__ATTR(trigger_time, 0644, spk_var_show, spk_var_store);\n\n \nstatic struct attribute *synth_attrs[] = {\n\t&caps_start_attribute.attr,\n\t&caps_stop_attribute.attr,\n\t&pitch_attribute.attr,\n\t&inflection_attribute.attr,\n\t&punct_attribute.attr,\n\t&rate_attribute.attr,\n\t&voice_attribute.attr,\n\t&vol_attribute.attr,\n\t&delay_time_attribute.attr,\n\t&direct_attribute.attr,\n\t&full_time_attribute.attr,\n\t&jiffy_delta_attribute.attr,\n\t&trigger_time_attribute.attr,\n\tNULL,\t \n};\n\nstatic struct spk_synth synth_dec_pc = {\n\t.name = \"decpc\",\n\t.version = DRV_VERSION,\n\t.long_name = \"Dectalk PC\",\n\t.init = \"[:pe -380]\",\n\t.procspeech = PROCSPEECH,\n\t.delay = 500,\n\t.trigger = 50,\n\t.jiffies = 50,\n\t.full = 1000,\n\t.flags = SF_DEC,\n\t.startup = SYNTH_START,\n\t.checkval = SYNTH_CHECK,\n\t.vars = vars,\n\t.io_ops = &spk_serial_io_ops,\n\t.probe = synth_probe,\n\t.release = dtpc_release,\n\t.synth_immediate = synth_immediate,\n\t.catch_up = do_catch_up,\n\t.flush = synth_flush,\n\t.is_alive = spk_synth_is_alive_nop,\n\t.synth_adjust = NULL,\n\t.read_buff_add = NULL,\n\t.get_index = NULL,\n\t.indexing = {\n\t\t.command = NULL,\n\t\t.lowindex = 0,\n\t\t.highindex = 0,\n\t\t.currindex = 0,\n\t},\n\t.attributes = {\n\t\t.attrs = synth_attrs,\n\t\t.name = \"decpc\",\n\t},\n};\n\nstatic int dt_getstatus(void)\n{\n\tdt_stat = inb_p(speakup_info.port_tts) |\n\t\t (inb_p(speakup_info.port_tts + 1) << 8);\n\treturn dt_stat;\n}\n\nstatic void dt_sendcmd(u_int cmd)\n{\n\toutb_p(cmd & 0xFF, speakup_info.port_tts);\n\toutb_p((cmd >> 8) & 0xFF, speakup_info.port_tts + 1);\n}\n\nstatic int dt_waitbit(int bit)\n{\n\tint timeout = 100;\n\n\twhile (--timeout > 0) {\n\t\tif ((dt_getstatus() & bit) == bit)\n\t\t\treturn 1;\n\t\tudelay(50);\n\t}\n\treturn 0;\n}\n\nstatic int dt_wait_dma(void)\n{\n\tint timeout = 100, state = dma_state;\n\n\tif (!dt_waitbit(STAT_dma_ready))\n\t\treturn 0;\n\twhile (--timeout > 0) {\n\t\tif ((dt_getstatus() & STAT_dma_state) == state)\n\t\t\treturn 1;\n\t\tudelay(50);\n\t}\n\tdma_state = dt_getstatus() & STAT_dma_state;\n\treturn 1;\n}\n\nstatic int dt_ctrl(u_int cmd)\n{\n\tint timeout = 10;\n\n\tif (!dt_waitbit(STAT_cmd_ready))\n\t\treturn -1;\n\toutb_p(0, speakup_info.port_tts + 2);\n\toutb_p(0, speakup_info.port_tts + 3);\n\tdt_getstatus();\n\tdt_sendcmd(CMD_control | cmd);\n\toutb_p(0, speakup_info.port_tts + 6);\n\twhile (dt_getstatus() & STAT_cmd_ready) {\n\t\tudelay(20);\n\t\tif (--timeout == 0)\n\t\t\tbreak;\n\t}\n\tdt_sendcmd(CMD_null);\n\treturn 0;\n}\n\nstatic void synth_flush(struct spk_synth *synth)\n{\n\tint timeout = 10;\n\n\tif (is_flushing)\n\t\treturn;\n\tis_flushing = 4;\n\tin_escape = 0;\n\twhile (dt_ctrl(CTRL_flush)) {\n\t\tif (--timeout == 0)\n\t\t\tbreak;\n\t\tudelay(50);\n\t}\n\tfor (timeout = 0; timeout < 10; timeout++) {\n\t\tif (dt_waitbit(STAT_dma_ready))\n\t\t\tbreak;\n\t\tudelay(50);\n\t}\n\toutb_p(DMA_sync, speakup_info.port_tts + 4);\n\toutb_p(0, speakup_info.port_tts + 4);\n\tudelay(100);\n\tfor (timeout = 0; timeout < 10; timeout++) {\n\t\tif (!(dt_getstatus() & STAT_flushing))\n\t\t\tbreak;\n\t\tudelay(50);\n\t}\n\tdma_state = dt_getstatus() & STAT_dma_state;\n\tdma_state ^= STAT_dma_state;\n\tis_flushing = 0;\n}\n\nstatic int dt_sendchar(char ch)\n{\n\tif (!dt_wait_dma())\n\t\treturn -1;\n\tif (!(dt_stat & STAT_rr_char))\n\t\treturn -2;\n\toutb_p(DMA_single_in, speakup_info.port_tts + 4);\n\toutb_p(ch, speakup_info.port_tts + 4);\n\tdma_state ^= STAT_dma_state;\n\treturn 0;\n}\n\nstatic int testkernel(void)\n{\n\tint status = 0;\n\n\tif (dt_getstatus() == 0xffff) {\n\t\tstatus = -1;\n\t\tgoto oops;\n\t}\n\tdt_sendcmd(CMD_sync);\n\tif (!dt_waitbit(STAT_cmd_ready))\n\t\tstatus = -2;\n\telse if (dt_stat & 0x8000)\n\t\treturn 0;\n\telse if (dt_stat == 0x0dec)\n\t\tpr_warn(\"dec_pc at 0x%x, software not loaded\\n\",\n\t\t\tspeakup_info.port_tts);\n\tstatus = -3;\noops:\tsynth_release_region(speakup_info.port_tts, SYNTH_IO_EXTENT);\n\tspeakup_info.port_tts = 0;\n\treturn status;\n}\n\nstatic void do_catch_up(struct spk_synth *synth)\n{\n\tu_char ch;\n\tstatic u_char last;\n\tunsigned long flags;\n\tunsigned long jiff_max;\n\tstruct var_t *jiffy_delta;\n\tstruct var_t *delay_time;\n\tint jiffy_delta_val;\n\tint delay_time_val;\n\n\tjiffy_delta = spk_get_var(JIFFY);\n\tdelay_time = spk_get_var(DELAY);\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tjiffy_delta_val = jiffy_delta->u.n.value;\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\tjiff_max = jiffies + jiffy_delta_val;\n\n\twhile (!kthread_should_stop()) {\n\t\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\t\tif (speakup_info.flushing) {\n\t\t\tspeakup_info.flushing = 0;\n\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\t\tsynth->flush(synth);\n\t\t\tcontinue;\n\t\t}\n\t\tsynth_buffer_skip_nonlatin1();\n\t\tif (synth_buffer_empty()) {\n\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tch = synth_buffer_peek();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tdelay_time_val = delay_time->u.n.value;\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\tif (ch == '\\n')\n\t\t\tch = 0x0D;\n\t\tif (dt_sendchar(ch)) {\n\t\t\tschedule_timeout(msecs_to_jiffies(delay_time_val));\n\t\t\tcontinue;\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\t\tsynth_buffer_getc();\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\tif (ch == '[') {\n\t\t\tin_escape = 1;\n\t\t} else if (ch == ']') {\n\t\t\tin_escape = 0;\n\t\t} else if (ch <= SPACE) {\n\t\t\tif (!in_escape && strchr(\",.!?;:\", last))\n\t\t\t\tdt_sendchar(PROCSPEECH);\n\t\t\tif (time_after_eq(jiffies, jiff_max)) {\n\t\t\t\tif (!in_escape)\n\t\t\t\t\tdt_sendchar(PROCSPEECH);\n\t\t\t\tspin_lock_irqsave(&speakup_info.spinlock,\n\t\t\t\t\t\t  flags);\n\t\t\t\tjiffy_delta_val = jiffy_delta->u.n.value;\n\t\t\t\tdelay_time_val = delay_time->u.n.value;\n\t\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tschedule_timeout(msecs_to_jiffies\n\t\t\t\t\t\t (delay_time_val));\n\t\t\t\tjiff_max = jiffies + jiffy_delta_val;\n\t\t\t}\n\t\t}\n\t\tlast = ch;\n\t\tch = 0;\n\t}\n\tif (!in_escape)\n\t\tdt_sendchar(PROCSPEECH);\n}\n\nstatic const char *synth_immediate(struct spk_synth *synth, const char *buf)\n{\n\tu_char ch;\n\n\twhile ((ch = *buf)) {\n\t\tif (ch == '\\n')\n\t\t\tch = PROCSPEECH;\n\t\tif (dt_sendchar(ch))\n\t\t\treturn buf;\n\t\tbuf++;\n\t}\n\treturn NULL;\n}\n\nstatic int synth_probe(struct spk_synth *synth)\n{\n\tint i = 0, failed = 0;\n\n\tpr_info(\"Probing for %s.\\n\", synth->long_name);\n\tfor (i = 0; synth_portlist[i]; i++) {\n\t\tif (synth_request_region(synth_portlist[i], SYNTH_IO_EXTENT)) {\n\t\t\tpr_warn(\"request_region: failed with 0x%x, %d\\n\",\n\t\t\t\tsynth_portlist[i], SYNTH_IO_EXTENT);\n\t\t\tcontinue;\n\t\t}\n\t\tspeakup_info.port_tts = synth_portlist[i];\n\t\tfailed = testkernel();\n\t\tif (failed == 0)\n\t\t\tbreak;\n\t}\n\tif (failed) {\n\t\tpr_info(\"%s: not found\\n\", synth->long_name);\n\t\treturn -ENODEV;\n\t}\n\tpr_info(\"%s: %03x-%03x, Driver Version %s,\\n\", synth->long_name,\n\t\tspeakup_info.port_tts, speakup_info.port_tts + 7,\n\t\tsynth->version);\n\tsynth->alive = 1;\n\treturn 0;\n}\n\nstatic void dtpc_release(struct spk_synth *synth)\n{\n\tspk_stop_serial_interrupt();\n\tif (speakup_info.port_tts)\n\t\tsynth_release_region(speakup_info.port_tts, SYNTH_IO_EXTENT);\n\tspeakup_info.port_tts = 0;\n}\n\nmodule_param_named(start, synth_dec_pc.startup, short, 0444);\nmodule_param_named(rate, vars[RATE_ID].u.n.default_val, int, 0444);\nmodule_param_named(pitch, vars[PITCH_ID].u.n.default_val, int, 0444);\nmodule_param_named(inflection, vars[INFLECTION_ID].u.n.default_val, int, 0444);\nmodule_param_named(vol, vars[VOL_ID].u.n.default_val, int, 0444);\nmodule_param_named(punct, vars[PUNCT_ID].u.n.default_val, int, 0444);\nmodule_param_named(voice, vars[VOICE_ID].u.n.default_val, int, 0444);\nmodule_param_named(direct, vars[DIRECT_ID].u.n.default_val, int, 0444);\n\n\n\n\nMODULE_PARM_DESC(start, \"Start the synthesizer once it is loaded.\");\nMODULE_PARM_DESC(rate, \"Set the rate variable on load.\");\nMODULE_PARM_DESC(pitch, \"Set the pitch variable on load.\");\nMODULE_PARM_DESC(inflection, \"Set the inflection variable on load.\");\nMODULE_PARM_DESC(vol, \"Set the vol variable on load.\");\nMODULE_PARM_DESC(punct, \"Set the punct variable on load.\");\nMODULE_PARM_DESC(voice, \"Set the voice variable on load.\");\nMODULE_PARM_DESC(direct, \"Set the direct variable on load.\");\n\nmodule_spk_synth(synth_dec_pc);\n\nMODULE_AUTHOR(\"Kirk Reiser <kirk@braille.uwo.ca>\");\nMODULE_AUTHOR(\"David Borowski\");\nMODULE_DESCRIPTION(\"Speakup support for DECtalk PC synthesizers\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}