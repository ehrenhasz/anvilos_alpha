{
  "module_name": "speakup_dtlk.c",
  "hash_id": "668e4ff6a4d74a0914450216cdfa9f6d1d5109043754e52bd07a92a9e4053030",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/speakup/speakup_dtlk.c",
  "human_readable_source": "\n \n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/kthread.h>\n\n#include \"spk_priv.h\"\n#include \"serialio.h\"\n#include \"speakup_dtlk.h\"  \n#include \"speakup.h\"\n\n#define DRV_VERSION \"2.10\"\n#define PROCSPEECH 0x00\n\nstatic int synth_probe(struct spk_synth *synth);\nstatic void dtlk_release(struct spk_synth *synth);\nstatic const char *synth_immediate(struct spk_synth *synth, const char *buf);\nstatic void do_catch_up(struct spk_synth *synth);\nstatic void synth_flush(struct spk_synth *synth);\n\nstatic int synth_lpc;\nstatic int port_forced;\nstatic unsigned int synth_portlist[] = {\n\t\t 0x25e, 0x29e, 0x2de, 0x31e, 0x35e, 0x39e, 0\n};\n\nstatic u_char synth_status;\n\nenum default_vars_id {\n\tCAPS_START_ID = 0, CAPS_STOP_ID,\n\tRATE_ID, PITCH_ID,\n\tVOL_ID, TONE_ID, PUNCT_ID,\n\tVOICE_ID, FREQUENCY_ID,\n\tDIRECT_ID, V_LAST_VAR_ID,\n\tNB_ID,\n};\n\n\nstatic struct var_t vars[NB_ID] = {\n\t[CAPS_START_ID] = { CAPS_START, .u.s = {\"\\x01+35p\" } },\n\t[CAPS_STOP_ID] = { CAPS_STOP, .u.s = {\"\\x01-35p\" } },\n\t[RATE_ID] = { RATE, .u.n = {\"\\x01%ds\", 8, 0, 9, 0, 0, NULL } },\n\t[PITCH_ID] = { PITCH, .u.n = {\"\\x01%dp\", 50, 0, 99, 0, 0, NULL } },\n\t[VOL_ID] = { VOL, .u.n = {\"\\x01%dv\", 5, 0, 9, 0, 0, NULL } },\n\t[TONE_ID] = { TONE, .u.n = {\"\\x01%dx\", 1, 0, 2, 0, 0, NULL } },\n\t[PUNCT_ID] = { PUNCT, .u.n = {\"\\x01%db\", 7, 0, 15, 0, 0, NULL } },\n\t[VOICE_ID] = { VOICE, .u.n = {\"\\x01%do\", 0, 0, 7, 0, 0, NULL } },\n\t[FREQUENCY_ID] = { FREQUENCY, .u.n = {\"\\x01%df\", 5, 0, 9, 0, 0, NULL } },\n\t[DIRECT_ID] = { DIRECT, .u.n = {NULL, 0, 0, 1, 0, 0, NULL } },\n\tV_LAST_VAR\n};\n\n \nstatic struct kobj_attribute caps_start_attribute =\n\t__ATTR(caps_start, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute caps_stop_attribute =\n\t__ATTR(caps_stop, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute freq_attribute =\n\t__ATTR(freq, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute pitch_attribute =\n\t__ATTR(pitch, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute punct_attribute =\n\t__ATTR(punct, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute rate_attribute =\n\t__ATTR(rate, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute tone_attribute =\n\t__ATTR(tone, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute voice_attribute =\n\t__ATTR(voice, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute vol_attribute =\n\t__ATTR(vol, 0644, spk_var_show, spk_var_store);\n\nstatic struct kobj_attribute delay_time_attribute =\n\t__ATTR(delay_time, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute direct_attribute =\n\t__ATTR(direct, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute full_time_attribute =\n\t__ATTR(full_time, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute jiffy_delta_attribute =\n\t__ATTR(jiffy_delta, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute trigger_time_attribute =\n\t__ATTR(trigger_time, 0644, spk_var_show, spk_var_store);\n\n \nstatic struct attribute *synth_attrs[] = {\n\t&caps_start_attribute.attr,\n\t&caps_stop_attribute.attr,\n\t&freq_attribute.attr,\n\t&pitch_attribute.attr,\n\t&punct_attribute.attr,\n\t&rate_attribute.attr,\n\t&tone_attribute.attr,\n\t&voice_attribute.attr,\n\t&vol_attribute.attr,\n\t&delay_time_attribute.attr,\n\t&direct_attribute.attr,\n\t&full_time_attribute.attr,\n\t&jiffy_delta_attribute.attr,\n\t&trigger_time_attribute.attr,\n\tNULL,\t \n};\n\nstatic struct spk_synth synth_dtlk = {\n\t.name = \"dtlk\",\n\t.version = DRV_VERSION,\n\t.long_name = \"DoubleTalk PC\",\n\t.init = \"\\x01@\\x01\\x31y\",\n\t.procspeech = PROCSPEECH,\n\t.clear = SYNTH_CLEAR,\n\t.delay = 500,\n\t.trigger = 30,\n\t.jiffies = 50,\n\t.full = 1000,\n\t.startup = SYNTH_START,\n\t.checkval = SYNTH_CHECK,\n\t.vars = vars,\n\t.io_ops = &spk_serial_io_ops,\n\t.probe = synth_probe,\n\t.release = dtlk_release,\n\t.synth_immediate = synth_immediate,\n\t.catch_up = do_catch_up,\n\t.flush = synth_flush,\n\t.is_alive = spk_synth_is_alive_nop,\n\t.synth_adjust = NULL,\n\t.read_buff_add = NULL,\n\t.get_index = spk_synth_get_index,\n\t.indexing = {\n\t\t.command = \"\\x01%di\",\n\t\t.lowindex = 1,\n\t\t.highindex = 5,\n\t\t.currindex = 1,\n\t},\n\t.attributes = {\n\t\t.attrs = synth_attrs,\n\t\t.name = \"dtlk\",\n\t},\n};\n\nstatic inline bool synth_readable(void)\n{\n\tsynth_status = inb_p(speakup_info.port_tts + UART_RX);\n\treturn (synth_status & TTS_READABLE) != 0;\n}\n\nstatic inline bool synth_writable(void)\n{\n\tsynth_status = inb_p(speakup_info.port_tts + UART_RX);\n\treturn (synth_status & TTS_WRITABLE) != 0;\n}\n\nstatic inline bool synth_full(void)\n{\n\tsynth_status = inb_p(speakup_info.port_tts + UART_RX);\n\treturn (synth_status & TTS_ALMOST_FULL) != 0;\n}\n\nstatic void spk_out(const char ch)\n{\n\tint timeout = SPK_XMITR_TIMEOUT;\n\n\twhile (!synth_writable()) {\n\t\tif (!--timeout)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\toutb_p(ch, speakup_info.port_tts);\n\ttimeout = SPK_XMITR_TIMEOUT;\n\twhile (synth_writable()) {\n\t\tif (!--timeout)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void do_catch_up(struct spk_synth *synth)\n{\n\tu_char ch;\n\tunsigned long flags;\n\tunsigned long jiff_max;\n\tstruct var_t *jiffy_delta;\n\tstruct var_t *delay_time;\n\tint jiffy_delta_val;\n\tint delay_time_val;\n\n\tjiffy_delta = spk_get_var(JIFFY);\n\tdelay_time = spk_get_var(DELAY);\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tjiffy_delta_val = jiffy_delta->u.n.value;\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\tjiff_max = jiffies + jiffy_delta_val;\n\twhile (!kthread_should_stop()) {\n\t\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\t\tif (speakup_info.flushing) {\n\t\t\tspeakup_info.flushing = 0;\n\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\t\tsynth->flush(synth);\n\t\t\tcontinue;\n\t\t}\n\t\tsynth_buffer_skip_nonlatin1();\n\t\tif (synth_buffer_empty()) {\n\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tdelay_time_val = delay_time->u.n.value;\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\tif (synth_full()) {\n\t\t\tschedule_timeout(msecs_to_jiffies(delay_time_val));\n\t\t\tcontinue;\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\t\tch = synth_buffer_getc();\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\tif (ch == '\\n')\n\t\t\tch = PROCSPEECH;\n\t\tspk_out(ch);\n\t\tif (time_after_eq(jiffies, jiff_max) && (ch == SPACE)) {\n\t\t\tspk_out(PROCSPEECH);\n\t\t\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\t\t\tdelay_time_val = delay_time->u.n.value;\n\t\t\tjiffy_delta_val = jiffy_delta->u.n.value;\n\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\t\tschedule_timeout(msecs_to_jiffies(delay_time_val));\n\t\t\tjiff_max = jiffies + jiffy_delta_val;\n\t\t}\n\t}\n\tspk_out(PROCSPEECH);\n}\n\nstatic const char *synth_immediate(struct spk_synth *synth, const char *buf)\n{\n\tu_char ch;\n\n\twhile ((ch = (u_char)*buf)) {\n\t\tif (synth_full())\n\t\t\treturn buf;\n\t\tif (ch == '\\n')\n\t\t\tch = PROCSPEECH;\n\t\tspk_out(ch);\n\t\tbuf++;\n\t}\n\treturn NULL;\n}\n\nstatic void synth_flush(struct spk_synth *synth)\n{\n\toutb_p(SYNTH_CLEAR, speakup_info.port_tts);\n\twhile (synth_writable())\n\t\tcpu_relax();\n}\n\nstatic char synth_read_tts(void)\n{\n\tu_char ch;\n\n\twhile (!synth_readable())\n\t\tcpu_relax();\n\tch = synth_status & 0x7f;\n\toutb_p(ch, speakup_info.port_tts);\n\twhile (synth_readable())\n\t\tcpu_relax();\n\treturn (char)ch;\n}\n\n \nstatic struct synth_settings *synth_interrogate(struct spk_synth *synth)\n{\n\tu_char *t;\n\tstatic char buf[sizeof(struct synth_settings) + 1];\n\tint total, i;\n\tstatic struct synth_settings status;\n\n\tsynth_immediate(synth, \"\\x18\\x01?\");\n\tfor (total = 0, i = 0; i < 50; i++) {\n\t\tbuf[total] = synth_read_tts();\n\t\tif (total > 2 && buf[total] == 0x7f)\n\t\t\tbreak;\n\t\tif (total < sizeof(struct synth_settings))\n\t\t\ttotal++;\n\t}\n\tt = buf;\n\t \n\tstatus.serial_number = t[0] + t[1] * 256;\n\tt += 2;\n\tfor (i = 0; *t != '\\r'; t++) {\n\t\tstatus.rom_version[i] = *t;\n\t\tif (i < sizeof(status.rom_version) - 1)\n\t\t\ti++;\n\t}\n\tstatus.rom_version[i] = 0;\n\tt++;\n\tstatus.mode = *t++;\n\tstatus.punc_level = *t++;\n\tstatus.formant_freq = *t++;\n\tstatus.pitch = *t++;\n\tstatus.speed = *t++;\n\tstatus.volume = *t++;\n\tstatus.tone = *t++;\n\tstatus.expression = *t++;\n\tstatus.ext_dict_loaded = *t++;\n\tstatus.ext_dict_status = *t++;\n\tstatus.free_ram = *t++;\n\tstatus.articulation = *t++;\n\tstatus.reverb = *t++;\n\tstatus.eob = *t++;\n\treturn &status;\n}\n\nstatic int synth_probe(struct spk_synth *synth)\n{\n\tunsigned int port_val = 0;\n\tint i;\n\tstruct synth_settings *sp;\n\n\tpr_info(\"Probing for DoubleTalk.\\n\");\n\tif (port_forced) {\n\t\tspeakup_info.port_tts = port_forced;\n\t\tpr_info(\"probe forced to %x by kernel command line\\n\",\n\t\t\tspeakup_info.port_tts);\n\t\tif ((port_forced & 0xf) != 0xf)\n\t\t\tpr_info(\"warning: port base should probably end with f\\n\");\n\t\tif (synth_request_region(speakup_info.port_tts - 1,\n\t\t\t\t\t SYNTH_IO_EXTENT)) {\n\t\t\tpr_warn(\"sorry, port already reserved\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tport_val = inw(speakup_info.port_tts - 1);\n\t\tsynth_lpc = speakup_info.port_tts - 1;\n\t} else {\n\t\tfor (i = 0; synth_portlist[i]; i++) {\n\t\t\tif (synth_request_region(synth_portlist[i],\n\t\t\t\t\t\t SYNTH_IO_EXTENT))\n\t\t\t\tcontinue;\n\t\t\tport_val = inw(synth_portlist[i]) & 0xfbff;\n\t\t\tif (port_val == 0x107f) {\n\t\t\t\tsynth_lpc = synth_portlist[i];\n\t\t\t\tspeakup_info.port_tts = synth_lpc + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsynth_release_region(synth_portlist[i],\n\t\t\t\t\t     SYNTH_IO_EXTENT);\n\t\t}\n\t}\n\tport_val &= 0xfbff;\n\tif (port_val != 0x107f) {\n\t\tpr_info(\"DoubleTalk PC: not found\\n\");\n\t\tif (synth_lpc)\n\t\t\tsynth_release_region(synth_lpc, SYNTH_IO_EXTENT);\n\t\treturn -ENODEV;\n\t}\n\twhile (inw_p(synth_lpc) != 0x147f)\n\t\tcpu_relax();  \n\tsp = synth_interrogate(synth);\n\tpr_info(\"%s: %03x-%03x, ROM ver %s, s/n %u, driver: %s\\n\",\n\t\tsynth->long_name, synth_lpc, synth_lpc + SYNTH_IO_EXTENT - 1,\n\t\tsp->rom_version, sp->serial_number, synth->version);\n\tsynth->alive = 1;\n\treturn 0;\n}\n\nstatic void dtlk_release(struct spk_synth *synth)\n{\n\tspk_stop_serial_interrupt();\n\tif (speakup_info.port_tts)\n\t\tsynth_release_region(speakup_info.port_tts - 1,\n\t\t\t\t     SYNTH_IO_EXTENT);\n\tspeakup_info.port_tts = 0;\n}\n\nmodule_param_hw_named(port, port_forced, int, ioport, 0444);\nmodule_param_named(start, synth_dtlk.startup, short, 0444);\nmodule_param_named(rate, vars[RATE_ID].u.n.default_val, int, 0444);\nmodule_param_named(pitch, vars[PITCH_ID].u.n.default_val, int, 0444);\nmodule_param_named(vol, vars[VOL_ID].u.n.default_val, int, 0444);\nmodule_param_named(tone, vars[TONE_ID].u.n.default_val, int, 0444);\nmodule_param_named(punct, vars[PUNCT_ID].u.n.default_val, int, 0444);\nmodule_param_named(voice, vars[VOICE_ID].u.n.default_val, int, 0444);\nmodule_param_named(frequency, vars[FREQUENCY_ID].u.n.default_val, int, 0444);\nmodule_param_named(direct, vars[DIRECT_ID].u.n.default_val, int, 0444);\n\n\nMODULE_PARM_DESC(port, \"Set the port for the synthesizer (override probing).\");\nMODULE_PARM_DESC(start, \"Start the synthesizer once it is loaded.\");\nMODULE_PARM_DESC(rate, \"Set the rate variable on load.\");\nMODULE_PARM_DESC(pitch, \"Set the pitch variable on load.\");\nMODULE_PARM_DESC(vol, \"Set the vol variable on load.\");\nMODULE_PARM_DESC(tone, \"Set the tone variable on load.\");\nMODULE_PARM_DESC(punct, \"Set the punct variable on load.\");\nMODULE_PARM_DESC(voice, \"Set the voice variable on load.\");\nMODULE_PARM_DESC(frequency, \"Set the frequency variable on load.\");\nMODULE_PARM_DESC(direct, \"Set the direct variable on load.\");\n\n\nmodule_spk_synth(synth_dtlk);\n\nMODULE_AUTHOR(\"Kirk Reiser <kirk@braille.uwo.ca>\");\nMODULE_AUTHOR(\"David Borowski\");\nMODULE_DESCRIPTION(\"Speakup support for DoubleTalk PC synthesizers\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}