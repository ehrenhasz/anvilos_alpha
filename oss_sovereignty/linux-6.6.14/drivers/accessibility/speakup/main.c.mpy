{
  "module_name": "main.c",
  "hash_id": "8ad633da9ce87a290be4f34ee45a297c2fad03a6e77a05277e6c1d91ed59cc5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/speakup/main.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/vt.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\t\t \n#include <linux/vt_kern.h>\n#include <linux/ctype.h>\n#include <linux/selection.h>\n#include <linux/unistd.h>\n#include <linux/jiffies.h>\n#include <linux/kthread.h>\n#include <linux/keyboard.h>\t \n#include <linux/kbd_kern.h>\t \n#include <linux/input.h>\n#include <linux/kmod.h>\n\n \n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/consolemap.h>\n\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n\n#include <linux/uaccess.h>\t \n\n#include \"spk_priv.h\"\n#include \"speakup.h\"\n\n#define MAX_DELAY msecs_to_jiffies(500)\n#define MINECHOCHAR SPACE\n\nMODULE_AUTHOR(\"Kirk Reiser <kirk@braille.uwo.ca>\");\nMODULE_AUTHOR(\"Daniel Drake <dsd@gentoo.org>\");\nMODULE_DESCRIPTION(\"Speakup console speech\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(SPEAKUP_VERSION);\n\nchar *synth_name;\nmodule_param_named(synth, synth_name, charp, 0444);\nmodule_param_named(quiet, spk_quiet_boot, bool, 0444);\n\nMODULE_PARM_DESC(synth, \"Synth to start if speakup is built in.\");\nMODULE_PARM_DESC(quiet, \"Do not announce when the synthesizer is found.\");\n\nspecial_func spk_special_handler;\n\nshort spk_pitch_shift, synth_flags;\nstatic u16 buf[256];\nint spk_attrib_bleep, spk_bleeps, spk_bleep_time = 10;\nint spk_no_intr, spk_spell_delay;\nint spk_key_echo, spk_say_word_ctl;\nint spk_say_ctrl, spk_bell_pos;\nshort spk_punc_mask;\nint spk_punc_level, spk_reading_punc;\nint spk_cur_phonetic;\nchar spk_str_caps_start[MAXVARLEN + 1] = \"\\0\";\nchar spk_str_caps_stop[MAXVARLEN + 1] = \"\\0\";\nchar spk_str_pause[MAXVARLEN + 1] = \"\\0\";\nbool spk_paused;\nconst struct st_bits_data spk_punc_info[] = {\n\t{\"none\", \"\", 0},\n\t{\"some\", \"/$%&@\", SOME},\n\t{\"most\", \"$%&#()=+*/@^<>|\\\\\", MOST},\n\t{\"all\", \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\", PUNC},\n\t{\"delimiters\", \"\", B_WDLM},\n\t{\"repeats\", \"()\", CH_RPT},\n\t{\"extended numeric\", \"\", B_EXNUM},\n\t{\"symbols\", \"\", B_SYM},\n\t{NULL, NULL}\n};\n\nstatic char mark_cut_flag;\n#define MAX_KEY 160\nstatic u_char *spk_shift_table;\nu_char *spk_our_keys[MAX_KEY];\nu_char spk_key_buf[600];\nconst u_char spk_key_defaults[] = {\n#include \"speakupmap.h\"\n};\n\n \nenum cursor_track {\n\tCT_Off = 0,\n\tCT_On,\n\tCT_Highlight,\n\tCT_Window,\n\tCT_Max,\n\tread_all_mode = CT_Max,\n};\n\n \nstatic enum cursor_track cursor_track = 1, prev_cursor_track = 1;\n\nstatic struct tty_struct *tty;\n\nstatic void spkup_write(const u16 *in_buf, int count);\n\nstatic char *phonetic[] = {\n\t\"alfa\", \"bravo\", \"charlie\", \"delta\", \"echo\", \"foxtrot\", \"golf\", \"hotel\",\n\t\"india\", \"juliett\", \"keelo\", \"leema\", \"mike\", \"november\", \"oscar\",\n\t    \"papa\",\n\t\"keh beck\", \"romeo\", \"sierra\", \"tango\", \"uniform\", \"victer\", \"whiskey\",\n\t\"x ray\", \"yankee\", \"zulu\"\n};\n\n \nchar *spk_characters[256];\n\nchar *spk_default_chars[256] = {\n  \"null\", \"^a\", \"^b\", \"^c\", \"^d\", \"^e\", \"^f\", \"^g\",\n  \"^h\", \"^i\", \"^j\", \"^k\", \"^l\", \"^m\", \"^n\", \"^o\",\n  \"^p\", \"^q\", \"^r\", \"^s\", \"^t\", \"^u\", \"^v\", \"^w\",\n  \"^x\", \"^y\", \"^z\", \"control\", \"control\", \"control\", \"control\",\n\t    \"control\",\n  \"space\", \"bang!\", \"quote\", \"number\", \"dollar\", \"percent\", \"and\",\n\t    \"tick\",\n  \"left paren\", \"right paren\", \"star\", \"plus\", \"comma\", \"dash\",\n\t    \"dot\",\n\t\"slash\",\n  \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\",\n\t\"eight\", \"nine\",\n  \"colon\", \"semmy\", \"less\", \"equals\", \"greater\", \"question\", \"at\",\n  \"EIGH\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\",\n  \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\",\n  \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\",\n  \"Y\", \"ZED\", \"left bracket\", \"backslash\", \"right bracket\",\n\t    \"caret\",\n\t\"line\",\n  \"accent\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\n  \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\",\n  \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\",\n  \"x\", \"y\", \"zed\", \"left brace\", \"bar\", \"right brace\", \"tihlduh\",\n  \"del\", \"control\", \"control\", \"control\", \"control\", \"control\",\n\t    \"control\", \"control\", \"control\", \"control\", \"control\",\n  \"control\", \"control\", \"control\", \"control\", \"control\",\n\t    \"control\", \"control\", \"control\", \"control\", \"control\",\n\t    \"control\", \"control\",\n  \"control\", \"control\", \"control\", \"control\", \"control\",\n\t    \"control\", \"control\", \"control\", \"control\", \"control\",\n  \"nbsp\", \"inverted bang\",\n  \"cents\", \"pounds\", \"currency\", \"yen\", \"broken bar\", \"section\",\n  \"diaeresis\", \"copyright\", \"female ordinal\", \"double left angle\",\n  \"not\", \"soft hyphen\", \"registered\", \"macron\",\n  \"degrees\", \"plus or minus\", \"super two\", \"super three\",\n  \"acute accent\", \"micro\", \"pilcrow\", \"middle dot\",\n  \"cedilla\", \"super one\", \"male ordinal\", \"double right angle\",\n  \"one quarter\", \"one half\", \"three quarters\",\n\t    \"inverted question\",\n  \"A GRAVE\", \"A ACUTE\", \"A CIRCUMFLEX\", \"A TILDE\", \"A OOMLAUT\",\n\t    \"A RING\",\n  \"AE\", \"C CIDELLA\", \"E GRAVE\", \"E ACUTE\", \"E CIRCUMFLEX\",\n\t    \"E OOMLAUT\",\n  \"I GRAVE\", \"I ACUTE\", \"I CIRCUMFLEX\", \"I OOMLAUT\", \"ETH\",\n\t    \"N TILDE\",\n  \"O GRAVE\", \"O ACUTE\", \"O CIRCUMFLEX\", \"O TILDE\", \"O OOMLAUT\",\n  \"multiplied by\", \"O STROKE\", \"U GRAVE\", \"U ACUTE\",\n\t    \"U CIRCUMFLEX\",\n  \"U OOMLAUT\", \"Y ACUTE\", \"THORN\", \"sharp s\", \"a grave\",\n  \"a acute\", \"a circumflex\", \"a tilde\", \"a oomlaut\", \"a ring\",\n  \"ae\", \"c cidella\", \"e grave\", \"e acute\",\n  \"e circumflex\", \"e oomlaut\", \"i grave\", \"i acute\",\n\t    \"i circumflex\",\n  \"i oomlaut\", \"eth\", \"n tilde\", \"o grave\", \"o acute\",\n\t    \"o circumflex\",\n  \"o tilde\", \"o oomlaut\", \"divided by\", \"o stroke\", \"u grave\",\n\t    \"u acute\",\n  \"u circumflex\", \"u oomlaut\", \"y acute\", \"thorn\", \"y oomlaut\"\n};\n\n \nu_short spk_chartab[256];\n\nstatic u_short default_chartab[256] = {\n\tB_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL,\t \n\tB_CTL, B_CTL, A_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL,\t \n\tB_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL,\t \n\tB_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL,\t \n\tWDLM, A_PUNC, PUNC, PUNC, PUNC, PUNC, PUNC, A_PUNC,\t \n\tPUNC, PUNC, PUNC, PUNC, A_PUNC, A_PUNC, A_PUNC, PUNC,\t \n\tNUM, NUM, NUM, NUM, NUM, NUM, NUM, NUM,\t \n\tNUM, NUM, A_PUNC, PUNC, PUNC, PUNC, PUNC, A_PUNC,\t \n\tPUNC, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP,\t \n\tA_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP,\t \n\tA_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP,\t \n\tA_CAP, A_CAP, A_CAP, PUNC, PUNC, PUNC, PUNC, PUNC,\t \n\tPUNC, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,\t \n\tALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,\t \n\tALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,\t \n\tALPHA, ALPHA, ALPHA, PUNC, PUNC, PUNC, PUNC, 0,\t \n\tB_CAPSYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM,  \n\tB_SYM,\t \n\tB_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM,  \n\tB_CAPSYM,\t \n\tB_CAPSYM, B_CAPSYM, B_SYM, B_CAPSYM, B_SYM, B_SYM, B_SYM,  \n\tB_SYM,\t \n\tB_SYM, B_SYM, B_CAPSYM, B_CAPSYM, B_SYM, B_SYM, B_SYM,  \n\tB_SYM,\t \n\tWDLM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_CAPSYM,  \n\tB_SYM,\t \n\tB_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM,\t \n\tB_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM,\t \n\tB_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM,\t \n\tA_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP,\t \n\tA_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP,\t \n\tA_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, B_SYM,\t \n\tA_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, ALPHA,\t \n\tALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,\t \n\tALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,\t \n\tALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, B_SYM,\t \n\tALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA\t \n};\n\nstruct task_struct *speakup_task;\nstruct bleep spk_unprocessed_sound;\nstatic int spk_keydown;\nstatic u16 spk_lastkey;\nstatic u_char spk_close_press, keymap_flags;\nstatic u_char last_keycode, this_speakup_key;\nstatic u_long last_spk_jiffy;\n\nstruct st_spk_t *speakup_console[MAX_NR_CONSOLES];\n\nDEFINE_MUTEX(spk_mutex);\n\nstatic int keyboard_notifier_call(struct notifier_block *,\n\t\t\t\t  unsigned long code, void *param);\n\nstatic struct notifier_block keyboard_notifier_block = {\n\t.notifier_call = keyboard_notifier_call,\n};\n\nstatic int vt_notifier_call(struct notifier_block *,\n\t\t\t    unsigned long code, void *param);\n\nstatic struct notifier_block vt_notifier_block = {\n\t.notifier_call = vt_notifier_call,\n};\n\nstatic unsigned char get_attributes(struct vc_data *vc, u16 *pos)\n{\n\tpos = screen_pos(vc, pos - (u16 *)vc->vc_origin, true);\n\treturn (scr_readw(pos) & ~vc->vc_hi_font_mask) >> 8;\n}\n\nstatic void speakup_date(struct vc_data *vc)\n{\n\tspk_x = spk_cx = vc->state.x;\n\tspk_y = spk_cy = vc->state.y;\n\tspk_pos = spk_cp = vc->vc_pos;\n\tspk_old_attr = spk_attr;\n\tspk_attr = get_attributes(vc, (u_short *)spk_pos);\n}\n\nstatic void bleep(u_short val)\n{\n\tstatic const short vals[] = {\n\t\t350, 370, 392, 414, 440, 466, 491, 523, 554, 587, 619, 659\n\t};\n\tshort freq;\n\tint time = spk_bleep_time;\n\n\tfreq = vals[val % 12];\n\tif (val > 11)\n\t\tfreq *= (1 << (val / 12));\n\tspk_unprocessed_sound.freq = freq;\n\tspk_unprocessed_sound.jiffies = msecs_to_jiffies(time);\n\tspk_unprocessed_sound.active = 1;\n\t \n}\n\nstatic void speakup_shut_up(struct vc_data *vc)\n{\n\tif (spk_killed)\n\t\treturn;\n\tspk_shut_up |= 0x01;\n\tspk_parked &= 0xfe;\n\tspeakup_date(vc);\n\tif (synth)\n\t\tspk_do_flush();\n}\n\nstatic void speech_kill(struct vc_data *vc)\n{\n\tchar val = synth->is_alive(synth);\n\n\tif (val == 0)\n\t\treturn;\n\n\t \n\tif (val == 2 || spk_killed) {\n\t\t \n\t\tspk_shut_up &= ~0x40;\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_IAM_ALIVE));\n\t} else {\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_YOU_KILLED_SPEAKUP));\n\t\tspk_shut_up |= 0x40;\n\t}\n}\n\nstatic void speakup_off(struct vc_data *vc)\n{\n\tif (spk_shut_up & 0x80) {\n\t\tspk_shut_up &= 0x7f;\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_HEY_THATS_BETTER));\n\t} else {\n\t\tspk_shut_up |= 0x80;\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_YOU_TURNED_ME_OFF));\n\t}\n\tspeakup_date(vc);\n}\n\nstatic void speakup_parked(struct vc_data *vc)\n{\n\tif (spk_parked & 0x80) {\n\t\tspk_parked = 0;\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_UNPARKED));\n\t} else {\n\t\tspk_parked |= 0x80;\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_PARKED));\n\t}\n}\n\nstatic void speakup_cut(struct vc_data *vc)\n{\n\tstatic const char err_buf[] = \"set selection failed\";\n\tint ret;\n\n\tif (!mark_cut_flag) {\n\t\tmark_cut_flag = 1;\n\t\tspk_xs = (u_short)spk_x;\n\t\tspk_ys = (u_short)spk_y;\n\t\tspk_sel_cons = vc;\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_MARK));\n\t\treturn;\n\t}\n\tspk_xe = (u_short)spk_x;\n\tspk_ye = (u_short)spk_y;\n\tmark_cut_flag = 0;\n\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_CUT));\n\n\tret = speakup_set_selection(tty);\n\n\tswitch (ret) {\n\tcase 0:\n\t\tbreak;\t\t \n\tcase -EFAULT:\n\t\tpr_warn(\"%sEFAULT\\n\", err_buf);\n\t\tbreak;\n\tcase -EINVAL:\n\t\tpr_warn(\"%sEINVAL\\n\", err_buf);\n\t\tbreak;\n\tcase -ENOMEM:\n\t\tpr_warn(\"%sENOMEM\\n\", err_buf);\n\t\tbreak;\n\t}\n}\n\nstatic void speakup_paste(struct vc_data *vc)\n{\n\tif (mark_cut_flag) {\n\t\tmark_cut_flag = 0;\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_MARK_CLEARED));\n\t} else {\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_PASTE));\n\t\tspeakup_paste_selection(tty);\n\t}\n}\n\nstatic void say_attributes(struct vc_data *vc)\n{\n\tint fg = spk_attr & 0x0f;\n\tint bg = spk_attr >> 4;\n\n\tsynth_printf(\"%s\", spk_msg_get(MSG_COLORS_START + fg));\n\tif (bg > 7) {\n\t\tsynth_printf(\" %s \", spk_msg_get(MSG_ON_BLINKING));\n\t\tbg -= 8;\n\t} else {\n\t\tsynth_printf(\" %s \", spk_msg_get(MSG_ON));\n\t}\n\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_COLORS_START + bg));\n}\n\n \nenum edge {\n\tedge_none = 0,\n\tedge_top,\n\tedge_bottom,\n\tedge_left,\n\tedge_right,\n\tedge_quiet\n};\n\nstatic void announce_edge(struct vc_data *vc, enum edge msg_id)\n{\n\tif (spk_bleeps & 1)\n\t\tbleep(spk_y);\n\tif ((spk_bleeps & 2) && (msg_id < edge_quiet))\n\t\tsynth_printf(\"%s\\n\",\n\t\t\t     spk_msg_get(MSG_EDGE_MSGS_START + msg_id - 1));\n}\n\nstatic void speak_char(u16 ch)\n{\n\tchar *cp;\n\tstruct var_t *direct = spk_get_var(DIRECT);\n\n\tif (ch >= 0x100 || (direct && direct->u.n.value)) {\n\t\tif (ch < 0x100 && IS_CHAR(ch, B_CAP)) {\n\t\t\tspk_pitch_shift++;\n\t\t\tsynth_printf(\"%s\", spk_str_caps_start);\n\t\t}\n\t\tsynth_putwc_s(ch);\n\t\tif (ch < 0x100 && IS_CHAR(ch, B_CAP))\n\t\t\tsynth_printf(\"%s\", spk_str_caps_stop);\n\t\treturn;\n\t}\n\n\tcp = spk_characters[ch];\n\tif (!cp) {\n\t\tpr_info(\"%s: cp == NULL!\\n\", __func__);\n\t\treturn;\n\t}\n\tif (IS_CHAR(ch, B_CAP)) {\n\t\tspk_pitch_shift++;\n\t\tsynth_printf(\"%s %s %s\",\n\t\t\t     spk_str_caps_start, cp, spk_str_caps_stop);\n\t} else {\n\t\tif (*cp == '^') {\n\t\t\tcp++;\n\t\t\tsynth_printf(\" %s%s \", spk_msg_get(MSG_CTRL), cp);\n\t\t} else {\n\t\t\tsynth_printf(\" %s \", cp);\n\t\t}\n\t}\n}\n\nstatic u16 get_char(struct vc_data *vc, u16 *pos, u_char *attribs)\n{\n\tu16 ch = ' ';\n\n\tif (vc && pos) {\n\t\tu16 w;\n\t\tu16 c;\n\n\t\tpos = screen_pos(vc, pos - (u16 *)vc->vc_origin, true);\n\t\tw = scr_readw(pos);\n\t\tc = w & 0xff;\n\n\t\tif (w & vc->vc_hi_font_mask) {\n\t\t\tw &= ~vc->vc_hi_font_mask;\n\t\t\tc |= 0x100;\n\t\t}\n\n\t\tch = inverse_translate(vc, c, true);\n\t\t*attribs = (w & 0xff00) >> 8;\n\t}\n\treturn ch;\n}\n\nstatic void say_char(struct vc_data *vc)\n{\n\tu16 ch;\n\n\tspk_old_attr = spk_attr;\n\tch = get_char(vc, (u_short *)spk_pos, &spk_attr);\n\tif (spk_attr != spk_old_attr) {\n\t\tif (spk_attrib_bleep & 1)\n\t\t\tbleep(spk_y);\n\t\tif (spk_attrib_bleep & 2)\n\t\t\tsay_attributes(vc);\n\t}\n\tspeak_char(ch);\n}\n\nstatic void say_phonetic_char(struct vc_data *vc)\n{\n\tu16 ch;\n\n\tspk_old_attr = spk_attr;\n\tch = get_char(vc, (u_short *)spk_pos, &spk_attr);\n\tif (ch <= 0x7f && isalpha(ch)) {\n\t\tch &= 0x1f;\n\t\tsynth_printf(\"%s\\n\", phonetic[--ch]);\n\t} else {\n\t\tif (ch < 0x100 && IS_CHAR(ch, B_NUM))\n\t\t\tsynth_printf(\"%s \", spk_msg_get(MSG_NUMBER));\n\t\tspeak_char(ch);\n\t}\n}\n\nstatic void say_prev_char(struct vc_data *vc)\n{\n\tspk_parked |= 0x01;\n\tif (spk_x == 0) {\n\t\tannounce_edge(vc, edge_left);\n\t\treturn;\n\t}\n\tspk_x--;\n\tspk_pos -= 2;\n\tsay_char(vc);\n}\n\nstatic void say_next_char(struct vc_data *vc)\n{\n\tspk_parked |= 0x01;\n\tif (spk_x == vc->vc_cols - 1) {\n\t\tannounce_edge(vc, edge_right);\n\t\treturn;\n\t}\n\tspk_x++;\n\tspk_pos += 2;\n\tsay_char(vc);\n}\n\n \n\nstatic u_long get_word(struct vc_data *vc)\n{\n\tu_long cnt = 0, tmpx = spk_x, tmp_pos = spk_pos;\n\tu16 ch;\n\tu16 attr_ch;\n\tu_char temp;\n\n\tspk_old_attr = spk_attr;\n\tch = get_char(vc, (u_short *)tmp_pos, &temp);\n\n \n\tif (spk_say_word_ctl && ch == SPACE) {\n\t\t*buf = '\\0';\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_SPACE));\n\t\treturn 0;\n\t} else if (tmpx < vc->vc_cols - 2 &&\n\t\t   (ch == SPACE || ch == 0 || (ch < 0x100 && IS_WDLM(ch))) &&\n\t\t   get_char(vc, (u_short *)tmp_pos + 1, &temp) > SPACE) {\n\t\ttmp_pos += 2;\n\t\ttmpx++;\n\t} else {\n\t\twhile (tmpx > 0) {\n\t\t\tch = get_char(vc, (u_short *)tmp_pos - 1, &temp);\n\t\t\tif ((ch == SPACE || ch == 0 ||\n\t\t\t     (ch < 0x100 && IS_WDLM(ch))) &&\n\t\t\t    get_char(vc, (u_short *)tmp_pos, &temp) > SPACE)\n\t\t\t\tbreak;\n\t\t\ttmp_pos -= 2;\n\t\t\ttmpx--;\n\t\t}\n\t}\n\tattr_ch = get_char(vc, (u_short *)tmp_pos, &spk_attr);\n\tbuf[cnt++] = attr_ch;\n\twhile (tmpx < vc->vc_cols - 1) {\n\t\ttmp_pos += 2;\n\t\ttmpx++;\n\t\tch = get_char(vc, (u_short *)tmp_pos, &temp);\n\t\tif (ch == SPACE || ch == 0 ||\n\t\t    (buf[cnt - 1] < 0x100 && IS_WDLM(buf[cnt - 1]) &&\n\t\t     ch > SPACE))\n\t\t\tbreak;\n\t\tbuf[cnt++] = ch;\n\t}\n\tbuf[cnt] = '\\0';\n\treturn cnt;\n}\n\nstatic void say_word(struct vc_data *vc)\n{\n\tu_long cnt = get_word(vc);\n\tu_short saved_punc_mask = spk_punc_mask;\n\n\tif (cnt == 0)\n\t\treturn;\n\tspk_punc_mask = PUNC;\n\tbuf[cnt++] = SPACE;\n\tspkup_write(buf, cnt);\n\tspk_punc_mask = saved_punc_mask;\n}\n\nstatic void say_prev_word(struct vc_data *vc)\n{\n\tu_char temp;\n\tu16 ch;\n\tenum edge edge_said = edge_none;\n\tu_short last_state = 0, state = 0;\n\n\tspk_parked |= 0x01;\n\n\tif (spk_x == 0) {\n\t\tif (spk_y == 0) {\n\t\t\tannounce_edge(vc, edge_top);\n\t\t\treturn;\n\t\t}\n\t\tspk_y--;\n\t\tspk_x = vc->vc_cols;\n\t\tedge_said = edge_quiet;\n\t}\n\twhile (1) {\n\t\tif (spk_x == 0) {\n\t\t\tif (spk_y == 0) {\n\t\t\t\tedge_said = edge_top;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (edge_said != edge_quiet)\n\t\t\t\tedge_said = edge_left;\n\t\t\tif (state > 0)\n\t\t\t\tbreak;\n\t\t\tspk_y--;\n\t\t\tspk_x = vc->vc_cols - 1;\n\t\t} else {\n\t\t\tspk_x--;\n\t\t}\n\t\tspk_pos -= 2;\n\t\tch = get_char(vc, (u_short *)spk_pos, &temp);\n\t\tif (ch == SPACE || ch == 0)\n\t\t\tstate = 0;\n\t\telse if (ch < 0x100 && IS_WDLM(ch))\n\t\t\tstate = 1;\n\t\telse\n\t\t\tstate = 2;\n\t\tif (state < last_state) {\n\t\t\tspk_pos += 2;\n\t\t\tspk_x++;\n\t\t\tbreak;\n\t\t}\n\t\tlast_state = state;\n\t}\n\tif (spk_x == 0 && edge_said == edge_quiet)\n\t\tedge_said = edge_left;\n\tif (edge_said > edge_none && edge_said < edge_quiet)\n\t\tannounce_edge(vc, edge_said);\n\tsay_word(vc);\n}\n\nstatic void say_next_word(struct vc_data *vc)\n{\n\tu_char temp;\n\tu16 ch;\n\tenum edge edge_said = edge_none;\n\tu_short last_state = 2, state = 0;\n\n\tspk_parked |= 0x01;\n\tif (spk_x == vc->vc_cols - 1 && spk_y == vc->vc_rows - 1) {\n\t\tannounce_edge(vc, edge_bottom);\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tch = get_char(vc, (u_short *)spk_pos, &temp);\n\t\tif (ch == SPACE || ch == 0)\n\t\t\tstate = 0;\n\t\telse if (ch < 0x100 && IS_WDLM(ch))\n\t\t\tstate = 1;\n\t\telse\n\t\t\tstate = 2;\n\t\tif (state > last_state)\n\t\t\tbreak;\n\t\tif (spk_x >= vc->vc_cols - 1) {\n\t\t\tif (spk_y == vc->vc_rows - 1) {\n\t\t\t\tedge_said = edge_bottom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate = 0;\n\t\t\tspk_y++;\n\t\t\tspk_x = 0;\n\t\t\tedge_said = edge_right;\n\t\t} else {\n\t\t\tspk_x++;\n\t\t}\n\t\tspk_pos += 2;\n\t\tlast_state = state;\n\t}\n\tif (edge_said > edge_none)\n\t\tannounce_edge(vc, edge_said);\n\tsay_word(vc);\n}\n\nstatic void spell_word(struct vc_data *vc)\n{\n\tstatic char const *delay_str[] = { \"\", \",\", \".\", \". .\", \". . .\" };\n\tu16 *cp = buf;\n\tchar *cp1;\n\tchar *str_cap = spk_str_caps_stop;\n\tchar *last_cap = spk_str_caps_stop;\n\tstruct var_t *direct = spk_get_var(DIRECT);\n\tu16 ch;\n\n\tif (!get_word(vc))\n\t\treturn;\n\twhile ((ch = *cp)) {\n\t\tif (cp != buf)\n\t\t\tsynth_printf(\" %s \", delay_str[spk_spell_delay]);\n\t\t \n\t\tif (ch < 0x100 && IS_CHAR(ch, B_CAP)) {\n\t\t\tstr_cap = spk_str_caps_start;\n\t\t\tif (*spk_str_caps_stop)\n\t\t\t\tspk_pitch_shift++;\n\t\t\telse\t \n\t\t\t\tlast_cap = spk_str_caps_stop;\n\t\t} else {\n\t\t\tstr_cap = spk_str_caps_stop;\n\t\t}\n\t\tif (str_cap != last_cap) {\n\t\t\tsynth_printf(\"%s\", str_cap);\n\t\t\tlast_cap = str_cap;\n\t\t}\n\t\tif (ch >= 0x100 || (direct && direct->u.n.value)) {\n\t\t\tsynth_putwc_s(ch);\n\t\t} else if (this_speakup_key == SPELL_PHONETIC &&\n\t\t    ch <= 0x7f && isalpha(ch)) {\n\t\t\tch &= 0x1f;\n\t\t\tcp1 = phonetic[--ch];\n\t\t\tsynth_printf(\"%s\", cp1);\n\t\t} else {\n\t\t\tcp1 = spk_characters[ch];\n\t\t\tif (*cp1 == '^') {\n\t\t\t\tsynth_printf(\"%s\", spk_msg_get(MSG_CTRL));\n\t\t\t\tcp1++;\n\t\t\t}\n\t\t\tsynth_printf(\"%s\", cp1);\n\t\t}\n\t\tcp++;\n\t}\n\tif (str_cap != spk_str_caps_stop)\n\t\tsynth_printf(\"%s\", spk_str_caps_stop);\n}\n\nstatic int get_line(struct vc_data *vc)\n{\n\tu_long tmp = spk_pos - (spk_x * 2);\n\tint i = 0;\n\tu_char tmp2;\n\n\tspk_old_attr = spk_attr;\n\tspk_attr = get_attributes(vc, (u_short *)spk_pos);\n\tfor (i = 0; i < vc->vc_cols; i++) {\n\t\tbuf[i] = get_char(vc, (u_short *)tmp, &tmp2);\n\t\ttmp += 2;\n\t}\n\tfor (--i; i >= 0; i--)\n\t\tif (buf[i] != SPACE)\n\t\t\tbreak;\n\treturn ++i;\n}\n\nstatic void say_line(struct vc_data *vc)\n{\n\tint i = get_line(vc);\n\tu16 *cp;\n\tu_short saved_punc_mask = spk_punc_mask;\n\n\tif (i == 0) {\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_BLANK));\n\t\treturn;\n\t}\n\tbuf[i++] = '\\n';\n\tif (this_speakup_key == SAY_LINE_INDENT) {\n\t\tcp = buf;\n\t\twhile (*cp == SPACE)\n\t\t\tcp++;\n\t\tsynth_printf(\"%zd, \", (cp - buf) + 1);\n\t}\n\tspk_punc_mask = spk_punc_masks[spk_reading_punc];\n\tspkup_write(buf, i);\n\tspk_punc_mask = saved_punc_mask;\n}\n\nstatic void say_prev_line(struct vc_data *vc)\n{\n\tspk_parked |= 0x01;\n\tif (spk_y == 0) {\n\t\tannounce_edge(vc, edge_top);\n\t\treturn;\n\t}\n\tspk_y--;\n\tspk_pos -= vc->vc_size_row;\n\tsay_line(vc);\n}\n\nstatic void say_next_line(struct vc_data *vc)\n{\n\tspk_parked |= 0x01;\n\tif (spk_y == vc->vc_rows - 1) {\n\t\tannounce_edge(vc, edge_bottom);\n\t\treturn;\n\t}\n\tspk_y++;\n\tspk_pos += vc->vc_size_row;\n\tsay_line(vc);\n}\n\nstatic int say_from_to(struct vc_data *vc, u_long from, u_long to,\n\t\t       int read_punc)\n{\n\tint i = 0;\n\tu_char tmp;\n\tu_short saved_punc_mask = spk_punc_mask;\n\n\tspk_old_attr = spk_attr;\n\tspk_attr = get_attributes(vc, (u_short *)from);\n\twhile (from < to) {\n\t\tbuf[i++] = get_char(vc, (u_short *)from, &tmp);\n\t\tfrom += 2;\n\t\tif (i >= vc->vc_size_row)\n\t\t\tbreak;\n\t}\n\tfor (--i; i >= 0; i--)\n\t\tif (buf[i] != SPACE)\n\t\t\tbreak;\n\tbuf[++i] = SPACE;\n\tbuf[++i] = '\\0';\n\tif (i < 1)\n\t\treturn i;\n\tif (read_punc)\n\t\tspk_punc_mask = spk_punc_info[spk_reading_punc].mask;\n\tspkup_write(buf, i);\n\tif (read_punc)\n\t\tspk_punc_mask = saved_punc_mask;\n\treturn i - 1;\n}\n\nstatic void say_line_from_to(struct vc_data *vc, u_long from, u_long to,\n\t\t\t     int read_punc)\n{\n\tu_long start = vc->vc_origin + (spk_y * vc->vc_size_row);\n\tu_long end = start + (to * 2);\n\n\tstart += from * 2;\n\tif (say_from_to(vc, start, end, read_punc) <= 0)\n\t\tif (cursor_track != read_all_mode)\n\t\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_BLANK));\n}\n\n \n\nstatic int currsentence;\nstatic int numsentences[2];\nstatic u16 *sentbufend[2];\nstatic u16 *sentmarks[2][10];\nstatic int currbuf;\nstatic int bn;\nstatic u16 sentbuf[2][256];\n\nstatic int say_sentence_num(int num, int prev)\n{\n\tbn = currbuf;\n\tcurrsentence = num + 1;\n\tif (prev && --bn == -1)\n\t\tbn = 1;\n\n\tif (num > numsentences[bn])\n\t\treturn 0;\n\n\tspkup_write(sentmarks[bn][num], sentbufend[bn] - sentmarks[bn][num]);\n\treturn 1;\n}\n\nstatic int get_sentence_buf(struct vc_data *vc, int read_punc)\n{\n\tu_long start, end;\n\tint i, bn;\n\tu_char tmp;\n\n\tcurrbuf++;\n\tif (currbuf == 2)\n\t\tcurrbuf = 0;\n\tbn = currbuf;\n\tstart = vc->vc_origin + ((spk_y) * vc->vc_size_row);\n\tend = vc->vc_origin + ((spk_y) * vc->vc_size_row) + vc->vc_cols * 2;\n\n\tnumsentences[bn] = 0;\n\tsentmarks[bn][0] = &sentbuf[bn][0];\n\ti = 0;\n\tspk_old_attr = spk_attr;\n\tspk_attr = get_attributes(vc, (u_short *)start);\n\n\twhile (start < end) {\n\t\tsentbuf[bn][i] = get_char(vc, (u_short *)start, &tmp);\n\t\tif (i > 0) {\n\t\t\tif (sentbuf[bn][i] == SPACE &&\n\t\t\t    sentbuf[bn][i - 1] == '.' &&\n\t\t\t    numsentences[bn] < 9) {\n\t\t\t\t \n\t\t\t\tnumsentences[bn]++;\n\t\t\t\tsentmarks[bn][numsentences[bn]] =\n\t\t\t\t    &sentbuf[bn][i];\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tstart += 2;\n\t\tif (i >= vc->vc_size_row)\n\t\t\tbreak;\n\t}\n\n\tfor (--i; i >= 0; i--)\n\t\tif (sentbuf[bn][i] != SPACE)\n\t\t\tbreak;\n\n\tif (i < 1)\n\t\treturn -1;\n\n\tsentbuf[bn][++i] = SPACE;\n\tsentbuf[bn][++i] = '\\0';\n\n\tsentbufend[bn] = &sentbuf[bn][i];\n\treturn numsentences[bn];\n}\n\nstatic void say_screen_from_to(struct vc_data *vc, u_long from, u_long to)\n{\n\tu_long start = vc->vc_origin, end;\n\n\tif (from > 0)\n\t\tstart += from * vc->vc_size_row;\n\tif (to > vc->vc_rows)\n\t\tto = vc->vc_rows;\n\tend = vc->vc_origin + (to * vc->vc_size_row);\n\tfor (from = start; from < end; from = to) {\n\t\tto = from + vc->vc_size_row;\n\t\tsay_from_to(vc, from, to, 1);\n\t}\n}\n\nstatic void say_screen(struct vc_data *vc)\n{\n\tsay_screen_from_to(vc, 0, vc->vc_rows);\n}\n\nstatic void speakup_win_say(struct vc_data *vc)\n{\n\tu_long start, end, from, to;\n\n\tif (win_start < 2) {\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_NO_WINDOW));\n\t\treturn;\n\t}\n\tstart = vc->vc_origin + (win_top * vc->vc_size_row);\n\tend = vc->vc_origin + (win_bottom * vc->vc_size_row);\n\twhile (start <= end) {\n\t\tfrom = start + (win_left * 2);\n\t\tto = start + (win_right * 2);\n\t\tsay_from_to(vc, from, to, 1);\n\t\tstart += vc->vc_size_row;\n\t}\n}\n\nstatic void top_edge(struct vc_data *vc)\n{\n\tspk_parked |= 0x01;\n\tspk_pos = vc->vc_origin + 2 * spk_x;\n\tspk_y = 0;\n\tsay_line(vc);\n}\n\nstatic void bottom_edge(struct vc_data *vc)\n{\n\tspk_parked |= 0x01;\n\tspk_pos += (vc->vc_rows - spk_y - 1) * vc->vc_size_row;\n\tspk_y = vc->vc_rows - 1;\n\tsay_line(vc);\n}\n\nstatic void left_edge(struct vc_data *vc)\n{\n\tspk_parked |= 0x01;\n\tspk_pos -= spk_x * 2;\n\tspk_x = 0;\n\tsay_char(vc);\n}\n\nstatic void right_edge(struct vc_data *vc)\n{\n\tspk_parked |= 0x01;\n\tspk_pos += (vc->vc_cols - spk_x - 1) * 2;\n\tspk_x = vc->vc_cols - 1;\n\tsay_char(vc);\n}\n\nstatic void say_first_char(struct vc_data *vc)\n{\n\tint i, len = get_line(vc);\n\tu16 ch;\n\n\tspk_parked |= 0x01;\n\tif (len == 0) {\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_BLANK));\n\t\treturn;\n\t}\n\tfor (i = 0; i < len; i++)\n\t\tif (buf[i] != SPACE)\n\t\t\tbreak;\n\tch = buf[i];\n\tspk_pos -= (spk_x - i) * 2;\n\tspk_x = i;\n\tsynth_printf(\"%d, \", ++i);\n\tspeak_char(ch);\n}\n\nstatic void say_last_char(struct vc_data *vc)\n{\n\tint len = get_line(vc);\n\tu16 ch;\n\n\tspk_parked |= 0x01;\n\tif (len == 0) {\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_BLANK));\n\t\treturn;\n\t}\n\tch = buf[--len];\n\tspk_pos -= (spk_x - len) * 2;\n\tspk_x = len;\n\tsynth_printf(\"%d, \", ++len);\n\tspeak_char(ch);\n}\n\nstatic void say_position(struct vc_data *vc)\n{\n\tsynth_printf(spk_msg_get(MSG_POS_INFO), spk_y + 1, spk_x + 1,\n\t\t     vc->vc_num + 1);\n\tsynth_printf(\"\\n\");\n}\n\n \nstatic void say_char_num(struct vc_data *vc)\n{\n\tu_char tmp;\n\tu16 ch = get_char(vc, (u_short *)spk_pos, &tmp);\n\n\tsynth_printf(spk_msg_get(MSG_CHAR_INFO), ch, ch);\n}\n\n \n\nstatic void say_from_top(struct vc_data *vc)\n{\n\tsay_screen_from_to(vc, 0, spk_y);\n}\n\nstatic void say_to_bottom(struct vc_data *vc)\n{\n\tsay_screen_from_to(vc, spk_y, vc->vc_rows);\n}\n\nstatic void say_from_left(struct vc_data *vc)\n{\n\tsay_line_from_to(vc, 0, spk_x, 1);\n}\n\nstatic void say_to_right(struct vc_data *vc)\n{\n\tsay_line_from_to(vc, spk_x, vc->vc_cols, 1);\n}\n\n \n\nstatic void spkup_write(const u16 *in_buf, int count)\n{\n\tstatic int rep_count;\n\tstatic u16 ch = '\\0', old_ch = '\\0';\n\tstatic u_short char_type, last_type;\n\tint in_count = count;\n\n\tspk_keydown = 0;\n\twhile (count--) {\n\t\tif (cursor_track == read_all_mode) {\n\t\t\t \n\t\t\tif ((in_buf == sentmarks[bn][currsentence]) &&\n\t\t\t    (currsentence <= numsentences[bn]))\n\t\t\t\tsynth_insert_next_index(currsentence++);\n\t\t}\n\t\tch = *in_buf++;\n\t\tif (ch < 0x100)\n\t\t\tchar_type = spk_chartab[ch];\n\t\telse\n\t\t\tchar_type = ALPHA;\n\t\tif (ch == old_ch && !(char_type & B_NUM)) {\n\t\t\tif (++rep_count > 2)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif ((last_type & CH_RPT) && rep_count > 2) {\n\t\t\t\tsynth_printf(\" \");\n\t\t\t\tsynth_printf(spk_msg_get(MSG_REPEAT_DESC),\n\t\t\t\t\t     ++rep_count);\n\t\t\t\tsynth_printf(\" \");\n\t\t\t}\n\t\t\trep_count = 0;\n\t\t}\n\t\tif (ch == spk_lastkey) {\n\t\t\trep_count = 0;\n\t\t\tif (spk_key_echo == 1 && ch >= MINECHOCHAR)\n\t\t\t\tspeak_char(ch);\n\t\t} else if (char_type & B_ALPHA) {\n\t\t\tif ((synth_flags & SF_DEC) && (last_type & PUNC))\n\t\t\t\tsynth_buffer_add(SPACE);\n\t\t\tsynth_putwc_s(ch);\n\t\t} else if (char_type & B_NUM) {\n\t\t\trep_count = 0;\n\t\t\tsynth_putwc_s(ch);\n\t\t} else if (char_type & spk_punc_mask) {\n\t\t\tspeak_char(ch);\n\t\t\tchar_type &= ~PUNC;\t \n\t\t} else if (char_type & SYNTH_OK) {\n\t\t\t \n\t\t\tif (ch != old_ch)\n\t\t\t\tsynth_putwc_s(ch);\n\t\t\telse\n\t\t\t\trep_count = 0;\n\t\t} else {\n \n\t\t\tif (old_ch != ch)\n\t\t\t\tsynth_buffer_add(SPACE);\n\t\t\telse\n\t\t\t\trep_count = 0;\n\t\t}\n\t\told_ch = ch;\n\t\tlast_type = char_type;\n\t}\n\tspk_lastkey = 0;\n\tif (in_count > 2 && rep_count > 2) {\n\t\tif (last_type & CH_RPT) {\n\t\t\tsynth_printf(\" \");\n\t\t\tsynth_printf(spk_msg_get(MSG_REPEAT_DESC2),\n\t\t\t\t     ++rep_count);\n\t\t\tsynth_printf(\" \");\n\t\t}\n\t\trep_count = 0;\n\t}\n}\n\nstatic const int NUM_CTL_LABELS = (MSG_CTL_END - MSG_CTL_START + 1);\n\nstatic void read_all_doc(struct vc_data *vc);\nstatic void cursor_done(struct timer_list *unused);\nstatic DEFINE_TIMER(cursor_timer, cursor_done);\n\nstatic void do_handle_shift(struct vc_data *vc, u_char value, char up_flag)\n{\n\tunsigned long flags;\n\n\tif (!synth || up_flag || spk_killed)\n\t\treturn;\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tif (cursor_track == read_all_mode) {\n\t\tswitch (value) {\n\t\tcase KVAL(K_SHIFT):\n\t\t\tdel_timer(&cursor_timer);\n\t\t\tspk_shut_up &= 0xfe;\n\t\t\tspk_do_flush();\n\t\t\tread_all_doc(vc);\n\t\t\tbreak;\n\t\tcase KVAL(K_CTRL):\n\t\t\tdel_timer(&cursor_timer);\n\t\t\tcursor_track = prev_cursor_track;\n\t\t\tspk_shut_up &= 0xfe;\n\t\t\tspk_do_flush();\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tspk_shut_up &= 0xfe;\n\t\tspk_do_flush();\n\t}\n\tif (spk_say_ctrl && value < NUM_CTL_LABELS)\n\t\tsynth_printf(\"%s\", spk_msg_get(MSG_CTL_START + value));\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n}\n\nstatic void do_handle_latin(struct vc_data *vc, u_char value, char up_flag)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tif (up_flag) {\n\t\tspk_lastkey = 0;\n\t\tspk_keydown = 0;\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\treturn;\n\t}\n\tif (!synth || spk_killed) {\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\treturn;\n\t}\n\tspk_shut_up &= 0xfe;\n\tspk_lastkey = value;\n\tspk_keydown++;\n\tspk_parked &= 0xfe;\n\tif (spk_key_echo == 2 && value >= MINECHOCHAR)\n\t\tspeak_char(value);\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n}\n\nint spk_set_key_info(const u_char *key_info, u_char *k_buffer)\n{\n\tint i = 0, states, key_data_len;\n\tconst u_char *cp = key_info;\n\tu_char *cp1 = k_buffer;\n\tu_char ch, version, num_keys;\n\n\tversion = *cp++;\n\tif (version != KEY_MAP_VER) {\n\t\tpr_debug(\"version found %d should be %d\\n\",\n\t\t\t version, KEY_MAP_VER);\n\t\treturn -EINVAL;\n\t}\n\tnum_keys = *cp;\n\tstates = (int)cp[1];\n\tkey_data_len = (states + 1) * (num_keys + 1);\n\tif (key_data_len + SHIFT_TBL_SIZE + 4 >= sizeof(spk_key_buf)) {\n\t\tpr_debug(\"too many key_infos (%d over %u)\\n\",\n\t\t\t key_data_len + SHIFT_TBL_SIZE + 4,\n\t\t\t (unsigned int)(sizeof(spk_key_buf)));\n\t\treturn -EINVAL;\n\t}\n\tmemset(k_buffer, 0, SHIFT_TBL_SIZE);\n\tmemset(spk_our_keys, 0, sizeof(spk_our_keys));\n\tspk_shift_table = k_buffer;\n\tspk_our_keys[0] = spk_shift_table;\n\tcp1 += SHIFT_TBL_SIZE;\n\tmemcpy(cp1, cp, key_data_len + 3);\n\t \n\tcp1 += 2;\t\t \n\tfor (i = 1; i <= states; i++) {\n\t\tch = *cp1++;\n\t\tif (ch >= SHIFT_TBL_SIZE) {\n\t\t\tpr_debug(\"(%d) not valid shift state (max_allowed = %d)\\n\",\n\t\t\t\t ch, SHIFT_TBL_SIZE);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tspk_shift_table[ch] = i;\n\t}\n\tkeymap_flags = *cp1++;\n\twhile ((ch = *cp1)) {\n\t\tif (ch >= MAX_KEY) {\n\t\t\tpr_debug(\"(%d), not valid key, (max_allowed = %d)\\n\",\n\t\t\t\t ch, MAX_KEY);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tspk_our_keys[ch] = cp1;\n\t\tcp1 += states + 1;\n\t}\n\treturn 0;\n}\n\nenum spk_vars_id {\n\tBELL_POS_ID = 0, SPELL_DELAY_ID, ATTRIB_BLEEP_ID,\n\tBLEEPS_ID, BLEEP_TIME_ID, PUNC_LEVEL_ID,\n\tREADING_PUNC_ID, CURSOR_TIME_ID, SAY_CONTROL_ID,\n\tSAY_WORD_CTL_ID, NO_INTERRUPT_ID, KEY_ECHO_ID,\n\tCUR_PHONETIC_ID, V_LAST_VAR_ID, NB_ID\n};\n\nstatic struct var_t spk_vars[NB_ID] = {\n\t \n\t[BELL_POS_ID] = { BELL_POS, .u.n = {NULL, 0, 0, 0, 0, 0, NULL} },\n\t[SPELL_DELAY_ID] = { SPELL_DELAY, .u.n = {NULL, 0, 0, 4, 0, 0, NULL} },\n\t[ATTRIB_BLEEP_ID] = { ATTRIB_BLEEP, .u.n = {NULL, 1, 0, 3, 0, 0, NULL} },\n\t[BLEEPS_ID] = { BLEEPS, .u.n = {NULL, 3, 0, 3, 0, 0, NULL} },\n\t[BLEEP_TIME_ID] = { BLEEP_TIME, .u.n = {NULL, 30, 1, 200, 0, 0, NULL} },\n\t[PUNC_LEVEL_ID] = { PUNC_LEVEL, .u.n = {NULL, 1, 0, 4, 0, 0, NULL} },\n\t[READING_PUNC_ID] = { READING_PUNC, .u.n = {NULL, 1, 0, 4, 0, 0, NULL} },\n\t[CURSOR_TIME_ID] = { CURSOR_TIME, .u.n = {NULL, 120, 50, 600, 0, 0, NULL} },\n\t[SAY_CONTROL_ID] = { SAY_CONTROL, TOGGLE_0},\n\t[SAY_WORD_CTL_ID] = {SAY_WORD_CTL, TOGGLE_0},\n\t[NO_INTERRUPT_ID] = { NO_INTERRUPT, TOGGLE_0},\n\t[KEY_ECHO_ID] = { KEY_ECHO, .u.n = {NULL, 1, 0, 2, 0, 0, NULL} },\n\t[CUR_PHONETIC_ID] = { CUR_PHONETIC, .u.n = {NULL, 0, 0, 1, 0, 0, NULL} },\n\tV_LAST_VAR\n};\n\nstatic void toggle_cursoring(struct vc_data *vc)\n{\n\tif (cursor_track == read_all_mode)\n\t\tcursor_track = prev_cursor_track;\n\tif (++cursor_track >= CT_Max)\n\t\tcursor_track = 0;\n\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_CURSOR_MSGS_START + cursor_track));\n}\n\nvoid spk_reset_default_chars(void)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 256; i++) {\n\t\tif (spk_characters[i] &&\n\t\t    (spk_characters[i] != spk_default_chars[i]))\n\t\t\tkfree(spk_characters[i]);\n\t}\n\n\tmemcpy(spk_characters, spk_default_chars, sizeof(spk_default_chars));\n}\n\nvoid spk_reset_default_chartab(void)\n{\n\tmemcpy(spk_chartab, default_chartab, sizeof(default_chartab));\n}\n\nstatic const struct st_bits_data *pb_edit;\n\nstatic int edit_bits(struct vc_data *vc, u_char type, u_char ch, u_short key)\n{\n\tshort mask = pb_edit->mask, ch_type = spk_chartab[ch];\n\n\tif (type != KT_LATIN || (ch_type & B_NUM) || ch < SPACE)\n\t\treturn -1;\n\tif (ch == SPACE) {\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_EDIT_DONE));\n\t\tspk_special_handler = NULL;\n\t\treturn 1;\n\t}\n\tif (mask < PUNC && !(ch_type & PUNC))\n\t\treturn -1;\n\tspk_chartab[ch] ^= mask;\n\tspeak_char(ch);\n\tsynth_printf(\" %s\\n\",\n\t\t     (spk_chartab[ch] & mask) ? spk_msg_get(MSG_ON) :\n\t\t     spk_msg_get(MSG_OFF));\n\treturn 1;\n}\n\n \nstatic int speakup_allocate(struct vc_data *vc, gfp_t gfp_flags)\n{\n\tint vc_num;\n\n\tvc_num = vc->vc_num;\n\tif (!speakup_console[vc_num]) {\n\t\tspeakup_console[vc_num] = kzalloc(sizeof(*speakup_console[0]),\n\t\t\t\t\t\t  gfp_flags);\n\t\tif (!speakup_console[vc_num])\n\t\t\treturn -ENOMEM;\n\t\tspeakup_date(vc);\n\t} else if (!spk_parked) {\n\t\tspeakup_date(vc);\n\t}\n\n\treturn 0;\n}\n\nstatic void speakup_deallocate(struct vc_data *vc)\n{\n\tint vc_num;\n\n\tvc_num = vc->vc_num;\n\tkfree(speakup_console[vc_num]);\n\tspeakup_console[vc_num] = NULL;\n}\n\nenum read_all_command {\n\tRA_NEXT_SENT = KVAL(K_DOWN)+1,\n\tRA_PREV_LINE = KVAL(K_LEFT)+1,\n\tRA_NEXT_LINE = KVAL(K_RIGHT)+1,\n\tRA_PREV_SENT = KVAL(K_UP)+1,\n\tRA_DOWN_ARROW,\n\tRA_TIMER,\n\tRA_FIND_NEXT_SENT,\n\tRA_FIND_PREV_SENT,\n};\n\nstatic u_char is_cursor;\nstatic u_long old_cursor_pos, old_cursor_x, old_cursor_y;\nstatic int cursor_con;\n\nstatic void reset_highlight_buffers(struct vc_data *);\n\nstatic enum read_all_command read_all_key;\n\nstatic int in_keyboard_notifier;\n\nstatic void start_read_all_timer(struct vc_data *vc, enum read_all_command command);\n\nstatic void kbd_fakekey2(struct vc_data *vc, enum read_all_command command)\n{\n\tdel_timer(&cursor_timer);\n\tspeakup_fake_down_arrow();\n\tstart_read_all_timer(vc, command);\n}\n\nstatic void read_all_doc(struct vc_data *vc)\n{\n\tif ((vc->vc_num != fg_console) || !synth || spk_shut_up)\n\t\treturn;\n\tif (!synth_supports_indexing())\n\t\treturn;\n\tif (cursor_track != read_all_mode)\n\t\tprev_cursor_track = cursor_track;\n\tcursor_track = read_all_mode;\n\tspk_reset_index_count(0);\n\tif (get_sentence_buf(vc, 0) == -1) {\n\t\tdel_timer(&cursor_timer);\n\t\tif (!in_keyboard_notifier)\n\t\t\tspeakup_fake_down_arrow();\n\t\tstart_read_all_timer(vc, RA_DOWN_ARROW);\n\t} else {\n\t\tsay_sentence_num(0, 0);\n\t\tsynth_insert_next_index(0);\n\t\tstart_read_all_timer(vc, RA_TIMER);\n\t}\n}\n\nstatic void stop_read_all(struct vc_data *vc)\n{\n\tdel_timer(&cursor_timer);\n\tcursor_track = prev_cursor_track;\n\tspk_shut_up &= 0xfe;\n\tspk_do_flush();\n}\n\nstatic void start_read_all_timer(struct vc_data *vc, enum read_all_command command)\n{\n\tstruct var_t *cursor_timeout;\n\n\tcursor_con = vc->vc_num;\n\tread_all_key = command;\n\tcursor_timeout = spk_get_var(CURSOR_TIME);\n\tmod_timer(&cursor_timer,\n\t\t  jiffies + msecs_to_jiffies(cursor_timeout->u.n.value));\n}\n\nstatic void handle_cursor_read_all(struct vc_data *vc, enum read_all_command command)\n{\n\tint indcount, sentcount, rv, sn;\n\n\tswitch (command) {\n\tcase RA_NEXT_SENT:\n\t\t \n\t\tspk_get_index_count(&indcount, &sentcount);\n\t\t \n\t\tspk_reset_index_count(sentcount + 1);\n\t\tif (indcount == 1) {\n\t\t\tif (!say_sentence_num(sentcount + 1, 0)) {\n\t\t\t\tkbd_fakekey2(vc, RA_FIND_NEXT_SENT);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsynth_insert_next_index(0);\n\t\t} else {\n\t\t\tsn = 0;\n\t\t\tif (!say_sentence_num(sentcount + 1, 1)) {\n\t\t\t\tsn = 1;\n\t\t\t\tspk_reset_index_count(sn);\n\t\t\t} else {\n\t\t\t\tsynth_insert_next_index(0);\n\t\t\t}\n\t\t\tif (!say_sentence_num(sn, 0)) {\n\t\t\t\tkbd_fakekey2(vc, RA_FIND_NEXT_SENT);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsynth_insert_next_index(0);\n\t\t}\n\t\tstart_read_all_timer(vc, RA_TIMER);\n\t\tbreak;\n\tcase RA_PREV_SENT:\n\t\tbreak;\n\tcase RA_NEXT_LINE:\n\t\tread_all_doc(vc);\n\t\tbreak;\n\tcase RA_PREV_LINE:\n\t\tbreak;\n\tcase RA_DOWN_ARROW:\n\t\tif (get_sentence_buf(vc, 0) == -1) {\n\t\t\tkbd_fakekey2(vc, RA_DOWN_ARROW);\n\t\t} else {\n\t\t\tsay_sentence_num(0, 0);\n\t\t\tsynth_insert_next_index(0);\n\t\t\tstart_read_all_timer(vc, RA_TIMER);\n\t\t}\n\t\tbreak;\n\tcase RA_FIND_NEXT_SENT:\n\t\trv = get_sentence_buf(vc, 0);\n\t\tif (rv == -1)\n\t\t\tread_all_doc(vc);\n\t\tif (rv == 0) {\n\t\t\tkbd_fakekey2(vc, RA_FIND_NEXT_SENT);\n\t\t} else {\n\t\t\tsay_sentence_num(1, 0);\n\t\t\tsynth_insert_next_index(0);\n\t\t\tstart_read_all_timer(vc, RA_TIMER);\n\t\t}\n\t\tbreak;\n\tcase RA_FIND_PREV_SENT:\n\t\tbreak;\n\tcase RA_TIMER:\n\t\tspk_get_index_count(&indcount, &sentcount);\n\t\tif (indcount < 2)\n\t\t\tkbd_fakekey2(vc, RA_DOWN_ARROW);\n\t\telse\n\t\t\tstart_read_all_timer(vc, RA_TIMER);\n\t\tbreak;\n\t}\n}\n\nstatic int pre_handle_cursor(struct vc_data *vc, u_char value, char up_flag)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tif (cursor_track == read_all_mode) {\n\t\tspk_parked &= 0xfe;\n\t\tif (!synth || up_flag || spk_shut_up) {\n\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\t\treturn NOTIFY_STOP;\n\t\t}\n\t\tdel_timer(&cursor_timer);\n\t\tspk_shut_up &= 0xfe;\n\t\tspk_do_flush();\n\t\tstart_read_all_timer(vc, value + 1);\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\treturn NOTIFY_STOP;\n\t}\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn NOTIFY_OK;\n}\n\nstatic void do_handle_cursor(struct vc_data *vc, u_char value, char up_flag)\n{\n\tunsigned long flags;\n\tstruct var_t *cursor_timeout;\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tspk_parked &= 0xfe;\n\tif (!synth || up_flag || spk_shut_up || cursor_track == CT_Off) {\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\treturn;\n\t}\n\tspk_shut_up &= 0xfe;\n\tif (spk_no_intr)\n\t\tspk_do_flush();\n \n\tis_cursor = value + 1;\n\told_cursor_pos = vc->vc_pos;\n\told_cursor_x = vc->state.x;\n\told_cursor_y = vc->state.y;\n\tspeakup_console[vc->vc_num]->ht.cy = vc->state.y;\n\tcursor_con = vc->vc_num;\n\tif (cursor_track == CT_Highlight)\n\t\treset_highlight_buffers(vc);\n\tcursor_timeout = spk_get_var(CURSOR_TIME);\n\tmod_timer(&cursor_timer,\n\t\t  jiffies + msecs_to_jiffies(cursor_timeout->u.n.value));\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n}\n\nstatic void update_color_buffer(struct vc_data *vc, const u16 *ic, int len)\n{\n\tint i, bi, hi;\n\tint vc_num = vc->vc_num;\n\n\tbi = (vc->vc_attr & 0x70) >> 4;\n\thi = speakup_console[vc_num]->ht.highsize[bi];\n\n\ti = 0;\n\tif (speakup_console[vc_num]->ht.highsize[bi] == 0) {\n\t\tspeakup_console[vc_num]->ht.rpos[bi] = vc->vc_pos;\n\t\tspeakup_console[vc_num]->ht.rx[bi] = vc->state.x;\n\t\tspeakup_console[vc_num]->ht.ry[bi] = vc->state.y;\n\t}\n\twhile ((hi < COLOR_BUFFER_SIZE) && (i < len)) {\n\t\tif (ic[i] > 32) {\n\t\t\tspeakup_console[vc_num]->ht.highbuf[bi][hi] = ic[i];\n\t\t\thi++;\n\t\t} else if ((ic[i] == 32) && (hi != 0)) {\n\t\t\tif (speakup_console[vc_num]->ht.highbuf[bi][hi - 1] !=\n\t\t\t    32) {\n\t\t\t\tspeakup_console[vc_num]->ht.highbuf[bi][hi] =\n\t\t\t\t    ic[i];\n\t\t\t\thi++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tspeakup_console[vc_num]->ht.highsize[bi] = hi;\n}\n\nstatic void reset_highlight_buffers(struct vc_data *vc)\n{\n\tint i;\n\tint vc_num = vc->vc_num;\n\n\tfor (i = 0; i < 8; i++)\n\t\tspeakup_console[vc_num]->ht.highsize[i] = 0;\n}\n\nstatic int count_highlight_color(struct vc_data *vc)\n{\n\tint i, bg;\n\tint cc;\n\tint vc_num = vc->vc_num;\n\tu16 ch;\n\tu16 *start = (u16 *)vc->vc_origin;\n\n\tfor (i = 0; i < 8; i++)\n\t\tspeakup_console[vc_num]->ht.bgcount[i] = 0;\n\n\tfor (i = 0; i < vc->vc_rows; i++) {\n\t\tu16 *end = start + vc->vc_cols * 2;\n\t\tu16 *ptr;\n\n\t\tfor (ptr = start; ptr < end; ptr++) {\n\t\t\tch = get_attributes(vc, ptr);\n\t\t\tbg = (ch & 0x70) >> 4;\n\t\t\tspeakup_console[vc_num]->ht.bgcount[bg]++;\n\t\t}\n\t\tstart += vc->vc_size_row;\n\t}\n\n\tcc = 0;\n\tfor (i = 0; i < 8; i++)\n\t\tif (speakup_console[vc_num]->ht.bgcount[i] > 0)\n\t\t\tcc++;\n\treturn cc;\n}\n\nstatic int get_highlight_color(struct vc_data *vc)\n{\n\tint i, j;\n\tunsigned int cptr[8];\n\tint vc_num = vc->vc_num;\n\n\tfor (i = 0; i < 8; i++)\n\t\tcptr[i] = i;\n\n\tfor (i = 0; i < 7; i++)\n\t\tfor (j = i + 1; j < 8; j++)\n\t\t\tif (speakup_console[vc_num]->ht.bgcount[cptr[i]] >\n\t\t\t    speakup_console[vc_num]->ht.bgcount[cptr[j]])\n\t\t\t\tswap(cptr[i], cptr[j]);\n\n\tfor (i = 0; i < 8; i++)\n\t\tif (speakup_console[vc_num]->ht.bgcount[cptr[i]] != 0)\n\t\t\tif (speakup_console[vc_num]->ht.highsize[cptr[i]] > 0)\n\t\t\t\treturn cptr[i];\n\treturn -1;\n}\n\nstatic int speak_highlight(struct vc_data *vc)\n{\n\tint hc, d;\n\tint vc_num = vc->vc_num;\n\n\tif (count_highlight_color(vc) == 1)\n\t\treturn 0;\n\thc = get_highlight_color(vc);\n\tif (hc != -1) {\n\t\td = vc->state.y - speakup_console[vc_num]->ht.cy;\n\t\tif ((d == 1) || (d == -1))\n\t\t\tif (speakup_console[vc_num]->ht.ry[hc] != vc->state.y)\n\t\t\t\treturn 0;\n\t\tspk_parked |= 0x01;\n\t\tspk_do_flush();\n\t\tspkup_write(speakup_console[vc_num]->ht.highbuf[hc],\n\t\t\t    speakup_console[vc_num]->ht.highsize[hc]);\n\t\tspk_pos = spk_cp = speakup_console[vc_num]->ht.rpos[hc];\n\t\tspk_x = spk_cx = speakup_console[vc_num]->ht.rx[hc];\n\t\tspk_y = spk_cy = speakup_console[vc_num]->ht.ry[hc];\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void cursor_done(struct timer_list *unused)\n{\n\tstruct vc_data *vc = vc_cons[cursor_con].d;\n\tunsigned long flags;\n\n\tdel_timer(&cursor_timer);\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tif (cursor_con != fg_console) {\n\t\tis_cursor = 0;\n\t\tgoto out;\n\t}\n\tspeakup_date(vc);\n\tif (win_enabled) {\n\t\tif (vc->state.x >= win_left && vc->state.x <= win_right &&\n\t\t    vc->state.y >= win_top && vc->state.y <= win_bottom) {\n\t\t\tspk_keydown = 0;\n\t\t\tis_cursor = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (cursor_track == read_all_mode) {\n\t\thandle_cursor_read_all(vc, read_all_key);\n\t\tgoto out;\n\t}\n\tif (cursor_track == CT_Highlight) {\n\t\tif (speak_highlight(vc)) {\n\t\t\tspk_keydown = 0;\n\t\t\tis_cursor = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (cursor_track == CT_Window)\n\t\tspeakup_win_say(vc);\n\telse if (is_cursor == 1 || is_cursor == 4)\n\t\tsay_line_from_to(vc, 0, vc->vc_cols, 0);\n\telse {\n\t\tif (spk_cur_phonetic == 1)\n\t\t\tsay_phonetic_char(vc);\n\t\telse\n\t\t\tsay_char(vc);\n\t}\n\tspk_keydown = 0;\n\tis_cursor = 0;\nout:\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n}\n\n \nstatic void speakup_bs(struct vc_data *vc)\n{\n\tunsigned long flags;\n\n\tif (!speakup_console[vc->vc_num])\n\t\treturn;\n\tif (!spin_trylock_irqsave(&speakup_info.spinlock, flags))\n\t\t \n\t\treturn;\n\tif (!spk_parked)\n\t\tspeakup_date(vc);\n\tif (spk_shut_up || !synth) {\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\treturn;\n\t}\n\tif (vc->vc_num == fg_console && spk_keydown) {\n\t\tspk_keydown = 0;\n\t\tif (!is_cursor)\n\t\t\tsay_char(vc);\n\t}\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n}\n\n \nstatic void speakup_con_write(struct vc_data *vc, u16 *str, int len)\n{\n\tunsigned long flags;\n\n\tif ((vc->vc_num != fg_console) || spk_shut_up || !synth)\n\t\treturn;\n\tif (!spin_trylock_irqsave(&speakup_info.spinlock, flags))\n\t\t \n\t\treturn;\n\tif (spk_bell_pos && spk_keydown && (vc->state.x == spk_bell_pos - 1))\n\t\tbleep(3);\n\tif ((is_cursor) || (cursor_track == read_all_mode)) {\n\t\tif (cursor_track == CT_Highlight)\n\t\t\tupdate_color_buffer(vc, str, len);\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\treturn;\n\t}\n\tif (win_enabled) {\n\t\tif (vc->state.x >= win_left && vc->state.x <= win_right &&\n\t\t    vc->state.y >= win_top && vc->state.y <= win_bottom) {\n\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tspkup_write(str, len);\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n}\n\nstatic void speakup_con_update(struct vc_data *vc)\n{\n\tunsigned long flags;\n\n\tif (!speakup_console[vc->vc_num] || spk_parked || !synth)\n\t\treturn;\n\tif (!spin_trylock_irqsave(&speakup_info.spinlock, flags))\n\t\t \n\t\treturn;\n\tspeakup_date(vc);\n\tif (vc->vc_mode == KD_GRAPHICS && !spk_paused && spk_str_pause[0]) {\n\t\tsynth_printf(\"%s\", spk_str_pause);\n\t\tspk_paused = true;\n\t}\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n}\n\nstatic void do_handle_spec(struct vc_data *vc, u_char value, char up_flag)\n{\n\tunsigned long flags;\n\tint on_off = 2;\n\tchar *label;\n\n\tif (!synth || up_flag || spk_killed)\n\t\treturn;\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tspk_shut_up &= 0xfe;\n\tif (spk_no_intr)\n\t\tspk_do_flush();\n\tswitch (value) {\n\tcase KVAL(K_CAPS):\n\t\tlabel = spk_msg_get(MSG_KEYNAME_CAPSLOCK);\n\t\ton_off = vt_get_leds(fg_console, VC_CAPSLOCK);\n\t\tbreak;\n\tcase KVAL(K_NUM):\n\t\tlabel = spk_msg_get(MSG_KEYNAME_NUMLOCK);\n\t\ton_off = vt_get_leds(fg_console, VC_NUMLOCK);\n\t\tbreak;\n\tcase KVAL(K_HOLD):\n\t\tlabel = spk_msg_get(MSG_KEYNAME_SCROLLLOCK);\n\t\ton_off = vt_get_leds(fg_console, VC_SCROLLOCK);\n\t\tif (speakup_console[vc->vc_num])\n\t\t\tspeakup_console[vc->vc_num]->tty_stopped = on_off;\n\t\tbreak;\n\tdefault:\n\t\tspk_parked &= 0xfe;\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\treturn;\n\t}\n\tif (on_off < 2)\n\t\tsynth_printf(\"%s %s\\n\",\n\t\t\t     label, spk_msg_get(MSG_STATUS_START + on_off));\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n}\n\nstatic int inc_dec_var(u_char value)\n{\n\tstruct st_var_header *p_header;\n\tstruct var_t *var_data;\n\tchar num_buf[32];\n\tchar *cp = num_buf;\n\tchar *pn;\n\tint var_id = (int)value - VAR_START;\n\tint how = (var_id & 1) ? E_INC : E_DEC;\n\n\tvar_id = var_id / 2 + FIRST_SET_VAR;\n\tp_header = spk_get_var_header(var_id);\n\tif (!p_header)\n\t\treturn -1;\n\tif (p_header->var_type != VAR_NUM)\n\t\treturn -1;\n\tvar_data = p_header->data;\n\tif (spk_set_num_var(1, p_header, how) != 0)\n\t\treturn -1;\n\tif (!spk_close_press) {\n\t\tfor (pn = p_header->name; *pn; pn++) {\n\t\t\tif (*pn == '_')\n\t\t\t\t*cp = SPACE;\n\t\t\telse\n\t\t\t\t*cp++ = *pn;\n\t\t}\n\t}\n\tsnprintf(cp, sizeof(num_buf) - (cp - num_buf), \" %d \",\n\t\t var_data->u.n.value);\n\tsynth_printf(\"%s\", num_buf);\n\treturn 0;\n}\n\nstatic void speakup_win_set(struct vc_data *vc)\n{\n\tchar info[40];\n\n\tif (win_start > 1) {\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_WINDOW_ALREADY_SET));\n\t\treturn;\n\t}\n\tif (spk_x < win_left || spk_y < win_top) {\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_END_BEFORE_START));\n\t\treturn;\n\t}\n\tif (win_start && spk_x == win_left && spk_y == win_top) {\n\t\twin_left = 0;\n\t\twin_right = vc->vc_cols - 1;\n\t\twin_bottom = spk_y;\n\t\tsnprintf(info, sizeof(info), spk_msg_get(MSG_WINDOW_LINE),\n\t\t\t (int)win_top + 1);\n\t} else {\n\t\tif (!win_start) {\n\t\t\twin_top = spk_y;\n\t\t\twin_left = spk_x;\n\t\t} else {\n\t\t\twin_bottom = spk_y;\n\t\t\twin_right = spk_x;\n\t\t}\n\t\tsnprintf(info, sizeof(info), spk_msg_get(MSG_WINDOW_BOUNDARY),\n\t\t\t (win_start) ?\n\t\t\t\tspk_msg_get(MSG_END) : spk_msg_get(MSG_START),\n\t\t\t (int)spk_y + 1, (int)spk_x + 1);\n\t}\n\tsynth_printf(\"%s\\n\", info);\n\twin_start++;\n}\n\nstatic void speakup_win_clear(struct vc_data *vc)\n{\n\twin_top = 0;\n\twin_bottom = 0;\n\twin_left = 0;\n\twin_right = 0;\n\twin_start = 0;\n\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_WINDOW_CLEARED));\n}\n\nstatic void speakup_win_enable(struct vc_data *vc)\n{\n\tif (win_start < 2) {\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_NO_WINDOW));\n\t\treturn;\n\t}\n\twin_enabled ^= 1;\n\tif (win_enabled)\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_WINDOW_SILENCED));\n\telse\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_WINDOW_SILENCE_DISABLED));\n}\n\nstatic void speakup_bits(struct vc_data *vc)\n{\n\tint val = this_speakup_key - (FIRST_EDIT_BITS - 1);\n\n\tif (spk_special_handler || val < 1 || val > 6) {\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_ERROR));\n\t\treturn;\n\t}\n\tpb_edit = &spk_punc_info[val];\n\tsynth_printf(spk_msg_get(MSG_EDIT_PROMPT), pb_edit->name);\n\tspk_special_handler = edit_bits;\n}\n\nstatic int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)\n{\n\tstatic u_char goto_buf[8];\n\tstatic int num;\n\tint maxlen;\n\tchar *cp;\n\tu16 wch;\n\n\tif (type == KT_SPKUP && ch == SPEAKUP_GOTO)\n\t\tgoto do_goto;\n\tif (type == KT_LATIN && ch == '\\n')\n\t\tgoto do_goto;\n\tif (type != 0)\n\t\tgoto oops;\n\tif (ch == 8) {\n\t\tu16 wch;\n\n\t\tif (num == 0)\n\t\t\treturn -1;\n\t\twch = goto_buf[--num];\n\t\tgoto_buf[num] = '\\0';\n\t\tspkup_write(&wch, 1);\n\t\treturn 1;\n\t}\n\tif (ch < '+' || ch > 'y')\n\t\tgoto oops;\n\twch = ch;\n\tgoto_buf[num++] = ch;\n\tgoto_buf[num] = '\\0';\n\tspkup_write(&wch, 1);\n\tmaxlen = (*goto_buf >= '0') ? 3 : 4;\n\tif ((ch == '+' || ch == '-') && num == 1)\n\t\treturn 1;\n\tif (ch >= '0' && ch <= '9' && num < maxlen)\n\t\treturn 1;\n\tif (num < maxlen - 1 || num > maxlen)\n\t\tgoto oops;\n\tif (ch < 'x' || ch > 'y') {\noops:\n\t\tif (!spk_killed)\n\t\t\tsynth_printf(\" %s\\n\", spk_msg_get(MSG_GOTO_CANCELED));\n\t\tgoto_buf[num = 0] = '\\0';\n\t\tspk_special_handler = NULL;\n\t\treturn 1;\n\t}\n\n\t \n\tgoto_pos = simple_strtoul(goto_buf, &cp, 10);\n\n\tif (*cp == 'x') {\n\t\tif (*goto_buf < '0')\n\t\t\tgoto_pos += spk_x;\n\t\telse if (goto_pos > 0)\n\t\t\tgoto_pos--;\n\n\t\tif (goto_pos >= vc->vc_cols)\n\t\t\tgoto_pos = vc->vc_cols - 1;\n\t\tgoto_x = 1;\n\t} else {\n\t\tif (*goto_buf < '0')\n\t\t\tgoto_pos += spk_y;\n\t\telse if (goto_pos > 0)\n\t\t\tgoto_pos--;\n\n\t\tif (goto_pos >= vc->vc_rows)\n\t\t\tgoto_pos = vc->vc_rows - 1;\n\t\tgoto_x = 0;\n\t}\n\tgoto_buf[num = 0] = '\\0';\ndo_goto:\n\tspk_special_handler = NULL;\n\tspk_parked |= 0x01;\n\tif (goto_x) {\n\t\tspk_pos -= spk_x * 2;\n\t\tspk_x = goto_pos;\n\t\tspk_pos += goto_pos * 2;\n\t\tsay_word(vc);\n\t} else {\n\t\tspk_y = goto_pos;\n\t\tspk_pos = vc->vc_origin + (goto_pos * vc->vc_size_row);\n\t\tsay_line(vc);\n\t}\n\treturn 1;\n}\n\nstatic void speakup_goto(struct vc_data *vc)\n{\n\tif (spk_special_handler) {\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_ERROR));\n\t\treturn;\n\t}\n\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_GOTO));\n\tspk_special_handler = handle_goto;\n}\n\nstatic void speakup_help(struct vc_data *vc)\n{\n\tspk_handle_help(vc, KT_SPKUP, SPEAKUP_HELP, 0);\n}\n\nstatic void do_nothing(struct vc_data *vc)\n{\n\treturn;\t\t\t \n}\n\nstatic u_char key_speakup, spk_key_locked;\n\nstatic void speakup_lock(struct vc_data *vc)\n{\n\tif (!spk_key_locked) {\n\t\tspk_key_locked = 16;\n\t\tkey_speakup = 16;\n\t} else {\n\t\tspk_key_locked = 0;\n\t\tkey_speakup = 0;\n\t}\n}\n\ntypedef void (*spkup_hand) (struct vc_data *);\nstatic spkup_hand spkup_handler[] = {\n\t \n\tdo_nothing, speakup_goto, speech_kill, speakup_shut_up,\n\tspeakup_cut, speakup_paste, say_first_char, say_last_char,\n\tsay_char, say_prev_char, say_next_char,\n\tsay_word, say_prev_word, say_next_word,\n\tsay_line, say_prev_line, say_next_line,\n\ttop_edge, bottom_edge, left_edge, right_edge,\n\tspell_word, spell_word, say_screen,\n\tsay_position, say_attributes,\n\tspeakup_off, speakup_parked, say_line,\t \n\tsay_from_top, say_to_bottom,\n\tsay_from_left, say_to_right,\n\tsay_char_num, speakup_bits, speakup_bits, say_phonetic_char,\n\tspeakup_bits, speakup_bits, speakup_bits,\n\tspeakup_win_set, speakup_win_clear, speakup_win_enable, speakup_win_say,\n\tspeakup_lock, speakup_help, toggle_cursoring, read_all_doc, NULL\n};\n\nstatic void do_spkup(struct vc_data *vc, u_char value)\n{\n\tif (spk_killed && value != SPEECH_KILL)\n\t\treturn;\n\tspk_keydown = 0;\n\tspk_lastkey = 0;\n\tspk_shut_up &= 0xfe;\n\tthis_speakup_key = value;\n\tif (value < SPKUP_MAX_FUNC && spkup_handler[value]) {\n\t\tspk_do_flush();\n\t\t(*spkup_handler[value]) (vc);\n\t} else {\n\t\tif (inc_dec_var(value) < 0)\n\t\t\tbleep(9);\n\t}\n}\n\nstatic const char *pad_chars = \"0123456789+-*/\\015,.?()\";\n\nstatic int\nspeakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,\n\t    int up_flag)\n{\n\tunsigned long flags;\n\tint kh;\n\tu_char *key_info;\n\tu_char type = KTYP(keysym), value = KVAL(keysym), new_key = 0;\n\tu_char shift_info, offset;\n\tint ret = 0;\n\n\tif (!synth)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\ttty = vc->port.tty;\n\tif (type >= 0xf0)\n\t\ttype -= 0xf0;\n\tif (type == KT_PAD &&\n\t    (vt_get_leds(fg_console, VC_NUMLOCK))) {\n\t\tif (up_flag) {\n\t\t\tspk_keydown = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tvalue = pad_chars[value];\n\t\tspk_lastkey = value;\n\t\tspk_keydown++;\n\t\tspk_parked &= 0xfe;\n\t\tgoto no_map;\n\t}\n\tif (keycode >= MAX_KEY)\n\t\tgoto no_map;\n\tkey_info = spk_our_keys[keycode];\n\tif (!key_info)\n\t\tgoto no_map;\n\t \n\tif ((cursor_track == read_all_mode) && (!up_flag)) {\n\t\tswitch (value) {\n\t\tcase KVAL(K_DOWN):\n\t\tcase KVAL(K_UP):\n\t\tcase KVAL(K_LEFT):\n\t\tcase KVAL(K_RIGHT):\n\t\tcase KVAL(K_PGUP):\n\t\tcase KVAL(K_PGDN):\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstop_read_all(vc);\n\t\t\tbreak;\n\t\t}\n\t}\n\tshift_info = (shift_state & 0x0f) + key_speakup;\n\toffset = spk_shift_table[shift_info];\n\tif (offset) {\n\t\tnew_key = key_info[offset];\n\t\tif (new_key) {\n\t\t\tret = 1;\n\t\t\tif (new_key == SPK_KEY) {\n\t\t\t\tif (!spk_key_locked)\n\t\t\t\t\tkey_speakup = (up_flag) ? 0 : 16;\n\t\t\t\tif (up_flag || spk_killed)\n\t\t\t\t\tgoto out;\n\t\t\t\tspk_shut_up &= 0xfe;\n\t\t\t\tspk_do_flush();\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (up_flag)\n\t\t\t\tgoto out;\n\t\t\tif (last_keycode == keycode &&\n\t\t\t    time_after(last_spk_jiffy + MAX_DELAY, jiffies)) {\n\t\t\t\tspk_close_press = 1;\n\t\t\t\toffset = spk_shift_table[shift_info + 32];\n\t\t\t\t \n\t\t\t\tif (offset && key_info[offset])\n\t\t\t\t\tnew_key = key_info[offset];\n\t\t\t}\n\t\t\tlast_keycode = keycode;\n\t\t\tlast_spk_jiffy = jiffies;\n\t\t\ttype = KT_SPKUP;\n\t\t\tvalue = new_key;\n\t\t}\n\t}\nno_map:\n\tif (type == KT_SPKUP && !spk_special_handler) {\n\t\tdo_spkup(vc, new_key);\n\t\tspk_close_press = 0;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tif (up_flag || spk_killed || type == KT_SHIFT)\n\t\tgoto out;\n\tspk_shut_up &= 0xfe;\n\tkh = (value == KVAL(K_DOWN)) ||\n\t    (value == KVAL(K_UP)) ||\n\t    (value == KVAL(K_LEFT)) ||\n\t    (value == KVAL(K_RIGHT));\n\tif ((cursor_track != read_all_mode) || !kh)\n\t\tif (!spk_no_intr)\n\t\t\tspk_do_flush();\n\tif (spk_special_handler) {\n\t\tif (type == KT_SPEC && value == 1) {\n\t\t\tvalue = '\\n';\n\t\t\ttype = KT_LATIN;\n\t\t} else if (type == KT_LETTER) {\n\t\t\ttype = KT_LATIN;\n\t\t} else if (value == 0x7f) {\n\t\t\tvalue = 8;\t \n\t\t}\n\t\tret = (*spk_special_handler) (vc, type, value, keycode);\n\t\tspk_close_press = 0;\n\t\tif (ret < 0)\n\t\t\tbleep(9);\n\t\tgoto out;\n\t}\n\tlast_keycode = 0;\nout:\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn ret;\n}\n\nstatic int keyboard_notifier_call(struct notifier_block *nb,\n\t\t\t\t  unsigned long code, void *_param)\n{\n\tstruct keyboard_notifier_param *param = _param;\n\tstruct vc_data *vc = param->vc;\n\tint up = !param->down;\n\tint ret = NOTIFY_OK;\n\tstatic int keycode;\t \n\n\tin_keyboard_notifier = 1;\n\n\tif (vc->vc_mode == KD_GRAPHICS)\n\t\tgoto out;\n\n\t \n\n\tif (speakup_fake_key_pressed())\n\t\tgoto out;\n\n\tswitch (code) {\n\tcase KBD_KEYCODE:\n\t\t \n\t\tkeycode = param->value;\n\t\tbreak;\n\tcase KBD_UNBOUND_KEYCODE:\n\t\t \n\t\tbreak;\n\tcase KBD_UNICODE:\n\t\t \n\t\tbreak;\n\tcase KBD_KEYSYM:\n\t\tif (speakup_key(vc, param->shift, keycode, param->value, up))\n\t\t\tret = NOTIFY_STOP;\n\t\telse if (KTYP(param->value) == KT_CUR)\n\t\t\tret = pre_handle_cursor(vc, KVAL(param->value), up);\n\t\tbreak;\n\tcase KBD_POST_KEYSYM:{\n\t\t\tunsigned char type = KTYP(param->value) - 0xf0;\n\t\t\tunsigned char val = KVAL(param->value);\n\n\t\t\tswitch (type) {\n\t\t\tcase KT_SHIFT:\n\t\t\t\tdo_handle_shift(vc, val, up);\n\t\t\t\tbreak;\n\t\t\tcase KT_LATIN:\n\t\t\tcase KT_LETTER:\n\t\t\t\tdo_handle_latin(vc, val, up);\n\t\t\t\tbreak;\n\t\t\tcase KT_CUR:\n\t\t\t\tdo_handle_cursor(vc, val, up);\n\t\t\t\tbreak;\n\t\t\tcase KT_SPEC:\n\t\t\t\tdo_handle_spec(vc, val, up);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tin_keyboard_notifier = 0;\n\treturn ret;\n}\n\nstatic int vt_notifier_call(struct notifier_block *nb,\n\t\t\t    unsigned long code, void *_param)\n{\n\tstruct vt_notifier_param *param = _param;\n\tstruct vc_data *vc = param->vc;\n\n\tswitch (code) {\n\tcase VT_ALLOCATE:\n\t\tif (vc->vc_mode == KD_TEXT)\n\t\t\tspeakup_allocate(vc, GFP_ATOMIC);\n\t\tbreak;\n\tcase VT_DEALLOCATE:\n\t\tspeakup_deallocate(vc);\n\t\tbreak;\n\tcase VT_WRITE:\n\t\tif (param->c == '\\b') {\n\t\t\tspeakup_bs(vc);\n\t\t} else {\n\t\t\tu16 d = param->c;\n\n\t\t\tspeakup_con_write(vc, &d, 1);\n\t\t}\n\t\tbreak;\n\tcase VT_UPDATE:\n\t\tspeakup_con_update(vc);\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\n \nstatic void __exit speakup_exit(void)\n{\n\tint i;\n\n\tunregister_keyboard_notifier(&keyboard_notifier_block);\n\tunregister_vt_notifier(&vt_notifier_block);\n\tspeakup_unregister_devsynth();\n\tspeakup_cancel_selection();\n\tspeakup_cancel_paste();\n\tdel_timer_sync(&cursor_timer);\n\tkthread_stop(speakup_task);\n\tspeakup_task = NULL;\n\tmutex_lock(&spk_mutex);\n\tsynth_release();\n\tmutex_unlock(&spk_mutex);\n\tspk_ttyio_unregister_ldisc();\n\n\tspeakup_kobj_exit();\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++)\n\t\tkfree(speakup_console[i]);\n\n\tspeakup_remove_virtual_keyboard();\n\n\tfor (i = 0; i < MAXVARS; i++)\n\t\tspeakup_unregister_var(i);\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (spk_characters[i] != spk_default_chars[i])\n\t\t\tkfree(spk_characters[i]);\n\t}\n\n\tspk_free_user_msgs();\n}\n\n \nstatic int __init speakup_init(void)\n{\n\tint i;\n\tlong err = 0;\n\tstruct vc_data *vc = vc_cons[fg_console].d;\n\tstruct var_t *var;\n\n\t \n\tspk_initialize_msgs();\t \n\tspk_reset_default_chars();\n\tspk_reset_default_chartab();\n\tspk_strlwr(synth_name);\n\tspk_vars[0].u.n.high = vc->vc_cols;\n\tfor (var = spk_vars; var->var_id != MAXVARS; var++)\n\t\tspeakup_register_var(var);\n\tfor (var = synth_time_vars;\n\t     (var->var_id >= 0) && (var->var_id < MAXVARS); var++)\n\t\tspeakup_register_var(var);\n\tfor (i = 1; spk_punc_info[i].mask != 0; i++)\n\t\tspk_set_mask_bits(NULL, i, 2);\n\n\tspk_set_key_info(spk_key_defaults, spk_key_buf);\n\n\t \n\terr = speakup_add_virtual_keyboard();\n\tif (err)\n\t\tgoto error_virtkeyboard;\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++)\n\t\tif (vc_cons[i].d) {\n\t\t\terr = speakup_allocate(vc_cons[i].d, GFP_KERNEL);\n\t\t\tif (err)\n\t\t\t\tgoto error_kobjects;\n\t\t}\n\n\tif (spk_quiet_boot)\n\t\tspk_shut_up |= 0x01;\n\n\terr = speakup_kobj_init();\n\tif (err)\n\t\tgoto error_kobjects;\n\n\tspk_ttyio_register_ldisc();\n\tsynth_init(synth_name);\n\tspeakup_register_devsynth();\n\t \n\n\terr = register_keyboard_notifier(&keyboard_notifier_block);\n\tif (err)\n\t\tgoto error_kbdnotifier;\n\terr = register_vt_notifier(&vt_notifier_block);\n\tif (err)\n\t\tgoto error_vtnotifier;\n\n\tspeakup_task = kthread_create(speakup_thread, NULL, \"speakup\");\n\n\tif (IS_ERR(speakup_task)) {\n\t\terr = PTR_ERR(speakup_task);\n\t\tgoto error_task;\n\t}\n\n\tset_user_nice(speakup_task, 10);\n\twake_up_process(speakup_task);\n\n\tpr_info(\"speakup %s: initialized\\n\", SPEAKUP_VERSION);\n\tpr_info(\"synth name on entry is: %s\\n\", synth_name);\n\tgoto out;\n\nerror_task:\n\tunregister_vt_notifier(&vt_notifier_block);\n\nerror_vtnotifier:\n\tunregister_keyboard_notifier(&keyboard_notifier_block);\n\tdel_timer(&cursor_timer);\n\nerror_kbdnotifier:\n\tspeakup_unregister_devsynth();\n\tmutex_lock(&spk_mutex);\n\tsynth_release();\n\tmutex_unlock(&spk_mutex);\n\tspeakup_kobj_exit();\n\nerror_kobjects:\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++)\n\t\tkfree(speakup_console[i]);\n\n\tspeakup_remove_virtual_keyboard();\n\nerror_virtkeyboard:\n\tfor (i = 0; i < MAXVARS; i++)\n\t\tspeakup_unregister_var(i);\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (spk_characters[i] != spk_default_chars[i])\n\t\t\tkfree(spk_characters[i]);\n\t}\n\n\tspk_free_user_msgs();\n\nout:\n\treturn err;\n}\n\nmodule_param_named(bell_pos, spk_vars[BELL_POS_ID].u.n.default_val, int, 0444);\nmodule_param_named(spell_delay, spk_vars[SPELL_DELAY_ID].u.n.default_val, int, 0444);\nmodule_param_named(attrib_bleep, spk_vars[ATTRIB_BLEEP_ID].u.n.default_val, int, 0444);\nmodule_param_named(bleeps, spk_vars[BLEEPS_ID].u.n.default_val, int, 0444);\nmodule_param_named(bleep_time, spk_vars[BLEEP_TIME_ID].u.n.default_val, int, 0444);\nmodule_param_named(punc_level, spk_vars[PUNC_LEVEL_ID].u.n.default_val, int, 0444);\nmodule_param_named(reading_punc, spk_vars[READING_PUNC_ID].u.n.default_val, int, 0444);\nmodule_param_named(cursor_time, spk_vars[CURSOR_TIME_ID].u.n.default_val, int, 0444);\nmodule_param_named(say_control, spk_vars[SAY_CONTROL_ID].u.n.default_val, int, 0444);\nmodule_param_named(say_word_ctl, spk_vars[SAY_WORD_CTL_ID].u.n.default_val, int, 0444);\nmodule_param_named(no_interrupt, spk_vars[NO_INTERRUPT_ID].u.n.default_val, int, 0444);\nmodule_param_named(key_echo, spk_vars[KEY_ECHO_ID].u.n.default_val, int, 0444);\nmodule_param_named(cur_phonetic, spk_vars[CUR_PHONETIC_ID].u.n.default_val, int, 0444);\n\nMODULE_PARM_DESC(bell_pos, \"This works much like a typewriter bell. If for example 72 is echoed to bell_pos, it will beep the PC speaker when typing on a line past character 72.\");\nMODULE_PARM_DESC(spell_delay, \"This controls how fast a word is spelled when speakup's spell word review command is pressed.\");\nMODULE_PARM_DESC(attrib_bleep, \"Beeps the PC speaker when there is an attribute change such as background color when using speakup review commands. One = on, zero = off.\");\nMODULE_PARM_DESC(bleeps, \"This controls whether one hears beeps through the PC speaker when using speakup review commands.\");\nMODULE_PARM_DESC(bleep_time, \"This controls the duration of the PC speaker beeps speakup produces.\");\nMODULE_PARM_DESC(punc_level, \"Controls the level of punctuation spoken as the screen is displayed, not reviewed.\");\nMODULE_PARM_DESC(reading_punc, \"It controls the level of punctuation when reviewing the screen with speakup's screen review commands.\");\nMODULE_PARM_DESC(cursor_time, \"This controls cursor delay when using arrow keys.\");\nMODULE_PARM_DESC(say_control, \"This controls if speakup speaks shift, alt and control when those keys are pressed or not.\");\nMODULE_PARM_DESC(say_word_ctl, \"Sets the say_word_ctl on load.\");\nMODULE_PARM_DESC(no_interrupt, \"Controls if typing interrupts output from speakup.\");\nMODULE_PARM_DESC(key_echo, \"Controls if speakup speaks keys when they are typed. One = on zero = off or don't echo keys.\");\nMODULE_PARM_DESC(cur_phonetic, \"Controls if speakup speaks letters phonetically during navigation. One = on zero = off or don't speak phonetically.\");\n\nmodule_init(speakup_init);\nmodule_exit(speakup_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}