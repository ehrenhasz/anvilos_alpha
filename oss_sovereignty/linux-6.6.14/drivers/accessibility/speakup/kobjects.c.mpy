{
  "module_name": "kobjects.c",
  "hash_id": "85fd654ed3c038e7c1ae841a29fe828114ef9aa2e2c367dec9f39dbff817f572",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/speakup/kobjects.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\t\t \n#include <linux/kernel.h>\n#include <linux/kobject.h>\n#include <linux/string.h>\n#include <linux/string_helpers.h>\n#include <linux/sysfs.h>\n#include <linux/ctype.h>\n\n#include \"speakup.h\"\n#include \"spk_priv.h\"\n\n \nstatic ssize_t chars_chartab_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\tint i;\n\tint len = 0;\n\tchar *cp;\n\tchar *buf_pointer = buf;\n\tsize_t bufsize = PAGE_SIZE;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\t*buf_pointer = '\\0';\n\tfor (i = 0; i < 256; i++) {\n\t\tif (bufsize <= 1)\n\t\t\tbreak;\n\t\tif (strcmp(\"characters\", attr->attr.name) == 0) {\n\t\t\tlen = scnprintf(buf_pointer, bufsize, \"%d\\t%s\\n\",\n\t\t\t\t\ti, spk_characters[i]);\n\t\t} else {\t \n\t\t\tif (IS_TYPE(i, B_CTL))\n\t\t\t\tcp = \"B_CTL\";\n\t\t\telse if (IS_TYPE(i, WDLM))\n\t\t\t\tcp = \"WDLM\";\n\t\t\telse if (IS_TYPE(i, A_PUNC))\n\t\t\t\tcp = \"A_PUNC\";\n\t\t\telse if (IS_TYPE(i, PUNC))\n\t\t\t\tcp = \"PUNC\";\n\t\t\telse if (IS_TYPE(i, NUM))\n\t\t\t\tcp = \"NUM\";\n\t\t\telse if (IS_TYPE(i, A_CAP))\n\t\t\t\tcp = \"A_CAP\";\n\t\t\telse if (IS_TYPE(i, ALPHA))\n\t\t\t\tcp = \"ALPHA\";\n\t\t\telse if (IS_TYPE(i, B_CAPSYM))\n\t\t\t\tcp = \"B_CAPSYM\";\n\t\t\telse if (IS_TYPE(i, B_SYM))\n\t\t\t\tcp = \"B_SYM\";\n\t\t\telse\n\t\t\t\tcp = \"0\";\n\t\t\tlen =\n\t\t\t    scnprintf(buf_pointer, bufsize, \"%d\\t%s\\n\", i, cp);\n\t\t}\n\t\tbufsize -= len;\n\t\tbuf_pointer += len;\n\t}\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn buf_pointer - buf;\n}\n\n \nstatic void report_char_chartab_status(int reset, int received, int used,\n\t\t\t\t       int rejected, int do_characters)\n{\n\tstatic char const *object_type[] = {\n\t\t\"character class entries\",\n\t\t\"character descriptions\",\n\t};\n\tint len;\n\tchar buf[80];\n\n\tif (reset) {\n\t\tpr_info(\"%s reset to defaults\\n\", object_type[do_characters]);\n\t} else if (received) {\n\t\tlen = snprintf(buf, sizeof(buf),\n\t\t\t       \" updated %d of %d %s\\n\",\n\t\t\t       used, received, object_type[do_characters]);\n\t\tif (rejected)\n\t\t\tsnprintf(buf + (len - 1), sizeof(buf) - (len - 1),\n\t\t\t\t \" with %d reject%s\\n\",\n\t\t\t\t rejected, rejected > 1 ? \"s\" : \"\");\n\t\tpr_info(\"%s\", buf);\n\t}\n}\n\n \nstatic ssize_t chars_chartab_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tchar *cp = (char *)buf;\n\tchar *end = cp + count;  \n\tchar *linefeed = NULL;\n\tchar keyword[MAX_DESC_LEN + 1];\n\tchar *outptr = NULL;\t \n\tchar *temp = NULL;\n\tchar *desc = NULL;\n\tssize_t retval = count;\n\tunsigned long flags;\n\tunsigned long index = 0;\n\tint charclass = 0;\n\tint received = 0;\n\tint used = 0;\n\tint rejected = 0;\n\tint reset = 0;\n\tint do_characters = !strcmp(attr->attr.name, \"characters\");\n\tsize_t desc_length = 0;\n\tint i;\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\twhile (cp < end) {\n\t\twhile ((cp < end) && (*cp == ' ' || *cp == '\\t'))\n\t\t\tcp++;\n\n\t\tif (cp == end)\n\t\t\tbreak;\n\t\tif ((*cp == '\\n') || strchr(\"dDrR\", *cp)) {\n\t\t\treset = 1;\n\t\t\tbreak;\n\t\t}\n\t\treceived++;\n\n\t\tlinefeed = strchr(cp, '\\n');\n\t\tif (!linefeed) {\n\t\t\trejected++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!isdigit(*cp)) {\n\t\t\trejected++;\n\t\t\tcp = linefeed + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tindex = simple_strtoul(cp, &temp, 10);\n\t\tif (index > 255) {\n\t\t\trejected++;\n\t\t\tcp = linefeed + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile ((temp < linefeed) && (*temp == ' ' || *temp == '\\t'))\n\t\t\ttemp++;\n\n\t\tdesc_length = linefeed - temp;\n\t\tif (desc_length > MAX_DESC_LEN) {\n\t\t\trejected++;\n\t\t\tcp = linefeed + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (do_characters) {\n\t\t\tdesc = kmalloc(desc_length + 1, GFP_ATOMIC);\n\t\t\tif (!desc) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\treset = 1;\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toutptr = desc;\n\t\t} else {\n\t\t\toutptr = keyword;\n\t\t}\n\n\t\tfor (i = 0; i < desc_length; i++)\n\t\t\toutptr[i] = temp[i];\n\t\toutptr[desc_length] = '\\0';\n\n\t\tif (do_characters) {\n\t\t\tif (spk_characters[index] != spk_default_chars[index])\n\t\t\t\tkfree(spk_characters[index]);\n\t\t\tspk_characters[index] = desc;\n\t\t\tused++;\n\t\t} else {\n\t\t\tcharclass = spk_chartab_get_value(keyword);\n\t\t\tif (charclass == 0) {\n\t\t\t\trejected++;\n\t\t\t\tcp = linefeed + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (charclass != spk_chartab[index]) {\n\t\t\t\tspk_chartab[index] = charclass;\n\t\t\t\tused++;\n\t\t\t}\n\t\t}\n\t\tcp = linefeed + 1;\n\t}\n\n\tif (reset) {\n\t\tif (do_characters)\n\t\t\tspk_reset_default_chars();\n\t\telse\n\t\t\tspk_reset_default_chartab();\n\t}\n\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treport_char_chartab_status(reset, received, used, rejected,\n\t\t\t\t   do_characters);\n\treturn retval;\n}\n\n \nstatic ssize_t keymap_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\tchar *cp = buf;\n\tint i;\n\tint n;\n\tint num_keys;\n\tint nstates;\n\tu_char *cp1;\n\tu_char ch;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tcp1 = spk_key_buf + SHIFT_TBL_SIZE;\n\tnum_keys = (int)(*cp1);\n\tnstates = (int)cp1[1];\n\tcp += sprintf(cp, \"%d, %d, %d,\\n\", KEY_MAP_VER, num_keys, nstates);\n\tcp1 += 2;  \n\t \n\tfor (n = 0; n <= num_keys; n++) {\n\t\tfor (i = 0; i <= nstates; i++) {\n\t\t\tch = *cp1++;\n\t\t\tcp += sprintf(cp, \"%d,\", (int)ch);\n\t\t\t*cp++ = (i < nstates) ? SPACE : '\\n';\n\t\t}\n\t}\n\tcp += sprintf(cp, \"0, %d\\n\", KEY_MAP_VER);\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn (int)(cp - buf);\n}\n\n \nstatic ssize_t keymap_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint i;\n\tssize_t ret = count;\n\tchar *in_buff = NULL;\n\tchar *cp;\n\tu_char *cp1;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tin_buff = kmemdup(buf, count + 1, GFP_ATOMIC);\n\tif (!in_buff) {\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\treturn -ENOMEM;\n\t}\n\tif (strchr(\"dDrR\", *in_buff)) {\n\t\tspk_set_key_info(spk_key_defaults, spk_key_buf);\n\t\tpr_info(\"keymap set to default values\\n\");\n\t\tkfree(in_buff);\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\treturn count;\n\t}\n\tif (in_buff[count - 1] == '\\n')\n\t\tin_buff[count - 1] = '\\0';\n\tcp = in_buff;\n\tcp1 = (u_char *)in_buff;\n\tfor (i = 0; i < 3; i++) {\n\t\tcp = spk_s2uchar(cp, cp1);\n\t\tcp1++;\n\t}\n\ti = (int)cp1[-2] + 1;\n\ti *= (int)cp1[-1] + 1;\n\ti += 2;  \n\tif (cp1[-3] != KEY_MAP_VER || cp1[-1] > 10 ||\n\t    i + SHIFT_TBL_SIZE + 4 >= sizeof(spk_key_buf)) {\n\t\tpr_warn(\"i %d %d %d %d\\n\", i,\n\t\t\t(int)cp1[-3], (int)cp1[-2], (int)cp1[-1]);\n\t\tkfree(in_buff);\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\treturn -EINVAL;\n\t}\n\twhile (--i >= 0) {\n\t\tcp = spk_s2uchar(cp, cp1);\n\t\tcp1++;\n\t\tif (!(*cp))\n\t\t\tbreak;\n\t}\n\tif (i != 0 || cp1[-1] != KEY_MAP_VER || cp1[-2] != 0) {\n\t\tret = -EINVAL;\n\t\tpr_warn(\"end %d %d %d %d\\n\", i,\n\t\t\t(int)cp1[-3], (int)cp1[-2], (int)cp1[-1]);\n\t} else {\n\t\tif (spk_set_key_info(in_buff, spk_key_buf)) {\n\t\t\tspk_set_key_info(spk_key_defaults, spk_key_buf);\n\t\t\tret = -EINVAL;\n\t\t\tpr_warn(\"set key failed\\n\");\n\t\t}\n\t}\n\tkfree(in_buff);\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn ret;\n}\n\n \nstatic ssize_t silent_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint len;\n\tstruct vc_data *vc = vc_cons[fg_console].d;\n\tchar ch = 0;\n\tchar shut;\n\tunsigned long flags;\n\n\tlen = strlen(buf);\n\tif (len > 0 && len < 3) {\n\t\tch = buf[0];\n\t\tif (ch == '\\n')\n\t\t\tch = '0';\n\t}\n\tif (ch < '0' || ch > '7') {\n\t\tpr_warn(\"silent value '%c' not in range (0,7)\\n\", ch);\n\t\treturn -EINVAL;\n\t}\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tif (ch & 2) {\n\t\tshut = 1;\n\t\tspk_do_flush();\n\t} else {\n\t\tshut = 0;\n\t}\n\tif (ch & 4)\n\t\tshut |= 0x40;\n\tif (ch & 1)\n\t\tspk_shut_up |= shut;\n\telse\n\t\tspk_shut_up &= ~shut;\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn count;\n}\n\n \nstatic ssize_t synth_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  char *buf)\n{\n\tint rv;\n\n\tif (!synth)\n\t\trv = sprintf(buf, \"%s\\n\", \"none\");\n\telse\n\t\trv = sprintf(buf, \"%s\\n\", synth->name);\n\treturn rv;\n}\n\n \nstatic ssize_t synth_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tint len;\n\tchar new_synth_name[10];\n\n\tlen = strlen(buf);\n\tif (len < 2 || len > 9)\n\t\treturn -EINVAL;\n\tmemcpy(new_synth_name, buf, len);\n\tif (new_synth_name[len - 1] == '\\n')\n\t\tlen--;\n\tnew_synth_name[len] = '\\0';\n\tspk_strlwr(new_synth_name);\n\tif (synth && !strcmp(new_synth_name, synth->name)) {\n\t\tpr_warn(\"%s already in use\\n\", new_synth_name);\n\t} else if (synth_init(new_synth_name) != 0) {\n\t\tpr_warn(\"failed to init synth %s\\n\", new_synth_name);\n\t\treturn -ENODEV;\n\t}\n\treturn count;\n}\n\n \nstatic ssize_t synth_direct_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tu_char tmp[256];\n\tint len;\n\tint bytes;\n\tconst char *ptr = buf;\n\tunsigned long flags;\n\n\tif (!synth)\n\t\treturn -EPERM;\n\n\tlen = strlen(buf);\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\twhile (len > 0) {\n\t\tbytes = min_t(size_t, len, 250);\n\t\tstrncpy(tmp, ptr, bytes);\n\t\ttmp[bytes] = '\\0';\n\t\tstring_unescape_any_inplace(tmp);\n\t\tsynth_printf(\"%s\", tmp);\n\t\tptr += bytes;\n\t\tlen -= bytes;\n\t}\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn count;\n}\n\n \nstatic ssize_t version_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    char *buf)\n{\n\tchar *cp;\n\n\tcp = buf;\n\tcp += sprintf(cp, \"Speakup version %s\\n\", SPEAKUP_VERSION);\n\tif (synth)\n\t\tcp += sprintf(cp, \"%s synthesizer driver version %s\\n\",\n\t\tsynth->name, synth->version);\n\treturn cp - buf;\n}\n\n \nstatic ssize_t punc_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t char *buf)\n{\n\tint i;\n\tchar *cp = buf;\n\tstruct st_var_header *p_header;\n\tstruct punc_var_t *var;\n\tstruct st_bits_data *pb;\n\tshort mask;\n\tunsigned long flags;\n\n\tp_header = spk_var_header_by_name(attr->attr.name);\n\tif (!p_header) {\n\t\tpr_warn(\"p_header is null, attr->attr.name is %s\\n\",\n\t\t\tattr->attr.name);\n\t\treturn -EINVAL;\n\t}\n\n\tvar = spk_get_punc_var(p_header->var_id);\n\tif (!var) {\n\t\tpr_warn(\"var is null, p_header->var_id is %i\\n\",\n\t\t\tp_header->var_id);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tpb = (struct st_bits_data *)&spk_punc_info[var->value];\n\tmask = pb->mask;\n\tfor (i = 33; i < 128; i++) {\n\t\tif (!(spk_chartab[i] & mask))\n\t\t\tcontinue;\n\t\t*cp++ = (char)i;\n\t}\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn cp - buf;\n}\n\n \nstatic ssize_t punc_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tint x;\n\tstruct st_var_header *p_header;\n\tstruct punc_var_t *var;\n\tchar punc_buf[100];\n\tunsigned long flags;\n\n\tx = strlen(buf);\n\tif (x < 1 || x > 99)\n\t\treturn -EINVAL;\n\n\tp_header = spk_var_header_by_name(attr->attr.name);\n\tif (!p_header) {\n\t\tpr_warn(\"p_header is null, attr->attr.name is %s\\n\",\n\t\t\tattr->attr.name);\n\t\treturn -EINVAL;\n\t}\n\n\tvar = spk_get_punc_var(p_header->var_id);\n\tif (!var) {\n\t\tpr_warn(\"var is null, p_header->var_id is %i\\n\",\n\t\t\tp_header->var_id);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(punc_buf, buf, x);\n\n\twhile (x && punc_buf[x - 1] == '\\n')\n\t\tx--;\n\tpunc_buf[x] = '\\0';\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\n\tif (*punc_buf == 'd' || *punc_buf == 'r')\n\t\tx = spk_set_mask_bits(NULL, var->value, 3);\n\telse\n\t\tx = spk_set_mask_bits(punc_buf, var->value, 3);\n\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn count;\n}\n\n \nssize_t spk_var_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t     char *buf)\n{\n\tint rv = 0;\n\tstruct st_var_header *param;\n\tstruct var_t *var;\n\tchar *cp1;\n\tchar *cp;\n\tchar ch;\n\tunsigned long flags;\n\n\tparam = spk_var_header_by_name(attr->attr.name);\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tvar = (struct var_t *)param->data;\n\tswitch (param->var_type) {\n\tcase VAR_NUM:\n\tcase VAR_TIME:\n\t\tif (var)\n\t\t\trv = sprintf(buf, \"%i\\n\", var->u.n.value);\n\t\telse\n\t\t\trv = sprintf(buf, \"0\\n\");\n\t\tbreak;\n\tcase VAR_STRING:\n\t\tif (var) {\n\t\t\tcp1 = buf;\n\t\t\t*cp1++ = '\"';\n\t\t\tfor (cp = (char *)param->p_val; (ch = *cp); cp++) {\n\t\t\t\tif (ch >= ' ' && ch < '~')\n\t\t\t\t\t*cp1++ = ch;\n\t\t\t\telse\n\t\t\t\t\tcp1 += sprintf(cp1, \"\\\\x%02x\", ch);\n\t\t\t}\n\t\t\t*cp1++ = '\"';\n\t\t\t*cp1++ = '\\n';\n\t\t\t*cp1 = '\\0';\n\t\t\trv = cp1 - buf;\n\t\t} else {\n\t\t\trv = sprintf(buf, \"\\\"\\\"\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trv = sprintf(buf, \"Bad parameter  %s, type %i\\n\",\n\t\t\t     param->name, param->var_type);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(spk_var_show);\n\n \nstatic inline void spk_reset_default_value(char *header_name,\n\t\t\t\t\t   int *synth_default_value, int idx)\n{\n\tstruct st_var_header *param;\n\n\tif (synth && synth_default_value) {\n\t\tparam = spk_var_header_by_name(header_name);\n\t\tif (param)  {\n\t\t\tspk_set_num_var(synth_default_value[idx],\n\t\t\t\t\tparam, E_NEW_DEFAULT);\n\t\t\tspk_set_num_var(0, param, E_DEFAULT);\n\t\t\tpr_info(\"%s reset to default value\\n\", param->name);\n\t\t}\n\t}\n}\n\n \nssize_t spk_var_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct st_var_header *param;\n\tint ret;\n\tint len;\n\tchar *cp;\n\tstruct var_t *var_data;\n\tlong value;\n\tunsigned long flags;\n\n\tparam = spk_var_header_by_name(attr->attr.name);\n\tif (!param)\n\t\treturn -EINVAL;\n\tif (!param->data)\n\t\treturn 0;\n\tret = 0;\n\tcp = (char *)buf;\n\tstring_unescape_any_inplace(cp);\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tswitch (param->var_type) {\n\tcase VAR_NUM:\n\tcase VAR_TIME:\n\t\tif (*cp == 'd' || *cp == 'r' || *cp == '\\0')\n\t\t\tlen = E_DEFAULT;\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t\tlen = E_INC;\n\t\telse\n\t\t\tlen = E_SET;\n\t\tif (kstrtol(cp, 10, &value) == 0)\n\t\t\tret = spk_set_num_var(value, param, len);\n\t\telse\n\t\t\tpr_warn(\"overflow or parsing error has occurred\");\n\t\tif (ret == -ERANGE) {\n\t\t\tvar_data = param->data;\n\t\t\tpr_warn(\"value for %s out of range, expect %d to %d\\n\",\n\t\t\t\tparam->name,\n\t\t\t\tvar_data->u.n.low, var_data->u.n.high);\n\t\t}\n\n\t        \n\t\tif (param->var_id == VOICE && synth &&\n\t\t    (ret == 0 || ret == -ERESTART)) {\n\t\t\tvar_data = param->data;\n\t\t\tvalue = var_data->u.n.value;\n\t\t\tspk_reset_default_value(\"pitch\", synth->default_pitch,\n\t\t\t\t\t\tvalue);\n\t\t\tspk_reset_default_value(\"vol\", synth->default_vol,\n\t\t\t\t\t\tvalue);\n\t\t}\n\t\tbreak;\n\tcase VAR_STRING:\n\t\tlen = strlen(cp);\n\t\tif ((len >= 1) && (cp[len - 1] == '\\n'))\n\t\t\t--len;\n\t\tif ((len >= 2) && (cp[0] == '\"') && (cp[len - 1] == '\"')) {\n\t\t\t++cp;\n\t\t\tlen -= 2;\n\t\t}\n\t\tcp[len] = '\\0';\n\t\tret = spk_set_string_var(cp, param, len);\n\t\tif (ret == -E2BIG)\n\t\t\tpr_warn(\"value too long for %s\\n\",\n\t\t\t\tparam->name);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s unknown type %d\\n\",\n\t\t\tparam->name, (int)param->var_type);\n\tbreak;\n\t}\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\n\tif (ret == -ERESTART)\n\t\tpr_info(\"%s reset to default value\\n\", param->name);\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(spk_var_store);\n\n \n\nstatic ssize_t message_show_helper(char *buf, enum msg_index_t first,\n\t\t\t\t   enum msg_index_t last)\n{\n\tsize_t bufsize = PAGE_SIZE;\n\tchar *buf_pointer = buf;\n\tint printed;\n\tenum msg_index_t cursor;\n\tint index = 0;\n\t*buf_pointer = '\\0';  \n\n\tfor (cursor = first; cursor <= last; cursor++, index++) {\n\t\tif (bufsize <= 1)\n\t\t\tbreak;\n\t\tprinted = scnprintf(buf_pointer, bufsize, \"%d\\t%s\\n\",\n\t\t\t\t    index, spk_msg_get(cursor));\n\t\tbuf_pointer += printed;\n\t\tbufsize -= printed;\n\t}\n\n\treturn buf_pointer - buf;\n}\n\nstatic void report_msg_status(int reset, int received, int used,\n\t\t\t      int rejected, char *groupname)\n{\n\tint len;\n\tchar buf[160];\n\n\tif (reset) {\n\t\tpr_info(\"i18n messages from group %s reset to defaults\\n\",\n\t\t\tgroupname);\n\t} else if (received) {\n\t\tlen = snprintf(buf, sizeof(buf),\n\t\t\t       \" updated %d of %d i18n messages from group %s\\n\",\n\t\t\t\t       used, received, groupname);\n\t\tif (rejected)\n\t\t\tsnprintf(buf + (len - 1), sizeof(buf) - (len - 1),\n\t\t\t\t \" with %d reject%s\\n\",\n\t\t\t\t rejected, rejected > 1 ? \"s\" : \"\");\n\t\tpr_info(\"%s\", buf);\n\t}\n}\n\nstatic ssize_t message_store_helper(const char *buf, size_t count,\n\t\t\t\t    struct msg_group_t *group)\n{\n\tchar *cp = (char *)buf;\n\tchar *end = cp + count;\n\tchar *linefeed = NULL;\n\tchar *temp = NULL;\n\tssize_t msg_stored = 0;\n\tssize_t retval = count;\n\tsize_t desc_length = 0;\n\tunsigned long index = 0;\n\tint received = 0;\n\tint used = 0;\n\tint rejected = 0;\n\tint reset = 0;\n\tenum msg_index_t firstmessage = group->start;\n\tenum msg_index_t lastmessage = group->end;\n\tenum msg_index_t curmessage;\n\n\twhile (cp < end) {\n\t\twhile ((cp < end) && (*cp == ' ' || *cp == '\\t'))\n\t\t\tcp++;\n\n\t\tif (cp == end)\n\t\t\tbreak;\n\t\tif (strchr(\"dDrR\", *cp)) {\n\t\t\treset = 1;\n\t\t\tbreak;\n\t\t}\n\t\treceived++;\n\n\t\tlinefeed = strchr(cp, '\\n');\n\t\tif (!linefeed) {\n\t\t\trejected++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!isdigit(*cp)) {\n\t\t\trejected++;\n\t\t\tcp = linefeed + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tindex = simple_strtoul(cp, &temp, 10);\n\n\t\twhile ((temp < linefeed) && (*temp == ' ' || *temp == '\\t'))\n\t\t\ttemp++;\n\n\t\tdesc_length = linefeed - temp;\n\t\tcurmessage = firstmessage + index;\n\n\t\t \n\n\t\tif ((curmessage < firstmessage) || (curmessage > lastmessage)) {\n\t\t\trejected++;\n\t\t\tcp = linefeed + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmsg_stored = spk_msg_set(curmessage, temp, desc_length);\n\t\tif (msg_stored < 0) {\n\t\t\tretval = msg_stored;\n\t\t\tif (msg_stored == -ENOMEM)\n\t\t\t\treset = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tused++;\n\n\t\tcp = linefeed + 1;\n\t}\n\n\tif (reset)\n\t\tspk_reset_msg_group(group);\n\n\treport_msg_status(reset, received, used, rejected, group->name);\n\treturn retval;\n}\n\nstatic ssize_t message_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\tssize_t retval = 0;\n\tstruct msg_group_t *group = spk_find_msg_group(attr->attr.name);\n\tunsigned long flags;\n\n\tif (WARN_ON(!group))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tretval = message_show_helper(buf, group->start, group->end);\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn retval;\n}\n\nstatic ssize_t message_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct msg_group_t *group = spk_find_msg_group(attr->attr.name);\n\n\tif (WARN_ON(!group))\n\t\treturn -EINVAL;\n\n\treturn message_store_helper(buf, count, group);\n}\n\n \nstatic struct kobj_attribute keymap_attribute =\n\t__ATTR_RW(keymap);\nstatic struct kobj_attribute silent_attribute =\n\t__ATTR_WO(silent);\nstatic struct kobj_attribute synth_attribute =\n\t__ATTR_RW(synth);\nstatic struct kobj_attribute synth_direct_attribute =\n\t__ATTR_WO(synth_direct);\nstatic struct kobj_attribute version_attribute =\n\t__ATTR_RO(version);\n\nstatic struct kobj_attribute delimiters_attribute =\n\t__ATTR(delimiters, 0644, punc_show, punc_store);\nstatic struct kobj_attribute ex_num_attribute =\n\t__ATTR(ex_num, 0644, punc_show, punc_store);\nstatic struct kobj_attribute punc_all_attribute =\n\t__ATTR(punc_all, 0644, punc_show, punc_store);\nstatic struct kobj_attribute punc_most_attribute =\n\t__ATTR(punc_most, 0644, punc_show, punc_store);\nstatic struct kobj_attribute punc_some_attribute =\n\t__ATTR(punc_some, 0644, punc_show, punc_store);\nstatic struct kobj_attribute repeats_attribute =\n\t__ATTR(repeats, 0644, punc_show, punc_store);\n\nstatic struct kobj_attribute attrib_bleep_attribute =\n\t__ATTR(attrib_bleep, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute bell_pos_attribute =\n\t__ATTR(bell_pos, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute bleep_time_attribute =\n\t__ATTR(bleep_time, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute bleeps_attribute =\n\t__ATTR(bleeps, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute cursor_time_attribute =\n\t__ATTR(cursor_time, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute key_echo_attribute =\n\t__ATTR(key_echo, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute no_interrupt_attribute =\n\t__ATTR(no_interrupt, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute punc_level_attribute =\n\t__ATTR(punc_level, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute reading_punc_attribute =\n\t__ATTR(reading_punc, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute say_control_attribute =\n\t__ATTR(say_control, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute say_word_ctl_attribute =\n\t__ATTR(say_word_ctl, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute spell_delay_attribute =\n\t__ATTR(spell_delay, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute cur_phonetic_attribute =\n\t__ATTR(cur_phonetic, 0644, spk_var_show, spk_var_store);\n\n \nstatic struct kobj_attribute announcements_attribute =\n\t__ATTR(announcements, 0644, message_show, message_store);\nstatic struct kobj_attribute characters_attribute =\n\t__ATTR(characters, 0644, chars_chartab_show,\n\t       chars_chartab_store);\nstatic struct kobj_attribute chartab_attribute =\n\t__ATTR(chartab, 0644, chars_chartab_show,\n\t       chars_chartab_store);\nstatic struct kobj_attribute ctl_keys_attribute =\n\t__ATTR(ctl_keys, 0644, message_show, message_store);\nstatic struct kobj_attribute colors_attribute =\n\t__ATTR(colors, 0644, message_show, message_store);\nstatic struct kobj_attribute formatted_attribute =\n\t__ATTR(formatted, 0644, message_show, message_store);\nstatic struct kobj_attribute function_names_attribute =\n\t__ATTR(function_names, 0644, message_show, message_store);\nstatic struct kobj_attribute key_names_attribute =\n\t__ATTR(key_names, 0644, message_show, message_store);\nstatic struct kobj_attribute states_attribute =\n\t__ATTR(states, 0644, message_show, message_store);\n\n \nstatic struct attribute *main_attrs[] = {\n\t&keymap_attribute.attr,\n\t&silent_attribute.attr,\n\t&synth_attribute.attr,\n\t&synth_direct_attribute.attr,\n\t&version_attribute.attr,\n\t&delimiters_attribute.attr,\n\t&ex_num_attribute.attr,\n\t&punc_all_attribute.attr,\n\t&punc_most_attribute.attr,\n\t&punc_some_attribute.attr,\n\t&repeats_attribute.attr,\n\t&attrib_bleep_attribute.attr,\n\t&bell_pos_attribute.attr,\n\t&bleep_time_attribute.attr,\n\t&bleeps_attribute.attr,\n\t&cursor_time_attribute.attr,\n\t&key_echo_attribute.attr,\n\t&no_interrupt_attribute.attr,\n\t&punc_level_attribute.attr,\n\t&reading_punc_attribute.attr,\n\t&say_control_attribute.attr,\n\t&say_word_ctl_attribute.attr,\n\t&spell_delay_attribute.attr,\n\t&cur_phonetic_attribute.attr,\n\tNULL,\n};\n\nstatic struct attribute *i18n_attrs[] = {\n\t&announcements_attribute.attr,\n\t&characters_attribute.attr,\n\t&chartab_attribute.attr,\n\t&ctl_keys_attribute.attr,\n\t&colors_attribute.attr,\n\t&formatted_attribute.attr,\n\t&function_names_attribute.attr,\n\t&key_names_attribute.attr,\n\t&states_attribute.attr,\n\tNULL,\n};\n\n \nstatic const struct attribute_group main_attr_group = {\n\t.attrs = main_attrs,\n};\n\nstatic const struct attribute_group i18n_attr_group = {\n\t.attrs = i18n_attrs,\n\t.name = \"i18n\",\n};\n\nstatic struct kobject *accessibility_kobj;\nstruct kobject *speakup_kobj;\n\nint speakup_kobj_init(void)\n{\n\tint retval;\n\n\t \n\taccessibility_kobj = kobject_create_and_add(\"accessibility\", NULL);\n\tif (!accessibility_kobj) {\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tspeakup_kobj = kobject_create_and_add(\"speakup\", accessibility_kobj);\n\tif (!speakup_kobj) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_acc;\n\t}\n\n\t \n\tretval = sysfs_create_group(speakup_kobj, &main_attr_group);\n\tif (retval)\n\t\tgoto err_speakup;\n\n\tretval = sysfs_create_group(speakup_kobj, &i18n_attr_group);\n\tif (retval)\n\t\tgoto err_group;\n\n\tgoto out;\n\nerr_group:\n\tsysfs_remove_group(speakup_kobj, &main_attr_group);\nerr_speakup:\n\tkobject_put(speakup_kobj);\nerr_acc:\n\tkobject_put(accessibility_kobj);\nout:\n\treturn retval;\n}\n\nvoid speakup_kobj_exit(void)\n{\n\tsysfs_remove_group(speakup_kobj, &i18n_attr_group);\n\tsysfs_remove_group(speakup_kobj, &main_attr_group);\n\tkobject_put(speakup_kobj);\n\tkobject_put(accessibility_kobj);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}