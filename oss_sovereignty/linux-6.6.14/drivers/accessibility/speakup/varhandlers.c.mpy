{
  "module_name": "varhandlers.c",
  "hash_id": "7850de395a7c54bee64517712e864cc4b6be42b53039c6e84f2ef4d83acece8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/speakup/varhandlers.c",
  "human_readable_source": "\n#include <linux/ctype.h>\n#include \"spk_types.h\"\n#include \"spk_priv.h\"\n#include \"speakup.h\"\n\nstatic struct st_var_header var_headers[] = {\n\t{ \"version\", VERSION, VAR_PROC, NULL, NULL },\n\t{ \"synth_name\", SYNTH, VAR_PROC, NULL, NULL },\n\t{ \"keymap\", KEYMAP, VAR_PROC, NULL, NULL },\n\t{ \"silent\", SILENT, VAR_PROC, NULL, NULL },\n\t{ \"punc_some\", PUNC_SOME, VAR_PROC, NULL, NULL },\n\t{ \"punc_most\", PUNC_MOST, VAR_PROC, NULL, NULL },\n\t{ \"punc_all\", PUNC_ALL, VAR_PROC, NULL, NULL },\n\t{ \"delimiters\", DELIM, VAR_PROC, NULL, NULL },\n\t{ \"repeats\", REPEATS, VAR_PROC, NULL, NULL },\n\t{ \"ex_num\", EXNUMBER, VAR_PROC, NULL, NULL },\n\t{ \"characters\", CHARS, VAR_PROC, NULL, NULL },\n\t{ \"synth_direct\", SYNTH_DIRECT, VAR_PROC, NULL, NULL },\n\t{ \"caps_start\", CAPS_START, VAR_STRING, spk_str_caps_start, NULL },\n\t{ \"caps_stop\", CAPS_STOP, VAR_STRING, spk_str_caps_stop, NULL },\n\t{ \"delay_time\", DELAY, VAR_TIME, NULL, NULL },\n\t{ \"trigger_time\", TRIGGER, VAR_TIME, NULL, NULL },\n\t{ \"jiffy_delta\", JIFFY, VAR_TIME, NULL, NULL },\n\t{ \"full_time\", FULL, VAR_TIME, NULL, NULL },\n\t{ \"flush_time\", FLUSH, VAR_TIME, NULL, NULL },\n\t{ \"spell_delay\", SPELL_DELAY, VAR_NUM, &spk_spell_delay, NULL },\n\t{ \"bleeps\", BLEEPS, VAR_NUM, &spk_bleeps, NULL },\n\t{ \"attrib_bleep\", ATTRIB_BLEEP, VAR_NUM, &spk_attrib_bleep, NULL },\n\t{ \"bleep_time\", BLEEP_TIME, VAR_TIME, &spk_bleep_time, NULL },\n\t{ \"cursor_time\", CURSOR_TIME, VAR_TIME, NULL, NULL },\n\t{ \"punc_level\", PUNC_LEVEL, VAR_NUM, &spk_punc_level, NULL },\n\t{ \"reading_punc\", READING_PUNC, VAR_NUM, &spk_reading_punc, NULL },\n\t{ \"say_control\", SAY_CONTROL, VAR_NUM, &spk_say_ctrl, NULL },\n\t{ \"say_word_ctl\", SAY_WORD_CTL, VAR_NUM, &spk_say_word_ctl, NULL },\n\t{ \"no_interrupt\", NO_INTERRUPT, VAR_NUM, &spk_no_intr, NULL },\n\t{ \"key_echo\", KEY_ECHO, VAR_NUM, &spk_key_echo, NULL },\n\t{ \"bell_pos\", BELL_POS, VAR_NUM, &spk_bell_pos, NULL },\n\t{ \"rate\", RATE, VAR_NUM, NULL, NULL },\n\t{ \"pitch\", PITCH, VAR_NUM, NULL, NULL },\n\t{ \"inflection\", INFLECTION, VAR_NUM, NULL, NULL },\n\t{ \"vol\", VOL, VAR_NUM, NULL, NULL },\n\t{ \"tone\", TONE, VAR_NUM, NULL, NULL },\n\t{ \"punct\", PUNCT, VAR_NUM, NULL, NULL   },\n\t{ \"voice\", VOICE, VAR_NUM, NULL, NULL },\n\t{ \"freq\", FREQUENCY, VAR_NUM, NULL, NULL },\n\t{ \"lang\", LANG, VAR_NUM, NULL, NULL },\n\t{ \"chartab\", CHARTAB, VAR_PROC, NULL, NULL },\n\t{ \"direct\", DIRECT, VAR_NUM, NULL, NULL },\n\t{ \"pause\", PAUSE, VAR_STRING, spk_str_pause, NULL },\n\t{ \"cur_phonetic\", CUR_PHONETIC, VAR_NUM, &spk_cur_phonetic, NULL },\n};\n\nstatic struct st_var_header *var_ptrs[MAXVARS] = { NULL, NULL, NULL };\n\nstatic struct punc_var_t punc_vars[] = {\n\t{ PUNC_SOME, 1 },\n\t{ PUNC_MOST, 2 },\n\t{ PUNC_ALL, 3 },\n\t{ DELIM, 4 },\n\t{ REPEATS, 5 },\n\t{ EXNUMBER, 6 },\n\t{ -1, -1 },\n};\n\nint spk_chartab_get_value(char *keyword)\n{\n\tint value = 0;\n\n\tif (!strcmp(keyword, \"ALPHA\"))\n\t\tvalue = ALPHA;\n\telse if (!strcmp(keyword, \"B_CTL\"))\n\t\tvalue = B_CTL;\n\telse if (!strcmp(keyword, \"WDLM\"))\n\t\tvalue = WDLM;\n\telse if (!strcmp(keyword, \"A_PUNC\"))\n\t\tvalue = A_PUNC;\n\telse if (!strcmp(keyword, \"PUNC\"))\n\t\tvalue = PUNC;\n\telse if (!strcmp(keyword, \"NUM\"))\n\t\tvalue = NUM;\n\telse if (!strcmp(keyword, \"A_CAP\"))\n\t\tvalue = A_CAP;\n\telse if (!strcmp(keyword, \"B_CAPSYM\"))\n\t\tvalue = B_CAPSYM;\n\telse if (!strcmp(keyword, \"B_SYM\"))\n\t\tvalue = B_SYM;\n\treturn value;\n}\n\nvoid speakup_register_var(struct var_t *var)\n{\n\tstatic char nothing[2] = \"\\0\";\n\tint i;\n\tstruct st_var_header *p_header;\n\n\tBUG_ON(!var || var->var_id < 0 || var->var_id >= MAXVARS);\n\tif (!var_ptrs[0]) {\n\t\tfor (i = 0; i < MAXVARS; i++) {\n\t\t\tp_header = &var_headers[i];\n\t\t\tvar_ptrs[p_header->var_id] = p_header;\n\t\t\tp_header->data = NULL;\n\t\t}\n\t}\n\tp_header = var_ptrs[var->var_id];\n\tif (p_header->data)\n\t\treturn;\n\tp_header->data = var;\n\tswitch (p_header->var_type) {\n\tcase VAR_STRING:\n\t\tspk_set_string_var(nothing, p_header, 0);\n\t\tbreak;\n\tcase VAR_NUM:\n\tcase VAR_TIME:\n\t\tspk_set_num_var(0, p_header, E_DEFAULT);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid speakup_unregister_var(enum var_id_t var_id)\n{\n\tstruct st_var_header *p_header;\n\n\tBUG_ON(var_id < 0 || var_id >= MAXVARS);\n\tp_header = var_ptrs[var_id];\n\tp_header->data = NULL;\n}\n\nstruct st_var_header *spk_get_var_header(enum var_id_t var_id)\n{\n\tstruct st_var_header *p_header;\n\n\tif (var_id < 0 || var_id >= MAXVARS)\n\t\treturn NULL;\n\tp_header = var_ptrs[var_id];\n\tif (!p_header->data)\n\t\treturn NULL;\n\treturn p_header;\n}\nEXPORT_SYMBOL_GPL(spk_get_var_header);\n\nstruct st_var_header *spk_var_header_by_name(const char *name)\n{\n\tint i;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tfor (i = 0; i < MAXVARS; i++) {\n\t\tif (strcmp(name, var_ptrs[i]->name) == 0)\n\t\t\treturn var_ptrs[i];\n\t}\n\treturn NULL;\n}\n\nstruct var_t *spk_get_var(enum var_id_t var_id)\n{\n\tBUG_ON(var_id < 0 || var_id >= MAXVARS);\n\tBUG_ON(!var_ptrs[var_id]);\n\treturn var_ptrs[var_id]->data;\n}\nEXPORT_SYMBOL_GPL(spk_get_var);\n\nstruct punc_var_t *spk_get_punc_var(enum var_id_t var_id)\n{\n\tstruct punc_var_t *rv = NULL;\n\tstruct punc_var_t *where;\n\n\twhere = punc_vars;\n\twhile ((where->var_id != -1) && (!rv)) {\n\t\tif (where->var_id == var_id)\n\t\t\trv = where;\n\t\telse\n\t\t\twhere++;\n\t}\n\treturn rv;\n}\n\n \nint spk_set_num_var(int input, struct st_var_header *var, int how)\n{\n\tint val;\n\tint *p_val = var->p_val;\n\tchar buf[32];\n\tchar *cp;\n\tstruct var_t *var_data = var->data;\n\n\tif (!var_data)\n\t\treturn -ENODATA;\n\n\tval = var_data->u.n.value;\n\tswitch (how) {\n\tcase E_NEW_DEFAULT:\n\t\tif (input < var_data->u.n.low || input > var_data->u.n.high)\n\t\t\treturn -ERANGE;\n\t\tvar_data->u.n.default_val = input;\n\t\treturn 0;\n\tcase E_DEFAULT:\n\t\tval = var_data->u.n.default_val;\n\t\tbreak;\n\tcase E_SET:\n\t\tval = input;\n\t\tbreak;\n\tcase E_INC:\n\t\tval += input;\n\t\tbreak;\n\tcase E_DEC:\n\t\tval -= input;\n\t\tbreak;\n\t}\n\n\tif (val < var_data->u.n.low || val > var_data->u.n.high)\n\t\treturn -ERANGE;\n\n\tvar_data->u.n.value = val;\n\tif (var->var_type == VAR_TIME && p_val) {\n\t\t*p_val = msecs_to_jiffies(val);\n\t\treturn 0;\n\t}\n\tif (p_val)\n\t\t*p_val = val;\n\tif (var->var_id == PUNC_LEVEL) {\n\t\tspk_punc_mask = spk_punc_masks[val];\n\t}\n\tif (var_data->u.n.multiplier != 0)\n\t\tval *= var_data->u.n.multiplier;\n\tval += var_data->u.n.offset;\n\n\tif (!synth)\n\t\treturn 0;\n\tif (synth->synth_adjust && synth->synth_adjust(synth, var))\n\t\treturn 0;\n\tif (var->var_id < FIRST_SYNTH_VAR)\n\t\treturn 0;\n\n\tif (!var_data->u.n.synth_fmt)\n\t\treturn 0;\n\tif (var->var_id == PITCH)\n\t\tcp = spk_pitch_buff;\n\telse\n\t\tcp = buf;\n\tif (!var_data->u.n.out_str)\n\t\tsprintf(cp, var_data->u.n.synth_fmt, (int)val);\n\telse\n\t\tsprintf(cp, var_data->u.n.synth_fmt,\n\t\t\tvar_data->u.n.out_str[val]);\n\tsynth_printf(\"%s\", cp);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(spk_set_num_var);\n\nint spk_set_string_var(const char *page, struct st_var_header *var, int len)\n{\n\tstruct var_t *var_data = var->data;\n\n\tif (!var_data)\n\t\treturn -ENODATA;\n\tif (len > MAXVARLEN)\n\t\treturn -E2BIG;\n\tif (!len) {\n\t\tif (!var_data->u.s.default_val)\n\t\t\treturn 0;\n\t\tif (!var->p_val)\n\t\t\tvar->p_val = var_data->u.s.default_val;\n\t\tif (var->p_val != var_data->u.s.default_val)\n\t\t\tstrcpy((char *)var->p_val, var_data->u.s.default_val);\n\t\treturn -ERESTART;\n\t} else if (var->p_val) {\n\t\tstrcpy((char *)var->p_val, page);\n\t} else {\n\t\treturn -E2BIG;\n\t}\n\treturn 0;\n}\n\n \nint spk_set_mask_bits(const char *input, const int which, const int how)\n{\n\tu_char *cp;\n\tshort mask = spk_punc_info[which].mask;\n\n\tif (how & 1) {\n\t\tfor (cp = (u_char *)spk_punc_info[3].value; *cp; cp++)\n\t\t\tspk_chartab[*cp] &= ~mask;\n\t}\n\tcp = (u_char *)input;\n\tif (!cp) {\n\t\tcp = spk_punc_info[which].value;\n\t} else {\n\t\tfor (; *cp; cp++) {\n\t\t\tif (*cp < SPACE)\n\t\t\t\tbreak;\n\t\t\tif (mask < PUNC) {\n\t\t\t\tif (!(spk_chartab[*cp] & PUNC))\n\t\t\t\t\tbreak;\n\t\t\t} else if (spk_chartab[*cp] & B_NUM) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (*cp)\n\t\t\treturn -EINVAL;\n\t\tcp = (u_char *)input;\n\t}\n\tif (how & 2) {\n\t\tfor (; *cp; cp++)\n\t\t\tif (*cp > SPACE)\n\t\t\t\tspk_chartab[*cp] |= mask;\n\t} else {\n\t\tfor (; *cp; cp++)\n\t\t\tif (*cp > SPACE)\n\t\t\t\tspk_chartab[*cp] &= ~mask;\n\t}\n\treturn 0;\n}\n\nchar *spk_strlwr(char *s)\n{\n\tchar *p;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tfor (p = s; *p; p++)\n\t\t*p = tolower(*p);\n\treturn s;\n}\n\nchar *spk_s2uchar(char *start, char *dest)\n{\n\tint val;\n\n\t \n\tval = simple_strtoul(skip_spaces(start), &start, 10);\n\tif (*start == ',')\n\t\tstart++;\n\t*dest = (u_char)val;\n\treturn start;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}