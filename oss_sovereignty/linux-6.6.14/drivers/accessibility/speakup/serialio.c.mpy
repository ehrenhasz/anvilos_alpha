{
  "module_name": "serialio.c",
  "hash_id": "db3e8995ebabaabe6576bd255edf533331bd287d397f609fbc3f9b9ecbfd3926",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/speakup/serialio.c",
  "human_readable_source": "\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n\n#include \"spk_types.h\"\n#include \"speakup.h\"\n#include \"spk_priv.h\"\n#include \"serialio.h\"\n\n#include <linux/serial_core.h>\n \n#include <asm/serial.h>\n\n#ifndef SERIAL_PORT_DFNS\n#define SERIAL_PORT_DFNS\n#endif\n\nstatic void start_serial_interrupt(int irq);\n\nstatic const struct old_serial_port rs_table[] = {\n\tSERIAL_PORT_DFNS\n};\n\nstatic const struct old_serial_port *serstate;\nstatic int timeouts;\n\nstatic int spk_serial_out(struct spk_synth *in_synth, const char ch);\nstatic void spk_serial_send_xchar(struct spk_synth *in_synth, char ch);\nstatic void spk_serial_tiocmset(struct spk_synth *in_synth, unsigned int set, unsigned int clear);\nstatic unsigned char spk_serial_in(struct spk_synth *in_synth);\nstatic unsigned char spk_serial_in_nowait(struct spk_synth *in_synth);\nstatic void spk_serial_flush_buffer(struct spk_synth *in_synth);\nstatic int spk_serial_wait_for_xmitr(struct spk_synth *in_synth);\n\nstruct spk_io_ops spk_serial_io_ops = {\n\t.synth_out = spk_serial_out,\n\t.send_xchar = spk_serial_send_xchar,\n\t.tiocmset = spk_serial_tiocmset,\n\t.synth_in = spk_serial_in,\n\t.synth_in_nowait = spk_serial_in_nowait,\n\t.flush_buffer = spk_serial_flush_buffer,\n\t.wait_for_xmitr = spk_serial_wait_for_xmitr,\n};\nEXPORT_SYMBOL_GPL(spk_serial_io_ops);\n\nconst struct old_serial_port *spk_serial_init(int index)\n{\n\tint baud = 9600, quot = 0;\n\tunsigned int cval = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL | B9600 | CS8;\n\tconst struct old_serial_port *ser;\n\tint err;\n\n\tif (index >= ARRAY_SIZE(rs_table)) {\n\t\tpr_info(\"no port info for ttyS%d\\n\", index);\n\t\treturn NULL;\n\t}\n\tser = rs_table + index;\n\n\t \n\tquot = ser->baud_base / baud;\n\tcval = cflag & (CSIZE | CSTOPB);\n#if defined(__powerpc__) || defined(__alpha__)\n\tcval >>= 8;\n#else  \n\tcval >>= 4;\n#endif  \n\tif (cflag & PARENB)\n\t\tcval |= UART_LCR_PARITY;\n\tif (!(cflag & PARODD))\n\t\tcval |= UART_LCR_EPAR;\n\tif (synth_request_region(ser->port, 8)) {\n\t\t \n\t\tpr_info(\"Ports not available, trying to steal them\\n\");\n\t\t__release_region(&ioport_resource, ser->port, 8);\n\t\terr = synth_request_region(ser->port, 8);\n\t\tif (err) {\n\t\t\tpr_warn(\"Unable to allocate port at %x, errno %i\",\n\t\t\t\tser->port, err);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t \n\toutb(cval | UART_LCR_DLAB, ser->port + UART_LCR);\t \n\toutb(quot & 0xff, ser->port + UART_DLL);\t \n\toutb(quot >> 8, ser->port + UART_DLM);\t\t \n\toutb(cval, ser->port + UART_LCR);\t\t \n\n\t \n\toutb(0, ser->port + UART_IER);\n\toutb(UART_MCR_DTR | UART_MCR_RTS, ser->port + UART_MCR);\n\n\t \n\tif (inb(ser->port + UART_LSR) == 0xff) {\n\t\tsynth_release_region(ser->port, 8);\n\t\tserstate = NULL;\n\t\treturn NULL;\n\t}\n\n\tmdelay(1);\n\tspeakup_info.port_tts = ser->port;\n\tserstate = ser;\n\n\tstart_serial_interrupt(ser->irq);\n\n\treturn ser;\n}\n\nstatic irqreturn_t synth_readbuf_handler(int irq, void *dev_id)\n{\n\tunsigned long flags;\n\tint c;\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\twhile (inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR) {\n\t\tc = inb_p(speakup_info.port_tts + UART_RX);\n\t\tsynth->read_buff_add((u_char)c);\n\t}\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic void start_serial_interrupt(int irq)\n{\n\tint rv;\n\n\tif (!synth->read_buff_add)\n\t\treturn;\n\n\trv = request_irq(irq, synth_readbuf_handler, IRQF_SHARED,\n\t\t\t \"serial\", (void *)synth_readbuf_handler);\n\n\tif (rv)\n\t\tpr_err(\"Unable to request Speakup serial I R Q\\n\");\n\t \n\toutb(UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2,\n\t     speakup_info.port_tts + UART_MCR);\n\t \n\toutb(UART_IER_MSI | UART_IER_RLSI | UART_IER_RDI,\n\t     speakup_info.port_tts + UART_IER);\n\tinb(speakup_info.port_tts + UART_LSR);\n\tinb(speakup_info.port_tts + UART_RX);\n\tinb(speakup_info.port_tts + UART_IIR);\n\tinb(speakup_info.port_tts + UART_MSR);\n\toutb(1, speakup_info.port_tts + UART_FCR);\t \n}\n\nstatic void spk_serial_send_xchar(struct spk_synth *synth, char ch)\n{\n\tint timeout = SPK_XMITR_TIMEOUT;\n\n\twhile (spk_serial_tx_busy()) {\n\t\tif (!--timeout)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\toutb(ch, speakup_info.port_tts);\n}\n\nstatic void spk_serial_tiocmset(struct spk_synth *in_synth, unsigned int set, unsigned int clear)\n{\n\tint old = inb(speakup_info.port_tts + UART_MCR);\n\n\toutb((old & ~clear) | set, speakup_info.port_tts + UART_MCR);\n}\n\nint spk_serial_synth_probe(struct spk_synth *synth)\n{\n\tconst struct old_serial_port *ser;\n\tint failed = 0;\n\n\tif ((synth->ser >= SPK_LO_TTY) && (synth->ser <= SPK_HI_TTY)) {\n\t\tser = spk_serial_init(synth->ser);\n\t\tif (!ser) {\n\t\t\tfailed = -1;\n\t\t} else {\n\t\t\toutb_p(0, ser->port);\n\t\t\tmdelay(1);\n\t\t\toutb_p('\\r', ser->port);\n\t\t}\n\t} else {\n\t\tfailed = -1;\n\t\tpr_warn(\"ttyS%i is an invalid port\\n\", synth->ser);\n\t}\n\tif (failed) {\n\t\tpr_info(\"%s: not found\\n\", synth->long_name);\n\t\treturn -ENODEV;\n\t}\n\tpr_info(\"%s: ttyS%i, Driver Version %s\\n\",\n\t\tsynth->long_name, synth->ser, synth->version);\n\tsynth->alive = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(spk_serial_synth_probe);\n\nvoid spk_stop_serial_interrupt(void)\n{\n\tif (speakup_info.port_tts == 0)\n\t\treturn;\n\n\tif (!synth->read_buff_add)\n\t\treturn;\n\n\t \n\toutb(0, speakup_info.port_tts + UART_IER);\n\t \n\tfree_irq(serstate->irq, (void *)synth_readbuf_handler);\n}\nEXPORT_SYMBOL_GPL(spk_stop_serial_interrupt);\n\nstatic int spk_serial_wait_for_xmitr(struct spk_synth *in_synth)\n{\n\tint tmout = SPK_XMITR_TIMEOUT;\n\n\tif ((in_synth->alive) && (timeouts >= NUM_DISABLE_TIMEOUTS)) {\n\t\tpr_warn(\"%s: too many timeouts, deactivating speakup\\n\",\n\t\t\tin_synth->long_name);\n\t\tin_synth->alive = 0;\n\t\t \n\t\tspeakup_start_ttys();\n\t\ttimeouts = 0;\n\t\treturn 0;\n\t}\n\twhile (spk_serial_tx_busy()) {\n\t\tif (--tmout == 0) {\n\t\t\tpr_warn(\"%s: timed out (tx busy)\\n\",\n\t\t\t\tin_synth->long_name);\n\t\t\ttimeouts++;\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\ttmout = SPK_CTS_TIMEOUT;\n\twhile (!((inb_p(speakup_info.port_tts + UART_MSR)) & UART_MSR_CTS)) {\n\t\t \n\t\tif (--tmout == 0) {\n\t\t\ttimeouts++;\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\ttimeouts = 0;\n\treturn 1;\n}\n\nstatic unsigned char spk_serial_in(struct spk_synth *in_synth)\n{\n\tint tmout = SPK_SERIAL_TIMEOUT;\n\n\twhile (!(inb_p(speakup_info.port_tts + UART_LSR) & UART_LSR_DR)) {\n\t\tif (--tmout == 0) {\n\t\t\tpr_warn(\"time out while waiting for input.\\n\");\n\t\t\treturn 0xff;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn inb_p(speakup_info.port_tts + UART_RX);\n}\n\nstatic unsigned char spk_serial_in_nowait(struct spk_synth *in_synth)\n{\n\tunsigned char lsr;\n\n\tlsr = inb_p(speakup_info.port_tts + UART_LSR);\n\tif (!(lsr & UART_LSR_DR))\n\t\treturn 0;\n\treturn inb_p(speakup_info.port_tts + UART_RX);\n}\n\nstatic void spk_serial_flush_buffer(struct spk_synth *in_synth)\n{\n\t \n}\n\nstatic int spk_serial_out(struct spk_synth *in_synth, const char ch)\n{\n\tif (in_synth->alive && spk_serial_wait_for_xmitr(in_synth)) {\n\t\toutb_p(ch, speakup_info.port_tts);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nconst char *spk_serial_synth_immediate(struct spk_synth *synth,\n\t\t\t\t       const char *buff)\n{\n\tu_char ch;\n\n\twhile ((ch = *buff)) {\n\t\tif (ch == '\\n')\n\t\t\tch = synth->procspeech;\n\t\tif (spk_serial_wait_for_xmitr(synth))\n\t\t\toutb(ch, speakup_info.port_tts);\n\t\telse\n\t\t\treturn buff;\n\t\tbuff++;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(spk_serial_synth_immediate);\n\nvoid spk_serial_release(struct spk_synth *synth)\n{\n\tspk_stop_serial_interrupt();\n\tif (speakup_info.port_tts == 0)\n\t\treturn;\n\tsynth_release_region(speakup_info.port_tts, 8);\n\tspeakup_info.port_tts = 0;\n}\nEXPORT_SYMBOL_GPL(spk_serial_release);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}