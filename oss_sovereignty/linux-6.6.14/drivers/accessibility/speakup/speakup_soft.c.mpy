{
  "module_name": "speakup_soft.c",
  "hash_id": "dcf758977571ac94fdda9c866c8ab555e68ddb76671b7b1c73232a9bec8ca481",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/speakup/speakup_soft.c",
  "human_readable_source": "\n \n\n#include <linux/unistd.h>\n#include <linux/miscdevice.h>\t \n#include <linux/poll.h>\t\t \n\n \n#include <linux/sched/signal.h>\n\n#include \"spk_priv.h\"\n#include \"speakup.h\"\n\n#define DRV_VERSION \"2.6\"\n#define PROCSPEECH 0x0d\n#define CLEAR_SYNTH 0x18\n\nstatic int softsynth_probe(struct spk_synth *synth);\nstatic void softsynth_release(struct spk_synth *synth);\nstatic int softsynth_is_alive(struct spk_synth *synth);\nstatic int softsynth_adjust(struct spk_synth *synth, struct st_var_header *var);\nstatic unsigned char get_index(struct spk_synth *synth);\n\nstatic struct miscdevice synth_device, synthu_device;\nstatic int init_pos;\nstatic int misc_registered;\n\n\nenum default_vars_id {\n\tDIRECT_ID = 0, CAPS_START_ID, CAPS_STOP_ID,\n\tPAUSE_ID, RATE_ID, PITCH_ID, INFLECTION_ID,\n\tVOL_ID, TONE_ID, PUNCT_ID, VOICE_ID,\n\tFREQUENCY_ID, V_LAST_VAR_ID,\n\t NB_ID\n};\n\n\nstatic struct var_t vars[NB_ID] = {\n\n\t[DIRECT_ID]  = { DIRECT, .u.n = {NULL, 0, 0, 1, 0, 0, NULL } },\n\t[CAPS_START_ID] = { CAPS_START, .u.s = {\"\\x01+3p\" } },\n\t[CAPS_STOP_ID]  = { CAPS_STOP, .u.s = {\"\\x01-3p\" } },\n\t[PAUSE_ID]  = { PAUSE, .u.n = {\"\\x01P\" } },\n\t[RATE_ID]  = { RATE, .u.n = {\"\\x01%ds\", 2, 0, 9, 0, 0, NULL } },\n\t[PITCH_ID]  = { PITCH, .u.n = {\"\\x01%dp\", 5, 0, 9, 0, 0, NULL } },\n\t[INFLECTION_ID]  = { INFLECTION, .u.n = {\"\\x01%dr\", 5, 0, 9, 0, 0, NULL } },\n\t[VOL_ID]  = { VOL, .u.n = {\"\\x01%dv\", 5, 0, 9, 0, 0, NULL } },\n\t[TONE_ID]  = { TONE, .u.n = {\"\\x01%dx\", 1, 0, 2, 0, 0, NULL } },\n\t[PUNCT_ID]  = { PUNCT, .u.n = {\"\\x01%db\", 0, 0, 3, 0, 0, NULL } },\n\t[VOICE_ID]  = { VOICE, .u.n = {\"\\x01%do\", 0, 0, 7, 0, 0, NULL } },\n\t[FREQUENCY_ID]  = { FREQUENCY, .u.n = {\"\\x01%df\", 5, 0, 9, 0, 0, NULL } },\n\tV_LAST_VAR\n};\n\n \n\nstatic struct kobj_attribute caps_start_attribute =\n\t__ATTR(caps_start, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute caps_stop_attribute =\n\t__ATTR(caps_stop, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute freq_attribute =\n\t__ATTR(freq, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute pitch_attribute =\n\t__ATTR(pitch, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute inflection_attribute =\n\t__ATTR(inflection, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute punct_attribute =\n\t__ATTR(punct, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute rate_attribute =\n\t__ATTR(rate, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute tone_attribute =\n\t__ATTR(tone, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute voice_attribute =\n\t__ATTR(voice, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute vol_attribute =\n\t__ATTR(vol, 0644, spk_var_show, spk_var_store);\n\n \n\nstatic struct kobj_attribute delay_time_attribute =\n\t__ATTR(delay_time, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute direct_attribute =\n\t__ATTR(direct, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute full_time_attribute =\n\t__ATTR(full_time, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute jiffy_delta_attribute =\n\t__ATTR(jiffy_delta, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute trigger_time_attribute =\n\t__ATTR(trigger_time, 0644, spk_var_show, spk_var_store);\n\n \nstatic struct attribute *synth_attrs[] = {\n\t&caps_start_attribute.attr,\n\t&caps_stop_attribute.attr,\n\t&freq_attribute.attr,\n \n\t&pitch_attribute.attr,\n\t&inflection_attribute.attr,\n\t&punct_attribute.attr,\n\t&rate_attribute.attr,\n\t&tone_attribute.attr,\n\t&voice_attribute.attr,\n\t&vol_attribute.attr,\n\t&delay_time_attribute.attr,\n\t&direct_attribute.attr,\n\t&full_time_attribute.attr,\n\t&jiffy_delta_attribute.attr,\n\t&trigger_time_attribute.attr,\n\tNULL,\t \n};\n\nstatic struct spk_synth synth_soft = {\n\t.name = \"soft\",\n\t.version = DRV_VERSION,\n\t.long_name = \"software synth\",\n\t.init = \"\\01@\\x01\\x31y\\n\",\n\t.procspeech = PROCSPEECH,\n\t.delay = 0,\n\t.trigger = 0,\n\t.jiffies = 0,\n\t.full = 0,\n\t.startup = SYNTH_START,\n\t.checkval = SYNTH_CHECK,\n\t.vars = vars,\n\t.io_ops = NULL,\n\t.probe = softsynth_probe,\n\t.release = softsynth_release,\n\t.synth_immediate = NULL,\n\t.catch_up = NULL,\n\t.flush = NULL,\n\t.is_alive = softsynth_is_alive,\n\t.synth_adjust = softsynth_adjust,\n\t.read_buff_add = NULL,\n\t.get_index = get_index,\n\t.indexing = {\n\t\t.command = \"\\x01%di\",\n\t\t.lowindex = 1,\n\t\t.highindex = 5,\n\t\t.currindex = 1,\n\t},\n\t.attributes = {\n\t\t.attrs = synth_attrs,\n\t\t.name = \"soft\",\n\t},\n};\n\nstatic char *get_initstring(void)\n{\n\tstatic char buf[40];\n\tchar *cp;\n\tstruct var_t *var;\n\tsize_t len;\n\tsize_t n;\n\n\tmemset(buf, 0, sizeof(buf));\n\tcp = buf;\n\tlen = sizeof(buf);\n\n\tvar = synth_soft.vars;\n\twhile (var->var_id != MAXVARS) {\n\t\tif (var->var_id != CAPS_START && var->var_id != CAPS_STOP &&\n\t\t    var->var_id != PAUSE && var->var_id != DIRECT) {\n\t\t\tn = scnprintf(cp, len, var->u.n.synth_fmt,\n\t\t\t\t      var->u.n.value);\n\t\t\tcp = cp + n;\n\t\t\tlen = len - n;\n\t\t}\n\t\tvar++;\n\t}\n\tcp = cp + scnprintf(cp, len, \"\\n\");\n\treturn buf;\n}\n\nstatic int softsynth_open(struct inode *inode, struct file *fp)\n{\n\tunsigned long flags;\n\t \n\t \n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tif (synth_soft.alive) {\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\treturn -EBUSY;\n\t}\n\tsynth_soft.alive = 1;\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn 0;\n}\n\nstatic int softsynth_close(struct inode *inode, struct file *fp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tsynth_soft.alive = 0;\n\tinit_pos = 0;\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t \n\tspeakup_start_ttys();\n\treturn 0;\n}\n\nstatic ssize_t softsynthx_read(struct file *fp, char __user *buf, size_t count,\n\t\t\t       loff_t *pos, int unicode)\n{\n\tint chars_sent = 0;\n\tchar __user *cp;\n\tchar *init;\n\tsize_t bytes_per_ch = unicode ? 3 : 1;\n\tu16 ch;\n\tint empty;\n\tunsigned long flags;\n\tDEFINE_WAIT(wait);\n\n\tif (count < bytes_per_ch)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tsynth_soft.alive = 1;\n\twhile (1) {\n\t\tprepare_to_wait(&speakup_event, &wait, TASK_INTERRUPTIBLE);\n\t\tif (synth_current() == &synth_soft) {\n\t\t\tif (!unicode)\n\t\t\t\tsynth_buffer_skip_nonlatin1();\n\t\t\tif (!synth_buffer_empty() || speakup_info.flushing)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\tif (fp->f_flags & O_NONBLOCK) {\n\t\t\tfinish_wait(&speakup_event, &wait);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tfinish_wait(&speakup_event, &wait);\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t\tschedule();\n\t\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\t}\n\tfinish_wait(&speakup_event, &wait);\n\n\tcp = buf;\n\tinit = get_initstring();\n\n\t \n\twhile (chars_sent <= count - bytes_per_ch) {\n\t\tif (synth_current() != &synth_soft)\n\t\t\tbreak;\n\t\tif (speakup_info.flushing) {\n\t\t\tspeakup_info.flushing = 0;\n\t\t\tch = '\\x18';\n\t\t} else if (init[init_pos]) {\n\t\t\tch = init[init_pos++];\n\t\t} else {\n\t\t\tif (!unicode)\n\t\t\t\tsynth_buffer_skip_nonlatin1();\n\t\t\tif (synth_buffer_empty())\n\t\t\t\tbreak;\n\t\t\tch = synth_buffer_getc();\n\t\t}\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\n\t\tif ((!unicode && ch < 0x100) || (unicode && ch < 0x80)) {\n\t\t\tu_char c = ch;\n\n\t\t\tif (copy_to_user(cp, &c, 1))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tchars_sent++;\n\t\t\tcp++;\n\t\t} else if (unicode && ch < 0x800) {\n\t\t\tu_char s[2] = {\n\t\t\t\t0xc0 | (ch >> 6),\n\t\t\t\t0x80 | (ch & 0x3f)\n\t\t\t};\n\n\t\t\tif (copy_to_user(cp, s, sizeof(s)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tchars_sent += sizeof(s);\n\t\t\tcp += sizeof(s);\n\t\t} else if (unicode) {\n\t\t\tu_char s[3] = {\n\t\t\t\t0xe0 | (ch >> 12),\n\t\t\t\t0x80 | ((ch >> 6) & 0x3f),\n\t\t\t\t0x80 | (ch & 0x3f)\n\t\t\t};\n\n\t\t\tif (copy_to_user(cp, s, sizeof(s)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tchars_sent += sizeof(s);\n\t\t\tcp += sizeof(s);\n\t\t}\n\n\t\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\t}\n\t*pos += chars_sent;\n\tempty = synth_buffer_empty();\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\tif (empty) {\n\t\tspeakup_start_ttys();\n\t\t*pos = 0;\n\t}\n\treturn chars_sent;\n}\n\nstatic ssize_t softsynth_read(struct file *fp, char __user *buf, size_t count,\n\t\t\t      loff_t *pos)\n{\n\treturn softsynthx_read(fp, buf, count, pos, 0);\n}\n\nstatic ssize_t softsynthu_read(struct file *fp, char __user *buf, size_t count,\n\t\t\t       loff_t *pos)\n{\n\treturn softsynthx_read(fp, buf, count, pos, 1);\n}\n\nstatic int last_index;\n\nstatic ssize_t softsynth_write(struct file *fp, const char __user *buf,\n\t\t\t       size_t count, loff_t *pos)\n{\n\tunsigned long supplied_index = 0;\n\tint converted;\n\n\tconverted = kstrtoul_from_user(buf, count, 0, &supplied_index);\n\n\tif (converted < 0)\n\t\treturn converted;\n\n\tlast_index = supplied_index;\n\treturn count;\n}\n\nstatic __poll_t softsynth_poll(struct file *fp, struct poll_table_struct *wait)\n{\n\tunsigned long flags;\n\t__poll_t ret = 0;\n\n\tpoll_wait(fp, &speakup_event, wait);\n\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tif (synth_current() == &synth_soft &&\n\t    (!synth_buffer_empty() || speakup_info.flushing))\n\t\tret = EPOLLIN | EPOLLRDNORM;\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\treturn ret;\n}\n\nstatic unsigned char get_index(struct spk_synth *synth)\n{\n\tint rv;\n\n\trv = last_index;\n\tlast_index = 0;\n\treturn rv;\n}\n\nstatic const struct file_operations softsynth_fops = {\n\t.owner = THIS_MODULE,\n\t.poll = softsynth_poll,\n\t.read = softsynth_read,\n\t.write = softsynth_write,\n\t.open = softsynth_open,\n\t.release = softsynth_close,\n};\n\nstatic const struct file_operations softsynthu_fops = {\n\t.owner = THIS_MODULE,\n\t.poll = softsynth_poll,\n\t.read = softsynthu_read,\n\t.write = softsynth_write,\n\t.open = softsynth_open,\n\t.release = softsynth_close,\n};\n\nstatic int softsynth_probe(struct spk_synth *synth)\n{\n\tif (misc_registered != 0)\n\t\treturn 0;\n\tmemset(&synth_device, 0, sizeof(synth_device));\n\tsynth_device.minor = MISC_DYNAMIC_MINOR;\n\tsynth_device.name = \"softsynth\";\n\tsynth_device.fops = &softsynth_fops;\n\tif (misc_register(&synth_device)) {\n\t\tpr_warn(\"Couldn't initialize miscdevice /dev/softsynth.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmemset(&synthu_device, 0, sizeof(synthu_device));\n\tsynthu_device.minor = MISC_DYNAMIC_MINOR;\n\tsynthu_device.name = \"softsynthu\";\n\tsynthu_device.fops = &softsynthu_fops;\n\tif (misc_register(&synthu_device)) {\n\t\tmisc_deregister(&synth_device);\n\t\tpr_warn(\"Couldn't initialize miscdevice /dev/softsynthu.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmisc_registered = 1;\n\tpr_info(\"initialized device: /dev/softsynth, node (MAJOR 10, MINOR %d)\\n\",\n\t\tsynth_device.minor);\n\tpr_info(\"initialized device: /dev/softsynthu, node (MAJOR 10, MINOR %d)\\n\",\n\t\tsynthu_device.minor);\n\treturn 0;\n}\n\nstatic void softsynth_release(struct spk_synth *synth)\n{\n\tmisc_deregister(&synth_device);\n\tmisc_deregister(&synthu_device);\n\tmisc_registered = 0;\n\tpr_info(\"unregistered /dev/softsynth\\n\");\n\tpr_info(\"unregistered /dev/softsynthu\\n\");\n}\n\nstatic int softsynth_is_alive(struct spk_synth *synth)\n{\n\tif (synth_soft.alive)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int softsynth_adjust(struct spk_synth *synth, struct st_var_header *var)\n{\n\tstruct st_var_header *punc_level_var;\n\tstruct var_t *var_data;\n\n\tif (var->var_id != PUNC_LEVEL)\n\t\treturn 0;\n\n\t \n\tvar_data = var->data;\n\tif (!var_data)\n\t\treturn 0;\n\tpunc_level_var = spk_get_var_header(PUNCT);\n\tif (!punc_level_var)\n\t\treturn 0;\n\tspk_set_num_var(var_data->u.n.value, punc_level_var, E_SET);\n\n\treturn 1;\n}\n\nmodule_param_named(start, synth_soft.startup, short, 0444);\nmodule_param_named(direct, vars[DIRECT_ID].u.n.default_val, int, 0444);\nmodule_param_named(rate, vars[RATE_ID].u.n.default_val, int, 0444);\nmodule_param_named(pitch, vars[PITCH_ID].u.n.default_val, int, 0444);\nmodule_param_named(inflection, vars[INFLECTION_ID].u.n.default_val, int, 0444);\nmodule_param_named(vol, vars[VOL_ID].u.n.default_val, int, 0444);\nmodule_param_named(tone, vars[TONE_ID].u.n.default_val, int, 0444);\nmodule_param_named(punct, vars[PUNCT_ID].u.n.default_val, int, 0444);\nmodule_param_named(voice, vars[VOICE_ID].u.n.default_val, int, 0444);\nmodule_param_named(frequency, vars[FREQUENCY_ID].u.n.default_val, int, 0444);\n\n\n\nMODULE_PARM_DESC(start, \"Start the synthesizer once it is loaded.\");\nMODULE_PARM_DESC(direct, \"Set the direct variable on load.\");\nMODULE_PARM_DESC(rate, \"Sets the rate of the synthesizer.\");\nMODULE_PARM_DESC(pitch, \"Sets the pitch of the synthesizer.\");\nMODULE_PARM_DESC(inflection, \"Sets the inflection of the synthesizer.\");\nMODULE_PARM_DESC(vol, \"Sets the volume of the speech synthesizer.\");\nMODULE_PARM_DESC(tone, \"Sets the tone of the speech synthesizer.\");\nMODULE_PARM_DESC(punct, \"Sets the amount of punctuation spoken by the synthesizer.\");\nMODULE_PARM_DESC(voice, \"Sets the voice used by the synthesizer.\");\nMODULE_PARM_DESC(frequency, \"Sets the frequency of speech synthesizer.\");\n\nmodule_spk_synth(synth_soft);\n\nMODULE_AUTHOR(\"Kirk Reiser <kirk@braille.uwo.ca>\");\nMODULE_DESCRIPTION(\"Speakup userspace software synthesizer support\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}