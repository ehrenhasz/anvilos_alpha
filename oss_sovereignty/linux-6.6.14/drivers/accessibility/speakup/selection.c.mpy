{
  "module_name": "selection.c",
  "hash_id": "6564690e09faa6a511caa173131c2a610333dd845f48c17c87ac25103e747f7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/speakup/selection.c",
  "human_readable_source": "\n#include <linux/slab.h>  \n#include <linux/consolemap.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/device.h>  \n#include <linux/selection.h>\n#include <linux/workqueue.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/atomic.h>\n#include <linux/console.h>\n\n#include \"speakup.h\"\n\nunsigned short spk_xs, spk_ys, spk_xe, spk_ye;  \nstruct vc_data *spk_sel_cons;\n\nstruct speakup_selection_work {\n\tstruct work_struct work;\n\tstruct tiocl_selection sel;\n\tstruct tty_struct *tty;\n};\n\nstatic void __speakup_set_selection(struct work_struct *work)\n{\n\tstruct speakup_selection_work *ssw =\n\t\tcontainer_of(work, struct speakup_selection_work, work);\n\n\tstruct tty_struct *tty;\n\tstruct tiocl_selection sel;\n\n\tsel = ssw->sel;\n\n\t \n\trmb();\n\n\t \n\ttty = xchg(&ssw->tty, NULL);\n\n\tif (spk_sel_cons != vc_cons[fg_console].d) {\n\t\tspk_sel_cons = vc_cons[fg_console].d;\n\t\tpr_warn(\"Selection: mark console not the same as cut\\n\");\n\t\tgoto unref;\n\t}\n\n\tconsole_lock();\n\tclear_selection();\n\tconsole_unlock();\n\n\tset_selection_kernel(&sel, tty);\n\nunref:\n\ttty_kref_put(tty);\n}\n\nstatic struct speakup_selection_work speakup_sel_work = {\n\t.work = __WORK_INITIALIZER(speakup_sel_work.work,\n\t\t\t\t   __speakup_set_selection)\n};\n\nint speakup_set_selection(struct tty_struct *tty)\n{\n\t \n\ttty_kref_get(tty);\n\tif (cmpxchg(&speakup_sel_work.tty, NULL, tty)) {\n\t\ttty_kref_put(tty);\n\t\treturn -EBUSY;\n\t}\n\t \n\twmb();\n\n\tspeakup_sel_work.sel.xs = spk_xs + 1;\n\tspeakup_sel_work.sel.ys = spk_ys + 1;\n\tspeakup_sel_work.sel.xe = spk_xe + 1;\n\tspeakup_sel_work.sel.ye = spk_ye + 1;\n\tspeakup_sel_work.sel.sel_mode = TIOCL_SELCHAR;\n\n\tschedule_work_on(WORK_CPU_UNBOUND, &speakup_sel_work.work);\n\n\treturn 0;\n}\n\nvoid speakup_cancel_selection(void)\n{\n\tstruct tty_struct *tty;\n\n\tcancel_work_sync(&speakup_sel_work.work);\n\t \n\ttty = xchg(&speakup_sel_work.tty, NULL);\n\tif (tty)\n\t\ttty_kref_put(tty);\n}\n\nstatic void __speakup_paste_selection(struct work_struct *work)\n{\n\tstruct speakup_selection_work *ssw =\n\t\tcontainer_of(work, struct speakup_selection_work, work);\n\tstruct tty_struct *tty = xchg(&ssw->tty, NULL);\n\n\tpaste_selection(tty);\n\ttty_kref_put(tty);\n}\n\nstatic struct speakup_selection_work speakup_paste_work = {\n\t.work = __WORK_INITIALIZER(speakup_paste_work.work,\n\t\t\t\t   __speakup_paste_selection)\n};\n\nint speakup_paste_selection(struct tty_struct *tty)\n{\n\ttty_kref_get(tty);\n\tif (cmpxchg(&speakup_paste_work.tty, NULL, tty)) {\n\t\ttty_kref_put(tty);\n\t\treturn -EBUSY;\n\t}\n\n\tschedule_work_on(WORK_CPU_UNBOUND, &speakup_paste_work.work);\n\treturn 0;\n}\n\nvoid speakup_cancel_paste(void)\n{\n\tstruct tty_struct *tty;\n\n\tcancel_work_sync(&speakup_paste_work.work);\n\ttty = xchg(&speakup_paste_work.tty, NULL);\n\tif (tty)\n\t\ttty_kref_put(tty);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}