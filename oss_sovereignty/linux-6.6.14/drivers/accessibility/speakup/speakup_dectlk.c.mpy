{
  "module_name": "speakup_dectlk.c",
  "hash_id": "ce46eac5aec2965c4afaff232eed460dc000f0a5936bb2a937a929548daa3d04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/speakup/speakup_dectlk.c",
  "human_readable_source": "\n \n#include <linux/unistd.h>\n#include <linux/proc_fs.h>\n#include <linux/jiffies.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/kthread.h>\n#include \"speakup.h\"\n#include \"spk_priv.h\"\n\n#define DRV_VERSION \"2.20\"\n#define SYNTH_CLEAR 0x03\n#define PROCSPEECH 0x0b\nstatic int xoff;\n\nstatic inline int synth_full(void)\n{\n\treturn xoff;\n}\n\nstatic void do_catch_up(struct spk_synth *synth);\nstatic void synth_flush(struct spk_synth *synth);\nstatic void read_buff_add(u_char c);\nstatic unsigned char get_index(struct spk_synth *synth);\n\nstatic int in_escape;\nstatic int is_flushing;\n\nstatic DEFINE_SPINLOCK(flush_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(flush);\n\nenum default_vars_id {\n\tCAPS_START_ID = 0, CAPS_STOP_ID,\n\tRATE_ID, PITCH_ID, INFLECTION_ID,\n\tVOL_ID, PUNCT_ID, VOICE_ID,\n\tDIRECT_ID, V_LAST_VAR_ID,\n\tNB_ID,\n};\n\nstatic struct var_t vars[NB_ID] = {\n\t[CAPS_START_ID] = { CAPS_START, .u.s = {\"[:dv ap 160] \" } },\n\t[CAPS_STOP_ID] = { CAPS_STOP, .u.s = {\"[:dv ap 100 ] \" } },\n\t[RATE_ID] = { RATE, .u.n = {\"[:ra %d] \", 180, 75, 650, 0, 0, NULL } },\n\t[PITCH_ID] = { PITCH, .u.n = {\"[:dv ap %d] \", 122, 50, 350, 0, 0, NULL } },\n\t[INFLECTION_ID] = { INFLECTION, .u.n = {\"[:dv pr %d] \", 100, 0, 10000, 0, 0, NULL } },\n\t[VOL_ID] = { VOL, .u.n = {\"[:dv g5 %d] \", 86, 60, 86, 0, 0, NULL } },\n\t[PUNCT_ID] = { PUNCT, .u.n = {\"[:pu %c] \", 0, 0, 2, 0, 0, \"nsa\" } },\n\t[VOICE_ID] = { VOICE, .u.n = {\"[:n%c] \", 0, 0, 9, 0, 0, \"phfdburwkv\" } },\n\t[DIRECT_ID] = { DIRECT, .u.n = {NULL, 0, 0, 1, 0, 0, NULL } },\n\tV_LAST_VAR\n};\n\n \nstatic struct kobj_attribute caps_start_attribute =\n\t__ATTR(caps_start, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute caps_stop_attribute =\n\t__ATTR(caps_stop, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute pitch_attribute =\n\t__ATTR(pitch, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute inflection_attribute =\n\t__ATTR(inflection, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute punct_attribute =\n\t__ATTR(punct, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute rate_attribute =\n\t__ATTR(rate, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute voice_attribute =\n\t__ATTR(voice, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute vol_attribute =\n\t__ATTR(vol, 0644, spk_var_show, spk_var_store);\n\nstatic struct kobj_attribute delay_time_attribute =\n\t__ATTR(delay_time, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute direct_attribute =\n\t__ATTR(direct, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute full_time_attribute =\n\t__ATTR(full_time, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute flush_time_attribute =\n\t__ATTR(flush_time, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute jiffy_delta_attribute =\n\t__ATTR(jiffy_delta, 0644, spk_var_show, spk_var_store);\nstatic struct kobj_attribute trigger_time_attribute =\n\t__ATTR(trigger_time, 0644, spk_var_show, spk_var_store);\n\n \nstatic struct attribute *synth_attrs[] = {\n\t&caps_start_attribute.attr,\n\t&caps_stop_attribute.attr,\n\t&pitch_attribute.attr,\n\t&inflection_attribute.attr,\n\t&punct_attribute.attr,\n\t&rate_attribute.attr,\n\t&voice_attribute.attr,\n\t&vol_attribute.attr,\n\t&delay_time_attribute.attr,\n\t&direct_attribute.attr,\n\t&full_time_attribute.attr,\n\t&flush_time_attribute.attr,\n\t&jiffy_delta_attribute.attr,\n\t&trigger_time_attribute.attr,\n\tNULL,\t \n};\n\nstatic int ap_defaults[] = {122, 89, 155, 110, 208, 240, 200, 106, 306};\nstatic int g5_defaults[] = {86, 81, 86, 84, 81, 80, 83, 83, 73};\n\nstatic struct spk_synth synth_dectlk = {\n\t.name = \"dectlk\",\n\t.version = DRV_VERSION,\n\t.long_name = \"Dectalk Express\",\n\t.init = \"[:error sp :name paul :rate 180 :tsr off] \",\n\t.procspeech = PROCSPEECH,\n\t.clear = SYNTH_CLEAR,\n\t.delay = 500,\n\t.trigger = 50,\n\t.jiffies = 50,\n\t.full = 40000,\n\t.flush_time = 4000,\n\t.dev_name = SYNTH_DEFAULT_DEV,\n\t.startup = SYNTH_START,\n\t.checkval = SYNTH_CHECK,\n\t.vars = vars,\n\t.default_pitch = ap_defaults,\n\t.default_vol = g5_defaults,\n\t.io_ops = &spk_ttyio_ops,\n\t.probe = spk_ttyio_synth_probe,\n\t.release = spk_ttyio_release,\n\t.synth_immediate = spk_ttyio_synth_immediate,\n\t.catch_up = do_catch_up,\n\t.flush = synth_flush,\n\t.is_alive = spk_synth_is_alive_restart,\n\t.synth_adjust = NULL,\n\t.read_buff_add = read_buff_add,\n\t.get_index = get_index,\n\t.indexing = {\n\t\t.command = \"[:in re %d ] \",\n\t\t.lowindex = 1,\n\t\t.highindex = 8,\n\t\t.currindex = 1,\n\t},\n\t.attributes = {\n\t\t.attrs = synth_attrs,\n\t\t.name = \"dectlk\",\n\t},\n};\n\nstatic int is_indnum(u_char *ch)\n{\n\tif ((*ch >= '0') && (*ch <= '9')) {\n\t\t*ch = *ch - '0';\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic u_char lastind;\n\nstatic unsigned char get_index(struct spk_synth *synth)\n{\n\tu_char rv;\n\n\trv = lastind;\n\tlastind = 0;\n\treturn rv;\n}\n\nstatic void read_buff_add(u_char c)\n{\n\tstatic int ind = -1;\n\n\tif (c == 0x01) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&flush_lock, flags);\n\t\tis_flushing = 0;\n\t\twake_up_interruptible(&flush);\n\t\tspin_unlock_irqrestore(&flush_lock, flags);\n\t} else if (c == 0x13) {\n\t\txoff = 1;\n\t} else if (c == 0x11) {\n\t\txoff = 0;\n\t} else if (is_indnum(&c)) {\n\t\tif (ind == -1)\n\t\t\tind = c;\n\t\telse\n\t\t\tind = ind * 10 + c;\n\t} else if ((c > 31) && (c < 127)) {\n\t\tif (ind != -1)\n\t\t\tlastind = (u_char)ind;\n\t\tind = -1;\n\t}\n}\n\nstatic void do_catch_up(struct spk_synth *synth)\n{\n\tint synth_full_val = 0;\n\tstatic u_char ch;\n\tstatic u_char last = '\\0';\n\tunsigned long flags;\n\tunsigned long jiff_max;\n\tunsigned long timeout;\n\tDEFINE_WAIT(wait);\n\tstruct var_t *jiffy_delta;\n\tstruct var_t *delay_time;\n\tstruct var_t *flush_time;\n\tint jiffy_delta_val;\n\tint delay_time_val;\n\tint timeout_val;\n\n\tjiffy_delta = spk_get_var(JIFFY);\n\tdelay_time = spk_get_var(DELAY);\n\tflush_time = spk_get_var(FLUSH);\n\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\tjiffy_delta_val = jiffy_delta->u.n.value;\n\ttimeout_val = flush_time->u.n.value;\n\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\ttimeout = msecs_to_jiffies(timeout_val);\n\tjiff_max = jiffies + jiffy_delta_val;\n\n\twhile (!kthread_should_stop()) {\n\t\t \n\t\tspin_lock_irqsave(&flush_lock, flags);\n\t\twhile (is_flushing && timeout) {\n\t\t\tprepare_to_wait(&flush, &wait, TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irqrestore(&flush_lock, flags);\n\t\t\ttimeout = schedule_timeout(timeout);\n\t\t\tspin_lock_irqsave(&flush_lock, flags);\n\t\t}\n\t\tfinish_wait(&flush, &wait);\n\t\tis_flushing = 0;\n\t\tspin_unlock_irqrestore(&flush_lock, flags);\n\n\t\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\t\tif (speakup_info.flushing) {\n\t\t\tspeakup_info.flushing = 0;\n\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\t\tsynth->flush(synth);\n\t\t\tcontinue;\n\t\t}\n\t\tsynth_buffer_skip_nonlatin1();\n\t\tif (synth_buffer_empty()) {\n\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tch = synth_buffer_peek();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tdelay_time_val = delay_time->u.n.value;\n\t\tsynth_full_val = synth_full();\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\tif (ch == '\\n')\n\t\t\tch = 0x0D;\n\t\tif (synth_full_val || !synth->io_ops->synth_out(synth, ch)) {\n\t\t\tschedule_timeout(msecs_to_jiffies(delay_time_val));\n\t\t\tcontinue;\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t\tspin_lock_irqsave(&speakup_info.spinlock, flags);\n\t\tsynth_buffer_getc();\n\t\tspin_unlock_irqrestore(&speakup_info.spinlock, flags);\n\t\tif (ch == '[') {\n\t\t\tin_escape = 1;\n\t\t} else if (ch == ']') {\n\t\t\tin_escape = 0;\n\t\t} else if (ch <= SPACE) {\n\t\t\tif (!in_escape && strchr(\",.!?;:\", last))\n\t\t\t\tsynth->io_ops->synth_out(synth, PROCSPEECH);\n\t\t\tif (time_after_eq(jiffies, jiff_max)) {\n\t\t\t\tif (!in_escape)\n\t\t\t\t\tsynth->io_ops->synth_out(synth,\n\t\t\t\t\t\t\t\t PROCSPEECH);\n\t\t\t\tspin_lock_irqsave(&speakup_info.spinlock,\n\t\t\t\t\t\t  flags);\n\t\t\t\tjiffy_delta_val = jiffy_delta->u.n.value;\n\t\t\t\tdelay_time_val = delay_time->u.n.value;\n\t\t\t\tspin_unlock_irqrestore(&speakup_info.spinlock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tschedule_timeout(msecs_to_jiffies\n\t\t\t\t\t\t (delay_time_val));\n\t\t\t\tjiff_max = jiffies + jiffy_delta_val;\n\t\t\t}\n\t\t}\n\t\tlast = ch;\n\t}\n\tif (!in_escape)\n\t\tsynth->io_ops->synth_out(synth, PROCSPEECH);\n}\n\nstatic void synth_flush(struct spk_synth *synth)\n{\n\tif (in_escape)\n\t\t \n\t\tsynth->io_ops->synth_out(synth, ']');\n\tin_escape = 0;\n\tis_flushing = 1;\n\tsynth->io_ops->flush_buffer(synth);\n\tsynth->io_ops->synth_out(synth, SYNTH_CLEAR);\n}\n\nmodule_param_named(ser, synth_dectlk.ser, int, 0444);\nmodule_param_named(dev, synth_dectlk.dev_name, charp, 0444);\nmodule_param_named(start, synth_dectlk.startup, short, 0444);\nmodule_param_named(rate, vars[RATE_ID].u.n.default_val, int, 0444);\nmodule_param_named(pitch, vars[PITCH_ID].u.n.default_val, int, 0444);\nmodule_param_named(inflection, vars[INFLECTION_ID].u.n.default_val, int, 0444);\nmodule_param_named(vol, vars[VOL_ID].u.n.default_val, int, 0444);\nmodule_param_named(punct, vars[PUNCT_ID].u.n.default_val, int, 0444);\nmodule_param_named(voice, vars[VOICE_ID].u.n.default_val, int, 0444);\nmodule_param_named(direct, vars[DIRECT_ID].u.n.default_val, int, 0444);\n\n\n\nMODULE_PARM_DESC(ser, \"Set the serial port for the synthesizer (0-based).\");\nMODULE_PARM_DESC(dev, \"Set the device e.g. ttyUSB0, for the synthesizer.\");\nMODULE_PARM_DESC(start, \"Start the synthesizer once it is loaded.\");\nMODULE_PARM_DESC(rate, \"Set the rate variable on load.\");\nMODULE_PARM_DESC(pitch, \"Set the pitch variable on load.\");\nMODULE_PARM_DESC(inflection, \"Set the inflection variable on load.\");\nMODULE_PARM_DESC(vol, \"Set the vol variable on load.\");\nMODULE_PARM_DESC(punct, \"Set the punct variable on load.\");\nMODULE_PARM_DESC(voice, \"Set the voice variable on load.\");\nMODULE_PARM_DESC(direct, \"Set the direct variable on load.\");\n\n\nmodule_spk_synth(synth_dectlk);\n\nMODULE_AUTHOR(\"Kirk Reiser <kirk@braille.uwo.ca>\");\nMODULE_AUTHOR(\"David Borowski\");\nMODULE_DESCRIPTION(\"Speakup support for DECtalk Express synthesizers\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}