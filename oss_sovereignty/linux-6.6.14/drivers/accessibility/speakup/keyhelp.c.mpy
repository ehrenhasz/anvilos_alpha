{
  "module_name": "keyhelp.c",
  "hash_id": "1786a572dc5244b5118927853335cb6c4239c32b964e6efae42ed66589b5fb38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/accessibility/speakup/keyhelp.c",
  "human_readable_source": "\n \n\n#include <linux/keyboard.h>\n#include \"spk_priv.h\"\n#include \"speakup.h\"\n\n#define MAXFUNCS 130\n#define MAXKEYS 256\nstatic const int num_key_names = MSG_KEYNAMES_END - MSG_KEYNAMES_START + 1;\nstatic u_short key_offsets[MAXFUNCS], key_data[MAXKEYS];\nstatic u_short masks[] = { 32, 16, 8, 4, 2, 1 };\n\nstatic short letter_offsets[26] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1 };\n\nstatic u_char funcvals[] = {\n\tATTRIB_BLEEP_DEC, ATTRIB_BLEEP_INC, BLEEPS_DEC, BLEEPS_INC,\n\tSAY_FIRST_CHAR, SAY_LAST_CHAR, SAY_CHAR, SAY_CHAR_NUM,\n\tSAY_NEXT_CHAR, SAY_PHONETIC_CHAR, SAY_PREV_CHAR, SPEAKUP_PARKED,\n\tSPEAKUP_CUT, EDIT_DELIM, EDIT_EXNUM, EDIT_MOST,\n\tEDIT_REPEAT, EDIT_SOME, SPEAKUP_GOTO, BOTTOM_EDGE,\n\tLEFT_EDGE, RIGHT_EDGE, TOP_EDGE, SPEAKUP_HELP,\n\tSAY_LINE, SAY_NEXT_LINE, SAY_PREV_LINE, SAY_LINE_INDENT,\n\tSPEAKUP_PASTE, PITCH_DEC, PITCH_INC, PUNCT_DEC,\n\tPUNCT_INC, PUNC_LEVEL_DEC, PUNC_LEVEL_INC, SPEAKUP_QUIET,\n\tRATE_DEC, RATE_INC, READING_PUNC_DEC, READING_PUNC_INC,\n\tSAY_ATTRIBUTES, SAY_FROM_LEFT, SAY_FROM_TOP, SAY_POSITION,\n\tSAY_SCREEN, SAY_TO_BOTTOM, SAY_TO_RIGHT, SPK_KEY,\n\tSPK_LOCK, SPEAKUP_OFF, SPEECH_KILL, SPELL_DELAY_DEC,\n\tSPELL_DELAY_INC, SPELL_WORD, SPELL_PHONETIC, TONE_DEC,\n\tTONE_INC, VOICE_DEC, VOICE_INC, VOL_DEC,\n\tVOL_INC, CLEAR_WIN, SAY_WIN, SET_WIN,\n\tENABLE_WIN, SAY_WORD, SAY_NEXT_WORD, SAY_PREV_WORD, 0\n};\n\nstatic u_char *state_tbl;\nstatic int cur_item, nstates;\n\nstatic void build_key_data(void)\n{\n\tu_char *kp, counters[MAXFUNCS], ch, ch1;\n\tu_short *p_key, key;\n\tint i, offset = 1;\n\n\tnstates = (int)(state_tbl[-1]);\n\tmemset(counters, 0, sizeof(counters));\n\tmemset(key_offsets, 0, sizeof(key_offsets));\n\tkp = state_tbl + nstates + 1;\n\twhile (*kp++) {\n\t\t \n\t\tfor (i = 0; i < nstates; i++, kp++) {\n\t\t\tif (!*kp)\n\t\t\t\tcontinue;\n\t\t\tif ((state_tbl[i] & 16) != 0 && *kp == SPK_KEY)\n\t\t\t\tcontinue;\n\t\t\tcounters[*kp]++;\n\t\t}\n\t}\n\tfor (i = 0; i < MAXFUNCS; i++) {\n\t\tif (counters[i] == 0)\n\t\t\tcontinue;\n\t\tkey_offsets[i] = offset;\n\t\toffset += (counters[i] + 1);\n\t\tif (offset >= MAXKEYS)\n\t\t\tbreak;\n\t}\n \n\tkp = state_tbl + nstates + 1;\n\twhile ((ch = *kp++)) {\n\t\tfor (i = 0; i < nstates; i++) {\n\t\t\tch1 = *kp++;\n\t\t\tif (!ch1)\n\t\t\t\tcontinue;\n\t\t\tif ((state_tbl[i] & 16) != 0 && ch1 == SPK_KEY)\n\t\t\t\tcontinue;\n\t\t\tkey = (state_tbl[i] << 8) + ch;\n\t\t\tcounters[ch1]--;\n\t\t\toffset = key_offsets[ch1];\n\t\t\tif (!offset)\n\t\t\t\tcontinue;\n\t\t\tp_key = key_data + offset + counters[ch1];\n\t\t\t*p_key = key;\n\t\t}\n\t}\n}\n\nstatic void say_key(int key)\n{\n\tint i, state = key >> 8;\n\n\tkey &= 0xff;\n\tfor (i = 0; i < 6; i++) {\n\t\tif (state & masks[i])\n\t\t\tsynth_printf(\" %s\", spk_msg_get(MSG_STATES_START + i));\n\t}\n\tif ((key > 0) && (key <= num_key_names))\n\t\tsynth_printf(\" %s\\n\",\n\t\t\t     spk_msg_get(MSG_KEYNAMES_START + (key - 1)));\n}\n\nstatic int help_init(void)\n{\n\tchar start = SPACE;\n\tint i;\n\tint num_funcs = MSG_FUNCNAMES_END - MSG_FUNCNAMES_START + 1;\n\n\tstate_tbl = spk_our_keys[0] + SHIFT_TBL_SIZE + 2;\n\tfor (i = 0; i < num_funcs; i++) {\n\t\tchar *cur_funcname = spk_msg_get(MSG_FUNCNAMES_START + i);\n\n\t\tif (start == *cur_funcname)\n\t\t\tcontinue;\n\t\tstart = *cur_funcname;\n\t\tletter_offsets[(start & 31) - 1] = i;\n\t}\n\treturn 0;\n}\n\nint spk_handle_help(struct vc_data *vc, u_char type, u_char ch, u_short key)\n{\n\tint i, n;\n\tchar *name;\n\tu_char func, *kp;\n\tu_short *p_keys, val;\n\n\tif (letter_offsets[0] == -1)\n\t\thelp_init();\n\tif (type == KT_LATIN) {\n\t\tif (ch == SPACE) {\n\t\t\tspk_special_handler = NULL;\n\t\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_LEAVING_HELP));\n\t\t\treturn 1;\n\t\t}\n\t\tch |= 32;  \n\t\tif (ch < 'a' || ch > 'z')\n\t\t\treturn -1;\n\t\tif (letter_offsets[ch - 'a'] == -1) {\n\t\t\tsynth_printf(spk_msg_get(MSG_NO_COMMAND), ch);\n\t\t\tsynth_printf(\"\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tcur_item = letter_offsets[ch - 'a'];\n\t} else if (type == KT_CUR) {\n\t\tif (ch == 0 &&\n\t\t    (MSG_FUNCNAMES_START + cur_item + 1) <= MSG_FUNCNAMES_END)\n\t\t\tcur_item++;\n\t\telse if (ch == 3 && cur_item > 0)\n\t\t\tcur_item--;\n\t\telse\n\t\t\treturn -1;\n\t} else if (type == KT_SPKUP && ch == SPEAKUP_HELP &&\n\t\t   !spk_special_handler) {\n\t\tspk_special_handler = spk_handle_help;\n\t\tsynth_printf(\"%s\\n\", spk_msg_get(MSG_HELP_INFO));\n\t\tbuild_key_data();  \n\t\treturn 1;\n\t} else {\n\t\tname = NULL;\n\t\tif ((type != KT_SPKUP) && (key > 0) && (key <= num_key_names)) {\n\t\t\tsynth_printf(\"%s\\n\",\n\t\t\t\t     spk_msg_get(MSG_KEYNAMES_START + key - 1));\n\t\t\treturn 1;\n\t\t}\n\t\tfor (i = 0; funcvals[i] != 0 && !name; i++) {\n\t\t\tif (ch == funcvals[i])\n\t\t\t\tname = spk_msg_get(MSG_FUNCNAMES_START + i);\n\t\t}\n\t\tif (!name)\n\t\t\treturn -1;\n\t\tkp = spk_our_keys[key] + 1;\n\t\tfor (i = 0; i < nstates; i++) {\n\t\t\tif (ch == kp[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tkey += (state_tbl[i] << 8);\n\t\tsay_key(key);\n\t\tsynth_printf(spk_msg_get(MSG_KEYDESC), name);\n\t\tsynth_printf(\"\\n\");\n\t\treturn 1;\n\t}\n\tname = spk_msg_get(MSG_FUNCNAMES_START + cur_item);\n\tfunc = funcvals[cur_item];\n\tsynth_printf(\"%s\", name);\n\tif (key_offsets[func] == 0) {\n\t\tsynth_printf(\" %s\\n\", spk_msg_get(MSG_IS_UNASSIGNED));\n\t\treturn 1;\n\t}\n\tp_keys = key_data + key_offsets[func];\n\tfor (n = 0; p_keys[n]; n++) {\n\t\tval = p_keys[n];\n\t\tif (n > 0)\n\t\t\tsynth_printf(\"%s \", spk_msg_get(MSG_DISJUNCTION));\n\t\tsay_key(val);\n\t}\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}