{
  "module_name": "ufs-hisi.c",
  "hash_id": "c1a3e1df49361e1feffbcb595a5801223ff34ad972f2f19e640f5eefc1662411",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ufs/host/ufs-hisi.c",
  "human_readable_source": "\n \n\n#include <linux/time.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#include <ufs/ufshcd.h>\n#include \"ufshcd-pltfrm.h\"\n#include <ufs/unipro.h>\n#include \"ufs-hisi.h\"\n#include <ufs/ufshci.h>\n#include <ufs/ufs_quirks.h>\n\nstatic int ufs_hisi_check_hibern8(struct ufs_hba *hba)\n{\n\tint err = 0;\n\tu32 tx_fsm_val_0 = 0;\n\tu32 tx_fsm_val_1 = 0;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(HBRN8_POLL_TOUT_MS);\n\n\tdo {\n\t\terr = ufshcd_dme_get(hba, UIC_ARG_MIB_SEL(MPHY_TX_FSM_STATE, 0),\n\t\t\t\t      &tx_fsm_val_0);\n\t\terr |= ufshcd_dme_get(hba,\n\t\t    UIC_ARG_MIB_SEL(MPHY_TX_FSM_STATE, 1), &tx_fsm_val_1);\n\t\tif (err || (tx_fsm_val_0 == TX_FSM_HIBERN8 &&\n\t\t\ttx_fsm_val_1 == TX_FSM_HIBERN8))\n\t\t\tbreak;\n\n\t\t \n\t\tusleep_range(100, 200);\n\t} while (time_before(jiffies, timeout));\n\n\t \n\tif (time_after(jiffies, timeout)) {\n\t\terr = ufshcd_dme_get(hba, UIC_ARG_MIB_SEL(MPHY_TX_FSM_STATE, 0),\n\t\t\t\t     &tx_fsm_val_0);\n\t\terr |= ufshcd_dme_get(hba,\n\t\t UIC_ARG_MIB_SEL(MPHY_TX_FSM_STATE, 1), &tx_fsm_val_1);\n\t}\n\n\tif (err) {\n\t\tdev_err(hba->dev, \"%s: unable to get TX_FSM_STATE, err %d\\n\",\n\t\t\t__func__, err);\n\t} else if (tx_fsm_val_0 != TX_FSM_HIBERN8 ||\n\t\t\t tx_fsm_val_1 != TX_FSM_HIBERN8) {\n\t\terr = -1;\n\t\tdev_err(hba->dev, \"%s: invalid TX_FSM_STATE, lane0 = %d, lane1 = %d\\n\",\n\t\t\t__func__, tx_fsm_val_0, tx_fsm_val_1);\n\t}\n\n\treturn err;\n}\n\nstatic void ufs_hisi_clk_init(struct ufs_hba *hba)\n{\n\tstruct ufs_hisi_host *host = ufshcd_get_variant(hba);\n\n\tufs_sys_ctrl_clr_bits(host, BIT_SYSCTRL_REF_CLOCK_EN, PHY_CLK_CTRL);\n\tif (ufs_sys_ctrl_readl(host, PHY_CLK_CTRL) & BIT_SYSCTRL_REF_CLOCK_EN)\n\t\tmdelay(1);\n\t \n\tufs_sys_ctrl_clr_bits(host, BIT_UFS_REFCLK_SRC_SEl, UFS_SYSCTRL);\n\tufs_sys_ctrl_clr_bits(host, BIT_UFS_REFCLK_ISO_EN, PHY_ISO_EN);\n\t \n\tufs_sys_ctrl_set_bits(host, BIT_SYSCTRL_REF_CLOCK_EN, PHY_CLK_CTRL);\n}\n\nstatic void ufs_hisi_soc_init(struct ufs_hba *hba)\n{\n\tstruct ufs_hisi_host *host = ufshcd_get_variant(hba);\n\tu32 reg;\n\n\tif (!IS_ERR(host->rst))\n\t\treset_control_assert(host->rst);\n\n\t \n\tufs_sys_ctrl_set_bits(host, BIT_UFS_PSW_MTCMOS_EN, PSW_POWER_CTRL);\n\tudelay(10);\n\t \n\tufs_sys_ctrl_set_bits(host, BIT_SYSCTRL_PWR_READY, HC_LP_CTRL);\n\tufs_sys_ctrl_writel(host, MASK_UFS_DEVICE_RESET | 0,\n\t\tUFS_DEVICE_RESET_CTRL);\n\n\treg = ufs_sys_ctrl_readl(host, PHY_CLK_CTRL);\n\treg = (reg & ~MASK_SYSCTRL_CFG_CLOCK_FREQ) | UFS_FREQ_CFG_CLK;\n\t \n\tufs_sys_ctrl_writel(host, reg, PHY_CLK_CTRL);\n\t \n\tufs_sys_ctrl_clr_bits(host, MASK_SYSCTRL_REF_CLOCK_SEL, PHY_CLK_CTRL);\n\t \n\tufs_sys_ctrl_set_bits(host, MASK_UFS_CLK_GATE_BYPASS,\n\t\t\t\t\t\t CLOCK_GATE_BYPASS);\n\tufs_sys_ctrl_set_bits(host, MASK_UFS_SYSCRTL_BYPASS, UFS_SYSCTRL);\n\n\t \n\tufs_sys_ctrl_set_bits(host, BIT_SYSCTRL_PSW_CLK_EN, PSW_CLK_CTRL);\n\t \n\tufs_sys_ctrl_clr_bits(host, BIT_UFS_PSW_ISO_CTRL, PSW_POWER_CTRL);\n\t \n\tufs_sys_ctrl_clr_bits(host, BIT_UFS_PHY_ISO_CTRL, PHY_ISO_EN);\n\t \n\tufs_sys_ctrl_clr_bits(host, BIT_SYSCTRL_LP_ISOL_EN, HC_LP_CTRL);\n\n\t \n\tufs_sys_ctrl_set_bits(host, BIT_SYSCTRL_LP_RESET_N, RESET_CTRL_EN);\n\tmdelay(1);\n\n\tufs_sys_ctrl_writel(host, MASK_UFS_DEVICE_RESET | BIT_UFS_DEVICE_RESET,\n\t\tUFS_DEVICE_RESET_CTRL);\n\n\tmsleep(20);\n\n\t \n\tufs_sys_ctrl_writel(host, 0x03300330, UFS_DEVICE_RESET_CTRL);\n\n\tif (!IS_ERR(host->rst))\n\t\treset_control_deassert(host->rst);\n}\n\nstatic int ufs_hisi_link_startup_pre_change(struct ufs_hba *hba)\n{\n\tstruct ufs_hisi_host *host = ufshcd_get_variant(hba);\n\tint err;\n\tuint32_t value;\n\tuint32_t reg;\n\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0xD0C1, 0x0), 0x1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x156A, 0x0), 0x2);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x8114, 0x0), 0x1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x8121, 0x0), 0x2D);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x8122, 0x0), 0x1);\n\n\tif (host->caps & UFS_HISI_CAP_PHY10nm) {\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x8127, 0x0), 0x98);\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x8128, 0x0), 0x1);\n\t}\n\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0xD085, 0x0), 0x1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x800D, 0x4), 0x58);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x800D, 0x5), 0x58);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x800E, 0x4), 0xB);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x800E, 0x5), 0xB);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x8009, 0x4), 0x1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x8009, 0x5), 0x1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0xD085, 0x0), 0x1);\n\n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x8113, 0x0), 0x1);\n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0xD085, 0x0), 0x1);\n\n\tif (host->caps & UFS_HISI_CAP_PHY10nm) {\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x0092, 0x4), 0xA);\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x0092, 0x5), 0xA);\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x008f, 0x4), 0xA);\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x008f, 0x5), 0xA);\n\t} else {\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x008F, 0x4), 0x7);\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x008F, 0x5), 0x7);\n\t}\n\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x0095, 0x4), 0x4F);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x0095, 0x5), 0x4F);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x0094, 0x4), 0x4F);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x0094, 0x5), 0x4F);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x008B, 0x4), 0x4F);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x008B, 0x5), 0x4F);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x000F, 0x0), 0x5);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0x000F, 0x1), 0x5);\n\n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0xD085, 0x0), 0x1);\n\t \n\tufshcd_dme_get(hba, UIC_ARG_MIB_SEL(0xD0C1, 0x0), &value);\n\tif (value != 0x1)\n\t\tdev_info(hba->dev,\n\t\t    \"Warring!!! Unipro VS_mphy_disable is 0x%x\\n\", value);\n\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0xD0C1, 0x0), 0x0);\n\terr = ufs_hisi_check_hibern8(hba);\n\tif (err)\n\t\tdev_err(hba->dev, \"ufs_hisi_check_hibern8 error\\n\");\n\n\tif (!(host->caps & UFS_HISI_CAP_PHY10nm))\n\t\tufshcd_writel(hba, UFS_HCLKDIV_NORMAL_VALUE, UFS_REG_HCLKDIV);\n\n\t \n\treg = ufshcd_readl(hba, REG_AUTO_HIBERNATE_IDLE_TIMER);\n\treg = reg & (~UFS_AHIT_AH8ITV_MASK);\n\tufshcd_writel(hba, reg, REG_AUTO_HIBERNATE_IDLE_TIMER);\n\n\t \n\tufshcd_disable_host_tx_lcc(hba);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0xD0AB, 0x0), 0x0);\n\tufshcd_dme_get(hba, UIC_ARG_MIB_SEL(0xD0AB, 0x0), &value);\n\tif (value != 0) {\n\t\t \n\t\tdev_info(hba->dev, \"WARN: close VS_Mk2ExtnSupport failed\\n\");\n\t}\n\n\treturn err;\n}\n\nstatic int ufs_hisi_link_startup_post_change(struct ufs_hba *hba)\n{\n\tstruct ufs_hisi_host *host = ufshcd_get_variant(hba);\n\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0x2044), 0x0);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0x2045), 0x0);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0x2040), 0x9);\n\n\t \n\tufs_sys_ctrl_clr_bits(host, MASK_UFS_CLK_GATE_BYPASS,\n\t\t\t\t\t\tCLOCK_GATE_BYPASS);\n\tufs_sys_ctrl_clr_bits(host, MASK_UFS_SYSCRTL_BYPASS,\n\t\t\t\t\t\tUFS_SYSCTRL);\n\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0xd09a), 0x80000000);\n\t  \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0xd09c), 0x00000005);\n\n\treturn 0;\n}\n\nstatic int ufs_hisi_link_startup_notify(struct ufs_hba *hba,\n\t\t\t\t\t  enum ufs_notify_change_status status)\n{\n\tint err = 0;\n\n\tswitch (status) {\n\tcase PRE_CHANGE:\n\t\terr = ufs_hisi_link_startup_pre_change(hba);\n\t\tbreak;\n\tcase POST_CHANGE:\n\t\terr = ufs_hisi_link_startup_post_change(hba);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void ufs_hisi_set_dev_cap(struct ufs_dev_params *hisi_param)\n{\n\tufshcd_init_pwr_dev_param(hisi_param);\n}\n\nstatic void ufs_hisi_pwr_change_pre_change(struct ufs_hba *hba)\n{\n\tstruct ufs_hisi_host *host = ufshcd_get_variant(hba);\n\n\tif (host->caps & UFS_HISI_CAP_PHY10nm) {\n\t\t \n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB((u32)0xD0A0), 0x13);\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB((u32)0x1552), 0x4f);\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB((u32)0x1554), 0x4f);\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB((u32)0x1556), 0x4f);\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB((u32)0x15a7), 0xA);\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB((u32)0x15a8), 0xA);\n\t\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(0xd085, 0x0), 0x01);\n\t}\n\n\tif (hba->dev_quirks & UFS_DEVICE_QUIRK_HOST_VS_DEBUGSAVECONFIGTIME) {\n\t\tpr_info(\"ufs flash device must set VS_DebugSaveConfigTime 0x10\\n\");\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB(0xD0A0), 0x10);\n\t\t \n\t\tufshcd_dme_set(hba, UIC_ARG_MIB(0x1556), 0x48);\n\t}\n\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0x15A8), 0x1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0x155c), 0x0);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0x15b0), SZ_8K - 1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0x15b1), SZ_64K - 1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0x15b2), SZ_32K - 1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0xd041), SZ_8K - 1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0xd042), SZ_64K - 1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0xd043), SZ_32K - 1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0x15b3), SZ_8K - 1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0x15b4), SZ_64K - 1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0x15b5), SZ_32K - 1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0xd044), SZ_8K - 1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0xd045), SZ_64K - 1);\n\t \n\tufshcd_dme_set(hba, UIC_ARG_MIB(0xd046), SZ_32K - 1);\n}\n\nstatic int ufs_hisi_pwr_change_notify(struct ufs_hba *hba,\n\t\t\t\t       enum ufs_notify_change_status status,\n\t\t\t\t       struct ufs_pa_layer_attr *dev_max_params,\n\t\t\t\t       struct ufs_pa_layer_attr *dev_req_params)\n{\n\tstruct ufs_dev_params ufs_hisi_cap;\n\tint ret = 0;\n\n\tif (!dev_req_params) {\n\t\tdev_err(hba->dev,\n\t\t\t    \"%s: incoming dev_req_params is NULL\\n\", __func__);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (status) {\n\tcase PRE_CHANGE:\n\t\tufs_hisi_set_dev_cap(&ufs_hisi_cap);\n\t\tret = ufshcd_get_pwr_dev_param(&ufs_hisi_cap,\n\t\t\t\t\t       dev_max_params, dev_req_params);\n\t\tif (ret) {\n\t\t\tdev_err(hba->dev,\n\t\t\t    \"%s: failed to determine capabilities\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\n\t\tufs_hisi_pwr_change_pre_change(hba);\n\t\tbreak;\n\tcase POST_CHANGE:\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int ufs_hisi_suspend_prepare(struct device *dev)\n{\n\t \n\treturn __ufshcd_suspend_prepare(dev, false);\n}\n\nstatic int ufs_hisi_suspend(struct ufs_hba *hba, enum ufs_pm_op pm_op,\n\tenum ufs_notify_change_status status)\n{\n\tstruct ufs_hisi_host *host = ufshcd_get_variant(hba);\n\n\tif (status == PRE_CHANGE)\n\t\treturn 0;\n\n\tif (pm_op == UFS_RUNTIME_PM)\n\t\treturn 0;\n\n\tif (host->in_suspend) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tufs_sys_ctrl_clr_bits(host, BIT_SYSCTRL_REF_CLOCK_EN, PHY_CLK_CTRL);\n\tudelay(10);\n\t \n\tufs_sys_ctrl_writel(host, 0x00100000, UFS_DEVICE_RESET_CTRL);\n\n\thost->in_suspend = true;\n\n\treturn 0;\n}\n\nstatic int ufs_hisi_resume(struct ufs_hba *hba, enum ufs_pm_op pm_op)\n{\n\tstruct ufs_hisi_host *host = ufshcd_get_variant(hba);\n\n\tif (!host->in_suspend)\n\t\treturn 0;\n\n\t \n\tufs_sys_ctrl_writel(host, 0x00100010, UFS_DEVICE_RESET_CTRL);\n\tudelay(10);\n\tufs_sys_ctrl_set_bits(host, BIT_SYSCTRL_REF_CLOCK_EN, PHY_CLK_CTRL);\n\n\thost->in_suspend = false;\n\treturn 0;\n}\n\nstatic int ufs_hisi_get_resource(struct ufs_hisi_host *host)\n{\n\tstruct device *dev = host->hba->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\t \n\thost->ufs_sys_ctrl = devm_platform_ioremap_resource(pdev, 1);\n\treturn PTR_ERR_OR_ZERO(host->ufs_sys_ctrl);\n}\n\nstatic void ufs_hisi_set_pm_lvl(struct ufs_hba *hba)\n{\n\thba->rpm_lvl = UFS_PM_LVL_1;\n\thba->spm_lvl = UFS_PM_LVL_3;\n}\n\n \nstatic int ufs_hisi_init_common(struct ufs_hba *hba)\n{\n\tint err = 0;\n\tstruct device *dev = hba->dev;\n\tstruct ufs_hisi_host *host;\n\n\thost = devm_kzalloc(dev, sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->hba = hba;\n\tufshcd_set_variant(hba, host);\n\n\thost->rst = devm_reset_control_get(dev, \"rst\");\n\tif (IS_ERR(host->rst)) {\n\t\tdev_err(dev, \"%s: failed to get reset control\\n\", __func__);\n\t\terr = PTR_ERR(host->rst);\n\t\tgoto error;\n\t}\n\n\tufs_hisi_set_pm_lvl(hba);\n\n\terr = ufs_hisi_get_resource(host);\n\tif (err)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tufshcd_set_variant(hba, NULL);\n\treturn err;\n}\n\nstatic int ufs_hi3660_init(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tstruct device *dev = hba->dev;\n\n\tret = ufs_hisi_init_common(hba);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: ufs common init fail\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tufs_hisi_clk_init(hba);\n\n\tufs_hisi_soc_init(hba);\n\n\treturn 0;\n}\n\nstatic int ufs_hi3670_init(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tstruct device *dev = hba->dev;\n\tstruct ufs_hisi_host *host;\n\n\tret = ufs_hisi_init_common(hba);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: ufs common init fail\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tufs_hisi_clk_init(hba);\n\n\tufs_hisi_soc_init(hba);\n\n\t \n\thost = ufshcd_get_variant(hba);\n\thost->caps |= UFS_HISI_CAP_PHY10nm;\n\n\treturn 0;\n}\n\nstatic const struct ufs_hba_variant_ops ufs_hba_hi3660_vops = {\n\t.name = \"hi3660\",\n\t.init = ufs_hi3660_init,\n\t.link_startup_notify = ufs_hisi_link_startup_notify,\n\t.pwr_change_notify = ufs_hisi_pwr_change_notify,\n\t.suspend = ufs_hisi_suspend,\n\t.resume = ufs_hisi_resume,\n};\n\nstatic const struct ufs_hba_variant_ops ufs_hba_hi3670_vops = {\n\t.name = \"hi3670\",\n\t.init = ufs_hi3670_init,\n\t.link_startup_notify = ufs_hisi_link_startup_notify,\n\t.pwr_change_notify = ufs_hisi_pwr_change_notify,\n\t.suspend = ufs_hisi_suspend,\n\t.resume = ufs_hisi_resume,\n};\n\nstatic const struct of_device_id ufs_hisi_of_match[] = {\n\t{ .compatible = \"hisilicon,hi3660-ufs\", .data = &ufs_hba_hi3660_vops },\n\t{ .compatible = \"hisilicon,hi3670-ufs\", .data = &ufs_hba_hi3670_vops },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, ufs_hisi_of_match);\n\nstatic int ufs_hisi_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *of_id;\n\n\tof_id = of_match_node(ufs_hisi_of_match, pdev->dev.of_node);\n\n\treturn ufshcd_pltfrm_init(pdev, of_id->data);\n}\n\nstatic int ufs_hisi_remove(struct platform_device *pdev)\n{\n\tstruct ufs_hba *hba =  platform_get_drvdata(pdev);\n\n\tufshcd_remove(hba);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ufs_hisi_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(ufshcd_system_suspend, ufshcd_system_resume)\n\tSET_RUNTIME_PM_OPS(ufshcd_runtime_suspend, ufshcd_runtime_resume, NULL)\n\t.prepare\t = ufs_hisi_suspend_prepare,\n\t.complete\t = ufshcd_resume_complete,\n};\n\nstatic struct platform_driver ufs_hisi_pltform = {\n\t.probe\t= ufs_hisi_probe,\n\t.remove\t= ufs_hisi_remove,\n\t.driver\t= {\n\t\t.name\t= \"ufshcd-hisi\",\n\t\t.pm\t= &ufs_hisi_pm_ops,\n\t\t.of_match_table = ufs_hisi_of_match,\n\t},\n};\nmodule_platform_driver(ufs_hisi_pltform);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:ufshcd-hisi\");\nMODULE_DESCRIPTION(\"HiSilicon Hixxxx UFS Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}