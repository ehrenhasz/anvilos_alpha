{
  "module_name": "ufs-sprd.c",
  "hash_id": "3bda12fd88599a7630888dbca7f90fb87222c3841e1f9f1390e88db576b4c2d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ufs/host/ufs-sprd.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/regulator/consumer.h>\n\n#include <ufs/ufshcd.h>\n#include \"ufshcd-pltfrm.h\"\n#include \"ufs-sprd.h\"\n\nstatic const struct of_device_id ufs_sprd_of_match[];\n\nstatic struct ufs_sprd_priv *ufs_sprd_get_priv_data(struct ufs_hba *hba)\n{\n\tstruct ufs_sprd_host *host = ufshcd_get_variant(hba);\n\n\tWARN_ON(!host->priv);\n\treturn host->priv;\n}\n\nstatic void ufs_sprd_regmap_update(struct ufs_sprd_priv *priv, unsigned int index,\n\t\t\t\tunsigned int reg, unsigned int bits,  unsigned int val)\n{\n\tregmap_update_bits(priv->sysci[index].regmap, reg, bits, val);\n}\n\nstatic void ufs_sprd_regmap_read(struct ufs_sprd_priv *priv, unsigned int index,\n\t\t\t\tunsigned int reg, unsigned int *val)\n{\n\tregmap_read(priv->sysci[index].regmap, reg, val);\n}\n\nstatic void ufs_sprd_get_unipro_ver(struct ufs_hba *hba)\n{\n\tstruct ufs_sprd_host *host = ufshcd_get_variant(hba);\n\n\tif (ufshcd_dme_get(hba, UIC_ARG_MIB(PA_LOCALVERINFO), &host->unipro_ver))\n\t\thost->unipro_ver = 0;\n}\n\nstatic void ufs_sprd_ctrl_uic_compl(struct ufs_hba *hba, bool enable)\n{\n\tu32 set = ufshcd_readl(hba, REG_INTERRUPT_ENABLE);\n\n\tif (enable == true)\n\t\tset |= UIC_COMMAND_COMPL;\n\telse\n\t\tset &= ~UIC_COMMAND_COMPL;\n\tufshcd_writel(hba, set, REG_INTERRUPT_ENABLE);\n}\n\nstatic int ufs_sprd_get_reset_ctrl(struct device *dev, struct ufs_sprd_rst *rci)\n{\n\trci->rc = devm_reset_control_get(dev, rci->name);\n\tif (IS_ERR(rci->rc)) {\n\t\tdev_err(dev, \"failed to get reset ctrl:%s\\n\", rci->name);\n\t\treturn PTR_ERR(rci->rc);\n\t}\n\n\treturn 0;\n}\n\nstatic int ufs_sprd_get_syscon_reg(struct device *dev, struct ufs_sprd_syscon *sysci)\n{\n\tsysci->regmap = syscon_regmap_lookup_by_phandle(dev->of_node, sysci->name);\n\tif (IS_ERR(sysci->regmap)) {\n\t\tdev_err(dev, \"failed to get ufs syscon:%s\\n\", sysci->name);\n\t\treturn PTR_ERR(sysci->regmap);\n\t}\n\n\treturn 0;\n}\n\nstatic int ufs_sprd_get_vreg(struct device *dev, struct ufs_sprd_vreg *vregi)\n{\n\tvregi->vreg = devm_regulator_get(dev, vregi->name);\n\tif (IS_ERR(vregi->vreg)) {\n\t\tdev_err(dev, \"failed to get vreg:%s\\n\", vregi->name);\n\t\treturn PTR_ERR(vregi->vreg);\n\t}\n\n\treturn 0;\n}\n\nstatic int ufs_sprd_parse_dt(struct device *dev, struct ufs_hba *hba, struct ufs_sprd_host *host)\n{\n\tu32 i;\n\tstruct ufs_sprd_priv *priv = host->priv;\n\tint ret = 0;\n\n\t \n\tfor (i = 0; i < SPRD_UFS_RST_MAX; i++) {\n\t\tif (!priv->rci[i].name)\n\t\t\tcontinue;\n\t\tret = ufs_sprd_get_reset_ctrl(dev, &priv->rci[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < SPRD_UFS_SYSCON_MAX; i++) {\n\t\tif (!priv->sysci[i].name)\n\t\t\tcontinue;\n\t\tret = ufs_sprd_get_syscon_reg(dev, &priv->sysci[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < SPRD_UFS_VREG_MAX; i++) {\n\t\tif (!priv->vregi[i].name)\n\t\t\tcontinue;\n\t\tret = ufs_sprd_get_vreg(dev, &priv->vregi[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int ufs_sprd_common_init(struct ufs_hba *hba)\n{\n\tstruct device *dev = hba->dev;\n\tstruct ufs_sprd_host *host;\n\tstruct platform_device __maybe_unused *pdev = to_platform_device(dev);\n\tconst struct of_device_id *of_id;\n\tint ret = 0;\n\n\thost = devm_kzalloc(dev, sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tof_id = of_match_node(ufs_sprd_of_match, pdev->dev.of_node);\n\tif (of_id->data != NULL)\n\t\thost->priv = container_of(of_id->data, struct ufs_sprd_priv,\n\t\t\t\t\t  ufs_hba_sprd_vops);\n\n\thost->hba = hba;\n\tufshcd_set_variant(hba, host);\n\n\thba->caps |= UFSHCD_CAP_CLK_GATING |\n\t\tUFSHCD_CAP_CRYPTO |\n\t\tUFSHCD_CAP_WB_EN;\n\thba->quirks |= UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS;\n\n\tret = ufs_sprd_parse_dt(dev, hba, host);\n\n\treturn ret;\n}\n\nstatic int sprd_ufs_pwr_change_notify(struct ufs_hba *hba,\n\t\t\t\t      enum ufs_notify_change_status status,\n\t\t\t\t      struct ufs_pa_layer_attr *dev_max_params,\n\t\t\t\t      struct ufs_pa_layer_attr *dev_req_params)\n{\n\tstruct ufs_sprd_host *host = ufshcd_get_variant(hba);\n\n\tif (status == PRE_CHANGE) {\n\t\tmemcpy(dev_req_params, dev_max_params,\n\t\t\tsizeof(struct ufs_pa_layer_attr));\n\t\tif (host->unipro_ver >= UFS_UNIPRO_VER_1_8)\n\t\t\tufshcd_dme_configure_adapt(hba, dev_req_params->gear_tx,\n\t\t\t\t\t\t   PA_INITIAL_ADAPT);\n\t}\n\n\treturn 0;\n}\n\nstatic int ufs_sprd_suspend(struct ufs_hba *hba, enum ufs_pm_op pm_op,\n\t\t\t    enum ufs_notify_change_status status)\n{\n\tunsigned long flags;\n\n\tif (status == PRE_CHANGE) {\n\t\tif (ufshcd_is_auto_hibern8_supported(hba)) {\n\t\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t\t\tufshcd_writel(hba, 0, REG_AUTO_HIBERNATE_IDLE_TIMER);\n\t\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ufs_sprd_n6_host_reset(struct ufs_hba *hba)\n{\n\tstruct ufs_sprd_priv *priv = ufs_sprd_get_priv_data(hba);\n\n\tdev_info(hba->dev, \"ufs host reset!\\n\");\n\n\treset_control_assert(priv->rci[SPRD_UFSHCI_SOFT_RST].rc);\n\tusleep_range(1000, 1100);\n\treset_control_deassert(priv->rci[SPRD_UFSHCI_SOFT_RST].rc);\n}\n\nstatic int ufs_sprd_n6_device_reset(struct ufs_hba *hba)\n{\n\tstruct ufs_sprd_priv *priv = ufs_sprd_get_priv_data(hba);\n\n\tdev_info(hba->dev, \"ufs device reset!\\n\");\n\n\treset_control_assert(priv->rci[SPRD_UFS_DEV_RST].rc);\n\tusleep_range(1000, 1100);\n\treset_control_deassert(priv->rci[SPRD_UFS_DEV_RST].rc);\n\n\treturn 0;\n}\n\nstatic void ufs_sprd_n6_key_acc_enable(struct ufs_hba *hba)\n{\n\tu32 val;\n\tu32 retry = 10;\n\tstruct arm_smccc_res res;\n\ncheck_hce:\n\t \n\tval = ufshcd_readl(hba, REG_CONTROLLER_ENABLE);\n\tif (!(val & CONTROLLER_ENABLE)) {\n\t\tufs_sprd_n6_host_reset(hba);\n\t\tval |= CONTROLLER_ENABLE;\n\t\tufshcd_writel(hba, val, REG_CONTROLLER_ENABLE);\n\t\tusleep_range(1000, 1100);\n\t\tif (retry) {\n\t\t\tretry--;\n\t\t\tgoto check_hce;\n\t\t}\n\t\tgoto disable_crypto;\n\t}\n\n\tarm_smccc_smc(SPRD_SIP_SVC_STORAGE_UFS_CRYPTO_ENABLE,\n\t\t      0, 0, 0, 0, 0, 0, 0, &res);\n\tif (!res.a0)\n\t\treturn;\n\ndisable_crypto:\n\tdev_err(hba->dev, \"key reg access enable fail, disable crypto\\n\");\n\thba->caps &= ~UFSHCD_CAP_CRYPTO;\n}\n\nstatic int ufs_sprd_n6_init(struct ufs_hba *hba)\n{\n\tstruct ufs_sprd_priv *priv;\n\tint ret = 0;\n\n\tret = ufs_sprd_common_init(hba);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tpriv = ufs_sprd_get_priv_data(hba);\n\n\tret = regulator_enable(priv->vregi[SPRD_UFS_VDD_MPHY].vreg);\n\tif (ret)\n\t\treturn -ENODEV;\n\n\tif (hba->caps & UFSHCD_CAP_CRYPTO)\n\t\tufs_sprd_n6_key_acc_enable(hba);\n\n\treturn 0;\n}\n\nstatic int ufs_sprd_n6_phy_init(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tuint32_t val = 0;\n\tuint32_t retry = 10;\n\tuint32_t offset;\n\tstruct ufs_sprd_priv *priv = ufs_sprd_get_priv_data(hba);\n\n\tufshcd_dme_set(hba, UIC_ARG_MIB(CBREFCLKCTRL2), 0x90);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(CBCRCTRL), 0x01);\n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(RXSQCONTROL,\n\t\t\t\tUIC_ARG_MPHY_RX_GEN_SEL_INDEX(0)), 0x01);\n\tufshcd_dme_set(hba, UIC_ARG_MIB_SEL(RXSQCONTROL,\n\t\t\t\tUIC_ARG_MPHY_RX_GEN_SEL_INDEX(1)), 0x01);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(VS_MPHYCFGUPDT), 0x01);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(CBRATESEL), 0x01);\n\n\tdo {\n\t\t \n\t\tufs_sprd_regmap_read(priv, SPRD_UFS_ANLG, 0xc, &val);\n\t\tif ((val & 0x1) == 0x1) {\n\t\t\tfor (offset = 0x40; offset < 0x42; offset++) {\n\t\t\t\t \n\t\t\t\tufshcd_dme_set(hba, UIC_ARG_MIB(CBCREGADDRLSB), 0x1c);\n\t\t\t\tufshcd_dme_set(hba, UIC_ARG_MIB(CBCREGADDRMSB), offset);\n\t\t\t\tufshcd_dme_set(hba, UIC_ARG_MIB(CBCREGWRLSB), 0x04);\n\t\t\t\tufshcd_dme_set(hba, UIC_ARG_MIB(CBCREGWRMSB), 0x00);\n\t\t\t\tufshcd_dme_set(hba, UIC_ARG_MIB(CBCREGRDWRSEL), 0x01);\n\t\t\t\tufshcd_dme_set(hba, UIC_ARG_MIB(VS_MPHYCFGUPDT), 0x01);\n\t\t\t}\n\n\t\t\tgoto update_phy;\n\t\t}\n\t\tudelay(1000);\n\t\tretry--;\n\t} while (retry > 0);\n\n\tret = -ETIMEDOUT;\n\tgoto out;\n\nupdate_phy:\n\t \n\tufs_sprd_regmap_update(priv, SPRD_UFS_ANLG, 0xc, 0x2, 0);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(VS_MPHYCFGUPDT), 0x01);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(VS_MPHYDISABLE), 0x0);\nout:\n\treturn ret;\n}\n\n\nstatic int sprd_ufs_n6_hce_enable_notify(struct ufs_hba *hba,\n\t\t\t\t\t enum ufs_notify_change_status status)\n{\n\tint err = 0;\n\tstruct ufs_sprd_priv *priv = ufs_sprd_get_priv_data(hba);\n\n\tif (status == PRE_CHANGE) {\n\t\t \n\t\tufs_sprd_regmap_update(priv, SPRD_UFS_ANLG, 0xc, 0x2, 0x2);\n\t\t \n\t\tufs_sprd_regmap_update(priv, SPRD_UFS_ANLG, 0xc, 0x4, 0x4);\n\n\t\tufs_sprd_n6_host_reset(hba);\n\n\t\tif (hba->caps & UFSHCD_CAP_CRYPTO)\n\t\t\tufs_sprd_n6_key_acc_enable(hba);\n\t}\n\n\tif (status == POST_CHANGE) {\n\t\terr = ufs_sprd_n6_phy_init(hba);\n\t\tif (err) {\n\t\t\tdev_err(hba->dev, \"Phy setup failed (%d)\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tufs_sprd_get_unipro_ver(hba);\n\t}\nout:\n\treturn err;\n}\n\nstatic void sprd_ufs_n6_h8_notify(struct ufs_hba *hba,\n\t\t\t\t  enum uic_cmd_dme cmd,\n\t\t\t\t  enum ufs_notify_change_status status)\n{\n\tstruct ufs_sprd_priv *priv = ufs_sprd_get_priv_data(hba);\n\n\tif (status == PRE_CHANGE) {\n\t\tif (cmd == UIC_CMD_DME_HIBER_ENTER)\n\t\t\t \n\t\t\tufs_sprd_ctrl_uic_compl(hba, false);\n\n\t\tif (cmd == UIC_CMD_DME_HIBER_EXIT) {\n\t\t\tufs_sprd_regmap_update(priv, SPRD_UFS_AON_APB, APB_UFSDEV_REG,\n\t\t\t\tAPB_UFSDEV_REFCLK_EN, APB_UFSDEV_REFCLK_EN);\n\t\t\tufs_sprd_regmap_update(priv, SPRD_UFS_AON_APB, APB_USB31PLL_CTRL,\n\t\t\t\tAPB_USB31PLLV_REF2MPHY, APB_USB31PLLV_REF2MPHY);\n\t\t}\n\t}\n\n\tif (status == POST_CHANGE) {\n\t\tif (cmd == UIC_CMD_DME_HIBER_EXIT)\n\t\t\tufs_sprd_ctrl_uic_compl(hba, true);\n\n\t\tif (cmd == UIC_CMD_DME_HIBER_ENTER) {\n\t\t\tufs_sprd_regmap_update(priv, SPRD_UFS_AON_APB, APB_UFSDEV_REG,\n\t\t\t\tAPB_UFSDEV_REFCLK_EN, 0);\n\t\t\tufs_sprd_regmap_update(priv, SPRD_UFS_AON_APB, APB_USB31PLL_CTRL,\n\t\t\t\tAPB_USB31PLLV_REF2MPHY, 0);\n\t\t}\n\t}\n}\n\nstatic struct ufs_sprd_priv n6_ufs = {\n\t.rci[SPRD_UFSHCI_SOFT_RST] = { .name = \"controller\", },\n\t.rci[SPRD_UFS_DEV_RST] = { .name = \"device\", },\n\n\t.sysci[SPRD_UFS_ANLG] = { .name = \"sprd,ufs-anlg-syscon\", },\n\t.sysci[SPRD_UFS_AON_APB] = { .name = \"sprd,aon-apb-syscon\", },\n\n\t.vregi[SPRD_UFS_VDD_MPHY] = { .name = \"vdd-mphy\", },\n\n\t.ufs_hba_sprd_vops = {\n\t\t.name = \"sprd,ums9620-ufs\",\n\t\t.init = ufs_sprd_n6_init,\n\t\t.hce_enable_notify = sprd_ufs_n6_hce_enable_notify,\n\t\t.pwr_change_notify = sprd_ufs_pwr_change_notify,\n\t\t.hibern8_notify = sprd_ufs_n6_h8_notify,\n\t\t.device_reset = ufs_sprd_n6_device_reset,\n\t\t.suspend = ufs_sprd_suspend,\n\t},\n};\n\nstatic const struct of_device_id __maybe_unused ufs_sprd_of_match[] = {\n\t{ .compatible = \"sprd,ums9620-ufs\", .data = &n6_ufs.ufs_hba_sprd_vops},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ufs_sprd_of_match);\n\nstatic int ufs_sprd_probe(struct platform_device *pdev)\n{\n\tint err;\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *of_id;\n\n\tof_id = of_match_node(ufs_sprd_of_match, dev->of_node);\n\terr = ufshcd_pltfrm_init(pdev, of_id->data);\n\tif (err)\n\t\tdev_err(dev, \"ufshcd_pltfrm_init() failed %d\\n\", err);\n\n\treturn err;\n}\n\nstatic int ufs_sprd_remove(struct platform_device *pdev)\n{\n\tstruct ufs_hba *hba =  platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(&(pdev)->dev);\n\tufshcd_remove(hba);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ufs_sprd_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(ufshcd_system_suspend, ufshcd_system_resume)\n\tSET_RUNTIME_PM_OPS(ufshcd_runtime_suspend, ufshcd_runtime_resume, NULL)\n\t.prepare\t = ufshcd_suspend_prepare,\n\t.complete\t = ufshcd_resume_complete,\n};\n\nstatic struct platform_driver ufs_sprd_pltform = {\n\t.probe = ufs_sprd_probe,\n\t.remove = ufs_sprd_remove,\n\t.driver = {\n\t\t.name = \"ufshcd-sprd\",\n\t\t.pm = &ufs_sprd_pm_ops,\n\t\t.of_match_table = of_match_ptr(ufs_sprd_of_match),\n\t},\n};\nmodule_platform_driver(ufs_sprd_pltform);\n\nMODULE_AUTHOR(\"Zhe Wang <zhe.wang1@unisoc.com>\");\nMODULE_DESCRIPTION(\"Unisoc UFS Host Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}