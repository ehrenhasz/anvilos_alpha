{
  "module_name": "ufshcd-pltfrm.c",
  "hash_id": "14ede0285c6932bb1458d4933937472322053acf9f464fcd6e5c9aa4b544f503",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ufs/host/ufshcd-pltfrm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n\n#include <ufs/ufshcd.h>\n#include \"ufshcd-pltfrm.h\"\n#include <ufs/unipro.h>\n\n#define UFSHCD_DEFAULT_LANES_PER_DIRECTION\t\t2\n\nstatic int ufshcd_parse_clock_info(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tint cnt;\n\tint i;\n\tstruct device *dev = hba->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst char *name;\n\tu32 *clkfreq = NULL;\n\tstruct ufs_clk_info *clki;\n\tint len = 0;\n\tsize_t sz = 0;\n\n\tif (!np)\n\t\tgoto out;\n\n\tcnt = of_property_count_strings(np, \"clock-names\");\n\tif (!cnt || (cnt == -EINVAL)) {\n\t\tdev_info(dev, \"%s: Unable to find clocks, assuming enabled\\n\",\n\t\t\t\t__func__);\n\t} else if (cnt < 0) {\n\t\tdev_err(dev, \"%s: count clock strings failed, err %d\\n\",\n\t\t\t\t__func__, cnt);\n\t\tret = cnt;\n\t}\n\n\tif (cnt <= 0)\n\t\tgoto out;\n\n\tif (!of_get_property(np, \"freq-table-hz\", &len)) {\n\t\tdev_info(dev, \"freq-table-hz property not specified\\n\");\n\t\tgoto out;\n\t}\n\n\tif (len <= 0)\n\t\tgoto out;\n\n\tsz = len / sizeof(*clkfreq);\n\tif (sz != 2 * cnt) {\n\t\tdev_err(dev, \"%s len mismatch\\n\", \"freq-table-hz\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tclkfreq = devm_kcalloc(dev, sz, sizeof(*clkfreq),\n\t\t\t       GFP_KERNEL);\n\tif (!clkfreq) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = of_property_read_u32_array(np, \"freq-table-hz\",\n\t\t\tclkfreq, sz);\n\tif (ret && (ret != -EINVAL)) {\n\t\tdev_err(dev, \"%s: error reading array %d\\n\",\n\t\t\t\t\"freq-table-hz\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < sz; i += 2) {\n\t\tret = of_property_read_string_index(np,\t\"clock-names\", i/2,\n\t\t\t\t\t\t    &name);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tclki = devm_kzalloc(dev, sizeof(*clki), GFP_KERNEL);\n\t\tif (!clki) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tclki->min_freq = clkfreq[i];\n\t\tclki->max_freq = clkfreq[i+1];\n\t\tclki->name = devm_kstrdup(dev, name, GFP_KERNEL);\n\t\tif (!clki->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!strcmp(name, \"ref_clk\"))\n\t\t\tclki->keep_link_active = true;\n\t\tdev_dbg(dev, \"%s: min %u max %u name %s\\n\", \"freq-table-hz\",\n\t\t\t\tclki->min_freq, clki->max_freq, clki->name);\n\t\tlist_add_tail(&clki->list, &hba->clk_list_head);\n\t}\nout:\n\treturn ret;\n}\n\nstatic bool phandle_exists(const struct device_node *np,\n\t\t\t   const char *phandle_name, int index)\n{\n\tstruct device_node *parse_np = of_parse_phandle(np, phandle_name, index);\n\n\tif (parse_np)\n\t\tof_node_put(parse_np);\n\n\treturn parse_np != NULL;\n}\n\n#define MAX_PROP_SIZE 32\nint ufshcd_populate_vreg(struct device *dev, const char *name,\n\t\t\t struct ufs_vreg **out_vreg)\n{\n\tchar prop_name[MAX_PROP_SIZE];\n\tstruct ufs_vreg *vreg = NULL;\n\tstruct device_node *np = dev->of_node;\n\n\tif (!np) {\n\t\tdev_err(dev, \"%s: non DT initialization\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tsnprintf(prop_name, MAX_PROP_SIZE, \"%s-supply\", name);\n\tif (!phandle_exists(np, prop_name, 0)) {\n\t\tdev_info(dev, \"%s: Unable to find %s regulator, assuming enabled\\n\",\n\t\t\t\t__func__, prop_name);\n\t\tgoto out;\n\t}\n\n\tvreg = devm_kzalloc(dev, sizeof(*vreg), GFP_KERNEL);\n\tif (!vreg)\n\t\treturn -ENOMEM;\n\n\tvreg->name = devm_kstrdup(dev, name, GFP_KERNEL);\n\tif (!vreg->name)\n\t\treturn -ENOMEM;\n\n\tsnprintf(prop_name, MAX_PROP_SIZE, \"%s-max-microamp\", name);\n\tif (of_property_read_u32(np, prop_name, &vreg->max_uA)) {\n\t\tdev_info(dev, \"%s: unable to find %s\\n\", __func__, prop_name);\n\t\tvreg->max_uA = 0;\n\t}\nout:\n\t*out_vreg = vreg;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ufshcd_populate_vreg);\n\n \nstatic int ufshcd_parse_regulator_info(struct ufs_hba *hba)\n{\n\tint err;\n\tstruct device *dev = hba->dev;\n\tstruct ufs_vreg_info *info = &hba->vreg_info;\n\n\terr = ufshcd_populate_vreg(dev, \"vdd-hba\", &info->vdd_hba);\n\tif (err)\n\t\tgoto out;\n\n\terr = ufshcd_populate_vreg(dev, \"vcc\", &info->vcc);\n\tif (err)\n\t\tgoto out;\n\n\terr = ufshcd_populate_vreg(dev, \"vccq\", &info->vccq);\n\tif (err)\n\t\tgoto out;\n\n\terr = ufshcd_populate_vreg(dev, \"vccq2\", &info->vccq2);\nout:\n\treturn err;\n}\n\nstatic void ufshcd_init_lanes_per_dir(struct ufs_hba *hba)\n{\n\tstruct device *dev = hba->dev;\n\tint ret;\n\n\tret = of_property_read_u32(dev->of_node, \"lanes-per-direction\",\n\t\t&hba->lanes_per_direction);\n\tif (ret) {\n\t\tdev_dbg(hba->dev,\n\t\t\t\"%s: failed to read lanes-per-direction, ret=%d\\n\",\n\t\t\t__func__, ret);\n\t\thba->lanes_per_direction = UFSHCD_DEFAULT_LANES_PER_DIRECTION;\n\t}\n}\n\n \nint ufshcd_get_pwr_dev_param(const struct ufs_dev_params *pltfrm_param,\n\t\t\t     const struct ufs_pa_layer_attr *dev_max,\n\t\t\t     struct ufs_pa_layer_attr *agreed_pwr)\n{\n\tint min_pltfrm_gear;\n\tint min_dev_gear;\n\tbool is_dev_sup_hs = false;\n\tbool is_pltfrm_max_hs = false;\n\n\tif (dev_max->pwr_rx == FAST_MODE)\n\t\tis_dev_sup_hs = true;\n\n\tif (pltfrm_param->desired_working_mode == UFS_HS_MODE) {\n\t\tis_pltfrm_max_hs = true;\n\t\tmin_pltfrm_gear = min_t(u32, pltfrm_param->hs_rx_gear,\n\t\t\t\t\tpltfrm_param->hs_tx_gear);\n\t} else {\n\t\tmin_pltfrm_gear = min_t(u32, pltfrm_param->pwm_rx_gear,\n\t\t\t\t\tpltfrm_param->pwm_tx_gear);\n\t}\n\n\t \n\tif (!is_dev_sup_hs && is_pltfrm_max_hs) {\n\t\tpr_info(\"%s: device doesn't support HS\\n\",\n\t\t\t__func__);\n\t\treturn -ENOTSUPP;\n\t} else if (is_dev_sup_hs && is_pltfrm_max_hs) {\n\t\t \n\t\tagreed_pwr->pwr_rx = pltfrm_param->rx_pwr_hs;\n\t\tagreed_pwr->pwr_tx = agreed_pwr->pwr_rx;\n\t} else {\n\t\t \n\t\tagreed_pwr->pwr_rx = pltfrm_param->rx_pwr_pwm;\n\t\tagreed_pwr->pwr_tx = agreed_pwr->pwr_rx;\n\t}\n\n\t \n\tagreed_pwr->lane_tx = min_t(u32, dev_max->lane_tx,\n\t\t\t\t    pltfrm_param->tx_lanes);\n\tagreed_pwr->lane_rx = min_t(u32, dev_max->lane_rx,\n\t\t\t\t    pltfrm_param->rx_lanes);\n\n\t \n\tmin_dev_gear = min_t(u32, dev_max->gear_rx, dev_max->gear_tx);\n\n\t \n\tif ((is_dev_sup_hs && is_pltfrm_max_hs) ||\n\t    (!is_dev_sup_hs && !is_pltfrm_max_hs)) {\n\t\tagreed_pwr->gear_rx =\n\t\t\tmin_t(u32, min_dev_gear, min_pltfrm_gear);\n\t} else if (!is_dev_sup_hs) {\n\t\tagreed_pwr->gear_rx = min_dev_gear;\n\t} else {\n\t\tagreed_pwr->gear_rx = min_pltfrm_gear;\n\t}\n\tagreed_pwr->gear_tx = agreed_pwr->gear_rx;\n\n\tagreed_pwr->hs_rate = pltfrm_param->hs_rate;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ufshcd_get_pwr_dev_param);\n\nvoid ufshcd_init_pwr_dev_param(struct ufs_dev_params *dev_param)\n{\n\t*dev_param = (struct ufs_dev_params){\n\t\t.tx_lanes = UFS_LANE_2,\n\t\t.rx_lanes = UFS_LANE_2,\n\t\t.hs_rx_gear = UFS_HS_G3,\n\t\t.hs_tx_gear = UFS_HS_G3,\n\t\t.pwm_rx_gear = UFS_PWM_G4,\n\t\t.pwm_tx_gear = UFS_PWM_G4,\n\t\t.rx_pwr_pwm = SLOW_MODE,\n\t\t.tx_pwr_pwm = SLOW_MODE,\n\t\t.rx_pwr_hs = FAST_MODE,\n\t\t.tx_pwr_hs = FAST_MODE,\n\t\t.hs_rate = PA_HS_MODE_B,\n\t\t.desired_working_mode = UFS_HS_MODE,\n\t};\n}\nEXPORT_SYMBOL_GPL(ufshcd_init_pwr_dev_param);\n\n \nint ufshcd_pltfrm_init(struct platform_device *pdev,\n\t\t       const struct ufs_hba_variant_ops *vops)\n{\n\tstruct ufs_hba *hba;\n\tvoid __iomem *mmio_base;\n\tint irq, err;\n\tstruct device *dev = &pdev->dev;\n\n\tmmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mmio_base)) {\n\t\terr = PTR_ERR(mmio_base);\n\t\tgoto out;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\terr = irq;\n\t\tgoto out;\n\t}\n\n\terr = ufshcd_alloc_host(dev, &hba);\n\tif (err) {\n\t\tdev_err(dev, \"Allocation failed\\n\");\n\t\tgoto out;\n\t}\n\n\thba->vops = vops;\n\n\terr = ufshcd_parse_clock_info(hba);\n\tif (err) {\n\t\tdev_err(dev, \"%s: clock parse failed %d\\n\",\n\t\t\t\t__func__, err);\n\t\tgoto dealloc_host;\n\t}\n\terr = ufshcd_parse_regulator_info(hba);\n\tif (err) {\n\t\tdev_err(dev, \"%s: regulator init failed %d\\n\",\n\t\t\t\t__func__, err);\n\t\tgoto dealloc_host;\n\t}\n\n\tufshcd_init_lanes_per_dir(hba);\n\n\terr = ufshcd_init(hba, mmio_base, irq);\n\tif (err) {\n\t\tdev_err_probe(dev, err, \"Initialization failed with error %d\\n\",\n\t\t\t      err);\n\t\tgoto dealloc_host;\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\ndealloc_host:\n\tufshcd_dealloc_host(hba);\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ufshcd_pltfrm_init);\n\nMODULE_AUTHOR(\"Santosh Yaragnavi <santosh.sy@samsung.com>\");\nMODULE_AUTHOR(\"Vinayak Holikatti <h.vinayak@samsung.com>\");\nMODULE_DESCRIPTION(\"UFS host controller Platform bus based glue driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}