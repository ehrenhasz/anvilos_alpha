{
  "module_name": "ufs-qcom.h",
  "hash_id": "07d220d247f9746561c74dfa7f75c4da7927a65f0e321367cd07daee004793cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ufs/host/ufs-qcom.h",
  "human_readable_source": " \n \n\n#ifndef UFS_QCOM_H_\n#define UFS_QCOM_H_\n\n#include <linux/reset-controller.h>\n#include <linux/reset.h>\n#include <soc/qcom/ice.h>\n#include <ufs/ufshcd.h>\n\n#define MAX_UFS_QCOM_HOSTS\t1\n#define MAX_U32                 (~(u32)0)\n#define MPHY_TX_FSM_STATE       0x41\n#define TX_FSM_HIBERN8          0x1\n#define HBRN8_POLL_TOUT_MS      100\n#define DEFAULT_CLK_RATE_HZ     1000000\n#define BUS_VECTOR_NAME_LEN     32\n#define MAX_SUPP_MAC\t\t64\n\n#define UFS_HW_VER_MAJOR_MASK\tGENMASK(31, 28)\n#define UFS_HW_VER_MINOR_MASK\tGENMASK(27, 16)\n#define UFS_HW_VER_STEP_MASK\tGENMASK(15, 0)\n\n \n#define SLOW 1\n#define FAST 2\n\n#define UFS_QCOM_LIMIT_HS_RATE\t\tPA_HS_MODE_B\n\n \nenum {\n\tREG_UFS_SYS1CLK_1US                 = 0xC0,\n\tREG_UFS_TX_SYMBOL_CLK_NS_US         = 0xC4,\n\tREG_UFS_LOCAL_PORT_ID_REG           = 0xC8,\n\tREG_UFS_PA_ERR_CODE                 = 0xCC,\n\t \n\tREG_UFS_PARAM0                      = 0xD0,\n\t \n\tREG_UFS_CFG0                        = 0xD8,\n\tREG_UFS_CFG1                        = 0xDC,\n\tREG_UFS_CFG2                        = 0xE0,\n\tREG_UFS_HW_VERSION                  = 0xE4,\n\n\tUFS_TEST_BUS\t\t\t\t= 0xE8,\n\tUFS_TEST_BUS_CTRL_0\t\t\t= 0xEC,\n\tUFS_TEST_BUS_CTRL_1\t\t\t= 0xF0,\n\tUFS_TEST_BUS_CTRL_2\t\t\t= 0xF4,\n\tUFS_UNIPRO_CFG\t\t\t\t= 0xF8,\n\n\t \n\tUFS_AH8_CFG\t\t\t\t= 0xFC,\n\n\tREG_UFS_CFG3\t\t\t\t= 0x271C,\n};\n\n \nenum {\n\tUFS_DBG_RD_REG_UAWM\t\t\t= 0x100,\n\tUFS_DBG_RD_REG_UARM\t\t\t= 0x200,\n\tUFS_DBG_RD_REG_TXUC\t\t\t= 0x300,\n\tUFS_DBG_RD_REG_RXUC\t\t\t= 0x400,\n\tUFS_DBG_RD_REG_DFC\t\t\t= 0x500,\n\tUFS_DBG_RD_REG_TRLUT\t\t\t= 0x600,\n\tUFS_DBG_RD_REG_TMRLUT\t\t\t= 0x700,\n\tUFS_UFS_DBG_RD_REG_OCSC\t\t\t= 0x800,\n\n\tUFS_UFS_DBG_RD_DESC_RAM\t\t\t= 0x1500,\n\tUFS_UFS_DBG_RD_PRDT_RAM\t\t\t= 0x1700,\n\tUFS_UFS_DBG_RD_RESP_RAM\t\t\t= 0x1800,\n\tUFS_UFS_DBG_RD_EDTL_RAM\t\t\t= 0x1900,\n};\n\nenum {\n\tUFS_MEM_CQIS_VS\t\t= 0x8,\n};\n\n#define UFS_CNTLR_2_x_x_VEN_REGS_OFFSET(x)\t(0x000 + x)\n#define UFS_CNTLR_3_x_x_VEN_REGS_OFFSET(x)\t(0x400 + x)\n\n \n#define QUNIPRO_G4_SEL\t\tBIT(5)\n\n \n#define QUNIPRO_SEL\t\tBIT(0)\n#define UFS_PHY_SOFT_RESET\tBIT(1)\n#define UTP_DBG_RAMS_EN\t\tBIT(17)\n#define TEST_BUS_EN\t\tBIT(18)\n#define TEST_BUS_SEL\t\tGENMASK(22, 19)\n#define UFS_REG_TEST_BUS_EN\tBIT(30)\n\n#define UFS_PHY_RESET_ENABLE\t1\n#define UFS_PHY_RESET_DISABLE\t0\n\n \n#define UAWM_HW_CGC_EN\t\tBIT(0)\n#define UARM_HW_CGC_EN\t\tBIT(1)\n#define TXUC_HW_CGC_EN\t\tBIT(2)\n#define RXUC_HW_CGC_EN\t\tBIT(3)\n#define DFC_HW_CGC_EN\t\tBIT(4)\n#define TRLUT_HW_CGC_EN\t\tBIT(5)\n#define TMRLUT_HW_CGC_EN\tBIT(6)\n#define OCSC_HW_CGC_EN\t\tBIT(7)\n\n \n#define MAX_HS_GEAR_MASK\tGENMASK(6, 4)\n#define UFS_QCOM_MAX_GEAR(x)\tFIELD_GET(MAX_HS_GEAR_MASK, (x))\n\n \n#define TEST_BUS_SUB_SEL_MASK\tGENMASK(4, 0)   \n\n#define REG_UFS_CFG2_CGC_EN_ALL (UAWM_HW_CGC_EN | UARM_HW_CGC_EN |\\\n\t\t\t\t TXUC_HW_CGC_EN | RXUC_HW_CGC_EN |\\\n\t\t\t\t DFC_HW_CGC_EN | TRLUT_HW_CGC_EN |\\\n\t\t\t\t TMRLUT_HW_CGC_EN | OCSC_HW_CGC_EN)\n\n \n#define OFFSET_CLK_NS_REG\t\t0xa\n\n \n#define MASK_TX_SYMBOL_CLK_1US_REG\tGENMASK(9, 0)\n#define MASK_CLK_NS_REG\t\t\tGENMASK(23, 10)\n\n \n#define PA_VS_CONFIG_REG1\t0x9000\n#define DME_VS_CORE_CLK_CTRL\t0xD002\n \n#define DME_VS_CORE_CLK_CTRL_CORE_CLK_DIV_EN_BIT\t\tBIT(8)\n#define DME_VS_CORE_CLK_CTRL_MAX_CORE_CLK_1US_CYCLES_MASK\t0xFF\n\nstatic inline void\nufs_qcom_get_controller_revision(struct ufs_hba *hba,\n\t\t\t\t u8 *major, u16 *minor, u16 *step)\n{\n\tu32 ver = ufshcd_readl(hba, REG_UFS_HW_VERSION);\n\n\t*major = FIELD_GET(UFS_HW_VER_MAJOR_MASK, ver);\n\t*minor = FIELD_GET(UFS_HW_VER_MINOR_MASK, ver);\n\t*step = FIELD_GET(UFS_HW_VER_STEP_MASK, ver);\n};\n\nstatic inline void ufs_qcom_assert_reset(struct ufs_hba *hba)\n{\n\tufshcd_rmwl(hba, UFS_PHY_SOFT_RESET, FIELD_PREP(UFS_PHY_SOFT_RESET, UFS_PHY_RESET_ENABLE),\n\t\t    REG_UFS_CFG1);\n\n\t \n\tmb();\n}\n\nstatic inline void ufs_qcom_deassert_reset(struct ufs_hba *hba)\n{\n\tufshcd_rmwl(hba, UFS_PHY_SOFT_RESET, FIELD_PREP(UFS_PHY_SOFT_RESET, UFS_PHY_RESET_DISABLE),\n\t\t    REG_UFS_CFG1);\n\n\t \n\tmb();\n}\n\n \nstruct ufs_hw_version {\n\tu16 step;\n\tu16 minor;\n\tu8 major;\n};\n\nstruct ufs_qcom_testbus {\n\tu8 select_major;\n\tu8 select_minor;\n};\n\nstruct gpio_desc;\n\nstruct ufs_qcom_host {\n\t \n\t#define UFS_QCOM_CAP_QUNIPRO\t0x1\n\n\t \n\t#define UFS_QCOM_CAP_RETAIN_SEC_CFG_AFTER_PWR_COLLAPSE\t0x2\n\tu32 caps;\n\n\tstruct phy *generic_phy;\n\tstruct ufs_hba *hba;\n\tstruct ufs_pa_layer_attr dev_req_params;\n\tstruct clk *rx_l0_sync_clk;\n\tstruct clk *tx_l0_sync_clk;\n\tstruct clk *rx_l1_sync_clk;\n\tstruct clk *tx_l1_sync_clk;\n\tbool is_lane_clks_enabled;\n\n\tstruct icc_path *icc_ddr;\n\tstruct icc_path *icc_cpu;\n\n#ifdef CONFIG_SCSI_UFS_CRYPTO\n\tstruct qcom_ice *ice;\n#endif\n\n\tvoid __iomem *dev_ref_clk_ctrl_mmio;\n\tbool is_dev_ref_clk_enabled;\n\tstruct ufs_hw_version hw_ver;\n\n\tu32 dev_ref_clk_en_mask;\n\n\tstruct ufs_qcom_testbus testbus;\n\n\t \n\tstruct reset_control *core_reset;\n\tstruct reset_controller_dev rcdev;\n\n\tstruct gpio_desc *device_reset;\n\n\tu32 hs_gear;\n\n\tbool esi_enabled;\n};\n\nstatic inline u32\nufs_qcom_get_debug_reg_offset(struct ufs_qcom_host *host, u32 reg)\n{\n\tif (host->hw_ver.major <= 0x02)\n\t\treturn UFS_CNTLR_2_x_x_VEN_REGS_OFFSET(reg);\n\n\treturn UFS_CNTLR_3_x_x_VEN_REGS_OFFSET(reg);\n};\n\n#define ufs_qcom_is_link_off(hba) ufshcd_is_link_off(hba)\n#define ufs_qcom_is_link_active(hba) ufshcd_is_link_active(hba)\n#define ufs_qcom_is_link_hibern8(hba) ufshcd_is_link_hibern8(hba)\n\nint ufs_qcom_testbus_config(struct ufs_qcom_host *host);\n\nstatic inline bool ufs_qcom_cap_qunipro(struct ufs_qcom_host *host)\n{\n\treturn host->caps & UFS_QCOM_CAP_QUNIPRO;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}