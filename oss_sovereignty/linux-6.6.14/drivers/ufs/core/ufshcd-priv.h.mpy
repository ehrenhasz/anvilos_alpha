{
  "module_name": "ufshcd-priv.h",
  "hash_id": "6dc5191de23efbb6609b89d46d817f5250fa064dd5dc7b21155676f2b196a6ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ufs/core/ufshcd-priv.h",
  "human_readable_source": " \n\n#ifndef _UFSHCD_PRIV_H_\n#define _UFSHCD_PRIV_H_\n\n#include <linux/pm_runtime.h>\n#include <ufs/ufshcd.h>\n\nstatic inline bool ufshcd_is_user_access_allowed(struct ufs_hba *hba)\n{\n\treturn !hba->shutting_down;\n}\n\nvoid ufshcd_schedule_eh_work(struct ufs_hba *hba);\n\nstatic inline bool ufshcd_keep_autobkops_enabled_except_suspend(\n\t\t\t\t\t\t\tstruct ufs_hba *hba)\n{\n\treturn hba->caps & UFSHCD_CAP_KEEP_AUTO_BKOPS_ENABLED_EXCEPT_SUSPEND;\n}\n\nstatic inline u8 ufshcd_wb_get_query_index(struct ufs_hba *hba)\n{\n\tif (hba->dev_info.wb_buffer_type == WB_BUF_MODE_LU_DEDICATED)\n\t\treturn hba->dev_info.wb_dedicated_lu;\n\treturn 0;\n}\n\nstatic inline bool ufshcd_is_wb_buf_flush_allowed(struct ufs_hba *hba)\n{\n\treturn ufshcd_is_wb_allowed(hba) &&\n\t\t!(hba->quirks & UFSHCI_QUIRK_SKIP_MANUAL_WB_FLUSH_CTRL);\n}\n\n#ifdef CONFIG_SCSI_UFS_HWMON\nvoid ufs_hwmon_probe(struct ufs_hba *hba, u8 mask);\nvoid ufs_hwmon_remove(struct ufs_hba *hba);\nvoid ufs_hwmon_notify_event(struct ufs_hba *hba, u8 ee_mask);\n#else\nstatic inline void ufs_hwmon_probe(struct ufs_hba *hba, u8 mask) {}\nstatic inline void ufs_hwmon_remove(struct ufs_hba *hba) {}\nstatic inline void ufs_hwmon_notify_event(struct ufs_hba *hba, u8 ee_mask) {}\n#endif\n\nint ufshcd_query_descriptor_retry(struct ufs_hba *hba,\n\t\t\t\t  enum query_opcode opcode,\n\t\t\t\t  enum desc_idn idn, u8 index,\n\t\t\t\t  u8 selector,\n\t\t\t\t  u8 *desc_buf, int *buf_len);\nint ufshcd_read_desc_param(struct ufs_hba *hba,\n\t\t\t   enum desc_idn desc_id,\n\t\t\t   int desc_index,\n\t\t\t   u8 param_offset,\n\t\t\t   u8 *param_read_buf,\n\t\t\t   u8 param_size);\nint ufshcd_query_attr_retry(struct ufs_hba *hba, enum query_opcode opcode,\n\t\t\t    enum attr_idn idn, u8 index, u8 selector,\n\t\t\t    u32 *attr_val);\nint ufshcd_query_attr(struct ufs_hba *hba, enum query_opcode opcode,\n\t\t      enum attr_idn idn, u8 index, u8 selector, u32 *attr_val);\nint ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,\n\tenum flag_idn idn, u8 index, bool *flag_res);\nvoid ufshcd_auto_hibern8_update(struct ufs_hba *hba, u32 ahit);\nvoid ufshcd_compl_one_cqe(struct ufs_hba *hba, int task_tag,\n\t\t\t  struct cq_entry *cqe);\nint ufshcd_mcq_init(struct ufs_hba *hba);\nint ufshcd_mcq_decide_queue_depth(struct ufs_hba *hba);\nint ufshcd_mcq_memory_alloc(struct ufs_hba *hba);\nvoid ufshcd_mcq_make_queues_operational(struct ufs_hba *hba);\nvoid ufshcd_mcq_config_mac(struct ufs_hba *hba, u32 max_active_cmds);\nu32 ufshcd_mcq_read_cqis(struct ufs_hba *hba, int i);\nvoid ufshcd_mcq_write_cqis(struct ufs_hba *hba, u32 val, int i);\nstruct ufs_hw_queue *ufshcd_mcq_req_to_hwq(struct ufs_hba *hba,\n\t\t\t\t\t   struct request *req);\nunsigned long ufshcd_mcq_poll_cqe_lock(struct ufs_hba *hba,\n\t\t\t\t       struct ufs_hw_queue *hwq);\nvoid ufshcd_mcq_compl_all_cqes_lock(struct ufs_hba *hba,\n\t\t\t\t    struct ufs_hw_queue *hwq);\nbool ufshcd_cmd_inflight(struct scsi_cmnd *cmd);\nint ufshcd_mcq_sq_cleanup(struct ufs_hba *hba, int task_tag);\nint ufshcd_mcq_abort(struct scsi_cmnd *cmd);\nint ufshcd_try_to_abort_task(struct ufs_hba *hba, int tag);\nvoid ufshcd_release_scsi_cmd(struct ufs_hba *hba,\n\t\t\t     struct ufshcd_lrb *lrbp);\n\n#define SD_ASCII_STD true\n#define SD_RAW false\nint ufshcd_read_string_desc(struct ufs_hba *hba, u8 desc_index,\n\t\t\t    u8 **buf, bool ascii);\n\nint ufshcd_send_uic_cmd(struct ufs_hba *hba, struct uic_command *uic_cmd);\n\nint ufshcd_exec_raw_upiu_cmd(struct ufs_hba *hba,\n\t\t\t     struct utp_upiu_req *req_upiu,\n\t\t\t     struct utp_upiu_req *rsp_upiu,\n\t\t\t     enum upiu_request_transaction msgcode,\n\t\t\t     u8 *desc_buff, int *buff_len,\n\t\t\t     enum query_opcode desc_op);\n\nint ufshcd_wb_toggle(struct ufs_hba *hba, bool enable);\n\n \nstatic inline const char *ufshcd_get_var_name(struct ufs_hba *hba)\n{\n\tif (hba->vops)\n\t\treturn hba->vops->name;\n\treturn \"\";\n}\n\nstatic inline void ufshcd_vops_exit(struct ufs_hba *hba)\n{\n\tif (hba->vops && hba->vops->exit)\n\t\treturn hba->vops->exit(hba);\n}\n\nstatic inline u32 ufshcd_vops_get_ufs_hci_version(struct ufs_hba *hba)\n{\n\tif (hba->vops && hba->vops->get_ufs_hci_version)\n\t\treturn hba->vops->get_ufs_hci_version(hba);\n\n\treturn ufshcd_readl(hba, REG_UFS_VERSION);\n}\n\nstatic inline int ufshcd_vops_clk_scale_notify(struct ufs_hba *hba,\n\t\t\tbool up, enum ufs_notify_change_status status)\n{\n\tif (hba->vops && hba->vops->clk_scale_notify)\n\t\treturn hba->vops->clk_scale_notify(hba, up, status);\n\treturn 0;\n}\n\nstatic inline void ufshcd_vops_event_notify(struct ufs_hba *hba,\n\t\t\t\t\t    enum ufs_event_type evt,\n\t\t\t\t\t    void *data)\n{\n\tif (hba->vops && hba->vops->event_notify)\n\t\thba->vops->event_notify(hba, evt, data);\n}\n\nstatic inline int ufshcd_vops_setup_clocks(struct ufs_hba *hba, bool on,\n\t\t\t\t\tenum ufs_notify_change_status status)\n{\n\tif (hba->vops && hba->vops->setup_clocks)\n\t\treturn hba->vops->setup_clocks(hba, on, status);\n\treturn 0;\n}\n\nstatic inline int ufshcd_vops_hce_enable_notify(struct ufs_hba *hba,\n\t\t\t\t\t\tbool status)\n{\n\tif (hba->vops && hba->vops->hce_enable_notify)\n\t\treturn hba->vops->hce_enable_notify(hba, status);\n\n\treturn 0;\n}\nstatic inline int ufshcd_vops_link_startup_notify(struct ufs_hba *hba,\n\t\t\t\t\t\tbool status)\n{\n\tif (hba->vops && hba->vops->link_startup_notify)\n\t\treturn hba->vops->link_startup_notify(hba, status);\n\n\treturn 0;\n}\n\nstatic inline int ufshcd_vops_pwr_change_notify(struct ufs_hba *hba,\n\t\t\t\t  enum ufs_notify_change_status status,\n\t\t\t\t  struct ufs_pa_layer_attr *dev_max_params,\n\t\t\t\t  struct ufs_pa_layer_attr *dev_req_params)\n{\n\tif (hba->vops && hba->vops->pwr_change_notify)\n\t\treturn hba->vops->pwr_change_notify(hba, status,\n\t\t\t\t\tdev_max_params, dev_req_params);\n\n\treturn -ENOTSUPP;\n}\n\nstatic inline void ufshcd_vops_setup_task_mgmt(struct ufs_hba *hba,\n\t\t\t\t\tint tag, u8 tm_function)\n{\n\tif (hba->vops && hba->vops->setup_task_mgmt)\n\t\treturn hba->vops->setup_task_mgmt(hba, tag, tm_function);\n}\n\nstatic inline void ufshcd_vops_hibern8_notify(struct ufs_hba *hba,\n\t\t\t\t\tenum uic_cmd_dme cmd,\n\t\t\t\t\tenum ufs_notify_change_status status)\n{\n\tif (hba->vops && hba->vops->hibern8_notify)\n\t\treturn hba->vops->hibern8_notify(hba, cmd, status);\n}\n\nstatic inline int ufshcd_vops_apply_dev_quirks(struct ufs_hba *hba)\n{\n\tif (hba->vops && hba->vops->apply_dev_quirks)\n\t\treturn hba->vops->apply_dev_quirks(hba);\n\treturn 0;\n}\n\nstatic inline void ufshcd_vops_fixup_dev_quirks(struct ufs_hba *hba)\n{\n\tif (hba->vops && hba->vops->fixup_dev_quirks)\n\t\thba->vops->fixup_dev_quirks(hba);\n}\n\nstatic inline int ufshcd_vops_suspend(struct ufs_hba *hba, enum ufs_pm_op op,\n\t\t\t\tenum ufs_notify_change_status status)\n{\n\tif (hba->vops && hba->vops->suspend)\n\t\treturn hba->vops->suspend(hba, op, status);\n\n\treturn 0;\n}\n\nstatic inline int ufshcd_vops_resume(struct ufs_hba *hba, enum ufs_pm_op op)\n{\n\tif (hba->vops && hba->vops->resume)\n\t\treturn hba->vops->resume(hba, op);\n\n\treturn 0;\n}\n\nstatic inline void ufshcd_vops_dbg_register_dump(struct ufs_hba *hba)\n{\n\tif (hba->vops && hba->vops->dbg_register_dump)\n\t\thba->vops->dbg_register_dump(hba);\n}\n\nstatic inline int ufshcd_vops_device_reset(struct ufs_hba *hba)\n{\n\tif (hba->vops && hba->vops->device_reset)\n\t\treturn hba->vops->device_reset(hba);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void ufshcd_vops_config_scaling_param(struct ufs_hba *hba,\n\t\tstruct devfreq_dev_profile *p,\n\t\tstruct devfreq_simple_ondemand_data *data)\n{\n\tif (hba->vops && hba->vops->config_scaling_param)\n\t\thba->vops->config_scaling_param(hba, p, data);\n}\n\nstatic inline void ufshcd_vops_reinit_notify(struct ufs_hba *hba)\n{\n\tif (hba->vops && hba->vops->reinit_notify)\n\t\thba->vops->reinit_notify(hba);\n}\n\nstatic inline int ufshcd_vops_mcq_config_resource(struct ufs_hba *hba)\n{\n\tif (hba->vops && hba->vops->mcq_config_resource)\n\t\treturn hba->vops->mcq_config_resource(hba);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int ufshcd_mcq_vops_get_hba_mac(struct ufs_hba *hba)\n{\n\tif (hba->vops && hba->vops->get_hba_mac)\n\t\treturn hba->vops->get_hba_mac(hba);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int ufshcd_mcq_vops_op_runtime_config(struct ufs_hba *hba)\n{\n\tif (hba->vops && hba->vops->op_runtime_config)\n\t\treturn hba->vops->op_runtime_config(hba);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int ufshcd_vops_get_outstanding_cqs(struct ufs_hba *hba,\n\t\t\t\t\t\t  unsigned long *ocqs)\n{\n\tif (hba->vops && hba->vops->get_outstanding_cqs)\n\t\treturn hba->vops->get_outstanding_cqs(hba, ocqs);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int ufshcd_mcq_vops_config_esi(struct ufs_hba *hba)\n{\n\tif (hba->vops && hba->vops->config_esi)\n\t\treturn hba->vops->config_esi(hba);\n\n\treturn -EOPNOTSUPP;\n}\n\nextern const struct ufs_pm_lvl_states ufs_pm_lvl_states[];\n\n \nstatic inline u8 ufshcd_scsi_to_upiu_lun(unsigned int scsi_lun)\n{\n\tif (scsi_is_wlun(scsi_lun))\n\t\treturn (scsi_lun & UFS_UPIU_MAX_UNIT_NUM_ID)\n\t\t\t| UFS_UPIU_WLUN_ID;\n\telse\n\t\treturn scsi_lun & UFS_UPIU_MAX_UNIT_NUM_ID;\n}\n\nint __ufshcd_write_ee_control(struct ufs_hba *hba, u32 ee_ctrl_mask);\nint ufshcd_write_ee_control(struct ufs_hba *hba);\nint ufshcd_update_ee_control(struct ufs_hba *hba, u16 *mask,\n\t\t\t     const u16 *other_mask, u16 set, u16 clr);\n\nstatic inline int ufshcd_update_ee_drv_mask(struct ufs_hba *hba,\n\t\t\t\t\t    u16 set, u16 clr)\n{\n\treturn ufshcd_update_ee_control(hba, &hba->ee_drv_mask,\n\t\t\t\t\t&hba->ee_usr_mask, set, clr);\n}\n\nstatic inline int ufshcd_update_ee_usr_mask(struct ufs_hba *hba,\n\t\t\t\t\t    u16 set, u16 clr)\n{\n\treturn ufshcd_update_ee_control(hba, &hba->ee_usr_mask,\n\t\t\t\t\t&hba->ee_drv_mask, set, clr);\n}\n\nstatic inline int ufshcd_rpm_get_sync(struct ufs_hba *hba)\n{\n\treturn pm_runtime_get_sync(&hba->ufs_device_wlun->sdev_gendev);\n}\n\nstatic inline int ufshcd_rpm_put_sync(struct ufs_hba *hba)\n{\n\treturn pm_runtime_put_sync(&hba->ufs_device_wlun->sdev_gendev);\n}\n\nstatic inline void ufshcd_rpm_get_noresume(struct ufs_hba *hba)\n{\n\tpm_runtime_get_noresume(&hba->ufs_device_wlun->sdev_gendev);\n}\n\nstatic inline int ufshcd_rpm_resume(struct ufs_hba *hba)\n{\n\treturn pm_runtime_resume(&hba->ufs_device_wlun->sdev_gendev);\n}\n\nstatic inline int ufshcd_rpm_put(struct ufs_hba *hba)\n{\n\treturn pm_runtime_put(&hba->ufs_device_wlun->sdev_gendev);\n}\n\n \nstatic inline bool ufs_is_valid_unit_desc_lun(struct ufs_dev_info *dev_info, u8 lun)\n{\n\tif (!dev_info || !dev_info->max_lu_supported) {\n\t\tpr_err(\"Max General LU supported by UFS isn't initialized\\n\");\n\t\treturn false;\n\t}\n\treturn lun == UFS_UPIU_RPMB_WLUN || (lun < dev_info->max_lu_supported);\n}\n\nstatic inline void ufshcd_inc_sq_tail(struct ufs_hw_queue *q)\n\t__must_hold(&q->sq_lock)\n{\n\tu32 val;\n\n\tq->sq_tail_slot++;\n\tif (q->sq_tail_slot == q->max_entries)\n\t\tq->sq_tail_slot = 0;\n\tval = q->sq_tail_slot * sizeof(struct utp_transfer_req_desc);\n\twritel(val, q->mcq_sq_tail);\n}\n\nstatic inline void ufshcd_mcq_update_cq_tail_slot(struct ufs_hw_queue *q)\n{\n\tu32 val = readl(q->mcq_cq_tail);\n\n\tq->cq_tail_slot = val / sizeof(struct cq_entry);\n}\n\nstatic inline bool ufshcd_mcq_is_cq_empty(struct ufs_hw_queue *q)\n{\n\treturn q->cq_head_slot == q->cq_tail_slot;\n}\n\nstatic inline void ufshcd_mcq_inc_cq_head_slot(struct ufs_hw_queue *q)\n{\n\tq->cq_head_slot++;\n\tif (q->cq_head_slot == q->max_entries)\n\t\tq->cq_head_slot = 0;\n}\n\nstatic inline void ufshcd_mcq_update_cq_head(struct ufs_hw_queue *q)\n{\n\twritel(q->cq_head_slot * sizeof(struct cq_entry), q->mcq_cq_head);\n}\n\nstatic inline struct cq_entry *ufshcd_mcq_cur_cqe(struct ufs_hw_queue *q)\n{\n\tstruct cq_entry *cqe = q->cqe_base_addr;\n\n\treturn cqe + q->cq_head_slot;\n}\n\nstatic inline u32 ufshcd_mcq_get_sq_head_slot(struct ufs_hw_queue *q)\n{\n\tu32 val = readl(q->mcq_sq_head);\n\n\treturn val / sizeof(struct utp_transfer_req_desc);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}