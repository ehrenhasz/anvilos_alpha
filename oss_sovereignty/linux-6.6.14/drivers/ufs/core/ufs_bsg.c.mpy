{
  "module_name": "ufs_bsg.c",
  "hash_id": "7fe3fa041c9ea4c8e7fb56804e489d3262806a4074eb3a5ebe2c985a1164aef7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ufs/core/ufs_bsg.c",
  "human_readable_source": "\n \n\n#include <linux/bsg-lib.h>\n#include <linux/dma-mapping.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include \"ufs_bsg.h\"\n#include <ufs/ufshcd.h>\n#include \"ufshcd-priv.h\"\n\nstatic int ufs_bsg_get_query_desc_size(struct ufs_hba *hba, int *desc_len,\n\t\t\t\t       struct utp_upiu_query *qr)\n{\n\tint desc_size = be16_to_cpu(qr->length);\n\n\tif (desc_size <= 0)\n\t\treturn -EINVAL;\n\n\t*desc_len = min_t(int, QUERY_DESC_MAX_SIZE, desc_size);\n\n\treturn 0;\n}\n\nstatic int ufs_bsg_alloc_desc_buffer(struct ufs_hba *hba, struct bsg_job *job,\n\t\t\t\t     uint8_t **desc_buff, int *desc_len,\n\t\t\t\t     enum query_opcode desc_op)\n{\n\tstruct ufs_bsg_request *bsg_request = job->request;\n\tstruct utp_upiu_query *qr;\n\tu8 *descp;\n\n\tif (desc_op != UPIU_QUERY_OPCODE_WRITE_DESC &&\n\t    desc_op != UPIU_QUERY_OPCODE_READ_DESC)\n\t\tgoto out;\n\n\tqr = &bsg_request->upiu_req.qr;\n\tif (ufs_bsg_get_query_desc_size(hba, desc_len, qr)) {\n\t\tdev_err(hba->dev, \"Illegal desc size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*desc_len > job->request_payload.payload_len) {\n\t\tdev_err(hba->dev, \"Illegal desc size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdescp = kzalloc(*desc_len, GFP_KERNEL);\n\tif (!descp)\n\t\treturn -ENOMEM;\n\n\tif (desc_op == UPIU_QUERY_OPCODE_WRITE_DESC)\n\t\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t\t  job->request_payload.sg_cnt, descp,\n\t\t\t\t  *desc_len);\n\n\t*desc_buff = descp;\n\nout:\n\treturn 0;\n}\n\nstatic int ufs_bsg_exec_advanced_rpmb_req(struct ufs_hba *hba, struct bsg_job *job)\n{\n\tstruct ufs_rpmb_request *rpmb_request = job->request;\n\tstruct ufs_rpmb_reply *rpmb_reply = job->reply;\n\tstruct bsg_buffer *payload = NULL;\n\tenum dma_data_direction dir;\n\tstruct scatterlist *sg_list = NULL;\n\tint rpmb_req_type;\n\tint sg_cnt = 0;\n\tint ret;\n\tint data_len;\n\n\tif (hba->ufs_version < ufshci_version(4, 0) || !hba->dev_info.b_advanced_rpmb_en)\n\t\treturn -EINVAL;\n\n\tif (rpmb_request->ehs_req.length != 2 || rpmb_request->ehs_req.ehs_type != 1)\n\t\treturn -EINVAL;\n\n\trpmb_req_type = be16_to_cpu(rpmb_request->ehs_req.meta.req_resp_type);\n\n\tswitch (rpmb_req_type) {\n\tcase UFS_RPMB_WRITE_KEY:\n\tcase UFS_RPMB_READ_CNT:\n\tcase UFS_RPMB_PURGE_ENABLE:\n\t\tdir = DMA_NONE;\n\t\tbreak;\n\tcase UFS_RPMB_WRITE:\n\tcase UFS_RPMB_SEC_CONF_WRITE:\n\t\tdir = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase UFS_RPMB_READ:\n\tcase UFS_RPMB_SEC_CONF_READ:\n\tcase UFS_RPMB_PURGE_STATUS_READ:\n\t\tdir = DMA_FROM_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (dir != DMA_NONE) {\n\t\tpayload = &job->request_payload;\n\t\tif (!payload || !payload->payload_len || !payload->sg_cnt)\n\t\t\treturn -EINVAL;\n\n\t\tsg_cnt = dma_map_sg(hba->host->dma_dev, payload->sg_list, payload->sg_cnt, dir);\n\t\tif (unlikely(!sg_cnt))\n\t\t\treturn -ENOMEM;\n\t\tsg_list = payload->sg_list;\n\t\tdata_len = payload->payload_len;\n\t}\n\n\tret = ufshcd_advanced_rpmb_req_handler(hba, &rpmb_request->bsg_request.upiu_req,\n\t\t\t\t   &rpmb_reply->bsg_reply.upiu_rsp, &rpmb_request->ehs_req,\n\t\t\t\t   &rpmb_reply->ehs_rsp, sg_cnt, sg_list, dir);\n\n\tif (dir != DMA_NONE) {\n\t\tdma_unmap_sg(hba->host->dma_dev, payload->sg_list, payload->sg_cnt, dir);\n\n\t\tif (!ret)\n\t\t\trpmb_reply->bsg_reply.reply_payload_rcv_len = data_len;\n\t}\n\n\treturn ret;\n}\n\nstatic int ufs_bsg_request(struct bsg_job *job)\n{\n\tstruct ufs_bsg_request *bsg_request = job->request;\n\tstruct ufs_bsg_reply *bsg_reply = job->reply;\n\tstruct ufs_hba *hba = shost_priv(dev_to_shost(job->dev->parent));\n\tstruct uic_command uc = {};\n\tint msgcode;\n\tuint8_t *buff = NULL;\n\tint desc_len = 0;\n\tenum query_opcode desc_op = UPIU_QUERY_OPCODE_NOP;\n\tint ret;\n\tbool rpmb = false;\n\n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tufshcd_rpm_get_sync(hba);\n\n\tmsgcode = bsg_request->msgcode;\n\tswitch (msgcode) {\n\tcase UPIU_TRANSACTION_QUERY_REQ:\n\t\tdesc_op = bsg_request->upiu_req.qr.opcode;\n\t\tret = ufs_bsg_alloc_desc_buffer(hba, job, &buff, &desc_len, desc_op);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tfallthrough;\n\tcase UPIU_TRANSACTION_NOP_OUT:\n\tcase UPIU_TRANSACTION_TASK_REQ:\n\t\tret = ufshcd_exec_raw_upiu_cmd(hba, &bsg_request->upiu_req,\n\t\t\t\t\t       &bsg_reply->upiu_rsp, msgcode,\n\t\t\t\t\t       buff, &desc_len, desc_op);\n\t\tif (ret)\n\t\t\tdev_err(hba->dev, \"exe raw upiu: error code %d\\n\", ret);\n\t\telse if (desc_op == UPIU_QUERY_OPCODE_READ_DESC && desc_len) {\n\t\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\t\tsg_copy_from_buffer(job->request_payload.sg_list,\n\t\t\t\t\t\t    job->request_payload.sg_cnt,\n\t\t\t\t\t\t    buff, desc_len);\n\t\t}\n\t\tbreak;\n\tcase UPIU_TRANSACTION_UIC_CMD:\n\t\tmemcpy(&uc, &bsg_request->upiu_req.uc, UIC_CMD_SIZE);\n\t\tret = ufshcd_send_uic_cmd(hba, &uc);\n\t\tif (ret)\n\t\t\tdev_err(hba->dev, \"send uic cmd: error code %d\\n\", ret);\n\n\t\tmemcpy(&bsg_reply->upiu_rsp.uc, &uc, UIC_CMD_SIZE);\n\n\t\tbreak;\n\tcase UPIU_TRANSACTION_ARPMB_CMD:\n\t\trpmb = true;\n\t\tret = ufs_bsg_exec_advanced_rpmb_req(hba, job);\n\t\tif (ret)\n\t\t\tdev_err(hba->dev, \"ARPMB OP failed: error code  %d\\n\", ret);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tdev_err(hba->dev, \"unsupported msgcode 0x%x\\n\", msgcode);\n\n\t\tbreak;\n\t}\n\nout:\n\tufshcd_rpm_put_sync(hba);\n\tkfree(buff);\n\tbsg_reply->result = ret;\n\tjob->reply_len = !rpmb ? sizeof(struct ufs_bsg_reply) : sizeof(struct ufs_rpmb_reply);\n\t \n\tif (ret == 0)\n\t\tbsg_job_done(job, ret, bsg_reply->reply_payload_rcv_len);\n\n\treturn ret;\n}\n\n \nvoid ufs_bsg_remove(struct ufs_hba *hba)\n{\n\tstruct device *bsg_dev = &hba->bsg_dev;\n\n\tif (!hba->bsg_queue)\n\t\treturn;\n\n\tbsg_remove_queue(hba->bsg_queue);\n\n\tdevice_del(bsg_dev);\n\tput_device(bsg_dev);\n}\n\nstatic inline void ufs_bsg_node_release(struct device *dev)\n{\n\tput_device(dev->parent);\n}\n\n \nint ufs_bsg_probe(struct ufs_hba *hba)\n{\n\tstruct device *bsg_dev = &hba->bsg_dev;\n\tstruct Scsi_Host *shost = hba->host;\n\tstruct device *parent = &shost->shost_gendev;\n\tstruct request_queue *q;\n\tint ret;\n\n\tdevice_initialize(bsg_dev);\n\n\tbsg_dev->parent = get_device(parent);\n\tbsg_dev->release = ufs_bsg_node_release;\n\n\tdev_set_name(bsg_dev, \"ufs-bsg%u\", shost->host_no);\n\n\tret = device_add(bsg_dev);\n\tif (ret)\n\t\tgoto out;\n\n\tq = bsg_setup_queue(bsg_dev, dev_name(bsg_dev), ufs_bsg_request, NULL, 0);\n\tif (IS_ERR(q)) {\n\t\tret = PTR_ERR(q);\n\t\tgoto out;\n\t}\n\n\thba->bsg_queue = q;\n\n\treturn 0;\n\nout:\n\tdev_err(bsg_dev, \"fail to initialize a bsg dev %d\\n\", shost->host_no);\n\tput_device(bsg_dev);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}