{
  "module_name": "ufs-sysfs.c",
  "hash_id": "7fd02cbc97b2fe4db0539499a1c46974c0f4a5a5510330ad8ff772a11db97844",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ufs/core/ufs-sysfs.c",
  "human_readable_source": "\n\n\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/bitfield.h>\n#include <asm/unaligned.h>\n\n#include <ufs/ufs.h>\n#include \"ufs-sysfs.h\"\n#include \"ufshcd-priv.h\"\n\nstatic const char *ufshcd_uic_link_state_to_string(\n\t\t\tenum uic_link_state state)\n{\n\tswitch (state) {\n\tcase UIC_LINK_OFF_STATE:\treturn \"OFF\";\n\tcase UIC_LINK_ACTIVE_STATE:\treturn \"ACTIVE\";\n\tcase UIC_LINK_HIBERN8_STATE:\treturn \"HIBERN8\";\n\tcase UIC_LINK_BROKEN_STATE:\treturn \"BROKEN\";\n\tdefault:\t\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic const char *ufshcd_ufs_dev_pwr_mode_to_string(\n\t\t\tenum ufs_dev_pwr_mode state)\n{\n\tswitch (state) {\n\tcase UFS_ACTIVE_PWR_MODE:\treturn \"ACTIVE\";\n\tcase UFS_SLEEP_PWR_MODE:\treturn \"SLEEP\";\n\tcase UFS_POWERDOWN_PWR_MODE:\treturn \"POWERDOWN\";\n\tcase UFS_DEEPSLEEP_PWR_MODE:\treturn \"DEEPSLEEP\";\n\tdefault:\t\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic inline ssize_t ufs_sysfs_pm_lvl_store(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count,\n\t\t\t\t\t     bool rpm)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tstruct ufs_dev_info *dev_info = &hba->dev_info;\n\tunsigned long flags, value;\n\n\tif (kstrtoul(buf, 0, &value))\n\t\treturn -EINVAL;\n\n\tif (value >= UFS_PM_LVL_MAX)\n\t\treturn -EINVAL;\n\n\tif (ufs_pm_lvl_states[value].dev_state == UFS_DEEPSLEEP_PWR_MODE &&\n\t    (!(hba->caps & UFSHCD_CAP_DEEPSLEEP) ||\n\t     !(dev_info->wspecversion >= 0x310)))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (rpm)\n\t\thba->rpm_lvl = value;\n\telse\n\t\thba->spm_lvl = value;\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\treturn count;\n}\n\nstatic ssize_t rpm_lvl_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", hba->rpm_lvl);\n}\n\nstatic ssize_t rpm_lvl_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn ufs_sysfs_pm_lvl_store(dev, attr, buf, count, true);\n}\n\nstatic ssize_t rpm_target_dev_state_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", ufshcd_ufs_dev_pwr_mode_to_string(\n\t\t\tufs_pm_lvl_states[hba->rpm_lvl].dev_state));\n}\n\nstatic ssize_t rpm_target_link_state_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", ufshcd_uic_link_state_to_string(\n\t\t\tufs_pm_lvl_states[hba->rpm_lvl].link_state));\n}\n\nstatic ssize_t spm_lvl_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", hba->spm_lvl);\n}\n\nstatic ssize_t spm_lvl_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\treturn ufs_sysfs_pm_lvl_store(dev, attr, buf, count, false);\n}\n\nstatic ssize_t spm_target_dev_state_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", ufshcd_ufs_dev_pwr_mode_to_string(\n\t\t\t\tufs_pm_lvl_states[hba->spm_lvl].dev_state));\n}\n\nstatic ssize_t spm_target_link_state_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", ufshcd_uic_link_state_to_string(\n\t\t\t\tufs_pm_lvl_states[hba->spm_lvl].link_state));\n}\n\n \nstatic int ufshcd_ahit_to_us(u32 ahit)\n{\n\tint timer = FIELD_GET(UFSHCI_AHIBERN8_TIMER_MASK, ahit);\n\tint scale = FIELD_GET(UFSHCI_AHIBERN8_SCALE_MASK, ahit);\n\n\tfor (; scale > 0; --scale)\n\t\ttimer *= UFSHCI_AHIBERN8_SCALE_FACTOR;\n\n\treturn timer;\n}\n\n \nstatic u32 ufshcd_us_to_ahit(unsigned int timer)\n{\n\tunsigned int scale;\n\n\tfor (scale = 0; timer > UFSHCI_AHIBERN8_TIMER_MASK; ++scale)\n\t\ttimer /= UFSHCI_AHIBERN8_SCALE_FACTOR;\n\n\treturn FIELD_PREP(UFSHCI_AHIBERN8_TIMER_MASK, timer) |\n\t       FIELD_PREP(UFSHCI_AHIBERN8_SCALE_MASK, scale);\n}\n\nstatic ssize_t auto_hibern8_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tu32 ahit;\n\tint ret;\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\tif (!ufshcd_is_auto_hibern8_supported(hba))\n\t\treturn -EOPNOTSUPP;\n\n\tdown(&hba->host_sem);\n\tif (!ufshcd_is_user_access_allowed(hba)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tpm_runtime_get_sync(hba->dev);\n\tufshcd_hold(hba);\n\tahit = ufshcd_readl(hba, REG_AUTO_HIBERNATE_IDLE_TIMER);\n\tufshcd_release(hba);\n\tpm_runtime_put_sync(hba->dev);\n\n\tret = sysfs_emit(buf, \"%d\\n\", ufshcd_ahit_to_us(ahit));\n\nout:\n\tup(&hba->host_sem);\n\treturn ret;\n}\n\nstatic ssize_t auto_hibern8_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tunsigned int timer;\n\tint ret = 0;\n\n\tif (!ufshcd_is_auto_hibern8_supported(hba))\n\t\treturn -EOPNOTSUPP;\n\n\tif (kstrtouint(buf, 0, &timer))\n\t\treturn -EINVAL;\n\n\tif (timer > UFSHCI_AHIBERN8_MAX)\n\t\treturn -EINVAL;\n\n\tdown(&hba->host_sem);\n\tif (!ufshcd_is_user_access_allowed(hba)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tufshcd_auto_hibern8_update(hba, ufshcd_us_to_ahit(timer));\n\nout:\n\tup(&hba->host_sem);\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t wb_on_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", hba->dev_info.wb_enabled);\n}\n\nstatic ssize_t wb_on_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tunsigned int wb_enable;\n\tssize_t res;\n\n\tif (!ufshcd_is_wb_allowed(hba) || (ufshcd_is_clkscaling_supported(hba)\n\t\t&& ufshcd_enable_wb_if_scaling_up(hba))) {\n\t\t \n\t\tdev_warn(dev, \"It is not allowed to configure WB!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (kstrtouint(buf, 0, &wb_enable))\n\t\treturn -EINVAL;\n\n\tif (wb_enable != 0 && wb_enable != 1)\n\t\treturn -EINVAL;\n\n\tdown(&hba->host_sem);\n\tif (!ufshcd_is_user_access_allowed(hba)) {\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tufshcd_rpm_get_sync(hba);\n\tres = ufshcd_wb_toggle(hba, wb_enable);\n\tufshcd_rpm_put_sync(hba);\nout:\n\tup(&hba->host_sem);\n\treturn res < 0 ? res : count;\n}\n\nstatic ssize_t enable_wb_buf_flush_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", hba->dev_info.wb_buf_flush_enabled);\n}\n\nstatic ssize_t enable_wb_buf_flush_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tunsigned int enable_wb_buf_flush;\n\tssize_t res;\n\n\tif (!ufshcd_is_wb_buf_flush_allowed(hba)) {\n\t\tdev_warn(dev, \"It is not allowed to configure WB buf flushing!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (kstrtouint(buf, 0, &enable_wb_buf_flush))\n\t\treturn -EINVAL;\n\n\tif (enable_wb_buf_flush != 0 && enable_wb_buf_flush != 1)\n\t\treturn -EINVAL;\n\n\tdown(&hba->host_sem);\n\tif (!ufshcd_is_user_access_allowed(hba)) {\n\t\tres = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tufshcd_rpm_get_sync(hba);\n\tres = ufshcd_wb_toggle_buf_flush(hba, enable_wb_buf_flush);\n\tufshcd_rpm_put_sync(hba);\n\nout:\n\tup(&hba->host_sem);\n\treturn res < 0 ? res : count;\n}\n\nstatic ssize_t wb_flush_threshold_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", hba->vps->wb_flush_threshold);\n}\n\nstatic ssize_t wb_flush_threshold_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tunsigned int wb_flush_threshold;\n\n\tif (kstrtouint(buf, 0, &wb_flush_threshold))\n\t\treturn -EINVAL;\n\n\t \n\tif (wb_flush_threshold > UFS_WB_BUF_REMAIN_PERCENT(100) ||\n\t    wb_flush_threshold == 0) {\n\t\tdev_err(dev, \"The value of wb_flush_threshold is invalid!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thba->vps->wb_flush_threshold = wb_flush_threshold;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(rpm_lvl);\nstatic DEVICE_ATTR_RO(rpm_target_dev_state);\nstatic DEVICE_ATTR_RO(rpm_target_link_state);\nstatic DEVICE_ATTR_RW(spm_lvl);\nstatic DEVICE_ATTR_RO(spm_target_dev_state);\nstatic DEVICE_ATTR_RO(spm_target_link_state);\nstatic DEVICE_ATTR_RW(auto_hibern8);\nstatic DEVICE_ATTR_RW(wb_on);\nstatic DEVICE_ATTR_RW(enable_wb_buf_flush);\nstatic DEVICE_ATTR_RW(wb_flush_threshold);\n\nstatic struct attribute *ufs_sysfs_ufshcd_attrs[] = {\n\t&dev_attr_rpm_lvl.attr,\n\t&dev_attr_rpm_target_dev_state.attr,\n\t&dev_attr_rpm_target_link_state.attr,\n\t&dev_attr_spm_lvl.attr,\n\t&dev_attr_spm_target_dev_state.attr,\n\t&dev_attr_spm_target_link_state.attr,\n\t&dev_attr_auto_hibern8.attr,\n\t&dev_attr_wb_on.attr,\n\t&dev_attr_enable_wb_buf_flush.attr,\n\t&dev_attr_wb_flush_threshold.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ufs_sysfs_default_group = {\n\t.attrs = ufs_sysfs_ufshcd_attrs,\n};\n\nstatic ssize_t clock_scaling_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ufshcd_is_clkscaling_supported(hba));\n}\n\nstatic ssize_t write_booster_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", ufshcd_is_wb_allowed(hba));\n}\n\nstatic DEVICE_ATTR_RO(clock_scaling);\nstatic DEVICE_ATTR_RO(write_booster);\n\n \nstatic struct attribute *ufs_sysfs_capabilities_attrs[] = {\n\t&dev_attr_clock_scaling.attr,\n\t&dev_attr_write_booster.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ufs_sysfs_capabilities_group = {\n\t.name = \"capabilities\",\n\t.attrs = ufs_sysfs_capabilities_attrs,\n};\n\nstatic ssize_t monitor_enable_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", hba->monitor.enabled);\n}\n\nstatic ssize_t monitor_enable_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tunsigned long value, flags;\n\n\tif (kstrtoul(buf, 0, &value))\n\t\treturn -EINVAL;\n\n\tvalue = !!value;\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (value == hba->monitor.enabled)\n\t\tgoto out_unlock;\n\n\tif (!value) {\n\t\tmemset(&hba->monitor, 0, sizeof(hba->monitor));\n\t} else {\n\t\thba->monitor.enabled = true;\n\t\thba->monitor.enabled_ts = ktime_get();\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\treturn count;\n}\n\nstatic ssize_t monitor_chunk_size_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", hba->monitor.chunk_size);\n}\n\nstatic ssize_t monitor_chunk_size_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tunsigned long value, flags;\n\n\tif (kstrtoul(buf, 0, &value))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t \n\tif (!hba->monitor.enabled)\n\t\thba->monitor.chunk_size = value;\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\treturn count;\n}\n\nstatic ssize_t read_total_sectors_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", hba->monitor.nr_sec_rw[READ]);\n}\n\nstatic ssize_t read_total_busy_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  ktime_to_us(hba->monitor.total_busy[READ]));\n}\n\nstatic ssize_t read_nr_requests_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", hba->monitor.nr_req[READ]);\n}\n\nstatic ssize_t read_req_latency_avg_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tstruct ufs_hba_monitor *m = &hba->monitor;\n\n\treturn sysfs_emit(buf, \"%llu\\n\", div_u64(ktime_to_us(m->lat_sum[READ]),\n\t\t\t\t\t\t m->nr_req[READ]));\n}\n\nstatic ssize_t read_req_latency_max_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  ktime_to_us(hba->monitor.lat_max[READ]));\n}\n\nstatic ssize_t read_req_latency_min_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  ktime_to_us(hba->monitor.lat_min[READ]));\n}\n\nstatic ssize_t read_req_latency_sum_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  ktime_to_us(hba->monitor.lat_sum[READ]));\n}\n\nstatic ssize_t write_total_sectors_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", hba->monitor.nr_sec_rw[WRITE]);\n}\n\nstatic ssize_t write_total_busy_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  ktime_to_us(hba->monitor.total_busy[WRITE]));\n}\n\nstatic ssize_t write_nr_requests_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", hba->monitor.nr_req[WRITE]);\n}\n\nstatic ssize_t write_req_latency_avg_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tstruct ufs_hba_monitor *m = &hba->monitor;\n\n\treturn sysfs_emit(buf, \"%llu\\n\", div_u64(ktime_to_us(m->lat_sum[WRITE]),\n\t\t\t\t\t\t m->nr_req[WRITE]));\n}\n\nstatic ssize_t write_req_latency_max_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  ktime_to_us(hba->monitor.lat_max[WRITE]));\n}\n\nstatic ssize_t write_req_latency_min_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  ktime_to_us(hba->monitor.lat_min[WRITE]));\n}\n\nstatic ssize_t write_req_latency_sum_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  ktime_to_us(hba->monitor.lat_sum[WRITE]));\n}\n\nstatic DEVICE_ATTR_RW(monitor_enable);\nstatic DEVICE_ATTR_RW(monitor_chunk_size);\nstatic DEVICE_ATTR_RO(read_total_sectors);\nstatic DEVICE_ATTR_RO(read_total_busy);\nstatic DEVICE_ATTR_RO(read_nr_requests);\nstatic DEVICE_ATTR_RO(read_req_latency_avg);\nstatic DEVICE_ATTR_RO(read_req_latency_max);\nstatic DEVICE_ATTR_RO(read_req_latency_min);\nstatic DEVICE_ATTR_RO(read_req_latency_sum);\nstatic DEVICE_ATTR_RO(write_total_sectors);\nstatic DEVICE_ATTR_RO(write_total_busy);\nstatic DEVICE_ATTR_RO(write_nr_requests);\nstatic DEVICE_ATTR_RO(write_req_latency_avg);\nstatic DEVICE_ATTR_RO(write_req_latency_max);\nstatic DEVICE_ATTR_RO(write_req_latency_min);\nstatic DEVICE_ATTR_RO(write_req_latency_sum);\n\nstatic struct attribute *ufs_sysfs_monitor_attrs[] = {\n\t&dev_attr_monitor_enable.attr,\n\t&dev_attr_monitor_chunk_size.attr,\n\t&dev_attr_read_total_sectors.attr,\n\t&dev_attr_read_total_busy.attr,\n\t&dev_attr_read_nr_requests.attr,\n\t&dev_attr_read_req_latency_avg.attr,\n\t&dev_attr_read_req_latency_max.attr,\n\t&dev_attr_read_req_latency_min.attr,\n\t&dev_attr_read_req_latency_sum.attr,\n\t&dev_attr_write_total_sectors.attr,\n\t&dev_attr_write_total_busy.attr,\n\t&dev_attr_write_nr_requests.attr,\n\t&dev_attr_write_req_latency_avg.attr,\n\t&dev_attr_write_req_latency_max.attr,\n\t&dev_attr_write_req_latency_min.attr,\n\t&dev_attr_write_req_latency_sum.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ufs_sysfs_monitor_group = {\n\t.name = \"monitor\",\n\t.attrs = ufs_sysfs_monitor_attrs,\n};\n\nstatic ssize_t ufs_sysfs_read_desc_param(struct ufs_hba *hba,\n\t\t\t\t  enum desc_idn desc_id,\n\t\t\t\t  u8 desc_index,\n\t\t\t\t  u8 param_offset,\n\t\t\t\t  u8 *sysfs_buf,\n\t\t\t\t  u8 param_size)\n{\n\tu8 desc_buf[8] = {0};\n\tint ret;\n\n\tif (param_size > 8)\n\t\treturn -EINVAL;\n\n\tdown(&hba->host_sem);\n\tif (!ufshcd_is_user_access_allowed(hba)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tufshcd_rpm_get_sync(hba);\n\tret = ufshcd_read_desc_param(hba, desc_id, desc_index,\n\t\t\t\tparam_offset, desc_buf, param_size);\n\tufshcd_rpm_put_sync(hba);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (param_size) {\n\tcase 1:\n\t\tret = sysfs_emit(sysfs_buf, \"0x%02X\\n\", *desc_buf);\n\t\tbreak;\n\tcase 2:\n\t\tret = sysfs_emit(sysfs_buf, \"0x%04X\\n\",\n\t\t\tget_unaligned_be16(desc_buf));\n\t\tbreak;\n\tcase 4:\n\t\tret = sysfs_emit(sysfs_buf, \"0x%08X\\n\",\n\t\t\tget_unaligned_be32(desc_buf));\n\t\tbreak;\n\tcase 8:\n\t\tret = sysfs_emit(sysfs_buf, \"0x%016llX\\n\",\n\t\t\tget_unaligned_be64(desc_buf));\n\t\tbreak;\n\t}\n\nout:\n\tup(&hba->host_sem);\n\treturn ret;\n}\n\n#define UFS_DESC_PARAM(_name, _puname, _duname, _size)\t\t\t\\\nstatic ssize_t _name##_show(struct device *dev,\t\t\t\t\\\n\tstruct device_attribute *attr, char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\t\t\t\\\n\treturn ufs_sysfs_read_desc_param(hba, QUERY_DESC_IDN_##_duname,\t\\\n\t\t0, _duname##_DESC_PARAM##_puname, buf, _size);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(_name)\n\n#define UFS_DEVICE_DESC_PARAM(_name, _uname, _size)\t\t\t\\\n\tUFS_DESC_PARAM(_name, _uname, DEVICE, _size)\n\nUFS_DEVICE_DESC_PARAM(device_type, _DEVICE_TYPE, 1);\nUFS_DEVICE_DESC_PARAM(device_class, _DEVICE_CLASS, 1);\nUFS_DEVICE_DESC_PARAM(device_sub_class, _DEVICE_SUB_CLASS, 1);\nUFS_DEVICE_DESC_PARAM(protocol, _PRTCL, 1);\nUFS_DEVICE_DESC_PARAM(number_of_luns, _NUM_LU, 1);\nUFS_DEVICE_DESC_PARAM(number_of_wluns, _NUM_WLU, 1);\nUFS_DEVICE_DESC_PARAM(boot_enable, _BOOT_ENBL, 1);\nUFS_DEVICE_DESC_PARAM(descriptor_access_enable, _DESC_ACCSS_ENBL, 1);\nUFS_DEVICE_DESC_PARAM(initial_power_mode, _INIT_PWR_MODE, 1);\nUFS_DEVICE_DESC_PARAM(high_priority_lun, _HIGH_PR_LUN, 1);\nUFS_DEVICE_DESC_PARAM(secure_removal_type, _SEC_RMV_TYPE, 1);\nUFS_DEVICE_DESC_PARAM(support_security_lun, _SEC_LU, 1);\nUFS_DEVICE_DESC_PARAM(bkops_termination_latency, _BKOP_TERM_LT, 1);\nUFS_DEVICE_DESC_PARAM(initial_active_icc_level, _ACTVE_ICC_LVL, 1);\nUFS_DEVICE_DESC_PARAM(specification_version, _SPEC_VER, 2);\nUFS_DEVICE_DESC_PARAM(manufacturing_date, _MANF_DATE, 2);\nUFS_DEVICE_DESC_PARAM(manufacturer_id, _MANF_ID, 2);\nUFS_DEVICE_DESC_PARAM(rtt_capability, _RTT_CAP, 1);\nUFS_DEVICE_DESC_PARAM(rtc_update, _FRQ_RTC, 2);\nUFS_DEVICE_DESC_PARAM(ufs_features, _UFS_FEAT, 1);\nUFS_DEVICE_DESC_PARAM(ffu_timeout, _FFU_TMT, 1);\nUFS_DEVICE_DESC_PARAM(queue_depth, _Q_DPTH, 1);\nUFS_DEVICE_DESC_PARAM(device_version, _DEV_VER, 2);\nUFS_DEVICE_DESC_PARAM(number_of_secure_wpa, _NUM_SEC_WPA, 1);\nUFS_DEVICE_DESC_PARAM(psa_max_data_size, _PSA_MAX_DATA, 4);\nUFS_DEVICE_DESC_PARAM(psa_state_timeout, _PSA_TMT, 1);\nUFS_DEVICE_DESC_PARAM(ext_feature_sup, _EXT_UFS_FEATURE_SUP, 4);\nUFS_DEVICE_DESC_PARAM(wb_presv_us_en, _WB_PRESRV_USRSPC_EN, 1);\nUFS_DEVICE_DESC_PARAM(wb_type, _WB_TYPE, 1);\nUFS_DEVICE_DESC_PARAM(wb_shared_alloc_units, _WB_SHARED_ALLOC_UNITS, 4);\n\nstatic struct attribute *ufs_sysfs_device_descriptor[] = {\n\t&dev_attr_device_type.attr,\n\t&dev_attr_device_class.attr,\n\t&dev_attr_device_sub_class.attr,\n\t&dev_attr_protocol.attr,\n\t&dev_attr_number_of_luns.attr,\n\t&dev_attr_number_of_wluns.attr,\n\t&dev_attr_boot_enable.attr,\n\t&dev_attr_descriptor_access_enable.attr,\n\t&dev_attr_initial_power_mode.attr,\n\t&dev_attr_high_priority_lun.attr,\n\t&dev_attr_secure_removal_type.attr,\n\t&dev_attr_support_security_lun.attr,\n\t&dev_attr_bkops_termination_latency.attr,\n\t&dev_attr_initial_active_icc_level.attr,\n\t&dev_attr_specification_version.attr,\n\t&dev_attr_manufacturing_date.attr,\n\t&dev_attr_manufacturer_id.attr,\n\t&dev_attr_rtt_capability.attr,\n\t&dev_attr_rtc_update.attr,\n\t&dev_attr_ufs_features.attr,\n\t&dev_attr_ffu_timeout.attr,\n\t&dev_attr_queue_depth.attr,\n\t&dev_attr_device_version.attr,\n\t&dev_attr_number_of_secure_wpa.attr,\n\t&dev_attr_psa_max_data_size.attr,\n\t&dev_attr_psa_state_timeout.attr,\n\t&dev_attr_ext_feature_sup.attr,\n\t&dev_attr_wb_presv_us_en.attr,\n\t&dev_attr_wb_type.attr,\n\t&dev_attr_wb_shared_alloc_units.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ufs_sysfs_device_descriptor_group = {\n\t.name = \"device_descriptor\",\n\t.attrs = ufs_sysfs_device_descriptor,\n};\n\n#define UFS_INTERCONNECT_DESC_PARAM(_name, _uname, _size)\t\t\\\n\tUFS_DESC_PARAM(_name, _uname, INTERCONNECT, _size)\n\nUFS_INTERCONNECT_DESC_PARAM(unipro_version, _UNIPRO_VER, 2);\nUFS_INTERCONNECT_DESC_PARAM(mphy_version, _MPHY_VER, 2);\n\nstatic struct attribute *ufs_sysfs_interconnect_descriptor[] = {\n\t&dev_attr_unipro_version.attr,\n\t&dev_attr_mphy_version.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ufs_sysfs_interconnect_descriptor_group = {\n\t.name = \"interconnect_descriptor\",\n\t.attrs = ufs_sysfs_interconnect_descriptor,\n};\n\n#define UFS_GEOMETRY_DESC_PARAM(_name, _uname, _size)\t\t\t\\\n\tUFS_DESC_PARAM(_name, _uname, GEOMETRY, _size)\n\nUFS_GEOMETRY_DESC_PARAM(raw_device_capacity, _DEV_CAP, 8);\nUFS_GEOMETRY_DESC_PARAM(max_number_of_luns, _MAX_NUM_LUN, 1);\nUFS_GEOMETRY_DESC_PARAM(segment_size, _SEG_SIZE, 4);\nUFS_GEOMETRY_DESC_PARAM(allocation_unit_size, _ALLOC_UNIT_SIZE, 1);\nUFS_GEOMETRY_DESC_PARAM(min_addressable_block_size, _MIN_BLK_SIZE, 1);\nUFS_GEOMETRY_DESC_PARAM(optimal_read_block_size, _OPT_RD_BLK_SIZE, 1);\nUFS_GEOMETRY_DESC_PARAM(optimal_write_block_size, _OPT_WR_BLK_SIZE, 1);\nUFS_GEOMETRY_DESC_PARAM(max_in_buffer_size, _MAX_IN_BUF_SIZE, 1);\nUFS_GEOMETRY_DESC_PARAM(max_out_buffer_size, _MAX_OUT_BUF_SIZE, 1);\nUFS_GEOMETRY_DESC_PARAM(rpmb_rw_size, _RPMB_RW_SIZE, 1);\nUFS_GEOMETRY_DESC_PARAM(dyn_capacity_resource_policy, _DYN_CAP_RSRC_PLC, 1);\nUFS_GEOMETRY_DESC_PARAM(data_ordering, _DATA_ORDER, 1);\nUFS_GEOMETRY_DESC_PARAM(max_number_of_contexts, _MAX_NUM_CTX, 1);\nUFS_GEOMETRY_DESC_PARAM(sys_data_tag_unit_size, _TAG_UNIT_SIZE, 1);\nUFS_GEOMETRY_DESC_PARAM(sys_data_tag_resource_size, _TAG_RSRC_SIZE, 1);\nUFS_GEOMETRY_DESC_PARAM(secure_removal_types, _SEC_RM_TYPES, 1);\nUFS_GEOMETRY_DESC_PARAM(memory_types, _MEM_TYPES, 2);\nUFS_GEOMETRY_DESC_PARAM(sys_code_memory_max_alloc_units,\n\t_SCM_MAX_NUM_UNITS, 4);\nUFS_GEOMETRY_DESC_PARAM(sys_code_memory_capacity_adjustment_factor,\n\t_SCM_CAP_ADJ_FCTR, 2);\nUFS_GEOMETRY_DESC_PARAM(non_persist_memory_max_alloc_units,\n\t_NPM_MAX_NUM_UNITS, 4);\nUFS_GEOMETRY_DESC_PARAM(non_persist_memory_capacity_adjustment_factor,\n\t_NPM_CAP_ADJ_FCTR, 2);\nUFS_GEOMETRY_DESC_PARAM(enh1_memory_max_alloc_units,\n\t_ENM1_MAX_NUM_UNITS, 4);\nUFS_GEOMETRY_DESC_PARAM(enh1_memory_capacity_adjustment_factor,\n\t_ENM1_CAP_ADJ_FCTR, 2);\nUFS_GEOMETRY_DESC_PARAM(enh2_memory_max_alloc_units,\n\t_ENM2_MAX_NUM_UNITS, 4);\nUFS_GEOMETRY_DESC_PARAM(enh2_memory_capacity_adjustment_factor,\n\t_ENM2_CAP_ADJ_FCTR, 2);\nUFS_GEOMETRY_DESC_PARAM(enh3_memory_max_alloc_units,\n\t_ENM3_MAX_NUM_UNITS, 4);\nUFS_GEOMETRY_DESC_PARAM(enh3_memory_capacity_adjustment_factor,\n\t_ENM3_CAP_ADJ_FCTR, 2);\nUFS_GEOMETRY_DESC_PARAM(enh4_memory_max_alloc_units,\n\t_ENM4_MAX_NUM_UNITS, 4);\nUFS_GEOMETRY_DESC_PARAM(enh4_memory_capacity_adjustment_factor,\n\t_ENM4_CAP_ADJ_FCTR, 2);\nUFS_GEOMETRY_DESC_PARAM(wb_max_alloc_units, _WB_MAX_ALLOC_UNITS, 4);\nUFS_GEOMETRY_DESC_PARAM(wb_max_wb_luns, _WB_MAX_WB_LUNS, 1);\nUFS_GEOMETRY_DESC_PARAM(wb_buff_cap_adj, _WB_BUFF_CAP_ADJ, 1);\nUFS_GEOMETRY_DESC_PARAM(wb_sup_red_type, _WB_SUP_RED_TYPE, 1);\nUFS_GEOMETRY_DESC_PARAM(wb_sup_wb_type, _WB_SUP_WB_TYPE, 1);\n\n\nstatic struct attribute *ufs_sysfs_geometry_descriptor[] = {\n\t&dev_attr_raw_device_capacity.attr,\n\t&dev_attr_max_number_of_luns.attr,\n\t&dev_attr_segment_size.attr,\n\t&dev_attr_allocation_unit_size.attr,\n\t&dev_attr_min_addressable_block_size.attr,\n\t&dev_attr_optimal_read_block_size.attr,\n\t&dev_attr_optimal_write_block_size.attr,\n\t&dev_attr_max_in_buffer_size.attr,\n\t&dev_attr_max_out_buffer_size.attr,\n\t&dev_attr_rpmb_rw_size.attr,\n\t&dev_attr_dyn_capacity_resource_policy.attr,\n\t&dev_attr_data_ordering.attr,\n\t&dev_attr_max_number_of_contexts.attr,\n\t&dev_attr_sys_data_tag_unit_size.attr,\n\t&dev_attr_sys_data_tag_resource_size.attr,\n\t&dev_attr_secure_removal_types.attr,\n\t&dev_attr_memory_types.attr,\n\t&dev_attr_sys_code_memory_max_alloc_units.attr,\n\t&dev_attr_sys_code_memory_capacity_adjustment_factor.attr,\n\t&dev_attr_non_persist_memory_max_alloc_units.attr,\n\t&dev_attr_non_persist_memory_capacity_adjustment_factor.attr,\n\t&dev_attr_enh1_memory_max_alloc_units.attr,\n\t&dev_attr_enh1_memory_capacity_adjustment_factor.attr,\n\t&dev_attr_enh2_memory_max_alloc_units.attr,\n\t&dev_attr_enh2_memory_capacity_adjustment_factor.attr,\n\t&dev_attr_enh3_memory_max_alloc_units.attr,\n\t&dev_attr_enh3_memory_capacity_adjustment_factor.attr,\n\t&dev_attr_enh4_memory_max_alloc_units.attr,\n\t&dev_attr_enh4_memory_capacity_adjustment_factor.attr,\n\t&dev_attr_wb_max_alloc_units.attr,\n\t&dev_attr_wb_max_wb_luns.attr,\n\t&dev_attr_wb_buff_cap_adj.attr,\n\t&dev_attr_wb_sup_red_type.attr,\n\t&dev_attr_wb_sup_wb_type.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ufs_sysfs_geometry_descriptor_group = {\n\t.name = \"geometry_descriptor\",\n\t.attrs = ufs_sysfs_geometry_descriptor,\n};\n\n#define UFS_HEALTH_DESC_PARAM(_name, _uname, _size)\t\t\t\\\n\tUFS_DESC_PARAM(_name, _uname, HEALTH, _size)\n\nUFS_HEALTH_DESC_PARAM(eol_info, _EOL_INFO, 1);\nUFS_HEALTH_DESC_PARAM(life_time_estimation_a, _LIFE_TIME_EST_A, 1);\nUFS_HEALTH_DESC_PARAM(life_time_estimation_b, _LIFE_TIME_EST_B, 1);\n\nstatic struct attribute *ufs_sysfs_health_descriptor[] = {\n\t&dev_attr_eol_info.attr,\n\t&dev_attr_life_time_estimation_a.attr,\n\t&dev_attr_life_time_estimation_b.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ufs_sysfs_health_descriptor_group = {\n\t.name = \"health_descriptor\",\n\t.attrs = ufs_sysfs_health_descriptor,\n};\n\n#define UFS_POWER_DESC_PARAM(_name, _uname, _index)\t\t\t\\\nstatic ssize_t _name##_index##_show(struct device *dev,\t\t\t\\\n\tstruct device_attribute *attr, char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\t\t\t\\\n\treturn ufs_sysfs_read_desc_param(hba, QUERY_DESC_IDN_POWER, 0,\t\\\n\t\tPWR_DESC##_uname##_0 + _index * 2, buf, 2);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(_name##_index)\n\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 0);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 1);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 2);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 3);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 4);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 5);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 6);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 7);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 8);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 9);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 10);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 11);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 12);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 13);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 14);\nUFS_POWER_DESC_PARAM(active_icc_levels_vcc, _ACTIVE_LVLS_VCC, 15);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 0);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 1);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 2);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 3);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 4);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 5);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 6);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 7);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 8);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 9);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 10);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 11);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 12);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 13);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 14);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq, _ACTIVE_LVLS_VCCQ, 15);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 0);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 1);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 2);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 3);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 4);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 5);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 6);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 7);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 8);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 9);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 10);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 11);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 12);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 13);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 14);\nUFS_POWER_DESC_PARAM(active_icc_levels_vccq2, _ACTIVE_LVLS_VCCQ2, 15);\n\nstatic struct attribute *ufs_sysfs_power_descriptor[] = {\n\t&dev_attr_active_icc_levels_vcc0.attr,\n\t&dev_attr_active_icc_levels_vcc1.attr,\n\t&dev_attr_active_icc_levels_vcc2.attr,\n\t&dev_attr_active_icc_levels_vcc3.attr,\n\t&dev_attr_active_icc_levels_vcc4.attr,\n\t&dev_attr_active_icc_levels_vcc5.attr,\n\t&dev_attr_active_icc_levels_vcc6.attr,\n\t&dev_attr_active_icc_levels_vcc7.attr,\n\t&dev_attr_active_icc_levels_vcc8.attr,\n\t&dev_attr_active_icc_levels_vcc9.attr,\n\t&dev_attr_active_icc_levels_vcc10.attr,\n\t&dev_attr_active_icc_levels_vcc11.attr,\n\t&dev_attr_active_icc_levels_vcc12.attr,\n\t&dev_attr_active_icc_levels_vcc13.attr,\n\t&dev_attr_active_icc_levels_vcc14.attr,\n\t&dev_attr_active_icc_levels_vcc15.attr,\n\t&dev_attr_active_icc_levels_vccq0.attr,\n\t&dev_attr_active_icc_levels_vccq1.attr,\n\t&dev_attr_active_icc_levels_vccq2.attr,\n\t&dev_attr_active_icc_levels_vccq3.attr,\n\t&dev_attr_active_icc_levels_vccq4.attr,\n\t&dev_attr_active_icc_levels_vccq5.attr,\n\t&dev_attr_active_icc_levels_vccq6.attr,\n\t&dev_attr_active_icc_levels_vccq7.attr,\n\t&dev_attr_active_icc_levels_vccq8.attr,\n\t&dev_attr_active_icc_levels_vccq9.attr,\n\t&dev_attr_active_icc_levels_vccq10.attr,\n\t&dev_attr_active_icc_levels_vccq11.attr,\n\t&dev_attr_active_icc_levels_vccq12.attr,\n\t&dev_attr_active_icc_levels_vccq13.attr,\n\t&dev_attr_active_icc_levels_vccq14.attr,\n\t&dev_attr_active_icc_levels_vccq15.attr,\n\t&dev_attr_active_icc_levels_vccq20.attr,\n\t&dev_attr_active_icc_levels_vccq21.attr,\n\t&dev_attr_active_icc_levels_vccq22.attr,\n\t&dev_attr_active_icc_levels_vccq23.attr,\n\t&dev_attr_active_icc_levels_vccq24.attr,\n\t&dev_attr_active_icc_levels_vccq25.attr,\n\t&dev_attr_active_icc_levels_vccq26.attr,\n\t&dev_attr_active_icc_levels_vccq27.attr,\n\t&dev_attr_active_icc_levels_vccq28.attr,\n\t&dev_attr_active_icc_levels_vccq29.attr,\n\t&dev_attr_active_icc_levels_vccq210.attr,\n\t&dev_attr_active_icc_levels_vccq211.attr,\n\t&dev_attr_active_icc_levels_vccq212.attr,\n\t&dev_attr_active_icc_levels_vccq213.attr,\n\t&dev_attr_active_icc_levels_vccq214.attr,\n\t&dev_attr_active_icc_levels_vccq215.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ufs_sysfs_power_descriptor_group = {\n\t.name = \"power_descriptor\",\n\t.attrs = ufs_sysfs_power_descriptor,\n};\n\n#define UFS_STRING_DESCRIPTOR(_name, _pname)\t\t\t\t\\\nstatic ssize_t _name##_show(struct device *dev,\t\t\t\t\\\n\tstruct device_attribute *attr, char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu8 index;\t\t\t\t\t\t\t\\\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tint desc_len = QUERY_DESC_MAX_SIZE;\t\t\t\t\\\n\tu8 *desc_buf;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdown(&hba->host_sem);\t\t\t\t\t\t\\\n\tif (!ufshcd_is_user_access_allowed(hba)) {\t\t\t\\\n\t\tup(&hba->host_sem);\t\t\t\t\t\\\n\t\treturn -EBUSY;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tdesc_buf = kzalloc(QUERY_DESC_MAX_SIZE, GFP_ATOMIC);\t\t\\\n\tif (!desc_buf) {\t\t\t\t\t\t\\\n\t\tup(&hba->host_sem);\t\t\t\t\t\\\n\t\treturn -ENOMEM;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tufshcd_rpm_get_sync(hba);\t\t\t\t\t\\\n\tret = ufshcd_query_descriptor_retry(hba,\t\t\t\\\n\t\tUPIU_QUERY_OPCODE_READ_DESC, QUERY_DESC_IDN_DEVICE,\t\\\n\t\t0, 0, desc_buf, &desc_len);\t\t\t\t\\\n\tif (ret) {\t\t\t\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tindex = desc_buf[DEVICE_DESC_PARAM##_pname];\t\t\t\\\n\tkfree(desc_buf);\t\t\t\t\t\t\\\n\tdesc_buf = NULL;\t\t\t\t\t\t\\\n\tret = ufshcd_read_string_desc(hba, index, &desc_buf,\t\t\\\n\t\t\t\t      SD_ASCII_STD);\t\t\t\\\n\tif (ret < 0)\t\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\\\n\tret = sysfs_emit(buf, \"%s\\n\", desc_buf);\t\t\t\\\nout:\t\t\t\t\t\t\t\t\t\\\n\tufshcd_rpm_put_sync(hba);\t\t\t\t\t\\\n\tkfree(desc_buf);\t\t\t\t\t\t\\\n\tup(&hba->host_sem);\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(_name)\n\nUFS_STRING_DESCRIPTOR(manufacturer_name, _MANF_NAME);\nUFS_STRING_DESCRIPTOR(product_name, _PRDCT_NAME);\nUFS_STRING_DESCRIPTOR(oem_id, _OEM_ID);\nUFS_STRING_DESCRIPTOR(serial_number, _SN);\nUFS_STRING_DESCRIPTOR(product_revision, _PRDCT_REV);\n\nstatic struct attribute *ufs_sysfs_string_descriptors[] = {\n\t&dev_attr_manufacturer_name.attr,\n\t&dev_attr_product_name.attr,\n\t&dev_attr_oem_id.attr,\n\t&dev_attr_serial_number.attr,\n\t&dev_attr_product_revision.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ufs_sysfs_string_descriptors_group = {\n\t.name = \"string_descriptors\",\n\t.attrs = ufs_sysfs_string_descriptors,\n};\n\nstatic inline bool ufshcd_is_wb_flags(enum flag_idn idn)\n{\n\treturn idn >= QUERY_FLAG_IDN_WB_EN &&\n\t\tidn <= QUERY_FLAG_IDN_WB_BUFF_FLUSH_DURING_HIBERN8;\n}\n\n#define UFS_FLAG(_name, _uname)\t\t\t\t\t\t\\\nstatic ssize_t _name##_show(struct device *dev,\t\t\t\t\\\n\tstruct device_attribute *attr, char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tbool flag;\t\t\t\t\t\t\t\\\n\tu8 index = 0;\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdown(&hba->host_sem);\t\t\t\t\t\t\\\n\tif (!ufshcd_is_user_access_allowed(hba)) {\t\t\t\\\n\t\tup(&hba->host_sem);\t\t\t\t\t\\\n\t\treturn -EBUSY;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (ufshcd_is_wb_flags(QUERY_FLAG_IDN##_uname))\t\t\t\\\n\t\tindex = ufshcd_wb_get_query_index(hba);\t\t\t\\\n\tufshcd_rpm_get_sync(hba);\t\t\t\t\t\\\n\tret = ufshcd_query_flag(hba, UPIU_QUERY_OPCODE_READ_FLAG,\t\\\n\t\tQUERY_FLAG_IDN##_uname, index, &flag);\t\t\t\\\n\tufshcd_rpm_put_sync(hba);\t\t\t\t\t\\\n\tif (ret) {\t\t\t\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret = sysfs_emit(buf, \"%s\\n\", flag ? \"true\" : \"false\");\t\t\\\nout:\t\t\t\t\t\t\t\t\t\\\n\tup(&hba->host_sem);\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(_name)\n\nUFS_FLAG(device_init, _FDEVICEINIT);\nUFS_FLAG(permanent_wpe, _PERMANENT_WPE);\nUFS_FLAG(power_on_wpe, _PWR_ON_WPE);\nUFS_FLAG(bkops_enable, _BKOPS_EN);\nUFS_FLAG(life_span_mode_enable, _LIFE_SPAN_MODE_ENABLE);\nUFS_FLAG(phy_resource_removal, _FPHYRESOURCEREMOVAL);\nUFS_FLAG(busy_rtc, _BUSY_RTC);\nUFS_FLAG(disable_fw_update, _PERMANENTLY_DISABLE_FW_UPDATE);\nUFS_FLAG(wb_enable, _WB_EN);\nUFS_FLAG(wb_flush_en, _WB_BUFF_FLUSH_EN);\nUFS_FLAG(wb_flush_during_h8, _WB_BUFF_FLUSH_DURING_HIBERN8);\n\nstatic struct attribute *ufs_sysfs_device_flags[] = {\n\t&dev_attr_device_init.attr,\n\t&dev_attr_permanent_wpe.attr,\n\t&dev_attr_power_on_wpe.attr,\n\t&dev_attr_bkops_enable.attr,\n\t&dev_attr_life_span_mode_enable.attr,\n\t&dev_attr_phy_resource_removal.attr,\n\t&dev_attr_busy_rtc.attr,\n\t&dev_attr_disable_fw_update.attr,\n\t&dev_attr_wb_enable.attr,\n\t&dev_attr_wb_flush_en.attr,\n\t&dev_attr_wb_flush_during_h8.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ufs_sysfs_flags_group = {\n\t.name = \"flags\",\n\t.attrs = ufs_sysfs_device_flags,\n};\n\nstatic inline bool ufshcd_is_wb_attrs(enum attr_idn idn)\n{\n\treturn idn >= QUERY_ATTR_IDN_WB_FLUSH_STATUS &&\n\t\tidn <= QUERY_ATTR_IDN_CURR_WB_BUFF_SIZE;\n}\n\n#define UFS_ATTRIBUTE(_name, _uname)\t\t\t\t\t\\\nstatic ssize_t _name##_show(struct device *dev,\t\t\t\t\\\n\tstruct device_attribute *attr, char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\t\t\t\\\n\tu32 value;\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tu8 index = 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdown(&hba->host_sem);\t\t\t\t\t\t\\\n\tif (!ufshcd_is_user_access_allowed(hba)) {\t\t\t\\\n\t\tup(&hba->host_sem);\t\t\t\t\t\\\n\t\treturn -EBUSY;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (ufshcd_is_wb_attrs(QUERY_ATTR_IDN##_uname))\t\t\t\\\n\t\tindex = ufshcd_wb_get_query_index(hba);\t\t\t\\\n\tufshcd_rpm_get_sync(hba);\t\t\t\t\t\\\n\tret = ufshcd_query_attr(hba, UPIU_QUERY_OPCODE_READ_ATTR,\t\\\n\t\tQUERY_ATTR_IDN##_uname, index, 0, &value);\t\t\\\n\tufshcd_rpm_put_sync(hba);\t\t\t\t\t\\\n\tif (ret) {\t\t\t\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret = sysfs_emit(buf, \"0x%08X\\n\", value);\t\t\t\\\nout:\t\t\t\t\t\t\t\t\t\\\n\tup(&hba->host_sem);\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(_name)\n\nUFS_ATTRIBUTE(boot_lun_enabled, _BOOT_LU_EN);\nUFS_ATTRIBUTE(current_power_mode, _POWER_MODE);\nUFS_ATTRIBUTE(active_icc_level, _ACTIVE_ICC_LVL);\nUFS_ATTRIBUTE(ooo_data_enabled, _OOO_DATA_EN);\nUFS_ATTRIBUTE(bkops_status, _BKOPS_STATUS);\nUFS_ATTRIBUTE(purge_status, _PURGE_STATUS);\nUFS_ATTRIBUTE(max_data_in_size, _MAX_DATA_IN);\nUFS_ATTRIBUTE(max_data_out_size, _MAX_DATA_OUT);\nUFS_ATTRIBUTE(reference_clock_frequency, _REF_CLK_FREQ);\nUFS_ATTRIBUTE(configuration_descriptor_lock, _CONF_DESC_LOCK);\nUFS_ATTRIBUTE(max_number_of_rtt, _MAX_NUM_OF_RTT);\nUFS_ATTRIBUTE(exception_event_control, _EE_CONTROL);\nUFS_ATTRIBUTE(exception_event_status, _EE_STATUS);\nUFS_ATTRIBUTE(ffu_status, _FFU_STATUS);\nUFS_ATTRIBUTE(psa_state, _PSA_STATE);\nUFS_ATTRIBUTE(psa_data_size, _PSA_DATA_SIZE);\nUFS_ATTRIBUTE(wb_flush_status, _WB_FLUSH_STATUS);\nUFS_ATTRIBUTE(wb_avail_buf, _AVAIL_WB_BUFF_SIZE);\nUFS_ATTRIBUTE(wb_life_time_est, _WB_BUFF_LIFE_TIME_EST);\nUFS_ATTRIBUTE(wb_cur_buf, _CURR_WB_BUFF_SIZE);\n\n\nstatic struct attribute *ufs_sysfs_attributes[] = {\n\t&dev_attr_boot_lun_enabled.attr,\n\t&dev_attr_current_power_mode.attr,\n\t&dev_attr_active_icc_level.attr,\n\t&dev_attr_ooo_data_enabled.attr,\n\t&dev_attr_bkops_status.attr,\n\t&dev_attr_purge_status.attr,\n\t&dev_attr_max_data_in_size.attr,\n\t&dev_attr_max_data_out_size.attr,\n\t&dev_attr_reference_clock_frequency.attr,\n\t&dev_attr_configuration_descriptor_lock.attr,\n\t&dev_attr_max_number_of_rtt.attr,\n\t&dev_attr_exception_event_control.attr,\n\t&dev_attr_exception_event_status.attr,\n\t&dev_attr_ffu_status.attr,\n\t&dev_attr_psa_state.attr,\n\t&dev_attr_psa_data_size.attr,\n\t&dev_attr_wb_flush_status.attr,\n\t&dev_attr_wb_avail_buf.attr,\n\t&dev_attr_wb_life_time_est.attr,\n\t&dev_attr_wb_cur_buf.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ufs_sysfs_attributes_group = {\n\t.name = \"attributes\",\n\t.attrs = ufs_sysfs_attributes,\n};\n\nstatic const struct attribute_group *ufs_sysfs_groups[] = {\n\t&ufs_sysfs_default_group,\n\t&ufs_sysfs_capabilities_group,\n\t&ufs_sysfs_monitor_group,\n\t&ufs_sysfs_device_descriptor_group,\n\t&ufs_sysfs_interconnect_descriptor_group,\n\t&ufs_sysfs_geometry_descriptor_group,\n\t&ufs_sysfs_health_descriptor_group,\n\t&ufs_sysfs_power_descriptor_group,\n\t&ufs_sysfs_string_descriptors_group,\n\t&ufs_sysfs_flags_group,\n\t&ufs_sysfs_attributes_group,\n\tNULL,\n};\n\n#define UFS_LUN_DESC_PARAM(_pname, _puname, _duname, _size)\t\t\\\nstatic ssize_t _pname##_show(struct device *dev,\t\t\t\\\n\tstruct device_attribute *attr, char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct scsi_device *sdev = to_scsi_device(dev);\t\t\t\\\n\tstruct ufs_hba *hba = shost_priv(sdev->host);\t\t\t\\\n\tu8 lun = ufshcd_scsi_to_upiu_lun(sdev->lun);\t\t\t\\\n\tif (!ufs_is_valid_unit_desc_lun(&hba->dev_info, lun))\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\treturn ufs_sysfs_read_desc_param(hba, QUERY_DESC_IDN_##_duname,\t\\\n\t\tlun, _duname##_DESC_PARAM##_puname, buf, _size);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(_pname)\n\n#define UFS_UNIT_DESC_PARAM(_name, _uname, _size)\t\t\t\\\n\tUFS_LUN_DESC_PARAM(_name, _uname, UNIT, _size)\n\nUFS_UNIT_DESC_PARAM(lu_enable, _LU_ENABLE, 1);\nUFS_UNIT_DESC_PARAM(boot_lun_id, _BOOT_LUN_ID, 1);\nUFS_UNIT_DESC_PARAM(lun_write_protect, _LU_WR_PROTECT, 1);\nUFS_UNIT_DESC_PARAM(lun_queue_depth, _LU_Q_DEPTH, 1);\nUFS_UNIT_DESC_PARAM(psa_sensitive, _PSA_SENSITIVE, 1);\nUFS_UNIT_DESC_PARAM(lun_memory_type, _MEM_TYPE, 1);\nUFS_UNIT_DESC_PARAM(data_reliability, _DATA_RELIABILITY, 1);\nUFS_UNIT_DESC_PARAM(logical_block_size, _LOGICAL_BLK_SIZE, 1);\nUFS_UNIT_DESC_PARAM(logical_block_count, _LOGICAL_BLK_COUNT, 8);\nUFS_UNIT_DESC_PARAM(erase_block_size, _ERASE_BLK_SIZE, 4);\nUFS_UNIT_DESC_PARAM(provisioning_type, _PROVISIONING_TYPE, 1);\nUFS_UNIT_DESC_PARAM(physical_memory_resourse_count, _PHY_MEM_RSRC_CNT, 8);\nUFS_UNIT_DESC_PARAM(context_capabilities, _CTX_CAPABILITIES, 2);\nUFS_UNIT_DESC_PARAM(large_unit_granularity, _LARGE_UNIT_SIZE_M1, 1);\nUFS_UNIT_DESC_PARAM(wb_buf_alloc_units, _WB_BUF_ALLOC_UNITS, 4);\n\nstatic struct attribute *ufs_sysfs_unit_descriptor[] = {\n\t&dev_attr_lu_enable.attr,\n\t&dev_attr_boot_lun_id.attr,\n\t&dev_attr_lun_write_protect.attr,\n\t&dev_attr_lun_queue_depth.attr,\n\t&dev_attr_psa_sensitive.attr,\n\t&dev_attr_lun_memory_type.attr,\n\t&dev_attr_data_reliability.attr,\n\t&dev_attr_logical_block_size.attr,\n\t&dev_attr_logical_block_count.attr,\n\t&dev_attr_erase_block_size.attr,\n\t&dev_attr_provisioning_type.attr,\n\t&dev_attr_physical_memory_resourse_count.attr,\n\t&dev_attr_context_capabilities.attr,\n\t&dev_attr_large_unit_granularity.attr,\n\t&dev_attr_wb_buf_alloc_units.attr,\n\tNULL,\n};\n\nstatic umode_t ufs_unit_descriptor_is_visible(struct kobject *kobj, struct attribute *attr, int n)\n{\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tu8 lun = ufshcd_scsi_to_upiu_lun(sdev->lun);\n\tumode_t mode = attr->mode;\n\n\tif (lun == UFS_UPIU_BOOT_WLUN || lun == UFS_UPIU_UFS_DEVICE_WLUN)\n\t\t \n\t\tmode = 0;\n\tif (lun == UFS_UPIU_RPMB_WLUN && attr == &dev_attr_wb_buf_alloc_units.attr)\n\t\tmode = 0;\n\n\treturn mode;\n}\n\n\nconst struct attribute_group ufs_sysfs_unit_descriptor_group = {\n\t.name = \"unit_descriptor\",\n\t.attrs = ufs_sysfs_unit_descriptor,\n\t.is_visible = ufs_unit_descriptor_is_visible,\n};\n\nstatic ssize_t dyn_cap_needed_attribute_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tu32 value;\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct ufs_hba *hba = shost_priv(sdev->host);\n\tu8 lun = ufshcd_scsi_to_upiu_lun(sdev->lun);\n\tint ret;\n\n\tdown(&hba->host_sem);\n\tif (!ufshcd_is_user_access_allowed(hba)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tufshcd_rpm_get_sync(hba);\n\tret = ufshcd_query_attr(hba, UPIU_QUERY_OPCODE_READ_ATTR,\n\t\tQUERY_ATTR_IDN_DYN_CAP_NEEDED, lun, 0, &value);\n\tufshcd_rpm_put_sync(hba);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sysfs_emit(buf, \"0x%08X\\n\", value);\n\nout:\n\tup(&hba->host_sem);\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(dyn_cap_needed_attribute);\n\nstatic struct attribute *ufs_sysfs_lun_attributes[] = {\n\t&dev_attr_dyn_cap_needed_attribute.attr,\n\tNULL,\n};\n\nconst struct attribute_group ufs_sysfs_lun_attributes_group = {\n\t.attrs = ufs_sysfs_lun_attributes,\n};\n\nvoid ufs_sysfs_add_nodes(struct device *dev)\n{\n\tint ret;\n\n\tret = sysfs_create_groups(&dev->kobj, ufs_sysfs_groups);\n\tif (ret)\n\t\tdev_err(dev,\n\t\t\t\"%s: sysfs groups creation failed (err = %d)\\n\",\n\t\t\t__func__, ret);\n}\n\nvoid ufs_sysfs_remove_nodes(struct device *dev)\n{\n\tsysfs_remove_groups(&dev->kobj, ufs_sysfs_groups);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}