{
  "module_name": "ufs-hwmon.c",
  "hash_id": "bbcf0241d581cd36e1d659b2183915d16be5cfdc15cad884792fa1ab69ed8573",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ufs/core/ufs-hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/hwmon.h>\n#include <linux/units.h>\n\n#include <ufs/ufshcd.h>\n#include \"ufshcd-priv.h\"\n\nstruct ufs_hwmon_data {\n\tstruct ufs_hba *hba;\n\tu8 mask;\n};\n\nstatic int ufs_read_temp_enable(struct ufs_hba *hba, u8 mask, long *val)\n{\n\tu32 ee_mask;\n\tint err;\n\n\terr = ufshcd_query_attr(hba, UPIU_QUERY_OPCODE_READ_ATTR, QUERY_ATTR_IDN_EE_CONTROL, 0, 0,\n\t\t\t\t&ee_mask);\n\tif (err)\n\t\treturn err;\n\n\t*val = (mask & ee_mask & MASK_EE_TOO_HIGH_TEMP) || (mask & ee_mask & MASK_EE_TOO_LOW_TEMP);\n\n\treturn 0;\n}\n\nstatic int ufs_get_temp(struct ufs_hba *hba, enum attr_idn idn, long *val)\n{\n\tu32 value;\n\tint err;\n\n\terr = ufshcd_query_attr(hba, UPIU_QUERY_OPCODE_READ_ATTR, idn, 0, 0, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (value == 0)\n\t\treturn -ENODATA;\n\n\t*val = ((long)value - 80) * MILLIDEGREE_PER_DEGREE;\n\n\treturn 0;\n}\n\nstatic int ufs_hwmon_read(struct device *dev, enum hwmon_sensor_types type, u32 attr, int channel,\n\t\t\t  long *val)\n{\n\tstruct ufs_hwmon_data *data = dev_get_drvdata(dev);\n\tstruct ufs_hba *hba = data->hba;\n\tint err;\n\n\tdown(&hba->host_sem);\n\n\tif (!ufshcd_is_user_access_allowed(hba)) {\n\t\tup(&hba->host_sem);\n\t\treturn -EBUSY;\n\t}\n\n\tufshcd_rpm_get_sync(hba);\n\n\tswitch (attr) {\n\tcase hwmon_temp_enable:\n\t\terr = ufs_read_temp_enable(hba, data->mask, val);\n\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\terr = ufs_get_temp(hba, QUERY_ATTR_IDN_HIGH_TEMP_BOUND, val);\n\n\t\tbreak;\n\tcase hwmon_temp_lcrit:\n\t\terr = ufs_get_temp(hba, QUERY_ATTR_IDN_LOW_TEMP_BOUND, val);\n\n\t\tbreak;\n\tcase hwmon_temp_input:\n\t\terr = ufs_get_temp(hba, QUERY_ATTR_IDN_CASE_ROUGH_TEMP, val);\n\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\n\t\tbreak;\n\t}\n\n\tufshcd_rpm_put_sync(hba);\n\n\tup(&hba->host_sem);\n\n\treturn err;\n}\n\nstatic int ufs_hwmon_write(struct device *dev, enum hwmon_sensor_types type, u32 attr, int channel,\n\t\t\t   long val)\n{\n\tstruct ufs_hwmon_data *data = dev_get_drvdata(dev);\n\tstruct ufs_hba *hba = data->hba;\n\tint err;\n\n\tif (attr != hwmon_temp_enable)\n\t\treturn -EINVAL;\n\n\tif (val != 0 && val != 1)\n\t\treturn -EINVAL;\n\n\tdown(&hba->host_sem);\n\n\tif (!ufshcd_is_user_access_allowed(hba)) {\n\t\tup(&hba->host_sem);\n\t\treturn -EBUSY;\n\t}\n\n\tufshcd_rpm_get_sync(hba);\n\n\tif (val == 1)\n\t\terr = ufshcd_update_ee_usr_mask(hba, MASK_EE_URGENT_TEMP, 0);\n\telse\n\t\terr = ufshcd_update_ee_usr_mask(hba, 0, MASK_EE_URGENT_TEMP);\n\n\tufshcd_rpm_put_sync(hba);\n\n\tup(&hba->host_sem);\n\n\treturn err;\n}\n\nstatic umode_t ufs_hwmon_is_visible(const void *data,\n\t\t\t\t    enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t    int channel)\n{\n\tif (type != hwmon_temp)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_temp_enable:\n\t\treturn 0644;\n\tcase hwmon_temp_crit:\n\tcase hwmon_temp_lcrit:\n\tcase hwmon_temp_input:\n\t\treturn 0444;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info *const ufs_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_ENABLE | HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_LCRIT),\n\tNULL\n};\n\nstatic const struct hwmon_ops ufs_hwmon_ops = {\n\t.is_visible\t= ufs_hwmon_is_visible,\n\t.read\t\t= ufs_hwmon_read,\n\t.write\t\t= ufs_hwmon_write,\n};\n\nstatic const struct hwmon_chip_info ufs_hwmon_hba_info = {\n\t.ops\t= &ufs_hwmon_ops,\n\t.info\t= ufs_hwmon_info,\n};\n\nvoid ufs_hwmon_probe(struct ufs_hba *hba, u8 mask)\n{\n\tstruct device *dev = hba->dev;\n\tstruct ufs_hwmon_data *data;\n\tstruct device *hwmon;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\tdata->hba = hba;\n\tdata->mask = mask;\n\n\thwmon = hwmon_device_register_with_info(dev, \"ufs\", data, &ufs_hwmon_hba_info, NULL);\n\tif (IS_ERR(hwmon)) {\n\t\tdev_warn(dev, \"Failed to instantiate hwmon device\\n\");\n\t\tkfree(data);\n\t\treturn;\n\t}\n\n\thba->hwmon_device = hwmon;\n}\n\nvoid ufs_hwmon_remove(struct ufs_hba *hba)\n{\n\tstruct ufs_hwmon_data *data;\n\n\tif (!hba->hwmon_device)\n\t\treturn;\n\n\tdata = dev_get_drvdata(hba->hwmon_device);\n\thwmon_device_unregister(hba->hwmon_device);\n\thba->hwmon_device = NULL;\n\tkfree(data);\n}\n\nvoid ufs_hwmon_notify_event(struct ufs_hba *hba, u8 ee_mask)\n{\n\tif (!hba->hwmon_device)\n\t\treturn;\n\n\tif (ee_mask & MASK_EE_TOO_HIGH_TEMP)\n\t\thwmon_notify_event(hba->hwmon_device, hwmon_temp, hwmon_temp_max_alarm, 0);\n\n\tif (ee_mask & MASK_EE_TOO_LOW_TEMP)\n\t\thwmon_notify_event(hba->hwmon_device, hwmon_temp, hwmon_temp_min_alarm, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}