{
  "module_name": "ufshcd-crypto.c",
  "hash_id": "4f98881bd2d9d08899d9610ae11a49fdecd6a47f616b17ceda27e27be68b47e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ufs/core/ufshcd-crypto.c",
  "human_readable_source": "\n \n\n#include <ufs/ufshcd.h>\n#include \"ufshcd-crypto.h\"\n\n \nstatic const struct ufs_crypto_alg_entry {\n\tenum ufs_crypto_alg ufs_alg;\n\tenum ufs_crypto_key_size ufs_key_size;\n} ufs_crypto_algs[BLK_ENCRYPTION_MODE_MAX] = {\n\t[BLK_ENCRYPTION_MODE_AES_256_XTS] = {\n\t\t.ufs_alg = UFS_CRYPTO_ALG_AES_XTS,\n\t\t.ufs_key_size = UFS_CRYPTO_KEY_SIZE_256,\n\t},\n};\n\nstatic int ufshcd_program_key(struct ufs_hba *hba,\n\t\t\t      const union ufs_crypto_cfg_entry *cfg, int slot)\n{\n\tint i;\n\tu32 slot_offset = hba->crypto_cfg_register + slot * sizeof(*cfg);\n\tint err = 0;\n\n\tufshcd_hold(hba);\n\n\tif (hba->vops && hba->vops->program_key) {\n\t\terr = hba->vops->program_key(hba, cfg, slot);\n\t\tgoto out;\n\t}\n\n\t \n\tufshcd_writel(hba, 0, slot_offset + 16 * sizeof(cfg->reg_val[0]));\n\tfor (i = 0; i < 16; i++) {\n\t\tufshcd_writel(hba, le32_to_cpu(cfg->reg_val[i]),\n\t\t\t      slot_offset + i * sizeof(cfg->reg_val[0]));\n\t}\n\t \n\tufshcd_writel(hba, le32_to_cpu(cfg->reg_val[17]),\n\t\t      slot_offset + 17 * sizeof(cfg->reg_val[0]));\n\t \n\tufshcd_writel(hba, le32_to_cpu(cfg->reg_val[16]),\n\t\t      slot_offset + 16 * sizeof(cfg->reg_val[0]));\nout:\n\tufshcd_release(hba);\n\treturn err;\n}\n\nstatic int ufshcd_crypto_keyslot_program(struct blk_crypto_profile *profile,\n\t\t\t\t\t const struct blk_crypto_key *key,\n\t\t\t\t\t unsigned int slot)\n{\n\tstruct ufs_hba *hba =\n\t\tcontainer_of(profile, struct ufs_hba, crypto_profile);\n\tconst union ufs_crypto_cap_entry *ccap_array = hba->crypto_cap_array;\n\tconst struct ufs_crypto_alg_entry *alg =\n\t\t\t&ufs_crypto_algs[key->crypto_cfg.crypto_mode];\n\tu8 data_unit_mask = key->crypto_cfg.data_unit_size / 512;\n\tint i;\n\tint cap_idx = -1;\n\tunion ufs_crypto_cfg_entry cfg = {};\n\tint err;\n\n\tBUILD_BUG_ON(UFS_CRYPTO_KEY_SIZE_INVALID != 0);\n\tfor (i = 0; i < hba->crypto_capabilities.num_crypto_cap; i++) {\n\t\tif (ccap_array[i].algorithm_id == alg->ufs_alg &&\n\t\t    ccap_array[i].key_size == alg->ufs_key_size &&\n\t\t    (ccap_array[i].sdus_mask & data_unit_mask)) {\n\t\t\tcap_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ON(cap_idx < 0))\n\t\treturn -EOPNOTSUPP;\n\n\tcfg.data_unit_size = data_unit_mask;\n\tcfg.crypto_cap_idx = cap_idx;\n\tcfg.config_enable = UFS_CRYPTO_CONFIGURATION_ENABLE;\n\n\tif (ccap_array[cap_idx].algorithm_id == UFS_CRYPTO_ALG_AES_XTS) {\n\t\t \n\t\tmemcpy(cfg.crypto_key, key->raw, key->size/2);\n\t\tmemcpy(cfg.crypto_key + UFS_CRYPTO_KEY_MAX_SIZE/2,\n\t\t       key->raw + key->size/2, key->size/2);\n\t} else {\n\t\tmemcpy(cfg.crypto_key, key->raw, key->size);\n\t}\n\n\terr = ufshcd_program_key(hba, &cfg, slot);\n\n\tmemzero_explicit(&cfg, sizeof(cfg));\n\treturn err;\n}\n\nstatic int ufshcd_clear_keyslot(struct ufs_hba *hba, int slot)\n{\n\t \n\tunion ufs_crypto_cfg_entry cfg = {};\n\n\treturn ufshcd_program_key(hba, &cfg, slot);\n}\n\nstatic int ufshcd_crypto_keyslot_evict(struct blk_crypto_profile *profile,\n\t\t\t\t       const struct blk_crypto_key *key,\n\t\t\t\t       unsigned int slot)\n{\n\tstruct ufs_hba *hba =\n\t\tcontainer_of(profile, struct ufs_hba, crypto_profile);\n\n\treturn ufshcd_clear_keyslot(hba, slot);\n}\n\nbool ufshcd_crypto_enable(struct ufs_hba *hba)\n{\n\tif (!(hba->caps & UFSHCD_CAP_CRYPTO))\n\t\treturn false;\n\n\t \n\tblk_crypto_reprogram_all_keys(&hba->crypto_profile);\n\treturn true;\n}\n\nstatic const struct blk_crypto_ll_ops ufshcd_crypto_ops = {\n\t.keyslot_program\t= ufshcd_crypto_keyslot_program,\n\t.keyslot_evict\t\t= ufshcd_crypto_keyslot_evict,\n};\n\nstatic enum blk_crypto_mode_num\nufshcd_find_blk_crypto_mode(union ufs_crypto_cap_entry cap)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ufs_crypto_algs); i++) {\n\t\tBUILD_BUG_ON(UFS_CRYPTO_KEY_SIZE_INVALID != 0);\n\t\tif (ufs_crypto_algs[i].ufs_alg == cap.algorithm_id &&\n\t\t    ufs_crypto_algs[i].ufs_key_size == cap.key_size) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn BLK_ENCRYPTION_MODE_INVALID;\n}\n\n \nint ufshcd_hba_init_crypto_capabilities(struct ufs_hba *hba)\n{\n\tint cap_idx;\n\tint err = 0;\n\tenum blk_crypto_mode_num blk_mode_num;\n\n\t \n\tif (!(hba->capabilities & MASK_CRYPTO_SUPPORT) ||\n\t    !(hba->caps & UFSHCD_CAP_CRYPTO))\n\t\tgoto out;\n\n\thba->crypto_capabilities.reg_val =\n\t\t\tcpu_to_le32(ufshcd_readl(hba, REG_UFS_CCAP));\n\thba->crypto_cfg_register =\n\t\t(u32)hba->crypto_capabilities.config_array_ptr * 0x100;\n\thba->crypto_cap_array =\n\t\tdevm_kcalloc(hba->dev, hba->crypto_capabilities.num_crypto_cap,\n\t\t\t     sizeof(hba->crypto_cap_array[0]), GFP_KERNEL);\n\tif (!hba->crypto_cap_array) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\terr = devm_blk_crypto_profile_init(\n\t\t\thba->dev, &hba->crypto_profile,\n\t\t\thba->crypto_capabilities.config_count + 1);\n\tif (err)\n\t\tgoto out;\n\n\thba->crypto_profile.ll_ops = ufshcd_crypto_ops;\n\t \n\thba->crypto_profile.max_dun_bytes_supported = 8;\n\thba->crypto_profile.dev = hba->dev;\n\n\t \n\tfor (cap_idx = 0; cap_idx < hba->crypto_capabilities.num_crypto_cap;\n\t     cap_idx++) {\n\t\thba->crypto_cap_array[cap_idx].reg_val =\n\t\t\tcpu_to_le32(ufshcd_readl(hba,\n\t\t\t\t\t\t REG_UFS_CRYPTOCAP +\n\t\t\t\t\t\t cap_idx * sizeof(__le32)));\n\t\tblk_mode_num = ufshcd_find_blk_crypto_mode(\n\t\t\t\t\t\thba->crypto_cap_array[cap_idx]);\n\t\tif (blk_mode_num != BLK_ENCRYPTION_MODE_INVALID)\n\t\t\thba->crypto_profile.modes_supported[blk_mode_num] |=\n\t\t\t\thba->crypto_cap_array[cap_idx].sdus_mask * 512;\n\t}\n\n\treturn 0;\n\nout:\n\t \n\thba->caps &= ~UFSHCD_CAP_CRYPTO;\n\treturn err;\n}\n\n \nvoid ufshcd_init_crypto(struct ufs_hba *hba)\n{\n\tint slot;\n\n\tif (!(hba->caps & UFSHCD_CAP_CRYPTO))\n\t\treturn;\n\n\t \n\tfor (slot = 0; slot < hba->crypto_capabilities.config_count + 1; slot++)\n\t\tufshcd_clear_keyslot(hba, slot);\n}\n\nvoid ufshcd_crypto_register(struct ufs_hba *hba, struct request_queue *q)\n{\n\tif (hba->caps & UFSHCD_CAP_CRYPTO)\n\t\tblk_crypto_register(&hba->crypto_profile, q);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}