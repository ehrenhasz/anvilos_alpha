{
  "module_name": "ufs-debugfs.c",
  "hash_id": "900499295b0098ee21a0eb4c93b7ff9ac8346b41f75801d19c08fae9099d8407",
  "original_prompt": "Ingested from linux-6.6.14/drivers/ufs/core/ufs-debugfs.c",
  "human_readable_source": "\n\n\n#include <linux/debugfs.h>\n\n#include \"ufs-debugfs.h\"\n#include <ufs/ufshcd.h>\n#include \"ufshcd-priv.h\"\n\nstatic struct dentry *ufs_debugfs_root;\n\nstruct ufs_debugfs_attr {\n\tconst char\t\t\t*name;\n\tmode_t\t\t\t\tmode;\n\tconst struct file_operations\t*fops;\n};\n\n \nstatic inline struct ufs_hba *hba_from_file(const struct file *file)\n{\n\treturn d_inode(file->f_path.dentry->d_parent)->i_private;\n}\n\nvoid __init ufs_debugfs_init(void)\n{\n\tufs_debugfs_root = debugfs_create_dir(\"ufshcd\", NULL);\n}\n\nvoid ufs_debugfs_exit(void)\n{\n\tdebugfs_remove_recursive(ufs_debugfs_root);\n}\n\nstatic int ufs_debugfs_stats_show(struct seq_file *s, void *data)\n{\n\tstruct ufs_hba *hba = hba_from_file(s->file);\n\tstruct ufs_event_hist *e = hba->ufs_stats.event;\n\n#define PRT(fmt, typ) \\\n\tseq_printf(s, fmt, e[UFS_EVT_ ## typ].cnt)\n\n\tPRT(\"PHY Adapter Layer errors (except LINERESET): %llu\\n\", PA_ERR);\n\tPRT(\"Data Link Layer errors: %llu\\n\", DL_ERR);\n\tPRT(\"Network Layer errors: %llu\\n\", NL_ERR);\n\tPRT(\"Transport Layer errors: %llu\\n\", TL_ERR);\n\tPRT(\"Generic DME errors: %llu\\n\", DME_ERR);\n\tPRT(\"Auto-hibernate errors: %llu\\n\", AUTO_HIBERN8_ERR);\n\tPRT(\"IS Fatal errors (CEFES, SBFES, HCFES, DFES): %llu\\n\", FATAL_ERR);\n\tPRT(\"DME Link Startup errors: %llu\\n\", LINK_STARTUP_FAIL);\n\tPRT(\"PM Resume errors: %llu\\n\", RESUME_ERR);\n\tPRT(\"PM Suspend errors : %llu\\n\", SUSPEND_ERR);\n\tPRT(\"Logical Unit Resets: %llu\\n\", DEV_RESET);\n\tPRT(\"Host Resets: %llu\\n\", HOST_RESET);\n\tPRT(\"SCSI command aborts: %llu\\n\", ABORT);\n#undef PRT\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ufs_debugfs_stats);\n\nstatic int ee_usr_mask_get(void *data, u64 *val)\n{\n\tstruct ufs_hba *hba = data;\n\n\t*val = hba->ee_usr_mask;\n\treturn 0;\n}\n\nstatic int ufs_debugfs_get_user_access(struct ufs_hba *hba)\n__acquires(&hba->host_sem)\n{\n\tdown(&hba->host_sem);\n\tif (!ufshcd_is_user_access_allowed(hba)) {\n\t\tup(&hba->host_sem);\n\t\treturn -EBUSY;\n\t}\n\tufshcd_rpm_get_sync(hba);\n\treturn 0;\n}\n\nstatic void ufs_debugfs_put_user_access(struct ufs_hba *hba)\n__releases(&hba->host_sem)\n{\n\tufshcd_rpm_put_sync(hba);\n\tup(&hba->host_sem);\n}\n\nstatic int ee_usr_mask_set(void *data, u64 val)\n{\n\tstruct ufs_hba *hba = data;\n\tint err;\n\n\tif (val & ~(u64)MASK_EE_STATUS)\n\t\treturn -EINVAL;\n\terr = ufs_debugfs_get_user_access(hba);\n\tif (err)\n\t\treturn err;\n\terr = ufshcd_update_ee_usr_mask(hba, val, MASK_EE_STATUS);\n\tufs_debugfs_put_user_access(hba);\n\treturn err;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(ee_usr_mask_fops, ee_usr_mask_get, ee_usr_mask_set, \"%#llx\\n\");\n\nvoid ufs_debugfs_exception_event(struct ufs_hba *hba, u16 status)\n{\n\tbool chgd = false;\n\tu16 ee_ctrl_mask;\n\tint err = 0;\n\n\tif (!hba->debugfs_ee_rate_limit_ms || !status)\n\t\treturn;\n\n\tmutex_lock(&hba->ee_ctrl_mutex);\n\tee_ctrl_mask = hba->ee_drv_mask | (hba->ee_usr_mask & ~status);\n\tchgd = ee_ctrl_mask != hba->ee_ctrl_mask;\n\tif (chgd) {\n\t\terr = __ufshcd_write_ee_control(hba, ee_ctrl_mask);\n\t\tif (err)\n\t\t\tdev_err(hba->dev, \"%s: failed to write ee control %d\\n\",\n\t\t\t\t__func__, err);\n\t}\n\tmutex_unlock(&hba->ee_ctrl_mutex);\n\n\tif (chgd && !err) {\n\t\tunsigned long delay = msecs_to_jiffies(hba->debugfs_ee_rate_limit_ms);\n\n\t\tqueue_delayed_work(system_freezable_wq, &hba->debugfs_ee_work, delay);\n\t}\n}\n\nstatic void ufs_debugfs_restart_ee(struct work_struct *work)\n{\n\tstruct ufs_hba *hba = container_of(work, struct ufs_hba, debugfs_ee_work.work);\n\n\tif (!hba->ee_usr_mask || pm_runtime_suspended(hba->dev) ||\n\t    ufs_debugfs_get_user_access(hba))\n\t\treturn;\n\tufshcd_write_ee_control(hba);\n\tufs_debugfs_put_user_access(hba);\n}\n\nstatic int ufs_saved_err_show(struct seq_file *s, void *data)\n{\n\tstruct ufs_debugfs_attr *attr = s->private;\n\tstruct ufs_hba *hba = hba_from_file(s->file);\n\tconst int *p;\n\n\tif (strcmp(attr->name, \"saved_err\") == 0) {\n\t\tp = &hba->saved_err;\n\t} else if (strcmp(attr->name, \"saved_uic_err\") == 0) {\n\t\tp = &hba->saved_uic_err;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n\n\tseq_printf(s, \"%d\\n\", *p);\n\treturn 0;\n}\n\nstatic ssize_t ufs_saved_err_write(struct file *file, const char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ufs_debugfs_attr *attr = file->f_inode->i_private;\n\tstruct ufs_hba *hba = hba_from_file(file);\n\tchar val_str[16] = { };\n\tint val, ret;\n\n\tif (count > sizeof(val_str))\n\t\treturn -EINVAL;\n\tif (copy_from_user(val_str, buf, count))\n\t\treturn -EFAULT;\n\tret = kstrtoint(val_str, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tspin_lock_irq(hba->host->host_lock);\n\tif (strcmp(attr->name, \"saved_err\") == 0) {\n\t\thba->saved_err = val;\n\t} else if (strcmp(attr->name, \"saved_uic_err\") == 0) {\n\t\thba->saved_uic_err = val;\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\tif (ret == 0)\n\t\tufshcd_schedule_eh_work(hba);\n\tspin_unlock_irq(hba->host->host_lock);\n\n\treturn ret < 0 ? ret : count;\n}\n\nstatic int ufs_saved_err_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ufs_saved_err_show, inode->i_private);\n}\n\nstatic const struct file_operations ufs_saved_err_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ufs_saved_err_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= ufs_saved_err_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic const struct ufs_debugfs_attr ufs_attrs[] = {\n\t{ \"stats\", 0400, &ufs_debugfs_stats_fops },\n\t{ \"saved_err\", 0600, &ufs_saved_err_fops },\n\t{ \"saved_uic_err\", 0600, &ufs_saved_err_fops },\n\t{ }\n};\n\nvoid ufs_debugfs_hba_init(struct ufs_hba *hba)\n{\n\tconst struct ufs_debugfs_attr *attr;\n\tstruct dentry *root;\n\n\t \n\thba->debugfs_ee_rate_limit_ms = 20;\n\tINIT_DELAYED_WORK(&hba->debugfs_ee_work, ufs_debugfs_restart_ee);\n\n\troot = debugfs_create_dir(dev_name(hba->dev), ufs_debugfs_root);\n\tif (IS_ERR_OR_NULL(root))\n\t\treturn;\n\thba->debugfs_root = root;\n\td_inode(root)->i_private = hba;\n\tfor (attr = ufs_attrs; attr->name; attr++)\n\t\tdebugfs_create_file(attr->name, attr->mode, root, (void *)attr,\n\t\t\t\t    attr->fops);\n\tdebugfs_create_file(\"exception_event_mask\", 0600, hba->debugfs_root,\n\t\t\t    hba, &ee_usr_mask_fops);\n\tdebugfs_create_u32(\"exception_event_rate_limit_ms\", 0600, hba->debugfs_root,\n\t\t\t   &hba->debugfs_ee_rate_limit_ms);\n}\n\nvoid ufs_debugfs_hba_exit(struct ufs_hba *hba)\n{\n\tdebugfs_remove_recursive(hba->debugfs_root);\n\tcancel_delayed_work_sync(&hba->debugfs_ee_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}