{
  "module_name": "governor.c",
  "hash_id": "6b8eac68ba6333abe484c8edf33190c9f436721191edb3eceb5a1dc44a48df4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/governor.c",
  "human_readable_source": " \n\n#include <linux/cpu.h>\n#include <linux/cpuidle.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/pm_qos.h>\n\n#include \"cpuidle.h\"\n\nchar param_governor[CPUIDLE_NAME_LEN];\n\nLIST_HEAD(cpuidle_governors);\nstruct cpuidle_governor *cpuidle_curr_governor;\nstruct cpuidle_governor *cpuidle_prev_governor;\n\n \nstruct cpuidle_governor *cpuidle_find_governor(const char *str)\n{\n\tstruct cpuidle_governor *gov;\n\n\tlist_for_each_entry(gov, &cpuidle_governors, governor_list)\n\t\tif (!strncasecmp(str, gov->name, CPUIDLE_NAME_LEN))\n\t\t\treturn gov;\n\n\treturn NULL;\n}\n\n \nint cpuidle_switch_governor(struct cpuidle_governor *gov)\n{\n\tstruct cpuidle_device *dev;\n\n\tif (!gov)\n\t\treturn -EINVAL;\n\n\tif (gov == cpuidle_curr_governor)\n\t\treturn 0;\n\n\tcpuidle_uninstall_idle_handler();\n\n\tif (cpuidle_curr_governor) {\n\t\tlist_for_each_entry(dev, &cpuidle_detected_devices, device_list)\n\t\t\tcpuidle_disable_device(dev);\n\t}\n\n\tcpuidle_curr_governor = gov;\n\n\tlist_for_each_entry(dev, &cpuidle_detected_devices, device_list)\n\t\tcpuidle_enable_device(dev);\n\n\tcpuidle_install_idle_handler();\n\tpr_info(\"cpuidle: using governor %s\\n\", gov->name);\n\n\treturn 0;\n}\n\n \nint cpuidle_register_governor(struct cpuidle_governor *gov)\n{\n\tint ret = -EEXIST;\n\n\tif (!gov || !gov->select)\n\t\treturn -EINVAL;\n\n\tif (cpuidle_disabled())\n\t\treturn -ENODEV;\n\n\tmutex_lock(&cpuidle_lock);\n\tif (cpuidle_find_governor(gov->name) == NULL) {\n\t\tret = 0;\n\t\tlist_add_tail(&gov->governor_list, &cpuidle_governors);\n\t\tif (!cpuidle_curr_governor ||\n\t\t    !strncasecmp(param_governor, gov->name, CPUIDLE_NAME_LEN) ||\n\t\t    (cpuidle_curr_governor->rating < gov->rating &&\n\t\t     strncasecmp(param_governor, cpuidle_curr_governor->name,\n\t\t\t\t CPUIDLE_NAME_LEN)))\n\t\t\tcpuidle_switch_governor(gov);\n\t}\n\tmutex_unlock(&cpuidle_lock);\n\n\treturn ret;\n}\n\n \ns64 cpuidle_governor_latency_req(unsigned int cpu)\n{\n\tstruct device *device = get_cpu_device(cpu);\n\tint device_req = dev_pm_qos_raw_resume_latency(device);\n\tint global_req = cpu_latency_qos_limit();\n\n\tif (device_req > global_req)\n\t\tdevice_req = global_req;\n\n\treturn (s64)device_req * NSEC_PER_USEC;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}