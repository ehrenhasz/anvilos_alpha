{
  "module_name": "dt_idle_states.c",
  "hash_id": "6712892210d29c88ca8948e7b04aa74ee8a5005b6f029e1b6400fb052802e4cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/dt_idle_states.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"DT idle-states: \" fmt\n\n#include <linux/cpuidle.h>\n#include <linux/cpumask.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#include \"dt_idle_states.h\"\n\nstatic int init_state_node(struct cpuidle_state *idle_state,\n\t\t\t   const struct of_device_id *match_id,\n\t\t\t   struct device_node *state_node)\n{\n\tint err;\n\tconst char *desc;\n\n\t \n\tidle_state->enter = match_id->data;\n\t \n\tidle_state->enter_s2idle = match_id->data;\n\n\terr = of_property_read_u32(state_node, \"wakeup-latency-us\",\n\t\t\t\t   &idle_state->exit_latency);\n\tif (err) {\n\t\tu32 entry_latency, exit_latency;\n\n\t\terr = of_property_read_u32(state_node, \"entry-latency-us\",\n\t\t\t\t\t   &entry_latency);\n\t\tif (err) {\n\t\t\tpr_debug(\" * %pOF missing entry-latency-us property\\n\",\n\t\t\t\t state_node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = of_property_read_u32(state_node, \"exit-latency-us\",\n\t\t\t\t\t   &exit_latency);\n\t\tif (err) {\n\t\t\tpr_debug(\" * %pOF missing exit-latency-us property\\n\",\n\t\t\t\t state_node);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tidle_state->exit_latency = entry_latency + exit_latency;\n\t}\n\n\terr = of_property_read_u32(state_node, \"min-residency-us\",\n\t\t\t\t   &idle_state->target_residency);\n\tif (err) {\n\t\tpr_debug(\" * %pOF missing min-residency-us property\\n\",\n\t\t\t     state_node);\n\t\treturn -EINVAL;\n\t}\n\n\terr = of_property_read_string(state_node, \"idle-state-name\", &desc);\n\tif (err)\n\t\tdesc = state_node->name;\n\n\tidle_state->flags = CPUIDLE_FLAG_RCU_IDLE;\n\tif (of_property_read_bool(state_node, \"local-timer-stop\"))\n\t\tidle_state->flags |= CPUIDLE_FLAG_TIMER_STOP;\n\t \n\tstrncpy(idle_state->name, state_node->name, CPUIDLE_NAME_LEN - 1);\n\tstrncpy(idle_state->desc, desc, CPUIDLE_DESC_LEN - 1);\n\treturn 0;\n}\n\n \nstatic bool idle_state_valid(struct device_node *state_node, unsigned int idx,\n\t\t\t     const cpumask_t *cpumask)\n{\n\tint cpu;\n\tstruct device_node *cpu_node, *curr_state_node;\n\tbool valid = true;\n\n\t \n\tfor (cpu = cpumask_next(cpumask_first(cpumask), cpumask);\n\t     cpu < nr_cpu_ids; cpu = cpumask_next(cpu, cpumask)) {\n\t\tcpu_node = of_cpu_device_node_get(cpu);\n\t\tcurr_state_node = of_get_cpu_state_node(cpu_node, idx);\n\t\tif (state_node != curr_state_node)\n\t\t\tvalid = false;\n\n\t\tof_node_put(curr_state_node);\n\t\tof_node_put(cpu_node);\n\t\tif (!valid)\n\t\t\tbreak;\n\t}\n\n\treturn valid;\n}\n\n \nint dt_init_idle_driver(struct cpuidle_driver *drv,\n\t\t\tconst struct of_device_id *matches,\n\t\t\tunsigned int start_idx)\n{\n\tstruct cpuidle_state *idle_state;\n\tstruct device_node *state_node, *cpu_node;\n\tconst struct of_device_id *match_id;\n\tint i, err = 0;\n\tconst cpumask_t *cpumask;\n\tunsigned int state_idx = start_idx;\n\n\tif (state_idx >= CPUIDLE_STATE_MAX)\n\t\treturn -EINVAL;\n\t \n\tcpumask = drv->cpumask ? : cpu_possible_mask;\n\tcpu_node = of_cpu_device_node_get(cpumask_first(cpumask));\n\n\tfor (i = 0; ; i++) {\n\t\tstate_node = of_get_cpu_state_node(cpu_node, i);\n\t\tif (!state_node)\n\t\t\tbreak;\n\n\t\tmatch_id = of_match_node(matches, state_node);\n\t\tif (!match_id) {\n\t\t\terr = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!of_device_is_available(state_node)) {\n\t\t\tof_node_put(state_node);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!idle_state_valid(state_node, i, cpumask)) {\n\t\t\tpr_warn(\"%pOF idle state not valid, bailing out\\n\",\n\t\t\t\tstate_node);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state_idx == CPUIDLE_STATE_MAX) {\n\t\t\tpr_warn(\"State index reached static CPU idle driver states array size\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tidle_state = &drv->states[state_idx++];\n\t\terr = init_state_node(idle_state, match_id, state_node);\n\t\tif (err) {\n\t\t\tpr_err(\"Parsing idle state node %pOF failed with err %d\\n\",\n\t\t\t       state_node, err);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tof_node_put(state_node);\n\t}\n\n\tof_node_put(state_node);\n\tof_node_put(cpu_node);\n\tif (err)\n\t\treturn err;\n\n\t \n\tdrv->state_count = state_idx;\n\n\t \n\treturn state_idx - start_idx;\n}\nEXPORT_SYMBOL_GPL(dt_init_idle_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}