{
  "module_name": "cpuidle-cps.c",
  "hash_id": "195ba56e15c2dd844156f25d29e071bb7d6c6583314e50bed6c88de209a9feb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/cpuidle-cps.c",
  "human_readable_source": "\n \n\n#include <linux/cpu_pm.h>\n#include <linux/cpuidle.h>\n#include <linux/init.h>\n\n#include <asm/idle.h>\n#include <asm/pm-cps.h>\n\n \nenum cps_idle_state {\n\tSTATE_WAIT = 0,\t\t \n\tSTATE_NC_WAIT,\t\t \n\tSTATE_CLOCK_GATED,\t \n\tSTATE_POWER_GATED,\t \n\tSTATE_COUNT\n};\n\nstatic int cps_nc_enter(struct cpuidle_device *dev,\n\t\t\tstruct cpuidle_driver *drv, int index)\n{\n\tenum cps_pm_state pm_state;\n\tint err;\n\n\t \n\tif (cpus_are_siblings(0, dev->cpu) && (index > STATE_NC_WAIT))\n\t\tindex = STATE_NC_WAIT;\n\n\t \n\tswitch (index) {\n\tcase STATE_NC_WAIT:\n\t\tpm_state = CPS_PM_NC_WAIT;\n\t\tbreak;\n\tcase STATE_CLOCK_GATED:\n\t\tpm_state = CPS_PM_CLOCK_GATED;\n\t\tbreak;\n\tcase STATE_POWER_GATED:\n\t\tpm_state = CPS_PM_POWER_GATED;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((pm_state == CPS_PM_POWER_GATED) && cpu_pm_enter())\n\t\treturn -EINTR;\n\n\t \n\terr = cps_pm_enter_state(pm_state);\n\n\t \n\tif (pm_state == CPS_PM_POWER_GATED)\n\t\tcpu_pm_exit();\n\n\treturn err ?: index;\n}\n\nstatic struct cpuidle_driver cps_driver = {\n\t.name\t\t\t= \"cpc_cpuidle\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.states = {\n\t\t[STATE_WAIT] = MIPS_CPUIDLE_WAIT_STATE,\n\t\t[STATE_NC_WAIT] = {\n\t\t\t.enter\t= cps_nc_enter,\n\t\t\t.exit_latency\t\t= 200,\n\t\t\t.target_residency\t= 450,\n\t\t\t.name\t= \"nc-wait\",\n\t\t\t.desc\t= \"non-coherent MIPS wait\",\n\t\t},\n\t\t[STATE_CLOCK_GATED] = {\n\t\t\t.enter\t= cps_nc_enter,\n\t\t\t.exit_latency\t\t= 300,\n\t\t\t.target_residency\t= 700,\n\t\t\t.flags\t= CPUIDLE_FLAG_TIMER_STOP,\n\t\t\t.name\t= \"clock-gated\",\n\t\t\t.desc\t= \"core clock gated\",\n\t\t},\n\t\t[STATE_POWER_GATED] = {\n\t\t\t.enter\t= cps_nc_enter,\n\t\t\t.exit_latency\t\t= 600,\n\t\t\t.target_residency\t= 1000,\n\t\t\t.flags\t= CPUIDLE_FLAG_TIMER_STOP,\n\t\t\t.name\t= \"power-gated\",\n\t\t\t.desc\t= \"core power gated\",\n\t\t},\n\t},\n\t.state_count\t\t= STATE_COUNT,\n\t.safe_state_index\t= 0,\n};\n\nstatic void __init cps_cpuidle_unregister(void)\n{\n\tint cpu;\n\tstruct cpuidle_device *device;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tdevice = &per_cpu(cpuidle_dev, cpu);\n\t\tcpuidle_unregister_device(device);\n\t}\n\n\tcpuidle_unregister_driver(&cps_driver);\n}\n\nstatic int __init cps_cpuidle_init(void)\n{\n\tint err, cpu, i;\n\tstruct cpuidle_device *device;\n\n\t \n\tif (!cps_pm_support_state(CPS_PM_POWER_GATED))\n\t\tcps_driver.state_count = STATE_CLOCK_GATED + 1;\n\tif (!cps_pm_support_state(CPS_PM_CLOCK_GATED))\n\t\tcps_driver.state_count = STATE_NC_WAIT + 1;\n\tif (!cps_pm_support_state(CPS_PM_NC_WAIT))\n\t\tcps_driver.state_count = STATE_WAIT + 1;\n\n\t \n\tif (cps_driver.state_count < STATE_COUNT) {\n\t\tpr_info(\"cpuidle-cps: limited to \");\n\t\tswitch (cps_driver.state_count - 1) {\n\t\tcase STATE_WAIT:\n\t\t\tpr_cont(\"coherent wait\\n\");\n\t\t\tbreak;\n\t\tcase STATE_NC_WAIT:\n\t\t\tpr_cont(\"non-coherent wait\\n\");\n\t\t\tbreak;\n\t\tcase STATE_CLOCK_GATED:\n\t\t\tpr_cont(\"clock gating\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (coupled_coherence)\n\t\tfor (i = STATE_NC_WAIT; i < cps_driver.state_count; i++)\n\t\t\tcps_driver.states[i].flags |= CPUIDLE_FLAG_COUPLED;\n\n\terr = cpuidle_register_driver(&cps_driver);\n\tif (err) {\n\t\tpr_err(\"Failed to register CPS cpuidle driver\\n\");\n\t\treturn err;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tdevice = &per_cpu(cpuidle_dev, cpu);\n\t\tdevice->cpu = cpu;\n#ifdef CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED\n\t\tcpumask_copy(&device->coupled_cpus, &cpu_sibling_map[cpu]);\n#endif\n\n\t\terr = cpuidle_register_device(device);\n\t\tif (err) {\n\t\t\tpr_err(\"Failed to register CPU%d cpuidle device\\n\",\n\t\t\t       cpu);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\treturn 0;\nerr_out:\n\tcps_cpuidle_unregister();\n\treturn err;\n}\ndevice_initcall(cps_cpuidle_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}