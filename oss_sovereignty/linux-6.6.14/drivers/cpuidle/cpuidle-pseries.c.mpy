{
  "module_name": "cpuidle-pseries.c",
  "hash_id": "9bca96a0addb93979365c85f8fbd5beb0e85d74aa35e0495b105ee93ccb1388b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/cpuidle-pseries.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/moduleparam.h>\n#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n\n#include <asm/paca.h>\n#include <asm/reg.h>\n#include <asm/machdep.h>\n#include <asm/firmware.h>\n#include <asm/runlatch.h>\n#include <asm/idle.h>\n#include <asm/plpar_wrappers.h>\n#include <asm/rtas.h>\n\nstatic struct cpuidle_driver pseries_idle_driver = {\n\t.name             = \"pseries_idle\",\n\t.owner            = THIS_MODULE,\n};\n\nstatic int max_idle_state __read_mostly;\nstatic struct cpuidle_state *cpuidle_state_table __read_mostly;\nstatic u64 snooze_timeout __read_mostly;\nstatic bool snooze_timeout_en __read_mostly;\n\nstatic __cpuidle\nint snooze_loop(struct cpuidle_device *dev, struct cpuidle_driver *drv,\n\t\tint index)\n{\n\tu64 snooze_exit_time;\n\n\tset_thread_flag(TIF_POLLING_NRFLAG);\n\n\tpseries_idle_prolog();\n\traw_local_irq_enable();\n\tsnooze_exit_time = get_tb() + snooze_timeout;\n\tdev->poll_time_limit = false;\n\n\twhile (!need_resched()) {\n\t\tHMT_low();\n\t\tHMT_very_low();\n\t\tif (likely(snooze_timeout_en) && get_tb() > snooze_exit_time) {\n\t\t\t \n\t\t\tdev->poll_time_limit = true;\n\t\t\tclear_thread_flag(TIF_POLLING_NRFLAG);\n\t\t\tsmp_mb();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tHMT_medium();\n\tclear_thread_flag(TIF_POLLING_NRFLAG);\n\n\traw_local_irq_disable();\n\n\tpseries_idle_epilog();\n\n\treturn index;\n}\n\nstatic __cpuidle void check_and_cede_processor(void)\n{\n\t \n\tif (prep_irq_for_idle()) {\n\t\tcede_processor();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\t\t \n\t\tif (WARN_ON(!(mfmsr() & MSR_EE)))\n\t\t\t__hard_irq_enable();\n#endif\n\t}\n}\n\n \n\n \n#define CEDE_LATENCY_TOKEN\t45\n\n \nstruct xcede_latency_record {\n\tu8\thint;\n\t__be64\tlatency_ticks;\n\tu8\twake_on_irqs;\n} __packed;\n\n\nstruct xcede_latency_payload {\n\tu8     record_size;\n\tstruct xcede_latency_record records[16];\n} __packed;\n\nstruct xcede_latency_parameter {\n\t__be16  payload_size;\n\tstruct xcede_latency_payload payload;\n\tu8 null_char;\n} __packed;\n\nstatic unsigned int nr_xcede_records;\nstatic struct xcede_latency_parameter xcede_latency_parameter __initdata;\n\nstatic int __init parse_cede_parameters(void)\n{\n\tstruct xcede_latency_payload *payload;\n\tu32 total_xcede_records_size;\n\tu8 xcede_record_size;\n\tu16 payload_size;\n\tint ret, i;\n\n\tret = rtas_call(rtas_token(\"ibm,get-system-parameter\"), 3, 1,\n\t\t\tNULL, CEDE_LATENCY_TOKEN, __pa(&xcede_latency_parameter),\n\t\t\tsizeof(xcede_latency_parameter));\n\tif (ret) {\n\t\tpr_err(\"xcede: Error parsing CEDE_LATENCY_TOKEN\\n\");\n\t\treturn ret;\n\t}\n\n\tpayload_size = be16_to_cpu(xcede_latency_parameter.payload_size);\n\tpayload = &xcede_latency_parameter.payload;\n\n\txcede_record_size = payload->record_size + 1;\n\n\tif (xcede_record_size != sizeof(struct xcede_latency_record)) {\n\t\tpr_err(\"xcede: Expected record-size %lu. Observed size %u.\\n\",\n\t\t       sizeof(struct xcede_latency_record), xcede_record_size);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_info(\"xcede: xcede_record_size = %d\\n\", xcede_record_size);\n\n\t \n\ttotal_xcede_records_size = payload_size - 2;\n\tnr_xcede_records = total_xcede_records_size / xcede_record_size;\n\n\tfor (i = 0; i < nr_xcede_records; i++) {\n\t\tstruct xcede_latency_record *record = &payload->records[i];\n\t\tu64 latency_ticks = be64_to_cpu(record->latency_ticks);\n\t\tu8 wake_on_irqs = record->wake_on_irqs;\n\t\tu8 hint = record->hint;\n\n\t\tpr_info(\"xcede: Record %d : hint = %u, latency = 0x%llx tb ticks, Wake-on-irq = %u\\n\",\n\t\t\ti, hint, latency_ticks, wake_on_irqs);\n\t}\n\n\treturn 0;\n}\n\n#define NR_DEDICATED_STATES\t2  \nstatic u8 cede_latency_hint[NR_DEDICATED_STATES];\n\nstatic __cpuidle\nint dedicated_cede_loop(struct cpuidle_device *dev, struct cpuidle_driver *drv,\n\t\t\tint index)\n{\n\tu8 old_latency_hint;\n\n\tpseries_idle_prolog();\n\tget_lppaca()->donate_dedicated_cpu = 1;\n\told_latency_hint = get_lppaca()->cede_latency_hint;\n\tget_lppaca()->cede_latency_hint = cede_latency_hint[index];\n\n\tHMT_medium();\n\tcheck_and_cede_processor();\n\n\traw_local_irq_disable();\n\tget_lppaca()->donate_dedicated_cpu = 0;\n\tget_lppaca()->cede_latency_hint = old_latency_hint;\n\n\tpseries_idle_epilog();\n\n\treturn index;\n}\n\nstatic __cpuidle\nint shared_cede_loop(struct cpuidle_device *dev, struct cpuidle_driver *drv,\n\t\t     int index)\n{\n\n\tpseries_idle_prolog();\n\n\t \n\tcheck_and_cede_processor();\n\n\traw_local_irq_disable();\n\tpseries_idle_epilog();\n\n\treturn index;\n}\n\n \nstatic struct cpuidle_state dedicated_states[NR_DEDICATED_STATES] = {\n\t{  \n\t\t.name = \"snooze\",\n\t\t.desc = \"snooze\",\n\t\t.exit_latency = 0,\n\t\t.target_residency = 0,\n\t\t.enter = &snooze_loop,\n\t\t.flags = CPUIDLE_FLAG_POLLING },\n\t{  \n\t\t.name = \"CEDE\",\n\t\t.desc = \"CEDE\",\n\t\t.exit_latency = 10,\n\t\t.target_residency = 100,\n\t\t.enter = &dedicated_cede_loop },\n};\n\n \nstatic struct cpuidle_state shared_states[] = {\n\t{  \n\t\t.name = \"snooze\",\n\t\t.desc = \"snooze\",\n\t\t.exit_latency = 0,\n\t\t.target_residency = 0,\n\t\t.enter = &snooze_loop,\n\t\t.flags = CPUIDLE_FLAG_POLLING },\n\t{  \n\t\t.name = \"Shared Cede\",\n\t\t.desc = \"Shared Cede\",\n\t\t.exit_latency = 10,\n\t\t.target_residency = 100,\n\t\t.enter = &shared_cede_loop },\n};\n\nstatic int pseries_cpuidle_cpu_online(unsigned int cpu)\n{\n\tstruct cpuidle_device *dev = per_cpu(cpuidle_devices, cpu);\n\n\tif (dev && cpuidle_get_driver()) {\n\t\tcpuidle_pause_and_lock();\n\t\tcpuidle_enable_device(dev);\n\t\tcpuidle_resume_and_unlock();\n\t}\n\treturn 0;\n}\n\nstatic int pseries_cpuidle_cpu_dead(unsigned int cpu)\n{\n\tstruct cpuidle_device *dev = per_cpu(cpuidle_devices, cpu);\n\n\tif (dev && cpuidle_get_driver()) {\n\t\tcpuidle_pause_and_lock();\n\t\tcpuidle_disable_device(dev);\n\t\tcpuidle_resume_and_unlock();\n\t}\n\treturn 0;\n}\n\n \nstatic int pseries_cpuidle_driver_init(void)\n{\n\tint idle_state;\n\tstruct cpuidle_driver *drv = &pseries_idle_driver;\n\n\tdrv->state_count = 0;\n\n\tfor (idle_state = 0; idle_state < max_idle_state; ++idle_state) {\n\t\t \n\t\tif (cpuidle_state_table[idle_state].enter == NULL)\n\t\t\tcontinue;\n\n\t\tdrv->states[drv->state_count] =\t \n\t\t\tcpuidle_state_table[idle_state];\n\n\t\tdrv->state_count += 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void __init fixup_cede0_latency(void)\n{\n\tstruct xcede_latency_payload *payload;\n\tu64 min_xcede_latency_us = UINT_MAX;\n\tint i;\n\n\tif (parse_cede_parameters())\n\t\treturn;\n\n\tpr_info(\"cpuidle: Skipping the %d Extended CEDE idle states\\n\",\n\t\tnr_xcede_records);\n\n\tpayload = &xcede_latency_parameter.payload;\n\n\t \n\tfor (i = 0; i < nr_xcede_records; i++) {\n\t\tstruct xcede_latency_record *record = &payload->records[i];\n\t\tu8 hint = record->hint;\n\t\tu64 latency_tb = be64_to_cpu(record->latency_ticks);\n\t\tu64 latency_us = DIV_ROUND_UP_ULL(tb_to_ns(latency_tb), NSEC_PER_USEC);\n\n\t\t \n\t\tif (latency_us == 0) {\n\t\t\tpr_warn(\"cpuidle: Skipping xcede record %d [hint=%d]. Exit latency = 0us\\n\",\n\t\t\t\ti, hint);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (latency_us < min_xcede_latency_us)\n\t\t\tmin_xcede_latency_us = latency_us;\n\t}\n\n\tif (min_xcede_latency_us != UINT_MAX) {\n\t\tdedicated_states[1].exit_latency = min_xcede_latency_us;\n\t\tdedicated_states[1].target_residency = 10 * (min_xcede_latency_us);\n\t\tpr_info(\"cpuidle: Fixed up CEDE exit latency to %llu us\\n\",\n\t\t\tmin_xcede_latency_us);\n\t}\n\n}\n\n \nstatic int __init pseries_idle_probe(void)\n{\n\n\tif (cpuidle_disable != IDLE_NO_OVERRIDE)\n\t\treturn -ENODEV;\n\n\tif (firmware_has_feature(FW_FEATURE_SPLPAR)) {\n\t\tif (lppaca_shared_proc()) {\n\t\t\tcpuidle_state_table = shared_states;\n\t\t\tmax_idle_state = ARRAY_SIZE(shared_states);\n\t\t} else {\n\t\t\t \n\t\t\tif (cpu_has_feature(CPU_FTR_ARCH_31) || pvr_version_is(PVR_POWER10))\n\t\t\t\tfixup_cede0_latency();\n\t\t\tcpuidle_state_table = dedicated_states;\n\t\t\tmax_idle_state = NR_DEDICATED_STATES;\n\t\t}\n\t} else\n\t\treturn -ENODEV;\n\n\tif (max_idle_state > 1) {\n\t\tsnooze_timeout_en = true;\n\t\tsnooze_timeout = cpuidle_state_table[1].target_residency *\n\t\t\t\t tb_ticks_per_usec;\n\t}\n\treturn 0;\n}\n\nstatic int __init pseries_processor_idle_init(void)\n{\n\tint retval;\n\n\tretval = pseries_idle_probe();\n\tif (retval)\n\t\treturn retval;\n\n\tpseries_cpuidle_driver_init();\n\tretval = cpuidle_register(&pseries_idle_driver, NULL);\n\tif (retval) {\n\t\tprintk(KERN_DEBUG \"Registration of pseries driver failed.\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t   \"cpuidle/pseries:online\",\n\t\t\t\t\t   pseries_cpuidle_cpu_online, NULL);\n\tWARN_ON(retval < 0);\n\tretval = cpuhp_setup_state_nocalls(CPUHP_CPUIDLE_DEAD,\n\t\t\t\t\t   \"cpuidle/pseries:DEAD\", NULL,\n\t\t\t\t\t   pseries_cpuidle_cpu_dead);\n\tWARN_ON(retval < 0);\n\tprintk(KERN_DEBUG \"pseries_idle_driver registered\\n\");\n\treturn 0;\n}\n\ndevice_initcall(pseries_processor_idle_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}