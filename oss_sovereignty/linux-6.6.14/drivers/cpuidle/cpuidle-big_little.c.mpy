{
  "module_name": "cpuidle-big_little.c",
  "hash_id": "f4a37d81347ad6468b5c9775e76113be1b85386bebef6c9e969801b93a0946be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/cpuidle-big_little.c",
  "human_readable_source": "\n \n#include <linux/cpuidle.h>\n#include <linux/cpu_pm.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n#include <asm/cpu.h>\n#include <asm/cputype.h>\n#include <asm/cpuidle.h>\n#include <asm/mcpm.h>\n#include <asm/smp_plat.h>\n#include <asm/suspend.h>\n\n#include \"dt_idle_states.h\"\n\nstatic int bl_enter_powerdown(struct cpuidle_device *dev,\n\t\t\t      struct cpuidle_driver *drv, int idx);\n\n \nstatic struct cpuidle_driver bl_idle_little_driver = {\n\t.name = \"little_idle\",\n\t.owner = THIS_MODULE,\n\t.states[0] = ARM_CPUIDLE_WFI_STATE,\n\t.states[1] = {\n\t\t.enter\t\t\t= bl_enter_powerdown,\n\t\t.exit_latency\t\t= 700,\n\t\t.target_residency\t= 2500,\n\t\t.flags\t\t\t= CPUIDLE_FLAG_TIMER_STOP |\n\t\t\t\t\t  CPUIDLE_FLAG_RCU_IDLE,\n\t\t.name\t\t\t= \"C1\",\n\t\t.desc\t\t\t= \"ARM little-cluster power down\",\n\t},\n\t.state_count = 2,\n};\n\nstatic const struct of_device_id bl_idle_state_match[] __initconst = {\n\t{ .compatible = \"arm,idle-state\",\n\t  .data = bl_enter_powerdown },\n\t{ },\n};\n\nstatic struct cpuidle_driver bl_idle_big_driver = {\n\t.name = \"big_idle\",\n\t.owner = THIS_MODULE,\n\t.states[0] = ARM_CPUIDLE_WFI_STATE,\n\t.states[1] = {\n\t\t.enter\t\t\t= bl_enter_powerdown,\n\t\t.exit_latency\t\t= 500,\n\t\t.target_residency\t= 2000,\n\t\t.flags\t\t\t= CPUIDLE_FLAG_TIMER_STOP |\n\t\t\t\t\t  CPUIDLE_FLAG_RCU_IDLE,\n\t\t.name\t\t\t= \"C1\",\n\t\t.desc\t\t\t= \"ARM big-cluster power down\",\n\t},\n\t.state_count = 2,\n};\n\n \nstatic int notrace bl_powerdown_finisher(unsigned long arg)\n{\n\t \n\tunsigned int mpidr = read_cpuid_mpidr();\n\tunsigned int cluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\n\tunsigned int cpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\n\n\tmcpm_set_entry_vector(cpu, cluster, cpu_resume);\n\tmcpm_cpu_suspend();\n\n\t \n\treturn 1;\n}\n\n \nstatic __cpuidle int bl_enter_powerdown(struct cpuidle_device *dev,\n\t\t\t\t\tstruct cpuidle_driver *drv, int idx)\n{\n\tcpu_pm_enter();\n\tct_cpuidle_enter();\n\n\tcpu_suspend(0, bl_powerdown_finisher);\n\n\t \n\tmcpm_cpu_powered_up();\n\tct_cpuidle_exit();\n\n\tcpu_pm_exit();\n\n\treturn idx;\n}\n\nstatic int __init bl_idle_driver_init(struct cpuidle_driver *drv, int part_id)\n{\n\tstruct cpumask *cpumask;\n\tint cpu;\n\n\tcpumask = kzalloc(cpumask_size(), GFP_KERNEL);\n\tif (!cpumask)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu)\n\t\tif (smp_cpuid_part(cpu) == part_id)\n\t\t\tcpumask_set_cpu(cpu, cpumask);\n\n\tdrv->cpumask = cpumask;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id compatible_machine_match[] = {\n\t{ .compatible = \"arm,vexpress,v2p-ca15_a7\" },\n\t{ .compatible = \"google,peach\" },\n\t{},\n};\n\nstatic int __init bl_idle_init(void)\n{\n\tint ret;\n\tstruct device_node *root = of_find_node_by_path(\"/\");\n\tconst struct of_device_id *match_id;\n\n\tif (!root)\n\t\treturn -ENODEV;\n\n\t \n\tmatch_id = of_match_node(compatible_machine_match, root);\n\n\tof_node_put(root);\n\n\tif (!match_id)\n\t\treturn -ENODEV;\n\n\tif (!mcpm_is_available())\n\t\treturn -EUNATCH;\n\n\t \n\tret = bl_idle_driver_init(&bl_idle_little_driver,\n\t\t\t\t  ARM_CPU_PART_CORTEX_A7);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bl_idle_driver_init(&bl_idle_big_driver, ARM_CPU_PART_CORTEX_A15);\n\tif (ret)\n\t\tgoto out_uninit_little;\n\n\t \n\tret = dt_init_idle_driver(&bl_idle_big_driver, bl_idle_state_match, 1);\n\tif (ret < 0)\n\t\tgoto out_uninit_big;\n\n\t \n\tret = dt_init_idle_driver(&bl_idle_little_driver,\n\t\t\t\t  bl_idle_state_match, 1);\n\tif (ret < 0)\n\t\tgoto out_uninit_big;\n\n\tret = cpuidle_register(&bl_idle_little_driver, NULL);\n\tif (ret)\n\t\tgoto out_uninit_big;\n\n\tret = cpuidle_register(&bl_idle_big_driver, NULL);\n\tif (ret)\n\t\tgoto out_unregister_little;\n\n\treturn 0;\n\nout_unregister_little:\n\tcpuidle_unregister(&bl_idle_little_driver);\nout_uninit_big:\n\tkfree(bl_idle_big_driver.cpumask);\nout_uninit_little:\n\tkfree(bl_idle_little_driver.cpumask);\n\n\treturn ret;\n}\ndevice_initcall(bl_idle_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}