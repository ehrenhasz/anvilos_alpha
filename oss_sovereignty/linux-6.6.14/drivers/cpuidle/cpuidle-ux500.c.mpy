{
  "module_name": "cpuidle-ux500.c",
  "hash_id": "37d9d8368e53ebac94d63fbc6d7c0177e6cbd3a3315c5f90bfd74fb0dd457454",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/cpuidle-ux500.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/cpuidle.h>\n#include <linux/spinlock.h>\n#include <linux/atomic.h>\n#include <linux/smp.h>\n#include <linux/mfd/dbx500-prcmu.h>\n#include <linux/platform_data/arm-ux500-pm.h>\n#include <linux/platform_device.h>\n\n#include <asm/cpuidle.h>\n\nstatic atomic_t master = ATOMIC_INIT(0);\nstatic DEFINE_SPINLOCK(master_lock);\n\nstatic inline int ux500_enter_idle(struct cpuidle_device *dev,\n\t\t\t\t   struct cpuidle_driver *drv, int index)\n{\n\tint this_cpu = smp_processor_id();\n\tbool recouple = false;\n\n\tif (atomic_inc_return(&master) == num_online_cpus()) {\n\n\t\t \n\t\tif (!spin_trylock(&master_lock))\n\t\t\tgoto wfi;\n\n\t\t \n\t\tif (prcmu_gic_decouple()) {\n\t\t\tspin_unlock(&master_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\trecouple = true;\n\n\t\t \n\t\tif (!prcmu_is_cpu_in_wfi(this_cpu ? 0 : 1))\n\t\t\tgoto out;\n\n\t\t \n\t\tif (prcmu_copy_gic_settings())\n\t\t\tgoto out;\n\n\t\t \n\t\tif (prcmu_gic_pending_irq())\n\t\t\tgoto out;\n\n\t\t \n\t\tif (prcmu_pending_irq())\n\t\t\tgoto out;\n\n\t\t \n\t\tif (prcmu_set_power_state(PRCMU_AP_IDLE, true, true))\n\t\t\tgoto out;\n\n\t\t \n\t\trecouple = false;\n\n\t\tspin_unlock(&master_lock);\n\t}\nwfi:\n\tcpu_do_idle();\nout:\n\tatomic_dec(&master);\n\n\tif (recouple) {\n\t\tprcmu_gic_recouple();\n\t\tspin_unlock(&master_lock);\n\t}\n\n\treturn index;\n}\n\nstatic struct cpuidle_driver ux500_idle_driver = {\n\t.name = \"ux500_idle\",\n\t.owner = THIS_MODULE,\n\t.states = {\n\t\tARM_CPUIDLE_WFI_STATE,\n\t\t{\n\t\t\t.enter\t\t  = ux500_enter_idle,\n\t\t\t.exit_latency\t  = 70,\n\t\t\t.target_residency = 260,\n\t\t\t.flags\t\t  = CPUIDLE_FLAG_TIMER_STOP,\n\t\t\t.name\t\t  = \"ApIdle\",\n\t\t\t.desc\t\t  = \"ARM Retention\",\n\t\t},\n\t},\n\t.safe_state_index = 0,\n\t.state_count = 2,\n};\n\nstatic int dbx500_cpuidle_probe(struct platform_device *pdev)\n{\n\t \n\tprcmu_enable_wakeups(PRCMU_WAKEUP(ARM) | PRCMU_WAKEUP(RTC) |\n\t\t\t     PRCMU_WAKEUP(ABB));\n\n\treturn cpuidle_register(&ux500_idle_driver, NULL);\n}\n\nstatic struct platform_driver dbx500_cpuidle_plat_driver = {\n\t.driver = {\n\t\t.name = \"db8500-cpuidle\",\n\t},\n\t.probe = dbx500_cpuidle_probe,\n};\nbuiltin_platform_driver(dbx500_cpuidle_plat_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}