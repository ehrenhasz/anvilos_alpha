{
  "module_name": "dt_idle_genpd.c",
  "hash_id": "8531f61dd701276f1842351254281d7419df1b4636422e7f1b271d88c647d5e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/dt_idle_genpd.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"dt-idle-genpd: \" fmt\n\n#include <linux/cpu.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include \"dt_idle_genpd.h\"\n\nstatic int pd_parse_state_nodes(\n\t\t\tint (*parse_state)(struct device_node *, u32 *),\n\t\t\tstruct genpd_power_state *states, int state_count)\n{\n\tint i, ret;\n\tu32 state, *state_buf;\n\n\tfor (i = 0; i < state_count; i++) {\n\t\tret = parse_state(to_of_node(states[i].fwnode), &state);\n\t\tif (ret)\n\t\t\tgoto free_state;\n\n\t\tstate_buf = kmalloc(sizeof(u32), GFP_KERNEL);\n\t\tif (!state_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_state;\n\t\t}\n\t\t*state_buf = state;\n\t\tstates[i].data = state_buf;\n\t}\n\n\treturn 0;\n\nfree_state:\n\ti--;\n\tfor (; i >= 0; i--)\n\t\tkfree(states[i].data);\n\treturn ret;\n}\n\nstatic int pd_parse_states(struct device_node *np,\n\t\t\t   int (*parse_state)(struct device_node *, u32 *),\n\t\t\t   struct genpd_power_state **states,\n\t\t\t   int *state_count)\n{\n\tint ret;\n\n\t \n\tret = of_genpd_parse_idle_states(np, states, state_count);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = pd_parse_state_nodes(parse_state, *states, *state_count);\n\tif (ret)\n\t\tkfree(*states);\n\n\treturn ret;\n}\n\nstatic void pd_free_states(struct genpd_power_state *states,\n\t\t\t    unsigned int state_count)\n{\n\tint i;\n\n\tfor (i = 0; i < state_count; i++)\n\t\tkfree(states[i].data);\n\tkfree(states);\n}\n\nvoid dt_idle_pd_free(struct generic_pm_domain *pd)\n{\n\tpd_free_states(pd->states, pd->state_count);\n\tkfree(pd->name);\n\tkfree(pd);\n}\n\nstruct generic_pm_domain *dt_idle_pd_alloc(struct device_node *np,\n\t\t\tint (*parse_state)(struct device_node *, u32 *))\n{\n\tstruct generic_pm_domain *pd;\n\tstruct genpd_power_state *states = NULL;\n\tint ret, state_count = 0;\n\n\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto out;\n\n\tpd->name = kasprintf(GFP_KERNEL, \"%pOF\", np);\n\tif (!pd->name)\n\t\tgoto free_pd;\n\n\t \n\tret = pd_parse_states(np, parse_state, &states, &state_count);\n\tif (ret)\n\t\tgoto free_name;\n\n\tpd->free_states = pd_free_states;\n\tpd->name = kbasename(pd->name);\n\tpd->states = states;\n\tpd->state_count = state_count;\n\n\tpr_debug(\"alloc PM domain %s\\n\", pd->name);\n\treturn pd;\n\nfree_name:\n\tkfree(pd->name);\nfree_pd:\n\tkfree(pd);\nout:\n\tpr_err(\"failed to alloc PM domain %pOF\\n\", np);\n\treturn NULL;\n}\n\nint dt_idle_pd_init_topology(struct device_node *np)\n{\n\tstruct device_node *node;\n\tstruct of_phandle_args child, parent;\n\tint ret;\n\n\tfor_each_child_of_node(np, node) {\n\t\tif (of_parse_phandle_with_args(node, \"power-domains\",\n\t\t\t\t\t\"#power-domain-cells\", 0, &parent))\n\t\t\tcontinue;\n\n\t\tchild.np = node;\n\t\tchild.args_count = 0;\n\t\tret = of_genpd_add_subdomain(&parent, &child);\n\t\tof_node_put(parent.np);\n\t\tif (ret) {\n\t\t\tof_node_put(node);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint dt_idle_pd_remove_topology(struct device_node *np)\n{\n\tstruct device_node *node;\n\tstruct of_phandle_args child, parent;\n\tint ret;\n\n\tfor_each_child_of_node(np, node) {\n\t\tif (of_parse_phandle_with_args(node, \"power-domains\",\n\t\t\t\t\t\"#power-domain-cells\", 0, &parent))\n\t\t\tcontinue;\n\n\t\tchild.np = node;\n\t\tchild.args_count = 0;\n\t\tret = of_genpd_remove_subdomain(&parent, &child);\n\t\tof_node_put(parent.np);\n\t\tif (ret) {\n\t\t\tof_node_put(node);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct device *dt_idle_attach_cpu(int cpu, const char *name)\n{\n\tstruct device *dev;\n\n\tdev = dev_pm_domain_attach_by_name(get_cpu_device(cpu), name);\n\tif (IS_ERR_OR_NULL(dev))\n\t\treturn dev;\n\n\tpm_runtime_irq_safe(dev);\n\tif (cpu_online(cpu))\n\t\tpm_runtime_get_sync(dev);\n\n\tdev_pm_syscore_device(dev, true);\n\n\treturn dev;\n}\n\nvoid dt_idle_detach_cpu(struct device *dev)\n{\n\tif (IS_ERR_OR_NULL(dev))\n\t\treturn;\n\n\tdev_pm_domain_detach(dev, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}