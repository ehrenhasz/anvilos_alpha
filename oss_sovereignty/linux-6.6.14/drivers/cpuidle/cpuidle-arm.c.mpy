{
  "module_name": "cpuidle-arm.c",
  "hash_id": "ada701bc766b1fa10234c2b10e6fb0c27e5644028911f55c3d2f0a5326cb67b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/cpuidle-arm.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"CPUidle arm: \" fmt\n\n#include <linux/cpu_cooling.h>\n#include <linux/cpuidle.h>\n#include <linux/cpumask.h>\n#include <linux/cpu_pm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\n#include <asm/cpuidle.h>\n\n#include \"dt_idle_states.h\"\n\n \nstatic __cpuidle int arm_enter_idle_state(struct cpuidle_device *dev,\n\t\t\t\t\t  struct cpuidle_driver *drv, int idx)\n{\n\t \n\treturn CPU_PM_CPU_IDLE_ENTER(arm_cpuidle_suspend, idx);\n}\n\nstatic struct cpuidle_driver arm_idle_driver __initdata = {\n\t.name = \"arm_idle\",\n\t.owner = THIS_MODULE,\n\t \n\t.states[0] = {\n\t\t.enter                  = arm_enter_idle_state,\n\t\t.exit_latency           = 1,\n\t\t.target_residency       = 1,\n\t\t.power_usage\t\t= UINT_MAX,\n\t\t.name                   = \"WFI\",\n\t\t.desc                   = \"ARM WFI\",\n\t}\n};\n\nstatic const struct of_device_id arm_idle_state_match[] __initconst = {\n\t{ .compatible = \"arm,idle-state\",\n\t  .data = arm_enter_idle_state },\n\t{ },\n};\n\n \nstatic int __init arm_idle_init_cpu(int cpu)\n{\n\tint ret;\n\tstruct cpuidle_driver *drv;\n\n\tdrv = kmemdup(&arm_idle_driver, sizeof(*drv), GFP_KERNEL);\n\tif (!drv)\n\t\treturn -ENOMEM;\n\n\tdrv->cpumask = (struct cpumask *)cpumask_of(cpu);\n\n\t \n\tret = dt_init_idle_driver(drv, arm_idle_state_match, 1);\n\tif (ret <= 0) {\n\t\tret = ret ? : -ENODEV;\n\t\tgoto out_kfree_drv;\n\t}\n\n\t \n\tret = arm_cpuidle_init(cpu);\n\n\t \n\tif (ret) {\n\t\tif (ret != -EOPNOTSUPP)\n\t\t\tpr_err(\"CPU %d failed to init idle CPU ops\\n\", cpu);\n\t\tret = ret == -ENXIO ? 0 : ret;\n\t\tgoto out_kfree_drv;\n\t}\n\n\tret = cpuidle_register(drv, NULL);\n\tif (ret)\n\t\tgoto out_kfree_drv;\n\n\tcpuidle_cooling_register(drv);\n\n\treturn 0;\n\nout_kfree_drv:\n\tkfree(drv);\n\treturn ret;\n}\n\n \nstatic int __init arm_idle_init(void)\n{\n\tint cpu, ret;\n\tstruct cpuidle_driver *drv;\n\tstruct cpuidle_device *dev;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tret = arm_idle_init_cpu(cpu);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t}\n\n\treturn 0;\n\nout_fail:\n\twhile (--cpu >= 0) {\n\t\tdev = per_cpu(cpuidle_devices, cpu);\n\t\tdrv = cpuidle_get_cpu_driver(dev);\n\t\tcpuidle_unregister(drv);\n\t\tkfree(drv);\n\t}\n\n\treturn ret;\n}\ndevice_initcall(arm_idle_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}