{
  "module_name": "sysfs.c",
  "hash_id": "b394468fd04e94ce442b72e6fcb3035cd90532d0c90d959ca5a66aabf5eeda0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/sysfs.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/cpuidle.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/device.h>\n#include <linux/kobject.h>\n\n#include \"cpuidle.h\"\n\nstatic ssize_t show_available_governors(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tssize_t i = 0;\n\tstruct cpuidle_governor *tmp;\n\n\tmutex_lock(&cpuidle_lock);\n\tlist_for_each_entry(tmp, &cpuidle_governors, governor_list) {\n\t\tif (i >= (ssize_t) (PAGE_SIZE - (CPUIDLE_NAME_LEN + 2)))\n\t\t\tgoto out;\n\n\t\ti += scnprintf(&buf[i], CPUIDLE_NAME_LEN + 1, \"%s \", tmp->name);\n\t}\n\nout:\n\ti+= sprintf(&buf[i], \"\\n\");\n\tmutex_unlock(&cpuidle_lock);\n\treturn i;\n}\n\nstatic ssize_t show_current_driver(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tssize_t ret;\n\tstruct cpuidle_driver *drv;\n\n\tspin_lock(&cpuidle_driver_lock);\n\tdrv = cpuidle_get_driver();\n\tif (drv)\n\t\tret = sprintf(buf, \"%s\\n\", drv->name);\n\telse\n\t\tret = sprintf(buf, \"none\\n\");\n\tspin_unlock(&cpuidle_driver_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t show_current_governor(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tssize_t ret;\n\n\tmutex_lock(&cpuidle_lock);\n\tif (cpuidle_curr_governor)\n\t\tret = sprintf(buf, \"%s\\n\", cpuidle_curr_governor->name);\n\telse\n\t\tret = sprintf(buf, \"none\\n\");\n\tmutex_unlock(&cpuidle_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t store_current_governor(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tchar gov_name[CPUIDLE_NAME_LEN + 1];\n\tint ret;\n\tstruct cpuidle_governor *gov;\n\n\tret = sscanf(buf, \"%\" __stringify(CPUIDLE_NAME_LEN) \"s\", gov_name);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cpuidle_lock);\n\tret = -EINVAL;\n\tlist_for_each_entry(gov, &cpuidle_governors, governor_list) {\n\t\tif (!strncmp(gov->name, gov_name, CPUIDLE_NAME_LEN)) {\n\t\t\tret = cpuidle_switch_governor(gov);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&cpuidle_lock);\n\n\treturn ret ? ret : count;\n}\n\nstatic DEVICE_ATTR(available_governors, 0444, show_available_governors, NULL);\nstatic DEVICE_ATTR(current_driver, 0444, show_current_driver, NULL);\nstatic DEVICE_ATTR(current_governor, 0644, show_current_governor,\n\t\t\t\t   store_current_governor);\nstatic DEVICE_ATTR(current_governor_ro, 0444, show_current_governor, NULL);\n\nstatic struct attribute *cpuidle_attrs[] = {\n\t&dev_attr_available_governors.attr,\n\t&dev_attr_current_driver.attr,\n\t&dev_attr_current_governor.attr,\n\t&dev_attr_current_governor_ro.attr,\n\tNULL\n};\n\nstatic struct attribute_group cpuidle_attr_group = {\n\t.attrs = cpuidle_attrs,\n\t.name = \"cpuidle\",\n};\n\n \nint cpuidle_add_interface(void)\n{\n\tstruct device *dev_root = bus_get_dev_root(&cpu_subsys);\n\tint retval;\n\n\tif (!dev_root)\n\t\treturn -EINVAL;\n\n\tretval = sysfs_create_group(&dev_root->kobj, &cpuidle_attr_group);\n\tput_device(dev_root);\n\treturn retval;\n}\n\n \nvoid cpuidle_remove_interface(struct device *dev)\n{\n\tsysfs_remove_group(&dev->kobj, &cpuidle_attr_group);\n}\n\nstruct cpuidle_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct cpuidle_device *, char *);\n\tssize_t (*store)(struct cpuidle_device *, const char *, size_t count);\n};\n\n#define attr_to_cpuidleattr(a) container_of(a, struct cpuidle_attr, attr)\n\nstruct cpuidle_device_kobj {\n\tstruct cpuidle_device *dev;\n\tstruct completion kobj_unregister;\n\tstruct kobject kobj;\n};\n\nstatic inline struct cpuidle_device *to_cpuidle_device(struct kobject *kobj)\n{\n\tstruct cpuidle_device_kobj *kdev =\n\t\tcontainer_of(kobj, struct cpuidle_device_kobj, kobj);\n\n\treturn kdev->dev;\n}\n\nstatic ssize_t cpuidle_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t    char *buf)\n{\n\tint ret = -EIO;\n\tstruct cpuidle_device *dev = to_cpuidle_device(kobj);\n\tstruct cpuidle_attr *cattr = attr_to_cpuidleattr(attr);\n\n\tif (cattr->show) {\n\t\tmutex_lock(&cpuidle_lock);\n\t\tret = cattr->show(dev, buf);\n\t\tmutex_unlock(&cpuidle_lock);\n\t}\n\treturn ret;\n}\n\nstatic ssize_t cpuidle_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tint ret = -EIO;\n\tstruct cpuidle_device *dev = to_cpuidle_device(kobj);\n\tstruct cpuidle_attr *cattr = attr_to_cpuidleattr(attr);\n\n\tif (cattr->store) {\n\t\tmutex_lock(&cpuidle_lock);\n\t\tret = cattr->store(dev, buf, count);\n\t\tmutex_unlock(&cpuidle_lock);\n\t}\n\treturn ret;\n}\n\nstatic const struct sysfs_ops cpuidle_sysfs_ops = {\n\t.show = cpuidle_show,\n\t.store = cpuidle_store,\n};\n\nstatic void cpuidle_sysfs_release(struct kobject *kobj)\n{\n\tstruct cpuidle_device_kobj *kdev =\n\t\tcontainer_of(kobj, struct cpuidle_device_kobj, kobj);\n\n\tcomplete(&kdev->kobj_unregister);\n}\n\nstatic const struct kobj_type ktype_cpuidle = {\n\t.sysfs_ops = &cpuidle_sysfs_ops,\n\t.release = cpuidle_sysfs_release,\n};\n\nstruct cpuidle_state_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct cpuidle_state *, \\\n\t\t\t\t\tstruct cpuidle_state_usage *, char *);\n\tssize_t (*store)(struct cpuidle_state *, \\\n\t\t\tstruct cpuidle_state_usage *, const char *, size_t);\n};\n\n#define define_one_state_ro(_name, show) \\\nstatic struct cpuidle_state_attr attr_##_name = __ATTR(_name, 0444, show, NULL)\n\n#define define_one_state_rw(_name, show, store) \\\nstatic struct cpuidle_state_attr attr_##_name = __ATTR(_name, 0644, show, store)\n\n#define define_show_state_function(_name) \\\nstatic ssize_t show_state_##_name(struct cpuidle_state *state, \\\n\t\t\t struct cpuidle_state_usage *state_usage, char *buf) \\\n{ \\\n\treturn sprintf(buf, \"%u\\n\", state->_name);\\\n}\n\n#define define_show_state_ull_function(_name) \\\nstatic ssize_t show_state_##_name(struct cpuidle_state *state, \\\n\t\t\t\t  struct cpuidle_state_usage *state_usage, \\\n\t\t\t\t  char *buf)\t\t\t\t\\\n{ \\\n\treturn sprintf(buf, \"%llu\\n\", state_usage->_name);\\\n}\n\n#define define_show_state_str_function(_name) \\\nstatic ssize_t show_state_##_name(struct cpuidle_state *state, \\\n\t\t\t\t  struct cpuidle_state_usage *state_usage, \\\n\t\t\t\t  char *buf)\t\t\t\t\\\n{ \\\n\tif (state->_name[0] == '\\0')\\\n\t\treturn sprintf(buf, \"<null>\\n\");\\\n\treturn sprintf(buf, \"%s\\n\", state->_name);\\\n}\n\n#define define_show_state_time_function(_name) \\\nstatic ssize_t show_state_##_name(struct cpuidle_state *state, \\\n\t\t\t\t  struct cpuidle_state_usage *state_usage, \\\n\t\t\t\t  char *buf) \\\n{ \\\n\treturn sprintf(buf, \"%llu\\n\", ktime_to_us(state->_name##_ns)); \\\n}\n\ndefine_show_state_time_function(exit_latency)\ndefine_show_state_time_function(target_residency)\ndefine_show_state_function(power_usage)\ndefine_show_state_ull_function(usage)\ndefine_show_state_ull_function(rejected)\ndefine_show_state_str_function(name)\ndefine_show_state_str_function(desc)\ndefine_show_state_ull_function(above)\ndefine_show_state_ull_function(below)\n\nstatic ssize_t show_state_time(struct cpuidle_state *state,\n\t\t\t       struct cpuidle_state_usage *state_usage,\n\t\t\t       char *buf)\n{\n\treturn sprintf(buf, \"%llu\\n\", ktime_to_us(state_usage->time_ns));\n}\n\nstatic ssize_t show_state_disable(struct cpuidle_state *state,\n\t\t\t\t  struct cpuidle_state_usage *state_usage,\n\t\t\t\t  char *buf)\n{\n\treturn sprintf(buf, \"%llu\\n\",\n\t\t       state_usage->disable & CPUIDLE_STATE_DISABLED_BY_USER);\n}\n\nstatic ssize_t store_state_disable(struct cpuidle_state *state,\n\t\t\t\t   struct cpuidle_state_usage *state_usage,\n\t\t\t\t   const char *buf, size_t size)\n{\n\tunsigned int value;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terr = kstrtouint(buf, 0, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (value)\n\t\tstate_usage->disable |= CPUIDLE_STATE_DISABLED_BY_USER;\n\telse\n\t\tstate_usage->disable &= ~CPUIDLE_STATE_DISABLED_BY_USER;\n\n\treturn size;\n}\n\nstatic ssize_t show_state_default_status(struct cpuidle_state *state,\n\t\t\t\t\t  struct cpuidle_state_usage *state_usage,\n\t\t\t\t\t  char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       state->flags & CPUIDLE_FLAG_OFF ? \"disabled\" : \"enabled\");\n}\n\ndefine_one_state_ro(name, show_state_name);\ndefine_one_state_ro(desc, show_state_desc);\ndefine_one_state_ro(latency, show_state_exit_latency);\ndefine_one_state_ro(residency, show_state_target_residency);\ndefine_one_state_ro(power, show_state_power_usage);\ndefine_one_state_ro(usage, show_state_usage);\ndefine_one_state_ro(rejected, show_state_rejected);\ndefine_one_state_ro(time, show_state_time);\ndefine_one_state_rw(disable, show_state_disable, store_state_disable);\ndefine_one_state_ro(above, show_state_above);\ndefine_one_state_ro(below, show_state_below);\ndefine_one_state_ro(default_status, show_state_default_status);\n\nstatic struct attribute *cpuidle_state_default_attrs[] = {\n\t&attr_name.attr,\n\t&attr_desc.attr,\n\t&attr_latency.attr,\n\t&attr_residency.attr,\n\t&attr_power.attr,\n\t&attr_usage.attr,\n\t&attr_rejected.attr,\n\t&attr_time.attr,\n\t&attr_disable.attr,\n\t&attr_above.attr,\n\t&attr_below.attr,\n\t&attr_default_status.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(cpuidle_state_default);\n\nstruct cpuidle_state_kobj {\n\tstruct cpuidle_state *state;\n\tstruct cpuidle_state_usage *state_usage;\n\tstruct completion kobj_unregister;\n\tstruct kobject kobj;\n\tstruct cpuidle_device *device;\n};\n\n#ifdef CONFIG_SUSPEND\n#define define_show_state_s2idle_ull_function(_name) \\\nstatic ssize_t show_state_s2idle_##_name(struct cpuidle_state *state, \\\n\t\t\t\t\t struct cpuidle_state_usage *state_usage, \\\n\t\t\t\t\t char *buf)\t\t\t\t\\\n{ \\\n\treturn sprintf(buf, \"%llu\\n\", state_usage->s2idle_##_name);\\\n}\n\ndefine_show_state_s2idle_ull_function(usage);\ndefine_show_state_s2idle_ull_function(time);\n\n#define define_one_state_s2idle_ro(_name, show) \\\nstatic struct cpuidle_state_attr attr_s2idle_##_name = \\\n\t__ATTR(_name, 0444, show, NULL)\n\ndefine_one_state_s2idle_ro(usage, show_state_s2idle_usage);\ndefine_one_state_s2idle_ro(time, show_state_s2idle_time);\n\nstatic struct attribute *cpuidle_state_s2idle_attrs[] = {\n\t&attr_s2idle_usage.attr,\n\t&attr_s2idle_time.attr,\n\tNULL\n};\n\nstatic const struct attribute_group cpuidle_state_s2idle_group = {\n\t.name\t= \"s2idle\",\n\t.attrs\t= cpuidle_state_s2idle_attrs,\n};\n\nstatic void cpuidle_add_s2idle_attr_group(struct cpuidle_state_kobj *kobj)\n{\n\tint ret;\n\n\tif (!kobj->state->enter_s2idle)\n\t\treturn;\n\n\tret = sysfs_create_group(&kobj->kobj, &cpuidle_state_s2idle_group);\n\tif (ret)\n\t\tpr_debug(\"%s: sysfs attribute group not created\\n\", __func__);\n}\n\nstatic void cpuidle_remove_s2idle_attr_group(struct cpuidle_state_kobj *kobj)\n{\n\tif (kobj->state->enter_s2idle)\n\t\tsysfs_remove_group(&kobj->kobj, &cpuidle_state_s2idle_group);\n}\n#else\nstatic inline void cpuidle_add_s2idle_attr_group(struct cpuidle_state_kobj *kobj) { }\nstatic inline void cpuidle_remove_s2idle_attr_group(struct cpuidle_state_kobj *kobj) { }\n#endif  \n\n#define kobj_to_state_obj(k) container_of(k, struct cpuidle_state_kobj, kobj)\n#define kobj_to_state(k) (kobj_to_state_obj(k)->state)\n#define kobj_to_state_usage(k) (kobj_to_state_obj(k)->state_usage)\n#define kobj_to_device(k) (kobj_to_state_obj(k)->device)\n#define attr_to_stateattr(a) container_of(a, struct cpuidle_state_attr, attr)\n\nstatic ssize_t cpuidle_state_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tint ret = -EIO;\n\tstruct cpuidle_state *state = kobj_to_state(kobj);\n\tstruct cpuidle_state_usage *state_usage = kobj_to_state_usage(kobj);\n\tstruct cpuidle_state_attr *cattr = attr_to_stateattr(attr);\n\n\tif (cattr->show)\n\t\tret = cattr->show(state, state_usage, buf);\n\n\treturn ret;\n}\n\nstatic ssize_t cpuidle_state_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t   const char *buf, size_t size)\n{\n\tint ret = -EIO;\n\tstruct cpuidle_state *state = kobj_to_state(kobj);\n\tstruct cpuidle_state_usage *state_usage = kobj_to_state_usage(kobj);\n\tstruct cpuidle_state_attr *cattr = attr_to_stateattr(attr);\n\tstruct cpuidle_device *dev = kobj_to_device(kobj);\n\n\tif (cattr->store)\n\t\tret = cattr->store(state, state_usage, buf, size);\n\n\t \n\tdev->poll_limit_ns = 0;\n\n\treturn ret;\n}\n\nstatic const struct sysfs_ops cpuidle_state_sysfs_ops = {\n\t.show = cpuidle_state_show,\n\t.store = cpuidle_state_store,\n};\n\nstatic void cpuidle_state_sysfs_release(struct kobject *kobj)\n{\n\tstruct cpuidle_state_kobj *state_obj = kobj_to_state_obj(kobj);\n\n\tcomplete(&state_obj->kobj_unregister);\n}\n\nstatic const struct kobj_type ktype_state_cpuidle = {\n\t.sysfs_ops = &cpuidle_state_sysfs_ops,\n\t.default_groups = cpuidle_state_default_groups,\n\t.release = cpuidle_state_sysfs_release,\n};\n\nstatic inline void cpuidle_free_state_kobj(struct cpuidle_device *device, int i)\n{\n\tcpuidle_remove_s2idle_attr_group(device->kobjs[i]);\n\tkobject_put(&device->kobjs[i]->kobj);\n\twait_for_completion(&device->kobjs[i]->kobj_unregister);\n\tkfree(device->kobjs[i]);\n\tdevice->kobjs[i] = NULL;\n}\n\n \nstatic int cpuidle_add_state_sysfs(struct cpuidle_device *device)\n{\n\tint i, ret = -ENOMEM;\n\tstruct cpuidle_state_kobj *kobj;\n\tstruct cpuidle_device_kobj *kdev = device->kobj_dev;\n\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(device);\n\n\t \n\tfor (i = 0; i < drv->state_count; i++) {\n\t\tkobj = kzalloc(sizeof(struct cpuidle_state_kobj), GFP_KERNEL);\n\t\tif (!kobj) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_state;\n\t\t}\n\t\tkobj->state = &drv->states[i];\n\t\tkobj->state_usage = &device->states_usage[i];\n\t\tkobj->device = device;\n\t\tinit_completion(&kobj->kobj_unregister);\n\n\t\tret = kobject_init_and_add(&kobj->kobj, &ktype_state_cpuidle,\n\t\t\t\t\t   &kdev->kobj, \"state%d\", i);\n\t\tif (ret) {\n\t\t\tkobject_put(&kobj->kobj);\n\t\t\tkfree(kobj);\n\t\t\tgoto error_state;\n\t\t}\n\t\tcpuidle_add_s2idle_attr_group(kobj);\n\t\tkobject_uevent(&kobj->kobj, KOBJ_ADD);\n\t\tdevice->kobjs[i] = kobj;\n\t}\n\n\treturn 0;\n\nerror_state:\n\tfor (i = i - 1; i >= 0; i--)\n\t\tcpuidle_free_state_kobj(device, i);\n\treturn ret;\n}\n\n \nstatic void cpuidle_remove_state_sysfs(struct cpuidle_device *device)\n{\n\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(device);\n\tint i;\n\n\tfor (i = 0; i < drv->state_count; i++)\n\t\tcpuidle_free_state_kobj(device, i);\n}\n\n#ifdef CONFIG_CPU_IDLE_MULTIPLE_DRIVERS\n#define kobj_to_driver_kobj(k) container_of(k, struct cpuidle_driver_kobj, kobj)\n#define attr_to_driver_attr(a) container_of(a, struct cpuidle_driver_attr, attr)\n\n#define define_one_driver_ro(_name, show)                       \\\n\tstatic struct cpuidle_driver_attr attr_driver_##_name = \\\n\t\t__ATTR(_name, 0444, show, NULL)\n\nstruct cpuidle_driver_kobj {\n\tstruct cpuidle_driver *drv;\n\tstruct completion kobj_unregister;\n\tstruct kobject kobj;\n};\n\nstruct cpuidle_driver_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct cpuidle_driver *, char *);\n\tssize_t (*store)(struct cpuidle_driver *, const char *, size_t);\n};\n\nstatic ssize_t show_driver_name(struct cpuidle_driver *drv, char *buf)\n{\n\tssize_t ret;\n\n\tspin_lock(&cpuidle_driver_lock);\n\tret = sprintf(buf, \"%s\\n\", drv ? drv->name : \"none\");\n\tspin_unlock(&cpuidle_driver_lock);\n\n\treturn ret;\n}\n\nstatic void cpuidle_driver_sysfs_release(struct kobject *kobj)\n{\n\tstruct cpuidle_driver_kobj *driver_kobj = kobj_to_driver_kobj(kobj);\n\tcomplete(&driver_kobj->kobj_unregister);\n}\n\nstatic ssize_t cpuidle_driver_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tint ret = -EIO;\n\tstruct cpuidle_driver_kobj *driver_kobj = kobj_to_driver_kobj(kobj);\n\tstruct cpuidle_driver_attr *dattr = attr_to_driver_attr(attr);\n\n\tif (dattr->show)\n\t\tret = dattr->show(driver_kobj->drv, buf);\n\n\treturn ret;\n}\n\nstatic ssize_t cpuidle_driver_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t    const char *buf, size_t size)\n{\n\tint ret = -EIO;\n\tstruct cpuidle_driver_kobj *driver_kobj = kobj_to_driver_kobj(kobj);\n\tstruct cpuidle_driver_attr *dattr = attr_to_driver_attr(attr);\n\n\tif (dattr->store)\n\t\tret = dattr->store(driver_kobj->drv, buf, size);\n\n\treturn ret;\n}\n\ndefine_one_driver_ro(name, show_driver_name);\n\nstatic const struct sysfs_ops cpuidle_driver_sysfs_ops = {\n\t.show = cpuidle_driver_show,\n\t.store = cpuidle_driver_store,\n};\n\nstatic struct attribute *cpuidle_driver_default_attrs[] = {\n\t&attr_driver_name.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(cpuidle_driver_default);\n\nstatic const struct kobj_type ktype_driver_cpuidle = {\n\t.sysfs_ops = &cpuidle_driver_sysfs_ops,\n\t.default_groups = cpuidle_driver_default_groups,\n\t.release = cpuidle_driver_sysfs_release,\n};\n\n \nstatic int cpuidle_add_driver_sysfs(struct cpuidle_device *dev)\n{\n\tstruct cpuidle_driver_kobj *kdrv;\n\tstruct cpuidle_device_kobj *kdev = dev->kobj_dev;\n\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);\n\tint ret;\n\n\tkdrv = kzalloc(sizeof(*kdrv), GFP_KERNEL);\n\tif (!kdrv)\n\t\treturn -ENOMEM;\n\n\tkdrv->drv = drv;\n\tinit_completion(&kdrv->kobj_unregister);\n\n\tret = kobject_init_and_add(&kdrv->kobj, &ktype_driver_cpuidle,\n\t\t\t\t   &kdev->kobj, \"driver\");\n\tif (ret) {\n\t\tkobject_put(&kdrv->kobj);\n\t\tkfree(kdrv);\n\t\treturn ret;\n\t}\n\n\tkobject_uevent(&kdrv->kobj, KOBJ_ADD);\n\tdev->kobj_driver = kdrv;\n\n\treturn ret;\n}\n\n \nstatic void cpuidle_remove_driver_sysfs(struct cpuidle_device *dev)\n{\n\tstruct cpuidle_driver_kobj *kdrv = dev->kobj_driver;\n\tkobject_put(&kdrv->kobj);\n\twait_for_completion(&kdrv->kobj_unregister);\n\tkfree(kdrv);\n}\n#else\nstatic inline int cpuidle_add_driver_sysfs(struct cpuidle_device *dev)\n{\n\treturn 0;\n}\n\nstatic inline void cpuidle_remove_driver_sysfs(struct cpuidle_device *dev)\n{\n\t;\n}\n#endif\n\n \nint cpuidle_add_device_sysfs(struct cpuidle_device *device)\n{\n\tint ret;\n\n\tret = cpuidle_add_state_sysfs(device);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cpuidle_add_driver_sysfs(device);\n\tif (ret)\n\t\tcpuidle_remove_state_sysfs(device);\n\treturn ret;\n}\n\n \nvoid cpuidle_remove_device_sysfs(struct cpuidle_device *device)\n{\n\tcpuidle_remove_driver_sysfs(device);\n\tcpuidle_remove_state_sysfs(device);\n}\n\n \nint cpuidle_add_sysfs(struct cpuidle_device *dev)\n{\n\tstruct cpuidle_device_kobj *kdev;\n\tstruct device *cpu_dev = get_cpu_device((unsigned long)dev->cpu);\n\tint error;\n\n\t \n\tif (!cpu_dev)\n\t\treturn -ENODEV;\n\n\tkdev = kzalloc(sizeof(*kdev), GFP_KERNEL);\n\tif (!kdev)\n\t\treturn -ENOMEM;\n\tkdev->dev = dev;\n\n\tinit_completion(&kdev->kobj_unregister);\n\n\terror = kobject_init_and_add(&kdev->kobj, &ktype_cpuidle, &cpu_dev->kobj,\n\t\t\t\t   \"cpuidle\");\n\tif (error) {\n\t\tkobject_put(&kdev->kobj);\n\t\tkfree(kdev);\n\t\treturn error;\n\t}\n\n\tdev->kobj_dev = kdev;\n\tkobject_uevent(&kdev->kobj, KOBJ_ADD);\n\n\treturn 0;\n}\n\n \nvoid cpuidle_remove_sysfs(struct cpuidle_device *dev)\n{\n\tstruct cpuidle_device_kobj *kdev = dev->kobj_dev;\n\n\tkobject_put(&kdev->kobj);\n\twait_for_completion(&kdev->kobj_unregister);\n\tkfree(kdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}