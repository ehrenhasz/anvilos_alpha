{
  "module_name": "cpuidle-psci-domain.c",
  "hash_id": "af532af150c86cf17b7dfed7a03197e83e0e768309606bff9e7ad860f836733a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/cpuidle-psci-domain.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"CPUidle PSCI: \" fmt\n\n#include <linux/cpu.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/psci.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include \"cpuidle-psci.h\"\n\nstruct psci_pd_provider {\n\tstruct list_head link;\n\tstruct device_node *node;\n};\n\nstatic LIST_HEAD(psci_pd_providers);\nstatic bool psci_pd_allow_domain_state;\n\nstatic int psci_pd_power_off(struct generic_pm_domain *pd)\n{\n\tstruct genpd_power_state *state = &pd->states[pd->state_idx];\n\tu32 *pd_state;\n\n\tif (!state->data)\n\t\treturn 0;\n\n\tif (!psci_pd_allow_domain_state)\n\t\treturn -EBUSY;\n\n\t \n\tpd_state = state->data;\n\tpsci_set_domain_state(*pd_state);\n\n\treturn 0;\n}\n\nstatic int psci_pd_init(struct device_node *np, bool use_osi)\n{\n\tstruct generic_pm_domain *pd;\n\tstruct psci_pd_provider *pd_provider;\n\tstruct dev_power_governor *pd_gov;\n\tint ret = -ENOMEM;\n\n\tpd = dt_idle_pd_alloc(np, psci_dt_parse_state_node);\n\tif (!pd)\n\t\tgoto out;\n\n\tpd_provider = kzalloc(sizeof(*pd_provider), GFP_KERNEL);\n\tif (!pd_provider)\n\t\tgoto free_pd;\n\n\tpd->flags |= GENPD_FLAG_IRQ_SAFE | GENPD_FLAG_CPU_DOMAIN;\n\n\t \n\tif (use_osi && !IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tpd->power_off = psci_pd_power_off;\n\telse\n\t\tpd->flags |= GENPD_FLAG_ALWAYS_ON;\n\n\t \n\tpd_gov = pd->states ? &pm_domain_cpu_gov : NULL;\n\n\tret = pm_genpd_init(pd, pd_gov, false);\n\tif (ret)\n\t\tgoto free_pd_prov;\n\n\tret = of_genpd_add_provider_simple(np, pd);\n\tif (ret)\n\t\tgoto remove_pd;\n\n\tpd_provider->node = of_node_get(np);\n\tlist_add(&pd_provider->link, &psci_pd_providers);\n\n\tpr_debug(\"init PM domain %s\\n\", pd->name);\n\treturn 0;\n\nremove_pd:\n\tpm_genpd_remove(pd);\nfree_pd_prov:\n\tkfree(pd_provider);\nfree_pd:\n\tdt_idle_pd_free(pd);\nout:\n\tpr_err(\"failed to init PM domain ret=%d %pOF\\n\", ret, np);\n\treturn ret;\n}\n\nstatic void psci_pd_remove(void)\n{\n\tstruct psci_pd_provider *pd_provider, *it;\n\tstruct generic_pm_domain *genpd;\n\n\tlist_for_each_entry_safe_reverse(pd_provider, it,\n\t\t\t\t\t &psci_pd_providers, link) {\n\t\tof_genpd_del_provider(pd_provider->node);\n\n\t\tgenpd = of_genpd_remove_last(pd_provider->node);\n\t\tif (!IS_ERR(genpd))\n\t\t\tkfree(genpd);\n\n\t\tof_node_put(pd_provider->node);\n\t\tlist_del(&pd_provider->link);\n\t\tkfree(pd_provider);\n\t}\n}\n\nstatic void psci_cpuidle_domain_sync_state(struct device *dev)\n{\n\t \n\tpsci_pd_allow_domain_state = true;\n}\n\nstatic const struct of_device_id psci_of_match[] = {\n\t{ .compatible = \"arm,psci-1.0\" },\n\t{}\n};\n\nstatic int psci_cpuidle_domain_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *node;\n\tbool use_osi = psci_has_osi_support();\n\tint ret = 0, pd_count = 0;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\t \n\tfor_each_child_of_node(np, node) {\n\t\tif (!of_property_present(node, \"#power-domain-cells\"))\n\t\t\tcontinue;\n\n\t\tret = psci_pd_init(node, use_osi);\n\t\tif (ret) {\n\t\t\tof_node_put(node);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tpd_count++;\n\t}\n\n\t \n\tif (!pd_count)\n\t\treturn 0;\n\n\t \n\tret = dt_idle_pd_init_topology(np);\n\tif (ret)\n\t\tgoto remove_pd;\n\n\t \n\tret = psci_set_osi_mode(use_osi);\n\tif (ret)\n\t\tgoto remove_pd;\n\n\tpr_info(\"Initialized CPU PM domain topology using %s mode\\n\",\n\t\tuse_osi ? \"OSI\" : \"PC\");\n\treturn 0;\n\nremove_pd:\n\tdt_idle_pd_remove_topology(np);\n\tpsci_pd_remove();\nexit:\n\tpr_err(\"failed to create CPU PM domains ret=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic struct platform_driver psci_cpuidle_domain_driver = {\n\t.probe  = psci_cpuidle_domain_probe,\n\t.driver = {\n\t\t.name = \"psci-cpuidle-domain\",\n\t\t.of_match_table = psci_of_match,\n\t\t.sync_state = psci_cpuidle_domain_sync_state,\n\t},\n};\n\nstatic int __init psci_idle_init_domains(void)\n{\n\treturn platform_driver_register(&psci_cpuidle_domain_driver);\n}\nsubsys_initcall(psci_idle_init_domains);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}