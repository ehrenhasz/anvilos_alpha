{
  "module_name": "cpuidle-powernv.c",
  "hash_id": "a7155eee2ff993a43ff852acb9ffed688b57d36270e8b42cac132f636cf444b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/cpuidle-powernv.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/moduleparam.h>\n#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/clockchips.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\n#include <asm/machdep.h>\n#include <asm/firmware.h>\n#include <asm/opal.h>\n#include <asm/runlatch.h>\n#include <asm/cpuidle.h>\n\n \n#define POWERNV_THRESHOLD_LATENCY_NS 200000\n\nstatic struct cpuidle_driver powernv_idle_driver = {\n\t.name             = \"powernv_idle\",\n\t.owner            = THIS_MODULE,\n};\n\nstatic int max_idle_state __read_mostly;\nstatic struct cpuidle_state *cpuidle_state_table __read_mostly;\n\nstruct stop_psscr_table {\n\tu64 val;\n\tu64 mask;\n};\n\nstatic struct stop_psscr_table stop_psscr_table[CPUIDLE_STATE_MAX] __read_mostly;\n\nstatic u64 default_snooze_timeout __read_mostly;\nstatic bool snooze_timeout_en __read_mostly;\n\nstatic u64 get_snooze_timeout(struct cpuidle_device *dev,\n\t\t\t      struct cpuidle_driver *drv,\n\t\t\t      int index)\n{\n\tint i;\n\n\tif (unlikely(!snooze_timeout_en))\n\t\treturn default_snooze_timeout;\n\n\tfor (i = index + 1; i < drv->state_count; i++) {\n\t\tif (dev->states_usage[i].disable)\n\t\t\tcontinue;\n\n\t\treturn drv->states[i].target_residency * tb_ticks_per_usec;\n\t}\n\n\treturn default_snooze_timeout;\n}\n\nstatic int snooze_loop(struct cpuidle_device *dev,\n\t\t\tstruct cpuidle_driver *drv,\n\t\t\tint index)\n{\n\tu64 snooze_exit_time;\n\n\tset_thread_flag(TIF_POLLING_NRFLAG);\n\n\tlocal_irq_enable();\n\n\tsnooze_exit_time = get_tb() + get_snooze_timeout(dev, drv, index);\n\tdev->poll_time_limit = false;\n\tppc64_runlatch_off();\n\tHMT_very_low();\n\twhile (!need_resched()) {\n\t\tif (likely(snooze_timeout_en) && get_tb() > snooze_exit_time) {\n\t\t\t \n\t\t\tclear_thread_flag(TIF_POLLING_NRFLAG);\n\t\t\tdev->poll_time_limit = true;\n\t\t\tsmp_mb();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tHMT_medium();\n\tppc64_runlatch_on();\n\tclear_thread_flag(TIF_POLLING_NRFLAG);\n\n\tlocal_irq_disable();\n\n\treturn index;\n}\n\nstatic int nap_loop(struct cpuidle_device *dev,\n\t\t\tstruct cpuidle_driver *drv,\n\t\t\tint index)\n{\n\tpower7_idle_type(PNV_THREAD_NAP);\n\n\treturn index;\n}\n\n \n#ifdef CONFIG_TICK_ONESHOT\nstatic int fastsleep_loop(struct cpuidle_device *dev,\n\t\t\t\tstruct cpuidle_driver *drv,\n\t\t\t\tint index)\n{\n\tunsigned long old_lpcr = mfspr(SPRN_LPCR);\n\tunsigned long new_lpcr;\n\n\tif (unlikely(system_state < SYSTEM_RUNNING))\n\t\treturn index;\n\n\tnew_lpcr = old_lpcr;\n\t \n\tnew_lpcr &= ~LPCR_PECE1;\n\n\tmtspr(SPRN_LPCR, new_lpcr);\n\n\tpower7_idle_type(PNV_THREAD_SLEEP);\n\n\tmtspr(SPRN_LPCR, old_lpcr);\n\n\treturn index;\n}\n#endif\n\nstatic int stop_loop(struct cpuidle_device *dev,\n\t\t     struct cpuidle_driver *drv,\n\t\t     int index)\n{\n\tarch300_idle_type(stop_psscr_table[index].val,\n\t\t\t stop_psscr_table[index].mask);\n\treturn index;\n}\n\n \nstatic struct cpuidle_state powernv_states[CPUIDLE_STATE_MAX] = {\n\t{  \n\t\t.name = \"snooze\",\n\t\t.desc = \"snooze\",\n\t\t.exit_latency = 0,\n\t\t.target_residency = 0,\n\t\t.enter = snooze_loop,\n\t\t.flags = CPUIDLE_FLAG_POLLING },\n};\n\nstatic int powernv_cpuidle_cpu_online(unsigned int cpu)\n{\n\tstruct cpuidle_device *dev = per_cpu(cpuidle_devices, cpu);\n\n\tif (dev && cpuidle_get_driver()) {\n\t\tcpuidle_pause_and_lock();\n\t\tcpuidle_enable_device(dev);\n\t\tcpuidle_resume_and_unlock();\n\t}\n\treturn 0;\n}\n\nstatic int powernv_cpuidle_cpu_dead(unsigned int cpu)\n{\n\tstruct cpuidle_device *dev = per_cpu(cpuidle_devices, cpu);\n\n\tif (dev && cpuidle_get_driver()) {\n\t\tcpuidle_pause_and_lock();\n\t\tcpuidle_disable_device(dev);\n\t\tcpuidle_resume_and_unlock();\n\t}\n\treturn 0;\n}\n\n \nstatic int powernv_cpuidle_driver_init(void)\n{\n\tint idle_state;\n\tstruct cpuidle_driver *drv = &powernv_idle_driver;\n\n\tdrv->state_count = 0;\n\n\tfor (idle_state = 0; idle_state < max_idle_state; ++idle_state) {\n\t\t \n\t\tif (cpuidle_state_table[idle_state].enter == NULL)\n\t\t\tcontinue;\n\n\t\tdrv->states[drv->state_count] =\t \n\t\t\tcpuidle_state_table[idle_state];\n\n\t\tdrv->state_count += 1;\n\t}\n\n\t \n\n\tdrv->cpumask = (struct cpumask *)cpu_present_mask;\n\n\treturn 0;\n}\n\nstatic inline void add_powernv_state(int index, const char *name,\n\t\t\t\t     unsigned int flags,\n\t\t\t\t     int (*idle_fn)(struct cpuidle_device *,\n\t\t\t\t\t\t    struct cpuidle_driver *,\n\t\t\t\t\t\t    int),\n\t\t\t\t     unsigned int target_residency,\n\t\t\t\t     unsigned int exit_latency,\n\t\t\t\t     u64 psscr_val, u64 psscr_mask)\n{\n\tstrscpy(powernv_states[index].name, name, CPUIDLE_NAME_LEN);\n\tstrscpy(powernv_states[index].desc, name, CPUIDLE_NAME_LEN);\n\tpowernv_states[index].flags = flags;\n\tpowernv_states[index].target_residency = target_residency;\n\tpowernv_states[index].exit_latency = exit_latency;\n\tpowernv_states[index].enter = idle_fn;\n\t \n\tstop_psscr_table[index].val = psscr_val;\n\tstop_psscr_table[index].mask = psscr_mask;\n}\n\nextern u32 pnv_get_supported_cpuidle_states(void);\nstatic int powernv_add_idle_states(void)\n{\n\tint nr_idle_states = 1;  \n\tint dt_idle_states;\n\tu32 has_stop_states = 0;\n\tint i;\n\tu32 supported_flags = pnv_get_supported_cpuidle_states();\n\n\n\t \n\tif (nr_pnv_idle_states <= 0) {\n\t\tpr_warn(\"cpuidle-powernv : Only Snooze is available\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tdt_idle_states = nr_pnv_idle_states;\n\n\t \n\tif (nr_pnv_idle_states > CPUIDLE_STATE_MAX - 1) {\n\t\tpr_warn(\"cpuidle-powernv: discovered idle states more than allowed\");\n\t\tdt_idle_states = CPUIDLE_STATE_MAX - 1;\n\t}\n\n\t \n\thas_stop_states = (pnv_idle_states[0].flags &\n\t\t\t   (OPAL_PM_STOP_INST_FAST | OPAL_PM_STOP_INST_DEEP));\n\n\tfor (i = 0; i < dt_idle_states; i++) {\n\t\tunsigned int exit_latency, target_residency;\n\t\tbool stops_timebase = false;\n\t\tstruct pnv_idle_states_t *state = &pnv_idle_states[i];\n\n\t\t \n\t\tif ((state->flags & supported_flags) != state->flags)\n\t\t\tcontinue;\n\t\t \n\t\tif (state->latency_ns > POWERNV_THRESHOLD_LATENCY_NS)\n\t\t\tcontinue;\n\t\t \n\t\texit_latency = DIV_ROUND_UP(state->latency_ns, 1000);\n\t\ttarget_residency = DIV_ROUND_UP(state->residency_ns, 1000);\n\n\t\tif (has_stop_states && !(state->valid))\n\t\t\t\tcontinue;\n\n\t\tif (state->flags & OPAL_PM_TIMEBASE_STOP)\n\t\t\tstops_timebase = true;\n\n\t\tif (state->flags & OPAL_PM_NAP_ENABLED) {\n\t\t\t \n\t\t\tadd_powernv_state(nr_idle_states, \"Nap\",\n\t\t\t\t\t  CPUIDLE_FLAG_NONE, nap_loop,\n\t\t\t\t\t  target_residency, exit_latency, 0, 0);\n\t\t} else if (has_stop_states && !stops_timebase) {\n\t\t\tadd_powernv_state(nr_idle_states, state->name,\n\t\t\t\t\t  CPUIDLE_FLAG_NONE, stop_loop,\n\t\t\t\t\t  target_residency, exit_latency,\n\t\t\t\t\t  state->psscr_val,\n\t\t\t\t\t  state->psscr_mask);\n\t\t}\n\n\t\t \n#ifdef CONFIG_TICK_ONESHOT\n\t\telse if (state->flags & OPAL_PM_SLEEP_ENABLED ||\n\t\t\t state->flags & OPAL_PM_SLEEP_ENABLED_ER1) {\n\t\t\t \n\t\t\tadd_powernv_state(nr_idle_states, \"FastSleep\",\n\t\t\t\t\t  CPUIDLE_FLAG_TIMER_STOP,\n\t\t\t\t\t  fastsleep_loop,\n\t\t\t\t\t  target_residency, exit_latency, 0, 0);\n\t\t} else if (has_stop_states && stops_timebase) {\n\t\t\tadd_powernv_state(nr_idle_states, state->name,\n\t\t\t\t\t  CPUIDLE_FLAG_TIMER_STOP, stop_loop,\n\t\t\t\t\t  target_residency, exit_latency,\n\t\t\t\t\t  state->psscr_val,\n\t\t\t\t\t  state->psscr_mask);\n\t\t}\n#endif\n\t\telse\n\t\t\tcontinue;\n\t\tnr_idle_states++;\n\t}\nout:\n\treturn nr_idle_states;\n}\n\n \nstatic int powernv_idle_probe(void)\n{\n\tif (cpuidle_disable != IDLE_NO_OVERRIDE)\n\t\treturn -ENODEV;\n\n\tif (firmware_has_feature(FW_FEATURE_OPAL)) {\n\t\tcpuidle_state_table = powernv_states;\n\t\t \n\t\tmax_idle_state = powernv_add_idle_states();\n\t\tdefault_snooze_timeout = TICK_USEC * tb_ticks_per_usec;\n\t\tif (max_idle_state > 1)\n\t\t\tsnooze_timeout_en = true;\n \t} else\n \t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int __init powernv_processor_idle_init(void)\n{\n\tint retval;\n\n\tretval = powernv_idle_probe();\n\tif (retval)\n\t\treturn retval;\n\n\tpowernv_cpuidle_driver_init();\n\tretval = cpuidle_register(&powernv_idle_driver, NULL);\n\tif (retval) {\n\t\tprintk(KERN_DEBUG \"Registration of powernv driver failed.\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t   \"cpuidle/powernv:online\",\n\t\t\t\t\t   powernv_cpuidle_cpu_online, NULL);\n\tWARN_ON(retval < 0);\n\tretval = cpuhp_setup_state_nocalls(CPUHP_CPUIDLE_DEAD,\n\t\t\t\t\t   \"cpuidle/powernv:dead\", NULL,\n\t\t\t\t\t   powernv_cpuidle_cpu_dead);\n\tWARN_ON(retval < 0);\n\tprintk(KERN_DEBUG \"powernv_idle_driver registered\\n\");\n\treturn 0;\n}\n\ndevice_initcall(powernv_processor_idle_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}