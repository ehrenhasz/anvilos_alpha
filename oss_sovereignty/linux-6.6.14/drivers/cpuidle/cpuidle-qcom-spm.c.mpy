{
  "module_name": "cpuidle-qcom-spm.c",
  "hash_id": "be304a672cac71d625f4ef7a5294d8489aa9b1bae917fd6499ffd5ec0e07b0f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/cpuidle-qcom-spm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/cpuidle.h>\n#include <linux/cpu_pm.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n#include <soc/qcom/spm.h>\n\n#include <asm/proc-fns.h>\n#include <asm/suspend.h>\n\n#include \"dt_idle_states.h\"\n\nstruct cpuidle_qcom_spm_data {\n\tstruct cpuidle_driver cpuidle_driver;\n\tstruct spm_driver_data *spm;\n};\n\nstatic int qcom_pm_collapse(unsigned long int unused)\n{\n\tqcom_scm_cpu_power_down(QCOM_SCM_CPU_PWR_DOWN_L2_ON);\n\n\t \n\treturn -1;\n}\n\nstatic int qcom_cpu_spc(struct spm_driver_data *drv)\n{\n\tint ret;\n\n\tspm_set_low_power_mode(drv, PM_SLEEP_MODE_SPC);\n\tret = cpu_suspend(0, qcom_pm_collapse);\n\t \n\tspm_set_low_power_mode(drv, PM_SLEEP_MODE_STBY);\n\n\treturn ret;\n}\n\nstatic __cpuidle int spm_enter_idle_state(struct cpuidle_device *dev,\n\t\t\t\t\t  struct cpuidle_driver *drv, int idx)\n{\n\tstruct cpuidle_qcom_spm_data *data = container_of(drv, struct cpuidle_qcom_spm_data,\n\t\t\t\t\t\t\t  cpuidle_driver);\n\n\treturn CPU_PM_CPU_IDLE_ENTER_PARAM(qcom_cpu_spc, idx, data->spm);\n}\n\nstatic struct cpuidle_driver qcom_spm_idle_driver = {\n\t.name = \"qcom_spm\",\n\t.owner = THIS_MODULE,\n\t.states[0] = {\n\t\t.enter\t\t\t= spm_enter_idle_state,\n\t\t.exit_latency\t\t= 1,\n\t\t.target_residency\t= 1,\n\t\t.power_usage\t\t= UINT_MAX,\n\t\t.name\t\t\t= \"WFI\",\n\t\t.desc\t\t\t= \"ARM WFI\",\n\t}\n};\n\nstatic const struct of_device_id qcom_idle_state_match[] = {\n\t{ .compatible = \"qcom,idle-state-spc\", .data = spm_enter_idle_state },\n\t{ },\n};\n\nstatic int spm_cpuidle_register(struct device *cpuidle_dev, int cpu)\n{\n\tstruct platform_device *pdev = NULL;\n\tstruct device_node *cpu_node, *saw_node;\n\tstruct cpuidle_qcom_spm_data *data = NULL;\n\tint ret;\n\n\tcpu_node = of_cpu_device_node_get(cpu);\n\tif (!cpu_node)\n\t\treturn -ENODEV;\n\n\tsaw_node = of_parse_phandle(cpu_node, \"qcom,saw\", 0);\n\tif (!saw_node)\n\t\treturn -ENODEV;\n\n\tpdev = of_find_device_by_node(saw_node);\n\tof_node_put(saw_node);\n\tof_node_put(cpu_node);\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(cpuidle_dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->spm = dev_get_drvdata(&pdev->dev);\n\tif (!data->spm)\n\t\treturn -EINVAL;\n\n\tdata->cpuidle_driver = qcom_spm_idle_driver;\n\tdata->cpuidle_driver.cpumask = (struct cpumask *)cpumask_of(cpu);\n\n\tret = dt_init_idle_driver(&data->cpuidle_driver,\n\t\t\t\t  qcom_idle_state_match, 1);\n\tif (ret <= 0)\n\t\treturn ret ? : -ENODEV;\n\n\treturn cpuidle_register(&data->cpuidle_driver, NULL);\n}\n\nstatic int spm_cpuidle_drv_probe(struct platform_device *pdev)\n{\n\tint cpu, ret;\n\n\tif (!qcom_scm_is_available())\n\t\treturn -EPROBE_DEFER;\n\n\tret = qcom_scm_set_warm_boot_addr(cpu_resume_arm);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"set warm boot addr failed\");\n\n\tfor_each_possible_cpu(cpu) {\n\t\tret = spm_cpuidle_register(&pdev->dev, cpu);\n\t\tif (ret && ret != -ENODEV) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Cannot register for CPU%d: %d\\n\", cpu, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver spm_cpuidle_driver = {\n\t.probe = spm_cpuidle_drv_probe,\n\t.driver = {\n\t\t.name = \"qcom-spm-cpuidle\",\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\nstatic bool __init qcom_spm_find_any_cpu(void)\n{\n\tstruct device_node *cpu_node, *saw_node;\n\n\tfor_each_of_cpu_node(cpu_node) {\n\t\tsaw_node = of_parse_phandle(cpu_node, \"qcom,saw\", 0);\n\t\tif (of_device_is_available(saw_node)) {\n\t\t\tof_node_put(saw_node);\n\t\t\tof_node_put(cpu_node);\n\t\t\treturn true;\n\t\t}\n\t\tof_node_put(saw_node);\n\t}\n\treturn false;\n}\n\nstatic int __init qcom_spm_cpuidle_init(void)\n{\n\tstruct platform_device *pdev;\n\tint ret;\n\n\tret = platform_driver_register(&spm_cpuidle_driver);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!qcom_spm_find_any_cpu())\n\t\treturn 0;\n\n\tpdev = platform_device_register_simple(\"qcom-spm-cpuidle\",\n\t\t\t\t\t       -1, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\tplatform_driver_unregister(&spm_cpuidle_driver);\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\treturn 0;\n}\ndevice_initcall(qcom_spm_cpuidle_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}