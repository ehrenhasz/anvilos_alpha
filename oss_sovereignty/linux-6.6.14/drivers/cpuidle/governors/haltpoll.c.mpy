{
  "module_name": "haltpoll.c",
  "hash_id": "4243f41c79ddc05238d1d2c3dd504783c5b44c588a43dfb0333f06478361b934",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/governors/haltpoll.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/cpuidle.h>\n#include <linux/time.h>\n#include <linux/ktime.h>\n#include <linux/hrtimer.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kvm_para.h>\n#include <trace/events/power.h>\n\nstatic unsigned int guest_halt_poll_ns __read_mostly = 200000;\nmodule_param(guest_halt_poll_ns, uint, 0644);\n\n \nstatic unsigned int guest_halt_poll_shrink __read_mostly = 2;\nmodule_param(guest_halt_poll_shrink, uint, 0644);\n\n \nstatic unsigned int guest_halt_poll_grow __read_mostly = 2;\nmodule_param(guest_halt_poll_grow, uint, 0644);\n\n \nstatic unsigned int guest_halt_poll_grow_start __read_mostly = 50000;\nmodule_param(guest_halt_poll_grow_start, uint, 0644);\n\n \nstatic bool guest_halt_poll_allow_shrink __read_mostly = true;\nmodule_param(guest_halt_poll_allow_shrink, bool, 0644);\n\n \nstatic int haltpoll_select(struct cpuidle_driver *drv,\n\t\t\t   struct cpuidle_device *dev,\n\t\t\t   bool *stop_tick)\n{\n\ts64 latency_req = cpuidle_governor_latency_req(dev->cpu);\n\n\tif (!drv->state_count || latency_req == 0) {\n\t\t*stop_tick = false;\n\t\treturn 0;\n\t}\n\n\tif (dev->poll_limit_ns == 0)\n\t\treturn 1;\n\n\t \n\tif (dev->last_state_idx == 0) {\n\t\t \n\t\tif (dev->poll_time_limit == true)\n\t\t\treturn 1;\n\n\t\t*stop_tick = false;\n\t\t \n\t\treturn 0;\n\t}\n\n\t*stop_tick = false;\n\t \n\treturn 0;\n}\n\nstatic void adjust_poll_limit(struct cpuidle_device *dev, u64 block_ns)\n{\n\tunsigned int val;\n\n\t \n\tif (block_ns > dev->poll_limit_ns && block_ns <= guest_halt_poll_ns) {\n\t\tval = dev->poll_limit_ns * guest_halt_poll_grow;\n\n\t\tif (val < guest_halt_poll_grow_start)\n\t\t\tval = guest_halt_poll_grow_start;\n\t\tif (val > guest_halt_poll_ns)\n\t\t\tval = guest_halt_poll_ns;\n\n\t\ttrace_guest_halt_poll_ns_grow(val, dev->poll_limit_ns);\n\t\tdev->poll_limit_ns = val;\n\t} else if (block_ns > guest_halt_poll_ns &&\n\t\t   guest_halt_poll_allow_shrink) {\n\t\tunsigned int shrink = guest_halt_poll_shrink;\n\n\t\tval = dev->poll_limit_ns;\n\t\tif (shrink == 0)\n\t\t\tval = 0;\n\t\telse\n\t\t\tval /= shrink;\n\t\ttrace_guest_halt_poll_ns_shrink(val, dev->poll_limit_ns);\n\t\tdev->poll_limit_ns = val;\n\t}\n}\n\n \nstatic void haltpoll_reflect(struct cpuidle_device *dev, int index)\n{\n\tdev->last_state_idx = index;\n\n\tif (index != 0)\n\t\tadjust_poll_limit(dev, dev->last_residency_ns);\n}\n\n \nstatic int haltpoll_enable_device(struct cpuidle_driver *drv,\n\t\t\t\t  struct cpuidle_device *dev)\n{\n\tdev->poll_limit_ns = 0;\n\n\treturn 0;\n}\n\nstatic struct cpuidle_governor haltpoll_governor = {\n\t.name =\t\t\t\"haltpoll\",\n\t.rating =\t\t9,\n\t.enable =\t\thaltpoll_enable_device,\n\t.select =\t\thaltpoll_select,\n\t.reflect =\t\thaltpoll_reflect,\n};\n\nstatic int __init init_haltpoll(void)\n{\n\tif (kvm_para_available())\n\t\treturn cpuidle_register_governor(&haltpoll_governor);\n\n\treturn 0;\n}\n\npostcore_initcall(init_haltpoll);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}