{
  "module_name": "ladder.c",
  "hash_id": "767f67cec7623e29391be11fc79aee0f1fc0a731a9ace67487398ebdbe1876f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/governors/ladder.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/cpuidle.h>\n#include <linux/jiffies.h>\n#include <linux/tick.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#define PROMOTION_COUNT 4\n#define DEMOTION_COUNT 1\n\nstruct ladder_device_state {\n\tstruct {\n\t\tu32 promotion_count;\n\t\tu32 demotion_count;\n\t\tu64 promotion_time_ns;\n\t\tu64 demotion_time_ns;\n\t} threshold;\n\tstruct {\n\t\tint promotion_count;\n\t\tint demotion_count;\n\t} stats;\n};\n\nstruct ladder_device {\n\tstruct ladder_device_state states[CPUIDLE_STATE_MAX];\n};\n\nstatic DEFINE_PER_CPU(struct ladder_device, ladder_devices);\n\n \nstatic inline void ladder_do_selection(struct cpuidle_device *dev,\n\t\t\t\t       struct ladder_device *ldev,\n\t\t\t\t       int old_idx, int new_idx)\n{\n\tldev->states[old_idx].stats.promotion_count = 0;\n\tldev->states[old_idx].stats.demotion_count = 0;\n\tdev->last_state_idx = new_idx;\n}\n\n \nstatic int ladder_select_state(struct cpuidle_driver *drv,\n\t\t\t       struct cpuidle_device *dev, bool *dummy)\n{\n\tstruct ladder_device *ldev = this_cpu_ptr(&ladder_devices);\n\tstruct ladder_device_state *last_state;\n\tint last_idx = dev->last_state_idx;\n\tint first_idx = drv->states[0].flags & CPUIDLE_FLAG_POLLING ? 1 : 0;\n\ts64 latency_req = cpuidle_governor_latency_req(dev->cpu);\n\ts64 last_residency;\n\n\t \n\tif (unlikely(latency_req == 0)) {\n\t\tladder_do_selection(dev, ldev, last_idx, 0);\n\t\treturn 0;\n\t}\n\n\tlast_state = &ldev->states[last_idx];\n\n\tlast_residency = dev->last_residency_ns - drv->states[last_idx].exit_latency_ns;\n\n\t \n\tif (last_idx < drv->state_count - 1 &&\n\t    !dev->states_usage[last_idx + 1].disable &&\n\t    last_residency > last_state->threshold.promotion_time_ns &&\n\t    drv->states[last_idx + 1].exit_latency_ns <= latency_req) {\n\t\tlast_state->stats.promotion_count++;\n\t\tlast_state->stats.demotion_count = 0;\n\t\tif (last_state->stats.promotion_count >= last_state->threshold.promotion_count) {\n\t\t\tladder_do_selection(dev, ldev, last_idx, last_idx + 1);\n\t\t\treturn last_idx + 1;\n\t\t}\n\t}\n\n\t \n\tif (last_idx > first_idx &&\n\t    (dev->states_usage[last_idx].disable ||\n\t    drv->states[last_idx].exit_latency_ns > latency_req)) {\n\t\tint i;\n\n\t\tfor (i = last_idx - 1; i > first_idx; i--) {\n\t\t\tif (drv->states[i].exit_latency_ns <= latency_req)\n\t\t\t\tbreak;\n\t\t}\n\t\tladder_do_selection(dev, ldev, last_idx, i);\n\t\treturn i;\n\t}\n\n\tif (last_idx > first_idx &&\n\t    last_residency < last_state->threshold.demotion_time_ns) {\n\t\tlast_state->stats.demotion_count++;\n\t\tlast_state->stats.promotion_count = 0;\n\t\tif (last_state->stats.demotion_count >= last_state->threshold.demotion_count) {\n\t\t\tladder_do_selection(dev, ldev, last_idx, last_idx - 1);\n\t\t\treturn last_idx - 1;\n\t\t}\n\t}\n\n\t \n\treturn last_idx;\n}\n\n \nstatic int ladder_enable_device(struct cpuidle_driver *drv,\n\t\t\t\tstruct cpuidle_device *dev)\n{\n\tint i;\n\tint first_idx = drv->states[0].flags & CPUIDLE_FLAG_POLLING ? 1 : 0;\n\tstruct ladder_device *ldev = &per_cpu(ladder_devices, dev->cpu);\n\tstruct ladder_device_state *lstate;\n\tstruct cpuidle_state *state;\n\n\tdev->last_state_idx = first_idx;\n\n\tfor (i = first_idx; i < drv->state_count; i++) {\n\t\tstate = &drv->states[i];\n\t\tlstate = &ldev->states[i];\n\n\t\tlstate->stats.promotion_count = 0;\n\t\tlstate->stats.demotion_count = 0;\n\n\t\tlstate->threshold.promotion_count = PROMOTION_COUNT;\n\t\tlstate->threshold.demotion_count = DEMOTION_COUNT;\n\n\t\tif (i < drv->state_count - 1)\n\t\t\tlstate->threshold.promotion_time_ns = state->exit_latency_ns;\n\t\tif (i > first_idx)\n\t\t\tlstate->threshold.demotion_time_ns = state->exit_latency_ns;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ladder_reflect(struct cpuidle_device *dev, int index)\n{\n\tif (index > 0)\n\t\tdev->last_state_idx = index;\n}\n\nstatic struct cpuidle_governor ladder_governor = {\n\t.name =\t\t\"ladder\",\n\t.rating =\t10,\n\t.enable =\tladder_enable_device,\n\t.select =\tladder_select_state,\n\t.reflect =\tladder_reflect,\n};\n\n \nstatic int __init init_ladder(void)\n{\n\t \n\tif (!tick_nohz_enabled)\n\t\tladder_governor.rating = 25;\n\n\treturn cpuidle_register_governor(&ladder_governor);\n}\n\npostcore_initcall(init_ladder);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}