{
  "module_name": "teo.c",
  "hash_id": "6194c3da4dad02847e785142f94b79775764f4839ae1eaaeb999173cc763923f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/governors/teo.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/cpuidle.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/topology.h>\n#include <linux/tick.h>\n\n#include \"gov.h\"\n\n \n#define UTIL_THRESHOLD_SHIFT 6\n\n \n#define PULSE\t\t1024\n#define DECAY_SHIFT\t3\n\n \n#define NR_RECENT\t9\n\n \nstruct teo_bin {\n\tunsigned int intercepts;\n\tunsigned int hits;\n\tunsigned int recent;\n};\n\n \nstruct teo_cpu {\n\ts64 time_span_ns;\n\ts64 sleep_length_ns;\n\tstruct teo_bin state_bins[CPUIDLE_STATE_MAX];\n\tunsigned int total;\n\tint next_recent_idx;\n\tint recent_idx[NR_RECENT];\n\tunsigned int tick_hits;\n\tunsigned long util_threshold;\n};\n\nstatic DEFINE_PER_CPU(struct teo_cpu, teo_cpus);\n\n \n#ifdef CONFIG_SMP\nstatic bool teo_cpu_is_utilized(int cpu, struct teo_cpu *cpu_data)\n{\n\treturn sched_cpu_util(cpu) > cpu_data->util_threshold;\n}\n#else\nstatic bool teo_cpu_is_utilized(int cpu, struct teo_cpu *cpu_data)\n{\n\treturn false;\n}\n#endif\n\n \nstatic void teo_update(struct cpuidle_driver *drv, struct cpuidle_device *dev)\n{\n\tstruct teo_cpu *cpu_data = per_cpu_ptr(&teo_cpus, dev->cpu);\n\tint i, idx_timer = 0, idx_duration = 0;\n\ts64 target_residency_ns;\n\tu64 measured_ns;\n\n\tif (cpu_data->time_span_ns >= cpu_data->sleep_length_ns) {\n\t\t \n\t\tmeasured_ns = U64_MAX;\n\t} else {\n\t\tu64 lat_ns = drv->states[dev->last_state_idx].exit_latency_ns;\n\n\t\t \n\t\tmeasured_ns = dev->last_residency_ns;\n\t\t \n\t\tif (measured_ns >= lat_ns)\n\t\t\tmeasured_ns -= lat_ns / 2;\n\t\telse\n\t\t\tmeasured_ns /= 2;\n\t}\n\n\tcpu_data->total = 0;\n\n\t \n\tfor (i = 0; i < drv->state_count; i++) {\n\t\tstruct teo_bin *bin = &cpu_data->state_bins[i];\n\n\t\tbin->hits -= bin->hits >> DECAY_SHIFT;\n\t\tbin->intercepts -= bin->intercepts >> DECAY_SHIFT;\n\n\t\tcpu_data->total += bin->hits + bin->intercepts;\n\n\t\ttarget_residency_ns = drv->states[i].target_residency_ns;\n\n\t\tif (target_residency_ns <= cpu_data->sleep_length_ns) {\n\t\t\tidx_timer = i;\n\t\t\tif (target_residency_ns <= measured_ns)\n\t\t\t\tidx_duration = i;\n\t\t}\n\t}\n\n\ti = cpu_data->next_recent_idx++;\n\tif (cpu_data->next_recent_idx >= NR_RECENT)\n\t\tcpu_data->next_recent_idx = 0;\n\n\tif (cpu_data->recent_idx[i] >= 0)\n\t\tcpu_data->state_bins[cpu_data->recent_idx[i]].recent--;\n\n\t \n\tif (target_residency_ns < TICK_NSEC) {\n\t\tcpu_data->tick_hits -= cpu_data->tick_hits >> DECAY_SHIFT;\n\n\t\tcpu_data->total += cpu_data->tick_hits;\n\n\t\tif (TICK_NSEC <= cpu_data->sleep_length_ns) {\n\t\t\tidx_timer = drv->state_count;\n\t\t\tif (TICK_NSEC <= measured_ns) {\n\t\t\t\tcpu_data->tick_hits += PULSE;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (idx_timer == idx_duration) {\n\t\tcpu_data->state_bins[idx_timer].hits += PULSE;\n\t\tcpu_data->recent_idx[i] = -1;\n\t} else {\n\t\tcpu_data->state_bins[idx_duration].intercepts += PULSE;\n\t\tcpu_data->state_bins[idx_duration].recent++;\n\t\tcpu_data->recent_idx[i] = idx_duration;\n\t}\n\nend:\n\tcpu_data->total += PULSE;\n}\n\nstatic bool teo_state_ok(int i, struct cpuidle_driver *drv)\n{\n\treturn !tick_nohz_tick_stopped() ||\n\t\tdrv->states[i].target_residency_ns >= TICK_NSEC;\n}\n\n \nstatic int teo_find_shallower_state(struct cpuidle_driver *drv,\n\t\t\t\t    struct cpuidle_device *dev, int state_idx,\n\t\t\t\t    s64 duration_ns, bool no_poll)\n{\n\tint i;\n\n\tfor (i = state_idx - 1; i >= 0; i--) {\n\t\tif (dev->states_usage[i].disable ||\n\t\t\t\t(no_poll && drv->states[i].flags & CPUIDLE_FLAG_POLLING))\n\t\t\tcontinue;\n\n\t\tstate_idx = i;\n\t\tif (drv->states[i].target_residency_ns <= duration_ns)\n\t\t\tbreak;\n\t}\n\treturn state_idx;\n}\n\n \nstatic int teo_select(struct cpuidle_driver *drv, struct cpuidle_device *dev,\n\t\t      bool *stop_tick)\n{\n\tstruct teo_cpu *cpu_data = per_cpu_ptr(&teo_cpus, dev->cpu);\n\ts64 latency_req = cpuidle_governor_latency_req(dev->cpu);\n\tktime_t delta_tick = TICK_NSEC / 2;\n\tunsigned int tick_intercept_sum = 0;\n\tunsigned int idx_intercept_sum = 0;\n\tunsigned int intercept_sum = 0;\n\tunsigned int idx_recent_sum = 0;\n\tunsigned int recent_sum = 0;\n\tunsigned int idx_hit_sum = 0;\n\tunsigned int hit_sum = 0;\n\tint constraint_idx = 0;\n\tint idx0 = 0, idx = -1;\n\tbool alt_intercepts, alt_recent;\n\tbool cpu_utilized;\n\ts64 duration_ns;\n\tint i;\n\n\tif (dev->last_state_idx >= 0) {\n\t\tteo_update(drv, dev);\n\t\tdev->last_state_idx = -1;\n\t}\n\n\tcpu_data->time_span_ns = local_clock();\n\t \n\tcpu_data->sleep_length_ns = KTIME_MAX;\n\n\t \n\tif (drv->state_count < 2) {\n\t\tidx = 0;\n\t\tgoto out_tick;\n\t}\n\n\tif (!dev->states_usage[0].disable)\n\t\tidx = 0;\n\n\tcpu_utilized = teo_cpu_is_utilized(dev->cpu, cpu_data);\n\t \n\tif (drv->state_count < 3 && cpu_utilized) {\n\t\t \n\t\tif ((!idx && !(drv->states[0].flags & CPUIDLE_FLAG_POLLING) &&\n\t\t    teo_state_ok(0, drv)) || dev->states_usage[1].disable) {\n\t\t\tidx = 0;\n\t\t\tgoto out_tick;\n\t\t}\n\t\t \n\t\tidx = 1;\n\t\tduration_ns = drv->states[1].target_residency_ns;\n\t\tgoto end;\n\t}\n\n\t \n\tfor (i = 1; i < drv->state_count; i++) {\n\t\tstruct teo_bin *prev_bin = &cpu_data->state_bins[i-1];\n\t\tstruct cpuidle_state *s = &drv->states[i];\n\n\t\t \n\t\tintercept_sum += prev_bin->intercepts;\n\t\thit_sum += prev_bin->hits;\n\t\trecent_sum += prev_bin->recent;\n\n\t\tif (dev->states_usage[i].disable)\n\t\t\tcontinue;\n\n\t\tif (idx < 0)\n\t\t\tidx0 = i;  \n\n\t\tidx = i;\n\n\t\tif (s->exit_latency_ns <= latency_req)\n\t\t\tconstraint_idx = i;\n\n\t\t \n\t\tidx_intercept_sum = intercept_sum;\n\t\tidx_hit_sum = hit_sum;\n\t\tidx_recent_sum = recent_sum;\n\t}\n\n\t \n\tif (idx < 0) {\n\t\tidx = 0;  \n\t\tgoto out_tick;\n\t}\n\n\tif (idx == idx0) {\n\t\t \n\t\tduration_ns = drv->states[idx].target_residency_ns;\n\t\tgoto end;\n\t}\n\n\ttick_intercept_sum = intercept_sum +\n\t\t\tcpu_data->state_bins[drv->state_count-1].intercepts;\n\n\t \n\talt_intercepts = 2 * idx_intercept_sum > cpu_data->total - idx_hit_sum;\n\talt_recent = idx_recent_sum > NR_RECENT / 2;\n\tif (alt_recent || alt_intercepts) {\n\t\tint first_suitable_idx = idx;\n\n\t\t \n\t\tintercept_sum = 0;\n\t\trecent_sum = 0;\n\n\t\tfor (i = idx - 1; i >= 0; i--) {\n\t\t\tstruct teo_bin *bin = &cpu_data->state_bins[i];\n\n\t\t\tintercept_sum += bin->intercepts;\n\t\t\trecent_sum += bin->recent;\n\n\t\t\tif ((!alt_recent || 2 * recent_sum > idx_recent_sum) &&\n\t\t\t    (!alt_intercepts ||\n\t\t\t     2 * intercept_sum > idx_intercept_sum)) {\n\t\t\t\t \n\t\t\t\tif (teo_state_ok(i, drv) &&\n\t\t\t\t    !dev->states_usage[i].disable)\n\t\t\t\t\tidx = i;\n\t\t\t\telse\n\t\t\t\t\tidx = first_suitable_idx;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (dev->states_usage[i].disable)\n\t\t\t\tcontinue;\n\n\t\t\tif (!teo_state_ok(i, drv)) {\n\t\t\t\t \n\t\t\t\tif (first_suitable_idx != idx)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfirst_suitable_idx = i;\n\t\t}\n\t}\n\n\t \n\tif (idx > constraint_idx)\n\t\tidx = constraint_idx;\n\n\t \n\tif (cpu_utilized) {\n\t\ti = teo_find_shallower_state(drv, dev, idx, KTIME_MAX, true);\n\t\tif (teo_state_ok(i, drv))\n\t\t\tidx = i;\n\t}\n\n\t \n\tif (!idx)\n\t\tgoto out_tick;\n\n\t \n\tif ((drv->states[0].flags & CPUIDLE_FLAG_POLLING) &&\n\t    drv->states[idx].target_residency_ns < RESIDENCY_THRESHOLD_NS)\n\t\tgoto out_tick;\n\n\tduration_ns = tick_nohz_get_sleep_length(&delta_tick);\n\tcpu_data->sleep_length_ns = duration_ns;\n\n\t \n\tif (drv->states[idx].target_residency_ns > duration_ns) {\n\t\ti = teo_find_shallower_state(drv, dev, idx, duration_ns, false);\n\t\tif (teo_state_ok(i, drv))\n\t\t\tidx = i;\n\t}\n\n\t \n\tif (drv->states[idx].target_residency_ns < TICK_NSEC &&\n\t    tick_intercept_sum > cpu_data->total / 2 + cpu_data->total / 8)\n\t\tduration_ns = TICK_NSEC / 2;\n\nend:\n\t \n\tif ((!(drv->states[idx].flags & CPUIDLE_FLAG_POLLING) &&\n\t    duration_ns >= TICK_NSEC) || tick_nohz_tick_stopped())\n\t\treturn idx;\n\n\t \n\tif (idx > idx0 &&\n\t    drv->states[idx].target_residency_ns > delta_tick)\n\t\tidx = teo_find_shallower_state(drv, dev, idx, delta_tick, false);\n\nout_tick:\n\t*stop_tick = false;\n\treturn idx;\n}\n\n \nstatic void teo_reflect(struct cpuidle_device *dev, int state)\n{\n\tstruct teo_cpu *cpu_data = per_cpu_ptr(&teo_cpus, dev->cpu);\n\n\tdev->last_state_idx = state;\n\t \n\tif (dev->poll_time_limit ||\n\t    (tick_nohz_idle_got_tick() && cpu_data->sleep_length_ns > TICK_NSEC)) {\n\t\tdev->poll_time_limit = false;\n\t\tcpu_data->time_span_ns = cpu_data->sleep_length_ns;\n\t} else {\n\t\tcpu_data->time_span_ns = local_clock() - cpu_data->time_span_ns;\n\t}\n}\n\n \nstatic int teo_enable_device(struct cpuidle_driver *drv,\n\t\t\t     struct cpuidle_device *dev)\n{\n\tstruct teo_cpu *cpu_data = per_cpu_ptr(&teo_cpus, dev->cpu);\n\tunsigned long max_capacity = arch_scale_cpu_capacity(dev->cpu);\n\tint i;\n\n\tmemset(cpu_data, 0, sizeof(*cpu_data));\n\tcpu_data->util_threshold = max_capacity >> UTIL_THRESHOLD_SHIFT;\n\n\tfor (i = 0; i < NR_RECENT; i++)\n\t\tcpu_data->recent_idx[i] = -1;\n\n\treturn 0;\n}\n\nstatic struct cpuidle_governor teo_governor = {\n\t.name =\t\t\"teo\",\n\t.rating =\t19,\n\t.enable =\tteo_enable_device,\n\t.select =\tteo_select,\n\t.reflect =\tteo_reflect,\n};\n\nstatic int __init teo_governor_init(void)\n{\n\treturn cpuidle_register_governor(&teo_governor);\n}\n\npostcore_initcall(teo_governor_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}