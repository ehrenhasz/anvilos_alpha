{
  "module_name": "menu.c",
  "hash_id": "9f142b72af8ff66cac9926e2fc600470f69a4ec29f72c16ceeba262a38914323",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/governors/menu.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/cpuidle.h>\n#include <linux/time.h>\n#include <linux/ktime.h>\n#include <linux/hrtimer.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/stat.h>\n#include <linux/math64.h>\n\n#include \"gov.h\"\n\n#define BUCKETS 12\n#define INTERVAL_SHIFT 3\n#define INTERVALS (1UL << INTERVAL_SHIFT)\n#define RESOLUTION 1024\n#define DECAY 8\n#define MAX_INTERESTING (50000 * NSEC_PER_USEC)\n\n \n\nstruct menu_device {\n\tint             needs_update;\n\tint             tick_wakeup;\n\n\tu64\t\tnext_timer_ns;\n\tunsigned int\tbucket;\n\tunsigned int\tcorrection_factor[BUCKETS];\n\tunsigned int\tintervals[INTERVALS];\n\tint\t\tinterval_ptr;\n};\n\nstatic inline int which_bucket(u64 duration_ns, unsigned int nr_iowaiters)\n{\n\tint bucket = 0;\n\n\t \n\tif (nr_iowaiters)\n\t\tbucket = BUCKETS/2;\n\n\tif (duration_ns < 10ULL * NSEC_PER_USEC)\n\t\treturn bucket;\n\tif (duration_ns < 100ULL * NSEC_PER_USEC)\n\t\treturn bucket + 1;\n\tif (duration_ns < 1000ULL * NSEC_PER_USEC)\n\t\treturn bucket + 2;\n\tif (duration_ns < 10000ULL * NSEC_PER_USEC)\n\t\treturn bucket + 3;\n\tif (duration_ns < 100000ULL * NSEC_PER_USEC)\n\t\treturn bucket + 4;\n\treturn bucket + 5;\n}\n\n \nstatic inline int performance_multiplier(unsigned int nr_iowaiters)\n{\n\t \n\treturn 1 + 10 * nr_iowaiters;\n}\n\nstatic DEFINE_PER_CPU(struct menu_device, menu_devices);\n\nstatic void menu_update(struct cpuidle_driver *drv, struct cpuidle_device *dev);\n\n \nstatic unsigned int get_typical_interval(struct menu_device *data)\n{\n\tint i, divisor;\n\tunsigned int min, max, thresh, avg;\n\tuint64_t sum, variance;\n\n\tthresh = INT_MAX;  \n\nagain:\n\n\t \n\tmin = UINT_MAX;\n\tmax = 0;\n\tsum = 0;\n\tdivisor = 0;\n\tfor (i = 0; i < INTERVALS; i++) {\n\t\tunsigned int value = data->intervals[i];\n\t\tif (value <= thresh) {\n\t\t\tsum += value;\n\t\t\tdivisor++;\n\t\t\tif (value > max)\n\t\t\t\tmax = value;\n\n\t\t\tif (value < min)\n\t\t\t\tmin = value;\n\t\t}\n\t}\n\n\tif (!max)\n\t\treturn UINT_MAX;\n\n\tif (divisor == INTERVALS)\n\t\tavg = sum >> INTERVAL_SHIFT;\n\telse\n\t\tavg = div_u64(sum, divisor);\n\n\t \n\tvariance = 0;\n\tfor (i = 0; i < INTERVALS; i++) {\n\t\tunsigned int value = data->intervals[i];\n\t\tif (value <= thresh) {\n\t\t\tint64_t diff = (int64_t)value - avg;\n\t\t\tvariance += diff * diff;\n\t\t}\n\t}\n\tif (divisor == INTERVALS)\n\t\tvariance >>= INTERVAL_SHIFT;\n\telse\n\t\tdo_div(variance, divisor);\n\n\t \n\tif (likely(variance <= U64_MAX/36)) {\n\t\tif ((((u64)avg*avg > variance*36) && (divisor * 4 >= INTERVALS * 3))\n\t\t\t\t\t\t\t|| variance <= 400) {\n\t\t\treturn avg;\n\t\t}\n\t}\n\n\t \n\tif ((divisor * 4) <= INTERVALS * 3)\n\t\treturn UINT_MAX;\n\n\tthresh = max - 1;\n\tgoto again;\n}\n\n \nstatic int menu_select(struct cpuidle_driver *drv, struct cpuidle_device *dev,\n\t\t       bool *stop_tick)\n{\n\tstruct menu_device *data = this_cpu_ptr(&menu_devices);\n\ts64 latency_req = cpuidle_governor_latency_req(dev->cpu);\n\tu64 predicted_ns;\n\tu64 interactivity_req;\n\tunsigned int nr_iowaiters;\n\tktime_t delta, delta_tick;\n\tint i, idx;\n\n\tif (data->needs_update) {\n\t\tmenu_update(drv, dev);\n\t\tdata->needs_update = 0;\n\t}\n\n\tnr_iowaiters = nr_iowait_cpu(dev->cpu);\n\n\t \n\tpredicted_ns = get_typical_interval(data) * NSEC_PER_USEC;\n\tif (predicted_ns > RESIDENCY_THRESHOLD_NS) {\n\t\tunsigned int timer_us;\n\n\t\t \n\t\tdelta = tick_nohz_get_sleep_length(&delta_tick);\n\t\tif (unlikely(delta < 0)) {\n\t\t\tdelta = 0;\n\t\t\tdelta_tick = 0;\n\t\t}\n\n\t\tdata->next_timer_ns = delta;\n\t\tdata->bucket = which_bucket(data->next_timer_ns, nr_iowaiters);\n\n\t\t \n\t\ttimer_us = div_u64((RESOLUTION * DECAY * NSEC_PER_USEC) / 2 +\n\t\t\t\t\tdata->next_timer_ns *\n\t\t\t\t\t\tdata->correction_factor[data->bucket],\n\t\t\t\t   RESOLUTION * DECAY * NSEC_PER_USEC);\n\t\t \n\t\tpredicted_ns = min((u64)timer_us * NSEC_PER_USEC, predicted_ns);\n\t} else {\n\t\t \n\t\tdata->next_timer_ns = KTIME_MAX;\n\t\tdelta_tick = TICK_NSEC / 2;\n\t\tdata->bucket = which_bucket(KTIME_MAX, nr_iowaiters);\n\t}\n\n\tif (unlikely(drv->state_count <= 1 || latency_req == 0) ||\n\t    ((data->next_timer_ns < drv->states[1].target_residency_ns ||\n\t      latency_req < drv->states[1].exit_latency_ns) &&\n\t     !dev->states_usage[0].disable)) {\n\t\t \n\t\t*stop_tick = !(drv->states[0].flags & CPUIDLE_FLAG_POLLING);\n\t\treturn 0;\n\t}\n\n\tif (tick_nohz_tick_stopped()) {\n\t\t \n\t\tif (predicted_ns < TICK_NSEC)\n\t\t\tpredicted_ns = data->next_timer_ns;\n\t} else {\n\t\t \n\t\tinteractivity_req = div64_u64(predicted_ns,\n\t\t\t\t\t      performance_multiplier(nr_iowaiters));\n\t\tif (latency_req > interactivity_req)\n\t\t\tlatency_req = interactivity_req;\n\t}\n\n\t \n\tidx = -1;\n\tfor (i = 0; i < drv->state_count; i++) {\n\t\tstruct cpuidle_state *s = &drv->states[i];\n\n\t\tif (dev->states_usage[i].disable)\n\t\t\tcontinue;\n\n\t\tif (idx == -1)\n\t\t\tidx = i;  \n\n\t\tif (s->target_residency_ns > predicted_ns) {\n\t\t\t \n\t\t\tif ((drv->states[idx].flags & CPUIDLE_FLAG_POLLING) &&\n\t\t\t    s->exit_latency_ns <= latency_req &&\n\t\t\t    s->target_residency_ns <= data->next_timer_ns) {\n\t\t\t\tpredicted_ns = s->target_residency_ns;\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (predicted_ns < TICK_NSEC)\n\t\t\t\tbreak;\n\n\t\t\tif (!tick_nohz_tick_stopped()) {\n\t\t\t\t \n\t\t\t\tpredicted_ns = drv->states[idx].target_residency_ns;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (drv->states[idx].target_residency_ns < TICK_NSEC &&\n\t\t\t    s->target_residency_ns <= delta_tick)\n\t\t\t\tidx = i;\n\n\t\t\treturn idx;\n\t\t}\n\t\tif (s->exit_latency_ns > latency_req)\n\t\t\tbreak;\n\n\t\tidx = i;\n\t}\n\n\tif (idx == -1)\n\t\tidx = 0;  \n\n\t \n\tif (((drv->states[idx].flags & CPUIDLE_FLAG_POLLING) ||\n\t     predicted_ns < TICK_NSEC) && !tick_nohz_tick_stopped()) {\n\t\t*stop_tick = false;\n\n\t\tif (idx > 0 && drv->states[idx].target_residency_ns > delta_tick) {\n\t\t\t \n\t\t\tfor (i = idx - 1; i >= 0; i--) {\n\t\t\t\tif (dev->states_usage[i].disable)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tidx = i;\n\t\t\t\tif (drv->states[i].target_residency_ns <= delta_tick)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn idx;\n}\n\n \nstatic void menu_reflect(struct cpuidle_device *dev, int index)\n{\n\tstruct menu_device *data = this_cpu_ptr(&menu_devices);\n\n\tdev->last_state_idx = index;\n\tdata->needs_update = 1;\n\tdata->tick_wakeup = tick_nohz_idle_got_tick();\n}\n\n \nstatic void menu_update(struct cpuidle_driver *drv, struct cpuidle_device *dev)\n{\n\tstruct menu_device *data = this_cpu_ptr(&menu_devices);\n\tint last_idx = dev->last_state_idx;\n\tstruct cpuidle_state *target = &drv->states[last_idx];\n\tu64 measured_ns;\n\tunsigned int new_factor;\n\n\t \n\n\tif (data->tick_wakeup && data->next_timer_ns > TICK_NSEC) {\n\t\t \n\t\tmeasured_ns = 9 * MAX_INTERESTING / 10;\n\t} else if ((drv->states[last_idx].flags & CPUIDLE_FLAG_POLLING) &&\n\t\t   dev->poll_time_limit) {\n\t\t \n\t\tmeasured_ns = data->next_timer_ns;\n\t} else {\n\t\t \n\t\tmeasured_ns = dev->last_residency_ns;\n\n\t\t \n\t\tif (measured_ns > 2 * target->exit_latency_ns)\n\t\t\tmeasured_ns -= target->exit_latency_ns;\n\t\telse\n\t\t\tmeasured_ns /= 2;\n\t}\n\n\t \n\tif (measured_ns > data->next_timer_ns)\n\t\tmeasured_ns = data->next_timer_ns;\n\n\t \n\tnew_factor = data->correction_factor[data->bucket];\n\tnew_factor -= new_factor / DECAY;\n\n\tif (data->next_timer_ns > 0 && measured_ns < MAX_INTERESTING)\n\t\tnew_factor += div64_u64(RESOLUTION * measured_ns,\n\t\t\t\t\tdata->next_timer_ns);\n\telse\n\t\t \n\t\tnew_factor += RESOLUTION;\n\n\t \n\tif (DECAY == 1 && unlikely(new_factor == 0))\n\t\tnew_factor = 1;\n\n\tdata->correction_factor[data->bucket] = new_factor;\n\n\t \n\tdata->intervals[data->interval_ptr++] = ktime_to_us(measured_ns);\n\tif (data->interval_ptr >= INTERVALS)\n\t\tdata->interval_ptr = 0;\n}\n\n \nstatic int menu_enable_device(struct cpuidle_driver *drv,\n\t\t\t\tstruct cpuidle_device *dev)\n{\n\tstruct menu_device *data = &per_cpu(menu_devices, dev->cpu);\n\tint i;\n\n\tmemset(data, 0, sizeof(struct menu_device));\n\n\t \n\tfor(i = 0; i < BUCKETS; i++)\n\t\tdata->correction_factor[i] = RESOLUTION * DECAY;\n\n\treturn 0;\n}\n\nstatic struct cpuidle_governor menu_governor = {\n\t.name =\t\t\"menu\",\n\t.rating =\t20,\n\t.enable =\tmenu_enable_device,\n\t.select =\tmenu_select,\n\t.reflect =\tmenu_reflect,\n};\n\n \nstatic int __init init_menu(void)\n{\n\treturn cpuidle_register_governor(&menu_governor);\n}\n\npostcore_initcall(init_menu);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}