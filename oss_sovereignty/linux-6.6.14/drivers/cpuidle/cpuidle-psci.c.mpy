{
  "module_name": "cpuidle-psci.c",
  "hash_id": "ea8c7191c541c70ca438f6857a85c04b31872e73a8f8cc41f5a2edff66cdfeb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/cpuidle-psci.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"CPUidle PSCI: \" fmt\n\n#include <linux/cpuhotplug.h>\n#include <linux/cpu_cooling.h>\n#include <linux/cpuidle.h>\n#include <linux/cpumask.h>\n#include <linux/cpu_pm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/psci.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/syscore_ops.h>\n\n#include <asm/cpuidle.h>\n\n#include \"cpuidle-psci.h\"\n#include \"dt_idle_states.h\"\n\nstruct psci_cpuidle_data {\n\tu32 *psci_states;\n\tstruct device *dev;\n};\n\nstatic DEFINE_PER_CPU_READ_MOSTLY(struct psci_cpuidle_data, psci_cpuidle_data);\nstatic DEFINE_PER_CPU(u32, domain_state);\nstatic bool psci_cpuidle_use_cpuhp;\n\nvoid psci_set_domain_state(u32 state)\n{\n\t__this_cpu_write(domain_state, state);\n}\n\nstatic inline u32 psci_get_domain_state(void)\n{\n\treturn __this_cpu_read(domain_state);\n}\n\nstatic __cpuidle int __psci_enter_domain_idle_state(struct cpuidle_device *dev,\n\t\t\t\t\t\t    struct cpuidle_driver *drv, int idx,\n\t\t\t\t\t\t    bool s2idle)\n{\n\tstruct psci_cpuidle_data *data = this_cpu_ptr(&psci_cpuidle_data);\n\tu32 *states = data->psci_states;\n\tstruct device *pd_dev = data->dev;\n\tu32 state;\n\tint ret;\n\n\tret = cpu_pm_enter();\n\tif (ret)\n\t\treturn -1;\n\n\t \n\tif (s2idle)\n\t\tdev_pm_genpd_suspend(pd_dev);\n\telse\n\t\tpm_runtime_put_sync_suspend(pd_dev);\n\n\tstate = psci_get_domain_state();\n\tif (!state)\n\t\tstate = states[idx];\n\n\tret = psci_cpu_suspend_enter(state) ? -1 : idx;\n\n\tif (s2idle)\n\t\tdev_pm_genpd_resume(pd_dev);\n\telse\n\t\tpm_runtime_get_sync(pd_dev);\n\n\tcpu_pm_exit();\n\n\t \n\tpsci_set_domain_state(0);\n\treturn ret;\n}\n\nstatic int psci_enter_domain_idle_state(struct cpuidle_device *dev,\n\t\t\t\t\tstruct cpuidle_driver *drv, int idx)\n{\n\treturn __psci_enter_domain_idle_state(dev, drv, idx, false);\n}\n\nstatic int psci_enter_s2idle_domain_idle_state(struct cpuidle_device *dev,\n\t\t\t\t\t       struct cpuidle_driver *drv,\n\t\t\t\t\t       int idx)\n{\n\treturn __psci_enter_domain_idle_state(dev, drv, idx, true);\n}\n\nstatic int psci_idle_cpuhp_up(unsigned int cpu)\n{\n\tstruct device *pd_dev = __this_cpu_read(psci_cpuidle_data.dev);\n\n\tif (pd_dev)\n\t\tpm_runtime_get_sync(pd_dev);\n\n\treturn 0;\n}\n\nstatic int psci_idle_cpuhp_down(unsigned int cpu)\n{\n\tstruct device *pd_dev = __this_cpu_read(psci_cpuidle_data.dev);\n\n\tif (pd_dev) {\n\t\tpm_runtime_put_sync(pd_dev);\n\t\t \n\t\tpsci_set_domain_state(0);\n\t}\n\n\treturn 0;\n}\n\nstatic void psci_idle_syscore_switch(bool suspend)\n{\n\tbool cleared = false;\n\tstruct device *dev;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tdev = per_cpu_ptr(&psci_cpuidle_data, cpu)->dev;\n\n\t\tif (dev && suspend) {\n\t\t\tdev_pm_genpd_suspend(dev);\n\t\t} else if (dev) {\n\t\t\tdev_pm_genpd_resume(dev);\n\n\t\t\t \n\t\t\tif (pm_runtime_status_suspended(dev))\n\t\t\t\tpm_runtime_set_active(dev);\n\n\t\t\t \n\t\t\tif (!cleared) {\n\t\t\t\tpsci_set_domain_state(0);\n\t\t\t\tcleared = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int psci_idle_syscore_suspend(void)\n{\n\tpsci_idle_syscore_switch(true);\n\treturn 0;\n}\n\nstatic void psci_idle_syscore_resume(void)\n{\n\tpsci_idle_syscore_switch(false);\n}\n\nstatic struct syscore_ops psci_idle_syscore_ops = {\n\t.suspend = psci_idle_syscore_suspend,\n\t.resume = psci_idle_syscore_resume,\n};\n\nstatic void psci_idle_init_cpuhp(void)\n{\n\tint err;\n\n\tif (!psci_cpuidle_use_cpuhp)\n\t\treturn;\n\n\tregister_syscore_ops(&psci_idle_syscore_ops);\n\n\terr = cpuhp_setup_state_nocalls(CPUHP_AP_CPU_PM_STARTING,\n\t\t\t\t\t\"cpuidle/psci:online\",\n\t\t\t\t\tpsci_idle_cpuhp_up,\n\t\t\t\t\tpsci_idle_cpuhp_down);\n\tif (err)\n\t\tpr_warn(\"Failed %d while setup cpuhp state\\n\", err);\n}\n\nstatic __cpuidle int psci_enter_idle_state(struct cpuidle_device *dev,\n\t\t\t\t\t   struct cpuidle_driver *drv, int idx)\n{\n\tu32 *state = __this_cpu_read(psci_cpuidle_data.psci_states);\n\n\treturn CPU_PM_CPU_IDLE_ENTER_PARAM_RCU(psci_cpu_suspend_enter, idx, state[idx]);\n}\n\nstatic const struct of_device_id psci_idle_state_match[] = {\n\t{ .compatible = \"arm,idle-state\",\n\t  .data = psci_enter_idle_state },\n\t{ },\n};\n\nint psci_dt_parse_state_node(struct device_node *np, u32 *state)\n{\n\tint err = of_property_read_u32(np, \"arm,psci-suspend-param\", state);\n\n\tif (err) {\n\t\tpr_warn(\"%pOF missing arm,psci-suspend-param property\\n\", np);\n\t\treturn err;\n\t}\n\n\tif (!psci_power_state_is_valid(*state)) {\n\t\tpr_warn(\"Invalid PSCI power state %#x\\n\", *state);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int psci_dt_cpu_init_topology(struct cpuidle_driver *drv,\n\t\t\t\t     struct psci_cpuidle_data *data,\n\t\t\t\t     unsigned int state_count, int cpu)\n{\n\t \n\tif (!psci_has_osi_support())\n\t\treturn 0;\n\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\treturn 0;\n\n\tdata->dev = psci_dt_attach_cpu(cpu);\n\tif (IS_ERR_OR_NULL(data->dev))\n\t\treturn PTR_ERR_OR_ZERO(data->dev);\n\n\t \n\tdrv->states[state_count - 1].flags |= CPUIDLE_FLAG_RCU_IDLE;\n\tdrv->states[state_count - 1].enter = psci_enter_domain_idle_state;\n\tdrv->states[state_count - 1].enter_s2idle = psci_enter_s2idle_domain_idle_state;\n\tpsci_cpuidle_use_cpuhp = true;\n\n\treturn 0;\n}\n\nstatic int psci_dt_cpu_init_idle(struct device *dev, struct cpuidle_driver *drv,\n\t\t\t\t struct device_node *cpu_node,\n\t\t\t\t unsigned int state_count, int cpu)\n{\n\tint i, ret = 0;\n\tu32 *psci_states;\n\tstruct device_node *state_node;\n\tstruct psci_cpuidle_data *data = per_cpu_ptr(&psci_cpuidle_data, cpu);\n\n\tstate_count++;  \n\tpsci_states = devm_kcalloc(dev, state_count, sizeof(*psci_states),\n\t\t\t\t   GFP_KERNEL);\n\tif (!psci_states)\n\t\treturn -ENOMEM;\n\n\tfor (i = 1; i < state_count; i++) {\n\t\tstate_node = of_get_cpu_state_node(cpu_node, i - 1);\n\t\tif (!state_node)\n\t\t\tbreak;\n\n\t\tret = psci_dt_parse_state_node(state_node, &psci_states[i]);\n\t\tof_node_put(state_node);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpr_debug(\"psci-power-state %#x index %d\\n\", psci_states[i], i);\n\t}\n\n\tif (i != state_count)\n\t\treturn -ENODEV;\n\n\t \n\tret = psci_dt_cpu_init_topology(drv, data, state_count, cpu);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdata->psci_states = psci_states;\n\treturn 0;\n}\n\nstatic int psci_cpu_init_idle(struct device *dev, struct cpuidle_driver *drv,\n\t\t\t      unsigned int cpu, unsigned int state_count)\n{\n\tstruct device_node *cpu_node;\n\tint ret;\n\n\t \n\tif (!psci_ops.cpu_suspend)\n\t\treturn -EOPNOTSUPP;\n\n\tcpu_node = of_cpu_device_node_get(cpu);\n\tif (!cpu_node)\n\t\treturn -ENODEV;\n\n\tret = psci_dt_cpu_init_idle(dev, drv, cpu_node, state_count, cpu);\n\n\tof_node_put(cpu_node);\n\n\treturn ret;\n}\n\nstatic void psci_cpu_deinit_idle(int cpu)\n{\n\tstruct psci_cpuidle_data *data = per_cpu_ptr(&psci_cpuidle_data, cpu);\n\n\tpsci_dt_detach_cpu(data->dev);\n\tpsci_cpuidle_use_cpuhp = false;\n}\n\nstatic int psci_idle_init_cpu(struct device *dev, int cpu)\n{\n\tstruct cpuidle_driver *drv;\n\tstruct device_node *cpu_node;\n\tconst char *enable_method;\n\tint ret = 0;\n\n\tcpu_node = of_cpu_device_node_get(cpu);\n\tif (!cpu_node)\n\t\treturn -ENODEV;\n\n\t \n\tenable_method = of_get_property(cpu_node, \"enable-method\", NULL);\n\tif (!enable_method || (strcmp(enable_method, \"psci\")))\n\t\tret = -ENODEV;\n\n\tof_node_put(cpu_node);\n\tif (ret)\n\t\treturn ret;\n\n\tdrv = devm_kzalloc(dev, sizeof(*drv), GFP_KERNEL);\n\tif (!drv)\n\t\treturn -ENOMEM;\n\n\tdrv->name = \"psci_idle\";\n\tdrv->owner = THIS_MODULE;\n\tdrv->cpumask = (struct cpumask *)cpumask_of(cpu);\n\n\t \n\tdrv->states[0].enter = psci_enter_idle_state;\n\tdrv->states[0].exit_latency = 1;\n\tdrv->states[0].target_residency = 1;\n\tdrv->states[0].power_usage = UINT_MAX;\n\tstrcpy(drv->states[0].name, \"WFI\");\n\tstrcpy(drv->states[0].desc, \"ARM WFI\");\n\n\t \n\tret = dt_init_idle_driver(drv, psci_idle_state_match, 1);\n\tif (ret <= 0)\n\t\treturn ret ? : -ENODEV;\n\n\t \n\tret = psci_cpu_init_idle(dev, drv, cpu, ret);\n\tif (ret) {\n\t\tpr_err(\"CPU %d failed to PSCI idle\\n\", cpu);\n\t\treturn ret;\n\t}\n\n\tret = cpuidle_register(drv, NULL);\n\tif (ret)\n\t\tgoto deinit;\n\n\tcpuidle_cooling_register(drv);\n\n\treturn 0;\ndeinit:\n\tpsci_cpu_deinit_idle(cpu);\n\treturn ret;\n}\n\n \nstatic int psci_cpuidle_probe(struct platform_device *pdev)\n{\n\tint cpu, ret;\n\tstruct cpuidle_driver *drv;\n\tstruct cpuidle_device *dev;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tret = psci_idle_init_cpu(&pdev->dev, cpu);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t}\n\n\tpsci_idle_init_cpuhp();\n\treturn 0;\n\nout_fail:\n\twhile (--cpu >= 0) {\n\t\tdev = per_cpu(cpuidle_devices, cpu);\n\t\tdrv = cpuidle_get_cpu_driver(dev);\n\t\tcpuidle_unregister(drv);\n\t\tpsci_cpu_deinit_idle(cpu);\n\t}\n\n\treturn ret;\n}\n\nstatic struct platform_driver psci_cpuidle_driver = {\n\t.probe = psci_cpuidle_probe,\n\t.driver = {\n\t\t.name = \"psci-cpuidle\",\n\t},\n};\n\nstatic int __init psci_idle_init(void)\n{\n\tstruct platform_device *pdev;\n\tint ret;\n\n\tret = platform_driver_register(&psci_cpuidle_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tpdev = platform_device_register_simple(\"psci-cpuidle\", -1, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\tplatform_driver_unregister(&psci_cpuidle_driver);\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\treturn 0;\n}\ndevice_initcall(psci_idle_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}