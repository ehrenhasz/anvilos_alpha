{
  "module_name": "cpuidle-haltpoll.c",
  "hash_id": "872ac691458ed63f3851d9bb797ed85dd6b047ee3b680112fbcda8e41259f231",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/cpuidle-haltpoll.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/cpuidle.h>\n#include <linux/module.h>\n#include <linux/sched/idle.h>\n#include <linux/kvm_para.h>\n#include <linux/cpuidle_haltpoll.h>\n\nstatic bool force __read_mostly;\nmodule_param(force, bool, 0444);\nMODULE_PARM_DESC(force, \"Load unconditionally\");\n\nstatic struct cpuidle_device __percpu *haltpoll_cpuidle_devices;\nstatic enum cpuhp_state haltpoll_hp_state;\n\nstatic __cpuidle int default_enter_idle(struct cpuidle_device *dev,\n\t\t\t\t\tstruct cpuidle_driver *drv, int index)\n{\n\tif (current_clr_polling_and_test())\n\t\treturn index;\n\n\tarch_cpu_idle();\n\treturn index;\n}\n\nstatic struct cpuidle_driver haltpoll_driver = {\n\t.name = \"haltpoll\",\n\t.governor = \"haltpoll\",\n\t.states = {\n\t\t{   },\n\t\t{\n\t\t\t.enter\t\t\t= default_enter_idle,\n\t\t\t.exit_latency\t\t= 1,\n\t\t\t.target_residency\t= 1,\n\t\t\t.power_usage\t\t= -1,\n\t\t\t.name\t\t\t= \"haltpoll idle\",\n\t\t\t.desc\t\t\t= \"default architecture idle\",\n\t\t},\n\t},\n\t.safe_state_index = 0,\n\t.state_count = 2,\n};\n\nstatic int haltpoll_cpu_online(unsigned int cpu)\n{\n\tstruct cpuidle_device *dev;\n\n\tdev = per_cpu_ptr(haltpoll_cpuidle_devices, cpu);\n\tif (!dev->registered) {\n\t\tdev->cpu = cpu;\n\t\tif (cpuidle_register_device(dev)) {\n\t\t\tpr_notice(\"cpuidle_register_device %d failed!\\n\", cpu);\n\t\t\treturn -EIO;\n\t\t}\n\t\tarch_haltpoll_enable(cpu);\n\t}\n\n\treturn 0;\n}\n\nstatic int haltpoll_cpu_offline(unsigned int cpu)\n{\n\tstruct cpuidle_device *dev;\n\n\tdev = per_cpu_ptr(haltpoll_cpuidle_devices, cpu);\n\tif (dev->registered) {\n\t\tarch_haltpoll_disable(cpu);\n\t\tcpuidle_unregister_device(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void haltpoll_uninit(void)\n{\n\tif (haltpoll_hp_state)\n\t\tcpuhp_remove_state(haltpoll_hp_state);\n\tcpuidle_unregister_driver(&haltpoll_driver);\n\n\tfree_percpu(haltpoll_cpuidle_devices);\n\thaltpoll_cpuidle_devices = NULL;\n}\n\nstatic bool haltpoll_want(void)\n{\n\treturn kvm_para_has_hint(KVM_HINTS_REALTIME) || force;\n}\n\nstatic int __init haltpoll_init(void)\n{\n\tint ret;\n\tstruct cpuidle_driver *drv = &haltpoll_driver;\n\n\t \n\tif (boot_option_idle_override != IDLE_NO_OVERRIDE)\n\t\treturn -ENODEV;\n\n\tif (!kvm_para_available() || !haltpoll_want())\n\t\treturn -ENODEV;\n\n\tcpuidle_poll_state_init(drv);\n\n\tret = cpuidle_register_driver(drv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thaltpoll_cpuidle_devices = alloc_percpu(struct cpuidle_device);\n\tif (haltpoll_cpuidle_devices == NULL) {\n\t\tcpuidle_unregister_driver(drv);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"cpuidle/haltpoll:online\",\n\t\t\t\thaltpoll_cpu_online, haltpoll_cpu_offline);\n\tif (ret < 0) {\n\t\thaltpoll_uninit();\n\t} else {\n\t\thaltpoll_hp_state = ret;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit haltpoll_exit(void)\n{\n\thaltpoll_uninit();\n}\n\nmodule_init(haltpoll_init);\nmodule_exit(haltpoll_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Marcelo Tosatti <mtosatti@redhat.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}