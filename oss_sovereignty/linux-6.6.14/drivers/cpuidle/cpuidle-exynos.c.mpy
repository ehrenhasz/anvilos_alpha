{
  "module_name": "cpuidle-exynos.c",
  "hash_id": "601d5760e7819218b5447294c5dd494464a40edd189019665e8170c8b12131e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/cpuidle-exynos.c",
  "human_readable_source": "\n \n\n#include <linux/cpuidle.h>\n#include <linux/cpu_pm.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/platform_data/cpuidle-exynos.h>\n\n#include <asm/suspend.h>\n#include <asm/cpuidle.h>\n\nstatic atomic_t exynos_idle_barrier;\n\nstatic struct cpuidle_exynos_data *exynos_cpuidle_pdata;\nstatic void (*exynos_enter_aftr)(void);\n\nstatic int exynos_enter_coupled_lowpower(struct cpuidle_device *dev,\n\t\t\t\t\t struct cpuidle_driver *drv,\n\t\t\t\t\t int index)\n{\n\tint ret;\n\n\texynos_cpuidle_pdata->pre_enter_aftr();\n\n\t \n\tcpuidle_coupled_parallel_barrier(dev, &exynos_idle_barrier);\n\n\t \n\tret = dev->cpu ? exynos_cpuidle_pdata->cpu1_powerdown()\n\t\t       : exynos_cpuidle_pdata->cpu0_enter_aftr();\n\tif (ret)\n\t\tindex = ret;\n\n\t \n\tcpuidle_coupled_parallel_barrier(dev, &exynos_idle_barrier);\n\n\texynos_cpuidle_pdata->post_enter_aftr();\n\n\treturn index;\n}\n\nstatic int exynos_enter_lowpower(struct cpuidle_device *dev,\n\t\t\t\tstruct cpuidle_driver *drv,\n\t\t\t\tint index)\n{\n\tint new_index = index;\n\n\t \n\tif (num_online_cpus() > 1 || dev->cpu != 0)\n\t\tnew_index = drv->safe_state_index;\n\n\tif (new_index == 0)\n\t\treturn arm_cpuidle_simple_enter(dev, drv, new_index);\n\n\texynos_enter_aftr();\n\n\treturn new_index;\n}\n\nstatic struct cpuidle_driver exynos_idle_driver = {\n\t.name\t\t\t= \"exynos_idle\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.states = {\n\t\t[0] = ARM_CPUIDLE_WFI_STATE,\n\t\t[1] = {\n\t\t\t.enter\t\t\t= exynos_enter_lowpower,\n\t\t\t.exit_latency\t\t= 300,\n\t\t\t.target_residency\t= 10000,\n\t\t\t.name\t\t\t= \"C1\",\n\t\t\t.desc\t\t\t= \"ARM power down\",\n\t\t},\n\t},\n\t.state_count = 2,\n\t.safe_state_index = 0,\n};\n\nstatic struct cpuidle_driver exynos_coupled_idle_driver = {\n\t.name\t\t\t= \"exynos_coupled_idle\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.states = {\n\t\t[0] = ARM_CPUIDLE_WFI_STATE,\n\t\t[1] = {\n\t\t\t.enter\t\t\t= exynos_enter_coupled_lowpower,\n\t\t\t.exit_latency\t\t= 5000,\n\t\t\t.target_residency\t= 10000,\n\t\t\t.flags\t\t\t= CPUIDLE_FLAG_COUPLED |\n\t\t\t\t\t\t  CPUIDLE_FLAG_TIMER_STOP,\n\t\t\t.name\t\t\t= \"C1\",\n\t\t\t.desc\t\t\t= \"ARM power down\",\n\t\t},\n\t},\n\t.state_count = 2,\n\t.safe_state_index = 0,\n};\n\nstatic int exynos_cpuidle_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_SMP) &&\n\t    (of_machine_is_compatible(\"samsung,exynos4210\") ||\n\t     of_machine_is_compatible(\"samsung,exynos3250\"))) {\n\t\texynos_cpuidle_pdata = pdev->dev.platform_data;\n\n\t\tret = cpuidle_register(&exynos_coupled_idle_driver,\n\t\t\t\t       cpu_possible_mask);\n\t} else {\n\t\texynos_enter_aftr = (void *)(pdev->dev.platform_data);\n\n\t\tret = cpuidle_register(&exynos_idle_driver, NULL);\n\t}\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register cpuidle driver\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver exynos_cpuidle_driver = {\n\t.probe\t= exynos_cpuidle_probe,\n\t.driver = {\n\t\t.name = \"exynos_cpuidle\",\n\t},\n};\nbuiltin_platform_driver(exynos_cpuidle_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}