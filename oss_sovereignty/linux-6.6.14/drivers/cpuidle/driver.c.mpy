{
  "module_name": "driver.c",
  "hash_id": "c3104ce36f290dce0a50f73fe6427a0f3aa7e3f1e897f5ef4bc984311ec1d15e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/driver.c",
  "human_readable_source": " \n\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/sched/idle.h>\n#include <linux/cpuidle.h>\n#include <linux/cpumask.h>\n#include <linux/tick.h>\n#include <linux/cpu.h>\n\n#include \"cpuidle.h\"\n\nDEFINE_SPINLOCK(cpuidle_driver_lock);\n\n#ifdef CONFIG_CPU_IDLE_MULTIPLE_DRIVERS\n\nstatic DEFINE_PER_CPU(struct cpuidle_driver *, cpuidle_drivers);\n\n \nstatic struct cpuidle_driver *__cpuidle_get_cpu_driver(int cpu)\n{\n\treturn per_cpu(cpuidle_drivers, cpu);\n}\n\n \nstatic inline void __cpuidle_unset_driver(struct cpuidle_driver *drv)\n{\n\tint cpu;\n\n\tfor_each_cpu(cpu, drv->cpumask) {\n\n\t\tif (drv != __cpuidle_get_cpu_driver(cpu))\n\t\t\tcontinue;\n\n\t\tper_cpu(cpuidle_drivers, cpu) = NULL;\n\t}\n}\n\n \nstatic inline int __cpuidle_set_driver(struct cpuidle_driver *drv)\n{\n\tint cpu;\n\n\tfor_each_cpu(cpu, drv->cpumask) {\n\t\tstruct cpuidle_driver *old_drv;\n\n\t\told_drv = __cpuidle_get_cpu_driver(cpu);\n\t\tif (old_drv && old_drv != drv)\n\t\t\treturn -EBUSY;\n\t}\n\n\tfor_each_cpu(cpu, drv->cpumask)\n\t\tper_cpu(cpuidle_drivers, cpu) = drv;\n\n\treturn 0;\n}\n\n#else\n\nstatic struct cpuidle_driver *cpuidle_curr_driver;\n\n \nstatic inline struct cpuidle_driver *__cpuidle_get_cpu_driver(int cpu)\n{\n\treturn cpuidle_curr_driver;\n}\n\n \nstatic inline int __cpuidle_set_driver(struct cpuidle_driver *drv)\n{\n\tif (cpuidle_curr_driver)\n\t\treturn -EBUSY;\n\n\tcpuidle_curr_driver = drv;\n\n\treturn 0;\n}\n\n \nstatic inline void __cpuidle_unset_driver(struct cpuidle_driver *drv)\n{\n\tif (drv == cpuidle_curr_driver)\n\t\tcpuidle_curr_driver = NULL;\n}\n\n#endif\n\n \nstatic void cpuidle_setup_broadcast_timer(void *arg)\n{\n\tif (arg)\n\t\ttick_broadcast_enable();\n\telse\n\t\ttick_broadcast_disable();\n}\n\n \nstatic void __cpuidle_driver_init(struct cpuidle_driver *drv)\n{\n\tint i;\n\n\t \n\tif (!drv->cpumask)\n\t\tdrv->cpumask = (struct cpumask *)cpu_possible_mask;\n\n\tfor (i = 0; i < drv->state_count; i++) {\n\t\tstruct cpuidle_state *s = &drv->states[i];\n\n\t\t \n\t\tif (s->flags & CPUIDLE_FLAG_TIMER_STOP)\n\t\t\tdrv->bctimer = 1;\n\n\t\t \n\t\tif (s->target_residency > 0)\n\t\t\ts->target_residency_ns = s->target_residency * NSEC_PER_USEC;\n\t\telse if (s->target_residency_ns < 0)\n\t\t\ts->target_residency_ns = 0;\n\t\telse\n\t\t\ts->target_residency = div_u64(s->target_residency_ns, NSEC_PER_USEC);\n\n\t\tif (s->exit_latency > 0)\n\t\t\ts->exit_latency_ns = s->exit_latency * NSEC_PER_USEC;\n\t\telse if (s->exit_latency_ns < 0)\n\t\t\ts->exit_latency_ns =  0;\n\t\telse\n\t\t\ts->exit_latency = div_u64(s->exit_latency_ns, NSEC_PER_USEC);\n\t}\n}\n\n \nstatic int __cpuidle_register_driver(struct cpuidle_driver *drv)\n{\n\tint ret;\n\n\tif (!drv || !drv->state_count)\n\t\treturn -EINVAL;\n\n\tret = cpuidle_coupled_state_verify(drv);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cpuidle_disabled())\n\t\treturn -ENODEV;\n\n\t__cpuidle_driver_init(drv);\n\n\tret = __cpuidle_set_driver(drv);\n\tif (ret)\n\t\treturn ret;\n\n\tif (drv->bctimer)\n\t\ton_each_cpu_mask(drv->cpumask, cpuidle_setup_broadcast_timer,\n\t\t\t\t (void *)1, 1);\n\n\treturn 0;\n}\n\n \nstatic void __cpuidle_unregister_driver(struct cpuidle_driver *drv)\n{\n\tif (drv->bctimer) {\n\t\tdrv->bctimer = 0;\n\t\ton_each_cpu_mask(drv->cpumask, cpuidle_setup_broadcast_timer,\n\t\t\t\t NULL, 1);\n\t}\n\n\t__cpuidle_unset_driver(drv);\n}\n\n \nint cpuidle_register_driver(struct cpuidle_driver *drv)\n{\n\tstruct cpuidle_governor *gov;\n\tint ret;\n\n\tspin_lock(&cpuidle_driver_lock);\n\tret = __cpuidle_register_driver(drv);\n\tspin_unlock(&cpuidle_driver_lock);\n\n\tif (!ret && !strlen(param_governor) && drv->governor &&\n\t    (cpuidle_get_driver() == drv)) {\n\t\tmutex_lock(&cpuidle_lock);\n\t\tgov = cpuidle_find_governor(drv->governor);\n\t\tif (gov) {\n\t\t\tcpuidle_prev_governor = cpuidle_curr_governor;\n\t\t\tif (cpuidle_switch_governor(gov) < 0)\n\t\t\t\tcpuidle_prev_governor = NULL;\n\t\t}\n\t\tmutex_unlock(&cpuidle_lock);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cpuidle_register_driver);\n\n \nvoid cpuidle_unregister_driver(struct cpuidle_driver *drv)\n{\n\tbool enabled = (cpuidle_get_driver() == drv);\n\n\tspin_lock(&cpuidle_driver_lock);\n\t__cpuidle_unregister_driver(drv);\n\tspin_unlock(&cpuidle_driver_lock);\n\n\tif (!enabled)\n\t\treturn;\n\n\tmutex_lock(&cpuidle_lock);\n\tif (cpuidle_prev_governor) {\n\t\tif (!cpuidle_switch_governor(cpuidle_prev_governor))\n\t\t\tcpuidle_prev_governor = NULL;\n\t}\n\tmutex_unlock(&cpuidle_lock);\n}\nEXPORT_SYMBOL_GPL(cpuidle_unregister_driver);\n\n \nstruct cpuidle_driver *cpuidle_get_driver(void)\n{\n\tstruct cpuidle_driver *drv;\n\tint cpu;\n\n\tcpu = get_cpu();\n\tdrv = __cpuidle_get_cpu_driver(cpu);\n\tput_cpu();\n\n\treturn drv;\n}\nEXPORT_SYMBOL_GPL(cpuidle_get_driver);\n\n \nstruct cpuidle_driver *cpuidle_get_cpu_driver(struct cpuidle_device *dev)\n{\n\tif (!dev)\n\t\treturn NULL;\n\n\treturn __cpuidle_get_cpu_driver(dev->cpu);\n}\nEXPORT_SYMBOL_GPL(cpuidle_get_cpu_driver);\n\n \nvoid cpuidle_driver_state_disabled(struct cpuidle_driver *drv, int idx,\n\t\t\t\t bool disable)\n{\n\tunsigned int cpu;\n\n\tmutex_lock(&cpuidle_lock);\n\n\tspin_lock(&cpuidle_driver_lock);\n\n\tif (!drv->cpumask) {\n\t\tdrv->states[idx].flags |= CPUIDLE_FLAG_UNUSABLE;\n\t\tgoto unlock;\n\t}\n\n\tfor_each_cpu(cpu, drv->cpumask) {\n\t\tstruct cpuidle_device *dev = per_cpu(cpuidle_devices, cpu);\n\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\tif (disable)\n\t\t\tdev->states_usage[idx].disable |= CPUIDLE_STATE_DISABLED_BY_DRIVER;\n\t\telse\n\t\t\tdev->states_usage[idx].disable &= ~CPUIDLE_STATE_DISABLED_BY_DRIVER;\n\t}\n\nunlock:\n\tspin_unlock(&cpuidle_driver_lock);\n\n\tmutex_unlock(&cpuidle_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}