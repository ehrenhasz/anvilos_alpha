{
  "module_name": "cpuidle-tegra.c",
  "hash_id": "e204c3b138b6f02b19626e618113ea40ee6bc139abd0821f2e40c61b5a120558",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/cpuidle-tegra.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"tegra-cpuidle: \" fmt\n\n#include <linux/atomic.h>\n#include <linux/cpuidle.h>\n#include <linux/cpumask.h>\n#include <linux/cpu_pm.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\n#include <linux/clk/tegra.h>\n#include <linux/firmware/trusted_foundations.h>\n\n#include <soc/tegra/cpuidle.h>\n#include <soc/tegra/flowctrl.h>\n#include <soc/tegra/fuse.h>\n#include <soc/tegra/irq.h>\n#include <soc/tegra/pm.h>\n#include <soc/tegra/pmc.h>\n\n#include <asm/cpuidle.h>\n#include <asm/firmware.h>\n#include <asm/smp_plat.h>\n#include <asm/suspend.h>\n\nenum tegra_state {\n\tTEGRA_C1,\n\tTEGRA_C7,\n\tTEGRA_CC6,\n\tTEGRA_STATE_COUNT,\n};\n\nstatic atomic_t tegra_idle_barrier;\nstatic atomic_t tegra_abort_flag;\n\nstatic void tegra_cpuidle_report_cpus_state(void)\n{\n\tunsigned long cpu, lcpu, csr;\n\n\tfor_each_cpu(lcpu, cpu_possible_mask) {\n\t\tcpu = cpu_logical_map(lcpu);\n\t\tcsr = flowctrl_read_cpu_csr(cpu);\n\n\t\tpr_err(\"cpu%lu: online=%d flowctrl_csr=0x%08lx\\n\",\n\t\t       cpu, cpu_online(lcpu), csr);\n\t}\n}\n\nstatic int tegra_cpuidle_wait_for_secondary_cpus_parking(void)\n{\n\tunsigned int retries = 3;\n\n\twhile (retries--) {\n\t\tunsigned int delay_us = 10;\n\t\tunsigned int timeout_us = 500 * 1000 / delay_us;\n\n\t\t \n\t\tdo {\n\t\t\tif (tegra_cpu_rail_off_ready())\n\t\t\t\treturn 0;\n\n\t\t\tudelay(delay_us);\n\n\t\t} while (timeout_us--);\n\n\t\tpr_err(\"secondary CPU taking too long to park\\n\");\n\n\t\ttegra_cpuidle_report_cpus_state();\n\t}\n\n\tpr_err(\"timed out waiting secondaries to park\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void tegra_cpuidle_unpark_secondary_cpus(void)\n{\n\tunsigned int cpu, lcpu;\n\n\tfor_each_cpu(lcpu, cpu_online_mask) {\n\t\tcpu = cpu_logical_map(lcpu);\n\n\t\tif (cpu > 0) {\n\t\t\ttegra_enable_cpu_clock(cpu);\n\t\t\ttegra_cpu_out_of_reset(cpu);\n\t\t\tflowctrl_write_cpu_halt(cpu, 0);\n\t\t}\n\t}\n}\n\nstatic int tegra_cpuidle_cc6_enter(unsigned int cpu)\n{\n\tint ret;\n\n\tif (cpu > 0) {\n\t\tret = cpu_suspend(cpu, tegra_pm_park_secondary_cpu);\n\t} else {\n\t\tret = tegra_cpuidle_wait_for_secondary_cpus_parking();\n\t\tif (!ret)\n\t\t\tret = tegra_pm_enter_lp2();\n\n\t\ttegra_cpuidle_unpark_secondary_cpus();\n\t}\n\n\treturn ret;\n}\n\nstatic int tegra_cpuidle_c7_enter(void)\n{\n\tint err;\n\n\terr = call_firmware_op(prepare_idle, TF_PM_MODE_LP2_NOFLUSH_L2);\n\tif (err && err != -ENOSYS)\n\t\treturn err;\n\n\treturn cpu_suspend(0, tegra30_pm_secondary_cpu_suspend);\n}\n\nstatic int tegra_cpuidle_coupled_barrier(struct cpuidle_device *dev)\n{\n\tif (tegra_pending_sgi()) {\n\t\t \n\t\tatomic_set(&tegra_abort_flag, 1);\n\t}\n\n\tcpuidle_coupled_parallel_barrier(dev, &tegra_idle_barrier);\n\n\tif (atomic_read(&tegra_abort_flag)) {\n\t\tcpuidle_coupled_parallel_barrier(dev, &tegra_idle_barrier);\n\t\tatomic_set(&tegra_abort_flag, 0);\n\t\treturn -EINTR;\n\t}\n\n\treturn 0;\n}\n\nstatic __cpuidle int tegra_cpuidle_state_enter(struct cpuidle_device *dev,\n\t\t\t\t\t       int index, unsigned int cpu)\n{\n\tint err;\n\n\t \n\tif (index == TEGRA_CC6) {\n\t\terr = tegra_cpuidle_coupled_barrier(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tlocal_fiq_disable();\n\ttegra_pm_set_cpu_in_lp2();\n\tcpu_pm_enter();\n\n\tct_cpuidle_enter();\n\n\tswitch (index) {\n\tcase TEGRA_C7:\n\t\terr = tegra_cpuidle_c7_enter();\n\t\tbreak;\n\n\tcase TEGRA_CC6:\n\t\terr = tegra_cpuidle_cc6_enter(cpu);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tct_cpuidle_exit();\n\n\tcpu_pm_exit();\n\ttegra_pm_clear_cpu_in_lp2();\n\tlocal_fiq_enable();\n\n\treturn err ?: index;\n}\n\nstatic int tegra_cpuidle_adjust_state_index(int index, unsigned int cpu)\n{\n\t \n\tif (cpu > 0 || index != TEGRA_C7 || tegra_get_chip_id() != TEGRA30)\n\t\treturn index;\n\n\t \n\tif (!IS_ENABLED(CONFIG_PM_SLEEP) || num_online_cpus() > 1)\n\t\tindex = TEGRA_C1;\n\telse\n\t\tindex = TEGRA_CC6;\n\n\treturn index;\n}\n\nstatic __cpuidle int tegra_cpuidle_enter(struct cpuidle_device *dev,\n\t\t\t\t\t struct cpuidle_driver *drv,\n\t\t\t\t\t int index)\n{\n\tbool do_rcu = drv->states[index].flags & CPUIDLE_FLAG_RCU_IDLE;\n\tunsigned int cpu = cpu_logical_map(dev->cpu);\n\tint ret;\n\n\tindex = tegra_cpuidle_adjust_state_index(index, cpu);\n\tif (dev->states_usage[index].disable)\n\t\treturn -1;\n\n\tif (index == TEGRA_C1) {\n\t\tif (do_rcu)\n\t\t\tct_cpuidle_enter();\n\t\tret = arm_cpuidle_simple_enter(dev, drv, index);\n\t\tif (do_rcu)\n\t\t\tct_cpuidle_exit();\n\t} else\n\t\tret = tegra_cpuidle_state_enter(dev, index, cpu);\n\n\tif (ret < 0) {\n\t\tif (ret != -EINTR || index != TEGRA_CC6)\n\t\t\tpr_err_once(\"failed to enter state %d err: %d\\n\",\n\t\t\t\t    index, ret);\n\t\tindex = -1;\n\t} else {\n\t\tindex = ret;\n\t}\n\n\treturn index;\n}\n\nstatic int tegra114_enter_s2idle(struct cpuidle_device *dev,\n\t\t\t\t struct cpuidle_driver *drv,\n\t\t\t\t int index)\n{\n\ttegra_cpuidle_enter(dev, drv, index);\n\n\treturn 0;\n}\n\n \nstatic struct cpuidle_driver tegra_idle_driver = {\n\t.name = \"tegra_idle\",\n\t.states = {\n\t\t[TEGRA_C1] = ARM_CPUIDLE_WFI_STATE_PWR(600),\n\t\t[TEGRA_C7] = {\n\t\t\t.enter\t\t\t= tegra_cpuidle_enter,\n\t\t\t.exit_latency\t\t= 2000,\n\t\t\t.target_residency\t= 2200,\n\t\t\t.power_usage\t\t= 100,\n\t\t\t.flags\t\t\t= CPUIDLE_FLAG_TIMER_STOP |\n\t\t\t\t\t\t  CPUIDLE_FLAG_RCU_IDLE,\n\t\t\t.name\t\t\t= \"C7\",\n\t\t\t.desc\t\t\t= \"CPU core powered off\",\n\t\t},\n\t\t[TEGRA_CC6] = {\n\t\t\t.enter\t\t\t= tegra_cpuidle_enter,\n\t\t\t.exit_latency\t\t= 5000,\n\t\t\t.target_residency\t= 10000,\n\t\t\t.power_usage\t\t= 0,\n\t\t\t.flags\t\t\t= CPUIDLE_FLAG_TIMER_STOP |\n\t\t\t\t\t\t  CPUIDLE_FLAG_RCU_IDLE   |\n\t\t\t\t\t\t  CPUIDLE_FLAG_COUPLED,\n\t\t\t.name\t\t\t= \"CC6\",\n\t\t\t.desc\t\t\t= \"CPU cluster powered off\",\n\t\t},\n\t},\n\t.state_count = TEGRA_STATE_COUNT,\n\t.safe_state_index = TEGRA_C1,\n};\n\nstatic inline void tegra_cpuidle_disable_state(enum tegra_state state)\n{\n\tcpuidle_driver_state_disabled(&tegra_idle_driver, state, true);\n}\n\n \nvoid tegra_cpuidle_pcie_irqs_in_use(void)\n{\n\tstruct cpuidle_state *state_cc6 = &tegra_idle_driver.states[TEGRA_CC6];\n\n\tif ((state_cc6->flags & CPUIDLE_FLAG_UNUSABLE) ||\n\t    tegra_get_chip_id() != TEGRA20)\n\t\treturn;\n\n\tpr_info(\"disabling CC6 state, since PCIe IRQs are in use\\n\");\n\ttegra_cpuidle_disable_state(TEGRA_CC6);\n}\n\nstatic void tegra_cpuidle_setup_tegra114_c7_state(void)\n{\n\tstruct cpuidle_state *s = &tegra_idle_driver.states[TEGRA_C7];\n\n\ts->enter_s2idle = tegra114_enter_s2idle;\n\ts->target_residency = 1000;\n\ts->exit_latency = 500;\n}\n\nstatic int tegra_cpuidle_probe(struct platform_device *pdev)\n{\n\tif (tegra_pmc_get_suspend_mode() == TEGRA_SUSPEND_NOT_READY)\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tif (tegra_pmc_get_suspend_mode() < TEGRA_SUSPEND_LP2)\n\t\ttegra_cpuidle_disable_state(TEGRA_CC6);\n\n\t \n\tif (!IS_ENABLED(CONFIG_PM_SLEEP)) {\n\t\ttegra_cpuidle_disable_state(TEGRA_C7);\n\t\ttegra_cpuidle_disable_state(TEGRA_CC6);\n\t}\n\n\t \n\tswitch (tegra_get_chip_id()) {\n\tcase TEGRA20:\n\t\t \n\t\ttegra_cpuidle_disable_state(TEGRA_C7);\n\t\tbreak;\n\n\tcase TEGRA30:\n\t\tbreak;\n\n\tcase TEGRA114:\n\tcase TEGRA124:\n\t\ttegra_cpuidle_setup_tegra114_c7_state();\n\n\t\t \n\t\ttegra_cpuidle_disable_state(TEGRA_CC6);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn cpuidle_register(&tegra_idle_driver, cpu_possible_mask);\n}\n\nstatic struct platform_driver tegra_cpuidle_driver = {\n\t.probe = tegra_cpuidle_probe,\n\t.driver = {\n\t\t.name = \"tegra-cpuidle\",\n\t},\n};\nbuiltin_platform_driver(tegra_cpuidle_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}