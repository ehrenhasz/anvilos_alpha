{
  "module_name": "Kconfig",
  "hash_id": "ed8ea8136c0bee5eaad86ddf28277b7b22f12b8e457c814010d5ffc483592204",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpuidle/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nmenu \"CPU Idle\"\n\nconfig CPU_IDLE\n\tbool \"CPU idle PM support\"\n\tdefault y if ACPI || PPC_PSERIES\n\tselect CPU_IDLE_GOV_LADDER if (!NO_HZ && !NO_HZ_IDLE)\n\tselect CPU_IDLE_GOV_MENU if (NO_HZ || NO_HZ_IDLE) && !CPU_IDLE_GOV_TEO\n\thelp\n\t  CPU idle is a generic framework for supporting software-controlled\n\t  idle processor power management.  It includes modular cross-platform\n\t  governors that can be swapped during runtime.\n\n\t  If you're using an ACPI-enabled platform, you should say Y here.\n\nif CPU_IDLE\n\nconfig CPU_IDLE_MULTIPLE_DRIVERS\n\tbool\n\nconfig CPU_IDLE_GOV_LADDER\n\tbool \"Ladder governor (for periodic timer tick)\"\n\nconfig CPU_IDLE_GOV_MENU\n\tbool \"Menu governor (for tickless system)\"\n\nconfig CPU_IDLE_GOV_TEO\n\tbool \"Timer events oriented (TEO) governor (for tickless systems)\"\n\thelp\n\t  This governor implements a simplified idle state selection method\n\t  focused on timer events and does not do any interactivity boosting.\n\n\t  Some workloads benefit from using it and it generally should be safe\n\t  to use.  Say Y here if you are not happy with the alternatives.\n\nconfig CPU_IDLE_GOV_HALTPOLL\n\tbool \"Haltpoll governor (for virtualized systems)\"\n\tdepends on KVM_GUEST\n\thelp\n\t  This governor implements haltpoll idle state selection, to be\n\t  used in conjunction with the haltpoll cpuidle driver, allowing\n\t  for polling for a certain amount of time before entering idle\n\t  state.\n\n\t  Some virtualized workloads benefit from using it.\n\nconfig DT_IDLE_STATES\n\tbool\n\nconfig DT_IDLE_GENPD\n\tdepends on PM_GENERIC_DOMAINS_OF\n\tbool\n\nmenu \"ARM CPU Idle Drivers\"\ndepends on ARM || ARM64\nsource \"drivers/cpuidle/Kconfig.arm\"\nendmenu\n\nmenu \"MIPS CPU Idle Drivers\"\ndepends on MIPS\nsource \"drivers/cpuidle/Kconfig.mips\"\nendmenu\n\nmenu \"POWERPC CPU Idle Drivers\"\ndepends on PPC\nsource \"drivers/cpuidle/Kconfig.powerpc\"\nendmenu\n\nmenu \"RISC-V CPU Idle Drivers\"\ndepends on RISCV\nsource \"drivers/cpuidle/Kconfig.riscv\"\nendmenu\n\nconfig HALTPOLL_CPUIDLE\n\ttristate \"Halt poll cpuidle driver\"\n\tdepends on X86 && KVM_GUEST\n\tselect CPU_IDLE_GOV_HALTPOLL\n\tdefault y\n\thelp\n\t This option enables halt poll cpuidle driver, which allows to poll\n\t before halting in the guest (more efficient than polling in the\n\t host via halt_poll_ns for some scenarios).\n\nendif\n\nconfig ARCH_NEEDS_CPU_IDLE_COUPLED\n\tdef_bool n\nendmenu\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}