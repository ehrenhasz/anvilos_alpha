{
  "module_name": "max8973-regulator.c",
  "hash_id": "a903ad79ddef93f40aff613ed96162c2b046f1612f152aeda3007dade1c2f752",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/max8973-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/max8973-regulator.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_gpio.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <linux/thermal.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n\n \n#define MAX8973_VOUT\t\t\t\t\t0x0\n#define MAX8973_VOUT_DVS\t\t\t\t0x1\n#define MAX8973_CONTROL1\t\t\t\t0x2\n#define MAX8973_CONTROL2\t\t\t\t0x3\n#define MAX8973_CHIPID1\t\t\t\t\t0x4\n#define MAX8973_CHIPID2\t\t\t\t\t0x5\n\n#define MAX8973_MAX_VOUT_REG\t\t\t\t2\n\n \n#define MAX8973_VOUT_ENABLE\t\t\t\tBIT(7)\n#define MAX8973_VOUT_MASK\t\t\t\t0x7F\n\n \n#define MAX8973_DVS_VOUT_MASK\t\t\t\t0x7F\n\n \n#define MAX8973_SNS_ENABLE\t\t\t\tBIT(7)\n#define MAX8973_FPWM_EN_M\t\t\t\tBIT(6)\n#define MAX8973_NFSR_ENABLE\t\t\t\tBIT(5)\n#define MAX8973_AD_ENABLE\t\t\t\tBIT(4)\n#define MAX8973_BIAS_ENABLE\t\t\t\tBIT(3)\n#define MAX8973_FREQSHIFT_9PER\t\t\t\tBIT(2)\n\n#define MAX8973_RAMP_12mV_PER_US\t\t\t0x0\n#define MAX8973_RAMP_25mV_PER_US\t\t\t0x1\n#define MAX8973_RAMP_50mV_PER_US\t\t\t0x2\n#define MAX8973_RAMP_200mV_PER_US\t\t\t0x3\n#define MAX8973_RAMP_MASK\t\t\t\t0x3\n\n \n#define MAX8973_WDTMR_ENABLE\t\t\t\tBIT(6)\n#define MAX8973_DISCH_ENBABLE\t\t\t\tBIT(5)\n#define MAX8973_FT_ENABLE\t\t\t\tBIT(4)\n#define MAX77621_T_JUNCTION_120\t\t\t\tBIT(7)\n\n#define MAX8973_CKKADV_TRIP_MASK\t\t\t0xC\n#define MAX8973_CKKADV_TRIP_DISABLE\t\t\t0xC\n#define MAX8973_CKKADV_TRIP_75mV_PER_US\t\t\t0x0\n#define MAX8973_CKKADV_TRIP_150mV_PER_US\t\t0x4\n#define MAX8973_CKKADV_TRIP_75mV_PER_US_HIST_DIS\t0x8\n#define MAX8973_CONTROL_CLKADV_TRIP_MASK\t\t0x00030000\n\n#define MAX8973_INDUCTOR_MIN_30_PER\t\t\t0x0\n#define MAX8973_INDUCTOR_NOMINAL\t\t\t0x1\n#define MAX8973_INDUCTOR_PLUS_30_PER\t\t\t0x2\n#define MAX8973_INDUCTOR_PLUS_60_PER\t\t\t0x3\n#define MAX8973_CONTROL_INDUCTOR_VALUE_MASK\t\t0x00300000\n\n#define MAX8973_MIN_VOLATGE\t\t\t\t606250\n#define MAX8973_MAX_VOLATGE\t\t\t\t1400000\n#define MAX8973_VOLATGE_STEP\t\t\t\t6250\n#define MAX8973_BUCK_N_VOLTAGE\t\t\t\t0x80\n\n#define MAX77621_CHIPID_TJINT_S\t\t\t\tBIT(0)\n\n#define MAX77621_NORMAL_OPERATING_TEMP\t\t\t100000\n#define MAX77621_TJINT_WARNING_TEMP_120\t\t\t120000\n#define MAX77621_TJINT_WARNING_TEMP_140\t\t\t140000\n\nenum device_id {\n\tMAX8973,\n\tMAX77621\n};\n\n \nstruct max8973_chip {\n\tstruct device *dev;\n\tstruct regulator_desc desc;\n\tstruct regmap *regmap;\n\tbool enable_external_control;\n\tint dvs_gpio;\n\tint lru_index[MAX8973_MAX_VOUT_REG];\n\tint curr_vout_val[MAX8973_MAX_VOUT_REG];\n\tint curr_vout_reg;\n\tint curr_gpio_val;\n\tstruct regulator_ops ops;\n\tenum device_id id;\n\tint junction_temp_warning;\n\tint irq;\n\tstruct thermal_zone_device *tz_device;\n};\n\n \nstatic bool find_voltage_set_register(struct max8973_chip *tps,\n\t\tint req_vsel, int *vout_reg, int *gpio_val)\n{\n\tint i;\n\tbool found = false;\n\tint new_vout_reg = tps->lru_index[MAX8973_MAX_VOUT_REG - 1];\n\tint found_index = MAX8973_MAX_VOUT_REG - 1;\n\n\tfor (i = 0; i < MAX8973_MAX_VOUT_REG; ++i) {\n\t\tif (tps->curr_vout_val[tps->lru_index[i]] == req_vsel) {\n\t\t\tnew_vout_reg = tps->lru_index[i];\n\t\t\tfound_index = i;\n\t\t\tfound = true;\n\t\t\tgoto update_lru_index;\n\t\t}\n\t}\n\nupdate_lru_index:\n\tfor (i = found_index; i > 0; i--)\n\t\ttps->lru_index[i] = tps->lru_index[i - 1];\n\n\ttps->lru_index[0] = new_vout_reg;\n\t*gpio_val = new_vout_reg;\n\t*vout_reg = MAX8973_VOUT + new_vout_reg;\n\treturn found;\n}\n\nstatic int max8973_dcdc_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct max8973_chip *max = rdev_get_drvdata(rdev);\n\tunsigned int data;\n\tint ret;\n\n\tret = regmap_read(max->regmap, max->curr_vout_reg, &data);\n\tif (ret < 0) {\n\t\tdev_err(max->dev, \"register %d read failed, err = %d\\n\",\n\t\t\tmax->curr_vout_reg, ret);\n\t\treturn ret;\n\t}\n\treturn data & MAX8973_VOUT_MASK;\n}\n\nstatic int max8973_dcdc_set_voltage_sel(struct regulator_dev *rdev,\n\t     unsigned vsel)\n{\n\tstruct max8973_chip *max = rdev_get_drvdata(rdev);\n\tint ret;\n\tbool found = false;\n\tint vout_reg = max->curr_vout_reg;\n\tint gpio_val = max->curr_gpio_val;\n\n\t \n\tif (gpio_is_valid(max->dvs_gpio))\n\t\tfound = find_voltage_set_register(max, vsel,\n\t\t\t\t\t&vout_reg, &gpio_val);\n\n\tif (!found) {\n\t\tret = regmap_update_bits(max->regmap, vout_reg,\n\t\t\t\t\tMAX8973_VOUT_MASK, vsel);\n\t\tif (ret < 0) {\n\t\t\tdev_err(max->dev, \"register %d update failed, err %d\\n\",\n\t\t\t\t vout_reg, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tmax->curr_vout_reg = vout_reg;\n\t\tmax->curr_vout_val[gpio_val] = vsel;\n\t}\n\n\t \n\tif (gpio_is_valid(max->dvs_gpio)) {\n\t\tgpio_set_value_cansleep(max->dvs_gpio, gpio_val & 0x1);\n\t\tmax->curr_gpio_val = gpio_val;\n\t}\n\treturn 0;\n}\n\nstatic int max8973_dcdc_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct max8973_chip *max = rdev_get_drvdata(rdev);\n\tint ret;\n\tint pwm;\n\n\t \n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tpwm = MAX8973_FPWM_EN_M;\n\t\tbreak;\n\n\tcase REGULATOR_MODE_NORMAL:\n\t\tpwm = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(max->regmap, MAX8973_CONTROL1,\n\t\t\t\tMAX8973_FPWM_EN_M, pwm);\n\tif (ret < 0)\n\t\tdev_err(max->dev, \"register %d update failed, err %d\\n\",\n\t\t\t\tMAX8973_CONTROL1, ret);\n\treturn ret;\n}\n\nstatic unsigned int max8973_dcdc_get_mode(struct regulator_dev *rdev)\n{\n\tstruct max8973_chip *max = rdev_get_drvdata(rdev);\n\tunsigned int data;\n\tint ret;\n\n\tret = regmap_read(max->regmap, MAX8973_CONTROL1, &data);\n\tif (ret < 0) {\n\t\tdev_err(max->dev, \"register %d read failed, err %d\\n\",\n\t\t\t\tMAX8973_CONTROL1, ret);\n\t\treturn ret;\n\t}\n\treturn (data & MAX8973_FPWM_EN_M) ?\n\t\tREGULATOR_MODE_FAST : REGULATOR_MODE_NORMAL;\n}\n\nstatic int max8973_set_current_limit(struct regulator_dev *rdev,\n\t\tint min_ua, int max_ua)\n{\n\tstruct max8973_chip *max = rdev_get_drvdata(rdev);\n\tunsigned int val;\n\tint ret;\n\n\tif (max_ua <= 9000000)\n\t\tval = MAX8973_CKKADV_TRIP_75mV_PER_US;\n\telse if (max_ua <= 12000000)\n\t\tval = MAX8973_CKKADV_TRIP_150mV_PER_US;\n\telse\n\t\tval = MAX8973_CKKADV_TRIP_DISABLE;\n\n\tret = regmap_update_bits(max->regmap, MAX8973_CONTROL2,\n\t\t\tMAX8973_CKKADV_TRIP_MASK, val);\n\tif (ret < 0) {\n\t\tdev_err(max->dev, \"register %d update failed: %d\\n\",\n\t\t\t\tMAX8973_CONTROL2, ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int max8973_get_current_limit(struct regulator_dev *rdev)\n{\n\tstruct max8973_chip *max = rdev_get_drvdata(rdev);\n\tunsigned int control2;\n\tint ret;\n\n\tret = regmap_read(max->regmap, MAX8973_CONTROL2, &control2);\n\tif (ret < 0) {\n\t\tdev_err(max->dev, \"register %d read failed: %d\\n\",\n\t\t\t\tMAX8973_CONTROL2, ret);\n\t\treturn ret;\n\t}\n\tswitch (control2 & MAX8973_CKKADV_TRIP_MASK) {\n\tcase MAX8973_CKKADV_TRIP_DISABLE:\n\t\treturn 15000000;\n\tcase MAX8973_CKKADV_TRIP_150mV_PER_US:\n\t\treturn 12000000;\n\tcase MAX8973_CKKADV_TRIP_75mV_PER_US:\n\t\treturn 9000000;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 9000000;\n}\n\nstatic const unsigned int max8973_buck_ramp_table[] = {\n\t12000, 25000, 50000, 200000\n};\n\nstatic const struct regulator_ops max8973_dcdc_ops = {\n\t.get_voltage_sel\t= max8973_dcdc_get_voltage_sel,\n\t.set_voltage_sel\t= max8973_dcdc_set_voltage_sel,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.set_mode\t\t= max8973_dcdc_set_mode,\n\t.get_mode\t\t= max8973_dcdc_get_mode,\n\t.set_voltage_time_sel\t= regulator_set_voltage_time_sel,\n\t.set_ramp_delay\t\t= regulator_set_ramp_delay_regmap,\n};\n\nstatic int max8973_init_dcdc(struct max8973_chip *max,\n\t\t\t     struct max8973_regulator_platform_data *pdata)\n{\n\tint ret;\n\tuint8_t\tcontrol1 = 0;\n\tuint8_t control2 = 0;\n\tunsigned int data;\n\n\tret = regmap_read(max->regmap, MAX8973_CONTROL1, &data);\n\tif (ret < 0) {\n\t\tdev_err(max->dev, \"register %d read failed, err = %d\",\n\t\t\t\tMAX8973_CONTROL1, ret);\n\t\treturn ret;\n\t}\n\tcontrol1 = data & MAX8973_RAMP_MASK;\n\tswitch (control1) {\n\tcase MAX8973_RAMP_12mV_PER_US:\n\t\tmax->desc.ramp_delay = 12000;\n\t\tbreak;\n\tcase MAX8973_RAMP_25mV_PER_US:\n\t\tmax->desc.ramp_delay = 25000;\n\t\tbreak;\n\tcase MAX8973_RAMP_50mV_PER_US:\n\t\tmax->desc.ramp_delay = 50000;\n\t\tbreak;\n\tcase MAX8973_RAMP_200mV_PER_US:\n\t\tmax->desc.ramp_delay = 200000;\n\t\tbreak;\n\t}\n\n\tif (pdata->control_flags & MAX8973_CONTROL_REMOTE_SENSE_ENABLE)\n\t\tcontrol1 |= MAX8973_SNS_ENABLE;\n\n\tif (!(pdata->control_flags & MAX8973_CONTROL_FALLING_SLEW_RATE_ENABLE))\n\t\tcontrol1 |= MAX8973_NFSR_ENABLE;\n\n\tif (pdata->control_flags & MAX8973_CONTROL_OUTPUT_ACTIVE_DISCH_ENABLE)\n\t\tcontrol1 |= MAX8973_AD_ENABLE;\n\n\tif (pdata->control_flags & MAX8973_CONTROL_BIAS_ENABLE) {\n\t\tcontrol1 |= MAX8973_BIAS_ENABLE;\n\t\tmax->desc.enable_time = 20;\n\t} else {\n\t\tmax->desc.enable_time = 240;\n\t}\n\n\tif (pdata->control_flags & MAX8973_CONTROL_FREQ_SHIFT_9PER_ENABLE)\n\t\tcontrol1 |= MAX8973_FREQSHIFT_9PER;\n\n\tif ((pdata->junction_temp_warning == MAX77621_TJINT_WARNING_TEMP_120) &&\n\t    (max->id == MAX77621))\n\t\tcontrol2 |= MAX77621_T_JUNCTION_120;\n\n\tif (!(pdata->control_flags & MAX8973_CONTROL_PULL_DOWN_ENABLE))\n\t\tcontrol2 |= MAX8973_DISCH_ENBABLE;\n\n\t \n\tswitch (pdata->control_flags & MAX8973_CONTROL_CLKADV_TRIP_MASK) {\n\tcase MAX8973_CONTROL_CLKADV_TRIP_DISABLED:\n\t\tcontrol2 |= MAX8973_CKKADV_TRIP_DISABLE;\n\t\tbreak;\n\n\tcase MAX8973_CONTROL_CLKADV_TRIP_75mV_PER_US:\n\t\tcontrol2 |= MAX8973_CKKADV_TRIP_75mV_PER_US;\n\t\tbreak;\n\n\tcase MAX8973_CONTROL_CLKADV_TRIP_150mV_PER_US:\n\t\tcontrol2 |= MAX8973_CKKADV_TRIP_150mV_PER_US;\n\t\tbreak;\n\n\tcase MAX8973_CONTROL_CLKADV_TRIP_75mV_PER_US_HIST_DIS:\n\t\tcontrol2 |= MAX8973_CKKADV_TRIP_75mV_PER_US_HIST_DIS;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (pdata->control_flags & MAX8973_CONTROL_INDUCTOR_VALUE_MASK) {\n\tcase MAX8973_CONTROL_INDUCTOR_VALUE_NOMINAL:\n\t\tcontrol2 |= MAX8973_INDUCTOR_NOMINAL;\n\t\tbreak;\n\n\tcase MAX8973_CONTROL_INDUCTOR_VALUE_MINUS_30_PER:\n\t\tcontrol2 |= MAX8973_INDUCTOR_MIN_30_PER;\n\t\tbreak;\n\n\tcase MAX8973_CONTROL_INDUCTOR_VALUE_PLUS_30_PER:\n\t\tcontrol2 |= MAX8973_INDUCTOR_PLUS_30_PER;\n\t\tbreak;\n\n\tcase MAX8973_CONTROL_INDUCTOR_VALUE_PLUS_60_PER:\n\t\tcontrol2 |= MAX8973_INDUCTOR_PLUS_60_PER;\n\t\tbreak;\n\t}\n\n\tret = regmap_write(max->regmap, MAX8973_CONTROL1, control1);\n\tif (ret < 0) {\n\t\tdev_err(max->dev, \"register %d write failed, err = %d\",\n\t\t\t\tMAX8973_CONTROL1, ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(max->regmap, MAX8973_CONTROL2, control2);\n\tif (ret < 0) {\n\t\tdev_err(max->dev, \"register %d write failed, err = %d\",\n\t\t\t\tMAX8973_CONTROL2, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (max->enable_external_control && (max->id == MAX8973)) {\n\t\tret = regmap_update_bits(max->regmap, MAX8973_VOUT,\n\t\t\t\t\t\tMAX8973_VOUT_ENABLE, 0);\n\t\tif (ret < 0)\n\t\t\tdev_err(max->dev, \"register %d update failed, err = %d\",\n\t\t\t\tMAX8973_VOUT, ret);\n\t}\n\treturn ret;\n}\n\nstatic int max8973_thermal_read_temp(struct thermal_zone_device *tz, int *temp)\n{\n\tstruct max8973_chip *mchip = thermal_zone_device_priv(tz);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(mchip->regmap, MAX8973_CHIPID1, &val);\n\tif (ret < 0) {\n\t\tdev_err(mchip->dev, \"Failed to read register CHIPID1, %d\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (val & MAX77621_CHIPID_TJINT_S)\n\t\t*temp = mchip->junction_temp_warning + 1000;\n\telse\n\t\t*temp = MAX77621_NORMAL_OPERATING_TEMP;\n\n\treturn 0;\n}\n\nstatic irqreturn_t max8973_thermal_irq(int irq, void *data)\n{\n\tstruct max8973_chip *mchip = data;\n\n\tthermal_zone_device_update(mchip->tz_device,\n\t\t\t\t   THERMAL_EVENT_UNSPECIFIED);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct thermal_zone_device_ops max77621_tz_ops = {\n\t.get_temp = max8973_thermal_read_temp,\n};\n\nstatic int max8973_thermal_init(struct max8973_chip *mchip)\n{\n\tstruct thermal_zone_device *tzd;\n\tstruct irq_data *irq_data;\n\tunsigned long irq_flags = 0;\n\tint ret;\n\n\tif (mchip->id != MAX77621)\n\t\treturn 0;\n\n\ttzd = devm_thermal_of_zone_register(mchip->dev, 0, mchip,\n\t\t\t\t\t    &max77621_tz_ops);\n\tif (IS_ERR(tzd)) {\n\t\tret = PTR_ERR(tzd);\n\t\tdev_err(mchip->dev, \"Failed to register thermal sensor: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (mchip->irq <= 0)\n\t\treturn 0;\n\n\tirq_data = irq_get_irq_data(mchip->irq);\n\tif (irq_data)\n\t\tirq_flags = irqd_get_trigger_type(irq_data);\n\n\tret = devm_request_threaded_irq(mchip->dev, mchip->irq, NULL,\n\t\t\t\t\tmax8973_thermal_irq,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED | irq_flags,\n\t\t\t\t\tdev_name(mchip->dev), mchip);\n\tif (ret < 0) {\n\t\tdev_err(mchip->dev, \"Failed to request irq %d, %d\\n\",\n\t\t\tmchip->irq, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_config max8973_regmap_config = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\t.max_register\t\t= MAX8973_CHIPID2,\n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\nstatic struct max8973_regulator_platform_data *max8973_parse_dt(\n\t\tstruct device *dev)\n{\n\tstruct max8973_regulator_platform_data *pdata;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\tu32 pval;\n\tbool etr_enable;\n\tbool etr_sensitivity_high;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tpdata->enable_ext_control = of_property_read_bool(np,\n\t\t\t\t\t\t\"maxim,externally-enable\");\n\tpdata->dvs_gpio = of_get_named_gpio(np, \"maxim,dvs-gpio\", 0);\n\n\tret = of_property_read_u32(np, \"maxim,dvs-default-state\", &pval);\n\tif (!ret)\n\t\tpdata->dvs_def_state = pval;\n\n\tif (of_property_read_bool(np, \"maxim,enable-remote-sense\"))\n\t\tpdata->control_flags  |= MAX8973_CONTROL_REMOTE_SENSE_ENABLE;\n\n\tif (of_property_read_bool(np, \"maxim,enable-falling-slew-rate\"))\n\t\tpdata->control_flags  |=\n\t\t\t\tMAX8973_CONTROL_FALLING_SLEW_RATE_ENABLE;\n\n\tif (of_property_read_bool(np, \"maxim,enable-active-discharge\"))\n\t\tpdata->control_flags  |=\n\t\t\t\tMAX8973_CONTROL_OUTPUT_ACTIVE_DISCH_ENABLE;\n\n\tif (of_property_read_bool(np, \"maxim,enable-frequency-shift\"))\n\t\tpdata->control_flags  |= MAX8973_CONTROL_FREQ_SHIFT_9PER_ENABLE;\n\n\tif (of_property_read_bool(np, \"maxim,enable-bias-control\"))\n\t\tpdata->control_flags  |= MAX8973_CONTROL_BIAS_ENABLE;\n\n\tetr_enable = of_property_read_bool(np, \"maxim,enable-etr\");\n\tetr_sensitivity_high = of_property_read_bool(np,\n\t\t\t\t\"maxim,enable-high-etr-sensitivity\");\n\tif (etr_sensitivity_high)\n\t\tetr_enable = true;\n\n\tif (etr_enable) {\n\t\tif (etr_sensitivity_high)\n\t\t\tpdata->control_flags |=\n\t\t\t\tMAX8973_CONTROL_CLKADV_TRIP_75mV_PER_US;\n\t\telse\n\t\t\tpdata->control_flags |=\n\t\t\t\tMAX8973_CONTROL_CLKADV_TRIP_150mV_PER_US;\n\t} else {\n\t\tpdata->control_flags |= MAX8973_CONTROL_CLKADV_TRIP_DISABLED;\n\t}\n\n\tpdata->junction_temp_warning = MAX77621_TJINT_WARNING_TEMP_140;\n\tret = of_property_read_u32(np, \"junction-warn-millicelsius\", &pval);\n\tif (!ret && (pval <= MAX77621_TJINT_WARNING_TEMP_120))\n\t\tpdata->junction_temp_warning = MAX77621_TJINT_WARNING_TEMP_120;\n\n\treturn pdata;\n}\n\nstatic const struct of_device_id of_max8973_match_tbl[] = {\n\t{ .compatible = \"maxim,max8973\", .data = (void *)MAX8973, },\n\t{ .compatible = \"maxim,max77621\", .data = (void *)MAX77621, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, of_max8973_match_tbl);\n\nstatic int max8973_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct max8973_regulator_platform_data *pdata;\n\tstruct regulator_init_data *ridata;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tstruct max8973_chip *max;\n\tbool pdata_from_dt = false;\n\tunsigned int chip_id;\n\tstruct gpio_desc *gpiod;\n\tenum gpiod_flags gflags;\n\tint ret;\n\n\tpdata = dev_get_platdata(&client->dev);\n\n\tif (!pdata && client->dev.of_node) {\n\t\tpdata = max8973_parse_dt(&client->dev);\n\t\tpdata_from_dt = true;\n\t}\n\n\tif (!pdata) {\n\t\tdev_err(&client->dev, \"No Platform data\");\n\t\treturn -EIO;\n\t}\n\n\tif (pdata->dvs_gpio == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tmax = devm_kzalloc(&client->dev, sizeof(*max), GFP_KERNEL);\n\tif (!max)\n\t\treturn -ENOMEM;\n\n\tmax->regmap = devm_regmap_init_i2c(client, &max8973_regmap_config);\n\tif (IS_ERR(max->regmap)) {\n\t\tret = PTR_ERR(max->regmap);\n\t\tdev_err(&client->dev, \"regmap init failed, err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (client->dev.of_node) {\n\t\tconst struct of_device_id *match;\n\n\t\tmatch = of_match_device(of_match_ptr(of_max8973_match_tbl),\n\t\t\t\t&client->dev);\n\t\tif (!match)\n\t\t\treturn -ENODATA;\n\t\tmax->id = (u32)((uintptr_t)match->data);\n\t} else {\n\t\tmax->id = id->driver_data;\n\t}\n\n\tret = regmap_read(max->regmap, MAX8973_CHIPID1, &chip_id);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"register CHIPID1 read failed, %d\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_info(&client->dev, \"CHIP-ID OTP: 0x%02x ID_M: 0x%02x\\n\",\n\t\t\t(chip_id >> 4) & 0xF, (chip_id >> 1) & 0x7);\n\n\ti2c_set_clientdata(client, max);\n\tmax->ops = max8973_dcdc_ops;\n\tmax->dev = &client->dev;\n\tmax->desc.name = id->name;\n\tmax->desc.id = 0;\n\tmax->desc.ops = &max->ops;\n\tmax->desc.type = REGULATOR_VOLTAGE;\n\tmax->desc.owner = THIS_MODULE;\n\tmax->desc.min_uV = MAX8973_MIN_VOLATGE;\n\tmax->desc.uV_step = MAX8973_VOLATGE_STEP;\n\tmax->desc.n_voltages = MAX8973_BUCK_N_VOLTAGE;\n\tmax->desc.ramp_reg = MAX8973_CONTROL1;\n\tmax->desc.ramp_mask = MAX8973_RAMP_MASK;\n\tmax->desc.ramp_delay_table = max8973_buck_ramp_table;\n\tmax->desc.n_ramp_values = ARRAY_SIZE(max8973_buck_ramp_table);\n\n\tmax->dvs_gpio = (pdata->dvs_gpio) ? pdata->dvs_gpio : -EINVAL;\n\tmax->enable_external_control = pdata->enable_ext_control;\n\tmax->curr_gpio_val = pdata->dvs_def_state;\n\tmax->curr_vout_reg = MAX8973_VOUT + pdata->dvs_def_state;\n\tmax->junction_temp_warning = pdata->junction_temp_warning;\n\n\tmax->lru_index[0] = max->curr_vout_reg;\n\n\tif (gpio_is_valid(max->dvs_gpio)) {\n\t\tint gpio_flags;\n\t\tint i;\n\n\t\tgpio_flags = (pdata->dvs_def_state) ?\n\t\t\t\tGPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;\n\t\tret = devm_gpio_request_one(&client->dev, max->dvs_gpio,\n\t\t\t\tgpio_flags, \"max8973-dvs\");\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"gpio_request for gpio %d failed, err = %d\\n\",\n\t\t\t\tmax->dvs_gpio, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < MAX8973_MAX_VOUT_REG; ++i)\n\t\t\tmax->lru_index[i] = i;\n\t\tmax->lru_index[0] = max->curr_vout_reg;\n\t\tmax->lru_index[max->curr_vout_reg] = 0;\n\t} else {\n\t\t \n\t\tmax->ops.set_voltage_sel = regulator_set_voltage_sel_regmap;\n\t\tmax->ops.get_voltage_sel = regulator_get_voltage_sel_regmap;\n\t\tmax->desc.vsel_reg = max->curr_vout_reg;\n\t\tmax->desc.vsel_mask = MAX8973_VOUT_MASK;\n\t}\n\n\tif (pdata_from_dt)\n\t\tpdata->reg_init_data = of_get_regulator_init_data(&client->dev,\n\t\t\t\t\tclient->dev.of_node, &max->desc);\n\n\tridata = pdata->reg_init_data;\n\tswitch (max->id) {\n\tcase MAX8973:\n\t\tif (!pdata->enable_ext_control) {\n\t\t\tmax->desc.enable_reg = MAX8973_VOUT;\n\t\t\tmax->desc.enable_mask = MAX8973_VOUT_ENABLE;\n\t\t\tmax->ops.enable = regulator_enable_regmap;\n\t\t\tmax->ops.disable = regulator_disable_regmap;\n\t\t\tmax->ops.is_enabled = regulator_is_enabled_regmap;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ridata && (ridata->constraints.always_on ||\n\t\t\t       ridata->constraints.boot_on))\n\t\t\tgflags = GPIOD_OUT_HIGH;\n\t\telse\n\t\t\tgflags = GPIOD_OUT_LOW;\n\t\tgflags |= GPIOD_FLAGS_BIT_NONEXCLUSIVE;\n\t\tgpiod = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t\"maxim,enable\",\n\t\t\t\t\t\tgflags);\n\t\tif (IS_ERR(gpiod))\n\t\t\treturn PTR_ERR(gpiod);\n\t\tif (gpiod) {\n\t\t\tconfig.ena_gpiod = gpiod;\n\t\t\tmax->enable_external_control = true;\n\t\t}\n\n\t\tbreak;\n\n\tcase MAX77621:\n\t\t \n\t\tgpiod = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t\"maxim,enable\",\n\t\t\t\t\t\tGPIOD_OUT_HIGH);\n\t\tif (IS_ERR(gpiod))\n\t\t\treturn PTR_ERR(gpiod);\n\t\tif (gpiod)\n\t\t\tmax->enable_external_control = true;\n\n\t\tmax->desc.enable_reg = MAX8973_VOUT;\n\t\tmax->desc.enable_mask = MAX8973_VOUT_ENABLE;\n\t\tmax->ops.enable = regulator_enable_regmap;\n\t\tmax->ops.disable = regulator_disable_regmap;\n\t\tmax->ops.is_enabled = regulator_is_enabled_regmap;\n\t\tmax->ops.set_current_limit = max8973_set_current_limit;\n\t\tmax->ops.get_current_limit = max8973_get_current_limit;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = max8973_init_dcdc(max, pdata);\n\tif (ret < 0) {\n\t\tdev_err(max->dev, \"Max8973 Init failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tconfig.dev = &client->dev;\n\tconfig.init_data = pdata->reg_init_data;\n\tconfig.driver_data = max;\n\tconfig.of_node = client->dev.of_node;\n\tconfig.regmap = max->regmap;\n\n\t \n\tif (config.ena_gpiod)\n\t\tdevm_gpiod_unhinge(&client->dev, config.ena_gpiod);\n\trdev = devm_regulator_register(&client->dev, &max->desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\t\tdev_err(max->dev, \"regulator register failed, err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmax8973_thermal_init(max);\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max8973_id[] = {\n\t{.name = \"max8973\", .driver_data = MAX8973},\n\t{.name = \"max77621\", .driver_data = MAX77621},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, max8973_id);\n\nstatic struct i2c_driver max8973_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max8973\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_max8973_match_tbl,\n\t},\n\t.probe = max8973_probe,\n\t.id_table = max8973_id,\n};\n\nstatic int __init max8973_init(void)\n{\n\treturn i2c_add_driver(&max8973_i2c_driver);\n}\nsubsys_initcall(max8973_init);\n\nstatic void __exit max8973_cleanup(void)\n{\n\ti2c_del_driver(&max8973_i2c_driver);\n}\nmodule_exit(max8973_cleanup);\n\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_DESCRIPTION(\"MAX8973 voltage regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}