{
  "module_name": "lp872x.c",
  "hash_id": "913f1d3fb19b52768a95413d7d183e8b6d73d3469f241f5c5e30fcf43897ecd4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/lp872x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/regulator/lp872x.h>\n#include <linux/regulator/driver.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/regulator/of_regulator.h>\n\n \n#define LP872X_GENERAL_CFG\t\t0x00\n#define LP872X_LDO1_VOUT\t\t0x01\n#define LP872X_LDO2_VOUT\t\t0x02\n#define LP872X_LDO3_VOUT\t\t0x03\n#define LP872X_LDO4_VOUT\t\t0x04\n#define LP872X_LDO5_VOUT\t\t0x05\n\n \n#define LP8720_BUCK_VOUT1\t\t0x06\n#define LP8720_BUCK_VOUT2\t\t0x07\n#define LP8720_ENABLE\t\t\t0x08\n\n \n#define LP8725_LILO1_VOUT\t\t0x06\n#define LP8725_LILO2_VOUT\t\t0x07\n#define LP8725_BUCK1_VOUT1\t\t0x08\n#define LP8725_BUCK1_VOUT2\t\t0x09\n#define LP8725_BUCK2_VOUT1\t\t0x0A\n#define LP8725_BUCK2_VOUT2\t\t0x0B\n#define LP8725_BUCK_CTRL\t\t0x0C\n#define LP8725_LDO_CTRL\t\t\t0x0D\n\n \n#define LP872X_VOUT_M\t\t\t0x1F\n#define LP872X_START_DELAY_M\t\t0xE0\n#define LP872X_START_DELAY_S\t\t5\n#define LP872X_EN_LDO1_M\t\tBIT(0)\n#define LP872X_EN_LDO2_M\t\tBIT(1)\n#define LP872X_EN_LDO3_M\t\tBIT(2)\n#define LP872X_EN_LDO4_M\t\tBIT(3)\n#define LP872X_EN_LDO5_M\t\tBIT(4)\n\n \n#define LP8720_TIMESTEP_S\t\t0\t\t \n#define LP8720_TIMESTEP_M\t\tBIT(0)\n#define LP8720_EXT_DVS_M\t\tBIT(2)\n#define LP8720_BUCK_FPWM_S\t\t5\t\t \n#define LP8720_BUCK_FPWM_M\t\tBIT(5)\n#define LP8720_EN_BUCK_M\t\tBIT(5)\t\t \n#define LP8720_DVS_SEL_M\t\tBIT(7)\n\n \n#define LP8725_TIMESTEP_M\t\t0xC0\t\t \n#define LP8725_TIMESTEP_S\t\t6\n#define LP8725_BUCK1_EN_M\t\tBIT(0)\n#define LP8725_DVS1_M\t\t\tBIT(2)\n#define LP8725_DVS2_M\t\t\tBIT(3)\n#define LP8725_BUCK2_EN_M\t\tBIT(4)\n#define LP8725_BUCK_CL_M\t\t0xC0\t\t \n#define LP8725_BUCK_CL_S\t\t6\n#define LP8725_BUCK1_FPWM_S\t\t1\t\t \n#define LP8725_BUCK1_FPWM_M\t\tBIT(1)\n#define LP8725_BUCK2_FPWM_S\t\t5\n#define LP8725_BUCK2_FPWM_M\t\tBIT(5)\n#define LP8725_EN_LILO1_M\t\tBIT(5)\t\t \n#define LP8725_EN_LILO2_M\t\tBIT(6)\n\n \n#define LP872X_FORCE_PWM\t\t1\n#define LP872X_AUTO_PWM\t\t\t0\n\n#define LP8720_NUM_REGULATORS\t\t6\n#define LP8725_NUM_REGULATORS\t\t9\n#define EXTERN_DVS_USED\t\t\t0\n#define MAX_DELAY\t\t\t6\n\n \n#define LP8720_DEFAULT_DVS\t\t0\n#define LP8725_DEFAULT_DVS\t\tBIT(2)\n\n \n#define MAX_REGISTERS\t\t\t0x0F\n\nenum lp872x_id {\n\tLP8720,\n\tLP8725,\n};\n\nstruct lp872x {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tenum lp872x_id chipid;\n\tstruct lp872x_platform_data *pdata;\n\tint num_regulators;\n\tenum gpiod_flags dvs_pin;\n};\n\n \nstatic const unsigned int lp872x_ldo_vtbl[] = {\n\t1200000, 1250000, 1300000, 1350000, 1400000, 1450000, 1500000, 1550000,\n\t1600000, 1650000, 1700000, 1750000, 1800000, 1850000, 1900000, 2000000,\n\t2100000, 2200000, 2300000, 2400000, 2500000, 2600000, 2650000, 2700000,\n\t2750000, 2800000, 2850000, 2900000, 2950000, 3000000, 3100000, 3300000,\n};\n\n \nstatic const unsigned int lp8720_ldo4_vtbl[] = {\n\t 800000,  850000,  900000, 1000000, 1100000, 1200000, 1250000, 1300000,\n\t1350000, 1400000, 1450000, 1500000, 1550000, 1600000, 1650000, 1700000,\n\t1750000, 1800000, 1850000, 1900000, 2000000, 2100000, 2200000, 2300000,\n\t2400000, 2500000, 2600000, 2650000, 2700000, 2750000, 2800000, 2850000,\n};\n\n \nstatic const unsigned int lp8725_lilo_vtbl[] = {\n\t 800000,  850000,  900000,  950000, 1000000, 1050000, 1100000, 1150000,\n\t1200000, 1250000, 1300000, 1350000, 1400000, 1500000, 1600000, 1700000,\n\t1800000, 1900000, 2000000, 2100000, 2200000, 2300000, 2400000, 2500000,\n\t2600000, 2700000, 2800000, 2850000, 2900000, 3000000, 3100000, 3300000,\n};\n\n \n#define EXT_R\t\t0\t \nstatic const unsigned int lp8720_buck_vtbl[] = {\n\t  EXT_R,  800000,  850000,  900000,  950000, 1000000, 1050000, 1100000,\n\t1150000, 1200000, 1250000, 1300000, 1350000, 1400000, 1450000, 1500000,\n\t1550000, 1600000, 1650000, 1700000, 1750000, 1800000, 1850000, 1900000,\n\t1950000, 2000000, 2050000, 2100000, 2150000, 2200000, 2250000, 2300000,\n};\n\n \nstatic const unsigned int lp8725_buck_vtbl[] = {\n\t 800000,  850000,  900000,  950000, 1000000, 1050000, 1100000, 1150000,\n\t1200000, 1250000, 1300000, 1350000, 1400000, 1500000, 1600000, 1700000,\n\t1750000, 1800000, 1850000, 1900000, 2000000, 2100000, 2200000, 2300000,\n\t2400000, 2500000, 2600000, 2700000, 2800000, 2850000, 2900000, 3000000,\n};\n\n \nstatic const unsigned int lp8725_buck_uA[] = {\n\t460000, 780000, 1050000, 1370000,\n};\n\nstatic int lp872x_read_byte(struct lp872x *lp, u8 addr, u8 *data)\n{\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(lp->regmap, addr, &val);\n\tif (ret < 0) {\n\t\tdev_err(lp->dev, \"failed to read 0x%.2x\\n\", addr);\n\t\treturn ret;\n\t}\n\n\t*data = (u8)val;\n\treturn 0;\n}\n\nstatic inline int lp872x_write_byte(struct lp872x *lp, u8 addr, u8 data)\n{\n\treturn regmap_write(lp->regmap, addr, data);\n}\n\nstatic inline int lp872x_update_bits(struct lp872x *lp, u8 addr,\n\t\t\t\tunsigned int mask, u8 data)\n{\n\treturn regmap_update_bits(lp->regmap, addr, mask, data);\n}\n\nstatic int lp872x_get_timestep_usec(struct lp872x *lp)\n{\n\tenum lp872x_id chip = lp->chipid;\n\tu8 val, mask, shift;\n\tint *time_usec, size, ret;\n\tint lp8720_time_usec[] = { 25, 50 };\n\tint lp8725_time_usec[] = { 32, 64, 128, 256 };\n\n\tswitch (chip) {\n\tcase LP8720:\n\t\tmask = LP8720_TIMESTEP_M;\n\t\tshift = LP8720_TIMESTEP_S;\n\t\ttime_usec = &lp8720_time_usec[0];\n\t\tsize = ARRAY_SIZE(lp8720_time_usec);\n\t\tbreak;\n\tcase LP8725:\n\t\tmask = LP8725_TIMESTEP_M;\n\t\tshift = LP8725_TIMESTEP_S;\n\t\ttime_usec = &lp8725_time_usec[0];\n\t\tsize = ARRAY_SIZE(lp8725_time_usec);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = lp872x_read_byte(lp, LP872X_GENERAL_CFG, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = (val & mask) >> shift;\n\tif (val >= size)\n\t\treturn -EINVAL;\n\n\treturn *(time_usec + val);\n}\n\nstatic int lp872x_regulator_enable_time(struct regulator_dev *rdev)\n{\n\tstruct lp872x *lp = rdev_get_drvdata(rdev);\n\tenum lp872x_regulator_id rid = rdev_get_id(rdev);\n\tint time_step_us = lp872x_get_timestep_usec(lp);\n\tint ret;\n\tu8 addr, val;\n\n\tif (time_step_us < 0)\n\t\treturn time_step_us;\n\n\tswitch (rid) {\n\tcase LP8720_ID_LDO1 ... LP8720_ID_BUCK:\n\t\taddr = LP872X_LDO1_VOUT + rid;\n\t\tbreak;\n\tcase LP8725_ID_LDO1 ... LP8725_ID_BUCK1:\n\t\taddr = LP872X_LDO1_VOUT + rid - LP8725_ID_BASE;\n\t\tbreak;\n\tcase LP8725_ID_BUCK2:\n\t\taddr = LP8725_BUCK2_VOUT1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = lp872x_read_byte(lp, addr, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = (val & LP872X_START_DELAY_M) >> LP872X_START_DELAY_S;\n\n\treturn val > MAX_DELAY ? 0 : val * time_step_us;\n}\n\nstatic void lp872x_set_dvs(struct lp872x *lp, enum lp872x_dvs_sel dvs_sel,\n\t\t\tstruct gpio_desc *gpio)\n{\n\tenum gpiod_flags state;\n\n\tstate = dvs_sel == SEL_V1 ? GPIOD_OUT_HIGH : GPIOD_OUT_LOW;\n\tgpiod_set_value(gpio, state);\n\tlp->dvs_pin = state;\n}\n\nstatic u8 lp872x_select_buck_vout_addr(struct lp872x *lp,\n\t\t\t\tenum lp872x_regulator_id buck)\n{\n\tu8 val, addr;\n\n\tif (lp872x_read_byte(lp, LP872X_GENERAL_CFG, &val))\n\t\treturn 0;\n\n\tswitch (buck) {\n\tcase LP8720_ID_BUCK:\n\t\tif (val & LP8720_EXT_DVS_M) {\n\t\t\taddr = (lp->dvs_pin == GPIOD_OUT_HIGH) ?\n\t\t\t\tLP8720_BUCK_VOUT1 : LP8720_BUCK_VOUT2;\n\t\t} else {\n\t\t\tif (lp872x_read_byte(lp, LP8720_ENABLE, &val))\n\t\t\t\treturn 0;\n\n\t\t\taddr = val & LP8720_DVS_SEL_M ?\n\t\t\t\tLP8720_BUCK_VOUT1 : LP8720_BUCK_VOUT2;\n\t\t}\n\t\tbreak;\n\tcase LP8725_ID_BUCK1:\n\t\tif (val & LP8725_DVS1_M)\n\t\t\taddr = LP8725_BUCK1_VOUT1;\n\t\telse\n\t\t\taddr = (lp->dvs_pin == GPIOD_OUT_HIGH) ?\n\t\t\t\tLP8725_BUCK1_VOUT1 : LP8725_BUCK1_VOUT2;\n\t\tbreak;\n\tcase LP8725_ID_BUCK2:\n\t\taddr =  val & LP8725_DVS2_M ?\n\t\t\tLP8725_BUCK2_VOUT1 : LP8725_BUCK2_VOUT2;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn addr;\n}\n\nstatic bool lp872x_is_valid_buck_addr(u8 addr)\n{\n\tswitch (addr) {\n\tcase LP8720_BUCK_VOUT1:\n\tcase LP8720_BUCK_VOUT2:\n\tcase LP8725_BUCK1_VOUT1:\n\tcase LP8725_BUCK1_VOUT2:\n\tcase LP8725_BUCK2_VOUT1:\n\tcase LP8725_BUCK2_VOUT2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int lp872x_buck_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\tunsigned selector)\n{\n\tstruct lp872x *lp = rdev_get_drvdata(rdev);\n\tenum lp872x_regulator_id buck = rdev_get_id(rdev);\n\tu8 addr, mask = LP872X_VOUT_M;\n\tstruct lp872x_dvs *dvs = lp->pdata ? lp->pdata->dvs : NULL;\n\n\tif (dvs && dvs->gpio)\n\t\tlp872x_set_dvs(lp, dvs->vsel, dvs->gpio);\n\n\taddr = lp872x_select_buck_vout_addr(lp, buck);\n\tif (!lp872x_is_valid_buck_addr(addr))\n\t\treturn -EINVAL;\n\n\treturn lp872x_update_bits(lp, addr, mask, selector);\n}\n\nstatic int lp872x_buck_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct lp872x *lp = rdev_get_drvdata(rdev);\n\tenum lp872x_regulator_id buck = rdev_get_id(rdev);\n\tu8 addr, val;\n\tint ret;\n\n\taddr = lp872x_select_buck_vout_addr(lp, buck);\n\tif (!lp872x_is_valid_buck_addr(addr))\n\t\treturn -EINVAL;\n\n\tret = lp872x_read_byte(lp, addr, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val & LP872X_VOUT_M;\n}\n\nstatic int lp872x_buck_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct lp872x *lp = rdev_get_drvdata(rdev);\n\tenum lp872x_regulator_id buck = rdev_get_id(rdev);\n\tu8 addr, mask, shift, val;\n\n\tswitch (buck) {\n\tcase LP8720_ID_BUCK:\n\t\taddr = LP8720_BUCK_VOUT2;\n\t\tmask = LP8720_BUCK_FPWM_M;\n\t\tshift = LP8720_BUCK_FPWM_S;\n\t\tbreak;\n\tcase LP8725_ID_BUCK1:\n\t\taddr = LP8725_BUCK_CTRL;\n\t\tmask = LP8725_BUCK1_FPWM_M;\n\t\tshift = LP8725_BUCK1_FPWM_S;\n\t\tbreak;\n\tcase LP8725_ID_BUCK2:\n\t\taddr = LP8725_BUCK_CTRL;\n\t\tmask = LP8725_BUCK2_FPWM_M;\n\t\tshift = LP8725_BUCK2_FPWM_S;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode == REGULATOR_MODE_FAST)\n\t\tval = LP872X_FORCE_PWM << shift;\n\telse if (mode == REGULATOR_MODE_NORMAL)\n\t\tval = LP872X_AUTO_PWM << shift;\n\telse\n\t\treturn -EINVAL;\n\n\treturn lp872x_update_bits(lp, addr, mask, val);\n}\n\nstatic unsigned int lp872x_buck_get_mode(struct regulator_dev *rdev)\n{\n\tstruct lp872x *lp = rdev_get_drvdata(rdev);\n\tenum lp872x_regulator_id buck = rdev_get_id(rdev);\n\tu8 addr, mask, val;\n\tint ret;\n\n\tswitch (buck) {\n\tcase LP8720_ID_BUCK:\n\t\taddr = LP8720_BUCK_VOUT2;\n\t\tmask = LP8720_BUCK_FPWM_M;\n\t\tbreak;\n\tcase LP8725_ID_BUCK1:\n\t\taddr = LP8725_BUCK_CTRL;\n\t\tmask = LP8725_BUCK1_FPWM_M;\n\t\tbreak;\n\tcase LP8725_ID_BUCK2:\n\t\taddr = LP8725_BUCK_CTRL;\n\t\tmask = LP8725_BUCK2_FPWM_M;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = lp872x_read_byte(lp, addr, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val & mask ? REGULATOR_MODE_FAST : REGULATOR_MODE_NORMAL;\n}\n\nstatic const struct regulator_ops lp872x_ldo_ops = {\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable_time = lp872x_regulator_enable_time,\n};\n\nstatic const struct regulator_ops lp8720_buck_ops = {\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n\t.set_voltage_sel = lp872x_buck_set_voltage_sel,\n\t.get_voltage_sel = lp872x_buck_get_voltage_sel,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable_time = lp872x_regulator_enable_time,\n\t.set_mode = lp872x_buck_set_mode,\n\t.get_mode = lp872x_buck_get_mode,\n};\n\nstatic const struct regulator_ops lp8725_buck_ops = {\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n\t.set_voltage_sel = lp872x_buck_set_voltage_sel,\n\t.get_voltage_sel = lp872x_buck_get_voltage_sel,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable_time = lp872x_regulator_enable_time,\n\t.set_mode = lp872x_buck_set_mode,\n\t.get_mode = lp872x_buck_get_mode,\n\t.set_current_limit = regulator_set_current_limit_regmap,\n\t.get_current_limit = regulator_get_current_limit_regmap,\n};\n\nstatic const struct regulator_desc lp8720_regulator_desc[] = {\n\t{\n\t\t.name = \"ldo1\",\n\t\t.of_match = of_match_ptr(\"ldo1\"),\n\t\t.id = LP8720_ID_LDO1,\n\t\t.ops = &lp872x_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp872x_ldo_vtbl),\n\t\t.volt_table = lp872x_ldo_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP872X_LDO1_VOUT,\n\t\t.vsel_mask = LP872X_VOUT_M,\n\t\t.enable_reg = LP8720_ENABLE,\n\t\t.enable_mask = LP872X_EN_LDO1_M,\n\t},\n\t{\n\t\t.name = \"ldo2\",\n\t\t.of_match = of_match_ptr(\"ldo2\"),\n\t\t.id = LP8720_ID_LDO2,\n\t\t.ops = &lp872x_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp872x_ldo_vtbl),\n\t\t.volt_table = lp872x_ldo_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP872X_LDO2_VOUT,\n\t\t.vsel_mask = LP872X_VOUT_M,\n\t\t.enable_reg = LP8720_ENABLE,\n\t\t.enable_mask = LP872X_EN_LDO2_M,\n\t},\n\t{\n\t\t.name = \"ldo3\",\n\t\t.of_match = of_match_ptr(\"ldo3\"),\n\t\t.id = LP8720_ID_LDO3,\n\t\t.ops = &lp872x_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp872x_ldo_vtbl),\n\t\t.volt_table = lp872x_ldo_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP872X_LDO3_VOUT,\n\t\t.vsel_mask = LP872X_VOUT_M,\n\t\t.enable_reg = LP8720_ENABLE,\n\t\t.enable_mask = LP872X_EN_LDO3_M,\n\t},\n\t{\n\t\t.name = \"ldo4\",\n\t\t.of_match = of_match_ptr(\"ldo4\"),\n\t\t.id = LP8720_ID_LDO4,\n\t\t.ops = &lp872x_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp8720_ldo4_vtbl),\n\t\t.volt_table = lp8720_ldo4_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP872X_LDO4_VOUT,\n\t\t.vsel_mask = LP872X_VOUT_M,\n\t\t.enable_reg = LP8720_ENABLE,\n\t\t.enable_mask = LP872X_EN_LDO4_M,\n\t},\n\t{\n\t\t.name = \"ldo5\",\n\t\t.of_match = of_match_ptr(\"ldo5\"),\n\t\t.id = LP8720_ID_LDO5,\n\t\t.ops = &lp872x_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp872x_ldo_vtbl),\n\t\t.volt_table = lp872x_ldo_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP872X_LDO5_VOUT,\n\t\t.vsel_mask = LP872X_VOUT_M,\n\t\t.enable_reg = LP8720_ENABLE,\n\t\t.enable_mask = LP872X_EN_LDO5_M,\n\t},\n\t{\n\t\t.name = \"buck\",\n\t\t.of_match = of_match_ptr(\"buck\"),\n\t\t.id = LP8720_ID_BUCK,\n\t\t.ops = &lp8720_buck_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp8720_buck_vtbl),\n\t\t.volt_table = lp8720_buck_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.enable_reg = LP8720_ENABLE,\n\t\t.enable_mask = LP8720_EN_BUCK_M,\n\t},\n};\n\nstatic const struct regulator_desc lp8725_regulator_desc[] = {\n\t{\n\t\t.name = \"ldo1\",\n\t\t.of_match = of_match_ptr(\"ldo1\"),\n\t\t.id = LP8725_ID_LDO1,\n\t\t.ops = &lp872x_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp872x_ldo_vtbl),\n\t\t.volt_table = lp872x_ldo_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP872X_LDO1_VOUT,\n\t\t.vsel_mask = LP872X_VOUT_M,\n\t\t.enable_reg = LP8725_LDO_CTRL,\n\t\t.enable_mask = LP872X_EN_LDO1_M,\n\t},\n\t{\n\t\t.name = \"ldo2\",\n\t\t.of_match = of_match_ptr(\"ldo2\"),\n\t\t.id = LP8725_ID_LDO2,\n\t\t.ops = &lp872x_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp872x_ldo_vtbl),\n\t\t.volt_table = lp872x_ldo_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP872X_LDO2_VOUT,\n\t\t.vsel_mask = LP872X_VOUT_M,\n\t\t.enable_reg = LP8725_LDO_CTRL,\n\t\t.enable_mask = LP872X_EN_LDO2_M,\n\t},\n\t{\n\t\t.name = \"ldo3\",\n\t\t.of_match = of_match_ptr(\"ldo3\"),\n\t\t.id = LP8725_ID_LDO3,\n\t\t.ops = &lp872x_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp872x_ldo_vtbl),\n\t\t.volt_table = lp872x_ldo_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP872X_LDO3_VOUT,\n\t\t.vsel_mask = LP872X_VOUT_M,\n\t\t.enable_reg = LP8725_LDO_CTRL,\n\t\t.enable_mask = LP872X_EN_LDO3_M,\n\t},\n\t{\n\t\t.name = \"ldo4\",\n\t\t.of_match = of_match_ptr(\"ldo4\"),\n\t\t.id = LP8725_ID_LDO4,\n\t\t.ops = &lp872x_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp872x_ldo_vtbl),\n\t\t.volt_table = lp872x_ldo_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP872X_LDO4_VOUT,\n\t\t.vsel_mask = LP872X_VOUT_M,\n\t\t.enable_reg = LP8725_LDO_CTRL,\n\t\t.enable_mask = LP872X_EN_LDO4_M,\n\t},\n\t{\n\t\t.name = \"ldo5\",\n\t\t.of_match = of_match_ptr(\"ldo5\"),\n\t\t.id = LP8725_ID_LDO5,\n\t\t.ops = &lp872x_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp872x_ldo_vtbl),\n\t\t.volt_table = lp872x_ldo_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP872X_LDO5_VOUT,\n\t\t.vsel_mask = LP872X_VOUT_M,\n\t\t.enable_reg = LP8725_LDO_CTRL,\n\t\t.enable_mask = LP872X_EN_LDO5_M,\n\t},\n\t{\n\t\t.name = \"lilo1\",\n\t\t.of_match = of_match_ptr(\"lilo1\"),\n\t\t.id = LP8725_ID_LILO1,\n\t\t.ops = &lp872x_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp8725_lilo_vtbl),\n\t\t.volt_table = lp8725_lilo_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP8725_LILO1_VOUT,\n\t\t.vsel_mask = LP872X_VOUT_M,\n\t\t.enable_reg = LP8725_LDO_CTRL,\n\t\t.enable_mask = LP8725_EN_LILO1_M,\n\t},\n\t{\n\t\t.name = \"lilo2\",\n\t\t.of_match = of_match_ptr(\"lilo2\"),\n\t\t.id = LP8725_ID_LILO2,\n\t\t.ops = &lp872x_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp8725_lilo_vtbl),\n\t\t.volt_table = lp8725_lilo_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP8725_LILO2_VOUT,\n\t\t.vsel_mask = LP872X_VOUT_M,\n\t\t.enable_reg = LP8725_LDO_CTRL,\n\t\t.enable_mask = LP8725_EN_LILO2_M,\n\t},\n\t{\n\t\t.name = \"buck1\",\n\t\t.of_match = of_match_ptr(\"buck1\"),\n\t\t.id = LP8725_ID_BUCK1,\n\t\t.ops = &lp8725_buck_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp8725_buck_vtbl),\n\t\t.volt_table = lp8725_buck_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.enable_reg = LP872X_GENERAL_CFG,\n\t\t.enable_mask = LP8725_BUCK1_EN_M,\n\t\t.curr_table = lp8725_buck_uA,\n\t\t.n_current_limits = ARRAY_SIZE(lp8725_buck_uA),\n\t\t.csel_reg = LP8725_BUCK1_VOUT2,\n\t\t.csel_mask = LP8725_BUCK_CL_M,\n\t},\n\t{\n\t\t.name = \"buck2\",\n\t\t.of_match = of_match_ptr(\"buck2\"),\n\t\t.id = LP8725_ID_BUCK2,\n\t\t.ops = &lp8725_buck_ops,\n\t\t.n_voltages = ARRAY_SIZE(lp8725_buck_vtbl),\n\t\t.volt_table = lp8725_buck_vtbl,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.enable_reg = LP872X_GENERAL_CFG,\n\t\t.enable_mask = LP8725_BUCK2_EN_M,\n\t\t.curr_table = lp8725_buck_uA,\n\t\t.n_current_limits = ARRAY_SIZE(lp8725_buck_uA),\n\t\t.csel_reg = LP8725_BUCK2_VOUT2,\n\t\t.csel_mask = LP8725_BUCK_CL_M,\n\t},\n};\n\nstatic int lp872x_init_dvs(struct lp872x *lp)\n{\n\tstruct lp872x_dvs *dvs = lp->pdata ? lp->pdata->dvs : NULL;\n\tenum gpiod_flags pinstate;\n\tu8 mask[] = { LP8720_EXT_DVS_M, LP8725_DVS1_M | LP8725_DVS2_M };\n\tu8 default_dvs_mode[] = { LP8720_DEFAULT_DVS, LP8725_DEFAULT_DVS };\n\n\tif (!dvs)\n\t\tgoto set_default_dvs_mode;\n\n\tif (!dvs->gpio)\n\t\tgoto set_default_dvs_mode;\n\n\tpinstate = dvs->init_state;\n\tdvs->gpio = devm_gpiod_get_optional(lp->dev, \"ti,dvs\", pinstate);\n\n\tif (IS_ERR(dvs->gpio)) {\n\t\tdev_err(lp->dev, \"gpio request err: %ld\\n\", PTR_ERR(dvs->gpio));\n\t\treturn PTR_ERR(dvs->gpio);\n\t}\n\n\tlp->dvs_pin = pinstate;\n\n\treturn 0;\n\nset_default_dvs_mode:\n\treturn lp872x_update_bits(lp, LP872X_GENERAL_CFG, mask[lp->chipid],\n\t\t\t\tdefault_dvs_mode[lp->chipid]);\n}\n\nstatic int lp872x_hw_enable(struct lp872x *lp)\n{\n\tif (!lp->pdata)\n\t\treturn -EINVAL;\n\n\tif (!lp->pdata->enable_gpio)\n\t\treturn 0;\n\n\t \n\tlp->pdata->enable_gpio = devm_gpiod_get_optional(lp->dev, \"enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(lp->pdata->enable_gpio)) {\n\t\tdev_err(lp->dev, \"gpio request err: %ld\\n\", PTR_ERR(lp->pdata->enable_gpio));\n\t\treturn PTR_ERR(lp->pdata->enable_gpio);\n\t}\n\n\t \n\tif (lp->chipid == LP8720)\n\t\tusleep_range(LP8720_ENABLE_DELAY, 1.5 * LP8720_ENABLE_DELAY);\n\telse\n\t\tusleep_range(LP8725_ENABLE_DELAY, 1.5 * LP8725_ENABLE_DELAY);\n\n\treturn 0;\n}\n\nstatic int lp872x_config(struct lp872x *lp)\n{\n\tstruct lp872x_platform_data *pdata = lp->pdata;\n\tint ret;\n\n\tif (!pdata || !pdata->update_config)\n\t\tgoto init_dvs;\n\n\tret = lp872x_write_byte(lp, LP872X_GENERAL_CFG, pdata->general_config);\n\tif (ret)\n\t\treturn ret;\n\ninit_dvs:\n\treturn lp872x_init_dvs(lp);\n}\n\nstatic struct regulator_init_data\n*lp872x_find_regulator_init_data(int id, struct lp872x *lp)\n{\n\tstruct lp872x_platform_data *pdata = lp->pdata;\n\tint i;\n\n\tif (!pdata)\n\t\treturn NULL;\n\n\tfor (i = 0; i < lp->num_regulators; i++) {\n\t\tif (pdata->regulator_data[i].id == id)\n\t\t\treturn pdata->regulator_data[i].init_data;\n\t}\n\n\treturn NULL;\n}\n\nstatic int lp872x_regulator_register(struct lp872x *lp)\n{\n\tconst struct regulator_desc *desc;\n\tstruct regulator_config cfg = { };\n\tstruct regulator_dev *rdev;\n\tint i;\n\n\tfor (i = 0; i < lp->num_regulators; i++) {\n\t\tdesc = (lp->chipid == LP8720) ? &lp8720_regulator_desc[i] :\n\t\t\t\t\t\t&lp8725_regulator_desc[i];\n\n\t\tcfg.dev = lp->dev;\n\t\tcfg.init_data = lp872x_find_regulator_init_data(desc->id, lp);\n\t\tcfg.driver_data = lp;\n\t\tcfg.regmap = lp->regmap;\n\n\t\trdev = devm_regulator_register(lp->dev, desc, &cfg);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(lp->dev, \"regulator register err\");\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_config lp872x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MAX_REGISTERS,\n};\n\n#ifdef CONFIG_OF\n\n#define LP872X_VALID_OPMODE\t(REGULATOR_MODE_FAST | REGULATOR_MODE_NORMAL)\n\nstatic struct of_regulator_match lp8720_matches[] = {\n\t{ .name = \"ldo1\", .driver_data = (void *)LP8720_ID_LDO1, },\n\t{ .name = \"ldo2\", .driver_data = (void *)LP8720_ID_LDO2, },\n\t{ .name = \"ldo3\", .driver_data = (void *)LP8720_ID_LDO3, },\n\t{ .name = \"ldo4\", .driver_data = (void *)LP8720_ID_LDO4, },\n\t{ .name = \"ldo5\", .driver_data = (void *)LP8720_ID_LDO5, },\n\t{ .name = \"buck\", .driver_data = (void *)LP8720_ID_BUCK, },\n};\n\nstatic struct of_regulator_match lp8725_matches[] = {\n\t{ .name = \"ldo1\", .driver_data = (void *)LP8725_ID_LDO1, },\n\t{ .name = \"ldo2\", .driver_data = (void *)LP8725_ID_LDO2, },\n\t{ .name = \"ldo3\", .driver_data = (void *)LP8725_ID_LDO3, },\n\t{ .name = \"ldo4\", .driver_data = (void *)LP8725_ID_LDO4, },\n\t{ .name = \"ldo5\", .driver_data = (void *)LP8725_ID_LDO5, },\n\t{ .name = \"lilo1\", .driver_data = (void *)LP8725_ID_LILO1, },\n\t{ .name = \"lilo2\", .driver_data = (void *)LP8725_ID_LILO2, },\n\t{ .name = \"buck1\", .driver_data = (void *)LP8725_ID_BUCK1, },\n\t{ .name = \"buck2\", .driver_data = (void *)LP8725_ID_BUCK2, },\n};\n\nstatic struct lp872x_platform_data\n*lp872x_populate_pdata_from_dt(struct device *dev, enum lp872x_id which)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct lp872x_platform_data *pdata;\n\tstruct of_regulator_match *match;\n\tint num_matches;\n\tint count;\n\tint i;\n\tu8 dvs_state;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tof_property_read_u8(np, \"ti,general-config\", &pdata->general_config);\n\tpdata->update_config = of_property_read_bool(np, \"ti,update-config\");\n\n\tpdata->dvs = devm_kzalloc(dev, sizeof(struct lp872x_dvs), GFP_KERNEL);\n\tif (!pdata->dvs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tof_property_read_u8(np, \"ti,dvs-vsel\", (u8 *)&pdata->dvs->vsel);\n\tof_property_read_u8(np, \"ti,dvs-state\", &dvs_state);\n\tpdata->dvs->init_state = dvs_state ? GPIOD_OUT_HIGH : GPIOD_OUT_LOW;\n\n\tif (of_get_child_count(np) == 0)\n\t\tgoto out;\n\n\tswitch (which) {\n\tcase LP8720:\n\t\tmatch = lp8720_matches;\n\t\tnum_matches = ARRAY_SIZE(lp8720_matches);\n\t\tbreak;\n\tcase LP8725:\n\t\tmatch = lp8725_matches;\n\t\tnum_matches = ARRAY_SIZE(lp8725_matches);\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tcount = of_regulator_match(dev, np, match, num_matches);\n\tif (count <= 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < num_matches; i++) {\n\t\tpdata->regulator_data[i].id =\n\t\t\t\t(uintptr_t)match[i].driver_data;\n\t\tpdata->regulator_data[i].init_data = match[i].init_data;\n\t}\nout:\n\treturn pdata;\n}\n#else\nstatic struct lp872x_platform_data\n*lp872x_populate_pdata_from_dt(struct device *dev, enum lp872x_id which)\n{\n\treturn NULL;\n}\n#endif\n\nstatic int lp872x_probe(struct i2c_client *cl)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(cl);\n\tstruct lp872x *lp;\n\tstruct lp872x_platform_data *pdata;\n\tint ret;\n\tstatic const int lp872x_num_regulators[] = {\n\t\t[LP8720] = LP8720_NUM_REGULATORS,\n\t\t[LP8725] = LP8725_NUM_REGULATORS,\n\t};\n\n\tif (cl->dev.of_node) {\n\t\tpdata = lp872x_populate_pdata_from_dt(&cl->dev,\n\t\t\t\t\t      (enum lp872x_id)id->driver_data);\n\t\tif (IS_ERR(pdata))\n\t\t\treturn PTR_ERR(pdata);\n\t} else {\n\t\tpdata = dev_get_platdata(&cl->dev);\n\t}\n\n\tlp = devm_kzalloc(&cl->dev, sizeof(struct lp872x), GFP_KERNEL);\n\tif (!lp)\n\t\treturn -ENOMEM;\n\n\tlp->num_regulators = lp872x_num_regulators[id->driver_data];\n\n\tlp->regmap = devm_regmap_init_i2c(cl, &lp872x_regmap_config);\n\tif (IS_ERR(lp->regmap)) {\n\t\tret = PTR_ERR(lp->regmap);\n\t\tdev_err(&cl->dev, \"regmap init i2c err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tlp->dev = &cl->dev;\n\tlp->pdata = pdata;\n\tlp->chipid = id->driver_data;\n\ti2c_set_clientdata(cl, lp);\n\n\tret = lp872x_hw_enable(lp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lp872x_config(lp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn lp872x_regulator_register(lp);\n}\n\nstatic const struct of_device_id lp872x_dt_ids[] __maybe_unused = {\n\t{ .compatible = \"ti,lp8720\", },\n\t{ .compatible = \"ti,lp8725\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lp872x_dt_ids);\n\nstatic const struct i2c_device_id lp872x_ids[] = {\n\t{\"lp8720\", LP8720},\n\t{\"lp8725\", LP8725},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lp872x_ids);\n\nstatic struct i2c_driver lp872x_driver = {\n\t.driver = {\n\t\t.name = \"lp872x\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(lp872x_dt_ids),\n\t},\n\t.probe = lp872x_probe,\n\t.id_table = lp872x_ids,\n};\n\nmodule_i2c_driver(lp872x_driver);\n\nMODULE_DESCRIPTION(\"TI/National Semiconductor LP872x PMU Regulator Driver\");\nMODULE_AUTHOR(\"Milo Kim\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}