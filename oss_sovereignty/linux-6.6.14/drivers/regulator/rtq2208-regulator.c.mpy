{
  "module_name": "rtq2208-regulator.c",
  "hash_id": "92ce3639d8cedcd4fb28d7f29c11d8840a6a4be7495344feb40d491a216bdb06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rtq2208-regulator.c",
  "human_readable_source": "\n\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/util_macros.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/mod_devicetable.h>\n\n \n#define RTQ2208_REG_GLOBAL_INT1\t\t\t0x12\n#define RTQ2208_REG_FLT_RECORDBUCK_CB\t\t0x18\n#define RTQ2208_REG_GLOBAL_INT1_MASK\t\t0x1D\n#define RTQ2208_REG_FLT_MASKBUCK_CB\t\t0x1F\n#define RTQ2208_REG_BUCK_C_CFG0\t\t\t0x32\n#define RTQ2208_REG_BUCK_B_CFG0\t\t\t0x42\n#define RTQ2208_REG_BUCK_A_CFG0\t\t\t0x52\n#define RTQ2208_REG_BUCK_D_CFG0\t\t\t0x62\n#define RTQ2208_REG_BUCK_G_CFG0\t\t\t0x72\n#define RTQ2208_REG_BUCK_F_CFG0\t\t\t0x82\n#define RTQ2208_REG_BUCK_E_CFG0\t\t\t0x92\n#define RTQ2208_REG_BUCK_H_CFG0\t\t\t0xA2\n#define RTQ2208_REG_LDO1_CFG\t\t\t0xB1\n#define RTQ2208_REG_LDO2_CFG\t\t\t0xC1\n\n \n#define RTQ2208_BUCK_NR_MTP_SEL_MASK\t\tGENMASK(7, 0)\n#define RTQ2208_BUCK_EN_NR_MTP_SEL0_MASK\tBIT(0)\n#define RTQ2208_BUCK_EN_NR_MTP_SEL1_MASK\tBIT(1)\n#define RTQ2208_BUCK_RSPUP_MASK\t\t\tGENMASK(6, 4)\n#define RTQ2208_BUCK_RSPDN_MASK\t\t\tGENMASK(2, 0)\n#define RTQ2208_BUCK_NRMODE_MASK\t\tBIT(5)\n#define RTQ2208_BUCK_STRMODE_MASK\t\tBIT(5)\n#define RTQ2208_BUCK_EN_STR_MASK\t\tBIT(0)\n#define RTQ2208_LDO_EN_STR_MASK\t\t\tBIT(7)\n#define RTQ2208_EN_DIS_MASK\t\t\tBIT(0)\n#define RTQ2208_BUCK_RAMP_SEL_MASK\t\tGENMASK(2, 0)\n#define RTQ2208_HD_INT_MASK\t\t\tBIT(0)\n\n \n#define RTQ2208_VOUT_MAXNUM\t\t\t256\n#define RTQ2208_BUCK_NUM_IRQ_REGS\t\t5\n#define RTQ2208_STS_NUM_IRQ_REGS\t\t2\n\n \n#define RTQ2208_RAMP_VALUE_MIN_uV\t\t500\n#define RTQ2208_RAMP_VALUE_MAX_uV\t\t64000\n\n#define RTQ2208_BUCK_MASK(uv_irq, ov_irq)\t(1 << ((uv_irq) % 8) | 1 << ((ov_irq) % 8))\n\nenum {\n\tRTQ2208_BUCK_B = 0,\n\tRTQ2208_BUCK_C,\n\tRTQ2208_BUCK_D,\n\tRTQ2208_BUCK_A,\n\tRTQ2208_BUCK_F,\n\tRTQ2208_BUCK_G,\n\tRTQ2208_BUCK_H,\n\tRTQ2208_BUCK_E,\n\tRTQ2208_LDO2,\n\tRTQ2208_LDO1,\n\tRTQ2208_LDO_MAX,\n};\n\nenum {\n\tRTQ2208_AUTO_MODE = 0,\n\tRTQ2208_FCCM,\n};\n\nstruct rtq2208_regulator_desc {\n\tstruct regulator_desc desc;\n\tunsigned int mtp_sel_reg;\n\tunsigned int mtp_sel_mask;\n\tunsigned int mode_reg;\n\tunsigned int mode_mask;\n\tunsigned int suspend_config_reg;\n\tunsigned int suspend_enable_mask;\n\tunsigned int suspend_mode_mask;\n};\n\nstruct rtq2208_rdev_map {\n\tstruct regulator_dev *rdev[RTQ2208_LDO_MAX];\n\tstruct regmap *regmap;\n\tstruct device *dev;\n};\n\n \nstatic int rtq2208_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tconst struct rtq2208_regulator_desc *rdesc =\n\t\t(const struct rtq2208_regulator_desc *)rdev->desc;\n\tunsigned int val, shift;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = RTQ2208_AUTO_MODE;\n\t\tbreak;\n\tcase REGULATOR_MODE_FAST:\n\t\tval = RTQ2208_FCCM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tshift = ffs(rdesc->mode_mask) - 1;\n\treturn regmap_update_bits(rdev->regmap, rdesc->mode_reg,\n\t\t\t\t  rdesc->mode_mask, val << shift);\n}\n\nstatic unsigned int rtq2208_get_mode(struct regulator_dev *rdev)\n{\n\tconst struct rtq2208_regulator_desc *rdesc =\n\t\t(const struct rtq2208_regulator_desc *)rdev->desc;\n\tunsigned int mode_val;\n\tint ret;\n\n\tret = regmap_read(rdev->regmap, rdesc->mode_reg, &mode_val);\n\tif (ret)\n\t\treturn REGULATOR_MODE_INVALID;\n\n\treturn (mode_val & rdesc->mode_mask) ? REGULATOR_MODE_FAST : REGULATOR_MODE_NORMAL;\n}\n\nstatic int rtq2208_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)\n{\n\tconst struct regulator_desc *desc = rdev->desc;\n\tunsigned int sel = 0, val;\n\n\tramp_delay = max(ramp_delay, RTQ2208_RAMP_VALUE_MIN_uV);\n\tramp_delay = min(ramp_delay, RTQ2208_RAMP_VALUE_MAX_uV);\n\n\tramp_delay /= RTQ2208_RAMP_VALUE_MIN_uV;\n\n\t \n\n\tsel = fls(ramp_delay) - 1;\n\tsel = RTQ2208_BUCK_RAMP_SEL_MASK - sel;\n\n\tval = FIELD_PREP(RTQ2208_BUCK_RSPUP_MASK, sel) | FIELD_PREP(RTQ2208_BUCK_RSPDN_MASK, sel);\n\n\treturn regmap_update_bits(rdev->regmap, desc->ramp_reg,\n\t\t\t\t  RTQ2208_BUCK_RSPUP_MASK | RTQ2208_BUCK_RSPDN_MASK, val);\n}\n\nstatic int rtq2208_set_suspend_enable(struct regulator_dev *rdev)\n{\n\tconst struct rtq2208_regulator_desc *rdesc =\n\t\t(const struct rtq2208_regulator_desc *)rdev->desc;\n\n\treturn regmap_set_bits(rdev->regmap, rdesc->suspend_config_reg, rdesc->suspend_enable_mask);\n}\n\nstatic int rtq2208_set_suspend_disable(struct regulator_dev *rdev)\n{\n\tconst struct rtq2208_regulator_desc *rdesc =\n\t\t(const struct rtq2208_regulator_desc *)rdev->desc;\n\n\treturn regmap_update_bits(rdev->regmap, rdesc->suspend_config_reg, rdesc->suspend_enable_mask, 0);\n}\n\nstatic int rtq2208_set_suspend_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tconst struct rtq2208_regulator_desc *rdesc =\n\t\t(const struct rtq2208_regulator_desc *)rdev->desc;\n\tunsigned int val, shift;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = RTQ2208_AUTO_MODE;\n\t\tbreak;\n\tcase REGULATOR_MODE_FAST:\n\t\tval = RTQ2208_FCCM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tshift = ffs(rdesc->suspend_mode_mask) - 1;\n\n\treturn regmap_update_bits(rdev->regmap, rdesc->suspend_config_reg,\n\t\t\trdesc->suspend_mode_mask, val << shift);\n}\n\nstatic const struct regulator_ops rtq2208_regulator_buck_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_mode = rtq2208_set_mode,\n\t.get_mode = rtq2208_get_mode,\n\t.set_ramp_delay = rtq2208_set_ramp_delay,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n\t.set_suspend_enable = rtq2208_set_suspend_enable,\n\t.set_suspend_disable = rtq2208_set_suspend_disable,\n\t.set_suspend_mode = rtq2208_set_suspend_mode,\n};\n\nstatic const struct regulator_ops rtq2208_regulator_ldo_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n\t.set_suspend_enable = rtq2208_set_suspend_enable,\n\t.set_suspend_disable = rtq2208_set_suspend_disable,\n};\n\nstatic unsigned int rtq2208_of_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase RTQ2208_AUTO_MODE:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase RTQ2208_FCCM:\n\t\treturn REGULATOR_MODE_FAST;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic int rtq2208_init_irq_mask(struct rtq2208_rdev_map *rdev_map, unsigned int *buck_masks)\n{\n\tunsigned char buck_clr_masks[5] = {0x33, 0x33, 0x33, 0x33, 0x33},\n\t\t      sts_clr_masks[2] = {0xE7, 0xF7}, sts_masks[2] = {0xE6, 0xF6};\n\tint ret;\n\n\t \n\tret = regmap_bulk_write(rdev_map->regmap, RTQ2208_REG_FLT_RECORDBUCK_CB, buck_clr_masks, 5);\n\tif (ret)\n\t\treturn dev_err_probe(rdev_map->dev, ret, \"Failed to clr buck irqs\\n\");\n\n\t \n\tret = regmap_bulk_write(rdev_map->regmap, RTQ2208_REG_GLOBAL_INT1, sts_clr_masks, 2);\n\tif (ret)\n\t\treturn dev_err_probe(rdev_map->dev, ret, \"Failed to clr general irqs\\n\");\n\n\t \n\tret = regmap_bulk_write(rdev_map->regmap, RTQ2208_REG_FLT_MASKBUCK_CB, buck_masks, 5);\n\tif (ret)\n\t\treturn dev_err_probe(rdev_map->dev, ret, \"Failed to unmask buck irqs\\n\");\n\n\t \n\treturn regmap_bulk_write(rdev_map->regmap, RTQ2208_REG_GLOBAL_INT1_MASK, sts_masks, 2);\n}\n\nstatic irqreturn_t rtq2208_irq_handler(int irqno, void *devid)\n{\n\tunsigned char buck_flags[RTQ2208_BUCK_NUM_IRQ_REGS], sts_flags[RTQ2208_STS_NUM_IRQ_REGS];\n\tint ret = 0, i, uv_bit, ov_bit;\n\tstruct rtq2208_rdev_map *rdev_map = devid;\n\tstruct regulator_dev *rdev;\n\n\tif (!rdev_map)\n\t\treturn IRQ_NONE;\n\n\t \n\tret = regmap_bulk_read(rdev_map->regmap, RTQ2208_REG_FLT_RECORDBUCK_CB,\n\t\t\t\tbuck_flags, ARRAY_SIZE(buck_flags));\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tret = regmap_bulk_read(rdev_map->regmap, RTQ2208_REG_GLOBAL_INT1,\n\t\t\t\tsts_flags, ARRAY_SIZE(sts_flags));\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\t \n\tret = regmap_bulk_write(rdev_map->regmap, RTQ2208_REG_FLT_RECORDBUCK_CB,\n\t\t\t\tbuck_flags, ARRAY_SIZE(buck_flags));\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tret = regmap_bulk_write(rdev_map->regmap, RTQ2208_REG_GLOBAL_INT1,\n\t\t\t\tsts_flags, ARRAY_SIZE(sts_flags));\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tfor (i = 0; i < RTQ2208_LDO_MAX; i++) {\n\t\tif (!rdev_map->rdev[i])\n\t\t\tcontinue;\n\n\t\trdev = rdev_map->rdev[i];\n\t\t \n\t\tuv_bit = (i & 1) ? 4 : 0;\n\t\tif (buck_flags[i >> 1] & (1 << uv_bit))\n\t\t\tregulator_notifier_call_chain(rdev,\n\t\t\t\t\tREGULATOR_EVENT_UNDER_VOLTAGE, NULL);\n\t\t \n\t\tov_bit = uv_bit + 1;\n\t\tif (buck_flags[i >> 1] & (1 << ov_bit))\n\t\t\tregulator_notifier_call_chain(rdev,\n\t\t\t\t\tREGULATOR_EVENT_REGULATION_OUT, NULL);\n\n\t\t \n\t\tif (sts_flags[1] & RTQ2208_HD_INT_MASK)\n\t\t\tregulator_notifier_call_chain(rdev,\n\t\t\t\t\tREGULATOR_EVENT_OVER_TEMP, NULL);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n#define RTQ2208_REGULATOR_INFO(_name, _base) \\\n{ \\\n\t.name = #_name, \\\n\t.base = _base, \\\n}\n#define BUCK_RG_BASE(_id)\tRTQ2208_REG_BUCK_##_id##_CFG0\n#define BUCK_RG_SHIFT(_base, _shift)\t(_base + _shift)\n#define LDO_RG_BASE(_id)\tRTQ2208_REG_LDO##_id##_CFG\n#define LDO_RG_SHIFT(_base, _shift)\t(_base + _shift)\n#define\tVSEL_SHIFT(_sel)\t(_sel ? 3 : 1)\n#define MTP_SEL_MASK(_sel)\tRTQ2208_BUCK_EN_NR_MTP_SEL##_sel##_MASK\n\nstatic const struct linear_range rtq2208_vout_range[] = {\n\tREGULATOR_LINEAR_RANGE(400000, 0, 180, 5000),\n\tREGULATOR_LINEAR_RANGE(1310000, 181, 255, 10000),\n};\n\nstatic int rtq2208_of_get_fixed_voltage(struct device *dev,\n\t\t\t\t\tstruct of_regulator_match *rtq2208_ldo_match, int n_fixed)\n{\n\tstruct device_node *np;\n\tstruct of_regulator_match *match;\n\tstruct rtq2208_regulator_desc *rdesc;\n\tstruct regulator_init_data *init_data;\n\tint ret, i;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tnp = of_get_child_by_name(dev->of_node, \"regulators\");\n\tif (!np)\n\t\tnp = dev->of_node;\n\n\tret = of_regulator_match(dev, np, rtq2208_ldo_match, n_fixed);\n\n\tof_node_put(np);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < n_fixed; i++) {\n\t\tmatch = rtq2208_ldo_match + i;\n\t\tinit_data = match->init_data;\n\t\trdesc = (struct rtq2208_regulator_desc *)match->driver_data;\n\n\t\tif (!init_data || !rdesc)\n\t\t\tcontinue;\n\n\t\tif (init_data->constraints.min_uV == init_data->constraints.max_uV)\n\t\t\trdesc->desc.fixed_uV = init_data->constraints.min_uV;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtq2208_init_regulator_desc(struct rtq2208_regulator_desc *rdesc, int mtp_sel,\n\t\t\t\t\tint idx, struct of_regulator_match *rtq2208_ldo_match, int *ldo_idx)\n{\n\tstruct regulator_desc *desc;\n\tstatic const struct {\n\t\tchar *name;\n\t\tint base;\n\t} regulator_info[] = {\n\t\tRTQ2208_REGULATOR_INFO(buck-b, BUCK_RG_BASE(B)),\n\t\tRTQ2208_REGULATOR_INFO(buck-c, BUCK_RG_BASE(C)),\n\t\tRTQ2208_REGULATOR_INFO(buck-d, BUCK_RG_BASE(D)),\n\t\tRTQ2208_REGULATOR_INFO(buck-a, BUCK_RG_BASE(A)),\n\t\tRTQ2208_REGULATOR_INFO(buck-f, BUCK_RG_BASE(F)),\n\t\tRTQ2208_REGULATOR_INFO(buck-g, BUCK_RG_BASE(G)),\n\t\tRTQ2208_REGULATOR_INFO(buck-h, BUCK_RG_BASE(H)),\n\t\tRTQ2208_REGULATOR_INFO(buck-e, BUCK_RG_BASE(E)),\n\t\tRTQ2208_REGULATOR_INFO(ldo2, LDO_RG_BASE(2)),\n\t\tRTQ2208_REGULATOR_INFO(ldo1, LDO_RG_BASE(1)),\n\t}, *curr_info;\n\n\tcurr_info = regulator_info + idx;\n\tdesc = &rdesc->desc;\n\tdesc->name = curr_info->name;\n\tdesc->of_match = of_match_ptr(curr_info->name);\n\tdesc->regulators_node = of_match_ptr(\"regulators\");\n\tdesc->id = idx;\n\tdesc->owner = THIS_MODULE;\n\tdesc->type = REGULATOR_VOLTAGE;\n\tdesc->enable_mask = mtp_sel ? MTP_SEL_MASK(1) : MTP_SEL_MASK(0);\n\tdesc->active_discharge_on = RTQ2208_EN_DIS_MASK;\n\tdesc->active_discharge_off = 0;\n\tdesc->active_discharge_mask = RTQ2208_EN_DIS_MASK;\n\n\trdesc->mode_mask = RTQ2208_BUCK_NRMODE_MASK;\n\n\tif (idx >= RTQ2208_BUCK_B && idx <= RTQ2208_BUCK_E) {\n\t\t \n\t\tdesc->enable_reg = BUCK_RG_SHIFT(curr_info->base, 2);\n\t\tdesc->ops = &rtq2208_regulator_buck_ops;\n\t\tdesc->vsel_reg = curr_info->base + VSEL_SHIFT(mtp_sel);\n\t\tdesc->vsel_mask = RTQ2208_BUCK_NR_MTP_SEL_MASK;\n\t\tdesc->n_voltages = RTQ2208_VOUT_MAXNUM;\n\t\tdesc->linear_ranges = rtq2208_vout_range;\n\t\tdesc->n_linear_ranges = ARRAY_SIZE(rtq2208_vout_range);\n\t\tdesc->ramp_reg = BUCK_RG_SHIFT(curr_info->base, 5);\n\t\tdesc->active_discharge_reg = curr_info->base;\n\t\tdesc->of_map_mode = rtq2208_of_map_mode;\n\n\t\trdesc->mode_reg = BUCK_RG_SHIFT(curr_info->base, 2);\n\t\trdesc->suspend_config_reg = BUCK_RG_SHIFT(curr_info->base, 4);\n\t\trdesc->suspend_enable_mask = RTQ2208_BUCK_EN_STR_MASK;\n\t\trdesc->suspend_mode_mask = RTQ2208_BUCK_STRMODE_MASK;\n\t} else {\n\t\t \n\t\tdesc->enable_reg = curr_info->base;\n\t\tdesc->ops = &rtq2208_regulator_ldo_ops;\n\t\tdesc->n_voltages = 1;\n\t\tdesc->active_discharge_reg = LDO_RG_SHIFT(curr_info->base, 2);\n\n\t\trtq2208_ldo_match[*ldo_idx].name = desc->name;\n\t\trtq2208_ldo_match[*ldo_idx].driver_data = rdesc;\n\t\trtq2208_ldo_match[(*ldo_idx)++].desc = desc;\n\n\t\trdesc->suspend_config_reg = curr_info->base;\n\t\trdesc->suspend_enable_mask = RTQ2208_LDO_EN_STR_MASK;\n\t}\n}\n\nstatic int rtq2208_parse_regulator_dt_data(int n_regulator, const unsigned int *regulator_idx_table,\n\t\tstruct rtq2208_regulator_desc *rdesc[RTQ2208_LDO_MAX], struct device *dev)\n{\n\tstruct of_regulator_match rtq2208_ldo_match[2];\n\tint mtp_sel, ret, i, idx, ldo_idx = 0;\n\n\t \n\tmtp_sel = device_property_read_bool(dev, \"richtek,mtp-sel-high\");\n\n\tfor (i = 0; i < n_regulator; i++) {\n\t\tidx = regulator_idx_table[i];\n\n\t\trdesc[i] = devm_kcalloc(dev, 1, sizeof(*rdesc[0]), GFP_KERNEL);\n\t\tif (!rdesc[i])\n\t\t\treturn -ENOMEM;\n\n\t\trtq2208_init_regulator_desc(rdesc[i], mtp_sel, idx, rtq2208_ldo_match, &ldo_idx);\n\t}\n\n\t \n\tret = rtq2208_of_get_fixed_voltage(dev, rtq2208_ldo_match, ldo_idx);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to get ldo fixed_uV\\n\");\n\n\treturn 0;\n\n}\n\n \nstatic int rtq2208_regulator_check(int slave_addr, int *num,\n\t\t\t\tint *regulator_idx_table, unsigned int *buck_masks)\n{\n\tstatic bool rtq2208_used_table[3][RTQ2208_LDO_MAX] = {\n\t\t \n\t\t{1, 1, 0, 1, 1, 1, 0, 1, 1, 1},\n\t\t \n\t\t{1, 1, 0, 0, 1, 1, 1, 1, 1, 1},\n\t\t \n\t\t{0, 1, 0, 0, 0, 1, 0, 0, 1, 1},\n\t};\n\tint i, idx = ffs(slave_addr >> 4) - 1;\n\tu8 mask;\n\n\tfor (i = 0; i < RTQ2208_LDO_MAX; i++) {\n\t\tif (!rtq2208_used_table[idx][i])\n\t\t\tcontinue;\n\n\t\tregulator_idx_table[(*num)++] = i;\n\n\t\tmask = RTQ2208_BUCK_MASK(4 * i, 4 * i + 1);\n\t\tbuck_masks[i >> 1] &= ~mask;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_config rtq2208_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xEF,\n};\n\nstatic int rtq2208_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct regmap *regmap;\n\tstruct rtq2208_regulator_desc *rdesc[RTQ2208_LDO_MAX];\n\tstruct regulator_dev *rdev;\n\tstruct regulator_config cfg;\n\tstruct rtq2208_rdev_map *rdev_map;\n\tint i, ret = 0, idx, n_regulator = 0;\n\tunsigned int regulator_idx_table[RTQ2208_LDO_MAX],\n\t\t     buck_masks[RTQ2208_BUCK_NUM_IRQ_REGS] = {0x33, 0x33, 0x33, 0x33, 0x33};\n\n\trdev_map = devm_kzalloc(dev, sizeof(struct rtq2208_rdev_map), GFP_KERNEL);\n\tif (!rdev_map)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_i2c(i2c, &rtq2208_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap), \"Failed to allocate regmap\\n\");\n\n\t \n\tret = rtq2208_regulator_check(i2c->addr, &n_regulator, regulator_idx_table, buck_masks);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to check used regulators\\n\");\n\n\trdev_map->regmap = regmap;\n\trdev_map->dev = dev;\n\n\tcfg.dev = dev;\n\n\t \n\tret = rtq2208_parse_regulator_dt_data(n_regulator, regulator_idx_table, rdesc, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < n_regulator; i++) {\n\t\tidx = regulator_idx_table[i];\n\n\t\t \n\t\trdev = devm_regulator_register(dev, &rdesc[i]->desc, &cfg);\n\t\tif (IS_ERR(rdev))\n\t\t\treturn PTR_ERR(rdev);\n\n\t\trdev_map->rdev[idx] = rdev;\n\t}\n\n\t \n\tret = rtq2208_init_irq_mask(rdev_map, buck_masks);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn devm_request_threaded_irq(dev, i2c->irq, NULL, rtq2208_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT, dev_name(dev), rdev_map);\n}\n\nstatic const struct of_device_id rtq2208_device_tables[] = {\n\t{ .compatible = \"richtek,rtq2208\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rtq2208_device_tables);\n\nstatic struct i2c_driver rtq2208_driver = {\n\t.driver = {\n\t\t.name = \"rtq2208\",\n\t\t.of_match_table = rtq2208_device_tables,\n\t},\n\t.probe = rtq2208_probe,\n};\nmodule_i2c_driver(rtq2208_driver);\n\nMODULE_AUTHOR(\"Alina Yu <alina_yu@richtek.com>\");\nMODULE_DESCRIPTION(\"Richtek RTQ2208 Regulator Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}