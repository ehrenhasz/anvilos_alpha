{
  "module_name": "bcm590xx-regulator.c",
  "hash_id": "79a160caba95bf696d34fd7a42c19873c3bfc5488f7dee38985deafc82f521d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/bcm590xx-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mfd/bcm590xx.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/slab.h>\n\n \n#define BCM590XX_RFLDOPMCTRL1\t0x60\n#define BCM590XX_IOSR1PMCTRL1\t0x7a\n#define BCM590XX_IOSR2PMCTRL1\t0x7c\n#define BCM590XX_CSRPMCTRL1\t0x7e\n#define BCM590XX_SDSR1PMCTRL1\t0x82\n#define BCM590XX_SDSR2PMCTRL1\t0x86\n#define BCM590XX_MSRPMCTRL1\t0x8a\n#define BCM590XX_VSRPMCTRL1\t0x8e\n#define BCM590XX_RFLDOCTRL\t0x96\n#define BCM590XX_CSRVOUT1\t0xc0\n\n \n#define BCM590XX_GPLDO5PMCTRL1\t0x16\n#define BCM590XX_GPLDO6PMCTRL1\t0x18\n#define BCM590XX_GPLDO1CTRL\t0x1a\n#define BCM590XX_GPLDO2CTRL\t0x1b\n#define BCM590XX_GPLDO3CTRL\t0x1c\n#define BCM590XX_GPLDO4CTRL\t0x1d\n#define BCM590XX_GPLDO5CTRL\t0x1e\n#define BCM590XX_GPLDO6CTRL\t0x1f\n#define BCM590XX_OTG_CTRL\t0x40\n#define BCM590XX_GPLDO1PMCTRL1\t0x57\n#define BCM590XX_GPLDO2PMCTRL1\t0x59\n#define BCM590XX_GPLDO3PMCTRL1\t0x5b\n#define BCM590XX_GPLDO4PMCTRL1\t0x5d\n\n#define BCM590XX_REG_ENABLE\tBIT(7)\n#define BCM590XX_VBUS_ENABLE\tBIT(2)\n#define BCM590XX_LDO_VSEL_MASK\tGENMASK(5, 3)\n#define BCM590XX_SR_VSEL_MASK\tGENMASK(5, 0)\n\n \n\n \n#define BCM590XX_REG_RFLDO\t0\n#define BCM590XX_REG_CAMLDO1\t1\n#define BCM590XX_REG_CAMLDO2\t2\n#define BCM590XX_REG_SIMLDO1\t3\n#define BCM590XX_REG_SIMLDO2\t4\n#define BCM590XX_REG_SDLDO\t5\n#define BCM590XX_REG_SDXLDO\t6\n#define BCM590XX_REG_MMCLDO1\t7\n#define BCM590XX_REG_MMCLDO2\t8\n#define BCM590XX_REG_AUDLDO\t9\n#define BCM590XX_REG_MICLDO\t10\n#define BCM590XX_REG_USBLDO\t11\n#define BCM590XX_REG_VIBLDO\t12\n\n \n#define BCM590XX_REG_CSR\t13\n#define BCM590XX_REG_IOSR1\t14\n#define BCM590XX_REG_IOSR2\t15\n#define BCM590XX_REG_MSR\t16\n#define BCM590XX_REG_SDSR1\t17\n#define BCM590XX_REG_SDSR2\t18\n#define BCM590XX_REG_VSR\t19\n\n \n\n#define BCM590XX_REG_GPLDO1\t20\n#define BCM590XX_REG_GPLDO2\t21\n#define BCM590XX_REG_GPLDO3\t22\n#define BCM590XX_REG_GPLDO4\t23\n#define BCM590XX_REG_GPLDO5\t24\n#define BCM590XX_REG_GPLDO6\t25\n#define BCM590XX_REG_VBUS\t26\n\n#define BCM590XX_NUM_REGS\t27\n\n#define BCM590XX_REG_IS_LDO(n)\t(n < BCM590XX_REG_CSR)\n#define BCM590XX_REG_IS_GPLDO(n) \\\n\t((n > BCM590XX_REG_VSR) && (n < BCM590XX_REG_VBUS))\n#define BCM590XX_REG_IS_VBUS(n)\t(n == BCM590XX_REG_VBUS)\n\n \nstatic const unsigned int ldo_a_table[] = {\n\t1200000, 1800000, 2500000, 2700000, 2800000,\n\t2900000, 3000000, 3300000,\n};\n\n \nstatic const unsigned int ldo_c_table[] = {\n\t3100000, 1800000, 2500000, 2700000, 2800000,\n\t2900000, 3000000, 3300000,\n};\n\nstatic const unsigned int ldo_vbus[] = {\n\t5000000,\n};\n\n \nstatic const struct linear_range dcdc_csr_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(860000, 2, 50, 10000),\n\tREGULATOR_LINEAR_RANGE(1360000, 51, 55, 20000),\n\tREGULATOR_LINEAR_RANGE(900000, 56, 63, 0),\n};\n\n \nstatic const struct linear_range dcdc_iosr1_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(860000, 2, 51, 10000),\n\tREGULATOR_LINEAR_RANGE(1500000, 52, 52, 0),\n\tREGULATOR_LINEAR_RANGE(1800000, 53, 53, 0),\n\tREGULATOR_LINEAR_RANGE(900000, 54, 63, 0),\n};\n\n \nstatic const struct linear_range dcdc_sdsr1_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(860000, 2, 50, 10000),\n\tREGULATOR_LINEAR_RANGE(1340000, 51, 51, 0),\n\tREGULATOR_LINEAR_RANGE(900000, 52, 63, 0),\n};\n\nstruct bcm590xx_info {\n\tconst char *name;\n\tconst char *vin_name;\n\tu8 n_voltages;\n\tconst unsigned int *volt_table;\n\tu8 n_linear_ranges;\n\tconst struct linear_range *linear_ranges;\n};\n\n#define BCM590XX_REG_TABLE(_name, _table) \\\n\t{ \\\n\t\t.name = #_name, \\\n\t\t.n_voltages = ARRAY_SIZE(_table), \\\n\t\t.volt_table = _table, \\\n\t}\n\n#define BCM590XX_REG_RANGES(_name, _ranges) \\\n\t{ \\\n\t\t.name = #_name, \\\n\t\t.n_voltages = 64, \\\n\t\t.n_linear_ranges = ARRAY_SIZE(_ranges), \\\n\t\t.linear_ranges = _ranges, \\\n\t}\n\nstatic struct bcm590xx_info bcm590xx_regs[] = {\n\tBCM590XX_REG_TABLE(rfldo, ldo_a_table),\n\tBCM590XX_REG_TABLE(camldo1, ldo_c_table),\n\tBCM590XX_REG_TABLE(camldo2, ldo_c_table),\n\tBCM590XX_REG_TABLE(simldo1, ldo_a_table),\n\tBCM590XX_REG_TABLE(simldo2, ldo_a_table),\n\tBCM590XX_REG_TABLE(sdldo, ldo_c_table),\n\tBCM590XX_REG_TABLE(sdxldo, ldo_a_table),\n\tBCM590XX_REG_TABLE(mmcldo1, ldo_a_table),\n\tBCM590XX_REG_TABLE(mmcldo2, ldo_a_table),\n\tBCM590XX_REG_TABLE(audldo, ldo_a_table),\n\tBCM590XX_REG_TABLE(micldo, ldo_a_table),\n\tBCM590XX_REG_TABLE(usbldo, ldo_a_table),\n\tBCM590XX_REG_TABLE(vibldo, ldo_c_table),\n\tBCM590XX_REG_RANGES(csr, dcdc_csr_ranges),\n\tBCM590XX_REG_RANGES(iosr1, dcdc_iosr1_ranges),\n\tBCM590XX_REG_RANGES(iosr2, dcdc_iosr1_ranges),\n\tBCM590XX_REG_RANGES(msr, dcdc_iosr1_ranges),\n\tBCM590XX_REG_RANGES(sdsr1, dcdc_sdsr1_ranges),\n\tBCM590XX_REG_RANGES(sdsr2, dcdc_iosr1_ranges),\n\tBCM590XX_REG_RANGES(vsr, dcdc_iosr1_ranges),\n\tBCM590XX_REG_TABLE(gpldo1, ldo_a_table),\n\tBCM590XX_REG_TABLE(gpldo2, ldo_a_table),\n\tBCM590XX_REG_TABLE(gpldo3, ldo_a_table),\n\tBCM590XX_REG_TABLE(gpldo4, ldo_a_table),\n\tBCM590XX_REG_TABLE(gpldo5, ldo_a_table),\n\tBCM590XX_REG_TABLE(gpldo6, ldo_a_table),\n\tBCM590XX_REG_TABLE(vbus, ldo_vbus),\n};\n\nstruct bcm590xx_reg {\n\tstruct regulator_desc *desc;\n\tstruct bcm590xx *mfd;\n};\n\nstatic int bcm590xx_get_vsel_register(int id)\n{\n\tif (BCM590XX_REG_IS_LDO(id))\n\t\treturn BCM590XX_RFLDOCTRL + id;\n\telse if (BCM590XX_REG_IS_GPLDO(id))\n\t\treturn BCM590XX_GPLDO1CTRL + id;\n\telse\n\t\treturn BCM590XX_CSRVOUT1 + (id - BCM590XX_REG_CSR) * 3;\n}\n\nstatic int bcm590xx_get_enable_register(int id)\n{\n\tint reg = 0;\n\n\tif (BCM590XX_REG_IS_LDO(id))\n\t\treg = BCM590XX_RFLDOPMCTRL1 + id * 2;\n\telse if (BCM590XX_REG_IS_GPLDO(id))\n\t\treg = BCM590XX_GPLDO1PMCTRL1 + id * 2;\n\telse\n\t\tswitch (id) {\n\t\tcase BCM590XX_REG_CSR:\n\t\t\treg = BCM590XX_CSRPMCTRL1;\n\t\t\tbreak;\n\t\tcase BCM590XX_REG_IOSR1:\n\t\t\treg = BCM590XX_IOSR1PMCTRL1;\n\t\t\tbreak;\n\t\tcase BCM590XX_REG_IOSR2:\n\t\t\treg = BCM590XX_IOSR2PMCTRL1;\n\t\t\tbreak;\n\t\tcase BCM590XX_REG_MSR:\n\t\t\treg = BCM590XX_MSRPMCTRL1;\n\t\t\tbreak;\n\t\tcase BCM590XX_REG_SDSR1:\n\t\t\treg = BCM590XX_SDSR1PMCTRL1;\n\t\t\tbreak;\n\t\tcase BCM590XX_REG_SDSR2:\n\t\t\treg = BCM590XX_SDSR2PMCTRL1;\n\t\t\tbreak;\n\t\tcase BCM590XX_REG_VSR:\n\t\t\treg = BCM590XX_VSRPMCTRL1;\n\t\t\tbreak;\n\t\tcase BCM590XX_REG_VBUS:\n\t\t\treg = BCM590XX_OTG_CTRL;\n\t\t\tbreak;\n\t\t}\n\n\n\treturn reg;\n}\n\nstatic const struct regulator_ops bcm590xx_ops_ldo = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_table,\n\t.map_voltage\t\t= regulator_map_voltage_iterate,\n};\n\nstatic const struct regulator_ops bcm590xx_ops_dcdc = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n};\n\nstatic const struct regulator_ops bcm590xx_ops_vbus = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n};\n\nstatic int bcm590xx_probe(struct platform_device *pdev)\n{\n\tstruct bcm590xx *bcm590xx = dev_get_drvdata(pdev->dev.parent);\n\tstruct bcm590xx_reg *pmu;\n\tstruct regulator_config config = { };\n\tstruct bcm590xx_info *info;\n\tstruct regulator_dev *rdev;\n\tint i;\n\n\tpmu = devm_kzalloc(&pdev->dev, sizeof(*pmu), GFP_KERNEL);\n\tif (!pmu)\n\t\treturn -ENOMEM;\n\n\tpmu->mfd = bcm590xx;\n\n\tplatform_set_drvdata(pdev, pmu);\n\n\tpmu->desc = devm_kcalloc(&pdev->dev,\n\t\t\t\t BCM590XX_NUM_REGS,\n\t\t\t\t sizeof(struct regulator_desc),\n\t\t\t\t GFP_KERNEL);\n\tif (!pmu->desc)\n\t\treturn -ENOMEM;\n\n\tinfo = bcm590xx_regs;\n\n\tfor (i = 0; i < BCM590XX_NUM_REGS; i++, info++) {\n\t\t \n\t\tpmu->desc[i].name = info->name;\n\t\tpmu->desc[i].of_match = of_match_ptr(info->name);\n\t\tpmu->desc[i].regulators_node = of_match_ptr(\"regulators\");\n\t\tpmu->desc[i].supply_name = info->vin_name;\n\t\tpmu->desc[i].id = i;\n\t\tpmu->desc[i].volt_table = info->volt_table;\n\t\tpmu->desc[i].n_voltages = info->n_voltages;\n\t\tpmu->desc[i].linear_ranges = info->linear_ranges;\n\t\tpmu->desc[i].n_linear_ranges = info->n_linear_ranges;\n\n\t\tif ((BCM590XX_REG_IS_LDO(i)) || (BCM590XX_REG_IS_GPLDO(i))) {\n\t\t\tpmu->desc[i].ops = &bcm590xx_ops_ldo;\n\t\t\tpmu->desc[i].vsel_mask = BCM590XX_LDO_VSEL_MASK;\n\t\t} else if (BCM590XX_REG_IS_VBUS(i))\n\t\t\tpmu->desc[i].ops = &bcm590xx_ops_vbus;\n\t\telse {\n\t\t\tpmu->desc[i].ops = &bcm590xx_ops_dcdc;\n\t\t\tpmu->desc[i].vsel_mask = BCM590XX_SR_VSEL_MASK;\n\t\t}\n\n\t\tif (BCM590XX_REG_IS_VBUS(i))\n\t\t\tpmu->desc[i].enable_mask = BCM590XX_VBUS_ENABLE;\n\t\telse {\n\t\t\tpmu->desc[i].vsel_reg = bcm590xx_get_vsel_register(i);\n\t\t\tpmu->desc[i].enable_is_inverted = true;\n\t\t\tpmu->desc[i].enable_mask = BCM590XX_REG_ENABLE;\n\t\t}\n\t\tpmu->desc[i].enable_reg = bcm590xx_get_enable_register(i);\n\t\tpmu->desc[i].type = REGULATOR_VOLTAGE;\n\t\tpmu->desc[i].owner = THIS_MODULE;\n\n\t\tconfig.dev = bcm590xx->dev;\n\t\tconfig.driver_data = pmu;\n\t\tif (BCM590XX_REG_IS_GPLDO(i) || BCM590XX_REG_IS_VBUS(i))\n\t\t\tconfig.regmap = bcm590xx->regmap_sec;\n\t\telse\n\t\t\tconfig.regmap = bcm590xx->regmap_pri;\n\n\t\trdev = devm_regulator_register(&pdev->dev, &pmu->desc[i],\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(bcm590xx->dev,\n\t\t\t\t\"failed to register %s regulator\\n\",\n\t\t\t\tpdev->name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver bcm590xx_regulator_driver = {\n\t.driver = {\n\t\t.name = \"bcm590xx-vregs\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = bcm590xx_probe,\n};\nmodule_platform_driver(bcm590xx_regulator_driver);\n\nMODULE_AUTHOR(\"Matt Porter <mporter@linaro.org>\");\nMODULE_DESCRIPTION(\"BCM590xx voltage regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:bcm590xx-vregs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}