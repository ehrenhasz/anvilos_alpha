{
  "module_name": "palmas-regulator.c",
  "hash_id": "139e08ea69f995bda2adabeb69e8a6a10063e17dd07c23da0462254953ca874d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/palmas-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <linux/mfd/palmas.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/regulator/of_regulator.h>\n\nstatic const struct linear_range smps_low_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(0, 0x0, 0x0, 0),\n\tREGULATOR_LINEAR_RANGE(500000, 0x1, 0x6, 0),\n\tREGULATOR_LINEAR_RANGE(510000, 0x7, 0x79, 10000),\n\tREGULATOR_LINEAR_RANGE(1650000, 0x7A, 0x7f, 0),\n};\n\nstatic const struct linear_range smps_high_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(0, 0x0, 0x0, 0),\n\tREGULATOR_LINEAR_RANGE(1000000, 0x1, 0x6, 0),\n\tREGULATOR_LINEAR_RANGE(1020000, 0x7, 0x79, 20000),\n\tREGULATOR_LINEAR_RANGE(3300000, 0x7A, 0x7f, 0),\n};\n\nstatic struct palmas_regs_info palmas_generic_regs_info[] = {\n\t{\n\t\t.name\t\t= \"SMPS12\",\n\t\t.sname\t\t= \"smps1-in\",\n\t\t.vsel_addr\t= PALMAS_SMPS12_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_SMPS12_CTRL,\n\t\t.tstep_addr\t= PALMAS_SMPS12_TSTEP,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_SMPS12,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS123\",\n\t\t.sname\t\t= \"smps1-in\",\n\t\t.vsel_addr\t= PALMAS_SMPS12_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_SMPS12_CTRL,\n\t\t.tstep_addr\t= PALMAS_SMPS12_TSTEP,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_SMPS12,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS3\",\n\t\t.sname\t\t= \"smps3-in\",\n\t\t.vsel_addr\t= PALMAS_SMPS3_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_SMPS3_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_SMPS3,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS45\",\n\t\t.sname\t\t= \"smps4-in\",\n\t\t.vsel_addr\t= PALMAS_SMPS45_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_SMPS45_CTRL,\n\t\t.tstep_addr\t= PALMAS_SMPS45_TSTEP,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_SMPS45,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS457\",\n\t\t.sname\t\t= \"smps4-in\",\n\t\t.vsel_addr\t= PALMAS_SMPS45_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_SMPS45_CTRL,\n\t\t.tstep_addr\t= PALMAS_SMPS45_TSTEP,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_SMPS45,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS6\",\n\t\t.sname\t\t= \"smps6-in\",\n\t\t.vsel_addr\t= PALMAS_SMPS6_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_SMPS6_CTRL,\n\t\t.tstep_addr\t= PALMAS_SMPS6_TSTEP,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_SMPS6,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS7\",\n\t\t.sname\t\t= \"smps7-in\",\n\t\t.vsel_addr\t= PALMAS_SMPS7_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_SMPS7_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_SMPS7,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS8\",\n\t\t.sname\t\t= \"smps8-in\",\n\t\t.vsel_addr\t= PALMAS_SMPS8_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_SMPS8_CTRL,\n\t\t.tstep_addr\t= PALMAS_SMPS8_TSTEP,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_SMPS8,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS9\",\n\t\t.sname\t\t= \"smps9-in\",\n\t\t.vsel_addr\t= PALMAS_SMPS9_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_SMPS9_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_SMPS9,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS10_OUT2\",\n\t\t.sname\t\t= \"smps10-in\",\n\t\t.ctrl_addr\t= PALMAS_SMPS10_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_SMPS10,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS10_OUT1\",\n\t\t.sname\t\t= \"smps10-out2\",\n\t\t.ctrl_addr\t= PALMAS_SMPS10_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_SMPS10,\n\t},\n\t{\n\t\t.name\t\t= \"LDO1\",\n\t\t.sname\t\t= \"ldo1-in\",\n\t\t.vsel_addr\t= PALMAS_LDO1_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_LDO1_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_LDO1,\n\t},\n\t{\n\t\t.name\t\t= \"LDO2\",\n\t\t.sname\t\t= \"ldo2-in\",\n\t\t.vsel_addr\t= PALMAS_LDO2_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_LDO2_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_LDO2,\n\t},\n\t{\n\t\t.name\t\t= \"LDO3\",\n\t\t.sname\t\t= \"ldo3-in\",\n\t\t.vsel_addr\t= PALMAS_LDO3_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_LDO3_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_LDO3,\n\t},\n\t{\n\t\t.name\t\t= \"LDO4\",\n\t\t.sname\t\t= \"ldo4-in\",\n\t\t.vsel_addr\t= PALMAS_LDO4_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_LDO4_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_LDO4,\n\t},\n\t{\n\t\t.name\t\t= \"LDO5\",\n\t\t.sname\t\t= \"ldo5-in\",\n\t\t.vsel_addr\t= PALMAS_LDO5_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_LDO5_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_LDO5,\n\t},\n\t{\n\t\t.name\t\t= \"LDO6\",\n\t\t.sname\t\t= \"ldo6-in\",\n\t\t.vsel_addr\t= PALMAS_LDO6_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_LDO6_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_LDO6,\n\t},\n\t{\n\t\t.name\t\t= \"LDO7\",\n\t\t.sname\t\t= \"ldo7-in\",\n\t\t.vsel_addr\t= PALMAS_LDO7_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_LDO7_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_LDO7,\n\t},\n\t{\n\t\t.name\t\t= \"LDO8\",\n\t\t.sname\t\t= \"ldo8-in\",\n\t\t.vsel_addr\t= PALMAS_LDO8_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_LDO8_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_LDO8,\n\t},\n\t{\n\t\t.name\t\t= \"LDO9\",\n\t\t.sname\t\t= \"ldo9-in\",\n\t\t.vsel_addr\t= PALMAS_LDO9_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_LDO9_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_LDO9,\n\t},\n\t{\n\t\t.name\t\t= \"LDOLN\",\n\t\t.sname\t\t= \"ldoln-in\",\n\t\t.vsel_addr\t= PALMAS_LDOLN_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_LDOLN_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_LDOLN,\n\t},\n\t{\n\t\t.name\t\t= \"LDOUSB\",\n\t\t.sname\t\t= \"ldousb-in\",\n\t\t.vsel_addr\t= PALMAS_LDOUSB_VOLTAGE,\n\t\t.ctrl_addr\t= PALMAS_LDOUSB_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_LDOUSB,\n\t},\n\t{\n\t\t.name\t\t= \"REGEN1\",\n\t\t.ctrl_addr\t= PALMAS_REGEN1_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_REGEN1,\n\t},\n\t{\n\t\t.name\t\t= \"REGEN2\",\n\t\t.ctrl_addr\t= PALMAS_REGEN2_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_REGEN2,\n\t},\n\t{\n\t\t.name\t\t= \"REGEN3\",\n\t\t.ctrl_addr\t= PALMAS_REGEN3_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_REGEN3,\n\t},\n\t{\n\t\t.name\t\t= \"SYSEN1\",\n\t\t.ctrl_addr\t= PALMAS_SYSEN1_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_SYSEN1,\n\t},\n\t{\n\t\t.name\t\t= \"SYSEN2\",\n\t\t.ctrl_addr\t= PALMAS_SYSEN2_CTRL,\n\t\t.sleep_id\t= PALMAS_EXTERNAL_REQSTR_ID_SYSEN2,\n\t},\n};\n\nstatic struct palmas_regs_info tps65917_regs_info[] = {\n\t{\n\t\t.name\t\t= \"SMPS1\",\n\t\t.sname\t\t= \"smps1-in\",\n\t\t.vsel_addr\t= TPS65917_SMPS1_VOLTAGE,\n\t\t.ctrl_addr\t= TPS65917_SMPS1_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_SMPS1,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS2\",\n\t\t.sname\t\t= \"smps2-in\",\n\t\t.vsel_addr\t= TPS65917_SMPS2_VOLTAGE,\n\t\t.ctrl_addr\t= TPS65917_SMPS2_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_SMPS2,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS3\",\n\t\t.sname\t\t= \"smps3-in\",\n\t\t.vsel_addr\t= TPS65917_SMPS3_VOLTAGE,\n\t\t.ctrl_addr\t= TPS65917_SMPS3_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_SMPS3,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS4\",\n\t\t.sname\t\t= \"smps4-in\",\n\t\t.vsel_addr\t= TPS65917_SMPS4_VOLTAGE,\n\t\t.ctrl_addr\t= TPS65917_SMPS4_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_SMPS4,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS5\",\n\t\t.sname\t\t= \"smps5-in\",\n\t\t.vsel_addr\t= TPS65917_SMPS5_VOLTAGE,\n\t\t.ctrl_addr\t= TPS65917_SMPS5_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_SMPS5,\n\t},\n\t{\n\t\t.name\t\t= \"SMPS12\",\n\t\t.sname\t\t= \"smps1-in\",\n\t\t.vsel_addr\t= TPS65917_SMPS1_VOLTAGE,\n\t\t.ctrl_addr\t= TPS65917_SMPS1_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_SMPS12,\n\t},\n\t{\n\t\t.name\t\t= \"LDO1\",\n\t\t.sname\t\t= \"ldo1-in\",\n\t\t.vsel_addr\t= TPS65917_LDO1_VOLTAGE,\n\t\t.ctrl_addr\t= TPS65917_LDO1_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_LDO1,\n\t},\n\t{\n\t\t.name\t\t= \"LDO2\",\n\t\t.sname\t\t= \"ldo2-in\",\n\t\t.vsel_addr\t= TPS65917_LDO2_VOLTAGE,\n\t\t.ctrl_addr\t= TPS65917_LDO2_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_LDO2,\n\t},\n\t{\n\t\t.name\t\t= \"LDO3\",\n\t\t.sname\t\t= \"ldo3-in\",\n\t\t.vsel_addr\t= TPS65917_LDO3_VOLTAGE,\n\t\t.ctrl_addr\t= TPS65917_LDO3_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_LDO3,\n\t},\n\t{\n\t\t.name\t\t= \"LDO4\",\n\t\t.sname\t\t= \"ldo4-in\",\n\t\t.vsel_addr\t= TPS65917_LDO4_VOLTAGE,\n\t\t.ctrl_addr\t= TPS65917_LDO4_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_LDO4,\n\t},\n\t{\n\t\t.name\t\t= \"LDO5\",\n\t\t.sname\t\t= \"ldo5-in\",\n\t\t.vsel_addr\t= TPS65917_LDO5_VOLTAGE,\n\t\t.ctrl_addr\t= TPS65917_LDO5_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_LDO5,\n\t},\n\t{\n\t\t.name\t\t= \"REGEN1\",\n\t\t.ctrl_addr\t= TPS65917_REGEN1_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_REGEN1,\n\t},\n\t{\n\t\t.name\t\t= \"REGEN2\",\n\t\t.ctrl_addr\t= TPS65917_REGEN2_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_REGEN2,\n\t},\n\t{\n\t\t.name\t\t= \"REGEN3\",\n\t\t.ctrl_addr\t= TPS65917_REGEN3_CTRL,\n\t\t.sleep_id\t= TPS65917_EXTERNAL_REQSTR_ID_REGEN3,\n\t},\n};\n\n#define EXTERNAL_REQUESTOR(_id, _offset, _pos)\t\t\\\n\t[PALMAS_EXTERNAL_REQSTR_ID_##_id] = {\t\t\\\n\t\t.id = PALMAS_EXTERNAL_REQSTR_ID_##_id,\t\\\n\t\t.reg_offset = _offset,\t\t\t\\\n\t\t.bit_pos = _pos,\t\t\t\\\n\t}\n\nstatic struct palmas_sleep_requestor_info palma_sleep_req_info[] = {\n\tEXTERNAL_REQUESTOR(REGEN1, 0, 0),\n\tEXTERNAL_REQUESTOR(REGEN2, 0, 1),\n\tEXTERNAL_REQUESTOR(SYSEN1, 0, 2),\n\tEXTERNAL_REQUESTOR(SYSEN2, 0, 3),\n\tEXTERNAL_REQUESTOR(CLK32KG, 0, 4),\n\tEXTERNAL_REQUESTOR(CLK32KGAUDIO, 0, 5),\n\tEXTERNAL_REQUESTOR(REGEN3, 0, 6),\n\tEXTERNAL_REQUESTOR(SMPS12, 1, 0),\n\tEXTERNAL_REQUESTOR(SMPS3, 1, 1),\n\tEXTERNAL_REQUESTOR(SMPS45, 1, 2),\n\tEXTERNAL_REQUESTOR(SMPS6, 1, 3),\n\tEXTERNAL_REQUESTOR(SMPS7, 1, 4),\n\tEXTERNAL_REQUESTOR(SMPS8, 1, 5),\n\tEXTERNAL_REQUESTOR(SMPS9, 1, 6),\n\tEXTERNAL_REQUESTOR(SMPS10, 1, 7),\n\tEXTERNAL_REQUESTOR(LDO1, 2, 0),\n\tEXTERNAL_REQUESTOR(LDO2, 2, 1),\n\tEXTERNAL_REQUESTOR(LDO3, 2, 2),\n\tEXTERNAL_REQUESTOR(LDO4, 2, 3),\n\tEXTERNAL_REQUESTOR(LDO5, 2, 4),\n\tEXTERNAL_REQUESTOR(LDO6, 2, 5),\n\tEXTERNAL_REQUESTOR(LDO7, 2, 6),\n\tEXTERNAL_REQUESTOR(LDO8, 2, 7),\n\tEXTERNAL_REQUESTOR(LDO9, 3, 0),\n\tEXTERNAL_REQUESTOR(LDOLN, 3, 1),\n\tEXTERNAL_REQUESTOR(LDOUSB, 3, 2),\n};\n\n#define EXTERNAL_REQUESTOR_TPS65917(_id, _offset, _pos)\t\t\\\n\t[TPS65917_EXTERNAL_REQSTR_ID_##_id] = {\t\t\\\n\t\t.id = TPS65917_EXTERNAL_REQSTR_ID_##_id,\t\\\n\t\t.reg_offset = _offset,\t\t\t\\\n\t\t.bit_pos = _pos,\t\t\t\\\n\t}\n\nstatic struct palmas_sleep_requestor_info tps65917_sleep_req_info[] = {\n\tEXTERNAL_REQUESTOR_TPS65917(REGEN1, 0, 0),\n\tEXTERNAL_REQUESTOR_TPS65917(REGEN2, 0, 1),\n\tEXTERNAL_REQUESTOR_TPS65917(REGEN3, 0, 6),\n\tEXTERNAL_REQUESTOR_TPS65917(SMPS1, 1, 0),\n\tEXTERNAL_REQUESTOR_TPS65917(SMPS2, 1, 1),\n\tEXTERNAL_REQUESTOR_TPS65917(SMPS3, 1, 2),\n\tEXTERNAL_REQUESTOR_TPS65917(SMPS4, 1, 3),\n\tEXTERNAL_REQUESTOR_TPS65917(SMPS5, 1, 4),\n\tEXTERNAL_REQUESTOR_TPS65917(SMPS12, 1, 5),\n\tEXTERNAL_REQUESTOR_TPS65917(LDO1, 2, 0),\n\tEXTERNAL_REQUESTOR_TPS65917(LDO2, 2, 1),\n\tEXTERNAL_REQUESTOR_TPS65917(LDO3, 2, 2),\n\tEXTERNAL_REQUESTOR_TPS65917(LDO4, 2, 3),\n\tEXTERNAL_REQUESTOR_TPS65917(LDO5, 2, 4),\n};\n\nstatic const unsigned int palmas_smps_ramp_delay[4] = {0, 10000, 5000, 2500};\n\n#define SMPS_CTRL_MODE_OFF\t\t0x00\n#define SMPS_CTRL_MODE_ON\t\t0x01\n#define SMPS_CTRL_MODE_ECO\t\t0x02\n#define SMPS_CTRL_MODE_PWM\t\t0x03\n\n#define PALMAS_SMPS_NUM_VOLTAGES\t122\n#define PALMAS_SMPS10_NUM_VOLTAGES\t2\n#define PALMAS_LDO_NUM_VOLTAGES\t\t50\n\n#define SMPS10_VSEL\t\t\t(1<<3)\n#define SMPS10_BOOST_EN\t\t\t(1<<2)\n#define SMPS10_BYPASS_EN\t\t(1<<1)\n#define SMPS10_SWITCH_EN\t\t(1<<0)\n\n#define REGULATOR_SLAVE\t\t\t0\n\nstatic int palmas_smps_read(struct palmas *palmas, unsigned int reg,\n\t\tunsigned int *dest)\n{\n\tunsigned int addr;\n\n\taddr = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE, reg);\n\n\treturn regmap_read(palmas->regmap[REGULATOR_SLAVE], addr, dest);\n}\n\nstatic int palmas_smps_write(struct palmas *palmas, unsigned int reg,\n\t\tunsigned int value)\n{\n\tunsigned int addr;\n\n\taddr = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE, reg);\n\n\treturn regmap_write(palmas->regmap[REGULATOR_SLAVE], addr, value);\n}\n\nstatic int palmas_ldo_read(struct palmas *palmas, unsigned int reg,\n\t\tunsigned int *dest)\n{\n\tunsigned int addr;\n\n\taddr = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE, reg);\n\n\treturn regmap_read(palmas->regmap[REGULATOR_SLAVE], addr, dest);\n}\n\nstatic int palmas_ldo_write(struct palmas *palmas, unsigned int reg,\n\t\tunsigned int value)\n{\n\tunsigned int addr;\n\n\taddr = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE, reg);\n\n\treturn regmap_write(palmas->regmap[REGULATOR_SLAVE], addr, value);\n}\n\nstatic int palmas_set_mode_smps(struct regulator_dev *dev, unsigned int mode)\n{\n\tint id = rdev_get_id(dev);\n\tint ret;\n\tstruct palmas_pmic *pmic = rdev_get_drvdata(dev);\n\tstruct palmas_pmic_driver_data *ddata = pmic->palmas->pmic_ddata;\n\tstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\n\tunsigned int reg;\n\tbool rail_enable = true;\n\n\tret = palmas_smps_read(pmic->palmas, rinfo->ctrl_addr, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\treg &= ~PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\n\n\tif (reg == SMPS_CTRL_MODE_OFF)\n\t\trail_enable = false;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\treg |= SMPS_CTRL_MODE_ON;\n\t\tbreak;\n\tcase REGULATOR_MODE_IDLE:\n\t\treg |= SMPS_CTRL_MODE_ECO;\n\t\tbreak;\n\tcase REGULATOR_MODE_FAST:\n\t\treg |= SMPS_CTRL_MODE_PWM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpmic->current_reg_mode[id] = reg & PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\n\tif (rail_enable)\n\t\tpalmas_smps_write(pmic->palmas, rinfo->ctrl_addr, reg);\n\n\t \n\tpmic->desc[id].enable_val = pmic->current_reg_mode[id];\n\n\treturn 0;\n}\n\nstatic unsigned int palmas_get_mode_smps(struct regulator_dev *dev)\n{\n\tstruct palmas_pmic *pmic = rdev_get_drvdata(dev);\n\tint id = rdev_get_id(dev);\n\tunsigned int reg;\n\n\treg = pmic->current_reg_mode[id] & PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\n\n\tswitch (reg) {\n\tcase SMPS_CTRL_MODE_ON:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase SMPS_CTRL_MODE_ECO:\n\t\treturn REGULATOR_MODE_IDLE;\n\tcase SMPS_CTRL_MODE_PWM:\n\t\treturn REGULATOR_MODE_FAST;\n\t}\n\n\treturn 0;\n}\n\nstatic int palmas_smps_set_ramp_delay(struct regulator_dev *rdev,\n\t\t int ramp_delay)\n{\n\tint id = rdev_get_id(rdev);\n\tstruct palmas_pmic *pmic = rdev_get_drvdata(rdev);\n\tstruct palmas_pmic_driver_data *ddata = pmic->palmas->pmic_ddata;\n\tstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\n\tunsigned int reg = 0;\n\tint ret;\n\n\t \n\tswitch (id) {\n\tcase PALMAS_REG_SMPS3:\n\tcase PALMAS_REG_SMPS7:\n\t\treturn 0;\n\t}\n\n\tif (ramp_delay <= 0)\n\t\treg = 0;\n\telse if (ramp_delay <= 2500)\n\t\treg = 3;\n\telse if (ramp_delay <= 5000)\n\t\treg = 2;\n\telse\n\t\treg = 1;\n\n\tret = palmas_smps_write(pmic->palmas, rinfo->tstep_addr, reg);\n\tif (ret < 0) {\n\t\tdev_err(pmic->palmas->dev, \"TSTEP write failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpmic->ramp_delay[id] = palmas_smps_ramp_delay[reg];\n\treturn ret;\n}\n\nstatic const struct regulator_ops palmas_ops_smps = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.set_mode\t\t= palmas_set_mode_smps,\n\t.get_mode\t\t= palmas_get_mode_smps,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n\t.set_voltage_time_sel\t= regulator_set_voltage_time_sel,\n\t.set_ramp_delay\t\t= palmas_smps_set_ramp_delay,\n};\n\nstatic const struct regulator_ops palmas_ops_ext_control_smps = {\n\t.set_mode\t\t= palmas_set_mode_smps,\n\t.get_mode\t\t= palmas_get_mode_smps,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n\t.set_voltage_time_sel\t= regulator_set_voltage_time_sel,\n\t.set_ramp_delay\t\t= palmas_smps_set_ramp_delay,\n};\n\nstatic const struct regulator_ops palmas_ops_smps10 = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n\t.set_bypass\t\t= regulator_set_bypass_regmap,\n\t.get_bypass\t\t= regulator_get_bypass_regmap,\n};\n\nstatic const struct regulator_ops tps65917_ops_smps = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.set_mode\t\t= palmas_set_mode_smps,\n\t.get_mode\t\t= palmas_get_mode_smps,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n\t.set_voltage_time_sel\t= regulator_set_voltage_time_sel,\n};\n\nstatic const struct regulator_ops tps65917_ops_ext_control_smps = {\n\t.set_mode\t\t= palmas_set_mode_smps,\n\t.get_mode\t\t= palmas_get_mode_smps,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n};\n\nstatic int palmas_is_enabled_ldo(struct regulator_dev *dev)\n{\n\tint id = rdev_get_id(dev);\n\tstruct palmas_pmic *pmic = rdev_get_drvdata(dev);\n\tstruct palmas_pmic_driver_data *ddata = pmic->palmas->pmic_ddata;\n\tstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\n\tunsigned int reg;\n\n\tpalmas_ldo_read(pmic->palmas, rinfo->ctrl_addr, &reg);\n\n\treg &= PALMAS_LDO1_CTRL_STATUS;\n\n\treturn !!(reg);\n}\n\nstatic const struct regulator_ops palmas_ops_ldo = {\n\t.is_enabled\t\t= palmas_is_enabled_ldo,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n};\n\nstatic const struct regulator_ops palmas_ops_ldo9 = {\n\t.is_enabled\t\t= palmas_is_enabled_ldo,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n\t.set_bypass\t\t= regulator_set_bypass_regmap,\n\t.get_bypass\t\t= regulator_get_bypass_regmap,\n};\n\nstatic const struct regulator_ops palmas_ops_ext_control_ldo = {\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n};\n\nstatic const struct regulator_ops palmas_ops_extreg = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n};\n\nstatic const struct regulator_ops palmas_ops_ext_control_extreg = {\n};\n\nstatic const struct regulator_ops tps65917_ops_ldo = {\n\t.is_enabled\t\t= palmas_is_enabled_ldo,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n\t.set_voltage_time_sel\t= regulator_set_voltage_time_sel,\n};\n\nstatic const struct regulator_ops tps65917_ops_ldo_1_2 = {\n\t.is_enabled\t\t= palmas_is_enabled_ldo,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n\t.set_voltage_time_sel\t= regulator_set_voltage_time_sel,\n\t.set_bypass\t\t= regulator_set_bypass_regmap,\n\t.get_bypass\t\t= regulator_get_bypass_regmap,\n};\n\nstatic int palmas_regulator_config_external(struct palmas *palmas, int id,\n\t\tstruct palmas_reg_init *reg_init)\n{\n\tstruct palmas_pmic_driver_data *ddata = palmas->pmic_ddata;\n\tstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\n\tint ret;\n\n\tret = palmas_ext_control_req_config(palmas, rinfo->sleep_id,\n\t\t\t\t\t    reg_init->roof_floor, true);\n\tif (ret < 0)\n\t\tdev_err(palmas->dev,\n\t\t\t\"Ext control config for regulator %d failed %d\\n\",\n\t\t\tid, ret);\n\treturn ret;\n}\n\n \nstatic int palmas_smps_init(struct palmas *palmas, int id,\n\t\tstruct palmas_reg_init *reg_init)\n{\n\tunsigned int reg;\n\tint ret;\n\tstruct palmas_pmic_driver_data *ddata = palmas->pmic_ddata;\n\tstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\n\tunsigned int addr = rinfo->ctrl_addr;\n\n\tret = palmas_smps_read(palmas, addr, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (id) {\n\tcase PALMAS_REG_SMPS10_OUT1:\n\tcase PALMAS_REG_SMPS10_OUT2:\n\t\treg &= ~PALMAS_SMPS10_CTRL_MODE_SLEEP_MASK;\n\t\tif (reg_init->mode_sleep)\n\t\t\treg |= reg_init->mode_sleep <<\n\t\t\t\t\tPALMAS_SMPS10_CTRL_MODE_SLEEP_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tif (reg_init->warm_reset)\n\t\t\treg |= PALMAS_SMPS12_CTRL_WR_S;\n\t\telse\n\t\t\treg &= ~PALMAS_SMPS12_CTRL_WR_S;\n\n\t\tif (reg_init->roof_floor)\n\t\t\treg |= PALMAS_SMPS12_CTRL_ROOF_FLOOR_EN;\n\t\telse\n\t\t\treg &= ~PALMAS_SMPS12_CTRL_ROOF_FLOOR_EN;\n\n\t\treg &= ~PALMAS_SMPS12_CTRL_MODE_SLEEP_MASK;\n\t\tif (reg_init->mode_sleep)\n\t\t\treg |= reg_init->mode_sleep <<\n\t\t\t\t\tPALMAS_SMPS12_CTRL_MODE_SLEEP_SHIFT;\n\t}\n\n\tret = palmas_smps_write(palmas, addr, reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rinfo->vsel_addr && reg_init->vsel) {\n\n\t\treg = reg_init->vsel;\n\n\t\tret = palmas_smps_write(palmas, rinfo->vsel_addr, reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (reg_init->roof_floor && (id != PALMAS_REG_SMPS10_OUT1) &&\n\t\t\t(id != PALMAS_REG_SMPS10_OUT2)) {\n\t\t \n\t\tret = palmas_smps_read(palmas, addr, &reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(reg & PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK)) {\n\t\t\treg |= SMPS_CTRL_MODE_ON;\n\t\t\tret = palmas_smps_write(palmas, addr, reg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\treturn palmas_regulator_config_external(palmas, id, reg_init);\n\t}\n\treturn 0;\n}\n\nstatic int palmas_ldo_init(struct palmas *palmas, int id,\n\t\tstruct palmas_reg_init *reg_init)\n{\n\tunsigned int reg;\n\tunsigned int addr;\n\tint ret;\n\tstruct palmas_pmic_driver_data *ddata = palmas->pmic_ddata;\n\tstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\n\n\taddr = rinfo->ctrl_addr;\n\n\tret = palmas_ldo_read(palmas, addr, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reg_init->warm_reset)\n\t\treg |= PALMAS_LDO1_CTRL_WR_S;\n\telse\n\t\treg &= ~PALMAS_LDO1_CTRL_WR_S;\n\n\tif (reg_init->mode_sleep)\n\t\treg |= PALMAS_LDO1_CTRL_MODE_SLEEP;\n\telse\n\t\treg &= ~PALMAS_LDO1_CTRL_MODE_SLEEP;\n\n\tret = palmas_ldo_write(palmas, addr, reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reg_init->roof_floor) {\n\t\t \n\t\tret = palmas_update_bits(palmas, PALMAS_LDO_BASE,\n\t\t\t\taddr, PALMAS_LDO1_CTRL_MODE_ACTIVE,\n\t\t\t\tPALMAS_LDO1_CTRL_MODE_ACTIVE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(palmas->dev,\n\t\t\t\t\"LDO Register 0x%02x update failed %d\\n\",\n\t\t\t\taddr, ret);\n\t\t\treturn ret;\n\t\t}\n\t\treturn palmas_regulator_config_external(palmas, id, reg_init);\n\t}\n\treturn 0;\n}\n\nstatic int palmas_extreg_init(struct palmas *palmas, int id,\n\t\tstruct palmas_reg_init *reg_init)\n{\n\tunsigned int addr;\n\tint ret;\n\tunsigned int val = 0;\n\tstruct palmas_pmic_driver_data *ddata = palmas->pmic_ddata;\n\tstruct palmas_regs_info *rinfo = &ddata->palmas_regs_info[id];\n\n\taddr = rinfo->ctrl_addr;\n\n\tif (reg_init->mode_sleep)\n\t\tval = PALMAS_REGEN1_CTRL_MODE_SLEEP;\n\n\tret = palmas_update_bits(palmas, PALMAS_RESOURCE_BASE,\n\t\t\taddr, PALMAS_REGEN1_CTRL_MODE_SLEEP, val);\n\tif (ret < 0) {\n\t\tdev_err(palmas->dev, \"Resource reg 0x%02x update failed %d\\n\",\n\t\t\taddr, ret);\n\t\treturn ret;\n\t}\n\n\tif (reg_init->roof_floor) {\n\t\t \n\t\tret = palmas_update_bits(palmas, PALMAS_RESOURCE_BASE,\n\t\t\t\taddr, PALMAS_REGEN1_CTRL_MODE_ACTIVE,\n\t\t\t\tPALMAS_REGEN1_CTRL_MODE_ACTIVE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(palmas->dev,\n\t\t\t\t\"Resource Register 0x%02x update failed %d\\n\",\n\t\t\t\taddr, ret);\n\t\t\treturn ret;\n\t\t}\n\t\treturn palmas_regulator_config_external(palmas, id, reg_init);\n\t}\n\treturn 0;\n}\n\nstatic void palmas_enable_ldo8_track(struct palmas *palmas)\n{\n\tunsigned int reg;\n\tunsigned int addr;\n\tint ret;\n\tstruct palmas_pmic_driver_data *ddata = palmas->pmic_ddata;\n\tstruct palmas_regs_info *rinfo;\n\n\trinfo = &ddata->palmas_regs_info[PALMAS_REG_LDO8];\n\taddr = rinfo->ctrl_addr;\n\n\tret = palmas_ldo_read(palmas, addr, &reg);\n\tif (ret) {\n\t\tdev_err(palmas->dev, \"Error in reading ldo8 control reg\\n\");\n\t\treturn;\n\t}\n\n\treg |= PALMAS_LDO8_CTRL_LDO_TRACKING_EN;\n\tret = palmas_ldo_write(palmas, addr, reg);\n\tif (ret < 0) {\n\t\tdev_err(palmas->dev, \"Error in enabling tracking mode\\n\");\n\t\treturn;\n\t}\n\t \n\taddr = rinfo->vsel_addr;\n\tret = palmas_ldo_read(palmas, addr, &reg);\n\tif (ret) {\n\t\tdev_err(palmas->dev, \"Error in reading ldo8 voltage reg\\n\");\n\t\treturn;\n\t}\n\n\treg = (reg << 1) & PALMAS_LDO8_VOLTAGE_VSEL_MASK;\n\tret = palmas_ldo_write(palmas, addr, reg);\n\tif (ret < 0)\n\t\tdev_err(palmas->dev, \"Error in setting ldo8 voltage reg\\n\");\n\n\treturn;\n}\n\nstatic int palmas_ldo_registration(struct palmas_pmic *pmic,\n\t\t\t\t   struct palmas_pmic_driver_data *ddata,\n\t\t\t\t   struct palmas_pmic_platform_data *pdata,\n\t\t\t\t   const char *pdev_name,\n\t\t\t\t   struct regulator_config config)\n{\n\tint id, ret;\n\tstruct regulator_dev *rdev;\n\tstruct palmas_reg_init *reg_init;\n\tstruct palmas_regs_info *rinfo;\n\tstruct regulator_desc *desc;\n\n\tfor (id = ddata->ldo_begin; id < ddata->max_reg; id++) {\n\t\tif (pdata && pdata->reg_init[id])\n\t\t\treg_init = pdata->reg_init[id];\n\t\telse\n\t\t\treg_init = NULL;\n\n\t\trinfo = &ddata->palmas_regs_info[id];\n\t\t \n\n\t\t \n\t\tdesc = &pmic->desc[id];\n\t\tdesc->name = rinfo->name;\n\t\tdesc->id = id;\n\t\tdesc->type = REGULATOR_VOLTAGE;\n\t\tdesc->owner = THIS_MODULE;\n\n\t\tif (id < PALMAS_REG_REGEN1) {\n\t\t\tdesc->n_voltages = PALMAS_LDO_NUM_VOLTAGES;\n\t\t\tif (reg_init && reg_init->roof_floor)\n\t\t\t\tdesc->ops = &palmas_ops_ext_control_ldo;\n\t\t\telse\n\t\t\t\tdesc->ops = &palmas_ops_ldo;\n\t\t\tdesc->min_uV = 900000;\n\t\t\tdesc->uV_step = 50000;\n\t\t\tdesc->linear_min_sel = 1;\n\t\t\tdesc->enable_time = 500;\n\t\t\tdesc->vsel_reg = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE,\n\t\t\t\t\t\t\t    rinfo->vsel_addr);\n\t\t\tdesc->vsel_mask = PALMAS_LDO1_VOLTAGE_VSEL_MASK;\n\t\t\tdesc->enable_reg = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE,\n\t\t\t\t\t\t\t      rinfo->ctrl_addr);\n\t\t\tdesc->enable_mask = PALMAS_LDO1_CTRL_MODE_ACTIVE;\n\n\t\t\t \n\t\t\tif (pdata && (id == PALMAS_REG_LDO8) &&\n\t\t\t    pdata->enable_ldo8_tracking) {\n\t\t\t\tpalmas_enable_ldo8_track(pmic->palmas);\n\t\t\t\tdesc->min_uV = 450000;\n\t\t\t\tdesc->uV_step = 25000;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (pdata && pdata->ldo6_vibrator &&\n\t\t\t    (id == PALMAS_REG_LDO6))\n\t\t\t\tdesc->enable_time = 2000;\n\n\t\t\tif (id == PALMAS_REG_LDO9) {\n\t\t\t\tdesc->ops = &palmas_ops_ldo9;\n\t\t\t\tdesc->bypass_reg = desc->enable_reg;\n\t\t\t\tdesc->bypass_val_on =\n\t\t\t\t\t\tPALMAS_LDO9_CTRL_LDO_BYPASS_EN;\n\t\t\t\tdesc->bypass_mask =\n\t\t\t\t\t\tPALMAS_LDO9_CTRL_LDO_BYPASS_EN;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ddata->has_regen3 && id == PALMAS_REG_REGEN3)\n\t\t\t\tcontinue;\n\n\t\t\tdesc->n_voltages = 1;\n\t\t\tif (reg_init && reg_init->roof_floor)\n\t\t\t\tdesc->ops = &palmas_ops_ext_control_extreg;\n\t\t\telse\n\t\t\t\tdesc->ops = &palmas_ops_extreg;\n\t\t\tdesc->enable_reg =\n\t\t\t\t\tPALMAS_BASE_TO_REG(PALMAS_RESOURCE_BASE,\n\t\t\t\t\t\t\t   rinfo->ctrl_addr);\n\t\t\tdesc->enable_mask = PALMAS_REGEN1_CTRL_MODE_ACTIVE;\n\t\t}\n\n\t\tif (pdata)\n\t\t\tconfig.init_data = pdata->reg_data[id];\n\t\telse\n\t\t\tconfig.init_data = NULL;\n\n\t\tdesc->supply_name = rinfo->sname;\n\t\tconfig.of_node = ddata->palmas_matches[id].of_node;\n\n\t\trdev = devm_regulator_register(pmic->dev, desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(pmic->dev,\n\t\t\t\t\"failed to register %s regulator\\n\",\n\t\t\t\tpdev_name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\n\t\t \n\t\tif (pdata) {\n\t\t\treg_init = pdata->reg_init[id];\n\t\t\tif (reg_init) {\n\t\t\t\tif (id <= ddata->ldo_end)\n\t\t\t\t\tret = palmas_ldo_init(pmic->palmas, id,\n\t\t\t\t\t\t\t      reg_init);\n\t\t\t\telse\n\t\t\t\t\tret = palmas_extreg_init(pmic->palmas,\n\t\t\t\t\t\t\t\t id, reg_init);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tps65917_ldo_registration(struct palmas_pmic *pmic,\n\t\t\t\t     struct palmas_pmic_driver_data *ddata,\n\t\t\t\t     struct palmas_pmic_platform_data *pdata,\n\t\t\t\t     const char *pdev_name,\n\t\t\t\t     struct regulator_config config)\n{\n\tint id, ret;\n\tstruct regulator_dev *rdev;\n\tstruct palmas_reg_init *reg_init;\n\tstruct palmas_regs_info *rinfo;\n\tstruct regulator_desc *desc;\n\n\tfor (id = ddata->ldo_begin; id < ddata->max_reg; id++) {\n\t\tif (pdata && pdata->reg_init[id])\n\t\t\treg_init = pdata->reg_init[id];\n\t\telse\n\t\t\treg_init = NULL;\n\n\t\t \n\t\trinfo = &ddata->palmas_regs_info[id];\n\n\t\t \n\t\tdesc = &pmic->desc[id];\n\t\tdesc->name = rinfo->name;\n\t\tdesc->id = id;\n\t\tdesc->type = REGULATOR_VOLTAGE;\n\t\tdesc->owner = THIS_MODULE;\n\n\t\tif (id < TPS65917_REG_REGEN1) {\n\t\t\tdesc->n_voltages = PALMAS_LDO_NUM_VOLTAGES;\n\t\t\tif (reg_init && reg_init->roof_floor)\n\t\t\t\tdesc->ops = &palmas_ops_ext_control_ldo;\n\t\t\telse\n\t\t\t\tdesc->ops = &tps65917_ops_ldo;\n\t\t\tdesc->min_uV = 900000;\n\t\t\tdesc->uV_step = 50000;\n\t\t\tdesc->linear_min_sel = 1;\n\t\t\tdesc->enable_time = 500;\n\t\t\tdesc->vsel_reg = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE,\n\t\t\t\t\t\t\t    rinfo->vsel_addr);\n\t\t\tdesc->vsel_mask = PALMAS_LDO1_VOLTAGE_VSEL_MASK;\n\t\t\tdesc->enable_reg = PALMAS_BASE_TO_REG(PALMAS_LDO_BASE,\n\t\t\t\t\t\t\t      rinfo->ctrl_addr);\n\t\t\tdesc->enable_mask = PALMAS_LDO1_CTRL_MODE_ACTIVE;\n\t\t\t \n\t\t\tdesc->ramp_delay = 2500;\n\t\t\tif (id == TPS65917_REG_LDO1 ||\n\t\t\t    id == TPS65917_REG_LDO2) {\n\t\t\t\tdesc->ops = &tps65917_ops_ldo_1_2;\n\t\t\t\tdesc->bypass_reg = desc->enable_reg;\n\t\t\t\tdesc->bypass_val_on =\n\t\t\t\t\t\tTPS65917_LDO1_CTRL_BYPASS_EN;\n\t\t\t\tdesc->bypass_mask =\n\t\t\t\t\t\tTPS65917_LDO1_CTRL_BYPASS_EN;\n\t\t\t}\n\t\t} else {\n\t\t\tdesc->n_voltages = 1;\n\t\t\tif (reg_init && reg_init->roof_floor)\n\t\t\t\tdesc->ops = &palmas_ops_ext_control_extreg;\n\t\t\telse\n\t\t\t\tdesc->ops = &palmas_ops_extreg;\n\t\t\tdesc->enable_reg =\n\t\t\t\t\tPALMAS_BASE_TO_REG(PALMAS_RESOURCE_BASE,\n\t\t\t\t\t\t\t   rinfo->ctrl_addr);\n\t\t\tdesc->enable_mask = PALMAS_REGEN1_CTRL_MODE_ACTIVE;\n\t\t}\n\n\t\tif (pdata)\n\t\t\tconfig.init_data = pdata->reg_data[id];\n\t\telse\n\t\t\tconfig.init_data = NULL;\n\n\t\tdesc->supply_name = rinfo->sname;\n\t\tconfig.of_node = ddata->palmas_matches[id].of_node;\n\n\t\trdev = devm_regulator_register(pmic->dev, desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(pmic->dev,\n\t\t\t\t\"failed to register %s regulator\\n\",\n\t\t\t\tpdev_name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\n\t\t \n\t\tif (pdata) {\n\t\t\treg_init = pdata->reg_init[id];\n\t\t\tif (reg_init) {\n\t\t\t\tif (id < TPS65917_REG_REGEN1)\n\t\t\t\t\tret = palmas_ldo_init(pmic->palmas,\n\t\t\t\t\t\t\t      id, reg_init);\n\t\t\t\telse\n\t\t\t\t\tret = palmas_extreg_init(pmic->palmas,\n\t\t\t\t\t\t\t\t id, reg_init);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int palmas_smps_registration(struct palmas_pmic *pmic,\n\t\t\t\t    struct palmas_pmic_driver_data *ddata,\n\t\t\t\t    struct palmas_pmic_platform_data *pdata,\n\t\t\t\t    const char *pdev_name,\n\t\t\t\t    struct regulator_config config)\n{\n\tint id, ret;\n\tunsigned int addr, reg;\n\tstruct regulator_dev *rdev;\n\tstruct palmas_reg_init *reg_init;\n\tstruct palmas_regs_info *rinfo;\n\tstruct regulator_desc *desc;\n\n\tfor (id = ddata->smps_start; id <= ddata->smps_end; id++) {\n\t\tbool ramp_delay_support = false;\n\n\t\t \n\t\tswitch (id) {\n\t\tcase PALMAS_REG_SMPS12:\n\t\tcase PALMAS_REG_SMPS3:\n\t\t\tif (pmic->smps123)\n\t\t\t\tcontinue;\n\t\t\tif (id == PALMAS_REG_SMPS12)\n\t\t\t\tramp_delay_support = true;\n\t\t\tbreak;\n\t\tcase PALMAS_REG_SMPS123:\n\t\t\tif (!pmic->smps123)\n\t\t\t\tcontinue;\n\t\t\tramp_delay_support = true;\n\t\t\tbreak;\n\t\tcase PALMAS_REG_SMPS45:\n\t\tcase PALMAS_REG_SMPS7:\n\t\t\tif (pmic->smps457)\n\t\t\t\tcontinue;\n\t\t\tif (id == PALMAS_REG_SMPS45)\n\t\t\t\tramp_delay_support = true;\n\t\t\tbreak;\n\t\tcase PALMAS_REG_SMPS457:\n\t\t\tif (!pmic->smps457)\n\t\t\t\tcontinue;\n\t\t\tramp_delay_support = true;\n\t\t\tbreak;\n\t\tcase PALMAS_REG_SMPS10_OUT1:\n\t\tcase PALMAS_REG_SMPS10_OUT2:\n\t\t\tif (!PALMAS_PMIC_HAS(pmic->palmas, SMPS10_BOOST))\n\t\t\t\tcontinue;\n\t\t}\n\t\trinfo = &ddata->palmas_regs_info[id];\n\t\tdesc = &pmic->desc[id];\n\n\t\tif ((id == PALMAS_REG_SMPS6) || (id == PALMAS_REG_SMPS8))\n\t\t\tramp_delay_support = true;\n\n\t\tif (ramp_delay_support) {\n\t\t\taddr = rinfo->tstep_addr;\n\t\t\tret = palmas_smps_read(pmic->palmas, addr, &reg);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(pmic->dev,\n\t\t\t\t\t\"reading TSTEP reg failed: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdesc->ramp_delay = palmas_smps_ramp_delay[reg & 0x3];\n\t\t\tpmic->ramp_delay[id] = desc->ramp_delay;\n\t\t}\n\n\t\t \n\t\tif (pdata && pdata->reg_init[id]) {\n\t\t\treg_init = pdata->reg_init[id];\n\t\t\tret = palmas_smps_init(pmic->palmas, id, reg_init);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\treg_init = NULL;\n\t\t}\n\n\t\t \n\t\tdesc->name = rinfo->name;\n\t\tdesc->id = id;\n\n\t\tswitch (id) {\n\t\tcase PALMAS_REG_SMPS10_OUT1:\n\t\tcase PALMAS_REG_SMPS10_OUT2:\n\t\t\tdesc->n_voltages = PALMAS_SMPS10_NUM_VOLTAGES;\n\t\t\tdesc->ops = &palmas_ops_smps10;\n\t\t\tdesc->vsel_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\n\t\t\t\t\t\t\t    PALMAS_SMPS10_CTRL);\n\t\t\tdesc->vsel_mask = SMPS10_VSEL;\n\t\t\tdesc->enable_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\n\t\t\t\t\t\t\t    PALMAS_SMPS10_CTRL);\n\t\t\tif (id == PALMAS_REG_SMPS10_OUT1)\n\t\t\t\tdesc->enable_mask = SMPS10_SWITCH_EN;\n\t\t\telse\n\t\t\t\tdesc->enable_mask = SMPS10_BOOST_EN;\n\t\t\tdesc->bypass_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\n\t\t\t\t\t\t\t    PALMAS_SMPS10_CTRL);\n\t\t\tdesc->bypass_val_on = SMPS10_BYPASS_EN;\n\t\t\tdesc->bypass_mask = SMPS10_BYPASS_EN;\n\t\t\tdesc->min_uV = 3750000;\n\t\t\tdesc->uV_step = 1250000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\taddr = rinfo->vsel_addr;\n\t\t\tdesc->n_linear_ranges = 3;\n\n\t\t\tret = palmas_smps_read(pmic->palmas, addr, &reg);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (reg & PALMAS_SMPS12_VOLTAGE_RANGE)\n\t\t\t\tpmic->range[id] = 1;\n\t\t\tif (pmic->range[id])\n\t\t\t\tdesc->linear_ranges = smps_high_ranges;\n\t\t\telse\n\t\t\t\tdesc->linear_ranges = smps_low_ranges;\n\n\t\t\tif (reg_init && reg_init->roof_floor)\n\t\t\t\tdesc->ops = &palmas_ops_ext_control_smps;\n\t\t\telse\n\t\t\t\tdesc->ops = &palmas_ops_smps;\n\t\t\tdesc->n_voltages = PALMAS_SMPS_NUM_VOLTAGES;\n\t\t\tdesc->vsel_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\n\t\t\t\t\t\t\t    rinfo->vsel_addr);\n\t\t\tdesc->vsel_mask = PALMAS_SMPS12_VOLTAGE_VSEL_MASK;\n\n\t\t\t \n\t\t\taddr = rinfo->ctrl_addr;\n\t\t\tret = palmas_smps_read(pmic->palmas, addr, &reg);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tpmic->current_reg_mode[id] = reg &\n\t\t\t\t\tPALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\n\n\t\t\tdesc->enable_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\n\t\t\t\t\t\t\t      rinfo->ctrl_addr);\n\t\t\tdesc->enable_mask = PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\n\t\t\t \n\t\t\tdesc->enable_val = SMPS_CTRL_MODE_ON;\n\t\t}\n\n\t\tdesc->type = REGULATOR_VOLTAGE;\n\t\tdesc->owner = THIS_MODULE;\n\n\t\tif (pdata)\n\t\t\tconfig.init_data = pdata->reg_data[id];\n\t\telse\n\t\t\tconfig.init_data = NULL;\n\n\t\tdesc->supply_name = rinfo->sname;\n\t\tconfig.of_node = ddata->palmas_matches[id].of_node;\n\n\t\trdev = devm_regulator_register(pmic->dev, desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(pmic->dev,\n\t\t\t\t\"failed to register %s regulator\\n\",\n\t\t\t\tpdev_name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tps65917_smps_registration(struct palmas_pmic *pmic,\n\t\t\t\t      struct palmas_pmic_driver_data *ddata,\n\t\t\t\t      struct palmas_pmic_platform_data *pdata,\n\t\t\t\t      const char *pdev_name,\n\t\t\t\t      struct regulator_config config)\n{\n\tint id, ret;\n\tunsigned int addr, reg;\n\tstruct regulator_dev *rdev;\n\tstruct palmas_reg_init *reg_init;\n\tstruct palmas_regs_info *rinfo;\n\tstruct regulator_desc *desc;\n\n\tfor (id = ddata->smps_start; id <= ddata->smps_end; id++) {\n\t\t \n\t\tdesc = &pmic->desc[id];\n\t\tdesc->n_linear_ranges = 3;\n\t\tif ((id == TPS65917_REG_SMPS2 || id == TPS65917_REG_SMPS1) &&\n\t\t    pmic->smps12)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (pdata && pdata->reg_init[id]) {\n\t\t\treg_init = pdata->reg_init[id];\n\t\t\tret = palmas_smps_init(pmic->palmas, id, reg_init);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\treg_init = NULL;\n\t\t}\n\t\trinfo = &ddata->palmas_regs_info[id];\n\n\t\t \n\t\tdesc->name = rinfo->name;\n\t\tdesc->id = id;\n\n\t\t \n\t\taddr = rinfo->vsel_addr;\n\n\t\tret = palmas_smps_read(pmic->palmas, addr, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (reg & TPS65917_SMPS1_VOLTAGE_RANGE)\n\t\t\tpmic->range[id] = 1;\n\n\t\tif (pmic->range[id])\n\t\t\tdesc->linear_ranges = smps_high_ranges;\n\t\telse\n\t\t\tdesc->linear_ranges = smps_low_ranges;\n\n\t\tif (reg_init && reg_init->roof_floor)\n\t\t\tdesc->ops = &tps65917_ops_ext_control_smps;\n\t\telse\n\t\t\tdesc->ops = &tps65917_ops_smps;\n\t\tdesc->n_voltages = PALMAS_SMPS_NUM_VOLTAGES;\n\t\tdesc->vsel_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\n\t\t\t\t\t\t    rinfo->vsel_addr);\n\t\tdesc->vsel_mask = PALMAS_SMPS12_VOLTAGE_VSEL_MASK;\n\t\tdesc->ramp_delay = 2500;\n\n\t\t \n\t\taddr = rinfo->ctrl_addr;\n\t\tret = palmas_smps_read(pmic->palmas, addr, &reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpmic->current_reg_mode[id] = reg &\n\t\t\t\tPALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\n\t\tdesc->enable_reg = PALMAS_BASE_TO_REG(PALMAS_SMPS_BASE,\n\t\t\t\t\t\t      rinfo->ctrl_addr);\n\t\tdesc->enable_mask = PALMAS_SMPS12_CTRL_MODE_ACTIVE_MASK;\n\t\t \n\t\tdesc->enable_val = SMPS_CTRL_MODE_ON;\n\n\t\tdesc->type = REGULATOR_VOLTAGE;\n\t\tdesc->owner = THIS_MODULE;\n\n\t\tif (pdata)\n\t\t\tconfig.init_data = pdata->reg_data[id];\n\t\telse\n\t\t\tconfig.init_data = NULL;\n\n\t\tdesc->supply_name = rinfo->sname;\n\t\tconfig.of_node = ddata->palmas_matches[id].of_node;\n\n\t\trdev = devm_regulator_register(pmic->dev, desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(pmic->dev,\n\t\t\t\t\"failed to register %s regulator\\n\",\n\t\t\t\tpdev_name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct of_regulator_match palmas_matches[] = {\n\t{ .name = \"smps12\", },\n\t{ .name = \"smps123\", },\n\t{ .name = \"smps3\", },\n\t{ .name = \"smps45\", },\n\t{ .name = \"smps457\", },\n\t{ .name = \"smps6\", },\n\t{ .name = \"smps7\", },\n\t{ .name = \"smps8\", },\n\t{ .name = \"smps9\", },\n\t{ .name = \"smps10_out2\", },\n\t{ .name = \"smps10_out1\", },\n\t{ .name = \"ldo1\", },\n\t{ .name = \"ldo2\", },\n\t{ .name = \"ldo3\", },\n\t{ .name = \"ldo4\", },\n\t{ .name = \"ldo5\", },\n\t{ .name = \"ldo6\", },\n\t{ .name = \"ldo7\", },\n\t{ .name = \"ldo8\", },\n\t{ .name = \"ldo9\", },\n\t{ .name = \"ldoln\", },\n\t{ .name = \"ldousb\", },\n\t{ .name = \"regen1\", },\n\t{ .name = \"regen2\", },\n\t{ .name = \"regen3\", },\n\t{ .name = \"sysen1\", },\n\t{ .name = \"sysen2\", },\n};\n\nstatic struct of_regulator_match tps65917_matches[] = {\n\t{ .name = \"smps1\", },\n\t{ .name = \"smps2\", },\n\t{ .name = \"smps3\", },\n\t{ .name = \"smps4\", },\n\t{ .name = \"smps5\", },\n\t{ .name = \"smps12\",},\n\t{ .name = \"ldo1\", },\n\t{ .name = \"ldo2\", },\n\t{ .name = \"ldo3\", },\n\t{ .name = \"ldo4\", },\n\t{ .name = \"ldo5\", },\n\t{ .name = \"regen1\", },\n\t{ .name = \"regen2\", },\n\t{ .name = \"regen3\", },\n\t{ .name = \"sysen1\", },\n\t{ .name = \"sysen2\", },\n};\n\nstatic struct palmas_pmic_driver_data palmas_ddata = {\n\t.smps_start = PALMAS_REG_SMPS12,\n\t.smps_end = PALMAS_REG_SMPS10_OUT1,\n\t.ldo_begin = PALMAS_REG_LDO1,\n\t.ldo_end = PALMAS_REG_LDOUSB,\n\t.max_reg = PALMAS_NUM_REGS,\n\t.has_regen3 = true,\n\t.palmas_regs_info = palmas_generic_regs_info,\n\t.palmas_matches = palmas_matches,\n\t.sleep_req_info = palma_sleep_req_info,\n\t.smps_register = palmas_smps_registration,\n\t.ldo_register = palmas_ldo_registration,\n};\n\nstatic struct palmas_pmic_driver_data tps65917_ddata = {\n\t.smps_start = TPS65917_REG_SMPS1,\n\t.smps_end = TPS65917_REG_SMPS12,\n\t.ldo_begin = TPS65917_REG_LDO1,\n\t.ldo_end = TPS65917_REG_LDO5,\n\t.max_reg = TPS65917_NUM_REGS,\n\t.has_regen3 = true,\n\t.palmas_regs_info = tps65917_regs_info,\n\t.palmas_matches = tps65917_matches,\n\t.sleep_req_info = tps65917_sleep_req_info,\n\t.smps_register = tps65917_smps_registration,\n\t.ldo_register = tps65917_ldo_registration,\n};\n\nstatic int palmas_dt_to_pdata(struct device *dev,\n\t\t\t      struct device_node *node,\n\t\t\t      struct palmas_pmic_platform_data *pdata,\n\t\t\t      struct palmas_pmic_driver_data *ddata)\n{\n\tstruct device_node *regulators;\n\tu32 prop;\n\tint idx, ret;\n\n\tregulators = of_get_child_by_name(node, \"regulators\");\n\tif (!regulators) {\n\t\tdev_info(dev, \"regulator node not found\\n\");\n\t\treturn 0;\n\t}\n\n\tret = of_regulator_match(dev, regulators, ddata->palmas_matches,\n\t\t\t\t ddata->max_reg);\n\tof_node_put(regulators);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error parsing regulator init data: %d\\n\", ret);\n\t\treturn 0;\n\t}\n\n\tfor (idx = 0; idx < ddata->max_reg; idx++) {\n\t\tstruct of_regulator_match *match;\n\t\tstruct palmas_reg_init *rinit;\n\t\tstruct device_node *np;\n\n\t\tmatch = &ddata->palmas_matches[idx];\n\t\tnp = match->of_node;\n\n\t\tif (!match->init_data || !np)\n\t\t\tcontinue;\n\n\t\trinit = devm_kzalloc(dev, sizeof(*rinit), GFP_KERNEL);\n\t\tif (!rinit)\n\t\t\treturn -ENOMEM;\n\n\t\tpdata->reg_data[idx] = match->init_data;\n\t\tpdata->reg_init[idx] = rinit;\n\n\t\trinit->warm_reset = of_property_read_bool(np, \"ti,warm-reset\");\n\t\tret = of_property_read_u32(np, \"ti,roof-floor\", &prop);\n\t\t \n\t\tif (ret != -EINVAL) {\n\t\t\tint econtrol;\n\n\t\t\t \n\t\t\tecontrol = PALMAS_EXT_CONTROL_NSLEEP;\n\t\t\tif (!ret) {\n\t\t\t\tswitch (prop) {\n\t\t\t\tcase 1:\n\t\t\t\t\tecontrol = PALMAS_EXT_CONTROL_ENABLE1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tecontrol = PALMAS_EXT_CONTROL_ENABLE2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tecontrol = PALMAS_EXT_CONTROL_NSLEEP;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\tdev_warn(dev,\n\t\t\t\t\t\t \"%s: Invalid roof-floor option: %u\\n\",\n\t\t\t\t\t\t match->name, prop);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trinit->roof_floor = econtrol;\n\t\t}\n\n\t\tret = of_property_read_u32(np, \"ti,mode-sleep\", &prop);\n\t\tif (!ret)\n\t\t\trinit->mode_sleep = prop;\n\n\t\tret = of_property_read_bool(np, \"ti,smps-range\");\n\t\tif (ret)\n\t\t\trinit->vsel = PALMAS_SMPS12_VOLTAGE_RANGE;\n\n\t\tif (idx == PALMAS_REG_LDO8)\n\t\t\tpdata->enable_ldo8_tracking = of_property_read_bool(\n\t\t\t\t\t\tnp, \"ti,enable-ldo8-tracking\");\n\t}\n\n\tpdata->ldo6_vibrator = of_property_read_bool(node, \"ti,ldo6-vibrator\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_palmas_match_tbl[] = {\n\t{\n\t\t.compatible = \"ti,palmas-pmic\",\n\t\t.data = &palmas_ddata,\n\t},\n\t{\n\t\t.compatible = \"ti,twl6035-pmic\",\n\t\t.data = &palmas_ddata,\n\t},\n\t{\n\t\t.compatible = \"ti,twl6036-pmic\",\n\t\t.data = &palmas_ddata,\n\t},\n\t{\n\t\t.compatible = \"ti,twl6037-pmic\",\n\t\t.data = &palmas_ddata,\n\t},\n\t{\n\t\t.compatible = \"ti,tps65913-pmic\",\n\t\t.data = &palmas_ddata,\n\t},\n\t{\n\t\t.compatible = \"ti,tps65914-pmic\",\n\t\t.data = &palmas_ddata,\n\t},\n\t{\n\t\t.compatible = \"ti,tps80036-pmic\",\n\t\t.data = &palmas_ddata,\n\t},\n\t{\n\t\t.compatible = \"ti,tps659038-pmic\",\n\t\t.data = &palmas_ddata,\n\t},\n\t {\n\t\t.compatible = \"ti,tps65917-pmic\",\n\t\t.data = &tps65917_ddata,\n\t},\n\t{   }\n};\n\nstatic int palmas_regulators_probe(struct platform_device *pdev)\n{\n\tstruct palmas *palmas = dev_get_drvdata(pdev->dev.parent);\n\tstruct palmas_pmic_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct palmas_pmic_driver_data *driver_data;\n\tstruct regulator_config config = { };\n\tstruct palmas_pmic *pmic;\n\tconst char *pdev_name;\n\tconst struct of_device_id *match;\n\tint ret = 0;\n\tunsigned int reg;\n\n\tmatch = of_match_device(of_match_ptr(of_palmas_match_tbl), &pdev->dev);\n\n\tif (!match)\n\t\treturn -ENODATA;\n\n\tdriver_data = (struct palmas_pmic_driver_data *)match->data;\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpmic = devm_kzalloc(&pdev->dev, sizeof(*pmic), GFP_KERNEL);\n\tif (!pmic)\n\t\treturn -ENOMEM;\n\n\tif (of_device_is_compatible(node, \"ti,tps659038-pmic\")) {\n\t\tpalmas_generic_regs_info[PALMAS_REG_REGEN2].ctrl_addr =\n\t\t\t\t\t\t\tTPS659038_REGEN2_CTRL;\n\t\tpalmas_ddata.has_regen3 = false;\n\t}\n\n\tpmic->dev = &pdev->dev;\n\tpmic->palmas = palmas;\n\tpalmas->pmic = pmic;\n\tplatform_set_drvdata(pdev, pmic);\n\tpmic->palmas->pmic_ddata = driver_data;\n\n\tret = palmas_dt_to_pdata(&pdev->dev, node, pdata, driver_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = palmas_smps_read(palmas, PALMAS_SMPS_CTRL, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reg & PALMAS_SMPS_CTRL_SMPS12_SMPS123_EN) {\n\t\tpmic->smps123 = 1;\n\t\tpmic->smps12 = 1;\n\t}\n\n\tif (reg & PALMAS_SMPS_CTRL_SMPS45_SMPS457_EN)\n\t\tpmic->smps457 = 1;\n\n\tconfig.regmap = palmas->regmap[REGULATOR_SLAVE];\n\tconfig.dev = &pdev->dev;\n\tconfig.driver_data = pmic;\n\tpdev_name = pdev->name;\n\n\tret = driver_data->smps_register(pmic, driver_data, pdata, pdev_name,\n\t\t\t\t\t config);\n\tif (ret)\n\t\treturn ret;\n\n\tret = driver_data->ldo_register(pmic, driver_data, pdata, pdev_name,\n\t\t\t\t\tconfig);\n\n\treturn ret;\n}\n\nstatic struct platform_driver palmas_driver = {\n\t.driver = {\n\t\t.name = \"palmas-pmic\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_palmas_match_tbl,\n\t},\n\t.probe = palmas_regulators_probe,\n};\n\nstatic int __init palmas_init(void)\n{\n\treturn platform_driver_register(&palmas_driver);\n}\nsubsys_initcall(palmas_init);\n\nstatic void __exit palmas_exit(void)\n{\n\tplatform_driver_unregister(&palmas_driver);\n}\nmodule_exit(palmas_exit);\n\nMODULE_AUTHOR(\"Graeme Gregory <gg@slimlogic.co.uk>\");\nMODULE_DESCRIPTION(\"Palmas voltage regulator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:palmas-pmic\");\nMODULE_DEVICE_TABLE(of, of_palmas_match_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}