{
  "module_name": "rt4801-regulator.c",
  "hash_id": "7b4530c61c98944010762bcfdcc0aeeea567b2822c76b1a2f5447c56f0d7cae5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rt4801-regulator.c",
  "human_readable_source": "\n\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n\n#define RT4801_REG_VOP\t0x00\n#define RT4801_REG_VON\t0x01\n#define RT4801_REG_APPS\t0x03\n\n#define VOUT_MASK\t0x1F\n\n#define MIN_UV\t\t4000000\n#define STEP_UV\t\t100000\n#define MAX_UV\t\t6000000\n#define N_VOLTAGES\t((MAX_UV - MIN_UV) / STEP_UV + 1)\n\n#define DSV_OUT_POS\t0\n#define DSV_OUT_NEG\t1\n#define DSV_OUT_MAX\t2\n\n#define DSVP_ENABLE\tBIT(0)\n#define DSVN_ENABLE\tBIT(1)\n#define DSVALL_ENABLE\t(DSVP_ENABLE | DSVN_ENABLE)\n\nstruct rt4801_priv {\n\tstruct device *dev;\n\tstruct gpio_desc *enable_gpios[DSV_OUT_MAX];\n\tunsigned int enable_flag;\n\tunsigned int volt_sel[DSV_OUT_MAX];\n};\n\nstatic int rt4801_of_parse_cb(struct device_node *np,\n\t\t\t      const struct regulator_desc *desc,\n\t\t\t      struct regulator_config *config)\n{\n\tstruct rt4801_priv *priv = config->driver_data;\n\tint id = desc->id;\n\n\tif (priv->enable_gpios[id]) {\n\t\tdev_warn(priv->dev, \"duplicated enable-gpios property\\n\");\n\t\treturn 0;\n\t}\n\tpriv->enable_gpios[id] = devm_fwnode_gpiod_get_index(priv->dev,\n\t\t\t\t\t\t\t     of_fwnode_handle(np),\n\t\t\t\t\t\t\t     \"enable\", 0,\n\t\t\t\t\t\t\t     GPIOD_OUT_HIGH,\n\t\t\t\t\t\t\t     \"rt4801\");\n\tif (IS_ERR(priv->enable_gpios[id]))\n\t\tpriv->enable_gpios[id] = NULL;\n\n\treturn 0;\n}\n\nstatic int rt4801_set_voltage_sel(struct regulator_dev *rdev, unsigned int selector)\n{\n\tstruct rt4801_priv *priv = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev), ret;\n\n\tif (priv->enable_flag & BIT(id)) {\n\t\tret = regulator_set_voltage_sel_regmap(rdev, selector);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpriv->volt_sel[id] = selector;\n\treturn 0;\n}\n\nstatic int rt4801_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct rt4801_priv *priv = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\n\tif (priv->enable_flag & BIT(id))\n\t\treturn regulator_get_voltage_sel_regmap(rdev);\n\n\treturn priv->volt_sel[id];\n}\n\nstatic int rt4801_enable(struct regulator_dev *rdev)\n{\n\tstruct rt4801_priv *priv = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev), ret;\n\n\tif (!priv->enable_gpios[id]) {\n\t\tdev_warn(&rdev->dev, \"no dedicated gpio can control\\n\");\n\t\tgoto bypass_gpio;\n\t}\n\n\tgpiod_set_value(priv->enable_gpios[id], 1);\n\nbypass_gpio:\n\tret = regmap_write(rdev->regmap, rdev->desc->vsel_reg, priv->volt_sel[id]);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->enable_flag |= BIT(id);\n\treturn 0;\n}\n\nstatic int rt4801_disable(struct regulator_dev *rdev)\n{\n\tstruct rt4801_priv *priv = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\n\tif (!priv->enable_gpios[id]) {\n\t\tdev_warn(&rdev->dev, \"no dedicated gpio can control\\n\");\n\t\tgoto bypass_gpio;\n\t}\n\n\tgpiod_set_value(priv->enable_gpios[id], 0);\n\nbypass_gpio:\n\tpriv->enable_flag &= ~BIT(id);\n\treturn 0;\n}\n\nstatic int rt4801_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct rt4801_priv *priv = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\n\treturn !!(priv->enable_flag & BIT(id));\n}\n\nstatic const struct regulator_ops rt4801_regulator_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = rt4801_set_voltage_sel,\n\t.get_voltage_sel = rt4801_get_voltage_sel,\n\t.enable = rt4801_enable,\n\t.disable = rt4801_disable,\n\t.is_enabled = rt4801_is_enabled,\n};\n\nstatic const struct regulator_desc rt4801_regulator_descs[] = {\n\t{\n\t\t.name = \"DSVP\",\n\t\t.ops = &rt4801_regulator_ops,\n\t\t.of_match = of_match_ptr(\"DSVP\"),\n\t\t.of_parse_cb = rt4801_of_parse_cb,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.id = DSV_OUT_POS,\n\t\t.min_uV = MIN_UV,\n\t\t.uV_step = STEP_UV,\n\t\t.n_voltages = N_VOLTAGES,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = RT4801_REG_VOP,\n\t\t.vsel_mask = VOUT_MASK,\n\t},\n\t{\n\t\t.name = \"DSVN\",\n\t\t.ops = &rt4801_regulator_ops,\n\t\t.of_match = of_match_ptr(\"DSVN\"),\n\t\t.of_parse_cb = rt4801_of_parse_cb,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.id = DSV_OUT_NEG,\n\t\t.min_uV = MIN_UV,\n\t\t.uV_step = STEP_UV,\n\t\t.n_voltages = N_VOLTAGES,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = RT4801_REG_VON,\n\t\t.vsel_mask = VOUT_MASK,\n\t},\n};\n\nstatic const struct regmap_config rt4801_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RT4801_REG_APPS,\n};\n\nstatic int rt4801_probe(struct i2c_client *i2c)\n{\n\tstruct rt4801_priv *priv;\n\tstruct regmap *regmap;\n\tint i;\n\n\tpriv = devm_kzalloc(&i2c->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &i2c->dev;\n\t \n\tpriv->enable_flag = DSVALL_ENABLE;\n\n\tregmap = devm_regmap_init_i2c(i2c, &rt4801_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&i2c->dev, \"Failed to init regmap\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tfor (i = 0; i < DSV_OUT_MAX; i++) {\n\t\tpriv->enable_gpios[i] = devm_gpiod_get_index_optional(&i2c->dev,\n\t\t\t\t\t\t\t\t      \"enable\",\n\t\t\t\t\t\t\t\t      i,\n\t\t\t\t\t\t\t\t      GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(priv->enable_gpios[i])) {\n\t\t\tdev_err(&i2c->dev, \"Failed to get gpios\\n\");\n\t\t\treturn PTR_ERR(priv->enable_gpios[i]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < DSV_OUT_MAX; i++) {\n\t\tconst struct regulator_desc *desc = rt4801_regulator_descs + i;\n\t\tstruct regulator_config config = { .dev = &i2c->dev, .driver_data = priv,\n\t\t\t\t\t\t   .regmap = regmap, };\n\t\tstruct regulator_dev *rdev;\n\t\tunsigned int val;\n\t\tint ret;\n\n\t\t \n\t\tret = regmap_read(regmap, desc->vsel_reg, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpriv->volt_sel[i] = val & desc->vsel_mask;\n\n\t\trdev = devm_regulator_register(&i2c->dev, desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&i2c->dev, \"Failed to register [%d] regulator\\n\", i);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused rt4801_of_id[] = {\n\t{ .compatible = \"richtek,rt4801\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rt4801_of_id);\n\nstatic struct i2c_driver rt4801_driver = {\n\t.driver = {\n\t\t.name = \"rt4801\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(rt4801_of_id),\n\t},\n\t.probe = rt4801_probe,\n};\nmodule_i2c_driver(rt4801_driver);\n\nMODULE_AUTHOR(\"ChiYuan Hwang <cy_huang@richtek.com>\");\nMODULE_DESCRIPTION(\"Richtek RT4801 Display Bias Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}