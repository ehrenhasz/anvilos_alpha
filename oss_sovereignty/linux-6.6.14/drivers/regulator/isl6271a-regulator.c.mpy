{
  "module_name": "isl6271a-regulator.c",
  "hash_id": "b9816cf9b00e2e9364e3b744accfae08de75d211d4e88c8b63a479ecc783a051",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/isl6271a-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n\n#define\tISL6271A_VOLTAGE_MIN\t850000\n#define\tISL6271A_VOLTAGE_MAX\t1600000\n#define\tISL6271A_VOLTAGE_STEP\t50000\n\n \nstruct isl_pmic {\n\tstruct i2c_client\t*client;\n\tstruct mutex\t\tmtx;\n};\n\nstatic int isl6271a_get_voltage_sel(struct regulator_dev *dev)\n{\n\tstruct isl_pmic *pmic = rdev_get_drvdata(dev);\n\tint idx;\n\n\tmutex_lock(&pmic->mtx);\n\n\tidx = i2c_smbus_read_byte(pmic->client);\n\tif (idx < 0)\n\t\tdev_err(&pmic->client->dev, \"Error getting voltage\\n\");\n\n\tmutex_unlock(&pmic->mtx);\n\treturn idx;\n}\n\nstatic int isl6271a_set_voltage_sel(struct regulator_dev *dev,\n\t\t\t\t    unsigned selector)\n{\n\tstruct isl_pmic *pmic = rdev_get_drvdata(dev);\n\tint err;\n\n\tmutex_lock(&pmic->mtx);\n\n\terr = i2c_smbus_write_byte(pmic->client, selector);\n\tif (err < 0)\n\t\tdev_err(&pmic->client->dev, \"Error setting voltage\\n\");\n\n\tmutex_unlock(&pmic->mtx);\n\treturn err;\n}\n\nstatic const struct regulator_ops isl_core_ops = {\n\t.get_voltage_sel = isl6271a_get_voltage_sel,\n\t.set_voltage_sel = isl6271a_set_voltage_sel,\n\t.list_voltage\t= regulator_list_voltage_linear,\n\t.map_voltage\t= regulator_map_voltage_linear,\n};\n\nstatic const struct regulator_ops isl_fixed_ops = {\n\t.list_voltage\t= regulator_list_voltage_linear,\n};\n\nstatic const struct regulator_desc isl_rd[] = {\n\t{\n\t\t.name\t\t= \"Core Buck\",\n\t\t.id\t\t= 0,\n\t\t.n_voltages\t= 16,\n\t\t.ops\t\t= &isl_core_ops,\n\t\t.type\t\t= REGULATOR_VOLTAGE,\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.min_uV\t\t= ISL6271A_VOLTAGE_MIN,\n\t\t.uV_step\t= ISL6271A_VOLTAGE_STEP,\n\t}, {\n\t\t.name\t\t= \"LDO1\",\n\t\t.id\t\t= 1,\n\t\t.n_voltages\t= 1,\n\t\t.ops\t\t= &isl_fixed_ops,\n\t\t.type\t\t= REGULATOR_VOLTAGE,\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.min_uV\t\t= 1100000,\n\t}, {\n\t\t.name\t\t= \"LDO2\",\n\t\t.id\t\t= 2,\n\t\t.n_voltages\t= 1,\n\t\t.ops\t\t= &isl_fixed_ops,\n\t\t.type\t\t= REGULATOR_VOLTAGE,\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.min_uV\t\t= 1300000,\n\t},\n};\n\nstatic int isl6271a_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tstruct regulator_dev *rdev;\n\tstruct regulator_config config = { };\n\tstruct regulator_init_data *init_data\t= dev_get_platdata(&i2c->dev);\n\tstruct isl_pmic *pmic;\n\tint i;\n\n\tif (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EIO;\n\n\tpmic = devm_kzalloc(&i2c->dev, sizeof(struct isl_pmic), GFP_KERNEL);\n\tif (!pmic)\n\t\treturn -ENOMEM;\n\n\tpmic->client = i2c;\n\n\tmutex_init(&pmic->mtx);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tconfig.dev = &i2c->dev;\n\t\tif (i == 0)\n\t\t\tconfig.init_data = init_data;\n\t\telse\n\t\t\tconfig.init_data = NULL;\n\t\tconfig.driver_data = pmic;\n\n\t\trdev = devm_regulator_register(&i2c->dev, &isl_rd[i], &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&i2c->dev, \"failed to register %s\\n\", id->name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\ti2c_set_clientdata(i2c, pmic);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id isl6271a_id[] = {\n\t{.name = \"isl6271a\", 0 },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(i2c, isl6271a_id);\n\nstatic struct i2c_driver isl6271a_i2c_driver = {\n\t.driver = {\n\t\t.name = \"isl6271a\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = isl6271a_probe,\n\t.id_table = isl6271a_id,\n};\n\nstatic int __init isl6271a_init(void)\n{\n\treturn i2c_add_driver(&isl6271a_i2c_driver);\n}\n\nstatic void __exit isl6271a_cleanup(void)\n{\n\ti2c_del_driver(&isl6271a_i2c_driver);\n}\n\nsubsys_initcall(isl6271a_init);\nmodule_exit(isl6271a_cleanup);\n\nMODULE_AUTHOR(\"Marek Vasut <marek.vasut@gmail.com>\");\nMODULE_DESCRIPTION(\"Intersil ISL6271A voltage regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}