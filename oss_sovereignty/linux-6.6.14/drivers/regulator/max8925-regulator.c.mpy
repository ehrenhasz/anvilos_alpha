{
  "module_name": "max8925-regulator.c",
  "hash_id": "11d87639b577cb31dc8b717ccda27f2bdb87e19d18cc4f423684856812ef0588",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/max8925-regulator.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/mfd/max8925.h>\n#include <linux/of.h>\n#include <linux/regulator/of_regulator.h>\n\n#define SD1_DVM_VMIN\t\t850000\n#define SD1_DVM_VMAX\t\t1000000\n#define SD1_DVM_STEP\t\t50000\n#define SD1_DVM_SHIFT\t\t5\t\t \n#define SD1_DVM_EN\t\t6\t\t \n\n \n#define LDO_SEQ_I2C\t\t0x7\t\t \n#define LDO_SEQ_MASK\t\t0x7\t\t \n#define LDO_SEQ_SHIFT\t\t2\t\t \n#define LDO_I2C_EN\t\t0x1\t\t \n#define LDO_I2C_EN_MASK\t\t0x1\t\t \n#define LDO_I2C_EN_SHIFT\t0\t\t \n\nstruct max8925_regulator_info {\n\tstruct regulator_desc\tdesc;\n\tstruct i2c_client\t*i2c;\n\n\tint\tvol_reg;\n\tint\tenable_reg;\n};\n\nstatic int max8925_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t   unsigned int selector)\n{\n\tstruct max8925_regulator_info *info = rdev_get_drvdata(rdev);\n\tunsigned char mask = rdev->desc->n_voltages - 1;\n\n\treturn max8925_set_bits(info->i2c, info->vol_reg, mask, selector);\n}\n\nstatic int max8925_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct max8925_regulator_info *info = rdev_get_drvdata(rdev);\n\tunsigned char data, mask;\n\tint ret;\n\n\tret = max8925_reg_read(info->i2c, info->vol_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\tmask = rdev->desc->n_voltages - 1;\n\tdata = ret & mask;\n\n\treturn data;\n}\n\nstatic int max8925_enable(struct regulator_dev *rdev)\n{\n\tstruct max8925_regulator_info *info = rdev_get_drvdata(rdev);\n\n\treturn max8925_set_bits(info->i2c, info->enable_reg,\n\t\t\t\tLDO_SEQ_MASK << LDO_SEQ_SHIFT |\n\t\t\t\tLDO_I2C_EN_MASK << LDO_I2C_EN_SHIFT,\n\t\t\t\tLDO_SEQ_I2C << LDO_SEQ_SHIFT |\n\t\t\t\tLDO_I2C_EN << LDO_I2C_EN_SHIFT);\n}\n\nstatic int max8925_disable(struct regulator_dev *rdev)\n{\n\tstruct max8925_regulator_info *info = rdev_get_drvdata(rdev);\n\n\treturn max8925_set_bits(info->i2c, info->enable_reg,\n\t\t\t\tLDO_SEQ_MASK << LDO_SEQ_SHIFT |\n\t\t\t\tLDO_I2C_EN_MASK << LDO_I2C_EN_SHIFT,\n\t\t\t\tLDO_SEQ_I2C << LDO_SEQ_SHIFT);\n}\n\nstatic int max8925_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct max8925_regulator_info *info = rdev_get_drvdata(rdev);\n\tint ldo_seq, ret;\n\n\tret = max8925_reg_read(info->i2c, info->enable_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\tldo_seq = (ret >> LDO_SEQ_SHIFT) & LDO_SEQ_MASK;\n\tif (ldo_seq != LDO_SEQ_I2C)\n\t\treturn 1;\n\telse\n\t\treturn ret & (LDO_I2C_EN_MASK << LDO_I2C_EN_SHIFT);\n}\n\nstatic int max8925_set_dvm_voltage(struct regulator_dev *rdev, int uV)\n{\n\tstruct max8925_regulator_info *info = rdev_get_drvdata(rdev);\n\tunsigned char data, mask;\n\n\tif (uV < SD1_DVM_VMIN || uV > SD1_DVM_VMAX)\n\t\treturn -EINVAL;\n\n\tdata = DIV_ROUND_UP(uV - SD1_DVM_VMIN, SD1_DVM_STEP);\n\tdata <<= SD1_DVM_SHIFT;\n\tmask = 3 << SD1_DVM_SHIFT;\n\n\treturn max8925_set_bits(info->i2c, info->enable_reg, mask, data);\n}\n\nstatic int max8925_set_dvm_enable(struct regulator_dev *rdev)\n{\n\tstruct max8925_regulator_info *info = rdev_get_drvdata(rdev);\n\n\treturn max8925_set_bits(info->i2c, info->vol_reg, 1 << SD1_DVM_EN,\n\t\t\t\t1 << SD1_DVM_EN);\n}\n\nstatic int max8925_set_dvm_disable(struct regulator_dev *rdev)\n{\n\tstruct max8925_regulator_info *info = rdev_get_drvdata(rdev);\n\n\treturn max8925_set_bits(info->i2c, info->vol_reg, 1 << SD1_DVM_EN, 0);\n}\n\nstatic const struct regulator_ops max8925_regulator_sdv_ops = {\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.set_voltage_sel\t= max8925_set_voltage_sel,\n\t.get_voltage_sel\t= max8925_get_voltage_sel,\n\t.enable\t\t\t= max8925_enable,\n\t.disable\t\t= max8925_disable,\n\t.is_enabled\t\t= max8925_is_enabled,\n\t.set_suspend_voltage\t= max8925_set_dvm_voltage,\n\t.set_suspend_enable\t= max8925_set_dvm_enable,\n\t.set_suspend_disable\t= max8925_set_dvm_disable,\n};\n\nstatic const struct regulator_ops max8925_regulator_ldo_ops = {\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.set_voltage_sel\t= max8925_set_voltage_sel,\n\t.get_voltage_sel\t= max8925_get_voltage_sel,\n\t.enable\t\t\t= max8925_enable,\n\t.disable\t\t= max8925_disable,\n\t.is_enabled\t\t= max8925_is_enabled,\n};\n\n#define MAX8925_SDV(_id, min, max, step)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.desc\t= {\t\t\t\t\t\t\\\n\t\t.name\t= \"SDV\" #_id,\t\t\t\t\\\n\t\t.of_match = of_match_ptr(\"SDV\" #_id),\t\t\\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\t\\\n\t\t.ops\t= &max8925_regulator_sdv_ops,\t\t\\\n\t\t.type\t= REGULATOR_VOLTAGE,\t\t\t\\\n\t\t.id\t= MAX8925_ID_SD##_id,\t\t\t\\\n\t\t.owner\t= THIS_MODULE,\t\t\t\t\\\n\t\t.n_voltages = 64,\t\t\t\t\\\n\t\t.min_uV = min * 1000,\t\t\t\t\\\n\t\t.uV_step = step * 1000,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.vol_reg\t= MAX8925_SDV##_id,\t\t\t\\\n\t.enable_reg\t= MAX8925_SDCTL##_id,\t\t\t\\\n}\n\n#define MAX8925_LDO(_id, min, max, step)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.desc\t= {\t\t\t\t\t\t\\\n\t\t.name\t= \"LDO\" #_id,\t\t\t\t\\\n\t\t.of_match = of_match_ptr(\"LDO\" #_id),\t\t\\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\t\\\n\t\t.ops\t= &max8925_regulator_ldo_ops,\t\t\\\n\t\t.type\t= REGULATOR_VOLTAGE,\t\t\t\\\n\t\t.id\t= MAX8925_ID_LDO##_id,\t\t\t\\\n\t\t.owner\t= THIS_MODULE,\t\t\t\t\\\n\t\t.n_voltages = 64,\t\t\t\t\\\n\t\t.min_uV = min * 1000,\t\t\t\t\\\n\t\t.uV_step = step * 1000,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.vol_reg\t= MAX8925_LDOVOUT##_id,\t\t\t\\\n\t.enable_reg\t= MAX8925_LDOCTL##_id,\t\t\t\\\n}\n\nstatic struct max8925_regulator_info max8925_regulator_info[] = {\n\tMAX8925_SDV(1, 637.5, 1425, 12.5),\n\tMAX8925_SDV(2,   650, 2225,   25),\n\tMAX8925_SDV(3,   750, 3900,   50),\n\n\tMAX8925_LDO(1,  750, 3900, 50),\n\tMAX8925_LDO(2,  650, 2250, 25),\n\tMAX8925_LDO(3,  650, 2250, 25),\n\tMAX8925_LDO(4,  750, 3900, 50),\n\tMAX8925_LDO(5,  750, 3900, 50),\n\tMAX8925_LDO(6,  750, 3900, 50),\n\tMAX8925_LDO(7,  750, 3900, 50),\n\tMAX8925_LDO(8,  750, 3900, 50),\n\tMAX8925_LDO(9,  750, 3900, 50),\n\tMAX8925_LDO(10, 750, 3900, 50),\n\tMAX8925_LDO(11, 750, 3900, 50),\n\tMAX8925_LDO(12, 750, 3900, 50),\n\tMAX8925_LDO(13, 750, 3900, 50),\n\tMAX8925_LDO(14, 750, 3900, 50),\n\tMAX8925_LDO(15, 750, 3900, 50),\n\tMAX8925_LDO(16, 750, 3900, 50),\n\tMAX8925_LDO(17, 650, 2250, 25),\n\tMAX8925_LDO(18, 650, 2250, 25),\n\tMAX8925_LDO(19, 750, 3900, 50),\n\tMAX8925_LDO(20, 750, 3900, 50),\n};\n\nstatic int max8925_regulator_probe(struct platform_device *pdev)\n{\n\tstruct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct regulator_init_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct regulator_config config = { };\n\tstruct max8925_regulator_info *ri;\n\tstruct resource *res;\n\tstruct regulator_dev *rdev;\n\tint i;\n\n\tres = platform_get_resource(pdev, IORESOURCE_REG, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"No REG resource!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(max8925_regulator_info); i++) {\n\t\tri = &max8925_regulator_info[i];\n\t\tif (ri->vol_reg == res->start)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(max8925_regulator_info)) {\n\t\tdev_err(&pdev->dev, \"Failed to find regulator %llu\\n\",\n\t\t\t(unsigned long long)res->start);\n\t\treturn -EINVAL;\n\t}\n\tri->i2c = chip->i2c;\n\n\tconfig.dev = chip->dev;\n\tconfig.driver_data = ri;\n\n\tif (pdata)\n\t\tconfig.init_data = pdata;\n\n\trdev = devm_regulator_register(&pdev->dev, &ri->desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(&pdev->dev, \"failed to register regulator %s\\n\",\n\t\t\t\tri->desc.name);\n\t\treturn PTR_ERR(rdev);\n\t}\n\n\tplatform_set_drvdata(pdev, rdev);\n\treturn 0;\n}\n\nstatic struct platform_driver max8925_regulator_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"max8925-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t\t= max8925_regulator_probe,\n};\n\nstatic int __init max8925_regulator_init(void)\n{\n\treturn platform_driver_register(&max8925_regulator_driver);\n}\nsubsys_initcall(max8925_regulator_init);\n\nstatic void __exit max8925_regulator_exit(void)\n{\n\tplatform_driver_unregister(&max8925_regulator_driver);\n}\nmodule_exit(max8925_regulator_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Haojian Zhuang <haojian.zhuang@marvell.com>\");\nMODULE_DESCRIPTION(\"Regulator Driver for Maxim 8925 PMIC\");\nMODULE_ALIAS(\"platform:max8925-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}