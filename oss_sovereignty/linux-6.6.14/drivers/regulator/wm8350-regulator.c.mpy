{
  "module_name": "wm8350-regulator.c",
  "hash_id": "5f24cd7979f641b502d0a707adb496fd7364092ecc7035706187577fda50c104",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/wm8350-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/mfd/wm8350/core.h>\n#include <linux/mfd/wm8350/pmic.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n\n \n#define WM8350_DCDC_MAX_VSEL 0x66\n\n \nstatic const unsigned int isink_cur[] = {\n\t4,\n\t5,\n\t6,\n\t7,\n\t8,\n\t10,\n\t11,\n\t14,\n\t16,\n\t19,\n\t23,\n\t27,\n\t32,\n\t39,\n\t46,\n\t54,\n\t65,\n\t77,\n\t92,\n\t109,\n\t130,\n\t154,\n\t183,\n\t218,\n\t259,\n\t308,\n\t367,\n\t436,\n\t518,\n\t616,\n\t733,\n\t872,\n\t1037,\n\t1233,\n\t1466,\n\t1744,\n\t2073,\n\t2466,\n\t2933,\n\t3487,\n\t4147,\n\t4932,\n\t5865,\n\t6975,\n\t8294,\n\t9864,\n\t11730,\n\t13949,\n\t16589,\n\t19728,\n\t23460,\n\t27899,\n\t33178,\n\t39455,\n\t46920,\n\t55798,\n\t66355,\n\t78910,\n\t93840,\n\t111596,\n\t132710,\n\t157820,\n\t187681,\n\t223191\n};\n\n \nstatic int wm8350_isink_enable(struct regulator_dev *rdev)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint isink = rdev_get_id(rdev);\n\n\tswitch (isink) {\n\tcase WM8350_ISINK_A:\n\t\tswitch (wm8350->pmic.isink_A_dcdc) {\n\t\tcase WM8350_DCDC_2:\n\t\tcase WM8350_DCDC_5:\n\t\t\twm8350_set_bits(wm8350, WM8350_POWER_MGMT_7,\n\t\t\t\t\tWM8350_CS1_ENA);\n\t\t\twm8350_set_bits(wm8350, WM8350_CSA_FLASH_CONTROL,\n\t\t\t\t\tWM8350_CS1_DRIVE);\n\t\t\twm8350_set_bits(wm8350, WM8350_DCDC_LDO_REQUESTED,\n\t\t\t\t\t1 << (wm8350->pmic.isink_A_dcdc -\n\t\t\t\t\t      WM8350_DCDC_1));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase WM8350_ISINK_B:\n\t\tswitch (wm8350->pmic.isink_B_dcdc) {\n\t\tcase WM8350_DCDC_2:\n\t\tcase WM8350_DCDC_5:\n\t\t\twm8350_set_bits(wm8350, WM8350_POWER_MGMT_7,\n\t\t\t\t\tWM8350_CS2_ENA);\n\t\t\twm8350_set_bits(wm8350, WM8350_CSB_FLASH_CONTROL,\n\t\t\t\t\tWM8350_CS2_DRIVE);\n\t\t\twm8350_set_bits(wm8350, WM8350_DCDC_LDO_REQUESTED,\n\t\t\t\t\t1 << (wm8350->pmic.isink_B_dcdc -\n\t\t\t\t\t      WM8350_DCDC_1));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int wm8350_isink_disable(struct regulator_dev *rdev)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint isink = rdev_get_id(rdev);\n\n\tswitch (isink) {\n\tcase WM8350_ISINK_A:\n\t\tswitch (wm8350->pmic.isink_A_dcdc) {\n\t\tcase WM8350_DCDC_2:\n\t\tcase WM8350_DCDC_5:\n\t\t\twm8350_clear_bits(wm8350, WM8350_DCDC_LDO_REQUESTED,\n\t\t\t\t\t  1 << (wm8350->pmic.isink_A_dcdc -\n\t\t\t\t\t\tWM8350_DCDC_1));\n\t\t\twm8350_clear_bits(wm8350, WM8350_POWER_MGMT_7,\n\t\t\t\t\t  WM8350_CS1_ENA);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase WM8350_ISINK_B:\n\t\tswitch (wm8350->pmic.isink_B_dcdc) {\n\t\tcase WM8350_DCDC_2:\n\t\tcase WM8350_DCDC_5:\n\t\t\twm8350_clear_bits(wm8350, WM8350_DCDC_LDO_REQUESTED,\n\t\t\t\t\t  1 << (wm8350->pmic.isink_B_dcdc -\n\t\t\t\t\t\tWM8350_DCDC_1));\n\t\t\twm8350_clear_bits(wm8350, WM8350_POWER_MGMT_7,\n\t\t\t\t\t  WM8350_CS2_ENA);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int wm8350_isink_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint isink = rdev_get_id(rdev);\n\n\tswitch (isink) {\n\tcase WM8350_ISINK_A:\n\t\treturn wm8350_reg_read(wm8350, WM8350_CURRENT_SINK_DRIVER_A) &\n\t\t    0x8000;\n\tcase WM8350_ISINK_B:\n\t\treturn wm8350_reg_read(wm8350, WM8350_CURRENT_SINK_DRIVER_B) &\n\t\t    0x8000;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int wm8350_isink_enable_time(struct regulator_dev *rdev)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint isink = rdev_get_id(rdev);\n\tint reg;\n\n\tswitch (isink) {\n\tcase WM8350_ISINK_A:\n\t\treg = wm8350_reg_read(wm8350, WM8350_CSA_FLASH_CONTROL);\n\t\tbreak;\n\tcase WM8350_ISINK_B:\n\t\treg = wm8350_reg_read(wm8350, WM8350_CSB_FLASH_CONTROL);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (reg & WM8350_CS1_FLASH_MODE) {\n\t\tswitch (reg & WM8350_CS1_ON_RAMP_MASK) {\n\t\tcase 0:\n\t\t\treturn 0;\n\t\tcase 1:\n\t\t\treturn 1950;\n\t\tcase 2:\n\t\t\treturn 3910;\n\t\tcase 3:\n\t\t\treturn 7800;\n\t\t}\n\t} else {\n\t\tswitch (reg & WM8350_CS1_ON_RAMP_MASK) {\n\t\tcase 0:\n\t\t\treturn 0;\n\t\tcase 1:\n\t\t\treturn 250000;\n\t\tcase 2:\n\t\t\treturn 500000;\n\t\tcase 3:\n\t\t\treturn 1000000;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n\nint wm8350_isink_set_flash(struct wm8350 *wm8350, int isink, u16 mode,\n\t\t\t   u16 trigger, u16 duration, u16 on_ramp, u16 off_ramp,\n\t\t\t   u16 drive)\n{\n\tswitch (isink) {\n\tcase WM8350_ISINK_A:\n\t\twm8350_reg_write(wm8350, WM8350_CSA_FLASH_CONTROL,\n\t\t\t\t (mode ? WM8350_CS1_FLASH_MODE : 0) |\n\t\t\t\t (trigger ? WM8350_CS1_TRIGSRC : 0) |\n\t\t\t\t duration | on_ramp | off_ramp | drive);\n\t\tbreak;\n\tcase WM8350_ISINK_B:\n\t\twm8350_reg_write(wm8350, WM8350_CSB_FLASH_CONTROL,\n\t\t\t\t (mode ? WM8350_CS2_FLASH_MODE : 0) |\n\t\t\t\t (trigger ? WM8350_CS2_TRIGSRC : 0) |\n\t\t\t\t duration | on_ramp | off_ramp | drive);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm8350_isink_set_flash);\n\nstatic int wm8350_dcdc_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint sel, volt_reg, dcdc = rdev_get_id(rdev);\n\tu16 val;\n\n\tdev_dbg(wm8350->dev, \"%s %d mV %d\\n\", __func__, dcdc, uV / 1000);\n\n\tswitch (dcdc) {\n\tcase WM8350_DCDC_1:\n\t\tvolt_reg = WM8350_DCDC1_LOW_POWER;\n\t\tbreak;\n\tcase WM8350_DCDC_3:\n\t\tvolt_reg = WM8350_DCDC3_LOW_POWER;\n\t\tbreak;\n\tcase WM8350_DCDC_4:\n\t\tvolt_reg = WM8350_DCDC4_LOW_POWER;\n\t\tbreak;\n\tcase WM8350_DCDC_6:\n\t\tvolt_reg = WM8350_DCDC6_LOW_POWER;\n\t\tbreak;\n\tcase WM8350_DCDC_2:\n\tcase WM8350_DCDC_5:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsel = regulator_map_voltage_linear(rdev, uV, uV);\n\tif (sel < 0)\n\t\treturn sel;\n\n\t \n\tval = wm8350_reg_read(wm8350, volt_reg) & ~WM8350_DC1_VSEL_MASK;\n\twm8350_reg_write(wm8350, volt_reg, val | sel);\n\treturn 0;\n}\n\nstatic int wm8350_dcdc_set_suspend_enable(struct regulator_dev *rdev)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint dcdc = rdev_get_id(rdev);\n\tu16 val;\n\n\tswitch (dcdc) {\n\tcase WM8350_DCDC_1:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC1_LOW_POWER)\n\t\t\t& ~WM8350_DCDC_HIB_MODE_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_DCDC1_LOW_POWER,\n\t\t\tval | wm8350->pmic.dcdc1_hib_mode);\n\t\tbreak;\n\tcase WM8350_DCDC_3:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC3_LOW_POWER)\n\t\t\t& ~WM8350_DCDC_HIB_MODE_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_DCDC3_LOW_POWER,\n\t\t\tval | wm8350->pmic.dcdc3_hib_mode);\n\t\tbreak;\n\tcase WM8350_DCDC_4:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC4_LOW_POWER)\n\t\t\t& ~WM8350_DCDC_HIB_MODE_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_DCDC4_LOW_POWER,\n\t\t\tval | wm8350->pmic.dcdc4_hib_mode);\n\t\tbreak;\n\tcase WM8350_DCDC_6:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC6_LOW_POWER)\n\t\t\t& ~WM8350_DCDC_HIB_MODE_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_DCDC6_LOW_POWER,\n\t\t\tval | wm8350->pmic.dcdc6_hib_mode);\n\t\tbreak;\n\tcase WM8350_DCDC_2:\n\tcase WM8350_DCDC_5:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8350_dcdc_set_suspend_disable(struct regulator_dev *rdev)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint dcdc = rdev_get_id(rdev);\n\tu16 val;\n\n\tswitch (dcdc) {\n\tcase WM8350_DCDC_1:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC1_LOW_POWER);\n\t\twm8350->pmic.dcdc1_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_DCDC1_LOW_POWER,\n\t\t\t\t val | WM8350_DCDC_HIB_MODE_DIS);\n\t\tbreak;\n\tcase WM8350_DCDC_3:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC3_LOW_POWER);\n\t\twm8350->pmic.dcdc3_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_DCDC3_LOW_POWER,\n\t\t\t\t val | WM8350_DCDC_HIB_MODE_DIS);\n\t\tbreak;\n\tcase WM8350_DCDC_4:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC4_LOW_POWER);\n\t\twm8350->pmic.dcdc4_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_DCDC4_LOW_POWER,\n\t\t\t\t val | WM8350_DCDC_HIB_MODE_DIS);\n\t\tbreak;\n\tcase WM8350_DCDC_6:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC6_LOW_POWER);\n\t\twm8350->pmic.dcdc6_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_DCDC6_LOW_POWER,\n\t\t\t\t val | WM8350_DCDC_HIB_MODE_DIS);\n\t\tbreak;\n\tcase WM8350_DCDC_2:\n\tcase WM8350_DCDC_5:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8350_dcdc25_set_suspend_enable(struct regulator_dev *rdev)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint dcdc = rdev_get_id(rdev);\n\tu16 val;\n\n\tswitch (dcdc) {\n\tcase WM8350_DCDC_2:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC2_CONTROL)\n\t\t    & ~WM8350_DC2_HIB_MODE_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_DCDC2_CONTROL, val |\n\t\t    (WM8350_DC2_HIB_MODE_ACTIVE << WM8350_DC2_HIB_MODE_SHIFT));\n\t\tbreak;\n\tcase WM8350_DCDC_5:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC5_CONTROL)\n\t\t    & ~WM8350_DC5_HIB_MODE_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_DCDC5_CONTROL, val |\n\t\t    (WM8350_DC5_HIB_MODE_ACTIVE << WM8350_DC5_HIB_MODE_SHIFT));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int wm8350_dcdc25_set_suspend_disable(struct regulator_dev *rdev)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint dcdc = rdev_get_id(rdev);\n\tu16 val;\n\n\tswitch (dcdc) {\n\tcase WM8350_DCDC_2:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC2_CONTROL)\n\t\t    & ~WM8350_DC2_HIB_MODE_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_DCDC2_CONTROL, val |\n\t\t    (WM8350_DC2_HIB_MODE_DISABLE << WM8350_DC2_HIB_MODE_SHIFT));\n\t\tbreak;\n\tcase WM8350_DCDC_5:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC5_CONTROL)\n\t\t    & ~WM8350_DC5_HIB_MODE_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_DCDC5_CONTROL, val |\n\t\t    (WM8350_DC5_HIB_MODE_DISABLE << WM8350_DC5_HIB_MODE_SHIFT));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int wm8350_dcdc_set_suspend_mode(struct regulator_dev *rdev,\n\tunsigned int mode)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint dcdc = rdev_get_id(rdev);\n\tu16 *hib_mode;\n\n\tswitch (dcdc) {\n\tcase WM8350_DCDC_1:\n\t\thib_mode = &wm8350->pmic.dcdc1_hib_mode;\n\t\tbreak;\n\tcase WM8350_DCDC_3:\n\t\thib_mode = &wm8350->pmic.dcdc3_hib_mode;\n\t\tbreak;\n\tcase WM8350_DCDC_4:\n\t\thib_mode = &wm8350->pmic.dcdc4_hib_mode;\n\t\tbreak;\n\tcase WM8350_DCDC_6:\n\t\thib_mode = &wm8350->pmic.dcdc6_hib_mode;\n\t\tbreak;\n\tcase WM8350_DCDC_2:\n\tcase WM8350_DCDC_5:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\t*hib_mode = WM8350_DCDC_HIB_MODE_IMAGE;\n\t\tbreak;\n\tcase REGULATOR_MODE_IDLE:\n\t\t*hib_mode = WM8350_DCDC_HIB_MODE_STANDBY;\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\t*hib_mode = WM8350_DCDC_HIB_MODE_LDO_IM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct linear_range wm8350_ldo_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(900000, 0, 15, 50000),\n\tREGULATOR_LINEAR_RANGE(1800000, 16, 31, 100000),\n};\n\nstatic int wm8350_ldo_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint sel, volt_reg, ldo = rdev_get_id(rdev);\n\tu16 val;\n\n\tdev_dbg(wm8350->dev, \"%s %d mV %d\\n\", __func__, ldo, uV / 1000);\n\n\tswitch (ldo) {\n\tcase WM8350_LDO_1:\n\t\tvolt_reg = WM8350_LDO1_LOW_POWER;\n\t\tbreak;\n\tcase WM8350_LDO_2:\n\t\tvolt_reg = WM8350_LDO2_LOW_POWER;\n\t\tbreak;\n\tcase WM8350_LDO_3:\n\t\tvolt_reg = WM8350_LDO3_LOW_POWER;\n\t\tbreak;\n\tcase WM8350_LDO_4:\n\t\tvolt_reg = WM8350_LDO4_LOW_POWER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsel = regulator_map_voltage_linear_range(rdev, uV, uV);\n\tif (sel < 0)\n\t\treturn sel;\n\n\t \n\tval = wm8350_reg_read(wm8350, volt_reg) & ~WM8350_LDO1_VSEL_MASK;\n\twm8350_reg_write(wm8350, volt_reg, val | sel);\n\treturn 0;\n}\n\nstatic int wm8350_ldo_set_suspend_enable(struct regulator_dev *rdev)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint volt_reg, ldo = rdev_get_id(rdev);\n\tu16 val;\n\n\tswitch (ldo) {\n\tcase WM8350_LDO_1:\n\t\tvolt_reg = WM8350_LDO1_LOW_POWER;\n\t\tbreak;\n\tcase WM8350_LDO_2:\n\t\tvolt_reg = WM8350_LDO2_LOW_POWER;\n\t\tbreak;\n\tcase WM8350_LDO_3:\n\t\tvolt_reg = WM8350_LDO3_LOW_POWER;\n\t\tbreak;\n\tcase WM8350_LDO_4:\n\t\tvolt_reg = WM8350_LDO4_LOW_POWER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval = wm8350_reg_read(wm8350, volt_reg) & ~WM8350_LDO1_HIB_MODE_MASK;\n\twm8350_reg_write(wm8350, volt_reg, val);\n\treturn 0;\n}\n\nstatic int wm8350_ldo_set_suspend_disable(struct regulator_dev *rdev)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint volt_reg, ldo = rdev_get_id(rdev);\n\tu16 val;\n\n\tswitch (ldo) {\n\tcase WM8350_LDO_1:\n\t\tvolt_reg = WM8350_LDO1_LOW_POWER;\n\t\tbreak;\n\tcase WM8350_LDO_2:\n\t\tvolt_reg = WM8350_LDO2_LOW_POWER;\n\t\tbreak;\n\tcase WM8350_LDO_3:\n\t\tvolt_reg = WM8350_LDO3_LOW_POWER;\n\t\tbreak;\n\tcase WM8350_LDO_4:\n\t\tvolt_reg = WM8350_LDO4_LOW_POWER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval = wm8350_reg_read(wm8350, volt_reg) & ~WM8350_LDO1_HIB_MODE_MASK;\n\twm8350_reg_write(wm8350, volt_reg, val | WM8350_LDO1_HIB_MODE_DIS);\n\treturn 0;\n}\n\nint wm8350_dcdc_set_slot(struct wm8350 *wm8350, int dcdc, u16 start,\n\t\t\t u16 stop, u16 fault)\n{\n\tint slot_reg;\n\tu16 val;\n\n\tdev_dbg(wm8350->dev, \"%s %d start %d stop %d\\n\",\n\t\t__func__, dcdc, start, stop);\n\n\t \n\tif (start > 15 || stop > 15)\n\t\treturn -EINVAL;\n\n\tswitch (dcdc) {\n\tcase WM8350_DCDC_1:\n\t\tslot_reg = WM8350_DCDC1_TIMEOUTS;\n\t\tbreak;\n\tcase WM8350_DCDC_2:\n\t\tslot_reg = WM8350_DCDC2_TIMEOUTS;\n\t\tbreak;\n\tcase WM8350_DCDC_3:\n\t\tslot_reg = WM8350_DCDC3_TIMEOUTS;\n\t\tbreak;\n\tcase WM8350_DCDC_4:\n\t\tslot_reg = WM8350_DCDC4_TIMEOUTS;\n\t\tbreak;\n\tcase WM8350_DCDC_5:\n\t\tslot_reg = WM8350_DCDC5_TIMEOUTS;\n\t\tbreak;\n\tcase WM8350_DCDC_6:\n\t\tslot_reg = WM8350_DCDC6_TIMEOUTS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval = wm8350_reg_read(wm8350, slot_reg) &\n\t    ~(WM8350_DC1_ENSLOT_MASK | WM8350_DC1_SDSLOT_MASK |\n\t      WM8350_DC1_ERRACT_MASK);\n\twm8350_reg_write(wm8350, slot_reg,\n\t\t\t val | (start << WM8350_DC1_ENSLOT_SHIFT) |\n\t\t\t (stop << WM8350_DC1_SDSLOT_SHIFT) |\n\t\t\t (fault << WM8350_DC1_ERRACT_SHIFT));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm8350_dcdc_set_slot);\n\nint wm8350_ldo_set_slot(struct wm8350 *wm8350, int ldo, u16 start, u16 stop)\n{\n\tint slot_reg;\n\tu16 val;\n\n\tdev_dbg(wm8350->dev, \"%s %d start %d stop %d\\n\",\n\t\t__func__, ldo, start, stop);\n\n\t \n\tif (start > 15 || stop > 15)\n\t\treturn -EINVAL;\n\n\tswitch (ldo) {\n\tcase WM8350_LDO_1:\n\t\tslot_reg = WM8350_LDO1_TIMEOUTS;\n\t\tbreak;\n\tcase WM8350_LDO_2:\n\t\tslot_reg = WM8350_LDO2_TIMEOUTS;\n\t\tbreak;\n\tcase WM8350_LDO_3:\n\t\tslot_reg = WM8350_LDO3_TIMEOUTS;\n\t\tbreak;\n\tcase WM8350_LDO_4:\n\t\tslot_reg = WM8350_LDO4_TIMEOUTS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval = wm8350_reg_read(wm8350, slot_reg) & ~WM8350_LDO1_SDSLOT_MASK;\n\twm8350_reg_write(wm8350, slot_reg, val | ((start << 10) | (stop << 6)));\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm8350_ldo_set_slot);\n\nint wm8350_dcdc25_set_mode(struct wm8350 *wm8350, int dcdc, u16 mode,\n\t\t\t   u16 ilim, u16 ramp, u16 feedback)\n{\n\tu16 val;\n\n\tdev_dbg(wm8350->dev, \"%s %d mode: %s %s\\n\", __func__, dcdc,\n\t\tmode ? \"normal\" : \"boost\", ilim ? \"low\" : \"normal\");\n\n\tswitch (dcdc) {\n\tcase WM8350_DCDC_2:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC2_CONTROL)\n\t\t    & ~(WM8350_DC2_MODE_MASK | WM8350_DC2_ILIM_MASK |\n\t\t\tWM8350_DC2_RMP_MASK | WM8350_DC2_FBSRC_MASK);\n\t\twm8350_reg_write(wm8350, WM8350_DCDC2_CONTROL, val |\n\t\t\t\t (mode << WM8350_DC2_MODE_SHIFT) |\n\t\t\t\t (ilim << WM8350_DC2_ILIM_SHIFT) |\n\t\t\t\t (ramp << WM8350_DC2_RMP_SHIFT) |\n\t\t\t\t (feedback << WM8350_DC2_FBSRC_SHIFT));\n\t\tbreak;\n\tcase WM8350_DCDC_5:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC5_CONTROL)\n\t\t    & ~(WM8350_DC5_MODE_MASK | WM8350_DC5_ILIM_MASK |\n\t\t\tWM8350_DC5_RMP_MASK | WM8350_DC5_FBSRC_MASK);\n\t\twm8350_reg_write(wm8350, WM8350_DCDC5_CONTROL, val |\n\t\t\t\t (mode << WM8350_DC5_MODE_SHIFT) |\n\t\t\t\t (ilim << WM8350_DC5_ILIM_SHIFT) |\n\t\t\t\t (ramp << WM8350_DC5_RMP_SHIFT) |\n\t\t\t\t (feedback << WM8350_DC5_FBSRC_SHIFT));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm8350_dcdc25_set_mode);\n\nstatic int force_continuous_enable(struct wm8350 *wm8350, int dcdc, int enable)\n{\n\tint reg = 0, ret;\n\n\tswitch (dcdc) {\n\tcase WM8350_DCDC_1:\n\t\treg = WM8350_DCDC1_FORCE_PWM;\n\t\tbreak;\n\tcase WM8350_DCDC_3:\n\t\treg = WM8350_DCDC3_FORCE_PWM;\n\t\tbreak;\n\tcase WM8350_DCDC_4:\n\t\treg = WM8350_DCDC4_FORCE_PWM;\n\t\tbreak;\n\tcase WM8350_DCDC_6:\n\t\treg = WM8350_DCDC6_FORCE_PWM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (enable)\n\t\tret = wm8350_set_bits(wm8350, reg,\n\t\t\tWM8350_DCDC1_FORCE_PWM_ENA);\n\telse\n\t\tret = wm8350_clear_bits(wm8350, reg,\n\t\t\tWM8350_DCDC1_FORCE_PWM_ENA);\n\treturn ret;\n}\n\nstatic int wm8350_dcdc_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint dcdc = rdev_get_id(rdev);\n\tu16 val;\n\n\tif (dcdc < WM8350_DCDC_1 || dcdc > WM8350_DCDC_6)\n\t\treturn -EINVAL;\n\n\tif (dcdc == WM8350_DCDC_2 || dcdc == WM8350_DCDC_5)\n\t\treturn -EINVAL;\n\n\tval = 1 << (dcdc - WM8350_DCDC_1);\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\t \n\t\twm8350_set_bits(wm8350, WM8350_DCDC_ACTIVE_OPTIONS, val);\n\t\twm8350_clear_bits(wm8350, WM8350_DCDC_SLEEP_OPTIONS, val);\n\t\tforce_continuous_enable(wm8350, dcdc, 1);\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\t \n\t\twm8350_set_bits(wm8350, WM8350_DCDC_ACTIVE_OPTIONS, val);\n\t\twm8350_clear_bits(wm8350, WM8350_DCDC_SLEEP_OPTIONS, val);\n\t\tforce_continuous_enable(wm8350, dcdc, 0);\n\t\tbreak;\n\tcase REGULATOR_MODE_IDLE:\n\t\t \n\t\tforce_continuous_enable(wm8350, dcdc, 0);\n\t\twm8350_clear_bits(wm8350, WM8350_DCDC_SLEEP_OPTIONS, val);\n\t\twm8350_clear_bits(wm8350, WM8350_DCDC_ACTIVE_OPTIONS, val);\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\t \n\t\tforce_continuous_enable(wm8350, dcdc, 0);\n\t\twm8350_set_bits(wm8350, WM8350_DCDC_SLEEP_OPTIONS, val);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int wm8350_dcdc_get_mode(struct regulator_dev *rdev)\n{\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\tint dcdc = rdev_get_id(rdev);\n\tu16 mask, sleep, active, force;\n\tint mode = REGULATOR_MODE_NORMAL;\n\tint reg;\n\n\tswitch (dcdc) {\n\tcase WM8350_DCDC_1:\n\t\treg = WM8350_DCDC1_FORCE_PWM;\n\t\tbreak;\n\tcase WM8350_DCDC_3:\n\t\treg = WM8350_DCDC3_FORCE_PWM;\n\t\tbreak;\n\tcase WM8350_DCDC_4:\n\t\treg = WM8350_DCDC4_FORCE_PWM;\n\t\tbreak;\n\tcase WM8350_DCDC_6:\n\t\treg = WM8350_DCDC6_FORCE_PWM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmask = 1 << (dcdc - WM8350_DCDC_1);\n\tactive = wm8350_reg_read(wm8350, WM8350_DCDC_ACTIVE_OPTIONS) & mask;\n\tforce = wm8350_reg_read(wm8350, reg) & WM8350_DCDC1_FORCE_PWM_ENA;\n\tsleep = wm8350_reg_read(wm8350, WM8350_DCDC_SLEEP_OPTIONS) & mask;\n\n\tdev_dbg(wm8350->dev, \"mask %x active %x sleep %x force %x\",\n\t\tmask, active, sleep, force);\n\n\tif (active && !sleep) {\n\t\tif (force)\n\t\t\tmode = REGULATOR_MODE_FAST;\n\t\telse\n\t\t\tmode = REGULATOR_MODE_NORMAL;\n\t} else if (!active && !sleep)\n\t\tmode = REGULATOR_MODE_IDLE;\n\telse if (sleep)\n\t\tmode = REGULATOR_MODE_STANDBY;\n\n\treturn mode;\n}\n\nstatic unsigned int wm8350_ldo_get_mode(struct regulator_dev *rdev)\n{\n\treturn REGULATOR_MODE_NORMAL;\n}\n\nstruct wm8350_dcdc_efficiency {\n\tint uA_load_min;\n\tint uA_load_max;\n\tunsigned int mode;\n};\n\nstatic const struct wm8350_dcdc_efficiency dcdc1_6_efficiency[] = {\n\t{0, 10000, REGULATOR_MODE_STANDBY},        \n\t{10000, 100000, REGULATOR_MODE_IDLE},      \n\t{100000, 1000000, REGULATOR_MODE_NORMAL},  \n\t{-1, -1, REGULATOR_MODE_NORMAL},\n};\n\nstatic const struct wm8350_dcdc_efficiency dcdc3_4_efficiency[] = {\n\t{0, 10000, REGULATOR_MODE_STANDBY},       \n\t{10000, 100000, REGULATOR_MODE_IDLE},     \n\t{100000, 800000, REGULATOR_MODE_NORMAL},  \n\t{-1, -1, REGULATOR_MODE_NORMAL},\n};\n\nstatic unsigned int get_mode(int uA, const struct wm8350_dcdc_efficiency *eff)\n{\n\tint i = 0;\n\n\twhile (eff[i].uA_load_min != -1) {\n\t\tif (uA >= eff[i].uA_load_min && uA <= eff[i].uA_load_max)\n\t\t\treturn eff[i].mode;\n\t\ti++;\n\t}\n\treturn REGULATOR_MODE_NORMAL;\n}\n\n \nstatic unsigned int wm8350_dcdc_get_optimum_mode(struct regulator_dev *rdev,\n\t\t\t\t\t\t int input_uV, int output_uV,\n\t\t\t\t\t\t int output_uA)\n{\n\tint dcdc = rdev_get_id(rdev), mode;\n\n\tswitch (dcdc) {\n\tcase WM8350_DCDC_1:\n\tcase WM8350_DCDC_6:\n\t\tmode = get_mode(output_uA, dcdc1_6_efficiency);\n\t\tbreak;\n\tcase WM8350_DCDC_3:\n\tcase WM8350_DCDC_4:\n\t\tmode = get_mode(output_uA, dcdc3_4_efficiency);\n\t\tbreak;\n\tdefault:\n\t\tmode = REGULATOR_MODE_NORMAL;\n\t\tbreak;\n\t}\n\treturn mode;\n}\n\nstatic const struct regulator_ops wm8350_dcdc_ops = {\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.get_mode = wm8350_dcdc_get_mode,\n\t.set_mode = wm8350_dcdc_set_mode,\n\t.get_optimum_mode = wm8350_dcdc_get_optimum_mode,\n\t.set_suspend_voltage = wm8350_dcdc_set_suspend_voltage,\n\t.set_suspend_enable = wm8350_dcdc_set_suspend_enable,\n\t.set_suspend_disable = wm8350_dcdc_set_suspend_disable,\n\t.set_suspend_mode = wm8350_dcdc_set_suspend_mode,\n};\n\nstatic const struct regulator_ops wm8350_dcdc2_5_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_suspend_enable = wm8350_dcdc25_set_suspend_enable,\n\t.set_suspend_disable = wm8350_dcdc25_set_suspend_disable,\n};\n\nstatic const struct regulator_ops wm8350_ldo_ops = {\n\t.map_voltage = regulator_map_voltage_linear_range,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.get_mode = wm8350_ldo_get_mode,\n\t.set_suspend_voltage = wm8350_ldo_set_suspend_voltage,\n\t.set_suspend_enable = wm8350_ldo_set_suspend_enable,\n\t.set_suspend_disable = wm8350_ldo_set_suspend_disable,\n};\n\nstatic const struct regulator_ops wm8350_isink_ops = {\n\t.set_current_limit = regulator_set_current_limit_regmap,\n\t.get_current_limit = regulator_get_current_limit_regmap,\n\t.enable = wm8350_isink_enable,\n\t.disable = wm8350_isink_disable,\n\t.is_enabled = wm8350_isink_is_enabled,\n\t.enable_time = wm8350_isink_enable_time,\n};\n\nstatic const struct regulator_desc wm8350_reg[NUM_WM8350_REGULATORS] = {\n\t{\n\t\t.name = \"DCDC1\",\n\t\t.id = WM8350_DCDC_1,\n\t\t.ops = &wm8350_dcdc_ops,\n\t\t.irq = WM8350_IRQ_UV_DC1,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = WM8350_DCDC_MAX_VSEL + 1,\n\t\t.min_uV = 850000,\n\t\t.uV_step = 25000,\n\t\t.vsel_reg = WM8350_DCDC1_CONTROL,\n\t\t.vsel_mask = WM8350_DC1_VSEL_MASK,\n\t\t.enable_reg = WM8350_DCDC_LDO_REQUESTED,\n\t\t.enable_mask = WM8350_DC1_ENA,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"DCDC2\",\n\t\t.id = WM8350_DCDC_2,\n\t\t.ops = &wm8350_dcdc2_5_ops,\n\t\t.irq = WM8350_IRQ_UV_DC2,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.enable_reg = WM8350_DCDC_LDO_REQUESTED,\n\t\t.enable_mask = WM8350_DC2_ENA,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"DCDC3\",\n\t\t.id = WM8350_DCDC_3,\n\t\t.ops = &wm8350_dcdc_ops,\n\t\t.irq = WM8350_IRQ_UV_DC3,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = WM8350_DCDC_MAX_VSEL + 1,\n\t\t.min_uV = 850000,\n\t\t.uV_step = 25000,\n\t\t.vsel_reg = WM8350_DCDC3_CONTROL,\n\t\t.vsel_mask = WM8350_DC3_VSEL_MASK,\n\t\t.enable_reg = WM8350_DCDC_LDO_REQUESTED,\n\t\t.enable_mask = WM8350_DC3_ENA,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"DCDC4\",\n\t\t.id = WM8350_DCDC_4,\n\t\t.ops = &wm8350_dcdc_ops,\n\t\t.irq = WM8350_IRQ_UV_DC4,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = WM8350_DCDC_MAX_VSEL + 1,\n\t\t.min_uV = 850000,\n\t\t.uV_step = 25000,\n\t\t.vsel_reg = WM8350_DCDC4_CONTROL,\n\t\t.vsel_mask = WM8350_DC4_VSEL_MASK,\n\t\t.enable_reg = WM8350_DCDC_LDO_REQUESTED,\n\t\t.enable_mask = WM8350_DC4_ENA,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"DCDC5\",\n\t\t.id = WM8350_DCDC_5,\n\t\t.ops = &wm8350_dcdc2_5_ops,\n\t\t.irq = WM8350_IRQ_UV_DC5,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.enable_reg = WM8350_DCDC_LDO_REQUESTED,\n\t\t.enable_mask = WM8350_DC5_ENA,\n\t\t.owner = THIS_MODULE,\n\t },\n\t{\n\t\t.name = \"DCDC6\",\n\t\t.id = WM8350_DCDC_6,\n\t\t.ops = &wm8350_dcdc_ops,\n\t\t.irq = WM8350_IRQ_UV_DC6,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = WM8350_DCDC_MAX_VSEL + 1,\n\t\t.min_uV = 850000,\n\t\t.uV_step = 25000,\n\t\t.vsel_reg = WM8350_DCDC6_CONTROL,\n\t\t.vsel_mask = WM8350_DC6_VSEL_MASK,\n\t\t.enable_reg = WM8350_DCDC_LDO_REQUESTED,\n\t\t.enable_mask = WM8350_DC6_ENA,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"LDO1\",\n\t\t.id = WM8350_LDO_1,\n\t\t.ops = &wm8350_ldo_ops,\n\t\t.irq = WM8350_IRQ_UV_LDO1,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = WM8350_LDO1_VSEL_MASK + 1,\n\t\t.linear_ranges = wm8350_ldo_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(wm8350_ldo_ranges),\n\t\t.vsel_reg = WM8350_LDO1_CONTROL,\n\t\t.vsel_mask = WM8350_LDO1_VSEL_MASK,\n\t\t.enable_reg = WM8350_DCDC_LDO_REQUESTED,\n\t\t.enable_mask = WM8350_LDO1_ENA,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"LDO2\",\n\t\t.id = WM8350_LDO_2,\n\t\t.ops = &wm8350_ldo_ops,\n\t\t.irq = WM8350_IRQ_UV_LDO2,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = WM8350_LDO2_VSEL_MASK + 1,\n\t\t.linear_ranges = wm8350_ldo_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(wm8350_ldo_ranges),\n\t\t.vsel_reg = WM8350_LDO2_CONTROL,\n\t\t.vsel_mask = WM8350_LDO2_VSEL_MASK,\n\t\t.enable_reg = WM8350_DCDC_LDO_REQUESTED,\n\t\t.enable_mask = WM8350_LDO2_ENA,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"LDO3\",\n\t\t.id = WM8350_LDO_3,\n\t\t.ops = &wm8350_ldo_ops,\n\t\t.irq = WM8350_IRQ_UV_LDO3,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = WM8350_LDO3_VSEL_MASK + 1,\n\t\t.linear_ranges = wm8350_ldo_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(wm8350_ldo_ranges),\n\t\t.vsel_reg = WM8350_LDO3_CONTROL,\n\t\t.vsel_mask = WM8350_LDO3_VSEL_MASK,\n\t\t.enable_reg = WM8350_DCDC_LDO_REQUESTED,\n\t\t.enable_mask = WM8350_LDO3_ENA,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"LDO4\",\n\t\t.id = WM8350_LDO_4,\n\t\t.ops = &wm8350_ldo_ops,\n\t\t.irq = WM8350_IRQ_UV_LDO4,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = WM8350_LDO4_VSEL_MASK + 1,\n\t\t.linear_ranges = wm8350_ldo_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(wm8350_ldo_ranges),\n\t\t.vsel_reg = WM8350_LDO4_CONTROL,\n\t\t.vsel_mask = WM8350_LDO4_VSEL_MASK,\n\t\t.enable_reg = WM8350_DCDC_LDO_REQUESTED,\n\t\t.enable_mask = WM8350_LDO4_ENA,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"ISINKA\",\n\t\t.id = WM8350_ISINK_A,\n\t\t.ops = &wm8350_isink_ops,\n\t\t.irq = WM8350_IRQ_CS1,\n\t\t.type = REGULATOR_CURRENT,\n\t\t.owner = THIS_MODULE,\n\t\t.curr_table = isink_cur,\n\t\t.n_current_limits = ARRAY_SIZE(isink_cur),\n\t\t.csel_reg = WM8350_CURRENT_SINK_DRIVER_A,\n\t\t.csel_mask = WM8350_CS1_ISEL_MASK,\n\t },\n\t{\n\t\t.name = \"ISINKB\",\n\t\t.id = WM8350_ISINK_B,\n\t\t.ops = &wm8350_isink_ops,\n\t\t.irq = WM8350_IRQ_CS2,\n\t\t.type = REGULATOR_CURRENT,\n\t\t.owner = THIS_MODULE,\n\t\t.curr_table = isink_cur,\n\t\t.n_current_limits = ARRAY_SIZE(isink_cur),\n\t\t.csel_reg = WM8350_CURRENT_SINK_DRIVER_B,\n\t\t.csel_mask = WM8350_CS2_ISEL_MASK,\n\t },\n};\n\nstatic irqreturn_t pmic_uv_handler(int irq, void *data)\n{\n\tstruct regulator_dev *rdev = (struct regulator_dev *)data;\n\n\tif (irq == WM8350_IRQ_CS1 || irq == WM8350_IRQ_CS2)\n\t\tregulator_notifier_call_chain(rdev,\n\t\t\t\t\t      REGULATOR_EVENT_REGULATION_OUT,\n\t\t\t\t\t      NULL);\n\telse\n\t\tregulator_notifier_call_chain(rdev,\n\t\t\t\t\t      REGULATOR_EVENT_UNDER_VOLTAGE,\n\t\t\t\t\t      NULL);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int wm8350_regulator_probe(struct platform_device *pdev)\n{\n\tstruct wm8350 *wm8350 = dev_get_drvdata(&pdev->dev);\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tint ret;\n\tu16 val;\n\n\tif (pdev->id < WM8350_DCDC_1 || pdev->id > WM8350_ISINK_B)\n\t\treturn -ENODEV;\n\n\t \n\tswitch (pdev->id) {\n\tcase WM8350_DCDC_1:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC1_LOW_POWER);\n\t\twm8350->pmic.dcdc1_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\n\t\tbreak;\n\tcase WM8350_DCDC_3:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC3_LOW_POWER);\n\t\twm8350->pmic.dcdc3_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\n\t\tbreak;\n\tcase WM8350_DCDC_4:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC4_LOW_POWER);\n\t\twm8350->pmic.dcdc4_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\n\t\tbreak;\n\tcase WM8350_DCDC_6:\n\t\tval = wm8350_reg_read(wm8350, WM8350_DCDC6_LOW_POWER);\n\t\twm8350->pmic.dcdc6_hib_mode = val & WM8350_DCDC_HIB_MODE_MASK;\n\t\tbreak;\n\t}\n\n\tconfig.dev = &pdev->dev;\n\tconfig.init_data = dev_get_platdata(&pdev->dev);\n\tconfig.driver_data = dev_get_drvdata(&pdev->dev);\n\tconfig.regmap = wm8350->regmap;\n\n\t \n\trdev = devm_regulator_register(&pdev->dev, &wm8350_reg[pdev->id],\n\t\t\t\t       &config);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(&pdev->dev, \"failed to register %s\\n\",\n\t\t\twm8350_reg[pdev->id].name);\n\t\treturn PTR_ERR(rdev);\n\t}\n\n\t \n\tret = wm8350_register_irq(wm8350, wm8350_reg[pdev->id].irq,\n\t\t\t\t  pmic_uv_handler, 0, \"UV\", rdev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register regulator %s IRQ\\n\",\n\t\t\twm8350_reg[pdev->id].name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8350_regulator_remove(struct platform_device *pdev)\n{\n\tstruct regulator_dev *rdev = platform_get_drvdata(pdev);\n\tstruct wm8350 *wm8350 = rdev_get_drvdata(rdev);\n\n\twm8350_free_irq(wm8350, wm8350_reg[pdev->id].irq, rdev);\n\n\treturn 0;\n}\n\nint wm8350_register_regulator(struct wm8350 *wm8350, int reg,\n\t\t\t      struct regulator_init_data *initdata)\n{\n\tstruct platform_device *pdev;\n\tint ret;\n\tif (reg < 0 || reg >= NUM_WM8350_REGULATORS)\n\t\treturn -EINVAL;\n\n\tif (wm8350->pmic.pdev[reg])\n\t\treturn -EBUSY;\n\n\tif (reg >= WM8350_DCDC_1 && reg <= WM8350_DCDC_6 &&\n\t    reg > wm8350->pmic.max_dcdc)\n\t\treturn -ENODEV;\n\tif (reg >= WM8350_ISINK_A && reg <= WM8350_ISINK_B &&\n\t    reg > wm8350->pmic.max_isink)\n\t\treturn -ENODEV;\n\n\tpdev = platform_device_alloc(\"wm8350-regulator\", reg);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\twm8350->pmic.pdev[reg] = pdev;\n\n\tinitdata->driver_data = wm8350;\n\n\tpdev->dev.platform_data = initdata;\n\tpdev->dev.parent = wm8350->dev;\n\tplatform_set_drvdata(pdev, wm8350);\n\n\tret = platform_device_add(pdev);\n\n\tif (ret != 0) {\n\t\tdev_err(wm8350->dev, \"Failed to register regulator %d: %d\\n\",\n\t\t\treg, ret);\n\t\tplatform_device_put(pdev);\n\t\twm8350->pmic.pdev[reg] = NULL;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm8350_register_regulator);\n\n \nint wm8350_register_led(struct wm8350 *wm8350, int lednum, int dcdc, int isink,\n\t\t\tstruct wm8350_led_platform_data *pdata)\n{\n\tstruct wm8350_led *led;\n\tstruct platform_device *pdev;\n\tint ret;\n\n\tif (lednum >= ARRAY_SIZE(wm8350->pmic.led) || lednum < 0) {\n\t\tdev_err(wm8350->dev, \"Invalid LED index %d\\n\", lednum);\n\t\treturn -ENODEV;\n\t}\n\n\tled = &wm8350->pmic.led[lednum];\n\n\tif (led->pdev) {\n\t\tdev_err(wm8350->dev, \"LED %d already allocated\\n\", lednum);\n\t\treturn -EINVAL;\n\t}\n\n\tpdev = platform_device_alloc(\"wm8350-led\", lednum);\n\tif (pdev == NULL) {\n\t\tdev_err(wm8350->dev, \"Failed to allocate LED %d\\n\", lednum);\n\t\treturn -ENOMEM;\n\t}\n\n\tled->isink_consumer.dev_name = dev_name(&pdev->dev);\n\tled->isink_consumer.supply = \"led_isink\";\n\tled->isink_init.num_consumer_supplies = 1;\n\tled->isink_init.consumer_supplies = &led->isink_consumer;\n\tled->isink_init.constraints.min_uA = 0;\n\tled->isink_init.constraints.max_uA = pdata->max_uA;\n\tled->isink_init.constraints.valid_ops_mask\n\t\t= REGULATOR_CHANGE_CURRENT | REGULATOR_CHANGE_STATUS;\n\tled->isink_init.constraints.valid_modes_mask = REGULATOR_MODE_NORMAL;\n\tret = wm8350_register_regulator(wm8350, isink, &led->isink_init);\n\tif (ret != 0) {\n\t\tplatform_device_put(pdev);\n\t\treturn ret;\n\t}\n\n\tled->dcdc_consumer.dev_name = dev_name(&pdev->dev);\n\tled->dcdc_consumer.supply = \"led_vcc\";\n\tled->dcdc_init.num_consumer_supplies = 1;\n\tled->dcdc_init.consumer_supplies = &led->dcdc_consumer;\n\tled->dcdc_init.constraints.valid_modes_mask = REGULATOR_MODE_NORMAL;\n\tled->dcdc_init.constraints.valid_ops_mask =  REGULATOR_CHANGE_STATUS;\n\tret = wm8350_register_regulator(wm8350, dcdc, &led->dcdc_init);\n\tif (ret != 0) {\n\t\tplatform_device_put(pdev);\n\t\treturn ret;\n\t}\n\n\tswitch (isink) {\n\tcase WM8350_ISINK_A:\n\t\twm8350->pmic.isink_A_dcdc = dcdc;\n\t\tbreak;\n\tcase WM8350_ISINK_B:\n\t\twm8350->pmic.isink_B_dcdc = dcdc;\n\t\tbreak;\n\t}\n\n\tpdev->dev.platform_data = pdata;\n\tpdev->dev.parent = wm8350->dev;\n\tret = platform_device_add(pdev);\n\tif (ret != 0) {\n\t\tdev_err(wm8350->dev, \"Failed to register LED %d: %d\\n\",\n\t\t\tlednum, ret);\n\t\tplatform_device_put(pdev);\n\t\treturn ret;\n\t}\n\n\tled->pdev = pdev;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm8350_register_led);\n\nstatic struct platform_driver wm8350_regulator_driver = {\n\t.probe = wm8350_regulator_probe,\n\t.remove = wm8350_regulator_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"wm8350-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init wm8350_regulator_init(void)\n{\n\treturn platform_driver_register(&wm8350_regulator_driver);\n}\nsubsys_initcall(wm8350_regulator_init);\n\nstatic void __exit wm8350_regulator_exit(void)\n{\n\tplatform_driver_unregister(&wm8350_regulator_driver);\n}\nmodule_exit(wm8350_regulator_exit);\n\n \nMODULE_AUTHOR(\"Liam Girdwood\");\nMODULE_DESCRIPTION(\"WM8350 voltage and current regulator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm8350-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}