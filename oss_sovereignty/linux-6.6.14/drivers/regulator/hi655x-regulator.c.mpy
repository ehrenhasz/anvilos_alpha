{
  "module_name": "hi655x-regulator.c",
  "hash_id": "d78bd6e04b2ff4ef59bef5979b25e4305a3155901a04c6c010bb9a039de3bdf2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/hi655x-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/mfd/hi655x-pmic.h>\n\nstruct hi655x_regulator {\n\tunsigned int disable_reg;\n\tunsigned int status_reg;\n\tstruct regulator_desc rdesc;\n};\n\n \nstatic const unsigned int ldo7_voltages[] = {\n\t1800000, 1850000, 2850000, 2900000,\n\t3000000, 3100000, 3200000, 3300000,\n};\n\nstatic const unsigned int ldo19_voltages[] = {\n\t1800000, 1850000, 1900000, 1750000,\n\t2800000, 2850000, 2900000, 3000000,\n};\n\nstatic const unsigned int ldo22_voltages[] = {\n\t 900000, 1000000, 1050000, 1100000,\n\t1150000, 1175000, 1185000, 1200000,\n};\n\nenum hi655x_regulator_id {\n\tHI655X_LDO0,\n\tHI655X_LDO1,\n\tHI655X_LDO2,\n\tHI655X_LDO3,\n\tHI655X_LDO4,\n\tHI655X_LDO5,\n\tHI655X_LDO6,\n\tHI655X_LDO7,\n\tHI655X_LDO8,\n\tHI655X_LDO9,\n\tHI655X_LDO10,\n\tHI655X_LDO11,\n\tHI655X_LDO12,\n\tHI655X_LDO13,\n\tHI655X_LDO14,\n\tHI655X_LDO15,\n\tHI655X_LDO16,\n\tHI655X_LDO17,\n\tHI655X_LDO18,\n\tHI655X_LDO19,\n\tHI655X_LDO20,\n\tHI655X_LDO21,\n\tHI655X_LDO22,\n};\n\nstatic int hi655x_is_enabled(struct regulator_dev *rdev)\n{\n\tunsigned int value = 0;\n\tconst struct hi655x_regulator *regulator = rdev_get_drvdata(rdev);\n\n\tregmap_read(rdev->regmap, regulator->status_reg, &value);\n\treturn (value & rdev->desc->enable_mask);\n}\n\nstatic int hi655x_disable(struct regulator_dev *rdev)\n{\n\tconst struct hi655x_regulator *regulator = rdev_get_drvdata(rdev);\n\n\treturn regmap_write(rdev->regmap, regulator->disable_reg,\n\t\t\t    rdev->desc->enable_mask);\n}\n\nstatic const struct regulator_ops hi655x_regulator_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = hi655x_disable,\n\t.is_enabled = hi655x_is_enabled,\n\t.list_voltage = regulator_list_voltage_table,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n};\n\nstatic const struct regulator_ops hi655x_ldo_linear_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = hi655x_disable,\n\t.is_enabled = hi655x_is_enabled,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n};\n\n#define HI655X_LDO(_ID, vreg, vmask, ereg, dreg,                 \\\n\t\t   sreg, cmask, vtable) {                        \\\n\t.rdesc = {                                               \\\n\t\t.name            = #_ID,                         \\\n\t\t.of_match        = of_match_ptr(#_ID),           \\\n\t\t.ops             = &hi655x_regulator_ops,        \\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),   \\\n\t\t.type            = REGULATOR_VOLTAGE,            \\\n\t\t.id              = HI655X_##_ID,                 \\\n\t\t.owner           = THIS_MODULE,                  \\\n\t\t.n_voltages      = ARRAY_SIZE(vtable),           \\\n\t\t.volt_table      = vtable,                       \\\n\t\t.vsel_reg        = HI655X_BUS_ADDR(vreg),        \\\n\t\t.vsel_mask       = vmask,                        \\\n\t\t.enable_reg      = HI655X_BUS_ADDR(ereg),        \\\n\t\t.enable_mask     = BIT(cmask),                   \\\n\t},                                                       \\\n\t.disable_reg = HI655X_BUS_ADDR(dreg),                    \\\n\t.status_reg = HI655X_BUS_ADDR(sreg),                     \\\n}\n\n#define HI655X_LDO_LINEAR(_ID, vreg, vmask, ereg, dreg,          \\\n\t\t\t  sreg, cmask, minv, nvolt, vstep) {     \\\n\t.rdesc = {                                               \\\n\t\t.name            = #_ID,                         \\\n\t\t.of_match        = of_match_ptr(#_ID),           \\\n\t\t.ops             = &hi655x_ldo_linear_ops,       \\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),   \\\n\t\t.type            = REGULATOR_VOLTAGE,            \\\n\t\t.id              = HI655X_##_ID,                 \\\n\t\t.owner           = THIS_MODULE,                  \\\n\t\t.min_uV          = minv,                         \\\n\t\t.n_voltages      = nvolt,                        \\\n\t\t.uV_step         = vstep,                        \\\n\t\t.vsel_reg        = HI655X_BUS_ADDR(vreg),        \\\n\t\t.vsel_mask       = vmask,                        \\\n\t\t.enable_reg      = HI655X_BUS_ADDR(ereg),        \\\n\t\t.enable_mask     = BIT(cmask),                   \\\n\t},                                                       \\\n\t.disable_reg = HI655X_BUS_ADDR(dreg),                    \\\n\t.status_reg = HI655X_BUS_ADDR(sreg),                     \\\n}\n\nstatic const struct hi655x_regulator regulators[] = {\n\tHI655X_LDO_LINEAR(LDO2, 0x72, 0x07, 0x29, 0x2a, 0x2b, 0x01,\n\t\t\t  2500000, 8, 100000),\n\tHI655X_LDO(LDO7, 0x78, 0x07, 0x29, 0x2a, 0x2b, 0x06, ldo7_voltages),\n\tHI655X_LDO(LDO10, 0x78, 0x07, 0x29, 0x2a, 0x2b, 0x01, ldo7_voltages),\n\tHI655X_LDO_LINEAR(LDO13, 0x7e, 0x07, 0x2c, 0x2d, 0x2e, 0x04,\n\t\t\t  1600000, 8, 50000),\n\tHI655X_LDO_LINEAR(LDO14, 0x7f, 0x07, 0x2c, 0x2d, 0x2e, 0x05,\n\t\t\t  2500000, 8, 100000),\n\tHI655X_LDO_LINEAR(LDO15, 0x80, 0x07, 0x2c, 0x2d, 0x2e, 0x06,\n\t\t\t  1600000, 8, 50000),\n\tHI655X_LDO_LINEAR(LDO17, 0x82, 0x07, 0x2f, 0x30, 0x31, 0x00,\n\t\t\t  2500000, 8, 100000),\n\tHI655X_LDO(LDO19, 0x84, 0x07, 0x2f, 0x30, 0x31, 0x02, ldo19_voltages),\n\tHI655X_LDO_LINEAR(LDO21, 0x86, 0x07, 0x2f, 0x30, 0x31, 0x04,\n\t\t\t  1650000, 8, 50000),\n\tHI655X_LDO(LDO22, 0x87, 0x07, 0x2f, 0x30, 0x31, 0x05, ldo22_voltages),\n};\n\nstatic int hi655x_regulator_probe(struct platform_device *pdev)\n{\n\tunsigned int i;\n\tstruct hi655x_pmic *pmic;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\n\tpmic = dev_get_drvdata(pdev->dev.parent);\n\tif (!pmic) {\n\t\tdev_err(&pdev->dev, \"no pmic in the regulator parent node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tconfig.dev = pdev->dev.parent;\n\tconfig.regmap = pmic->regmap;\n\tfor (i = 0; i < ARRAY_SIZE(regulators); i++) {\n\t\tconfig.driver_data = (void *) &regulators[i];\n\n\t\trdev = devm_regulator_register(&pdev->dev,\n\t\t\t\t\t       &regulators[i].rdesc,\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&pdev->dev, \"failed to register regulator %s\\n\",\n\t\t\t\tregulators[i].rdesc.name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct platform_device_id hi655x_regulator_table[] = {\n\t{ .name = \"hi655x-regulator\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, hi655x_regulator_table);\n\nstatic struct platform_driver hi655x_regulator_driver = {\n\t.id_table = hi655x_regulator_table,\n\t.driver = {\n\t\t.name\t= \"hi655x-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t= hi655x_regulator_probe,\n};\nmodule_platform_driver(hi655x_regulator_driver);\n\nMODULE_AUTHOR(\"Chen Feng <puck.chen@hisilicon.com>\");\nMODULE_DESCRIPTION(\"Hisilicon Hi655x regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}