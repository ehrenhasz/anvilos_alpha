{
  "module_name": "tps6507x-regulator.c",
  "hash_id": "80868e7eb23d5465aee8c80feccb0101e67972f2bc931f3a580f1690a7c8bef3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/tps6507x-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/tps6507x.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/mfd/tps6507x.h>\n#include <linux/regulator/of_regulator.h>\n\n \n#define TPS6507X_DCDC_1\t\t\t\t0\n#define TPS6507X_DCDC_2\t\t\t\t1\n#define TPS6507X_DCDC_3\t\t\t\t2\n \n#define TPS6507X_LDO_1\t\t\t\t3\n#define TPS6507X_LDO_2\t\t\t\t4\n\n#define TPS6507X_MAX_REG_ID\t\t\tTPS6507X_LDO_2\n\n \n#define TPS6507X_NUM_DCDC\t\t\t3\n \n#define TPS6507X_NUM_LDO\t\t\t2\n \n#define TPS6507X_NUM_REGULATOR\t\t(TPS6507X_NUM_DCDC + TPS6507X_NUM_LDO)\n\n \nstatic const unsigned int VDCDCx_VSEL_table[] = {\n\t725000, 750000, 775000, 800000,\n\t825000, 850000, 875000, 900000,\n\t925000, 950000, 975000, 1000000,\n\t1025000, 1050000, 1075000, 1100000,\n\t1125000, 1150000, 1175000, 1200000,\n\t1225000, 1250000, 1275000, 1300000,\n\t1325000, 1350000, 1375000, 1400000,\n\t1425000, 1450000, 1475000, 1500000,\n\t1550000, 1600000, 1650000, 1700000,\n\t1750000, 1800000, 1850000, 1900000,\n\t1950000, 2000000, 2050000, 2100000,\n\t2150000, 2200000, 2250000, 2300000,\n\t2350000, 2400000, 2450000, 2500000,\n\t2550000, 2600000, 2650000, 2700000,\n\t2750000, 2800000, 2850000, 2900000,\n\t3000000, 3100000, 3200000, 3300000,\n};\n\nstatic const unsigned int LDO1_VSEL_table[] = {\n\t1000000, 1100000, 1200000, 1250000,\n\t1300000, 1350000, 1400000, 1500000,\n\t1600000, 1800000, 2500000, 2750000,\n\t2800000, 3000000, 3100000, 3300000,\n};\n\n \n#define LDO2_VSEL_table VDCDCx_VSEL_table\n\nstruct tps_info {\n\tconst char *name;\n\tu8 table_len;\n\tconst unsigned int *table;\n\n\t \n\tbool defdcdc_default;\n};\n\nstatic struct tps_info tps6507x_pmic_regs[] = {\n\t{\n\t\t.name = \"VDCDC1\",\n\t\t.table_len = ARRAY_SIZE(VDCDCx_VSEL_table),\n\t\t.table = VDCDCx_VSEL_table,\n\t},\n\t{\n\t\t.name = \"VDCDC2\",\n\t\t.table_len = ARRAY_SIZE(VDCDCx_VSEL_table),\n\t\t.table = VDCDCx_VSEL_table,\n\t},\n\t{\n\t\t.name = \"VDCDC3\",\n\t\t.table_len = ARRAY_SIZE(VDCDCx_VSEL_table),\n\t\t.table = VDCDCx_VSEL_table,\n\t},\n\t{\n\t\t.name = \"LDO1\",\n\t\t.table_len = ARRAY_SIZE(LDO1_VSEL_table),\n\t\t.table = LDO1_VSEL_table,\n\t},\n\t{\n\t\t.name = \"LDO2\",\n\t\t.table_len = ARRAY_SIZE(LDO2_VSEL_table),\n\t\t.table = LDO2_VSEL_table,\n\t},\n};\n\nstruct tps6507x_pmic {\n\tstruct regulator_desc desc[TPS6507X_NUM_REGULATOR];\n\tstruct tps6507x_dev *mfd;\n\tstruct tps_info *info[TPS6507X_NUM_REGULATOR];\n\tstruct mutex io_lock;\n};\nstatic inline int tps6507x_pmic_read(struct tps6507x_pmic *tps, u8 reg)\n{\n\tu8 val;\n\tint err;\n\n\terr = tps->mfd->read_dev(tps->mfd, reg, 1, &val);\n\n\tif (err)\n\t\treturn err;\n\n\treturn val;\n}\n\nstatic inline int tps6507x_pmic_write(struct tps6507x_pmic *tps, u8 reg, u8 val)\n{\n\treturn tps->mfd->write_dev(tps->mfd, reg, 1, &val);\n}\n\nstatic int tps6507x_pmic_set_bits(struct tps6507x_pmic *tps, u8 reg, u8 mask)\n{\n\tint err, data;\n\n\tmutex_lock(&tps->io_lock);\n\n\tdata = tps6507x_pmic_read(tps, reg);\n\tif (data < 0) {\n\t\tdev_err(tps->mfd->dev, \"Read from reg 0x%x failed\\n\", reg);\n\t\terr = data;\n\t\tgoto out;\n\t}\n\n\tdata |= mask;\n\terr = tps6507x_pmic_write(tps, reg, data);\n\tif (err)\n\t\tdev_err(tps->mfd->dev, \"Write for reg 0x%x failed\\n\", reg);\n\nout:\n\tmutex_unlock(&tps->io_lock);\n\treturn err;\n}\n\nstatic int tps6507x_pmic_clear_bits(struct tps6507x_pmic *tps, u8 reg, u8 mask)\n{\n\tint err, data;\n\n\tmutex_lock(&tps->io_lock);\n\n\tdata = tps6507x_pmic_read(tps, reg);\n\tif (data < 0) {\n\t\tdev_err(tps->mfd->dev, \"Read from reg 0x%x failed\\n\", reg);\n\t\terr = data;\n\t\tgoto out;\n\t}\n\n\tdata &= ~mask;\n\terr = tps6507x_pmic_write(tps, reg, data);\n\tif (err)\n\t\tdev_err(tps->mfd->dev, \"Write for reg 0x%x failed\\n\", reg);\n\nout:\n\tmutex_unlock(&tps->io_lock);\n\treturn err;\n}\n\nstatic int tps6507x_pmic_reg_read(struct tps6507x_pmic *tps, u8 reg)\n{\n\tint data;\n\n\tmutex_lock(&tps->io_lock);\n\n\tdata = tps6507x_pmic_read(tps, reg);\n\tif (data < 0)\n\t\tdev_err(tps->mfd->dev, \"Read from reg 0x%x failed\\n\", reg);\n\n\tmutex_unlock(&tps->io_lock);\n\treturn data;\n}\n\nstatic int tps6507x_pmic_reg_write(struct tps6507x_pmic *tps, u8 reg, u8 val)\n{\n\tint err;\n\n\tmutex_lock(&tps->io_lock);\n\n\terr = tps6507x_pmic_write(tps, reg, val);\n\tif (err < 0)\n\t\tdev_err(tps->mfd->dev, \"Write for reg 0x%x failed\\n\", reg);\n\n\tmutex_unlock(&tps->io_lock);\n\treturn err;\n}\n\nstatic int tps6507x_pmic_is_enabled(struct regulator_dev *dev)\n{\n\tstruct tps6507x_pmic *tps = rdev_get_drvdata(dev);\n\tint data, rid = rdev_get_id(dev);\n\tu8 shift;\n\n\tif (rid < TPS6507X_DCDC_1 || rid > TPS6507X_LDO_2)\n\t\treturn -EINVAL;\n\n\tshift = TPS6507X_MAX_REG_ID - rid;\n\tdata = tps6507x_pmic_reg_read(tps, TPS6507X_REG_CON_CTRL1);\n\n\tif (data < 0)\n\t\treturn data;\n\telse\n\t\treturn (data & 1<<shift) ? 1 : 0;\n}\n\nstatic int tps6507x_pmic_enable(struct regulator_dev *dev)\n{\n\tstruct tps6507x_pmic *tps = rdev_get_drvdata(dev);\n\tint rid = rdev_get_id(dev);\n\tu8 shift;\n\n\tif (rid < TPS6507X_DCDC_1 || rid > TPS6507X_LDO_2)\n\t\treturn -EINVAL;\n\n\tshift = TPS6507X_MAX_REG_ID - rid;\n\treturn tps6507x_pmic_set_bits(tps, TPS6507X_REG_CON_CTRL1, 1 << shift);\n}\n\nstatic int tps6507x_pmic_disable(struct regulator_dev *dev)\n{\n\tstruct tps6507x_pmic *tps = rdev_get_drvdata(dev);\n\tint rid = rdev_get_id(dev);\n\tu8 shift;\n\n\tif (rid < TPS6507X_DCDC_1 || rid > TPS6507X_LDO_2)\n\t\treturn -EINVAL;\n\n\tshift = TPS6507X_MAX_REG_ID - rid;\n\treturn tps6507x_pmic_clear_bits(tps, TPS6507X_REG_CON_CTRL1,\n\t\t\t\t\t1 << shift);\n}\n\nstatic int tps6507x_pmic_get_voltage_sel(struct regulator_dev *dev)\n{\n\tstruct tps6507x_pmic *tps = rdev_get_drvdata(dev);\n\tint data, rid = rdev_get_id(dev);\n\tu8 reg, mask;\n\n\tswitch (rid) {\n\tcase TPS6507X_DCDC_1:\n\t\treg = TPS6507X_REG_DEFDCDC1;\n\t\tmask = TPS6507X_DEFDCDCX_DCDC_MASK;\n\t\tbreak;\n\tcase TPS6507X_DCDC_2:\n\t\tif (tps->info[rid]->defdcdc_default)\n\t\t\treg = TPS6507X_REG_DEFDCDC2_HIGH;\n\t\telse\n\t\t\treg = TPS6507X_REG_DEFDCDC2_LOW;\n\t\tmask = TPS6507X_DEFDCDCX_DCDC_MASK;\n\t\tbreak;\n\tcase TPS6507X_DCDC_3:\n\t\tif (tps->info[rid]->defdcdc_default)\n\t\t\treg = TPS6507X_REG_DEFDCDC3_HIGH;\n\t\telse\n\t\t\treg = TPS6507X_REG_DEFDCDC3_LOW;\n\t\tmask = TPS6507X_DEFDCDCX_DCDC_MASK;\n\t\tbreak;\n\tcase TPS6507X_LDO_1:\n\t\treg = TPS6507X_REG_LDO_CTRL1;\n\t\tmask = TPS6507X_REG_LDO_CTRL1_LDO1_MASK;\n\t\tbreak;\n\tcase TPS6507X_LDO_2:\n\t\treg = TPS6507X_REG_DEFLDO2;\n\t\tmask = TPS6507X_REG_DEFLDO2_LDO2_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdata = tps6507x_pmic_reg_read(tps, reg);\n\tif (data < 0)\n\t\treturn data;\n\n\tdata &= mask;\n\treturn data;\n}\n\nstatic int tps6507x_pmic_set_voltage_sel(struct regulator_dev *dev,\n\t\t\t\t\t  unsigned selector)\n{\n\tstruct tps6507x_pmic *tps = rdev_get_drvdata(dev);\n\tint data, rid = rdev_get_id(dev);\n\tu8 reg, mask;\n\n\tswitch (rid) {\n\tcase TPS6507X_DCDC_1:\n\t\treg = TPS6507X_REG_DEFDCDC1;\n\t\tmask = TPS6507X_DEFDCDCX_DCDC_MASK;\n\t\tbreak;\n\tcase TPS6507X_DCDC_2:\n\t\tif (tps->info[rid]->defdcdc_default)\n\t\t\treg = TPS6507X_REG_DEFDCDC2_HIGH;\n\t\telse\n\t\t\treg = TPS6507X_REG_DEFDCDC2_LOW;\n\t\tmask = TPS6507X_DEFDCDCX_DCDC_MASK;\n\t\tbreak;\n\tcase TPS6507X_DCDC_3:\n\t\tif (tps->info[rid]->defdcdc_default)\n\t\t\treg = TPS6507X_REG_DEFDCDC3_HIGH;\n\t\telse\n\t\t\treg = TPS6507X_REG_DEFDCDC3_LOW;\n\t\tmask = TPS6507X_DEFDCDCX_DCDC_MASK;\n\t\tbreak;\n\tcase TPS6507X_LDO_1:\n\t\treg = TPS6507X_REG_LDO_CTRL1;\n\t\tmask = TPS6507X_REG_LDO_CTRL1_LDO1_MASK;\n\t\tbreak;\n\tcase TPS6507X_LDO_2:\n\t\treg = TPS6507X_REG_DEFLDO2;\n\t\tmask = TPS6507X_REG_DEFLDO2_LDO2_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdata = tps6507x_pmic_reg_read(tps, reg);\n\tif (data < 0)\n\t\treturn data;\n\n\tdata &= ~mask;\n\tdata |= selector;\n\n\treturn tps6507x_pmic_reg_write(tps, reg, data);\n}\n\nstatic const struct regulator_ops tps6507x_pmic_ops = {\n\t.is_enabled = tps6507x_pmic_is_enabled,\n\t.enable = tps6507x_pmic_enable,\n\t.disable = tps6507x_pmic_disable,\n\t.get_voltage_sel = tps6507x_pmic_get_voltage_sel,\n\t.set_voltage_sel = tps6507x_pmic_set_voltage_sel,\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n};\n\nstatic int tps6507x_pmic_of_parse_cb(struct device_node *np,\n\t\t\t\t     const struct regulator_desc *desc,\n\t\t\t\t     struct regulator_config *config)\n{\n\tstruct tps6507x_pmic *tps = config->driver_data;\n\tstruct tps_info *info = tps->info[desc->id];\n\tu32 prop;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"ti,defdcdc_default\", &prop);\n\tif (!ret)\n\t\tinfo->defdcdc_default = prop;\n\n\treturn 0;\n}\n\nstatic int tps6507x_pmic_probe(struct platform_device *pdev)\n{\n\tstruct tps6507x_dev *tps6507x_dev = dev_get_drvdata(pdev->dev.parent);\n\tstruct tps_info *info = &tps6507x_pmic_regs[0];\n\tstruct regulator_config config = { };\n\tstruct regulator_init_data *init_data = NULL;\n\tstruct regulator_dev *rdev;\n\tstruct tps6507x_pmic *tps;\n\tstruct tps6507x_board *tps_board;\n\tint i;\n\n\t \n\n\ttps_board = dev_get_platdata(tps6507x_dev->dev);\n\tif (tps_board)\n\t\tinit_data = tps_board->tps6507x_pmic_init_data;\n\n\ttps = devm_kzalloc(&pdev->dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&tps->io_lock);\n\n\t \n\ttps->mfd = tps6507x_dev;\n\n\tfor (i = 0; i < TPS6507X_NUM_REGULATOR; i++, info++) {\n\t\t \n\t\ttps->info[i] = info;\n\t\tif (init_data && init_data[i].driver_data) {\n\t\t\tstruct tps6507x_reg_platform_data *data =\n\t\t\t\t\tinit_data[i].driver_data;\n\t\t\tinfo->defdcdc_default = data->defdcdc_default;\n\t\t}\n\n\t\ttps->desc[i].name = info->name;\n\t\ttps->desc[i].of_match = of_match_ptr(info->name);\n\t\ttps->desc[i].regulators_node = of_match_ptr(\"regulators\");\n\t\ttps->desc[i].of_parse_cb = tps6507x_pmic_of_parse_cb;\n\t\ttps->desc[i].id = i;\n\t\ttps->desc[i].n_voltages = info->table_len;\n\t\ttps->desc[i].volt_table = info->table;\n\t\ttps->desc[i].ops = &tps6507x_pmic_ops;\n\t\ttps->desc[i].type = REGULATOR_VOLTAGE;\n\t\ttps->desc[i].owner = THIS_MODULE;\n\n\t\tconfig.dev = tps6507x_dev->dev;\n\t\tconfig.init_data = init_data;\n\t\tconfig.driver_data = tps;\n\n\t\trdev = devm_regulator_register(&pdev->dev, &tps->desc[i],\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(tps6507x_dev->dev,\n\t\t\t\t\"failed to register %s regulator\\n\",\n\t\t\t\tpdev->name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\ttps6507x_dev->pmic = tps;\n\tplatform_set_drvdata(pdev, tps6507x_dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver tps6507x_pmic_driver = {\n\t.driver = {\n\t\t.name = \"tps6507x-pmic\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = tps6507x_pmic_probe,\n};\n\nstatic int __init tps6507x_pmic_init(void)\n{\n\treturn platform_driver_register(&tps6507x_pmic_driver);\n}\nsubsys_initcall(tps6507x_pmic_init);\n\nstatic void __exit tps6507x_pmic_cleanup(void)\n{\n\tplatform_driver_unregister(&tps6507x_pmic_driver);\n}\nmodule_exit(tps6507x_pmic_cleanup);\n\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_DESCRIPTION(\"TPS6507x voltage regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:tps6507x-pmic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}