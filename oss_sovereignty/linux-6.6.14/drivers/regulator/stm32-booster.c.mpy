{
  "module_name": "stm32-booster.c",
  "hash_id": "9bd00655c38a8459c0141cd39924a97504c8db99ce62ae9b628372802579d679",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/stm32-booster.c",
  "human_readable_source": "\n\n\n\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n \n#define STM32H7_SYSCFG_PMCR\t\t0x04\n#define STM32H7_SYSCFG_BOOSTE_MASK\tBIT(8)\n\n \n#define STM32MP1_SYSCFG_PMCSETR\t\t0x04\n#define STM32MP1_SYSCFG_PMCCLRR\t\t0x44\n#define STM32MP1_SYSCFG_EN_BOOSTER_MASK\tBIT(8)\n\nstatic const struct regulator_ops stm32h7_booster_ops = {\n\t.enable\t\t= regulator_enable_regmap,\n\t.disable\t= regulator_disable_regmap,\n\t.is_enabled\t= regulator_is_enabled_regmap,\n};\n\nstatic const struct regulator_desc stm32h7_booster_desc = {\n\t.name = \"booster\",\n\t.supply_name = \"vdda\",\n\t.n_voltages = 1,\n\t.type = REGULATOR_VOLTAGE,\n\t.fixed_uV = 3300000,\n\t.ramp_delay = 66000,  \n\t.ops = &stm32h7_booster_ops,\n\t.enable_reg = STM32H7_SYSCFG_PMCR,\n\t.enable_mask = STM32H7_SYSCFG_BOOSTE_MASK,\n\t.owner = THIS_MODULE,\n};\n\nstatic int stm32mp1_booster_enable(struct regulator_dev *rdev)\n{\n\treturn regmap_write(rdev->regmap, STM32MP1_SYSCFG_PMCSETR,\n\t\t\t    STM32MP1_SYSCFG_EN_BOOSTER_MASK);\n}\n\nstatic int stm32mp1_booster_disable(struct regulator_dev *rdev)\n{\n\treturn regmap_write(rdev->regmap, STM32MP1_SYSCFG_PMCCLRR,\n\t\t\t    STM32MP1_SYSCFG_EN_BOOSTER_MASK);\n}\n\nstatic const struct regulator_ops stm32mp1_booster_ops = {\n\t.enable\t\t= stm32mp1_booster_enable,\n\t.disable\t= stm32mp1_booster_disable,\n\t.is_enabled\t= regulator_is_enabled_regmap,\n};\n\nstatic const struct regulator_desc stm32mp1_booster_desc = {\n\t.name = \"booster\",\n\t.supply_name = \"vdda\",\n\t.n_voltages = 1,\n\t.type = REGULATOR_VOLTAGE,\n\t.fixed_uV = 3300000,\n\t.ramp_delay = 66000,\n\t.ops = &stm32mp1_booster_ops,\n\t.enable_reg = STM32MP1_SYSCFG_PMCSETR,\n\t.enable_mask = STM32MP1_SYSCFG_EN_BOOSTER_MASK,\n\t.owner = THIS_MODULE,\n};\n\nstatic int stm32_booster_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct regulator_config config = { };\n\tconst struct regulator_desc *desc;\n\tstruct regulator_dev *rdev;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tregmap = syscon_regmap_lookup_by_phandle(np, \"st,syscfg\");\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tdesc = (const struct regulator_desc *)\n\t\tof_match_device(dev->driver->of_match_table, dev)->data;\n\n\tconfig.regmap = regmap;\n\tconfig.dev = dev;\n\tconfig.of_node = np;\n\tconfig.init_data = of_get_regulator_init_data(dev, np, desc);\n\n\trdev = devm_regulator_register(dev, desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\t\tdev_err(dev, \"register failed with error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused stm32_booster_of_match[] = {\n\t{\n\t\t.compatible = \"st,stm32h7-booster\",\n\t\t.data = (void *)&stm32h7_booster_desc\n\t}, {\n\t\t.compatible = \"st,stm32mp1-booster\",\n\t\t.data = (void *)&stm32mp1_booster_desc\n\t}, {\n\t},\n};\nMODULE_DEVICE_TABLE(of, stm32_booster_of_match);\n\nstatic struct platform_driver stm32_booster_driver = {\n\t.probe = stm32_booster_probe,\n\t.driver = {\n\t\t.name  = \"stm32-booster\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(stm32_booster_of_match),\n\t},\n};\nmodule_platform_driver(stm32_booster_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Fabrice Gasnier <fabrice.gasnier@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 booster regulator driver\");\nMODULE_ALIAS(\"platform:stm32-booster\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}