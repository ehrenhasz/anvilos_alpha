{
  "module_name": "tps6287x-regulator.c",
  "hash_id": "fc4651047833bbce3876870fb656eed2dd0f1baa5befa2e9298d91da1fe896c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/tps6287x-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/driver.h>\n#include <linux/bitfield.h>\n#include <linux/linear_range.h>\n\n#define TPS6287X_VSET\t\t0x00\n#define TPS6287X_CTRL1\t\t0x01\n#define TPS6287X_CTRL1_VRAMP\tGENMASK(1, 0)\n#define TPS6287X_CTRL1_FPWMEN\tBIT(4)\n#define TPS6287X_CTRL1_SWEN\tBIT(5)\n#define TPS6287X_CTRL2\t\t0x02\n#define TPS6287X_CTRL2_VRANGE\tGENMASK(3, 2)\n#define TPS6287X_CTRL3\t\t0x03\n#define TPS6287X_STATUS\t\t0x04\n\nstatic const struct regmap_config tps6287x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = TPS6287X_STATUS,\n};\n\nstatic const struct linear_range tps6287x_voltage_ranges[] = {\n\tLINEAR_RANGE(400000, 0, 0xFF, 1250),\n\tLINEAR_RANGE(400000, 0, 0xFF, 2500),\n\tLINEAR_RANGE(400000, 0, 0xFF, 5000),\n\tLINEAR_RANGE(800000, 0, 0xFF, 10000),\n};\n\nstatic const unsigned int tps6287x_voltage_range_sel[] = {\n\t0x0, 0x1, 0x2, 0x3\n};\n\nstatic const unsigned int tps6287x_ramp_table[] = {\n\t10000, 5000, 1250, 500\n};\n\nstatic int tps6287x_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tunsigned int val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = 0;\n\t\tbreak;\n\tcase REGULATOR_MODE_FAST:\n\t\tval = TPS6287X_CTRL1_FPWMEN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(rdev->regmap, TPS6287X_CTRL1,\n\t\t\t\t  TPS6287X_CTRL1_FPWMEN, val);\n}\n\nstatic unsigned int tps6287x_get_mode(struct regulator_dev *rdev)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(rdev->regmap, TPS6287X_CTRL1, &val);\n\tif (ret < 0)\n\t\treturn 0;\n\n\treturn (val & TPS6287X_CTRL1_FPWMEN) ? REGULATOR_MODE_FAST :\n\t    REGULATOR_MODE_NORMAL;\n}\n\nstatic unsigned int tps6287x_of_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\tcase REGULATOR_MODE_FAST:\n\t\treturn mode;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic const struct regulator_ops tps6287x_regulator_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.set_mode = tps6287x_set_mode,\n\t.get_mode = tps6287x_get_mode,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_pickable_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_pickable_regmap,\n\t.list_voltage = regulator_list_voltage_pickable_linear_range,\n\t.set_ramp_delay = regulator_set_ramp_delay_regmap,\n};\n\nstatic struct regulator_desc tps6287x_reg = {\n\t.name = \"tps6287x\",\n\t.owner = THIS_MODULE,\n\t.ops = &tps6287x_regulator_ops,\n\t.of_map_mode = tps6287x_of_map_mode,\n\t.type = REGULATOR_VOLTAGE,\n\t.enable_reg = TPS6287X_CTRL1,\n\t.enable_mask = TPS6287X_CTRL1_SWEN,\n\t.vsel_reg = TPS6287X_VSET,\n\t.vsel_mask = 0xFF,\n\t.vsel_range_reg = TPS6287X_CTRL2,\n\t.vsel_range_mask = TPS6287X_CTRL2_VRANGE,\n\t.ramp_reg = TPS6287X_CTRL1,\n\t.ramp_mask = TPS6287X_CTRL1_VRAMP,\n\t.ramp_delay_table = tps6287x_ramp_table,\n\t.n_ramp_values = ARRAY_SIZE(tps6287x_ramp_table),\n\t.n_voltages = 256 * ARRAY_SIZE(tps6287x_voltage_ranges),\n\t.linear_ranges = tps6287x_voltage_ranges,\n\t.n_linear_ranges = ARRAY_SIZE(tps6287x_voltage_ranges),\n\t.linear_range_selectors_bitfield = tps6287x_voltage_range_sel,\n};\n\nstatic int tps6287x_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct regulator_config config = {};\n\tstruct regulator_dev *rdev;\n\n\tconfig.regmap = devm_regmap_init_i2c(i2c, &tps6287x_regmap_config);\n\tif (IS_ERR(config.regmap)) {\n\t\tdev_err(dev, \"Failed to init i2c\\n\");\n\t\treturn PTR_ERR(config.regmap);\n\t}\n\n\tconfig.dev = dev;\n\tconfig.of_node = dev->of_node;\n\tconfig.init_data = of_get_regulator_init_data(dev, dev->of_node,\n\t\t\t\t\t\t      &tps6287x_reg);\n\n\trdev = devm_regulator_register(dev, &tps6287x_reg, &config);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(dev, \"Failed to register regulator\\n\");\n\t\treturn PTR_ERR(rdev);\n\t}\n\n\tdev_dbg(dev, \"Probed regulator\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tps6287x_dt_ids[] = {\n\t{ .compatible = \"ti,tps62870\", },\n\t{ .compatible = \"ti,tps62871\", },\n\t{ .compatible = \"ti,tps62872\", },\n\t{ .compatible = \"ti,tps62873\", },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, tps6287x_dt_ids);\n\nstatic const struct i2c_device_id tps6287x_i2c_id[] = {\n\t{ \"tps62870\", 0 },\n\t{ \"tps62871\", 0 },\n\t{ \"tps62872\", 0 },\n\t{ \"tps62873\", 0 },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, tps6287x_i2c_id);\n\nstatic struct i2c_driver tps6287x_regulator_driver = {\n\t.driver = {\n\t\t.name = \"tps6287x\",\n\t\t.of_match_table = tps6287x_dt_ids,\n\t},\n\t.probe = tps6287x_i2c_probe,\n\t.id_table = tps6287x_i2c_id,\n};\n\nmodule_i2c_driver(tps6287x_regulator_driver);\n\nMODULE_AUTHOR(\"M\u00e5rten Lindahl <marten.lindahl@axis.com>\");\nMODULE_DESCRIPTION(\"Regulator driver for TI TPS6287X PMIC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}