{
  "module_name": "lp8755.c",
  "hash_id": "ca90c612f0335c7c30c2bd30ea0179d122b77e8688243b1fca548a43256df511",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/lp8755.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/regmap.h>\n#include <linux/uaccess.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/platform_data/lp8755.h>\n\n#define LP8755_REG_BUCK0\t0x00\n#define LP8755_REG_BUCK1\t0x03\n#define LP8755_REG_BUCK2\t0x04\n#define LP8755_REG_BUCK3\t0x01\n#define LP8755_REG_BUCK4\t0x05\n#define LP8755_REG_BUCK5\t0x02\n#define LP8755_REG_MAX\t\t0xFF\n\n#define LP8755_BUCK_EN_M\tBIT(7)\n#define LP8755_BUCK_LINEAR_OUT_MAX\t0x76\n#define LP8755_BUCK_VOUT_M\t0x7F\n\nstruct lp8755_mphase {\n\tint nreg;\n\tint buck_num[LP8755_BUCK_MAX];\n};\n\nstruct lp8755_chip {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct lp8755_platform_data *pdata;\n\n\tint irq;\n\tunsigned int irqmask;\n\n\tint mphase;\n\tstruct regulator_dev *rdev[LP8755_BUCK_MAX];\n};\n\nstatic int lp8755_buck_enable_time(struct regulator_dev *rdev)\n{\n\tint ret;\n\tunsigned int regval;\n\tenum lp8755_bucks id = rdev_get_id(rdev);\n\n\tret = regmap_read(rdev->regmap, 0x12 + id, &regval);\n\tif (ret < 0) {\n\t\tdev_err(&rdev->dev, \"i2c access error %s\\n\", __func__);\n\t\treturn ret;\n\t}\n\treturn (regval & 0xff) * 100;\n}\n\nstatic int lp8755_buck_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tint ret;\n\tunsigned int regbval = 0x0;\n\tenum lp8755_bucks id = rdev_get_id(rdev);\n\tstruct lp8755_chip *pchip = rdev_get_drvdata(rdev);\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\t \n\t\tregbval = (0x01 << id);\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\t \n\t\tret = regmap_update_bits(rdev->regmap, 0x08 + id, 0x20, 0x00);\n\t\tif (ret < 0)\n\t\t\tgoto err_i2c;\n\t\tbreak;\n\tcase REGULATOR_MODE_IDLE:\n\t\t \n\t\tret = regmap_update_bits(rdev->regmap, 0x08 + id, 0x20, 0x20);\n\t\tif (ret < 0)\n\t\t\tgoto err_i2c;\n\n\t\tret = regmap_update_bits(rdev->regmap, 0x10, 0x01, 0x01);\n\t\tif (ret < 0)\n\t\t\tgoto err_i2c;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pchip->dev, \"Not supported buck mode %s\\n\", __func__);\n\t\t \n\t\tregbval = (0x01 << id);\n\t}\n\n\tret = regmap_update_bits(rdev->regmap, 0x06, 0x01 << id, regbval);\n\tif (ret < 0)\n\t\tgoto err_i2c;\n\treturn ret;\nerr_i2c:\n\tdev_err(&rdev->dev, \"i2c access error %s\\n\", __func__);\n\treturn ret;\n}\n\nstatic unsigned int lp8755_buck_get_mode(struct regulator_dev *rdev)\n{\n\tint ret;\n\tunsigned int regval;\n\tenum lp8755_bucks id = rdev_get_id(rdev);\n\n\tret = regmap_read(rdev->regmap, 0x06, &regval);\n\tif (ret < 0)\n\t\tgoto err_i2c;\n\n\t \n\tif (regval & (0x01 << id))\n\t\treturn REGULATOR_MODE_FAST;\n\n\tret = regmap_read(rdev->regmap, 0x08 + id, &regval);\n\tif (ret < 0)\n\t\tgoto err_i2c;\n\n\t \n\tif (regval & 0x20)\n\t\treturn REGULATOR_MODE_IDLE;\n\n\t \n\treturn REGULATOR_MODE_NORMAL;\n\nerr_i2c:\n\tdev_err(&rdev->dev, \"i2c access error %s\\n\", __func__);\n\treturn 0;\n}\n\nstatic const unsigned int lp8755_buck_ramp_table[] = {\n\t30000, 15000, 7500, 3800, 1900, 940, 470, 230\n};\n\nstatic const struct regulator_ops lp8755_buck_ops = {\n\t.map_voltage = regulator_map_voltage_linear,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable_time = lp8755_buck_enable_time,\n\t.set_mode = lp8755_buck_set_mode,\n\t.get_mode = lp8755_buck_get_mode,\n\t.set_ramp_delay = regulator_set_ramp_delay_regmap,\n};\n\n#define lp8755_rail(_id) \"lp8755_buck\"#_id\n#define lp8755_buck_init(_id)\\\n{\\\n\t.constraints = {\\\n\t\t.name = lp8755_rail(_id),\\\n\t\t.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,\\\n\t\t.min_uV = 500000,\\\n\t\t.max_uV = 1675000,\\\n\t},\\\n}\n\nstatic struct regulator_init_data lp8755_reg_default[LP8755_BUCK_MAX] = {\n\t[LP8755_BUCK0] = lp8755_buck_init(0),\n\t[LP8755_BUCK1] = lp8755_buck_init(1),\n\t[LP8755_BUCK2] = lp8755_buck_init(2),\n\t[LP8755_BUCK3] = lp8755_buck_init(3),\n\t[LP8755_BUCK4] = lp8755_buck_init(4),\n\t[LP8755_BUCK5] = lp8755_buck_init(5),\n};\n\nstatic const struct lp8755_mphase mphase_buck[MPHASE_CONF_MAX] = {\n\t{ 3, { LP8755_BUCK0, LP8755_BUCK3, LP8755_BUCK5 } },\n\t{ 6, { LP8755_BUCK0, LP8755_BUCK1, LP8755_BUCK2, LP8755_BUCK3,\n\t       LP8755_BUCK4, LP8755_BUCK5 } },\n\t{ 5, { LP8755_BUCK0, LP8755_BUCK2, LP8755_BUCK3, LP8755_BUCK4,\n\t       LP8755_BUCK5} },\n\t{ 4, { LP8755_BUCK0, LP8755_BUCK3, LP8755_BUCK4, LP8755_BUCK5} },\n\t{ 3, { LP8755_BUCK0, LP8755_BUCK4, LP8755_BUCK5} },\n\t{ 2, { LP8755_BUCK0, LP8755_BUCK5} },\n\t{ 1, { LP8755_BUCK0} },\n\t{ 2, { LP8755_BUCK0, LP8755_BUCK3} },\n\t{ 4, { LP8755_BUCK0, LP8755_BUCK2, LP8755_BUCK3, LP8755_BUCK5} },\n};\n\nstatic int lp8755_init_data(struct lp8755_chip *pchip)\n{\n\tunsigned int regval;\n\tint ret, icnt, buck_num;\n\tstruct lp8755_platform_data *pdata = pchip->pdata;\n\n\t \n\tret = regmap_read(pchip->regmap, 0x3D, &regval);\n\tif (ret < 0)\n\t\tgoto out_i2c_error;\n\tpchip->mphase = regval & 0x0F;\n\n\t \n\tfor (icnt = 0; icnt < mphase_buck[pchip->mphase].nreg; icnt++) {\n\t\tbuck_num = mphase_buck[pchip->mphase].buck_num[icnt];\n\t\tpdata->buck_data[buck_num] = &lp8755_reg_default[buck_num];\n\t}\n\treturn ret;\n\nout_i2c_error:\n\tdev_err(pchip->dev, \"i2c access error %s\\n\", __func__);\n\treturn ret;\n}\n\n#define lp8755_buck_desc(_id)\\\n{\\\n\t.name = lp8755_rail(_id),\\\n\t.id   = LP8755_BUCK##_id,\\\n\t.ops  = &lp8755_buck_ops,\\\n\t.n_voltages = LP8755_BUCK_LINEAR_OUT_MAX+1,\\\n\t.uV_step = 10000,\\\n\t.min_uV = 500000,\\\n\t.type = REGULATOR_VOLTAGE,\\\n\t.owner = THIS_MODULE,\\\n\t.enable_reg = LP8755_REG_BUCK##_id,\\\n\t.enable_mask = LP8755_BUCK_EN_M,\\\n\t.vsel_reg = LP8755_REG_BUCK##_id,\\\n\t.vsel_mask = LP8755_BUCK_VOUT_M,\\\n\t.ramp_reg = (LP8755_BUCK##_id) + 0x7,\\\n\t.ramp_mask = 0x7,\\\n\t.ramp_delay_table = lp8755_buck_ramp_table,\\\n\t.n_ramp_values = ARRAY_SIZE(lp8755_buck_ramp_table),\\\n}\n\nstatic const struct regulator_desc lp8755_regulators[] = {\n\tlp8755_buck_desc(0),\n\tlp8755_buck_desc(1),\n\tlp8755_buck_desc(2),\n\tlp8755_buck_desc(3),\n\tlp8755_buck_desc(4),\n\tlp8755_buck_desc(5),\n};\n\nstatic int lp8755_regulator_init(struct lp8755_chip *pchip)\n{\n\tint ret, icnt, buck_num;\n\tstruct lp8755_platform_data *pdata = pchip->pdata;\n\tstruct regulator_config rconfig = { };\n\n\trconfig.regmap = pchip->regmap;\n\trconfig.dev = pchip->dev;\n\trconfig.driver_data = pchip;\n\n\tfor (icnt = 0; icnt < mphase_buck[pchip->mphase].nreg; icnt++) {\n\t\tbuck_num = mphase_buck[pchip->mphase].buck_num[icnt];\n\t\trconfig.init_data = pdata->buck_data[buck_num];\n\t\trconfig.of_node = pchip->dev->of_node;\n\t\tpchip->rdev[buck_num] =\n\t\t    devm_regulator_register(pchip->dev,\n\t\t\t\t    &lp8755_regulators[buck_num], &rconfig);\n\t\tif (IS_ERR(pchip->rdev[buck_num])) {\n\t\t\tret = PTR_ERR(pchip->rdev[buck_num]);\n\t\t\tpchip->rdev[buck_num] = NULL;\n\t\t\tdev_err(pchip->dev, \"regulator init failed: buck %d\\n\",\n\t\t\t\tbuck_num);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t lp8755_irq_handler(int irq, void *data)\n{\n\tint ret, icnt;\n\tunsigned int flag0, flag1;\n\tstruct lp8755_chip *pchip = data;\n\n\t \n\tret = regmap_read(pchip->regmap, 0x0D, &flag0);\n\tif (ret < 0)\n\t\tgoto err_i2c;\n\t \n\tret = regmap_write(pchip->regmap, 0x0D, 0x00);\n\tif (ret < 0)\n\t\tgoto err_i2c;\n\n\t \n\tfor (icnt = 0; icnt < LP8755_BUCK_MAX; icnt++)\n\t\tif ((flag0 & (0x4 << icnt))\n\t\t    && (pchip->irqmask & (0x04 << icnt))\n\t\t    && (pchip->rdev[icnt] != NULL)) {\n\t\t\tregulator_notifier_call_chain(pchip->rdev[icnt],\n\t\t\t\t\t\t      LP8755_EVENT_PWR_FAULT,\n\t\t\t\t\t\t      NULL);\n\t\t}\n\n\t \n\tret = regmap_read(pchip->regmap, 0x0E, &flag1);\n\tif (ret < 0)\n\t\tgoto err_i2c;\n\t \n\tret = regmap_write(pchip->regmap, 0x0E, 0x00);\n\tif (ret < 0)\n\t\tgoto err_i2c;\n\n\t \n\tif ((flag1 & 0x01) && (pchip->irqmask & 0x01))\n\t\tfor (icnt = 0; icnt < LP8755_BUCK_MAX; icnt++)\n\t\t\tif (pchip->rdev[icnt] != NULL) {\n\t\t\t\tregulator_notifier_call_chain(pchip->rdev[icnt],\n\t\t\t\t\t\t\t      LP8755_EVENT_OCP,\n\t\t\t\t\t\t\t      NULL);\n\t\t\t}\n\n\t \n\tif ((flag1 & 0x02) && (pchip->irqmask & 0x02))\n\t\tfor (icnt = 0; icnt < LP8755_BUCK_MAX; icnt++)\n\t\t\tif (pchip->rdev[icnt] != NULL) {\n\t\t\t\tregulator_notifier_call_chain(pchip->rdev[icnt],\n\t\t\t\t\t\t\t      LP8755_EVENT_OVP,\n\t\t\t\t\t\t\t      NULL);\n\t\t\t}\n\treturn IRQ_HANDLED;\n\nerr_i2c:\n\tdev_err(pchip->dev, \"i2c access error %s\\n\", __func__);\n\treturn IRQ_NONE;\n}\n\nstatic int lp8755_int_config(struct lp8755_chip *pchip)\n{\n\tint ret;\n\tunsigned int regval;\n\n\tif (pchip->irq == 0) {\n\t\tdev_warn(pchip->dev, \"not use interrupt : %s\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tret = regmap_read(pchip->regmap, 0x0F, &regval);\n\tif (ret < 0) {\n\t\tdev_err(pchip->dev, \"i2c access error %s\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tpchip->irqmask = regval;\n\treturn devm_request_threaded_irq(pchip->dev, pchip->irq, NULL,\n\t\t\t\t\t lp8755_irq_handler,\n\t\t\t\t\t IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t \"lp8755-irq\", pchip);\n}\n\nstatic const struct regmap_config lp8755_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = LP8755_REG_MAX,\n};\n\nstatic int lp8755_probe(struct i2c_client *client)\n{\n\tint ret, icnt;\n\tstruct lp8755_chip *pchip;\n\tstruct lp8755_platform_data *pdata = dev_get_platdata(&client->dev);\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"i2c functionality check fail.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpchip = devm_kzalloc(&client->dev,\n\t\t\t     sizeof(struct lp8755_chip), GFP_KERNEL);\n\tif (!pchip)\n\t\treturn -ENOMEM;\n\n\tpchip->dev = &client->dev;\n\tpchip->regmap = devm_regmap_init_i2c(client, &lp8755_regmap);\n\tif (IS_ERR(pchip->regmap)) {\n\t\tret = PTR_ERR(pchip->regmap);\n\t\tdev_err(&client->dev, \"fail to allocate regmap %d\\n\", ret);\n\t\treturn ret;\n\t}\n\ti2c_set_clientdata(client, pchip);\n\n\tif (pdata != NULL) {\n\t\tpchip->pdata = pdata;\n\t\tpchip->mphase = pdata->mphase;\n\t} else {\n\t\tpchip->pdata = devm_kzalloc(pchip->dev,\n\t\t\t\t\t    sizeof(struct lp8755_platform_data),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!pchip->pdata)\n\t\t\treturn -ENOMEM;\n\t\tret = lp8755_init_data(pchip);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev, \"fail to initialize chip\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = lp8755_regulator_init(pchip);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"fail to initialize regulators\\n\");\n\t\tgoto err;\n\t}\n\n\tpchip->irq = client->irq;\n\tret = lp8755_int_config(pchip);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"fail to irq config\\n\");\n\t\tgoto err;\n\t}\n\n\treturn ret;\n\nerr:\n\t \n\tfor (icnt = 0; icnt < LP8755_BUCK_MAX; icnt++)\n\t\tregmap_write(pchip->regmap, icnt, 0x00);\n\n\treturn ret;\n}\n\nstatic void lp8755_remove(struct i2c_client *client)\n{\n\tint icnt;\n\tstruct lp8755_chip *pchip = i2c_get_clientdata(client);\n\n\tfor (icnt = 0; icnt < LP8755_BUCK_MAX; icnt++)\n\t\tregmap_write(pchip->regmap, icnt, 0x00);\n}\n\nstatic const struct i2c_device_id lp8755_id[] = {\n\t{LP8755_NAME, 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, lp8755_id);\n\nstatic struct i2c_driver lp8755_i2c_driver = {\n\t.driver = {\n\t\t   .name = LP8755_NAME,\n\t\t   .probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t   },\n\t.probe = lp8755_probe,\n\t.remove = lp8755_remove,\n\t.id_table = lp8755_id,\n};\n\nstatic int __init lp8755_init(void)\n{\n\treturn i2c_add_driver(&lp8755_i2c_driver);\n}\n\nsubsys_initcall(lp8755_init);\n\nstatic void __exit lp8755_exit(void)\n{\n\ti2c_del_driver(&lp8755_i2c_driver);\n}\n\nmodule_exit(lp8755_exit);\n\nMODULE_DESCRIPTION(\"Texas Instruments lp8755 driver\");\nMODULE_AUTHOR(\"Daniel Jeong <daniel.jeong@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}