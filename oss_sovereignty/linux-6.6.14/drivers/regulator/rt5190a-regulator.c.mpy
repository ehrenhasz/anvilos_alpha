{
  "module_name": "rt5190a-regulator.c",
  "hash_id": "f17cfe433e989127b01eb26adc422c4ccc715fd626f298454744105127cb833e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rt5190a-regulator.c",
  "human_readable_source": "\n\n#include <dt-bindings/regulator/richtek,rt5190a-regulator.h>\n#include <linux/bits.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n\n#define RT5190A_REG_MANUFACTURE\t\t0x00\n#define RT5190A_REG_BUCK2VSEL\t\t0x04\n#define RT5190A_REG_BUCK3VSEL\t\t0x05\n#define RT5190A_REG_DCDCCNTL\t\t0x06\n#define RT5190A_REG_ENABLE\t\t0x07\n#define RT5190A_REG_DISCHARGE\t\t0x09\n#define RT5190A_REG_PROTMODE\t\t0x0A\n#define RT5190A_REG_MUTECNTL\t\t0x0B\n#define RT5190A_REG_PGSTAT\t\t0x0F\n#define RT5190A_REG_OVINT\t\t0x10\n#define RT5190A_REG_HOTDIEMASK\t\t0x17\n\n#define RT5190A_VSEL_MASK\t\tGENMASK(6, 0)\n#define RT5190A_RID_BITMASK(rid)\tBIT(rid + 1)\n#define RT5190A_BUCK1_DISCHG_MASK\tGENMASK(1, 0)\n#define RT5190A_BUCK1_DISCHG_ONVAL\t0x01\n#define RT5190A_OVERVOLT_MASK\t\tGENMASK(7, 0)\n#define RT5190A_UNDERVOLT_MASK\t\tGENMASK(15, 8)\n#define RT5190A_CH234OT_MASK\t\tBIT(29)\n#define RT5190A_CHIPOT_MASK\t\tBIT(28)\n\n#define RT5190A_BUCK23_MINUV\t\t600000\n#define RT5190A_BUCK23_MAXUV\t\t1400000\n#define RT5190A_BUCK23_STEPUV\t\t10000\n#define RT5190A_BUCK23_STEPNUM\t\t((1400000 - 600000) / 10000 + 1)\n\nenum {\n\tRT5190A_IDX_BUCK1 = 0,\n\tRT5190A_IDX_BUCK2,\n\tRT5190A_IDX_BUCK3,\n\tRT5190A_IDX_BUCK4,\n\tRT5190A_IDX_LDO,\n\tRT5190A_MAX_IDX\n};\n\nstruct rt5190a_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regulator_desc rdesc[RT5190A_MAX_IDX];\n\tstruct regulator_dev *rdev[RT5190A_MAX_IDX];\n};\n\nstatic int rt5190a_get_error_flags(struct regulator_dev *rdev,\n\t\t\t\t   unsigned int *flags)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tint rid = rdev_get_id(rdev);\n\tunsigned int pgood_stat;\n\tint ret;\n\n\tret = regmap_read(regmap, RT5190A_REG_PGSTAT, &pgood_stat);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(pgood_stat & RT5190A_RID_BITMASK(rid)))\n\t\t*flags = REGULATOR_ERROR_FAIL;\n\telse\n\t\t*flags = 0;\n\n\treturn 0;\n}\n\nstatic int rt5190a_fixed_buck_set_mode(struct regulator_dev *rdev,\n\t\t\t\t       unsigned int mode)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tint rid = rdev_get_id(rdev);\n\tunsigned int mask = RT5190A_RID_BITMASK(rid), val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tval = mask;\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(regmap, RT5190A_REG_DCDCCNTL, mask, val);\n}\n\nstatic unsigned int rt5190a_fixed_buck_get_mode(struct regulator_dev *rdev)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tint rid = rdev_get_id(rdev);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(regmap, RT5190A_REG_DCDCCNTL, &val);\n\tif (ret) {\n\t\tdev_err(&rdev->dev, \"Failed to get mode [%d]\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (val & RT5190A_RID_BITMASK(rid))\n\t\treturn REGULATOR_MODE_FAST;\n\n\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic const struct regulator_ops rt5190a_ranged_buck_ops = {\n\t.enable\t= regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n\t.get_error_flags = rt5190a_get_error_flags,\n};\n\nstatic const struct regulator_ops rt5190a_fixed_buck_ops = {\n\t.enable\t= regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n\t.set_mode = rt5190a_fixed_buck_set_mode,\n\t.get_mode = rt5190a_fixed_buck_get_mode,\n\t.get_error_flags = rt5190a_get_error_flags,\n};\n\nstatic const struct regulator_ops rt5190a_fixed_ldo_ops = {\n\t.enable\t= regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n\t.get_error_flags = rt5190a_get_error_flags,\n};\n\nstatic irqreturn_t rt5190a_irq_handler(int irq, void *data)\n{\n\tstruct rt5190a_priv *priv = data;\n\t__le32 raws;\n\tunsigned int events, fields;\n\tstatic const struct {\n\t\tunsigned int bitmask;\n\t\tunsigned int report;\n\t} event_tbl[] = {\n\t\t{ RT5190A_OVERVOLT_MASK, REGULATOR_ERROR_REGULATION_OUT },\n\t\t{ RT5190A_UNDERVOLT_MASK, REGULATOR_ERROR_UNDER_VOLTAGE }\n\t};\n\tint i, j, ret;\n\n\tret = regmap_raw_read(priv->regmap, RT5190A_REG_OVINT, &raws,\n\t\t\t      sizeof(raws));\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to read events\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tevents = le32_to_cpu(raws);\n\n\tret = regmap_raw_write(priv->regmap, RT5190A_REG_OVINT, &raws,\n\t\t\t       sizeof(raws));\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to write-clear events\\n\");\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(event_tbl); i++) {\n\t\tfields = events & event_tbl[i].bitmask;\n\t\tfields >>= ffs(event_tbl[i].bitmask) - 1;\n\n\t\tfor (j = 0; j < RT5190A_MAX_IDX; j++) {\n\t\t\tif (!(fields & RT5190A_RID_BITMASK(j)))\n\t\t\t\tcontinue;\n\n\t\t\tregulator_notifier_call_chain(priv->rdev[j],\n\t\t\t\t\t\t      event_tbl[i].report,\n\t\t\t\t\t\t      NULL);\n\t\t}\n\t}\n\n\t \n\tif (events & RT5190A_CH234OT_MASK) {\n\t\tfor (j = RT5190A_IDX_BUCK2; j < RT5190A_IDX_LDO; j++) {\n\t\t\tregulator_notifier_call_chain(priv->rdev[j],\n\t\t\t\t\t\t      REGULATOR_ERROR_OVER_TEMP,\n\t\t\t\t\t\t      NULL);\n\t\t}\n\t}\n\n\t \n\tif (events & RT5190A_CHIPOT_MASK)\n\t\tdev_warn(priv->dev, \"CHIP overheat\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int rt5190a_of_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase RT5190A_OPMODE_AUTO:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase RT5190A_OPMODE_FPWM:\n\t\treturn REGULATOR_MODE_FAST;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic int rt5190a_of_parse_cb(struct rt5190a_priv *priv, int rid,\n\t\t\t       struct of_regulator_match *match)\n{\n\tstruct regulator_desc *desc = priv->rdesc + rid;\n\tstruct regulator_init_data *init_data = match->init_data;\n\tstruct device_node *np = match->of_node;\n\tbool latchup_enable;\n\tunsigned int mask = RT5190A_RID_BITMASK(rid), val;\n\n\tif (!init_data)\n\t\treturn 0;\n\n\tswitch (rid) {\n\tcase RT5190A_IDX_BUCK1:\n\tcase RT5190A_IDX_BUCK4:\n\tcase RT5190A_IDX_LDO:\n\t\tinit_data->constraints.apply_uV = 0;\n\n\t\tif (init_data->constraints.min_uV ==\n\t\t\t\tinit_data->constraints.max_uV)\n\t\t\tdesc->fixed_uV = init_data->constraints.min_uV;\n\t\telse {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"Variable voltage for fixed regulator\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tlatchup_enable = of_property_read_bool(np, \"richtek,latchup-enable\");\n\n\t \n\tval = !latchup_enable ? mask : 0;\n\n\treturn regmap_update_bits(priv->regmap, RT5190A_REG_PROTMODE, mask, val);\n}\n\nstatic void rt5190a_fillin_regulator_desc(struct regulator_desc *desc, int rid)\n{\n\tstatic const char * const regu_name[] = { \"buck1\", \"buck2\",\n\t\t\t\t\t\t  \"buck3\", \"buck4\",\n\t\t\t\t\t\t  \"ldo\" };\n\tstatic const char * const supply[] = { NULL, \"vin2\", \"vin3\", \"vin4\",\n\t\t\t\t\t       \"vinldo\" };\n\n\tdesc->name = regu_name[rid];\n\tdesc->supply_name = supply[rid];\n\tdesc->owner = THIS_MODULE;\n\tdesc->type = REGULATOR_VOLTAGE;\n\tdesc->id = rid;\n\tdesc->enable_reg = RT5190A_REG_ENABLE;\n\tdesc->enable_mask = RT5190A_RID_BITMASK(rid);\n\tdesc->active_discharge_reg = RT5190A_REG_DISCHARGE;\n\tdesc->active_discharge_mask = RT5190A_RID_BITMASK(rid);\n\tdesc->active_discharge_on = RT5190A_RID_BITMASK(rid);\n\n\tswitch (rid) {\n\tcase RT5190A_IDX_BUCK1:\n\t\tdesc->active_discharge_mask = RT5190A_BUCK1_DISCHG_MASK;\n\t\tdesc->active_discharge_on = RT5190A_BUCK1_DISCHG_ONVAL;\n\t\tdesc->n_voltages = 1;\n\t\tdesc->ops = &rt5190a_fixed_buck_ops;\n\t\tdesc->of_map_mode = rt5190a_of_map_mode;\n\t\tbreak;\n\tcase RT5190A_IDX_BUCK2:\n\t\tdesc->vsel_reg = RT5190A_REG_BUCK2VSEL;\n\t\tdesc->vsel_mask = RT5190A_VSEL_MASK;\n\t\tdesc->min_uV = RT5190A_BUCK23_MINUV;\n\t\tdesc->uV_step = RT5190A_BUCK23_STEPUV;\n\t\tdesc->n_voltages = RT5190A_BUCK23_STEPNUM;\n\t\tdesc->ops = &rt5190a_ranged_buck_ops;\n\t\tbreak;\n\tcase RT5190A_IDX_BUCK3:\n\t\tdesc->vsel_reg = RT5190A_REG_BUCK3VSEL;\n\t\tdesc->vsel_mask = RT5190A_VSEL_MASK;\n\t\tdesc->min_uV = RT5190A_BUCK23_MINUV;\n\t\tdesc->uV_step = RT5190A_BUCK23_STEPUV;\n\t\tdesc->n_voltages = RT5190A_BUCK23_STEPNUM;\n\t\tdesc->ops = &rt5190a_ranged_buck_ops;\n\t\tbreak;\n\tcase RT5190A_IDX_BUCK4:\n\t\tdesc->n_voltages = 1;\n\t\tdesc->ops = &rt5190a_fixed_buck_ops;\n\t\tdesc->of_map_mode = rt5190a_of_map_mode;\n\t\tbreak;\n\tcase RT5190A_IDX_LDO:\n\t\tdesc->n_voltages = 1;\n\t\tdesc->ops = &rt5190a_fixed_ldo_ops;\n\t\tbreak;\n\t}\n}\n\nstatic struct of_regulator_match rt5190a_regulator_match[] = {\n\t{ .name = \"buck1\", },\n\t{ .name = \"buck2\", },\n\t{ .name = \"buck3\", },\n\t{ .name = \"buck4\", },\n\t{ .name = \"ldo\", }\n};\n\nstatic int rt5190a_parse_regulator_dt_data(struct rt5190a_priv *priv)\n{\n\tstruct device_node *regulator_np;\n\tstruct regulator_desc *reg_desc;\n\tstruct of_regulator_match *match;\n\tint i, ret;\n\n\tfor (i = 0; i < RT5190A_MAX_IDX; i++) {\n\t\treg_desc = priv->rdesc + i;\n\t\tmatch = rt5190a_regulator_match + i;\n\n\t\trt5190a_fillin_regulator_desc(reg_desc, i);\n\n\t\tmatch->desc = reg_desc;\n\t}\n\n\tregulator_np = of_get_child_by_name(priv->dev->of_node, \"regulators\");\n\tif (!regulator_np) {\n\t\tdev_err(priv->dev, \"Could not find 'regulators' node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_regulator_match(priv->dev, regulator_np,\n\t\t\t\t rt5190a_regulator_match,\n\t\t\t\t ARRAY_SIZE(rt5190a_regulator_match));\n\n\tof_node_put(regulator_np);\n\n\tif (ret < 0) {\n\t\tdev_err(priv->dev,\n\t\t\t\"Error parsing regulator init data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < RT5190A_MAX_IDX; i++) {\n\t\tmatch = rt5190a_regulator_match + i;\n\n\t\tret = rt5190a_of_parse_cb(priv, i, match);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"Failed in [%d] of_parse_cb\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct reg_sequence rt5190a_init_patch[] = {\n\t{ 0x09, 0x3d, },\n\t{ 0x0a, 0x3e, },\n\t{ 0x0b, 0x01, },\n\t{ 0x10, 0xff, },\n\t{ 0x11, 0xff, },\n\t{ 0x12, 0xff, },\n\t{ 0x13, 0xff, },\n\t{ 0x14, 0, },\n\t{ 0x15, 0, },\n\t{ 0x16, 0x3e, },\n\t{ 0x17, 0, }\n};\n\nstatic int rt5190a_device_initialize(struct rt5190a_priv *priv)\n{\n\tbool mute_enable;\n\tint ret;\n\n\tret = regmap_register_patch(priv->regmap, rt5190a_init_patch,\n\t\t\t\t    ARRAY_SIZE(rt5190a_init_patch));\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to do register patch\\n\");\n\t\treturn ret;\n\t}\n\n\tmute_enable = device_property_read_bool(priv->dev,\n\t\t\t\t\t\t\"richtek,mute-enable\");\n\n\tif (mute_enable) {\n\t\tret = regmap_write(priv->regmap, RT5190A_REG_MUTECNTL, 0x00);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"Failed to enable mute function\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rt5190a_device_check(struct rt5190a_priv *priv)\n{\n\tu16 devid;\n\tint ret;\n\n\tret = regmap_raw_read(priv->regmap, RT5190A_REG_MANUFACTURE, &devid,\n\t\t\t      sizeof(devid));\n\tif (ret)\n\t\treturn ret;\n\n\tif (devid) {\n\t\tdev_err(priv->dev, \"Incorrect device id 0x%04x\\n\", devid);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_config rt5190a_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RT5190A_REG_HOTDIEMASK,\n};\n\nstatic int rt5190a_probe(struct i2c_client *i2c)\n{\n\tstruct rt5190a_priv *priv;\n\tstruct regulator_config cfg = {};\n\tint i, ret;\n\n\tpriv = devm_kzalloc(&i2c->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &i2c->dev;\n\n\tpriv->regmap = devm_regmap_init_i2c(i2c, &rt5190a_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(&i2c->dev, \"Failed to allocate regmap\\n\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\tret = rt5190a_device_check(priv);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to check device %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = rt5190a_device_initialize(priv);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to initialize the device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rt5190a_parse_regulator_dt_data(priv);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to parse regulator dt\\n\");\n\t\treturn ret;\n\t}\n\n\tcfg.dev = &i2c->dev;\n\tcfg.regmap = priv->regmap;\n\n\tfor (i = 0; i < RT5190A_MAX_IDX; i++) {\n\t\tstruct regulator_desc *desc = priv->rdesc + i;\n\t\tstruct of_regulator_match *match = rt5190a_regulator_match + i;\n\n\t\tcfg.init_data = match->init_data;\n\t\tcfg.of_node = match->of_node;\n\n\t\tpriv->rdev[i] = devm_regulator_register(&i2c->dev, desc, &cfg);\n\t\tif (IS_ERR(priv->rdev[i])) {\n\t\t\tdev_err(&i2c->dev, \"Failed to register regulator %s\\n\",\n\t\t\t\tdesc->name);\n\t\t\treturn PTR_ERR(priv->rdev[i]);\n\t\t}\n\t}\n\n\tif (i2c->irq) {\n\t\tret = devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL,\n\t\t\t\t\t\trt5190a_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(&i2c->dev), priv);\n\t\tif (ret) {\n\t\t\tdev_err(&i2c->dev, \"Failed to register interrupt\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused rt5190a_device_table[] = {\n\t{ .compatible = \"richtek,rt5190a\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rt5190a_device_table);\n\nstatic struct i2c_driver rt5190a_driver = {\n\t.driver = {\n\t\t.name = \"rt5190a\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = rt5190a_device_table,\n\t},\n\t.probe = rt5190a_probe,\n};\nmodule_i2c_driver(rt5190a_driver);\n\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_DESCRIPTION(\"Richtek RT5190A Regulator Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}