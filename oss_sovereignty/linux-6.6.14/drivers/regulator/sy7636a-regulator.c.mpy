{
  "module_name": "sy7636a-regulator.c",
  "hash_id": "a09aa8e21d234aae0a4dcb91b3c065657b6c80382ed0919c1bba20f675b2cba2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/sy7636a-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/mfd/sy7636a.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regmap.h>\n\nstruct sy7636a_data {\n\tstruct regmap *regmap;\n\tstruct gpio_desc *pgood_gpio;\n};\n\nstatic int sy7636a_get_vcom_voltage_op(struct regulator_dev *rdev)\n{\n\tint ret;\n\tunsigned int val, val_h;\n\n\tret = regmap_read(rdev->regmap, SY7636A_REG_VCOM_ADJUST_CTRL_L, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(rdev->regmap, SY7636A_REG_VCOM_ADJUST_CTRL_H, &val_h);\n\tif (ret)\n\t\treturn ret;\n\n\tval |= (val_h << VCOM_ADJUST_CTRL_SHIFT);\n\n\treturn (val & VCOM_ADJUST_CTRL_MASK) * VCOM_ADJUST_CTRL_SCAL;\n}\n\nstatic int sy7636a_get_status(struct regulator_dev *rdev)\n{\n\tstruct sy7636a_data *data = dev_get_drvdata(rdev->dev.parent);\n\tint ret = 0;\n\n\tret = gpiod_get_value_cansleep(data->pgood_gpio);\n\tif (ret < 0)\n\t\tdev_err(&rdev->dev, \"Failed to read pgood gpio: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct regulator_ops sy7636a_vcom_volt_ops = {\n\t.get_voltage = sy7636a_get_vcom_voltage_op,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.get_status = sy7636a_get_status,\n};\n\nstatic const struct regulator_desc desc = {\n\t.name = \"vcom\",\n\t.id = 0,\n\t.ops = &sy7636a_vcom_volt_ops,\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n\t.enable_reg = SY7636A_REG_OPERATION_MODE_CRL,\n\t.enable_mask = SY7636A_OPERATION_MODE_CRL_ONOFF,\n\t.regulators_node = of_match_ptr(\"regulators\"),\n\t.of_match = of_match_ptr(\"vcom\"),\n};\n\nstatic int sy7636a_regulator_probe(struct platform_device *pdev)\n{\n\tstruct regmap *regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tstruct gpio_desc *gdp;\n\tstruct sy7636a_data *data;\n\tint ret;\n\n\tif (!regmap)\n\t\treturn -EPROBE_DEFER;\n\n\tgdp = devm_gpiod_get(pdev->dev.parent, \"epd-pwr-good\", GPIOD_IN);\n\tif (IS_ERR(gdp)) {\n\t\tdev_err(pdev->dev.parent, \"Power good GPIO fault %ld\\n\", PTR_ERR(gdp));\n\t\treturn PTR_ERR(gdp);\n\t}\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct sy7636a_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regmap = regmap;\n\tdata->pgood_gpio = gdp;\n\n\tplatform_set_drvdata(pdev, data);\n\n\tret = regmap_write(regmap, SY7636A_REG_POWER_ON_DELAY_TIME, 0x0);\n\tif (ret) {\n\t\tdev_err(pdev->dev.parent, \"Failed to initialize regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tconfig.dev = &pdev->dev;\n\tconfig.dev->of_node = pdev->dev.parent->of_node;\n\tconfig.regmap = regmap;\n\n\trdev = devm_regulator_register(&pdev->dev, &desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(pdev->dev.parent, \"Failed to register %s regulator\\n\",\n\t\t\tpdev->name);\n\t\treturn PTR_ERR(rdev);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id sy7636a_regulator_id_table[] = {\n\t{ \"sy7636a-regulator\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, sy7636a_regulator_id_table);\n\nstatic struct platform_driver sy7636a_regulator_driver = {\n\t.driver = {\n\t\t.name = \"sy7636a-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = sy7636a_regulator_probe,\n\t.id_table = sy7636a_regulator_id_table,\n};\nmodule_platform_driver(sy7636a_regulator_driver);\n\nMODULE_AUTHOR(\"Lars Ivar Miljeteig <lars.ivar.miljeteig@remarkable.com>\");\nMODULE_DESCRIPTION(\"SY7636A voltage regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}