{
  "module_name": "sy8824x.c",
  "hash_id": "805957535a85cd9c7d023d3b28ee8ad9fc0d6dfc9d68138f3a7dde62ac3628e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/sy8824x.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n#define SY8824C_BUCK_EN\t\t(1 << 7)\n#define SY8824C_MODE\t\t(1 << 6)\n\nstruct sy8824_config {\n\t \n\tunsigned int vol_reg;\n\tunsigned int mode_reg;\n\tunsigned int enable_reg;\n\t \n\tunsigned int vsel_min;\n\tunsigned int vsel_step;\n\tunsigned int vsel_count;\n\tconst struct regmap_config *config;\n};\n\nstruct sy8824_device_info {\n\tstruct device *dev;\n\tstruct regulator_desc desc;\n\tstruct regulator_init_data *regulator;\n\tconst struct sy8824_config *cfg;\n};\n\nstatic int sy8824_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct sy8824_device_info *di = rdev_get_drvdata(rdev);\n\tconst struct sy8824_config *cfg = di->cfg;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tregmap_update_bits(rdev->regmap, cfg->mode_reg,\n\t\t\t\t   SY8824C_MODE, SY8824C_MODE);\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tregmap_update_bits(rdev->regmap, cfg->mode_reg,\n\t\t\t\t   SY8824C_MODE, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic unsigned int sy8824_get_mode(struct regulator_dev *rdev)\n{\n\tstruct sy8824_device_info *di = rdev_get_drvdata(rdev);\n\tconst struct sy8824_config *cfg = di->cfg;\n\tu32 val;\n\tint ret = 0;\n\n\tret = regmap_read(rdev->regmap, cfg->mode_reg, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (val & SY8824C_MODE)\n\t\treturn REGULATOR_MODE_FAST;\n\telse\n\t\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic const struct regulator_ops sy8824_regulator_ops = {\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_time_sel = regulator_set_voltage_time_sel,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_mode = sy8824_set_mode,\n\t.get_mode = sy8824_get_mode,\n};\n\nstatic int sy8824_regulator_register(struct sy8824_device_info *di,\n\t\t\tstruct regulator_config *config)\n{\n\tstruct regulator_desc *rdesc = &di->desc;\n\tconst struct sy8824_config *cfg = di->cfg;\n\tstruct regulator_dev *rdev;\n\n\trdesc->name = \"sy8824-reg\";\n\trdesc->supply_name = \"vin\";\n\trdesc->ops = &sy8824_regulator_ops;\n\trdesc->type = REGULATOR_VOLTAGE;\n\trdesc->n_voltages = cfg->vsel_count;\n\trdesc->enable_reg = cfg->enable_reg;\n\trdesc->enable_mask = SY8824C_BUCK_EN;\n\trdesc->min_uV = cfg->vsel_min;\n\trdesc->uV_step = cfg->vsel_step;\n\trdesc->vsel_reg = cfg->vol_reg;\n\trdesc->vsel_mask = cfg->vsel_count - 1;\n\trdesc->owner = THIS_MODULE;\n\n\trdev = devm_regulator_register(di->dev, &di->desc, config);\n\treturn PTR_ERR_OR_ZERO(rdev);\n}\n\nstatic const struct regmap_config sy8824_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.num_reg_defaults_raw = 1,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct regmap_config sy20276_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.num_reg_defaults_raw = 2,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int sy8824_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct sy8824_device_info *di;\n\tstruct regulator_config config = { };\n\tstruct regmap *regmap;\n\tint ret;\n\n\tdi = devm_kzalloc(dev, sizeof(struct sy8824_device_info), GFP_KERNEL);\n\tif (!di)\n\t\treturn -ENOMEM;\n\n\tdi->regulator = of_get_regulator_init_data(dev, np, &di->desc);\n\tif (!di->regulator) {\n\t\tdev_err(dev, \"Platform data not found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdi->dev = dev;\n\tdi->cfg = of_device_get_match_data(dev);\n\n\tregmap = devm_regmap_init_i2c(client, di->cfg->config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"Failed to allocate regmap!\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\ti2c_set_clientdata(client, di);\n\n\tconfig.dev = di->dev;\n\tconfig.init_data = di->regulator;\n\tconfig.regmap = regmap;\n\tconfig.driver_data = di;\n\tconfig.of_node = np;\n\n\tret = sy8824_regulator_register(di, &config);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to register regulator!\\n\");\n\treturn ret;\n}\n\nstatic const struct sy8824_config sy8824c_cfg = {\n\t.vol_reg = 0x00,\n\t.mode_reg = 0x00,\n\t.enable_reg = 0x00,\n\t.vsel_min = 762500,\n\t.vsel_step = 12500,\n\t.vsel_count = 64,\n\t.config = &sy8824_regmap_config,\n};\n\nstatic const struct sy8824_config sy8824e_cfg = {\n\t.vol_reg = 0x00,\n\t.mode_reg = 0x00,\n\t.enable_reg = 0x00,\n\t.vsel_min = 700000,\n\t.vsel_step = 12500,\n\t.vsel_count = 64,\n\t.config = &sy8824_regmap_config,\n};\n\nstatic const struct sy8824_config sy20276_cfg = {\n\t.vol_reg = 0x00,\n\t.mode_reg = 0x01,\n\t.enable_reg = 0x01,\n\t.vsel_min = 600000,\n\t.vsel_step = 10000,\n\t.vsel_count = 128,\n\t.config = &sy20276_regmap_config,\n};\n\nstatic const struct sy8824_config sy20278_cfg = {\n\t.vol_reg = 0x00,\n\t.mode_reg = 0x01,\n\t.enable_reg = 0x01,\n\t.vsel_min = 762500,\n\t.vsel_step = 12500,\n\t.vsel_count = 64,\n\t.config = &sy20276_regmap_config,\n};\n\nstatic const struct of_device_id sy8824_dt_ids[] = {\n\t{\n\t\t.compatible = \"silergy,sy8824c\",\n\t\t.data = &sy8824c_cfg\n\t},\n\t{\n\t\t.compatible = \"silergy,sy8824e\",\n\t\t.data = &sy8824e_cfg\n\t},\n\t{\n\t\t.compatible = \"silergy,sy20276\",\n\t\t.data = &sy20276_cfg\n\t},\n\t{\n\t\t.compatible = \"silergy,sy20278\",\n\t\t.data = &sy20278_cfg\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sy8824_dt_ids);\n\nstatic const struct i2c_device_id sy8824_id[] = {\n\t{ \"sy8824\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, sy8824_id);\n\nstatic struct i2c_driver sy8824_regulator_driver = {\n\t.driver = {\n\t\t.name = \"sy8824-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = sy8824_dt_ids,\n\t},\n\t.probe = sy8824_i2c_probe,\n\t.id_table = sy8824_id,\n};\nmodule_i2c_driver(sy8824_regulator_driver);\n\nMODULE_AUTHOR(\"Jisheng Zhang <jszhang@kernel.org>\");\nMODULE_DESCRIPTION(\"SY8824C/SY8824E regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}