{
  "module_name": "88pm800-regulator.c",
  "hash_id": "b2e27374603be528fd9a552649fa71ff7fc5f1c2657c0d846965f22ebe8607e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/88pm800-regulator.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/mfd/88pm80x.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/regulator/of_regulator.h>\n\n \n#define PM800_LDO1_VOUT\t\t(0x08)  \n#define PM800_LDO1_VOUT_2\t(0x09)\n#define PM800_LDO1_VOUT_3\t(0x0A)\n#define PM800_LDO2_VOUT\t\t(0x0B)\n#define PM800_LDO3_VOUT\t\t(0x0C)\n#define PM800_LDO4_VOUT\t\t(0x0D)\n#define PM800_LDO5_VOUT\t\t(0x0E)\n#define PM800_LDO6_VOUT\t\t(0x0F)\n#define PM800_LDO7_VOUT\t\t(0x10)\n#define PM800_LDO8_VOUT\t\t(0x11)\n#define PM800_LDO9_VOUT\t\t(0x12)\n#define PM800_LDO10_VOUT\t(0x13)\n#define PM800_LDO11_VOUT\t(0x14)\n#define PM800_LDO12_VOUT\t(0x15)\n#define PM800_LDO13_VOUT\t(0x16)\n#define PM800_LDO14_VOUT\t(0x17)\n#define PM800_LDO15_VOUT\t(0x18)\n#define PM800_LDO16_VOUT\t(0x19)\n#define PM800_LDO17_VOUT\t(0x1A)\n#define PM800_LDO18_VOUT\t(0x1B)\n#define PM800_LDO19_VOUT\t(0x1C)\n\n \n#define PM800_BUCK1\t\t(0x3C)\n#define PM800_BUCK1_1\t\t(0x3D)\n#define PM800_BUCK1_2\t\t(0x3E)\n#define PM800_BUCK1_3\t\t(0x3F)\n#define PM800_BUCK2\t\t(0x40)\n#define PM800_BUCK3\t\t(0x41)\n#define PM800_BUCK4\t\t(0x42)\n#define PM800_BUCK4_1\t\t(0x43)\n#define PM800_BUCK4_2\t\t(0x44)\n#define PM800_BUCK4_3\t\t(0x45)\n#define PM800_BUCK5\t\t(0x46)\n\n#define PM800_BUCK_ENA\t\t(0x50)\n#define PM800_LDO_ENA1_1\t(0x51)\n#define PM800_LDO_ENA1_2\t(0x52)\n#define PM800_LDO_ENA1_3\t(0x53)\n\n#define PM800_LDO_ENA2_1\t(0x56)\n#define PM800_LDO_ENA2_2\t(0x57)\n#define PM800_LDO_ENA2_3\t(0x58)\n\n#define PM800_BUCK1_MISC1\t(0x78)\n#define PM800_BUCK3_MISC1\t(0x7E)\n#define PM800_BUCK4_MISC1\t(0x81)\n#define PM800_BUCK5_MISC1\t(0x84)\n\nstruct pm800_regulator_info {\n\tstruct regulator_desc desc;\n\tint max_ua;\n};\n\n \n#define PM800_BUCK(match, vreg, ereg, ebit, amax, volt_ranges, n_volt)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.desc\t= {\t\t\t\t\t\t\t\\\n\t\t.name\t\t\t= #vreg,\t\t\t\\\n\t\t.of_match\t\t= of_match_ptr(#match),\t\t\\\n\t\t.regulators_node\t= of_match_ptr(\"regulators\"),\t\\\n\t\t.ops\t\t\t= &pm800_volt_range_ops,\t\\\n\t\t.type\t\t\t= REGULATOR_VOLTAGE,\t\t\\\n\t\t.id\t\t\t= PM800_ID_##vreg,\t\t\\\n\t\t.owner\t\t\t= THIS_MODULE,\t\t\t\\\n\t\t.n_voltages\t\t= n_volt,\t\t\t\\\n\t\t.linear_ranges\t\t= volt_ranges,\t\t\t\\\n\t\t.n_linear_ranges\t= ARRAY_SIZE(volt_ranges),\t\\\n\t\t.vsel_reg\t\t= PM800_##vreg,\t\t\t\\\n\t\t.vsel_mask\t\t= 0x7f,\t\t\t\t\\\n\t\t.enable_reg\t\t= PM800_##ereg,\t\t\t\\\n\t\t.enable_mask\t\t= 1 << (ebit),\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.max_ua\t= (amax),\t\t\t\t\t\t\\\n}\n\n \n#define PM800_LDO(match, vreg, ereg, ebit, amax, ldo_volt_table)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.desc\t= {\t\t\t\t\t\t\t\\\n\t\t.name\t\t\t= #vreg,\t\t\t\\\n\t\t.of_match\t\t= of_match_ptr(#match),\t\t\\\n\t\t.regulators_node\t= of_match_ptr(\"regulators\"),\t\\\n\t\t.ops\t\t\t= &pm800_volt_table_ops,\t\\\n\t\t.type\t\t\t= REGULATOR_VOLTAGE,\t\t\\\n\t\t.id\t\t\t= PM800_ID_##vreg,\t\t\\\n\t\t.owner\t\t\t= THIS_MODULE,\t\t\t\\\n\t\t.n_voltages\t\t= ARRAY_SIZE(ldo_volt_table),\t\\\n\t\t.vsel_reg\t\t= PM800_##vreg##_VOUT,\t\t\\\n\t\t.vsel_mask\t\t= 0xf,\t\t\t\t\\\n\t\t.enable_reg\t\t= PM800_##ereg,\t\t\t\\\n\t\t.enable_mask\t\t= 1 << (ebit),\t\t\t\\\n\t\t.volt_table\t\t= ldo_volt_table,\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.max_ua\t= (amax),\t\t\t\t\t\t\\\n}\n\n \nstatic const struct linear_range buck1_volt_range[] = {\n\tREGULATOR_LINEAR_RANGE(600000, 0, 0x4f, 12500),\n\tREGULATOR_LINEAR_RANGE(1600000, 0x50, 0x54, 50000),\n};\n\n \nstatic const struct linear_range buck2_5_volt_range[] = {\n\tREGULATOR_LINEAR_RANGE(600000, 0, 0x4f, 12500),\n\tREGULATOR_LINEAR_RANGE(1600000, 0x50, 0x72, 50000),\n};\n\nstatic const unsigned int ldo1_volt_table[] = {\n\t600000,  650000,  700000,  750000,  800000,  850000,  900000,  950000,\n\t1000000, 1050000, 1100000, 1150000, 1200000, 1300000, 1400000, 1500000,\n};\n\nstatic const unsigned int ldo2_volt_table[] = {\n\t1700000, 1800000, 1900000, 2000000, 2100000, 2500000, 2700000, 2800000,\n};\n\n \nstatic const unsigned int ldo3_17_volt_table[] = {\n\t1200000, 1250000, 1700000, 1800000, 1850000, 1900000, 2500000, 2600000,\n\t2700000, 2750000, 2800000, 2850000, 2900000, 3000000, 3100000, 3300000,\n};\n\n \nstatic const unsigned int ldo18_19_volt_table[] = {\n\t1700000, 1800000, 1900000, 2500000, 2800000, 2900000, 3100000, 3300000,\n};\n\nstatic int pm800_get_current_limit(struct regulator_dev *rdev)\n{\n\tstruct pm800_regulator_info *info = rdev_get_drvdata(rdev);\n\n\treturn info->max_ua;\n}\n\nstatic const struct regulator_ops pm800_volt_range_ops = {\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.get_current_limit\t= pm800_get_current_limit,\n};\n\nstatic const struct regulator_ops pm800_volt_table_ops = {\n\t.list_voltage\t\t= regulator_list_voltage_table,\n\t.map_voltage\t\t= regulator_map_voltage_iterate,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.get_current_limit\t= pm800_get_current_limit,\n};\n\n \nstatic struct pm800_regulator_info pm800_regulator_info[] = {\n\tPM800_BUCK(buck1, BUCK1, BUCK_ENA, 0, 3000000, buck1_volt_range, 0x55),\n\tPM800_BUCK(buck2, BUCK2, BUCK_ENA, 1, 1200000, buck2_5_volt_range, 0x73),\n\tPM800_BUCK(buck3, BUCK3, BUCK_ENA, 2, 1200000, buck2_5_volt_range, 0x73),\n\tPM800_BUCK(buck4, BUCK4, BUCK_ENA, 3, 1200000, buck2_5_volt_range, 0x73),\n\tPM800_BUCK(buck5, BUCK5, BUCK_ENA, 4, 1200000, buck2_5_volt_range, 0x73),\n\n\tPM800_LDO(ldo1, LDO1, LDO_ENA1_1, 0, 200000, ldo1_volt_table),\n\tPM800_LDO(ldo2, LDO2, LDO_ENA1_1, 1, 10000, ldo2_volt_table),\n\tPM800_LDO(ldo3, LDO3, LDO_ENA1_1, 2, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo4, LDO4, LDO_ENA1_1, 3, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo5, LDO5, LDO_ENA1_1, 4, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo6, LDO6, LDO_ENA1_1, 5, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo7, LDO7, LDO_ENA1_1, 6, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo8, LDO8, LDO_ENA1_1, 7, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo9, LDO9, LDO_ENA1_2, 0, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo10, LDO10, LDO_ENA1_2, 1, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo11, LDO11, LDO_ENA1_2, 2, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo12, LDO12, LDO_ENA1_2, 3, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo13, LDO13, LDO_ENA1_2, 4, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo14, LDO14, LDO_ENA1_2, 5, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo15, LDO15, LDO_ENA1_2, 6, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo16, LDO16, LDO_ENA1_2, 7, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo17, LDO17, LDO_ENA1_3, 0, 300000, ldo3_17_volt_table),\n\tPM800_LDO(ldo18, LDO18, LDO_ENA1_3, 1, 200000, ldo18_19_volt_table),\n\tPM800_LDO(ldo19, LDO19, LDO_ENA1_3, 2, 200000, ldo18_19_volt_table),\n};\n\nstatic int pm800_regulator_probe(struct platform_device *pdev)\n{\n\tstruct pm80x_chip *chip = dev_get_drvdata(pdev->dev.parent);\n\tstruct pm80x_platform_data *pdata = dev_get_platdata(pdev->dev.parent);\n\tstruct regulator_config config = { };\n\tstruct regulator_init_data *init_data;\n\tint i, ret;\n\n\tif (pdata && pdata->num_regulators) {\n\t\tunsigned int count = 0;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(pdata->regulators); i++) {\n\t\t\tif (pdata->regulators[i])\n\t\t\t\tcount++;\n\t\t}\n\t\tif (count != pdata->num_regulators)\n\t\t\treturn -EINVAL;\n\t}\n\n\tconfig.dev = chip->dev;\n\tconfig.regmap = chip->subchip->regmap_power;\n\tfor (i = 0; i < PM800_ID_RG_MAX; i++) {\n\t\tstruct regulator_dev *regulator;\n\n\t\tif (pdata && pdata->num_regulators) {\n\t\t\tinit_data = pdata->regulators[i];\n\t\t\tif (!init_data)\n\t\t\t\tcontinue;\n\n\t\t\tconfig.init_data = init_data;\n\t\t}\n\n\t\tconfig.driver_data = &pm800_regulator_info[i];\n\n\t\tregulator = devm_regulator_register(&pdev->dev,\n\t\t\t\t&pm800_regulator_info[i].desc, &config);\n\t\tif (IS_ERR(regulator)) {\n\t\t\tret = PTR_ERR(regulator);\n\t\t\tdev_err(&pdev->dev, \"Failed to register %s\\n\",\n\t\t\t\t\tpm800_regulator_info[i].desc.name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver pm800_regulator_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"88pm80x-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t\t= pm800_regulator_probe,\n};\n\nmodule_platform_driver(pm800_regulator_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Joseph(Yossi) Hanin <yhanin@marvell.com>\");\nMODULE_DESCRIPTION(\"Regulator Driver for Marvell 88PM800 PMIC\");\nMODULE_ALIAS(\"platform:88pm800-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}