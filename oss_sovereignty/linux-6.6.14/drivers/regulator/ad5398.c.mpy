{
  "module_name": "ad5398.c",
  "hash_id": "57fc6ff85a8665169eb176d24599aad040270932bc6718c85e99e35331d284fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/ad5398.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n\n#define AD5398_CURRENT_EN_MASK\t0x8000\n\nstruct ad5398_chip_info {\n\tstruct i2c_client *client;\n\tint min_uA;\n\tint max_uA;\n\tunsigned int current_level;\n\tunsigned int current_mask;\n\tunsigned int current_offset;\n\tstruct regulator_dev *rdev;\n};\n\nstatic int ad5398_calc_current(struct ad5398_chip_info *chip,\n\tunsigned selector)\n{\n\tunsigned range_uA = chip->max_uA - chip->min_uA;\n\n\treturn chip->min_uA + (selector * range_uA / chip->current_level);\n}\n\nstatic int ad5398_read_reg(struct i2c_client *client, unsigned short *data)\n{\n\tunsigned short val;\n\tint ret;\n\n\tret = i2c_master_recv(client, (char *)&val, 2);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"I2C read error\\n\");\n\t\treturn ret;\n\t}\n\t*data = be16_to_cpu(val);\n\n\treturn ret;\n}\n\nstatic int ad5398_write_reg(struct i2c_client *client, const unsigned short data)\n{\n\tunsigned short val;\n\tint ret;\n\n\tval = cpu_to_be16(data);\n\tret = i2c_master_send(client, (char *)&val, 2);\n\tif (ret != 2) {\n\t\tdev_err(&client->dev, \"I2C write error\\n\");\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad5398_get_current_limit(struct regulator_dev *rdev)\n{\n\tstruct ad5398_chip_info *chip = rdev_get_drvdata(rdev);\n\tstruct i2c_client *client = chip->client;\n\tunsigned short data;\n\tint ret;\n\n\tret = ad5398_read_reg(client, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = (data & chip->current_mask) >> chip->current_offset;\n\n\treturn ad5398_calc_current(chip, ret);\n}\n\nstatic int ad5398_set_current_limit(struct regulator_dev *rdev, int min_uA, int max_uA)\n{\n\tstruct ad5398_chip_info *chip = rdev_get_drvdata(rdev);\n\tstruct i2c_client *client = chip->client;\n\tunsigned range_uA = chip->max_uA - chip->min_uA;\n\tunsigned selector;\n\tunsigned short data;\n\tint ret;\n\n\tif (min_uA < chip->min_uA)\n\t\tmin_uA = chip->min_uA;\n\tif (max_uA > chip->max_uA)\n\t\tmax_uA = chip->max_uA;\n\n\tif (min_uA > chip->max_uA || max_uA < chip->min_uA)\n\t\treturn -EINVAL;\n\n\tselector = DIV_ROUND_UP((min_uA - chip->min_uA) * chip->current_level,\n\t\t\t\trange_uA);\n\tif (ad5398_calc_current(chip, selector) > max_uA)\n\t\treturn -EINVAL;\n\n\tdev_dbg(&client->dev, \"changing current %duA\\n\",\n\t\tad5398_calc_current(chip, selector));\n\n\t \n\tret = ad5398_read_reg(client, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tselector = (selector << chip->current_offset) & chip->current_mask;\n\tdata = (unsigned short)selector | (data & AD5398_CURRENT_EN_MASK);\n\n\t \n\tret = ad5398_write_reg(client, data);\n\n\treturn ret;\n}\n\nstatic int ad5398_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct ad5398_chip_info *chip = rdev_get_drvdata(rdev);\n\tstruct i2c_client *client = chip->client;\n\tunsigned short data;\n\tint ret;\n\n\tret = ad5398_read_reg(client, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (data & AD5398_CURRENT_EN_MASK)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int ad5398_enable(struct regulator_dev *rdev)\n{\n\tstruct ad5398_chip_info *chip = rdev_get_drvdata(rdev);\n\tstruct i2c_client *client = chip->client;\n\tunsigned short data;\n\tint ret;\n\n\tret = ad5398_read_reg(client, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (data & AD5398_CURRENT_EN_MASK)\n\t\treturn 0;\n\n\tdata |= AD5398_CURRENT_EN_MASK;\n\n\tret = ad5398_write_reg(client, data);\n\n\treturn ret;\n}\n\nstatic int ad5398_disable(struct regulator_dev *rdev)\n{\n\tstruct ad5398_chip_info *chip = rdev_get_drvdata(rdev);\n\tstruct i2c_client *client = chip->client;\n\tunsigned short data;\n\tint ret;\n\n\tret = ad5398_read_reg(client, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(data & AD5398_CURRENT_EN_MASK))\n\t\treturn 0;\n\n\tdata &= ~AD5398_CURRENT_EN_MASK;\n\n\tret = ad5398_write_reg(client, data);\n\n\treturn ret;\n}\n\nstatic const struct regulator_ops ad5398_ops = {\n\t.get_current_limit = ad5398_get_current_limit,\n\t.set_current_limit = ad5398_set_current_limit,\n\t.enable = ad5398_enable,\n\t.disable = ad5398_disable,\n\t.is_enabled = ad5398_is_enabled,\n};\n\nstatic const struct regulator_desc ad5398_reg = {\n\t.name = \"isink\",\n\t.id = 0,\n\t.ops = &ad5398_ops,\n\t.type = REGULATOR_CURRENT,\n\t.owner = THIS_MODULE,\n};\n\nstruct ad5398_current_data_format {\n\tint current_bits;\n\tint current_offset;\n\tint min_uA;\n\tint max_uA;\n};\n\nstatic const struct ad5398_current_data_format df_10_4_120 = {10, 4, 0, 120000};\n\nstatic const struct i2c_device_id ad5398_id[] = {\n\t{ \"ad5398\", (kernel_ulong_t)&df_10_4_120 },\n\t{ \"ad5821\", (kernel_ulong_t)&df_10_4_120 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ad5398_id);\n\nstatic int ad5398_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct regulator_init_data *init_data = dev_get_platdata(&client->dev);\n\tstruct regulator_config config = { };\n\tstruct ad5398_chip_info *chip;\n\tconst struct ad5398_current_data_format *df =\n\t\t\t(struct ad5398_current_data_format *)id->driver_data;\n\n\tif (!init_data)\n\t\treturn -EINVAL;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tconfig.dev = &client->dev;\n\tconfig.init_data = init_data;\n\tconfig.driver_data = chip;\n\n\tchip->client = client;\n\n\tchip->min_uA = df->min_uA;\n\tchip->max_uA = df->max_uA;\n\tchip->current_level = 1 << df->current_bits;\n\tchip->current_offset = df->current_offset;\n\tchip->current_mask = (chip->current_level - 1) << chip->current_offset;\n\n\tchip->rdev = devm_regulator_register(&client->dev, &ad5398_reg,\n\t\t\t\t\t     &config);\n\tif (IS_ERR(chip->rdev)) {\n\t\tdev_err(&client->dev, \"failed to register %s %s\\n\",\n\t\t\tid->name, ad5398_reg.name);\n\t\treturn PTR_ERR(chip->rdev);\n\t}\n\n\ti2c_set_clientdata(client, chip);\n\tdev_dbg(&client->dev, \"%s regulator driver is registered.\\n\", id->name);\n\treturn 0;\n}\n\nstatic struct i2c_driver ad5398_driver = {\n\t.probe = ad5398_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"ad5398\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.id_table\t= ad5398_id,\n};\n\nstatic int __init ad5398_init(void)\n{\n\treturn i2c_add_driver(&ad5398_driver);\n}\nsubsys_initcall(ad5398_init);\n\nstatic void __exit ad5398_exit(void)\n{\n\ti2c_del_driver(&ad5398_driver);\n}\nmodule_exit(ad5398_exit);\n\nMODULE_DESCRIPTION(\"AD5398 and AD5821 current regulator driver\");\nMODULE_AUTHOR(\"Sonic Zhang\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}