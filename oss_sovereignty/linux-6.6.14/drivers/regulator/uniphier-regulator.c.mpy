{
  "module_name": "uniphier-regulator.c",
  "hash_id": "7c9255793188ada3a88067319f83eb78aee615a68d544ee4841cf4d9625954e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/uniphier-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/reset.h>\n\n#define MAX_CLKS\t2\n#define MAX_RSTS\t2\n\nstruct uniphier_regulator_soc_data {\n\tint nclks;\n\tconst char * const *clock_names;\n\tint nrsts;\n\tconst char * const *reset_names;\n\tconst struct regulator_desc *desc;\n\tconst struct regmap_config *regconf;\n};\n\nstruct uniphier_regulator_priv {\n\tstruct clk_bulk_data clk[MAX_CLKS];\n\tstruct reset_control *rst[MAX_RSTS];\n\tconst struct uniphier_regulator_soc_data *data;\n};\n\nstatic const struct regulator_ops uniphier_regulator_ops = {\n\t.enable     = regulator_enable_regmap,\n\t.disable    = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n};\n\nstatic int uniphier_regulator_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_regulator_priv *priv;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tconst char *name;\n\tint i, ret, nr;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->data = of_device_get_match_data(dev);\n\tif (WARN_ON(!priv->data))\n\t\treturn -EINVAL;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tfor (i = 0; i < priv->data->nclks; i++)\n\t\tpriv->clk[i].id = priv->data->clock_names[i];\n\tret = devm_clk_bulk_get(dev, priv->data->nclks, priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < priv->data->nrsts; i++) {\n\t\tname = priv->data->reset_names[i];\n\t\tpriv->rst[i] = devm_reset_control_get_shared(dev, name);\n\t\tif (IS_ERR(priv->rst[i]))\n\t\t\treturn PTR_ERR(priv->rst[i]);\n\t}\n\n\tret = clk_bulk_prepare_enable(priv->data->nclks, priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (nr = 0; nr < priv->data->nrsts; nr++) {\n\t\tret = reset_control_deassert(priv->rst[nr]);\n\t\tif (ret)\n\t\t\tgoto out_rst_assert;\n\t}\n\n\tregmap = devm_regmap_init_mmio(dev, base, priv->data->regconf);\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tgoto out_rst_assert;\n\t}\n\n\tconfig.dev = dev;\n\tconfig.driver_data = priv;\n\tconfig.of_node = dev->of_node;\n\tconfig.regmap = regmap;\n\tconfig.init_data = of_get_regulator_init_data(dev, dev->of_node,\n\t\t\t\t\t\t      priv->data->desc);\n\trdev = devm_regulator_register(dev, priv->data->desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\t\tgoto out_rst_assert;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn 0;\n\nout_rst_assert:\n\twhile (nr--)\n\t\treset_control_assert(priv->rst[nr]);\n\n\tclk_bulk_disable_unprepare(priv->data->nclks, priv->clk);\n\n\treturn ret;\n}\n\nstatic int uniphier_regulator_remove(struct platform_device *pdev)\n{\n\tstruct uniphier_regulator_priv *priv = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < priv->data->nrsts; i++)\n\t\treset_control_assert(priv->rst[i]);\n\n\tclk_bulk_disable_unprepare(priv->data->nclks, priv->clk);\n\n\treturn 0;\n}\n\n \n#define USB3VBUS_OFFSET\t\t0x0\n#define USB3VBUS_REG\t\tBIT(4)\n#define USB3VBUS_REG_EN\t\tBIT(3)\nstatic const struct regulator_desc uniphier_usb3_regulator_desc = {\n\t.name = \"vbus\",\n\t.of_match = of_match_ptr(\"vbus\"),\n\t.ops = &uniphier_regulator_ops,\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n\t.enable_reg  = USB3VBUS_OFFSET,\n\t.enable_mask = USB3VBUS_REG_EN | USB3VBUS_REG,\n\t.enable_val  = USB3VBUS_REG_EN | USB3VBUS_REG,\n\t.disable_val = USB3VBUS_REG_EN,\n};\n\nstatic const struct regmap_config uniphier_usb3_regulator_regconf = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = 1,\n};\n\nstatic const char * const uniphier_pro4_clock_reset_names[] = {\n\t\"gio\", \"link\",\n};\n\nstatic const struct uniphier_regulator_soc_data uniphier_pro4_usb3_data = {\n\t.nclks = ARRAY_SIZE(uniphier_pro4_clock_reset_names),\n\t.clock_names = uniphier_pro4_clock_reset_names,\n\t.nrsts = ARRAY_SIZE(uniphier_pro4_clock_reset_names),\n\t.reset_names = uniphier_pro4_clock_reset_names,\n\t.desc = &uniphier_usb3_regulator_desc,\n\t.regconf = &uniphier_usb3_regulator_regconf,\n};\n\nstatic const char * const uniphier_pxs2_clock_reset_names[] = {\n\t\"link\",\n};\n\nstatic const struct uniphier_regulator_soc_data uniphier_pxs2_usb3_data = {\n\t.nclks = ARRAY_SIZE(uniphier_pxs2_clock_reset_names),\n\t.clock_names = uniphier_pxs2_clock_reset_names,\n\t.nrsts = ARRAY_SIZE(uniphier_pxs2_clock_reset_names),\n\t.reset_names = uniphier_pxs2_clock_reset_names,\n\t.desc = &uniphier_usb3_regulator_desc,\n\t.regconf = &uniphier_usb3_regulator_regconf,\n};\n\nstatic const struct of_device_id uniphier_regulator_match[] = {\n\t \n\t{\n\t\t.compatible = \"socionext,uniphier-pro4-usb3-regulator\",\n\t\t.data = &uniphier_pro4_usb3_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pro5-usb3-regulator\",\n\t\t.data = &uniphier_pro4_usb3_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs2-usb3-regulator\",\n\t\t.data = &uniphier_pxs2_usb3_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-ld20-usb3-regulator\",\n\t\t.data = &uniphier_pxs2_usb3_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs3-usb3-regulator\",\n\t\t.data = &uniphier_pxs2_usb3_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-nx1-usb3-regulator\",\n\t\t.data = &uniphier_pxs2_usb3_data,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, uniphier_regulator_match);\n\nstatic struct platform_driver uniphier_regulator_driver = {\n\t.probe = uniphier_regulator_probe,\n\t.remove = uniphier_regulator_remove,\n\t.driver = {\n\t\t.name  = \"uniphier-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = uniphier_regulator_match,\n\t},\n};\nmodule_platform_driver(uniphier_regulator_driver);\n\nMODULE_AUTHOR(\"Kunihiko Hayashi <hayashi.kunihiko@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier Regulator Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}