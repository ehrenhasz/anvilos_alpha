{
  "module_name": "rt4803.c",
  "hash_id": "2160fda3f3992c343547f56247c3a5574a114a6aa14ef1f84e7d00579da96ba9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rt4803.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n#define RT4803_AUTO_MODE\t1\n#define RT4803_FPWM_MODE\t2\n\n#define RT4803_REG_CONFIG\t0x01\n#define RT4803_REG_VSELL\t0x02\n#define RT4803_REG_VSELH\t0x03\n#define RT4803_REG_ILIM\t\t0x04\n#define RT4803_REG_STAT\t\t0x05\n\n#define RT4803_MODE_MASK\tGENMASK(1, 0)\n#define RT4803_VSEL_MASK\tGENMASK(4, 0)\n#define RT4803_ILIM_MASK\tGENMASK(3, 0)\n#define RT4803_TSD_MASK\t\tBIT(7)\n#define RT4803_HOTDIE_MASK\tBIT(6)\n#define RT4803_FAULT_MASK\tBIT(1)\n#define RT4803_PGOOD_MASK\tBIT(0)\n\n#define RT4803_VOUT_MINUV\t2850000\n#define RT4803_VOUT_STEPUV\t50000\n#define RT4803_VOUT_NUM\t\t32\n\nstatic int rt4803_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int modeval;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tmodeval = RT4803_AUTO_MODE;\n\t\tbreak;\n\tcase REGULATOR_MODE_FAST:\n\t\tmodeval = RT4803_FPWM_MODE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmodeval <<= ffs(RT4803_MODE_MASK) - 1;\n\n\treturn regmap_update_bits(regmap, RT4803_REG_CONFIG, RT4803_MODE_MASK, modeval);\n}\n\nstatic unsigned int rt4803_get_mode(struct regulator_dev *rdev)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int modeval;\n\tint ret;\n\n\tret = regmap_read(regmap, RT4803_REG_CONFIG, &modeval);\n\tif (ret)\n\t\treturn REGULATOR_MODE_INVALID;\n\n\tmodeval >>= ffs(RT4803_MODE_MASK) - 1;\n\n\tswitch (modeval) {\n\tcase RT4803_AUTO_MODE:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase RT4803_FPWM_MODE:\n\t\treturn REGULATOR_MODE_FAST;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic int rt4803_get_error_flags(struct regulator_dev *rdev, unsigned int *flags)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int state, events = 0;\n\tint ret;\n\n\tret = regmap_read(regmap, RT4803_REG_STAT, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state & RT4803_PGOOD_MASK)\n\t\tgoto out_error_flag;\n\n\tif (state & RT4803_FAULT_MASK)\n\t\tevents |= REGULATOR_ERROR_FAIL;\n\n\tif (state & RT4803_HOTDIE_MASK)\n\t\tevents |= REGULATOR_ERROR_OVER_TEMP_WARN;\n\n\tif (state & RT4803_TSD_MASK)\n\t\tevents |= REGULATOR_ERROR_OVER_TEMP;\n\nout_error_flag:\n\t*flags = events;\n\treturn 0;\n}\n\nstatic int rt4803_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int reg, vsel;\n\n\tif (rdev->desc->vsel_reg == RT4803_REG_VSELL)\n\t\treg = RT4803_REG_VSELH;\n\telse\n\t\treg = RT4803_REG_VSELL;\n\n\tvsel = (uV - rdev->desc->min_uV) / rdev->desc->uV_step;\n\tvsel <<= ffs(RT4803_VSEL_MASK) - 1;\n\n\treturn regmap_update_bits(regmap, reg, RT4803_VSEL_MASK, vsel);\n}\n\nstatic const struct regulator_ops rt4803_regulator_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_mode = rt4803_set_mode,\n\t.get_mode = rt4803_get_mode,\n\t.get_error_flags = rt4803_get_error_flags,\n\t.set_suspend_voltage = rt4803_set_suspend_voltage,\n};\n\nstatic unsigned int rt4803_of_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase RT4803_AUTO_MODE:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase RT4803_FPWM_MODE:\n\t\treturn REGULATOR_MODE_FAST;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic const struct regmap_config rt4803_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RT4803_REG_STAT,\n};\n\nstatic int rt4803_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct regmap *regmap;\n\tstruct regulator_desc *desc;\n\tstruct regulator_config cfg = {};\n\tstruct regulator_dev *rdev;\n\tbool vsel_act_high;\n\tint ret;\n\n\tdesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_i2c(i2c, &rt4803_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap), \"Failed to init regmap\\n\");\n\n\t \n\tret = regmap_update_bits(regmap, RT4803_REG_ILIM, RT4803_ILIM_MASK, 0xff);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to config ILIM to max\\n\");\n\n\tvsel_act_high = device_property_read_bool(dev, \"richtek,vsel-active-high\");\n\n\tdesc->name = \"rt4803-regulator\";\n\tdesc->type = REGULATOR_VOLTAGE;\n\tdesc->owner = THIS_MODULE;\n\tdesc->ops = &rt4803_regulator_ops;\n\tdesc->min_uV = RT4803_VOUT_MINUV;\n\tdesc->uV_step = RT4803_VOUT_STEPUV;\n\tdesc->n_voltages = RT4803_VOUT_NUM;\n\tdesc->vsel_mask = RT4803_VSEL_MASK;\n\tdesc->of_map_mode = rt4803_of_map_mode;\n\tif (vsel_act_high)\n\t\tdesc->vsel_reg = RT4803_REG_VSELH;\n\telse\n\t\tdesc->vsel_reg = RT4803_REG_VSELL;\n\n\tcfg.dev = dev;\n\tcfg.of_node = dev_of_node(dev);\n\tcfg.init_data = of_get_regulator_init_data(dev, dev_of_node(dev), desc);\n\n\trdev = devm_regulator_register(dev, desc, &cfg);\n\treturn PTR_ERR_OR_ZERO(rdev);\n}\n\nstatic const struct of_device_id rt4803_device_match_table[] = {\n\t{ .compatible = \"richtek,rt4803\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rt4803_device_match_table);\n\nstatic struct i2c_driver rt4803_driver = {\n\t.driver = {\n\t\t.name = \"rt4803\",\n\t\t.of_match_table = rt4803_device_match_table,\n\t},\n\t.probe = rt4803_probe,\n};\nmodule_i2c_driver(rt4803_driver);\n\nMODULE_DESCRIPTION(\"Richtek RT4803 voltage regulator driver\");\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}