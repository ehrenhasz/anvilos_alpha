{
  "module_name": "gpio-regulator.c",
  "hash_id": "f9d90c9b3661859ded52fac36cb9031d1cfeffb395bb4e9e8037db2e87c806b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/gpio-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regulator/gpio-regulator.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\nstruct gpio_regulator_data {\n\tstruct regulator_desc desc;\n\n\tstruct gpio_desc **gpiods;\n\tint nr_gpios;\n\n\tstruct gpio_regulator_state *states;\n\tint nr_states;\n\n\tint state;\n};\n\nstatic int gpio_regulator_get_value(struct regulator_dev *dev)\n{\n\tstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\n\tint ptr;\n\n\tfor (ptr = 0; ptr < data->nr_states; ptr++)\n\t\tif (data->states[ptr].gpios == data->state)\n\t\t\treturn data->states[ptr].value;\n\n\treturn -EINVAL;\n}\n\nstatic int gpio_regulator_set_voltage(struct regulator_dev *dev,\n\t\t\t\t\tint min_uV, int max_uV,\n\t\t\t\t\tunsigned *selector)\n{\n\tstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\n\tint ptr, target = 0, state, best_val = INT_MAX;\n\n\tfor (ptr = 0; ptr < data->nr_states; ptr++)\n\t\tif (data->states[ptr].value < best_val &&\n\t\t    data->states[ptr].value >= min_uV &&\n\t\t    data->states[ptr].value <= max_uV) {\n\t\t\ttarget = data->states[ptr].gpios;\n\t\t\tbest_val = data->states[ptr].value;\n\t\t\tif (selector)\n\t\t\t\t*selector = ptr;\n\t\t}\n\n\tif (best_val == INT_MAX)\n\t\treturn -EINVAL;\n\n\tfor (ptr = 0; ptr < data->nr_gpios; ptr++) {\n\t\tstate = (target & (1 << ptr)) >> ptr;\n\t\tgpiod_set_value_cansleep(data->gpiods[ptr], state);\n\t}\n\tdata->state = target;\n\n\treturn 0;\n}\n\nstatic int gpio_regulator_list_voltage(struct regulator_dev *dev,\n\t\t\t\t      unsigned selector)\n{\n\tstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\n\n\tif (selector >= data->nr_states)\n\t\treturn -EINVAL;\n\n\treturn data->states[selector].value;\n}\n\nstatic int gpio_regulator_set_current_limit(struct regulator_dev *dev,\n\t\t\t\t\tint min_uA, int max_uA)\n{\n\tstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\n\tint ptr, target = 0, state, best_val = 0;\n\n\tfor (ptr = 0; ptr < data->nr_states; ptr++)\n\t\tif (data->states[ptr].value > best_val &&\n\t\t    data->states[ptr].value >= min_uA &&\n\t\t    data->states[ptr].value <= max_uA) {\n\t\t\ttarget = data->states[ptr].gpios;\n\t\t\tbest_val = data->states[ptr].value;\n\t\t}\n\n\tif (best_val == 0)\n\t\treturn -EINVAL;\n\n\tfor (ptr = 0; ptr < data->nr_gpios; ptr++) {\n\t\tstate = (target & (1 << ptr)) >> ptr;\n\t\tgpiod_set_value_cansleep(data->gpiods[ptr], state);\n\t}\n\tdata->state = target;\n\n\treturn 0;\n}\n\nstatic const struct regulator_ops gpio_regulator_voltage_ops = {\n\t.get_voltage = gpio_regulator_get_value,\n\t.set_voltage = gpio_regulator_set_voltage,\n\t.list_voltage = gpio_regulator_list_voltage,\n};\n\nstatic struct gpio_regulator_config *\nof_get_gpio_regulator_config(struct device *dev, struct device_node *np,\n\t\t\t     const struct regulator_desc *desc)\n{\n\tstruct gpio_regulator_config *config;\n\tconst char *regtype;\n\tint proplen, i;\n\tint ngpios;\n\tint ret;\n\n\tconfig = devm_kzalloc(dev,\n\t\t\tsizeof(struct gpio_regulator_config),\n\t\t\tGFP_KERNEL);\n\tif (!config)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconfig->init_data = of_get_regulator_init_data(dev, np, desc);\n\tif (!config->init_data)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tconfig->supply_name = config->init_data->constraints.name;\n\n\tif (config->init_data->constraints.boot_on)\n\t\tconfig->enabled_at_boot = true;\n\n\t \n\tif (of_property_read_bool(np, \"enable-at-boot\"))\n\t\tconfig->enabled_at_boot = true;\n\n\tof_property_read_u32(np, \"startup-delay-us\", &config->startup_delay);\n\n\t \n\tngpios = gpiod_count(dev, NULL);\n\tif (ngpios > 0) {\n\t\tconfig->gflags = devm_kzalloc(dev,\n\t\t\t\t\t      sizeof(enum gpiod_flags)\n\t\t\t\t\t      * ngpios,\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!config->gflags)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tfor (i = 0; i < ngpios; i++) {\n\t\t\tu32 val;\n\n\t\t\tret = of_property_read_u32_index(np, \"gpios-states\", i,\n\t\t\t\t\t\t\t &val);\n\n\t\t\t \n\t\t\tif (ret)\n\t\t\t\tconfig->gflags[i] = GPIOD_OUT_HIGH;\n\t\t\telse\n\t\t\t\tconfig->gflags[i] =\n\t\t\t\t\tval ? GPIOD_OUT_HIGH : GPIOD_OUT_LOW;\n\t\t}\n\t}\n\tconfig->ngpios = ngpios;\n\n\t \n\tproplen = of_property_count_u32_elems(np, \"states\");\n\tif (proplen < 0) {\n\t\tdev_err(dev, \"No 'states' property found\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tconfig->states = devm_kcalloc(dev,\n\t\t\t\tproplen / 2,\n\t\t\t\tsizeof(struct gpio_regulator_state),\n\t\t\t\tGFP_KERNEL);\n\tif (!config->states)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < proplen / 2; i++) {\n\t\tof_property_read_u32_index(np, \"states\", i * 2,\n\t\t\t\t\t   &config->states[i].value);\n\t\tof_property_read_u32_index(np, \"states\", i * 2 + 1,\n\t\t\t\t\t   &config->states[i].gpios);\n\t}\n\tconfig->nr_states = i;\n\n\tconfig->type = REGULATOR_VOLTAGE;\n\tret = of_property_read_string(np, \"regulator-type\", &regtype);\n\tif (ret >= 0) {\n\t\tif (!strncmp(\"voltage\", regtype, 7))\n\t\t\tconfig->type = REGULATOR_VOLTAGE;\n\t\telse if (!strncmp(\"current\", regtype, 7))\n\t\t\tconfig->type = REGULATOR_CURRENT;\n\t\telse\n\t\t\tdev_warn(dev, \"Unknown regulator-type '%s'\\n\",\n\t\t\t\t regtype);\n\t}\n\n\tif (of_property_present(np, \"vin-supply\"))\n\t\tconfig->input_supply = \"vin\";\n\n\treturn config;\n}\n\nstatic const struct regulator_ops gpio_regulator_current_ops = {\n\t.get_current_limit = gpio_regulator_get_value,\n\t.set_current_limit = gpio_regulator_set_current_limit,\n};\n\nstatic int gpio_regulator_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct gpio_regulator_config *config = dev_get_platdata(dev);\n\tstruct device_node *np = dev->of_node;\n\tstruct gpio_regulator_data *drvdata;\n\tstruct regulator_config cfg = { };\n\tstruct regulator_dev *rdev;\n\tenum gpiod_flags gflags;\n\tint ptr, ret, state, i;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(struct gpio_regulator_data),\n\t\t\t       GFP_KERNEL);\n\tif (drvdata == NULL)\n\t\treturn -ENOMEM;\n\n\tif (np) {\n\t\tconfig = of_get_gpio_regulator_config(dev, np,\n\t\t\t\t\t\t      &drvdata->desc);\n\t\tif (IS_ERR(config))\n\t\t\treturn PTR_ERR(config);\n\t}\n\n\tdrvdata->desc.name = devm_kstrdup(dev, config->supply_name, GFP_KERNEL);\n\tif (drvdata->desc.name == NULL) {\n\t\tdev_err(dev, \"Failed to allocate supply name\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdrvdata->gpiods = devm_kzalloc(dev, sizeof(struct gpio_desc *),\n\t\t\t\t       GFP_KERNEL);\n\n\tif (config->input_supply) {\n\t\tdrvdata->desc.supply_name = devm_kstrdup(&pdev->dev,\n\t\t\t\t\t\t\t config->input_supply,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!drvdata->desc.supply_name) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to allocate input supply\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (!drvdata->gpiods)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < config->ngpios; i++) {\n\t\tdrvdata->gpiods[i] = devm_gpiod_get_index(dev,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  i,\n\t\t\t\t\t\t\t  config->gflags[i]);\n\t\tif (IS_ERR(drvdata->gpiods[i]))\n\t\t\treturn PTR_ERR(drvdata->gpiods[i]);\n\t\t \n\t\tgpiod_set_consumer_name(drvdata->gpiods[i], drvdata->desc.name);\n\t}\n\tdrvdata->nr_gpios = config->ngpios;\n\n\tdrvdata->states = devm_kmemdup(dev,\n\t\t\t\t       config->states,\n\t\t\t\t       config->nr_states *\n\t\t\t\t       sizeof(struct gpio_regulator_state),\n\t\t\t\t       GFP_KERNEL);\n\tif (drvdata->states == NULL) {\n\t\tdev_err(dev, \"Failed to allocate state data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdrvdata->nr_states = config->nr_states;\n\n\tdrvdata->desc.owner = THIS_MODULE;\n\tdrvdata->desc.enable_time = config->startup_delay;\n\n\t \n\tswitch (config->type) {\n\tcase REGULATOR_VOLTAGE:\n\t\tdrvdata->desc.type = REGULATOR_VOLTAGE;\n\t\tdrvdata->desc.ops = &gpio_regulator_voltage_ops;\n\t\tdrvdata->desc.n_voltages = config->nr_states;\n\t\tbreak;\n\tcase REGULATOR_CURRENT:\n\t\tdrvdata->desc.type = REGULATOR_CURRENT;\n\t\tdrvdata->desc.ops = &gpio_regulator_current_ops;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"No regulator type set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tstate = 0;\n\tfor (ptr = 0; ptr < drvdata->nr_gpios; ptr++) {\n\t\tif (config->gflags[ptr] == GPIOD_OUT_HIGH)\n\t\t\tstate |= (1 << ptr);\n\t}\n\tdrvdata->state = state;\n\n\tcfg.dev = dev;\n\tcfg.init_data = config->init_data;\n\tcfg.driver_data = drvdata;\n\tcfg.of_node = np;\n\n\t \n\tif (config->enabled_at_boot)\n\t\tgflags = GPIOD_OUT_HIGH | GPIOD_FLAGS_BIT_NONEXCLUSIVE;\n\telse\n\t\tgflags = GPIOD_OUT_LOW | GPIOD_FLAGS_BIT_NONEXCLUSIVE;\n\n\tcfg.ena_gpiod = gpiod_get_optional(dev, \"enable\", gflags);\n\tif (IS_ERR(cfg.ena_gpiod))\n\t\treturn PTR_ERR(cfg.ena_gpiod);\n\n\trdev = devm_regulator_register(dev, &drvdata->desc, &cfg);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\t\tdev_err(dev, \"Failed to register regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, drvdata);\n\n\treturn 0;\n}\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id regulator_gpio_of_match[] = {\n\t{ .compatible = \"regulator-gpio\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, regulator_gpio_of_match);\n#endif\n\nstatic struct platform_driver gpio_regulator_driver = {\n\t.probe\t\t= gpio_regulator_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"gpio-regulator\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(regulator_gpio_of_match),\n\t},\n};\n\nstatic int __init gpio_regulator_init(void)\n{\n\treturn platform_driver_register(&gpio_regulator_driver);\n}\nsubsys_initcall(gpio_regulator_init);\n\nstatic void __exit gpio_regulator_exit(void)\n{\n\tplatform_driver_unregister(&gpio_regulator_driver);\n}\nmodule_exit(gpio_regulator_exit);\n\nMODULE_AUTHOR(\"Heiko Stuebner <heiko@sntech.de>\");\nMODULE_DESCRIPTION(\"gpio voltage regulator\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:gpio-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}