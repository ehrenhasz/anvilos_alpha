{
  "module_name": "da9121-regulator.c",
  "hash_id": "88e809e3558884f77138c1293980d81ff950ce48c110529002fa0132d5ed0a45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/da9121-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/driver.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/regulator/da9121.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n\n#include \"da9121-regulator.h\"\n\n \nstruct da9121 {\n\tstruct device *dev;\n\tstruct delayed_work work;\n\tstruct da9121_pdata *pdata;\n\tstruct regmap *regmap;\n\tstruct regulator_dev *rdev[DA9121_IDX_MAX];\n\tunsigned int persistent[2];\n\tunsigned int passive_delay;\n\tint chip_irq;\n\tint variant_id;\n\tint subvariant_id;\n};\n\n \nstruct da9121_range {\n\tint val_min;\n\tint val_max;\n\tint val_stp;\n\tint reg_min;\n\tint reg_max;\n};\n\nstatic struct da9121_range da9121_10A_2phase_current = {\n\t.val_min =  7000000,\n\t.val_max = 20000000,\n\t.val_stp =  1000000,\n\t.reg_min = 1,\n\t.reg_max = 14,\n};\n\nstatic struct da9121_range da9121_6A_2phase_current = {\n\t.val_min =  7000000,\n\t.val_max = 12000000,\n\t.val_stp =  1000000,\n\t.reg_min = 1,\n\t.reg_max = 6,\n};\n\nstatic struct da9121_range da9121_5A_1phase_current = {\n\t.val_min =  3500000,\n\t.val_max = 10000000,\n\t.val_stp =   500000,\n\t.reg_min = 1,\n\t.reg_max = 14,\n};\n\nstatic struct da9121_range da9121_3A_1phase_current = {\n\t.val_min = 3500000,\n\t.val_max = 6000000,\n\t.val_stp =  500000,\n\t.reg_min = 1,\n\t.reg_max = 6,\n};\n\nstatic struct da9121_range da914x_40A_4phase_current = {\n\t.val_min = 26000000,\n\t.val_max = 78000000,\n\t.val_stp =  4000000,\n\t.reg_min = 1,\n\t.reg_max = 14,\n};\n\nstatic struct da9121_range da914x_20A_2phase_current = {\n\t.val_min = 13000000,\n\t.val_max = 39000000,\n\t.val_stp =  2000000,\n\t.reg_min = 1,\n\t.reg_max = 14,\n};\n\nstruct da9121_variant_info {\n\tint num_bucks;\n\tint num_phases;\n\tstruct da9121_range *current_range;\n};\n\nstatic const struct da9121_variant_info variant_parameters[] = {\n\t{ 1, 2, &da9121_10A_2phase_current },\t\n\t{ 2, 1, &da9121_3A_1phase_current  },\t\n\t{ 2, 1, &da9121_5A_1phase_current  },\t\n\t{ 1, 2, &da9121_6A_2phase_current  },\t\n\t{ 1, 4, &da914x_40A_4phase_current },   \n\t{ 1, 2, &da914x_20A_2phase_current },   \n};\n\nstruct da9121_field {\n\tunsigned int reg;\n\tunsigned int msk;\n};\n\nstatic const struct da9121_field da9121_current_field[2] = {\n\t{ DA9121_REG_BUCK_BUCK1_2, DA9121_MASK_BUCK_BUCKx_2_CHx_ILIM },\n\t{ DA9xxx_REG_BUCK_BUCK2_2, DA9121_MASK_BUCK_BUCKx_2_CHx_ILIM },\n};\n\nstatic const struct da9121_field da9121_mode_field[2] = {\n\t{ DA9121_REG_BUCK_BUCK1_4, DA9121_MASK_BUCK_BUCKx_4_CHx_A_MODE },\n\t{ DA9xxx_REG_BUCK_BUCK2_4, DA9121_MASK_BUCK_BUCKx_4_CHx_A_MODE },\n};\n\nstruct status_event_data {\n\tint buck_id;  \n\tint reg_index;   \n\tint status_bit;  \n\tint event_bit;\n\tint mask_bit;\n\tunsigned long notification;  \n\tchar *warn;  \n};\n\n#define DA9121_STATUS(id, bank, name, notification, warning) \\\n\t{ id, bank, \\\n\tDA9121_MASK_SYS_STATUS_##bank##_##name, \\\n\tDA9121_MASK_SYS_EVENT_##bank##_E_##name, \\\n\tDA9121_MASK_SYS_MASK_##bank##_M_##name, \\\n\tnotification, warning }\n\n \n#define DA9xxx_STATUS(id, bank, name, notification, warning) \\\n\t{ id, bank, \\\n\tDA9xxx_MASK_SYS_STATUS_##bank##_##name, \\\n\tDA9xxx_MASK_SYS_EVENT_##bank##_E_##name, \\\n\tDA9xxx_MASK_SYS_MASK_##bank##_M_##name, \\\n\tnotification, warning }\n\n \nstatic const struct status_event_data status_event_handling[] = {\n\tDA9xxx_STATUS(0, 0, SG, 0, \"Handled E_SG\\n\"),\n\tDA9121_STATUS(0, 0, TEMP_CRIT, (REGULATOR_EVENT_OVER_TEMP|REGULATOR_EVENT_DISABLE), NULL),\n\tDA9121_STATUS(0, 0, TEMP_WARN, REGULATOR_EVENT_OVER_TEMP, NULL),\n\tDA9121_STATUS(1, 1, PG1, 0, \"Handled E_PG1\\n\"),\n\tDA9121_STATUS(1, 1, OV1, REGULATOR_EVENT_REGULATION_OUT, NULL),\n\tDA9121_STATUS(1, 1, UV1, REGULATOR_EVENT_UNDER_VOLTAGE, NULL),\n\tDA9121_STATUS(1, 1, OC1, REGULATOR_EVENT_OVER_CURRENT, NULL),\n\tDA9xxx_STATUS(2, 1, PG2, 0, \"Handled E_PG2\\n\"),\n\tDA9xxx_STATUS(2, 1, OV2, REGULATOR_EVENT_REGULATION_OUT, NULL),\n\tDA9xxx_STATUS(2, 1, UV2, REGULATOR_EVENT_UNDER_VOLTAGE, NULL),\n\tDA9xxx_STATUS(2, 1, OC2, REGULATOR_EVENT_OVER_CURRENT, NULL),\n\tDA9121_STATUS(0, 2, GPIO0, 0, \"Handled E_GPIO0\\n\"),\n\tDA9121_STATUS(0, 2, GPIO1, 0, \"Handled E_GPIO1\\n\"),\n\tDA9121_STATUS(0, 2, GPIO2, 0, \"Handled E_GPIO2\\n\"),\n};\n\nstatic int da9121_get_current_limit(struct regulator_dev *rdev)\n{\n\tstruct da9121 *chip = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\tstruct da9121_range *range =\n\t\tvariant_parameters[chip->variant_id].current_range;\n\tunsigned int val = 0;\n\tint ret = 0;\n\n\tret = regmap_read(chip->regmap, da9121_current_field[id].reg, &val);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Cannot read BUCK register: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tif (val < range->reg_min) {\n\t\tret = -EACCES;\n\t\tgoto error;\n\t}\n\n\tif (val > range->reg_max) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\treturn range->val_min + (range->val_stp * (val - range->reg_min));\nerror:\n\treturn ret;\n}\n\nstatic int da9121_ceiling_selector(struct regulator_dev *rdev,\n\t\tint min, int max,\n\t\tunsigned int *selector)\n{\n\tstruct da9121 *chip = rdev_get_drvdata(rdev);\n\tstruct da9121_range *range =\n\t\tvariant_parameters[chip->variant_id].current_range;\n\tunsigned int level;\n\tunsigned int i = 0;\n\tunsigned int sel = 0;\n\tint ret = 0;\n\n\tif (range->val_min > max || range->val_max < min) {\n\t\tdev_err(chip->dev,\n\t\t\t\"Requested current out of regulator capability\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tlevel = range->val_max;\n\tfor (i = range->reg_max; i >= range->reg_min; i--) {\n\t\tif (level <= max) {\n\t\t\tsel = i;\n\t\t\tbreak;\n\t\t}\n\t\tlevel -= range->val_stp;\n\t}\n\n\tif (level < min) {\n\t\tdev_err(chip->dev,\n\t\t\t\"Best match falls below minimum requested current\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t*selector = sel;\nerror:\n\treturn ret;\n}\n\nstatic int da9121_set_current_limit(struct regulator_dev *rdev,\n\t\t\t\tint min_ua, int max_ua)\n{\n\tstruct da9121 *chip = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\tstruct da9121_range *range =\n\t\tvariant_parameters[chip->variant_id].current_range;\n\tunsigned int sel = 0;\n\tint ret = 0;\n\n\tif (min_ua < range->val_min ||\n\t    max_ua > range->val_max) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (rdev->desc->ops->is_enabled(rdev)) {\n\t\tret = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tret = da9121_ceiling_selector(rdev, min_ua, max_ua, &sel);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = regmap_update_bits(chip->regmap,\n\t\t\t\tda9121_current_field[id].reg,\n\t\t\t\tda9121_current_field[id].msk,\n\t\t\t\t(unsigned int)sel);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Cannot update BUCK current limit, err: %d\\n\", ret);\n\nerror:\n\treturn ret;\n}\n\nstatic unsigned int da9121_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase DA9121_BUCK_MODE_FORCE_PWM:\n\t\treturn REGULATOR_MODE_FAST;\n\tcase DA9121_BUCK_MODE_FORCE_PWM_SHEDDING:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase DA9121_BUCK_MODE_AUTO:\n\t\treturn REGULATOR_MODE_IDLE;\n\tcase DA9121_BUCK_MODE_FORCE_PFM:\n\t\treturn REGULATOR_MODE_STANDBY;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic int da9121_buck_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct da9121 *chip = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\tunsigned int val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tval = DA9121_BUCK_MODE_FORCE_PWM;\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = DA9121_BUCK_MODE_FORCE_PWM_SHEDDING;\n\t\tbreak;\n\tcase REGULATOR_MODE_IDLE:\n\t\tval = DA9121_BUCK_MODE_AUTO;\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tval = DA9121_BUCK_MODE_FORCE_PFM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(chip->regmap,\n\t\t\t\t  da9121_mode_field[id].reg,\n\t\t\t\t  da9121_mode_field[id].msk,\n\t\t\t\t  val);\n}\n\nstatic unsigned int da9121_buck_get_mode(struct regulator_dev *rdev)\n{\n\tstruct da9121 *chip = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\tunsigned int val, mode;\n\tint ret = 0;\n\n\tret = regmap_read(chip->regmap, da9121_mode_field[id].reg, &val);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Cannot read BUCK register: %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tmode = da9121_map_mode(val & da9121_mode_field[id].msk);\n\tif (mode == REGULATOR_MODE_INVALID)\n\t\treturn -EINVAL;\n\n\treturn mode;\n}\n\nstatic const struct regulator_ops da9121_buck_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.get_current_limit = da9121_get_current_limit,\n\t.set_current_limit = da9121_set_current_limit,\n\t.set_mode = da9121_buck_set_mode,\n\t.get_mode = da9121_buck_get_mode,\n};\n\nstatic struct of_regulator_match da9121_matches[] = {\n\t[DA9121_IDX_BUCK1] = { .name = \"buck1\" },\n\t[DA9121_IDX_BUCK2] = { .name = \"buck2\" },\n};\n\nstatic int da9121_of_parse_cb(struct device_node *np,\n\t\t\t\tconst struct regulator_desc *desc,\n\t\t\t\tstruct regulator_config *config)\n{\n\tstruct da9121 *chip = config->driver_data;\n\tstruct da9121_pdata *pdata;\n\tstruct gpio_desc *ena_gpiod;\n\n\tif (chip->pdata == NULL) {\n\t\tpdata = devm_kzalloc(chip->dev, sizeof(*pdata), GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tpdata = chip->pdata;\n\t}\n\n\tpdata->num_buck++;\n\n\tif (pdata->num_buck > variant_parameters[chip->variant_id].num_bucks) {\n\t\tdev_err(chip->dev, \"Error: excessive regulators for device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tena_gpiod = fwnode_gpiod_get_index(of_fwnode_handle(np), \"enable\", 0,\n\t\t\t\t\t\tGPIOD_OUT_HIGH |\n\t\t\t\t\t\tGPIOD_FLAGS_BIT_NONEXCLUSIVE,\n\t\t\t\t\t\t\"da9121-enable\");\n\tif (!IS_ERR(ena_gpiod))\n\t\tconfig->ena_gpiod = ena_gpiod;\n\n\tif (variant_parameters[chip->variant_id].num_bucks == 2) {\n\t\tuint32_t ripple_cancel;\n\t\tuint32_t ripple_reg;\n\t\tint ret;\n\n\t\tif (of_property_read_u32(da9121_matches[pdata->num_buck-1].of_node,\n\t\t\t\t\"dlg,ripple-cancel\", &ripple_cancel)) {\n\t\t\tif (pdata->num_buck > 1)\n\t\t\t\tripple_reg = DA9xxx_REG_BUCK_BUCK2_7;\n\t\t\telse\n\t\t\t\tripple_reg = DA9121_REG_BUCK_BUCK1_7;\n\n\t\t\tret = regmap_update_bits(chip->regmap, ripple_reg,\n\t\t\t\tDA9xxx_MASK_BUCK_BUCKx_7_CHx_RIPPLE_CANCEL,\n\t\t\t\tripple_cancel);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(chip->dev, \"Cannot set ripple mode, err: %d\\n\", ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define DA9121_MIN_MV\t\t300\n#define DA9121_MAX_MV\t\t1900\n#define DA9121_STEP_MV\t\t10\n#define DA9121_MIN_SEL\t\t(DA9121_MIN_MV / DA9121_STEP_MV)\n#define DA9121_N_VOLTAGES\t(((DA9121_MAX_MV - DA9121_MIN_MV) / DA9121_STEP_MV) \\\n\t\t\t\t + 1 + DA9121_MIN_SEL)\n\nstatic const struct regulator_desc da9121_reg = {\n\t.id = DA9121_IDX_BUCK1,\n\t.name = \"da9121\",\n\t.of_match = \"buck1\",\n\t.of_parse_cb = da9121_of_parse_cb,\n\t.owner = THIS_MODULE,\n\t.regulators_node = \"regulators\",\n\t.of_map_mode = da9121_map_mode,\n\t.ops = &da9121_buck_ops,\n\t.type = REGULATOR_VOLTAGE,\n\t.n_voltages = DA9121_N_VOLTAGES,\n\t.min_uV = DA9121_MIN_MV * 1000,\n\t.uV_step = DA9121_STEP_MV * 1000,\n\t.linear_min_sel = DA9121_MIN_SEL,\n\t.vsel_reg = DA9121_REG_BUCK_BUCK1_5,\n\t.vsel_mask = DA9121_MASK_BUCK_BUCKx_5_CHx_A_VOUT,\n\t.enable_reg = DA9121_REG_BUCK_BUCK1_0,\n\t.enable_mask = DA9121_MASK_BUCK_BUCKx_0_CHx_EN,\n\t \n\t.ramp_delay = 20000,\n\t \n\t.enable_time = 20,\n};\n\nstatic const struct regulator_desc da9220_reg[2] = {\n\t{\n\t\t.id = DA9121_IDX_BUCK1,\n\t\t.name = \"DA9220/DA9132 BUCK1\",\n\t\t.of_match = \"buck1\",\n\t\t.of_parse_cb = da9121_of_parse_cb,\n\t\t.owner = THIS_MODULE,\n\t\t.regulators_node = \"regulators\",\n\t\t.of_map_mode = da9121_map_mode,\n\t\t.ops = &da9121_buck_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = DA9121_N_VOLTAGES,\n\t\t.min_uV = DA9121_MIN_MV * 1000,\n\t\t.uV_step = DA9121_STEP_MV * 1000,\n\t\t.linear_min_sel = DA9121_MIN_SEL,\n\t\t.enable_reg = DA9121_REG_BUCK_BUCK1_0,\n\t\t.enable_mask = DA9121_MASK_BUCK_BUCKx_0_CHx_EN,\n\t\t.vsel_reg = DA9121_REG_BUCK_BUCK1_5,\n\t\t.vsel_mask = DA9121_MASK_BUCK_BUCKx_5_CHx_A_VOUT,\n\t},\n\t{\n\t\t.id = DA9121_IDX_BUCK2,\n\t\t.name = \"DA9220/DA9132 BUCK2\",\n\t\t.of_match = \"buck2\",\n\t\t.of_parse_cb = da9121_of_parse_cb,\n\t\t.owner = THIS_MODULE,\n\t\t.regulators_node = \"regulators\",\n\t\t.of_map_mode = da9121_map_mode,\n\t\t.ops = &da9121_buck_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = DA9121_N_VOLTAGES,\n\t\t.min_uV = DA9121_MIN_MV * 1000,\n\t\t.uV_step = DA9121_STEP_MV * 1000,\n\t\t.linear_min_sel = DA9121_MIN_SEL,\n\t\t.enable_reg = DA9xxx_REG_BUCK_BUCK2_0,\n\t\t.enable_mask = DA9121_MASK_BUCK_BUCKx_0_CHx_EN,\n\t\t.vsel_reg = DA9xxx_REG_BUCK_BUCK2_5,\n\t\t.vsel_mask = DA9121_MASK_BUCK_BUCKx_5_CHx_A_VOUT,\n\t}\n};\n\nstatic const struct regulator_desc da9122_reg[2] = {\n\t{\n\t\t.id = DA9121_IDX_BUCK1,\n\t\t.name = \"DA9122/DA9131 BUCK1\",\n\t\t.of_match = \"buck1\",\n\t\t.of_parse_cb = da9121_of_parse_cb,\n\t\t.owner = THIS_MODULE,\n\t\t.regulators_node = \"regulators\",\n\t\t.of_map_mode = da9121_map_mode,\n\t\t.ops = &da9121_buck_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = DA9121_N_VOLTAGES,\n\t\t.min_uV = DA9121_MIN_MV * 1000,\n\t\t.uV_step = DA9121_STEP_MV * 1000,\n\t\t.linear_min_sel = DA9121_MIN_SEL,\n\t\t.enable_reg = DA9121_REG_BUCK_BUCK1_0,\n\t\t.enable_mask = DA9121_MASK_BUCK_BUCKx_0_CHx_EN,\n\t\t.vsel_reg = DA9121_REG_BUCK_BUCK1_5,\n\t\t.vsel_mask = DA9121_MASK_BUCK_BUCKx_5_CHx_A_VOUT,\n\t},\n\t{\n\t\t.id = DA9121_IDX_BUCK2,\n\t\t.name = \"DA9122/DA9131 BUCK2\",\n\t\t.of_match = \"buck2\",\n\t\t.of_parse_cb = da9121_of_parse_cb,\n\t\t.owner = THIS_MODULE,\n\t\t.regulators_node = \"regulators\",\n\t\t.of_map_mode = da9121_map_mode,\n\t\t.ops = &da9121_buck_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = DA9121_N_VOLTAGES,\n\t\t.min_uV = DA9121_MIN_MV * 1000,\n\t\t.uV_step = DA9121_STEP_MV * 1000,\n\t\t.linear_min_sel = DA9121_MIN_SEL,\n\t\t.enable_reg = DA9xxx_REG_BUCK_BUCK2_0,\n\t\t.enable_mask = DA9121_MASK_BUCK_BUCKx_0_CHx_EN,\n\t\t.vsel_reg = DA9xxx_REG_BUCK_BUCK2_5,\n\t\t.vsel_mask = DA9121_MASK_BUCK_BUCKx_5_CHx_A_VOUT,\n\t}\n};\n\nstatic const struct regulator_desc da9217_reg = {\n\t.id = DA9121_IDX_BUCK1,\n\t.name = \"DA9217 BUCK1\",\n\t.of_match = \"buck1\",\n\t.of_parse_cb = da9121_of_parse_cb,\n\t.owner = THIS_MODULE,\n\t.regulators_node = \"regulators\",\n\t.of_map_mode = da9121_map_mode,\n\t.ops = &da9121_buck_ops,\n\t.type = REGULATOR_VOLTAGE,\n\t.n_voltages = DA9121_N_VOLTAGES,\n\t.min_uV = DA9121_MIN_MV * 1000,\n\t.uV_step = DA9121_STEP_MV * 1000,\n\t.linear_min_sel = DA9121_MIN_SEL,\n\t.enable_reg = DA9121_REG_BUCK_BUCK1_0,\n\t.enable_mask = DA9121_MASK_BUCK_BUCKx_0_CHx_EN,\n\t.vsel_reg = DA9121_REG_BUCK_BUCK1_5,\n\t.vsel_mask = DA9121_MASK_BUCK_BUCKx_5_CHx_A_VOUT,\n};\n\n#define DA914X_MIN_MV\t\t500\n#define DA914X_MAX_MV\t\t1300\n#define DA914X_STEP_MV\t\t10\n#define DA914X_MIN_SEL\t\t(DA914X_MIN_MV / DA914X_STEP_MV)\n#define DA914X_N_VOLTAGES\t(((DA914X_MAX_MV - DA914X_MIN_MV) / DA914X_STEP_MV) \\\n\t\t\t\t + 1 + DA914X_MIN_SEL)\n\nstatic const struct regulator_desc da9141_reg = {\n\t.id = DA9121_IDX_BUCK1,\n\t.name = \"DA9141\",\n\t.of_match = \"buck1\",\n\t.of_parse_cb = da9121_of_parse_cb,\n\t.owner = THIS_MODULE,\n\t.regulators_node = \"regulators\",\n\t.of_map_mode = da9121_map_mode,\n\t.ops = &da9121_buck_ops,\n\t.type = REGULATOR_VOLTAGE,\n\t.n_voltages = DA914X_N_VOLTAGES,\n\t.min_uV = DA914X_MIN_MV * 1000,\n\t.uV_step = DA914X_STEP_MV * 1000,\n\t.linear_min_sel = DA914X_MIN_SEL,\n\t.vsel_reg = DA9121_REG_BUCK_BUCK1_5,\n\t.vsel_mask = DA9121_MASK_BUCK_BUCKx_5_CHx_A_VOUT,\n\t.enable_reg = DA9121_REG_BUCK_BUCK1_0,\n\t.enable_mask = DA9121_MASK_BUCK_BUCKx_0_CHx_EN,\n};\n\nstatic const struct regulator_desc da9142_reg = {\n\t.id = DA9121_IDX_BUCK1,\n\t.name = \"DA9142 BUCK1\",\n\t.of_match = \"buck1\",\n\t.of_parse_cb = da9121_of_parse_cb,\n\t.owner = THIS_MODULE,\n\t.regulators_node = \"regulators\",\n\t.of_map_mode = da9121_map_mode,\n\t.ops = &da9121_buck_ops,\n\t.type = REGULATOR_VOLTAGE,\n\t.n_voltages = DA914X_N_VOLTAGES,\n\t.min_uV = DA914X_MIN_MV * 1000,\n\t.uV_step = DA914X_STEP_MV * 1000,\n\t.linear_min_sel = DA914X_MIN_SEL,\n\t.enable_reg = DA9121_REG_BUCK_BUCK1_0,\n\t.enable_mask = DA9121_MASK_BUCK_BUCKx_0_CHx_EN,\n\t.vsel_reg = DA9121_REG_BUCK_BUCK1_5,\n\t.vsel_mask = DA9121_MASK_BUCK_BUCKx_5_CHx_A_VOUT,\n};\n\n\nstatic const struct regulator_desc *local_da9121_regulators[][DA9121_IDX_MAX] = {\n\t[DA9121_TYPE_DA9121_DA9130] = { &da9121_reg, NULL },\n\t[DA9121_TYPE_DA9220_DA9132] = { &da9220_reg[0], &da9220_reg[1] },\n\t[DA9121_TYPE_DA9122_DA9131] = { &da9122_reg[0], &da9122_reg[1] },\n\t[DA9121_TYPE_DA9217] = { &da9217_reg, NULL },\n\t[DA9121_TYPE_DA9141] = { &da9141_reg, NULL },\n\t[DA9121_TYPE_DA9142] = { &da9142_reg, NULL },\n};\n\nstatic void da9121_status_poll_on(struct work_struct *work)\n{\n\tstruct da9121 *chip = container_of(work, struct da9121, work.work);\n\tint status[3] = {0};\n\tint clear[3] = {0};\n\tunsigned long delay;\n\tint i;\n\tint ret;\n\n\tret = regmap_bulk_read(chip->regmap, DA9121_REG_SYS_STATUS_0, status, 2);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev,\n\t\t\t\"Failed to read STATUS registers: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(status_event_handling); i++) {\n\t\tconst struct status_event_data *item = &status_event_handling[i];\n\t\tint reg_idx = item->reg_index;\n\t\tbool relevant = (item->buck_id <= variant_parameters[chip->variant_id].num_bucks);\n\t\tbool supported = (item->warn == NULL);\n\t\tbool persisting = (chip->persistent[reg_idx] & item->event_bit);\n\t\tbool now_cleared = !(status[reg_idx] & item->status_bit);\n\n\t\tif (relevant && supported && persisting && now_cleared) {\n\t\t\tclear[reg_idx] |= item->mask_bit;\n\t\t\tchip->persistent[reg_idx] &= ~item->event_bit;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (clear[i]) {\n\t\t\tunsigned int reg = DA9121_REG_SYS_MASK_0 + i;\n\t\t\tunsigned int mbit = clear[i];\n\n\t\t\tret = regmap_update_bits(chip->regmap, reg, mbit, 0);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(chip->dev,\n\t\t\t\t\t\"Failed to unmask 0x%02x %d\\n\",\n\t\t\t\t\treg, ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (chip->persistent[0] | chip->persistent[1]) {\n\t\tdelay = msecs_to_jiffies(chip->passive_delay);\n\t\tqueue_delayed_work(system_freezable_wq, &chip->work, delay);\n\t}\n\nerror:\n\treturn;\n}\n\nstatic irqreturn_t da9121_irq_handler(int irq, void *data)\n{\n\tstruct da9121 *chip = data;\n\tstruct regulator_dev *rdev;\n\tint event[3] = {0};\n\tint handled[3] = {0};\n\tint mask[3] = {0};\n\tint ret = IRQ_NONE;\n\tint i;\n\tint err;\n\n\terr = regmap_bulk_read(chip->regmap, DA9121_REG_SYS_EVENT_0, event, 3);\n\tif (err < 0) {\n\t\tdev_err(chip->dev, \"Failed to read EVENT registers %d\\n\", err);\n\t\tret = IRQ_NONE;\n\t\tgoto error;\n\t}\n\n\terr = regmap_bulk_read(chip->regmap, DA9121_REG_SYS_MASK_0, mask, 3);\n\tif (err < 0) {\n\t\tdev_err(chip->dev,\n\t\t\t\"Failed to read MASK registers: %d\\n\", ret);\n\t\tret = IRQ_NONE;\n\t\tgoto error;\n\t}\n\n\trdev = chip->rdev[DA9121_IDX_BUCK1];\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(status_event_handling); i++) {\n\t\tconst struct status_event_data *item = &status_event_handling[i];\n\t\tint reg_idx = item->reg_index;\n\t\tbool relevant = (item->buck_id <= variant_parameters[chip->variant_id].num_bucks);\n\t\tbool enabled = !(mask[reg_idx] & item->mask_bit);\n\t\tbool active = (event[reg_idx] & item->event_bit);\n\t\tbool notify = (item->warn == NULL);\n\n\t\tif (relevant && enabled && active) {\n\t\t\tif (notify) {\n\t\t\t\tchip->persistent[reg_idx] |= item->event_bit;\n\t\t\t\tregulator_notifier_call_chain(rdev, item->notification, NULL);\n\t\t\t} else {\n\t\t\t\tdev_warn(chip->dev, item->warn);\n\t\t\t\thandled[reg_idx] |= item->event_bit;\n\t\t\t\tret = IRQ_HANDLED;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (event[i] != handled[i]) {\n\t\t\tdev_warn(chip->dev,\n\t\t\t\t\"Unhandled event(s) in bank%d 0x%02x\\n\", i,\n\t\t\t\tevent[i] ^ handled[i]);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tif (handled[i]) {\n\t\t\tunsigned int reg = DA9121_REG_SYS_MASK_0 + i;\n\t\t\tunsigned int mbit = handled[i];\n\n\t\t\terr = regmap_update_bits(chip->regmap, reg, mbit, mbit);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(chip->dev,\n\t\t\t\t\t\"Failed to mask 0x%02x interrupt %d\\n\",\n\t\t\t\t\treg, err);\n\t\t\t\tret = IRQ_NONE;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (handled[0] | handled[1] | handled[2]) {\n\t\terr = regmap_bulk_write(chip->regmap, DA9121_REG_SYS_EVENT_0, handled, 3);\n\t\tif (err < 0) {\n\t\t\tdev_err(chip->dev, \"Fail to write EVENTs %d\\n\", err);\n\t\t\tret = IRQ_NONE;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tqueue_delayed_work(system_freezable_wq, &chip->work, 0);\nerror:\n\treturn ret;\n}\n\nstatic int da9121_set_regulator_config(struct da9121 *chip)\n{\n\tstruct regulator_config config = { };\n\tunsigned int max_matches = variant_parameters[chip->variant_id].num_bucks;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < max_matches; i++) {\n\t\tconst struct regulator_desc *regl_desc =\n\t\t\tlocal_da9121_regulators[chip->variant_id][i];\n\n\t\tconfig.dev = chip->dev;\n\t\tconfig.driver_data = chip;\n\t\tconfig.regmap = chip->regmap;\n\n\t\tchip->rdev[i] = devm_regulator_register(chip->dev,\n\t\t\t\t\tregl_desc, &config);\n\t\tif (IS_ERR(chip->rdev[i])) {\n\t\t\tdev_err(chip->dev, \"Failed to register regulator %s, %d/%d\\n\",\n\t\t\t\tregl_desc->name, (i+1), max_matches);\n\t\t\tret = PTR_ERR(chip->rdev[i]);\n\t\t\tgoto error;\n\t\t}\n\t}\n\nerror:\n\treturn ret;\n}\n\n \nstatic const struct regmap_range da9121_1ch_readable_ranges[] = {\n\tregmap_reg_range(DA9121_REG_SYS_STATUS_0, DA9121_REG_SYS_MASK_3),\n\tregmap_reg_range(DA9121_REG_SYS_CONFIG_2, DA9121_REG_SYS_CONFIG_3),\n\tregmap_reg_range(DA9121_REG_SYS_GPIO0_0, DA9121_REG_SYS_GPIO2_1),\n\tregmap_reg_range(DA9121_REG_BUCK_BUCK1_0, DA9121_REG_BUCK_BUCK1_6),\n\tregmap_reg_range(DA9121_REG_OTP_DEVICE_ID, DA9121_REG_OTP_CONFIG_ID),\n};\n\nstatic const struct regmap_access_table da9121_1ch_readable_table = {\n\t.yes_ranges = da9121_1ch_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(da9121_1ch_readable_ranges),\n};\n\nstatic const struct regmap_range da9121_2ch_readable_ranges[] = {\n\tregmap_reg_range(DA9121_REG_SYS_STATUS_0, DA9121_REG_SYS_MASK_3),\n\tregmap_reg_range(DA9121_REG_SYS_CONFIG_2, DA9121_REG_SYS_CONFIG_3),\n\tregmap_reg_range(DA9121_REG_SYS_GPIO0_0, DA9121_REG_SYS_GPIO2_1),\n\tregmap_reg_range(DA9121_REG_BUCK_BUCK1_0, DA9121_REG_BUCK_BUCK1_7),\n\tregmap_reg_range(DA9xxx_REG_BUCK_BUCK2_0, DA9xxx_REG_BUCK_BUCK2_7),\n\tregmap_reg_range(DA9121_REG_OTP_DEVICE_ID, DA9121_REG_OTP_CONFIG_ID),\n};\n\nstatic const struct regmap_access_table da9121_2ch_readable_table = {\n\t.yes_ranges = da9121_2ch_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(da9121_2ch_readable_ranges),\n};\n\nstatic const struct regmap_range da9121_1ch_writeable_ranges[] = {\n\tregmap_reg_range(DA9121_REG_SYS_EVENT_0, DA9121_REG_SYS_MASK_3),\n\tregmap_reg_range(DA9121_REG_SYS_CONFIG_2, DA9121_REG_SYS_CONFIG_3),\n\tregmap_reg_range(DA9121_REG_SYS_GPIO0_0, DA9121_REG_SYS_GPIO2_1),\n\tregmap_reg_range(DA9121_REG_BUCK_BUCK1_0, DA9121_REG_BUCK_BUCK1_2),\n\tregmap_reg_range(DA9121_REG_BUCK_BUCK1_4, DA9121_REG_BUCK_BUCK1_6),\n};\n\nstatic const struct regmap_access_table da9121_1ch_writeable_table = {\n\t.yes_ranges = da9121_1ch_writeable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(da9121_1ch_writeable_ranges),\n};\n\nstatic const struct regmap_range da9121_2ch_writeable_ranges[] = {\n\tregmap_reg_range(DA9121_REG_SYS_EVENT_0, DA9121_REG_SYS_MASK_3),\n\tregmap_reg_range(DA9121_REG_SYS_CONFIG_2, DA9121_REG_SYS_CONFIG_3),\n\tregmap_reg_range(DA9121_REG_SYS_GPIO0_0, DA9121_REG_SYS_GPIO2_1),\n\tregmap_reg_range(DA9121_REG_BUCK_BUCK1_0, DA9121_REG_BUCK_BUCK1_2),\n\tregmap_reg_range(DA9121_REG_BUCK_BUCK1_4, DA9121_REG_BUCK_BUCK1_7),\n\tregmap_reg_range(DA9xxx_REG_BUCK_BUCK2_0, DA9xxx_REG_BUCK_BUCK2_2),\n\tregmap_reg_range(DA9xxx_REG_BUCK_BUCK2_4, DA9xxx_REG_BUCK_BUCK2_7),\n};\n\nstatic const struct regmap_access_table da9121_2ch_writeable_table = {\n\t.yes_ranges = da9121_2ch_writeable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(da9121_2ch_writeable_ranges),\n};\n\n\nstatic const struct regmap_range da9121_volatile_ranges[] = {\n\tregmap_reg_range(DA9121_REG_SYS_STATUS_0, DA9121_REG_SYS_EVENT_2),\n\tregmap_reg_range(DA9121_REG_SYS_GPIO0_0, DA9121_REG_SYS_GPIO2_1),\n\tregmap_reg_range(DA9121_REG_BUCK_BUCK1_0, DA9121_REG_BUCK_BUCK1_6),\n};\n\nstatic const struct regmap_access_table da9121_volatile_table = {\n\t.yes_ranges = da9121_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(da9121_volatile_ranges),\n};\n\n \nstatic struct regmap_config da9121_1ch_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = DA9121_REG_OTP_CONFIG_ID,\n\t.rd_table = &da9121_1ch_readable_table,\n\t.wr_table = &da9121_1ch_writeable_table,\n\t.volatile_table = &da9121_volatile_table,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\n \nstatic struct regmap_config da9121_2ch_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = DA9121_REG_OTP_CONFIG_ID,\n\t.rd_table = &da9121_2ch_readable_table,\n\t.wr_table = &da9121_2ch_writeable_table,\n\t.volatile_table = &da9121_volatile_table,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int da9121_check_device_type(struct i2c_client *i2c, struct da9121 *chip)\n{\n\tu32 device_id;\n\tu32 variant_id;\n\tu8 variant_mrc, variant_vrc;\n\tchar *type;\n\tbool config_match = false;\n\tint ret = 0;\n\n\tret = regmap_read(chip->regmap, DA9121_REG_OTP_DEVICE_ID, &device_id);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Cannot read device ID: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = regmap_read(chip->regmap, DA9121_REG_OTP_VARIANT_ID, &variant_id);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Cannot read variant ID: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tif ((device_id != DA9121_DEVICE_ID) && (device_id != DA914x_DEVICE_ID)) {\n\t\tdev_err(chip->dev, \"Invalid device ID: 0x%02x\\n\", device_id);\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tvariant_vrc = variant_id & DA9121_MASK_OTP_VARIANT_ID_VRC;\n\n\tswitch (chip->subvariant_id) {\n\tcase DA9121_SUBTYPE_DA9121:\n\t\ttype = \"DA9121\";\n\t\tconfig_match = (variant_vrc == DA9121_VARIANT_VRC);\n\t\tbreak;\n\tcase DA9121_SUBTYPE_DA9130:\n\t\ttype = \"DA9130\";\n\t\tconfig_match = (variant_vrc == DA9130_VARIANT_VRC);\n\t\tbreak;\n\tcase DA9121_SUBTYPE_DA9220:\n\t\ttype = \"DA9220\";\n\t\tconfig_match = (variant_vrc == DA9220_VARIANT_VRC);\n\t\tbreak;\n\tcase DA9121_SUBTYPE_DA9132:\n\t\ttype = \"DA9132\";\n\t\tconfig_match = (variant_vrc == DA9132_VARIANT_VRC);\n\t\tbreak;\n\tcase DA9121_SUBTYPE_DA9122:\n\t\ttype = \"DA9122\";\n\t\tconfig_match = (variant_vrc == DA9122_VARIANT_VRC);\n\t\tbreak;\n\tcase DA9121_SUBTYPE_DA9131:\n\t\ttype = \"DA9131\";\n\t\tconfig_match = (variant_vrc == DA9131_VARIANT_VRC);\n\t\tbreak;\n\tcase DA9121_SUBTYPE_DA9217:\n\t\ttype = \"DA9217\";\n\t\tconfig_match = (variant_vrc == DA9217_VARIANT_VRC);\n\t\tbreak;\n\tdefault:\n\t\ttype = \"Unknown\";\n\t\tbreak;\n\t}\n\n\tif (device_id == DA914x_DEVICE_ID) {\n\t\tswitch (chip->subvariant_id) {\n\t\tcase DA9121_SUBTYPE_DA9141:\n\t\t\ttype = \"DA9141\";\n\t\t\tconfig_match = (variant_vrc == DA9141_VARIANT_VRC);\n\t\t\tbreak;\n\t\tcase DA9121_SUBTYPE_DA9142:\n\t\t\ttype = \"DA9142\";\n\t\t\tconfig_match = (variant_vrc == DA9142_VARIANT_VRC);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = \"Unknown\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdev_info(chip->dev,\n\t\t \"Device detected (device-ID: 0x%02X, var-ID: 0x%02X, %s)\\n\",\n\t\t device_id, variant_id, type);\n\n\tif (!config_match) {\n\t\tdev_err(chip->dev, \"Device tree configuration does not match detected device.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tvariant_mrc = (variant_id & DA9121_MASK_OTP_VARIANT_ID_MRC)\n\t\t\t>> DA9121_SHIFT_OTP_VARIANT_ID_MRC;\n\n\tif (((device_id == DA9121_DEVICE_ID) &&\n\t     (variant_mrc < DA9121_VARIANT_MRC_BASE)) ||\n\t    ((device_id == DA914x_DEVICE_ID) &&\n\t     (variant_mrc != DA914x_VARIANT_MRC_BASE))) {\n\t\tdev_err(chip->dev,\n\t\t\t\"Cannot support variant MRC: 0x%02X\\n\", variant_mrc);\n\t\tret = -EINVAL;\n\t}\nerror:\n\treturn ret;\n}\n\nstatic int da9121_assign_chip_model(struct i2c_client *i2c,\n\t\t\tstruct da9121 *chip)\n{\n\tstruct regmap_config *regmap;\n\tint ret = 0;\n\n\tchip->dev = &i2c->dev;\n\n\t \n\tswitch (chip->subvariant_id) {\n\tcase DA9121_SUBTYPE_DA9121:\n\tcase DA9121_SUBTYPE_DA9130:\n\t\tchip->variant_id = DA9121_TYPE_DA9121_DA9130;\n\t\tregmap = &da9121_1ch_regmap_config;\n\t\tbreak;\n\tcase DA9121_SUBTYPE_DA9217:\n\t\tchip->variant_id = DA9121_TYPE_DA9217;\n\t\tregmap = &da9121_1ch_regmap_config;\n\t\tbreak;\n\tcase DA9121_SUBTYPE_DA9122:\n\tcase DA9121_SUBTYPE_DA9131:\n\t\tchip->variant_id = DA9121_TYPE_DA9122_DA9131;\n\t\tregmap = &da9121_2ch_regmap_config;\n\t\tbreak;\n\tcase DA9121_SUBTYPE_DA9220:\n\tcase DA9121_SUBTYPE_DA9132:\n\t\tchip->variant_id = DA9121_TYPE_DA9220_DA9132;\n\t\tregmap = &da9121_2ch_regmap_config;\n\t\tbreak;\n\tcase DA9121_SUBTYPE_DA9141:\n\t\tchip->variant_id = DA9121_TYPE_DA9141;\n\t\tregmap = &da9121_1ch_regmap_config;\n\t\tbreak;\n\tcase DA9121_SUBTYPE_DA9142:\n\t\tchip->variant_id = DA9121_TYPE_DA9142;\n\t\tregmap = &da9121_2ch_regmap_config;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tda9121_matches[0].desc = local_da9121_regulators[chip->variant_id][0];\n\tda9121_matches[1].desc = local_da9121_regulators[chip->variant_id][1];\n\n\tchip->regmap = devm_regmap_init_i2c(i2c, regmap);\n\tif (IS_ERR(chip->regmap)) {\n\t\tret = PTR_ERR(chip->regmap);\n\t\tdev_err(chip->dev, \"Failed to configure a register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = da9121_check_device_type(i2c, chip);\n\n\treturn ret;\n}\n\nstatic int da9121_config_irq(struct i2c_client *i2c,\n\t\t\tstruct da9121 *chip)\n{\n\tunsigned int p_delay = DA9121_DEFAULT_POLLING_PERIOD_MS;\n\tconst int mask_all[4] = { 0, 0, 0xFF, 0xFF };\n\tint ret = 0;\n\n\tchip->chip_irq = i2c->irq;\n\n\tif (chip->chip_irq != 0) {\n\t\tif (!of_property_read_u32(chip->dev->of_node,\n\t\t\t\t\t  \"dlg,irq-polling-delay-passive-ms\",\n\t\t\t\t\t  &p_delay)) {\n\t\t\tif (p_delay < DA9121_MIN_POLLING_PERIOD_MS ||\n\t\t\t    p_delay > DA9121_MAX_POLLING_PERIOD_MS) {\n\t\t\t\tdev_warn(chip->dev,\n\t\t\t\t\t \"Out-of-range polling period %d ms\\n\",\n\t\t\t\t\t p_delay);\n\t\t\t\tp_delay = DA9121_DEFAULT_POLLING_PERIOD_MS;\n\t\t\t}\n\t\t}\n\n\t\tchip->passive_delay = p_delay;\n\n\t\tret = request_threaded_irq(chip->chip_irq, NULL,\n\t\t\t\t\tda9121_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_LOW|IRQF_ONESHOT,\n\t\t\t\t\t\"da9121\", chip);\n\t\tif (ret != 0) {\n\t\t\tdev_err(chip->dev, \"Failed IRQ request: %d\\n\",\n\t\t\t\tchip->chip_irq);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = regmap_bulk_write(chip->regmap, DA9121_REG_SYS_MASK_0, mask_all, 4);\n\t\tif (ret != 0) {\n\t\t\tdev_err(chip->dev, \"Failed to set IRQ masks: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto regmap_error;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&chip->work, da9121_status_poll_on);\n\t\tdev_info(chip->dev, \"Interrupt polling period set at %d ms\\n\",\n\t\t\t chip->passive_delay);\n\t}\nerror:\n\treturn ret;\nregmap_error:\n\tfree_irq(chip->chip_irq, chip);\n\treturn ret;\n}\n\nstatic const struct of_device_id da9121_dt_ids[] = {\n\t{ .compatible = \"dlg,da9121\", .data = (void *) DA9121_SUBTYPE_DA9121 },\n\t{ .compatible = \"dlg,da9130\", .data = (void *) DA9121_SUBTYPE_DA9130 },\n\t{ .compatible = \"dlg,da9217\", .data = (void *) DA9121_SUBTYPE_DA9217 },\n\t{ .compatible = \"dlg,da9122\", .data = (void *) DA9121_SUBTYPE_DA9122 },\n\t{ .compatible = \"dlg,da9131\", .data = (void *) DA9121_SUBTYPE_DA9131 },\n\t{ .compatible = \"dlg,da9220\", .data = (void *) DA9121_SUBTYPE_DA9220 },\n\t{ .compatible = \"dlg,da9132\", .data = (void *) DA9121_SUBTYPE_DA9132 },\n\t{ .compatible = \"dlg,da9141\", .data = (void *) DA9121_SUBTYPE_DA9141 },\n\t{ .compatible = \"dlg,da9142\", .data = (void *) DA9121_SUBTYPE_DA9142 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, da9121_dt_ids);\n\nstatic inline int da9121_of_get_id(struct device *dev)\n{\n\tconst struct of_device_id *id = of_match_device(da9121_dt_ids, dev);\n\n\tif (!id) {\n\t\tdev_err(dev, \"%s: Failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\treturn (uintptr_t)id->data;\n}\n\nstatic int da9121_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct da9121 *chip;\n\tconst int mask_all[4] = { 0xFF, 0xFF, 0xFF, 0xFF };\n\tint ret = 0;\n\n\tchip = devm_kzalloc(&i2c->dev, sizeof(struct da9121), GFP_KERNEL);\n\tif (!chip) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tchip->pdata = i2c->dev.platform_data;\n\tchip->subvariant_id = da9121_of_get_id(&i2c->dev);\n\n\tret = da9121_assign_chip_model(i2c, chip);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = regmap_bulk_write(chip->regmap, DA9121_REG_SYS_MASK_0, mask_all, 4);\n\tif (ret != 0) {\n\t\tdev_err(chip->dev, \"Failed to set IRQ masks: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = da9121_set_regulator_config(chip);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = da9121_config_irq(i2c, chip);\n\nerror:\n\treturn ret;\n}\n\nstatic void da9121_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct da9121 *chip = i2c_get_clientdata(i2c);\n\tconst int mask_all[4] = { 0xFF, 0xFF, 0xFF, 0xFF };\n\tint ret;\n\n\tfree_irq(chip->chip_irq, chip);\n\tcancel_delayed_work_sync(&chip->work);\n\n\tret = regmap_bulk_write(chip->regmap, DA9121_REG_SYS_MASK_0, mask_all, 4);\n\tif (ret != 0)\n\t\tdev_err(chip->dev, \"Failed to set IRQ masks: %d\\n\", ret);\n}\n\nstatic const struct i2c_device_id da9121_i2c_id[] = {\n\t{\"da9121\", DA9121_TYPE_DA9121_DA9130},\n\t{\"da9130\", DA9121_TYPE_DA9121_DA9130},\n\t{\"da9217\", DA9121_TYPE_DA9217},\n\t{\"da9122\", DA9121_TYPE_DA9122_DA9131},\n\t{\"da9131\", DA9121_TYPE_DA9122_DA9131},\n\t{\"da9220\", DA9121_TYPE_DA9220_DA9132},\n\t{\"da9132\", DA9121_TYPE_DA9220_DA9132},\n\t{\"da9141\", DA9121_TYPE_DA9141},\n\t{\"da9142\", DA9121_TYPE_DA9142},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, da9121_i2c_id);\n\nstatic struct i2c_driver da9121_regulator_driver = {\n\t.driver = {\n\t\t.name = \"da9121\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = da9121_dt_ids,\n\t},\n\t.probe = da9121_i2c_probe,\n\t.remove = da9121_i2c_remove,\n\t.id_table = da9121_i2c_id,\n};\n\nmodule_i2c_driver(da9121_regulator_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}