{
  "module_name": "rt5120-regulator.c",
  "hash_id": "0230c0c62efd8ddc68e15a00267d8300e6cc9168cb5010fdb02922ce0b343746",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rt5120-regulator.c",
  "human_readable_source": "\n\n#include <linux/bits.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n\n#define RT5120_REG_PGSTAT\t0x03\n#define RT5120_REG_CH1VID\t0x06\n#define RT5120_REG_CH1SLPVID\t0x07\n#define RT5120_REG_ENABLE\t0x08\n#define RT5120_REG_MODECTL\t0x09\n#define RT5120_REG_UVOVPROT\t0x0A\n#define RT5120_REG_SLPCTL\t0x0C\n#define RT5120_REG_INTSTAT\t0x1E\n#define RT5120_REG_DISCHG\t0x1F\n\n#define RT5120_OUTPG_MASK(rid)\tBIT(rid + 1)\n#define RT5120_OUTUV_MASK(rid)\tBIT(rid + 9)\n#define RT5120_OUTOV_MASK(rid)\tBIT(rid + 16)\n#define RT5120_CH1VID_MASK\tGENMASK(6, 0)\n#define RT5120_RIDEN_MASK(rid)\tBIT(rid + 1)\n#define RT5120_RADEN_MASK(rid)\tBIT(rid)\n#define RT5120_FPWM_MASK(rid)\tBIT(rid + 1)\n#define RT5120_UVHICCUP_MASK\tBIT(1)\n#define RT5120_OVHICCUP_MASK\tBIT(0)\n#define RT5120_HOTDIE_MASK\tBIT(1)\n\n#define RT5120_BUCK1_MINUV\t600000\n#define RT5120_BUCK1_MAXUV\t1393750\n#define RT5120_BUCK1_STEPUV\t6250\n#define RT5120_BUCK1_NUM_VOLT\t0x80\n\n#define RT5120_AUTO_MODE\t0\n#define RT5120_FPWM_MODE\t1\n\nenum {\n\tRT5120_REGULATOR_BUCK1 = 0,\n\tRT5120_REGULATOR_BUCK2,\n\tRT5120_REGULATOR_BUCK3,\n\tRT5120_REGULATOR_BUCK4,\n\tRT5120_REGULATOR_LDO,\n\tRT5120_REGULATOR_EXTEN,\n\tRT5120_MAX_REGULATOR\n};\n\nstruct rt5120_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regulator_desc rdesc[RT5120_MAX_REGULATOR];\n};\n\nstatic int rt5120_buck_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tint rid = rdev_get_id(rdev);\n\tunsigned int mask = RT5120_FPWM_MASK(rid), val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = 0;\n\t\tbreak;\n\tcase REGULATOR_MODE_FAST:\n\t\tval = RT5120_FPWM_MASK(rid);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(regmap, RT5120_REG_MODECTL, mask, val);\n}\n\nstatic unsigned int rt5120_buck_get_mode(struct regulator_dev *rdev)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tint ret, rid = rdev_get_id(rdev);\n\tunsigned int val;\n\n\tret = regmap_read(regmap, RT5120_REG_MODECTL, &val);\n\tif (ret)\n\t\treturn REGULATOR_MODE_INVALID;\n\n\tif (val & RT5120_FPWM_MASK(rid))\n\t\treturn REGULATOR_MODE_FAST;\n\n\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int rt5120_regulator_get_error_flags(struct regulator_dev *rdev,\n\t\t\t\t\t    unsigned int *flags)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int stat, hd_stat, cur_flags = 0;\n\tint rid = rdev_get_id(rdev), ret;\n\n\t \n\tret = regmap_raw_read(regmap, RT5120_REG_PGSTAT, &stat, 3);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(regmap, RT5120_REG_INTSTAT, &hd_stat);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(stat & RT5120_OUTPG_MASK(rid))) {\n\t\tif (stat & RT5120_OUTUV_MASK(rid))\n\t\t\tcur_flags |= REGULATOR_ERROR_UNDER_VOLTAGE;\n\n\t\tif (stat & RT5120_OUTOV_MASK(rid))\n\t\t\tcur_flags |= REGULATOR_ERROR_REGULATION_OUT;\n\t}\n\n\tif (hd_stat & RT5120_HOTDIE_MASK)\n\t\tcur_flags |= REGULATOR_ERROR_OVER_TEMP;\n\n\t*flags = cur_flags;\n\treturn 0;\n}\n\nstatic int rt5120_buck1_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tint sel;\n\n\tif (uV < RT5120_BUCK1_MINUV || uV > RT5120_BUCK1_MAXUV)\n\t\treturn -EINVAL;\n\n\tsel = (uV - RT5120_BUCK1_MINUV) / RT5120_BUCK1_STEPUV;\n\treturn regmap_write(regmap, RT5120_REG_CH1SLPVID, sel);\n}\n\nstatic int rt5120_regulator_set_suspend_enable(struct regulator_dev *rdev)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tint rid = rdev_get_id(rdev);\n\tunsigned int mask = RT5120_RIDEN_MASK(rid);\n\n\treturn regmap_update_bits(regmap, RT5120_REG_SLPCTL, mask, mask);\n}\n\nstatic int rt5120_regulator_set_suspend_disable(struct regulator_dev *rdev)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tint rid = rdev_get_id(rdev);\n\tunsigned int mask = RT5120_RIDEN_MASK(rid);\n\n\treturn regmap_update_bits(regmap, RT5120_REG_SLPCTL, mask, 0);\n}\n\nstatic const struct regulator_ops rt5120_buck1_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n\t.set_mode = rt5120_buck_set_mode,\n\t.get_mode = rt5120_buck_get_mode,\n\t.get_error_flags = rt5120_regulator_get_error_flags,\n\t.set_suspend_voltage = rt5120_buck1_set_suspend_voltage,\n\t.set_suspend_enable = rt5120_regulator_set_suspend_enable,\n\t.set_suspend_disable = rt5120_regulator_set_suspend_disable,\n};\n\nstatic const struct regulator_ops rt5120_buck234_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n\t.set_mode = rt5120_buck_set_mode,\n\t.get_mode = rt5120_buck_get_mode,\n\t.get_error_flags = rt5120_regulator_get_error_flags,\n\t.set_suspend_enable = rt5120_regulator_set_suspend_enable,\n\t.set_suspend_disable = rt5120_regulator_set_suspend_disable,\n};\n\nstatic const struct regulator_ops rt5120_ldo_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n\t.get_error_flags = rt5120_regulator_get_error_flags,\n\t.set_suspend_enable = rt5120_regulator_set_suspend_enable,\n\t.set_suspend_disable = rt5120_regulator_set_suspend_disable,\n};\n\nstatic const struct regulator_ops rt5120_exten_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_suspend_enable = rt5120_regulator_set_suspend_enable,\n\t.set_suspend_disable = rt5120_regulator_set_suspend_disable,\n};\n\nstatic unsigned int rt5120_buck_of_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase RT5120_AUTO_MODE:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase RT5120_FPWM_MODE:\n\t\treturn REGULATOR_MODE_FAST;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic void rt5120_fillin_regulator_desc(struct regulator_desc *desc, int rid)\n{\n\tstatic const char * const name[] = {\n\t\t\"buck1\", \"buck2\", \"buck3\", \"buck4\", \"ldo\", \"exten\" };\n\tstatic const char * const sname[] = {\n\t\t\"vin1\", \"vin2\", \"vin3\", \"vin4\", \"vinldo\", NULL };\n\n\t \n\tdesc->name = name[rid];\n\tdesc->supply_name = sname[rid];\n\tdesc->owner = THIS_MODULE;\n\tdesc->type = REGULATOR_VOLTAGE;\n\tdesc->id = rid;\n\tdesc->enable_reg = RT5120_REG_ENABLE;\n\tdesc->enable_mask = RT5120_RIDEN_MASK(rid);\n\tdesc->active_discharge_reg = RT5120_REG_DISCHG;\n\tdesc->active_discharge_mask = RT5120_RADEN_MASK(rid);\n\tdesc->active_discharge_on = RT5120_RADEN_MASK(rid);\n\t \n\tdesc->n_voltages = 1;\n\n\t \n\tif (rid >= RT5120_REGULATOR_BUCK1 && rid <= RT5120_REGULATOR_BUCK4)\n\t\tdesc->of_map_mode = rt5120_buck_of_map_mode;\n\n\t \n\tswitch (rid) {\n\tcase RT5120_REGULATOR_BUCK1:\n\t\t \n\t\tdesc->n_voltages = RT5120_BUCK1_NUM_VOLT;\n\t\tdesc->min_uV = RT5120_BUCK1_MINUV;\n\t\tdesc->uV_step = RT5120_BUCK1_STEPUV;\n\t\tdesc->vsel_reg = RT5120_REG_CH1VID,\n\t\tdesc->vsel_mask = RT5120_CH1VID_MASK,\n\t\tdesc->ops = &rt5120_buck1_ops;\n\t\tbreak;\n\tcase RT5120_REGULATOR_BUCK2 ... RT5120_REGULATOR_BUCK4:\n\t\tdesc->ops = &rt5120_buck234_ops;\n\t\tbreak;\n\tcase RT5120_REGULATOR_LDO:\n\t\tdesc->ops = &rt5120_ldo_ops;\n\t\tbreak;\n\tdefault:\n\t\tdesc->ops = &rt5120_exten_ops;\n\t}\n}\n\nstatic int rt5120_of_parse_cb(struct rt5120_priv *priv, int rid,\n\t\t\t      struct of_regulator_match *match)\n{\n\tstruct regulator_desc *desc = priv->rdesc + rid;\n\tstruct regulator_init_data *init_data = match->init_data;\n\n\tif (!init_data || rid == RT5120_REGULATOR_BUCK1)\n\t\treturn 0;\n\n\tif (init_data->constraints.min_uV != init_data->constraints.max_uV) {\n\t\tdev_err(priv->dev, \"Variable voltage for fixed regulator\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdesc->fixed_uV = init_data->constraints.min_uV;\n\treturn 0;\n}\n\nstatic struct of_regulator_match rt5120_regu_match[RT5120_MAX_REGULATOR] = {\n\t[RT5120_REGULATOR_BUCK1] = { .name = \"buck1\", },\n\t[RT5120_REGULATOR_BUCK2] = { .name = \"buck2\", },\n\t[RT5120_REGULATOR_BUCK3] = { .name = \"buck3\", },\n\t[RT5120_REGULATOR_BUCK4] = { .name = \"buck4\", },\n\t[RT5120_REGULATOR_LDO] = { .name = \"ldo\", },\n\t[RT5120_REGULATOR_EXTEN] = { .name = \"exten\", }\n};\n\nstatic int rt5120_parse_regulator_dt_data(struct rt5120_priv *priv)\n{\n\tstruct device *dev = priv->dev->parent;\n\tstruct device_node *reg_node;\n\tint i, ret;\n\n\tfor (i = 0; i < RT5120_MAX_REGULATOR; i++) {\n\t\trt5120_fillin_regulator_desc(priv->rdesc + i, i);\n\n\t\trt5120_regu_match[i].desc = priv->rdesc + i;\n\t}\n\n\treg_node = of_get_child_by_name(dev->of_node, \"regulators\");\n\tif (!reg_node) {\n\t\tdev_err(priv->dev, \"Couldn't find 'regulators' node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_regulator_match(priv->dev, reg_node, rt5120_regu_match,\n\t\t\t\t ARRAY_SIZE(rt5120_regu_match));\n\n\tof_node_put(reg_node);\n\n\tif (ret < 0) {\n\t\tdev_err(priv->dev,\n\t\t\t\"Error parsing regulator init data (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < RT5120_MAX_REGULATOR; i++) {\n\t\tret = rt5120_of_parse_cb(priv, i, rt5120_regu_match + i);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"Failed in [%d] of_passe_cb\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rt5120_device_property_init(struct rt5120_priv *priv)\n{\n\tstruct device *dev = priv->dev->parent;\n\tstruct device_node *np = dev->of_node;\n\tbool prot_enable;\n\tunsigned int prot_enable_val = 0;\n\n\t \n\tprot_enable = of_property_read_bool(np,\n\t\t\t\t\t    \"richtek,enable-undervolt-hiccup\");\n\tif (prot_enable)\n\t\tprot_enable_val |= RT5120_UVHICCUP_MASK;\n\n\tprot_enable = of_property_read_bool(np,\n\t\t\t\t\t    \"richtek,enable-overvolt-hiccup\");\n\tif (prot_enable)\n\t\tprot_enable_val |= RT5120_OVHICCUP_MASK;\n\n\treturn regmap_update_bits(priv->regmap, RT5120_REG_UVOVPROT,\n\t\t\t\t  RT5120_UVHICCUP_MASK | RT5120_OVHICCUP_MASK,\n\t\t\t\t  prot_enable_val);\n}\n\nstatic int rt5120_regulator_probe(struct platform_device *pdev)\n{\n\tstruct rt5120_priv *priv;\n\tstruct regulator_dev *rdev;\n\tstruct regulator_config config = {};\n\tint i, ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\n\tpriv->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!priv->regmap) {\n\t\tdev_err(&pdev->dev, \"Failed to init regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = rt5120_device_property_init(priv);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to do property init\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rt5120_parse_regulator_dt_data(priv);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to parse dt data\\n\");\n\t\treturn ret;\n\t}\n\n\tconfig.dev = &pdev->dev;\n\tconfig.regmap = priv->regmap;\n\n\tfor (i = 0; i < RT5120_MAX_REGULATOR; i++) {\n\t\tconfig.of_node = rt5120_regu_match[i].of_node;\n\t\tconfig.init_data = rt5120_regu_match[i].init_data;\n\n\t\trdev = devm_regulator_register(&pdev->dev, priv->rdesc + i,\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to register regulator [%d]\\n\", i);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id rt5120_regulator_dev_table[] = {\n\t{ \"rt5120-regulator\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(platform, rt5120_regulator_dev_table);\n\nstatic struct platform_driver rt5120_regulator_driver = {\n\t.driver = {\n\t\t.name = \"rt5120-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.id_table = rt5120_regulator_dev_table,\n\t.probe = rt5120_regulator_probe,\n};\nmodule_platform_driver(rt5120_regulator_driver);\n\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_DESCRIPTION(\"Richtek RT5120 regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}