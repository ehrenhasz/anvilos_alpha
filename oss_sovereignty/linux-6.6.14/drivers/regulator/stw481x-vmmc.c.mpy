{
  "module_name": "stw481x-vmmc.c",
  "hash_id": "5ba2adcd70b4fcadbf5dec705a3ce66e073e3771af6d9bf04d8197f6b891ac63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/stw481x-vmmc.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/mfd/stw481x.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\nstatic const unsigned int stw481x_vmmc_voltages[] = {\n\t1800000,\n\t1800000,\n\t2850000,\n\t3000000,\n\t1850000,\n\t2600000,\n\t2700000,\n\t3300000,\n};\n\nstatic const struct regulator_ops stw481x_vmmc_ops = {\n\t.list_voltage = regulator_list_voltage_table,\n\t.enable      = regulator_enable_regmap,\n\t.disable     = regulator_disable_regmap,\n\t.is_enabled  = regulator_is_enabled_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n};\n\nstatic const struct regulator_desc vmmc_regulator = {\n\t.name = \"VMMC\",\n\t.id   = 0,\n\t.ops  = &stw481x_vmmc_ops,\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n\t.n_voltages = ARRAY_SIZE(stw481x_vmmc_voltages),\n\t.volt_table = stw481x_vmmc_voltages,\n\t.enable_time = 200,  \n\t.enable_reg = STW_CONF1,\n\t.enable_mask = STW_CONF1_PDN_VMMC | STW_CONF1_MMC_LS_STATUS,\n\t.enable_val = STW_CONF1_PDN_VMMC,\n\t.vsel_reg = STW_CONF1,\n\t.vsel_mask = STW_CONF1_VMMC_MASK,\n};\n\nstatic int stw481x_vmmc_regulator_probe(struct platform_device *pdev)\n{\n\tstruct stw481x *stw481x = dev_get_platdata(&pdev->dev);\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(stw481x->map, STW_CONF2,\n\t\t\t\t STW_CONF2_VMMC_EXT, 0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not disable external VMMC\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tconfig.dev = &pdev->dev;\n\tconfig.driver_data = stw481x;\n\tconfig.regmap = stw481x->map;\n\tconfig.of_node = pdev->dev.of_node;\n\tconfig.init_data = of_get_regulator_init_data(&pdev->dev,\n\t\t\t\t\t\t      pdev->dev.of_node,\n\t\t\t\t\t\t      &vmmc_regulator);\n\n\trdev = devm_regulator_register(&pdev->dev, &vmmc_regulator, &config);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"error initializing STw481x VMMC regulator\\n\");\n\t\treturn PTR_ERR(rdev);\n\t}\n\n\tdev_info(&pdev->dev, \"initialized STw481x VMMC regulator\\n\");\n\treturn 0;\n}\n\nstatic const struct of_device_id stw481x_vmmc_match[] = {\n\t{ .compatible = \"st,stw481x-vmmc\", },\n\t{},\n};\n\nstatic struct platform_driver stw481x_vmmc_regulator_driver = {\n\t.driver = {\n\t\t.name  = \"stw481x-vmmc-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = stw481x_vmmc_match,\n\t},\n\t.probe = stw481x_vmmc_regulator_probe,\n};\n\nmodule_platform_driver(stw481x_vmmc_regulator_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}