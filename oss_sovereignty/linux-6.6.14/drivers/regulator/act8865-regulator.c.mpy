{
  "module_name": "act8865-regulator.c",
  "hash_id": "191d504c05b892104973ad2c70bfbb58b2d0978266cf67ae256560c6ff69e645",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/act8865-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/act8865.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/power_supply.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regmap.h>\n#include <dt-bindings/regulator/active-semi,8865-regulator.h>\n\n \n#define ACT8600_SYS_MODE\t0x00\n#define ACT8600_SYS_CTRL\t0x01\n#define ACT8600_DCDC1_VSET\t0x10\n#define ACT8600_DCDC1_CTRL\t0x12\n#define ACT8600_DCDC2_VSET\t0x20\n#define ACT8600_DCDC2_CTRL\t0x22\n#define ACT8600_DCDC3_VSET\t0x30\n#define ACT8600_DCDC3_CTRL\t0x32\n#define ACT8600_SUDCDC4_VSET\t0x40\n#define ACT8600_SUDCDC4_CTRL\t0x41\n#define ACT8600_LDO5_VSET\t0x50\n#define ACT8600_LDO5_CTRL\t0x51\n#define ACT8600_LDO6_VSET\t0x60\n#define ACT8600_LDO6_CTRL\t0x61\n#define ACT8600_LDO7_VSET\t0x70\n#define ACT8600_LDO7_CTRL\t0x71\n#define ACT8600_LDO8_VSET\t0x80\n#define ACT8600_LDO8_CTRL\t0x81\n#define ACT8600_LDO910_CTRL\t0x91\n#define ACT8600_APCH0\t\t0xA1\n#define ACT8600_APCH1\t\t0xA8\n#define ACT8600_APCH2\t\t0xA9\n#define ACT8600_APCH_STAT\t0xAA\n#define ACT8600_OTG0\t\t0xB0\n#define ACT8600_OTG1\t\t0xB2\n\n \n#define\tACT8846_SYS0\t\t0x00\n#define\tACT8846_SYS1\t\t0x01\n#define\tACT8846_REG1_VSET\t0x10\n#define\tACT8846_REG1_CTRL\t0x12\n#define\tACT8846_REG2_VSET0\t0x20\n#define\tACT8846_REG2_VSET1\t0x21\n#define\tACT8846_REG2_CTRL\t0x22\n#define\tACT8846_REG3_VSET0\t0x30\n#define\tACT8846_REG3_VSET1\t0x31\n#define\tACT8846_REG3_CTRL\t0x32\n#define\tACT8846_REG4_VSET0\t0x40\n#define\tACT8846_REG4_VSET1\t0x41\n#define\tACT8846_REG4_CTRL\t0x42\n#define\tACT8846_REG5_VSET\t0x50\n#define\tACT8846_REG5_CTRL\t0x51\n#define\tACT8846_REG6_VSET\t0x58\n#define\tACT8846_REG6_CTRL\t0x59\n#define\tACT8846_REG7_VSET\t0x60\n#define\tACT8846_REG7_CTRL\t0x61\n#define\tACT8846_REG8_VSET\t0x68\n#define\tACT8846_REG8_CTRL\t0x69\n#define\tACT8846_REG9_VSET\t0x70\n#define\tACT8846_REG9_CTRL\t0x71\n#define\tACT8846_REG10_VSET\t0x80\n#define\tACT8846_REG10_CTRL\t0x81\n#define\tACT8846_REG11_VSET\t0x90\n#define\tACT8846_REG11_CTRL\t0x91\n#define\tACT8846_REG12_VSET\t0xa0\n#define\tACT8846_REG12_CTRL\t0xa1\n#define\tACT8846_REG13_CTRL\t0xb1\n#define\tACT8846_GLB_OFF_CTRL\t0xc3\n#define\tACT8846_OFF_SYSMASK\t0x18\n\n \n#define\tACT8865_SYS_MODE\t0x00\n#define\tACT8865_SYS_CTRL\t0x01\n#define\tACT8865_SYS_UNLK_REGS\t0x0b\n#define\tACT8865_DCDC1_VSET1\t0x20\n#define\tACT8865_DCDC1_VSET2\t0x21\n#define\tACT8865_DCDC1_CTRL\t0x22\n#define\tACT8865_DCDC1_SUS\t0x24\n#define\tACT8865_DCDC2_VSET1\t0x30\n#define\tACT8865_DCDC2_VSET2\t0x31\n#define\tACT8865_DCDC2_CTRL\t0x32\n#define\tACT8865_DCDC2_SUS\t0x34\n#define\tACT8865_DCDC3_VSET1\t0x40\n#define\tACT8865_DCDC3_VSET2\t0x41\n#define\tACT8865_DCDC3_CTRL\t0x42\n#define\tACT8865_DCDC3_SUS\t0x44\n#define\tACT8865_LDO1_VSET\t0x50\n#define\tACT8865_LDO1_CTRL\t0x51\n#define\tACT8865_LDO1_SUS\t0x52\n#define\tACT8865_LDO2_VSET\t0x54\n#define\tACT8865_LDO2_CTRL\t0x55\n#define\tACT8865_LDO2_SUS\t0x56\n#define\tACT8865_LDO3_VSET\t0x60\n#define\tACT8865_LDO3_CTRL\t0x61\n#define\tACT8865_LDO3_SUS\t0x62\n#define\tACT8865_LDO4_VSET\t0x64\n#define\tACT8865_LDO4_CTRL\t0x65\n#define\tACT8865_LDO4_SUS\t0x66\n#define\tACT8865_MSTROFF\t\t0x20\n\n \n#define\tACT8865_ENA\t\t0x80\t \n#define\tACT8865_DIS\t\t0x40\t \n\n#define\tACT8865_VSEL_MASK\t0x3F\t \n\n\n#define ACT8600_LDO10_ENA\t\t0x40\t \n#define ACT8600_SUDCDC_VSEL_MASK\t0xFF\t \n\n#define ACT8600_APCH_CHG_ACIN\t\tBIT(7)\n#define ACT8600_APCH_CHG_USB\t\tBIT(6)\n#define ACT8600_APCH_CSTATE0\t\tBIT(5)\n#define ACT8600_APCH_CSTATE1\t\tBIT(4)\n\n \n#define\tACT8865_VOLTAGE_NUM\t64\n#define ACT8600_SUDCDC_VOLTAGE_NUM\t256\n\nstruct act8865 {\n\tstruct regmap *regmap;\n\tint off_reg;\n\tint off_mask;\n};\n\nstatic const struct regmap_range act8600_reg_ranges[] = {\n\tregmap_reg_range(0x00, 0x01),\n\tregmap_reg_range(0x10, 0x10),\n\tregmap_reg_range(0x12, 0x12),\n\tregmap_reg_range(0x20, 0x20),\n\tregmap_reg_range(0x22, 0x22),\n\tregmap_reg_range(0x30, 0x30),\n\tregmap_reg_range(0x32, 0x32),\n\tregmap_reg_range(0x40, 0x41),\n\tregmap_reg_range(0x50, 0x51),\n\tregmap_reg_range(0x60, 0x61),\n\tregmap_reg_range(0x70, 0x71),\n\tregmap_reg_range(0x80, 0x81),\n\tregmap_reg_range(0x91, 0x91),\n\tregmap_reg_range(0xA1, 0xA1),\n\tregmap_reg_range(0xA8, 0xAA),\n\tregmap_reg_range(0xB0, 0xB0),\n\tregmap_reg_range(0xB2, 0xB2),\n\tregmap_reg_range(0xC1, 0xC1),\n};\n\nstatic const struct regmap_range act8600_reg_ro_ranges[] = {\n\tregmap_reg_range(0xAA, 0xAA),\n\tregmap_reg_range(0xC1, 0xC1),\n};\n\nstatic const struct regmap_range act8600_reg_volatile_ranges[] = {\n\tregmap_reg_range(0x00, 0x01),\n\tregmap_reg_range(0x12, 0x12),\n\tregmap_reg_range(0x22, 0x22),\n\tregmap_reg_range(0x32, 0x32),\n\tregmap_reg_range(0x41, 0x41),\n\tregmap_reg_range(0x51, 0x51),\n\tregmap_reg_range(0x61, 0x61),\n\tregmap_reg_range(0x71, 0x71),\n\tregmap_reg_range(0x81, 0x81),\n\tregmap_reg_range(0xA8, 0xA8),\n\tregmap_reg_range(0xAA, 0xAA),\n\tregmap_reg_range(0xB0, 0xB0),\n\tregmap_reg_range(0xC1, 0xC1),\n};\n\nstatic const struct regmap_access_table act8600_write_ranges_table = {\n\t.yes_ranges\t= act8600_reg_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(act8600_reg_ranges),\n\t.no_ranges\t= act8600_reg_ro_ranges,\n\t.n_no_ranges\t= ARRAY_SIZE(act8600_reg_ro_ranges),\n};\n\nstatic const struct regmap_access_table act8600_read_ranges_table = {\n\t.yes_ranges\t= act8600_reg_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(act8600_reg_ranges),\n};\n\nstatic const struct regmap_access_table act8600_volatile_ranges_table = {\n\t.yes_ranges\t= act8600_reg_volatile_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(act8600_reg_volatile_ranges),\n};\n\nstatic const struct regmap_config act8600_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xFF,\n\t.wr_table = &act8600_write_ranges_table,\n\t.rd_table = &act8600_read_ranges_table,\n\t.volatile_table = &act8600_volatile_ranges_table,\n};\n\nstatic const struct regmap_config act8865_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic const struct linear_range act8865_voltage_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(600000, 0, 23, 25000),\n\tREGULATOR_LINEAR_RANGE(1200000, 24, 47, 50000),\n\tREGULATOR_LINEAR_RANGE(2400000, 48, 63, 100000),\n};\n\nstatic const struct linear_range act8600_sudcdc_voltage_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(3000000, 0, 63, 0),\n\tREGULATOR_LINEAR_RANGE(3000000, 64, 159, 100000),\n\tREGULATOR_LINEAR_RANGE(12600000, 160, 191, 200000),\n\tREGULATOR_LINEAR_RANGE(19000000, 192, 247, 400000),\n\tREGULATOR_LINEAR_RANGE(41400000, 248, 255, 0),\n};\n\nstatic int act8865_set_suspend_state(struct regulator_dev *rdev, bool enable)\n{\n\tstruct regmap *regmap = rdev->regmap;\n\tint id = rdev->desc->id, reg, val;\n\n\tswitch (id) {\n\tcase ACT8865_ID_DCDC1:\n\t\treg = ACT8865_DCDC1_SUS;\n\t\tval = 0xa8;\n\t\tbreak;\n\tcase ACT8865_ID_DCDC2:\n\t\treg = ACT8865_DCDC2_SUS;\n\t\tval = 0xa8;\n\t\tbreak;\n\tcase ACT8865_ID_DCDC3:\n\t\treg = ACT8865_DCDC3_SUS;\n\t\tval = 0xa8;\n\t\tbreak;\n\tcase ACT8865_ID_LDO1:\n\t\treg = ACT8865_LDO1_SUS;\n\t\tval = 0xe8;\n\t\tbreak;\n\tcase ACT8865_ID_LDO2:\n\t\treg = ACT8865_LDO2_SUS;\n\t\tval = 0xe8;\n\t\tbreak;\n\tcase ACT8865_ID_LDO3:\n\t\treg = ACT8865_LDO3_SUS;\n\t\tval = 0xe8;\n\t\tbreak;\n\tcase ACT8865_ID_LDO4:\n\t\treg = ACT8865_LDO4_SUS;\n\t\tval = 0xe8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (enable)\n\t\tval |= BIT(4);\n\n\t \n\treturn regmap_write(regmap, reg, val);\n}\n\nstatic int act8865_set_suspend_enable(struct regulator_dev *rdev)\n{\n\treturn act8865_set_suspend_state(rdev, true);\n}\n\nstatic int act8865_set_suspend_disable(struct regulator_dev *rdev)\n{\n\treturn act8865_set_suspend_state(rdev, false);\n}\n\nstatic unsigned int act8865_of_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase ACT8865_REGULATOR_MODE_FIXED:\n\t\treturn REGULATOR_MODE_FAST;\n\tcase ACT8865_REGULATOR_MODE_NORMAL:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase ACT8865_REGULATOR_MODE_LOWPOWER:\n\t\treturn REGULATOR_MODE_STANDBY;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic int act8865_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct regmap *regmap = rdev->regmap;\n\tint id = rdev_get_id(rdev);\n\tint reg, val = 0;\n\n\tswitch (id) {\n\tcase ACT8865_ID_DCDC1:\n\t\treg = ACT8865_DCDC1_CTRL;\n\t\tbreak;\n\tcase ACT8865_ID_DCDC2:\n\t\treg = ACT8865_DCDC2_CTRL;\n\t\tbreak;\n\tcase ACT8865_ID_DCDC3:\n\t\treg = ACT8865_DCDC3_CTRL;\n\t\tbreak;\n\tcase ACT8865_ID_LDO1:\n\t\treg = ACT8865_LDO1_CTRL;\n\t\tbreak;\n\tcase ACT8865_ID_LDO2:\n\t\treg = ACT8865_LDO2_CTRL;\n\t\tbreak;\n\tcase ACT8865_ID_LDO3:\n\t\treg = ACT8865_LDO3_CTRL;\n\t\tbreak;\n\tcase ACT8865_ID_LDO4:\n\t\treg = ACT8865_LDO4_CTRL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\tcase REGULATOR_MODE_NORMAL:\n\t\tif (id <= ACT8865_ID_DCDC3)\n\t\t\tval = BIT(5);\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tif (id > ACT8865_ID_DCDC3)\n\t\t\tval = BIT(5);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(regmap, reg, BIT(5), val);\n}\n\nstatic unsigned int act8865_get_mode(struct regulator_dev *rdev)\n{\n\tstruct regmap *regmap = rdev->regmap;\n\tint id = rdev_get_id(rdev);\n\tint reg, ret, val = 0;\n\n\tswitch (id) {\n\tcase ACT8865_ID_DCDC1:\n\t\treg = ACT8865_DCDC1_CTRL;\n\t\tbreak;\n\tcase ACT8865_ID_DCDC2:\n\t\treg = ACT8865_DCDC2_CTRL;\n\t\tbreak;\n\tcase ACT8865_ID_DCDC3:\n\t\treg = ACT8865_DCDC3_CTRL;\n\t\tbreak;\n\tcase ACT8865_ID_LDO1:\n\t\treg = ACT8865_LDO1_CTRL;\n\t\tbreak;\n\tcase ACT8865_ID_LDO2:\n\t\treg = ACT8865_LDO2_CTRL;\n\t\tbreak;\n\tcase ACT8865_ID_LDO3:\n\t\treg = ACT8865_LDO3_CTRL;\n\t\tbreak;\n\tcase ACT8865_ID_LDO4:\n\t\treg = ACT8865_LDO4_CTRL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_read(regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (id <= ACT8865_ID_DCDC3 && (val & BIT(5)))\n\t\treturn REGULATOR_MODE_FAST;\n\telse if\t(id > ACT8865_ID_DCDC3 && !(val & BIT(5)))\n\t\treturn REGULATOR_MODE_NORMAL;\n\telse\n\t\treturn REGULATOR_MODE_STANDBY;\n}\n\nstatic const struct regulator_ops act8865_ops = {\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.set_mode\t\t= act8865_set_mode,\n\t.get_mode\t\t= act8865_get_mode,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_suspend_enable\t= act8865_set_suspend_enable,\n\t.set_suspend_disable\t= act8865_set_suspend_disable,\n};\n\nstatic const struct regulator_ops act8865_ldo_ops = {\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.set_mode\t\t= act8865_set_mode,\n\t.get_mode\t\t= act8865_get_mode,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_suspend_enable\t= act8865_set_suspend_enable,\n\t.set_suspend_disable\t= act8865_set_suspend_disable,\n\t.set_pull_down\t\t= regulator_set_pull_down_regmap,\n};\n\nstatic const struct regulator_ops act8865_fixed_ldo_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n};\n\n#define ACT88xx_REG_(_name, _family, _id, _vsel_reg, _supply, _ops)\t\\\n\t[_family##_ID_##_id] = {\t\t\t\t\t\\\n\t\t.name\t\t\t= _name,\t\t\t\\\n\t\t.of_match\t\t= of_match_ptr(_name),\t\t\\\n\t\t.of_map_mode\t\t= act8865_of_map_mode,\t\t\\\n\t\t.regulators_node\t= of_match_ptr(\"regulators\"),\t\\\n\t\t.supply_name\t\t= _supply,\t\t\t\\\n\t\t.id\t\t\t= _family##_ID_##_id,\t\t\\\n\t\t.type\t\t\t= REGULATOR_VOLTAGE,\t\t\\\n\t\t.ops\t\t\t= _ops,\t\t\t\t\\\n\t\t.n_voltages\t\t= ACT8865_VOLTAGE_NUM,\t\t\\\n\t\t.linear_ranges\t\t= act8865_voltage_ranges,\t\\\n\t\t.n_linear_ranges\t= ARRAY_SIZE(act8865_voltage_ranges), \\\n\t\t.vsel_reg\t\t= _family##_##_id##_##_vsel_reg, \\\n\t\t.vsel_mask\t\t= ACT8865_VSEL_MASK,\t\t\\\n\t\t.enable_reg\t\t= _family##_##_id##_CTRL,\t\\\n\t\t.enable_mask\t\t= ACT8865_ENA,\t\t\t\\\n\t\t.pull_down_reg\t\t= _family##_##_id##_CTRL,\t\\\n\t\t.pull_down_mask\t\t= ACT8865_DIS,\t\t\t\\\n\t\t.owner\t\t\t= THIS_MODULE,\t\t\t\\\n\t}\n\n#define ACT88xx_REG(_name, _family, _id, _vsel_reg, _supply) \\\n\tACT88xx_REG_(_name, _family, _id, _vsel_reg, _supply, &act8865_ops)\n\n#define ACT88xx_LDO(_name, _family, _id, _vsel_reg, _supply) \\\n\tACT88xx_REG_(_name, _family, _id, _vsel_reg, _supply, &act8865_ldo_ops)\n\nstatic const struct regulator_desc act8600_regulators[] = {\n\tACT88xx_REG(\"DCDC1\", ACT8600, DCDC1, VSET, \"vp1\"),\n\tACT88xx_REG(\"DCDC2\", ACT8600, DCDC2, VSET, \"vp2\"),\n\tACT88xx_REG(\"DCDC3\", ACT8600, DCDC3, VSET, \"vp3\"),\n\t{\n\t\t.name = \"SUDCDC_REG4\",\n\t\t.of_match = of_match_ptr(\"SUDCDC_REG4\"),\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t.id = ACT8600_ID_SUDCDC4,\n\t\t.ops = &act8865_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = ACT8600_SUDCDC_VOLTAGE_NUM,\n\t\t.linear_ranges = act8600_sudcdc_voltage_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(act8600_sudcdc_voltage_ranges),\n\t\t.vsel_reg = ACT8600_SUDCDC4_VSET,\n\t\t.vsel_mask = ACT8600_SUDCDC_VSEL_MASK,\n\t\t.enable_reg = ACT8600_SUDCDC4_CTRL,\n\t\t.enable_mask = ACT8865_ENA,\n\t\t.owner = THIS_MODULE,\n\t},\n\tACT88xx_REG(\"LDO5\", ACT8600, LDO5, VSET, \"inl\"),\n\tACT88xx_REG(\"LDO6\", ACT8600, LDO6, VSET, \"inl\"),\n\tACT88xx_REG(\"LDO7\", ACT8600, LDO7, VSET, \"inl\"),\n\tACT88xx_REG(\"LDO8\", ACT8600, LDO8, VSET, \"inl\"),\n\t{\n\t\t.name = \"LDO_REG9\",\n\t\t.of_match = of_match_ptr(\"LDO_REG9\"),\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t.id = ACT8600_ID_LDO9,\n\t\t.ops = &act8865_fixed_ldo_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = 1,\n\t\t.fixed_uV = 3300000,\n\t\t.enable_reg = ACT8600_LDO910_CTRL,\n\t\t.enable_mask = ACT8865_ENA,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"LDO_REG10\",\n\t\t.of_match = of_match_ptr(\"LDO_REG10\"),\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t.id = ACT8600_ID_LDO10,\n\t\t.ops = &act8865_fixed_ldo_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = 1,\n\t\t.fixed_uV = 1200000,\n\t\t.enable_reg = ACT8600_LDO910_CTRL,\n\t\t.enable_mask = ACT8600_LDO10_ENA,\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\nstatic const struct regulator_desc act8846_regulators[] = {\n\tACT88xx_REG(\"REG1\", ACT8846, REG1, VSET, \"vp1\"),\n\tACT88xx_REG(\"REG2\", ACT8846, REG2, VSET0, \"vp2\"),\n\tACT88xx_REG(\"REG3\", ACT8846, REG3, VSET0, \"vp3\"),\n\tACT88xx_REG(\"REG4\", ACT8846, REG4, VSET0, \"vp4\"),\n\tACT88xx_REG(\"REG5\", ACT8846, REG5, VSET, \"inl1\"),\n\tACT88xx_REG(\"REG6\", ACT8846, REG6, VSET, \"inl1\"),\n\tACT88xx_REG(\"REG7\", ACT8846, REG7, VSET, \"inl1\"),\n\tACT88xx_REG(\"REG8\", ACT8846, REG8, VSET, \"inl2\"),\n\tACT88xx_REG(\"REG9\", ACT8846, REG9, VSET, \"inl2\"),\n\tACT88xx_REG(\"REG10\", ACT8846, REG10, VSET, \"inl3\"),\n\tACT88xx_REG(\"REG11\", ACT8846, REG11, VSET, \"inl3\"),\n\tACT88xx_REG(\"REG12\", ACT8846, REG12, VSET, \"inl3\"),\n};\n\nstatic const struct regulator_desc act8865_regulators[] = {\n\tACT88xx_REG(\"DCDC_REG1\", ACT8865, DCDC1, VSET1, \"vp1\"),\n\tACT88xx_REG(\"DCDC_REG2\", ACT8865, DCDC2, VSET1, \"vp2\"),\n\tACT88xx_REG(\"DCDC_REG3\", ACT8865, DCDC3, VSET1, \"vp3\"),\n\tACT88xx_LDO(\"LDO_REG1\", ACT8865, LDO1, VSET, \"inl45\"),\n\tACT88xx_LDO(\"LDO_REG2\", ACT8865, LDO2, VSET, \"inl45\"),\n\tACT88xx_LDO(\"LDO_REG3\", ACT8865, LDO3, VSET, \"inl67\"),\n\tACT88xx_LDO(\"LDO_REG4\", ACT8865, LDO4, VSET, \"inl67\"),\n};\n\nstatic const struct regulator_desc act8865_alt_regulators[] = {\n\tACT88xx_REG(\"DCDC_REG1\", ACT8865, DCDC1, VSET2, \"vp1\"),\n\tACT88xx_REG(\"DCDC_REG2\", ACT8865, DCDC2, VSET2, \"vp2\"),\n\tACT88xx_REG(\"DCDC_REG3\", ACT8865, DCDC3, VSET2, \"vp3\"),\n\tACT88xx_LDO(\"LDO_REG1\", ACT8865, LDO1, VSET, \"inl45\"),\n\tACT88xx_LDO(\"LDO_REG2\", ACT8865, LDO2, VSET, \"inl45\"),\n\tACT88xx_LDO(\"LDO_REG3\", ACT8865, LDO3, VSET, \"inl67\"),\n\tACT88xx_LDO(\"LDO_REG4\", ACT8865, LDO4, VSET, \"inl67\"),\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id act8865_dt_ids[] = {\n\t{ .compatible = \"active-semi,act8600\", .data = (void *)ACT8600 },\n\t{ .compatible = \"active-semi,act8846\", .data = (void *)ACT8846 },\n\t{ .compatible = \"active-semi,act8865\", .data = (void *)ACT8865 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, act8865_dt_ids);\n#endif\n\nstatic struct act8865_regulator_data *act8865_get_regulator_data(\n\t\tint id, struct act8865_platform_data *pdata)\n{\n\tint i;\n\n\tfor (i = 0; i < pdata->num_regulators; i++) {\n\t\tif (pdata->regulators[i].id == id)\n\t\t\treturn &pdata->regulators[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic struct i2c_client *act8865_i2c_client;\nstatic void act8865_power_off(void)\n{\n\tstruct act8865 *act8865;\n\n\tact8865 = i2c_get_clientdata(act8865_i2c_client);\n\tregmap_write(act8865->regmap, act8865->off_reg, act8865->off_mask);\n\twhile (1);\n}\n\nstatic int act8600_charger_get_status(struct regmap *map)\n{\n\tunsigned int val;\n\tint ret;\n\tu8 state0, state1;\n\n\tret = regmap_read(map, ACT8600_APCH_STAT, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstate0 = val & ACT8600_APCH_CSTATE0;\n\tstate1 = val & ACT8600_APCH_CSTATE1;\n\n\tif (state0 && !state1)\n\t\treturn POWER_SUPPLY_STATUS_CHARGING;\n\tif (!state0 && state1)\n\t\treturn POWER_SUPPLY_STATUS_NOT_CHARGING;\n\tif (!state0 && !state1)\n\t\treturn POWER_SUPPLY_STATUS_DISCHARGING;\n\n\treturn POWER_SUPPLY_STATUS_UNKNOWN;\n}\n\nstatic int act8600_charger_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp, union power_supply_propval *val)\n{\n\tstruct regmap *map = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = act8600_charger_get_status(map);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval->intval = ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic enum power_supply_property act8600_charger_properties[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n};\n\nstatic const struct power_supply_desc act8600_charger_desc = {\n\t.name = \"act8600-charger\",\n\t.type = POWER_SUPPLY_TYPE_BATTERY,\n\t.properties = act8600_charger_properties,\n\t.num_properties = ARRAY_SIZE(act8600_charger_properties),\n\t.get_property = act8600_charger_get_property,\n};\n\nstatic int act8600_charger_probe(struct device *dev, struct regmap *regmap)\n{\n\tstruct power_supply *charger;\n\tstruct power_supply_config cfg = {\n\t\t.drv_data = regmap,\n\t\t.of_node = dev->of_node,\n\t};\n\n\tcharger = devm_power_supply_register(dev, &act8600_charger_desc, &cfg);\n\n\treturn PTR_ERR_OR_ZERO(charger);\n}\n\nstatic int act8865_pmic_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *i2c_id = i2c_client_get_device_id(client);\n\tconst struct regulator_desc *regulators;\n\tstruct act8865_platform_data *pdata = NULL;\n\tstruct device *dev = &client->dev;\n\tint i, ret, num_regulators;\n\tstruct act8865 *act8865;\n\tconst struct regmap_config *regmap_config;\n\tunsigned long type;\n\tint off_reg, off_mask;\n\tint voltage_select = 0;\n\n\tif (dev->of_node) {\n\t\tconst struct of_device_id *id;\n\n\t\tid = of_match_device(of_match_ptr(act8865_dt_ids), dev);\n\t\tif (!id)\n\t\t\treturn -ENODEV;\n\n\t\ttype = (unsigned long) id->data;\n\n\t\tvoltage_select = !!of_get_property(dev->of_node,\n\t\t\t\t\t\t   \"active-semi,vsel-high\",\n\t\t\t\t\t\t   NULL);\n\t} else {\n\t\ttype = i2c_id->driver_data;\n\t\tpdata = dev_get_platdata(dev);\n\t}\n\n\tswitch (type) {\n\tcase ACT8600:\n\t\tregulators = act8600_regulators;\n\t\tnum_regulators = ARRAY_SIZE(act8600_regulators);\n\t\tregmap_config = &act8600_regmap_config;\n\t\toff_reg = -1;\n\t\toff_mask = -1;\n\t\tbreak;\n\tcase ACT8846:\n\t\tregulators = act8846_regulators;\n\t\tnum_regulators = ARRAY_SIZE(act8846_regulators);\n\t\tregmap_config = &act8865_regmap_config;\n\t\toff_reg = ACT8846_GLB_OFF_CTRL;\n\t\toff_mask = ACT8846_OFF_SYSMASK;\n\t\tbreak;\n\tcase ACT8865:\n\t\tif (voltage_select) {\n\t\t\tregulators = act8865_alt_regulators;\n\t\t\tnum_regulators = ARRAY_SIZE(act8865_alt_regulators);\n\t\t} else {\n\t\t\tregulators = act8865_regulators;\n\t\t\tnum_regulators = ARRAY_SIZE(act8865_regulators);\n\t\t}\n\t\tregmap_config = &act8865_regmap_config;\n\t\toff_reg = ACT8865_SYS_CTRL;\n\t\toff_mask = ACT8865_MSTROFF;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"invalid device id %lu\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tact8865 = devm_kzalloc(dev, sizeof(struct act8865), GFP_KERNEL);\n\tif (!act8865)\n\t\treturn -ENOMEM;\n\n\tact8865->regmap = devm_regmap_init_i2c(client, regmap_config);\n\tif (IS_ERR(act8865->regmap)) {\n\t\tret = PTR_ERR(act8865->regmap);\n\t\tdev_err(dev, \"Failed to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (of_device_is_system_power_controller(dev->of_node)) {\n\t\tif (!pm_power_off && (off_reg > 0)) {\n\t\t\tact8865_i2c_client = client;\n\t\t\tact8865->off_reg = off_reg;\n\t\t\tact8865->off_mask = off_mask;\n\t\t\tpm_power_off = act8865_power_off;\n\t\t} else {\n\t\t\tdev_err(dev, \"Failed to set poweroff capability, already defined\\n\");\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < num_regulators; i++) {\n\t\tconst struct regulator_desc *desc = &regulators[i];\n\t\tstruct regulator_config config = { };\n\t\tstruct regulator_dev *rdev;\n\n\t\tconfig.dev = dev;\n\t\tconfig.driver_data = act8865;\n\t\tconfig.regmap = act8865->regmap;\n\n\t\tif (pdata) {\n\t\t\tstruct act8865_regulator_data *rdata;\n\n\t\t\trdata = act8865_get_regulator_data(desc->id, pdata);\n\t\t\tif (rdata) {\n\t\t\t\tconfig.init_data = rdata->init_data;\n\t\t\t\tconfig.of_node = rdata->of_node;\n\t\t\t}\n\t\t}\n\n\t\trdev = devm_regulator_register(dev, desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(dev, \"failed to register %s\\n\", desc->name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\tif (type == ACT8600) {\n\t\tret = act8600_charger_probe(dev, act8865->regmap);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"Failed to probe charger\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ti2c_set_clientdata(client, act8865);\n\n\t \n\treturn type != ACT8865 ? 0 : regmap_write(act8865->regmap,\n\t\t\t\t\t\t  ACT8865_SYS_UNLK_REGS, 0xef);\n}\n\nstatic const struct i2c_device_id act8865_ids[] = {\n\t{ .name = \"act8600\", .driver_data = ACT8600 },\n\t{ .name = \"act8846\", .driver_data = ACT8846 },\n\t{ .name = \"act8865\", .driver_data = ACT8865 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, act8865_ids);\n\nstatic struct i2c_driver act8865_pmic_driver = {\n\t.driver\t= {\n\t\t.name\t= \"act8865\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t\t= act8865_pmic_probe,\n\t.id_table\t= act8865_ids,\n};\n\nmodule_i2c_driver(act8865_pmic_driver);\n\nMODULE_DESCRIPTION(\"active-semi act88xx voltage regulator driver\");\nMODULE_AUTHOR(\"Wenyou Yang <wenyou.yang@atmel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}