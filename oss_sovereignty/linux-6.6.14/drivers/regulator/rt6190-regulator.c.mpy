{
  "module_name": "rt6190-regulator.c",
  "hash_id": "3abbaf9112f0597b2fa615547f6be6bdcea5845a93bcd81fed5a4afdb9647bc0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rt6190-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n#define RT6190_REG_VID\t\t0x00\n#define RT6190_REG_OUTV\t\t0x01\n#define RT6190_REG_OUTC\t\t0x03\n#define RT6190_REG_SET1\t\t0x0D\n#define RT6190_REG_SET2\t\t0x0E\n#define RT6190_REG_SET4\t\t0x10\n#define RT6190_REG_RATIO\t0x11\n#define RT6190_REG_OUT_VOLT_L\t0x12\n#define RT6190_REG_TEMP_H\t0x1B\n#define RT6190_REG_STAT1\t0x1C\n#define RT6190_REG_ALERT1\t0x1E\n#define RT6190_REG_ALERT2\t0x1F\n#define RT6190_REG_MASK2\t0x21\n#define RT6190_REG_OCPEN\t0x28\n#define RT6190_REG_SET5\t\t0x29\n#define RT6190_REG_VBUSC_ADC\t0x32\n#define RT6190_REG_BUSC_VOLT_L\t0x33\n#define RT6190_REG_BUSC_VOLT_H\t0x34\n#define RT6190_REG_STAT3\t0x37\n#define RT6190_REG_ALERT3\t0x38\n#define RT6190_REG_MASK3\t0x39\n\n#define RT6190_ENPWM_MASK\tBIT(7)\n#define RT6190_ENDCHG_MASK\tBIT(4)\n#define RT6190_ALERT_OTPEVT\tBIT(6)\n#define RT6190_ALERT_UVPEVT\tBIT(5)\n#define RT6190_ALERT_OVPEVT\tBIT(4)\n#define RT6190_ENGCP_MASK\tBIT(1)\n#define RT6190_FCCM_MASK\tBIT(7)\n\n#define RICHTEK_VID\t\t0x82\n#define RT6190_OUT_MIN_UV\t3000000\n#define RT6190_OUT_MAX_UV\t32000000\n#define RT6190_OUT_STEP_UV\t20000\n#define RT6190_OUT_N_VOLT\t(RT6190_OUT_MAX_UV / RT6190_OUT_STEP_UV + 1)\n#define RT6190_OUTV_MINSEL\t150\n#define RT6190_OUT_MIN_UA\t306000\n#define RT6190_OUT_MAX_UA\t12114000\n#define RT6190_OUT_STEP_UA\t24000\n#define RT6190_OUTC_MINSEL\t19\n#define RT6190_EN_TIME_US\t500\n\n#define RT6190_PSM_MODE\t\t0\n#define RT6190_FCCM_MODE\t1\n\nstruct rt6190_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *enable_gpio;\n\tunsigned int cached_alert_evt;\n};\n\nstatic int rt6190_out_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t      unsigned int selector)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\t__le16 le_sel = cpu_to_le16(selector);\n\n\treturn regmap_raw_write(regmap, RT6190_REG_OUTV, &le_sel,\n\t\t\t\tsizeof(le_sel));\n}\n\nstatic int rt6190_out_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\t__le16 le_sel;\n\tint ret;\n\n\tret = regmap_raw_read(regmap, RT6190_REG_OUTV, &le_sel, sizeof(le_sel));\n\n\treturn ret ?: le16_to_cpu(le_sel);\n}\n\nstatic int rt6190_out_enable(struct regulator_dev *rdev)\n{\n\tstruct rt6190_data *data = rdev_get_drvdata(rdev);\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tu8 out_cfg[4];\n\tint ret;\n\n\tpm_runtime_get_sync(data->dev);\n\n\t \n\tret = regmap_raw_read(regmap, RT6190_REG_OUTV, out_cfg,\n\t\t\t      sizeof(out_cfg));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_enable_regmap(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_raw_write(regmap, RT6190_REG_OUTV, out_cfg,\n\t\t\t       sizeof(out_cfg));\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(regmap, RT6190_REG_SET5, RT6190_ENGCP_MASK,\n\t\t\t\t  RT6190_ENGCP_MASK);\n}\n\nstatic int rt6190_out_disable(struct regulator_dev *rdev)\n{\n\tstruct rt6190_data *data = rdev_get_drvdata(rdev);\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tint ret;\n\n\tret = regmap_update_bits(regmap, RT6190_REG_SET5, RT6190_ENGCP_MASK, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_disable_regmap(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdata->cached_alert_evt = 0;\n\n\tpm_runtime_put(data->dev);\n\n\treturn 0;\n}\n\nstatic int rt6190_out_set_current_limit(struct regulator_dev *rdev, int min_uA,\n\t\t\t\t\tint max_uA)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tint csel, clim;\n\t__le16 le_csel;\n\n\tif (min_uA < RT6190_OUT_MIN_UA || max_uA > RT6190_OUT_MAX_UA)\n\t\treturn -EINVAL;\n\n\tcsel = DIV_ROUND_UP(min_uA - RT6190_OUT_MIN_UA, RT6190_OUT_STEP_UA);\n\n\tclim = RT6190_OUT_MIN_UA + RT6190_OUT_STEP_UA * csel;\n\tif (clim > max_uA)\n\t\treturn -EINVAL;\n\n\tcsel += RT6190_OUTC_MINSEL;\n\tle_csel = cpu_to_le16(csel);\n\n\treturn regmap_raw_write(regmap, RT6190_REG_OUTC, &le_csel,\n\t\t\t\tsizeof(le_csel));\n}\n\nstatic int rt6190_out_get_current_limit(struct regulator_dev *rdev)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\t__le16 le_csel;\n\tint csel, ret;\n\n\tret = regmap_raw_read(regmap, RT6190_REG_OUTC, &le_csel,\n\t\t\t      sizeof(le_csel));\n\tif (ret)\n\t\treturn ret;\n\n\tcsel = le16_to_cpu(le_csel);\n\tcsel -= RT6190_OUTC_MINSEL;\n\n\treturn RT6190_OUT_MIN_UA + RT6190_OUT_STEP_UA * csel;\n}\n\nstatic int rt6190_out_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tval = RT6190_FCCM_MASK;\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(regmap, RT6190_REG_SET1, RT6190_FCCM_MASK,\n\t\t\t\t  val);\n}\n\nstatic unsigned int rt6190_out_get_mode(struct regulator_dev *rdev)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int config;\n\tint ret;\n\n\tret = regmap_read(regmap, RT6190_REG_SET1, &config);\n\tif (ret)\n\t\treturn REGULATOR_MODE_INVALID;\n\n\tif (config & RT6190_FCCM_MASK)\n\t\treturn REGULATOR_MODE_FAST;\n\n\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int rt6190_out_get_error_flags(struct regulator_dev *rdev,\n\t\t\t\t      unsigned int *flags)\n{\n\tstruct rt6190_data *data = rdev_get_drvdata(rdev);\n\tunsigned int state, rpt_flags = 0;\n\tint ret;\n\n\tret = regmap_read(data->regmap, RT6190_REG_STAT1, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tstate |= data->cached_alert_evt;\n\n\tif (state & RT6190_ALERT_OTPEVT)\n\t\trpt_flags |= REGULATOR_ERROR_OVER_TEMP;\n\n\tif (state & RT6190_ALERT_UVPEVT)\n\t\trpt_flags |= REGULATOR_ERROR_UNDER_VOLTAGE;\n\n\tif (state & RT6190_ALERT_OVPEVT)\n\t\trpt_flags |= REGULATOR_ERROR_REGULATION_OUT;\n\n\t*flags = rpt_flags;\n\n\treturn 0;\n}\n\nstatic unsigned int rt6190_out_of_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase RT6190_PSM_MODE:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase RT6190_FCCM_MODE:\n\t\treturn REGULATOR_MODE_FAST;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic const struct regulator_ops rt6190_regulator_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = rt6190_out_set_voltage_sel,\n\t.get_voltage_sel = rt6190_out_get_voltage_sel,\n\t.enable = rt6190_out_enable,\n\t.disable = rt6190_out_disable,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_current_limit = rt6190_out_set_current_limit,\n\t.get_current_limit = rt6190_out_get_current_limit,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n\t.set_mode = rt6190_out_set_mode,\n\t.get_mode = rt6190_out_get_mode,\n\t.get_error_flags = rt6190_out_get_error_flags,\n};\n\nstatic const struct regulator_desc rt6190_regulator_desc = {\n\t.name = \"rt6190-regulator\",\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n\t.ops = &rt6190_regulator_ops,\n\t.min_uV = RT6190_OUT_MIN_UV,\n\t.uV_step = RT6190_OUT_STEP_UV,\n\t.n_voltages = RT6190_OUT_N_VOLT,\n\t.linear_min_sel = RT6190_OUTV_MINSEL,\n\t.enable_reg = RT6190_REG_SET2,\n\t.enable_mask = RT6190_ENPWM_MASK,\n\t.active_discharge_reg = RT6190_REG_SET2,\n\t.active_discharge_mask = RT6190_ENDCHG_MASK,\n\t.active_discharge_on = RT6190_ENDCHG_MASK,\n\t.of_map_mode = rt6190_out_of_map_mode,\n};\n\nstatic bool rt6190_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RT6190_REG_OUT_VOLT_L ... RT6190_REG_ALERT2:\n\tcase RT6190_REG_BUSC_VOLT_L ... RT6190_REG_BUSC_VOLT_H:\n\tcase RT6190_REG_STAT3 ... RT6190_REG_ALERT3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config rt6190_regmap_config = {\n\t.name = \"rt6190\",\n\t.cache_type = REGCACHE_FLAT,\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RT6190_REG_MASK3,\n\t.num_reg_defaults_raw = RT6190_REG_MASK3 + 1,\n\t.volatile_reg = rt6190_is_volatile_reg,\n};\n\nstatic irqreturn_t rt6190_irq_handler(int irq, void *devid)\n{\n\tstruct regulator_dev *rdev = devid;\n\tstruct rt6190_data *data = rdev_get_drvdata(rdev);\n\tunsigned int alert;\n\tint ret;\n\n\tret = regmap_read(data->regmap, RT6190_REG_ALERT1, &alert);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\t \n\tret = regmap_write(data->regmap, RT6190_REG_ALERT1, alert);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tdata->cached_alert_evt |= alert;\n\n\tif (alert & RT6190_ALERT_OTPEVT)\n\t\tregulator_notifier_call_chain(rdev, REGULATOR_EVENT_OVER_TEMP, NULL);\n\n\tif (alert & RT6190_ALERT_UVPEVT)\n\t\tregulator_notifier_call_chain(rdev, REGULATOR_EVENT_UNDER_VOLTAGE, NULL);\n\n\tif (alert & RT6190_ALERT_OVPEVT)\n\t\tregulator_notifier_call_chain(rdev, REGULATOR_EVENT_REGULATION_OUT, NULL);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rt6190_init_registers(struct regmap *regmap)\n{\n\tint ret;\n\n\t \n\tret = regmap_write(regmap, RT6190_REG_SET4, 0x82);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(regmap, RT6190_REG_RATIO, 0x20);\n\n\t \n\tret = regmap_write(regmap, RT6190_REG_MASK2, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(regmap, RT6190_REG_OCPEN, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_write(regmap, RT6190_REG_VBUSC_ADC, 0x02);\n}\n\nstatic int rt6190_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct rt6190_data *data;\n\tstruct gpio_desc *enable_gpio;\n\tstruct regmap *regmap;\n\tstruct regulator_dev *rdev;\n\tstruct regulator_config cfg = {};\n\tunsigned int vid;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tenable_gpio = devm_gpiod_get_optional(dev, \"enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(enable_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(enable_gpio), \"Failed to get 'enable' gpio\\n\");\n\telse if (enable_gpio)\n\t\tusleep_range(RT6190_EN_TIME_US, RT6190_EN_TIME_US * 2);\n\n\tregmap = devm_regmap_init_i2c(i2c, &rt6190_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap), \"Failed to init regmap\\n\");\n\n\tdata->dev = dev;\n\tdata->enable_gpio = enable_gpio;\n\tdata->regmap = regmap;\n\ti2c_set_clientdata(i2c, data);\n\n\tret = regmap_read(regmap, RT6190_REG_VID, &vid);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to read VID\\n\");\n\n\tif (vid != RICHTEK_VID)\n\t\treturn dev_err_probe(dev, -ENODEV, \"Incorrect VID 0x%02x\\n\", vid);\n\n\tret = rt6190_init_registers(regmap);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to init registers\\n\");\n\n\tpm_runtime_set_active(dev);\n\tret = devm_pm_runtime_enable(dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to set pm_runtime enable\\n\");\n\n\tcfg.dev = dev;\n\tcfg.of_node = dev->of_node;\n\tcfg.driver_data = data;\n\tcfg.init_data = of_get_regulator_init_data(dev, dev->of_node,\n\t\t\t\t\t\t   &rt6190_regulator_desc);\n\n\trdev = devm_regulator_register(dev, &rt6190_regulator_desc, &cfg);\n\tif (IS_ERR(rdev))\n\t\treturn dev_err_probe(dev, PTR_ERR(rdev), \"Failed to register regulator\\n\");\n\n\tif (i2c->irq) {\n\t\tret = devm_request_threaded_irq(dev, i2c->irq, NULL,\n\t\t\t\t\t\trt6190_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT, dev_name(dev),\n\t\t\t\t\t\trdev);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"Failed to register interrupt\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int rt6190_runtime_suspend(struct device *dev)\n{\n\tstruct rt6190_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\n\tif (!data->enable_gpio)\n\t\treturn 0;\n\n\tregcache_cache_only(regmap, true);\n\tregcache_mark_dirty(regmap);\n\n\tgpiod_set_value(data->enable_gpio, 0);\n\n\treturn 0;\n}\n\nstatic int rt6190_runtime_resume(struct device *dev)\n{\n\tstruct rt6190_data *data = dev_get_drvdata(dev);\n\tstruct regmap *regmap = data->regmap;\n\n\tif (!data->enable_gpio)\n\t\treturn 0;\n\n\tgpiod_set_value(data->enable_gpio, 1);\n\tusleep_range(RT6190_EN_TIME_US, RT6190_EN_TIME_US * 2);\n\n\tregcache_cache_only(regmap, false);\n\treturn regcache_sync(regmap);\n}\n\nstatic const struct dev_pm_ops __maybe_unused rt6190_dev_pm = {\n\tRUNTIME_PM_OPS(rt6190_runtime_suspend, rt6190_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id rt6190_of_dev_table[] = {\n\t{ .compatible = \"richtek,rt6190\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rt6190_of_dev_table);\n\nstatic struct i2c_driver rt6190_driver = {\n\t.driver = {\n\t\t.name = \"rt6190\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = rt6190_of_dev_table,\n\t\t.pm = pm_ptr(&rt6190_dev_pm),\n\t},\n\t.probe = rt6190_probe,\n};\nmodule_i2c_driver(rt6190_driver);\n\nMODULE_DESCRIPTION(\"Richtek RT6190 regulator driver\");\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}