{
  "module_name": "da903x-regulator.c",
  "hash_id": "a647c1c766615962e382e93e000a35ed5192f7568d30c10b40f952961e14c15b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/da903x-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/mfd/da903x.h>\n\n \n#define DA9030_INVAL\t\t(-1)\n#define DA9030_LDO1011\t\t(0x10)\n#define DA9030_LDO15\t\t(0x11)\n#define DA9030_LDO1416\t\t(0x12)\n#define DA9030_LDO1819\t\t(0x13)\n#define DA9030_LDO17\t\t(0x14)\n#define DA9030_BUCK2DVM1\t(0x15)\n#define DA9030_BUCK2DVM2\t(0x16)\n#define DA9030_RCTL11\t\t(0x17)\n#define DA9030_RCTL21\t\t(0x18)\n#define DA9030_LDO1\t\t(0x90)\n#define DA9030_LDO23\t\t(0x91)\n#define DA9030_LDO45\t\t(0x92)\n#define DA9030_LDO6\t\t(0x93)\n#define DA9030_LDO78\t\t(0x94)\n#define DA9030_LDO912\t\t(0x95)\n#define DA9030_BUCK\t\t(0x96)\n#define DA9030_RCTL12\t\t(0x97)\n#define DA9030_RCTL22\t\t(0x98)\n#define DA9030_LDO_UNLOCK\t(0xa0)\n#define DA9030_LDO_UNLOCK_MASK\t(0xe0)\n#define DA9034_OVER1\t\t(0x10)\n\n \n#define DA9034_INVAL\t\t(-1)\n#define DA9034_OVER2\t\t(0x11)\n#define DA9034_OVER3\t\t(0x12)\n#define DA9034_LDO643\t\t(0x13)\n#define DA9034_LDO987\t\t(0x14)\n#define DA9034_LDO1110\t\t(0x15)\n#define DA9034_LDO1312\t\t(0x16)\n#define DA9034_LDO1514\t\t(0x17)\n#define DA9034_VCC1\t\t(0x20)\n#define DA9034_ADTV1\t\t(0x23)\n#define DA9034_ADTV2\t\t(0x24)\n#define DA9034_AVRC\t\t(0x25)\n#define DA9034_CDTV1\t\t(0x26)\n#define DA9034_CDTV2\t\t(0x27)\n#define DA9034_CVRC\t\t(0x28)\n#define DA9034_SDTV1\t\t(0x29)\n#define DA9034_SDTV2\t\t(0x2a)\n#define DA9034_SVRC\t\t(0x2b)\n#define DA9034_MDTV1\t\t(0x32)\n#define DA9034_MDTV2\t\t(0x33)\n#define DA9034_MVRC\t\t(0x34)\n\n \n#define DA9035_OVER3\t\t(0x12)\n#define DA9035_VCC2\t\t(0x1f)\n#define DA9035_3DTV1\t\t(0x2c)\n#define DA9035_3DTV2\t\t(0x2d)\n#define DA9035_3VRC\t\t(0x2e)\n#define DA9035_AUTOSKIP\t\t(0x2f)\n\nstruct da903x_regulator_info {\n\tstruct regulator_desc desc;\n\n\tint\tmax_uV;\n\tint\tvol_reg;\n\tint\tvol_shift;\n\tint\tvol_nbits;\n\tint\tupdate_reg;\n\tint\tupdate_bit;\n\tint\tenable_reg;\n\tint\tenable_bit;\n};\n\nstatic inline struct device *to_da903x_dev(struct regulator_dev *rdev)\n{\n\treturn rdev_get_dev(rdev)->parent->parent;\n}\n\nstatic inline int check_range(struct da903x_regulator_info *info,\n\t\t\t\tint min_uV, int max_uV)\n{\n\tif (min_uV < info->desc.min_uV || min_uV > info->max_uV)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int da903x_set_voltage_sel(struct regulator_dev *rdev, unsigned selector)\n{\n\tstruct da903x_regulator_info *info = rdev_get_drvdata(rdev);\n\tstruct device *da9034_dev = to_da903x_dev(rdev);\n\tuint8_t val, mask;\n\n\tif (rdev->desc->n_voltages == 1)\n\t\treturn -EINVAL;\n\n\tval = selector << info->vol_shift;\n\tmask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;\n\n\treturn da903x_update(da9034_dev, info->vol_reg, val, mask);\n}\n\nstatic int da903x_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct da903x_regulator_info *info = rdev_get_drvdata(rdev);\n\tstruct device *da9034_dev = to_da903x_dev(rdev);\n\tuint8_t val, mask;\n\tint ret;\n\n\tif (rdev->desc->n_voltages == 1)\n\t\treturn 0;\n\n\tret = da903x_read(da9034_dev, info->vol_reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;\n\tval = (val & mask) >> info->vol_shift;\n\n\treturn val;\n}\n\nstatic int da903x_enable(struct regulator_dev *rdev)\n{\n\tstruct da903x_regulator_info *info = rdev_get_drvdata(rdev);\n\tstruct device *da9034_dev = to_da903x_dev(rdev);\n\n\treturn da903x_set_bits(da9034_dev, info->enable_reg,\n\t\t\t\t\t1 << info->enable_bit);\n}\n\nstatic int da903x_disable(struct regulator_dev *rdev)\n{\n\tstruct da903x_regulator_info *info = rdev_get_drvdata(rdev);\n\tstruct device *da9034_dev = to_da903x_dev(rdev);\n\n\treturn da903x_clr_bits(da9034_dev, info->enable_reg,\n\t\t\t\t\t1 << info->enable_bit);\n}\n\nstatic int da903x_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct da903x_regulator_info *info = rdev_get_drvdata(rdev);\n\tstruct device *da9034_dev = to_da903x_dev(rdev);\n\tuint8_t reg_val;\n\tint ret;\n\n\tret = da903x_read(da9034_dev, info->enable_reg, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(reg_val & (1 << info->enable_bit));\n}\n\n \nstatic int da9030_set_ldo1_15_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\t  unsigned selector)\n{\n\tstruct da903x_regulator_info *info = rdev_get_drvdata(rdev);\n\tstruct device *da903x_dev = to_da903x_dev(rdev);\n\tuint8_t val, mask;\n\tint ret;\n\n\tval = selector << info->vol_shift;\n\tmask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;\n\tval |= DA9030_LDO_UNLOCK;  \n\tmask |= DA9030_LDO_UNLOCK_MASK;\n\n\t \n\tret = da903x_update(da903x_dev, info->vol_reg, val, mask);\n\tif (ret)\n\t\treturn ret;\n\n\treturn da903x_update(da903x_dev, info->vol_reg, val, mask);\n}\n\nstatic int da9030_map_ldo14_voltage(struct regulator_dev *rdev,\n\t\t\t\t    int min_uV, int max_uV)\n{\n\tstruct da903x_regulator_info *info = rdev_get_drvdata(rdev);\n\tint thresh, sel;\n\n\tif (check_range(info, min_uV, max_uV)) {\n\t\tpr_err(\"invalid voltage range (%d, %d) uV\\n\", min_uV, max_uV);\n\t\treturn -EINVAL;\n\t}\n\n\tthresh = (info->max_uV + info->desc.min_uV) / 2;\n\tif (min_uV < thresh) {\n\t\tsel = DIV_ROUND_UP(thresh - min_uV, info->desc.uV_step);\n\t\tsel |= 0x4;\n\t} else {\n\t\tsel = DIV_ROUND_UP(min_uV - thresh, info->desc.uV_step);\n\t}\n\n\treturn sel;\n}\n\nstatic int da9030_list_ldo14_voltage(struct regulator_dev *rdev,\n\t\t\t\t     unsigned selector)\n{\n\tstruct da903x_regulator_info *info = rdev_get_drvdata(rdev);\n\tint volt;\n\n\tif (selector & 0x4)\n\t\tvolt = rdev->desc->min_uV +\n\t\t       rdev->desc->uV_step * (3 - (selector & ~0x4));\n\telse\n\t\tvolt = (info->max_uV + rdev->desc->min_uV) / 2 +\n\t\t       rdev->desc->uV_step * (selector & ~0x4);\n\n\tif (volt > info->max_uV)\n\t\treturn -EINVAL;\n\n\treturn volt;\n}\n\n \nstatic int da9034_set_dvc_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t      unsigned selector)\n{\n\tstruct da903x_regulator_info *info = rdev_get_drvdata(rdev);\n\tstruct device *da9034_dev = to_da903x_dev(rdev);\n\tuint8_t val, mask;\n\tint ret;\n\n\tval = selector << info->vol_shift;\n\tmask = ((1 << info->vol_nbits) - 1)  << info->vol_shift;\n\n\tret = da903x_update(da9034_dev, info->vol_reg, val, mask);\n\tif (ret)\n\t\treturn ret;\n\n\tret = da903x_set_bits(da9034_dev, info->update_reg,\n\t\t\t\t\t1 << info->update_bit);\n\treturn ret;\n}\n\nstatic const struct linear_range da9034_ldo12_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1700000, 0, 7, 50000),\n\tREGULATOR_LINEAR_RANGE(2700000, 8, 15, 50000),\n};\n\nstatic const struct regulator_ops da903x_regulator_ldo_ops = {\n\t.set_voltage_sel = da903x_set_voltage_sel,\n\t.get_voltage_sel = da903x_get_voltage_sel,\n\t.list_voltage\t= regulator_list_voltage_linear,\n\t.map_voltage\t= regulator_map_voltage_linear,\n\t.enable\t\t= da903x_enable,\n\t.disable\t= da903x_disable,\n\t.is_enabled\t= da903x_is_enabled,\n};\n\n \nstatic const struct regulator_ops da9030_regulator_ldo14_ops = {\n\t.set_voltage_sel = da903x_set_voltage_sel,\n\t.get_voltage_sel = da903x_get_voltage_sel,\n\t.list_voltage\t= da9030_list_ldo14_voltage,\n\t.map_voltage\t= da9030_map_ldo14_voltage,\n\t.enable\t\t= da903x_enable,\n\t.disable\t= da903x_disable,\n\t.is_enabled\t= da903x_is_enabled,\n};\n\n \nstatic const struct regulator_ops da9030_regulator_ldo1_15_ops = {\n\t.set_voltage_sel = da9030_set_ldo1_15_voltage_sel,\n\t.get_voltage_sel = da903x_get_voltage_sel,\n\t.list_voltage\t= regulator_list_voltage_linear,\n\t.map_voltage\t= regulator_map_voltage_linear,\n\t.enable\t\t= da903x_enable,\n\t.disable\t= da903x_disable,\n\t.is_enabled\t= da903x_is_enabled,\n};\n\nstatic const struct regulator_ops da9034_regulator_dvc_ops = {\n\t.set_voltage_sel = da9034_set_dvc_voltage_sel,\n\t.get_voltage_sel = da903x_get_voltage_sel,\n\t.list_voltage\t= regulator_list_voltage_linear,\n\t.map_voltage\t= regulator_map_voltage_linear,\n\t.enable\t\t= da903x_enable,\n\t.disable\t= da903x_disable,\n\t.is_enabled\t= da903x_is_enabled,\n};\n\n \nstatic const struct regulator_ops da9034_regulator_ldo12_ops = {\n\t.set_voltage_sel = da903x_set_voltage_sel,\n\t.get_voltage_sel = da903x_get_voltage_sel,\n\t.list_voltage\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t= regulator_map_voltage_linear_range,\n\t.enable\t\t= da903x_enable,\n\t.disable\t= da903x_disable,\n\t.is_enabled\t= da903x_is_enabled,\n};\n\n#define DA903x_LDO(_pmic, _id, min, max, step, vreg, shift, nbits, ereg, ebit)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.desc\t= {\t\t\t\t\t\t\t\\\n\t\t.name\t= \"LDO\" #_id,\t\t\t\t\t\\\n\t\t.ops\t= &da903x_regulator_ldo_ops,\t\t\t\\\n\t\t.type\t= REGULATOR_VOLTAGE,\t\t\t\t\\\n\t\t.id\t= _pmic##_ID_LDO##_id,\t\t\t\t\\\n\t\t.n_voltages = (step) ? ((max - min) / step + 1) : 1,\t\\\n\t\t.owner\t= THIS_MODULE,\t\t\t\t\t\\\n\t\t.min_uV\t = (min) * 1000,\t\t\t\t\\\n\t\t.uV_step = (step) * 1000,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.max_uV\t\t= (max) * 1000,\t\t\t\t\t\\\n\t.vol_reg\t= _pmic##_##vreg,\t\t\t\t\\\n\t.vol_shift\t= (shift),\t\t\t\t\t\\\n\t.vol_nbits\t= (nbits),\t\t\t\t\t\\\n\t.enable_reg\t= _pmic##_##ereg,\t\t\t\t\\\n\t.enable_bit\t= (ebit),\t\t\t\t\t\\\n}\n\n#define DA903x_DVC(_pmic, _id, min, max, step, vreg, nbits, ureg, ubit, ereg, ebit) \\\n{\t\t\t\t\t\t\t\t\t\\\n\t.desc\t= {\t\t\t\t\t\t\t\\\n\t\t.name\t= #_id,\t\t\t\t\t\t\\\n\t\t.ops\t= &da9034_regulator_dvc_ops,\t\t\t\\\n\t\t.type\t= REGULATOR_VOLTAGE,\t\t\t\t\\\n\t\t.id\t= _pmic##_ID_##_id,\t\t\t\t\\\n\t\t.n_voltages = (step) ? ((max - min) / step + 1) : 1,\t\\\n\t\t.owner\t= THIS_MODULE,\t\t\t\t\t\\\n\t\t.min_uV = (min) * 1000,\t\t\t\t\t\\\n\t\t.uV_step = (step) * 1000,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.max_uV\t\t= (max) * 1000,\t\t\t\t\t\\\n\t.vol_reg\t= _pmic##_##vreg,\t\t\t\t\\\n\t.vol_shift\t= (0),\t\t\t\t\t\t\\\n\t.vol_nbits\t= (nbits),\t\t\t\t\t\\\n\t.update_reg\t= _pmic##_##ureg,\t\t\t\t\\\n\t.update_bit\t= (ubit),\t\t\t\t\t\\\n\t.enable_reg\t= _pmic##_##ereg,\t\t\t\t\\\n\t.enable_bit\t= (ebit),\t\t\t\t\t\\\n}\n\n#define DA9034_LDO(_id, min, max, step, vreg, shift, nbits, ereg, ebit)\t\\\n\tDA903x_LDO(DA9034, _id, min, max, step, vreg, shift, nbits, ereg, ebit)\n\n#define DA9030_LDO(_id, min, max, step, vreg, shift, nbits, ereg, ebit)\t\\\n\tDA903x_LDO(DA9030, _id, min, max, step, vreg, shift, nbits, ereg, ebit)\n\n#define DA9030_DVC(_id, min, max, step, vreg, nbits, ureg, ubit, ereg, ebit) \\\n\tDA903x_DVC(DA9030, _id, min, max, step, vreg, nbits, ureg, ubit, \\\n\t\t   ereg, ebit)\n\n#define DA9034_DVC(_id, min, max, step, vreg, nbits, ureg, ubit, ereg, ebit) \\\n\tDA903x_DVC(DA9034, _id, min, max, step, vreg, nbits, ureg, ubit, \\\n\t\t   ereg, ebit)\n\n#define DA9035_DVC(_id, min, max, step, vreg, nbits, ureg, ubit, ereg, ebit) \\\n\tDA903x_DVC(DA9035, _id, min, max, step, vreg, nbits, ureg, ubit, \\\n\t\t   ereg, ebit)\n\nstatic struct da903x_regulator_info da903x_regulator_info[] = {\n\t \n\tDA9030_DVC(BUCK2, 850, 1625, 25, BUCK2DVM1, 5, BUCK2DVM1, 7, RCTL11, 0),\n\n\tDA9030_LDO( 1, 1200, 3200, 100,    LDO1, 0, 5, RCTL12, 1),\n\tDA9030_LDO( 2, 1800, 3200, 100,   LDO23, 0, 4, RCTL12, 2),\n\tDA9030_LDO( 3, 1800, 3200, 100,   LDO23, 4, 4, RCTL12, 3),\n\tDA9030_LDO( 4, 1800, 3200, 100,   LDO45, 0, 4, RCTL12, 4),\n\tDA9030_LDO( 5, 1800, 3200, 100,   LDO45, 4, 4, RCTL12, 5),\n\tDA9030_LDO( 6, 1800, 3200, 100,    LDO6, 0, 4, RCTL12, 6),\n\tDA9030_LDO( 7, 1800, 3200, 100,   LDO78, 0, 4, RCTL12, 7),\n\tDA9030_LDO( 8, 1800, 3200, 100,   LDO78, 4, 4, RCTL22, 0),\n\tDA9030_LDO( 9, 1800, 3200, 100,  LDO912, 0, 4, RCTL22, 1),\n\tDA9030_LDO(10, 1800, 3200, 100, LDO1011, 0, 4, RCTL22, 2),\n\tDA9030_LDO(11, 1800, 3200, 100, LDO1011, 4, 4, RCTL22, 3),\n\tDA9030_LDO(12, 1800, 3200, 100,  LDO912, 4, 4, RCTL22, 4),\n\tDA9030_LDO(14, 2760, 2940,  30, LDO1416, 0, 3, RCTL11, 4),\n\tDA9030_LDO(15, 1100, 2650,  50,\t  LDO15, 0, 5, RCTL11, 5),\n\tDA9030_LDO(16, 1100, 2650,  50, LDO1416, 3, 5, RCTL11, 6),\n\tDA9030_LDO(17, 1800, 3200, 100,   LDO17, 0, 4, RCTL11, 7),\n\tDA9030_LDO(18, 1800, 3200, 100, LDO1819, 0, 4, RCTL21, 2),\n\tDA9030_LDO(19, 1800, 3200, 100, LDO1819, 4, 4, RCTL21, 1),\n\tDA9030_LDO(13, 2100, 2100, 0, INVAL, 0, 0, RCTL11, 3),  \n\n\t \n\tDA9034_DVC(BUCK1, 725, 1500, 25, ADTV2, 5, VCC1, 0, OVER1, 0),\n\tDA9034_DVC(BUCK2, 725, 1500, 25, CDTV2, 5, VCC1, 2, OVER1, 1),\n\tDA9034_DVC(LDO2,  725, 1500, 25, SDTV2, 5, VCC1, 4, OVER1, 2),\n\tDA9034_DVC(LDO1, 1700, 2075, 25, MDTV1, 4, VCC1, 6, OVER3, 4),\n\n\tDA9034_LDO( 3, 1800, 3300, 100,  LDO643, 0, 4, OVER3, 5),\n\tDA9034_LDO( 4, 1800, 2900,1100,  LDO643, 4, 1, OVER3, 6),\n\tDA9034_LDO( 6, 2500, 2850,  50,  LDO643, 5, 3, OVER2, 0),\n\tDA9034_LDO( 7, 2700, 3050,  50,  LDO987, 0, 3, OVER2, 1),\n\tDA9034_LDO( 8, 2700, 2850,  50,  LDO987, 3, 2, OVER2, 2),\n\tDA9034_LDO( 9, 2700, 3050,  50,  LDO987, 5, 3, OVER2, 3),\n\tDA9034_LDO(10, 2700, 3050,  50, LDO1110, 0, 3, OVER2, 4),\n\tDA9034_LDO(11, 1800, 3300, 100, LDO1110, 4, 4, OVER2, 5),\n\tDA9034_LDO(12, 1700, 3050,  50, LDO1312, 0, 4, OVER3, 6),\n\tDA9034_LDO(13, 1800, 3300, 100, LDO1312, 4, 4, OVER2, 7),\n\tDA9034_LDO(14, 1800, 3300, 100, LDO1514, 0, 4, OVER3, 0),\n\tDA9034_LDO(15, 1800, 3300, 100, LDO1514, 4, 4, OVER3, 1),\n\tDA9034_LDO(5, 3100, 3100, 0, INVAL, 0, 0, OVER3, 7),  \n\n\t \n\tDA9035_DVC(BUCK3, 1800, 2200, 100, 3DTV1, 3, VCC2, 0, OVER3, 3),\n};\n\nstatic inline struct da903x_regulator_info *find_regulator_info(int id)\n{\n\tstruct da903x_regulator_info *ri;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(da903x_regulator_info); i++) {\n\t\tri = &da903x_regulator_info[i];\n\t\tif (ri->desc.id == id)\n\t\t\treturn ri;\n\t}\n\treturn NULL;\n}\n\nstatic int da903x_regulator_probe(struct platform_device *pdev)\n{\n\tstruct da903x_regulator_info *ri = NULL;\n\tstruct regulator_dev *rdev;\n\tstruct regulator_config config = { };\n\n\tri = find_regulator_info(pdev->id);\n\tif (ri == NULL) {\n\t\tdev_err(&pdev->dev, \"invalid regulator ID specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ri->desc.id == DA9034_ID_LDO12) {\n\t\tri->desc.ops = &da9034_regulator_ldo12_ops;\n\t\tri->desc.n_voltages = 16;\n\t\tri->desc.linear_ranges = da9034_ldo12_ranges;\n\t\tri->desc.n_linear_ranges = ARRAY_SIZE(da9034_ldo12_ranges);\n\t}\n\n\tif (ri->desc.id == DA9030_ID_LDO14)\n\t\tri->desc.ops = &da9030_regulator_ldo14_ops;\n\n\tif (ri->desc.id == DA9030_ID_LDO1 || ri->desc.id == DA9030_ID_LDO15)\n\t\tri->desc.ops = &da9030_regulator_ldo1_15_ops;\n\n\tconfig.dev = &pdev->dev;\n\tconfig.init_data = dev_get_platdata(&pdev->dev);\n\tconfig.driver_data = ri;\n\n\trdev = devm_regulator_register(&pdev->dev, &ri->desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(&pdev->dev, \"failed to register regulator %s\\n\",\n\t\t\t\tri->desc.name);\n\t\treturn PTR_ERR(rdev);\n\t}\n\n\tplatform_set_drvdata(pdev, rdev);\n\treturn 0;\n}\n\nstatic struct platform_driver da903x_regulator_driver = {\n\t.driver\t= {\n\t\t.name\t= \"da903x-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t\t= da903x_regulator_probe,\n};\n\nstatic int __init da903x_regulator_init(void)\n{\n\treturn platform_driver_register(&da903x_regulator_driver);\n}\nsubsys_initcall(da903x_regulator_init);\n\nstatic void __exit da903x_regulator_exit(void)\n{\n\tplatform_driver_unregister(&da903x_regulator_driver);\n}\nmodule_exit(da903x_regulator_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Eric Miao <eric.miao@marvell.com>\"\n\t      \"Mike Rapoport <mike@compulab.co.il>\");\nMODULE_DESCRIPTION(\"Regulator Driver for Dialog Semiconductor DA903X PMIC\");\nMODULE_ALIAS(\"platform:da903x-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}