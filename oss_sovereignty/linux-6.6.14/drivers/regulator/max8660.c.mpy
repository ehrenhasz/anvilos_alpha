{
  "module_name": "max8660.c",
  "hash_id": "caea9c3eee3dcea19f2eaf0bb8c34feb8eca879f51780e7b8bc36d8f712409b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/max8660.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/slab.h>\n#include <linux/regulator/max8660.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/regulator/of_regulator.h>\n\n#define MAX8660_DCDC_MIN_UV\t 725000\n#define MAX8660_DCDC_MAX_UV\t1800000\n#define MAX8660_DCDC_STEP\t  25000\n#define MAX8660_DCDC_MAX_SEL\t0x2b\n\n#define MAX8660_LDO5_MIN_UV\t1700000\n#define MAX8660_LDO5_MAX_UV\t2000000\n#define MAX8660_LDO5_STEP\t  25000\n#define MAX8660_LDO5_MAX_SEL\t0x0c\n\n#define MAX8660_LDO67_MIN_UV\t1800000\n#define MAX8660_LDO67_MAX_UV\t3300000\n#define MAX8660_LDO67_STEP\t 100000\n#define MAX8660_LDO67_MAX_SEL\t0x0f\n\nenum {\n\tMAX8660_OVER1,\n\tMAX8660_OVER2,\n\tMAX8660_VCC1,\n\tMAX8660_ADTV1,\n\tMAX8660_ADTV2,\n\tMAX8660_SDTV1,\n\tMAX8660_SDTV2,\n\tMAX8660_MDTV1,\n\tMAX8660_MDTV2,\n\tMAX8660_L12VCR,\n\tMAX8660_FPWM,\n\tMAX8660_N_REGS,\t \n};\n\nstruct max8660 {\n\tstruct i2c_client *client;\n\tu8 shadow_regs[MAX8660_N_REGS];\t\t \n};\n\nstatic int max8660_write(struct max8660 *max8660, u8 reg, u8 mask, u8 val)\n{\n\tstatic const u8 max8660_addresses[MAX8660_N_REGS] = {\n\t 0x10, 0x12, 0x20, 0x23, 0x24, 0x29, 0x2a, 0x32, 0x33, 0x39, 0x80\n\t};\n\n\tint ret;\n\tu8 reg_val = (max8660->shadow_regs[reg] & mask) | val;\n\n\tdev_vdbg(&max8660->client->dev, \"Writing reg %02x with %02x\\n\",\n\t\t\tmax8660_addresses[reg], reg_val);\n\n\tret = i2c_smbus_write_byte_data(max8660->client,\n\t\t\tmax8660_addresses[reg], reg_val);\n\tif (ret == 0)\n\t\tmax8660->shadow_regs[reg] = reg_val;\n\n\treturn ret;\n}\n\n\n \n\nstatic int max8660_dcdc_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct max8660 *max8660 = rdev_get_drvdata(rdev);\n\tu8 val = max8660->shadow_regs[MAX8660_OVER1];\n\tu8 mask = (rdev_get_id(rdev) == MAX8660_V3) ? 1 : 4;\n\n\treturn !!(val & mask);\n}\n\nstatic int max8660_dcdc_enable(struct regulator_dev *rdev)\n{\n\tstruct max8660 *max8660 = rdev_get_drvdata(rdev);\n\tu8 bit = (rdev_get_id(rdev) == MAX8660_V3) ? 1 : 4;\n\n\treturn max8660_write(max8660, MAX8660_OVER1, 0xff, bit);\n}\n\nstatic int max8660_dcdc_disable(struct regulator_dev *rdev)\n{\n\tstruct max8660 *max8660 = rdev_get_drvdata(rdev);\n\tu8 mask = (rdev_get_id(rdev) == MAX8660_V3) ? ~1 : ~4;\n\n\treturn max8660_write(max8660, MAX8660_OVER1, mask, 0);\n}\n\nstatic int max8660_dcdc_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct max8660 *max8660 = rdev_get_drvdata(rdev);\n\tu8 reg = (rdev_get_id(rdev) == MAX8660_V3) ? MAX8660_ADTV2 : MAX8660_SDTV2;\n\tu8 selector = max8660->shadow_regs[reg];\n\n\treturn selector;\n}\n\nstatic int max8660_dcdc_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\tunsigned int selector)\n{\n\tstruct max8660 *max8660 = rdev_get_drvdata(rdev);\n\tu8 reg, bits;\n\tint ret;\n\n\treg = (rdev_get_id(rdev) == MAX8660_V3) ? MAX8660_ADTV2 : MAX8660_SDTV2;\n\tret = max8660_write(max8660, reg, 0, selector);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbits = (rdev_get_id(rdev) == MAX8660_V3) ? 0x03 : 0x30;\n\treturn max8660_write(max8660, MAX8660_VCC1, 0xff, bits);\n}\n\nstatic struct regulator_ops max8660_dcdc_ops = {\n\t.is_enabled = max8660_dcdc_is_enabled,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.set_voltage_sel = max8660_dcdc_set_voltage_sel,\n\t.get_voltage_sel = max8660_dcdc_get_voltage_sel,\n};\n\n\n \n\nstatic int max8660_ldo5_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct max8660 *max8660 = rdev_get_drvdata(rdev);\n\n\tu8 selector = max8660->shadow_regs[MAX8660_MDTV2];\n\treturn selector;\n}\n\nstatic int max8660_ldo5_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\tunsigned int selector)\n{\n\tstruct max8660 *max8660 = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tret = max8660_write(max8660, MAX8660_MDTV2, 0, selector);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn max8660_write(max8660, MAX8660_VCC1, 0xff, 0xc0);\n}\n\nstatic const struct regulator_ops max8660_ldo5_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.set_voltage_sel = max8660_ldo5_set_voltage_sel,\n\t.get_voltage_sel = max8660_ldo5_get_voltage_sel,\n};\n\n\n \n\nstatic int max8660_ldo67_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct max8660 *max8660 = rdev_get_drvdata(rdev);\n\tu8 val = max8660->shadow_regs[MAX8660_OVER2];\n\tu8 mask = (rdev_get_id(rdev) == MAX8660_V6) ? 2 : 4;\n\n\treturn !!(val & mask);\n}\n\nstatic int max8660_ldo67_enable(struct regulator_dev *rdev)\n{\n\tstruct max8660 *max8660 = rdev_get_drvdata(rdev);\n\tu8 bit = (rdev_get_id(rdev) == MAX8660_V6) ? 2 : 4;\n\n\treturn max8660_write(max8660, MAX8660_OVER2, 0xff, bit);\n}\n\nstatic int max8660_ldo67_disable(struct regulator_dev *rdev)\n{\n\tstruct max8660 *max8660 = rdev_get_drvdata(rdev);\n\tu8 mask = (rdev_get_id(rdev) == MAX8660_V6) ? ~2 : ~4;\n\n\treturn max8660_write(max8660, MAX8660_OVER2, mask, 0);\n}\n\nstatic int max8660_ldo67_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct max8660 *max8660 = rdev_get_drvdata(rdev);\n\tu8 shift = (rdev_get_id(rdev) == MAX8660_V6) ? 0 : 4;\n\tu8 selector = (max8660->shadow_regs[MAX8660_L12VCR] >> shift) & 0xf;\n\n\treturn selector;\n}\n\nstatic int max8660_ldo67_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\t unsigned int selector)\n{\n\tstruct max8660 *max8660 = rdev_get_drvdata(rdev);\n\n\tif (rdev_get_id(rdev) == MAX8660_V6)\n\t\treturn max8660_write(max8660, MAX8660_L12VCR, 0xf0, selector);\n\telse\n\t\treturn max8660_write(max8660, MAX8660_L12VCR, 0x0f,\n\t\t\t\t     selector << 4);\n}\n\nstatic const struct regulator_ops max8660_ldo67_ops = {\n\t.is_enabled = max8660_ldo67_is_enabled,\n\t.enable = max8660_ldo67_enable,\n\t.disable = max8660_ldo67_disable,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.get_voltage_sel = max8660_ldo67_get_voltage_sel,\n\t.set_voltage_sel = max8660_ldo67_set_voltage_sel,\n};\n\nstatic const struct regulator_desc max8660_reg[] = {\n\t{\n\t\t.name = \"V3(DCDC)\",\n\t\t.id = MAX8660_V3,\n\t\t.ops = &max8660_dcdc_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = MAX8660_DCDC_MAX_SEL + 1,\n\t\t.owner = THIS_MODULE,\n\t\t.min_uV = MAX8660_DCDC_MIN_UV,\n\t\t.uV_step = MAX8660_DCDC_STEP,\n\t},\n\t{\n\t\t.name = \"V4(DCDC)\",\n\t\t.id = MAX8660_V4,\n\t\t.ops = &max8660_dcdc_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = MAX8660_DCDC_MAX_SEL + 1,\n\t\t.owner = THIS_MODULE,\n\t\t.min_uV = MAX8660_DCDC_MIN_UV,\n\t\t.uV_step = MAX8660_DCDC_STEP,\n\t},\n\t{\n\t\t.name = \"V5(LDO)\",\n\t\t.id = MAX8660_V5,\n\t\t.ops = &max8660_ldo5_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = MAX8660_LDO5_MAX_SEL + 1,\n\t\t.owner = THIS_MODULE,\n\t\t.min_uV = MAX8660_LDO5_MIN_UV,\n\t\t.uV_step = MAX8660_LDO5_STEP,\n\t},\n\t{\n\t\t.name = \"V6(LDO)\",\n\t\t.id = MAX8660_V6,\n\t\t.ops = &max8660_ldo67_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = MAX8660_LDO67_MAX_SEL + 1,\n\t\t.owner = THIS_MODULE,\n\t\t.min_uV = MAX8660_LDO67_MIN_UV,\n\t\t.uV_step = MAX8660_LDO67_STEP,\n\t},\n\t{\n\t\t.name = \"V7(LDO)\",\n\t\t.id = MAX8660_V7,\n\t\t.ops = &max8660_ldo67_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = MAX8660_LDO67_MAX_SEL + 1,\n\t\t.owner = THIS_MODULE,\n\t\t.min_uV = MAX8660_LDO67_MIN_UV,\n\t\t.uV_step = MAX8660_LDO67_STEP,\n\t},\n};\n\nenum {\n\tMAX8660 = 0,\n\tMAX8661 = 1,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id max8660_dt_ids[] = {\n\t{ .compatible = \"maxim,max8660\", .data = (void *) MAX8660 },\n\t{ .compatible = \"maxim,max8661\", .data = (void *) MAX8661 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max8660_dt_ids);\n\nstatic int max8660_pdata_from_dt(struct device *dev,\n\t\t\t\t struct device_node **of_node,\n\t\t\t\t struct max8660_platform_data *pdata)\n{\n\tint matched, i;\n\tstruct device_node *np;\n\tstruct max8660_subdev_data *sub;\n\tstruct of_regulator_match rmatch[ARRAY_SIZE(max8660_reg)] = { };\n\n\tnp = of_get_child_by_name(dev->of_node, \"regulators\");\n\tif (!np) {\n\t\tdev_err(dev, \"missing 'regulators' subnode in DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rmatch); i++)\n\t\trmatch[i].name = max8660_reg[i].name;\n\n\tmatched = of_regulator_match(dev, np, rmatch, ARRAY_SIZE(rmatch));\n\tof_node_put(np);\n\tif (matched <= 0)\n\t\treturn matched;\n\n\tpdata->subdevs = devm_kcalloc(dev,\n\t\t\t\t      matched,\n\t\t\t\t      sizeof(struct max8660_subdev_data),\n\t\t\t\t      GFP_KERNEL);\n\tif (!pdata->subdevs)\n\t\treturn -ENOMEM;\n\n\tpdata->num_subdevs = matched;\n\tsub = pdata->subdevs;\n\n\tfor (i = 0; i < matched; i++) {\n\t\tsub->id = i;\n\t\tsub->name = rmatch[i].name;\n\t\tsub->platform_data = rmatch[i].init_data;\n\t\tof_node[i] = rmatch[i].of_node;\n\t\tsub++;\n\t}\n\n\treturn 0;\n}\n#else\nstatic inline int max8660_pdata_from_dt(struct device *dev,\n\t\t\t\t\tstruct device_node **of_node,\n\t\t\t\t\tstruct max8660_platform_data *pdata)\n{\n\treturn 0;\n}\n#endif\n\nstatic int max8660_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *i2c_id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct max8660_platform_data pdata_of, *pdata = dev_get_platdata(dev);\n\tstruct regulator_config config = { };\n\tstruct max8660 *max8660;\n\tint boot_on, i, id, ret = -EINVAL;\n\tstruct device_node *of_node[MAX8660_V_END];\n\tunsigned long type;\n\n\tif (dev->of_node && !pdata) {\n\t\tconst struct of_device_id *id;\n\n\t\tid = of_match_device(of_match_ptr(max8660_dt_ids), dev);\n\t\tif (!id)\n\t\t\treturn -ENODEV;\n\n\t\tret = max8660_pdata_from_dt(dev, of_node, &pdata_of);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tpdata = &pdata_of;\n\t\ttype = (unsigned long) id->data;\n\t} else {\n\t\ttype = i2c_id->driver_data;\n\t\tmemset(of_node, 0, sizeof(of_node));\n\t}\n\n\tif (pdata->num_subdevs > MAX8660_V_END) {\n\t\tdev_err(dev, \"Too many regulators found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmax8660 = devm_kzalloc(dev, sizeof(struct max8660), GFP_KERNEL);\n\tif (!max8660)\n\t\treturn -ENOMEM;\n\n\tmax8660->client = client;\n\n\tif (pdata->en34_is_high) {\n\t\t \n\t\tmax8660->shadow_regs[MAX8660_OVER1] = 5;\n\t} else {\n\t\t \n\t\tmax8660_dcdc_ops.enable = max8660_dcdc_enable;\n\t\tmax8660_dcdc_ops.disable = max8660_dcdc_disable;\n\t}\n\n\t \n\tmax8660->shadow_regs[MAX8660_ADTV1] =\n\t\tmax8660->shadow_regs[MAX8660_ADTV2] =\n\t\tmax8660->shadow_regs[MAX8660_SDTV1] =\n\t\tmax8660->shadow_regs[MAX8660_SDTV2] = 0x1b;\n\tmax8660->shadow_regs[MAX8660_MDTV1] =\n\t\tmax8660->shadow_regs[MAX8660_MDTV2] = 0x04;\n\n\tfor (i = 0; i < pdata->num_subdevs; i++) {\n\n\t\tif (!pdata->subdevs[i].platform_data)\n\t\t\tboot_on = false;\n\t\telse\n\t\t\tboot_on = pdata->subdevs[i].platform_data->constraints.boot_on;\n\n\t\tswitch (pdata->subdevs[i].id) {\n\t\tcase MAX8660_V3:\n\t\t\tif (boot_on)\n\t\t\t\tmax8660->shadow_regs[MAX8660_OVER1] |= 1;\n\t\t\tbreak;\n\n\t\tcase MAX8660_V4:\n\t\t\tif (boot_on)\n\t\t\t\tmax8660->shadow_regs[MAX8660_OVER1] |= 4;\n\t\t\tbreak;\n\n\t\tcase MAX8660_V5:\n\t\t\tbreak;\n\n\t\tcase MAX8660_V6:\n\t\t\tif (boot_on)\n\t\t\t\tmax8660->shadow_regs[MAX8660_OVER2] |= 2;\n\t\t\tbreak;\n\n\t\tcase MAX8660_V7:\n\t\t\tif (type == MAX8661) {\n\t\t\t\tdev_err(dev, \"Regulator not on this chip!\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (boot_on)\n\t\t\t\tmax8660->shadow_regs[MAX8660_OVER2] |= 4;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(dev, \"invalid regulator %s\\n\",\n\t\t\t\t pdata->subdevs[i].name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < pdata->num_subdevs; i++) {\n\t\tstruct regulator_dev *rdev;\n\n\t\tid = pdata->subdevs[i].id;\n\n\t\tconfig.dev = dev;\n\t\tconfig.init_data = pdata->subdevs[i].platform_data;\n\t\tconfig.of_node = of_node[i];\n\t\tconfig.driver_data = max8660;\n\n\t\trdev = devm_regulator_register(&client->dev,\n\t\t\t\t\t\t  &max8660_reg[id], &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&client->dev, \"failed to register %s\\n\",\n\t\t\t\tmax8660_reg[id].name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\ti2c_set_clientdata(client, max8660);\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max8660_id[] = {\n\t{ .name = \"max8660\", .driver_data = MAX8660 },\n\t{ .name = \"max8661\", .driver_data = MAX8661 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max8660_id);\n\nstatic struct i2c_driver max8660_driver = {\n\t.probe = max8660_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"max8660\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.id_table\t= max8660_id,\n};\n\nstatic int __init max8660_init(void)\n{\n\treturn i2c_add_driver(&max8660_driver);\n}\nsubsys_initcall(max8660_init);\n\nstatic void __exit max8660_exit(void)\n{\n\ti2c_del_driver(&max8660_driver);\n}\nmodule_exit(max8660_exit);\n\n \nMODULE_DESCRIPTION(\"MAXIM 8660/8661 voltage regulator driver\");\nMODULE_AUTHOR(\"Wolfram Sang\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}