{
  "module_name": "da9055-regulator.c",
  "hash_id": "814b7b665200f237cf670ced44b503db2b3bd67454761fba7a72dbd12c45c714",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/da9055-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/of.h>\n#include <linux/regulator/of_regulator.h>\n\n#include <linux/mfd/da9055/core.h>\n#include <linux/mfd/da9055/reg.h>\n#include <linux/mfd/da9055/pdata.h>\n\n#define DA9055_MIN_UA\t\t0\n#define DA9055_MAX_UA\t\t3\n\n#define DA9055_LDO_MODE_SYNC\t0\n#define DA9055_LDO_MODE_SLEEP\t1\n\n#define DA9055_BUCK_MODE_SLEEP\t1\n#define DA9055_BUCK_MODE_SYNC\t2\n#define DA9055_BUCK_MODE_AUTO\t3\n\n \n#define DA9055_ID_BUCK1\t0\n#define DA9055_ID_BUCK2\t1\n#define DA9055_ID_LDO1\t\t2\n#define DA9055_ID_LDO2\t\t3\n#define DA9055_ID_LDO3\t\t4\n#define DA9055_ID_LDO4\t\t5\n#define DA9055_ID_LDO5\t\t6\n#define DA9055_ID_LDO6\t\t7\n\n \nstatic const unsigned int da9055_current_limits[] = {\n\t500000, 600000, 700000, 800000\n};\n\nstruct da9055_conf_reg {\n\tint reg;\n\tint sel_mask;\n\tint en_mask;\n};\n\nstruct da9055_volt_reg {\n\tint reg_a;\n\tint reg_b;\n\tint sl_shift;\n\tint v_mask;\n};\n\nstruct da9055_mode_reg {\n\tint reg;\n\tint mask;\n\tint shift;\n};\n\nstruct da9055_regulator_info {\n\tstruct regulator_desc reg_desc;\n\tstruct da9055_conf_reg conf;\n\tstruct da9055_volt_reg volt;\n\tstruct da9055_mode_reg mode;\n};\n\nstruct da9055_regulator {\n\tstruct da9055 *da9055;\n\tstruct da9055_regulator_info *info;\n\tstruct regulator_dev *rdev;\n\tenum gpio_select reg_rselect;\n};\n\nstatic unsigned int da9055_buck_get_mode(struct regulator_dev *rdev)\n{\n\tstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\n\tstruct da9055_regulator_info *info = regulator->info;\n\tint ret, mode = 0;\n\n\tret = da9055_reg_read(regulator->da9055, info->mode.reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch ((ret & info->mode.mask) >> info->mode.shift) {\n\tcase DA9055_BUCK_MODE_SYNC:\n\t\tmode = REGULATOR_MODE_FAST;\n\t\tbreak;\n\tcase DA9055_BUCK_MODE_AUTO:\n\t\tmode = REGULATOR_MODE_NORMAL;\n\t\tbreak;\n\tcase DA9055_BUCK_MODE_SLEEP:\n\t\tmode = REGULATOR_MODE_STANDBY;\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\n\nstatic int da9055_buck_set_mode(struct regulator_dev *rdev,\n\t\t\t\t\tunsigned int mode)\n{\n\tstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\n\tstruct da9055_regulator_info *info = regulator->info;\n\tint val = 0;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tval = DA9055_BUCK_MODE_SYNC << info->mode.shift;\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = DA9055_BUCK_MODE_AUTO << info->mode.shift;\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tval = DA9055_BUCK_MODE_SLEEP << info->mode.shift;\n\t\tbreak;\n\t}\n\n\treturn da9055_reg_update(regulator->da9055, info->mode.reg,\n\t\t\t\t info->mode.mask, val);\n}\n\nstatic unsigned int da9055_ldo_get_mode(struct regulator_dev *rdev)\n{\n\tstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\n\tstruct da9055_regulator_info *info = regulator->info;\n\tint ret;\n\n\tret = da9055_reg_read(regulator->da9055, info->volt.reg_b);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret >> info->volt.sl_shift)\n\t\treturn REGULATOR_MODE_STANDBY;\n\telse\n\t\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int da9055_ldo_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\n\tstruct da9055_regulator_info *info = regulator->info;\n\tstruct da9055_volt_reg volt = info->volt;\n\tint val = 0;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\tcase REGULATOR_MODE_FAST:\n\t\tval = DA9055_LDO_MODE_SYNC;\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tval = DA9055_LDO_MODE_SLEEP;\n\t\tbreak;\n\t}\n\n\treturn da9055_reg_update(regulator->da9055, volt.reg_b,\n\t\t\t\t 1 << volt.sl_shift,\n\t\t\t\t val << volt.sl_shift);\n}\n\nstatic int da9055_regulator_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\n\tstruct da9055_regulator_info *info = regulator->info;\n\tstruct da9055_volt_reg volt = info->volt;\n\tint ret, sel;\n\n\t \n\tret = da9055_reg_read(regulator->da9055, info->conf.reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret &= info->conf.sel_mask;\n\n\t \n\tif (ret == DA9055_REGUALTOR_SET_A)\n\t\tret = da9055_reg_read(regulator->da9055, volt.reg_a);\n\telse\n\t\tret = da9055_reg_read(regulator->da9055, volt.reg_b);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsel = (ret & volt.v_mask);\n\treturn sel;\n}\n\nstatic int da9055_regulator_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\t    unsigned int selector)\n{\n\tstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\n\tstruct da9055_regulator_info *info = regulator->info;\n\tint ret;\n\n\t \n\tif (regulator->reg_rselect == NO_GPIO) {\n\t\t \n\t\tret = da9055_reg_update(regulator->da9055, info->conf.reg,\n\t\t\t\t\tinfo->conf.sel_mask, DA9055_SEL_REG_A);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\treturn da9055_reg_update(regulator->da9055, info->volt.reg_a,\n\t\t\t\t\t info->volt.v_mask, selector);\n\t}\n\n\t \n\tret = da9055_reg_read(regulator->da9055, info->conf.reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret &= info->conf.sel_mask;\n\n\t \n\tif (ret == DA9055_REGUALTOR_SET_A)\n\t\treturn da9055_reg_update(regulator->da9055, info->volt.reg_a,\n\t\t\t\t\t info->volt.v_mask, selector);\n\telse\n\t\treturn da9055_reg_update(regulator->da9055, info->volt.reg_b,\n\t\t\t\t\t info->volt.v_mask, selector);\n}\n\nstatic int da9055_regulator_set_suspend_voltage(struct regulator_dev *rdev,\n\t\t\t\t\t\tint uV)\n{\n\tstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\n\tstruct da9055_regulator_info *info = regulator->info;\n\tint ret;\n\n\t \n\tif (regulator->reg_rselect == NO_GPIO) {\n\t\tret = da9055_reg_update(regulator->da9055, info->conf.reg,\n\t\t\t\t\tinfo->conf.sel_mask, DA9055_SEL_REG_B);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = regulator_map_voltage_linear(rdev, uV, uV);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn da9055_reg_update(regulator->da9055, info->volt.reg_b,\n\t\t\t\t info->volt.v_mask, ret);\n}\n\nstatic int da9055_suspend_enable(struct regulator_dev *rdev)\n{\n\tstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\n\tstruct da9055_regulator_info *info = regulator->info;\n\n\t \n\tif (regulator->reg_rselect == NO_GPIO)\n\t\treturn da9055_reg_update(regulator->da9055, info->conf.reg,\n\t\t\t\t\tinfo->conf.sel_mask, DA9055_SEL_REG_B);\n\telse\n\t\treturn 0;\n}\n\nstatic int da9055_suspend_disable(struct regulator_dev *rdev)\n{\n\tstruct da9055_regulator *regulator = rdev_get_drvdata(rdev);\n\tstruct da9055_regulator_info *info = regulator->info;\n\n\t \n\tif (regulator->reg_rselect == NO_GPIO)\n\t\treturn da9055_reg_update(regulator->da9055, info->conf.reg,\n\t\t\t\t\tinfo->conf.sel_mask, DA9055_SEL_REG_A);\n\telse\n\t\treturn 0;\n}\n\nstatic const struct regulator_ops da9055_buck_ops = {\n\t.get_mode = da9055_buck_get_mode,\n\t.set_mode = da9055_buck_set_mode,\n\n\t.get_current_limit = regulator_get_current_limit_regmap,\n\t.set_current_limit = regulator_set_current_limit_regmap,\n\n\t.get_voltage_sel = da9055_regulator_get_voltage_sel,\n\t.set_voltage_sel = da9055_regulator_set_voltage_sel,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\n\t.set_suspend_voltage = da9055_regulator_set_suspend_voltage,\n\t.set_suspend_enable = da9055_suspend_enable,\n\t.set_suspend_disable = da9055_suspend_disable,\n\t.set_suspend_mode = da9055_buck_set_mode,\n};\n\nstatic const struct regulator_ops da9055_ldo_ops = {\n\t.get_mode = da9055_ldo_get_mode,\n\t.set_mode = da9055_ldo_set_mode,\n\n\t.get_voltage_sel = da9055_regulator_get_voltage_sel,\n\t.set_voltage_sel = da9055_regulator_set_voltage_sel,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\n\t.set_suspend_voltage = da9055_regulator_set_suspend_voltage,\n\t.set_suspend_enable = da9055_suspend_enable,\n\t.set_suspend_disable = da9055_suspend_disable,\n\t.set_suspend_mode = da9055_ldo_set_mode,\n\n};\n\n#define DA9055_LDO(_id, step, min, max, vbits, voffset) \\\n{\\\n\t.reg_desc = {\\\n\t\t.name = #_id,\\\n\t\t.of_match = of_match_ptr(#_id),\\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\\\n\t\t.ops = &da9055_ldo_ops,\\\n\t\t.type = REGULATOR_VOLTAGE,\\\n\t\t.id = DA9055_ID_##_id,\\\n\t\t.n_voltages = (max - min) / step + 1 + (voffset), \\\n\t\t.enable_reg = DA9055_REG_BCORE_CONT + DA9055_ID_##_id, \\\n\t\t.enable_mask = 1, \\\n\t\t.min_uV = (min) * 1000,\\\n\t\t.uV_step = (step) * 1000,\\\n\t\t.linear_min_sel = (voffset),\\\n\t\t.owner = THIS_MODULE,\\\n\t},\\\n\t.conf = {\\\n\t\t.reg = DA9055_REG_BCORE_CONT + DA9055_ID_##_id, \\\n\t\t.sel_mask = (1 << 4),\\\n\t\t.en_mask = 1,\\\n\t},\\\n\t.volt = {\\\n\t\t.reg_a = DA9055_REG_VBCORE_A + DA9055_ID_##_id, \\\n\t\t.reg_b = DA9055_REG_VBCORE_B + DA9055_ID_##_id, \\\n\t\t.sl_shift = 7,\\\n\t\t.v_mask = (1 << (vbits)) - 1,\\\n\t},\\\n}\n\n#define DA9055_BUCK(_id, step, min, max, vbits, voffset, mbits, sbits) \\\n{\\\n\t.reg_desc = {\\\n\t\t.name = #_id,\\\n\t\t.of_match = of_match_ptr(#_id),\\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\\\n\t\t.ops = &da9055_buck_ops,\\\n\t\t.type = REGULATOR_VOLTAGE,\\\n\t\t.id = DA9055_ID_##_id,\\\n\t\t.n_voltages = (max - min) / step + 1 + (voffset), \\\n\t\t.enable_reg = DA9055_REG_BCORE_CONT + DA9055_ID_##_id, \\\n\t\t.enable_mask = 1,\\\n\t\t.min_uV = (min) * 1000,\\\n\t\t.uV_step = (step) * 1000,\\\n\t\t.linear_min_sel = (voffset),\\\n\t\t.owner = THIS_MODULE,\\\n\t\t.curr_table = da9055_current_limits,\\\n\t\t.n_current_limits = ARRAY_SIZE(da9055_current_limits),\\\n\t\t.csel_reg = DA9055_REG_BUCK_LIM,\\\n\t\t.csel_mask = (mbits),\\\n\t},\\\n\t.conf = {\\\n\t\t.reg = DA9055_REG_BCORE_CONT + DA9055_ID_##_id, \\\n\t\t.sel_mask = (1 << 4),\\\n\t\t.en_mask = 1,\\\n\t},\\\n\t.volt = {\\\n\t\t.reg_a = DA9055_REG_VBCORE_A + DA9055_ID_##_id, \\\n\t\t.reg_b = DA9055_REG_VBCORE_B + DA9055_ID_##_id, \\\n\t\t.sl_shift = 7,\\\n\t\t.v_mask = (1 << (vbits)) - 1,\\\n\t},\\\n\t.mode = {\\\n\t\t.reg = DA9055_REG_BCORE_MODE,\\\n\t\t.mask = (mbits),\\\n\t\t.shift = (sbits),\\\n\t},\\\n}\n\nstatic struct da9055_regulator_info da9055_regulator_info[] = {\n\tDA9055_BUCK(BUCK1, 25, 725, 2075, 6, 9, 0xc, 2),\n\tDA9055_BUCK(BUCK2, 25, 925, 2500, 6, 0, 3, 0),\n\tDA9055_LDO(LDO1, 50, 900, 3300, 6, 2),\n\tDA9055_LDO(LDO2, 50, 900, 3300, 6, 3),\n\tDA9055_LDO(LDO3, 50, 900, 3300, 6, 2),\n\tDA9055_LDO(LDO4, 50, 900, 3300, 6, 2),\n\tDA9055_LDO(LDO5, 50, 900, 2750, 6, 2),\n\tDA9055_LDO(LDO6, 20, 900, 3300, 7, 0),\n};\n\n \nstatic int da9055_gpio_init(struct da9055_regulator *regulator,\n\t\t\t    struct regulator_config *config,\n\t\t\t    struct da9055_pdata *pdata, int id)\n{\n\tstruct da9055_regulator_info *info = regulator->info;\n\tint ret = 0;\n\n\tif (!pdata)\n\t\treturn 0;\n\n\tif (pdata->gpio_ren && pdata->gpio_ren[id]) {\n\t\tchar name[18];\n\t\tint gpio_mux = pdata->gpio_ren[id];\n\n\t\tconfig->ena_gpiod = pdata->ena_gpiods[id];\n\n\t\t \n\t\tsprintf(name, \"DA9055 GPI %d\", gpio_mux);\n\t\tret = devm_gpio_request_one(config->dev, gpio_mux, GPIOF_DIR_IN,\n\t\t\t\t\t    name);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = da9055_reg_update(regulator->da9055, info->conf.reg,\n\t\t\t\t\tDA9055_E_GPI_MASK,\n\t\t\t\t\tpdata->reg_ren[id]\n\t\t\t\t\t<< DA9055_E_GPI_SHIFT);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tif (pdata->gpio_rsel && pdata->gpio_rsel[id]) {\n\t\tchar name[18];\n\t\tint gpio_mux = pdata->gpio_rsel[id];\n\n\t\tregulator->reg_rselect = pdata->reg_rsel[id];\n\n\t\t \n\t\tsprintf(name, \"DA9055 GPI %d\", gpio_mux);\n\t\tret = devm_gpio_request_one(config->dev, gpio_mux, GPIOF_DIR_IN,\n\t\t\t\t\t    name);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = da9055_reg_update(regulator->da9055, info->conf.reg,\n\t\t\t\t\tDA9055_V_GPI_MASK,\n\t\t\t\t\tpdata->reg_rsel[id]\n\t\t\t\t\t<< DA9055_V_GPI_SHIFT);\n\t}\n\nerr:\n\treturn ret;\n}\n\nstatic irqreturn_t da9055_ldo5_6_oc_irq(int irq, void *data)\n{\n\tstruct da9055_regulator *regulator = data;\n\n\tregulator_notifier_call_chain(regulator->rdev,\n\t\t\t\t      REGULATOR_EVENT_OVER_CURRENT, NULL);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline struct da9055_regulator_info *find_regulator_info(int id)\n{\n\tstruct da9055_regulator_info *info;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(da9055_regulator_info); i++) {\n\t\tinfo = &da9055_regulator_info[i];\n\t\tif (info->reg_desc.id == id)\n\t\t\treturn info;\n\t}\n\n\treturn NULL;\n}\n\nstatic int da9055_regulator_probe(struct platform_device *pdev)\n{\n\tstruct regulator_config config = { };\n\tstruct da9055_regulator *regulator;\n\tstruct da9055 *da9055 = dev_get_drvdata(pdev->dev.parent);\n\tstruct da9055_pdata *pdata = dev_get_platdata(da9055->dev);\n\tint ret, irq;\n\n\tregulator = devm_kzalloc(&pdev->dev, sizeof(struct da9055_regulator),\n\t\t\t\t GFP_KERNEL);\n\tif (!regulator)\n\t\treturn -ENOMEM;\n\n\tregulator->info = find_regulator_info(pdev->id);\n\tif (regulator->info == NULL) {\n\t\tdev_err(&pdev->dev, \"invalid regulator ID specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregulator->da9055 = da9055;\n\tconfig.dev = da9055->dev;\n\tconfig.driver_data = regulator;\n\tconfig.regmap = da9055->regmap;\n\n\tif (pdata)\n\t\tconfig.init_data = pdata->regulators[pdev->id];\n\n\tret = da9055_gpio_init(regulator, &config, pdata, pdev->id);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregulator->rdev = devm_regulator_register(&pdev->dev,\n\t\t\t\t\t\t  &regulator->info->reg_desc,\n\t\t\t\t\t\t  &config);\n\tif (IS_ERR(regulator->rdev)) {\n\t\tdev_err(&pdev->dev, \"Failed to register regulator %s\\n\",\n\t\t\tregulator->info->reg_desc.name);\n\t\treturn PTR_ERR(regulator->rdev);\n\t}\n\n\t \n\tif (pdev->id == DA9055_ID_LDO5 || pdev->id ==  DA9055_ID_LDO6) {\n\t\tirq = platform_get_irq_byname(pdev, \"REGULATOR\");\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\t\tda9055_ldo5_6_oc_irq,\n\t\t\t\t\t\tIRQF_TRIGGER_HIGH |\n\t\t\t\t\t\tIRQF_ONESHOT |\n\t\t\t\t\t\tIRQF_PROBE_SHARED,\n\t\t\t\t\t\tpdev->name, regulator);\n\t\tif (ret != 0) {\n\t\t\tif (ret != -EBUSY) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to request Regulator IRQ %d: %d\\n\",\n\t\t\t\tirq, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, regulator);\n\n\treturn 0;\n}\n\nstatic struct platform_driver da9055_regulator_driver = {\n\t.probe = da9055_regulator_probe,\n\t.driver = {\n\t\t.name = \"da9055-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init da9055_regulator_init(void)\n{\n\treturn platform_driver_register(&da9055_regulator_driver);\n}\nsubsys_initcall(da9055_regulator_init);\n\nstatic void __exit da9055_regulator_exit(void)\n{\n\tplatform_driver_unregister(&da9055_regulator_driver);\n}\nmodule_exit(da9055_regulator_exit);\n\nMODULE_AUTHOR(\"David Dajun Chen <dchen@diasemi.com>\");\nMODULE_DESCRIPTION(\"Power Regulator driver for Dialog DA9055 PMIC\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9055-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}