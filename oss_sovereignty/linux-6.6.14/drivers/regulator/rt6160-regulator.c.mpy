{
  "module_name": "rt6160-regulator.c",
  "hash_id": "e60d15f39b35d1699b2d8bc2b996f59924a026171ece664035395e420151c99e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rt6160-regulator.c",
  "human_readable_source": "\n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n#define RT6160_MODE_AUTO\t0\n#define RT6160_MODE_FPWM\t1\n\n#define RT6160_REG_CNTL\t\t0x01\n#define RT6160_REG_STATUS\t0x02\n#define RT6160_REG_DEVID\t0x03\n#define RT6160_REG_VSELL\t0x04\n#define RT6160_REG_VSELH\t0x05\n#define RT6160_NUM_REGS\t\t(RT6160_REG_VSELH + 1)\n\n#define RT6160_FPWM_MASK\tBIT(3)\n#define RT6160_RAMPRATE_MASK\tGENMASK(1, 0)\n#define RT6160_VID_MASK\t\tGENMASK(7, 4)\n#define RT6160_VSEL_MASK\tGENMASK(6, 0)\n#define RT6160_HDSTAT_MASK\tBIT(4)\n#define RT6160_UVSTAT_MASK\tBIT(3)\n#define RT6160_OCSTAT_MASK\tBIT(2)\n#define RT6160_TSDSTAT_MASK\tBIT(1)\n#define RT6160_PGSTAT_MASK\tBIT(0)\n\n#define RT6160_VENDOR_ID\t0xA0\n#define RT6160_VOUT_MINUV\t2025000\n#define RT6160_VOUT_MAXUV\t5200000\n#define RT6160_VOUT_STPUV\t25000\n#define RT6160_N_VOUTS\t\t((RT6160_VOUT_MAXUV - RT6160_VOUT_MINUV) / RT6160_VOUT_STPUV + 1)\n\n#define RT6160_I2CRDY_TIMEUS\t100\n\nstruct rt6160_priv {\n\tstruct regulator_desc desc;\n\tstruct gpio_desc *enable_gpio;\n\tstruct regmap *regmap;\n\tbool enable_state;\n};\n\nstatic const unsigned int rt6160_ramp_tables[] = {\n\t1000, 2500, 5000, 10000\n};\n\nstatic int rt6160_enable(struct regulator_dev *rdev)\n{\n\tstruct rt6160_priv *priv = rdev_get_drvdata(rdev);\n\n\tif (!priv->enable_gpio)\n\t\treturn 0;\n\n\tgpiod_set_value_cansleep(priv->enable_gpio, 1);\n\tpriv->enable_state = true;\n\n\tusleep_range(RT6160_I2CRDY_TIMEUS, RT6160_I2CRDY_TIMEUS + 100);\n\n\tregcache_cache_only(priv->regmap, false);\n\treturn regcache_sync(priv->regmap);\n}\n\nstatic int rt6160_disable(struct regulator_dev *rdev)\n{\n\tstruct rt6160_priv *priv = rdev_get_drvdata(rdev);\n\n\tif (!priv->enable_gpio)\n\t\treturn -EINVAL;\n\n\t \n\tregcache_cache_only(priv->regmap, true);\n\tregcache_mark_dirty(priv->regmap);\n\n\tpriv->enable_state = false;\n\tgpiod_set_value_cansleep(priv->enable_gpio, 0);\n\n\treturn 0;\n}\n\nstatic int rt6160_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct rt6160_priv *priv = rdev_get_drvdata(rdev);\n\n\treturn priv->enable_state ? 1 : 0;\n}\n\nstatic int rt6160_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int mode_val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tmode_val = RT6160_FPWM_MASK;\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tmode_val = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&rdev->dev, \"mode not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(regmap, RT6160_REG_CNTL, RT6160_FPWM_MASK, mode_val);\n}\n\nstatic unsigned int rt6160_get_mode(struct regulator_dev *rdev)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(regmap, RT6160_REG_CNTL, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & RT6160_FPWM_MASK)\n\t\treturn REGULATOR_MODE_FAST;\n\n\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int rt6160_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int suspend_vsel_reg;\n\tint vsel;\n\n\tvsel = regulator_map_voltage_linear(rdev, uV, uV);\n\tif (vsel < 0)\n\t\treturn vsel;\n\n\tif (rdev->desc->vsel_reg == RT6160_REG_VSELL)\n\t\tsuspend_vsel_reg = RT6160_REG_VSELH;\n\telse\n\t\tsuspend_vsel_reg = RT6160_REG_VSELL;\n\n\treturn regmap_update_bits(regmap, suspend_vsel_reg,\n\t\t\t\t  RT6160_VSEL_MASK, vsel);\n}\n\nstatic int rt6160_get_error_flags(struct regulator_dev *rdev, unsigned int *flags)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int val, events = 0;\n\tint ret;\n\n\tret = regmap_read(regmap, RT6160_REG_STATUS, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & (RT6160_HDSTAT_MASK | RT6160_TSDSTAT_MASK))\n\t\tevents |= REGULATOR_ERROR_OVER_TEMP;\n\n\tif (val & RT6160_UVSTAT_MASK)\n\t\tevents |= REGULATOR_ERROR_UNDER_VOLTAGE;\n\n\tif (val & RT6160_OCSTAT_MASK)\n\t\tevents |= REGULATOR_ERROR_OVER_CURRENT;\n\n\tif (val & RT6160_PGSTAT_MASK)\n\t\tevents |= REGULATOR_ERROR_FAIL;\n\n\t*flags = events;\n\treturn 0;\n}\n\nstatic const struct regulator_ops rt6160_regulator_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\n\t.enable = rt6160_enable,\n\t.disable = rt6160_disable,\n\t.is_enabled = rt6160_is_enabled,\n\n\t.set_mode = rt6160_set_mode,\n\t.get_mode = rt6160_get_mode,\n\t.set_suspend_voltage = rt6160_set_suspend_voltage,\n\t.set_ramp_delay = regulator_set_ramp_delay_regmap,\n\t.get_error_flags = rt6160_get_error_flags,\n};\n\nstatic unsigned int rt6160_of_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase RT6160_MODE_FPWM:\n\t\treturn REGULATOR_MODE_FAST;\n\tcase RT6160_MODE_AUTO:\n\t\treturn REGULATOR_MODE_NORMAL;\n\t}\n\n\treturn REGULATOR_MODE_INVALID;\n}\n\nstatic bool rt6160_is_accessible_reg(struct device *dev, unsigned int reg)\n{\n\tif (reg >= RT6160_REG_CNTL && reg <= RT6160_REG_VSELH)\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool rt6160_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tif (reg == RT6160_REG_STATUS)\n\t\treturn true;\n\treturn false;\n}\n\nstatic const struct regmap_config rt6160_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RT6160_REG_VSELH,\n\t.num_reg_defaults_raw = RT6160_NUM_REGS,\n\t.cache_type = REGCACHE_FLAT,\n\n\t.writeable_reg = rt6160_is_accessible_reg,\n\t.readable_reg = rt6160_is_accessible_reg,\n\t.volatile_reg = rt6160_is_volatile_reg,\n};\n\nstatic int rt6160_probe(struct i2c_client *i2c)\n{\n\tstruct rt6160_priv *priv;\n\tstruct regulator_config regulator_cfg = {};\n\tstruct regulator_dev *rdev;\n\tbool vsel_active_low;\n\tunsigned int devid;\n\tint ret;\n\n\tpriv = devm_kzalloc(&i2c->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tvsel_active_low =\n\t\tdevice_property_present(&i2c->dev, \"richtek,vsel-active-low\");\n\n\tpriv->enable_gpio = devm_gpiod_get_optional(&i2c->dev, \"enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->enable_gpio)) {\n\t\tdev_err(&i2c->dev, \"Failed to get 'enable' gpio\\n\");\n\t\treturn PTR_ERR(priv->enable_gpio);\n\t}\n\tpriv->enable_state = true;\n\n\tusleep_range(RT6160_I2CRDY_TIMEUS, RT6160_I2CRDY_TIMEUS + 100);\n\n\tpriv->regmap = devm_regmap_init_i2c(i2c, &rt6160_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tret = PTR_ERR(priv->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to init regmap (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(priv->regmap, RT6160_REG_DEVID, &devid);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((devid & RT6160_VID_MASK) != RT6160_VENDOR_ID) {\n\t\tdev_err(&i2c->dev, \"VID not correct [0x%02x]\\n\", devid);\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->desc.name = \"rt6160-buckboost\";\n\tpriv->desc.type = REGULATOR_VOLTAGE;\n\tpriv->desc.owner = THIS_MODULE;\n\tpriv->desc.min_uV = RT6160_VOUT_MINUV;\n\tpriv->desc.uV_step = RT6160_VOUT_STPUV;\n\tif (vsel_active_low)\n\t\tpriv->desc.vsel_reg = RT6160_REG_VSELL;\n\telse\n\t\tpriv->desc.vsel_reg = RT6160_REG_VSELH;\n\tpriv->desc.vsel_mask = RT6160_VSEL_MASK;\n\tpriv->desc.n_voltages = RT6160_N_VOUTS;\n\tpriv->desc.ramp_reg = RT6160_REG_CNTL;\n\tpriv->desc.ramp_mask = RT6160_RAMPRATE_MASK;\n\tpriv->desc.ramp_delay_table = rt6160_ramp_tables;\n\tpriv->desc.n_ramp_values = ARRAY_SIZE(rt6160_ramp_tables);\n\tpriv->desc.of_map_mode = rt6160_of_map_mode;\n\tpriv->desc.ops = &rt6160_regulator_ops;\n\n\tregulator_cfg.dev = &i2c->dev;\n\tregulator_cfg.of_node = i2c->dev.of_node;\n\tregulator_cfg.regmap = priv->regmap;\n\tregulator_cfg.driver_data = priv;\n\tregulator_cfg.init_data = of_get_regulator_init_data(&i2c->dev, i2c->dev.of_node,\n\t\t\t\t\t\t\t     &priv->desc);\n\n\trdev = devm_regulator_register(&i2c->dev, &priv->desc, &regulator_cfg);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(&i2c->dev, \"Failed to register regulator\\n\");\n\t\treturn PTR_ERR(rdev);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused rt6160_of_match_table[] = {\n\t{ .compatible = \"richtek,rt6160\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rt6160_of_match_table);\n\nstatic struct i2c_driver rt6160_driver = {\n\t.driver = {\n\t\t.name = \"rt6160\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = rt6160_of_match_table,\n\t},\n\t.probe = rt6160_probe,\n};\nmodule_i2c_driver(rt6160_driver);\n\nMODULE_DESCRIPTION(\"Richtek RT6160 voltage regulator driver\");\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}