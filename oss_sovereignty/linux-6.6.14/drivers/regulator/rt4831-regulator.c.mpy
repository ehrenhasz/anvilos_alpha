{
  "module_name": "rt4831-regulator.c",
  "hash_id": "98066a34bf3948e2e85d27ff2f3f90ff749151b322bf03d67c2b34834b51d2a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rt4831-regulator.c",
  "human_readable_source": "\n\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regulator/driver.h>\n\nenum {\n\tDSV_OUT_VLCM = 0,\n\tDSV_OUT_VPOS,\n\tDSV_OUT_VNEG,\n\tDSV_OUT_MAX\n};\n\n#define RT4831_REG_DSVEN\t0x09\n#define RT4831_REG_VLCM\t\t0x0c\n#define RT4831_REG_VPOS\t\t0x0d\n#define RT4831_REG_VNEG\t\t0x0e\n#define RT4831_REG_FLAGS\t0x0f\n\n#define RT4831_VOLT_MASK\tGENMASK(5, 0)\n#define RT4831_DSVMODE_SHIFT\t5\n#define RT4831_DSVMODE_MASK\tGENMASK(7, 5)\n#define RT4831_POSADEN_MASK\tBIT(4)\n#define RT4831_NEGADEN_MASK\tBIT(3)\n#define RT4831_POSEN_MASK\tBIT(2)\n#define RT4831_NEGEN_MASK\tBIT(1)\n\n#define RT4831_OTP_MASK\t\tBIT(6)\n#define RT4831_LCMOVP_MASK\tBIT(5)\n#define RT4831_VPOSSCP_MASK\tBIT(3)\n#define RT4831_VNEGSCP_MASK\tBIT(2)\n\n#define DSV_MODE_NORMAL\t\t(0x4 << RT4831_DSVMODE_SHIFT)\n#define DSV_MODE_BYPASS\t\t(0x6 << RT4831_DSVMODE_SHIFT)\n#define STEP_UV\t\t\t50000\n#define VLCM_MIN_UV\t\t4000000\n#define VLCM_MAX_UV\t\t7150000\n#define VLCM_N_VOLTAGES\t\t((VLCM_MAX_UV - VLCM_MIN_UV) / STEP_UV + 1)\n#define VPN_MIN_UV\t\t4000000\n#define VPN_MAX_UV\t\t6500000\n#define VPN_N_VOLTAGES\t\t((VPN_MAX_UV - VPN_MIN_UV) / STEP_UV + 1)\n\nstatic int rt4831_get_error_flags(struct regulator_dev *rdev, unsigned int *flags)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tint rid = rdev_get_id(rdev);\n\tunsigned int val, events = 0;\n\tint ret;\n\n\tret = regmap_read(regmap, RT4831_REG_FLAGS, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & RT4831_OTP_MASK)\n\t\tevents |= REGULATOR_ERROR_OVER_TEMP;\n\n\tif (rid == DSV_OUT_VLCM && (val & RT4831_LCMOVP_MASK))\n\t\tevents |= REGULATOR_ERROR_OVER_CURRENT;\n\n\tif (rid == DSV_OUT_VPOS && (val & RT4831_VPOSSCP_MASK))\n\t\tevents |= REGULATOR_ERROR_OVER_CURRENT;\n\n\tif (rid == DSV_OUT_VNEG && (val & RT4831_VNEGSCP_MASK))\n\t\tevents |= REGULATOR_ERROR_OVER_CURRENT;\n\n\t*flags = events;\n\treturn 0;\n}\n\nstatic const struct regulator_ops rt4831_dsvlcm_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_bypass = regulator_set_bypass_regmap,\n\t.get_bypass = regulator_get_bypass_regmap,\n\t.get_error_flags = rt4831_get_error_flags,\n};\n\nstatic const struct regulator_ops rt4831_dsvpn_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n\t.get_error_flags = rt4831_get_error_flags,\n};\n\nstatic const struct regulator_desc rt4831_regulator_descs[] = {\n\t{\n\t\t.name = \"DSVLCM\",\n\t\t.ops = &rt4831_dsvlcm_ops,\n\t\t.of_match = of_match_ptr(\"DSVLCM\"),\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.id = DSV_OUT_VLCM,\n\t\t.n_voltages = VLCM_N_VOLTAGES,\n\t\t.min_uV = VLCM_MIN_UV,\n\t\t.uV_step = STEP_UV,\n\t\t.vsel_reg = RT4831_REG_VLCM,\n\t\t.vsel_mask = RT4831_VOLT_MASK,\n\t\t.bypass_reg = RT4831_REG_DSVEN,\n\t\t.bypass_mask = RT4831_DSVMODE_MASK,\n\t\t.bypass_val_on = DSV_MODE_BYPASS,\n\t\t.bypass_val_off = DSV_MODE_NORMAL,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"DSVP\",\n\t\t.ops = &rt4831_dsvpn_ops,\n\t\t.of_match = of_match_ptr(\"DSVP\"),\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.id = DSV_OUT_VPOS,\n\t\t.n_voltages = VPN_N_VOLTAGES,\n\t\t.min_uV = VPN_MIN_UV,\n\t\t.uV_step = STEP_UV,\n\t\t.vsel_reg = RT4831_REG_VPOS,\n\t\t.vsel_mask = RT4831_VOLT_MASK,\n\t\t.enable_reg = RT4831_REG_DSVEN,\n\t\t.enable_mask = RT4831_POSEN_MASK,\n\t\t.active_discharge_reg = RT4831_REG_DSVEN,\n\t\t.active_discharge_mask = RT4831_POSADEN_MASK,\n\t\t.active_discharge_on = RT4831_POSADEN_MASK,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"DSVN\",\n\t\t.ops = &rt4831_dsvpn_ops,\n\t\t.of_match = of_match_ptr(\"DSVN\"),\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.id = DSV_OUT_VNEG,\n\t\t.n_voltages = VPN_N_VOLTAGES,\n\t\t.min_uV = VPN_MIN_UV,\n\t\t.uV_step = STEP_UV,\n\t\t.vsel_reg = RT4831_REG_VNEG,\n\t\t.vsel_mask = RT4831_VOLT_MASK,\n\t\t.enable_reg = RT4831_REG_DSVEN,\n\t\t.enable_mask = RT4831_NEGEN_MASK,\n\t\t.active_discharge_reg = RT4831_REG_DSVEN,\n\t\t.active_discharge_mask = RT4831_NEGADEN_MASK,\n\t\t.active_discharge_on = RT4831_NEGADEN_MASK,\n\t\t.owner = THIS_MODULE,\n\t}\n};\n\nstatic int rt4831_regulator_probe(struct platform_device *pdev)\n{\n\tstruct regmap *regmap;\n\tstruct regulator_dev *rdev;\n\tstruct regulator_config config = {};\n\tint i, ret;\n\n\tregmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!regmap) {\n\t\tdev_err(&pdev->dev, \"Failed to init regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = regmap_update_bits(regmap, RT4831_REG_DSVEN, RT4831_DSVMODE_MASK, DSV_MODE_NORMAL);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to configure dsv mode to normal\\n\");\n\t\treturn ret;\n\t}\n\n\tconfig.dev = pdev->dev.parent;\n\tconfig.regmap = regmap;\n\n\tfor (i = 0; i < DSV_OUT_MAX; i++) {\n\t\trdev = devm_regulator_register(&pdev->dev, rt4831_regulator_descs + i, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&pdev->dev, \"Failed to register %d regulator\\n\", i);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id rt4831_regulator_match[] = {\n\t{ \"rt4831-regulator\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(platform, rt4831_regulator_match);\n\nstatic struct platform_driver rt4831_regulator_driver = {\n\t.driver = {\n\t\t.name = \"rt4831-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.id_table = rt4831_regulator_match,\n\t.probe = rt4831_regulator_probe,\n};\nmodule_platform_driver(rt4831_regulator_driver);\n\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}