{
  "module_name": "vctrl-regulator.c",
  "hash_id": "645478c440759d163e920ede03d49e0a3f1f8fa75e9b5adb763753b9439479f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/vctrl-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/coupler.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/sort.h>\n\n#include \"internal.h\"\n\nstruct vctrl_voltage_range {\n\tint min_uV;\n\tint max_uV;\n};\n\nstruct vctrl_voltage_ranges {\n\tstruct vctrl_voltage_range ctrl;\n\tstruct vctrl_voltage_range out;\n};\n\nstruct vctrl_voltage_table {\n\tint ctrl;\n\tint out;\n\tint ovp_min_sel;\n};\n\nstruct vctrl_data {\n\tstruct regulator_dev *rdev;\n\tstruct regulator_desc desc;\n\tbool enabled;\n\tunsigned int min_slew_down_rate;\n\tunsigned int ovp_threshold;\n\tstruct vctrl_voltage_ranges vrange;\n\tstruct vctrl_voltage_table *vtable;\n\tunsigned int sel;\n};\n\nstatic int vctrl_calc_ctrl_voltage(struct vctrl_data *vctrl, int out_uV)\n{\n\tstruct vctrl_voltage_range *ctrl = &vctrl->vrange.ctrl;\n\tstruct vctrl_voltage_range *out = &vctrl->vrange.out;\n\n\treturn ctrl->min_uV +\n\t\tDIV_ROUND_CLOSEST_ULL((s64)(out_uV - out->min_uV) *\n\t\t\t\t      (ctrl->max_uV - ctrl->min_uV),\n\t\t\t\t      out->max_uV - out->min_uV);\n}\n\nstatic int vctrl_calc_output_voltage(struct vctrl_data *vctrl, int ctrl_uV)\n{\n\tstruct vctrl_voltage_range *ctrl = &vctrl->vrange.ctrl;\n\tstruct vctrl_voltage_range *out = &vctrl->vrange.out;\n\n\tif (ctrl_uV < 0) {\n\t\tpr_err(\"vctrl: failed to get control voltage\\n\");\n\t\treturn ctrl_uV;\n\t}\n\n\tif (ctrl_uV < ctrl->min_uV)\n\t\treturn out->min_uV;\n\n\tif (ctrl_uV > ctrl->max_uV)\n\t\treturn out->max_uV;\n\n\treturn out->min_uV +\n\t\tDIV_ROUND_CLOSEST_ULL((s64)(ctrl_uV - ctrl->min_uV) *\n\t\t\t\t      (out->max_uV - out->min_uV),\n\t\t\t\t      ctrl->max_uV - ctrl->min_uV);\n}\n\nstatic int vctrl_get_voltage(struct regulator_dev *rdev)\n{\n\tstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\n\tint ctrl_uV;\n\n\tif (!rdev->supply)\n\t\treturn -EPROBE_DEFER;\n\n\tctrl_uV = regulator_get_voltage_rdev(rdev->supply->rdev);\n\n\treturn vctrl_calc_output_voltage(vctrl, ctrl_uV);\n}\n\nstatic int vctrl_set_voltage(struct regulator_dev *rdev,\n\t\t\t     int req_min_uV, int req_max_uV,\n\t\t\t     unsigned int *selector)\n{\n\tstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\n\tint orig_ctrl_uV;\n\tint uV;\n\tint ret;\n\n\tif (!rdev->supply)\n\t\treturn -EPROBE_DEFER;\n\n\torig_ctrl_uV = regulator_get_voltage_rdev(rdev->supply->rdev);\n\tuV = vctrl_calc_output_voltage(vctrl, orig_ctrl_uV);\n\n\tif (req_min_uV >= uV || !vctrl->ovp_threshold)\n\t\t \n\t\treturn regulator_set_voltage_rdev(rdev->supply->rdev,\n\t\t\tvctrl_calc_ctrl_voltage(vctrl, req_min_uV),\n\t\t\tvctrl_calc_ctrl_voltage(vctrl, req_max_uV),\n\t\t\tPM_SUSPEND_ON);\n\n\twhile (uV > req_min_uV) {\n\t\tint max_drop_uV = (uV * vctrl->ovp_threshold) / 100;\n\t\tint next_uV;\n\t\tint next_ctrl_uV;\n\t\tint delay;\n\n\t\t \n\t\tif (max_drop_uV == 0)\n\t\t\tmax_drop_uV = 1;\n\n\t\tnext_uV = max_t(int, req_min_uV, uV - max_drop_uV);\n\t\tnext_ctrl_uV = vctrl_calc_ctrl_voltage(vctrl, next_uV);\n\n\t\tret = regulator_set_voltage_rdev(rdev->supply->rdev,\n\t\t\t\t\t    next_ctrl_uV,\n\t\t\t\t\t    next_ctrl_uV,\n\t\t\t\t\t    PM_SUSPEND_ON);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tdelay = DIV_ROUND_UP(uV - next_uV, vctrl->min_slew_down_rate);\n\t\tusleep_range(delay, delay + DIV_ROUND_UP(delay, 10));\n\n\t\tuV = next_uV;\n\t}\n\n\treturn 0;\n\nerr:\n\t \n\tregulator_set_voltage_rdev(rdev->supply->rdev, orig_ctrl_uV, orig_ctrl_uV,\n\t\t\t\t   PM_SUSPEND_ON);\n\n\treturn ret;\n}\n\nstatic int vctrl_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\n\n\treturn vctrl->sel;\n}\n\nstatic int vctrl_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t unsigned int selector)\n{\n\tstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\n\tunsigned int orig_sel = vctrl->sel;\n\tint ret;\n\n\tif (!rdev->supply)\n\t\treturn -EPROBE_DEFER;\n\n\tif (selector >= rdev->desc->n_voltages)\n\t\treturn -EINVAL;\n\n\tif (selector >= vctrl->sel || !vctrl->ovp_threshold) {\n\t\t \n\t\tret = regulator_set_voltage_rdev(rdev->supply->rdev,\n\t\t\t\t\t    vctrl->vtable[selector].ctrl,\n\t\t\t\t\t    vctrl->vtable[selector].ctrl,\n\t\t\t\t\t    PM_SUSPEND_ON);\n\t\tif (!ret)\n\t\t\tvctrl->sel = selector;\n\n\t\treturn ret;\n\t}\n\n\twhile (vctrl->sel != selector) {\n\t\tunsigned int next_sel;\n\t\tint delay;\n\n\t\tnext_sel = max_t(unsigned int, selector, vctrl->vtable[vctrl->sel].ovp_min_sel);\n\n\t\tret = regulator_set_voltage_rdev(rdev->supply->rdev,\n\t\t\t\t\t    vctrl->vtable[next_sel].ctrl,\n\t\t\t\t\t    vctrl->vtable[next_sel].ctrl,\n\t\t\t\t\t    PM_SUSPEND_ON);\n\t\tif (ret) {\n\t\t\tdev_err(&rdev->dev,\n\t\t\t\t\"failed to set control voltage to %duV\\n\",\n\t\t\t\tvctrl->vtable[next_sel].ctrl);\n\t\t\tgoto err;\n\t\t}\n\t\tvctrl->sel = next_sel;\n\n\t\tdelay = DIV_ROUND_UP(vctrl->vtable[vctrl->sel].out -\n\t\t\t\t     vctrl->vtable[next_sel].out,\n\t\t\t\t     vctrl->min_slew_down_rate);\n\t\tusleep_range(delay, delay + DIV_ROUND_UP(delay, 10));\n\t}\n\n\treturn 0;\n\nerr:\n\tif (vctrl->sel != orig_sel) {\n\t\t \n\t\tif (!regulator_set_voltage_rdev(rdev->supply->rdev,\n\t\t\t\t\t   vctrl->vtable[orig_sel].ctrl,\n\t\t\t\t\t   vctrl->vtable[orig_sel].ctrl,\n\t\t\t\t\t   PM_SUSPEND_ON))\n\t\t\tvctrl->sel = orig_sel;\n\t\telse\n\t\t\tdev_warn(&rdev->dev,\n\t\t\t\t \"failed to restore original voltage\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int vctrl_list_voltage(struct regulator_dev *rdev,\n\t\t\t      unsigned int selector)\n{\n\tstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\n\n\tif (selector >= rdev->desc->n_voltages)\n\t\treturn -EINVAL;\n\n\treturn vctrl->vtable[selector].out;\n}\n\nstatic int vctrl_parse_dt(struct platform_device *pdev,\n\t\t\t  struct vctrl_data *vctrl)\n{\n\tint ret;\n\tstruct device_node *np = pdev->dev.of_node;\n\tu32 pval;\n\tu32 vrange_ctrl[2];\n\n\tret = of_property_read_u32(np, \"ovp-threshold-percent\", &pval);\n\tif (!ret) {\n\t\tvctrl->ovp_threshold = pval;\n\t\tif (vctrl->ovp_threshold > 100) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"ovp-threshold-percent (%u) > 100\\n\",\n\t\t\t\tvctrl->ovp_threshold);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = of_property_read_u32(np, \"min-slew-down-rate\", &pval);\n\tif (!ret) {\n\t\tvctrl->min_slew_down_rate = pval;\n\n\t\t \n\t\tif (vctrl->min_slew_down_rate == 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"min-slew-down-rate must not be 0\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else if (vctrl->min_slew_down_rate > INT_MAX) {\n\t\t\tdev_err(&pdev->dev, \"min-slew-down-rate (%u) too big\\n\",\n\t\t\t\tvctrl->min_slew_down_rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (vctrl->ovp_threshold && !vctrl->min_slew_down_rate) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"ovp-threshold-percent requires min-slew-down-rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32(np, \"regulator-min-microvolt\", &pval);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to read regulator-min-microvolt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tvctrl->vrange.out.min_uV = pval;\n\n\tret = of_property_read_u32(np, \"regulator-max-microvolt\", &pval);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to read regulator-max-microvolt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tvctrl->vrange.out.max_uV = pval;\n\n\tret = of_property_read_u32_array(np, \"ctrl-voltage-range\", vrange_ctrl,\n\t\t\t\t\t 2);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to read ctrl-voltage-range: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (vrange_ctrl[0] >= vrange_ctrl[1]) {\n\t\tdev_err(&pdev->dev, \"ctrl-voltage-range is invalid: %d-%d\\n\",\n\t\t\tvrange_ctrl[0], vrange_ctrl[1]);\n\t\treturn -EINVAL;\n\t}\n\n\tvctrl->vrange.ctrl.min_uV = vrange_ctrl[0];\n\tvctrl->vrange.ctrl.max_uV = vrange_ctrl[1];\n\n\treturn 0;\n}\n\nstatic int vctrl_cmp_ctrl_uV(const void *a, const void *b)\n{\n\tconst struct vctrl_voltage_table *at = a;\n\tconst struct vctrl_voltage_table *bt = b;\n\n\treturn at->ctrl - bt->ctrl;\n}\n\nstatic int vctrl_init_vtable(struct platform_device *pdev,\n\t\t\t     struct regulator *ctrl_reg)\n{\n\tstruct vctrl_data *vctrl = platform_get_drvdata(pdev);\n\tstruct regulator_desc *rdesc = &vctrl->desc;\n\tstruct vctrl_voltage_range *vrange_ctrl = &vctrl->vrange.ctrl;\n\tint n_voltages;\n\tint ctrl_uV;\n\tint i, idx_vt;\n\n\tn_voltages = regulator_count_voltages(ctrl_reg);\n\n\trdesc->n_voltages = n_voltages;\n\n\t \n\tfor (i = 0; i < n_voltages; i++) {\n\t\tctrl_uV = regulator_list_voltage(ctrl_reg, i);\n\n\t\tif (ctrl_uV < vrange_ctrl->min_uV ||\n\t\t    ctrl_uV > vrange_ctrl->max_uV)\n\t\t\trdesc->n_voltages--;\n\t}\n\n\tif (rdesc->n_voltages == 0) {\n\t\tdev_err(&pdev->dev, \"invalid configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvctrl->vtable = devm_kcalloc(&pdev->dev, rdesc->n_voltages,\n\t\t\t\t     sizeof(struct vctrl_voltage_table),\n\t\t\t\t     GFP_KERNEL);\n\tif (!vctrl->vtable)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0, idx_vt = 0; i < n_voltages; i++) {\n\t\tctrl_uV = regulator_list_voltage(ctrl_reg, i);\n\n\t\tif (ctrl_uV < vrange_ctrl->min_uV ||\n\t\t    ctrl_uV > vrange_ctrl->max_uV)\n\t\t\tcontinue;\n\n\t\tvctrl->vtable[idx_vt].ctrl = ctrl_uV;\n\t\tvctrl->vtable[idx_vt].out =\n\t\t\tvctrl_calc_output_voltage(vctrl, ctrl_uV);\n\t\tidx_vt++;\n\t}\n\n\t \n\tsort(vctrl->vtable, rdesc->n_voltages,\n\t     sizeof(struct vctrl_voltage_table), vctrl_cmp_ctrl_uV,\n\t     NULL);\n\n\t \n\tfor (i = rdesc->n_voltages - 1; i > 0; i--) {\n\t\tint j;\n\t\tint ovp_min_uV = (vctrl->vtable[i].out *\n\t\t\t\t  (100 - vctrl->ovp_threshold)) / 100;\n\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (vctrl->vtable[j].out >= ovp_min_uV) {\n\t\t\t\tvctrl->vtable[i].ovp_min_sel = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (j == i) {\n\t\t\tdev_warn(&pdev->dev, \"switching down from %duV may cause OVP shutdown\\n\",\n\t\t\t\tvctrl->vtable[i].out);\n\t\t\t \n\t\t\tvctrl->vtable[i].ovp_min_sel = i - 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vctrl_enable(struct regulator_dev *rdev)\n{\n\tstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\n\n\tvctrl->enabled = true;\n\n\treturn 0;\n}\n\nstatic int vctrl_disable(struct regulator_dev *rdev)\n{\n\tstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\n\n\tvctrl->enabled = false;\n\n\treturn 0;\n}\n\nstatic int vctrl_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct vctrl_data *vctrl = rdev_get_drvdata(rdev);\n\n\treturn vctrl->enabled;\n}\n\nstatic const struct regulator_ops vctrl_ops_cont = {\n\t.enable\t\t  = vctrl_enable,\n\t.disable\t  = vctrl_disable,\n\t.is_enabled\t  = vctrl_is_enabled,\n\t.get_voltage\t  = vctrl_get_voltage,\n\t.set_voltage\t  = vctrl_set_voltage,\n};\n\nstatic const struct regulator_ops vctrl_ops_non_cont = {\n\t.enable\t\t  = vctrl_enable,\n\t.disable\t  = vctrl_disable,\n\t.is_enabled\t  = vctrl_is_enabled,\n\t.set_voltage_sel = vctrl_set_voltage_sel,\n\t.get_voltage_sel = vctrl_get_voltage_sel,\n\t.list_voltage    = vctrl_list_voltage,\n\t.map_voltage     = regulator_map_voltage_iterate,\n};\n\nstatic int vctrl_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct vctrl_data *vctrl;\n\tconst struct regulator_init_data *init_data;\n\tstruct regulator_desc *rdesc;\n\tstruct regulator_config cfg = { };\n\tstruct vctrl_voltage_range *vrange_ctrl;\n\tstruct regulator *ctrl_reg;\n\tint ctrl_uV;\n\tint ret;\n\n\tvctrl = devm_kzalloc(&pdev->dev, sizeof(struct vctrl_data),\n\t\t\t     GFP_KERNEL);\n\tif (!vctrl)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, vctrl);\n\n\tret = vctrl_parse_dt(pdev, vctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tctrl_reg = devm_regulator_get(&pdev->dev, \"ctrl\");\n\tif (IS_ERR(ctrl_reg))\n\t\treturn PTR_ERR(ctrl_reg);\n\n\tvrange_ctrl = &vctrl->vrange.ctrl;\n\n\trdesc = &vctrl->desc;\n\trdesc->name = \"vctrl\";\n\trdesc->type = REGULATOR_VOLTAGE;\n\trdesc->owner = THIS_MODULE;\n\trdesc->supply_name = \"ctrl\";\n\n\tif ((regulator_get_linear_step(ctrl_reg) == 1) ||\n\t    (regulator_count_voltages(ctrl_reg) == -EINVAL)) {\n\t\trdesc->continuous_voltage_range = true;\n\t\trdesc->ops = &vctrl_ops_cont;\n\t} else {\n\t\trdesc->ops = &vctrl_ops_non_cont;\n\t}\n\n\tinit_data = of_get_regulator_init_data(&pdev->dev, np, rdesc);\n\tif (!init_data)\n\t\treturn -ENOMEM;\n\n\tcfg.of_node = np;\n\tcfg.dev = &pdev->dev;\n\tcfg.driver_data = vctrl;\n\tcfg.init_data = init_data;\n\n\tif (!rdesc->continuous_voltage_range) {\n\t\tret = vctrl_init_vtable(pdev, ctrl_reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tctrl_uV = regulator_get_voltage(ctrl_reg);\n\t\tif (ctrl_uV < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to get control voltage\\n\");\n\t\t\treturn ctrl_uV;\n\t\t}\n\n\t\t \n\t\tif (ctrl_uV < vrange_ctrl->min_uV) {\n\t\t\tvctrl->sel = 0;\n\t\t} else if (ctrl_uV > vrange_ctrl->max_uV) {\n\t\t\tvctrl->sel = rdesc->n_voltages - 1;\n\t\t} else {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < rdesc->n_voltages; i++) {\n\t\t\t\tif (ctrl_uV == vctrl->vtable[i].ctrl) {\n\t\t\t\t\tvctrl->sel = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tdevm_regulator_put(ctrl_reg);\n\n\tvctrl->rdev = devm_regulator_register(&pdev->dev, rdesc, &cfg);\n\tif (IS_ERR(vctrl->rdev)) {\n\t\tret = PTR_ERR(vctrl->rdev);\n\t\tdev_err(&pdev->dev, \"failed to register regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id vctrl_of_match[] = {\n\t{ .compatible = \"vctrl-regulator\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, vctrl_of_match);\n\nstatic struct platform_driver vctrl_driver = {\n\t.probe\t\t= vctrl_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"vctrl-regulator\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(vctrl_of_match),\n\t},\n};\n\nmodule_platform_driver(vctrl_driver);\n\nMODULE_DESCRIPTION(\"Voltage Controlled Regulator Driver\");\nMODULE_AUTHOR(\"Matthias Kaehlcke <mka@chromium.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}