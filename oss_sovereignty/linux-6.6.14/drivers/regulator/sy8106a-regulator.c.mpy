{
  "module_name": "sy8106a-regulator.c",
  "hash_id": "849d169d5e67a65de0f10613f07826e765dbfbd189a22c62c2bcdaf9a23a3c96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/sy8106a-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n#define SY8106A_REG_VOUT1_SEL\t\t0x01\n#define SY8106A_REG_VOUT_COM\t\t0x02\n#define SY8106A_REG_VOUT1_SEL_MASK\t0x7f\n#define SY8106A_DISABLE_REG\t\tBIT(0)\n \n#define SY8106A_GO_BIT\t\t\tBIT(7)\n\nstatic const struct regmap_config sy8106a_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic const struct regulator_ops sy8106a_ops = {\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.set_voltage_time_sel = regulator_set_voltage_time_sel,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t \n};\n\n \n#define SY8106A_MIN_MV\t\t680\n#define SY8106A_MAX_MV\t\t1950\n#define SY8106A_STEP_MV\t\t10\n\nstatic const struct regulator_desc sy8106a_reg = {\n\t.name = \"SY8106A\",\n\t.id = 0,\n\t.ops = &sy8106a_ops,\n\t.type = REGULATOR_VOLTAGE,\n\t.n_voltages = ((SY8106A_MAX_MV - SY8106A_MIN_MV) / SY8106A_STEP_MV) + 1,\n\t.min_uV = (SY8106A_MIN_MV * 1000),\n\t.uV_step = (SY8106A_STEP_MV * 1000),\n\t.vsel_reg = SY8106A_REG_VOUT1_SEL,\n\t.vsel_mask = SY8106A_REG_VOUT1_SEL_MASK,\n\t \n\t.ramp_delay = 200,\n\t.owner = THIS_MODULE,\n};\n\n \nstatic int sy8106a_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct regulator_dev *rdev;\n\tstruct regulator_config config = { };\n\tstruct regmap *regmap;\n\tunsigned int reg, vsel;\n\tu32 fixed_voltage;\n\tint error;\n\n\terror = of_property_read_u32(dev->of_node, \"silergy,fixed-microvolt\",\n\t\t\t\t     &fixed_voltage);\n\tif (error)\n\t\treturn error;\n\n\tif (fixed_voltage < SY8106A_MIN_MV * 1000 ||\n\t    fixed_voltage > SY8106A_MAX_MV * 1000)\n\t\treturn -EINVAL;\n\n\tregmap = devm_regmap_init_i2c(i2c, &sy8106a_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\terror = PTR_ERR(regmap);\n\t\tdev_err(dev, \"Failed to allocate register map: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\tconfig.dev = &i2c->dev;\n\tconfig.regmap = regmap;\n\n\tconfig.of_node = dev->of_node;\n\tconfig.init_data = of_get_regulator_init_data(dev, dev->of_node,\n\t\t\t\t\t\t      &sy8106a_reg);\n\n\tif (!config.init_data)\n\t\treturn -ENOMEM;\n\n\t \n\terror = regmap_read(regmap, SY8106A_REG_VOUT1_SEL, &reg);\n\tif (error)\n\t\treturn error;\n\n\tif (!(reg & SY8106A_GO_BIT)) {\n\t\tvsel = (fixed_voltage / 1000 - SY8106A_MIN_MV) /\n\t\t       SY8106A_STEP_MV;\n\n\t\terror = regmap_write(regmap, SY8106A_REG_VOUT1_SEL,\n\t\t\t\t     vsel | SY8106A_GO_BIT);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\trdev = devm_regulator_register(&i2c->dev, &sy8106a_reg, &config);\n\tif (IS_ERR(rdev)) {\n\t\terror = PTR_ERR(rdev);\n\t\tdev_err(&i2c->dev, \"Failed to register SY8106A regulator: %d\\n\", error);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sy8106a_i2c_of_match[] = {\n\t{ .compatible = \"silergy,sy8106a\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sy8106a_i2c_of_match);\n\nstatic const struct i2c_device_id sy8106a_i2c_id[] = {\n\t{ \"sy8106a\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, sy8106a_i2c_id);\n\nstatic struct i2c_driver sy8106a_regulator_driver = {\n\t.driver = {\n\t\t.name = \"sy8106a\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table\t= sy8106a_i2c_of_match,\n\t},\n\t.probe = sy8106a_i2c_probe,\n\t.id_table = sy8106a_i2c_id,\n};\n\nmodule_i2c_driver(sy8106a_regulator_driver);\n\nMODULE_AUTHOR(\"Ond\u0159ej Jirman <megous@megous.com>\");\nMODULE_AUTHOR(\"Icenowy Zheng <icenowy@aosc.io>\");\nMODULE_DESCRIPTION(\"Regulator device driver for Silergy SY8106A\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}