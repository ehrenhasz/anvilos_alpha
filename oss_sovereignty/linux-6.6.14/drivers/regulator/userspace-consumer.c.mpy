{
  "module_name": "userspace-consumer.c",
  "hash_id": "b380d5e538337bbeffad2e453aeba5bf0f2a92409b7fe5537b9b4d4319e82b68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/userspace-consumer.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regulator/userspace-consumer.h>\n#include <linux/slab.h>\n\nstruct userspace_consumer_data {\n\tconst char *name;\n\n\tstruct mutex lock;\n\tbool enabled;\n\tbool no_autoswitch;\n\n\tint num_supplies;\n\tstruct regulator_bulk_data *supplies;\n};\n\nstatic ssize_t name_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct userspace_consumer_data *data = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", data->name);\n}\n\nstatic ssize_t state_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct userspace_consumer_data *data = dev_get_drvdata(dev);\n\n\tif (data->enabled)\n\t\treturn sprintf(buf, \"enabled\\n\");\n\n\treturn sprintf(buf, \"disabled\\n\");\n}\n\nstatic ssize_t state_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct userspace_consumer_data *data = dev_get_drvdata(dev);\n\tbool enabled;\n\tint ret;\n\n\t \n\tif (sysfs_streq(buf, \"enabled\\n\") || sysfs_streq(buf, \"1\"))\n\t\tenabled = true;\n\telse if (sysfs_streq(buf, \"disabled\\n\") || sysfs_streq(buf, \"0\"))\n\t\tenabled = false;\n\telse {\n\t\tdev_err(dev, \"Configuring invalid mode\\n\");\n\t\treturn count;\n\t}\n\n\tmutex_lock(&data->lock);\n\tif (enabled != data->enabled) {\n\t\tif (enabled)\n\t\t\tret = regulator_bulk_enable(data->num_supplies,\n\t\t\t\t\t\t    data->supplies);\n\t\telse\n\t\t\tret = regulator_bulk_disable(data->num_supplies,\n\t\t\t\t\t\t     data->supplies);\n\n\t\tif (ret == 0)\n\t\t\tdata->enabled = enabled;\n\t\telse\n\t\t\tdev_err(dev, \"Failed to configure state: %d\\n\", ret);\n\t}\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RO(name);\nstatic DEVICE_ATTR_RW(state);\n\nstatic struct attribute *attributes[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_state.attr,\n\tNULL,\n};\n\nstatic umode_t attr_visible(struct kobject *kobj, struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct userspace_consumer_data *data = dev_get_drvdata(dev);\n\n\t \n\tif (attr == &dev_attr_name.attr && !data->name)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group attr_group = {\n\t.attrs\t= attributes,\n\t.is_visible =  attr_visible,\n};\n\nstatic int regulator_userspace_consumer_probe(struct platform_device *pdev)\n{\n\tstruct regulator_userspace_consumer_data tmpdata;\n\tstruct regulator_userspace_consumer_data *pdata;\n\tstruct userspace_consumer_data *drvdata;\n\tint ret;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tif (!pdev->dev.of_node)\n\t\t\treturn -EINVAL;\n\n\t\tpdata = &tmpdata;\n\t\tmemset(pdata, 0, sizeof(*pdata));\n\n\t\tpdata->no_autoswitch = true;\n\t\tpdata->num_supplies = 1;\n\t\tpdata->supplies = devm_kzalloc(&pdev->dev, sizeof(*pdata->supplies), GFP_KERNEL);\n\t\tif (!pdata->supplies)\n\t\t\treturn -ENOMEM;\n\t\tpdata->supplies[0].supply = \"vout\";\n\t}\n\n\tif (pdata->num_supplies < 1) {\n\t\tdev_err(&pdev->dev, \"At least one supply required\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdrvdata = devm_kzalloc(&pdev->dev,\n\t\t\t       sizeof(struct userspace_consumer_data),\n\t\t\t       GFP_KERNEL);\n\tif (drvdata == NULL)\n\t\treturn -ENOMEM;\n\n\tdrvdata->name = pdata->name;\n\tdrvdata->num_supplies = pdata->num_supplies;\n\tdrvdata->supplies = pdata->supplies;\n\tdrvdata->no_autoswitch = pdata->no_autoswitch;\n\n\tmutex_init(&drvdata->lock);\n\n\tret = devm_regulator_bulk_get_exclusive(&pdev->dev, drvdata->num_supplies,\n\t\t\t\t\t\tdrvdata->supplies);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to get supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, drvdata);\n\n\tret = sysfs_create_group(&pdev->dev.kobj, &attr_group);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (pdata->init_on && !pdata->no_autoswitch) {\n\t\tret = regulator_bulk_enable(drvdata->num_supplies,\n\t\t\t\t\t    drvdata->supplies);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to set initial state: %d\\n\", ret);\n\t\t\tgoto err_enable;\n\t\t}\n\t}\n\n\tret = regulator_is_enabled(pdata->supplies[0].consumer);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get regulator status\\n\");\n\t\tgoto err_enable;\n\t}\n\tdrvdata->enabled = !!ret;\n\n\treturn 0;\n\nerr_enable:\n\tsysfs_remove_group(&pdev->dev.kobj, &attr_group);\n\n\treturn ret;\n}\n\nstatic int regulator_userspace_consumer_remove(struct platform_device *pdev)\n{\n\tstruct userspace_consumer_data *data = platform_get_drvdata(pdev);\n\n\tsysfs_remove_group(&pdev->dev.kobj, &attr_group);\n\n\tif (data->enabled && !data->no_autoswitch)\n\t\tregulator_bulk_disable(data->num_supplies, data->supplies);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id regulator_userspace_consumer_of_match[] = {\n\t{ .compatible = \"regulator-output\", },\n\t{},\n};\n\nstatic struct platform_driver regulator_userspace_consumer_driver = {\n\t.probe\t\t= regulator_userspace_consumer_probe,\n\t.remove\t\t= regulator_userspace_consumer_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"reg-userspace-consumer\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table\t= regulator_userspace_consumer_of_match,\n\t},\n};\n\nmodule_platform_driver(regulator_userspace_consumer_driver);\n\nMODULE_AUTHOR(\"Mike Rapoport <mike@compulab.co.il>\");\nMODULE_DESCRIPTION(\"Userspace consumer for voltage and current regulators\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}