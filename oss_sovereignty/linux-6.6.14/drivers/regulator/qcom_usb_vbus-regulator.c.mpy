{
  "module_name": "qcom_usb_vbus-regulator.c",
  "hash_id": "be4a702958494161b94133f48ec41e624dd740749e2cce1f06631da71cae2138",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/qcom_usb_vbus-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regmap.h>\n\n#define CMD_OTG\t\t\t\t0x40\n#define OTG_EN\t\t\t\tBIT(0)\n#define OTG_CURRENT_LIMIT_CFG\t\t0x52\n#define OTG_CURRENT_LIMIT_MASK\t\tGENMASK(2, 0)\n#define OTG_CFG\t\t\t\t0x53\n#define OTG_EN_SRC_CFG\t\t\tBIT(1)\n\nstatic const unsigned int curr_table[] = {\n\t500000, 1000000, 1500000, 2000000, 2500000, 3000000,\n};\n\nstatic const struct regulator_ops qcom_usb_vbus_reg_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.get_current_limit = regulator_get_current_limit_regmap,\n\t.set_current_limit = regulator_set_current_limit_regmap,\n};\n\nstatic struct regulator_desc qcom_usb_vbus_rdesc = {\n\t.name = \"usb_vbus\",\n\t.ops = &qcom_usb_vbus_reg_ops,\n\t.owner = THIS_MODULE,\n\t.type = REGULATOR_VOLTAGE,\n\t.curr_table = curr_table,\n\t.n_current_limits = ARRAY_SIZE(curr_table),\n};\n\nstatic int qcom_usb_vbus_regulator_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct regulator_dev *rdev;\n\tstruct regmap *regmap;\n\tstruct regulator_config config = { };\n\tstruct regulator_init_data *init_data;\n\tint ret;\n\tu32 base;\n\n\tret = of_property_read_u32(dev->of_node, \"reg\", &base);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"no base address found\\n\");\n\t\treturn ret;\n\t}\n\n\tregmap = dev_get_regmap(dev->parent, NULL);\n\tif (!regmap) {\n\t\tdev_err(dev, \"Failed to get regmap\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tinit_data = of_get_regulator_init_data(dev, dev->of_node,\n\t\t\t\t\t       &qcom_usb_vbus_rdesc);\n\tif (!init_data)\n\t\treturn -ENOMEM;\n\n\tqcom_usb_vbus_rdesc.enable_reg = base + CMD_OTG;\n\tqcom_usb_vbus_rdesc.enable_mask = OTG_EN;\n\tqcom_usb_vbus_rdesc.csel_reg = base + OTG_CURRENT_LIMIT_CFG;\n\tqcom_usb_vbus_rdesc.csel_mask = OTG_CURRENT_LIMIT_MASK;\n\tconfig.dev = dev;\n\tconfig.init_data = init_data;\n\tconfig.of_node = dev->of_node;\n\tconfig.regmap = regmap;\n\n\trdev = devm_regulator_register(dev, &qcom_usb_vbus_rdesc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\t\tdev_err(dev, \"not able to register vbus reg %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_update_bits(regmap, base + OTG_CFG, OTG_EN_SRC_CFG, 0);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qcom_usb_vbus_regulator_match[] = {\n\t{ .compatible = \"qcom,pm8150b-vbus-reg\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_usb_vbus_regulator_match);\n\nstatic struct platform_driver qcom_usb_vbus_regulator_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"qcom-usb-vbus-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = qcom_usb_vbus_regulator_match,\n\t},\n\t.probe\t\t= qcom_usb_vbus_regulator_probe,\n};\nmodule_platform_driver(qcom_usb_vbus_regulator_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm USB vbus regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}