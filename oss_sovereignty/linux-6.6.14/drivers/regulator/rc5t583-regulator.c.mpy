{
  "module_name": "rc5t583-regulator.c",
  "hash_id": "da49dc9841bc5201e36dff744dd989403a06dbbbda34bec95c21dd5c7f9383aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rc5t583-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/mfd/rc5t583.h>\n\nstruct rc5t583_regulator_info {\n\tint\t\t\tdeepsleep_id;\n\n\t \n\tuint8_t\t\t\treg_disc_reg;\n\tuint8_t\t\t\tdisc_bit;\n\tuint8_t\t\t\tdeepsleep_reg;\n\n\t \n\tint\t\t\tenable_uv_per_us;\n\n\t \n\tstruct regulator_desc\tdesc;\n};\n\nstatic int rc5t583_regulator_enable_time(struct regulator_dev *rdev)\n{\n\tstruct rc5t583_regulator_info *reg_info = rdev_get_drvdata(rdev);\n\tint vsel = regulator_get_voltage_sel_regmap(rdev);\n\tint curr_uV = regulator_list_voltage_linear(rdev, vsel);\n\n\treturn DIV_ROUND_UP(curr_uV, reg_info->enable_uv_per_us);\n}\n\nstatic const struct regulator_ops rc5t583_ops = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.enable_time\t\t= rc5t583_regulator_enable_time,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n\t.set_voltage_time_sel\t= regulator_set_voltage_time_sel,\n};\n\n#define RC5T583_REG(_id, _en_reg, _en_bit, _disc_reg, _disc_bit, \\\n\t\t_vout_mask, _min_mv, _max_mv, _step_uV, _enable_mv) \\\n{\t\t\t\t\t\t\t\t\\\n\t.reg_disc_reg\t= RC5T583_REG_##_disc_reg,\t\t\\\n\t.disc_bit\t= _disc_bit,\t\t\t\t\\\n\t.deepsleep_reg\t= RC5T583_REG_##_id##DAC_DS,\t\t\\\n\t.enable_uv_per_us = _enable_mv * 1000,\t\t\t\\\n\t.deepsleep_id\t= RC5T583_DS_##_id,\t\t\t\\\n\t.desc = {\t\t\t\t\t\t\\\n\t\t.name = \"rc5t583-regulator-\"#_id,\t\t\\\n\t\t.id = RC5T583_REGULATOR_##_id,\t\t\t\\\n\t\t.n_voltages = (_max_mv - _min_mv) * 1000 / _step_uV + 1, \\\n\t\t.ops = &rc5t583_ops,\t\t\t\t\\\n\t\t.type = REGULATOR_VOLTAGE,\t\t\t\\\n\t\t.owner = THIS_MODULE,\t\t\t\t\\\n\t\t.vsel_reg = RC5T583_REG_##_id##DAC,\t\t\\\n\t\t.vsel_mask = _vout_mask,\t\t\t\\\n\t\t.enable_reg = RC5T583_REG_##_en_reg,\t\t\\\n\t\t.enable_mask = BIT(_en_bit),\t\t\t\\\n\t\t.min_uV\t= _min_mv * 1000,\t\t\t\\\n\t\t.uV_step = _step_uV,\t\t\t\t\\\n\t\t.ramp_delay = 40 * 1000,\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n}\n\nstatic struct rc5t583_regulator_info rc5t583_reg_info[RC5T583_REGULATOR_MAX] = {\n\tRC5T583_REG(DC0, DC0CTL, 0, DC0CTL, 1, 0x7F, 700, 1500, 12500, 4),\n\tRC5T583_REG(DC1, DC1CTL, 0, DC1CTL, 1, 0x7F, 700, 1500, 12500, 14),\n\tRC5T583_REG(DC2, DC2CTL, 0, DC2CTL, 1, 0x7F, 900, 2400, 12500, 14),\n\tRC5T583_REG(DC3, DC3CTL, 0, DC3CTL, 1, 0x7F, 900, 2400, 12500, 14),\n\tRC5T583_REG(LDO0, LDOEN2, 0, LDODIS2, 0, 0x7F, 900, 3400, 25000, 160),\n\tRC5T583_REG(LDO1, LDOEN2, 1, LDODIS2, 1, 0x7F, 900, 3400, 25000, 160),\n\tRC5T583_REG(LDO2, LDOEN2, 2, LDODIS2, 2, 0x7F, 900, 3400, 25000, 160),\n\tRC5T583_REG(LDO3, LDOEN2, 3, LDODIS2, 3, 0x7F, 900, 3400, 25000, 160),\n\tRC5T583_REG(LDO4, LDOEN2, 4, LDODIS2, 4, 0x3F, 750, 1500, 12500, 133),\n\tRC5T583_REG(LDO5, LDOEN2, 5, LDODIS2, 5, 0x7F, 900, 3400, 25000, 267),\n\tRC5T583_REG(LDO6, LDOEN2, 6, LDODIS2, 6, 0x7F, 900, 3400, 25000, 133),\n\tRC5T583_REG(LDO7, LDOEN2, 7, LDODIS2, 7, 0x7F, 900, 3400, 25000, 233),\n\tRC5T583_REG(LDO8, LDOEN1, 0, LDODIS1, 0, 0x7F, 900, 3400, 25000, 233),\n\tRC5T583_REG(LDO9, LDOEN1, 1, LDODIS1, 1, 0x7F, 900, 3400, 25000, 133),\n};\n\nstatic int rc5t583_regulator_probe(struct platform_device *pdev)\n{\n\tstruct rc5t583 *rc5t583 = dev_get_drvdata(pdev->dev.parent);\n\tstruct rc5t583_platform_data *pdata = dev_get_platdata(rc5t583->dev);\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tstruct rc5t583_regulator_info *ri;\n\tint ret;\n\tint id;\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"No platform data, exiting...\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (id = 0; id < RC5T583_REGULATOR_MAX; ++id) {\n\t\tri = &rc5t583_reg_info[id];\n\n\t\tif (ri->deepsleep_id == RC5T583_DS_NONE)\n\t\t\tgoto skip_ext_pwr_config;\n\n\t\tret = rc5t583_ext_power_req_config(rc5t583->dev,\n\t\t\t\tri->deepsleep_id,\n\t\t\t\tpdata->regulator_ext_pwr_control[id],\n\t\t\t\tpdata->regulator_deepsleep_slot[id]);\n\t\t \n\t\tif (ret < 0)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\"Failed to configure ext control %d\\n\", id);\n\nskip_ext_pwr_config:\n\t\tconfig.dev = &pdev->dev;\n\t\tconfig.init_data = pdata->reg_init_data[id];\n\t\tconfig.driver_data = ri;\n\t\tconfig.regmap = rc5t583->regmap;\n\n\t\trdev = devm_regulator_register(&pdev->dev, &ri->desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&pdev->dev, \"Failed to register regulator %s\\n\",\n\t\t\t\t\t\tri->desc.name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct platform_driver rc5t583_regulator_driver = {\n\t.driver\t= {\n\t\t.name\t= \"rc5t583-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t\t= rc5t583_regulator_probe,\n};\n\nstatic int __init rc5t583_regulator_init(void)\n{\n\treturn platform_driver_register(&rc5t583_regulator_driver);\n}\nsubsys_initcall(rc5t583_regulator_init);\n\nstatic void __exit rc5t583_regulator_exit(void)\n{\n\tplatform_driver_unregister(&rc5t583_regulator_driver);\n}\nmodule_exit(rc5t583_regulator_exit);\n\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_DESCRIPTION(\"RC5T583 regulator driver\");\nMODULE_ALIAS(\"platform:rc5t583-regulator\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}