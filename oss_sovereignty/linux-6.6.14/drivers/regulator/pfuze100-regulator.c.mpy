{
  "module_name": "pfuze100-regulator.c",
  "hash_id": "0e5ad2c6c859d6672adf2e2a407fe1837cd039a5810b040ae2711c24eeb78ea1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/pfuze100-regulator.c",
  "human_readable_source": "\n\n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/pfuze100.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n\n#define PFUZE_FLAG_DISABLE_SW\tBIT(1)\n\n#define PFUZE_NUMREGS\t\t128\n#define PFUZE100_VOL_OFFSET\t0\n#define PFUZE100_STANDBY_OFFSET\t1\n#define PFUZE100_MODE_OFFSET\t3\n#define PFUZE100_CONF_OFFSET\t4\n\n#define PFUZE100_DEVICEID\t0x0\n#define PFUZE100_REVID\t\t0x3\n#define PFUZE100_FABID\t\t0x4\n\n#define PFUZE100_COINVOL\t0x1a\n#define PFUZE100_SW1ABVOL\t0x20\n#define PFUZE100_SW1ABMODE\t0x23\n#define PFUZE100_SW1CVOL\t0x2e\n#define PFUZE100_SW1CMODE\t0x31\n#define PFUZE100_SW2VOL\t\t0x35\n#define PFUZE100_SW2MODE\t0x38\n#define PFUZE100_SW3AVOL\t0x3c\n#define PFUZE100_SW3AMODE\t0x3f\n#define PFUZE100_SW3BVOL\t0x43\n#define PFUZE100_SW3BMODE\t0x46\n#define PFUZE100_SW4VOL\t\t0x4a\n#define PFUZE100_SW4MODE\t0x4d\n#define PFUZE100_SWBSTCON1\t0x66\n#define PFUZE100_VREFDDRCON\t0x6a\n#define PFUZE100_VSNVSVOL\t0x6b\n#define PFUZE100_VGEN1VOL\t0x6c\n#define PFUZE100_VGEN2VOL\t0x6d\n#define PFUZE100_VGEN3VOL\t0x6e\n#define PFUZE100_VGEN4VOL\t0x6f\n#define PFUZE100_VGEN5VOL\t0x70\n#define PFUZE100_VGEN6VOL\t0x71\n\n#define PFUZE100_SWxMODE_MASK\t0xf\n#define PFUZE100_SWxMODE_APS_APS\t0x8\n#define PFUZE100_SWxMODE_APS_OFF\t0x4\n\n#define PFUZE100_VGENxLPWR\tBIT(6)\n#define PFUZE100_VGENxSTBY\tBIT(5)\n\nenum chips { PFUZE100, PFUZE200, PFUZE3000 = 3, PFUZE3001 = 0x31, };\n\nstruct pfuze_regulator {\n\tstruct regulator_desc desc;\n\tunsigned char stby_reg;\n\tunsigned char stby_mask;\n\tbool sw_reg;\n};\n\nstruct pfuze_chip {\n\tint\tchip_id;\n\tint     flags;\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct pfuze_regulator regulator_descs[PFUZE100_MAX_REGULATOR];\n\tstruct regulator_dev *regulators[PFUZE100_MAX_REGULATOR];\n\tstruct pfuze_regulator *pfuze_regulators;\n};\n\nstatic const int pfuze100_swbst[] = {\n\t5000000, 5050000, 5100000, 5150000,\n};\n\nstatic const int pfuze100_vsnvs[] = {\n\t1000000, 1100000, 1200000, 1300000, 1500000, 1800000, 3000000,\n};\n\nstatic const int pfuze100_coin[] = {\n\t2500000, 2700000, 2800000, 2900000, 3000000, 3100000, 3200000, 3300000,\n};\n\nstatic const int pfuze3000_sw1a[] = {\n\t700000, 725000, 750000, 775000, 800000, 825000, 850000, 875000,\n\t900000, 925000, 950000, 975000, 1000000, 1025000, 1050000, 1075000,\n\t1100000, 1125000, 1150000, 1175000, 1200000, 1225000, 1250000, 1275000,\n\t1300000, 1325000, 1350000, 1375000, 1400000, 1425000, 1800000, 3300000,\n};\n\nstatic const int pfuze3000_sw2lo[] = {\n\t1500000, 1550000, 1600000, 1650000, 1700000, 1750000, 1800000, 1850000,\n};\n\nstatic const int pfuze3000_sw2hi[] = {\n\t2500000, 2800000, 2850000, 3000000, 3100000, 3150000, 3200000, 3300000,\n};\n\nstatic const struct of_device_id pfuze_dt_ids[] = {\n\t{ .compatible = \"fsl,pfuze100\", .data = (void *)PFUZE100},\n\t{ .compatible = \"fsl,pfuze200\", .data = (void *)PFUZE200},\n\t{ .compatible = \"fsl,pfuze3000\", .data = (void *)PFUZE3000},\n\t{ .compatible = \"fsl,pfuze3001\", .data = (void *)PFUZE3001},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pfuze_dt_ids);\n\nstatic int pfuze100_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)\n{\n\tstruct pfuze_chip *pfuze100 = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\tbool reg_has_ramp_delay;\n\tunsigned int ramp_bits = 0;\n\tint ret;\n\n\tswitch (pfuze100->chip_id) {\n\tcase PFUZE3001:\n\t\t \n\t\treg_has_ramp_delay = false;\n\t\tbreak;\n\tcase PFUZE3000:\n\t\treg_has_ramp_delay = (id < PFUZE3000_SWBST);\n\t\tbreak;\n\tcase PFUZE200:\n\t\treg_has_ramp_delay = (id < PFUZE200_SWBST);\n\t\tbreak;\n\tcase PFUZE100:\n\tdefault:\n\t\treg_has_ramp_delay = (id < PFUZE100_SWBST);\n\t\tbreak;\n\t}\n\n\tif (reg_has_ramp_delay) {\n\t\tif (ramp_delay > 0) {\n\t\t\tramp_delay = 12500 / ramp_delay;\n\t\t\tramp_bits = (ramp_delay >> 1) - (ramp_delay >> 3);\n\t\t}\n\n\t\tret = regmap_update_bits(pfuze100->regmap,\n\t\t\t\t\t rdev->desc->vsel_reg + 4,\n\t\t\t\t\t 0xc0, ramp_bits << 6);\n\t\tif (ret < 0)\n\t\t\tdev_err(pfuze100->dev, \"ramp failed, err %d\\n\", ret);\n\t} else {\n\t\tret = -EACCES;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct regulator_ops pfuze100_ldo_regulator_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n};\n\nstatic const struct regulator_ops pfuze100_fixed_regulator_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n};\n\nstatic const struct regulator_ops pfuze100_sw_regulator_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_time_sel = regulator_set_voltage_time_sel,\n\t.set_ramp_delay = pfuze100_set_ramp_delay,\n};\n\nstatic const struct regulator_ops pfuze100_sw_disable_regulator_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_time_sel = regulator_set_voltage_time_sel,\n\t.set_ramp_delay = pfuze100_set_ramp_delay,\n};\n\nstatic const struct regulator_ops pfuze100_swb_regulator_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\n};\n\nstatic const struct regulator_ops pfuze3000_sw_regulator_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_time_sel = regulator_set_voltage_time_sel,\n\t.set_ramp_delay = pfuze100_set_ramp_delay,\n\n};\n\n#define PFUZE100_FIXED_REG(_chip, _name, base, voltage)\t\\\n\t[_chip ## _ ## _name] = {\t\\\n\t\t.desc = {\t\\\n\t\t\t.name = #_name,\t\\\n\t\t\t.n_voltages = 1,\t\\\n\t\t\t.ops = &pfuze100_fixed_regulator_ops,\t\\\n\t\t\t.type = REGULATOR_VOLTAGE,\t\\\n\t\t\t.id = _chip ## _ ## _name,\t\\\n\t\t\t.owner = THIS_MODULE,\t\\\n\t\t\t.min_uV = (voltage),\t\\\n\t\t\t.enable_reg = (base),\t\\\n\t\t\t.enable_mask = 0x10,\t\\\n\t\t},\t\\\n\t}\n\n#define PFUZE100_SW_REG(_chip, _name, base, min, max, step)\t\\\n\t[_chip ## _ ## _name] = {\t\\\n\t\t.desc = {\t\\\n\t\t\t.name = #_name,\\\n\t\t\t.n_voltages = ((max) - (min)) / (step) + 1,\t\\\n\t\t\t.ops = &pfuze100_sw_regulator_ops,\t\\\n\t\t\t.type = REGULATOR_VOLTAGE,\t\\\n\t\t\t.id = _chip ## _ ## _name,\t\\\n\t\t\t.owner = THIS_MODULE,\t\\\n\t\t\t.min_uV = (min),\t\\\n\t\t\t.uV_step = (step),\t\\\n\t\t\t.vsel_reg = (base) + PFUZE100_VOL_OFFSET,\t\\\n\t\t\t.vsel_mask = 0x3f,\t\\\n\t\t\t.enable_reg = (base) + PFUZE100_MODE_OFFSET,\t\\\n\t\t\t.enable_mask = 0xf,\t\\\n\t\t},\t\\\n\t\t.stby_reg = (base) + PFUZE100_STANDBY_OFFSET,\t\\\n\t\t.stby_mask = 0x3f,\t\\\n\t\t.sw_reg = true,\t\t\\\n\t}\n\n#define PFUZE100_SWB_REG(_chip, _name, base, mask, voltages)\t\\\n\t[_chip ## _ ##  _name] = {\t\\\n\t\t.desc = {\t\\\n\t\t\t.name = #_name,\t\\\n\t\t\t.n_voltages = ARRAY_SIZE(voltages),\t\\\n\t\t\t.ops = &pfuze100_swb_regulator_ops,\t\\\n\t\t\t.type = REGULATOR_VOLTAGE,\t\\\n\t\t\t.id = _chip ## _ ## _name,\t\\\n\t\t\t.owner = THIS_MODULE,\t\\\n\t\t\t.volt_table = voltages,\t\\\n\t\t\t.vsel_reg = (base),\t\\\n\t\t\t.vsel_mask = (mask),\t\\\n\t\t\t.enable_reg = (base),\t\\\n\t\t\t.enable_mask = 0x48,\t\\\n\t\t},\t\\\n\t}\n\n#define PFUZE100_VGEN_REG(_chip, _name, base, min, max, step)\t\\\n\t[_chip ## _ ## _name] = {\t\\\n\t\t.desc = {\t\\\n\t\t\t.name = #_name,\t\\\n\t\t\t.n_voltages = ((max) - (min)) / (step) + 1,\t\\\n\t\t\t.ops = &pfuze100_ldo_regulator_ops,\t\\\n\t\t\t.type = REGULATOR_VOLTAGE,\t\\\n\t\t\t.id = _chip ## _ ## _name,\t\\\n\t\t\t.owner = THIS_MODULE,\t\\\n\t\t\t.min_uV = (min),\t\\\n\t\t\t.uV_step = (step),\t\\\n\t\t\t.vsel_reg = (base),\t\\\n\t\t\t.vsel_mask = 0xf,\t\\\n\t\t\t.enable_reg = (base),\t\\\n\t\t\t.enable_mask = 0x10,\t\\\n\t\t},\t\\\n\t\t.stby_reg = (base),\t\\\n\t\t.stby_mask = 0x20,\t\\\n\t}\n\n#define PFUZE100_COIN_REG(_chip, _name, base, mask, voltages)\t\\\n\t[_chip ## _ ##  _name] = {\t\\\n\t\t.desc = {\t\\\n\t\t\t.name = #_name,\t\\\n\t\t\t.n_voltages = ARRAY_SIZE(voltages),\t\\\n\t\t\t.ops = &pfuze100_swb_regulator_ops,\t\\\n\t\t\t.type = REGULATOR_VOLTAGE,\t\\\n\t\t\t.id = _chip ## _ ## _name,\t\\\n\t\t\t.owner = THIS_MODULE,\t\\\n\t\t\t.volt_table = voltages,\t\\\n\t\t\t.vsel_reg = (base),\t\\\n\t\t\t.vsel_mask = (mask),\t\\\n\t\t\t.enable_reg = (base),\t\\\n\t\t\t.enable_mask = 0x8,\t\\\n\t\t},\t\\\n\t}\n\n#define PFUZE3000_VCC_REG(_chip, _name, base, min, max, step)\t{\t\\\n\t.desc = {\t\\\n\t\t.name = #_name,\t\\\n\t\t.n_voltages = ((max) - (min)) / (step) + 1,\t\\\n\t\t.ops = &pfuze100_ldo_regulator_ops,\t\\\n\t\t.type = REGULATOR_VOLTAGE,\t\\\n\t\t.id = _chip ## _ ## _name,\t\\\n\t\t.owner = THIS_MODULE,\t\\\n\t\t.min_uV = (min),\t\\\n\t\t.uV_step = (step),\t\\\n\t\t.vsel_reg = (base),\t\\\n\t\t.vsel_mask = 0x3,\t\\\n\t\t.enable_reg = (base),\t\\\n\t\t.enable_mask = 0x10,\t\\\n\t},\t\\\n\t.stby_reg = (base),\t\\\n\t.stby_mask = 0x20,\t\\\n}\n\n \n#define PFUZE3000_SW_REG(_chip, _name, base, mask, voltages)\t\\\n\t[_chip ## _ ##  _name] = {\t\\\n\t\t.desc = {\t\\\n\t\t\t.name = #_name,\t\\\n\t\t\t.n_voltages = ARRAY_SIZE(voltages),\t\\\n\t\t\t.ops = &pfuze3000_sw_regulator_ops,\t\\\n\t\t\t.type = REGULATOR_VOLTAGE,\t\\\n\t\t\t.id = _chip ## _ ## _name,\t\\\n\t\t\t.owner = THIS_MODULE,\t\\\n\t\t\t.volt_table = voltages,\t\\\n\t\t\t.vsel_reg = (base) + PFUZE100_VOL_OFFSET,\t\\\n\t\t\t.vsel_mask = (mask),\t\\\n\t\t\t.enable_reg = (base) + PFUZE100_MODE_OFFSET,\t\\\n\t\t\t.enable_mask = 0xf,\t\\\n\t\t\t.enable_val = 0x8,\t\\\n\t\t\t.enable_time = 500,\t\\\n\t\t},\t\\\n\t\t.stby_reg = (base) + PFUZE100_STANDBY_OFFSET,\t\\\n\t\t.stby_mask = (mask),\t\\\n\t\t.sw_reg = true,\t\t\\\n\t}\n\n#define PFUZE3000_SW3_REG(_chip, _name, base, min, max, step)\t{\t\\\n\t.desc = {\t\\\n\t\t.name = #_name,\\\n\t\t.n_voltages = ((max) - (min)) / (step) + 1,\t\\\n\t\t.ops = &pfuze100_sw_regulator_ops,\t\\\n\t\t.type = REGULATOR_VOLTAGE,\t\\\n\t\t.id = _chip ## _ ## _name,\t\\\n\t\t.owner = THIS_MODULE,\t\\\n\t\t.min_uV = (min),\t\\\n\t\t.uV_step = (step),\t\\\n\t\t.vsel_reg = (base) + PFUZE100_VOL_OFFSET,\t\\\n\t\t.vsel_mask = 0xf,\t\\\n\t},\t\\\n\t.stby_reg = (base) + PFUZE100_STANDBY_OFFSET,\t\\\n\t.stby_mask = 0xf,\t\\\n}\n\n \nstatic struct pfuze_regulator pfuze100_regulators[] = {\n\tPFUZE100_SW_REG(PFUZE100, SW1AB, PFUZE100_SW1ABVOL, 300000, 1875000, 25000),\n\tPFUZE100_SW_REG(PFUZE100, SW1C, PFUZE100_SW1CVOL, 300000, 1875000, 25000),\n\tPFUZE100_SW_REG(PFUZE100, SW2, PFUZE100_SW2VOL, 400000, 1975000, 25000),\n\tPFUZE100_SW_REG(PFUZE100, SW3A, PFUZE100_SW3AVOL, 400000, 1975000, 25000),\n\tPFUZE100_SW_REG(PFUZE100, SW3B, PFUZE100_SW3BVOL, 400000, 1975000, 25000),\n\tPFUZE100_SW_REG(PFUZE100, SW4, PFUZE100_SW4VOL, 400000, 1975000, 25000),\n\tPFUZE100_SWB_REG(PFUZE100, SWBST, PFUZE100_SWBSTCON1, 0x3 , pfuze100_swbst),\n\tPFUZE100_SWB_REG(PFUZE100, VSNVS, PFUZE100_VSNVSVOL, 0x7, pfuze100_vsnvs),\n\tPFUZE100_FIXED_REG(PFUZE100, VREFDDR, PFUZE100_VREFDDRCON, 750000),\n\tPFUZE100_VGEN_REG(PFUZE100, VGEN1, PFUZE100_VGEN1VOL, 800000, 1550000, 50000),\n\tPFUZE100_VGEN_REG(PFUZE100, VGEN2, PFUZE100_VGEN2VOL, 800000, 1550000, 50000),\n\tPFUZE100_VGEN_REG(PFUZE100, VGEN3, PFUZE100_VGEN3VOL, 1800000, 3300000, 100000),\n\tPFUZE100_VGEN_REG(PFUZE100, VGEN4, PFUZE100_VGEN4VOL, 1800000, 3300000, 100000),\n\tPFUZE100_VGEN_REG(PFUZE100, VGEN5, PFUZE100_VGEN5VOL, 1800000, 3300000, 100000),\n\tPFUZE100_VGEN_REG(PFUZE100, VGEN6, PFUZE100_VGEN6VOL, 1800000, 3300000, 100000),\n\tPFUZE100_COIN_REG(PFUZE100, COIN, PFUZE100_COINVOL, 0x7, pfuze100_coin),\n};\n\nstatic struct pfuze_regulator pfuze200_regulators[] = {\n\tPFUZE100_SW_REG(PFUZE200, SW1AB, PFUZE100_SW1ABVOL, 300000, 1875000, 25000),\n\tPFUZE100_SW_REG(PFUZE200, SW2, PFUZE100_SW2VOL, 400000, 1975000, 25000),\n\tPFUZE100_SW_REG(PFUZE200, SW3A, PFUZE100_SW3AVOL, 400000, 1975000, 25000),\n\tPFUZE100_SW_REG(PFUZE200, SW3B, PFUZE100_SW3BVOL, 400000, 1975000, 25000),\n\tPFUZE100_SWB_REG(PFUZE200, SWBST, PFUZE100_SWBSTCON1, 0x3 , pfuze100_swbst),\n\tPFUZE100_SWB_REG(PFUZE200, VSNVS, PFUZE100_VSNVSVOL, 0x7, pfuze100_vsnvs),\n\tPFUZE100_FIXED_REG(PFUZE200, VREFDDR, PFUZE100_VREFDDRCON, 750000),\n\tPFUZE100_VGEN_REG(PFUZE200, VGEN1, PFUZE100_VGEN1VOL, 800000, 1550000, 50000),\n\tPFUZE100_VGEN_REG(PFUZE200, VGEN2, PFUZE100_VGEN2VOL, 800000, 1550000, 50000),\n\tPFUZE100_VGEN_REG(PFUZE200, VGEN3, PFUZE100_VGEN3VOL, 1800000, 3300000, 100000),\n\tPFUZE100_VGEN_REG(PFUZE200, VGEN4, PFUZE100_VGEN4VOL, 1800000, 3300000, 100000),\n\tPFUZE100_VGEN_REG(PFUZE200, VGEN5, PFUZE100_VGEN5VOL, 1800000, 3300000, 100000),\n\tPFUZE100_VGEN_REG(PFUZE200, VGEN6, PFUZE100_VGEN6VOL, 1800000, 3300000, 100000),\n\tPFUZE100_COIN_REG(PFUZE200, COIN, PFUZE100_COINVOL, 0x7, pfuze100_coin),\n};\n\nstatic struct pfuze_regulator pfuze3000_regulators[] = {\n\tPFUZE3000_SW_REG(PFUZE3000, SW1A, PFUZE100_SW1ABVOL, 0x1f, pfuze3000_sw1a),\n\tPFUZE100_SW_REG(PFUZE3000, SW1B, PFUZE100_SW1CVOL, 700000, 1475000, 25000),\n\tPFUZE3000_SW_REG(PFUZE3000, SW2, PFUZE100_SW2VOL, 0x7, pfuze3000_sw2lo),\n\tPFUZE3000_SW3_REG(PFUZE3000, SW3, PFUZE100_SW3AVOL, 900000, 1650000, 50000),\n\tPFUZE100_SWB_REG(PFUZE3000, SWBST, PFUZE100_SWBSTCON1, 0x3, pfuze100_swbst),\n\tPFUZE100_SWB_REG(PFUZE3000, VSNVS, PFUZE100_VSNVSVOL, 0x7, pfuze100_vsnvs),\n\tPFUZE100_FIXED_REG(PFUZE3000, VREFDDR, PFUZE100_VREFDDRCON, 750000),\n\tPFUZE100_VGEN_REG(PFUZE3000, VLDO1, PFUZE100_VGEN1VOL, 1800000, 3300000, 100000),\n\tPFUZE100_VGEN_REG(PFUZE3000, VLDO2, PFUZE100_VGEN2VOL, 800000, 1550000, 50000),\n\tPFUZE3000_VCC_REG(PFUZE3000, VCCSD, PFUZE100_VGEN3VOL, 2850000, 3300000, 150000),\n\tPFUZE3000_VCC_REG(PFUZE3000, V33, PFUZE100_VGEN4VOL, 2850000, 3300000, 150000),\n\tPFUZE100_VGEN_REG(PFUZE3000, VLDO3, PFUZE100_VGEN5VOL, 1800000, 3300000, 100000),\n\tPFUZE100_VGEN_REG(PFUZE3000, VLDO4, PFUZE100_VGEN6VOL, 1800000, 3300000, 100000),\n};\n\nstatic struct pfuze_regulator pfuze3001_regulators[] = {\n\tPFUZE3000_SW_REG(PFUZE3001, SW1, PFUZE100_SW1ABVOL, 0x1f, pfuze3000_sw1a),\n\tPFUZE3000_SW_REG(PFUZE3001, SW2, PFUZE100_SW2VOL, 0x7, pfuze3000_sw2lo),\n\tPFUZE3000_SW3_REG(PFUZE3001, SW3, PFUZE100_SW3AVOL, 900000, 1650000, 50000),\n\tPFUZE100_SWB_REG(PFUZE3001, VSNVS, PFUZE100_VSNVSVOL, 0x7, pfuze100_vsnvs),\n\tPFUZE100_VGEN_REG(PFUZE3001, VLDO1, PFUZE100_VGEN1VOL, 1800000, 3300000, 100000),\n\tPFUZE100_VGEN_REG(PFUZE3001, VLDO2, PFUZE100_VGEN2VOL, 800000, 1550000, 50000),\n\tPFUZE3000_VCC_REG(PFUZE3001, VCCSD, PFUZE100_VGEN3VOL, 2850000, 3300000, 150000),\n\tPFUZE3000_VCC_REG(PFUZE3001, V33, PFUZE100_VGEN4VOL, 2850000, 3300000, 150000),\n\tPFUZE100_VGEN_REG(PFUZE3001, VLDO3, PFUZE100_VGEN5VOL, 1800000, 3300000, 100000),\n\tPFUZE100_VGEN_REG(PFUZE3001, VLDO4, PFUZE100_VGEN6VOL, 1800000, 3300000, 100000),\n};\n\n \nstatic struct of_regulator_match pfuze100_matches[] = {\n\t{ .name = \"sw1ab\",\t},\n\t{ .name = \"sw1c\",\t},\n\t{ .name = \"sw2\",\t},\n\t{ .name = \"sw3a\",\t},\n\t{ .name = \"sw3b\",\t},\n\t{ .name = \"sw4\",\t},\n\t{ .name = \"swbst\",\t},\n\t{ .name = \"vsnvs\",\t},\n\t{ .name = \"vrefddr\",\t},\n\t{ .name = \"vgen1\",\t},\n\t{ .name = \"vgen2\",\t},\n\t{ .name = \"vgen3\",\t},\n\t{ .name = \"vgen4\",\t},\n\t{ .name = \"vgen5\",\t},\n\t{ .name = \"vgen6\",\t},\n\t{ .name = \"coin\",\t},\n};\n\n \nstatic struct of_regulator_match pfuze200_matches[] = {\n\n\t{ .name = \"sw1ab\",\t},\n\t{ .name = \"sw2\",\t},\n\t{ .name = \"sw3a\",\t},\n\t{ .name = \"sw3b\",\t},\n\t{ .name = \"swbst\",\t},\n\t{ .name = \"vsnvs\",\t},\n\t{ .name = \"vrefddr\",\t},\n\t{ .name = \"vgen1\",\t},\n\t{ .name = \"vgen2\",\t},\n\t{ .name = \"vgen3\",\t},\n\t{ .name = \"vgen4\",\t},\n\t{ .name = \"vgen5\",\t},\n\t{ .name = \"vgen6\",\t},\n\t{ .name = \"coin\",\t},\n};\n\n \nstatic struct of_regulator_match pfuze3000_matches[] = {\n\n\t{ .name = \"sw1a\",\t},\n\t{ .name = \"sw1b\",\t},\n\t{ .name = \"sw2\",\t},\n\t{ .name = \"sw3\",\t},\n\t{ .name = \"swbst\",\t},\n\t{ .name = \"vsnvs\",\t},\n\t{ .name = \"vrefddr\",\t},\n\t{ .name = \"vldo1\",\t},\n\t{ .name = \"vldo2\",\t},\n\t{ .name = \"vccsd\",\t},\n\t{ .name = \"v33\",\t},\n\t{ .name = \"vldo3\",\t},\n\t{ .name = \"vldo4\",\t},\n};\n\n \nstatic struct of_regulator_match pfuze3001_matches[] = {\n\n\t{ .name = \"sw1\",\t},\n\t{ .name = \"sw2\",\t},\n\t{ .name = \"sw3\",\t},\n\t{ .name = \"vsnvs\",\t},\n\t{ .name = \"vldo1\",\t},\n\t{ .name = \"vldo2\",\t},\n\t{ .name = \"vccsd\",\t},\n\t{ .name = \"v33\",\t},\n\t{ .name = \"vldo3\",\t},\n\t{ .name = \"vldo4\",\t},\n};\n\nstatic struct of_regulator_match *pfuze_matches;\n\nstatic int pfuze_parse_regulators_dt(struct pfuze_chip *chip)\n{\n\tstruct device *dev = chip->dev;\n\tstruct device_node *np, *parent;\n\tint ret;\n\n\tnp = of_node_get(dev->of_node);\n\tif (!np)\n\t\treturn -EINVAL;\n\n\tif (of_property_read_bool(np, \"fsl,pfuze-support-disable-sw\"))\n\t\tchip->flags |= PFUZE_FLAG_DISABLE_SW;\n\n\tparent = of_get_child_by_name(np, \"regulators\");\n\tif (!parent) {\n\t\tdev_err(dev, \"regulators node not found\\n\");\n\t\tof_node_put(np);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (chip->chip_id) {\n\tcase PFUZE3001:\n\t\tpfuze_matches = pfuze3001_matches;\n\t\tret = of_regulator_match(dev, parent, pfuze3001_matches,\n\t\t\t\t\t ARRAY_SIZE(pfuze3001_matches));\n\t\tbreak;\n\tcase PFUZE3000:\n\t\tpfuze_matches = pfuze3000_matches;\n\t\tret = of_regulator_match(dev, parent, pfuze3000_matches,\n\t\t\t\t\t ARRAY_SIZE(pfuze3000_matches));\n\t\tbreak;\n\tcase PFUZE200:\n\t\tpfuze_matches = pfuze200_matches;\n\t\tret = of_regulator_match(dev, parent, pfuze200_matches,\n\t\t\t\t\t ARRAY_SIZE(pfuze200_matches));\n\t\tbreak;\n\n\tcase PFUZE100:\n\tdefault:\n\t\tpfuze_matches = pfuze100_matches;\n\t\tret = of_regulator_match(dev, parent, pfuze100_matches,\n\t\t\t\t\t ARRAY_SIZE(pfuze100_matches));\n\t\tbreak;\n\t}\n\n\tof_node_put(parent);\n\tof_node_put(np);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error parsing regulator init data: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline struct regulator_init_data *match_init_data(int index)\n{\n\treturn pfuze_matches[index].init_data;\n}\n\nstatic inline struct device_node *match_of_node(int index)\n{\n\treturn pfuze_matches[index].of_node;\n}\n\nstatic int pfuze_power_off_prepare(struct sys_off_data *data)\n{\n\tstruct pfuze_chip *syspm_pfuze_chip = data->cb_data;\n\n\tdev_info(syspm_pfuze_chip->dev, \"Configure standby mode for power off\");\n\n\t \n\tregmap_update_bits(syspm_pfuze_chip->regmap, PFUZE100_SW1ABMODE,\n\t\t\t   PFUZE100_SWxMODE_MASK, PFUZE100_SWxMODE_APS_OFF);\n\tregmap_update_bits(syspm_pfuze_chip->regmap, PFUZE100_SW1CMODE,\n\t\t\t   PFUZE100_SWxMODE_MASK, PFUZE100_SWxMODE_APS_OFF);\n\tregmap_update_bits(syspm_pfuze_chip->regmap, PFUZE100_SW2MODE,\n\t\t\t   PFUZE100_SWxMODE_MASK, PFUZE100_SWxMODE_APS_OFF);\n\tregmap_update_bits(syspm_pfuze_chip->regmap, PFUZE100_SW3AMODE,\n\t\t\t   PFUZE100_SWxMODE_MASK, PFUZE100_SWxMODE_APS_OFF);\n\tregmap_update_bits(syspm_pfuze_chip->regmap, PFUZE100_SW3BMODE,\n\t\t\t   PFUZE100_SWxMODE_MASK, PFUZE100_SWxMODE_APS_OFF);\n\tregmap_update_bits(syspm_pfuze_chip->regmap, PFUZE100_SW4MODE,\n\t\t\t   PFUZE100_SWxMODE_MASK, PFUZE100_SWxMODE_APS_OFF);\n\n\tregmap_update_bits(syspm_pfuze_chip->regmap, PFUZE100_VGEN1VOL,\n\t\t\t   PFUZE100_VGENxLPWR | PFUZE100_VGENxSTBY,\n\t\t\t   PFUZE100_VGENxSTBY);\n\tregmap_update_bits(syspm_pfuze_chip->regmap, PFUZE100_VGEN2VOL,\n\t\t\t   PFUZE100_VGENxLPWR | PFUZE100_VGENxSTBY,\n\t\t\t   PFUZE100_VGENxSTBY);\n\tregmap_update_bits(syspm_pfuze_chip->regmap, PFUZE100_VGEN3VOL,\n\t\t\t   PFUZE100_VGENxLPWR | PFUZE100_VGENxSTBY,\n\t\t\t   PFUZE100_VGENxSTBY);\n\tregmap_update_bits(syspm_pfuze_chip->regmap, PFUZE100_VGEN4VOL,\n\t\t\t   PFUZE100_VGENxLPWR | PFUZE100_VGENxSTBY,\n\t\t\t   PFUZE100_VGENxSTBY);\n\tregmap_update_bits(syspm_pfuze_chip->regmap, PFUZE100_VGEN5VOL,\n\t\t\t   PFUZE100_VGENxLPWR | PFUZE100_VGENxSTBY,\n\t\t\t   PFUZE100_VGENxSTBY);\n\tregmap_update_bits(syspm_pfuze_chip->regmap, PFUZE100_VGEN6VOL,\n\t\t\t   PFUZE100_VGENxLPWR | PFUZE100_VGENxSTBY,\n\t\t\t   PFUZE100_VGENxSTBY);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int pfuze_power_off_prepare_init(struct pfuze_chip *pfuze_chip)\n{\n\tint err;\n\n\tif (pfuze_chip->chip_id != PFUZE100) {\n\t\tdev_warn(pfuze_chip->dev, \"Requested pm_power_off_prepare handler for not supported chip\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = devm_register_sys_off_handler(pfuze_chip->dev,\n\t\t\t\t\t    SYS_OFF_MODE_POWER_OFF_PREPARE,\n\t\t\t\t\t    SYS_OFF_PRIO_DEFAULT,\n\t\t\t\t\t    pfuze_power_off_prepare,\n\t\t\t\t\t    pfuze_chip);\n\tif (err) {\n\t\tdev_err(pfuze_chip->dev, \"failed to register sys-off handler: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int pfuze_identify(struct pfuze_chip *pfuze_chip)\n{\n\tunsigned int value;\n\tint ret;\n\n\tret = regmap_read(pfuze_chip->regmap, PFUZE100_DEVICEID, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (((value & 0x0f) == 0x8) && (pfuze_chip->chip_id == PFUZE100)) {\n\t\t \n\t\tdev_info(pfuze_chip->dev, \"Assuming misprogrammed ID=0x8\");\n\t} else if ((value & 0x0f) != pfuze_chip->chip_id &&\n\t\t   (value & 0xf0) >> 4 != pfuze_chip->chip_id &&\n\t\t   (value != pfuze_chip->chip_id)) {\n\t\t \n\t\tdev_warn(pfuze_chip->dev, \"Illegal ID: %x\\n\", value);\n\t\treturn -ENODEV;\n\t}\n\n\tret = regmap_read(pfuze_chip->regmap, PFUZE100_REVID, &value);\n\tif (ret)\n\t\treturn ret;\n\tdev_info(pfuze_chip->dev,\n\t\t \"Full layer: %x, Metal layer: %x\\n\",\n\t\t (value & 0xf0) >> 4, value & 0x0f);\n\n\tret = regmap_read(pfuze_chip->regmap, PFUZE100_FABID, &value);\n\tif (ret)\n\t\treturn ret;\n\tdev_info(pfuze_chip->dev, \"FAB: %x, FIN: %x\\n\",\n\t\t (value & 0xc) >> 2, value & 0x3);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config pfuze_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = PFUZE_NUMREGS - 1,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int pfuze100_regulator_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct pfuze_chip *pfuze_chip;\n\tstruct regulator_config config = { };\n\tint i, ret;\n\tconst struct of_device_id *match;\n\tu32 regulator_num;\n\tu32 sw_check_start, sw_check_end, sw_hi = 0x40;\n\n\tpfuze_chip = devm_kzalloc(&client->dev, sizeof(*pfuze_chip),\n\t\t\tGFP_KERNEL);\n\tif (!pfuze_chip)\n\t\treturn -ENOMEM;\n\n\tif (client->dev.of_node) {\n\t\tmatch = of_match_device(pfuze_dt_ids, &client->dev);\n\t\tif (!match) {\n\t\t\tdev_err(&client->dev, \"Error: No device match found\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tpfuze_chip->chip_id = (int)(long)match->data;\n\t} else if (id) {\n\t\tpfuze_chip->chip_id = id->driver_data;\n\t} else {\n\t\tdev_err(&client->dev, \"No dts match or id table match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ti2c_set_clientdata(client, pfuze_chip);\n\tpfuze_chip->dev = &client->dev;\n\n\tpfuze_chip->regmap = devm_regmap_init_i2c(client, &pfuze_regmap_config);\n\tif (IS_ERR(pfuze_chip->regmap)) {\n\t\tret = PTR_ERR(pfuze_chip->regmap);\n\t\tdev_err(&client->dev,\n\t\t\t\"regmap allocation failed with err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pfuze_identify(pfuze_chip);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"unrecognized pfuze chip ID!\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tswitch (pfuze_chip->chip_id) {\n\tcase PFUZE3001:\n\t\tpfuze_chip->pfuze_regulators = pfuze3001_regulators;\n\t\tregulator_num = ARRAY_SIZE(pfuze3001_regulators);\n\t\tsw_check_start = PFUZE3001_SW2;\n\t\tsw_check_end = PFUZE3001_SW2;\n\t\tsw_hi = 1 << 3;\n\t\tbreak;\n\tcase PFUZE3000:\n\t\tpfuze_chip->pfuze_regulators = pfuze3000_regulators;\n\t\tregulator_num = ARRAY_SIZE(pfuze3000_regulators);\n\t\tsw_check_start = PFUZE3000_SW2;\n\t\tsw_check_end = PFUZE3000_SW2;\n\t\tsw_hi = 1 << 3;\n\t\tbreak;\n\tcase PFUZE200:\n\t\tpfuze_chip->pfuze_regulators = pfuze200_regulators;\n\t\tregulator_num = ARRAY_SIZE(pfuze200_regulators);\n\t\tsw_check_start = PFUZE200_SW2;\n\t\tsw_check_end = PFUZE200_SW3B;\n\t\tbreak;\n\tcase PFUZE100:\n\tdefault:\n\t\tpfuze_chip->pfuze_regulators = pfuze100_regulators;\n\t\tregulator_num = ARRAY_SIZE(pfuze100_regulators);\n\t\tsw_check_start = PFUZE100_SW2;\n\t\tsw_check_end = PFUZE100_SW4;\n\t\tbreak;\n\t}\n\tdev_info(&client->dev, \"pfuze%s found.\\n\",\n\t\t(pfuze_chip->chip_id == PFUZE100) ? \"100\" :\n\t\t(((pfuze_chip->chip_id == PFUZE200) ? \"200\" :\n\t\t((pfuze_chip->chip_id == PFUZE3000) ? \"3000\" : \"3001\"))));\n\n\tmemcpy(pfuze_chip->regulator_descs, pfuze_chip->pfuze_regulators,\n\t\tregulator_num * sizeof(struct pfuze_regulator));\n\n\tret = pfuze_parse_regulators_dt(pfuze_chip);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < regulator_num; i++) {\n\t\tstruct regulator_init_data *init_data;\n\t\tstruct regulator_desc *desc;\n\t\tint val;\n\n\t\tdesc = &pfuze_chip->regulator_descs[i].desc;\n\n\t\tinit_data = match_init_data(i);\n\n\t\t \n\t\tif (i >= sw_check_start && i <= sw_check_end) {\n\t\t\tret = regmap_read(pfuze_chip->regmap,\n\t\t\t\t\t\tdesc->vsel_reg, &val);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&client->dev, \"Fails to read from the register.\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (val & sw_hi) {\n\t\t\t\tif (pfuze_chip->chip_id == PFUZE3000 ||\n\t\t\t\t\tpfuze_chip->chip_id == PFUZE3001) {\n\t\t\t\t\tdesc->volt_table = pfuze3000_sw2hi;\n\t\t\t\t\tdesc->n_voltages = ARRAY_SIZE(pfuze3000_sw2hi);\n\t\t\t\t} else {\n\t\t\t\t\tdesc->min_uV = 800000;\n\t\t\t\t\tdesc->uV_step = 50000;\n\t\t\t\t\tdesc->n_voltages = 51;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (pfuze_chip->flags & PFUZE_FLAG_DISABLE_SW) {\n\t\t\tif (pfuze_chip->chip_id == PFUZE100 ||\n\t\t\t\tpfuze_chip->chip_id == PFUZE200) {\n\t\t\t\tif (pfuze_chip->regulator_descs[i].sw_reg) {\n\t\t\t\t\tdesc->ops = &pfuze100_sw_disable_regulator_ops;\n\t\t\t\t\tdesc->enable_val = 0x8;\n\t\t\t\t\tdesc->disable_val = 0x0;\n\t\t\t\t\tdesc->enable_time = 500;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconfig.dev = &client->dev;\n\t\tconfig.init_data = init_data;\n\t\tconfig.driver_data = pfuze_chip;\n\t\tconfig.of_node = match_of_node(i);\n\n\t\tpfuze_chip->regulators[i] =\n\t\t\tdevm_regulator_register(&client->dev, desc, &config);\n\t\tif (IS_ERR(pfuze_chip->regulators[i])) {\n\t\t\tdev_err(&client->dev, \"register regulator%s failed\\n\",\n\t\t\t\tpfuze_chip->pfuze_regulators[i].desc.name);\n\t\t\treturn PTR_ERR(pfuze_chip->regulators[i]);\n\t\t}\n\t}\n\n\tif (of_property_read_bool(client->dev.of_node,\n\t\t\t\t  \"fsl,pmic-stby-poweroff\"))\n\t\treturn pfuze_power_off_prepare_init(pfuze_chip);\n\n\treturn 0;\n}\n\nstatic struct i2c_driver pfuze_driver = {\n\t.driver = {\n\t\t.name = \"pfuze100-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = pfuze_dt_ids,\n\t},\n\t.probe = pfuze100_regulator_probe,\n};\nmodule_i2c_driver(pfuze_driver);\n\nMODULE_AUTHOR(\"Robin Gong <b38343@freescale.com>\");\nMODULE_DESCRIPTION(\"Regulator Driver for Freescale PFUZE100/200/3000/3001 PMIC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}