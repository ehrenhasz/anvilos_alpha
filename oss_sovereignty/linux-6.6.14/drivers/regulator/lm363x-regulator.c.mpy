{
  "module_name": "lm363x-regulator.c",
  "hash_id": "ef068636a94e6a29dc245a5c3b28d8b8b28d4be0e95aa8bb8d55c49c2d73be81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/lm363x-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/mfd/ti-lmu.h>\n#include <linux/mfd/ti-lmu-register.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/slab.h>\n\n \n#define LM3631_BOOST_VSEL_MAX\t\t0x25\n#define LM3631_LDO_VSEL_MAX\t\t0x28\n#define LM3631_CONT_VSEL_MAX\t\t0x03\n#define LM3631_VBOOST_MIN\t\t4500000\n#define LM3631_VCONT_MIN\t\t1800000\n#define LM3631_VLDO_MIN\t\t\t4000000\n#define ENABLE_TIME_USEC\t\t1000\n\n \n#define LM3632_BOOST_VSEL_MAX\t\t0x26\n#define LM3632_LDO_VSEL_MAX\t\t0x28\n#define LM3632_VBOOST_MIN\t\t4500000\n#define LM3632_VLDO_MIN\t\t\t4000000\n\n \n#define LM36274_BOOST_VSEL_MAX\t\t0x3f\n#define LM36274_LDO_VSEL_MAX\t\t0x32\n#define LM36274_VOLTAGE_MIN\t\t4000000\n\n \n#define LM363X_STEP_50mV\t\t50000\n#define LM363X_STEP_500mV\t\t500000\n\nstatic const int ldo_cont_enable_time[] = {\n\t0, 2000, 5000, 10000, 20000, 50000, 100000, 200000,\n};\n\nstatic int lm363x_regulator_enable_time(struct regulator_dev *rdev)\n{\n\tenum lm363x_regulator_id id = rdev_get_id(rdev);\n\tunsigned int val, addr, mask;\n\n\tswitch (id) {\n\tcase LM3631_LDO_CONT:\n\t\taddr = LM3631_REG_ENTIME_VCONT;\n\t\tmask = LM3631_ENTIME_CONT_MASK;\n\t\tbreak;\n\tcase LM3631_LDO_OREF:\n\t\taddr = LM3631_REG_ENTIME_VOREF;\n\t\tmask = LM3631_ENTIME_MASK;\n\t\tbreak;\n\tcase LM3631_LDO_POS:\n\t\taddr = LM3631_REG_ENTIME_VPOS;\n\t\tmask = LM3631_ENTIME_MASK;\n\t\tbreak;\n\tcase LM3631_LDO_NEG:\n\t\taddr = LM3631_REG_ENTIME_VNEG;\n\t\tmask = LM3631_ENTIME_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (regmap_read(rdev->regmap, addr, &val))\n\t\treturn -EINVAL;\n\n\tval = (val & mask) >> LM3631_ENTIME_SHIFT;\n\n\tif (id == LM3631_LDO_CONT)\n\t\treturn ldo_cont_enable_time[val];\n\telse\n\t\treturn ENABLE_TIME_USEC * val;\n}\n\nstatic const struct regulator_ops lm363x_boost_voltage_table_ops = {\n\t.list_voltage     = regulator_list_voltage_linear,\n\t.set_voltage_sel  = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel  = regulator_get_voltage_sel_regmap,\n};\n\nstatic const struct regulator_ops lm363x_regulator_voltage_table_ops = {\n\t.list_voltage     = regulator_list_voltage_linear,\n\t.set_voltage_sel  = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel  = regulator_get_voltage_sel_regmap,\n\t.enable           = regulator_enable_regmap,\n\t.disable          = regulator_disable_regmap,\n\t.is_enabled       = regulator_is_enabled_regmap,\n\t.enable_time      = lm363x_regulator_enable_time,\n};\n\nstatic const struct regulator_desc lm363x_regulator_desc[] = {\n\t \n\t{\n\t\t.name           = \"vboost\",\n\t\t.of_match\t= \"vboost\",\n\t\t.id             = LM3631_BOOST,\n\t\t.ops            = &lm363x_boost_voltage_table_ops,\n\t\t.n_voltages     = LM3631_BOOST_VSEL_MAX + 1,\n\t\t.min_uV         = LM3631_VBOOST_MIN,\n\t\t.uV_step        = LM363X_STEP_50mV,\n\t\t.type           = REGULATOR_VOLTAGE,\n\t\t.owner          = THIS_MODULE,\n\t\t.vsel_reg       = LM3631_REG_VOUT_BOOST,\n\t\t.vsel_mask      = LM3631_VOUT_MASK,\n\t},\n\t{\n\t\t.name           = \"ldo_cont\",\n\t\t.of_match\t= \"vcont\",\n\t\t.id             = LM3631_LDO_CONT,\n\t\t.ops            = &lm363x_regulator_voltage_table_ops,\n\t\t.n_voltages     = LM3631_CONT_VSEL_MAX + 1,\n\t\t.min_uV         = LM3631_VCONT_MIN,\n\t\t.uV_step        = LM363X_STEP_500mV,\n\t\t.type           = REGULATOR_VOLTAGE,\n\t\t.owner          = THIS_MODULE,\n\t\t.vsel_reg       = LM3631_REG_VOUT_CONT,\n\t\t.vsel_mask      = LM3631_VOUT_CONT_MASK,\n\t\t.enable_reg     = LM3631_REG_LDO_CTRL2,\n\t\t.enable_mask    = LM3631_EN_CONT_MASK,\n\t},\n\t{\n\t\t.name           = \"ldo_oref\",\n\t\t.of_match\t= \"voref\",\n\t\t.id             = LM3631_LDO_OREF,\n\t\t.ops            = &lm363x_regulator_voltage_table_ops,\n\t\t.n_voltages     = LM3631_LDO_VSEL_MAX + 1,\n\t\t.min_uV         = LM3631_VLDO_MIN,\n\t\t.uV_step        = LM363X_STEP_50mV,\n\t\t.type           = REGULATOR_VOLTAGE,\n\t\t.owner          = THIS_MODULE,\n\t\t.vsel_reg       = LM3631_REG_VOUT_OREF,\n\t\t.vsel_mask      = LM3631_VOUT_MASK,\n\t\t.enable_reg     = LM3631_REG_LDO_CTRL1,\n\t\t.enable_mask    = LM3631_EN_OREF_MASK,\n\t},\n\t{\n\t\t.name           = \"ldo_vpos\",\n\t\t.of_match\t= \"vpos\",\n\t\t.id             = LM3631_LDO_POS,\n\t\t.ops            = &lm363x_regulator_voltage_table_ops,\n\t\t.n_voltages     = LM3631_LDO_VSEL_MAX + 1,\n\t\t.min_uV         = LM3631_VLDO_MIN,\n\t\t.uV_step        = LM363X_STEP_50mV,\n\t\t.type           = REGULATOR_VOLTAGE,\n\t\t.owner          = THIS_MODULE,\n\t\t.vsel_reg       = LM3631_REG_VOUT_POS,\n\t\t.vsel_mask      = LM3631_VOUT_MASK,\n\t\t.enable_reg     = LM3631_REG_LDO_CTRL1,\n\t\t.enable_mask    = LM3631_EN_VPOS_MASK,\n\t},\n\t{\n\t\t.name           = \"ldo_vneg\",\n\t\t.of_match\t= \"vneg\",\n\t\t.id             = LM3631_LDO_NEG,\n\t\t.ops            = &lm363x_regulator_voltage_table_ops,\n\t\t.n_voltages     = LM3631_LDO_VSEL_MAX + 1,\n\t\t.min_uV         = LM3631_VLDO_MIN,\n\t\t.uV_step        = LM363X_STEP_50mV,\n\t\t.type           = REGULATOR_VOLTAGE,\n\t\t.owner          = THIS_MODULE,\n\t\t.vsel_reg       = LM3631_REG_VOUT_NEG,\n\t\t.vsel_mask      = LM3631_VOUT_MASK,\n\t\t.enable_reg     = LM3631_REG_LDO_CTRL1,\n\t\t.enable_mask    = LM3631_EN_VNEG_MASK,\n\t},\n\t \n\t{\n\t\t.name           = \"vboost\",\n\t\t.of_match\t= \"vboost\",\n\t\t.id             = LM3632_BOOST,\n\t\t.ops            = &lm363x_boost_voltage_table_ops,\n\t\t.n_voltages     = LM3632_BOOST_VSEL_MAX + 1,\n\t\t.min_uV         = LM3632_VBOOST_MIN,\n\t\t.uV_step        = LM363X_STEP_50mV,\n\t\t.type           = REGULATOR_VOLTAGE,\n\t\t.owner          = THIS_MODULE,\n\t\t.vsel_reg       = LM3632_REG_VOUT_BOOST,\n\t\t.vsel_mask      = LM3632_VOUT_MASK,\n\t},\n\t{\n\t\t.name           = \"ldo_vpos\",\n\t\t.of_match\t= \"vpos\",\n\t\t.id             = LM3632_LDO_POS,\n\t\t.ops            = &lm363x_regulator_voltage_table_ops,\n\t\t.n_voltages     = LM3632_LDO_VSEL_MAX + 1,\n\t\t.min_uV         = LM3632_VLDO_MIN,\n\t\t.uV_step        = LM363X_STEP_50mV,\n\t\t.type           = REGULATOR_VOLTAGE,\n\t\t.owner          = THIS_MODULE,\n\t\t.vsel_reg       = LM3632_REG_VOUT_POS,\n\t\t.vsel_mask      = LM3632_VOUT_MASK,\n\t\t.enable_reg     = LM3632_REG_BIAS_CONFIG,\n\t\t.enable_mask    = LM3632_EN_VPOS_MASK,\n\t},\n\t{\n\t\t.name           = \"ldo_vneg\",\n\t\t.of_match\t= \"vneg\",\n\t\t.id             = LM3632_LDO_NEG,\n\t\t.ops            = &lm363x_regulator_voltage_table_ops,\n\t\t.n_voltages     = LM3632_LDO_VSEL_MAX + 1,\n\t\t.min_uV         = LM3632_VLDO_MIN,\n\t\t.uV_step        = LM363X_STEP_50mV,\n\t\t.type           = REGULATOR_VOLTAGE,\n\t\t.owner          = THIS_MODULE,\n\t\t.vsel_reg       = LM3632_REG_VOUT_NEG,\n\t\t.vsel_mask      = LM3632_VOUT_MASK,\n\t\t.enable_reg     = LM3632_REG_BIAS_CONFIG,\n\t\t.enable_mask    = LM3632_EN_VNEG_MASK,\n\t},\n\n\t \n\t{\n\t\t.name           = \"vboost\",\n\t\t.of_match\t= \"vboost\",\n\t\t.id             = LM36274_BOOST,\n\t\t.ops            = &lm363x_boost_voltage_table_ops,\n\t\t.n_voltages     = LM36274_BOOST_VSEL_MAX + 1,\n\t\t.min_uV         = LM36274_VOLTAGE_MIN,\n\t\t.uV_step        = LM363X_STEP_50mV,\n\t\t.type           = REGULATOR_VOLTAGE,\n\t\t.owner          = THIS_MODULE,\n\t\t.vsel_reg       = LM36274_REG_VOUT_BOOST,\n\t\t.vsel_mask      = LM36274_VOUT_MASK,\n\t},\n\t{\n\t\t.name           = \"ldo_vpos\",\n\t\t.of_match\t= \"vpos\",\n\t\t.id             = LM36274_LDO_POS,\n\t\t.ops            = &lm363x_regulator_voltage_table_ops,\n\t\t.n_voltages     = LM36274_LDO_VSEL_MAX + 1,\n\t\t.min_uV         = LM36274_VOLTAGE_MIN,\n\t\t.uV_step        = LM363X_STEP_50mV,\n\t\t.type           = REGULATOR_VOLTAGE,\n\t\t.owner          = THIS_MODULE,\n\t\t.vsel_reg       = LM36274_REG_VOUT_POS,\n\t\t.vsel_mask      = LM36274_VOUT_MASK,\n\t\t.enable_reg     = LM36274_REG_BIAS_CONFIG_1,\n\t\t.enable_mask    = LM36274_EN_VPOS_MASK,\n\t},\n\t{\n\t\t.name           = \"ldo_vneg\",\n\t\t.of_match\t= \"vneg\",\n\t\t.id             = LM36274_LDO_NEG,\n\t\t.ops            = &lm363x_regulator_voltage_table_ops,\n\t\t.n_voltages     = LM36274_LDO_VSEL_MAX + 1,\n\t\t.min_uV         = LM36274_VOLTAGE_MIN,\n\t\t.uV_step        = LM363X_STEP_50mV,\n\t\t.type           = REGULATOR_VOLTAGE,\n\t\t.owner          = THIS_MODULE,\n\t\t.vsel_reg       = LM36274_REG_VOUT_NEG,\n\t\t.vsel_mask      = LM36274_VOUT_MASK,\n\t\t.enable_reg     = LM36274_REG_BIAS_CONFIG_1,\n\t\t.enable_mask    = LM36274_EN_VNEG_MASK,\n\t},\n};\n\nstatic struct gpio_desc *lm363x_regulator_of_get_enable_gpio(struct device *dev, int id)\n{\n\t \n\tswitch (id) {\n\tcase LM3632_LDO_POS:\n\tcase LM36274_LDO_POS:\n\t\treturn gpiod_get_index_optional(dev, \"enable\", 0,\n\t\t\t\tGPIOD_OUT_LOW | GPIOD_FLAGS_BIT_NONEXCLUSIVE);\n\tcase LM3632_LDO_NEG:\n\tcase LM36274_LDO_NEG:\n\t\treturn gpiod_get_index_optional(dev, \"enable\", 1,\n\t\t\t\tGPIOD_OUT_LOW | GPIOD_FLAGS_BIT_NONEXCLUSIVE);\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int lm363x_regulator_set_ext_en(struct regmap *regmap, int id)\n{\n\tint ext_en_mask = 0;\n\n\tswitch (id) {\n\tcase LM3632_LDO_POS:\n\tcase LM3632_LDO_NEG:\n\t\text_en_mask = LM3632_EXT_EN_MASK;\n\t\tbreak;\n\tcase LM36274_LDO_POS:\n\tcase LM36274_LDO_NEG:\n\t\text_en_mask = LM36274_EXT_EN_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\treturn regmap_update_bits(regmap, lm363x_regulator_desc[id].enable_reg,\n\t\t\t\t ext_en_mask, ext_en_mask);\n}\n\nstatic int lm363x_regulator_probe(struct platform_device *pdev)\n{\n\tstruct ti_lmu *lmu = dev_get_drvdata(pdev->dev.parent);\n\tstruct regmap *regmap = lmu->regmap;\n\tstruct regulator_config cfg = { };\n\tstruct regulator_dev *rdev;\n\tstruct device *dev = &pdev->dev;\n\tint id = pdev->id;\n\tstruct gpio_desc *gpiod;\n\tint ret;\n\n\tcfg.dev = dev;\n\tcfg.regmap = regmap;\n\n\t \n\tgpiod = lm363x_regulator_of_get_enable_gpio(dev, id);\n\tif (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\n\tif (gpiod) {\n\t\tcfg.ena_gpiod = gpiod;\n\t\tret = lm363x_regulator_set_ext_en(regmap, id);\n\t\tif (ret) {\n\t\t\tgpiod_put(gpiod);\n\t\t\tdev_err(dev, \"External pin err: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\trdev = devm_regulator_register(dev, &lm363x_regulator_desc[id], &cfg);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\t\tdev_err(dev, \"[%d] regulator register err: %d\\n\", id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver lm363x_regulator_driver = {\n\t.probe = lm363x_regulator_probe,\n\t.driver = {\n\t\t.name = \"lm363x-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nmodule_platform_driver(lm363x_regulator_driver);\n\nMODULE_DESCRIPTION(\"TI LM363X Regulator Driver\");\nMODULE_AUTHOR(\"Milo Kim\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:lm363x-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}