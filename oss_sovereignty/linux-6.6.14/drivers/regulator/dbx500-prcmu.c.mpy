{
  "module_name": "dbx500-prcmu.c",
  "hash_id": "b657a983c5efcfb88acf57cb05784b4f73093f50f04841864db3c4b7752d2528",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/dbx500-prcmu.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/regulator/driver.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include \"dbx500-prcmu.h\"\n\n \nstatic int power_state_active_cnt;  \nstatic DEFINE_SPINLOCK(power_state_active_lock);\n\nvoid power_state_active_enable(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&power_state_active_lock, flags);\n\tpower_state_active_cnt++;\n\tspin_unlock_irqrestore(&power_state_active_lock, flags);\n}\n\nint power_state_active_disable(void)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&power_state_active_lock, flags);\n\tif (power_state_active_cnt <= 0) {\n\t\tpr_err(\"power state: unbalanced enable/disable calls\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpower_state_active_cnt--;\nout:\n\tspin_unlock_irqrestore(&power_state_active_lock, flags);\n\treturn ret;\n}\n\n#ifdef CONFIG_REGULATOR_DEBUG\n\nstatic int power_state_active_get(void)\n{\n\tunsigned long flags;\n\tint cnt;\n\n\tspin_lock_irqsave(&power_state_active_lock, flags);\n\tcnt = power_state_active_cnt;\n\tspin_unlock_irqrestore(&power_state_active_lock, flags);\n\n\treturn cnt;\n}\n\nstatic struct ux500_regulator_debug {\n\tstruct dentry *dir;\n\tstruct dbx500_regulator_info *regulator_array;\n\tint num_regulators;\n\tu8 *state_before_suspend;\n\tu8 *state_after_suspend;\n} rdebug;\n\nstatic int ux500_regulator_power_state_cnt_show(struct seq_file *s, void *p)\n{\n\t \n\tseq_printf(s, \"ux500-regulator power state count: %i\\n\",\n\t\t   power_state_active_get());\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ux500_regulator_power_state_cnt);\n\nstatic int ux500_regulator_status_show(struct seq_file *s, void *p)\n{\n\tint i;\n\n\t \n\tseq_puts(s, \"ux500-regulator status:\\n\");\n\tseq_printf(s, \"%31s : %8s : %8s\\n\", \"current\", \"before\", \"after\");\n\n\tfor (i = 0; i < rdebug.num_regulators; i++) {\n\t\tstruct dbx500_regulator_info *info;\n\t\t \n\t\tinfo = &rdebug.regulator_array[i];\n\n\t\t \n\t\tseq_printf(s, \"%20s : %8s : %8s : %8s\\n\",\n\t\t\t   info->desc.name,\n\t\t\t   info->is_enabled ? \"enabled\" : \"disabled\",\n\t\t\t   rdebug.state_before_suspend[i] ? \"enabled\" : \"disabled\",\n\t\t\t   rdebug.state_after_suspend[i] ? \"enabled\" : \"disabled\");\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ux500_regulator_status);\n\nint\nux500_regulator_debug_init(struct platform_device *pdev,\n\tstruct dbx500_regulator_info *regulator_info,\n\tint num_regulators)\n{\n\t \n\trdebug.dir = debugfs_create_dir(\"ux500-regulator\", NULL);\n\n\t \n\tdebugfs_create_file(\"status\", 0444, rdebug.dir, &pdev->dev,\n\t\t\t    &ux500_regulator_status_fops);\n\n\t \n\tdebugfs_create_file(\"power-state-count\", 0444, rdebug.dir,\n\t\t\t    &pdev->dev, &ux500_regulator_power_state_cnt_fops);\n\n\trdebug.regulator_array = regulator_info;\n\trdebug.num_regulators = num_regulators;\n\n\trdebug.state_before_suspend = kzalloc(num_regulators, GFP_KERNEL);\n\tif (!rdebug.state_before_suspend)\n\t\tgoto exit_destroy_power_state;\n\n\trdebug.state_after_suspend = kzalloc(num_regulators, GFP_KERNEL);\n\tif (!rdebug.state_after_suspend)\n\t\tgoto exit_free;\n\n\treturn 0;\n\nexit_free:\n\tkfree(rdebug.state_before_suspend);\nexit_destroy_power_state:\n\tdebugfs_remove_recursive(rdebug.dir);\n\treturn -ENOMEM;\n}\n\nint ux500_regulator_debug_exit(void)\n{\n\tdebugfs_remove_recursive(rdebug.dir);\n\tkfree(rdebug.state_after_suspend);\n\tkfree(rdebug.state_before_suspend);\n\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}