{
  "module_name": "twl-regulator.c",
  "hash_id": "5a321340f0197d5faf80f4d48d4e82e3a958385633247b3e55ef63a7a47a97cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/twl-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/mfd/twl.h>\n#include <linux/delay.h>\n\n \n\nstruct twlreg_info {\n\t \n\tu8\t\t\tbase;\n\n\t \n\tu8\t\t\tid;\n\n\t \n\tu8\t\t\ttable_len;\n\tconst u16\t\t*table;\n\n\t \n\tu8\t\t\tremap;\n\n\t \n\tstruct regulator_desc\tdesc;\n\n\t \n\tunsigned long\t\tfeatures;\n\n\t \n\tvoid\t\t\t*data;\n};\n\n\n \n \n#define VREG_GRP\t\t0\n \n#define VREG_TYPE\t\t1\n#define VREG_REMAP\t\t2\n#define VREG_DEDICATED\t\t3\t \n#define VREG_VOLTAGE_SMPS_4030\t9\n \n#define VREG_TRANS\t\t1\n#define VREG_STATE\t\t2\n#define VREG_VOLTAGE\t\t3\n#define VREG_VOLTAGE_SMPS\t4\n\nstatic inline int\ntwlreg_read(struct twlreg_info *info, unsigned slave_subgp, unsigned offset)\n{\n\tu8 value;\n\tint status;\n\n\tstatus = twl_i2c_read_u8(slave_subgp,\n\t\t\t&value, info->base + offset);\n\treturn (status < 0) ? status : value;\n}\n\nstatic inline int\ntwlreg_write(struct twlreg_info *info, unsigned slave_subgp, unsigned offset,\n\t\t\t\t\t\t u8 value)\n{\n\treturn twl_i2c_write_u8(slave_subgp,\n\t\t\tvalue, info->base + offset);\n}\n\n \n\n \n\nstatic int twlreg_grp(struct regulator_dev *rdev)\n{\n\treturn twlreg_read(rdev_get_drvdata(rdev), TWL_MODULE_PM_RECEIVER,\n\t\t\t\t\t\t\t\t VREG_GRP);\n}\n\n \n \n#define P3_GRP_4030\tBIT(7)\t\t \n#define P2_GRP_4030\tBIT(6)\t\t \n#define P1_GRP_4030\tBIT(5)\t\t \n \n#define P3_GRP_6030\tBIT(2)\t\t \n#define P2_GRP_6030\tBIT(1)\t\t \n#define P1_GRP_6030\tBIT(0)\t\t \n\nstatic int twl4030reg_is_enabled(struct regulator_dev *rdev)\n{\n\tint\tstate = twlreg_grp(rdev);\n\n\tif (state < 0)\n\t\treturn state;\n\n\treturn state & P1_GRP_4030;\n}\n\n#define PB_I2C_BUSY\tBIT(0)\n#define PB_I2C_BWEN\tBIT(1)\n\n \nstatic int twl4030_wait_pb_ready(void)\n{\n\n\tint\tret;\n\tint\ttimeout = 10;\n\tu8\tval;\n\n\tdo {\n\t\tret = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &val,\n\t\t\t\t      TWL4030_PM_MASTER_PB_CFG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(val & PB_I2C_BUSY))\n\t\t\treturn 0;\n\n\t\tmdelay(1);\n\t\ttimeout--;\n\t} while (timeout);\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int twl4030_send_pb_msg(unsigned msg)\n{\n\tu8\tval;\n\tint\tret;\n\n\t \n\tret = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &val,\n\t\t\t      TWL4030_PM_MASTER_PB_CFG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, val | PB_I2C_BWEN,\n\t\t\t       TWL4030_PM_MASTER_PB_CFG);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = twl4030_wait_pb_ready();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, msg >> 8,\n\t\t\t       TWL4030_PM_MASTER_PB_WORD_MSB);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, msg & 0xff,\n\t\t\t       TWL4030_PM_MASTER_PB_WORD_LSB);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = twl4030_wait_pb_ready();\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn twl_i2c_write_u8(TWL_MODULE_PM_MASTER, val,\n\t\t\t\tTWL4030_PM_MASTER_PB_CFG);\n}\n\nstatic int twl4030reg_enable(struct regulator_dev *rdev)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\tint\t\t\tgrp;\n\n\tgrp = twlreg_grp(rdev);\n\tif (grp < 0)\n\t\treturn grp;\n\n\tgrp |= P1_GRP_4030;\n\n\treturn twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_GRP, grp);\n}\n\nstatic int twl4030reg_disable(struct regulator_dev *rdev)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\tint\t\t\tgrp;\n\n\tgrp = twlreg_grp(rdev);\n\tif (grp < 0)\n\t\treturn grp;\n\n\tgrp &= ~(P1_GRP_4030 | P2_GRP_4030 | P3_GRP_4030);\n\n\treturn twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_GRP, grp);\n}\n\nstatic int twl4030reg_get_status(struct regulator_dev *rdev)\n{\n\tint\tstate = twlreg_grp(rdev);\n\n\tif (state < 0)\n\t\treturn state;\n\tstate &= 0x0f;\n\n\t \n\tif (!state)\n\t\treturn REGULATOR_STATUS_OFF;\n\treturn (state & BIT(3))\n\t\t? REGULATOR_STATUS_NORMAL\n\t\t: REGULATOR_STATUS_STANDBY;\n}\n\nstatic int twl4030reg_set_mode(struct regulator_dev *rdev, unsigned mode)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\tunsigned\t\tmessage;\n\n\t \n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tmessage = MSG_SINGULAR(DEV_GRP_P1, info->id, RES_STATE_ACTIVE);\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tmessage = MSG_SINGULAR(DEV_GRP_P1, info->id, RES_STATE_SLEEP);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn twl4030_send_pb_msg(message);\n}\n\nstatic inline unsigned int twl4030reg_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase RES_STATE_ACTIVE:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase RES_STATE_SLEEP:\n\t\treturn REGULATOR_MODE_STANDBY;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\n \n\n \n#define UNSUP_MASK\t0x8000\n\n#define UNSUP(x)\t(UNSUP_MASK | (x))\n#define IS_UNSUP(info, x)\t\t\t\\\n\t((UNSUP_MASK & (x)) &&\t\t\t\\\n\t !((info)->features & TWL4030_ALLOW_UNSUPPORTED))\n#define LDO_MV(x)\t(~UNSUP_MASK & (x))\n\n\nstatic const u16 VAUX1_VSEL_table[] = {\n\tUNSUP(1500), UNSUP(1800), 2500, 2800,\n\t3000, 3000, 3000, 3000,\n};\nstatic const u16 VAUX2_4030_VSEL_table[] = {\n\tUNSUP(1000), UNSUP(1000), UNSUP(1200), 1300,\n\t1500, 1800, UNSUP(1850), 2500,\n\tUNSUP(2600), 2800, UNSUP(2850), UNSUP(3000),\n\tUNSUP(3150), UNSUP(3150), UNSUP(3150), UNSUP(3150),\n};\nstatic const u16 VAUX2_VSEL_table[] = {\n\t1700, 1700, 1900, 1300,\n\t1500, 1800, 2000, 2500,\n\t2100, 2800, 2200, 2300,\n\t2400, 2400, 2400, 2400,\n};\nstatic const u16 VAUX3_VSEL_table[] = {\n\t1500, 1800, 2500, 2800,\n\t3000, 3000, 3000, 3000,\n};\nstatic const u16 VAUX4_VSEL_table[] = {\n\t700, 1000, 1200, UNSUP(1300),\n\t1500, 1800, UNSUP(1850), 2500,\n\tUNSUP(2600), 2800, UNSUP(2850), UNSUP(3000),\n\tUNSUP(3150), UNSUP(3150), UNSUP(3150), UNSUP(3150),\n};\nstatic const u16 VMMC1_VSEL_table[] = {\n\t1850, 2850, 3000, 3150,\n};\nstatic const u16 VMMC2_VSEL_table[] = {\n\tUNSUP(1000), UNSUP(1000), UNSUP(1200), UNSUP(1300),\n\tUNSUP(1500), UNSUP(1800), 1850, UNSUP(2500),\n\t2600, 2800, 2850, 3000,\n\t3150, 3150, 3150, 3150,\n};\nstatic const u16 VPLL1_VSEL_table[] = {\n\t1000, 1200, 1300, 1800,\n\tUNSUP(2800), UNSUP(3000), UNSUP(3000), UNSUP(3000),\n};\nstatic const u16 VPLL2_VSEL_table[] = {\n\t700, 1000, 1200, 1300,\n\tUNSUP(1500), 1800, UNSUP(1850), UNSUP(2500),\n\tUNSUP(2600), UNSUP(2800), UNSUP(2850), UNSUP(3000),\n\tUNSUP(3150), UNSUP(3150), UNSUP(3150), UNSUP(3150),\n};\nstatic const u16 VSIM_VSEL_table[] = {\n\tUNSUP(1000), UNSUP(1200), UNSUP(1300), 1800,\n\t2800, 3000, 3000, 3000,\n};\nstatic const u16 VDAC_VSEL_table[] = {\n\t1200, 1300, 1800, 1800,\n};\nstatic const u16 VIO_VSEL_table[] = {\n\t1800, 1850,\n};\nstatic const u16 VINTANA2_VSEL_table[] = {\n\t2500, 2750,\n};\n\n \nstatic const struct linear_range VDD1_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(600000, 0, 68, 12500)\n};\n\n \nstatic const struct linear_range VDD2_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(600000, 0, 68, 12500),\n\tREGULATOR_LINEAR_RANGE(1500000, 69, 69, 12500)\n};\n\nstatic int twl4030ldo_list_voltage(struct regulator_dev *rdev, unsigned index)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\tint\t\t\tmV = info->table[index];\n\n\treturn IS_UNSUP(info, mV) ? 0 : (LDO_MV(mV) * 1000);\n}\n\nstatic int\ntwl4030ldo_set_voltage_sel(struct regulator_dev *rdev, unsigned selector)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\n\treturn twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE,\n\t\t\t    selector);\n}\n\nstatic int twl4030ldo_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\tint vsel = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE);\n\n\tif (vsel < 0)\n\t\treturn vsel;\n\n\tvsel &= info->table_len - 1;\n\treturn vsel;\n}\n\nstatic const struct regulator_ops twl4030ldo_ops = {\n\t.list_voltage\t= twl4030ldo_list_voltage,\n\n\t.set_voltage_sel = twl4030ldo_set_voltage_sel,\n\t.get_voltage_sel = twl4030ldo_get_voltage_sel,\n\n\t.enable\t\t= twl4030reg_enable,\n\t.disable\t= twl4030reg_disable,\n\t.is_enabled\t= twl4030reg_is_enabled,\n\n\t.set_mode\t= twl4030reg_set_mode,\n\n\t.get_status\t= twl4030reg_get_status,\n};\n\nstatic int\ntwl4030smps_set_voltage(struct regulator_dev *rdev, int min_uV, int max_uV,\n\t\t\tunsigned *selector)\n{\n\tstruct twlreg_info *info = rdev_get_drvdata(rdev);\n\tint vsel = DIV_ROUND_UP(min_uV - 600000, 12500);\n\n\ttwlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE_SMPS_4030, vsel);\n\n\treturn 0;\n}\n\nstatic int twl4030smps_get_voltage(struct regulator_dev *rdev)\n{\n\tstruct twlreg_info *info = rdev_get_drvdata(rdev);\n\tint vsel;\n\n\tvsel = twlreg_read(info, TWL_MODULE_PM_RECEIVER,\n\t\tVREG_VOLTAGE_SMPS_4030);\n\n\treturn vsel * 12500 + 600000;\n}\n\nstatic const struct regulator_ops twl4030smps_ops = {\n\t.list_voltage   = regulator_list_voltage_linear_range,\n\n\t.set_voltage\t= twl4030smps_set_voltage,\n\t.get_voltage\t= twl4030smps_get_voltage,\n};\n\n \n\nstatic const struct regulator_ops twl4030fixed_ops = {\n\t.list_voltage\t= regulator_list_voltage_linear,\n\n\t.enable\t\t= twl4030reg_enable,\n\t.disable\t= twl4030reg_disable,\n\t.is_enabled\t= twl4030reg_is_enabled,\n\n\t.set_mode\t= twl4030reg_set_mode,\n\n\t.get_status\t= twl4030reg_get_status,\n};\n\n \n\n#define TWL4030_ADJUSTABLE_LDO(label, offset, num, turnon_delay, remap_conf) \\\nstatic const struct twlreg_info TWL4030_INFO_##label = { \\\n\t.base = offset, \\\n\t.id = num, \\\n\t.table_len = ARRAY_SIZE(label##_VSEL_table), \\\n\t.table = label##_VSEL_table, \\\n\t.remap = remap_conf, \\\n\t.desc = { \\\n\t\t.name = #label, \\\n\t\t.id = TWL4030_REG_##label, \\\n\t\t.n_voltages = ARRAY_SIZE(label##_VSEL_table), \\\n\t\t.ops = &twl4030ldo_ops, \\\n\t\t.type = REGULATOR_VOLTAGE, \\\n\t\t.owner = THIS_MODULE, \\\n\t\t.enable_time = turnon_delay, \\\n\t\t.of_map_mode = twl4030reg_map_mode, \\\n\t\t}, \\\n\t}\n\n#define TWL4030_ADJUSTABLE_SMPS(label, offset, num, turnon_delay, remap_conf, \\\n\t\tn_volt) \\\nstatic const struct twlreg_info TWL4030_INFO_##label = { \\\n\t.base = offset, \\\n\t.id = num, \\\n\t.remap = remap_conf, \\\n\t.desc = { \\\n\t\t.name = #label, \\\n\t\t.id = TWL4030_REG_##label, \\\n\t\t.ops = &twl4030smps_ops, \\\n\t\t.type = REGULATOR_VOLTAGE, \\\n\t\t.owner = THIS_MODULE, \\\n\t\t.enable_time = turnon_delay, \\\n\t\t.of_map_mode = twl4030reg_map_mode, \\\n\t\t.n_voltages = n_volt, \\\n\t\t.n_linear_ranges = ARRAY_SIZE(label ## _ranges), \\\n\t\t.linear_ranges = label ## _ranges, \\\n\t\t}, \\\n\t}\n\n#define TWL4030_FIXED_LDO(label, offset, mVolts, num, turnon_delay, \\\n\t\t\tremap_conf) \\\nstatic const struct twlreg_info TWLFIXED_INFO_##label = { \\\n\t.base = offset, \\\n\t.id = num, \\\n\t.remap = remap_conf, \\\n\t.desc = { \\\n\t\t.name = #label, \\\n\t\t.id = TWL4030##_REG_##label, \\\n\t\t.n_voltages = 1, \\\n\t\t.ops = &twl4030fixed_ops, \\\n\t\t.type = REGULATOR_VOLTAGE, \\\n\t\t.owner = THIS_MODULE, \\\n\t\t.min_uV = mVolts * 1000, \\\n\t\t.enable_time = turnon_delay, \\\n\t\t.of_map_mode = twl4030reg_map_mode, \\\n\t\t}, \\\n\t}\n\n \nTWL4030_ADJUSTABLE_LDO(VAUX1, 0x17, 1, 100, 0x08);\nTWL4030_ADJUSTABLE_LDO(VAUX2_4030, 0x1b, 2, 100, 0x08);\nTWL4030_ADJUSTABLE_LDO(VAUX2, 0x1b, 2, 100, 0x08);\nTWL4030_ADJUSTABLE_LDO(VAUX3, 0x1f, 3, 100, 0x08);\nTWL4030_ADJUSTABLE_LDO(VAUX4, 0x23, 4, 100, 0x08);\nTWL4030_ADJUSTABLE_LDO(VMMC1, 0x27, 5, 100, 0x08);\nTWL4030_ADJUSTABLE_LDO(VMMC2, 0x2b, 6, 100, 0x08);\nTWL4030_ADJUSTABLE_LDO(VPLL1, 0x2f, 7, 100, 0x00);\nTWL4030_ADJUSTABLE_LDO(VPLL2, 0x33, 8, 100, 0x08);\nTWL4030_ADJUSTABLE_LDO(VSIM, 0x37, 9, 100, 0x00);\nTWL4030_ADJUSTABLE_LDO(VDAC, 0x3b, 10, 100, 0x08);\nTWL4030_ADJUSTABLE_LDO(VINTANA2, 0x43, 12, 100, 0x08);\nTWL4030_ADJUSTABLE_LDO(VIO, 0x4b, 14, 1000, 0x08);\nTWL4030_ADJUSTABLE_SMPS(VDD1, 0x55, 15, 1000, 0x08, 68);\nTWL4030_ADJUSTABLE_SMPS(VDD2, 0x63, 16, 1000, 0x08, 69);\n \nTWL4030_FIXED_LDO(VINTANA1, 0x3f, 1500, 11, 100, 0x08);\nTWL4030_FIXED_LDO(VINTDIG, 0x47, 1500, 13, 100, 0x08);\nTWL4030_FIXED_LDO(VUSB1V5, 0x71, 1500, 17, 100, 0x08);\nTWL4030_FIXED_LDO(VUSB1V8, 0x74, 1800, 18, 100, 0x08);\nTWL4030_FIXED_LDO(VUSB3V1, 0x77, 3100, 19, 150, 0x08);\n\n#define TWL_OF_MATCH(comp, family, label) \\\n\t{ \\\n\t\t.compatible = comp, \\\n\t\t.data = &family##_INFO_##label, \\\n\t}\n\n#define TWL4030_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWL4030, label)\n#define TWL6030_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWL6030, label)\n#define TWL6032_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWL6032, label)\n#define TWLFIXED_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWLFIXED, label)\n#define TWLSMPS_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWLSMPS, label)\n\nstatic const struct of_device_id twl_of_match[] = {\n\tTWL4030_OF_MATCH(\"ti,twl4030-vaux1\", VAUX1),\n\tTWL4030_OF_MATCH(\"ti,twl4030-vaux2\", VAUX2_4030),\n\tTWL4030_OF_MATCH(\"ti,twl5030-vaux2\", VAUX2),\n\tTWL4030_OF_MATCH(\"ti,twl4030-vaux3\", VAUX3),\n\tTWL4030_OF_MATCH(\"ti,twl4030-vaux4\", VAUX4),\n\tTWL4030_OF_MATCH(\"ti,twl4030-vmmc1\", VMMC1),\n\tTWL4030_OF_MATCH(\"ti,twl4030-vmmc2\", VMMC2),\n\tTWL4030_OF_MATCH(\"ti,twl4030-vpll1\", VPLL1),\n\tTWL4030_OF_MATCH(\"ti,twl4030-vpll2\", VPLL2),\n\tTWL4030_OF_MATCH(\"ti,twl4030-vsim\", VSIM),\n\tTWL4030_OF_MATCH(\"ti,twl4030-vdac\", VDAC),\n\tTWL4030_OF_MATCH(\"ti,twl4030-vintana2\", VINTANA2),\n\tTWL4030_OF_MATCH(\"ti,twl4030-vio\", VIO),\n\tTWL4030_OF_MATCH(\"ti,twl4030-vdd1\", VDD1),\n\tTWL4030_OF_MATCH(\"ti,twl4030-vdd2\", VDD2),\n\tTWLFIXED_OF_MATCH(\"ti,twl4030-vintana1\", VINTANA1),\n\tTWLFIXED_OF_MATCH(\"ti,twl4030-vintdig\", VINTDIG),\n\tTWLFIXED_OF_MATCH(\"ti,twl4030-vusb1v5\", VUSB1V5),\n\tTWLFIXED_OF_MATCH(\"ti,twl4030-vusb1v8\", VUSB1V8),\n\tTWLFIXED_OF_MATCH(\"ti,twl4030-vusb3v1\", VUSB3V1),\n\t{},\n};\nMODULE_DEVICE_TABLE(of, twl_of_match);\n\nstatic int twlreg_probe(struct platform_device *pdev)\n{\n\tint id;\n\tstruct twlreg_info\t\t*info;\n\tconst struct twlreg_info\t*template;\n\tstruct regulator_init_data\t*initdata;\n\tstruct regulation_constraints\t*c;\n\tstruct regulator_dev\t\t*rdev;\n\tstruct regulator_config\t\tconfig = { };\n\n\ttemplate = of_device_get_match_data(&pdev->dev);\n\tif (!template)\n\t\treturn -ENODEV;\n\n\tid = template->desc.id;\n\tinitdata = of_get_regulator_init_data(&pdev->dev, pdev->dev.of_node,\n\t\t\t\t\t\t&template->desc);\n\tif (!initdata)\n\t\treturn -EINVAL;\n\n\tinfo = devm_kmemdup(&pdev->dev, template, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\t \n\tc = &initdata->constraints;\n\tc->valid_modes_mask &= REGULATOR_MODE_NORMAL | REGULATOR_MODE_STANDBY;\n\tc->valid_ops_mask &= REGULATOR_CHANGE_VOLTAGE\n\t\t\t\t| REGULATOR_CHANGE_MODE\n\t\t\t\t| REGULATOR_CHANGE_STATUS;\n\tswitch (id) {\n\tcase TWL4030_REG_VIO:\n\tcase TWL4030_REG_VDD1:\n\tcase TWL4030_REG_VDD2:\n\tcase TWL4030_REG_VPLL1:\n\tcase TWL4030_REG_VINTANA1:\n\tcase TWL4030_REG_VINTANA2:\n\tcase TWL4030_REG_VINTDIG:\n\t\tc->always_on = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tconfig.dev = &pdev->dev;\n\tconfig.init_data = initdata;\n\tconfig.driver_data = info;\n\tconfig.of_node = pdev->dev.of_node;\n\n\trdev = devm_regulator_register(&pdev->dev, &info->desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(&pdev->dev, \"can't register %s, %ld\\n\",\n\t\t\t\tinfo->desc.name, PTR_ERR(rdev));\n\t\treturn PTR_ERR(rdev);\n\t}\n\tplatform_set_drvdata(pdev, rdev);\n\n\ttwlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_REMAP, info->remap);\n\n\t \n\n\treturn 0;\n}\n\nMODULE_ALIAS(\"platform:twl4030_reg\");\n\nstatic struct platform_driver twlreg_driver = {\n\t.probe\t\t= twlreg_probe,\n\t \n\t.driver  = {\n\t\t.name  = \"twl4030_reg\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(twl_of_match),\n\t},\n};\n\nstatic int __init twlreg_init(void)\n{\n\treturn platform_driver_register(&twlreg_driver);\n}\nsubsys_initcall(twlreg_init);\n\nstatic void __exit twlreg_exit(void)\n{\n\tplatform_driver_unregister(&twlreg_driver);\n}\nmodule_exit(twlreg_exit)\n\nMODULE_DESCRIPTION(\"TWL4030 regulator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}