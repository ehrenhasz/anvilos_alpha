{
  "module_name": "helpers.c",
  "hash_id": "edfc195b2356acfcef8485ccc0ab59f547215daf2e287621471fb61893969976",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/helpers.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regulator/driver.h>\n\n#include \"internal.h\"\n\n \nint regulator_is_enabled_regmap(struct regulator_dev *rdev)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(rdev->regmap, rdev->desc->enable_reg, &val);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tval &= rdev->desc->enable_mask;\n\n\tif (rdev->desc->enable_is_inverted) {\n\t\tif (rdev->desc->enable_val)\n\t\t\treturn val != rdev->desc->enable_val;\n\t\treturn val == 0;\n\t} else {\n\t\tif (rdev->desc->enable_val)\n\t\t\treturn val == rdev->desc->enable_val;\n\t\treturn val != 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(regulator_is_enabled_regmap);\n\n \nint regulator_enable_regmap(struct regulator_dev *rdev)\n{\n\tunsigned int val;\n\n\tif (rdev->desc->enable_is_inverted) {\n\t\tval = rdev->desc->disable_val;\n\t} else {\n\t\tval = rdev->desc->enable_val;\n\t\tif (!val)\n\t\t\tval = rdev->desc->enable_mask;\n\t}\n\n\treturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\n\t\t\t\t  rdev->desc->enable_mask, val);\n}\nEXPORT_SYMBOL_GPL(regulator_enable_regmap);\n\n \nint regulator_disable_regmap(struct regulator_dev *rdev)\n{\n\tunsigned int val;\n\n\tif (rdev->desc->enable_is_inverted) {\n\t\tval = rdev->desc->enable_val;\n\t\tif (!val)\n\t\t\tval = rdev->desc->enable_mask;\n\t} else {\n\t\tval = rdev->desc->disable_val;\n\t}\n\n\treturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\n\t\t\t\t  rdev->desc->enable_mask, val);\n}\nEXPORT_SYMBOL_GPL(regulator_disable_regmap);\n\nstatic int regulator_range_selector_to_index(struct regulator_dev *rdev,\n\t\t\t\t\t     unsigned int rval)\n{\n\tint i;\n\n\tif (!rdev->desc->linear_range_selectors_bitfield)\n\t\treturn -EINVAL;\n\n\trval &= rdev->desc->vsel_range_mask;\n\trval >>= ffs(rdev->desc->vsel_range_mask) - 1;\n\n\tfor (i = 0; i < rdev->desc->n_linear_ranges; i++) {\n\t\tif (rdev->desc->linear_range_selectors_bitfield[i] == rval)\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\n \nint regulator_get_voltage_sel_pickable_regmap(struct regulator_dev *rdev)\n{\n\tunsigned int r_val;\n\tint range;\n\tunsigned int val;\n\tint ret;\n\tunsigned int voltages = 0;\n\tconst struct linear_range *r = rdev->desc->linear_ranges;\n\n\tif (!r)\n\t\treturn -EINVAL;\n\n\tret = regmap_read(rdev->regmap, rdev->desc->vsel_reg, &val);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = regmap_read(rdev->regmap, rdev->desc->vsel_range_reg, &r_val);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tval &= rdev->desc->vsel_mask;\n\tval >>= ffs(rdev->desc->vsel_mask) - 1;\n\n\trange = regulator_range_selector_to_index(rdev, r_val);\n\tif (range < 0)\n\t\treturn -EINVAL;\n\n\tvoltages = linear_range_values_in_range_array(r, range);\n\n\treturn val + voltages;\n}\nEXPORT_SYMBOL_GPL(regulator_get_voltage_sel_pickable_regmap);\n\n \nint regulator_set_voltage_sel_pickable_regmap(struct regulator_dev *rdev,\n\t\t\t\t\t      unsigned int sel)\n{\n\tunsigned int range;\n\tint ret, i;\n\tunsigned int voltages_in_range = 0;\n\n\tfor (i = 0; i < rdev->desc->n_linear_ranges; i++) {\n\t\tconst struct linear_range *r;\n\n\t\tr = &rdev->desc->linear_ranges[i];\n\t\tvoltages_in_range = linear_range_values_in_range(r);\n\n\t\tif (sel < voltages_in_range)\n\t\t\tbreak;\n\t\tsel -= voltages_in_range;\n\t}\n\n\tif (i == rdev->desc->n_linear_ranges)\n\t\treturn -EINVAL;\n\n\tsel <<= ffs(rdev->desc->vsel_mask) - 1;\n\tsel += rdev->desc->linear_ranges[i].min_sel;\n\n\trange = rdev->desc->linear_range_selectors_bitfield[i];\n\trange <<= ffs(rdev->desc->vsel_range_mask) - 1;\n\n\tif (rdev->desc->vsel_reg == rdev->desc->vsel_range_reg) {\n\t\tret = regmap_update_bits(rdev->regmap,\n\t\t\t\t\t rdev->desc->vsel_reg,\n\t\t\t\t\t rdev->desc->vsel_range_mask |\n\t\t\t\t\t rdev->desc->vsel_mask, sel | range);\n\t} else {\n\t\tret = regmap_update_bits(rdev->regmap,\n\t\t\t\t\t rdev->desc->vsel_range_reg,\n\t\t\t\t\t rdev->desc->vsel_range_mask, range);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(rdev->regmap, rdev->desc->vsel_reg,\n\t\t\t\t  rdev->desc->vsel_mask, sel);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (rdev->desc->apply_bit)\n\t\tret = regmap_update_bits(rdev->regmap, rdev->desc->apply_reg,\n\t\t\t\t\t rdev->desc->apply_bit,\n\t\t\t\t\t rdev->desc->apply_bit);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_voltage_sel_pickable_regmap);\n\n \nint regulator_get_voltage_sel_regmap(struct regulator_dev *rdev)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(rdev->regmap, rdev->desc->vsel_reg, &val);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tval &= rdev->desc->vsel_mask;\n\tval >>= ffs(rdev->desc->vsel_mask) - 1;\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(regulator_get_voltage_sel_regmap);\n\n \nint regulator_set_voltage_sel_regmap(struct regulator_dev *rdev, unsigned sel)\n{\n\tint ret;\n\n\tsel <<= ffs(rdev->desc->vsel_mask) - 1;\n\n\tret = regmap_update_bits(rdev->regmap, rdev->desc->vsel_reg,\n\t\t\t\t  rdev->desc->vsel_mask, sel);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rdev->desc->apply_bit)\n\t\tret = regmap_update_bits(rdev->regmap, rdev->desc->apply_reg,\n\t\t\t\t\t rdev->desc->apply_bit,\n\t\t\t\t\t rdev->desc->apply_bit);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_voltage_sel_regmap);\n\n \nint regulator_map_voltage_iterate(struct regulator_dev *rdev,\n\t\t\t\t  int min_uV, int max_uV)\n{\n\tint best_val = INT_MAX;\n\tint selector = 0;\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < rdev->desc->n_voltages; i++) {\n\t\tret = rdev->desc->ops->list_voltage(rdev, i);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tif (ret < best_val && ret >= min_uV && ret <= max_uV) {\n\t\t\tbest_val = ret;\n\t\t\tselector = i;\n\t\t}\n\t}\n\n\tif (best_val != INT_MAX)\n\t\treturn selector;\n\telse\n\t\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(regulator_map_voltage_iterate);\n\n \nint regulator_map_voltage_ascend(struct regulator_dev *rdev,\n\t\t\t\t int min_uV, int max_uV)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < rdev->desc->n_voltages; i++) {\n\t\tret = rdev->desc->ops->list_voltage(rdev, i);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tif (ret > max_uV)\n\t\t\tbreak;\n\n\t\tif (ret >= min_uV && ret <= max_uV)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(regulator_map_voltage_ascend);\n\n \nint regulator_map_voltage_linear(struct regulator_dev *rdev,\n\t\t\t\t int min_uV, int max_uV)\n{\n\tint ret, voltage;\n\n\t \n\tif (rdev->desc->n_voltages == 1 && rdev->desc->uV_step == 0) {\n\t\tif (min_uV <= rdev->desc->min_uV && rdev->desc->min_uV <= max_uV)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->desc->uV_step) {\n\t\tBUG_ON(!rdev->desc->uV_step);\n\t\treturn -EINVAL;\n\t}\n\n\tif (min_uV < rdev->desc->min_uV)\n\t\tmin_uV = rdev->desc->min_uV;\n\n\tret = DIV_ROUND_UP(min_uV - rdev->desc->min_uV, rdev->desc->uV_step);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret += rdev->desc->linear_min_sel;\n\n\t \n\tvoltage = rdev->desc->ops->list_voltage(rdev, ret);\n\tif (voltage < min_uV || voltage > max_uV)\n\t\treturn -EINVAL;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_map_voltage_linear);\n\n \nint regulator_map_voltage_linear_range(struct regulator_dev *rdev,\n\t\t\t\t       int min_uV, int max_uV)\n{\n\tconst struct linear_range *range;\n\tint ret = -EINVAL;\n\tunsigned int sel;\n\tbool found;\n\tint voltage, i;\n\n\tif (!rdev->desc->n_linear_ranges) {\n\t\tBUG_ON(!rdev->desc->n_linear_ranges);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < rdev->desc->n_linear_ranges; i++) {\n\t\trange = &rdev->desc->linear_ranges[i];\n\n\t\tret = linear_range_get_selector_high(range, min_uV, &sel,\n\t\t\t\t\t\t     &found);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tret = sel;\n\n\t\t \n\t\tvoltage = rdev->desc->ops->list_voltage(rdev, sel);\n\t\tif (voltage >= min_uV && voltage <= max_uV)\n\t\t\tbreak;\n\t}\n\n\tif (i == rdev->desc->n_linear_ranges)\n\t\treturn -EINVAL;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_map_voltage_linear_range);\n\n \nint regulator_map_voltage_pickable_linear_range(struct regulator_dev *rdev,\n\t\t\t\t\t\tint min_uV, int max_uV)\n{\n\tconst struct linear_range *range;\n\tint ret = -EINVAL;\n\tint voltage, i;\n\tunsigned int selector = 0;\n\n\tif (!rdev->desc->n_linear_ranges) {\n\t\tBUG_ON(!rdev->desc->n_linear_ranges);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < rdev->desc->n_linear_ranges; i++) {\n\t\tint linear_max_uV;\n\t\tbool found;\n\t\tunsigned int sel;\n\n\t\trange = &rdev->desc->linear_ranges[i];\n\t\tlinear_max_uV = linear_range_get_max_value(range);\n\n\t\tif (!(min_uV <= linear_max_uV && max_uV >= range->min)) {\n\t\t\tselector += linear_range_values_in_range(range);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = linear_range_get_selector_high(range, min_uV, &sel,\n\t\t\t\t\t\t     &found);\n\t\tif (ret) {\n\t\t\tselector += linear_range_values_in_range(range);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = selector + sel - range->min_sel;\n\n\t\tvoltage = rdev->desc->ops->list_voltage(rdev, ret);\n\n\t\t \n\t\tif (voltage < min_uV || voltage > max_uV)\n\t\t\tselector += linear_range_values_in_range(range);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (i == rdev->desc->n_linear_ranges)\n\t\treturn -EINVAL;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_map_voltage_pickable_linear_range);\n\n \nint regulator_desc_list_voltage_linear(const struct regulator_desc *desc,\n\t\t\t\t       unsigned int selector)\n{\n\tif (selector >= desc->n_voltages)\n\t\treturn -EINVAL;\n\n\tif (selector < desc->linear_min_sel)\n\t\treturn 0;\n\n\tselector -= desc->linear_min_sel;\n\n\treturn desc->min_uV + (desc->uV_step * selector);\n}\nEXPORT_SYMBOL_GPL(regulator_desc_list_voltage_linear);\n\n \nint regulator_list_voltage_linear(struct regulator_dev *rdev,\n\t\t\t\t  unsigned int selector)\n{\n\treturn regulator_desc_list_voltage_linear(rdev->desc, selector);\n}\nEXPORT_SYMBOL_GPL(regulator_list_voltage_linear);\n\n \nint regulator_list_voltage_pickable_linear_range(struct regulator_dev *rdev,\n\t\t\t\t\t\t unsigned int selector)\n{\n\tconst struct linear_range *range;\n\tint i;\n\tunsigned int all_sels = 0;\n\n\tif (!rdev->desc->n_linear_ranges) {\n\t\tBUG_ON(!rdev->desc->n_linear_ranges);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < rdev->desc->n_linear_ranges; i++) {\n\t\tunsigned int sel_indexes;\n\n\t\trange = &rdev->desc->linear_ranges[i];\n\n\t\tsel_indexes = linear_range_values_in_range(range) - 1;\n\n\t\tif (all_sels + sel_indexes >= selector) {\n\t\t\tselector -= all_sels;\n\t\t\t \n\t\t\treturn range->min + (range->step * selector);\n\t\t}\n\n\t\tall_sels += (sel_indexes + 1);\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(regulator_list_voltage_pickable_linear_range);\n\n \nint regulator_desc_list_voltage_linear_range(const struct regulator_desc *desc,\n\t\t\t\t\t     unsigned int selector)\n{\n\tunsigned int val;\n\tint ret;\n\n\tBUG_ON(!desc->n_linear_ranges);\n\n\tret = linear_range_get_value_array(desc->linear_ranges,\n\t\t\t\t\t   desc->n_linear_ranges, selector,\n\t\t\t\t\t   &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(regulator_desc_list_voltage_linear_range);\n\n \nint regulator_list_voltage_linear_range(struct regulator_dev *rdev,\n\t\t\t\t\tunsigned int selector)\n{\n\treturn regulator_desc_list_voltage_linear_range(rdev->desc, selector);\n}\nEXPORT_SYMBOL_GPL(regulator_list_voltage_linear_range);\n\n \nint regulator_list_voltage_table(struct regulator_dev *rdev,\n\t\t\t\t unsigned int selector)\n{\n\tif (!rdev->desc->volt_table) {\n\t\tBUG_ON(!rdev->desc->volt_table);\n\t\treturn -EINVAL;\n\t}\n\n\tif (selector >= rdev->desc->n_voltages)\n\t\treturn -EINVAL;\n\tif (selector < rdev->desc->linear_min_sel)\n\t\treturn 0;\n\n\treturn rdev->desc->volt_table[selector];\n}\nEXPORT_SYMBOL_GPL(regulator_list_voltage_table);\n\n \nint regulator_set_bypass_regmap(struct regulator_dev *rdev, bool enable)\n{\n\tunsigned int val;\n\n\tif (enable) {\n\t\tval = rdev->desc->bypass_val_on;\n\t\tif (!val)\n\t\t\tval = rdev->desc->bypass_mask;\n\t} else {\n\t\tval = rdev->desc->bypass_val_off;\n\t}\n\n\treturn regmap_update_bits(rdev->regmap, rdev->desc->bypass_reg,\n\t\t\t\t  rdev->desc->bypass_mask, val);\n}\nEXPORT_SYMBOL_GPL(regulator_set_bypass_regmap);\n\n \nint regulator_set_soft_start_regmap(struct regulator_dev *rdev)\n{\n\tunsigned int val;\n\n\tval = rdev->desc->soft_start_val_on;\n\tif (!val)\n\t\tval = rdev->desc->soft_start_mask;\n\n\treturn regmap_update_bits(rdev->regmap, rdev->desc->soft_start_reg,\n\t\t\t\t  rdev->desc->soft_start_mask, val);\n}\nEXPORT_SYMBOL_GPL(regulator_set_soft_start_regmap);\n\n \nint regulator_set_pull_down_regmap(struct regulator_dev *rdev)\n{\n\tunsigned int val;\n\n\tval = rdev->desc->pull_down_val_on;\n\tif (!val)\n\t\tval = rdev->desc->pull_down_mask;\n\n\treturn regmap_update_bits(rdev->regmap, rdev->desc->pull_down_reg,\n\t\t\t\t  rdev->desc->pull_down_mask, val);\n}\nEXPORT_SYMBOL_GPL(regulator_set_pull_down_regmap);\n\n \nint regulator_get_bypass_regmap(struct regulator_dev *rdev, bool *enable)\n{\n\tunsigned int val;\n\tunsigned int val_on = rdev->desc->bypass_val_on;\n\tint ret;\n\n\tret = regmap_read(rdev->regmap, rdev->desc->bypass_reg, &val);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (!val_on)\n\t\tval_on = rdev->desc->bypass_mask;\n\n\t*enable = (val & rdev->desc->bypass_mask) == val_on;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_get_bypass_regmap);\n\n \nint regulator_set_active_discharge_regmap(struct regulator_dev *rdev,\n\t\t\t\t\t  bool enable)\n{\n\tunsigned int val;\n\n\tif (enable)\n\t\tval = rdev->desc->active_discharge_on;\n\telse\n\t\tval = rdev->desc->active_discharge_off;\n\n\treturn regmap_update_bits(rdev->regmap,\n\t\t\t\t  rdev->desc->active_discharge_reg,\n\t\t\t\t  rdev->desc->active_discharge_mask, val);\n}\nEXPORT_SYMBOL_GPL(regulator_set_active_discharge_regmap);\n\n \nint regulator_set_current_limit_regmap(struct regulator_dev *rdev,\n\t\t\t\t       int min_uA, int max_uA)\n{\n\tunsigned int n_currents = rdev->desc->n_current_limits;\n\tint i, sel = -1;\n\n\tif (n_currents == 0)\n\t\treturn -EINVAL;\n\n\tif (rdev->desc->curr_table) {\n\t\tconst unsigned int *curr_table = rdev->desc->curr_table;\n\t\tbool ascend = curr_table[n_currents - 1] > curr_table[0];\n\n\t\t \n\t\tif (ascend) {\n\t\t\tfor (i = n_currents - 1; i >= 0; i--) {\n\t\t\t\tif (min_uA <= curr_table[i] &&\n\t\t\t\t    curr_table[i] <= max_uA) {\n\t\t\t\t\tsel = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < n_currents; i++) {\n\t\t\t\tif (min_uA <= curr_table[i] &&\n\t\t\t\t    curr_table[i] <= max_uA) {\n\t\t\t\t\tsel = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sel < 0)\n\t\treturn -EINVAL;\n\n\tsel <<= ffs(rdev->desc->csel_mask) - 1;\n\n\treturn regmap_update_bits(rdev->regmap, rdev->desc->csel_reg,\n\t\t\t\t  rdev->desc->csel_mask, sel);\n}\nEXPORT_SYMBOL_GPL(regulator_set_current_limit_regmap);\n\n \nint regulator_get_current_limit_regmap(struct regulator_dev *rdev)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(rdev->regmap, rdev->desc->csel_reg, &val);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tval &= rdev->desc->csel_mask;\n\tval >>= ffs(rdev->desc->csel_mask) - 1;\n\n\tif (rdev->desc->curr_table) {\n\t\tif (val >= rdev->desc->n_current_limits)\n\t\t\treturn -EINVAL;\n\n\t\treturn rdev->desc->curr_table[val];\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(regulator_get_current_limit_regmap);\n\n \nvoid regulator_bulk_set_supply_names(struct regulator_bulk_data *consumers,\n\t\t\t\t     const char *const *supply_names,\n\t\t\t\t     unsigned int num_supplies)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < num_supplies; i++)\n\t\tconsumers[i].supply = supply_names[i];\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_set_supply_names);\n\n \nbool regulator_is_equal(struct regulator *reg1, struct regulator *reg2)\n{\n\treturn reg1->rdev == reg2->rdev;\n}\nEXPORT_SYMBOL_GPL(regulator_is_equal);\n\n \nint regulator_find_closest_bigger(unsigned int target, const unsigned int *table,\n\t\t\t\t  unsigned int num_sel, unsigned int *sel)\n{\n\tunsigned int s, tmp, max, maxsel = 0;\n\tbool found = false;\n\n\tmax = table[0];\n\n\tfor (s = 0; s < num_sel; s++) {\n\t\tif (table[s] > max) {\n\t\t\tmax = table[s];\n\t\t\tmaxsel = s;\n\t\t}\n\t\tif (table[s] >= target) {\n\t\t\tif (!found || table[s] - target < tmp - target) {\n\t\t\t\ttmp = table[s];\n\t\t\t\t*sel = s;\n\t\t\t\tfound = true;\n\t\t\t\tif (tmp == target)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!found) {\n\t\t*sel = maxsel;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_find_closest_bigger);\n\n \nint regulator_set_ramp_delay_regmap(struct regulator_dev *rdev, int ramp_delay)\n{\n\tint ret;\n\tunsigned int sel;\n\n\tif (WARN_ON(!rdev->desc->n_ramp_values || !rdev->desc->ramp_delay_table))\n\t\treturn -EINVAL;\n\n\tret = regulator_find_closest_bigger(ramp_delay, rdev->desc->ramp_delay_table,\n\t\t\t\t\t    rdev->desc->n_ramp_values, &sel);\n\n\tif (ret) {\n\t\tdev_warn(rdev_get_dev(rdev),\n\t\t\t \"Can't set ramp-delay %u, setting %u\\n\", ramp_delay,\n\t\t\t rdev->desc->ramp_delay_table[sel]);\n\t}\n\n\tsel <<= ffs(rdev->desc->ramp_mask) - 1;\n\n\treturn regmap_update_bits(rdev->regmap, rdev->desc->ramp_reg,\n\t\t\t\t  rdev->desc->ramp_mask, sel);\n}\nEXPORT_SYMBOL_GPL(regulator_set_ramp_delay_regmap);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}