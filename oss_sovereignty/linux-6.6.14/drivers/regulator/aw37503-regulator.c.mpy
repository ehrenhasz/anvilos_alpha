{
  "module_name": "aw37503-regulator.c",
  "hash_id": "e8b05bdddb81030997c02c7562d3915118880fa36d65ccbc6cff6b1406e9d149",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/aw37503-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n\n#define AW37503_REG_VPOS\t\t0x00\n#define AW37503_REG_VNEG\t\t0x01\n#define AW37503_REG_APPS\t\t0x03\n#define AW37503_REG_CONTROL\t\t0x04\n#define AW37503_REG_WPRTEN\t\t0x21\n\n#define AW37503_VOUT_MASK\t\t0x1F\n#define AW37503_VOUT_N_VOLTAGE\t\t0x15\n#define AW37503_VOUT_VMIN\t\t4000000\n#define AW37503_VOUT_VMAX\t\t6000000\n#define AW37503_VOUT_STEP\t\t100000\n\n#define AW37503_REG_APPS_DIS_VPOS\tBIT(1)\n#define AW37503_REG_APPS_DIS_VNEG\tBIT(0)\n\n#define AW37503_REGULATOR_ID_VPOS\t0\n#define AW37503_REGULATOR_ID_VNEG\t1\n#define AW37503_MAX_REGULATORS\t\t2\n\nstruct aw37503_reg_pdata {\n\tstruct gpio_desc *en_gpiod;\n\tint ena_gpio_state;\n};\n\nstruct aw37503_regulator {\n\tstruct device *dev;\n\tstruct aw37503_reg_pdata reg_pdata[AW37503_MAX_REGULATORS];\n};\n\nstatic int aw37503_regulator_enable(struct regulator_dev *rdev)\n{\n\tstruct aw37503_regulator *chip = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\tstruct aw37503_reg_pdata *rpdata = &chip->reg_pdata[id];\n\tint ret;\n\n\tif (!IS_ERR(rpdata->en_gpiod)) {\n\t\tgpiod_set_value_cansleep(rpdata->en_gpiod, 1);\n\t\trpdata->ena_gpio_state = 1;\n\t}\n\n\t \n\tif (rdev->constraints->active_discharge ==\n\t\t\tREGULATOR_ACTIVE_DISCHARGE_DISABLE) {\n\t\tret = regulator_set_active_discharge_regmap(rdev, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev, \"Failed to disable active discharge: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int aw37503_regulator_disable(struct regulator_dev *rdev)\n{\n\tstruct aw37503_regulator *chip = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\tstruct aw37503_reg_pdata *rpdata = &chip->reg_pdata[id];\n\n\tif (!IS_ERR(rpdata->en_gpiod)) {\n\t\tgpiod_set_value_cansleep(rpdata->en_gpiod, 0);\n\t\trpdata->ena_gpio_state = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw37503_regulator_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct aw37503_regulator *chip = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\tstruct aw37503_reg_pdata *rpdata = &chip->reg_pdata[id];\n\n\tif (!IS_ERR(rpdata->en_gpiod))\n\t\treturn rpdata->ena_gpio_state;\n\n\treturn 1;\n}\n\nstatic const struct regulator_ops aw37503_regulator_ops = {\n\t.enable = aw37503_regulator_enable,\n\t.disable = aw37503_regulator_disable,\n\t.is_enabled = aw37503_regulator_is_enabled,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n};\n\nstatic int aw37503_of_parse_cb(struct device_node *np,\n\t\t\t\tconst struct regulator_desc *desc,\n\t\t\t\tstruct regulator_config *config)\n{\n\tstruct aw37503_regulator *chip = config->driver_data;\n\tstruct aw37503_reg_pdata *rpdata = &chip->reg_pdata[desc->id];\n\tint ret;\n\n\trpdata->en_gpiod = devm_fwnode_gpiod_get(chip->dev, of_fwnode_handle(np),\n\t\t\t\t\t\t \"enable\", GPIOD_OUT_LOW,\n\t\t\t\t\t\t \"enable\");\n\n\tif (IS_ERR(rpdata->en_gpiod)) {\n\t\tret = PTR_ERR(rpdata->en_gpiod);\n\n\t\t \n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n#define AW37503_REGULATOR_DESC(_id, _name)\t\t\\\n\t[AW37503_REGULATOR_ID_##_id] = {\t\t\\\n\t\t.name = \"aw37503-\"#_name,\t\t\\\n\t\t.supply_name = \"vin\",\t\t\t\\\n\t\t.id = AW37503_REGULATOR_ID_##_id,\t\\\n\t\t.of_match = of_match_ptr(#_name),\t\\\n\t\t.of_parse_cb = aw37503_of_parse_cb,\t\\\n\t\t.ops = &aw37503_regulator_ops,\t\t\\\n\t\t.n_voltages = AW37503_VOUT_N_VOLTAGE,\t\\\n\t\t.min_uV = AW37503_VOUT_VMIN,\t\t\\\n\t\t.uV_step = AW37503_VOUT_STEP,\t\t\\\n\t\t.enable_time = 500,\t\t\t\\\n\t\t.vsel_mask = AW37503_VOUT_MASK,\t\\\n\t\t.vsel_reg = AW37503_REG_##_id,\t\t\\\n\t\t.active_discharge_off = 0,\t\t\t\\\n\t\t.active_discharge_on = AW37503_REG_APPS_DIS_##_id, \\\n\t\t.active_discharge_mask = AW37503_REG_APPS_DIS_##_id, \\\n\t\t.active_discharge_reg = AW37503_REG_APPS, \\\n\t\t.type = REGULATOR_VOLTAGE,\t\t\\\n\t\t.owner = THIS_MODULE,\t\t\t\\\n\t}\n\nstatic const struct regulator_desc aw_regs_desc[AW37503_MAX_REGULATORS] = {\n\tAW37503_REGULATOR_DESC(VPOS, outp),\n\tAW37503_REGULATOR_DESC(VNEG, outn),\n};\n\nstatic const struct regmap_range aw37503_no_reg_ranges[] = {\n\tregmap_reg_range(AW37503_REG_CONTROL + 1,\n\t\t\t AW37503_REG_WPRTEN - 1),\n};\n\nstatic const struct regmap_access_table aw37503_no_reg_table = {\n\t.no_ranges = aw37503_no_reg_ranges,\n\t.n_no_ranges = ARRAY_SIZE(aw37503_no_reg_ranges),\n};\n\nstatic const struct regmap_config aw37503_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= AW37503_REG_WPRTEN,\n\t.rd_table\t= &aw37503_no_reg_table,\n\t.wr_table\t= &aw37503_no_reg_table,\n};\n\nstatic int aw37503_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct aw37503_regulator *chip;\n\tstruct regulator_dev *rdev;\n\tstruct regmap *regmap;\n\tstruct regulator_config config = { };\n\tint id;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_i2c(client, &aw37503_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap),\n\t\t\t\t     \"Failed to init regmap\\n\");\n\n\ti2c_set_clientdata(client, chip);\n\tchip->dev = dev;\n\n\tconfig.regmap = regmap;\n\tconfig.dev = dev;\n\tconfig.driver_data = chip;\n\n\tfor (id = 0; id < AW37503_MAX_REGULATORS; ++id) {\n\t\trdev = devm_regulator_register(dev, &aw_regs_desc[id],\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(rdev),\n\t\t\t\t\t     \"Failed to register regulator %s\\n\",\n\t\t\t\t\t     aw_regs_desc[id].name);\n\t}\n\treturn 0;\n}\n\nstatic const struct i2c_device_id aw37503_id[] = {\n\t{.name = \"aw37503\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, aw37503_id);\n\nstatic const struct of_device_id aw37503_of_match[] = {\n\t{.compatible = \"awinic,aw37503\",},\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(of, aw37503_of_match);\n\nstatic struct i2c_driver aw37503_i2c_driver = {\n\t.driver = {\n\t\t.name = \"aw37503\",\n\t\t.of_match_table = aw37503_of_match,\n\t},\n\t.probe = aw37503_probe,\n\t.id_table = aw37503_id,\n};\n\nmodule_i2c_driver(aw37503_i2c_driver);\n\nMODULE_DESCRIPTION(\"aw37503 regulator driver\");\nMODULE_AUTHOR(\"Alec Li <like@awinic.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}