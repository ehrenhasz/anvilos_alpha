{
  "module_name": "aat2870-regulator.c",
  "hash_id": "2119c6db88786f456df2a7b7d2fbc6449d3b5212177fd260f91368e642478d15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/aat2870-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/mfd/aat2870.h>\n\nstruct aat2870_regulator {\n\tstruct aat2870_data *aat2870;\n\tstruct regulator_desc desc;\n\n\tu8 enable_addr;\n\tu8 enable_shift;\n\tu8 enable_mask;\n\n\tu8 voltage_addr;\n\tu8 voltage_shift;\n\tu8 voltage_mask;\n};\n\nstatic int aat2870_ldo_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t       unsigned selector)\n{\n\tstruct aat2870_regulator *ri = rdev_get_drvdata(rdev);\n\tstruct aat2870_data *aat2870 = ri->aat2870;\n\n\treturn aat2870->update(aat2870, ri->voltage_addr, ri->voltage_mask,\n\t\t\t       selector << ri->voltage_shift);\n}\n\nstatic int aat2870_ldo_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct aat2870_regulator *ri = rdev_get_drvdata(rdev);\n\tstruct aat2870_data *aat2870 = ri->aat2870;\n\tu8 val;\n\tint ret;\n\n\tret = aat2870->read(aat2870, ri->voltage_addr, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (val & ri->voltage_mask) >> ri->voltage_shift;\n}\n\nstatic int aat2870_ldo_enable(struct regulator_dev *rdev)\n{\n\tstruct aat2870_regulator *ri = rdev_get_drvdata(rdev);\n\tstruct aat2870_data *aat2870 = ri->aat2870;\n\n\treturn aat2870->update(aat2870, ri->enable_addr, ri->enable_mask,\n\t\t\t       ri->enable_mask);\n}\n\nstatic int aat2870_ldo_disable(struct regulator_dev *rdev)\n{\n\tstruct aat2870_regulator *ri = rdev_get_drvdata(rdev);\n\tstruct aat2870_data *aat2870 = ri->aat2870;\n\n\treturn aat2870->update(aat2870, ri->enable_addr, ri->enable_mask, 0);\n}\n\nstatic int aat2870_ldo_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct aat2870_regulator *ri = rdev_get_drvdata(rdev);\n\tstruct aat2870_data *aat2870 = ri->aat2870;\n\tu8 val;\n\tint ret;\n\n\tret = aat2870->read(aat2870, ri->enable_addr, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val & ri->enable_mask ? 1 : 0;\n}\n\nstatic const struct regulator_ops aat2870_ldo_ops = {\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n\t.set_voltage_sel = aat2870_ldo_set_voltage_sel,\n\t.get_voltage_sel = aat2870_ldo_get_voltage_sel,\n\t.enable = aat2870_ldo_enable,\n\t.disable = aat2870_ldo_disable,\n\t.is_enabled = aat2870_ldo_is_enabled,\n};\n\nstatic const unsigned int aat2870_ldo_voltages[] = {\n\t1200000, 1300000, 1500000, 1600000,\n\t1800000, 2000000, 2200000, 2500000,\n\t2600000, 2700000, 2800000, 2900000,\n\t3000000, 3100000, 3200000, 3300000,\n};\n\n#define AAT2870_LDO(ids)\t\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.desc = {\t\t\t\t\\\n\t\t\t.name = #ids,\t\t\t\\\n\t\t\t.id = AAT2870_ID_##ids,\t\t\\\n\t\t\t.n_voltages = ARRAY_SIZE(aat2870_ldo_voltages),\t\\\n\t\t\t.volt_table = aat2870_ldo_voltages, \\\n\t\t\t.ops = &aat2870_ldo_ops,\t\\\n\t\t\t.type = REGULATOR_VOLTAGE,\t\\\n\t\t\t.owner = THIS_MODULE,\t\t\\\n\t\t},\t\t\t\t\t\\\n\t}\n\nstatic struct aat2870_regulator aat2870_regulators[] = {\n\tAAT2870_LDO(LDOA),\n\tAAT2870_LDO(LDOB),\n\tAAT2870_LDO(LDOC),\n\tAAT2870_LDO(LDOD),\n};\n\nstatic struct aat2870_regulator *aat2870_get_regulator(int id)\n{\n\tstruct aat2870_regulator *ri = NULL;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(aat2870_regulators); i++) {\n\t\tri = &aat2870_regulators[i];\n\t\tif (ri->desc.id == id)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(aat2870_regulators))\n\t\treturn NULL;\n\n\tri->enable_addr = AAT2870_LDO_EN;\n\tri->enable_shift = id - AAT2870_ID_LDOA;\n\tri->enable_mask = 0x1 << ri->enable_shift;\n\n\tri->voltage_addr = (id - AAT2870_ID_LDOA) / 2 ?\n\t\t\t   AAT2870_LDO_CD : AAT2870_LDO_AB;\n\tri->voltage_shift = (id - AAT2870_ID_LDOA) % 2 ? 0 : 4;\n\tri->voltage_mask = 0xF << ri->voltage_shift;\n\n\treturn ri;\n}\n\nstatic int aat2870_regulator_probe(struct platform_device *pdev)\n{\n\tstruct aat2870_regulator *ri;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\n\tri = aat2870_get_regulator(pdev->id);\n\tif (!ri) {\n\t\tdev_err(&pdev->dev, \"Invalid device ID, %d\\n\", pdev->id);\n\t\treturn -EINVAL;\n\t}\n\tri->aat2870 = dev_get_drvdata(pdev->dev.parent);\n\n\tconfig.dev = &pdev->dev;\n\tconfig.driver_data = ri;\n\tconfig.init_data = dev_get_platdata(&pdev->dev);\n\n\trdev = devm_regulator_register(&pdev->dev, &ri->desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(&pdev->dev, \"Failed to register regulator %s\\n\",\n\t\t\tri->desc.name);\n\t\treturn PTR_ERR(rdev);\n\t}\n\tplatform_set_drvdata(pdev, rdev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver aat2870_regulator_driver = {\n\t.driver = {\n\t\t.name\t= \"aat2870-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t= aat2870_regulator_probe,\n};\n\nstatic int __init aat2870_regulator_init(void)\n{\n\treturn platform_driver_register(&aat2870_regulator_driver);\n}\nsubsys_initcall(aat2870_regulator_init);\n\nstatic void __exit aat2870_regulator_exit(void)\n{\n\tplatform_driver_unregister(&aat2870_regulator_driver);\n}\nmodule_exit(aat2870_regulator_exit);\n\nMODULE_DESCRIPTION(\"AnalogicTech AAT2870 Regulator\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jin Park <jinyoungp@nvidia.com>\");\nMODULE_ALIAS(\"platform:aat2870-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}