{
  "module_name": "max8952.c",
  "hash_id": "c1a22ed1a2101027d0a8172d3e8c02fd350150da06a765b6f62416f6796a2cae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/max8952.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/max8952.h>\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/slab.h>\n\n \nenum {\n\tMAX8952_REG_MODE0,\n\tMAX8952_REG_MODE1,\n\tMAX8952_REG_MODE2,\n\tMAX8952_REG_MODE3,\n\tMAX8952_REG_CONTROL,\n\tMAX8952_REG_SYNC,\n\tMAX8952_REG_RAMP,\n\tMAX8952_REG_CHIP_ID1,\n\tMAX8952_REG_CHIP_ID2,\n};\n\nstruct max8952_data {\n\tstruct i2c_client\t*client;\n\tstruct max8952_platform_data *pdata;\n\tstruct gpio_desc *vid0_gpiod;\n\tstruct gpio_desc *vid1_gpiod;\n\tbool vid0;\n\tbool vid1;\n};\n\nstatic int max8952_read_reg(struct max8952_data *max8952, u8 reg)\n{\n\tint ret = i2c_smbus_read_byte_data(max8952->client, reg);\n\n\tif (ret > 0)\n\t\tret &= 0xff;\n\n\treturn ret;\n}\n\nstatic int max8952_write_reg(struct max8952_data *max8952,\n\t\tu8 reg, u8 value)\n{\n\treturn i2c_smbus_write_byte_data(max8952->client, reg, value);\n}\n\nstatic int max8952_list_voltage(struct regulator_dev *rdev,\n\t\tunsigned int selector)\n{\n\tstruct max8952_data *max8952 = rdev_get_drvdata(rdev);\n\n\tif (rdev_get_id(rdev) != 0)\n\t\treturn -EINVAL;\n\n\treturn (max8952->pdata->dvs_mode[selector] * 10 + 770) * 1000;\n}\n\nstatic int max8952_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct max8952_data *max8952 = rdev_get_drvdata(rdev);\n\tu8 vid = 0;\n\n\tif (max8952->vid0)\n\t\tvid += 1;\n\tif (max8952->vid1)\n\t\tvid += 2;\n\n\treturn vid;\n}\n\nstatic int max8952_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t   unsigned selector)\n{\n\tstruct max8952_data *max8952 = rdev_get_drvdata(rdev);\n\n\tif (!max8952->vid0_gpiod || !max8952->vid1_gpiod) {\n\t\t \n\t\treturn -EPERM;\n\t}\n\n\tmax8952->vid0 = selector & 0x1;\n\tmax8952->vid1 = (selector >> 1) & 0x1;\n\tgpiod_set_value(max8952->vid0_gpiod, max8952->vid0);\n\tgpiod_set_value(max8952->vid1_gpiod, max8952->vid1);\n\n\treturn 0;\n}\n\nstatic const struct regulator_ops max8952_ops = {\n\t.list_voltage\t\t= max8952_list_voltage,\n\t.get_voltage_sel\t= max8952_get_voltage_sel,\n\t.set_voltage_sel\t= max8952_set_voltage_sel,\n};\n\nstatic const struct regulator_desc regulator = {\n\t.name\t\t= \"MAX8952_VOUT\",\n\t.id\t\t= 0,\n\t.n_voltages\t= MAX8952_NUM_DVS_MODE,\n\t.ops\t\t= &max8952_ops,\n\t.type\t\t= REGULATOR_VOLTAGE,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id max8952_dt_match[] = {\n\t{ .compatible = \"maxim,max8952\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, max8952_dt_match);\n\nstatic struct max8952_platform_data *max8952_parse_dt(struct device *dev)\n{\n\tstruct max8952_platform_data *pd;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\tint i;\n\n\tpd = devm_kzalloc(dev, sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn NULL;\n\n\tif (of_property_read_u32(np, \"max8952,default-mode\", &pd->default_mode))\n\t\tdev_warn(dev, \"Default mode not specified, assuming 0\\n\");\n\n\tret = of_property_read_u32_array(np, \"max8952,dvs-mode-microvolt\",\n\t\t\t\t\tpd->dvs_mode, ARRAY_SIZE(pd->dvs_mode));\n\tif (ret) {\n\t\tdev_err(dev, \"max8952,dvs-mode-microvolt property not specified\");\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pd->dvs_mode); ++i) {\n\t\tif (pd->dvs_mode[i] < 770000 || pd->dvs_mode[i] > 1400000) {\n\t\t\tdev_err(dev, \"DVS voltage %d out of range\\n\", i);\n\t\t\treturn NULL;\n\t\t}\n\t\tpd->dvs_mode[i] = (pd->dvs_mode[i] - 770000) / 10000;\n\t}\n\n\tif (of_property_read_u32(np, \"max8952,sync-freq\", &pd->sync_freq))\n\t\tdev_warn(dev, \"max8952,sync-freq property not specified, defaulting to 26MHz\\n\");\n\n\tif (of_property_read_u32(np, \"max8952,ramp-speed\", &pd->ramp_speed))\n\t\tdev_warn(dev, \"max8952,ramp-speed property not specified, defaulting to 32mV/us\\n\");\n\n\tpd->reg_data = of_get_regulator_init_data(dev, np, &regulator);\n\tif (!pd->reg_data) {\n\t\tdev_err(dev, \"Failed to parse regulator init data\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn pd;\n}\n#else\nstatic struct max8952_platform_data *max8952_parse_dt(struct device *dev)\n{\n\treturn NULL;\n}\n#endif\n\nstatic int max8952_pmic_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct max8952_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct regulator_config config = { };\n\tstruct max8952_data *max8952;\n\tstruct regulator_dev *rdev;\n\tstruct gpio_desc *gpiod;\n\tenum gpiod_flags gflags;\n\n\tint ret = 0;\n\n\tif (client->dev.of_node)\n\t\tpdata = max8952_parse_dt(&client->dev);\n\n\tif (!pdata) {\n\t\tdev_err(&client->dev, \"Require the platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE))\n\t\treturn -EIO;\n\n\tmax8952 = devm_kzalloc(&client->dev, sizeof(struct max8952_data),\n\t\t\t       GFP_KERNEL);\n\tif (!max8952)\n\t\treturn -ENOMEM;\n\n\tmax8952->client = client;\n\tmax8952->pdata = pdata;\n\n\tconfig.dev = &client->dev;\n\tconfig.init_data = pdata->reg_data;\n\tconfig.driver_data = max8952;\n\tconfig.of_node = client->dev.of_node;\n\n\tif (pdata->reg_data->constraints.boot_on)\n\t\tgflags = GPIOD_OUT_HIGH;\n\telse\n\t\tgflags = GPIOD_OUT_LOW;\n\tgflags |= GPIOD_FLAGS_BIT_NONEXCLUSIVE;\n\t \n\tgpiod = gpiod_get_optional(&client->dev,\n\t\t\t\t   \"max8952,en\",\n\t\t\t\t   gflags);\n\tif (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\tif (gpiod)\n\t\tconfig.ena_gpiod = gpiod;\n\n\trdev = devm_regulator_register(&client->dev, &regulator, &config);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\t\tdev_err(&client->dev, \"regulator init failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmax8952->vid0 = pdata->default_mode & 0x1;\n\tmax8952->vid1 = (pdata->default_mode >> 1) & 0x1;\n\n\t \n\tgflags = max8952->vid0 ? GPIOD_OUT_HIGH : GPIOD_OUT_LOW;\n\tmax8952->vid0_gpiod = devm_gpiod_get_index_optional(&client->dev,\n\t\t\t\t\t\t\t    \"max8952,vid\",\n\t\t\t\t\t\t\t    0, gflags);\n\tif (IS_ERR(max8952->vid0_gpiod))\n\t\treturn PTR_ERR(max8952->vid0_gpiod);\n\tgflags = max8952->vid1 ? GPIOD_OUT_HIGH : GPIOD_OUT_LOW;\n\tmax8952->vid1_gpiod = devm_gpiod_get_index_optional(&client->dev,\n\t\t\t\t\t\t\t    \"max8952,vid\",\n\t\t\t\t\t\t\t    1, gflags);\n\tif (IS_ERR(max8952->vid1_gpiod))\n\t\treturn PTR_ERR(max8952->vid1_gpiod);\n\n\t \n\tif (!max8952->vid0_gpiod || !max8952->vid1_gpiod) {\n\t\tdev_warn(&client->dev, \"VID0/1 gpio invalid: \"\n\t\t\t \"DVS not available.\\n\");\n\t\tmax8952->vid0 = 0;\n\t\tmax8952->vid1 = 0;\n\t\t \n\t\tif (max8952->vid0_gpiod)\n\t\t\tgpiod_set_value(max8952->vid0_gpiod, 0);\n\t\tif (max8952->vid1_gpiod)\n\t\t\tgpiod_set_value(max8952->vid1_gpiod, 0);\n\n\t\t \n\t\tmax8952_write_reg(max8952, MAX8952_REG_CONTROL, 0x60);\n\n\t\tdev_err(&client->dev, \"DVS modes disabled because VID0 and VID1\"\n\t\t\t\t\" do not have proper controls.\\n\");\n\t} else {\n\t\t \n\t\tmax8952_write_reg(max8952, MAX8952_REG_CONTROL, 0x0);\n\t}\n\n\tmax8952_write_reg(max8952, MAX8952_REG_MODE0,\n\t\t\t(max8952_read_reg(max8952,\n\t\t\t\t\t  MAX8952_REG_MODE0) & 0xC0) |\n\t\t\t(pdata->dvs_mode[0] & 0x3F));\n\tmax8952_write_reg(max8952, MAX8952_REG_MODE1,\n\t\t\t(max8952_read_reg(max8952,\n\t\t\t\t\t  MAX8952_REG_MODE1) & 0xC0) |\n\t\t\t(pdata->dvs_mode[1] & 0x3F));\n\tmax8952_write_reg(max8952, MAX8952_REG_MODE2,\n\t\t\t(max8952_read_reg(max8952,\n\t\t\t\t\t  MAX8952_REG_MODE2) & 0xC0) |\n\t\t\t(pdata->dvs_mode[2] & 0x3F));\n\tmax8952_write_reg(max8952, MAX8952_REG_MODE3,\n\t\t\t(max8952_read_reg(max8952,\n\t\t\t\t\t  MAX8952_REG_MODE3) & 0xC0) |\n\t\t\t(pdata->dvs_mode[3] & 0x3F));\n\n\tmax8952_write_reg(max8952, MAX8952_REG_SYNC,\n\t\t\t(max8952_read_reg(max8952, MAX8952_REG_SYNC) & 0x3F) |\n\t\t\t((pdata->sync_freq & 0x3) << 6));\n\tmax8952_write_reg(max8952, MAX8952_REG_RAMP,\n\t\t\t(max8952_read_reg(max8952, MAX8952_REG_RAMP) & 0x1F) |\n\t\t\t((pdata->ramp_speed & 0x7) << 5));\n\n\ti2c_set_clientdata(client, max8952);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max8952_ids[] = {\n\t{ \"max8952\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, max8952_ids);\n\nstatic struct i2c_driver max8952_pmic_driver = {\n\t.probe\t\t= max8952_pmic_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"max8952\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(max8952_dt_match),\n\t},\n\t.id_table\t= max8952_ids,\n};\n\nstatic int __init max8952_pmic_init(void)\n{\n\treturn i2c_add_driver(&max8952_pmic_driver);\n}\nsubsys_initcall(max8952_pmic_init);\n\nstatic void __exit max8952_pmic_exit(void)\n{\n\ti2c_del_driver(&max8952_pmic_driver);\n}\nmodule_exit(max8952_pmic_exit);\n\nMODULE_DESCRIPTION(\"MAXIM 8952 voltage regulator driver\");\nMODULE_AUTHOR(\"MyungJoo Ham <myungjoo.ham@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}