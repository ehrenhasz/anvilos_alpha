{
  "module_name": "rpi-panel-attiny-regulator.c",
  "hash_id": "7e166dd49c8097135a8982720d75fb87428505d999df925371c677b3242ef7c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rpi-panel-attiny-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/slab.h>\n\n \n#define REG_ID\t\t0x80\n#define REG_PORTA\t0x81\n#define REG_PORTB\t0x82\n#define REG_PORTC\t0x83\n#define REG_POWERON\t0x85\n#define REG_PWM\t\t0x86\n#define REG_ADDR_L\t0x8c\n#define REG_ADDR_H\t0x8d\n#define REG_WRITE_DATA_H\t0x90\n#define REG_WRITE_DATA_L\t0x91\n\n#define PA_LCD_DITHB\t\tBIT(0)\n#define PA_LCD_MODE\t\tBIT(1)\n#define PA_LCD_LR\t\tBIT(2)\n#define PA_LCD_UD\t\tBIT(3)\n\n#define PB_BRIDGE_PWRDNX_N\tBIT(0)\n#define PB_LCD_VCC_N\t\tBIT(1)\n#define PB_LCD_MAIN\t\tBIT(7)\n\n#define PC_LED_EN\t\tBIT(0)\n#define PC_RST_TP_N\t\tBIT(1)\n#define PC_RST_LCD_N\t\tBIT(2)\n#define PC_RST_BRIDGE_N\t\tBIT(3)\n\nenum gpio_signals {\n\tRST_BRIDGE_N,\t \n\tRST_TP_N,\t \n\tNUM_GPIO\n};\n\nstruct gpio_signal_mappings {\n\tunsigned int reg;\n\tunsigned int mask;\n};\n\nstatic const struct gpio_signal_mappings mappings[NUM_GPIO] = {\n\t[RST_BRIDGE_N] = { REG_PORTC, PC_RST_BRIDGE_N | PC_RST_LCD_N  },\n\t[RST_TP_N] = { REG_PORTC, PC_RST_TP_N },\n};\n\nstruct attiny_lcd {\n\t \n\tstruct mutex\tlock;\n\tstruct regmap\t*regmap;\n\tbool gpio_states[NUM_GPIO];\n\tu8 port_states[3];\n\n\tstruct gpio_chip gc;\n};\n\nstatic const struct regmap_config attiny_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.disable_locking = 1,\n\t.max_register = REG_WRITE_DATA_L,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int attiny_set_port_state(struct attiny_lcd *state, int reg, u8 val)\n{\n\tstate->port_states[reg - REG_PORTA] = val;\n\treturn regmap_write(state->regmap, reg, val);\n};\n\nstatic u8 attiny_get_port_state(struct attiny_lcd *state, int reg)\n{\n\treturn state->port_states[reg - REG_PORTA];\n};\n\nstatic int attiny_lcd_power_enable(struct regulator_dev *rdev)\n{\n\tstruct attiny_lcd *state = rdev_get_drvdata(rdev);\n\n\tmutex_lock(&state->lock);\n\n\t \n\tattiny_set_port_state(state, REG_PORTC, 0);\n\tusleep_range(5000, 10000);\n\n\t \n\tattiny_set_port_state(state, REG_PORTA, PA_LCD_LR);\n\tusleep_range(5000, 10000);\n\t \n\tattiny_set_port_state(state, REG_PORTB, PB_LCD_MAIN);\n\tusleep_range(5000, 10000);\n\t \n\tattiny_set_port_state(state, REG_PORTC, PC_LED_EN);\n\n\tmsleep(80);\n\n\tmutex_unlock(&state->lock);\n\n\treturn 0;\n}\n\nstatic int attiny_lcd_power_disable(struct regulator_dev *rdev)\n{\n\tstruct attiny_lcd *state = rdev_get_drvdata(rdev);\n\n\tmutex_lock(&state->lock);\n\n\tregmap_write(rdev->regmap, REG_PWM, 0);\n\tusleep_range(5000, 10000);\n\n\tattiny_set_port_state(state, REG_PORTA, 0);\n\tusleep_range(5000, 10000);\n\tattiny_set_port_state(state, REG_PORTB, PB_LCD_VCC_N);\n\tusleep_range(5000, 10000);\n\tattiny_set_port_state(state, REG_PORTC, 0);\n\tmsleep(30);\n\n\tmutex_unlock(&state->lock);\n\n\treturn 0;\n}\n\nstatic int attiny_lcd_power_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct attiny_lcd *state = rdev_get_drvdata(rdev);\n\tunsigned int data;\n\tint ret, i;\n\n\tmutex_lock(&state->lock);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tret = regmap_read(rdev->regmap, REG_PORTC, &data);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tusleep_range(10000, 12000);\n\t}\n\n\tmutex_unlock(&state->lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn data & PC_RST_BRIDGE_N;\n}\n\nstatic const struct regulator_init_data attiny_regulator_default = {\n\t.constraints = {\n\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t},\n};\n\nstatic const struct regulator_ops attiny_regulator_ops = {\n\t.enable = attiny_lcd_power_enable,\n\t.disable = attiny_lcd_power_disable,\n\t.is_enabled = attiny_lcd_power_is_enabled,\n};\n\nstatic const struct regulator_desc attiny_regulator = {\n\t.name\t= \"tc358762-power\",\n\t.ops\t= &attiny_regulator_ops,\n\t.type\t= REGULATOR_VOLTAGE,\n\t.owner\t= THIS_MODULE,\n};\n\nstatic int attiny_update_status(struct backlight_device *bl)\n{\n\tstruct attiny_lcd *state = bl_get_data(bl);\n\tstruct regmap *regmap = state->regmap;\n\tint brightness = backlight_get_brightness(bl);\n\tint ret, i;\n\n\tmutex_lock(&state->lock);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tret = regmap_write(regmap, REG_PWM, brightness);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&state->lock);\n\n\treturn ret;\n}\n\nstatic const struct backlight_ops attiny_bl = {\n\t.update_status\t= attiny_update_status,\n};\n\nstatic int attiny_gpio_get_direction(struct gpio_chip *gc, unsigned int off)\n{\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic void attiny_gpio_set(struct gpio_chip *gc, unsigned int off, int val)\n{\n\tstruct attiny_lcd *state = gpiochip_get_data(gc);\n\tu8 last_val;\n\n\tif (off >= NUM_GPIO)\n\t\treturn;\n\n\tmutex_lock(&state->lock);\n\n\tlast_val = attiny_get_port_state(state, mappings[off].reg);\n\tif (val)\n\t\tlast_val |= mappings[off].mask;\n\telse\n\t\tlast_val &= ~mappings[off].mask;\n\n\tattiny_set_port_state(state, mappings[off].reg, last_val);\n\n\tif (off == RST_BRIDGE_N && val) {\n\t\tusleep_range(5000, 8000);\n\t\tregmap_write(state->regmap, REG_ADDR_H, 0x04);\n\t\tusleep_range(5000, 8000);\n\t\tregmap_write(state->regmap, REG_ADDR_L, 0x7c);\n\t\tusleep_range(5000, 8000);\n\t\tregmap_write(state->regmap, REG_WRITE_DATA_H, 0x00);\n\t\tusleep_range(5000, 8000);\n\t\tregmap_write(state->regmap, REG_WRITE_DATA_L, 0x00);\n\n\t\tmsleep(100);\n\t}\n\n\tmutex_unlock(&state->lock);\n}\n\nstatic int attiny_i2c_read(struct i2c_client *client, u8 reg, unsigned int *buf)\n{\n\tstruct i2c_msg msgs[1];\n\tu8 addr_buf[1] = { reg };\n\tu8 data_buf[1] = { 0, };\n\tint ret;\n\n\t \n\tmsgs[0].addr = client->addr;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = ARRAY_SIZE(addr_buf);\n\tmsgs[0].buf = addr_buf;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret != ARRAY_SIZE(msgs))\n\t\treturn -EIO;\n\n\tusleep_range(5000, 10000);\n\n\t \n\tmsgs[0].addr = client->addr;\n\tmsgs[0].flags = I2C_M_RD;\n\tmsgs[0].len = 1;\n\tmsgs[0].buf = data_buf;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret != ARRAY_SIZE(msgs))\n\t\treturn -EIO;\n\n\t*buf = data_buf[0];\n\treturn 0;\n}\n\n \nstatic int attiny_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct backlight_properties props = { };\n\tstruct regulator_config config = { };\n\tstruct backlight_device *bl;\n\tstruct regulator_dev *rdev;\n\tstruct attiny_lcd *state;\n\tstruct regmap *regmap;\n\tunsigned int data;\n\tint ret;\n\n\tstate = devm_kzalloc(&i2c->dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&state->lock);\n\ti2c_set_clientdata(i2c, state);\n\n\tregmap = devm_regmap_init_i2c(i2c, &attiny_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\tgoto error;\n\t}\n\n\tret = attiny_i2c_read(i2c, REG_ID, &data);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read REG_ID reg: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tswitch (data) {\n\tcase 0xde:  \n\tcase 0xc3:  \n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2c->dev, \"Unknown Atmel firmware revision: 0x%02x\\n\", data);\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tregmap_write(regmap, REG_POWERON, 0);\n\tmsleep(30);\n\tregmap_write(regmap, REG_PWM, 0);\n\n\tconfig.dev = &i2c->dev;\n\tconfig.regmap = regmap;\n\tconfig.of_node = i2c->dev.of_node;\n\tconfig.init_data = &attiny_regulator_default;\n\tconfig.driver_data = state;\n\n\trdev = devm_regulator_register(&i2c->dev, &attiny_regulator, &config);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(&i2c->dev, \"Failed to register ATTINY regulator\\n\");\n\t\tret = PTR_ERR(rdev);\n\t\tgoto error;\n\t}\n\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = 0xff;\n\n\tstate->regmap = regmap;\n\n\tbl = devm_backlight_device_register(&i2c->dev, dev_name(&i2c->dev),\n\t\t\t\t\t    &i2c->dev, state, &attiny_bl,\n\t\t\t\t\t    &props);\n\tif (IS_ERR(bl)) {\n\t\tret = PTR_ERR(bl);\n\t\tgoto error;\n\t}\n\n\tbl->props.brightness = 0xff;\n\n\tstate->gc.parent = &i2c->dev;\n\tstate->gc.label = i2c->name;\n\tstate->gc.owner = THIS_MODULE;\n\tstate->gc.base = -1;\n\tstate->gc.ngpio = NUM_GPIO;\n\n\tstate->gc.set = attiny_gpio_set;\n\tstate->gc.get_direction = attiny_gpio_get_direction;\n\tstate->gc.can_sleep = true;\n\n\tret = devm_gpiochip_add_data(&i2c->dev, &state->gc, state);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to create gpiochip: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tmutex_destroy(&state->lock);\n\n\treturn ret;\n}\n\nstatic void attiny_i2c_remove(struct i2c_client *client)\n{\n\tstruct attiny_lcd *state = i2c_get_clientdata(client);\n\n\tmutex_destroy(&state->lock);\n}\n\nstatic const struct of_device_id attiny_dt_ids[] = {\n\t{ .compatible = \"raspberrypi,7inch-touchscreen-panel-regulator\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, attiny_dt_ids);\n\nstatic struct i2c_driver attiny_regulator_driver = {\n\t.driver = {\n\t\t.name = \"rpi_touchscreen_attiny\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = attiny_dt_ids,\n\t},\n\t.probe = attiny_i2c_probe,\n\t.remove\t= attiny_i2c_remove,\n};\n\nmodule_i2c_driver(attiny_regulator_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"Regulator device driver for Raspberry Pi 7-inch touchscreen\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}