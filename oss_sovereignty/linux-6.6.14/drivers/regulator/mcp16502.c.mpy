{
  "module_name": "mcp16502.c",
  "hash_id": "c77cb6c5de77b7271a0c7cfd9f63f3c0cd9e4db99cd51365e087a91642d6c931",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/mcp16502.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/suspend.h>\n#include <linux/gpio/consumer.h>\n\n#define VDD_LOW_SEL 0x0D\n#define VDD_HIGH_SEL 0x3F\n\n#define MCP16502_FLT\t\tBIT(7)\n#define MCP16502_DVSR\t\tGENMASK(3, 2)\n#define MCP16502_ENS\t\tBIT(0)\n\n \n\n \n#define MCP16502_REG_BASE(i, r) ((((i) + 1) << 4) + MCP16502_REG_##r)\n#define MCP16502_STAT_BASE(i) ((i) + 5)\n\n#define MCP16502_OPMODE_ACTIVE REGULATOR_MODE_NORMAL\n#define MCP16502_OPMODE_LPM REGULATOR_MODE_IDLE\n#define MCP16502_OPMODE_HIB REGULATOR_MODE_STANDBY\n\n#define MCP16502_MODE_AUTO_PFM 0\n#define MCP16502_MODE_FPWM BIT(6)\n\n#define MCP16502_VSEL 0x3F\n#define MCP16502_EN BIT(7)\n#define MCP16502_MODE BIT(6)\n\n#define MCP16502_MIN_REG 0x0\n#define MCP16502_MAX_REG 0x65\n\n \nenum mcp16502_reg {\n\tMCP16502_REG_A,\n\tMCP16502_REG_LPM,\n\tMCP16502_REG_HIB,\n\tMCP16502_REG_HPM,\n\tMCP16502_REG_SEQ,\n\tMCP16502_REG_CFG,\n};\n\n \nstatic const unsigned int mcp16502_ramp_b1l12[] = {\n\t6250, 3125, 2083, 1563\n};\n\n \nstatic const unsigned int mcp16502_ramp_b234[] = {\n\t3125, 1563, 1042, 781\n};\n\nstatic unsigned int mcp16502_of_map_mode(unsigned int mode)\n{\n\tif (mode == REGULATOR_MODE_NORMAL || mode == REGULATOR_MODE_IDLE)\n\t\treturn mode;\n\n\treturn REGULATOR_MODE_INVALID;\n}\n\n#define MCP16502_REGULATOR(_name, _id, _ranges, _ops, _ramp_table)\t\\\n\t[_id] = {\t\t\t\t\t\t\t\\\n\t\t.name\t\t\t= _name,\t\t\t\\\n\t\t.regulators_node\t= \"regulators\",\t\t\t\\\n\t\t.id\t\t\t= _id,\t\t\t\t\\\n\t\t.ops\t\t\t= &(_ops),\t\t\t\\\n\t\t.type\t\t\t= REGULATOR_VOLTAGE,\t\t\\\n\t\t.owner\t\t\t= THIS_MODULE,\t\t\t\\\n\t\t.n_voltages\t\t= MCP16502_VSEL + 1,\t\t\\\n\t\t.linear_ranges\t\t= _ranges,\t\t\t\\\n\t\t.linear_min_sel\t\t= VDD_LOW_SEL,\t\t\t\\\n\t\t.n_linear_ranges\t= ARRAY_SIZE(_ranges),\t\t\\\n\t\t.of_match\t\t= _name,\t\t\t\\\n\t\t.of_map_mode\t\t= mcp16502_of_map_mode,\t\t\\\n\t\t.vsel_reg\t\t= (((_id) + 1) << 4),\t\t\\\n\t\t.vsel_mask\t\t= MCP16502_VSEL,\t\t\\\n\t\t.enable_reg\t\t= (((_id) + 1) << 4),\t\t\\\n\t\t.enable_mask\t\t= MCP16502_EN,\t\t\t\\\n\t\t.ramp_reg\t\t= MCP16502_REG_BASE(_id, CFG),\t\\\n\t\t.ramp_mask\t\t= MCP16502_DVSR,\t\t\\\n\t\t.ramp_delay_table\t= _ramp_table,\t\t\t\\\n\t\t.n_ramp_values\t\t= ARRAY_SIZE(_ramp_table),\t\\\n\t}\n\nenum {\n\tBUCK1 = 0,\n\tBUCK2,\n\tBUCK3,\n\tBUCK4,\n\tLDO1,\n\tLDO2,\n\tNUM_REGULATORS\n};\n\n \nstruct mcp16502 {\n\tstruct gpio_desc *lpm;\n};\n\n \nstatic void mcp16502_gpio_set_mode(struct mcp16502 *mcp, int mode)\n{\n\tswitch (mode) {\n\tcase MCP16502_OPMODE_ACTIVE:\n\t\tgpiod_set_value(mcp->lpm, 0);\n\t\tbreak;\n\tcase MCP16502_OPMODE_LPM:\n\tcase MCP16502_OPMODE_HIB:\n\t\tgpiod_set_value(mcp->lpm, 1);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: %d invalid\\n\", __func__, mode);\n\t}\n}\n\n \nstatic int mcp16502_get_state_reg(struct regulator_dev *rdev, int opmode)\n{\n\tswitch (opmode) {\n\tcase MCP16502_OPMODE_ACTIVE:\n\t\treturn MCP16502_REG_BASE(rdev_get_id(rdev), A);\n\tcase MCP16502_OPMODE_LPM:\n\t\treturn MCP16502_REG_BASE(rdev_get_id(rdev), LPM);\n\tcase MCP16502_OPMODE_HIB:\n\t\treturn MCP16502_REG_BASE(rdev_get_id(rdev), HIB);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic unsigned int mcp16502_get_mode(struct regulator_dev *rdev)\n{\n\tunsigned int val;\n\tint ret, reg;\n\n\treg = mcp16502_get_state_reg(rdev, MCP16502_OPMODE_ACTIVE);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tret = regmap_read(rdev->regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (val & MCP16502_MODE) {\n\tcase MCP16502_MODE_FPWM:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase MCP16502_MODE_AUTO_PFM:\n\t\treturn REGULATOR_MODE_IDLE;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\n \nstatic int _mcp16502_set_mode(struct regulator_dev *rdev, unsigned int mode,\n\t\t\t      unsigned int op_mode)\n{\n\tint val;\n\tint reg;\n\n\treg = mcp16502_get_state_reg(rdev, op_mode);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = MCP16502_MODE_FPWM;\n\t\tbreak;\n\tcase REGULATOR_MODE_IDLE:\n\t\tval = MCP16502_MODE_AUTO_PFM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treg = regmap_update_bits(rdev->regmap, reg, MCP16502_MODE, val);\n\treturn reg;\n}\n\n \nstatic int mcp16502_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\treturn _mcp16502_set_mode(rdev, mode, MCP16502_OPMODE_ACTIVE);\n}\n\n \nstatic int mcp16502_get_status(struct regulator_dev *rdev)\n{\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(rdev->regmap, MCP16502_STAT_BASE(rdev_get_id(rdev)),\n\t\t\t  &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & MCP16502_FLT)\n\t\treturn REGULATOR_STATUS_ERROR;\n\telse if (val & MCP16502_ENS)\n\t\treturn REGULATOR_STATUS_ON;\n\telse if (!(val & MCP16502_ENS))\n\t\treturn REGULATOR_STATUS_OFF;\n\n\treturn REGULATOR_STATUS_UNDEFINED;\n}\n\nstatic int mcp16502_set_voltage_time_sel(struct regulator_dev *rdev,\n\t\t\t\t\t unsigned int old_sel,\n\t\t\t\t\t unsigned int new_sel)\n{\n\tstatic const u8 us_ramp[] = { 8, 16, 24, 32 };\n\tint id = rdev_get_id(rdev);\n\tunsigned int uV_delta, val;\n\tint ret;\n\n\tret = regmap_read(rdev->regmap, MCP16502_REG_BASE(id, CFG), &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = (val & MCP16502_DVSR) >> 2;\n\tuV_delta = abs(new_sel * rdev->desc->linear_ranges->step -\n\t\t       old_sel * rdev->desc->linear_ranges->step);\n\tswitch (id) {\n\tcase BUCK1:\n\tcase LDO1:\n\tcase LDO2:\n\t\tret = DIV_ROUND_CLOSEST(uV_delta * us_ramp[val],\n\t\t\t\t\tmcp16502_ramp_b1l12[val]);\n\t\tbreak;\n\n\tcase BUCK2:\n\tcase BUCK3:\n\tcase BUCK4:\n\t\tret = DIV_ROUND_CLOSEST(uV_delta * us_ramp[val],\n\t\t\t\t\tmcp16502_ramp_b234[val]);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_SUSPEND\n \nstatic int mcp16502_suspend_get_target_reg(struct regulator_dev *rdev)\n{\n\tswitch (pm_suspend_target_state) {\n\tcase PM_SUSPEND_STANDBY:\n\t\treturn mcp16502_get_state_reg(rdev, MCP16502_OPMODE_LPM);\n\tcase PM_SUSPEND_ON:\n\tcase PM_SUSPEND_MEM:\n\t\treturn mcp16502_get_state_reg(rdev, MCP16502_OPMODE_HIB);\n\tdefault:\n\t\tdev_err(&rdev->dev, \"invalid suspend target: %d\\n\",\n\t\t\tpm_suspend_target_state);\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int mcp16502_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tint sel = regulator_map_voltage_linear_range(rdev, uV, uV);\n\tint reg = mcp16502_suspend_get_target_reg(rdev);\n\n\tif (sel < 0)\n\t\treturn sel;\n\n\tif (reg < 0)\n\t\treturn reg;\n\n\treturn regmap_update_bits(rdev->regmap, reg, MCP16502_VSEL, sel);\n}\n\n \nstatic int mcp16502_set_suspend_mode(struct regulator_dev *rdev,\n\t\t\t\t     unsigned int mode)\n{\n\tswitch (pm_suspend_target_state) {\n\tcase PM_SUSPEND_STANDBY:\n\t\treturn _mcp16502_set_mode(rdev, mode, MCP16502_OPMODE_LPM);\n\tcase PM_SUSPEND_ON:\n\tcase PM_SUSPEND_MEM:\n\t\treturn _mcp16502_set_mode(rdev, mode, MCP16502_OPMODE_HIB);\n\tdefault:\n\t\tdev_err(&rdev->dev, \"invalid suspend target: %d\\n\",\n\t\t\tpm_suspend_target_state);\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int mcp16502_set_suspend_enable(struct regulator_dev *rdev)\n{\n\tint reg = mcp16502_suspend_get_target_reg(rdev);\n\n\tif (reg < 0)\n\t\treturn reg;\n\n\treturn regmap_update_bits(rdev->regmap, reg, MCP16502_EN, MCP16502_EN);\n}\n\n \nstatic int mcp16502_set_suspend_disable(struct regulator_dev *rdev)\n{\n\tint reg = mcp16502_suspend_get_target_reg(rdev);\n\n\tif (reg < 0)\n\t\treturn reg;\n\n\treturn regmap_update_bits(rdev->regmap, reg, MCP16502_EN, 0);\n}\n#endif  \n\nstatic const struct regulator_ops mcp16502_buck_ops = {\n\t.list_voltage\t\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t\t= regulator_map_voltage_linear_range,\n\t.get_voltage_sel\t\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t\t= regulator_set_voltage_sel_regmap,\n\t.enable\t\t\t\t= regulator_enable_regmap,\n\t.disable\t\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t\t= regulator_is_enabled_regmap,\n\t.get_status\t\t\t= mcp16502_get_status,\n\t.set_voltage_time_sel\t\t= mcp16502_set_voltage_time_sel,\n\t.set_ramp_delay\t\t\t= regulator_set_ramp_delay_regmap,\n\n\t.set_mode\t\t\t= mcp16502_set_mode,\n\t.get_mode\t\t\t= mcp16502_get_mode,\n\n#ifdef CONFIG_SUSPEND\n\t.set_suspend_voltage\t\t= mcp16502_set_suspend_voltage,\n\t.set_suspend_mode\t\t= mcp16502_set_suspend_mode,\n\t.set_suspend_enable\t\t= mcp16502_set_suspend_enable,\n\t.set_suspend_disable\t\t= mcp16502_set_suspend_disable,\n#endif  \n};\n\n \nstatic const struct regulator_ops mcp16502_ldo_ops = {\n\t.list_voltage\t\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t\t= regulator_map_voltage_linear_range,\n\t.get_voltage_sel\t\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t\t= regulator_set_voltage_sel_regmap,\n\t.enable\t\t\t\t= regulator_enable_regmap,\n\t.disable\t\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t\t= regulator_is_enabled_regmap,\n\t.get_status\t\t\t= mcp16502_get_status,\n\t.set_voltage_time_sel\t\t= mcp16502_set_voltage_time_sel,\n\t.set_ramp_delay\t\t\t= regulator_set_ramp_delay_regmap,\n\n#ifdef CONFIG_SUSPEND\n\t.set_suspend_voltage\t\t= mcp16502_set_suspend_voltage,\n\t.set_suspend_enable\t\t= mcp16502_set_suspend_enable,\n\t.set_suspend_disable\t\t= mcp16502_set_suspend_disable,\n#endif  \n};\n\nstatic const struct of_device_id mcp16502_ids[] = {\n\t{ .compatible = \"microchip,mcp16502\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mcp16502_ids);\n\nstatic const struct linear_range b1l12_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1200000, VDD_LOW_SEL, VDD_HIGH_SEL, 50000),\n};\n\nstatic const struct linear_range b234_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(600000, VDD_LOW_SEL, VDD_HIGH_SEL, 25000),\n};\n\nstatic const struct regulator_desc mcp16502_desc[] = {\n\t \n\tMCP16502_REGULATOR(\"VDD_IO\", BUCK1, b1l12_ranges, mcp16502_buck_ops,\n\t\t\t   mcp16502_ramp_b1l12),\n\tMCP16502_REGULATOR(\"VDD_DDR\", BUCK2, b234_ranges, mcp16502_buck_ops,\n\t\t\t   mcp16502_ramp_b234),\n\tMCP16502_REGULATOR(\"VDD_CORE\", BUCK3, b234_ranges, mcp16502_buck_ops,\n\t\t\t   mcp16502_ramp_b234),\n\tMCP16502_REGULATOR(\"VDD_OTHER\", BUCK4, b234_ranges, mcp16502_buck_ops,\n\t\t\t   mcp16502_ramp_b234),\n\tMCP16502_REGULATOR(\"LDO1\", LDO1, b1l12_ranges, mcp16502_ldo_ops,\n\t\t\t   mcp16502_ramp_b1l12),\n\tMCP16502_REGULATOR(\"LDO2\", LDO2, b1l12_ranges, mcp16502_ldo_ops,\n\t\t\t   mcp16502_ramp_b1l12)\n};\n\nstatic const struct regmap_range mcp16502_ranges[] = {\n\tregmap_reg_range(MCP16502_MIN_REG, MCP16502_MAX_REG)\n};\n\nstatic const struct regmap_access_table mcp16502_yes_reg_table = {\n\t.yes_ranges = mcp16502_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(mcp16502_ranges),\n};\n\nstatic const struct regmap_config mcp16502_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= MCP16502_MAX_REG,\n\t.cache_type\t= REGCACHE_NONE,\n\t.rd_table\t= &mcp16502_yes_reg_table,\n\t.wr_table\t= &mcp16502_yes_reg_table,\n};\n\nstatic int mcp16502_probe(struct i2c_client *client)\n{\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tstruct device *dev;\n\tstruct mcp16502 *mcp;\n\tstruct regmap *rmap;\n\tint i, ret;\n\n\tdev = &client->dev;\n\tconfig.dev = dev;\n\n\tmcp = devm_kzalloc(dev, sizeof(*mcp), GFP_KERNEL);\n\tif (!mcp)\n\t\treturn -ENOMEM;\n\n\trmap = devm_regmap_init_i2c(client, &mcp16502_regmap_config);\n\tif (IS_ERR(rmap)) {\n\t\tret = PTR_ERR(rmap);\n\t\tdev_err(dev, \"regmap init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(client, mcp);\n\tconfig.regmap = rmap;\n\tconfig.driver_data = mcp;\n\n\tmcp->lpm = devm_gpiod_get_optional(dev, \"lpm\", GPIOD_OUT_LOW);\n\tif (IS_ERR(mcp->lpm)) {\n\t\tdev_err(dev, \"failed to get lpm pin: %ld\\n\", PTR_ERR(mcp->lpm));\n\t\treturn PTR_ERR(mcp->lpm);\n\t}\n\n\tfor (i = 0; i < NUM_REGULATORS; i++) {\n\t\trdev = devm_regulator_register(dev, &mcp16502_desc[i], &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"failed to register %s regulator %ld\\n\",\n\t\t\t\tmcp16502_desc[i].name, PTR_ERR(rdev));\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\tmcp16502_gpio_set_mode(mcp, MCP16502_OPMODE_ACTIVE);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mcp16502_suspend_noirq(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mcp16502 *mcp = i2c_get_clientdata(client);\n\n\tmcp16502_gpio_set_mode(mcp, MCP16502_OPMODE_LPM);\n\n\treturn 0;\n}\n\nstatic int mcp16502_resume_noirq(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mcp16502 *mcp = i2c_get_clientdata(client);\n\n\tmcp16502_gpio_set_mode(mcp, MCP16502_OPMODE_ACTIVE);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic const struct dev_pm_ops mcp16502_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(mcp16502_suspend_noirq,\n\t\t\t\t      mcp16502_resume_noirq)\n};\n#endif\nstatic const struct i2c_device_id mcp16502_i2c_id[] = {\n\t{ \"mcp16502\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, mcp16502_i2c_id);\n\nstatic struct i2c_driver mcp16502_drv = {\n\t.probe\t\t= mcp16502_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"mcp16502-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table\t= mcp16502_ids,\n#ifdef CONFIG_PM\n\t\t.pm = &mcp16502_pm_ops,\n#endif\n\t},\n\t.id_table\t= mcp16502_i2c_id,\n};\n\nmodule_i2c_driver(mcp16502_drv);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MCP16502 PMIC driver\");\nMODULE_AUTHOR(\"Andrei Stefanescu andrei.stefanescu@microchip.com\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}