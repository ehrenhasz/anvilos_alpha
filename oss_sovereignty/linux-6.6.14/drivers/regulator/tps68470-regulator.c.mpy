{
  "module_name": "tps68470-regulator.c",
  "hash_id": "4cc92b81eb0abb2162fb03acbb2f8f5c6d7a25d5cb6e010fa0dbbd675a5a96a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/tps68470-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mfd/tps68470.h>\n#include <linux/module.h>\n#include <linux/platform_data/tps68470.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n\nstruct tps68470_regulator_data {\n\tstruct clk *clk;\n};\n\n#define TPS68470_REGULATOR(_name, _id, _ops, _n,\t\t\t\\\n\t\t\t   _vr, _vm, _er, _em, _lr, _nlr)\t\t\\\n\t[TPS68470_ ## _name] = {\t\t\t\t\t\\\n\t\t.name\t\t\t= # _name,\t\t\t\\\n\t\t.id\t\t\t= _id,\t\t\t\t\\\n\t\t.ops\t\t\t= &_ops,\t\t\t\\\n\t\t.n_voltages\t\t= _n,\t\t\t\t\\\n\t\t.type\t\t\t= REGULATOR_VOLTAGE,\t\t\\\n\t\t.owner\t\t\t= THIS_MODULE,\t\t\t\\\n\t\t.vsel_reg\t\t= _vr,\t\t\t\t\\\n\t\t.vsel_mask\t\t= _vm,\t\t\t\t\\\n\t\t.enable_reg\t\t= _er,\t\t\t\t\\\n\t\t.enable_mask\t\t= _em,\t\t\t\t\\\n\t\t.linear_ranges\t\t= _lr,\t\t\t\t\\\n\t\t.n_linear_ranges\t= _nlr,\t\t\t\t\\\n\t}\n\nstatic const struct linear_range tps68470_ldo_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(875000, 0, 125, 17800),\n};\n\nstatic const struct linear_range tps68470_core_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(900000, 0, 42, 25000),\n};\n\nstatic int tps68470_regulator_enable(struct regulator_dev *rdev)\n{\n\tstruct tps68470_regulator_data *data = rdev->reg_data;\n\tint ret;\n\n\t \n\tif (rdev->desc->id == TPS68470_CORE) {\n\t\tret = clk_prepare_enable(data->clk);\n\t\tif (ret) {\n\t\t\tdev_err(&rdev->dev, \"Error enabling TPS68470 clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn regulator_enable_regmap(rdev);\n}\n\nstatic int tps68470_regulator_disable(struct regulator_dev *rdev)\n{\n\tstruct tps68470_regulator_data *data = rdev->reg_data;\n\n\tif (rdev->desc->id == TPS68470_CORE)\n\t\tclk_disable_unprepare(data->clk);\n\n\treturn regulator_disable_regmap(rdev);\n}\n\n \nstatic const struct regulator_ops tps68470_regulator_ops = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= tps68470_regulator_enable,\n\t.disable\t\t= tps68470_regulator_disable,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n};\n\nstatic const struct regulator_ops tps68470_always_on_reg_ops = {\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n};\n\nstatic const struct regulator_desc regulators[] = {\n\tTPS68470_REGULATOR(CORE, TPS68470_CORE, tps68470_regulator_ops, 43,\n\t\t\t   TPS68470_REG_VDVAL, TPS68470_VDVAL_DVOLT_MASK,\n\t\t\t   TPS68470_REG_VDCTL, TPS68470_VDCTL_EN_MASK,\n\t\t\t   tps68470_core_ranges, ARRAY_SIZE(tps68470_core_ranges)),\n\tTPS68470_REGULATOR(ANA, TPS68470_ANA, tps68470_regulator_ops, 126,\n\t\t\t   TPS68470_REG_VAVAL, TPS68470_VAVAL_AVOLT_MASK,\n\t\t\t   TPS68470_REG_VACTL, TPS68470_VACTL_EN_MASK,\n\t\t\t   tps68470_ldo_ranges, ARRAY_SIZE(tps68470_ldo_ranges)),\n\tTPS68470_REGULATOR(VCM, TPS68470_VCM, tps68470_regulator_ops, 126,\n\t\t\t   TPS68470_REG_VCMVAL, TPS68470_VCMVAL_VCVOLT_MASK,\n\t\t\t   TPS68470_REG_VCMCTL, TPS68470_VCMCTL_EN_MASK,\n\t\t\t   tps68470_ldo_ranges, ARRAY_SIZE(tps68470_ldo_ranges)),\n\tTPS68470_REGULATOR(VIO, TPS68470_VIO, tps68470_always_on_reg_ops, 126,\n\t\t\t   TPS68470_REG_VIOVAL, TPS68470_VIOVAL_IOVOLT_MASK,\n\t\t\t   0, 0,\n\t\t\t   tps68470_ldo_ranges, ARRAY_SIZE(tps68470_ldo_ranges)),\n \n\tTPS68470_REGULATOR(VSIO, TPS68470_VSIO, tps68470_regulator_ops, 126,\n\t\t\t   TPS68470_REG_VSIOVAL, TPS68470_VSIOVAL_IOVOLT_MASK,\n\t\t\t   TPS68470_REG_S_I2C_CTL, TPS68470_S_I2C_CTL_EN_MASK,\n\t\t\t   tps68470_ldo_ranges, ARRAY_SIZE(tps68470_ldo_ranges)),\n\tTPS68470_REGULATOR(AUX1, TPS68470_AUX1, tps68470_regulator_ops, 126,\n\t\t\t   TPS68470_REG_VAUX1VAL, TPS68470_VAUX1VAL_AUX1VOLT_MASK,\n\t\t\t   TPS68470_REG_VAUX1CTL, TPS68470_VAUX1CTL_EN_MASK,\n\t\t\t   tps68470_ldo_ranges, ARRAY_SIZE(tps68470_ldo_ranges)),\n\tTPS68470_REGULATOR(AUX2, TPS68470_AUX2, tps68470_regulator_ops, 126,\n\t\t\t   TPS68470_REG_VAUX2VAL, TPS68470_VAUX2VAL_AUX2VOLT_MASK,\n\t\t\t   TPS68470_REG_VAUX2CTL, TPS68470_VAUX2CTL_EN_MASK,\n\t\t\t   tps68470_ldo_ranges, ARRAY_SIZE(tps68470_ldo_ranges)),\n};\n\nstatic int tps68470_regulator_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tps68470_regulator_platform_data *pdata = dev_get_platdata(dev);\n\tstruct tps68470_regulator_data *data;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tint i;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->clk = devm_clk_get(dev, \"tps68470-clk\");\n\tif (IS_ERR(data->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->clk), \"getting tps68470-clk\\n\");\n\n\tconfig.dev = dev->parent;\n\tconfig.regmap = dev_get_drvdata(dev->parent);\n\tconfig.driver_data = data;\n\n\tfor (i = 0; i < TPS68470_NUM_REGULATORS; i++) {\n\t\tif (pdata)\n\t\t\tconfig.init_data = pdata->reg_init_data[i];\n\t\telse\n\t\t\tconfig.init_data = NULL;\n\n\t\trdev = devm_regulator_register(dev, &regulators[i], &config);\n\t\tif (IS_ERR(rdev))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(rdev),\n\t\t\t\t\t     \"registering %s regulator\\n\",\n\t\t\t\t\t     regulators[i].name);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver tps68470_regulator_driver = {\n\t.driver = {\n\t\t.name = \"tps68470-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = tps68470_regulator_probe,\n};\n\n \nstatic int __init tps68470_regulator_init(void)\n{\n\treturn platform_driver_register(&tps68470_regulator_driver);\n}\nsubsys_initcall(tps68470_regulator_init);\n\nstatic void __exit tps68470_regulator_exit(void)\n{\n\tplatform_driver_unregister(&tps68470_regulator_driver);\n}\nmodule_exit(tps68470_regulator_exit);\n\nMODULE_ALIAS(\"platform:tps68470-regulator\");\nMODULE_DESCRIPTION(\"TPS68470 voltage regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}