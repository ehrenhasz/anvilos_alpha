{
  "module_name": "sy8827n.c",
  "hash_id": "11eafe482c322757e3f353a1c4b0638b32406670fb845e42327f786cd3abe2c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/sy8827n.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n#define SY8827N_VSEL0\t\t0\n#define   SY8827N_BUCK_EN\t(1 << 7)\n#define   SY8827N_MODE\t\t(1 << 6)\n#define SY8827N_VSEL1\t\t1\n#define SY8827N_CTRL\t\t2\n#define SY8827N_ID1\t\t3\n#define SY8827N_ID2\t\t4\n#define SY8827N_PGOOD\t\t5\n#define SY8827N_MAX\t\t(SY8827N_PGOOD + 1)\n\n#define SY8827N_NVOLTAGES\t64\n#define SY8827N_VSELMIN\t\t600000\n#define SY8827N_VSELSTEP\t12500\n\nstruct sy8827n_device_info {\n\tstruct device *dev;\n\tstruct regulator_desc desc;\n\tstruct regulator_init_data *regulator;\n\tstruct gpio_desc *en_gpio;\n\tunsigned int vsel_reg;\n};\n\nstatic int sy8827n_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct sy8827n_device_info *di = rdev_get_drvdata(rdev);\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tregmap_update_bits(rdev->regmap, di->vsel_reg,\n\t\t\t\t   SY8827N_MODE, SY8827N_MODE);\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tregmap_update_bits(rdev->regmap, di->vsel_reg,\n\t\t\t\t   SY8827N_MODE, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic unsigned int sy8827n_get_mode(struct regulator_dev *rdev)\n{\n\tstruct sy8827n_device_info *di = rdev_get_drvdata(rdev);\n\tu32 val;\n\tint ret = 0;\n\n\tret = regmap_read(rdev->regmap, di->vsel_reg, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (val & SY8827N_MODE)\n\t\treturn REGULATOR_MODE_FAST;\n\telse\n\t\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic const struct regulator_ops sy8827n_regulator_ops = {\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_time_sel = regulator_set_voltage_time_sel,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_mode = sy8827n_set_mode,\n\t.get_mode = sy8827n_get_mode,\n};\n\nstatic int sy8827n_regulator_register(struct sy8827n_device_info *di,\n\t\t\tstruct regulator_config *config)\n{\n\tstruct regulator_desc *rdesc = &di->desc;\n\tstruct regulator_dev *rdev;\n\n\trdesc->name = \"sy8827n-reg\";\n\trdesc->supply_name = \"vin\";\n\trdesc->ops = &sy8827n_regulator_ops;\n\trdesc->type = REGULATOR_VOLTAGE;\n\trdesc->n_voltages = SY8827N_NVOLTAGES;\n\trdesc->enable_reg = di->vsel_reg;\n\trdesc->enable_mask = SY8827N_BUCK_EN;\n\trdesc->min_uV = SY8827N_VSELMIN;\n\trdesc->uV_step = SY8827N_VSELSTEP;\n\trdesc->vsel_reg = di->vsel_reg;\n\trdesc->vsel_mask = rdesc->n_voltages - 1;\n\trdesc->owner = THIS_MODULE;\n\n\trdev = devm_regulator_register(di->dev, &di->desc, config);\n\treturn PTR_ERR_OR_ZERO(rdev);\n}\n\nstatic bool sy8827n_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tif (reg == SY8827N_PGOOD)\n\t\treturn true;\n\treturn false;\n}\n\nstatic const struct regmap_config sy8827n_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_reg = sy8827n_volatile_reg,\n\t.num_reg_defaults_raw = SY8827N_MAX,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int sy8827n_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct sy8827n_device_info *di;\n\tstruct regulator_config config = { };\n\tstruct regmap *regmap;\n\tint ret;\n\n\tdi = devm_kzalloc(dev, sizeof(struct sy8827n_device_info), GFP_KERNEL);\n\tif (!di)\n\t\treturn -ENOMEM;\n\n\tdi->regulator = of_get_regulator_init_data(dev, np, &di->desc);\n\tif (!di->regulator) {\n\t\tdev_err(dev, \"Platform data not found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdi->en_gpio = devm_gpiod_get_optional(dev, \"enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(di->en_gpio))\n\t\treturn PTR_ERR(di->en_gpio);\n\n\tif (of_property_read_bool(np, \"silergy,vsel-state-high\"))\n\t\tdi->vsel_reg = SY8827N_VSEL1;\n\telse\n\t\tdi->vsel_reg = SY8827N_VSEL0;\n\n\tdi->dev = dev;\n\n\tregmap = devm_regmap_init_i2c(client, &sy8827n_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"Failed to allocate regmap!\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\ti2c_set_clientdata(client, di);\n\n\tconfig.dev = di->dev;\n\tconfig.init_data = di->regulator;\n\tconfig.regmap = regmap;\n\tconfig.driver_data = di;\n\tconfig.of_node = np;\n\n\tret = sy8827n_regulator_register(di, &config);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to register regulator!\\n\");\n\treturn ret;\n}\n\nstatic const struct of_device_id sy8827n_dt_ids[] = {\n\t{\n\t\t.compatible = \"silergy,sy8827n\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sy8827n_dt_ids);\n\nstatic const struct i2c_device_id sy8827n_id[] = {\n\t{ \"sy8827n\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, sy8827n_id);\n\nstatic struct i2c_driver sy8827n_regulator_driver = {\n\t.driver = {\n\t\t.name = \"sy8827n-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = sy8827n_dt_ids,\n\t},\n\t.probe = sy8827n_i2c_probe,\n\t.id_table = sy8827n_id,\n};\nmodule_i2c_driver(sy8827n_regulator_driver);\n\nMODULE_AUTHOR(\"Jisheng Zhang <jszhang@kernel.org>\");\nMODULE_DESCRIPTION(\"SY8827N regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}