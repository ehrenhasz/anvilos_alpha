{
  "module_name": "vexpress-regulator.c",
  "hash_id": "03f4285c8e4b878cc2c0ece612656400131541cf4f4a4296c40b2516b6ca4d50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/vexpress-regulator.c",
  "human_readable_source": "\n\n\n\n#define DRVNAME \"vexpress-regulator\"\n#define pr_fmt(fmt) DRVNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/vexpress.h>\n\nstatic int vexpress_regulator_get_voltage(struct regulator_dev *regdev)\n{\n\tunsigned int uV;\n\tint err = regmap_read(regdev->regmap, 0, &uV);\n\n\treturn err ? err : uV;\n}\n\nstatic int vexpress_regulator_set_voltage(struct regulator_dev *regdev,\n\t\tint min_uV, int max_uV, unsigned *selector)\n{\n\treturn regmap_write(regdev->regmap, 0, min_uV);\n}\n\nstatic const struct regulator_ops vexpress_regulator_ops_ro = {\n\t.get_voltage = vexpress_regulator_get_voltage,\n};\n\nstatic const struct regulator_ops vexpress_regulator_ops = {\n\t.get_voltage = vexpress_regulator_get_voltage,\n\t.set_voltage = vexpress_regulator_set_voltage,\n};\n\nstatic int vexpress_regulator_probe(struct platform_device *pdev)\n{\n\tstruct regulator_desc *desc;\n\tstruct regulator_init_data *init_data;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tstruct regmap *regmap;\n\n\tdesc = devm_kzalloc(&pdev->dev, sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tregmap = devm_regmap_init_vexpress_config(&pdev->dev);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tdesc->name = dev_name(&pdev->dev);\n\tdesc->type = REGULATOR_VOLTAGE;\n\tdesc->owner = THIS_MODULE;\n\tdesc->continuous_voltage_range = true;\n\n\tinit_data = of_get_regulator_init_data(&pdev->dev, pdev->dev.of_node,\n\t\t\t\t\t       desc);\n\tif (!init_data)\n\t\treturn -EINVAL;\n\n\tinit_data->constraints.apply_uV = 0;\n\tif (init_data->constraints.min_uV && init_data->constraints.max_uV)\n\t\tdesc->ops = &vexpress_regulator_ops;\n\telse\n\t\tdesc->ops = &vexpress_regulator_ops_ro;\n\n\tconfig.regmap = regmap;\n\tconfig.dev = &pdev->dev;\n\tconfig.init_data = init_data;\n\tconfig.of_node = pdev->dev.of_node;\n\n\trdev = devm_regulator_register(&pdev->dev, desc, &config);\n\treturn PTR_ERR_OR_ZERO(rdev);\n}\n\nstatic const struct of_device_id vexpress_regulator_of_match[] = {\n\t{ .compatible = \"arm,vexpress-volt\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, vexpress_regulator_of_match);\n\nstatic struct platform_driver vexpress_regulator_driver = {\n\t.probe = vexpress_regulator_probe,\n\t.driver\t= {\n\t\t.name = DRVNAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = vexpress_regulator_of_match,\n\t},\n};\n\nmodule_platform_driver(vexpress_regulator_driver);\n\nMODULE_AUTHOR(\"Pawel Moll <pawel.moll@arm.com>\");\nMODULE_DESCRIPTION(\"Versatile Express regulator\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:vexpress-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}