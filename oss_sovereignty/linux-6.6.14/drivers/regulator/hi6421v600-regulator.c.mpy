{
  "module_name": "hi6421v600-regulator.c",
  "hash_id": "a1c6ac0414ea95feb2652b943153d16da1aa145403eb11c8561986231c1de91b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/hi6421v600-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/spmi.h>\n\nstruct hi6421_spmi_reg_priv {\n\t \n\tstruct mutex enable_mutex;\n};\n\nstruct hi6421_spmi_reg_info {\n\tstruct regulator_desc\tdesc;\n\tu8\t\t\teco_mode_mask;\n\tu32\t\t\teco_uA;\n};\n\nstatic const unsigned int range_1v5_to_2v0[] = {\n\t1500000, 1550000, 1600000, 1650000,\n\t1700000, 1725000, 1750000, 1775000,\n\t1800000, 1825000, 1850000, 1875000,\n\t1900000, 1925000, 1950000, 2000000\n};\n\nstatic const unsigned int range_1v725_to_1v9[] = {\n\t1725000, 1750000, 1775000, 1800000,\n\t1825000, 1850000, 1875000, 1900000\n};\n\nstatic const unsigned int range_1v75_to_3v3[] = {\n\t1750000, 1800000, 1825000, 2800000,\n\t2850000, 2950000, 3000000, 3300000\n};\n\nstatic const unsigned int range_1v8_to_3v0[] = {\n\t1800000, 1850000, 2400000, 2600000,\n\t2700000, 2850000, 2950000, 3000000\n};\n\nstatic const unsigned int range_2v5_to_3v3[] = {\n\t2500000, 2600000, 2700000, 2800000,\n\t3000000, 3100000, 3200000, 3300000\n};\n\nstatic const unsigned int range_2v6_to_3v3[] = {\n\t2600000, 2700000, 2800000, 2900000,\n\t3000000, 3100000, 3200000, 3300000\n};\n\n \n#define HI6421V600_LDO(_id, vtable, ereg, emask, vreg,\t\t\t       \\\n\t\t       odelay, etime, ecomask, ecoamp)\t\t\t       \\\n\t[hi6421v600_##_id] = {\t\t\t\t\t\t       \\\n\t\t.desc = {\t\t\t\t\t\t       \\\n\t\t\t.name\t\t= #_id,\t\t\t\t       \\\n\t\t\t.of_match        = of_match_ptr(#_id),\t\t       \\\n\t\t\t.regulators_node = of_match_ptr(\"regulators\"),\t       \\\n\t\t\t.ops\t\t= &hi6421_spmi_ldo_rops,\t       \\\n\t\t\t.type\t\t= REGULATOR_VOLTAGE,\t\t       \\\n\t\t\t.id\t\t= hi6421v600_##_id,\t\t       \\\n\t\t\t.owner\t\t= THIS_MODULE,\t\t\t       \\\n\t\t\t.volt_table\t= vtable,\t\t\t       \\\n\t\t\t.n_voltages\t= ARRAY_SIZE(vtable),\t\t       \\\n\t\t\t.vsel_mask\t= ARRAY_SIZE(vtable) - 1,\t       \\\n\t\t\t.vsel_reg\t= vreg,\t\t\t\t       \\\n\t\t\t.enable_reg\t= ereg,\t\t\t\t       \\\n\t\t\t.enable_mask\t= emask,\t\t\t       \\\n\t\t\t.enable_time\t= etime,\t\t\t       \\\n\t\t\t.ramp_delay\t= etime,\t\t\t       \\\n\t\t\t.off_on_delay\t= odelay,\t\t\t       \\\n\t\t},\t\t\t\t\t\t\t       \\\n\t\t.eco_mode_mask\t\t= ecomask,\t\t\t       \\\n\t\t.eco_uA\t\t\t= ecoamp,\t\t\t       \\\n\t}\n\nstatic int hi6421_spmi_regulator_enable(struct regulator_dev *rdev)\n{\n\tstruct hi6421_spmi_reg_priv *priv = rdev_get_drvdata(rdev);\n\tint ret;\n\n\t \n\tmutex_lock(&priv->enable_mutex);\n\n\tret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\n\t\t\t\t rdev->desc->enable_mask,\n\t\t\t\t rdev->desc->enable_mask);\n\n\t \n\tusleep_range(rdev->desc->off_on_delay, rdev->desc->off_on_delay + 60);\n\n\tmutex_unlock(&priv->enable_mutex);\n\n\treturn ret;\n}\n\nstatic unsigned int hi6421_spmi_regulator_get_mode(struct regulator_dev *rdev)\n{\n\tstruct hi6421_spmi_reg_info *sreg;\n\tunsigned int reg_val;\n\n\tsreg = container_of(rdev->desc, struct hi6421_spmi_reg_info, desc);\n\tregmap_read(rdev->regmap, rdev->desc->enable_reg, &reg_val);\n\n\tif (reg_val & sreg->eco_mode_mask)\n\t\treturn REGULATOR_MODE_IDLE;\n\n\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int hi6421_spmi_regulator_set_mode(struct regulator_dev *rdev,\n\t\t\t\t\t  unsigned int mode)\n{\n\tstruct hi6421_spmi_reg_info *sreg;\n\tunsigned int val;\n\n\tsreg = container_of(rdev->desc, struct hi6421_spmi_reg_info, desc);\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = 0;\n\t\tbreak;\n\tcase REGULATOR_MODE_IDLE:\n\t\tif (!sreg->eco_mode_mask)\n\t\t\treturn -EINVAL;\n\n\t\tval = sreg->eco_mode_mask;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\n\t\t\t\t  sreg->eco_mode_mask, val);\n}\n\nstatic unsigned int\nhi6421_spmi_regulator_get_optimum_mode(struct regulator_dev *rdev,\n\t\t\t\t       int input_uV, int output_uV,\n\t\t\t\t       int load_uA)\n{\n\tstruct hi6421_spmi_reg_info *sreg;\n\n\tsreg = container_of(rdev->desc, struct hi6421_spmi_reg_info, desc);\n\n\tif (!sreg->eco_uA || ((unsigned int)load_uA > sreg->eco_uA))\n\t\treturn REGULATOR_MODE_NORMAL;\n\n\treturn REGULATOR_MODE_IDLE;\n}\n\nstatic const struct regulator_ops hi6421_spmi_ldo_rops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = hi6421_spmi_regulator_enable,\n\t.disable = regulator_disable_regmap,\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_mode = hi6421_spmi_regulator_get_mode,\n\t.set_mode = hi6421_spmi_regulator_set_mode,\n\t.get_optimum_mode = hi6421_spmi_regulator_get_optimum_mode,\n};\n\n \nenum hi6421_spmi_regulator_id {\n\thi6421v600_ldo3,\n\thi6421v600_ldo4,\n\thi6421v600_ldo9,\n\thi6421v600_ldo15,\n\thi6421v600_ldo16,\n\thi6421v600_ldo17,\n\thi6421v600_ldo33,\n\thi6421v600_ldo34,\n};\n\nstatic struct hi6421_spmi_reg_info regulator_info[] = {\n\tHI6421V600_LDO(ldo3, range_1v5_to_2v0,\n\t\t       0x16, 0x01, 0x51,\n\t\t       20000, 120,\n\t\t       0, 0),\n\tHI6421V600_LDO(ldo4, range_1v725_to_1v9,\n\t\t       0x17, 0x01, 0x52,\n\t\t       20000, 120,\n\t\t       0x10, 10000),\n\tHI6421V600_LDO(ldo9, range_1v75_to_3v3,\n\t\t       0x1c, 0x01, 0x57,\n\t\t       20000, 360,\n\t\t       0x10, 10000),\n\tHI6421V600_LDO(ldo15, range_1v8_to_3v0,\n\t\t       0x21, 0x01, 0x5c,\n\t\t       20000, 360,\n\t\t       0x10, 10000),\n\tHI6421V600_LDO(ldo16, range_1v8_to_3v0,\n\t\t       0x22, 0x01, 0x5d,\n\t\t       20000, 360,\n\t\t       0x10, 10000),\n\tHI6421V600_LDO(ldo17, range_2v5_to_3v3,\n\t\t       0x23, 0x01, 0x5e,\n\t\t       20000, 120,\n\t\t       0x10, 10000),\n\tHI6421V600_LDO(ldo33, range_2v5_to_3v3,\n\t\t       0x32, 0x01, 0x6d,\n\t\t       20000, 120,\n\t\t       0, 0),\n\tHI6421V600_LDO(ldo34, range_2v6_to_3v3,\n\t\t       0x33, 0x01, 0x6e,\n\t\t       20000, 120,\n\t\t       0, 0),\n};\n\nstatic int hi6421_spmi_regulator_probe(struct platform_device *pdev)\n{\n\tstruct device *pmic_dev = pdev->dev.parent;\n\tstruct regulator_config config = { };\n\tstruct hi6421_spmi_reg_priv *priv;\n\tstruct hi6421_spmi_reg_info *info;\n\tstruct device *dev = &pdev->dev;\n\tstruct regmap *regmap;\n\tstruct regulator_dev *rdev;\n\tint i;\n\n\t \n\tregmap = dev_get_drvdata(pmic_dev);\n\tif (WARN_ON(!regmap))\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->enable_mutex);\n\n\tfor (i = 0; i < ARRAY_SIZE(regulator_info); i++) {\n\t\tinfo = &regulator_info[i];\n\n\t\tconfig.dev = pdev->dev.parent;\n\t\tconfig.driver_data = priv;\n\t\tconfig.regmap = regmap;\n\n\t\trdev = devm_regulator_register(dev, &info->desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(dev, \"failed to register %s\\n\",\n\t\t\t\tinfo->desc.name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id hi6421_spmi_regulator_table[] = {\n\t{ .name = \"hi6421v600-regulator\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, hi6421_spmi_regulator_table);\n\nstatic struct platform_driver hi6421_spmi_regulator_driver = {\n\t.id_table = hi6421_spmi_regulator_table,\n\t.driver = {\n\t\t.name = \"hi6421v600-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t= hi6421_spmi_regulator_probe,\n};\nmodule_platform_driver(hi6421_spmi_regulator_driver);\n\nMODULE_DESCRIPTION(\"Hi6421v600 SPMI regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}