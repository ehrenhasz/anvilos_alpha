{
  "module_name": "pf8x00-regulator.c",
  "hash_id": "a530484732a01e74107e15cc0fc9f2b8fc9b842d0cdea7ad33368ea1414b9fb1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/pf8x00-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n\n \n#define PF8X00_DEVICEID\t\t\t0x00\n#define PF8X00_REVID\t\t\t0x01\n#define PF8X00_EMREV\t\t\t0x02\n#define PF8X00_PROGID\t\t\t0x03\n#define PF8X00_IMS_INT\t\t\t0x04\n#define PF8X00_IMS_THERM\t\t0x07\n#define PF8X00_SW_MODE_INT\t\t0x0a\n#define PF8X00_SW_MODE_MASK\t\t0x0b\n#define PF8X00_IMS_SW_ILIM\t\t0x12\n#define PF8X00_IMS_LDO_ILIM\t\t0x15\n#define PF8X00_IMS_SW_UV\t\t0x18\n#define PF8X00_IMS_SW_OV\t\t0x1b\n#define PF8X00_IMS_LDO_UV\t\t0x1e\n#define PF8X00_IMS_LDO_OV\t\t0x21\n#define PF8X00_IMS_PWRON\t\t0x24\n#define PF8X00_SYS_INT\t\t\t0x27\n#define PF8X00_HARD_FAULT\t\t0x29\n#define PF8X00_FSOB_FLAGS\t\t0x2a\n#define PF8X00_FSOB_SELECT\t\t0x2b\n#define PF8X00_ABIST_OV1\t\t0x2c\n#define PF8X00_ABIST_OV2\t\t0x2d\n#define PF8X00_ABIST_UV1\t\t0x2e\n#define PF8X00_ABIST_UV2\t\t0x2f\n#define PF8X00_TEST_FLAGS\t\t0x30\n#define PF8X00_ABIST_RUN\t\t0x31\n#define PF8X00_RANDOM_GEN\t\t0x33\n#define PF8X00_RANDOM_CHK\t\t0x34\n#define PF8X00_VMONEN1\t\t\t0x35\n#define PF8X00_VMONEN2\t\t\t0x36\n#define PF8X00_CTRL1\t\t\t0x37\n#define PF8X00_CTRL2\t\t\t0x38\n#define PF8X00_CTRL3\t\t\t0x39\n#define PF8X00_PWRUP_CTRL\t\t0x3a\n#define PF8X00_RESETBMCU\t\t0x3c\n#define PF8X00_PGOOD\t\t\t0x3d\n#define PF8X00_PWRDN_DLY1\t\t0x3e\n#define PF8X00_PWRDN_DLY2\t\t0x3f\n#define PF8X00_FREQ_CTRL\t\t0x40\n#define PF8X00_COINCELL_CTRL\t\t0x41\n#define PF8X00_PWRON\t\t\t0x42\n#define PF8X00_WD_CONFIG\t\t0x43\n#define PF8X00_WD_CLEAR\t\t\t0x44\n#define PF8X00_WD_EXPIRE\t\t0x45\n#define PF8X00_WD_COUNTER\t\t0x46\n#define PF8X00_FAULT_COUNTER\t\t0x47\n#define PF8X00_FSAFE_COUNTER\t\t0x48\n#define PF8X00_FAULT_TIMER\t\t0x49\n#define PF8X00_AMUX\t\t\t0x4a\n#define PF8X00_SW1_CONFIG1\t\t0x4d\n#define PF8X00_LDO1_CONFIG1\t\t0x85\n#define PF8X00_VSNVS_CONFIG1\t\t0x9d\n#define PF8X00_PAGE_SELECT\t\t0x9f\n\n \nenum pf8x00_regulators {\n\tPF8X00_LDO1,\n\tPF8X00_LDO2,\n\tPF8X00_LDO3,\n\tPF8X00_LDO4,\n\tPF8X00_BUCK1,\n\tPF8X00_BUCK2,\n\tPF8X00_BUCK3,\n\tPF8X00_BUCK4,\n\tPF8X00_BUCK5,\n\tPF8X00_BUCK6,\n\tPF8X00_BUCK7,\n\tPF8X00_VSNVS,\n\n\tPF8X00_MAX_REGULATORS,\n};\n\nenum pf8x00_buck_states {\n\tSW_CONFIG1,\n\tSW_CONFIG2,\n\tSW_PWRUP,\n\tSW_MODE1,\n\tSW_RUN_VOLT,\n\tSW_STBY_VOLT,\n};\n#define PF8X00_SW_BASE(i)\t\t(8 * (i - PF8X00_BUCK1) + PF8X00_SW1_CONFIG1)\n\nenum pf8x00_ldo_states {\n\tLDO_CONFIG1,\n\tLDO_CONFIG2,\n\tLDO_PWRUP,\n\tLDO_RUN_VOLT,\n\tLDO_STBY_VOLT,\n};\n#define PF8X00_LDO_BASE(i)\t\t(6 * (i - PF8X00_LDO1) + PF8X00_LDO1_CONFIG1)\n\nenum swxilim_bits {\n\tSWXILIM_2100_MA,\n\tSWXILIM_2600_MA,\n\tSWXILIM_3000_MA,\n\tSWXILIM_4500_MA,\n};\n#define PF8X00_SWXILIM_SHIFT\t\t3\n#define PF8X00_SWXILIM_MASK\t\tGENMASK(4, 3)\n#define PF8X00_SWXPHASE_MASK\t\tGENMASK(2, 0)\n#define PF8X00_SWXPHASE_SHIFT\t\t7\n\nenum pf8x00_devid {\n\tPF8100\t\t\t= 0x0,\n\tPF8121A\t\t\t= BIT(1),\n\tPF8200\t\t\t= BIT(3),\n};\n#define PF8X00_FAM\t\t\tBIT(6)\n#define PF8X00_DEVICE_FAM_MASK\t\tGENMASK(7, 4)\n#define PF8X00_DEVICE_ID_MASK\t\tGENMASK(3, 0)\n\nstruct pf8x00_regulator_data {\n\tstruct regulator_desc desc;\n\tunsigned int suspend_enable_reg;\n\tunsigned int suspend_enable_mask;\n\tunsigned int suspend_voltage_reg;\n\tunsigned int suspend_voltage_cache;\n};\n\nstruct pf8x00_chip {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n};\n\nstatic const struct regmap_config pf8x00_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = PF8X00_PAGE_SELECT,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\n \nstatic const int pf8x00_ldo_voltages[] = {\n\t1500000, 1600000, 1800000, 1850000, 2150000, 2500000, 2800000, 3000000,\n\t3100000, 3150000, 3200000, 3300000, 3350000, 1650000, 1700000, 5000000,\n};\n\n \nstatic const unsigned int pf8x00_sw_current_table[] = {\n\t2100000, 2600000, 3000000, 4500000,\n};\n\n \n#define PF8XOO_SW1_6_VOLTAGE_NUM 0xB2\nstatic const struct linear_range pf8x00_sw1_to_6_voltages[] = {\n\tREGULATOR_LINEAR_RANGE(400000, 0x00, 0xB0, 6250),\n\tREGULATOR_LINEAR_RANGE(1800000, 0xB1, 0xB1, 0),\n};\n\n \nstatic const int pf8x00_sw7_voltages[] = {\n\t1000000, 1100000, 1200000, 1250000, 1300000, 1350000, 1500000, 1600000,\n\t1800000, 1850000, 2000000, 2100000, 2150000, 2250000, 2300000, 2400000,\n\t2500000, 2800000, 3150000, 3200000, 3250000, 3300000, 3350000, 3400000,\n\t3500000, 3800000, 4000000, 4100000, 4100000, 4100000, 4100000, 4100000,\n};\n\n \nstatic const int pf8x00_vsnvs_voltages[] = {\n\t0, 1800000, 3000000, 3300000,\n};\n\nstatic void swxilim_select(struct pf8x00_chip *chip, int id, int ilim)\n{\n\tu8 ilim_sel;\n\tu8 reg = PF8X00_SW_BASE(id) + SW_CONFIG2;\n\n\tswitch (ilim) {\n\tcase 2100:\n\t\tilim_sel = SWXILIM_2100_MA;\n\t\tbreak;\n\tcase 2600:\n\t\tilim_sel = SWXILIM_2600_MA;\n\t\tbreak;\n\tcase 3000:\n\t\tilim_sel = SWXILIM_3000_MA;\n\t\tbreak;\n\tcase 4500:\n\t\tilim_sel = SWXILIM_4500_MA;\n\t\tbreak;\n\tdefault:\n\t\tilim_sel = SWXILIM_2100_MA;\n\t\tbreak;\n\t}\n\n\tregmap_update_bits(chip->regmap, reg,\n\t\t\t\t\tPF8X00_SWXILIM_MASK,\n\t\t\t\t\tilim_sel << PF8X00_SWXILIM_SHIFT);\n}\n\nstatic void handle_ilim_property(struct device_node *np,\n\t\t\t      const struct regulator_desc *desc,\n\t\t\t      struct regulator_config *config)\n{\n\tstruct pf8x00_chip *chip = config->driver_data;\n\tint ret;\n\tint val;\n\n\tif ((desc->id >= PF8X00_BUCK1) && (desc->id <= PF8X00_BUCK7)) {\n\t\tret = of_property_read_u32(np, \"nxp,ilim-ma\", &val);\n\t\tif (ret) {\n\t\t\tdev_dbg(chip->dev, \"unspecified ilim for BUCK%d, use value stored in OTP\\n\",\n\t\t\t\tdesc->id - PF8X00_LDO4);\n\t\t\treturn;\n\t\t}\n\n\t\tdev_warn(chip->dev, \"nxp,ilim-ma is deprecated, please use regulator-max-microamp\\n\");\n\t\tswxilim_select(chip, desc->id, val);\n\n\t} else\n\t\tdev_warn(chip->dev, \"nxp,ilim-ma used with incorrect regulator (%d)\\n\", desc->id);\n}\n\nstatic void handle_shift_property(struct device_node *np,\n\t\t\t      const struct regulator_desc *desc,\n\t\t\t      struct regulator_config *config)\n{\n\tunsigned char id = desc->id - PF8X00_LDO4;\n\tunsigned char reg = PF8X00_SW_BASE(id) + SW_CONFIG2;\n\tstruct pf8x00_chip *chip = config->driver_data;\n\n\tint phase;\n\tint val;\n\tint ret;\n\tif ((desc->id >= PF8X00_BUCK1) && (desc->id <= PF8X00_BUCK7)) {\n\t\tret = of_property_read_u32(np, \"nxp,phase-shift\", &val);\n\t\tif (ret) {\n\t\t\tdev_dbg(chip->dev,\n\t\t\t\t\"unspecified phase-shift for BUCK%d, using OTP configuration\\n\",\n\t\t\t\tid);\n\t\t\treturn;\n\t\t}\n\n\t\tif (val < 0 || val > 315 || val % 45 != 0) {\n\t\t\tdev_warn(config->dev,\n\t\t\t\t\"invalid phase_shift %d for BUCK%d, using OTP configuration\\n\",\n\t\t\t\tval, id);\n\t\t\treturn;\n\t\t}\n\n\t\tphase = val / 45;\n\n\t\tif (phase >= 1)\n\t\t\tphase -= 1;\n\t\telse\n\t\t\tphase = PF8X00_SWXPHASE_SHIFT;\n\n\t\tregmap_update_bits(chip->regmap, reg,\n\t\t\t\tPF8X00_SWXPHASE_MASK,\n\t\t\t\tphase);\n\t} else\n\t\tdev_warn(chip->dev, \"nxp,phase-shift used with incorrect regulator (%d)\\n\", id);\n\n}\n\nstatic int pf8x00_of_parse_cb(struct device_node *np,\n\t\t\t      const struct regulator_desc *desc,\n\t\t\t      struct regulator_config *config)\n{\n\n\thandle_ilim_property(np, desc, config);\n\thandle_shift_property(np, desc, config);\n\n\treturn 0;\n}\n\nstatic int pf8x00_suspend_enable(struct regulator_dev *rdev)\n{\n\tstruct pf8x00_regulator_data *regl = rdev_get_drvdata(rdev);\n\tstruct regmap *rmap = rdev_get_regmap(rdev);\n\n\treturn regmap_update_bits(rmap, regl->suspend_enable_reg,\n\t\t\t\t  regl->suspend_enable_mask,\n\t\t\t\t  regl->suspend_enable_mask);\n}\n\nstatic int pf8x00_suspend_disable(struct regulator_dev *rdev)\n{\n\tstruct pf8x00_regulator_data *regl = rdev_get_drvdata(rdev);\n\tstruct regmap *rmap = rdev_get_regmap(rdev);\n\n\treturn regmap_update_bits(rmap, regl->suspend_enable_reg,\n\t\t\t\t  regl->suspend_enable_mask, 0);\n}\n\nstatic int pf8x00_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tstruct pf8x00_regulator_data *regl = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tif (regl->suspend_voltage_cache == uV)\n\t\treturn 0;\n\n\tret = regulator_map_voltage_iterate(rdev, uV, uV);\n\tif (ret < 0) {\n\t\tdev_err(rdev_get_dev(rdev), \"failed to map %i uV\\n\", uV);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(rdev_get_dev(rdev), \"uV: %i, reg: 0x%x, msk: 0x%x, val: 0x%x\\n\",\n\t\tuV, regl->suspend_voltage_reg, regl->desc.vsel_mask, ret);\n\tret = regmap_update_bits(rdev->regmap, regl->suspend_voltage_reg,\n\t\t\t\t regl->desc.vsel_mask, ret);\n\tif (ret < 0) {\n\t\tdev_err(rdev_get_dev(rdev), \"failed to set %i uV\\n\", uV);\n\t\treturn ret;\n\t}\n\n\tregl->suspend_voltage_cache = uV;\n\n\treturn 0;\n}\n\nstatic const struct regulator_ops pf8x00_ldo_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_table,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_suspend_enable = pf8x00_suspend_enable,\n\t.set_suspend_disable = pf8x00_suspend_disable,\n\t.set_suspend_voltage = pf8x00_set_suspend_voltage,\n};\n\n\nstatic const struct regulator_ops pf8x00_buck1_6_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.get_current_limit = regulator_get_current_limit_regmap,\n\t.set_current_limit = regulator_set_current_limit_regmap,\n\t.set_suspend_enable = pf8x00_suspend_enable,\n\t.set_suspend_disable = pf8x00_suspend_disable,\n\t.set_suspend_voltage = pf8x00_set_suspend_voltage,\n};\n\nstatic const struct regulator_ops pf8x00_buck7_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.get_current_limit = regulator_get_current_limit_regmap,\n\t.set_current_limit = regulator_set_current_limit_regmap,\n\t.set_suspend_enable = pf8x00_suspend_enable,\n\t.set_suspend_disable = pf8x00_suspend_disable,\n};\n\nstatic const struct regulator_ops pf8x00_vsnvs_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n};\n\n#define PF8X00LDO(_id, _name, base, voltages)\t\t\t\\\n\t[PF8X00_LDO ## _id] = {\t\t\t\t\t\\\n\t\t.desc = {\t\t\t\t\t\\\n\t\t\t.name = _name,\t\t\t\t\\\n\t\t\t.of_match = _name,\t\t\t\\\n\t\t\t.regulators_node = \"regulators\",\t\\\n\t\t\t.n_voltages = ARRAY_SIZE(voltages),\t\\\n\t\t\t.ops = &pf8x00_ldo_ops,\t\t\t\\\n\t\t\t.type = REGULATOR_VOLTAGE,\t\t\\\n\t\t\t.id = PF8X00_LDO ## _id,\t\t\\\n\t\t\t.owner = THIS_MODULE,\t\t\t\\\n\t\t\t.volt_table = voltages,\t\t\t\\\n\t\t\t.vsel_reg = (base) + LDO_RUN_VOLT,\t\\\n\t\t\t.vsel_mask = 0xff,\t\t\t\\\n\t\t\t.enable_reg = (base) + LDO_CONFIG2,\t\\\n\t\t\t.enable_val = 0x2,\t\t\t\\\n\t\t\t.disable_val = 0x0,\t\t\t\\\n\t\t\t.enable_mask = 2,\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.suspend_enable_reg = (base) + LDO_CONFIG2,\t\\\n\t\t.suspend_enable_mask = 1,\t\t\t\\\n\t\t.suspend_voltage_reg = (base) + LDO_STBY_VOLT,\t\\\n\t}\n\n#define PF8X00BUCK(_id, _name, base, voltages)\t\t\t\\\n\t[PF8X00_BUCK ## _id] = {\t\t\t\t\\\n\t\t.desc = {\t\t\t\t\t\\\n\t\t\t.name = _name,\t\t\t\t\\\n\t\t\t.of_match = _name,\t\t\t\\\n\t\t\t.regulators_node = \"regulators\",\t\\\n\t\t\t.of_parse_cb = pf8x00_of_parse_cb,\t\\\n\t\t\t.n_voltages = PF8XOO_SW1_6_VOLTAGE_NUM,\t\\\n\t\t\t.ops = &pf8x00_buck1_6_ops,\t\t\\\n\t\t\t.type = REGULATOR_VOLTAGE,\t\t\\\n\t\t\t.id = PF8X00_BUCK ## _id,\t\t\\\n\t\t\t.owner = THIS_MODULE,\t\t\t\\\n\t\t\t.ramp_delay = 19000,\t\t\t\\\n\t\t\t.linear_ranges = pf8x00_sw1_to_6_voltages, \\\n\t\t\t.n_linear_ranges = \\\n\t\t\t\tARRAY_SIZE(pf8x00_sw1_to_6_voltages), \\\n\t\t\t.vsel_reg = (base) + SW_RUN_VOLT,\t\\\n\t\t\t.vsel_mask = 0xff,\t\t\t\\\n\t\t\t.curr_table = pf8x00_sw_current_table, \\\n\t\t\t.n_current_limits = \\\n\t\t\t\tARRAY_SIZE(pf8x00_sw_current_table), \\\n\t\t\t.csel_reg = (base) + SW_CONFIG2,\t\\\n\t\t\t.csel_mask = PF8X00_SWXILIM_MASK,\t\\\n\t\t\t.enable_reg = (base) + SW_MODE1,\t\\\n\t\t\t.enable_val = 0x3,\t\t\t\\\n\t\t\t.disable_val = 0x0,\t\t\t\\\n\t\t\t.enable_mask = 0x3,\t\t\t\\\n\t\t\t.enable_time = 500,\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.suspend_enable_reg = (base) + SW_MODE1,\t\\\n\t\t.suspend_enable_mask = 0xc,\t\t\t\\\n\t\t.suspend_voltage_reg = (base) + SW_STBY_VOLT,\t\\\n\t}\n\n#define PF8X00BUCK7(_name, base, voltages)\t\t\t\\\n\t[PF8X00_BUCK7] = {\t\t\t\t\\\n\t\t.desc = {\t\t\t\t\t\\\n\t\t\t.name = _name,\t\t\t\t\\\n\t\t\t.of_match = _name,\t\t\t\\\n\t\t\t.regulators_node = \"regulators\",\t\\\n\t\t\t.of_parse_cb = pf8x00_of_parse_cb,\t\\\n\t\t\t.n_voltages = ARRAY_SIZE(voltages),\t\\\n\t\t\t.ops = &pf8x00_buck7_ops,\t\t\\\n\t\t\t.type = REGULATOR_VOLTAGE,\t\t\\\n\t\t\t.id = PF8X00_BUCK7,\t\t\\\n\t\t\t.owner = THIS_MODULE,\t\t\t\\\n\t\t\t.ramp_delay = 19000,\t\t\t\\\n\t\t\t.volt_table = voltages,\t\t\t\\\n\t\t\t.vsel_reg = (base) + SW_RUN_VOLT,\t\\\n\t\t\t.vsel_mask = 0xff,\t\t\t\\\n\t\t\t.curr_table = pf8x00_sw_current_table, \\\n\t\t\t.n_current_limits = \\\n\t\t\t\tARRAY_SIZE(pf8x00_sw_current_table), \\\n\t\t\t.csel_reg = (base) + SW_CONFIG2,\t\\\n\t\t\t.csel_mask = PF8X00_SWXILIM_MASK,\t\\\n\t\t\t.enable_reg = (base) + SW_MODE1,\t\\\n\t\t\t.enable_val = 0x3,\t\t\t\\\n\t\t\t.disable_val = 0x0,\t\t\t\\\n\t\t\t.enable_mask = 0x3,\t\t\t\\\n\t\t\t.enable_time = 500,\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t}\n\n\n#define PF8X00VSNVS(_name, base, voltages)\t\t\t\\\n\t[PF8X00_VSNVS] = {\t\t\t\t\t\\\n\t\t.desc = {\t\t\t\t\t\\\n\t\t\t.name = _name,\t\t\t\t\\\n\t\t\t.of_match = _name,\t\t\t\\\n\t\t\t.regulators_node = \"regulators\",\t\\\n\t\t\t.n_voltages = ARRAY_SIZE(voltages),\t\\\n\t\t\t.ops = &pf8x00_vsnvs_ops,\t\t\\\n\t\t\t.type = REGULATOR_VOLTAGE,\t\t\\\n\t\t\t.id = PF8X00_VSNVS,\t\t\t\\\n\t\t\t.owner = THIS_MODULE,\t\t\t\\\n\t\t\t.volt_table = voltages,\t\t\t\\\n\t\t\t.vsel_reg = (base),\t\t\t\\\n\t\t\t.vsel_mask = 0x3,\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t}\n\nstatic struct pf8x00_regulator_data pf8x00_regs_data[PF8X00_MAX_REGULATORS] = {\n\tPF8X00LDO(1, \"ldo1\", PF8X00_LDO_BASE(PF8X00_LDO1), pf8x00_ldo_voltages),\n\tPF8X00LDO(2, \"ldo2\", PF8X00_LDO_BASE(PF8X00_LDO2), pf8x00_ldo_voltages),\n\tPF8X00LDO(3, \"ldo3\", PF8X00_LDO_BASE(PF8X00_LDO3), pf8x00_ldo_voltages),\n\tPF8X00LDO(4, \"ldo4\", PF8X00_LDO_BASE(PF8X00_LDO4), pf8x00_ldo_voltages),\n\tPF8X00BUCK(1, \"buck1\", PF8X00_SW_BASE(PF8X00_BUCK1), pf8x00_sw1_to_6_voltages),\n\tPF8X00BUCK(2, \"buck2\", PF8X00_SW_BASE(PF8X00_BUCK2), pf8x00_sw1_to_6_voltages),\n\tPF8X00BUCK(3, \"buck3\", PF8X00_SW_BASE(PF8X00_BUCK3), pf8x00_sw1_to_6_voltages),\n\tPF8X00BUCK(4, \"buck4\", PF8X00_SW_BASE(PF8X00_BUCK4), pf8x00_sw1_to_6_voltages),\n\tPF8X00BUCK(5, \"buck5\", PF8X00_SW_BASE(PF8X00_BUCK5), pf8x00_sw1_to_6_voltages),\n\tPF8X00BUCK(6, \"buck6\", PF8X00_SW_BASE(PF8X00_BUCK6), pf8x00_sw1_to_6_voltages),\n\tPF8X00BUCK7(\"buck7\", PF8X00_SW_BASE(PF8X00_BUCK7), pf8x00_sw7_voltages),\n\tPF8X00VSNVS(\"vsnvs\", PF8X00_VSNVS_CONFIG1, pf8x00_vsnvs_voltages),\n};\n\nstatic int pf8x00_identify(struct pf8x00_chip *chip)\n{\n\tunsigned int value;\n\tu8 dev_fam, dev_id;\n\tconst char *name = NULL;\n\tint ret;\n\n\tret = regmap_read(chip->regmap, PF8X00_DEVICEID, &value);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"failed to read chip family\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_fam = value & PF8X00_DEVICE_FAM_MASK;\n\tswitch (dev_fam) {\n\tcase PF8X00_FAM:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->dev,\n\t\t\t\"Chip 0x%x is not from PF8X00 family\\n\", dev_fam);\n\t\treturn ret;\n\t}\n\n\tdev_id = value & PF8X00_DEVICE_ID_MASK;\n\tswitch (dev_id) {\n\tcase PF8100:\n\t\tname = \"PF8100\";\n\t\tbreak;\n\tcase PF8121A:\n\t\tname = \"PF8121A\";\n\t\tbreak;\n\tcase PF8200:\n\t\tname = \"PF8200\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->dev, \"Unknown pf8x00 device id 0x%x\\n\", dev_id);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(chip->dev, \"%s PMIC found.\\n\", name);\n\n\treturn 0;\n}\n\nstatic int pf8x00_i2c_probe(struct i2c_client *client)\n{\n\tstruct regulator_config config = { NULL, };\n\tstruct pf8x00_chip *chip;\n\tint id;\n\tint ret;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, chip);\n\tchip->dev = &client->dev;\n\n\tchip->regmap = devm_regmap_init_i2c(client, &pf8x00_regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\tret = PTR_ERR(chip->regmap);\n\t\tdev_err(&client->dev,\n\t\t\t\"regmap allocation failed with err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pf8x00_identify(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (id = 0; id < ARRAY_SIZE(pf8x00_regs_data); id++) {\n\t\tstruct pf8x00_regulator_data *data = &pf8x00_regs_data[id];\n\t\tstruct regulator_dev *rdev;\n\n\t\tconfig.dev = chip->dev;\n\t\tconfig.driver_data = data;\n\t\tconfig.regmap = chip->regmap;\n\n\t\trdev = devm_regulator_register(&client->dev, &data->desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"failed to register %s regulator\\n\", data->desc.name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id pf8x00_dt_ids[] = {\n\t{ .compatible = \"nxp,pf8100\",},\n\t{ .compatible = \"nxp,pf8121a\",},\n\t{ .compatible = \"nxp,pf8200\",},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pf8x00_dt_ids);\n\nstatic const struct i2c_device_id pf8x00_i2c_id[] = {\n\t{ \"pf8100\", 0 },\n\t{ \"pf8121a\", 0 },\n\t{ \"pf8200\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, pf8x00_i2c_id);\n\nstatic struct i2c_driver pf8x00_regulator_driver = {\n\t.id_table = pf8x00_i2c_id,\n\t.driver = {\n\t\t.name = \"pf8x00\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = pf8x00_dt_ids,\n\t},\n\t.probe = pf8x00_i2c_probe,\n};\nmodule_i2c_driver(pf8x00_regulator_driver);\n\nMODULE_AUTHOR(\"Jagan Teki <jagan@amarulasolutions.com>\");\nMODULE_AUTHOR(\"Troy Kisky <troy.kisky@boundarydevices.com>\");\nMODULE_DESCRIPTION(\"Regulator Driver for NXP's PF8100/PF8121A/PF8200 PMIC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}