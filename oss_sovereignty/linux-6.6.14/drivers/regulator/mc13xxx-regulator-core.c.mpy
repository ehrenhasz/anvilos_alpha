{
  "module_name": "mc13xxx-regulator-core.c",
  "hash_id": "3467cc836dd9baf9f82a761c966e1f109d4611e6228aec796af932341d6d1a34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/mc13xxx-regulator-core.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/mfd/mc13xxx.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include \"mc13xxx.h\"\n\nstatic int mc13xxx_regulator_enable(struct regulator_dev *rdev)\n{\n\tstruct mc13xxx_regulator_priv *priv = rdev_get_drvdata(rdev);\n\tstruct mc13xxx_regulator *mc13xxx_regulators = priv->mc13xxx_regulators;\n\tint id = rdev_get_id(rdev);\n\n\tdev_dbg(rdev_get_dev(rdev), \"%s id: %d\\n\", __func__, id);\n\n\treturn mc13xxx_reg_rmw(priv->mc13xxx, mc13xxx_regulators[id].reg,\n\t\t\t       mc13xxx_regulators[id].enable_bit,\n\t\t\t       mc13xxx_regulators[id].enable_bit);\n}\n\nstatic int mc13xxx_regulator_disable(struct regulator_dev *rdev)\n{\n\tstruct mc13xxx_regulator_priv *priv = rdev_get_drvdata(rdev);\n\tstruct mc13xxx_regulator *mc13xxx_regulators = priv->mc13xxx_regulators;\n\tint id = rdev_get_id(rdev);\n\n\tdev_dbg(rdev_get_dev(rdev), \"%s id: %d\\n\", __func__, id);\n\n\treturn mc13xxx_reg_rmw(priv->mc13xxx, mc13xxx_regulators[id].reg,\n\t\t\t       mc13xxx_regulators[id].enable_bit, 0);\n}\n\nstatic int mc13xxx_regulator_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct mc13xxx_regulator_priv *priv = rdev_get_drvdata(rdev);\n\tstruct mc13xxx_regulator *mc13xxx_regulators = priv->mc13xxx_regulators;\n\tint ret, id = rdev_get_id(rdev);\n\tunsigned int val;\n\n\tret = mc13xxx_reg_read(priv->mc13xxx, mc13xxx_regulators[id].reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (val & mc13xxx_regulators[id].enable_bit) != 0;\n}\n\nstatic int mc13xxx_regulator_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\t     unsigned selector)\n{\n\tstruct mc13xxx_regulator_priv *priv = rdev_get_drvdata(rdev);\n\tstruct mc13xxx_regulator *mc13xxx_regulators = priv->mc13xxx_regulators;\n\tint id = rdev_get_id(rdev);\n\n\treturn mc13xxx_reg_rmw(priv->mc13xxx, mc13xxx_regulators[id].vsel_reg,\n\t\t\t       mc13xxx_regulators[id].vsel_mask,\n\t\t\t       selector << mc13xxx_regulators[id].vsel_shift);\n}\n\nstatic int mc13xxx_regulator_get_voltage(struct regulator_dev *rdev)\n{\n\tstruct mc13xxx_regulator_priv *priv = rdev_get_drvdata(rdev);\n\tstruct mc13xxx_regulator *mc13xxx_regulators = priv->mc13xxx_regulators;\n\tint ret, id = rdev_get_id(rdev);\n\tunsigned int val;\n\n\tdev_dbg(rdev_get_dev(rdev), \"%s id: %d\\n\", __func__, id);\n\n\tret = mc13xxx_reg_read(priv->mc13xxx,\n\t\t\t\tmc13xxx_regulators[id].vsel_reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = (val & mc13xxx_regulators[id].vsel_mask)\n\t\t>> mc13xxx_regulators[id].vsel_shift;\n\n\tdev_dbg(rdev_get_dev(rdev), \"%s id: %d val: %d\\n\", __func__, id, val);\n\n\tBUG_ON(val >= mc13xxx_regulators[id].desc.n_voltages);\n\n\treturn rdev->desc->volt_table[val];\n}\n\nconst struct regulator_ops mc13xxx_regulator_ops = {\n\t.enable = mc13xxx_regulator_enable,\n\t.disable = mc13xxx_regulator_disable,\n\t.is_enabled = mc13xxx_regulator_is_enabled,\n\t.list_voltage = regulator_list_voltage_table,\n\t.set_voltage_sel = mc13xxx_regulator_set_voltage_sel,\n\t.get_voltage = mc13xxx_regulator_get_voltage,\n};\nEXPORT_SYMBOL_GPL(mc13xxx_regulator_ops);\n\nint mc13xxx_fixed_regulator_set_voltage(struct regulator_dev *rdev, int min_uV,\n\t       int max_uV, unsigned *selector)\n{\n\tint id = rdev_get_id(rdev);\n\n\tdev_dbg(rdev_get_dev(rdev), \"%s id: %d min_uV: %d max_uV: %d\\n\",\n\t\t__func__, id, min_uV, max_uV);\n\n\tif (min_uV <= rdev->desc->volt_table[0] &&\n\t    rdev->desc->volt_table[0] <= max_uV) {\n\t\t*selector = 0;\n\t\treturn 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL_GPL(mc13xxx_fixed_regulator_set_voltage);\n\nconst struct regulator_ops mc13xxx_fixed_regulator_ops = {\n\t.enable = mc13xxx_regulator_enable,\n\t.disable = mc13xxx_regulator_disable,\n\t.is_enabled = mc13xxx_regulator_is_enabled,\n\t.list_voltage = regulator_list_voltage_table,\n\t.set_voltage = mc13xxx_fixed_regulator_set_voltage,\n};\nEXPORT_SYMBOL_GPL(mc13xxx_fixed_regulator_ops);\n\n#ifdef CONFIG_OF\nint mc13xxx_get_num_regulators_dt(struct platform_device *pdev)\n{\n\tstruct device_node *parent;\n\tint num;\n\n\tif (!pdev->dev.parent->of_node)\n\t\treturn -ENODEV;\n\n\tparent = of_get_child_by_name(pdev->dev.parent->of_node, \"regulators\");\n\tif (!parent)\n\t\treturn -ENODEV;\n\n\tnum = of_get_child_count(parent);\n\tof_node_put(parent);\n\treturn num;\n}\nEXPORT_SYMBOL_GPL(mc13xxx_get_num_regulators_dt);\n\nstruct mc13xxx_regulator_init_data *mc13xxx_parse_regulators_dt(\n\tstruct platform_device *pdev, struct mc13xxx_regulator *regulators,\n\tint num_regulators)\n{\n\tstruct mc13xxx_regulator_priv *priv = platform_get_drvdata(pdev);\n\tstruct mc13xxx_regulator_init_data *data, *p;\n\tstruct device_node *parent, *child;\n\tint i, parsed = 0;\n\n\tif (!pdev->dev.parent->of_node)\n\t\treturn NULL;\n\n\tparent = of_get_child_by_name(pdev->dev.parent->of_node, \"regulators\");\n\tif (!parent)\n\t\treturn NULL;\n\n\tdata = devm_kcalloc(&pdev->dev, priv->num_regulators, sizeof(*data),\n\t\t\t    GFP_KERNEL);\n\tif (!data) {\n\t\tof_node_put(parent);\n\t\treturn NULL;\n\t}\n\n\tp = data;\n\n\tfor_each_child_of_node(parent, child) {\n\t\tint found = 0;\n\n\t\tfor (i = 0; i < num_regulators; i++) {\n\t\t\tif (!regulators[i].desc.name)\n\t\t\t\tcontinue;\n\t\t\tif (of_node_name_eq(child,\n\t\t\t\t\t regulators[i].desc.name)) {\n\t\t\t\tp->id = i;\n\t\t\t\tp->init_data = of_get_regulator_init_data(\n\t\t\t\t\t\t\t&pdev->dev, child,\n\t\t\t\t\t\t\t&regulators[i].desc);\n\t\t\t\tp->node = child;\n\t\t\t\tp++;\n\n\t\t\t\tparsed++;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Unknown regulator: %pOFn\\n\", child);\n\t}\n\tof_node_put(parent);\n\n\tpriv->num_regulators = parsed;\n\n\treturn data;\n}\nEXPORT_SYMBOL_GPL(mc13xxx_parse_regulators_dt);\n#endif\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Yong Shen <yong.shen@linaro.org>\");\nMODULE_DESCRIPTION(\"Regulator Driver for Freescale MC13xxx PMIC\");\nMODULE_ALIAS(\"mc13xxx-regulator-core\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}