{
  "module_name": "max20086-regulator.c",
  "hash_id": "f5ea91b47cd3153e9b88f984bb24553592f9264515ae4ef4eabb573597a8c8ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/max20086-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/slab.h>\n\n \n#define MAX20086_REG_MASK\t\t0x00\n#define MAX20086_REG_CONFIG\t\t0x01\n#define\tMAX20086_REG_ID\t\t\t0x02\n#define\tMAX20086_REG_STAT1\t\t0x03\n#define\tMAX20086_REG_STAT2_L\t\t0x04\n#define\tMAX20086_REG_STAT2_H\t\t0x05\n#define\tMAX20086_REG_ADC1\t\t0x06\n#define\tMAX20086_REG_ADC2\t\t0x07\n#define\tMAX20086_REG_ADC3\t\t0x08\n#define\tMAX20086_REG_ADC4\t\t0x09\n\n \n#define MAX20086_DEVICE_ID_MAX20086\t0x40\n#define MAX20086_DEVICE_ID_MAX20087\t0x20\n#define MAX20086_DEVICE_ID_MAX20088\t0x10\n#define MAX20086_DEVICE_ID_MAX20089\t0x00\n#define DEVICE_ID_MASK\t\t\t0xf0\n\n \n#define MAX20086_EN_MASK\t\t0x0f\n#define MAX20086_EN_OUT1\t\t0x01\n#define MAX20086_EN_OUT2\t\t0x02\n#define MAX20086_EN_OUT3\t\t0x04\n#define MAX20086_EN_OUT4\t\t0x08\n#define MAX20086_INT_DISABLE_ALL\t0x3f\n\n#define MAX20086_MAX_REGULATORS\t\t4\n\nstruct max20086_chip_info {\n\tu8 id;\n\tunsigned int num_outputs;\n};\n\nstruct max20086_regulator {\n\tstruct device_node *of_node;\n\tstruct regulator_init_data *init_data;\n\tconst struct regulator_desc *desc;\n\tstruct regulator_dev *rdev;\n};\n\nstruct max20086 {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *ena_gpiod;\n\n\tconst struct max20086_chip_info *info;\n\n\tstruct max20086_regulator regulators[MAX20086_MAX_REGULATORS];\n};\n\nstatic const struct regulator_ops max20086_buck_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n};\n\n#define MAX20086_REGULATOR_DESC(n)\t\t\\\n{\t\t\t\t\t\t\\\n\t.name = \"OUT\"#n,\t\t\t\\\n\t.supply_name = \"in\",\t\t\t\\\n\t.id = (n) - 1,\t\t\t\t\\\n\t.ops = &max20086_buck_ops,\t\t\\\n\t.type = REGULATOR_VOLTAGE,\t\t\\\n\t.owner = THIS_MODULE,\t\t\t\\\n\t.enable_reg = MAX20086_REG_CONFIG,\t\\\n\t.enable_mask = 1 << ((n) - 1),\t\t\\\n\t.enable_val = 1 << ((n) - 1),\t\t\\\n\t.disable_val = 0,\t\t\t\\\n}\n\nstatic const char * const max20086_output_names[] = {\n\t\"OUT1\",\n\t\"OUT2\",\n\t\"OUT3\",\n\t\"OUT4\",\n};\n\nstatic const struct regulator_desc max20086_regulators[] = {\n\tMAX20086_REGULATOR_DESC(1),\n\tMAX20086_REGULATOR_DESC(2),\n\tMAX20086_REGULATOR_DESC(3),\n\tMAX20086_REGULATOR_DESC(4),\n};\n\nstatic int max20086_regulators_register(struct max20086 *chip)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < chip->info->num_outputs; i++) {\n\t\tstruct max20086_regulator *reg = &chip->regulators[i];\n\t\tstruct regulator_config config = { };\n\t\tstruct regulator_dev *rdev;\n\n\t\tconfig.dev = chip->dev;\n\t\tconfig.init_data = reg->init_data;\n\t\tconfig.driver_data = chip;\n\t\tconfig.of_node = reg->of_node;\n\t\tconfig.regmap = chip->regmap;\n\t\tconfig.ena_gpiod = chip->ena_gpiod;\n\n\t\trdev = devm_regulator_register(chip->dev, reg->desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"Failed to register regulator output %s\\n\",\n\t\t\t\treg->desc->name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\n\t\treg->rdev = rdev;\n\t}\n\n\treturn 0;\n}\n\nstatic int max20086_parse_regulators_dt(struct max20086 *chip, bool *boot_on)\n{\n\tstruct of_regulator_match matches[MAX20086_MAX_REGULATORS] = { };\n\tstruct device_node *node;\n\tunsigned int i;\n\tint ret;\n\n\tnode = of_get_child_by_name(chip->dev->of_node, \"regulators\");\n\tif (!node) {\n\t\tdev_err(chip->dev, \"regulators node not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < chip->info->num_outputs; ++i)\n\t\tmatches[i].name = max20086_output_names[i];\n\n\tret = of_regulator_match(chip->dev, node, matches,\n\t\t\t\t chip->info->num_outputs);\n\tof_node_put(node);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to match regulators\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*boot_on = false;\n\n\tfor (i = 0; i < chip->info->num_outputs; i++) {\n\t\tstruct max20086_regulator *reg = &chip->regulators[i];\n\n\t\treg->init_data = matches[i].init_data;\n\t\treg->of_node = matches[i].of_node;\n\t\treg->desc = &max20086_regulators[i];\n\n\t\tif (reg->init_data) {\n\t\t\tif (reg->init_data->constraints.always_on ||\n\t\t\t    reg->init_data->constraints.boot_on)\n\t\t\t\t*boot_on = true;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int max20086_detect(struct max20086 *chip)\n{\n\tunsigned int data;\n\tint ret;\n\n\tret = regmap_read(chip->regmap, MAX20086_REG_ID, &data);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to read DEVICE_ID reg: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif ((data & DEVICE_ID_MASK) != chip->info->id) {\n\t\tdev_err(chip->dev, \"Invalid device ID 0x%02x\\n\", data);\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic bool max20086_gen_is_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX20086_REG_MASK:\n\tcase MAX20086_REG_CONFIG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config max20086_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.writeable_reg = max20086_gen_is_writeable_reg,\n\t.max_register = 0x9,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic int max20086_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct max20086 *chip;\n\tenum gpiod_flags flags;\n\tbool boot_on;\n\tint ret;\n\n\tchip = devm_kzalloc(&i2c->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = &i2c->dev;\n\tchip->info = device_get_match_data(chip->dev);\n\n\ti2c_set_clientdata(i2c, chip);\n\n\tchip->regmap = devm_regmap_init_i2c(i2c, &max20086_regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\tret = PTR_ERR(chip->regmap);\n\t\tdev_err(chip->dev, \"Failed to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = max20086_parse_regulators_dt(chip, &boot_on);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = max20086_detect(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(chip->regmap, MAX20086_REG_MASK,\n\t\t\t\t MAX20086_INT_DISABLE_ALL,\n\t\t\t\t MAX20086_INT_DISABLE_ALL);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to disable interrupts: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tflags = boot_on ? GPIOD_OUT_HIGH : GPIOD_OUT_LOW;\n\tchip->ena_gpiod = devm_gpiod_get(chip->dev, \"enable\", flags);\n\tif (IS_ERR(chip->ena_gpiod)) {\n\t\tret = PTR_ERR(chip->ena_gpiod);\n\t\tdev_err(chip->dev, \"Failed to get enable GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = max20086_regulators_register(chip);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to register regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max20086_i2c_id[] = {\n\t{ \"max20086\" },\n\t{ \"max20087\" },\n\t{ \"max20088\" },\n\t{ \"max20089\" },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(i2c, max20086_i2c_id);\n\nstatic const struct of_device_id max20086_dt_ids[] __maybe_unused = {\n\t{\n\t\t.compatible = \"maxim,max20086\",\n\t\t.data = &(const struct max20086_chip_info) {\n\t\t\t.id = MAX20086_DEVICE_ID_MAX20086,\n\t\t\t.num_outputs = 4,\n\t\t}\n\t}, {\n\t\t.compatible = \"maxim,max20087\",\n\t\t.data = &(const struct max20086_chip_info) {\n\t\t\t.id = MAX20086_DEVICE_ID_MAX20087,\n\t\t\t.num_outputs = 4,\n\t\t}\n\t}, {\n\t\t.compatible = \"maxim,max20088\",\n\t\t.data = &(const struct max20086_chip_info) {\n\t\t\t.id = MAX20086_DEVICE_ID_MAX20088,\n\t\t\t.num_outputs = 2,\n\t\t}\n\t}, {\n\t\t.compatible = \"maxim,max20089\",\n\t\t.data = &(const struct max20086_chip_info) {\n\t\t\t.id = MAX20086_DEVICE_ID_MAX20089,\n\t\t\t.num_outputs = 2,\n\t\t}\n\t},\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(of, max20086_dt_ids);\n\nstatic struct i2c_driver max20086_regulator_driver = {\n\t.driver = {\n\t\t.name = \"max20086\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(max20086_dt_ids),\n\t},\n\t.probe = max20086_i2c_probe,\n\t.id_table = max20086_i2c_id,\n};\n\nmodule_i2c_driver(max20086_regulator_driver);\n\nMODULE_AUTHOR(\"Watson Chow <watson.chow@avnet.com>\");\nMODULE_DESCRIPTION(\"MAX20086-MAX20089 Camera Power Protector Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}