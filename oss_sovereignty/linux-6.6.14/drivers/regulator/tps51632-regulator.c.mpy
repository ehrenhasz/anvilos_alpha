{
  "module_name": "tps51632-regulator.c",
  "hash_id": "d491a734e586d586385ea5ad1080003735dbb8ddfd0b54b72b5a361d2ed6c3e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/tps51632-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regulator/tps51632-regulator.h>\n#include <linux/slab.h>\n\n \n#define TPS51632_VOLTAGE_SELECT_REG\t\t0x0\n#define TPS51632_VOLTAGE_BASE_REG\t\t0x1\n#define TPS51632_OFFSET_REG\t\t\t0x2\n#define TPS51632_IMON_REG\t\t\t0x3\n#define TPS51632_VMAX_REG\t\t\t0x4\n#define TPS51632_DVFS_CONTROL_REG\t\t0x5\n#define TPS51632_POWER_STATE_REG\t\t0x6\n#define TPS51632_SLEW_REGS\t\t\t0x7\n#define TPS51632_FAULT_REG\t\t\t0x14\n\n#define TPS51632_MAX_REG\t\t\t0x15\n\n#define TPS51632_VOUT_MASK\t\t\t0x7F\n#define TPS51632_VOUT_OFFSET_MASK\t\t0x1F\n#define TPS51632_VMAX_MASK\t\t\t0x7F\n#define TPS51632_VMAX_LOCK\t\t\t0x80\n\n \n#define TPS51632_DVFS_PWMEN\t\t\t0x1\n#define TPS51632_DVFS_STEP_20\t\t\t0x2\n#define TPS51632_DVFS_VMAX_PG\t\t\t0x4\n#define TPS51632_DVFS_PWMRST\t\t\t0x8\n#define TPS51632_DVFS_OCA_EN\t\t\t0x10\n#define TPS51632_DVFS_FCCM\t\t\t0x20\n\n \n#define TPS51632_POWER_STATE_MASK\t\t0x03\n#define TPS51632_POWER_STATE_MULTI_PHASE_CCM\t0x0\n#define TPS51632_POWER_STATE_SINGLE_PHASE_CCM\t0x1\n#define TPS51632_POWER_STATE_SINGLE_PHASE_DCM\t0x2\n\n#define TPS51632_MIN_VOLTAGE\t\t\t500000\n#define TPS51632_MAX_VOLTAGE\t\t\t1520000\n#define TPS51632_VOLTAGE_STEP_10mV\t\t10000\n#define TPS51632_VOLTAGE_STEP_20mV\t\t20000\n#define TPS51632_MAX_VSEL\t\t\t0x7F\n#define TPS51632_MIN_VSEL\t\t\t0x19\n#define TPS51632_DEFAULT_RAMP_DELAY\t\t6000\n#define TPS51632_VOLT_VSEL(uV)\t\t\t\t\t\\\n\t\t(DIV_ROUND_UP(uV - TPS51632_MIN_VOLTAGE,\t\\\n\t\t\tTPS51632_VOLTAGE_STEP_10mV) +\t\t\\\n\t\t\tTPS51632_MIN_VSEL)\n\n \nstruct tps51632_chip {\n\tstruct device *dev;\n\tstruct regulator_desc desc;\n\tstruct regulator_dev *rdev;\n\tstruct regmap *regmap;\n};\n\nstatic int tps51632_dcdc_set_ramp_delay(struct regulator_dev *rdev,\n\t\tint ramp_delay)\n{\n\tstruct tps51632_chip *tps = rdev_get_drvdata(rdev);\n\tint bit;\n\tint ret;\n\n\tif (ramp_delay == 0)\n\t\tbit = 0;\n\telse\n\t\tbit = DIV_ROUND_UP(ramp_delay, 6000) - 1;\n\n\tret = regmap_write(tps->regmap, TPS51632_SLEW_REGS, BIT(bit));\n\tif (ret < 0)\n\t\tdev_err(tps->dev, \"SLEW reg write failed, err %d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct regulator_ops tps51632_dcdc_ops = {\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.set_voltage_time_sel\t= regulator_set_voltage_time_sel,\n\t.set_ramp_delay\t\t= tps51632_dcdc_set_ramp_delay,\n};\n\nstatic int tps51632_init_dcdc(struct tps51632_chip *tps,\n\t\tstruct tps51632_regulator_platform_data *pdata)\n{\n\tint ret;\n\tuint8_t\tcontrol = 0;\n\tint vsel;\n\n\tif (!pdata->enable_pwm_dvfs)\n\t\tgoto skip_pwm_config;\n\n\tcontrol |= TPS51632_DVFS_PWMEN;\n\tvsel = TPS51632_VOLT_VSEL(pdata->base_voltage_uV);\n\tret = regmap_write(tps->regmap, TPS51632_VOLTAGE_BASE_REG, vsel);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev, \"BASE reg write failed, err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (pdata->dvfs_step_20mV)\n\t\tcontrol |= TPS51632_DVFS_STEP_20;\n\n\tif (pdata->max_voltage_uV) {\n\t\tunsigned int vmax;\n\t\t \n\t\tret = regmap_read(tps->regmap, TPS51632_VMAX_REG, &vmax);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tps->dev, \"VMAX read failed, err %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(vmax & TPS51632_VMAX_LOCK)) {\n\t\t\tvsel = TPS51632_VOLT_VSEL(pdata->max_voltage_uV);\n\t\t\tret = regmap_write(tps->regmap, TPS51632_VMAX_REG,\n\t\t\t\t\tvsel);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(tps->dev,\n\t\t\t\t\t\"VMAX write failed, err %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\nskip_pwm_config:\n\tret = regmap_write(tps->regmap, TPS51632_DVFS_CONTROL_REG, control);\n\tif (ret < 0)\n\t\tdev_err(tps->dev, \"DVFS reg write failed, err %d\\n\", ret);\n\treturn ret;\n}\n\nstatic bool is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TPS51632_OFFSET_REG:\n\tcase TPS51632_FAULT_REG:\n\tcase TPS51632_IMON_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool is_read_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x08 ... 0x0F:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool is_write_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TPS51632_VOLTAGE_SELECT_REG:\n\tcase TPS51632_VOLTAGE_BASE_REG:\n\tcase TPS51632_VMAX_REG:\n\tcase TPS51632_DVFS_CONTROL_REG:\n\tcase TPS51632_POWER_STATE_REG:\n\tcase TPS51632_SLEW_REGS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config tps51632_regmap_config = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\t.writeable_reg\t\t= is_write_reg,\n\t.readable_reg\t\t= is_read_reg,\n\t.volatile_reg\t\t= is_volatile_reg,\n\t.max_register\t\t= TPS51632_MAX_REG - 1,\n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id tps51632_of_match[] = {\n\t{ .compatible = \"ti,tps51632\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tps51632_of_match);\n\nstatic struct tps51632_regulator_platform_data *\n\tof_get_tps51632_platform_data(struct device *dev,\n\t\t\t\t      const struct regulator_desc *desc)\n{\n\tstruct tps51632_regulator_platform_data *pdata;\n\tstruct device_node *np = dev->of_node;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tpdata->reg_init_data = of_get_regulator_init_data(dev, dev->of_node,\n\t\t\t\t\t\t\t  desc);\n\tif (!pdata->reg_init_data) {\n\t\tdev_err(dev, \"Not able to get OF regulator init data\\n\");\n\t\treturn NULL;\n\t}\n\n\tpdata->enable_pwm_dvfs =\n\t\t\tof_property_read_bool(np, \"ti,enable-pwm-dvfs\");\n\tpdata->dvfs_step_20mV = of_property_read_bool(np, \"ti,dvfs-step-20mV\");\n\n\tpdata->base_voltage_uV = pdata->reg_init_data->constraints.min_uV ? :\n\t\t\t\t\tTPS51632_MIN_VOLTAGE;\n\tpdata->max_voltage_uV = pdata->reg_init_data->constraints.max_uV ? :\n\t\t\t\t\tTPS51632_MAX_VOLTAGE;\n\treturn pdata;\n}\n#else\nstatic struct tps51632_regulator_platform_data *\n\tof_get_tps51632_platform_data(struct device *dev,\n\t\t\t\t      const struct regulator_desc *desc)\n{\n\treturn NULL;\n}\n#endif\n\nstatic int tps51632_probe(struct i2c_client *client)\n{\n\tstruct tps51632_regulator_platform_data *pdata;\n\tstruct regulator_dev *rdev;\n\tstruct tps51632_chip *tps;\n\tint ret;\n\tstruct regulator_config config = { };\n\n\tif (client->dev.of_node) {\n\t\tconst struct of_device_id *match;\n\t\tmatch = of_match_device(of_match_ptr(tps51632_of_match),\n\t\t\t\t&client->dev);\n\t\tif (!match) {\n\t\t\tdev_err(&client->dev, \"Error: No device match found\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\ttps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\ttps->dev = &client->dev;\n\ttps->desc.name = client->name;\n\ttps->desc.id = 0;\n\ttps->desc.ramp_delay = TPS51632_DEFAULT_RAMP_DELAY;\n\ttps->desc.min_uV = TPS51632_MIN_VOLTAGE;\n\ttps->desc.uV_step = TPS51632_VOLTAGE_STEP_10mV;\n\ttps->desc.linear_min_sel = TPS51632_MIN_VSEL;\n\ttps->desc.n_voltages = TPS51632_MAX_VSEL + 1;\n\ttps->desc.ops = &tps51632_dcdc_ops;\n\ttps->desc.type = REGULATOR_VOLTAGE;\n\ttps->desc.owner = THIS_MODULE;\n\n\tpdata = dev_get_platdata(&client->dev);\n\tif (!pdata && client->dev.of_node)\n\t\tpdata = of_get_tps51632_platform_data(&client->dev, &tps->desc);\n\tif (!pdata) {\n\t\tdev_err(&client->dev, \"No Platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->enable_pwm_dvfs) {\n\t\tif ((pdata->base_voltage_uV < TPS51632_MIN_VOLTAGE) ||\n\t\t    (pdata->base_voltage_uV > TPS51632_MAX_VOLTAGE)) {\n\t\t\tdev_err(&client->dev, \"Invalid base_voltage_uV setting\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((pdata->max_voltage_uV) &&\n\t\t    ((pdata->max_voltage_uV < TPS51632_MIN_VOLTAGE) ||\n\t\t     (pdata->max_voltage_uV > TPS51632_MAX_VOLTAGE))) {\n\t\t\tdev_err(&client->dev, \"Invalid max_voltage_uV setting\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (pdata->enable_pwm_dvfs)\n\t\ttps->desc.vsel_reg = TPS51632_VOLTAGE_BASE_REG;\n\telse\n\t\ttps->desc.vsel_reg = TPS51632_VOLTAGE_SELECT_REG;\n\ttps->desc.vsel_mask = TPS51632_VOUT_MASK;\n\n\ttps->regmap = devm_regmap_init_i2c(client, &tps51632_regmap_config);\n\tif (IS_ERR(tps->regmap)) {\n\t\tret = PTR_ERR(tps->regmap);\n\t\tdev_err(&client->dev, \"regmap init failed, err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\ti2c_set_clientdata(client, tps);\n\n\tret = tps51632_init_dcdc(tps, pdata);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev, \"Init failed, err = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tconfig.dev = &client->dev;\n\tconfig.init_data = pdata->reg_init_data;\n\tconfig.driver_data = tps;\n\tconfig.regmap = tps->regmap;\n\tconfig.of_node = client->dev.of_node;\n\n\trdev = devm_regulator_register(&client->dev, &tps->desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(tps->dev, \"regulator register failed\\n\");\n\t\treturn PTR_ERR(rdev);\n\t}\n\n\ttps->rdev = rdev;\n\treturn 0;\n}\n\nstatic const struct i2c_device_id tps51632_id[] = {\n\t{.name = \"tps51632\",},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, tps51632_id);\n\nstatic struct i2c_driver tps51632_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tps51632\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(tps51632_of_match),\n\t},\n\t.probe = tps51632_probe,\n\t.id_table = tps51632_id,\n};\n\nstatic int __init tps51632_init(void)\n{\n\treturn i2c_add_driver(&tps51632_i2c_driver);\n}\nsubsys_initcall(tps51632_init);\n\nstatic void __exit tps51632_cleanup(void)\n{\n\ti2c_del_driver(&tps51632_i2c_driver);\n}\nmodule_exit(tps51632_cleanup);\n\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_DESCRIPTION(\"TPS51632 voltage regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}