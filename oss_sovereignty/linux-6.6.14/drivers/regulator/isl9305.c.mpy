{
  "module_name": "isl9305.c",
  "hash_id": "f5bab13f8a9694ead844d301c2124c276fc8d6bff95e56a1aaffd5058467295c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/isl9305.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n#include <linux/platform_data/isl9305.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/slab.h>\n\n \n#define ISL9305_DCD1OUT          0x0\n#define ISL9305_DCD2OUT          0x1\n#define ISL9305_LDO1OUT          0x2\n#define ISL9305_LDO2OUT          0x3\n#define ISL9305_DCD_PARAMETER    0x4\n#define ISL9305_SYSTEM_PARAMETER 0x5\n#define ISL9305_DCD_SRCTL        0x6\n\n#define ISL9305_MAX_REG ISL9305_DCD_SRCTL\n\n \n#define ISL9305_DCD_PHASE   0x40\n#define ISL9305_DCD2_ULTRA  0x20\n#define ISL9305_DCD1_ULTRA  0x10\n#define ISL9305_DCD2_BLD    0x08\n#define ISL9305_DCD1_BLD    0x04\n#define ISL9305_DCD2_MODE   0x02\n#define ISL9305_DCD1_MODE   0x01\n\n \n#define ISL9305_I2C_EN      0x40\n#define ISL9305_DCDPOR_MASK 0x30\n#define ISL9305_LDO2_EN     0x08\n#define ISL9305_LDO1_EN     0x04\n#define ISL9305_DCD2_EN     0x02\n#define ISL9305_DCD1_EN     0x01\n\n \n#define ISL9305_DCD2SR_MASK 0xc0\n#define ISL9305_DCD1SR_MASK 0x07\n\nstatic const struct regulator_ops isl9305_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n};\n\nstatic const struct regulator_desc isl9305_regulators[] = {\n\t[ISL9305_DCD1] = {\n\t\t.name =\t\t\"DCD1\",\n\t\t.of_match =\tof_match_ptr(\"dcd1\"),\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t.n_voltages =\t0x70,\n\t\t.min_uV =\t825000,\n\t\t.uV_step =\t25000,\n\t\t.vsel_reg =\tISL9305_DCD1OUT,\n\t\t.vsel_mask =\t0x7f,\n\t\t.enable_reg =\tISL9305_SYSTEM_PARAMETER,\n\t\t.enable_mask =\tISL9305_DCD1_EN,\n\t\t.supply_name =\t\"VINDCD1\",\n\t\t.ops =\t\t&isl9305_ops,\n\t\t.owner =\tTHIS_MODULE,\n\t},\n\t[ISL9305_DCD2] = {\n\t\t.name =\t\t\"DCD2\",\n\t\t.of_match =\tof_match_ptr(\"dcd2\"),\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t.n_voltages =\t0x70,\n\t\t.min_uV =\t825000,\n\t\t.uV_step =\t25000,\n\t\t.vsel_reg =\tISL9305_DCD2OUT,\n\t\t.vsel_mask =\t0x7f,\n\t\t.enable_reg =\tISL9305_SYSTEM_PARAMETER,\n\t\t.enable_mask =\tISL9305_DCD2_EN,\n\t\t.supply_name =\t\"VINDCD2\",\n\t\t.ops =\t\t&isl9305_ops,\n\t\t.owner =\tTHIS_MODULE,\n\t},\n\t[ISL9305_LDO1] = {\n\t\t.name =\t\t\"LDO1\",\n\t\t.of_match =\tof_match_ptr(\"ldo1\"),\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t.n_voltages =\t0x37,\n\t\t.min_uV =\t900000,\n\t\t.uV_step =\t50000,\n\t\t.vsel_reg =\tISL9305_LDO1OUT,\n\t\t.vsel_mask =\t0x3f,\n\t\t.enable_reg =\tISL9305_SYSTEM_PARAMETER,\n\t\t.enable_mask =\tISL9305_LDO1_EN,\n\t\t.supply_name =\t\"VINLDO1\",\n\t\t.ops =\t\t&isl9305_ops,\n\t\t.owner =\tTHIS_MODULE,\n\t},\n\t[ISL9305_LDO2] = {\n\t\t.name =\t\t\"LDO2\",\n\t\t.of_match =\tof_match_ptr(\"ldo2\"),\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t.n_voltages =\t0x37,\n\t\t.min_uV =\t900000,\n\t\t.uV_step =\t50000,\n\t\t.vsel_reg =\tISL9305_LDO2OUT,\n\t\t.vsel_mask =\t0x3f,\n\t\t.enable_reg =\tISL9305_SYSTEM_PARAMETER,\n\t\t.enable_mask =\tISL9305_LDO2_EN,\n\t\t.supply_name =\t\"VINLDO2\",\n\t\t.ops =\t\t&isl9305_ops,\n\t\t.owner =\tTHIS_MODULE,\n\t},\n};\n\nstatic const struct regmap_config isl9305_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = ISL9305_MAX_REG,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int isl9305_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct regulator_config config = { };\n\tstruct isl9305_pdata *pdata = i2c->dev.platform_data;\n\tstruct regulator_dev *rdev;\n\tstruct regmap *regmap;\n\tint i, ret;\n\n\tregmap = devm_regmap_init_i2c(i2c, &isl9305_regmap);\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tdev_err(&i2c->dev, \"Failed to create regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tconfig.dev = &i2c->dev;\n\n\tfor (i = 0; i < ARRAY_SIZE(isl9305_regulators); i++) {\n\t\tif (pdata)\n\t\t\tconfig.init_data = pdata->init_data[i];\n\t\telse\n\t\t\tconfig.init_data = NULL;\n\n\t\trdev = devm_regulator_register(&i2c->dev,\n\t\t\t\t\t       &isl9305_regulators[i],\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tret = PTR_ERR(rdev);\n\t\t\tdev_err(&i2c->dev, \"Failed to register %s: %d\\n\",\n\t\t\t\tisl9305_regulators[i].name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id isl9305_dt_ids[] = {\n\t{ .compatible = \"isl,isl9305\" },  \n\t{ .compatible = \"isil,isl9305\" },\n\t{ .compatible = \"isl,isl9305h\" },  \n\t{ .compatible = \"isil,isl9305h\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, isl9305_dt_ids);\n#endif\n\nstatic const struct i2c_device_id isl9305_i2c_id[] = {\n\t{ \"isl9305\", },\n\t{ \"isl9305h\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, isl9305_i2c_id);\n\nstatic struct i2c_driver isl9305_regulator_driver = {\n\t.driver = {\n\t\t.name = \"isl9305\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table\t= of_match_ptr(isl9305_dt_ids),\n\t},\n\t.probe = isl9305_i2c_probe,\n\t.id_table = isl9305_i2c_id,\n};\n\nmodule_i2c_driver(isl9305_regulator_driver);\n\nMODULE_AUTHOR(\"Mark Brown\");\nMODULE_DESCRIPTION(\"Intersil ISL9305 DCDC regulator\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}