{
  "module_name": "atc260x-regulator.c",
  "hash_id": "9e4efe94843a3cc5dea7d87802a03f3b72d92cb44b1df6a04d320e69f81f76aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/atc260x-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/mfd/atc260x/core.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n\nstruct atc260x_regulator_data {\n\tint voltage_time_dcdc;\n\tint voltage_time_ldo;\n};\n\nstatic const struct linear_range atc2603c_dcdc_voltage_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1300000, 0, 13, 50000),\n\tREGULATOR_LINEAR_RANGE(1950000, 14, 15, 100000),\n};\n\nstatic const struct linear_range atc2609a_dcdc_voltage_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(600000, 0, 127, 6250),\n\tREGULATOR_LINEAR_RANGE(1400000, 128, 232, 25000),\n};\n\nstatic const struct linear_range atc2609a_ldo_voltage_ranges0[] = {\n\tREGULATOR_LINEAR_RANGE(700000, 0, 15, 100000),\n\tREGULATOR_LINEAR_RANGE(2100000, 0, 12, 100000),\n};\n\nstatic const struct linear_range atc2609a_ldo_voltage_ranges1[] = {\n\tREGULATOR_LINEAR_RANGE(850000, 0, 15, 100000),\n\tREGULATOR_LINEAR_RANGE(2100000, 0, 11, 100000),\n};\n\nstatic const unsigned int atc260x_ldo_voltage_range_sel[] = {\n\t0x0, 0x1,\n};\n\nstatic int atc260x_dcdc_set_voltage_time_sel(struct regulator_dev *rdev,\n\t\t\t\t\t     unsigned int old_selector,\n\t\t\t\t\t     unsigned int new_selector)\n{\n\tstruct atc260x_regulator_data *data = rdev_get_drvdata(rdev);\n\n\tif (new_selector > old_selector)\n\t\treturn data->voltage_time_dcdc;\n\n\treturn 0;\n}\n\nstatic int atc260x_ldo_set_voltage_time_sel(struct regulator_dev *rdev,\n\t\t\t\t\t    unsigned int old_selector,\n\t\t\t\t\t    unsigned int new_selector)\n{\n\tstruct atc260x_regulator_data *data = rdev_get_drvdata(rdev);\n\n\tif (new_selector > old_selector)\n\t\treturn data->voltage_time_ldo;\n\n\treturn 0;\n}\n\nstatic const struct regulator_ops atc260x_dcdc_ops = {\n\t.enable\t= regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_time_sel = atc260x_dcdc_set_voltage_time_sel,\n};\n\nstatic const struct regulator_ops atc260x_ldo_ops = {\n\t.enable\t= regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_time_sel = atc260x_ldo_set_voltage_time_sel,\n};\n\nstatic const struct regulator_ops atc260x_ldo_bypass_ops = {\n\t.enable\t= regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_time_sel = atc260x_ldo_set_voltage_time_sel,\n\t.set_bypass = regulator_set_bypass_regmap,\n\t.get_bypass = regulator_get_bypass_regmap,\n};\n\nstatic const struct regulator_ops atc260x_ldo_bypass_discharge_ops = {\n\t.enable\t= regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_time_sel = atc260x_ldo_set_voltage_time_sel,\n\t.set_bypass = regulator_set_bypass_regmap,\n\t.get_bypass = regulator_get_bypass_regmap,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n};\n\nstatic const struct regulator_ops atc260x_dcdc_range_ops = {\n\t.enable\t= regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_time_sel = atc260x_dcdc_set_voltage_time_sel,\n};\n\nstatic const struct regulator_ops atc260x_ldo_range_pick_ops = {\n\t.enable\t= regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_pickable_linear_range,\n\t.set_voltage_sel = regulator_set_voltage_sel_pickable_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_pickable_regmap,\n\t.set_voltage_time_sel = atc260x_ldo_set_voltage_time_sel,\n};\n\nstatic const struct regulator_ops atc260x_dcdc_fixed_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_time_sel = atc260x_dcdc_set_voltage_time_sel,\n};\n\nstatic const struct regulator_ops atc260x_ldo_fixed_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_time_sel = atc260x_ldo_set_voltage_time_sel,\n};\n\nstatic const struct regulator_ops atc260x_no_ops = {\n};\n\n \nenum atc2603c_reg_ids {\n\tATC2603C_ID_DCDC1,\n\tATC2603C_ID_DCDC2,\n\tATC2603C_ID_DCDC3,\n\tATC2603C_ID_LDO1,\n\tATC2603C_ID_LDO2,\n\tATC2603C_ID_LDO3,\n\tATC2603C_ID_LDO5,\n\tATC2603C_ID_LDO6,\n\tATC2603C_ID_LDO7,\n\tATC2603C_ID_LDO8,\n\tATC2603C_ID_LDO11,\n\tATC2603C_ID_LDO12,\n\tATC2603C_ID_SWITCHLDO1,\n\tATC2603C_ID_MAX,\n};\n\n#define atc2603c_reg_desc_dcdc(num, min, step, n_volt, vsel_h, vsel_l) { \\\n\t.name = \"DCDC\"#num, \\\n\t.supply_name = \"dcdc\"#num, \\\n\t.of_match = of_match_ptr(\"dcdc\"#num), \\\n\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t.id = ATC2603C_ID_DCDC##num, \\\n\t.ops = &atc260x_dcdc_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.min_uV = min, \\\n\t.uV_step = step, \\\n\t.n_voltages = n_volt, \\\n\t.vsel_reg = ATC2603C_PMU_DC##num##_CTL0, \\\n\t.vsel_mask = GENMASK(vsel_h, vsel_l), \\\n\t.enable_reg = ATC2603C_PMU_DC##num##_CTL0, \\\n\t.enable_mask = BIT(15), \\\n\t.enable_time = 800, \\\n\t.owner = THIS_MODULE, \\\n}\n\n#define atc2603c_reg_desc_dcdc_range(num, vsel_h, vsel_l) { \\\n\t.name = \"DCDC\"#num, \\\n\t.supply_name = \"dcdc\"#num, \\\n\t.of_match = of_match_ptr(\"dcdc\"#num), \\\n\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t.id = ATC2603C_ID_DCDC##num, \\\n\t.ops = &atc260x_dcdc_range_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.n_voltages = 16, \\\n\t.linear_ranges = atc2603c_dcdc_voltage_ranges, \\\n\t.n_linear_ranges = ARRAY_SIZE(atc2603c_dcdc_voltage_ranges), \\\n\t.vsel_reg = ATC2603C_PMU_DC##num##_CTL0, \\\n\t.vsel_mask = GENMASK(vsel_h, vsel_l), \\\n\t.enable_reg = ATC2603C_PMU_DC##num##_CTL0, \\\n\t.enable_mask = BIT(15), \\\n\t.enable_time = 800, \\\n\t.owner = THIS_MODULE, \\\n}\n\n#define atc2603c_reg_desc_dcdc_fixed(num, min, step, n_volt, vsel_h, vsel_l) { \\\n\t.name = \"DCDC\"#num, \\\n\t.supply_name = \"dcdc\"#num, \\\n\t.of_match = of_match_ptr(\"dcdc\"#num), \\\n\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t.id = ATC2603C_ID_DCDC##num, \\\n\t.ops = &atc260x_dcdc_fixed_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.min_uV = min, \\\n\t.uV_step = step, \\\n\t.n_voltages = n_volt, \\\n\t.vsel_reg = ATC2603C_PMU_DC##num##_CTL0, \\\n\t.vsel_mask = GENMASK(vsel_h, vsel_l), \\\n\t.enable_time = 800, \\\n\t.owner = THIS_MODULE, \\\n}\n\n#define atc2603c_reg_desc_ldo(num, min, step, n_volt, vsel_h, vsel_l) { \\\n\t.name = \"LDO\"#num, \\\n\t.supply_name = \"ldo\"#num, \\\n\t.of_match = of_match_ptr(\"ldo\"#num), \\\n\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t.id = ATC2603C_ID_LDO##num, \\\n\t.ops = &atc260x_ldo_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.min_uV = min, \\\n\t.uV_step = step, \\\n\t.n_voltages = n_volt, \\\n\t.vsel_reg = ATC2603C_PMU_LDO##num##_CTL, \\\n\t.vsel_mask = GENMASK(vsel_h, vsel_l), \\\n\t.enable_reg = ATC2603C_PMU_LDO##num##_CTL, \\\n\t.enable_mask = BIT(0), \\\n\t.enable_time = 2000, \\\n\t.owner = THIS_MODULE, \\\n}\n\n#define atc2603c_reg_desc_ldo_fixed(num, min, step, n_volt, vsel_h, vsel_l) { \\\n\t.name = \"LDO\"#num, \\\n\t.supply_name = \"ldo\"#num, \\\n\t.of_match = of_match_ptr(\"ldo\"#num), \\\n\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t.id = ATC2603C_ID_LDO##num, \\\n\t.ops = &atc260x_ldo_fixed_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.min_uV = min, \\\n\t.uV_step = step, \\\n\t.n_voltages = n_volt, \\\n\t.vsel_reg = ATC2603C_PMU_LDO##num##_CTL, \\\n\t.vsel_mask = GENMASK(vsel_h, vsel_l), \\\n\t.enable_time = 2000, \\\n\t.owner = THIS_MODULE, \\\n}\n\n#define atc2603c_reg_desc_ldo_noops(num, vfixed) { \\\n\t.name = \"LDO\"#num, \\\n\t.supply_name = \"ldo\"#num, \\\n\t.of_match = of_match_ptr(\"ldo\"#num), \\\n\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t.id = ATC2603C_ID_LDO##num, \\\n\t.ops = &atc260x_no_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.fixed_uV = vfixed, \\\n\t.n_voltages = 1, \\\n\t.owner = THIS_MODULE, \\\n}\n\n#define atc2603c_reg_desc_ldo_switch(num, min, step, n_volt, vsel_h, vsel_l) { \\\n\t.name = \"SWITCHLDO\"#num, \\\n\t.supply_name = \"switchldo\"#num, \\\n\t.of_match = of_match_ptr(\"switchldo\"#num), \\\n\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t.id = ATC2603C_ID_SWITCHLDO##num, \\\n\t.ops = &atc260x_ldo_bypass_discharge_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.min_uV = min, \\\n\t.uV_step = step, \\\n\t.n_voltages = n_volt, \\\n\t.vsel_reg = ATC2603C_PMU_SWITCH_CTL, \\\n\t.vsel_mask = GENMASK(vsel_h, vsel_l), \\\n\t.enable_reg = ATC2603C_PMU_SWITCH_CTL, \\\n\t.enable_mask = BIT(15), \\\n\t.enable_is_inverted = true, \\\n\t.enable_time = 2000, \\\n\t.bypass_reg = ATC2603C_PMU_SWITCH_CTL, \\\n\t.bypass_mask = BIT(5), \\\n\t.active_discharge_reg = ATC2603C_PMU_SWITCH_CTL, \\\n\t.active_discharge_mask = BIT(1), \\\n\t.active_discharge_on = BIT(1), \\\n\t.owner = THIS_MODULE, \\\n}\n\nstatic const struct regulator_desc atc2603c_reg[] = {\n\tatc2603c_reg_desc_dcdc_fixed(1, 700000, 25000, 29, 11, 7),\n\tatc2603c_reg_desc_dcdc_range(2, 12, 8),\n\tatc2603c_reg_desc_dcdc_fixed(3, 2600000, 100000, 8, 11, 9),\n\tatc2603c_reg_desc_ldo_fixed(1, 2600000, 100000, 8, 15, 13),\n\tatc2603c_reg_desc_ldo_fixed(2, 2600000, 100000, 8, 15, 13),\n\tatc2603c_reg_desc_ldo_fixed(3, 1500000, 100000, 6, 15, 13),\n\tatc2603c_reg_desc_ldo(5, 2600000, 100000, 8, 15, 13),\n\tatc2603c_reg_desc_ldo_fixed(6, 700000, 25000, 29, 15, 11),\n\tatc2603c_reg_desc_ldo(7, 1500000, 100000, 6, 15, 13),\n\tatc2603c_reg_desc_ldo(8, 2300000, 100000, 11, 15, 12),\n\tatc2603c_reg_desc_ldo_fixed(11, 2600000, 100000, 8, 15, 13),\n\tatc2603c_reg_desc_ldo_noops(12, 1800000),\n\tatc2603c_reg_desc_ldo_switch(1, 3000000, 100000, 4, 4, 3),\n};\n\nstatic const struct regulator_desc atc2603c_reg_dcdc2_ver_b =\n\tatc2603c_reg_desc_dcdc(2, 1000000, 50000, 18, 12, 8);\n\nenum atc2609a_reg_ids {\n\tATC2609A_ID_DCDC0,\n\tATC2609A_ID_DCDC1,\n\tATC2609A_ID_DCDC2,\n\tATC2609A_ID_DCDC3,\n\tATC2609A_ID_DCDC4,\n\tATC2609A_ID_LDO0,\n\tATC2609A_ID_LDO1,\n\tATC2609A_ID_LDO2,\n\tATC2609A_ID_LDO3,\n\tATC2609A_ID_LDO4,\n\tATC2609A_ID_LDO5,\n\tATC2609A_ID_LDO6,\n\tATC2609A_ID_LDO7,\n\tATC2609A_ID_LDO8,\n\tATC2609A_ID_LDO9,\n\tATC2609A_ID_MAX,\n};\n\n#define atc2609a_reg_desc_dcdc(num, en_bit) { \\\n\t.name = \"DCDC\"#num, \\\n\t.supply_name = \"dcdc\"#num, \\\n\t.of_match = of_match_ptr(\"dcdc\"#num), \\\n\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t.id = ATC2609A_ID_DCDC##num, \\\n\t.ops = &atc260x_dcdc_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.min_uV = 600000, \\\n\t.uV_step = 6250, \\\n\t.n_voltages = 256, \\\n\t.vsel_reg = ATC2609A_PMU_DC##num##_CTL0, \\\n\t.vsel_mask = GENMASK(15, 8), \\\n\t.enable_reg = ATC2609A_PMU_DC_OSC, \\\n\t.enable_mask = BIT(en_bit), \\\n\t.enable_time = 800, \\\n\t.owner = THIS_MODULE, \\\n}\n\n#define atc2609a_reg_desc_dcdc_range(num, en_bit) { \\\n\t.name = \"DCDC\"#num, \\\n\t.supply_name = \"dcdc\"#num, \\\n\t.of_match = of_match_ptr(\"dcdc\"#num), \\\n\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t.id = ATC2609A_ID_DCDC##num, \\\n\t.ops = &atc260x_dcdc_range_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.n_voltages = 233, \\\n\t.linear_ranges = atc2609a_dcdc_voltage_ranges, \\\n\t.n_linear_ranges = ARRAY_SIZE(atc2609a_dcdc_voltage_ranges), \\\n\t.vsel_reg = ATC2609A_PMU_DC##num##_CTL0, \\\n\t.vsel_mask = GENMASK(15, 8), \\\n\t.enable_reg = ATC2609A_PMU_DC_OSC, \\\n\t.enable_mask = BIT(en_bit), \\\n\t.enable_time = 800, \\\n\t.owner = THIS_MODULE, \\\n}\n\n#define atc2609a_reg_desc_ldo(num) { \\\n\t.name = \"LDO\"#num, \\\n\t.supply_name = \"ldo\"#num, \\\n\t.of_match = of_match_ptr(\"ldo\"#num), \\\n\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t.id = ATC2609A_ID_LDO##num, \\\n\t.ops = &atc260x_ldo_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.min_uV = 700000, \\\n\t.uV_step = 100000, \\\n\t.n_voltages = 16, \\\n\t.vsel_reg = ATC2609A_PMU_LDO##num##_CTL0, \\\n\t.vsel_mask = GENMASK(4, 1), \\\n\t.enable_reg = ATC2609A_PMU_LDO##num##_CTL0, \\\n\t.enable_mask = BIT(0), \\\n\t.enable_time = 2000, \\\n\t.owner = THIS_MODULE, \\\n}\n\n#define atc2609a_reg_desc_ldo_bypass(num) { \\\n\t.name = \"LDO\"#num, \\\n\t.supply_name = \"ldo\"#num, \\\n\t.of_match = of_match_ptr(\"ldo\"#num), \\\n\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t.id = ATC2609A_ID_LDO##num, \\\n\t.ops = &atc260x_ldo_bypass_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.min_uV = 2300000, \\\n\t.uV_step = 100000, \\\n\t.n_voltages = 12, \\\n\t.vsel_reg = ATC2609A_PMU_LDO##num##_CTL0, \\\n\t.vsel_mask = GENMASK(5, 2), \\\n\t.enable_reg = ATC2609A_PMU_LDO##num##_CTL0, \\\n\t.enable_mask = BIT(0), \\\n\t.enable_time = 2000, \\\n\t.bypass_reg = ATC2609A_PMU_LDO##num##_CTL0, \\\n\t.bypass_mask = BIT(1), \\\n\t.owner = THIS_MODULE, \\\n}\n\n#define atc2609a_reg_desc_ldo_range_pick(num, n_range, n_volt) { \\\n\t.name = \"LDO\"#num, \\\n\t.supply_name = \"ldo\"#num, \\\n\t.of_match = of_match_ptr(\"ldo\"#num), \\\n\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t.id = ATC2609A_ID_LDO##num, \\\n\t.ops = &atc260x_ldo_range_pick_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.linear_ranges = atc2609a_ldo_voltage_ranges##n_range, \\\n\t.n_linear_ranges = ARRAY_SIZE(atc2609a_ldo_voltage_ranges##n_range), \\\n\t.n_voltages = n_volt, \\\n\t.vsel_reg = ATC2609A_PMU_LDO##num##_CTL0, \\\n\t.vsel_mask = GENMASK(4, 1), \\\n\t.vsel_range_reg = ATC2609A_PMU_LDO##num##_CTL0, \\\n\t.vsel_range_mask = BIT(5), \\\n\t.linear_range_selectors_bitfield = atc260x_ldo_voltage_range_sel, \\\n\t.enable_reg = ATC2609A_PMU_LDO##num##_CTL0, \\\n\t.enable_mask = BIT(0), \\\n\t.enable_time = 2000, \\\n\t.owner = THIS_MODULE, \\\n}\n\n#define atc2609a_reg_desc_ldo_fixed(num) { \\\n\t.name = \"LDO\"#num, \\\n\t.supply_name = \"ldo\"#num, \\\n\t.of_match = of_match_ptr(\"ldo\"#num), \\\n\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t.id = ATC2609A_ID_LDO##num, \\\n\t.ops = &atc260x_ldo_fixed_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.min_uV = 2600000, \\\n\t.uV_step = 100000, \\\n\t.n_voltages = 8, \\\n\t.vsel_reg = ATC2609A_PMU_LDO##num##_CTL, \\\n\t.vsel_mask = GENMASK(15, 13), \\\n\t.enable_time = 2000, \\\n\t.owner = THIS_MODULE, \\\n}\n\nstatic const struct regulator_desc atc2609a_reg[] = {\n\tatc2609a_reg_desc_dcdc(0, 4),\n\tatc2609a_reg_desc_dcdc(1, 5),\n\tatc2609a_reg_desc_dcdc(2, 6),\n\tatc2609a_reg_desc_dcdc_range(3, 7),\n\tatc2609a_reg_desc_dcdc(4, 8),\n\tatc2609a_reg_desc_ldo_bypass(0),\n\tatc2609a_reg_desc_ldo_bypass(1),\n\tatc2609a_reg_desc_ldo_bypass(2),\n\tatc2609a_reg_desc_ldo_range_pick(3, 0, 29),\n\tatc2609a_reg_desc_ldo_range_pick(4, 0, 29),\n\tatc2609a_reg_desc_ldo(5),\n\tatc2609a_reg_desc_ldo_range_pick(6, 1, 28),\n\tatc2609a_reg_desc_ldo_range_pick(7, 0, 29),\n\tatc2609a_reg_desc_ldo_range_pick(8, 0, 29),\n\tatc2609a_reg_desc_ldo_fixed(9),\n};\n\nstatic int atc260x_regulator_probe(struct platform_device *pdev)\n{\n\tstruct atc260x *atc260x = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = atc260x->dev;\n\tstruct atc260x_regulator_data *atc260x_data;\n\tstruct regulator_config config = {};\n\tstruct regulator_dev *atc260x_rdev;\n\tconst struct regulator_desc *regulators;\n\tbool atc2603c_ver_b = false;\n\tint i, nregulators;\n\n\tatc260x_data = devm_kzalloc(&pdev->dev, sizeof(*atc260x_data), GFP_KERNEL);\n\tif (!atc260x_data)\n\t\treturn -ENOMEM;\n\n\tatc260x_data->voltage_time_dcdc = 350;\n\tatc260x_data->voltage_time_ldo = 800;\n\n\tswitch (atc260x->ic_type) {\n\tcase ATC2603C:\n\t\tregulators = atc2603c_reg;\n\t\tnregulators = ATC2603C_ID_MAX;\n\t\tatc2603c_ver_b = atc260x->ic_ver == ATC260X_B;\n\t\tbreak;\n\tcase ATC2609A:\n\t\tatc260x_data->voltage_time_dcdc = 250;\n\t\tregulators = atc2609a_reg;\n\t\tnregulators = ATC2609A_ID_MAX;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported ATC260X ID %d\\n\", atc260x->ic_type);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig.dev = dev;\n\tconfig.regmap = atc260x->regmap;\n\tconfig.driver_data = atc260x_data;\n\n\t \n\tfor (i = 0; i < nregulators; i++) {\n\t\tif (atc2603c_ver_b && regulators[i].id == ATC2603C_ID_DCDC2)\n\t\t\tatc260x_rdev = devm_regulator_register(&pdev->dev,\n\t\t\t\t\t\t\t       &atc2603c_reg_dcdc2_ver_b,\n\t\t\t\t\t\t\t       &config);\n\t\telse\n\t\t\tatc260x_rdev = devm_regulator_register(&pdev->dev,\n\t\t\t\t\t\t\t       &regulators[i],\n\t\t\t\t\t\t\t       &config);\n\t\tif (IS_ERR(atc260x_rdev)) {\n\t\t\tdev_err(dev, \"failed to register regulator: %d\\n\", i);\n\t\t\treturn PTR_ERR(atc260x_rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver atc260x_regulator_driver = {\n\t.probe = atc260x_regulator_probe,\n\t.driver = {\n\t\t.name = \"atc260x-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nmodule_platform_driver(atc260x_regulator_driver);\n\nMODULE_DESCRIPTION(\"Regulator driver for ATC260x PMICs\");\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_AUTHOR(\"Cristian Ciocaltea <cristian.ciocaltea@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}