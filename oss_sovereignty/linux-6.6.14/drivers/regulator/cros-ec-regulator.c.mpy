{
  "module_name": "cros-ec-regulator.c",
  "hash_id": "1dfb4b3ccc3330c4ce98d753c8c54a9814c1ccc450af90f8538aa96ac0ada1c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/cros-ec-regulator.c",
  "human_readable_source": "\n\n\n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/slab.h>\n\nstruct cros_ec_regulator_data {\n\tstruct regulator_desc desc;\n\tstruct regulator_dev *dev;\n\tstruct cros_ec_device *ec_dev;\n\n\tu32 index;\n\n\tu16 *voltages_mV;\n\tu16 num_voltages;\n};\n\nstatic int cros_ec_regulator_enable(struct regulator_dev *dev)\n{\n\tstruct cros_ec_regulator_data *data = rdev_get_drvdata(dev);\n\tstruct ec_params_regulator_enable cmd = {\n\t\t.index = data->index,\n\t\t.enable = 1,\n\t};\n\n\treturn cros_ec_cmd(data->ec_dev, 0, EC_CMD_REGULATOR_ENABLE, &cmd,\n\t\t\t   sizeof(cmd), NULL, 0);\n}\n\nstatic int cros_ec_regulator_disable(struct regulator_dev *dev)\n{\n\tstruct cros_ec_regulator_data *data = rdev_get_drvdata(dev);\n\tstruct ec_params_regulator_enable cmd = {\n\t\t.index = data->index,\n\t\t.enable = 0,\n\t};\n\n\treturn cros_ec_cmd(data->ec_dev, 0, EC_CMD_REGULATOR_ENABLE, &cmd,\n\t\t\t   sizeof(cmd), NULL, 0);\n}\n\nstatic int cros_ec_regulator_is_enabled(struct regulator_dev *dev)\n{\n\tstruct cros_ec_regulator_data *data = rdev_get_drvdata(dev);\n\tstruct ec_params_regulator_is_enabled cmd = {\n\t\t.index = data->index,\n\t};\n\tstruct ec_response_regulator_is_enabled resp;\n\tint ret;\n\n\tret = cros_ec_cmd(data->ec_dev, 0, EC_CMD_REGULATOR_IS_ENABLED, &cmd,\n\t\t\t  sizeof(cmd), &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\treturn resp.enabled;\n}\n\nstatic int cros_ec_regulator_list_voltage(struct regulator_dev *dev,\n\t\t\t\t\t  unsigned int selector)\n{\n\tstruct cros_ec_regulator_data *data = rdev_get_drvdata(dev);\n\n\tif (selector >= data->num_voltages)\n\t\treturn -EINVAL;\n\n\treturn data->voltages_mV[selector] * 1000;\n}\n\nstatic int cros_ec_regulator_get_voltage(struct regulator_dev *dev)\n{\n\tstruct cros_ec_regulator_data *data = rdev_get_drvdata(dev);\n\tstruct ec_params_regulator_get_voltage cmd = {\n\t\t.index = data->index,\n\t};\n\tstruct ec_response_regulator_get_voltage resp;\n\tint ret;\n\n\tret = cros_ec_cmd(data->ec_dev, 0, EC_CMD_REGULATOR_GET_VOLTAGE, &cmd,\n\t\t\t  sizeof(cmd), &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\treturn resp.voltage_mv * 1000;\n}\n\nstatic int cros_ec_regulator_set_voltage(struct regulator_dev *dev, int min_uV,\n\t\t\t\t\t int max_uV, unsigned int *selector)\n{\n\tstruct cros_ec_regulator_data *data = rdev_get_drvdata(dev);\n\tint min_mV = DIV_ROUND_UP(min_uV, 1000);\n\tint max_mV = max_uV / 1000;\n\tstruct ec_params_regulator_set_voltage cmd = {\n\t\t.index = data->index,\n\t\t.min_mv = min_mV,\n\t\t.max_mv = max_mV,\n\t};\n\n\t \n\tif (min_mV > max_mV)\n\t\treturn -EINVAL;\n\n\treturn cros_ec_cmd(data->ec_dev, 0, EC_CMD_REGULATOR_SET_VOLTAGE, &cmd,\n\t\t\t   sizeof(cmd), NULL, 0);\n}\n\nstatic const struct regulator_ops cros_ec_regulator_voltage_ops = {\n\t.enable = cros_ec_regulator_enable,\n\t.disable = cros_ec_regulator_disable,\n\t.is_enabled = cros_ec_regulator_is_enabled,\n\t.list_voltage = cros_ec_regulator_list_voltage,\n\t.get_voltage = cros_ec_regulator_get_voltage,\n\t.set_voltage = cros_ec_regulator_set_voltage,\n};\n\nstatic int cros_ec_regulator_init_info(struct device *dev,\n\t\t\t\t       struct cros_ec_regulator_data *data)\n{\n\tstruct ec_params_regulator_get_info cmd = {\n\t\t.index = data->index,\n\t};\n\tstruct ec_response_regulator_get_info resp;\n\tint ret;\n\n\tret = cros_ec_cmd(data->ec_dev, 0, EC_CMD_REGULATOR_GET_INFO, &cmd,\n\t\t\t  sizeof(cmd), &resp, sizeof(resp));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata->num_voltages =\n\t\tmin_t(u16, ARRAY_SIZE(resp.voltages_mv), resp.num_voltages);\n\tdata->voltages_mV =\n\t\tdevm_kmemdup(dev, resp.voltages_mv,\n\t\t\t     sizeof(u16) * data->num_voltages, GFP_KERNEL);\n\tif (!data->voltages_mV)\n\t\treturn -ENOMEM;\n\n\tdata->desc.n_voltages = data->num_voltages;\n\n\t \n\tresp.name[ARRAY_SIZE(resp.name) - 1] = '\\0';\n\tdata->desc.name = devm_kstrdup(dev, resp.name, GFP_KERNEL);\n\tif (!data->desc.name)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int cros_ec_regulator_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct cros_ec_regulator_data *drvdata;\n\tstruct regulator_init_data *init_data;\n\tstruct regulator_config cfg = {};\n\tstruct regulator_desc *desc;\n\tint ret;\n\n\tdrvdata = devm_kzalloc(\n\t\t&pdev->dev, sizeof(struct cros_ec_regulator_data), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->ec_dev = dev_get_drvdata(dev->parent);\n\tdesc = &drvdata->desc;\n\n\tinit_data = of_get_regulator_init_data(dev, np, desc);\n\tif (!init_data)\n\t\treturn -EINVAL;\n\n\tret = of_property_read_u32(np, \"reg\", &drvdata->index);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdesc->owner = THIS_MODULE;\n\tdesc->type = REGULATOR_VOLTAGE;\n\tdesc->ops = &cros_ec_regulator_voltage_ops;\n\n\tret = cros_ec_regulator_init_info(dev, drvdata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcfg.dev = &pdev->dev;\n\tcfg.init_data = init_data;\n\tcfg.driver_data = drvdata;\n\tcfg.of_node = np;\n\n\tdrvdata->dev = devm_regulator_register(dev, &drvdata->desc, &cfg);\n\tif (IS_ERR(drvdata->dev)) {\n\t\tret = PTR_ERR(drvdata->dev);\n\t\tdev_err(&pdev->dev, \"Failed to register regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, drvdata);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id regulator_cros_ec_of_match[] = {\n\t{ .compatible = \"google,cros-ec-regulator\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, regulator_cros_ec_of_match);\n\nstatic struct platform_driver cros_ec_regulator_driver = {\n\t.probe\t\t= cros_ec_regulator_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"cros-ec-regulator\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = regulator_cros_ec_of_match,\n\t},\n};\n\nmodule_platform_driver(cros_ec_regulator_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ChromeOS EC controlled regulator\");\nMODULE_AUTHOR(\"Pi-Hsun Shih <pihsun@chromium.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}