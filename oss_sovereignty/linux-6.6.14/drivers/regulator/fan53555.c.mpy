{
  "module_name": "fan53555.c",
  "hash_id": "54e4374cc603280b7b81dd409298283576700a3c55e20b09e10a2a5070c46a3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/fan53555.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/param.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/fan53555.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/slab.h>\n\n \n#define FAN53555_VSEL0\t\t0x00\n#define FAN53555_VSEL1\t\t0x01\n\n#define RK8602_VSEL0\t\t0x06\n#define RK8602_VSEL1\t\t0x07\n\n#define TCS4525_VSEL0\t\t0x11\n#define TCS4525_VSEL1\t\t0x10\n#define TCS4525_TIME\t\t0x13\n#define TCS4525_COMMAND\t\t0x14\n\n \n#define FAN53555_CONTROL\t0x02\n \n#define FAN53555_ID1\t\t0x03\n \n#define FAN53555_ID2\t\t0x04\n \n#define FAN53555_MONITOR\t0x05\n\n \n#define VSEL_BUCK_EN\t\tBIT(7)\n#define VSEL_MODE\t\tBIT(6)\n \n#define DIE_ID\t\t\t0x0F\t \n#define DIE_REV\t\t\t0x0F\t \n \n#define CTL_OUTPUT_DISCHG\tBIT(7)\n#define CTL_SLEW_MASK\t\tGENMASK(6, 4)\n#define CTL_RESET\t\tBIT(2)\n#define CTL_MODE_VSEL0_MODE\tBIT(0)\n#define CTL_MODE_VSEL1_MODE\tBIT(1)\n\n#define FAN53555_NVOLTAGES\t64\t \n#define FAN53526_NVOLTAGES\t128\n#define RK8602_NVOLTAGES\t160\n\n#define TCS_VSEL0_MODE\t\tBIT(7)\n#define TCS_VSEL1_MODE\t\tBIT(6)\n\n#define TCS_SLEW_MASK\t\tGENMASK(4, 3)\n\nenum fan53555_vendor {\n\tFAN53526_VENDOR_FAIRCHILD = 0,\n\tFAN53555_VENDOR_FAIRCHILD,\n\tFAN53555_VENDOR_ROCKCHIP,\t \n\tRK8602_VENDOR_ROCKCHIP,\t\t \n\tFAN53555_VENDOR_SILERGY,\n\tFAN53526_VENDOR_TCS,\n};\n\nenum {\n\tFAN53526_CHIP_ID_01 = 1,\n};\n\nenum {\n\tFAN53526_CHIP_REV_08 = 8,\n};\n\n \nenum {\n\tFAN53555_CHIP_ID_00 = 0,\n\tFAN53555_CHIP_ID_01,\n\tFAN53555_CHIP_ID_02,\n\tFAN53555_CHIP_ID_03,\n\tFAN53555_CHIP_ID_04,\n\tFAN53555_CHIP_ID_05,\n\tFAN53555_CHIP_ID_08 = 8,\n};\n\nenum {\n\tRK8600_CHIP_ID_08 = 8,\t\t \n};\n\nenum {\n\tRK8602_CHIP_ID_10 = 10,\t\t \n};\n\nenum {\n\tTCS4525_CHIP_ID_12 = 12,\n};\n\nenum {\n\tTCS4526_CHIP_ID_00 = 0,\n};\n\n \nenum {\n\tFAN53555_CHIP_REV_00 = 0x3,\n\tFAN53555_CHIP_REV_13 = 0xf,\n};\n\nenum {\n\tSILERGY_SYR82X = 8,\n\tSILERGY_SYR83X = 9,\n};\n\nstruct fan53555_device_info {\n\tenum fan53555_vendor vendor;\n\tstruct device *dev;\n\tstruct regulator_desc desc;\n\tstruct regulator_init_data *regulator;\n\t \n\tint chip_id;\n\tint chip_rev;\n\t \n\tunsigned int vol_reg;\n\tunsigned int sleep_reg;\n\tunsigned int en_reg;\n\tunsigned int sleep_en_reg;\n\t \n\tunsigned int vsel_min;\n\tunsigned int vsel_step;\n\tunsigned int vsel_count;\n\t \n\tunsigned int mode_reg;\n\tunsigned int mode_mask;\n\t \n\tunsigned int sleep_vol_cache;\n\t \n\tunsigned int slew_reg;\n\tunsigned int slew_mask;\n\tconst unsigned int *ramp_delay_table;\n\tunsigned int n_ramp_values;\n\tunsigned int slew_rate;\n};\n\nstatic int fan53555_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tstruct fan53555_device_info *di = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tif (di->sleep_vol_cache == uV)\n\t\treturn 0;\n\tret = regulator_map_voltage_linear(rdev, uV, uV);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = regmap_update_bits(rdev->regmap, di->sleep_reg,\n\t\t\t\t di->desc.vsel_mask, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tdi->sleep_vol_cache = uV;\n\n\treturn 0;\n}\n\nstatic int fan53555_set_suspend_enable(struct regulator_dev *rdev)\n{\n\tstruct fan53555_device_info *di = rdev_get_drvdata(rdev);\n\n\treturn regmap_update_bits(rdev->regmap, di->sleep_en_reg,\n\t\t\t\t  VSEL_BUCK_EN, VSEL_BUCK_EN);\n}\n\nstatic int fan53555_set_suspend_disable(struct regulator_dev *rdev)\n{\n\tstruct fan53555_device_info *di = rdev_get_drvdata(rdev);\n\n\treturn regmap_update_bits(rdev->regmap, di->sleep_en_reg,\n\t\t\t\t  VSEL_BUCK_EN, 0);\n}\n\nstatic int fan53555_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct fan53555_device_info *di = rdev_get_drvdata(rdev);\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tregmap_update_bits(rdev->regmap, di->mode_reg,\n\t\t\t\t   di->mode_mask, di->mode_mask);\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tregmap_update_bits(rdev->regmap, di->vol_reg, di->mode_mask, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic unsigned int fan53555_get_mode(struct regulator_dev *rdev)\n{\n\tstruct fan53555_device_info *di = rdev_get_drvdata(rdev);\n\tunsigned int val;\n\tint ret = 0;\n\n\tret = regmap_read(rdev->regmap, di->mode_reg, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (val & di->mode_mask)\n\t\treturn REGULATOR_MODE_FAST;\n\telse\n\t\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic const unsigned int slew_rates[] = {\n\t64000,\n\t32000,\n\t16000,\n\t 8000,\n\t 4000,\n\t 2000,\n\t 1000,\n\t  500,\n};\n\nstatic const unsigned int tcs_slew_rates[] = {\n\t18700,\n\t 9300,\n\t 4600,\n\t 2300,\n};\n\nstatic const struct regulator_ops fan53555_regulator_ops = {\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_time_sel = regulator_set_voltage_time_sel,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_suspend_voltage = fan53555_set_suspend_voltage,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_mode = fan53555_set_mode,\n\t.get_mode = fan53555_get_mode,\n\t.set_ramp_delay = regulator_set_ramp_delay_regmap,\n\t.set_suspend_enable = fan53555_set_suspend_enable,\n\t.set_suspend_disable = fan53555_set_suspend_disable,\n};\n\nstatic int fan53526_voltages_setup_fairchild(struct fan53555_device_info *di)\n{\n\t \n\tswitch (di->chip_id) {\n\tcase FAN53526_CHIP_ID_01:\n\t\tswitch (di->chip_rev) {\n\t\tcase FAN53526_CHIP_REV_08:\n\t\t\tdi->vsel_min = 600000;\n\t\t\tdi->vsel_step = 6250;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(di->dev,\n\t\t\t\t\"Chip ID %d with rev %d not supported!\\n\",\n\t\t\t\tdi->chip_id, di->chip_rev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(di->dev,\n\t\t\t\"Chip ID %d not supported!\\n\", di->chip_id);\n\t\treturn -EINVAL;\n\t}\n\n\tdi->slew_reg = FAN53555_CONTROL;\n\tdi->slew_mask = CTL_SLEW_MASK;\n\tdi->ramp_delay_table = slew_rates;\n\tdi->n_ramp_values = ARRAY_SIZE(slew_rates);\n\tdi->vsel_count = FAN53526_NVOLTAGES;\n\n\treturn 0;\n}\n\nstatic int fan53555_voltages_setup_fairchild(struct fan53555_device_info *di)\n{\n\t \n\tswitch (di->chip_id) {\n\tcase FAN53555_CHIP_ID_00:\n\t\tswitch (di->chip_rev) {\n\t\tcase FAN53555_CHIP_REV_00:\n\t\t\tdi->vsel_min = 600000;\n\t\t\tdi->vsel_step = 10000;\n\t\t\tbreak;\n\t\tcase FAN53555_CHIP_REV_13:\n\t\t\tdi->vsel_min = 800000;\n\t\t\tdi->vsel_step = 10000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(di->dev,\n\t\t\t\t\"Chip ID %d with rev %d not supported!\\n\",\n\t\t\t\tdi->chip_id, di->chip_rev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase FAN53555_CHIP_ID_01:\n\tcase FAN53555_CHIP_ID_03:\n\tcase FAN53555_CHIP_ID_05:\n\tcase FAN53555_CHIP_ID_08:\n\t\tdi->vsel_min = 600000;\n\t\tdi->vsel_step = 10000;\n\t\tbreak;\n\tcase FAN53555_CHIP_ID_04:\n\t\tdi->vsel_min = 603000;\n\t\tdi->vsel_step = 12826;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(di->dev,\n\t\t\t\"Chip ID %d not supported!\\n\", di->chip_id);\n\t\treturn -EINVAL;\n\t}\n\tdi->slew_reg = FAN53555_CONTROL;\n\tdi->slew_mask = CTL_SLEW_MASK;\n\tdi->ramp_delay_table = slew_rates;\n\tdi->n_ramp_values = ARRAY_SIZE(slew_rates);\n\tdi->vsel_count = FAN53555_NVOLTAGES;\n\n\treturn 0;\n}\n\nstatic int fan53555_voltages_setup_rockchip(struct fan53555_device_info *di)\n{\n\t \n\tswitch (di->chip_id) {\n\tcase RK8600_CHIP_ID_08:\n\t\tdi->vsel_min = 712500;\n\t\tdi->vsel_step = 12500;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(di->dev,\n\t\t\t\"Chip ID %d not supported!\\n\", di->chip_id);\n\t\treturn -EINVAL;\n\t}\n\tdi->slew_reg = FAN53555_CONTROL;\n\tdi->slew_mask = CTL_SLEW_MASK;\n\tdi->ramp_delay_table = slew_rates;\n\tdi->n_ramp_values = ARRAY_SIZE(slew_rates);\n\tdi->vsel_count = FAN53555_NVOLTAGES;\n\n\treturn 0;\n}\n\nstatic int rk8602_voltages_setup_rockchip(struct fan53555_device_info *di)\n{\n\t \n\tswitch (di->chip_id) {\n\tcase RK8602_CHIP_ID_10:\n\t\tdi->vsel_min = 500000;\n\t\tdi->vsel_step = 6250;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(di->dev,\n\t\t\t\"Chip ID %d not supported!\\n\", di->chip_id);\n\t\treturn -EINVAL;\n\t}\n\tdi->slew_reg = FAN53555_CONTROL;\n\tdi->slew_mask = CTL_SLEW_MASK;\n\tdi->ramp_delay_table = slew_rates;\n\tdi->n_ramp_values = ARRAY_SIZE(slew_rates);\n\tdi->vsel_count = RK8602_NVOLTAGES;\n\n\treturn 0;\n}\n\nstatic int fan53555_voltages_setup_silergy(struct fan53555_device_info *di)\n{\n\t \n\tswitch (di->chip_id) {\n\tcase SILERGY_SYR82X:\n\tcase SILERGY_SYR83X:\n\t\tdi->vsel_min = 712500;\n\t\tdi->vsel_step = 12500;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(di->dev,\n\t\t\t\"Chip ID %d not supported!\\n\", di->chip_id);\n\t\treturn -EINVAL;\n\t}\n\tdi->slew_reg = FAN53555_CONTROL;\n\tdi->slew_mask = CTL_SLEW_MASK;\n\tdi->ramp_delay_table = slew_rates;\n\tdi->n_ramp_values = ARRAY_SIZE(slew_rates);\n\tdi->vsel_count = FAN53555_NVOLTAGES;\n\n\treturn 0;\n}\n\nstatic int fan53526_voltages_setup_tcs(struct fan53555_device_info *di)\n{\n\tswitch (di->chip_id) {\n\tcase TCS4525_CHIP_ID_12:\n\tcase TCS4526_CHIP_ID_00:\n\t\tdi->slew_reg = TCS4525_TIME;\n\t\tdi->slew_mask = TCS_SLEW_MASK;\n\t\tdi->ramp_delay_table = tcs_slew_rates;\n\t\tdi->n_ramp_values = ARRAY_SIZE(tcs_slew_rates);\n\n\t\t \n\t\tdi->vsel_min = 600000;\n\t\tdi->vsel_step = 6250;\n\t\tdi->vsel_count = FAN53526_NVOLTAGES;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(di->dev, \"Chip ID %d not supported!\\n\", di->chip_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fan53555_device_setup(struct fan53555_device_info *di,\n\t\t\t\tstruct fan53555_platform_data *pdata)\n{\n\tint ret = 0;\n\n\t \n\tswitch (di->vendor) {\n\tcase FAN53526_VENDOR_FAIRCHILD:\n\tcase FAN53555_VENDOR_FAIRCHILD:\n\tcase FAN53555_VENDOR_ROCKCHIP:\n\tcase FAN53555_VENDOR_SILERGY:\n\t\tswitch (pdata->sleep_vsel_id) {\n\t\tcase FAN53555_VSEL_ID_0:\n\t\t\tdi->sleep_reg = FAN53555_VSEL0;\n\t\t\tdi->vol_reg = FAN53555_VSEL1;\n\t\t\tbreak;\n\t\tcase FAN53555_VSEL_ID_1:\n\t\t\tdi->sleep_reg = FAN53555_VSEL1;\n\t\t\tdi->vol_reg = FAN53555_VSEL0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(di->dev, \"Invalid VSEL ID!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdi->sleep_en_reg = di->sleep_reg;\n\t\tdi->en_reg = di->vol_reg;\n\t\tbreak;\n\tcase RK8602_VENDOR_ROCKCHIP:\n\t\tswitch (pdata->sleep_vsel_id) {\n\t\tcase FAN53555_VSEL_ID_0:\n\t\t\tdi->sleep_reg = RK8602_VSEL0;\n\t\t\tdi->vol_reg = RK8602_VSEL1;\n\t\t\tdi->sleep_en_reg = FAN53555_VSEL0;\n\t\t\tdi->en_reg = FAN53555_VSEL1;\n\t\t\tbreak;\n\t\tcase FAN53555_VSEL_ID_1:\n\t\t\tdi->sleep_reg = RK8602_VSEL1;\n\t\t\tdi->vol_reg = RK8602_VSEL0;\n\t\t\tdi->sleep_en_reg = FAN53555_VSEL1;\n\t\t\tdi->en_reg = FAN53555_VSEL0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(di->dev, \"Invalid VSEL ID!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase FAN53526_VENDOR_TCS:\n\t\tswitch (pdata->sleep_vsel_id) {\n\t\tcase FAN53555_VSEL_ID_0:\n\t\t\tdi->sleep_reg = TCS4525_VSEL0;\n\t\t\tdi->vol_reg = TCS4525_VSEL1;\n\t\t\tbreak;\n\t\tcase FAN53555_VSEL_ID_1:\n\t\t\tdi->sleep_reg = TCS4525_VSEL1;\n\t\t\tdi->vol_reg = TCS4525_VSEL0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(di->dev, \"Invalid VSEL ID!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdi->sleep_en_reg = di->sleep_reg;\n\t\tdi->en_reg = di->vol_reg;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(di->dev, \"vendor %d not supported!\\n\", di->vendor);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (di->vendor) {\n\tcase FAN53526_VENDOR_FAIRCHILD:\n\t\tdi->mode_reg = FAN53555_CONTROL;\n\n\t\tswitch (pdata->sleep_vsel_id) {\n\t\tcase FAN53555_VSEL_ID_0:\n\t\t\tdi->mode_mask = CTL_MODE_VSEL1_MODE;\n\t\t\tbreak;\n\t\tcase FAN53555_VSEL_ID_1:\n\t\t\tdi->mode_mask = CTL_MODE_VSEL0_MODE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FAN53555_VENDOR_FAIRCHILD:\n\tcase FAN53555_VENDOR_ROCKCHIP:\n\tcase FAN53555_VENDOR_SILERGY:\n\t\tdi->mode_reg = di->vol_reg;\n\t\tdi->mode_mask = VSEL_MODE;\n\t\tbreak;\n\tcase RK8602_VENDOR_ROCKCHIP:\n\t\tdi->mode_mask = VSEL_MODE;\n\n\t\tswitch (pdata->sleep_vsel_id) {\n\t\tcase FAN53555_VSEL_ID_0:\n\t\t\tdi->mode_reg = FAN53555_VSEL1;\n\t\t\tbreak;\n\t\tcase FAN53555_VSEL_ID_1:\n\t\t\tdi->mode_reg = FAN53555_VSEL0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FAN53526_VENDOR_TCS:\n\t\tdi->mode_reg = TCS4525_COMMAND;\n\n\t\tswitch (pdata->sleep_vsel_id) {\n\t\tcase FAN53555_VSEL_ID_0:\n\t\t\tdi->mode_mask = TCS_VSEL1_MODE;\n\t\t\tbreak;\n\t\tcase FAN53555_VSEL_ID_1:\n\t\t\tdi->mode_mask = TCS_VSEL0_MODE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(di->dev, \"vendor %d not supported!\\n\", di->vendor);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (di->vendor) {\n\tcase FAN53526_VENDOR_FAIRCHILD:\n\t\tret = fan53526_voltages_setup_fairchild(di);\n\t\tbreak;\n\tcase FAN53555_VENDOR_FAIRCHILD:\n\t\tret = fan53555_voltages_setup_fairchild(di);\n\t\tbreak;\n\tcase FAN53555_VENDOR_ROCKCHIP:\n\t\tret = fan53555_voltages_setup_rockchip(di);\n\t\tbreak;\n\tcase RK8602_VENDOR_ROCKCHIP:\n\t\tret = rk8602_voltages_setup_rockchip(di);\n\t\tbreak;\n\tcase FAN53555_VENDOR_SILERGY:\n\t\tret = fan53555_voltages_setup_silergy(di);\n\t\tbreak;\n\tcase FAN53526_VENDOR_TCS:\n\t\tret = fan53526_voltages_setup_tcs(di);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(di->dev, \"vendor %d not supported!\\n\", di->vendor);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int fan53555_regulator_register(struct fan53555_device_info *di,\n\t\t\tstruct regulator_config *config)\n{\n\tstruct regulator_desc *rdesc = &di->desc;\n\tstruct regulator_dev *rdev;\n\n\trdesc->name = \"fan53555-reg\";\n\trdesc->supply_name = \"vin\";\n\trdesc->ops = &fan53555_regulator_ops;\n\trdesc->type = REGULATOR_VOLTAGE;\n\trdesc->n_voltages = di->vsel_count;\n\trdesc->enable_reg = di->en_reg;\n\trdesc->enable_mask = VSEL_BUCK_EN;\n\trdesc->min_uV = di->vsel_min;\n\trdesc->uV_step = di->vsel_step;\n\trdesc->vsel_reg = di->vol_reg;\n\trdesc->vsel_mask = BIT(fls(di->vsel_count - 1)) - 1;\n\trdesc->ramp_reg = di->slew_reg;\n\trdesc->ramp_mask = di->slew_mask;\n\trdesc->ramp_delay_table = di->ramp_delay_table;\n\trdesc->n_ramp_values = di->n_ramp_values;\n\trdesc->owner = THIS_MODULE;\n\n\trdev = devm_regulator_register(di->dev, &di->desc, config);\n\treturn PTR_ERR_OR_ZERO(rdev);\n}\n\nstatic const struct regmap_config fan53555_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic struct fan53555_platform_data *fan53555_parse_dt(struct device *dev,\n\t\t\t\t\t      struct device_node *np,\n\t\t\t\t\t      const struct regulator_desc *desc)\n{\n\tstruct fan53555_platform_data *pdata;\n\tint ret;\n\tu32 tmp;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tpdata->regulator = of_get_regulator_init_data(dev, np, desc);\n\n\tret = of_property_read_u32(np, \"fcs,suspend-voltage-selector\",\n\t\t\t\t   &tmp);\n\tif (!ret)\n\t\tpdata->sleep_vsel_id = tmp;\n\n\treturn pdata;\n}\n\nstatic const struct of_device_id __maybe_unused fan53555_dt_ids[] = {\n\t{\n\t\t.compatible = \"fcs,fan53526\",\n\t\t.data = (void *)FAN53526_VENDOR_FAIRCHILD,\n\t}, {\n\t\t.compatible = \"fcs,fan53555\",\n\t\t.data = (void *)FAN53555_VENDOR_FAIRCHILD\n\t}, {\n\t\t.compatible = \"rockchip,rk8600\",\n\t\t.data = (void *)FAN53555_VENDOR_ROCKCHIP\n\t}, {\n\t\t.compatible = \"rockchip,rk8602\",\n\t\t.data = (void *)RK8602_VENDOR_ROCKCHIP\n\t}, {\n\t\t.compatible = \"silergy,syr827\",\n\t\t.data = (void *)FAN53555_VENDOR_SILERGY,\n\t}, {\n\t\t.compatible = \"silergy,syr828\",\n\t\t.data = (void *)FAN53555_VENDOR_SILERGY,\n\t}, {\n\t\t.compatible = \"tcs,tcs4525\",\n\t\t.data = (void *)FAN53526_VENDOR_TCS\n\t}, {\n\t\t.compatible = \"tcs,tcs4526\",\n\t\t.data = (void *)FAN53526_VENDOR_TCS\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, fan53555_dt_ids);\n\nstatic int fan53555_regulator_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device_node *np = client->dev.of_node;\n\tstruct fan53555_device_info *di;\n\tstruct fan53555_platform_data *pdata;\n\tstruct regulator_config config = { };\n\tstruct regmap *regmap;\n\tunsigned int val;\n\tint ret;\n\n\tdi = devm_kzalloc(&client->dev, sizeof(struct fan53555_device_info),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!di)\n\t\treturn -ENOMEM;\n\n\tpdata = dev_get_platdata(&client->dev);\n\tif (!pdata)\n\t\tpdata = fan53555_parse_dt(&client->dev, np, &di->desc);\n\n\tif (!pdata || !pdata->regulator)\n\t\treturn dev_err_probe(&client->dev, -ENODEV,\n\t\t\t\t     \"Platform data not found!\\n\");\n\n\tdi->regulator = pdata->regulator;\n\tif (client->dev.of_node) {\n\t\tdi->vendor =\n\t\t\t(unsigned long)of_device_get_match_data(&client->dev);\n\t} else {\n\t\t \n\t\tif (!di->regulator->constraints.ramp_delay) {\n\t\t\tif (pdata->slew_rate >= ARRAY_SIZE(slew_rates))\n\t\t\t\treturn dev_err_probe(&client->dev, -EINVAL,\n\t\t\t\t\t\t     \"Invalid slew_rate\\n\");\n\n\t\t\tdi->regulator->constraints.ramp_delay\n\t\t\t\t\t= slew_rates[pdata->slew_rate];\n\t\t}\n\n\t\tdi->vendor = id->driver_data;\n\t}\n\n\tregmap = devm_regmap_init_i2c(client, &fan53555_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(regmap),\n\t\t\t\t     \"Failed to allocate regmap!\\n\");\n\n\tdi->dev = &client->dev;\n\ti2c_set_clientdata(client, di);\n\t \n\tret = regmap_read(regmap, FAN53555_ID1, &val);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&client->dev, ret, \"Failed to get chip ID!\\n\");\n\n\tdi->chip_id = val & DIE_ID;\n\t \n\tret = regmap_read(regmap, FAN53555_ID2, &val);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&client->dev, ret, \"Failed to get chip Rev!\\n\");\n\n\tdi->chip_rev = val & DIE_REV;\n\tdev_info(&client->dev, \"FAN53555 Option[%d] Rev[%d] Detected!\\n\",\n\t\t\t\tdi->chip_id, di->chip_rev);\n\t \n\tret = fan53555_device_setup(di, pdata);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&client->dev, ret, \"Failed to setup device!\\n\");\n\n\t \n\tconfig.dev = di->dev;\n\tconfig.init_data = di->regulator;\n\tconfig.regmap = regmap;\n\tconfig.driver_data = di;\n\tconfig.of_node = np;\n\n\tret = fan53555_regulator_register(di, &config);\n\tif (ret < 0)\n\t\tdev_err_probe(&client->dev, ret, \"Failed to register regulator!\\n\");\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id fan53555_id[] = {\n\t{\n\t\t.name = \"fan53526\",\n\t\t.driver_data = FAN53526_VENDOR_FAIRCHILD\n\t}, {\n\t\t.name = \"fan53555\",\n\t\t.driver_data = FAN53555_VENDOR_FAIRCHILD\n\t}, {\n\t\t.name = \"rk8600\",\n\t\t.driver_data = FAN53555_VENDOR_ROCKCHIP\n\t}, {\n\t\t.name = \"rk8602\",\n\t\t.driver_data = RK8602_VENDOR_ROCKCHIP\n\t}, {\n\t\t.name = \"syr827\",\n\t\t.driver_data = FAN53555_VENDOR_SILERGY\n\t}, {\n\t\t.name = \"syr828\",\n\t\t.driver_data = FAN53555_VENDOR_SILERGY\n\t}, {\n\t\t.name = \"tcs4525\",\n\t\t.driver_data = FAN53526_VENDOR_TCS\n\t}, {\n\t\t.name = \"tcs4526\",\n\t\t.driver_data = FAN53526_VENDOR_TCS\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, fan53555_id);\n\nstatic struct i2c_driver fan53555_regulator_driver = {\n\t.driver = {\n\t\t.name = \"fan53555-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(fan53555_dt_ids),\n\t},\n\t.probe = fan53555_regulator_probe,\n\t.id_table = fan53555_id,\n};\n\nmodule_i2c_driver(fan53555_regulator_driver);\n\nMODULE_AUTHOR(\"Yunfan Zhang <yfzhang@marvell.com>\");\nMODULE_DESCRIPTION(\"FAN53555 regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}