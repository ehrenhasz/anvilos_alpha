{
  "module_name": "mpq7920.c",
  "hash_id": "f3f4b6666a092dead59d31966dfe21a3c1cb0a3d06e1b0cc889f3b1801ac0c36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/mpq7920.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include \"mpq7920.h\"\n\n#define MPQ7920_BUCK_VOLT_RANGE \\\n\t((MPQ7920_VOLT_MAX - MPQ7920_BUCK_VOLT_MIN)/MPQ7920_VOLT_STEP + 1)\n#define MPQ7920_LDO_VOLT_RANGE \\\n\t((MPQ7920_VOLT_MAX - MPQ7920_LDO_VOLT_MIN)/MPQ7920_VOLT_STEP + 1)\n\n#define MPQ7920BUCK(_name, _id, _ilim)\t\t\t\t\t\\\n\t[MPQ7920_BUCK ## _id] = {\t\t\t\t\t\\\n\t\t.id = MPQ7920_BUCK ## _id,\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.of_match = _name,\t\t\t\t\t\\\n\t\t.regulators_node = \"regulators\",\t\t\t\\\n\t\t.of_parse_cb = mpq7920_parse_cb,\t\t\t\\\n\t\t.ops = &mpq7920_buck_ops,\t\t\t\t\\\n\t\t.min_uV = MPQ7920_BUCK_VOLT_MIN,\t\t\t\\\n\t\t.uV_step = MPQ7920_VOLT_STEP,\t\t\t\t\\\n\t\t.n_voltages = MPQ7920_BUCK_VOLT_RANGE,\t\t\t\\\n\t\t.curr_table = _ilim,\t\t\t\t\t\\\n\t\t.n_current_limits = ARRAY_SIZE(_ilim),\t\t\t\\\n\t\t.csel_reg = MPQ7920_BUCK ##_id## _REG_C,\t\t\\\n\t\t.csel_mask = MPQ7920_MASK_BUCK_ILIM,\t\t\t\\\n\t\t.enable_reg = MPQ7920_REG_REGULATOR_EN,\t\t\t\\\n\t\t.enable_mask = BIT(MPQ7920_REGULATOR_EN_OFFSET -\t\\\n\t\t\t\t\t MPQ7920_BUCK ## _id),\t\t\\\n\t\t.vsel_reg = MPQ7920_BUCK ##_id## _REG_A,\t\t\\\n\t\t.vsel_mask = MPQ7920_MASK_VREF,\t\t\t\t\\\n\t\t.active_discharge_on\t= MPQ7920_DISCHARGE_ON,\t\t\\\n\t\t.active_discharge_reg\t= MPQ7920_BUCK ##_id## _REG_B,\t\\\n\t\t.active_discharge_mask\t= MPQ7920_MASK_DISCHARGE,\t\\\n\t\t.soft_start_reg\t\t= MPQ7920_BUCK ##_id## _REG_C,\t\\\n\t\t.soft_start_mask\t= MPQ7920_MASK_SOFTSTART,\t\\\n\t\t.owner\t\t\t= THIS_MODULE,\t\t\t\\\n\t}\n\n#define MPQ7920LDO(_name, _id, _ops, _ilim, _ilim_sz, _creg, _cmask)\t\\\n\t[MPQ7920_LDO ## _id] = {\t\t\t\t\t\\\n\t\t.id = MPQ7920_LDO ## _id,\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.of_match = _name,\t\t\t\t\t\\\n\t\t.regulators_node = \"regulators\",\t\t\t\\\n\t\t.ops = _ops,\t\t\t\t\t\t\\\n\t\t.min_uV = MPQ7920_LDO_VOLT_MIN,\t\t\t\t\\\n\t\t.uV_step = MPQ7920_VOLT_STEP,\t\t\t\t\\\n\t\t.n_voltages = MPQ7920_LDO_VOLT_RANGE,\t\t\t\\\n\t\t.vsel_reg = MPQ7920_LDO ##_id## _REG_A,\t\t\t\\\n\t\t.vsel_mask = MPQ7920_MASK_VREF,\t\t\t\t\\\n\t\t.curr_table = _ilim,\t\t\t\t\t\\\n\t\t.n_current_limits = _ilim_sz,\t\t\t\t\\\n\t\t.csel_reg = _creg,\t\t\t\t\t\\\n\t\t.csel_mask = _cmask,\t\t\t\t\t\\\n\t\t.enable_reg = (_id == 1) ? 0 : MPQ7920_REG_REGULATOR_EN,\\\n\t\t.enable_mask = BIT(MPQ7920_REGULATOR_EN_OFFSET -\t\\\n\t\t\t\t\tMPQ7920_LDO ##_id + 1),\t\t\\\n\t\t.active_discharge_on\t= MPQ7920_DISCHARGE_ON,\t\t\\\n\t\t.active_discharge_mask\t= MPQ7920_MASK_DISCHARGE,\t\\\n\t\t.active_discharge_reg\t= MPQ7920_LDO ##_id## _REG_B,\t\\\n\t\t.type\t\t\t= REGULATOR_VOLTAGE,\t\t\\\n\t\t.owner\t\t\t= THIS_MODULE,\t\t\t\\\n\t}\n\nenum mpq7920_regulators {\n\tMPQ7920_BUCK1,\n\tMPQ7920_BUCK2,\n\tMPQ7920_BUCK3,\n\tMPQ7920_BUCK4,\n\tMPQ7920_LDO1,  \n\tMPQ7920_LDO2,\n\tMPQ7920_LDO3,\n\tMPQ7920_LDO4,\n\tMPQ7920_LDO5,\n\tMPQ7920_MAX_REGULATORS,\n};\n\nstruct mpq7920_regulator_info {\n\tstruct regmap *regmap;\n\tstruct regulator_desc *rdesc;\n};\n\nstatic const struct regmap_config mpq7920_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x25,\n};\n\n \nstatic const unsigned int mpq7920_I_limits1[] = {\n\t4600000, 6600000, 7600000, 9300000\n};\n\n \nstatic const unsigned int mpq7920_I_limits2[] = {\n\t2700000, 3900000, 5100000, 6100000\n};\n\n \nstatic const unsigned int mpq7920_I_limits3[] = {\n\t300000, 700000\n};\n\nstatic int mpq7920_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay);\nstatic int mpq7920_parse_cb(struct device_node *np,\n\t\t\t\tconst struct regulator_desc *rdesc,\n\t\t\t\tstruct regulator_config *config);\n\n \nstatic const struct regulator_ops mpq7920_ldortc_ops = {\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n};\n\nstatic const struct regulator_ops mpq7920_ldo_wo_current_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.set_active_discharge\t= regulator_set_active_discharge_regmap,\n};\n\nstatic const struct regulator_ops mpq7920_ldo_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.set_active_discharge\t= regulator_set_active_discharge_regmap,\n\t.get_current_limit\t= regulator_get_current_limit_regmap,\n\t.set_current_limit\t= regulator_set_current_limit_regmap,\n};\n\nstatic const struct regulator_ops mpq7920_buck_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.set_active_discharge\t= regulator_set_active_discharge_regmap,\n\t.set_soft_start\t\t= regulator_set_soft_start_regmap,\n\t.set_ramp_delay\t\t= mpq7920_set_ramp_delay,\n};\n\nstatic struct regulator_desc mpq7920_regulators_desc[MPQ7920_MAX_REGULATORS] = {\n\tMPQ7920BUCK(\"buck1\", 1, mpq7920_I_limits1),\n\tMPQ7920BUCK(\"buck2\", 2, mpq7920_I_limits2),\n\tMPQ7920BUCK(\"buck3\", 3, mpq7920_I_limits1),\n\tMPQ7920BUCK(\"buck4\", 4, mpq7920_I_limits2),\n\tMPQ7920LDO(\"ldortc\", 1, &mpq7920_ldortc_ops, NULL, 0, 0, 0),\n\tMPQ7920LDO(\"ldo2\", 2, &mpq7920_ldo_wo_current_ops, NULL, 0, 0, 0),\n\tMPQ7920LDO(\"ldo3\", 3, &mpq7920_ldo_wo_current_ops, NULL, 0, 0, 0),\n\tMPQ7920LDO(\"ldo4\", 4, &mpq7920_ldo_ops, mpq7920_I_limits3,\n\t\t\tARRAY_SIZE(mpq7920_I_limits3), MPQ7920_LDO4_REG_B,\n\t\t\tMPQ7920_MASK_LDO_ILIM),\n\tMPQ7920LDO(\"ldo5\", 5, &mpq7920_ldo_ops, mpq7920_I_limits3,\n\t\t\tARRAY_SIZE(mpq7920_I_limits3), MPQ7920_LDO5_REG_B,\n\t\t\tMPQ7920_MASK_LDO_ILIM),\n};\n\n \nstatic int mpq7920_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)\n{\n\tunsigned int ramp_val;\n\n\tif (ramp_delay > 8000 || ramp_delay < 0)\n\t\treturn -EINVAL;\n\n\tif (ramp_delay <= 4000)\n\t\tramp_val = 3;\n\telse\n\t\tramp_val = 2;\n\n\treturn regmap_update_bits(rdev->regmap, MPQ7920_REG_CTL0,\n\t\t\t\t  MPQ7920_MASK_DVS_SLEWRATE, ramp_val << 6);\n}\n\nstatic int mpq7920_parse_cb(struct device_node *np,\n\t\t\t\tconst struct regulator_desc *desc,\n\t\t\t\tstruct regulator_config *config)\n{\n\tuint8_t val;\n\tint ret;\n\tstruct mpq7920_regulator_info *info = config->driver_data;\n\tstruct regulator_desc *rdesc = &info->rdesc[desc->id];\n\n\tif (of_property_read_bool(np, \"mps,buck-ovp-disable\")) {\n\t\tregmap_update_bits(config->regmap,\n\t\t\t\tMPQ7920_BUCK1_REG_B + (rdesc->id * 4),\n\t\t\t\tMPQ7920_MASK_OVP, MPQ7920_OVP_DISABLE);\n\t}\n\n\tret = of_property_read_u8(np, \"mps,buck-phase-delay\", &val);\n\tif (!ret) {\n\t\tregmap_update_bits(config->regmap,\n\t\t\t\tMPQ7920_BUCK1_REG_C + (rdesc->id * 4),\n\t\t\t\tMPQ7920_MASK_BUCK_PHASE_DEALY,\n\t\t\t\t(val & 3) << 4);\n\t}\n\n\tret = of_property_read_u8(np, \"mps,buck-softstart\", &val);\n\tif (!ret)\n\t\trdesc->soft_start_val_on = (val & 3) << 2;\n\n\treturn 0;\n}\n\nstatic void mpq7920_parse_dt(struct device *dev,\n\t\t struct mpq7920_regulator_info *info)\n{\n\tint ret;\n\tstruct device_node *np = dev->of_node;\n\tuint8_t freq;\n\n\tnp = of_get_child_by_name(np, \"regulators\");\n\tif (!np) {\n\t\tdev_err(dev, \"missing 'regulators' subnode in DT\\n\");\n\t\treturn;\n\t}\n\n\tret = of_property_read_u8(np, \"mps,switch-freq\", &freq);\n\tif (!ret) {\n\t\tregmap_update_bits(info->regmap, MPQ7920_REG_CTL0,\n\t\t\t\t\tMPQ7920_MASK_SWITCH_FREQ,\n\t\t\t\t\t(freq & 3) << 4);\n\t}\n\n\tof_node_put(np);\n}\n\nstatic int mpq7920_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct mpq7920_regulator_info *info;\n\tstruct regulator_config config = { NULL, };\n\tstruct regulator_dev *rdev;\n\tstruct regmap *regmap;\n\tint i;\n\n\tinfo = devm_kzalloc(dev, sizeof(struct mpq7920_regulator_info),\n\t\t\t\tGFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->rdesc = mpq7920_regulators_desc;\n\tregmap = devm_regmap_init_i2c(client, &mpq7920_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"Failed to allocate regmap!\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\ti2c_set_clientdata(client, info);\n\tinfo->regmap = regmap;\n\tif (client->dev.of_node)\n\t\tmpq7920_parse_dt(&client->dev, info);\n\n\tconfig.dev = dev;\n\tconfig.regmap = regmap;\n\tconfig.driver_data = info;\n\n\tfor (i = 0; i < MPQ7920_MAX_REGULATORS; i++) {\n\t\trdev = devm_regulator_register(dev,\n\t\t\t\t\t       &mpq7920_regulators_desc[i],\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(dev, \"Failed to register regulator!\\n\");\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mpq7920_of_match[] = {\n\t{ .compatible = \"mps,mpq7920\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mpq7920_of_match);\n\nstatic const struct i2c_device_id mpq7920_id[] = {\n\t{ \"mpq7920\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, mpq7920_id);\n\nstatic struct i2c_driver mpq7920_regulator_driver = {\n\t.driver = {\n\t\t.name = \"mpq7920\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = mpq7920_of_match,\n\t},\n\t.probe = mpq7920_i2c_probe,\n\t.id_table = mpq7920_id,\n};\nmodule_i2c_driver(mpq7920_regulator_driver);\n\nMODULE_AUTHOR(\"Saravanan Sekar <sravanhome@gmail.com>\");\nMODULE_DESCRIPTION(\"MPQ7920 PMIC regulator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}