{
  "module_name": "rn5t618-regulator.c",
  "hash_id": "4118a67010817f5d73c8ba5128cacc9644bfbc68ca3a1530a9aad21c4fdcec20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rn5t618-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/rn5t618.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\nstatic const struct regulator_ops rn5t618_reg_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n};\n\n#define REG(rid, ereg, emask, vreg, vmask, min, max, step)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name\t\t= #rid,\t\t\t\t\t\\\n\t\t.of_match\t= of_match_ptr(#rid),\t\t\t\\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\t\t\\\n\t\t.id\t\t= RN5T618_##rid,\t\t\t\\\n\t\t.type\t\t= REGULATOR_VOLTAGE,\t\t\t\\\n\t\t.owner\t\t= THIS_MODULE,\t\t\t\t\\\n\t\t.ops\t\t= &rn5t618_reg_ops,\t\t\t\\\n\t\t.n_voltages\t= ((max) - (min)) / (step) + 1,\t\t\\\n\t\t.min_uV\t\t= (min),\t\t\t\t\\\n\t\t.uV_step\t= (step),\t\t\t\t\\\n\t\t.enable_reg\t= RN5T618_##ereg,\t\t\t\\\n\t\t.enable_mask\t= (emask),\t\t\t\t\\\n\t\t.vsel_reg\t= RN5T618_##vreg,\t\t\t\\\n\t\t.vsel_mask\t= (vmask),\t\t\t\t\\\n\t}\n\nstatic const struct regulator_desc rn5t567_regulators[] = {\n\t \n\tREG(DCDC1, DC1CTL, BIT(0), DC1DAC, 0xff, 600000, 3500000, 12500),\n\tREG(DCDC2, DC2CTL, BIT(0), DC2DAC, 0xff, 600000, 3500000, 12500),\n\tREG(DCDC3, DC3CTL, BIT(0), DC3DAC, 0xff, 600000, 3500000, 12500),\n\tREG(DCDC4, DC4CTL, BIT(0), DC4DAC, 0xff, 600000, 3500000, 12500),\n\t \n\tREG(LDO1, LDOEN1, BIT(0), LDO1DAC, 0x7f, 900000, 3500000, 25000),\n\tREG(LDO2, LDOEN1, BIT(1), LDO2DAC, 0x7f, 900000, 3500000, 25000),\n\tREG(LDO3, LDOEN1, BIT(2), LDO3DAC, 0x7f, 600000, 3500000, 25000),\n\tREG(LDO4, LDOEN1, BIT(3), LDO4DAC, 0x7f, 900000, 3500000, 25000),\n\tREG(LDO5, LDOEN1, BIT(4), LDO5DAC, 0x7f, 900000, 3500000, 25000),\n\t \n\tREG(LDORTC1, LDOEN2, BIT(4), LDORTCDAC, 0x7f, 1200000, 3500000, 25000),\n\tREG(LDORTC2, LDOEN2, BIT(5), LDORTC2DAC, 0x7f, 900000, 3500000, 25000),\n};\n\nstatic const struct regulator_desc rn5t618_regulators[] = {\n\t \n\tREG(DCDC1, DC1CTL, BIT(0), DC1DAC, 0xff, 600000, 3500000, 12500),\n\tREG(DCDC2, DC2CTL, BIT(0), DC2DAC, 0xff, 600000, 3500000, 12500),\n\tREG(DCDC3, DC3CTL, BIT(0), DC3DAC, 0xff, 600000, 3500000, 12500),\n\t \n\tREG(LDO1, LDOEN1, BIT(0), LDO1DAC, 0x7f, 900000, 3500000, 25000),\n\tREG(LDO2, LDOEN1, BIT(1), LDO2DAC, 0x7f, 900000, 3500000, 25000),\n\tREG(LDO3, LDOEN1, BIT(2), LDO3DAC, 0x7f, 600000, 3500000, 25000),\n\tREG(LDO4, LDOEN1, BIT(3), LDO4DAC, 0x7f, 900000, 3500000, 25000),\n\tREG(LDO5, LDOEN1, BIT(4), LDO5DAC, 0x7f, 900000, 3500000, 25000),\n\t \n\tREG(LDORTC1, LDOEN2, BIT(4), LDORTCDAC, 0x7f, 1700000, 3500000, 25000),\n\tREG(LDORTC2, LDOEN2, BIT(5), LDORTC2DAC, 0x7f, 900000, 3500000, 25000),\n};\n\nstatic const struct regulator_desc rc5t619_regulators[] = {\n\t \n\tREG(DCDC1, DC1CTL, BIT(0), DC1DAC, 0xff, 600000, 3500000, 12500),\n\tREG(DCDC2, DC2CTL, BIT(0), DC2DAC, 0xff, 600000, 3500000, 12500),\n\tREG(DCDC3, DC3CTL, BIT(0), DC3DAC, 0xff, 600000, 3500000, 12500),\n\tREG(DCDC4, DC4CTL, BIT(0), DC4DAC, 0xff, 600000, 3500000, 12500),\n\tREG(DCDC5, DC5CTL, BIT(0), DC5DAC, 0xff, 600000, 3500000, 12500),\n\t \n\tREG(LDO1, LDOEN1, BIT(0), LDO1DAC, 0x7f, 900000, 3500000, 25000),\n\tREG(LDO2, LDOEN1, BIT(1), LDO2DAC, 0x7f, 900000, 3500000, 25000),\n\tREG(LDO3, LDOEN1, BIT(2), LDO3DAC, 0x7f, 900000, 3500000, 25000),\n\tREG(LDO4, LDOEN1, BIT(3), LDO4DAC, 0x7f, 900000, 3500000, 25000),\n\tREG(LDO5, LDOEN1, BIT(4), LDO5DAC, 0x7f, 600000, 3500000, 25000),\n\tREG(LDO6, LDOEN1, BIT(5), LDO6DAC, 0x7f, 600000, 3500000, 25000),\n\tREG(LDO7, LDOEN1, BIT(6), LDO7DAC, 0x7f, 900000, 3500000, 25000),\n\tREG(LDO8, LDOEN1, BIT(7), LDO8DAC, 0x7f, 900000, 3500000, 25000),\n\tREG(LDO9, LDOEN2, BIT(0), LDO9DAC, 0x7f, 900000, 3500000, 25000),\n\tREG(LDO10, LDOEN2, BIT(1), LDO10DAC, 0x7f, 900000, 3500000, 25000),\n\t \n\tREG(LDORTC1, LDOEN2, BIT(4), LDORTCDAC, 0x7f, 1700000, 3500000, 25000),\n\tREG(LDORTC2, LDOEN2, BIT(5), LDORTC2DAC, 0x7f, 900000, 3500000, 25000),\n};\n\nstatic int rn5t618_regulator_probe(struct platform_device *pdev)\n{\n\tstruct rn5t618 *rn5t618 = dev_get_drvdata(pdev->dev.parent);\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tconst struct regulator_desc *regulators;\n\tint i;\n\tint num_regulators = 0;\n\n\tswitch (rn5t618->variant) {\n\tcase RN5T567:\n\t\tregulators = rn5t567_regulators;\n\t\tnum_regulators = ARRAY_SIZE(rn5t567_regulators);\n\t\tbreak;\n\tcase RN5T618:\n\t\tregulators = rn5t618_regulators;\n\t\tnum_regulators = ARRAY_SIZE(rn5t618_regulators);\n\t\tbreak;\n\tcase RC5T619:\n\t\tregulators = rc5t619_regulators;\n\t\tnum_regulators = ARRAY_SIZE(rc5t619_regulators);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tconfig.dev = pdev->dev.parent;\n\tconfig.regmap = rn5t618->regmap;\n\n\tfor (i = 0; i < num_regulators; i++) {\n\t\trdev = devm_regulator_register(&pdev->dev,\n\t\t\t\t\t       &regulators[i],\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&pdev->dev, \"failed to register %s regulator\\n\",\n\t\t\t\tregulators[i].name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver rn5t618_regulator_driver = {\n\t.probe = rn5t618_regulator_probe,\n\t.driver = {\n\t\t.name\t= \"rn5t618-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nmodule_platform_driver(rn5t618_regulator_driver);\n\nMODULE_ALIAS(\"platform:rn5t618-regulator\");\nMODULE_AUTHOR(\"Beniamino Galvani <b.galvani@gmail.com>\");\nMODULE_DESCRIPTION(\"RN5T618 regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}