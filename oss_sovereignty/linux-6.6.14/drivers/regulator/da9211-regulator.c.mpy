{
  "module_name": "da9211-regulator.c",
  "hash_id": "ec12cd09c8b7591b1761a28cca21680bd7fc5ef124ceccf552671bcbb623c787",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/da9211-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regmap.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regulator/da9211.h>\n#include <dt-bindings/regulator/dlg,da9211-regulator.h>\n#include \"da9211-regulator.h\"\n\n \n#define DA9211_DEVICE_ID\t0x22\n#define DA9213_DEVICE_ID\t0x23\n#define DA9215_DEVICE_ID\t0x24\n\n \n#define DA9211_ID_BUCKA\t0\n#define DA9211_ID_BUCKB\t1\n\nstruct da9211 {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct da9211_pdata *pdata;\n\tstruct regulator_dev *rdev[DA9211_MAX_REGULATORS];\n\tint num_regulator;\n\tint chip_irq;\n\tint chip_id;\n};\n\nstatic const struct regmap_range_cfg da9211_regmap_range[] = {\n\t{\n\t\t.selector_reg = DA9211_REG_PAGE_CON,\n\t\t.selector_mask  = DA9211_REG_PAGE_MASK,\n\t\t.selector_shift = DA9211_REG_PAGE_SHIFT,\n\t\t.window_start = 0,\n\t\t.window_len = 256,\n\t\t.range_min = 0,\n\t\t.range_max = 5*128,\n\t},\n};\n\nstatic bool da9211_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase DA9211_REG_STATUS_A:\n\tcase DA9211_REG_STATUS_B:\n\tcase DA9211_REG_EVENT_A:\n\tcase DA9211_REG_EVENT_B:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const struct regmap_config da9211_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 5 * 128,\n\t.volatile_reg = da9211_volatile_reg,\n\t.cache_type = REGCACHE_RBTREE,\n\t.ranges = da9211_regmap_range,\n\t.num_ranges = ARRAY_SIZE(da9211_regmap_range),\n};\n\n \n#define DA9211_MIN_MV\t\t300\n#define DA9211_MAX_MV\t\t1570\n#define DA9211_STEP_MV\t\t10\n\n \nstatic const int da9211_current_limits[] = {\n\t2000000, 2200000, 2400000, 2600000, 2800000, 3000000, 3200000, 3400000,\n\t3600000, 3800000, 4000000, 4200000, 4400000, 4600000, 4800000, 5000000\n};\n \nstatic const int da9213_current_limits[] = {\n\t3000000, 3200000, 3400000, 3600000, 3800000, 4000000, 4200000, 4400000,\n\t4600000, 4800000, 5000000, 5200000, 5400000, 5600000, 5800000, 6000000\n};\n \nstatic const int da9215_current_limits[] = {\n\t4000000, 4200000, 4400000, 4600000, 4800000, 5000000, 5200000, 5400000,\n\t5600000, 5800000, 6000000, 6200000, 6400000, 6600000, 6800000, 7000000\n};\n\nstatic unsigned int da9211_map_buck_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase DA9211_BUCK_MODE_SLEEP:\n\t\treturn REGULATOR_MODE_STANDBY;\n\tcase DA9211_BUCK_MODE_SYNC:\n\t\treturn REGULATOR_MODE_FAST;\n\tcase DA9211_BUCK_MODE_AUTO:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic unsigned int da9211_buck_get_mode(struct regulator_dev *rdev)\n{\n\tint id = rdev_get_id(rdev);\n\tstruct da9211 *chip = rdev_get_drvdata(rdev);\n\tunsigned int data;\n\tint ret, mode = 0;\n\n\tret = regmap_read(chip->regmap, DA9211_REG_BUCKA_CONF+id, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (data & 0x03) {\n\tcase DA9211_BUCK_MODE_SYNC:\n\t\tmode = REGULATOR_MODE_FAST;\n\t\tbreak;\n\tcase DA9211_BUCK_MODE_AUTO:\n\t\tmode = REGULATOR_MODE_NORMAL;\n\t\tbreak;\n\tcase DA9211_BUCK_MODE_SLEEP:\n\t\tmode = REGULATOR_MODE_STANDBY;\n\t\tbreak;\n\t}\n\n\treturn mode;\n}\n\nstatic int da9211_buck_set_mode(struct regulator_dev *rdev,\n\t\t\t\t\tunsigned int mode)\n{\n\tint id = rdev_get_id(rdev);\n\tstruct da9211 *chip = rdev_get_drvdata(rdev);\n\tint val = 0;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tval = DA9211_BUCK_MODE_SYNC;\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = DA9211_BUCK_MODE_AUTO;\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tval = DA9211_BUCK_MODE_SLEEP;\n\t\tbreak;\n\t}\n\n\treturn regmap_update_bits(chip->regmap, DA9211_REG_BUCKA_CONF+id,\n\t\t\t\t\t0x03, val);\n}\n\nstatic int da9211_set_current_limit(struct regulator_dev *rdev, int min,\n\t\t\t\t    int max)\n{\n\tint id = rdev_get_id(rdev);\n\tstruct da9211 *chip = rdev_get_drvdata(rdev);\n\tint i, max_size;\n\tconst int *current_limits;\n\n\tswitch (chip->chip_id) {\n\tcase DA9211:\n\t\tcurrent_limits = da9211_current_limits;\n\t\tmax_size = ARRAY_SIZE(da9211_current_limits)-1;\n\t\tbreak;\n\tcase DA9213:\n\t\tcurrent_limits = da9213_current_limits;\n\t\tmax_size = ARRAY_SIZE(da9213_current_limits)-1;\n\t\tbreak;\n\tcase DA9215:\n\t\tcurrent_limits = da9215_current_limits;\n\t\tmax_size = ARRAY_SIZE(da9215_current_limits)-1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = max_size; i >= 0; i--) {\n\t\tif (min <= current_limits[i] &&\n\t\t    max >= current_limits[i]) {\n\t\t\t\treturn regmap_update_bits(chip->regmap,\n\t\t\t\t\tDA9211_REG_BUCK_ILIM,\n\t\t\t\t\t(0x0F << id*4), (i << id*4));\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int da9211_get_current_limit(struct regulator_dev *rdev)\n{\n\tint id = rdev_get_id(rdev);\n\tstruct da9211 *chip = rdev_get_drvdata(rdev);\n\tunsigned int data;\n\tint ret;\n\tconst int *current_limits;\n\n\tswitch (chip->chip_id) {\n\tcase DA9211:\n\t\tcurrent_limits = da9211_current_limits;\n\t\tbreak;\n\tcase DA9213:\n\t\tcurrent_limits = da9213_current_limits;\n\t\tbreak;\n\tcase DA9215:\n\t\tcurrent_limits = da9215_current_limits;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_read(chip->regmap, DA9211_REG_BUCK_ILIM, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdata = (data >> id*4) & 0x0F;\n\treturn current_limits[data];\n}\n\nstatic const struct regulator_ops da9211_buck_ops = {\n\t.get_mode = da9211_buck_get_mode,\n\t.set_mode = da9211_buck_set_mode,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_current_limit = da9211_set_current_limit,\n\t.get_current_limit = da9211_get_current_limit,\n};\n\n#define DA9211_BUCK(_id) \\\n{\\\n\t.name = #_id,\\\n\t.ops = &da9211_buck_ops,\\\n\t.type = REGULATOR_VOLTAGE,\\\n\t.id = DA9211_ID_##_id,\\\n\t.n_voltages = (DA9211_MAX_MV - DA9211_MIN_MV) / DA9211_STEP_MV + 1,\\\n\t.min_uV = (DA9211_MIN_MV * 1000),\\\n\t.uV_step = (DA9211_STEP_MV * 1000),\\\n\t.enable_reg = DA9211_REG_BUCKA_CONT + DA9211_ID_##_id,\\\n\t.enable_mask = DA9211_BUCKA_EN,\\\n\t.vsel_reg = DA9211_REG_VBUCKA_A + DA9211_ID_##_id * 2,\\\n\t.vsel_mask = DA9211_VBUCK_MASK,\\\n\t.owner = THIS_MODULE,\\\n\t.of_map_mode = da9211_map_buck_mode,\\\n}\n\nstatic struct regulator_desc da9211_regulators[] = {\n\tDA9211_BUCK(BUCKA),\n\tDA9211_BUCK(BUCKB),\n};\n\n#ifdef CONFIG_OF\nstatic struct of_regulator_match da9211_matches[] = {\n\t[DA9211_ID_BUCKA] = {\n\t\t.name = \"BUCKA\",\n\t\t.desc = &da9211_regulators[DA9211_ID_BUCKA],\n\t},\n\t[DA9211_ID_BUCKB] = {\n\t\t.name = \"BUCKB\",\n\t\t.desc = &da9211_regulators[DA9211_ID_BUCKB],\n\t},\n\t};\n\nstatic struct da9211_pdata *da9211_parse_regulators_dt(\n\t\tstruct device *dev)\n{\n\tstruct da9211_pdata *pdata;\n\tstruct device_node *node;\n\tint i, num, n;\n\n\tnode = of_get_child_by_name(dev->of_node, \"regulators\");\n\tif (!node) {\n\t\tdev_err(dev, \"regulators node not found\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tnum = of_regulator_match(dev, node, da9211_matches,\n\t\t\t\t ARRAY_SIZE(da9211_matches));\n\tof_node_put(node);\n\tif (num < 0) {\n\t\tdev_err(dev, \"Failed to match regulators\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdata->num_buck = num;\n\n\tn = 0;\n\tfor (i = 0; i < ARRAY_SIZE(da9211_matches); i++) {\n\t\tif (!da9211_matches[i].init_data)\n\t\t\tcontinue;\n\n\t\tpdata->init_data[n] = da9211_matches[i].init_data;\n\t\tpdata->reg_node[n] = da9211_matches[i].of_node;\n\t\tpdata->gpiod_ren[n] = devm_fwnode_gpiod_get(dev,\n\t\t\t\t\tof_fwnode_handle(pdata->reg_node[n]),\n\t\t\t\t\t\"enable\",\n\t\t\t\t\tGPIOD_OUT_HIGH |\n\t\t\t\t\t\tGPIOD_FLAGS_BIT_NONEXCLUSIVE,\n\t\t\t\t\t\"da9211-enable\");\n\t\tif (IS_ERR(pdata->gpiod_ren[n]))\n\t\t\tpdata->gpiod_ren[n] = NULL;\n\t\tn++;\n\t}\n\n\treturn pdata;\n}\n#else\nstatic struct da9211_pdata *da9211_parse_regulators_dt(\n\t\tstruct device *dev)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n#endif\n\nstatic irqreturn_t da9211_irq_handler(int irq, void *data)\n{\n\tstruct da9211 *chip = data;\n\tint reg_val, err, ret = IRQ_NONE;\n\n\terr = regmap_read(chip->regmap, DA9211_REG_EVENT_B, &reg_val);\n\tif (err < 0)\n\t\tgoto error_i2c;\n\n\tif (reg_val & DA9211_E_OV_CURR_A) {\n\t\tregulator_notifier_call_chain(chip->rdev[0],\n\t\t\tREGULATOR_EVENT_OVER_CURRENT, NULL);\n\n\t\terr = regmap_write(chip->regmap, DA9211_REG_EVENT_B,\n\t\t\tDA9211_E_OV_CURR_A);\n\t\tif (err < 0)\n\t\t\tgoto error_i2c;\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (reg_val & DA9211_E_OV_CURR_B) {\n\t\tregulator_notifier_call_chain(chip->rdev[1],\n\t\t\tREGULATOR_EVENT_OVER_CURRENT, NULL);\n\n\t\terr = regmap_write(chip->regmap, DA9211_REG_EVENT_B,\n\t\t\tDA9211_E_OV_CURR_B);\n\t\tif (err < 0)\n\t\t\tgoto error_i2c;\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n\nerror_i2c:\n\tdev_err(chip->dev, \"I2C error : %d\\n\", err);\n\treturn IRQ_NONE;\n}\n\nstatic int da9211_regulator_init(struct da9211 *chip)\n{\n\tstruct regulator_config config = { };\n\tint i, ret;\n\tunsigned int data;\n\n\tret = regmap_read(chip->regmap, DA9211_REG_CONFIG_E, &data);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to read CONFIG_E reg: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata &= DA9211_SLAVE_SEL;\n\t \n\tif (chip->pdata->num_buck == 1 && data == 0x00)\n\t\tchip->num_regulator = 1;\n\telse if (chip->pdata->num_buck == 2 && data != 0x00)\n\t\tchip->num_regulator = 2;\n\telse {\n\t\tdev_err(chip->dev, \"Configuration is mismatched\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < chip->num_regulator; i++) {\n\t\tconfig.init_data = chip->pdata->init_data[i];\n\t\tconfig.dev = chip->dev;\n\t\tconfig.driver_data = chip;\n\t\tconfig.regmap = chip->regmap;\n\t\tconfig.of_node = chip->pdata->reg_node[i];\n\n\t\tif (chip->pdata->gpiod_ren[i])\n\t\t\tconfig.ena_gpiod = chip->pdata->gpiod_ren[i];\n\t\telse\n\t\t\tconfig.ena_gpiod = NULL;\n\n\t\t \n\t\tif (config.ena_gpiod)\n\t\t\tdevm_gpiod_unhinge(chip->dev, config.ena_gpiod);\n\t\tchip->rdev[i] = devm_regulator_register(chip->dev,\n\t\t\t&da9211_regulators[i], &config);\n\t\tif (IS_ERR(chip->rdev[i])) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"Failed to register DA9211 regulator\\n\");\n\t\t\treturn PTR_ERR(chip->rdev[i]);\n\t\t}\n\n\t\tif (chip->chip_irq != 0) {\n\t\t\tret = regmap_update_bits(chip->regmap,\n\t\t\t\tDA9211_REG_MASK_B, DA9211_M_OV_CURR_A << i, 0);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(chip->dev,\n\t\t\t\t\t\"Failed to update mask reg: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int da9211_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct da9211 *chip;\n\tint error, ret;\n\tunsigned int data;\n\n\tchip = devm_kzalloc(&i2c->dev, sizeof(struct da9211), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = &i2c->dev;\n\tchip->regmap = devm_regmap_init_i2c(i2c, &da9211_regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\terror = PTR_ERR(chip->regmap);\n\t\tdev_err(chip->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\ti2c_set_clientdata(i2c, chip);\n\n\tchip->pdata = i2c->dev.platform_data;\n\n\tret = regmap_read(chip->regmap, DA9211_REG_DEVICE_ID, &data);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to read DEVICE_ID reg: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (data) {\n\tcase DA9211_DEVICE_ID:\n\t\tchip->chip_id = DA9211;\n\t\tbreak;\n\tcase DA9213_DEVICE_ID:\n\t\tchip->chip_id = DA9213;\n\t\tbreak;\n\tcase DA9215_DEVICE_ID:\n\t\tchip->chip_id = DA9215;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->dev, \"Unsupported device id = 0x%x.\\n\", data);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!chip->pdata)\n\t\tchip->pdata = da9211_parse_regulators_dt(chip->dev);\n\n\tif (IS_ERR(chip->pdata)) {\n\t\tdev_err(chip->dev, \"No regulators defined for the platform\\n\");\n\t\treturn PTR_ERR(chip->pdata);\n\t}\n\n\tchip->chip_irq = i2c->irq;\n\n\tret = da9211_regulator_init(chip);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to initialize regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (chip->chip_irq != 0) {\n\t\tret = devm_request_threaded_irq(chip->dev, chip->chip_irq, NULL,\n\t\t\t\t\tda9211_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_LOW|IRQF_ONESHOT,\n\t\t\t\t\t\"da9211\", chip);\n\t\tif (ret != 0) {\n\t\t\tdev_err(chip->dev, \"Failed to request IRQ: %d\\n\",\n\t\t\t\tchip->chip_irq);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tdev_warn(chip->dev, \"No IRQ configured\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id da9211_i2c_id[] = {\n\t{\"da9211\", DA9211},\n\t{\"da9212\", DA9212},\n\t{\"da9213\", DA9213},\n\t{\"da9223\", DA9223},\n\t{\"da9214\", DA9214},\n\t{\"da9224\", DA9224},\n\t{\"da9215\", DA9215},\n\t{\"da9225\", DA9225},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, da9211_i2c_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id da9211_dt_ids[] = {\n\t{ .compatible = \"dlg,da9211\", .data = &da9211_i2c_id[0] },\n\t{ .compatible = \"dlg,da9212\", .data = &da9211_i2c_id[1] },\n\t{ .compatible = \"dlg,da9213\", .data = &da9211_i2c_id[2] },\n\t{ .compatible = \"dlg,da9223\", .data = &da9211_i2c_id[3] },\n\t{ .compatible = \"dlg,da9214\", .data = &da9211_i2c_id[4] },\n\t{ .compatible = \"dlg,da9224\", .data = &da9211_i2c_id[5] },\n\t{ .compatible = \"dlg,da9215\", .data = &da9211_i2c_id[6] },\n\t{ .compatible = \"dlg,da9225\", .data = &da9211_i2c_id[7] },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, da9211_dt_ids);\n#endif\n\nstatic struct i2c_driver da9211_regulator_driver = {\n\t.driver = {\n\t\t.name = \"da9211\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(da9211_dt_ids),\n\t},\n\t.probe = da9211_i2c_probe,\n\t.id_table = da9211_i2c_id,\n};\n\nmodule_i2c_driver(da9211_regulator_driver);\n\nMODULE_AUTHOR(\"James Ban <James.Ban.opensource@diasemi.com>\");\nMODULE_DESCRIPTION(\"DA9211/DA9212/DA9213/DA9223/DA9214/DA9224/DA9215/DA9225 regulator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}