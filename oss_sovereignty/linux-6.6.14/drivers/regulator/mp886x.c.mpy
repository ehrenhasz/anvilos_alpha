{
  "module_name": "mp886x.c",
  "hash_id": "1de1454932d346172a7a049b086c90ed41b870d7b84182e9abba4b4b58448491",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/mp886x.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n#define MP886X_VSEL\t\t0x00\n#define  MP886X_V_BOOT\t\t(1 << 7)\n#define MP886X_SYSCNTLREG1\t0x01\n#define  MP886X_MODE\t\t(1 << 0)\n#define  MP886X_SLEW_SHIFT\t3\n#define  MP886X_SLEW_MASK\t(0x7 << MP886X_SLEW_SHIFT)\n#define  MP886X_GO\t\t(1 << 6)\n#define  MP886X_EN\t\t(1 << 7)\n#define MP8869_SYSCNTLREG2\t0x02\n\nstruct mp886x_cfg_info {\n\tconst struct regulator_ops *rops;\n\tconst unsigned int slew_rates[8];\n\tconst int switch_freq[4];\n\tconst u8 fs_reg;\n\tconst u8 fs_shift;\n};\n\nstruct mp886x_device_info {\n\tstruct device *dev;\n\tstruct regulator_desc desc;\n\tstruct regulator_init_data *regulator;\n\tstruct gpio_desc *en_gpio;\n\tconst struct mp886x_cfg_info *ci;\n\tu32 r[2];\n\tunsigned int sel;\n};\n\nstatic void mp886x_set_switch_freq(struct mp886x_device_info *di,\n\t\t\t\t   struct regmap *regmap,\n\t\t\t\t   u32 freq)\n{\n\tconst struct mp886x_cfg_info *ci = di->ci;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ci->switch_freq); i++) {\n\t\tif (freq == ci->switch_freq[i]) {\n\t\t\tregmap_update_bits(regmap, ci->fs_reg,\n\t\t\t\t  0x3 << ci->fs_shift, i << ci->fs_shift);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdev_err(di->dev, \"invalid frequency %d\\n\", freq);\n}\n\nstatic int mp886x_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tregmap_update_bits(rdev->regmap, MP886X_SYSCNTLREG1,\n\t\t\t\t   MP886X_MODE, MP886X_MODE);\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tregmap_update_bits(rdev->regmap, MP886X_SYSCNTLREG1,\n\t\t\t\t   MP886X_MODE, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic unsigned int mp886x_get_mode(struct regulator_dev *rdev)\n{\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(rdev->regmap, MP886X_SYSCNTLREG1, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (val & MP886X_MODE)\n\t\treturn REGULATOR_MODE_FAST;\n\telse\n\t\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int mp8869_set_voltage_sel(struct regulator_dev *rdev, unsigned int sel)\n{\n\tint ret;\n\n\tret = regmap_update_bits(rdev->regmap, MP886X_SYSCNTLREG1,\n\t\t\t\t MP886X_GO, MP886X_GO);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsel <<= ffs(rdev->desc->vsel_mask) - 1;\n\treturn regmap_update_bits(rdev->regmap, rdev->desc->vsel_reg,\n\t\t\t\t  MP886X_V_BOOT | rdev->desc->vsel_mask, sel);\n}\n\nstatic inline unsigned int mp8869_scale(unsigned int uv, u32 r1, u32 r2)\n{\n\tu32 tmp = uv * r1 / r2;\n\n\treturn uv + tmp;\n}\n\nstatic int mp8869_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct mp886x_device_info *di = rdev_get_drvdata(rdev);\n\tint ret, uv;\n\tunsigned int val;\n\tbool fbloop;\n\n\tret = regmap_read(rdev->regmap, rdev->desc->vsel_reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tfbloop = val & MP886X_V_BOOT;\n\tif (fbloop) {\n\t\tuv = rdev->desc->min_uV;\n\t\tuv = mp8869_scale(uv, di->r[0], di->r[1]);\n\t\treturn regulator_map_voltage_linear(rdev, uv, uv);\n\t}\n\n\tval &= rdev->desc->vsel_mask;\n\tval >>= ffs(rdev->desc->vsel_mask) - 1;\n\n\treturn val;\n}\n\nstatic const struct regulator_ops mp8869_regulator_ops = {\n\t.set_voltage_sel = mp8869_set_voltage_sel,\n\t.get_voltage_sel = mp8869_get_voltage_sel,\n\t.set_voltage_time_sel = regulator_set_voltage_time_sel,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_mode = mp886x_set_mode,\n\t.get_mode = mp886x_get_mode,\n\t.set_ramp_delay = regulator_set_ramp_delay_regmap,\n};\n\nstatic const struct mp886x_cfg_info mp8869_ci = {\n\t.rops = &mp8869_regulator_ops,\n\t.slew_rates = {\n\t\t40000,\n\t\t30000,\n\t\t20000,\n\t\t10000,\n\t\t5000,\n\t\t2500,\n\t\t1250,\n\t\t625,\n\t},\n\t.switch_freq = {\n\t\t500000,\n\t\t750000,\n\t\t1000000,\n\t\t1250000,\n\t},\n\t.fs_reg = MP8869_SYSCNTLREG2,\n\t.fs_shift = 4,\n};\n\nstatic int mp8867_set_voltage_sel(struct regulator_dev *rdev, unsigned int sel)\n{\n\tstruct mp886x_device_info *di = rdev_get_drvdata(rdev);\n\tint ret, delta;\n\n\tret = mp8869_set_voltage_sel(rdev, sel);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdelta = di->sel - sel;\n\tif (abs(delta) <= 5)\n\t\tret = regmap_update_bits(rdev->regmap, MP886X_SYSCNTLREG1,\n\t\t\t\t\t MP886X_GO, 0);\n\tdi->sel = sel;\n\n\treturn ret;\n}\n\nstatic int mp8867_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct mp886x_device_info *di = rdev_get_drvdata(rdev);\n\tint ret, uv;\n\tunsigned int val;\n\tbool fbloop;\n\n\tret = regmap_read(rdev->regmap, rdev->desc->vsel_reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tfbloop = val & MP886X_V_BOOT;\n\n\tval &= rdev->desc->vsel_mask;\n\tval >>= ffs(rdev->desc->vsel_mask) - 1;\n\n\tif (fbloop) {\n\t\tuv = regulator_list_voltage_linear(rdev, val);\n\t\tuv = mp8869_scale(uv, di->r[0], di->r[1]);\n\t\treturn regulator_map_voltage_linear(rdev, uv, uv);\n\t}\n\n\treturn val;\n}\n\nstatic const struct regulator_ops mp8867_regulator_ops = {\n\t.set_voltage_sel = mp8867_set_voltage_sel,\n\t.get_voltage_sel = mp8867_get_voltage_sel,\n\t.set_voltage_time_sel = regulator_set_voltage_time_sel,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_mode = mp886x_set_mode,\n\t.get_mode = mp886x_get_mode,\n\t.set_ramp_delay = regulator_set_ramp_delay_regmap,\n};\n\nstatic const struct mp886x_cfg_info mp8867_ci = {\n\t.rops = &mp8867_regulator_ops,\n\t.slew_rates = {\n\t\t64000,\n\t\t32000,\n\t\t16000,\n\t\t8000,\n\t\t4000,\n\t\t2000,\n\t\t1000,\n\t\t500,\n\t},\n\t.switch_freq = {\n\t\t500000,\n\t\t750000,\n\t\t1000000,\n\t\t1500000,\n\t},\n\t.fs_reg = MP886X_SYSCNTLREG1,\n\t.fs_shift = 1,\n};\n\nstatic int mp886x_regulator_register(struct mp886x_device_info *di,\n\t\t\t\t     struct regulator_config *config)\n{\n\tstruct regulator_desc *rdesc = &di->desc;\n\tstruct regulator_dev *rdev;\n\n\trdesc->name = \"mp886x-reg\";\n\trdesc->supply_name = \"vin\";\n\trdesc->ops = di->ci->rops;\n\trdesc->type = REGULATOR_VOLTAGE;\n\trdesc->n_voltages = 128;\n\trdesc->enable_reg = MP886X_SYSCNTLREG1;\n\trdesc->enable_mask = MP886X_EN;\n\trdesc->min_uV = 600000;\n\trdesc->uV_step = 10000;\n\trdesc->vsel_reg = MP886X_VSEL;\n\trdesc->vsel_mask = 0x3f;\n\trdesc->ramp_reg = MP886X_SYSCNTLREG1;\n\trdesc->ramp_mask = MP886X_SLEW_MASK;\n\trdesc->ramp_delay_table = di->ci->slew_rates;\n\trdesc->n_ramp_values = ARRAY_SIZE(di->ci->slew_rates);\n\trdesc->owner = THIS_MODULE;\n\n\trdev = devm_regulator_register(di->dev, &di->desc, config);\n\tif (IS_ERR(rdev))\n\t\treturn PTR_ERR(rdev);\n\tdi->sel = rdesc->ops->get_voltage_sel(rdev);\n\treturn 0;\n}\n\nstatic const struct regmap_config mp886x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int mp886x_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct mp886x_device_info *di;\n\tstruct regulator_config config = { };\n\tstruct regmap *regmap;\n\tu32 freq;\n\tint ret;\n\n\tdi = devm_kzalloc(dev, sizeof(struct mp886x_device_info), GFP_KERNEL);\n\tif (!di)\n\t\treturn -ENOMEM;\n\n\tdi->regulator = of_get_regulator_init_data(dev, np, &di->desc);\n\tif (!di->regulator) {\n\t\tdev_err(dev, \"Platform data not found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32_array(np, \"mps,fb-voltage-divider\",\n\t\t\t\t\t di->r, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tdi->en_gpio = devm_gpiod_get(dev, \"enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(di->en_gpio))\n\t\treturn PTR_ERR(di->en_gpio);\n\n\tdi->ci = of_device_get_match_data(dev);\n\tdi->dev = dev;\n\n\tregmap = devm_regmap_init_i2c(client, &mp886x_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"Failed to allocate regmap!\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\ti2c_set_clientdata(client, di);\n\n\tconfig.dev = di->dev;\n\tconfig.init_data = di->regulator;\n\tconfig.regmap = regmap;\n\tconfig.driver_data = di;\n\tconfig.of_node = np;\n\n\tif (!of_property_read_u32(np, \"mps,switch-frequency-hz\", &freq))\n\t\tmp886x_set_switch_freq(di, regmap, freq);\n\n\tret = mp886x_regulator_register(di, &config);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to register regulator!\\n\");\n\treturn ret;\n}\n\nstatic const struct of_device_id mp886x_dt_ids[] = {\n\t{\n\t\t.compatible = \"mps,mp8867\",\n\t\t.data = &mp8867_ci\n\t},\n\t{\n\t\t.compatible = \"mps,mp8869\",\n\t\t.data = &mp8869_ci\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mp886x_dt_ids);\n\nstatic const struct i2c_device_id mp886x_id[] = {\n\t{ \"mp886x\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, mp886x_id);\n\nstatic struct i2c_driver mp886x_regulator_driver = {\n\t.driver = {\n\t\t.name = \"mp886x-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = mp886x_dt_ids,\n\t},\n\t.probe = mp886x_i2c_probe,\n\t.id_table = mp886x_id,\n};\nmodule_i2c_driver(mp886x_regulator_driver);\n\nMODULE_AUTHOR(\"Jisheng Zhang <jszhang@kernel.org>\");\nMODULE_DESCRIPTION(\"MP886x regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}