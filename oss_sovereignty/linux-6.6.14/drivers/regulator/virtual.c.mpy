{
  "module_name": "virtual.c",
  "hash_id": "959e573cc56971cd679d22a3dd29760446af0010e703d6be5a90e1a7005aa764",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/virtual.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\nstruct virtual_consumer_data {\n\tstruct mutex lock;\n\tstruct regulator *regulator;\n\tbool enabled;\n\tint min_uV;\n\tint max_uV;\n\tint min_uA;\n\tint max_uA;\n\tunsigned int mode;\n};\n\nstatic void update_voltage_constraints(struct device *dev,\n\t\t\t\t       struct virtual_consumer_data *data)\n{\n\tint ret;\n\n\tif (data->min_uV && data->max_uV\n\t    && data->min_uV <= data->max_uV) {\n\t\tdev_dbg(dev, \"Requesting %d-%duV\\n\",\n\t\t\tdata->min_uV, data->max_uV);\n\t\tret = regulator_set_voltage(data->regulator,\n\t\t\t\t\tdata->min_uV, data->max_uV);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"regulator_set_voltage() failed: %d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (data->min_uV && data->max_uV && !data->enabled) {\n\t\tdev_dbg(dev, \"Enabling regulator\\n\");\n\t\tret = regulator_enable(data->regulator);\n\t\tif (ret == 0)\n\t\t\tdata->enabled = true;\n\t\telse\n\t\t\tdev_err(dev, \"regulator_enable() failed: %d\\n\",\n\t\t\t\tret);\n\t}\n\n\tif (!(data->min_uV && data->max_uV) && data->enabled) {\n\t\tdev_dbg(dev, \"Disabling regulator\\n\");\n\t\tret = regulator_disable(data->regulator);\n\t\tif (ret == 0)\n\t\t\tdata->enabled = false;\n\t\telse\n\t\t\tdev_err(dev, \"regulator_disable() failed: %d\\n\",\n\t\t\t\tret);\n\t}\n}\n\nstatic void update_current_limit_constraints(struct device *dev,\n\t\t\t\t\t  struct virtual_consumer_data *data)\n{\n\tint ret;\n\n\tif (data->max_uA\n\t    && data->min_uA <= data->max_uA) {\n\t\tdev_dbg(dev, \"Requesting %d-%duA\\n\",\n\t\t\tdata->min_uA, data->max_uA);\n\t\tret = regulator_set_current_limit(data->regulator,\n\t\t\t\t\tdata->min_uA, data->max_uA);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"regulator_set_current_limit() failed: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (data->max_uA && !data->enabled) {\n\t\tdev_dbg(dev, \"Enabling regulator\\n\");\n\t\tret = regulator_enable(data->regulator);\n\t\tif (ret == 0)\n\t\t\tdata->enabled = true;\n\t\telse\n\t\t\tdev_err(dev, \"regulator_enable() failed: %d\\n\",\n\t\t\t\tret);\n\t}\n\n\tif (!(data->min_uA && data->max_uA) && data->enabled) {\n\t\tdev_dbg(dev, \"Disabling regulator\\n\");\n\t\tret = regulator_disable(data->regulator);\n\t\tif (ret == 0)\n\t\t\tdata->enabled = false;\n\t\telse\n\t\t\tdev_err(dev, \"regulator_disable() failed: %d\\n\",\n\t\t\t\tret);\n\t}\n}\n\nstatic ssize_t show_min_uV(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct virtual_consumer_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", data->min_uV);\n}\n\nstatic ssize_t set_min_uV(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct virtual_consumer_data *data = dev_get_drvdata(dev);\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val) != 0)\n\t\treturn count;\n\n\tmutex_lock(&data->lock);\n\n\tdata->min_uV = val;\n\tupdate_voltage_constraints(dev, data);\n\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_max_uV(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct virtual_consumer_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", data->max_uV);\n}\n\nstatic ssize_t set_max_uV(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct virtual_consumer_data *data = dev_get_drvdata(dev);\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val) != 0)\n\t\treturn count;\n\n\tmutex_lock(&data->lock);\n\n\tdata->max_uV = val;\n\tupdate_voltage_constraints(dev, data);\n\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_min_uA(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct virtual_consumer_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", data->min_uA);\n}\n\nstatic ssize_t set_min_uA(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct virtual_consumer_data *data = dev_get_drvdata(dev);\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val) != 0)\n\t\treturn count;\n\n\tmutex_lock(&data->lock);\n\n\tdata->min_uA = val;\n\tupdate_current_limit_constraints(dev, data);\n\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_max_uA(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct virtual_consumer_data *data = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", data->max_uA);\n}\n\nstatic ssize_t set_max_uA(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct virtual_consumer_data *data = dev_get_drvdata(dev);\n\tlong val;\n\n\tif (kstrtol(buf, 10, &val) != 0)\n\t\treturn count;\n\n\tmutex_lock(&data->lock);\n\n\tdata->max_uA = val;\n\tupdate_current_limit_constraints(dev, data);\n\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_mode(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct virtual_consumer_data *data = dev_get_drvdata(dev);\n\n\tswitch (data->mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\treturn sprintf(buf, \"fast\\n\");\n\tcase REGULATOR_MODE_NORMAL:\n\t\treturn sprintf(buf, \"normal\\n\");\n\tcase REGULATOR_MODE_IDLE:\n\t\treturn sprintf(buf, \"idle\\n\");\n\tcase REGULATOR_MODE_STANDBY:\n\t\treturn sprintf(buf, \"standby\\n\");\n\tdefault:\n\t\treturn sprintf(buf, \"unknown\\n\");\n\t}\n}\n\nstatic ssize_t set_mode(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct virtual_consumer_data *data = dev_get_drvdata(dev);\n\tunsigned int mode;\n\tint ret;\n\n\t \n\tif (sysfs_streq(buf, \"fast\\n\"))\n\t\tmode = REGULATOR_MODE_FAST;\n\telse if (sysfs_streq(buf, \"normal\\n\"))\n\t\tmode = REGULATOR_MODE_NORMAL;\n\telse if (sysfs_streq(buf, \"idle\\n\"))\n\t\tmode = REGULATOR_MODE_IDLE;\n\telse if (sysfs_streq(buf, \"standby\\n\"))\n\t\tmode = REGULATOR_MODE_STANDBY;\n\telse {\n\t\tdev_err(dev, \"Configuring invalid mode\\n\");\n\t\treturn count;\n\t}\n\n\tmutex_lock(&data->lock);\n\tret = regulator_set_mode(data->regulator, mode);\n\tif (ret == 0)\n\t\tdata->mode = mode;\n\telse\n\t\tdev_err(dev, \"Failed to configure mode: %d\\n\", ret);\n\tmutex_unlock(&data->lock);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(min_microvolts, 0664, show_min_uV, set_min_uV);\nstatic DEVICE_ATTR(max_microvolts, 0664, show_max_uV, set_max_uV);\nstatic DEVICE_ATTR(min_microamps, 0664, show_min_uA, set_min_uA);\nstatic DEVICE_ATTR(max_microamps, 0664, show_max_uA, set_max_uA);\nstatic DEVICE_ATTR(mode, 0664, show_mode, set_mode);\n\nstatic struct attribute *regulator_virtual_attributes[] = {\n\t&dev_attr_min_microvolts.attr,\n\t&dev_attr_max_microvolts.attr,\n\t&dev_attr_min_microamps.attr,\n\t&dev_attr_max_microamps.attr,\n\t&dev_attr_mode.attr,\n\tNULL\n};\n\nstatic const struct attribute_group regulator_virtual_attr_group = {\n\t.attrs\t= regulator_virtual_attributes,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id regulator_virtual_consumer_of_match[] = {\n\t{ .compatible = \"regulator-virtual-consumer\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, regulator_virtual_consumer_of_match);\n#endif\n\nstatic int regulator_virtual_probe(struct platform_device *pdev)\n{\n\tchar *reg_id = dev_get_platdata(&pdev->dev);\n\tstruct virtual_consumer_data *drvdata;\n\tstatic bool warned;\n\tint ret;\n\n\tif (!warned) {\n\t\twarned = true;\n\t\tpr_warn(\"**********************************************************\\n\");\n\t\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\t\tpr_warn(\"**                                                      **\\n\");\n\t\tpr_warn(\"** regulator-virtual-consumer is only for testing and   **\\n\");\n\t\tpr_warn(\"** debugging.  Do not use it in a production kernel.    **\\n\");\n\t\tpr_warn(\"**                                                      **\\n\");\n\t\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\t\tpr_warn(\"**********************************************************\\n\");\n\t}\n\n\tdrvdata = devm_kzalloc(&pdev->dev, sizeof(struct virtual_consumer_data),\n\t\t\t       GFP_KERNEL);\n\tif (drvdata == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!reg_id && pdev->dev.of_node)\n\t\treg_id = \"default\";\n\n\tmutex_init(&drvdata->lock);\n\n\tdrvdata->regulator = devm_regulator_get(&pdev->dev, reg_id);\n\tif (IS_ERR(drvdata->regulator))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(drvdata->regulator),\n\t\t\t\t     \"Failed to obtain supply '%s'\\n\",\n\t\t\t\t     reg_id);\n\n\tret = sysfs_create_group(&pdev->dev.kobj,\n\t\t\t\t &regulator_virtual_attr_group);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to create attribute group: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrvdata->mode = regulator_get_mode(drvdata->regulator);\n\n\tplatform_set_drvdata(pdev, drvdata);\n\n\treturn 0;\n}\n\nstatic int regulator_virtual_remove(struct platform_device *pdev)\n{\n\tstruct virtual_consumer_data *drvdata = platform_get_drvdata(pdev);\n\n\tsysfs_remove_group(&pdev->dev.kobj, &regulator_virtual_attr_group);\n\n\tif (drvdata->enabled)\n\t\tregulator_disable(drvdata->regulator);\n\n\treturn 0;\n}\n\nstatic struct platform_driver regulator_virtual_consumer_driver = {\n\t.probe\t\t= regulator_virtual_probe,\n\t.remove\t\t= regulator_virtual_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"reg-virt-consumer\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(regulator_virtual_consumer_of_match),\n\t},\n};\n\nmodule_platform_driver(regulator_virtual_consumer_driver);\n\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"Virtual regulator consumer\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:reg-virt-consumer\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}