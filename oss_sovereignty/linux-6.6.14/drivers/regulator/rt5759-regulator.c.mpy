{
  "module_name": "rt5759-regulator.c",
  "hash_id": "0bdc4ea42b970c2d37bd61c9ca212b4f83653d8ef76fbd563ee2fc7184115b96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rt5759-regulator.c",
  "human_readable_source": "\n\n#include <linux/bits.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n#define RT5759_REG_VENDORINFO\t0x00\n#define RT5759_REG_FREQ\t\t0x01\n#define RT5759_REG_VSEL\t\t0x02\n#define RT5759_REG_DCDCCTRL\t0x03\n#define RT5759_REG_STATUS\t0x04\n#define RT5759_REG_DCDCSET\t0x05\n#define RT5759A_REG_WDTEN\t0x42\n\n#define RT5759_TSTEP_MASK\tGENMASK(3, 2)\n#define RT5759_VSEL_MASK\tGENMASK(6, 0)\n#define RT5759_DISCHARGE_MASK\tBIT(3)\n#define RT5759_FPWM_MASK\tBIT(2)\n#define RT5759_ENABLE_MASK\tBIT(1)\n#define RT5759_OT_MASK\t\tBIT(1)\n#define RT5759_UV_MASK\t\tBIT(0)\n#define RT5957_OCLVL_MASK\tGENMASK(7, 6)\n#define RT5759_OCLVL_SHIFT\t6\n#define RT5957_OTLVL_MASK\tGENMASK(5, 4)\n#define RT5759_OTLVL_SHIFT\t4\n#define RT5759A_WDTEN_MASK\tBIT(1)\n\n#define RT5759_MANUFACTURER_ID\t0x82\n \n#define RT5759_NUM_VOLTS\t91\n#define RT5759_MIN_UV\t\t600000\n#define RT5759_STEP_UV\t\t10000\n#define RT5759A_STEP_UV\t\t12500\n#define RT5759_MINSS_TIMEUS\t1500\n\n#define RT5759_PSKIP_MODE\t0\n#define RT5759_FPWM_MODE\t1\n\nenum {\n\tCHIP_TYPE_RT5759 = 0,\n\tCHIP_TYPE_RT5759A,\n\tCHIP_TYPE_MAX\n};\n\nstruct rt5759_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regulator_desc desc;\n\tunsigned long chip_type;\n};\n\nstatic int rt5759_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int mode_val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tmode_val = 0;\n\t\tbreak;\n\tcase REGULATOR_MODE_FAST:\n\t\tmode_val = RT5759_FPWM_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(regmap, RT5759_REG_STATUS, RT5759_FPWM_MASK,\n\t\t\t\t  mode_val);\n}\n\nstatic unsigned int rt5759_get_mode(struct regulator_dev *rdev)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int regval;\n\tint ret;\n\n\tret = regmap_read(regmap, RT5759_REG_DCDCCTRL, &regval);\n\tif (ret)\n\t\treturn REGULATOR_MODE_INVALID;\n\n\tif (regval & RT5759_FPWM_MASK)\n\t\treturn REGULATOR_MODE_FAST;\n\n\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int rt5759_get_error_flags(struct regulator_dev *rdev,\n\t\t\t\t  unsigned int *flags)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int status, events = 0;\n\tint ret;\n\n\tret = regmap_read(regmap, RT5759_REG_STATUS, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status & RT5759_OT_MASK)\n\t\tevents |= REGULATOR_ERROR_OVER_TEMP;\n\n\tif (status & RT5759_UV_MASK)\n\t\tevents |= REGULATOR_ERROR_UNDER_VOLTAGE;\n\n\t*flags = events;\n\treturn 0;\n}\n\nstatic int rt5759_set_ocp(struct regulator_dev *rdev, int lim_uA, int severity,\n\t\t\t  bool enable)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tint ocp_lvl[] = { 9800000, 10800000, 11800000 };\n\tunsigned int ocp_regval;\n\tint i;\n\n\t \n\tif (severity != REGULATOR_SEVERITY_PROT)\n\t\treturn 0;\n\n\tif (enable) {\n\t\t \n\t\tif (lim_uA == 0)\n\t\t\tlim_uA = 10800000;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(ocp_lvl); i++) {\n\t\t\tif (lim_uA <= ocp_lvl[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(ocp_lvl))\n\t\t\ti = ARRAY_SIZE(ocp_lvl) - 1;\n\n\t\tocp_regval = i + 1;\n\t} else\n\t\tocp_regval = 0;\n\n\treturn regmap_update_bits(regmap, RT5759_REG_DCDCSET, RT5957_OCLVL_MASK,\n\t\t\t\t  ocp_regval << RT5759_OCLVL_SHIFT);\n}\n\nstatic int rt5759_set_otp(struct regulator_dev *rdev, int lim, int severity,\n\t\t\t  bool enable)\n{\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tint otp_lvl[] = { 140, 150, 170 };\n\tunsigned int otp_regval;\n\tint i;\n\n\t \n\tif (severity != REGULATOR_SEVERITY_PROT)\n\t\treturn 0;\n\n\tif (enable) {\n\t\t \n\t\tif (lim == 0)\n\t\t\tlim = 150;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(otp_lvl); i++) {\n\t\t\tif (lim <= otp_lvl[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(otp_lvl))\n\t\t\ti = ARRAY_SIZE(otp_lvl) - 1;\n\n\t\totp_regval = i + 1;\n\t} else\n\t\totp_regval = 0;\n\n\treturn regmap_update_bits(regmap, RT5759_REG_DCDCSET, RT5957_OTLVL_MASK,\n\t\t\t\t  otp_regval << RT5759_OTLVL_SHIFT);\n}\n\nstatic const struct regulator_ops rt5759_regulator_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n\t.set_mode = rt5759_set_mode,\n\t.get_mode = rt5759_get_mode,\n\t.set_ramp_delay = regulator_set_ramp_delay_regmap,\n\t.get_error_flags = rt5759_get_error_flags,\n\t.set_over_current_protection = rt5759_set_ocp,\n\t.set_thermal_protection = rt5759_set_otp,\n};\n\nstatic unsigned int rt5759_of_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase RT5759_FPWM_MODE:\n\t\treturn REGULATOR_MODE_FAST;\n\tcase RT5759_PSKIP_MODE:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic const unsigned int rt5759_ramp_table[] = { 20000, 15000, 10000, 5000 };\n\nstatic int rt5759_regulator_register(struct rt5759_priv *priv)\n{\n\tstruct device_node *np = priv->dev->of_node;\n\tstruct regulator_desc *reg_desc = &priv->desc;\n\tstruct regulator_config reg_cfg;\n\tstruct regulator_dev *rdev;\n\tint ret;\n\n\treg_desc->name = \"rt5759-buck\";\n\treg_desc->type = REGULATOR_VOLTAGE;\n\treg_desc->owner = THIS_MODULE;\n\treg_desc->ops = &rt5759_regulator_ops;\n\treg_desc->n_voltages = RT5759_NUM_VOLTS;\n\treg_desc->min_uV = RT5759_MIN_UV;\n\treg_desc->uV_step = RT5759_STEP_UV;\n\treg_desc->vsel_reg = RT5759_REG_VSEL;\n\treg_desc->vsel_mask = RT5759_VSEL_MASK;\n\treg_desc->enable_reg = RT5759_REG_DCDCCTRL;\n\treg_desc->enable_mask = RT5759_ENABLE_MASK;\n\treg_desc->active_discharge_reg = RT5759_REG_DCDCCTRL;\n\treg_desc->active_discharge_mask = RT5759_DISCHARGE_MASK;\n\treg_desc->active_discharge_on = RT5759_DISCHARGE_MASK;\n\treg_desc->ramp_reg = RT5759_REG_FREQ;\n\treg_desc->ramp_mask = RT5759_TSTEP_MASK;\n\treg_desc->ramp_delay_table = rt5759_ramp_table;\n\treg_desc->n_ramp_values = ARRAY_SIZE(rt5759_ramp_table);\n\treg_desc->enable_time = RT5759_MINSS_TIMEUS;\n\treg_desc->of_map_mode = rt5759_of_map_mode;\n\n\t \n\tif (priv->chip_type == CHIP_TYPE_RT5759A)\n\t\treg_desc->uV_step = RT5759A_STEP_UV;\n\n\tmemset(&reg_cfg, 0, sizeof(reg_cfg));\n\treg_cfg.dev = priv->dev;\n\treg_cfg.of_node = np;\n\treg_cfg.init_data = of_get_regulator_init_data(priv->dev, np, reg_desc);\n\treg_cfg.regmap = priv->regmap;\n\n\trdev = devm_regulator_register(priv->dev, reg_desc, &reg_cfg);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\t\tdev_err(priv->dev, \"Failed to register regulator (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt5759_init_device_property(struct rt5759_priv *priv)\n{\n\tunsigned int val = 0;\n\n\t \n\tif (priv->chip_type != CHIP_TYPE_RT5759A)\n\t\treturn 0;\n\n\tif (device_property_read_bool(priv->dev, \"richtek,watchdog-enable\"))\n\t\tval = RT5759A_WDTEN_MASK;\n\n\treturn regmap_update_bits(priv->regmap, RT5759A_REG_WDTEN,\n\t\t\t\t  RT5759A_WDTEN_MASK, val);\n}\n\nstatic int rt5759_manufacturer_check(struct rt5759_priv *priv)\n{\n\tunsigned int vendor;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, RT5759_REG_VENDORINFO, &vendor);\n\tif (ret)\n\t\treturn ret;\n\n\tif (vendor != RT5759_MANUFACTURER_ID) {\n\t\tdev_err(priv->dev, \"vendor info not correct (%d)\\n\", vendor);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool rt5759_is_accessible_reg(struct device *dev, unsigned int reg)\n{\n\tstruct rt5759_priv *priv = dev_get_drvdata(dev);\n\n\tif (reg <= RT5759_REG_DCDCSET)\n\t\treturn true;\n\n\tif (priv->chip_type == CHIP_TYPE_RT5759A && reg == RT5759A_REG_WDTEN)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct regmap_config rt5759_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RT5759A_REG_WDTEN,\n\t.readable_reg = rt5759_is_accessible_reg,\n\t.writeable_reg = rt5759_is_accessible_reg,\n};\n\nstatic int rt5759_probe(struct i2c_client *i2c)\n{\n\tstruct rt5759_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&i2c->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &i2c->dev;\n\tpriv->chip_type = (unsigned long)of_device_get_match_data(&i2c->dev);\n\ti2c_set_clientdata(i2c, priv);\n\n\tpriv->regmap = devm_regmap_init_i2c(i2c, &rt5759_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tret = PTR_ERR(priv->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate regmap (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = rt5759_manufacturer_check(priv);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to check device (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = rt5759_init_device_property(priv);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to init device (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn rt5759_regulator_register(priv);\n}\n\nstatic const struct of_device_id __maybe_unused rt5759_device_table[] = {\n\t{ .compatible = \"richtek,rt5759\", .data = (void *)CHIP_TYPE_RT5759 },\n\t{ .compatible = \"richtek,rt5759a\", .data = (void *)CHIP_TYPE_RT5759A },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rt5759_device_table);\n\nstatic struct i2c_driver rt5759_driver = {\n\t.driver = {\n\t\t.name = \"rt5759\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(rt5759_device_table),\n\t},\n\t.probe = rt5759_probe,\n};\nmodule_i2c_driver(rt5759_driver);\n\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_DESCRIPTION(\"Richtek RT5759 Regulator Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}