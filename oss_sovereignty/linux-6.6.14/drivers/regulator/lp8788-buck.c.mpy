{
  "module_name": "lp8788-buck.c",
  "hash_id": "909125f8781d56d98074995e9f65d2521a34c20ceb7118011efaa2344c0f0a15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/lp8788-buck.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/mfd/lp8788.h>\n#include <linux/gpio.h>\n\n \n#define LP8788_EN_BUCK\t\t\t0x0C\n#define LP8788_BUCK_DVS_SEL\t\t0x1D\n#define LP8788_BUCK1_VOUT0\t\t0x1E\n#define LP8788_BUCK1_VOUT1\t\t0x1F\n#define LP8788_BUCK1_VOUT2\t\t0x20\n#define LP8788_BUCK1_VOUT3\t\t0x21\n#define LP8788_BUCK2_VOUT0\t\t0x22\n#define LP8788_BUCK2_VOUT1\t\t0x23\n#define LP8788_BUCK2_VOUT2\t\t0x24\n#define LP8788_BUCK2_VOUT3\t\t0x25\n#define LP8788_BUCK3_VOUT\t\t0x26\n#define LP8788_BUCK4_VOUT\t\t0x27\n#define LP8788_BUCK1_TIMESTEP\t\t0x28\n#define LP8788_BUCK_PWM\t\t\t0x2D\n\n \n#define LP8788_EN_BUCK1_M\t\tBIT(0)\t \n#define LP8788_EN_BUCK2_M\t\tBIT(1)\n#define LP8788_EN_BUCK3_M\t\tBIT(2)\n#define LP8788_EN_BUCK4_M\t\tBIT(3)\n#define LP8788_BUCK1_DVS_SEL_M\t\t0x04\t \n#define LP8788_BUCK1_DVS_M\t\t0x03\n#define LP8788_BUCK1_DVS_S\t\t0\n#define LP8788_BUCK2_DVS_SEL_M\t\t0x40\n#define LP8788_BUCK2_DVS_M\t\t0x30\n#define LP8788_BUCK2_DVS_S\t\t4\n#define LP8788_BUCK1_DVS_I2C\t\tBIT(2)\n#define LP8788_BUCK2_DVS_I2C\t\tBIT(6)\n#define LP8788_BUCK1_DVS_PIN\t\t(0 << 2)\n#define LP8788_BUCK2_DVS_PIN\t\t(0 << 6)\n#define LP8788_VOUT_M\t\t\t0x1F\t \n#define LP8788_STARTUP_TIME_M\t\t0xF8\t \n#define LP8788_STARTUP_TIME_S\t\t3\n#define LP8788_FPWM_BUCK1_M\t\tBIT(0)\t \n#define LP8788_FPWM_BUCK1_S\t\t0\n#define LP8788_FPWM_BUCK2_M\t\tBIT(1)\n#define LP8788_FPWM_BUCK2_S\t\t1\n#define LP8788_FPWM_BUCK3_M\t\tBIT(2)\n#define LP8788_FPWM_BUCK3_S\t\t2\n#define LP8788_FPWM_BUCK4_M\t\tBIT(3)\n#define LP8788_FPWM_BUCK4_S\t\t3\n\n#define INVALID_ADDR\t\t\t0xFF\n#define LP8788_FORCE_PWM\t\t1\n#define LP8788_AUTO_PWM\t\t\t0\n#define PIN_LOW\t\t\t\t0\n#define PIN_HIGH\t\t\t1\n#define ENABLE_TIME_USEC\t\t32\n\n#define BUCK_FPWM_MASK(x)\t\t(1 << (x))\n#define BUCK_FPWM_SHIFT(x)\t\t(x)\n\nenum lp8788_dvs_state {\n\tDVS_LOW  = GPIOF_OUT_INIT_LOW,\n\tDVS_HIGH = GPIOF_OUT_INIT_HIGH,\n};\n\nenum lp8788_dvs_mode {\n\tREGISTER,\n\tEXTPIN,\n};\n\nenum lp8788_buck_id {\n\tBUCK1,\n\tBUCK2,\n\tBUCK3,\n\tBUCK4,\n};\n\nstruct lp8788_buck {\n\tstruct lp8788 *lp;\n\tstruct regulator_dev *regulator;\n\tvoid *dvs;\n};\n\n \nstatic const struct linear_range buck_volt_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(500000, 0, 0, 0),\n\tREGULATOR_LINEAR_RANGE(800000, 1, 25, 50000),\n};\n\nstatic void lp8788_buck1_set_dvs(struct lp8788_buck *buck)\n{\n\tstruct lp8788_buck1_dvs *dvs = (struct lp8788_buck1_dvs *)buck->dvs;\n\tenum lp8788_dvs_state pinstate;\n\n\tif (!dvs)\n\t\treturn;\n\n\tpinstate = dvs->vsel == DVS_SEL_V0 ? DVS_LOW : DVS_HIGH;\n\tif (gpio_is_valid(dvs->gpio))\n\t\tgpio_set_value(dvs->gpio, pinstate);\n}\n\nstatic void lp8788_buck2_set_dvs(struct lp8788_buck *buck)\n{\n\tstruct lp8788_buck2_dvs *dvs = (struct lp8788_buck2_dvs *)buck->dvs;\n\tenum lp8788_dvs_state pin1, pin2;\n\n\tif (!dvs)\n\t\treturn;\n\n\tswitch (dvs->vsel) {\n\tcase DVS_SEL_V0:\n\t\tpin1 = DVS_LOW;\n\t\tpin2 = DVS_LOW;\n\t\tbreak;\n\tcase DVS_SEL_V1:\n\t\tpin1 = DVS_HIGH;\n\t\tpin2 = DVS_LOW;\n\t\tbreak;\n\tcase DVS_SEL_V2:\n\t\tpin1 = DVS_LOW;\n\t\tpin2 = DVS_HIGH;\n\t\tbreak;\n\tcase DVS_SEL_V3:\n\t\tpin1 = DVS_HIGH;\n\t\tpin2 = DVS_HIGH;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (gpio_is_valid(dvs->gpio[0]))\n\t\tgpio_set_value(dvs->gpio[0], pin1);\n\n\tif (gpio_is_valid(dvs->gpio[1]))\n\t\tgpio_set_value(dvs->gpio[1], pin2);\n}\n\nstatic void lp8788_set_dvs(struct lp8788_buck *buck, enum lp8788_buck_id id)\n{\n\tswitch (id) {\n\tcase BUCK1:\n\t\tlp8788_buck1_set_dvs(buck);\n\t\tbreak;\n\tcase BUCK2:\n\t\tlp8788_buck2_set_dvs(buck);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic enum lp8788_dvs_mode\nlp8788_get_buck_dvs_ctrl_mode(struct lp8788_buck *buck, enum lp8788_buck_id id)\n{\n\tu8 val, mask;\n\n\tswitch (id) {\n\tcase BUCK1:\n\t\tmask = LP8788_BUCK1_DVS_SEL_M;\n\t\tbreak;\n\tcase BUCK2:\n\t\tmask = LP8788_BUCK2_DVS_SEL_M;\n\t\tbreak;\n\tdefault:\n\t\treturn REGISTER;\n\t}\n\n\tlp8788_read_byte(buck->lp, LP8788_BUCK_DVS_SEL, &val);\n\n\treturn val & mask ? REGISTER : EXTPIN;\n}\n\nstatic bool lp8788_is_valid_buck_addr(u8 addr)\n{\n\tswitch (addr) {\n\tcase LP8788_BUCK1_VOUT0:\n\tcase LP8788_BUCK1_VOUT1:\n\tcase LP8788_BUCK1_VOUT2:\n\tcase LP8788_BUCK1_VOUT3:\n\tcase LP8788_BUCK2_VOUT0:\n\tcase LP8788_BUCK2_VOUT1:\n\tcase LP8788_BUCK2_VOUT2:\n\tcase LP8788_BUCK2_VOUT3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic u8 lp8788_select_buck_vout_addr(struct lp8788_buck *buck,\n\t\t\t\t\tenum lp8788_buck_id id)\n{\n\tenum lp8788_dvs_mode mode = lp8788_get_buck_dvs_ctrl_mode(buck, id);\n\tstruct lp8788_buck1_dvs *b1_dvs;\n\tstruct lp8788_buck2_dvs *b2_dvs;\n\tu8 val, idx, addr;\n\tint pin1, pin2;\n\n\tswitch (id) {\n\tcase BUCK1:\n\t\tif (mode == EXTPIN) {\n\t\t\tb1_dvs = (struct lp8788_buck1_dvs *)buck->dvs;\n\t\t\tif (!b1_dvs)\n\t\t\t\tgoto err;\n\n\t\t\tidx = gpio_get_value(b1_dvs->gpio) ? 1 : 0;\n\t\t} else {\n\t\t\tlp8788_read_byte(buck->lp, LP8788_BUCK_DVS_SEL, &val);\n\t\t\tidx = (val & LP8788_BUCK1_DVS_M) >> LP8788_BUCK1_DVS_S;\n\t\t}\n\t\taddr = LP8788_BUCK1_VOUT0 + idx;\n\t\tbreak;\n\tcase BUCK2:\n\t\tif (mode == EXTPIN) {\n\t\t\tb2_dvs = (struct lp8788_buck2_dvs *)buck->dvs;\n\t\t\tif (!b2_dvs)\n\t\t\t\tgoto err;\n\n\t\t\tpin1 = gpio_get_value(b2_dvs->gpio[0]);\n\t\t\tpin2 = gpio_get_value(b2_dvs->gpio[1]);\n\n\t\t\tif (pin1 == PIN_LOW && pin2 == PIN_LOW)\n\t\t\t\tidx = 0;\n\t\t\telse if (pin1 == PIN_LOW && pin2 == PIN_HIGH)\n\t\t\t\tidx = 2;\n\t\t\telse if (pin1 == PIN_HIGH && pin2 == PIN_LOW)\n\t\t\t\tidx = 1;\n\t\t\telse\n\t\t\t\tidx = 3;\n\t\t} else {\n\t\t\tlp8788_read_byte(buck->lp, LP8788_BUCK_DVS_SEL, &val);\n\t\t\tidx = (val & LP8788_BUCK2_DVS_M) >> LP8788_BUCK2_DVS_S;\n\t\t}\n\t\taddr = LP8788_BUCK2_VOUT0 + idx;\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\treturn addr;\nerr:\n\treturn INVALID_ADDR;\n}\n\nstatic int lp8788_buck12_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\tunsigned selector)\n{\n\tstruct lp8788_buck *buck = rdev_get_drvdata(rdev);\n\tenum lp8788_buck_id id = rdev_get_id(rdev);\n\tu8 addr;\n\n\tif (buck->dvs)\n\t\tlp8788_set_dvs(buck, id);\n\n\taddr = lp8788_select_buck_vout_addr(buck, id);\n\tif (!lp8788_is_valid_buck_addr(addr))\n\t\treturn -EINVAL;\n\n\treturn lp8788_update_bits(buck->lp, addr, LP8788_VOUT_M, selector);\n}\n\nstatic int lp8788_buck12_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct lp8788_buck *buck = rdev_get_drvdata(rdev);\n\tenum lp8788_buck_id id = rdev_get_id(rdev);\n\tint ret;\n\tu8 val, addr;\n\n\taddr = lp8788_select_buck_vout_addr(buck, id);\n\tif (!lp8788_is_valid_buck_addr(addr))\n\t\treturn -EINVAL;\n\n\tret = lp8788_read_byte(buck->lp, addr, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val & LP8788_VOUT_M;\n}\n\nstatic int lp8788_buck_enable_time(struct regulator_dev *rdev)\n{\n\tstruct lp8788_buck *buck = rdev_get_drvdata(rdev);\n\tenum lp8788_buck_id id = rdev_get_id(rdev);\n\tu8 val, addr = LP8788_BUCK1_TIMESTEP + id;\n\n\tif (lp8788_read_byte(buck->lp, addr, &val))\n\t\treturn -EINVAL;\n\n\tval = (val & LP8788_STARTUP_TIME_M) >> LP8788_STARTUP_TIME_S;\n\n\treturn ENABLE_TIME_USEC * val;\n}\n\nstatic int lp8788_buck_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct lp8788_buck *buck = rdev_get_drvdata(rdev);\n\tenum lp8788_buck_id id = rdev_get_id(rdev);\n\tu8 mask, val;\n\n\tmask = BUCK_FPWM_MASK(id);\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tval = LP8788_FORCE_PWM << BUCK_FPWM_SHIFT(id);\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = LP8788_AUTO_PWM << BUCK_FPWM_SHIFT(id);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn lp8788_update_bits(buck->lp, LP8788_BUCK_PWM, mask, val);\n}\n\nstatic unsigned int lp8788_buck_get_mode(struct regulator_dev *rdev)\n{\n\tstruct lp8788_buck *buck = rdev_get_drvdata(rdev);\n\tenum lp8788_buck_id id = rdev_get_id(rdev);\n\tu8 val;\n\tint ret;\n\n\tret = lp8788_read_byte(buck->lp, LP8788_BUCK_PWM, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val & BUCK_FPWM_MASK(id) ?\n\t\t\t\tREGULATOR_MODE_FAST : REGULATOR_MODE_NORMAL;\n}\n\nstatic const struct regulator_ops lp8788_buck12_ops = {\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.map_voltage = regulator_map_voltage_linear_range,\n\t.set_voltage_sel = lp8788_buck12_set_voltage_sel,\n\t.get_voltage_sel = lp8788_buck12_get_voltage_sel,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable_time = lp8788_buck_enable_time,\n\t.set_mode = lp8788_buck_set_mode,\n\t.get_mode = lp8788_buck_get_mode,\n};\n\nstatic const struct regulator_ops lp8788_buck34_ops = {\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.map_voltage = regulator_map_voltage_linear_range,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable_time = lp8788_buck_enable_time,\n\t.set_mode = lp8788_buck_set_mode,\n\t.get_mode = lp8788_buck_get_mode,\n};\n\nstatic const struct regulator_desc lp8788_buck_desc[] = {\n\t{\n\t\t.name = \"buck1\",\n\t\t.id = BUCK1,\n\t\t.ops = &lp8788_buck12_ops,\n\t\t.n_voltages = 26,\n\t\t.linear_ranges = buck_volt_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(buck_volt_ranges),\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.enable_reg = LP8788_EN_BUCK,\n\t\t.enable_mask = LP8788_EN_BUCK1_M,\n\t},\n\t{\n\t\t.name = \"buck2\",\n\t\t.id = BUCK2,\n\t\t.ops = &lp8788_buck12_ops,\n\t\t.n_voltages = 26,\n\t\t.linear_ranges = buck_volt_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(buck_volt_ranges),\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.enable_reg = LP8788_EN_BUCK,\n\t\t.enable_mask = LP8788_EN_BUCK2_M,\n\t},\n\t{\n\t\t.name = \"buck3\",\n\t\t.id = BUCK3,\n\t\t.ops = &lp8788_buck34_ops,\n\t\t.n_voltages = 26,\n\t\t.linear_ranges = buck_volt_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(buck_volt_ranges),\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP8788_BUCK3_VOUT,\n\t\t.vsel_mask = LP8788_VOUT_M,\n\t\t.enable_reg = LP8788_EN_BUCK,\n\t\t.enable_mask = LP8788_EN_BUCK3_M,\n\t},\n\t{\n\t\t.name = \"buck4\",\n\t\t.id = BUCK4,\n\t\t.ops = &lp8788_buck34_ops,\n\t\t.n_voltages = 26,\n\t\t.linear_ranges = buck_volt_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(buck_volt_ranges),\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t\t.vsel_reg = LP8788_BUCK4_VOUT,\n\t\t.vsel_mask = LP8788_VOUT_M,\n\t\t.enable_reg = LP8788_EN_BUCK,\n\t\t.enable_mask = LP8788_EN_BUCK4_M,\n\t},\n};\n\nstatic int lp8788_dvs_gpio_request(struct platform_device *pdev,\n\t\t\t\tstruct lp8788_buck *buck,\n\t\t\t\tenum lp8788_buck_id id)\n{\n\tstruct lp8788_platform_data *pdata = buck->lp->pdata;\n\tchar *b1_name = \"LP8788_B1_DVS\";\n\tchar *b2_name[] = { \"LP8788_B2_DVS1\", \"LP8788_B2_DVS2\" };\n\tint i, gpio, ret;\n\n\tswitch (id) {\n\tcase BUCK1:\n\t\tgpio = pdata->buck1_dvs->gpio;\n\t\tret = devm_gpio_request_one(&pdev->dev, gpio, DVS_LOW,\n\t\t\t\t\t    b1_name);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbuck->dvs = pdata->buck1_dvs;\n\t\tbreak;\n\tcase BUCK2:\n\t\tfor (i = 0; i < LP8788_NUM_BUCK2_DVS; i++) {\n\t\t\tgpio = pdata->buck2_dvs->gpio[i];\n\t\t\tret = devm_gpio_request_one(&pdev->dev, gpio,\n\t\t\t\t\t\t    DVS_LOW, b2_name[i]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbuck->dvs = pdata->buck2_dvs;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int lp8788_init_dvs(struct platform_device *pdev,\n\t\t\tstruct lp8788_buck *buck, enum lp8788_buck_id id)\n{\n\tstruct lp8788_platform_data *pdata = buck->lp->pdata;\n\tu8 mask[] = { LP8788_BUCK1_DVS_SEL_M, LP8788_BUCK2_DVS_SEL_M };\n\tu8 val[]  = { LP8788_BUCK1_DVS_PIN, LP8788_BUCK2_DVS_PIN };\n\tu8 default_dvs_mode[] = { LP8788_BUCK1_DVS_I2C, LP8788_BUCK2_DVS_I2C };\n\n\t \n\tif (id > BUCK2)\n\t\treturn 0;\n\n\t \n\tif (!pdata)\n\t\tgoto set_default_dvs_mode;\n\n\tif ((id == BUCK1 && !pdata->buck1_dvs) ||\n\t\t(id == BUCK2 && !pdata->buck2_dvs))\n\t\tgoto set_default_dvs_mode;\n\n\tif (lp8788_dvs_gpio_request(pdev, buck, id))\n\t\tgoto set_default_dvs_mode;\n\n\treturn lp8788_update_bits(buck->lp, LP8788_BUCK_DVS_SEL, mask[id],\n\t\t\t\tval[id]);\n\nset_default_dvs_mode:\n\treturn lp8788_update_bits(buck->lp, LP8788_BUCK_DVS_SEL, mask[id],\n\t\t\t\t  default_dvs_mode[id]);\n}\n\nstatic int lp8788_buck_probe(struct platform_device *pdev)\n{\n\tstruct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);\n\tint id = pdev->id;\n\tstruct lp8788_buck *buck;\n\tstruct regulator_config cfg = { };\n\tstruct regulator_dev *rdev;\n\tint ret;\n\n\tif (id >= LP8788_NUM_BUCKS)\n\t\treturn -EINVAL;\n\n\tbuck = devm_kzalloc(&pdev->dev, sizeof(struct lp8788_buck), GFP_KERNEL);\n\tif (!buck)\n\t\treturn -ENOMEM;\n\n\tbuck->lp = lp;\n\n\tret = lp8788_init_dvs(pdev, buck, id);\n\tif (ret)\n\t\treturn ret;\n\n\tcfg.dev = pdev->dev.parent;\n\tcfg.init_data = lp->pdata ? lp->pdata->buck_data[id] : NULL;\n\tcfg.driver_data = buck;\n\tcfg.regmap = lp->regmap;\n\n\trdev = devm_regulator_register(&pdev->dev, &lp8788_buck_desc[id], &cfg);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\t\tdev_err(&pdev->dev, \"BUCK%d regulator register err = %d\\n\",\n\t\t\t\tid + 1, ret);\n\t\treturn ret;\n\t}\n\n\tbuck->regulator = rdev;\n\tplatform_set_drvdata(pdev, buck);\n\n\treturn 0;\n}\n\nstatic struct platform_driver lp8788_buck_driver = {\n\t.probe = lp8788_buck_probe,\n\t.driver = {\n\t\t.name = LP8788_DEV_BUCK,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init lp8788_buck_init(void)\n{\n\treturn platform_driver_register(&lp8788_buck_driver);\n}\nsubsys_initcall(lp8788_buck_init);\n\nstatic void __exit lp8788_buck_exit(void)\n{\n\tplatform_driver_unregister(&lp8788_buck_driver);\n}\nmodule_exit(lp8788_buck_exit);\n\nMODULE_DESCRIPTION(\"TI LP8788 BUCK Driver\");\nMODULE_AUTHOR(\"Milo Kim\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:lp8788-buck\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}