{
  "module_name": "anatop-regulator.c",
  "hash_id": "94a21456bbebf002f64c4593a97d8a237b96fe78e6ec62d4bfeec880cafbf6d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/anatop-regulator.c",
  "human_readable_source": "\n\n\n\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/mfd/syscon.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regulator/machine.h>\n\n#define LDO_RAMP_UP_UNIT_IN_CYCLES      64  \n#define LDO_RAMP_UP_FREQ_IN_MHZ         24  \n\n#define LDO_POWER_GATE\t\t\t0x00\n#define LDO_FET_FULL_ON\t\t\t0x1f\n\nstruct anatop_regulator {\n\tu32 delay_reg;\n\tint delay_bit_shift;\n\tint delay_bit_width;\n\tstruct regulator_desc rdesc;\n\tbool bypass;\n\tint sel;\n};\n\nstatic int anatop_regmap_set_voltage_time_sel(struct regulator_dev *reg,\n\tunsigned int old_sel,\n\tunsigned int new_sel)\n{\n\tstruct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);\n\tu32 val;\n\tint ret = 0;\n\n\t \n\tif (anatop_reg->delay_bit_width && new_sel > old_sel) {\n\t\t \n\t\tregmap_read(reg->regmap, anatop_reg->delay_reg, &val);\n\t\tval = (val >> anatop_reg->delay_bit_shift) &\n\t\t\t((1 << anatop_reg->delay_bit_width) - 1);\n\t\tret = (new_sel - old_sel) * (LDO_RAMP_UP_UNIT_IN_CYCLES <<\n\t\t\tval) / LDO_RAMP_UP_FREQ_IN_MHZ + 1;\n\t}\n\n\treturn ret;\n}\n\nstatic int anatop_regmap_enable(struct regulator_dev *reg)\n{\n\tstruct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);\n\tint sel;\n\n\tsel = anatop_reg->bypass ? LDO_FET_FULL_ON : anatop_reg->sel;\n\treturn regulator_set_voltage_sel_regmap(reg, sel);\n}\n\nstatic int anatop_regmap_disable(struct regulator_dev *reg)\n{\n\treturn regulator_set_voltage_sel_regmap(reg, LDO_POWER_GATE);\n}\n\nstatic int anatop_regmap_is_enabled(struct regulator_dev *reg)\n{\n\treturn regulator_get_voltage_sel_regmap(reg) != LDO_POWER_GATE;\n}\n\nstatic int anatop_regmap_core_set_voltage_sel(struct regulator_dev *reg,\n\t\t\t\t\t      unsigned selector)\n{\n\tstruct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);\n\tint ret;\n\n\tif (anatop_reg->bypass || !anatop_regmap_is_enabled(reg)) {\n\t\tanatop_reg->sel = selector;\n\t\treturn 0;\n\t}\n\n\tret = regulator_set_voltage_sel_regmap(reg, selector);\n\tif (!ret)\n\t\tanatop_reg->sel = selector;\n\treturn ret;\n}\n\nstatic int anatop_regmap_core_get_voltage_sel(struct regulator_dev *reg)\n{\n\tstruct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);\n\n\tif (anatop_reg->bypass || !anatop_regmap_is_enabled(reg))\n\t\treturn anatop_reg->sel;\n\n\treturn regulator_get_voltage_sel_regmap(reg);\n}\n\nstatic int anatop_regmap_get_bypass(struct regulator_dev *reg, bool *enable)\n{\n\tstruct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);\n\tint sel;\n\n\tsel = regulator_get_voltage_sel_regmap(reg);\n\tif (sel == LDO_FET_FULL_ON)\n\t\tWARN_ON(!anatop_reg->bypass);\n\telse if (sel != LDO_POWER_GATE)\n\t\tWARN_ON(anatop_reg->bypass);\n\n\t*enable = anatop_reg->bypass;\n\treturn 0;\n}\n\nstatic int anatop_regmap_set_bypass(struct regulator_dev *reg, bool enable)\n{\n\tstruct anatop_regulator *anatop_reg = rdev_get_drvdata(reg);\n\tint sel;\n\n\tif (enable == anatop_reg->bypass)\n\t\treturn 0;\n\n\tsel = enable ? LDO_FET_FULL_ON : anatop_reg->sel;\n\tanatop_reg->bypass = enable;\n\n\treturn regulator_set_voltage_sel_regmap(reg, sel);\n}\n\nstatic struct regulator_ops anatop_rops = {\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n};\n\nstatic const struct regulator_ops anatop_core_rops = {\n\t.enable = anatop_regmap_enable,\n\t.disable = anatop_regmap_disable,\n\t.is_enabled = anatop_regmap_is_enabled,\n\t.set_voltage_sel = anatop_regmap_core_set_voltage_sel,\n\t.set_voltage_time_sel = anatop_regmap_set_voltage_time_sel,\n\t.get_voltage_sel = anatop_regmap_core_get_voltage_sel,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.get_bypass = anatop_regmap_get_bypass,\n\t.set_bypass = anatop_regmap_set_bypass,\n};\n\nstatic int anatop_regulator_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *anatop_np;\n\tstruct regulator_desc *rdesc;\n\tstruct regulator_dev *rdev;\n\tstruct anatop_regulator *sreg;\n\tstruct regulator_init_data *initdata;\n\tstruct regulator_config config = { };\n\tstruct regmap *regmap;\n\tu32 control_reg;\n\tu32 vol_bit_shift;\n\tu32 vol_bit_width;\n\tu32 min_bit_val;\n\tu32 min_voltage;\n\tu32 max_voltage;\n\tint ret = 0;\n\tu32 val;\n\n\tsreg = devm_kzalloc(dev, sizeof(*sreg), GFP_KERNEL);\n\tif (!sreg)\n\t\treturn -ENOMEM;\n\n\trdesc = &sreg->rdesc;\n\trdesc->type = REGULATOR_VOLTAGE;\n\trdesc->owner = THIS_MODULE;\n\n\tof_property_read_string(np, \"regulator-name\", &rdesc->name);\n\tif (!rdesc->name) {\n\t\tdev_err(dev, \"failed to get a regulator-name\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinitdata = of_get_regulator_init_data(dev, np, rdesc);\n\tif (!initdata)\n\t\treturn -ENOMEM;\n\n\tinitdata->supply_regulator = \"vin\";\n\n\tanatop_np = of_get_parent(np);\n\tif (!anatop_np)\n\t\treturn -ENODEV;\n\tregmap = syscon_node_to_regmap(anatop_np);\n\tof_node_put(anatop_np);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tret = of_property_read_u32(np, \"anatop-reg-offset\", &control_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"no anatop-reg-offset property set\\n\");\n\t\treturn ret;\n\t}\n\tret = of_property_read_u32(np, \"anatop-vol-bit-width\", &vol_bit_width);\n\tif (ret) {\n\t\tdev_err(dev, \"no anatop-vol-bit-width property set\\n\");\n\t\treturn ret;\n\t}\n\tret = of_property_read_u32(np, \"anatop-vol-bit-shift\", &vol_bit_shift);\n\tif (ret) {\n\t\tdev_err(dev, \"no anatop-vol-bit-shift property set\\n\");\n\t\treturn ret;\n\t}\n\tret = of_property_read_u32(np, \"anatop-min-bit-val\", &min_bit_val);\n\tif (ret) {\n\t\tdev_err(dev, \"no anatop-min-bit-val property set\\n\");\n\t\treturn ret;\n\t}\n\tret = of_property_read_u32(np, \"anatop-min-voltage\", &min_voltage);\n\tif (ret) {\n\t\tdev_err(dev, \"no anatop-min-voltage property set\\n\");\n\t\treturn ret;\n\t}\n\tret = of_property_read_u32(np, \"anatop-max-voltage\", &max_voltage);\n\tif (ret) {\n\t\tdev_err(dev, \"no anatop-max-voltage property set\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tof_property_read_u32(np, \"anatop-delay-reg-offset\",\n\t\t\t     &sreg->delay_reg);\n\tof_property_read_u32(np, \"anatop-delay-bit-width\",\n\t\t\t     &sreg->delay_bit_width);\n\tof_property_read_u32(np, \"anatop-delay-bit-shift\",\n\t\t\t     &sreg->delay_bit_shift);\n\n\trdesc->n_voltages = (max_voltage - min_voltage) / 25000 + 1\n\t\t\t    + min_bit_val;\n\trdesc->min_uV = min_voltage;\n\trdesc->uV_step = 25000;\n\trdesc->linear_min_sel = min_bit_val;\n\trdesc->vsel_reg = control_reg;\n\trdesc->vsel_mask = ((1 << vol_bit_width) - 1) << vol_bit_shift;\n\trdesc->min_dropout_uV = 125000;\n\n\tconfig.dev = &pdev->dev;\n\tconfig.init_data = initdata;\n\tconfig.driver_data = sreg;\n\tconfig.of_node = pdev->dev.of_node;\n\tconfig.regmap = regmap;\n\n\t \n\tif (control_reg && sreg->delay_bit_width) {\n\t\trdesc->ops = &anatop_core_rops;\n\n\t\tret = regmap_read(config.regmap, rdesc->vsel_reg, &val);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to read initial state\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsreg->sel = (val & rdesc->vsel_mask) >> vol_bit_shift;\n\t\tif (sreg->sel == LDO_FET_FULL_ON) {\n\t\t\tsreg->sel = 0;\n\t\t\tsreg->bypass = true;\n\t\t}\n\n\t\t \n\t\tif (!sreg->sel && !strcmp(rdesc->name, \"vddpu\"))\n\t\t\tsreg->sel = 22;\n\n\t\t \n\t\tif (!sreg->sel && !strcmp(rdesc->name, \"vddpcie\"))\n\t\t\tsreg->sel = 0x10;\n\n\t\tif (!sreg->bypass && !sreg->sel) {\n\t\t\tdev_err(&pdev->dev, \"Failed to read a valid default voltage selector.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tu32 enable_bit;\n\n\t\trdesc->ops = &anatop_rops;\n\n\t\tif (!of_property_read_u32(np, \"anatop-enable-bit\",\n\t\t\t\t\t  &enable_bit)) {\n\t\t\tanatop_rops.enable  = regulator_enable_regmap;\n\t\t\tanatop_rops.disable = regulator_disable_regmap;\n\t\t\tanatop_rops.is_enabled = regulator_is_enabled_regmap;\n\n\t\t\trdesc->enable_reg = control_reg;\n\t\t\trdesc->enable_mask = BIT(enable_bit);\n\t\t}\n\t}\n\n\t \n\trdev = devm_regulator_register(dev, rdesc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tdev_dbg(dev, \"failed to register %s, deferring...\\n\",\n\t\t\t\trdesc->name);\n\t\telse\n\t\t\tdev_err(dev, \"failed to register %s\\n\", rdesc->name);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, rdev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_anatop_regulator_match_tbl[] = {\n\t{ .compatible = \"fsl,anatop-regulator\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_anatop_regulator_match_tbl);\n\nstatic struct platform_driver anatop_regulator_driver = {\n\t.driver = {\n\t\t.name\t= \"anatop_regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_anatop_regulator_match_tbl,\n\t},\n\t.probe\t= anatop_regulator_probe,\n};\n\nstatic int __init anatop_regulator_init(void)\n{\n\treturn platform_driver_register(&anatop_regulator_driver);\n}\npostcore_initcall(anatop_regulator_init);\n\nstatic void __exit anatop_regulator_exit(void)\n{\n\tplatform_driver_unregister(&anatop_regulator_driver);\n}\nmodule_exit(anatop_regulator_exit);\n\nMODULE_AUTHOR(\"Nancy Chen <Nancy.Chen@freescale.com>\");\nMODULE_AUTHOR(\"Ying-Chun Liu (PaulLiu) <paul.liu@linaro.org>\");\nMODULE_DESCRIPTION(\"ANATOP Regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:anatop_regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}