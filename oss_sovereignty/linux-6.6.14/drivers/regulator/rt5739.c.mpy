{
  "module_name": "rt5739.c",
  "hash_id": "444f35bdb3bd947b3300fb15407e3030ad40246c89d67f095d9e24c8faf6f69c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rt5739.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n#define RT5739_AUTO_MODE\t0\n#define RT5739_FPWM_MODE\t1\n\n#define RT5739_REG_NSEL0\t0x00\n#define RT5739_REG_NSEL1\t0x01\n#define RT5739_REG_CNTL1\t0x02\n#define RT5739_REG_ID1\t\t0x03\n#define RT5739_REG_CNTL2\t0x06\n#define RT5739_REG_CNTL4\t0x08\n\n#define RT5739_VSEL_MASK\tGENMASK(7, 0)\n#define RT5739_MODEVSEL1_MASK\tBIT(1)\n#define RT5739_MODEVSEL0_MASK\tBIT(0)\n#define RT5739_VID_MASK\t\tGENMASK(7, 5)\n#define RT5739_DID_MASK\t\tGENMASK(3, 0)\n#define RT5739_ACTD_MASK\tBIT(7)\n#define RT5739_ENVSEL1_MASK\tBIT(1)\n#define RT5739_ENVSEL0_MASK\tBIT(0)\n\n#define RT5733_CHIPDIE_ID\t0x1\n#define RT5733_VOLT_MINUV\t270000\n#define RT5733_VOLT_MAXUV\t1401250\n#define RT5733_VOLT_STPUV\t6250\n#define RT5733_N_VOLTS\t\t182\n\n#define RT5739_VOLT_MINUV\t300000\n#define RT5739_VOLT_MAXUV\t1300000\n#define RT5739_VOLT_STPUV\t5000\n#define RT5739_N_VOLTS\t\t201\n#define RT5739_I2CRDY_TIMEUS\t1000\n\nstatic int rt5739_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tconst struct regulator_desc *desc = rdev->desc;\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int mask, val;\n\n\tif (desc->vsel_reg == RT5739_REG_NSEL0)\n\t\tmask = RT5739_MODEVSEL0_MASK;\n\telse\n\t\tmask = RT5739_MODEVSEL1_MASK;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tval = mask;\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(regmap, RT5739_REG_CNTL1, mask, val);\n}\n\nstatic unsigned int rt5739_get_mode(struct regulator_dev *rdev)\n{\n\tconst struct regulator_desc *desc = rdev->desc;\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int mask, val;\n\tint ret;\n\n\tif (desc->vsel_reg == RT5739_REG_NSEL0)\n\t\tmask = RT5739_MODEVSEL0_MASK;\n\telse\n\t\tmask = RT5739_MODEVSEL1_MASK;\n\n\tret = regmap_read(regmap, RT5739_REG_CNTL1, &val);\n\tif (ret)\n\t\treturn REGULATOR_MODE_INVALID;\n\n\tif (val & mask)\n\t\treturn REGULATOR_MODE_FAST;\n\n\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int rt5739_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tconst struct regulator_desc *desc = rdev->desc;\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int reg, vsel;\n\tint max_uV;\n\n\tmax_uV = desc->min_uV + desc->uV_step * (desc->n_voltages - 1);\n\n\tif (uV < desc->min_uV || uV > max_uV)\n\t\treturn -EINVAL;\n\n\tif (desc->vsel_reg == RT5739_REG_NSEL0)\n\t\treg = RT5739_REG_NSEL1;\n\telse\n\t\treg = RT5739_REG_NSEL0;\n\n\tvsel = (uV - desc->min_uV) / desc->uV_step;\n\treturn regmap_write(regmap, reg, vsel);\n}\n\nstatic int rt5739_set_suspend_enable(struct regulator_dev *rdev)\n{\n\tconst struct regulator_desc *desc = rdev->desc;\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int mask;\n\n\tif (desc->vsel_reg == RT5739_REG_NSEL0)\n\t\tmask = RT5739_ENVSEL1_MASK;\n\telse\n\t\tmask = RT5739_ENVSEL0_MASK;\n\n\treturn regmap_update_bits(regmap, desc->enable_reg, mask, mask);\n}\n\nstatic int rt5739_set_suspend_disable(struct regulator_dev *rdev)\n{\n\tconst struct regulator_desc *desc = rdev->desc;\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int mask;\n\n\tif (desc->vsel_reg == RT5739_REG_NSEL0)\n\t\tmask = RT5739_ENVSEL1_MASK;\n\telse\n\t\tmask = RT5739_ENVSEL0_MASK;\n\n\treturn regmap_update_bits(regmap, desc->enable_reg, mask, 0);\n}\n\nstatic int rt5739_set_suspend_mode(struct regulator_dev *rdev,\n\t\t\t\t   unsigned int mode)\n{\n\tconst struct regulator_desc *desc = rdev->desc;\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\tunsigned int mask, val;\n\n\tif (desc->vsel_reg == RT5739_REG_NSEL0)\n\t\tmask = RT5739_MODEVSEL1_MASK;\n\telse\n\t\tmask = RT5739_MODEVSEL0_MASK;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tval = mask;\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(regmap, RT5739_REG_CNTL1, mask, val);\n}\n\nstatic const struct regulator_ops rt5739_regulator_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.enable\t= regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n\t.set_mode = rt5739_set_mode,\n\t.get_mode = rt5739_get_mode,\n\t.set_suspend_voltage = rt5739_set_suspend_voltage,\n\t.set_suspend_enable = rt5739_set_suspend_enable,\n\t.set_suspend_disable = rt5739_set_suspend_disable,\n\t.set_suspend_mode = rt5739_set_suspend_mode,\n};\n\nstatic unsigned int rt5739_of_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase RT5739_AUTO_MODE:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase RT5739_FPWM_MODE:\n\t\treturn REGULATOR_MODE_FAST;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic void rt5739_init_regulator_desc(struct regulator_desc *desc,\n\t\t\t\t       bool vsel_active_high, u8 did)\n{\n\t \n\tdesc->name = \"rt5739-regulator\";\n\tdesc->owner = THIS_MODULE;\n\tdesc->ops = &rt5739_regulator_ops;\n\tdesc->vsel_mask = RT5739_VSEL_MASK;\n\tdesc->enable_reg = RT5739_REG_CNTL2;\n\tdesc->active_discharge_reg = RT5739_REG_CNTL1;\n\tdesc->active_discharge_mask = RT5739_ACTD_MASK;\n\tdesc->active_discharge_on = RT5739_ACTD_MASK;\n\tdesc->of_map_mode = rt5739_of_map_mode;\n\n\t \n\tif (vsel_active_high) {\n\t\tdesc->vsel_reg = RT5739_REG_NSEL1;\n\t\tdesc->enable_mask = RT5739_ENVSEL1_MASK;\n\t} else {\n\t\tdesc->vsel_reg = RT5739_REG_NSEL0;\n\t\tdesc->enable_mask = RT5739_ENVSEL0_MASK;\n\t}\n\n\t \n\tswitch (did) {\n\tcase RT5733_CHIPDIE_ID:\n\t\tdesc->n_voltages = RT5733_N_VOLTS;\n\t\tdesc->min_uV = RT5733_VOLT_MINUV;\n\t\tdesc->uV_step = RT5733_VOLT_STPUV;\n\t\tbreak;\n\tdefault:\n\t\tdesc->n_voltages = RT5739_N_VOLTS;\n\t\tdesc->min_uV = RT5739_VOLT_MINUV;\n\t\tdesc->uV_step = RT5739_VOLT_STPUV;\n\t\tbreak;\n\t}\n}\n\nstatic const struct regmap_config rt5739_regmap_config = {\n\t.name = \"rt5739\",\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RT5739_REG_CNTL4,\n};\n\nstatic int rt5739_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct regulator_desc *desc;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *enable_gpio;\n\tstruct regulator_config cfg = {};\n\tstruct regulator_dev *rdev;\n\tbool vsel_acth;\n\tunsigned int vid;\n\tint ret;\n\n\tdesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tenable_gpio = devm_gpiod_get_optional(dev, \"enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(enable_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(enable_gpio), \"Failed to get 'enable' gpio\\n\");\n\telse if (enable_gpio)\n\t\tusleep_range(RT5739_I2CRDY_TIMEUS, RT5739_I2CRDY_TIMEUS + 1000);\n\n\tregmap = devm_regmap_init_i2c(i2c, &rt5739_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap), \"Failed to init regmap\\n\");\n\n\tret = regmap_read(regmap, RT5739_REG_ID1, &vid);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to read VID\\n\");\n\n\t \n\tif (vid & RT5739_VID_MASK)\n\t\treturn dev_err_probe(dev, -ENODEV, \"Incorrect VID (0x%02x)\\n\", vid);\n\n\tvsel_acth = device_property_read_bool(dev, \"richtek,vsel-active-high\");\n\n\trt5739_init_regulator_desc(desc, vsel_acth, vid & RT5739_DID_MASK);\n\n\tcfg.dev = dev;\n\tcfg.of_node = dev_of_node(dev);\n\tcfg.init_data = of_get_regulator_init_data(dev, dev_of_node(dev), desc);\n\trdev = devm_regulator_register(dev, desc, &cfg);\n\tif (IS_ERR(rdev))\n\t\treturn dev_err_probe(dev, PTR_ERR(rdev), \"Failed to register regulator\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rt5739_device_table[] = {\n\t{ .compatible = \"richtek,rt5733\" },\n\t{ .compatible = \"richtek,rt5739\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rt5739_device_table);\n\nstatic struct i2c_driver rt5739_driver = {\n\t.driver = {\n\t\t.name = \"rt5739\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = rt5739_device_table,\n\t},\n\t.probe = rt5739_probe,\n};\nmodule_i2c_driver(rt5739_driver);\n\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_DESCRIPTION(\"Richtek RT5739 regulator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}