{
  "module_name": "wm831x-dcdc.c",
  "hash_id": "097c33fed8c63959aab6ddc4b5fcfc1e5396b8a8068811c01b866f215497f5ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/wm831x-dcdc.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n\n#include <linux/mfd/wm831x/core.h>\n#include <linux/mfd/wm831x/regulator.h>\n#include <linux/mfd/wm831x/pdata.h>\n\n#define WM831X_BUCKV_MAX_SELECTOR 0x68\n#define WM831X_BUCKP_MAX_SELECTOR 0x66\n\n#define WM831X_DCDC_MODE_FAST    0\n#define WM831X_DCDC_MODE_NORMAL  1\n#define WM831X_DCDC_MODE_IDLE    2\n#define WM831X_DCDC_MODE_STANDBY 3\n\n#define WM831X_DCDC_MAX_NAME 9\n\n \n#define WM831X_DCDC_CONTROL_1     0\n#define WM831X_DCDC_CONTROL_2     1\n#define WM831X_DCDC_ON_CONFIG     2\n#define WM831X_DCDC_SLEEP_CONTROL 3\n#define WM831X_DCDC_DVS_CONTROL   4\n\n \n\nstruct wm831x_dcdc {\n\tchar name[WM831X_DCDC_MAX_NAME];\n\tchar supply_name[WM831X_DCDC_MAX_NAME];\n\tstruct regulator_desc desc;\n\tint base;\n\tstruct wm831x *wm831x;\n\tstruct regulator_dev *regulator;\n\tstruct gpio_desc *dvs_gpiod;\n\tint dvs_gpio_state;\n\tint on_vsel;\n\tint dvs_vsel;\n};\n\nstatic unsigned int wm831x_dcdc_get_mode(struct regulator_dev *rdev)\n\n{\n\tstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = dcdc->wm831x;\n\tu16 reg = dcdc->base + WM831X_DCDC_ON_CONFIG;\n\tint val;\n\n\tval = wm831x_reg_read(wm831x, reg);\n\tif (val < 0)\n\t\treturn val;\n\n\tval = (val & WM831X_DC1_ON_MODE_MASK) >> WM831X_DC1_ON_MODE_SHIFT;\n\n\tswitch (val) {\n\tcase WM831X_DCDC_MODE_FAST:\n\t\treturn REGULATOR_MODE_FAST;\n\tcase WM831X_DCDC_MODE_NORMAL:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase WM831X_DCDC_MODE_STANDBY:\n\t\treturn REGULATOR_MODE_STANDBY;\n\tcase WM831X_DCDC_MODE_IDLE:\n\t\treturn REGULATOR_MODE_IDLE;\n\tdefault:\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int wm831x_dcdc_set_mode_int(struct wm831x *wm831x, int reg,\n\t\t\t\t    unsigned int mode)\n{\n\tint val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tval = WM831X_DCDC_MODE_FAST;\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = WM831X_DCDC_MODE_NORMAL;\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tval = WM831X_DCDC_MODE_STANDBY;\n\t\tbreak;\n\tcase REGULATOR_MODE_IDLE:\n\t\tval = WM831X_DCDC_MODE_IDLE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn wm831x_set_bits(wm831x, reg, WM831X_DC1_ON_MODE_MASK,\n\t\t\t       val << WM831X_DC1_ON_MODE_SHIFT);\n}\n\nstatic int wm831x_dcdc_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = dcdc->wm831x;\n\tu16 reg = dcdc->base + WM831X_DCDC_ON_CONFIG;\n\n\treturn wm831x_dcdc_set_mode_int(wm831x, reg, mode);\n}\n\nstatic int wm831x_dcdc_set_suspend_mode(struct regulator_dev *rdev,\n\t\t\t\t\tunsigned int mode)\n{\n\tstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = dcdc->wm831x;\n\tu16 reg = dcdc->base + WM831X_DCDC_SLEEP_CONTROL;\n\n\treturn wm831x_dcdc_set_mode_int(wm831x, reg, mode);\n}\n\nstatic int wm831x_dcdc_get_status(struct regulator_dev *rdev)\n{\n\tstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = dcdc->wm831x;\n\tint ret;\n\n\t \n\tret = wm831x_reg_read(wm831x, WM831X_DCDC_UV_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & (1 << rdev_get_id(rdev))) {\n\t\tdev_dbg(wm831x->dev, \"DCDC%d under voltage\\n\",\n\t\t\trdev_get_id(rdev) + 1);\n\t\treturn REGULATOR_STATUS_ERROR;\n\t}\n\n\t \n\tif (rdev_get_id(rdev) < 2) {\n\t\tif (ret & (WM831X_DC1_OV_STS << rdev_get_id(rdev))) {\n\t\t\tdev_dbg(wm831x->dev, \"DCDC%d over voltage\\n\",\n\t\t\t\trdev_get_id(rdev) + 1);\n\t\t\treturn REGULATOR_STATUS_ERROR;\n\t\t}\n\n\t\tif (ret & (WM831X_DC1_HC_STS << rdev_get_id(rdev))) {\n\t\t\tdev_dbg(wm831x->dev, \"DCDC%d over current\\n\",\n\t\t\t\trdev_get_id(rdev) + 1);\n\t\t\treturn REGULATOR_STATUS_ERROR;\n\t\t}\n\t}\n\n\t \n\tret = wm831x_reg_read(wm831x, WM831X_DCDC_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!(ret & (1 << rdev_get_id(rdev))))\n\t\treturn REGULATOR_STATUS_OFF;\n\n\t \n\treturn REGULATOR_STATUS_ON;\n}\n\nstatic irqreturn_t wm831x_dcdc_uv_irq(int irq, void *data)\n{\n\tstruct wm831x_dcdc *dcdc = data;\n\n\tregulator_notifier_call_chain(dcdc->regulator,\n\t\t\t\t      REGULATOR_EVENT_UNDER_VOLTAGE,\n\t\t\t\t      NULL);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wm831x_dcdc_oc_irq(int irq, void *data)\n{\n\tstruct wm831x_dcdc *dcdc = data;\n\n\tregulator_notifier_call_chain(dcdc->regulator,\n\t\t\t\t      REGULATOR_EVENT_OVER_CURRENT,\n\t\t\t\t      NULL);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic const struct linear_range wm831x_buckv_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(600000, 0, 0x7, 0),\n\tREGULATOR_LINEAR_RANGE(600000, 0x8, 0x68, 12500),\n};\n\nstatic int wm831x_buckv_set_dvs(struct regulator_dev *rdev, int state)\n{\n\tstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\n\n\tif (state == dcdc->dvs_gpio_state)\n\t\treturn 0;\n\n\tdcdc->dvs_gpio_state = state;\n\tgpiod_set_value(dcdc->dvs_gpiod, state);\n\n\t \n\n\treturn 0;\n}\n\nstatic int wm831x_buckv_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\tunsigned vsel)\n{\n\tstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = dcdc->wm831x;\n\tint on_reg = dcdc->base + WM831X_DCDC_ON_CONFIG;\n\tint dvs_reg = dcdc->base + WM831X_DCDC_DVS_CONTROL;\n\tint ret;\n\n\t \n\tif (dcdc->dvs_gpiod && dcdc->on_vsel == vsel)\n\t\treturn wm831x_buckv_set_dvs(rdev, 0);\n\n\tif (dcdc->dvs_gpiod && dcdc->dvs_vsel == vsel)\n\t\treturn wm831x_buckv_set_dvs(rdev, 1);\n\n\t \n\tret = wm831x_set_bits(wm831x, on_reg, WM831X_DC1_ON_VSEL_MASK, vsel);\n\tif (ret < 0)\n\t\treturn ret;\n\tdcdc->on_vsel = vsel;\n\n\tif (!dcdc->dvs_gpiod)\n\t\treturn ret;\n\n\t \n\tret = wm831x_buckv_set_dvs(rdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (vsel > dcdc->dvs_vsel) {\n\t\tret = wm831x_set_bits(wm831x, dvs_reg,\n\t\t\t\t      WM831X_DC1_DVS_VSEL_MASK,\n\t\t\t\t      vsel);\n\t\tif (ret == 0)\n\t\t\tdcdc->dvs_vsel = vsel;\n\t\telse\n\t\t\tdev_warn(wm831x->dev,\n\t\t\t\t \"Failed to set DCDC DVS VSEL: %d\\n\", ret);\n\t}\n\n\treturn 0;\n}\n\nstatic int wm831x_buckv_set_suspend_voltage(struct regulator_dev *rdev,\n\t\t\t\t\t    int uV)\n{\n\tstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = dcdc->wm831x;\n\tu16 reg = dcdc->base + WM831X_DCDC_SLEEP_CONTROL;\n\tint vsel;\n\n\tvsel = regulator_map_voltage_linear_range(rdev, uV, uV);\n\tif (vsel < 0)\n\t\treturn vsel;\n\n\treturn wm831x_set_bits(wm831x, reg, WM831X_DC1_SLP_VSEL_MASK, vsel);\n}\n\nstatic int wm831x_buckv_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\n\n\tif (dcdc->dvs_gpiod && dcdc->dvs_gpio_state)\n\t\treturn dcdc->dvs_vsel;\n\telse\n\t\treturn dcdc->on_vsel;\n}\n\n \nstatic const unsigned int wm831x_dcdc_ilim[] = {\n\t125000, 250000, 375000, 500000, 625000, 750000, 875000, 1000000\n};\n\nstatic const struct regulator_ops wm831x_buckv_ops = {\n\t.set_voltage_sel = wm831x_buckv_set_voltage_sel,\n\t.get_voltage_sel = wm831x_buckv_get_voltage_sel,\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.map_voltage = regulator_map_voltage_linear_range,\n\t.set_suspend_voltage = wm831x_buckv_set_suspend_voltage,\n\t.set_current_limit = regulator_set_current_limit_regmap,\n\t.get_current_limit = regulator_get_current_limit_regmap,\n\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.get_status = wm831x_dcdc_get_status,\n\t.get_mode = wm831x_dcdc_get_mode,\n\t.set_mode = wm831x_dcdc_set_mode,\n\t.set_suspend_mode = wm831x_dcdc_set_suspend_mode,\n};\n\n \nstatic void wm831x_buckv_dvs_init(struct platform_device *pdev,\n\t\t\t\t  struct wm831x_dcdc *dcdc,\n\t\t\t\t  struct wm831x_buckv_pdata *pdata)\n{\n\tstruct wm831x *wm831x = dcdc->wm831x;\n\tint ret;\n\tu16 ctrl;\n\n\tif (!pdata)\n\t\treturn;\n\n\t \n\tdcdc->dvs_gpio_state = pdata->dvs_init_state;\n\n\tdcdc->dvs_gpiod = devm_gpiod_get(&pdev->dev, \"dvs\",\n\t\t\tdcdc->dvs_gpio_state ? GPIOD_OUT_HIGH : GPIOD_OUT_LOW);\n\tif (IS_ERR(dcdc->dvs_gpiod)) {\n\t\tdev_err(wm831x->dev, \"Failed to get %s DVS GPIO: %ld\\n\",\n\t\t\tdcdc->name, PTR_ERR(dcdc->dvs_gpiod));\n\t\treturn;\n\t}\n\n\tswitch (pdata->dvs_control_src) {\n\tcase 1:\n\t\tctrl = 2 << WM831X_DC1_DVS_SRC_SHIFT;\n\t\tbreak;\n\tcase 2:\n\t\tctrl = 3 << WM831X_DC1_DVS_SRC_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(wm831x->dev, \"Invalid DVS control source %d for %s\\n\",\n\t\t\tpdata->dvs_control_src, dcdc->name);\n\t\treturn;\n\t}\n\n\t \n\tif (!dcdc->dvs_vsel) {\n\t\tret = wm831x_set_bits(wm831x,\n\t\t\t\t      dcdc->base + WM831X_DCDC_DVS_CONTROL,\n\t\t\t\t      WM831X_DC1_DVS_VSEL_MASK, dcdc->on_vsel);\n\t\tif (ret == 0)\n\t\t\tdcdc->dvs_vsel = dcdc->on_vsel;\n\t\telse\n\t\t\tdev_warn(wm831x->dev, \"Failed to set DVS_VSEL: %d\\n\",\n\t\t\t\t ret);\n\t}\n\n\tret = wm831x_set_bits(wm831x, dcdc->base + WM831X_DCDC_DVS_CONTROL,\n\t\t\t      WM831X_DC1_DVS_SRC_MASK, ctrl);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev, \"Failed to set %s DVS source: %d\\n\",\n\t\t\tdcdc->name, ret);\n\t}\n}\n\nstatic int wm831x_buckv_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\n\tstruct regulator_config config = { };\n\tint id;\n\tstruct wm831x_dcdc *dcdc;\n\tstruct resource *res;\n\tint ret, irq;\n\n\tif (pdata && pdata->wm831x_num)\n\t\tid = (pdata->wm831x_num * 10) + 1;\n\telse\n\t\tid = 0;\n\tid = pdev->id - id;\n\n\tdev_dbg(&pdev->dev, \"Probing DCDC%d\\n\", id + 1);\n\n\tdcdc = devm_kzalloc(&pdev->dev,  sizeof(struct wm831x_dcdc),\n\t\t\t    GFP_KERNEL);\n\tif (!dcdc)\n\t\treturn -ENOMEM;\n\n\tdcdc->wm831x = wm831x;\n\n\tres = platform_get_resource(pdev, IORESOURCE_REG, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"No REG resource\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tdcdc->base = res->start;\n\n\tsnprintf(dcdc->name, sizeof(dcdc->name), \"DCDC%d\", id + 1);\n\tdcdc->desc.name = dcdc->name;\n\n\tsnprintf(dcdc->supply_name, sizeof(dcdc->supply_name),\n\t\t \"DC%dVDD\", id + 1);\n\tdcdc->desc.supply_name = dcdc->supply_name;\n\n\tdcdc->desc.id = id;\n\tdcdc->desc.type = REGULATOR_VOLTAGE;\n\tdcdc->desc.n_voltages = WM831X_BUCKV_MAX_SELECTOR + 1;\n\tdcdc->desc.linear_ranges = wm831x_buckv_ranges;\n\tdcdc->desc.n_linear_ranges = ARRAY_SIZE(wm831x_buckv_ranges);\n\tdcdc->desc.ops = &wm831x_buckv_ops;\n\tdcdc->desc.owner = THIS_MODULE;\n\tdcdc->desc.enable_reg = WM831X_DCDC_ENABLE;\n\tdcdc->desc.enable_mask = 1 << id;\n\tdcdc->desc.csel_reg = dcdc->base + WM831X_DCDC_CONTROL_2;\n\tdcdc->desc.csel_mask = WM831X_DC1_HC_THR_MASK;\n\tdcdc->desc.n_current_limits = ARRAY_SIZE(wm831x_dcdc_ilim);\n\tdcdc->desc.curr_table = wm831x_dcdc_ilim;\n\n\tret = wm831x_reg_read(wm831x, dcdc->base + WM831X_DCDC_ON_CONFIG);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev, \"Failed to read ON VSEL: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\tdcdc->on_vsel = ret & WM831X_DC1_ON_VSEL_MASK;\n\n\tret = wm831x_reg_read(wm831x, dcdc->base + WM831X_DCDC_DVS_CONTROL);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev, \"Failed to read DVS VSEL: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\tdcdc->dvs_vsel = ret & WM831X_DC1_DVS_VSEL_MASK;\n\n\tif (pdata && pdata->dcdc[id])\n\t\twm831x_buckv_dvs_init(pdev, dcdc,\n\t\t\t\t      pdata->dcdc[id]->driver_data);\n\n\tconfig.dev = pdev->dev.parent;\n\tif (pdata)\n\t\tconfig.init_data = pdata->dcdc[id];\n\tconfig.driver_data = dcdc;\n\tconfig.regmap = wm831x->regmap;\n\n\tdcdc->regulator = devm_regulator_register(&pdev->dev, &dcdc->desc,\n\t\t\t\t\t\t  &config);\n\tif (IS_ERR(dcdc->regulator)) {\n\t\tret = PTR_ERR(dcdc->regulator);\n\t\tdev_err(wm831x->dev, \"Failed to register DCDC%d: %d\\n\",\n\t\t\tid + 1, ret);\n\t\tgoto err;\n\t}\n\n\tirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, \"UV\"));\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\twm831x_dcdc_uv_irq,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tdcdc->name, dcdc);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request UV IRQ %d: %d\\n\",\n\t\t\tirq, ret);\n\t\tgoto err;\n\t}\n\n\tirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, \"HC\"));\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\twm831x_dcdc_oc_irq,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tdcdc->name, dcdc);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request HC IRQ %d: %d\\n\",\n\t\t\tirq, ret);\n\t\tgoto err;\n\t}\n\n\tplatform_set_drvdata(pdev, dcdc);\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic struct platform_driver wm831x_buckv_driver = {\n\t.probe = wm831x_buckv_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"wm831x-buckv\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\n \n\nstatic int wm831x_buckp_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = dcdc->wm831x;\n\tu16 reg = dcdc->base + WM831X_DCDC_SLEEP_CONTROL;\n\tint sel;\n\n\tsel = regulator_map_voltage_linear(rdev, uV, uV);\n\tif (sel < 0)\n\t\treturn sel;\n\n\treturn wm831x_set_bits(wm831x, reg, WM831X_DC3_ON_VSEL_MASK, sel);\n}\n\nstatic const struct regulator_ops wm831x_buckp_ops = {\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.set_suspend_voltage = wm831x_buckp_set_suspend_voltage,\n\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.get_status = wm831x_dcdc_get_status,\n\t.get_mode = wm831x_dcdc_get_mode,\n\t.set_mode = wm831x_dcdc_set_mode,\n\t.set_suspend_mode = wm831x_dcdc_set_suspend_mode,\n};\n\nstatic int wm831x_buckp_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\n\tstruct regulator_config config = { };\n\tint id;\n\tstruct wm831x_dcdc *dcdc;\n\tstruct resource *res;\n\tint ret, irq;\n\n\tif (pdata && pdata->wm831x_num)\n\t\tid = (pdata->wm831x_num * 10) + 1;\n\telse\n\t\tid = 0;\n\tid = pdev->id - id;\n\n\tdev_dbg(&pdev->dev, \"Probing DCDC%d\\n\", id + 1);\n\n\tdcdc = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_dcdc),\n\t\t\t    GFP_KERNEL);\n\tif (!dcdc)\n\t\treturn -ENOMEM;\n\n\tdcdc->wm831x = wm831x;\n\n\tres = platform_get_resource(pdev, IORESOURCE_REG, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"No REG resource\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tdcdc->base = res->start;\n\n\tsnprintf(dcdc->name, sizeof(dcdc->name), \"DCDC%d\", id + 1);\n\tdcdc->desc.name = dcdc->name;\n\n\tsnprintf(dcdc->supply_name, sizeof(dcdc->supply_name),\n\t\t \"DC%dVDD\", id + 1);\n\tdcdc->desc.supply_name = dcdc->supply_name;\n\n\tdcdc->desc.id = id;\n\tdcdc->desc.type = REGULATOR_VOLTAGE;\n\tdcdc->desc.n_voltages = WM831X_BUCKP_MAX_SELECTOR + 1;\n\tdcdc->desc.ops = &wm831x_buckp_ops;\n\tdcdc->desc.owner = THIS_MODULE;\n\tdcdc->desc.vsel_reg = dcdc->base + WM831X_DCDC_ON_CONFIG;\n\tdcdc->desc.vsel_mask = WM831X_DC3_ON_VSEL_MASK;\n\tdcdc->desc.enable_reg = WM831X_DCDC_ENABLE;\n\tdcdc->desc.enable_mask = 1 << id;\n\tdcdc->desc.min_uV = 850000;\n\tdcdc->desc.uV_step = 25000;\n\n\tconfig.dev = pdev->dev.parent;\n\tif (pdata)\n\t\tconfig.init_data = pdata->dcdc[id];\n\tconfig.driver_data = dcdc;\n\tconfig.regmap = wm831x->regmap;\n\n\tdcdc->regulator = devm_regulator_register(&pdev->dev, &dcdc->desc,\n\t\t\t\t\t\t  &config);\n\tif (IS_ERR(dcdc->regulator)) {\n\t\tret = PTR_ERR(dcdc->regulator);\n\t\tdev_err(wm831x->dev, \"Failed to register DCDC%d: %d\\n\",\n\t\t\tid + 1, ret);\n\t\tgoto err;\n\t}\n\n\tirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, \"UV\"));\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\twm831x_dcdc_uv_irq,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tdcdc->name, dcdc);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request UV IRQ %d: %d\\n\",\n\t\t\tirq, ret);\n\t\tgoto err;\n\t}\n\n\tplatform_set_drvdata(pdev, dcdc);\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic struct platform_driver wm831x_buckp_driver = {\n\t.probe = wm831x_buckp_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"wm831x-buckp\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\n \n\nstatic int wm831x_boostp_get_status(struct regulator_dev *rdev)\n{\n\tstruct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = dcdc->wm831x;\n\tint ret;\n\n\t \n\tret = wm831x_reg_read(wm831x, WM831X_DCDC_UV_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & (1 << rdev_get_id(rdev))) {\n\t\tdev_dbg(wm831x->dev, \"DCDC%d under voltage\\n\",\n\t\t\trdev_get_id(rdev) + 1);\n\t\treturn REGULATOR_STATUS_ERROR;\n\t}\n\n\t \n\tret = wm831x_reg_read(wm831x, WM831X_DCDC_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret & (1 << rdev_get_id(rdev)))\n\t\treturn REGULATOR_STATUS_ON;\n\telse\n\t\treturn REGULATOR_STATUS_OFF;\n}\n\nstatic const struct regulator_ops wm831x_boostp_ops = {\n\t.get_status = wm831x_boostp_get_status,\n\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n};\n\nstatic int wm831x_boostp_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\n\tstruct regulator_config config = { };\n\tint id = pdev->id % ARRAY_SIZE(pdata->dcdc);\n\tstruct wm831x_dcdc *dcdc;\n\tstruct resource *res;\n\tint ret, irq;\n\n\tdev_dbg(&pdev->dev, \"Probing DCDC%d\\n\", id + 1);\n\n\tif (pdata == NULL || pdata->dcdc[id] == NULL)\n\t\treturn -ENODEV;\n\n\tdcdc = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_dcdc), GFP_KERNEL);\n\tif (!dcdc)\n\t\treturn -ENOMEM;\n\n\tdcdc->wm831x = wm831x;\n\n\tres = platform_get_resource(pdev, IORESOURCE_REG, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"No REG resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdcdc->base = res->start;\n\n\tsnprintf(dcdc->name, sizeof(dcdc->name), \"DCDC%d\", id + 1);\n\tdcdc->desc.name = dcdc->name;\n\tdcdc->desc.id = id;\n\tdcdc->desc.type = REGULATOR_VOLTAGE;\n\tdcdc->desc.ops = &wm831x_boostp_ops;\n\tdcdc->desc.owner = THIS_MODULE;\n\tdcdc->desc.enable_reg = WM831X_DCDC_ENABLE;\n\tdcdc->desc.enable_mask = 1 << id;\n\n\tconfig.dev = pdev->dev.parent;\n\tif (pdata)\n\t\tconfig.init_data = pdata->dcdc[id];\n\tconfig.driver_data = dcdc;\n\tconfig.regmap = wm831x->regmap;\n\n\tdcdc->regulator = devm_regulator_register(&pdev->dev, &dcdc->desc,\n\t\t\t\t\t\t  &config);\n\tif (IS_ERR(dcdc->regulator)) {\n\t\tret = PTR_ERR(dcdc->regulator);\n\t\tdev_err(wm831x->dev, \"Failed to register DCDC%d: %d\\n\",\n\t\t\tid + 1, ret);\n\t\treturn ret;\n\t}\n\n\tirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, \"UV\"));\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\twm831x_dcdc_uv_irq,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tdcdc->name,\n\t\t\t\t\tdcdc);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request UV IRQ %d: %d\\n\",\n\t\t\tirq, ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, dcdc);\n\n\treturn 0;\n}\n\nstatic struct platform_driver wm831x_boostp_driver = {\n\t.probe = wm831x_boostp_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"wm831x-boostp\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\n \n\n#define WM831X_EPE_BASE 6\n\nstatic const struct regulator_ops wm831x_epe_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.get_status = wm831x_dcdc_get_status,\n};\n\nstatic int wm831x_epe_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\n\tstruct regulator_config config = { };\n\tint id = pdev->id % ARRAY_SIZE(pdata->epe);\n\tstruct wm831x_dcdc *dcdc;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"Probing EPE%d\\n\", id + 1);\n\n\tdcdc = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_dcdc), GFP_KERNEL);\n\tif (!dcdc)\n\t\treturn -ENOMEM;\n\n\tdcdc->wm831x = wm831x;\n\n\t \n\tsnprintf(dcdc->name, sizeof(dcdc->name), \"EPE%d\", id + 1);\n\tdcdc->desc.name = dcdc->name;\n\tdcdc->desc.id = id + WM831X_EPE_BASE;  \n\tdcdc->desc.ops = &wm831x_epe_ops;\n\tdcdc->desc.type = REGULATOR_VOLTAGE;\n\tdcdc->desc.owner = THIS_MODULE;\n\tdcdc->desc.enable_reg = WM831X_DCDC_ENABLE;\n\tdcdc->desc.enable_mask = 1 << dcdc->desc.id;\n\n\tconfig.dev = pdev->dev.parent;\n\tif (pdata)\n\t\tconfig.init_data = pdata->epe[id];\n\tconfig.driver_data = dcdc;\n\tconfig.regmap = wm831x->regmap;\n\n\tdcdc->regulator = devm_regulator_register(&pdev->dev, &dcdc->desc,\n\t\t\t\t\t\t  &config);\n\tif (IS_ERR(dcdc->regulator)) {\n\t\tret = PTR_ERR(dcdc->regulator);\n\t\tdev_err(wm831x->dev, \"Failed to register EPE%d: %d\\n\",\n\t\t\tid + 1, ret);\n\t\tgoto err;\n\t}\n\n\tplatform_set_drvdata(pdev, dcdc);\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic struct platform_driver wm831x_epe_driver = {\n\t.probe = wm831x_epe_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"wm831x-epe\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic struct platform_driver * const drivers[] = {\n\t&wm831x_buckv_driver,\n\t&wm831x_buckp_driver,\n\t&wm831x_boostp_driver,\n\t&wm831x_epe_driver,\n};\n\nstatic int __init wm831x_dcdc_init(void)\n{\n\treturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n}\nsubsys_initcall(wm831x_dcdc_init);\n\nstatic void __exit wm831x_dcdc_exit(void)\n{\n\tplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\n}\nmodule_exit(wm831x_dcdc_exit);\n\n \nMODULE_AUTHOR(\"Mark Brown\");\nMODULE_DESCRIPTION(\"WM831x DC-DC convertor driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm831x-buckv\");\nMODULE_ALIAS(\"platform:wm831x-buckp\");\nMODULE_ALIAS(\"platform:wm831x-boostp\");\nMODULE_ALIAS(\"platform:wm831x-epe\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}