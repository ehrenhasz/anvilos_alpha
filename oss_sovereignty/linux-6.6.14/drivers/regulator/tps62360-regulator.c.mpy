{
  "module_name": "tps62360-regulator.c",
  "hash_id": "0db8b4a189d97d7a3b0a05f08db79ee9fc81adaec07765b523c6ed5c65bbd1f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/tps62360-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/tps62360.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n\n \n#define REG_VSET0\t\t0\n#define REG_VSET1\t\t1\n#define REG_VSET2\t\t2\n#define REG_VSET3\t\t3\n#define REG_CONTROL\t\t4\n#define REG_TEMP\t\t5\n#define REG_RAMPCTRL\t\t6\n#define REG_CHIPID\t\t8\n\n#define FORCE_PWM_ENABLE\tBIT(7)\n\nenum chips {TPS62360, TPS62361, TPS62362, TPS62363};\n\n#define TPS62360_BASE_VOLTAGE\t770000\n#define TPS62360_N_VOLTAGES\t64\n\n#define TPS62361_BASE_VOLTAGE\t500000\n#define TPS62361_N_VOLTAGES\t128\n\n \nstruct tps62360_chip {\n\tstruct device *dev;\n\tstruct regulator_desc desc;\n\tstruct regulator_dev *rdev;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *vsel0_gpio;\n\tstruct gpio_desc *vsel1_gpio;\n\tu8 voltage_reg_mask;\n\tbool en_internal_pulldn;\n\tbool en_discharge;\n\tbool valid_gpios;\n\tint lru_index[4];\n\tint curr_vset_vsel[4];\n\tint curr_vset_id;\n};\n\n \nstatic bool find_voltage_set_register(struct tps62360_chip *tps,\n\t\tint req_vsel, int *vset_reg_id)\n{\n\tint i;\n\tbool found = false;\n\tint new_vset_reg = tps->lru_index[3];\n\tint found_index = 3;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (tps->curr_vset_vsel[tps->lru_index[i]] == req_vsel) {\n\t\t\tnew_vset_reg = tps->lru_index[i];\n\t\t\tfound_index = i;\n\t\t\tfound = true;\n\t\t\tgoto update_lru_index;\n\t\t}\n\t}\n\nupdate_lru_index:\n\tfor (i = found_index; i > 0; i--)\n\t\ttps->lru_index[i] = tps->lru_index[i - 1];\n\n\ttps->lru_index[0] = new_vset_reg;\n\t*vset_reg_id = new_vset_reg;\n\treturn found;\n}\n\nstatic int tps62360_dcdc_get_voltage_sel(struct regulator_dev *dev)\n{\n\tstruct tps62360_chip *tps = rdev_get_drvdata(dev);\n\tint vsel;\n\tunsigned int data;\n\tint ret;\n\n\tret = regmap_read(tps->regmap, REG_VSET0 + tps->curr_vset_id, &data);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev, \"%s(): register %d read failed with err %d\\n\",\n\t\t\t__func__, REG_VSET0 + tps->curr_vset_id, ret);\n\t\treturn ret;\n\t}\n\tvsel = (int)data & tps->voltage_reg_mask;\n\treturn vsel;\n}\n\nstatic int tps62360_dcdc_set_voltage_sel(struct regulator_dev *dev,\n\t\t\t\t\t unsigned selector)\n{\n\tstruct tps62360_chip *tps = rdev_get_drvdata(dev);\n\tint ret;\n\tbool found = false;\n\tint new_vset_id = tps->curr_vset_id;\n\n\t \n\tif (tps->valid_gpios)\n\t\tfound = find_voltage_set_register(tps, selector, &new_vset_id);\n\n\tif (!found) {\n\t\tret = regmap_update_bits(tps->regmap, REG_VSET0 + new_vset_id,\n\t\t\t\ttps->voltage_reg_mask, selector);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tps->dev,\n\t\t\t\t\"%s(): register %d update failed with err %d\\n\",\n\t\t\t\t __func__, REG_VSET0 + new_vset_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t\ttps->curr_vset_id = new_vset_id;\n\t\ttps->curr_vset_vsel[new_vset_id] = selector;\n\t}\n\n\t \n\tif (tps->valid_gpios) {\n\t\tgpiod_set_value_cansleep(tps->vsel0_gpio, new_vset_id & 0x1);\n\t\tgpiod_set_value_cansleep(tps->vsel1_gpio,\n\t\t\t\t\t(new_vset_id >> 1) & 0x1);\n\t}\n\treturn 0;\n}\n\nstatic int tps62360_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct tps62360_chip *tps = rdev_get_drvdata(rdev);\n\tint i;\n\tint val;\n\tint ret;\n\n\t \n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tval = FORCE_PWM_ENABLE;\n\t\tbreak;\n\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tps->valid_gpios) {\n\t\tret = regmap_update_bits(tps->regmap,\n\t\t\tREG_VSET0 + tps->curr_vset_id, FORCE_PWM_ENABLE, val);\n\t\tif (ret < 0)\n\t\t\tdev_err(tps->dev,\n\t\t\t\t\"%s(): register %d update failed with err %d\\n\",\n\t\t\t\t__func__, REG_VSET0 + tps->curr_vset_id, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < 4; ++i) {\n\t\tret = regmap_update_bits(tps->regmap,\n\t\t\t\t\tREG_VSET0 + i, FORCE_PWM_ENABLE, val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tps->dev,\n\t\t\t\t\"%s(): register %d update failed with err %d\\n\",\n\t\t\t\t__func__, REG_VSET0 + i, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic unsigned int tps62360_get_mode(struct regulator_dev *rdev)\n{\n\tstruct tps62360_chip *tps = rdev_get_drvdata(rdev);\n\tunsigned int data;\n\tint ret;\n\n\tret = regmap_read(tps->regmap, REG_VSET0 + tps->curr_vset_id, &data);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev, \"%s(): register %d read failed with err %d\\n\",\n\t\t\t__func__, REG_VSET0 + tps->curr_vset_id, ret);\n\t\treturn ret;\n\t}\n\treturn (data & FORCE_PWM_ENABLE) ?\n\t\t\t\tREGULATOR_MODE_FAST : REGULATOR_MODE_NORMAL;\n}\n\nstatic const struct regulator_ops tps62360_dcdc_ops = {\n\t.get_voltage_sel\t= tps62360_dcdc_get_voltage_sel,\n\t.set_voltage_sel\t= tps62360_dcdc_set_voltage_sel,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n\t.set_voltage_time_sel\t= regulator_set_voltage_time_sel,\n\t.set_mode\t\t= tps62360_set_mode,\n\t.get_mode\t\t= tps62360_get_mode,\n};\n\nstatic int tps62360_init_dcdc(struct tps62360_chip *tps,\n\t\tstruct tps62360_regulator_platform_data *pdata)\n{\n\tint ret;\n\tunsigned int ramp_ctrl;\n\n\t \n\tif (tps->en_internal_pulldn)\n\t\tret = regmap_write(tps->regmap, REG_CONTROL, 0xE0);\n\telse\n\t\tret = regmap_write(tps->regmap, REG_CONTROL, 0x0);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev,\n\t\t\t\"%s(): register %d write failed with err %d\\n\",\n\t\t\t__func__, REG_CONTROL, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(tps->regmap, REG_RAMPCTRL, BIT(2), 0);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev,\n\t\t\t\"%s(): register %d update failed with err %d\\n\",\n\t\t\t__func__, REG_RAMPCTRL, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_read(tps->regmap, REG_RAMPCTRL, &ramp_ctrl);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev,\n\t\t\t\"%s(): register %d read failed with err %d\\n\",\n\t\t\t__func__, REG_RAMPCTRL, ret);\n\t\treturn ret;\n\t}\n\tramp_ctrl = (ramp_ctrl >> 5) & 0x7;\n\n\t \n\ttps->desc.ramp_delay = DIV_ROUND_UP(32000, BIT(ramp_ctrl));\n\treturn ret;\n}\n\nstatic const struct regmap_config tps62360_regmap_config = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\t.max_register\t\t= REG_CHIPID,\n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\nstatic struct tps62360_regulator_platform_data *\n\tof_get_tps62360_platform_data(struct device *dev,\n\t\t\t\t      const struct regulator_desc *desc)\n{\n\tstruct tps62360_regulator_platform_data *pdata;\n\tstruct device_node *np = dev->of_node;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tpdata->reg_init_data = of_get_regulator_init_data(dev, dev->of_node,\n\t\t\t\t\t\t\t  desc);\n\tif (!pdata->reg_init_data) {\n\t\tdev_err(dev, \"Not able to get OF regulator init data\\n\");\n\t\treturn NULL;\n\t}\n\n\tpdata->vsel0_def_state = of_property_read_bool(np, \"ti,vsel0-state-high\");\n\tpdata->vsel1_def_state = of_property_read_bool(np, \"ti,vsel1-state-high\");\n\tpdata->en_internal_pulldn = of_property_read_bool(np, \"ti,enable-pull-down\");\n\tpdata->en_discharge = of_property_read_bool(np, \"ti,enable-vout-discharge\");\n\n\treturn pdata;\n}\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id tps62360_of_match[] = {\n\t { .compatible = \"ti,tps62360\", .data = (void *)TPS62360},\n\t { .compatible = \"ti,tps62361\", .data = (void *)TPS62361},\n\t { .compatible = \"ti,tps62362\", .data = (void *)TPS62362},\n\t { .compatible = \"ti,tps62363\", .data = (void *)TPS62363},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tps62360_of_match);\n#endif\n\nstatic int tps62360_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct regulator_config config = { };\n\tstruct tps62360_regulator_platform_data *pdata;\n\tstruct regulator_dev *rdev;\n\tstruct tps62360_chip *tps;\n\tint ret;\n\tint i;\n\tint chip_id;\n\tint gpio_flags;\n\n\tpdata = dev_get_platdata(&client->dev);\n\n\ttps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\ttps->desc.name = client->name;\n\ttps->desc.id = 0;\n\ttps->desc.ops = &tps62360_dcdc_ops;\n\ttps->desc.type = REGULATOR_VOLTAGE;\n\ttps->desc.owner = THIS_MODULE;\n\ttps->desc.uV_step = 10000;\n\n\tif (client->dev.of_node) {\n\t\tconst struct of_device_id *match;\n\t\tmatch = of_match_device(of_match_ptr(tps62360_of_match),\n\t\t\t\t&client->dev);\n\t\tif (!match) {\n\t\t\tdev_err(&client->dev, \"Error: No device match found\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tchip_id = (int)(long)match->data;\n\t\tif (!pdata)\n\t\t\tpdata = of_get_tps62360_platform_data(&client->dev,\n\t\t\t\t\t\t\t      &tps->desc);\n\t} else if (id) {\n\t\tchip_id = id->driver_data;\n\t} else {\n\t\tdev_err(&client->dev, \"No device tree match or id table match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!pdata) {\n\t\tdev_err(&client->dev, \"%s(): Platform data not found\\n\",\n\t\t\t\t\t\t__func__);\n\t\treturn -EIO;\n\t}\n\n\ttps->en_discharge = pdata->en_discharge;\n\ttps->en_internal_pulldn = pdata->en_internal_pulldn;\n\ttps->dev = &client->dev;\n\n\tswitch (chip_id) {\n\tcase TPS62360:\n\tcase TPS62362:\n\t\ttps->desc.min_uV = TPS62360_BASE_VOLTAGE;\n\t\ttps->voltage_reg_mask = 0x3F;\n\t\ttps->desc.n_voltages = TPS62360_N_VOLTAGES;\n\t\tbreak;\n\tcase TPS62361:\n\tcase TPS62363:\n\t\ttps->desc.min_uV = TPS62361_BASE_VOLTAGE;\n\t\ttps->voltage_reg_mask = 0x7F;\n\t\ttps->desc.n_voltages = TPS62361_N_VOLTAGES;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\ttps->regmap = devm_regmap_init_i2c(client, &tps62360_regmap_config);\n\tif (IS_ERR(tps->regmap)) {\n\t\tret = PTR_ERR(tps->regmap);\n\t\tdev_err(&client->dev,\n\t\t\t\"%s(): regmap allocation failed with err %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\ti2c_set_clientdata(client, tps);\n\n\ttps->curr_vset_id = (pdata->vsel1_def_state & 1) * 2 +\n\t\t\t\t(pdata->vsel0_def_state & 1);\n\ttps->lru_index[0] = tps->curr_vset_id;\n\ttps->valid_gpios = false;\n\n\tgpio_flags = (pdata->vsel0_def_state) ?\n\t\t\tGPIOD_OUT_HIGH : GPIOD_OUT_LOW;\n\ttps->vsel0_gpio = devm_gpiod_get_optional(&client->dev, \"vsel0\", gpio_flags);\n\tif (IS_ERR(tps->vsel0_gpio)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s(): Could not obtain vsel0 GPIO: %ld\\n\",\n\t\t\t__func__, PTR_ERR(tps->vsel0_gpio));\n\t\treturn PTR_ERR(tps->vsel0_gpio);\n\t}\n\n\tgpio_flags = (pdata->vsel1_def_state) ?\n\t\t\tGPIOD_OUT_HIGH : GPIOD_OUT_LOW;\n\ttps->vsel1_gpio = devm_gpiod_get_optional(&client->dev, \"vsel1\", gpio_flags);\n\tif (IS_ERR(tps->vsel1_gpio)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"%s(): Could not obtain vsel1 GPIO: %ld\\n\",\n\t\t\t__func__, PTR_ERR(tps->vsel1_gpio));\n\t\treturn PTR_ERR(tps->vsel1_gpio);\n\t}\n\n\tif (tps->vsel0_gpio != NULL && tps->vsel1_gpio != NULL) {\n\t\ttps->valid_gpios = true;\n\n\t\t \n\t\tfor (i = 0; i < 4; ++i)\n\t\t\ttps->lru_index[i] = i;\n\t\ttps->lru_index[0] = tps->curr_vset_id;\n\t\ttps->lru_index[tps->curr_vset_id] = 0;\n\t}\n\n\tret = tps62360_init_dcdc(tps, pdata);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev, \"%s(): Init failed with err = %d\\n\",\n\t\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tconfig.dev = &client->dev;\n\tconfig.init_data = pdata->reg_init_data;\n\tconfig.driver_data = tps;\n\tconfig.of_node = client->dev.of_node;\n\n\t \n\trdev = devm_regulator_register(&client->dev, &tps->desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(tps->dev,\n\t\t\t\"%s(): regulator register failed with err %s\\n\",\n\t\t\t__func__, id->name);\n\t\treturn PTR_ERR(rdev);\n\t}\n\n\ttps->rdev = rdev;\n\treturn 0;\n}\n\nstatic void tps62360_shutdown(struct i2c_client *client)\n{\n\tstruct tps62360_chip *tps = i2c_get_clientdata(client);\n\tint st;\n\n\tif (!tps->en_discharge)\n\t\treturn;\n\n\t \n\tst = regmap_update_bits(tps->regmap, REG_RAMPCTRL, BIT(2), BIT(2));\n\tif (st < 0)\n\t\tdev_err(tps->dev,\n\t\t\t\"%s(): register %d update failed with err %d\\n\",\n\t\t\t__func__, REG_RAMPCTRL, st);\n}\n\nstatic const struct i2c_device_id tps62360_id[] = {\n\t{.name = \"tps62360\", .driver_data = TPS62360},\n\t{.name = \"tps62361\", .driver_data = TPS62361},\n\t{.name = \"tps62362\", .driver_data = TPS62362},\n\t{.name = \"tps62363\", .driver_data = TPS62363},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, tps62360_id);\n\nstatic struct i2c_driver tps62360_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tps62360\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(tps62360_of_match),\n\t},\n\t.probe = tps62360_probe,\n\t.shutdown = tps62360_shutdown,\n\t.id_table = tps62360_id,\n};\n\nstatic int __init tps62360_init(void)\n{\n\treturn i2c_add_driver(&tps62360_i2c_driver);\n}\nsubsys_initcall(tps62360_init);\n\nstatic void __exit tps62360_cleanup(void)\n{\n\ti2c_del_driver(&tps62360_i2c_driver);\n}\nmodule_exit(tps62360_cleanup);\n\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_DESCRIPTION(\"TPS6236x voltage regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}