{
  "module_name": "wm8400-regulator.c",
  "hash_id": "1a9746630aed9f2a1a67b6631e006abaebd906f0cae665f40d04a9172801e92e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/wm8400-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/bug.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regulator/driver.h>\n#include <linux/mfd/wm8400-private.h>\n\nstatic const struct linear_range wm8400_ldo_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(900000, 0, 14, 50000),\n\tREGULATOR_LINEAR_RANGE(1700000, 15, 31, 100000),\n};\n\nstatic const struct regulator_ops wm8400_ldo_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.map_voltage = regulator_map_voltage_linear_range,\n};\n\nstatic unsigned int wm8400_dcdc_get_mode(struct regulator_dev *dev)\n{\n\tstruct regmap *rmap = rdev_get_regmap(dev);\n\tint offset = (rdev_get_id(dev) - WM8400_DCDC1) * 2;\n\tu16 data[2];\n\tint ret;\n\n\tret = regmap_bulk_read(rmap, WM8400_DCDC1_CONTROL_1 + offset, data, 2);\n\tif (ret != 0)\n\t\treturn 0;\n\n\t \n\tif (data[0] & WM8400_DC1_SLEEP)\n\t\treturn REGULATOR_MODE_STANDBY;\n\n\t \n\tif (!(data[0] & WM8400_DC1_ACTIVE))\n\t\treturn REGULATOR_MODE_IDLE;\n\n\t \n\tif (data[1] & WM8400_DC1_FRC_PWM)\n\t\treturn REGULATOR_MODE_FAST;\n\telse\n\t\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int wm8400_dcdc_set_mode(struct regulator_dev *dev, unsigned int mode)\n{\n\tstruct regmap *rmap = rdev_get_regmap(dev);\n\tint offset = (rdev_get_id(dev) - WM8400_DCDC1) * 2;\n\tint ret;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\t \n\t\tret = regmap_update_bits(rmap, WM8400_DCDC1_CONTROL_2 + offset,\n\t\t\t\t      WM8400_DC1_FRC_PWM, WM8400_DC1_FRC_PWM);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\treturn regmap_update_bits(rmap, WM8400_DCDC1_CONTROL_1 + offset,\n\t\t\t\t       WM8400_DC1_ACTIVE | WM8400_DC1_SLEEP,\n\t\t\t\t       WM8400_DC1_ACTIVE);\n\n\tcase REGULATOR_MODE_NORMAL:\n\t\t \n\t\tret = regmap_update_bits(rmap, WM8400_DCDC1_CONTROL_2 + offset,\n\t\t\t\t      WM8400_DC1_FRC_PWM, 0);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\treturn regmap_update_bits(rmap, WM8400_DCDC1_CONTROL_1 + offset,\n\t\t\t\t       WM8400_DC1_ACTIVE | WM8400_DC1_SLEEP,\n\t\t\t\t       WM8400_DC1_ACTIVE);\n\n\tcase REGULATOR_MODE_IDLE:\n\t\t \n\t\treturn regmap_update_bits(rmap, WM8400_DCDC1_CONTROL_1 + offset,\n\t\t\t\t       WM8400_DC1_ACTIVE | WM8400_DC1_SLEEP, 0);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic unsigned int wm8400_dcdc_get_optimum_mode(struct regulator_dev *dev,\n\t\t\t\t\t\t int input_uV, int output_uV,\n\t\t\t\t\t\t int load_uA)\n{\n\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic const struct regulator_ops wm8400_dcdc_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_mode = wm8400_dcdc_get_mode,\n\t.set_mode = wm8400_dcdc_set_mode,\n\t.get_optimum_mode = wm8400_dcdc_get_optimum_mode,\n};\n\nstatic struct regulator_desc regulators[] = {\n\t{\n\t\t.name = \"LDO1\",\n\t\t.id = WM8400_LDO1,\n\t\t.ops = &wm8400_ldo_ops,\n\t\t.enable_reg = WM8400_LDO1_CONTROL,\n\t\t.enable_mask = WM8400_LDO1_ENA,\n\t\t.n_voltages = WM8400_LDO1_VSEL_MASK + 1,\n\t\t.linear_ranges = wm8400_ldo_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(wm8400_ldo_ranges),\n\t\t.vsel_reg = WM8400_LDO1_CONTROL,\n\t\t.vsel_mask = WM8400_LDO1_VSEL_MASK,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"LDO2\",\n\t\t.id = WM8400_LDO2,\n\t\t.ops = &wm8400_ldo_ops,\n\t\t.enable_reg = WM8400_LDO2_CONTROL,\n\t\t.enable_mask = WM8400_LDO2_ENA,\n\t\t.n_voltages = WM8400_LDO2_VSEL_MASK + 1,\n\t\t.linear_ranges = wm8400_ldo_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(wm8400_ldo_ranges),\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.vsel_reg = WM8400_LDO2_CONTROL,\n\t\t.vsel_mask = WM8400_LDO2_VSEL_MASK,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"LDO3\",\n\t\t.id = WM8400_LDO3,\n\t\t.ops = &wm8400_ldo_ops,\n\t\t.enable_reg = WM8400_LDO3_CONTROL,\n\t\t.enable_mask = WM8400_LDO3_ENA,\n\t\t.n_voltages = WM8400_LDO3_VSEL_MASK + 1,\n\t\t.linear_ranges = wm8400_ldo_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(wm8400_ldo_ranges),\n\t\t.vsel_reg = WM8400_LDO3_CONTROL,\n\t\t.vsel_mask = WM8400_LDO3_VSEL_MASK,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"LDO4\",\n\t\t.id = WM8400_LDO4,\n\t\t.ops = &wm8400_ldo_ops,\n\t\t.enable_reg = WM8400_LDO4_CONTROL,\n\t\t.enable_mask = WM8400_LDO4_ENA,\n\t\t.n_voltages = WM8400_LDO4_VSEL_MASK + 1,\n\t\t.linear_ranges = wm8400_ldo_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(wm8400_ldo_ranges),\n\t\t.vsel_reg = WM8400_LDO4_CONTROL,\n\t\t.vsel_mask = WM8400_LDO4_VSEL_MASK,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"DCDC1\",\n\t\t.id = WM8400_DCDC1,\n\t\t.ops = &wm8400_dcdc_ops,\n\t\t.enable_reg = WM8400_DCDC1_CONTROL_1,\n\t\t.enable_mask = WM8400_DC1_ENA_MASK,\n\t\t.n_voltages = WM8400_DC1_VSEL_MASK + 1,\n\t\t.vsel_reg = WM8400_DCDC1_CONTROL_1,\n\t\t.vsel_mask = WM8400_DC1_VSEL_MASK,\n\t\t.min_uV = 850000,\n\t\t.uV_step = 25000,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"DCDC2\",\n\t\t.id = WM8400_DCDC2,\n\t\t.ops = &wm8400_dcdc_ops,\n\t\t.enable_reg = WM8400_DCDC2_CONTROL_1,\n\t\t.enable_mask = WM8400_DC2_ENA_MASK,\n\t\t.n_voltages = WM8400_DC2_VSEL_MASK + 1,\n\t\t.vsel_reg = WM8400_DCDC2_CONTROL_1,\n\t\t.vsel_mask = WM8400_DC2_VSEL_MASK,\n\t\t.min_uV = 850000,\n\t\t.uV_step = 25000,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\nstatic int wm8400_regulator_probe(struct platform_device *pdev)\n{\n\tstruct wm8400 *wm8400 = container_of(pdev, struct wm8400, regulators[pdev->id]);\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\n\tconfig.dev = &pdev->dev;\n\tconfig.init_data = dev_get_platdata(&pdev->dev);\n\tconfig.driver_data = wm8400;\n\tconfig.regmap = wm8400->regmap;\n\n\trdev = devm_regulator_register(&pdev->dev, &regulators[pdev->id],\n\t\t\t\t       &config);\n\tif (IS_ERR(rdev))\n\t\treturn PTR_ERR(rdev);\n\n\tplatform_set_drvdata(pdev, rdev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver wm8400_regulator_driver = {\n\t.driver = {\n\t\t.name = \"wm8400-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = wm8400_regulator_probe,\n};\n\n \nint wm8400_register_regulator(struct device *dev, int reg,\n\t\t\t      struct regulator_init_data *initdata)\n{\n\tstruct wm8400 *wm8400 = dev_get_drvdata(dev);\n\n\tif (wm8400->regulators[reg].name)\n\t\treturn -EBUSY;\n\n\tinitdata->driver_data = wm8400;\n\n\twm8400->regulators[reg].name = \"wm8400-regulator\";\n\twm8400->regulators[reg].id = reg;\n\twm8400->regulators[reg].dev.parent = dev;\n\twm8400->regulators[reg].dev.platform_data = initdata;\n\n\treturn platform_device_register(&wm8400->regulators[reg]);\n}\nEXPORT_SYMBOL_GPL(wm8400_register_regulator);\n\nstatic int __init wm8400_regulator_init(void)\n{\n\treturn platform_driver_register(&wm8400_regulator_driver);\n}\nsubsys_initcall(wm8400_regulator_init);\n\nstatic void __exit wm8400_regulator_exit(void)\n{\n\tplatform_driver_unregister(&wm8400_regulator_driver);\n}\nmodule_exit(wm8400_regulator_exit);\n\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"WM8400 regulator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm8400-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}