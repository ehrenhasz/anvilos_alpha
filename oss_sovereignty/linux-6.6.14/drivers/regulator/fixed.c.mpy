{
  "module_name": "fixed.c",
  "hash_id": "5fa5b53ecd4015f18d75083d9f535ce32964b3ecd5ee0e0cc11c926a0fd5a496",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/fixed.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_opp.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/fixed.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regulator/machine.h>\n#include <linux/clk.h>\n\n\nstruct fixed_voltage_data {\n\tstruct regulator_desc desc;\n\tstruct regulator_dev *dev;\n\n\tstruct clk *enable_clock;\n\tunsigned int enable_counter;\n\tint performance_state;\n};\n\nstruct fixed_dev_type {\n\tbool has_enable_clock;\n\tbool has_performance_state;\n};\n\nstatic int reg_clock_enable(struct regulator_dev *rdev)\n{\n\tstruct fixed_voltage_data *priv = rdev_get_drvdata(rdev);\n\tint ret = 0;\n\n\tret = clk_prepare_enable(priv->enable_clock);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->enable_counter++;\n\n\treturn ret;\n}\n\nstatic int reg_clock_disable(struct regulator_dev *rdev)\n{\n\tstruct fixed_voltage_data *priv = rdev_get_drvdata(rdev);\n\n\tclk_disable_unprepare(priv->enable_clock);\n\tpriv->enable_counter--;\n\n\treturn 0;\n}\n\nstatic int reg_domain_enable(struct regulator_dev *rdev)\n{\n\tstruct fixed_voltage_data *priv = rdev_get_drvdata(rdev);\n\tstruct device *dev = rdev->dev.parent;\n\tint ret;\n\n\tret = dev_pm_genpd_set_performance_state(dev, priv->performance_state);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->enable_counter++;\n\n\treturn ret;\n}\n\nstatic int reg_domain_disable(struct regulator_dev *rdev)\n{\n\tstruct fixed_voltage_data *priv = rdev_get_drvdata(rdev);\n\tstruct device *dev = rdev->dev.parent;\n\tint ret;\n\n\tret = dev_pm_genpd_set_performance_state(dev, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->enable_counter--;\n\n\treturn 0;\n}\n\nstatic int reg_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct fixed_voltage_data *priv = rdev_get_drvdata(rdev);\n\n\treturn priv->enable_counter > 0;\n}\n\n\n \nstatic struct fixed_voltage_config *\nof_get_fixed_voltage_config(struct device *dev,\n\t\t\t    const struct regulator_desc *desc)\n{\n\tstruct fixed_voltage_config *config;\n\tstruct device_node *np = dev->of_node;\n\tstruct regulator_init_data *init_data;\n\n\tconfig = devm_kzalloc(dev, sizeof(struct fixed_voltage_config),\n\t\t\t\t\t\t\t\t GFP_KERNEL);\n\tif (!config)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconfig->init_data = of_get_regulator_init_data(dev, dev->of_node, desc);\n\tif (!config->init_data)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tinit_data = config->init_data;\n\tinit_data->constraints.apply_uV = 0;\n\n\tconfig->supply_name = init_data->constraints.name;\n\tif (init_data->constraints.min_uV == init_data->constraints.max_uV) {\n\t\tconfig->microvolts = init_data->constraints.min_uV;\n\t} else {\n\t\tdev_err(dev,\n\t\t\t \"Fixed regulator specified with variable voltages\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (init_data->constraints.boot_on)\n\t\tconfig->enabled_at_boot = true;\n\n\tof_property_read_u32(np, \"startup-delay-us\", &config->startup_delay);\n\tof_property_read_u32(np, \"off-on-delay-us\", &config->off_on_delay);\n\n\tif (of_property_present(np, \"vin-supply\"))\n\t\tconfig->input_supply = \"vin\";\n\n\treturn config;\n}\n\nstatic const struct regulator_ops fixed_voltage_ops = {\n};\n\nstatic const struct regulator_ops fixed_voltage_clkenabled_ops = {\n\t.enable = reg_clock_enable,\n\t.disable = reg_clock_disable,\n\t.is_enabled = reg_is_enabled,\n};\n\nstatic const struct regulator_ops fixed_voltage_domain_ops = {\n\t.enable = reg_domain_enable,\n\t.disable = reg_domain_disable,\n\t.is_enabled = reg_is_enabled,\n};\n\nstatic int reg_fixed_voltage_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fixed_voltage_config *config;\n\tstruct fixed_voltage_data *drvdata;\n\tconst struct fixed_dev_type *drvtype = of_device_get_match_data(dev);\n\tstruct regulator_config cfg = { };\n\tenum gpiod_flags gflags;\n\tint ret;\n\n\tdrvdata = devm_kzalloc(&pdev->dev, sizeof(struct fixed_voltage_data),\n\t\t\t       GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tif (pdev->dev.of_node) {\n\t\tconfig = of_get_fixed_voltage_config(&pdev->dev,\n\t\t\t\t\t\t     &drvdata->desc);\n\t\tif (IS_ERR(config))\n\t\t\treturn PTR_ERR(config);\n\t} else {\n\t\tconfig = dev_get_platdata(&pdev->dev);\n\t}\n\n\tif (!config)\n\t\treturn -ENOMEM;\n\n\tdrvdata->desc.name = devm_kstrdup(&pdev->dev,\n\t\t\t\t\t  config->supply_name,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (drvdata->desc.name == NULL) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate supply name\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdrvdata->desc.type = REGULATOR_VOLTAGE;\n\tdrvdata->desc.owner = THIS_MODULE;\n\n\tif (drvtype && drvtype->has_enable_clock) {\n\t\tdrvdata->desc.ops = &fixed_voltage_clkenabled_ops;\n\n\t\tdrvdata->enable_clock = devm_clk_get(dev, NULL);\n\t\tif (IS_ERR(drvdata->enable_clock)) {\n\t\t\tdev_err(dev, \"Can't get enable-clock from devicetree\\n\");\n\t\t\treturn PTR_ERR(drvdata->enable_clock);\n\t\t}\n\t} else if (drvtype && drvtype->has_performance_state) {\n\t\tdrvdata->desc.ops = &fixed_voltage_domain_ops;\n\n\t\tdrvdata->performance_state = of_get_required_opp_performance_state(dev->of_node, 0);\n\t\tif (drvdata->performance_state < 0) {\n\t\t\tdev_err(dev, \"Can't get performance state from devicetree\\n\");\n\t\t\treturn drvdata->performance_state;\n\t\t}\n\t} else {\n\t\tdrvdata->desc.ops = &fixed_voltage_ops;\n\t}\n\n\tdrvdata->desc.enable_time = config->startup_delay;\n\tdrvdata->desc.off_on_delay = config->off_on_delay;\n\n\tif (config->input_supply) {\n\t\tdrvdata->desc.supply_name = devm_kstrdup(&pdev->dev,\n\t\t\t\t\t    config->input_supply,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!drvdata->desc.supply_name)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (config->microvolts)\n\t\tdrvdata->desc.n_voltages = 1;\n\n\tdrvdata->desc.fixed_uV = config->microvolts;\n\n\t \n\tif (config->enabled_at_boot)\n\t\tgflags = GPIOD_OUT_HIGH;\n\telse\n\t\tgflags = GPIOD_OUT_LOW;\n\n\t \n\tgflags |= GPIOD_FLAGS_BIT_NONEXCLUSIVE;\n\n\t \n\tcfg.ena_gpiod = gpiod_get_optional(&pdev->dev, NULL, gflags);\n\tif (IS_ERR(cfg.ena_gpiod))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(cfg.ena_gpiod),\n\t\t\t\t     \"can't get GPIO\\n\");\n\n\tcfg.dev = &pdev->dev;\n\tcfg.init_data = config->init_data;\n\tcfg.driver_data = drvdata;\n\tcfg.of_node = pdev->dev.of_node;\n\n\tdrvdata->dev = devm_regulator_register(&pdev->dev, &drvdata->desc,\n\t\t\t\t\t       &cfg);\n\tif (IS_ERR(drvdata->dev)) {\n\t\tret = dev_err_probe(&pdev->dev, PTR_ERR(drvdata->dev),\n\t\t\t\t    \"Failed to register regulator: %ld\\n\",\n\t\t\t\t    PTR_ERR(drvdata->dev));\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, drvdata);\n\n\tdev_dbg(&pdev->dev, \"%s supplying %duV\\n\", drvdata->desc.name,\n\t\tdrvdata->desc.fixed_uV);\n\n\treturn 0;\n}\n\n#if defined(CONFIG_OF)\nstatic const struct fixed_dev_type fixed_voltage_data = {\n\t.has_enable_clock = false,\n};\n\nstatic const struct fixed_dev_type fixed_clkenable_data = {\n\t.has_enable_clock = true,\n};\n\nstatic const struct fixed_dev_type fixed_domain_data = {\n\t.has_performance_state = true,\n};\n\nstatic const struct of_device_id fixed_of_match[] = {\n\t{\n\t\t.compatible = \"regulator-fixed\",\n\t\t.data = &fixed_voltage_data,\n\t},\n\t{\n\t\t.compatible = \"regulator-fixed-clock\",\n\t\t.data = &fixed_clkenable_data,\n\t},\n\t{\n\t\t.compatible = \"regulator-fixed-domain\",\n\t\t.data = &fixed_domain_data,\n\t},\n\t{\n\t},\n};\nMODULE_DEVICE_TABLE(of, fixed_of_match);\n#endif\n\nstatic struct platform_driver regulator_fixed_voltage_driver = {\n\t.probe\t\t= reg_fixed_voltage_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"reg-fixed-voltage\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(fixed_of_match),\n\t},\n};\n\nstatic int __init regulator_fixed_voltage_init(void)\n{\n\treturn platform_driver_register(&regulator_fixed_voltage_driver);\n}\nsubsys_initcall(regulator_fixed_voltage_init);\n\nstatic void __exit regulator_fixed_voltage_exit(void)\n{\n\tplatform_driver_unregister(&regulator_fixed_voltage_driver);\n}\nmodule_exit(regulator_fixed_voltage_exit);\n\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"Fixed voltage regulator\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:reg-fixed-voltage\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}