{
  "module_name": "s5m8767.c",
  "hash_id": "22037c3523e15455f6c807cc1f145b700fda549e7b5b25469ad4c53e236a700d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/s5m8767.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/err.h>\n#include <linux/of_gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/mfd/samsung/core.h>\n#include <linux/mfd/samsung/s5m8767.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regmap.h>\n\n#define S5M8767_OPMODE_NORMAL_MODE 0x1\n\nstruct s5m8767_info {\n\tstruct device *dev;\n\tstruct sec_pmic_dev *iodev;\n\tint num_regulators;\n\tstruct sec_opmode_data *opmode;\n\n\tint ramp_delay;\n\tbool buck2_ramp;\n\tbool buck3_ramp;\n\tbool buck4_ramp;\n\n\tbool buck2_gpiodvs;\n\tbool buck3_gpiodvs;\n\tbool buck4_gpiodvs;\n\tu8 buck2_vol[8];\n\tu8 buck3_vol[8];\n\tu8 buck4_vol[8];\n\tint buck_gpios[3];\n\tint buck_ds[3];\n\tint buck_gpioindex;\n};\n\nstruct sec_voltage_desc {\n\tint max;\n\tint min;\n\tint step;\n};\n\nstatic const struct sec_voltage_desc buck_voltage_val1 = {\n\t.max = 2225000,\n\t.min =  650000,\n\t.step =   6250,\n};\n\nstatic const struct sec_voltage_desc buck_voltage_val2 = {\n\t.max = 1600000,\n\t.min =  600000,\n\t.step =   6250,\n};\n\nstatic const struct sec_voltage_desc buck_voltage_val3 = {\n\t.max = 3000000,\n\t.min =  750000,\n\t.step =  12500,\n};\n\nstatic const struct sec_voltage_desc ldo_voltage_val1 = {\n\t.max = 3950000,\n\t.min =  800000,\n\t.step =  50000,\n};\n\nstatic const struct sec_voltage_desc ldo_voltage_val2 = {\n\t.max = 2375000,\n\t.min =  800000,\n\t.step =  25000,\n};\n\nstatic const struct sec_voltage_desc *reg_voltage_map[] = {\n\t[S5M8767_LDO1] = &ldo_voltage_val2,\n\t[S5M8767_LDO2] = &ldo_voltage_val2,\n\t[S5M8767_LDO3] = &ldo_voltage_val1,\n\t[S5M8767_LDO4] = &ldo_voltage_val1,\n\t[S5M8767_LDO5] = &ldo_voltage_val1,\n\t[S5M8767_LDO6] = &ldo_voltage_val2,\n\t[S5M8767_LDO7] = &ldo_voltage_val2,\n\t[S5M8767_LDO8] = &ldo_voltage_val2,\n\t[S5M8767_LDO9] = &ldo_voltage_val1,\n\t[S5M8767_LDO10] = &ldo_voltage_val1,\n\t[S5M8767_LDO11] = &ldo_voltage_val1,\n\t[S5M8767_LDO12] = &ldo_voltage_val1,\n\t[S5M8767_LDO13] = &ldo_voltage_val1,\n\t[S5M8767_LDO14] = &ldo_voltage_val1,\n\t[S5M8767_LDO15] = &ldo_voltage_val2,\n\t[S5M8767_LDO16] = &ldo_voltage_val1,\n\t[S5M8767_LDO17] = &ldo_voltage_val1,\n\t[S5M8767_LDO18] = &ldo_voltage_val1,\n\t[S5M8767_LDO19] = &ldo_voltage_val1,\n\t[S5M8767_LDO20] = &ldo_voltage_val1,\n\t[S5M8767_LDO21] = &ldo_voltage_val1,\n\t[S5M8767_LDO22] = &ldo_voltage_val1,\n\t[S5M8767_LDO23] = &ldo_voltage_val1,\n\t[S5M8767_LDO24] = &ldo_voltage_val1,\n\t[S5M8767_LDO25] = &ldo_voltage_val1,\n\t[S5M8767_LDO26] = &ldo_voltage_val1,\n\t[S5M8767_LDO27] = &ldo_voltage_val1,\n\t[S5M8767_LDO28] = &ldo_voltage_val1,\n\t[S5M8767_BUCK1] = &buck_voltage_val1,\n\t[S5M8767_BUCK2] = &buck_voltage_val2,\n\t[S5M8767_BUCK3] = &buck_voltage_val2,\n\t[S5M8767_BUCK4] = &buck_voltage_val2,\n\t[S5M8767_BUCK5] = &buck_voltage_val1,\n\t[S5M8767_BUCK6] = &buck_voltage_val1,\n\t[S5M8767_BUCK7] = &buck_voltage_val3,\n\t[S5M8767_BUCK8] = &buck_voltage_val3,\n\t[S5M8767_BUCK9] = &buck_voltage_val3,\n};\n\nstatic const unsigned int s5m8767_opmode_reg[][4] = {\n\t \n\t \n\t{0x0, 0x3, 0x2, 0x1},  \n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x0, 0x0, 0x0},\n\t{0x0, 0x3, 0x2, 0x1},  \n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},  \n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},  \n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x0, 0x0, 0x0},\n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},  \n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x0, 0x0, 0x0},\n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},  \n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},  \n\n\t \n\t{0x0, 0x3, 0x1, 0x1},  \n\t{0x0, 0x3, 0x1, 0x1},\n\t{0x0, 0x3, 0x1, 0x1},\n\t{0x0, 0x3, 0x1, 0x1},\n\t{0x0, 0x3, 0x2, 0x1},  \n\t{0x0, 0x3, 0x1, 0x1},\n\t{0x0, 0x3, 0x1, 0x1},\n\t{0x0, 0x3, 0x1, 0x1},\n\t{0x0, 0x3, 0x1, 0x1},  \n};\n\nstatic int s5m8767_get_register(struct s5m8767_info *s5m8767, int reg_id,\n\t\t\t\tint *reg, int *enable_ctrl)\n{\n\tint i;\n\tunsigned int mode;\n\n\tswitch (reg_id) {\n\tcase S5M8767_LDO1 ... S5M8767_LDO2:\n\t\t*reg = S5M8767_REG_LDO1CTRL + (reg_id - S5M8767_LDO1);\n\t\tbreak;\n\tcase S5M8767_LDO3 ... S5M8767_LDO28:\n\t\t*reg = S5M8767_REG_LDO3CTRL + (reg_id - S5M8767_LDO3);\n\t\tbreak;\n\tcase S5M8767_BUCK1:\n\t\t*reg = S5M8767_REG_BUCK1CTRL1;\n\t\tbreak;\n\tcase S5M8767_BUCK2 ... S5M8767_BUCK4:\n\t\t*reg = S5M8767_REG_BUCK2CTRL + (reg_id - S5M8767_BUCK2) * 9;\n\t\tbreak;\n\tcase S5M8767_BUCK5:\n\t\t*reg = S5M8767_REG_BUCK5CTRL1;\n\t\tbreak;\n\tcase S5M8767_BUCK6 ... S5M8767_BUCK9:\n\t\t*reg = S5M8767_REG_BUCK6CTRL1 + (reg_id - S5M8767_BUCK6) * 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < s5m8767->num_regulators; i++) {\n\t\tif (s5m8767->opmode[i].id == reg_id) {\n\t\t\tmode = s5m8767->opmode[i].mode;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= s5m8767->num_regulators)\n\t\treturn -EINVAL;\n\n\t*enable_ctrl = s5m8767_opmode_reg[reg_id][mode] << S5M8767_ENCTRL_SHIFT;\n\n\treturn 0;\n}\n\nstatic int s5m8767_get_vsel_reg(int reg_id, struct s5m8767_info *s5m8767)\n{\n\tint reg;\n\n\tswitch (reg_id) {\n\tcase S5M8767_LDO1 ... S5M8767_LDO2:\n\t\treg = S5M8767_REG_LDO1CTRL + (reg_id - S5M8767_LDO1);\n\t\tbreak;\n\tcase S5M8767_LDO3 ... S5M8767_LDO28:\n\t\treg = S5M8767_REG_LDO3CTRL + (reg_id - S5M8767_LDO3);\n\t\tbreak;\n\tcase S5M8767_BUCK1:\n\t\treg = S5M8767_REG_BUCK1CTRL2;\n\t\tbreak;\n\tcase S5M8767_BUCK2:\n\t\treg = S5M8767_REG_BUCK2DVS1;\n\t\tif (s5m8767->buck2_gpiodvs)\n\t\t\treg += s5m8767->buck_gpioindex;\n\t\tbreak;\n\tcase S5M8767_BUCK3:\n\t\treg = S5M8767_REG_BUCK3DVS1;\n\t\tif (s5m8767->buck3_gpiodvs)\n\t\t\treg += s5m8767->buck_gpioindex;\n\t\tbreak;\n\tcase S5M8767_BUCK4:\n\t\treg = S5M8767_REG_BUCK4DVS1;\n\t\tif (s5m8767->buck4_gpiodvs)\n\t\t\treg += s5m8767->buck_gpioindex;\n\t\tbreak;\n\tcase S5M8767_BUCK5:\n\t\treg = S5M8767_REG_BUCK5CTRL2;\n\t\tbreak;\n\tcase S5M8767_BUCK6 ... S5M8767_BUCK9:\n\t\treg = S5M8767_REG_BUCK6CTRL2 + (reg_id - S5M8767_BUCK6) * 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn reg;\n}\n\nstatic int s5m8767_convert_voltage_to_sel(const struct sec_voltage_desc *desc,\n\t\t\t\t\t  int min_vol)\n{\n\tint selector = 0;\n\n\tif (desc == NULL)\n\t\treturn -EINVAL;\n\n\tif (min_vol > desc->max)\n\t\treturn -EINVAL;\n\n\tif (min_vol < desc->min)\n\t\tmin_vol = desc->min;\n\n\tselector = DIV_ROUND_UP(min_vol - desc->min, desc->step);\n\n\tif (desc->min + desc->step * selector > desc->max)\n\t\treturn -EINVAL;\n\n\treturn selector;\n}\n\nstatic inline int s5m8767_set_high(struct s5m8767_info *s5m8767)\n{\n\tint temp_index = s5m8767->buck_gpioindex;\n\n\tgpio_set_value(s5m8767->buck_gpios[0], (temp_index >> 2) & 0x1);\n\tgpio_set_value(s5m8767->buck_gpios[1], (temp_index >> 1) & 0x1);\n\tgpio_set_value(s5m8767->buck_gpios[2], temp_index & 0x1);\n\n\treturn 0;\n}\n\nstatic inline int s5m8767_set_low(struct s5m8767_info *s5m8767)\n{\n\tint temp_index = s5m8767->buck_gpioindex;\n\n\tgpio_set_value(s5m8767->buck_gpios[2], temp_index & 0x1);\n\tgpio_set_value(s5m8767->buck_gpios[1], (temp_index >> 1) & 0x1);\n\tgpio_set_value(s5m8767->buck_gpios[0], (temp_index >> 2) & 0x1);\n\n\treturn 0;\n}\n\nstatic int s5m8767_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t   unsigned selector)\n{\n\tstruct s5m8767_info *s5m8767 = rdev_get_drvdata(rdev);\n\tint reg_id = rdev_get_id(rdev);\n\tint old_index, index = 0;\n\tu8 *buck234_vol = NULL;\n\n\tswitch (reg_id) {\n\tcase S5M8767_LDO1 ... S5M8767_LDO28:\n\t\tbreak;\n\tcase S5M8767_BUCK1 ... S5M8767_BUCK6:\n\t\tif (reg_id == S5M8767_BUCK2 && s5m8767->buck2_gpiodvs)\n\t\t\tbuck234_vol = &s5m8767->buck2_vol[0];\n\t\telse if (reg_id == S5M8767_BUCK3 && s5m8767->buck3_gpiodvs)\n\t\t\tbuck234_vol = &s5m8767->buck3_vol[0];\n\t\telse if (reg_id == S5M8767_BUCK4 && s5m8767->buck4_gpiodvs)\n\t\t\tbuck234_vol = &s5m8767->buck4_vol[0];\n\t\tbreak;\n\tcase S5M8767_BUCK7 ... S5M8767_BUCK8:\n\t\treturn -EINVAL;\n\tcase S5M8767_BUCK9:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (buck234_vol) {\n\t\twhile (*buck234_vol != selector) {\n\t\t\tbuck234_vol++;\n\t\t\tindex++;\n\t\t}\n\t\told_index = s5m8767->buck_gpioindex;\n\t\ts5m8767->buck_gpioindex = index;\n\n\t\tif (index > old_index)\n\t\t\treturn s5m8767_set_high(s5m8767);\n\t\telse\n\t\t\treturn s5m8767_set_low(s5m8767);\n\t} else {\n\t\treturn regulator_set_voltage_sel_regmap(rdev, selector);\n\t}\n}\n\nstatic int s5m8767_set_voltage_time_sel(struct regulator_dev *rdev,\n\t\t\t\t\t     unsigned int old_sel,\n\t\t\t\t\t     unsigned int new_sel)\n{\n\tstruct s5m8767_info *s5m8767 = rdev_get_drvdata(rdev);\n\n\tif ((old_sel < new_sel) && s5m8767->ramp_delay)\n\t\treturn DIV_ROUND_UP(rdev->desc->uV_step * (new_sel - old_sel),\n\t\t\t\t\ts5m8767->ramp_delay * 1000);\n\treturn 0;\n}\n\nstatic const struct regulator_ops s5m8767_ops = {\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= s5m8767_set_voltage_sel,\n\t.set_voltage_time_sel\t= s5m8767_set_voltage_time_sel,\n};\n\nstatic const struct regulator_ops s5m8767_buck78_ops = {\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n};\n\n#define s5m8767_regulator_desc(_name) {\t\t\\\n\t.name\t\t= #_name,\t\t\\\n\t.id\t\t= S5M8767_##_name,\t\\\n\t.ops\t\t= &s5m8767_ops,\t\t\\\n\t.type\t\t= REGULATOR_VOLTAGE,\t\\\n\t.owner\t\t= THIS_MODULE,\t\t\\\n}\n\n#define s5m8767_regulator_buck78_desc(_name) {\t\\\n\t.name\t\t= #_name,\t\t\\\n\t.id\t\t= S5M8767_##_name,\t\\\n\t.ops\t\t= &s5m8767_buck78_ops,\t\\\n\t.type\t\t= REGULATOR_VOLTAGE,\t\\\n\t.owner\t\t= THIS_MODULE,\t\t\\\n}\n\nstatic struct regulator_desc regulators[] = {\n\ts5m8767_regulator_desc(LDO1),\n\ts5m8767_regulator_desc(LDO2),\n\ts5m8767_regulator_desc(LDO3),\n\ts5m8767_regulator_desc(LDO4),\n\ts5m8767_regulator_desc(LDO5),\n\ts5m8767_regulator_desc(LDO6),\n\ts5m8767_regulator_desc(LDO7),\n\ts5m8767_regulator_desc(LDO8),\n\ts5m8767_regulator_desc(LDO9),\n\ts5m8767_regulator_desc(LDO10),\n\ts5m8767_regulator_desc(LDO11),\n\ts5m8767_regulator_desc(LDO12),\n\ts5m8767_regulator_desc(LDO13),\n\ts5m8767_regulator_desc(LDO14),\n\ts5m8767_regulator_desc(LDO15),\n\ts5m8767_regulator_desc(LDO16),\n\ts5m8767_regulator_desc(LDO17),\n\ts5m8767_regulator_desc(LDO18),\n\ts5m8767_regulator_desc(LDO19),\n\ts5m8767_regulator_desc(LDO20),\n\ts5m8767_regulator_desc(LDO21),\n\ts5m8767_regulator_desc(LDO22),\n\ts5m8767_regulator_desc(LDO23),\n\ts5m8767_regulator_desc(LDO24),\n\ts5m8767_regulator_desc(LDO25),\n\ts5m8767_regulator_desc(LDO26),\n\ts5m8767_regulator_desc(LDO27),\n\ts5m8767_regulator_desc(LDO28),\n\ts5m8767_regulator_desc(BUCK1),\n\ts5m8767_regulator_desc(BUCK2),\n\ts5m8767_regulator_desc(BUCK3),\n\ts5m8767_regulator_desc(BUCK4),\n\ts5m8767_regulator_desc(BUCK5),\n\ts5m8767_regulator_desc(BUCK6),\n\ts5m8767_regulator_buck78_desc(BUCK7),\n\ts5m8767_regulator_buck78_desc(BUCK8),\n\ts5m8767_regulator_desc(BUCK9),\n};\n\n \nstatic void s5m8767_regulator_config_ext_control(struct s5m8767_info *s5m8767,\n\t\tstruct sec_regulator_data *rdata,\n\t\tstruct regulator_config *config)\n{\n\tint i, mode = 0;\n\n\tif (rdata->id != S5M8767_BUCK9)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < s5m8767->num_regulators; i++) {\n\t\tconst struct sec_opmode_data *opmode = &s5m8767->opmode[i];\n\t\tif (opmode->id == rdata->id) {\n\t\t\tmode = s5m8767_opmode_reg[rdata->id][opmode->mode];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode != S5M8767_ENCTRL_USE_GPIO) {\n\t\tdev_warn(s5m8767->dev,\n\t\t\t\t\"ext-control for %pOFn: mismatched op_mode (%x), ignoring\\n\",\n\t\t\t\trdata->reg_node, mode);\n\t\treturn;\n\t}\n\n\tif (!rdata->ext_control_gpiod) {\n\t\tdev_warn(s5m8767->dev,\n\t\t\t\t\"ext-control for %pOFn: GPIO not valid, ignoring\\n\",\n\t\t\t rdata->reg_node);\n\t\treturn;\n\t}\n\n\tconfig->ena_gpiod = rdata->ext_control_gpiod;\n}\n\n \nstatic int s5m8767_enable_ext_control(struct s5m8767_info *s5m8767,\n\t\tstruct regulator_dev *rdev)\n{\n\tint id = rdev_get_id(rdev);\n\tint ret, reg, enable_ctrl;\n\n\tif (id != S5M8767_BUCK9)\n\t\treturn -EINVAL;\n\n\tret = s5m8767_get_register(s5m8767, id, &reg, &enable_ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(s5m8767->iodev->regmap_pmic,\n\t\t\treg, S5M8767_ENCTRL_MASK,\n\t\t\tS5M8767_ENCTRL_USE_GPIO << S5M8767_ENCTRL_SHIFT);\n}\n\n\n#ifdef CONFIG_OF\nstatic int s5m8767_pmic_dt_parse_dvs_gpio(struct sec_pmic_dev *iodev,\n\t\t\tstruct sec_platform_data *pdata,\n\t\t\tstruct device_node *pmic_np)\n{\n\tint i, gpio;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tgpio = of_get_named_gpio(pmic_np,\n\t\t\t\t\t\"s5m8767,pmic-buck-dvs-gpios\", i);\n\t\tif (!gpio_is_valid(gpio)) {\n\t\t\tdev_err(iodev->dev, \"invalid gpio[%d]: %d\\n\", i, gpio);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpdata->buck_gpios[i] = gpio;\n\t}\n\treturn 0;\n}\n\nstatic int s5m8767_pmic_dt_parse_ds_gpio(struct sec_pmic_dev *iodev,\n\t\t\tstruct sec_platform_data *pdata,\n\t\t\tstruct device_node *pmic_np)\n{\n\tint i, gpio;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tgpio = of_get_named_gpio(pmic_np,\n\t\t\t\t\t\"s5m8767,pmic-buck-ds-gpios\", i);\n\t\tif (!gpio_is_valid(gpio)) {\n\t\t\tdev_err(iodev->dev, \"invalid gpio[%d]: %d\\n\", i, gpio);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpdata->buck_ds[i] = gpio;\n\t}\n\treturn 0;\n}\n\nstatic int s5m8767_pmic_dt_parse_pdata(struct platform_device *pdev,\n\t\t\t\t\tstruct sec_platform_data *pdata)\n{\n\tstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\n\tstruct device_node *pmic_np, *regulators_np, *reg_np;\n\tstruct sec_regulator_data *rdata;\n\tstruct sec_opmode_data *rmode;\n\tunsigned int i, dvs_voltage_nr = 8, ret;\n\n\tpmic_np = iodev->dev->of_node;\n\tif (!pmic_np) {\n\t\tdev_err(iodev->dev, \"could not find pmic sub-node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tregulators_np = of_get_child_by_name(pmic_np, \"regulators\");\n\tif (!regulators_np) {\n\t\tdev_err(iodev->dev, \"could not find regulators sub-node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpdata->num_regulators = of_get_child_count(regulators_np);\n\n\trdata = devm_kcalloc(&pdev->dev,\n\t\t\t     pdata->num_regulators, sizeof(*rdata),\n\t\t\t     GFP_KERNEL);\n\tif (!rdata) {\n\t\tof_node_put(regulators_np);\n\t\treturn -ENOMEM;\n\t}\n\n\trmode = devm_kcalloc(&pdev->dev,\n\t\t\t     pdata->num_regulators, sizeof(*rmode),\n\t\t\t     GFP_KERNEL);\n\tif (!rmode) {\n\t\tof_node_put(regulators_np);\n\t\treturn -ENOMEM;\n\t}\n\n\tpdata->regulators = rdata;\n\tpdata->opmode = rmode;\n\tfor_each_child_of_node(regulators_np, reg_np) {\n\t\tfor (i = 0; i < ARRAY_SIZE(regulators); i++)\n\t\t\tif (of_node_name_eq(reg_np, regulators[i].name))\n\t\t\t\tbreak;\n\n\t\tif (i == ARRAY_SIZE(regulators)) {\n\t\t\tdev_warn(iodev->dev,\n\t\t\t\"don't know how to configure regulator %pOFn\\n\",\n\t\t\treg_np);\n\t\t\tcontinue;\n\t\t}\n\n\t\trdata->ext_control_gpiod = devm_fwnode_gpiod_get(\n\t\t\t&pdev->dev,\n\t\t\tof_fwnode_handle(reg_np),\n\t\t\t\"s5m8767,pmic-ext-control\",\n\t\t\tGPIOD_OUT_HIGH | GPIOD_FLAGS_BIT_NONEXCLUSIVE,\n\t\t\t\"s5m8767\");\n\t\tif (PTR_ERR(rdata->ext_control_gpiod) == -ENOENT) {\n\t\t\trdata->ext_control_gpiod = NULL;\n\t\t} else if (IS_ERR(rdata->ext_control_gpiod)) {\n\t\t\tof_node_put(reg_np);\n\t\t\tof_node_put(regulators_np);\n\t\t\treturn PTR_ERR(rdata->ext_control_gpiod);\n\t\t}\n\n\t\trdata->id = i;\n\t\trdata->initdata = of_get_regulator_init_data(\n\t\t\t\t\t\t&pdev->dev, reg_np,\n\t\t\t\t\t\t&regulators[i]);\n\t\trdata->reg_node = reg_np;\n\t\trdata++;\n\t\trmode->id = i;\n\t\tif (of_property_read_u32(reg_np, \"op_mode\",\n\t\t\t\t&rmode->mode)) {\n\t\t\tdev_warn(iodev->dev,\n\t\t\t\t\"no op_mode property at %pOF\\n\",\n\t\t\t\treg_np);\n\n\t\t\trmode->mode = S5M8767_OPMODE_NORMAL_MODE;\n\t\t}\n\t\trmode++;\n\t}\n\n\tof_node_put(regulators_np);\n\n\tif (of_property_read_bool(pmic_np, \"s5m8767,pmic-buck2-uses-gpio-dvs\")) {\n\t\tpdata->buck2_gpiodvs = true;\n\n\t\tif (of_property_read_u32_array(pmic_np,\n\t\t\t\t\"s5m8767,pmic-buck2-dvs-voltage\",\n\t\t\t\tpdata->buck2_voltage, dvs_voltage_nr)) {\n\t\t\tdev_err(iodev->dev, \"buck2 voltages not specified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (of_property_read_bool(pmic_np, \"s5m8767,pmic-buck3-uses-gpio-dvs\")) {\n\t\tpdata->buck3_gpiodvs = true;\n\n\t\tif (of_property_read_u32_array(pmic_np,\n\t\t\t\t\"s5m8767,pmic-buck3-dvs-voltage\",\n\t\t\t\tpdata->buck3_voltage, dvs_voltage_nr)) {\n\t\t\tdev_err(iodev->dev, \"buck3 voltages not specified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (of_property_read_bool(pmic_np, \"s5m8767,pmic-buck4-uses-gpio-dvs\")) {\n\t\tpdata->buck4_gpiodvs = true;\n\n\t\tif (of_property_read_u32_array(pmic_np,\n\t\t\t\t\"s5m8767,pmic-buck4-dvs-voltage\",\n\t\t\t\tpdata->buck4_voltage, dvs_voltage_nr)) {\n\t\t\tdev_err(iodev->dev, \"buck4 voltages not specified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (pdata->buck2_gpiodvs || pdata->buck3_gpiodvs ||\n\t\t\t\t\t\tpdata->buck4_gpiodvs) {\n\t\tret = s5m8767_pmic_dt_parse_dvs_gpio(iodev, pdata, pmic_np);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\tif (of_property_read_u32(pmic_np,\n\t\t\t\t\"s5m8767,pmic-buck-default-dvs-idx\",\n\t\t\t\t&pdata->buck_default_idx)) {\n\t\t\tpdata->buck_default_idx = 0;\n\t\t} else {\n\t\t\tif (pdata->buck_default_idx >= 8) {\n\t\t\t\tpdata->buck_default_idx = 0;\n\t\t\t\tdev_info(iodev->dev,\n\t\t\t\t\"invalid value for default dvs index, use 0\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tret = s5m8767_pmic_dt_parse_ds_gpio(iodev, pdata, pmic_np);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tpdata->buck2_ramp_enable = of_property_read_bool(pmic_np, \"s5m8767,pmic-buck2-ramp-enable\");\n\tpdata->buck3_ramp_enable = of_property_read_bool(pmic_np, \"s5m8767,pmic-buck3-ramp-enable\");\n\tpdata->buck4_ramp_enable = of_property_read_bool(pmic_np, \"s5m8767,pmic-buck4-ramp-enable\");\n\n\tif (pdata->buck2_ramp_enable || pdata->buck3_ramp_enable\n\t\t\t|| pdata->buck4_ramp_enable) {\n\t\tif (of_property_read_u32(pmic_np, \"s5m8767,pmic-buck-ramp-delay\",\n\t\t\t\t&pdata->buck_ramp_delay))\n\t\t\tpdata->buck_ramp_delay = 0;\n\t}\n\n\treturn 0;\n}\n#else\nstatic int s5m8767_pmic_dt_parse_pdata(struct platform_device *pdev,\n\t\t\t\t\tstruct sec_platform_data *pdata)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int s5m8767_pmic_probe(struct platform_device *pdev)\n{\n\tstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\n\tstruct sec_platform_data *pdata = iodev->pdata;\n\tstruct regulator_config config = { };\n\tstruct s5m8767_info *s5m8767;\n\tint i, ret, buck_init;\n\n\tif (!pdata) {\n\t\tdev_err(pdev->dev.parent, \"Platform data not supplied\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (iodev->dev->of_node) {\n\t\tret = s5m8767_pmic_dt_parse_pdata(pdev, pdata);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (pdata->buck2_gpiodvs) {\n\t\tif (pdata->buck3_gpiodvs || pdata->buck4_gpiodvs) {\n\t\t\tdev_err(&pdev->dev, \"S5M8767 GPIO DVS NOT VALID\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (pdata->buck3_gpiodvs) {\n\t\tif (pdata->buck2_gpiodvs || pdata->buck4_gpiodvs) {\n\t\t\tdev_err(&pdev->dev, \"S5M8767 GPIO DVS NOT VALID\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (pdata->buck4_gpiodvs) {\n\t\tif (pdata->buck2_gpiodvs || pdata->buck3_gpiodvs) {\n\t\t\tdev_err(&pdev->dev, \"S5M8767 GPIO DVS NOT VALID\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ts5m8767 = devm_kzalloc(&pdev->dev, sizeof(struct s5m8767_info),\n\t\t\t\tGFP_KERNEL);\n\tif (!s5m8767)\n\t\treturn -ENOMEM;\n\n\ts5m8767->dev = &pdev->dev;\n\ts5m8767->iodev = iodev;\n\ts5m8767->num_regulators = pdata->num_regulators;\n\tplatform_set_drvdata(pdev, s5m8767);\n\n\ts5m8767->buck_gpioindex = pdata->buck_default_idx;\n\ts5m8767->buck2_gpiodvs = pdata->buck2_gpiodvs;\n\ts5m8767->buck3_gpiodvs = pdata->buck3_gpiodvs;\n\ts5m8767->buck4_gpiodvs = pdata->buck4_gpiodvs;\n\ts5m8767->buck_gpios[0] = pdata->buck_gpios[0];\n\ts5m8767->buck_gpios[1] = pdata->buck_gpios[1];\n\ts5m8767->buck_gpios[2] = pdata->buck_gpios[2];\n\ts5m8767->buck_ds[0] = pdata->buck_ds[0];\n\ts5m8767->buck_ds[1] = pdata->buck_ds[1];\n\ts5m8767->buck_ds[2] = pdata->buck_ds[2];\n\n\ts5m8767->ramp_delay = pdata->buck_ramp_delay;\n\ts5m8767->buck2_ramp = pdata->buck2_ramp_enable;\n\ts5m8767->buck3_ramp = pdata->buck3_ramp_enable;\n\ts5m8767->buck4_ramp = pdata->buck4_ramp_enable;\n\ts5m8767->opmode = pdata->opmode;\n\n\tbuck_init = s5m8767_convert_voltage_to_sel(&buck_voltage_val2,\n\t\t\t\t\t\t   pdata->buck2_init);\n\n\tregmap_write(s5m8767->iodev->regmap_pmic, S5M8767_REG_BUCK2DVS2,\n\t\t\tbuck_init);\n\n\tbuck_init = s5m8767_convert_voltage_to_sel(&buck_voltage_val2,\n\t\t\t\t\t\t   pdata->buck3_init);\n\n\tregmap_write(s5m8767->iodev->regmap_pmic, S5M8767_REG_BUCK3DVS2,\n\t\t\tbuck_init);\n\n\tbuck_init = s5m8767_convert_voltage_to_sel(&buck_voltage_val2,\n\t\t\t\t\t\t   pdata->buck4_init);\n\n\tregmap_write(s5m8767->iodev->regmap_pmic, S5M8767_REG_BUCK4DVS2,\n\t\t\tbuck_init);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (s5m8767->buck2_gpiodvs) {\n\t\t\ts5m8767->buck2_vol[i] =\n\t\t\t\ts5m8767_convert_voltage_to_sel(\n\t\t\t\t\t\t&buck_voltage_val2,\n\t\t\t\t\t\tpdata->buck2_voltage[i]);\n\t\t}\n\n\t\tif (s5m8767->buck3_gpiodvs) {\n\t\t\ts5m8767->buck3_vol[i] =\n\t\t\t\ts5m8767_convert_voltage_to_sel(\n\t\t\t\t\t\t&buck_voltage_val2,\n\t\t\t\t\t\tpdata->buck3_voltage[i]);\n\t\t}\n\n\t\tif (s5m8767->buck4_gpiodvs) {\n\t\t\ts5m8767->buck4_vol[i] =\n\t\t\t\ts5m8767_convert_voltage_to_sel(\n\t\t\t\t\t\t&buck_voltage_val2,\n\t\t\t\t\t\tpdata->buck4_voltage[i]);\n\t\t}\n\t}\n\n\tif (pdata->buck2_gpiodvs || pdata->buck3_gpiodvs ||\n\t\t\t\t\t\tpdata->buck4_gpiodvs) {\n\n\t\tif (!gpio_is_valid(pdata->buck_gpios[0]) ||\n\t\t\t!gpio_is_valid(pdata->buck_gpios[1]) ||\n\t\t\t!gpio_is_valid(pdata->buck_gpios[2])) {\n\t\t\tdev_err(&pdev->dev, \"GPIO NOT VALID\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = devm_gpio_request(&pdev->dev, pdata->buck_gpios[0],\n\t\t\t\t\t\"S5M8767 SET1\");\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_gpio_request(&pdev->dev, pdata->buck_gpios[1],\n\t\t\t\t\t\"S5M8767 SET2\");\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_gpio_request(&pdev->dev, pdata->buck_gpios[2],\n\t\t\t\t\t\"S5M8767 SET3\");\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tgpio_direction_output(pdata->buck_gpios[0],\n\t\t\t\t(s5m8767->buck_gpioindex >> 2) & 0x1);\n\t\t \n\t\tgpio_direction_output(pdata->buck_gpios[1],\n\t\t\t\t(s5m8767->buck_gpioindex >> 1) & 0x1);\n\t\t \n\t\tgpio_direction_output(pdata->buck_gpios[2],\n\t\t\t\t(s5m8767->buck_gpioindex >> 0) & 0x1);\n\t}\n\n\tret = devm_gpio_request(&pdev->dev, pdata->buck_ds[0], \"S5M8767 DS2\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_gpio_request(&pdev->dev, pdata->buck_ds[1], \"S5M8767 DS3\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_gpio_request(&pdev->dev, pdata->buck_ds[2], \"S5M8767 DS4\");\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tgpio_direction_output(pdata->buck_ds[0], 0x0);\n\t \n\tgpio_direction_output(pdata->buck_ds[1], 0x0);\n\t \n\tgpio_direction_output(pdata->buck_ds[2], 0x0);\n\n\tregmap_update_bits(s5m8767->iodev->regmap_pmic,\n\t\t\t   S5M8767_REG_BUCK2CTRL, 1 << 1,\n\t\t\t   (pdata->buck2_gpiodvs) ? (1 << 1) : (0 << 1));\n\tregmap_update_bits(s5m8767->iodev->regmap_pmic,\n\t\t\t   S5M8767_REG_BUCK3CTRL, 1 << 1,\n\t\t\t   (pdata->buck3_gpiodvs) ? (1 << 1) : (0 << 1));\n\tregmap_update_bits(s5m8767->iodev->regmap_pmic,\n\t\t\t   S5M8767_REG_BUCK4CTRL, 1 << 1,\n\t\t\t   (pdata->buck4_gpiodvs) ? (1 << 1) : (0 << 1));\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tif (s5m8767->buck2_gpiodvs) {\n\t\t\tregmap_write(s5m8767->iodev->regmap_pmic,\n\t\t\t\t\tS5M8767_REG_BUCK2DVS1 + i,\n\t\t\t\t\ts5m8767->buck2_vol[i]);\n\t\t}\n\n\t\tif (s5m8767->buck3_gpiodvs) {\n\t\t\tregmap_write(s5m8767->iodev->regmap_pmic,\n\t\t\t\t\tS5M8767_REG_BUCK3DVS1 + i,\n\t\t\t\t\ts5m8767->buck3_vol[i]);\n\t\t}\n\n\t\tif (s5m8767->buck4_gpiodvs) {\n\t\t\tregmap_write(s5m8767->iodev->regmap_pmic,\n\t\t\t\t\tS5M8767_REG_BUCK4DVS1 + i,\n\t\t\t\t\ts5m8767->buck4_vol[i]);\n\t\t}\n\t}\n\n\tif (s5m8767->buck2_ramp)\n\t\tregmap_update_bits(s5m8767->iodev->regmap_pmic,\n\t\t\t\tS5M8767_REG_DVSRAMP, 0x08, 0x08);\n\n\tif (s5m8767->buck3_ramp)\n\t\tregmap_update_bits(s5m8767->iodev->regmap_pmic,\n\t\t\t\tS5M8767_REG_DVSRAMP, 0x04, 0x04);\n\n\tif (s5m8767->buck4_ramp)\n\t\tregmap_update_bits(s5m8767->iodev->regmap_pmic,\n\t\t\t\tS5M8767_REG_DVSRAMP, 0x02, 0x02);\n\n\tif (s5m8767->buck2_ramp || s5m8767->buck3_ramp\n\t\t|| s5m8767->buck4_ramp) {\n\t\tunsigned int val;\n\t\tswitch (s5m8767->ramp_delay) {\n\t\tcase 5:\n\t\t\tval = S5M8767_DVS_BUCK_RAMP_5;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tval = S5M8767_DVS_BUCK_RAMP_10;\n\t\t\tbreak;\n\t\tcase 25:\n\t\t\tval = S5M8767_DVS_BUCK_RAMP_25;\n\t\t\tbreak;\n\t\tcase 50:\n\t\t\tval = S5M8767_DVS_BUCK_RAMP_50;\n\t\t\tbreak;\n\t\tcase 100:\n\t\t\tval = S5M8767_DVS_BUCK_RAMP_100;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval = S5M8767_DVS_BUCK_RAMP_10;\n\t\t}\n\t\tregmap_update_bits(s5m8767->iodev->regmap_pmic,\n\t\t\t\t\tS5M8767_REG_DVSRAMP,\n\t\t\t\t\tS5M8767_DVS_BUCK_RAMP_MASK,\n\t\t\t\t\tval << S5M8767_DVS_BUCK_RAMP_SHIFT);\n\t}\n\n\tfor (i = 0; i < pdata->num_regulators; i++) {\n\t\tconst struct sec_voltage_desc *desc;\n\t\tunsigned int id = pdata->regulators[i].id;\n\t\tint enable_reg, enable_val;\n\t\tstruct regulator_dev *rdev;\n\n\t\tBUILD_BUG_ON(ARRAY_SIZE(regulators) != ARRAY_SIZE(reg_voltage_map));\n\t\tif (WARN_ON_ONCE(id >= ARRAY_SIZE(regulators)))\n\t\t\tcontinue;\n\n\t\tdesc = reg_voltage_map[id];\n\t\tif (desc) {\n\t\t\tregulators[id].n_voltages =\n\t\t\t\t(desc->max - desc->min) / desc->step + 1;\n\t\t\tregulators[id].min_uV = desc->min;\n\t\t\tregulators[id].uV_step = desc->step;\n\t\t\tregulators[id].vsel_reg =\n\t\t\t\ts5m8767_get_vsel_reg(id, s5m8767);\n\t\t\tif (id < S5M8767_BUCK1)\n\t\t\t\tregulators[id].vsel_mask = 0x3f;\n\t\t\telse\n\t\t\t\tregulators[id].vsel_mask = 0xff;\n\n\t\t\tret = s5m8767_get_register(s5m8767, id, &enable_reg,\n\t\t\t\t\t     &enable_val);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(s5m8767->dev, \"error reading registers\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tregulators[id].enable_reg = enable_reg;\n\t\t\tregulators[id].enable_mask = S5M8767_ENCTRL_MASK;\n\t\t\tregulators[id].enable_val = enable_val;\n\t\t}\n\n\t\tconfig.dev = s5m8767->dev;\n\t\tconfig.init_data = pdata->regulators[i].initdata;\n\t\tconfig.driver_data = s5m8767;\n\t\tconfig.regmap = iodev->regmap_pmic;\n\t\tconfig.of_node = pdata->regulators[i].reg_node;\n\t\tconfig.ena_gpiod = NULL;\n\t\tif (pdata->regulators[i].ext_control_gpiod) {\n\t\t\t \n\t\t\ts5m8767_regulator_config_ext_control(s5m8767,\n\t\t\t\t\t&pdata->regulators[i], &config);\n\n\t\t\t \n\t\t\tdevm_gpiod_unhinge(s5m8767->dev, config.ena_gpiod);\n\t\t}\n\t\trdev = devm_regulator_register(&pdev->dev, &regulators[id],\n\t\t\t\t\t\t  &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tret = PTR_ERR(rdev);\n\t\t\tdev_err(s5m8767->dev, \"regulator init failed for %d\\n\",\n\t\t\t\t\tid);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (pdata->regulators[i].ext_control_gpiod) {\n\t\t\tret = s5m8767_enable_ext_control(s5m8767, rdev);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(s5m8767->dev,\n\t\t\t\t\t\t\"failed to enable gpio control over %s: %d\\n\",\n\t\t\t\t\t\trdev->desc->name, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id s5m8767_pmic_id[] = {\n\t{ \"s5m8767-pmic\", 0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, s5m8767_pmic_id);\n\nstatic struct platform_driver s5m8767_pmic_driver = {\n\t.driver = {\n\t\t.name = \"s5m8767-pmic\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = s5m8767_pmic_probe,\n\t.id_table = s5m8767_pmic_id,\n};\nmodule_platform_driver(s5m8767_pmic_driver);\n\n \nMODULE_AUTHOR(\"Sangbeom Kim <sbkim73@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung S5M8767 Regulator Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}