{
  "module_name": "devres.c",
  "hash_id": "72541bdbd18cc76475e00f3eaf7485bab957df94a463c8a7c786de8dad7c9662",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/devres.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regulator/driver.h>\n#include <linux/module.h>\n\n#include \"internal.h\"\n\nstatic void devm_regulator_release(struct device *dev, void *res)\n{\n\tregulator_put(*(struct regulator **)res);\n}\n\nstatic struct regulator *_devm_regulator_get(struct device *dev, const char *id,\n\t\t\t\t\t     int get_type)\n{\n\tstruct regulator **ptr, *regulator;\n\n\tptr = devres_alloc(devm_regulator_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tregulator = _regulator_get(dev, id, get_type);\n\tif (!IS_ERR(regulator)) {\n\t\t*ptr = regulator;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn regulator;\n}\n\n \nstruct regulator *devm_regulator_get(struct device *dev, const char *id)\n{\n\treturn _devm_regulator_get(dev, id, NORMAL_GET);\n}\nEXPORT_SYMBOL_GPL(devm_regulator_get);\n\n \nstruct regulator *devm_regulator_get_exclusive(struct device *dev,\n\t\t\t\t\t       const char *id)\n{\n\treturn _devm_regulator_get(dev, id, EXCLUSIVE_GET);\n}\nEXPORT_SYMBOL_GPL(devm_regulator_get_exclusive);\n\nstatic void regulator_action_disable(void *d)\n{\n\tstruct regulator *r = (struct regulator *)d;\n\n\tregulator_disable(r);\n}\n\nstatic int _devm_regulator_get_enable(struct device *dev, const char *id,\n\t\t\t\t      int get_type)\n{\n\tstruct regulator *r;\n\tint ret;\n\n\tr = _devm_regulator_get(dev, id, get_type);\n\tif (IS_ERR(r))\n\t\treturn PTR_ERR(r);\n\n\tret = regulator_enable(r);\n\tif (!ret)\n\t\tret = devm_add_action_or_reset(dev, &regulator_action_disable, r);\n\n\tif (ret)\n\t\tdevm_regulator_put(r);\n\n\treturn ret;\n}\n\n \nint devm_regulator_get_enable_optional(struct device *dev, const char *id)\n{\n\treturn _devm_regulator_get_enable(dev, id, OPTIONAL_GET);\n}\nEXPORT_SYMBOL_GPL(devm_regulator_get_enable_optional);\n\n \nint devm_regulator_get_enable(struct device *dev, const char *id)\n{\n\treturn _devm_regulator_get_enable(dev, id, NORMAL_GET);\n}\nEXPORT_SYMBOL_GPL(devm_regulator_get_enable);\n\n \nstruct regulator *devm_regulator_get_optional(struct device *dev,\n\t\t\t\t\t      const char *id)\n{\n\treturn _devm_regulator_get(dev, id, OPTIONAL_GET);\n}\nEXPORT_SYMBOL_GPL(devm_regulator_get_optional);\n\nstatic int devm_regulator_match(struct device *dev, void *res, void *data)\n{\n\tstruct regulator **r = res;\n\tif (!r || !*r) {\n\t\tWARN_ON(!r || !*r);\n\t\treturn 0;\n\t}\n\treturn *r == data;\n}\n\n \nvoid devm_regulator_put(struct regulator *regulator)\n{\n\tint rc;\n\n\trc = devres_release(regulator->dev, devm_regulator_release,\n\t\t\t    devm_regulator_match, regulator);\n\tif (rc != 0)\n\t\tWARN_ON(rc);\n}\nEXPORT_SYMBOL_GPL(devm_regulator_put);\n\nstruct regulator_bulk_devres {\n\tstruct regulator_bulk_data *consumers;\n\tint num_consumers;\n};\n\nstatic void devm_regulator_bulk_release(struct device *dev, void *res)\n{\n\tstruct regulator_bulk_devres *devres = res;\n\n\tregulator_bulk_free(devres->num_consumers, devres->consumers);\n}\n\nstatic int _devm_regulator_bulk_get(struct device *dev, int num_consumers,\n\t\t\t\t    struct regulator_bulk_data *consumers,\n\t\t\t\t    enum regulator_get_type get_type)\n{\n\tstruct regulator_bulk_devres *devres;\n\tint ret;\n\n\tdevres = devres_alloc(devm_regulator_bulk_release,\n\t\t\t      sizeof(*devres), GFP_KERNEL);\n\tif (!devres)\n\t\treturn -ENOMEM;\n\n\tret = _regulator_bulk_get(dev, num_consumers, consumers, get_type);\n\tif (!ret) {\n\t\tdevres->consumers = consumers;\n\t\tdevres->num_consumers = num_consumers;\n\t\tdevres_add(dev, devres);\n\t} else {\n\t\tdevres_free(devres);\n\t}\n\n\treturn ret;\n}\n\n \nint devm_regulator_bulk_get(struct device *dev, int num_consumers,\n\t\t\t    struct regulator_bulk_data *consumers)\n{\n\treturn _devm_regulator_bulk_get(dev, num_consumers, consumers, NORMAL_GET);\n}\nEXPORT_SYMBOL_GPL(devm_regulator_bulk_get);\n\n \nint devm_regulator_bulk_get_exclusive(struct device *dev, int num_consumers,\n\t\t\t\t      struct regulator_bulk_data *consumers)\n{\n\treturn _devm_regulator_bulk_get(dev, num_consumers, consumers, EXCLUSIVE_GET);\n}\nEXPORT_SYMBOL_GPL(devm_regulator_bulk_get_exclusive);\n\n \nint devm_regulator_bulk_get_const(struct device *dev, int num_consumers,\n\t\t\t\t  const struct regulator_bulk_data *in_consumers,\n\t\t\t\t  struct regulator_bulk_data **out_consumers)\n{\n\t*out_consumers = devm_kmemdup(dev, in_consumers,\n\t\t\t\t      num_consumers * sizeof(*in_consumers),\n\t\t\t\t      GFP_KERNEL);\n\tif (*out_consumers == NULL)\n\t\treturn -ENOMEM;\n\n\treturn devm_regulator_bulk_get(dev, num_consumers, *out_consumers);\n}\nEXPORT_SYMBOL_GPL(devm_regulator_bulk_get_const);\n\nstatic int devm_regulator_bulk_match(struct device *dev, void *res,\n\t\t\t\t     void *data)\n{\n\tstruct regulator_bulk_devres *match = res;\n\tstruct regulator_bulk_data *target = data;\n\n\t \n\treturn match->consumers == target;\n}\n\n \nvoid devm_regulator_bulk_put(struct regulator_bulk_data *consumers)\n{\n\tint rc;\n\tstruct regulator *regulator = consumers[0].consumer;\n\n\trc = devres_release(regulator->dev, devm_regulator_bulk_release,\n\t\t\t    devm_regulator_bulk_match, consumers);\n\tif (rc != 0)\n\t\tWARN_ON(rc);\n}\nEXPORT_SYMBOL_GPL(devm_regulator_bulk_put);\n\nstatic void devm_regulator_bulk_disable(void *res)\n{\n\tstruct regulator_bulk_devres *devres = res;\n\tint i;\n\n\tfor (i = 0; i < devres->num_consumers; i++)\n\t\tregulator_disable(devres->consumers[i].consumer);\n}\n\n \nint devm_regulator_bulk_get_enable(struct device *dev, int num_consumers,\n\t\t\t\t   const char * const *id)\n{\n\tstruct regulator_bulk_devres *devres;\n\tstruct regulator_bulk_data *consumers;\n\tint i, ret;\n\n\tdevres = devm_kmalloc(dev, sizeof(*devres), GFP_KERNEL);\n\tif (!devres)\n\t\treturn -ENOMEM;\n\n\tdevres->consumers = devm_kcalloc(dev, num_consumers, sizeof(*consumers),\n\t\t\t\t\t GFP_KERNEL);\n\tconsumers = devres->consumers;\n\tif (!consumers)\n\t\treturn -ENOMEM;\n\n\tdevres->num_consumers = num_consumers;\n\n\tfor (i = 0; i < num_consumers; i++)\n\t\tconsumers[i].supply = id[i];\n\n\tret = devm_regulator_bulk_get(dev, num_consumers, consumers);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tret = regulator_enable(consumers[i].consumer);\n\t\tif (ret)\n\t\t\tgoto unwind;\n\t}\n\n\tret = devm_add_action(dev, devm_regulator_bulk_disable, devres);\n\tif (!ret)\n\t\treturn 0;\n\nunwind:\n\twhile (--i >= 0)\n\t\tregulator_disable(consumers[i].consumer);\n\n\tdevm_regulator_bulk_put(consumers);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_regulator_bulk_get_enable);\n\nstatic void devm_rdev_release(struct device *dev, void *res)\n{\n\tregulator_unregister(*(struct regulator_dev **)res);\n}\n\n \nstruct regulator_dev *devm_regulator_register(struct device *dev,\n\t\t\t\t  const struct regulator_desc *regulator_desc,\n\t\t\t\t  const struct regulator_config *config)\n{\n\tstruct regulator_dev **ptr, *rdev;\n\n\tptr = devres_alloc(devm_rdev_release, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trdev = regulator_register(dev, regulator_desc, config);\n\tif (!IS_ERR(rdev)) {\n\t\t*ptr = rdev;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn rdev;\n}\nEXPORT_SYMBOL_GPL(devm_regulator_register);\n\nstruct regulator_supply_alias_match {\n\tstruct device *dev;\n\tconst char *id;\n};\n\nstatic int devm_regulator_match_supply_alias(struct device *dev, void *res,\n\t\t\t\t\t     void *data)\n{\n\tstruct regulator_supply_alias_match *match = res;\n\tstruct regulator_supply_alias_match *target = data;\n\n\treturn match->dev == target->dev && strcmp(match->id, target->id) == 0;\n}\n\nstatic void devm_regulator_destroy_supply_alias(struct device *dev, void *res)\n{\n\tstruct regulator_supply_alias_match *match = res;\n\n\tregulator_unregister_supply_alias(match->dev, match->id);\n}\n\n \nint devm_regulator_register_supply_alias(struct device *dev, const char *id,\n\t\t\t\t\t struct device *alias_dev,\n\t\t\t\t\t const char *alias_id)\n{\n\tstruct regulator_supply_alias_match *match;\n\tint ret;\n\n\tmatch = devres_alloc(devm_regulator_destroy_supply_alias,\n\t\t\t   sizeof(struct regulator_supply_alias_match),\n\t\t\t   GFP_KERNEL);\n\tif (!match)\n\t\treturn -ENOMEM;\n\n\tmatch->dev = dev;\n\tmatch->id = id;\n\n\tret = regulator_register_supply_alias(dev, id, alias_dev, alias_id);\n\tif (ret < 0) {\n\t\tdevres_free(match);\n\t\treturn ret;\n\t}\n\n\tdevres_add(dev, match);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_regulator_register_supply_alias);\n\nstatic void devm_regulator_unregister_supply_alias(struct device *dev,\n\t\t\t\t\t\t   const char *id)\n{\n\tstruct regulator_supply_alias_match match;\n\tint rc;\n\n\tmatch.dev = dev;\n\tmatch.id = id;\n\n\trc = devres_release(dev, devm_regulator_destroy_supply_alias,\n\t\t\t    devm_regulator_match_supply_alias, &match);\n\tif (rc != 0)\n\t\tWARN_ON(rc);\n}\n\n \nint devm_regulator_bulk_register_supply_alias(struct device *dev,\n\t\t\t\t\t      const char *const *id,\n\t\t\t\t\t      struct device *alias_dev,\n\t\t\t\t\t      const char *const *alias_id,\n\t\t\t\t\t      int num_id)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < num_id; ++i) {\n\t\tret = devm_regulator_register_supply_alias(dev, id[i],\n\t\t\t\t\t\t\t   alias_dev,\n\t\t\t\t\t\t\t   alias_id[i]);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tdev_err(dev,\n\t\t\"Failed to create supply alias %s,%s -> %s,%s\\n\",\n\t\tid[i], dev_name(dev), alias_id[i], dev_name(alias_dev));\n\n\twhile (--i >= 0)\n\t\tdevm_regulator_unregister_supply_alias(dev, id[i]);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_regulator_bulk_register_supply_alias);\n\nstruct regulator_notifier_match {\n\tstruct regulator *regulator;\n\tstruct notifier_block *nb;\n};\n\nstatic int devm_regulator_match_notifier(struct device *dev, void *res,\n\t\t\t\t\t void *data)\n{\n\tstruct regulator_notifier_match *match = res;\n\tstruct regulator_notifier_match *target = data;\n\n\treturn match->regulator == target->regulator && match->nb == target->nb;\n}\n\nstatic void devm_regulator_destroy_notifier(struct device *dev, void *res)\n{\n\tstruct regulator_notifier_match *match = res;\n\n\tregulator_unregister_notifier(match->regulator, match->nb);\n}\n\n \nint devm_regulator_register_notifier(struct regulator *regulator,\n\t\t\t\t     struct notifier_block *nb)\n{\n\tstruct regulator_notifier_match *match;\n\tint ret;\n\n\tmatch = devres_alloc(devm_regulator_destroy_notifier,\n\t\t\t     sizeof(struct regulator_notifier_match),\n\t\t\t     GFP_KERNEL);\n\tif (!match)\n\t\treturn -ENOMEM;\n\n\tmatch->regulator = regulator;\n\tmatch->nb = nb;\n\n\tret = regulator_register_notifier(regulator, nb);\n\tif (ret < 0) {\n\t\tdevres_free(match);\n\t\treturn ret;\n\t}\n\n\tdevres_add(regulator->dev, match);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_regulator_register_notifier);\n\n \nvoid devm_regulator_unregister_notifier(struct regulator *regulator,\n\t\t\t\t\tstruct notifier_block *nb)\n{\n\tstruct regulator_notifier_match match;\n\tint rc;\n\n\tmatch.regulator = regulator;\n\tmatch.nb = nb;\n\n\trc = devres_release(regulator->dev, devm_regulator_destroy_notifier,\n\t\t\t    devm_regulator_match_notifier, &match);\n\tif (rc != 0)\n\t\tWARN_ON(rc);\n}\nEXPORT_SYMBOL_GPL(devm_regulator_unregister_notifier);\n\nstatic void regulator_irq_helper_drop(void *res)\n{\n\tregulator_irq_helper_cancel(&res);\n}\n\n \nvoid *devm_regulator_irq_helper(struct device *dev,\n\t\t\t\tconst struct regulator_irq_desc *d, int irq,\n\t\t\t\tint irq_flags, int common_errs,\n\t\t\t\tint *per_rdev_errs,\n\t\t\t\tstruct regulator_dev **rdev, int rdev_amount)\n{\n\tvoid *ptr;\n\tint ret;\n\n\tptr = regulator_irq_helper(dev, d, irq, irq_flags, common_errs,\n\t\t\t\t    per_rdev_errs, rdev, rdev_amount);\n\tif (IS_ERR(ptr))\n\t\treturn ptr;\n\n\tret = devm_add_action_or_reset(dev, regulator_irq_helper_drop, ptr);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn ptr;\n}\nEXPORT_SYMBOL_GPL(devm_regulator_irq_helper);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}