{
  "module_name": "tps65219-regulator.c",
  "hash_id": "af6e4715247aaa2d18e9b6231a5cce5a48a9da262e49315411d3565f04b69d5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/tps65219-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/mfd/tps65219.h>\n\nstruct tps65219_regulator_irq_type {\n\tconst char *irq_name;\n\tconst char *regulator_name;\n\tconst char *event_name;\n\tunsigned long event;\n};\n\nstatic struct tps65219_regulator_irq_type tps65219_regulator_irq_types[] = {\n\t{ \"LDO3_SCG\", \"LDO3\", \"short circuit to ground\", REGULATOR_EVENT_REGULATION_OUT },\n\t{ \"LDO3_OC\", \"LDO3\", \"overcurrent\", REGULATOR_EVENT_OVER_CURRENT },\n\t{ \"LDO3_UV\", \"LDO3\", \"undervoltage\", REGULATOR_EVENT_UNDER_VOLTAGE },\n\t{ \"LDO4_SCG\", \"LDO4\", \"short circuit to ground\", REGULATOR_EVENT_REGULATION_OUT },\n\t{ \"LDO4_OC\", \"LDO4\", \"overcurrent\", REGULATOR_EVENT_OVER_CURRENT },\n\t{ \"LDO4_UV\", \"LDO4\", \"undervoltage\", REGULATOR_EVENT_UNDER_VOLTAGE },\n\t{ \"LDO1_SCG\", \"LDO1\", \"short circuit to ground\", REGULATOR_EVENT_REGULATION_OUT },\n\t{ \"LDO1_OC\", \"LDO1\", \"overcurrent\", REGULATOR_EVENT_OVER_CURRENT },\n\t{ \"LDO1_UV\", \"LDO1\", \"undervoltage\", REGULATOR_EVENT_UNDER_VOLTAGE },\n\t{ \"LDO2_SCG\", \"LDO2\", \"short circuit to ground\", REGULATOR_EVENT_REGULATION_OUT },\n\t{ \"LDO2_OC\", \"LDO2\", \"overcurrent\", REGULATOR_EVENT_OVER_CURRENT },\n\t{ \"LDO2_UV\", \"LDO2\", \"undervoltage\", REGULATOR_EVENT_UNDER_VOLTAGE },\n\t{ \"BUCK3_SCG\", \"BUCK3\", \"short circuit to ground\", REGULATOR_EVENT_REGULATION_OUT },\n\t{ \"BUCK3_OC\", \"BUCK3\", \"overcurrent\", REGULATOR_EVENT_OVER_CURRENT },\n\t{ \"BUCK3_NEG_OC\", \"BUCK3\", \"negative overcurrent\", REGULATOR_EVENT_OVER_CURRENT },\n\t{ \"BUCK3_UV\", \"BUCK3\", \"undervoltage\", REGULATOR_EVENT_UNDER_VOLTAGE },\n\t{ \"BUCK1_SCG\", \"BUCK1\", \"short circuit to ground\", REGULATOR_EVENT_REGULATION_OUT },\n\t{ \"BUCK1_OC\", \"BUCK1\", \"overcurrent\", REGULATOR_EVENT_OVER_CURRENT },\n\t{ \"BUCK1_NEG_OC\", \"BUCK1\", \"negative overcurrent\", REGULATOR_EVENT_OVER_CURRENT },\n\t{ \"BUCK1_UV\", \"BUCK1\", \"undervoltage\", REGULATOR_EVENT_UNDER_VOLTAGE },\n\t{ \"BUCK2_SCG\", \"BUCK2\", \"short circuit to ground\", REGULATOR_EVENT_REGULATION_OUT },\n\t{ \"BUCK2_OC\", \"BUCK2\", \"overcurrent\", REGULATOR_EVENT_OVER_CURRENT },\n\t{ \"BUCK2_NEG_OC\", \"BUCK2\", \"negative overcurrent\", REGULATOR_EVENT_OVER_CURRENT },\n\t{ \"BUCK2_UV\", \"BUCK2\", \"undervoltage\", REGULATOR_EVENT_UNDER_VOLTAGE },\n\t{ \"BUCK1_RV\", \"BUCK1\", \"residual voltage\", REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"BUCK2_RV\", \"BUCK2\", \"residual voltage\", REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"BUCK3_RV\", \"BUCK3\", \"residual voltage\", REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"LDO1_RV\", \"LDO1\", \"residual voltage\", REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"LDO2_RV\", \"LDO2\", \"residual voltage\", REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"LDO3_RV\", \"LDO3\", \"residual voltage\", REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"LDO4_RV\", \"LDO4\", \"residual voltage\", REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"BUCK1_RV_SD\", \"BUCK1\", \"residual voltage on shutdown\",\n\t REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"BUCK2_RV_SD\", \"BUCK2\", \"residual voltage on shutdown\",\n\t REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"BUCK3_RV_SD\", \"BUCK3\", \"residual voltage on shutdown\",\n\t REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"LDO1_RV_SD\", \"LDO1\", \"residual voltage on shutdown\", REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"LDO2_RV_SD\", \"LDO2\", \"residual voltage on shutdown\", REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"LDO3_RV_SD\", \"LDO3\", \"residual voltage on shutdown\", REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"LDO4_RV_SD\", \"LDO4\", \"residual voltage on shutdown\", REGULATOR_EVENT_OVER_VOLTAGE_WARN },\n\t{ \"SENSOR_3_WARM\", \"SENSOR3\", \"warm temperature\", REGULATOR_EVENT_OVER_TEMP_WARN},\n\t{ \"SENSOR_2_WARM\", \"SENSOR2\", \"warm temperature\", REGULATOR_EVENT_OVER_TEMP_WARN },\n\t{ \"SENSOR_1_WARM\", \"SENSOR1\", \"warm temperature\", REGULATOR_EVENT_OVER_TEMP_WARN },\n\t{ \"SENSOR_0_WARM\", \"SENSOR0\", \"warm temperature\", REGULATOR_EVENT_OVER_TEMP_WARN },\n\t{ \"SENSOR_3_HOT\", \"SENSOR3\", \"hot temperature\", REGULATOR_EVENT_OVER_TEMP},\n\t{ \"SENSOR_2_HOT\", \"SENSOR2\", \"hot temperature\", REGULATOR_EVENT_OVER_TEMP },\n\t{ \"SENSOR_1_HOT\", \"SENSOR1\", \"hot temperature\", REGULATOR_EVENT_OVER_TEMP },\n\t{ \"SENSOR_0_HOT\", \"SENSOR0\", \"hot temperature\", REGULATOR_EVENT_OVER_TEMP },\n\t{ \"TIMEOUT\", \"\", \"\", REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE },\n};\n\nstruct tps65219_regulator_irq_data {\n\tstruct device *dev;\n\tstruct tps65219_regulator_irq_type *type;\n\tstruct regulator_dev *rdev;\n};\n\n#define TPS65219_REGULATOR(_name, _of, _id, _type, _ops, _n, _vr, _vm, _er, \\\n\t\t\t   _em, _cr, _cm, _lr, _nlr, _delay, _fuv, \\\n\t\t\t   _ct, _ncl, _bpm) \\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name\t\t\t= _name,\t\t\t\\\n\t\t.of_match\t\t= _of,\t\t\t\t\\\n\t\t.regulators_node\t= of_match_ptr(\"regulators\"),\t\\\n\t\t.supply_name\t\t= _of,\t\t\t\t\\\n\t\t.id\t\t\t= _id,\t\t\t\t\\\n\t\t.ops\t\t\t= &(_ops),\t\t\t\\\n\t\t.n_voltages\t\t= _n,\t\t\t\t\\\n\t\t.type\t\t\t= _type,\t\t\t\\\n\t\t.owner\t\t\t= THIS_MODULE,\t\t\t\\\n\t\t.vsel_reg\t\t= _vr,\t\t\t\t\\\n\t\t.vsel_mask\t\t= _vm,\t\t\t\t\\\n\t\t.csel_reg\t\t= _cr,\t\t\t\t\\\n\t\t.csel_mask\t\t= _cm,\t\t\t\t\\\n\t\t.curr_table\t\t= _ct,\t\t\t\t\\\n\t\t.n_current_limits\t= _ncl,\t\t\t\t\\\n\t\t.enable_reg\t\t= _er,\t\t\t\t\\\n\t\t.enable_mask\t\t= _em,\t\t\t\t\\\n\t\t.volt_table\t\t= NULL,\t\t\t\t\\\n\t\t.linear_ranges\t\t= _lr,\t\t\t\t\\\n\t\t.n_linear_ranges\t= _nlr,\t\t\t\t\\\n\t\t.ramp_delay\t\t= _delay,\t\t\t\\\n\t\t.fixed_uV\t\t= _fuv,\t\t\t\t\\\n\t\t.bypass_reg\t\t= _vr,\t\t\t\t\\\n\t\t.bypass_mask\t\t= _bpm,\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\nstatic const struct linear_range bucks_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(600000, 0x0, 0x1f, 25000),\n\tREGULATOR_LINEAR_RANGE(1400000, 0x20, 0x33, 100000),\n\tREGULATOR_LINEAR_RANGE(3400000, 0x34, 0x3f, 0),\n};\n\nstatic const struct linear_range ldos_1_2_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(600000, 0x0, 0x37, 50000),\n\tREGULATOR_LINEAR_RANGE(3400000, 0x38, 0x3f, 0),\n};\n\nstatic const struct linear_range ldos_3_4_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1200000, 0x0, 0xC, 0),\n\tREGULATOR_LINEAR_RANGE(1250000, 0xD, 0x35, 50000),\n\tREGULATOR_LINEAR_RANGE(3300000, 0x36, 0x3F, 0),\n};\n\nstatic int tps65219_set_mode(struct regulator_dev *dev, unsigned int mode)\n{\n\tstruct tps65219 *tps = rdev_get_drvdata(dev);\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\treturn regmap_set_bits(tps->regmap, TPS65219_REG_STBY_1_CONFIG,\n\t\t\t\t       dev->desc->enable_mask);\n\n\tcase REGULATOR_MODE_STANDBY:\n\t\treturn regmap_clear_bits(tps->regmap,\n\t\t\t\t\t TPS65219_REG_STBY_1_CONFIG,\n\t\t\t\t\t dev->desc->enable_mask);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic unsigned int tps65219_get_mode(struct regulator_dev *dev)\n{\n\tstruct tps65219 *tps = rdev_get_drvdata(dev);\n\tunsigned int rid = rdev_get_id(dev);\n\tint ret, value = 0;\n\n\tret = regmap_read(tps->regmap, TPS65219_REG_STBY_1_CONFIG, &value);\n\tif (ret) {\n\t\tdev_dbg(tps->dev, \"%s failed for regulator %s: %d \",\n\t\t\t__func__, dev->desc->name, ret);\n\t\treturn ret;\n\t}\n\tvalue = (value & BIT(rid)) >> rid;\n\tif (value)\n\t\treturn REGULATOR_MODE_STANDBY;\n\telse\n\t\treturn REGULATOR_MODE_NORMAL;\n}\n\n \nstatic const struct regulator_ops tps65219_bucks_ops = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.set_mode\t\t= tps65219_set_mode,\n\t.get_mode\t\t= tps65219_get_mode,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n\t.set_voltage_time_sel\t= regulator_set_voltage_time_sel,\n\n};\n\n \nstatic const struct regulator_ops tps65219_ldos_1_2_ops = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.set_mode\t\t= tps65219_set_mode,\n\t.get_mode\t\t= tps65219_get_mode,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n\t.set_bypass\t\t= regulator_set_bypass_regmap,\n\t.get_bypass\t\t= regulator_get_bypass_regmap,\n};\n\n \nstatic const struct regulator_ops tps65219_ldos_3_4_ops = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.set_mode\t\t= tps65219_set_mode,\n\t.get_mode\t\t= tps65219_get_mode,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n};\n\nstatic const struct regulator_desc regulators[] = {\n\tTPS65219_REGULATOR(\"BUCK1\", \"buck1\", TPS65219_BUCK_1,\n\t\t\t   REGULATOR_VOLTAGE, tps65219_bucks_ops, 64,\n\t\t\t   TPS65219_REG_BUCK1_VOUT,\n\t\t\t   TPS65219_BUCKS_LDOS_VOUT_VSET_MASK,\n\t\t\t   TPS65219_REG_ENABLE_CTRL,\n\t\t\t   TPS65219_ENABLE_BUCK1_EN_MASK, 0, 0, bucks_ranges,\n\t\t\t   3, 4000, 0, NULL, 0, 0),\n\tTPS65219_REGULATOR(\"BUCK2\", \"buck2\", TPS65219_BUCK_2,\n\t\t\t   REGULATOR_VOLTAGE, tps65219_bucks_ops, 64,\n\t\t\t   TPS65219_REG_BUCK2_VOUT,\n\t\t\t   TPS65219_BUCKS_LDOS_VOUT_VSET_MASK,\n\t\t\t   TPS65219_REG_ENABLE_CTRL,\n\t\t\t   TPS65219_ENABLE_BUCK2_EN_MASK, 0, 0, bucks_ranges,\n\t\t\t   3, 4000, 0, NULL, 0, 0),\n\tTPS65219_REGULATOR(\"BUCK3\", \"buck3\", TPS65219_BUCK_3,\n\t\t\t   REGULATOR_VOLTAGE, tps65219_bucks_ops, 64,\n\t\t\t   TPS65219_REG_BUCK3_VOUT,\n\t\t\t   TPS65219_BUCKS_LDOS_VOUT_VSET_MASK,\n\t\t\t   TPS65219_REG_ENABLE_CTRL,\n\t\t\t   TPS65219_ENABLE_BUCK3_EN_MASK, 0, 0, bucks_ranges,\n\t\t\t   3, 0, 0, NULL, 0, 0),\n\tTPS65219_REGULATOR(\"LDO1\", \"ldo1\", TPS65219_LDO_1,\n\t\t\t   REGULATOR_VOLTAGE, tps65219_ldos_1_2_ops, 64,\n\t\t\t   TPS65219_REG_LDO1_VOUT,\n\t\t\t   TPS65219_BUCKS_LDOS_VOUT_VSET_MASK,\n\t\t\t   TPS65219_REG_ENABLE_CTRL,\n\t\t\t   TPS65219_ENABLE_LDO1_EN_MASK, 0, 0, ldos_1_2_ranges,\n\t\t\t   2, 0, 0, NULL, 0, TPS65219_LDOS_BYP_CONFIG_MASK),\n\tTPS65219_REGULATOR(\"LDO2\", \"ldo2\", TPS65219_LDO_2,\n\t\t\t   REGULATOR_VOLTAGE, tps65219_ldos_1_2_ops, 64,\n\t\t\t   TPS65219_REG_LDO2_VOUT,\n\t\t\t   TPS65219_BUCKS_LDOS_VOUT_VSET_MASK,\n\t\t\t   TPS65219_REG_ENABLE_CTRL,\n\t\t\t   TPS65219_ENABLE_LDO2_EN_MASK, 0, 0, ldos_1_2_ranges,\n\t\t\t   2, 0, 0, NULL, 0, TPS65219_LDOS_BYP_CONFIG_MASK),\n\tTPS65219_REGULATOR(\"LDO3\", \"ldo3\", TPS65219_LDO_3,\n\t\t\t   REGULATOR_VOLTAGE, tps65219_ldos_3_4_ops, 64,\n\t\t\t   TPS65219_REG_LDO3_VOUT,\n\t\t\t   TPS65219_BUCKS_LDOS_VOUT_VSET_MASK,\n\t\t\t   TPS65219_REG_ENABLE_CTRL,\n\t\t\t   TPS65219_ENABLE_LDO3_EN_MASK, 0, 0, ldos_3_4_ranges,\n\t\t\t   3, 0, 0, NULL, 0, 0),\n\tTPS65219_REGULATOR(\"LDO4\", \"ldo4\", TPS65219_LDO_4,\n\t\t\t   REGULATOR_VOLTAGE, tps65219_ldos_3_4_ops, 64,\n\t\t\t   TPS65219_REG_LDO4_VOUT,\n\t\t\t   TPS65219_BUCKS_LDOS_VOUT_VSET_MASK,\n\t\t\t   TPS65219_REG_ENABLE_CTRL,\n\t\t\t   TPS65219_ENABLE_LDO4_EN_MASK, 0, 0, ldos_3_4_ranges,\n\t\t\t   3, 0, 0, NULL, 0, 0),\n};\n\nstatic irqreturn_t tps65219_regulator_irq_handler(int irq, void *data)\n{\n\tstruct tps65219_regulator_irq_data *irq_data = data;\n\n\tif (irq_data->type->event_name[0] == '\\0') {\n\t\t \n\t\tdev_err(irq_data->dev,\n\t\t\t\"System was put in shutdown due to timeout during an active or standby transition.\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tregulator_notifier_call_chain(irq_data->rdev,\n\t\t\t\t      irq_data->type->event, NULL);\n\n\tdev_err(irq_data->dev, \"Error IRQ trap %s for %s\\n\",\n\t\tirq_data->type->event_name, irq_data->type->regulator_name);\n\treturn IRQ_HANDLED;\n}\n\nstatic int tps65219_get_rdev_by_name(const char *regulator_name,\n\t\t\t\t     struct regulator_dev *rdevtbl[7],\n\t\t\t\t     struct regulator_dev **dev)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(regulators); i++) {\n\t\tif (strcmp(regulator_name, regulators[i].name) == 0) {\n\t\t\t*dev = rdevtbl[i];\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int tps65219_regulator_probe(struct platform_device *pdev)\n{\n\tstruct tps65219 *tps = dev_get_drvdata(pdev->dev.parent);\n\tstruct regulator_dev *rdev;\n\tstruct regulator_config config = { };\n\tint i;\n\tint error;\n\tint irq;\n\tstruct tps65219_regulator_irq_data *irq_data;\n\tstruct tps65219_regulator_irq_type *irq_type;\n\tstruct regulator_dev *rdevtbl[7];\n\n\tconfig.dev = tps->dev;\n\tconfig.driver_data = tps;\n\tconfig.regmap = tps->regmap;\n\n\tfor (i = 0; i < ARRAY_SIZE(regulators); i++) {\n\t\tdev_dbg(tps->dev, \"%s regul i= %d START\", __func__, i);\n\t\trdev = devm_regulator_register(&pdev->dev, &regulators[i],\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(tps->dev, \"failed to register %s regulator\\n\",\n\t\t\t\tregulators[i].name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\trdevtbl[i] = rdev;\n\t\tdev_dbg(tps->dev, \"%s regul i= %d COMPLETED\", __func__, i);\n\t}\n\n\tirq_data = devm_kmalloc(tps->dev,\n\t\t\t\tARRAY_SIZE(tps65219_regulator_irq_types) *\n\t\t\t\tsizeof(struct tps65219_regulator_irq_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!irq_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(tps65219_regulator_irq_types); ++i) {\n\t\tirq_type = &tps65219_regulator_irq_types[i];\n\n\t\tirq = platform_get_irq_byname(pdev, irq_type->irq_name);\n\t\tif (irq < 0)\n\t\t\treturn -EINVAL;\n\n\t\tirq_data[i].dev = tps->dev;\n\t\tirq_data[i].type = irq_type;\n\n\t\ttps65219_get_rdev_by_name(irq_type->regulator_name, rdevtbl, &rdev);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(tps->dev, \"Failed to get rdev for %s\\n\",\n\t\t\t\tirq_type->regulator_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tirq_data[i].rdev = rdev;\n\n\t\terror = devm_request_threaded_irq(tps->dev, irq, NULL,\n\t\t\t\t\t\t  tps65219_regulator_irq_handler,\n\t\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t\t  irq_type->irq_name,\n\t\t\t\t\t\t  &irq_data[i]);\n\t\tif (error) {\n\t\t\tdev_err(tps->dev, \"failed to request %s IRQ %d: %d\\n\",\n\t\t\t\tirq_type->irq_name, irq, error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id tps65219_regulator_id_table[] = {\n\t{ \"tps65219-regulator\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, tps65219_regulator_id_table);\n\nstatic struct platform_driver tps65219_regulator_driver = {\n\t.driver = {\n\t\t.name = \"tps65219-pmic\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = tps65219_regulator_probe,\n\t.id_table = tps65219_regulator_id_table,\n};\n\nmodule_platform_driver(tps65219_regulator_driver);\n\nMODULE_AUTHOR(\"Jerome Neanne <j-neanne@baylibre.com>\");\nMODULE_DESCRIPTION(\"TPS65219 voltage regulator driver\");\nMODULE_ALIAS(\"platform:tps65219-pmic\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}