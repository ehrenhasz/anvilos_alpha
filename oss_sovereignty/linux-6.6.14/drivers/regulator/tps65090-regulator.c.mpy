{
  "module_name": "tps65090-regulator.c",
  "hash_id": "cead07b071861c7c53366cfeaafdd3a6d2814afce29be9b6aadf7a25be17cbfd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/tps65090-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/mfd/tps65090.h>\n\n#define MAX_CTRL_READ_TRIES\t5\n#define MAX_FET_ENABLE_TRIES\t1000\n\n#define CTRL_EN_BIT\t\t0  \n#define CTRL_WT_BIT\t\t2  \n#define CTRL_PG_BIT\t\t4  \n#define CTRL_TO_BIT\t\t7  \n\n#define MAX_OVERCURRENT_WAIT\t3  \n\n \n\nstruct tps65090_regulator {\n\tstruct device\t\t*dev;\n\tstruct regulator_desc\t*desc;\n\tstruct regulator_dev\t*rdev;\n\tbool\t\t\tovercurrent_wait_valid;\n\tint\t\t\tovercurrent_wait;\n};\n\nstatic const struct regulator_ops tps65090_ext_control_ops = {\n};\n\n \nstatic int tps65090_reg_set_overcurrent_wait(struct tps65090_regulator *ri,\n\t\t\t\t\t     struct regulator_dev *rdev)\n{\n\tint ret;\n\n\tret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\n\t\t\t\t MAX_OVERCURRENT_WAIT << CTRL_WT_BIT,\n\t\t\t\t ri->overcurrent_wait << CTRL_WT_BIT);\n\tif (ret) {\n\t\tdev_err(&rdev->dev, \"Error updating overcurrent wait %#x\\n\",\n\t\t\trdev->desc->enable_reg);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int tps65090_try_enable_fet(struct regulator_dev *rdev)\n{\n\tunsigned int control;\n\tint ret, i;\n\n\tret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\n\t\t\t\t rdev->desc->enable_mask,\n\t\t\t\t rdev->desc->enable_mask);\n\tif (ret < 0) {\n\t\tdev_err(&rdev->dev, \"Error in updating reg %#x\\n\",\n\t\t\trdev->desc->enable_reg);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < MAX_CTRL_READ_TRIES; i++) {\n\t\tret = regmap_read(rdev->regmap, rdev->desc->enable_reg,\n\t\t\t\t  &control);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(control & BIT(CTRL_TO_BIT)))\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 1500);\n\t}\n\tif (!(control & BIT(CTRL_PG_BIT)))\n\t\treturn -ENOTRECOVERABLE;\n\n\treturn 0;\n}\n\n \nstatic int tps65090_fet_enable(struct regulator_dev *rdev)\n{\n\tint ret, tries;\n\n\t \n\ttries = 0;\n\twhile (true) {\n\t\tret = tps65090_try_enable_fet(rdev);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tif (ret != -ENOTRECOVERABLE || tries == MAX_FET_ENABLE_TRIES)\n\t\t\tgoto err;\n\n\t\t \n\t\tret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\n\t\t\t\t\t rdev->desc->enable_mask, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\ttries++;\n\t}\n\n\tif (tries)\n\t\tdev_warn(&rdev->dev, \"reg %#x enable ok after %d tries\\n\",\n\t\t\t rdev->desc->enable_reg, tries);\n\n\treturn 0;\nerr:\n\tdev_warn(&rdev->dev, \"reg %#x enable failed\\n\", rdev->desc->enable_reg);\n\tWARN_ON(1);\n\n\treturn ret;\n}\n\nstatic const struct regulator_ops tps65090_reg_control_ops = {\n\t.enable\t\t= regulator_enable_regmap,\n\t.disable\t= regulator_disable_regmap,\n\t.is_enabled\t= regulator_is_enabled_regmap,\n};\n\nstatic const struct regulator_ops tps65090_fet_control_ops = {\n\t.enable\t\t= tps65090_fet_enable,\n\t.disable\t= regulator_disable_regmap,\n\t.is_enabled\t= regulator_is_enabled_regmap,\n};\n\nstatic const struct regulator_ops tps65090_ldo_ops = {\n};\n\n#define tps65090_REG_DESC(_id, _sname, _en_reg, _en_bits, _nvolt, _volt, _ops) \\\n{\t\t\t\t\t\t\t\\\n\t.name = \"TPS65090_RAILS\"#_id,\t\t\t\\\n\t.supply_name = _sname,\t\t\t\t\\\n\t.id = TPS65090_REGULATOR_##_id,\t\t\t\\\n\t.n_voltages = _nvolt,\t\t\t\t\\\n\t.ops = &_ops,\t\t\t\t\t\\\n\t.fixed_uV = _volt,\t\t\t\t\\\n\t.enable_reg = _en_reg,\t\t\t\t\\\n\t.enable_val = _en_bits,\t\t\t\t\\\n\t.enable_mask = _en_bits,\t\t\t\\\n\t.type = REGULATOR_VOLTAGE,\t\t\t\\\n\t.owner = THIS_MODULE,\t\t\t\t\\\n}\n\n#define tps65090_REG_FIXEDV(_id, _sname, en_reg, _en_bits, _volt, _ops) \\\n\ttps65090_REG_DESC(_id, _sname, en_reg, _en_bits, 1, _volt, _ops)\n\n#define tps65090_REG_SWITCH(_id, _sname, en_reg, _en_bits, _ops) \\\n\ttps65090_REG_DESC(_id, _sname, en_reg, _en_bits, 0, 0, _ops)\n\nstatic struct regulator_desc tps65090_regulator_desc[] = {\n\ttps65090_REG_FIXEDV(DCDC1, \"vsys1\",   0x0C, BIT(CTRL_EN_BIT), 5000000,\n\t\t\t    tps65090_reg_control_ops),\n\ttps65090_REG_FIXEDV(DCDC2, \"vsys2\",   0x0D, BIT(CTRL_EN_BIT), 3300000,\n\t\t\t    tps65090_reg_control_ops),\n\ttps65090_REG_SWITCH(DCDC3, \"vsys3\",   0x0E, BIT(CTRL_EN_BIT),\n\t\t\t    tps65090_reg_control_ops),\n\n\ttps65090_REG_SWITCH(FET1,  \"infet1\",  0x0F,\n\t\t\t    BIT(CTRL_EN_BIT) | BIT(CTRL_PG_BIT),\n\t\t\t    tps65090_fet_control_ops),\n\ttps65090_REG_SWITCH(FET2,  \"infet2\",  0x10,\n\t\t\t    BIT(CTRL_EN_BIT) | BIT(CTRL_PG_BIT),\n\t\t\t    tps65090_fet_control_ops),\n\ttps65090_REG_SWITCH(FET3,  \"infet3\",  0x11,\n\t\t\t    BIT(CTRL_EN_BIT) | BIT(CTRL_PG_BIT),\n\t\t\t    tps65090_fet_control_ops),\n\ttps65090_REG_SWITCH(FET4,  \"infet4\",  0x12,\n\t\t\t    BIT(CTRL_EN_BIT) | BIT(CTRL_PG_BIT),\n\t\t\t    tps65090_fet_control_ops),\n\ttps65090_REG_SWITCH(FET5,  \"infet5\",  0x13,\n\t\t\t    BIT(CTRL_EN_BIT) | BIT(CTRL_PG_BIT),\n\t\t\t    tps65090_fet_control_ops),\n\ttps65090_REG_SWITCH(FET6,  \"infet6\",  0x14,\n\t\t\t    BIT(CTRL_EN_BIT) | BIT(CTRL_PG_BIT),\n\t\t\t    tps65090_fet_control_ops),\n\ttps65090_REG_SWITCH(FET7,  \"infet7\",  0x15,\n\t\t\t    BIT(CTRL_EN_BIT) | BIT(CTRL_PG_BIT),\n\t\t\t    tps65090_fet_control_ops),\n\n\ttps65090_REG_FIXEDV(LDO1,  \"vsys-l1\", 0, 0, 5000000,\n\t\t\t    tps65090_ldo_ops),\n\ttps65090_REG_FIXEDV(LDO2,  \"vsys-l2\", 0, 0, 3300000,\n\t\t\t    tps65090_ldo_ops),\n};\n\nstatic inline bool is_dcdc(int id)\n{\n\tswitch (id) {\n\tcase TPS65090_REGULATOR_DCDC1:\n\tcase TPS65090_REGULATOR_DCDC2:\n\tcase TPS65090_REGULATOR_DCDC3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int tps65090_config_ext_control(\n\tstruct tps65090_regulator *ri, bool enable)\n{\n\tint ret;\n\tstruct device *parent = ri->dev->parent;\n\tunsigned int reg_en_reg = ri->desc->enable_reg;\n\n\tif (enable)\n\t\tret = tps65090_set_bits(parent, reg_en_reg, 1);\n\telse\n\t\tret =  tps65090_clr_bits(parent, reg_en_reg, 1);\n\tif (ret < 0)\n\t\tdev_err(ri->dev, \"Error in updating reg 0x%x\\n\", reg_en_reg);\n\treturn ret;\n}\n\nstatic int tps65090_regulator_disable_ext_control(\n\t\tstruct tps65090_regulator *ri,\n\t\tstruct tps65090_regulator_plat_data *tps_pdata)\n{\n\tint ret = 0;\n\tstruct device *parent = ri->dev->parent;\n\tunsigned int reg_en_reg = ri->desc->enable_reg;\n\n\t \n\tif (tps_pdata->reg_init_data->constraints.always_on ||\n\t\t\ttps_pdata->reg_init_data->constraints.boot_on) {\n\t\tret =  tps65090_set_bits(parent, reg_en_reg, 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ri->dev, \"Error in set reg 0x%x\\n\", reg_en_reg);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn tps65090_config_ext_control(ri, false);\n}\n\n#ifdef CONFIG_OF\nstatic struct of_regulator_match tps65090_matches[] = {\n\t{ .name = \"dcdc1\", },\n\t{ .name = \"dcdc2\", },\n\t{ .name = \"dcdc3\", },\n\t{ .name = \"fet1\",  },\n\t{ .name = \"fet2\",  },\n\t{ .name = \"fet3\",  },\n\t{ .name = \"fet4\",  },\n\t{ .name = \"fet5\",  },\n\t{ .name = \"fet6\",  },\n\t{ .name = \"fet7\",  },\n\t{ .name = \"ldo1\",  },\n\t{ .name = \"ldo2\",  },\n};\n\nstatic struct tps65090_platform_data *tps65090_parse_dt_reg_data(\n\t\tstruct platform_device *pdev,\n\t\tstruct of_regulator_match **tps65090_reg_matches)\n{\n\tstruct tps65090_platform_data *tps65090_pdata;\n\tstruct device_node *np = pdev->dev.parent->of_node;\n\tstruct device_node *regulators;\n\tint idx = 0, ret;\n\tstruct tps65090_regulator_plat_data *reg_pdata;\n\n\ttps65090_pdata = devm_kzalloc(&pdev->dev, sizeof(*tps65090_pdata),\n\t\t\t\tGFP_KERNEL);\n\tif (!tps65090_pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treg_pdata = devm_kcalloc(&pdev->dev,\n\t\t\t\t TPS65090_REGULATOR_MAX, sizeof(*reg_pdata),\n\t\t\t\t GFP_KERNEL);\n\tif (!reg_pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tregulators = of_get_child_by_name(np, \"regulators\");\n\tif (!regulators) {\n\t\tdev_err(&pdev->dev, \"regulator node not found\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tret = of_regulator_match(&pdev->dev, regulators, tps65090_matches,\n\t\t\tARRAY_SIZE(tps65090_matches));\n\tof_node_put(regulators);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Error parsing regulator init data: %d\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t*tps65090_reg_matches = tps65090_matches;\n\tfor (idx = 0; idx < ARRAY_SIZE(tps65090_matches); idx++) {\n\t\tstruct regulator_init_data *ri_data;\n\t\tstruct tps65090_regulator_plat_data *rpdata;\n\t\tstruct device_node *np;\n\n\t\trpdata = &reg_pdata[idx];\n\t\tri_data = tps65090_matches[idx].init_data;\n\t\tif (!ri_data)\n\t\t\tcontinue;\n\n\t\tnp = tps65090_matches[idx].of_node;\n\t\tif (!np)\n\t\t\tcontinue;\n\n\t\trpdata->reg_init_data = ri_data;\n\t\trpdata->enable_ext_control = of_property_read_bool(np,\n\t\t\t\t\t\t\"ti,enable-ext-control\");\n\t\tif (rpdata->enable_ext_control) {\n\t\t\tenum gpiod_flags gflags;\n\n\t\t\tif (ri_data->constraints.always_on ||\n\t\t\t    ri_data->constraints.boot_on)\n\t\t\t\tgflags = GPIOD_OUT_HIGH;\n\t\t\telse\n\t\t\t\tgflags = GPIOD_OUT_LOW;\n\t\t\tgflags |= GPIOD_FLAGS_BIT_NONEXCLUSIVE;\n\n\t\t\trpdata->gpiod = devm_fwnode_gpiod_get(\n\t\t\t\t\t\t\t&pdev->dev,\n\t\t\t\t\t\t\tof_fwnode_handle(np),\n\t\t\t\t\t\t\t\"dcdc-ext-control\",\n\t\t\t\t\t\t\tgflags,\n\t\t\t\t\t\t\t\"tps65090\");\n\t\t\tif (PTR_ERR(rpdata->gpiod) == -ENOENT) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"could not find DCDC external control GPIO\\n\");\n\t\t\t\trpdata->gpiod = NULL;\n\t\t\t} else if (IS_ERR(rpdata->gpiod))\n\t\t\t\treturn ERR_CAST(rpdata->gpiod);\n\t\t}\n\n\t\tif (of_property_read_u32(np, \"ti,overcurrent-wait\",\n\t\t\t\t\t &rpdata->overcurrent_wait) == 0)\n\t\t\trpdata->overcurrent_wait_valid = true;\n\n\t\ttps65090_pdata->reg_pdata[idx] = rpdata;\n\t}\n\treturn tps65090_pdata;\n}\n#else\nstatic inline struct tps65090_platform_data *tps65090_parse_dt_reg_data(\n\t\t\tstruct platform_device *pdev,\n\t\t\tstruct of_regulator_match **tps65090_reg_matches)\n{\n\t*tps65090_reg_matches = NULL;\n\treturn NULL;\n}\n#endif\n\nstatic int tps65090_regulator_probe(struct platform_device *pdev)\n{\n\tstruct tps65090 *tps65090_mfd = dev_get_drvdata(pdev->dev.parent);\n\tstruct tps65090_regulator *ri = NULL;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tstruct tps65090_regulator_plat_data *tps_pdata;\n\tstruct tps65090_regulator *pmic;\n\tstruct tps65090_platform_data *tps65090_pdata;\n\tstruct of_regulator_match *tps65090_reg_matches = NULL;\n\tint num;\n\tint ret;\n\n\tdev_dbg(&pdev->dev, \"Probing regulator\\n\");\n\n\ttps65090_pdata = dev_get_platdata(pdev->dev.parent);\n\tif (!tps65090_pdata && tps65090_mfd->dev->of_node)\n\t\ttps65090_pdata = tps65090_parse_dt_reg_data(pdev,\n\t\t\t\t\t&tps65090_reg_matches);\n\tif (IS_ERR_OR_NULL(tps65090_pdata)) {\n\t\tdev_err(&pdev->dev, \"Platform data missing\\n\");\n\t\treturn tps65090_pdata ? PTR_ERR(tps65090_pdata) : -EINVAL;\n\t}\n\n\tpmic = devm_kcalloc(&pdev->dev,\n\t\t\t    TPS65090_REGULATOR_MAX, sizeof(*pmic),\n\t\t\t    GFP_KERNEL);\n\tif (!pmic)\n\t\treturn -ENOMEM;\n\n\tfor (num = 0; num < TPS65090_REGULATOR_MAX; num++) {\n\t\ttps_pdata = tps65090_pdata->reg_pdata[num];\n\n\t\tri = &pmic[num];\n\t\tri->dev = &pdev->dev;\n\t\tri->desc = &tps65090_regulator_desc[num];\n\t\tif (tps_pdata) {\n\t\t\tri->overcurrent_wait_valid =\n\t\t\t\ttps_pdata->overcurrent_wait_valid;\n\t\t\tri->overcurrent_wait = tps_pdata->overcurrent_wait;\n\t\t}\n\n\t\t \n\t\tif (tps_pdata && is_dcdc(num) && tps_pdata->reg_init_data) {\n\t\t\tif (tps_pdata->enable_ext_control) {\n\t\t\t\tconfig.ena_gpiod = tps_pdata->gpiod;\n\t\t\t\tri->desc->ops = &tps65090_ext_control_ops;\n\t\t\t} else {\n\t\t\t\tret = tps65090_regulator_disable_ext_control(\n\t\t\t\t\t\tri, tps_pdata);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\t\"failed disable ext control\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconfig.dev = pdev->dev.parent;\n\t\tconfig.driver_data = ri;\n\t\tconfig.regmap = tps65090_mfd->rmap;\n\t\tif (tps_pdata)\n\t\t\tconfig.init_data = tps_pdata->reg_init_data;\n\t\telse\n\t\t\tconfig.init_data = NULL;\n\t\tif (tps65090_reg_matches)\n\t\t\tconfig.of_node = tps65090_reg_matches[num].of_node;\n\t\telse\n\t\t\tconfig.of_node = NULL;\n\n\t\t \n\t\tif (config.ena_gpiod)\n\t\t\tdevm_gpiod_unhinge(&pdev->dev, config.ena_gpiod);\n\t\trdev = devm_regulator_register(&pdev->dev, ri->desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&pdev->dev, \"failed to register regulator %s\\n\",\n\t\t\t\tri->desc->name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\tri->rdev = rdev;\n\n\t\tif (ri->overcurrent_wait_valid) {\n\t\t\tret = tps65090_reg_set_overcurrent_wait(ri, rdev);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (tps_pdata && is_dcdc(num) && tps_pdata->reg_init_data &&\n\t\t\t\ttps_pdata->enable_ext_control) {\n\t\t\tret = tps65090_config_ext_control(ri, true);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, pmic);\n\treturn 0;\n}\n\nstatic struct platform_driver tps65090_regulator_driver = {\n\t.driver\t= {\n\t\t.name\t= \"tps65090-pmic\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t\t= tps65090_regulator_probe,\n};\n\nstatic int __init tps65090_regulator_init(void)\n{\n\treturn platform_driver_register(&tps65090_regulator_driver);\n}\nsubsys_initcall(tps65090_regulator_init);\n\nstatic void __exit tps65090_regulator_exit(void)\n{\n\tplatform_driver_unregister(&tps65090_regulator_driver);\n}\nmodule_exit(tps65090_regulator_exit);\n\nMODULE_DESCRIPTION(\"tps65090 regulator driver\");\nMODULE_AUTHOR(\"Venu Byravarasu <vbyravarasu@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:tps65090-pmic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}