{
  "module_name": "max5970-regulator.c",
  "hash_id": "8620259abfed272f58eacd866bd7ad5fb126567d7382c02ab497b32ee72cdbe1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/max5970-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/platform_device.h>\n\n#include <linux/mfd/max5970.h>\n\nstruct max5970_regulator {\n\tint num_switches, mon_rng, irng, shunt_micro_ohms, lim_uA;\n\tstruct regmap *regmap;\n};\n\nenum max597x_regulator_id {\n\tMAX597X_SW0,\n\tMAX597X_SW1,\n};\n\nstatic int max597x_uvp_ovp_check_mode(struct regulator_dev *rdev, int severity)\n{\n\tint ret, reg;\n\n\t \n\tret = regmap_read(rdev->regmap, MAX5970_REG_STATUS1, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (severity == REGULATOR_SEVERITY_PROT) {\n\t\tif (STATUS1_PROT(reg) != STATUS1_PROT_SHUTDOWN)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn 0;\n\t}\n\tif (STATUS1_PROT(reg) == STATUS1_PROT_SHUTDOWN)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int max597x_set_vp(struct regulator_dev *rdev, int lim_uV, int severity,\n\t\t\t  bool enable, bool overvoltage)\n{\n\tint off_h, off_l, reg, ret;\n\tstruct max5970_regulator *data = rdev_get_drvdata(rdev);\n\tint channel = rdev_get_id(rdev);\n\n\tif (overvoltage) {\n\t\tif (severity == REGULATOR_SEVERITY_WARN) {\n\t\t\toff_h = MAX5970_REG_CH_OV_WARN_H(channel);\n\t\t\toff_l = MAX5970_REG_CH_OV_WARN_L(channel);\n\t\t} else {\n\t\t\toff_h = MAX5970_REG_CH_OV_CRIT_H(channel);\n\t\t\toff_l = MAX5970_REG_CH_OV_CRIT_L(channel);\n\t\t}\n\t} else {\n\t\tif (severity == REGULATOR_SEVERITY_WARN) {\n\t\t\toff_h = MAX5970_REG_CH_UV_WARN_H(channel);\n\t\t\toff_l = MAX5970_REG_CH_UV_WARN_L(channel);\n\t\t} else {\n\t\t\toff_h = MAX5970_REG_CH_UV_CRIT_H(channel);\n\t\t\toff_l = MAX5970_REG_CH_UV_CRIT_L(channel);\n\t\t}\n\t}\n\n\tif (enable)\n\t\t \n\t\treg = ADC_MASK * lim_uV / data->mon_rng;\n\telse\n\t\treg = 0;\n\n\tret = regmap_write(rdev->regmap, off_h, MAX5970_VAL2REG_H(reg));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(rdev->regmap, off_l, MAX5970_VAL2REG_L(reg));\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int max597x_set_uvp(struct regulator_dev *rdev, int lim_uV, int severity,\n\t\t\t   bool enable)\n{\n\tint ret;\n\n\t \n\tif ((lim_uV && !enable) || (!lim_uV && enable))\n\t\treturn -EINVAL;\n\n\tret = max597x_uvp_ovp_check_mode(rdev, severity);\n\tif (ret)\n\t\treturn ret;\n\n\treturn max597x_set_vp(rdev, lim_uV, severity, enable, false);\n}\n\nstatic int max597x_set_ovp(struct regulator_dev *rdev, int lim_uV, int severity,\n\t\t\t   bool enable)\n{\n\tint ret;\n\n\t \n\tif ((lim_uV && !enable) || (!lim_uV && enable))\n\t\treturn -EINVAL;\n\n\tret = max597x_uvp_ovp_check_mode(rdev, severity);\n\tif (ret)\n\t\treturn ret;\n\n\treturn max597x_set_vp(rdev, lim_uV, severity, enable, true);\n}\n\nstatic int max597x_set_ocp(struct regulator_dev *rdev, int lim_uA,\n\t\t\t   int severity, bool enable)\n{\n\tint val, reg;\n\tunsigned int vthst, vthfst;\n\n\tstruct max5970_regulator *data = rdev_get_drvdata(rdev);\n\tint rdev_id = rdev_get_id(rdev);\n\t \n\tif (lim_uA != 0 && lim_uA != data->lim_uA)\n\t\tdata->lim_uA = lim_uA;\n\n\tif (severity != REGULATOR_SEVERITY_PROT)\n\t\treturn -EINVAL;\n\n\tif (enable) {\n\n\t\t \n\t\tvthst =\n\t\t    div_u64(mul_u32_u32(data->shunt_micro_ohms, data->lim_uA),\n\t\t\t    1000000);\n\n\t\t \n\t\tvthst = div_u64(mul_u32_u32(vthst, 120), 100);\n\n\t\t \n\t\tvthfst = vthst * (MAX5970_FAST2SLOW_RATIO / 100);\n\n\t\tif (vthfst > data->irng) {\n\t\t\tdev_err(&rdev->dev, \"Current limit out of range\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tval = div_u64(mul_u32_u32(0xFF, vthfst), data->irng);\n\t} else\n\t\t \n\t\tval = 0xFF;\n\n\treg = MAX5970_REG_DAC_FAST(rdev_id);\n\n\treturn regmap_write(rdev->regmap, reg, val);\n}\n\nstatic int max597x_get_status(struct regulator_dev *rdev)\n{\n\tint val, ret;\n\n\tret = regmap_read(rdev->regmap, MAX5970_REG_STATUS3, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & MAX5970_STATUS3_ALERT)\n\t\treturn REGULATOR_STATUS_ERROR;\n\n\tret = regulator_is_enabled_regmap(rdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret)\n\t\treturn REGULATOR_STATUS_ON;\n\n\treturn REGULATOR_STATUS_OFF;\n}\n\nstatic const struct regulator_ops max597x_switch_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.get_status = max597x_get_status,\n\t.set_over_voltage_protection = max597x_set_ovp,\n\t.set_under_voltage_protection = max597x_set_uvp,\n\t.set_over_current_protection = max597x_set_ocp,\n};\n\nstatic int max597x_dt_parse(struct device_node *np,\n\t\t\t    const struct regulator_desc *desc,\n\t\t\t    struct regulator_config *cfg)\n{\n\tstruct max5970_regulator *data = cfg->driver_data;\n\tint ret = 0;\n\n\tret =\n\t    of_property_read_u32(np, \"shunt-resistor-micro-ohms\",\n\t\t\t\t &data->shunt_micro_ohms);\n\tif (ret < 0)\n\t\tdev_err(cfg->dev,\n\t\t\t\"property 'shunt-resistor-micro-ohms' not found, err %d\\n\",\n\t\t\tret);\n\treturn ret;\n\n}\n\n#define MAX597X_SWITCH(_ID, _ereg, _chan, _supply) {     \\\n\t.name            = #_ID,                         \\\n\t.of_match        = of_match_ptr(#_ID),           \\\n\t.ops             = &max597x_switch_ops,          \\\n\t.regulators_node = of_match_ptr(\"regulators\"),   \\\n\t.type            = REGULATOR_VOLTAGE,            \\\n\t.id              = MAX597X_##_ID,                \\\n\t.owner           = THIS_MODULE,                  \\\n\t.supply_name     = _supply,                      \\\n\t.enable_reg      = _ereg,                        \\\n\t.enable_mask     = CHXEN((_chan)),               \\\n\t.of_parse_cb\t = max597x_dt_parse,\t\t \\\n}\n\nstatic const struct regulator_desc regulators[] = {\n\tMAX597X_SWITCH(SW0, MAX5970_REG_CHXEN, 0, \"vss1\"),\n\tMAX597X_SWITCH(SW1, MAX5970_REG_CHXEN, 1, \"vss2\"),\n};\n\nstatic int max597x_regmap_read_clear(struct regmap *map, unsigned int reg,\n\t\t\t\t     unsigned int *val)\n{\n\tint ret;\n\n\tret = regmap_read(map, reg, val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (*val)\n\t\treturn regmap_write(map, reg, *val);\n\n\treturn 0;\n}\n\nstatic int max597x_irq_handler(int irq, struct regulator_irq_data *rid,\n\t\t\t       unsigned long *dev_mask)\n{\n\tstruct regulator_err_state *stat;\n\tstruct max5970_regulator *d = (struct max5970_regulator *)rid->data;\n\tint val, ret, i;\n\n\tret = max597x_regmap_read_clear(d->regmap, MAX5970_REG_FAULT0, &val);\n\tif (ret)\n\t\treturn REGULATOR_FAILED_RETRY;\n\n\t*dev_mask = 0;\n\tfor (i = 0; i < d->num_switches; i++) {\n\t\tstat = &rid->states[i];\n\t\tstat->notifs = 0;\n\t\tstat->errors = 0;\n\t}\n\n\tfor (i = 0; i < d->num_switches; i++) {\n\t\tstat = &rid->states[i];\n\n\t\tif (val & UV_STATUS_CRIT(i)) {\n\t\t\t*dev_mask |= 1 << i;\n\t\t\tstat->notifs |= REGULATOR_EVENT_UNDER_VOLTAGE;\n\t\t\tstat->errors |= REGULATOR_ERROR_UNDER_VOLTAGE;\n\t\t} else if (val & UV_STATUS_WARN(i)) {\n\t\t\t*dev_mask |= 1 << i;\n\t\t\tstat->notifs |= REGULATOR_EVENT_UNDER_VOLTAGE_WARN;\n\t\t\tstat->errors |= REGULATOR_ERROR_UNDER_VOLTAGE_WARN;\n\t\t}\n\t}\n\n\tret = max597x_regmap_read_clear(d->regmap, MAX5970_REG_FAULT1, &val);\n\tif (ret)\n\t\treturn REGULATOR_FAILED_RETRY;\n\n\tfor (i = 0; i < d->num_switches; i++) {\n\t\tstat = &rid->states[i];\n\n\t\tif (val & OV_STATUS_CRIT(i)) {\n\t\t\t*dev_mask |= 1 << i;\n\t\t\tstat->notifs |= REGULATOR_EVENT_REGULATION_OUT;\n\t\t\tstat->errors |= REGULATOR_ERROR_REGULATION_OUT;\n\t\t} else if (val & OV_STATUS_WARN(i)) {\n\t\t\t*dev_mask |= 1 << i;\n\t\t\tstat->notifs |= REGULATOR_EVENT_OVER_VOLTAGE_WARN;\n\t\t\tstat->errors |= REGULATOR_ERROR_OVER_VOLTAGE_WARN;\n\t\t}\n\t}\n\n\tret = max597x_regmap_read_clear(d->regmap, MAX5970_REG_FAULT2, &val);\n\tif (ret)\n\t\treturn REGULATOR_FAILED_RETRY;\n\n\tfor (i = 0; i < d->num_switches; i++) {\n\t\tstat = &rid->states[i];\n\n\t\tif (val & OC_STATUS_WARN(i)) {\n\t\t\t*dev_mask |= 1 << i;\n\t\t\tstat->notifs |= REGULATOR_EVENT_OVER_CURRENT_WARN;\n\t\t\tstat->errors |= REGULATOR_ERROR_OVER_CURRENT_WARN;\n\t\t}\n\t}\n\n\tret = regmap_read(d->regmap, MAX5970_REG_STATUS0, &val);\n\tif (ret)\n\t\treturn REGULATOR_FAILED_RETRY;\n\n\tfor (i = 0; i < d->num_switches; i++) {\n\t\tstat = &rid->states[i];\n\n\t\tif ((val & MAX5970_CB_IFAULTF(i))\n\t\t    || (val & MAX5970_CB_IFAULTS(i))) {\n\t\t\t*dev_mask |= 1 << i;\n\t\t\tstat->notifs |=\n\t\t\t    REGULATOR_EVENT_OVER_CURRENT |\n\t\t\t    REGULATOR_EVENT_DISABLE;\n\t\t\tstat->errors |=\n\t\t\t    REGULATOR_ERROR_OVER_CURRENT | REGULATOR_ERROR_FAIL;\n\n\t\t\t \n\t\t\tregulator_disable_regmap(stat->rdev);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int max597x_adc_range(struct regmap *regmap, const int ch,\n\t\t\t     u32 *irng, u32 *mon_rng)\n{\n\tunsigned int reg;\n\tint ret;\n\n\t \n\tret = regmap_read(regmap, MAX5970_REG_STATUS2, &reg);\n\tif (ret)\n\t\treturn ret;\n\tswitch (MAX5970_IRNG(reg, ch)) {\n\tcase 0:\n\t\t*irng = 100000;\t \n\t\tbreak;\n\tcase 1:\n\t\t*irng = 50000;\t \n\t\tbreak;\n\tcase 2:\n\t\t*irng = 25000;\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_read(regmap, MAX5970_REG_MON_RANGE, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\t*mon_rng = MAX5970_MON_MAX_RANGE_UV >> MAX5970_MON(reg, ch);\n\n\treturn 0;\n}\n\nstatic int max597x_setup_irq(struct device *dev,\n\t\t\t     int irq,\n\t\t\t     struct regulator_dev *rdevs[MAX5970_NUM_SWITCHES],\n\t\t\t     int num_switches, struct max5970_regulator *data)\n{\n\tstruct regulator_irq_desc max597x_notif = {\n\t\t.name = \"max597x-irq\",\n\t\t.map_event = max597x_irq_handler,\n\t\t.data = data,\n\t};\n\tint errs = REGULATOR_ERROR_UNDER_VOLTAGE |\n\t    REGULATOR_ERROR_UNDER_VOLTAGE_WARN |\n\t    REGULATOR_ERROR_OVER_VOLTAGE_WARN |\n\t    REGULATOR_ERROR_REGULATION_OUT |\n\t    REGULATOR_ERROR_OVER_CURRENT |\n\t    REGULATOR_ERROR_OVER_CURRENT_WARN | REGULATOR_ERROR_FAIL;\n\tvoid *irq_helper;\n\n\t \n\tirq_helper = devm_regulator_irq_helper(dev, &max597x_notif,\n\t\t\t\t\t       irq, 0, errs, NULL,\n\t\t\t\t\t       &rdevs[0], num_switches);\n\tif (IS_ERR(irq_helper)) {\n\t\tif (PTR_ERR(irq_helper) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tdev_warn(dev, \"IRQ disabled %pe\\n\", irq_helper);\n\t}\n\n\treturn 0;\n}\n\nstatic int max597x_regulator_probe(struct platform_device *pdev)\n{\n\tstruct max5970_data *max597x;\n\tstruct regmap *regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tstruct max5970_regulator *data;\n\tstruct i2c_client *i2c = to_i2c_client(pdev->dev.parent);\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tstruct regulator_dev *rdevs[MAX5970_NUM_SWITCHES];\n\tint num_switches;\n\tint ret, i;\n\n\tif (!regmap)\n\t\treturn -EPROBE_DEFER;\n\n\tmax597x = devm_kzalloc(&i2c->dev, sizeof(struct max5970_data), GFP_KERNEL);\n\tif (!max597x)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, max597x);\n\n\tif (of_device_is_compatible(i2c->dev.of_node, \"maxim,max5978\"))\n\t\tmax597x->num_switches = MAX5978_NUM_SWITCHES;\n\telse if (of_device_is_compatible(i2c->dev.of_node, \"maxim,max5970\"))\n\t\tmax597x->num_switches = MAX5970_NUM_SWITCHES;\n\telse\n\t\treturn -ENODEV;\n\n\ti2c_set_clientdata(i2c, max597x);\n\tnum_switches = max597x->num_switches;\n\n\tfor (i = 0; i < num_switches; i++) {\n\t\tdata =\n\t\t    devm_kzalloc(&i2c->dev, sizeof(struct max5970_regulator),\n\t\t\t\t GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tdata->num_switches = num_switches;\n\t\tdata->regmap = regmap;\n\n\t\tret = max597x_adc_range(regmap, i, &max597x->irng[i], &max597x->mon_rng[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdata->irng = max597x->irng[i];\n\t\tdata->mon_rng = max597x->mon_rng[i];\n\n\t\tconfig.dev = &i2c->dev;\n\t\tconfig.driver_data = (void *)data;\n\t\tconfig.regmap = data->regmap;\n\t\trdev = devm_regulator_register(&i2c->dev,\n\t\t\t\t\t       &regulators[i], &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&i2c->dev, \"failed to register regulator %s\\n\",\n\t\t\t\tregulators[i].name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\trdevs[i] = rdev;\n\t\tmax597x->shunt_micro_ohms[i] = data->shunt_micro_ohms;\n\t}\n\n\tif (i2c->irq) {\n\t\tret =\n\t\t    max597x_setup_irq(&i2c->dev, i2c->irq, rdevs, num_switches,\n\t\t\t\t      data);\n\t\tif (ret) {\n\t\t\tdev_err(&i2c->dev, \"IRQ setup failed\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic struct platform_driver max597x_regulator_driver = {\n\t.driver = {\n\t\t.name = \"max5970-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = max597x_regulator_probe,\n};\n\nmodule_platform_driver(max597x_regulator_driver);\n\n\nMODULE_AUTHOR(\"Patrick Rudolph <patrick.rudolph@9elements.com>\");\nMODULE_DESCRIPTION(\"MAX5970_hot-swap controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}