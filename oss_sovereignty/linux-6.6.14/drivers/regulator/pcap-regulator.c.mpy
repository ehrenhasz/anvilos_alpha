{
  "module_name": "pcap-regulator.c",
  "hash_id": "8deac6c487ade3d9af7fda5eaa9e94d7d5775e469322ddb0290736bd3b6dbf50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/pcap-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/mfd/ezx-pcap.h>\n\nstatic const unsigned int V1_table[] = {\n\t2775000, 1275000, 1600000, 1725000, 1825000, 1925000, 2075000, 2275000,\n};\n\nstatic const unsigned int V2_table[] = {\n\t2500000, 2775000,\n};\n\nstatic const unsigned int V3_table[] = {\n\t1075000, 1275000, 1550000, 1725000, 1876000, 1950000, 2075000, 2275000,\n};\n\nstatic const unsigned int V4_table[] = {\n\t1275000, 1550000, 1725000, 1875000, 1950000, 2075000, 2275000, 2775000,\n};\n\nstatic const unsigned int V5_table[] = {\n\t1875000, 2275000, 2475000, 2775000,\n};\n\nstatic const unsigned int V6_table[] = {\n\t2475000, 2775000,\n};\n\nstatic const unsigned int V7_table[] = {\n\t1875000, 2775000,\n};\n\n#define V8_table V4_table\n\nstatic const unsigned int V9_table[] = {\n\t1575000, 1875000, 2475000, 2775000,\n};\n\nstatic const unsigned int V10_table[] = {\n\t5000000,\n};\n\nstatic const unsigned int VAUX1_table[] = {\n\t1875000, 2475000, 2775000, 3000000,\n};\n\n#define VAUX2_table VAUX1_table\n\nstatic const unsigned int VAUX3_table[] = {\n\t1200000, 1200000, 1200000, 1200000, 1400000, 1600000, 1800000, 2000000,\n\t2200000, 2400000, 2600000, 2800000, 3000000, 3200000, 3400000, 3600000,\n};\n\nstatic const unsigned int VAUX4_table[] = {\n\t1800000, 1800000, 3000000, 5000000,\n};\n\nstatic const unsigned int VSIM_table[] = {\n\t1875000, 3000000,\n};\n\nstatic const unsigned int VSIM2_table[] = {\n\t1875000,\n};\n\nstatic const unsigned int VVIB_table[] = {\n\t1300000, 1800000, 2000000, 3000000,\n};\n\nstatic const unsigned int SW1_table[] = {\n\t 900000,  950000, 1000000, 1050000, 1100000, 1150000, 1200000, 1250000,\n\t1300000, 1350000, 1400000, 1450000, 1500000, 1600000, 1875000, 2250000,\n};\n\n#define SW2_table SW1_table\n\nstruct pcap_regulator {\n\tconst u8 reg;\n\tconst u8 en;\n\tconst u8 index;\n\tconst u8 stby;\n\tconst u8 lowpwr;\n};\n\n#define NA 0xff\n\n#define VREG_INFO(_vreg, _reg, _en, _index, _stby, _lowpwr)\t\t\\\n\t[_vreg]\t= {\t\t\t\t\t\t\t\\\n\t\t.reg\t\t= _reg,\t\t\t\t\t\\\n\t\t.en\t\t= _en,\t\t\t\t\t\\\n\t\t.index\t\t= _index,\t\t\t\t\\\n\t\t.stby\t\t= _stby,\t\t\t\t\\\n\t\t.lowpwr\t\t= _lowpwr,\t\t\t\t\\\n\t}\n\nstatic struct pcap_regulator vreg_table[] = {\n\tVREG_INFO(V1,    PCAP_REG_VREG1,   1,  2,  18, 0),\n\tVREG_INFO(V2,    PCAP_REG_VREG1,   5,  6,  19, 22),\n\tVREG_INFO(V3,    PCAP_REG_VREG1,   7,  8,  20, 23),\n\tVREG_INFO(V4,    PCAP_REG_VREG1,   11, 12, 21, 24),\n\t \n\tVREG_INFO(V5,    PCAP_REG_VREG1,   15, 16, 12, 19),\n\n\tVREG_INFO(V6,    PCAP_REG_VREG2,   1,  2,  14, 20),\n\tVREG_INFO(V7,    PCAP_REG_VREG2,   3,  4,  15, 21),\n\tVREG_INFO(V8,    PCAP_REG_VREG2,   5,  6,  16, 22),\n\tVREG_INFO(V9,    PCAP_REG_VREG2,   9,  10, 17, 23),\n\tVREG_INFO(V10,   PCAP_REG_VREG2,   10, NA, 18, 24),\n\n\tVREG_INFO(VAUX1, PCAP_REG_AUXVREG, 1,  2,  22, 23),\n\t \n\tVREG_INFO(VAUX2, PCAP_REG_AUXVREG, 4,  5,  0,  1),\n\tVREG_INFO(VAUX3, PCAP_REG_AUXVREG, 7,  8,  2,  3),\n\tVREG_INFO(VAUX4, PCAP_REG_AUXVREG, 12, 13, 4,  5),\n\tVREG_INFO(VSIM,  PCAP_REG_AUXVREG, 17, 18, NA, 6),\n\tVREG_INFO(VSIM2, PCAP_REG_AUXVREG, 16, NA, NA, 7),\n\tVREG_INFO(VVIB,  PCAP_REG_AUXVREG, 19, 20, NA, NA),\n\n\tVREG_INFO(SW1,   PCAP_REG_SWCTRL,  1,  2,  NA, NA),\n\tVREG_INFO(SW2,   PCAP_REG_SWCTRL,  6,  7,  NA, NA),\n\t \n\tVREG_INFO(SW3,   PCAP_REG_SWCTRL,  11, 12, 24, NA),\n\n\t \n \n};\n\nstatic int pcap_regulator_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\t  unsigned selector)\n{\n\tstruct pcap_regulator *vreg = &vreg_table[rdev_get_id(rdev)];\n\tvoid *pcap = rdev_get_drvdata(rdev);\n\n\t \n\tif (rdev->desc->n_voltages == 1)\n\t\treturn -EINVAL;\n\n\treturn ezx_pcap_set_bits(pcap, vreg->reg,\n\t\t\t\t (rdev->desc->n_voltages - 1) << vreg->index,\n\t\t\t\t selector << vreg->index);\n}\n\nstatic int pcap_regulator_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct pcap_regulator *vreg = &vreg_table[rdev_get_id(rdev)];\n\tvoid *pcap = rdev_get_drvdata(rdev);\n\tu32 tmp;\n\n\tif (rdev->desc->n_voltages == 1)\n\t\treturn 0;\n\n\tezx_pcap_read(pcap, vreg->reg, &tmp);\n\ttmp = ((tmp >> vreg->index) & (rdev->desc->n_voltages - 1));\n\treturn tmp;\n}\n\nstatic int pcap_regulator_enable(struct regulator_dev *rdev)\n{\n\tstruct pcap_regulator *vreg = &vreg_table[rdev_get_id(rdev)];\n\tvoid *pcap = rdev_get_drvdata(rdev);\n\n\tif (vreg->en == NA)\n\t\treturn -EINVAL;\n\n\treturn ezx_pcap_set_bits(pcap, vreg->reg, 1 << vreg->en, 1 << vreg->en);\n}\n\nstatic int pcap_regulator_disable(struct regulator_dev *rdev)\n{\n\tstruct pcap_regulator *vreg = &vreg_table[rdev_get_id(rdev)];\n\tvoid *pcap = rdev_get_drvdata(rdev);\n\n\tif (vreg->en == NA)\n\t\treturn -EINVAL;\n\n\treturn ezx_pcap_set_bits(pcap, vreg->reg, 1 << vreg->en, 0);\n}\n\nstatic int pcap_regulator_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct pcap_regulator *vreg = &vreg_table[rdev_get_id(rdev)];\n\tvoid *pcap = rdev_get_drvdata(rdev);\n\tu32 tmp;\n\n\tif (vreg->en == NA)\n\t\treturn -EINVAL;\n\n\tezx_pcap_read(pcap, vreg->reg, &tmp);\n\treturn (tmp >> vreg->en) & 1;\n}\n\nstatic const struct regulator_ops pcap_regulator_ops = {\n\t.list_voltage\t= regulator_list_voltage_table,\n\t.set_voltage_sel = pcap_regulator_set_voltage_sel,\n\t.get_voltage_sel = pcap_regulator_get_voltage_sel,\n\t.enable\t\t= pcap_regulator_enable,\n\t.disable\t= pcap_regulator_disable,\n\t.is_enabled\t= pcap_regulator_is_enabled,\n};\n\n#define VREG(_vreg)\t\t\t\t\t\t\\\n\t[_vreg]\t= {\t\t\t\t\t\t\\\n\t\t.name\t\t= #_vreg,\t\t\t\\\n\t\t.id\t\t= _vreg,\t\t\t\\\n\t\t.n_voltages\t= ARRAY_SIZE(_vreg##_table),\t\\\n\t\t.volt_table\t= _vreg##_table,\t\t\\\n\t\t.ops\t\t= &pcap_regulator_ops,\t\t\\\n\t\t.type\t\t= REGULATOR_VOLTAGE,\t\t\\\n\t\t.owner\t\t= THIS_MODULE,\t\t\t\\\n\t}\n\nstatic const struct regulator_desc pcap_regulators[] = {\n\tVREG(V1), VREG(V2), VREG(V3), VREG(V4), VREG(V5), VREG(V6), VREG(V7),\n\tVREG(V8), VREG(V9), VREG(V10), VREG(VAUX1), VREG(VAUX2), VREG(VAUX3),\n\tVREG(VAUX4), VREG(VSIM), VREG(VSIM2), VREG(VVIB), VREG(SW1), VREG(SW2),\n};\n\nstatic int pcap_regulator_probe(struct platform_device *pdev)\n{\n\tstruct regulator_dev *rdev;\n\tvoid *pcap = dev_get_drvdata(pdev->dev.parent);\n\tstruct regulator_config config = { };\n\n\tconfig.dev = &pdev->dev;\n\tconfig.init_data = dev_get_platdata(&pdev->dev);\n\tconfig.driver_data = pcap;\n\n\trdev = devm_regulator_register(&pdev->dev, &pcap_regulators[pdev->id],\n\t\t\t\t       &config);\n\tif (IS_ERR(rdev))\n\t\treturn PTR_ERR(rdev);\n\n\tplatform_set_drvdata(pdev, rdev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver pcap_regulator_driver = {\n\t.driver = {\n\t\t.name\t= \"pcap-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t= pcap_regulator_probe,\n};\n\nstatic int __init pcap_regulator_init(void)\n{\n\treturn platform_driver_register(&pcap_regulator_driver);\n}\n\nstatic void __exit pcap_regulator_exit(void)\n{\n\tplatform_driver_unregister(&pcap_regulator_driver);\n}\n\nsubsys_initcall(pcap_regulator_init);\nmodule_exit(pcap_regulator_exit);\n\nMODULE_AUTHOR(\"Daniel Ribeiro <drwyrm@gmail.com>\");\nMODULE_DESCRIPTION(\"PCAP2 Regulator Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}