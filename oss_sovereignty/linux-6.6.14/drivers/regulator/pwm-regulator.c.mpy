{
  "module_name": "pwm-regulator.c",
  "hash_id": "e4ac052194273f060b903638d69f51938ddb1c6534b7bab95e5d5a2e2ca8ddd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/pwm-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/of.h>\n#include <linux/pwm.h>\n#include <linux/gpio/consumer.h>\n\nstruct pwm_continuous_reg_data {\n\tunsigned int min_uV_dutycycle;\n\tunsigned int max_uV_dutycycle;\n\tunsigned int dutycycle_unit;\n};\n\nstruct pwm_regulator_data {\n\t \n\tstruct pwm_device *pwm;\n\n\t \n\tstruct pwm_voltages *duty_cycle_table;\n\n\t \n\tstruct pwm_continuous_reg_data continuous;\n\n\t \n\tstruct regulator_desc desc;\n\n\tint state;\n\n\t \n\tstruct gpio_desc *enb_gpio;\n};\n\nstruct pwm_voltages {\n\tunsigned int uV;\n\tunsigned int dutycycle;\n};\n\n \nstatic void pwm_regulator_init_state(struct regulator_dev *rdev)\n{\n\tstruct pwm_regulator_data *drvdata = rdev_get_drvdata(rdev);\n\tstruct pwm_state pwm_state;\n\tunsigned int dutycycle;\n\tint i;\n\n\tpwm_get_state(drvdata->pwm, &pwm_state);\n\tdutycycle = pwm_get_relative_duty_cycle(&pwm_state, 100);\n\n\tfor (i = 0; i < rdev->desc->n_voltages; i++) {\n\t\tif (dutycycle == drvdata->duty_cycle_table[i].dutycycle) {\n\t\t\tdrvdata->state = i;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int pwm_regulator_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct pwm_regulator_data *drvdata = rdev_get_drvdata(rdev);\n\n\tif (drvdata->state < 0)\n\t\tpwm_regulator_init_state(rdev);\n\n\treturn drvdata->state;\n}\n\nstatic int pwm_regulator_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\t unsigned selector)\n{\n\tstruct pwm_regulator_data *drvdata = rdev_get_drvdata(rdev);\n\tstruct pwm_state pstate;\n\tint ret;\n\n\tpwm_init_state(drvdata->pwm, &pstate);\n\tpwm_set_relative_duty_cycle(&pstate,\n\t\t\tdrvdata->duty_cycle_table[selector].dutycycle, 100);\n\n\tret = pwm_apply_state(drvdata->pwm, &pstate);\n\tif (ret) {\n\t\tdev_err(&rdev->dev, \"Failed to configure PWM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrvdata->state = selector;\n\n\treturn 0;\n}\n\nstatic int pwm_regulator_list_voltage(struct regulator_dev *rdev,\n\t\t\t\t      unsigned selector)\n{\n\tstruct pwm_regulator_data *drvdata = rdev_get_drvdata(rdev);\n\n\tif (selector >= rdev->desc->n_voltages)\n\t\treturn -EINVAL;\n\n\treturn drvdata->duty_cycle_table[selector].uV;\n}\n\nstatic int pwm_regulator_enable(struct regulator_dev *dev)\n{\n\tstruct pwm_regulator_data *drvdata = rdev_get_drvdata(dev);\n\n\tgpiod_set_value_cansleep(drvdata->enb_gpio, 1);\n\n\treturn pwm_enable(drvdata->pwm);\n}\n\nstatic int pwm_regulator_disable(struct regulator_dev *dev)\n{\n\tstruct pwm_regulator_data *drvdata = rdev_get_drvdata(dev);\n\n\tpwm_disable(drvdata->pwm);\n\n\tgpiod_set_value_cansleep(drvdata->enb_gpio, 0);\n\n\treturn 0;\n}\n\nstatic int pwm_regulator_is_enabled(struct regulator_dev *dev)\n{\n\tstruct pwm_regulator_data *drvdata = rdev_get_drvdata(dev);\n\n\tif (drvdata->enb_gpio && !gpiod_get_value_cansleep(drvdata->enb_gpio))\n\t\treturn false;\n\n\treturn pwm_is_enabled(drvdata->pwm);\n}\n\nstatic int pwm_regulator_get_voltage(struct regulator_dev *rdev)\n{\n\tstruct pwm_regulator_data *drvdata = rdev_get_drvdata(rdev);\n\tunsigned int min_uV_duty = drvdata->continuous.min_uV_dutycycle;\n\tunsigned int max_uV_duty = drvdata->continuous.max_uV_dutycycle;\n\tunsigned int duty_unit = drvdata->continuous.dutycycle_unit;\n\tint min_uV = rdev->constraints->min_uV;\n\tint max_uV = rdev->constraints->max_uV;\n\tint diff_uV = max_uV - min_uV;\n\tstruct pwm_state pstate;\n\tunsigned int diff_duty;\n\tunsigned int voltage;\n\n\tpwm_get_state(drvdata->pwm, &pstate);\n\n\tvoltage = pwm_get_relative_duty_cycle(&pstate, duty_unit);\n\n\t \n\tif (max_uV_duty < min_uV_duty) {\n\t\tvoltage = min_uV_duty - voltage;\n\t\tdiff_duty = min_uV_duty - max_uV_duty;\n\t} else {\n\t\tvoltage = voltage - min_uV_duty;\n\t\tdiff_duty = max_uV_duty - min_uV_duty;\n\t}\n\n\tvoltage = DIV_ROUND_CLOSEST_ULL((u64)voltage * diff_uV, diff_duty);\n\n\treturn voltage + min_uV;\n}\n\nstatic int pwm_regulator_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t     int req_min_uV, int req_max_uV,\n\t\t\t\t     unsigned int *selector)\n{\n\tstruct pwm_regulator_data *drvdata = rdev_get_drvdata(rdev);\n\tunsigned int min_uV_duty = drvdata->continuous.min_uV_dutycycle;\n\tunsigned int max_uV_duty = drvdata->continuous.max_uV_dutycycle;\n\tunsigned int duty_unit = drvdata->continuous.dutycycle_unit;\n\tint min_uV = rdev->constraints->min_uV;\n\tint max_uV = rdev->constraints->max_uV;\n\tint diff_uV = max_uV - min_uV;\n\tstruct pwm_state pstate;\n\tunsigned int diff_duty;\n\tunsigned int dutycycle;\n\tint ret;\n\n\tpwm_init_state(drvdata->pwm, &pstate);\n\n\t \n\tif (max_uV_duty < min_uV_duty)\n\t\tdiff_duty = min_uV_duty - max_uV_duty;\n\telse\n\t\tdiff_duty = max_uV_duty - min_uV_duty;\n\n\tdutycycle = DIV_ROUND_CLOSEST_ULL((u64)(req_min_uV - min_uV) *\n\t\t\t\t\t  diff_duty,\n\t\t\t\t\t  diff_uV);\n\n\tif (max_uV_duty < min_uV_duty)\n\t\tdutycycle = min_uV_duty - dutycycle;\n\telse\n\t\tdutycycle = min_uV_duty + dutycycle;\n\n\tpwm_set_relative_duty_cycle(&pstate, dutycycle, duty_unit);\n\n\tret = pwm_apply_state(drvdata->pwm, &pstate);\n\tif (ret) {\n\t\tdev_err(&rdev->dev, \"Failed to configure PWM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regulator_ops pwm_regulator_voltage_table_ops = {\n\t.set_voltage_sel = pwm_regulator_set_voltage_sel,\n\t.get_voltage_sel = pwm_regulator_get_voltage_sel,\n\t.list_voltage    = pwm_regulator_list_voltage,\n\t.map_voltage     = regulator_map_voltage_iterate,\n\t.enable          = pwm_regulator_enable,\n\t.disable         = pwm_regulator_disable,\n\t.is_enabled      = pwm_regulator_is_enabled,\n};\n\nstatic const struct regulator_ops pwm_regulator_voltage_continuous_ops = {\n\t.get_voltage = pwm_regulator_get_voltage,\n\t.set_voltage = pwm_regulator_set_voltage,\n\t.enable          = pwm_regulator_enable,\n\t.disable         = pwm_regulator_disable,\n\t.is_enabled      = pwm_regulator_is_enabled,\n};\n\nstatic const struct regulator_desc pwm_regulator_desc = {\n\t.name\t\t= \"pwm-regulator\",\n\t.type\t\t= REGULATOR_VOLTAGE,\n\t.owner\t\t= THIS_MODULE,\n\t.supply_name    = \"pwm\",\n};\n\nstatic int pwm_regulator_init_table(struct platform_device *pdev,\n\t\t\t\t    struct pwm_regulator_data *drvdata)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct pwm_voltages *duty_cycle_table;\n\tunsigned int length = 0;\n\tint ret;\n\n\tof_find_property(np, \"voltage-table\", &length);\n\n\tif ((length < sizeof(*duty_cycle_table)) ||\n\t    (length % sizeof(*duty_cycle_table))) {\n\t\tdev_err(&pdev->dev, \"voltage-table length(%d) is invalid\\n\",\n\t\t\tlength);\n\t\treturn -EINVAL;\n\t}\n\n\tduty_cycle_table = devm_kzalloc(&pdev->dev, length, GFP_KERNEL);\n\tif (!duty_cycle_table)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32_array(np, \"voltage-table\",\n\t\t\t\t\t (u32 *)duty_cycle_table,\n\t\t\t\t\t length / sizeof(u32));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to read voltage-table: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrvdata->state\t\t\t= -ENOTRECOVERABLE;\n\tdrvdata->duty_cycle_table\t= duty_cycle_table;\n\tdrvdata->desc.ops = &pwm_regulator_voltage_table_ops;\n\tdrvdata->desc.n_voltages\t= length / sizeof(*duty_cycle_table);\n\n\treturn 0;\n}\n\nstatic int pwm_regulator_init_continuous(struct platform_device *pdev,\n\t\t\t\t\t struct pwm_regulator_data *drvdata)\n{\n\tu32 dutycycle_range[2] = { 0, 100 };\n\tu32 dutycycle_unit = 100;\n\n\tdrvdata->desc.ops = &pwm_regulator_voltage_continuous_ops;\n\tdrvdata->desc.continuous_voltage_range = true;\n\n\tof_property_read_u32_array(pdev->dev.of_node,\n\t\t\t\t   \"pwm-dutycycle-range\",\n\t\t\t\t   dutycycle_range, 2);\n\tof_property_read_u32(pdev->dev.of_node, \"pwm-dutycycle-unit\",\n\t\t\t     &dutycycle_unit);\n\n\tif (dutycycle_range[0] > dutycycle_unit ||\n\t    dutycycle_range[1] > dutycycle_unit)\n\t\treturn -EINVAL;\n\n\tdrvdata->continuous.dutycycle_unit = dutycycle_unit;\n\tdrvdata->continuous.min_uV_dutycycle = dutycycle_range[0];\n\tdrvdata->continuous.max_uV_dutycycle = dutycycle_range[1];\n\n\treturn 0;\n}\n\nstatic int pwm_regulator_probe(struct platform_device *pdev)\n{\n\tconst struct regulator_init_data *init_data;\n\tstruct pwm_regulator_data *drvdata;\n\tstruct regulator_dev *regulator;\n\tstruct regulator_config config = { };\n\tstruct device_node *np = pdev->dev.of_node;\n\tenum gpiod_flags gpio_flags;\n\tint ret;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"Device Tree node missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdrvdata = devm_kzalloc(&pdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&drvdata->desc, &pwm_regulator_desc, sizeof(drvdata->desc));\n\n\tif (of_property_present(np, \"voltage-table\"))\n\t\tret = pwm_regulator_init_table(pdev, drvdata);\n\telse\n\t\tret = pwm_regulator_init_continuous(pdev, drvdata);\n\tif (ret)\n\t\treturn ret;\n\n\tinit_data = of_get_regulator_init_data(&pdev->dev, np,\n\t\t\t\t\t       &drvdata->desc);\n\tif (!init_data)\n\t\treturn -ENOMEM;\n\n\tconfig.of_node = np;\n\tconfig.dev = &pdev->dev;\n\tconfig.driver_data = drvdata;\n\tconfig.init_data = init_data;\n\n\tdrvdata->pwm = devm_pwm_get(&pdev->dev, NULL);\n\tif (IS_ERR(drvdata->pwm))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(drvdata->pwm),\n\t\t\t\t     \"Failed to get PWM\\n\");\n\n\tif (init_data->constraints.boot_on || init_data->constraints.always_on)\n\t\tgpio_flags = GPIOD_OUT_HIGH;\n\telse\n\t\tgpio_flags = GPIOD_OUT_LOW;\n\tdrvdata->enb_gpio = devm_gpiod_get_optional(&pdev->dev, \"enable\",\n\t\t\t\t\t\t    gpio_flags);\n\tif (IS_ERR(drvdata->enb_gpio)) {\n\t\tret = PTR_ERR(drvdata->enb_gpio);\n\t\tdev_err(&pdev->dev, \"Failed to get enable GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pwm_adjust_config(drvdata->pwm);\n\tif (ret)\n\t\treturn ret;\n\n\tregulator = devm_regulator_register(&pdev->dev,\n\t\t\t\t\t    &drvdata->desc, &config);\n\tif (IS_ERR(regulator)) {\n\t\tret = PTR_ERR(regulator);\n\t\tdev_err(&pdev->dev, \"Failed to register regulator %s: %d\\n\",\n\t\t\tdrvdata->desc.name, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused pwm_of_match[] = {\n\t{ .compatible = \"pwm-regulator\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pwm_of_match);\n\nstatic struct platform_driver pwm_regulator_driver = {\n\t.driver = {\n\t\t.name\t\t= \"pwm-regulator\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(pwm_of_match),\n\t},\n\t.probe = pwm_regulator_probe,\n};\n\nmodule_platform_driver(pwm_regulator_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Lee Jones <lee.jones@linaro.org>\");\nMODULE_DESCRIPTION(\"PWM Regulator Driver\");\nMODULE_ALIAS(\"platform:pwm-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}