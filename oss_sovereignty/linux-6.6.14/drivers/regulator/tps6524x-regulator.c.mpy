{
  "module_name": "tps6524x-regulator.c",
  "hash_id": "4b475edc1f574ad32d5ed8e1ba631f4b722ce61efb81e8ae5e1731d880a5d2f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/tps6524x-regulator.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n\n#define REG_LDO_SET\t\t0x0\n#define LDO_ILIM_MASK\t\t1\t \n#define LDO_VSEL_MASK\t\t0x0f\n#define LDO2_ILIM_SHIFT\t\t12\n#define LDO2_VSEL_SHIFT\t\t4\n#define LDO1_ILIM_SHIFT\t\t8\n#define LDO1_VSEL_SHIFT\t\t0\n\n#define REG_BLOCK_EN\t\t0x1\n#define BLOCK_MASK\t\t1\n#define BLOCK_LDO1_SHIFT\t0\n#define BLOCK_LDO2_SHIFT\t1\n#define BLOCK_LCD_SHIFT\t\t2\n#define BLOCK_USB_SHIFT\t\t3\n\n#define REG_DCDC_SET\t\t0x2\n#define DCDC_VDCDC_MASK\t\t0x1f\n#define DCDC_VDCDC1_SHIFT\t0\n#define DCDC_VDCDC2_SHIFT\t5\n#define DCDC_VDCDC3_SHIFT\t10\n\n#define REG_DCDC_EN\t\t0x3\n#define DCDCDCDC_EN_MASK\t0x1\n#define DCDCDCDC1_EN_SHIFT\t0\n#define DCDCDCDC1_PG_MSK\tBIT(1)\n#define DCDCDCDC2_EN_SHIFT\t2\n#define DCDCDCDC2_PG_MSK\tBIT(3)\n#define DCDCDCDC3_EN_SHIFT\t4\n#define DCDCDCDC3_PG_MSK\tBIT(5)\n\n#define REG_USB\t\t\t0x4\n#define USB_ILIM_SHIFT\t\t0\n#define USB_ILIM_MASK\t\t0x3\n#define USB_TSD_SHIFT\t\t2\n#define USB_TSD_MASK\t\t0x3\n#define USB_TWARN_SHIFT\t\t4\n#define USB_TWARN_MASK\t\t0x3\n#define USB_IWARN_SD\t\tBIT(6)\n#define USB_FAST_LOOP\t\tBIT(7)\n\n#define REG_ALARM\t\t0x5\n#define ALARM_LDO1\t\tBIT(0)\n#define ALARM_DCDC1\t\tBIT(1)\n#define ALARM_DCDC2\t\tBIT(2)\n#define ALARM_DCDC3\t\tBIT(3)\n#define ALARM_LDO2\t\tBIT(4)\n#define ALARM_USB_WARN\t\tBIT(5)\n#define ALARM_USB_ALARM\t\tBIT(6)\n#define ALARM_LCD\t\tBIT(9)\n#define ALARM_TEMP_WARM\t\tBIT(10)\n#define ALARM_TEMP_HOT\t\tBIT(11)\n#define ALARM_NRST\t\tBIT(14)\n#define ALARM_POWERUP\t\tBIT(15)\n\n#define REG_INT_ENABLE\t\t0x6\n#define INT_LDO1\t\tBIT(0)\n#define INT_DCDC1\t\tBIT(1)\n#define INT_DCDC2\t\tBIT(2)\n#define INT_DCDC3\t\tBIT(3)\n#define INT_LDO2\t\tBIT(4)\n#define INT_USB_WARN\t\tBIT(5)\n#define INT_USB_ALARM\t\tBIT(6)\n#define INT_LCD\t\t\tBIT(9)\n#define INT_TEMP_WARM\t\tBIT(10)\n#define INT_TEMP_HOT\t\tBIT(11)\n#define INT_GLOBAL_EN\t\tBIT(15)\n\n#define REG_INT_STATUS\t\t0x7\n#define STATUS_LDO1\t\tBIT(0)\n#define STATUS_DCDC1\t\tBIT(1)\n#define STATUS_DCDC2\t\tBIT(2)\n#define STATUS_DCDC3\t\tBIT(3)\n#define STATUS_LDO2\t\tBIT(4)\n#define STATUS_USB_WARN\t\tBIT(5)\n#define STATUS_USB_ALARM\tBIT(6)\n#define STATUS_LCD\t\tBIT(9)\n#define STATUS_TEMP_WARM\tBIT(10)\n#define STATUS_TEMP_HOT\t\tBIT(11)\n\n#define REG_SOFTWARE_RESET\t0xb\n#define REG_WRITE_ENABLE\t0xd\n#define REG_REV_ID\t\t0xf\n\n#define N_DCDC\t\t\t3\n#define N_LDO\t\t\t2\n#define N_SWITCH\t\t2\n#define N_REGULATORS\t\t(N_DCDC + N_LDO + N_SWITCH)\n\n#define CMD_READ(reg)\t\t((reg) << 6)\n#define CMD_WRITE(reg)\t\t(BIT(5) | (reg) << 6)\n#define STAT_CLK\t\tBIT(3)\n#define STAT_WRITE\t\tBIT(2)\n#define STAT_INVALID\t\tBIT(1)\n#define STAT_WP\t\t\tBIT(0)\n\nstruct field {\n\tint\t\treg;\n\tint\t\tshift;\n\tint\t\tmask;\n};\n\nstruct supply_info {\n\tconst char\t*name;\n\tint\t\tn_voltages;\n\tconst unsigned int *voltages;\n\tint\t\tn_ilimsels;\n\tconst unsigned int *ilimsels;\n\tstruct field\tenable, voltage, ilimsel;\n};\n\nstruct tps6524x {\n\tstruct device\t\t*dev;\n\tstruct spi_device\t*spi;\n\tstruct mutex\t\tlock;\n\tstruct regulator_desc\tdesc[N_REGULATORS];\n};\n\nstatic int __read_reg(struct tps6524x *hw, int reg)\n{\n\tint error = 0;\n\tu16 cmd = CMD_READ(reg), in;\n\tu8 status;\n\tstruct spi_message m;\n\tstruct spi_transfer t[3];\n\n\tspi_message_init(&m);\n\tmemset(t, 0, sizeof(t));\n\n\tt[0].tx_buf = &cmd;\n\tt[0].len = 2;\n\tt[0].bits_per_word = 12;\n\tspi_message_add_tail(&t[0], &m);\n\n\tt[1].rx_buf = &in;\n\tt[1].len = 2;\n\tt[1].bits_per_word = 16;\n\tspi_message_add_tail(&t[1], &m);\n\n\tt[2].rx_buf = &status;\n\tt[2].len = 1;\n\tt[2].bits_per_word = 4;\n\tspi_message_add_tail(&t[2], &m);\n\n\terror = spi_sync(hw->spi, &m);\n\tif (error < 0)\n\t\treturn error;\n\n\tdev_dbg(hw->dev, \"read reg %d, data %x, status %x\\n\",\n\t\treg, in, status);\n\n\tif (!(status & STAT_CLK) || (status & STAT_WRITE))\n\t\treturn -EIO;\n\n\tif (status & STAT_INVALID)\n\t\treturn -EINVAL;\n\n\treturn in;\n}\n\nstatic int read_reg(struct tps6524x *hw, int reg)\n{\n\tint ret;\n\n\tmutex_lock(&hw->lock);\n\tret = __read_reg(hw, reg);\n\tmutex_unlock(&hw->lock);\n\n\treturn ret;\n}\n\nstatic int __write_reg(struct tps6524x *hw, int reg, int val)\n{\n\tint error = 0;\n\tu16 cmd = CMD_WRITE(reg), out = val;\n\tu8 status;\n\tstruct spi_message m;\n\tstruct spi_transfer t[3];\n\n\tspi_message_init(&m);\n\tmemset(t, 0, sizeof(t));\n\n\tt[0].tx_buf = &cmd;\n\tt[0].len = 2;\n\tt[0].bits_per_word = 12;\n\tspi_message_add_tail(&t[0], &m);\n\n\tt[1].tx_buf = &out;\n\tt[1].len = 2;\n\tt[1].bits_per_word = 16;\n\tspi_message_add_tail(&t[1], &m);\n\n\tt[2].rx_buf = &status;\n\tt[2].len = 1;\n\tt[2].bits_per_word = 4;\n\tspi_message_add_tail(&t[2], &m);\n\n\terror = spi_sync(hw->spi, &m);\n\tif (error < 0)\n\t\treturn error;\n\n\tdev_dbg(hw->dev, \"wrote reg %d, data %x, status %x\\n\",\n\t\treg, out, status);\n\n\tif (!(status & STAT_CLK) || !(status & STAT_WRITE))\n\t\treturn -EIO;\n\n\tif (status & (STAT_INVALID | STAT_WP))\n\t\treturn -EINVAL;\n\n\treturn error;\n}\n\nstatic int __rmw_reg(struct tps6524x *hw, int reg, int mask, int val)\n{\n\tint ret;\n\n\tret = __read_reg(hw, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret &= ~mask;\n\tret |= val;\n\n\tret = __write_reg(hw, reg, ret);\n\n\treturn (ret < 0) ? ret : 0;\n}\n\nstatic int rmw_protect(struct tps6524x *hw, int reg, int mask, int val)\n{\n\tint ret;\n\n\tmutex_lock(&hw->lock);\n\n\tret = __write_reg(hw, REG_WRITE_ENABLE, 1);\n\tif (ret) {\n\t\tdev_err(hw->dev, \"failed to set write enable\\n\");\n\t\tgoto error;\n\t}\n\n\tret = __rmw_reg(hw, reg, mask, val);\n\tif (ret)\n\t\tdev_err(hw->dev, \"failed to rmw register %d\\n\", reg);\n\n\tret = __write_reg(hw, REG_WRITE_ENABLE, 0);\n\tif (ret) {\n\t\tdev_err(hw->dev, \"failed to clear write enable\\n\");\n\t\tgoto error;\n\t}\n\nerror:\n\tmutex_unlock(&hw->lock);\n\n\treturn ret;\n}\n\nstatic int read_field(struct tps6524x *hw, const struct field *field)\n{\n\tint tmp;\n\n\ttmp = read_reg(hw, field->reg);\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\treturn (tmp >> field->shift) & field->mask;\n}\n\nstatic int write_field(struct tps6524x *hw, const struct field *field,\n\t\t       int val)\n{\n\tif (val & ~field->mask)\n\t\treturn -EOVERFLOW;\n\n\treturn rmw_protect(hw, field->reg,\n\t\t\t\t    field->mask << field->shift,\n\t\t\t\t    val << field->shift);\n}\n\nstatic const unsigned int dcdc1_voltages[] = {\n\t 800000,  825000,  850000,  875000,\n\t 900000,  925000,  950000,  975000,\n\t1000000, 1025000, 1050000, 1075000,\n\t1100000, 1125000, 1150000, 1175000,\n\t1200000, 1225000, 1250000, 1275000,\n\t1300000, 1325000, 1350000, 1375000,\n\t1400000, 1425000, 1450000, 1475000,\n\t1500000, 1525000, 1550000, 1575000,\n};\n\nstatic const unsigned int dcdc2_voltages[] = {\n\t1400000, 1450000, 1500000, 1550000,\n\t1600000, 1650000, 1700000, 1750000,\n\t1800000, 1850000, 1900000, 1950000,\n\t2000000, 2050000, 2100000, 2150000,\n\t2200000, 2250000, 2300000, 2350000,\n\t2400000, 2450000, 2500000, 2550000,\n\t2600000, 2650000, 2700000, 2750000,\n\t2800000, 2850000, 2900000, 2950000,\n};\n\nstatic const unsigned int dcdc3_voltages[] = {\n\t2400000, 2450000, 2500000, 2550000, 2600000,\n\t2650000, 2700000, 2750000, 2800000, 2850000,\n\t2900000, 2950000, 3000000, 3050000, 3100000,\n\t3150000, 3200000, 3250000, 3300000, 3350000,\n\t3400000, 3450000, 3500000, 3550000, 3600000,\n};\n\nstatic const unsigned int ldo1_voltages[] = {\n\t4300000, 4350000, 4400000, 4450000,\n\t4500000, 4550000, 4600000, 4650000,\n\t4700000, 4750000, 4800000, 4850000,\n\t4900000, 4950000, 5000000, 5050000,\n};\n\nstatic const unsigned int ldo2_voltages[] = {\n\t1100000, 1150000, 1200000, 1250000,\n\t1300000, 1700000, 1750000, 1800000,\n\t1850000, 1900000, 3150000, 3200000,\n\t3250000, 3300000, 3350000, 3400000,\n};\n\nstatic const unsigned int fixed_5000000_voltage[] = {\n\t5000000\n};\n\nstatic const unsigned int ldo_ilimsel[] = {\n\t400000, 1500000\n};\n\nstatic const unsigned int usb_ilimsel[] = {\n\t200000, 400000, 800000, 1000000\n};\n\nstatic const unsigned int fixed_2400000_ilimsel[] = {\n\t2400000\n};\n\nstatic const unsigned int fixed_1200000_ilimsel[] = {\n\t1200000\n};\n\nstatic const unsigned int fixed_400000_ilimsel[] = {\n\t400000\n};\n\n#define __MK_FIELD(_reg, _mask, _shift) \\\n\t{ .reg = (_reg), .mask = (_mask), .shift = (_shift), }\n\nstatic const struct supply_info supply_info[N_REGULATORS] = {\n\t{\n\t\t.name\t\t= \"DCDC1\",\n\t\t.n_voltages\t= ARRAY_SIZE(dcdc1_voltages),\n\t\t.voltages\t= dcdc1_voltages,\n\t\t.n_ilimsels\t= ARRAY_SIZE(fixed_2400000_ilimsel),\n\t\t.ilimsels\t= fixed_2400000_ilimsel,\n\t\t.enable\t\t= __MK_FIELD(REG_DCDC_EN, DCDCDCDC_EN_MASK,\n\t\t\t\t\t     DCDCDCDC1_EN_SHIFT),\n\t\t.voltage\t= __MK_FIELD(REG_DCDC_SET, DCDC_VDCDC_MASK,\n\t\t\t\t\t     DCDC_VDCDC1_SHIFT),\n\t},\n\t{\n\t\t.name\t\t= \"DCDC2\",\n\t\t.n_voltages\t= ARRAY_SIZE(dcdc2_voltages),\n\t\t.voltages\t= dcdc2_voltages,\n\t\t.n_ilimsels\t= ARRAY_SIZE(fixed_1200000_ilimsel),\n\t\t.ilimsels\t= fixed_1200000_ilimsel,\n\t\t.enable\t\t= __MK_FIELD(REG_DCDC_EN, DCDCDCDC_EN_MASK,\n\t\t\t\t\t     DCDCDCDC2_EN_SHIFT),\n\t\t.voltage\t= __MK_FIELD(REG_DCDC_SET, DCDC_VDCDC_MASK,\n\t\t\t\t\t     DCDC_VDCDC2_SHIFT),\n\t},\n\t{\n\t\t.name\t\t= \"DCDC3\",\n\t\t.n_voltages\t= ARRAY_SIZE(dcdc3_voltages),\n\t\t.voltages\t= dcdc3_voltages,\n\t\t.n_ilimsels\t= ARRAY_SIZE(fixed_1200000_ilimsel),\n\t\t.ilimsels\t= fixed_1200000_ilimsel,\n\t\t.enable\t\t= __MK_FIELD(REG_DCDC_EN, DCDCDCDC_EN_MASK,\n\t\t\t\t\tDCDCDCDC3_EN_SHIFT),\n\t\t.voltage\t= __MK_FIELD(REG_DCDC_SET, DCDC_VDCDC_MASK,\n\t\t\t\t\t     DCDC_VDCDC3_SHIFT),\n\t},\n\t{\n\t\t.name\t\t= \"LDO1\",\n\t\t.n_voltages\t= ARRAY_SIZE(ldo1_voltages),\n\t\t.voltages\t= ldo1_voltages,\n\t\t.n_ilimsels\t= ARRAY_SIZE(ldo_ilimsel),\n\t\t.ilimsels\t= ldo_ilimsel,\n\t\t.enable\t\t= __MK_FIELD(REG_BLOCK_EN, BLOCK_MASK,\n\t\t\t\t\t     BLOCK_LDO1_SHIFT),\n\t\t.voltage\t= __MK_FIELD(REG_LDO_SET, LDO_VSEL_MASK,\n\t\t\t\t\t     LDO1_VSEL_SHIFT),\n\t\t.ilimsel\t= __MK_FIELD(REG_LDO_SET, LDO_ILIM_MASK,\n\t\t\t\t\t     LDO1_ILIM_SHIFT),\n\t},\n\t{\n\t\t.name\t\t= \"LDO2\",\n\t\t.n_voltages\t= ARRAY_SIZE(ldo2_voltages),\n\t\t.voltages\t= ldo2_voltages,\n\t\t.n_ilimsels\t= ARRAY_SIZE(ldo_ilimsel),\n\t\t.ilimsels\t= ldo_ilimsel,\n\t\t.enable\t\t= __MK_FIELD(REG_BLOCK_EN, BLOCK_MASK,\n\t\t\t\t\t     BLOCK_LDO2_SHIFT),\n\t\t.voltage\t= __MK_FIELD(REG_LDO_SET, LDO_VSEL_MASK,\n\t\t\t\t\t     LDO2_VSEL_SHIFT),\n\t\t.ilimsel\t= __MK_FIELD(REG_LDO_SET, LDO_ILIM_MASK,\n\t\t\t\t\t     LDO2_ILIM_SHIFT),\n\t},\n\t{\n\t\t.name\t\t= \"USB\",\n\t\t.n_voltages\t= ARRAY_SIZE(fixed_5000000_voltage),\n\t\t.voltages\t= fixed_5000000_voltage,\n\t\t.n_ilimsels\t= ARRAY_SIZE(usb_ilimsel),\n\t\t.ilimsels\t= usb_ilimsel,\n\t\t.enable\t\t= __MK_FIELD(REG_BLOCK_EN, BLOCK_MASK,\n\t\t\t\t\t     BLOCK_USB_SHIFT),\n\t\t.ilimsel\t= __MK_FIELD(REG_USB, USB_ILIM_MASK,\n\t\t\t\t\t     USB_ILIM_SHIFT),\n\t},\n\t{\n\t\t.name\t\t= \"LCD\",\n\t\t.n_voltages\t= ARRAY_SIZE(fixed_5000000_voltage),\n\t\t.voltages\t= fixed_5000000_voltage,\n\t\t.n_ilimsels\t= ARRAY_SIZE(fixed_400000_ilimsel),\n\t\t.ilimsels\t= fixed_400000_ilimsel,\n\t\t.enable\t\t= __MK_FIELD(REG_BLOCK_EN, BLOCK_MASK,\n\t\t\t\t\t     BLOCK_LCD_SHIFT),\n\t},\n};\n\nstatic int set_voltage_sel(struct regulator_dev *rdev, unsigned selector)\n{\n\tconst struct supply_info *info;\n\tstruct tps6524x *hw;\n\n\thw\t= rdev_get_drvdata(rdev);\n\tinfo\t= &supply_info[rdev_get_id(rdev)];\n\n\tif (rdev->desc->n_voltages == 1)\n\t\treturn -EINVAL;\n\n\treturn write_field(hw, &info->voltage, selector);\n}\n\nstatic int get_voltage_sel(struct regulator_dev *rdev)\n{\n\tconst struct supply_info *info;\n\tstruct tps6524x *hw;\n\tint ret;\n\n\thw\t= rdev_get_drvdata(rdev);\n\tinfo\t= &supply_info[rdev_get_id(rdev)];\n\n\tif (rdev->desc->n_voltages == 1)\n\t\treturn 0;\n\n\tret = read_field(hw, &info->voltage);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (WARN_ON(ret >= info->n_voltages))\n\t\treturn -EIO;\n\n\treturn ret;\n}\n\nstatic int set_current_limit(struct regulator_dev *rdev, int min_uA,\n\t\t\t     int max_uA)\n{\n\tconst struct supply_info *info;\n\tstruct tps6524x *hw;\n\tint i;\n\n\thw\t= rdev_get_drvdata(rdev);\n\tinfo\t= &supply_info[rdev_get_id(rdev)];\n\n\tif (info->n_ilimsels == 1)\n\t\treturn -EINVAL;\n\n\tfor (i = info->n_ilimsels - 1; i >= 0; i--) {\n\t\tif (min_uA <= info->ilimsels[i] &&\n\t\t    max_uA >= info->ilimsels[i])\n\t\t\treturn write_field(hw, &info->ilimsel, i);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int get_current_limit(struct regulator_dev *rdev)\n{\n\tconst struct supply_info *info;\n\tstruct tps6524x *hw;\n\tint ret;\n\n\thw\t= rdev_get_drvdata(rdev);\n\tinfo\t= &supply_info[rdev_get_id(rdev)];\n\n\tif (info->n_ilimsels == 1)\n\t\treturn info->ilimsels[0];\n\n\tret = read_field(hw, &info->ilimsel);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (WARN_ON(ret >= info->n_ilimsels))\n\t\treturn -EIO;\n\n\treturn info->ilimsels[ret];\n}\n\nstatic int enable_supply(struct regulator_dev *rdev)\n{\n\tconst struct supply_info *info;\n\tstruct tps6524x *hw;\n\n\thw\t= rdev_get_drvdata(rdev);\n\tinfo\t= &supply_info[rdev_get_id(rdev)];\n\n\treturn write_field(hw, &info->enable, 1);\n}\n\nstatic int disable_supply(struct regulator_dev *rdev)\n{\n\tconst struct supply_info *info;\n\tstruct tps6524x *hw;\n\n\thw\t= rdev_get_drvdata(rdev);\n\tinfo\t= &supply_info[rdev_get_id(rdev)];\n\n\treturn write_field(hw, &info->enable, 0);\n}\n\nstatic int is_supply_enabled(struct regulator_dev *rdev)\n{\n\tconst struct supply_info *info;\n\tstruct tps6524x *hw;\n\n\thw\t= rdev_get_drvdata(rdev);\n\tinfo\t= &supply_info[rdev_get_id(rdev)];\n\n\treturn read_field(hw, &info->enable);\n}\n\nstatic const struct regulator_ops regulator_ops = {\n\t.is_enabled\t\t= is_supply_enabled,\n\t.enable\t\t\t= enable_supply,\n\t.disable\t\t= disable_supply,\n\t.get_voltage_sel\t= get_voltage_sel,\n\t.set_voltage_sel\t= set_voltage_sel,\n\t.list_voltage\t\t= regulator_list_voltage_table,\n\t.map_voltage\t\t= regulator_map_voltage_ascend,\n\t.set_current_limit\t= set_current_limit,\n\t.get_current_limit\t= get_current_limit,\n};\n\nstatic int pmic_probe(struct spi_device *spi)\n{\n\tstruct tps6524x *hw;\n\tstruct device *dev = &spi->dev;\n\tconst struct supply_info *info = supply_info;\n\tstruct regulator_init_data *init_data;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tint i;\n\n\tinit_data = dev_get_platdata(dev);\n\tif (!init_data) {\n\t\tdev_err(dev, \"could not find regulator platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thw = devm_kzalloc(&spi->dev, sizeof(struct tps6524x), GFP_KERNEL);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, hw);\n\n\tmemset(hw, 0, sizeof(struct tps6524x));\n\thw->dev = dev;\n\thw->spi = spi;\n\tmutex_init(&hw->lock);\n\n\tfor (i = 0; i < N_REGULATORS; i++, info++, init_data++) {\n\t\thw->desc[i].name\t= info->name;\n\t\thw->desc[i].id\t\t= i;\n\t\thw->desc[i].n_voltages\t= info->n_voltages;\n\t\thw->desc[i].volt_table\t= info->voltages;\n\t\thw->desc[i].ops\t\t= &regulator_ops;\n\t\thw->desc[i].type\t= REGULATOR_VOLTAGE;\n\t\thw->desc[i].owner\t= THIS_MODULE;\n\n\t\tconfig.dev = dev;\n\t\tconfig.init_data = init_data;\n\t\tconfig.driver_data = hw;\n\n\t\trdev = devm_regulator_register(dev, &hw->desc[i], &config);\n\t\tif (IS_ERR(rdev))\n\t\t\treturn PTR_ERR(rdev);\n\t}\n\n\treturn 0;\n}\n\nstatic struct spi_driver pmic_driver = {\n\t.probe\t\t= pmic_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"tps6524x\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nmodule_spi_driver(pmic_driver);\n\nMODULE_DESCRIPTION(\"TPS6524X PMIC Driver\");\nMODULE_AUTHOR(\"Cyril Chemparathy\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:tps6524x\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}