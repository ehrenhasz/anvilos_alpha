{
  "module_name": "internal.h",
  "hash_id": "1809fffca557111a98997d3602e6456ccbe8d2c3bb20483d178bca504b4b24d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/internal.h",
  "human_readable_source": " \n \n\n#ifndef __REGULATOR_INTERNAL_H\n#define __REGULATOR_INTERNAL_H\n\n#include <linux/suspend.h>\n\n#define REGULATOR_STATES_NUM\t(PM_SUSPEND_MAX + 1)\n\n#define rdev_crit(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_crit(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n#define rdev_err(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_err(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n#define rdev_warn(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_warn(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n#define rdev_info(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_info(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n#define rdev_dbg(rdev, fmt, ...)\t\t\t\t\t\\\n\tpr_debug(\"%s: \" fmt, rdev_get_name(rdev), ##__VA_ARGS__)\n\nstruct regulator_voltage {\n\tint min_uV;\n\tint max_uV;\n};\n\n \nstruct regulator {\n\tstruct device *dev;\n\tstruct list_head list;\n\tunsigned int always_on:1;\n\tunsigned int bypass:1;\n\tunsigned int device_link:1;\n\tint uA_load;\n\tunsigned int enable_count;\n\tunsigned int deferred_disables;\n\tstruct regulator_voltage voltage[REGULATOR_STATES_NUM];\n\tconst char *supply_name;\n\tstruct device_attribute dev_attr;\n\tstruct regulator_dev *rdev;\n\tstruct dentry *debugfs;\n};\n\nextern struct class regulator_class;\n\nstatic inline struct regulator_dev *dev_to_rdev(struct device *dev)\n{\n\treturn container_of(dev, struct regulator_dev, dev);\n}\n\n#ifdef CONFIG_OF\nstruct regulator_dev *of_find_regulator_by_node(struct device_node *np);\nstruct regulator_init_data *regulator_of_get_init_data(struct device *dev,\n\t\t\t         const struct regulator_desc *desc,\n\t\t\t\t struct regulator_config *config,\n\t\t\t\t struct device_node **node);\n\nstruct regulator_dev *of_parse_coupled_regulator(struct regulator_dev *rdev,\n\t\t\t\t\t\t int index);\n\nint of_get_n_coupled(struct regulator_dev *rdev);\n\nbool of_check_coupling_data(struct regulator_dev *rdev);\n\n#else\nstatic inline struct regulator_dev *\nof_find_regulator_by_node(struct device_node *np)\n{\n\treturn NULL;\n}\n\nstatic inline struct regulator_init_data *\nregulator_of_get_init_data(struct device *dev,\n\t\t\t   const struct regulator_desc *desc,\n\t\t\t   struct regulator_config *config,\n\t\t\t   struct device_node **node)\n{\n\treturn NULL;\n}\n\nstatic inline struct regulator_dev *\nof_parse_coupled_regulator(struct regulator_dev *rdev,\n\t\t\t   int index)\n{\n\treturn NULL;\n}\n\nstatic inline int of_get_n_coupled(struct regulator_dev *rdev)\n{\n\treturn 0;\n}\n\nstatic inline bool of_check_coupling_data(struct regulator_dev *rdev)\n{\n\treturn false;\n}\n\n#endif\nenum regulator_get_type {\n\tNORMAL_GET,\n\tEXCLUSIVE_GET,\n\tOPTIONAL_GET,\n\tMAX_GET_TYPE\n};\n\nstruct regulator *_regulator_get(struct device *dev, const char *id,\n\t\t\t\t enum regulator_get_type get_type);\nint _regulator_bulk_get(struct device *dev, int num_consumers,\n\t\t\tstruct regulator_bulk_data *consumers, enum regulator_get_type get_type);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}