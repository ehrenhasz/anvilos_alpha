{
  "module_name": "tps65023-regulator.c",
  "hash_id": "eab453e287d12d1cc29238f29e5b6f085558e7c7f1e4356c7a8e10d042a8730a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/tps65023-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n\n \n#define\tTPS65023_REG_VERSION\t\t0\n#define\tTPS65023_REG_PGOODZ\t\t1\n#define\tTPS65023_REG_MASK\t\t2\n#define\tTPS65023_REG_REG_CTRL\t\t3\n#define\tTPS65023_REG_CON_CTRL\t\t4\n#define\tTPS65023_REG_CON_CTRL2\t\t5\n#define\tTPS65023_REG_DEF_CORE\t\t6\n#define\tTPS65023_REG_DEFSLEW\t\t7\n#define\tTPS65023_REG_LDO_CTRL\t\t8\n\n \n#define\tTPS65023_PGOODZ_PWRFAILZ\tBIT(7)\n#define\tTPS65023_PGOODZ_LOWBATTZ\tBIT(6)\n#define\tTPS65023_PGOODZ_VDCDC1\t\tBIT(5)\n#define\tTPS65023_PGOODZ_VDCDC2\t\tBIT(4)\n#define\tTPS65023_PGOODZ_VDCDC3\t\tBIT(3)\n#define\tTPS65023_PGOODZ_LDO2\t\tBIT(2)\n#define\tTPS65023_PGOODZ_LDO1\t\tBIT(1)\n\n \n#define\tTPS65023_MASK_PWRFAILZ\t\tBIT(7)\n#define\tTPS65023_MASK_LOWBATTZ\t\tBIT(6)\n#define\tTPS65023_MASK_VDCDC1\t\tBIT(5)\n#define\tTPS65023_MASK_VDCDC2\t\tBIT(4)\n#define\tTPS65023_MASK_VDCDC3\t\tBIT(3)\n#define\tTPS65023_MASK_LDO2\t\tBIT(2)\n#define\tTPS65023_MASK_LDO1\t\tBIT(1)\n\n \n#define TPS65023_REG_CTRL_VDCDC1_EN\tBIT(5)\n#define TPS65023_REG_CTRL_VDCDC2_EN\tBIT(4)\n#define TPS65023_REG_CTRL_VDCDC3_EN\tBIT(3)\n#define TPS65023_REG_CTRL_LDO2_EN\tBIT(2)\n#define TPS65023_REG_CTRL_LDO1_EN\tBIT(1)\n\n \n#define TPS65023_REG_CTRL2_GO\t\tBIT(7)\n#define TPS65023_REG_CTRL2_CORE_ADJ\tBIT(6)\n#define TPS65023_REG_CTRL2_DCDC2\tBIT(2)\n#define TPS65023_REG_CTRL2_DCDC1\tBIT(1)\n#define TPS65023_REG_CTRL2_DCDC3\tBIT(0)\n\n \n#define TPS65023_NUM_DCDC\t\t3\n \n#define TPS65023_NUM_LDO\t\t2\n \n#define TPS65023_NUM_REGULATOR\t(TPS65023_NUM_DCDC + TPS65023_NUM_LDO)\n\n \n#define TPS65023_DCDC_1\t\t\t0\n#define TPS65023_DCDC_2\t\t\t1\n#define TPS65023_DCDC_3\t\t\t2\n \n#define TPS65023_LDO_1\t\t\t3\n#define TPS65023_LDO_2\t\t\t4\n\n#define TPS65023_MAX_REG_ID\t\tTPS65023_LDO_2\n\n#define TPS65023_REGULATOR_DCDC(_num, _t, _em)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.name\t\t= \"VDCDC\"#_num,\t\t\t\\\n\t\t.of_match\t= of_match_ptr(\"VDCDC\"#_num),\t\\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\t\\\n\t\t.id\t\t= TPS65023_DCDC_##_num,\t\t\\\n\t\t.n_voltages     = ARRAY_SIZE(_t),\t\t\\\n\t\t.ops\t\t= &tps65023_dcdc_ops,\t\t\\\n\t\t.type\t\t= REGULATOR_VOLTAGE,\t\t\\\n\t\t.owner\t\t= THIS_MODULE,\t\t\t\\\n\t\t.volt_table\t= _t,\t\t\t\t\\\n\t\t.vsel_reg\t= TPS65023_REG_DEF_CORE,\t\\\n\t\t.vsel_mask\t= ARRAY_SIZE(_t) - 1,\t\t\\\n\t\t.enable_mask\t= _em,\t\t\t\t\\\n\t\t.enable_reg\t= TPS65023_REG_REG_CTRL,\t\\\n\t\t.apply_reg\t= TPS65023_REG_CON_CTRL2,\t\\\n\t\t.apply_bit\t= TPS65023_REG_CTRL2_GO,\t\\\n\t}\t\t\t\t\t\t\t\\\n\n#define TPS65023_REGULATOR_LDO(_num, _t, _vm)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.name\t\t= \"LDO\"#_num,\t\t\t\\\n\t\t.of_match\t= of_match_ptr(\"LDO\"#_num),\t\\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\t\\\n\t\t.id\t\t= TPS65023_LDO_##_num,\t\t\\\n\t\t.n_voltages     = ARRAY_SIZE(_t),\t\t\\\n\t\t.ops\t\t= &tps65023_ldo_ops,\t\t\\\n\t\t.type\t\t= REGULATOR_VOLTAGE,\t\t\\\n\t\t.owner\t\t= THIS_MODULE,\t\t\t\\\n\t\t.volt_table\t= _t,\t\t\t\t\\\n\t\t.vsel_reg\t= TPS65023_REG_LDO_CTRL,\t\\\n\t\t.vsel_mask\t= _vm,\t\t\t\t\\\n\t\t.enable_mask\t= 1 << (_num),\t\t\t\\\n\t\t.enable_reg\t= TPS65023_REG_REG_CTRL,\t\\\n\t}\t\t\t\t\t\t\t\\\n\n \nstatic const unsigned int VCORE_VSEL_table[] = {\n\t800000, 825000, 850000, 875000,\n\t900000, 925000, 950000, 975000,\n\t1000000, 1025000, 1050000, 1075000,\n\t1100000, 1125000, 1150000, 1175000,\n\t1200000, 1225000, 1250000, 1275000,\n\t1300000, 1325000, 1350000, 1375000,\n\t1400000, 1425000, 1450000, 1475000,\n\t1500000, 1525000, 1550000, 1600000,\n};\n\nstatic const unsigned int DCDC_FIXED_3300000_VSEL_table[] = {\n\t3300000,\n};\n\nstatic const unsigned int DCDC_FIXED_1800000_VSEL_table[] = {\n\t1800000,\n};\n\n \nstatic const unsigned int TPS65020_LDO_VSEL_table[] = {\n\t1000000, 1050000, 1100000, 1300000,\n\t1800000, 2500000, 3000000, 3300000,\n};\n\n \nstatic const unsigned int TPS65023_LDO1_VSEL_table[] = {\n\t1000000, 1100000, 1300000, 1800000,\n\t2200000, 2600000, 2800000, 3150000,\n};\n\nstatic const unsigned int TPS65023_LDO2_VSEL_table[] = {\n\t1050000, 1200000, 1300000, 1800000,\n\t2500000, 2800000, 3000000, 3300000,\n};\n\n \nstruct tps_pmic {\n\tstruct regulator_dev *rdev[TPS65023_NUM_REGULATOR];\n\tconst struct tps_driver_data *driver_data;\n\tstruct regmap *regmap;\n};\n\n \nstruct tps_driver_data {\n\tconst struct regulator_desc *desc;\n\tu8 core_regulator;\n};\n\nstatic int tps65023_dcdc_get_voltage_sel(struct regulator_dev *dev)\n{\n\tstruct tps_pmic *tps = rdev_get_drvdata(dev);\n\tint dcdc = rdev_get_id(dev);\n\n\tif (dcdc < TPS65023_DCDC_1 || dcdc > TPS65023_DCDC_3)\n\t\treturn -EINVAL;\n\n\tif (dcdc != tps->driver_data->core_regulator)\n\t\treturn 0;\n\n\treturn regulator_get_voltage_sel_regmap(dev);\n}\n\nstatic int tps65023_dcdc_set_voltage_sel(struct regulator_dev *dev,\n\t\t\t\t\t unsigned selector)\n{\n\tstruct tps_pmic *tps = rdev_get_drvdata(dev);\n\tint dcdc = rdev_get_id(dev);\n\n\tif (dcdc != tps->driver_data->core_regulator)\n\t\treturn -EINVAL;\n\n\treturn regulator_set_voltage_sel_regmap(dev, selector);\n}\n\n \nstatic const struct regulator_ops tps65023_dcdc_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.get_voltage_sel = tps65023_dcdc_get_voltage_sel,\n\t.set_voltage_sel = tps65023_dcdc_set_voltage_sel,\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n};\n\n \nstatic const struct regulator_ops tps65023_ldo_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n};\n\nstatic const struct regmap_config tps65023_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic const struct regulator_desc tps65020_regulators[] = {\n\tTPS65023_REGULATOR_DCDC(1, DCDC_FIXED_3300000_VSEL_table, 0x20),\n\tTPS65023_REGULATOR_DCDC(2, DCDC_FIXED_1800000_VSEL_table, 0x10),\n\tTPS65023_REGULATOR_DCDC(3, VCORE_VSEL_table, 0x08),\n\tTPS65023_REGULATOR_LDO(1, TPS65020_LDO_VSEL_table, 0x07),\n\tTPS65023_REGULATOR_LDO(2, TPS65020_LDO_VSEL_table, 0x70),\n};\n\nstatic const struct regulator_desc tps65021_regulators[] = {\n\tTPS65023_REGULATOR_DCDC(1, DCDC_FIXED_3300000_VSEL_table, 0x20),\n\tTPS65023_REGULATOR_DCDC(2, DCDC_FIXED_1800000_VSEL_table, 0x10),\n\tTPS65023_REGULATOR_DCDC(3, VCORE_VSEL_table, 0x08),\n\tTPS65023_REGULATOR_LDO(1, TPS65023_LDO1_VSEL_table, 0x07),\n\tTPS65023_REGULATOR_LDO(2, TPS65023_LDO2_VSEL_table, 0x70),\n};\n\nstatic const struct regulator_desc tps65023_regulators[] = {\n\tTPS65023_REGULATOR_DCDC(1, VCORE_VSEL_table, 0x20),\n\tTPS65023_REGULATOR_DCDC(2, DCDC_FIXED_3300000_VSEL_table, 0x10),\n\tTPS65023_REGULATOR_DCDC(3, DCDC_FIXED_1800000_VSEL_table, 0x08),\n\tTPS65023_REGULATOR_LDO(1, TPS65023_LDO1_VSEL_table, 0x07),\n\tTPS65023_REGULATOR_LDO(2, TPS65023_LDO2_VSEL_table, 0x70),\n};\n\nstatic struct tps_driver_data tps65020_drv_data = {\n\t.desc = tps65020_regulators,\n\t.core_regulator = TPS65023_DCDC_3,\n};\n\nstatic struct tps_driver_data tps65021_drv_data = {\n\t.desc = tps65021_regulators,\n\t.core_regulator = TPS65023_DCDC_3,\n};\n\nstatic struct tps_driver_data tps65023_drv_data = {\n\t.desc = tps65023_regulators,\n\t.core_regulator = TPS65023_DCDC_1,\n};\n\nstatic int tps_65023_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct regulator_init_data *init_data = dev_get_platdata(&client->dev);\n\tstruct regulator_config config = { };\n\tstruct tps_pmic *tps;\n\tint i;\n\tint error;\n\n\ttps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\ttps->driver_data = (struct tps_driver_data *)id->driver_data;\n\n\ttps->regmap = devm_regmap_init_i2c(client, &tps65023_regmap_config);\n\tif (IS_ERR(tps->regmap)) {\n\t\terror = PTR_ERR(tps->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\tconfig.dev = &client->dev;\n\tconfig.driver_data = tps;\n\tconfig.regmap = tps->regmap;\n\n\tfor (i = 0; i < TPS65023_NUM_REGULATOR; i++) {\n\t\tif (init_data)\n\t\t\tconfig.init_data = &init_data[i];\n\n\t\t \n\t\ttps->rdev[i] = devm_regulator_register(&client->dev,\n\t\t\t\t\t&tps->driver_data->desc[i], &config);\n\t\tif (IS_ERR(tps->rdev[i])) {\n\t\t\tdev_err(&client->dev, \"failed to register %s\\n\",\n\t\t\t\tid->name);\n\t\t\treturn PTR_ERR(tps->rdev[i]);\n\t\t}\n\t}\n\n\ti2c_set_clientdata(client, tps);\n\n\t \n\tregmap_update_bits(tps->regmap, TPS65023_REG_CON_CTRL2,\n\t\t\t   TPS65023_REG_CTRL2_CORE_ADJ, 0);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused tps65023_of_match[] = {\n\t{ .compatible = \"ti,tps65020\", .data = &tps65020_drv_data},\n\t{ .compatible = \"ti,tps65021\", .data = &tps65021_drv_data},\n\t{ .compatible = \"ti,tps65023\", .data = &tps65023_drv_data},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tps65023_of_match);\n\nstatic const struct i2c_device_id tps_65023_id[] = {\n\t{\n\t\t.name = \"tps65023\",\n\t\t.driver_data = (kernel_ulong_t)&tps65023_drv_data\n\t}, {\n\t\t.name = \"tps65021\",\n\t\t.driver_data = (kernel_ulong_t)&tps65021_drv_data\n\t}, {\n\t\t.name = \"tps65020\",\n\t\t.driver_data = (kernel_ulong_t)&tps65020_drv_data\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, tps_65023_id);\n\nstatic struct i2c_driver tps_65023_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tps65023\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(tps65023_of_match),\n\t},\n\t.probe = tps_65023_probe,\n\t.id_table = tps_65023_id,\n};\n\nstatic int __init tps_65023_init(void)\n{\n\treturn i2c_add_driver(&tps_65023_i2c_driver);\n}\nsubsys_initcall(tps_65023_init);\n\nstatic void __exit tps_65023_cleanup(void)\n{\n\ti2c_del_driver(&tps_65023_i2c_driver);\n}\nmodule_exit(tps_65023_cleanup);\n\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_DESCRIPTION(\"TPS65023 voltage regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}