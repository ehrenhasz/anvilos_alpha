{
  "module_name": "stm32-vrefbuf.c",
  "hash_id": "b5b415cc1d924bff5e0d465b399a9b0ea5fd89571603baf56544fb28019532f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/stm32-vrefbuf.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/pm_runtime.h>\n\n \n#define STM32_VREFBUF_CSR\t\t0x00\n\n \n#define STM32_VRS\t\t\tGENMASK(6, 4)\n#define STM32_VRR\t\t\tBIT(3)\n#define STM32_HIZ\t\t\tBIT(1)\n#define STM32_ENVR\t\t\tBIT(0)\n\n#define STM32_VREFBUF_AUTO_SUSPEND_DELAY_MS\t10\n\nstruct stm32_vrefbuf {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct device *dev;\n};\n\nstatic const unsigned int stm32_vrefbuf_voltages[] = {\n\t \n\t2500000, 2048000, 1800000, 1500000,\n};\n\nstatic int stm32_vrefbuf_enable(struct regulator_dev *rdev)\n{\n\tstruct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);\n\tu32 val;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = readl_relaxed(priv->base + STM32_VREFBUF_CSR);\n\tval = (val & ~STM32_HIZ) | STM32_ENVR;\n\twritel_relaxed(val, priv->base + STM32_VREFBUF_CSR);\n\n\t \n\tret = readl_poll_timeout(priv->base + STM32_VREFBUF_CSR, val,\n\t\t\t\t val & STM32_VRR, 650, 10000);\n\tif (ret) {\n\t\tdev_err(&rdev->dev, \"stm32 vrefbuf timed out!\\n\");\n\t\tval = readl_relaxed(priv->base + STM32_VREFBUF_CSR);\n\t\tval = (val & ~STM32_ENVR) | STM32_HIZ;\n\t\twritel_relaxed(val, priv->base + STM32_VREFBUF_CSR);\n\t}\n\n\tpm_runtime_mark_last_busy(priv->dev);\n\tpm_runtime_put_autosuspend(priv->dev);\n\n\treturn ret;\n}\n\nstatic int stm32_vrefbuf_disable(struct regulator_dev *rdev)\n{\n\tstruct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);\n\tu32 val;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = readl_relaxed(priv->base + STM32_VREFBUF_CSR);\n\tval &= ~STM32_ENVR;\n\twritel_relaxed(val, priv->base + STM32_VREFBUF_CSR);\n\n\tpm_runtime_mark_last_busy(priv->dev);\n\tpm_runtime_put_autosuspend(priv->dev);\n\n\treturn 0;\n}\n\nstatic int stm32_vrefbuf_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = readl_relaxed(priv->base + STM32_VREFBUF_CSR) & STM32_ENVR;\n\n\tpm_runtime_mark_last_busy(priv->dev);\n\tpm_runtime_put_autosuspend(priv->dev);\n\n\treturn ret;\n}\n\nstatic int stm32_vrefbuf_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\t unsigned sel)\n{\n\tstruct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);\n\tu32 val;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = readl_relaxed(priv->base + STM32_VREFBUF_CSR);\n\tval = (val & ~STM32_VRS) | FIELD_PREP(STM32_VRS, sel);\n\twritel_relaxed(val, priv->base + STM32_VREFBUF_CSR);\n\n\tpm_runtime_mark_last_busy(priv->dev);\n\tpm_runtime_put_autosuspend(priv->dev);\n\n\treturn 0;\n}\n\nstatic int stm32_vrefbuf_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);\n\tu32 val;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = readl_relaxed(priv->base + STM32_VREFBUF_CSR);\n\tret = FIELD_GET(STM32_VRS, val);\n\n\tpm_runtime_mark_last_busy(priv->dev);\n\tpm_runtime_put_autosuspend(priv->dev);\n\n\treturn ret;\n}\n\nstatic const struct regulator_ops stm32_vrefbuf_volt_ops = {\n\t.enable\t\t= stm32_vrefbuf_enable,\n\t.disable\t= stm32_vrefbuf_disable,\n\t.is_enabled\t= stm32_vrefbuf_is_enabled,\n\t.get_voltage_sel = stm32_vrefbuf_get_voltage_sel,\n\t.set_voltage_sel = stm32_vrefbuf_set_voltage_sel,\n\t.list_voltage\t= regulator_list_voltage_table,\n};\n\nstatic const struct regulator_desc stm32_vrefbuf_regu = {\n\t.name = \"vref\",\n\t.supply_name = \"vdda\",\n\t.volt_table = stm32_vrefbuf_voltages,\n\t.n_voltages = ARRAY_SIZE(stm32_vrefbuf_voltages),\n\t.ops = &stm32_vrefbuf_volt_ops,\n\t.off_on_delay = 1000,\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n};\n\nstatic int stm32_vrefbuf_probe(struct platform_device *pdev)\n{\n\tstruct stm32_vrefbuf *priv;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->dev = &pdev->dev;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev,\n\t\t\t\t\t STM32_VREFBUF_AUTO_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"clk prepare failed with error %d\\n\", ret);\n\t\tgoto err_pm_stop;\n\t}\n\n\tconfig.dev = &pdev->dev;\n\tconfig.driver_data = priv;\n\tconfig.of_node = pdev->dev.of_node;\n\tconfig.init_data = of_get_regulator_init_data(&pdev->dev,\n\t\t\t\t\t\t      pdev->dev.of_node,\n\t\t\t\t\t\t      &stm32_vrefbuf_regu);\n\n\trdev = regulator_register(&pdev->dev, &stm32_vrefbuf_regu, &config);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\t\tdev_err(&pdev->dev, \"register failed with error %d\\n\", ret);\n\t\tgoto err_clk_dis;\n\t}\n\tplatform_set_drvdata(pdev, rdev);\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\nerr_clk_dis:\n\tclk_disable_unprepare(priv->clk);\nerr_pm_stop:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic int stm32_vrefbuf_remove(struct platform_device *pdev)\n{\n\tstruct regulator_dev *rdev = platform_get_drvdata(pdev);\n\tstruct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tregulator_unregister(rdev);\n\tclk_disable_unprepare(priv->clk);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\treturn 0;\n};\n\nstatic int __maybe_unused stm32_vrefbuf_runtime_suspend(struct device *dev)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tstruct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_vrefbuf_runtime_resume(struct device *dev)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tstruct stm32_vrefbuf *priv = rdev_get_drvdata(rdev);\n\n\treturn clk_prepare_enable(priv->clk);\n}\n\nstatic const struct dev_pm_ops stm32_vrefbuf_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(stm32_vrefbuf_runtime_suspend,\n\t\t\t   stm32_vrefbuf_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id __maybe_unused stm32_vrefbuf_of_match[] = {\n\t{ .compatible = \"st,stm32-vrefbuf\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_vrefbuf_of_match);\n\nstatic struct platform_driver stm32_vrefbuf_driver = {\n\t.probe = stm32_vrefbuf_probe,\n\t.remove = stm32_vrefbuf_remove,\n\t.driver = {\n\t\t.name  = \"stm32-vrefbuf\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(stm32_vrefbuf_of_match),\n\t\t.pm = &stm32_vrefbuf_pm_ops,\n\t},\n};\nmodule_platform_driver(stm32_vrefbuf_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Fabrice Gasnier <fabrice.gasnier@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 VREFBUF driver\");\nMODULE_ALIAS(\"platform:stm32-vrefbuf\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}