{
  "module_name": "cpcap-regulator.c",
  "hash_id": "c3a4d128aea352796c6bf5d99623ee2b19dd3f2e7dbf5ce2aa6e521afe7810c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/cpcap-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/mfd/motorola-cpcap.h>\n\n \n\n \n#define CPCAP_BIT_VSDIO_SEL\t\tBIT(15)\n#define CPCAP_BIT_VDIG_SEL\t\tBIT(14)\n#define CPCAP_BIT_VCAM_SEL\t\tBIT(13)\n#define CPCAP_BIT_SW6_SEL\t\tBIT(12)\n#define CPCAP_BIT_SW5_SEL\t\tBIT(11)\n#define CPCAP_BIT_SW4_SEL\t\tBIT(10)\n#define CPCAP_BIT_SW3_SEL\t\tBIT(9)\n#define CPCAP_BIT_SW2_SEL\t\tBIT(8)\n#define CPCAP_BIT_SW1_SEL\t\tBIT(7)\n\n \n#define CPCAP_BIT_VUSBINT2_SEL\t\tBIT(15)\n#define CPCAP_BIT_VUSBINT1_SEL\t\tBIT(14)\n#define CPCAP_BIT_VVIB_SEL\t\tBIT(13)\n#define CPCAP_BIT_VWLAN1_SEL\t\tBIT(12)\n#define CPCAP_BIT_VRF1_SEL\t\tBIT(11)\n#define CPCAP_BIT_VHVIO_SEL\t\tBIT(10)\n#define CPCAP_BIT_VDAC_SEL\t\tBIT(9)\n#define CPCAP_BIT_VUSB_SEL\t\tBIT(8)\n#define CPCAP_BIT_VSIM_SEL\t\tBIT(7)\n#define CPCAP_BIT_VRFREF_SEL\t\tBIT(6)\n#define CPCAP_BIT_VPLL_SEL\t\tBIT(5)\n#define CPCAP_BIT_VFUSE_SEL\t\tBIT(4)\n#define CPCAP_BIT_VCSI_SEL\t\tBIT(3)\n#define CPCAP_BIT_SPARE_14_2\t\tBIT(2)\n#define CPCAP_BIT_VWLAN2_SEL\t\tBIT(1)\n#define CPCAP_BIT_VRF2_SEL\t\tBIT(0)\n\n \n#define CPCAP_BIT_VAUDIO_SEL\t\tBIT(0)\n\n \n#define CPCAP_BIT_AUDIO_LOW_PWR\t\tBIT(6)\n#define CPCAP_BIT_AUD_LOWPWR_SPEED\tBIT(5)\n#define CPCAP_BIT_VAUDIOPRISTBY\t\tBIT(4)\n#define CPCAP_BIT_VAUDIO_MODE1\t\tBIT(2)\n#define CPCAP_BIT_VAUDIO_MODE0\t\tBIT(1)\n#define CPCAP_BIT_V_AUDIO_EN\t\tBIT(0)\n\n#define CPCAP_BIT_AUDIO_NORMAL_MODE\t0x00\n\n \n#define CPCAP_REG_OFF_MODE_SEC\t\tBIT(15)\n\n \nstruct cpcap_regulator {\n\tstruct regulator_desc rdesc;\n\tconst u16 assign_reg;\n\tconst u16 assign_mask;\n};\n\n#define CPCAP_REG(_ID, reg, assignment_reg, assignment_mask, val_tbl,\t\\\n\t\tmode_mask, volt_mask, mode_val, off_val,\t\t\\\n\t\tvolt_trans_time) {\t\t\t\t\t\\\n\t.rdesc = {\t\t\t\t\t\t\t\\\n\t\t.name = #_ID,\t\t\t\t\t\t\\\n\t\t.of_match = of_match_ptr(#_ID),\t\t\t\t\\\n\t\t.ops = &cpcap_regulator_ops,\t\t\t\t\\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\t\t\\\n\t\t.type = REGULATOR_VOLTAGE,\t\t\t\t\\\n\t\t.id = CPCAP_##_ID,\t\t\t\t\t\\\n\t\t.owner = THIS_MODULE,\t\t\t\t\t\\\n\t\t.n_voltages = ARRAY_SIZE(val_tbl),\t\t\t\\\n\t\t.volt_table = (val_tbl),\t\t\t\t\\\n\t\t.vsel_reg = (reg),\t\t\t\t\t\\\n\t\t.vsel_mask = (volt_mask),\t\t\t\t\\\n\t\t.enable_reg = (reg),\t\t\t\t\t\\\n\t\t.enable_mask = (mode_mask),\t\t\t\t\\\n\t\t.enable_val = (mode_val),\t\t\t\t\\\n\t\t.disable_val = (off_val),\t\t\t\t\\\n\t\t.ramp_delay = (volt_trans_time),\t\t\t\\\n\t\t.of_map_mode = cpcap_map_mode,\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.assign_reg = (assignment_reg),\t\t\t\t\t\\\n\t.assign_mask = (assignment_mask),\t\t\t\t\\\n}\n\nstruct cpcap_ddata {\n\tstruct regmap *reg;\n\tstruct device *dev;\n\tconst struct cpcap_regulator *soc;\n};\n\nenum cpcap_regulator_id {\n\tCPCAP_SW1,\n\tCPCAP_SW2,\n\tCPCAP_SW3,\n\tCPCAP_SW4,\n\tCPCAP_SW5,\n\tCPCAP_SW6,\n\tCPCAP_VCAM,\n\tCPCAP_VCSI,\n\tCPCAP_VDAC,\n\tCPCAP_VDIG,\n\tCPCAP_VFUSE,\n\tCPCAP_VHVIO,\n\tCPCAP_VSDIO,\n\tCPCAP_VPLL,\n\tCPCAP_VRF1,\n\tCPCAP_VRF2,\n\tCPCAP_VRFREF,\n\tCPCAP_VWLAN1,\n\tCPCAP_VWLAN2,\n\tCPCAP_VSIM,\n\tCPCAP_VSIMCARD,\n\tCPCAP_VVIB,\n\tCPCAP_VUSB,\n\tCPCAP_VAUDIO,\n\tCPCAP_NR_REGULATORS,\n};\n\n \nstatic int cpcap_regulator_enable(struct regulator_dev *rdev)\n{\n\tstruct cpcap_regulator *regulator = rdev_get_drvdata(rdev);\n\tint error;\n\n\terror = regulator_enable_regmap(rdev);\n\tif (error)\n\t\treturn error;\n\n\tif (rdev->desc->enable_val & CPCAP_REG_OFF_MODE_SEC) {\n\t\terror = regmap_update_bits(rdev->regmap, regulator->assign_reg,\n\t\t\t\t\t   regulator->assign_mask,\n\t\t\t\t\t   regulator->assign_mask);\n\t\tif (error)\n\t\t\tregulator_disable_regmap(rdev);\n\t}\n\n\treturn error;\n}\n\n \nstatic int cpcap_regulator_disable(struct regulator_dev *rdev)\n{\n\tstruct cpcap_regulator *regulator = rdev_get_drvdata(rdev);\n\tint error;\n\n\tif (rdev->desc->enable_val & CPCAP_REG_OFF_MODE_SEC) {\n\t\terror = regmap_update_bits(rdev->regmap, regulator->assign_reg,\n\t\t\t\t\t   regulator->assign_mask, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = regulator_disable_regmap(rdev);\n\tif (error && (rdev->desc->enable_val & CPCAP_REG_OFF_MODE_SEC)) {\n\t\tregmap_update_bits(rdev->regmap, regulator->assign_reg,\n\t\t\t\t   regulator->assign_mask,\n\t\t\t\t   regulator->assign_mask);\n\t}\n\n\treturn error;\n}\n\nstatic unsigned int cpcap_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase CPCAP_BIT_AUDIO_NORMAL_MODE:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase CPCAP_BIT_AUDIO_LOW_PWR:\n\t\treturn REGULATOR_MODE_STANDBY;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic unsigned int cpcap_regulator_get_mode(struct regulator_dev *rdev)\n{\n\tint value;\n\n\tregmap_read(rdev->regmap, rdev->desc->enable_reg, &value);\n\n\tif (value & CPCAP_BIT_AUDIO_LOW_PWR)\n\t\treturn REGULATOR_MODE_STANDBY;\n\n\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int cpcap_regulator_set_mode(struct regulator_dev *rdev,\n\t\t\t\t    unsigned int mode)\n{\n\tint value;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tvalue = CPCAP_BIT_AUDIO_NORMAL_MODE;\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tvalue = CPCAP_BIT_AUDIO_LOW_PWR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\n\t\t\t\t  CPCAP_BIT_AUDIO_LOW_PWR, value);\n}\n\nstatic const struct regulator_ops cpcap_regulator_ops = {\n\t.enable = cpcap_regulator_enable,\n\t.disable = cpcap_regulator_disable,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_iterate,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_mode = cpcap_regulator_get_mode,\n\t.set_mode = cpcap_regulator_set_mode,\n};\n\nstatic const unsigned int unknown_val_tbl[] = { 0, };\nstatic const unsigned int sw2_sw4_val_tbl[] = { 612500, 625000, 637500,\n\t\t\t\t\t\t650000, 662500, 675000,\n\t\t\t\t\t\t687500, 700000, 712500,\n\t\t\t\t\t\t725000, 737500, 750000,\n\t\t\t\t\t\t762500, 775000, 787500,\n\t\t\t\t\t\t800000, 812500, 825000,\n\t\t\t\t\t\t837500, 850000, 862500,\n\t\t\t\t\t\t875000, 887500, 900000,\n\t\t\t\t\t\t912500, 925000, 937500,\n\t\t\t\t\t\t950000, 962500, 975000,\n\t\t\t\t\t\t987500, 1000000, 1012500,\n\t\t\t\t\t\t1025000, 1037500, 1050000,\n\t\t\t\t\t\t1062500, 1075000, 1087500,\n\t\t\t\t\t\t1100000, 1112500, 1125000,\n\t\t\t\t\t\t1137500, 1150000, 1162500,\n\t\t\t\t\t\t1175000, 1187500, 1200000,\n\t\t\t\t\t\t1212500, 1225000, 1237500,\n\t\t\t\t\t\t1250000, 1262500, 1275000,\n\t\t\t\t\t\t1287500, 1300000, 1312500,\n\t\t\t\t\t\t1325000, 1337500, 1350000,\n\t\t\t\t\t\t1362500, 1375000, 1387500,\n\t\t\t\t\t\t1400000, 1412500, 1425000,\n\t\t\t\t\t\t1437500, 1450000, 1462500, };\nstatic const unsigned int sw5_val_tbl[] = { 0, 5050000, };\nstatic const unsigned int vcam_val_tbl[] = { 2600000, 2700000, 2800000,\n\t\t\t\t\t     2900000, };\nstatic const unsigned int vcsi_val_tbl[] = { 1200000, 1800000, };\nstatic const unsigned int vdac_val_tbl[] = { 1200000, 1500000, 1800000,\n\t\t\t\t\t     2500000,};\nstatic const unsigned int vdig_val_tbl[] = { 1200000, 1350000, 1500000,\n\t\t\t\t\t     1875000, };\nstatic const unsigned int vfuse_val_tbl[] = { 1500000, 1600000, 1700000,\n\t\t\t\t\t      1800000, 1900000, 2000000,\n\t\t\t\t\t      2100000, 2200000, 2300000,\n\t\t\t\t\t      2400000, 2500000, 2600000,\n\t\t\t\t\t      2700000, 3150000, };\nstatic const unsigned int vhvio_val_tbl[] = { 2775000, };\nstatic const unsigned int vsdio_val_tbl[] = { 1500000, 1600000, 1800000,\n\t\t\t\t\t      2600000, 2700000, 2800000,\n\t\t\t\t\t      2900000, 3000000, };\nstatic const unsigned int vpll_val_tbl[] = { 1200000, 1300000, 1400000,\n\t\t\t\t\t     1800000, };\n \nstatic const unsigned int vrf1_val_tbl[] = { 2775000, 2500000, };\nstatic const unsigned int vrf2_val_tbl[] = { 0, 2775000, };\nstatic const unsigned int vrfref_val_tbl[] = { 2500000, 2775000, };\nstatic const unsigned int vwlan1_val_tbl[] = { 1800000, 1900000, };\nstatic const unsigned int vwlan2_val_tbl[] = { 2775000, 3000000, 3300000,\n\t\t\t\t\t       3300000, };\nstatic const unsigned int vsim_val_tbl[] = { 1800000, 2900000, };\nstatic const unsigned int vsimcard_val_tbl[] = { 1800000, 2900000, };\nstatic const unsigned int vvib_val_tbl[] = { 1300000, 1800000, 2000000,\n\t\t\t\t\t     3000000, };\nstatic const unsigned int vusb_val_tbl[] = { 0, 3300000, };\nstatic const unsigned int vaudio_val_tbl[] = { 0, 2775000, };\n\n \nstatic const struct cpcap_regulator omap4_regulators[] = {\n\tCPCAP_REG(SW1, CPCAP_REG_S1C1, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_SW1_SEL, unknown_val_tbl,\n\t\t  0, 0, 0, 0, 0),\n\tCPCAP_REG(SW2, CPCAP_REG_S2C1, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_SW2_SEL, unknown_val_tbl,\n\t\t  0, 0, 0, 0, 0),\n\tCPCAP_REG(SW3, CPCAP_REG_S3C, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_SW3_SEL, unknown_val_tbl,\n\t\t  0, 0, 0, 0, 0),\n\tCPCAP_REG(SW4, CPCAP_REG_S4C1, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_SW4_SEL, unknown_val_tbl,\n\t\t  0, 0, 0, 0, 0),\n\tCPCAP_REG(SW5, CPCAP_REG_S5C, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_SW5_SEL, sw5_val_tbl,\n\t\t  0x28, 0, 0x20 | CPCAP_REG_OFF_MODE_SEC, 0, 0),\n\tCPCAP_REG(SW6, CPCAP_REG_S6C, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_SW6_SEL, unknown_val_tbl,\n\t\t  0, 0, 0, 0, 0),\n\tCPCAP_REG(VCAM, CPCAP_REG_VCAMC, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_VCAM_SEL, vcam_val_tbl,\n\t\t  0x87, 0x30, 0x3, 0, 420),\n\tCPCAP_REG(VCSI, CPCAP_REG_VCSIC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VCSI_SEL, vcsi_val_tbl,\n\t\t  0x47, 0x10, 0x43, 0x41, 350),\n\tCPCAP_REG(VDAC, CPCAP_REG_VDACC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VDAC_SEL, vdac_val_tbl,\n\t\t  0x87, 0x30, 0x3, 0, 420),\n\tCPCAP_REG(VDIG, CPCAP_REG_VDIGC, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_VDIG_SEL, vdig_val_tbl,\n\t\t  0x87, 0x30, 0x82, 0, 420),\n\tCPCAP_REG(VFUSE, CPCAP_REG_VFUSEC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VFUSE_SEL, vfuse_val_tbl,\n\t\t  0x80, 0xf, 0x80, 0, 420),\n\tCPCAP_REG(VHVIO, CPCAP_REG_VHVIOC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VHVIO_SEL, vhvio_val_tbl,\n\t\t  0x17, 0, 0, 0x12, 0),\n\tCPCAP_REG(VSDIO, CPCAP_REG_VSDIOC, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_VSDIO_SEL, vsdio_val_tbl,\n\t\t  0x87, 0x38, 0x82, 0, 420),\n\tCPCAP_REG(VPLL, CPCAP_REG_VPLLC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VPLL_SEL, vpll_val_tbl,\n\t\t  0x43, 0x18, 0x2, 0, 420),\n\tCPCAP_REG(VRF1, CPCAP_REG_VRF1C, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VRF1_SEL, vrf1_val_tbl,\n\t\t  0xac, 0x2, 0x4, 0, 10),\n\tCPCAP_REG(VRF2, CPCAP_REG_VRF2C, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VRF2_SEL, vrf2_val_tbl,\n\t\t  0x23, 0x8, 0, 0, 10),\n\tCPCAP_REG(VRFREF, CPCAP_REG_VRFREFC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VRFREF_SEL, vrfref_val_tbl,\n\t\t  0x23, 0x8, 0, 0, 420),\n\tCPCAP_REG(VWLAN1, CPCAP_REG_VWLAN1C, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VWLAN1_SEL, vwlan1_val_tbl,\n\t\t  0x47, 0x10, 0, 0, 420),\n\tCPCAP_REG(VWLAN2, CPCAP_REG_VWLAN2C, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VWLAN2_SEL, vwlan2_val_tbl,\n\t\t  0x20c, 0xc0, 0x20c, 0, 420),\n\tCPCAP_REG(VSIM, CPCAP_REG_VSIMC, CPCAP_REG_ASSIGN3,\n\t\t  0xffff, vsim_val_tbl,\n\t\t  0x23, 0x8, 0x3, 0, 420),\n\tCPCAP_REG(VSIMCARD, CPCAP_REG_VSIMC, CPCAP_REG_ASSIGN3,\n\t\t  0xffff, vsimcard_val_tbl,\n\t\t  0x1e80, 0x8, 0x1e00, 0, 420),\n\tCPCAP_REG(VVIB, CPCAP_REG_VVIBC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VVIB_SEL, vvib_val_tbl,\n\t\t  0x1, 0xc, 0x1, 0, 500),\n\tCPCAP_REG(VUSB, CPCAP_REG_VUSBC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VUSB_SEL, vusb_val_tbl,\n\t\t  0x11c, 0x40, 0xc, 0, 0),\n\tCPCAP_REG(VAUDIO, CPCAP_REG_VAUDIOC, CPCAP_REG_ASSIGN4,\n\t\t  CPCAP_BIT_VAUDIO_SEL, vaudio_val_tbl,\n\t\t  0x16, 0x1, 0x4, 0, 0),\n\t{   },\n};\n\nstatic const struct cpcap_regulator xoom_regulators[] = {\n\tCPCAP_REG(SW1, CPCAP_REG_S1C1, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_SW1_SEL, unknown_val_tbl,\n\t\t  0, 0, 0, 0, 0),\n\tCPCAP_REG(SW2, CPCAP_REG_S2C1, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_SW2_SEL, sw2_sw4_val_tbl,\n\t\t  0xf00, 0x7f, 0x800, 0, 120),\n\tCPCAP_REG(SW3, CPCAP_REG_S3C, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_SW3_SEL, unknown_val_tbl,\n\t\t  0, 0, 0, 0, 0),\n\tCPCAP_REG(SW4, CPCAP_REG_S4C1, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_SW4_SEL, sw2_sw4_val_tbl,\n\t\t  0xf00, 0x7f, 0x900, 0, 100),\n\tCPCAP_REG(SW5, CPCAP_REG_S5C, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_SW5_SEL, sw5_val_tbl,\n\t\t  0x2a, 0, 0x22, 0, 0),\n\tCPCAP_REG(SW6, CPCAP_REG_S6C, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_SW6_SEL, unknown_val_tbl,\n\t\t  0, 0, 0, 0, 0),\n\tCPCAP_REG(VCAM, CPCAP_REG_VCAMC, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_VCAM_SEL, vcam_val_tbl,\n\t\t  0x87, 0x30, 0x7, 0, 420),\n\tCPCAP_REG(VCSI, CPCAP_REG_VCSIC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VCSI_SEL, vcsi_val_tbl,\n\t\t  0x47, 0x10, 0x7, 0, 350),\n\tCPCAP_REG(VDAC, CPCAP_REG_VDACC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VDAC_SEL, vdac_val_tbl,\n\t\t  0x87, 0x30, 0x3, 0, 420),\n\tCPCAP_REG(VDIG, CPCAP_REG_VDIGC, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_VDIG_SEL, vdig_val_tbl,\n\t\t  0x87, 0x30, 0x5, 0, 420),\n\tCPCAP_REG(VFUSE, CPCAP_REG_VFUSEC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VFUSE_SEL, vfuse_val_tbl,\n\t\t  0x80, 0xf, 0x80, 0, 420),\n\tCPCAP_REG(VHVIO, CPCAP_REG_VHVIOC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VHVIO_SEL, vhvio_val_tbl,\n\t\t  0x17, 0, 0x2, 0, 0),\n\tCPCAP_REG(VSDIO, CPCAP_REG_VSDIOC, CPCAP_REG_ASSIGN2,\n\t\t  CPCAP_BIT_VSDIO_SEL, vsdio_val_tbl,\n\t\t  0x87, 0x38, 0x2, 0, 420),\n\tCPCAP_REG(VPLL, CPCAP_REG_VPLLC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VPLL_SEL, vpll_val_tbl,\n\t\t  0x43, 0x18, 0x1, 0, 420),\n\tCPCAP_REG(VRF1, CPCAP_REG_VRF1C, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VRF1_SEL, vrf1_val_tbl,\n\t\t  0xac, 0x2, 0xc, 0, 10),\n\tCPCAP_REG(VRF2, CPCAP_REG_VRF2C, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VRF2_SEL, vrf2_val_tbl,\n\t\t  0x23, 0x8, 0x3, 0, 10),\n\tCPCAP_REG(VRFREF, CPCAP_REG_VRFREFC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VRFREF_SEL, vrfref_val_tbl,\n\t\t  0x23, 0x8, 0x3, 0, 420),\n\tCPCAP_REG(VWLAN1, CPCAP_REG_VWLAN1C, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VWLAN1_SEL, vwlan1_val_tbl,\n\t\t  0x47, 0x10, 0x5, 0, 420),\n\tCPCAP_REG(VWLAN2, CPCAP_REG_VWLAN2C, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VWLAN2_SEL, vwlan2_val_tbl,\n\t\t  0x20c, 0xc0, 0x8, 0, 420),\n\tCPCAP_REG(VSIM, CPCAP_REG_VSIMC, CPCAP_REG_ASSIGN3,\n\t\t  0xffff, vsim_val_tbl,\n\t\t  0x23, 0x8, 0x3, 0, 420),\n\tCPCAP_REG(VSIMCARD, CPCAP_REG_VSIMC, CPCAP_REG_ASSIGN3,\n\t\t  0xffff, vsimcard_val_tbl,\n\t\t  0x1e80, 0x8, 0x1e00, 0, 420),\n\tCPCAP_REG(VVIB, CPCAP_REG_VVIBC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VVIB_SEL, vvib_val_tbl,\n\t\t  0x1, 0xc, 0, 0x1, 500),\n\tCPCAP_REG(VUSB, CPCAP_REG_VUSBC, CPCAP_REG_ASSIGN3,\n\t\t  CPCAP_BIT_VUSB_SEL, vusb_val_tbl,\n\t\t  0x11c, 0x40, 0xc, 0, 0),\n\tCPCAP_REG(VAUDIO, CPCAP_REG_VAUDIOC, CPCAP_REG_ASSIGN4,\n\t\t  CPCAP_BIT_VAUDIO_SEL, vaudio_val_tbl,\n\t\t  0x16, 0x1, 0x4, 0, 0),\n\t{   },\n};\n\nstatic const struct of_device_id cpcap_regulator_id_table[] = {\n\t{\n\t\t.compatible = \"motorola,cpcap-regulator\",\n\t},\n\t{\n\t\t.compatible = \"motorola,mapphone-cpcap-regulator\",\n\t\t.data = omap4_regulators,\n\t},\n\t{\n\t\t.compatible = \"motorola,xoom-cpcap-regulator\",\n\t\t.data = xoom_regulators,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cpcap_regulator_id_table);\n\nstatic int cpcap_regulator_probe(struct platform_device *pdev)\n{\n\tstruct cpcap_ddata *ddata;\n\tconst struct cpcap_regulator *match_data;\n\tstruct regulator_config config;\n\tint i;\n\n\tmatch_data = of_device_get_match_data(&pdev->dev);\n\tif (!match_data) {\n\t\tdev_err(&pdev->dev, \"no configuration data found\\n\");\n\n\t\treturn -ENODEV;\n\t}\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tddata->reg = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!ddata->reg)\n\t\treturn -ENODEV;\n\n\tddata->dev = &pdev->dev;\n\tddata->soc = match_data;\n\tplatform_set_drvdata(pdev, ddata);\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.dev = &pdev->dev;\n\tconfig.regmap = ddata->reg;\n\n\tfor (i = 0; i < CPCAP_NR_REGULATORS; i++) {\n\t\tconst struct cpcap_regulator *regulator = &ddata->soc[i];\n\t\tstruct regulator_dev *rdev;\n\n\t\tif (!regulator->rdesc.name)\n\t\t\tbreak;\n\n\t\tif (regulator->rdesc.volt_table == unknown_val_tbl)\n\t\t\tcontinue;\n\n\t\tconfig.driver_data = (void *)regulator;\n\t\trdev = devm_regulator_register(&pdev->dev,\n\t\t\t\t\t       &regulator->rdesc,\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&pdev->dev, \"failed to register regulator %s\\n\",\n\t\t\t\tregulator->rdesc.name);\n\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver cpcap_regulator_driver = {\n\t.probe\t\t= cpcap_regulator_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"cpcap-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(cpcap_regulator_id_table),\n\t},\n};\n\nmodule_platform_driver(cpcap_regulator_driver);\n\nMODULE_ALIAS(\"platform:cpcap-regulator\");\nMODULE_AUTHOR(\"Tony Lindgren <tony@atomide.com>\");\nMODULE_DESCRIPTION(\"CPCAP regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}