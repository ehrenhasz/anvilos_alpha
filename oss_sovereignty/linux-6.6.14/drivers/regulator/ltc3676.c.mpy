{
  "module_name": "ltc3676.c",
  "hash_id": "fb96f5f8a40893923c65de1e79f288f2108ab9f2a0651d982e111576b0cdd5e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/ltc3676.c",
  "human_readable_source": "\n \n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n\n#define DRIVER_NAME\t\t\"ltc3676\"\n\n \n#define LTC3676_BUCK1     0x01\n#define LTC3676_BUCK2     0x02\n#define LTC3676_BUCK3     0x03\n#define LTC3676_BUCK4     0x04\n#define LTC3676_LDOA      0x05\n#define LTC3676_LDOB      0x06\n#define LTC3676_SQD1      0x07\n#define LTC3676_SQD2      0x08\n#define LTC3676_CNTRL     0x09\n#define LTC3676_DVB1A     0x0A\n#define LTC3676_DVB1B     0x0B\n#define LTC3676_DVB2A     0x0C\n#define LTC3676_DVB2B     0x0D\n#define LTC3676_DVB3A     0x0E\n#define LTC3676_DVB3B     0x0F\n#define LTC3676_DVB4A     0x10\n#define LTC3676_DVB4B     0x11\n#define LTC3676_MSKIRQ    0x12\n#define LTC3676_MSKPG     0x13\n#define LTC3676_USER      0x14\n#define LTC3676_IRQSTAT   0x15\n#define LTC3676_PGSTATL   0x16\n#define LTC3676_PGSTATRT  0x17\n#define LTC3676_HRST      0x1E\n#define LTC3676_CLIRQ     0x1F\n\n#define LTC3676_DVBxA_REF_SELECT\tBIT(5)\n#define LTC3676_DVBxB_PGOOD_MASK\tBIT(5)\n\n#define LTC3676_IRQSTAT_PGOOD_TIMEOUT\tBIT(3)\n#define LTC3676_IRQSTAT_UNDERVOLT_WARN\tBIT(4)\n#define LTC3676_IRQSTAT_UNDERVOLT_FAULT\tBIT(5)\n#define LTC3676_IRQSTAT_THERMAL_WARN\tBIT(6)\n#define LTC3676_IRQSTAT_THERMAL_FAULT\tBIT(7)\n\nenum ltc3676_reg {\n\tLTC3676_SW1,\n\tLTC3676_SW2,\n\tLTC3676_SW3,\n\tLTC3676_SW4,\n\tLTC3676_LDO1,\n\tLTC3676_LDO2,\n\tLTC3676_LDO3,\n\tLTC3676_LDO4,\n\tLTC3676_NUM_REGULATORS,\n};\n\nstruct ltc3676 {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct regulator_desc regulator_descs[LTC3676_NUM_REGULATORS];\n\tstruct regulator_dev *regulators[LTC3676_NUM_REGULATORS];\n};\n\nstatic int ltc3676_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tstruct ltc3676 *ltc3676 = rdev_get_drvdata(rdev);\n\tstruct device *dev = ltc3676->dev;\n\tint dcdc = rdev_get_id(rdev);\n\tint sel;\n\n\tdev_dbg(dev, \"%s id=%d uV=%d\\n\", __func__, dcdc, uV);\n\tsel = regulator_map_voltage_linear(rdev, uV, uV);\n\tif (sel < 0)\n\t\treturn sel;\n\n\t \n\treturn regmap_update_bits(ltc3676->regmap, rdev->desc->vsel_reg + 1,\n\t\t\t\t  rdev->desc->vsel_mask, sel);\n}\n\nstatic int ltc3676_set_suspend_mode(struct regulator_dev *rdev,\n\t\t\t\t    unsigned int mode)\n{\n\tstruct ltc3676 *ltc3676= rdev_get_drvdata(rdev);\n\tstruct device *dev = ltc3676->dev;\n\tint mask, val;\n\tint dcdc = rdev_get_id(rdev);\n\n\tdev_dbg(dev, \"%s id=%d mode=%d\\n\", __func__, dcdc, mode);\n\n\tmask = LTC3676_DVBxA_REF_SELECT;\n\tswitch (mode) {\n\tcase REGULATOR_MODE_STANDBY:\n\t\tval = 0;  \n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = LTC3676_DVBxA_REF_SELECT;  \n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&rdev->dev, \"%s: regulator mode: 0x%x not supported\\n\",\n\t\t\t rdev->desc->name, mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(ltc3676->regmap, rdev->desc->vsel_reg,\n\t\t\t\t  mask, val);\n}\n\nstatic int ltc3676_set_voltage_sel(struct regulator_dev *rdev, unsigned selector)\n{\n\tstruct ltc3676 *ltc3676 = rdev_get_drvdata(rdev);\n\tstruct device *dev = ltc3676->dev;\n\tint ret, dcdc = rdev_get_id(rdev);\n\n\tdev_dbg(dev, \"%s id=%d selector=%d\\n\", __func__, dcdc, selector);\n\n\tret = regmap_update_bits(ltc3676->regmap, rdev->desc->vsel_reg + 1,\n\t\t\t\t LTC3676_DVBxB_PGOOD_MASK,\n\t\t\t\t LTC3676_DVBxB_PGOOD_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regulator_set_voltage_sel_regmap(rdev, selector);\n}\n\nstatic inline unsigned int ltc3676_scale(unsigned int uV, u32 r1, u32 r2)\n{\n\tuint64_t tmp;\n\tif (uV == 0)\n\t\treturn 0;\n\ttmp = (uint64_t)uV * r1;\n\tdo_div(tmp, r2);\n\treturn uV + (unsigned int)tmp;\n}\n\nstatic int ltc3676_of_parse_cb(struct device_node *np,\n\t\t\t       const struct regulator_desc *desc,\n\t\t\t       struct regulator_config *config)\n{\n\tstruct ltc3676 *ltc3676 = config->driver_data;\n\tstruct regulator_desc *rdesc = &ltc3676->regulator_descs[desc->id];\n\tu32 r[2];\n\tint ret;\n\n\t \n\tif (desc->id == LTC3676_LDO3)\n\t\treturn 0;\n\n\tret = of_property_read_u32_array(np, \"lltc,fb-voltage-divider\", r, 2);\n\tif (ret) {\n\t\tdev_err(ltc3676->dev, \"Failed to parse voltage divider: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\trdesc->min_uV = ltc3676_scale(desc->min_uV, r[0], r[1]);\n\trdesc->uV_step = ltc3676_scale(desc->uV_step, r[0], r[1]);\n\trdesc->fixed_uV = ltc3676_scale(desc->fixed_uV, r[0], r[1]);\n\n\treturn 0;\n}\n\n \nstatic const struct regulator_ops ltc3676_linear_regulator_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = ltc3676_set_voltage_sel,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_suspend_voltage = ltc3676_set_suspend_voltage,\n\t.set_suspend_mode = ltc3676_set_suspend_mode,\n};\n\n \nstatic const struct regulator_ops ltc3676_fixed_standby_regulator_ops = {\n};\n\n \nstatic const struct regulator_ops ltc3676_fixed_regulator_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n};\n\n#define LTC3676_REG(_id, _name, _ops, en_reg, en_bit, dvba_reg, dvb_mask)   \\\n\t[LTC3676_ ## _id] = {                                        \\\n\t\t.name = #_name,                                \\\n\t\t.of_match = of_match_ptr(#_name),              \\\n\t\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t\t.of_parse_cb = ltc3676_of_parse_cb,            \\\n\t\t.n_voltages = (dvb_mask) + 1,                  \\\n\t\t.min_uV = (dvba_reg) ? 412500 : 0,             \\\n\t\t.uV_step = (dvba_reg) ? 12500 : 0,             \\\n\t\t.ramp_delay = (dvba_reg) ? 800 : 0,            \\\n\t\t.fixed_uV = (dvb_mask) ? 0 : 725000,           \\\n\t\t.ops = &ltc3676_ ## _ops ## _regulator_ops,    \\\n\t\t.type = REGULATOR_VOLTAGE,                     \\\n\t\t.id = LTC3676_ ## _id,                         \\\n\t\t.owner = THIS_MODULE,                          \\\n\t\t.vsel_reg = (dvba_reg),                        \\\n\t\t.vsel_mask = (dvb_mask),                       \\\n\t\t.enable_reg = (en_reg),                        \\\n\t\t.enable_mask = (1 << en_bit),                  \\\n\t}\n\n#define LTC3676_LINEAR_REG(_id, _name, _en, _dvba)                     \\\n\tLTC3676_REG(_id, _name, linear,                                \\\n\t\t    LTC3676_ ## _en, 7,                                \\\n\t\t    LTC3676_ ## _dvba, 0x1f)\n\n#define LTC3676_FIXED_REG(_id, _name, _en_reg, _en_bit)                \\\n\tLTC3676_REG(_id, _name, fixed, LTC3676_ ## _en_reg, _en_bit, 0, 0)\n\nstatic const struct regulator_desc ltc3676_regulators[LTC3676_NUM_REGULATORS] = {\n\tLTC3676_LINEAR_REG(SW1, sw1, BUCK1, DVB1A),\n\tLTC3676_LINEAR_REG(SW2, sw2, BUCK2, DVB2A),\n\tLTC3676_LINEAR_REG(SW3, sw3, BUCK3, DVB3A),\n\tLTC3676_LINEAR_REG(SW4, sw4, BUCK4, DVB4A),\n\tLTC3676_REG(LDO1, ldo1, fixed_standby, 0, 0, 0, 0),\n\tLTC3676_FIXED_REG(LDO2, ldo2, LDOA, 2),\n\tLTC3676_FIXED_REG(LDO3, ldo3, LDOA, 5),\n\tLTC3676_FIXED_REG(LDO4, ldo4, LDOB, 2),\n};\n\nstatic bool ltc3676_readable_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LTC3676_BUCK1 ... LTC3676_IRQSTAT:\n\tcase LTC3676_HRST:\n\tcase LTC3676_CLIRQ:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool ltc3676_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LTC3676_IRQSTAT ... LTC3676_PGSTATRT:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const struct regmap_config ltc3676_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.writeable_reg = ltc3676_readable_writeable_reg,\n\t.readable_reg = ltc3676_readable_writeable_reg,\n\t.volatile_reg = ltc3676_volatile_reg,\n\t.max_register = LTC3676_CLIRQ,\n\t.use_single_read = true,\n\t.use_single_write = true,\n\t.cache_type = REGCACHE_MAPLE,\n};\n\nstatic irqreturn_t ltc3676_isr(int irq, void *dev_id)\n{\n\tstruct ltc3676 *ltc3676 = dev_id;\n\tstruct device *dev = ltc3676->dev;\n\tunsigned int i, irqstat, event;\n\n\tregmap_read(ltc3676->regmap, LTC3676_IRQSTAT, &irqstat);\n\n\tdev_dbg(dev, \"irq%d irqstat=0x%02x\\n\", irq, irqstat);\n\tif (irqstat & LTC3676_IRQSTAT_THERMAL_WARN) {\n\t\tdev_warn(dev, \"Over-temperature Warning\\n\");\n\t\tevent = REGULATOR_EVENT_OVER_TEMP;\n\t\tfor (i = 0; i < LTC3676_NUM_REGULATORS; i++)\n\t\t\tregulator_notifier_call_chain(ltc3676->regulators[i],\n\t\t\t\t\t\t      event, NULL);\n\t}\n\n\tif (irqstat & LTC3676_IRQSTAT_UNDERVOLT_WARN) {\n\t\tdev_info(dev, \"Undervoltage Warning\\n\");\n\t\tevent = REGULATOR_EVENT_UNDER_VOLTAGE;\n\t\tfor (i = 0; i < LTC3676_NUM_REGULATORS; i++)\n\t\t\tregulator_notifier_call_chain(ltc3676->regulators[i],\n\t\t\t\t\t\t      event, NULL);\n\t}\n\n\t \n\tregmap_write(ltc3676->regmap, LTC3676_CLIRQ, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ltc3676_regulator_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct regulator_init_data *init_data = dev_get_platdata(dev);\n\tstruct regulator_desc *descs;\n\tstruct ltc3676 *ltc3676;\n\tint i, ret;\n\n\tltc3676 = devm_kzalloc(dev, sizeof(*ltc3676), GFP_KERNEL);\n\tif (!ltc3676)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, ltc3676);\n\tltc3676->dev = dev;\n\n\tdescs = ltc3676->regulator_descs;\n\tmemcpy(descs, ltc3676_regulators, sizeof(ltc3676_regulators));\n\tdescs[LTC3676_LDO3].fixed_uV = 1800000;  \n\n\tltc3676->regmap = devm_regmap_init_i2c(client, &ltc3676_regmap_config);\n\tif (IS_ERR(ltc3676->regmap)) {\n\t\tret = PTR_ERR(ltc3676->regmap);\n\t\tdev_err(dev, \"failed to initialize regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < LTC3676_NUM_REGULATORS; i++) {\n\t\tstruct regulator_desc *desc = &ltc3676->regulator_descs[i];\n\t\tstruct regulator_config config = { };\n\n\t\tif (init_data)\n\t\t\tconfig.init_data = &init_data[i];\n\n\t\tconfig.dev = dev;\n\t\tconfig.driver_data = ltc3676;\n\n\t\tltc3676->regulators[i] = devm_regulator_register(dev, desc,\n\t\t\t\t\t\t\t\t &config);\n\t\tif (IS_ERR(ltc3676->regulators[i])) {\n\t\t\tret = PTR_ERR(ltc3676->regulators[i]);\n\t\t\tdev_err(dev, \"failed to register regulator %s: %d\\n\",\n\t\t\t\tdesc->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tregmap_write(ltc3676->regmap, LTC3676_CLIRQ, 0);\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\t\tltc3676_isr,\n\t\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\tclient->name, ltc3676);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to request IRQ: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id ltc3676_i2c_id[] = {\n\t{ \"ltc3676\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ltc3676_i2c_id);\n\nstatic const struct of_device_id __maybe_unused ltc3676_of_match[] = {\n\t{ .compatible = \"lltc,ltc3676\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ltc3676_of_match);\n\nstatic struct i2c_driver ltc3676_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(ltc3676_of_match),\n\t},\n\t.probe = ltc3676_regulator_probe,\n\t.id_table = ltc3676_i2c_id,\n};\nmodule_i2c_driver(ltc3676_driver);\n\nMODULE_AUTHOR(\"Tim Harvey <tharvey@gateworks.com>\");\nMODULE_DESCRIPTION(\"Regulator driver for Linear Technology LTC3676\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}