{
  "module_name": "ti-abb-regulator.c",
  "hash_id": "caf36e541e30945ec085095d6e8c299820c3b0e0c8ea805eabde721f3f75a201",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/ti-abb-regulator.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n\n \n#define TI_ABB_NOMINAL_OPP\t0\n#define TI_ABB_FAST_OPP\t\t1\n#define TI_ABB_SLOW_OPP\t\t3\n\n \nstruct ti_abb_info {\n\tu32 opp_sel;\n\tu32 vset;\n};\n\n \nstruct ti_abb_reg {\n\tu32 setup_off;\n\tu32 control_off;\n\n\t \n\tu32 sr2_wtcnt_value_mask;\n\tu32 fbb_sel_mask;\n\tu32 rbb_sel_mask;\n\tu32 sr2_en_mask;\n\n\t \n\tu32 opp_change_mask;\n\tu32 opp_sel_mask;\n};\n\n \nstruct ti_abb {\n\tstruct regulator_desc rdesc;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tvoid __iomem *setup_reg;\n\tvoid __iomem *control_reg;\n\tvoid __iomem *int_base;\n\tvoid __iomem *efuse_base;\n\tvoid __iomem *ldo_base;\n\n\tconst struct ti_abb_reg *regs;\n\tu32 txdone_mask;\n\tu32 ldovbb_override_mask;\n\tu32 ldovbb_vset_mask;\n\n\tstruct ti_abb_info *info;\n\tint current_info_idx;\n\n\tu32 settling_time;\n};\n\n \nstatic inline u32 ti_abb_rmw(u32 mask, u32 value, void __iomem *reg)\n{\n\tu32 val;\n\n\tval = readl(reg);\n\tval &= ~mask;\n\tval |= (value << __ffs(mask)) & mask;\n\twritel(val, reg);\n\n\treturn val;\n}\n\n \nstatic inline bool ti_abb_check_txdone(const struct ti_abb *abb)\n{\n\treturn !!(readl(abb->int_base) & abb->txdone_mask);\n}\n\n \nstatic inline void ti_abb_clear_txdone(const struct ti_abb *abb)\n{\n\twritel(abb->txdone_mask, abb->int_base);\n};\n\n \nstatic int ti_abb_wait_txdone(struct device *dev, struct ti_abb *abb)\n{\n\tint timeout = 0;\n\tbool status;\n\n\twhile (timeout++ <= abb->settling_time) {\n\t\tstatus = ti_abb_check_txdone(abb);\n\t\tif (status)\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t}\n\n\tdev_warn_ratelimited(dev, \"%s:TRANXDONE timeout(%duS) int=0x%08x\\n\",\n\t\t\t     __func__, timeout, readl(abb->int_base));\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int ti_abb_clear_all_txdone(struct device *dev, const struct ti_abb *abb)\n{\n\tint timeout = 0;\n\tbool status;\n\n\twhile (timeout++ <= abb->settling_time) {\n\t\tti_abb_clear_txdone(abb);\n\n\t\tstatus = ti_abb_check_txdone(abb);\n\t\tif (!status)\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t}\n\n\tdev_warn_ratelimited(dev, \"%s:TRANXDONE timeout(%duS) int=0x%08x\\n\",\n\t\t\t     __func__, timeout, readl(abb->int_base));\n\treturn -ETIMEDOUT;\n}\n\n \nstatic void ti_abb_program_ldovbb(struct device *dev, const struct ti_abb *abb,\n\t\t\t\t  struct ti_abb_info *info)\n{\n\tu32 val;\n\n\tval = readl(abb->ldo_base);\n\t \n\tval &= ~(abb->ldovbb_override_mask | abb->ldovbb_vset_mask);\n\n\tswitch (info->opp_sel) {\n\tcase TI_ABB_SLOW_OPP:\n\tcase TI_ABB_FAST_OPP:\n\t\tval |= abb->ldovbb_override_mask;\n\t\tval |= info->vset << __ffs(abb->ldovbb_vset_mask);\n\t\tbreak;\n\t}\n\n\twritel(val, abb->ldo_base);\n}\n\n \nstatic int ti_abb_set_opp(struct regulator_dev *rdev, struct ti_abb *abb,\n\t\t\t  struct ti_abb_info *info)\n{\n\tconst struct ti_abb_reg *regs = abb->regs;\n\tstruct device *dev = &rdev->dev;\n\tint ret;\n\n\tret = ti_abb_clear_all_txdone(dev, abb);\n\tif (ret)\n\t\tgoto out;\n\n\tti_abb_rmw(regs->fbb_sel_mask | regs->rbb_sel_mask, 0, abb->setup_reg);\n\n\tswitch (info->opp_sel) {\n\tcase TI_ABB_SLOW_OPP:\n\t\tti_abb_rmw(regs->rbb_sel_mask, 1, abb->setup_reg);\n\t\tbreak;\n\tcase TI_ABB_FAST_OPP:\n\t\tti_abb_rmw(regs->fbb_sel_mask, 1, abb->setup_reg);\n\t\tbreak;\n\t}\n\n\t \n\tti_abb_rmw(regs->opp_sel_mask, info->opp_sel, abb->control_reg);\n\n\t \n\tif (abb->ldo_base && info->opp_sel != TI_ABB_NOMINAL_OPP)\n\t\tti_abb_program_ldovbb(dev, abb, info);\n\n\t \n\tti_abb_rmw(regs->opp_change_mask, 1, abb->control_reg);\n\n\t \n\tret = ti_abb_wait_txdone(dev, abb);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ti_abb_clear_all_txdone(dev, abb);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (abb->ldo_base && info->opp_sel == TI_ABB_NOMINAL_OPP)\n\t\tti_abb_program_ldovbb(dev, abb, info);\n\nout:\n\treturn ret;\n}\n\n \nstatic int ti_abb_set_voltage_sel(struct regulator_dev *rdev, unsigned int sel)\n{\n\tconst struct regulator_desc *desc = rdev->desc;\n\tstruct ti_abb *abb = rdev_get_drvdata(rdev);\n\tstruct device *dev = &rdev->dev;\n\tstruct ti_abb_info *info, *oinfo;\n\tint ret = 0;\n\n\tif (!abb) {\n\t\tdev_err_ratelimited(dev, \"%s: No regulator drvdata\\n\",\n\t\t\t\t    __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!desc->n_voltages || !abb->info) {\n\t\tdev_err_ratelimited(dev,\n\t\t\t\t    \"%s: No valid voltage table entries?\\n\",\n\t\t\t\t    __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sel >= desc->n_voltages) {\n\t\tdev_err(dev, \"%s: sel idx(%d) >= n_voltages(%d)\\n\", __func__,\n\t\t\tsel, desc->n_voltages);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (sel == abb->current_info_idx) {\n\t\tdev_dbg(dev, \"%s: Already at sel=%d\\n\", __func__, sel);\n\t\treturn ret;\n\t}\n\n\tinfo = &abb->info[sel];\n\t \n\tif (abb->current_info_idx == -EINVAL)\n\t\tgoto just_set_abb;\n\n\t \n\toinfo = &abb->info[abb->current_info_idx];\n\tif (!memcmp(info, oinfo, sizeof(*info))) {\n\t\tdev_dbg(dev, \"%s: Same data new idx=%d, old idx=%d\\n\", __func__,\n\t\t\tsel, abb->current_info_idx);\n\t\tgoto out;\n\t}\n\njust_set_abb:\n\tret = ti_abb_set_opp(rdev, abb, info);\n\nout:\n\tif (!ret)\n\t\tabb->current_info_idx = sel;\n\telse\n\t\tdev_err_ratelimited(dev,\n\t\t\t\t    \"%s: Volt[%d] idx[%d] mode[%d] Fail(%d)\\n\",\n\t\t\t\t    __func__, desc->volt_table[sel], sel,\n\t\t\t\t    info->opp_sel, ret);\n\treturn ret;\n}\n\n \nstatic int ti_abb_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tconst struct regulator_desc *desc = rdev->desc;\n\tstruct ti_abb *abb = rdev_get_drvdata(rdev);\n\tstruct device *dev = &rdev->dev;\n\n\tif (!abb) {\n\t\tdev_err_ratelimited(dev, \"%s: No regulator drvdata\\n\",\n\t\t\t\t    __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!desc->n_voltages || !abb->info) {\n\t\tdev_err_ratelimited(dev,\n\t\t\t\t    \"%s: No valid voltage table entries?\\n\",\n\t\t\t\t    __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (abb->current_info_idx >= (int)desc->n_voltages) {\n\t\tdev_err(dev, \"%s: Corrupted data? idx(%d) >= n_voltages(%d)\\n\",\n\t\t\t__func__, abb->current_info_idx, desc->n_voltages);\n\t\treturn -EINVAL;\n\t}\n\n\treturn abb->current_info_idx;\n}\n\n \nstatic int ti_abb_init_timings(struct device *dev, struct ti_abb *abb)\n{\n\tu32 clock_cycles;\n\tu32 clk_rate, sr2_wt_cnt_val, cycle_rate;\n\tconst struct ti_abb_reg *regs = abb->regs;\n\tint ret;\n\tchar *pname = \"ti,settling-time\";\n\n\t \n\tret = of_property_read_u32(dev->of_node, pname, &abb->settling_time);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to get property '%s'(%d)\\n\", pname, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!abb->settling_time) {\n\t\tdev_err(dev, \"Invalid property:'%s' set as 0!\\n\", pname);\n\t\treturn -EINVAL;\n\t}\n\n\tpname = \"ti,clock-cycles\";\n\tret = of_property_read_u32(dev->of_node, pname, &clock_cycles);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to get property '%s'(%d)\\n\", pname, ret);\n\t\treturn ret;\n\t}\n\t \n\tif (!clock_cycles) {\n\t\tdev_err(dev, \"Invalid property:'%s' set as 0!\\n\", pname);\n\t\treturn -EINVAL;\n\t}\n\n\tabb->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(abb->clk)) {\n\t\tret = PTR_ERR(abb->clk);\n\t\tdev_err(dev, \"%s: Unable to get clk(%d)\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\n\t \n\tclk_rate = DIV_ROUND_CLOSEST(clk_get_rate(abb->clk), 1000000);\n\n\t \n\tcycle_rate = DIV_ROUND_CLOSEST(clock_cycles * 10, clk_rate);\n\n\t \n\tsr2_wt_cnt_val = DIV_ROUND_CLOSEST(abb->settling_time * 10, cycle_rate);\n\n\tdev_dbg(dev, \"%s: Clk_rate=%ld, sr2_cnt=0x%08x\\n\", __func__,\n\t\tclk_get_rate(abb->clk), sr2_wt_cnt_val);\n\n\tti_abb_rmw(regs->sr2_wtcnt_value_mask, sr2_wt_cnt_val, abb->setup_reg);\n\n\treturn 0;\n}\n\n \nstatic int ti_abb_init_table(struct device *dev, struct ti_abb *abb,\n\t\t\t     struct regulator_init_data *rinit_data)\n{\n\tstruct ti_abb_info *info;\n\tconst u32 num_values = 6;\n\tchar *pname = \"ti,abb_info\";\n\tu32 i;\n\tunsigned int *volt_table;\n\tint num_entries, min_uV = INT_MAX, max_uV = 0;\n\tstruct regulation_constraints *c = &rinit_data->constraints;\n\n\t \n\tnum_entries = of_property_count_u32_elems(dev->of_node, pname);\n\tif (num_entries < 0) {\n\t\tdev_err(dev, \"No '%s' property?\\n\", pname);\n\t\treturn num_entries;\n\t}\n\n\tif (!num_entries || (num_entries % num_values)) {\n\t\tdev_err(dev, \"All '%s' list entries need %d vals\\n\", pname,\n\t\t\tnum_values);\n\t\treturn -EINVAL;\n\t}\n\tnum_entries /= num_values;\n\n\tinfo = devm_kcalloc(dev, num_entries, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tabb->info = info;\n\n\tvolt_table = devm_kcalloc(dev, num_entries, sizeof(unsigned int),\n\t\t\t\t  GFP_KERNEL);\n\tif (!volt_table)\n\t\treturn -ENOMEM;\n\n\tabb->rdesc.n_voltages = num_entries;\n\tabb->rdesc.volt_table = volt_table;\n\t \n\tabb->current_info_idx = -EINVAL;\n\n\tfor (i = 0; i < num_entries; i++, info++, volt_table++) {\n\t\tu32 efuse_offset, rbb_mask, fbb_mask, vset_mask;\n\t\tu32 efuse_val;\n\n\t\t \n\t\tof_property_read_u32_index(dev->of_node, pname, i * num_values,\n\t\t\t\t\t   volt_table);\n\t\tof_property_read_u32_index(dev->of_node, pname,\n\t\t\t\t\t   i * num_values + 1, &info->opp_sel);\n\t\tof_property_read_u32_index(dev->of_node, pname,\n\t\t\t\t\t   i * num_values + 2, &efuse_offset);\n\t\tof_property_read_u32_index(dev->of_node, pname,\n\t\t\t\t\t   i * num_values + 3, &rbb_mask);\n\t\tof_property_read_u32_index(dev->of_node, pname,\n\t\t\t\t\t   i * num_values + 4, &fbb_mask);\n\t\tof_property_read_u32_index(dev->of_node, pname,\n\t\t\t\t\t   i * num_values + 5, &vset_mask);\n\n\t\tdev_dbg(dev,\n\t\t\t\"[%d]v=%d ABB=%d ef=0x%x rbb=0x%x fbb=0x%x vset=0x%x\\n\",\n\t\t\ti, *volt_table, info->opp_sel, efuse_offset, rbb_mask,\n\t\t\tfbb_mask, vset_mask);\n\n\t\t \n\t\tif (min_uV > *volt_table)\n\t\t\tmin_uV = *volt_table;\n\t\tif (max_uV < *volt_table)\n\t\t\tmax_uV = *volt_table;\n\n\t\tif (!abb->efuse_base) {\n\t\t\t \n\t\t\tif (efuse_offset || rbb_mask || fbb_mask || vset_mask)\n\t\t\t\tdev_err(dev, \"prop '%s': v=%d,bad efuse/mask\\n\",\n\t\t\t\t\tpname, *volt_table);\n\t\t\tgoto check_abb;\n\t\t}\n\n\t\tefuse_val = readl(abb->efuse_base + efuse_offset);\n\n\t\t \n\t\tif (efuse_val & rbb_mask)\n\t\t\tinfo->opp_sel = TI_ABB_SLOW_OPP;\n\t\telse if (efuse_val & fbb_mask)\n\t\t\tinfo->opp_sel = TI_ABB_FAST_OPP;\n\t\telse if (rbb_mask || fbb_mask)\n\t\t\tinfo->opp_sel = TI_ABB_NOMINAL_OPP;\n\n\t\tdev_dbg(dev,\n\t\t\t\"[%d]v=%d efusev=0x%x final ABB=%d\\n\",\n\t\t\ti, *volt_table, efuse_val, info->opp_sel);\n\n\t\t \n\t\tif (!abb->ldo_base) {\n\t\t\tif (vset_mask)\n\t\t\t\tdev_err(dev, \"prop'%s':v=%d vst=%x LDO base?\\n\",\n\t\t\t\t\tpname, *volt_table, vset_mask);\n\t\t\tcontinue;\n\t\t}\n\t\tinfo->vset = (efuse_val & vset_mask) >> __ffs(vset_mask);\n\t\tdev_dbg(dev, \"[%d]v=%d vset=%x\\n\", i, *volt_table, info->vset);\ncheck_abb:\n\t\tswitch (info->opp_sel) {\n\t\tcase TI_ABB_NOMINAL_OPP:\n\t\tcase TI_ABB_FAST_OPP:\n\t\tcase TI_ABB_SLOW_OPP:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"%s:[%d]v=%d, ABB=%d is invalid! Abort!\\n\",\n\t\t\t\t__func__, i, *volt_table, info->opp_sel);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tc->min_uV = min_uV;\n\tc->max_uV = max_uV;\n\n\treturn 0;\n}\n\nstatic const struct regulator_ops ti_abb_reg_ops = {\n\t.list_voltage = regulator_list_voltage_table,\n\n\t.set_voltage_sel = ti_abb_set_voltage_sel,\n\t.get_voltage_sel = ti_abb_get_voltage_sel,\n};\n\n \nstatic const struct ti_abb_reg abb_regs_v1 = {\n\t \n\t.setup_off\t\t= 0x04,\n\t.control_off\t\t= 0x00,\n\n\t.sr2_wtcnt_value_mask\t= (0xff << 8),\n\t.fbb_sel_mask\t\t= (0x01 << 2),\n\t.rbb_sel_mask\t\t= (0x01 << 1),\n\t.sr2_en_mask\t\t= (0x01 << 0),\n\n\t.opp_change_mask\t= (0x01 << 2),\n\t.opp_sel_mask\t\t= (0x03 << 0),\n};\n\nstatic const struct ti_abb_reg abb_regs_v2 = {\n\t.setup_off\t\t= 0x00,\n\t.control_off\t\t= 0x04,\n\n\t.sr2_wtcnt_value_mask\t= (0xff << 8),\n\t.fbb_sel_mask\t\t= (0x01 << 2),\n\t.rbb_sel_mask\t\t= (0x01 << 1),\n\t.sr2_en_mask\t\t= (0x01 << 0),\n\n\t.opp_change_mask\t= (0x01 << 2),\n\t.opp_sel_mask\t\t= (0x03 << 0),\n};\n\nstatic const struct ti_abb_reg abb_regs_generic = {\n\t.sr2_wtcnt_value_mask\t= (0xff << 8),\n\t.fbb_sel_mask\t\t= (0x01 << 2),\n\t.rbb_sel_mask\t\t= (0x01 << 1),\n\t.sr2_en_mask\t\t= (0x01 << 0),\n\n\t.opp_change_mask\t= (0x01 << 2),\n\t.opp_sel_mask\t\t= (0x03 << 0),\n};\n\nstatic const struct of_device_id ti_abb_of_match[] = {\n\t{.compatible = \"ti,abb-v1\", .data = &abb_regs_v1},\n\t{.compatible = \"ti,abb-v2\", .data = &abb_regs_v2},\n\t{.compatible = \"ti,abb-v3\", .data = &abb_regs_generic},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, ti_abb_of_match);\n\n \nstatic int ti_abb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *match;\n\tstruct resource *res;\n\tstruct ti_abb *abb;\n\tstruct regulator_init_data *initdata = NULL;\n\tstruct regulator_dev *rdev = NULL;\n\tstruct regulator_desc *desc;\n\tstruct regulation_constraints *c;\n\tstruct regulator_config config = { };\n\tchar *pname;\n\tint ret = 0;\n\n\tmatch = of_match_device(ti_abb_of_match, dev);\n\tif (!match) {\n\t\t \n\t\tdev_err(dev, \"%s: Unable to match device\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\tif (!match->data) {\n\t\tdev_err(dev, \"%s: Bad data in match\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tabb = devm_kzalloc(dev, sizeof(struct ti_abb), GFP_KERNEL);\n\tif (!abb)\n\t\treturn -ENOMEM;\n\tabb->regs = match->data;\n\n\t \n\tif (abb->regs->setup_off || abb->regs->control_off) {\n\t\tabb->base = devm_platform_ioremap_resource_byname(pdev, \"base-address\");\n\t\tif (IS_ERR(abb->base))\n\t\t\treturn PTR_ERR(abb->base);\n\n\t\tabb->setup_reg = abb->base + abb->regs->setup_off;\n\t\tabb->control_reg = abb->base + abb->regs->control_off;\n\n\t} else {\n\t\tabb->control_reg = devm_platform_ioremap_resource_byname(pdev, \"control-address\");\n\t\tif (IS_ERR(abb->control_reg))\n\t\t\treturn PTR_ERR(abb->control_reg);\n\n\t\tabb->setup_reg = devm_platform_ioremap_resource_byname(pdev, \"setup-address\");\n\t\tif (IS_ERR(abb->setup_reg))\n\t\t\treturn PTR_ERR(abb->setup_reg);\n\t}\n\n\tabb->int_base = devm_platform_ioremap_resource_byname(pdev, \"int-address\");\n\tif (IS_ERR(abb->int_base))\n\t\treturn PTR_ERR(abb->int_base);\n\n\t \n\tpname = \"efuse-address\";\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, pname);\n\tif (!res) {\n\t\tdev_dbg(dev, \"Missing '%s' IO resource\\n\", pname);\n\t\tret = -ENODEV;\n\t\tgoto skip_opt;\n\t}\n\n\t \n\tabb->efuse_base = devm_ioremap(dev, res->start,\n\t\t\t\t\t       resource_size(res));\n\tif (!abb->efuse_base) {\n\t\tdev_err(dev, \"Unable to map '%s'\\n\", pname);\n\t\treturn -ENOMEM;\n\t}\n\n\tpname = \"ldo-address\";\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, pname);\n\tif (!res) {\n\t\tdev_dbg(dev, \"Missing '%s' IO resource\\n\", pname);\n\t\tret = -ENODEV;\n\t\tgoto skip_opt;\n\t}\n\tabb->ldo_base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(abb->ldo_base))\n\t\treturn PTR_ERR(abb->ldo_base);\n\n\t \n\tpname = \"ti,ldovbb-override-mask\";\n\tret =\n\t    of_property_read_u32(pdev->dev.of_node, pname,\n\t\t\t\t &abb->ldovbb_override_mask);\n\tif (ret) {\n\t\tdev_err(dev, \"Missing '%s' (%d)\\n\", pname, ret);\n\t\treturn ret;\n\t}\n\tif (!abb->ldovbb_override_mask) {\n\t\tdev_err(dev, \"Invalid property:'%s' set as 0!\\n\", pname);\n\t\treturn -EINVAL;\n\t}\n\n\tpname = \"ti,ldovbb-vset-mask\";\n\tret =\n\t    of_property_read_u32(pdev->dev.of_node, pname,\n\t\t\t\t &abb->ldovbb_vset_mask);\n\tif (ret) {\n\t\tdev_err(dev, \"Missing '%s' (%d)\\n\", pname, ret);\n\t\treturn ret;\n\t}\n\tif (!abb->ldovbb_vset_mask) {\n\t\tdev_err(dev, \"Invalid property:'%s' set as 0!\\n\", pname);\n\t\treturn -EINVAL;\n\t}\n\nskip_opt:\n\tpname = \"ti,tranxdone-status-mask\";\n\tret =\n\t    of_property_read_u32(pdev->dev.of_node, pname,\n\t\t\t\t &abb->txdone_mask);\n\tif (ret) {\n\t\tdev_err(dev, \"Missing '%s' (%d)\\n\", pname, ret);\n\t\treturn ret;\n\t}\n\tif (!abb->txdone_mask) {\n\t\tdev_err(dev, \"Invalid property:'%s' set as 0!\\n\", pname);\n\t\treturn -EINVAL;\n\t}\n\n\tinitdata = of_get_regulator_init_data(dev, pdev->dev.of_node,\n\t\t\t\t\t      &abb->rdesc);\n\tif (!initdata) {\n\t\tdev_err(dev, \"%s: Unable to alloc regulator init data\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = ti_abb_init_table(dev, abb, initdata);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ti_abb_init_timings(dev, abb);\n\tif (ret)\n\t\treturn ret;\n\n\tdesc = &abb->rdesc;\n\tdesc->name = dev_name(dev);\n\tdesc->owner = THIS_MODULE;\n\tdesc->type = REGULATOR_VOLTAGE;\n\tdesc->ops = &ti_abb_reg_ops;\n\n\tc = &initdata->constraints;\n\tif (desc->n_voltages > 1)\n\t\tc->valid_ops_mask |= REGULATOR_CHANGE_VOLTAGE;\n\tc->always_on = true;\n\n\tconfig.dev = dev;\n\tconfig.init_data = initdata;\n\tconfig.driver_data = abb;\n\tconfig.of_node = pdev->dev.of_node;\n\n\trdev = devm_regulator_register(dev, desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\t\tdev_err(dev, \"%s: failed to register regulator(%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\tplatform_set_drvdata(pdev, rdev);\n\n\t \n\tti_abb_rmw(abb->regs->sr2_en_mask, 1, abb->setup_reg);\n\n\treturn 0;\n}\n\nMODULE_ALIAS(\"platform:ti_abb\");\n\nstatic struct platform_driver ti_abb_driver = {\n\t.probe = ti_abb_probe,\n\t.driver = {\n\t\t   .name = \"ti_abb\",\n\t\t   .probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t   .of_match_table = of_match_ptr(ti_abb_of_match),\n\t\t   },\n};\nmodule_platform_driver(ti_abb_driver);\n\nMODULE_DESCRIPTION(\"Texas Instruments ABB LDO regulator driver\");\nMODULE_AUTHOR(\"Texas Instruments Inc.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}