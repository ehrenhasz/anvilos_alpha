{
  "module_name": "arizona-micsupp.c",
  "hash_id": "3155657ba0257a8b3855f05ef085fca05c4867f3680319ee1d86b81de1167e35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/arizona-micsupp.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <sound/soc.h>\n\n#include <linux/mfd/arizona/core.h>\n#include <linux/mfd/arizona/pdata.h>\n#include <linux/mfd/arizona/registers.h>\n\n#include <linux/mfd/madera/core.h>\n#include <linux/mfd/madera/pdata.h>\n#include <linux/mfd/madera/registers.h>\n\n#include <linux/regulator/arizona-micsupp.h>\n\nstruct arizona_micsupp {\n\tstruct regulator_dev *regulator;\n\tstruct regmap *regmap;\n\tstruct snd_soc_dapm_context **dapm;\n\tconst struct regulator_desc *desc;\n\tstruct device *dev;\n\n\tstruct regulator_consumer_supply supply;\n\tstruct regulator_init_data init_data;\n\n\tstruct work_struct check_cp_work;\n};\n\nstatic void arizona_micsupp_check_cp(struct work_struct *work)\n{\n\tstruct arizona_micsupp *micsupp =\n\t\tcontainer_of(work, struct arizona_micsupp, check_cp_work);\n\tstruct snd_soc_dapm_context *dapm = *micsupp->dapm;\n\tstruct snd_soc_component *component;\n\tconst struct regulator_desc *desc = micsupp->desc;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(micsupp->regmap, desc->enable_reg, &val);\n\tif (ret != 0) {\n\t\tdev_err(micsupp->dev,\n\t\t\t\"Failed to read CP state: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (dapm) {\n\t\tcomponent = snd_soc_dapm_to_component(dapm);\n\n\t\tif ((val & (desc->enable_mask | desc->bypass_mask)) ==\n\t\t    desc->enable_mask)\n\t\t\tsnd_soc_component_force_enable_pin(component,\n\t\t\t\t\t\t\t   \"MICSUPP\");\n\t\telse\n\t\t\tsnd_soc_component_disable_pin(component, \"MICSUPP\");\n\n\t\tsnd_soc_dapm_sync(dapm);\n\t}\n}\n\nstatic int arizona_micsupp_enable(struct regulator_dev *rdev)\n{\n\tstruct arizona_micsupp *micsupp = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tret = regulator_enable_regmap(rdev);\n\n\tif (ret == 0)\n\t\tschedule_work(&micsupp->check_cp_work);\n\n\treturn ret;\n}\n\nstatic int arizona_micsupp_disable(struct regulator_dev *rdev)\n{\n\tstruct arizona_micsupp *micsupp = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tret = regulator_disable_regmap(rdev);\n\tif (ret == 0)\n\t\tschedule_work(&micsupp->check_cp_work);\n\n\treturn ret;\n}\n\nstatic int arizona_micsupp_set_bypass(struct regulator_dev *rdev, bool ena)\n{\n\tstruct arizona_micsupp *micsupp = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tret = regulator_set_bypass_regmap(rdev, ena);\n\tif (ret == 0)\n\t\tschedule_work(&micsupp->check_cp_work);\n\n\treturn ret;\n}\n\nstatic const struct regulator_ops arizona_micsupp_ops = {\n\t.enable = arizona_micsupp_enable,\n\t.disable = arizona_micsupp_disable,\n\t.is_enabled = regulator_is_enabled_regmap,\n\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.map_voltage = regulator_map_voltage_linear_range,\n\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\n\t.get_bypass = regulator_get_bypass_regmap,\n\t.set_bypass = arizona_micsupp_set_bypass,\n};\n\nstatic const struct linear_range arizona_micsupp_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1700000, 0,    0x1e, 50000),\n\tREGULATOR_LINEAR_RANGE(3300000, 0x1f, 0x1f, 0),\n};\n\nstatic const struct regulator_desc arizona_micsupp = {\n\t.name = \"MICVDD\",\n\t.supply_name = \"CPVDD\",\n\t.type = REGULATOR_VOLTAGE,\n\t.n_voltages = 32,\n\t.ops = &arizona_micsupp_ops,\n\n\t.vsel_reg = ARIZONA_LDO2_CONTROL_1,\n\t.vsel_mask = ARIZONA_LDO2_VSEL_MASK,\n\t.enable_reg = ARIZONA_MIC_CHARGE_PUMP_1,\n\t.enable_mask = ARIZONA_CPMIC_ENA,\n\t.bypass_reg = ARIZONA_MIC_CHARGE_PUMP_1,\n\t.bypass_mask = ARIZONA_CPMIC_BYPASS,\n\n\t.linear_ranges = arizona_micsupp_ranges,\n\t.n_linear_ranges = ARRAY_SIZE(arizona_micsupp_ranges),\n\n\t.enable_time = 3000,\n\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct linear_range arizona_micsupp_ext_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(900000,  0,    0x14, 25000),\n\tREGULATOR_LINEAR_RANGE(1500000, 0x15, 0x27, 100000),\n};\n\nstatic const struct regulator_desc arizona_micsupp_ext = {\n\t.name = \"MICVDD\",\n\t.supply_name = \"CPVDD\",\n\t.type = REGULATOR_VOLTAGE,\n\t.n_voltages = 40,\n\t.ops = &arizona_micsupp_ops,\n\n\t.vsel_reg = ARIZONA_LDO2_CONTROL_1,\n\t.vsel_mask = ARIZONA_LDO2_VSEL_MASK,\n\t.enable_reg = ARIZONA_MIC_CHARGE_PUMP_1,\n\t.enable_mask = ARIZONA_CPMIC_ENA,\n\t.bypass_reg = ARIZONA_MIC_CHARGE_PUMP_1,\n\t.bypass_mask = ARIZONA_CPMIC_BYPASS,\n\n\t.linear_ranges = arizona_micsupp_ext_ranges,\n\t.n_linear_ranges = ARRAY_SIZE(arizona_micsupp_ext_ranges),\n\n\t.enable_time = 3000,\n\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct regulator_init_data arizona_micsupp_default = {\n\t.constraints = {\n\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS |\n\t\t\t\tREGULATOR_CHANGE_VOLTAGE |\n\t\t\t\tREGULATOR_CHANGE_BYPASS,\n\t\t.min_uV = 1700000,\n\t\t.max_uV = 3300000,\n\t},\n\n\t.num_consumer_supplies = 1,\n};\n\nstatic const struct regulator_init_data arizona_micsupp_ext_default = {\n\t.constraints = {\n\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS |\n\t\t\t\tREGULATOR_CHANGE_VOLTAGE |\n\t\t\t\tREGULATOR_CHANGE_BYPASS,\n\t\t.min_uV = 900000,\n\t\t.max_uV = 3300000,\n\t},\n\n\t.num_consumer_supplies = 1,\n};\n\nstatic const struct regulator_desc madera_micsupp = {\n\t.name = \"MICVDD\",\n\t.supply_name = \"CPVDD1\",\n\t.type = REGULATOR_VOLTAGE,\n\t.n_voltages = 40,\n\t.ops = &arizona_micsupp_ops,\n\t.vsel_reg = MADERA_LDO2_CONTROL_1,\n\t.vsel_mask = MADERA_LDO2_VSEL_MASK,\n\t.enable_reg = MADERA_MIC_CHARGE_PUMP_1,\n\t.enable_mask = MADERA_CPMIC_ENA,\n\t.bypass_reg = MADERA_MIC_CHARGE_PUMP_1,\n\t.bypass_mask = MADERA_CPMIC_BYPASS,\n\n\t.linear_ranges = arizona_micsupp_ext_ranges,\n\t.n_linear_ranges = ARRAY_SIZE(arizona_micsupp_ext_ranges),\n\n\t.enable_time = 3000,\n\n\t.owner = THIS_MODULE,\n};\n\nstatic int arizona_micsupp_of_get_pdata(struct arizona_micsupp_pdata *pdata,\n\t\t\t\t\tstruct regulator_config *config,\n\t\t\t\t\tconst struct regulator_desc *desc)\n{\n\tstruct arizona_micsupp *micsupp = config->driver_data;\n\tstruct device_node *np;\n\tstruct regulator_init_data *init_data;\n\n\tnp = of_get_child_by_name(config->dev->of_node, \"micvdd\");\n\n\tif (np) {\n\t\tconfig->of_node = np;\n\n\t\tinit_data = of_get_regulator_init_data(config->dev, np, desc);\n\n\t\tif (init_data) {\n\t\t\tinit_data->consumer_supplies = &micsupp->supply;\n\t\t\tinit_data->num_consumer_supplies = 1;\n\n\t\t\tpdata->init_data = init_data;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int arizona_micsupp_common_init(struct platform_device *pdev,\n\t\t\t\t       struct arizona_micsupp *micsupp,\n\t\t\t\t       const struct regulator_desc *desc,\n\t\t\t\t       struct arizona_micsupp_pdata *pdata)\n{\n\tstruct regulator_config config = { };\n\tint ret;\n\n\tINIT_WORK(&micsupp->check_cp_work, arizona_micsupp_check_cp);\n\n\tmicsupp->init_data.consumer_supplies = &micsupp->supply;\n\tmicsupp->supply.dev_name = dev_name(micsupp->dev);\n\tmicsupp->desc = desc;\n\n\tconfig.dev = micsupp->dev;\n\tconfig.driver_data = micsupp;\n\tconfig.regmap = micsupp->regmap;\n\n\tif (IS_ENABLED(CONFIG_OF)) {\n\t\tif (!dev_get_platdata(micsupp->dev)) {\n\t\t\tret = arizona_micsupp_of_get_pdata(pdata, &config,\n\t\t\t\t\t\t\t   desc);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (pdata->init_data)\n\t\tconfig.init_data = pdata->init_data;\n\telse\n\t\tconfig.init_data = &micsupp->init_data;\n\n\t \n\tregmap_update_bits(micsupp->regmap, desc->enable_reg, desc->bypass_mask, 0);\n\n\tmicsupp->regulator = devm_regulator_register(&pdev->dev,\n\t\t\t\t\t\t     desc,\n\t\t\t\t\t\t     &config);\n\n\tof_node_put(config.of_node);\n\n\tif (IS_ERR(micsupp->regulator)) {\n\t\tret = PTR_ERR(micsupp->regulator);\n\t\tdev_err(micsupp->dev, \"Failed to register mic supply: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, micsupp);\n\n\treturn 0;\n}\n\nstatic int arizona_micsupp_probe(struct platform_device *pdev)\n{\n\tstruct arizona *arizona = dev_get_drvdata(pdev->dev.parent);\n\tconst struct regulator_desc *desc;\n\tstruct arizona_micsupp *micsupp;\n\n\tmicsupp = devm_kzalloc(&pdev->dev, sizeof(*micsupp), GFP_KERNEL);\n\tif (!micsupp)\n\t\treturn -ENOMEM;\n\n\tmicsupp->regmap = arizona->regmap;\n\tmicsupp->dapm = &arizona->dapm;\n\tmicsupp->dev = arizona->dev;\n\n\tmicsupp->supply.supply = \"MICVDD\";\n\n\t \n\tswitch (arizona->type) {\n\tcase WM5110:\n\tcase WM8280:\n\t\tdesc = &arizona_micsupp_ext;\n\t\tmicsupp->init_data = arizona_micsupp_ext_default;\n\t\tbreak;\n\tdefault:\n\t\tdesc = &arizona_micsupp;\n\t\tmicsupp->init_data = arizona_micsupp_default;\n\t\tbreak;\n\t}\n\n\treturn arizona_micsupp_common_init(pdev, micsupp, desc,\n\t\t\t\t\t   &arizona->pdata.micvdd);\n}\n\nstatic int madera_micsupp_probe(struct platform_device *pdev)\n{\n\tstruct madera *madera = dev_get_drvdata(pdev->dev.parent);\n\tstruct arizona_micsupp *micsupp;\n\n\tmicsupp = devm_kzalloc(&pdev->dev, sizeof(*micsupp), GFP_KERNEL);\n\tif (!micsupp)\n\t\treturn -ENOMEM;\n\n\tmicsupp->regmap = madera->regmap;\n\tmicsupp->dapm = &madera->dapm;\n\tmicsupp->dev = madera->dev;\n\tmicsupp->init_data = arizona_micsupp_ext_default;\n\n\tmicsupp->supply.supply = \"MICVDD\";\n\n\treturn arizona_micsupp_common_init(pdev, micsupp, &madera_micsupp,\n\t\t\t\t\t   &madera->pdata.micvdd);\n}\n\nstatic struct platform_driver arizona_micsupp_driver = {\n\t.probe = arizona_micsupp_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"arizona-micsupp\",\n\t\t.probe_type = PROBE_FORCE_SYNCHRONOUS,\n\t},\n};\n\nstatic struct platform_driver madera_micsupp_driver = {\n\t.probe = madera_micsupp_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"madera-micsupp\",\n\t\t.probe_type = PROBE_FORCE_SYNCHRONOUS,\n\t},\n};\n\nstatic struct platform_driver * const arizona_micsupp_drivers[] = {\n\t&arizona_micsupp_driver,\n\t&madera_micsupp_driver,\n};\n\nstatic int __init arizona_micsupp_init(void)\n{\n\treturn platform_register_drivers(arizona_micsupp_drivers,\n\t\t\t\t\t ARRAY_SIZE(arizona_micsupp_drivers));\n}\nmodule_init(arizona_micsupp_init);\n\nstatic void __exit arizona_micsupp_exit(void)\n{\n\tplatform_unregister_drivers(arizona_micsupp_drivers,\n\t\t\t\t    ARRAY_SIZE(arizona_micsupp_drivers));\n}\nmodule_exit(arizona_micsupp_exit);\n\n \nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"Arizona microphone supply driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:arizona-micsupp\");\nMODULE_ALIAS(\"platform:madera-micsupp\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}