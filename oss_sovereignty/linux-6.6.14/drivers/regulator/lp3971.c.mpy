{
  "module_name": "lp3971.c",
  "hash_id": "da5ce7a53ec9243a05e16081ccd8c9b0b19b568873b7feb29a67c700b8987cd4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/lp3971.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/lp3971.h>\n#include <linux/slab.h>\n\nstruct lp3971 {\n\tstruct device *dev;\n\tstruct mutex io_lock;\n\tstruct i2c_client *i2c;\n};\n\nstatic u8 lp3971_reg_read(struct lp3971 *lp3971, u8 reg);\nstatic int lp3971_set_bits(struct lp3971 *lp3971, u8 reg, u16 mask, u16 val);\n\n#define LP3971_SYS_CONTROL1_REG 0x07\n\n \n#define SYS_CONTROL1_INIT_VAL 0x40\n#define SYS_CONTROL1_INIT_MASK 0xCF\n\n#define LP3971_BUCK_VOL_ENABLE_REG 0x10\n#define LP3971_BUCK_VOL_CHANGE_REG 0x20\n\n \n#define BUCK_VOL_CHANGE_SHIFT(x) (((!!x) << 2) | (x & ~0x01))\n#define BUCK_VOL_CHANGE_FLAG_GO 0x01\n#define BUCK_VOL_CHANGE_FLAG_TARGET 0x02\n#define BUCK_VOL_CHANGE_FLAG_MASK 0x03\n\n#define LP3971_BUCK1_BASE 0x23\n#define LP3971_BUCK2_BASE 0x29\n#define LP3971_BUCK3_BASE 0x32\n\nstatic const int buck_base_addr[] = {\n\tLP3971_BUCK1_BASE,\n\tLP3971_BUCK2_BASE,\n\tLP3971_BUCK3_BASE,\n};\n\n#define LP3971_BUCK_TARGET_VOL1_REG(x) (buck_base_addr[x])\n#define LP3971_BUCK_TARGET_VOL2_REG(x) (buck_base_addr[x]+1)\n\nstatic const unsigned int buck_voltage_map[] = {\n\t      0,  800000,  850000,  900000,  950000, 1000000, 1050000, 1100000,\n\t1150000, 1200000, 1250000, 1300000, 1350000, 1400000, 1450000, 1500000,\n\t1550000, 1600000, 1650000, 1700000, 1800000, 1900000, 2500000, 2800000,\n\t3000000, 3300000,\n};\n\n#define BUCK_TARGET_VOL_MASK 0x3f\n\n#define LP3971_BUCK_RAMP_REG(x)\t(buck_base_addr[x]+2)\n\n#define LP3971_LDO_ENABLE_REG 0x12\n#define LP3971_LDO_VOL_CONTR_BASE 0x39\n\n \n#define LP3971_LDO_VOL_CONTR_REG(x)\t(LP3971_LDO_VOL_CONTR_BASE + (x >> 1))\n\n \n#define LDO_VOL_CONTR_SHIFT(x) ((x & 1) << 2)\n#define LDO_VOL_CONTR_MASK 0x0f\n\nstatic const unsigned int ldo45_voltage_map[] = {\n\t1000000, 1050000, 1100000, 1150000, 1200000, 1250000, 1300000, 1350000,\n\t1400000, 1500000, 1800000, 1900000, 2500000, 2800000, 3000000, 3300000,\n};\n\nstatic const unsigned int ldo123_voltage_map[] = {\n\t1800000, 1900000, 2000000, 2100000, 2200000, 2300000, 2400000, 2500000,\n\t2600000, 2700000, 2800000, 2900000, 3000000, 3100000, 3200000, 3300000,\n};\n\n#define LDO_VOL_MIN_IDX 0x00\n#define LDO_VOL_MAX_IDX 0x0f\n\nstatic int lp3971_ldo_is_enabled(struct regulator_dev *dev)\n{\n\tstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\n\tint ldo = rdev_get_id(dev) - LP3971_LDO1;\n\tu16 mask = 1 << (1 + ldo);\n\tu16 val;\n\n\tval = lp3971_reg_read(lp3971, LP3971_LDO_ENABLE_REG);\n\treturn (val & mask) != 0;\n}\n\nstatic int lp3971_ldo_enable(struct regulator_dev *dev)\n{\n\tstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\n\tint ldo = rdev_get_id(dev) - LP3971_LDO1;\n\tu16 mask = 1 << (1 + ldo);\n\n\treturn lp3971_set_bits(lp3971, LP3971_LDO_ENABLE_REG, mask, mask);\n}\n\nstatic int lp3971_ldo_disable(struct regulator_dev *dev)\n{\n\tstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\n\tint ldo = rdev_get_id(dev) - LP3971_LDO1;\n\tu16 mask = 1 << (1 + ldo);\n\n\treturn lp3971_set_bits(lp3971, LP3971_LDO_ENABLE_REG, mask, 0);\n}\n\nstatic int lp3971_ldo_get_voltage_sel(struct regulator_dev *dev)\n{\n\tstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\n\tint ldo = rdev_get_id(dev) - LP3971_LDO1;\n\tu16 val, reg;\n\n\treg = lp3971_reg_read(lp3971, LP3971_LDO_VOL_CONTR_REG(ldo));\n\tval = (reg >> LDO_VOL_CONTR_SHIFT(ldo)) & LDO_VOL_CONTR_MASK;\n\n\treturn val;\n}\n\nstatic int lp3971_ldo_set_voltage_sel(struct regulator_dev *dev,\n\t\t\t\t      unsigned int selector)\n{\n\tstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\n\tint ldo = rdev_get_id(dev) - LP3971_LDO1;\n\n\treturn lp3971_set_bits(lp3971, LP3971_LDO_VOL_CONTR_REG(ldo),\n\t\t\tLDO_VOL_CONTR_MASK << LDO_VOL_CONTR_SHIFT(ldo),\n\t\t\tselector << LDO_VOL_CONTR_SHIFT(ldo));\n}\n\nstatic const struct regulator_ops lp3971_ldo_ops = {\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n\t.is_enabled = lp3971_ldo_is_enabled,\n\t.enable = lp3971_ldo_enable,\n\t.disable = lp3971_ldo_disable,\n\t.get_voltage_sel = lp3971_ldo_get_voltage_sel,\n\t.set_voltage_sel = lp3971_ldo_set_voltage_sel,\n};\n\nstatic int lp3971_dcdc_is_enabled(struct regulator_dev *dev)\n{\n\tstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\n\tint buck = rdev_get_id(dev) - LP3971_DCDC1;\n\tu16 mask = 1 << (buck * 2);\n\tu16 val;\n\n\tval = lp3971_reg_read(lp3971, LP3971_BUCK_VOL_ENABLE_REG);\n\treturn (val & mask) != 0;\n}\n\nstatic int lp3971_dcdc_enable(struct regulator_dev *dev)\n{\n\tstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\n\tint buck = rdev_get_id(dev) - LP3971_DCDC1;\n\tu16 mask = 1 << (buck * 2);\n\n\treturn lp3971_set_bits(lp3971, LP3971_BUCK_VOL_ENABLE_REG, mask, mask);\n}\n\nstatic int lp3971_dcdc_disable(struct regulator_dev *dev)\n{\n\tstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\n\tint buck = rdev_get_id(dev) - LP3971_DCDC1;\n\tu16 mask = 1 << (buck * 2);\n\n\treturn lp3971_set_bits(lp3971, LP3971_BUCK_VOL_ENABLE_REG, mask, 0);\n}\n\nstatic int lp3971_dcdc_get_voltage_sel(struct regulator_dev *dev)\n{\n\tstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\n\tint buck = rdev_get_id(dev) - LP3971_DCDC1;\n\tu16 reg;\n\n\treg = lp3971_reg_read(lp3971, LP3971_BUCK_TARGET_VOL1_REG(buck));\n\treg &= BUCK_TARGET_VOL_MASK;\n\n\treturn reg;\n}\n\nstatic int lp3971_dcdc_set_voltage_sel(struct regulator_dev *dev,\n\t\t\t\t       unsigned int selector)\n{\n\tstruct lp3971 *lp3971 = rdev_get_drvdata(dev);\n\tint buck = rdev_get_id(dev) - LP3971_DCDC1;\n\tint ret;\n\n\tret = lp3971_set_bits(lp3971, LP3971_BUCK_TARGET_VOL1_REG(buck),\n\t       BUCK_TARGET_VOL_MASK, selector);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lp3971_set_bits(lp3971, LP3971_BUCK_VOL_CHANGE_REG,\n\t       BUCK_VOL_CHANGE_FLAG_MASK << BUCK_VOL_CHANGE_SHIFT(buck),\n\t       BUCK_VOL_CHANGE_FLAG_GO << BUCK_VOL_CHANGE_SHIFT(buck));\n\tif (ret)\n\t\treturn ret;\n\n\treturn lp3971_set_bits(lp3971, LP3971_BUCK_VOL_CHANGE_REG,\n\t       BUCK_VOL_CHANGE_FLAG_MASK << BUCK_VOL_CHANGE_SHIFT(buck),\n\t       0 << BUCK_VOL_CHANGE_SHIFT(buck));\n}\n\nstatic const struct regulator_ops lp3971_dcdc_ops = {\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n\t.is_enabled = lp3971_dcdc_is_enabled,\n\t.enable = lp3971_dcdc_enable,\n\t.disable = lp3971_dcdc_disable,\n\t.get_voltage_sel = lp3971_dcdc_get_voltage_sel,\n\t.set_voltage_sel = lp3971_dcdc_set_voltage_sel,\n};\n\nstatic const struct regulator_desc regulators[] = {\n\t{\n\t\t.name = \"LDO1\",\n\t\t.id = LP3971_LDO1,\n\t\t.ops = &lp3971_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(ldo123_voltage_map),\n\t\t.volt_table = ldo123_voltage_map,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"LDO2\",\n\t\t.id = LP3971_LDO2,\n\t\t.ops = &lp3971_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(ldo123_voltage_map),\n\t\t.volt_table = ldo123_voltage_map,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"LDO3\",\n\t\t.id = LP3971_LDO3,\n\t\t.ops = &lp3971_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(ldo123_voltage_map),\n\t\t.volt_table = ldo123_voltage_map,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"LDO4\",\n\t\t.id = LP3971_LDO4,\n\t\t.ops = &lp3971_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(ldo45_voltage_map),\n\t\t.volt_table = ldo45_voltage_map,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"LDO5\",\n\t\t.id = LP3971_LDO5,\n\t\t.ops = &lp3971_ldo_ops,\n\t\t.n_voltages = ARRAY_SIZE(ldo45_voltage_map),\n\t\t.volt_table = ldo45_voltage_map,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"DCDC1\",\n\t\t.id = LP3971_DCDC1,\n\t\t.ops = &lp3971_dcdc_ops,\n\t\t.n_voltages = ARRAY_SIZE(buck_voltage_map),\n\t\t.volt_table = buck_voltage_map,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"DCDC2\",\n\t\t.id = LP3971_DCDC2,\n\t\t.ops = &lp3971_dcdc_ops,\n\t\t.n_voltages = ARRAY_SIZE(buck_voltage_map),\n\t\t.volt_table = buck_voltage_map,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"DCDC3\",\n\t\t.id = LP3971_DCDC3,\n\t\t.ops = &lp3971_dcdc_ops,\n\t\t.n_voltages = ARRAY_SIZE(buck_voltage_map),\n\t\t.volt_table = buck_voltage_map,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\nstatic int lp3971_i2c_read(struct i2c_client *i2c, char reg, int count,\n\tu16 *dest)\n{\n\tint ret;\n\n\tif (count != 1)\n\t\treturn -EIO;\n\tret = i2c_smbus_read_byte_data(i2c, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*dest = ret;\n\treturn 0;\n}\n\nstatic int lp3971_i2c_write(struct i2c_client *i2c, char reg, int count,\n\tconst u16 *src)\n{\n\tif (count != 1)\n\t\treturn -EIO;\n\treturn i2c_smbus_write_byte_data(i2c, reg, *src);\n}\n\nstatic u8 lp3971_reg_read(struct lp3971 *lp3971, u8 reg)\n{\n\tu16 val = 0;\n\n\tmutex_lock(&lp3971->io_lock);\n\n\tlp3971_i2c_read(lp3971->i2c, reg, 1, &val);\n\n\tdev_dbg(lp3971->dev, \"reg read 0x%02x -> 0x%02x\\n\", (int)reg,\n\t\t(unsigned)val&0xff);\n\n\tmutex_unlock(&lp3971->io_lock);\n\n\treturn val & 0xff;\n}\n\nstatic int lp3971_set_bits(struct lp3971 *lp3971, u8 reg, u16 mask, u16 val)\n{\n\tu16 tmp;\n\tint ret;\n\n\tmutex_lock(&lp3971->io_lock);\n\n\tret = lp3971_i2c_read(lp3971->i2c, reg, 1, &tmp);\n\tif (ret == 0) {\n\t\ttmp = (tmp & ~mask) | val;\n\t\tret = lp3971_i2c_write(lp3971->i2c, reg, 1, &tmp);\n\t\tdev_dbg(lp3971->dev, \"reg write 0x%02x -> 0x%02x\\n\", (int)reg,\n\t\t\t(unsigned)val&0xff);\n\t}\n\tmutex_unlock(&lp3971->io_lock);\n\n\treturn ret;\n}\n\nstatic int setup_regulators(struct lp3971 *lp3971,\n\t\t\t\t      struct lp3971_platform_data *pdata)\n{\n\tint i, err;\n\n\t \n\tfor (i = 0; i < pdata->num_regulators; i++) {\n\t\tstruct regulator_config config = { };\n\t\tstruct lp3971_regulator_subdev *reg = &pdata->regulators[i];\n\t\tstruct regulator_dev *rdev;\n\n\t\tconfig.dev = lp3971->dev;\n\t\tconfig.init_data = reg->initdata;\n\t\tconfig.driver_data = lp3971;\n\n\t\trdev = devm_regulator_register(lp3971->dev,\n\t\t\t\t\t       &regulators[reg->id], &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\terr = PTR_ERR(rdev);\n\t\t\tdev_err(lp3971->dev, \"regulator init failed: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lp3971_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct lp3971 *lp3971;\n\tstruct lp3971_platform_data *pdata = dev_get_platdata(&i2c->dev);\n\tint ret;\n\tu16 val;\n\n\tif (!pdata) {\n\t\tdev_dbg(&i2c->dev, \"No platform init data supplied\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlp3971 = devm_kzalloc(&i2c->dev, sizeof(struct lp3971), GFP_KERNEL);\n\tif (lp3971 == NULL)\n\t\treturn -ENOMEM;\n\n\tlp3971->i2c = i2c;\n\tlp3971->dev = &i2c->dev;\n\n\tmutex_init(&lp3971->io_lock);\n\n\t \n\tret = lp3971_i2c_read(i2c, LP3971_SYS_CONTROL1_REG, 1, &val);\n\tif (ret == 0 && (val & SYS_CONTROL1_INIT_MASK) != SYS_CONTROL1_INIT_VAL)\n\t\tret = -ENODEV;\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"failed to detect device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = setup_regulators(lp3971, pdata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ti2c_set_clientdata(i2c, lp3971);\n\treturn 0;\n}\n\nstatic const struct i2c_device_id lp3971_i2c_id[] = {\n\t{ \"lp3971\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lp3971_i2c_id);\n\nstatic struct i2c_driver lp3971_i2c_driver = {\n\t.driver = {\n\t\t.name = \"LP3971\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = lp3971_i2c_probe,\n\t.id_table = lp3971_i2c_id,\n};\n\nmodule_i2c_driver(lp3971_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Marek Szyprowski <m.szyprowski@samsung.com>\");\nMODULE_DESCRIPTION(\"LP3971 PMIC driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}