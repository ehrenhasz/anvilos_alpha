{
  "module_name": "scmi-regulator.c",
  "hash_id": "2c078b9a70a08b79c56e472e9d932ea757a3e7a01bf03e93d234d2490dc41042",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/scmi-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/linear_range.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/scmi_protocol.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct scmi_voltage_proto_ops *voltage_ops;\n\nstruct scmi_regulator {\n\tu32 id;\n\tstruct scmi_device *sdev;\n\tstruct scmi_protocol_handle *ph;\n\tstruct regulator_dev *rdev;\n\tstruct device_node *of_node;\n\tstruct regulator_desc desc;\n\tstruct regulator_config conf;\n};\n\nstruct scmi_regulator_info {\n\tint num_doms;\n\tstruct scmi_regulator **sregv;\n};\n\nstatic int scmi_reg_enable(struct regulator_dev *rdev)\n{\n\tstruct scmi_regulator *sreg = rdev_get_drvdata(rdev);\n\n\treturn voltage_ops->config_set(sreg->ph, sreg->id,\n\t\t\t\t       SCMI_VOLTAGE_ARCH_STATE_ON);\n}\n\nstatic int scmi_reg_disable(struct regulator_dev *rdev)\n{\n\tstruct scmi_regulator *sreg = rdev_get_drvdata(rdev);\n\n\treturn voltage_ops->config_set(sreg->ph, sreg->id,\n\t\t\t\t       SCMI_VOLTAGE_ARCH_STATE_OFF);\n}\n\nstatic int scmi_reg_is_enabled(struct regulator_dev *rdev)\n{\n\tint ret;\n\tu32 config;\n\tstruct scmi_regulator *sreg = rdev_get_drvdata(rdev);\n\n\tret = voltage_ops->config_get(sreg->ph, sreg->id, &config);\n\tif (ret) {\n\t\tdev_err(&sreg->sdev->dev,\n\t\t\t\"Error %d reading regulator %s status.\\n\",\n\t\t\tret, sreg->desc.name);\n\t\treturn ret;\n\t}\n\n\treturn config & SCMI_VOLTAGE_ARCH_STATE_ON;\n}\n\nstatic int scmi_reg_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tint ret;\n\ts32 volt_uV;\n\tstruct scmi_regulator *sreg = rdev_get_drvdata(rdev);\n\n\tret = voltage_ops->level_get(sreg->ph, sreg->id, &volt_uV);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sreg->desc.ops->map_voltage(rdev, volt_uV, volt_uV);\n}\n\nstatic int scmi_reg_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t    unsigned int selector)\n{\n\ts32 volt_uV;\n\tstruct scmi_regulator *sreg = rdev_get_drvdata(rdev);\n\n\tvolt_uV = sreg->desc.ops->list_voltage(rdev, selector);\n\tif (volt_uV <= 0)\n\t\treturn -EINVAL;\n\n\treturn voltage_ops->level_set(sreg->ph, sreg->id, 0x0, volt_uV);\n}\n\nstatic const struct regulator_ops scmi_reg_fixed_ops = {\n\t.enable = scmi_reg_enable,\n\t.disable = scmi_reg_disable,\n\t.is_enabled = scmi_reg_is_enabled,\n};\n\nstatic const struct regulator_ops scmi_reg_linear_ops = {\n\t.enable = scmi_reg_enable,\n\t.disable = scmi_reg_disable,\n\t.is_enabled = scmi_reg_is_enabled,\n\t.get_voltage_sel = scmi_reg_get_voltage_sel,\n\t.set_voltage_sel = scmi_reg_set_voltage_sel,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n};\n\nstatic const struct regulator_ops scmi_reg_discrete_ops = {\n\t.enable = scmi_reg_enable,\n\t.disable = scmi_reg_disable,\n\t.is_enabled = scmi_reg_is_enabled,\n\t.get_voltage_sel = scmi_reg_get_voltage_sel,\n\t.set_voltage_sel = scmi_reg_set_voltage_sel,\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_iterate,\n};\n\nstatic int\nscmi_config_linear_regulator_mappings(struct scmi_regulator *sreg,\n\t\t\t\t      const struct scmi_voltage_info *vinfo)\n{\n\ts32 delta_uV;\n\n\t \n\n\tdelta_uV = (vinfo->levels_uv[SCMI_VOLTAGE_SEGMENT_HIGH] -\n\t\t\tvinfo->levels_uv[SCMI_VOLTAGE_SEGMENT_LOW]);\n\n\t \n\tif (delta_uV < 0) {\n\t\tdev_err(&sreg->sdev->dev,\n\t\t\t\"Invalid volt-range %d-%duV for domain %d\\n\",\n\t\t\tvinfo->levels_uv[SCMI_VOLTAGE_SEGMENT_LOW],\n\t\t\tvinfo->levels_uv[SCMI_VOLTAGE_SEGMENT_HIGH],\n\t\t\tsreg->id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!delta_uV) {\n\t\t \n\t\tsreg->desc.fixed_uV =\n\t\t\tvinfo->levels_uv[SCMI_VOLTAGE_SEGMENT_LOW];\n\t\tsreg->desc.n_voltages = 1;\n\t\tsreg->desc.ops = &scmi_reg_fixed_ops;\n\t} else {\n\t\t \n\t\tsreg->desc.min_uV =\n\t\t\tvinfo->levels_uv[SCMI_VOLTAGE_SEGMENT_LOW];\n\t\tsreg->desc.uV_step =\n\t\t\tvinfo->levels_uv[SCMI_VOLTAGE_SEGMENT_STEP];\n\t\tsreg->desc.linear_min_sel = 0;\n\t\tsreg->desc.n_voltages = (delta_uV / sreg->desc.uV_step) + 1;\n\t\tsreg->desc.ops = &scmi_reg_linear_ops;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nscmi_config_discrete_regulator_mappings(struct scmi_regulator *sreg,\n\t\t\t\t\tconst struct scmi_voltage_info *vinfo)\n{\n\t \n\tsreg->desc.n_voltages = vinfo->num_levels;\n\n\tif (sreg->desc.n_voltages > 1) {\n\t\tsreg->desc.volt_table = (const unsigned int *)vinfo->levels_uv;\n\t\tsreg->desc.ops = &scmi_reg_discrete_ops;\n\t} else {\n\t\tsreg->desc.fixed_uV = vinfo->levels_uv[0];\n\t\tsreg->desc.ops = &scmi_reg_fixed_ops;\n\t}\n\n\treturn 0;\n}\n\nstatic int scmi_regulator_common_init(struct scmi_regulator *sreg)\n{\n\tint ret;\n\tstruct device *dev = &sreg->sdev->dev;\n\tconst struct scmi_voltage_info *vinfo;\n\n\tvinfo = voltage_ops->info_get(sreg->ph, sreg->id);\n\tif (!vinfo) {\n\t\tdev_warn(dev, \"Failure to get voltage domain %d\\n\",\n\t\t\t sreg->id);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (vinfo->negative_volts_allowed) {\n\t\tdev_warn(dev, \"Negative voltages NOT supported...skip %s\\n\",\n\t\t\t sreg->of_node->full_name);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tsreg->desc.name = devm_kasprintf(dev, GFP_KERNEL, \"%s\", vinfo->name);\n\tif (!sreg->desc.name)\n\t\treturn -ENOMEM;\n\n\tsreg->desc.id = sreg->id;\n\tsreg->desc.type = REGULATOR_VOLTAGE;\n\tsreg->desc.owner = THIS_MODULE;\n\tsreg->desc.of_match_full_name = true;\n\tsreg->desc.of_match = sreg->of_node->full_name;\n\tsreg->desc.regulators_node = \"regulators\";\n\tif (vinfo->segmented)\n\t\tret = scmi_config_linear_regulator_mappings(sreg, vinfo);\n\telse\n\t\tret = scmi_config_discrete_regulator_mappings(sreg, vinfo);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsreg->conf.dev = dev;\n\n\t \n\tsreg->conf.driver_data = sreg;\n\n\treturn 0;\n}\n\nstatic int process_scmi_regulator_of_node(struct scmi_device *sdev,\n\t\t\t\t\t  struct scmi_protocol_handle *ph,\n\t\t\t\t\t  struct device_node *np,\n\t\t\t\t\t  struct scmi_regulator_info *rinfo)\n{\n\tu32 dom, ret;\n\n\tret = of_property_read_u32(np, \"reg\", &dom);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dom >= rinfo->num_doms)\n\t\treturn -ENODEV;\n\n\tif (rinfo->sregv[dom]) {\n\t\tdev_err(&sdev->dev,\n\t\t\t\"SCMI Voltage Domain %d already in use. Skipping: %s\\n\",\n\t\t\tdom, np->full_name);\n\t\treturn -EINVAL;\n\t}\n\n\trinfo->sregv[dom] = devm_kzalloc(&sdev->dev,\n\t\t\t\t\t sizeof(struct scmi_regulator),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!rinfo->sregv[dom])\n\t\treturn -ENOMEM;\n\n\trinfo->sregv[dom]->id = dom;\n\trinfo->sregv[dom]->sdev = sdev;\n\trinfo->sregv[dom]->ph = ph;\n\n\t \n\tof_node_get(np);\n\trinfo->sregv[dom]->of_node = np;\n\n\tdev_dbg(&sdev->dev,\n\t\t\"Found SCMI Regulator entry -- OF node [%d] -> %s\\n\",\n\t\tdom, np->full_name);\n\n\treturn 0;\n}\n\nstatic int scmi_regulator_probe(struct scmi_device *sdev)\n{\n\tint d, ret, num_doms;\n\tstruct device_node *np, *child;\n\tconst struct scmi_handle *handle = sdev->handle;\n\tstruct scmi_regulator_info *rinfo;\n\tstruct scmi_protocol_handle *ph;\n\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tvoltage_ops = handle->devm_protocol_get(sdev,\n\t\t\t\t\t\tSCMI_PROTOCOL_VOLTAGE, &ph);\n\tif (IS_ERR(voltage_ops))\n\t\treturn PTR_ERR(voltage_ops);\n\n\tnum_doms = voltage_ops->num_domains_get(ph);\n\tif (!num_doms)\n\t\treturn 0;\n\n\tif (num_doms < 0) {\n\t\tdev_err(&sdev->dev, \"failed to get voltage domains - err:%d\\n\",\n\t\t\tnum_doms);\n\n\t\treturn num_doms;\n\t}\n\n\trinfo = devm_kzalloc(&sdev->dev, sizeof(*rinfo), GFP_KERNEL);\n\tif (!rinfo)\n\t\treturn -ENOMEM;\n\n\t \n\trinfo->sregv = devm_kcalloc(&sdev->dev, num_doms,\n\t\t\t\t    sizeof(void *), GFP_KERNEL);\n\tif (!rinfo->sregv)\n\t\treturn -ENOMEM;\n\n\trinfo->num_doms = num_doms;\n\n\t \n\tof_node_get(handle->dev->of_node);\n\tnp = of_find_node_by_name(handle->dev->of_node, \"regulators\");\n\tfor_each_child_of_node(np, child) {\n\t\tret = process_scmi_regulator_of_node(sdev, ph, child, rinfo);\n\t\t \n\t\tif (ret == -ENOMEM) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tof_node_put(np);\n\t \n\tfor (d = 0; d < num_doms; d++) {\n\t\tstruct scmi_regulator *sreg = rinfo->sregv[d];\n\n\t\t \n\t\tif (!sreg)\n\t\t\tcontinue;\n\n\t\tret = scmi_regulator_common_init(sreg);\n\t\t \n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tsreg->rdev = devm_regulator_register(&sdev->dev, &sreg->desc,\n\t\t\t\t\t\t     &sreg->conf);\n\t\tif (IS_ERR(sreg->rdev)) {\n\t\t\tsreg->rdev = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_info(&sdev->dev,\n\t\t\t \"Regulator %s registered for domain [%d]\\n\",\n\t\t\t sreg->desc.name, sreg->id);\n\t}\n\n\tdev_set_drvdata(&sdev->dev, rinfo);\n\n\treturn 0;\n}\n\nstatic void scmi_regulator_remove(struct scmi_device *sdev)\n{\n\tint d;\n\tstruct scmi_regulator_info *rinfo;\n\n\trinfo = dev_get_drvdata(&sdev->dev);\n\tif (!rinfo)\n\t\treturn;\n\n\tfor (d = 0; d < rinfo->num_doms; d++) {\n\t\tif (!rinfo->sregv[d])\n\t\t\tcontinue;\n\t\tof_node_put(rinfo->sregv[d]->of_node);\n\t}\n}\n\nstatic const struct scmi_device_id scmi_regulator_id_table[] = {\n\t{ SCMI_PROTOCOL_VOLTAGE,  \"regulator\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(scmi, scmi_regulator_id_table);\n\nstatic struct scmi_driver scmi_drv = {\n\t.name\t\t= \"scmi-regulator\",\n\t.probe\t\t= scmi_regulator_probe,\n\t.remove\t\t= scmi_regulator_remove,\n\t.id_table\t= scmi_regulator_id_table,\n};\n\nmodule_scmi_driver(scmi_drv);\n\nMODULE_AUTHOR(\"Cristian Marussi <cristian.marussi@arm.com>\");\nMODULE_DESCRIPTION(\"ARM SCMI regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}