{
  "module_name": "wm831x-isink.c",
  "hash_id": "d0ba7238ce70d864b15bb4ad7d6d1047bf804f2d9070b37a76831f01bffdbc79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/wm831x-isink.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/slab.h>\n\n#include <linux/mfd/wm831x/core.h>\n#include <linux/mfd/wm831x/regulator.h>\n#include <linux/mfd/wm831x/pdata.h>\n\n#define WM831X_ISINK_MAX_NAME 7\n\nstruct wm831x_isink {\n\tchar name[WM831X_ISINK_MAX_NAME];\n\tstruct regulator_desc desc;\n\tint reg;\n\tstruct wm831x *wm831x;\n\tstruct regulator_dev *regulator;\n};\n\nstatic int wm831x_isink_enable(struct regulator_dev *rdev)\n{\n\tstruct wm831x_isink *isink = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = isink->wm831x;\n\tint ret;\n\n\t \n\tret = wm831x_set_bits(wm831x, isink->reg, WM831X_CS1_ENA,\n\t\t\t      WM831X_CS1_ENA);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tret = wm831x_set_bits(wm831x, isink->reg, WM831X_CS1_DRIVE,\n\t\t\t      WM831X_CS1_DRIVE);\n\tif (ret != 0)\n\t\twm831x_set_bits(wm831x, isink->reg, WM831X_CS1_ENA, 0);\n\n\treturn ret;\n\n}\n\nstatic int wm831x_isink_disable(struct regulator_dev *rdev)\n{\n\tstruct wm831x_isink *isink = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = isink->wm831x;\n\tint ret;\n\n\tret = wm831x_set_bits(wm831x, isink->reg, WM831X_CS1_DRIVE, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wm831x_set_bits(wm831x, isink->reg, WM831X_CS1_ENA, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret;\n\n}\n\nstatic int wm831x_isink_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct wm831x_isink *isink = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = isink->wm831x;\n\tint ret;\n\n\tret = wm831x_reg_read(wm831x, isink->reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((ret & (WM831X_CS1_ENA | WM831X_CS1_DRIVE)) ==\n\t    (WM831X_CS1_ENA | WM831X_CS1_DRIVE))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic const struct regulator_ops wm831x_isink_ops = {\n\t.is_enabled = wm831x_isink_is_enabled,\n\t.enable = wm831x_isink_enable,\n\t.disable = wm831x_isink_disable,\n\t.set_current_limit = regulator_set_current_limit_regmap,\n\t.get_current_limit = regulator_get_current_limit_regmap,\n};\n\nstatic irqreturn_t wm831x_isink_irq(int irq, void *data)\n{\n\tstruct wm831x_isink *isink = data;\n\n\tregulator_notifier_call_chain(isink->regulator,\n\t\t\t\t      REGULATOR_EVENT_OVER_CURRENT,\n\t\t\t\t      NULL);\n\n\treturn IRQ_HANDLED;\n}\n\n\nstatic int wm831x_isink_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\n\tstruct wm831x_isink *isink;\n\tint id = pdev->id % ARRAY_SIZE(pdata->isink);\n\tstruct regulator_config config = { };\n\tstruct resource *res;\n\tint ret, irq;\n\n\tdev_dbg(&pdev->dev, \"Probing ISINK%d\\n\", id + 1);\n\n\tif (pdata == NULL || pdata->isink[id] == NULL)\n\t\treturn -ENODEV;\n\n\tisink = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_isink),\n\t\t\t     GFP_KERNEL);\n\tif (!isink)\n\t\treturn -ENOMEM;\n\n\tisink->wm831x = wm831x;\n\n\tres = platform_get_resource(pdev, IORESOURCE_REG, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"No REG resource\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tisink->reg = res->start;\n\n\t \n\tsnprintf(isink->name, sizeof(isink->name), \"ISINK%d\", id + 1);\n\tisink->desc.name = isink->name;\n\tisink->desc.id = id;\n\tisink->desc.ops = &wm831x_isink_ops;\n\tisink->desc.type = REGULATOR_CURRENT;\n\tisink->desc.owner = THIS_MODULE;\n\tisink->desc.curr_table = wm831x_isinkv_values,\n\tisink->desc.n_current_limits = ARRAY_SIZE(wm831x_isinkv_values),\n\tisink->desc.csel_reg = isink->reg,\n\tisink->desc.csel_mask = WM831X_CS1_ISEL_MASK,\n\n\tconfig.dev = pdev->dev.parent;\n\tconfig.init_data = pdata->isink[id];\n\tconfig.driver_data = isink;\n\tconfig.regmap = wm831x->regmap;\n\n\tisink->regulator = devm_regulator_register(&pdev->dev, &isink->desc,\n\t\t\t\t\t\t   &config);\n\tif (IS_ERR(isink->regulator)) {\n\t\tret = PTR_ERR(isink->regulator);\n\t\tdev_err(wm831x->dev, \"Failed to register ISINK%d: %d\\n\",\n\t\t\tid + 1, ret);\n\t\tgoto err;\n\t}\n\n\tirq = wm831x_irq(wm831x, platform_get_irq(pdev, 0));\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\twm831x_isink_irq,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tisink->name,\n\t\t\t\t\tisink);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request ISINK IRQ %d: %d\\n\",\n\t\t\tirq, ret);\n\t\tgoto err;\n\t}\n\n\tplatform_set_drvdata(pdev, isink);\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic struct platform_driver wm831x_isink_driver = {\n\t.probe = wm831x_isink_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"wm831x-isink\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init wm831x_isink_init(void)\n{\n\tint ret;\n\tret = platform_driver_register(&wm831x_isink_driver);\n\tif (ret != 0)\n\t\tpr_err(\"Failed to register WM831x ISINK driver: %d\\n\", ret);\n\n\treturn ret;\n}\nsubsys_initcall(wm831x_isink_init);\n\nstatic void __exit wm831x_isink_exit(void)\n{\n\tplatform_driver_unregister(&wm831x_isink_driver);\n}\nmodule_exit(wm831x_isink_exit);\n\n \nMODULE_AUTHOR(\"Mark Brown\");\nMODULE_DESCRIPTION(\"WM831x current sink driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm831x-isink\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}