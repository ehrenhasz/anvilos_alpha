{
  "module_name": "tps6586x-regulator.c",
  "hash_id": "e27d9f32c71dcd26275712a53f87c6e7463d4cc5694c74e0a7fe4f3cf46c2763",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/tps6586x-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/mfd/tps6586x.h>\n\n \n#define TPS6586X_SUPPLYENA\t0x10\n#define TPS6586X_SUPPLYENB\t0x11\n#define TPS6586X_SUPPLYENC\t0x12\n#define TPS6586X_SUPPLYEND\t0x13\n#define TPS6586X_SUPPLYENE\t0x14\n#define TPS6586X_VCC1\t\t0x20\n#define TPS6586X_VCC2\t\t0x21\n#define TPS6586X_SM1V1\t\t0x23\n#define TPS6586X_SM1V2\t\t0x24\n#define TPS6586X_SM1SL\t\t0x25\n#define TPS6586X_SM0V1\t\t0x26\n#define TPS6586X_SM0V2\t\t0x27\n#define TPS6586X_SM0SL\t\t0x28\n#define TPS6586X_LDO2AV1\t0x29\n#define TPS6586X_LDO2AV2\t0x2A\n#define TPS6586X_LDO2BV1\t0x2F\n#define TPS6586X_LDO2BV2\t0x30\n#define TPS6586X_LDO4V1\t\t0x32\n#define TPS6586X_LDO4V2\t\t0x33\n\n \n#define TPS6586X_SUPPLYV1\t0x41\n#define TPS6586X_SUPPLYV2\t0x42\n#define TPS6586X_SUPPLYV3\t0x43\n#define TPS6586X_SUPPLYV4\t0x44\n#define TPS6586X_SUPPLYV5\t0x45\n#define TPS6586X_SUPPLYV6\t0x46\n#define TPS6586X_SMODE1\t\t0x47\n#define TPS6586X_SMODE2\t\t0x48\n\nstruct tps6586x_regulator {\n\tstruct regulator_desc desc;\n\n\tint enable_bit[2];\n\tint enable_reg[2];\n};\n\nstatic const struct regulator_ops tps6586x_rw_regulator_ops = {\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n};\n\nstatic const struct regulator_ops tps6586x_rw_linear_regulator_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n};\n\nstatic const struct regulator_ops tps6586x_ro_regulator_ops = {\n\t.list_voltage = regulator_list_voltage_table,\n\t.map_voltage = regulator_map_voltage_ascend,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n};\n\nstatic const struct regulator_ops tps6586x_sys_regulator_ops = {\n};\n\nstatic const unsigned int tps6586x_ldo0_voltages[] = {\n\t1200000, 1500000, 1800000, 2500000, 2700000, 2850000, 3100000, 3300000,\n};\n\nstatic const unsigned int tps6586x_ldo_voltages[] = {\n\t1250000, 1500000, 1800000, 2500000, 2700000, 2850000, 3100000, 3300000,\n};\n\nstatic const unsigned int tps658640_rtc_voltages[] = {\n\t2500000, 2850000, 3100000, 3300000,\n};\n\n#define TPS6586X_REGULATOR(_id, _ops, _pin_name, vdata, vreg, shift, nbits, \\\n\t\t\t   ereg0, ebit0, ereg1, ebit1, goreg, gobit)\t\\\n\t.desc\t= {\t\t\t\t\t\t\t\\\n\t\t.supply_name = _pin_name,\t\t\t\t\\\n\t\t.name\t= \"REG-\" #_id,\t\t\t\t\t\\\n\t\t.ops\t= &tps6586x_## _ops ## _regulator_ops,\t\t\\\n\t\t.type\t= REGULATOR_VOLTAGE,\t\t\t\t\\\n\t\t.id\t= TPS6586X_ID_##_id,\t\t\t\t\\\n\t\t.n_voltages = ARRAY_SIZE(vdata##_voltages),\t\t\\\n\t\t.volt_table = vdata##_voltages,\t\t\t\t\\\n\t\t.owner\t= THIS_MODULE,\t\t\t\t\t\\\n\t\t.enable_reg = TPS6586X_SUPPLY##ereg0,\t\t\t\\\n\t\t.enable_mask = 1 << (ebit0),\t\t\t\t\\\n\t\t.vsel_reg = TPS6586X_##vreg,\t\t\t\t\\\n\t\t.vsel_mask = ((1 << (nbits)) - 1) << (shift),\t\t\\\n\t\t.apply_reg = (goreg),\t\t\t\t\\\n\t\t.apply_bit = (gobit),\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.enable_reg[0]\t= TPS6586X_SUPPLY##ereg0,\t\t\t\\\n\t.enable_bit[0]\t= (ebit0),\t\t\t\t\t\\\n\t.enable_reg[1]\t= TPS6586X_SUPPLY##ereg1,\t\t\t\\\n\t.enable_bit[1]\t= (ebit1),\n\n#define TPS6586X_REGULATOR_LINEAR(_id, _ops, _pin_name, n_volt, min_uv,\t\\\n\t\t\t\t  uv_step, vreg, shift, nbits, ereg0,\t\\\n\t\t\t\t  ebit0, ereg1, ebit1, goreg, gobit)\t\\\n\t.desc\t= {\t\t\t\t\t\t\t\\\n\t\t.supply_name = _pin_name,\t\t\t\t\\\n\t\t.name\t= \"REG-\" #_id,\t\t\t\t\t\\\n\t\t.ops\t= &tps6586x_## _ops ## _regulator_ops,\t\t\\\n\t\t.type\t= REGULATOR_VOLTAGE,\t\t\t\t\\\n\t\t.id\t= TPS6586X_ID_##_id,\t\t\t\t\\\n\t\t.n_voltages = n_volt,\t\t\t\t\t\\\n\t\t.min_uV = min_uv,\t\t\t\t\t\\\n\t\t.uV_step = uv_step,\t\t\t\t\t\\\n\t\t.owner\t= THIS_MODULE,\t\t\t\t\t\\\n\t\t.enable_reg = TPS6586X_SUPPLY##ereg0,\t\t\t\\\n\t\t.enable_mask = 1 << (ebit0),\t\t\t\t\\\n\t\t.vsel_reg = TPS6586X_##vreg,\t\t\t\t\\\n\t\t.vsel_mask = ((1 << (nbits)) - 1) << (shift),\t\t\\\n\t\t.apply_reg = (goreg),\t\t\t\t\\\n\t\t.apply_bit = (gobit),\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.enable_reg[0]\t= TPS6586X_SUPPLY##ereg0,\t\t\t\\\n\t.enable_bit[0]\t= (ebit0),\t\t\t\t\t\\\n\t.enable_reg[1]\t= TPS6586X_SUPPLY##ereg1,\t\t\t\\\n\t.enable_bit[1]\t= (ebit1),\n\n#define TPS6586X_LDO(_id, _pname, vdata, vreg, shift, nbits,\t\t\\\n\t\t     ereg0, ebit0, ereg1, ebit1)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tTPS6586X_REGULATOR(_id, rw, _pname, vdata, vreg, shift, nbits,\t\\\n\t\t\t   ereg0, ebit0, ereg1, ebit1, 0, 0)\t\t\\\n}\n\n#define TPS6586X_LDO_LINEAR(_id, _pname, n_volt, min_uv, uv_step, vreg,\t\\\n\t\t\t    shift, nbits, ereg0, ebit0, ereg1, ebit1)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tTPS6586X_REGULATOR_LINEAR(_id, rw_linear, _pname, n_volt,\t\\\n\t\t\t\t  min_uv, uv_step, vreg, shift, nbits,\t\\\n\t\t\t\t  ereg0, ebit0, ereg1, ebit1, 0, 0)\t\\\n}\n\n#define TPS6586X_FIXED_LDO(_id, _pname, vdata, vreg, shift, nbits,\t\\\n\t\t\t  ereg0, ebit0, ereg1, ebit1)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tTPS6586X_REGULATOR(_id, ro, _pname, vdata, vreg, shift, nbits,\t\\\n\t\t\t   ereg0, ebit0, ereg1, ebit1, 0, 0)\t\t\\\n}\n\n#define TPS6586X_DVM(_id, _pname, n_volt, min_uv, uv_step, vreg, shift,\t\\\n\t\t     nbits, ereg0, ebit0, ereg1, ebit1, goreg, gobit)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tTPS6586X_REGULATOR_LINEAR(_id, rw_linear, _pname, n_volt,\t\\\n\t\t\t\t  min_uv, uv_step, vreg, shift, nbits,\t\\\n\t\t\t\t  ereg0, ebit0, ereg1, ebit1, goreg,\t\\\n\t\t\t\t  gobit)\t\t\t\t\\\n}\n\n#define TPS6586X_SYS_REGULATOR()\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.desc\t= {\t\t\t\t\t\t\t\\\n\t\t.supply_name = \"sys\",\t\t\t\t\t\\\n\t\t.name\t= \"REG-SYS\",\t\t\t\t\t\\\n\t\t.ops\t= &tps6586x_sys_regulator_ops,\t\t\t\\\n\t\t.type\t= REGULATOR_VOLTAGE,\t\t\t\t\\\n\t\t.id\t= TPS6586X_ID_SYS,\t\t\t\t\\\n\t\t.owner\t= THIS_MODULE,\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nstatic struct tps6586x_regulator tps6586x_regulator[] = {\n\tTPS6586X_SYS_REGULATOR(),\n\tTPS6586X_LDO(LDO_0, \"vinldo01\", tps6586x_ldo0, SUPPLYV1, 5, 3, ENC, 0,\n\t\t\t\t\tEND, 0),\n\tTPS6586X_LDO(LDO_3, \"vinldo23\", tps6586x_ldo, SUPPLYV4, 0, 3, ENC, 2,\n\t\t\t\t\tEND, 2),\n\tTPS6586X_LDO(LDO_5, \"REG-SYS\", tps6586x_ldo, SUPPLYV6, 0, 3, ENE, 6,\n\t\t\t\t\tENE, 6),\n\tTPS6586X_LDO(LDO_6, \"vinldo678\", tps6586x_ldo, SUPPLYV3, 0, 3, ENC, 4,\n\t\t\t\t\tEND, 4),\n\tTPS6586X_LDO(LDO_7, \"vinldo678\", tps6586x_ldo, SUPPLYV3, 3, 3, ENC, 5,\n\t\t\t\t\tEND, 5),\n\tTPS6586X_LDO(LDO_8, \"vinldo678\", tps6586x_ldo, SUPPLYV2, 5, 3, ENC, 6,\n\t\t\t\t\tEND, 6),\n\tTPS6586X_LDO(LDO_9, \"vinldo9\", tps6586x_ldo, SUPPLYV6, 3, 3, ENE, 7,\n\t\t\t\t\tENE, 7),\n\tTPS6586X_LDO(LDO_RTC, \"REG-SYS\", tps6586x_ldo, SUPPLYV4, 3, 3, V4, 7,\n\t\t\t\t\tV4, 7),\n\tTPS6586X_LDO_LINEAR(LDO_1, \"vinldo01\", 32, 725000, 25000, SUPPLYV1,\n\t\t\t    0, 5, ENC, 1, END, 1),\n\tTPS6586X_LDO_LINEAR(SM_2, \"vin-sm2\", 32, 3000000, 50000, SUPPLYV2,\n\t\t\t    0, 5, ENC, 7, END, 7),\n\tTPS6586X_DVM(LDO_2, \"vinldo23\", 32, 725000, 25000, LDO2BV1, 0, 5,\n\t\t     ENA, 3, ENB, 3, TPS6586X_VCC2, BIT(6)),\n\tTPS6586X_DVM(LDO_4, \"vinldo4\", 32, 1700000, 25000, LDO4V1, 0, 5,\n\t\t     ENC, 3, END, 3, TPS6586X_VCC1, BIT(6)),\n\tTPS6586X_DVM(SM_0, \"vin-sm0\", 32, 725000, 25000, SM0V1, 0, 5,\n\t\t     ENA, 1, ENB, 1, TPS6586X_VCC1, BIT(2)),\n\tTPS6586X_DVM(SM_1, \"vin-sm1\", 32, 725000, 25000, SM1V1, 0, 5,\n\t\t     ENA, 0, ENB, 0, TPS6586X_VCC1, BIT(0)),\n};\n\nstatic struct tps6586x_regulator tps658623_regulator[] = {\n\tTPS6586X_LDO_LINEAR(SM_2, \"vin-sm2\", 32, 1700000, 25000, SUPPLYV2,\n\t\t\t    0, 5, ENC, 7, END, 7),\n};\n\nstatic struct tps6586x_regulator tps658640_regulator[] = {\n\tTPS6586X_LDO(LDO_3, \"vinldo23\", tps6586x_ldo0, SUPPLYV4, 0, 3,\n\t\t\t\t\tENC, 2, END, 2),\n\tTPS6586X_LDO(LDO_5, \"REG-SYS\", tps6586x_ldo0, SUPPLYV6, 0, 3,\n\t\t\t\t\tENE, 6, ENE, 6),\n\tTPS6586X_LDO(LDO_6, \"vinldo678\", tps6586x_ldo0, SUPPLYV3, 0, 3,\n\t\t\t\t\tENC, 4, END, 4),\n\tTPS6586X_LDO(LDO_7, \"vinldo678\", tps6586x_ldo0, SUPPLYV3, 3, 3,\n\t\t\t\t\tENC, 5, END, 5),\n\tTPS6586X_LDO(LDO_8, \"vinldo678\", tps6586x_ldo0, SUPPLYV2, 5, 3,\n\t\t\t\t\tENC, 6, END, 6),\n\tTPS6586X_LDO(LDO_9, \"vinldo9\", tps6586x_ldo0, SUPPLYV6, 3, 3,\n\t\t\t\t\tENE, 7, ENE, 7),\n\tTPS6586X_LDO_LINEAR(SM_2, \"vin-sm2\", 32, 2150000, 50000, SUPPLYV2,\n\t\t\t    0, 5, ENC, 7, END, 7),\n\n\tTPS6586X_FIXED_LDO(LDO_RTC, \"REG-SYS\", tps658640_rtc, SUPPLYV4, 3, 2,\n\t\t\t\t\tV4, 7, V4, 7),\n};\n\nstatic struct tps6586x_regulator tps658643_regulator[] = {\n\tTPS6586X_LDO_LINEAR(SM_2, \"vin-sm2\", 32, 1025000, 25000, SUPPLYV2,\n\t\t\t    0, 5, ENC, 7, END, 7),\n};\n\n \nstatic inline int tps6586x_regulator_preinit(struct device *parent,\n\t\t\t\t\t     struct tps6586x_regulator *ri)\n{\n\tuint8_t val1, val2;\n\tint ret;\n\n\tif (ri->enable_reg[0] == ri->enable_reg[1] &&\n\t    ri->enable_bit[0] == ri->enable_bit[1])\n\t\t\treturn 0;\n\n\tret = tps6586x_read(parent, ri->enable_reg[0], &val1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tps6586x_read(parent, ri->enable_reg[1], &val2);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(val2 & (1 << ri->enable_bit[1])))\n\t\treturn 0;\n\n\t \n\tif (!(val1 & (1 << ri->enable_bit[0]))) {\n\t\tret = tps6586x_set_bits(parent, ri->enable_reg[0],\n\t\t\t\t\t1 << ri->enable_bit[0]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn tps6586x_clr_bits(parent, ri->enable_reg[1],\n\t\t\t\t 1 << ri->enable_bit[1]);\n}\n\nstatic int tps6586x_regulator_set_slew_rate(struct platform_device *pdev,\n\t\t\tint id, struct regulator_init_data *p)\n{\n\tstruct device *parent = pdev->dev.parent;\n\tstruct tps6586x_settings *setting = p->driver_data;\n\tuint8_t reg;\n\n\tif (setting == NULL)\n\t\treturn 0;\n\n\tif (!(setting->slew_rate & TPS6586X_SLEW_RATE_SET))\n\t\treturn 0;\n\n\t \n\tswitch (id) {\n\tcase TPS6586X_ID_SM_0:\n\t\treg = TPS6586X_SM0SL;\n\t\tbreak;\n\tcase TPS6586X_ID_SM_1:\n\t\treg = TPS6586X_SM1SL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Only SM0/SM1 can set slew rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn tps6586x_write(parent, reg,\n\t\t\tsetting->slew_rate & TPS6586X_SLEW_RATE_MASK);\n}\n\nstatic struct tps6586x_regulator *find_regulator_info(int id, int version)\n{\n\tstruct tps6586x_regulator *ri;\n\tstruct tps6586x_regulator *table = NULL;\n\tint num;\n\tint i;\n\n\tswitch (version) {\n\tcase TPS658623:\n\tcase TPS658624:\n\t\ttable = tps658623_regulator;\n\t\tnum = ARRAY_SIZE(tps658623_regulator);\n\t\tbreak;\n\tcase TPS658640:\n\tcase TPS658640v2:\n\t\ttable = tps658640_regulator;\n\t\tnum = ARRAY_SIZE(tps658640_regulator);\n\t\tbreak;\n\tcase TPS658643:\n\t\ttable = tps658643_regulator;\n\t\tnum = ARRAY_SIZE(tps658643_regulator);\n\t\tbreak;\n\t}\n\n\t \n\tif (table) {\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tri = &table[i];\n\t\t\tif (ri->desc.id == id)\n\t\t\t\treturn ri;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tps6586x_regulator); i++) {\n\t\tri = &tps6586x_regulator[i];\n\t\tif (ri->desc.id == id)\n\t\t\treturn ri;\n\t}\n\treturn NULL;\n}\n\n#ifdef CONFIG_OF\nstatic struct of_regulator_match tps6586x_matches[] = {\n\t{ .name = \"sys\",     .driver_data = (void *)TPS6586X_ID_SYS     },\n\t{ .name = \"sm0\",     .driver_data = (void *)TPS6586X_ID_SM_0    },\n\t{ .name = \"sm1\",     .driver_data = (void *)TPS6586X_ID_SM_1    },\n\t{ .name = \"sm2\",     .driver_data = (void *)TPS6586X_ID_SM_2    },\n\t{ .name = \"ldo0\",    .driver_data = (void *)TPS6586X_ID_LDO_0   },\n\t{ .name = \"ldo1\",    .driver_data = (void *)TPS6586X_ID_LDO_1   },\n\t{ .name = \"ldo2\",    .driver_data = (void *)TPS6586X_ID_LDO_2   },\n\t{ .name = \"ldo3\",    .driver_data = (void *)TPS6586X_ID_LDO_3   },\n\t{ .name = \"ldo4\",    .driver_data = (void *)TPS6586X_ID_LDO_4   },\n\t{ .name = \"ldo5\",    .driver_data = (void *)TPS6586X_ID_LDO_5   },\n\t{ .name = \"ldo6\",    .driver_data = (void *)TPS6586X_ID_LDO_6   },\n\t{ .name = \"ldo7\",    .driver_data = (void *)TPS6586X_ID_LDO_7   },\n\t{ .name = \"ldo8\",    .driver_data = (void *)TPS6586X_ID_LDO_8   },\n\t{ .name = \"ldo9\",    .driver_data = (void *)TPS6586X_ID_LDO_9   },\n\t{ .name = \"ldo_rtc\", .driver_data = (void *)TPS6586X_ID_LDO_RTC },\n};\n\nstatic struct tps6586x_platform_data *tps6586x_parse_regulator_dt(\n\t\tstruct platform_device *pdev,\n\t\tstruct of_regulator_match **tps6586x_reg_matches)\n{\n\tconst unsigned int num = ARRAY_SIZE(tps6586x_matches);\n\tstruct device_node *np = pdev->dev.parent->of_node;\n\tstruct device_node *regs;\n\tconst char *sys_rail = NULL;\n\tunsigned int i;\n\tstruct tps6586x_platform_data *pdata;\n\tint err;\n\n\tregs = of_get_child_by_name(np, \"regulators\");\n\tif (!regs) {\n\t\tdev_err(&pdev->dev, \"regulator node not found\\n\");\n\t\treturn NULL;\n\t}\n\n\terr = of_regulator_match(&pdev->dev, regs, tps6586x_matches, num);\n\tof_node_put(regs);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"Regulator match failed, e %d\\n\", err);\n\t\treturn NULL;\n\t}\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num; i++) {\n\t\tuintptr_t id;\n\t\tif (!tps6586x_matches[i].init_data)\n\t\t\tcontinue;\n\n\t\tpdata->reg_init_data[i] = tps6586x_matches[i].init_data;\n\t\tid = (uintptr_t)tps6586x_matches[i].driver_data;\n\t\tif (id == TPS6586X_ID_SYS)\n\t\t\tsys_rail = pdata->reg_init_data[i]->constraints.name;\n\n\t\tif ((id == TPS6586X_ID_LDO_5) || (id == TPS6586X_ID_LDO_RTC))\n\t\t\tpdata->reg_init_data[i]->supply_regulator = sys_rail;\n\t}\n\t*tps6586x_reg_matches = tps6586x_matches;\n\treturn pdata;\n}\n#else\nstatic struct tps6586x_platform_data *tps6586x_parse_regulator_dt(\n\t\tstruct platform_device *pdev,\n\t\tstruct of_regulator_match **tps6586x_reg_matches)\n{\n\t*tps6586x_reg_matches = NULL;\n\treturn NULL;\n}\n#endif\n\nstatic int tps6586x_regulator_probe(struct platform_device *pdev)\n{\n\tstruct tps6586x_regulator *ri = NULL;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tstruct regulator_init_data *reg_data;\n\tstruct tps6586x_platform_data *pdata;\n\tstruct of_regulator_match *tps6586x_reg_matches = NULL;\n\tint version;\n\tint id;\n\tint err;\n\n\tdev_dbg(&pdev->dev, \"Probing regulator\\n\");\n\n\tpdata = dev_get_platdata(pdev->dev.parent);\n\tif ((!pdata) && (pdev->dev.parent->of_node))\n\t\tpdata = tps6586x_parse_regulator_dt(pdev,\n\t\t\t\t\t&tps6586x_reg_matches);\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"Platform data not available, exiting\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tversion = tps6586x_get_version(pdev->dev.parent);\n\n\tfor (id = 0; id < TPS6586X_ID_MAX_REGULATOR; ++id) {\n\t\treg_data = pdata->reg_init_data[id];\n\n\t\tri = find_regulator_info(id, version);\n\n\t\tif (!ri) {\n\t\t\tdev_err(&pdev->dev, \"invalid regulator ID specified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = tps6586x_regulator_preinit(pdev->dev.parent, ri);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"regulator %d preinit failed, e %d\\n\", id, err);\n\t\t\treturn err;\n\t\t}\n\n\t\tconfig.dev = pdev->dev.parent;\n\t\tconfig.init_data = reg_data;\n\t\tconfig.driver_data = ri;\n\n\t\tif (tps6586x_reg_matches)\n\t\t\tconfig.of_node = tps6586x_reg_matches[id].of_node;\n\n\t\trdev = devm_regulator_register(&pdev->dev, &ri->desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&pdev->dev, \"failed to register regulator %s\\n\",\n\t\t\t\t\tri->desc.name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\n\t\tif (reg_data) {\n\t\t\terr = tps6586x_regulator_set_slew_rate(pdev, id,\n\t\t\t\t\treg_data);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Slew rate config failed, e %d\\n\", err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, rdev);\n\treturn 0;\n}\n\nstatic struct platform_driver tps6586x_regulator_driver = {\n\t.driver\t= {\n\t\t.name\t= \"tps6586x-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t\t= tps6586x_regulator_probe,\n};\n\nstatic int __init tps6586x_regulator_init(void)\n{\n\treturn platform_driver_register(&tps6586x_regulator_driver);\n}\nsubsys_initcall(tps6586x_regulator_init);\n\nstatic void __exit tps6586x_regulator_exit(void)\n{\n\tplatform_driver_unregister(&tps6586x_regulator_driver);\n}\nmodule_exit(tps6586x_regulator_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Mike Rapoport <mike@compulab.co.il>\");\nMODULE_DESCRIPTION(\"Regulator Driver for TI TPS6586X PMIC\");\nMODULE_ALIAS(\"platform:tps6586x-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}