{
  "module_name": "max77693-regulator.c",
  "hash_id": "befcbe20cf49ae21835b24f362887265cbcc16cb04d6066ebad2e33f6c4d62da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/max77693-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/mfd/max77693.h>\n#include <linux/mfd/max77693-common.h>\n#include <linux/mfd/max77693-private.h>\n#include <linux/mfd/max77843-private.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regmap.h>\n\n \nenum max77843_regulator_type {\n\tMAX77843_SAFEOUT1 = 0,\n\tMAX77843_SAFEOUT2,\n\tMAX77843_CHARGER,\n\n\tMAX77843_NUM,\n};\n\n \nstruct chg_reg_data {\n\tunsigned int linear_reg;\n\tunsigned int linear_mask;\n\tunsigned int uA_step;\n\tunsigned int min_sel;\n};\n\n \nstatic int max77693_chg_get_current_limit(struct regulator_dev *rdev)\n{\n\tconst struct chg_reg_data *reg_data = rdev_get_drvdata(rdev);\n\tunsigned int chg_min_uA = rdev->constraints->min_uA;\n\tunsigned int chg_max_uA = rdev->constraints->max_uA;\n\tunsigned int reg, sel;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(rdev->regmap, reg_data->linear_reg, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsel = reg & reg_data->linear_mask;\n\n\t \n\tif (sel <= reg_data->min_sel)\n\t\tsel = 0;\n\telse\n\t\tsel -= reg_data->min_sel;\n\n\tval = chg_min_uA + reg_data->uA_step * sel;\n\tif (val > chg_max_uA)\n\t\treturn -EINVAL;\n\n\treturn val;\n}\n\nstatic int max77693_chg_set_current_limit(struct regulator_dev *rdev,\n\t\t\t\t\t\tint min_uA, int max_uA)\n{\n\tconst struct chg_reg_data *reg_data = rdev_get_drvdata(rdev);\n\tunsigned int chg_min_uA = rdev->constraints->min_uA;\n\tint sel = 0;\n\n\twhile (chg_min_uA + reg_data->uA_step * sel < min_uA)\n\t\tsel++;\n\n\tif (chg_min_uA + reg_data->uA_step * sel > max_uA)\n\t\treturn -EINVAL;\n\n\t \n\tsel += reg_data->min_sel;\n\n\treturn regmap_write(rdev->regmap, reg_data->linear_reg, sel);\n}\n \n\n \nstatic struct regmap *max77693_get_regmap(enum max77693_types type,\n\t\t\t\t\t  struct max77693_dev *max77693,\n\t\t\t\t\t  int reg_id)\n{\n\tif (type == TYPE_MAX77693)\n\t\treturn max77693->regmap;\n\n\t \n\tswitch (reg_id) {\n\tcase MAX77843_SAFEOUT1:\n\tcase MAX77843_SAFEOUT2:\n\t\treturn max77693->regmap;\n\tcase MAX77843_CHARGER:\n\t\treturn max77693->regmap_chg;\n\tdefault:\n\t\treturn max77693->regmap;\n\t}\n}\n\nstatic const unsigned int max77693_safeout_table[] = {\n\t4850000,\n\t4900000,\n\t4950000,\n\t3300000,\n};\n\nstatic const struct regulator_ops max77693_safeout_ops = {\n\t.list_voltage\t\t= regulator_list_voltage_table,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n};\n\nstatic const struct regulator_ops max77693_charger_ops = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_current_limit\t= max77693_chg_get_current_limit,\n\t.set_current_limit\t= max77693_chg_set_current_limit,\n};\n\n#define max77693_regulator_desc_esafeout(_num)\t{\t\t\\\n\t.name\t\t= \"ESAFEOUT\"#_num,\t\t\t\\\n\t.id\t\t= MAX77693_ESAFEOUT##_num,\t\t\\\n\t.of_match\t= of_match_ptr(\"ESAFEOUT\"#_num),\t\\\n\t.regulators_node\t= of_match_ptr(\"regulators\"),\t\\\n\t.n_voltages\t= 4,\t\t\t\t\t\\\n\t.ops\t\t= &max77693_safeout_ops,\t\t\\\n\t.type\t\t= REGULATOR_VOLTAGE,\t\t\t\\\n\t.owner\t\t= THIS_MODULE,\t\t\t\t\\\n\t.volt_table\t= max77693_safeout_table,\t\t\\\n\t.vsel_reg\t= MAX77693_CHG_REG_SAFEOUT_CTRL,\t\\\n\t.vsel_mask\t= SAFEOUT_CTRL_SAFEOUT##_num##_MASK,\t\\\n\t.enable_reg\t= MAX77693_CHG_REG_SAFEOUT_CTRL,\t\\\n\t.enable_mask\t= SAFEOUT_CTRL_ENSAFEOUT##_num##_MASK ,\t\\\n}\n\nstatic const struct regulator_desc max77693_supported_regulators[] = {\n\tmax77693_regulator_desc_esafeout(1),\n\tmax77693_regulator_desc_esafeout(2),\n\t{\n\t\t.name = \"CHARGER\",\n\t\t.id = MAX77693_CHARGER,\n\t\t.of_match = of_match_ptr(\"CHARGER\"),\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t.ops = &max77693_charger_ops,\n\t\t.type = REGULATOR_CURRENT,\n\t\t.owner = THIS_MODULE,\n\t\t.enable_reg = MAX77693_CHG_REG_CHG_CNFG_00,\n\t\t.enable_mask = CHG_CNFG_00_CHG_MASK |\n\t\t\t\tCHG_CNFG_00_BUCK_MASK,\n\t\t.enable_val = CHG_CNFG_00_CHG_MASK | CHG_CNFG_00_BUCK_MASK,\n\t},\n};\n\nstatic const struct chg_reg_data max77693_chg_reg_data = {\n\t.linear_reg\t= MAX77693_CHG_REG_CHG_CNFG_09,\n\t.linear_mask\t= CHG_CNFG_09_CHGIN_ILIM_MASK,\n\t.uA_step\t= 20000,\n\t.min_sel\t= 3,\n};\n\n#define\tmax77843_regulator_desc_esafeout(num)\t{\t\t\t\\\n\t.name\t\t= \"SAFEOUT\" # num,\t\t\t\t\\\n\t.id\t\t= MAX77843_SAFEOUT ## num,\t\t\t\\\n\t.ops\t\t= &max77693_safeout_ops,\t\t\t\\\n\t.of_match\t= of_match_ptr(\"SAFEOUT\" # num),\t\t\\\n\t.regulators_node = of_match_ptr(\"regulators\"),\t\t\t\\\n\t.type\t\t= REGULATOR_VOLTAGE,\t\t\t\t\\\n\t.owner\t\t= THIS_MODULE,\t\t\t\t\t\\\n\t.n_voltages\t= ARRAY_SIZE(max77693_safeout_table),\t\t\\\n\t.volt_table\t= max77693_safeout_table,\t\t\t\\\n\t.enable_reg\t= MAX77843_SYS_REG_SAFEOUTCTRL,\t\t\t\\\n\t.enable_mask\t= MAX77843_REG_SAFEOUTCTRL_ENSAFEOUT ## num,\t\\\n\t.vsel_reg\t= MAX77843_SYS_REG_SAFEOUTCTRL,\t\t\t\\\n\t.vsel_mask\t= MAX77843_REG_SAFEOUTCTRL_SAFEOUT ## num ## _MASK, \\\n}\n\nstatic const struct regulator_desc max77843_supported_regulators[] = {\n\t[MAX77843_SAFEOUT1] = max77843_regulator_desc_esafeout(1),\n\t[MAX77843_SAFEOUT2] = max77843_regulator_desc_esafeout(2),\n\t[MAX77843_CHARGER] = {\n\t\t.name\t\t= \"CHARGER\",\n\t\t.id\t\t= MAX77843_CHARGER,\n\t\t.ops\t\t= &max77693_charger_ops,\n\t\t.of_match\t= of_match_ptr(\"CHARGER\"),\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t.type\t\t= REGULATOR_CURRENT,\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.enable_reg\t= MAX77843_CHG_REG_CHG_CNFG_00,\n\t\t.enable_mask\t= MAX77843_CHG_MASK,\n\t\t.enable_val\t= MAX77843_CHG_MASK,\n\t},\n};\n\nstatic const struct chg_reg_data max77843_chg_reg_data = {\n\t.linear_reg\t= MAX77843_CHG_REG_CHG_CNFG_02,\n\t.linear_mask\t= MAX77843_CHG_FAST_CHG_CURRENT_MASK,\n\t.uA_step\t= MAX77843_CHG_FAST_CHG_CURRENT_STEP,\n\t.min_sel\t= 2,\n};\n\nstatic int max77693_pmic_probe(struct platform_device *pdev)\n{\n\tenum max77693_types type = platform_get_device_id(pdev)->driver_data;\n\tstruct max77693_dev *iodev = dev_get_drvdata(pdev->dev.parent);\n\tconst struct regulator_desc *regulators;\n\tunsigned int regulators_size;\n\tint i;\n\tstruct regulator_config config = { };\n\n\tconfig.dev = iodev->dev;\n\n\tswitch (type) {\n\tcase TYPE_MAX77693:\n\t\tregulators = max77693_supported_regulators;\n\t\tregulators_size = ARRAY_SIZE(max77693_supported_regulators);\n\t\tconfig.driver_data = (void *)&max77693_chg_reg_data;\n\t\tbreak;\n\tcase TYPE_MAX77843:\n\t\tregulators = max77843_supported_regulators;\n\t\tregulators_size = ARRAY_SIZE(max77843_supported_regulators);\n\t\tconfig.driver_data = (void *)&max77843_chg_reg_data;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unsupported device type: %u\\n\", type);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < regulators_size; i++) {\n\t\tstruct regulator_dev *rdev;\n\n\t\tconfig.regmap = max77693_get_regmap(type, iodev,\n\t\t\t\t\t\t    regulators[i].id);\n\n\t\trdev = devm_regulator_register(&pdev->dev,\n\t\t\t\t\t\t&regulators[i], &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to initialize regulator-%d\\n\", i);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id max77693_pmic_id[] = {\n\t{ \"max77693-pmic\", TYPE_MAX77693 },\n\t{ \"max77843-regulator\", TYPE_MAX77843 },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(platform, max77693_pmic_id);\n\nstatic struct platform_driver max77693_pmic_driver = {\n\t.driver = {\n\t\t   .name = \"max77693-pmic\",\n\t\t   .probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t   },\n\t.probe = max77693_pmic_probe,\n\t.id_table = max77693_pmic_id,\n};\n\nstatic int __init max77693_pmic_init(void)\n{\n\treturn platform_driver_register(&max77693_pmic_driver);\n}\nsubsys_initcall(max77693_pmic_init);\n\nstatic void __exit max77693_pmic_cleanup(void)\n{\n\tplatform_driver_unregister(&max77693_pmic_driver);\n}\nmodule_exit(max77693_pmic_cleanup);\n\nMODULE_DESCRIPTION(\"MAXIM 77693/77843 regulator driver\");\nMODULE_AUTHOR(\"Jonghwa Lee <jonghwa3.lee@samsung.com>\");\nMODULE_AUTHOR(\"Krzysztof Kozlowski <krzk@kernel.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}