{
  "module_name": "slg51000-regulator.c",
  "hash_id": "f79118813512f19deb2b1f00565d2d5846085f6cd9d258d51858fa1667abca87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/slg51000-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include \"slg51000-regulator.h\"\n\n#define SLG51000_SCTL_EVT               7\n#define SLG51000_MAX_EVT_REGISTER       8\n#define SLG51000_LDOHP_LV_MIN           1200000\n#define SLG51000_LDOHP_HV_MIN           2400000\n\nenum slg51000_regulators {\n\tSLG51000_REGULATOR_LDO1 = 0,\n\tSLG51000_REGULATOR_LDO2,\n\tSLG51000_REGULATOR_LDO3,\n\tSLG51000_REGULATOR_LDO4,\n\tSLG51000_REGULATOR_LDO5,\n\tSLG51000_REGULATOR_LDO6,\n\tSLG51000_REGULATOR_LDO7,\n\tSLG51000_MAX_REGULATORS,\n};\n\nstruct slg51000 {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regulator_desc *rdesc[SLG51000_MAX_REGULATORS];\n\tstruct regulator_dev *rdev[SLG51000_MAX_REGULATORS];\n\tstruct gpio_desc *cs_gpiod;\n\tint chip_irq;\n};\n\nstruct slg51000_evt_sta {\n\tunsigned int ereg;\n\tunsigned int sreg;\n};\n\nstatic const struct slg51000_evt_sta es_reg[SLG51000_MAX_EVT_REGISTER] = {\n\t{SLG51000_LDO1_EVENT, SLG51000_LDO1_STATUS},\n\t{SLG51000_LDO2_EVENT, SLG51000_LDO2_STATUS},\n\t{SLG51000_LDO3_EVENT, SLG51000_LDO3_STATUS},\n\t{SLG51000_LDO4_EVENT, SLG51000_LDO4_STATUS},\n\t{SLG51000_LDO5_EVENT, SLG51000_LDO5_STATUS},\n\t{SLG51000_LDO6_EVENT, SLG51000_LDO6_STATUS},\n\t{SLG51000_LDO7_EVENT, SLG51000_LDO7_STATUS},\n\t{SLG51000_SYSCTL_EVENT, SLG51000_SYSCTL_STATUS},\n};\n\nstatic const struct regmap_range slg51000_writeable_ranges[] = {\n\tregmap_reg_range(SLG51000_SYSCTL_MATRIX_CONF_A,\n\t\t\t SLG51000_SYSCTL_MATRIX_CONF_A),\n\tregmap_reg_range(SLG51000_LDO1_VSEL, SLG51000_LDO1_VSEL),\n\tregmap_reg_range(SLG51000_LDO1_MINV, SLG51000_LDO1_MAXV),\n\tregmap_reg_range(SLG51000_LDO1_IRQ_MASK, SLG51000_LDO1_IRQ_MASK),\n\tregmap_reg_range(SLG51000_LDO2_VSEL, SLG51000_LDO2_VSEL),\n\tregmap_reg_range(SLG51000_LDO2_MINV, SLG51000_LDO2_MAXV),\n\tregmap_reg_range(SLG51000_LDO2_IRQ_MASK, SLG51000_LDO2_IRQ_MASK),\n\tregmap_reg_range(SLG51000_LDO3_VSEL, SLG51000_LDO3_VSEL),\n\tregmap_reg_range(SLG51000_LDO3_MINV, SLG51000_LDO3_MAXV),\n\tregmap_reg_range(SLG51000_LDO3_IRQ_MASK, SLG51000_LDO3_IRQ_MASK),\n\tregmap_reg_range(SLG51000_LDO4_VSEL, SLG51000_LDO4_VSEL),\n\tregmap_reg_range(SLG51000_LDO4_MINV, SLG51000_LDO4_MAXV),\n\tregmap_reg_range(SLG51000_LDO4_IRQ_MASK, SLG51000_LDO4_IRQ_MASK),\n\tregmap_reg_range(SLG51000_LDO5_VSEL, SLG51000_LDO5_VSEL),\n\tregmap_reg_range(SLG51000_LDO5_MINV, SLG51000_LDO5_MAXV),\n\tregmap_reg_range(SLG51000_LDO5_IRQ_MASK, SLG51000_LDO5_IRQ_MASK),\n\tregmap_reg_range(SLG51000_LDO6_VSEL, SLG51000_LDO6_VSEL),\n\tregmap_reg_range(SLG51000_LDO6_MINV, SLG51000_LDO6_MAXV),\n\tregmap_reg_range(SLG51000_LDO6_IRQ_MASK, SLG51000_LDO6_IRQ_MASK),\n\tregmap_reg_range(SLG51000_LDO7_VSEL, SLG51000_LDO7_VSEL),\n\tregmap_reg_range(SLG51000_LDO7_MINV, SLG51000_LDO7_MAXV),\n\tregmap_reg_range(SLG51000_LDO7_IRQ_MASK, SLG51000_LDO7_IRQ_MASK),\n\tregmap_reg_range(SLG51000_OTP_IRQ_MASK, SLG51000_OTP_IRQ_MASK),\n};\n\nstatic const struct regmap_range slg51000_readable_ranges[] = {\n\tregmap_reg_range(SLG51000_SYSCTL_PATN_ID_B0,\n\t\t\t SLG51000_SYSCTL_PATN_ID_B2),\n\tregmap_reg_range(SLG51000_SYSCTL_SYS_CONF_A,\n\t\t\t SLG51000_SYSCTL_SYS_CONF_A),\n\tregmap_reg_range(SLG51000_SYSCTL_SYS_CONF_D,\n\t\t\t SLG51000_SYSCTL_MATRIX_CONF_B),\n\tregmap_reg_range(SLG51000_SYSCTL_REFGEN_CONF_C,\n\t\t\t SLG51000_SYSCTL_UVLO_CONF_A),\n\tregmap_reg_range(SLG51000_SYSCTL_FAULT_LOG1, SLG51000_SYSCTL_IRQ_MASK),\n\tregmap_reg_range(SLG51000_IO_GPIO1_CONF, SLG51000_IO_GPIO_STATUS),\n\tregmap_reg_range(SLG51000_LUTARRAY_LUT_VAL_0,\n\t\t\t SLG51000_LUTARRAY_LUT_VAL_11),\n\tregmap_reg_range(SLG51000_MUXARRAY_INPUT_SEL_0,\n\t\t\t SLG51000_MUXARRAY_INPUT_SEL_63),\n\tregmap_reg_range(SLG51000_PWRSEQ_RESOURCE_EN_0,\n\t\t\t SLG51000_PWRSEQ_INPUT_SENSE_CONF_B),\n\tregmap_reg_range(SLG51000_LDO1_VSEL, SLG51000_LDO1_VSEL),\n\tregmap_reg_range(SLG51000_LDO1_MINV, SLG51000_LDO1_MAXV),\n\tregmap_reg_range(SLG51000_LDO1_MISC1, SLG51000_LDO1_VSEL_ACTUAL),\n\tregmap_reg_range(SLG51000_LDO1_EVENT, SLG51000_LDO1_IRQ_MASK),\n\tregmap_reg_range(SLG51000_LDO2_VSEL, SLG51000_LDO2_VSEL),\n\tregmap_reg_range(SLG51000_LDO2_MINV, SLG51000_LDO2_MAXV),\n\tregmap_reg_range(SLG51000_LDO2_MISC1, SLG51000_LDO2_VSEL_ACTUAL),\n\tregmap_reg_range(SLG51000_LDO2_EVENT, SLG51000_LDO2_IRQ_MASK),\n\tregmap_reg_range(SLG51000_LDO3_VSEL, SLG51000_LDO3_VSEL),\n\tregmap_reg_range(SLG51000_LDO3_MINV, SLG51000_LDO3_MAXV),\n\tregmap_reg_range(SLG51000_LDO3_CONF1, SLG51000_LDO3_VSEL_ACTUAL),\n\tregmap_reg_range(SLG51000_LDO3_EVENT, SLG51000_LDO3_IRQ_MASK),\n\tregmap_reg_range(SLG51000_LDO4_VSEL, SLG51000_LDO4_VSEL),\n\tregmap_reg_range(SLG51000_LDO4_MINV, SLG51000_LDO4_MAXV),\n\tregmap_reg_range(SLG51000_LDO4_CONF1, SLG51000_LDO4_VSEL_ACTUAL),\n\tregmap_reg_range(SLG51000_LDO4_EVENT, SLG51000_LDO4_IRQ_MASK),\n\tregmap_reg_range(SLG51000_LDO5_VSEL, SLG51000_LDO5_VSEL),\n\tregmap_reg_range(SLG51000_LDO5_MINV, SLG51000_LDO5_MAXV),\n\tregmap_reg_range(SLG51000_LDO5_TRIM2, SLG51000_LDO5_TRIM2),\n\tregmap_reg_range(SLG51000_LDO5_CONF1, SLG51000_LDO5_VSEL_ACTUAL),\n\tregmap_reg_range(SLG51000_LDO5_EVENT, SLG51000_LDO5_IRQ_MASK),\n\tregmap_reg_range(SLG51000_LDO6_VSEL, SLG51000_LDO6_VSEL),\n\tregmap_reg_range(SLG51000_LDO6_MINV, SLG51000_LDO6_MAXV),\n\tregmap_reg_range(SLG51000_LDO6_TRIM2, SLG51000_LDO6_TRIM2),\n\tregmap_reg_range(SLG51000_LDO6_CONF1, SLG51000_LDO6_VSEL_ACTUAL),\n\tregmap_reg_range(SLG51000_LDO6_EVENT, SLG51000_LDO6_IRQ_MASK),\n\tregmap_reg_range(SLG51000_LDO7_VSEL, SLG51000_LDO7_VSEL),\n\tregmap_reg_range(SLG51000_LDO7_MINV, SLG51000_LDO7_MAXV),\n\tregmap_reg_range(SLG51000_LDO7_CONF1, SLG51000_LDO7_VSEL_ACTUAL),\n\tregmap_reg_range(SLG51000_LDO7_EVENT, SLG51000_LDO7_IRQ_MASK),\n\tregmap_reg_range(SLG51000_OTP_EVENT, SLG51000_OTP_EVENT),\n\tregmap_reg_range(SLG51000_OTP_IRQ_MASK, SLG51000_OTP_IRQ_MASK),\n\tregmap_reg_range(SLG51000_OTP_LOCK_OTP_PROG, SLG51000_OTP_LOCK_CTRL),\n\tregmap_reg_range(SLG51000_LOCK_GLOBAL_LOCK_CTRL1,\n\t\t\t SLG51000_LOCK_GLOBAL_LOCK_CTRL1),\n};\n\nstatic const struct regmap_range slg51000_volatile_ranges[] = {\n\tregmap_reg_range(SLG51000_SYSCTL_FAULT_LOG1, SLG51000_SYSCTL_STATUS),\n\tregmap_reg_range(SLG51000_IO_GPIO_STATUS, SLG51000_IO_GPIO_STATUS),\n\tregmap_reg_range(SLG51000_LDO1_EVENT, SLG51000_LDO1_STATUS),\n\tregmap_reg_range(SLG51000_LDO2_EVENT, SLG51000_LDO2_STATUS),\n\tregmap_reg_range(SLG51000_LDO3_EVENT, SLG51000_LDO3_STATUS),\n\tregmap_reg_range(SLG51000_LDO4_EVENT, SLG51000_LDO4_STATUS),\n\tregmap_reg_range(SLG51000_LDO5_EVENT, SLG51000_LDO5_STATUS),\n\tregmap_reg_range(SLG51000_LDO6_EVENT, SLG51000_LDO6_STATUS),\n\tregmap_reg_range(SLG51000_LDO7_EVENT, SLG51000_LDO7_STATUS),\n\tregmap_reg_range(SLG51000_OTP_EVENT, SLG51000_OTP_EVENT),\n};\n\nstatic const struct regmap_access_table slg51000_writeable_table = {\n\t.yes_ranges\t= slg51000_writeable_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(slg51000_writeable_ranges),\n};\n\nstatic const struct regmap_access_table slg51000_readable_table = {\n\t.yes_ranges\t= slg51000_readable_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(slg51000_readable_ranges),\n};\n\nstatic const struct regmap_access_table slg51000_volatile_table = {\n\t.yes_ranges\t= slg51000_volatile_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(slg51000_volatile_ranges),\n};\n\nstatic const struct regmap_config slg51000_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = 0x8000,\n\t.wr_table = &slg51000_writeable_table,\n\t.rd_table = &slg51000_readable_table,\n\t.volatile_table = &slg51000_volatile_table,\n};\n\nstatic const struct regulator_ops slg51000_regl_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n};\n\nstatic const struct regulator_ops slg51000_switch_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n};\n\nstatic int slg51000_of_parse_cb(struct device_node *np,\n\t\t\t\tconst struct regulator_desc *desc,\n\t\t\t\tstruct regulator_config *config)\n{\n\tstruct gpio_desc *ena_gpiod;\n\n\tena_gpiod = fwnode_gpiod_get_index(of_fwnode_handle(np), \"enable\", 0,\n\t\t\t\t\t   GPIOD_OUT_LOW |\n\t\t\t\t\t\tGPIOD_FLAGS_BIT_NONEXCLUSIVE,\n\t\t\t\t\t   \"gpio-en-ldo\");\n\tif (!IS_ERR(ena_gpiod))\n\t\tconfig->ena_gpiod = ena_gpiod;\n\n\treturn 0;\n}\n\n#define SLG51000_REGL_DESC(_id, _name, _s_name, _min, _step) \\\n\t[SLG51000_REGULATOR_##_id] = {                             \\\n\t\t.name = #_name,                                    \\\n\t\t.supply_name = _s_name,\t\t\t\t   \\\n\t\t.id = SLG51000_REGULATOR_##_id,                    \\\n\t\t.of_match = of_match_ptr(#_name),                  \\\n\t\t.of_parse_cb = slg51000_of_parse_cb,               \\\n\t\t.ops = &slg51000_regl_ops,                         \\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),     \\\n\t\t.n_voltages = 256,                                 \\\n\t\t.min_uV = _min,                                    \\\n\t\t.uV_step = _step,                                  \\\n\t\t.linear_min_sel = 0,                               \\\n\t\t.vsel_mask = SLG51000_VSEL_MASK,                   \\\n\t\t.vsel_reg = SLG51000_##_id##_VSEL,                 \\\n\t\t.enable_reg = SLG51000_SYSCTL_MATRIX_CONF_A,       \\\n\t\t.enable_mask = BIT(SLG51000_REGULATOR_##_id),      \\\n\t\t.type = REGULATOR_VOLTAGE,                         \\\n\t\t.owner = THIS_MODULE,                              \\\n\t}\n\nstatic struct regulator_desc regls_desc[SLG51000_MAX_REGULATORS] = {\n\tSLG51000_REGL_DESC(LDO1, ldo1, NULL,   2400000,  5000),\n\tSLG51000_REGL_DESC(LDO2, ldo2, NULL,   2400000,  5000),\n\tSLG51000_REGL_DESC(LDO3, ldo3, \"vin3\", 1200000, 10000),\n\tSLG51000_REGL_DESC(LDO4, ldo4, \"vin4\", 1200000, 10000),\n\tSLG51000_REGL_DESC(LDO5, ldo5, \"vin5\",  400000,  5000),\n\tSLG51000_REGL_DESC(LDO6, ldo6, \"vin6\",  400000,  5000),\n\tSLG51000_REGL_DESC(LDO7, ldo7, \"vin7\", 1200000, 10000),\n};\n\nstatic int slg51000_regulator_init(struct slg51000 *chip)\n{\n\tstruct regulator_config config = { };\n\tstruct regulator_desc *rdesc;\n\tunsigned int reg, val;\n\tu8 vsel_range[2];\n\tint id, ret = 0;\n\tconst unsigned int min_regs[SLG51000_MAX_REGULATORS] = {\n\t\tSLG51000_LDO1_MINV, SLG51000_LDO2_MINV, SLG51000_LDO3_MINV,\n\t\tSLG51000_LDO4_MINV, SLG51000_LDO5_MINV, SLG51000_LDO6_MINV,\n\t\tSLG51000_LDO7_MINV,\n\t};\n\n\tfor (id = 0; id < SLG51000_MAX_REGULATORS; id++) {\n\t\tchip->rdesc[id] = &regls_desc[id];\n\t\trdesc = chip->rdesc[id];\n\t\tconfig.regmap = chip->regmap;\n\t\tconfig.dev = chip->dev;\n\t\tconfig.driver_data = chip;\n\n\t\tret = regmap_bulk_read(chip->regmap, min_regs[id],\n\t\t\t\t       vsel_range, 2);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"Failed to read the MIN register\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (id) {\n\t\tcase SLG51000_REGULATOR_LDO1:\n\t\tcase SLG51000_REGULATOR_LDO2:\n\t\t\tif (id == SLG51000_REGULATOR_LDO1)\n\t\t\t\treg = SLG51000_LDO1_MISC1;\n\t\t\telse\n\t\t\t\treg = SLG51000_LDO2_MISC1;\n\n\t\t\tret = regmap_read(chip->regmap, reg, &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(chip->dev,\n\t\t\t\t\t\"Failed to read voltage range of ldo%d\\n\",\n\t\t\t\t\tid + 1);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\trdesc->linear_min_sel = vsel_range[0];\n\t\t\trdesc->n_voltages = vsel_range[1] + 1;\n\t\t\tif (val & SLG51000_SEL_VRANGE_MASK)\n\t\t\t\trdesc->min_uV = SLG51000_LDOHP_HV_MIN\n\t\t\t\t\t\t+ (vsel_range[0]\n\t\t\t\t\t\t   * rdesc->uV_step);\n\t\t\telse\n\t\t\t\trdesc->min_uV = SLG51000_LDOHP_LV_MIN\n\t\t\t\t\t\t+ (vsel_range[0]\n\t\t\t\t\t\t   * rdesc->uV_step);\n\t\t\tbreak;\n\n\t\tcase SLG51000_REGULATOR_LDO5:\n\t\tcase SLG51000_REGULATOR_LDO6:\n\t\t\tif (id == SLG51000_REGULATOR_LDO5)\n\t\t\t\treg = SLG51000_LDO5_TRIM2;\n\t\t\telse\n\t\t\t\treg = SLG51000_LDO6_TRIM2;\n\n\t\t\tret = regmap_read(chip->regmap, reg, &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(chip->dev,\n\t\t\t\t\t\"Failed to read LDO mode register\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (val & SLG51000_SEL_BYP_MODE_MASK) {\n\t\t\t\trdesc->ops = &slg51000_switch_ops;\n\t\t\t\trdesc->n_voltages = 0;\n\t\t\t\trdesc->min_uV = 0;\n\t\t\t\trdesc->uV_step = 0;\n\t\t\t\trdesc->linear_min_sel = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t \n\n\t\tdefault:\n\t\t\trdesc->linear_min_sel = vsel_range[0];\n\t\t\trdesc->n_voltages = vsel_range[1] + 1;\n\t\t\trdesc->min_uV = rdesc->min_uV\n\t\t\t\t\t+ (vsel_range[0] * rdesc->uV_step);\n\t\t\tbreak;\n\t\t}\n\n\t\tchip->rdev[id] = devm_regulator_register(chip->dev, rdesc,\n\t\t\t\t\t\t\t &config);\n\t\tif (IS_ERR(chip->rdev[id])) {\n\t\t\tret = PTR_ERR(chip->rdev[id]);\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"Failed to register regulator(%s):%d\\n\",\n\t\t\t\tchip->rdesc[id]->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t slg51000_irq_handler(int irq, void *data)\n{\n\tstruct slg51000 *chip = data;\n\tstruct regmap *regmap = chip->regmap;\n\tenum { R0 = 0, R1, R2, REG_MAX };\n\tu8 evt[SLG51000_MAX_EVT_REGISTER][REG_MAX];\n\tint ret, i, handled = IRQ_NONE;\n\tunsigned int evt_otp, mask_otp;\n\n\t \n\tfor (i = 0; i < SLG51000_MAX_EVT_REGISTER; i++) {\n\t\tret = regmap_bulk_read(regmap, es_reg[i].ereg, evt[i], REG_MAX);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"Failed to read event registers(%d)\\n\", ret);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\t}\n\n\tret = regmap_read(regmap, SLG51000_OTP_EVENT, &evt_otp);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev,\n\t\t\t\"Failed to read otp event registers(%d)\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = regmap_read(regmap, SLG51000_OTP_IRQ_MASK, &mask_otp);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev,\n\t\t\t\"Failed to read otp mask register(%d)\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif ((evt_otp & SLG51000_EVT_CRC_MASK) &&\n\t    !(mask_otp & SLG51000_IRQ_CRC_MASK)) {\n\t\tdev_info(chip->dev,\n\t\t\t \"OTP has been read or OTP crc is not zero\\n\");\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\tfor (i = 0; i < SLG51000_MAX_REGULATORS; i++) {\n\t\tif (!(evt[i][R2] & SLG51000_IRQ_ILIM_FLAG_MASK) &&\n\t\t    (evt[i][R0] & SLG51000_EVT_ILIM_FLAG_MASK)) {\n\t\t\tregulator_notifier_call_chain(chip->rdev[i],\n\t\t\t\t\t    REGULATOR_EVENT_OVER_CURRENT, NULL);\n\n\t\t\tif (evt[i][R1] & SLG51000_STA_ILIM_FLAG_MASK)\n\t\t\t\tdev_warn(chip->dev,\n\t\t\t\t\t \"Over-current limit(ldo%d)\\n\", i + 1);\n\t\t\thandled = IRQ_HANDLED;\n\t\t}\n\t}\n\n\tif (!(evt[SLG51000_SCTL_EVT][R2] & SLG51000_IRQ_HIGH_TEMP_WARN_MASK) &&\n\t    (evt[SLG51000_SCTL_EVT][R0] & SLG51000_EVT_HIGH_TEMP_WARN_MASK)) {\n\t\tfor (i = 0; i < SLG51000_MAX_REGULATORS; i++) {\n\t\t\tif (!(evt[i][R1] & SLG51000_STA_ILIM_FLAG_MASK) &&\n\t\t\t    (evt[i][R1] & SLG51000_STA_VOUT_OK_FLAG_MASK)) {\n\t\t\t\tregulator_notifier_call_chain(chip->rdev[i],\n\t\t\t\t\t       REGULATOR_EVENT_OVER_TEMP, NULL);\n\t\t\t}\n\t\t}\n\t\thandled = IRQ_HANDLED;\n\t\tif (evt[SLG51000_SCTL_EVT][R1] &\n\t\t    SLG51000_STA_HIGH_TEMP_WARN_MASK)\n\t\t\tdev_warn(chip->dev, \"High temperature warning!\\n\");\n\t}\n\n\treturn handled;\n}\n\nstatic void slg51000_clear_fault_log(struct slg51000 *chip)\n{\n\tunsigned int val = 0;\n\tint ret = 0;\n\n\tret = regmap_read(chip->regmap, SLG51000_SYSCTL_FAULT_LOG1, &val);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to read Fault log register\\n\");\n\t\treturn;\n\t}\n\n\tif (val & SLG51000_FLT_OVER_TEMP_MASK)\n\t\tdev_dbg(chip->dev, \"Fault log: FLT_OVER_TEMP\\n\");\n\tif (val & SLG51000_FLT_POWER_SEQ_CRASH_REQ_MASK)\n\t\tdev_dbg(chip->dev, \"Fault log: FLT_POWER_SEQ_CRASH_REQ\\n\");\n\tif (val & SLG51000_FLT_RST_MASK)\n\t\tdev_dbg(chip->dev, \"Fault log: FLT_RST\\n\");\n\tif (val & SLG51000_FLT_POR_MASK)\n\t\tdev_dbg(chip->dev, \"Fault log: FLT_POR\\n\");\n}\n\nstatic int slg51000_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct slg51000 *chip;\n\tstruct gpio_desc *cs_gpiod;\n\tint error, ret;\n\n\tchip = devm_kzalloc(dev, sizeof(struct slg51000), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tcs_gpiod = devm_gpiod_get_optional(dev, \"dlg,cs\",\n\t\t\t\t\t   GPIOD_OUT_HIGH |\n\t\t\t\t\t\tGPIOD_FLAGS_BIT_NONEXCLUSIVE);\n\tif (IS_ERR(cs_gpiod))\n\t\treturn PTR_ERR(cs_gpiod);\n\n\tif (cs_gpiod) {\n\t\tdev_info(dev, \"Found chip selector property\\n\");\n\t\tchip->cs_gpiod = cs_gpiod;\n\t}\n\n\tusleep_range(10000, 11000);\n\n\ti2c_set_clientdata(client, chip);\n\tchip->chip_irq = client->irq;\n\tchip->dev = dev;\n\tchip->regmap = devm_regmap_init_i2c(client, &slg51000_regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\terror = PTR_ERR(chip->regmap);\n\t\tdev_err(dev, \"Failed to allocate register map: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\tret = slg51000_regulator_init(chip);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to init regulator(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tslg51000_clear_fault_log(chip);\n\n\tif (chip->chip_irq) {\n\t\tret = devm_request_threaded_irq(dev, chip->chip_irq, NULL,\n\t\t\t\t\t\tslg51000_irq_handler,\n\t\t\t\t\t\t(IRQF_TRIGGER_HIGH |\n\t\t\t\t\t\tIRQF_ONESHOT),\n\t\t\t\t\t\t\"slg51000-irq\", chip);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"Failed to request IRQ: %d\\n\",\n\t\t\t\tchip->chip_irq);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tdev_info(dev, \"No IRQ configured\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id slg51000_i2c_id[] = {\n\t{\"slg51000\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, slg51000_i2c_id);\n\nstatic struct i2c_driver slg51000_regulator_driver = {\n\t.driver = {\n\t\t.name = \"slg51000-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = slg51000_i2c_probe,\n\t.id_table = slg51000_i2c_id,\n};\n\nmodule_i2c_driver(slg51000_regulator_driver);\n\nMODULE_AUTHOR(\"Eric Jeong <eric.jeong.opensource@diasemi.com>\");\nMODULE_DESCRIPTION(\"SLG51000 regulator driver\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}