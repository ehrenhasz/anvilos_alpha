{
  "module_name": "max1586.c",
  "hash_id": "e6e01083092f9d7c253261025134fb9f57a14b6e4f2aa4517c1afe8002610029",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/max1586.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/slab.h>\n#include <linux/regulator/max1586.h>\n#include <linux/of_device.h>\n#include <linux/regulator/of_regulator.h>\n\n#define MAX1586_V3_MAX_VSEL 31\n#define MAX1586_V6_MAX_VSEL 3\n\n#define MAX1586_V3_MIN_UV   700000\n#define MAX1586_V3_MAX_UV  1475000\n\n#define MAX1586_V6_MIN_UV        0\n#define MAX1586_V6_MAX_UV  3000000\n\n#define I2C_V3_SELECT (0 << 5)\n#define I2C_V6_SELECT (1 << 5)\n\nstruct max1586_data {\n\tstruct i2c_client *client;\n\n\t \n\tunsigned int min_uV;\n\tunsigned int max_uV;\n\n\tunsigned int v3_curr_sel;\n\tunsigned int v6_curr_sel;\n};\n\n \nstatic const unsigned int v6_voltages_uv[] = { 1, 1800000, 2500000, 3000000 };\n\n \nstatic int max1586_v3_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct max1586_data *max1586 = rdev_get_drvdata(rdev);\n\n\treturn max1586->v3_curr_sel;\n}\n\nstatic int max1586_v3_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t      unsigned selector)\n{\n\tstruct max1586_data *max1586 = rdev_get_drvdata(rdev);\n\tstruct i2c_client *client = max1586->client;\n\tint ret;\n\tu8 v3_prog;\n\n\tdev_dbg(&client->dev, \"changing voltage v3 to %dmv\\n\",\n\t\tregulator_list_voltage_linear(rdev, selector) / 1000);\n\n\tv3_prog = I2C_V3_SELECT | (u8) selector;\n\tret = i2c_smbus_write_byte(client, v3_prog);\n\tif (ret)\n\t\treturn ret;\n\n\tmax1586->v3_curr_sel = selector;\n\n\treturn 0;\n}\n\nstatic int max1586_v6_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct max1586_data *max1586 = rdev_get_drvdata(rdev);\n\n\treturn max1586->v6_curr_sel;\n}\n\nstatic int max1586_v6_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t      unsigned int selector)\n{\n\tstruct max1586_data *max1586 = rdev_get_drvdata(rdev);\n\tstruct i2c_client *client = max1586->client;\n\tu8 v6_prog;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"changing voltage v6 to %dmv\\n\",\n\t\trdev->desc->volt_table[selector] / 1000);\n\n\tv6_prog = I2C_V6_SELECT | (u8) selector;\n\tret = i2c_smbus_write_byte(client, v6_prog);\n\tif (ret)\n\t\treturn ret;\n\n\tmax1586->v6_curr_sel = selector;\n\n\treturn 0;\n}\n\n \nstatic const struct regulator_ops max1586_v3_ops = {\n\t.get_voltage_sel = max1586_v3_get_voltage_sel,\n\t.set_voltage_sel = max1586_v3_set_voltage_sel,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n};\n\nstatic const struct regulator_ops max1586_v6_ops = {\n\t.get_voltage_sel = max1586_v6_get_voltage_sel,\n\t.set_voltage_sel = max1586_v6_set_voltage_sel,\n\t.list_voltage = regulator_list_voltage_table,\n};\n\nstatic struct regulator_desc max1586_reg[] = {\n\t{\n\t\t.name = \"Output_V3\",\n\t\t.id = MAX1586_V3,\n\t\t.ops = &max1586_v3_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = MAX1586_V3_MAX_VSEL + 1,\n\t\t.owner = THIS_MODULE,\n\t},\n\t{\n\t\t.name = \"Output_V6\",\n\t\t.id = MAX1586_V6,\n\t\t.ops = &max1586_v6_ops,\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = MAX1586_V6_MAX_VSEL + 1,\n\t\t.volt_table = v6_voltages_uv,\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\nstatic int of_get_max1586_platform_data(struct device *dev,\n\t\t\t\t struct max1586_platform_data *pdata)\n{\n\tstruct max1586_subdev_data *sub;\n\tstruct of_regulator_match rmatch[ARRAY_SIZE(max1586_reg)] = { };\n\tstruct device_node *np = dev->of_node;\n\tint i, matched;\n\n\tif (of_property_read_u32(np, \"v3-gain\",\n\t\t\t\t &pdata->v3_gain) < 0) {\n\t\tdev_err(dev, \"%pOF has no 'v3-gain' property\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tnp = of_get_child_by_name(np, \"regulators\");\n\tif (!np) {\n\t\tdev_err(dev, \"missing 'regulators' subnode in DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rmatch); i++)\n\t\trmatch[i].name = max1586_reg[i].name;\n\n\tmatched = of_regulator_match(dev, np, rmatch, ARRAY_SIZE(rmatch));\n\tof_node_put(np);\n\t \n\tif (matched <= 0)\n\t\treturn matched;\n\n\tpdata->subdevs = devm_kcalloc(dev,\n\t\t\t\t      matched,\n\t\t\t\t      sizeof(struct max1586_subdev_data),\n\t\t\t\t      GFP_KERNEL);\n\tif (!pdata->subdevs)\n\t\treturn -ENOMEM;\n\n\tpdata->num_subdevs = matched;\n\tsub = pdata->subdevs;\n\n\tfor (i = 0; i < matched; i++) {\n\t\tsub->id = i;\n\t\tsub->name = rmatch[i].of_node->name;\n\t\tsub->platform_data = rmatch[i].init_data;\n\t\tsub++;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused max1586_of_match[] = {\n\t{ .compatible = \"maxim,max1586\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, max1586_of_match);\n\nstatic int max1586_pmic_probe(struct i2c_client *client)\n{\n\tstruct max1586_platform_data *pdata, pdata_of;\n\tstruct regulator_config config = { };\n\tstruct max1586_data *max1586;\n\tint i, id, ret;\n\tconst struct of_device_id *match;\n\n\tpdata = dev_get_platdata(&client->dev);\n\tif (client->dev.of_node && !pdata) {\n\t\tmatch = of_match_device(of_match_ptr(max1586_of_match),\n\t\t\t\t\t&client->dev);\n\t\tif (!match) {\n\t\t\tdev_err(&client->dev, \"Error: No device match found\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tret = of_get_max1586_platform_data(&client->dev, &pdata_of);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpdata = &pdata_of;\n\t}\n\n\tmax1586 = devm_kzalloc(&client->dev, sizeof(struct max1586_data),\n\t\t\tGFP_KERNEL);\n\tif (!max1586)\n\t\treturn -ENOMEM;\n\n\tmax1586->client = client;\n\n\tif (!pdata->v3_gain)\n\t\treturn -EINVAL;\n\n\tmax1586->min_uV = MAX1586_V3_MIN_UV / 1000 * pdata->v3_gain / 1000;\n\tmax1586->max_uV = MAX1586_V3_MAX_UV / 1000 * pdata->v3_gain / 1000;\n\n\t \n\tmax1586->v3_curr_sel = 24;  \n\tmax1586->v6_curr_sel = 0;\n\n\tfor (i = 0; i < pdata->num_subdevs && i <= MAX1586_V6; i++) {\n\t\tstruct regulator_dev *rdev;\n\n\t\tid = pdata->subdevs[i].id;\n\t\tif (!pdata->subdevs[i].platform_data)\n\t\t\tcontinue;\n\t\tif (id < MAX1586_V3 || id > MAX1586_V6) {\n\t\t\tdev_err(&client->dev, \"invalid regulator id %d\\n\", id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (id == MAX1586_V3) {\n\t\t\tmax1586_reg[id].min_uV = max1586->min_uV;\n\t\t\tmax1586_reg[id].uV_step =\n\t\t\t\t\t(max1586->max_uV - max1586->min_uV) /\n\t\t\t\t\tMAX1586_V3_MAX_VSEL;\n\t\t}\n\n\t\tconfig.dev = &client->dev;\n\t\tconfig.init_data = pdata->subdevs[i].platform_data;\n\t\tconfig.driver_data = max1586;\n\n\t\trdev = devm_regulator_register(&client->dev,\n\t\t\t\t\t\t  &max1586_reg[id], &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&client->dev, \"failed to register %s\\n\",\n\t\t\t\tmax1586_reg[id].name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\ti2c_set_clientdata(client, max1586);\n\tdev_info(&client->dev, \"Maxim 1586 regulator driver loaded\\n\");\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max1586_id[] = {\n\t{ \"max1586\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max1586_id);\n\nstatic struct i2c_driver max1586_pmic_driver = {\n\t.probe = max1586_pmic_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"max1586\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(max1586_of_match),\n\t},\n\t.id_table\t= max1586_id,\n};\n\nstatic int __init max1586_pmic_init(void)\n{\n\treturn i2c_add_driver(&max1586_pmic_driver);\n}\nsubsys_initcall(max1586_pmic_init);\n\nstatic void __exit max1586_pmic_exit(void)\n{\n\ti2c_del_driver(&max1586_pmic_driver);\n}\nmodule_exit(max1586_pmic_exit);\n\n \nMODULE_DESCRIPTION(\"MAXIM 1586 voltage regulator driver\");\nMODULE_AUTHOR(\"Robert Jarzmik\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}