{
  "module_name": "rohm-regulator.c",
  "hash_id": "e28b7f0615f8ec164944cda6760d414b1bcc98a6d436a783ef1d68f4324aa2e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rohm-regulator.c",
  "human_readable_source": "\n\n\n#include <linux/errno.h>\n#include <linux/mfd/rohm-generic.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n\nstatic int set_dvs_level(const struct regulator_desc *desc,\n\t\t\t struct device_node *np, struct regmap *regmap,\n\t\t\t char *prop, unsigned int reg, unsigned int mask,\n\t\t\t unsigned int omask, unsigned int oreg)\n{\n\tint ret, i;\n\tuint32_t uv;\n\n\tret = of_property_read_u32(np, prop, &uv);\n\tif (ret) {\n\t\tif (ret != -EINVAL)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\t \n\tif (uv == 0) {\n\t\tif (omask)\n\t\t\treturn regmap_update_bits(regmap, oreg, omask, 0);\n\t}\n\t \n\tif (!mask) {\n\t\tif (omask)\n\t\t\treturn regmap_update_bits(regmap, oreg, omask, omask);\n\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < desc->n_voltages; i++) {\n\t\t \n\t\tif (desc->linear_range_selectors_bitfield)\n\t\t\treturn -EINVAL;\n\t\tif (desc->n_linear_ranges)\n\t\t\tret = regulator_desc_list_voltage_linear_range(desc, i);\n\t\telse\n\t\t\tret = regulator_desc_list_voltage_linear(desc, i);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\t\tif (ret == uv) {\n\t\t\ti <<= ffs(desc->vsel_mask) - 1;\n\t\t\tret = regmap_update_bits(regmap, reg, mask, i);\n\t\t\tif (omask && !ret)\n\t\t\t\tret = regmap_update_bits(regmap, oreg, omask,\n\t\t\t\t\t\t\t omask);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint rohm_regulator_set_dvs_levels(const struct rohm_dvs_config *dvs,\n\t\t\t  struct device_node *np,\n\t\t\t  const struct regulator_desc *desc,\n\t\t\t  struct regmap *regmap)\n{\n\tint i, ret = 0;\n\tchar *prop;\n\tunsigned int reg, mask, omask, oreg = desc->enable_reg;\n\n\tfor (i = 0; i < ROHM_DVS_LEVEL_VALID_AMOUNT && !ret; i++) {\n\t\tint bit;\n\n\t\tbit = BIT(i);\n\t\tif (dvs->level_map & bit) {\n\t\t\tswitch (bit) {\n\t\t\tcase ROHM_DVS_LEVEL_RUN:\n\t\t\t\tprop = \"rohm,dvs-run-voltage\";\n\t\t\t\treg = dvs->run_reg;\n\t\t\t\tmask = dvs->run_mask;\n\t\t\t\tomask = dvs->run_on_mask;\n\t\t\t\tbreak;\n\t\t\tcase ROHM_DVS_LEVEL_IDLE:\n\t\t\t\tprop = \"rohm,dvs-idle-voltage\";\n\t\t\t\treg = dvs->idle_reg;\n\t\t\t\tmask = dvs->idle_mask;\n\t\t\t\tomask = dvs->idle_on_mask;\n\t\t\t\tbreak;\n\t\t\tcase ROHM_DVS_LEVEL_SUSPEND:\n\t\t\t\tprop = \"rohm,dvs-suspend-voltage\";\n\t\t\t\treg = dvs->suspend_reg;\n\t\t\t\tmask = dvs->suspend_mask;\n\t\t\t\tomask = dvs->suspend_on_mask;\n\t\t\t\tbreak;\n\t\t\tcase ROHM_DVS_LEVEL_LPSR:\n\t\t\t\tprop = \"rohm,dvs-lpsr-voltage\";\n\t\t\t\treg = dvs->lpsr_reg;\n\t\t\t\tmask = dvs->lpsr_mask;\n\t\t\t\tomask = dvs->lpsr_on_mask;\n\t\t\t\tbreak;\n\t\t\tcase ROHM_DVS_LEVEL_SNVS:\n\t\t\t\tprop = \"rohm,dvs-snvs-voltage\";\n\t\t\t\treg = dvs->snvs_reg;\n\t\t\t\tmask = dvs->snvs_mask;\n\t\t\t\tomask = dvs->snvs_on_mask;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = set_dvs_level(desc, np, regmap, prop, reg, mask,\n\t\t\t\t\t    omask, oreg);\n\t\t}\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(rohm_regulator_set_dvs_levels);\n\n \nint rohm_regulator_set_voltage_sel_restricted(struct regulator_dev *rdev,\n\t\t\t\t\t      unsigned int sel)\n{\n\tif (rdev->desc->ops->is_enabled(rdev))\n\t\treturn -EBUSY;\n\n\treturn regulator_set_voltage_sel_regmap(rdev, sel);\n}\nEXPORT_SYMBOL_GPL(rohm_regulator_set_voltage_sel_restricted);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>\");\nMODULE_DESCRIPTION(\"Generic helpers for ROHM PMIC regulator drivers\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}