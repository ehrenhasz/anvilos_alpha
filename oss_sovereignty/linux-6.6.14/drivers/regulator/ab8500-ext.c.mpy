{
  "module_name": "ab8500-ext.c",
  "hash_id": "d2817bca7b987175e9a171555567dc7c6dc3ce11bee2ca15d6184a4c88edb7ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/ab8500-ext.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/mfd/abx500.h>\n#include <linux/mfd/abx500/ab8500.h>\n\n \nenum ab8500_ext_regulator_id {\n\tAB8500_EXT_SUPPLY1,\n\tAB8500_EXT_SUPPLY2,\n\tAB8500_EXT_SUPPLY3,\n\tAB8500_NUM_EXT_REGULATORS,\n};\n\nstruct ab8500_ext_regulator_cfg {\n\tbool hwreq;  \n};\n\n \nstatic struct regulator_consumer_supply ab8500_ext_supply3_consumers[] = {\n\t \n\tREGULATOR_SUPPLY(\"vinvsim\", \"sim-detect.0\"),\n};\n\n \nstatic struct regulator_init_data ab8500_ext_regulators[] = {\n\t \n\t[AB8500_EXT_SUPPLY1] = {\n\t\t.constraints = {\n\t\t\t.name = \"ab8500-ext-supply1\",\n\t\t\t.min_uV = 1800000,\n\t\t\t.max_uV = 1800000,\n\t\t\t.initial_mode = REGULATOR_MODE_IDLE,\n\t\t\t.boot_on = 1,\n\t\t\t.always_on = 1,\n\t\t},\n\t},\n\t \n\t[AB8500_EXT_SUPPLY2] = {\n\t\t.constraints = {\n\t\t\t.name = \"ab8500-ext-supply2\",\n\t\t\t.min_uV = 1360000,\n\t\t\t.max_uV = 1360000,\n\t\t},\n\t},\n\t \n\t[AB8500_EXT_SUPPLY3] = {\n\t\t.constraints = {\n\t\t\t.name = \"ab8500-ext-supply3\",\n\t\t\t.min_uV = 3400000,\n\t\t\t.max_uV = 3400000,\n\t\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t\t\t.boot_on = 1,\n\t\t},\n\t\t.num_consumer_supplies =\n\t\t\tARRAY_SIZE(ab8500_ext_supply3_consumers),\n\t\t.consumer_supplies = ab8500_ext_supply3_consumers,\n\t},\n};\n\n \nstruct ab8500_ext_regulator_info {\n\tstruct device *dev;\n\tstruct regulator_desc desc;\n\tstruct ab8500_ext_regulator_cfg *cfg;\n\tu8 update_bank;\n\tu8 update_reg;\n\tu8 update_mask;\n\tu8 update_val;\n\tu8 update_val_hp;\n\tu8 update_val_lp;\n\tu8 update_val_hw;\n};\n\nstatic int ab8500_ext_regulator_enable(struct regulator_dev *rdev)\n{\n\tint ret;\n\tstruct ab8500_ext_regulator_info *info = rdev_get_drvdata(rdev);\n\tu8 regval;\n\n\tif (info == NULL) {\n\t\tdev_err(rdev_get_dev(rdev), \"regulator info null pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (info->cfg && info->cfg->hwreq)\n\t\tregval = info->update_val_hp;\n\telse\n\t\tregval = info->update_val;\n\n\tret = abx500_mask_and_set_register_interruptible(info->dev,\n\t\tinfo->update_bank, info->update_reg,\n\t\tinfo->update_mask, regval);\n\tif (ret < 0) {\n\t\tdev_err(rdev_get_dev(rdev),\n\t\t\t\"couldn't set enable bits for regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(rdev_get_dev(rdev),\n\t\t\"%s-enable (bank, reg, mask, value): 0x%02x, 0x%02x, 0x%02x, 0x%02x\\n\",\n\t\tinfo->desc.name, info->update_bank, info->update_reg,\n\t\tinfo->update_mask, regval);\n\n\treturn 0;\n}\n\nstatic int ab8500_ext_regulator_disable(struct regulator_dev *rdev)\n{\n\tint ret;\n\tstruct ab8500_ext_regulator_info *info = rdev_get_drvdata(rdev);\n\tu8 regval;\n\n\tif (info == NULL) {\n\t\tdev_err(rdev_get_dev(rdev), \"regulator info null pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (info->cfg && info->cfg->hwreq)\n\t\tregval = info->update_val_hw;\n\telse\n\t\tregval = 0;\n\n\tret = abx500_mask_and_set_register_interruptible(info->dev,\n\t\tinfo->update_bank, info->update_reg,\n\t\tinfo->update_mask, regval);\n\tif (ret < 0) {\n\t\tdev_err(rdev_get_dev(rdev),\n\t\t\t\"couldn't set disable bits for regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(rdev_get_dev(rdev), \"%s-disable (bank, reg, mask, value):\"\n\t\t\" 0x%02x, 0x%02x, 0x%02x, 0x%02x\\n\",\n\t\tinfo->desc.name, info->update_bank, info->update_reg,\n\t\tinfo->update_mask, regval);\n\n\treturn 0;\n}\n\nstatic int ab8500_ext_regulator_is_enabled(struct regulator_dev *rdev)\n{\n\tint ret;\n\tstruct ab8500_ext_regulator_info *info = rdev_get_drvdata(rdev);\n\tu8 regval;\n\n\tif (info == NULL) {\n\t\tdev_err(rdev_get_dev(rdev), \"regulator info null pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = abx500_get_register_interruptible(info->dev,\n\t\tinfo->update_bank, info->update_reg, &regval);\n\tif (ret < 0) {\n\t\tdev_err(rdev_get_dev(rdev),\n\t\t\t\"couldn't read 0x%x register\\n\", info->update_reg);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(rdev_get_dev(rdev), \"%s-is_enabled (bank, reg, mask, value):\"\n\t\t\" 0x%02x, 0x%02x, 0x%02x, 0x%02x\\n\",\n\t\tinfo->desc.name, info->update_bank, info->update_reg,\n\t\tinfo->update_mask, regval);\n\n\tif (((regval & info->update_mask) == info->update_val_lp) ||\n\t    ((regval & info->update_mask) == info->update_val_hp))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int ab8500_ext_regulator_set_mode(struct regulator_dev *rdev,\n\t\t\t\t\t unsigned int mode)\n{\n\tint ret = 0;\n\tstruct ab8500_ext_regulator_info *info = rdev_get_drvdata(rdev);\n\tu8 regval;\n\n\tif (info == NULL) {\n\t\tdev_err(rdev_get_dev(rdev), \"regulator info null pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tregval = info->update_val_hp;\n\t\tbreak;\n\tcase REGULATOR_MODE_IDLE:\n\t\tregval = info->update_val_lp;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ab8500_ext_regulator_is_enabled(rdev) &&\n\t    !(info->cfg && info->cfg->hwreq)) {\n\t\tret = abx500_mask_and_set_register_interruptible(info->dev,\n\t\t\t\t\tinfo->update_bank, info->update_reg,\n\t\t\t\t\tinfo->update_mask, regval);\n\t\tif (ret < 0) {\n\t\t\tdev_err(rdev_get_dev(rdev),\n\t\t\t\t\"Could not set regulator mode.\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_dbg(rdev_get_dev(rdev),\n\t\t\t\"%s-set_mode (bank, reg, mask, value): \"\n\t\t\t\"0x%x, 0x%x, 0x%x, 0x%x\\n\",\n\t\t\tinfo->desc.name, info->update_bank, info->update_reg,\n\t\t\tinfo->update_mask, regval);\n\t}\n\n\tinfo->update_val = regval;\n\n\treturn 0;\n}\n\nstatic unsigned int ab8500_ext_regulator_get_mode(struct regulator_dev *rdev)\n{\n\tstruct ab8500_ext_regulator_info *info = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tif (info == NULL) {\n\t\tdev_err(rdev_get_dev(rdev), \"regulator info null pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->update_val == info->update_val_hp)\n\t\tret = REGULATOR_MODE_NORMAL;\n\telse if (info->update_val == info->update_val_lp)\n\t\tret = REGULATOR_MODE_IDLE;\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic int ab8500_ext_set_voltage(struct regulator_dev *rdev, int min_uV,\n\t\t\t\t  int max_uV, unsigned *selector)\n{\n\tstruct regulation_constraints *regu_constraints = rdev->constraints;\n\n\tif (!regu_constraints) {\n\t\tdev_err(rdev_get_dev(rdev), \"No regulator constraints\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (regu_constraints->min_uV == min_uV &&\n\t    regu_constraints->max_uV == max_uV)\n\t\treturn 0;\n\n\tdev_err(rdev_get_dev(rdev),\n\t\t\"Requested min %duV max %duV != constrained min %duV max %duV\\n\",\n\t\tmin_uV, max_uV,\n\t\tregu_constraints->min_uV, regu_constraints->max_uV);\n\n\treturn -EINVAL;\n}\n\nstatic int ab8500_ext_list_voltage(struct regulator_dev *rdev,\n\t\t\t\t   unsigned selector)\n{\n\tstruct regulation_constraints *regu_constraints = rdev->constraints;\n\n\tif (regu_constraints == NULL) {\n\t\tdev_err(rdev_get_dev(rdev), \"regulator constraints null pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (regu_constraints->min_uV && regu_constraints->max_uV) {\n\t\tif (regu_constraints->min_uV == regu_constraints->max_uV)\n\t\t\treturn regu_constraints->min_uV;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct regulator_ops ab8500_ext_regulator_ops = {\n\t.enable\t\t\t= ab8500_ext_regulator_enable,\n\t.disable\t\t= ab8500_ext_regulator_disable,\n\t.is_enabled\t\t= ab8500_ext_regulator_is_enabled,\n\t.set_mode\t\t= ab8500_ext_regulator_set_mode,\n\t.get_mode\t\t= ab8500_ext_regulator_get_mode,\n\t.set_voltage\t\t= ab8500_ext_set_voltage,\n\t.list_voltage\t\t= ab8500_ext_list_voltage,\n};\n\nstatic struct ab8500_ext_regulator_info\n\t\tab8500_ext_regulator_info[AB8500_NUM_EXT_REGULATORS] = {\n\t[AB8500_EXT_SUPPLY1] = {\n\t\t.desc = {\n\t\t\t.name\t\t= \"VEXTSUPPLY1\",\n\t\t\t.of_match\t= of_match_ptr(\"ab8500_ext1\"),\n\t\t\t.ops\t\t= &ab8500_ext_regulator_ops,\n\t\t\t.type\t\t= REGULATOR_VOLTAGE,\n\t\t\t.id\t\t= AB8500_EXT_SUPPLY1,\n\t\t\t.owner\t\t= THIS_MODULE,\n\t\t\t.n_voltages\t= 1,\n\t\t},\n\t\t.update_bank\t\t= 0x04,\n\t\t.update_reg\t\t= 0x08,\n\t\t.update_mask\t\t= 0x03,\n\t\t.update_val\t\t= 0x01,\n\t\t.update_val_hp\t\t= 0x01,\n\t\t.update_val_lp\t\t= 0x03,\n\t\t.update_val_hw\t\t= 0x02,\n\t},\n\t[AB8500_EXT_SUPPLY2] = {\n\t\t.desc = {\n\t\t\t.name\t\t= \"VEXTSUPPLY2\",\n\t\t\t.of_match\t= of_match_ptr(\"ab8500_ext2\"),\n\t\t\t.ops\t\t= &ab8500_ext_regulator_ops,\n\t\t\t.type\t\t= REGULATOR_VOLTAGE,\n\t\t\t.id\t\t= AB8500_EXT_SUPPLY2,\n\t\t\t.owner\t\t= THIS_MODULE,\n\t\t\t.n_voltages\t= 1,\n\t\t},\n\t\t.update_bank\t\t= 0x04,\n\t\t.update_reg\t\t= 0x08,\n\t\t.update_mask\t\t= 0x0c,\n\t\t.update_val\t\t= 0x04,\n\t\t.update_val_hp\t\t= 0x04,\n\t\t.update_val_lp\t\t= 0x0c,\n\t\t.update_val_hw\t\t= 0x08,\n\t},\n\t[AB8500_EXT_SUPPLY3] = {\n\t\t.desc = {\n\t\t\t.name\t\t= \"VEXTSUPPLY3\",\n\t\t\t.of_match\t= of_match_ptr(\"ab8500_ext3\"),\n\t\t\t.ops\t\t= &ab8500_ext_regulator_ops,\n\t\t\t.type\t\t= REGULATOR_VOLTAGE,\n\t\t\t.id\t\t= AB8500_EXT_SUPPLY3,\n\t\t\t.owner\t\t= THIS_MODULE,\n\t\t\t.n_voltages\t= 1,\n\t\t},\n\t\t.update_bank\t\t= 0x04,\n\t\t.update_reg\t\t= 0x08,\n\t\t.update_mask\t\t= 0x30,\n\t\t.update_val\t\t= 0x10,\n\t\t.update_val_hp\t\t= 0x10,\n\t\t.update_val_lp\t\t= 0x30,\n\t\t.update_val_hw\t\t= 0x20,\n\t},\n};\n\nstatic int ab8500_ext_regulator_probe(struct platform_device *pdev)\n{\n\tstruct ab8500 *ab8500 = dev_get_drvdata(pdev->dev.parent);\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tint i;\n\n\tif (!ab8500) {\n\t\tdev_err(&pdev->dev, \"null mfd parent\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (is_ab8500_2p0_or_earlier(ab8500)) {\n\t\tstruct ab8500_ext_regulator_info *info;\n\n\t\t \n\t\tinfo = &ab8500_ext_regulator_info[AB8500_EXT_SUPPLY3];\n\t\tinfo->update_val = 0x30;\n\t\tinfo->update_val_hp = 0x30;\n\t\tinfo->update_val_lp = 0x10;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ab8500_ext_regulator_info); i++) {\n\t\tstruct ab8500_ext_regulator_info *info = NULL;\n\n\t\t \n\t\tinfo = &ab8500_ext_regulator_info[i];\n\t\tinfo->dev = &pdev->dev;\n\t\tinfo->cfg = (struct ab8500_ext_regulator_cfg *)\n\t\t\tab8500_ext_regulators[i].driver_data;\n\n\t\tconfig.dev = &pdev->dev;\n\t\tconfig.driver_data = info;\n\t\tconfig.init_data = &ab8500_ext_regulators[i];\n\n\t\t \n\t\trdev = devm_regulator_register(&pdev->dev, &info->desc,\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&pdev->dev, \"failed to register regulator %s\\n\",\n\t\t\t\t\tinfo->desc.name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\n\t\tdev_dbg(&pdev->dev, \"%s-probed\\n\", info->desc.name);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver ab8500_ext_regulator_driver = {\n\t.probe = ab8500_ext_regulator_probe,\n\t.driver         = {\n\t\t.name   = \"ab8500-ext-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init ab8500_ext_regulator_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&ab8500_ext_regulator_driver);\n\tif (ret)\n\t\tpr_err(\"Failed to register ab8500 ext regulator: %d\\n\", ret);\n\n\treturn ret;\n}\nsubsys_initcall(ab8500_ext_regulator_init);\n\nstatic void __exit ab8500_ext_regulator_exit(void)\n{\n\tplatform_driver_unregister(&ab8500_ext_regulator_driver);\n}\nmodule_exit(ab8500_ext_regulator_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Bengt Jonsson <bengt.g.jonsson@stericsson.com>\");\nMODULE_DESCRIPTION(\"AB8500 external regulator driver\");\nMODULE_ALIAS(\"platform:ab8500-ext-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}