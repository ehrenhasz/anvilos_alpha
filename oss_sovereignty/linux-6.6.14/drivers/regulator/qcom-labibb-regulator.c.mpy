{
  "module_name": "qcom-labibb-regulator.c",
  "hash_id": "bdee93d85a5f29b0ccdc4f3876e97868f2fd3bd78e8e559b8eb1f53daed3ed26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/qcom-labibb-regulator.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n#define REG_PERPH_TYPE                  0x04\n\n#define QCOM_LAB_TYPE\t\t\t0x24\n#define QCOM_IBB_TYPE\t\t\t0x20\n\n#define PMI8998_LAB_REG_BASE\t\t0xde00\n#define PMI8998_IBB_REG_BASE\t\t0xdc00\n#define PMI8998_IBB_LAB_REG_OFFSET\t0x200\n\n#define REG_LABIBB_STATUS1\t\t0x08\n #define LABIBB_STATUS1_SC_BIT\t\tBIT(6)\n #define LABIBB_STATUS1_VREG_OK_BIT\tBIT(7)\n\n#define REG_LABIBB_INT_SET_TYPE\t\t0x11\n#define REG_LABIBB_INT_POLARITY_HIGH\t0x12\n#define REG_LABIBB_INT_POLARITY_LOW\t0x13\n#define REG_LABIBB_INT_LATCHED_CLR\t0x14\n#define REG_LABIBB_INT_EN_SET\t\t0x15\n#define REG_LABIBB_INT_EN_CLR\t\t0x16\n #define LABIBB_INT_VREG_OK\t\tBIT(0)\n #define LABIBB_INT_VREG_TYPE_LEVEL\t0\n\n#define REG_LABIBB_VOLTAGE\t\t0x41\n #define LABIBB_VOLTAGE_OVERRIDE_EN\tBIT(7)\n #define LAB_VOLTAGE_SET_MASK\t\tGENMASK(3, 0)\n #define IBB_VOLTAGE_SET_MASK\t\tGENMASK(5, 0)\n\n#define REG_LABIBB_ENABLE_CTL\t\t0x46\n #define LABIBB_CONTROL_ENABLE\t\tBIT(7)\n\n#define REG_LABIBB_PD_CTL\t\t0x47\n #define LAB_PD_CTL_MASK\t\tGENMASK(1, 0)\n #define IBB_PD_CTL_MASK\t\t(BIT(0) | BIT(7))\n #define LAB_PD_CTL_STRONG_PULL\t\tBIT(0)\n #define IBB_PD_CTL_HALF_STRENGTH\tBIT(0)\n #define IBB_PD_CTL_EN\t\t\tBIT(7)\n\n#define REG_LABIBB_CURRENT_LIMIT\t0x4b\n #define LAB_CURRENT_LIMIT_MASK\t\tGENMASK(2, 0)\n #define IBB_CURRENT_LIMIT_MASK\t\tGENMASK(4, 0)\n #define LAB_CURRENT_LIMIT_OVERRIDE_EN\tBIT(3)\n #define LABIBB_CURRENT_LIMIT_EN\tBIT(7)\n\n#define REG_IBB_PWRUP_PWRDN_CTL_1\t0x58\n #define IBB_CTL_1_DISCHARGE_EN\t\tBIT(2)\n\n#define REG_LABIBB_SOFT_START_CTL\t0x5f\n#define REG_LABIBB_SEC_ACCESS\t\t0xd0\n #define LABIBB_SEC_UNLOCK_CODE\t\t0xa5\n\n#define LAB_ENABLE_CTL_MASK\t\tBIT(7)\n#define IBB_ENABLE_CTL_MASK\t\t(BIT(7) | BIT(6))\n\n#define LABIBB_OFF_ON_DELAY\t\t1000\n#define LAB_ENABLE_TIME\t\t\t(LABIBB_OFF_ON_DELAY * 2)\n#define IBB_ENABLE_TIME\t\t\t(LABIBB_OFF_ON_DELAY * 10)\n#define LABIBB_POLL_ENABLED_TIME\t1000\n#define OCP_RECOVERY_INTERVAL_MS\t500\n#define SC_RECOVERY_INTERVAL_MS\t\t250\n#define LABIBB_MAX_OCP_COUNT\t\t4\n#define LABIBB_MAX_SC_COUNT\t\t3\n#define LABIBB_MAX_FATAL_COUNT\t\t2\n\nstruct labibb_current_limits {\n\tu32\t\t\t\tuA_min;\n\tu32\t\t\t\tuA_step;\n\tu8\t\t\t\tovr_val;\n};\n\nstruct labibb_regulator {\n\tstruct regulator_desc\t\tdesc;\n\tstruct device\t\t\t*dev;\n\tstruct regmap\t\t\t*regmap;\n\tstruct regulator_dev\t\t*rdev;\n\tstruct labibb_current_limits\tuA_limits;\n\tstruct delayed_work\t\tocp_recovery_work;\n\tstruct delayed_work\t\tsc_recovery_work;\n\tu16\t\t\t\tbase;\n\tu8\t\t\t\ttype;\n\tu8\t\t\t\tdischg_sel;\n\tu8\t\t\t\tsoft_start_sel;\n\tint\t\t\t\tsc_irq;\n\tint\t\t\t\tsc_count;\n\tint\t\t\t\tocp_irq;\n\tint\t\t\t\tocp_irq_count;\n\tint\t\t\t\tfatal_count;\n};\n\nstruct labibb_regulator_data {\n\tconst char\t\t\t*name;\n\tu8\t\t\t\ttype;\n\tu16\t\t\t\tbase;\n\tconst struct regulator_desc\t*desc;\n};\n\nstatic int qcom_labibb_ocp_hw_enable(struct regulator_dev *rdev)\n{\n\tstruct labibb_regulator *vreg = rdev_get_drvdata(rdev);\n\tint ret;\n\n\t \n\tret = regmap_update_bits(rdev->regmap,\n\t\t\t\t vreg->base + REG_LABIBB_INT_LATCHED_CLR,\n\t\t\t\t LABIBB_INT_VREG_OK, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(rdev->regmap,\n\t\t\t\t  vreg->base + REG_LABIBB_INT_EN_SET,\n\t\t\t\t  LABIBB_INT_VREG_OK, 1);\n}\n\nstatic int qcom_labibb_ocp_hw_disable(struct regulator_dev *rdev)\n{\n\tstruct labibb_regulator *vreg = rdev_get_drvdata(rdev);\n\n\treturn regmap_update_bits(rdev->regmap,\n\t\t\t\t  vreg->base + REG_LABIBB_INT_EN_CLR,\n\t\t\t\t  LABIBB_INT_VREG_OK, 1);\n}\n\n \nstatic int qcom_labibb_check_ocp_status(struct labibb_regulator *vreg)\n{\n\tu32 cur_status;\n\tint ret;\n\n\tret = regmap_read(vreg->rdev->regmap, vreg->base + REG_LABIBB_STATUS1,\n\t\t\t  &cur_status);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !(cur_status & LABIBB_STATUS1_VREG_OK_BIT);\n}\n\n \nstatic void qcom_labibb_ocp_recovery_worker(struct work_struct *work)\n{\n\tstruct labibb_regulator *vreg;\n\tconst struct regulator_ops *ops;\n\tint ret;\n\n\tvreg = container_of(work, struct labibb_regulator,\n\t\t\t    ocp_recovery_work.work);\n\tops = vreg->rdev->desc->ops;\n\n\tif (vreg->ocp_irq_count >= LABIBB_MAX_OCP_COUNT) {\n\t\t \n\t\tBUG_ON(vreg->fatal_count > LABIBB_MAX_FATAL_COUNT);\n\t\tdev_err(&vreg->rdev->dev, \"LABIBB: CRITICAL: Disabling regulator\\n\");\n\n\t\t \n\t\tret = ops->disable(vreg->rdev);\n\t\tif (ret) {\n\t\t\tvreg->fatal_count++;\n\t\t\tgoto reschedule;\n\t\t}\n\t\tenable_irq(vreg->ocp_irq);\n\t\tvreg->fatal_count = 0;\n\t\treturn;\n\t}\n\n\tret = qcom_labibb_check_ocp_status(vreg);\n\tif (ret != 0) {\n\t\tvreg->ocp_irq_count++;\n\t\tgoto reschedule;\n\t}\n\n\tret = qcom_labibb_ocp_hw_enable(vreg->rdev);\n\tif (ret) {\n\t\t \n\t\tdev_err(vreg->dev, \"Cannot enable OCP IRQ\\n\");\n\t\tvreg->ocp_irq_count++;\n\t\tgoto reschedule;\n\t}\n\n\tenable_irq(vreg->ocp_irq);\n\t \n\tvreg->ocp_irq_count = 0;\n\treturn;\n\nreschedule:\n\tmod_delayed_work(system_wq, &vreg->ocp_recovery_work,\n\t\t\t msecs_to_jiffies(OCP_RECOVERY_INTERVAL_MS));\n}\n\n \nstatic irqreturn_t qcom_labibb_ocp_isr(int irq, void *chip)\n{\n\tstruct labibb_regulator *vreg = chip;\n\tconst struct regulator_ops *ops = vreg->rdev->desc->ops;\n\tint ret;\n\n\t \n\tif (!ops->is_enabled(vreg->rdev))\n\t\treturn IRQ_HANDLED;\n\n\t \n\tif (vreg->ocp_irq_count > LABIBB_MAX_OCP_COUNT)\n\t\treturn IRQ_NONE;\n\n\t \n\tret = qcom_labibb_check_ocp_status(vreg);\n\tif (ret == 0) {\n\t\tvreg->ocp_irq_count = 0;\n\t\tgoto end;\n\t}\n\tvreg->ocp_irq_count++;\n\n\t \n\tdisable_irq_nosync(irq);\n\n\t \n\tdev_warn(vreg->dev, \"Over-Current interrupt fired!\\n\");\n\n\t \n\tret = qcom_labibb_ocp_hw_disable(vreg->rdev);\n\tif (ret)\n\t\tgoto end;\n\n\t \n\tregulator_notifier_call_chain(vreg->rdev,\n\t\t\t\t      REGULATOR_EVENT_OVER_CURRENT, NULL);\n\nend:\n\t \n\tschedule_delayed_work(&vreg->ocp_recovery_work,\n\t\t\t      msecs_to_jiffies(OCP_RECOVERY_INTERVAL_MS));\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int qcom_labibb_set_ocp(struct regulator_dev *rdev, int lim,\n\t\t\t       int severity, bool enable)\n{\n\tstruct labibb_regulator *vreg = rdev_get_drvdata(rdev);\n\tchar *ocp_irq_name;\n\tu32 irq_flags = IRQF_ONESHOT;\n\tint irq_trig_low, ret;\n\n\t \n\tif (lim || severity != REGULATOR_SEVERITY_PROT || !enable)\n\t\treturn -EINVAL;\n\n\t \n\tif (vreg->ocp_irq <= 0)\n\t\treturn -EINVAL;\n\n\tocp_irq_name = devm_kasprintf(vreg->dev, GFP_KERNEL, \"%s-over-current\",\n\t\t\t\t      vreg->desc.name);\n\tif (!ocp_irq_name)\n\t\treturn -ENOMEM;\n\n\t \n\tswitch (vreg->type) {\n\tcase QCOM_LAB_TYPE:\n\t\tirq_flags |= IRQF_TRIGGER_LOW;\n\t\tirq_trig_low = 1;\n\t\tbreak;\n\tcase QCOM_IBB_TYPE:\n\t\tirq_flags |= IRQF_TRIGGER_HIGH;\n\t\tirq_trig_low = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_update_bits(rdev->regmap,\n\t\t\t\t vreg->base + REG_LABIBB_INT_SET_TYPE,\n\t\t\t\t LABIBB_INT_VREG_OK,\n\t\t\t\t LABIBB_INT_VREG_TYPE_LEVEL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(rdev->regmap,\n\t\t\t\t vreg->base + REG_LABIBB_INT_POLARITY_HIGH,\n\t\t\t\t LABIBB_INT_VREG_OK, !irq_trig_low);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_update_bits(rdev->regmap,\n\t\t\t\t vreg->base + REG_LABIBB_INT_POLARITY_LOW,\n\t\t\t\t LABIBB_INT_VREG_OK, irq_trig_low);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_labibb_ocp_hw_enable(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_request_threaded_irq(vreg->dev, vreg->ocp_irq, NULL,\n\t\t\t\t\t qcom_labibb_ocp_isr, irq_flags,\n\t\t\t\t\t ocp_irq_name, vreg);\n}\n\n \nstatic int qcom_labibb_check_sc_status(struct labibb_regulator *vreg)\n{\n\tu32 ibb_status, ibb_reg, lab_status, lab_reg;\n\tint ret;\n\n\t \n\tlab_reg = ibb_reg = vreg->base + REG_LABIBB_STATUS1;\n\tif (vreg->type == QCOM_LAB_TYPE)\n\t\tibb_reg -= PMI8998_IBB_LAB_REG_OFFSET;\n\telse\n\t\tlab_reg += PMI8998_IBB_LAB_REG_OFFSET;\n\n\tret = regmap_read(vreg->rdev->regmap, lab_reg, &lab_status);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_read(vreg->rdev->regmap, ibb_reg, &ibb_status);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(lab_status & LABIBB_STATUS1_SC_BIT) ||\n\t       !!(ibb_status & LABIBB_STATUS1_SC_BIT);\n}\n\n \nstatic void qcom_labibb_sc_recovery_worker(struct work_struct *work)\n{\n\tstruct labibb_regulator *vreg;\n\tconst struct regulator_ops *ops;\n\tu32 lab_reg, ibb_reg, lab_val, ibb_val, val;\n\tbool pbs_cut = false;\n\tint i, sc, ret;\n\n\tvreg = container_of(work, struct labibb_regulator,\n\t\t\t    sc_recovery_work.work);\n\tops = vreg->rdev->desc->ops;\n\n\t \n\tif (vreg->fatal_count > LABIBB_MAX_FATAL_COUNT)\n\t\treturn;\n\n\t \n\tif (vreg->sc_count > LABIBB_MAX_SC_COUNT)\n\t\treturn;\n\n\t \n\tlab_reg = ibb_reg = vreg->base + REG_LABIBB_ENABLE_CTL;\n\tif (vreg->type == QCOM_LAB_TYPE)\n\t\tibb_reg -= PMI8998_IBB_LAB_REG_OFFSET;\n\telse\n\t\tlab_reg += PMI8998_IBB_LAB_REG_OFFSET;\n\n\tsc = qcom_labibb_check_sc_status(vreg);\n\tif (sc)\n\t\tgoto reschedule;\n\n\tfor (i = 0; i < LABIBB_MAX_SC_COUNT; i++) {\n\t\tret = regmap_read(vreg->regmap, lab_reg, &lab_val);\n\t\tif (ret) {\n\t\t\tvreg->fatal_count++;\n\t\t\tgoto reschedule;\n\t\t}\n\n\t\tret = regmap_read(vreg->regmap, ibb_reg, &ibb_val);\n\t\tif (ret) {\n\t\t\tvreg->fatal_count++;\n\t\t\tgoto reschedule;\n\t\t}\n\t\tval = lab_val & ibb_val;\n\n\t\tif (!(val & LABIBB_CONTROL_ENABLE)) {\n\t\t\tpbs_cut = true;\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(5000, 6000);\n\t}\n\tif (pbs_cut)\n\t\tgoto reschedule;\n\n\n\t \n\tret = ops->enable(vreg->rdev);\n\tif (ret)\n\t\tgoto reschedule;\n\n\t \n\tvreg->sc_count = 0;\n\tenable_irq(vreg->sc_irq);\n\treturn;\n\nreschedule:\n\t \n\tvreg->sc_count++;\n\tmod_delayed_work(system_wq, &vreg->sc_recovery_work,\n\t\t\t msecs_to_jiffies(SC_RECOVERY_INTERVAL_MS));\n}\n\n \nstatic irqreturn_t qcom_labibb_sc_isr(int irq, void *chip)\n{\n\tstruct labibb_regulator *vreg = chip;\n\n\tif (vreg->sc_count > LABIBB_MAX_SC_COUNT)\n\t\treturn IRQ_NONE;\n\n\t \n\tdev_warn(vreg->dev, \"Short-Circuit interrupt fired!\\n\");\n\n\t \n\tdisable_irq_nosync(irq);\n\n\t \n\tregulator_notifier_call_chain(vreg->rdev,\n\t\t\t\t      REGULATOR_EVENT_REGULATION_OUT, NULL);\n\n\t \n\tmod_delayed_work(system_highpri_wq, &vreg->sc_recovery_work,\n\t\t\t msecs_to_jiffies(SC_RECOVERY_INTERVAL_MS));\n\treturn IRQ_HANDLED;\n}\n\n\nstatic int qcom_labibb_set_current_limit(struct regulator_dev *rdev,\n\t\t\t\t\t int min_uA, int max_uA)\n{\n\tstruct labibb_regulator *vreg = rdev_get_drvdata(rdev);\n\tstruct regulator_desc *desc = &vreg->desc;\n\tstruct labibb_current_limits *lim = &vreg->uA_limits;\n\tu32 mask, val;\n\tint i, ret, sel = -1;\n\n\tif (min_uA < lim->uA_min || max_uA < lim->uA_min)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < desc->n_current_limits; i++) {\n\t\tint uA_limit = (lim->uA_step * i) + lim->uA_min;\n\n\t\tif (max_uA >= uA_limit && min_uA <= uA_limit)\n\t\t\tsel = i;\n\t}\n\tif (sel < 0)\n\t\treturn -EINVAL;\n\n\t \n\tret = regmap_write(vreg->regmap, vreg->base + REG_LABIBB_SEC_ACCESS,\n\t\t\t   LABIBB_SEC_UNLOCK_CODE);\n\tif (ret)\n\t\treturn ret;\n\n\tmask = desc->csel_mask | lim->ovr_val;\n\tmask |= LABIBB_CURRENT_LIMIT_EN;\n\tval = (u32)sel | lim->ovr_val;\n\tval |= LABIBB_CURRENT_LIMIT_EN;\n\n\treturn regmap_update_bits(vreg->regmap, desc->csel_reg, mask, val);\n}\n\nstatic int qcom_labibb_get_current_limit(struct regulator_dev *rdev)\n{\n\tstruct labibb_regulator *vreg = rdev_get_drvdata(rdev);\n\tstruct regulator_desc *desc = &vreg->desc;\n\tstruct labibb_current_limits *lim = &vreg->uA_limits;\n\tunsigned int cur_step;\n\tint ret;\n\n\tret = regmap_read(vreg->regmap, desc->csel_reg, &cur_step);\n\tif (ret)\n\t\treturn ret;\n\tcur_step &= desc->csel_mask;\n\n\treturn (cur_step * lim->uA_step) + lim->uA_min;\n}\n\nstatic int qcom_labibb_set_soft_start(struct regulator_dev *rdev)\n{\n\tstruct labibb_regulator *vreg = rdev_get_drvdata(rdev);\n\tu32 val = 0;\n\n\tif (vreg->type == QCOM_IBB_TYPE)\n\t\tval = vreg->dischg_sel;\n\telse\n\t\tval = vreg->soft_start_sel;\n\n\treturn regmap_write(rdev->regmap, rdev->desc->soft_start_reg, val);\n}\n\nstatic int qcom_labibb_get_table_sel(const int *table, int sz, u32 value)\n{\n\tint i;\n\n\tfor (i = 0; i < sz; i++)\n\t\tif (table[i] == value)\n\t\t\treturn i;\n\treturn -EINVAL;\n}\n\n \nstatic const int dischg_resistor_values[] = { 300, 64, 32, 16 };\n\n \nstatic const int soft_start_values[] = { 200, 400, 600, 800 };\n\nstatic int qcom_labibb_of_parse_cb(struct device_node *np,\n\t\t\t\t   const struct regulator_desc *desc,\n\t\t\t\t   struct regulator_config *config)\n{\n\tstruct labibb_regulator *vreg = config->driver_data;\n\tu32 dischg_kohms, soft_start_time;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"qcom,discharge-resistor-kohms\",\n\t\t\t\t       &dischg_kohms);\n\tif (ret)\n\t\tdischg_kohms = 300;\n\n\tret = qcom_labibb_get_table_sel(dischg_resistor_values,\n\t\t\t\t\tARRAY_SIZE(dischg_resistor_values),\n\t\t\t\t\tdischg_kohms);\n\tif (ret < 0)\n\t\treturn ret;\n\tvreg->dischg_sel = (u8)ret;\n\n\tret = of_property_read_u32(np, \"qcom,soft-start-us\",\n\t\t\t\t   &soft_start_time);\n\tif (ret)\n\t\tsoft_start_time = 200;\n\n\tret = qcom_labibb_get_table_sel(soft_start_values,\n\t\t\t\t\tARRAY_SIZE(soft_start_values),\n\t\t\t\t\tsoft_start_time);\n\tif (ret < 0)\n\t\treturn ret;\n\tvreg->soft_start_sel = (u8)ret;\n\n\treturn 0;\n}\n\nstatic const struct regulator_ops qcom_labibb_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear,\n\t.map_voltage\t\t= regulator_map_voltage_linear,\n\t.set_active_discharge\t= regulator_set_active_discharge_regmap,\n\t.set_pull_down\t\t= regulator_set_pull_down_regmap,\n\t.set_current_limit\t= qcom_labibb_set_current_limit,\n\t.get_current_limit\t= qcom_labibb_get_current_limit,\n\t.set_soft_start\t\t= qcom_labibb_set_soft_start,\n\t.set_over_current_protection = qcom_labibb_set_ocp,\n};\n\nstatic const struct regulator_desc pmi8998_lab_desc = {\n\t.enable_mask\t\t= LAB_ENABLE_CTL_MASK,\n\t.enable_reg\t\t= (PMI8998_LAB_REG_BASE + REG_LABIBB_ENABLE_CTL),\n\t.enable_val\t\t= LABIBB_CONTROL_ENABLE,\n\t.enable_time\t\t= LAB_ENABLE_TIME,\n\t.poll_enabled_time\t= LABIBB_POLL_ENABLED_TIME,\n\t.soft_start_reg\t\t= (PMI8998_LAB_REG_BASE + REG_LABIBB_SOFT_START_CTL),\n\t.pull_down_reg\t\t= (PMI8998_LAB_REG_BASE + REG_LABIBB_PD_CTL),\n\t.pull_down_mask\t\t= LAB_PD_CTL_MASK,\n\t.pull_down_val_on\t= LAB_PD_CTL_STRONG_PULL,\n\t.vsel_reg\t\t= (PMI8998_LAB_REG_BASE + REG_LABIBB_VOLTAGE),\n\t.vsel_mask\t\t= LAB_VOLTAGE_SET_MASK,\n\t.apply_reg\t\t= (PMI8998_LAB_REG_BASE + REG_LABIBB_VOLTAGE),\n\t.apply_bit\t\t= LABIBB_VOLTAGE_OVERRIDE_EN,\n\t.csel_reg\t\t= (PMI8998_LAB_REG_BASE + REG_LABIBB_CURRENT_LIMIT),\n\t.csel_mask\t\t= LAB_CURRENT_LIMIT_MASK,\n\t.n_current_limits\t= 8,\n\t.off_on_delay\t\t= LABIBB_OFF_ON_DELAY,\n\t.owner\t\t\t= THIS_MODULE,\n\t.type\t\t\t= REGULATOR_VOLTAGE,\n\t.min_uV\t\t\t= 4600000,\n\t.uV_step\t\t= 100000,\n\t.n_voltages\t\t= 16,\n\t.ops\t\t\t= &qcom_labibb_ops,\n\t.of_parse_cb\t\t= qcom_labibb_of_parse_cb,\n};\n\nstatic const struct regulator_desc pmi8998_ibb_desc = {\n\t.enable_mask\t\t= IBB_ENABLE_CTL_MASK,\n\t.enable_reg\t\t= (PMI8998_IBB_REG_BASE + REG_LABIBB_ENABLE_CTL),\n\t.enable_val\t\t= LABIBB_CONTROL_ENABLE,\n\t.enable_time\t\t= IBB_ENABLE_TIME,\n\t.poll_enabled_time\t= LABIBB_POLL_ENABLED_TIME,\n\t.soft_start_reg\t\t= (PMI8998_IBB_REG_BASE + REG_LABIBB_SOFT_START_CTL),\n\t.active_discharge_off\t= 0,\n\t.active_discharge_on\t= IBB_CTL_1_DISCHARGE_EN,\n\t.active_discharge_mask\t= IBB_CTL_1_DISCHARGE_EN,\n\t.active_discharge_reg\t= (PMI8998_IBB_REG_BASE + REG_IBB_PWRUP_PWRDN_CTL_1),\n\t.pull_down_reg\t\t= (PMI8998_IBB_REG_BASE + REG_LABIBB_PD_CTL),\n\t.pull_down_mask\t\t= IBB_PD_CTL_MASK,\n\t.pull_down_val_on\t= IBB_PD_CTL_HALF_STRENGTH | IBB_PD_CTL_EN,\n\t.vsel_reg\t\t= (PMI8998_IBB_REG_BASE + REG_LABIBB_VOLTAGE),\n\t.vsel_mask\t\t= IBB_VOLTAGE_SET_MASK,\n\t.apply_reg\t\t= (PMI8998_IBB_REG_BASE + REG_LABIBB_VOLTAGE),\n\t.apply_bit\t\t= LABIBB_VOLTAGE_OVERRIDE_EN,\n\t.csel_reg\t\t= (PMI8998_IBB_REG_BASE + REG_LABIBB_CURRENT_LIMIT),\n\t.csel_mask\t\t= IBB_CURRENT_LIMIT_MASK,\n\t.n_current_limits\t= 32,\n\t.off_on_delay\t\t= LABIBB_OFF_ON_DELAY,\n\t.owner\t\t\t= THIS_MODULE,\n\t.type\t\t\t= REGULATOR_VOLTAGE,\n\t.min_uV\t\t\t= 1400000,\n\t.uV_step\t\t= 100000,\n\t.n_voltages\t\t= 64,\n\t.ops\t\t\t= &qcom_labibb_ops,\n\t.of_parse_cb\t\t= qcom_labibb_of_parse_cb,\n};\n\nstatic const struct labibb_regulator_data pmi8998_labibb_data[] = {\n\t{\"lab\", QCOM_LAB_TYPE, PMI8998_LAB_REG_BASE, &pmi8998_lab_desc},\n\t{\"ibb\", QCOM_IBB_TYPE, PMI8998_IBB_REG_BASE, &pmi8998_ibb_desc},\n\t{ },\n};\n\nstatic const struct of_device_id qcom_labibb_match[] = {\n\t{ .compatible = \"qcom,pmi8998-lab-ibb\", .data = &pmi8998_labibb_data},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, qcom_labibb_match);\n\nstatic int qcom_labibb_regulator_probe(struct platform_device *pdev)\n{\n\tstruct labibb_regulator *vreg;\n\tstruct device *dev = &pdev->dev;\n\tstruct regulator_config cfg = {};\n\tstruct device_node *reg_node;\n\tconst struct of_device_id *match;\n\tconst struct labibb_regulator_data *reg_data;\n\tstruct regmap *reg_regmap;\n\tunsigned int type;\n\tint ret;\n\n\treg_regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!reg_regmap) {\n\t\tdev_err(&pdev->dev, \"Couldn't get parent's regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmatch = of_match_device(qcom_labibb_match, &pdev->dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tfor (reg_data = match->data; reg_data->name; reg_data++) {\n\t\tchar *sc_irq_name;\n\t\tint irq = 0;\n\n\t\t \n\t\tret = regmap_read(reg_regmap, reg_data->base + REG_PERPH_TYPE,\n\t\t\t\t  &type);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Peripheral type read failed ret=%d\\n\",\n\t\t\t\tret);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (WARN_ON((type != QCOM_LAB_TYPE) && (type != QCOM_IBB_TYPE)) ||\n\t\t    WARN_ON(type != reg_data->type))\n\t\t\treturn -EINVAL;\n\n\t\tvreg  = devm_kzalloc(&pdev->dev, sizeof(*vreg),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!vreg)\n\t\t\treturn -ENOMEM;\n\n\t\tsc_irq_name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t     \"%s-short-circuit\",\n\t\t\t\t\t     reg_data->name);\n\t\tif (!sc_irq_name)\n\t\t\treturn -ENOMEM;\n\n\t\treg_node = of_get_child_by_name(pdev->dev.of_node,\n\t\t\t\t\t\treg_data->name);\n\t\tif (!reg_node)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tirq = of_irq_get_byname(reg_node, \"sc-err\");\n\t\tif (irq <= 0) {\n\t\t\tif (irq == 0)\n\t\t\t\tirq = -EINVAL;\n\n\t\t\tof_node_put(reg_node);\n\t\t\treturn dev_err_probe(vreg->dev, irq,\n\t\t\t\t\t     \"Short-circuit irq not found.\\n\");\n\t\t}\n\t\tvreg->sc_irq = irq;\n\n\t\t \n\t\tirq = of_irq_get_byname(reg_node, \"ocp\");\n\t\tvreg->ocp_irq = irq;\n\t\tvreg->ocp_irq_count = 0;\n\t\tof_node_put(reg_node);\n\n\t\tvreg->regmap = reg_regmap;\n\t\tvreg->dev = dev;\n\t\tvreg->base = reg_data->base;\n\t\tvreg->type = reg_data->type;\n\t\tINIT_DELAYED_WORK(&vreg->sc_recovery_work,\n\t\t\t\t  qcom_labibb_sc_recovery_worker);\n\n\t\tif (vreg->ocp_irq > 0)\n\t\t\tINIT_DELAYED_WORK(&vreg->ocp_recovery_work,\n\t\t\t\t\t  qcom_labibb_ocp_recovery_worker);\n\n\t\tswitch (vreg->type) {\n\t\tcase QCOM_LAB_TYPE:\n\t\t\t \n\t\t\tvreg->uA_limits.uA_min  = 200000;\n\t\t\tvreg->uA_limits.uA_step = 200000;\n\t\t\tvreg->uA_limits.ovr_val = LAB_CURRENT_LIMIT_OVERRIDE_EN;\n\t\t\tbreak;\n\t\tcase QCOM_IBB_TYPE:\n\t\t\t \n\t\t\tvreg->uA_limits.uA_min  = 0;\n\t\t\tvreg->uA_limits.uA_step = 50000;\n\t\t\tvreg->uA_limits.ovr_val = 0;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(&vreg->desc, reg_data->desc, sizeof(vreg->desc));\n\t\tvreg->desc.of_match = reg_data->name;\n\t\tvreg->desc.name = reg_data->name;\n\n\t\tcfg.dev = vreg->dev;\n\t\tcfg.driver_data = vreg;\n\t\tcfg.regmap = vreg->regmap;\n\n\t\tvreg->rdev = devm_regulator_register(vreg->dev, &vreg->desc,\n\t\t\t\t\t\t\t&cfg);\n\n\t\tif (IS_ERR(vreg->rdev)) {\n\t\t\tdev_err(dev, \"qcom_labibb: error registering %s : %d\\n\",\n\t\t\t\t\treg_data->name, ret);\n\t\t\treturn PTR_ERR(vreg->rdev);\n\t\t}\n\n\t\tret = devm_request_threaded_irq(vreg->dev, vreg->sc_irq, NULL,\n\t\t\t\t\t\tqcom_labibb_sc_isr,\n\t\t\t\t\t\tIRQF_ONESHOT |\n\t\t\t\t\t\tIRQF_TRIGGER_RISING,\n\t\t\t\t\t\tsc_irq_name, vreg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver qcom_labibb_regulator_driver = {\n\t.driver\t= {\n\t\t.name = \"qcom-lab-ibb-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table\t= qcom_labibb_match,\n\t},\n\t.probe = qcom_labibb_regulator_probe,\n};\nmodule_platform_driver(qcom_labibb_regulator_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm labibb driver\");\nMODULE_AUTHOR(\"Nisha Kumari <nishakumari@codeaurora.org>\");\nMODULE_AUTHOR(\"Sumit Semwal <sumit.semwal@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}