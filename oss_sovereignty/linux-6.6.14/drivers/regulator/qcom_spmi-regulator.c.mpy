{
  "module_name": "qcom_spmi-regulator.c",
  "hash_id": "0753061aa9178d9bca1d5200c770840f8479b928eca6137562304b51e75550f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/qcom_spmi-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/devm-helpers.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/ktime.h>\n#include <linux/regulator/driver.h>\n#include <linux/regmap.h>\n#include <linux/list.h>\n#include <linux/mfd/syscon.h>\n#include <linux/io.h>\n\n \n#define SPMI_REGULATOR_PIN_CTRL_ENABLE_NONE\t\t0x00\n#define SPMI_REGULATOR_PIN_CTRL_ENABLE_EN0\t\t0x01\n#define SPMI_REGULATOR_PIN_CTRL_ENABLE_EN1\t\t0x02\n#define SPMI_REGULATOR_PIN_CTRL_ENABLE_EN2\t\t0x04\n#define SPMI_REGULATOR_PIN_CTRL_ENABLE_EN3\t\t0x08\n#define SPMI_REGULATOR_PIN_CTRL_ENABLE_HW_DEFAULT\t0x10\n\n \n#define SPMI_REGULATOR_PIN_CTRL_HPM_NONE\t\t0x00\n#define SPMI_REGULATOR_PIN_CTRL_HPM_EN0\t\t\t0x01\n#define SPMI_REGULATOR_PIN_CTRL_HPM_EN1\t\t\t0x02\n#define SPMI_REGULATOR_PIN_CTRL_HPM_EN2\t\t\t0x04\n#define SPMI_REGULATOR_PIN_CTRL_HPM_EN3\t\t\t0x08\n#define SPMI_REGULATOR_PIN_CTRL_HPM_SLEEP_B\t\t0x10\n#define SPMI_REGULATOR_PIN_CTRL_HPM_HW_DEFAULT\t\t0x20\n\n \n#define SPMI_REGULATOR_USE_HW_DEFAULT\t\t\t2\n\n \nenum spmi_vs_soft_start_str {\n\tSPMI_VS_SOFT_START_STR_0P05_UA = 0,\n\tSPMI_VS_SOFT_START_STR_0P25_UA,\n\tSPMI_VS_SOFT_START_STR_0P55_UA,\n\tSPMI_VS_SOFT_START_STR_0P75_UA,\n\tSPMI_VS_SOFT_START_STR_HW_DEFAULT,\n};\n\n \nstruct spmi_regulator_init_data {\n\tunsigned\t\t\t\tpin_ctrl_enable;\n\tunsigned\t\t\t\tpin_ctrl_hpm;\n\tenum spmi_vs_soft_start_str\t\tvs_soft_start_strength;\n};\n\n \nenum spmi_regulator_logical_type {\n\tSPMI_REGULATOR_LOGICAL_TYPE_SMPS,\n\tSPMI_REGULATOR_LOGICAL_TYPE_LDO,\n\tSPMI_REGULATOR_LOGICAL_TYPE_VS,\n\tSPMI_REGULATOR_LOGICAL_TYPE_BOOST,\n\tSPMI_REGULATOR_LOGICAL_TYPE_FTSMPS,\n\tSPMI_REGULATOR_LOGICAL_TYPE_BOOST_BYP,\n\tSPMI_REGULATOR_LOGICAL_TYPE_LN_LDO,\n\tSPMI_REGULATOR_LOGICAL_TYPE_ULT_LO_SMPS,\n\tSPMI_REGULATOR_LOGICAL_TYPE_ULT_HO_SMPS,\n\tSPMI_REGULATOR_LOGICAL_TYPE_ULT_LDO,\n\tSPMI_REGULATOR_LOGICAL_TYPE_FTSMPS426,\n\tSPMI_REGULATOR_LOGICAL_TYPE_HFS430,\n\tSPMI_REGULATOR_LOGICAL_TYPE_FTSMPS3,\n\tSPMI_REGULATOR_LOGICAL_TYPE_LDO_510,\n\tSPMI_REGULATOR_LOGICAL_TYPE_HFSMPS,\n};\n\nenum spmi_regulator_type {\n\tSPMI_REGULATOR_TYPE_BUCK\t\t= 0x03,\n\tSPMI_REGULATOR_TYPE_LDO\t\t\t= 0x04,\n\tSPMI_REGULATOR_TYPE_VS\t\t\t= 0x05,\n\tSPMI_REGULATOR_TYPE_BOOST\t\t= 0x1b,\n\tSPMI_REGULATOR_TYPE_FTS\t\t\t= 0x1c,\n\tSPMI_REGULATOR_TYPE_BOOST_BYP\t\t= 0x1f,\n\tSPMI_REGULATOR_TYPE_ULT_LDO\t\t= 0x21,\n\tSPMI_REGULATOR_TYPE_ULT_BUCK\t\t= 0x22,\n};\n\nenum spmi_regulator_subtype {\n\tSPMI_REGULATOR_SUBTYPE_GP_CTL\t\t= 0x08,\n\tSPMI_REGULATOR_SUBTYPE_RF_CTL\t\t= 0x09,\n\tSPMI_REGULATOR_SUBTYPE_N50\t\t= 0x01,\n\tSPMI_REGULATOR_SUBTYPE_N150\t\t= 0x02,\n\tSPMI_REGULATOR_SUBTYPE_N300\t\t= 0x03,\n\tSPMI_REGULATOR_SUBTYPE_N600\t\t= 0x04,\n\tSPMI_REGULATOR_SUBTYPE_N1200\t\t= 0x05,\n\tSPMI_REGULATOR_SUBTYPE_N600_ST\t\t= 0x06,\n\tSPMI_REGULATOR_SUBTYPE_N1200_ST\t\t= 0x07,\n\tSPMI_REGULATOR_SUBTYPE_N900_ST\t\t= 0x14,\n\tSPMI_REGULATOR_SUBTYPE_N300_ST\t\t= 0x15,\n\tSPMI_REGULATOR_SUBTYPE_P50\t\t= 0x08,\n\tSPMI_REGULATOR_SUBTYPE_P150\t\t= 0x09,\n\tSPMI_REGULATOR_SUBTYPE_P300\t\t= 0x0a,\n\tSPMI_REGULATOR_SUBTYPE_P600\t\t= 0x0b,\n\tSPMI_REGULATOR_SUBTYPE_P1200\t\t= 0x0c,\n\tSPMI_REGULATOR_SUBTYPE_LN\t\t= 0x10,\n\tSPMI_REGULATOR_SUBTYPE_LV_P50\t\t= 0x28,\n\tSPMI_REGULATOR_SUBTYPE_LV_P150\t\t= 0x29,\n\tSPMI_REGULATOR_SUBTYPE_LV_P300\t\t= 0x2a,\n\tSPMI_REGULATOR_SUBTYPE_LV_P600\t\t= 0x2b,\n\tSPMI_REGULATOR_SUBTYPE_LV_P1200\t\t= 0x2c,\n\tSPMI_REGULATOR_SUBTYPE_LV_P450\t\t= 0x2d,\n\tSPMI_REGULATOR_SUBTYPE_HT_N300_ST\t= 0x30,\n\tSPMI_REGULATOR_SUBTYPE_HT_N600_ST\t= 0x31,\n\tSPMI_REGULATOR_SUBTYPE_HT_N1200_ST\t= 0x32,\n\tSPMI_REGULATOR_SUBTYPE_HT_LVP150\t= 0x3b,\n\tSPMI_REGULATOR_SUBTYPE_HT_LVP300\t= 0x3c,\n\tSPMI_REGULATOR_SUBTYPE_L660_N300_ST\t= 0x42,\n\tSPMI_REGULATOR_SUBTYPE_L660_N600_ST\t= 0x43,\n\tSPMI_REGULATOR_SUBTYPE_L660_P50\t\t= 0x46,\n\tSPMI_REGULATOR_SUBTYPE_L660_P150\t= 0x47,\n\tSPMI_REGULATOR_SUBTYPE_L660_P600\t= 0x49,\n\tSPMI_REGULATOR_SUBTYPE_L660_LVP150\t= 0x4d,\n\tSPMI_REGULATOR_SUBTYPE_L660_LVP600\t= 0x4f,\n\tSPMI_REGULATOR_SUBTYPE_LV100\t\t= 0x01,\n\tSPMI_REGULATOR_SUBTYPE_LV300\t\t= 0x02,\n\tSPMI_REGULATOR_SUBTYPE_MV300\t\t= 0x08,\n\tSPMI_REGULATOR_SUBTYPE_MV500\t\t= 0x09,\n\tSPMI_REGULATOR_SUBTYPE_HDMI\t\t= 0x10,\n\tSPMI_REGULATOR_SUBTYPE_OTG\t\t= 0x11,\n\tSPMI_REGULATOR_SUBTYPE_5V_BOOST\t\t= 0x01,\n\tSPMI_REGULATOR_SUBTYPE_FTS_CTL\t\t= 0x08,\n\tSPMI_REGULATOR_SUBTYPE_FTS2p5_CTL\t= 0x09,\n\tSPMI_REGULATOR_SUBTYPE_FTS426_CTL\t= 0x0a,\n\tSPMI_REGULATOR_SUBTYPE_BB_2A\t\t= 0x01,\n\tSPMI_REGULATOR_SUBTYPE_ULT_HF_CTL1\t= 0x0d,\n\tSPMI_REGULATOR_SUBTYPE_ULT_HF_CTL2\t= 0x0e,\n\tSPMI_REGULATOR_SUBTYPE_ULT_HF_CTL3\t= 0x0f,\n\tSPMI_REGULATOR_SUBTYPE_ULT_HF_CTL4\t= 0x10,\n\tSPMI_REGULATOR_SUBTYPE_HFS430\t\t= 0x0a,\n\tSPMI_REGULATOR_SUBTYPE_HT_P150\t\t= 0x35,\n\tSPMI_REGULATOR_SUBTYPE_HT_P600\t\t= 0x3d,\n\tSPMI_REGULATOR_SUBTYPE_HFSMPS_510\t= 0x0a,\n\tSPMI_REGULATOR_SUBTYPE_FTSMPS_510\t= 0x0b,\n\tSPMI_REGULATOR_SUBTYPE_LV_P150_510\t= 0x71,\n\tSPMI_REGULATOR_SUBTYPE_LV_P300_510\t= 0x72,\n\tSPMI_REGULATOR_SUBTYPE_LV_P600_510\t= 0x73,\n\tSPMI_REGULATOR_SUBTYPE_N300_510\t\t= 0x6a,\n\tSPMI_REGULATOR_SUBTYPE_N600_510\t\t= 0x6b,\n\tSPMI_REGULATOR_SUBTYPE_N1200_510\t= 0x6c,\n\tSPMI_REGULATOR_SUBTYPE_MV_P50_510\t= 0x7a,\n\tSPMI_REGULATOR_SUBTYPE_MV_P150_510\t= 0x7b,\n\tSPMI_REGULATOR_SUBTYPE_MV_P600_510\t= 0x7d,\n};\n\nenum spmi_common_regulator_registers {\n\tSPMI_COMMON_REG_DIG_MAJOR_REV\t\t= 0x01,\n\tSPMI_COMMON_REG_TYPE\t\t\t= 0x04,\n\tSPMI_COMMON_REG_SUBTYPE\t\t\t= 0x05,\n\tSPMI_COMMON_REG_VOLTAGE_RANGE\t\t= 0x40,\n\tSPMI_COMMON_REG_VOLTAGE_SET\t\t= 0x41,\n\tSPMI_COMMON_REG_MODE\t\t\t= 0x45,\n\tSPMI_COMMON_REG_ENABLE\t\t\t= 0x46,\n\tSPMI_COMMON_REG_PULL_DOWN\t\t= 0x48,\n\tSPMI_COMMON_REG_SOFT_START\t\t= 0x4c,\n\tSPMI_COMMON_REG_STEP_CTRL\t\t= 0x61,\n};\n\n \nenum spmi_ftsmps426_regulator_registers {\n\tSPMI_FTSMPS426_REG_VOLTAGE_LSB\t\t= 0x40,\n\tSPMI_FTSMPS426_REG_VOLTAGE_MSB\t\t= 0x41,\n\tSPMI_FTSMPS426_REG_VOLTAGE_ULS_LSB\t= 0x68,\n\tSPMI_FTSMPS426_REG_VOLTAGE_ULS_MSB\t= 0x69,\n};\n\n \nenum spmi_hfsmps_regulator_registers {\n\tSPMI_HFSMPS_REG_STEP_CTRL\t\t= 0x3c,\n\tSPMI_HFSMPS_REG_PULL_DOWN\t\t= 0xa0,\n};\n\nenum spmi_vs_registers {\n\tSPMI_VS_REG_OCP\t\t\t\t= 0x4a,\n\tSPMI_VS_REG_SOFT_START\t\t\t= 0x4c,\n};\n\nenum spmi_boost_registers {\n\tSPMI_BOOST_REG_CURRENT_LIMIT\t\t= 0x4a,\n};\n\nenum spmi_boost_byp_registers {\n\tSPMI_BOOST_BYP_REG_CURRENT_LIMIT\t= 0x4b,\n};\n\nenum spmi_saw3_registers {\n\tSAW3_SECURE\t\t\t\t= 0x00,\n\tSAW3_ID\t\t\t\t\t= 0x04,\n\tSAW3_SPM_STS\t\t\t\t= 0x0C,\n\tSAW3_AVS_STS\t\t\t\t= 0x10,\n\tSAW3_PMIC_STS\t\t\t\t= 0x14,\n\tSAW3_RST\t\t\t\t= 0x18,\n\tSAW3_VCTL\t\t\t\t= 0x1C,\n\tSAW3_AVS_CTL\t\t\t\t= 0x20,\n\tSAW3_AVS_LIMIT\t\t\t\t= 0x24,\n\tSAW3_AVS_DLY\t\t\t\t= 0x28,\n\tSAW3_AVS_HYSTERESIS\t\t\t= 0x2C,\n\tSAW3_SPM_STS2\t\t\t\t= 0x38,\n\tSAW3_SPM_PMIC_DATA_3\t\t\t= 0x4C,\n\tSAW3_VERSION\t\t\t\t= 0xFD0,\n};\n\n \nenum spmi_common_control_register_index {\n\tSPMI_COMMON_IDX_VOLTAGE_RANGE\t\t= 0,\n\tSPMI_COMMON_IDX_VOLTAGE_SET\t\t= 1,\n\tSPMI_COMMON_IDX_MODE\t\t\t= 5,\n\tSPMI_COMMON_IDX_ENABLE\t\t\t= 6,\n};\n\n \n#define SPMI_COMMON_ENABLE_MASK\t\t\t0x80\n#define SPMI_COMMON_ENABLE\t\t\t0x80\n#define SPMI_COMMON_DISABLE\t\t\t0x00\n#define SPMI_COMMON_ENABLE_FOLLOW_HW_EN3_MASK\t0x08\n#define SPMI_COMMON_ENABLE_FOLLOW_HW_EN2_MASK\t0x04\n#define SPMI_COMMON_ENABLE_FOLLOW_HW_EN1_MASK\t0x02\n#define SPMI_COMMON_ENABLE_FOLLOW_HW_EN0_MASK\t0x01\n#define SPMI_COMMON_ENABLE_FOLLOW_ALL_MASK\t0x0f\n\n \n#define SPMI_COMMON_MODE_HPM_MASK\t\t0x80\n#define SPMI_COMMON_MODE_AUTO_MASK\t\t0x40\n#define SPMI_COMMON_MODE_BYPASS_MASK\t\t0x20\n#define SPMI_COMMON_MODE_FOLLOW_AWAKE_MASK\t0x10\n#define SPMI_COMMON_MODE_FOLLOW_HW_EN3_MASK\t0x08\n#define SPMI_COMMON_MODE_FOLLOW_HW_EN2_MASK\t0x04\n#define SPMI_COMMON_MODE_FOLLOW_HW_EN1_MASK\t0x02\n#define SPMI_COMMON_MODE_FOLLOW_HW_EN0_MASK\t0x01\n#define SPMI_COMMON_MODE_FOLLOW_ALL_MASK\t0x1f\n\n#define SPMI_FTSMPS426_MODE_BYPASS_MASK\t\t3\n#define SPMI_FTSMPS426_MODE_RETENTION_MASK\t4\n#define SPMI_FTSMPS426_MODE_LPM_MASK\t\t5\n#define SPMI_FTSMPS426_MODE_AUTO_MASK\t\t6\n#define SPMI_FTSMPS426_MODE_HPM_MASK\t\t7\n\n#define SPMI_FTSMPS426_MODE_MASK\t\t0x07\n\n \n#define SPMI_HFSMPS_MODE_BYPASS_MASK\t\t2\n#define SPMI_HFSMPS_MODE_RETENTION_MASK\t\t3\n#define SPMI_HFSMPS_MODE_LPM_MASK\t\t4\n#define SPMI_HFSMPS_MODE_AUTO_MASK\t\t6\n#define SPMI_HFSMPS_MODE_HPM_MASK\t\t7\n\n#define SPMI_HFSMPS_MODE_MASK\t\t\t0x07\n\n \n#define SPMI_COMMON_PULL_DOWN_ENABLE_MASK\t0x80\n\n \n#define SPMI_LDO_CURRENT_LIMIT_ENABLE_MASK\t0x80\n\n \n#define SPMI_LDO_SOFT_START_ENABLE_MASK\t\t0x80\n\n \n#define SPMI_VS_OCP_OVERRIDE\t\t\t0x01\n#define SPMI_VS_OCP_NO_OVERRIDE\t\t\t0x00\n\n \n#define SPMI_VS_SOFT_START_ENABLE_MASK\t\t0x80\n#define SPMI_VS_SOFT_START_SEL_MASK\t\t0x03\n\n \n#define SPMI_BOOST_CURRENT_LIMIT_ENABLE_MASK\t0x80\n#define SPMI_BOOST_CURRENT_LIMIT_MASK\t\t0x07\n\n#define SPMI_VS_OCP_DEFAULT_MAX_RETRIES\t\t10\n#define SPMI_VS_OCP_DEFAULT_RETRY_DELAY_MS\t30\n#define SPMI_VS_OCP_FALL_DELAY_US\t\t90\n#define SPMI_VS_OCP_FAULT_DELAY_US\t\t20000\n\n#define SPMI_FTSMPS_STEP_CTRL_STEP_MASK\t\t0x18\n#define SPMI_FTSMPS_STEP_CTRL_STEP_SHIFT\t3\n#define SPMI_FTSMPS_STEP_CTRL_DELAY_MASK\t0x07\n#define SPMI_FTSMPS_STEP_CTRL_DELAY_SHIFT\t0\n\n \n#define SPMI_FTSMPS_CLOCK_RATE\t\t19200\n\n \n#define SPMI_FTSMPS_STEP_DELAY\t\t8\n#define SPMI_DEFAULT_STEP_DELAY\t\t20\n\n \n#define SPMI_FTSMPS_STEP_MARGIN_NUM\t4\n#define SPMI_FTSMPS_STEP_MARGIN_DEN\t5\n\n \n#define SPMI_HFSMPS_SLEW_RATE_38p4 38400\n\n#define SPMI_FTSMPS426_STEP_CTRL_DELAY_MASK\t0x03\n#define SPMI_FTSMPS426_STEP_CTRL_DELAY_SHIFT\t0\n\n \n#define SPMI_FTSMPS426_CLOCK_RATE\t\t4800\n\n#define SPMI_HFS430_CLOCK_RATE\t\t\t1600\n\n \n#define SPMI_FTSMPS426_STEP_DELAY\t\t2\n\n \n#define SPMI_FTSMPS426_STEP_MARGIN_NUM\t10\n#define SPMI_FTSMPS426_STEP_MARGIN_DEN\t11\n\n\n \n#define ULT_SMPS_RANGE_SPLIT 0x60\n\n \nstruct spmi_voltage_range {\n\tint\t\t\t\t\tmin_uV;\n\tint\t\t\t\t\tmax_uV;\n\tint\t\t\t\t\tstep_uV;\n\tint\t\t\t\t\tset_point_min_uV;\n\tint\t\t\t\t\tset_point_max_uV;\n\tunsigned\t\t\t\tn_voltages;\n\tu8\t\t\t\t\trange_sel;\n};\n\n \nstruct spmi_voltage_set_points {\n\tstruct spmi_voltage_range\t\t*range;\n\tint\t\t\t\t\tcount;\n\tunsigned\t\t\t\tn_voltages;\n};\n\nstruct spmi_regulator {\n\tstruct regulator_desc\t\t\tdesc;\n\tstruct device\t\t\t\t*dev;\n\tstruct delayed_work\t\t\tocp_work;\n\tstruct regmap\t\t\t\t*regmap;\n\tstruct spmi_voltage_set_points\t\t*set_points;\n\tenum spmi_regulator_logical_type\tlogical_type;\n\tint\t\t\t\t\tocp_irq;\n\tint\t\t\t\t\tocp_count;\n\tint\t\t\t\t\tocp_max_retries;\n\tint\t\t\t\t\tocp_retry_delay_ms;\n\tint\t\t\t\t\thpm_min_load;\n\tint\t\t\t\t\tslew_rate;\n\tktime_t\t\t\t\t\tvs_enable_time;\n\tu16\t\t\t\t\tbase;\n\tstruct list_head\t\t\tnode;\n};\n\nstruct spmi_regulator_mapping {\n\tenum spmi_regulator_type\t\ttype;\n\tenum spmi_regulator_subtype\t\tsubtype;\n\tenum spmi_regulator_logical_type\tlogical_type;\n\tu32\t\t\t\t\trevision_min;\n\tu32\t\t\t\t\trevision_max;\n\tconst struct regulator_ops\t\t*ops;\n\tstruct spmi_voltage_set_points\t\t*set_points;\n\tint\t\t\t\t\thpm_min_load;\n};\n\nstruct spmi_regulator_data {\n\tconst char\t\t\t*name;\n\tu16\t\t\t\tbase;\n\tconst char\t\t\t*supply;\n\tconst char\t\t\t*ocp;\n\tu16\t\t\t\tforce_type;\n};\n\n#define SPMI_VREG(_type, _subtype, _dig_major_min, _dig_major_max, \\\n\t\t      _logical_type, _ops_val, _set_points_val, _hpm_min_load) \\\n\t{ \\\n\t\t.type\t\t= SPMI_REGULATOR_TYPE_##_type, \\\n\t\t.subtype\t= SPMI_REGULATOR_SUBTYPE_##_subtype, \\\n\t\t.revision_min\t= _dig_major_min, \\\n\t\t.revision_max\t= _dig_major_max, \\\n\t\t.logical_type\t= SPMI_REGULATOR_LOGICAL_TYPE_##_logical_type, \\\n\t\t.ops\t\t= &spmi_##_ops_val##_ops, \\\n\t\t.set_points\t= &_set_points_val##_set_points, \\\n\t\t.hpm_min_load\t= _hpm_min_load, \\\n\t}\n\n#define SPMI_VREG_VS(_subtype, _dig_major_min, _dig_major_max) \\\n\t{ \\\n\t\t.type\t\t= SPMI_REGULATOR_TYPE_VS, \\\n\t\t.subtype\t= SPMI_REGULATOR_SUBTYPE_##_subtype, \\\n\t\t.revision_min\t= _dig_major_min, \\\n\t\t.revision_max\t= _dig_major_max, \\\n\t\t.logical_type\t= SPMI_REGULATOR_LOGICAL_TYPE_VS, \\\n\t\t.ops\t\t= &spmi_vs_ops, \\\n\t}\n\n#define SPMI_VOLTAGE_RANGE(_range_sel, _min_uV, _set_point_min_uV, \\\n\t\t\t_set_point_max_uV, _max_uV, _step_uV) \\\n\t{ \\\n\t\t.min_uV\t\t\t= _min_uV, \\\n\t\t.max_uV\t\t\t= _max_uV, \\\n\t\t.set_point_min_uV\t= _set_point_min_uV, \\\n\t\t.set_point_max_uV\t= _set_point_max_uV, \\\n\t\t.step_uV\t\t= _step_uV, \\\n\t\t.range_sel\t\t= _range_sel, \\\n\t}\n\n#define DEFINE_SPMI_SET_POINTS(name) \\\nstruct spmi_voltage_set_points name##_set_points = { \\\n\t.range\t= name##_ranges, \\\n\t.count\t= ARRAY_SIZE(name##_ranges), \\\n}\n\n \nstatic struct spmi_voltage_range pldo_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(2,  750000,  750000, 1537500, 1537500, 12500),\n\tSPMI_VOLTAGE_RANGE(3, 1500000, 1550000, 3075000, 3075000, 25000),\n\tSPMI_VOLTAGE_RANGE(4, 1750000, 3100000, 4900000, 4900000, 50000),\n};\n\nstatic struct spmi_voltage_range nldo1_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(2,  750000,  750000, 1537500, 1537500, 12500),\n};\n\nstatic struct spmi_voltage_range nldo2_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0,  375000,       0,       0, 1537500, 12500),\n\tSPMI_VOLTAGE_RANGE(1,  375000,  375000,  768750,  768750,  6250),\n\tSPMI_VOLTAGE_RANGE(2,  750000,  775000, 1537500, 1537500, 12500),\n};\n\nstatic struct spmi_voltage_range nldo3_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0,  375000,  375000, 1537500, 1537500, 12500),\n\tSPMI_VOLTAGE_RANGE(1,  375000,       0,       0, 1537500, 12500),\n\tSPMI_VOLTAGE_RANGE(2,  750000,       0,       0, 1537500, 12500),\n};\n\nstatic struct spmi_voltage_range ln_ldo_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(1,  690000,  690000, 1110000, 1110000, 60000),\n\tSPMI_VOLTAGE_RANGE(0, 1380000, 1380000, 2220000, 2220000, 120000),\n};\n\nstatic struct spmi_voltage_range smps_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0,  375000,  375000, 1562500, 1562500, 12500),\n\tSPMI_VOLTAGE_RANGE(1, 1550000, 1575000, 3125000, 3125000, 25000),\n};\n\nstatic struct spmi_voltage_range ftsmps_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0,       0,  350000, 1275000, 1275000,  5000),\n\tSPMI_VOLTAGE_RANGE(1,       0, 1280000, 2040000, 2040000, 10000),\n};\n\nstatic struct spmi_voltage_range ftsmps2p5_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0,   80000,  350000, 1355000, 1355000,  5000),\n\tSPMI_VOLTAGE_RANGE(1,  160000, 1360000, 2200000, 2200000, 10000),\n};\n\nstatic struct spmi_voltage_range ftsmps426_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0,       0,  320000, 1352000, 1352000,  4000),\n};\n\nstatic struct spmi_voltage_range boost_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0, 4000000, 4000000, 5550000, 5550000, 50000),\n};\n\nstatic struct spmi_voltage_range boost_byp_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0, 2500000, 2500000, 5200000, 5650000, 50000),\n};\n\nstatic struct spmi_voltage_range ult_lo_smps_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0,  375000,  375000, 1562500, 1562500, 12500),\n\tSPMI_VOLTAGE_RANGE(1,  750000,       0,       0, 1525000, 25000),\n};\n\nstatic struct spmi_voltage_range ult_ho_smps_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0, 1550000, 1550000, 2325000, 2325000, 25000),\n};\n\nstatic struct spmi_voltage_range ult_nldo_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0,  375000,  375000, 1537500, 1537500, 12500),\n};\n\nstatic struct spmi_voltage_range ult_pldo_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0, 1750000, 1750000, 3337500, 3337500, 12500),\n};\n\nstatic struct spmi_voltage_range pldo660_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0, 1504000, 1504000, 3544000, 3544000, 8000),\n};\n\nstatic struct spmi_voltage_range nldo660_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0,  320000,  320000, 1304000, 1304000, 8000),\n};\n\nstatic struct spmi_voltage_range ht_lvpldo_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0, 1504000, 1504000, 2000000, 2000000, 8000),\n};\n\nstatic struct spmi_voltage_range ht_nldo_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0,  312000,  312000, 1304000, 1304000, 8000),\n};\n\nstatic struct spmi_voltage_range hfs430_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0, 320000, 320000, 2040000, 2040000, 8000),\n};\n\nstatic struct spmi_voltage_range ht_p150_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0, 1616000, 1616000, 3304000, 3304000, 8000),\n};\n\nstatic struct spmi_voltage_range ht_p600_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0, 1704000, 1704000, 1896000, 1896000, 8000),\n};\n\nstatic struct spmi_voltage_range nldo_510_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0, 320000, 320000, 1304000, 1304000, 8000),\n};\n\nstatic struct spmi_voltage_range ftsmps510_ranges[] = {\n\tSPMI_VOLTAGE_RANGE(0, 300000, 300000, 1372000, 1372000, 4000),\n};\n\nstatic DEFINE_SPMI_SET_POINTS(pldo);\nstatic DEFINE_SPMI_SET_POINTS(nldo1);\nstatic DEFINE_SPMI_SET_POINTS(nldo2);\nstatic DEFINE_SPMI_SET_POINTS(nldo3);\nstatic DEFINE_SPMI_SET_POINTS(ln_ldo);\nstatic DEFINE_SPMI_SET_POINTS(smps);\nstatic DEFINE_SPMI_SET_POINTS(ftsmps);\nstatic DEFINE_SPMI_SET_POINTS(ftsmps2p5);\nstatic DEFINE_SPMI_SET_POINTS(ftsmps426);\nstatic DEFINE_SPMI_SET_POINTS(boost);\nstatic DEFINE_SPMI_SET_POINTS(boost_byp);\nstatic DEFINE_SPMI_SET_POINTS(ult_lo_smps);\nstatic DEFINE_SPMI_SET_POINTS(ult_ho_smps);\nstatic DEFINE_SPMI_SET_POINTS(ult_nldo);\nstatic DEFINE_SPMI_SET_POINTS(ult_pldo);\nstatic DEFINE_SPMI_SET_POINTS(pldo660);\nstatic DEFINE_SPMI_SET_POINTS(nldo660);\nstatic DEFINE_SPMI_SET_POINTS(ht_lvpldo);\nstatic DEFINE_SPMI_SET_POINTS(ht_nldo);\nstatic DEFINE_SPMI_SET_POINTS(hfs430);\nstatic DEFINE_SPMI_SET_POINTS(ht_p150);\nstatic DEFINE_SPMI_SET_POINTS(ht_p600);\nstatic DEFINE_SPMI_SET_POINTS(nldo_510);\nstatic DEFINE_SPMI_SET_POINTS(ftsmps510);\n\nstatic inline int spmi_vreg_read(struct spmi_regulator *vreg, u16 addr, u8 *buf,\n\t\t\t\t int len)\n{\n\treturn regmap_bulk_read(vreg->regmap, vreg->base + addr, buf, len);\n}\n\nstatic inline int spmi_vreg_write(struct spmi_regulator *vreg, u16 addr,\n\t\t\t\tu8 *buf, int len)\n{\n\treturn regmap_bulk_write(vreg->regmap, vreg->base + addr, buf, len);\n}\n\nstatic int spmi_vreg_update_bits(struct spmi_regulator *vreg, u16 addr, u8 val,\n\t\tu8 mask)\n{\n\treturn regmap_update_bits(vreg->regmap, vreg->base + addr, mask, val);\n}\n\nstatic int spmi_regulator_vs_enable(struct regulator_dev *rdev)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\n\tif (vreg->ocp_irq) {\n\t\tvreg->ocp_count = 0;\n\t\tvreg->vs_enable_time = ktime_get();\n\t}\n\n\treturn regulator_enable_regmap(rdev);\n}\n\nstatic int spmi_regulator_vs_ocp(struct regulator_dev *rdev, int lim_uA,\n\t\t\t\t int severity, bool enable)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tu8 reg = SPMI_VS_OCP_OVERRIDE;\n\n\tif (lim_uA || !enable || severity != REGULATOR_SEVERITY_PROT)\n\t\treturn -EINVAL;\n\n\treturn spmi_vreg_write(vreg, SPMI_VS_REG_OCP, &reg, 1);\n}\n\nstatic int spmi_regulator_select_voltage(struct spmi_regulator *vreg,\n\t\t\t\t\t int min_uV, int max_uV)\n{\n\tconst struct spmi_voltage_range *range;\n\tint uV = min_uV;\n\tint lim_min_uV, lim_max_uV, i, range_id, range_max_uV;\n\tint selector, voltage_sel;\n\n\t \n\tlim_min_uV = vreg->set_points->range[0].set_point_min_uV;\n\tlim_max_uV =\n\t  vreg->set_points->range[vreg->set_points->count - 1].set_point_max_uV;\n\n\tif (uV < lim_min_uV && max_uV >= lim_min_uV)\n\t\tuV = lim_min_uV;\n\n\tif (uV < lim_min_uV || uV > lim_max_uV) {\n\t\tdev_err(vreg->dev,\n\t\t\t\"request v=[%d, %d] is outside possible v=[%d, %d]\\n\",\n\t\t\t min_uV, max_uV, lim_min_uV, lim_max_uV);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = vreg->set_points->count - 1; i > 0; i--) {\n\t\trange_max_uV = vreg->set_points->range[i - 1].set_point_max_uV;\n\t\tif (uV > range_max_uV && range_max_uV > 0)\n\t\t\tbreak;\n\t}\n\n\trange_id = i;\n\trange = &vreg->set_points->range[range_id];\n\n\t \n\tvoltage_sel = DIV_ROUND_UP(uV - range->min_uV, range->step_uV);\n\tuV = voltage_sel * range->step_uV + range->min_uV;\n\n\tif (uV > max_uV) {\n\t\tdev_err(vreg->dev,\n\t\t\t\"request v=[%d, %d] cannot be met by any set point; \"\n\t\t\t\"next set point: %d\\n\",\n\t\t\tmin_uV, max_uV, uV);\n\t\treturn -EINVAL;\n\t}\n\n\tselector = 0;\n\tfor (i = 0; i < range_id; i++)\n\t\tselector += vreg->set_points->range[i].n_voltages;\n\tselector += (uV - range->set_point_min_uV) / range->step_uV;\n\n\treturn selector;\n}\n\nstatic int spmi_sw_selector_to_hw(struct spmi_regulator *vreg,\n\t\t\t\t  unsigned selector, u8 *range_sel,\n\t\t\t\t  u8 *voltage_sel)\n{\n\tconst struct spmi_voltage_range *range, *end;\n\tunsigned offset;\n\n\trange = vreg->set_points->range;\n\tend = range + vreg->set_points->count;\n\n\tfor (; range < end; range++) {\n\t\tif (selector < range->n_voltages) {\n\t\t\t \n\t\t\toffset = range->set_point_min_uV - range->min_uV;\n\t\t\toffset /= range->step_uV;\n\t\t\t*voltage_sel = selector + offset;\n\t\t\t*range_sel = range->range_sel;\n\t\t\treturn 0;\n\t\t}\n\n\t\tselector -= range->n_voltages;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int spmi_hw_selector_to_sw(struct spmi_regulator *vreg, u8 hw_sel,\n\t\t\t\t  const struct spmi_voltage_range *range)\n{\n\tunsigned sw_sel = 0;\n\tunsigned offset, max_hw_sel;\n\tconst struct spmi_voltage_range *r = vreg->set_points->range;\n\tconst struct spmi_voltage_range *end = r + vreg->set_points->count;\n\n\tfor (; r < end; r++) {\n\t\tif (r == range && range->n_voltages) {\n\t\t\t \n\t\t\toffset = range->set_point_min_uV - range->min_uV;\n\t\t\toffset /= range->step_uV;\n\t\t\tif (hw_sel < offset)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmax_hw_sel = range->set_point_max_uV - range->min_uV;\n\t\t\tmax_hw_sel /= range->step_uV;\n\t\t\tif (hw_sel > max_hw_sel)\n\t\t\t\treturn -EINVAL;\n\n\t\t\treturn sw_sel + hw_sel - offset;\n\t\t}\n\t\tsw_sel += r->n_voltages;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct spmi_voltage_range *\nspmi_regulator_find_range(struct spmi_regulator *vreg)\n{\n\tu8 range_sel;\n\tconst struct spmi_voltage_range *range, *end;\n\n\trange = vreg->set_points->range;\n\tend = range + vreg->set_points->count;\n\n\tspmi_vreg_read(vreg, SPMI_COMMON_REG_VOLTAGE_RANGE, &range_sel, 1);\n\n\tfor (; range < end; range++)\n\t\tif (range->range_sel == range_sel)\n\t\t\treturn range;\n\n\treturn NULL;\n}\n\nstatic int spmi_regulator_select_voltage_same_range(struct spmi_regulator *vreg,\n\t\tint min_uV, int max_uV)\n{\n\tconst struct spmi_voltage_range *range;\n\tint uV = min_uV;\n\tint i, selector;\n\n\trange = spmi_regulator_find_range(vreg);\n\tif (!range)\n\t\tgoto different_range;\n\n\tif (uV < range->min_uV && max_uV >= range->min_uV)\n\t\tuV = range->min_uV;\n\n\tif (uV < range->min_uV || uV > range->max_uV) {\n\t\t \n\t\tgoto different_range;\n\t}\n\n\t \n\tuV = DIV_ROUND_UP(uV - range->min_uV, range->step_uV);\n\tuV = uV * range->step_uV + range->min_uV;\n\n\tif (uV > max_uV) {\n\t\t \n\t\tgoto different_range;\n\t}\n\n\tselector = 0;\n\tfor (i = 0; i < vreg->set_points->count; i++) {\n\t\tif (uV >= vreg->set_points->range[i].set_point_min_uV\n\t\t    && uV <= vreg->set_points->range[i].set_point_max_uV) {\n\t\t\tselector +=\n\t\t\t    (uV - vreg->set_points->range[i].set_point_min_uV)\n\t\t\t\t/ vreg->set_points->range[i].step_uV;\n\t\t\tbreak;\n\t\t}\n\n\t\tselector += vreg->set_points->range[i].n_voltages;\n\t}\n\n\tif (selector >= vreg->set_points->n_voltages)\n\t\tgoto different_range;\n\n\treturn selector;\n\ndifferent_range:\n\treturn spmi_regulator_select_voltage(vreg, min_uV, max_uV);\n}\n\nstatic int spmi_regulator_common_map_voltage(struct regulator_dev *rdev,\n\t\t\t\t\t     int min_uV, int max_uV)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\n\t \n\treturn spmi_regulator_select_voltage_same_range(vreg, min_uV, max_uV);\n}\n\nstatic int\nspmi_regulator_common_set_voltage(struct regulator_dev *rdev, unsigned selector)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tint ret;\n\tu8 buf[2];\n\tu8 range_sel, voltage_sel;\n\n\tret = spmi_sw_selector_to_hw(vreg, selector, &range_sel, &voltage_sel);\n\tif (ret)\n\t\treturn ret;\n\n\tbuf[0] = range_sel;\n\tbuf[1] = voltage_sel;\n\treturn spmi_vreg_write(vreg, SPMI_COMMON_REG_VOLTAGE_RANGE, buf, 2);\n}\n\nstatic int spmi_regulator_common_list_voltage(struct regulator_dev *rdev,\n\t\t\t\t\t      unsigned selector);\n\nstatic int spmi_regulator_ftsmps426_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t\t      unsigned selector)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tu8 buf[2];\n\tint mV;\n\n\tmV = spmi_regulator_common_list_voltage(rdev, selector) / 1000;\n\n\tbuf[0] = mV & 0xff;\n\tbuf[1] = mV >> 8;\n\treturn spmi_vreg_write(vreg, SPMI_FTSMPS426_REG_VOLTAGE_LSB, buf, 2);\n}\n\nstatic int spmi_regulator_set_voltage_time_sel(struct regulator_dev *rdev,\n\t\tunsigned int old_selector, unsigned int new_selector)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tint diff_uV;\n\n\tdiff_uV = abs(spmi_regulator_common_list_voltage(rdev, new_selector) -\n\t\t      spmi_regulator_common_list_voltage(rdev, old_selector));\n\n\treturn DIV_ROUND_UP(diff_uV, vreg->slew_rate);\n}\n\nstatic int spmi_regulator_common_get_voltage(struct regulator_dev *rdev)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tconst struct spmi_voltage_range *range;\n\tu8 voltage_sel;\n\n\tspmi_vreg_read(vreg, SPMI_COMMON_REG_VOLTAGE_SET, &voltage_sel, 1);\n\n\trange = spmi_regulator_find_range(vreg);\n\tif (!range)\n\t\treturn -EINVAL;\n\n\treturn spmi_hw_selector_to_sw(vreg, voltage_sel, range);\n}\n\nstatic int spmi_regulator_ftsmps426_get_voltage(struct regulator_dev *rdev)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tconst struct spmi_voltage_range *range;\n\tu8 buf[2];\n\tint uV;\n\n\tspmi_vreg_read(vreg, SPMI_FTSMPS426_REG_VOLTAGE_LSB, buf, 2);\n\n\tuV = (((unsigned int)buf[1] << 8) | (unsigned int)buf[0]) * 1000;\n\trange = vreg->set_points->range;\n\n\treturn (uV - range->set_point_min_uV) / range->step_uV;\n}\n\nstatic int spmi_regulator_single_map_voltage(struct regulator_dev *rdev,\n\t\tint min_uV, int max_uV)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\n\treturn spmi_regulator_select_voltage(vreg, min_uV, max_uV);\n}\n\nstatic int spmi_regulator_single_range_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t\t\t   unsigned selector)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tu8 sel = selector;\n\n\t \n\treturn spmi_vreg_write(vreg, SPMI_COMMON_REG_VOLTAGE_SET, &sel, 1);\n}\n\nstatic int spmi_regulator_single_range_get_voltage(struct regulator_dev *rdev)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tu8 selector;\n\tint ret;\n\n\tret = spmi_vreg_read(vreg, SPMI_COMMON_REG_VOLTAGE_SET, &selector, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn selector;\n}\n\nstatic int spmi_regulator_ult_lo_smps_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t\t\t  unsigned selector)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tint ret;\n\tu8 range_sel, voltage_sel;\n\n\tret = spmi_sw_selector_to_hw(vreg, selector, &range_sel, &voltage_sel);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (range_sel == 1)\n\t\tvoltage_sel |= ULT_SMPS_RANGE_SPLIT;\n\n\treturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_VOLTAGE_SET,\n\t\t\t\t     voltage_sel, 0xff);\n}\n\nstatic int spmi_regulator_ult_lo_smps_get_voltage(struct regulator_dev *rdev)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tconst struct spmi_voltage_range *range;\n\tu8 voltage_sel;\n\n\tspmi_vreg_read(vreg, SPMI_COMMON_REG_VOLTAGE_SET, &voltage_sel, 1);\n\n\trange = spmi_regulator_find_range(vreg);\n\tif (!range)\n\t\treturn -EINVAL;\n\n\tif (range->range_sel == 1)\n\t\tvoltage_sel &= ~ULT_SMPS_RANGE_SPLIT;\n\n\treturn spmi_hw_selector_to_sw(vreg, voltage_sel, range);\n}\n\nstatic int spmi_regulator_common_list_voltage(struct regulator_dev *rdev,\n\t\t\tunsigned selector)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tint uV = 0;\n\tint i;\n\n\tif (selector >= vreg->set_points->n_voltages)\n\t\treturn 0;\n\n\tfor (i = 0; i < vreg->set_points->count; i++) {\n\t\tif (selector < vreg->set_points->range[i].n_voltages) {\n\t\t\tuV = selector * vreg->set_points->range[i].step_uV\n\t\t\t\t+ vreg->set_points->range[i].set_point_min_uV;\n\t\t\tbreak;\n\t\t}\n\n\t\tselector -= vreg->set_points->range[i].n_voltages;\n\t}\n\n\treturn uV;\n}\n\nstatic int\nspmi_regulator_common_set_bypass(struct regulator_dev *rdev, bool enable)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tu8 mask = SPMI_COMMON_MODE_BYPASS_MASK;\n\tu8 val = 0;\n\n\tif (enable)\n\t\tval = mask;\n\n\treturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_MODE, val, mask);\n}\n\nstatic int\nspmi_regulator_common_get_bypass(struct regulator_dev *rdev, bool *enable)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tu8 val;\n\tint ret;\n\n\tret = spmi_vreg_read(vreg, SPMI_COMMON_REG_MODE, &val, 1);\n\t*enable = val & SPMI_COMMON_MODE_BYPASS_MASK;\n\n\treturn ret;\n}\n\nstatic unsigned int spmi_regulator_common_get_mode(struct regulator_dev *rdev)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tu8 reg;\n\n\tspmi_vreg_read(vreg, SPMI_COMMON_REG_MODE, &reg, 1);\n\n\treg &= SPMI_COMMON_MODE_HPM_MASK | SPMI_COMMON_MODE_AUTO_MASK;\n\n\tswitch (reg) {\n\tcase SPMI_COMMON_MODE_HPM_MASK:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase SPMI_COMMON_MODE_AUTO_MASK:\n\t\treturn REGULATOR_MODE_FAST;\n\tdefault:\n\t\treturn REGULATOR_MODE_IDLE;\n\t}\n}\n\nstatic unsigned int spmi_regulator_ftsmps426_get_mode(struct regulator_dev *rdev)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tu8 reg;\n\n\tspmi_vreg_read(vreg, SPMI_COMMON_REG_MODE, &reg, 1);\n\n\tswitch (reg) {\n\tcase SPMI_FTSMPS426_MODE_HPM_MASK:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase SPMI_FTSMPS426_MODE_AUTO_MASK:\n\t\treturn REGULATOR_MODE_FAST;\n\tdefault:\n\t\treturn REGULATOR_MODE_IDLE;\n\t}\n}\n\nstatic unsigned int spmi_regulator_hfsmps_get_mode(struct regulator_dev *rdev)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tu8 reg;\n\n\tspmi_vreg_read(vreg, SPMI_COMMON_REG_MODE, &reg, 1);\n\n\tswitch (reg) {\n\tcase SPMI_HFSMPS_MODE_HPM_MASK:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase SPMI_HFSMPS_MODE_AUTO_MASK:\n\t\treturn REGULATOR_MODE_FAST;\n\tdefault:\n\t\treturn REGULATOR_MODE_IDLE;\n\t}\n}\n\nstatic int\nspmi_regulator_common_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tu8 mask = SPMI_COMMON_MODE_HPM_MASK | SPMI_COMMON_MODE_AUTO_MASK;\n\tu8 val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = SPMI_COMMON_MODE_HPM_MASK;\n\t\tbreak;\n\tcase REGULATOR_MODE_FAST:\n\t\tval = SPMI_COMMON_MODE_AUTO_MASK;\n\t\tbreak;\n\tdefault:\n\t\tval = 0;\n\t\tbreak;\n\t}\n\n\treturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_MODE, val, mask);\n}\n\nstatic int\nspmi_regulator_ftsmps426_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tu8 mask = SPMI_FTSMPS426_MODE_MASK;\n\tu8 val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = SPMI_FTSMPS426_MODE_HPM_MASK;\n\t\tbreak;\n\tcase REGULATOR_MODE_FAST:\n\t\tval = SPMI_FTSMPS426_MODE_AUTO_MASK;\n\t\tbreak;\n\tcase REGULATOR_MODE_IDLE:\n\t\tval = SPMI_FTSMPS426_MODE_LPM_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_MODE, val, mask);\n}\n\nstatic int\nspmi_regulator_hfsmps_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tu8 mask = SPMI_HFSMPS_MODE_MASK;\n\tu8 val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = SPMI_HFSMPS_MODE_HPM_MASK;\n\t\tbreak;\n\tcase REGULATOR_MODE_FAST:\n\t\tval = SPMI_HFSMPS_MODE_AUTO_MASK;\n\t\tbreak;\n\tcase REGULATOR_MODE_IDLE:\n\t\tval = vreg->logical_type ==\n\t\t\t\tSPMI_REGULATOR_LOGICAL_TYPE_FTSMPS3 ?\n\t\t\tSPMI_HFSMPS_MODE_RETENTION_MASK :\n\t\t\tSPMI_HFSMPS_MODE_LPM_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_MODE, val, mask);\n}\n\nstatic int\nspmi_regulator_common_set_load(struct regulator_dev *rdev, int load_uA)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tunsigned int mode;\n\n\tif (load_uA >= vreg->hpm_min_load)\n\t\tmode = REGULATOR_MODE_NORMAL;\n\telse\n\t\tmode = REGULATOR_MODE_IDLE;\n\n\treturn spmi_regulator_common_set_mode(rdev, mode);\n}\n\nstatic int spmi_regulator_common_set_pull_down(struct regulator_dev *rdev)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tunsigned int mask = SPMI_COMMON_PULL_DOWN_ENABLE_MASK;\n\n\treturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_PULL_DOWN,\n\t\t\t\t     mask, mask);\n}\n\nstatic int spmi_regulator_hfsmps_set_pull_down(struct regulator_dev *rdev)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tunsigned int mask = SPMI_COMMON_PULL_DOWN_ENABLE_MASK;\n\n\treturn spmi_vreg_update_bits(vreg, SPMI_HFSMPS_REG_PULL_DOWN,\n\t\t\t\t     mask, mask);\n}\n\nstatic int spmi_regulator_common_set_soft_start(struct regulator_dev *rdev)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tunsigned int mask = SPMI_LDO_SOFT_START_ENABLE_MASK;\n\n\treturn spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_SOFT_START,\n\t\t\t\t     mask, mask);\n}\n\nstatic int spmi_regulator_set_ilim(struct regulator_dev *rdev, int ilim_uA)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tenum spmi_regulator_logical_type type = vreg->logical_type;\n\tunsigned int current_reg;\n\tu8 reg;\n\tu8 mask = SPMI_BOOST_CURRENT_LIMIT_MASK |\n\t\t  SPMI_BOOST_CURRENT_LIMIT_ENABLE_MASK;\n\tint max = (SPMI_BOOST_CURRENT_LIMIT_MASK + 1) * 500;\n\n\tif (type == SPMI_REGULATOR_LOGICAL_TYPE_BOOST)\n\t\tcurrent_reg = SPMI_BOOST_REG_CURRENT_LIMIT;\n\telse\n\t\tcurrent_reg = SPMI_BOOST_BYP_REG_CURRENT_LIMIT;\n\n\tif (ilim_uA > max || ilim_uA <= 0)\n\t\treturn -EINVAL;\n\n\treg = (ilim_uA - 1) / 500;\n\treg |= SPMI_BOOST_CURRENT_LIMIT_ENABLE_MASK;\n\n\treturn spmi_vreg_update_bits(vreg, current_reg, reg, mask);\n}\n\nstatic int spmi_regulator_vs_clear_ocp(struct spmi_regulator *vreg)\n{\n\tint ret;\n\n\tret = spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_ENABLE,\n\t\tSPMI_COMMON_DISABLE, SPMI_COMMON_ENABLE_MASK);\n\n\tvreg->vs_enable_time = ktime_get();\n\n\tret = spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_ENABLE,\n\t\tSPMI_COMMON_ENABLE, SPMI_COMMON_ENABLE_MASK);\n\n\treturn ret;\n}\n\nstatic void spmi_regulator_vs_ocp_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct spmi_regulator *vreg\n\t\t= container_of(dwork, struct spmi_regulator, ocp_work);\n\n\tspmi_regulator_vs_clear_ocp(vreg);\n}\n\nstatic irqreturn_t spmi_regulator_vs_ocp_isr(int irq, void *data)\n{\n\tstruct spmi_regulator *vreg = data;\n\tktime_t ocp_irq_time;\n\ts64 ocp_trigger_delay_us;\n\n\tocp_irq_time = ktime_get();\n\tocp_trigger_delay_us = ktime_us_delta(ocp_irq_time,\n\t\t\t\t\t\tvreg->vs_enable_time);\n\n\t \n\tif (ocp_trigger_delay_us > SPMI_VS_OCP_FAULT_DELAY_US)\n\t\tvreg->ocp_count = 0;\n\n\t \n\tudelay(SPMI_VS_OCP_FALL_DELAY_US);\n\n\tvreg->ocp_count++;\n\n\tif (vreg->ocp_count == 1) {\n\t\t \n\t\tspmi_regulator_vs_clear_ocp(vreg);\n\t} else if (vreg->ocp_count <= vreg->ocp_max_retries) {\n\t\t \n\t\tschedule_delayed_work(&vreg->ocp_work,\n\t\t\tmsecs_to_jiffies(vreg->ocp_retry_delay_ms) + 1);\n\t} else {\n\t\tdev_err(vreg->dev,\n\t\t\t\"OCP triggered %d times; no further retries\\n\",\n\t\t\tvreg->ocp_count);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n#define SAW3_VCTL_DATA_MASK\t0xFF\n#define SAW3_VCTL_CLEAR_MASK\t0x700FF\n#define SAW3_AVS_CTL_EN_MASK\t0x1\n#define SAW3_AVS_CTL_TGGL_MASK\t0x8000000\n#define SAW3_AVS_CTL_CLEAR_MASK\t0x7efc00\n\nstatic struct regmap *saw_regmap;\n\nstatic void spmi_saw_set_vdd(void *data)\n{\n\tu32 vctl, data3, avs_ctl, pmic_sts;\n\tbool avs_enabled = false;\n\tunsigned long timeout;\n\tu8 voltage_sel = *(u8 *)data;\n\n\tregmap_read(saw_regmap, SAW3_AVS_CTL, &avs_ctl);\n\tregmap_read(saw_regmap, SAW3_VCTL, &vctl);\n\tregmap_read(saw_regmap, SAW3_SPM_PMIC_DATA_3, &data3);\n\n\t \n\tvctl &= ~SAW3_VCTL_CLEAR_MASK;\n\tvctl |= (u32)voltage_sel;\n\n\tdata3 &= ~SAW3_VCTL_CLEAR_MASK;\n\tdata3 |= (u32)voltage_sel;\n\n\t \n\tavs_enabled = SAW3_AVS_CTL_EN_MASK & avs_ctl;\n\tif (avs_enabled) {\n\t\tavs_ctl &= ~SAW3_AVS_CTL_TGGL_MASK;\n\t\tregmap_write(saw_regmap, SAW3_AVS_CTL, avs_ctl);\n\t}\n\n\tregmap_write(saw_regmap, SAW3_RST, 1);\n\tregmap_write(saw_regmap, SAW3_VCTL, vctl);\n\tregmap_write(saw_regmap, SAW3_SPM_PMIC_DATA_3, data3);\n\n\ttimeout = jiffies + usecs_to_jiffies(100);\n\tdo {\n\t\tregmap_read(saw_regmap, SAW3_PMIC_STS, &pmic_sts);\n\t\tpmic_sts &= SAW3_VCTL_DATA_MASK;\n\t\tif (pmic_sts == (u32)voltage_sel)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\n\t} while (time_before(jiffies, timeout));\n\n\t \n\tif (avs_enabled) {\n\t\tpmic_sts &= 0x3f;\n\t\tavs_ctl &= ~SAW3_AVS_CTL_CLEAR_MASK;\n\t\tavs_ctl |= ((pmic_sts - 4) << 10);\n\t\tavs_ctl |= (pmic_sts << 17);\n\t\tavs_ctl |= SAW3_AVS_CTL_TGGL_MASK;\n\t\tregmap_write(saw_regmap, SAW3_AVS_CTL, avs_ctl);\n\t}\n}\n\nstatic int\nspmi_regulator_saw_set_voltage(struct regulator_dev *rdev, unsigned selector)\n{\n\tstruct spmi_regulator *vreg = rdev_get_drvdata(rdev);\n\tint ret;\n\tu8 range_sel, voltage_sel;\n\n\tret = spmi_sw_selector_to_hw(vreg, selector, &range_sel, &voltage_sel);\n\tif (ret)\n\t\treturn ret;\n\n\tif (0 != range_sel) {\n\t\tdev_dbg(&rdev->dev, \"range_sel = %02X voltage_sel = %02X\", \\\n\t\t\trange_sel, voltage_sel);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn smp_call_function_single(0, spmi_saw_set_vdd, \\\n\t\t\t\t\t&voltage_sel, true);\n}\n\nstatic struct regulator_ops spmi_saw_ops = {};\n\nstatic const struct regulator_ops spmi_smps_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_voltage_sel\t= spmi_regulator_common_set_voltage,\n\t.set_voltage_time_sel\t= spmi_regulator_set_voltage_time_sel,\n\t.get_voltage_sel\t= spmi_regulator_common_get_voltage,\n\t.map_voltage\t\t= spmi_regulator_common_map_voltage,\n\t.list_voltage\t\t= spmi_regulator_common_list_voltage,\n\t.set_mode\t\t= spmi_regulator_common_set_mode,\n\t.get_mode\t\t= spmi_regulator_common_get_mode,\n\t.set_load\t\t= spmi_regulator_common_set_load,\n\t.set_pull_down\t\t= spmi_regulator_common_set_pull_down,\n};\n\nstatic const struct regulator_ops spmi_ldo_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_voltage_sel\t= spmi_regulator_common_set_voltage,\n\t.get_voltage_sel\t= spmi_regulator_common_get_voltage,\n\t.map_voltage\t\t= spmi_regulator_common_map_voltage,\n\t.list_voltage\t\t= spmi_regulator_common_list_voltage,\n\t.set_mode\t\t= spmi_regulator_common_set_mode,\n\t.get_mode\t\t= spmi_regulator_common_get_mode,\n\t.set_load\t\t= spmi_regulator_common_set_load,\n\t.set_bypass\t\t= spmi_regulator_common_set_bypass,\n\t.get_bypass\t\t= spmi_regulator_common_get_bypass,\n\t.set_pull_down\t\t= spmi_regulator_common_set_pull_down,\n\t.set_soft_start\t\t= spmi_regulator_common_set_soft_start,\n};\n\nstatic const struct regulator_ops spmi_ln_ldo_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_voltage_sel\t= spmi_regulator_common_set_voltage,\n\t.get_voltage_sel\t= spmi_regulator_common_get_voltage,\n\t.map_voltage\t\t= spmi_regulator_common_map_voltage,\n\t.list_voltage\t\t= spmi_regulator_common_list_voltage,\n\t.set_bypass\t\t= spmi_regulator_common_set_bypass,\n\t.get_bypass\t\t= spmi_regulator_common_get_bypass,\n};\n\nstatic const struct regulator_ops spmi_vs_ops = {\n\t.enable\t\t\t= spmi_regulator_vs_enable,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_pull_down\t\t= spmi_regulator_common_set_pull_down,\n\t.set_soft_start\t\t= spmi_regulator_common_set_soft_start,\n\t.set_over_current_protection = spmi_regulator_vs_ocp,\n\t.set_mode\t\t= spmi_regulator_common_set_mode,\n\t.get_mode\t\t= spmi_regulator_common_get_mode,\n};\n\nstatic const struct regulator_ops spmi_boost_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_voltage_sel\t= spmi_regulator_single_range_set_voltage,\n\t.get_voltage_sel\t= spmi_regulator_single_range_get_voltage,\n\t.map_voltage\t\t= spmi_regulator_single_map_voltage,\n\t.list_voltage\t\t= spmi_regulator_common_list_voltage,\n\t.set_input_current_limit = spmi_regulator_set_ilim,\n};\n\nstatic const struct regulator_ops spmi_ftsmps_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_voltage_sel\t= spmi_regulator_common_set_voltage,\n\t.set_voltage_time_sel\t= spmi_regulator_set_voltage_time_sel,\n\t.get_voltage_sel\t= spmi_regulator_common_get_voltage,\n\t.map_voltage\t\t= spmi_regulator_common_map_voltage,\n\t.list_voltage\t\t= spmi_regulator_common_list_voltage,\n\t.set_mode\t\t= spmi_regulator_common_set_mode,\n\t.get_mode\t\t= spmi_regulator_common_get_mode,\n\t.set_load\t\t= spmi_regulator_common_set_load,\n\t.set_pull_down\t\t= spmi_regulator_common_set_pull_down,\n};\n\nstatic const struct regulator_ops spmi_ult_lo_smps_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_voltage_sel\t= spmi_regulator_ult_lo_smps_set_voltage,\n\t.set_voltage_time_sel\t= spmi_regulator_set_voltage_time_sel,\n\t.get_voltage_sel\t= spmi_regulator_ult_lo_smps_get_voltage,\n\t.list_voltage\t\t= spmi_regulator_common_list_voltage,\n\t.set_mode\t\t= spmi_regulator_common_set_mode,\n\t.get_mode\t\t= spmi_regulator_common_get_mode,\n\t.set_load\t\t= spmi_regulator_common_set_load,\n\t.set_pull_down\t\t= spmi_regulator_common_set_pull_down,\n};\n\nstatic const struct regulator_ops spmi_ult_ho_smps_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_voltage_sel\t= spmi_regulator_single_range_set_voltage,\n\t.set_voltage_time_sel\t= spmi_regulator_set_voltage_time_sel,\n\t.get_voltage_sel\t= spmi_regulator_single_range_get_voltage,\n\t.map_voltage\t\t= spmi_regulator_single_map_voltage,\n\t.list_voltage\t\t= spmi_regulator_common_list_voltage,\n\t.set_mode\t\t= spmi_regulator_common_set_mode,\n\t.get_mode\t\t= spmi_regulator_common_get_mode,\n\t.set_load\t\t= spmi_regulator_common_set_load,\n\t.set_pull_down\t\t= spmi_regulator_common_set_pull_down,\n};\n\nstatic const struct regulator_ops spmi_ult_ldo_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_voltage_sel\t= spmi_regulator_single_range_set_voltage,\n\t.get_voltage_sel\t= spmi_regulator_single_range_get_voltage,\n\t.map_voltage\t\t= spmi_regulator_single_map_voltage,\n\t.list_voltage\t\t= spmi_regulator_common_list_voltage,\n\t.set_mode\t\t= spmi_regulator_common_set_mode,\n\t.get_mode\t\t= spmi_regulator_common_get_mode,\n\t.set_load\t\t= spmi_regulator_common_set_load,\n\t.set_bypass\t\t= spmi_regulator_common_set_bypass,\n\t.get_bypass\t\t= spmi_regulator_common_get_bypass,\n\t.set_pull_down\t\t= spmi_regulator_common_set_pull_down,\n\t.set_soft_start\t\t= spmi_regulator_common_set_soft_start,\n};\n\nstatic const struct regulator_ops spmi_ftsmps426_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_voltage_sel\t= spmi_regulator_ftsmps426_set_voltage,\n\t.set_voltage_time_sel\t= spmi_regulator_set_voltage_time_sel,\n\t.get_voltage_sel\t= spmi_regulator_ftsmps426_get_voltage,\n\t.map_voltage\t\t= spmi_regulator_single_map_voltage,\n\t.list_voltage\t\t= spmi_regulator_common_list_voltage,\n\t.set_mode\t\t= spmi_regulator_ftsmps426_set_mode,\n\t.get_mode\t\t= spmi_regulator_ftsmps426_get_mode,\n\t.set_load\t\t= spmi_regulator_common_set_load,\n\t.set_pull_down\t\t= spmi_regulator_common_set_pull_down,\n};\n\nstatic const struct regulator_ops spmi_hfs430_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_voltage_sel\t= spmi_regulator_ftsmps426_set_voltage,\n\t.set_voltage_time_sel\t= spmi_regulator_set_voltage_time_sel,\n\t.get_voltage_sel\t= spmi_regulator_ftsmps426_get_voltage,\n\t.map_voltage\t\t= spmi_regulator_single_map_voltage,\n\t.list_voltage\t\t= spmi_regulator_common_list_voltage,\n\t.set_mode\t\t= spmi_regulator_ftsmps426_set_mode,\n\t.get_mode\t\t= spmi_regulator_ftsmps426_get_mode,\n};\n\nstatic const struct regulator_ops spmi_hfsmps_ops = {\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.set_voltage_sel\t= spmi_regulator_ftsmps426_set_voltage,\n\t.set_voltage_time_sel\t= spmi_regulator_set_voltage_time_sel,\n\t.get_voltage_sel\t= spmi_regulator_ftsmps426_get_voltage,\n\t.map_voltage\t\t= spmi_regulator_single_map_voltage,\n\t.list_voltage\t\t= spmi_regulator_common_list_voltage,\n\t.set_mode\t\t= spmi_regulator_hfsmps_set_mode,\n\t.get_mode\t\t= spmi_regulator_hfsmps_get_mode,\n\t.set_load\t\t= spmi_regulator_common_set_load,\n\t.set_pull_down\t\t= spmi_regulator_hfsmps_set_pull_down,\n};\n\n \n#define INF 0xFF\n\nstatic const struct spmi_regulator_mapping supported_regulators[] = {\n\t \n\tSPMI_VREG(LDO,   HT_P600,  0, INF, HFS430, hfs430, ht_p600, 10000),\n\tSPMI_VREG(LDO,   HT_P150,  0, INF, HFS430, hfs430, ht_p150, 10000),\n\tSPMI_VREG(BUCK,  GP_CTL,   0, INF, SMPS,   smps,   smps,   100000),\n\tSPMI_VREG(BUCK,  HFS430,   0,   3, HFS430, hfs430, hfs430,  10000),\n\tSPMI_VREG(BUCK,  HFSMPS_510, 4, INF, HFSMPS, hfsmps, hfs430, 100000),\n\tSPMI_VREG(LDO,   N300,     0, INF, LDO,    ldo,    nldo1,   10000),\n\tSPMI_VREG(LDO,   N600,     0,   0, LDO,    ldo,    nldo2,   10000),\n\tSPMI_VREG(LDO,   N1200,    0,   0, LDO,    ldo,    nldo2,   10000),\n\tSPMI_VREG(LDO,   N600,     1, INF, LDO,    ldo,    nldo3,   10000),\n\tSPMI_VREG(LDO,   N1200,    1, INF, LDO,    ldo,    nldo3,   10000),\n\tSPMI_VREG(LDO,   N600_ST,  0,   0, LDO,    ldo,    nldo2,   10000),\n\tSPMI_VREG(LDO,   N1200_ST, 0,   0, LDO,    ldo,    nldo2,   10000),\n\tSPMI_VREG(LDO,   N600_ST,  1, INF, LDO,    ldo,    nldo3,   10000),\n\tSPMI_VREG(LDO,   N1200_ST, 1, INF, LDO,    ldo,    nldo3,   10000),\n\tSPMI_VREG(LDO,   P50,      0, INF, LDO,    ldo,    pldo,     5000),\n\tSPMI_VREG(LDO,   P150,     0, INF, LDO,    ldo,    pldo,    10000),\n\tSPMI_VREG(LDO,   P300,     0, INF, LDO,    ldo,    pldo,    10000),\n\tSPMI_VREG(LDO,   P600,     0, INF, LDO,    ldo,    pldo,    10000),\n\tSPMI_VREG(LDO,   P1200,    0, INF, LDO,    ldo,    pldo,    10000),\n\tSPMI_VREG(LDO,   LN,       0, INF, LN_LDO, ln_ldo, ln_ldo,      0),\n\tSPMI_VREG(LDO,   LV_P50,   0, INF, LDO,    ldo,    pldo,     5000),\n\tSPMI_VREG(LDO,   LV_P150,  0, INF, LDO,    ldo,    pldo,    10000),\n\tSPMI_VREG(LDO,   LV_P300,  0, INF, LDO,    ldo,    pldo,    10000),\n\tSPMI_VREG(LDO,   LV_P600,  0, INF, LDO,    ldo,    pldo,    10000),\n\tSPMI_VREG(LDO,   LV_P1200, 0, INF, LDO,    ldo,    pldo,    10000),\n\tSPMI_VREG(LDO, HT_N300_ST,   0, INF, FTSMPS426, ftsmps426,\n\t\t\t\t\t\t\tht_nldo,   30000),\n\tSPMI_VREG(LDO, HT_N600_ST,   0, INF, FTSMPS426, ftsmps426,\n\t\t\t\t\t\t\tht_nldo,   30000),\n\tSPMI_VREG(LDO, HT_N1200_ST,  0, INF, FTSMPS426, ftsmps426,\n\t\t\t\t\t\t\tht_nldo,   30000),\n\tSPMI_VREG(LDO, HT_LVP150,    0, INF, FTSMPS426, ftsmps426,\n\t\t\t\t\t\t\tht_lvpldo, 10000),\n\tSPMI_VREG(LDO, HT_LVP300,    0, INF, FTSMPS426, ftsmps426,\n\t\t\t\t\t\t\tht_lvpldo, 10000),\n\tSPMI_VREG(LDO, L660_N300_ST, 0, INF, FTSMPS426, ftsmps426,\n\t\t\t\t\t\t\tnldo660,   10000),\n\tSPMI_VREG(LDO, L660_N600_ST, 0, INF, FTSMPS426, ftsmps426,\n\t\t\t\t\t\t\tnldo660,   10000),\n\tSPMI_VREG(LDO, L660_P50,     0, INF, FTSMPS426, ftsmps426,\n\t\t\t\t\t\t\tpldo660,   10000),\n\tSPMI_VREG(LDO, L660_P150,    0, INF, FTSMPS426, ftsmps426,\n\t\t\t\t\t\t\tpldo660,   10000),\n\tSPMI_VREG(LDO, L660_P600,    0, INF, FTSMPS426, ftsmps426,\n\t\t\t\t\t\t\tpldo660,   10000),\n\tSPMI_VREG(LDO, L660_LVP150,  0, INF, FTSMPS426, ftsmps426,\n\t\t\t\t\t\t\tht_lvpldo, 10000),\n\tSPMI_VREG(LDO, L660_LVP600,  0, INF, FTSMPS426, ftsmps426,\n\t\t\t\t\t\t\tht_lvpldo, 10000),\n\tSPMI_VREG_VS(LV100,        0, INF),\n\tSPMI_VREG_VS(LV300,        0, INF),\n\tSPMI_VREG_VS(MV300,        0, INF),\n\tSPMI_VREG_VS(MV500,        0, INF),\n\tSPMI_VREG_VS(HDMI,         0, INF),\n\tSPMI_VREG_VS(OTG,          0, INF),\n\tSPMI_VREG(BOOST, 5V_BOOST, 0, INF, BOOST,  boost,  boost,       0),\n\tSPMI_VREG(FTS,   FTS_CTL,  0, INF, FTSMPS, ftsmps, ftsmps, 100000),\n\tSPMI_VREG(FTS, FTS2p5_CTL, 0, INF, FTSMPS, ftsmps, ftsmps2p5, 100000),\n\tSPMI_VREG(FTS, FTS426_CTL, 0, INF, FTSMPS426, ftsmps426, ftsmps426, 100000),\n\tSPMI_VREG(BOOST_BYP, BB_2A, 0, INF, BOOST_BYP, boost, boost_byp, 0),\n\tSPMI_VREG(ULT_BUCK, ULT_HF_CTL1, 0, INF, ULT_LO_SMPS, ult_lo_smps,\n\t\t\t\t\t\tult_lo_smps,   100000),\n\tSPMI_VREG(ULT_BUCK, ULT_HF_CTL2, 0, INF, ULT_LO_SMPS, ult_lo_smps,\n\t\t\t\t\t\tult_lo_smps,   100000),\n\tSPMI_VREG(ULT_BUCK, ULT_HF_CTL3, 0, INF, ULT_LO_SMPS, ult_lo_smps,\n\t\t\t\t\t\tult_lo_smps,   100000),\n\tSPMI_VREG(ULT_BUCK, ULT_HF_CTL4, 0, INF, ULT_HO_SMPS, ult_ho_smps,\n\t\t\t\t\t\tult_ho_smps,   100000),\n\tSPMI_VREG(ULT_LDO, N300_ST, 0, INF, ULT_LDO, ult_ldo, ult_nldo, 10000),\n\tSPMI_VREG(ULT_LDO, N600_ST, 0, INF, ULT_LDO, ult_ldo, ult_nldo, 10000),\n\tSPMI_VREG(ULT_LDO, N900_ST, 0, INF, ULT_LDO, ult_ldo, ult_nldo, 10000),\n\tSPMI_VREG(ULT_LDO, N1200_ST, 0, INF, ULT_LDO, ult_ldo, ult_nldo, 10000),\n\tSPMI_VREG(ULT_LDO, LV_P50,   0, INF, ULT_LDO, ult_ldo, ult_pldo, 10000),\n\tSPMI_VREG(ULT_LDO, LV_P150,  0, INF, ULT_LDO, ult_ldo, ult_pldo, 10000),\n\tSPMI_VREG(ULT_LDO, LV_P300,  0, INF, ULT_LDO, ult_ldo, ult_pldo, 10000),\n\tSPMI_VREG(ULT_LDO, LV_P450,  0, INF, ULT_LDO, ult_ldo, ult_pldo, 10000),\n\tSPMI_VREG(ULT_LDO, P600,     0, INF, ULT_LDO, ult_ldo, ult_pldo, 10000),\n\tSPMI_VREG(ULT_LDO, P300,     0, INF, ULT_LDO, ult_ldo, ult_pldo, 10000),\n\tSPMI_VREG(ULT_LDO, P150,     0, INF, ULT_LDO, ult_ldo, ult_pldo, 10000),\n\tSPMI_VREG(ULT_LDO, P50,     0, INF, ULT_LDO, ult_ldo, ult_pldo, 5000),\n\tSPMI_VREG(LDO, LV_P150_510, 0, INF, LDO_510, hfsmps, ht_lvpldo, 10000),\n\tSPMI_VREG(LDO, LV_P300_510, 0, INF, LDO_510, hfsmps, ht_lvpldo, 10000),\n\tSPMI_VREG(LDO, LV_P600_510, 0, INF, LDO_510, hfsmps, ht_lvpldo, 10000),\n\tSPMI_VREG(LDO, MV_P50_510,  0, INF, LDO_510, hfsmps, pldo660, 10000),\n\tSPMI_VREG(LDO, MV_P150_510, 0, INF, LDO_510, hfsmps, pldo660, 10000),\n\tSPMI_VREG(LDO, MV_P600_510, 0, INF, LDO_510, hfsmps, pldo660, 10000),\n\tSPMI_VREG(LDO, N300_510,    0, INF, LDO_510, hfsmps, nldo_510, 10000),\n\tSPMI_VREG(LDO, N600_510,    0, INF, LDO_510, hfsmps, nldo_510, 10000),\n\tSPMI_VREG(LDO, N1200_510,   0, INF, LDO_510, hfsmps, nldo_510, 10000),\n\tSPMI_VREG(FTS, FTSMPS_510,  0, INF, FTSMPS3, hfsmps, ftsmps510, 100000),\n};\n\nstatic void spmi_calculate_num_voltages(struct spmi_voltage_set_points *points)\n{\n\tunsigned int n;\n\tstruct spmi_voltage_range *range = points->range;\n\n\tfor (; range < points->range + points->count; range++) {\n\t\tn = 0;\n\t\tif (range->set_point_max_uV) {\n\t\t\tn = range->set_point_max_uV - range->set_point_min_uV;\n\t\t\tn = (n / range->step_uV) + 1;\n\t\t}\n\t\trange->n_voltages = n;\n\t\tpoints->n_voltages += n;\n\t}\n}\n\nstatic int spmi_regulator_match(struct spmi_regulator *vreg, u16 force_type)\n{\n\tconst struct spmi_regulator_mapping *mapping;\n\tint ret, i;\n\tu32 dig_major_rev;\n\tu8 version[SPMI_COMMON_REG_SUBTYPE - SPMI_COMMON_REG_DIG_MAJOR_REV + 1];\n\tu8 type, subtype;\n\n\tret = spmi_vreg_read(vreg, SPMI_COMMON_REG_DIG_MAJOR_REV, version,\n\t\tARRAY_SIZE(version));\n\tif (ret) {\n\t\tdev_dbg(vreg->dev, \"could not read version registers\\n\");\n\t\treturn ret;\n\t}\n\tdig_major_rev\t= version[SPMI_COMMON_REG_DIG_MAJOR_REV\n\t\t\t\t\t- SPMI_COMMON_REG_DIG_MAJOR_REV];\n\n\tif (!force_type) {\n\t\ttype\t\t= version[SPMI_COMMON_REG_TYPE -\n\t\t\t\t\t  SPMI_COMMON_REG_DIG_MAJOR_REV];\n\t\tsubtype\t\t= version[SPMI_COMMON_REG_SUBTYPE -\n\t\t\t\t\t  SPMI_COMMON_REG_DIG_MAJOR_REV];\n\t} else {\n\t\ttype = force_type >> 8;\n\t\tsubtype = force_type;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(supported_regulators); i++) {\n\t\tmapping = &supported_regulators[i];\n\t\tif (mapping->type == type && mapping->subtype == subtype\n\t\t    && mapping->revision_min <= dig_major_rev\n\t\t    && mapping->revision_max >= dig_major_rev)\n\t\t\tgoto found;\n\t}\n\n\tdev_err(vreg->dev,\n\t\t\"unsupported regulator: name=%s type=0x%02X, subtype=0x%02X, dig major rev=0x%02X\\n\",\n\t\tvreg->desc.name, type, subtype, dig_major_rev);\n\n\treturn -ENODEV;\n\nfound:\n\tvreg->logical_type\t= mapping->logical_type;\n\tvreg->set_points\t= mapping->set_points;\n\tvreg->hpm_min_load\t= mapping->hpm_min_load;\n\tvreg->desc.ops\t\t= mapping->ops;\n\n\tif (mapping->set_points) {\n\t\tif (!mapping->set_points->n_voltages)\n\t\t\tspmi_calculate_num_voltages(mapping->set_points);\n\t\tvreg->desc.n_voltages = mapping->set_points->n_voltages;\n\t}\n\n\treturn 0;\n}\n\nstatic int spmi_regulator_init_slew_rate(struct spmi_regulator *vreg)\n{\n\tint ret;\n\tu8 reg = 0;\n\tint step, delay, slew_rate, step_delay;\n\tconst struct spmi_voltage_range *range;\n\n\tret = spmi_vreg_read(vreg, SPMI_COMMON_REG_STEP_CTRL, &reg, 1);\n\tif (ret) {\n\t\tdev_err(vreg->dev, \"spmi read failed, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trange = spmi_regulator_find_range(vreg);\n\tif (!range)\n\t\treturn -EINVAL;\n\n\tswitch (vreg->logical_type) {\n\tcase SPMI_REGULATOR_LOGICAL_TYPE_FTSMPS:\n\t\tstep_delay = SPMI_FTSMPS_STEP_DELAY;\n\t\tbreak;\n\tdefault:\n\t\tstep_delay = SPMI_DEFAULT_STEP_DELAY;\n\t\tbreak;\n\t}\n\n\tstep = reg & SPMI_FTSMPS_STEP_CTRL_STEP_MASK;\n\tstep >>= SPMI_FTSMPS_STEP_CTRL_STEP_SHIFT;\n\n\tdelay = reg & SPMI_FTSMPS_STEP_CTRL_DELAY_MASK;\n\tdelay >>= SPMI_FTSMPS_STEP_CTRL_DELAY_SHIFT;\n\n\t \n\tslew_rate = SPMI_FTSMPS_CLOCK_RATE * range->step_uV * (1 << step);\n\tslew_rate /= 1000 * (step_delay << delay);\n\tslew_rate *= SPMI_FTSMPS_STEP_MARGIN_NUM;\n\tslew_rate /= SPMI_FTSMPS_STEP_MARGIN_DEN;\n\n\t \n\tvreg->slew_rate = max(slew_rate, 1);\n\n\treturn ret;\n}\n\nstatic int spmi_regulator_init_slew_rate_ftsmps426(struct spmi_regulator *vreg,\n\t\t\t\t\t\t   int clock_rate)\n{\n\tint ret;\n\tu8 reg = 0;\n\tint delay, slew_rate;\n\tconst struct spmi_voltage_range *range = &vreg->set_points->range[0];\n\n\tret = spmi_vreg_read(vreg, SPMI_COMMON_REG_STEP_CTRL, &reg, 1);\n\tif (ret) {\n\t\tdev_err(vreg->dev, \"spmi read failed, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdelay = reg & SPMI_FTSMPS426_STEP_CTRL_DELAY_MASK;\n\tdelay >>= SPMI_FTSMPS426_STEP_CTRL_DELAY_SHIFT;\n\n\t \n\tslew_rate = clock_rate * range->step_uV;\n\tslew_rate /= 1000 * (SPMI_FTSMPS426_STEP_DELAY << delay);\n\tslew_rate *= SPMI_FTSMPS426_STEP_MARGIN_NUM;\n\tslew_rate /= SPMI_FTSMPS426_STEP_MARGIN_DEN;\n\n\t \n\tvreg->slew_rate = max(slew_rate, 1);\n\n\treturn ret;\n}\n\nstatic int spmi_regulator_init_slew_rate_hfsmps(struct spmi_regulator *vreg)\n{\n\tint ret;\n\tu8 reg = 0;\n\tint delay;\n\n\tret = spmi_vreg_read(vreg, SPMI_HFSMPS_REG_STEP_CTRL, &reg, 1);\n\tif (ret) {\n\t\tdev_err(vreg->dev, \"spmi read failed, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdelay = reg & SPMI_FTSMPS426_STEP_CTRL_DELAY_MASK;\n\tdelay >>= SPMI_FTSMPS426_STEP_CTRL_DELAY_SHIFT;\n\n\tvreg->slew_rate = SPMI_HFSMPS_SLEW_RATE_38p4 >> delay;\n\n\treturn ret;\n}\n\nstatic int spmi_regulator_init_registers(struct spmi_regulator *vreg,\n\t\t\t\tconst struct spmi_regulator_init_data *data)\n{\n\tint ret;\n\tenum spmi_regulator_logical_type type;\n\tu8 ctrl_reg[8], reg, mask;\n\n\ttype = vreg->logical_type;\n\n\tret = spmi_vreg_read(vreg, SPMI_COMMON_REG_VOLTAGE_RANGE, ctrl_reg, 8);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!(data->pin_ctrl_enable & SPMI_REGULATOR_PIN_CTRL_ENABLE_HW_DEFAULT)) {\n\t\tswitch (type) {\n\t\tcase SPMI_REGULATOR_LOGICAL_TYPE_SMPS:\n\t\tcase SPMI_REGULATOR_LOGICAL_TYPE_LDO:\n\t\tcase SPMI_REGULATOR_LOGICAL_TYPE_VS:\n\t\t\tctrl_reg[SPMI_COMMON_IDX_ENABLE] &=\n\t\t\t\t~SPMI_COMMON_ENABLE_FOLLOW_ALL_MASK;\n\t\t\tctrl_reg[SPMI_COMMON_IDX_ENABLE] |=\n\t\t\t\tdata->pin_ctrl_enable & SPMI_COMMON_ENABLE_FOLLOW_ALL_MASK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!(data->pin_ctrl_hpm & SPMI_REGULATOR_PIN_CTRL_HPM_HW_DEFAULT)) {\n\t\tswitch (type) {\n\t\tcase SPMI_REGULATOR_LOGICAL_TYPE_SMPS:\n\t\tcase SPMI_REGULATOR_LOGICAL_TYPE_LDO:\n\t\t\tctrl_reg[SPMI_COMMON_IDX_MODE] &=\n\t\t\t\t~SPMI_COMMON_MODE_FOLLOW_ALL_MASK;\n\t\t\tctrl_reg[SPMI_COMMON_IDX_MODE] |=\n\t\t\t\tdata->pin_ctrl_hpm & SPMI_COMMON_MODE_FOLLOW_ALL_MASK;\n\t\t\tbreak;\n\t\tcase SPMI_REGULATOR_LOGICAL_TYPE_VS:\n\t\tcase SPMI_REGULATOR_LOGICAL_TYPE_ULT_LO_SMPS:\n\t\tcase SPMI_REGULATOR_LOGICAL_TYPE_ULT_HO_SMPS:\n\t\tcase SPMI_REGULATOR_LOGICAL_TYPE_ULT_LDO:\n\t\t\tctrl_reg[SPMI_COMMON_IDX_MODE] &=\n\t\t\t\t~SPMI_COMMON_MODE_FOLLOW_AWAKE_MASK;\n\t\t\tctrl_reg[SPMI_COMMON_IDX_MODE] |=\n\t\t\t\tdata->pin_ctrl_hpm & SPMI_COMMON_MODE_FOLLOW_AWAKE_MASK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tret = spmi_vreg_write(vreg, SPMI_COMMON_REG_VOLTAGE_RANGE, ctrl_reg, 8);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (type == SPMI_REGULATOR_LOGICAL_TYPE_VS) {\n\t\tif (data->vs_soft_start_strength\n\t\t\t\t!= SPMI_VS_SOFT_START_STR_HW_DEFAULT) {\n\t\t\treg = data->vs_soft_start_strength\n\t\t\t\t& SPMI_VS_SOFT_START_SEL_MASK;\n\t\t\tmask = SPMI_VS_SOFT_START_SEL_MASK;\n\t\t\treturn spmi_vreg_update_bits(vreg,\n\t\t\t\t\t\t     SPMI_VS_REG_SOFT_START,\n\t\t\t\t\t\t     reg, mask);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void spmi_regulator_get_dt_config(struct spmi_regulator *vreg,\n\t\tstruct device_node *node, struct spmi_regulator_init_data *data)\n{\n\t \n\tdata->pin_ctrl_enable\t    = SPMI_REGULATOR_PIN_CTRL_ENABLE_HW_DEFAULT;\n\tdata->pin_ctrl_hpm\t    = SPMI_REGULATOR_PIN_CTRL_HPM_HW_DEFAULT;\n\tdata->vs_soft_start_strength\t= SPMI_VS_SOFT_START_STR_HW_DEFAULT;\n\n\t \n\tof_property_read_u32(node, \"qcom,ocp-max-retries\",\n\t\t&vreg->ocp_max_retries);\n\tof_property_read_u32(node, \"qcom,ocp-retry-delay\",\n\t\t&vreg->ocp_retry_delay_ms);\n\tof_property_read_u32(node, \"qcom,pin-ctrl-enable\",\n\t\t&data->pin_ctrl_enable);\n\tof_property_read_u32(node, \"qcom,pin-ctrl-hpm\", &data->pin_ctrl_hpm);\n\tof_property_read_u32(node, \"qcom,vs-soft-start-strength\",\n\t\t&data->vs_soft_start_strength);\n}\n\nstatic unsigned int spmi_regulator_of_map_mode(unsigned int mode)\n{\n\tif (mode == 1)\n\t\treturn REGULATOR_MODE_NORMAL;\n\tif (mode == 2)\n\t\treturn REGULATOR_MODE_FAST;\n\n\treturn REGULATOR_MODE_IDLE;\n}\n\nstatic int spmi_regulator_of_parse(struct device_node *node,\n\t\t\t    const struct regulator_desc *desc,\n\t\t\t    struct regulator_config *config)\n{\n\tstruct spmi_regulator_init_data data = { };\n\tstruct spmi_regulator *vreg = config->driver_data;\n\tstruct device *dev = config->dev;\n\tint ret;\n\n\tspmi_regulator_get_dt_config(vreg, node, &data);\n\n\tif (!vreg->ocp_max_retries)\n\t\tvreg->ocp_max_retries = SPMI_VS_OCP_DEFAULT_MAX_RETRIES;\n\tif (!vreg->ocp_retry_delay_ms)\n\t\tvreg->ocp_retry_delay_ms = SPMI_VS_OCP_DEFAULT_RETRY_DELAY_MS;\n\n\tret = spmi_regulator_init_registers(vreg, &data);\n\tif (ret) {\n\t\tdev_err(dev, \"common initialization failed, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (vreg->logical_type) {\n\tcase SPMI_REGULATOR_LOGICAL_TYPE_FTSMPS:\n\tcase SPMI_REGULATOR_LOGICAL_TYPE_ULT_LO_SMPS:\n\tcase SPMI_REGULATOR_LOGICAL_TYPE_ULT_HO_SMPS:\n\tcase SPMI_REGULATOR_LOGICAL_TYPE_SMPS:\n\t\tret = spmi_regulator_init_slew_rate(vreg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SPMI_REGULATOR_LOGICAL_TYPE_FTSMPS426:\n\t\tret = spmi_regulator_init_slew_rate_ftsmps426(vreg,\n\t\t\t\t\t\tSPMI_FTSMPS426_CLOCK_RATE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SPMI_REGULATOR_LOGICAL_TYPE_HFS430:\n\t\tret = spmi_regulator_init_slew_rate_ftsmps426(vreg,\n\t\t\t\t\t\t\tSPMI_HFS430_CLOCK_RATE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SPMI_REGULATOR_LOGICAL_TYPE_HFSMPS:\n\tcase SPMI_REGULATOR_LOGICAL_TYPE_FTSMPS3:\n\t\tret = spmi_regulator_init_slew_rate_hfsmps(vreg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (vreg->logical_type != SPMI_REGULATOR_LOGICAL_TYPE_VS)\n\t\tvreg->ocp_irq = 0;\n\n\tif (vreg->ocp_irq) {\n\t\tret = devm_request_irq(dev, vreg->ocp_irq,\n\t\t\tspmi_regulator_vs_ocp_isr, IRQF_TRIGGER_RISING, \"ocp\",\n\t\t\tvreg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to request irq %d, ret=%d\\n\",\n\t\t\t\tvreg->ocp_irq, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = devm_delayed_work_autocancel(dev, &vreg->ocp_work,\n\t\t\t\t\t\t   spmi_regulator_vs_ocp_work);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct spmi_regulator_data pm6125_regulators[] = {\n\t{ \"s1\", 0x1400, \"vdd_s1\" },\n\t{ \"s2\", 0x1700, \"vdd_s2\" },\n\t{ \"s3\", 0x1a00, \"vdd_s3\" },\n\t{ \"s4\", 0x1d00, \"vdd_s4\" },\n\t{ \"s5\", 0x2000, \"vdd_s5\" },\n\t{ \"s6\", 0x2300, \"vdd_s6\" },\n\t{ \"s7\", 0x2600, \"vdd_s7\" },\n\t{ \"s8\", 0x2900, \"vdd_s8\" },\n\t{ \"l1\", 0x4000, \"vdd_l1_l7_l17_l18\" },\n\t{ \"l2\", 0x4100, \"vdd_l2_l3_l4\" },\n\t{ \"l3\", 0x4200, \"vdd_l2_l3_l4\" },\n\t{ \"l4\", 0x4300, \"vdd_l2_l3_l4\" },\n\t{ \"l5\", 0x4400, \"vdd_l5_l15_l19_l20_l21_l22\" },\n\t{ \"l6\", 0x4500, \"vdd_l6_l8\" },\n\t{ \"l7\", 0x4600, \"vdd_l1_l7_l17_l18\" },\n\t{ \"l8\", 0x4700, \"vdd_l6_l8\" },\n\t{ \"l9\", 0x4800, \"vdd_l9_l11\" },\n\t{ \"l10\", 0x4900, \"vdd_l10_l13_l14\" },\n\t{ \"l11\", 0x4a00, \"vdd_l9_l11\" },\n\t{ \"l12\", 0x4b00, \"vdd_l12_l16\" },\n\t{ \"l13\", 0x4c00, \"vdd_l10_l13_l14\" },\n\t{ \"l14\", 0x4d00, \"vdd_l10_l13_l14\" },\n\t{ \"l15\", 0x4e00, \"vdd_l5_l15_l19_l20_l21_l22\" },\n\t{ \"l16\", 0x4f00, \"vdd_l12_l16\" },\n\t{ \"l17\", 0x5000, \"vdd_l1_l7_l17_l18\" },\n\t{ \"l18\", 0x5100, \"vdd_l1_l7_l17_l18\" },\n\t{ \"l19\", 0x5200, \"vdd_l5_l15_l19_l20_l21_l22\" },\n\t{ \"l20\", 0x5300, \"vdd_l5_l15_l19_l20_l21_l22\" },\n\t{ \"l21\", 0x5400, \"vdd_l5_l15_l19_l20_l21_l22\" },\n\t{ \"l22\", 0x5500, \"vdd_l5_l15_l19_l20_l21_l22\" },\n\t{ \"l23\", 0x5600, \"vdd_l23_l24\" },\n\t{ \"l24\", 0x5700, \"vdd_l23_l24\" },\n};\n\nstatic const struct spmi_regulator_data pm660_regulators[] = {\n\t{ \"s1\", 0x1400, \"vdd_s1\", },\n\t{ \"s2\", 0x1700, \"vdd_s2\", },\n\t{ \"s3\", 0x1a00, \"vdd_s3\", },\n\t{ \"s4\", 0x1d00, \"vdd_s3\", },\n\t{ \"s5\", 0x2000, \"vdd_s5\", },\n\t{ \"s6\", 0x2300, \"vdd_s6\", },\n\t{ \"l1\", 0x4000, \"vdd_l1_l6_l7\", },\n\t{ \"l2\", 0x4100, \"vdd_l2_l3\", },\n\t{ \"l3\", 0x4200, \"vdd_l2_l3\", },\n\t \n\t{ \"l5\", 0x4400, \"vdd_l5\", },\n\t{ \"l6\", 0x4500, \"vdd_l1_l6_l7\", },\n\t{ \"l7\", 0x4600, \"vdd_l1_l6_l7\", },\n\t{ \"l8\", 0x4700, \"vdd_l8_l9_l10_l11_l12_l13_l14\", },\n\t{ \"l9\", 0x4800, \"vdd_l8_l9_l10_l11_l12_l13_l14\", },\n\t{ \"l10\", 0x4900, \"vdd_l8_l9_l10_l11_l12_l13_l14\", },\n\t{ \"l11\", 0x4a00, \"vdd_l8_l9_l10_l11_l12_l13_l14\", },\n\t{ \"l12\", 0x4b00, \"vdd_l8_l9_l10_l11_l12_l13_l14\", },\n\t{ \"l13\", 0x4c00, \"vdd_l8_l9_l10_l11_l12_l13_l14\", },\n\t{ \"l14\", 0x4d00, \"vdd_l8_l9_l10_l11_l12_l13_l14\", },\n\t{ \"l15\", 0x4e00, \"vdd_l15_l16_l17_l18_l19\", },\n\t{ \"l16\", 0x4f00, \"vdd_l15_l16_l17_l18_l19\", },\n\t{ \"l17\", 0x5000, \"vdd_l15_l16_l17_l18_l19\", },\n\t{ \"l18\", 0x5100, \"vdd_l15_l16_l17_l18_l19\", },\n\t{ \"l19\", 0x5200, \"vdd_l15_l16_l17_l18_l19\", },\n\t{ }\n};\n\nstatic const struct spmi_regulator_data pm660l_regulators[] = {\n\t{ \"s1\", 0x1400, \"vdd_s1\", },\n\t{ \"s2\", 0x1700, \"vdd_s2\", },\n\t{ \"s3\", 0x1a00, \"vdd_s3\", },\n\t{ \"s4\", 0x1d00, \"vdd_s4\", },\n\t{ \"s5\", 0x2000, \"vdd_s5\", },\n\t{ \"l1\", 0x4000, \"vdd_l1_l9_l10\", },\n\t{ \"l2\", 0x4100, \"vdd_l2\", },\n\t{ \"l3\", 0x4200, \"vdd_l3_l5_l7_l8\", },\n\t{ \"l4\", 0x4300, \"vdd_l4_l6\", },\n\t{ \"l5\", 0x4400, \"vdd_l3_l5_l7_l8\", },\n\t{ \"l6\", 0x4500, \"vdd_l4_l6\", },\n\t{ \"l7\", 0x4600, \"vdd_l3_l5_l7_l8\", },\n\t{ \"l8\", 0x4700, \"vdd_l3_l5_l7_l8\", },\n\t{ \"l9\", 0x4800, \"vdd_l1_l9_l10\", },\n\t{ \"l10\", 0x4900, \"vdd_l1_l9_l10\", },\n\t{ }\n};\n\nstatic const struct spmi_regulator_data pm8004_regulators[] = {\n\t{ \"s2\", 0x1700, \"vdd_s2\", },\n\t{ \"s5\", 0x2000, \"vdd_s5\", },\n\t{ }\n};\n\nstatic const struct spmi_regulator_data pm8005_regulators[] = {\n\t{ \"s1\", 0x1400, \"vdd_s1\", },\n\t{ \"s2\", 0x1700, \"vdd_s2\", },\n\t{ \"s3\", 0x1a00, \"vdd_s3\", },\n\t{ \"s4\", 0x1d00, \"vdd_s4\", },\n\t{ }\n};\n\nstatic const struct spmi_regulator_data pm8226_regulators[] = {\n\t{ \"s1\", 0x1400, \"vdd_s1\", },\n\t{ \"s2\", 0x1700, \"vdd_s2\", },\n\t{ \"s3\", 0x1a00, \"vdd_s3\", },\n\t{ \"s4\", 0x1d00, \"vdd_s4\", },\n\t{ \"s5\", 0x2000, \"vdd_s5\", },\n\t{ \"l1\", 0x4000, \"vdd_l1_l2_l4_l5\", },\n\t{ \"l2\", 0x4100, \"vdd_l1_l2_l4_l5\", },\n\t{ \"l3\", 0x4200, \"vdd_l3_l24_l26\", },\n\t{ \"l4\", 0x4300, \"vdd_l1_l2_l4_l5\", },\n\t{ \"l5\", 0x4400, \"vdd_l1_l2_l4_l5\", },\n\t{ \"l6\", 0x4500, \"vdd_l6_l7_l8_l9_l27\", },\n\t{ \"l7\", 0x4600, \"vdd_l6_l7_l8_l9_l27\", },\n\t{ \"l8\", 0x4700, \"vdd_l6_l7_l8_l9_l27\", },\n\t{ \"l9\", 0x4800, \"vdd_l6_l7_l8_l9_l27\", },\n\t{ \"l10\", 0x4900, \"vdd_l10_l11_l13\", },\n\t{ \"l11\", 0x4a00, \"vdd_l10_l11_l13\", },\n\t{ \"l12\", 0x4b00, \"vdd_l12_l14\", },\n\t{ \"l13\", 0x4c00, \"vdd_l10_l11_l13\", },\n\t{ \"l14\", 0x4d00, \"vdd_l12_l14\", },\n\t{ \"l15\", 0x4e00, \"vdd_l15_l16_l17_l18\", },\n\t{ \"l16\", 0x4f00, \"vdd_l15_l16_l17_l18\", },\n\t{ \"l17\", 0x5000, \"vdd_l15_l16_l17_l18\", },\n\t{ \"l18\", 0x5100, \"vdd_l15_l16_l17_l18\", },\n\t{ \"l19\", 0x5200, \"vdd_l19_l20_l21_l22_l23_l28\", },\n\t{ \"l20\", 0x5300, \"vdd_l19_l20_l21_l22_l23_l28\", },\n\t{ \"l21\", 0x5400, \"vdd_l19_l20_l21_l22_l23_l28\", },\n\t{ \"l22\", 0x5500, \"vdd_l19_l20_l21_l22_l23_l28\", },\n\t{ \"l23\", 0x5600, \"vdd_l19_l20_l21_l22_l23_l28\", },\n\t{ \"l24\", 0x5700, \"vdd_l3_l24_l26\", },\n\t{ \"l25\", 0x5800, \"vdd_l25\", },\n\t{ \"l26\", 0x5900, \"vdd_l3_l24_l26\", },\n\t{ \"l27\", 0x5a00, \"vdd_l6_l7_l8_l9_l27\", },\n\t{ \"l28\", 0x5b00, \"vdd_l19_l20_l21_l22_l23_l28\", },\n\t{ \"lvs1\", 0x8000, \"vdd_lvs1\", },\n\t{ }\n};\n\nstatic const struct spmi_regulator_data pm8841_regulators[] = {\n\t{ \"s1\", 0x1400, \"vdd_s1\", },\n\t{ \"s2\", 0x1700, \"vdd_s2\", NULL, 0x1c08 },\n\t{ \"s3\", 0x1a00, \"vdd_s3\", },\n\t{ \"s4\", 0x1d00, \"vdd_s4\", NULL, 0x1c08 },\n\t{ \"s5\", 0x2000, \"vdd_s5\", NULL, 0x1c08 },\n\t{ \"s6\", 0x2300, \"vdd_s6\", NULL, 0x1c08 },\n\t{ \"s7\", 0x2600, \"vdd_s7\", NULL, 0x1c08 },\n\t{ \"s8\", 0x2900, \"vdd_s8\", NULL, 0x1c08 },\n\t{ }\n};\n\nstatic const struct spmi_regulator_data pm8916_regulators[] = {\n\t{ \"s1\", 0x1400, \"vdd_s1\", },\n\t{ \"s2\", 0x1700, \"vdd_s2\", },\n\t{ \"s3\", 0x1a00, \"vdd_s3\", },\n\t{ \"s4\", 0x1d00, \"vdd_s4\", },\n\t{ \"l1\", 0x4000, \"vdd_l1_l3\", },\n\t{ \"l2\", 0x4100, \"vdd_l2\", },\n\t{ \"l3\", 0x4200, \"vdd_l1_l3\", },\n\t{ \"l4\", 0x4300, \"vdd_l4_l5_l6\", },\n\t{ \"l5\", 0x4400, \"vdd_l4_l5_l6\", },\n\t{ \"l6\", 0x4500, \"vdd_l4_l5_l6\", },\n\t{ \"l7\", 0x4600, \"vdd_l7\", },\n\t{ \"l8\", 0x4700, \"vdd_l8_l11_l14_l15_l16\", },\n\t{ \"l9\", 0x4800, \"vdd_l9_l10_l12_l13_l17_l18\", },\n\t{ \"l10\", 0x4900, \"vdd_l9_l10_l12_l13_l17_l18\", },\n\t{ \"l11\", 0x4a00, \"vdd_l8_l11_l14_l15_l16\", },\n\t{ \"l12\", 0x4b00, \"vdd_l9_l10_l12_l13_l17_l18\", },\n\t{ \"l13\", 0x4c00, \"vdd_l9_l10_l12_l13_l17_l18\", },\n\t{ \"l14\", 0x4d00, \"vdd_l8_l11_l14_l15_l16\", },\n\t{ \"l15\", 0x4e00, \"vdd_l8_l11_l14_l15_l16\", },\n\t{ \"l16\", 0x4f00, \"vdd_l8_l11_l14_l15_l16\", },\n\t{ \"l17\", 0x5000, \"vdd_l9_l10_l12_l13_l17_l18\", },\n\t{ \"l18\", 0x5100, \"vdd_l9_l10_l12_l13_l17_l18\", },\n\t{ }\n};\n\nstatic const struct spmi_regulator_data pm8941_regulators[] = {\n\t{ \"s1\", 0x1400, \"vdd_s1\", },\n\t{ \"s2\", 0x1700, \"vdd_s2\", },\n\t{ \"s3\", 0x1a00, \"vdd_s3\", },\n\t{ \"s4\", 0xa000, },\n\t{ \"l1\", 0x4000, \"vdd_l1_l3\", },\n\t{ \"l2\", 0x4100, \"vdd_l2_lvs_1_2_3\", },\n\t{ \"l3\", 0x4200, \"vdd_l1_l3\", },\n\t{ \"l4\", 0x4300, \"vdd_l4_l11\", },\n\t{ \"l5\", 0x4400, \"vdd_l5_l7\", NULL, 0x0410 },\n\t{ \"l6\", 0x4500, \"vdd_l6_l12_l14_l15\", },\n\t{ \"l7\", 0x4600, \"vdd_l5_l7\", NULL, 0x0410 },\n\t{ \"l8\", 0x4700, \"vdd_l8_l16_l18_19\", },\n\t{ \"l9\", 0x4800, \"vdd_l9_l10_l17_l22\", },\n\t{ \"l10\", 0x4900, \"vdd_l9_l10_l17_l22\", },\n\t{ \"l11\", 0x4a00, \"vdd_l4_l11\", },\n\t{ \"l12\", 0x4b00, \"vdd_l6_l12_l14_l15\", },\n\t{ \"l13\", 0x4c00, \"vdd_l13_l20_l23_l24\", },\n\t{ \"l14\", 0x4d00, \"vdd_l6_l12_l14_l15\", },\n\t{ \"l15\", 0x4e00, \"vdd_l6_l12_l14_l15\", },\n\t{ \"l16\", 0x4f00, \"vdd_l8_l16_l18_19\", },\n\t{ \"l17\", 0x5000, \"vdd_l9_l10_l17_l22\", },\n\t{ \"l18\", 0x5100, \"vdd_l8_l16_l18_19\", },\n\t{ \"l19\", 0x5200, \"vdd_l8_l16_l18_19\", },\n\t{ \"l20\", 0x5300, \"vdd_l13_l20_l23_l24\", },\n\t{ \"l21\", 0x5400, \"vdd_l21\", },\n\t{ \"l22\", 0x5500, \"vdd_l9_l10_l17_l22\", },\n\t{ \"l23\", 0x5600, \"vdd_l13_l20_l23_l24\", },\n\t{ \"l24\", 0x5700, \"vdd_l13_l20_l23_l24\", },\n\t{ \"lvs1\", 0x8000, \"vdd_l2_lvs_1_2_3\", },\n\t{ \"lvs2\", 0x8100, \"vdd_l2_lvs_1_2_3\", },\n\t{ \"lvs3\", 0x8200, \"vdd_l2_lvs_1_2_3\", },\n\t{ \"5vs1\", 0x8300, \"vin_5vs\", \"ocp-5vs1\", },\n\t{ \"5vs2\", 0x8400, \"vin_5vs\", \"ocp-5vs2\", },\n\t{ }\n};\n\nstatic const struct spmi_regulator_data pm8950_regulators[] = {\n\t{ \"s1\", 0x1400, \"vdd_s1\", },\n\t{ \"s2\", 0x1700, \"vdd_s2\", },\n\t{ \"s3\", 0x1a00, \"vdd_s3\", },\n\t{ \"s4\", 0x1d00, \"vdd_s4\", },\n\t{ \"s5\", 0x2000, \"vdd_s5\", },\n\t{ \"s6\", 0x2300, \"vdd_s6\", },\n\t{ \"l1\", 0x4000, \"vdd_l1_l19\", },\n\t{ \"l2\", 0x4100, \"vdd_l2_l23\", },\n\t{ \"l3\", 0x4200, \"vdd_l3\", },\n\t{ \"l4\", 0x4300, \"vdd_l4_l5_l6_l7_l16\", },\n\t{ \"l5\", 0x4400, \"vdd_l4_l5_l6_l7_l16\", },\n\t{ \"l6\", 0x4500, \"vdd_l4_l5_l6_l7_l16\", },\n\t{ \"l7\", 0x4600, \"vdd_l4_l5_l6_l7_l16\", },\n\t{ \"l8\", 0x4700, \"vdd_l8_l11_l12_l17_l22\", },\n\t{ \"l9\", 0x4800, \"vdd_l9_l10_l13_l14_l15_l18\", },\n\t{ \"l10\", 0x4900, \"vdd_l9_l10_l13_l14_l15_l18\", },\n\t{ \"l11\", 0x4a00, \"vdd_l8_l11_l12_l17_l22\", },\n\t{ \"l12\", 0x4b00, \"vdd_l8_l11_l12_l17_l22\", },\n\t{ \"l13\", 0x4c00, \"vdd_l9_l10_l13_l14_l15_l18\", },\n\t{ \"l14\", 0x4d00, \"vdd_l9_l10_l13_l14_l15_l18\", },\n\t{ \"l15\", 0x4e00, \"vdd_l9_l10_l13_l14_l15_l18\", },\n\t{ \"l16\", 0x4f00, \"vdd_l4_l5_l6_l7_l16\", },\n\t{ \"l17\", 0x5000, \"vdd_l8_l11_l12_l17_l22\", },\n\t{ \"l18\", 0x5100, \"vdd_l9_l10_l13_l14_l15_l18\", },\n\t{ \"l19\", 0x5200, \"vdd_l1_l19\", },\n\t{ \"l20\", 0x5300, \"vdd_l20\", },\n\t{ \"l21\", 0x5400, \"vdd_l21\", },\n\t{ \"l22\", 0x5500, \"vdd_l8_l11_l12_l17_l22\", },\n\t{ \"l23\", 0x5600, \"vdd_l2_l23\", },\n\t{ }\n};\n\nstatic const struct spmi_regulator_data pm8994_regulators[] = {\n\t{ \"s1\", 0x1400, \"vdd_s1\", },\n\t{ \"s2\", 0x1700, \"vdd_s2\", },\n\t{ \"s3\", 0x1a00, \"vdd_s3\", },\n\t{ \"s4\", 0x1d00, \"vdd_s4\", },\n\t{ \"s5\", 0x2000, \"vdd_s5\", },\n\t{ \"s6\", 0x2300, \"vdd_s6\", },\n\t{ \"s7\", 0x2600, \"vdd_s7\", },\n\t{ \"s8\", 0x2900, \"vdd_s8\", },\n\t{ \"s9\", 0x2c00, \"vdd_s9\", },\n\t{ \"s10\", 0x2f00, \"vdd_s10\", },\n\t{ \"s11\", 0x3200, \"vdd_s11\", },\n\t{ \"s12\", 0x3500, \"vdd_s12\", },\n\t{ \"l1\", 0x4000, \"vdd_l1\", },\n\t{ \"l2\", 0x4100, \"vdd_l2_l26_l28\", },\n\t{ \"l3\", 0x4200, \"vdd_l3_l11\", },\n\t{ \"l4\", 0x4300, \"vdd_l4_l27_l31\", },\n\t{ \"l5\", 0x4400, \"vdd_l5_l7\", },\n\t{ \"l6\", 0x4500, \"vdd_l6_l12_l32\", },\n\t{ \"l7\", 0x4600, \"vdd_l5_l7\", },\n\t{ \"l8\", 0x4700, \"vdd_l8_l16_l30\", },\n\t{ \"l9\", 0x4800, \"vdd_l9_l10_l18_l22\", },\n\t{ \"l10\", 0x4900, \"vdd_l9_l10_l18_l22\", },\n\t{ \"l11\", 0x4a00, \"vdd_l3_l11\", },\n\t{ \"l12\", 0x4b00, \"vdd_l6_l12_l32\", },\n\t{ \"l13\", 0x4c00, \"vdd_l13_l19_l23_l24\", },\n\t{ \"l14\", 0x4d00, \"vdd_l14_l15\", },\n\t{ \"l15\", 0x4e00, \"vdd_l14_l15\", },\n\t{ \"l16\", 0x4f00, \"vdd_l8_l16_l30\", },\n\t{ \"l17\", 0x5000, \"vdd_l17_l29\", },\n\t{ \"l18\", 0x5100, \"vdd_l9_l10_l18_l22\", },\n\t{ \"l19\", 0x5200, \"vdd_l13_l19_l23_l24\", },\n\t{ \"l20\", 0x5300, \"vdd_l20_l21\", },\n\t{ \"l21\", 0x5400, \"vdd_l20_l21\", },\n\t{ \"l22\", 0x5500, \"vdd_l9_l10_l18_l22\", },\n\t{ \"l23\", 0x5600, \"vdd_l13_l19_l23_l24\", },\n\t{ \"l24\", 0x5700, \"vdd_l13_l19_l23_l24\", },\n\t{ \"l25\", 0x5800, \"vdd_l25\", },\n\t{ \"l26\", 0x5900, \"vdd_l2_l26_l28\", },\n\t{ \"l27\", 0x5a00, \"vdd_l4_l27_l31\", },\n\t{ \"l28\", 0x5b00, \"vdd_l2_l26_l28\", },\n\t{ \"l29\", 0x5c00, \"vdd_l17_l29\", },\n\t{ \"l30\", 0x5d00, \"vdd_l8_l16_l30\", },\n\t{ \"l31\", 0x5e00, \"vdd_l4_l27_l31\", },\n\t{ \"l32\", 0x5f00, \"vdd_l6_l12_l32\", },\n\t{ \"lvs1\", 0x8000, \"vdd_lvs_1_2\", },\n\t{ \"lvs2\", 0x8100, \"vdd_lvs_1_2\", },\n\t{ }\n};\n\nstatic const struct spmi_regulator_data pmi8994_regulators[] = {\n\t{ \"s1\", 0x1400, \"vdd_s1\", },\n\t{ \"s2\", 0x1700, \"vdd_s2\", },\n\t{ \"s3\", 0x1a00, \"vdd_s3\", },\n\t{ \"l1\", 0x4000, \"vdd_l1\", },\n\t{ }\n};\n\nstatic const struct spmi_regulator_data pmp8074_regulators[] = {\n\t{ \"s1\", 0x1400, \"vdd_s1\"},\n\t{ \"s2\", 0x1700, \"vdd_s2\"},\n\t{ \"s3\", 0x1a00, \"vdd_s3\"},\n\t{ \"s4\", 0x1d00, \"vdd_s4\"},\n\t{ \"s5\", 0x2000, \"vdd_s5\"},\n\t{ \"l1\", 0x4000, \"vdd_l1_l2\"},\n\t{ \"l2\", 0x4100, \"vdd_l1_l2\"},\n\t{ \"l3\", 0x4200, \"vdd_l3_l8\"},\n\t{ \"l4\", 0x4300, \"vdd_l4\"},\n\t{ \"l5\", 0x4400, \"vdd_l5_l6_l15\"},\n\t{ \"l6\", 0x4500, \"vdd_l5_l6_l15\"},\n\t{ \"l7\", 0x4600, \"vdd_l7\"},\n\t{ \"l8\", 0x4700, \"vdd_l3_l8\"},\n\t{ \"l9\", 0x4800, \"vdd_l9\"},\n\t \n\t{ \"l11\", 0x4a00, \"vdd_l10_l11_l12_l13\"},\n\t{ \"l12\", 0x4b00, \"vdd_l10_l11_l12_l13\"},\n\t{ \"l13\", 0x4c00, \"vdd_l10_l11_l12_l13\"},\n\t{ }\n};\n\nstatic const struct spmi_regulator_data pms405_regulators[] = {\n\t{ \"s3\", 0x1a00, \"vdd_s3\"},\n\t{ }\n};\n\nstatic const struct of_device_id qcom_spmi_regulator_match[] = {\n\t{ .compatible = \"qcom,pm6125-regulators\", .data = &pm6125_regulators },\n\t{ .compatible = \"qcom,pm660-regulators\", .data = &pm660_regulators },\n\t{ .compatible = \"qcom,pm660l-regulators\", .data = &pm660l_regulators },\n\t{ .compatible = \"qcom,pm8004-regulators\", .data = &pm8004_regulators },\n\t{ .compatible = \"qcom,pm8005-regulators\", .data = &pm8005_regulators },\n\t{ .compatible = \"qcom,pm8226-regulators\", .data = &pm8226_regulators },\n\t{ .compatible = \"qcom,pm8841-regulators\", .data = &pm8841_regulators },\n\t{ .compatible = \"qcom,pm8916-regulators\", .data = &pm8916_regulators },\n\t{ .compatible = \"qcom,pm8941-regulators\", .data = &pm8941_regulators },\n\t{ .compatible = \"qcom,pm8950-regulators\", .data = &pm8950_regulators },\n\t{ .compatible = \"qcom,pm8994-regulators\", .data = &pm8994_regulators },\n\t{ .compatible = \"qcom,pmi8994-regulators\", .data = &pmi8994_regulators },\n\t{ .compatible = \"qcom,pmp8074-regulators\", .data = &pmp8074_regulators },\n\t{ .compatible = \"qcom,pms405-regulators\", .data = &pms405_regulators },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_spmi_regulator_match);\n\nstatic int qcom_spmi_regulator_probe(struct platform_device *pdev)\n{\n\tconst struct spmi_regulator_data *reg;\n\tconst struct spmi_voltage_range *range;\n\tconst struct of_device_id *match;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tstruct spmi_regulator *vreg;\n\tstruct regmap *regmap;\n\tconst char *name;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device_node *syscon, *reg_node;\n\tstruct property *reg_prop;\n\tint ret, lenp;\n\tstruct list_head *vreg_list;\n\n\tvreg_list = devm_kzalloc(dev, sizeof(*vreg_list), GFP_KERNEL);\n\tif (!vreg_list)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(vreg_list);\n\tplatform_set_drvdata(pdev, vreg_list);\n\n\tregmap = dev_get_regmap(dev->parent, NULL);\n\tif (!regmap)\n\t\treturn -ENODEV;\n\n\tmatch = of_match_device(qcom_spmi_regulator_match, &pdev->dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tif (of_find_property(node, \"qcom,saw-reg\", &lenp)) {\n\t\tsyscon = of_parse_phandle(node, \"qcom,saw-reg\", 0);\n\t\tsaw_regmap = syscon_node_to_regmap(syscon);\n\t\tof_node_put(syscon);\n\t\tif (IS_ERR(saw_regmap))\n\t\t\tdev_err(dev, \"ERROR reading SAW regmap\\n\");\n\t}\n\n\tfor (reg = match->data; reg->name; reg++) {\n\n\t\tif (saw_regmap) {\n\t\t\treg_node = of_get_child_by_name(node, reg->name);\n\t\t\treg_prop = of_find_property(reg_node, \"qcom,saw-slave\",\n\t\t\t\t\t\t    &lenp);\n\t\t\tof_node_put(reg_node);\n\t\t\tif (reg_prop)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tvreg = devm_kzalloc(dev, sizeof(*vreg), GFP_KERNEL);\n\t\tif (!vreg)\n\t\t\treturn -ENOMEM;\n\n\t\tvreg->dev = dev;\n\t\tvreg->base = reg->base;\n\t\tvreg->regmap = regmap;\n\t\tif (reg->ocp) {\n\t\t\tvreg->ocp_irq = platform_get_irq_byname(pdev, reg->ocp);\n\t\t\tif (vreg->ocp_irq < 0)\n\t\t\t\treturn vreg->ocp_irq;\n\t\t}\n\t\tvreg->desc.id = -1;\n\t\tvreg->desc.owner = THIS_MODULE;\n\t\tvreg->desc.type = REGULATOR_VOLTAGE;\n\t\tvreg->desc.enable_reg = reg->base + SPMI_COMMON_REG_ENABLE;\n\t\tvreg->desc.enable_mask = SPMI_COMMON_ENABLE_MASK;\n\t\tvreg->desc.enable_val = SPMI_COMMON_ENABLE;\n\t\tvreg->desc.name = name = reg->name;\n\t\tvreg->desc.supply_name = reg->supply;\n\t\tvreg->desc.of_match = reg->name;\n\t\tvreg->desc.of_parse_cb = spmi_regulator_of_parse;\n\t\tvreg->desc.of_map_mode = spmi_regulator_of_map_mode;\n\n\t\tret = spmi_regulator_match(vreg, reg->force_type);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tif (saw_regmap) {\n\t\t\treg_node = of_get_child_by_name(node, reg->name);\n\t\t\treg_prop = of_find_property(reg_node, \"qcom,saw-leader\",\n\t\t\t\t\t\t    &lenp);\n\t\t\tof_node_put(reg_node);\n\t\t\tif (reg_prop) {\n\t\t\t\tspmi_saw_ops = *(vreg->desc.ops);\n\t\t\t\tspmi_saw_ops.set_voltage_sel =\n\t\t\t\t\tspmi_regulator_saw_set_voltage;\n\t\t\t\tvreg->desc.ops = &spmi_saw_ops;\n\t\t\t}\n\t\t}\n\n\t\tif (vreg->set_points && vreg->set_points->count == 1) {\n\t\t\t \n\t\t\trange = vreg->set_points->range;\n\t\t\tvreg->desc.uV_step = range->step_uV;\n\t\t}\n\n\t\tconfig.dev = dev;\n\t\tconfig.driver_data = vreg;\n\t\tconfig.regmap = regmap;\n\t\trdev = devm_regulator_register(dev, &vreg->desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(dev, \"failed to register %s\\n\", name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\n\t\tINIT_LIST_HEAD(&vreg->node);\n\t\tlist_add(&vreg->node, vreg_list);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver qcom_spmi_regulator_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"qcom-spmi-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = qcom_spmi_regulator_match,\n\t},\n\t.probe\t\t= qcom_spmi_regulator_probe,\n};\nmodule_platform_driver(qcom_spmi_regulator_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm SPMI PMIC regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:qcom-spmi-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}