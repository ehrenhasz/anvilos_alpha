{
  "module_name": "da9052-regulator.c",
  "hash_id": "9414e9c293ffef06949130b881efd3ba548695500afad5889b5f2fb431c970c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/da9052-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/of.h>\n#include <linux/regulator/of_regulator.h>\n\n#include <linux/mfd/da9052/da9052.h>\n#include <linux/mfd/da9052/reg.h>\n#include <linux/mfd/da9052/pdata.h>\n\n \n#define DA9052_BUCK_PERI_3uV_STEP\t\t100000\n#define DA9052_BUCK_PERI_REG_MAP_UPTO_3uV\t24\n#define DA9052_CONST_3uV\t\t\t3000000\n\n#define DA9052_MIN_UA\t\t0\n#define DA9052_MAX_UA\t\t3\n#define DA9052_CURRENT_RANGE\t4\n\n \n#define DA9052_BUCK_ILIM_MASK_EVEN\t0x0c\n#define DA9052_BUCK_ILIM_MASK_ODD\t0xc0\n\n \n#define DA9052_ID_BUCK1\t\t0\n#define DA9052_ID_BUCK2\t\t1\n#define DA9052_ID_BUCK3\t\t2\n#define DA9052_ID_BUCK4\t\t3\n#define DA9052_ID_LDO1\t\t4\n#define DA9052_ID_LDO2\t\t5\n#define DA9052_ID_LDO3\t\t6\n#define DA9052_ID_LDO4\t\t7\n#define DA9052_ID_LDO5\t\t8\n#define DA9052_ID_LDO6\t\t9\n#define DA9052_ID_LDO7\t\t10\n#define DA9052_ID_LDO8\t\t11\n#define DA9052_ID_LDO9\t\t12\n#define DA9052_ID_LDO10\t\t13\n\nstatic const u32 da9052_current_limits[3][4] = {\n\t{700000, 800000, 1000000, 1200000},\t \n\t{1600000, 2000000, 2400000, 3000000},\t \n\t{800000, 1000000, 1200000, 1500000},\t \n};\n\nstruct da9052_regulator_info {\n\tstruct regulator_desc reg_desc;\n\tint step_uV;\n\tint min_uV;\n\tint max_uV;\n\tunsigned char activate_bit;\n};\n\nstruct da9052_regulator {\n\tstruct da9052 *da9052;\n\tstruct da9052_regulator_info *info;\n\tstruct regulator_dev *rdev;\n};\n\nstatic int verify_range(struct da9052_regulator_info *info,\n\t\t\t int min_uV, int max_uV)\n{\n\tif (min_uV > info->max_uV || max_uV < info->min_uV)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int da9052_dcdc_get_current_limit(struct regulator_dev *rdev)\n{\n\tstruct da9052_regulator *regulator = rdev_get_drvdata(rdev);\n\tint offset = rdev_get_id(rdev);\n\tint ret, row = 2;\n\n\tret = da9052_reg_read(regulator->da9052, DA9052_BUCKA_REG + offset/2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (offset % 2 == 0)\n\t\tret = (ret & DA9052_BUCK_ILIM_MASK_EVEN) >> 2;\n\telse\n\t\tret = (ret & DA9052_BUCK_ILIM_MASK_ODD) >> 6;\n\n\t \n\tif (regulator->da9052->chip_id == DA9052)\n\t\trow = 0;\n\telse if (offset == 0)\n\t\trow = 1;\n\n\treturn da9052_current_limits[row][ret];\n}\n\nstatic int da9052_dcdc_set_current_limit(struct regulator_dev *rdev, int min_uA,\n\t\t\t\t\t  int max_uA)\n{\n\tstruct da9052_regulator *regulator = rdev_get_drvdata(rdev);\n\tint offset = rdev_get_id(rdev);\n\tint reg_val = 0;\n\tint i, row = 2;\n\n\t \n\tif (regulator->da9052->chip_id == DA9052)\n\t\trow = 0;\n\telse if (offset == 0)\n\t\trow = 1;\n\n\tfor (i = DA9052_CURRENT_RANGE - 1; i >= 0; i--) {\n\t\tif ((min_uA <= da9052_current_limits[row][i]) &&\n\t\t    (da9052_current_limits[row][i] <= max_uA)) {\n\t\t\treg_val = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (offset % 2 == 0)\n\t\treturn da9052_reg_update(regulator->da9052,\n\t\t\t\t\t DA9052_BUCKA_REG + offset/2,\n\t\t\t\t\t DA9052_BUCK_ILIM_MASK_EVEN,\n\t\t\t\t\t reg_val << 2);\n\telse\n\t\treturn da9052_reg_update(regulator->da9052,\n\t\t\t\t\t DA9052_BUCKA_REG + offset/2,\n\t\t\t\t\t DA9052_BUCK_ILIM_MASK_ODD,\n\t\t\t\t\t reg_val << 6);\n}\n\nstatic int da9052_list_voltage(struct regulator_dev *rdev,\n\t\t\t\tunsigned int selector)\n{\n\tstruct da9052_regulator *regulator = rdev_get_drvdata(rdev);\n\tstruct da9052_regulator_info *info = regulator->info;\n\tint id = rdev_get_id(rdev);\n\tint volt_uV;\n\n\tif ((id == DA9052_ID_BUCK4) && (regulator->da9052->chip_id == DA9052)\n\t\t&& (selector >= DA9052_BUCK_PERI_REG_MAP_UPTO_3uV)) {\n\t\tvolt_uV = ((DA9052_BUCK_PERI_REG_MAP_UPTO_3uV * info->step_uV)\n\t\t\t  + info->min_uV);\n\t\tvolt_uV += (selector - DA9052_BUCK_PERI_REG_MAP_UPTO_3uV)\n\t\t\t\t    * (DA9052_BUCK_PERI_3uV_STEP);\n\t} else {\n\t\tvolt_uV = (selector * info->step_uV) + info->min_uV;\n\t}\n\n\tif (volt_uV > info->max_uV)\n\t\treturn -EINVAL;\n\n\treturn volt_uV;\n}\n\nstatic int da9052_map_voltage(struct regulator_dev *rdev,\n\t\t\t      int min_uV, int max_uV)\n{\n\tstruct da9052_regulator *regulator = rdev_get_drvdata(rdev);\n\tstruct da9052_regulator_info *info = regulator->info;\n\tint id = rdev_get_id(rdev);\n\tint ret, sel;\n\n\tret = verify_range(info, min_uV, max_uV);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (min_uV < info->min_uV)\n\t\tmin_uV = info->min_uV;\n\n\tif ((id == DA9052_ID_BUCK4) && (regulator->da9052->chip_id == DA9052)\n\t\t&& (min_uV >= DA9052_CONST_3uV)) {\n\t\t\tsel = DA9052_BUCK_PERI_REG_MAP_UPTO_3uV +\n\t\t\t      DIV_ROUND_UP(min_uV - DA9052_CONST_3uV,\n\t\t\t\t\t   DA9052_BUCK_PERI_3uV_STEP);\n\t} else {\n\t\tsel = DIV_ROUND_UP(min_uV - info->min_uV, info->step_uV);\n\t}\n\n\tret = da9052_list_voltage(rdev, sel);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sel;\n}\n\nstatic int da9052_regulator_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\t    unsigned int selector)\n{\n\tstruct da9052_regulator *regulator = rdev_get_drvdata(rdev);\n\tstruct da9052_regulator_info *info = regulator->info;\n\tint id = rdev_get_id(rdev);\n\tint ret;\n\n\tret = da9052_reg_update(regulator->da9052, rdev->desc->vsel_reg,\n\t\t\t\trdev->desc->vsel_mask, selector);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tswitch (id) {\n\tcase DA9052_ID_BUCK1:\n\tcase DA9052_ID_BUCK2:\n\tcase DA9052_ID_BUCK3:\n\tcase DA9052_ID_LDO2:\n\tcase DA9052_ID_LDO3:\n\t\tret = da9052_reg_update(regulator->da9052, DA9052_SUPPLY_REG,\n\t\t\t\t\tinfo->activate_bit, info->activate_bit);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int da9052_regulator_set_voltage_time_sel(struct regulator_dev *rdev,\n\t\t\t\t\t\t unsigned int old_sel,\n\t\t\t\t\t\t unsigned int new_sel)\n{\n\tstruct da9052_regulator *regulator = rdev_get_drvdata(rdev);\n\tstruct da9052_regulator_info *info = regulator->info;\n\tint id = rdev_get_id(rdev);\n\tint ret = 0;\n\n\t \n\tswitch (id) {\n\tcase DA9052_ID_BUCK1:\n\tcase DA9052_ID_BUCK2:\n\tcase DA9052_ID_BUCK3:\n\tcase DA9052_ID_LDO2:\n\tcase DA9052_ID_LDO3:\n\t\tret = DIV_ROUND_UP(abs(new_sel - old_sel) * info->step_uV,\n\t\t\t\t   6250);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct regulator_ops da9052_dcdc_ops = {\n\t.get_current_limit = da9052_dcdc_get_current_limit,\n\t.set_current_limit = da9052_dcdc_set_current_limit,\n\n\t.list_voltage = da9052_list_voltage,\n\t.map_voltage = da9052_map_voltage,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = da9052_regulator_set_voltage_sel,\n\t.set_voltage_time_sel = da9052_regulator_set_voltage_time_sel,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n};\n\nstatic const struct regulator_ops da9052_ldo_ops = {\n\t.list_voltage = da9052_list_voltage,\n\t.map_voltage = da9052_map_voltage,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = da9052_regulator_set_voltage_sel,\n\t.set_voltage_time_sel = da9052_regulator_set_voltage_time_sel,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n};\n\n#define DA9052_LDO(_id, _name, step, min, max, sbits, ebits, abits) \\\n{\\\n\t.reg_desc = {\\\n\t\t.name = #_name,\\\n\t\t.of_match = of_match_ptr(#_name),\\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\\\n\t\t.ops = &da9052_ldo_ops,\\\n\t\t.type = REGULATOR_VOLTAGE,\\\n\t\t.id = DA9052_ID_##_id,\\\n\t\t.n_voltages = (max - min) / step + 1, \\\n\t\t.owner = THIS_MODULE,\\\n\t\t.vsel_reg = DA9052_BUCKCORE_REG + DA9052_ID_##_id, \\\n\t\t.vsel_mask = (1 << (sbits)) - 1,\\\n\t\t.enable_reg = DA9052_BUCKCORE_REG + DA9052_ID_##_id, \\\n\t\t.enable_mask = 1 << (ebits),\\\n\t},\\\n\t.min_uV = (min) * 1000,\\\n\t.max_uV = (max) * 1000,\\\n\t.step_uV = (step) * 1000,\\\n\t.activate_bit = (abits),\\\n}\n\n#define DA9052_DCDC(_id, _name, step, min, max, sbits, ebits, abits) \\\n{\\\n\t.reg_desc = {\\\n\t\t.name = #_name,\\\n\t\t.of_match = of_match_ptr(#_name),\\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\\\n\t\t.ops = &da9052_dcdc_ops,\\\n\t\t.type = REGULATOR_VOLTAGE,\\\n\t\t.id = DA9052_ID_##_id,\\\n\t\t.n_voltages = (max - min) / step + 1, \\\n\t\t.owner = THIS_MODULE,\\\n\t\t.vsel_reg = DA9052_BUCKCORE_REG + DA9052_ID_##_id, \\\n\t\t.vsel_mask = (1 << (sbits)) - 1,\\\n\t\t.enable_reg = DA9052_BUCKCORE_REG + DA9052_ID_##_id, \\\n\t\t.enable_mask = 1 << (ebits),\\\n\t},\\\n\t.min_uV = (min) * 1000,\\\n\t.max_uV = (max) * 1000,\\\n\t.step_uV = (step) * 1000,\\\n\t.activate_bit = (abits),\\\n}\n\nstatic struct da9052_regulator_info da9052_regulator_info[] = {\n\tDA9052_DCDC(BUCK1, buck1, 25, 500, 2075, 6, 6, DA9052_SUPPLY_VBCOREGO),\n\tDA9052_DCDC(BUCK2, buck2, 25, 500, 2075, 6, 6, DA9052_SUPPLY_VBPROGO),\n\tDA9052_DCDC(BUCK3, buck3, 25, 950, 2525, 6, 6, DA9052_SUPPLY_VBMEMGO),\n\tDA9052_DCDC(BUCK4, buck4, 50, 1800, 3600, 5, 6, 0),\n\tDA9052_LDO(LDO1, ldo1, 50, 600, 1800, 5, 6, 0),\n\tDA9052_LDO(LDO2, ldo2, 25, 600, 1800, 6, 6, DA9052_SUPPLY_VLDO2GO),\n\tDA9052_LDO(LDO3, ldo3, 25, 1725, 3300, 6, 6, DA9052_SUPPLY_VLDO3GO),\n\tDA9052_LDO(LDO4, ldo4, 25, 1725, 3300, 6, 6, 0),\n\tDA9052_LDO(LDO5, ldo5, 50, 1200, 3600, 6, 6, 0),\n\tDA9052_LDO(LDO6, ldo6, 50, 1200, 3600, 6, 6, 0),\n\tDA9052_LDO(LDO7, ldo7, 50, 1200, 3600, 6, 6, 0),\n\tDA9052_LDO(LDO8, ldo8, 50, 1200, 3600, 6, 6, 0),\n\tDA9052_LDO(LDO9, ldo9, 50, 1250, 3650, 6, 6, 0),\n\tDA9052_LDO(LDO10, ldo10, 50, 1200, 3600, 6, 6, 0),\n};\n\nstatic struct da9052_regulator_info da9053_regulator_info[] = {\n\tDA9052_DCDC(BUCK1, buck1, 25, 500, 2075, 6, 6, DA9052_SUPPLY_VBCOREGO),\n\tDA9052_DCDC(BUCK2, buck2, 25, 500, 2075, 6, 6, DA9052_SUPPLY_VBPROGO),\n\tDA9052_DCDC(BUCK3, buck3, 25, 950, 2525, 6, 6, DA9052_SUPPLY_VBMEMGO),\n\tDA9052_DCDC(BUCK4, buck4, 25, 950, 2525, 6, 6, 0),\n\tDA9052_LDO(LDO1, ldo1, 50, 600, 1800, 5, 6, 0),\n\tDA9052_LDO(LDO2, ldo2, 25, 600, 1800, 6, 6, DA9052_SUPPLY_VLDO2GO),\n\tDA9052_LDO(LDO3, ldo3, 25, 1725, 3300, 6, 6, DA9052_SUPPLY_VLDO3GO),\n\tDA9052_LDO(LDO4, ldo4, 25, 1725, 3300, 6, 6, 0),\n\tDA9052_LDO(LDO5, ldo5, 50, 1200, 3600, 6, 6, 0),\n\tDA9052_LDO(LDO6, ldo6, 50, 1200, 3600, 6, 6, 0),\n\tDA9052_LDO(LDO7, ldo7, 50, 1200, 3600, 6, 6, 0),\n\tDA9052_LDO(LDO8, ldo8, 50, 1200, 3600, 6, 6, 0),\n\tDA9052_LDO(LDO9, ldo9, 50, 1250, 3650, 6, 6, 0),\n\tDA9052_LDO(LDO10, ldo10, 50, 1200, 3600, 6, 6, 0),\n};\n\nstatic inline struct da9052_regulator_info *find_regulator_info(u8 chip_id,\n\t\t\t\t\t\t\t\t int id)\n{\n\tstruct da9052_regulator_info *info;\n\tint i;\n\n\tswitch (chip_id) {\n\tcase DA9052:\n\t\tfor (i = 0; i < ARRAY_SIZE(da9052_regulator_info); i++) {\n\t\t\tinfo = &da9052_regulator_info[i];\n\t\t\tif (info->reg_desc.id == id)\n\t\t\t\treturn info;\n\t\t}\n\t\tbreak;\n\tcase DA9053_AA:\n\tcase DA9053_BA:\n\tcase DA9053_BB:\n\tcase DA9053_BC:\n\t\tfor (i = 0; i < ARRAY_SIZE(da9053_regulator_info); i++) {\n\t\t\tinfo = &da9053_regulator_info[i];\n\t\t\tif (info->reg_desc.id == id)\n\t\t\t\treturn info;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nstatic int da9052_regulator_probe(struct platform_device *pdev)\n{\n\tconst struct mfd_cell *cell = mfd_get_cell(pdev);\n\tstruct regulator_config config = { };\n\tstruct da9052_regulator *regulator;\n\tstruct da9052 *da9052;\n\tstruct da9052_pdata *pdata;\n\n\tregulator = devm_kzalloc(&pdev->dev, sizeof(struct da9052_regulator),\n\t\t\t\t GFP_KERNEL);\n\tif (!regulator)\n\t\treturn -ENOMEM;\n\n\tda9052 = dev_get_drvdata(pdev->dev.parent);\n\tpdata = dev_get_platdata(da9052->dev);\n\tregulator->da9052 = da9052;\n\n\tregulator->info = find_regulator_info(regulator->da9052->chip_id,\n\t\t\t\t\t      cell->id);\n\tif (regulator->info == NULL) {\n\t\tdev_err(&pdev->dev, \"invalid regulator ID specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tconfig.dev = da9052->dev;\n\tconfig.driver_data = regulator;\n\tconfig.regmap = da9052->regmap;\n\tif (pdata)\n\t\tconfig.init_data = pdata->regulators[cell->id];\n\n\tregulator->rdev = devm_regulator_register(&pdev->dev,\n\t\t\t\t\t\t  &regulator->info->reg_desc,\n\t\t\t\t\t\t  &config);\n\tif (IS_ERR(regulator->rdev)) {\n\t\tdev_err(&pdev->dev, \"failed to register regulator %s\\n\",\n\t\t\tregulator->info->reg_desc.name);\n\t\treturn PTR_ERR(regulator->rdev);\n\t}\n\n\tplatform_set_drvdata(pdev, regulator);\n\n\treturn 0;\n}\n\nstatic struct platform_driver da9052_regulator_driver = {\n\t.probe = da9052_regulator_probe,\n\t.driver = {\n\t\t.name = \"da9052-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init da9052_regulator_init(void)\n{\n\treturn platform_driver_register(&da9052_regulator_driver);\n}\nsubsys_initcall(da9052_regulator_init);\n\nstatic void __exit da9052_regulator_exit(void)\n{\n\tplatform_driver_unregister(&da9052_regulator_driver);\n}\nmodule_exit(da9052_regulator_exit);\n\nMODULE_AUTHOR(\"David Dajun Chen <dchen@diasemi.com>\");\nMODULE_DESCRIPTION(\"Power Regulator driver for Dialog DA9052 PMIC\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:da9052-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}