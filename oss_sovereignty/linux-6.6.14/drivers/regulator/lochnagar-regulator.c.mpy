{
  "module_name": "lochnagar-regulator.c",
  "hash_id": "6765b80fe97fd9c58e9f4de93b4ec9968aa75c68495ec2b57cf816b2ad41a672",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/lochnagar-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n\n#include <linux/mfd/lochnagar.h>\n#include <linux/mfd/lochnagar1_regs.h>\n#include <linux/mfd/lochnagar2_regs.h>\n\nstatic const struct regulator_ops lochnagar_micvdd_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.map_voltage = regulator_map_voltage_linear_range,\n\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n};\n\nstatic const struct linear_range lochnagar_micvdd_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1000000, 0,    0xC, 50000),\n\tREGULATOR_LINEAR_RANGE(1700000, 0xD, 0x1F, 100000),\n};\n\nstatic int lochnagar_micbias_enable(struct regulator_dev *rdev)\n{\n\tstruct lochnagar *lochnagar = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tmutex_lock(&lochnagar->analogue_config_lock);\n\n\tret = regulator_enable_regmap(rdev);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = lochnagar_update_config(lochnagar);\n\nerr:\n\tmutex_unlock(&lochnagar->analogue_config_lock);\n\n\treturn ret;\n}\n\nstatic int lochnagar_micbias_disable(struct regulator_dev *rdev)\n{\n\tstruct lochnagar *lochnagar = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tmutex_lock(&lochnagar->analogue_config_lock);\n\n\tret = regulator_disable_regmap(rdev);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = lochnagar_update_config(lochnagar);\n\nerr:\n\tmutex_unlock(&lochnagar->analogue_config_lock);\n\n\treturn ret;\n}\n\nstatic const struct regulator_ops lochnagar_micbias_ops = {\n\t.enable = lochnagar_micbias_enable,\n\t.disable = lochnagar_micbias_disable,\n\t.is_enabled = regulator_is_enabled_regmap,\n};\n\nstatic const struct regulator_ops lochnagar_vddcore_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.map_voltage = regulator_map_voltage_linear_range,\n\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n};\n\nstatic const struct linear_range lochnagar_vddcore_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(600000, 0,    0x7, 0),\n\tREGULATOR_LINEAR_RANGE(600000, 0x8, 0x41, 12500),\n};\n\nenum lochnagar_regulators {\n\tLOCHNAGAR_MICVDD,\n\tLOCHNAGAR_MIC1VDD,\n\tLOCHNAGAR_MIC2VDD,\n\tLOCHNAGAR_VDDCORE,\n};\n\nstatic int lochnagar_micbias_of_parse(struct device_node *np,\n\t\t\t\t      const struct regulator_desc *desc,\n\t\t\t\t      struct regulator_config *config)\n{\n\tstruct lochnagar *lochnagar = config->driver_data;\n\tint shift = (desc->id - LOCHNAGAR_MIC1VDD) *\n\t\t    LOCHNAGAR2_P2_MICBIAS_SRC_SHIFT;\n\tint mask = LOCHNAGAR2_P1_MICBIAS_SRC_MASK << shift;\n\tunsigned int val;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"cirrus,micbias-input\", &val);\n\tif (ret >= 0) {\n\t\tmutex_lock(&lochnagar->analogue_config_lock);\n\t\tret = regmap_update_bits(lochnagar->regmap,\n\t\t\t\t\t LOCHNAGAR2_ANALOGUE_PATH_CTRL2,\n\t\t\t\t\t mask, val << shift);\n\t\tmutex_unlock(&lochnagar->analogue_config_lock);\n\t\tif (ret < 0) {\n\t\t\tdev_err(lochnagar->dev,\n\t\t\t\t\"Failed to update micbias source: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regulator_desc lochnagar_regulators[] = {\n\t[LOCHNAGAR_MICVDD] = {\n\t\t.name = \"MICVDD\",\n\t\t.supply_name = \"SYSVDD\",\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = 32,\n\t\t.ops = &lochnagar_micvdd_ops,\n\n\t\t.id = LOCHNAGAR_MICVDD,\n\t\t.of_match = of_match_ptr(\"MICVDD\"),\n\n\t\t.enable_reg = LOCHNAGAR2_MICVDD_CTRL1,\n\t\t.enable_mask = LOCHNAGAR2_MICVDD_REG_ENA_MASK,\n\t\t.vsel_reg = LOCHNAGAR2_MICVDD_CTRL2,\n\t\t.vsel_mask = LOCHNAGAR2_MICVDD_VSEL_MASK,\n\n\t\t.linear_ranges = lochnagar_micvdd_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(lochnagar_micvdd_ranges),\n\n\t\t.enable_time = 3000,\n\t\t.ramp_delay = 1000,\n\n\t\t.owner = THIS_MODULE,\n\t},\n\t[LOCHNAGAR_MIC1VDD] = {\n\t\t.name = \"MIC1VDD\",\n\t\t.supply_name = \"MICBIAS1\",\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.ops = &lochnagar_micbias_ops,\n\n\t\t.id = LOCHNAGAR_MIC1VDD,\n\t\t.of_match = of_match_ptr(\"MIC1VDD\"),\n\t\t.of_parse_cb = lochnagar_micbias_of_parse,\n\n\t\t.enable_reg = LOCHNAGAR2_ANALOGUE_PATH_CTRL2,\n\t\t.enable_mask = LOCHNAGAR2_P1_INPUT_BIAS_ENA_MASK,\n\n\t\t.owner = THIS_MODULE,\n\t},\n\t[LOCHNAGAR_MIC2VDD] = {\n\t\t.name = \"MIC2VDD\",\n\t\t.supply_name = \"MICBIAS2\",\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.ops = &lochnagar_micbias_ops,\n\n\t\t.id = LOCHNAGAR_MIC2VDD,\n\t\t.of_match = of_match_ptr(\"MIC2VDD\"),\n\t\t.of_parse_cb = lochnagar_micbias_of_parse,\n\n\t\t.enable_reg = LOCHNAGAR2_ANALOGUE_PATH_CTRL2,\n\t\t.enable_mask = LOCHNAGAR2_P2_INPUT_BIAS_ENA_MASK,\n\n\t\t.owner = THIS_MODULE,\n\t},\n\t[LOCHNAGAR_VDDCORE] = {\n\t\t.name = \"VDDCORE\",\n\t\t.supply_name = \"SYSVDD\",\n\t\t.type = REGULATOR_VOLTAGE,\n\t\t.n_voltages = 66,\n\t\t.ops = &lochnagar_vddcore_ops,\n\n\t\t.id = LOCHNAGAR_VDDCORE,\n\t\t.of_match = of_match_ptr(\"VDDCORE\"),\n\n\t\t.enable_reg = LOCHNAGAR2_VDDCORE_CDC_CTRL1,\n\t\t.enable_mask = LOCHNAGAR2_VDDCORE_CDC_REG_ENA_MASK,\n\t\t.vsel_reg = LOCHNAGAR2_VDDCORE_CDC_CTRL2,\n\t\t.vsel_mask = LOCHNAGAR2_VDDCORE_CDC_VSEL_MASK,\n\n\t\t.linear_ranges = lochnagar_vddcore_ranges,\n\t\t.n_linear_ranges = ARRAY_SIZE(lochnagar_vddcore_ranges),\n\n\t\t.enable_time = 3000,\n\t\t.ramp_delay = 1000,\n\t\t.off_on_delay = 15000,\n\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\nstatic const struct of_device_id lochnagar_of_match[] = {\n\t{\n\t\t.compatible = \"cirrus,lochnagar2-micvdd\",\n\t\t.data = &lochnagar_regulators[LOCHNAGAR_MICVDD],\n\t},\n\t{\n\t\t.compatible = \"cirrus,lochnagar2-mic1vdd\",\n\t\t.data = &lochnagar_regulators[LOCHNAGAR_MIC1VDD],\n\t},\n\t{\n\t\t.compatible = \"cirrus,lochnagar2-mic2vdd\",\n\t\t.data = &lochnagar_regulators[LOCHNAGAR_MIC2VDD],\n\t},\n\t{\n\t\t.compatible = \"cirrus,lochnagar2-vddcore\",\n\t\t.data = &lochnagar_regulators[LOCHNAGAR_VDDCORE],\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, lochnagar_of_match);\n\nstatic int lochnagar_regulator_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct lochnagar *lochnagar = dev_get_drvdata(dev->parent);\n\tstruct regulator_config config = { };\n\tconst struct of_device_id *of_id;\n\tconst struct regulator_desc *desc;\n\tstruct regulator_dev *rdev;\n\tint ret;\n\n\tconfig.dev = dev;\n\tconfig.regmap = lochnagar->regmap;\n\tconfig.driver_data = lochnagar;\n\n\tof_id = of_match_device(lochnagar_of_match, dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tdesc = of_id->data;\n\n\trdev = devm_regulator_register(dev, desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\t\tdev_err(dev, \"Failed to register %s regulator: %d\\n\",\n\t\t\tdesc->name, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver lochnagar_regulator_driver = {\n\t.driver = {\n\t\t.name = \"lochnagar-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(lochnagar_of_match),\n\t},\n\n\t.probe = lochnagar_regulator_probe,\n};\nmodule_platform_driver(lochnagar_regulator_driver);\n\nMODULE_AUTHOR(\"Charles Keepax <ckeepax@opensource.cirrus.com>\");\nMODULE_DESCRIPTION(\"Regulator driver for Cirrus Logic Lochnagar Board\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:lochnagar-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}