{
  "module_name": "tps65132-regulator.c",
  "hash_id": "1716595c57ce16c43e7b04f06f7fa6dac8e521cbca7036b4d09b55ec53d11d82",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/tps65132-regulator.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n\n#define TPS65132_REG_VPOS\t\t0x00\n#define TPS65132_REG_VNEG\t\t0x01\n#define TPS65132_REG_APPS_DISP_DISN\t0x03\n#define TPS65132_REG_CONTROL\t\t0x0FF\n\n#define TPS65132_VOUT_MASK\t\t0x1F\n#define TPS65132_VOUT_N_VOLTAGE\t\t0x15\n#define TPS65132_VOUT_VMIN\t\t4000000\n#define TPS65132_VOUT_VMAX\t\t6000000\n#define TPS65132_VOUT_STEP\t\t100000\n\n#define TPS65132_REG_APPS_DIS_VPOS\t\tBIT(0)\n#define TPS65132_REG_APPS_DIS_VNEG\t\tBIT(1)\n\n#define TPS65132_REGULATOR_ID_VPOS\t0\n#define TPS65132_REGULATOR_ID_VNEG\t1\n#define TPS65132_MAX_REGULATORS\t\t2\n\n#define TPS65132_ACT_DIS_TIME_SLACK\t\t1000\n\nstruct tps65132_reg_pdata {\n\tstruct gpio_desc *en_gpiod;\n\tstruct gpio_desc *act_dis_gpiod;\n\tunsigned int act_dis_time_us;\n\tint ena_gpio_state;\n};\n\nstruct tps65132_regulator {\n\tstruct device *dev;\n\tstruct tps65132_reg_pdata reg_pdata[TPS65132_MAX_REGULATORS];\n};\n\nstatic int tps65132_regulator_enable(struct regulator_dev *rdev)\n{\n\tstruct tps65132_regulator *tps = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\tstruct tps65132_reg_pdata *rpdata = &tps->reg_pdata[id];\n\tint ret;\n\n\tif (!IS_ERR(rpdata->en_gpiod)) {\n\t\tgpiod_set_value_cansleep(rpdata->en_gpiod, 1);\n\t\trpdata->ena_gpio_state = 1;\n\t}\n\n\t \n\tif (rdev->constraints->active_discharge ==\n\t\t\tREGULATOR_ACTIVE_DISCHARGE_DISABLE) {\n\t\tret = regulator_set_active_discharge_regmap(rdev, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tps->dev, \"Failed to disable active discharge: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tps65132_regulator_disable(struct regulator_dev *rdev)\n{\n\tstruct tps65132_regulator *tps = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\tstruct tps65132_reg_pdata *rpdata = &tps->reg_pdata[id];\n\n\tif (!IS_ERR(rpdata->en_gpiod)) {\n\t\tgpiod_set_value_cansleep(rpdata->en_gpiod, 0);\n\t\trpdata->ena_gpio_state = 0;\n\t}\n\n\tif (!IS_ERR(rpdata->act_dis_gpiod)) {\n\t\tgpiod_set_value_cansleep(rpdata->act_dis_gpiod, 1);\n\t\tusleep_range(rpdata->act_dis_time_us, rpdata->act_dis_time_us +\n\t\t\t     TPS65132_ACT_DIS_TIME_SLACK);\n\t\tgpiod_set_value_cansleep(rpdata->act_dis_gpiod, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int tps65132_regulator_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct tps65132_regulator *tps = rdev_get_drvdata(rdev);\n\tint id = rdev_get_id(rdev);\n\tstruct tps65132_reg_pdata *rpdata = &tps->reg_pdata[id];\n\n\tif (!IS_ERR(rpdata->en_gpiod))\n\t\treturn rpdata->ena_gpio_state;\n\n\treturn 1;\n}\n\nstatic const struct regulator_ops tps65132_regulator_ops = {\n\t.enable = tps65132_regulator_enable,\n\t.disable = tps65132_regulator_disable,\n\t.is_enabled = tps65132_regulator_is_enabled,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n};\n\nstatic int tps65132_of_parse_cb(struct device_node *np,\n\t\t\t\tconst struct regulator_desc *desc,\n\t\t\t\tstruct regulator_config *config)\n{\n\tstruct tps65132_regulator *tps = config->driver_data;\n\tstruct tps65132_reg_pdata *rpdata = &tps->reg_pdata[desc->id];\n\tint ret;\n\n\trpdata->en_gpiod = devm_fwnode_gpiod_get(tps->dev, of_fwnode_handle(np),\n\t\t\t\t\t\t \"enable\", GPIOD_ASIS,\n\t\t\t\t\t\t \"enable\");\n\tif (IS_ERR(rpdata->en_gpiod)) {\n\t\tret = PTR_ERR(rpdata->en_gpiod);\n\n\t\t \n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\trpdata->act_dis_gpiod = devm_fwnode_gpiod_get(tps->dev,\n\t\t\t\t\t\t      of_fwnode_handle(np),\n\t\t\t\t\t\t      \"active-discharge\",\n\t\t\t\t\t\t      GPIOD_ASIS,\n\t\t\t\t\t\t      \"active-discharge\");\n\tif (IS_ERR(rpdata->act_dis_gpiod)) {\n\t\tret = PTR_ERR(rpdata->act_dis_gpiod);\n\n\t\t \n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\n\t\treturn 0;\n\t}\n\n\tret = of_property_read_u32(np, \"ti,active-discharge-time-us\",\n\t\t\t\t   &rpdata->act_dis_time_us);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev, \"Failed to read active discharge time:%d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#define TPS65132_REGULATOR_DESC(_id, _name)\t\t\\\n\t[TPS65132_REGULATOR_ID_##_id] = {\t\t\\\n\t\t.name = \"tps65132-\"#_name,\t\t\\\n\t\t.supply_name = \"vin\",\t\t\t\\\n\t\t.id = TPS65132_REGULATOR_ID_##_id,\t\\\n\t\t.of_match = of_match_ptr(#_name),\t\\\n\t\t.of_parse_cb\t= tps65132_of_parse_cb,\t\\\n\t\t.ops = &tps65132_regulator_ops,\t\t\\\n\t\t.n_voltages = TPS65132_VOUT_N_VOLTAGE,\t\\\n\t\t.min_uV = TPS65132_VOUT_VMIN,\t\t\\\n\t\t.uV_step = TPS65132_VOUT_STEP,\t\t\\\n\t\t.enable_time = 500,\t\t\t\\\n\t\t.vsel_mask = TPS65132_VOUT_MASK,\t\\\n\t\t.vsel_reg = TPS65132_REG_##_id,\t\t\\\n\t\t.active_discharge_off = 0,\t\t\t\\\n\t\t.active_discharge_on = TPS65132_REG_APPS_DIS_##_id, \\\n\t\t.active_discharge_mask = TPS65132_REG_APPS_DIS_##_id, \\\n\t\t.active_discharge_reg = TPS65132_REG_APPS_DISP_DISN, \\\n\t\t.type = REGULATOR_VOLTAGE,\t\t\\\n\t\t.owner = THIS_MODULE,\t\t\t\\\n\t}\n\nstatic const struct regulator_desc tps_regs_desc[TPS65132_MAX_REGULATORS] = {\n\tTPS65132_REGULATOR_DESC(VPOS, outp),\n\tTPS65132_REGULATOR_DESC(VNEG, outn),\n};\n\nstatic const struct regmap_range tps65132_no_reg_ranges[] = {\n\tregmap_reg_range(TPS65132_REG_APPS_DISP_DISN + 1,\n\t\t\t TPS65132_REG_CONTROL - 1),\n};\n\nstatic const struct regmap_access_table tps65132_no_reg_table = {\n\t.no_ranges = tps65132_no_reg_ranges,\n\t.n_no_ranges = ARRAY_SIZE(tps65132_no_reg_ranges),\n};\n\nstatic const struct regmap_config tps65132_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= TPS65132_REG_CONTROL,\n\t.cache_type\t= REGCACHE_NONE,\n\t.rd_table\t= &tps65132_no_reg_table,\n\t.wr_table\t= &tps65132_no_reg_table,\n};\n\nstatic int tps65132_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tps65132_regulator *tps;\n\tstruct regulator_dev *rdev;\n\tstruct regmap *rmap;\n\tstruct regulator_config config = { };\n\tint id;\n\tint ret;\n\n\ttps = devm_kzalloc(dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\trmap = devm_regmap_init_i2c(client, &tps65132_regmap_config);\n\tif (IS_ERR(rmap)) {\n\t\tret = PTR_ERR(rmap);\n\t\tdev_err(dev, \"regmap init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(client, tps);\n\ttps->dev = dev;\n\n\tfor (id = 0; id < TPS65132_MAX_REGULATORS; ++id) {\n\t\tconfig.regmap = rmap;\n\t\tconfig.dev = dev;\n\t\tconfig.driver_data = tps;\n\n\t\trdev = devm_regulator_register(dev, &tps_regs_desc[id],\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tret = PTR_ERR(rdev);\n\t\t\tdev_err(dev, \"regulator %s register failed: %d\\n\",\n\t\t\t\ttps_regs_desc[id].name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct i2c_device_id tps65132_id[] = {\n\t{.name = \"tps65132\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, tps65132_id);\n\nstatic struct i2c_driver tps65132_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tps65132\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = tps65132_probe,\n\t.id_table = tps65132_id,\n};\n\nmodule_i2c_driver(tps65132_i2c_driver);\n\nMODULE_DESCRIPTION(\"tps65132 regulator driver\");\nMODULE_AUTHOR(\"Venkat Reddy Talla <vreddytalla@nvidia.com>\");\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}