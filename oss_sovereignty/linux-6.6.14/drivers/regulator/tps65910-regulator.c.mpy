{
  "module_name": "tps65910-regulator.c",
  "hash_id": "6be605757b418d264f69b8a2120e12f322357b7d9dd613b331aa9debc41dbbbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/tps65910-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/slab.h>\n#include <linux/mfd/tps65910.h>\n#include <linux/regulator/of_regulator.h>\n\n#define TPS65910_SUPPLY_STATE_ENABLED\t0x1\n#define EXT_SLEEP_CONTROL (TPS65910_SLEEP_CONTROL_EXT_INPUT_EN1 |\t\\\n\t\t\tTPS65910_SLEEP_CONTROL_EXT_INPUT_EN2 |\t\t\\\n\t\t\tTPS65910_SLEEP_CONTROL_EXT_INPUT_EN3 |\t\t\\\n\t\t\tTPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP)\n\n \nstatic const unsigned int VIO_VSEL_table[] = {\n\t1500000, 1800000, 2500000, 3300000,\n};\n\n \n\n \nstatic const unsigned int VRTC_VSEL_table[] = {\n\t1800000,\n};\n\n \nstatic const unsigned int VDD3_VSEL_table[] = {\n\t5000000,\n};\n\n \nstatic const unsigned int VDIG1_VSEL_table[] = {\n\t1200000, 1500000, 1800000, 2700000,\n};\n\n \nstatic const unsigned int VDIG2_VSEL_table[] = {\n\t1000000, 1100000, 1200000, 1800000,\n};\n\n \nstatic const unsigned int VPLL_VSEL_table[] = {\n\t1000000, 1100000, 1800000, 2500000,\n};\n\n \nstatic const unsigned int VDAC_VSEL_table[] = {\n\t1800000, 2600000, 2800000, 2850000,\n};\n\n \nstatic const unsigned int VAUX1_VSEL_table[] = {\n\t1800000, 2500000, 2800000, 2850000,\n};\n\n \nstatic const unsigned int VAUX2_VSEL_table[] = {\n\t1800000, 2800000, 2900000, 3300000,\n};\n\n \nstatic const unsigned int VAUX33_VSEL_table[] = {\n\t1800000, 2000000, 2800000, 3300000,\n};\n\n \nstatic const unsigned int VMMC_VSEL_table[] = {\n\t1800000, 2800000, 3000000, 3300000,\n};\n\n \nstatic const unsigned int VBB_VSEL_table[] = {\n\t3000000, 2520000, 3150000, 5000000,\n};\n\nstruct tps_info {\n\tconst char *name;\n\tconst char *vin_name;\n\tu8 n_voltages;\n\tconst unsigned int *voltage_table;\n\tint enable_time_us;\n};\n\nstatic struct tps_info tps65910_regs[] = {\n\t{\n\t\t.name = \"vrtc\",\n\t\t.vin_name = \"vcc7\",\n\t\t.n_voltages = ARRAY_SIZE(VRTC_VSEL_table),\n\t\t.voltage_table = VRTC_VSEL_table,\n\t\t.enable_time_us = 2200,\n\t},\n\t{\n\t\t.name = \"vio\",\n\t\t.vin_name = \"vccio\",\n\t\t.n_voltages = ARRAY_SIZE(VIO_VSEL_table),\n\t\t.voltage_table = VIO_VSEL_table,\n\t\t.enable_time_us = 350,\n\t},\n\t{\n\t\t.name = \"vdd1\",\n\t\t.vin_name = \"vcc1\",\n\t\t.enable_time_us = 350,\n\t},\n\t{\n\t\t.name = \"vdd2\",\n\t\t.vin_name = \"vcc2\",\n\t\t.enable_time_us = 350,\n\t},\n\t{\n\t\t.name = \"vdd3\",\n\t\t.n_voltages = ARRAY_SIZE(VDD3_VSEL_table),\n\t\t.voltage_table = VDD3_VSEL_table,\n\t\t.enable_time_us = 200,\n\t},\n\t{\n\t\t.name = \"vdig1\",\n\t\t.vin_name = \"vcc6\",\n\t\t.n_voltages = ARRAY_SIZE(VDIG1_VSEL_table),\n\t\t.voltage_table = VDIG1_VSEL_table,\n\t\t.enable_time_us = 100,\n\t},\n\t{\n\t\t.name = \"vdig2\",\n\t\t.vin_name = \"vcc6\",\n\t\t.n_voltages = ARRAY_SIZE(VDIG2_VSEL_table),\n\t\t.voltage_table = VDIG2_VSEL_table,\n\t\t.enable_time_us = 100,\n\t},\n\t{\n\t\t.name = \"vpll\",\n\t\t.vin_name = \"vcc5\",\n\t\t.n_voltages = ARRAY_SIZE(VPLL_VSEL_table),\n\t\t.voltage_table = VPLL_VSEL_table,\n\t\t.enable_time_us = 100,\n\t},\n\t{\n\t\t.name = \"vdac\",\n\t\t.vin_name = \"vcc5\",\n\t\t.n_voltages = ARRAY_SIZE(VDAC_VSEL_table),\n\t\t.voltage_table = VDAC_VSEL_table,\n\t\t.enable_time_us = 100,\n\t},\n\t{\n\t\t.name = \"vaux1\",\n\t\t.vin_name = \"vcc4\",\n\t\t.n_voltages = ARRAY_SIZE(VAUX1_VSEL_table),\n\t\t.voltage_table = VAUX1_VSEL_table,\n\t\t.enable_time_us = 100,\n\t},\n\t{\n\t\t.name = \"vaux2\",\n\t\t.vin_name = \"vcc4\",\n\t\t.n_voltages = ARRAY_SIZE(VAUX2_VSEL_table),\n\t\t.voltage_table = VAUX2_VSEL_table,\n\t\t.enable_time_us = 100,\n\t},\n\t{\n\t\t.name = \"vaux33\",\n\t\t.vin_name = \"vcc3\",\n\t\t.n_voltages = ARRAY_SIZE(VAUX33_VSEL_table),\n\t\t.voltage_table = VAUX33_VSEL_table,\n\t\t.enable_time_us = 100,\n\t},\n\t{\n\t\t.name = \"vmmc\",\n\t\t.vin_name = \"vcc3\",\n\t\t.n_voltages = ARRAY_SIZE(VMMC_VSEL_table),\n\t\t.voltage_table = VMMC_VSEL_table,\n\t\t.enable_time_us = 100,\n\t},\n\t{\n\t\t.name = \"vbb\",\n\t\t.vin_name = \"vcc7\",\n\t\t.n_voltages = ARRAY_SIZE(VBB_VSEL_table),\n\t\t.voltage_table = VBB_VSEL_table,\n\t},\n};\n\nstatic struct tps_info tps65911_regs[] = {\n\t{\n\t\t.name = \"vrtc\",\n\t\t.vin_name = \"vcc7\",\n\t\t.enable_time_us = 2200,\n\t},\n\t{\n\t\t.name = \"vio\",\n\t\t.vin_name = \"vccio\",\n\t\t.n_voltages = ARRAY_SIZE(VIO_VSEL_table),\n\t\t.voltage_table = VIO_VSEL_table,\n\t\t.enable_time_us = 350,\n\t},\n\t{\n\t\t.name = \"vdd1\",\n\t\t.vin_name = \"vcc1\",\n\t\t.n_voltages = 0x4C,\n\t\t.enable_time_us = 350,\n\t},\n\t{\n\t\t.name = \"vdd2\",\n\t\t.vin_name = \"vcc2\",\n\t\t.n_voltages = 0x4C,\n\t\t.enable_time_us = 350,\n\t},\n\t{\n\t\t.name = \"vddctrl\",\n\t\t.n_voltages = 0x44,\n\t\t.enable_time_us = 900,\n\t},\n\t{\n\t\t.name = \"ldo1\",\n\t\t.vin_name = \"vcc6\",\n\t\t.n_voltages = 0x33,\n\t\t.enable_time_us = 420,\n\t},\n\t{\n\t\t.name = \"ldo2\",\n\t\t.vin_name = \"vcc6\",\n\t\t.n_voltages = 0x33,\n\t\t.enable_time_us = 420,\n\t},\n\t{\n\t\t.name = \"ldo3\",\n\t\t.vin_name = \"vcc5\",\n\t\t.n_voltages = 0x1A,\n\t\t.enable_time_us = 230,\n\t},\n\t{\n\t\t.name = \"ldo4\",\n\t\t.vin_name = \"vcc5\",\n\t\t.n_voltages = 0x33,\n\t\t.enable_time_us = 230,\n\t},\n\t{\n\t\t.name = \"ldo5\",\n\t\t.vin_name = \"vcc4\",\n\t\t.n_voltages = 0x1A,\n\t\t.enable_time_us = 230,\n\t},\n\t{\n\t\t.name = \"ldo6\",\n\t\t.vin_name = \"vcc3\",\n\t\t.n_voltages = 0x1A,\n\t\t.enable_time_us = 230,\n\t},\n\t{\n\t\t.name = \"ldo7\",\n\t\t.vin_name = \"vcc3\",\n\t\t.n_voltages = 0x1A,\n\t\t.enable_time_us = 230,\n\t},\n\t{\n\t\t.name = \"ldo8\",\n\t\t.vin_name = \"vcc3\",\n\t\t.n_voltages = 0x1A,\n\t\t.enable_time_us = 230,\n\t},\n};\n\n#define EXT_CONTROL_REG_BITS(id, regs_offs, bits) (((regs_offs) << 8) | (bits))\nstatic unsigned int tps65910_ext_sleep_control[] = {\n\t0,\n\tEXT_CONTROL_REG_BITS(VIO,    1, 0),\n\tEXT_CONTROL_REG_BITS(VDD1,   1, 1),\n\tEXT_CONTROL_REG_BITS(VDD2,   1, 2),\n\tEXT_CONTROL_REG_BITS(VDD3,   1, 3),\n\tEXT_CONTROL_REG_BITS(VDIG1,  0, 1),\n\tEXT_CONTROL_REG_BITS(VDIG2,  0, 2),\n\tEXT_CONTROL_REG_BITS(VPLL,   0, 6),\n\tEXT_CONTROL_REG_BITS(VDAC,   0, 7),\n\tEXT_CONTROL_REG_BITS(VAUX1,  0, 3),\n\tEXT_CONTROL_REG_BITS(VAUX2,  0, 4),\n\tEXT_CONTROL_REG_BITS(VAUX33, 0, 5),\n\tEXT_CONTROL_REG_BITS(VMMC,   0, 0),\n};\n\nstatic unsigned int tps65911_ext_sleep_control[] = {\n\t0,\n\tEXT_CONTROL_REG_BITS(VIO,     1, 0),\n\tEXT_CONTROL_REG_BITS(VDD1,    1, 1),\n\tEXT_CONTROL_REG_BITS(VDD2,    1, 2),\n\tEXT_CONTROL_REG_BITS(VDDCTRL, 1, 3),\n\tEXT_CONTROL_REG_BITS(LDO1,    0, 1),\n\tEXT_CONTROL_REG_BITS(LDO2,    0, 2),\n\tEXT_CONTROL_REG_BITS(LDO3,    0, 7),\n\tEXT_CONTROL_REG_BITS(LDO4,    0, 6),\n\tEXT_CONTROL_REG_BITS(LDO5,    0, 3),\n\tEXT_CONTROL_REG_BITS(LDO6,    0, 0),\n\tEXT_CONTROL_REG_BITS(LDO7,    0, 5),\n\tEXT_CONTROL_REG_BITS(LDO8,    0, 4),\n};\n\nstruct tps65910_reg {\n\tstruct regulator_desc *desc;\n\tstruct tps65910 *mfd;\n\tstruct regulator_dev **rdev;\n\tstruct tps_info **info;\n\tint num_regulators;\n\tint mode;\n\tint  (*get_ctrl_reg)(int);\n\tunsigned int *ext_sleep_control;\n\tunsigned int board_ext_control[TPS65910_NUM_REGS];\n};\n\nstatic int tps65910_get_ctrl_register(int id)\n{\n\tswitch (id) {\n\tcase TPS65910_REG_VRTC:\n\t\treturn TPS65910_VRTC;\n\tcase TPS65910_REG_VIO:\n\t\treturn TPS65910_VIO;\n\tcase TPS65910_REG_VDD1:\n\t\treturn TPS65910_VDD1;\n\tcase TPS65910_REG_VDD2:\n\t\treturn TPS65910_VDD2;\n\tcase TPS65910_REG_VDD3:\n\t\treturn TPS65910_VDD3;\n\tcase TPS65910_REG_VDIG1:\n\t\treturn TPS65910_VDIG1;\n\tcase TPS65910_REG_VDIG2:\n\t\treturn TPS65910_VDIG2;\n\tcase TPS65910_REG_VPLL:\n\t\treturn TPS65910_VPLL;\n\tcase TPS65910_REG_VDAC:\n\t\treturn TPS65910_VDAC;\n\tcase TPS65910_REG_VAUX1:\n\t\treturn TPS65910_VAUX1;\n\tcase TPS65910_REG_VAUX2:\n\t\treturn TPS65910_VAUX2;\n\tcase TPS65910_REG_VAUX33:\n\t\treturn TPS65910_VAUX33;\n\tcase TPS65910_REG_VMMC:\n\t\treturn TPS65910_VMMC;\n\tcase TPS65910_REG_VBB:\n\t\treturn TPS65910_BBCH;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tps65911_get_ctrl_register(int id)\n{\n\tswitch (id) {\n\tcase TPS65910_REG_VRTC:\n\t\treturn TPS65910_VRTC;\n\tcase TPS65910_REG_VIO:\n\t\treturn TPS65910_VIO;\n\tcase TPS65910_REG_VDD1:\n\t\treturn TPS65910_VDD1;\n\tcase TPS65910_REG_VDD2:\n\t\treturn TPS65910_VDD2;\n\tcase TPS65911_REG_VDDCTRL:\n\t\treturn TPS65911_VDDCTRL;\n\tcase TPS65911_REG_LDO1:\n\t\treturn TPS65911_LDO1;\n\tcase TPS65911_REG_LDO2:\n\t\treturn TPS65911_LDO2;\n\tcase TPS65911_REG_LDO3:\n\t\treturn TPS65911_LDO3;\n\tcase TPS65911_REG_LDO4:\n\t\treturn TPS65911_LDO4;\n\tcase TPS65911_REG_LDO5:\n\t\treturn TPS65911_LDO5;\n\tcase TPS65911_REG_LDO6:\n\t\treturn TPS65911_LDO6;\n\tcase TPS65911_REG_LDO7:\n\t\treturn TPS65911_LDO7;\n\tcase TPS65911_REG_LDO8:\n\t\treturn TPS65911_LDO8;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tps65910_set_mode(struct regulator_dev *dev, unsigned int mode)\n{\n\tstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\n\tstruct regmap *regmap = rdev_get_regmap(dev);\n\tint reg, id = rdev_get_id(dev);\n\n\treg = pmic->get_ctrl_reg(id);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\treturn regmap_update_bits(regmap, reg,\n\t\t\t\t\t  LDO_ST_MODE_BIT | LDO_ST_ON_BIT,\n\t\t\t\t\t  LDO_ST_ON_BIT);\n\tcase REGULATOR_MODE_IDLE:\n\t\treturn regmap_set_bits(regmap, reg,\n\t\t\t\t       LDO_ST_ON_BIT | LDO_ST_MODE_BIT);\n\tcase REGULATOR_MODE_STANDBY:\n\t\treturn regmap_clear_bits(regmap, reg, LDO_ST_ON_BIT);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic unsigned int tps65910_get_mode(struct regulator_dev *dev)\n{\n\tstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\n\tstruct regmap *regmap = rdev_get_regmap(dev);\n\tint ret, reg, value, id = rdev_get_id(dev);\n\n\treg = pmic->get_ctrl_reg(id);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tret = regmap_read(regmap, reg, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(value & LDO_ST_ON_BIT))\n\t\treturn REGULATOR_MODE_STANDBY;\n\telse if (value & LDO_ST_MODE_BIT)\n\t\treturn REGULATOR_MODE_IDLE;\n\telse\n\t\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int tps65910_get_voltage_dcdc_sel(struct regulator_dev *dev)\n{\n\tstruct regmap *regmap = rdev_get_regmap(dev);\n\tint ret, id = rdev_get_id(dev);\n\tint opvsel = 0, srvsel = 0, vselmax = 0, mult = 0, sr = 0;\n\n\tswitch (id) {\n\tcase TPS65910_REG_VDD1:\n\t\tret = regmap_read(regmap, TPS65910_VDD1_OP, &opvsel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_read(regmap, TPS65910_VDD1, &mult);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmult = (mult & VDD1_VGAIN_SEL_MASK) >> VDD1_VGAIN_SEL_SHIFT;\n\t\tret = regmap_read(regmap, TPS65910_VDD1_SR, &srvsel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsr = opvsel & VDD1_OP_CMD_MASK;\n\t\topvsel &= VDD1_OP_SEL_MASK;\n\t\tsrvsel &= VDD1_SR_SEL_MASK;\n\t\tvselmax = 75;\n\t\tbreak;\n\tcase TPS65910_REG_VDD2:\n\t\tret = regmap_read(regmap, TPS65910_VDD2_OP, &opvsel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_read(regmap, TPS65910_VDD2, &mult);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmult = (mult & VDD2_VGAIN_SEL_MASK) >> VDD2_VGAIN_SEL_SHIFT;\n\t\tret = regmap_read(regmap, TPS65910_VDD2_SR, &srvsel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsr = opvsel & VDD2_OP_CMD_MASK;\n\t\topvsel &= VDD2_OP_SEL_MASK;\n\t\tsrvsel &= VDD2_SR_SEL_MASK;\n\t\tvselmax = 75;\n\t\tbreak;\n\tcase TPS65911_REG_VDDCTRL:\n\t\tret = regmap_read(regmap, TPS65911_VDDCTRL_OP, &opvsel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_read(regmap, TPS65911_VDDCTRL_SR, &srvsel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsr = opvsel & VDDCTRL_OP_CMD_MASK;\n\t\topvsel &= VDDCTRL_OP_SEL_MASK;\n\t\tsrvsel &= VDDCTRL_SR_SEL_MASK;\n\t\tvselmax = 64;\n\t\tbreak;\n\t}\n\n\t \n\tif (!mult)\n\t\tmult = 1;\n\n\tif (sr) {\n\t\t \n\t\tif (srvsel < 3)\n\t\t\tsrvsel = 3;\n\t\tif (srvsel > vselmax)\n\t\t\tsrvsel = vselmax;\n\t\treturn srvsel - 3;\n\t} else {\n\n\t\t \n\t\tif (opvsel < 3)\n\t\t\topvsel = 3;\n\t\tif (opvsel > vselmax)\n\t\t\topvsel = vselmax;\n\t\treturn opvsel - 3;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int tps65910_get_voltage_sel(struct regulator_dev *dev)\n{\n\tstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\n\tstruct regmap *regmap = rdev_get_regmap(dev);\n\tint ret, reg, value, id = rdev_get_id(dev);\n\n\treg = pmic->get_ctrl_reg(id);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tret = regmap_read(regmap, reg, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (id) {\n\tcase TPS65910_REG_VIO:\n\tcase TPS65910_REG_VDIG1:\n\tcase TPS65910_REG_VDIG2:\n\tcase TPS65910_REG_VPLL:\n\tcase TPS65910_REG_VDAC:\n\tcase TPS65910_REG_VAUX1:\n\tcase TPS65910_REG_VAUX2:\n\tcase TPS65910_REG_VAUX33:\n\tcase TPS65910_REG_VMMC:\n\t\tvalue &= LDO_SEL_MASK;\n\t\tvalue >>= LDO_SEL_SHIFT;\n\t\tbreak;\n\tcase TPS65910_REG_VBB:\n\t\tvalue &= BBCH_BBSEL_MASK;\n\t\tvalue >>= BBCH_BBSEL_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn value;\n}\n\nstatic int tps65910_get_voltage_vdd3(struct regulator_dev *dev)\n{\n\treturn dev->desc->volt_table[0];\n}\n\nstatic int tps65911_get_voltage_sel(struct regulator_dev *dev)\n{\n\tstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\n\tstruct regmap *regmap = rdev_get_regmap(dev);\n\tint ret, id = rdev_get_id(dev);\n\tunsigned int value, reg;\n\n\treg = pmic->get_ctrl_reg(id);\n\n\tret = regmap_read(regmap, reg, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (id) {\n\tcase TPS65911_REG_LDO1:\n\tcase TPS65911_REG_LDO2:\n\tcase TPS65911_REG_LDO4:\n\t\tvalue &= LDO1_SEL_MASK;\n\t\tvalue >>= LDO_SEL_SHIFT;\n\t\tbreak;\n\tcase TPS65911_REG_LDO3:\n\tcase TPS65911_REG_LDO5:\n\tcase TPS65911_REG_LDO6:\n\tcase TPS65911_REG_LDO7:\n\tcase TPS65911_REG_LDO8:\n\t\tvalue &= LDO3_SEL_MASK;\n\t\tvalue >>= LDO_SEL_SHIFT;\n\t\tbreak;\n\tcase TPS65910_REG_VIO:\n\t\tvalue &= LDO_SEL_MASK;\n\t\tvalue >>= LDO_SEL_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn value;\n}\n\nstatic int tps65910_set_voltage_dcdc_sel(struct regulator_dev *dev,\n\t\t\t\t\t unsigned selector)\n{\n\tstruct regmap *regmap = rdev_get_regmap(dev);\n\tint id = rdev_get_id(dev), vsel;\n\tint dcdc_mult = 0;\n\n\tswitch (id) {\n\tcase TPS65910_REG_VDD1:\n\t\tdcdc_mult = (selector / VDD1_2_NUM_VOLT_FINE) + 1;\n\t\tif (dcdc_mult == 1)\n\t\t\tdcdc_mult--;\n\t\tvsel = (selector % VDD1_2_NUM_VOLT_FINE) + 3;\n\n\t\tregmap_update_bits(regmap, TPS65910_VDD1, VDD1_VGAIN_SEL_MASK,\n\t\t\t\t   dcdc_mult << VDD1_VGAIN_SEL_SHIFT);\n\t\tregmap_write(regmap, TPS65910_VDD1_OP, vsel);\n\t\tbreak;\n\tcase TPS65910_REG_VDD2:\n\t\tdcdc_mult = (selector / VDD1_2_NUM_VOLT_FINE) + 1;\n\t\tif (dcdc_mult == 1)\n\t\t\tdcdc_mult--;\n\t\tvsel = (selector % VDD1_2_NUM_VOLT_FINE) + 3;\n\n\t\tregmap_update_bits(regmap, TPS65910_VDD2, VDD1_VGAIN_SEL_MASK,\n\t\t\t\t   dcdc_mult << VDD2_VGAIN_SEL_SHIFT);\n\t\tregmap_write(regmap, TPS65910_VDD2_OP, vsel);\n\t\tbreak;\n\tcase TPS65911_REG_VDDCTRL:\n\t\tvsel = selector + 3;\n\t\tregmap_write(regmap, TPS65911_VDDCTRL_OP, vsel);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tps65910_set_voltage_sel(struct regulator_dev *dev,\n\t\t\t\t    unsigned selector)\n{\n\tstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\n\tstruct regmap *regmap = rdev_get_regmap(dev);\n\tint reg, id = rdev_get_id(dev);\n\n\treg = pmic->get_ctrl_reg(id);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tswitch (id) {\n\tcase TPS65910_REG_VIO:\n\tcase TPS65910_REG_VDIG1:\n\tcase TPS65910_REG_VDIG2:\n\tcase TPS65910_REG_VPLL:\n\tcase TPS65910_REG_VDAC:\n\tcase TPS65910_REG_VAUX1:\n\tcase TPS65910_REG_VAUX2:\n\tcase TPS65910_REG_VAUX33:\n\tcase TPS65910_REG_VMMC:\n\t\treturn regmap_update_bits(regmap, reg, LDO_SEL_MASK,\n\t\t\t\t\t  selector << LDO_SEL_SHIFT);\n\tcase TPS65910_REG_VBB:\n\t\treturn regmap_update_bits(regmap, reg, BBCH_BBSEL_MASK,\n\t\t\t\t\t  selector << BBCH_BBSEL_SHIFT);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int tps65911_set_voltage_sel(struct regulator_dev *dev,\n\t\t\t\t    unsigned selector)\n{\n\tstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\n\tstruct regmap *regmap = rdev_get_regmap(dev);\n\tint reg, id = rdev_get_id(dev);\n\n\treg = pmic->get_ctrl_reg(id);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tswitch (id) {\n\tcase TPS65911_REG_LDO1:\n\tcase TPS65911_REG_LDO2:\n\tcase TPS65911_REG_LDO4:\n\t\treturn regmap_update_bits(regmap, reg, LDO1_SEL_MASK,\n\t\t\t\t\t  selector << LDO_SEL_SHIFT);\n\tcase TPS65911_REG_LDO3:\n\tcase TPS65911_REG_LDO5:\n\tcase TPS65911_REG_LDO6:\n\tcase TPS65911_REG_LDO7:\n\tcase TPS65911_REG_LDO8:\n\t\treturn regmap_update_bits(regmap, reg, LDO3_SEL_MASK,\n\t\t\t\t\t  selector << LDO_SEL_SHIFT);\n\tcase TPS65910_REG_VIO:\n\t\treturn regmap_update_bits(regmap, reg, LDO_SEL_MASK,\n\t\t\t\t\t  selector << LDO_SEL_SHIFT);\n\tcase TPS65910_REG_VBB:\n\t\treturn regmap_update_bits(regmap, reg, BBCH_BBSEL_MASK,\n\t\t\t\t\t  selector << BBCH_BBSEL_SHIFT);\n\t}\n\n\treturn -EINVAL;\n}\n\n\nstatic int tps65910_list_voltage_dcdc(struct regulator_dev *dev,\n\t\t\t\t\tunsigned selector)\n{\n\tint volt, mult = 1, id = rdev_get_id(dev);\n\n\tswitch (id) {\n\tcase TPS65910_REG_VDD1:\n\tcase TPS65910_REG_VDD2:\n\t\tmult = (selector / VDD1_2_NUM_VOLT_FINE) + 1;\n\t\tvolt = VDD1_2_MIN_VOLT +\n\t\t\t(selector % VDD1_2_NUM_VOLT_FINE) * VDD1_2_OFFSET;\n\t\tbreak;\n\tcase TPS65911_REG_VDDCTRL:\n\t\tvolt = VDDCTRL_MIN_VOLT + (selector * VDDCTRL_OFFSET);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n\n\treturn  volt * 100 * mult;\n}\n\nstatic int tps65911_list_voltage(struct regulator_dev *dev, unsigned selector)\n{\n\tstruct tps65910_reg *pmic = rdev_get_drvdata(dev);\n\tint step_mv = 0, id = rdev_get_id(dev);\n\n\tswitch (id) {\n\tcase TPS65911_REG_LDO1:\n\tcase TPS65911_REG_LDO2:\n\tcase TPS65911_REG_LDO4:\n\t\t \n\t\tif (selector < 5)\n\t\t\tselector = 0;\n\t\telse\n\t\t\tselector -= 4;\n\n\t\tstep_mv = 50;\n\t\tbreak;\n\tcase TPS65911_REG_LDO3:\n\tcase TPS65911_REG_LDO5:\n\tcase TPS65911_REG_LDO6:\n\tcase TPS65911_REG_LDO7:\n\tcase TPS65911_REG_LDO8:\n\t\t \n\t\tif (selector < 3)\n\t\t\tselector = 0;\n\t\telse\n\t\t\tselector -= 2;\n\n\t\tstep_mv = 100;\n\t\tbreak;\n\tcase TPS65910_REG_VIO:\n\t\treturn pmic->info[id]->voltage_table[selector];\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn (LDO_MIN_VOLT + selector * step_mv) * 1000;\n}\n\n \nstatic const struct regulator_ops tps65910_ops_dcdc = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.set_mode\t\t= tps65910_set_mode,\n\t.get_mode\t\t= tps65910_get_mode,\n\t.get_voltage_sel\t= tps65910_get_voltage_dcdc_sel,\n\t.set_voltage_sel\t= tps65910_set_voltage_dcdc_sel,\n\t.set_voltage_time_sel\t= regulator_set_voltage_time_sel,\n\t.list_voltage\t\t= tps65910_list_voltage_dcdc,\n\t.map_voltage\t\t= regulator_map_voltage_ascend,\n};\n\nstatic const struct regulator_ops tps65910_ops_vdd3 = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.set_mode\t\t= tps65910_set_mode,\n\t.get_mode\t\t= tps65910_get_mode,\n\t.get_voltage\t\t= tps65910_get_voltage_vdd3,\n\t.list_voltage\t\t= regulator_list_voltage_table,\n\t.map_voltage\t\t= regulator_map_voltage_ascend,\n};\n\nstatic const struct regulator_ops tps65910_ops_vbb = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.set_mode\t\t= tps65910_set_mode,\n\t.get_mode\t\t= tps65910_get_mode,\n\t.get_voltage_sel\t= tps65910_get_voltage_sel,\n\t.set_voltage_sel\t= tps65910_set_voltage_sel,\n\t.list_voltage\t\t= regulator_list_voltage_table,\n\t.map_voltage\t\t= regulator_map_voltage_iterate,\n};\n\nstatic const struct regulator_ops tps65910_ops = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.set_mode\t\t= tps65910_set_mode,\n\t.get_mode\t\t= tps65910_get_mode,\n\t.get_voltage_sel\t= tps65910_get_voltage_sel,\n\t.set_voltage_sel\t= tps65910_set_voltage_sel,\n\t.list_voltage\t\t= regulator_list_voltage_table,\n\t.map_voltage\t\t= regulator_map_voltage_ascend,\n};\n\nstatic const struct regulator_ops tps65911_ops = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.set_mode\t\t= tps65910_set_mode,\n\t.get_mode\t\t= tps65910_get_mode,\n\t.get_voltage_sel\t= tps65911_get_voltage_sel,\n\t.set_voltage_sel\t= tps65911_set_voltage_sel,\n\t.list_voltage\t\t= tps65911_list_voltage,\n\t.map_voltage\t\t= regulator_map_voltage_ascend,\n};\n\nstatic int tps65910_set_ext_sleep_config(struct tps65910_reg *pmic,\n\t\tint id, int ext_sleep_config)\n{\n\tstruct tps65910 *mfd = pmic->mfd;\n\tu8 regoffs = (pmic->ext_sleep_control[id] >> 8) & 0xFF;\n\tu8 bit_pos = (1 << pmic->ext_sleep_control[id] & 0xFF);\n\tint ret;\n\n\t \n\tif (ext_sleep_config & EXT_SLEEP_CONTROL) {\n\t\tint en_count;\n\t\ten_count = ((ext_sleep_config &\n\t\t\t\tTPS65910_SLEEP_CONTROL_EXT_INPUT_EN1) != 0);\n\t\ten_count += ((ext_sleep_config &\n\t\t\t\tTPS65910_SLEEP_CONTROL_EXT_INPUT_EN2) != 0);\n\t\ten_count += ((ext_sleep_config &\n\t\t\t\tTPS65910_SLEEP_CONTROL_EXT_INPUT_EN3) != 0);\n\t\ten_count += ((ext_sleep_config &\n\t\t\t\tTPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP) != 0);\n\t\tif (en_count > 1) {\n\t\t\tdev_err(mfd->dev,\n\t\t\t\t\"External sleep control flag is not proper\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpmic->board_ext_control[id] = ext_sleep_config;\n\n\t \n\tif (ext_sleep_config & TPS65910_SLEEP_CONTROL_EXT_INPUT_EN1)\n\t\tret = regmap_set_bits(mfd->regmap,\n\t\t\t\tTPS65910_EN1_LDO_ASS + regoffs, bit_pos);\n\telse\n\t\tret = regmap_clear_bits(mfd->regmap,\n\t\t\t\tTPS65910_EN1_LDO_ASS + regoffs, bit_pos);\n\tif (ret < 0) {\n\t\tdev_err(mfd->dev,\n\t\t\t\"Error in configuring external control EN1\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (ext_sleep_config & TPS65910_SLEEP_CONTROL_EXT_INPUT_EN2)\n\t\tret = regmap_set_bits(mfd->regmap,\n\t\t\t\tTPS65910_EN2_LDO_ASS + regoffs, bit_pos);\n\telse\n\t\tret = regmap_clear_bits(mfd->regmap,\n\t\t\t\tTPS65910_EN2_LDO_ASS + regoffs, bit_pos);\n\tif (ret < 0) {\n\t\tdev_err(mfd->dev,\n\t\t\t\"Error in configuring external control EN2\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif ((tps65910_chip_id(mfd) == TPS65910) &&\n\t\t\t(id >= TPS65910_REG_VDIG1)) {\n\t\tif (ext_sleep_config & TPS65910_SLEEP_CONTROL_EXT_INPUT_EN3)\n\t\t\tret = regmap_set_bits(mfd->regmap,\n\t\t\t\tTPS65910_EN3_LDO_ASS + regoffs, bit_pos);\n\t\telse\n\t\t\tret = regmap_clear_bits(mfd->regmap,\n\t\t\t\tTPS65910_EN3_LDO_ASS + regoffs, bit_pos);\n\t\tif (ret < 0) {\n\t\t\tdev_err(mfd->dev,\n\t\t\t\t\"Error in configuring external control EN3\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (!(ext_sleep_config & EXT_SLEEP_CONTROL)) {\n\t\t \n\t\tret = regmap_clear_bits(mfd->regmap,\n\t\t\tTPS65910_SLEEP_KEEP_LDO_ON + regoffs, bit_pos);\n\t\tif (!ret)\n\t\t\tret = regmap_clear_bits(mfd->regmap,\n\t\t\t\tTPS65910_SLEEP_SET_LDO_OFF + regoffs, bit_pos);\n\t\tif (ret < 0)\n\t\t\tdev_err(mfd->dev,\n\t\t\t\t\"Error in configuring SLEEP register\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif ((id == TPS65910_REG_VDD1) ||\n\t\t(id == TPS65910_REG_VDD2) ||\n\t\t\t((id == TPS65911_REG_VDDCTRL) &&\n\t\t\t\t(tps65910_chip_id(mfd) == TPS65911))) {\n\t\tint op_reg_add = pmic->get_ctrl_reg(id) + 1;\n\t\tint sr_reg_add = pmic->get_ctrl_reg(id) + 2;\n\t\tint opvsel, srvsel;\n\n\t\tret = regmap_read(mfd->regmap, op_reg_add, &opvsel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_read(mfd->regmap, sr_reg_add, &srvsel);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (opvsel & VDD1_OP_CMD_MASK) {\n\t\t\tu8 reg_val = srvsel & VDD1_OP_SEL_MASK;\n\n\t\t\tret = regmap_write(mfd->regmap, op_reg_add, reg_val);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(mfd->dev,\n\t\t\t\t\t\"Error in configuring op register\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tret = regmap_write(mfd->regmap, sr_reg_add, 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(mfd->dev, \"Error in setting sr register\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = regmap_clear_bits(mfd->regmap,\n\t\t\tTPS65910_SLEEP_KEEP_LDO_ON + regoffs, bit_pos);\n\tif (!ret) {\n\t\tif (ext_sleep_config & TPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP)\n\t\t\tret = regmap_set_bits(mfd->regmap,\n\t\t\t\tTPS65910_SLEEP_SET_LDO_OFF + regoffs, bit_pos);\n\t\telse\n\t\t\tret = regmap_clear_bits(mfd->regmap,\n\t\t\t\tTPS65910_SLEEP_SET_LDO_OFF + regoffs, bit_pos);\n\t}\n\tif (ret < 0)\n\t\tdev_err(mfd->dev,\n\t\t\t\"Error in configuring SLEEP register\\n\");\n\n\treturn ret;\n}\n\n#ifdef CONFIG_OF\n\nstatic struct of_regulator_match tps65910_matches[] = {\n\t{ .name = \"vrtc\",\t.driver_data = (void *) &tps65910_regs[0] },\n\t{ .name = \"vio\",\t.driver_data = (void *) &tps65910_regs[1] },\n\t{ .name = \"vdd1\",\t.driver_data = (void *) &tps65910_regs[2] },\n\t{ .name = \"vdd2\",\t.driver_data = (void *) &tps65910_regs[3] },\n\t{ .name = \"vdd3\",\t.driver_data = (void *) &tps65910_regs[4] },\n\t{ .name = \"vdig1\",\t.driver_data = (void *) &tps65910_regs[5] },\n\t{ .name = \"vdig2\",\t.driver_data = (void *) &tps65910_regs[6] },\n\t{ .name = \"vpll\",\t.driver_data = (void *) &tps65910_regs[7] },\n\t{ .name = \"vdac\",\t.driver_data = (void *) &tps65910_regs[8] },\n\t{ .name = \"vaux1\",\t.driver_data = (void *) &tps65910_regs[9] },\n\t{ .name = \"vaux2\",\t.driver_data = (void *) &tps65910_regs[10] },\n\t{ .name = \"vaux33\",\t.driver_data = (void *) &tps65910_regs[11] },\n\t{ .name = \"vmmc\",\t.driver_data = (void *) &tps65910_regs[12] },\n\t{ .name = \"vbb\",\t.driver_data = (void *) &tps65910_regs[13] },\n};\n\nstatic struct of_regulator_match tps65911_matches[] = {\n\t{ .name = \"vrtc\",\t.driver_data = (void *) &tps65911_regs[0] },\n\t{ .name = \"vio\",\t.driver_data = (void *) &tps65911_regs[1] },\n\t{ .name = \"vdd1\",\t.driver_data = (void *) &tps65911_regs[2] },\n\t{ .name = \"vdd2\",\t.driver_data = (void *) &tps65911_regs[3] },\n\t{ .name = \"vddctrl\",\t.driver_data = (void *) &tps65911_regs[4] },\n\t{ .name = \"ldo1\",\t.driver_data = (void *) &tps65911_regs[5] },\n\t{ .name = \"ldo2\",\t.driver_data = (void *) &tps65911_regs[6] },\n\t{ .name = \"ldo3\",\t.driver_data = (void *) &tps65911_regs[7] },\n\t{ .name = \"ldo4\",\t.driver_data = (void *) &tps65911_regs[8] },\n\t{ .name = \"ldo5\",\t.driver_data = (void *) &tps65911_regs[9] },\n\t{ .name = \"ldo6\",\t.driver_data = (void *) &tps65911_regs[10] },\n\t{ .name = \"ldo7\",\t.driver_data = (void *) &tps65911_regs[11] },\n\t{ .name = \"ldo8\",\t.driver_data = (void *) &tps65911_regs[12] },\n};\n\nstatic struct tps65910_board *tps65910_parse_dt_reg_data(\n\t\tstruct platform_device *pdev,\n\t\tstruct of_regulator_match **tps65910_reg_matches)\n{\n\tstruct tps65910_board *pmic_plat_data;\n\tstruct tps65910 *tps65910 = dev_get_drvdata(pdev->dev.parent);\n\tstruct device_node *np, *regulators;\n\tstruct of_regulator_match *matches;\n\tunsigned int prop;\n\tint idx = 0, ret, count;\n\n\tpmic_plat_data = devm_kzalloc(&pdev->dev, sizeof(*pmic_plat_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!pmic_plat_data)\n\t\treturn NULL;\n\n\tnp = pdev->dev.parent->of_node;\n\tregulators = of_get_child_by_name(np, \"regulators\");\n\tif (!regulators) {\n\t\tdev_err(&pdev->dev, \"regulator node not found\\n\");\n\t\treturn NULL;\n\t}\n\n\tswitch (tps65910_chip_id(tps65910)) {\n\tcase TPS65910:\n\t\tcount = ARRAY_SIZE(tps65910_matches);\n\t\tmatches = tps65910_matches;\n\t\tbreak;\n\tcase TPS65911:\n\t\tcount = ARRAY_SIZE(tps65911_matches);\n\t\tmatches = tps65911_matches;\n\t\tbreak;\n\tdefault:\n\t\tof_node_put(regulators);\n\t\tdev_err(&pdev->dev, \"Invalid tps chip version\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = of_regulator_match(&pdev->dev, regulators, matches, count);\n\tof_node_put(regulators);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Error parsing regulator init data: %d\\n\",\n\t\t\tret);\n\t\treturn NULL;\n\t}\n\n\t*tps65910_reg_matches = matches;\n\n\tfor (idx = 0; idx < count; idx++) {\n\t\tif (!matches[idx].of_node)\n\t\t\tcontinue;\n\n\t\tpmic_plat_data->tps65910_pmic_init_data[idx] =\n\t\t\t\t\t\t\tmatches[idx].init_data;\n\n\t\tret = of_property_read_u32(matches[idx].of_node,\n\t\t\t\t\"ti,regulator-ext-sleep-control\", &prop);\n\t\tif (!ret)\n\t\t\tpmic_plat_data->regulator_ext_sleep_control[idx] = prop;\n\n\t}\n\n\treturn pmic_plat_data;\n}\n#else\nstatic inline struct tps65910_board *tps65910_parse_dt_reg_data(\n\t\t\tstruct platform_device *pdev,\n\t\t\tstruct of_regulator_match **tps65910_reg_matches)\n{\n\t*tps65910_reg_matches = NULL;\n\treturn NULL;\n}\n#endif\n\nstatic int tps65910_probe(struct platform_device *pdev)\n{\n\tstruct tps65910 *tps65910 = dev_get_drvdata(pdev->dev.parent);\n\tstruct regulator_config config = { };\n\tstruct tps_info *info;\n\tstruct regulator_dev *rdev;\n\tstruct tps65910_reg *pmic;\n\tstruct tps65910_board *pmic_plat_data;\n\tstruct of_regulator_match *tps65910_reg_matches = NULL;\n\tint i, err;\n\n\tpmic_plat_data = dev_get_platdata(tps65910->dev);\n\tif (!pmic_plat_data && tps65910->dev->of_node)\n\t\tpmic_plat_data = tps65910_parse_dt_reg_data(pdev,\n\t\t\t\t\t\t&tps65910_reg_matches);\n\n\tif (!pmic_plat_data) {\n\t\tdev_err(&pdev->dev, \"Platform data not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpmic = devm_kzalloc(&pdev->dev, sizeof(*pmic), GFP_KERNEL);\n\tif (!pmic)\n\t\treturn -ENOMEM;\n\n\tpmic->mfd = tps65910;\n\tplatform_set_drvdata(pdev, pmic);\n\n\t \n\terr = regmap_set_bits(pmic->mfd->regmap, TPS65910_DEVCTRL,\n\t\t\t\tDEVCTRL_SR_CTL_I2C_SEL_MASK);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (tps65910_chip_id(tps65910)) {\n\tcase TPS65910:\n\t\tBUILD_BUG_ON(TPS65910_NUM_REGS < ARRAY_SIZE(tps65910_regs));\n\t\tpmic->get_ctrl_reg = &tps65910_get_ctrl_register;\n\t\tpmic->num_regulators = ARRAY_SIZE(tps65910_regs);\n\t\tpmic->ext_sleep_control = tps65910_ext_sleep_control;\n\t\tinfo = tps65910_regs;\n\t\t \n\t\tregmap_clear_bits(pmic->mfd->regmap, TPS65910_DCDCCTRL,\n\t\t\t\t\tDCDCCTRL_DCDCCKSYNC_MASK);\n\t\tbreak;\n\tcase TPS65911:\n\t\tBUILD_BUG_ON(TPS65910_NUM_REGS < ARRAY_SIZE(tps65911_regs));\n\t\tpmic->get_ctrl_reg = &tps65911_get_ctrl_register;\n\t\tpmic->num_regulators = ARRAY_SIZE(tps65911_regs);\n\t\tpmic->ext_sleep_control = tps65911_ext_sleep_control;\n\t\tinfo = tps65911_regs;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Invalid tps chip version\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpmic->desc = devm_kcalloc(&pdev->dev,\n\t\t\t\t  pmic->num_regulators,\n\t\t\t\t  sizeof(struct regulator_desc),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pmic->desc)\n\t\treturn -ENOMEM;\n\n\tpmic->info = devm_kcalloc(&pdev->dev,\n\t\t\t\t  pmic->num_regulators,\n\t\t\t\t  sizeof(struct tps_info *),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pmic->info)\n\t\treturn -ENOMEM;\n\n\tpmic->rdev = devm_kcalloc(&pdev->dev,\n\t\t\t\t  pmic->num_regulators,\n\t\t\t\t  sizeof(struct regulator_dev *),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pmic->rdev)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pmic->num_regulators; i++, info++) {\n\t\t \n\t\tpmic->info[i] = info;\n\n\t\tpmic->desc[i].name = info->name;\n\t\tpmic->desc[i].supply_name = info->vin_name;\n\t\tpmic->desc[i].id = i;\n\t\tpmic->desc[i].n_voltages = info->n_voltages;\n\t\tpmic->desc[i].enable_time = info->enable_time_us;\n\n\t\tif (i == TPS65910_REG_VDD1 || i == TPS65910_REG_VDD2) {\n\t\t\tpmic->desc[i].ops = &tps65910_ops_dcdc;\n\t\t\tpmic->desc[i].n_voltages = VDD1_2_NUM_VOLT_FINE *\n\t\t\t\t\t\t\tVDD1_2_NUM_VOLT_COARSE;\n\t\t\tpmic->desc[i].ramp_delay = 12500;\n\t\t} else if (i == TPS65910_REG_VDD3) {\n\t\t\tif (tps65910_chip_id(tps65910) == TPS65910) {\n\t\t\t\tpmic->desc[i].ops = &tps65910_ops_vdd3;\n\t\t\t\tpmic->desc[i].volt_table = info->voltage_table;\n\t\t\t} else {\n\t\t\t\tpmic->desc[i].ops = &tps65910_ops_dcdc;\n\t\t\t\tpmic->desc[i].ramp_delay = 5000;\n\t\t\t}\n\t\t} else if (i == TPS65910_REG_VBB &&\n\t\t\t\ttps65910_chip_id(tps65910) == TPS65910) {\n\t\t\tpmic->desc[i].ops = &tps65910_ops_vbb;\n\t\t\tpmic->desc[i].volt_table = info->voltage_table;\n\t\t} else {\n\t\t\tif (tps65910_chip_id(tps65910) == TPS65910) {\n\t\t\t\tpmic->desc[i].ops = &tps65910_ops;\n\t\t\t\tpmic->desc[i].volt_table = info->voltage_table;\n\t\t\t} else {\n\t\t\t\tpmic->desc[i].ops = &tps65911_ops;\n\t\t\t}\n\t\t}\n\n\t\terr = tps65910_set_ext_sleep_config(pmic, i,\n\t\t\t\tpmic_plat_data->regulator_ext_sleep_control[i]);\n\t\t \n\t\tif (err < 0)\n\t\t\tdev_warn(tps65910->dev,\n\t\t\t\t\"Failed to initialise ext control config\\n\");\n\n\t\tpmic->desc[i].type = REGULATOR_VOLTAGE;\n\t\tpmic->desc[i].owner = THIS_MODULE;\n\t\tpmic->desc[i].enable_reg = pmic->get_ctrl_reg(i);\n\t\tpmic->desc[i].enable_mask = TPS65910_SUPPLY_STATE_ENABLED;\n\n\t\tconfig.dev = tps65910->dev;\n\t\tconfig.init_data = pmic_plat_data->tps65910_pmic_init_data[i];\n\t\tconfig.driver_data = pmic;\n\t\tconfig.regmap = tps65910->regmap;\n\n\t\tif (tps65910_reg_matches)\n\t\t\tconfig.of_node = tps65910_reg_matches[i].of_node;\n\n\t\trdev = devm_regulator_register(&pdev->dev, &pmic->desc[i],\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev))\n\t\t\treturn dev_err_probe(tps65910->dev, PTR_ERR(rdev),\n\t\t\t\t\t     \"failed to register %s regulator\\n\",\n\t\t\t\t\t     pdev->name);\n\n\t\t \n\t\tpmic->rdev[i] = rdev;\n\t}\n\treturn 0;\n}\n\nstatic void tps65910_shutdown(struct platform_device *pdev)\n{\n\tstruct tps65910_reg *pmic = platform_get_drvdata(pdev);\n\tint i;\n\n\t \n\tfor (i = 0; i < pmic->num_regulators; i++) {\n\t\tint err;\n\t\tif (!pmic->rdev[i])\n\t\t\tcontinue;\n\n\t\terr = tps65910_set_ext_sleep_config(pmic, i, 0);\n\t\tif (err < 0)\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Error in clearing external control\\n\");\n\t}\n}\n\nstatic struct platform_driver tps65910_driver = {\n\t.driver = {\n\t\t.name = \"tps65910-pmic\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = tps65910_probe,\n\t.shutdown = tps65910_shutdown,\n};\n\nstatic int __init tps65910_init(void)\n{\n\treturn platform_driver_register(&tps65910_driver);\n}\nsubsys_initcall(tps65910_init);\n\nstatic void __exit tps65910_cleanup(void)\n{\n\tplatform_driver_unregister(&tps65910_driver);\n}\nmodule_exit(tps65910_cleanup);\n\nMODULE_AUTHOR(\"Graeme Gregory <gg@slimlogic.co.uk>\");\nMODULE_DESCRIPTION(\"TPS65910/TPS65911 voltage regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:tps65910-pmic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}