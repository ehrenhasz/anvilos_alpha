{
  "module_name": "max8649.c",
  "hash_id": "0c221d323455ddadd8850483ed01f64fb631e477c97818b809f8d2edb54a71b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/max8649.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/slab.h>\n#include <linux/regulator/max8649.h>\n#include <linux/regmap.h>\n\n#define MAX8649_DCDC_VMIN\t750000\t\t \n#define MAX8649_DCDC_VMAX\t1380000\t\t \n#define MAX8649_DCDC_STEP\t10000\t\t \n#define MAX8649_VOL_MASK\t0x3f\n\n \n#define MAX8649_MODE0\t\t0x00\n#define MAX8649_MODE1\t\t0x01\n#define MAX8649_MODE2\t\t0x02\n#define MAX8649_MODE3\t\t0x03\n#define MAX8649_CONTROL\t\t0x04\n#define MAX8649_SYNC\t\t0x05\n#define MAX8649_RAMP\t\t0x06\n#define MAX8649_CHIP_ID1\t0x08\n#define MAX8649_CHIP_ID2\t0x09\n\n \n#define MAX8649_EN_PD\t\t(1 << 7)\n#define MAX8649_VID0_PD\t\t(1 << 6)\n#define MAX8649_VID1_PD\t\t(1 << 5)\n#define MAX8649_VID_MASK\t(3 << 5)\n\n#define MAX8649_FORCE_PWM\t(1 << 7)\n#define MAX8649_SYNC_EXTCLK\t(1 << 6)\n\n#define MAX8649_EXT_MASK\t(3 << 6)\n\n#define MAX8649_RAMP_MASK\t(7 << 5)\n#define MAX8649_RAMP_DOWN\t(1 << 1)\n\nstruct max8649_regulator_info {\n\tstruct device\t\t*dev;\n\tstruct regmap\t\t*regmap;\n\n\tunsigned\tmode:2;\t \n\tunsigned\textclk_freq:2;\n\tunsigned\textclk:1;\n\tunsigned\tramp_timing:3;\n\tunsigned\tramp_down:1;\n};\n\nstatic int max8649_enable_time(struct regulator_dev *rdev)\n{\n\tstruct max8649_regulator_info *info = rdev_get_drvdata(rdev);\n\tint voltage, rate, ret;\n\tunsigned int val;\n\n\t \n\tret = regmap_read(info->regmap, rdev->desc->vsel_reg, &val);\n\tif (ret != 0)\n\t\treturn ret;\n\tval &= MAX8649_VOL_MASK;\n\tvoltage = regulator_list_voltage_linear(rdev, (unsigned char)val);\n\n\t \n\tret = regmap_read(info->regmap, MAX8649_RAMP, &val);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = (val & MAX8649_RAMP_MASK) >> 5;\n\trate = (32 * 1000) >> ret;\t \n\n\treturn DIV_ROUND_UP(voltage, rate);\n}\n\nstatic int max8649_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct max8649_regulator_info *info = rdev_get_drvdata(rdev);\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tregmap_update_bits(info->regmap, rdev->desc->vsel_reg,\n\t\t\t\t   MAX8649_FORCE_PWM, MAX8649_FORCE_PWM);\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tregmap_update_bits(info->regmap, rdev->desc->vsel_reg,\n\t\t\t\t   MAX8649_FORCE_PWM, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic unsigned int max8649_get_mode(struct regulator_dev *rdev)\n{\n\tstruct max8649_regulator_info *info = rdev_get_drvdata(rdev);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(info->regmap, rdev->desc->vsel_reg, &val);\n\tif (ret != 0)\n\t\treturn ret;\n\tif (val & MAX8649_FORCE_PWM)\n\t\treturn REGULATOR_MODE_FAST;\n\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic const struct regulator_ops max8649_dcdc_ops = {\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.list_voltage\t= regulator_list_voltage_linear,\n\t.map_voltage\t= regulator_map_voltage_linear,\n\t.enable\t\t= regulator_enable_regmap,\n\t.disable\t= regulator_disable_regmap,\n\t.is_enabled\t= regulator_is_enabled_regmap,\n\t.enable_time\t= max8649_enable_time,\n\t.set_mode\t= max8649_set_mode,\n\t.get_mode\t= max8649_get_mode,\n\n};\n\nstatic struct regulator_desc dcdc_desc = {\n\t.name\t\t= \"max8649\",\n\t.ops\t\t= &max8649_dcdc_ops,\n\t.type\t\t= REGULATOR_VOLTAGE,\n\t.n_voltages\t= 1 << 6,\n\t.owner\t\t= THIS_MODULE,\n\t.vsel_mask\t= MAX8649_VOL_MASK,\n\t.min_uV\t\t= MAX8649_DCDC_VMIN,\n\t.uV_step\t= MAX8649_DCDC_STEP,\n\t.enable_reg\t= MAX8649_CONTROL,\n\t.enable_mask\t= MAX8649_EN_PD,\n\t.enable_is_inverted = true,\n};\n\nstatic const struct regmap_config max8649_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int max8649_regulator_probe(struct i2c_client *client)\n{\n\tstruct max8649_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct max8649_regulator_info *info = NULL;\n\tstruct regulator_dev *regulator;\n\tstruct regulator_config config = { };\n\tunsigned int val;\n\tunsigned char data;\n\tint ret;\n\n\tinfo = devm_kzalloc(&client->dev, sizeof(struct max8649_regulator_info),\n\t\t\t    GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->regmap = devm_regmap_init_i2c(client, &max8649_regmap_config);\n\tif (IS_ERR(info->regmap)) {\n\t\tret = PTR_ERR(info->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinfo->dev = &client->dev;\n\ti2c_set_clientdata(client, info);\n\n\tinfo->mode = pdata->mode;\n\tswitch (info->mode) {\n\tcase 0:\n\t\tdcdc_desc.vsel_reg = MAX8649_MODE0;\n\t\tbreak;\n\tcase 1:\n\t\tdcdc_desc.vsel_reg = MAX8649_MODE1;\n\t\tbreak;\n\tcase 2:\n\t\tdcdc_desc.vsel_reg = MAX8649_MODE2;\n\t\tbreak;\n\tcase 3:\n\t\tdcdc_desc.vsel_reg = MAX8649_MODE3;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = regmap_read(info->regmap, MAX8649_CHIP_ID1, &val);\n\tif (ret != 0) {\n\t\tdev_err(info->dev, \"Failed to detect ID of MAX8649:%d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tdev_info(info->dev, \"Detected MAX8649 (ID:%x)\\n\", val);\n\n\t \n\tregmap_update_bits(info->regmap, MAX8649_CONTROL, MAX8649_VID_MASK, 0);\n\n\t \n\tinfo->extclk = pdata->extclk;\n\tdata = (info->extclk) ? MAX8649_SYNC_EXTCLK : 0;\n\tregmap_update_bits(info->regmap, dcdc_desc.vsel_reg,\n\t\t\t   MAX8649_SYNC_EXTCLK, data);\n\tif (info->extclk) {\n\t\t \n\t\tinfo->extclk_freq = pdata->extclk_freq;\n\t\tregmap_update_bits(info->regmap, MAX8649_SYNC, MAX8649_EXT_MASK,\n\t\t\t\t   info->extclk_freq << 6);\n\t}\n\n\tif (pdata->ramp_timing) {\n\t\tinfo->ramp_timing = pdata->ramp_timing;\n\t\tregmap_update_bits(info->regmap, MAX8649_RAMP, MAX8649_RAMP_MASK,\n\t\t\t\t   info->ramp_timing << 5);\n\t}\n\n\tinfo->ramp_down = pdata->ramp_down;\n\tif (info->ramp_down) {\n\t\tregmap_update_bits(info->regmap, MAX8649_RAMP, MAX8649_RAMP_DOWN,\n\t\t\t\t   MAX8649_RAMP_DOWN);\n\t}\n\n\tconfig.dev = &client->dev;\n\tconfig.init_data = pdata->regulator;\n\tconfig.driver_data = info;\n\tconfig.regmap = info->regmap;\n\n\tregulator = devm_regulator_register(&client->dev, &dcdc_desc,\n\t\t\t\t\t\t  &config);\n\tif (IS_ERR(regulator)) {\n\t\tdev_err(info->dev, \"failed to register regulator %s\\n\",\n\t\t\tdcdc_desc.name);\n\t\treturn PTR_ERR(regulator);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id max8649_id[] = {\n\t{ \"max8649\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max8649_id);\n\nstatic struct i2c_driver max8649_driver = {\n\t.probe\t\t= max8649_regulator_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"max8649\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.id_table\t= max8649_id,\n};\n\nstatic int __init max8649_init(void)\n{\n\treturn i2c_add_driver(&max8649_driver);\n}\nsubsys_initcall(max8649_init);\n\nstatic void __exit max8649_exit(void)\n{\n\ti2c_del_driver(&max8649_driver);\n}\nmodule_exit(max8649_exit);\n\n \nMODULE_DESCRIPTION(\"MAXIM 8649 voltage regulator driver\");\nMODULE_AUTHOR(\"Haojian Zhuang <haojian.zhuang@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}