{
  "module_name": "core.c",
  "hash_id": "ee545c509aae59e49af6170b5b1820007d9efd930b675948f7dd68bb20291534",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/core.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/async.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/suspend.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regulator/coupler.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/module.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/regulator.h>\n\n#include \"dummy.h\"\n#include \"internal.h\"\n\nstatic DEFINE_WW_CLASS(regulator_ww_class);\nstatic DEFINE_MUTEX(regulator_nesting_mutex);\nstatic DEFINE_MUTEX(regulator_list_mutex);\nstatic LIST_HEAD(regulator_map_list);\nstatic LIST_HEAD(regulator_ena_gpio_list);\nstatic LIST_HEAD(regulator_supply_alias_list);\nstatic LIST_HEAD(regulator_coupler_list);\nstatic bool has_full_constraints;\n\nstatic struct dentry *debugfs_root;\n\n \nstruct regulator_map {\n\tstruct list_head list;\n\tconst char *dev_name;    \n\tconst char *supply;\n\tstruct regulator_dev *regulator;\n};\n\n \nstruct regulator_enable_gpio {\n\tstruct list_head list;\n\tstruct gpio_desc *gpiod;\n\tu32 enable_count;\t \n\tu32 request_count;\t \n};\n\n \nstruct regulator_supply_alias {\n\tstruct list_head list;\n\tstruct device *src_dev;\n\tconst char *src_supply;\n\tstruct device *alias_dev;\n\tconst char *alias_supply;\n};\n\nstatic int _regulator_is_enabled(struct regulator_dev *rdev);\nstatic int _regulator_disable(struct regulator *regulator);\nstatic int _regulator_get_error_flags(struct regulator_dev *rdev, unsigned int *flags);\nstatic int _regulator_get_current_limit(struct regulator_dev *rdev);\nstatic unsigned int _regulator_get_mode(struct regulator_dev *rdev);\nstatic int _notifier_call_chain(struct regulator_dev *rdev,\n\t\t\t\t  unsigned long event, void *data);\nstatic int _regulator_do_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t     int min_uV, int max_uV);\nstatic int regulator_balance_voltage(struct regulator_dev *rdev,\n\t\t\t\t     suspend_state_t state);\nstatic struct regulator *create_regulator(struct regulator_dev *rdev,\n\t\t\t\t\t  struct device *dev,\n\t\t\t\t\t  const char *supply_name);\nstatic void destroy_regulator(struct regulator *regulator);\nstatic void _regulator_put(struct regulator *regulator);\n\nconst char *rdev_get_name(struct regulator_dev *rdev)\n{\n\tif (rdev->constraints && rdev->constraints->name)\n\t\treturn rdev->constraints->name;\n\telse if (rdev->desc->name)\n\t\treturn rdev->desc->name;\n\telse\n\t\treturn \"\";\n}\nEXPORT_SYMBOL_GPL(rdev_get_name);\n\nstatic bool have_full_constraints(void)\n{\n\treturn has_full_constraints || of_have_populated_dt();\n}\n\nstatic bool regulator_ops_is_valid(struct regulator_dev *rdev, int ops)\n{\n\tif (!rdev->constraints) {\n\t\trdev_err(rdev, \"no constraints\\n\");\n\t\treturn false;\n\t}\n\n\tif (rdev->constraints->valid_ops_mask & ops)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic inline int regulator_lock_nested(struct regulator_dev *rdev,\n\t\t\t\t\tstruct ww_acquire_ctx *ww_ctx)\n{\n\tbool lock = false;\n\tint ret = 0;\n\n\tmutex_lock(&regulator_nesting_mutex);\n\n\tif (!ww_mutex_trylock(&rdev->mutex, ww_ctx)) {\n\t\tif (rdev->mutex_owner == current)\n\t\t\trdev->ref_cnt++;\n\t\telse\n\t\t\tlock = true;\n\n\t\tif (lock) {\n\t\t\tmutex_unlock(&regulator_nesting_mutex);\n\t\t\tret = ww_mutex_lock(&rdev->mutex, ww_ctx);\n\t\t\tmutex_lock(&regulator_nesting_mutex);\n\t\t}\n\t} else {\n\t\tlock = true;\n\t}\n\n\tif (lock && ret != -EDEADLK) {\n\t\trdev->ref_cnt++;\n\t\trdev->mutex_owner = current;\n\t}\n\n\tmutex_unlock(&regulator_nesting_mutex);\n\n\treturn ret;\n}\n\n \nstatic void regulator_lock(struct regulator_dev *rdev)\n{\n\tregulator_lock_nested(rdev, NULL);\n}\n\n \nstatic void regulator_unlock(struct regulator_dev *rdev)\n{\n\tmutex_lock(&regulator_nesting_mutex);\n\n\tif (--rdev->ref_cnt == 0) {\n\t\trdev->mutex_owner = NULL;\n\t\tww_mutex_unlock(&rdev->mutex);\n\t}\n\n\tWARN_ON_ONCE(rdev->ref_cnt < 0);\n\n\tmutex_unlock(&regulator_nesting_mutex);\n}\n\n \nstatic void regulator_lock_two(struct regulator_dev *rdev1,\n\t\t\t       struct regulator_dev *rdev2,\n\t\t\t       struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct regulator_dev *held, *contended;\n\tint ret;\n\n\tww_acquire_init(ww_ctx, &regulator_ww_class);\n\n\t \n\tret = regulator_lock_nested(rdev1, ww_ctx);\n\tWARN_ON(ret);\n\tret = regulator_lock_nested(rdev2, ww_ctx);\n\tif (ret != -EDEADLOCK) {\n\t\tWARN_ON(ret);\n\t\tgoto exit;\n\t}\n\n\theld = rdev1;\n\tcontended = rdev2;\n\twhile (true) {\n\t\tregulator_unlock(held);\n\n\t\tww_mutex_lock_slow(&contended->mutex, ww_ctx);\n\t\tcontended->ref_cnt++;\n\t\tcontended->mutex_owner = current;\n\t\tswap(held, contended);\n\t\tret = regulator_lock_nested(contended, ww_ctx);\n\n\t\tif (ret != -EDEADLOCK) {\n\t\t\tWARN_ON(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\nexit:\n\tww_acquire_done(ww_ctx);\n}\n\n \n\nstatic void regulator_unlock_two(struct regulator_dev *rdev1,\n\t\t\t\t struct regulator_dev *rdev2,\n\t\t\t\t struct ww_acquire_ctx *ww_ctx)\n{\n\tregulator_unlock(rdev2);\n\tregulator_unlock(rdev1);\n\tww_acquire_fini(ww_ctx);\n}\n\nstatic bool regulator_supply_is_couple(struct regulator_dev *rdev)\n{\n\tstruct regulator_dev *c_rdev;\n\tint i;\n\n\tfor (i = 1; i < rdev->coupling_desc.n_coupled; i++) {\n\t\tc_rdev = rdev->coupling_desc.coupled_rdevs[i];\n\n\t\tif (rdev->supply->rdev == c_rdev)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void regulator_unlock_recursive(struct regulator_dev *rdev,\n\t\t\t\t       unsigned int n_coupled)\n{\n\tstruct regulator_dev *c_rdev, *supply_rdev;\n\tint i, supply_n_coupled;\n\n\tfor (i = n_coupled; i > 0; i--) {\n\t\tc_rdev = rdev->coupling_desc.coupled_rdevs[i - 1];\n\n\t\tif (!c_rdev)\n\t\t\tcontinue;\n\n\t\tif (c_rdev->supply && !regulator_supply_is_couple(c_rdev)) {\n\t\t\tsupply_rdev = c_rdev->supply->rdev;\n\t\t\tsupply_n_coupled = supply_rdev->coupling_desc.n_coupled;\n\n\t\t\tregulator_unlock_recursive(supply_rdev,\n\t\t\t\t\t\t   supply_n_coupled);\n\t\t}\n\n\t\tregulator_unlock(c_rdev);\n\t}\n}\n\nstatic int regulator_lock_recursive(struct regulator_dev *rdev,\n\t\t\t\t    struct regulator_dev **new_contended_rdev,\n\t\t\t\t    struct regulator_dev **old_contended_rdev,\n\t\t\t\t    struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct regulator_dev *c_rdev;\n\tint i, err;\n\n\tfor (i = 0; i < rdev->coupling_desc.n_coupled; i++) {\n\t\tc_rdev = rdev->coupling_desc.coupled_rdevs[i];\n\n\t\tif (!c_rdev)\n\t\t\tcontinue;\n\n\t\tif (c_rdev != *old_contended_rdev) {\n\t\t\terr = regulator_lock_nested(c_rdev, ww_ctx);\n\t\t\tif (err) {\n\t\t\t\tif (err == -EDEADLK) {\n\t\t\t\t\t*new_contended_rdev = c_rdev;\n\t\t\t\t\tgoto err_unlock;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tWARN_ON_ONCE(err != -EALREADY);\n\t\t\t}\n\t\t} else {\n\t\t\t*old_contended_rdev = NULL;\n\t\t}\n\n\t\tif (c_rdev->supply && !regulator_supply_is_couple(c_rdev)) {\n\t\t\terr = regulator_lock_recursive(c_rdev->supply->rdev,\n\t\t\t\t\t\t       new_contended_rdev,\n\t\t\t\t\t\t       old_contended_rdev,\n\t\t\t\t\t\t       ww_ctx);\n\t\t\tif (err) {\n\t\t\t\tregulator_unlock(c_rdev);\n\t\t\t\tgoto err_unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_unlock:\n\tregulator_unlock_recursive(rdev, i);\n\n\treturn err;\n}\n\n \nstatic void regulator_unlock_dependent(struct regulator_dev *rdev,\n\t\t\t\t       struct ww_acquire_ctx *ww_ctx)\n{\n\tregulator_unlock_recursive(rdev, rdev->coupling_desc.n_coupled);\n\tww_acquire_fini(ww_ctx);\n}\n\n \nstatic void regulator_lock_dependent(struct regulator_dev *rdev,\n\t\t\t\t     struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct regulator_dev *new_contended_rdev = NULL;\n\tstruct regulator_dev *old_contended_rdev = NULL;\n\tint err;\n\n\tmutex_lock(&regulator_list_mutex);\n\n\tww_acquire_init(ww_ctx, &regulator_ww_class);\n\n\tdo {\n\t\tif (new_contended_rdev) {\n\t\t\tww_mutex_lock_slow(&new_contended_rdev->mutex, ww_ctx);\n\t\t\told_contended_rdev = new_contended_rdev;\n\t\t\told_contended_rdev->ref_cnt++;\n\t\t\told_contended_rdev->mutex_owner = current;\n\t\t}\n\n\t\terr = regulator_lock_recursive(rdev,\n\t\t\t\t\t       &new_contended_rdev,\n\t\t\t\t\t       &old_contended_rdev,\n\t\t\t\t\t       ww_ctx);\n\n\t\tif (old_contended_rdev)\n\t\t\tregulator_unlock(old_contended_rdev);\n\n\t} while (err == -EDEADLK);\n\n\tww_acquire_done(ww_ctx);\n\n\tmutex_unlock(&regulator_list_mutex);\n}\n\n \nstatic struct device_node *of_get_child_regulator(struct device_node *parent,\n\t\t\t\t\t\t  const char *prop_name)\n{\n\tstruct device_node *regnode = NULL;\n\tstruct device_node *child = NULL;\n\n\tfor_each_child_of_node(parent, child) {\n\t\tregnode = of_parse_phandle(child, prop_name, 0);\n\n\t\tif (!regnode) {\n\t\t\tregnode = of_get_child_regulator(child, prop_name);\n\t\t\tif (regnode)\n\t\t\t\tgoto err_node_put;\n\t\t} else {\n\t\t\tgoto err_node_put;\n\t\t}\n\t}\n\treturn NULL;\n\nerr_node_put:\n\tof_node_put(child);\n\treturn regnode;\n}\n\n \nstatic struct device_node *of_get_regulator(struct device *dev, const char *supply)\n{\n\tstruct device_node *regnode = NULL;\n\tchar prop_name[64];  \n\n\tdev_dbg(dev, \"Looking up %s-supply from device tree\\n\", supply);\n\n\tsnprintf(prop_name, 64, \"%s-supply\", supply);\n\tregnode = of_parse_phandle(dev->of_node, prop_name, 0);\n\n\tif (!regnode) {\n\t\tregnode = of_get_child_regulator(dev->of_node, prop_name);\n\t\tif (regnode)\n\t\t\treturn regnode;\n\n\t\tdev_dbg(dev, \"Looking up %s property in node %pOF failed\\n\",\n\t\t\t\tprop_name, dev->of_node);\n\t\treturn NULL;\n\t}\n\treturn regnode;\n}\n\n \nint regulator_check_voltage(struct regulator_dev *rdev,\n\t\t\t    int *min_uV, int *max_uV)\n{\n\tBUG_ON(*min_uV > *max_uV);\n\n\tif (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE)) {\n\t\trdev_err(rdev, \"voltage operation not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (*max_uV > rdev->constraints->max_uV)\n\t\t*max_uV = rdev->constraints->max_uV;\n\tif (*min_uV < rdev->constraints->min_uV)\n\t\t*min_uV = rdev->constraints->min_uV;\n\n\tif (*min_uV > *max_uV) {\n\t\trdev_err(rdev, \"unsupportable voltage range: %d-%duV\\n\",\n\t\t\t *min_uV, *max_uV);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int regulator_check_states(suspend_state_t state)\n{\n\treturn (state > PM_SUSPEND_MAX || state == PM_SUSPEND_TO_IDLE);\n}\n\n \nint regulator_check_consumers(struct regulator_dev *rdev,\n\t\t\t      int *min_uV, int *max_uV,\n\t\t\t      suspend_state_t state)\n{\n\tstruct regulator *regulator;\n\tstruct regulator_voltage *voltage;\n\n\tlist_for_each_entry(regulator, &rdev->consumer_list, list) {\n\t\tvoltage = &regulator->voltage[state];\n\t\t \n\t\tif (!voltage->min_uV && !voltage->max_uV)\n\t\t\tcontinue;\n\n\t\tif (*max_uV > voltage->max_uV)\n\t\t\t*max_uV = voltage->max_uV;\n\t\tif (*min_uV < voltage->min_uV)\n\t\t\t*min_uV = voltage->min_uV;\n\t}\n\n\tif (*min_uV > *max_uV) {\n\t\trdev_err(rdev, \"Restricting voltage, %u-%uuV\\n\",\n\t\t\t*min_uV, *max_uV);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int regulator_check_current_limit(struct regulator_dev *rdev,\n\t\t\t\t\tint *min_uA, int *max_uA)\n{\n\tBUG_ON(*min_uA > *max_uA);\n\n\tif (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_CURRENT)) {\n\t\trdev_err(rdev, \"current operation not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (*max_uA > rdev->constraints->max_uA)\n\t\t*max_uA = rdev->constraints->max_uA;\n\tif (*min_uA < rdev->constraints->min_uA)\n\t\t*min_uA = rdev->constraints->min_uA;\n\n\tif (*min_uA > *max_uA) {\n\t\trdev_err(rdev, \"unsupportable current range: %d-%duA\\n\",\n\t\t\t *min_uA, *max_uA);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int regulator_mode_constrain(struct regulator_dev *rdev,\n\t\t\t\t    unsigned int *mode)\n{\n\tswitch (*mode) {\n\tcase REGULATOR_MODE_FAST:\n\tcase REGULATOR_MODE_NORMAL:\n\tcase REGULATOR_MODE_IDLE:\n\tcase REGULATOR_MODE_STANDBY:\n\t\tbreak;\n\tdefault:\n\t\trdev_err(rdev, \"invalid mode %x specified\\n\", *mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_MODE)) {\n\t\trdev_err(rdev, \"mode operation not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\twhile (*mode) {\n\t\tif (rdev->constraints->valid_modes_mask & *mode)\n\t\t\treturn 0;\n\t\t*mode /= 2;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic inline struct regulator_state *\nregulator_get_suspend_state(struct regulator_dev *rdev, suspend_state_t state)\n{\n\tif (rdev->constraints == NULL)\n\t\treturn NULL;\n\n\tswitch (state) {\n\tcase PM_SUSPEND_STANDBY:\n\t\treturn &rdev->constraints->state_standby;\n\tcase PM_SUSPEND_MEM:\n\t\treturn &rdev->constraints->state_mem;\n\tcase PM_SUSPEND_MAX:\n\t\treturn &rdev->constraints->state_disk;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic const struct regulator_state *\nregulator_get_suspend_state_check(struct regulator_dev *rdev, suspend_state_t state)\n{\n\tconst struct regulator_state *rstate;\n\n\trstate = regulator_get_suspend_state(rdev, state);\n\tif (rstate == NULL)\n\t\treturn NULL;\n\n\t \n\tif (rstate->enabled != ENABLE_IN_SUSPEND &&\n\t    rstate->enabled != DISABLE_IN_SUSPEND) {\n\t\tif (rdev->desc->ops->set_suspend_voltage ||\n\t\t    rdev->desc->ops->set_suspend_mode)\n\t\t\trdev_warn(rdev, \"No configuration\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn rstate;\n}\n\nstatic ssize_t microvolts_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tint uV;\n\n\tregulator_lock(rdev);\n\tuV = regulator_get_voltage_rdev(rdev);\n\tregulator_unlock(rdev);\n\n\tif (uV < 0)\n\t\treturn uV;\n\treturn sprintf(buf, \"%d\\n\", uV);\n}\nstatic DEVICE_ATTR_RO(microvolts);\n\nstatic ssize_t microamps_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", _regulator_get_current_limit(rdev));\n}\nstatic DEVICE_ATTR_RO(microamps);\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", rdev_get_name(rdev));\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic const char *regulator_opmode_to_str(int mode)\n{\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\treturn \"fast\";\n\tcase REGULATOR_MODE_NORMAL:\n\t\treturn \"normal\";\n\tcase REGULATOR_MODE_IDLE:\n\t\treturn \"idle\";\n\tcase REGULATOR_MODE_STANDBY:\n\t\treturn \"standby\";\n\t}\n\treturn \"unknown\";\n}\n\nstatic ssize_t regulator_print_opmode(char *buf, int mode)\n{\n\treturn sprintf(buf, \"%s\\n\", regulator_opmode_to_str(mode));\n}\n\nstatic ssize_t opmode_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_opmode(buf, _regulator_get_mode(rdev));\n}\nstatic DEVICE_ATTR_RO(opmode);\n\nstatic ssize_t regulator_print_state(char *buf, int state)\n{\n\tif (state > 0)\n\t\treturn sprintf(buf, \"enabled\\n\");\n\telse if (state == 0)\n\t\treturn sprintf(buf, \"disabled\\n\");\n\telse\n\t\treturn sprintf(buf, \"unknown\\n\");\n}\n\nstatic ssize_t state_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tssize_t ret;\n\n\tregulator_lock(rdev);\n\tret = regulator_print_state(buf, _regulator_is_enabled(rdev));\n\tregulator_unlock(rdev);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(state);\n\nstatic ssize_t status_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tint status;\n\tchar *label;\n\n\tstatus = rdev->desc->ops->get_status(rdev);\n\tif (status < 0)\n\t\treturn status;\n\n\tswitch (status) {\n\tcase REGULATOR_STATUS_OFF:\n\t\tlabel = \"off\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_ON:\n\t\tlabel = \"on\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_ERROR:\n\t\tlabel = \"error\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_FAST:\n\t\tlabel = \"fast\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_NORMAL:\n\t\tlabel = \"normal\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_IDLE:\n\t\tlabel = \"idle\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_STANDBY:\n\t\tlabel = \"standby\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_BYPASS:\n\t\tlabel = \"bypass\";\n\t\tbreak;\n\tcase REGULATOR_STATUS_UNDEFINED:\n\t\tlabel = \"undefined\";\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", label);\n}\nstatic DEVICE_ATTR_RO(status);\n\nstatic ssize_t min_microamps_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->min_uA);\n}\nstatic DEVICE_ATTR_RO(min_microamps);\n\nstatic ssize_t max_microamps_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->max_uA);\n}\nstatic DEVICE_ATTR_RO(max_microamps);\n\nstatic ssize_t min_microvolts_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->min_uV);\n}\nstatic DEVICE_ATTR_RO(min_microvolts);\n\nstatic ssize_t max_microvolts_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tif (!rdev->constraints)\n\t\treturn sprintf(buf, \"constraint not defined\\n\");\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->max_uV);\n}\nstatic DEVICE_ATTR_RO(max_microvolts);\n\nstatic ssize_t requested_microamps_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tstruct regulator *regulator;\n\tint uA = 0;\n\n\tregulator_lock(rdev);\n\tlist_for_each_entry(regulator, &rdev->consumer_list, list) {\n\t\tif (regulator->enable_count)\n\t\t\tuA += regulator->uA_load;\n\t}\n\tregulator_unlock(rdev);\n\treturn sprintf(buf, \"%d\\n\", uA);\n}\nstatic DEVICE_ATTR_RO(requested_microamps);\n\nstatic ssize_t num_users_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%d\\n\", rdev->use_count);\n}\nstatic DEVICE_ATTR_RO(num_users);\n\nstatic ssize_t type_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tswitch (rdev->desc->type) {\n\tcase REGULATOR_VOLTAGE:\n\t\treturn sprintf(buf, \"voltage\\n\");\n\tcase REGULATOR_CURRENT:\n\t\treturn sprintf(buf, \"current\\n\");\n\t}\n\treturn sprintf(buf, \"unknown\\n\");\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic ssize_t suspend_mem_microvolts_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->state_mem.uV);\n}\nstatic DEVICE_ATTR_RO(suspend_mem_microvolts);\n\nstatic ssize_t suspend_disk_microvolts_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->state_disk.uV);\n}\nstatic DEVICE_ATTR_RO(suspend_disk_microvolts);\n\nstatic ssize_t suspend_standby_microvolts_show(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", rdev->constraints->state_standby.uV);\n}\nstatic DEVICE_ATTR_RO(suspend_standby_microvolts);\n\nstatic ssize_t suspend_mem_mode_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_opmode(buf,\n\t\trdev->constraints->state_mem.mode);\n}\nstatic DEVICE_ATTR_RO(suspend_mem_mode);\n\nstatic ssize_t suspend_disk_mode_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_opmode(buf,\n\t\trdev->constraints->state_disk.mode);\n}\nstatic DEVICE_ATTR_RO(suspend_disk_mode);\n\nstatic ssize_t suspend_standby_mode_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_opmode(buf,\n\t\trdev->constraints->state_standby.mode);\n}\nstatic DEVICE_ATTR_RO(suspend_standby_mode);\n\nstatic ssize_t suspend_mem_state_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_state(buf,\n\t\t\trdev->constraints->state_mem.enabled);\n}\nstatic DEVICE_ATTR_RO(suspend_mem_state);\n\nstatic ssize_t suspend_disk_state_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_state(buf,\n\t\t\trdev->constraints->state_disk.enabled);\n}\nstatic DEVICE_ATTR_RO(suspend_disk_state);\n\nstatic ssize_t suspend_standby_state_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_state(buf,\n\t\t\trdev->constraints->state_standby.enabled);\n}\nstatic DEVICE_ATTR_RO(suspend_standby_state);\n\nstatic ssize_t bypass_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\tconst char *report;\n\tbool bypass;\n\tint ret;\n\n\tret = rdev->desc->ops->get_bypass(rdev, &bypass);\n\n\tif (ret != 0)\n\t\treport = \"unknown\";\n\telse if (bypass)\n\t\treport = \"enabled\";\n\telse\n\t\treport = \"disabled\";\n\n\treturn sprintf(buf, \"%s\\n\", report);\n}\nstatic DEVICE_ATTR_RO(bypass);\n\n#define REGULATOR_ERROR_ATTR(name, bit)\t\t\t\t\t\t\t\\\n\tstatic ssize_t name##_show(struct device *dev, struct device_attribute *attr,\t\\\n\t\t\t\t   char *buf)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\\\n\t\tint ret;\t\t\t\t\t\t\t\t\\\n\t\tunsigned int flags;\t\t\t\t\t\t\t\\\n\t\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\t\t\t\\\n\t\tret = _regulator_get_error_flags(rdev, &flags);\t\t\t\t\\\n\t\tif (ret)\t\t\t\t\t\t\t\t\\\n\t\t\treturn ret;\t\t\t\t\t\t\t\\\n\t\treturn sysfs_emit(buf, \"%d\\n\", !!(flags & (bit)));\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n\tstatic DEVICE_ATTR_RO(name)\n\nREGULATOR_ERROR_ATTR(under_voltage, REGULATOR_ERROR_UNDER_VOLTAGE);\nREGULATOR_ERROR_ATTR(over_current, REGULATOR_ERROR_OVER_CURRENT);\nREGULATOR_ERROR_ATTR(regulation_out, REGULATOR_ERROR_REGULATION_OUT);\nREGULATOR_ERROR_ATTR(fail, REGULATOR_ERROR_FAIL);\nREGULATOR_ERROR_ATTR(over_temp, REGULATOR_ERROR_OVER_TEMP);\nREGULATOR_ERROR_ATTR(under_voltage_warn, REGULATOR_ERROR_UNDER_VOLTAGE_WARN);\nREGULATOR_ERROR_ATTR(over_current_warn, REGULATOR_ERROR_OVER_CURRENT_WARN);\nREGULATOR_ERROR_ATTR(over_voltage_warn, REGULATOR_ERROR_OVER_VOLTAGE_WARN);\nREGULATOR_ERROR_ATTR(over_temp_warn, REGULATOR_ERROR_OVER_TEMP_WARN);\n\n \nstatic int drms_uA_update(struct regulator_dev *rdev)\n{\n\tstruct regulator *sibling;\n\tint current_uA = 0, output_uV, input_uV, err;\n\tunsigned int mode;\n\n\t \n\tif (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_DRMS)) {\n\t\trdev_dbg(rdev, \"DRMS operation not allowed\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!rdev->desc->ops->get_optimum_mode &&\n\t    !rdev->desc->ops->set_load)\n\t\treturn 0;\n\n\tif (!rdev->desc->ops->set_mode &&\n\t    !rdev->desc->ops->set_load)\n\t\treturn -EINVAL;\n\n\t \n\tlist_for_each_entry(sibling, &rdev->consumer_list, list) {\n\t\tif (sibling->enable_count)\n\t\t\tcurrent_uA += sibling->uA_load;\n\t}\n\n\tcurrent_uA += rdev->constraints->system_load;\n\n\tif (rdev->desc->ops->set_load) {\n\t\t \n\t\terr = rdev->desc->ops->set_load(rdev, current_uA);\n\t\tif (err < 0)\n\t\t\trdev_err(rdev, \"failed to set load %d: %pe\\n\",\n\t\t\t\t current_uA, ERR_PTR(err));\n\t} else {\n\t\t \n\t\tif (!rdev->constraints->valid_modes_mask) {\n\t\t\trdev_dbg(rdev, \"Can change modes; but no valid mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\toutput_uV = regulator_get_voltage_rdev(rdev);\n\n\t\t \n\t\tif (output_uV <= 0)\n\t\t\trdev_dbg(rdev, \"invalid output voltage found\\n\");\n\n\t\t \n\t\tinput_uV = 0;\n\t\tif (rdev->supply)\n\t\t\tinput_uV = regulator_get_voltage_rdev(rdev->supply->rdev);\n\t\tif (input_uV <= 0)\n\t\t\tinput_uV = rdev->constraints->input_uV;\n\n\t\t \n\t\tif (input_uV <= 0)\n\t\t\trdev_dbg(rdev, \"invalid input voltage found\\n\");\n\n\t\t \n\t\tmode = rdev->desc->ops->get_optimum_mode(rdev, input_uV,\n\t\t\t\t\t\t\t output_uV, current_uA);\n\n\t\t \n\t\terr = regulator_mode_constrain(rdev, &mode);\n\t\tif (err < 0) {\n\t\t\trdev_err(rdev, \"failed to get optimum mode @ %d uA %d -> %d uV: %pe\\n\",\n\t\t\t\t current_uA, input_uV, output_uV, ERR_PTR(err));\n\t\t\treturn err;\n\t\t}\n\n\t\terr = rdev->desc->ops->set_mode(rdev, mode);\n\t\tif (err < 0)\n\t\t\trdev_err(rdev, \"failed to set optimum mode %x: %pe\\n\",\n\t\t\t\t mode, ERR_PTR(err));\n\t}\n\n\treturn err;\n}\n\nstatic int __suspend_set_state(struct regulator_dev *rdev,\n\t\t\t       const struct regulator_state *rstate)\n{\n\tint ret = 0;\n\n\tif (rstate->enabled == ENABLE_IN_SUSPEND &&\n\t\trdev->desc->ops->set_suspend_enable)\n\t\tret = rdev->desc->ops->set_suspend_enable(rdev);\n\telse if (rstate->enabled == DISABLE_IN_SUSPEND &&\n\t\trdev->desc->ops->set_suspend_disable)\n\t\tret = rdev->desc->ops->set_suspend_disable(rdev);\n\telse  \n\t\tret = 0;\n\n\tif (ret < 0) {\n\t\trdev_err(rdev, \"failed to enabled/disable: %pe\\n\", ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tif (rdev->desc->ops->set_suspend_voltage && rstate->uV > 0) {\n\t\tret = rdev->desc->ops->set_suspend_voltage(rdev, rstate->uV);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set voltage: %pe\\n\", ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (rdev->desc->ops->set_suspend_mode && rstate->mode > 0) {\n\t\tret = rdev->desc->ops->set_suspend_mode(rdev, rstate->mode);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set mode: %pe\\n\", ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int suspend_set_initial_state(struct regulator_dev *rdev)\n{\n\tconst struct regulator_state *rstate;\n\n\trstate = regulator_get_suspend_state_check(rdev,\n\t\t\trdev->constraints->initial_state);\n\tif (!rstate)\n\t\treturn 0;\n\n\treturn __suspend_set_state(rdev, rstate);\n}\n\n#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)\nstatic void print_constraints_debug(struct regulator_dev *rdev)\n{\n\tstruct regulation_constraints *constraints = rdev->constraints;\n\tchar buf[160] = \"\";\n\tsize_t len = sizeof(buf) - 1;\n\tint count = 0;\n\tint ret;\n\n\tif (constraints->min_uV && constraints->max_uV) {\n\t\tif (constraints->min_uV == constraints->max_uV)\n\t\t\tcount += scnprintf(buf + count, len - count, \"%d mV \",\n\t\t\t\t\t   constraints->min_uV / 1000);\n\t\telse\n\t\t\tcount += scnprintf(buf + count, len - count,\n\t\t\t\t\t   \"%d <--> %d mV \",\n\t\t\t\t\t   constraints->min_uV / 1000,\n\t\t\t\t\t   constraints->max_uV / 1000);\n\t}\n\n\tif (!constraints->min_uV ||\n\t    constraints->min_uV != constraints->max_uV) {\n\t\tret = regulator_get_voltage_rdev(rdev);\n\t\tif (ret > 0)\n\t\t\tcount += scnprintf(buf + count, len - count,\n\t\t\t\t\t   \"at %d mV \", ret / 1000);\n\t}\n\n\tif (constraints->uV_offset)\n\t\tcount += scnprintf(buf + count, len - count, \"%dmV offset \",\n\t\t\t\t   constraints->uV_offset / 1000);\n\n\tif (constraints->min_uA && constraints->max_uA) {\n\t\tif (constraints->min_uA == constraints->max_uA)\n\t\t\tcount += scnprintf(buf + count, len - count, \"%d mA \",\n\t\t\t\t\t   constraints->min_uA / 1000);\n\t\telse\n\t\t\tcount += scnprintf(buf + count, len - count,\n\t\t\t\t\t   \"%d <--> %d mA \",\n\t\t\t\t\t   constraints->min_uA / 1000,\n\t\t\t\t\t   constraints->max_uA / 1000);\n\t}\n\n\tif (!constraints->min_uA ||\n\t    constraints->min_uA != constraints->max_uA) {\n\t\tret = _regulator_get_current_limit(rdev);\n\t\tif (ret > 0)\n\t\t\tcount += scnprintf(buf + count, len - count,\n\t\t\t\t\t   \"at %d mA \", ret / 1000);\n\t}\n\n\tif (constraints->valid_modes_mask & REGULATOR_MODE_FAST)\n\t\tcount += scnprintf(buf + count, len - count, \"fast \");\n\tif (constraints->valid_modes_mask & REGULATOR_MODE_NORMAL)\n\t\tcount += scnprintf(buf + count, len - count, \"normal \");\n\tif (constraints->valid_modes_mask & REGULATOR_MODE_IDLE)\n\t\tcount += scnprintf(buf + count, len - count, \"idle \");\n\tif (constraints->valid_modes_mask & REGULATOR_MODE_STANDBY)\n\t\tcount += scnprintf(buf + count, len - count, \"standby \");\n\n\tif (!count)\n\t\tcount = scnprintf(buf, len, \"no parameters\");\n\telse\n\t\t--count;\n\n\tcount += scnprintf(buf + count, len - count, \", %s\",\n\t\t_regulator_is_enabled(rdev) ? \"enabled\" : \"disabled\");\n\n\trdev_dbg(rdev, \"%s\\n\", buf);\n}\n#else  \nstatic inline void print_constraints_debug(struct regulator_dev *rdev) {}\n#endif  \n\nstatic void print_constraints(struct regulator_dev *rdev)\n{\n\tstruct regulation_constraints *constraints = rdev->constraints;\n\n\tprint_constraints_debug(rdev);\n\n\tif ((constraints->min_uV != constraints->max_uV) &&\n\t    !regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE))\n\t\trdev_warn(rdev,\n\t\t\t  \"Voltage range but no REGULATOR_CHANGE_VOLTAGE\\n\");\n}\n\nstatic int machine_constraints_voltage(struct regulator_dev *rdev,\n\tstruct regulation_constraints *constraints)\n{\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint ret;\n\n\t \n\tif (rdev->constraints->apply_uV &&\n\t    rdev->constraints->min_uV && rdev->constraints->max_uV) {\n\t\tint target_min, target_max;\n\t\tint current_uV = regulator_get_voltage_rdev(rdev);\n\n\t\tif (current_uV == -ENOTRECOVERABLE) {\n\t\t\t \n\t\t\trdev_info(rdev, \"Setting %d-%duV\\n\",\n\t\t\t\t  rdev->constraints->min_uV,\n\t\t\t\t  rdev->constraints->max_uV);\n\t\t\t_regulator_do_set_voltage(rdev,\n\t\t\t\t\t\t  rdev->constraints->min_uV,\n\t\t\t\t\t\t  rdev->constraints->max_uV);\n\t\t\tcurrent_uV = regulator_get_voltage_rdev(rdev);\n\t\t}\n\n\t\tif (current_uV < 0) {\n\t\t\tif (current_uV != -EPROBE_DEFER)\n\t\t\t\trdev_err(rdev,\n\t\t\t\t\t \"failed to get the current voltage: %pe\\n\",\n\t\t\t\t\t ERR_PTR(current_uV));\n\t\t\treturn current_uV;\n\t\t}\n\n\t\t \n\t\ttarget_min = current_uV;\n\t\ttarget_max = current_uV;\n\n\t\tif (current_uV < rdev->constraints->min_uV) {\n\t\t\ttarget_min = rdev->constraints->min_uV;\n\t\t\ttarget_max = rdev->constraints->min_uV;\n\t\t}\n\n\t\tif (current_uV > rdev->constraints->max_uV) {\n\t\t\ttarget_min = rdev->constraints->max_uV;\n\t\t\ttarget_max = rdev->constraints->max_uV;\n\t\t}\n\n\t\tif (target_min != current_uV || target_max != current_uV) {\n\t\t\trdev_info(rdev, \"Bringing %duV into %d-%duV\\n\",\n\t\t\t\t  current_uV, target_min, target_max);\n\t\t\tret = _regulator_do_set_voltage(\n\t\t\t\trdev, target_min, target_max);\n\t\t\tif (ret < 0) {\n\t\t\t\trdev_err(rdev,\n\t\t\t\t\t\"failed to apply %d-%duV constraint: %pe\\n\",\n\t\t\t\t\ttarget_min, target_max, ERR_PTR(ret));\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (ops->list_voltage && rdev->desc->n_voltages) {\n\t\tint\tcount = rdev->desc->n_voltages;\n\t\tint\ti;\n\t\tint\tmin_uV = INT_MAX;\n\t\tint\tmax_uV = INT_MIN;\n\t\tint\tcmin = constraints->min_uV;\n\t\tint\tcmax = constraints->max_uV;\n\n\t\t \n\t\tif (count == 1 && !cmin) {\n\t\t\tcmin = 1;\n\t\t\tcmax = INT_MAX;\n\t\t\tconstraints->min_uV = cmin;\n\t\t\tconstraints->max_uV = cmax;\n\t\t}\n\n\t\t \n\t\tif ((cmin == 0) && (cmax == 0))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (cmin <= 0 || cmax <= 0 || cmax < cmin) {\n\t\t\trdev_err(rdev, \"invalid voltage constraints\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (rdev->desc->continuous_voltage_range)\n\t\t\treturn 0;\n\n\t\t \n\t\tfor (i = 0; i < count; i++) {\n\t\t\tint\tvalue;\n\n\t\t\tvalue = ops->list_voltage(rdev, i);\n\t\t\tif (value <= 0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (value >= cmin && value < min_uV)\n\t\t\t\tmin_uV = value;\n\t\t\tif (value <= cmax && value > max_uV)\n\t\t\t\tmax_uV = value;\n\t\t}\n\n\t\t \n\t\tif (max_uV < min_uV) {\n\t\t\trdev_err(rdev,\n\t\t\t\t \"unsupportable voltage constraints %u-%uuV\\n\",\n\t\t\t\t min_uV, max_uV);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (constraints->min_uV < min_uV) {\n\t\t\trdev_dbg(rdev, \"override min_uV, %d -> %d\\n\",\n\t\t\t\t constraints->min_uV, min_uV);\n\t\t\tconstraints->min_uV = min_uV;\n\t\t}\n\t\tif (constraints->max_uV > max_uV) {\n\t\t\trdev_dbg(rdev, \"override max_uV, %d -> %d\\n\",\n\t\t\t\t constraints->max_uV, max_uV);\n\t\t\tconstraints->max_uV = max_uV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int machine_constraints_current(struct regulator_dev *rdev,\n\tstruct regulation_constraints *constraints)\n{\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint ret;\n\n\tif (!constraints->min_uA && !constraints->max_uA)\n\t\treturn 0;\n\n\tif (constraints->min_uA > constraints->max_uA) {\n\t\trdev_err(rdev, \"Invalid current constraints\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ops->set_current_limit || !ops->get_current_limit) {\n\t\trdev_warn(rdev, \"Operation of current configuration missing\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tret = ops->set_current_limit(rdev, constraints->min_uA,\n\t\t\tconstraints->max_uA);\n\tif (ret < 0) {\n\t\trdev_err(rdev, \"Failed to set current constraint, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int _regulator_do_enable(struct regulator_dev *rdev);\n\nstatic int notif_set_limit(struct regulator_dev *rdev,\n\t\t\t   int (*set)(struct regulator_dev *, int, int, bool),\n\t\t\t   int limit, int severity)\n{\n\tbool enable;\n\n\tif (limit == REGULATOR_NOTIF_LIMIT_DISABLE) {\n\t\tenable = false;\n\t\tlimit = 0;\n\t} else {\n\t\tenable = true;\n\t}\n\n\tif (limit == REGULATOR_NOTIF_LIMIT_ENABLE)\n\t\tlimit = 0;\n\n\treturn set(rdev, limit, severity, enable);\n}\n\nstatic int handle_notify_limits(struct regulator_dev *rdev,\n\t\t\tint (*set)(struct regulator_dev *, int, int, bool),\n\t\t\tstruct notification_limit *limits)\n{\n\tint ret = 0;\n\n\tif (!set)\n\t\treturn -EOPNOTSUPP;\n\n\tif (limits->prot)\n\t\tret = notif_set_limit(rdev, set, limits->prot,\n\t\t\t\t      REGULATOR_SEVERITY_PROT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (limits->err)\n\t\tret = notif_set_limit(rdev, set, limits->err,\n\t\t\t\t      REGULATOR_SEVERITY_ERR);\n\tif (ret)\n\t\treturn ret;\n\n\tif (limits->warn)\n\t\tret = notif_set_limit(rdev, set, limits->warn,\n\t\t\t\t      REGULATOR_SEVERITY_WARN);\n\n\treturn ret;\n}\n \nstatic int set_machine_constraints(struct regulator_dev *rdev)\n{\n\tint ret = 0;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\n\tret = machine_constraints_voltage(rdev, rdev->constraints);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = machine_constraints_current(rdev, rdev->constraints);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (rdev->constraints->ilim_uA && ops->set_input_current_limit) {\n\t\tret = ops->set_input_current_limit(rdev,\n\t\t\t\t\t\t   rdev->constraints->ilim_uA);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set input limit: %pe\\n\", ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (rdev->constraints->initial_state) {\n\t\tret = suspend_set_initial_state(rdev);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set suspend state: %pe\\n\", ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (rdev->constraints->initial_mode) {\n\t\tif (!ops->set_mode) {\n\t\t\trdev_err(rdev, \"no set_mode operation\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = ops->set_mode(rdev, rdev->constraints->initial_mode);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set initial mode: %pe\\n\", ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t} else if (rdev->constraints->system_load) {\n\t\t \n\t\tdrms_uA_update(rdev);\n\t}\n\n\tif ((rdev->constraints->ramp_delay || rdev->constraints->ramp_disable)\n\t\t&& ops->set_ramp_delay) {\n\t\tret = ops->set_ramp_delay(rdev, rdev->constraints->ramp_delay);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set ramp_delay: %pe\\n\", ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (rdev->constraints->pull_down && ops->set_pull_down) {\n\t\tret = ops->set_pull_down(rdev);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set pull down: %pe\\n\", ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (rdev->constraints->soft_start && ops->set_soft_start) {\n\t\tret = ops->set_soft_start(rdev);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set soft start: %pe\\n\", ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (rdev->constraints->over_current_protection\n\t\t&& ops->set_over_current_protection) {\n\t\tint lim = rdev->constraints->over_curr_limits.prot;\n\n\t\tret = ops->set_over_current_protection(rdev, lim,\n\t\t\t\t\t\t       REGULATOR_SEVERITY_PROT,\n\t\t\t\t\t\t       true);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set over current protection: %pe\\n\",\n\t\t\t\t ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (rdev->constraints->over_current_detection)\n\t\tret = handle_notify_limits(rdev,\n\t\t\t\t\t   ops->set_over_current_protection,\n\t\t\t\t\t   &rdev->constraints->over_curr_limits);\n\tif (ret) {\n\t\tif (ret != -EOPNOTSUPP) {\n\t\t\trdev_err(rdev, \"failed to set over current limits: %pe\\n\",\n\t\t\t\t ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t\trdev_warn(rdev,\n\t\t\t  \"IC does not support requested over-current limits\\n\");\n\t}\n\n\tif (rdev->constraints->over_voltage_detection)\n\t\tret = handle_notify_limits(rdev,\n\t\t\t\t\t   ops->set_over_voltage_protection,\n\t\t\t\t\t   &rdev->constraints->over_voltage_limits);\n\tif (ret) {\n\t\tif (ret != -EOPNOTSUPP) {\n\t\t\trdev_err(rdev, \"failed to set over voltage limits %pe\\n\",\n\t\t\t\t ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t\trdev_warn(rdev,\n\t\t\t  \"IC does not support requested over voltage limits\\n\");\n\t}\n\n\tif (rdev->constraints->under_voltage_detection)\n\t\tret = handle_notify_limits(rdev,\n\t\t\t\t\t   ops->set_under_voltage_protection,\n\t\t\t\t\t   &rdev->constraints->under_voltage_limits);\n\tif (ret) {\n\t\tif (ret != -EOPNOTSUPP) {\n\t\t\trdev_err(rdev, \"failed to set under voltage limits %pe\\n\",\n\t\t\t\t ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t\trdev_warn(rdev,\n\t\t\t  \"IC does not support requested under voltage limits\\n\");\n\t}\n\n\tif (rdev->constraints->over_temp_detection)\n\t\tret = handle_notify_limits(rdev,\n\t\t\t\t\t   ops->set_thermal_protection,\n\t\t\t\t\t   &rdev->constraints->temp_limits);\n\tif (ret) {\n\t\tif (ret != -EOPNOTSUPP) {\n\t\t\trdev_err(rdev, \"failed to set temperature limits %pe\\n\",\n\t\t\t\t ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t\trdev_warn(rdev,\n\t\t\t  \"IC does not support requested temperature limits\\n\");\n\t}\n\n\tif (rdev->constraints->active_discharge && ops->set_active_discharge) {\n\t\tbool ad_state = (rdev->constraints->active_discharge ==\n\t\t\t      REGULATOR_ACTIVE_DISCHARGE_ENABLE) ? true : false;\n\n\t\tret = ops->set_active_discharge(rdev, ad_state);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set active discharge: %pe\\n\", ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (!rdev->ena_pin && !ops->enable) {\n\t\tif (rdev->supply_name && !rdev->supply)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tif (rdev->supply)\n\t\t\trdev->constraints->always_on =\n\t\t\t\trdev->supply->rdev->constraints->always_on;\n\t\telse\n\t\t\trdev->constraints->always_on = true;\n\t}\n\n\t \n\tif (rdev->constraints->always_on || rdev->constraints->boot_on) {\n\t\t \n\t\tif (rdev->supply_name && !rdev->supply)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\t \n\t\tif (rdev->supply &&\n\t\t    (rdev->constraints->always_on ||\n\t\t     !regulator_is_enabled(rdev->supply))) {\n\t\t\tret = regulator_enable(rdev->supply);\n\t\t\tif (ret < 0) {\n\t\t\t\t_regulator_put(rdev->supply);\n\t\t\t\trdev->supply = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = _regulator_do_enable(rdev);\n\t\tif (ret < 0 && ret != -EINVAL) {\n\t\t\trdev_err(rdev, \"failed to enable: %pe\\n\", ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (rdev->constraints->always_on)\n\t\t\trdev->use_count++;\n\t} else if (rdev->desc->off_on_delay) {\n\t\trdev->last_off = ktime_get();\n\t}\n\n\tprint_constraints(rdev);\n\treturn 0;\n}\n\n \nstatic int set_supply(struct regulator_dev *rdev,\n\t\t      struct regulator_dev *supply_rdev)\n{\n\tint err;\n\n\trdev_dbg(rdev, \"supplied by %s\\n\", rdev_get_name(supply_rdev));\n\n\tif (!try_module_get(supply_rdev->owner))\n\t\treturn -ENODEV;\n\n\trdev->supply = create_regulator(supply_rdev, &rdev->dev, \"SUPPLY\");\n\tif (rdev->supply == NULL) {\n\t\tmodule_put(supply_rdev->owner);\n\t\terr = -ENOMEM;\n\t\treturn err;\n\t}\n\tsupply_rdev->open_count++;\n\n\treturn 0;\n}\n\n \nstatic int set_consumer_device_supply(struct regulator_dev *rdev,\n\t\t\t\t      const char *consumer_dev_name,\n\t\t\t\t      const char *supply)\n{\n\tstruct regulator_map *node, *new_node;\n\tint has_dev;\n\n\tif (supply == NULL)\n\t\treturn -EINVAL;\n\n\tif (consumer_dev_name != NULL)\n\t\thas_dev = 1;\n\telse\n\t\thas_dev = 0;\n\n\tnew_node = kzalloc(sizeof(struct regulator_map), GFP_KERNEL);\n\tif (new_node == NULL)\n\t\treturn -ENOMEM;\n\n\tnew_node->regulator = rdev;\n\tnew_node->supply = supply;\n\n\tif (has_dev) {\n\t\tnew_node->dev_name = kstrdup(consumer_dev_name, GFP_KERNEL);\n\t\tif (new_node->dev_name == NULL) {\n\t\t\tkfree(new_node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tmutex_lock(&regulator_list_mutex);\n\tlist_for_each_entry(node, &regulator_map_list, list) {\n\t\tif (node->dev_name && consumer_dev_name) {\n\t\t\tif (strcmp(node->dev_name, consumer_dev_name) != 0)\n\t\t\t\tcontinue;\n\t\t} else if (node->dev_name || consumer_dev_name) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(node->supply, supply) != 0)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"%s: %s/%s is '%s' supply; fail %s/%s\\n\",\n\t\t\t consumer_dev_name,\n\t\t\t dev_name(&node->regulator->dev),\n\t\t\t node->regulator->desc->name,\n\t\t\t supply,\n\t\t\t dev_name(&rdev->dev), rdev_get_name(rdev));\n\t\tgoto fail;\n\t}\n\n\tlist_add(&new_node->list, &regulator_map_list);\n\tmutex_unlock(&regulator_list_mutex);\n\n\treturn 0;\n\nfail:\n\tmutex_unlock(&regulator_list_mutex);\n\tkfree(new_node->dev_name);\n\tkfree(new_node);\n\treturn -EBUSY;\n}\n\nstatic void unset_regulator_supplies(struct regulator_dev *rdev)\n{\n\tstruct regulator_map *node, *n;\n\n\tlist_for_each_entry_safe(node, n, &regulator_map_list, list) {\n\t\tif (rdev == node->regulator) {\n\t\t\tlist_del(&node->list);\n\t\t\tkfree(node->dev_name);\n\t\t\tkfree(node);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic ssize_t constraint_flags_read_file(struct file *file,\n\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tconst struct regulator *regulator = file->private_data;\n\tconst struct regulation_constraints *c = regulator->rdev->constraints;\n\tchar *buf;\n\tssize_t ret;\n\n\tif (!c)\n\t\treturn 0;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = snprintf(buf, PAGE_SIZE,\n\t\t\t\"always_on: %u\\n\"\n\t\t\t\"boot_on: %u\\n\"\n\t\t\t\"apply_uV: %u\\n\"\n\t\t\t\"ramp_disable: %u\\n\"\n\t\t\t\"soft_start: %u\\n\"\n\t\t\t\"pull_down: %u\\n\"\n\t\t\t\"over_current_protection: %u\\n\",\n\t\t\tc->always_on,\n\t\t\tc->boot_on,\n\t\t\tc->apply_uV,\n\t\t\tc->ramp_disable,\n\t\t\tc->soft_start,\n\t\t\tc->pull_down,\n\t\t\tc->over_current_protection);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\n\tkfree(buf);\n\n\treturn ret;\n}\n\n#endif\n\nstatic const struct file_operations constraint_flags_fops = {\n#ifdef CONFIG_DEBUG_FS\n\t.open = simple_open,\n\t.read = constraint_flags_read_file,\n\t.llseek = default_llseek,\n#endif\n};\n\n#define REG_STR_SIZE\t64\n\nstatic struct regulator *create_regulator(struct regulator_dev *rdev,\n\t\t\t\t\t  struct device *dev,\n\t\t\t\t\t  const char *supply_name)\n{\n\tstruct regulator *regulator;\n\tint err = 0;\n\n\tlockdep_assert_held_once(&rdev->mutex.base);\n\n\tif (dev) {\n\t\tchar buf[REG_STR_SIZE];\n\t\tint size;\n\n\t\tsize = snprintf(buf, REG_STR_SIZE, \"%s-%s\",\n\t\t\t\tdev->kobj.name, supply_name);\n\t\tif (size >= REG_STR_SIZE)\n\t\t\treturn NULL;\n\n\t\tsupply_name = kstrdup(buf, GFP_KERNEL);\n\t\tif (supply_name == NULL)\n\t\t\treturn NULL;\n\t} else {\n\t\tsupply_name = kstrdup_const(supply_name, GFP_KERNEL);\n\t\tif (supply_name == NULL)\n\t\t\treturn NULL;\n\t}\n\n\tregulator = kzalloc(sizeof(*regulator), GFP_KERNEL);\n\tif (regulator == NULL) {\n\t\tkfree_const(supply_name);\n\t\treturn NULL;\n\t}\n\n\tregulator->rdev = rdev;\n\tregulator->supply_name = supply_name;\n\n\tlist_add(&regulator->list, &rdev->consumer_list);\n\n\tif (dev) {\n\t\tregulator->dev = dev;\n\n\t\t \n\t\terr = sysfs_create_link_nowarn(&rdev->dev.kobj, &dev->kobj,\n\t\t\t\t\t       supply_name);\n\t\tif (err) {\n\t\t\trdev_dbg(rdev, \"could not add device link %s: %pe\\n\",\n\t\t\t\t  dev->kobj.name, ERR_PTR(err));\n\t\t\t \n\t\t}\n\t}\n\n\tif (err != -EEXIST)\n\t\tregulator->debugfs = debugfs_create_dir(supply_name, rdev->debugfs);\n\tif (IS_ERR(regulator->debugfs))\n\t\trdev_dbg(rdev, \"Failed to create debugfs directory\\n\");\n\n\tdebugfs_create_u32(\"uA_load\", 0444, regulator->debugfs,\n\t\t\t   &regulator->uA_load);\n\tdebugfs_create_u32(\"min_uV\", 0444, regulator->debugfs,\n\t\t\t   &regulator->voltage[PM_SUSPEND_ON].min_uV);\n\tdebugfs_create_u32(\"max_uV\", 0444, regulator->debugfs,\n\t\t\t   &regulator->voltage[PM_SUSPEND_ON].max_uV);\n\tdebugfs_create_file(\"constraint_flags\", 0444, regulator->debugfs,\n\t\t\t    regulator, &constraint_flags_fops);\n\n\t \n\tif (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_STATUS) &&\n\t    _regulator_is_enabled(rdev))\n\t\tregulator->always_on = true;\n\n\treturn regulator;\n}\n\nstatic int _regulator_get_enable_time(struct regulator_dev *rdev)\n{\n\tif (rdev->constraints && rdev->constraints->enable_time)\n\t\treturn rdev->constraints->enable_time;\n\tif (rdev->desc->ops->enable_time)\n\t\treturn rdev->desc->ops->enable_time(rdev);\n\treturn rdev->desc->enable_time;\n}\n\nstatic struct regulator_supply_alias *regulator_find_supply_alias(\n\t\tstruct device *dev, const char *supply)\n{\n\tstruct regulator_supply_alias *map;\n\n\tlist_for_each_entry(map, &regulator_supply_alias_list, list)\n\t\tif (map->src_dev == dev && strcmp(map->src_supply, supply) == 0)\n\t\t\treturn map;\n\n\treturn NULL;\n}\n\nstatic void regulator_supply_alias(struct device **dev, const char **supply)\n{\n\tstruct regulator_supply_alias *map;\n\n\tmap = regulator_find_supply_alias(*dev, *supply);\n\tif (map) {\n\t\tdev_dbg(*dev, \"Mapping supply %s to %s,%s\\n\",\n\t\t\t\t*supply, map->alias_supply,\n\t\t\t\tdev_name(map->alias_dev));\n\t\t*dev = map->alias_dev;\n\t\t*supply = map->alias_supply;\n\t}\n}\n\nstatic int regulator_match(struct device *dev, const void *data)\n{\n\tstruct regulator_dev *r = dev_to_rdev(dev);\n\n\treturn strcmp(rdev_get_name(r), data) == 0;\n}\n\nstatic struct regulator_dev *regulator_lookup_by_name(const char *name)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device(&regulator_class, NULL, name, regulator_match);\n\n\treturn dev ? dev_to_rdev(dev) : NULL;\n}\n\n \nstatic struct regulator_dev *regulator_dev_lookup(struct device *dev,\n\t\t\t\t\t\t  const char *supply)\n{\n\tstruct regulator_dev *r = NULL;\n\tstruct device_node *node;\n\tstruct regulator_map *map;\n\tconst char *devname = NULL;\n\n\tregulator_supply_alias(&dev, &supply);\n\n\t \n\tif (dev && dev->of_node) {\n\t\tnode = of_get_regulator(dev, supply);\n\t\tif (node) {\n\t\t\tr = of_find_regulator_by_node(node);\n\t\t\tof_node_put(node);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\n\t\t\t \n\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t\t}\n\t}\n\n\t \n\tif (dev)\n\t\tdevname = dev_name(dev);\n\n\tmutex_lock(&regulator_list_mutex);\n\tlist_for_each_entry(map, &regulator_map_list, list) {\n\t\t \n\t\tif (map->dev_name &&\n\t\t    (!devname || strcmp(map->dev_name, devname)))\n\t\t\tcontinue;\n\n\t\tif (strcmp(map->supply, supply) == 0 &&\n\t\t    get_device(&map->regulator->dev)) {\n\t\t\tr = map->regulator;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&regulator_list_mutex);\n\n\tif (r)\n\t\treturn r;\n\n\tr = regulator_lookup_by_name(supply);\n\tif (r)\n\t\treturn r;\n\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic int regulator_resolve_supply(struct regulator_dev *rdev)\n{\n\tstruct regulator_dev *r;\n\tstruct device *dev = rdev->dev.parent;\n\tstruct ww_acquire_ctx ww_ctx;\n\tint ret = 0;\n\n\t \n\tif (!rdev->supply_name)\n\t\treturn 0;\n\n\t \n\tif (rdev->supply)\n\t\treturn 0;\n\n\tr = regulator_dev_lookup(dev, rdev->supply_name);\n\tif (IS_ERR(r)) {\n\t\tret = PTR_ERR(r);\n\n\t\t \n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto out;\n\n\t\tif (have_full_constraints()) {\n\t\t\tr = dummy_regulator_rdev;\n\t\t\tget_device(&r->dev);\n\t\t} else {\n\t\t\tdev_err(dev, \"Failed to resolve %s-supply for %s\\n\",\n\t\t\t\trdev->supply_name, rdev->desc->name);\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (r == rdev) {\n\t\tdev_err(dev, \"Supply for %s (%s) resolved to itself\\n\",\n\t\t\trdev->desc->name, rdev->supply_name);\n\t\tif (!have_full_constraints()) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tr = dummy_regulator_rdev;\n\t\tget_device(&r->dev);\n\t}\n\n\t \n\tif (r->dev.parent && r->dev.parent != rdev->dev.parent) {\n\t\tif (!device_is_bound(r->dev.parent)) {\n\t\t\tput_device(&r->dev);\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = regulator_resolve_supply(r);\n\tif (ret < 0) {\n\t\tput_device(&r->dev);\n\t\tgoto out;\n\t}\n\n\t \n\tregulator_lock_two(rdev, r, &ww_ctx);\n\n\t \n\tif (rdev->supply) {\n\t\tregulator_unlock_two(rdev, r, &ww_ctx);\n\t\tput_device(&r->dev);\n\t\tgoto out;\n\t}\n\n\tret = set_supply(rdev, r);\n\tif (ret < 0) {\n\t\tregulator_unlock_two(rdev, r, &ww_ctx);\n\t\tput_device(&r->dev);\n\t\tgoto out;\n\t}\n\n\tregulator_unlock_two(rdev, r, &ww_ctx);\n\n\t \n\tif (rdev->use_count) {\n\t\tret = regulator_enable(rdev->supply);\n\t\tif (ret < 0) {\n\t\t\t_regulator_put(rdev->supply);\n\t\t\trdev->supply = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstruct regulator *_regulator_get(struct device *dev, const char *id,\n\t\t\t\t enum regulator_get_type get_type)\n{\n\tstruct regulator_dev *rdev;\n\tstruct regulator *regulator;\n\tstruct device_link *link;\n\tint ret;\n\n\tif (get_type >= MAX_GET_TYPE) {\n\t\tdev_err(dev, \"invalid type %d in %s\\n\", get_type, __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (id == NULL) {\n\t\tpr_err(\"get() with no identifier\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\trdev = regulator_dev_lookup(dev, id);\n\tif (IS_ERR(rdev)) {\n\t\tret = PTR_ERR(rdev);\n\n\t\t \n\t\tif (ret != -ENODEV)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tif (!have_full_constraints()) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"incomplete constraints, dummy supplies not allowed\\n\");\n\t\t\treturn ERR_PTR(-ENODEV);\n\t\t}\n\n\t\tswitch (get_type) {\n\t\tcase NORMAL_GET:\n\t\t\t \n\t\t\tdev_warn(dev, \"supply %s not found, using dummy regulator\\n\", id);\n\t\t\trdev = dummy_regulator_rdev;\n\t\t\tget_device(&rdev->dev);\n\t\t\tbreak;\n\n\t\tcase EXCLUSIVE_GET:\n\t\t\tdev_warn(dev,\n\t\t\t\t \"dummy supplies not allowed for exclusive requests\\n\");\n\t\t\tfallthrough;\n\n\t\tdefault:\n\t\t\treturn ERR_PTR(-ENODEV);\n\t\t}\n\t}\n\n\tif (rdev->exclusive) {\n\t\tregulator = ERR_PTR(-EPERM);\n\t\tput_device(&rdev->dev);\n\t\treturn regulator;\n\t}\n\n\tif (get_type == EXCLUSIVE_GET && rdev->open_count) {\n\t\tregulator = ERR_PTR(-EBUSY);\n\t\tput_device(&rdev->dev);\n\t\treturn regulator;\n\t}\n\n\tmutex_lock(&regulator_list_mutex);\n\tret = (rdev->coupling_desc.n_resolved != rdev->coupling_desc.n_coupled);\n\tmutex_unlock(&regulator_list_mutex);\n\n\tif (ret != 0) {\n\t\tregulator = ERR_PTR(-EPROBE_DEFER);\n\t\tput_device(&rdev->dev);\n\t\treturn regulator;\n\t}\n\n\tret = regulator_resolve_supply(rdev);\n\tif (ret < 0) {\n\t\tregulator = ERR_PTR(ret);\n\t\tput_device(&rdev->dev);\n\t\treturn regulator;\n\t}\n\n\tif (!try_module_get(rdev->owner)) {\n\t\tregulator = ERR_PTR(-EPROBE_DEFER);\n\t\tput_device(&rdev->dev);\n\t\treturn regulator;\n\t}\n\n\tregulator_lock(rdev);\n\tregulator = create_regulator(rdev, dev, id);\n\tregulator_unlock(rdev);\n\tif (regulator == NULL) {\n\t\tregulator = ERR_PTR(-ENOMEM);\n\t\tmodule_put(rdev->owner);\n\t\tput_device(&rdev->dev);\n\t\treturn regulator;\n\t}\n\n\trdev->open_count++;\n\tif (get_type == EXCLUSIVE_GET) {\n\t\trdev->exclusive = 1;\n\n\t\tret = _regulator_is_enabled(rdev);\n\t\tif (ret > 0) {\n\t\t\trdev->use_count = 1;\n\t\t\tregulator->enable_count = 1;\n\t\t} else {\n\t\t\trdev->use_count = 0;\n\t\t\tregulator->enable_count = 0;\n\t\t}\n\t}\n\n\tlink = device_link_add(dev, &rdev->dev, DL_FLAG_STATELESS);\n\tif (!IS_ERR_OR_NULL(link))\n\t\tregulator->device_link = true;\n\n\treturn regulator;\n}\n\n \nstruct regulator *regulator_get(struct device *dev, const char *id)\n{\n\treturn _regulator_get(dev, id, NORMAL_GET);\n}\nEXPORT_SYMBOL_GPL(regulator_get);\n\n \nstruct regulator *regulator_get_exclusive(struct device *dev, const char *id)\n{\n\treturn _regulator_get(dev, id, EXCLUSIVE_GET);\n}\nEXPORT_SYMBOL_GPL(regulator_get_exclusive);\n\n \nstruct regulator *regulator_get_optional(struct device *dev, const char *id)\n{\n\treturn _regulator_get(dev, id, OPTIONAL_GET);\n}\nEXPORT_SYMBOL_GPL(regulator_get_optional);\n\nstatic void destroy_regulator(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\n\tdebugfs_remove_recursive(regulator->debugfs);\n\n\tif (regulator->dev) {\n\t\tif (regulator->device_link)\n\t\t\tdevice_link_remove(regulator->dev, &rdev->dev);\n\n\t\t \n\t\tsysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);\n\t}\n\n\tregulator_lock(rdev);\n\tlist_del(&regulator->list);\n\n\trdev->open_count--;\n\trdev->exclusive = 0;\n\tregulator_unlock(rdev);\n\n\tkfree_const(regulator->supply_name);\n\tkfree(regulator);\n}\n\n \nstatic void _regulator_put(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev;\n\n\tif (IS_ERR_OR_NULL(regulator))\n\t\treturn;\n\n\tlockdep_assert_held_once(&regulator_list_mutex);\n\n\t \n\tWARN_ON(regulator->enable_count);\n\n\trdev = regulator->rdev;\n\n\tdestroy_regulator(regulator);\n\n\tmodule_put(rdev->owner);\n\tput_device(&rdev->dev);\n}\n\n \nvoid regulator_put(struct regulator *regulator)\n{\n\tmutex_lock(&regulator_list_mutex);\n\t_regulator_put(regulator);\n\tmutex_unlock(&regulator_list_mutex);\n}\nEXPORT_SYMBOL_GPL(regulator_put);\n\n \nint regulator_register_supply_alias(struct device *dev, const char *id,\n\t\t\t\t    struct device *alias_dev,\n\t\t\t\t    const char *alias_id)\n{\n\tstruct regulator_supply_alias *map;\n\n\tmap = regulator_find_supply_alias(dev, id);\n\tif (map)\n\t\treturn -EEXIST;\n\n\tmap = kzalloc(sizeof(struct regulator_supply_alias), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->src_dev = dev;\n\tmap->src_supply = id;\n\tmap->alias_dev = alias_dev;\n\tmap->alias_supply = alias_id;\n\n\tlist_add(&map->list, &regulator_supply_alias_list);\n\n\tpr_info(\"Adding alias for supply %s,%s -> %s,%s\\n\",\n\t\tid, dev_name(dev), alias_id, dev_name(alias_dev));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_register_supply_alias);\n\n \nvoid regulator_unregister_supply_alias(struct device *dev, const char *id)\n{\n\tstruct regulator_supply_alias *map;\n\n\tmap = regulator_find_supply_alias(dev, id);\n\tif (map) {\n\t\tlist_del(&map->list);\n\t\tkfree(map);\n\t}\n}\nEXPORT_SYMBOL_GPL(regulator_unregister_supply_alias);\n\n \nint regulator_bulk_register_supply_alias(struct device *dev,\n\t\t\t\t\t const char *const *id,\n\t\t\t\t\t struct device *alias_dev,\n\t\t\t\t\t const char *const *alias_id,\n\t\t\t\t\t int num_id)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < num_id; ++i) {\n\t\tret = regulator_register_supply_alias(dev, id[i], alias_dev,\n\t\t\t\t\t\t      alias_id[i]);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tdev_err(dev,\n\t\t\"Failed to create supply alias %s,%s -> %s,%s\\n\",\n\t\tid[i], dev_name(dev), alias_id[i], dev_name(alias_dev));\n\n\twhile (--i >= 0)\n\t\tregulator_unregister_supply_alias(dev, id[i]);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_register_supply_alias);\n\n \nvoid regulator_bulk_unregister_supply_alias(struct device *dev,\n\t\t\t\t\t    const char *const *id,\n\t\t\t\t\t    int num_id)\n{\n\tint i;\n\n\tfor (i = 0; i < num_id; ++i)\n\t\tregulator_unregister_supply_alias(dev, id[i]);\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_unregister_supply_alias);\n\n\n \nstatic int regulator_ena_gpio_request(struct regulator_dev *rdev,\n\t\t\t\tconst struct regulator_config *config)\n{\n\tstruct regulator_enable_gpio *pin, *new_pin;\n\tstruct gpio_desc *gpiod;\n\n\tgpiod = config->ena_gpiod;\n\tnew_pin = kzalloc(sizeof(*new_pin), GFP_KERNEL);\n\n\tmutex_lock(&regulator_list_mutex);\n\n\tlist_for_each_entry(pin, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == gpiod) {\n\t\t\trdev_dbg(rdev, \"GPIO is already used\\n\");\n\t\t\tgoto update_ena_gpio_to_rdev;\n\t\t}\n\t}\n\n\tif (new_pin == NULL) {\n\t\tmutex_unlock(&regulator_list_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tpin = new_pin;\n\tnew_pin = NULL;\n\n\tpin->gpiod = gpiod;\n\tlist_add(&pin->list, &regulator_ena_gpio_list);\n\nupdate_ena_gpio_to_rdev:\n\tpin->request_count++;\n\trdev->ena_pin = pin;\n\n\tmutex_unlock(&regulator_list_mutex);\n\tkfree(new_pin);\n\n\treturn 0;\n}\n\nstatic void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\n\tif (!rdev->ena_pin)\n\t\treturn;\n\n\t \n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin != rdev->ena_pin)\n\t\t\tcontinue;\n\n\t\tif (--pin->request_count)\n\t\t\tbreak;\n\n\t\tgpiod_put(pin->gpiod);\n\t\tlist_del(&pin->list);\n\t\tkfree(pin);\n\t\tbreak;\n\t}\n\n\trdev->ena_pin = NULL;\n}\n\n \nstatic int regulator_ena_gpio_ctrl(struct regulator_dev *rdev, bool enable)\n{\n\tstruct regulator_enable_gpio *pin = rdev->ena_pin;\n\n\tif (!pin)\n\t\treturn -EINVAL;\n\n\tif (enable) {\n\t\t \n\t\tif (pin->enable_count == 0)\n\t\t\tgpiod_set_value_cansleep(pin->gpiod, 1);\n\n\t\tpin->enable_count++;\n\t} else {\n\t\tif (pin->enable_count > 1) {\n\t\t\tpin->enable_count--;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (pin->enable_count <= 1) {\n\t\t\tgpiod_set_value_cansleep(pin->gpiod, 0);\n\t\t\tpin->enable_count = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void _regulator_delay_helper(unsigned int delay)\n{\n\tunsigned int ms = delay / 1000;\n\tunsigned int us = delay % 1000;\n\n\tif (ms > 0) {\n\t\t \n\t\tif (ms < 20)\n\t\t\tus += ms * 1000;\n\t\telse\n\t\t\tmsleep(ms);\n\t}\n\n\t \n\tif (us >= 10)\n\t\tusleep_range(us, us + 100);\n\telse\n\t\tudelay(us);\n}\n\n \nstatic inline int _regulator_check_status_enabled(struct regulator_dev *rdev)\n{\n\tint ret = rdev->desc->ops->get_status(rdev);\n\n\tif (ret < 0) {\n\t\trdev_info(rdev, \"get_status returned error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (ret) {\n\tcase REGULATOR_STATUS_OFF:\n\tcase REGULATOR_STATUS_ERROR:\n\tcase REGULATOR_STATUS_UNDEFINED:\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int _regulator_do_enable(struct regulator_dev *rdev)\n{\n\tint ret, delay;\n\n\t \n\tret = _regulator_get_enable_time(rdev);\n\tif (ret >= 0) {\n\t\tdelay = ret;\n\t} else {\n\t\trdev_warn(rdev, \"enable_time() failed: %pe\\n\", ERR_PTR(ret));\n\t\tdelay = 0;\n\t}\n\n\ttrace_regulator_enable(rdev_get_name(rdev));\n\n\tif (rdev->desc->off_on_delay) {\n\t\t \n\t\tktime_t end = ktime_add_us(rdev->last_off, rdev->desc->off_on_delay);\n\t\ts64 remaining = ktime_us_delta(end, ktime_get_boottime());\n\n\t\tif (remaining > 0)\n\t\t\t_regulator_delay_helper(remaining);\n\t}\n\n\tif (rdev->ena_pin) {\n\t\tif (!rdev->ena_gpio_state) {\n\t\t\tret = regulator_ena_gpio_ctrl(rdev, true);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\trdev->ena_gpio_state = 1;\n\t\t}\n\t} else if (rdev->desc->ops->enable) {\n\t\tret = rdev->desc->ops->enable(rdev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttrace_regulator_enable_delay(rdev_get_name(rdev));\n\n\t \n\tif (rdev->desc->poll_enabled_time) {\n\t\tint time_remaining = delay;\n\n\t\twhile (time_remaining > 0) {\n\t\t\t_regulator_delay_helper(rdev->desc->poll_enabled_time);\n\n\t\t\tif (rdev->desc->ops->get_status) {\n\t\t\t\tret = _regulator_check_status_enabled(rdev);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\telse if (ret)\n\t\t\t\t\tbreak;\n\t\t\t} else if (rdev->desc->ops->is_enabled(rdev))\n\t\t\t\tbreak;\n\n\t\t\ttime_remaining -= rdev->desc->poll_enabled_time;\n\t\t}\n\n\t\tif (time_remaining <= 0) {\n\t\t\trdev_err(rdev, \"Enabled check timed out\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\t_regulator_delay_helper(delay);\n\t}\n\n\ttrace_regulator_enable_complete(rdev_get_name(rdev));\n\n\treturn 0;\n}\n\n \nstatic int _regulator_handle_consumer_enable(struct regulator *regulator)\n{\n\tint ret;\n\tstruct regulator_dev *rdev = regulator->rdev;\n\n\tlockdep_assert_held_once(&rdev->mutex.base);\n\n\tregulator->enable_count++;\n\tif (regulator->uA_load && regulator->enable_count == 1) {\n\t\tret = drms_uA_update(rdev);\n\t\tif (ret)\n\t\t\tregulator->enable_count--;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int _regulator_handle_consumer_disable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\n\tlockdep_assert_held_once(&rdev->mutex.base);\n\n\tif (!regulator->enable_count) {\n\t\trdev_err(rdev, \"Underflow of regulator enable count\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregulator->enable_count--;\n\tif (regulator->uA_load && regulator->enable_count == 0)\n\t\treturn drms_uA_update(rdev);\n\n\treturn 0;\n}\n\n \nstatic int _regulator_enable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret;\n\n\tlockdep_assert_held_once(&rdev->mutex.base);\n\n\tif (rdev->use_count == 0 && rdev->supply) {\n\t\tret = _regulator_enable(rdev->supply);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (rdev->coupling_desc.n_coupled > 1) {\n\t\tret = regulator_balance_voltage(rdev, PM_SUSPEND_ON);\n\t\tif (ret < 0)\n\t\t\tgoto err_disable_supply;\n\t}\n\n\tret = _regulator_handle_consumer_enable(regulator);\n\tif (ret < 0)\n\t\tgoto err_disable_supply;\n\n\tif (rdev->use_count == 0) {\n\t\t \n\t\tret = _regulator_is_enabled(rdev);\n\t\tif (ret == -EINVAL || ret == 0) {\n\t\t\tif (!regulator_ops_is_valid(rdev,\n\t\t\t\t\tREGULATOR_CHANGE_STATUS)) {\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto err_consumer_disable;\n\t\t\t}\n\n\t\t\tret = _regulator_do_enable(rdev);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_consumer_disable;\n\n\t\t\t_notifier_call_chain(rdev, REGULATOR_EVENT_ENABLE,\n\t\t\t\t\t     NULL);\n\t\t} else if (ret < 0) {\n\t\t\trdev_err(rdev, \"is_enabled() failed: %pe\\n\", ERR_PTR(ret));\n\t\t\tgoto err_consumer_disable;\n\t\t}\n\t\t \n\t}\n\n\trdev->use_count++;\n\n\treturn 0;\n\nerr_consumer_disable:\n\t_regulator_handle_consumer_disable(regulator);\n\nerr_disable_supply:\n\tif (rdev->use_count == 0 && rdev->supply)\n\t\t_regulator_disable(rdev->supply);\n\n\treturn ret;\n}\n\n \nint regulator_enable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tstruct ww_acquire_ctx ww_ctx;\n\tint ret;\n\n\tregulator_lock_dependent(rdev, &ww_ctx);\n\tret = _regulator_enable(regulator);\n\tregulator_unlock_dependent(rdev, &ww_ctx);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_enable);\n\nstatic int _regulator_do_disable(struct regulator_dev *rdev)\n{\n\tint ret;\n\n\ttrace_regulator_disable(rdev_get_name(rdev));\n\n\tif (rdev->ena_pin) {\n\t\tif (rdev->ena_gpio_state) {\n\t\t\tret = regulator_ena_gpio_ctrl(rdev, false);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\trdev->ena_gpio_state = 0;\n\t\t}\n\n\t} else if (rdev->desc->ops->disable) {\n\t\tret = rdev->desc->ops->disable(rdev);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tif (rdev->desc->off_on_delay)\n\t\trdev->last_off = ktime_get_boottime();\n\n\ttrace_regulator_disable_complete(rdev_get_name(rdev));\n\n\treturn 0;\n}\n\n \nstatic int _regulator_disable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret = 0;\n\n\tlockdep_assert_held_once(&rdev->mutex.base);\n\n\tif (WARN(rdev->use_count <= 0,\n\t\t \"unbalanced disables for %s\\n\", rdev_get_name(rdev)))\n\t\treturn -EIO;\n\n\t \n\tif (rdev->use_count == 1 &&\n\t    (rdev->constraints && !rdev->constraints->always_on)) {\n\n\t\t \n\t\tif (regulator_ops_is_valid(rdev, REGULATOR_CHANGE_STATUS)) {\n\t\t\tret = _notifier_call_chain(rdev,\n\t\t\t\t\t\t   REGULATOR_EVENT_PRE_DISABLE,\n\t\t\t\t\t\t   NULL);\n\t\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tret = _regulator_do_disable(rdev);\n\t\t\tif (ret < 0) {\n\t\t\t\trdev_err(rdev, \"failed to disable: %pe\\n\", ERR_PTR(ret));\n\t\t\t\t_notifier_call_chain(rdev,\n\t\t\t\t\t\tREGULATOR_EVENT_ABORT_DISABLE,\n\t\t\t\t\t\tNULL);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t_notifier_call_chain(rdev, REGULATOR_EVENT_DISABLE,\n\t\t\t\t\tNULL);\n\t\t}\n\n\t\trdev->use_count = 0;\n\t} else if (rdev->use_count > 1) {\n\t\trdev->use_count--;\n\t}\n\n\tif (ret == 0)\n\t\tret = _regulator_handle_consumer_disable(regulator);\n\n\tif (ret == 0 && rdev->coupling_desc.n_coupled > 1)\n\t\tret = regulator_balance_voltage(rdev, PM_SUSPEND_ON);\n\n\tif (ret == 0 && rdev->use_count == 0 && rdev->supply)\n\t\tret = _regulator_disable(rdev->supply);\n\n\treturn ret;\n}\n\n \nint regulator_disable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tstruct ww_acquire_ctx ww_ctx;\n\tint ret;\n\n\tregulator_lock_dependent(rdev, &ww_ctx);\n\tret = _regulator_disable(regulator);\n\tregulator_unlock_dependent(rdev, &ww_ctx);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_disable);\n\n \nstatic int _regulator_force_disable(struct regulator_dev *rdev)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held_once(&rdev->mutex.base);\n\n\tret = _notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE |\n\t\t\tREGULATOR_EVENT_PRE_DISABLE, NULL);\n\tif (ret & NOTIFY_STOP_MASK)\n\t\treturn -EINVAL;\n\n\tret = _regulator_do_disable(rdev);\n\tif (ret < 0) {\n\t\trdev_err(rdev, \"failed to force disable: %pe\\n\", ERR_PTR(ret));\n\t\t_notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE |\n\t\t\t\tREGULATOR_EVENT_ABORT_DISABLE, NULL);\n\t\treturn ret;\n\t}\n\n\t_notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE |\n\t\t\tREGULATOR_EVENT_DISABLE, NULL);\n\n\treturn 0;\n}\n\n \nint regulator_force_disable(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tstruct ww_acquire_ctx ww_ctx;\n\tint ret;\n\n\tregulator_lock_dependent(rdev, &ww_ctx);\n\n\tret = _regulator_force_disable(regulator->rdev);\n\n\tif (rdev->coupling_desc.n_coupled > 1)\n\t\tregulator_balance_voltage(rdev, PM_SUSPEND_ON);\n\n\tif (regulator->uA_load) {\n\t\tregulator->uA_load = 0;\n\t\tret = drms_uA_update(rdev);\n\t}\n\n\tif (rdev->use_count != 0 && rdev->supply)\n\t\t_regulator_disable(rdev->supply);\n\n\tregulator_unlock_dependent(rdev, &ww_ctx);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_force_disable);\n\nstatic void regulator_disable_work(struct work_struct *work)\n{\n\tstruct regulator_dev *rdev = container_of(work, struct regulator_dev,\n\t\t\t\t\t\t  disable_work.work);\n\tstruct ww_acquire_ctx ww_ctx;\n\tint count, i, ret;\n\tstruct regulator *regulator;\n\tint total_count = 0;\n\n\tregulator_lock_dependent(rdev, &ww_ctx);\n\n\t \n\tcancel_delayed_work(&rdev->disable_work);\n\n\tlist_for_each_entry(regulator, &rdev->consumer_list, list) {\n\t\tcount = regulator->deferred_disables;\n\n\t\tif (!count)\n\t\t\tcontinue;\n\n\t\ttotal_count += count;\n\t\tregulator->deferred_disables = 0;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tret = _regulator_disable(regulator);\n\t\t\tif (ret != 0)\n\t\t\t\trdev_err(rdev, \"Deferred disable failed: %pe\\n\",\n\t\t\t\t\t ERR_PTR(ret));\n\t\t}\n\t}\n\tWARN_ON(!total_count);\n\n\tif (rdev->coupling_desc.n_coupled > 1)\n\t\tregulator_balance_voltage(rdev, PM_SUSPEND_ON);\n\n\tregulator_unlock_dependent(rdev, &ww_ctx);\n}\n\n \nint regulator_disable_deferred(struct regulator *regulator, int ms)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\n\tif (!ms)\n\t\treturn regulator_disable(regulator);\n\n\tregulator_lock(rdev);\n\tregulator->deferred_disables++;\n\tmod_delayed_work(system_power_efficient_wq, &rdev->disable_work,\n\t\t\t msecs_to_jiffies(ms));\n\tregulator_unlock(rdev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_disable_deferred);\n\nstatic int _regulator_is_enabled(struct regulator_dev *rdev)\n{\n\t \n\tif (rdev->ena_pin)\n\t\treturn rdev->ena_gpio_state;\n\n\t \n\tif (!rdev->desc->ops->is_enabled)\n\t\treturn 1;\n\n\treturn rdev->desc->ops->is_enabled(rdev);\n}\n\nstatic int _regulator_list_voltage(struct regulator_dev *rdev,\n\t\t\t\t   unsigned selector, int lock)\n{\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint ret;\n\n\tif (rdev->desc->fixed_uV && rdev->desc->n_voltages == 1 && !selector)\n\t\treturn rdev->desc->fixed_uV;\n\n\tif (ops->list_voltage) {\n\t\tif (selector >= rdev->desc->n_voltages)\n\t\t\treturn -EINVAL;\n\t\tif (selector < rdev->desc->linear_min_sel)\n\t\t\treturn 0;\n\t\tif (lock)\n\t\t\tregulator_lock(rdev);\n\t\tret = ops->list_voltage(rdev, selector);\n\t\tif (lock)\n\t\t\tregulator_unlock(rdev);\n\t} else if (rdev->is_switch && rdev->supply) {\n\t\tret = _regulator_list_voltage(rdev->supply->rdev,\n\t\t\t\t\t      selector, lock);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret > 0) {\n\t\tif (ret < rdev->constraints->min_uV)\n\t\t\tret = 0;\n\t\telse if (ret > rdev->constraints->max_uV)\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nint regulator_is_enabled(struct regulator *regulator)\n{\n\tint ret;\n\n\tif (regulator->always_on)\n\t\treturn 1;\n\n\tregulator_lock(regulator->rdev);\n\tret = _regulator_is_enabled(regulator->rdev);\n\tregulator_unlock(regulator->rdev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_is_enabled);\n\n \nint regulator_count_voltages(struct regulator *regulator)\n{\n\tstruct regulator_dev\t*rdev = regulator->rdev;\n\n\tif (rdev->desc->n_voltages)\n\t\treturn rdev->desc->n_voltages;\n\n\tif (!rdev->is_switch || !rdev->supply)\n\t\treturn -EINVAL;\n\n\treturn regulator_count_voltages(rdev->supply);\n}\nEXPORT_SYMBOL_GPL(regulator_count_voltages);\n\n \nint regulator_list_voltage(struct regulator *regulator, unsigned selector)\n{\n\treturn _regulator_list_voltage(regulator->rdev, selector, 1);\n}\nEXPORT_SYMBOL_GPL(regulator_list_voltage);\n\n \nstruct regmap *regulator_get_regmap(struct regulator *regulator)\n{\n\tstruct regmap *map = regulator->rdev->regmap;\n\n\treturn map ? map : ERR_PTR(-EOPNOTSUPP);\n}\n\n \nint regulator_get_hardware_vsel_register(struct regulator *regulator,\n\t\t\t\t\t unsigned *vsel_reg,\n\t\t\t\t\t unsigned *vsel_mask)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\n\tif (ops->set_voltage_sel != regulator_set_voltage_sel_regmap)\n\t\treturn -EOPNOTSUPP;\n\n\t*vsel_reg = rdev->desc->vsel_reg;\n\t*vsel_mask = rdev->desc->vsel_mask;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_get_hardware_vsel_register);\n\n \nint regulator_list_hardware_vsel(struct regulator *regulator,\n\t\t\t\t unsigned selector)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\n\tif (selector >= rdev->desc->n_voltages)\n\t\treturn -EINVAL;\n\tif (selector < rdev->desc->linear_min_sel)\n\t\treturn 0;\n\tif (ops->set_voltage_sel != regulator_set_voltage_sel_regmap)\n\t\treturn -EOPNOTSUPP;\n\n\treturn selector;\n}\nEXPORT_SYMBOL_GPL(regulator_list_hardware_vsel);\n\n \nunsigned int regulator_get_linear_step(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\n\treturn rdev->desc->uV_step;\n}\nEXPORT_SYMBOL_GPL(regulator_get_linear_step);\n\n \nint regulator_is_supported_voltage(struct regulator *regulator,\n\t\t\t\t   int min_uV, int max_uV)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint i, voltages, ret;\n\n\t \n\tif (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE)) {\n\t\tret = regulator_get_voltage(regulator);\n\t\tif (ret >= 0)\n\t\t\treturn min_uV <= ret && ret <= max_uV;\n\t\telse\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (rdev->desc->continuous_voltage_range)\n\t\treturn min_uV >= rdev->constraints->min_uV &&\n\t\t\t\tmax_uV <= rdev->constraints->max_uV;\n\n\tret = regulator_count_voltages(regulator);\n\tif (ret < 0)\n\t\treturn 0;\n\tvoltages = ret;\n\n\tfor (i = 0; i < voltages; i++) {\n\t\tret = regulator_list_voltage(regulator, i);\n\n\t\tif (ret >= min_uV && ret <= max_uV)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(regulator_is_supported_voltage);\n\nstatic int regulator_map_voltage(struct regulator_dev *rdev, int min_uV,\n\t\t\t\t int max_uV)\n{\n\tconst struct regulator_desc *desc = rdev->desc;\n\n\tif (desc->ops->map_voltage)\n\t\treturn desc->ops->map_voltage(rdev, min_uV, max_uV);\n\n\tif (desc->ops->list_voltage == regulator_list_voltage_linear)\n\t\treturn regulator_map_voltage_linear(rdev, min_uV, max_uV);\n\n\tif (desc->ops->list_voltage == regulator_list_voltage_linear_range)\n\t\treturn regulator_map_voltage_linear_range(rdev, min_uV, max_uV);\n\n\tif (desc->ops->list_voltage ==\n\t\tregulator_list_voltage_pickable_linear_range)\n\t\treturn regulator_map_voltage_pickable_linear_range(rdev,\n\t\t\t\t\t\t\tmin_uV, max_uV);\n\n\treturn regulator_map_voltage_iterate(rdev, min_uV, max_uV);\n}\n\nstatic int _regulator_call_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t       int min_uV, int max_uV,\n\t\t\t\t       unsigned *selector)\n{\n\tstruct pre_voltage_change_data data;\n\tint ret;\n\n\tdata.old_uV = regulator_get_voltage_rdev(rdev);\n\tdata.min_uV = min_uV;\n\tdata.max_uV = max_uV;\n\tret = _notifier_call_chain(rdev, REGULATOR_EVENT_PRE_VOLTAGE_CHANGE,\n\t\t\t\t   &data);\n\tif (ret & NOTIFY_STOP_MASK)\n\t\treturn -EINVAL;\n\n\tret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV, selector);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\t_notifier_call_chain(rdev, REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE,\n\t\t\t     (void *)data.old_uV);\n\n\treturn ret;\n}\n\nstatic int _regulator_call_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\t   int uV, unsigned selector)\n{\n\tstruct pre_voltage_change_data data;\n\tint ret;\n\n\tdata.old_uV = regulator_get_voltage_rdev(rdev);\n\tdata.min_uV = uV;\n\tdata.max_uV = uV;\n\tret = _notifier_call_chain(rdev, REGULATOR_EVENT_PRE_VOLTAGE_CHANGE,\n\t\t\t\t   &data);\n\tif (ret & NOTIFY_STOP_MASK)\n\t\treturn -EINVAL;\n\n\tret = rdev->desc->ops->set_voltage_sel(rdev, selector);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\t_notifier_call_chain(rdev, REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE,\n\t\t\t     (void *)data.old_uV);\n\n\treturn ret;\n}\n\nstatic int _regulator_set_voltage_sel_step(struct regulator_dev *rdev,\n\t\t\t\t\t   int uV, int new_selector)\n{\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint diff, old_sel, curr_sel, ret;\n\n\t \n\tif (!_regulator_is_enabled(rdev))\n\t\tgoto final_set;\n\n\tif (!ops->get_voltage_sel)\n\t\treturn -EINVAL;\n\n\told_sel = ops->get_voltage_sel(rdev);\n\tif (old_sel < 0)\n\t\treturn old_sel;\n\n\tdiff = new_selector - old_sel;\n\tif (diff == 0)\n\t\treturn 0;  \n\n\tif (diff > 0) {\n\t\t \n\t\tfor (curr_sel = old_sel + rdev->desc->vsel_step;\n\t\t     curr_sel < new_selector;\n\t\t     curr_sel += rdev->desc->vsel_step) {\n\t\t\t \n\t\t\tret = ops->set_voltage_sel(rdev, curr_sel);\n\t\t\tif (ret)\n\t\t\t\tgoto try_revert;\n\t\t}\n\t} else {\n\t\t \n\t\tfor (curr_sel = old_sel - rdev->desc->vsel_step;\n\t\t     curr_sel > new_selector;\n\t\t     curr_sel -= rdev->desc->vsel_step) {\n\t\t\tret = ops->set_voltage_sel(rdev, curr_sel);\n\t\t\tif (ret)\n\t\t\t\tgoto try_revert;\n\t\t}\n\t}\n\nfinal_set:\n\t \n\treturn _regulator_call_set_voltage_sel(rdev, uV, new_selector);\n\ntry_revert:\n\t \n\t(void)ops->set_voltage_sel(rdev, old_sel);\n\treturn ret;\n}\n\nstatic int _regulator_set_voltage_time(struct regulator_dev *rdev,\n\t\t\t\t       int old_uV, int new_uV)\n{\n\tunsigned int ramp_delay = 0;\n\n\tif (rdev->constraints->ramp_delay)\n\t\tramp_delay = rdev->constraints->ramp_delay;\n\telse if (rdev->desc->ramp_delay)\n\t\tramp_delay = rdev->desc->ramp_delay;\n\telse if (rdev->constraints->settling_time)\n\t\treturn rdev->constraints->settling_time;\n\telse if (rdev->constraints->settling_time_up &&\n\t\t (new_uV > old_uV))\n\t\treturn rdev->constraints->settling_time_up;\n\telse if (rdev->constraints->settling_time_down &&\n\t\t (new_uV < old_uV))\n\t\treturn rdev->constraints->settling_time_down;\n\n\tif (ramp_delay == 0)\n\t\treturn 0;\n\n\treturn DIV_ROUND_UP(abs(new_uV - old_uV), ramp_delay);\n}\n\nstatic int _regulator_do_set_voltage(struct regulator_dev *rdev,\n\t\t\t\t     int min_uV, int max_uV)\n{\n\tint ret;\n\tint delay = 0;\n\tint best_val = 0;\n\tunsigned int selector;\n\tint old_selector = -1;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint old_uV = regulator_get_voltage_rdev(rdev);\n\n\ttrace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);\n\n\tmin_uV += rdev->constraints->uV_offset;\n\tmax_uV += rdev->constraints->uV_offset;\n\n\t \n\tif (_regulator_is_enabled(rdev) &&\n\t    ops->set_voltage_time_sel && ops->get_voltage_sel) {\n\t\told_selector = ops->get_voltage_sel(rdev);\n\t\tif (old_selector < 0)\n\t\t\treturn old_selector;\n\t}\n\n\tif (ops->set_voltage) {\n\t\tret = _regulator_call_set_voltage(rdev, min_uV, max_uV,\n\t\t\t\t\t\t  &selector);\n\n\t\tif (ret >= 0) {\n\t\t\tif (ops->list_voltage)\n\t\t\t\tbest_val = ops->list_voltage(rdev,\n\t\t\t\t\t\t\t     selector);\n\t\t\telse\n\t\t\t\tbest_val = regulator_get_voltage_rdev(rdev);\n\t\t}\n\n\t} else if (ops->set_voltage_sel) {\n\t\tret = regulator_map_voltage(rdev, min_uV, max_uV);\n\t\tif (ret >= 0) {\n\t\t\tbest_val = ops->list_voltage(rdev, ret);\n\t\t\tif (min_uV <= best_val && max_uV >= best_val) {\n\t\t\t\tselector = ret;\n\t\t\t\tif (old_selector == selector)\n\t\t\t\t\tret = 0;\n\t\t\t\telse if (rdev->desc->vsel_step)\n\t\t\t\t\tret = _regulator_set_voltage_sel_step(\n\t\t\t\t\t\trdev, best_val, selector);\n\t\t\t\telse\n\t\t\t\t\tret = _regulator_call_set_voltage_sel(\n\t\t\t\t\t\trdev, best_val, selector);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tgoto out;\n\n\tif (ops->set_voltage_time_sel) {\n\t\t \n\t\tif (old_selector >= 0 && old_selector != selector)\n\t\t\tdelay = ops->set_voltage_time_sel(rdev, old_selector,\n\t\t\t\t\t\t\t  selector);\n\t} else {\n\t\tif (old_uV != best_val) {\n\t\t\tif (ops->set_voltage_time)\n\t\t\t\tdelay = ops->set_voltage_time(rdev, old_uV,\n\t\t\t\t\t\t\t      best_val);\n\t\t\telse\n\t\t\t\tdelay = _regulator_set_voltage_time(rdev,\n\t\t\t\t\t\t\t\t    old_uV,\n\t\t\t\t\t\t\t\t    best_val);\n\t\t}\n\t}\n\n\tif (delay < 0) {\n\t\trdev_warn(rdev, \"failed to get delay: %pe\\n\", ERR_PTR(delay));\n\t\tdelay = 0;\n\t}\n\n\t \n\t_regulator_delay_helper(delay);\n\n\tif (best_val >= 0) {\n\t\tunsigned long data = best_val;\n\n\t\t_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE,\n\t\t\t\t     (void *)data);\n\t}\n\nout:\n\ttrace_regulator_set_voltage_complete(rdev_get_name(rdev), best_val);\n\n\treturn ret;\n}\n\nstatic int _regulator_do_set_suspend_voltage(struct regulator_dev *rdev,\n\t\t\t\t  int min_uV, int max_uV, suspend_state_t state)\n{\n\tstruct regulator_state *rstate;\n\tint uV, sel;\n\n\trstate = regulator_get_suspend_state(rdev, state);\n\tif (rstate == NULL)\n\t\treturn -EINVAL;\n\n\tif (min_uV < rstate->min_uV)\n\t\tmin_uV = rstate->min_uV;\n\tif (max_uV > rstate->max_uV)\n\t\tmax_uV = rstate->max_uV;\n\n\tsel = regulator_map_voltage(rdev, min_uV, max_uV);\n\tif (sel < 0)\n\t\treturn sel;\n\n\tuV = rdev->desc->ops->list_voltage(rdev, sel);\n\tif (uV >= min_uV && uV <= max_uV)\n\t\trstate->uV = uV;\n\n\treturn 0;\n}\n\nstatic int regulator_set_voltage_unlocked(struct regulator *regulator,\n\t\t\t\t\t  int min_uV, int max_uV,\n\t\t\t\t\t  suspend_state_t state)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tstruct regulator_voltage *voltage = &regulator->voltage[state];\n\tint ret = 0;\n\tint old_min_uV, old_max_uV;\n\tint current_uV;\n\n\t \n\tif (voltage->min_uV == min_uV && voltage->max_uV == max_uV)\n\t\tgoto out;\n\n\t \n\tif (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE)) {\n\t\tcurrent_uV = regulator_get_voltage_rdev(rdev);\n\t\tif (min_uV <= current_uV && current_uV <= max_uV) {\n\t\t\tvoltage->min_uV = min_uV;\n\t\t\tvoltage->max_uV = max_uV;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (!rdev->desc->ops->set_voltage &&\n\t    !rdev->desc->ops->set_voltage_sel) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tret = regulator_check_voltage(rdev, &min_uV, &max_uV);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\told_min_uV = voltage->min_uV;\n\told_max_uV = voltage->max_uV;\n\tvoltage->min_uV = min_uV;\n\tvoltage->max_uV = max_uV;\n\n\t \n\tret = regulator_balance_voltage(rdev, state);\n\tif (ret < 0) {\n\t\tvoltage->min_uV = old_min_uV;\n\t\tvoltage->max_uV = old_max_uV;\n\t}\n\nout:\n\treturn ret;\n}\n\nint regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,\n\t\t\t       int max_uV, suspend_state_t state)\n{\n\tint best_supply_uV = 0;\n\tint supply_change_uV = 0;\n\tint ret;\n\n\tif (rdev->supply &&\n\t    regulator_ops_is_valid(rdev->supply->rdev,\n\t\t\t\t   REGULATOR_CHANGE_VOLTAGE) &&\n\t    (rdev->desc->min_dropout_uV || !(rdev->desc->ops->get_voltage ||\n\t\t\t\t\t   rdev->desc->ops->get_voltage_sel))) {\n\t\tint current_supply_uV;\n\t\tint selector;\n\n\t\tselector = regulator_map_voltage(rdev, min_uV, max_uV);\n\t\tif (selector < 0) {\n\t\t\tret = selector;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbest_supply_uV = _regulator_list_voltage(rdev, selector, 0);\n\t\tif (best_supply_uV < 0) {\n\t\t\tret = best_supply_uV;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbest_supply_uV += rdev->desc->min_dropout_uV;\n\n\t\tcurrent_supply_uV = regulator_get_voltage_rdev(rdev->supply->rdev);\n\t\tif (current_supply_uV < 0) {\n\t\t\tret = current_supply_uV;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsupply_change_uV = best_supply_uV - current_supply_uV;\n\t}\n\n\tif (supply_change_uV > 0) {\n\t\tret = regulator_set_voltage_unlocked(rdev->supply,\n\t\t\t\tbest_supply_uV, INT_MAX, state);\n\t\tif (ret) {\n\t\t\tdev_err(&rdev->dev, \"Failed to increase supply voltage: %pe\\n\",\n\t\t\t\tERR_PTR(ret));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (state == PM_SUSPEND_ON)\n\t\tret = _regulator_do_set_voltage(rdev, min_uV, max_uV);\n\telse\n\t\tret = _regulator_do_set_suspend_voltage(rdev, min_uV,\n\t\t\t\t\t\t\tmax_uV, state);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (supply_change_uV < 0) {\n\t\tret = regulator_set_voltage_unlocked(rdev->supply,\n\t\t\t\tbest_supply_uV, INT_MAX, state);\n\t\tif (ret)\n\t\t\tdev_warn(&rdev->dev, \"Failed to decrease supply voltage: %pe\\n\",\n\t\t\t\t ERR_PTR(ret));\n\t\t \n\t\tret = 0;\n\t}\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_voltage_rdev);\n\nstatic int regulator_limit_voltage_step(struct regulator_dev *rdev,\n\t\t\t\t\tint *current_uV, int *min_uV)\n{\n\tstruct regulation_constraints *constraints = rdev->constraints;\n\n\t \n\tif (!constraints->max_uV_step || !_regulator_is_enabled(rdev))\n\t\treturn 1;\n\n\tif (*current_uV < 0) {\n\t\t*current_uV = regulator_get_voltage_rdev(rdev);\n\n\t\tif (*current_uV < 0)\n\t\t\treturn *current_uV;\n\t}\n\n\tif (abs(*current_uV - *min_uV) <= constraints->max_uV_step)\n\t\treturn 1;\n\n\t \n\tif (*current_uV < *min_uV)\n\t\t*min_uV = min(*current_uV + constraints->max_uV_step,\n\t\t\t      *min_uV);\n\telse\n\t\t*min_uV = max(*current_uV - constraints->max_uV_step,\n\t\t\t      *min_uV);\n\n\treturn 0;\n}\n\nstatic int regulator_get_optimal_voltage(struct regulator_dev *rdev,\n\t\t\t\t\t int *current_uV,\n\t\t\t\t\t int *min_uV, int *max_uV,\n\t\t\t\t\t suspend_state_t state,\n\t\t\t\t\t int n_coupled)\n{\n\tstruct coupling_desc *c_desc = &rdev->coupling_desc;\n\tstruct regulator_dev **c_rdevs = c_desc->coupled_rdevs;\n\tstruct regulation_constraints *constraints = rdev->constraints;\n\tint desired_min_uV = 0, desired_max_uV = INT_MAX;\n\tint max_current_uV = 0, min_current_uV = INT_MAX;\n\tint highest_min_uV = 0, target_uV, possible_uV;\n\tint i, ret, max_spread;\n\tbool done;\n\n\t*current_uV = -1;\n\n\t \n\tif (n_coupled == 1) {\n\t\t \n\t\tdesired_min_uV = constraints->min_uV;\n\t\tdesired_max_uV = constraints->max_uV;\n\n\t\tret = regulator_check_consumers(rdev,\n\t\t\t\t\t\t&desired_min_uV,\n\t\t\t\t\t\t&desired_max_uV, state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tpossible_uV = desired_min_uV;\n\t\tdone = true;\n\n\t\tgoto finish;\n\t}\n\n\t \n\tfor (i = 0; i < n_coupled; i++) {\n\t\tint tmp_min = 0;\n\t\tint tmp_max = INT_MAX;\n\n\t\tlockdep_assert_held_once(&c_rdevs[i]->mutex.base);\n\n\t\tret = regulator_check_consumers(c_rdevs[i],\n\t\t\t\t\t\t&tmp_min,\n\t\t\t\t\t\t&tmp_max, state);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regulator_check_voltage(c_rdevs[i], &tmp_min, &tmp_max);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\thighest_min_uV = max(highest_min_uV, tmp_min);\n\n\t\tif (i == 0) {\n\t\t\tdesired_min_uV = tmp_min;\n\t\t\tdesired_max_uV = tmp_max;\n\t\t}\n\t}\n\n\tmax_spread = constraints->max_spread[0];\n\n\t \n\ttarget_uV = max(desired_min_uV, highest_min_uV - max_spread);\n\n\t \n\tfor (i = 1; i < n_coupled; i++) {\n\t\tint tmp_act;\n\n\t\tif (!_regulator_is_enabled(c_rdevs[i]))\n\t\t\tcontinue;\n\n\t\ttmp_act = regulator_get_voltage_rdev(c_rdevs[i]);\n\t\tif (tmp_act < 0)\n\t\t\treturn tmp_act;\n\n\t\tmin_current_uV = min(tmp_act, min_current_uV);\n\t\tmax_current_uV = max(tmp_act, max_current_uV);\n\t}\n\n\t \n\tif (max_current_uV == 0) {\n\t\tpossible_uV = target_uV;\n\t} else {\n\t\t \n\t\tpossible_uV = max(target_uV, max_current_uV - max_spread);\n\t\tpossible_uV = min(possible_uV, min_current_uV + max_spread);\n\t}\n\n\tif (possible_uV > desired_max_uV)\n\t\treturn -EINVAL;\n\n\tdone = (possible_uV == target_uV);\n\tdesired_min_uV = possible_uV;\n\nfinish:\n\t \n\tif (state == PM_SUSPEND_ON) {\n\t\tret = regulator_limit_voltage_step(rdev, current_uV,\n\t\t\t\t\t\t   &desired_min_uV);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret == 0)\n\t\t\tdone = false;\n\t}\n\n\t \n\tif (n_coupled > 1 && *current_uV == -1) {\n\n\t\tif (_regulator_is_enabled(rdev)) {\n\t\t\tret = regulator_get_voltage_rdev(rdev);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t*current_uV = ret;\n\t\t} else {\n\t\t\t*current_uV = desired_min_uV;\n\t\t}\n\t}\n\n\t*min_uV = desired_min_uV;\n\t*max_uV = desired_max_uV;\n\n\treturn done;\n}\n\nint regulator_do_balance_voltage(struct regulator_dev *rdev,\n\t\t\t\t suspend_state_t state, bool skip_coupled)\n{\n\tstruct regulator_dev **c_rdevs;\n\tstruct regulator_dev *best_rdev;\n\tstruct coupling_desc *c_desc = &rdev->coupling_desc;\n\tint i, ret, n_coupled, best_min_uV, best_max_uV, best_c_rdev;\n\tunsigned int delta, best_delta;\n\tunsigned long c_rdev_done = 0;\n\tbool best_c_rdev_done;\n\n\tc_rdevs = c_desc->coupled_rdevs;\n\tn_coupled = skip_coupled ? 1 : c_desc->n_coupled;\n\n\t \n\tdo {\n\t\tbest_c_rdev_done = false;\n\t\tbest_delta = 0;\n\t\tbest_min_uV = 0;\n\t\tbest_max_uV = 0;\n\t\tbest_c_rdev = 0;\n\t\tbest_rdev = NULL;\n\n\t\t \n\t\tfor (i = 0; i < n_coupled; i++) {\n\t\t\t \n\t\t\tint optimal_uV = 0, optimal_max_uV = 0, current_uV = 0;\n\n\t\t\tif (test_bit(i, &c_rdev_done))\n\t\t\t\tcontinue;\n\n\t\t\tret = regulator_get_optimal_voltage(c_rdevs[i],\n\t\t\t\t\t\t\t    &current_uV,\n\t\t\t\t\t\t\t    &optimal_uV,\n\t\t\t\t\t\t\t    &optimal_max_uV,\n\t\t\t\t\t\t\t    state, n_coupled);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tdelta = abs(optimal_uV - current_uV);\n\n\t\t\tif (delta && best_delta <= delta) {\n\t\t\t\tbest_c_rdev_done = ret;\n\t\t\t\tbest_delta = delta;\n\t\t\t\tbest_rdev = c_rdevs[i];\n\t\t\t\tbest_min_uV = optimal_uV;\n\t\t\t\tbest_max_uV = optimal_max_uV;\n\t\t\t\tbest_c_rdev = i;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!best_rdev) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = regulator_set_voltage_rdev(best_rdev, best_min_uV,\n\t\t\t\t\t\t best_max_uV, state);\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (best_c_rdev_done)\n\t\t\tset_bit(best_c_rdev, &c_rdev_done);\n\n\t} while (n_coupled > 1);\n\nout:\n\treturn ret;\n}\n\nstatic int regulator_balance_voltage(struct regulator_dev *rdev,\n\t\t\t\t     suspend_state_t state)\n{\n\tstruct coupling_desc *c_desc = &rdev->coupling_desc;\n\tstruct regulator_coupler *coupler = c_desc->coupler;\n\tbool skip_coupled = false;\n\n\t \n\tif (state != PM_SUSPEND_ON)\n\t\tskip_coupled = true;\n\n\tif (c_desc->n_resolved < c_desc->n_coupled) {\n\t\trdev_err(rdev, \"Not all coupled regulators registered\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (coupler && coupler->balance_voltage)\n\t\treturn coupler->balance_voltage(coupler, rdev, state);\n\n\treturn regulator_do_balance_voltage(rdev, state, skip_coupled);\n}\n\n \nint regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)\n{\n\tstruct ww_acquire_ctx ww_ctx;\n\tint ret;\n\n\tregulator_lock_dependent(regulator->rdev, &ww_ctx);\n\n\tret = regulator_set_voltage_unlocked(regulator, min_uV, max_uV,\n\t\t\t\t\t     PM_SUSPEND_ON);\n\n\tregulator_unlock_dependent(regulator->rdev, &ww_ctx);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_voltage);\n\nstatic inline int regulator_suspend_toggle(struct regulator_dev *rdev,\n\t\t\t\t\t   suspend_state_t state, bool en)\n{\n\tstruct regulator_state *rstate;\n\n\trstate = regulator_get_suspend_state(rdev, state);\n\tif (rstate == NULL)\n\t\treturn -EINVAL;\n\n\tif (!rstate->changeable)\n\t\treturn -EPERM;\n\n\trstate->enabled = (en) ? ENABLE_IN_SUSPEND : DISABLE_IN_SUSPEND;\n\n\treturn 0;\n}\n\nint regulator_suspend_enable(struct regulator_dev *rdev,\n\t\t\t\t    suspend_state_t state)\n{\n\treturn regulator_suspend_toggle(rdev, state, true);\n}\nEXPORT_SYMBOL_GPL(regulator_suspend_enable);\n\nint regulator_suspend_disable(struct regulator_dev *rdev,\n\t\t\t\t     suspend_state_t state)\n{\n\tstruct regulator *regulator;\n\tstruct regulator_voltage *voltage;\n\n\t \n\tlist_for_each_entry(regulator, &rdev->consumer_list, list) {\n\t\tvoltage = &regulator->voltage[state];\n\t\tif (voltage->min_uV || voltage->max_uV)\n\t\t\treturn 0;\n\t}\n\n\treturn regulator_suspend_toggle(rdev, state, false);\n}\nEXPORT_SYMBOL_GPL(regulator_suspend_disable);\n\nstatic int _regulator_set_suspend_voltage(struct regulator *regulator,\n\t\t\t\t\t  int min_uV, int max_uV,\n\t\t\t\t\t  suspend_state_t state)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tstruct regulator_state *rstate;\n\n\trstate = regulator_get_suspend_state(rdev, state);\n\tif (rstate == NULL)\n\t\treturn -EINVAL;\n\n\tif (rstate->min_uV == rstate->max_uV) {\n\t\trdev_err(rdev, \"The suspend voltage can't be changed!\\n\");\n\t\treturn -EPERM;\n\t}\n\n\treturn regulator_set_voltage_unlocked(regulator, min_uV, max_uV, state);\n}\n\nint regulator_set_suspend_voltage(struct regulator *regulator, int min_uV,\n\t\t\t\t  int max_uV, suspend_state_t state)\n{\n\tstruct ww_acquire_ctx ww_ctx;\n\tint ret;\n\n\t \n\tif (regulator_check_states(state) || state == PM_SUSPEND_ON)\n\t\treturn -EINVAL;\n\n\tregulator_lock_dependent(regulator->rdev, &ww_ctx);\n\n\tret = _regulator_set_suspend_voltage(regulator, min_uV,\n\t\t\t\t\t     max_uV, state);\n\n\tregulator_unlock_dependent(regulator->rdev, &ww_ctx);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_suspend_voltage);\n\n \nint regulator_set_voltage_time(struct regulator *regulator,\n\t\t\t       int old_uV, int new_uV)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tint old_sel = -1;\n\tint new_sel = -1;\n\tint voltage;\n\tint i;\n\n\tif (ops->set_voltage_time)\n\t\treturn ops->set_voltage_time(rdev, old_uV, new_uV);\n\telse if (!ops->set_voltage_time_sel)\n\t\treturn _regulator_set_voltage_time(rdev, old_uV, new_uV);\n\n\t \n\tif (!ops->list_voltage || !rdev->desc->n_voltages)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < rdev->desc->n_voltages; i++) {\n\t\t \n\t\tif (i < rdev->desc->linear_min_sel)\n\t\t\tcontinue;\n\n\t\tif (old_sel >= 0 && new_sel >= 0)\n\t\t\tbreak;\n\n\t\tvoltage = regulator_list_voltage(regulator, i);\n\t\tif (voltage < 0)\n\t\t\treturn -EINVAL;\n\t\tif (voltage == 0)\n\t\t\tcontinue;\n\t\tif (voltage == old_uV)\n\t\t\told_sel = i;\n\t\tif (voltage == new_uV)\n\t\t\tnew_sel = i;\n\t}\n\n\tif (old_sel < 0 || new_sel < 0)\n\t\treturn -EINVAL;\n\n\treturn ops->set_voltage_time_sel(rdev, old_sel, new_sel);\n}\nEXPORT_SYMBOL_GPL(regulator_set_voltage_time);\n\n \nint regulator_set_voltage_time_sel(struct regulator_dev *rdev,\n\t\t\t\t   unsigned int old_selector,\n\t\t\t\t   unsigned int new_selector)\n{\n\tint old_volt, new_volt;\n\n\t \n\tif (!rdev->desc->ops->list_voltage)\n\t\treturn -EINVAL;\n\n\told_volt = rdev->desc->ops->list_voltage(rdev, old_selector);\n\tnew_volt = rdev->desc->ops->list_voltage(rdev, new_selector);\n\n\tif (rdev->desc->ops->set_voltage_time)\n\t\treturn rdev->desc->ops->set_voltage_time(rdev, old_volt,\n\t\t\t\t\t\t\t new_volt);\n\telse\n\t\treturn _regulator_set_voltage_time(rdev, old_volt, new_volt);\n}\nEXPORT_SYMBOL_GPL(regulator_set_voltage_time_sel);\n\nint regulator_sync_voltage_rdev(struct regulator_dev *rdev)\n{\n\tint ret;\n\n\tregulator_lock(rdev);\n\n\tif (!rdev->desc->ops->set_voltage &&\n\t    !rdev->desc->ops->set_voltage_sel) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (rdev->coupling_desc.n_coupled > 1)\n\t\tret = regulator_balance_voltage(rdev, PM_SUSPEND_ON);\n\telse\n\t\tret = -EOPNOTSUPP;\n\nout:\n\tregulator_unlock(rdev);\n\treturn ret;\n}\n\n \nint regulator_sync_voltage(struct regulator *regulator)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tstruct regulator_voltage *voltage = &regulator->voltage[PM_SUSPEND_ON];\n\tint ret, min_uV, max_uV;\n\n\tif (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE))\n\t\treturn 0;\n\n\tregulator_lock(rdev);\n\n\tif (!rdev->desc->ops->set_voltage &&\n\t    !rdev->desc->ops->set_voltage_sel) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!voltage->min_uV && !voltage->max_uV) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmin_uV = voltage->min_uV;\n\tmax_uV = voltage->max_uV;\n\n\t \n\tret = regulator_check_voltage(rdev, &min_uV, &max_uV);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = regulator_check_consumers(rdev, &min_uV, &max_uV, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (rdev->coupling_desc.n_coupled > 1)\n\t\tret = regulator_balance_voltage(rdev, PM_SUSPEND_ON);\n\telse\n\t\tret = _regulator_do_set_voltage(rdev, min_uV, max_uV);\n\nout:\n\tregulator_unlock(rdev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_sync_voltage);\n\nint regulator_get_voltage_rdev(struct regulator_dev *rdev)\n{\n\tint sel, ret;\n\tbool bypassed;\n\n\tif (rdev->desc->ops->get_bypass) {\n\t\tret = rdev->desc->ops->get_bypass(rdev, &bypassed);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (bypassed) {\n\t\t\t \n\t\t\tif (!rdev->supply) {\n\t\t\t\trdev_err(rdev,\n\t\t\t\t\t \"bypassed regulator has no supply!\\n\");\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t\t}\n\n\t\t\treturn regulator_get_voltage_rdev(rdev->supply->rdev);\n\t\t}\n\t}\n\n\tif (rdev->desc->ops->get_voltage_sel) {\n\t\tsel = rdev->desc->ops->get_voltage_sel(rdev);\n\t\tif (sel < 0)\n\t\t\treturn sel;\n\t\tret = rdev->desc->ops->list_voltage(rdev, sel);\n\t} else if (rdev->desc->ops->get_voltage) {\n\t\tret = rdev->desc->ops->get_voltage(rdev);\n\t} else if (rdev->desc->ops->list_voltage) {\n\t\tret = rdev->desc->ops->list_voltage(rdev, 0);\n\t} else if (rdev->desc->fixed_uV && (rdev->desc->n_voltages == 1)) {\n\t\tret = rdev->desc->fixed_uV;\n\t} else if (rdev->supply) {\n\t\tret = regulator_get_voltage_rdev(rdev->supply->rdev);\n\t} else if (rdev->supply_name) {\n\t\treturn -EPROBE_DEFER;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn ret - rdev->constraints->uV_offset;\n}\nEXPORT_SYMBOL_GPL(regulator_get_voltage_rdev);\n\n \nint regulator_get_voltage(struct regulator *regulator)\n{\n\tstruct ww_acquire_ctx ww_ctx;\n\tint ret;\n\n\tregulator_lock_dependent(regulator->rdev, &ww_ctx);\n\tret = regulator_get_voltage_rdev(regulator->rdev);\n\tregulator_unlock_dependent(regulator->rdev, &ww_ctx);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_get_voltage);\n\n \nint regulator_set_current_limit(struct regulator *regulator,\n\t\t\t       int min_uA, int max_uA)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret;\n\n\tregulator_lock(rdev);\n\n\t \n\tif (!rdev->desc->ops->set_current_limit) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tret = regulator_check_current_limit(rdev, &min_uA, &max_uA);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = rdev->desc->ops->set_current_limit(rdev, min_uA, max_uA);\nout:\n\tregulator_unlock(rdev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_current_limit);\n\nstatic int _regulator_get_current_limit_unlocked(struct regulator_dev *rdev)\n{\n\t \n\tif (!rdev->desc->ops->get_current_limit)\n\t\treturn -EINVAL;\n\n\treturn rdev->desc->ops->get_current_limit(rdev);\n}\n\nstatic int _regulator_get_current_limit(struct regulator_dev *rdev)\n{\n\tint ret;\n\n\tregulator_lock(rdev);\n\tret = _regulator_get_current_limit_unlocked(rdev);\n\tregulator_unlock(rdev);\n\n\treturn ret;\n}\n\n \nint regulator_get_current_limit(struct regulator *regulator)\n{\n\treturn _regulator_get_current_limit(regulator->rdev);\n}\nEXPORT_SYMBOL_GPL(regulator_get_current_limit);\n\n \nint regulator_set_mode(struct regulator *regulator, unsigned int mode)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret;\n\tint regulator_curr_mode;\n\n\tregulator_lock(rdev);\n\n\t \n\tif (!rdev->desc->ops->set_mode) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (rdev->desc->ops->get_mode) {\n\t\tregulator_curr_mode = rdev->desc->ops->get_mode(rdev);\n\t\tif (regulator_curr_mode == mode) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = regulator_mode_constrain(rdev, &mode);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = rdev->desc->ops->set_mode(rdev, mode);\nout:\n\tregulator_unlock(rdev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_mode);\n\nstatic unsigned int _regulator_get_mode_unlocked(struct regulator_dev *rdev)\n{\n\t \n\tif (!rdev->desc->ops->get_mode)\n\t\treturn -EINVAL;\n\n\treturn rdev->desc->ops->get_mode(rdev);\n}\n\nstatic unsigned int _regulator_get_mode(struct regulator_dev *rdev)\n{\n\tint ret;\n\n\tregulator_lock(rdev);\n\tret = _regulator_get_mode_unlocked(rdev);\n\tregulator_unlock(rdev);\n\n\treturn ret;\n}\n\n \nunsigned int regulator_get_mode(struct regulator *regulator)\n{\n\treturn _regulator_get_mode(regulator->rdev);\n}\nEXPORT_SYMBOL_GPL(regulator_get_mode);\n\nstatic int rdev_get_cached_err_flags(struct regulator_dev *rdev)\n{\n\tint ret = 0;\n\n\tif (rdev->use_cached_err) {\n\t\tspin_lock(&rdev->err_lock);\n\t\tret = rdev->cached_err;\n\t\tspin_unlock(&rdev->err_lock);\n\t}\n\treturn ret;\n}\n\nstatic int _regulator_get_error_flags(struct regulator_dev *rdev,\n\t\t\t\t\tunsigned int *flags)\n{\n\tint cached_flags, ret = 0;\n\n\tregulator_lock(rdev);\n\n\tcached_flags = rdev_get_cached_err_flags(rdev);\n\n\tif (rdev->desc->ops->get_error_flags)\n\t\tret = rdev->desc->ops->get_error_flags(rdev, flags);\n\telse if (!rdev->use_cached_err)\n\t\tret = -EINVAL;\n\n\t*flags |= cached_flags;\n\n\tregulator_unlock(rdev);\n\n\treturn ret;\n}\n\n \nint regulator_get_error_flags(struct regulator *regulator,\n\t\t\t\tunsigned int *flags)\n{\n\treturn _regulator_get_error_flags(regulator->rdev, flags);\n}\nEXPORT_SYMBOL_GPL(regulator_get_error_flags);\n\n \nint regulator_set_load(struct regulator *regulator, int uA_load)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint old_uA_load;\n\tint ret = 0;\n\n\tregulator_lock(rdev);\n\told_uA_load = regulator->uA_load;\n\tregulator->uA_load = uA_load;\n\tif (regulator->enable_count && old_uA_load != uA_load) {\n\t\tret = drms_uA_update(rdev);\n\t\tif (ret < 0)\n\t\t\tregulator->uA_load = old_uA_load;\n\t}\n\tregulator_unlock(rdev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_set_load);\n\n \nint regulator_allow_bypass(struct regulator *regulator, bool enable)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tconst char *name = rdev_get_name(rdev);\n\tint ret = 0;\n\n\tif (!rdev->desc->ops->set_bypass)\n\t\treturn 0;\n\n\tif (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_BYPASS))\n\t\treturn 0;\n\n\tregulator_lock(rdev);\n\n\tif (enable && !regulator->bypass) {\n\t\trdev->bypass_count++;\n\n\t\tif (rdev->bypass_count == rdev->open_count) {\n\t\t\ttrace_regulator_bypass_enable(name);\n\n\t\t\tret = rdev->desc->ops->set_bypass(rdev, enable);\n\t\t\tif (ret != 0)\n\t\t\t\trdev->bypass_count--;\n\t\t\telse\n\t\t\t\ttrace_regulator_bypass_enable_complete(name);\n\t\t}\n\n\t} else if (!enable && regulator->bypass) {\n\t\trdev->bypass_count--;\n\n\t\tif (rdev->bypass_count != rdev->open_count) {\n\t\t\ttrace_regulator_bypass_disable(name);\n\n\t\t\tret = rdev->desc->ops->set_bypass(rdev, enable);\n\t\t\tif (ret != 0)\n\t\t\t\trdev->bypass_count++;\n\t\t\telse\n\t\t\t\ttrace_regulator_bypass_disable_complete(name);\n\t\t}\n\t}\n\n\tif (ret == 0)\n\t\tregulator->bypass = enable;\n\n\tregulator_unlock(rdev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_allow_bypass);\n\n \nint regulator_register_notifier(struct regulator *regulator,\n\t\t\t      struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&regulator->rdev->notifier,\n\t\t\t\t\t\tnb);\n}\nEXPORT_SYMBOL_GPL(regulator_register_notifier);\n\n \nint regulator_unregister_notifier(struct regulator *regulator,\n\t\t\t\tstruct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&regulator->rdev->notifier,\n\t\t\t\t\t\t  nb);\n}\nEXPORT_SYMBOL_GPL(regulator_unregister_notifier);\n\n \nstatic int _notifier_call_chain(struct regulator_dev *rdev,\n\t\t\t\t  unsigned long event, void *data)\n{\n\t \n\treturn blocking_notifier_call_chain(&rdev->notifier, event, data);\n}\n\nint _regulator_bulk_get(struct device *dev, int num_consumers,\n\t\t\tstruct regulator_bulk_data *consumers, enum regulator_get_type get_type)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < num_consumers; i++)\n\t\tconsumers[i].consumer = NULL;\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tconsumers[i].consumer = _regulator_get(dev,\n\t\t\t\t\t\t       consumers[i].supply, get_type);\n\t\tif (IS_ERR(consumers[i].consumer)) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(consumers[i].consumer),\n\t\t\t\t\t    \"Failed to get supply '%s'\",\n\t\t\t\t\t    consumers[i].supply);\n\t\t\tconsumers[i].consumer = NULL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (consumers[i].init_load_uA > 0) {\n\t\t\tret = regulator_set_load(consumers[i].consumer,\n\t\t\t\t\t\t consumers[i].init_load_uA);\n\t\t\tif (ret) {\n\t\t\t\ti++;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0)\n\t\tregulator_put(consumers[i].consumer);\n\n\treturn ret;\n}\n\n \nint regulator_bulk_get(struct device *dev, int num_consumers,\n\t\t       struct regulator_bulk_data *consumers)\n{\n\treturn _regulator_bulk_get(dev, num_consumers, consumers, NORMAL_GET);\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_get);\n\nstatic void regulator_bulk_enable_async(void *data, async_cookie_t cookie)\n{\n\tstruct regulator_bulk_data *bulk = data;\n\n\tbulk->ret = regulator_enable(bulk->consumer);\n}\n\n \nint regulator_bulk_enable(int num_consumers,\n\t\t\t  struct regulator_bulk_data *consumers)\n{\n\tASYNC_DOMAIN_EXCLUSIVE(async_domain);\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tasync_schedule_domain(regulator_bulk_enable_async,\n\t\t\t\t      &consumers[i], &async_domain);\n\t}\n\n\tasync_synchronize_full_domain(&async_domain);\n\n\t \n\tfor (i = 0; i < num_consumers; i++) {\n\t\tif (consumers[i].ret != 0) {\n\t\t\tret = consumers[i].ret;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tif (consumers[i].ret < 0)\n\t\t\tpr_err(\"Failed to enable %s: %pe\\n\", consumers[i].supply,\n\t\t\t       ERR_PTR(consumers[i].ret));\n\t\telse\n\t\t\tregulator_disable(consumers[i].consumer);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_enable);\n\n \nint regulator_bulk_disable(int num_consumers,\n\t\t\t   struct regulator_bulk_data *consumers)\n{\n\tint i;\n\tint ret, r;\n\n\tfor (i = num_consumers - 1; i >= 0; --i) {\n\t\tret = regulator_disable(consumers[i].consumer);\n\t\tif (ret != 0)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tpr_err(\"Failed to disable %s: %pe\\n\", consumers[i].supply, ERR_PTR(ret));\n\tfor (++i; i < num_consumers; ++i) {\n\t\tr = regulator_enable(consumers[i].consumer);\n\t\tif (r != 0)\n\t\t\tpr_err(\"Failed to re-enable %s: %pe\\n\",\n\t\t\t       consumers[i].supply, ERR_PTR(r));\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_disable);\n\n \nint regulator_bulk_force_disable(int num_consumers,\n\t\t\t   struct regulator_bulk_data *consumers)\n{\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tconsumers[i].ret =\n\t\t\t    regulator_force_disable(consumers[i].consumer);\n\n\t\t \n\t\tif (consumers[i].ret && !ret)\n\t\t\tret = consumers[i].ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_force_disable);\n\n \nvoid regulator_bulk_free(int num_consumers,\n\t\t\t struct regulator_bulk_data *consumers)\n{\n\tint i;\n\n\tfor (i = 0; i < num_consumers; i++) {\n\t\tregulator_put(consumers[i].consumer);\n\t\tconsumers[i].consumer = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(regulator_bulk_free);\n\n \nint regulator_notifier_call_chain(struct regulator_dev *rdev,\n\t\t\t\t  unsigned long event, void *data)\n{\n\t_notifier_call_chain(rdev, event, data);\n\treturn NOTIFY_DONE;\n\n}\nEXPORT_SYMBOL_GPL(regulator_notifier_call_chain);\n\n \nint regulator_mode_to_status(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\treturn REGULATOR_STATUS_FAST;\n\tcase REGULATOR_MODE_NORMAL:\n\t\treturn REGULATOR_STATUS_NORMAL;\n\tcase REGULATOR_MODE_IDLE:\n\t\treturn REGULATOR_STATUS_IDLE;\n\tcase REGULATOR_MODE_STANDBY:\n\t\treturn REGULATOR_STATUS_STANDBY;\n\tdefault:\n\t\treturn REGULATOR_STATUS_UNDEFINED;\n\t}\n}\nEXPORT_SYMBOL_GPL(regulator_mode_to_status);\n\nstatic struct attribute *regulator_dev_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_num_users.attr,\n\t&dev_attr_type.attr,\n\t&dev_attr_microvolts.attr,\n\t&dev_attr_microamps.attr,\n\t&dev_attr_opmode.attr,\n\t&dev_attr_state.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_bypass.attr,\n\t&dev_attr_requested_microamps.attr,\n\t&dev_attr_min_microvolts.attr,\n\t&dev_attr_max_microvolts.attr,\n\t&dev_attr_min_microamps.attr,\n\t&dev_attr_max_microamps.attr,\n\t&dev_attr_under_voltage.attr,\n\t&dev_attr_over_current.attr,\n\t&dev_attr_regulation_out.attr,\n\t&dev_attr_fail.attr,\n\t&dev_attr_over_temp.attr,\n\t&dev_attr_under_voltage_warn.attr,\n\t&dev_attr_over_current_warn.attr,\n\t&dev_attr_over_voltage_warn.attr,\n\t&dev_attr_over_temp_warn.attr,\n\t&dev_attr_suspend_standby_state.attr,\n\t&dev_attr_suspend_mem_state.attr,\n\t&dev_attr_suspend_disk_state.attr,\n\t&dev_attr_suspend_standby_microvolts.attr,\n\t&dev_attr_suspend_mem_microvolts.attr,\n\t&dev_attr_suspend_disk_microvolts.attr,\n\t&dev_attr_suspend_standby_mode.attr,\n\t&dev_attr_suspend_mem_mode.attr,\n\t&dev_attr_suspend_disk_mode.attr,\n\tNULL\n};\n\n \nstatic umode_t regulator_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct regulator_dev *rdev = dev_to_rdev(dev);\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\tumode_t mode = attr->mode;\n\n\t \n\tif (attr == &dev_attr_name.attr ||\n\t    attr == &dev_attr_num_users.attr ||\n\t    attr == &dev_attr_type.attr)\n\t\treturn mode;\n\n\t \n\tif (attr == &dev_attr_microvolts.attr) {\n\t\tif ((ops->get_voltage && ops->get_voltage(rdev) >= 0) ||\n\t\t    (ops->get_voltage_sel && ops->get_voltage_sel(rdev) >= 0) ||\n\t\t    (ops->list_voltage && ops->list_voltage(rdev, 0) >= 0) ||\n\t\t    (rdev->desc->fixed_uV && rdev->desc->n_voltages == 1))\n\t\t\treturn mode;\n\t\treturn 0;\n\t}\n\n\tif (attr == &dev_attr_microamps.attr)\n\t\treturn ops->get_current_limit ? mode : 0;\n\n\tif (attr == &dev_attr_opmode.attr)\n\t\treturn ops->get_mode ? mode : 0;\n\n\tif (attr == &dev_attr_state.attr)\n\t\treturn (rdev->ena_pin || ops->is_enabled) ? mode : 0;\n\n\tif (attr == &dev_attr_status.attr)\n\t\treturn ops->get_status ? mode : 0;\n\n\tif (attr == &dev_attr_bypass.attr)\n\t\treturn ops->get_bypass ? mode : 0;\n\n\tif (attr == &dev_attr_under_voltage.attr ||\n\t    attr == &dev_attr_over_current.attr ||\n\t    attr == &dev_attr_regulation_out.attr ||\n\t    attr == &dev_attr_fail.attr ||\n\t    attr == &dev_attr_over_temp.attr ||\n\t    attr == &dev_attr_under_voltage_warn.attr ||\n\t    attr == &dev_attr_over_current_warn.attr ||\n\t    attr == &dev_attr_over_voltage_warn.attr ||\n\t    attr == &dev_attr_over_temp_warn.attr)\n\t\treturn ops->get_error_flags ? mode : 0;\n\n\t \n\tif (attr == &dev_attr_min_microvolts.attr ||\n\t    attr == &dev_attr_max_microvolts.attr)\n\t\treturn (ops->set_voltage || ops->set_voltage_sel) ? mode : 0;\n\n\tif (attr == &dev_attr_min_microamps.attr ||\n\t    attr == &dev_attr_max_microamps.attr)\n\t\treturn ops->set_current_limit ? mode : 0;\n\n\tif (attr == &dev_attr_suspend_standby_state.attr ||\n\t    attr == &dev_attr_suspend_mem_state.attr ||\n\t    attr == &dev_attr_suspend_disk_state.attr)\n\t\treturn mode;\n\n\tif (attr == &dev_attr_suspend_standby_microvolts.attr ||\n\t    attr == &dev_attr_suspend_mem_microvolts.attr ||\n\t    attr == &dev_attr_suspend_disk_microvolts.attr)\n\t\treturn ops->set_suspend_voltage ? mode : 0;\n\n\tif (attr == &dev_attr_suspend_standby_mode.attr ||\n\t    attr == &dev_attr_suspend_mem_mode.attr ||\n\t    attr == &dev_attr_suspend_disk_mode.attr)\n\t\treturn ops->set_suspend_mode ? mode : 0;\n\n\treturn mode;\n}\n\nstatic const struct attribute_group regulator_dev_group = {\n\t.attrs = regulator_dev_attrs,\n\t.is_visible = regulator_attr_is_visible,\n};\n\nstatic const struct attribute_group *regulator_dev_groups[] = {\n\t&regulator_dev_group,\n\tNULL\n};\n\nstatic void regulator_dev_release(struct device *dev)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\tdebugfs_remove_recursive(rdev->debugfs);\n\tkfree(rdev->constraints);\n\tof_node_put(rdev->dev.of_node);\n\tkfree(rdev);\n}\n\nstatic void rdev_init_debugfs(struct regulator_dev *rdev)\n{\n\tstruct device *parent = rdev->dev.parent;\n\tconst char *rname = rdev_get_name(rdev);\n\tchar name[NAME_MAX];\n\n\t \n\tif (parent && rname == rdev->desc->name) {\n\t\tsnprintf(name, sizeof(name), \"%s-%s\", dev_name(parent),\n\t\t\t rname);\n\t\trname = name;\n\t}\n\n\trdev->debugfs = debugfs_create_dir(rname, debugfs_root);\n\tif (IS_ERR(rdev->debugfs))\n\t\trdev_dbg(rdev, \"Failed to create debugfs directory\\n\");\n\n\tdebugfs_create_u32(\"use_count\", 0444, rdev->debugfs,\n\t\t\t   &rdev->use_count);\n\tdebugfs_create_u32(\"open_count\", 0444, rdev->debugfs,\n\t\t\t   &rdev->open_count);\n\tdebugfs_create_u32(\"bypass_count\", 0444, rdev->debugfs,\n\t\t\t   &rdev->bypass_count);\n}\n\nstatic int regulator_register_resolve_supply(struct device *dev, void *data)\n{\n\tstruct regulator_dev *rdev = dev_to_rdev(dev);\n\n\tif (regulator_resolve_supply(rdev))\n\t\trdev_dbg(rdev, \"unable to resolve supply\\n\");\n\n\treturn 0;\n}\n\nint regulator_coupler_register(struct regulator_coupler *coupler)\n{\n\tmutex_lock(&regulator_list_mutex);\n\tlist_add_tail(&coupler->list, &regulator_coupler_list);\n\tmutex_unlock(&regulator_list_mutex);\n\n\treturn 0;\n}\n\nstatic struct regulator_coupler *\nregulator_find_coupler(struct regulator_dev *rdev)\n{\n\tstruct regulator_coupler *coupler;\n\tint err;\n\n\t \n\tlist_for_each_entry_reverse(coupler, &regulator_coupler_list, list) {\n\t\terr = coupler->attach_regulator(coupler, rdev);\n\t\tif (!err) {\n\t\t\tif (!coupler->balance_voltage &&\n\t\t\t    rdev->coupling_desc.n_coupled > 2)\n\t\t\t\tgoto err_unsupported;\n\n\t\t\treturn coupler;\n\t\t}\n\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\n\t\tif (err == 1)\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n\nerr_unsupported:\n\tif (coupler->detach_regulator)\n\t\tcoupler->detach_regulator(coupler, rdev);\n\n\trdev_err(rdev,\n\t\t\"Voltage balancing for multiple regulator couples is unimplemented\\n\");\n\n\treturn ERR_PTR(-EPERM);\n}\n\nstatic void regulator_resolve_coupling(struct regulator_dev *rdev)\n{\n\tstruct regulator_coupler *coupler = rdev->coupling_desc.coupler;\n\tstruct coupling_desc *c_desc = &rdev->coupling_desc;\n\tint n_coupled = c_desc->n_coupled;\n\tstruct regulator_dev *c_rdev;\n\tint i;\n\n\tfor (i = 1; i < n_coupled; i++) {\n\t\t \n\t\tif (c_desc->coupled_rdevs[i])\n\t\t\tcontinue;\n\n\t\tc_rdev = of_parse_coupled_regulator(rdev, i - 1);\n\n\t\tif (!c_rdev)\n\t\t\tcontinue;\n\n\t\tif (c_rdev->coupling_desc.coupler != coupler) {\n\t\t\trdev_err(rdev, \"coupler mismatch with %s\\n\",\n\t\t\t\t rdev_get_name(c_rdev));\n\t\t\treturn;\n\t\t}\n\n\t\tc_desc->coupled_rdevs[i] = c_rdev;\n\t\tc_desc->n_resolved++;\n\n\t\tregulator_resolve_coupling(c_rdev);\n\t}\n}\n\nstatic void regulator_remove_coupling(struct regulator_dev *rdev)\n{\n\tstruct regulator_coupler *coupler = rdev->coupling_desc.coupler;\n\tstruct coupling_desc *__c_desc, *c_desc = &rdev->coupling_desc;\n\tstruct regulator_dev *__c_rdev, *c_rdev;\n\tunsigned int __n_coupled, n_coupled;\n\tint i, k;\n\tint err;\n\n\tn_coupled = c_desc->n_coupled;\n\n\tfor (i = 1; i < n_coupled; i++) {\n\t\tc_rdev = c_desc->coupled_rdevs[i];\n\n\t\tif (!c_rdev)\n\t\t\tcontinue;\n\n\t\tregulator_lock(c_rdev);\n\n\t\t__c_desc = &c_rdev->coupling_desc;\n\t\t__n_coupled = __c_desc->n_coupled;\n\n\t\tfor (k = 1; k < __n_coupled; k++) {\n\t\t\t__c_rdev = __c_desc->coupled_rdevs[k];\n\n\t\t\tif (__c_rdev == rdev) {\n\t\t\t\t__c_desc->coupled_rdevs[k] = NULL;\n\t\t\t\t__c_desc->n_resolved--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tregulator_unlock(c_rdev);\n\n\t\tc_desc->coupled_rdevs[i] = NULL;\n\t\tc_desc->n_resolved--;\n\t}\n\n\tif (coupler && coupler->detach_regulator) {\n\t\terr = coupler->detach_regulator(coupler, rdev);\n\t\tif (err)\n\t\t\trdev_err(rdev, \"failed to detach from coupler: %pe\\n\",\n\t\t\t\t ERR_PTR(err));\n\t}\n\n\tkfree(rdev->coupling_desc.coupled_rdevs);\n\trdev->coupling_desc.coupled_rdevs = NULL;\n}\n\nstatic int regulator_init_coupling(struct regulator_dev *rdev)\n{\n\tstruct regulator_dev **coupled;\n\tint err, n_phandles;\n\n\tif (!IS_ENABLED(CONFIG_OF))\n\t\tn_phandles = 0;\n\telse\n\t\tn_phandles = of_get_n_coupled(rdev);\n\n\tcoupled = kcalloc(n_phandles + 1, sizeof(*coupled), GFP_KERNEL);\n\tif (!coupled)\n\t\treturn -ENOMEM;\n\n\trdev->coupling_desc.coupled_rdevs = coupled;\n\n\t \n\trdev->coupling_desc.coupled_rdevs[0] = rdev;\n\trdev->coupling_desc.n_coupled = n_phandles + 1;\n\trdev->coupling_desc.n_resolved++;\n\n\t \n\tif (n_phandles == 0)\n\t\treturn 0;\n\n\tif (!of_check_coupling_data(rdev))\n\t\treturn -EPERM;\n\n\tmutex_lock(&regulator_list_mutex);\n\trdev->coupling_desc.coupler = regulator_find_coupler(rdev);\n\tmutex_unlock(&regulator_list_mutex);\n\n\tif (IS_ERR(rdev->coupling_desc.coupler)) {\n\t\terr = PTR_ERR(rdev->coupling_desc.coupler);\n\t\trdev_err(rdev, \"failed to get coupler: %pe\\n\", ERR_PTR(err));\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int generic_coupler_attach(struct regulator_coupler *coupler,\n\t\t\t\t  struct regulator_dev *rdev)\n{\n\tif (rdev->coupling_desc.n_coupled > 2) {\n\t\trdev_err(rdev,\n\t\t\t \"Voltage balancing for multiple regulator couples is unimplemented\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (!rdev->constraints->always_on) {\n\t\trdev_err(rdev,\n\t\t\t \"Coupling of a non always-on regulator is unimplemented\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic struct regulator_coupler generic_regulator_coupler = {\n\t.attach_regulator = generic_coupler_attach,\n};\n\n \nstruct regulator_dev *\nregulator_register(struct device *dev,\n\t\t   const struct regulator_desc *regulator_desc,\n\t\t   const struct regulator_config *cfg)\n{\n\tconst struct regulator_init_data *init_data;\n\tstruct regulator_config *config = NULL;\n\tstatic atomic_t regulator_no = ATOMIC_INIT(-1);\n\tstruct regulator_dev *rdev;\n\tbool dangling_cfg_gpiod = false;\n\tbool dangling_of_gpiod = false;\n\tint ret, i;\n\tbool resolved_early = false;\n\n\tif (cfg == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (cfg->ena_gpiod)\n\t\tdangling_cfg_gpiod = true;\n\tif (regulator_desc == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto rinse;\n\t}\n\n\tWARN_ON(!dev || !cfg->dev);\n\n\tif (regulator_desc->name == NULL || regulator_desc->ops == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto rinse;\n\t}\n\n\tif (regulator_desc->type != REGULATOR_VOLTAGE &&\n\t    regulator_desc->type != REGULATOR_CURRENT) {\n\t\tret = -EINVAL;\n\t\tgoto rinse;\n\t}\n\n\t \n\tWARN_ON(regulator_desc->ops->get_voltage &&\n\t\tregulator_desc->ops->get_voltage_sel);\n\tWARN_ON(regulator_desc->ops->set_voltage &&\n\t\tregulator_desc->ops->set_voltage_sel);\n\n\t \n\tif (regulator_desc->ops->get_voltage_sel &&\n\t    !regulator_desc->ops->list_voltage) {\n\t\tret = -EINVAL;\n\t\tgoto rinse;\n\t}\n\tif (regulator_desc->ops->set_voltage_sel &&\n\t    !regulator_desc->ops->list_voltage) {\n\t\tret = -EINVAL;\n\t\tgoto rinse;\n\t}\n\n\trdev = kzalloc(sizeof(struct regulator_dev), GFP_KERNEL);\n\tif (rdev == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto rinse;\n\t}\n\tdevice_initialize(&rdev->dev);\n\tdev_set_drvdata(&rdev->dev, rdev);\n\trdev->dev.class = &regulator_class;\n\tspin_lock_init(&rdev->err_lock);\n\n\t \n\tconfig = kmemdup(cfg, sizeof(*cfg), GFP_KERNEL);\n\tif (config == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto clean;\n\t}\n\n\tinit_data = regulator_of_get_init_data(dev, regulator_desc, config,\n\t\t\t\t\t       &rdev->dev.of_node);\n\n\t \n\tif (PTR_ERR(init_data) == -EPROBE_DEFER) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto clean;\n\t}\n\n\t \n\tif (!cfg->ena_gpiod && config->ena_gpiod)\n\t\tdangling_of_gpiod = true;\n\tif (!init_data) {\n\t\tinit_data = config->init_data;\n\t\trdev->dev.of_node = of_node_get(config->of_node);\n\t}\n\n\tww_mutex_init(&rdev->mutex, &regulator_ww_class);\n\trdev->reg_data = config->driver_data;\n\trdev->owner = regulator_desc->owner;\n\trdev->desc = regulator_desc;\n\tif (config->regmap)\n\t\trdev->regmap = config->regmap;\n\telse if (dev_get_regmap(dev, NULL))\n\t\trdev->regmap = dev_get_regmap(dev, NULL);\n\telse if (dev->parent)\n\t\trdev->regmap = dev_get_regmap(dev->parent, NULL);\n\tINIT_LIST_HEAD(&rdev->consumer_list);\n\tINIT_LIST_HEAD(&rdev->list);\n\tBLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);\n\tINIT_DELAYED_WORK(&rdev->disable_work, regulator_disable_work);\n\n\tif (init_data && init_data->supply_regulator)\n\t\trdev->supply_name = init_data->supply_regulator;\n\telse if (regulator_desc->supply_name)\n\t\trdev->supply_name = regulator_desc->supply_name;\n\n\t \n\trdev->dev.parent = config->dev;\n\tdev_set_name(&rdev->dev, \"regulator.%lu\",\n\t\t    (unsigned long) atomic_inc_return(&regulator_no));\n\n\t \n\tif (init_data)\n\t\trdev->constraints = kmemdup(&init_data->constraints,\n\t\t\t\t\t    sizeof(*rdev->constraints),\n\t\t\t\t\t    GFP_KERNEL);\n\telse\n\t\trdev->constraints = kzalloc(sizeof(*rdev->constraints),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!rdev->constraints) {\n\t\tret = -ENOMEM;\n\t\tgoto wash;\n\t}\n\n\tif ((rdev->supply_name && !rdev->supply) &&\n\t\t(rdev->constraints->always_on ||\n\t\t rdev->constraints->boot_on)) {\n\t\tret = regulator_resolve_supply(rdev);\n\t\tif (ret)\n\t\t\trdev_dbg(rdev, \"unable to resolve supply early: %pe\\n\",\n\t\t\t\t\t ERR_PTR(ret));\n\n\t\tresolved_early = true;\n\t}\n\n\t \n\tif (init_data && init_data->regulator_init) {\n\t\tret = init_data->regulator_init(rdev->reg_data);\n\t\tif (ret < 0)\n\t\t\tgoto wash;\n\t}\n\n\tif (config->ena_gpiod) {\n\t\tret = regulator_ena_gpio_request(rdev, config);\n\t\tif (ret != 0) {\n\t\t\trdev_err(rdev, \"Failed to request enable GPIO: %pe\\n\",\n\t\t\t\t ERR_PTR(ret));\n\t\t\tgoto wash;\n\t\t}\n\t\t \n\t\tdangling_cfg_gpiod = false;\n\t\tdangling_of_gpiod = false;\n\t}\n\n\tret = set_machine_constraints(rdev);\n\tif (ret == -EPROBE_DEFER && !resolved_early) {\n\t\t \n\t\t \n\t\trdev_dbg(rdev, \"will resolve supply early: %s\\n\",\n\t\t\t rdev->supply_name);\n\t\tret = regulator_resolve_supply(rdev);\n\t\tif (!ret)\n\t\t\tret = set_machine_constraints(rdev);\n\t\telse\n\t\t\trdev_dbg(rdev, \"unable to resolve supply early: %pe\\n\",\n\t\t\t\t ERR_PTR(ret));\n\t}\n\tif (ret < 0)\n\t\tgoto wash;\n\n\tret = regulator_init_coupling(rdev);\n\tif (ret < 0)\n\t\tgoto wash;\n\n\t \n\tif (init_data) {\n\t\tfor (i = 0; i < init_data->num_consumer_supplies; i++) {\n\t\t\tret = set_consumer_device_supply(rdev,\n\t\t\t\tinit_data->consumer_supplies[i].dev_name,\n\t\t\t\tinit_data->consumer_supplies[i].supply);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Failed to set supply %s\\n\",\n\t\t\t\t\tinit_data->consumer_supplies[i].supply);\n\t\t\t\tgoto unset_supplies;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!rdev->desc->ops->get_voltage &&\n\t    !rdev->desc->ops->list_voltage &&\n\t    !rdev->desc->fixed_uV)\n\t\trdev->is_switch = true;\n\n\tret = device_add(&rdev->dev);\n\tif (ret != 0)\n\t\tgoto unset_supplies;\n\n\trdev_init_debugfs(rdev);\n\n\t \n\tmutex_lock(&regulator_list_mutex);\n\tregulator_resolve_coupling(rdev);\n\tmutex_unlock(&regulator_list_mutex);\n\n\t \n\tclass_for_each_device(&regulator_class, NULL, NULL,\n\t\t\t      regulator_register_resolve_supply);\n\tkfree(config);\n\treturn rdev;\n\nunset_supplies:\n\tmutex_lock(&regulator_list_mutex);\n\tunset_regulator_supplies(rdev);\n\tregulator_remove_coupling(rdev);\n\tmutex_unlock(&regulator_list_mutex);\nwash:\n\tregulator_put(rdev->supply);\n\tkfree(rdev->coupling_desc.coupled_rdevs);\n\tmutex_lock(&regulator_list_mutex);\n\tregulator_ena_gpio_free(rdev);\n\tmutex_unlock(&regulator_list_mutex);\nclean:\n\tif (dangling_of_gpiod)\n\t\tgpiod_put(config->ena_gpiod);\n\tkfree(config);\n\tput_device(&rdev->dev);\nrinse:\n\tif (dangling_cfg_gpiod)\n\t\tgpiod_put(cfg->ena_gpiod);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(regulator_register);\n\n \nvoid regulator_unregister(struct regulator_dev *rdev)\n{\n\tif (rdev == NULL)\n\t\treturn;\n\n\tif (rdev->supply) {\n\t\twhile (rdev->use_count--)\n\t\t\tregulator_disable(rdev->supply);\n\t\tregulator_put(rdev->supply);\n\t}\n\n\tflush_work(&rdev->disable_work.work);\n\n\tmutex_lock(&regulator_list_mutex);\n\n\tWARN_ON(rdev->open_count);\n\tregulator_remove_coupling(rdev);\n\tunset_regulator_supplies(rdev);\n\tlist_del(&rdev->list);\n\tregulator_ena_gpio_free(rdev);\n\tdevice_unregister(&rdev->dev);\n\n\tmutex_unlock(&regulator_list_mutex);\n}\nEXPORT_SYMBOL_GPL(regulator_unregister);\n\n#ifdef CONFIG_SUSPEND\n \nstatic int regulator_suspend(struct device *dev)\n{\n\tstruct regulator_dev *rdev = dev_to_rdev(dev);\n\tsuspend_state_t state = pm_suspend_target_state;\n\tint ret;\n\tconst struct regulator_state *rstate;\n\n\trstate = regulator_get_suspend_state_check(rdev, state);\n\tif (!rstate)\n\t\treturn 0;\n\n\tregulator_lock(rdev);\n\tret = __suspend_set_state(rdev, rstate);\n\tregulator_unlock(rdev);\n\n\treturn ret;\n}\n\nstatic int regulator_resume(struct device *dev)\n{\n\tsuspend_state_t state = pm_suspend_target_state;\n\tstruct regulator_dev *rdev = dev_to_rdev(dev);\n\tstruct regulator_state *rstate;\n\tint ret = 0;\n\n\trstate = regulator_get_suspend_state(rdev, state);\n\tif (rstate == NULL)\n\t\treturn 0;\n\n\t \n\tif (!rdev->desc->ops->resume)\n\t\treturn 0;\n\n\tregulator_lock(rdev);\n\n\tif (rstate->enabled == ENABLE_IN_SUSPEND ||\n\t    rstate->enabled == DISABLE_IN_SUSPEND)\n\t\tret = rdev->desc->ops->resume(rdev);\n\n\tregulator_unlock(rdev);\n\n\treturn ret;\n}\n#else  \n\n#define regulator_suspend\tNULL\n#define regulator_resume\tNULL\n\n#endif  \n\n#ifdef CONFIG_PM\nstatic const struct dev_pm_ops __maybe_unused regulator_pm_ops = {\n\t.suspend\t= regulator_suspend,\n\t.resume\t\t= regulator_resume,\n};\n#endif\n\nstruct class regulator_class = {\n\t.name = \"regulator\",\n\t.dev_release = regulator_dev_release,\n\t.dev_groups = regulator_dev_groups,\n#ifdef CONFIG_PM\n\t.pm = &regulator_pm_ops,\n#endif\n};\n \nvoid regulator_has_full_constraints(void)\n{\n\thas_full_constraints = 1;\n}\nEXPORT_SYMBOL_GPL(regulator_has_full_constraints);\n\n \nvoid *rdev_get_drvdata(struct regulator_dev *rdev)\n{\n\treturn rdev->reg_data;\n}\nEXPORT_SYMBOL_GPL(rdev_get_drvdata);\n\n \nvoid *regulator_get_drvdata(struct regulator *regulator)\n{\n\treturn regulator->rdev->reg_data;\n}\nEXPORT_SYMBOL_GPL(regulator_get_drvdata);\n\n \nvoid regulator_set_drvdata(struct regulator *regulator, void *data)\n{\n\tregulator->rdev->reg_data = data;\n}\nEXPORT_SYMBOL_GPL(regulator_set_drvdata);\n\n \nint rdev_get_id(struct regulator_dev *rdev)\n{\n\treturn rdev->desc->id;\n}\nEXPORT_SYMBOL_GPL(rdev_get_id);\n\nstruct device *rdev_get_dev(struct regulator_dev *rdev)\n{\n\treturn &rdev->dev;\n}\nEXPORT_SYMBOL_GPL(rdev_get_dev);\n\nstruct regmap *rdev_get_regmap(struct regulator_dev *rdev)\n{\n\treturn rdev->regmap;\n}\nEXPORT_SYMBOL_GPL(rdev_get_regmap);\n\nvoid *regulator_get_init_drvdata(struct regulator_init_data *reg_init_data)\n{\n\treturn reg_init_data->driver_data;\n}\nEXPORT_SYMBOL_GPL(regulator_get_init_drvdata);\n\n#ifdef CONFIG_DEBUG_FS\nstatic int supply_map_show(struct seq_file *sf, void *data)\n{\n\tstruct regulator_map *map;\n\n\tlist_for_each_entry(map, &regulator_map_list, list) {\n\t\tseq_printf(sf, \"%s -> %s.%s\\n\",\n\t\t\t\trdev_get_name(map->regulator), map->dev_name,\n\t\t\t\tmap->supply);\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(supply_map);\n\nstruct summary_data {\n\tstruct seq_file *s;\n\tstruct regulator_dev *parent;\n\tint level;\n};\n\nstatic void regulator_summary_show_subtree(struct seq_file *s,\n\t\t\t\t\t   struct regulator_dev *rdev,\n\t\t\t\t\t   int level);\n\nstatic int regulator_summary_show_children(struct device *dev, void *data)\n{\n\tstruct regulator_dev *rdev = dev_to_rdev(dev);\n\tstruct summary_data *summary_data = data;\n\n\tif (rdev->supply && rdev->supply->rdev == summary_data->parent)\n\t\tregulator_summary_show_subtree(summary_data->s, rdev,\n\t\t\t\t\t       summary_data->level + 1);\n\n\treturn 0;\n}\n\nstatic void regulator_summary_show_subtree(struct seq_file *s,\n\t\t\t\t\t   struct regulator_dev *rdev,\n\t\t\t\t\t   int level)\n{\n\tstruct regulation_constraints *c;\n\tstruct regulator *consumer;\n\tstruct summary_data summary_data;\n\tunsigned int opmode;\n\n\tif (!rdev)\n\t\treturn;\n\n\topmode = _regulator_get_mode_unlocked(rdev);\n\tseq_printf(s, \"%*s%-*s %3d %4d %6d %7s \",\n\t\t   level * 3 + 1, \"\",\n\t\t   30 - level * 3, rdev_get_name(rdev),\n\t\t   rdev->use_count, rdev->open_count, rdev->bypass_count,\n\t\t   regulator_opmode_to_str(opmode));\n\n\tseq_printf(s, \"%5dmV \", regulator_get_voltage_rdev(rdev) / 1000);\n\tseq_printf(s, \"%5dmA \",\n\t\t   _regulator_get_current_limit_unlocked(rdev) / 1000);\n\n\tc = rdev->constraints;\n\tif (c) {\n\t\tswitch (rdev->desc->type) {\n\t\tcase REGULATOR_VOLTAGE:\n\t\t\tseq_printf(s, \"%5dmV %5dmV \",\n\t\t\t\t   c->min_uV / 1000, c->max_uV / 1000);\n\t\t\tbreak;\n\t\tcase REGULATOR_CURRENT:\n\t\t\tseq_printf(s, \"%5dmA %5dmA \",\n\t\t\t\t   c->min_uA / 1000, c->max_uA / 1000);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tseq_puts(s, \"\\n\");\n\n\tlist_for_each_entry(consumer, &rdev->consumer_list, list) {\n\t\tif (consumer->dev && consumer->dev->class == &regulator_class)\n\t\t\tcontinue;\n\n\t\tseq_printf(s, \"%*s%-*s \",\n\t\t\t   (level + 1) * 3 + 1, \"\",\n\t\t\t   30 - (level + 1) * 3,\n\t\t\t   consumer->supply_name ? consumer->supply_name :\n\t\t\t   consumer->dev ? dev_name(consumer->dev) : \"deviceless\");\n\n\t\tswitch (rdev->desc->type) {\n\t\tcase REGULATOR_VOLTAGE:\n\t\t\tseq_printf(s, \"%3d %33dmA%c%5dmV %5dmV\",\n\t\t\t\t   consumer->enable_count,\n\t\t\t\t   consumer->uA_load / 1000,\n\t\t\t\t   consumer->uA_load && !consumer->enable_count ?\n\t\t\t\t   '*' : ' ',\n\t\t\t\t   consumer->voltage[PM_SUSPEND_ON].min_uV / 1000,\n\t\t\t\t   consumer->voltage[PM_SUSPEND_ON].max_uV / 1000);\n\t\t\tbreak;\n\t\tcase REGULATOR_CURRENT:\n\t\t\tbreak;\n\t\t}\n\n\t\tseq_puts(s, \"\\n\");\n\t}\n\n\tsummary_data.s = s;\n\tsummary_data.level = level;\n\tsummary_data.parent = rdev;\n\n\tclass_for_each_device(&regulator_class, NULL, &summary_data,\n\t\t\t      regulator_summary_show_children);\n}\n\nstruct summary_lock_data {\n\tstruct ww_acquire_ctx *ww_ctx;\n\tstruct regulator_dev **new_contended_rdev;\n\tstruct regulator_dev **old_contended_rdev;\n};\n\nstatic int regulator_summary_lock_one(struct device *dev, void *data)\n{\n\tstruct regulator_dev *rdev = dev_to_rdev(dev);\n\tstruct summary_lock_data *lock_data = data;\n\tint ret = 0;\n\n\tif (rdev != *lock_data->old_contended_rdev) {\n\t\tret = regulator_lock_nested(rdev, lock_data->ww_ctx);\n\n\t\tif (ret == -EDEADLK)\n\t\t\t*lock_data->new_contended_rdev = rdev;\n\t\telse\n\t\t\tWARN_ON_ONCE(ret);\n\t} else {\n\t\t*lock_data->old_contended_rdev = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int regulator_summary_unlock_one(struct device *dev, void *data)\n{\n\tstruct regulator_dev *rdev = dev_to_rdev(dev);\n\tstruct summary_lock_data *lock_data = data;\n\n\tif (lock_data) {\n\t\tif (rdev == *lock_data->new_contended_rdev)\n\t\t\treturn -EDEADLK;\n\t}\n\n\tregulator_unlock(rdev);\n\n\treturn 0;\n}\n\nstatic int regulator_summary_lock_all(struct ww_acquire_ctx *ww_ctx,\n\t\t\t\t      struct regulator_dev **new_contended_rdev,\n\t\t\t\t      struct regulator_dev **old_contended_rdev)\n{\n\tstruct summary_lock_data lock_data;\n\tint ret;\n\n\tlock_data.ww_ctx = ww_ctx;\n\tlock_data.new_contended_rdev = new_contended_rdev;\n\tlock_data.old_contended_rdev = old_contended_rdev;\n\n\tret = class_for_each_device(&regulator_class, NULL, &lock_data,\n\t\t\t\t    regulator_summary_lock_one);\n\tif (ret)\n\t\tclass_for_each_device(&regulator_class, NULL, &lock_data,\n\t\t\t\t      regulator_summary_unlock_one);\n\n\treturn ret;\n}\n\nstatic void regulator_summary_lock(struct ww_acquire_ctx *ww_ctx)\n{\n\tstruct regulator_dev *new_contended_rdev = NULL;\n\tstruct regulator_dev *old_contended_rdev = NULL;\n\tint err;\n\n\tmutex_lock(&regulator_list_mutex);\n\n\tww_acquire_init(ww_ctx, &regulator_ww_class);\n\n\tdo {\n\t\tif (new_contended_rdev) {\n\t\t\tww_mutex_lock_slow(&new_contended_rdev->mutex, ww_ctx);\n\t\t\told_contended_rdev = new_contended_rdev;\n\t\t\told_contended_rdev->ref_cnt++;\n\t\t\told_contended_rdev->mutex_owner = current;\n\t\t}\n\n\t\terr = regulator_summary_lock_all(ww_ctx,\n\t\t\t\t\t\t &new_contended_rdev,\n\t\t\t\t\t\t &old_contended_rdev);\n\n\t\tif (old_contended_rdev)\n\t\t\tregulator_unlock(old_contended_rdev);\n\n\t} while (err == -EDEADLK);\n\n\tww_acquire_done(ww_ctx);\n}\n\nstatic void regulator_summary_unlock(struct ww_acquire_ctx *ww_ctx)\n{\n\tclass_for_each_device(&regulator_class, NULL, NULL,\n\t\t\t      regulator_summary_unlock_one);\n\tww_acquire_fini(ww_ctx);\n\n\tmutex_unlock(&regulator_list_mutex);\n}\n\nstatic int regulator_summary_show_roots(struct device *dev, void *data)\n{\n\tstruct regulator_dev *rdev = dev_to_rdev(dev);\n\tstruct seq_file *s = data;\n\n\tif (!rdev->supply)\n\t\tregulator_summary_show_subtree(s, rdev, 0);\n\n\treturn 0;\n}\n\nstatic int regulator_summary_show(struct seq_file *s, void *data)\n{\n\tstruct ww_acquire_ctx ww_ctx;\n\n\tseq_puts(s, \" regulator                      use open bypass  opmode voltage current     min     max\\n\");\n\tseq_puts(s, \"---------------------------------------------------------------------------------------\\n\");\n\n\tregulator_summary_lock(&ww_ctx);\n\n\tclass_for_each_device(&regulator_class, NULL, s,\n\t\t\t      regulator_summary_show_roots);\n\n\tregulator_summary_unlock(&ww_ctx);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(regulator_summary);\n#endif  \n\nstatic int __init regulator_init(void)\n{\n\tint ret;\n\n\tret = class_register(&regulator_class);\n\n\tdebugfs_root = debugfs_create_dir(\"regulator\", NULL);\n\tif (IS_ERR(debugfs_root))\n\t\tpr_debug(\"regulator: Failed to create debugfs directory\\n\");\n\n#ifdef CONFIG_DEBUG_FS\n\tdebugfs_create_file(\"supply_map\", 0444, debugfs_root, NULL,\n\t\t\t    &supply_map_fops);\n\n\tdebugfs_create_file(\"regulator_summary\", 0444, debugfs_root,\n\t\t\t    NULL, &regulator_summary_fops);\n#endif\n\tregulator_dummy_init();\n\n\tregulator_coupler_register(&generic_regulator_coupler);\n\n\treturn ret;\n}\n\n \ncore_initcall(regulator_init);\n\nstatic int regulator_late_cleanup(struct device *dev, void *data)\n{\n\tstruct regulator_dev *rdev = dev_to_rdev(dev);\n\tstruct regulation_constraints *c = rdev->constraints;\n\tint ret;\n\n\tif (c && c->always_on)\n\t\treturn 0;\n\n\tif (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_STATUS))\n\t\treturn 0;\n\n\tregulator_lock(rdev);\n\n\tif (rdev->use_count)\n\t\tgoto unlock;\n\n\t \n\tif (_regulator_is_enabled(rdev) <= 0)\n\t\tgoto unlock;\n\n\tif (have_full_constraints()) {\n\t\t \n\t\trdev_info(rdev, \"disabling\\n\");\n\t\tret = _regulator_do_disable(rdev);\n\t\tif (ret != 0)\n\t\t\trdev_err(rdev, \"couldn't disable: %pe\\n\", ERR_PTR(ret));\n\t} else {\n\t\t \n\t\trdev_warn(rdev, \"incomplete constraints, leaving on\\n\");\n\t}\n\nunlock:\n\tregulator_unlock(rdev);\n\n\treturn 0;\n}\n\nstatic void regulator_init_complete_work_function(struct work_struct *work)\n{\n\t \n\tclass_for_each_device(&regulator_class, NULL, NULL,\n\t\t\t      regulator_register_resolve_supply);\n\n\t \n\tclass_for_each_device(&regulator_class, NULL, NULL,\n\t\t\t      regulator_late_cleanup);\n}\n\nstatic DECLARE_DELAYED_WORK(regulator_init_complete_work,\n\t\t\t    regulator_init_complete_work_function);\n\nstatic int __init regulator_init_complete(void)\n{\n\t \n\tif (of_have_populated_dt())\n\t\thas_full_constraints = true;\n\n\t \n\tschedule_delayed_work(&regulator_init_complete_work,\n\t\t\t      msecs_to_jiffies(30000));\n\n\treturn 0;\n}\nlate_initcall_sync(regulator_init_complete);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}