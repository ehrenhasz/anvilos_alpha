{
  "module_name": "ltc3589.c",
  "hash_id": "f4a4a10878d65ef572cbb5e920852ea477d9d95c7ef236455c092b45e9f2b59a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/ltc3589.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n#define DRIVER_NAME\t\t\"ltc3589\"\n\n#define LTC3589_IRQSTAT\t\t0x02\n#define LTC3589_SCR1\t\t0x07\n#define LTC3589_OVEN\t\t0x10\n#define LTC3589_SCR2\t\t0x12\n#define LTC3589_PGSTAT\t\t0x13\n#define LTC3589_VCCR\t\t0x20\n#define LTC3589_CLIRQ\t\t0x21\n#define LTC3589_B1DTV1\t\t0x23\n#define LTC3589_B1DTV2\t\t0x24\n#define LTC3589_VRRCR\t\t0x25\n#define LTC3589_B2DTV1\t\t0x26\n#define LTC3589_B2DTV2\t\t0x27\n#define LTC3589_B3DTV1\t\t0x29\n#define LTC3589_B3DTV2\t\t0x2a\n#define LTC3589_L2DTV1\t\t0x32\n#define LTC3589_L2DTV2\t\t0x33\n\n#define LTC3589_IRQSTAT_PGOOD_TIMEOUT\tBIT(3)\n#define LTC3589_IRQSTAT_UNDERVOLT_WARN\tBIT(4)\n#define LTC3589_IRQSTAT_UNDERVOLT_FAULT\tBIT(5)\n#define LTC3589_IRQSTAT_THERMAL_WARN\tBIT(6)\n#define LTC3589_IRQSTAT_THERMAL_FAULT\tBIT(7)\n\n#define LTC3589_OVEN_SW1\t\tBIT(0)\n#define LTC3589_OVEN_SW2\t\tBIT(1)\n#define LTC3589_OVEN_SW3\t\tBIT(2)\n#define LTC3589_OVEN_BB_OUT\t\tBIT(3)\n#define LTC3589_OVEN_LDO2\t\tBIT(4)\n#define LTC3589_OVEN_LDO3\t\tBIT(5)\n#define LTC3589_OVEN_LDO4\t\tBIT(6)\n#define LTC3589_OVEN_SW_CTRL\t\tBIT(7)\n\n#define LTC3589_VCCR_SW1_GO\t\tBIT(0)\n#define LTC3589_VCCR_SW2_GO\t\tBIT(2)\n#define LTC3589_VCCR_SW3_GO\t\tBIT(4)\n#define LTC3589_VCCR_LDO2_GO\t\tBIT(6)\n\n#define LTC3589_VRRCR_SW1_RAMP_MASK\tGENMASK(1, 0)\n#define LTC3589_VRRCR_SW2_RAMP_MASK\tGENMASK(3, 2)\n#define LTC3589_VRRCR_SW3_RAMP_MASK\tGENMASK(5, 4)\n#define LTC3589_VRRCR_LDO2_RAMP_MASK\tGENMASK(7, 6)\n\nenum ltc3589_variant {\n\tLTC3589,\n\tLTC3589_1,\n\tLTC3589_2,\n};\n\nenum ltc3589_reg {\n\tLTC3589_SW1,\n\tLTC3589_SW2,\n\tLTC3589_SW3,\n\tLTC3589_BB_OUT,\n\tLTC3589_LDO1,\n\tLTC3589_LDO2,\n\tLTC3589_LDO3,\n\tLTC3589_LDO4,\n\tLTC3589_NUM_REGULATORS,\n};\n\nstruct ltc3589 {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tenum ltc3589_variant variant;\n\tstruct regulator_desc regulator_descs[LTC3589_NUM_REGULATORS];\n\tstruct regulator_dev *regulators[LTC3589_NUM_REGULATORS];\n};\n\nstatic const int ltc3589_ldo4[] = {\n\t2800000, 2500000, 1800000, 3300000,\n};\n\nstatic const int ltc3589_12_ldo4[] = {\n\t1200000, 1800000, 2500000, 3200000,\n};\n\nstatic const unsigned int ltc3589_ramp_table[] = {\n\t880, 1750, 3500, 7000\n};\n\nstatic int ltc3589_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tstruct ltc3589 *ltc3589 = rdev_get_drvdata(rdev);\n\tint sel;\n\n\tsel = regulator_map_voltage_linear(rdev, uV, uV);\n\tif (sel < 0)\n\t\treturn sel;\n\n\t \n\treturn regmap_update_bits(ltc3589->regmap, rdev->desc->vsel_reg + 1,\n\t\t\t\t  rdev->desc->vsel_mask, sel);\n}\n\nstatic int ltc3589_set_suspend_mode(struct regulator_dev *rdev,\n\t\t\t\t    unsigned int mode)\n{\n\tstruct ltc3589 *ltc3589 = rdev_get_drvdata(rdev);\n\tint mask, bit = 0;\n\n\t \n\tmask = rdev->desc->apply_bit << 1;\n\n\tif (mode == REGULATOR_MODE_STANDBY)\n\t\tbit = mask;\t \n\n\tmask |= rdev->desc->apply_bit;\n\tbit |= rdev->desc->apply_bit;\n\treturn regmap_update_bits(ltc3589->regmap, LTC3589_VCCR, mask, bit);\n}\n\n \nstatic const struct regulator_ops ltc3589_linear_regulator_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_linear,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_ramp_delay = regulator_set_ramp_delay_regmap,\n\t.set_voltage_time_sel = regulator_set_voltage_time_sel,\n\t.set_suspend_voltage = ltc3589_set_suspend_voltage,\n\t.set_suspend_mode = ltc3589_set_suspend_mode,\n};\n\n \nstatic const struct regulator_ops ltc3589_fixed_regulator_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n};\n\n \nstatic const struct regulator_ops ltc3589_fixed_standby_regulator_ops = {\n};\n\n \nstatic const struct regulator_ops ltc3589_table_regulator_ops = {\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = regulator_list_voltage_table,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n};\n\nstatic inline unsigned int ltc3589_scale(unsigned int uV, u32 r1, u32 r2)\n{\n\tuint64_t tmp;\n\n\tif (uV == 0)\n\t\treturn 0;\n\n\ttmp = (uint64_t)uV * r1;\n\tdo_div(tmp, r2);\n\treturn uV + (unsigned int)tmp;\n}\n\nstatic int ltc3589_of_parse_cb(struct device_node *np,\n\t\t\t       const struct regulator_desc *desc,\n\t\t\t       struct regulator_config *config)\n{\n\tstruct ltc3589 *ltc3589 = config->driver_data;\n\tstruct regulator_desc *rdesc = &ltc3589->regulator_descs[desc->id];\n\tu32 r[2];\n\tint ret;\n\n\t \n\tif (desc->id >= LTC3589_LDO3)\n\t\treturn 0;\n\n\tret = of_property_read_u32_array(np, \"lltc,fb-voltage-divider\", r, 2);\n\tif (ret) {\n\t\tdev_err(ltc3589->dev, \"Failed to parse voltage divider: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (!r[0] || !r[1])\n\t\treturn 0;\n\n\trdesc->min_uV = ltc3589_scale(desc->min_uV, r[0], r[1]);\n\trdesc->uV_step = ltc3589_scale(desc->uV_step, r[0], r[1]);\n\trdesc->fixed_uV = ltc3589_scale(desc->fixed_uV, r[0], r[1]);\n\n\treturn 0;\n}\n\n#define LTC3589_REG(_name, _of_name, _ops, en_bit, dtv1_reg, dtv_mask)\t\\\n\t[LTC3589_ ## _name] = {\t\t\t\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\t\\\n\t\t.of_match = of_match_ptr(#_of_name),\t\t\t\\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\t\t\\\n\t\t.of_parse_cb = ltc3589_of_parse_cb,\t\t\t\\\n\t\t.n_voltages = (dtv_mask) + 1,\t\t\t\t\\\n\t\t.fixed_uV = (dtv_mask) ? 0 : 800000,\t\t\t\\\n\t\t.ops = &ltc3589_ ## _ops ## _regulator_ops,\t\t\\\n\t\t.type = REGULATOR_VOLTAGE,\t\t\t\t\\\n\t\t.id = LTC3589_ ## _name,\t\t\t\t\\\n\t\t.owner = THIS_MODULE,\t\t\t\t\t\\\n\t\t.vsel_reg = (dtv1_reg),\t\t\t\t\t\\\n\t\t.vsel_mask = (dtv_mask),\t\t\t\t\\\n\t\t.enable_reg = (en_bit) ? LTC3589_OVEN : 0,\t\t\\\n\t\t.enable_mask = (en_bit),\t\t\t\t\\\n\t}\n\n#define LTC3589_LINEAR_REG(_name, _of_name, _dtv1)\t\t\t\\\n\t[LTC3589_ ## _name] = {\t\t\t\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\t\\\n\t\t.of_match = of_match_ptr(#_of_name),\t\t\t\\\n\t\t.regulators_node = of_match_ptr(\"regulators\"),\t\t\\\n\t\t.of_parse_cb = ltc3589_of_parse_cb,\t\t\t\\\n\t\t.n_voltages = 32,\t\t\t\t\t\\\n\t\t.min_uV = 362500,\t\t\t\t\t\\\n\t\t.uV_step = 12500,\t\t\t\t\t\\\n\t\t.ramp_delay = 1750,\t\t\t\t\t\\\n\t\t.ops = &ltc3589_linear_regulator_ops,\t\t\t\\\n\t\t.type = REGULATOR_VOLTAGE,\t\t\t\t\\\n\t\t.id = LTC3589_ ## _name,\t\t\t\t\\\n\t\t.owner = THIS_MODULE,\t\t\t\t\t\\\n\t\t.vsel_reg = LTC3589_ ## _dtv1,\t\t\t\t\\\n\t\t.vsel_mask = 0x1f,\t\t\t\t\t\\\n\t\t.apply_reg = LTC3589_VCCR,\t\t\t\t\\\n\t\t.apply_bit = LTC3589_VCCR_ ## _name ## _GO,\t\t\\\n\t\t.enable_reg = LTC3589_OVEN,\t\t\t\t\\\n\t\t.enable_mask = (LTC3589_OVEN_ ## _name),\t\t\\\n\t\t.ramp_reg = LTC3589_VRRCR,\t\t\t\t\\\n\t\t.ramp_mask = LTC3589_VRRCR_ ## _name ## _RAMP_MASK,\t\\\n\t\t.ramp_delay_table = ltc3589_ramp_table,\t\t\t\\\n\t\t.n_ramp_values = ARRAY_SIZE(ltc3589_ramp_table),\t\\\n\t}\n\n\n#define LTC3589_FIXED_REG(_name, _of_name)\t\t\t\t\\\n\tLTC3589_REG(_name, _of_name, fixed, LTC3589_OVEN_ ## _name, 0, 0)\n\nstatic const struct regulator_desc ltc3589_regulators[] = {\n\tLTC3589_LINEAR_REG(SW1, sw1, B1DTV1),\n\tLTC3589_LINEAR_REG(SW2, sw2, B2DTV1),\n\tLTC3589_LINEAR_REG(SW3, sw3, B3DTV1),\n\tLTC3589_FIXED_REG(BB_OUT, bb-out),\n\tLTC3589_REG(LDO1, ldo1, fixed_standby, 0, 0, 0),\n\tLTC3589_LINEAR_REG(LDO2, ldo2, L2DTV1),\n\tLTC3589_FIXED_REG(LDO3, ldo3),\n\tLTC3589_REG(LDO4, ldo4, table, LTC3589_OVEN_LDO4, LTC3589_L2DTV2, 0x60),\n};\n\nstatic bool ltc3589_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LTC3589_IRQSTAT:\n\tcase LTC3589_SCR1:\n\tcase LTC3589_OVEN:\n\tcase LTC3589_SCR2:\n\tcase LTC3589_VCCR:\n\tcase LTC3589_CLIRQ:\n\tcase LTC3589_B1DTV1:\n\tcase LTC3589_B1DTV2:\n\tcase LTC3589_VRRCR:\n\tcase LTC3589_B2DTV1:\n\tcase LTC3589_B2DTV2:\n\tcase LTC3589_B3DTV1:\n\tcase LTC3589_B3DTV2:\n\tcase LTC3589_L2DTV1:\n\tcase LTC3589_L2DTV2:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool ltc3589_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LTC3589_IRQSTAT:\n\tcase LTC3589_SCR1:\n\tcase LTC3589_OVEN:\n\tcase LTC3589_SCR2:\n\tcase LTC3589_PGSTAT:\n\tcase LTC3589_VCCR:\n\tcase LTC3589_B1DTV1:\n\tcase LTC3589_B1DTV2:\n\tcase LTC3589_VRRCR:\n\tcase LTC3589_B2DTV1:\n\tcase LTC3589_B2DTV2:\n\tcase LTC3589_B3DTV1:\n\tcase LTC3589_B3DTV2:\n\tcase LTC3589_L2DTV1:\n\tcase LTC3589_L2DTV2:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool ltc3589_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LTC3589_IRQSTAT:\n\tcase LTC3589_PGSTAT:\n\tcase LTC3589_VCCR:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const struct reg_default ltc3589_reg_defaults[] = {\n\t{ LTC3589_SCR1,   0x00 },\n\t{ LTC3589_OVEN,   0x00 },\n\t{ LTC3589_SCR2,   0x00 },\n\t{ LTC3589_VCCR,   0x00 },\n\t{ LTC3589_B1DTV1, 0x19 },\n\t{ LTC3589_B1DTV2, 0x19 },\n\t{ LTC3589_VRRCR,  0xff },\n\t{ LTC3589_B2DTV1, 0x19 },\n\t{ LTC3589_B2DTV2, 0x19 },\n\t{ LTC3589_B3DTV1, 0x19 },\n\t{ LTC3589_B3DTV2, 0x19 },\n\t{ LTC3589_L2DTV1, 0x19 },\n\t{ LTC3589_L2DTV2, 0x19 },\n};\n\nstatic const struct regmap_config ltc3589_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.writeable_reg = ltc3589_writeable_reg,\n\t.readable_reg = ltc3589_readable_reg,\n\t.volatile_reg = ltc3589_volatile_reg,\n\t.max_register = LTC3589_L2DTV2,\n\t.reg_defaults = ltc3589_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(ltc3589_reg_defaults),\n\t.use_single_read = true,\n\t.use_single_write = true,\n\t.cache_type = REGCACHE_MAPLE,\n};\n\nstatic irqreturn_t ltc3589_isr(int irq, void *dev_id)\n{\n\tstruct ltc3589 *ltc3589 = dev_id;\n\tunsigned int i, irqstat, event;\n\n\tregmap_read(ltc3589->regmap, LTC3589_IRQSTAT, &irqstat);\n\n\tif (irqstat & LTC3589_IRQSTAT_THERMAL_WARN) {\n\t\tevent = REGULATOR_EVENT_OVER_TEMP;\n\t\tfor (i = 0; i < LTC3589_NUM_REGULATORS; i++)\n\t\t\tregulator_notifier_call_chain(ltc3589->regulators[i],\n\t\t\t\t\t\t      event, NULL);\n\t}\n\n\tif (irqstat & LTC3589_IRQSTAT_UNDERVOLT_WARN) {\n\t\tevent = REGULATOR_EVENT_UNDER_VOLTAGE;\n\t\tfor (i = 0; i < LTC3589_NUM_REGULATORS; i++)\n\t\t\tregulator_notifier_call_chain(ltc3589->regulators[i],\n\t\t\t\t\t\t      event, NULL);\n\t}\n\n\t \n\tregmap_write(ltc3589->regmap, LTC3589_CLIRQ, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ltc3589_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct regulator_desc *descs;\n\tstruct ltc3589 *ltc3589;\n\tint i, ret;\n\n\tltc3589 = devm_kzalloc(dev, sizeof(*ltc3589), GFP_KERNEL);\n\tif (!ltc3589)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, ltc3589);\n\tif (client->dev.of_node)\n\t\tltc3589->variant = (uintptr_t)of_device_get_match_data(&client->dev);\n\telse\n\t\tltc3589->variant = id->driver_data;\n\tltc3589->dev = dev;\n\n\tdescs = ltc3589->regulator_descs;\n\tmemcpy(descs, ltc3589_regulators, sizeof(ltc3589_regulators));\n\tif (ltc3589->variant == LTC3589) {\n\t\tdescs[LTC3589_LDO3].fixed_uV = 1800000;\n\t\tdescs[LTC3589_LDO4].volt_table = ltc3589_ldo4;\n\t} else {\n\t\tdescs[LTC3589_LDO3].fixed_uV = 2800000;\n\t\tdescs[LTC3589_LDO4].volt_table = ltc3589_12_ldo4;\n\t}\n\n\tltc3589->regmap = devm_regmap_init_i2c(client, &ltc3589_regmap_config);\n\tif (IS_ERR(ltc3589->regmap)) {\n\t\tret = PTR_ERR(ltc3589->regmap);\n\t\tdev_err(dev, \"failed to initialize regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < LTC3589_NUM_REGULATORS; i++) {\n\t\tstruct regulator_desc *desc = &ltc3589->regulator_descs[i];\n\t\tstruct regulator_config config = { };\n\n\t\tconfig.dev = dev;\n\t\tconfig.driver_data = ltc3589;\n\n\t\tltc3589->regulators[i] = devm_regulator_register(dev, desc,\n\t\t\t\t\t\t\t\t &config);\n\t\tif (IS_ERR(ltc3589->regulators[i])) {\n\t\t\tret = PTR_ERR(ltc3589->regulators[i]);\n\t\t\tdev_err(dev, \"failed to register regulator %s: %d\\n\",\n\t\t\t\tdesc->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\t\tltc3589_isr,\n\t\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\tclient->name, ltc3589);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to request IRQ: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id ltc3589_i2c_id[] = {\n\t{ \"ltc3589\",   LTC3589   },\n\t{ \"ltc3589-1\", LTC3589_1 },\n\t{ \"ltc3589-2\", LTC3589_2 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ltc3589_i2c_id);\n\nstatic const struct of_device_id __maybe_unused ltc3589_of_match[] = {\n\t{\n\t\t.compatible = \"lltc,ltc3589\",\n\t\t.data = (void *)LTC3589,\n\t},\n\t{\n\t\t.compatible = \"lltc,ltc3589-1\",\n\t\t.data = (void *)LTC3589_1,\n\t},\n\t{\n\t\t.compatible = \"lltc,ltc3589-2\",\n\t\t.data = (void *)LTC3589_2,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ltc3589_of_match);\n\nstatic struct i2c_driver ltc3589_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(ltc3589_of_match),\n\t},\n\t.probe = ltc3589_probe,\n\t.id_table = ltc3589_i2c_id,\n};\nmodule_i2c_driver(ltc3589_driver);\n\nMODULE_AUTHOR(\"Philipp Zabel <p.zabel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"Regulator driver for Linear Technology LTC3589(-1,2)\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}