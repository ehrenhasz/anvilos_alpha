{
  "module_name": "twl6030-regulator.c",
  "hash_id": "33ee04fe60eb8faee6045b52ff8078672a45bf91e04bc74dff19f9a607d50963",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/twl6030-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/mfd/twl.h>\n#include <linux/delay.h>\n\nstruct twlreg_info {\n\t \n\tu8\t\t\tbase;\n\n\t \n\tu8\t\t\tid;\n\n\tu8\t\t\tflags;\n\n\t \n\tstruct regulator_desc\tdesc;\n\n\t \n\tunsigned long\t\tfeatures;\n\n\t \n\tvoid\t\t\t*data;\n};\n\n\n \n \n#define VREG_GRP\t\t0\n \n#define VREG_TRANS\t\t1\n#define VREG_STATE\t\t2\n#define VREG_VOLTAGE\t\t3\n#define VREG_VOLTAGE_SMPS\t4\n \n#define VREG_BC_ALL\t\t1\n#define VREG_BC_REF\t\t2\n#define VREG_BC_PROC\t\t3\n#define VREG_BC_CLK_RST\t\t4\n\n \n#define TWL6030_VREG_VOLTAGE_WR_S   BIT(7)\n\n \n#define TWL6030_CFG_STATE_OFF\t0x00\n#define TWL6030_CFG_STATE_ON\t0x01\n#define TWL6030_CFG_STATE_OFF2\t0x02\n#define TWL6030_CFG_STATE_SLEEP\t0x03\n#define TWL6030_CFG_STATE_GRP_SHIFT\t5\n#define TWL6030_CFG_STATE_APP_SHIFT\t2\n#define TWL6030_CFG_STATE_MASK\t\t0x03\n#define TWL6030_CFG_STATE_APP_MASK\t(0x03 << TWL6030_CFG_STATE_APP_SHIFT)\n#define TWL6030_CFG_STATE_APP(v)\t(((v) & TWL6030_CFG_STATE_APP_MASK) >>\\\n\t\t\t\t\t\tTWL6030_CFG_STATE_APP_SHIFT)\n\n \n#define SMPS_OFFSET_EN\t\tBIT(0)\n#define SMPS_EXTENDED_EN\tBIT(1)\n#define TWL_6030_WARM_RESET\tBIT(3)\n\n \n#define TWL6030_SMPS_OFFSET\t\t0xB0\n#define TWL6030_SMPS_MULT\t\t0xB3\n#define SMPS_MULTOFFSET_SMPS4\tBIT(0)\n#define SMPS_MULTOFFSET_VIO\tBIT(1)\n#define SMPS_MULTOFFSET_SMPS3\tBIT(6)\n\nstatic inline int\ntwlreg_read(struct twlreg_info *info, unsigned slave_subgp, unsigned offset)\n{\n\tu8 value;\n\tint status;\n\n\tstatus = twl_i2c_read_u8(slave_subgp,\n\t\t\t&value, info->base + offset);\n\treturn (status < 0) ? status : value;\n}\n\nstatic inline int\ntwlreg_write(struct twlreg_info *info, unsigned slave_subgp, unsigned offset,\n\t\t\t\t\t\t u8 value)\n{\n\treturn twl_i2c_write_u8(slave_subgp,\n\t\t\tvalue, info->base + offset);\n}\n\n \nstatic int twlreg_grp(struct regulator_dev *rdev)\n{\n\treturn twlreg_read(rdev_get_drvdata(rdev), TWL_MODULE_PM_RECEIVER,\n\t\t\t\t\t\t\t\t VREG_GRP);\n}\n\n \n \n#define P3_GRP_6030\tBIT(2)\t\t \n#define P2_GRP_6030\tBIT(1)\t\t \n#define P1_GRP_6030\tBIT(0)\t\t \n\nstatic int twl6030reg_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\tint\t\t\tgrp = 0, val;\n\n\tif (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS))) {\n\t\tgrp = twlreg_grp(rdev);\n\t\tif (grp < 0)\n\t\t\treturn grp;\n\t\tgrp &= P1_GRP_6030;\n\t\tval = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);\n\t\tval = TWL6030_CFG_STATE_APP(val);\n\t} else {\n\t\tval = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);\n\t\tval &= TWL6030_CFG_STATE_MASK;\n\t\tgrp = 1;\n\t}\n\n\treturn grp && (val == TWL6030_CFG_STATE_ON);\n}\n\n#define PB_I2C_BUSY\tBIT(0)\n#define PB_I2C_BWEN\tBIT(1)\n\n\nstatic int twl6030reg_enable(struct regulator_dev *rdev)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\tint\t\t\tgrp = 0;\n\tint\t\t\tret;\n\n\tif (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))\n\t\tgrp = twlreg_grp(rdev);\n\tif (grp < 0)\n\t\treturn grp;\n\n\tret = twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_STATE,\n\t\t\tgrp << TWL6030_CFG_STATE_GRP_SHIFT |\n\t\t\tTWL6030_CFG_STATE_ON);\n\treturn ret;\n}\n\nstatic int twl6030reg_disable(struct regulator_dev *rdev)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\tint\t\t\tgrp = 0;\n\tint\t\t\tret;\n\n\tif (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))\n\t\tgrp = P1_GRP_6030 | P2_GRP_6030 | P3_GRP_6030;\n\n\t \n\tret = twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_STATE,\n\t\t\t(grp) << TWL6030_CFG_STATE_GRP_SHIFT |\n\t\t\tTWL6030_CFG_STATE_OFF);\n\n\treturn ret;\n}\n\nstatic int twl6030reg_get_status(struct regulator_dev *rdev)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\tint\t\t\tval;\n\n\tval = twlreg_grp(rdev);\n\tif (val < 0)\n\t\treturn val;\n\n\tval = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);\n\n\tif (info->features & TWL6032_SUBCLASS)\n\t\tval &= TWL6030_CFG_STATE_MASK;\n\telse\n\t\tval = TWL6030_CFG_STATE_APP(val);\n\n\tswitch (val) {\n\tcase TWL6030_CFG_STATE_ON:\n\t\treturn REGULATOR_STATUS_NORMAL;\n\n\tcase TWL6030_CFG_STATE_SLEEP:\n\t\treturn REGULATOR_STATUS_STANDBY;\n\n\tcase TWL6030_CFG_STATE_OFF:\n\tcase TWL6030_CFG_STATE_OFF2:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn REGULATOR_STATUS_OFF;\n}\n\nstatic int twl6030reg_set_mode(struct regulator_dev *rdev, unsigned mode)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\tint grp = 0;\n\tint val;\n\n\tif (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))\n\t\tgrp = twlreg_grp(rdev);\n\n\tif (grp < 0)\n\t\treturn grp;\n\n\t \n\tval = grp << TWL6030_CFG_STATE_GRP_SHIFT;\n\t \n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval |= TWL6030_CFG_STATE_ON;\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tval |= TWL6030_CFG_STATE_SLEEP;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_STATE, val);\n}\n\nstatic int twl6030coresmps_set_voltage(struct regulator_dev *rdev, int min_uV,\n\tint max_uV, unsigned *selector)\n{\n\treturn -ENODEV;\n}\n\nstatic int twl6030coresmps_get_voltage(struct regulator_dev *rdev)\n{\n\treturn -ENODEV;\n}\n\nstatic const struct regulator_ops twl6030coresmps_ops = {\n\t.set_voltage\t= twl6030coresmps_set_voltage,\n\t.get_voltage\t= twl6030coresmps_get_voltage,\n};\n\nstatic int\ntwl6030ldo_set_voltage_sel(struct regulator_dev *rdev, unsigned selector)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\n\tif (info->flags & TWL_6030_WARM_RESET)\n\t\tselector |= TWL6030_VREG_VOLTAGE_WR_S;\n\n\treturn twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE,\n\t\t\t    selector);\n}\n\nstatic int twl6030ldo_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\tint vsel = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE);\n\n\tif (info->flags & TWL_6030_WARM_RESET)\n\t\tvsel &= ~TWL6030_VREG_VOLTAGE_WR_S;\n\n\treturn vsel;\n}\n\nstatic const struct regulator_ops twl6030ldo_ops = {\n\t.list_voltage\t= regulator_list_voltage_linear_range,\n\n\t.set_voltage_sel = twl6030ldo_set_voltage_sel,\n\t.get_voltage_sel = twl6030ldo_get_voltage_sel,\n\n\t.enable\t\t= twl6030reg_enable,\n\t.disable\t= twl6030reg_disable,\n\t.is_enabled\t= twl6030reg_is_enabled,\n\n\t.set_mode\t= twl6030reg_set_mode,\n\n\t.get_status\t= twl6030reg_get_status,\n};\n\nstatic const struct regulator_ops twl6030fixed_ops = {\n\t.list_voltage\t= regulator_list_voltage_linear,\n\n\t.enable\t\t= twl6030reg_enable,\n\t.disable\t= twl6030reg_disable,\n\t.is_enabled\t= twl6030reg_is_enabled,\n\n\t.set_mode\t= twl6030reg_set_mode,\n\n\t.get_status\t= twl6030reg_get_status,\n};\n\n \n\nstatic int twl6030smps_list_voltage(struct regulator_dev *rdev, unsigned index)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\n\tint voltage = 0;\n\n\tswitch (info->flags) {\n\tcase SMPS_OFFSET_EN:\n\t\tvoltage = 100000;\n\t\tfallthrough;\n\tcase 0:\n\t\tswitch (index) {\n\t\tcase 0:\n\t\t\tvoltage = 0;\n\t\t\tbreak;\n\t\tcase 58:\n\t\t\tvoltage = 1350 * 1000;\n\t\t\tbreak;\n\t\tcase 59:\n\t\t\tvoltage = 1500 * 1000;\n\t\t\tbreak;\n\t\tcase 60:\n\t\t\tvoltage = 1800 * 1000;\n\t\t\tbreak;\n\t\tcase 61:\n\t\t\tvoltage = 1900 * 1000;\n\t\t\tbreak;\n\t\tcase 62:\n\t\t\tvoltage = 2100 * 1000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvoltage += (600000 + (12500 * (index - 1)));\n\t\t}\n\t\tbreak;\n\tcase SMPS_EXTENDED_EN:\n\t\tswitch (index) {\n\t\tcase 0:\n\t\t\tvoltage = 0;\n\t\t\tbreak;\n\t\tcase 58:\n\t\t\tvoltage = 2084 * 1000;\n\t\t\tbreak;\n\t\tcase 59:\n\t\t\tvoltage = 2315 * 1000;\n\t\t\tbreak;\n\t\tcase 60:\n\t\t\tvoltage = 2778 * 1000;\n\t\t\tbreak;\n\t\tcase 61:\n\t\t\tvoltage = 2932 * 1000;\n\t\t\tbreak;\n\t\tcase 62:\n\t\t\tvoltage = 3241 * 1000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvoltage = (1852000 + (38600 * (index - 1)));\n\t\t}\n\t\tbreak;\n\tcase SMPS_OFFSET_EN | SMPS_EXTENDED_EN:\n\t\tswitch (index) {\n\t\tcase 0:\n\t\t\tvoltage = 0;\n\t\t\tbreak;\n\t\tcase 58:\n\t\t\tvoltage = 4167 * 1000;\n\t\t\tbreak;\n\t\tcase 59:\n\t\t\tvoltage = 2315 * 1000;\n\t\t\tbreak;\n\t\tcase 60:\n\t\t\tvoltage = 2778 * 1000;\n\t\t\tbreak;\n\t\tcase 61:\n\t\t\tvoltage = 2932 * 1000;\n\t\t\tbreak;\n\t\tcase 62:\n\t\t\tvoltage = 3241 * 1000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvoltage = (2161000 + (38600 * (index - 1)));\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn voltage;\n}\n\nstatic int twl6030smps_map_voltage(struct regulator_dev *rdev, int min_uV,\n\t\t\t\t   int max_uV)\n{\n\tstruct twlreg_info *info = rdev_get_drvdata(rdev);\n\tint vsel = 0;\n\n\tswitch (info->flags) {\n\tcase 0:\n\t\tif (min_uV == 0)\n\t\t\tvsel = 0;\n\t\telse if ((min_uV >= 600000) && (min_uV <= 1300000)) {\n\t\t\tvsel = DIV_ROUND_UP(min_uV - 600000, 12500);\n\t\t\tvsel++;\n\t\t}\n\t\t \n\t\telse if ((min_uV > 1900000) && (min_uV <= 2100000))\n\t\t\tvsel = 62;\n\t\telse if ((min_uV > 1800000) && (min_uV <= 1900000))\n\t\t\tvsel = 61;\n\t\telse if ((min_uV > 1500000) && (min_uV <= 1800000))\n\t\t\tvsel = 60;\n\t\telse if ((min_uV > 1350000) && (min_uV <= 1500000))\n\t\t\tvsel = 59;\n\t\telse if ((min_uV > 1300000) && (min_uV <= 1350000))\n\t\t\tvsel = 58;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SMPS_OFFSET_EN:\n\t\tif (min_uV == 0)\n\t\t\tvsel = 0;\n\t\telse if ((min_uV >= 700000) && (min_uV <= 1420000)) {\n\t\t\tvsel = DIV_ROUND_UP(min_uV - 700000, 12500);\n\t\t\tvsel++;\n\t\t}\n\t\t \n\t\telse if ((min_uV > 1900000) && (min_uV <= 2100000))\n\t\t\tvsel = 62;\n\t\telse if ((min_uV > 1800000) && (min_uV <= 1900000))\n\t\t\tvsel = 61;\n\t\telse if ((min_uV > 1500000) && (min_uV <= 1800000))\n\t\t\tvsel = 60;\n\t\telse if ((min_uV > 1350000) && (min_uV <= 1500000))\n\t\t\tvsel = 59;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SMPS_EXTENDED_EN:\n\t\tif (min_uV == 0) {\n\t\t\tvsel = 0;\n\t\t} else if ((min_uV >= 1852000) && (max_uV <= 4013600)) {\n\t\t\tvsel = DIV_ROUND_UP(min_uV - 1852000, 38600);\n\t\t\tvsel++;\n\t\t}\n\t\tbreak;\n\tcase SMPS_OFFSET_EN|SMPS_EXTENDED_EN:\n\t\tif (min_uV == 0) {\n\t\t\tvsel = 0;\n\t\t} else if ((min_uV >= 2161000) && (min_uV <= 4321000)) {\n\t\t\tvsel = DIV_ROUND_UP(min_uV - 2161000, 38600);\n\t\t\tvsel++;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn vsel;\n}\n\nstatic int twl6030smps_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t       unsigned int selector)\n{\n\tstruct twlreg_info *info = rdev_get_drvdata(rdev);\n\n\treturn twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE_SMPS,\n\t\t\t    selector);\n}\n\nstatic int twl6030smps_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct twlreg_info\t*info = rdev_get_drvdata(rdev);\n\n\treturn twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE_SMPS);\n}\n\nstatic const struct regulator_ops twlsmps_ops = {\n\t.list_voltage\t\t= twl6030smps_list_voltage,\n\t.map_voltage\t\t= twl6030smps_map_voltage,\n\n\t.set_voltage_sel\t= twl6030smps_set_voltage_sel,\n\t.get_voltage_sel\t= twl6030smps_get_voltage_sel,\n\n\t.enable\t\t\t= twl6030reg_enable,\n\t.disable\t\t= twl6030reg_disable,\n\t.is_enabled\t\t= twl6030reg_is_enabled,\n\n\t.set_mode\t\t= twl6030reg_set_mode,\n\n\t.get_status\t\t= twl6030reg_get_status,\n};\n\n \nstatic const struct linear_range twl6030ldo_linear_range[] = {\n\tREGULATOR_LINEAR_RANGE(0, 0, 0, 0),\n\tREGULATOR_LINEAR_RANGE(1000000, 1, 24, 100000),\n\tREGULATOR_LINEAR_RANGE(2750000, 31, 31, 0),\n};\n\n#define TWL6030_ADJUSTABLE_SMPS(label) \\\nstatic const struct twlreg_info TWL6030_INFO_##label = { \\\n\t.desc = { \\\n\t\t.name = #label, \\\n\t\t.id = TWL6030_REG_##label, \\\n\t\t.ops = &twl6030coresmps_ops, \\\n\t\t.type = REGULATOR_VOLTAGE, \\\n\t\t.owner = THIS_MODULE, \\\n\t\t}, \\\n\t}\n\n#define TWL6030_ADJUSTABLE_LDO(label, offset) \\\nstatic const struct twlreg_info TWL6030_INFO_##label = { \\\n\t.base = offset, \\\n\t.desc = { \\\n\t\t.name = #label, \\\n\t\t.id = TWL6030_REG_##label, \\\n\t\t.n_voltages = 32, \\\n\t\t.linear_ranges = twl6030ldo_linear_range, \\\n\t\t.n_linear_ranges = ARRAY_SIZE(twl6030ldo_linear_range), \\\n\t\t.ops = &twl6030ldo_ops, \\\n\t\t.type = REGULATOR_VOLTAGE, \\\n\t\t.owner = THIS_MODULE, \\\n\t\t}, \\\n\t}\n\n#define TWL6032_ADJUSTABLE_LDO(label, offset) \\\nstatic const struct twlreg_info TWL6032_INFO_##label = { \\\n\t.base = offset, \\\n\t.features = TWL6032_SUBCLASS, \\\n\t.desc = { \\\n\t\t.name = #label, \\\n\t\t.id = TWL6032_REG_##label, \\\n\t\t.n_voltages = 32, \\\n\t\t.linear_ranges = twl6030ldo_linear_range, \\\n\t\t.n_linear_ranges = ARRAY_SIZE(twl6030ldo_linear_range), \\\n\t\t.ops = &twl6030ldo_ops, \\\n\t\t.type = REGULATOR_VOLTAGE, \\\n\t\t.owner = THIS_MODULE, \\\n\t\t}, \\\n\t}\n\n#define TWL6030_FIXED_LDO(label, offset, mVolts, turnon_delay) \\\nstatic const struct twlreg_info TWLFIXED_INFO_##label = { \\\n\t.base = offset, \\\n\t.id = 0, \\\n\t.desc = { \\\n\t\t.name = #label, \\\n\t\t.id = TWL6030##_REG_##label, \\\n\t\t.n_voltages = 1, \\\n\t\t.ops = &twl6030fixed_ops, \\\n\t\t.type = REGULATOR_VOLTAGE, \\\n\t\t.owner = THIS_MODULE, \\\n\t\t.min_uV = mVolts * 1000, \\\n\t\t.enable_time = turnon_delay, \\\n\t\t.of_map_mode = NULL, \\\n\t\t}, \\\n\t}\n\n#define TWL6032_ADJUSTABLE_SMPS(label, offset) \\\nstatic const struct twlreg_info TWLSMPS_INFO_##label = { \\\n\t.base = offset, \\\n\t.features = TWL6032_SUBCLASS, \\\n\t.desc = { \\\n\t\t.name = #label, \\\n\t\t.id = TWL6032_REG_##label, \\\n\t\t.n_voltages = 63, \\\n\t\t.ops = &twlsmps_ops, \\\n\t\t.type = REGULATOR_VOLTAGE, \\\n\t\t.owner = THIS_MODULE, \\\n\t\t}, \\\n\t}\n\n \n \n \nTWL6030_ADJUSTABLE_SMPS(VDD1);\nTWL6030_ADJUSTABLE_SMPS(VDD2);\nTWL6030_ADJUSTABLE_SMPS(VDD3);\nTWL6030_ADJUSTABLE_LDO(VAUX1_6030, 0x54);\nTWL6030_ADJUSTABLE_LDO(VAUX2_6030, 0x58);\nTWL6030_ADJUSTABLE_LDO(VAUX3_6030, 0x5c);\nTWL6030_ADJUSTABLE_LDO(VMMC, 0x68);\nTWL6030_ADJUSTABLE_LDO(VPP, 0x6c);\nTWL6030_ADJUSTABLE_LDO(VUSIM, 0x74);\n \nTWL6032_ADJUSTABLE_LDO(LDO2, 0x54);\nTWL6032_ADJUSTABLE_LDO(LDO4, 0x58);\nTWL6032_ADJUSTABLE_LDO(LDO3, 0x5c);\nTWL6032_ADJUSTABLE_LDO(LDO5, 0x68);\nTWL6032_ADJUSTABLE_LDO(LDO1, 0x6c);\nTWL6032_ADJUSTABLE_LDO(LDO7, 0x74);\nTWL6032_ADJUSTABLE_LDO(LDO6, 0x60);\nTWL6032_ADJUSTABLE_LDO(LDOLN, 0x64);\nTWL6032_ADJUSTABLE_LDO(LDOUSB, 0x70);\nTWL6030_FIXED_LDO(VANA, 0x50, 2100, 0);\nTWL6030_FIXED_LDO(VCXIO, 0x60, 1800, 0);\nTWL6030_FIXED_LDO(VDAC, 0x64, 1800, 0);\nTWL6030_FIXED_LDO(VUSB, 0x70, 3300, 0);\nTWL6030_FIXED_LDO(V1V8, 0x16, 1800, 0);\nTWL6030_FIXED_LDO(V2V1, 0x1c, 2100, 0);\nTWL6032_ADJUSTABLE_SMPS(SMPS3, 0x34);\nTWL6032_ADJUSTABLE_SMPS(SMPS4, 0x10);\nTWL6032_ADJUSTABLE_SMPS(VIO, 0x16);\n\nstatic u8 twl_get_smps_offset(void)\n{\n\tu8 value;\n\n\ttwl_i2c_read_u8(TWL_MODULE_PM_RECEIVER, &value,\n\t\t\tTWL6030_SMPS_OFFSET);\n\treturn value;\n}\n\nstatic u8 twl_get_smps_mult(void)\n{\n\tu8 value;\n\n\ttwl_i2c_read_u8(TWL_MODULE_PM_RECEIVER, &value,\n\t\t\tTWL6030_SMPS_MULT);\n\treturn value;\n}\n\n#define TWL_OF_MATCH(comp, family, label) \\\n\t{ \\\n\t\t.compatible = comp, \\\n\t\t.data = &family##_INFO_##label, \\\n\t}\n\n#define TWL6030_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWL6030, label)\n#define TWL6032_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWL6032, label)\n#define TWLFIXED_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWLFIXED, label)\n#define TWLSMPS_OF_MATCH(comp, label) TWL_OF_MATCH(comp, TWLSMPS, label)\n\nstatic const struct of_device_id twl_of_match[] = {\n\tTWL6030_OF_MATCH(\"ti,twl6030-vdd1\", VDD1),\n\tTWL6030_OF_MATCH(\"ti,twl6030-vdd2\", VDD2),\n\tTWL6030_OF_MATCH(\"ti,twl6030-vdd3\", VDD3),\n\tTWL6030_OF_MATCH(\"ti,twl6030-vaux1\", VAUX1_6030),\n\tTWL6030_OF_MATCH(\"ti,twl6030-vaux2\", VAUX2_6030),\n\tTWL6030_OF_MATCH(\"ti,twl6030-vaux3\", VAUX3_6030),\n\tTWL6030_OF_MATCH(\"ti,twl6030-vmmc\", VMMC),\n\tTWL6030_OF_MATCH(\"ti,twl6030-vpp\", VPP),\n\tTWL6030_OF_MATCH(\"ti,twl6030-vusim\", VUSIM),\n\tTWL6032_OF_MATCH(\"ti,twl6032-ldo2\", LDO2),\n\tTWL6032_OF_MATCH(\"ti,twl6032-ldo4\", LDO4),\n\tTWL6032_OF_MATCH(\"ti,twl6032-ldo3\", LDO3),\n\tTWL6032_OF_MATCH(\"ti,twl6032-ldo5\", LDO5),\n\tTWL6032_OF_MATCH(\"ti,twl6032-ldo1\", LDO1),\n\tTWL6032_OF_MATCH(\"ti,twl6032-ldo7\", LDO7),\n\tTWL6032_OF_MATCH(\"ti,twl6032-ldo6\", LDO6),\n\tTWL6032_OF_MATCH(\"ti,twl6032-ldoln\", LDOLN),\n\tTWL6032_OF_MATCH(\"ti,twl6032-ldousb\", LDOUSB),\n\tTWLFIXED_OF_MATCH(\"ti,twl6030-vana\", VANA),\n\tTWLFIXED_OF_MATCH(\"ti,twl6030-vcxio\", VCXIO),\n\tTWLFIXED_OF_MATCH(\"ti,twl6030-vdac\", VDAC),\n\tTWLFIXED_OF_MATCH(\"ti,twl6030-vusb\", VUSB),\n\tTWLFIXED_OF_MATCH(\"ti,twl6030-v1v8\", V1V8),\n\tTWLFIXED_OF_MATCH(\"ti,twl6030-v2v1\", V2V1),\n\tTWLSMPS_OF_MATCH(\"ti,twl6032-smps3\", SMPS3),\n\tTWLSMPS_OF_MATCH(\"ti,twl6032-smps4\", SMPS4),\n\tTWLSMPS_OF_MATCH(\"ti,twl6032-vio\", VIO),\n\t{},\n};\nMODULE_DEVICE_TABLE(of, twl_of_match);\n\nstatic int twlreg_probe(struct platform_device *pdev)\n{\n\tint id;\n\tstruct twlreg_info\t\t*info;\n\tconst struct twlreg_info\t*template;\n\tstruct regulator_init_data\t*initdata;\n\tstruct regulation_constraints\t*c;\n\tstruct regulator_dev\t\t*rdev;\n\tstruct regulator_config\t\tconfig = { };\n\tstruct device_node\t\t*np = pdev->dev.of_node;\n\n\ttemplate = of_device_get_match_data(&pdev->dev);\n\tif (!template)\n\t\treturn -ENODEV;\n\n\tid = template->desc.id;\n\tinitdata = of_get_regulator_init_data(&pdev->dev, np, &template->desc);\n\tif (!initdata)\n\t\treturn -EINVAL;\n\n\tinfo = devm_kmemdup(&pdev->dev, template, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\t \n\tc = &initdata->constraints;\n\tc->valid_modes_mask &= REGULATOR_MODE_NORMAL | REGULATOR_MODE_STANDBY;\n\tc->valid_ops_mask &= REGULATOR_CHANGE_VOLTAGE\n\t\t\t\t| REGULATOR_CHANGE_MODE\n\t\t\t\t| REGULATOR_CHANGE_STATUS;\n\n\tswitch (id) {\n\tcase TWL6032_REG_SMPS3:\n\t\tif (twl_get_smps_mult() & SMPS_MULTOFFSET_SMPS3)\n\t\t\tinfo->flags |= SMPS_EXTENDED_EN;\n\t\tif (twl_get_smps_offset() & SMPS_MULTOFFSET_SMPS3)\n\t\t\tinfo->flags |= SMPS_OFFSET_EN;\n\t\tbreak;\n\tcase TWL6032_REG_SMPS4:\n\t\tif (twl_get_smps_mult() & SMPS_MULTOFFSET_SMPS4)\n\t\t\tinfo->flags |= SMPS_EXTENDED_EN;\n\t\tif (twl_get_smps_offset() & SMPS_MULTOFFSET_SMPS4)\n\t\t\tinfo->flags |= SMPS_OFFSET_EN;\n\t\tbreak;\n\tcase TWL6032_REG_VIO:\n\t\tif (twl_get_smps_mult() & SMPS_MULTOFFSET_VIO)\n\t\t\tinfo->flags |= SMPS_EXTENDED_EN;\n\t\tif (twl_get_smps_offset() & SMPS_MULTOFFSET_VIO)\n\t\t\tinfo->flags |= SMPS_OFFSET_EN;\n\t\tbreak;\n\t}\n\n\tif (of_property_read_bool(np, \"ti,retain-on-reset\"))\n\t\tinfo->flags |= TWL_6030_WARM_RESET;\n\n\tconfig.dev = &pdev->dev;\n\tconfig.init_data = initdata;\n\tconfig.driver_data = info;\n\tconfig.of_node = np;\n\n\trdev = devm_regulator_register(&pdev->dev, &info->desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(&pdev->dev, \"can't register %s, %ld\\n\",\n\t\t\t\tinfo->desc.name, PTR_ERR(rdev));\n\t\treturn PTR_ERR(rdev);\n\t}\n\tplatform_set_drvdata(pdev, rdev);\n\n\t \n\n\treturn 0;\n}\n\nMODULE_ALIAS(\"platform:twl6030_reg\");\n\nstatic struct platform_driver twlreg_driver = {\n\t.probe\t\t= twlreg_probe,\n\t \n\t.driver  = {\n\t\t.name  = \"twl6030_reg\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(twl_of_match),\n\t},\n};\n\nstatic int __init twlreg_init(void)\n{\n\treturn platform_driver_register(&twlreg_driver);\n}\nsubsys_initcall(twlreg_init);\n\nstatic void __exit twlreg_exit(void)\n{\n\tplatform_driver_unregister(&twlreg_driver);\n}\nmodule_exit(twlreg_exit)\n\nMODULE_DESCRIPTION(\"TWL6030 regulator driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}