{
  "module_name": "stm32-pwr.c",
  "hash_id": "216693c76e2239cd7e7291c73689a3536dec9523ed5f3e61013157963c59b830",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/stm32-pwr.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n \n#define REG_PWR_CR3 0x0C\n\n#define USB_3_3_EN BIT(24)\n#define USB_3_3_RDY BIT(26)\n#define REG_1_8_EN BIT(28)\n#define REG_1_8_RDY BIT(29)\n#define REG_1_1_EN BIT(30)\n#define REG_1_1_RDY BIT(31)\n\n \nenum {\n\tPWR_REG11,\n\tPWR_REG18,\n\tPWR_USB33,\n\tSTM32PWR_REG_NUM_REGS\n};\n\nstatic u32 ready_mask_table[STM32PWR_REG_NUM_REGS] = {\n\t[PWR_REG11] = REG_1_1_RDY,\n\t[PWR_REG18] = REG_1_8_RDY,\n\t[PWR_USB33] = USB_3_3_RDY,\n};\n\nstruct stm32_pwr_reg {\n\tvoid __iomem *base;\n\tu32 ready_mask;\n};\n\nstatic int stm32_pwr_reg_is_ready(struct regulator_dev *rdev)\n{\n\tstruct stm32_pwr_reg *priv = rdev_get_drvdata(rdev);\n\tu32 val;\n\n\tval = readl_relaxed(priv->base + REG_PWR_CR3);\n\n\treturn (val & priv->ready_mask);\n}\n\nstatic int stm32_pwr_reg_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct stm32_pwr_reg *priv = rdev_get_drvdata(rdev);\n\tu32 val;\n\n\tval = readl_relaxed(priv->base + REG_PWR_CR3);\n\n\treturn (val & rdev->desc->enable_mask);\n}\n\nstatic int stm32_pwr_reg_enable(struct regulator_dev *rdev)\n{\n\tstruct stm32_pwr_reg *priv = rdev_get_drvdata(rdev);\n\tint ret;\n\tu32 val;\n\n\tval = readl_relaxed(priv->base + REG_PWR_CR3);\n\tval |= rdev->desc->enable_mask;\n\twritel_relaxed(val, priv->base + REG_PWR_CR3);\n\n\t \n\tret = readx_poll_timeout(stm32_pwr_reg_is_ready, rdev, val, val,\n\t\t\t\t 100, 20 * 1000);\n\tif (ret)\n\t\tdev_err(&rdev->dev, \"regulator enable timed out!\\n\");\n\n\treturn ret;\n}\n\nstatic int stm32_pwr_reg_disable(struct regulator_dev *rdev)\n{\n\tstruct stm32_pwr_reg *priv = rdev_get_drvdata(rdev);\n\tint ret;\n\tu32 val;\n\n\tval = readl_relaxed(priv->base + REG_PWR_CR3);\n\tval &= ~rdev->desc->enable_mask;\n\twritel_relaxed(val, priv->base + REG_PWR_CR3);\n\n\t \n\tret = readx_poll_timeout(stm32_pwr_reg_is_enabled, rdev, val, !val,\n\t\t\t\t 100, 20 * 1000);\n\tif (ret)\n\t\tdev_err(&rdev->dev, \"regulator disable timed out!\\n\");\n\n\treturn ret;\n}\n\nstatic const struct regulator_ops stm32_pwr_reg_ops = {\n\t.enable\t\t= stm32_pwr_reg_enable,\n\t.disable\t= stm32_pwr_reg_disable,\n\t.is_enabled\t= stm32_pwr_reg_is_enabled,\n};\n\n#define PWR_REG(_id, _name, _volt, _en, _supply) \\\n\t[_id] = { \\\n\t\t.id = _id, \\\n\t\t.name = _name, \\\n\t\t.of_match = of_match_ptr(_name), \\\n\t\t.n_voltages = 1, \\\n\t\t.type = REGULATOR_VOLTAGE, \\\n\t\t.fixed_uV = _volt, \\\n\t\t.ops = &stm32_pwr_reg_ops, \\\n\t\t.enable_mask = _en, \\\n\t\t.owner = THIS_MODULE, \\\n\t\t.supply_name = _supply, \\\n\t} \\\n\nstatic const struct regulator_desc stm32_pwr_desc[] = {\n\tPWR_REG(PWR_REG11, \"reg11\", 1100000, REG_1_1_EN, \"vdd\"),\n\tPWR_REG(PWR_REG18, \"reg18\", 1800000, REG_1_8_EN, \"vdd\"),\n\tPWR_REG(PWR_USB33, \"usb33\", 3300000, USB_3_3_EN, \"vdd_3v3_usbfs\"),\n};\n\nstatic int stm32_pwr_regulator_probe(struct platform_device *pdev)\n{\n\tstruct stm32_pwr_reg *priv;\n\tvoid __iomem *base;\n\tstruct regulator_dev *rdev;\n\tstruct regulator_config config = { };\n\tint i, ret = 0;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base)) {\n\t\tdev_err(&pdev->dev, \"Unable to map IO memory\\n\");\n\t\treturn PTR_ERR(base);\n\t}\n\n\tconfig.dev = &pdev->dev;\n\n\tfor (i = 0; i < STM32PWR_REG_NUM_REGS; i++) {\n\t\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct stm32_pwr_reg),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!priv)\n\t\t\treturn -ENOMEM;\n\t\tpriv->base = base;\n\t\tpriv->ready_mask = ready_mask_table[i];\n\t\tconfig.driver_data = priv;\n\n\t\trdev = devm_regulator_register(&pdev->dev,\n\t\t\t\t\t       &stm32_pwr_desc[i],\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tret = PTR_ERR(rdev);\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to register regulator: %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic const struct of_device_id __maybe_unused stm32_pwr_of_match[] = {\n\t{ .compatible = \"st,stm32mp1,pwr-reg\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_pwr_of_match);\n\nstatic struct platform_driver stm32_pwr_driver = {\n\t.probe = stm32_pwr_regulator_probe,\n\t.driver = {\n\t\t.name  = \"stm32-pwr-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(stm32_pwr_of_match),\n\t},\n};\nmodule_platform_driver(stm32_pwr_driver);\n\nMODULE_DESCRIPTION(\"STM32MP1 PWR voltage regulator driver\");\nMODULE_AUTHOR(\"Pascal Paillet <p.paillet@st.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}