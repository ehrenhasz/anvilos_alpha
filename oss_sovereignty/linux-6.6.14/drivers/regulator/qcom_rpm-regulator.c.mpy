{
  "module_name": "qcom_rpm-regulator.c",
  "hash_id": "cc48220cc2147c5f60cca489cdf8c7ac55c523e985465d633a2432b13b717ad8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/qcom_rpm-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/mfd/qcom_rpm.h>\n\n#include <dt-bindings/mfd/qcom-rpm.h>\n\n#define MAX_REQUEST_LEN 2\n\nstruct request_member {\n\tint\t\tword;\n\tunsigned int\tmask;\n\tint\t\tshift;\n};\n\nstruct rpm_reg_parts {\n\tstruct request_member mV;\t\t \n\tstruct request_member uV;\t\t \n\tstruct request_member ip;\t\t \n\tstruct request_member pd;\t\t \n\tstruct request_member ia;\t\t \n\tstruct request_member fm;\t\t \n\tstruct request_member pm;\t\t \n\tstruct request_member pc;\t\t \n\tstruct request_member pf;\t\t \n\tstruct request_member enable_state;\t \n\tstruct request_member comp_mode;\t \n\tstruct request_member freq;\t\t \n\tstruct request_member freq_clk_src;\t \n\tstruct request_member hpm;\t\t \n\tint request_len;\n};\n\n#define FORCE_MODE_IS_2_BITS(reg) \\\n\t(((reg)->parts->fm.mask >> (reg)->parts->fm.shift) == 3)\n\nstruct qcom_rpm_reg {\n\tstruct qcom_rpm *rpm;\n\n\tstruct mutex lock;\n\tstruct device *dev;\n\tstruct regulator_desc desc;\n\tconst struct rpm_reg_parts *parts;\n\n\tint resource;\n\tu32 val[MAX_REQUEST_LEN];\n\n\tint uV;\n\tint is_enabled;\n\n\tbool supports_force_mode_auto;\n\tbool supports_force_mode_bypass;\n};\n\nstatic const struct rpm_reg_parts rpm8660_ldo_parts = {\n\t.request_len    = 2,\n\t.mV             = { 0, 0x00000FFF,  0 },\n\t.ip             = { 0, 0x00FFF000, 12 },\n\t.fm             = { 0, 0x03000000, 24 },\n\t.pc             = { 0, 0x3C000000, 26 },\n\t.pf             = { 0, 0xC0000000, 30 },\n\t.pd             = { 1, 0x00000001,  0 },\n\t.ia             = { 1, 0x00001FFE,  1 },\n};\n\nstatic const struct rpm_reg_parts rpm8660_smps_parts = {\n\t.request_len    = 2,\n\t.mV             = { 0, 0x00000FFF,  0 },\n\t.ip             = { 0, 0x00FFF000, 12 },\n\t.fm             = { 0, 0x03000000, 24 },\n\t.pc             = { 0, 0x3C000000, 26 },\n\t.pf             = { 0, 0xC0000000, 30 },\n\t.pd             = { 1, 0x00000001,  0 },\n\t.ia             = { 1, 0x00001FFE,  1 },\n\t.freq           = { 1, 0x001FE000, 13 },\n\t.freq_clk_src   = { 1, 0x00600000, 21 },\n};\n\nstatic const struct rpm_reg_parts rpm8660_switch_parts = {\n\t.request_len    = 1,\n\t.enable_state   = { 0, 0x00000001,  0 },\n\t.pd             = { 0, 0x00000002,  1 },\n\t.pc             = { 0, 0x0000003C,  2 },\n\t.pf             = { 0, 0x000000C0,  6 },\n\t.hpm            = { 0, 0x00000300,  8 },\n};\n\nstatic const struct rpm_reg_parts rpm8660_ncp_parts = {\n\t.request_len    = 1,\n\t.mV             = { 0, 0x00000FFF,  0 },\n\t.enable_state   = { 0, 0x00001000, 12 },\n\t.comp_mode      = { 0, 0x00002000, 13 },\n\t.freq           = { 0, 0x003FC000, 14 },\n};\n\nstatic const struct rpm_reg_parts rpm8960_ldo_parts = {\n\t.request_len    = 2,\n\t.uV             = { 0, 0x007FFFFF,  0 },\n\t.pd             = { 0, 0x00800000, 23 },\n\t.pc             = { 0, 0x0F000000, 24 },\n\t.pf             = { 0, 0xF0000000, 28 },\n\t.ip             = { 1, 0x000003FF,  0 },\n\t.ia             = { 1, 0x000FFC00, 10 },\n\t.fm             = { 1, 0x00700000, 20 },\n};\n\nstatic const struct rpm_reg_parts rpm8960_smps_parts = {\n\t.request_len    = 2,\n\t.uV             = { 0, 0x007FFFFF,  0 },\n\t.pd             = { 0, 0x00800000, 23 },\n\t.pc             = { 0, 0x0F000000, 24 },\n\t.pf             = { 0, 0xF0000000, 28 },\n\t.ip             = { 1, 0x000003FF,  0 },\n\t.ia             = { 1, 0x000FFC00, 10 },\n\t.fm             = { 1, 0x00700000, 20 },\n\t.pm             = { 1, 0x00800000, 23 },\n\t.freq           = { 1, 0x1F000000, 24 },\n\t.freq_clk_src   = { 1, 0x60000000, 29 },\n};\n\nstatic const struct rpm_reg_parts rpm8960_switch_parts = {\n\t.request_len    = 1,\n\t.enable_state   = { 0, 0x00000001,  0 },\n\t.pd             = { 0, 0x00000002,  1 },\n\t.pc             = { 0, 0x0000003C,  2 },\n\t.pf             = { 0, 0x000003C0,  6 },\n\t.hpm            = { 0, 0x00000C00, 10 },\n};\n\nstatic const struct rpm_reg_parts rpm8960_ncp_parts = {\n\t.request_len    = 1,\n\t.uV             = { 0, 0x007FFFFF,  0 },\n\t.enable_state   = { 0, 0x00800000, 23 },\n\t.comp_mode      = { 0, 0x01000000, 24 },\n\t.freq           = { 0, 0x3E000000, 25 },\n};\n\n \nstatic const struct linear_range pldo_ranges[] = {\n\tREGULATOR_LINEAR_RANGE( 750000,   0,  59, 12500),\n\tREGULATOR_LINEAR_RANGE(1500000,  60, 123, 25000),\n\tREGULATOR_LINEAR_RANGE(3100000, 124, 160, 50000),\n};\n\nstatic const struct linear_range nldo_ranges[] = {\n\tREGULATOR_LINEAR_RANGE( 750000,   0,  63, 12500),\n};\n\nstatic const struct linear_range nldo1200_ranges[] = {\n\tREGULATOR_LINEAR_RANGE( 375000,   0,  59,  6250),\n\tREGULATOR_LINEAR_RANGE( 750000,  60, 123, 12500),\n};\n\nstatic const struct linear_range smps_ranges[] = {\n\tREGULATOR_LINEAR_RANGE( 375000,   0,  29, 12500),\n\tREGULATOR_LINEAR_RANGE( 750000,  30,  89, 12500),\n\tREGULATOR_LINEAR_RANGE(1500000,  90, 153, 25000),\n};\n\nstatic const struct linear_range ftsmps_ranges[] = {\n\tREGULATOR_LINEAR_RANGE( 350000,   0,   6, 50000),\n\tREGULATOR_LINEAR_RANGE( 700000,   7,  63, 12500),\n\tREGULATOR_LINEAR_RANGE(1500000,  64, 100, 50000),\n};\n\nstatic const struct linear_range smb208_ranges[] = {\n\tREGULATOR_LINEAR_RANGE( 375000,   0,  29, 12500),\n\tREGULATOR_LINEAR_RANGE( 750000,  30,  89, 12500),\n\tREGULATOR_LINEAR_RANGE(1500000,  90, 153, 25000),\n\tREGULATOR_LINEAR_RANGE(3100000, 154, 234, 25000),\n};\n\nstatic const struct linear_range ncp_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1500000,   0,  31, 50000),\n};\n\nstatic int rpm_reg_write(struct qcom_rpm_reg *vreg,\n\t\t\t const struct request_member *req,\n\t\t\t const int value)\n{\n\tif (WARN_ON((value << req->shift) & ~req->mask))\n\t\treturn -EINVAL;\n\n\tvreg->val[req->word] &= ~req->mask;\n\tvreg->val[req->word] |= value << req->shift;\n\n\treturn qcom_rpm_write(vreg->rpm,\n\t\t\t      QCOM_RPM_ACTIVE_STATE,\n\t\t\t      vreg->resource,\n\t\t\t      vreg->val,\n\t\t\t      vreg->parts->request_len);\n}\n\nstatic int rpm_reg_set_mV_sel(struct regulator_dev *rdev,\n\t\t\t      unsigned selector)\n{\n\tstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\n\tconst struct rpm_reg_parts *parts = vreg->parts;\n\tconst struct request_member *req = &parts->mV;\n\tint ret = 0;\n\tint uV;\n\n\tif (req->mask == 0)\n\t\treturn -EINVAL;\n\n\tuV = regulator_list_voltage_linear_range(rdev, selector);\n\tif (uV < 0)\n\t\treturn uV;\n\n\tmutex_lock(&vreg->lock);\n\tif (vreg->is_enabled)\n\t\tret = rpm_reg_write(vreg, req, uV / 1000);\n\n\tif (!ret)\n\t\tvreg->uV = uV;\n\tmutex_unlock(&vreg->lock);\n\n\treturn ret;\n}\n\nstatic int rpm_reg_set_uV_sel(struct regulator_dev *rdev,\n\t\t\t      unsigned selector)\n{\n\tstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\n\tconst struct rpm_reg_parts *parts = vreg->parts;\n\tconst struct request_member *req = &parts->uV;\n\tint ret = 0;\n\tint uV;\n\n\tif (req->mask == 0)\n\t\treturn -EINVAL;\n\n\tuV = regulator_list_voltage_linear_range(rdev, selector);\n\tif (uV < 0)\n\t\treturn uV;\n\n\tmutex_lock(&vreg->lock);\n\tif (vreg->is_enabled)\n\t\tret = rpm_reg_write(vreg, req, uV);\n\n\tif (!ret)\n\t\tvreg->uV = uV;\n\tmutex_unlock(&vreg->lock);\n\n\treturn ret;\n}\n\nstatic int rpm_reg_get_voltage(struct regulator_dev *rdev)\n{\n\tstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\n\n\treturn vreg->uV;\n}\n\nstatic int rpm_reg_mV_enable(struct regulator_dev *rdev)\n{\n\tstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\n\tconst struct rpm_reg_parts *parts = vreg->parts;\n\tconst struct request_member *req = &parts->mV;\n\tint ret;\n\n\tif (req->mask == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&vreg->lock);\n\tret = rpm_reg_write(vreg, req, vreg->uV / 1000);\n\tif (!ret)\n\t\tvreg->is_enabled = 1;\n\tmutex_unlock(&vreg->lock);\n\n\treturn ret;\n}\n\nstatic int rpm_reg_uV_enable(struct regulator_dev *rdev)\n{\n\tstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\n\tconst struct rpm_reg_parts *parts = vreg->parts;\n\tconst struct request_member *req = &parts->uV;\n\tint ret;\n\n\tif (req->mask == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&vreg->lock);\n\tret = rpm_reg_write(vreg, req, vreg->uV);\n\tif (!ret)\n\t\tvreg->is_enabled = 1;\n\tmutex_unlock(&vreg->lock);\n\n\treturn ret;\n}\n\nstatic int rpm_reg_switch_enable(struct regulator_dev *rdev)\n{\n\tstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\n\tconst struct rpm_reg_parts *parts = vreg->parts;\n\tconst struct request_member *req = &parts->enable_state;\n\tint ret;\n\n\tif (req->mask == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&vreg->lock);\n\tret = rpm_reg_write(vreg, req, 1);\n\tif (!ret)\n\t\tvreg->is_enabled = 1;\n\tmutex_unlock(&vreg->lock);\n\n\treturn ret;\n}\n\nstatic int rpm_reg_mV_disable(struct regulator_dev *rdev)\n{\n\tstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\n\tconst struct rpm_reg_parts *parts = vreg->parts;\n\tconst struct request_member *req = &parts->mV;\n\tint ret;\n\n\tif (req->mask == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&vreg->lock);\n\tret = rpm_reg_write(vreg, req, 0);\n\tif (!ret)\n\t\tvreg->is_enabled = 0;\n\tmutex_unlock(&vreg->lock);\n\n\treturn ret;\n}\n\nstatic int rpm_reg_uV_disable(struct regulator_dev *rdev)\n{\n\tstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\n\tconst struct rpm_reg_parts *parts = vreg->parts;\n\tconst struct request_member *req = &parts->uV;\n\tint ret;\n\n\tif (req->mask == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&vreg->lock);\n\tret = rpm_reg_write(vreg, req, 0);\n\tif (!ret)\n\t\tvreg->is_enabled = 0;\n\tmutex_unlock(&vreg->lock);\n\n\treturn ret;\n}\n\nstatic int rpm_reg_switch_disable(struct regulator_dev *rdev)\n{\n\tstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\n\tconst struct rpm_reg_parts *parts = vreg->parts;\n\tconst struct request_member *req = &parts->enable_state;\n\tint ret;\n\n\tif (req->mask == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&vreg->lock);\n\tret = rpm_reg_write(vreg, req, 0);\n\tif (!ret)\n\t\tvreg->is_enabled = 0;\n\tmutex_unlock(&vreg->lock);\n\n\treturn ret;\n}\n\nstatic int rpm_reg_is_enabled(struct regulator_dev *rdev)\n{\n\tstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\n\n\treturn vreg->is_enabled;\n}\n\nstatic int rpm_reg_set_load(struct regulator_dev *rdev, int load_uA)\n{\n\tstruct qcom_rpm_reg *vreg = rdev_get_drvdata(rdev);\n\tconst struct rpm_reg_parts *parts = vreg->parts;\n\tconst struct request_member *req = &parts->ia;\n\tint load_mA = load_uA / 1000;\n\tint max_mA = req->mask >> req->shift;\n\tint ret;\n\n\tif (req->mask == 0)\n\t\treturn -EINVAL;\n\n\tif (load_mA > max_mA)\n\t\tload_mA = max_mA;\n\n\tmutex_lock(&vreg->lock);\n\tret = rpm_reg_write(vreg, req, load_mA);\n\tmutex_unlock(&vreg->lock);\n\n\treturn ret;\n}\n\nstatic const struct regulator_ops uV_ops = {\n\t.list_voltage = regulator_list_voltage_linear_range,\n\n\t.set_voltage_sel = rpm_reg_set_uV_sel,\n\t.get_voltage = rpm_reg_get_voltage,\n\n\t.enable = rpm_reg_uV_enable,\n\t.disable = rpm_reg_uV_disable,\n\t.is_enabled = rpm_reg_is_enabled,\n\n\t.set_load = rpm_reg_set_load,\n};\n\nstatic const struct regulator_ops mV_ops = {\n\t.list_voltage = regulator_list_voltage_linear_range,\n\n\t.set_voltage_sel = rpm_reg_set_mV_sel,\n\t.get_voltage = rpm_reg_get_voltage,\n\n\t.enable = rpm_reg_mV_enable,\n\t.disable = rpm_reg_mV_disable,\n\t.is_enabled = rpm_reg_is_enabled,\n\n\t.set_load = rpm_reg_set_load,\n};\n\nstatic const struct regulator_ops switch_ops = {\n\t.enable = rpm_reg_switch_enable,\n\t.disable = rpm_reg_switch_disable,\n\t.is_enabled = rpm_reg_is_enabled,\n};\n\n \nstatic const struct qcom_rpm_reg pm8018_pldo = {\n\t.desc.linear_ranges = pldo_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(pldo_ranges),\n\t.desc.n_voltages = 161,\n\t.desc.ops = &uV_ops,\n\t.parts = &rpm8960_ldo_parts,\n\t.supports_force_mode_auto = false,\n\t.supports_force_mode_bypass = false,\n};\n\nstatic const struct qcom_rpm_reg pm8018_nldo = {\n\t.desc.linear_ranges = nldo_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(nldo_ranges),\n\t.desc.n_voltages = 64,\n\t.desc.ops = &uV_ops,\n\t.parts = &rpm8960_ldo_parts,\n\t.supports_force_mode_auto = false,\n\t.supports_force_mode_bypass = false,\n};\n\nstatic const struct qcom_rpm_reg pm8018_smps = {\n\t.desc.linear_ranges = smps_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(smps_ranges),\n\t.desc.n_voltages = 154,\n\t.desc.ops = &uV_ops,\n\t.parts = &rpm8960_smps_parts,\n\t.supports_force_mode_auto = false,\n\t.supports_force_mode_bypass = false,\n};\n\nstatic const struct qcom_rpm_reg pm8018_switch = {\n\t.desc.ops = &switch_ops,\n\t.parts = &rpm8960_switch_parts,\n};\n\n \nstatic const struct qcom_rpm_reg pm8058_pldo = {\n\t.desc.linear_ranges = pldo_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(pldo_ranges),\n\t.desc.n_voltages = 161,\n\t.desc.ops = &mV_ops,\n\t.parts = &rpm8660_ldo_parts,\n\t.supports_force_mode_auto = false,\n\t.supports_force_mode_bypass = false,\n};\n\nstatic const struct qcom_rpm_reg pm8058_nldo = {\n\t.desc.linear_ranges = nldo_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(nldo_ranges),\n\t.desc.n_voltages = 64,\n\t.desc.ops = &mV_ops,\n\t.parts = &rpm8660_ldo_parts,\n\t.supports_force_mode_auto = false,\n\t.supports_force_mode_bypass = false,\n};\n\nstatic const struct qcom_rpm_reg pm8058_smps = {\n\t.desc.linear_ranges = smps_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(smps_ranges),\n\t.desc.n_voltages = 154,\n\t.desc.ops = &mV_ops,\n\t.parts = &rpm8660_smps_parts,\n\t.supports_force_mode_auto = false,\n\t.supports_force_mode_bypass = false,\n};\n\nstatic const struct qcom_rpm_reg pm8058_ncp = {\n\t.desc.linear_ranges = ncp_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(ncp_ranges),\n\t.desc.n_voltages = 32,\n\t.desc.ops = &mV_ops,\n\t.parts = &rpm8660_ncp_parts,\n};\n\nstatic const struct qcom_rpm_reg pm8058_switch = {\n\t.desc.ops = &switch_ops,\n\t.parts = &rpm8660_switch_parts,\n};\n\n \nstatic const struct qcom_rpm_reg pm8901_pldo = {\n\t.desc.linear_ranges = pldo_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(pldo_ranges),\n\t.desc.n_voltages = 161,\n\t.desc.ops = &mV_ops,\n\t.parts = &rpm8660_ldo_parts,\n\t.supports_force_mode_auto = false,\n\t.supports_force_mode_bypass = true,\n};\n\nstatic const struct qcom_rpm_reg pm8901_nldo = {\n\t.desc.linear_ranges = nldo_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(nldo_ranges),\n\t.desc.n_voltages = 64,\n\t.desc.ops = &mV_ops,\n\t.parts = &rpm8660_ldo_parts,\n\t.supports_force_mode_auto = false,\n\t.supports_force_mode_bypass = true,\n};\n\nstatic const struct qcom_rpm_reg pm8901_ftsmps = {\n\t.desc.linear_ranges = ftsmps_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(ftsmps_ranges),\n\t.desc.n_voltages = 101,\n\t.desc.ops = &mV_ops,\n\t.parts = &rpm8660_smps_parts,\n\t.supports_force_mode_auto = true,\n\t.supports_force_mode_bypass = false,\n};\n\nstatic const struct qcom_rpm_reg pm8901_switch = {\n\t.desc.ops = &switch_ops,\n\t.parts = &rpm8660_switch_parts,\n};\n\n \nstatic const struct qcom_rpm_reg pm8921_pldo = {\n\t.desc.linear_ranges = pldo_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(pldo_ranges),\n\t.desc.n_voltages = 161,\n\t.desc.ops = &uV_ops,\n\t.parts = &rpm8960_ldo_parts,\n\t.supports_force_mode_auto = false,\n\t.supports_force_mode_bypass = true,\n};\n\nstatic const struct qcom_rpm_reg pm8921_nldo = {\n\t.desc.linear_ranges = nldo_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(nldo_ranges),\n\t.desc.n_voltages = 64,\n\t.desc.ops = &uV_ops,\n\t.parts = &rpm8960_ldo_parts,\n\t.supports_force_mode_auto = false,\n\t.supports_force_mode_bypass = true,\n};\n\nstatic const struct qcom_rpm_reg pm8921_nldo1200 = {\n\t.desc.linear_ranges = nldo1200_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(nldo1200_ranges),\n\t.desc.n_voltages = 124,\n\t.desc.ops = &uV_ops,\n\t.parts = &rpm8960_ldo_parts,\n\t.supports_force_mode_auto = false,\n\t.supports_force_mode_bypass = true,\n};\n\nstatic const struct qcom_rpm_reg pm8921_smps = {\n\t.desc.linear_ranges = smps_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(smps_ranges),\n\t.desc.n_voltages = 154,\n\t.desc.ops = &uV_ops,\n\t.parts = &rpm8960_smps_parts,\n\t.supports_force_mode_auto = true,\n\t.supports_force_mode_bypass = false,\n};\n\nstatic const struct qcom_rpm_reg pm8921_ncp = {\n\t.desc.linear_ranges = ncp_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(ncp_ranges),\n\t.desc.n_voltages = 32,\n\t.desc.ops = &uV_ops,\n\t.parts = &rpm8960_ncp_parts,\n};\n\nstatic const struct qcom_rpm_reg pm8921_switch = {\n\t.desc.ops = &switch_ops,\n\t.parts = &rpm8960_switch_parts,\n};\n\nstatic const struct qcom_rpm_reg smb208_smps = {\n\t.desc.linear_ranges = smb208_ranges,\n\t.desc.n_linear_ranges = ARRAY_SIZE(smb208_ranges),\n\t.desc.n_voltages = 235,\n\t.desc.ops = &uV_ops,\n\t.parts = &rpm8960_smps_parts,\n\t.supports_force_mode_auto = false,\n\t.supports_force_mode_bypass = false,\n};\n\nstatic int rpm_reg_set(struct qcom_rpm_reg *vreg,\n\t\t       const struct request_member *req,\n\t\t       const int value)\n{\n\tif (req->mask == 0 || (value << req->shift) & ~req->mask)\n\t\treturn -EINVAL;\n\n\tvreg->val[req->word] &= ~req->mask;\n\tvreg->val[req->word] |= value << req->shift;\n\n\treturn 0;\n}\n\nstatic int rpm_reg_of_parse_freq(struct device *dev,\n\t\t\t\t struct device_node *node,\n\t\t\t\t struct qcom_rpm_reg *vreg)\n{\n\tstatic const int freq_table[] = {\n\t\t19200000, 9600000, 6400000, 4800000, 3840000, 3200000, 2740000,\n\t\t2400000, 2130000, 1920000, 1750000, 1600000, 1480000, 1370000,\n\t\t1280000, 1200000,\n\n\t};\n\tconst char *key;\n\tu32 freq;\n\tint ret;\n\tint i;\n\n\tkey = \"qcom,switch-mode-frequency\";\n\tret = of_property_read_u32(node, key, &freq);\n\tif (ret) {\n\t\tdev_err(dev, \"regulator requires %s property\\n\", key);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(freq_table); i++) {\n\t\tif (freq == freq_table[i]) {\n\t\t\trpm_reg_set(vreg, &vreg->parts->freq, i + 1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(dev, \"invalid frequency %d\\n\", freq);\n\treturn -EINVAL;\n}\n\nstatic int rpm_reg_of_parse(struct device_node *node,\n\t\t\t    const struct regulator_desc *desc,\n\t\t\t    struct regulator_config *config)\n{\n\tstruct qcom_rpm_reg *vreg = config->driver_data;\n\tstruct device *dev = config->dev;\n\tconst char *key;\n\tu32 force_mode;\n\tbool pwm;\n\tu32 val;\n\tint ret;\n\n\tkey = \"bias-pull-down\";\n\tif (of_property_read_bool(node, key)) {\n\t\tret = rpm_reg_set(vreg, &vreg->parts->pd, 1);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s is invalid\", key);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (vreg->parts->freq.mask) {\n\t\tret = rpm_reg_of_parse_freq(dev, node, vreg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (vreg->parts->pm.mask) {\n\t\tkey = \"qcom,power-mode-hysteretic\";\n\t\tpwm = !of_property_read_bool(node, key);\n\n\t\tret = rpm_reg_set(vreg, &vreg->parts->pm, pwm);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to set power mode\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (vreg->parts->fm.mask) {\n\t\tforce_mode = -1;\n\n\t\tkey = \"qcom,force-mode\";\n\t\tret = of_property_read_u32(node, key, &val);\n\t\tif (ret == -EINVAL) {\n\t\t\tval = QCOM_RPM_FORCE_MODE_NONE;\n\t\t} else if (ret < 0) {\n\t\t\tdev_err(dev, \"failed to read %s\\n\", key);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tswitch (val) {\n\t\tcase QCOM_RPM_FORCE_MODE_NONE:\n\t\t\tforce_mode = 0;\n\t\t\tbreak;\n\t\tcase QCOM_RPM_FORCE_MODE_LPM:\n\t\t\tforce_mode = 1;\n\t\t\tbreak;\n\t\tcase QCOM_RPM_FORCE_MODE_HPM:\n\t\t\tif (FORCE_MODE_IS_2_BITS(vreg))\n\t\t\t\tforce_mode = 2;\n\t\t\telse\n\t\t\t\tforce_mode = 3;\n\t\t\tbreak;\n\t\tcase QCOM_RPM_FORCE_MODE_AUTO:\n\t\t\tif (vreg->supports_force_mode_auto)\n\t\t\t\tforce_mode = 2;\n\t\t\tbreak;\n\t\tcase QCOM_RPM_FORCE_MODE_BYPASS:\n\t\t\tif (vreg->supports_force_mode_bypass)\n\t\t\t\tforce_mode = 4;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (force_mode == -1) {\n\t\t\tdev_err(dev, \"invalid force mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = rpm_reg_set(vreg, &vreg->parts->fm, force_mode);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to set force mode\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct rpm_regulator_data {\n\tconst char *name;\n\tint resource;\n\tconst struct qcom_rpm_reg *template;\n\tconst char *supply;\n};\n\nstatic const struct rpm_regulator_data rpm_pm8018_regulators[] = {\n\t{ \"s1\",  QCOM_RPM_PM8018_SMPS1, &pm8018_smps, \"vdd_s1\" },\n\t{ \"s2\",  QCOM_RPM_PM8018_SMPS2, &pm8018_smps, \"vdd_s2\" },\n\t{ \"s3\",  QCOM_RPM_PM8018_SMPS3, &pm8018_smps, \"vdd_s3\" },\n\t{ \"s4\",  QCOM_RPM_PM8018_SMPS4, &pm8018_smps, \"vdd_s4\" },\n\t{ \"s5\",  QCOM_RPM_PM8018_SMPS5, &pm8018_smps, \"vdd_s5\" },\n\n\t{ \"l2\",  QCOM_RPM_PM8018_LDO2,  &pm8018_pldo, \"vdd_l2\" },\n\t{ \"l3\",  QCOM_RPM_PM8018_LDO3,  &pm8018_pldo, \"vdd_l3\" },\n\t{ \"l4\",  QCOM_RPM_PM8018_LDO4,  &pm8018_pldo, \"vdd_l4\" },\n\t{ \"l5\",  QCOM_RPM_PM8018_LDO5,  &pm8018_pldo, \"vdd_l5\" },\n\t{ \"l6\",  QCOM_RPM_PM8018_LDO6,  &pm8018_pldo, \"vdd_l7\" },\n\t{ \"l7\",  QCOM_RPM_PM8018_LDO7,  &pm8018_pldo, \"vdd_l7\" },\n\t{ \"l8\",  QCOM_RPM_PM8018_LDO8,  &pm8018_nldo, \"vdd_l8\" },\n\t{ \"l9\",  QCOM_RPM_PM8018_LDO9,  &pm8921_nldo1200,\n\t\t\t\t\t\t      \"vdd_l9_l10_l11_l12\" },\n\t{ \"l10\", QCOM_RPM_PM8018_LDO10, &pm8018_nldo, \"vdd_l9_l10_l11_l12\" },\n\t{ \"l11\", QCOM_RPM_PM8018_LDO11, &pm8018_nldo, \"vdd_l9_l10_l11_l12\" },\n\t{ \"l12\", QCOM_RPM_PM8018_LDO12, &pm8018_nldo, \"vdd_l9_l10_l11_l12\" },\n\t{ \"l14\", QCOM_RPM_PM8018_LDO14, &pm8018_pldo, \"vdd_l14\" },\n\n\t{ \"lvs1\", QCOM_RPM_PM8018_LVS1, &pm8018_switch, \"lvs1_in\" },\n\n\t{ }\n};\n\nstatic const struct rpm_regulator_data rpm_pm8058_regulators[] = {\n\t{ \"s0\",   QCOM_RPM_PM8058_SMPS0,  &pm8058_smps, \"vdd_s0\" },\n\t{ \"s1\",   QCOM_RPM_PM8058_SMPS1,  &pm8058_smps, \"vdd_s1\" },\n\t{ \"s2\",   QCOM_RPM_PM8058_SMPS2,  &pm8058_smps, \"vdd_s2\" },\n\t{ \"s3\",   QCOM_RPM_PM8058_SMPS3,  &pm8058_smps, \"vdd_s3\" },\n\t{ \"s4\",   QCOM_RPM_PM8058_SMPS4,  &pm8058_smps, \"vdd_s4\" },\n\n\t{ \"l0\",   QCOM_RPM_PM8058_LDO0,   &pm8058_nldo, \"vdd_l0_l1_lvs\"\t},\n\t{ \"l1\",   QCOM_RPM_PM8058_LDO1,   &pm8058_nldo, \"vdd_l0_l1_lvs\" },\n\t{ \"l2\",   QCOM_RPM_PM8058_LDO2,   &pm8058_pldo, \"vdd_l2_l11_l12\" },\n\t{ \"l3\",   QCOM_RPM_PM8058_LDO3,   &pm8058_pldo, \"vdd_l3_l4_l5\" },\n\t{ \"l4\",   QCOM_RPM_PM8058_LDO4,   &pm8058_pldo, \"vdd_l3_l4_l5\" },\n\t{ \"l5\",   QCOM_RPM_PM8058_LDO5,   &pm8058_pldo, \"vdd_l3_l4_l5\" },\n\t{ \"l6\",   QCOM_RPM_PM8058_LDO6,   &pm8058_pldo, \"vdd_l6_l7\" },\n\t{ \"l7\",   QCOM_RPM_PM8058_LDO7,   &pm8058_pldo, \"vdd_l6_l7\" },\n\t{ \"l8\",   QCOM_RPM_PM8058_LDO8,   &pm8058_pldo, \"vdd_l8\" },\n\t{ \"l9\",   QCOM_RPM_PM8058_LDO9,   &pm8058_pldo, \"vdd_l9\" },\n\t{ \"l10\",  QCOM_RPM_PM8058_LDO10,  &pm8058_pldo, \"vdd_l10\" },\n\t{ \"l11\",  QCOM_RPM_PM8058_LDO11,  &pm8058_pldo, \"vdd_l2_l11_l12\" },\n\t{ \"l12\",  QCOM_RPM_PM8058_LDO12,  &pm8058_pldo, \"vdd_l2_l11_l12\" },\n\t{ \"l13\",  QCOM_RPM_PM8058_LDO13,  &pm8058_pldo, \"vdd_l13_l16\" },\n\t{ \"l14\",  QCOM_RPM_PM8058_LDO14,  &pm8058_pldo, \"vdd_l14_l15\" },\n\t{ \"l15\",  QCOM_RPM_PM8058_LDO15,  &pm8058_pldo, \"vdd_l14_l15\" },\n\t{ \"l16\",  QCOM_RPM_PM8058_LDO16,  &pm8058_pldo, \"vdd_l13_l16\" },\n\t{ \"l17\",  QCOM_RPM_PM8058_LDO17,  &pm8058_pldo, \"vdd_l17_l18\" },\n\t{ \"l18\",  QCOM_RPM_PM8058_LDO18,  &pm8058_pldo, \"vdd_l17_l18\" },\n\t{ \"l19\",  QCOM_RPM_PM8058_LDO19,  &pm8058_pldo, \"vdd_l19_l20\" },\n\t{ \"l20\",  QCOM_RPM_PM8058_LDO20,  &pm8058_pldo, \"vdd_l19_l20\" },\n\t{ \"l21\",  QCOM_RPM_PM8058_LDO21,  &pm8058_nldo, \"vdd_l21\" },\n\t{ \"l22\",  QCOM_RPM_PM8058_LDO22,  &pm8058_nldo, \"vdd_l22\" },\n\t{ \"l23\",  QCOM_RPM_PM8058_LDO23,  &pm8058_nldo, \"vdd_l23_l24_l25\" },\n\t{ \"l24\",  QCOM_RPM_PM8058_LDO24,  &pm8058_nldo, \"vdd_l23_l24_l25\" },\n\t{ \"l25\",  QCOM_RPM_PM8058_LDO25,  &pm8058_nldo, \"vdd_l23_l24_l25\" },\n\n\t{ \"lvs0\", QCOM_RPM_PM8058_LVS0, &pm8058_switch, \"vdd_l0_l1_lvs\" },\n\t{ \"lvs1\", QCOM_RPM_PM8058_LVS1, &pm8058_switch, \"vdd_l0_l1_lvs\" },\n\n\t{ \"ncp\",  QCOM_RPM_PM8058_NCP, &pm8058_ncp, \"vdd_ncp\" },\n\t{ }\n};\n\nstatic const struct rpm_regulator_data rpm_pm8901_regulators[] = {\n\t{ \"s0\",   QCOM_RPM_PM8901_SMPS0, &pm8901_ftsmps, \"vdd_s0\" },\n\t{ \"s1\",   QCOM_RPM_PM8901_SMPS1, &pm8901_ftsmps, \"vdd_s1\" },\n\t{ \"s2\",   QCOM_RPM_PM8901_SMPS2, &pm8901_ftsmps, \"vdd_s2\" },\n\t{ \"s3\",   QCOM_RPM_PM8901_SMPS3, &pm8901_ftsmps, \"vdd_s3\" },\n\t{ \"s4\",   QCOM_RPM_PM8901_SMPS4, &pm8901_ftsmps, \"vdd_s4\" },\n\n\t{ \"l0\",   QCOM_RPM_PM8901_LDO0, &pm8901_nldo, \"vdd_l0\" },\n\t{ \"l1\",   QCOM_RPM_PM8901_LDO1, &pm8901_pldo, \"vdd_l1\" },\n\t{ \"l2\",   QCOM_RPM_PM8901_LDO2, &pm8901_pldo, \"vdd_l2\" },\n\t{ \"l3\",   QCOM_RPM_PM8901_LDO3, &pm8901_pldo, \"vdd_l3\" },\n\t{ \"l4\",   QCOM_RPM_PM8901_LDO4, &pm8901_pldo, \"vdd_l4\" },\n\t{ \"l5\",   QCOM_RPM_PM8901_LDO5, &pm8901_pldo, \"vdd_l5\" },\n\t{ \"l6\",   QCOM_RPM_PM8901_LDO6, &pm8901_pldo, \"vdd_l6\" },\n\n\t{ \"lvs0\", QCOM_RPM_PM8901_LVS0, &pm8901_switch, \"lvs0_in\" },\n\t{ \"lvs1\", QCOM_RPM_PM8901_LVS1, &pm8901_switch, \"lvs1_in\" },\n\t{ \"lvs2\", QCOM_RPM_PM8901_LVS2, &pm8901_switch, \"lvs2_in\" },\n\t{ \"lvs3\", QCOM_RPM_PM8901_LVS3, &pm8901_switch, \"lvs3_in\" },\n\n\t{ \"mvs\", QCOM_RPM_PM8901_MVS, &pm8901_switch, \"mvs_in\" },\n\t{ }\n};\n\nstatic const struct rpm_regulator_data rpm_pm8921_regulators[] = {\n\t{ \"s1\",  QCOM_RPM_PM8921_SMPS1, &pm8921_smps, \"vdd_s1\" },\n\t{ \"s2\",  QCOM_RPM_PM8921_SMPS2, &pm8921_smps, \"vdd_s2\" },\n\t{ \"s3\",  QCOM_RPM_PM8921_SMPS3, &pm8921_smps },\n\t{ \"s4\",  QCOM_RPM_PM8921_SMPS4, &pm8921_smps, \"vdd_s4\" },\n\t{ \"s7\",  QCOM_RPM_PM8921_SMPS7, &pm8921_smps, \"vdd_s7\" },\n\t{ \"s8\",  QCOM_RPM_PM8921_SMPS8, &pm8921_smps, \"vdd_s8\"  },\n\n\t{ \"l1\",  QCOM_RPM_PM8921_LDO1, &pm8921_nldo, \"vdd_l1_l2_l12_l18\" },\n\t{ \"l2\",  QCOM_RPM_PM8921_LDO2, &pm8921_nldo, \"vdd_l1_l2_l12_l18\" },\n\t{ \"l3\",  QCOM_RPM_PM8921_LDO3, &pm8921_pldo, \"vdd_l3_l15_l17\" },\n\t{ \"l4\",  QCOM_RPM_PM8921_LDO4, &pm8921_pldo, \"vdd_l4_l14\" },\n\t{ \"l5\",  QCOM_RPM_PM8921_LDO5, &pm8921_pldo, \"vdd_l5_l8_l16\" },\n\t{ \"l6\",  QCOM_RPM_PM8921_LDO6, &pm8921_pldo, \"vdd_l6_l7\" },\n\t{ \"l7\",  QCOM_RPM_PM8921_LDO7, &pm8921_pldo, \"vdd_l6_l7\" },\n\t{ \"l8\",  QCOM_RPM_PM8921_LDO8, &pm8921_pldo, \"vdd_l5_l8_l16\" },\n\t{ \"l9\",  QCOM_RPM_PM8921_LDO9, &pm8921_pldo, \"vdd_l9_l11\" },\n\t{ \"l10\", QCOM_RPM_PM8921_LDO10, &pm8921_pldo, \"vdd_l10_l22\" },\n\t{ \"l11\", QCOM_RPM_PM8921_LDO11, &pm8921_pldo, \"vdd_l9_l11\" },\n\t{ \"l12\", QCOM_RPM_PM8921_LDO12, &pm8921_nldo, \"vdd_l1_l2_l12_l18\" },\n\t{ \"l14\", QCOM_RPM_PM8921_LDO14, &pm8921_pldo, \"vdd_l4_l14\" },\n\t{ \"l15\", QCOM_RPM_PM8921_LDO15, &pm8921_pldo, \"vdd_l3_l15_l17\" },\n\t{ \"l16\", QCOM_RPM_PM8921_LDO16, &pm8921_pldo, \"vdd_l5_l8_l16\" },\n\t{ \"l17\", QCOM_RPM_PM8921_LDO17, &pm8921_pldo, \"vdd_l3_l15_l17\" },\n\t{ \"l18\", QCOM_RPM_PM8921_LDO18, &pm8921_nldo, \"vdd_l1_l2_l12_l18\" },\n\t{ \"l21\", QCOM_RPM_PM8921_LDO21, &pm8921_pldo, \"vdd_l21_l23_l29\" },\n\t{ \"l22\", QCOM_RPM_PM8921_LDO22, &pm8921_pldo, \"vdd_l10_l22\" },\n\t{ \"l23\", QCOM_RPM_PM8921_LDO23, &pm8921_pldo, \"vdd_l21_l23_l29\" },\n\t{ \"l24\", QCOM_RPM_PM8921_LDO24, &pm8921_nldo1200, \"vdd_l24\" },\n\t{ \"l25\", QCOM_RPM_PM8921_LDO25, &pm8921_nldo1200, \"vdd_l25\" },\n\t{ \"l26\", QCOM_RPM_PM8921_LDO26, &pm8921_nldo1200, \"vdd_l26\" },\n\t{ \"l27\", QCOM_RPM_PM8921_LDO27, &pm8921_nldo1200, \"vdd_l27\" },\n\t{ \"l28\", QCOM_RPM_PM8921_LDO28, &pm8921_nldo1200, \"vdd_l28\" },\n\t{ \"l29\", QCOM_RPM_PM8921_LDO29, &pm8921_pldo, \"vdd_l21_l23_l29\" },\n\n\t{ \"lvs1\", QCOM_RPM_PM8921_LVS1, &pm8921_switch, \"vin_lvs1_3_6\" },\n\t{ \"lvs2\", QCOM_RPM_PM8921_LVS2, &pm8921_switch, \"vin_lvs2\" },\n\t{ \"lvs3\", QCOM_RPM_PM8921_LVS3, &pm8921_switch, \"vin_lvs1_3_6\" },\n\t{ \"lvs4\", QCOM_RPM_PM8921_LVS4, &pm8921_switch, \"vin_lvs4_5_7\" },\n\t{ \"lvs5\", QCOM_RPM_PM8921_LVS5, &pm8921_switch, \"vin_lvs4_5_7\" },\n\t{ \"lvs6\", QCOM_RPM_PM8921_LVS6, &pm8921_switch, \"vin_lvs1_3_6\" },\n\t{ \"lvs7\", QCOM_RPM_PM8921_LVS7, &pm8921_switch, \"vin_lvs4_5_7\" },\n\n\t{ \"usb-switch\", QCOM_RPM_USB_OTG_SWITCH, &pm8921_switch, \"vin_5vs\" },\n\t{ \"hdmi-switch\", QCOM_RPM_HDMI_SWITCH, &pm8921_switch, \"vin_5vs\" },\n\t{ \"ncp\", QCOM_RPM_PM8921_NCP, &pm8921_ncp, \"vdd_ncp\" },\n\t{ }\n};\n\nstatic const struct rpm_regulator_data rpm_smb208_regulators[] = {\n\t{ \"s1a\",  QCOM_RPM_SMB208_S1a, &smb208_smps, \"vin_s1a\" },\n\t{ \"s1b\",  QCOM_RPM_SMB208_S1b, &smb208_smps, \"vin_s1b\" },\n\t{ \"s2a\",  QCOM_RPM_SMB208_S2a, &smb208_smps, \"vin_s2a\" },\n\t{ \"s2b\",  QCOM_RPM_SMB208_S2b, &smb208_smps, \"vin_s2b\" },\n\t{ }\n};\n\nstatic const struct of_device_id rpm_of_match[] = {\n\t{ .compatible = \"qcom,rpm-pm8018-regulators\",\n\t\t.data = &rpm_pm8018_regulators },\n\t{ .compatible = \"qcom,rpm-pm8058-regulators\", .data = &rpm_pm8058_regulators },\n\t{ .compatible = \"qcom,rpm-pm8901-regulators\", .data = &rpm_pm8901_regulators },\n\t{ .compatible = \"qcom,rpm-pm8921-regulators\", .data = &rpm_pm8921_regulators },\n\t{ .compatible = \"qcom,rpm-smb208-regulators\", .data = &rpm_smb208_regulators },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rpm_of_match);\n\nstatic int rpm_reg_probe(struct platform_device *pdev)\n{\n\tconst struct rpm_regulator_data *reg;\n\tconst struct of_device_id *match;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tstruct qcom_rpm_reg *vreg;\n\tstruct qcom_rpm *rpm;\n\n\trpm = dev_get_drvdata(pdev->dev.parent);\n\tif (!rpm) {\n\t\tdev_err(&pdev->dev, \"unable to retrieve handle to rpm\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmatch = of_match_device(rpm_of_match, &pdev->dev);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"failed to match device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (reg = match->data; reg->name; reg++) {\n\t\tvreg = devm_kmemdup(&pdev->dev, reg->template, sizeof(*vreg), GFP_KERNEL);\n\t\tif (!vreg)\n\t\t\treturn -ENOMEM;\n\n\t\tmutex_init(&vreg->lock);\n\n\t\tvreg->dev = &pdev->dev;\n\t\tvreg->resource = reg->resource;\n\t\tvreg->rpm = rpm;\n\n\t\tvreg->desc.id = -1;\n\t\tvreg->desc.owner = THIS_MODULE;\n\t\tvreg->desc.type = REGULATOR_VOLTAGE;\n\t\tvreg->desc.name = reg->name;\n\t\tvreg->desc.supply_name = reg->supply;\n\t\tvreg->desc.of_match = reg->name;\n\t\tvreg->desc.of_parse_cb = rpm_reg_of_parse;\n\n\t\tconfig.dev = &pdev->dev;\n\t\tconfig.driver_data = vreg;\n\t\trdev = devm_regulator_register(&pdev->dev, &vreg->desc, &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&pdev->dev, \"failed to register %s\\n\", reg->name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver rpm_reg_driver = {\n\t.probe          = rpm_reg_probe,\n\t.driver  = {\n\t\t.name  = \"qcom_rpm_reg\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(rpm_of_match),\n\t},\n};\n\nstatic int __init rpm_reg_init(void)\n{\n\treturn platform_driver_register(&rpm_reg_driver);\n}\nsubsys_initcall(rpm_reg_init);\n\nstatic void __exit rpm_reg_exit(void)\n{\n\tplatform_driver_unregister(&rpm_reg_driver);\n}\nmodule_exit(rpm_reg_exit)\n\nMODULE_DESCRIPTION(\"Qualcomm RPM regulator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}