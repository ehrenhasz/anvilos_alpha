{
  "module_name": "wm831x-ldo.c",
  "hash_id": "ebedffd7db4ed3d50f7f74642220524cb16da3ada17b27dfc88e14205eb1c5a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/wm831x-ldo.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/slab.h>\n\n#include <linux/mfd/wm831x/core.h>\n#include <linux/mfd/wm831x/regulator.h>\n#include <linux/mfd/wm831x/pdata.h>\n\n#define WM831X_LDO_MAX_NAME 9\n\n#define WM831X_LDO_CONTROL       0\n#define WM831X_LDO_ON_CONTROL    1\n#define WM831X_LDO_SLEEP_CONTROL 2\n\n#define WM831X_ALIVE_LDO_ON_CONTROL    0\n#define WM831X_ALIVE_LDO_SLEEP_CONTROL 1\n\nstruct wm831x_ldo {\n\tchar name[WM831X_LDO_MAX_NAME];\n\tchar supply_name[WM831X_LDO_MAX_NAME];\n\tstruct regulator_desc desc;\n\tint base;\n\tstruct wm831x *wm831x;\n\tstruct regulator_dev *regulator;\n};\n\n \n\nstatic irqreturn_t wm831x_ldo_uv_irq(int irq, void *data)\n{\n\tstruct wm831x_ldo *ldo = data;\n\n\tregulator_notifier_call_chain(ldo->regulator,\n\t\t\t\t      REGULATOR_EVENT_UNDER_VOLTAGE,\n\t\t\t\t      NULL);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic const struct linear_range wm831x_gp_ldo_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(900000, 0, 14, 50000),\n\tREGULATOR_LINEAR_RANGE(1700000, 15, 31, 100000),\n};\n\nstatic int wm831x_gp_ldo_set_suspend_voltage(struct regulator_dev *rdev,\n\t\t\t\t\t     int uV)\n{\n\tstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = ldo->wm831x;\n\tint sel, reg = ldo->base + WM831X_LDO_SLEEP_CONTROL;\n\n\tsel = regulator_map_voltage_linear_range(rdev, uV, uV);\n\tif (sel < 0)\n\t\treturn sel;\n\n\treturn wm831x_set_bits(wm831x, reg, WM831X_LDO1_ON_VSEL_MASK, sel);\n}\n\nstatic unsigned int wm831x_gp_ldo_get_mode(struct regulator_dev *rdev)\n{\n\tstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = ldo->wm831x;\n\tint ctrl_reg = ldo->base + WM831X_LDO_CONTROL;\n\tint on_reg = ldo->base + WM831X_LDO_ON_CONTROL;\n\tint ret;\n\n\tret = wm831x_reg_read(wm831x, on_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(ret & WM831X_LDO1_ON_MODE))\n\t\treturn REGULATOR_MODE_NORMAL;\n\n\tret = wm831x_reg_read(wm831x, ctrl_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & WM831X_LDO1_LP_MODE)\n\t\treturn REGULATOR_MODE_STANDBY;\n\telse\n\t\treturn REGULATOR_MODE_IDLE;\n}\n\nstatic int wm831x_gp_ldo_set_mode(struct regulator_dev *rdev,\n\t\t\t\t  unsigned int mode)\n{\n\tstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = ldo->wm831x;\n\tint ctrl_reg = ldo->base + WM831X_LDO_CONTROL;\n\tint on_reg = ldo->base + WM831X_LDO_ON_CONTROL;\n\tint ret;\n\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tret = wm831x_set_bits(wm831x, on_reg,\n\t\t\t\t      WM831X_LDO1_ON_MODE, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase REGULATOR_MODE_IDLE:\n\t\tret = wm831x_set_bits(wm831x, ctrl_reg,\n\t\t\t\t      WM831X_LDO1_LP_MODE, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = wm831x_set_bits(wm831x, on_reg,\n\t\t\t\t      WM831X_LDO1_ON_MODE,\n\t\t\t\t      WM831X_LDO1_ON_MODE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase REGULATOR_MODE_STANDBY:\n\t\tret = wm831x_set_bits(wm831x, ctrl_reg,\n\t\t\t\t      WM831X_LDO1_LP_MODE,\n\t\t\t\t      WM831X_LDO1_LP_MODE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = wm831x_set_bits(wm831x, on_reg,\n\t\t\t\t      WM831X_LDO1_ON_MODE,\n\t\t\t\t      WM831X_LDO1_ON_MODE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm831x_gp_ldo_get_status(struct regulator_dev *rdev)\n{\n\tstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = ldo->wm831x;\n\tint mask = 1 << rdev_get_id(rdev);\n\tint ret;\n\n\t \n\tret = wm831x_reg_read(wm831x, WM831X_LDO_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!(ret & mask))\n\t\treturn REGULATOR_STATUS_OFF;\n\n\t \n\tret = wm831x_reg_read(wm831x, WM831X_LDO_UV_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret & mask)\n\t\treturn REGULATOR_STATUS_ERROR;\n\n\tret = wm831x_gp_ldo_get_mode(rdev);\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn regulator_mode_to_status(ret);\n}\n\nstatic unsigned int wm831x_gp_ldo_get_optimum_mode(struct regulator_dev *rdev,\n\t\t\t\t\t\t   int input_uV,\n\t\t\t\t\t\t   int output_uV, int load_uA)\n{\n\tif (load_uA < 20000)\n\t\treturn REGULATOR_MODE_STANDBY;\n\tif (load_uA < 50000)\n\t\treturn REGULATOR_MODE_IDLE;\n\treturn REGULATOR_MODE_NORMAL;\n}\n\n\nstatic const struct regulator_ops wm831x_gp_ldo_ops = {\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.map_voltage = regulator_map_voltage_linear_range,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.set_suspend_voltage = wm831x_gp_ldo_set_suspend_voltage,\n\t.get_mode = wm831x_gp_ldo_get_mode,\n\t.set_mode = wm831x_gp_ldo_set_mode,\n\t.get_status = wm831x_gp_ldo_get_status,\n\t.get_optimum_mode = wm831x_gp_ldo_get_optimum_mode,\n\t.get_bypass = regulator_get_bypass_regmap,\n\t.set_bypass = regulator_set_bypass_regmap,\n\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n};\n\nstatic int wm831x_gp_ldo_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\n\tstruct regulator_config config = { };\n\tint id;\n\tstruct wm831x_ldo *ldo;\n\tstruct resource *res;\n\tint ret, irq;\n\n\tif (pdata && pdata->wm831x_num)\n\t\tid = (pdata->wm831x_num * 10) + 1;\n\telse\n\t\tid = 0;\n\tid = pdev->id - id;\n\n\tdev_dbg(&pdev->dev, \"Probing LDO%d\\n\", id + 1);\n\n\tldo = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_ldo), GFP_KERNEL);\n\tif (!ldo)\n\t\treturn -ENOMEM;\n\n\tldo->wm831x = wm831x;\n\n\tres = platform_get_resource(pdev, IORESOURCE_REG, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"No REG resource\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tldo->base = res->start;\n\n\tsnprintf(ldo->name, sizeof(ldo->name), \"LDO%d\", id + 1);\n\tldo->desc.name = ldo->name;\n\n\tsnprintf(ldo->supply_name, sizeof(ldo->supply_name),\n\t\t \"LDO%dVDD\", id + 1);\n\tldo->desc.supply_name = ldo->supply_name;\n\n\tldo->desc.id = id;\n\tldo->desc.type = REGULATOR_VOLTAGE;\n\tldo->desc.n_voltages = 32;\n\tldo->desc.ops = &wm831x_gp_ldo_ops;\n\tldo->desc.owner = THIS_MODULE;\n\tldo->desc.vsel_reg = ldo->base + WM831X_LDO_ON_CONTROL;\n\tldo->desc.vsel_mask = WM831X_LDO1_ON_VSEL_MASK;\n\tldo->desc.enable_reg = WM831X_LDO_ENABLE;\n\tldo->desc.enable_mask = 1 << id;\n\tldo->desc.bypass_reg = ldo->base;\n\tldo->desc.bypass_mask = WM831X_LDO1_SWI;\n\tldo->desc.linear_ranges = wm831x_gp_ldo_ranges;\n\tldo->desc.n_linear_ranges = ARRAY_SIZE(wm831x_gp_ldo_ranges);\n\n\tconfig.dev = pdev->dev.parent;\n\tif (pdata)\n\t\tconfig.init_data = pdata->ldo[id];\n\tconfig.driver_data = ldo;\n\tconfig.regmap = wm831x->regmap;\n\n\tldo->regulator = devm_regulator_register(&pdev->dev, &ldo->desc,\n\t\t\t\t\t\t &config);\n\tif (IS_ERR(ldo->regulator)) {\n\t\tret = PTR_ERR(ldo->regulator);\n\t\tdev_err(wm831x->dev, \"Failed to register LDO%d: %d\\n\",\n\t\t\tid + 1, ret);\n\t\tgoto err;\n\t}\n\n\tirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, \"UV\"));\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\twm831x_ldo_uv_irq,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tldo->name,\n\t\t\t\t\tldo);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request UV IRQ %d: %d\\n\",\n\t\t\tirq, ret);\n\t\tgoto err;\n\t}\n\n\tplatform_set_drvdata(pdev, ldo);\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic struct platform_driver wm831x_gp_ldo_driver = {\n\t.probe = wm831x_gp_ldo_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"wm831x-ldo\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\n \n\nstatic const struct linear_range wm831x_aldo_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1000000, 0, 12, 50000),\n\tREGULATOR_LINEAR_RANGE(1700000, 13, 31, 100000),\n};\n\nstatic int wm831x_aldo_set_suspend_voltage(struct regulator_dev *rdev,\n\t\t\t\t\t     int uV)\n{\n\tstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = ldo->wm831x;\n\tint sel, reg = ldo->base + WM831X_LDO_SLEEP_CONTROL;\n\n\tsel = regulator_map_voltage_linear_range(rdev, uV, uV);\n\tif (sel < 0)\n\t\treturn sel;\n\n\treturn wm831x_set_bits(wm831x, reg, WM831X_LDO7_ON_VSEL_MASK, sel);\n}\n\nstatic unsigned int wm831x_aldo_get_mode(struct regulator_dev *rdev)\n{\n\tstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = ldo->wm831x;\n\tint on_reg = ldo->base + WM831X_LDO_ON_CONTROL;\n\tint ret;\n\n\tret = wm831x_reg_read(wm831x, on_reg);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (ret & WM831X_LDO7_ON_MODE)\n\t\treturn REGULATOR_MODE_IDLE;\n\telse\n\t\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int wm831x_aldo_set_mode(struct regulator_dev *rdev,\n\t\t\t\t  unsigned int mode)\n{\n\tstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = ldo->wm831x;\n\tint on_reg = ldo->base + WM831X_LDO_ON_CONTROL;\n\tint ret;\n\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tret = wm831x_set_bits(wm831x, on_reg, WM831X_LDO7_ON_MODE, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase REGULATOR_MODE_IDLE:\n\t\tret = wm831x_set_bits(wm831x, on_reg, WM831X_LDO7_ON_MODE,\n\t\t\t\t      WM831X_LDO7_ON_MODE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm831x_aldo_get_status(struct regulator_dev *rdev)\n{\n\tstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = ldo->wm831x;\n\tint mask = 1 << rdev_get_id(rdev);\n\tint ret;\n\n\t \n\tret = wm831x_reg_read(wm831x, WM831X_LDO_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!(ret & mask))\n\t\treturn REGULATOR_STATUS_OFF;\n\n\t \n\tret = wm831x_reg_read(wm831x, WM831X_LDO_UV_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret & mask)\n\t\treturn REGULATOR_STATUS_ERROR;\n\n\tret = wm831x_aldo_get_mode(rdev);\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn regulator_mode_to_status(ret);\n}\n\nstatic const struct regulator_ops wm831x_aldo_ops = {\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.map_voltage = regulator_map_voltage_linear_range,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.set_suspend_voltage = wm831x_aldo_set_suspend_voltage,\n\t.get_mode = wm831x_aldo_get_mode,\n\t.set_mode = wm831x_aldo_set_mode,\n\t.get_status = wm831x_aldo_get_status,\n\t.set_bypass = regulator_set_bypass_regmap,\n\t.get_bypass = regulator_get_bypass_regmap,\n\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n};\n\nstatic int wm831x_aldo_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\n\tstruct regulator_config config = { };\n\tint id;\n\tstruct wm831x_ldo *ldo;\n\tstruct resource *res;\n\tint ret, irq;\n\n\tif (pdata && pdata->wm831x_num)\n\t\tid = (pdata->wm831x_num * 10) + 1;\n\telse\n\t\tid = 0;\n\tid = pdev->id - id;\n\n\tdev_dbg(&pdev->dev, \"Probing LDO%d\\n\", id + 1);\n\n\tldo = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_ldo), GFP_KERNEL);\n\tif (!ldo)\n\t\treturn -ENOMEM;\n\n\tldo->wm831x = wm831x;\n\n\tres = platform_get_resource(pdev, IORESOURCE_REG, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"No REG resource\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tldo->base = res->start;\n\n\tsnprintf(ldo->name, sizeof(ldo->name), \"LDO%d\", id + 1);\n\tldo->desc.name = ldo->name;\n\n\tsnprintf(ldo->supply_name, sizeof(ldo->supply_name),\n\t\t \"LDO%dVDD\", id + 1);\n\tldo->desc.supply_name = ldo->supply_name;\n\n\tldo->desc.id = id;\n\tldo->desc.type = REGULATOR_VOLTAGE;\n\tldo->desc.n_voltages = 32;\n\tldo->desc.linear_ranges = wm831x_aldo_ranges;\n\tldo->desc.n_linear_ranges = ARRAY_SIZE(wm831x_aldo_ranges);\n\tldo->desc.ops = &wm831x_aldo_ops;\n\tldo->desc.owner = THIS_MODULE;\n\tldo->desc.vsel_reg = ldo->base + WM831X_LDO_ON_CONTROL;\n\tldo->desc.vsel_mask = WM831X_LDO7_ON_VSEL_MASK;\n\tldo->desc.enable_reg = WM831X_LDO_ENABLE;\n\tldo->desc.enable_mask = 1 << id;\n\tldo->desc.bypass_reg = ldo->base;\n\tldo->desc.bypass_mask = WM831X_LDO7_SWI;\n\n\tconfig.dev = pdev->dev.parent;\n\tif (pdata)\n\t\tconfig.init_data = pdata->ldo[id];\n\tconfig.driver_data = ldo;\n\tconfig.regmap = wm831x->regmap;\n\n\tldo->regulator = devm_regulator_register(&pdev->dev, &ldo->desc,\n\t\t\t\t\t\t &config);\n\tif (IS_ERR(ldo->regulator)) {\n\t\tret = PTR_ERR(ldo->regulator);\n\t\tdev_err(wm831x->dev, \"Failed to register LDO%d: %d\\n\",\n\t\t\tid + 1, ret);\n\t\tgoto err;\n\t}\n\n\tirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, \"UV\"));\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\twm831x_ldo_uv_irq,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\tldo->name, ldo);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request UV IRQ %d: %d\\n\",\n\t\t\tirq, ret);\n\t\tgoto err;\n\t}\n\n\tplatform_set_drvdata(pdev, ldo);\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic struct platform_driver wm831x_aldo_driver = {\n\t.probe = wm831x_aldo_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"wm831x-aldo\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\n \n\n#define WM831X_ALIVE_LDO_MAX_SELECTOR 0xf\n\nstatic int wm831x_alive_ldo_set_suspend_voltage(struct regulator_dev *rdev,\n\t\t\t\t\t     int uV)\n{\n\tstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = ldo->wm831x;\n\tint sel, reg = ldo->base + WM831X_ALIVE_LDO_SLEEP_CONTROL;\n\n\tsel = regulator_map_voltage_linear(rdev, uV, uV);\n\tif (sel < 0)\n\t\treturn sel;\n\n\treturn wm831x_set_bits(wm831x, reg, WM831X_LDO11_ON_VSEL_MASK, sel);\n}\n\nstatic int wm831x_alive_ldo_get_status(struct regulator_dev *rdev)\n{\n\tstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\n\tstruct wm831x *wm831x = ldo->wm831x;\n\tint mask = 1 << rdev_get_id(rdev);\n\tint ret;\n\n\t \n\tret = wm831x_reg_read(wm831x, WM831X_LDO_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret & mask)\n\t\treturn REGULATOR_STATUS_ON;\n\telse\n\t\treturn REGULATOR_STATUS_OFF;\n}\n\nstatic const struct regulator_ops wm831x_alive_ldo_ops = {\n\t.list_voltage = regulator_list_voltage_linear,\n\t.map_voltage = regulator_map_voltage_linear,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.set_suspend_voltage = wm831x_alive_ldo_set_suspend_voltage,\n\t.get_status = wm831x_alive_ldo_get_status,\n\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n};\n\nstatic int wm831x_alive_ldo_probe(struct platform_device *pdev)\n{\n\tstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\n\tstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\n\tstruct regulator_config config = { };\n\tint id;\n\tstruct wm831x_ldo *ldo;\n\tstruct resource *res;\n\tint ret;\n\n\tif (pdata && pdata->wm831x_num)\n\t\tid = (pdata->wm831x_num * 10) + 1;\n\telse\n\t\tid = 0;\n\tid = pdev->id - id;\n\n\n\tdev_dbg(&pdev->dev, \"Probing LDO%d\\n\", id + 1);\n\n\tldo = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_ldo), GFP_KERNEL);\n\tif (!ldo)\n\t\treturn -ENOMEM;\n\n\tldo->wm831x = wm831x;\n\n\tres = platform_get_resource(pdev, IORESOURCE_REG, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"No REG resource\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tldo->base = res->start;\n\n\tsnprintf(ldo->name, sizeof(ldo->name), \"LDO%d\", id + 1);\n\tldo->desc.name = ldo->name;\n\n\tsnprintf(ldo->supply_name, sizeof(ldo->supply_name),\n\t\t \"LDO%dVDD\", id + 1);\n\tldo->desc.supply_name = ldo->supply_name;\n\n\tldo->desc.id = id;\n\tldo->desc.type = REGULATOR_VOLTAGE;\n\tldo->desc.n_voltages = WM831X_ALIVE_LDO_MAX_SELECTOR + 1;\n\tldo->desc.ops = &wm831x_alive_ldo_ops;\n\tldo->desc.owner = THIS_MODULE;\n\tldo->desc.vsel_reg = ldo->base + WM831X_ALIVE_LDO_ON_CONTROL;\n\tldo->desc.vsel_mask = WM831X_LDO11_ON_VSEL_MASK;\n\tldo->desc.enable_reg = WM831X_LDO_ENABLE;\n\tldo->desc.enable_mask = 1 << id;\n\tldo->desc.min_uV = 800000;\n\tldo->desc.uV_step = 50000;\n\tldo->desc.enable_time = 1000;\n\n\tconfig.dev = pdev->dev.parent;\n\tif (pdata)\n\t\tconfig.init_data = pdata->ldo[id];\n\tconfig.driver_data = ldo;\n\tconfig.regmap = wm831x->regmap;\n\n\tldo->regulator = devm_regulator_register(&pdev->dev, &ldo->desc,\n\t\t\t\t\t\t &config);\n\tif (IS_ERR(ldo->regulator)) {\n\t\tret = PTR_ERR(ldo->regulator);\n\t\tdev_err(wm831x->dev, \"Failed to register LDO%d: %d\\n\",\n\t\t\tid + 1, ret);\n\t\tgoto err;\n\t}\n\n\tplatform_set_drvdata(pdev, ldo);\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic struct platform_driver wm831x_alive_ldo_driver = {\n\t.probe = wm831x_alive_ldo_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"wm831x-alive-ldo\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic struct platform_driver * const drivers[] = {\n\t&wm831x_gp_ldo_driver,\n\t&wm831x_aldo_driver,\n\t&wm831x_alive_ldo_driver,\n};\n\nstatic int __init wm831x_ldo_init(void)\n{\n\treturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n}\nsubsys_initcall(wm831x_ldo_init);\n\nstatic void __exit wm831x_ldo_exit(void)\n{\n\tplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\n}\nmodule_exit(wm831x_ldo_exit);\n\n \nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"WM831x LDO driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm831x-ldo\");\nMODULE_ALIAS(\"platform:wm831x-aldo\");\nMODULE_ALIAS(\"platform:wm831x-aliveldo\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}