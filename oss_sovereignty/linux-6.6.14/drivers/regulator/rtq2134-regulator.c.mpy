{
  "module_name": "rtq2134-regulator.c",
  "hash_id": "8e1dbe1373395031a8a5c2d5aad262114cd1b026cc4afd09eab2c93bd6187cd4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rtq2134-regulator.c",
  "human_readable_source": "\n\n#include <linux/bitops.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n\nenum {\n\tRTQ2134_IDX_BUCK1 = 0,\n\tRTQ2134_IDX_BUCK2,\n\tRTQ2134_IDX_BUCK3,\n\tRTQ2134_IDX_MAX\n};\n\n#define RTQ2134_AUTO_MODE\t\t0\n#define RTQ2134_FCCM_MODE\t\t1\n\n#define RTQ2134_BUCK_DVS0_CTRL\t\t0\n#define RTQ2134_BUCK_VSEL_CTRL\t\t2\n\n#define RTQ2134_REG_IO_CHIPNAME\t\t0x01\n#define RTQ2134_REG_FLT_RECORDTEMP\t0x13\n#define RTQ2134_REG_FLT_RECORDBUCK(_id)\t(0x14 + (_id))\n#define RTQ2134_REG_FLT_BUCKCTRL(_id)\t(0x37 + (_id))\n#define RTQ2134_REG_BUCK1_CFG0\t\t0x42\n#define RTQ2134_REG_BUCK1_DVS0CFG1\t0x48\n#define RTQ2134_REG_BUCK1_DVS0CFG0\t0x49\n#define RTQ2134_REG_BUCK1_DVS1CFG1\t0x4A\n#define RTQ2134_REG_BUCK1_DVS1CFG0\t0x4B\n#define RTQ2134_REG_BUCK1_DVSCFG\t0x52\n#define RTQ2134_REG_BUCK1_RSPCFG\t0x54\n#define RTQ2134_REG_BUCK2_CFG0\t\t0x5F\n#define RTQ2134_REG_BUCK2_DVS0CFG1\t0x62\n#define RTQ2134_REG_BUCK2_DVS0CFG0\t0x63\n#define RTQ2134_REG_BUCK2_DVS1CFG1\t0x64\n#define RTQ2134_REG_BUCK2_DVS1CFG0\t0x65\n#define RTQ2134_REG_BUCK2_DVSCFG\t0x6C\n#define RTQ2134_REG_BUCK2_RSPCFG\t0x6E\n#define RTQ2134_REG_BUCK3_CFG0\t\t0x79\n#define RTQ2134_REG_BUCK3_DVS0CFG1\t0x7C\n#define RTQ2134_REG_BUCK3_DVS0CFG0\t0x7D\n#define RTQ2134_REG_BUCK3_DVS1CFG1\t0x7E\n#define RTQ2134_REG_BUCK3_DVS1CFG0\t0x7F\n#define RTQ2134_REG_BUCK3_DVSCFG\t0x86\n#define RTQ2134_REG_BUCK3_RSPCFG\t0x88\n#define RTQ2134_REG_BUCK3_SLEWCTRL\t0x89\n\n#define RTQ2134_VOUT_MAXNUM\t\t256\n#define RTQ2134_VOUT_MASK\t\t0xFF\n#define RTQ2134_VOUTEN_MASK\t\tBIT(0)\n#define RTQ2134_ACTDISCHG_MASK\t\tBIT(0)\n#define RTQ2134_RSPUP_MASK\t\tGENMASK(6, 4)\n#define RTQ2134_FCCM_MASK\t\tBIT(5)\n#define RTQ2134_UVHICCUP_MASK\t\tBIT(3)\n#define RTQ2134_BUCKDVS_CTRL_MASK\tGENMASK(1, 0)\n#define RTQ2134_CHIPOT_MASK\t\tBIT(2)\n#define RTQ2134_BUCKOV_MASK\t\tBIT(5)\n#define RTQ2134_BUCKUV_MASK\t\tBIT(4)\n\nstruct rtq2134_regulator_desc {\n\tstruct regulator_desc desc;\n\t \n\tunsigned int mode_reg;\n\tunsigned int mode_mask;\n\tunsigned int suspend_enable_reg;\n\tunsigned int suspend_enable_mask;\n\tunsigned int suspend_vsel_reg;\n\tunsigned int suspend_vsel_mask;\n\tunsigned int suspend_mode_reg;\n\tunsigned int suspend_mode_mask;\n\tunsigned int dvs_ctrl_reg;\n};\n\nstatic int rtq2134_buck_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct rtq2134_regulator_desc *desc =\n\t\t(struct rtq2134_regulator_desc *)rdev->desc;\n\tunsigned int val;\n\n\tif (mode == REGULATOR_MODE_NORMAL)\n\t\tval = RTQ2134_AUTO_MODE;\n\telse if (mode == REGULATOR_MODE_FAST)\n\t\tval = RTQ2134_FCCM_MODE;\n\telse\n\t\treturn -EINVAL;\n\n\tval <<= ffs(desc->mode_mask) - 1;\n\treturn regmap_update_bits(rdev->regmap, desc->mode_reg, desc->mode_mask,\n\t\t\t\t  val);\n}\n\nstatic unsigned int rtq2134_buck_get_mode(struct regulator_dev *rdev)\n{\n\tstruct rtq2134_regulator_desc *desc =\n\t\t(struct rtq2134_regulator_desc *)rdev->desc;\n\tunsigned int mode;\n\tint ret;\n\n\tret = regmap_read(rdev->regmap, desc->mode_reg, &mode);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mode & desc->mode_mask)\n\t\treturn REGULATOR_MODE_FAST;\n\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int rtq2134_buck_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tstruct rtq2134_regulator_desc *desc =\n\t\t(struct rtq2134_regulator_desc *)rdev->desc;\n\tint sel;\n\n\tsel = regulator_map_voltage_linear_range(rdev, uV, uV);\n\tif (sel < 0)\n\t\treturn sel;\n\n\tsel <<= ffs(desc->suspend_vsel_mask) - 1;\n\n\treturn regmap_update_bits(rdev->regmap, desc->suspend_vsel_reg,\n\t\t\t\t  desc->suspend_vsel_mask, sel);\n}\n\nstatic int rtq2134_buck_set_suspend_enable(struct regulator_dev *rdev)\n{\n\tstruct rtq2134_regulator_desc *desc =\n\t\t(struct rtq2134_regulator_desc *)rdev->desc;\n\tunsigned int val = desc->suspend_enable_mask;\n\n\treturn regmap_update_bits(rdev->regmap, desc->suspend_enable_reg,\n\t\t\t\t  desc->suspend_enable_mask, val);\n}\n\nstatic int rtq2134_buck_set_suspend_disable(struct regulator_dev *rdev)\n{\n\tstruct rtq2134_regulator_desc *desc =\n\t\t(struct rtq2134_regulator_desc *)rdev->desc;\n\n\treturn regmap_update_bits(rdev->regmap, desc->suspend_enable_reg,\n\t\t\t\t  desc->suspend_enable_mask, 0);\n}\n\nstatic int rtq2134_buck_set_suspend_mode(struct regulator_dev *rdev,\n\t\t\t\t\t unsigned int mode)\n{\n\tstruct rtq2134_regulator_desc *desc =\n\t\t(struct rtq2134_regulator_desc *)rdev->desc;\n\tunsigned int val;\n\n\tif (mode == REGULATOR_MODE_NORMAL)\n\t\tval = RTQ2134_AUTO_MODE;\n\telse if (mode == REGULATOR_MODE_FAST)\n\t\tval = RTQ2134_FCCM_MODE;\n\telse\n\t\treturn -EINVAL;\n\n\tval <<= ffs(desc->suspend_mode_mask) - 1;\n\treturn regmap_update_bits(rdev->regmap, desc->suspend_mode_reg,\n\t\t\t\t  desc->suspend_mode_mask, val);\n}\n\nstatic int rtq2134_buck_get_error_flags(struct regulator_dev *rdev,\n\t\t\t\t\tunsigned int *flags)\n{\n\tint rid = rdev_get_id(rdev);\n\tunsigned int chip_error, buck_error, events = 0;\n\tint ret;\n\n\tret = regmap_read(rdev->regmap, RTQ2134_REG_FLT_RECORDTEMP,\n\t\t\t  &chip_error);\n\tif (ret) {\n\t\tdev_err(&rdev->dev, \"Failed to get chip error flag\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(rdev->regmap, RTQ2134_REG_FLT_RECORDBUCK(rid),\n\t\t\t  &buck_error);\n\tif (ret) {\n\t\tdev_err(&rdev->dev, \"Failed to get buck error flag\\n\");\n\t\treturn ret;\n\t}\n\n\tif (chip_error & RTQ2134_CHIPOT_MASK)\n\t\tevents |= REGULATOR_ERROR_OVER_TEMP;\n\n\tif (buck_error & RTQ2134_BUCKUV_MASK)\n\t\tevents |= REGULATOR_ERROR_UNDER_VOLTAGE;\n\n\tif (buck_error & RTQ2134_BUCKOV_MASK)\n\t\tevents |= REGULATOR_ERROR_REGULATION_OUT;\n\n\t*flags = events;\n\treturn 0;\n}\n\nstatic const struct regulator_ops rtq2134_buck_ops = {\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n\t.set_ramp_delay = regulator_set_ramp_delay_regmap,\n\t.set_mode = rtq2134_buck_set_mode,\n\t.get_mode = rtq2134_buck_get_mode,\n\t.set_suspend_voltage = rtq2134_buck_set_suspend_voltage,\n\t.set_suspend_enable = rtq2134_buck_set_suspend_enable,\n\t.set_suspend_disable = rtq2134_buck_set_suspend_disable,\n\t.set_suspend_mode = rtq2134_buck_set_suspend_mode,\n\t.get_error_flags = rtq2134_buck_get_error_flags,\n};\n\nstatic const struct linear_range rtq2134_buck_vout_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(300000, 0, 200, 5000),\n\tREGULATOR_LINEAR_RANGE(1310000, 201, 255, 10000)\n};\n\nstatic unsigned int rtq2134_buck_of_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase RTQ2134_AUTO_MODE:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase RTQ2134_FCCM_MODE:\n\t\treturn REGULATOR_MODE_FAST;\n\t}\n\n\treturn REGULATOR_MODE_INVALID;\n}\n\nstatic int rtq2134_buck_of_parse_cb(struct device_node *np,\n\t\t\t\t    const struct regulator_desc *desc,\n\t\t\t\t    struct regulator_config *cfg)\n{\n\tstruct rtq2134_regulator_desc *rdesc =\n\t\t(struct rtq2134_regulator_desc *)desc;\n\tint rid = desc->id;\n\tbool uv_shutdown, vsel_dvs;\n\tunsigned int val;\n\tint ret;\n\n\tvsel_dvs = of_property_read_bool(np, \"richtek,use-vsel-dvs\");\n\tif (vsel_dvs)\n\t\tval = RTQ2134_BUCK_VSEL_CTRL;\n\telse\n\t\tval = RTQ2134_BUCK_DVS0_CTRL;\n\n\tret = regmap_update_bits(cfg->regmap, rdesc->dvs_ctrl_reg,\n\t\t\t\t RTQ2134_BUCKDVS_CTRL_MASK, val);\n\tif (ret)\n\t\treturn ret;\n\n\tuv_shutdown = of_property_read_bool(np, \"richtek,uv-shutdown\");\n\tif (uv_shutdown)\n\t\tval = 0;\n\telse\n\t\tval = RTQ2134_UVHICCUP_MASK;\n\n\treturn regmap_update_bits(cfg->regmap, RTQ2134_REG_FLT_BUCKCTRL(rid),\n\t\t\t\t  RTQ2134_UVHICCUP_MASK, val);\n}\n\nstatic const unsigned int rtq2134_buck_ramp_delay_table[] = {\n\t0, 16000, 0, 8000, 4000, 2000, 1000, 500\n};\n\n#define RTQ2134_BUCK_DESC(_id) { \\\n\t.desc = { \\\n\t\t.name = \"rtq2134_buck\" #_id, \\\n\t\t.of_match = of_match_ptr(\"buck\" #_id), \\\n\t\t.regulators_node = of_match_ptr(\"regulators\"), \\\n\t\t.id = RTQ2134_IDX_BUCK##_id, \\\n\t\t.type = REGULATOR_VOLTAGE, \\\n\t\t.owner = THIS_MODULE, \\\n\t\t.ops = &rtq2134_buck_ops, \\\n\t\t.n_voltages = RTQ2134_VOUT_MAXNUM, \\\n\t\t.linear_ranges = rtq2134_buck_vout_ranges, \\\n\t\t.n_linear_ranges = ARRAY_SIZE(rtq2134_buck_vout_ranges), \\\n\t\t.vsel_reg = RTQ2134_REG_BUCK##_id##_DVS0CFG1, \\\n\t\t.vsel_mask = RTQ2134_VOUT_MASK, \\\n\t\t.enable_reg = RTQ2134_REG_BUCK##_id##_DVS0CFG0, \\\n\t\t.enable_mask = RTQ2134_VOUTEN_MASK, \\\n\t\t.active_discharge_reg = RTQ2134_REG_BUCK##_id##_CFG0, \\\n\t\t.active_discharge_mask = RTQ2134_ACTDISCHG_MASK, \\\n\t\t.active_discharge_on = RTQ2134_ACTDISCHG_MASK, \\\n\t\t.ramp_reg = RTQ2134_REG_BUCK##_id##_RSPCFG, \\\n\t\t.ramp_mask = RTQ2134_RSPUP_MASK, \\\n\t\t.ramp_delay_table = rtq2134_buck_ramp_delay_table, \\\n\t\t.n_ramp_values = ARRAY_SIZE(rtq2134_buck_ramp_delay_table), \\\n\t\t.of_map_mode = rtq2134_buck_of_map_mode, \\\n\t\t.of_parse_cb = rtq2134_buck_of_parse_cb, \\\n\t}, \\\n\t.mode_reg = RTQ2134_REG_BUCK##_id##_DVS0CFG0, \\\n\t.mode_mask = RTQ2134_FCCM_MASK, \\\n\t.suspend_mode_reg = RTQ2134_REG_BUCK##_id##_DVS1CFG0, \\\n\t.suspend_mode_mask = RTQ2134_FCCM_MASK, \\\n\t.suspend_enable_reg = RTQ2134_REG_BUCK##_id##_DVS1CFG0, \\\n\t.suspend_enable_mask = RTQ2134_VOUTEN_MASK, \\\n\t.suspend_vsel_reg = RTQ2134_REG_BUCK##_id##_DVS1CFG1, \\\n\t.suspend_vsel_mask = RTQ2134_VOUT_MASK, \\\n\t.dvs_ctrl_reg = RTQ2134_REG_BUCK##_id##_DVSCFG, \\\n}\n\nstatic const struct rtq2134_regulator_desc rtq2134_regulator_descs[] = {\n\tRTQ2134_BUCK_DESC(1),\n\tRTQ2134_BUCK_DESC(2),\n\tRTQ2134_BUCK_DESC(3)\n};\n\nstatic bool rtq2134_is_accissible_reg(struct device *dev, unsigned int reg)\n{\n\tif (reg >= RTQ2134_REG_IO_CHIPNAME && reg <= RTQ2134_REG_BUCK3_SLEWCTRL)\n\t\treturn true;\n\treturn false;\n}\n\nstatic const struct regmap_config rtq2134_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RTQ2134_REG_BUCK3_SLEWCTRL,\n\n\t.readable_reg = rtq2134_is_accissible_reg,\n\t.writeable_reg = rtq2134_is_accissible_reg,\n};\n\nstatic int rtq2134_probe(struct i2c_client *i2c)\n{\n\tstruct regmap *regmap;\n\tstruct regulator_dev *rdev;\n\tstruct regulator_config regulator_cfg = {};\n\tint i;\n\n\tregmap = devm_regmap_init_i2c(i2c, &rtq2134_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&i2c->dev, \"Failed to allocate regmap\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tregulator_cfg.dev = &i2c->dev;\n\tregulator_cfg.regmap = regmap;\n\tfor (i = 0; i < ARRAY_SIZE(rtq2134_regulator_descs); i++) {\n\t\trdev = devm_regulator_register(&i2c->dev,\n\t\t\t\t\t       &rtq2134_regulator_descs[i].desc,\n\t\t\t\t\t       &regulator_cfg);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&i2c->dev, \"Failed to init %d regulator\\n\", i);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused rtq2134_device_tables[] = {\n\t{ .compatible = \"richtek,rtq2134\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rtq2134_device_tables);\n\nstatic struct i2c_driver rtq2134_driver = {\n\t.driver = {\n\t\t.name = \"rtq2134\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = rtq2134_device_tables,\n\t},\n\t.probe = rtq2134_probe,\n};\nmodule_i2c_driver(rtq2134_driver);\n\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_DESCRIPTION(\"Richtek RTQ2134 Regulator Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}