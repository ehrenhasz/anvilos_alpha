{
  "module_name": "as3711-regulator.c",
  "hash_id": "83dfffc1fb43b3d81cbb9144b8906a9028bd1387cbd79ff41956dd3a61ead6dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/as3711-regulator.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/mfd/as3711.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/slab.h>\n\n \n\nstatic int as3711_set_mode_sd(struct regulator_dev *rdev, unsigned int mode)\n{\n\tunsigned int fast_bit = rdev->desc->enable_mask,\n\t\tlow_noise_bit = fast_bit << 4;\n\tu8 val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tval = fast_bit | low_noise_bit;\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = low_noise_bit;\n\t\tbreak;\n\tcase REGULATOR_MODE_IDLE:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(rdev->regmap, AS3711_SD_CONTROL_1,\n\t\t\t\t  low_noise_bit | fast_bit, val);\n}\n\nstatic unsigned int as3711_get_mode_sd(struct regulator_dev *rdev)\n{\n\tunsigned int fast_bit = rdev->desc->enable_mask,\n\t\tlow_noise_bit = fast_bit << 4, mask = fast_bit | low_noise_bit;\n\tunsigned int val;\n\tint ret = regmap_read(rdev->regmap, AS3711_SD_CONTROL_1, &val);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((val & mask) == mask)\n\t\treturn REGULATOR_MODE_FAST;\n\n\tif ((val & mask) == low_noise_bit)\n\t\treturn REGULATOR_MODE_NORMAL;\n\n\tif (!(val & mask))\n\t\treturn REGULATOR_MODE_IDLE;\n\n\treturn -EINVAL;\n}\n\nstatic const struct regulator_ops as3711_sd_ops = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n\t.get_mode\t\t= as3711_get_mode_sd,\n\t.set_mode\t\t= as3711_set_mode_sd,\n};\n\nstatic const struct regulator_ops as3711_aldo_ops = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n};\n\nstatic const struct regulator_ops as3711_dldo_ops = {\n\t.is_enabled\t\t= regulator_is_enabled_regmap,\n\t.enable\t\t\t= regulator_enable_regmap,\n\t.disable\t\t= regulator_disable_regmap,\n\t.get_voltage_sel\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t= regulator_list_voltage_linear_range,\n\t.map_voltage\t\t= regulator_map_voltage_linear_range,\n};\n\nstatic const struct linear_range as3711_sd_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(612500, 0x1, 0x40, 12500),\n\tREGULATOR_LINEAR_RANGE(1425000, 0x41, 0x70, 25000),\n\tREGULATOR_LINEAR_RANGE(2650000, 0x71, 0x7f, 50000),\n};\n\nstatic const struct linear_range as3711_aldo_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1200000, 0, 0xf, 50000),\n\tREGULATOR_LINEAR_RANGE(1800000, 0x10, 0x1f, 100000),\n};\n\nstatic const struct linear_range as3711_dldo_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(900000, 0, 0x10, 50000),\n\tREGULATOR_LINEAR_RANGE(1750000, 0x20, 0x3f, 50000),\n};\n\n#define AS3711_REG(_id, _en_reg, _en_bit, _vmask, _sfx)\t\t\t   \\\n\t[AS3711_REGULATOR_ ## _id] = {\t\t\t\t\t   \\\n\t\t.name = \"as3711-regulator-\" # _id,\t\t\t   \\\n\t\t.id = AS3711_REGULATOR_ ## _id,\t\t\t\t   \\\n\t\t.n_voltages = (_vmask + 1),\t\t\t\t   \\\n\t\t.ops = &as3711_ ## _sfx ## _ops,\t\t\t   \\\n\t\t.type = REGULATOR_VOLTAGE,\t\t\t\t   \\\n\t\t.owner = THIS_MODULE,\t\t\t\t\t   \\\n\t\t.vsel_reg = AS3711_ ## _id ## _VOLTAGE,\t\t\t   \\\n\t\t.vsel_mask = _vmask,\t\t\t\t\t   \\\n\t\t.enable_reg = AS3711_ ## _en_reg,\t\t\t   \\\n\t\t.enable_mask = BIT(_en_bit),\t\t\t\t   \\\n\t\t.linear_ranges = as3711_ ## _sfx ## _ranges,\t\t   \\\n\t\t.n_linear_ranges = ARRAY_SIZE(as3711_ ## _sfx ## _ranges), \\\n}\n\nstatic const struct regulator_desc as3711_reg_desc[] = {\n\tAS3711_REG(SD_1, SD_CONTROL, 0, 0x7f, sd),\n\tAS3711_REG(SD_2, SD_CONTROL, 1, 0x7f, sd),\n\tAS3711_REG(SD_3, SD_CONTROL, 2, 0x7f, sd),\n\tAS3711_REG(SD_4, SD_CONTROL, 3, 0x7f, sd),\n\tAS3711_REG(LDO_1, LDO_1_VOLTAGE, 7, 0x1f, aldo),\n\tAS3711_REG(LDO_2, LDO_2_VOLTAGE, 7, 0x1f, aldo),\n\tAS3711_REG(LDO_3, LDO_3_VOLTAGE, 7, 0x3f, dldo),\n\tAS3711_REG(LDO_4, LDO_4_VOLTAGE, 7, 0x3f, dldo),\n\tAS3711_REG(LDO_5, LDO_5_VOLTAGE, 7, 0x3f, dldo),\n\tAS3711_REG(LDO_6, LDO_6_VOLTAGE, 7, 0x3f, dldo),\n\tAS3711_REG(LDO_7, LDO_7_VOLTAGE, 7, 0x3f, dldo),\n\tAS3711_REG(LDO_8, LDO_8_VOLTAGE, 7, 0x3f, dldo),\n\t \n};\n\n#define AS3711_REGULATOR_NUM ARRAY_SIZE(as3711_reg_desc)\n\nstatic struct of_regulator_match\nas3711_regulator_matches[AS3711_REGULATOR_NUM] = {\n\t[AS3711_REGULATOR_SD_1] = { .name = \"sd1\" },\n\t[AS3711_REGULATOR_SD_2] = { .name = \"sd2\" },\n\t[AS3711_REGULATOR_SD_3] = { .name = \"sd3\" },\n\t[AS3711_REGULATOR_SD_4] = { .name = \"sd4\" },\n\t[AS3711_REGULATOR_LDO_1] = { .name = \"ldo1\" },\n\t[AS3711_REGULATOR_LDO_2] = { .name = \"ldo2\" },\n\t[AS3711_REGULATOR_LDO_3] = { .name = \"ldo3\" },\n\t[AS3711_REGULATOR_LDO_4] = { .name = \"ldo4\" },\n\t[AS3711_REGULATOR_LDO_5] = { .name = \"ldo5\" },\n\t[AS3711_REGULATOR_LDO_6] = { .name = \"ldo6\" },\n\t[AS3711_REGULATOR_LDO_7] = { .name = \"ldo7\" },\n\t[AS3711_REGULATOR_LDO_8] = { .name = \"ldo8\" },\n};\n\nstatic int as3711_regulator_parse_dt(struct device *dev,\n\t\t\t\tstruct device_node **of_node, const int count)\n{\n\tstruct as3711_regulator_pdata *pdata = dev_get_platdata(dev);\n\tstruct device_node *regulators =\n\t\tof_get_child_by_name(dev->parent->of_node, \"regulators\");\n\tstruct of_regulator_match *match;\n\tint ret, i;\n\n\tif (!regulators) {\n\t\tdev_err(dev, \"regulator node not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_regulator_match(dev->parent, regulators,\n\t\t\t\t as3711_regulator_matches, count);\n\tof_node_put(regulators);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error parsing regulator init data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0, match = as3711_regulator_matches; i < count; i++, match++)\n\t\tif (match->of_node) {\n\t\t\tpdata->init_data[i] = match->init_data;\n\t\t\tof_node[i] = match->of_node;\n\t\t}\n\n\treturn 0;\n}\n\nstatic int as3711_regulator_probe(struct platform_device *pdev)\n{\n\tstruct as3711_regulator_pdata *pdata = dev_get_platdata(&pdev->dev);\n\tstruct as3711 *as3711 = dev_get_drvdata(pdev->dev.parent);\n\tstruct regulator_config config = {.dev = &pdev->dev,};\n\tstruct device_node *of_node[AS3711_REGULATOR_NUM] = {};\n\tstruct regulator_dev *rdev;\n\tint ret;\n\tint id;\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"No platform data...\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pdev->dev.parent->of_node) {\n\t\tret = as3711_regulator_parse_dt(&pdev->dev, of_node, AS3711_REGULATOR_NUM);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"DT parsing failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (id = 0; id < AS3711_REGULATOR_NUM; id++) {\n\t\tconfig.init_data = pdata->init_data[id];\n\t\tconfig.regmap = as3711->regmap;\n\t\tconfig.of_node = of_node[id];\n\n\t\trdev = devm_regulator_register(&pdev->dev, &as3711_reg_desc[id],\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(&pdev->dev, \"Failed to register regulator %s\\n\",\n\t\t\t\tas3711_reg_desc[id].name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver as3711_regulator_driver = {\n\t.driver\t= {\n\t\t.name\t= \"as3711-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t\t= as3711_regulator_probe,\n};\n\nstatic int __init as3711_regulator_init(void)\n{\n\treturn platform_driver_register(&as3711_regulator_driver);\n}\nsubsys_initcall(as3711_regulator_init);\n\nstatic void __exit as3711_regulator_exit(void)\n{\n\tplatform_driver_unregister(&as3711_regulator_driver);\n}\nmodule_exit(as3711_regulator_exit);\n\nMODULE_AUTHOR(\"Guennadi Liakhovetski <g.liakhovetski@gmx.de>\");\nMODULE_DESCRIPTION(\"AS3711 regulator driver\");\nMODULE_ALIAS(\"platform:as3711-regulator\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}