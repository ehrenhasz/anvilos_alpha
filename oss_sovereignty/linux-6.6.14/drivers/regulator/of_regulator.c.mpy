{
  "module_name": "of_regulator.c",
  "hash_id": "3a871abdac3a656b151f08d7abf391eb7e02c1193dda890f2afa318d022788d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/of_regulator.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n\n#include \"internal.h\"\n\nstatic const char *const regulator_states[PM_SUSPEND_MAX + 1] = {\n\t[PM_SUSPEND_STANDBY]\t= \"regulator-state-standby\",\n\t[PM_SUSPEND_MEM]\t= \"regulator-state-mem\",\n\t[PM_SUSPEND_MAX]\t= \"regulator-state-disk\",\n};\n\nstatic void fill_limit(int *limit, int val)\n{\n\tif (val)\n\t\tif (val == 1)\n\t\t\t*limit = REGULATOR_NOTIF_LIMIT_ENABLE;\n\t\telse\n\t\t\t*limit = val;\n\telse\n\t\t*limit = REGULATOR_NOTIF_LIMIT_DISABLE;\n}\n\nstatic void of_get_regulator_prot_limits(struct device_node *np,\n\t\t\t\tstruct regulation_constraints *constraints)\n{\n\tu32 pval;\n\tint i;\n\tstatic const char *const props[] = {\n\t\t\"regulator-oc-%s-microamp\",\n\t\t\"regulator-ov-%s-microvolt\",\n\t\t\"regulator-temp-%s-kelvin\",\n\t\t\"regulator-uv-%s-microvolt\",\n\t};\n\tstruct notification_limit *limits[] = {\n\t\t&constraints->over_curr_limits,\n\t\t&constraints->over_voltage_limits,\n\t\t&constraints->temp_limits,\n\t\t&constraints->under_voltage_limits,\n\t};\n\tbool set[4] = {0};\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(props); i++) {\n\t\tchar prop[255];\n\t\tbool found;\n\t\tint j;\n\t\tstatic const char *const lvl[] = {\n\t\t\t\"protection\", \"error\", \"warn\"\n\t\t};\n\t\tint *l[] = {\n\t\t\t&limits[i]->prot, &limits[i]->err, &limits[i]->warn,\n\t\t};\n\n\t\tfor (j = 0; j < ARRAY_SIZE(lvl); j++) {\n\t\t\tsnprintf(prop, 255, props[i], lvl[j]);\n\t\t\tfound = !of_property_read_u32(np, prop, &pval);\n\t\t\tif (found)\n\t\t\t\tfill_limit(l[j], pval);\n\t\t\tset[i] |= found;\n\t\t}\n\t}\n\tconstraints->over_current_detection = set[0];\n\tconstraints->over_voltage_detection = set[1];\n\tconstraints->over_temp_detection = set[2];\n\tconstraints->under_voltage_detection = set[3];\n}\n\nstatic int of_get_regulation_constraints(struct device *dev,\n\t\t\t\t\tstruct device_node *np,\n\t\t\t\t\tstruct regulator_init_data **init_data,\n\t\t\t\t\tconst struct regulator_desc *desc)\n{\n\tstruct regulation_constraints *constraints = &(*init_data)->constraints;\n\tstruct regulator_state *suspend_state;\n\tstruct device_node *suspend_np;\n\tunsigned int mode;\n\tint ret, i, len;\n\tint n_phandles;\n\tu32 pval;\n\n\tn_phandles = of_count_phandle_with_args(np, \"regulator-coupled-with\",\n\t\t\t\t\t\tNULL);\n\tn_phandles = max(n_phandles, 0);\n\n\tconstraints->name = of_get_property(np, \"regulator-name\", NULL);\n\n\tif (!of_property_read_u32(np, \"regulator-min-microvolt\", &pval))\n\t\tconstraints->min_uV = pval;\n\n\tif (!of_property_read_u32(np, \"regulator-max-microvolt\", &pval))\n\t\tconstraints->max_uV = pval;\n\n\t \n\tif (constraints->min_uV != constraints->max_uV)\n\t\tconstraints->valid_ops_mask |= REGULATOR_CHANGE_VOLTAGE;\n\n\t \n\tif (constraints->min_uV && constraints->max_uV)\n\t\tconstraints->apply_uV = true;\n\n\tif (!of_property_read_u32(np, \"regulator-microvolt-offset\", &pval))\n\t\tconstraints->uV_offset = pval;\n\tif (!of_property_read_u32(np, \"regulator-min-microamp\", &pval))\n\t\tconstraints->min_uA = pval;\n\tif (!of_property_read_u32(np, \"regulator-max-microamp\", &pval))\n\t\tconstraints->max_uA = pval;\n\n\tif (!of_property_read_u32(np, \"regulator-input-current-limit-microamp\",\n\t\t\t\t  &pval))\n\t\tconstraints->ilim_uA = pval;\n\n\t \n\tif (constraints->min_uA != constraints->max_uA)\n\t\tconstraints->valid_ops_mask |= REGULATOR_CHANGE_CURRENT;\n\n\tconstraints->boot_on = of_property_read_bool(np, \"regulator-boot-on\");\n\tconstraints->always_on = of_property_read_bool(np, \"regulator-always-on\");\n\tif (!constraints->always_on)  \n\t\tconstraints->valid_ops_mask |= REGULATOR_CHANGE_STATUS;\n\n\tconstraints->pull_down = of_property_read_bool(np, \"regulator-pull-down\");\n\n\tif (of_property_read_bool(np, \"regulator-allow-bypass\"))\n\t\tconstraints->valid_ops_mask |= REGULATOR_CHANGE_BYPASS;\n\n\tif (of_property_read_bool(np, \"regulator-allow-set-load\"))\n\t\tconstraints->valid_ops_mask |= REGULATOR_CHANGE_DRMS;\n\n\tret = of_property_read_u32(np, \"regulator-ramp-delay\", &pval);\n\tif (!ret) {\n\t\tif (pval)\n\t\t\tconstraints->ramp_delay = pval;\n\t\telse\n\t\t\tconstraints->ramp_disable = true;\n\t}\n\n\tret = of_property_read_u32(np, \"regulator-settling-time-us\", &pval);\n\tif (!ret)\n\t\tconstraints->settling_time = pval;\n\n\tret = of_property_read_u32(np, \"regulator-settling-time-up-us\", &pval);\n\tif (!ret)\n\t\tconstraints->settling_time_up = pval;\n\tif (constraints->settling_time_up && constraints->settling_time) {\n\t\tpr_warn(\"%pOFn: ambiguous configuration for settling time, ignoring 'regulator-settling-time-up-us'\\n\",\n\t\t\tnp);\n\t\tconstraints->settling_time_up = 0;\n\t}\n\n\tret = of_property_read_u32(np, \"regulator-settling-time-down-us\",\n\t\t\t\t   &pval);\n\tif (!ret)\n\t\tconstraints->settling_time_down = pval;\n\tif (constraints->settling_time_down && constraints->settling_time) {\n\t\tpr_warn(\"%pOFn: ambiguous configuration for settling time, ignoring 'regulator-settling-time-down-us'\\n\",\n\t\t\tnp);\n\t\tconstraints->settling_time_down = 0;\n\t}\n\n\tret = of_property_read_u32(np, \"regulator-enable-ramp-delay\", &pval);\n\tif (!ret)\n\t\tconstraints->enable_time = pval;\n\n\tconstraints->soft_start = of_property_read_bool(np,\n\t\t\t\t\t\"regulator-soft-start\");\n\tret = of_property_read_u32(np, \"regulator-active-discharge\", &pval);\n\tif (!ret) {\n\t\tconstraints->active_discharge =\n\t\t\t\t(pval) ? REGULATOR_ACTIVE_DISCHARGE_ENABLE :\n\t\t\t\t\tREGULATOR_ACTIVE_DISCHARGE_DISABLE;\n\t}\n\n\tif (!of_property_read_u32(np, \"regulator-initial-mode\", &pval)) {\n\t\tif (desc && desc->of_map_mode) {\n\t\t\tmode = desc->of_map_mode(pval);\n\t\t\tif (mode == REGULATOR_MODE_INVALID)\n\t\t\t\tpr_err(\"%pOFn: invalid mode %u\\n\", np, pval);\n\t\t\telse\n\t\t\t\tconstraints->initial_mode = mode;\n\t\t} else {\n\t\t\tpr_warn(\"%pOFn: mapping for mode %d not defined\\n\",\n\t\t\t\tnp, pval);\n\t\t}\n\t}\n\n\tlen = of_property_count_elems_of_size(np, \"regulator-allowed-modes\",\n\t\t\t\t\t\tsizeof(u32));\n\tif (len > 0) {\n\t\tif (desc && desc->of_map_mode) {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tret = of_property_read_u32_index(np,\n\t\t\t\t\t\"regulator-allowed-modes\", i, &pval);\n\t\t\t\tif (ret) {\n\t\t\t\t\tpr_err(\"%pOFn: couldn't read allowed modes index %d, ret=%d\\n\",\n\t\t\t\t\t\tnp, i, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmode = desc->of_map_mode(pval);\n\t\t\t\tif (mode == REGULATOR_MODE_INVALID)\n\t\t\t\t\tpr_err(\"%pOFn: invalid regulator-allowed-modes element %u\\n\",\n\t\t\t\t\t\tnp, pval);\n\t\t\t\telse\n\t\t\t\t\tconstraints->valid_modes_mask |= mode;\n\t\t\t}\n\t\t\tif (constraints->valid_modes_mask)\n\t\t\t\tconstraints->valid_ops_mask\n\t\t\t\t\t|= REGULATOR_CHANGE_MODE;\n\t\t} else {\n\t\t\tpr_warn(\"%pOFn: mode mapping not defined\\n\", np);\n\t\t}\n\t}\n\n\tif (!of_property_read_u32(np, \"regulator-system-load\", &pval))\n\t\tconstraints->system_load = pval;\n\n\tif (n_phandles) {\n\t\tconstraints->max_spread = devm_kzalloc(dev,\n\t\t\t\tsizeof(*constraints->max_spread) * n_phandles,\n\t\t\t\tGFP_KERNEL);\n\n\t\tif (!constraints->max_spread)\n\t\t\treturn -ENOMEM;\n\n\t\tof_property_read_u32_array(np, \"regulator-coupled-max-spread\",\n\t\t\t\t\t   constraints->max_spread, n_phandles);\n\t}\n\n\tif (!of_property_read_u32(np, \"regulator-max-step-microvolt\",\n\t\t\t\t  &pval))\n\t\tconstraints->max_uV_step = pval;\n\n\tconstraints->over_current_protection = of_property_read_bool(np,\n\t\t\t\t\t\"regulator-over-current-protection\");\n\n\tof_get_regulator_prot_limits(np, constraints);\n\n\tfor (i = 0; i < ARRAY_SIZE(regulator_states); i++) {\n\t\tswitch (i) {\n\t\tcase PM_SUSPEND_MEM:\n\t\t\tsuspend_state = &constraints->state_mem;\n\t\t\tbreak;\n\t\tcase PM_SUSPEND_MAX:\n\t\t\tsuspend_state = &constraints->state_disk;\n\t\t\tbreak;\n\t\tcase PM_SUSPEND_STANDBY:\n\t\t\tsuspend_state = &constraints->state_standby;\n\t\t\tbreak;\n\t\tcase PM_SUSPEND_ON:\n\t\tcase PM_SUSPEND_TO_IDLE:\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tsuspend_np = of_get_child_by_name(np, regulator_states[i]);\n\t\tif (!suspend_np)\n\t\t\tcontinue;\n\t\tif (!suspend_state) {\n\t\t\tof_node_put(suspend_np);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!of_property_read_u32(suspend_np, \"regulator-mode\",\n\t\t\t\t\t  &pval)) {\n\t\t\tif (desc && desc->of_map_mode) {\n\t\t\t\tmode = desc->of_map_mode(pval);\n\t\t\t\tif (mode == REGULATOR_MODE_INVALID)\n\t\t\t\t\tpr_err(\"%pOFn: invalid mode %u\\n\",\n\t\t\t\t\t       np, pval);\n\t\t\t\telse\n\t\t\t\t\tsuspend_state->mode = mode;\n\t\t\t} else {\n\t\t\t\tpr_warn(\"%pOFn: mapping for mode %d not defined\\n\",\n\t\t\t\t\tnp, pval);\n\t\t\t}\n\t\t}\n\n\t\tif (of_property_read_bool(suspend_np,\n\t\t\t\t\t\"regulator-on-in-suspend\"))\n\t\t\tsuspend_state->enabled = ENABLE_IN_SUSPEND;\n\t\telse if (of_property_read_bool(suspend_np,\n\t\t\t\t\t\"regulator-off-in-suspend\"))\n\t\t\tsuspend_state->enabled = DISABLE_IN_SUSPEND;\n\n\t\tif (!of_property_read_u32(suspend_np,\n\t\t\t\t\"regulator-suspend-min-microvolt\", &pval))\n\t\t\tsuspend_state->min_uV = pval;\n\n\t\tif (!of_property_read_u32(suspend_np,\n\t\t\t\t\"regulator-suspend-max-microvolt\", &pval))\n\t\t\tsuspend_state->max_uV = pval;\n\n\t\tif (!of_property_read_u32(suspend_np,\n\t\t\t\t\t\"regulator-suspend-microvolt\", &pval))\n\t\t\tsuspend_state->uV = pval;\n\t\telse  \n\t\t\tsuspend_state->uV = suspend_state->min_uV;\n\n\t\tif (of_property_read_bool(suspend_np,\n\t\t\t\t\t\"regulator-changeable-in-suspend\"))\n\t\t\tsuspend_state->changeable = true;\n\n\t\tif (i == PM_SUSPEND_MEM)\n\t\t\tconstraints->initial_state = PM_SUSPEND_MEM;\n\n\t\tof_node_put(suspend_np);\n\t\tsuspend_state = NULL;\n\t\tsuspend_np = NULL;\n\t}\n\n\treturn 0;\n}\n\n \nstruct regulator_init_data *of_get_regulator_init_data(struct device *dev,\n\t\t\t\t\t  struct device_node *node,\n\t\t\t\t\t  const struct regulator_desc *desc)\n{\n\tstruct regulator_init_data *init_data;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tinit_data = devm_kzalloc(dev, sizeof(*init_data), GFP_KERNEL);\n\tif (!init_data)\n\t\treturn NULL;  \n\n\tif (of_get_regulation_constraints(dev, node, &init_data, desc))\n\t\treturn NULL;\n\n\treturn init_data;\n}\nEXPORT_SYMBOL_GPL(of_get_regulator_init_data);\n\nstruct devm_of_regulator_matches {\n\tstruct of_regulator_match *matches;\n\tunsigned int num_matches;\n};\n\nstatic void devm_of_regulator_put_matches(struct device *dev, void *res)\n{\n\tstruct devm_of_regulator_matches *devm_matches = res;\n\tint i;\n\n\tfor (i = 0; i < devm_matches->num_matches; i++)\n\t\tof_node_put(devm_matches->matches[i].of_node);\n}\n\n \nint of_regulator_match(struct device *dev, struct device_node *node,\n\t\t       struct of_regulator_match *matches,\n\t\t       unsigned int num_matches)\n{\n\tunsigned int count = 0;\n\tunsigned int i;\n\tconst char *name;\n\tstruct device_node *child;\n\tstruct devm_of_regulator_matches *devm_matches;\n\n\tif (!dev || !node)\n\t\treturn -EINVAL;\n\n\tdevm_matches = devres_alloc(devm_of_regulator_put_matches,\n\t\t\t\t    sizeof(struct devm_of_regulator_matches),\n\t\t\t\t    GFP_KERNEL);\n\tif (!devm_matches)\n\t\treturn -ENOMEM;\n\n\tdevm_matches->matches = matches;\n\tdevm_matches->num_matches = num_matches;\n\n\tdevres_add(dev, devm_matches);\n\n\tfor (i = 0; i < num_matches; i++) {\n\t\tstruct of_regulator_match *match = &matches[i];\n\t\tmatch->init_data = NULL;\n\t\tmatch->of_node = NULL;\n\t}\n\n\tfor_each_child_of_node(node, child) {\n\t\tname = of_get_property(child,\n\t\t\t\t\t\"regulator-compatible\", NULL);\n\t\tif (!name)\n\t\t\tname = child->name;\n\t\tfor (i = 0; i < num_matches; i++) {\n\t\t\tstruct of_regulator_match *match = &matches[i];\n\t\t\tif (match->of_node)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(match->name, name))\n\t\t\t\tcontinue;\n\n\t\t\tmatch->init_data =\n\t\t\t\tof_get_regulator_init_data(dev, child,\n\t\t\t\t\t\t\t   match->desc);\n\t\t\tif (!match->init_data) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"failed to parse DT for regulator %pOFn\\n\",\n\t\t\t\t\tchild);\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmatch->of_node = of_node_get(child);\n\t\t\tcount++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(of_regulator_match);\n\nstatic struct\ndevice_node *regulator_of_get_init_node(struct device *dev,\n\t\t\t\t\tconst struct regulator_desc *desc)\n{\n\tstruct device_node *search, *child;\n\tconst char *name;\n\n\tif (!dev->of_node || !desc->of_match)\n\t\treturn NULL;\n\n\tif (desc->regulators_node) {\n\t\tsearch = of_get_child_by_name(dev->of_node,\n\t\t\t\t\t      desc->regulators_node);\n\t} else {\n\t\tsearch = of_node_get(dev->of_node);\n\n\t\tif (!strcmp(desc->of_match, search->name))\n\t\t\treturn search;\n\t}\n\n\tif (!search) {\n\t\tdev_dbg(dev, \"Failed to find regulator container node '%s'\\n\",\n\t\t\tdesc->regulators_node);\n\t\treturn NULL;\n\t}\n\n\tfor_each_available_child_of_node(search, child) {\n\t\tname = of_get_property(child, \"regulator-compatible\", NULL);\n\t\tif (!name) {\n\t\t\tif (!desc->of_match_full_name)\n\t\t\t\tname = child->name;\n\t\t\telse\n\t\t\t\tname = child->full_name;\n\t\t}\n\n\t\tif (!strcmp(desc->of_match, name)) {\n\t\t\tof_node_put(search);\n\t\t\t \n\t\t\treturn child;\n\t\t}\n\t}\n\n\tof_node_put(search);\n\n\treturn NULL;\n}\n\nstruct regulator_init_data *regulator_of_get_init_data(struct device *dev,\n\t\t\t\t\t    const struct regulator_desc *desc,\n\t\t\t\t\t    struct regulator_config *config,\n\t\t\t\t\t    struct device_node **node)\n{\n\tstruct device_node *child;\n\tstruct regulator_init_data *init_data = NULL;\n\n\tchild = regulator_of_get_init_node(config->dev, desc);\n\tif (!child)\n\t\treturn NULL;\n\n\tinit_data = of_get_regulator_init_data(dev, child, desc);\n\tif (!init_data) {\n\t\tdev_err(dev, \"failed to parse DT for regulator %pOFn\\n\", child);\n\t\tgoto error;\n\t}\n\n\tif (desc->of_parse_cb) {\n\t\tint ret;\n\n\t\tret = desc->of_parse_cb(child, desc, config);\n\t\tif (ret) {\n\t\t\tif (ret == -EPROBE_DEFER) {\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t\t\t}\n\t\t\tdev_err(dev,\n\t\t\t\t\"driver callback failed to parse DT for regulator %pOFn\\n\",\n\t\t\t\tchild);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t*node = child;\n\n\treturn init_data;\n\nerror:\n\tof_node_put(child);\n\n\treturn NULL;\n}\n\nstruct regulator_dev *of_find_regulator_by_node(struct device_node *np)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device_by_of_node(&regulator_class, np);\n\n\treturn dev ? dev_to_rdev(dev) : NULL;\n}\n\n \nint of_get_n_coupled(struct regulator_dev *rdev)\n{\n\tstruct device_node *node = rdev->dev.of_node;\n\tint n_phandles;\n\n\tn_phandles = of_count_phandle_with_args(node,\n\t\t\t\t\t\t\"regulator-coupled-with\",\n\t\t\t\t\t\tNULL);\n\n\treturn (n_phandles > 0) ? n_phandles : 0;\n}\n\n \nstatic bool of_coupling_find_node(struct device_node *src,\n\t\t\t\t  struct device_node *to_find,\n\t\t\t\t  int *index)\n{\n\tint n_phandles, i;\n\tbool found = false;\n\n\tn_phandles = of_count_phandle_with_args(src,\n\t\t\t\t\t\t\"regulator-coupled-with\",\n\t\t\t\t\t\tNULL);\n\n\tfor (i = 0; i < n_phandles; i++) {\n\t\tstruct device_node *tmp = of_parse_phandle(src,\n\t\t\t\t\t   \"regulator-coupled-with\", i);\n\n\t\tif (!tmp)\n\t\t\tbreak;\n\n\t\t \n\t\tif (tmp == to_find)\n\t\t\tfound = true;\n\n\t\tof_node_put(tmp);\n\n\t\tif (found) {\n\t\t\t*index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\n \nbool of_check_coupling_data(struct regulator_dev *rdev)\n{\n\tstruct device_node *node = rdev->dev.of_node;\n\tint n_phandles = of_get_n_coupled(rdev);\n\tstruct device_node *c_node;\n\tint index;\n\tint i;\n\tbool ret = true;\n\n\t \n\tfor (i = 0; i < n_phandles; i++) {\n\t\tint max_spread = rdev->constraints->max_spread[i];\n\t\tint c_max_spread, c_n_phandles;\n\n\t\tif (max_spread <= 0) {\n\t\t\tdev_err(&rdev->dev, \"max_spread value invalid\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tc_node = of_parse_phandle(node,\n\t\t\t\t\t  \"regulator-coupled-with\", i);\n\n\t\tif (!c_node)\n\t\t\tret = false;\n\n\t\tc_n_phandles = of_count_phandle_with_args(c_node,\n\t\t\t\t\t\t\t  \"regulator-coupled-with\",\n\t\t\t\t\t\t\t  NULL);\n\n\t\tif (c_n_phandles != n_phandles) {\n\t\t\tdev_err(&rdev->dev, \"number of coupled reg phandles mismatch\\n\");\n\t\t\tret = false;\n\t\t\tgoto clean;\n\t\t}\n\n\t\tif (!of_coupling_find_node(c_node, node, &index)) {\n\t\t\tdev_err(&rdev->dev, \"missing 2-way linking for coupled regulators\\n\");\n\t\t\tret = false;\n\t\t\tgoto clean;\n\t\t}\n\n\t\tif (of_property_read_u32_index(c_node, \"regulator-coupled-max-spread\",\n\t\t\t\t\t       index, &c_max_spread)) {\n\t\t\tret = false;\n\t\t\tgoto clean;\n\t\t}\n\n\t\tif (c_max_spread != max_spread) {\n\t\t\tdev_err(&rdev->dev,\n\t\t\t\t\"coupled regulators max_spread mismatch\\n\");\n\t\t\tret = false;\n\t\t\tgoto clean;\n\t\t}\n\nclean:\n\t\tof_node_put(c_node);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstruct regulator_dev *of_parse_coupled_regulator(struct regulator_dev *rdev,\n\t\t\t\t\t\t int index)\n{\n\tstruct device_node *node = rdev->dev.of_node;\n\tstruct device_node *c_node;\n\tstruct regulator_dev *c_rdev;\n\n\tc_node = of_parse_phandle(node, \"regulator-coupled-with\", index);\n\tif (!c_node)\n\t\treturn NULL;\n\n\tc_rdev = of_find_regulator_by_node(c_node);\n\n\tof_node_put(c_node);\n\n\treturn c_rdev;\n}\n\n \nstatic int is_supply_name(const char *name)\n{\n\tint strs, i;\n\n\tstrs = strlen(name);\n\t \n\tif (strs < 8)\n\t\treturn 0;\n\tfor (i = strs - 6; i > 0; i--) {\n\t\t \n\t\tif (name[i] != '-')\n\t\t\tcontinue;\n\t\tif (strcmp(name + i + 1, \"supply\") != 0)\n\t\t\treturn 0;\n\t\treturn i;\n\t}\n\treturn 0;\n}\n\n \nint of_regulator_bulk_get_all(struct device *dev, struct device_node *np,\n\t\t\t      struct regulator_bulk_data **consumers)\n{\n\tint num_consumers = 0;\n\tstruct regulator *tmp;\n\tstruct property *prop;\n\tint i, n = 0, ret;\n\tchar name[64];\n\n\t*consumers = NULL;\n\n\t \nrestart:\n\tfor_each_property_of_node(np, prop) {\n\t\ti = is_supply_name(prop->name);\n\t\tif (i == 0)\n\t\t\tcontinue;\n\t\tif (!*consumers) {\n\t\t\tnum_consumers++;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tmemcpy(name, prop->name, i);\n\t\t\tname[i] = '\\0';\n\t\t\ttmp = regulator_get(dev, name);\n\t\t\tif (IS_ERR(tmp)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t(*consumers)[n].consumer = tmp;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif (*consumers)\n\t\treturn num_consumers;\n\tif (num_consumers == 0)\n\t\treturn 0;\n\t*consumers = kmalloc_array(num_consumers,\n\t\t\t\t   sizeof(struct regulator_bulk_data),\n\t\t\t\t   GFP_KERNEL);\n\tif (!*consumers)\n\t\treturn -ENOMEM;\n\tgoto restart;\n\nerror:\n\twhile (--n >= 0)\n\t\tregulator_put(consumers[n]->consumer);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_regulator_bulk_get_all);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}