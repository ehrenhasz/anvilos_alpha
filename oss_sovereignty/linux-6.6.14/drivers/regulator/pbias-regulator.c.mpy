{
  "module_name": "pbias-regulator.c",
  "hash_id": "13f6242bf264404eec8938bfd8ed6bb8ab211102545349fec5e2e4a656e7f57f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/pbias-regulator.c",
  "human_readable_source": " \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\nstruct pbias_reg_info {\n\tu32 enable;\n\tu32 enable_mask;\n\tu32 disable_val;\n\tu32 vmode;\n\tunsigned int enable_time;\n\tchar *name;\n\tconst unsigned int *pbias_volt_table;\n\tint n_voltages;\n};\n\nstruct pbias_of_data {\n\tunsigned int offset;\n};\n\nstatic const unsigned int pbias_volt_table_3_0V[] = {\n\t1800000,\n\t3000000\n};\n\nstatic const unsigned int pbias_volt_table_3_3V[] = {\n\t1800000,\n\t3300000\n};\n\nstatic const struct regulator_ops pbias_regulator_voltage_ops = {\n\t.list_voltage = regulator_list_voltage_table,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.is_enabled = regulator_is_enabled_regmap,\n};\n\nstatic const struct pbias_reg_info pbias_mmc_omap2430 = {\n\t.enable = BIT(1),\n\t.enable_mask = BIT(1),\n\t.vmode = BIT(0),\n\t.disable_val = 0,\n\t.enable_time = 100,\n\t.pbias_volt_table = pbias_volt_table_3_0V,\n\t.n_voltages = 2,\n\t.name = \"pbias_mmc_omap2430\"\n};\n\nstatic const struct pbias_reg_info pbias_sim_omap3 = {\n\t.enable = BIT(9),\n\t.enable_mask = BIT(9),\n\t.vmode = BIT(8),\n\t.enable_time = 100,\n\t.pbias_volt_table = pbias_volt_table_3_0V,\n\t.n_voltages = 2,\n\t.name = \"pbias_sim_omap3\"\n};\n\nstatic const struct pbias_reg_info pbias_mmc_omap4 = {\n\t.enable = BIT(26) | BIT(22),\n\t.enable_mask = BIT(26) | BIT(25) | BIT(22),\n\t.disable_val = BIT(25),\n\t.vmode = BIT(21),\n\t.enable_time = 100,\n\t.pbias_volt_table = pbias_volt_table_3_0V,\n\t.n_voltages = 2,\n\t.name = \"pbias_mmc_omap4\"\n};\n\nstatic const struct pbias_reg_info pbias_mmc_omap5 = {\n\t.enable = BIT(27) | BIT(26),\n\t.enable_mask = BIT(27) | BIT(25) | BIT(26),\n\t.disable_val = BIT(25),\n\t.vmode = BIT(21),\n\t.enable_time = 100,\n\t.pbias_volt_table = pbias_volt_table_3_3V,\n\t.n_voltages = 2,\n\t.name = \"pbias_mmc_omap5\"\n};\n\nstatic struct of_regulator_match pbias_matches[] = {\n\t{ .name = \"pbias_mmc_omap2430\", .driver_data = (void *)&pbias_mmc_omap2430},\n\t{ .name = \"pbias_sim_omap3\", .driver_data = (void *)&pbias_sim_omap3},\n\t{ .name = \"pbias_mmc_omap4\", .driver_data = (void *)&pbias_mmc_omap4},\n\t{ .name = \"pbias_mmc_omap5\", .driver_data = (void *)&pbias_mmc_omap5},\n};\n#define PBIAS_NUM_REGS\tARRAY_SIZE(pbias_matches)\n\n \n\nstatic const struct pbias_of_data pbias_of_data_omap2 = {\n\t.offset = 0x230,\n};\n\nstatic const struct pbias_of_data pbias_of_data_omap3 = {\n\t.offset = 0x2b0,\n};\n\nstatic const struct pbias_of_data pbias_of_data_omap4 = {\n\t.offset = 0x60,\n};\n\nstatic const struct pbias_of_data pbias_of_data_omap5 = {\n\t.offset = 0x60,\n};\n\nstatic const struct pbias_of_data pbias_of_data_dra7 = {\n\t.offset = 0xe00,\n};\n\nstatic const struct of_device_id pbias_of_match[] = {\n\t{ .compatible = \"ti,pbias-omap\", },\n\t{ .compatible = \"ti,pbias-omap2\", .data = &pbias_of_data_omap2, },\n\t{ .compatible = \"ti,pbias-omap3\", .data = &pbias_of_data_omap3, },\n\t{ .compatible = \"ti,pbias-omap4\", .data = &pbias_of_data_omap4, },\n\t{ .compatible = \"ti,pbias-omap5\", .data = &pbias_of_data_omap5, },\n\t{ .compatible = \"ti,pbias-dra7\", .data = &pbias_of_data_dra7, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, pbias_of_match);\n\nstatic int pbias_regulator_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct resource *res;\n\tstruct regulator_config cfg = { };\n\tstruct regulator_desc *desc;\n\tstruct regulator_dev *rdev;\n\tstruct regmap *syscon;\n\tconst struct pbias_reg_info *info;\n\tint ret, count, idx;\n\tconst struct pbias_of_data *data;\n\tunsigned int offset;\n\n\tcount = of_regulator_match(&pdev->dev, np, pbias_matches,\n\t\t\t\t\t\tPBIAS_NUM_REGS);\n\tif (count < 0)\n\t\treturn count;\n\n\tdesc = devm_kcalloc(&pdev->dev, count, sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tsyscon = syscon_regmap_lookup_by_phandle(np, \"syscon\");\n\tif (IS_ERR(syscon))\n\t\treturn PTR_ERR(syscon);\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (data) {\n\t\toffset = data->offset;\n\t} else {\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t\tif (!res)\n\t\t\treturn -EINVAL;\n\n\t\toffset = res->start;\n\t\tdev_WARN(&pdev->dev,\n\t\t\t \"using legacy dt data for pbias offset\\n\");\n\t}\n\n\tcfg.regmap = syscon;\n\tcfg.dev = &pdev->dev;\n\n\tfor (idx = 0; idx < PBIAS_NUM_REGS && count; idx++) {\n\t\tif (!pbias_matches[idx].init_data ||\n\t\t\t!pbias_matches[idx].of_node)\n\t\t\tcontinue;\n\n\t\tinfo = pbias_matches[idx].driver_data;\n\t\tif (!info)\n\t\t\treturn -ENODEV;\n\n\t\tdesc->name = info->name;\n\t\tdesc->owner = THIS_MODULE;\n\t\tdesc->type = REGULATOR_VOLTAGE;\n\t\tdesc->ops = &pbias_regulator_voltage_ops;\n\t\tdesc->volt_table = info->pbias_volt_table;\n\t\tdesc->n_voltages = info->n_voltages;\n\t\tdesc->enable_time = info->enable_time;\n\t\tdesc->vsel_reg = offset;\n\t\tdesc->vsel_mask = info->vmode;\n\t\tdesc->enable_reg = offset;\n\t\tdesc->enable_mask = info->enable_mask;\n\t\tdesc->enable_val = info->enable;\n\t\tdesc->disable_val = info->disable_val;\n\n\t\tcfg.init_data = pbias_matches[idx].init_data;\n\t\tcfg.of_node = pbias_matches[idx].of_node;\n\n\t\trdev = devm_regulator_register(&pdev->dev, desc, &cfg);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tret = PTR_ERR(rdev);\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to register regulator: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdesc++;\n\t\tcount--;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver pbias_regulator_driver = {\n\t.probe\t\t= pbias_regulator_probe,\n\t.driver\t\t= {\n\t\t.name\t\t= \"pbias-regulator\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(pbias_of_match),\n\t},\n};\n\nmodule_platform_driver(pbias_regulator_driver);\n\nMODULE_AUTHOR(\"Balaji T K <balajitk@ti.com>\");\nMODULE_DESCRIPTION(\"pbias voltage regulator\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pbias-regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}