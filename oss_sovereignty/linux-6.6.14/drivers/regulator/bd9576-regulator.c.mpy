{
  "module_name": "bd9576-regulator.c",
  "hash_id": "4e4540be7a23ff6c1522686ff91e7e9096cf4ecc980a711b181a1cad9dabb491",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/bd9576-regulator.c",
  "human_readable_source": "\n\n\n\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/mfd/rohm-bd957x.h>\n#include <linux/mfd/rohm-generic.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define BD957X_VOUTS1_VOLT\t3300000\n#define BD957X_VOUTS4_BASE_VOLT\t1030000\n#define BD957X_VOUTS34_NUM_VOLT\t32\n\n#define BD9576_THERM_IRQ_MASK_TW\tBIT(5)\n#define BD9576_xVD_IRQ_MASK_VOUTL1\tBIT(5)\n#define BD9576_UVD_IRQ_MASK_VOUTS1_OCW\tBIT(6)\n#define BD9576_xVD_IRQ_MASK_VOUT1TO4\t0x0F\n\nstatic const unsigned int vout1_volt_table[] = {\n\t5000000, 4900000, 4800000, 4700000, 4600000,\n\t4500000, 4500000, 4500000, 5000000, 5100000,\n\t5200000, 5300000, 5400000, 5500000, 5500000,\n\t5500000\n};\n\nstatic const unsigned int vout2_volt_table[] = {\n\t1800000, 1780000, 1760000, 1740000, 1720000,\n\t1700000, 1680000, 1660000, 1800000, 1820000,\n\t1840000, 1860000, 1880000, 1900000, 1920000,\n\t1940000\n};\n\nstatic const unsigned int voutl1_volt_table[] = {\n\t2500000, 2540000, 2580000, 2620000, 2660000,\n\t2700000, 2740000, 2780000, 2500000, 2460000,\n\t2420000, 2380000, 2340000, 2300000, 2260000,\n\t2220000\n};\n\nstatic const struct linear_range vout1_xvd_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(225000, 0x01, 0x2b, 0),\n\tREGULATOR_LINEAR_RANGE(225000, 0x2c, 0x54, 5000),\n\tREGULATOR_LINEAR_RANGE(425000, 0x55, 0x7f, 0),\n};\n\nstatic const struct linear_range vout234_xvd_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(17000, 0x01, 0x0f, 0),\n\tREGULATOR_LINEAR_RANGE(17000, 0x10, 0x6d, 1000),\n\tREGULATOR_LINEAR_RANGE(110000, 0x6e, 0x7f, 0),\n};\n\nstatic const struct linear_range voutL1_xvd_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(34000, 0x01, 0x0f, 0),\n\tREGULATOR_LINEAR_RANGE(34000, 0x10, 0x6d, 2000),\n\tREGULATOR_LINEAR_RANGE(220000, 0x6e, 0x7f, 0),\n};\n\nstatic struct linear_range voutS1_ocw_ranges_internal[] = {\n\tREGULATOR_LINEAR_RANGE(200000, 0x01, 0x04, 0),\n\tREGULATOR_LINEAR_RANGE(250000, 0x05, 0x18, 50000),\n\tREGULATOR_LINEAR_RANGE(1200000, 0x19, 0x3f, 0),\n};\n\nstatic struct linear_range voutS1_ocw_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(50000, 0x01, 0x04, 0),\n\tREGULATOR_LINEAR_RANGE(60000, 0x05, 0x18, 10000),\n\tREGULATOR_LINEAR_RANGE(250000, 0x19, 0x3f, 0),\n};\n\nstatic struct linear_range voutS1_ocp_ranges_internal[] = {\n\tREGULATOR_LINEAR_RANGE(300000, 0x01, 0x06, 0),\n\tREGULATOR_LINEAR_RANGE(350000, 0x7, 0x1b, 50000),\n\tREGULATOR_LINEAR_RANGE(1350000, 0x1c, 0x3f, 0),\n};\n\nstatic struct linear_range voutS1_ocp_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(70000, 0x01, 0x06, 0),\n\tREGULATOR_LINEAR_RANGE(80000, 0x7, 0x1b, 10000),\n\tREGULATOR_LINEAR_RANGE(280000, 0x1c, 0x3f, 0),\n};\n\nstruct bd957x_regulator_data {\n\tstruct regulator_desc desc;\n\tint base_voltage;\n\tstruct regulator_dev *rdev;\n\tint ovd_notif;\n\tint uvd_notif;\n\tint temp_notif;\n\tint ovd_err;\n\tint uvd_err;\n\tint temp_err;\n\tconst struct linear_range *xvd_ranges;\n\tint num_xvd_ranges;\n\tbool oc_supported;\n\tunsigned int ovd_reg;\n\tunsigned int uvd_reg;\n\tunsigned int xvd_mask;\n\tunsigned int ocp_reg;\n\tunsigned int ocp_mask;\n\tunsigned int ocw_reg;\n\tunsigned int ocw_mask;\n\tunsigned int ocw_rfet;\n};\n\n#define BD9576_NUM_REGULATORS 6\n#define BD9576_NUM_OVD_REGULATORS 5\n\nstruct bd957x_data {\n\tstruct bd957x_regulator_data regulator_data[BD9576_NUM_REGULATORS];\n\tstruct regmap *regmap;\n\tstruct delayed_work therm_irq_suppress;\n\tstruct delayed_work ovd_irq_suppress;\n\tstruct delayed_work uvd_irq_suppress;\n\tunsigned int therm_irq;\n\tunsigned int ovd_irq;\n\tunsigned int uvd_irq;\n\tspinlock_t err_lock;\n\tint regulator_global_err;\n};\n\nstatic int bd957x_vout34_list_voltage(struct regulator_dev *rdev,\n\t\t\t\t      unsigned int selector)\n{\n\tconst struct regulator_desc *desc = rdev->desc;\n\tint multiplier = selector & desc->vsel_mask & 0x7f;\n\tint tune;\n\n\t \n\ttune = multiplier * 10000;\n\n\tif (!(selector & 0x80))\n\t\treturn desc->fixed_uV - tune;\n\n\treturn desc->fixed_uV + tune;\n}\n\nstatic int bd957x_list_voltage(struct regulator_dev *rdev,\n\t\t\t       unsigned int selector)\n{\n\tconst struct regulator_desc *desc = rdev->desc;\n\tint index = selector & desc->vsel_mask & 0x7f;\n\n\tif (!(selector & 0x80))\n\t\tindex += desc->n_voltages/2;\n\n\tif (index >= desc->n_voltages)\n\t\treturn -EINVAL;\n\n\treturn desc->volt_table[index];\n}\n\nstatic void bd9576_fill_ovd_flags(struct bd957x_regulator_data *data,\n\t\t\t\t  bool warn)\n{\n\tif (warn) {\n\t\tdata->ovd_notif = REGULATOR_EVENT_OVER_VOLTAGE_WARN;\n\t\tdata->ovd_err = REGULATOR_ERROR_OVER_VOLTAGE_WARN;\n\t} else {\n\t\tdata->ovd_notif = REGULATOR_EVENT_REGULATION_OUT;\n\t\tdata->ovd_err = REGULATOR_ERROR_REGULATION_OUT;\n\t}\n}\n\nstatic void bd9576_fill_ocp_flags(struct bd957x_regulator_data *data,\n\t\t\t\t  bool warn)\n{\n\tif (warn) {\n\t\tdata->uvd_notif = REGULATOR_EVENT_OVER_CURRENT_WARN;\n\t\tdata->uvd_err = REGULATOR_ERROR_OVER_CURRENT_WARN;\n\t} else {\n\t\tdata->uvd_notif = REGULATOR_EVENT_OVER_CURRENT;\n\t\tdata->uvd_err = REGULATOR_ERROR_OVER_CURRENT;\n\t}\n}\n\nstatic void bd9576_fill_uvd_flags(struct bd957x_regulator_data *data,\n\t\t\t\t  bool warn)\n{\n\tif (warn) {\n\t\tdata->uvd_notif = REGULATOR_EVENT_UNDER_VOLTAGE_WARN;\n\t\tdata->uvd_err = REGULATOR_ERROR_UNDER_VOLTAGE_WARN;\n\t} else {\n\t\tdata->uvd_notif = REGULATOR_EVENT_UNDER_VOLTAGE;\n\t\tdata->uvd_err = REGULATOR_ERROR_UNDER_VOLTAGE;\n\t}\n}\n\nstatic void bd9576_fill_temp_flags(struct bd957x_regulator_data *data,\n\t\t\t\t   bool enable, bool warn)\n{\n\tif (!enable) {\n\t\tdata->temp_notif = 0;\n\t\tdata->temp_err = 0;\n\t} else if (warn) {\n\t\tdata->temp_notif = REGULATOR_EVENT_OVER_TEMP_WARN;\n\t\tdata->temp_err = REGULATOR_ERROR_OVER_TEMP_WARN;\n\t} else {\n\t\tdata->temp_notif = REGULATOR_EVENT_OVER_TEMP;\n\t\tdata->temp_err = REGULATOR_ERROR_OVER_TEMP;\n\t}\n}\n\nstatic int bd9576_set_limit(const struct linear_range *r, int num_ranges,\n\t\t\t    struct regmap *regmap, int reg, int mask, int lim)\n{\n\tint ret;\n\tbool found;\n\tint sel = 0;\n\n\tif (lim) {\n\n\t\tret = linear_range_get_selector_low_array(r, num_ranges,\n\t\t\t\t\t\t\t  lim, &sel, &found);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!found)\n\t\t\tdev_warn(regmap_get_device(regmap),\n\t\t\t\t \"limit %d out of range. Setting lower\\n\",\n\t\t\t\t lim);\n\t}\n\n\treturn regmap_update_bits(regmap, reg, mask, sel);\n}\n\nstatic bool check_ocp_flag_mismatch(struct regulator_dev *rdev, int severity,\n\t\t\t\t    struct bd957x_regulator_data *r)\n{\n\tif ((severity == REGULATOR_SEVERITY_ERR &&\n\t    r->uvd_notif != REGULATOR_EVENT_OVER_CURRENT) ||\n\t    (severity == REGULATOR_SEVERITY_WARN &&\n\t    r->uvd_notif != REGULATOR_EVENT_OVER_CURRENT_WARN)) {\n\t\tdev_warn(rdev_get_dev(rdev),\n\t\t\t \"Can't support both OCP WARN and ERR\\n\");\n\t\t \n\t\tif (severity == REGULATOR_SEVERITY_WARN)\n\t\t\treturn true;\n\n\t\tbd9576_fill_ocp_flags(r, 0);\n\t}\n\n\treturn false;\n}\n\nstatic bool check_uvd_flag_mismatch(struct regulator_dev *rdev, int severity,\n\t\t\t\t    struct bd957x_regulator_data *r)\n{\n\tif ((severity == REGULATOR_SEVERITY_ERR &&\n\t     r->uvd_notif != REGULATOR_EVENT_UNDER_VOLTAGE) ||\n\t     (severity == REGULATOR_SEVERITY_WARN &&\n\t     r->uvd_notif != REGULATOR_EVENT_UNDER_VOLTAGE_WARN)) {\n\t\tdev_warn(rdev_get_dev(rdev),\n\t\t\t \"Can't support both UVD WARN and ERR\\n\");\n\t\tif (severity == REGULATOR_SEVERITY_WARN)\n\t\t\treturn true;\n\n\t\tbd9576_fill_uvd_flags(r, 0);\n\t}\n\n\treturn false;\n}\n\nstatic bool check_ovd_flag_mismatch(struct regulator_dev *rdev, int severity,\n\t\t\t\t    struct bd957x_regulator_data *r)\n{\n\tif ((severity == REGULATOR_SEVERITY_ERR &&\n\t     r->ovd_notif != REGULATOR_EVENT_REGULATION_OUT) ||\n\t     (severity == REGULATOR_SEVERITY_WARN &&\n\t     r->ovd_notif != REGULATOR_EVENT_OVER_VOLTAGE_WARN)) {\n\t\tdev_warn(rdev_get_dev(rdev),\n\t\t\t \"Can't support both OVD WARN and ERR\\n\");\n\t\tif (severity == REGULATOR_SEVERITY_WARN)\n\t\t\treturn true;\n\n\t\tbd9576_fill_ovd_flags(r, 0);\n\t}\n\n\treturn false;\n}\n\nstatic bool check_temp_flag_mismatch(struct regulator_dev *rdev, int severity,\n\t\t\t\t    struct bd957x_regulator_data *r)\n{\n\tif ((severity == REGULATOR_SEVERITY_ERR &&\n\t     r->temp_notif != REGULATOR_EVENT_OVER_TEMP) ||\n\t     (severity == REGULATOR_SEVERITY_WARN &&\n\t     r->temp_notif != REGULATOR_EVENT_OVER_TEMP_WARN)) {\n\t\tdev_warn(rdev_get_dev(rdev),\n\t\t\t \"Can't support both thermal WARN and ERR\\n\");\n\t\tif (severity == REGULATOR_SEVERITY_WARN)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int bd9576_set_ocp(struct regulator_dev *rdev, int lim_uA, int severity,\n\t\t\t  bool enable)\n{\n\tstruct bd957x_data *d;\n\tstruct bd957x_regulator_data *r;\n\tint reg, mask;\n\tint Vfet, rfet;\n\tconst struct linear_range *range;\n\tint num_ranges;\n\n\tif ((lim_uA && !enable) || (!lim_uA && enable))\n\t\treturn -EINVAL;\n\n\tr = container_of(rdev->desc, struct bd957x_regulator_data, desc);\n\tif (!r->oc_supported)\n\t\treturn -EINVAL;\n\n\td = rdev_get_drvdata(rdev);\n\n\tif (severity == REGULATOR_SEVERITY_PROT) {\n\t\treg = r->ocp_reg;\n\t\tmask = r->ocp_mask;\n\t\tif (r->ocw_rfet) {\n\t\t\trange = voutS1_ocp_ranges;\n\t\t\tnum_ranges = ARRAY_SIZE(voutS1_ocp_ranges);\n\t\t\trfet = r->ocw_rfet / 1000;\n\t\t} else {\n\t\t\trange = voutS1_ocp_ranges_internal;\n\t\t\tnum_ranges = ARRAY_SIZE(voutS1_ocp_ranges_internal);\n\t\t\t \n\t\t\trfet = 1000;\n\t\t}\n\t} else {\n\t\treg = r->ocw_reg;\n\t\tmask = r->ocw_mask;\n\n\t\tif (r->ocw_rfet) {\n\t\t\trange = voutS1_ocw_ranges;\n\t\t\tnum_ranges = ARRAY_SIZE(voutS1_ocw_ranges);\n\t\t\trfet = r->ocw_rfet / 1000;\n\t\t} else {\n\t\t\trange = voutS1_ocw_ranges_internal;\n\t\t\tnum_ranges = ARRAY_SIZE(voutS1_ocw_ranges_internal);\n\t\t\t \n\t\t\trfet = 1000;\n\t\t}\n\n\t\t \n\t\tif (r->uvd_notif) {\n\t\t\t \n\t\t\tif (check_ocp_flag_mismatch(rdev, severity, r))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tbool warn = severity == REGULATOR_SEVERITY_WARN;\n\n\t\t\tbd9576_fill_ocp_flags(r, warn);\n\t\t}\n\t}\n\n\t \n\tVfet = lim_uA/1000 * rfet;\n\n\treturn bd9576_set_limit(range, num_ranges, d->regmap,\n\t\t\t\treg, mask, Vfet);\n}\n\nstatic int bd9576_set_uvp(struct regulator_dev *rdev, int lim_uV, int severity,\n\t\t\t  bool enable)\n{\n\tstruct bd957x_data *d;\n\tstruct bd957x_regulator_data *r;\n\tint mask, reg;\n\n\tif (severity == REGULATOR_SEVERITY_PROT) {\n\t\tif (!enable || lim_uV)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t \n\tif ((lim_uV && !enable) || (!lim_uV && enable))\n\t\treturn -EINVAL;\n\n\tr = container_of(rdev->desc, struct bd957x_regulator_data, desc);\n\td = rdev_get_drvdata(rdev);\n\n\tmask = r->xvd_mask;\n\treg = r->uvd_reg;\n\t \n\tif (r->uvd_notif) {\n\t\tif (check_uvd_flag_mismatch(rdev, severity, r))\n\t\t\treturn 0;\n\t} else {\n\t\tbd9576_fill_uvd_flags(r, severity == REGULATOR_SEVERITY_WARN);\n\t}\n\n\treturn bd9576_set_limit(r->xvd_ranges, r->num_xvd_ranges, d->regmap,\n\t\t\t\treg, mask, lim_uV);\n}\n\nstatic int bd9576_set_ovp(struct regulator_dev *rdev, int lim_uV, int severity,\n\t\t\t  bool enable)\n{\n\tstruct bd957x_data *d;\n\tstruct bd957x_regulator_data *r;\n\tint mask, reg;\n\n\tif (severity == REGULATOR_SEVERITY_PROT) {\n\t\tif (!enable || lim_uV)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t \n\tif ((lim_uV && !enable) || (!lim_uV && enable))\n\t\treturn -EINVAL;\n\n\tr = container_of(rdev->desc, struct bd957x_regulator_data, desc);\n\td = rdev_get_drvdata(rdev);\n\n\tmask = r->xvd_mask;\n\treg = r->ovd_reg;\n\t \n\tif (r->ovd_notif) {\n\t\tif (check_ovd_flag_mismatch(rdev, severity, r))\n\t\t\treturn 0;\n\t} else {\n\t\tbd9576_fill_ovd_flags(r, severity == REGULATOR_SEVERITY_WARN);\n\t}\n\n\treturn bd9576_set_limit(r->xvd_ranges, r->num_xvd_ranges, d->regmap,\n\t\t\t\treg, mask, lim_uV);\n}\n\n\nstatic int bd9576_set_tw(struct regulator_dev *rdev, int lim, int severity,\n\t\t\t  bool enable)\n{\n\tstruct bd957x_data *d;\n\tstruct bd957x_regulator_data *r;\n\tint i;\n\n\t \n\tif (lim)\n\t\treturn -EINVAL;\n\n\t \n\tif (severity == REGULATOR_SEVERITY_PROT) {\n\t\tif (!enable)\n\t\t\treturn -EINVAL;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tr = container_of(rdev->desc, struct bd957x_regulator_data, desc);\n\td = rdev_get_drvdata(rdev);\n\n\t \n\tif (r->temp_notif)\n\t\tif (check_temp_flag_mismatch(rdev, severity, r))\n\t\t\treturn 0;\n\n\tbd9576_fill_temp_flags(r, enable, severity == REGULATOR_SEVERITY_WARN);\n\n\tif (enable)\n\t\treturn regmap_update_bits(d->regmap, BD957X_REG_INT_THERM_MASK,\n\t\t\t\t\t BD9576_THERM_IRQ_MASK_TW, 0);\n\n\t \n\tfor (i = 0; i < BD9576_NUM_REGULATORS; i++)\n\t\tif (d->regulator_data[i].temp_notif)\n\t\t\treturn 0;\n\n\treturn regmap_update_bits(d->regmap, BD957X_REG_INT_THERM_MASK,\n\t\t\t\t  BD9576_THERM_IRQ_MASK_TW,\n\t\t\t\t  BD9576_THERM_IRQ_MASK_TW);\n}\n\nstatic const struct regulator_ops bd9573_vout34_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = bd957x_vout34_list_voltage,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n};\n\nstatic const struct regulator_ops bd9576_vout34_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = bd957x_vout34_list_voltage,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_over_voltage_protection = bd9576_set_ovp,\n\t.set_under_voltage_protection = bd9576_set_uvp,\n\t.set_thermal_protection = bd9576_set_tw,\n};\n\nstatic const struct regulator_ops bd9573_vouts1_regulator_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n};\n\nstatic const struct regulator_ops bd9576_vouts1_regulator_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.set_over_current_protection = bd9576_set_ocp,\n};\n\nstatic const struct regulator_ops bd9573_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = bd957x_list_voltage,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n};\n\nstatic const struct regulator_ops bd9576_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.list_voltage = bd957x_list_voltage,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_over_voltage_protection = bd9576_set_ovp,\n\t.set_under_voltage_protection = bd9576_set_uvp,\n\t.set_thermal_protection = bd9576_set_tw,\n};\n\nstatic const struct regulator_ops  *bd9573_ops_arr[] = {\n\t[BD957X_VD50]\t= &bd9573_ops,\n\t[BD957X_VD18]\t= &bd9573_ops,\n\t[BD957X_VDDDR]\t= &bd9573_vout34_ops,\n\t[BD957X_VD10]\t= &bd9573_vout34_ops,\n\t[BD957X_VOUTL1]\t= &bd9573_ops,\n\t[BD957X_VOUTS1]\t= &bd9573_vouts1_regulator_ops,\n};\n\nstatic const struct regulator_ops  *bd9576_ops_arr[] = {\n\t[BD957X_VD50]\t= &bd9576_ops,\n\t[BD957X_VD18]\t= &bd9576_ops,\n\t[BD957X_VDDDR]\t= &bd9576_vout34_ops,\n\t[BD957X_VD10]\t= &bd9576_vout34_ops,\n\t[BD957X_VOUTL1]\t= &bd9576_ops,\n\t[BD957X_VOUTS1]\t= &bd9576_vouts1_regulator_ops,\n};\n\nstatic int vouts1_get_fet_res(struct device_node *np,\n\t\t\t\tconst struct regulator_desc *desc,\n\t\t\t\tstruct regulator_config *cfg)\n{\n\tstruct bd957x_regulator_data *data;\n\tint ret;\n\tu32 uohms;\n\n\tdata = container_of(desc, struct bd957x_regulator_data, desc);\n\n\tret = of_property_read_u32(np, \"rohm,ocw-fet-ron-micro-ohms\", &uohms);\n\tif (ret) {\n\t\tif (ret != -EINVAL)\n\t\t\treturn ret;\n\n\t\treturn 0;\n\t}\n\tdata->ocw_rfet = uohms;\n\treturn 0;\n}\n\nstatic struct bd957x_data bd957x_regulators = {\n\t.regulator_data = {\n\t\t{\n\t\t\t.desc = {\n\t\t\t\t.name = \"VD50\",\n\t\t\t\t.of_match = of_match_ptr(\"regulator-vd50\"),\n\t\t\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t\t\t.id = BD957X_VD50,\n\t\t\t\t.type = REGULATOR_VOLTAGE,\n\t\t\t\t.volt_table = &vout1_volt_table[0],\n\t\t\t\t.n_voltages = ARRAY_SIZE(vout1_volt_table),\n\t\t\t\t.vsel_reg = BD957X_REG_VOUT1_TUNE,\n\t\t\t\t.vsel_mask = BD957X_MASK_VOUT1_TUNE,\n\t\t\t\t.enable_reg = BD957X_REG_POW_TRIGGER1,\n\t\t\t\t.enable_mask = BD957X_REGULATOR_EN_MASK,\n\t\t\t\t.enable_val = BD957X_REGULATOR_DIS_VAL,\n\t\t\t\t.enable_is_inverted = true,\n\t\t\t\t.owner = THIS_MODULE,\n\t\t\t},\n\t\t\t.xvd_ranges = vout1_xvd_ranges,\n\t\t\t.num_xvd_ranges = ARRAY_SIZE(vout1_xvd_ranges),\n\t\t\t.ovd_reg = BD9576_REG_VOUT1_OVD,\n\t\t\t.uvd_reg = BD9576_REG_VOUT1_UVD,\n\t\t\t.xvd_mask = BD9576_MASK_XVD,\n\t\t},\n\t\t{\n\t\t\t.desc = {\n\t\t\t\t.name = \"VD18\",\n\t\t\t\t.of_match = of_match_ptr(\"regulator-vd18\"),\n\t\t\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t\t\t.id = BD957X_VD18,\n\t\t\t\t.type = REGULATOR_VOLTAGE,\n\t\t\t\t.volt_table = &vout2_volt_table[0],\n\t\t\t\t.n_voltages = ARRAY_SIZE(vout2_volt_table),\n\t\t\t\t.vsel_reg = BD957X_REG_VOUT2_TUNE,\n\t\t\t\t.vsel_mask = BD957X_MASK_VOUT2_TUNE,\n\t\t\t\t.enable_reg = BD957X_REG_POW_TRIGGER2,\n\t\t\t\t.enable_mask = BD957X_REGULATOR_EN_MASK,\n\t\t\t\t.enable_val = BD957X_REGULATOR_DIS_VAL,\n\t\t\t\t.enable_is_inverted = true,\n\t\t\t\t.owner = THIS_MODULE,\n\t\t\t},\n\t\t\t.xvd_ranges = vout234_xvd_ranges,\n\t\t\t.num_xvd_ranges = ARRAY_SIZE(vout234_xvd_ranges),\n\t\t\t.ovd_reg = BD9576_REG_VOUT2_OVD,\n\t\t\t.uvd_reg = BD9576_REG_VOUT2_UVD,\n\t\t\t.xvd_mask = BD9576_MASK_XVD,\n\t\t},\n\t\t{\n\t\t\t.desc = {\n\t\t\t\t.name = \"VDDDR\",\n\t\t\t\t.of_match = of_match_ptr(\"regulator-vdddr\"),\n\t\t\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t\t\t.id = BD957X_VDDDR,\n\t\t\t\t.type = REGULATOR_VOLTAGE,\n\t\t\t\t.n_voltages = BD957X_VOUTS34_NUM_VOLT,\n\t\t\t\t.vsel_reg = BD957X_REG_VOUT3_TUNE,\n\t\t\t\t.vsel_mask = BD957X_MASK_VOUT3_TUNE,\n\t\t\t\t.enable_reg = BD957X_REG_POW_TRIGGER3,\n\t\t\t\t.enable_mask = BD957X_REGULATOR_EN_MASK,\n\t\t\t\t.enable_val = BD957X_REGULATOR_DIS_VAL,\n\t\t\t\t.enable_is_inverted = true,\n\t\t\t\t.owner = THIS_MODULE,\n\t\t\t},\n\t\t\t.ovd_reg = BD9576_REG_VOUT3_OVD,\n\t\t\t.uvd_reg = BD9576_REG_VOUT3_UVD,\n\t\t\t.xvd_mask = BD9576_MASK_XVD,\n\t\t\t.xvd_ranges = vout234_xvd_ranges,\n\t\t\t.num_xvd_ranges = ARRAY_SIZE(vout234_xvd_ranges),\n\t\t},\n\t\t{\n\t\t\t.desc = {\n\t\t\t\t.name = \"VD10\",\n\t\t\t\t.of_match = of_match_ptr(\"regulator-vd10\"),\n\t\t\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t\t\t.id = BD957X_VD10,\n\t\t\t\t.type = REGULATOR_VOLTAGE,\n\t\t\t\t.fixed_uV = BD957X_VOUTS4_BASE_VOLT,\n\t\t\t\t.n_voltages = BD957X_VOUTS34_NUM_VOLT,\n\t\t\t\t.vsel_reg = BD957X_REG_VOUT4_TUNE,\n\t\t\t\t.vsel_mask = BD957X_MASK_VOUT4_TUNE,\n\t\t\t\t.enable_reg = BD957X_REG_POW_TRIGGER4,\n\t\t\t\t.enable_mask = BD957X_REGULATOR_EN_MASK,\n\t\t\t\t.enable_val = BD957X_REGULATOR_DIS_VAL,\n\t\t\t\t.enable_is_inverted = true,\n\t\t\t\t.owner = THIS_MODULE,\n\t\t\t},\n\t\t\t.xvd_ranges = vout234_xvd_ranges,\n\t\t\t.num_xvd_ranges = ARRAY_SIZE(vout234_xvd_ranges),\n\t\t\t.ovd_reg = BD9576_REG_VOUT4_OVD,\n\t\t\t.uvd_reg = BD9576_REG_VOUT4_UVD,\n\t\t\t.xvd_mask = BD9576_MASK_XVD,\n\t\t},\n\t\t{\n\t\t\t.desc = {\n\t\t\t\t.name = \"VOUTL1\",\n\t\t\t\t.of_match = of_match_ptr(\"regulator-voutl1\"),\n\t\t\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t\t\t.id = BD957X_VOUTL1,\n\t\t\t\t.type = REGULATOR_VOLTAGE,\n\t\t\t\t.volt_table = &voutl1_volt_table[0],\n\t\t\t\t.n_voltages = ARRAY_SIZE(voutl1_volt_table),\n\t\t\t\t.vsel_reg = BD957X_REG_VOUTL1_TUNE,\n\t\t\t\t.vsel_mask = BD957X_MASK_VOUTL1_TUNE,\n\t\t\t\t.enable_reg = BD957X_REG_POW_TRIGGERL1,\n\t\t\t\t.enable_mask = BD957X_REGULATOR_EN_MASK,\n\t\t\t\t.enable_val = BD957X_REGULATOR_DIS_VAL,\n\t\t\t\t.enable_is_inverted = true,\n\t\t\t\t.owner = THIS_MODULE,\n\t\t\t},\n\t\t\t.xvd_ranges = voutL1_xvd_ranges,\n\t\t\t.num_xvd_ranges = ARRAY_SIZE(voutL1_xvd_ranges),\n\t\t\t.ovd_reg = BD9576_REG_VOUTL1_OVD,\n\t\t\t.uvd_reg = BD9576_REG_VOUTL1_UVD,\n\t\t\t.xvd_mask = BD9576_MASK_XVD,\n\t\t},\n\t\t{\n\t\t\t.desc = {\n\t\t\t\t.name = \"VOUTS1\",\n\t\t\t\t.of_match = of_match_ptr(\"regulator-vouts1\"),\n\t\t\t\t.regulators_node = of_match_ptr(\"regulators\"),\n\t\t\t\t.id = BD957X_VOUTS1,\n\t\t\t\t.type = REGULATOR_VOLTAGE,\n\t\t\t\t.n_voltages = 1,\n\t\t\t\t.fixed_uV = BD957X_VOUTS1_VOLT,\n\t\t\t\t.enable_reg = BD957X_REG_POW_TRIGGERS1,\n\t\t\t\t.enable_mask = BD957X_REGULATOR_EN_MASK,\n\t\t\t\t.enable_val = BD957X_REGULATOR_DIS_VAL,\n\t\t\t\t.enable_is_inverted = true,\n\t\t\t\t.owner = THIS_MODULE,\n\t\t\t\t.of_parse_cb = vouts1_get_fet_res,\n\t\t\t},\n\t\t\t.oc_supported = true,\n\t\t\t.ocw_reg = BD9576_REG_VOUT1S_OCW,\n\t\t\t.ocw_mask = BD9576_MASK_VOUT1S_OCW,\n\t\t\t.ocp_reg = BD9576_REG_VOUT1S_OCP,\n\t\t\t.ocp_mask = BD9576_MASK_VOUT1S_OCP,\n\t\t},\n\t},\n};\n\nstatic int bd9576_renable(struct regulator_irq_data *rid, int reg, int mask)\n{\n\tint val, ret;\n\tstruct bd957x_data *d = (struct bd957x_data *)rid->data;\n\n\tret = regmap_read(d->regmap, reg, &val);\n\tif (ret)\n\t\treturn REGULATOR_FAILED_RETRY;\n\n\tif (rid->opaque && rid->opaque == (val & mask)) {\n\t\t \n\t\tregmap_write(d->regmap, reg, mask & val);\n\t\treturn REGULATOR_ERROR_ON;\n\t}\n\trid->opaque = 0;\n\t \n\treturn REGULATOR_ERROR_CLEARED;\n}\n\nstatic int bd9576_uvd_renable(struct regulator_irq_data *rid)\n{\n\treturn bd9576_renable(rid, BD957X_REG_INT_UVD_STAT, UVD_IRQ_VALID_MASK);\n}\n\nstatic int bd9576_ovd_renable(struct regulator_irq_data *rid)\n{\n\treturn bd9576_renable(rid, BD957X_REG_INT_OVD_STAT, OVD_IRQ_VALID_MASK);\n}\n\nstatic int bd9576_temp_renable(struct regulator_irq_data *rid)\n{\n\treturn bd9576_renable(rid, BD957X_REG_INT_THERM_STAT,\n\t\t\t      BD9576_THERM_IRQ_MASK_TW);\n}\n\nstatic int bd9576_uvd_handler(int irq, struct regulator_irq_data *rid,\n\t\t\t      unsigned long *dev_mask)\n{\n\tint val, ret, i;\n\tstruct bd957x_data *d = (struct bd957x_data *)rid->data;\n\n\tret = regmap_read(d->regmap, BD957X_REG_INT_UVD_STAT, &val);\n\tif (ret)\n\t\treturn REGULATOR_FAILED_RETRY;\n\n\t*dev_mask = 0;\n\n\trid->opaque = val & UVD_IRQ_VALID_MASK;\n\n\t \n\t*dev_mask = val & BD9576_xVD_IRQ_MASK_VOUT1TO4;\n\t \n\t*dev_mask |= ((val & BD9576_xVD_IRQ_MASK_VOUTL1) >> 1);\n\t \n\t*dev_mask |= ((val & BD9576_UVD_IRQ_MASK_VOUTS1_OCW) >> 1);\n\n\tfor_each_set_bit(i, dev_mask, 6) {\n\t\tstruct bd957x_regulator_data *rdata;\n\t\tstruct regulator_err_state *stat;\n\n\t\trdata = &d->regulator_data[i];\n\t\tstat  = &rid->states[i];\n\n\t\tstat->notifs\t= rdata->uvd_notif;\n\t\tstat->errors\t= rdata->uvd_err;\n\t}\n\n\tret = regmap_write(d->regmap, BD957X_REG_INT_UVD_STAT,\n\t\t\t   UVD_IRQ_VALID_MASK & val);\n\n\treturn 0;\n}\n\nstatic int bd9576_ovd_handler(int irq, struct regulator_irq_data *rid,\n\t\t\t      unsigned long *dev_mask)\n{\n\tint val, ret, i;\n\tstruct bd957x_data *d = (struct bd957x_data *)rid->data;\n\n\tret = regmap_read(d->regmap, BD957X_REG_INT_OVD_STAT, &val);\n\tif (ret)\n\t\treturn REGULATOR_FAILED_RETRY;\n\n\trid->opaque = val & OVD_IRQ_VALID_MASK;\n\t*dev_mask = 0;\n\n\tif (!(val & OVD_IRQ_VALID_MASK))\n\t\treturn 0;\n\n\t*dev_mask = val & BD9576_xVD_IRQ_MASK_VOUT1TO4;\n\t \n\t*dev_mask |= ((val & BD9576_xVD_IRQ_MASK_VOUTL1) >> 1);\n\n\tfor_each_set_bit(i, dev_mask, 5) {\n\t\tstruct bd957x_regulator_data *rdata;\n\t\tstruct regulator_err_state *stat;\n\n\t\trdata = &d->regulator_data[i];\n\t\tstat  = &rid->states[i];\n\n\t\tstat->notifs\t= rdata->ovd_notif;\n\t\tstat->errors\t= rdata->ovd_err;\n\t}\n\n\t \n\tregmap_write(d->regmap, BD957X_REG_INT_OVD_STAT,\n\t\t     OVD_IRQ_VALID_MASK & val);\n\n\treturn 0;\n}\n\n#define BD9576_DEV_MASK_ALL_REGULATORS 0x3F\n\nstatic int bd9576_thermal_handler(int irq, struct regulator_irq_data *rid,\n\t\t\t\t  unsigned long *dev_mask)\n{\n\tint val, ret, i;\n\tstruct bd957x_data *d = (struct bd957x_data *)rid->data;\n\n\tret = regmap_read(d->regmap, BD957X_REG_INT_THERM_STAT, &val);\n\tif (ret)\n\t\treturn REGULATOR_FAILED_RETRY;\n\n\tif (!(val & BD9576_THERM_IRQ_MASK_TW)) {\n\t\t*dev_mask = 0;\n\t\treturn 0;\n\t}\n\n\t*dev_mask = BD9576_DEV_MASK_ALL_REGULATORS;\n\n\tfor (i = 0; i < BD9576_NUM_REGULATORS; i++) {\n\t\tstruct bd957x_regulator_data *rdata;\n\t\tstruct regulator_err_state *stat;\n\n\t\trdata = &d->regulator_data[i];\n\t\tstat  = &rid->states[i];\n\n\t\tstat->notifs\t= rdata->temp_notif;\n\t\tstat->errors\t= rdata->temp_err;\n\t}\n\n\t \n\tregmap_write(d->regmap, BD957X_REG_INT_THERM_STAT,\n\t\t     BD9576_THERM_IRQ_MASK_TW);\n\n\treturn 0;\n}\n\nstatic int bd957x_probe(struct platform_device *pdev)\n{\n\tint i;\n\tunsigned int num_reg_data;\n\tbool vout_mode, ddr_sel, may_have_irqs = false;\n\tstruct regmap *regmap;\n\tstruct bd957x_data *ic_data;\n\tstruct regulator_config config = { 0 };\n\t \n\tstruct regulator_dev *rdevs[BD9576_NUM_REGULATORS];\n\t \n\tstruct regulator_dev *ovd_devs[BD9576_NUM_OVD_REGULATORS];\n\tstatic const struct regulator_irq_desc bd9576_notif_uvd = {\n\t\t.name = \"bd9576-uvd\",\n\t\t.irq_off_ms = 1000,\n\t\t.map_event = bd9576_uvd_handler,\n\t\t.renable = bd9576_uvd_renable,\n\t\t.data = &bd957x_regulators,\n\t};\n\tstatic const struct regulator_irq_desc bd9576_notif_ovd = {\n\t\t.name = \"bd9576-ovd\",\n\t\t.irq_off_ms = 1000,\n\t\t.map_event = bd9576_ovd_handler,\n\t\t.renable = bd9576_ovd_renable,\n\t\t.data = &bd957x_regulators,\n\t};\n\tstatic const struct regulator_irq_desc bd9576_notif_temp = {\n\t\t.name = \"bd9576-temp\",\n\t\t.irq_off_ms = 1000,\n\t\t.map_event = bd9576_thermal_handler,\n\t\t.renable = bd9576_temp_renable,\n\t\t.data = &bd957x_regulators,\n\t};\n\tenum rohm_chip_type chip = platform_get_device_id(pdev)->driver_data;\n\n\tnum_reg_data = ARRAY_SIZE(bd957x_regulators.regulator_data);\n\n\tic_data = &bd957x_regulators;\n\n\tregmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!regmap) {\n\t\tdev_err(&pdev->dev, \"No regmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tic_data->regmap = regmap;\n\tvout_mode = device_property_read_bool(pdev->dev.parent,\n\t\t\t\t\t      \"rohm,vout1-en-low\");\n\tif (vout_mode) {\n\t\tstruct gpio_desc *en;\n\n\t\tdev_dbg(&pdev->dev, \"GPIO controlled mode\\n\");\n\n\t\t \n\t\t \n\t\ten = devm_fwnode_gpiod_get(&pdev->dev,\n\t\t\t\t\t   dev_fwnode(pdev->dev.parent),\n\t\t\t\t\t   \"rohm,vout1-en\", GPIOD_OUT_LOW,\n\t\t\t\t\t   \"vout1-en\");\n\n\t\t \n\t\t \n\t\tif (!IS_ERR(en))\n\t\t\tconfig.ena_gpiod = en;\n\t\telse\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(en),\n\t\t\t\t\t\"Failed to get VOUT1 control GPIO\\n\");\n\t}\n\n\t \n\tplatform_set_drvdata(pdev, ic_data);\n\tddr_sel = device_property_read_bool(pdev->dev.parent,\n\t\t\t\t\t    \"rohm,ddr-sel-low\");\n\tif (ddr_sel)\n\t\tic_data->regulator_data[2].desc.fixed_uV = 1350000;\n\telse\n\t\tic_data->regulator_data[2].desc.fixed_uV = 1500000;\n\n\tswitch (chip) {\n\tcase ROHM_CHIP_TYPE_BD9576:\n\t\tmay_have_irqs = true;\n\t\tdev_dbg(&pdev->dev, \"Found BD9576MUF\\n\");\n\t\tbreak;\n\tcase ROHM_CHIP_TYPE_BD9573:\n\t\tdev_dbg(&pdev->dev, \"Found BD9573MUF\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unsupported chip type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_reg_data; i++) {\n\t\tstruct regulator_desc *d;\n\n\t\td = &ic_data->regulator_data[i].desc;\n\n\n\t\tif (may_have_irqs) {\n\t\t\tif (d->id >= ARRAY_SIZE(bd9576_ops_arr))\n\t\t\t\treturn -EINVAL;\n\n\t\t\td->ops = bd9576_ops_arr[d->id];\n\t\t} else {\n\t\t\tif (d->id >= ARRAY_SIZE(bd9573_ops_arr))\n\t\t\t\treturn -EINVAL;\n\n\t\t\td->ops = bd9573_ops_arr[d->id];\n\t\t}\n\t}\n\n\tconfig.dev = pdev->dev.parent;\n\tconfig.regmap = regmap;\n\tconfig.driver_data = ic_data;\n\n\tfor (i = 0; i < num_reg_data; i++) {\n\n\t\tstruct bd957x_regulator_data *r = &ic_data->regulator_data[i];\n\t\tconst struct regulator_desc *desc = &r->desc;\n\n\t\tr->rdev = devm_regulator_register(&pdev->dev, desc,\n\t\t\t\t\t\t\t   &config);\n\t\tif (IS_ERR(r->rdev))\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(r->rdev),\n\t\t\t\t\t\"failed to register %s regulator\\n\",\n\t\t\t\t\tdesc->name);\n\t\t \n\t\tconfig.ena_gpiod = NULL;\n\n\t\tif (!may_have_irqs)\n\t\t\tcontinue;\n\n\t\trdevs[i] = r->rdev;\n\t\tif (i < BD957X_VOUTS1)\n\t\t\tovd_devs[i] = r->rdev;\n\t}\n\tif (may_have_irqs) {\n\t\tvoid *ret;\n\t\t \n\t\tint uvd_errs = REGULATOR_ERROR_UNDER_VOLTAGE |\n\t\t\t       REGULATOR_ERROR_UNDER_VOLTAGE_WARN |\n\t\t\t       REGULATOR_ERROR_OVER_CURRENT |\n\t\t\t       REGULATOR_ERROR_OVER_CURRENT_WARN;\n\t\tint ovd_errs = REGULATOR_ERROR_OVER_VOLTAGE_WARN |\n\t\t\t       REGULATOR_ERROR_REGULATION_OUT;\n\t\tint temp_errs = REGULATOR_ERROR_OVER_TEMP |\n\t\t\t\tREGULATOR_ERROR_OVER_TEMP_WARN;\n\t\tint irq;\n\n\t\tirq = platform_get_irq_byname(pdev, \"bd9576-uvd\");\n\n\t\t \n\t\tret = devm_regulator_irq_helper(&pdev->dev, &bd9576_notif_uvd,\n\t\t\t\t\t\tirq, 0, uvd_errs, NULL,\n\t\t\t\t\t\t&rdevs[0],\n\t\t\t\t\t\tBD9576_NUM_REGULATORS);\n\t\tif (IS_ERR(ret)) {\n\t\t\tif (PTR_ERR(ret) == -EPROBE_DEFER)\n\t\t\t\treturn -EPROBE_DEFER;\n\n\t\t\tdev_warn(&pdev->dev, \"UVD disabled %pe\\n\", ret);\n\t\t}\n\n\t\tirq = platform_get_irq_byname(pdev, \"bd9576-ovd\");\n\n\t\tret = devm_regulator_irq_helper(&pdev->dev, &bd9576_notif_ovd,\n\t\t\t\t\t\tirq, 0, ovd_errs, NULL,\n\t\t\t\t\t\t&ovd_devs[0],\n\t\t\t\t\t\tBD9576_NUM_OVD_REGULATORS);\n\t\tif (IS_ERR(ret)) {\n\t\t\tif (PTR_ERR(ret) == -EPROBE_DEFER)\n\t\t\t\treturn -EPROBE_DEFER;\n\n\t\t\tdev_warn(&pdev->dev, \"OVD disabled %pe\\n\", ret);\n\t\t}\n\t\tirq = platform_get_irq_byname(pdev, \"bd9576-temp\");\n\n\t\tret = devm_regulator_irq_helper(&pdev->dev, &bd9576_notif_temp,\n\t\t\t\t\t\tirq, 0, temp_errs, NULL,\n\t\t\t\t\t\t&rdevs[0],\n\t\t\t\t\t\tBD9576_NUM_REGULATORS);\n\t\tif (IS_ERR(ret)) {\n\t\t\tif (PTR_ERR(ret) == -EPROBE_DEFER)\n\t\t\t\treturn -EPROBE_DEFER;\n\n\t\t\tdev_warn(&pdev->dev, \"Thermal warning disabled %pe\\n\",\n\t\t\t\t ret);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct platform_device_id bd957x_pmic_id[] = {\n\t{ \"bd9573-regulator\", ROHM_CHIP_TYPE_BD9573 },\n\t{ \"bd9576-regulator\", ROHM_CHIP_TYPE_BD9576 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(platform, bd957x_pmic_id);\n\nstatic struct platform_driver bd957x_regulator = {\n\t.driver = {\n\t\t.name = \"bd957x-pmic\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = bd957x_probe,\n\t.id_table = bd957x_pmic_id,\n};\n\nmodule_platform_driver(bd957x_regulator);\n\nMODULE_AUTHOR(\"Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>\");\nMODULE_DESCRIPTION(\"ROHM BD9576/BD9573 voltage regulator driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:bd957x-pmic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}