{
  "module_name": "da9063-regulator.c",
  "hash_id": "cf25dd425371bb7bcaca7f4abfa351a4e4a22f576628358fdadd25284ffccdcb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/da9063-regulator.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/mfd/da9063/core.h>\n#include <linux/mfd/da9063/registers.h>\n\n\n \n#define BFIELD(_reg, _mask) \\\n\tREG_FIELD(_reg, __builtin_ffs((int)_mask) - 1, \\\n\t\tsizeof(unsigned int) * 8 - __builtin_clz((_mask)) - 1)\n\n \nenum {\n\t \n\tDA9063_ID_BCORE1,\n\tDA9063_ID_BCORE2,\n\tDA9063_ID_BPRO,\n\tDA9063_ID_BMEM,\n\tDA9063_ID_BIO,\n\tDA9063_ID_BPERI,\n\n\t \n\tDA9063_ID_BCORES_MERGED,\n\t \n\tDA9063_ID_BMEM_BIO_MERGED,\n\t \n\n\t \n\tDA9063_ID_LDO3,\n\tDA9063_ID_LDO7,\n\tDA9063_ID_LDO8,\n\tDA9063_ID_LDO9,\n\tDA9063_ID_LDO11,\n\n\t \n\tDA9063_ID_LDO1,\n\tDA9063_ID_LDO2,\n\tDA9063_ID_LDO4,\n\tDA9063_ID_LDO5,\n\tDA9063_ID_LDO6,\n\tDA9063_ID_LDO10,\n};\n\n \nstruct da9063_regulator_data {\n\tint\t\t\t\tid;\n\tstruct regulator_init_data\t*initdata;\n};\n\nstruct da9063_regulators_pdata {\n\tunsigned int\t\t\tn_regulators;\n\tstruct da9063_regulator_data\t*regulator_data;\n};\n\n \nstruct da9063_regulator_info {\n\tstruct regulator_desc desc;\n\n\t \n\tstruct reg_field mode;\t\t \n\tstruct reg_field suspend;\n\tstruct reg_field sleep;\n\tstruct reg_field suspend_sleep;\n\tunsigned int suspend_vsel_reg;\n\n\t \n\tstruct reg_field oc_event;\n\n\t \n\tstruct reg_field vmon;\n};\n\n \n#define DA9063_LDO(chip, regl_name, min_mV, step_mV, max_mV) \\\n\t.desc.id = chip##_ID_##regl_name, \\\n\t.desc.name = __stringify(chip##_##regl_name), \\\n\t.desc.ops = &da9063_ldo_ops, \\\n\t.desc.min_uV = (min_mV) * 1000, \\\n\t.desc.uV_step = (step_mV) * 1000, \\\n\t.desc.n_voltages = (((max_mV) - (min_mV))/(step_mV) + 1 \\\n\t\t+ (DA9063_V##regl_name##_BIAS)), \\\n\t.desc.enable_reg = DA9063_REG_##regl_name##_CONT, \\\n\t.desc.enable_mask = DA9063_LDO_EN, \\\n\t.desc.vsel_reg = DA9063_REG_V##regl_name##_A, \\\n\t.desc.vsel_mask = DA9063_V##regl_name##_MASK, \\\n\t.desc.linear_min_sel = DA9063_V##regl_name##_BIAS, \\\n\t.sleep = BFIELD(DA9063_REG_V##regl_name##_A, DA9063_LDO_SL), \\\n\t.suspend = BFIELD(DA9063_REG_##regl_name##_CONT, DA9063_LDO_CONF), \\\n\t.suspend_sleep = BFIELD(DA9063_REG_V##regl_name##_B, DA9063_LDO_SL), \\\n\t.suspend_vsel_reg = DA9063_REG_V##regl_name##_B\n\n \n#define DA9063_BUCK(chip, regl_name, min_mV, step_mV, max_mV, limits_array, \\\n\t\t    creg, cmask) \\\n\t.desc.id = chip##_ID_##regl_name, \\\n\t.desc.name = __stringify(chip##_##regl_name), \\\n\t.desc.ops = &da9063_buck_ops, \\\n\t.desc.min_uV = (min_mV) * 1000, \\\n\t.desc.uV_step = (step_mV) * 1000, \\\n\t.desc.n_voltages = ((max_mV) - (min_mV))/(step_mV) + 1, \\\n\t.desc.csel_reg = (creg), \\\n\t.desc.csel_mask = (cmask), \\\n\t.desc.curr_table = limits_array, \\\n\t.desc.n_current_limits = ARRAY_SIZE(limits_array)\n\n#define DA9063_BUCK_COMMON_FIELDS(regl_name) \\\n\t.desc.enable_reg = DA9063_REG_##regl_name##_CONT, \\\n\t.desc.enable_mask = DA9063_BUCK_EN, \\\n\t.desc.vsel_reg = DA9063_REG_V##regl_name##_A, \\\n\t.desc.vsel_mask = DA9063_VBUCK_MASK, \\\n\t.desc.linear_min_sel = DA9063_VBUCK_BIAS, \\\n\t.sleep = BFIELD(DA9063_REG_V##regl_name##_A, DA9063_BUCK_SL), \\\n\t.suspend = BFIELD(DA9063_REG_##regl_name##_CONT, DA9063_BUCK_CONF), \\\n\t.suspend_sleep = BFIELD(DA9063_REG_V##regl_name##_B, DA9063_BUCK_SL), \\\n\t.suspend_vsel_reg = DA9063_REG_V##regl_name##_B, \\\n\t.mode = BFIELD(DA9063_REG_##regl_name##_CFG, DA9063_BUCK_MODE_MASK)\n\n \nstruct da9063_dev_model {\n\tconst struct da9063_regulator_info\t*regulator_info;\n\tunsigned int\t\t\t\tn_regulators;\n\tenum da9063_type\t\t\ttype;\n};\n\n \nstruct da9063_regulator {\n\tstruct regulator_desc\t\t\tdesc;\n\tstruct regulator_dev\t\t\t*rdev;\n\tstruct da9063\t\t\t\t*hw;\n\tconst struct da9063_regulator_info\t*info;\n\n\tstruct regmap_field\t\t\t*mode;\n\tstruct regmap_field\t\t\t*suspend;\n\tstruct regmap_field\t\t\t*sleep;\n\tstruct regmap_field\t\t\t*suspend_sleep;\n\tstruct regmap_field\t\t\t*vmon;\n};\n\n \nstruct da9063_regulators {\n\tunsigned int\t\t\t\tn_regulators;\n\t \n\tstruct da9063_regulator\t\t\tregulator[];\n};\n\n \nenum {\n\tBUCK_MODE_MANUAL,\t \n\tBUCK_MODE_SLEEP,\t \n\tBUCK_MODE_SYNC,\t\t \n\tBUCK_MODE_AUTO\t\t \n};\n\n \n\n \nstatic const unsigned int da9063_buck_a_limits[] = {\n\t 500000,  600000,  700000,  800000,  900000, 1000000, 1100000, 1200000,\n\t1300000, 1400000, 1500000, 1600000, 1700000, 1800000, 1900000, 2000000\n};\n\n \nstatic const unsigned int da9063_buck_b_limits[] = {\n\t1500000, 1600000, 1700000, 1800000, 1900000, 2000000, 2100000, 2200000,\n\t2300000, 2400000, 2500000, 2600000, 2700000, 2800000, 2900000, 3000000\n};\n\n \nstatic const unsigned int da9063_bcores_merged_limits[] = {\n\t1000000, 1200000, 1400000, 1600000, 1800000, 2000000, 2200000, 2400000,\n\t2600000, 2800000, 3000000, 3200000, 3400000, 3600000, 3800000, 4000000\n};\n\n \nstatic const unsigned int da9063_bmem_bio_merged_limits[] = {\n\t3000000, 3200000, 3400000, 3600000, 3800000, 4000000, 4200000, 4400000,\n\t4600000, 4800000, 5000000, 5200000, 5400000, 5600000, 5800000, 6000000\n};\n\nstatic int da9063_set_xvp(struct regulator_dev *rdev, int lim_uV, int severity, bool enable)\n{\n\tstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\n\tstruct device *dev = regl->hw->dev;\n\n\tdev_dbg(dev, \"%s: lim: %d, sev: %d, en: %d\\n\", regl->desc.name, lim_uV, severity, enable);\n\n\t \n\tif (lim_uV)\n\t\treturn -EINVAL;\n\n\treturn regmap_field_write(regl->vmon, enable ? 1 : 0);\n}\n\nstatic int da9063_buck_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\n\tunsigned int val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tval = BUCK_MODE_SYNC;\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = BUCK_MODE_AUTO;\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tval = BUCK_MODE_SLEEP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_field_write(regl->mode, val);\n}\n\n \n\nstatic unsigned int da9063_buck_get_mode(struct regulator_dev *rdev)\n{\n\tstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_field_read(regl->mode, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (val) {\n\tdefault:\n\tcase BUCK_MODE_MANUAL:\n\t\t \n\t\tbreak;\n\tcase BUCK_MODE_SLEEP:\n\t\treturn REGULATOR_MODE_STANDBY;\n\tcase BUCK_MODE_SYNC:\n\t\treturn REGULATOR_MODE_FAST;\n\tcase BUCK_MODE_AUTO:\n\t\treturn REGULATOR_MODE_NORMAL;\n\t}\n\n\tret = regmap_field_read(regl->sleep, &val);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (val)\n\t\treturn REGULATOR_MODE_STANDBY;\n\telse\n\t\treturn REGULATOR_MODE_FAST;\n}\n\n \n\nstatic int da9063_ldo_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\n\tunsigned int val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = 0;\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tval = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_field_write(regl->sleep, val);\n}\n\nstatic unsigned int da9063_ldo_get_mode(struct regulator_dev *rdev)\n{\n\tstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\n\tint ret, val;\n\n\tret = regmap_field_read(regl->sleep, &val);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (val)\n\t\treturn REGULATOR_MODE_STANDBY;\n\telse\n\t\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int da9063_buck_get_status(struct regulator_dev *rdev)\n{\n\tint ret = regulator_is_enabled_regmap(rdev);\n\n\tif (ret == 0) {\n\t\tret = REGULATOR_STATUS_OFF;\n\t} else if (ret > 0) {\n\t\tret = da9063_buck_get_mode(rdev);\n\t\tif (ret > 0)\n\t\t\tret = regulator_mode_to_status(ret);\n\t\telse if (ret == 0)\n\t\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int da9063_ldo_get_status(struct regulator_dev *rdev)\n{\n\tint ret = regulator_is_enabled_regmap(rdev);\n\n\tif (ret == 0) {\n\t\tret = REGULATOR_STATUS_OFF;\n\t} else if (ret > 0) {\n\t\tret = da9063_ldo_get_mode(rdev);\n\t\tif (ret > 0)\n\t\t\tret = regulator_mode_to_status(ret);\n\t\telse if (ret == 0)\n\t\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int da9063_set_suspend_voltage(struct regulator_dev *rdev, int uV)\n{\n\tstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\n\tconst struct da9063_regulator_info *rinfo = regl->info;\n\tint ret, sel;\n\n\tsel = regulator_map_voltage_linear(rdev, uV, uV);\n\tif (sel < 0)\n\t\treturn sel;\n\n\tsel <<= ffs(rdev->desc->vsel_mask) - 1;\n\n\tret = regmap_update_bits(regl->hw->regmap, rinfo->suspend_vsel_reg,\n\t\t\t\t rdev->desc->vsel_mask, sel);\n\n\treturn ret;\n}\n\nstatic int da9063_suspend_enable(struct regulator_dev *rdev)\n{\n\tstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\n\n\treturn regmap_field_write(regl->suspend, 1);\n}\n\nstatic int da9063_suspend_disable(struct regulator_dev *rdev)\n{\n\tstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\n\n\treturn regmap_field_write(regl->suspend, 0);\n}\n\nstatic int da9063_buck_set_suspend_mode(struct regulator_dev *rdev,\n\t\t\t\tunsigned int mode)\n{\n\tstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\n\tint val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_FAST:\n\t\tval = BUCK_MODE_SYNC;\n\t\tbreak;\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = BUCK_MODE_AUTO;\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tval = BUCK_MODE_SLEEP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_field_write(regl->mode, val);\n}\n\nstatic int da9063_ldo_set_suspend_mode(struct regulator_dev *rdev,\n\t\t\t\tunsigned int mode)\n{\n\tstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\n\tunsigned int val;\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tval = 0;\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tval = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_field_write(regl->suspend_sleep, val);\n}\n\nstatic unsigned int da9063_get_overdrive_mask(const struct regulator_desc *desc)\n{\n\tswitch (desc->id) {\n\tcase DA9063_ID_BCORES_MERGED:\n\tcase DA9063_ID_BCORE1:\n\t\treturn DA9063_BCORE1_OD;\n\tcase DA9063_ID_BCORE2:\n\t\treturn DA9063_BCORE2_OD;\n\tcase DA9063_ID_BPRO:\n\t\treturn DA9063_BPRO_OD;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int da9063_buck_set_limit_set_overdrive(struct regulator_dev *rdev,\n\t\t\t\t\t       int min_uA, int max_uA,\n\t\t\t\t\t       unsigned int overdrive_mask)\n{\n\t \n\tstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\n\tint ret;\n\tunsigned int orig_overdrive;\n\n\tret = regmap_read(regl->hw->regmap, DA9063_REG_CONFIG_H,\n\t\t\t  &orig_overdrive);\n\tif (ret < 0)\n\t\treturn ret;\n\torig_overdrive &= overdrive_mask;\n\n\tif (orig_overdrive == 0) {\n\t\tret = regmap_set_bits(regl->hw->regmap, DA9063_REG_CONFIG_H,\n\t\t\t\toverdrive_mask);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = regulator_set_current_limit_regmap(rdev, min_uA / 2, max_uA / 2);\n\tif (ret < 0 && orig_overdrive == 0)\n\t\t \n\t\tregmap_clear_bits(regl->hw->regmap, DA9063_REG_CONFIG_H,\n\t\t\t\t  overdrive_mask);\n\n\treturn ret;\n}\n\nstatic int da9063_buck_set_limit_clear_overdrive(struct regulator_dev *rdev,\n\t\t\t\t\t\t int min_uA, int max_uA,\n\t\t\t\t\t\t unsigned int overdrive_mask)\n{\n\t \n\tstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\n\tint ret, orig_limit;\n\n\tret = regmap_read(rdev->regmap, rdev->desc->csel_reg, &orig_limit);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regulator_set_current_limit_regmap(rdev, min_uA, max_uA);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_clear_bits(regl->hw->regmap, DA9063_REG_CONFIG_H,\n\t\t\t\toverdrive_mask);\n\tif (ret < 0)\n\t\t \n\t\tregmap_write(rdev->regmap, rdev->desc->csel_reg, orig_limit);\n\n\treturn ret;\n}\n\nstatic int da9063_buck_set_current_limit(struct regulator_dev *rdev,\n\t\t\t\t\t int min_uA, int max_uA)\n{\n\tunsigned int overdrive_mask, n_currents;\n\n\toverdrive_mask = da9063_get_overdrive_mask(rdev->desc);\n\tif (overdrive_mask) {\n\t\tn_currents = rdev->desc->n_current_limits;\n\t\tif (n_currents == 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (max_uA > rdev->desc->curr_table[n_currents - 1])\n\t\t\treturn da9063_buck_set_limit_set_overdrive(rdev, min_uA,\n\t\t\t\t\t\t\t\t   max_uA,\n\t\t\t\t\t\t\t\t   overdrive_mask);\n\n\t\treturn da9063_buck_set_limit_clear_overdrive(rdev, min_uA,\n\t\t\t\t\t\t\t     max_uA,\n\t\t\t\t\t\t\t     overdrive_mask);\n\t}\n\treturn regulator_set_current_limit_regmap(rdev, min_uA, max_uA);\n}\n\nstatic int da9063_buck_get_current_limit(struct regulator_dev *rdev)\n{\n\tstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\n\tint val, ret, limit;\n\tunsigned int mask;\n\n\tlimit = regulator_get_current_limit_regmap(rdev);\n\tif (limit < 0)\n\t\treturn limit;\n\tmask = da9063_get_overdrive_mask(rdev->desc);\n\tif (mask) {\n\t\tret = regmap_read(regl->hw->regmap, DA9063_REG_CONFIG_H, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (val & mask)\n\t\t\tlimit *= 2;\n\t}\n\treturn limit;\n}\n\nstatic const struct regulator_ops da9063_buck_ops = {\n\t.enable\t\t\t\t= regulator_enable_regmap,\n\t.disable\t\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t\t= regulator_is_enabled_regmap,\n\t.get_voltage_sel\t\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t\t= regulator_list_voltage_linear,\n\t.set_current_limit\t\t= da9063_buck_set_current_limit,\n\t.get_current_limit\t\t= da9063_buck_get_current_limit,\n\t.set_mode\t\t\t= da9063_buck_set_mode,\n\t.get_mode\t\t\t= da9063_buck_get_mode,\n\t.get_status\t\t\t= da9063_buck_get_status,\n\t.set_suspend_voltage\t\t= da9063_set_suspend_voltage,\n\t.set_suspend_enable\t\t= da9063_suspend_enable,\n\t.set_suspend_disable\t\t= da9063_suspend_disable,\n\t.set_suspend_mode\t\t= da9063_buck_set_suspend_mode,\n\t.set_over_voltage_protection\t= da9063_set_xvp,\n\t.set_under_voltage_protection\t= da9063_set_xvp,\n};\n\nstatic const struct regulator_ops da9063_ldo_ops = {\n\t.enable\t\t\t\t= regulator_enable_regmap,\n\t.disable\t\t\t= regulator_disable_regmap,\n\t.is_enabled\t\t\t= regulator_is_enabled_regmap,\n\t.get_voltage_sel\t\t= regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel\t\t= regulator_set_voltage_sel_regmap,\n\t.list_voltage\t\t\t= regulator_list_voltage_linear,\n\t.set_mode\t\t\t= da9063_ldo_set_mode,\n\t.get_mode\t\t\t= da9063_ldo_get_mode,\n\t.get_status\t\t\t= da9063_ldo_get_status,\n\t.set_suspend_voltage\t\t= da9063_set_suspend_voltage,\n\t.set_suspend_enable\t\t= da9063_suspend_enable,\n\t.set_suspend_disable\t\t= da9063_suspend_disable,\n\t.set_suspend_mode\t\t= da9063_ldo_set_suspend_mode,\n\t.set_over_voltage_protection\t= da9063_set_xvp,\n\t.set_under_voltage_protection\t= da9063_set_xvp,\n};\n\n \nstatic const struct da9063_regulator_info da9063_regulator_info[] = {\n\t{\n\t\tDA9063_BUCK(DA9063, BCORE1, 300, 10, 1570,\n\t\t\t    da9063_buck_a_limits,\n\t\t\t    DA9063_REG_BUCK_ILIM_C, DA9063_BCORE1_ILIM_MASK),\n\t\tDA9063_BUCK_COMMON_FIELDS(BCORE1),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_4, DA9063_BCORE1_MON_EN),\n\t},\n\t{\n\t\tDA9063_BUCK(DA9063, BCORE2, 300, 10, 1570,\n\t\t\t    da9063_buck_a_limits,\n\t\t\t    DA9063_REG_BUCK_ILIM_C, DA9063_BCORE2_ILIM_MASK),\n\t\tDA9063_BUCK_COMMON_FIELDS(BCORE2),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_4, DA9063_BCORE2_MON_EN),\n\t},\n\t{\n\t\tDA9063_BUCK(DA9063, BPRO, 530, 10, 1800,\n\t\t\t    da9063_buck_a_limits,\n\t\t\t    DA9063_REG_BUCK_ILIM_B, DA9063_BPRO_ILIM_MASK),\n\t\tDA9063_BUCK_COMMON_FIELDS(BPRO),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_4, DA9063_BPRO_MON_EN),\n\t},\n\t{\n\t\tDA9063_BUCK(DA9063, BMEM, 800, 20, 3340,\n\t\t\t    da9063_buck_b_limits,\n\t\t\t    DA9063_REG_BUCK_ILIM_A, DA9063_BMEM_ILIM_MASK),\n\t\tDA9063_BUCK_COMMON_FIELDS(BMEM),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_4, DA9063_BMEM_MON_EN),\n\t},\n\t{\n\t\tDA9063_BUCK(DA9063, BIO, 800, 20, 3340,\n\t\t\t    da9063_buck_b_limits,\n\t\t\t    DA9063_REG_BUCK_ILIM_A, DA9063_BIO_ILIM_MASK),\n\t\tDA9063_BUCK_COMMON_FIELDS(BIO),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_4, DA9063_BIO_MON_EN),\n\t},\n\t{\n\t\tDA9063_BUCK(DA9063, BPERI, 800, 20, 3340,\n\t\t\t    da9063_buck_b_limits,\n\t\t\t    DA9063_REG_BUCK_ILIM_B, DA9063_BPERI_ILIM_MASK),\n\t\tDA9063_BUCK_COMMON_FIELDS(BPERI),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_4, DA9063_BPERI_MON_EN),\n\t},\n\t{\n\t\tDA9063_BUCK(DA9063, BCORES_MERGED, 300, 10, 1570,\n\t\t\t    da9063_bcores_merged_limits,\n\t\t\t    DA9063_REG_BUCK_ILIM_C, DA9063_BCORE1_ILIM_MASK),\n\t\t \n\t\tDA9063_BUCK_COMMON_FIELDS(BCORE1),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_4, DA9063_BCORE1_MON_EN),\n\t},\n\t{\n\t\tDA9063_BUCK(DA9063, BMEM_BIO_MERGED, 800, 20, 3340,\n\t\t\t    da9063_bmem_bio_merged_limits,\n\t\t\t    DA9063_REG_BUCK_ILIM_A, DA9063_BMEM_ILIM_MASK),\n\t\t \n\t\tDA9063_BUCK_COMMON_FIELDS(BMEM),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_4, DA9063_BMEM_MON_EN),\n\t},\n\t{\n\t\tDA9063_LDO(DA9063, LDO3, 900, 20, 3440),\n\t\t.oc_event = BFIELD(DA9063_REG_STATUS_D, DA9063_LDO3_LIM),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_2, DA9063_LDO3_MON_EN),\n\t},\n\t{\n\t\tDA9063_LDO(DA9063, LDO7, 900, 50, 3600),\n\t\t.oc_event = BFIELD(DA9063_REG_STATUS_D, DA9063_LDO7_LIM),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_2, DA9063_LDO7_MON_EN),\n\t},\n\t{\n\t\tDA9063_LDO(DA9063, LDO8, 900, 50, 3600),\n\t\t.oc_event = BFIELD(DA9063_REG_STATUS_D, DA9063_LDO8_LIM),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_2, DA9063_LDO8_MON_EN),\n\t},\n\t{\n\t\tDA9063_LDO(DA9063, LDO9, 950, 50, 3600),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_3, DA9063_LDO9_MON_EN),\n\t},\n\t{\n\t\tDA9063_LDO(DA9063, LDO11, 900, 50, 3600),\n\t\t.oc_event = BFIELD(DA9063_REG_STATUS_D, DA9063_LDO11_LIM),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_3, DA9063_LDO11_MON_EN),\n\t},\n\n\t \n\t{\n\t\tDA9063_LDO(DA9063, LDO1, 600, 20, 1860),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_2, DA9063_LDO1_MON_EN),\n\t},\n\t{\n\t\tDA9063_LDO(DA9063, LDO2, 600, 20, 1860),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_2, DA9063_LDO2_MON_EN),\n\t},\n\t{\n\t\tDA9063_LDO(DA9063, LDO4, 900, 20, 3440),\n\t\t.oc_event = BFIELD(DA9063_REG_STATUS_D, DA9063_LDO4_LIM),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_2, DA9063_LDO4_MON_EN),\n\t},\n\t{\n\t\tDA9063_LDO(DA9063, LDO5, 900, 50, 3600),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_2, DA9063_LDO5_MON_EN),\n\t},\n\t{\n\t\tDA9063_LDO(DA9063, LDO6, 900, 50, 3600),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_2, DA9063_LDO6_MON_EN),\n\t},\n\n\t{\n\t\tDA9063_LDO(DA9063, LDO10, 900, 50, 3600),\n\t\t.vmon = BFIELD(DA9063_BB_REG_MON_REG_3, DA9063_LDO10_MON_EN),\n\t},\n};\n\n \nstatic struct da9063_dev_model regulators_models[] = {\n\t{\n\t\t.regulator_info = da9063_regulator_info,\n\t\t.n_regulators = ARRAY_SIZE(da9063_regulator_info),\n\t\t.type = PMIC_TYPE_DA9063,\n\t},\n\t{\n\t\t.regulator_info = da9063_regulator_info,\n\t\t.n_regulators = ARRAY_SIZE(da9063_regulator_info) - 6,\n\t\t.type = PMIC_TYPE_DA9063L,\n\t},\n\t{ }\n};\n\n \nstatic irqreturn_t da9063_ldo_lim_event(int irq, void *data)\n{\n\tstruct da9063_regulators *regulators = data;\n\tstruct da9063 *hw = regulators->regulator[0].hw;\n\tstruct da9063_regulator *regl;\n\tint bits, i, ret;\n\n\tret = regmap_read(hw->regmap, DA9063_REG_STATUS_D, &bits);\n\tif (ret < 0)\n\t\treturn IRQ_NONE;\n\n\tfor (i = regulators->n_regulators - 1; i >= 0; i--) {\n\t\tregl = &regulators->regulator[i];\n\t\tif (regl->info->oc_event.reg != DA9063_REG_STATUS_D)\n\t\t\tcontinue;\n\n\t\tif (BIT(regl->info->oc_event.lsb) & bits) {\n\t\t\tregulator_notifier_call_chain(regl->rdev,\n\t\t\t\t\tREGULATOR_EVENT_OVER_CURRENT, NULL);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic const struct regulator_init_data *da9063_get_regulator_initdata(\n\t\tconst struct da9063_regulators_pdata *regl_pdata, int id)\n{\n\tint i;\n\n\tfor (i = 0; i < regl_pdata->n_regulators; i++) {\n\t\tif (id == regl_pdata->regulator_data[i].id)\n\t\t\treturn regl_pdata->regulator_data[i].initdata;\n\t}\n\n\treturn NULL;\n}\n\nstatic int da9063_check_xvp_constraints(struct regulator_config *config)\n{\n\tstruct da9063_regulator *regl = config->driver_data;\n\tconst struct regulation_constraints *constr = &config->init_data->constraints;\n\tconst struct notification_limit *uv_l = &constr->under_voltage_limits;\n\tconst struct notification_limit *ov_l = &constr->over_voltage_limits;\n\n\t \n\tif ((!!uv_l->prot + !!uv_l->err + !!uv_l->warn) > 1) {\n\t\tdev_err(config->dev, \"%s: at most one voltage monitoring severity allowed!\\n\",\n\t\t\tregl->desc.name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (uv_l->prot != ov_l->prot) {\n\t\tdev_err(config->dev,\n\t\t\t\"%s: protection-microvolt: value must be equal for uv and ov!\\n\",\n\t\t\tregl->desc.name);\n\t\treturn -EINVAL;\n\t}\n\tif (uv_l->err != ov_l->err) {\n\t\tdev_err(config->dev, \"%s: error-microvolt: value must be equal for uv and ov!\\n\",\n\t\t\tregl->desc.name);\n\t\treturn -EINVAL;\n\t}\n\tif (uv_l->warn != ov_l->warn) {\n\t\tdev_err(config->dev, \"%s: warn-microvolt: value must be equal for uv and ov!\\n\",\n\t\t\tregl->desc.name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct of_regulator_match da9063_matches[] = {\n\t[DA9063_ID_BCORE1]           = { .name = \"bcore1\"           },\n\t[DA9063_ID_BCORE2]           = { .name = \"bcore2\"           },\n\t[DA9063_ID_BPRO]             = { .name = \"bpro\",            },\n\t[DA9063_ID_BMEM]             = { .name = \"bmem\",            },\n\t[DA9063_ID_BIO]              = { .name = \"bio\",             },\n\t[DA9063_ID_BPERI]            = { .name = \"bperi\",           },\n\t[DA9063_ID_BCORES_MERGED]    = { .name = \"bcores-merged\"    },\n\t[DA9063_ID_BMEM_BIO_MERGED]  = { .name = \"bmem-bio-merged\", },\n\t[DA9063_ID_LDO3]             = { .name = \"ldo3\",            },\n\t[DA9063_ID_LDO7]             = { .name = \"ldo7\",            },\n\t[DA9063_ID_LDO8]             = { .name = \"ldo8\",            },\n\t[DA9063_ID_LDO9]             = { .name = \"ldo9\",            },\n\t[DA9063_ID_LDO11]            = { .name = \"ldo11\",           },\n\t \n\t[DA9063_ID_LDO1]             = { .name = \"ldo1\",            },\n\t[DA9063_ID_LDO2]             = { .name = \"ldo2\",            },\n\t[DA9063_ID_LDO4]             = { .name = \"ldo4\",            },\n\t[DA9063_ID_LDO5]             = { .name = \"ldo5\",            },\n\t[DA9063_ID_LDO6]             = { .name = \"ldo6\",            },\n\t[DA9063_ID_LDO10]            = { .name = \"ldo10\",           },\n};\n\nstatic struct da9063_regulators_pdata *da9063_parse_regulators_dt(\n\t\tstruct platform_device *pdev,\n\t\tstruct of_regulator_match **da9063_reg_matches)\n{\n\tstruct da9063 *da9063 = dev_get_drvdata(pdev->dev.parent);\n\tstruct da9063_regulators_pdata *pdata;\n\tstruct da9063_regulator_data *rdata;\n\tstruct device_node *node;\n\tint da9063_matches_len = ARRAY_SIZE(da9063_matches);\n\tint i, n, num;\n\n\tif (da9063->type == PMIC_TYPE_DA9063L)\n\t\tda9063_matches_len -= 6;\n\n\tnode = of_get_child_by_name(pdev->dev.parent->of_node, \"regulators\");\n\tif (!node) {\n\t\tdev_err(&pdev->dev, \"Regulators device node not found\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tnum = of_regulator_match(&pdev->dev, node, da9063_matches,\n\t\t\t\t da9063_matches_len);\n\tof_node_put(node);\n\tif (num < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to match regulators\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdata->regulator_data = devm_kcalloc(&pdev->dev,\n\t\t\t\t\tnum, sizeof(*pdata->regulator_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!pdata->regulator_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpdata->n_regulators = num;\n\n\tn = 0;\n\tfor (i = 0; i < da9063_matches_len; i++) {\n\t\tif (!da9063_matches[i].init_data)\n\t\t\tcontinue;\n\n\t\trdata = &pdata->regulator_data[n];\n\t\trdata->id = i;\n\t\trdata->initdata = da9063_matches[i].init_data;\n\n\t\tn++;\n\t}\n\n\t*da9063_reg_matches = da9063_matches;\n\treturn pdata;\n}\n\nstatic int da9063_regulator_probe(struct platform_device *pdev)\n{\n\tstruct da9063 *da9063 = dev_get_drvdata(pdev->dev.parent);\n\tstruct of_regulator_match *da9063_reg_matches = NULL;\n\tstruct da9063_regulators_pdata *regl_pdata;\n\tconst struct da9063_dev_model *model;\n\tstruct da9063_regulators *regulators;\n\tstruct da9063_regulator *regl;\n\tstruct regulator_config config;\n\tbool bcores_merged, bmem_bio_merged;\n\tint id, irq, n, n_regulators, ret, val;\n\n\tregl_pdata = da9063_parse_regulators_dt(pdev, &da9063_reg_matches);\n\n\tif (IS_ERR(regl_pdata) || regl_pdata->n_regulators == 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"No regulators defined for the platform\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (model = regulators_models; model->regulator_info; model++) {\n\t\tif (model->type == da9063->type)\n\t\t\tbreak;\n\t}\n\tif (!model->regulator_info) {\n\t\tdev_err(&pdev->dev, \"Chip model not recognised (%u)\\n\",\n\t\t\tda9063->type);\n\t\treturn -ENODEV;\n\t}\n\n\tret = regmap_read(da9063->regmap, DA9063_REG_CONFIG_H, &val);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Error while reading BUCKs configuration\\n\");\n\t\treturn ret;\n\t}\n\tbcores_merged = val & DA9063_BCORE_MERGE;\n\tbmem_bio_merged = val & DA9063_BUCK_MERGE;\n\n\tn_regulators = model->n_regulators;\n\tif (bcores_merged)\n\t\tn_regulators -= 2;  \n\telse\n\t\tn_regulators--;     \n\tif (bmem_bio_merged)\n\t\tn_regulators -= 2;  \n\telse\n\t\tn_regulators--;     \n\n\t \n\tregulators = devm_kzalloc(&pdev->dev, struct_size(regulators,\n\t\t\t\t  regulator, n_regulators), GFP_KERNEL);\n\tif (!regulators)\n\t\treturn -ENOMEM;\n\n\tregulators->n_regulators = n_regulators;\n\tplatform_set_drvdata(pdev, regulators);\n\n\t \n\tn = 0;\n\tid = 0;\n\twhile (n < regulators->n_regulators) {\n\t\t \n\t\tswitch (id) {\n\t\tcase DA9063_ID_BCORE1:\n\t\tcase DA9063_ID_BCORE2:\n\t\t\tif (bcores_merged) {\n\t\t\t\tid++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DA9063_ID_BMEM:\n\t\tcase DA9063_ID_BIO:\n\t\t\tif (bmem_bio_merged) {\n\t\t\t\tid++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DA9063_ID_BCORES_MERGED:\n\t\t\tif (!bcores_merged) {\n\t\t\t\tid++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DA9063_ID_BMEM_BIO_MERGED:\n\t\t\tif (!bmem_bio_merged) {\n\t\t\t\tid++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tregl = &regulators->regulator[n];\n\t\tregl->hw = da9063;\n\t\tregl->info = &model->regulator_info[id];\n\t\tregl->desc = regl->info->desc;\n\t\tregl->desc.type = REGULATOR_VOLTAGE;\n\t\tregl->desc.owner = THIS_MODULE;\n\n\t\tif (regl->info->mode.reg) {\n\t\t\tregl->mode = devm_regmap_field_alloc(&pdev->dev,\n\t\t\t\t\tda9063->regmap, regl->info->mode);\n\t\t\tif (IS_ERR(regl->mode))\n\t\t\t\treturn PTR_ERR(regl->mode);\n\t\t}\n\n\t\tif (regl->info->suspend.reg) {\n\t\t\tregl->suspend = devm_regmap_field_alloc(&pdev->dev,\n\t\t\t\t\tda9063->regmap, regl->info->suspend);\n\t\t\tif (IS_ERR(regl->suspend))\n\t\t\t\treturn PTR_ERR(regl->suspend);\n\t\t}\n\n\t\tif (regl->info->sleep.reg) {\n\t\t\tregl->sleep = devm_regmap_field_alloc(&pdev->dev,\n\t\t\t\t\tda9063->regmap, regl->info->sleep);\n\t\t\tif (IS_ERR(regl->sleep))\n\t\t\t\treturn PTR_ERR(regl->sleep);\n\t\t}\n\n\t\tif (regl->info->suspend_sleep.reg) {\n\t\t\tregl->suspend_sleep = devm_regmap_field_alloc(&pdev->dev,\n\t\t\t\tda9063->regmap, regl->info->suspend_sleep);\n\t\t\tif (IS_ERR(regl->suspend_sleep))\n\t\t\t\treturn PTR_ERR(regl->suspend_sleep);\n\t\t}\n\t\tif (regl->info->vmon.reg) {\n\t\t\tregl->vmon = devm_regmap_field_alloc(&pdev->dev,\n\t\t\t\tda9063->regmap, regl->info->vmon);\n\t\t\tif (IS_ERR(regl->vmon))\n\t\t\t\treturn PTR_ERR(regl->vmon);\n\t\t}\n\n\t\t \n\t\tmemset(&config, 0, sizeof(config));\n\t\tconfig.dev = &pdev->dev;\n\t\tconfig.init_data = da9063_get_regulator_initdata(regl_pdata, id);\n\t\tconfig.driver_data = regl;\n\t\tif (da9063_reg_matches)\n\t\t\tconfig.of_node = da9063_reg_matches[id].of_node;\n\t\tconfig.regmap = da9063->regmap;\n\n\t\t \n\t\tif (config.init_data) {\n\t\t\tret = da9063_check_xvp_constraints(&config);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tregl->rdev = devm_regulator_register(&pdev->dev, &regl->desc,\n\t\t\t\t\t\t     &config);\n\t\tif (IS_ERR(regl->rdev)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to register %s regulator\\n\",\n\t\t\t\tregl->desc.name);\n\t\t\treturn PTR_ERR(regl->rdev);\n\t\t}\n\t\tid++;\n\t\tn++;\n\t}\n\n\t \n\tirq = platform_get_irq_byname(pdev, \"LDO_LIM\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\t\tNULL, da9063_ldo_lim_event,\n\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\"LDO_LIM\", regulators);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Failed to request LDO_LIM IRQ.\\n\");\n\n\treturn ret;\n}\n\nstatic struct platform_driver da9063_regulator_driver = {\n\t.driver = {\n\t\t.name = DA9063_DRVNAME_REGULATORS,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = da9063_regulator_probe,\n};\n\nstatic int __init da9063_regulator_init(void)\n{\n\treturn platform_driver_register(&da9063_regulator_driver);\n}\nsubsys_initcall(da9063_regulator_init);\n\nstatic void __exit da9063_regulator_cleanup(void)\n{\n\tplatform_driver_unregister(&da9063_regulator_driver);\n}\nmodule_exit(da9063_regulator_cleanup);\n\n\n \nMODULE_AUTHOR(\"Krystian Garbaciak <krystian.garbaciak@diasemi.com>\");\nMODULE_DESCRIPTION(\"DA9063 regulators driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DA9063_DRVNAME_REGULATORS);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}