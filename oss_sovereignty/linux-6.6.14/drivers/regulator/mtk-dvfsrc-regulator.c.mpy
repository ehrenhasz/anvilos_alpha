{
  "module_name": "mtk-dvfsrc-regulator.c",
  "hash_id": "6847dc177a2d860873453297a0e4159a019183fb1310292d7d228a5aefdae2a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/mtk-dvfsrc-regulator.c",
  "human_readable_source": "\n\n\n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of_.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/soc/mediatek/mtk_dvfsrc.h>\n\n#define DVFSRC_ID_VCORE\t\t0\n#define DVFSRC_ID_VSCP\t\t1\n\n#define MT_DVFSRC_REGULAR(match, _name,\t_volt_table)\t\\\n[DVFSRC_ID_##_name] = {\t\t\t\t\t\\\n\t.desc = {\t\t\t\t\t\\\n\t\t.name = match,\t\t\t\t\\\n\t\t.of_match = of_match_ptr(match),\t\\\n\t\t.ops = &dvfsrc_vcore_ops,\t\t\\\n\t\t.type = REGULATOR_VOLTAGE,\t\t\\\n\t\t.id = DVFSRC_ID_##_name,\t\t\\\n\t\t.owner = THIS_MODULE,\t\t\t\\\n\t\t.n_voltages = ARRAY_SIZE(_volt_table),\t\\\n\t\t.volt_table = _volt_table,\t\t\\\n\t},\t\\\n}\n\n \n\nstruct dvfsrc_regulator {\n\tstruct regulator_desc\tdesc;\n};\n\n \nstruct dvfsrc_regulator_init_data {\n\tu32 size;\n\tstruct dvfsrc_regulator *regulator_info;\n};\n\nstatic inline struct device *to_dvfsrc_dev(struct regulator_dev *rdev)\n{\n\treturn rdev_get_dev(rdev)->parent;\n}\n\nstatic int dvfsrc_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t  unsigned int selector)\n{\n\tstruct device *dvfsrc_dev = to_dvfsrc_dev(rdev);\n\tint id = rdev_get_id(rdev);\n\n\tif (id == DVFSRC_ID_VCORE)\n\t\tmtk_dvfsrc_send_request(dvfsrc_dev,\n\t\t\t\t\tMTK_DVFSRC_CMD_VCORE_REQUEST,\n\t\t\t\t\tselector);\n\telse if (id == DVFSRC_ID_VSCP)\n\t\tmtk_dvfsrc_send_request(dvfsrc_dev,\n\t\t\t\t\tMTK_DVFSRC_CMD_VSCP_REQUEST,\n\t\t\t\t\tselector);\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int dvfsrc_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct device *dvfsrc_dev = to_dvfsrc_dev(rdev);\n\tint id = rdev_get_id(rdev);\n\tint val, ret;\n\n\tif (id == DVFSRC_ID_VCORE)\n\t\tret = mtk_dvfsrc_query_info(dvfsrc_dev,\n\t\t\t\t\t    MTK_DVFSRC_CMD_VCORE_LEVEL_QUERY,\n\t\t\t\t\t    &val);\n\telse if (id == DVFSRC_ID_VSCP)\n\t\tret = mtk_dvfsrc_query_info(dvfsrc_dev,\n\t\t\t\t\t    MTK_DVFSRC_CMD_VSCP_LEVEL_QUERY,\n\t\t\t\t\t    &val);\n\telse\n\t\treturn -EINVAL;\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic const struct regulator_ops dvfsrc_vcore_ops = {\n\t.list_voltage = regulator_list_voltage_table,\n\t.get_voltage_sel = dvfsrc_get_voltage_sel,\n\t.set_voltage_sel = dvfsrc_set_voltage_sel,\n};\n\nstatic const unsigned int mt8183_voltages[] = {\n\t725000,\n\t800000,\n};\n\nstatic struct dvfsrc_regulator mt8183_regulators[] = {\n\tMT_DVFSRC_REGULAR(\"dvfsrc-vcore\", VCORE,\n\t\t\t  mt8183_voltages),\n};\n\nstatic const struct dvfsrc_regulator_init_data regulator_mt8183_data = {\n\t.size = ARRAY_SIZE(mt8183_regulators),\n\t.regulator_info = &mt8183_regulators[0],\n};\n\nstatic const unsigned int mt6873_voltages[] = {\n\t575000,\n\t600000,\n\t650000,\n\t725000,\n};\n\nstatic struct dvfsrc_regulator mt6873_regulators[] = {\n\tMT_DVFSRC_REGULAR(\"dvfsrc-vcore\", VCORE,\n\t\t\t  mt6873_voltages),\n\tMT_DVFSRC_REGULAR(\"dvfsrc-vscp\", VSCP,\n\t\t\t  mt6873_voltages),\n};\n\nstatic const struct dvfsrc_regulator_init_data regulator_mt6873_data = {\n\t.size = ARRAY_SIZE(mt6873_regulators),\n\t.regulator_info = &mt6873_regulators[0],\n};\n\nstatic const struct of_device_id mtk_dvfsrc_regulator_match[] = {\n\t{\n\t\t.compatible = \"mediatek,mt8183-dvfsrc\",\n\t\t.data = &regulator_mt8183_data,\n\t}, {\n\t\t.compatible = \"mediatek,mt8192-dvfsrc\",\n\t\t.data = &regulator_mt6873_data,\n\t}, {\n\t\t.compatible = \"mediatek,mt6873-dvfsrc\",\n\t\t.data = &regulator_mt6873_data,\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, mtk_dvfsrc_regulator_match);\n\nstatic int dvfsrc_vcore_regulator_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct device *dev = &pdev->dev;\n\tstruct regulator_config config = { };\n\tstruct regulator_dev *rdev;\n\tconst struct dvfsrc_regulator_init_data *regulator_init_data;\n\tstruct dvfsrc_regulator *mt_regulators;\n\tint i;\n\n\tmatch = of_match_node(mtk_dvfsrc_regulator_match, dev->parent->of_node);\n\n\tif (!match) {\n\t\tdev_err(dev, \"invalid compatible string\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tregulator_init_data = match->data;\n\n\tmt_regulators = regulator_init_data->regulator_info;\n\tfor (i = 0; i < regulator_init_data->size; i++) {\n\t\tconfig.dev = dev->parent;\n\t\tconfig.driver_data = (mt_regulators + i);\n\t\trdev = devm_regulator_register(dev, &(mt_regulators + i)->desc,\n\t\t\t\t\t       &config);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tdev_err(dev, \"failed to register %s\\n\",\n\t\t\t\t(mt_regulators + i)->desc.name);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver mtk_dvfsrc_regulator_driver = {\n\t.driver = {\n\t\t.name  = \"mtk-dvfsrc-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = dvfsrc_vcore_regulator_probe,\n};\n\nstatic int __init mtk_dvfsrc_regulator_init(void)\n{\n\treturn platform_driver_register(&mtk_dvfsrc_regulator_driver);\n}\nsubsys_initcall(mtk_dvfsrc_regulator_init);\n\nstatic void __exit mtk_dvfsrc_regulator_exit(void)\n{\n\tplatform_driver_unregister(&mtk_dvfsrc_regulator_driver);\n}\nmodule_exit(mtk_dvfsrc_regulator_exit);\n\nMODULE_AUTHOR(\"Arvin wang <arvin.wang@mediatek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}