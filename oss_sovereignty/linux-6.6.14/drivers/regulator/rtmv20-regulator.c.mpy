{
  "module_name": "rtmv20-regulator.c",
  "hash_id": "755770cbbecd98c97eca017361e8ae0e5c2ce995c19e4942878b9c5a5dae9ffc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/rtmv20-regulator.c",
  "human_readable_source": "\n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n\n#define RTMV20_REG_DEVINFO\t0x00\n#define RTMV20_REG_PULSEDELAY\t0x01\n#define RTMV20_REG_PULSEWIDTH\t0x03\n#define RTMV20_REG_LDCTRL1\t0x05\n#define RTMV20_REG_ESPULSEWIDTH\t0x06\n#define RTMV20_REG_ESLDCTRL1\t0x08\n#define RTMV20_REG_LBP\t\t0x0A\n#define RTMV20_REG_LDCTRL2\t0x0B\n#define RTMV20_REG_FSIN1CTRL1\t0x0D\n#define RTMV20_REG_FSIN1CTRL3\t0x0F\n#define RTMV20_REG_FSIN2CTRL1\t0x10\n#define RTMV20_REG_FSIN2CTRL3\t0x12\n#define RTMV20_REG_ENCTRL\t0x13\n#define RTMV20_REG_STRBVSYNDLYL 0x29\n#define RTMV20_REG_LDIRQ\t0x30\n#define RTMV20_REG_LDSTAT\t0x40\n#define RTMV20_REG_LDMASK\t0x50\n#define RTMV20_MAX_REGS\t\t(RTMV20_REG_LDMASK + 1)\n\n#define RTMV20_VID_MASK\t\tGENMASK(7, 4)\n#define RICHTEK_VID\t\t0x80\n#define RTMV20_LDCURR_MASK\tGENMASK(7, 0)\n#define RTMV20_DELAY_MASK\tGENMASK(9, 0)\n#define RTMV20_WIDTH_MASK\tGENMASK(13, 0)\n#define RTMV20_WIDTH2_MASK\tGENMASK(7, 0)\n#define RTMV20_LBPLVL_MASK\tGENMASK(3, 0)\n#define RTMV20_LBPEN_MASK\tBIT(7)\n#define RTMV20_STROBEPOL_MASK\tBIT(0)\n#define RTMV20_VSYNPOL_MASK\tBIT(1)\n#define RTMV20_FSINEN_MASK\tBIT(7)\n#define RTMV20_ESEN_MASK\tBIT(6)\n#define RTMV20_FSINOUT_MASK\tBIT(2)\n#define LDENABLE_MASK\t\t(BIT(3) | BIT(0))\n\n#define OTPEVT_MASK\t\tBIT(4)\n#define SHORTEVT_MASK\t\tBIT(3)\n#define OPENEVT_MASK\t\tBIT(2)\n#define LBPEVT_MASK\t\tBIT(1)\n#define OCPEVT_MASK\t\tBIT(0)\n#define FAILEVT_MASK\t\t(SHORTEVT_MASK | OPENEVT_MASK | LBPEVT_MASK)\n\n#define RTMV20_LSW_MINUA\t0\n#define RTMV20_LSW_MAXUA\t6000000\n#define RTMV20_LSW_STEPUA\t30000\n\n#define RTMV20_LSW_DEFAULTUA\t3000000\n\n#define RTMV20_I2CRDY_TIMEUS\t200\n#define RTMV20_CSRDY_TIMEUS\t2000\n\nstruct rtmv20_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *enable_gpio;\n\tstruct regulator_dev *rdev;\n};\n\nstatic int rtmv20_lsw_enable(struct regulator_dev *rdev)\n{\n\tstruct rtmv20_priv *priv = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tgpiod_set_value(priv->enable_gpio, 1);\n\n\t \n\tusleep_range(RTMV20_I2CRDY_TIMEUS, RTMV20_I2CRDY_TIMEUS + 100);\n\n\t \n\tregcache_cache_only(priv->regmap, false);\n\tret = regcache_sync(priv->regmap);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regulator_enable_regmap(rdev);\n}\n\nstatic int rtmv20_lsw_disable(struct regulator_dev *rdev)\n{\n\tstruct rtmv20_priv *priv = rdev_get_drvdata(rdev);\n\tint ret;\n\n\tret = regulator_disable_regmap(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregcache_cache_only(priv->regmap, true);\n\tregcache_mark_dirty(priv->regmap);\n\n\tgpiod_set_value(priv->enable_gpio, 0);\n\n\treturn 0;\n}\n\nstatic int rtmv20_lsw_set_current_limit(struct regulator_dev *rdev, int min_uA,\n\t\t\t\t\tint max_uA)\n{\n\tint sel;\n\n\tif (min_uA > RTMV20_LSW_MAXUA || max_uA < RTMV20_LSW_MINUA)\n\t\treturn -EINVAL;\n\n\tif (max_uA > RTMV20_LSW_MAXUA)\n\t\tmax_uA = RTMV20_LSW_MAXUA;\n\n\tsel = (max_uA - RTMV20_LSW_MINUA) / RTMV20_LSW_STEPUA;\n\n\t \n\tif ((sel * RTMV20_LSW_STEPUA + RTMV20_LSW_MINUA) < min_uA)\n\t\treturn -EINVAL;\n\n\tsel <<= ffs(rdev->desc->csel_mask) - 1;\n\n\treturn regmap_update_bits(rdev->regmap, rdev->desc->csel_reg,\n\t\t\t\t  rdev->desc->csel_mask, sel);\n}\n\nstatic int rtmv20_lsw_get_current_limit(struct regulator_dev *rdev)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(rdev->regmap, rdev->desc->csel_reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= rdev->desc->csel_mask;\n\tval >>= ffs(rdev->desc->csel_mask) - 1;\n\n\treturn val * RTMV20_LSW_STEPUA + RTMV20_LSW_MINUA;\n}\n\nstatic const struct regulator_ops rtmv20_regulator_ops = {\n\t.set_current_limit = rtmv20_lsw_set_current_limit,\n\t.get_current_limit = rtmv20_lsw_get_current_limit,\n\t.enable = rtmv20_lsw_enable,\n\t.disable = rtmv20_lsw_disable,\n\t.is_enabled = regulator_is_enabled_regmap,\n};\n\nstatic const struct regulator_desc rtmv20_lsw_desc = {\n\t.name = \"rtmv20,lsw\",\n\t.of_match = of_match_ptr(\"lsw\"),\n\t.type = REGULATOR_CURRENT,\n\t.owner = THIS_MODULE,\n\t.ops = &rtmv20_regulator_ops,\n\t.csel_reg = RTMV20_REG_LDCTRL1,\n\t.csel_mask = RTMV20_LDCURR_MASK,\n\t.enable_reg = RTMV20_REG_ENCTRL,\n\t.enable_mask = LDENABLE_MASK,\n\t.enable_time = RTMV20_CSRDY_TIMEUS,\n};\n\nstatic irqreturn_t rtmv20_irq_handler(int irq, void *data)\n{\n\tstruct rtmv20_priv *priv = data;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, RTMV20_REG_LDIRQ, &val);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to get irq flags\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (val & OTPEVT_MASK)\n\t\tregulator_notifier_call_chain(priv->rdev, REGULATOR_EVENT_OVER_TEMP, NULL);\n\n\tif (val & OCPEVT_MASK)\n\t\tregulator_notifier_call_chain(priv->rdev, REGULATOR_EVENT_OVER_CURRENT, NULL);\n\n\tif (val & FAILEVT_MASK)\n\t\tregulator_notifier_call_chain(priv->rdev, REGULATOR_EVENT_FAIL, NULL);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic u32 clamp_to_selector(u32 val, u32 min, u32 max, u32 step)\n{\n\tu32 retval = clamp_val(val, min, max);\n\n\treturn (retval - min) / step;\n}\n\nstatic int rtmv20_properties_init(struct rtmv20_priv *priv)\n{\n\tconst struct {\n\t\tconst char *name;\n\t\tu32 def;\n\t\tu32 min;\n\t\tu32 max;\n\t\tu32 step;\n\t\tu32 addr;\n\t\tu32 mask;\n\t} props[] = {\n\t\t{ \"richtek,ld-pulse-delay-us\", 0, 0, 100000, 100, RTMV20_REG_PULSEDELAY,\n\t\t\tRTMV20_DELAY_MASK },\n\t\t{ \"richtek,ld-pulse-width-us\", 1200, 0, 10000, 1, RTMV20_REG_PULSEWIDTH,\n\t\t\tRTMV20_WIDTH_MASK },\n\t\t{ \"richtek,fsin1-delay-us\", 23000, 0, 100000, 100, RTMV20_REG_FSIN1CTRL1,\n\t\t\tRTMV20_DELAY_MASK },\n\t\t{ \"richtek,fsin1-width-us\", 160, 40, 10000, 40, RTMV20_REG_FSIN1CTRL3,\n\t\t\tRTMV20_WIDTH2_MASK },\n\t\t{ \"richtek,fsin2-delay-us\", 23000, 0, 100000, 100, RTMV20_REG_FSIN2CTRL1,\n\t\t\tRTMV20_DELAY_MASK },\n\t\t{ \"richtek,fsin2-width-us\", 160, 40, 10000, 40, RTMV20_REG_FSIN2CTRL3,\n\t\t\tRTMV20_WIDTH2_MASK },\n\t\t{ \"richtek,es-pulse-width-us\", 1200, 0, 10000, 1, RTMV20_REG_ESPULSEWIDTH,\n\t\t\tRTMV20_WIDTH_MASK },\n\t\t{ \"richtek,es-ld-current-microamp\", 3000000, 0, 6000000, 30000,\n\t\t\tRTMV20_REG_ESLDCTRL1, RTMV20_LDCURR_MASK },\n\t\t{ \"richtek,lbp-level-microvolt\", 2700000, 2400000, 3700000, 100000, RTMV20_REG_LBP,\n\t\t\tRTMV20_LBPLVL_MASK },\n\t\t{ \"richtek,lbp-enable\", 0, 0, 1, 1, RTMV20_REG_LBP, RTMV20_LBPEN_MASK },\n\t\t{ \"richtek,strobe-polarity-high\", 1, 0, 1, 1, RTMV20_REG_LDCTRL2,\n\t\t\tRTMV20_STROBEPOL_MASK },\n\t\t{ \"richtek,vsync-polarity-high\", 1, 0, 1, 1, RTMV20_REG_LDCTRL2,\n\t\t\tRTMV20_VSYNPOL_MASK },\n\t\t{ \"richtek,fsin-enable\", 0, 0, 1, 1, RTMV20_REG_ENCTRL, RTMV20_FSINEN_MASK },\n\t\t{ \"richtek,fsin-output\", 0, 0, 1, 1, RTMV20_REG_ENCTRL, RTMV20_FSINOUT_MASK },\n\t\t{ \"richtek,es-enable\", 0, 0, 1, 1, RTMV20_REG_ENCTRL, RTMV20_ESEN_MASK },\n\t};\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(props); i++) {\n\t\t__be16 bval16;\n\t\tu16 val16;\n\t\tu32 temp;\n\t\tint significant_bit = fls(props[i].mask);\n\t\tint shift = ffs(props[i].mask) - 1;\n\n\t\tif (props[i].max > 1) {\n\t\t\tret = device_property_read_u32(priv->dev, props[i].name, &temp);\n\t\t\tif (ret)\n\t\t\t\ttemp = props[i].def;\n\t\t} else\n\t\t\ttemp = device_property_read_bool(priv->dev, props[i].name);\n\n\t\ttemp = clamp_to_selector(temp, props[i].min, props[i].max, props[i].step);\n\n\t\t \n\t\tif (significant_bit > 8) {\n\t\t\tret = regmap_raw_read(priv->regmap, props[i].addr, &bval16, sizeof(bval16));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tval16 = be16_to_cpu(bval16);\n\t\t\tval16 &= ~props[i].mask;\n\t\t\tval16 |= (temp << shift);\n\t\t\tbval16 = cpu_to_be16(val16);\n\n\t\t\tret = regmap_raw_write(priv->regmap, props[i].addr, &bval16,\n\t\t\t\t\t       sizeof(bval16));\n\t\t} else {\n\t\t\tret = regmap_update_bits(priv->regmap, props[i].addr, props[i].mask,\n\t\t\t\t\t\t temp << shift);\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtmv20_check_chip_exist(struct rtmv20_priv *priv)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, RTMV20_REG_DEVINFO, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((val & RTMV20_VID_MASK) != RICHTEK_VID)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic bool rtmv20_is_accessible_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RTMV20_REG_DEVINFO ... RTMV20_REG_STRBVSYNDLYL:\n\tcase RTMV20_REG_LDIRQ:\n\tcase RTMV20_REG_LDSTAT:\n\tcase RTMV20_REG_LDMASK:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool rtmv20_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tif (reg == RTMV20_REG_LDIRQ || reg == RTMV20_REG_LDSTAT)\n\t\treturn true;\n\treturn false;\n}\n\nstatic const struct regmap_config rtmv20_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = RTMV20_REG_LDMASK,\n\t.num_reg_defaults_raw = RTMV20_MAX_REGS,\n\n\t.writeable_reg = rtmv20_is_accessible_reg,\n\t.readable_reg = rtmv20_is_accessible_reg,\n\t.volatile_reg = rtmv20_is_volatile_reg,\n};\n\nstatic int rtmv20_probe(struct i2c_client *i2c)\n{\n\tstruct rtmv20_priv *priv;\n\tstruct regulator_config config = {};\n\tint ret;\n\n\tpriv = devm_kzalloc(&i2c->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &i2c->dev;\n\n\t \n\tpriv->enable_gpio = devm_gpiod_get(&i2c->dev, \"enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->enable_gpio)) {\n\t\tdev_err(&i2c->dev, \"Failed to get enable gpio\\n\");\n\t\treturn PTR_ERR(priv->enable_gpio);\n\t}\n\n\t \n\tusleep_range(RTMV20_I2CRDY_TIMEUS, RTMV20_I2CRDY_TIMEUS + 100);\n\n\tpriv->regmap = devm_regmap_init_i2c(i2c, &rtmv20_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map\\n\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\tret = rtmv20_check_chip_exist(priv);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Chip vendor info is not matched\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtmv20_properties_init(priv);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to init properties\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tregcache_cache_only(priv->regmap, true);\n\tregcache_mark_dirty(priv->regmap);\n\tgpiod_set_value(priv->enable_gpio, 0);\n\n\tconfig.dev = &i2c->dev;\n\tconfig.regmap = priv->regmap;\n\tconfig.driver_data = priv;\n\tpriv->rdev = devm_regulator_register(&i2c->dev, &rtmv20_lsw_desc, &config);\n\tif (IS_ERR(priv->rdev)) {\n\t\tdev_err(&i2c->dev, \"Failed to register regulator\\n\");\n\t\treturn PTR_ERR(priv->rdev);\n\t}\n\n\t \n\tret = regmap_write(priv->regmap, RTMV20_REG_LDMASK, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL, rtmv20_irq_handler,\n\t\t\t\t\t IRQF_ONESHOT, dev_name(&i2c->dev), priv);\n}\n\nstatic int __maybe_unused rtmv20_suspend(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\n\t \n\tdisable_irq(i2c->irq);\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(i2c->irq);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rtmv20_resume(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\n\t \n\tenable_irq(i2c->irq);\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(i2c->irq);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(rtmv20_pm, rtmv20_suspend, rtmv20_resume);\n\nstatic const struct of_device_id __maybe_unused rtmv20_of_id[] = {\n\t{ .compatible = \"richtek,rtmv20\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rtmv20_of_id);\n\nstatic struct i2c_driver rtmv20_driver = {\n\t.driver = {\n\t\t.name = \"rtmv20\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(rtmv20_of_id),\n\t\t.pm = &rtmv20_pm,\n\t},\n\t.probe = rtmv20_probe,\n};\nmodule_i2c_driver(rtmv20_driver);\n\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_DESCRIPTION(\"Richtek RTMV20 Regulator Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}