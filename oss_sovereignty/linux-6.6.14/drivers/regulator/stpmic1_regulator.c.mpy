{
  "module_name": "stpmic1_regulator.c",
  "hash_id": "2f680784c441769edc24e62e6cf9e89bff696a1e38037b0a9773cf0827a458d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/regulator/stpmic1_regulator.c",
  "human_readable_source": "\n\n\n\n#include <linux/interrupt.h>\n#include <linux/mfd/stpmic1.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n\n#include <dt-bindings/mfd/st,stpmic1.h>\n\n \nstruct stpmic1_regulator_cfg {\n\tstruct regulator_desc desc;\n\tu8 mask_reset_reg;\n\tu8 mask_reset_mask;\n\tu8 icc_reg;\n\tu8 icc_mask;\n};\n\nstatic int stpmic1_set_mode(struct regulator_dev *rdev, unsigned int mode);\nstatic unsigned int stpmic1_get_mode(struct regulator_dev *rdev);\nstatic int stpmic1_set_icc(struct regulator_dev *rdev, int lim, int severity,\n\t\t\t   bool enable);\nstatic unsigned int stpmic1_map_mode(unsigned int mode);\n\nenum {\n\tSTPMIC1_BUCK1 = 0,\n\tSTPMIC1_BUCK2 = 1,\n\tSTPMIC1_BUCK3 = 2,\n\tSTPMIC1_BUCK4 = 3,\n\tSTPMIC1_LDO1 = 4,\n\tSTPMIC1_LDO2 = 5,\n\tSTPMIC1_LDO3 = 6,\n\tSTPMIC1_LDO4 = 7,\n\tSTPMIC1_LDO5 = 8,\n\tSTPMIC1_LDO6 = 9,\n\tSTPMIC1_VREF_DDR = 10,\n\tSTPMIC1_BOOST = 11,\n\tSTPMIC1_VBUS_OTG = 12,\n\tSTPMIC1_SW_OUT = 13,\n};\n\n \n#define PMIC_ENABLE_TIME_US 2200\n \n#define PMIC_RAMP_DELAY 2200\n\nstatic const struct linear_range buck1_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(725000, 0, 4, 0),\n\tREGULATOR_LINEAR_RANGE(725000, 5, 36, 25000),\n\tREGULATOR_LINEAR_RANGE(1500000, 37, 63, 0),\n};\n\nstatic const struct linear_range buck2_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1000000, 0, 17, 0),\n\tREGULATOR_LINEAR_RANGE(1050000, 18, 19, 0),\n\tREGULATOR_LINEAR_RANGE(1100000, 20, 21, 0),\n\tREGULATOR_LINEAR_RANGE(1150000, 22, 23, 0),\n\tREGULATOR_LINEAR_RANGE(1200000, 24, 25, 0),\n\tREGULATOR_LINEAR_RANGE(1250000, 26, 27, 0),\n\tREGULATOR_LINEAR_RANGE(1300000, 28, 29, 0),\n\tREGULATOR_LINEAR_RANGE(1350000, 30, 31, 0),\n\tREGULATOR_LINEAR_RANGE(1400000, 32, 33, 0),\n\tREGULATOR_LINEAR_RANGE(1450000, 34, 35, 0),\n\tREGULATOR_LINEAR_RANGE(1500000, 36, 63, 0),\n};\n\nstatic const struct linear_range buck3_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1000000, 0, 19, 0),\n\tREGULATOR_LINEAR_RANGE(1100000, 20, 23, 0),\n\tREGULATOR_LINEAR_RANGE(1200000, 24, 27, 0),\n\tREGULATOR_LINEAR_RANGE(1300000, 28, 31, 0),\n\tREGULATOR_LINEAR_RANGE(1400000, 32, 35, 0),\n\tREGULATOR_LINEAR_RANGE(1500000, 36, 55, 100000),\n\tREGULATOR_LINEAR_RANGE(3400000, 56, 63, 0),\n};\n\nstatic const struct linear_range buck4_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(600000, 0, 27, 25000),\n\tREGULATOR_LINEAR_RANGE(1300000, 28, 29, 0),\n\tREGULATOR_LINEAR_RANGE(1350000, 30, 31, 0),\n\tREGULATOR_LINEAR_RANGE(1400000, 32, 33, 0),\n\tREGULATOR_LINEAR_RANGE(1450000, 34, 35, 0),\n\tREGULATOR_LINEAR_RANGE(1500000, 36, 60, 100000),\n\tREGULATOR_LINEAR_RANGE(3900000, 61, 63, 0),\n};\n\nstatic const struct linear_range ldo1_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1700000, 0, 7, 0),\n\tREGULATOR_LINEAR_RANGE(1700000, 8, 24, 100000),\n\tREGULATOR_LINEAR_RANGE(3300000, 25, 31, 0),\n};\n\nstatic const struct linear_range ldo2_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1700000, 0, 7, 0),\n\tREGULATOR_LINEAR_RANGE(1700000, 8, 24, 100000),\n\tREGULATOR_LINEAR_RANGE(3300000, 25, 30, 0),\n};\n\nstatic const struct linear_range ldo3_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1700000, 0, 7, 0),\n\tREGULATOR_LINEAR_RANGE(1700000, 8, 24, 100000),\n\tREGULATOR_LINEAR_RANGE(3300000, 25, 30, 0),\n\t \n\tREGULATOR_LINEAR_RANGE(500000, 31, 31, 0),\n};\n\nstatic const struct linear_range ldo5_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(1700000, 0, 7, 0),\n\tREGULATOR_LINEAR_RANGE(1700000, 8, 30, 100000),\n\tREGULATOR_LINEAR_RANGE(3900000, 31, 31, 0),\n};\n\nstatic const struct linear_range ldo6_ranges[] = {\n\tREGULATOR_LINEAR_RANGE(900000, 0, 24, 100000),\n\tREGULATOR_LINEAR_RANGE(3300000, 25, 31, 0),\n};\n\nstatic const struct regulator_ops stpmic1_ldo_ops = {\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.map_voltage = regulator_map_voltage_linear_range,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.set_over_current_protection = stpmic1_set_icc,\n};\n\nstatic const struct regulator_ops stpmic1_ldo3_ops = {\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.map_voltage = regulator_map_voltage_iterate,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.get_bypass = regulator_get_bypass_regmap,\n\t.set_bypass = regulator_set_bypass_regmap,\n\t.set_over_current_protection = stpmic1_set_icc,\n};\n\nstatic const struct regulator_ops stpmic1_ldo4_fixed_regul_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.set_over_current_protection = stpmic1_set_icc,\n};\n\nstatic const struct regulator_ops stpmic1_buck_ops = {\n\t.list_voltage = regulator_list_voltage_linear_range,\n\t.map_voltage = regulator_map_voltage_linear_range,\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.get_voltage_sel = regulator_get_voltage_sel_regmap,\n\t.set_voltage_sel = regulator_set_voltage_sel_regmap,\n\t.set_pull_down = regulator_set_pull_down_regmap,\n\t.set_mode = stpmic1_set_mode,\n\t.get_mode = stpmic1_get_mode,\n\t.set_over_current_protection = stpmic1_set_icc,\n};\n\nstatic const struct regulator_ops stpmic1_vref_ddr_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n};\n\nstatic const struct regulator_ops stpmic1_boost_regul_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.set_over_current_protection = stpmic1_set_icc,\n};\n\nstatic const struct regulator_ops stpmic1_switch_regul_ops = {\n\t.is_enabled = regulator_is_enabled_regmap,\n\t.enable = regulator_enable_regmap,\n\t.disable = regulator_disable_regmap,\n\t.set_over_current_protection = stpmic1_set_icc,\n\t.set_active_discharge = regulator_set_active_discharge_regmap,\n};\n\n#define REG_LDO(ids, base) { \\\n\t.name = #ids, \\\n\t.id = STPMIC1_##ids, \\\n\t.n_voltages = 32, \\\n\t.ops = &stpmic1_ldo_ops, \\\n\t.linear_ranges = base ## _ranges, \\\n\t.n_linear_ranges = ARRAY_SIZE(base ## _ranges), \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.owner = THIS_MODULE, \\\n\t.vsel_reg = ids##_ACTIVE_CR, \\\n\t.vsel_mask = LDO_VOLTAGE_MASK, \\\n\t.enable_reg = ids##_ACTIVE_CR, \\\n\t.enable_mask = LDO_ENABLE_MASK, \\\n\t.enable_val = 1, \\\n\t.disable_val = 0, \\\n\t.enable_time = PMIC_ENABLE_TIME_US, \\\n\t.ramp_delay = PMIC_RAMP_DELAY, \\\n\t.supply_name = #base, \\\n}\n\n#define REG_LDO3(ids, base) { \\\n\t.name = #ids, \\\n\t.id = STPMIC1_##ids, \\\n\t.n_voltages = 32, \\\n\t.ops = &stpmic1_ldo3_ops, \\\n\t.linear_ranges = ldo3_ranges, \\\n\t.n_linear_ranges = ARRAY_SIZE(ldo3_ranges), \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.owner = THIS_MODULE, \\\n\t.vsel_reg = LDO3_ACTIVE_CR, \\\n\t.vsel_mask = LDO_VOLTAGE_MASK, \\\n\t.enable_reg = LDO3_ACTIVE_CR, \\\n\t.enable_mask = LDO_ENABLE_MASK, \\\n\t.enable_val = 1, \\\n\t.disable_val = 0, \\\n\t.enable_time = PMIC_ENABLE_TIME_US, \\\n\t.ramp_delay = PMIC_RAMP_DELAY, \\\n\t.bypass_reg = LDO3_ACTIVE_CR, \\\n\t.bypass_mask = LDO_BYPASS_MASK, \\\n\t.bypass_val_on = LDO_BYPASS_MASK, \\\n\t.bypass_val_off = 0, \\\n\t.supply_name = #base, \\\n}\n\n#define REG_LDO4(ids, base) { \\\n\t.name = #ids, \\\n\t.id = STPMIC1_##ids, \\\n\t.n_voltages = 1, \\\n\t.ops = &stpmic1_ldo4_fixed_regul_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.owner = THIS_MODULE, \\\n\t.min_uV = 3300000, \\\n\t.fixed_uV = 3300000, \\\n\t.enable_reg = LDO4_ACTIVE_CR, \\\n\t.enable_mask = LDO_ENABLE_MASK, \\\n\t.enable_val = 1, \\\n\t.disable_val = 0, \\\n\t.enable_time = PMIC_ENABLE_TIME_US, \\\n\t.ramp_delay = PMIC_RAMP_DELAY, \\\n\t.supply_name = #base, \\\n}\n\n#define REG_BUCK(ids, base) { \\\n\t.name = #ids, \\\n\t.id = STPMIC1_##ids, \\\n\t.ops = &stpmic1_buck_ops, \\\n\t.n_voltages = 64, \\\n\t.linear_ranges = base ## _ranges, \\\n\t.n_linear_ranges = ARRAY_SIZE(base ## _ranges), \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.owner = THIS_MODULE, \\\n\t.vsel_reg = ids##_ACTIVE_CR, \\\n\t.vsel_mask = BUCK_VOLTAGE_MASK, \\\n\t.enable_reg = ids##_ACTIVE_CR, \\\n\t.enable_mask = BUCK_ENABLE_MASK, \\\n\t.enable_val = 1, \\\n\t.disable_val = 0, \\\n\t.enable_time = PMIC_ENABLE_TIME_US, \\\n\t.ramp_delay = PMIC_RAMP_DELAY, \\\n\t.of_map_mode = stpmic1_map_mode, \\\n\t.pull_down_reg = ids##_PULL_DOWN_REG, \\\n\t.pull_down_mask = ids##_PULL_DOWN_MASK, \\\n\t.supply_name = #base, \\\n}\n\n#define REG_VREF_DDR(ids, base) { \\\n\t.name = #ids, \\\n\t.id = STPMIC1_##ids, \\\n\t.n_voltages = 1, \\\n\t.ops = &stpmic1_vref_ddr_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.owner = THIS_MODULE, \\\n\t.min_uV = 500000, \\\n\t.fixed_uV = 500000, \\\n\t.enable_reg = VREF_DDR_ACTIVE_CR, \\\n\t.enable_mask = BUCK_ENABLE_MASK, \\\n\t.enable_val = 1, \\\n\t.disable_val = 0, \\\n\t.enable_time = PMIC_ENABLE_TIME_US, \\\n\t.supply_name = #base, \\\n}\n\n#define REG_BOOST(ids, base) { \\\n\t.name = #ids, \\\n\t.id = STPMIC1_##ids, \\\n\t.n_voltages = 1, \\\n\t.ops = &stpmic1_boost_regul_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.owner = THIS_MODULE, \\\n\t.min_uV = 0, \\\n\t.fixed_uV = 5000000, \\\n\t.enable_reg = BST_SW_CR, \\\n\t.enable_mask = BOOST_ENABLED, \\\n\t.enable_val = BOOST_ENABLED, \\\n\t.disable_val = 0, \\\n\t.enable_time = PMIC_ENABLE_TIME_US, \\\n\t.supply_name = #base, \\\n}\n\n#define REG_VBUS_OTG(ids, base) { \\\n\t.name = #ids, \\\n\t.id = STPMIC1_##ids, \\\n\t.n_voltages = 1, \\\n\t.ops = &stpmic1_switch_regul_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.owner = THIS_MODULE, \\\n\t.min_uV = 0, \\\n\t.fixed_uV = 5000000, \\\n\t.enable_reg = BST_SW_CR, \\\n\t.enable_mask = USBSW_OTG_SWITCH_ENABLED, \\\n\t.enable_val = USBSW_OTG_SWITCH_ENABLED, \\\n\t.disable_val = 0, \\\n\t.enable_time = PMIC_ENABLE_TIME_US, \\\n\t.supply_name = #base, \\\n\t.active_discharge_reg = BST_SW_CR, \\\n\t.active_discharge_mask = VBUS_OTG_DISCHARGE, \\\n\t.active_discharge_on = VBUS_OTG_DISCHARGE, \\\n}\n\n#define REG_SW_OUT(ids, base) { \\\n\t.name = #ids, \\\n\t.id = STPMIC1_##ids, \\\n\t.n_voltages = 1, \\\n\t.ops = &stpmic1_switch_regul_ops, \\\n\t.type = REGULATOR_VOLTAGE, \\\n\t.owner = THIS_MODULE, \\\n\t.min_uV = 0, \\\n\t.fixed_uV = 5000000, \\\n\t.enable_reg = BST_SW_CR, \\\n\t.enable_mask = SWIN_SWOUT_ENABLED, \\\n\t.enable_val = SWIN_SWOUT_ENABLED, \\\n\t.disable_val = 0, \\\n\t.enable_time = PMIC_ENABLE_TIME_US, \\\n\t.supply_name = #base, \\\n\t.active_discharge_reg = BST_SW_CR, \\\n\t.active_discharge_mask = SW_OUT_DISCHARGE, \\\n\t.active_discharge_on = SW_OUT_DISCHARGE, \\\n}\n\nstatic const struct stpmic1_regulator_cfg stpmic1_regulator_cfgs[] = {\n\t[STPMIC1_BUCK1] = {\n\t\t.desc = REG_BUCK(BUCK1, buck1),\n\t\t.icc_reg = BUCKS_ICCTO_CR,\n\t\t.icc_mask = BIT(0),\n\t\t.mask_reset_reg = BUCKS_MASK_RESET_CR,\n\t\t.mask_reset_mask = BIT(0),\n\t},\n\t[STPMIC1_BUCK2] = {\n\t\t.desc = REG_BUCK(BUCK2, buck2),\n\t\t.icc_reg = BUCKS_ICCTO_CR,\n\t\t.icc_mask = BIT(1),\n\t\t.mask_reset_reg = BUCKS_MASK_RESET_CR,\n\t\t.mask_reset_mask = BIT(1),\n\t},\n\t[STPMIC1_BUCK3] = {\n\t\t.desc = REG_BUCK(BUCK3, buck3),\n\t\t.icc_reg = BUCKS_ICCTO_CR,\n\t\t.icc_mask = BIT(2),\n\t\t.mask_reset_reg = BUCKS_MASK_RESET_CR,\n\t\t.mask_reset_mask = BIT(2),\n\t},\n\t[STPMIC1_BUCK4] = {\n\t\t.desc = REG_BUCK(BUCK4, buck4),\n\t\t.icc_reg = BUCKS_ICCTO_CR,\n\t\t.icc_mask = BIT(3),\n\t\t.mask_reset_reg = BUCKS_MASK_RESET_CR,\n\t\t.mask_reset_mask = BIT(3),\n\t},\n\t[STPMIC1_LDO1] = {\n\t\t.desc = REG_LDO(LDO1, ldo1),\n\t\t.icc_reg = LDOS_ICCTO_CR,\n\t\t.icc_mask = BIT(0),\n\t\t.mask_reset_reg = LDOS_MASK_RESET_CR,\n\t\t.mask_reset_mask = BIT(0),\n\t},\n\t[STPMIC1_LDO2] = {\n\t\t.desc = REG_LDO(LDO2, ldo2),\n\t\t.icc_reg = LDOS_ICCTO_CR,\n\t\t.icc_mask = BIT(1),\n\t\t.mask_reset_reg = LDOS_MASK_RESET_CR,\n\t\t.mask_reset_mask = BIT(1),\n\t},\n\t[STPMIC1_LDO3] = {\n\t\t.desc = REG_LDO3(LDO3, ldo3),\n\t\t.icc_reg = LDOS_ICCTO_CR,\n\t\t.icc_mask = BIT(2),\n\t\t.mask_reset_reg = LDOS_MASK_RESET_CR,\n\t\t.mask_reset_mask = BIT(2),\n\t},\n\t[STPMIC1_LDO4] = {\n\t\t.desc = REG_LDO4(LDO4, ldo4),\n\t\t.icc_reg = LDOS_ICCTO_CR,\n\t\t.icc_mask = BIT(3),\n\t\t.mask_reset_reg = LDOS_MASK_RESET_CR,\n\t\t.mask_reset_mask = BIT(3),\n\t},\n\t[STPMIC1_LDO5] = {\n\t\t.desc = REG_LDO(LDO5, ldo5),\n\t\t.icc_reg = LDOS_ICCTO_CR,\n\t\t.icc_mask = BIT(4),\n\t\t.mask_reset_reg = LDOS_MASK_RESET_CR,\n\t\t.mask_reset_mask = BIT(4),\n\t},\n\t[STPMIC1_LDO6] = {\n\t\t.desc = REG_LDO(LDO6, ldo6),\n\t\t.icc_reg = LDOS_ICCTO_CR,\n\t\t.icc_mask = BIT(5),\n\t\t.mask_reset_reg = LDOS_MASK_RESET_CR,\n\t\t.mask_reset_mask = BIT(5),\n\t},\n\t[STPMIC1_VREF_DDR] = {\n\t\t.desc = REG_VREF_DDR(VREF_DDR, vref_ddr),\n\t\t.mask_reset_reg = LDOS_MASK_RESET_CR,\n\t\t.mask_reset_mask = BIT(6),\n\t},\n\t[STPMIC1_BOOST] = {\n\t\t.desc = REG_BOOST(BOOST, boost),\n\t\t.icc_reg = BUCKS_ICCTO_CR,\n\t\t.icc_mask = BIT(6),\n\t},\n\t[STPMIC1_VBUS_OTG] = {\n\t\t.desc = REG_VBUS_OTG(VBUS_OTG, pwr_sw1),\n\t\t.icc_reg = BUCKS_ICCTO_CR,\n\t\t.icc_mask = BIT(4),\n\t},\n\t[STPMIC1_SW_OUT] = {\n\t\t.desc = REG_SW_OUT(SW_OUT, pwr_sw2),\n\t\t.icc_reg = BUCKS_ICCTO_CR,\n\t\t.icc_mask = BIT(5),\n\t},\n};\n\nstatic unsigned int stpmic1_map_mode(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase STPMIC1_BUCK_MODE_NORMAL:\n\t\treturn REGULATOR_MODE_NORMAL;\n\tcase STPMIC1_BUCK_MODE_LP:\n\t\treturn REGULATOR_MODE_STANDBY;\n\tdefault:\n\t\treturn REGULATOR_MODE_INVALID;\n\t}\n}\n\nstatic unsigned int stpmic1_get_mode(struct regulator_dev *rdev)\n{\n\tint value;\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\n\tregmap_read(regmap, rdev->desc->enable_reg, &value);\n\n\tif (value & STPMIC1_BUCK_MODE_LP)\n\t\treturn REGULATOR_MODE_STANDBY;\n\n\treturn REGULATOR_MODE_NORMAL;\n}\n\nstatic int stpmic1_set_mode(struct regulator_dev *rdev, unsigned int mode)\n{\n\tint value;\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\n\tswitch (mode) {\n\tcase REGULATOR_MODE_NORMAL:\n\t\tvalue = STPMIC1_BUCK_MODE_NORMAL;\n\t\tbreak;\n\tcase REGULATOR_MODE_STANDBY:\n\t\tvalue = STPMIC1_BUCK_MODE_LP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(regmap, rdev->desc->enable_reg,\n\t\t\t\t  STPMIC1_BUCK_MODE_LP, value);\n}\n\nstatic int stpmic1_set_icc(struct regulator_dev *rdev, int lim, int severity,\n\t\t\t   bool enable)\n{\n\tstruct stpmic1_regulator_cfg *cfg = rdev_get_drvdata(rdev);\n\tstruct regmap *regmap = rdev_get_regmap(rdev);\n\n\t \n\tif (lim || severity != REGULATOR_SEVERITY_PROT || !enable)\n\t\treturn -EINVAL;\n\n\t \n\treturn regmap_update_bits(regmap, cfg->icc_reg, cfg->icc_mask,\n\t\t\t\t  cfg->icc_mask);\n}\n\nstatic irqreturn_t stpmic1_curlim_irq_handler(int irq, void *data)\n{\n\tstruct regulator_dev *rdev = (struct regulator_dev *)data;\n\n\t \n\tregulator_notifier_call_chain(rdev,\n\t\t\t\t      REGULATOR_EVENT_OVER_CURRENT,\n\t\t\t\t      NULL);\n\n\treturn IRQ_HANDLED;\n}\n\n#define MATCH(_name, _id) \\\n\t[STPMIC1_##_id] = { \\\n\t\t.name = #_name, \\\n\t\t.desc = &stpmic1_regulator_cfgs[STPMIC1_##_id].desc, \\\n\t}\n\nstatic struct of_regulator_match stpmic1_matches[] = {\n\tMATCH(buck1, BUCK1),\n\tMATCH(buck2, BUCK2),\n\tMATCH(buck3, BUCK3),\n\tMATCH(buck4, BUCK4),\n\tMATCH(ldo1, LDO1),\n\tMATCH(ldo2, LDO2),\n\tMATCH(ldo3, LDO3),\n\tMATCH(ldo4, LDO4),\n\tMATCH(ldo5, LDO5),\n\tMATCH(ldo6, LDO6),\n\tMATCH(vref_ddr, VREF_DDR),\n\tMATCH(boost, BOOST),\n\tMATCH(pwr_sw1, VBUS_OTG),\n\tMATCH(pwr_sw2, SW_OUT),\n};\n\nstatic int stpmic1_regulator_register(struct platform_device *pdev, int id,\n\t\t\t\t      struct of_regulator_match *match,\n\t\t\t\t      const struct stpmic1_regulator_cfg *cfg)\n{\n\tstruct stpmic1 *pmic_dev = dev_get_drvdata(pdev->dev.parent);\n\tstruct regulator_dev *rdev;\n\tstruct regulator_config config = {};\n\tint ret = 0;\n\tint irq;\n\n\tconfig.dev = &pdev->dev;\n\tconfig.init_data = match->init_data;\n\tconfig.of_node = match->of_node;\n\tconfig.regmap = pmic_dev->regmap;\n\tconfig.driver_data = (void *)cfg;\n\n\trdev = devm_regulator_register(&pdev->dev, &cfg->desc, &config);\n\tif (IS_ERR(rdev)) {\n\t\tdev_err(&pdev->dev, \"failed to register %s regulator\\n\",\n\t\t\tcfg->desc.name);\n\t\treturn PTR_ERR(rdev);\n\t}\n\n\t \n\tif (of_property_read_bool(config.of_node, \"st,mask-reset\") &&\n\t    cfg->mask_reset_reg != 0) {\n\t\tret = regmap_update_bits(pmic_dev->regmap,\n\t\t\t\t\t cfg->mask_reset_reg,\n\t\t\t\t\t cfg->mask_reset_mask,\n\t\t\t\t\t cfg->mask_reset_mask);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"set mask reset failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tirq = of_irq_get(config.of_node, 0);\n\tif (irq > 0) {\n\t\tret = devm_request_threaded_irq(&pdev->dev,\n\t\t\t\t\t\tirq, NULL,\n\t\t\t\t\t\tstpmic1_curlim_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED,\n\t\t\t\t\t\tpdev->name, rdev);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Request IRQ failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int stpmic1_regulator_probe(struct platform_device *pdev)\n{\n\tint i, ret;\n\n\tret = of_regulator_match(&pdev->dev, pdev->dev.of_node, stpmic1_matches,\n\t\t\t\t ARRAY_SIZE(stpmic1_matches));\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Error in PMIC regulator device tree node\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(stpmic1_regulator_cfgs); i++) {\n\t\tret = stpmic1_regulator_register(pdev, i, &stpmic1_matches[i],\n\t\t\t\t\t\t &stpmic1_regulator_cfgs[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tdev_dbg(&pdev->dev, \"stpmic1_regulator driver probed\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id of_pmic_regulator_match[] = {\n\t{ .compatible = \"st,stpmic1-regulators\" },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, of_pmic_regulator_match);\n\nstatic struct platform_driver stpmic1_regulator_driver = {\n\t.driver = {\n\t\t.name = \"stpmic1-regulator\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(of_pmic_regulator_match),\n\t},\n\t.probe = stpmic1_regulator_probe,\n};\n\nmodule_platform_driver(stpmic1_regulator_driver);\n\nMODULE_DESCRIPTION(\"STPMIC1 PMIC voltage regulator driver\");\nMODULE_AUTHOR(\"Pascal Paillet <p.paillet@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}