{
  "module_name": "pxa2xx_base.c",
  "hash_id": "342aec428e0fc4b445795aaef9159415bbcf9efdc5fbf7ed66361669928879d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/pxa2xx_base.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/soc/pxa/cpu.h>\n#include <linux/soc/pxa/smemc.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/mach-types.h>\n\n#include <pcmcia/ss.h>\n#include <pcmcia/cistpl.h>\n\n#include \"soc_common.h\"\n#include \"pxa2xx_base.h\"\n\n \n\n#define PCMCIAPrtSp\t0x04000000\t \n#define PCMCIASp\t(4*PCMCIAPrtSp)\t \n#define PCMCIAIOSp\tPCMCIAPrtSp\t \n#define PCMCIAAttrSp\tPCMCIAPrtSp\t \n#define PCMCIAMemSp\tPCMCIAPrtSp\t \n\n#define PCMCIA0Sp\tPCMCIASp\t \n#define PCMCIA0IOSp\tPCMCIAIOSp\t \n#define PCMCIA0AttrSp\tPCMCIAAttrSp\t \n#define PCMCIA0MemSp\tPCMCIAMemSp\t \n\n#define PCMCIA1Sp\tPCMCIASp\t \n#define PCMCIA1IOSp\tPCMCIAIOSp\t \n#define PCMCIA1AttrSp\tPCMCIAAttrSp\t \n#define PCMCIA1MemSp\tPCMCIAMemSp\t \n\n#define _PCMCIA(Nb)\t\t\t  \\\n\t\t\t(0x20000000 + (Nb) * PCMCIASp)\n#define _PCMCIAIO(Nb)\t_PCMCIA(Nb)\t \n#define _PCMCIAAttr(Nb)\t\t\t  \\\n\t\t\t(_PCMCIA(Nb) + 2 * PCMCIAPrtSp)\n#define _PCMCIAMem(Nb)\t\t\t  \\\n\t\t\t(_PCMCIA(Nb) + 3 * PCMCIAPrtSp)\n\n#define _PCMCIA0\t_PCMCIA(0)\t \n#define _PCMCIA0IO\t_PCMCIAIO(0)\t \n#define _PCMCIA0Attr\t_PCMCIAAttr(0)\t \n#define _PCMCIA0Mem\t_PCMCIAMem(0)\t \n\n#define _PCMCIA1\t_PCMCIA(1)\t \n#define _PCMCIA1IO\t_PCMCIAIO(1)\t \n#define _PCMCIA1Attr\t_PCMCIAAttr(1)\t \n#define _PCMCIA1Mem\t_PCMCIAMem(1)\t \n\n\n#define MCXX_SETUP_MASK     (0x7f)\n#define MCXX_ASST_MASK      (0x1f)\n#define MCXX_HOLD_MASK      (0x3f)\n#define MCXX_SETUP_SHIFT    (0)\n#define MCXX_ASST_SHIFT     (7)\n#define MCXX_HOLD_SHIFT     (14)\n\nstatic inline u_int pxa2xx_mcxx_hold(u_int pcmcia_cycle_ns,\n\t\t\t\t     u_int mem_clk_10khz)\n{\n\tu_int code = pcmcia_cycle_ns * mem_clk_10khz;\n\treturn (code / 300000) + ((code % 300000) ? 1 : 0) - 1;\n}\n\nstatic inline u_int pxa2xx_mcxx_asst(u_int pcmcia_cycle_ns,\n\t\t\t\t     u_int mem_clk_10khz)\n{\n\tu_int code = pcmcia_cycle_ns * mem_clk_10khz;\n\treturn (code / 300000) + ((code % 300000) ? 1 : 0) + 1;\n}\n\nstatic inline u_int pxa2xx_mcxx_setup(u_int pcmcia_cycle_ns,\n\t\t\t\t      u_int mem_clk_10khz)\n{\n\tu_int code = pcmcia_cycle_ns * mem_clk_10khz;\n\treturn (code / 100000) + ((code % 100000) ? 1 : 0) - 1;\n}\n\n \nstatic inline u_int pxa2xx_pcmcia_cmd_time(u_int mem_clk_10khz,\n\t\t\t\t\t   u_int pcmcia_mcxx_asst)\n{\n\treturn (300000 * (pcmcia_mcxx_asst + 1) / mem_clk_10khz);\n}\n\nstatic uint32_t pxa2xx_pcmcia_mcmem(int sock, int speed, int clock)\n{\n\tuint32_t val;\n\n\tval = ((pxa2xx_mcxx_setup(speed, clock)\n\t\t& MCXX_SETUP_MASK) << MCXX_SETUP_SHIFT)\n\t\t| ((pxa2xx_mcxx_asst(speed, clock)\n\t\t& MCXX_ASST_MASK) << MCXX_ASST_SHIFT)\n\t\t| ((pxa2xx_mcxx_hold(speed, clock)\n\t\t& MCXX_HOLD_MASK) << MCXX_HOLD_SHIFT);\n\n\treturn val;\n}\n\nstatic int pxa2xx_pcmcia_mcio(int sock, int speed, int clock)\n{\n\tuint32_t val;\n\n\tval = ((pxa2xx_mcxx_setup(speed, clock)\n\t\t& MCXX_SETUP_MASK) << MCXX_SETUP_SHIFT)\n\t\t| ((pxa2xx_mcxx_asst(speed, clock)\n\t\t& MCXX_ASST_MASK) << MCXX_ASST_SHIFT)\n\t\t| ((pxa2xx_mcxx_hold(speed, clock)\n\t\t& MCXX_HOLD_MASK) << MCXX_HOLD_SHIFT);\n\n\n\treturn val;\n}\n\nstatic int pxa2xx_pcmcia_mcatt(int sock, int speed, int clock)\n{\n\tuint32_t val;\n\n\tval = ((pxa2xx_mcxx_setup(speed, clock)\n\t\t& MCXX_SETUP_MASK) << MCXX_SETUP_SHIFT)\n\t\t| ((pxa2xx_mcxx_asst(speed, clock)\n\t\t& MCXX_ASST_MASK) << MCXX_ASST_SHIFT)\n\t\t| ((pxa2xx_mcxx_hold(speed, clock)\n\t\t& MCXX_HOLD_MASK) << MCXX_HOLD_SHIFT);\n\n\n\treturn val;\n}\n\nstatic int pxa2xx_pcmcia_set_timing(struct soc_pcmcia_socket *skt)\n{\n\tunsigned long clk = clk_get_rate(skt->clk) / 10000;\n\tstruct soc_pcmcia_timing timing;\n\tint sock = skt->nr;\n\n\tsoc_common_pcmcia_get_timing(skt, &timing);\n\n\tpxa_smemc_set_pcmcia_timing(sock,\n\t\tpxa2xx_pcmcia_mcmem(sock, timing.mem, clk),\n\t\tpxa2xx_pcmcia_mcatt(sock, timing.attr, clk),\n\t\tpxa2xx_pcmcia_mcio(sock, timing.io, clk));\n\n\treturn 0;\n}\n\n#ifdef CONFIG_CPU_FREQ\n\nstatic int\npxa2xx_pcmcia_frequency_change(struct soc_pcmcia_socket *skt,\n\t\t\t       unsigned long val,\n\t\t\t       struct cpufreq_freqs *freqs)\n{\n\tswitch (val) {\n\tcase CPUFREQ_PRECHANGE:\n\t\tif (freqs->new > freqs->old) {\n\t\t\tdebug(skt, 2, \"new frequency %u.%uMHz > %u.%uMHz, \"\n\t\t\t       \"pre-updating\\n\",\n\t\t\t       freqs->new / 1000, (freqs->new / 100) % 10,\n\t\t\t       freqs->old / 1000, (freqs->old / 100) % 10);\n\t\t\tpxa2xx_pcmcia_set_timing(skt);\n\t\t}\n\t\tbreak;\n\n\tcase CPUFREQ_POSTCHANGE:\n\t\tif (freqs->new < freqs->old) {\n\t\t\tdebug(skt, 2, \"new frequency %u.%uMHz < %u.%uMHz, \"\n\t\t\t       \"post-updating\\n\",\n\t\t\t       freqs->new / 1000, (freqs->new / 100) % 10,\n\t\t\t       freqs->old / 1000, (freqs->old / 100) % 10);\n\t\t\tpxa2xx_pcmcia_set_timing(skt);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n#endif\n\nvoid pxa2xx_configure_sockets(struct device *dev, struct pcmcia_low_level *ops)\n{\n\tpxa_smemc_set_pcmcia_socket(1);\n}\nEXPORT_SYMBOL(pxa2xx_configure_sockets);\n\nstatic const char *skt_names[] = {\n\t\"PCMCIA socket 0\",\n\t\"PCMCIA socket 1\",\n};\n\n#define SKT_DEV_INFO_SIZE(n) \\\n\t(sizeof(struct skt_dev_info) + (n)*sizeof(struct soc_pcmcia_socket))\n\nint pxa2xx_drv_pcmcia_add_one(struct soc_pcmcia_socket *skt)\n{\n\tskt->res_skt.start = _PCMCIA(skt->nr);\n\tskt->res_skt.end = _PCMCIA(skt->nr) + PCMCIASp - 1;\n\tskt->res_skt.name = skt_names[skt->nr];\n\tskt->res_skt.flags = IORESOURCE_MEM;\n\n\tskt->res_io.start = _PCMCIAIO(skt->nr);\n\tskt->res_io.end = _PCMCIAIO(skt->nr) + PCMCIAIOSp - 1;\n\tskt->res_io.name = \"io\";\n\tskt->res_io.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\n\tskt->res_mem.start = _PCMCIAMem(skt->nr);\n\tskt->res_mem.end = _PCMCIAMem(skt->nr) + PCMCIAMemSp - 1;\n\tskt->res_mem.name = \"memory\";\n\tskt->res_mem.flags = IORESOURCE_MEM;\n\n\tskt->res_attr.start = _PCMCIAAttr(skt->nr);\n\tskt->res_attr.end = _PCMCIAAttr(skt->nr) + PCMCIAAttrSp - 1;\n\tskt->res_attr.name = \"attribute\";\n\tskt->res_attr.flags = IORESOURCE_MEM;\n\n\treturn soc_pcmcia_add_one(skt);\n}\nEXPORT_SYMBOL(pxa2xx_drv_pcmcia_add_one);\n\nvoid pxa2xx_drv_pcmcia_ops(struct pcmcia_low_level *ops)\n{\n\t \n\tops->set_timing  = pxa2xx_pcmcia_set_timing;\n#ifdef CONFIG_CPU_FREQ\n\tops->frequency_change = pxa2xx_pcmcia_frequency_change;\n#endif\n}\nEXPORT_SYMBOL(pxa2xx_drv_pcmcia_ops);\n\nstatic int pxa2xx_drv_pcmcia_probe(struct platform_device *dev)\n{\n\tint i, ret = 0;\n\tstruct pcmcia_low_level *ops;\n\tstruct skt_dev_info *sinfo;\n\tstruct soc_pcmcia_socket *skt;\n\tstruct clk *clk;\n\n\tops = (struct pcmcia_low_level *)dev->dev.platform_data;\n\tif (!ops) {\n\t\tret = -ENODEV;\n\t\tgoto err0;\n\t}\n\n\tif (cpu_is_pxa320() && ops->nr > 1) {\n\t\tdev_err(&dev->dev, \"pxa320 supports only one pcmcia slot\");\n\t\tret = -EINVAL;\n\t\tgoto err0;\n\t}\n\n\tclk = devm_clk_get(&dev->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn -ENODEV;\n\n\tpxa2xx_drv_pcmcia_ops(ops);\n\n\tsinfo = devm_kzalloc(&dev->dev, SKT_DEV_INFO_SIZE(ops->nr),\n\t\t\t     GFP_KERNEL);\n\tif (!sinfo)\n\t\treturn -ENOMEM;\n\n\tsinfo->nskt = ops->nr;\n\n\t \n\tfor (i = 0; i < ops->nr; i++) {\n\t\tskt = &sinfo->skt[i];\n\n\t\tskt->nr = ops->first + i;\n\t\tskt->clk = clk;\n\t\tsoc_pcmcia_init_one(skt, ops, &dev->dev);\n\n\t\tret = pxa2xx_drv_pcmcia_add_one(skt);\n\t\tif (ret)\n\t\t\tgoto err1;\n\t}\n\n\tpxa2xx_configure_sockets(&dev->dev, ops);\n\tdev_set_drvdata(&dev->dev, sinfo);\n\n\treturn 0;\n\nerr1:\n\twhile (--i >= 0)\n\t\tsoc_pcmcia_remove_one(&sinfo->skt[i]);\n\nerr0:\n\treturn ret;\n}\n\nstatic int pxa2xx_drv_pcmcia_remove(struct platform_device *dev)\n{\n\tstruct skt_dev_info *sinfo = platform_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < sinfo->nskt; i++)\n\t\tsoc_pcmcia_remove_one(&sinfo->skt[i]);\n\n\treturn 0;\n}\n\nstatic int pxa2xx_drv_pcmcia_resume(struct device *dev)\n{\n\tstruct pcmcia_low_level *ops = (struct pcmcia_low_level *)dev->platform_data;\n\n\tpxa2xx_configure_sockets(dev, ops);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops pxa2xx_drv_pcmcia_pm_ops = {\n\t.resume\t\t= pxa2xx_drv_pcmcia_resume,\n};\n\nstatic struct platform_driver pxa2xx_pcmcia_driver = {\n\t.probe\t\t= pxa2xx_drv_pcmcia_probe,\n\t.remove\t\t= pxa2xx_drv_pcmcia_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"pxa2xx-pcmcia\",\n\t\t.pm\t= &pxa2xx_drv_pcmcia_pm_ops,\n\t},\n};\n\nstatic int __init pxa2xx_pcmcia_init(void)\n{\n\treturn platform_driver_register(&pxa2xx_pcmcia_driver);\n}\n\nstatic void __exit pxa2xx_pcmcia_exit(void)\n{\n\tplatform_driver_unregister(&pxa2xx_pcmcia_driver);\n}\n\nfs_initcall(pxa2xx_pcmcia_init);\nmodule_exit(pxa2xx_pcmcia_exit);\n\nMODULE_AUTHOR(\"Stefan Eletzhofer <stefan.eletzhofer@inquant.de> and Ian Molton <spyro@f2s.com>\");\nMODULE_DESCRIPTION(\"Linux PCMCIA Card Services: PXA2xx core socket driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pxa2xx-pcmcia\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}