{
  "module_name": "yenta_socket.c",
  "hash_id": "c7a6bac43704e5aef4d18e640db27921190c8e46bbaee8be1aae7dbcfc9fd654",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/yenta_socket.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#include <pcmcia/ss.h>\n\n#include \"yenta_socket.h\"\n#include \"i82365.h\"\n\nstatic bool disable_clkrun;\nmodule_param(disable_clkrun, bool, 0444);\nMODULE_PARM_DESC(disable_clkrun,\n\t\t \"If PC card doesn't function properly, please try this option (TI and Ricoh bridges only)\");\n\nstatic bool isa_probe = 1;\nmodule_param(isa_probe, bool, 0444);\nMODULE_PARM_DESC(isa_probe, \"If set ISA interrupts are probed (default). Set to N to disable probing\");\n\nstatic bool pwr_irqs_off;\nmodule_param(pwr_irqs_off, bool, 0644);\nMODULE_PARM_DESC(pwr_irqs_off, \"Force IRQs off during power-on of slot. Use only when seeing IRQ storms!\");\n\nstatic char o2_speedup[] = \"default\";\nmodule_param_string(o2_speedup, o2_speedup, sizeof(o2_speedup), 0444);\nMODULE_PARM_DESC(o2_speedup, \"Use prefetch/burst for O2-bridges: 'on', 'off' \"\n\t\"or 'default' (uses recommended behaviour for the detected bridge)\");\n\n \nstatic u32 isa_interrupts = 0x0ef8;\n\n\n#define debug(x, s, args...) dev_dbg(&s->dev->dev, x, ##args)\n\n \n#define to_cycles(ns)\t((ns)/120)\n#define to_ns(cycles)\t((cycles)*120)\n\n \n#ifdef CONFIG_YENTA_TI\nstatic int yenta_probe_cb_irq(struct yenta_socket *socket);\nstatic unsigned int yenta_probe_irq(struct yenta_socket *socket,\n\t\t\t\tu32 isa_irq_mask);\n#endif\n\n\nstatic unsigned int override_bios;\nmodule_param(override_bios, uint, 0000);\nMODULE_PARM_DESC(override_bios, \"yenta ignore bios resource allocation\");\n\n \nstatic inline u32 cb_readl(struct yenta_socket *socket, unsigned reg)\n{\n\tu32 val = readl(socket->base + reg);\n\tdebug(\"%04x %08x\\n\", socket, reg, val);\n\treturn val;\n}\n\nstatic inline void cb_writel(struct yenta_socket *socket, unsigned reg, u32 val)\n{\n\tdebug(\"%04x %08x\\n\", socket, reg, val);\n\twritel(val, socket->base + reg);\n\treadl(socket->base + reg);  \n}\n\nstatic inline u8 config_readb(struct yenta_socket *socket, unsigned offset)\n{\n\tu8 val;\n\tpci_read_config_byte(socket->dev, offset, &val);\n\tdebug(\"%04x %02x\\n\", socket, offset, val);\n\treturn val;\n}\n\nstatic inline u16 config_readw(struct yenta_socket *socket, unsigned offset)\n{\n\tu16 val;\n\tpci_read_config_word(socket->dev, offset, &val);\n\tdebug(\"%04x %04x\\n\", socket, offset, val);\n\treturn val;\n}\n\nstatic inline u32 config_readl(struct yenta_socket *socket, unsigned offset)\n{\n\tu32 val;\n\tpci_read_config_dword(socket->dev, offset, &val);\n\tdebug(\"%04x %08x\\n\", socket, offset, val);\n\treturn val;\n}\n\nstatic inline void config_writeb(struct yenta_socket *socket, unsigned offset, u8 val)\n{\n\tdebug(\"%04x %02x\\n\", socket, offset, val);\n\tpci_write_config_byte(socket->dev, offset, val);\n}\n\nstatic inline void config_writew(struct yenta_socket *socket, unsigned offset, u16 val)\n{\n\tdebug(\"%04x %04x\\n\", socket, offset, val);\n\tpci_write_config_word(socket->dev, offset, val);\n}\n\nstatic inline void config_writel(struct yenta_socket *socket, unsigned offset, u32 val)\n{\n\tdebug(\"%04x %08x\\n\", socket, offset, val);\n\tpci_write_config_dword(socket->dev, offset, val);\n}\n\nstatic inline u8 exca_readb(struct yenta_socket *socket, unsigned reg)\n{\n\tu8 val = readb(socket->base + 0x800 + reg);\n\tdebug(\"%04x %02x\\n\", socket, reg, val);\n\treturn val;\n}\n\n \n\nstatic inline void exca_writeb(struct yenta_socket *socket, unsigned reg, u8 val)\n{\n\tdebug(\"%04x %02x\\n\", socket, reg, val);\n\twriteb(val, socket->base + 0x800 + reg);\n\treadb(socket->base + 0x800 + reg);  \n}\n\nstatic void exca_writew(struct yenta_socket *socket, unsigned reg, u16 val)\n{\n\tdebug(\"%04x %04x\\n\", socket, reg, val);\n\twriteb(val, socket->base + 0x800 + reg);\n\twriteb(val >> 8, socket->base + 0x800 + reg + 1);\n\n\t \n\treadb(socket->base + 0x800 + reg);\n\treadb(socket->base + 0x800 + reg + 1);\n}\n\nstatic ssize_t show_yenta_registers(struct device *yentadev, struct device_attribute *attr, char *buf)\n{\n\tstruct yenta_socket *socket = dev_get_drvdata(yentadev);\n\tint offset = 0, i;\n\n\toffset = sysfs_emit(buf, \"CB registers:\");\n\tfor (i = 0; i < 0x24; i += 4) {\n\t\tunsigned val;\n\t\tif (!(i & 15))\n\t\t\toffset += sysfs_emit_at(buf, offset, \"\\n%02x:\", i);\n\t\tval = cb_readl(socket, i);\n\t\toffset += sysfs_emit_at(buf, offset, \" %08x\", val);\n\t}\n\n\toffset += sysfs_emit_at(buf, offset, \"\\n\\nExCA registers:\");\n\tfor (i = 0; i < 0x45; i++) {\n\t\tunsigned char val;\n\t\tif (!(i & 7)) {\n\t\t\tif (i & 8) {\n\t\t\t\tmemcpy(buf + offset, \" -\", 2);\n\t\t\t\toffset += 2;\n\t\t\t} else\n\t\t\t\toffset += sysfs_emit_at(buf, offset, \"\\n%02x:\", i);\n\t\t}\n\t\tval = exca_readb(socket, i);\n\t\toffset += sysfs_emit_at(buf, offset, \" %02x\", val);\n\t}\n\tsysfs_emit_at(buf, offset, \"\\n\");\n\treturn offset;\n}\n\nstatic DEVICE_ATTR(yenta_registers, S_IRUSR, show_yenta_registers, NULL);\n\n \nstatic int yenta_get_status(struct pcmcia_socket *sock, unsigned int *value)\n{\n\tstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\n\tunsigned int val;\n\tu32 state = cb_readl(socket, CB_SOCKET_STATE);\n\n\tval  = (state & CB_3VCARD) ? SS_3VCARD : 0;\n\tval |= (state & CB_XVCARD) ? SS_XVCARD : 0;\n\tval |= (state & (CB_5VCARD | CB_3VCARD | CB_XVCARD | CB_YVCARD)) ? 0 : SS_PENDING;\n\tval |= (state & (CB_CDETECT1 | CB_CDETECT2)) ? SS_PENDING : 0;\n\n\n\tif (state & CB_CBCARD) {\n\t\tval |= SS_CARDBUS;\n\t\tval |= (state & CB_CARDSTS) ? SS_STSCHG : 0;\n\t\tval |= (state & (CB_CDETECT1 | CB_CDETECT2)) ? 0 : SS_DETECT;\n\t\tval |= (state & CB_PWRCYCLE) ? SS_POWERON | SS_READY : 0;\n\t} else if (state & CB_16BITCARD) {\n\t\tu8 status = exca_readb(socket, I365_STATUS);\n\t\tval |= ((status & I365_CS_DETECT) == I365_CS_DETECT) ? SS_DETECT : 0;\n\t\tif (exca_readb(socket, I365_INTCTL) & I365_PC_IOCARD) {\n\t\t\tval |= (status & I365_CS_STSCHG) ? 0 : SS_STSCHG;\n\t\t} else {\n\t\t\tval |= (status & I365_CS_BVD1) ? 0 : SS_BATDEAD;\n\t\t\tval |= (status & I365_CS_BVD2) ? 0 : SS_BATWARN;\n\t\t}\n\t\tval |= (status & I365_CS_WRPROT) ? SS_WRPROT : 0;\n\t\tval |= (status & I365_CS_READY) ? SS_READY : 0;\n\t\tval |= (status & I365_CS_POWERON) ? SS_POWERON : 0;\n\t}\n\n\t*value = val;\n\treturn 0;\n}\n\nstatic void yenta_set_power(struct yenta_socket *socket, socket_state_t *state)\n{\n\t \n\tif (!(cb_readl(socket, CB_SOCKET_STATE) & CB_CBCARD) &&\n\t    (socket->flags & YENTA_16BIT_POWER_EXCA)) {\n\t\tu8 reg, old;\n\t\treg = old = exca_readb(socket, I365_POWER);\n\t\treg &= ~(I365_VCC_MASK | I365_VPP1_MASK | I365_VPP2_MASK);\n\n\t\t \n\t\tif (socket->flags & YENTA_16BIT_POWER_DF) {\n\t\t\tswitch (state->Vcc) {\n\t\t\tcase 33:\n\t\t\t\treg |= I365_VCC_3V;\n\t\t\t\tbreak;\n\t\t\tcase 50:\n\t\t\t\treg |= I365_VCC_5V;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treg = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (state->Vpp) {\n\t\t\tcase 33:\n\t\t\tcase 50:\n\t\t\t\treg |= I365_VPP1_5V;\n\t\t\t\tbreak;\n\t\t\tcase 120:\n\t\t\t\treg |= I365_VPP1_12V;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tswitch (state->Vcc) {\n\t\t\tcase 50:\n\t\t\t\treg |= I365_VCC_5V;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treg = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (state->Vpp) {\n\t\t\tcase 50:\n\t\t\t\treg |= I365_VPP1_5V | I365_VPP2_5V;\n\t\t\t\tbreak;\n\t\t\tcase 120:\n\t\t\t\treg |= I365_VPP1_12V | I365_VPP2_12V;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (reg != old)\n\t\t\texca_writeb(socket, I365_POWER, reg);\n\t} else {\n\t\tu32 reg = 0;\t \n\t\tswitch (state->Vcc) {\n\t\tcase 33:\n\t\t\treg = CB_SC_VCC_3V;\n\t\t\tbreak;\n\t\tcase 50:\n\t\t\treg = CB_SC_VCC_5V;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg = 0;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (state->Vpp) {\n\t\tcase 33:\n\t\t\treg |= CB_SC_VPP_3V;\n\t\t\tbreak;\n\t\tcase 50:\n\t\t\treg |= CB_SC_VPP_5V;\n\t\t\tbreak;\n\t\tcase 120:\n\t\t\treg |= CB_SC_VPP_12V;\n\t\t\tbreak;\n\t\t}\n\t\tif (reg != cb_readl(socket, CB_SOCKET_CONTROL))\n\t\t\tcb_writel(socket, CB_SOCKET_CONTROL, reg);\n\t}\n}\n\nstatic int yenta_set_socket(struct pcmcia_socket *sock, socket_state_t *state)\n{\n\tstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\n\tu16 bridge;\n\n\t \n\tif (state->Vcc == 0)\n\t\tyenta_set_power(socket, state);\n\n\tsocket->io_irq = state->io_irq;\n\tbridge = config_readw(socket, CB_BRIDGE_CONTROL) & ~(CB_BRIDGE_CRST | CB_BRIDGE_INTR);\n\tif (cb_readl(socket, CB_SOCKET_STATE) & CB_CBCARD) {\n\t\tu8 intr;\n\t\tbridge |= (state->flags & SS_RESET) ? CB_BRIDGE_CRST : 0;\n\n\t\t \n\t\tintr = exca_readb(socket, I365_INTCTL);\n\t\tintr = (intr & ~0xf);\n\t\tif (!socket->dev->irq) {\n\t\t\tintr |= socket->cb_irq ? socket->cb_irq : state->io_irq;\n\t\t\tbridge |= CB_BRIDGE_INTR;\n\t\t}\n\t\texca_writeb(socket, I365_INTCTL, intr);\n\t}  else {\n\t\tu8 reg;\n\n\t\treg = exca_readb(socket, I365_INTCTL) & (I365_RING_ENA | I365_INTR_ENA);\n\t\treg |= (state->flags & SS_RESET) ? 0 : I365_PC_RESET;\n\t\treg |= (state->flags & SS_IOCARD) ? I365_PC_IOCARD : 0;\n\t\tif (state->io_irq != socket->dev->irq) {\n\t\t\treg |= state->io_irq;\n\t\t\tbridge |= CB_BRIDGE_INTR;\n\t\t}\n\t\texca_writeb(socket, I365_INTCTL, reg);\n\n\t\treg = exca_readb(socket, I365_POWER) & (I365_VCC_MASK|I365_VPP1_MASK);\n\t\treg |= I365_PWR_NORESET;\n\t\tif (state->flags & SS_PWR_AUTO)\n\t\t\treg |= I365_PWR_AUTO;\n\t\tif (state->flags & SS_OUTPUT_ENA)\n\t\t\treg |= I365_PWR_OUT;\n\t\tif (exca_readb(socket, I365_POWER) != reg)\n\t\t\texca_writeb(socket, I365_POWER, reg);\n\n\t\t \n\t\treg = exca_readb(socket, I365_CSCINT);\n\t\treg &= I365_CSC_IRQ_MASK;\n\t\treg |= I365_CSC_DETECT;\n\t\tif (state->flags & SS_IOCARD) {\n\t\t\tif (state->csc_mask & SS_STSCHG)\n\t\t\t\treg |= I365_CSC_STSCHG;\n\t\t} else {\n\t\t\tif (state->csc_mask & SS_BATDEAD)\n\t\t\t\treg |= I365_CSC_BVD1;\n\t\t\tif (state->csc_mask & SS_BATWARN)\n\t\t\t\treg |= I365_CSC_BVD2;\n\t\t\tif (state->csc_mask & SS_READY)\n\t\t\t\treg |= I365_CSC_READY;\n\t\t}\n\t\texca_writeb(socket, I365_CSCINT, reg);\n\t\texca_readb(socket, I365_CSC);\n\t\tif (sock->zoom_video)\n\t\t\tsock->zoom_video(sock, state->flags & SS_ZVCARD);\n\t}\n\tconfig_writew(socket, CB_BRIDGE_CONTROL, bridge);\n\t \n\tcb_writel(socket, CB_SOCKET_EVENT, -1);\n\tcb_writel(socket, CB_SOCKET_MASK, CB_CDMASK);\n\n\t \n\tif (state->Vcc != 0)\n\t\tyenta_set_power(socket, state);\n\treturn 0;\n}\n\nstatic int yenta_set_io_map(struct pcmcia_socket *sock, struct pccard_io_map *io)\n{\n\tstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\n\tint map;\n\tunsigned char ioctl, addr, enable;\n\n\tmap = io->map;\n\n\tif (map > 1)\n\t\treturn -EINVAL;\n\n\tenable = I365_ENA_IO(map);\n\taddr = exca_readb(socket, I365_ADDRWIN);\n\n\t \n\tif (addr & enable) {\n\t\taddr &= ~enable;\n\t\texca_writeb(socket, I365_ADDRWIN, addr);\n\t}\n\n\texca_writew(socket, I365_IO(map)+I365_W_START, io->start);\n\texca_writew(socket, I365_IO(map)+I365_W_STOP, io->stop);\n\n\tioctl = exca_readb(socket, I365_IOCTL) & ~I365_IOCTL_MASK(map);\n\tif (io->flags & MAP_0WS)\n\t\tioctl |= I365_IOCTL_0WS(map);\n\tif (io->flags & MAP_16BIT)\n\t\tioctl |= I365_IOCTL_16BIT(map);\n\tif (io->flags & MAP_AUTOSZ)\n\t\tioctl |= I365_IOCTL_IOCS16(map);\n\texca_writeb(socket, I365_IOCTL, ioctl);\n\n\tif (io->flags & MAP_ACTIVE)\n\t\texca_writeb(socket, I365_ADDRWIN, addr | enable);\n\treturn 0;\n}\n\nstatic int yenta_set_mem_map(struct pcmcia_socket *sock, struct pccard_mem_map *mem)\n{\n\tstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\n\tstruct pci_bus_region region;\n\tint map;\n\tunsigned char addr, enable;\n\tunsigned int start, stop, card_start;\n\tunsigned short word;\n\n\tpcibios_resource_to_bus(socket->dev->bus, &region, mem->res);\n\n\tmap = mem->map;\n\tstart = region.start;\n\tstop = region.end;\n\tcard_start = mem->card_start;\n\n\tif (map > 4 || start > stop || ((start ^ stop) >> 24) ||\n\t    (card_start >> 26) || mem->speed > 1000)\n\t\treturn -EINVAL;\n\n\tenable = I365_ENA_MEM(map);\n\taddr = exca_readb(socket, I365_ADDRWIN);\n\tif (addr & enable) {\n\t\taddr &= ~enable;\n\t\texca_writeb(socket, I365_ADDRWIN, addr);\n\t}\n\n\texca_writeb(socket, CB_MEM_PAGE(map), start >> 24);\n\n\tword = (start >> 12) & 0x0fff;\n\tif (mem->flags & MAP_16BIT)\n\t\tword |= I365_MEM_16BIT;\n\tif (mem->flags & MAP_0WS)\n\t\tword |= I365_MEM_0WS;\n\texca_writew(socket, I365_MEM(map) + I365_W_START, word);\n\n\tword = (stop >> 12) & 0x0fff;\n\tswitch (to_cycles(mem->speed)) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tword |= I365_MEM_WS0;\n\t\tbreak;\n\tcase 2:\n\t\tword |= I365_MEM_WS1;\n\t\tbreak;\n\tdefault:\n\t\tword |= I365_MEM_WS1 | I365_MEM_WS0;\n\t\tbreak;\n\t}\n\texca_writew(socket, I365_MEM(map) + I365_W_STOP, word);\n\n\tword = ((card_start - start) >> 12) & 0x3fff;\n\tif (mem->flags & MAP_WRPROT)\n\t\tword |= I365_MEM_WRPROT;\n\tif (mem->flags & MAP_ATTRIB)\n\t\tword |= I365_MEM_REG;\n\texca_writew(socket, I365_MEM(map) + I365_W_OFF, word);\n\n\tif (mem->flags & MAP_ACTIVE)\n\t\texca_writeb(socket, I365_ADDRWIN, addr | enable);\n\treturn 0;\n}\n\n\n\nstatic irqreturn_t yenta_interrupt(int irq, void *dev_id)\n{\n\tunsigned int events;\n\tstruct yenta_socket *socket = (struct yenta_socket *) dev_id;\n\tu8 csc;\n\tu32 cb_event;\n\n\t \n\tcb_event = cb_readl(socket, CB_SOCKET_EVENT);\n\tcb_writel(socket, CB_SOCKET_EVENT, cb_event);\n\n\tcsc = exca_readb(socket, I365_CSC);\n\n\tif (!(cb_event || csc))\n\t\treturn IRQ_NONE;\n\n\tevents = (cb_event & (CB_CD1EVENT | CB_CD2EVENT)) ? SS_DETECT : 0 ;\n\tevents |= (csc & I365_CSC_DETECT) ? SS_DETECT : 0;\n\tif (exca_readb(socket, I365_INTCTL) & I365_PC_IOCARD) {\n\t\tevents |= (csc & I365_CSC_STSCHG) ? SS_STSCHG : 0;\n\t} else {\n\t\tevents |= (csc & I365_CSC_BVD1) ? SS_BATDEAD : 0;\n\t\tevents |= (csc & I365_CSC_BVD2) ? SS_BATWARN : 0;\n\t\tevents |= (csc & I365_CSC_READY) ? SS_READY : 0;\n\t}\n\n\tif (events)\n\t\tpcmcia_parse_events(&socket->socket, events);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void yenta_interrupt_wrapper(struct timer_list *t)\n{\n\tstruct yenta_socket *socket = from_timer(socket, t, poll_timer);\n\n\tyenta_interrupt(0, (void *)socket);\n\tsocket->poll_timer.expires = jiffies + HZ;\n\tadd_timer(&socket->poll_timer);\n}\n\nstatic void yenta_clear_maps(struct yenta_socket *socket)\n{\n\tint i;\n\tstruct resource res = { .start = 0, .end = 0x0fff };\n\tpccard_io_map io = { 0, 0, 0, 0, 1 };\n\tpccard_mem_map mem = { .res = &res, };\n\n\tyenta_set_socket(&socket->socket, &dead_socket);\n\tfor (i = 0; i < 2; i++) {\n\t\tio.map = i;\n\t\tyenta_set_io_map(&socket->socket, &io);\n\t}\n\tfor (i = 0; i < 5; i++) {\n\t\tmem.map = i;\n\t\tyenta_set_mem_map(&socket->socket, &mem);\n\t}\n}\n\n \nstatic void yenta_interrogate(struct yenta_socket *socket)\n{\n\tu32 state;\n\n\tstate = cb_readl(socket, CB_SOCKET_STATE);\n\tif (!(state & (CB_5VCARD | CB_3VCARD | CB_XVCARD | CB_YVCARD)) ||\n\t    (state & (CB_CDETECT1 | CB_CDETECT2 | CB_NOTACARD | CB_BADVCCREQ)) ||\n\t    ((state & (CB_16BITCARD | CB_CBCARD)) == (CB_16BITCARD | CB_CBCARD)))\n\t\tcb_writel(socket, CB_SOCKET_FORCE, CB_CVSTEST);\n}\n\n \nstatic int yenta_sock_init(struct pcmcia_socket *sock)\n{\n\tstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\n\n\texca_writeb(socket, I365_GBLCTL, 0x00);\n\texca_writeb(socket, I365_GENCTL, 0x00);\n\n\t \n\tyenta_interrogate(socket);\n\n\tyenta_clear_maps(socket);\n\n\tif (socket->type && socket->type->sock_init)\n\t\tsocket->type->sock_init(socket);\n\n\t \n\tcb_writel(socket, CB_SOCKET_MASK, CB_CDMASK);\n\n\treturn 0;\n}\n\nstatic int yenta_sock_suspend(struct pcmcia_socket *sock)\n{\n\tstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\n\n\t \n\tcb_writel(socket, CB_SOCKET_MASK, 0x0);\n\n\treturn 0;\n}\n\n \n#define BRIDGE_MEM_MAX (4*1024*1024)\n#define BRIDGE_MEM_ACC (128*1024)\n#define BRIDGE_MEM_MIN (16*1024)\n\n#define BRIDGE_IO_MAX 512\n#define BRIDGE_IO_ACC 256\n#define BRIDGE_IO_MIN 32\n\n#ifndef PCIBIOS_MIN_CARDBUS_IO\n#define PCIBIOS_MIN_CARDBUS_IO PCIBIOS_MIN_IO\n#endif\n\nstatic int yenta_search_one_res(struct resource *root, struct resource *res,\n\t\t\t\tu32 min)\n{\n\tu32 align, size, start, end;\n\n\tif (res->flags & IORESOURCE_IO) {\n\t\talign = 1024;\n\t\tsize = BRIDGE_IO_MAX;\n\t\tstart = PCIBIOS_MIN_CARDBUS_IO;\n\t\tend = ~0U;\n\t} else {\n\t\tunsigned long avail = root->end - root->start;\n\t\tint i;\n\t\tsize = BRIDGE_MEM_MAX;\n\t\tif (size > avail/8) {\n\t\t\tsize = (avail+1)/8;\n\t\t\t \n\t\t\ti = 0;\n\t\t\twhile ((size /= 2) != 0)\n\t\t\t\ti++;\n\t\t\tsize = 1 << i;\n\t\t}\n\t\tif (size < min)\n\t\t\tsize = min;\n\t\talign = size;\n\t\tstart = PCIBIOS_MIN_MEM;\n\t\tend = ~0U;\n\t}\n\n\tdo {\n\t\tif (allocate_resource(root, res, size, start, end, align,\n\t\t\t\t      NULL, NULL) == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tsize = size/2;\n\t\talign = size;\n\t} while (size >= min);\n\n\treturn 0;\n}\n\n\nstatic int yenta_search_res(struct yenta_socket *socket, struct resource *res,\n\t\t\t    u32 min)\n{\n\tstruct resource *root;\n\tint i;\n\n\tpci_bus_for_each_resource(socket->dev->bus, root, i) {\n\t\tif (!root)\n\t\t\tcontinue;\n\n\t\tif ((res->flags ^ root->flags) &\n\t\t    (IORESOURCE_IO | IORESOURCE_MEM | IORESOURCE_PREFETCH))\n\t\t\tcontinue;  \n\n\t\tif (yenta_search_one_res(root, res, min))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int yenta_allocate_res(struct yenta_socket *socket, int nr, unsigned type, int addr_start, int addr_end)\n{\n\tstruct pci_dev *dev = socket->dev;\n\tstruct resource *res;\n\tstruct pci_bus_region region;\n\tunsigned mask;\n\n\tres = &dev->resource[nr];\n\t \n\tif (res->parent)\n\t\treturn 0;\n\n\t \n\tmask = ~0xfff;\n\tif (type & IORESOURCE_IO)\n\t\tmask = ~3;\n\n\tres->name = dev->subordinate->name;\n\tres->flags = type;\n\n\tregion.start = config_readl(socket, addr_start) & mask;\n\tregion.end = config_readl(socket, addr_end) | ~mask;\n\tif (region.start && region.end > region.start && !override_bios) {\n\t\tpcibios_bus_to_resource(dev->bus, res, &region);\n\t\tif (pci_claim_resource(dev, nr) == 0)\n\t\t\treturn 0;\n\t\tdev_info(&dev->dev,\n\t\t\t \"Preassigned resource %d busy or not available, reconfiguring...\\n\",\n\t\t\t nr);\n\t}\n\n\tif (type & IORESOURCE_IO) {\n\t\tif ((yenta_search_res(socket, res, BRIDGE_IO_MAX)) ||\n\t\t    (yenta_search_res(socket, res, BRIDGE_IO_ACC)) ||\n\t\t    (yenta_search_res(socket, res, BRIDGE_IO_MIN)))\n\t\t\treturn 1;\n\t} else {\n\t\tif (type & IORESOURCE_PREFETCH) {\n\t\t\tif ((yenta_search_res(socket, res, BRIDGE_MEM_MAX)) ||\n\t\t\t    (yenta_search_res(socket, res, BRIDGE_MEM_ACC)) ||\n\t\t\t    (yenta_search_res(socket, res, BRIDGE_MEM_MIN)))\n\t\t\t\treturn 1;\n\t\t\t \n\t\t\tres->flags = IORESOURCE_MEM;\n\t\t}\n\t\tif ((yenta_search_res(socket, res, BRIDGE_MEM_MAX)) ||\n\t\t    (yenta_search_res(socket, res, BRIDGE_MEM_ACC)) ||\n\t\t    (yenta_search_res(socket, res, BRIDGE_MEM_MIN)))\n\t\t\treturn 1;\n\t}\n\n\tdev_info(&dev->dev,\n\t\t \"no resource of type %x available, trying to continue...\\n\",\n\t\t type);\n\tres->start = res->end = res->flags = 0;\n\treturn 0;\n}\n\nstatic void yenta_free_res(struct yenta_socket *socket, int nr)\n{\n\tstruct pci_dev *dev = socket->dev;\n\tstruct resource *res;\n\n\tres = &dev->resource[nr];\n\tif (res->start != 0 && res->end != 0)\n\t\trelease_resource(res);\n\n\tres->start = res->end = res->flags = 0;\n}\n\n \nstatic void yenta_allocate_resources(struct yenta_socket *socket)\n{\n\tint program = 0;\n\tprogram += yenta_allocate_res(socket, PCI_CB_BRIDGE_IO_0_WINDOW,\n\t\t\t   IORESOURCE_IO,\n\t\t\t   PCI_CB_IO_BASE_0, PCI_CB_IO_LIMIT_0);\n\tprogram += yenta_allocate_res(socket, PCI_CB_BRIDGE_IO_1_WINDOW,\n\t\t\t   IORESOURCE_IO,\n\t\t\t   PCI_CB_IO_BASE_1, PCI_CB_IO_LIMIT_1);\n\tprogram += yenta_allocate_res(socket, PCI_CB_BRIDGE_MEM_0_WINDOW,\n\t\t\t   IORESOURCE_MEM | IORESOURCE_PREFETCH,\n\t\t\t   PCI_CB_MEMORY_BASE_0, PCI_CB_MEMORY_LIMIT_0);\n\tprogram += yenta_allocate_res(socket, PCI_CB_BRIDGE_MEM_1_WINDOW,\n\t\t\t   IORESOURCE_MEM,\n\t\t\t   PCI_CB_MEMORY_BASE_1, PCI_CB_MEMORY_LIMIT_1);\n\tif (program)\n\t\tpci_setup_cardbus(socket->dev->subordinate);\n}\n\n\n \nstatic void yenta_free_resources(struct yenta_socket *socket)\n{\n\tyenta_free_res(socket, PCI_CB_BRIDGE_IO_0_WINDOW);\n\tyenta_free_res(socket, PCI_CB_BRIDGE_IO_1_WINDOW);\n\tyenta_free_res(socket, PCI_CB_BRIDGE_MEM_0_WINDOW);\n\tyenta_free_res(socket, PCI_CB_BRIDGE_MEM_1_WINDOW);\n}\n\n\n \nstatic void yenta_close(struct pci_dev *dev)\n{\n\tstruct yenta_socket *sock = pci_get_drvdata(dev);\n\n\t \n\tdevice_remove_file(&dev->dev, &dev_attr_yenta_registers);\n\n\t \n\tpcmcia_unregister_socket(&sock->socket);\n\n\t \n\tcb_writel(sock, CB_SOCKET_MASK, 0x0);\n\texca_writeb(sock, I365_CSCINT, 0);\n\n\tif (sock->cb_irq)\n\t\tfree_irq(sock->cb_irq, sock);\n\telse\n\t\ttimer_shutdown_sync(&sock->poll_timer);\n\n\tiounmap(sock->base);\n\tyenta_free_resources(sock);\n\n\tpci_release_regions(dev);\n\tpci_disable_device(dev);\n\tpci_set_drvdata(dev, NULL);\n\tkfree(sock);\n}\n\n\nstatic struct pccard_operations yenta_socket_operations = {\n\t.init\t\t\t= yenta_sock_init,\n\t.suspend\t\t= yenta_sock_suspend,\n\t.get_status\t\t= yenta_get_status,\n\t.set_socket\t\t= yenta_set_socket,\n\t.set_io_map\t\t= yenta_set_io_map,\n\t.set_mem_map\t\t= yenta_set_mem_map,\n};\n\n\n#ifdef CONFIG_YENTA_TI\n#include \"ti113x.h\"\n#endif\n#ifdef CONFIG_YENTA_RICOH\n#include \"ricoh.h\"\n#endif\n#ifdef CONFIG_YENTA_TOSHIBA\n#include \"topic.h\"\n#endif\n#ifdef CONFIG_YENTA_O2\n#include \"o2micro.h\"\n#endif\n\nenum {\n\tCARDBUS_TYPE_DEFAULT = -1,\n\tCARDBUS_TYPE_TI,\n\tCARDBUS_TYPE_TI113X,\n\tCARDBUS_TYPE_TI12XX,\n\tCARDBUS_TYPE_TI1250,\n\tCARDBUS_TYPE_RICOH,\n\tCARDBUS_TYPE_TOPIC95,\n\tCARDBUS_TYPE_TOPIC97,\n\tCARDBUS_TYPE_O2MICRO,\n\tCARDBUS_TYPE_ENE,\n};\n\n \nstatic struct cardbus_type cardbus_type[] = {\n#ifdef CONFIG_YENTA_TI\n\t[CARDBUS_TYPE_TI]\t= {\n\t\t.override\t= ti_override,\n\t\t.save_state\t= ti_save_state,\n\t\t.restore_state\t= ti_restore_state,\n\t\t.sock_init\t= ti_init,\n\t},\n\t[CARDBUS_TYPE_TI113X]\t= {\n\t\t.override\t= ti113x_override,\n\t\t.save_state\t= ti_save_state,\n\t\t.restore_state\t= ti_restore_state,\n\t\t.sock_init\t= ti_init,\n\t},\n\t[CARDBUS_TYPE_TI12XX]\t= {\n\t\t.override\t= ti12xx_override,\n\t\t.save_state\t= ti_save_state,\n\t\t.restore_state\t= ti_restore_state,\n\t\t.sock_init\t= ti_init,\n\t},\n\t[CARDBUS_TYPE_TI1250]\t= {\n\t\t.override\t= ti1250_override,\n\t\t.save_state\t= ti_save_state,\n\t\t.restore_state\t= ti_restore_state,\n\t\t.sock_init\t= ti_init,\n\t},\n\t[CARDBUS_TYPE_ENE]\t= {\n\t\t.override\t= ene_override,\n\t\t.save_state\t= ti_save_state,\n\t\t.restore_state\t= ti_restore_state,\n\t\t.sock_init\t= ti_init,\n\t},\n#endif\n#ifdef CONFIG_YENTA_RICOH\n\t[CARDBUS_TYPE_RICOH]\t= {\n\t\t.override\t= ricoh_override,\n\t\t.save_state\t= ricoh_save_state,\n\t\t.restore_state\t= ricoh_restore_state,\n\t},\n#endif\n#ifdef CONFIG_YENTA_TOSHIBA\n\t[CARDBUS_TYPE_TOPIC95]\t= {\n\t\t.override\t= topic95_override,\n\t},\n\t[CARDBUS_TYPE_TOPIC97]\t= {\n\t\t.override\t= topic97_override,\n\t},\n#endif\n#ifdef CONFIG_YENTA_O2\n\t[CARDBUS_TYPE_O2MICRO]\t= {\n\t\t.override\t= o2micro_override,\n\t\t.restore_state\t= o2micro_restore_state,\n\t},\n#endif\n};\n\n\nstatic unsigned int yenta_probe_irq(struct yenta_socket *socket, u32 isa_irq_mask)\n{\n\tint i;\n\tunsigned long val;\n\tu32 mask;\n\tu8 reg;\n\n\t \n\tcb_writel(socket, CB_SOCKET_EVENT, -1);\n\tcb_writel(socket, CB_SOCKET_MASK, CB_CSTSMASK);\n\treg = exca_readb(socket, I365_CSCINT);\n\texca_writeb(socket, I365_CSCINT, 0);\n\tval = probe_irq_on() & isa_irq_mask;\n\tfor (i = 1; i < 16; i++) {\n\t\tif (!((val >> i) & 1))\n\t\t\tcontinue;\n\t\texca_writeb(socket, I365_CSCINT, I365_CSC_STSCHG | (i << 4));\n\t\tcb_writel(socket, CB_SOCKET_FORCE, CB_FCARDSTS);\n\t\tudelay(100);\n\t\tcb_writel(socket, CB_SOCKET_EVENT, -1);\n\t}\n\tcb_writel(socket, CB_SOCKET_MASK, 0);\n\texca_writeb(socket, I365_CSCINT, reg);\n\n\tmask = probe_irq_mask(val) & 0xffff;\n\n\treturn mask;\n}\n\n\n \n#ifdef CONFIG_YENTA_TI\n\n \nstatic irqreturn_t yenta_probe_handler(int irq, void *dev_id)\n{\n\tstruct yenta_socket *socket = (struct yenta_socket *) dev_id;\n\tu8 csc;\n\tu32 cb_event;\n\n\t \n\tcb_event = cb_readl(socket, CB_SOCKET_EVENT);\n\tcb_writel(socket, CB_SOCKET_EVENT, -1);\n\tcsc = exca_readb(socket, I365_CSC);\n\n\tif (cb_event || csc) {\n\t\tsocket->probe_status = 1;\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\n \nstatic int yenta_probe_cb_irq(struct yenta_socket *socket)\n{\n\tu8 reg = 0;\n\n\tif (!socket->cb_irq)\n\t\treturn -1;\n\n\tsocket->probe_status = 0;\n\n\tif (request_irq(socket->cb_irq, yenta_probe_handler, IRQF_SHARED, \"yenta\", socket)) {\n\t\tdev_warn(&socket->dev->dev,\n\t\t\t \"request_irq() in yenta_probe_cb_irq() failed!\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (!socket->dev->irq)\n\t\treg = exca_readb(socket, I365_CSCINT);\n\texca_writeb(socket, I365_CSCINT, reg | I365_CSC_STSCHG);\n\tcb_writel(socket, CB_SOCKET_EVENT, -1);\n\tcb_writel(socket, CB_SOCKET_MASK, CB_CSTSMASK);\n\tcb_writel(socket, CB_SOCKET_FORCE, CB_FCARDSTS);\n\n\tmsleep(100);\n\n\t \n\tcb_writel(socket, CB_SOCKET_MASK, 0);\n\texca_writeb(socket, I365_CSCINT, reg);\n\tcb_writel(socket, CB_SOCKET_EVENT, -1);\n\texca_readb(socket, I365_CSC);\n\n\tfree_irq(socket->cb_irq, socket);\n\n\treturn (int) socket->probe_status;\n}\n\n#endif  \n\n\n \nstatic void yenta_get_socket_capabilities(struct yenta_socket *socket, u32 isa_irq_mask)\n{\n\tsocket->socket.pci_irq = socket->cb_irq;\n\tif (isa_probe)\n\t\tsocket->socket.irq_mask = yenta_probe_irq(socket, isa_irq_mask);\n\telse\n\t\tsocket->socket.irq_mask = 0;\n\n\tdev_info(&socket->dev->dev, \"ISA IRQ mask 0x%04x, PCI irq %d\\n\",\n\t\t socket->socket.irq_mask, socket->cb_irq);\n}\n\n \nstatic void yenta_config_init(struct yenta_socket *socket)\n{\n\tu16 bridge;\n\tstruct pci_dev *dev = socket->dev;\n\tstruct pci_bus_region region;\n\n\tpcibios_resource_to_bus(socket->dev->bus, &region, &dev->resource[0]);\n\n\tconfig_writel(socket, CB_LEGACY_MODE_BASE, 0);\n\tconfig_writel(socket, PCI_BASE_ADDRESS_0, region.start);\n\tconfig_writew(socket, PCI_COMMAND,\n\t\t\tPCI_COMMAND_IO |\n\t\t\tPCI_COMMAND_MEMORY |\n\t\t\tPCI_COMMAND_MASTER |\n\t\t\tPCI_COMMAND_WAIT);\n\n\t \n\tconfig_writeb(socket, PCI_CACHE_LINE_SIZE, L1_CACHE_BYTES / 4);\n\tconfig_writeb(socket, PCI_LATENCY_TIMER, 168);\n\tconfig_writel(socket, PCI_PRIMARY_BUS,\n\t\t(176 << 24) |\t\t\t    \n\t\t((unsigned int)dev->subordinate->busn_res.end << 16) |  \n\t\t((unsigned int)dev->subordinate->busn_res.start << 8) |   \n\t\tdev->subordinate->primary);\t\t    \n\n\t \n\tbridge = config_readw(socket, CB_BRIDGE_CONTROL);\n\tbridge &= ~(CB_BRIDGE_CRST | CB_BRIDGE_PREFETCH1 | CB_BRIDGE_ISAEN | CB_BRIDGE_VGAEN);\n\tbridge |= CB_BRIDGE_PREFETCH0 | CB_BRIDGE_POSTEN;\n\tconfig_writew(socket, CB_BRIDGE_CONTROL, bridge);\n}\n\n \nstatic void yenta_fixup_parent_bridge(struct pci_bus *cardbus_bridge)\n{\n\tstruct pci_bus *sibling;\n\tunsigned char upper_limit;\n\t \n\tstruct pci_bus *bridge_to_fix = cardbus_bridge->parent;\n\n\t \n\tif (bridge_to_fix->busn_res.end >= cardbus_bridge->busn_res.end)\n\t\treturn;  \n\n\tif (!bridge_to_fix->parent)\n\t\treturn;  \n\n\t \n\tupper_limit = bridge_to_fix->parent->busn_res.end;\n\n\t \n\tlist_for_each_entry(sibling, &bridge_to_fix->parent->children,\n\t\t\tnode) {\n\t\t \n\t\tif (sibling->busn_res.start > bridge_to_fix->busn_res.end\n\t\t    && sibling->busn_res.start <= upper_limit)\n\t\t\tupper_limit = sibling->busn_res.start - 1;\n\t}\n\n\t \n\tif (cardbus_bridge->busn_res.end > upper_limit)\n\t\tdev_warn(&cardbus_bridge->dev,\n\t\t\t \"Upper limit for fixing this bridge's parent bridge: #%02x\\n\",\n\t\t\t upper_limit);\n\n\t \n\tif (bridge_to_fix->busn_res.end < upper_limit) {\n\n\t\t \n\t\tunsigned char subordinate_to_assign =\n\t\t\tmin_t(int, cardbus_bridge->busn_res.end, upper_limit);\n\n\t\tdev_info(&bridge_to_fix->dev,\n\t\t\t \"Raising subordinate bus# of parent bus (#%02x) from #%02x to #%02x\\n\",\n\t\t\t bridge_to_fix->number,\n\t\t\t (int)bridge_to_fix->busn_res.end,\n\t\t\t subordinate_to_assign);\n\n\t\t \n\t\tbridge_to_fix->busn_res.end = subordinate_to_assign;\n\n\t\t \n\t\tpci_write_config_byte(bridge_to_fix->self,\n\t\t\tPCI_SUBORDINATE_BUS, bridge_to_fix->busn_res.end);\n\t}\n}\n\n \nstatic int yenta_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct yenta_socket *socket;\n\tint ret;\n\n\t \n\tif (!dev->subordinate) {\n\t\tdev_err(&dev->dev, \"no bus associated! (try 'pci=assign-busses')\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsocket = kzalloc(sizeof(struct yenta_socket), GFP_KERNEL);\n\tif (!socket)\n\t\treturn -ENOMEM;\n\n\t \n\tsocket->socket.ops = &yenta_socket_operations;\n\tsocket->socket.resource_ops = &pccard_nonstatic_ops;\n\tsocket->socket.dev.parent = &dev->dev;\n\tsocket->socket.driver_data = socket;\n\tsocket->socket.owner = THIS_MODULE;\n\tsocket->socket.features = SS_CAP_PAGE_REGS | SS_CAP_PCCARD;\n\tsocket->socket.map_size = 0x1000;\n\tsocket->socket.cb_dev = dev;\n\n\t \n\tsocket->dev = dev;\n\tpci_set_drvdata(dev, socket);\n\n\t \n\tif (pci_enable_device(dev)) {\n\t\tret = -EBUSY;\n\t\tgoto free;\n\t}\n\n\tret = pci_request_regions(dev, \"yenta_socket\");\n\tif (ret)\n\t\tgoto disable;\n\n\tif (!pci_resource_start(dev, 0)) {\n\t\tdev_err(&dev->dev, \"No cardbus resource!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto release;\n\t}\n\n\t \n\tsocket->base = ioremap(pci_resource_start(dev, 0), 0x1000);\n\tif (!socket->base) {\n\t\tret = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\t \n\tdev_info(&dev->dev, \"CardBus bridge found [%04x:%04x]\\n\",\n\t\t dev->subsystem_vendor, dev->subsystem_device);\n\n\tyenta_config_init(socket);\n\n\t \n\tcb_writel(socket, CB_SOCKET_MASK, 0x0);\n\n\t \n\tyenta_allocate_resources(socket);\n\n\tsocket->cb_irq = dev->irq;\n\n\t \n\tif (id->driver_data != CARDBUS_TYPE_DEFAULT &&\n\t    id->driver_data < ARRAY_SIZE(cardbus_type)) {\n\t\tsocket->type = &cardbus_type[id->driver_data];\n\n\t\tret = socket->type->override(socket);\n\t\tif (ret < 0)\n\t\t\tgoto unmap;\n\t}\n\n\t \n\n\tif (!socket->cb_irq || request_irq(socket->cb_irq, yenta_interrupt, IRQF_SHARED, \"yenta\", socket)) {\n\t\t \n\t\tsocket->cb_irq = 0;  \n\t\ttimer_setup(&socket->poll_timer, yenta_interrupt_wrapper, 0);\n\t\tmod_timer(&socket->poll_timer, jiffies + HZ);\n\t\tdev_info(&dev->dev,\n\t\t\t \"no PCI IRQ, CardBus support disabled for this socket.\\n\");\n\t\tdev_info(&dev->dev,\n\t\t\t \"check your BIOS CardBus, BIOS IRQ or ACPI settings.\\n\");\n\t} else {\n\t\tsocket->socket.features |= SS_CAP_CARDBUS;\n\t}\n\n\t \n\tyenta_interrogate(socket);\n\tyenta_get_socket_capabilities(socket, isa_interrupts);\n\tdev_info(&dev->dev, \"Socket status: %08x\\n\",\n\t\t cb_readl(socket, CB_SOCKET_STATE));\n\n\tyenta_fixup_parent_bridge(dev->subordinate);\n\n\t \n\tret = pcmcia_register_socket(&socket->socket);\n\tif (ret)\n\t\tgoto free_irq;\n\n\t \n\tret = device_create_file(&dev->dev, &dev_attr_yenta_registers);\n\tif (ret)\n\t\tgoto unregister_socket;\n\n\treturn ret;\n\n\t \n unregister_socket:\n\tpcmcia_unregister_socket(&socket->socket);\n free_irq:\n\tif (socket->cb_irq)\n\t\tfree_irq(socket->cb_irq, socket);\n\telse\n\t\ttimer_shutdown_sync(&socket->poll_timer);\n unmap:\n\tiounmap(socket->base);\n\tyenta_free_resources(socket);\n release:\n\tpci_release_regions(dev);\n disable:\n\tpci_disable_device(dev);\n free:\n\tpci_set_drvdata(dev, NULL);\n\tkfree(socket);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int yenta_dev_suspend_noirq(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct yenta_socket *socket = pci_get_drvdata(pdev);\n\n\tif (!socket)\n\t\treturn 0;\n\n\tif (socket->type && socket->type->save_state)\n\t\tsocket->type->save_state(socket);\n\n\tpci_save_state(pdev);\n\tpci_read_config_dword(pdev, 16*4, &socket->saved_state[0]);\n\tpci_read_config_dword(pdev, 17*4, &socket->saved_state[1]);\n\tpci_disable_device(pdev);\n\n\treturn 0;\n}\n\nstatic int yenta_dev_resume_noirq(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct yenta_socket *socket = pci_get_drvdata(pdev);\n\tint ret;\n\n\tif (!socket)\n\t\treturn 0;\n\n\tpci_write_config_dword(pdev, 16*4, socket->saved_state[0]);\n\tpci_write_config_dword(pdev, 17*4, socket->saved_state[1]);\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pdev);\n\n\tif (socket->type && socket->type->restore_state)\n\t\tsocket->type->restore_state(socket);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops yenta_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(yenta_dev_suspend_noirq, yenta_dev_resume_noirq)\n};\n\n#define YENTA_PM_OPS\t(&yenta_pm_ops)\n#else\n#define YENTA_PM_OPS\tNULL\n#endif\n\n#define CB_ID(vend, dev, type)\t\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.vendor\t\t= vend,\t\t\t\\\n\t\t.device\t\t= dev,\t\t\t\\\n\t\t.subvendor\t= PCI_ANY_ID,\t\t\\\n\t\t.subdevice\t= PCI_ANY_ID,\t\t\\\n\t\t.class\t\t= PCI_CLASS_BRIDGE_CARDBUS << 8, \\\n\t\t.class_mask\t= ~0,\t\t\t\\\n\t\t.driver_data\t= CARDBUS_TYPE_##type,\t\\\n\t}\n\nstatic const struct pci_device_id yenta_table[] = {\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1031, TI),\n\n\t \n#ifdef CONFIG_YENTA_TI\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1210, TI),\n\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1130, TI113X),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1131, TI113X),\n\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1211, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1220, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1221, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1225, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1251A, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1251B, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1420, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1450, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1451A, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1510, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1520, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1620, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_4410, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_4450, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_4451, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_4510, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_4520, TI12XX),\n\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1250, TI1250),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1410, TI1250),\n\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_XX21_XX11, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_X515, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_XX12, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_X420, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_X620, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_7410, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_7510, TI12XX),\n\tCB_ID(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_7610, TI12XX),\n\n\tCB_ID(PCI_VENDOR_ID_ENE, PCI_DEVICE_ID_ENE_710, ENE),\n\tCB_ID(PCI_VENDOR_ID_ENE, PCI_DEVICE_ID_ENE_712, ENE),\n\tCB_ID(PCI_VENDOR_ID_ENE, PCI_DEVICE_ID_ENE_720, ENE),\n\tCB_ID(PCI_VENDOR_ID_ENE, PCI_DEVICE_ID_ENE_722, ENE),\n\tCB_ID(PCI_VENDOR_ID_ENE, PCI_DEVICE_ID_ENE_1211, ENE),\n\tCB_ID(PCI_VENDOR_ID_ENE, PCI_DEVICE_ID_ENE_1225, ENE),\n\tCB_ID(PCI_VENDOR_ID_ENE, PCI_DEVICE_ID_ENE_1410, ENE),\n\tCB_ID(PCI_VENDOR_ID_ENE, PCI_DEVICE_ID_ENE_1420, ENE),\n#endif  \n\n#ifdef CONFIG_YENTA_RICOH\n\tCB_ID(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C465, RICOH),\n\tCB_ID(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C466, RICOH),\n\tCB_ID(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C475, RICOH),\n\tCB_ID(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C476, RICOH),\n\tCB_ID(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C478, RICOH),\n#endif\n\n#ifdef CONFIG_YENTA_TOSHIBA\n\tCB_ID(PCI_VENDOR_ID_TOSHIBA, PCI_DEVICE_ID_TOSHIBA_TOPIC95, TOPIC95),\n\tCB_ID(PCI_VENDOR_ID_TOSHIBA, PCI_DEVICE_ID_TOSHIBA_TOPIC97, TOPIC97),\n\tCB_ID(PCI_VENDOR_ID_TOSHIBA, PCI_DEVICE_ID_TOSHIBA_TOPIC100, TOPIC97),\n#endif\n\n#ifdef CONFIG_YENTA_O2\n\tCB_ID(PCI_VENDOR_ID_O2, PCI_ANY_ID, O2MICRO),\n#endif\n\n\t \n\tCB_ID(PCI_ANY_ID, PCI_ANY_ID, DEFAULT),\n\t{   }\n};\nMODULE_DEVICE_TABLE(pci, yenta_table);\n\n\nstatic struct pci_driver yenta_cardbus_driver = {\n\t.name\t\t= \"yenta_cardbus\",\n\t.id_table\t= yenta_table,\n\t.probe\t\t= yenta_probe,\n\t.remove\t\t= yenta_close,\n\t.driver.pm\t= YENTA_PM_OPS,\n};\n\nmodule_pci_driver(yenta_cardbus_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}