{
  "module_name": "soc_common.c",
  "hash_id": "2931b64301b82c51739840e860c23627a25a355f6b1ff878a54ea6b8cbeb6db5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/soc_common.c",
  "human_readable_source": " \n\n\n#include <linux/cpufreq.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/pci.h>\n\n#include \"soc_common.h\"\n\nstatic irqreturn_t soc_common_pcmcia_interrupt(int irq, void *dev);\n\n#ifdef CONFIG_PCMCIA_DEBUG\n\nstatic int pc_debug;\nmodule_param(pc_debug, int, 0644);\n\nvoid soc_pcmcia_debug(struct soc_pcmcia_socket *skt, const char *func,\n\t\t      int lvl, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tif (pc_debug > lvl) {\n\t\tva_start(args, fmt);\n\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_DEBUG \"skt%u: %s: %pV\", skt->nr, func, &vaf);\n\n\t\tva_end(args);\n\t}\n}\nEXPORT_SYMBOL(soc_pcmcia_debug);\n\n#endif\n\n#define to_soc_pcmcia_socket(x)\t\\\n\tcontainer_of(x, struct soc_pcmcia_socket, socket)\n\nint soc_pcmcia_regulator_set(struct soc_pcmcia_socket *skt,\n\tstruct soc_pcmcia_regulator *r, int v)\n{\n\tbool on;\n\tint ret;\n\n\tif (!r->reg)\n\t\treturn 0;\n\n\ton = v != 0;\n\tif (r->on == on)\n\t\treturn 0;\n\n\tif (on) {\n\t\tret = regulator_set_voltage(r->reg, v * 100000, v * 100000);\n\t\tif (ret) {\n\t\t\tint vout = regulator_get_voltage(r->reg) / 100000;\n\n\t\t\tdev_warn(&skt->socket.dev,\n\t\t\t\t \"CS requested %s=%u.%uV, applying %u.%uV\\n\",\n\t\t\t\t r == &skt->vcc ? \"Vcc\" : \"Vpp\",\n\t\t\t\t v / 10, v % 10, vout / 10, vout % 10);\n\t\t}\n\n\t\tret = regulator_enable(r->reg);\n\t} else {\n\t\tret = regulator_disable(r->reg);\n\t}\n\tif (ret == 0)\n\t\tr->on = on;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(soc_pcmcia_regulator_set);\n\nstatic unsigned short\ncalc_speed(unsigned short *spds, int num, unsigned short dflt)\n{\n\tunsigned short speed = 0;\n\tint i;\n\n\tfor (i = 0; i < num; i++)\n\t\tif (speed < spds[i])\n\t\t\tspeed = spds[i];\n\tif (speed == 0)\n\t\tspeed = dflt;\n\n\treturn speed;\n}\n\nvoid soc_common_pcmcia_get_timing(struct soc_pcmcia_socket *skt,\n\tstruct soc_pcmcia_timing *timing)\n{\n\ttiming->io =\n\t\tcalc_speed(skt->spd_io, MAX_IO_WIN, SOC_PCMCIA_IO_ACCESS);\n\ttiming->mem =\n\t\tcalc_speed(skt->spd_mem, MAX_WIN, SOC_PCMCIA_3V_MEM_ACCESS);\n\ttiming->attr =\n\t\tcalc_speed(skt->spd_attr, MAX_WIN, SOC_PCMCIA_3V_MEM_ACCESS);\n}\nEXPORT_SYMBOL(soc_common_pcmcia_get_timing);\n\nstatic void __soc_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt,\n\tunsigned int nr)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < nr; i++)\n\t\tif (skt->stat[i].irq)\n\t\t\tfree_irq(skt->stat[i].irq, skt);\n\n\tif (skt->ops->hw_shutdown)\n\t\tskt->ops->hw_shutdown(skt);\n\n\tclk_disable_unprepare(skt->clk);\n}\n\nstatic void soc_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)\n{\n\t__soc_pcmcia_hw_shutdown(skt, ARRAY_SIZE(skt->stat));\n}\n\nint soc_pcmcia_request_gpiods(struct soc_pcmcia_socket *skt)\n{\n\tstruct device *dev = skt->socket.dev.parent;\n\tstruct gpio_desc *desc;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(skt->stat); i++) {\n\t\tif (!skt->stat[i].name)\n\t\t\tcontinue;\n\n\t\tdesc = devm_gpiod_get(dev, skt->stat[i].name, GPIOD_IN);\n\t\tif (IS_ERR(desc)) {\n\t\t\tdev_err(dev, \"Failed to get GPIO for %s: %ld\\n\",\n\t\t\t\tskt->stat[i].name, PTR_ERR(desc));\n\t\t\treturn PTR_ERR(desc);\n\t\t}\n\n\t\tskt->stat[i].desc = desc;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(soc_pcmcia_request_gpiods);\n\nstatic int soc_pcmcia_hw_init(struct soc_pcmcia_socket *skt)\n{\n\tint ret = 0, i;\n\n\tret = clk_prepare_enable(skt->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (skt->ops->hw_init) {\n\t\tret = skt->ops->hw_init(skt);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(skt->clk);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(skt->stat); i++) {\n\t\tif (gpio_is_valid(skt->stat[i].gpio)) {\n\t\t\tunsigned long flags = GPIOF_IN;\n\n\t\t\t \n\t\t\tif (i == SOC_STAT_CD)\n\t\t\t\tflags |= GPIOF_ACTIVE_LOW;\n\n\t\t\tret = devm_gpio_request_one(skt->socket.dev.parent,\n\t\t\t\t\t\t    skt->stat[i].gpio, flags,\n\t\t\t\t\t\t    skt->stat[i].name);\n\t\t\tif (ret) {\n\t\t\t\t__soc_pcmcia_hw_shutdown(skt, i);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tskt->stat[i].desc = gpio_to_desc(skt->stat[i].gpio);\n\t\t}\n\n\t\tif (i < SOC_STAT_VS1 && skt->stat[i].desc) {\n\t\t\tint irq = gpiod_to_irq(skt->stat[i].desc);\n\n\t\t\tif (irq > 0) {\n\t\t\t\tif (i == SOC_STAT_RDY)\n\t\t\t\t\tskt->socket.pci_irq = irq;\n\t\t\t\telse\n\t\t\t\t\tskt->stat[i].irq = irq;\n\t\t\t}\n\t\t}\n\n\t\tif (skt->stat[i].irq) {\n\t\t\tret = request_irq(skt->stat[i].irq,\n\t\t\t\t\t  soc_common_pcmcia_interrupt,\n\t\t\t\t\t  IRQF_TRIGGER_NONE,\n\t\t\t\t\t  skt->stat[i].name, skt);\n\t\t\tif (ret) {\n\t\t\t\t__soc_pcmcia_hw_shutdown(skt, i);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void soc_pcmcia_hw_enable(struct soc_pcmcia_socket *skt)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(skt->stat); i++)\n\t\tif (skt->stat[i].irq) {\n\t\t\tirq_set_irq_type(skt->stat[i].irq, IRQ_TYPE_EDGE_RISING);\n\t\t\tirq_set_irq_type(skt->stat[i].irq, IRQ_TYPE_EDGE_BOTH);\n\t\t}\n}\n\nstatic void soc_pcmcia_hw_disable(struct soc_pcmcia_socket *skt)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(skt->stat); i++)\n\t\tif (skt->stat[i].irq)\n\t\t\tirq_set_irq_type(skt->stat[i].irq, IRQ_TYPE_NONE);\n}\n\n \nvoid soc_common_cf_socket_state(struct soc_pcmcia_socket *skt,\n\tstruct pcmcia_state *state)\n{\n\tstate->vs_3v = 1;\n}\nEXPORT_SYMBOL_GPL(soc_common_cf_socket_state);\n\nstatic unsigned int soc_common_pcmcia_skt_state(struct soc_pcmcia_socket *skt)\n{\n\tstruct pcmcia_state state;\n\tunsigned int stat;\n\n\tmemset(&state, 0, sizeof(struct pcmcia_state));\n\n\t \n\tstate.bvd1 = 1;\n\tstate.bvd2 = 1;\n\n\tif (skt->stat[SOC_STAT_CD].desc)\n\t\tstate.detect = !!gpiod_get_value(skt->stat[SOC_STAT_CD].desc);\n\tif (skt->stat[SOC_STAT_RDY].desc)\n\t\tstate.ready = !!gpiod_get_value(skt->stat[SOC_STAT_RDY].desc);\n\tif (skt->stat[SOC_STAT_BVD1].desc)\n\t\tstate.bvd1 = !!gpiod_get_value(skt->stat[SOC_STAT_BVD1].desc);\n\tif (skt->stat[SOC_STAT_BVD2].desc)\n\t\tstate.bvd2 = !!gpiod_get_value(skt->stat[SOC_STAT_BVD2].desc);\n\tif (skt->stat[SOC_STAT_VS1].desc)\n\t\tstate.vs_3v = !!gpiod_get_value(skt->stat[SOC_STAT_VS1].desc);\n\tif (skt->stat[SOC_STAT_VS2].desc)\n\t\tstate.vs_Xv = !!gpiod_get_value(skt->stat[SOC_STAT_VS2].desc);\n\n\tskt->ops->socket_state(skt, &state);\n\n\tstat = state.detect  ? SS_DETECT : 0;\n\tstat |= state.ready  ? SS_READY  : 0;\n\tstat |= state.wrprot ? SS_WRPROT : 0;\n\tstat |= state.vs_3v  ? SS_3VCARD : 0;\n\tstat |= state.vs_Xv  ? SS_XVCARD : 0;\n\n\t \n\tstat |= skt->cs_state.Vcc ? SS_POWERON : 0;\n\n\tif (skt->cs_state.flags & SS_IOCARD)\n\t\tstat |= state.bvd1 ? 0 : SS_STSCHG;\n\telse {\n\t\tif (state.bvd1 == 0)\n\t\t\tstat |= SS_BATDEAD;\n\t\telse if (state.bvd2 == 0)\n\t\t\tstat |= SS_BATWARN;\n\t}\n\treturn stat;\n}\n\n \nstatic int soc_common_pcmcia_config_skt(\n\tstruct soc_pcmcia_socket *skt, socket_state_t *state)\n{\n\tint ret;\n\n\tret = skt->ops->configure_socket(skt, state);\n\tif (ret < 0) {\n\t\tpr_err(\"soc_common_pcmcia: unable to configure socket %d\\n\",\n\t\t       skt->nr);\n\t\t \n\t\tWARN_ON(skt->ops->configure_socket(skt, &skt->cs_state));\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\tstruct gpio_desc *descs[2];\n\t\tDECLARE_BITMAP(values, 2);\n\t\tint n = 0;\n\n\t\tif (skt->gpio_reset) {\n\t\t\tdescs[n] = skt->gpio_reset;\n\t\t\t__assign_bit(n++, values, state->flags & SS_RESET);\n\t\t}\n\t\tif (skt->gpio_bus_enable) {\n\t\t\tdescs[n] = skt->gpio_bus_enable;\n\t\t\t__assign_bit(n++, values, state->flags & SS_OUTPUT_ENA);\n\t\t}\n\n\t\tif (n)\n\t\t\tgpiod_set_array_value_cansleep(n, descs, NULL, values);\n\n\t\t \n\t\tif (skt->irq_state != 1 && state->io_irq) {\n\t\t\tskt->irq_state = 1;\n\t\t\tirq_set_irq_type(skt->socket.pci_irq,\n\t\t\t\t\t IRQ_TYPE_EDGE_FALLING);\n\t\t} else if (skt->irq_state == 1 && state->io_irq == 0) {\n\t\t\tskt->irq_state = 0;\n\t\t\tirq_set_irq_type(skt->socket.pci_irq, IRQ_TYPE_NONE);\n\t\t}\n\n\t\tskt->cs_state = *state;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int soc_common_pcmcia_sock_init(struct pcmcia_socket *sock)\n{\n\tstruct soc_pcmcia_socket *skt = to_soc_pcmcia_socket(sock);\n\n\tdebug(skt, 2, \"initializing socket\\n\");\n\tif (skt->ops->socket_init)\n\t\tskt->ops->socket_init(skt);\n\tsoc_pcmcia_hw_enable(skt);\n\treturn 0;\n}\n\n\n \nstatic int soc_common_pcmcia_suspend(struct pcmcia_socket *sock)\n{\n\tstruct soc_pcmcia_socket *skt = to_soc_pcmcia_socket(sock);\n\n\tdebug(skt, 2, \"suspending socket\\n\");\n\n\tsoc_pcmcia_hw_disable(skt);\n\tif (skt->ops->socket_suspend)\n\t\tskt->ops->socket_suspend(skt);\n\n\treturn 0;\n}\n\nstatic DEFINE_SPINLOCK(status_lock);\n\nstatic void soc_common_check_status(struct soc_pcmcia_socket *skt)\n{\n\tunsigned int events;\n\n\tdebug(skt, 4, \"entering PCMCIA monitoring thread\\n\");\n\n\tdo {\n\t\tunsigned int status;\n\t\tunsigned long flags;\n\n\t\tstatus = soc_common_pcmcia_skt_state(skt);\n\n\t\tspin_lock_irqsave(&status_lock, flags);\n\t\tevents = (status ^ skt->status) & skt->cs_state.csc_mask;\n\t\tskt->status = status;\n\t\tspin_unlock_irqrestore(&status_lock, flags);\n\n\t\tdebug(skt, 4, \"events: %s%s%s%s%s%s\\n\",\n\t\t\tevents == 0         ? \"<NONE>\"   : \"\",\n\t\t\tevents & SS_DETECT  ? \"DETECT \"  : \"\",\n\t\t\tevents & SS_READY   ? \"READY \"   : \"\",\n\t\t\tevents & SS_BATDEAD ? \"BATDEAD \" : \"\",\n\t\t\tevents & SS_BATWARN ? \"BATWARN \" : \"\",\n\t\t\tevents & SS_STSCHG  ? \"STSCHG \"  : \"\");\n\n\t\tif (events)\n\t\t\tpcmcia_parse_events(&skt->socket, events);\n\t} while (events);\n}\n\n \nstatic void soc_common_pcmcia_poll_event(struct timer_list *t)\n{\n\tstruct soc_pcmcia_socket *skt = from_timer(skt, t, poll_timer);\n\tdebug(skt, 4, \"polling for events\\n\");\n\n\tmod_timer(&skt->poll_timer, jiffies + SOC_PCMCIA_POLL_PERIOD);\n\n\tsoc_common_check_status(skt);\n}\n\n\n \nstatic irqreturn_t soc_common_pcmcia_interrupt(int irq, void *dev)\n{\n\tstruct soc_pcmcia_socket *skt = dev;\n\n\tdebug(skt, 3, \"servicing IRQ %d\\n\", irq);\n\n\tsoc_common_check_status(skt);\n\n\treturn IRQ_HANDLED;\n}\n\n\n \nstatic int\nsoc_common_pcmcia_get_status(struct pcmcia_socket *sock, unsigned int *status)\n{\n\tstruct soc_pcmcia_socket *skt = to_soc_pcmcia_socket(sock);\n\n\tskt->status = soc_common_pcmcia_skt_state(skt);\n\t*status = skt->status;\n\n\treturn 0;\n}\n\n\n \nstatic int soc_common_pcmcia_set_socket(\n\tstruct pcmcia_socket *sock, socket_state_t *state)\n{\n\tstruct soc_pcmcia_socket *skt = to_soc_pcmcia_socket(sock);\n\n\tdebug(skt, 2, \"mask: %s%s%s%s%s%s flags: %s%s%s%s%s%s Vcc %d Vpp %d irq %d\\n\",\n\t\t\t(state->csc_mask == 0)\t\t? \"<NONE> \" :\t\"\",\n\t\t\t(state->csc_mask & SS_DETECT)\t? \"DETECT \" :\t\"\",\n\t\t\t(state->csc_mask & SS_READY)\t? \"READY \" :\t\"\",\n\t\t\t(state->csc_mask & SS_BATDEAD)\t? \"BATDEAD \" :\t\"\",\n\t\t\t(state->csc_mask & SS_BATWARN)\t? \"BATWARN \" :\t\"\",\n\t\t\t(state->csc_mask & SS_STSCHG)\t? \"STSCHG \" :\t\"\",\n\t\t\t(state->flags == 0)\t\t? \"<NONE> \" :\t\"\",\n\t\t\t(state->flags & SS_PWR_AUTO)\t? \"PWR_AUTO \" :\t\"\",\n\t\t\t(state->flags & SS_IOCARD)\t? \"IOCARD \" :\t\"\",\n\t\t\t(state->flags & SS_RESET)\t? \"RESET \" :\t\"\",\n\t\t\t(state->flags & SS_SPKR_ENA)\t? \"SPKR_ENA \" :\t\"\",\n\t\t\t(state->flags & SS_OUTPUT_ENA)\t? \"OUTPUT_ENA \" : \"\",\n\t\t\tstate->Vcc, state->Vpp, state->io_irq);\n\n\treturn soc_common_pcmcia_config_skt(skt, state);\n}\n\n\n \nstatic int soc_common_pcmcia_set_io_map(\n\tstruct pcmcia_socket *sock, struct pccard_io_map *map)\n{\n\tstruct soc_pcmcia_socket *skt = to_soc_pcmcia_socket(sock);\n\tunsigned short speed = map->speed;\n\n\tdebug(skt, 2, \"map %u  speed %u start 0x%08llx stop 0x%08llx\\n\",\n\t\tmap->map, map->speed, (unsigned long long)map->start,\n\t\t(unsigned long long)map->stop);\n\tdebug(skt, 2, \"flags: %s%s%s%s%s%s%s%s\\n\",\n\t\t(map->flags == 0)\t\t? \"<NONE>\"\t: \"\",\n\t\t(map->flags & MAP_ACTIVE)\t? \"ACTIVE \"\t: \"\",\n\t\t(map->flags & MAP_16BIT)\t? \"16BIT \"\t: \"\",\n\t\t(map->flags & MAP_AUTOSZ)\t? \"AUTOSZ \"\t: \"\",\n\t\t(map->flags & MAP_0WS)\t\t? \"0WS \"\t: \"\",\n\t\t(map->flags & MAP_WRPROT)\t? \"WRPROT \"\t: \"\",\n\t\t(map->flags & MAP_USE_WAIT)\t? \"USE_WAIT \"\t: \"\",\n\t\t(map->flags & MAP_PREFETCH)\t? \"PREFETCH \"\t: \"\");\n\n\tif (map->map >= MAX_IO_WIN) {\n\t\tprintk(KERN_ERR \"%s(): map (%d) out of range\\n\", __func__,\n\t\t       map->map);\n\t\treturn -1;\n\t}\n\n\tif (map->flags & MAP_ACTIVE) {\n\t\tif (speed == 0)\n\t\t\tspeed = SOC_PCMCIA_IO_ACCESS;\n\t} else {\n\t\tspeed = 0;\n\t}\n\n\tskt->spd_io[map->map] = speed;\n\tskt->ops->set_timing(skt);\n\n\tif (map->stop == 1)\n\t\tmap->stop = PAGE_SIZE-1;\n\n\tmap->stop -= map->start;\n\tmap->stop += skt->socket.io_offset;\n\tmap->start = skt->socket.io_offset;\n\n\treturn 0;\n}\n\n\n \nstatic int soc_common_pcmcia_set_mem_map(\n\tstruct pcmcia_socket *sock, struct pccard_mem_map *map)\n{\n\tstruct soc_pcmcia_socket *skt = to_soc_pcmcia_socket(sock);\n\tstruct resource *res;\n\tunsigned short speed = map->speed;\n\n\tdebug(skt, 2, \"map %u speed %u card_start %08x\\n\",\n\t\tmap->map, map->speed, map->card_start);\n\tdebug(skt, 2, \"flags: %s%s%s%s%s%s%s%s\\n\",\n\t\t(map->flags == 0)\t\t? \"<NONE>\"\t: \"\",\n\t\t(map->flags & MAP_ACTIVE)\t? \"ACTIVE \"\t: \"\",\n\t\t(map->flags & MAP_16BIT)\t? \"16BIT \"\t: \"\",\n\t\t(map->flags & MAP_AUTOSZ)\t? \"AUTOSZ \"\t: \"\",\n\t\t(map->flags & MAP_0WS)\t\t? \"0WS \"\t: \"\",\n\t\t(map->flags & MAP_WRPROT)\t? \"WRPROT \"\t: \"\",\n\t\t(map->flags & MAP_ATTRIB)\t? \"ATTRIB \"\t: \"\",\n\t\t(map->flags & MAP_USE_WAIT)\t? \"USE_WAIT \"\t: \"\");\n\n\tif (map->map >= MAX_WIN)\n\t\treturn -EINVAL;\n\n\tif (map->flags & MAP_ACTIVE) {\n\t\tif (speed == 0)\n\t\t\tspeed = 300;\n\t} else {\n\t\tspeed = 0;\n\t}\n\n\tif (map->flags & MAP_ATTRIB) {\n\t\tres = &skt->res_attr;\n\t\tskt->spd_attr[map->map] = speed;\n\t\tskt->spd_mem[map->map] = 0;\n\t} else {\n\t\tres = &skt->res_mem;\n\t\tskt->spd_attr[map->map] = 0;\n\t\tskt->spd_mem[map->map] = speed;\n\t}\n\n\tskt->ops->set_timing(skt);\n\n\tmap->static_start = res->start + map->card_start;\n\n\treturn 0;\n}\n\nstruct bittbl {\n\tunsigned int mask;\n\tconst char *name;\n};\n\nstatic struct bittbl status_bits[] = {\n\t{ SS_WRPROT,\t\t\"SS_WRPROT\"\t},\n\t{ SS_BATDEAD,\t\t\"SS_BATDEAD\"\t},\n\t{ SS_BATWARN,\t\t\"SS_BATWARN\"\t},\n\t{ SS_READY,\t\t\"SS_READY\"\t},\n\t{ SS_DETECT,\t\t\"SS_DETECT\"\t},\n\t{ SS_POWERON,\t\t\"SS_POWERON\"\t},\n\t{ SS_STSCHG,\t\t\"SS_STSCHG\"\t},\n\t{ SS_3VCARD,\t\t\"SS_3VCARD\"\t},\n\t{ SS_XVCARD,\t\t\"SS_XVCARD\"\t},\n};\n\nstatic struct bittbl conf_bits[] = {\n\t{ SS_PWR_AUTO,\t\t\"SS_PWR_AUTO\"\t},\n\t{ SS_IOCARD,\t\t\"SS_IOCARD\"\t},\n\t{ SS_RESET,\t\t\"SS_RESET\"\t},\n\t{ SS_DMA_MODE,\t\t\"SS_DMA_MODE\"\t},\n\t{ SS_SPKR_ENA,\t\t\"SS_SPKR_ENA\"\t},\n\t{ SS_OUTPUT_ENA,\t\"SS_OUTPUT_ENA\"\t},\n};\n\nstatic void dump_bits(char **p, const char *prefix,\n\tunsigned int val, struct bittbl *bits, int sz)\n{\n\tchar *b = *p;\n\tint i;\n\n\tb += sprintf(b, \"%-9s:\", prefix);\n\tfor (i = 0; i < sz; i++)\n\t\tif (val & bits[i].mask)\n\t\t\tb += sprintf(b, \" %s\", bits[i].name);\n\t*b++ = '\\n';\n\t*p = b;\n}\n\n \nstatic ssize_t show_status(\n\tstruct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct soc_pcmcia_socket *skt =\n\t\tcontainer_of(dev, struct soc_pcmcia_socket, socket.dev);\n\tchar *p = buf;\n\n\tp += sprintf(p, \"slot     : %d\\n\", skt->nr);\n\n\tdump_bits(&p, \"status\", skt->status,\n\t\t  status_bits, ARRAY_SIZE(status_bits));\n\tdump_bits(&p, \"csc_mask\", skt->cs_state.csc_mask,\n\t\t  status_bits, ARRAY_SIZE(status_bits));\n\tdump_bits(&p, \"cs_flags\", skt->cs_state.flags,\n\t\t  conf_bits, ARRAY_SIZE(conf_bits));\n\n\tp += sprintf(p, \"Vcc      : %d\\n\", skt->cs_state.Vcc);\n\tp += sprintf(p, \"Vpp      : %d\\n\", skt->cs_state.Vpp);\n\tp += sprintf(p, \"IRQ      : %d (%d)\\n\", skt->cs_state.io_irq,\n\t\tskt->socket.pci_irq);\n\tif (skt->ops->show_timing)\n\t\tp += skt->ops->show_timing(skt, p);\n\n\treturn p-buf;\n}\nstatic DEVICE_ATTR(status, S_IRUGO, show_status, NULL);\n\n\nstatic struct pccard_operations soc_common_pcmcia_operations = {\n\t.init\t\t\t= soc_common_pcmcia_sock_init,\n\t.suspend\t\t= soc_common_pcmcia_suspend,\n\t.get_status\t\t= soc_common_pcmcia_get_status,\n\t.set_socket\t\t= soc_common_pcmcia_set_socket,\n\t.set_io_map\t\t= soc_common_pcmcia_set_io_map,\n\t.set_mem_map\t\t= soc_common_pcmcia_set_mem_map,\n};\n\n\n#ifdef CONFIG_CPU_FREQ\nstatic int soc_common_pcmcia_cpufreq_nb(struct notifier_block *nb,\n\tunsigned long val, void *data)\n{\n\tstruct soc_pcmcia_socket *skt = container_of(nb, struct soc_pcmcia_socket, cpufreq_nb);\n\tstruct cpufreq_freqs *freqs = data;\n\n\treturn skt->ops->frequency_change(skt, val, freqs);\n}\n#endif\n\nvoid soc_pcmcia_init_one(struct soc_pcmcia_socket *skt,\n\tconst struct pcmcia_low_level *ops, struct device *dev)\n{\n\tint i;\n\n\tskt->ops = ops;\n\tskt->socket.owner = ops->owner;\n\tskt->socket.dev.parent = dev;\n\tskt->socket.pci_irq = NO_IRQ;\n\n\tfor (i = 0; i < ARRAY_SIZE(skt->stat); i++)\n\t\tskt->stat[i].gpio = -EINVAL;\n}\nEXPORT_SYMBOL(soc_pcmcia_init_one);\n\nvoid soc_pcmcia_remove_one(struct soc_pcmcia_socket *skt)\n{\n\tdel_timer_sync(&skt->poll_timer);\n\n\tpcmcia_unregister_socket(&skt->socket);\n\n#ifdef CONFIG_CPU_FREQ\n\tif (skt->ops->frequency_change)\n\t\tcpufreq_unregister_notifier(&skt->cpufreq_nb,\n\t\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n#endif\n\n\tsoc_pcmcia_hw_shutdown(skt);\n\n\t \n\tsoc_common_pcmcia_config_skt(skt, &dead_socket);\n\n\tiounmap(PCI_IOBASE + skt->res_io_io.start);\n\trelease_resource(&skt->res_attr);\n\trelease_resource(&skt->res_mem);\n\trelease_resource(&skt->res_io);\n\trelease_resource(&skt->res_skt);\n}\nEXPORT_SYMBOL(soc_pcmcia_remove_one);\n\nint soc_pcmcia_add_one(struct soc_pcmcia_socket *skt)\n{\n\tint ret;\n\n\tskt->cs_state = dead_socket;\n\n\ttimer_setup(&skt->poll_timer, soc_common_pcmcia_poll_event, 0);\n\tskt->poll_timer.expires = jiffies + SOC_PCMCIA_POLL_PERIOD;\n\n\tret = request_resource(&iomem_resource, &skt->res_skt);\n\tif (ret)\n\t\tgoto out_err_1;\n\n\tret = request_resource(&skt->res_skt, &skt->res_io);\n\tif (ret)\n\t\tgoto out_err_2;\n\n\tret = request_resource(&skt->res_skt, &skt->res_mem);\n\tif (ret)\n\t\tgoto out_err_3;\n\n\tret = request_resource(&skt->res_skt, &skt->res_attr);\n\tif (ret)\n\t\tgoto out_err_4;\n\n\tskt->res_io_io = (struct resource)\n\t\t DEFINE_RES_IO_NAMED(skt->nr * 0x1000 + 0x10000, 0x1000,\n\t\t\t\t     \"PCMCIA I/O\");\n\tret = pci_remap_iospace(&skt->res_io_io, skt->res_io.start);\n\tif (ret)\n\t\tgoto out_err_5;\n\n\t \n\tskt->ops->set_timing(skt);\n\n\tret = soc_pcmcia_hw_init(skt);\n\tif (ret)\n\t\tgoto out_err_6;\n\n\tskt->socket.ops = &soc_common_pcmcia_operations;\n\tskt->socket.features = SS_CAP_STATIC_MAP|SS_CAP_PCCARD;\n\tskt->socket.resource_ops = &pccard_static_ops;\n\tskt->socket.irq_mask = 0;\n\tskt->socket.map_size = PAGE_SIZE;\n\tskt->socket.io_offset = (unsigned long)skt->res_io_io.start;\n\n\tskt->status = soc_common_pcmcia_skt_state(skt);\n\n#ifdef CONFIG_CPU_FREQ\n\tif (skt->ops->frequency_change) {\n\t\tskt->cpufreq_nb.notifier_call = soc_common_pcmcia_cpufreq_nb;\n\n\t\tret = cpufreq_register_notifier(&skt->cpufreq_nb,\n\t\t\t\t\t\tCPUFREQ_TRANSITION_NOTIFIER);\n\t\tif (ret < 0)\n\t\t\tdev_err(skt->socket.dev.parent,\n\t\t\t\t\"unable to register CPU frequency change notifier for PCMCIA (%d)\\n\",\n\t\t\t\tret);\n\t}\n#endif\n\n\tret = pcmcia_register_socket(&skt->socket);\n\tif (ret)\n\t\tgoto out_err_7;\n\n\tret = device_create_file(&skt->socket.dev, &dev_attr_status);\n\tif (ret)\n\t\tgoto out_err_8;\n\n\treturn ret;\n\n out_err_8:\n\tdel_timer_sync(&skt->poll_timer);\n\tpcmcia_unregister_socket(&skt->socket);\n\n out_err_7:\n\tsoc_pcmcia_hw_shutdown(skt);\n out_err_6:\n\tiounmap(PCI_IOBASE + skt->res_io_io.start);\n out_err_5:\n\trelease_resource(&skt->res_attr);\n out_err_4:\n\trelease_resource(&skt->res_mem);\n out_err_3:\n\trelease_resource(&skt->res_io);\n out_err_2:\n\trelease_resource(&skt->res_skt);\n out_err_1:\n\n\treturn ret;\n}\nEXPORT_SYMBOL(soc_pcmcia_add_one);\n\nMODULE_AUTHOR(\"John Dorsey <john+@cs.cmu.edu>\");\nMODULE_DESCRIPTION(\"Linux PCMCIA Card Services: Common SoC support\");\nMODULE_LICENSE(\"Dual MPL/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}