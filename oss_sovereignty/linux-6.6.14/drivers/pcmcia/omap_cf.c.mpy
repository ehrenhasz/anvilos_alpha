{
  "module_name": "omap_cf.c",
  "hash_id": "59d808118a12f697e0b1ca44a39210dbc40aefb496c6d2c56badfb1002556c0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/omap_cf.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n\n#include <pcmcia/ss.h>\n\n#include <asm/io.h>\n#include <linux/sizes.h>\n\n#include <linux/soc/ti/omap1-io.h>\n#include <linux/soc/ti/omap1-soc.h>\n#include <linux/soc/ti/omap1-mux.h>\n\n \n#define\tCF_BASE\t0xfffe2800\n\n \n#define CF_STATUS\t\t\t(CF_BASE + 0x00)\n#\tdefine\tCF_STATUS_BAD_READ\t(1 << 2)\n#\tdefine\tCF_STATUS_BAD_WRITE\t(1 << 1)\n#\tdefine\tCF_STATUS_CARD_DETECT\t(1 << 0)\n\n \n#define CF_CFG\t\t\t\t(CF_BASE + 0x02)\n\n \n#define CF_CONTROL\t\t\t(CF_BASE + 0x04)\n#\tdefine\tCF_CONTROL_RESET\t(1 << 0)\n\n#define omap_cf_present() (!(omap_readw(CF_STATUS) & CF_STATUS_CARD_DETECT))\n\n \n\nstatic const char driver_name[] = \"omap_cf\";\n\nstruct omap_cf_socket {\n\tstruct pcmcia_socket\tsocket;\n\n\tstruct timer_list\ttimer;\n\tunsigned\t\tpresent:1;\n\tunsigned\t\tactive:1;\n\n\tstruct platform_device\t*pdev;\n\tunsigned long\t\tphys_cf;\n\tu_int\t\t\tirq;\n\tstruct resource\t\tiomem;\n};\n\n#define\tPOLL_INTERVAL\t\t(2 * HZ)\n\n \n\nstatic int omap_cf_ss_init(struct pcmcia_socket *s)\n{\n\treturn 0;\n}\n\n \nstatic void omap_cf_timer(struct timer_list *t)\n{\n\tstruct omap_cf_socket\t*cf = from_timer(cf, t, timer);\n\tunsigned\t\tpresent = omap_cf_present();\n\n\tif (present != cf->present) {\n\t\tcf->present = present;\n\t\tpr_debug(\"%s: card %s\\n\", driver_name,\n\t\t\tpresent ? \"present\" : \"gone\");\n\t\tpcmcia_parse_events(&cf->socket, SS_DETECT);\n\t}\n\n\tif (cf->active)\n\t\tmod_timer(&cf->timer, jiffies + POLL_INTERVAL);\n}\n\n \nstatic irqreturn_t omap_cf_irq(int irq, void *_cf)\n{\n\tstruct omap_cf_socket *cf = (struct omap_cf_socket *)_cf;\n\n\tomap_cf_timer(&cf->timer);\n\treturn IRQ_HANDLED;\n}\n\nstatic int omap_cf_get_status(struct pcmcia_socket *s, u_int *sp)\n{\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\t \n\tif (omap_cf_present()) {\n\t\tstruct omap_cf_socket\t*cf;\n\n\t\t*sp = SS_READY | SS_DETECT | SS_POWERON | SS_3VCARD;\n\t\tcf = container_of(s, struct omap_cf_socket, socket);\n\t\ts->pcmcia_irq = 0;\n\t\ts->pci_irq = cf->irq;\n\t} else\n\t\t*sp = 0;\n\treturn 0;\n}\n\nstatic int\nomap_cf_set_socket(struct pcmcia_socket *sock, struct socket_state_t *s)\n{\n\t \n\tswitch (s->Vcc) {\n\tcase 0:\n\tcase 33:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tomap_readw(CF_CONTROL);\n\tif (s->flags & SS_RESET)\n\t\tomap_writew(CF_CONTROL_RESET, CF_CONTROL);\n\telse\n\t\tomap_writew(0, CF_CONTROL);\n\n\tpr_debug(\"%s: Vcc %d, io_irq %d, flags %04x csc %04x\\n\",\n\t\tdriver_name, s->Vcc, s->io_irq, s->flags, s->csc_mask);\n\n\treturn 0;\n}\n\nstatic int omap_cf_ss_suspend(struct pcmcia_socket *s)\n{\n\tpr_debug(\"%s: %s\\n\", driver_name, __func__);\n\treturn omap_cf_set_socket(s, &dead_socket);\n}\n\n \n\nstatic int\nomap_cf_set_io_map(struct pcmcia_socket *s, struct pccard_io_map *io)\n{\n\tstruct omap_cf_socket\t*cf;\n\n\tcf = container_of(s, struct omap_cf_socket, socket);\n\tio->flags &= MAP_ACTIVE|MAP_ATTRIB|MAP_16BIT;\n\tio->start = cf->phys_cf + SZ_4K;\n\tio->stop = io->start + SZ_2K - 1;\n\treturn 0;\n}\n\nstatic int\nomap_cf_set_mem_map(struct pcmcia_socket *s, struct pccard_mem_map *map)\n{\n\tstruct omap_cf_socket\t*cf;\n\n\tif (map->card_start)\n\t\treturn -EINVAL;\n\tcf = container_of(s, struct omap_cf_socket, socket);\n\tmap->static_start = cf->phys_cf;\n\tmap->flags &= MAP_ACTIVE|MAP_ATTRIB|MAP_16BIT;\n\tif (map->flags & MAP_ATTRIB)\n\t\tmap->static_start += SZ_2K;\n\treturn 0;\n}\n\nstatic struct pccard_operations omap_cf_ops = {\n\t.init\t\t\t= omap_cf_ss_init,\n\t.suspend\t\t= omap_cf_ss_suspend,\n\t.get_status\t\t= omap_cf_get_status,\n\t.set_socket\t\t= omap_cf_set_socket,\n\t.set_io_map\t\t= omap_cf_set_io_map,\n\t.set_mem_map\t\t= omap_cf_set_mem_map,\n};\n\n \n\n \n\nstatic int __init omap_cf_probe(struct platform_device *pdev)\n{\n\tunsigned\t\tseg;\n\tstruct omap_cf_socket\t*cf;\n\tint\t\t\tirq;\n\tint\t\t\tstatus;\n\tstruct resource\t\t*res;\n\tstruct resource\t\tiospace = DEFINE_RES_IO(SZ_64, SZ_4K);\n\n\tseg = (int) pdev->dev.platform_data;\n\tif (seg == 0 || seg > 3)\n\t\treturn -ENODEV;\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tcf = kzalloc(sizeof *cf, GFP_KERNEL);\n\tif (!cf)\n\t\treturn -ENOMEM;\n\ttimer_setup(&cf->timer, omap_cf_timer, 0);\n\n\tcf->pdev = pdev;\n\tplatform_set_drvdata(pdev, cf);\n\n\t \n\tstatus = request_irq(irq, omap_cf_irq, IRQF_SHARED,\n\t\t\tdriver_name, cf);\n\tif (status < 0)\n\t\tgoto fail0;\n\tcf->irq = irq;\n\tcf->socket.pci_irq = irq;\n\tcf->phys_cf = res->start;\n\n\t \n\tcf->socket.io_offset = iospace.start;\n\tstatus = pci_remap_iospace(&iospace, cf->phys_cf + SZ_4K);\n\tif (status) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tif (!request_mem_region(cf->phys_cf, SZ_8K, driver_name)) {\n\t\tstatus = -ENXIO;\n\t\tgoto fail1;\n\t}\n\n\t \n\tomap_cfg_reg(W11_1610_CF_CD1);\n\tomap_cfg_reg(P11_1610_CF_CD2);\n\tomap_cfg_reg(R11_1610_CF_IOIS16);\n\tomap_cfg_reg(V10_1610_CF_IREQ);\n\tomap_cfg_reg(W10_1610_CF_RESET);\n\n\tomap_writew(~(1 << seg), CF_CFG);\n\n\tpr_info(\"%s: cs%d on irq %d\\n\", driver_name, seg, irq);\n\n\t \n\n\tpr_debug(\"%s: sts %04x cfg %04x control %04x %s\\n\", driver_name,\n\t\tomap_readw(CF_STATUS), omap_readw(CF_CFG),\n\t\tomap_readw(CF_CONTROL),\n\t\tomap_cf_present() ? \"present\" : \"(not present)\");\n\n\tcf->socket.owner = THIS_MODULE;\n\tcf->socket.dev.parent = &pdev->dev;\n\tcf->socket.ops = &omap_cf_ops;\n\tcf->socket.resource_ops = &pccard_static_ops;\n\tcf->socket.features = SS_CAP_PCCARD | SS_CAP_STATIC_MAP\n\t\t\t\t| SS_CAP_MEM_ALIGN;\n\tcf->socket.map_size = SZ_2K;\n\tcf->socket.io[0].res = &cf->iomem;\n\n\tstatus = pcmcia_register_socket(&cf->socket);\n\tif (status < 0)\n\t\tgoto fail2;\n\n\tcf->active = 1;\n\tmod_timer(&cf->timer, jiffies + POLL_INTERVAL);\n\treturn 0;\n\nfail2:\n\trelease_mem_region(cf->phys_cf, SZ_8K);\nfail1:\n\tfree_irq(irq, cf);\nfail0:\n\tkfree(cf);\n\treturn status;\n}\n\nstatic int __exit omap_cf_remove(struct platform_device *pdev)\n{\n\tstruct omap_cf_socket *cf = platform_get_drvdata(pdev);\n\n\tcf->active = 0;\n\tpcmcia_unregister_socket(&cf->socket);\n\ttimer_shutdown_sync(&cf->timer);\n\trelease_mem_region(cf->phys_cf, SZ_8K);\n\tfree_irq(cf->irq, cf);\n\tkfree(cf);\n\treturn 0;\n}\n\nstatic struct platform_driver omap_cf_driver = {\n\t.driver = {\n\t\t.name\t= driver_name,\n\t},\n\t.remove\t\t= __exit_p(omap_cf_remove),\n};\n\nstatic int __init omap_cf_init(void)\n{\n\tif (cpu_is_omap16xx())\n\t\treturn platform_driver_probe(&omap_cf_driver, omap_cf_probe);\n\treturn -ENODEV;\n}\n\nstatic void __exit omap_cf_exit(void)\n{\n\tif (cpu_is_omap16xx())\n\t\tplatform_driver_unregister(&omap_cf_driver);\n}\n\nmodule_init(omap_cf_init);\nmodule_exit(omap_cf_exit);\n\nMODULE_DESCRIPTION(\"OMAP CF Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:omap_cf\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}