{
  "module_name": "tcic.c",
  "hash_id": "f7b1be0044b7d051d325d519321372ddc0b5dee394f49e3ad7c8af4dd0cfb4f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/tcic.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/timer.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/platform_device.h>\n#include <linux/bitops.h>\n\n#include <asm/io.h>\n\n#include <pcmcia/ss.h>\n#include \"tcic.h\"\n\nMODULE_AUTHOR(\"David Hinds <dahinds@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"Databook TCIC-2 PCMCIA socket driver\");\nMODULE_LICENSE(\"Dual MPL/GPL\");\n\n \n\n \n\n \nstatic unsigned long tcic_base = TCIC_BASE;\n\n \nstatic int ignore = -1;\n\n \nstatic int do_scan = 1;\n\n \nstatic u_int irq_mask = 0xffff;\nstatic int irq_list[16];\nstatic unsigned int irq_list_count;\n\n \nstatic int cs_irq;\n\n \nstatic int poll_interval;\n\n \nstatic int poll_quick = HZ/20;\n\n \nstatic int cycle_time = 70;\n\nmodule_param_hw(tcic_base, ulong, ioport, 0444);\nmodule_param(ignore, int, 0444);\nmodule_param(do_scan, int, 0444);\nmodule_param_hw(irq_mask, int, other, 0444);\nmodule_param_hw_array(irq_list, int, irq, &irq_list_count, 0444);\nmodule_param_hw(cs_irq, int, irq, 0444);\nmodule_param(poll_interval, int, 0444);\nmodule_param(poll_quick, int, 0444);\nmodule_param(cycle_time, int, 0444);\n\n \n\nstatic irqreturn_t tcic_interrupt(int irq, void *dev);\nstatic void tcic_timer(struct timer_list *unused);\nstatic struct pccard_operations tcic_operations;\n\nstruct tcic_socket {\n    u_short\tpsock;\n    u_char\tlast_sstat;\n    u_char\tid;\n    struct pcmcia_socket\tsocket;\n};\n\nstatic struct timer_list poll_timer;\nstatic int tcic_timer_pending;\n\nstatic int sockets;\nstatic struct tcic_socket socket_table[2];\n\n \n\n \n#define TCIC_IRQ(x) ((x) ? (((x) == 11) ? 1 : (x)) : 15)\n\n#ifdef DEBUG_X\nstatic u_char tcic_getb(u_char reg)\n{\n    u_char val = inb(tcic_base+reg);\n    printk(KERN_DEBUG \"tcic_getb(%#lx) = %#x\\n\", tcic_base+reg, val);\n    return val;\n}\n\nstatic u_short tcic_getw(u_char reg)\n{\n    u_short val = inw(tcic_base+reg);\n    printk(KERN_DEBUG \"tcic_getw(%#lx) = %#x\\n\", tcic_base+reg, val);\n    return val;\n}\n\nstatic void tcic_setb(u_char reg, u_char data)\n{\n    printk(KERN_DEBUG \"tcic_setb(%#lx, %#x)\\n\", tcic_base+reg, data);\n    outb(data, tcic_base+reg);\n}\n\nstatic void tcic_setw(u_char reg, u_short data)\n{\n    printk(KERN_DEBUG \"tcic_setw(%#lx, %#x)\\n\", tcic_base+reg, data);\n    outw(data, tcic_base+reg);\n}\n#else\n#define tcic_getb(reg) inb(tcic_base+reg)\n#define tcic_getw(reg) inw(tcic_base+reg)\n#define tcic_setb(reg, data) outb(data, tcic_base+reg)\n#define tcic_setw(reg, data) outw(data, tcic_base+reg)\n#endif\n\nstatic void tcic_setl(u_char reg, u_int data)\n{\n#ifdef DEBUG_X\n    printk(KERN_DEBUG \"tcic_setl(%#x, %#lx)\\n\", tcic_base+reg, data);\n#endif\n    outw(data & 0xffff, tcic_base+reg);\n    outw(data >> 16, tcic_base+reg+2);\n}\n\nstatic void tcic_aux_setb(u_short reg, u_char data)\n{\n    u_char mode = (tcic_getb(TCIC_MODE) & TCIC_MODE_PGMMASK) | reg;\n    tcic_setb(TCIC_MODE, mode);\n    tcic_setb(TCIC_AUX, data);\n}\n\nstatic u_short tcic_aux_getw(u_short reg)\n{\n    u_char mode = (tcic_getb(TCIC_MODE) & TCIC_MODE_PGMMASK) | reg;\n    tcic_setb(TCIC_MODE, mode);\n    return tcic_getw(TCIC_AUX);\n}\n\nstatic void tcic_aux_setw(u_short reg, u_short data)\n{\n    u_char mode = (tcic_getb(TCIC_MODE) & TCIC_MODE_PGMMASK) | reg;\n    tcic_setb(TCIC_MODE, mode);\n    tcic_setw(TCIC_AUX, data);\n}\n\n \n\n \n\nstatic int to_cycles(int ns)\n{\n    if (ns < 14)\n\treturn 0;\n    else\n\treturn 2*(ns-14)/cycle_time;\n}\n\n \n\nstatic volatile u_int irq_hits;\n\nstatic irqreturn_t __init tcic_irq_count(int irq, void *dev)\n{\n    irq_hits++;\n    return IRQ_HANDLED;\n}\n\nstatic u_int __init try_irq(int irq)\n{\n    u_short cfg;\n\n    irq_hits = 0;\n    if (request_irq(irq, tcic_irq_count, 0, \"irq scan\", tcic_irq_count) != 0)\n\treturn -1;\n    mdelay(10);\n    if (irq_hits) {\n\tfree_irq(irq, tcic_irq_count);\n\treturn -1;\n    }\n\n     \n    cfg = TCIC_SYSCFG_AUTOBUSY | 0x0a00;\n    tcic_aux_setw(TCIC_AUX_SYSCFG, cfg | TCIC_IRQ(irq));\n    tcic_setb(TCIC_IENA, TCIC_IENA_ERR | TCIC_IENA_CFG_HIGH);\n    tcic_setb(TCIC_ICSR, TCIC_ICSR_ERR | TCIC_ICSR_JAM);\n\n    udelay(1000);\n    free_irq(irq, tcic_irq_count);\n\n     \n    tcic_setb(TCIC_IENA, TCIC_IENA_CFG_OFF);\n    while (tcic_getb(TCIC_ICSR))\n\ttcic_setb(TCIC_ICSR, TCIC_ICSR_JAM);\n    tcic_aux_setw(TCIC_AUX_SYSCFG, cfg);\n    \n    return (irq_hits != 1);\n}\n\nstatic u_int __init irq_scan(u_int mask0)\n{\n    u_int mask1;\n    int i;\n\n#ifdef __alpha__\n#define PIC 0x4d0\n     \n    int level_mask = inb_p(PIC) | (inb_p(PIC+1) << 8);\n    if (level_mask)\n\tmask0 &= ~level_mask;\n#endif\n\n    mask1 = 0;\n    if (do_scan) {\n\tfor (i = 0; i < 16; i++)\n\t    if ((mask0 & (1 << i)) && (try_irq(i) == 0))\n\t\tmask1 |= (1 << i);\n\tfor (i = 0; i < 16; i++)\n\t    if ((mask1 & (1 << i)) && (try_irq(i) != 0)) {\n\t\tmask1 ^= (1 << i);\n\t    }\n    }\n    \n    if (mask1) {\n\tprintk(\"scanned\");\n    } else {\n\t \n\tfor (i = 0; i < 16; i++)\n\t    if ((mask0 & (1 << i)) &&\n\t\t(request_irq(i, tcic_irq_count, 0, \"x\", tcic_irq_count) == 0)) {\n\t\tmask1 |= (1 << i);\n\t\tfree_irq(i, tcic_irq_count);\n\t    }\n\tprintk(\"default\");\n    }\n    \n    printk(\") = \");\n    for (i = 0; i < 16; i++)\n\tif (mask1 & (1<<i))\n\t    printk(\"%s%d\", ((mask1 & ((1<<i)-1)) ? \",\" : \"\"), i);\n    printk(\" \");\n    \n    return mask1;\n}\n\n \n\nstatic int __init is_active(int s)\n{\n    u_short scf1, ioctl, base, num;\n    u_char pwr, sstat;\n    u_int addr;\n    \n    tcic_setl(TCIC_ADDR, (s << TCIC_ADDR_SS_SHFT)\n\t      | TCIC_ADDR_INDREG | TCIC_SCF1(s));\n    scf1 = tcic_getw(TCIC_DATA);\n    pwr = tcic_getb(TCIC_PWR);\n    sstat = tcic_getb(TCIC_SSTAT);\n    addr = TCIC_IWIN(s, 0);\n    tcic_setw(TCIC_ADDR, addr + TCIC_IBASE_X);\n    base = tcic_getw(TCIC_DATA);\n    tcic_setw(TCIC_ADDR, addr + TCIC_ICTL_X);\n    ioctl = tcic_getw(TCIC_DATA);\n\n    if (ioctl & TCIC_ICTL_TINY)\n\tnum = 1;\n    else {\n\tnum = (base ^ (base-1));\n\tbase = base & (base-1);\n    }\n\n    if ((sstat & TCIC_SSTAT_CD) && (pwr & TCIC_PWR_VCC(s)) &&\n\t(scf1 & TCIC_SCF1_IOSTS) && (ioctl & TCIC_ICTL_ENA) &&\n\t((base & 0xfeef) != 0x02e8)) {\n\tstruct resource *res = request_region(base, num, \"tcic-2\");\n\tif (!res)  \n\t    return 1;\n\trelease_region(base, num);\n    }\n\n    return 0;\n}\n\n \n\nstatic int __init get_tcic_id(void)\n{\n    u_short id;\n    \n    tcic_aux_setw(TCIC_AUX_TEST, TCIC_TEST_DIAG);\n    id = tcic_aux_getw(TCIC_AUX_ILOCK);\n    id = (id & TCIC_ILOCKTEST_ID_MASK) >> TCIC_ILOCKTEST_ID_SH;\n    tcic_aux_setw(TCIC_AUX_TEST, 0);\n    return id;\n}\n\n \n\nstatic struct platform_driver tcic_driver = {\n\t.driver = {\n\t\t.name = \"tcic-pcmcia\",\n\t},\n};\n\nstatic struct platform_device tcic_device = {\n\t.name = \"tcic-pcmcia\",\n\t.id = 0,\n};\n\n\nstatic int __init init_tcic(void)\n{\n    int i, sock, ret = 0;\n    u_int mask, scan;\n\n    if (platform_driver_register(&tcic_driver))\n\treturn -1;\n    \n    printk(KERN_INFO \"Databook TCIC-2 PCMCIA probe: \");\n    sock = 0;\n\n    if (!request_region(tcic_base, 16, \"tcic-2\")) {\n\tprintk(\"could not allocate ports,\\n \");\n\tplatform_driver_unregister(&tcic_driver);\n\treturn -ENODEV;\n    }\n    else {\n\ttcic_setw(TCIC_ADDR, 0);\n\tif (tcic_getw(TCIC_ADDR) == 0) {\n\t    tcic_setw(TCIC_ADDR, 0xc3a5);\n\t    if (tcic_getw(TCIC_ADDR) == 0xc3a5) sock = 2;\n\t}\n\tif (sock == 0) {\n\t     \n\t    tcic_setb(TCIC_SCTRL, TCIC_SCTRL_RESET);\n\t    tcic_setb(TCIC_SCTRL, 0);\n\t    tcic_setw(TCIC_ADDR, 0);\n\t    if (tcic_getw(TCIC_ADDR) == 0) {\n\t\ttcic_setw(TCIC_ADDR, 0xc3a5);\n\t\tif (tcic_getw(TCIC_ADDR) == 0xc3a5) sock = 2;\n\t    }\n\t}\n    }\n    if (sock == 0) {\n\tprintk(\"not found.\\n\");\n\trelease_region(tcic_base, 16);\n\tplatform_driver_unregister(&tcic_driver);\n\treturn -ENODEV;\n    }\n\n    sockets = 0;\n    for (i = 0; i < sock; i++) {\n\tif ((i == ignore) || is_active(i)) continue;\n\tsocket_table[sockets].psock = i;\n\tsocket_table[sockets].id = get_tcic_id();\n\n\tsocket_table[sockets].socket.owner = THIS_MODULE;\n\t \n\t \n\tsocket_table[sockets].socket.features = SS_CAP_PCCARD | SS_CAP_MEM_ALIGN;\n\t \n\tsocket_table[sockets].socket.irq_mask = 0x4cf8;\n\t \n\tsocket_table[sockets].socket.map_size = 0x1000;\t\t\n\tsockets++;\n    }\n\n    switch (socket_table[0].id) {\n    case TCIC_ID_DB86082:\n\tprintk(\"DB86082\"); break;\n    case TCIC_ID_DB86082A:\n\tprintk(\"DB86082A\"); break;\n    case TCIC_ID_DB86084:\n\tprintk(\"DB86084\"); break;\n    case TCIC_ID_DB86084A:\n\tprintk(\"DB86084A\"); break;\n    case TCIC_ID_DB86072:\n\tprintk(\"DB86072\"); break;\n    case TCIC_ID_DB86184:\n\tprintk(\"DB86184\"); break;\n    case TCIC_ID_DB86082B:\n\tprintk(\"DB86082B\"); break;\n    default:\n\tprintk(\"Unknown ID 0x%02x\", socket_table[0].id);\n    }\n    \n     \n    timer_setup(&poll_timer, &tcic_timer, 0);\n\n     \n    printk(KERN_CONT \", %d sockets\\n\", sockets);\n    printk(KERN_INFO \"  irq list (\");\n    if (irq_list_count == 0)\n\tmask = irq_mask;\n    else\n\tfor (i = mask = 0; i < irq_list_count; i++)\n\t    mask |= (1<<irq_list[i]);\n\n     \n    mask &= 0x4cf8;\n     \n    mask = irq_scan(mask);\n    for (i=0;i<sockets;i++)\n\t    socket_table[i].socket.irq_mask = mask;\n    \n     \n    scan = (mask & (mask-1));\n    if (((scan & (scan-1)) == 0) && (poll_interval == 0))\n\tpoll_interval = HZ;\n    \n    if (poll_interval == 0) {\n\t \n\tu_int cs_mask = mask & ((cs_irq) ? (1<<cs_irq) : ~(1<<12));\n\tfor (i = 15; i > 0; i--)\n\t    if ((cs_mask & (1 << i)) &&\n\t\t(request_irq(i, tcic_interrupt, 0, \"tcic\",\n\t\t\t     tcic_interrupt) == 0))\n\t\tbreak;\n\tcs_irq = i;\n\tif (cs_irq == 0) poll_interval = HZ;\n    }\n    \n    if (socket_table[0].socket.irq_mask & (1 << 11))\n\tprintk(\"sktirq is irq 11, \");\n    if (cs_irq != 0)\n\tprintk(\"status change on irq %d\\n\", cs_irq);\n    else\n\tprintk(\"polled status, interval = %d ms\\n\",\n\t       poll_interval * 1000 / HZ);\n    \n    for (i = 0; i < sockets; i++) {\n\ttcic_setw(TCIC_ADDR+2, socket_table[i].psock << TCIC_SS_SHFT);\n\tsocket_table[i].last_sstat = tcic_getb(TCIC_SSTAT);\n    }\n    \n     \n    tcic_interrupt(0, NULL);\n\n    platform_device_register(&tcic_device);\n\n    for (i = 0; i < sockets; i++) {\n\t    socket_table[i].socket.ops = &tcic_operations;\n\t    socket_table[i].socket.resource_ops = &pccard_nonstatic_ops;\n\t    socket_table[i].socket.dev.parent = &tcic_device.dev;\n\t    ret = pcmcia_register_socket(&socket_table[i].socket);\n\t    if (ret && i)\n\t\t    pcmcia_unregister_socket(&socket_table[0].socket);\n    }\n    \n    return ret;\n\n    return 0;\n    \n}  \n\n \n\nstatic void __exit exit_tcic(void)\n{\n    int i;\n\n    del_timer_sync(&poll_timer);\n    if (cs_irq != 0) {\n\ttcic_aux_setw(TCIC_AUX_SYSCFG, TCIC_SYSCFG_AUTOBUSY|0x0a00);\n\tfree_irq(cs_irq, tcic_interrupt);\n    }\n    release_region(tcic_base, 16);\n\n    for (i = 0; i < sockets; i++) {\n\t    pcmcia_unregister_socket(&socket_table[i].socket);\t    \n    }\n\n    platform_device_unregister(&tcic_device);\n    platform_driver_unregister(&tcic_driver);\n}  \n\n \n\nstatic irqreturn_t tcic_interrupt(int irq, void *dev)\n{\n    int i, quick = 0;\n    u_char latch, sstat;\n    u_short psock;\n    u_int events;\n    static volatile int active = 0;\n\n    if (active) {\n\tprintk(KERN_NOTICE \"tcic: reentered interrupt handler!\\n\");\n\treturn IRQ_NONE;\n    } else\n\tactive = 1;\n\n    pr_debug(\"tcic_interrupt()\\n\");\n    \n    for (i = 0; i < sockets; i++) {\n\tpsock = socket_table[i].psock;\n\ttcic_setl(TCIC_ADDR, (psock << TCIC_ADDR_SS_SHFT)\n\t\t  | TCIC_ADDR_INDREG | TCIC_SCF1(psock));\n\tsstat = tcic_getb(TCIC_SSTAT);\n\tlatch = sstat ^ socket_table[psock].last_sstat;\n\tsocket_table[i].last_sstat = sstat;\n\tif (tcic_getb(TCIC_ICSR) & TCIC_ICSR_CDCHG) {\n\t    tcic_setb(TCIC_ICSR, TCIC_ICSR_CLEAR);\n\t    quick = 1;\n\t}\n\tif (latch == 0)\n\t    continue;\n\tevents = (latch & TCIC_SSTAT_CD) ? SS_DETECT : 0;\n\tevents |= (latch & TCIC_SSTAT_WP) ? SS_WRPROT : 0;\n\tif (tcic_getw(TCIC_DATA) & TCIC_SCF1_IOSTS) {\n\t    events |= (latch & TCIC_SSTAT_LBAT1) ? SS_STSCHG : 0;\n\t} else {\n\t    events |= (latch & TCIC_SSTAT_RDY) ? SS_READY : 0;\n\t    events |= (latch & TCIC_SSTAT_LBAT1) ? SS_BATDEAD : 0;\n\t    events |= (latch & TCIC_SSTAT_LBAT2) ? SS_BATWARN : 0;\n\t}\n\tif (events) {\n\t\tpcmcia_parse_events(&socket_table[i].socket, events);\n\t}\n    }\n\n     \n    if (((cs_irq == 0) || quick) && (!tcic_timer_pending)) {\n\tpoll_timer.expires = jiffies + (quick ? poll_quick : poll_interval);\n\tadd_timer(&poll_timer);\n\ttcic_timer_pending = 1;\n    }\n    active = 0;\n    \n    pr_debug(\"interrupt done\\n\");\n    return IRQ_HANDLED;\n}  \n\nstatic void tcic_timer(struct timer_list *unused)\n{\n    pr_debug(\"tcic_timer()\\n\");\n    tcic_timer_pending = 0;\n    tcic_interrupt(0, NULL);\n}  \n\n \n\nstatic int tcic_get_status(struct pcmcia_socket *sock, u_int *value)\n{\n    u_short psock = container_of(sock, struct tcic_socket, socket)->psock;\n    u_char reg;\n\n    tcic_setl(TCIC_ADDR, (psock << TCIC_ADDR_SS_SHFT)\n\t      | TCIC_ADDR_INDREG | TCIC_SCF1(psock));\n    reg = tcic_getb(TCIC_SSTAT);\n    *value  = (reg & TCIC_SSTAT_CD) ? SS_DETECT : 0;\n    *value |= (reg & TCIC_SSTAT_WP) ? SS_WRPROT : 0;\n    if (tcic_getw(TCIC_DATA) & TCIC_SCF1_IOSTS) {\n\t*value |= (reg & TCIC_SSTAT_LBAT1) ? SS_STSCHG : 0;\n    } else {\n\t*value |= (reg & TCIC_SSTAT_RDY) ? SS_READY : 0;\n\t*value |= (reg & TCIC_SSTAT_LBAT1) ? SS_BATDEAD : 0;\n\t*value |= (reg & TCIC_SSTAT_LBAT2) ? SS_BATWARN : 0;\n    }\n    reg = tcic_getb(TCIC_PWR);\n    if (reg & (TCIC_PWR_VCC(psock)|TCIC_PWR_VPP(psock)))\n\t*value |= SS_POWERON;\n    dev_dbg(&sock->dev, \"GetStatus(%d) = %#2.2x\\n\", psock, *value);\n    return 0;\n}  \n\n \n\nstatic int tcic_set_socket(struct pcmcia_socket *sock, socket_state_t *state)\n{\n    u_short psock = container_of(sock, struct tcic_socket, socket)->psock;\n    u_char reg;\n    u_short scf1, scf2;\n\n    dev_dbg(&sock->dev, \"SetSocket(%d, flags %#3.3x, Vcc %d, Vpp %d, \"\n\t  \"io_irq %d, csc_mask %#2.2x)\\n\", psock, state->flags,\n\t  state->Vcc, state->Vpp, state->io_irq, state->csc_mask);\n    tcic_setw(TCIC_ADDR+2, (psock << TCIC_SS_SHFT) | TCIC_ADR2_INDREG);\n\n    reg = tcic_getb(TCIC_PWR);\n    reg &= ~(TCIC_PWR_VCC(psock) | TCIC_PWR_VPP(psock));\n\n    if (state->Vcc == 50) {\n\tswitch (state->Vpp) {\n\tcase 0:   reg |= TCIC_PWR_VCC(psock) | TCIC_PWR_VPP(psock); break;\n\tcase 50:  reg |= TCIC_PWR_VCC(psock); break;\n\tcase 120: reg |= TCIC_PWR_VPP(psock); break;\n\tdefault:  return -EINVAL;\n\t}\n    } else if (state->Vcc != 0)\n\treturn -EINVAL;\n\n    if (reg != tcic_getb(TCIC_PWR))\n\ttcic_setb(TCIC_PWR, reg);\n\n    reg = TCIC_ILOCK_HOLD_CCLK | TCIC_ILOCK_CWAIT;\n    if (state->flags & SS_OUTPUT_ENA) {\n\ttcic_setb(TCIC_SCTRL, TCIC_SCTRL_ENA);\n\treg |= TCIC_ILOCK_CRESENA;\n    } else\n\ttcic_setb(TCIC_SCTRL, 0);\n    if (state->flags & SS_RESET)\n\treg |= TCIC_ILOCK_CRESET;\n    tcic_aux_setb(TCIC_AUX_ILOCK, reg);\n    \n    tcic_setw(TCIC_ADDR, TCIC_SCF1(psock));\n    scf1 = TCIC_SCF1_FINPACK;\n    scf1 |= TCIC_IRQ(state->io_irq);\n    if (state->flags & SS_IOCARD) {\n\tscf1 |= TCIC_SCF1_IOSTS;\n\tif (state->flags & SS_SPKR_ENA)\n\t    scf1 |= TCIC_SCF1_SPKR;\n\tif (state->flags & SS_DMA_MODE)\n\t    scf1 |= TCIC_SCF1_DREQ2 << TCIC_SCF1_DMA_SHIFT;\n    }\n    tcic_setw(TCIC_DATA, scf1);\n\n     \n    reg = TCIC_WAIT_ASYNC | TCIC_WAIT_SENSE | to_cycles(250);\n    tcic_aux_setb(TCIC_AUX_WCTL, reg);\n    tcic_aux_setw(TCIC_AUX_SYSCFG, TCIC_SYSCFG_AUTOBUSY|0x0a00|\n\t\t  TCIC_IRQ(cs_irq));\n    \n     \n    tcic_setw(TCIC_ADDR, TCIC_SCF2(psock));\n    scf2 = TCIC_SCF2_MALL;\n    if (state->csc_mask & SS_DETECT) scf2 &= ~TCIC_SCF2_MCD;\n    if (state->flags & SS_IOCARD) {\n\tif (state->csc_mask & SS_STSCHG) reg &= ~TCIC_SCF2_MLBAT1;\n    } else {\n\tif (state->csc_mask & SS_BATDEAD) reg &= ~TCIC_SCF2_MLBAT1;\n\tif (state->csc_mask & SS_BATWARN) reg &= ~TCIC_SCF2_MLBAT2;\n\tif (state->csc_mask & SS_READY) reg &= ~TCIC_SCF2_MRDY;\n    }\n    tcic_setw(TCIC_DATA, scf2);\n     \n    tcic_setb(TCIC_IENA, TCIC_IENA_CDCHG | TCIC_IENA_CFG_HIGH);\n\n    return 0;\n}  \n  \n \n\nstatic int tcic_set_io_map(struct pcmcia_socket *sock, struct pccard_io_map *io)\n{\n    u_short psock = container_of(sock, struct tcic_socket, socket)->psock;\n    u_int addr;\n    u_short base, len, ioctl;\n    \n    dev_dbg(&sock->dev, \"SetIOMap(%d, %d, %#2.2x, %d ns, \"\n\t  \"%#llx-%#llx)\\n\", psock, io->map, io->flags, io->speed,\n\t  (unsigned long long)io->start, (unsigned long long)io->stop);\n    if ((io->map > 1) || (io->start > 0xffff) || (io->stop > 0xffff) ||\n\t(io->stop < io->start)) return -EINVAL;\n    tcic_setw(TCIC_ADDR+2, TCIC_ADR2_INDREG | (psock << TCIC_SS_SHFT));\n    addr = TCIC_IWIN(psock, io->map);\n\n    base = io->start; len = io->stop - io->start;\n     \n    if ((len & (len+1)) || (base & len)) return -EINVAL;\n    base |= (len+1)>>1;\n    tcic_setw(TCIC_ADDR, addr + TCIC_IBASE_X);\n    tcic_setw(TCIC_DATA, base);\n    \n    ioctl  = (psock << TCIC_ICTL_SS_SHFT);\n    ioctl |= (len == 0) ? TCIC_ICTL_TINY : 0;\n    ioctl |= (io->flags & MAP_ACTIVE) ? TCIC_ICTL_ENA : 0;\n    ioctl |= to_cycles(io->speed) & TCIC_ICTL_WSCNT_MASK;\n    if (!(io->flags & MAP_AUTOSZ)) {\n\tioctl |= TCIC_ICTL_QUIET;\n\tioctl |= (io->flags & MAP_16BIT) ? TCIC_ICTL_BW_16 : TCIC_ICTL_BW_8;\n    }\n    tcic_setw(TCIC_ADDR, addr + TCIC_ICTL_X);\n    tcic_setw(TCIC_DATA, ioctl);\n    \n    return 0;\n}  \n\n \n\nstatic int tcic_set_mem_map(struct pcmcia_socket *sock, struct pccard_mem_map *mem)\n{\n    u_short psock = container_of(sock, struct tcic_socket, socket)->psock;\n    u_short addr, ctl;\n    u_long base, len, mmap;\n\n    dev_dbg(&sock->dev, \"SetMemMap(%d, %d, %#2.2x, %d ns, \"\n\t  \"%#llx-%#llx, %#x)\\n\", psock, mem->map, mem->flags,\n\t  mem->speed, (unsigned long long)mem->res->start,\n\t  (unsigned long long)mem->res->end, mem->card_start);\n    if ((mem->map > 3) || (mem->card_start > 0x3ffffff) ||\n\t(mem->res->start > 0xffffff) || (mem->res->end > 0xffffff) ||\n\t(mem->res->start > mem->res->end) || (mem->speed > 1000))\n\treturn -EINVAL;\n    tcic_setw(TCIC_ADDR+2, TCIC_ADR2_INDREG | (psock << TCIC_SS_SHFT));\n    addr = TCIC_MWIN(psock, mem->map);\n\n    base = mem->res->start; len = mem->res->end - mem->res->start;\n    if ((len & (len+1)) || (base & len)) return -EINVAL;\n    if (len == 0x0fff)\n\tbase = (base >> TCIC_MBASE_HA_SHFT) | TCIC_MBASE_4K_BIT;\n    else\n\tbase = (base | (len+1)>>1) >> TCIC_MBASE_HA_SHFT;\n    tcic_setw(TCIC_ADDR, addr + TCIC_MBASE_X);\n    tcic_setw(TCIC_DATA, base);\n    \n    mmap = mem->card_start - mem->res->start;\n    mmap = (mmap >> TCIC_MMAP_CA_SHFT) & TCIC_MMAP_CA_MASK;\n    if (mem->flags & MAP_ATTRIB) mmap |= TCIC_MMAP_REG;\n    tcic_setw(TCIC_ADDR, addr + TCIC_MMAP_X);\n    tcic_setw(TCIC_DATA, mmap);\n\n    ctl  = TCIC_MCTL_QUIET | (psock << TCIC_MCTL_SS_SHFT);\n    ctl |= to_cycles(mem->speed) & TCIC_MCTL_WSCNT_MASK;\n    ctl |= (mem->flags & MAP_16BIT) ? 0 : TCIC_MCTL_B8;\n    ctl |= (mem->flags & MAP_WRPROT) ? TCIC_MCTL_WP : 0;\n    ctl |= (mem->flags & MAP_ACTIVE) ? TCIC_MCTL_ENA : 0;\n    tcic_setw(TCIC_ADDR, addr + TCIC_MCTL_X);\n    tcic_setw(TCIC_DATA, ctl);\n    \n    return 0;\n}  \n\n \n\nstatic int tcic_init(struct pcmcia_socket *s)\n{\n\tint i;\n\tstruct resource res = { .start = 0, .end = 0x1000 };\n\tpccard_io_map io = { 0, 0, 0, 0, 1 };\n\tpccard_mem_map mem = { .res = &res, };\n\n\tfor (i = 0; i < 2; i++) {\n\t\tio.map = i;\n\t\ttcic_set_io_map(s, &io);\n\t}\n\tfor (i = 0; i < 5; i++) {\n\t\tmem.map = i;\n\t\ttcic_set_mem_map(s, &mem);\n\t}\n\treturn 0;\n}\n\nstatic struct pccard_operations tcic_operations = {\n\t.init\t\t   = tcic_init,\n\t.get_status\t   = tcic_get_status,\n\t.set_socket\t   = tcic_set_socket,\n\t.set_io_map\t   = tcic_set_io_map,\n\t.set_mem_map\t   = tcic_set_mem_map,\n};\n\n \n\nmodule_init(init_tcic);\nmodule_exit(exit_tcic);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}