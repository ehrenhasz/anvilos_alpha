{
  "module_name": "sa1111_generic.c",
  "hash_id": "8786682e71c0b78d03528995295774eeb54a9c4d635cd8bd9a412f25c6f11978",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/sa1111_generic.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#include <pcmcia/ss.h>\n\n#include <asm/hardware/sa1111.h>\n#include <asm/mach-types.h>\n#include <asm/irq.h>\n\n#include \"sa1111_generic.h\"\n\n \n#define PCCR\t0x0000\n#define PCSSR\t0x0004\n#define PCSR\t0x0008\n\n#define PCSR_S0_READY\t(1<<0)\n#define PCSR_S1_READY\t(1<<1)\n#define PCSR_S0_DETECT\t(1<<2)\n#define PCSR_S1_DETECT\t(1<<3)\n#define PCSR_S0_VS1\t(1<<4)\n#define PCSR_S0_VS2\t(1<<5)\n#define PCSR_S1_VS1\t(1<<6)\n#define PCSR_S1_VS2\t(1<<7)\n#define PCSR_S0_WP\t(1<<8)\n#define PCSR_S1_WP\t(1<<9)\n#define PCSR_S0_BVD1\t(1<<10)\n#define PCSR_S0_BVD2\t(1<<11)\n#define PCSR_S1_BVD1\t(1<<12)\n#define PCSR_S1_BVD2\t(1<<13)\n\n#define PCCR_S0_RST\t(1<<0)\n#define PCCR_S1_RST\t(1<<1)\n#define PCCR_S0_FLT\t(1<<2)\n#define PCCR_S1_FLT\t(1<<3)\n#define PCCR_S0_PWAITEN\t(1<<4)\n#define PCCR_S1_PWAITEN\t(1<<5)\n#define PCCR_S0_PSE\t(1<<6)\n#define PCCR_S1_PSE\t(1<<7)\n\n#define PCSSR_S0_SLEEP\t(1<<0)\n#define PCSSR_S1_SLEEP\t(1<<1)\n\n#define IDX_IRQ_S0_READY_NINT\t(0)\n#define IDX_IRQ_S0_CD_VALID\t(1)\n#define IDX_IRQ_S0_BVD1_STSCHG\t(2)\n#define IDX_IRQ_S1_READY_NINT\t(3)\n#define IDX_IRQ_S1_CD_VALID\t(4)\n#define IDX_IRQ_S1_BVD1_STSCHG\t(5)\n#define NUM_IRQS\t\t(6)\n\nvoid sa1111_pcmcia_socket_state(struct soc_pcmcia_socket *skt, struct pcmcia_state *state)\n{\n\tstruct sa1111_pcmcia_socket *s = to_skt(skt);\n\tu32 status = readl_relaxed(s->dev->mapbase + PCSR);\n\n\tswitch (skt->nr) {\n\tcase 0:\n\t\tstate->detect = status & PCSR_S0_DETECT ? 0 : 1;\n\t\tstate->ready  = status & PCSR_S0_READY  ? 1 : 0;\n\t\tstate->bvd1   = status & PCSR_S0_BVD1   ? 1 : 0;\n\t\tstate->bvd2   = status & PCSR_S0_BVD2   ? 1 : 0;\n\t\tstate->wrprot = status & PCSR_S0_WP     ? 1 : 0;\n\t\tstate->vs_3v  = status & PCSR_S0_VS1    ? 0 : 1;\n\t\tstate->vs_Xv  = status & PCSR_S0_VS2    ? 0 : 1;\n\t\tbreak;\n\n\tcase 1:\n\t\tstate->detect = status & PCSR_S1_DETECT ? 0 : 1;\n\t\tstate->ready  = status & PCSR_S1_READY  ? 1 : 0;\n\t\tstate->bvd1   = status & PCSR_S1_BVD1   ? 1 : 0;\n\t\tstate->bvd2   = status & PCSR_S1_BVD2   ? 1 : 0;\n\t\tstate->wrprot = status & PCSR_S1_WP     ? 1 : 0;\n\t\tstate->vs_3v  = status & PCSR_S1_VS1    ? 0 : 1;\n\t\tstate->vs_Xv  = status & PCSR_S1_VS2    ? 0 : 1;\n\t\tbreak;\n\t}\n}\n\nint sa1111_pcmcia_configure_socket(struct soc_pcmcia_socket *skt, const socket_state_t *state)\n{\n\tstruct sa1111_pcmcia_socket *s = to_skt(skt);\n\tu32 pccr_skt_mask, pccr_set_mask, val;\n\tunsigned long flags;\n\n\tswitch (skt->nr) {\n\tcase 0:\n\t\tpccr_skt_mask = PCCR_S0_RST|PCCR_S0_FLT|PCCR_S0_PWAITEN|PCCR_S0_PSE;\n\t\tbreak;\n\n\tcase 1:\n\t\tpccr_skt_mask = PCCR_S1_RST|PCCR_S1_FLT|PCCR_S1_PWAITEN|PCCR_S1_PSE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tpccr_set_mask = 0;\n\n\tif (state->Vcc != 0)\n\t\tpccr_set_mask |= PCCR_S0_PWAITEN|PCCR_S1_PWAITEN;\n\tif (state->Vcc == 50)\n\t\tpccr_set_mask |= PCCR_S0_PSE|PCCR_S1_PSE;\n\tif (state->flags & SS_RESET)\n\t\tpccr_set_mask |= PCCR_S0_RST|PCCR_S1_RST;\n\tif (state->flags & SS_OUTPUT_ENA)\n\t\tpccr_set_mask |= PCCR_S0_FLT|PCCR_S1_FLT;\n\n\tlocal_irq_save(flags);\n\tval = readl_relaxed(s->dev->mapbase + PCCR);\n\tval &= ~pccr_skt_mask;\n\tval |= pccr_set_mask & pccr_skt_mask;\n\twritel_relaxed(val, s->dev->mapbase + PCCR);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\nint sa1111_pcmcia_add(struct sa1111_dev *dev, struct pcmcia_low_level *ops,\n\tint (*add)(struct soc_pcmcia_socket *))\n{\n\tstruct sa1111_pcmcia_socket *s;\n\tstruct clk *clk;\n\tint i, ret = 0, irqs[NUM_IRQS];\n\n\tclk = devm_clk_get(&dev->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tfor (i = 0; i < NUM_IRQS; i++) {\n\t\tirqs[i] = sa1111_get_irq(dev, i);\n\t\tif (irqs[i] <= 0)\n\t\t\treturn irqs[i] ? : -ENXIO;\n\t}\n\n\tops->socket_state = sa1111_pcmcia_socket_state;\n\n\tfor (i = 0; i < ops->nr; i++) {\n\t\ts = kzalloc(sizeof(*s), GFP_KERNEL);\n\t\tif (!s)\n\t\t\treturn -ENOMEM;\n\n\t\ts->soc.nr = ops->first + i;\n\t\ts->soc.clk = clk;\n\n\t\tsoc_pcmcia_init_one(&s->soc, ops, &dev->dev);\n\t\ts->dev = dev;\n\t\tif (s->soc.nr) {\n\t\t\ts->soc.socket.pci_irq = irqs[IDX_IRQ_S1_READY_NINT];\n\t\t\ts->soc.stat[SOC_STAT_CD].irq = irqs[IDX_IRQ_S1_CD_VALID];\n\t\t\ts->soc.stat[SOC_STAT_CD].name = \"SA1111 CF card detect\";\n\t\t\ts->soc.stat[SOC_STAT_BVD1].irq = irqs[IDX_IRQ_S1_BVD1_STSCHG];\n\t\t\ts->soc.stat[SOC_STAT_BVD1].name = \"SA1111 CF BVD1\";\n\t\t} else {\n\t\t\ts->soc.socket.pci_irq = irqs[IDX_IRQ_S0_READY_NINT];\n\t\t\ts->soc.stat[SOC_STAT_CD].irq = irqs[IDX_IRQ_S0_CD_VALID];\n\t\t\ts->soc.stat[SOC_STAT_CD].name = \"SA1111 PCMCIA card detect\";\n\t\t\ts->soc.stat[SOC_STAT_BVD1].irq = irqs[IDX_IRQ_S0_BVD1_STSCHG];\n\t\t\ts->soc.stat[SOC_STAT_BVD1].name = \"SA1111 PCMCIA BVD1\";\n\t\t}\n\n\t\tret = add(&s->soc);\n\t\tif (ret == 0) {\n\t\t\ts->next = dev_get_drvdata(&dev->dev);\n\t\t\tdev_set_drvdata(&dev->dev, s);\n\t\t} else\n\t\t\tkfree(s);\n\t}\n\n\treturn ret;\n}\n\nstatic int pcmcia_probe(struct sa1111_dev *dev)\n{\n\tvoid __iomem *base;\n\tint ret;\n\n\tret = sa1111_enable_device(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(&dev->dev, NULL);\n\n\tif (!request_mem_region(dev->res.start, 512, SA1111_DRIVER_NAME(dev))) {\n\t\tsa1111_disable_device(dev);\n\t\treturn -EBUSY;\n\t}\n\n\tbase = dev->mapbase;\n\n\t \n\twritel_relaxed(PCSSR_S0_SLEEP | PCSSR_S1_SLEEP, base + PCSSR);\n\twritel_relaxed(PCCR_S0_FLT | PCCR_S1_FLT, base + PCCR);\n\n\tret = -ENODEV;\n#ifdef CONFIG_SA1100_JORNADA720\n\tif (machine_is_jornada720())\n\t\tret = pcmcia_jornada720_init(dev);\n#endif\n#ifdef CONFIG_ASSABET_NEPONSET\n\tif (machine_is_assabet())\n\t\tret = pcmcia_neponset_init(dev);\n#endif\n\n\tif (ret) {\n\t\trelease_mem_region(dev->res.start, 512);\n\t\tsa1111_disable_device(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void pcmcia_remove(struct sa1111_dev *dev)\n{\n\tstruct sa1111_pcmcia_socket *next, *s = dev_get_drvdata(&dev->dev);\n\n\tdev_set_drvdata(&dev->dev, NULL);\n\n\tfor (; s; s = next) {\n\t\tnext = s->next;\n\t\tsoc_pcmcia_remove_one(&s->soc);\n\t\tkfree(s);\n\t}\n\n\trelease_mem_region(dev->res.start, 512);\n\tsa1111_disable_device(dev);\n}\n\nstatic struct sa1111_driver pcmcia_driver = {\n\t.drv = {\n\t\t.name\t= \"sa1111-pcmcia\",\n\t},\n\t.devid\t\t= SA1111_DEVID_PCMCIA,\n\t.probe\t\t= pcmcia_probe,\n\t.remove\t\t= pcmcia_remove,\n};\n\nstatic int __init sa1111_drv_pcmcia_init(void)\n{\n\treturn sa1111_driver_register(&pcmcia_driver);\n}\n\nstatic void __exit sa1111_drv_pcmcia_exit(void)\n{\n\tsa1111_driver_unregister(&pcmcia_driver);\n}\n\nfs_initcall(sa1111_drv_pcmcia_init);\nmodule_exit(sa1111_drv_pcmcia_exit);\n\nMODULE_DESCRIPTION(\"SA1111 PCMCIA card socket driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}