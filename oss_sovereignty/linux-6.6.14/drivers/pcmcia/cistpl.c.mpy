{
  "module_name": "cistpl.c",
  "hash_id": "7424430cd9e71317bcf13814f88318eb69d6ae6e777c88addd7968515459562a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/cistpl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/major.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/pci.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/security.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n\n#include <pcmcia/ss.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n#include \"cs_internal.h\"\n\nstatic const u_char mantissa[] = {\n    10, 12, 13, 15, 20, 25, 30, 35,\n    40, 45, 50, 55, 60, 70, 80, 90\n};\n\nstatic const u_int exponent[] = {\n    1, 10, 100, 1000, 10000, 100000, 1000000, 10000000\n};\n\n \n#define SPEED_CVT(v) \\\n    (mantissa[(((v)>>3)&15)-1] * exponent[(v)&7] / 10)\n \n#define POWER_CVT(v) \\\n    (mantissa[((v)>>3)&15] * exponent[(v)&7] / 10)\n#define POWER_SCALE(v)\t\t(exponent[(v)&7])\n\n \n#define MAX_TUPLES\t\t200\n\n \n#define IRQ_INFO2_VALID\t\t0x10\n\n \nstatic int cis_width;\nmodule_param(cis_width, int, 0444);\n\nvoid release_cis_mem(struct pcmcia_socket *s)\n{\n\tmutex_lock(&s->ops_mutex);\n\tif (s->cis_mem.flags & MAP_ACTIVE) {\n\t\ts->cis_mem.flags &= ~MAP_ACTIVE;\n\t\ts->ops->set_mem_map(s, &s->cis_mem);\n\t\tif (s->cis_mem.res) {\n\t\t\trelease_resource(s->cis_mem.res);\n\t\t\tkfree(s->cis_mem.res);\n\t\t\ts->cis_mem.res = NULL;\n\t\t}\n\t\tiounmap(s->cis_virt);\n\t\ts->cis_virt = NULL;\n\t}\n\tmutex_unlock(&s->ops_mutex);\n}\n\n \nstatic void __iomem *set_cis_map(struct pcmcia_socket *s,\n\t\t\t\tunsigned int card_offset, unsigned int flags)\n{\n\tpccard_mem_map *mem = &s->cis_mem;\n\tint ret;\n\n\tif (!(s->features & SS_CAP_STATIC_MAP) && (mem->res == NULL)) {\n\t\tmem->res = pcmcia_find_mem_region(0, s->map_size,\n\t\t\t\t\t\ts->map_size, 0, s);\n\t\tif (mem->res == NULL) {\n\t\t\tdev_notice(&s->dev, \"cs: unable to map card memory!\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\ts->cis_virt = NULL;\n\t}\n\n\tif (!(s->features & SS_CAP_STATIC_MAP) && (!s->cis_virt))\n\t\ts->cis_virt = ioremap(mem->res->start, s->map_size);\n\n\tmem->card_start = card_offset;\n\tmem->flags = flags;\n\n\tret = s->ops->set_mem_map(s, mem);\n\tif (ret) {\n\t\tiounmap(s->cis_virt);\n\t\ts->cis_virt = NULL;\n\t\treturn NULL;\n\t}\n\n\tif (s->features & SS_CAP_STATIC_MAP) {\n\t\tif (s->cis_virt)\n\t\t\tiounmap(s->cis_virt);\n\t\ts->cis_virt = ioremap(mem->static_start, s->map_size);\n\t}\n\n\treturn s->cis_virt;\n}\n\n\n \n#define IS_ATTR\t\t1\n#define IS_INDIRECT\t8\n\n \nint pcmcia_read_cis_mem(struct pcmcia_socket *s, int attr, u_int addr,\n\t\t u_int len, void *ptr)\n{\n\tvoid __iomem *sys, *end;\n\tunsigned char *buf = ptr;\n\n\tdev_dbg(&s->dev, \"pcmcia_read_cis_mem(%d, %#x, %u)\\n\", attr, addr, len);\n\n\tif (attr & IS_INDIRECT) {\n\t\t \n\t\tu_char flags = ICTRL0_COMMON|ICTRL0_AUTOINC|ICTRL0_BYTEGRAN;\n\t\tif (attr & IS_ATTR) {\n\t\t\taddr *= 2;\n\t\t\tflags = ICTRL0_AUTOINC;\n\t\t}\n\n\t\tsys = set_cis_map(s, 0, MAP_ACTIVE |\n\t\t\t\t((cis_width) ? MAP_16BIT : 0));\n\t\tif (!sys) {\n\t\t\tdev_dbg(&s->dev, \"could not map memory\\n\");\n\t\t\tmemset(ptr, 0xff, len);\n\t\t\treturn -1;\n\t\t}\n\n\t\twriteb(flags, sys+CISREG_ICTRL0);\n\t\twriteb(addr & 0xff, sys+CISREG_IADDR0);\n\t\twriteb((addr>>8) & 0xff, sys+CISREG_IADDR1);\n\t\twriteb((addr>>16) & 0xff, sys+CISREG_IADDR2);\n\t\twriteb((addr>>24) & 0xff, sys+CISREG_IADDR3);\n\t\tfor ( ; len > 0; len--, buf++)\n\t\t\t*buf = readb(sys+CISREG_IDATA0);\n\t} else {\n\t\tu_int inc = 1, card_offset, flags;\n\n\t\tif (addr > CISTPL_MAX_CIS_SIZE) {\n\t\t\tdev_dbg(&s->dev,\n\t\t\t\t\"attempt to read CIS mem at addr %#x\", addr);\n\t\t\tmemset(ptr, 0xff, len);\n\t\t\treturn -1;\n\t\t}\n\n\t\tflags = MAP_ACTIVE | ((cis_width) ? MAP_16BIT : 0);\n\t\tif (attr) {\n\t\t\tflags |= MAP_ATTRIB;\n\t\t\tinc++;\n\t\t\taddr *= 2;\n\t\t}\n\n\t\tcard_offset = addr & ~(s->map_size-1);\n\t\twhile (len) {\n\t\t\tsys = set_cis_map(s, card_offset, flags);\n\t\t\tif (!sys) {\n\t\t\t\tdev_dbg(&s->dev, \"could not map memory\\n\");\n\t\t\t\tmemset(ptr, 0xff, len);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tend = sys + s->map_size;\n\t\t\tsys = sys + (addr & (s->map_size-1));\n\t\t\tfor ( ; len > 0; len--, buf++, sys += inc) {\n\t\t\t\tif (sys == end)\n\t\t\t\t\tbreak;\n\t\t\t\t*buf = readb(sys);\n\t\t\t}\n\t\t\tcard_offset += s->map_size;\n\t\t\taddr = 0;\n\t\t}\n\t}\n\tdev_dbg(&s->dev, \"  %#2.2x %#2.2x %#2.2x %#2.2x ...\\n\",\n\t\t*(u_char *)(ptr+0), *(u_char *)(ptr+1),\n\t\t*(u_char *)(ptr+2), *(u_char *)(ptr+3));\n\treturn 0;\n}\n\n\n \nint pcmcia_write_cis_mem(struct pcmcia_socket *s, int attr, u_int addr,\n\t\t   u_int len, void *ptr)\n{\n\tvoid __iomem *sys, *end;\n\tunsigned char *buf = ptr;\n\n\tdev_dbg(&s->dev,\n\t\t\"pcmcia_write_cis_mem(%d, %#x, %u)\\n\", attr, addr, len);\n\n\tif (attr & IS_INDIRECT) {\n\t\t \n\t\tu_char flags = ICTRL0_COMMON|ICTRL0_AUTOINC|ICTRL0_BYTEGRAN;\n\t\tif (attr & IS_ATTR) {\n\t\t\taddr *= 2;\n\t\t\tflags = ICTRL0_AUTOINC;\n\t\t}\n\n\t\tsys = set_cis_map(s, 0, MAP_ACTIVE |\n\t\t\t\t((cis_width) ? MAP_16BIT : 0));\n\t\tif (!sys) {\n\t\t\tdev_dbg(&s->dev, \"could not map memory\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\twriteb(flags, sys+CISREG_ICTRL0);\n\t\twriteb(addr & 0xff, sys+CISREG_IADDR0);\n\t\twriteb((addr>>8) & 0xff, sys+CISREG_IADDR1);\n\t\twriteb((addr>>16) & 0xff, sys+CISREG_IADDR2);\n\t\twriteb((addr>>24) & 0xff, sys+CISREG_IADDR3);\n\t\tfor ( ; len > 0; len--, buf++)\n\t\t\twriteb(*buf, sys+CISREG_IDATA0);\n\t} else {\n\t\tu_int inc = 1, card_offset, flags;\n\n\t\tflags = MAP_ACTIVE | ((cis_width) ? MAP_16BIT : 0);\n\t\tif (attr & IS_ATTR) {\n\t\t\tflags |= MAP_ATTRIB;\n\t\t\tinc++;\n\t\t\taddr *= 2;\n\t\t}\n\n\t\tcard_offset = addr & ~(s->map_size-1);\n\t\twhile (len) {\n\t\t\tsys = set_cis_map(s, card_offset, flags);\n\t\t\tif (!sys) {\n\t\t\t\tdev_dbg(&s->dev, \"could not map memory\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tend = sys + s->map_size;\n\t\t\tsys = sys + (addr & (s->map_size-1));\n\t\t\tfor ( ; len > 0; len--, buf++, sys += inc) {\n\t\t\t\tif (sys == end)\n\t\t\t\t\tbreak;\n\t\t\t\twriteb(*buf, sys);\n\t\t\t}\n\t\t\tcard_offset += s->map_size;\n\t\t\taddr = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n \nstatic int read_cis_cache(struct pcmcia_socket *s, int attr, u_int addr,\n\t\t\tsize_t len, void *ptr)\n{\n\tstruct cis_cache_entry *cis;\n\tint ret = 0;\n\n\tif (s->state & SOCKET_CARDBUS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&s->ops_mutex);\n\tif (s->fake_cis) {\n\t\tif (s->fake_cis_len >= addr+len)\n\t\t\tmemcpy(ptr, s->fake_cis+addr, len);\n\t\telse {\n\t\t\tmemset(ptr, 0xff, len);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn ret;\n\t}\n\n\tlist_for_each_entry(cis, &s->cis_cache, node) {\n\t\tif (cis->addr == addr && cis->len == len && cis->attr == attr) {\n\t\t\tmemcpy(ptr, cis->cache, len);\n\t\t\tmutex_unlock(&s->ops_mutex);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = pcmcia_read_cis_mem(s, attr, addr, len, ptr);\n\n\tif (ret == 0) {\n\t\t \n\t\tcis = kmalloc(sizeof(struct cis_cache_entry) + len, GFP_KERNEL);\n\t\tif (cis) {\n\t\t\tcis->addr = addr;\n\t\t\tcis->len = len;\n\t\t\tcis->attr = attr;\n\t\t\tmemcpy(cis->cache, ptr, len);\n\t\t\tlist_add(&cis->node, &s->cis_cache);\n\t\t}\n\t}\n\tmutex_unlock(&s->ops_mutex);\n\n\treturn ret;\n}\n\nstatic void\nremove_cis_cache(struct pcmcia_socket *s, int attr, u_int addr, u_int len)\n{\n\tstruct cis_cache_entry *cis;\n\n\tmutex_lock(&s->ops_mutex);\n\tlist_for_each_entry(cis, &s->cis_cache, node)\n\t\tif (cis->addr == addr && cis->len == len && cis->attr == attr) {\n\t\t\tlist_del(&cis->node);\n\t\t\tkfree(cis);\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&s->ops_mutex);\n}\n\n \nvoid destroy_cis_cache(struct pcmcia_socket *s)\n{\n\tstruct list_head *l, *n;\n\tstruct cis_cache_entry *cis;\n\n\tlist_for_each_safe(l, n, &s->cis_cache) {\n\t\tcis = list_entry(l, struct cis_cache_entry, node);\n\t\tlist_del(&cis->node);\n\t\tkfree(cis);\n\t}\n}\n\n \nint verify_cis_cache(struct pcmcia_socket *s)\n{\n\tstruct cis_cache_entry *cis;\n\tchar *buf;\n\tint ret;\n\n\tif (s->state & SOCKET_CARDBUS)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(256, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tdev_warn(&s->dev, \"no memory for verifying CIS\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmutex_lock(&s->ops_mutex);\n\tlist_for_each_entry(cis, &s->cis_cache, node) {\n\t\tint len = cis->len;\n\n\t\tif (len > 256)\n\t\t\tlen = 256;\n\n\t\tret = pcmcia_read_cis_mem(s, cis->attr, cis->addr, len, buf);\n\t\tif (ret || memcmp(buf, cis->cache, len) != 0) {\n\t\t\tkfree(buf);\n\t\t\tmutex_unlock(&s->ops_mutex);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tkfree(buf);\n\tmutex_unlock(&s->ops_mutex);\n\treturn 0;\n}\n\n \nint pcmcia_replace_cis(struct pcmcia_socket *s,\n\t\t       const u8 *data, const size_t len)\n{\n\tif (len > CISTPL_MAX_CIS_SIZE) {\n\t\tdev_warn(&s->dev, \"replacement CIS too big\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&s->ops_mutex);\n\tkfree(s->fake_cis);\n\ts->fake_cis = kmalloc(len, GFP_KERNEL);\n\tif (s->fake_cis == NULL) {\n\t\tdev_warn(&s->dev, \"no memory to replace CIS\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -ENOMEM;\n\t}\n\ts->fake_cis_len = len;\n\tmemcpy(s->fake_cis, data, len);\n\tdev_info(&s->dev, \"Using replacement CIS\\n\");\n\tmutex_unlock(&s->ops_mutex);\n\treturn 0;\n}\n\n \n\nstruct tuple_flags {\n\tu_int\t\tlink_space:4;\n\tu_int\t\thas_link:1;\n\tu_int\t\tmfc_fn:3;\n\tu_int\t\tspace:4;\n};\n\n#define LINK_SPACE(f)\t(((struct tuple_flags *)(&(f)))->link_space)\n#define HAS_LINK(f)\t(((struct tuple_flags *)(&(f)))->has_link)\n#define MFC_FN(f)\t(((struct tuple_flags *)(&(f)))->mfc_fn)\n#define SPACE(f)\t(((struct tuple_flags *)(&(f)))->space)\n\nint pccard_get_first_tuple(struct pcmcia_socket *s, unsigned int function,\n\t\t\ttuple_t *tuple)\n{\n\tif (!s)\n\t\treturn -EINVAL;\n\n\tif (!(s->state & SOCKET_PRESENT) || (s->state & SOCKET_CARDBUS))\n\t\treturn -ENODEV;\n\ttuple->TupleLink = tuple->Flags = 0;\n\n\t \n\ttuple->CISOffset = tuple->LinkOffset = 0;\n\tSPACE(tuple->Flags) = HAS_LINK(tuple->Flags) = 1;\n\n\tif ((s->functions > 1) && !(tuple->Attributes & TUPLE_RETURN_COMMON)) {\n\t\tcisdata_t req = tuple->DesiredTuple;\n\t\ttuple->DesiredTuple = CISTPL_LONGLINK_MFC;\n\t\tif (pccard_get_next_tuple(s, function, tuple) == 0) {\n\t\t\ttuple->DesiredTuple = CISTPL_LINKTARGET;\n\t\t\tif (pccard_get_next_tuple(s, function, tuple) != 0)\n\t\t\t\treturn -ENOSPC;\n\t\t} else\n\t\t\ttuple->CISOffset = tuple->TupleLink = 0;\n\t\ttuple->DesiredTuple = req;\n\t}\n\treturn pccard_get_next_tuple(s, function, tuple);\n}\n\nstatic int follow_link(struct pcmcia_socket *s, tuple_t *tuple)\n{\n\tu_char link[5];\n\tu_int ofs;\n\tint ret;\n\n\tif (MFC_FN(tuple->Flags)) {\n\t\t \n\t\tret = read_cis_cache(s, LINK_SPACE(tuple->Flags),\n\t\t\t\ttuple->LinkOffset, 5, link);\n\t\tif (ret)\n\t\t\treturn -1;\n\t\tofs = get_unaligned_le32(link + 1);\n\t\tSPACE(tuple->Flags) = (link[0] == CISTPL_MFC_ATTR);\n\t\t \n\t\ttuple->LinkOffset += 5;\n\t\tMFC_FN(tuple->Flags)--;\n\t} else if (HAS_LINK(tuple->Flags)) {\n\t\tofs = tuple->LinkOffset;\n\t\tSPACE(tuple->Flags) = LINK_SPACE(tuple->Flags);\n\t\tHAS_LINK(tuple->Flags) = 0;\n\t} else\n\t\treturn -1;\n\n\tif (SPACE(tuple->Flags)) {\n\t\t \n\t\tret = read_cis_cache(s, SPACE(tuple->Flags), ofs, 5, link);\n\t\tif (ret)\n\t\t\treturn -1;\n\t\tif ((link[0] == CISTPL_LINKTARGET) && (link[1] >= 3) &&\n\t\t\t(strncmp(link+2, \"CIS\", 3) == 0))\n\t\t\treturn ofs;\n\t\tremove_cis_cache(s, SPACE(tuple->Flags), ofs, 5);\n\t\t \n\t\tofs = ofs >> 1;\n\t}\n\tret = read_cis_cache(s, SPACE(tuple->Flags), ofs, 5, link);\n\tif (ret)\n\t\treturn -1;\n\tif ((link[0] == CISTPL_LINKTARGET) && (link[1] >= 3) &&\n\t\t(strncmp(link+2, \"CIS\", 3) == 0))\n\t\treturn ofs;\n\tremove_cis_cache(s, SPACE(tuple->Flags), ofs, 5);\n\treturn -1;\n}\n\nint pccard_get_next_tuple(struct pcmcia_socket *s, unsigned int function,\n\t\t\ttuple_t *tuple)\n{\n\tu_char link[2], tmp;\n\tint ofs, i, attr;\n\tint ret;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\tif (!(s->state & SOCKET_PRESENT) || (s->state & SOCKET_CARDBUS))\n\t\treturn -ENODEV;\n\n\tlink[1] = tuple->TupleLink;\n\tofs = tuple->CISOffset + tuple->TupleLink;\n\tattr = SPACE(tuple->Flags);\n\n\tfor (i = 0; i < MAX_TUPLES; i++) {\n\t\tif (link[1] == 0xff)\n\t\t\tlink[0] = CISTPL_END;\n\t\telse {\n\t\t\tret = read_cis_cache(s, attr, ofs, 2, link);\n\t\t\tif (ret)\n\t\t\t\treturn -1;\n\t\t\tif (link[0] == CISTPL_NULL) {\n\t\t\t\tofs++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (link[0] == CISTPL_END) {\n\t\t\tofs = follow_link(s, tuple);\n\t\t\tif (ofs < 0)\n\t\t\t\treturn -ENOSPC;\n\t\t\tattr = SPACE(tuple->Flags);\n\t\t\tret = read_cis_cache(s, attr, ofs, 2, link);\n\t\t\tif (ret)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\t \n\t\tif ((link[0] == CISTPL_LONGLINK_A) ||\n\t\t\t(link[0] == CISTPL_LONGLINK_C) ||\n\t\t\t(link[0] == CISTPL_LONGLINK_MFC) ||\n\t\t\t(link[0] == CISTPL_LINKTARGET) ||\n\t\t\t(link[0] == CISTPL_INDIRECT) ||\n\t\t\t(link[0] == CISTPL_NO_LINK)) {\n\t\t\tswitch (link[0]) {\n\t\t\tcase CISTPL_LONGLINK_A:\n\t\t\t\tHAS_LINK(tuple->Flags) = 1;\n\t\t\t\tLINK_SPACE(tuple->Flags) = attr | IS_ATTR;\n\t\t\t\tret = read_cis_cache(s, attr, ofs+2, 4,\n\t\t\t\t\t\t&tuple->LinkOffset);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase CISTPL_LONGLINK_C:\n\t\t\t\tHAS_LINK(tuple->Flags) = 1;\n\t\t\t\tLINK_SPACE(tuple->Flags) = attr & ~IS_ATTR;\n\t\t\t\tret = read_cis_cache(s, attr, ofs+2, 4,\n\t\t\t\t\t\t&tuple->LinkOffset);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\tcase CISTPL_INDIRECT:\n\t\t\t\tHAS_LINK(tuple->Flags) = 1;\n\t\t\t\tLINK_SPACE(tuple->Flags) = IS_ATTR |\n\t\t\t\t\tIS_INDIRECT;\n\t\t\t\ttuple->LinkOffset = 0;\n\t\t\t\tbreak;\n\t\t\tcase CISTPL_LONGLINK_MFC:\n\t\t\t\ttuple->LinkOffset = ofs + 3;\n\t\t\t\tLINK_SPACE(tuple->Flags) = attr;\n\t\t\t\tif (function == BIND_FN_ALL) {\n\t\t\t\t\t \n\t\t\t\t\tret = read_cis_cache(s, attr, ofs+2,\n\t\t\t\t\t\t\t1, &tmp);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tMFC_FN(tuple->Flags) = tmp;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tMFC_FN(tuple->Flags) = 1;\n\t\t\t\t\ttuple->LinkOffset += function * 5;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CISTPL_NO_LINK:\n\t\t\t\tHAS_LINK(tuple->Flags) = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((tuple->Attributes & TUPLE_RETURN_LINK) &&\n\t\t\t\t(tuple->DesiredTuple == RETURN_FIRST_TUPLE))\n\t\t\t\tbreak;\n\t\t} else\n\t\t\tif (tuple->DesiredTuple == RETURN_FIRST_TUPLE)\n\t\t\t\tbreak;\n\n\t\tif (link[0] == tuple->DesiredTuple)\n\t\t\tbreak;\n\t\tofs += link[1] + 2;\n\t}\n\tif (i == MAX_TUPLES) {\n\t\tdev_dbg(&s->dev, \"cs: overrun in pcmcia_get_next_tuple\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\ttuple->TupleCode = link[0];\n\ttuple->TupleLink = link[1];\n\ttuple->CISOffset = ofs + 2;\n\treturn 0;\n}\n\nint pccard_get_tuple_data(struct pcmcia_socket *s, tuple_t *tuple)\n{\n\tu_int len;\n\tint ret;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\tif (tuple->TupleLink < tuple->TupleOffset)\n\t\treturn -ENOSPC;\n\tlen = tuple->TupleLink - tuple->TupleOffset;\n\ttuple->TupleDataLen = tuple->TupleLink;\n\tif (len == 0)\n\t\treturn 0;\n\tret = read_cis_cache(s, SPACE(tuple->Flags),\n\t\t\ttuple->CISOffset + tuple->TupleOffset,\n\t\t\tmin(len, (u_int) tuple->TupleDataMax),\n\t\t\ttuple->TupleData);\n\tif (ret)\n\t\treturn -1;\n\treturn 0;\n}\n\n\n \n\nstatic int parse_device(tuple_t *tuple, cistpl_device_t *device)\n{\n\tint i;\n\tu_char scale;\n\tu_char *p, *q;\n\n\tp = (u_char *)tuple->TupleData;\n\tq = p + tuple->TupleDataLen;\n\n\tdevice->ndev = 0;\n\tfor (i = 0; i < CISTPL_MAX_DEVICES; i++) {\n\n\t\tif (*p == 0xff)\n\t\t\tbreak;\n\t\tdevice->dev[i].type = (*p >> 4);\n\t\tdevice->dev[i].wp = (*p & 0x08) ? 1 : 0;\n\t\tswitch (*p & 0x07) {\n\t\tcase 0:\n\t\t\tdevice->dev[i].speed = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdevice->dev[i].speed = 250;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdevice->dev[i].speed = 200;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdevice->dev[i].speed = 150;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdevice->dev[i].speed = 100;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tif (++p == q)\n\t\t\t\treturn -EINVAL;\n\t\t\tdevice->dev[i].speed = SPEED_CVT(*p);\n\t\t\twhile (*p & 0x80)\n\t\t\t\tif (++p == q)\n\t\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (++p == q)\n\t\t\treturn -EINVAL;\n\t\tif (*p == 0xff)\n\t\t\tbreak;\n\t\tscale = *p & 7;\n\t\tif (scale == 7)\n\t\t\treturn -EINVAL;\n\t\tdevice->dev[i].size = ((*p >> 3) + 1) * (512 << (scale*2));\n\t\tdevice->ndev++;\n\t\tif (++p == q)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int parse_checksum(tuple_t *tuple, cistpl_checksum_t *csum)\n{\n\tu_char *p;\n\tif (tuple->TupleDataLen < 5)\n\t\treturn -EINVAL;\n\tp = (u_char *) tuple->TupleData;\n\tcsum->addr = tuple->CISOffset + get_unaligned_le16(p) - 2;\n\tcsum->len = get_unaligned_le16(p + 2);\n\tcsum->sum = *(p + 4);\n\treturn 0;\n}\n\n\nstatic int parse_longlink(tuple_t *tuple, cistpl_longlink_t *link)\n{\n\tif (tuple->TupleDataLen < 4)\n\t\treturn -EINVAL;\n\tlink->addr = get_unaligned_le32(tuple->TupleData);\n\treturn 0;\n}\n\n\nstatic int parse_longlink_mfc(tuple_t *tuple, cistpl_longlink_mfc_t *link)\n{\n\tu_char *p;\n\tint i;\n\n\tp = (u_char *)tuple->TupleData;\n\n\tlink->nfn = *p; p++;\n\tif (tuple->TupleDataLen <= link->nfn*5)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < link->nfn; i++) {\n\t\tlink->fn[i].space = *p; p++;\n\t\tlink->fn[i].addr = get_unaligned_le32(p);\n\t\tp += 4;\n\t}\n\treturn 0;\n}\n\n\nstatic int parse_strings(u_char *p, u_char *q, int max,\n\t\t\t char *s, u_char *ofs, u_char *found)\n{\n\tint i, j, ns;\n\n\tif (p == q)\n\t\treturn -EINVAL;\n\tns = 0; j = 0;\n\tfor (i = 0; i < max; i++) {\n\t\tif (*p == 0xff)\n\t\t\tbreak;\n\t\tofs[i] = j;\n\t\tns++;\n\t\tfor (;;) {\n\t\t\ts[j++] = (*p == 0xff) ? '\\0' : *p;\n\t\t\tif ((*p == '\\0') || (*p == 0xff))\n\t\t\t\tbreak;\n\t\t\tif (++p == q)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((*p == 0xff) || (++p == q))\n\t\t\tbreak;\n\t}\n\tif (found) {\n\t\t*found = ns;\n\t\treturn 0;\n\t}\n\n\treturn (ns == max) ? 0 : -EINVAL;\n}\n\n\nstatic int parse_vers_1(tuple_t *tuple, cistpl_vers_1_t *vers_1)\n{\n\tu_char *p, *q;\n\n\tp = (u_char *)tuple->TupleData;\n\tq = p + tuple->TupleDataLen;\n\n\tvers_1->major = *p; p++;\n\tvers_1->minor = *p; p++;\n\tif (p >= q)\n\t\treturn -EINVAL;\n\n\treturn parse_strings(p, q, CISTPL_VERS_1_MAX_PROD_STRINGS,\n\t\t\tvers_1->str, vers_1->ofs, &vers_1->ns);\n}\n\n\nstatic int parse_altstr(tuple_t *tuple, cistpl_altstr_t *altstr)\n{\n\tu_char *p, *q;\n\n\tp = (u_char *)tuple->TupleData;\n\tq = p + tuple->TupleDataLen;\n\n\treturn parse_strings(p, q, CISTPL_MAX_ALTSTR_STRINGS,\n\t\t\taltstr->str, altstr->ofs, &altstr->ns);\n}\n\n\nstatic int parse_jedec(tuple_t *tuple, cistpl_jedec_t *jedec)\n{\n\tu_char *p, *q;\n\tint nid;\n\n\tp = (u_char *)tuple->TupleData;\n\tq = p + tuple->TupleDataLen;\n\n\tfor (nid = 0; nid < CISTPL_MAX_DEVICES; nid++) {\n\t\tif (p > q-2)\n\t\t\tbreak;\n\t\tjedec->id[nid].mfr = p[0];\n\t\tjedec->id[nid].info = p[1];\n\t\tp += 2;\n\t}\n\tjedec->nid = nid;\n\treturn 0;\n}\n\n\nstatic int parse_manfid(tuple_t *tuple, cistpl_manfid_t *m)\n{\n\tif (tuple->TupleDataLen < 4)\n\t\treturn -EINVAL;\n\tm->manf = get_unaligned_le16(tuple->TupleData);\n\tm->card = get_unaligned_le16(tuple->TupleData + 2);\n\treturn 0;\n}\n\n\nstatic int parse_funcid(tuple_t *tuple, cistpl_funcid_t *f)\n{\n\tu_char *p;\n\tif (tuple->TupleDataLen < 2)\n\t\treturn -EINVAL;\n\tp = (u_char *)tuple->TupleData;\n\tf->func = p[0];\n\tf->sysinit = p[1];\n\treturn 0;\n}\n\n\nstatic int parse_funce(tuple_t *tuple, cistpl_funce_t *f)\n{\n\tu_char *p;\n\tint i;\n\tif (tuple->TupleDataLen < 1)\n\t\treturn -EINVAL;\n\tp = (u_char *)tuple->TupleData;\n\tf->type = p[0];\n\tfor (i = 1; i < tuple->TupleDataLen; i++)\n\t\tf->data[i-1] = p[i];\n\treturn 0;\n}\n\n\nstatic int parse_config(tuple_t *tuple, cistpl_config_t *config)\n{\n\tint rasz, rmsz, i;\n\tu_char *p;\n\n\tp = (u_char *)tuple->TupleData;\n\trasz = *p & 0x03;\n\trmsz = (*p & 0x3c) >> 2;\n\tif (tuple->TupleDataLen < rasz+rmsz+4)\n\t\treturn -EINVAL;\n\tconfig->last_idx = *(++p);\n\tp++;\n\tconfig->base = 0;\n\tfor (i = 0; i <= rasz; i++)\n\t\tconfig->base += p[i] << (8*i);\n\tp += rasz+1;\n\tfor (i = 0; i < 4; i++)\n\t\tconfig->rmask[i] = 0;\n\tfor (i = 0; i <= rmsz; i++)\n\t\tconfig->rmask[i>>2] += p[i] << (8*(i%4));\n\tconfig->subtuples = tuple->TupleDataLen - (rasz+rmsz+4);\n\treturn 0;\n}\n\n \n\nstatic u_char *parse_power(u_char *p, u_char *q, cistpl_power_t *pwr)\n{\n\tint i;\n\tu_int scale;\n\n\tif (p == q)\n\t\treturn NULL;\n\tpwr->present = *p;\n\tpwr->flags = 0;\n\tp++;\n\tfor (i = 0; i < 7; i++)\n\t\tif (pwr->present & (1<<i)) {\n\t\t\tif (p == q)\n\t\t\t\treturn NULL;\n\t\t\tpwr->param[i] = POWER_CVT(*p);\n\t\t\tscale = POWER_SCALE(*p);\n\t\t\twhile (*p & 0x80) {\n\t\t\t\tif (++p == q)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif ((*p & 0x7f) < 100)\n\t\t\t\t\tpwr->param[i] +=\n\t\t\t\t\t\t(*p & 0x7f) * scale / 100;\n\t\t\t\telse if (*p == 0x7d)\n\t\t\t\t\tpwr->flags |= CISTPL_POWER_HIGHZ_OK;\n\t\t\t\telse if (*p == 0x7e)\n\t\t\t\t\tpwr->param[i] = 0;\n\t\t\t\telse if (*p == 0x7f)\n\t\t\t\t\tpwr->flags |= CISTPL_POWER_HIGHZ_REQ;\n\t\t\t\telse\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\treturn p;\n}\n\n\nstatic u_char *parse_timing(u_char *p, u_char *q, cistpl_timing_t *timing)\n{\n\tu_char scale;\n\n\tif (p == q)\n\t\treturn NULL;\n\tscale = *p;\n\tif ((scale & 3) != 3) {\n\t\tif (++p == q)\n\t\t\treturn NULL;\n\t\ttiming->wait = SPEED_CVT(*p);\n\t\ttiming->waitscale = exponent[scale & 3];\n\t} else\n\t\ttiming->wait = 0;\n\tscale >>= 2;\n\tif ((scale & 7) != 7) {\n\t\tif (++p == q)\n\t\t\treturn NULL;\n\t\ttiming->ready = SPEED_CVT(*p);\n\t\ttiming->rdyscale = exponent[scale & 7];\n\t} else\n\t\ttiming->ready = 0;\n\tscale >>= 3;\n\tif (scale != 7) {\n\t\tif (++p == q)\n\t\t\treturn NULL;\n\t\ttiming->reserved = SPEED_CVT(*p);\n\t\ttiming->rsvscale = exponent[scale];\n\t} else\n\t\ttiming->reserved = 0;\n\tp++;\n\treturn p;\n}\n\n\nstatic u_char *parse_io(u_char *p, u_char *q, cistpl_io_t *io)\n{\n\tint i, j, bsz, lsz;\n\n\tif (p == q)\n\t\treturn NULL;\n\tio->flags = *p;\n\n\tif (!(*p & 0x80)) {\n\t\tio->nwin = 1;\n\t\tio->win[0].base = 0;\n\t\tio->win[0].len = (1 << (io->flags & CISTPL_IO_LINES_MASK));\n\t\treturn p+1;\n\t}\n\n\tif (++p == q)\n\t\treturn NULL;\n\tio->nwin = (*p & 0x0f) + 1;\n\tbsz = (*p & 0x30) >> 4;\n\tif (bsz == 3)\n\t\tbsz++;\n\tlsz = (*p & 0xc0) >> 6;\n\tif (lsz == 3)\n\t\tlsz++;\n\tp++;\n\n\tfor (i = 0; i < io->nwin; i++) {\n\t\tio->win[i].base = 0;\n\t\tio->win[i].len = 1;\n\t\tfor (j = 0; j < bsz; j++, p++) {\n\t\t\tif (p == q)\n\t\t\t\treturn NULL;\n\t\t\tio->win[i].base += *p << (j*8);\n\t\t}\n\t\tfor (j = 0; j < lsz; j++, p++) {\n\t\t\tif (p == q)\n\t\t\t\treturn NULL;\n\t\t\tio->win[i].len += *p << (j*8);\n\t\t}\n\t}\n\treturn p;\n}\n\n\nstatic u_char *parse_mem(u_char *p, u_char *q, cistpl_mem_t *mem)\n{\n\tint i, j, asz, lsz, has_ha;\n\tu_int len, ca, ha;\n\n\tif (p == q)\n\t\treturn NULL;\n\n\tmem->nwin = (*p & 0x07) + 1;\n\tlsz = (*p & 0x18) >> 3;\n\tasz = (*p & 0x60) >> 5;\n\thas_ha = (*p & 0x80);\n\tif (++p == q)\n\t\treturn NULL;\n\n\tfor (i = 0; i < mem->nwin; i++) {\n\t\tlen = ca = ha = 0;\n\t\tfor (j = 0; j < lsz; j++, p++) {\n\t\t\tif (p == q)\n\t\t\t\treturn NULL;\n\t\t\tlen += *p << (j*8);\n\t\t}\n\t\tfor (j = 0; j < asz; j++, p++) {\n\t\t\tif (p == q)\n\t\t\t\treturn NULL;\n\t\t\tca += *p << (j*8);\n\t\t}\n\t\tif (has_ha)\n\t\t\tfor (j = 0; j < asz; j++, p++) {\n\t\t\t\tif (p == q)\n\t\t\t\t\treturn NULL;\n\t\t\t\tha += *p << (j*8);\n\t\t\t}\n\t\tmem->win[i].len = len << 8;\n\t\tmem->win[i].card_addr = ca << 8;\n\t\tmem->win[i].host_addr = ha << 8;\n\t}\n\treturn p;\n}\n\n\nstatic u_char *parse_irq(u_char *p, u_char *q, cistpl_irq_t *irq)\n{\n\tif (p == q)\n\t\treturn NULL;\n\tirq->IRQInfo1 = *p; p++;\n\tif (irq->IRQInfo1 & IRQ_INFO2_VALID) {\n\t\tif (p+2 > q)\n\t\t\treturn NULL;\n\t\tirq->IRQInfo2 = (p[1]<<8) + p[0];\n\t\tp += 2;\n\t}\n\treturn p;\n}\n\n\nstatic int parse_cftable_entry(tuple_t *tuple,\n\t\t\t       cistpl_cftable_entry_t *entry)\n{\n\tu_char *p, *q, features;\n\n\tp = tuple->TupleData;\n\tq = p + tuple->TupleDataLen;\n\tentry->index = *p & 0x3f;\n\tentry->flags = 0;\n\tif (*p & 0x40)\n\t\tentry->flags |= CISTPL_CFTABLE_DEFAULT;\n\tif (*p & 0x80) {\n\t\tif (++p == q)\n\t\t\treturn -EINVAL;\n\t\tif (*p & 0x10)\n\t\t\tentry->flags |= CISTPL_CFTABLE_BVDS;\n\t\tif (*p & 0x20)\n\t\t\tentry->flags |= CISTPL_CFTABLE_WP;\n\t\tif (*p & 0x40)\n\t\t\tentry->flags |= CISTPL_CFTABLE_RDYBSY;\n\t\tif (*p & 0x80)\n\t\t\tentry->flags |= CISTPL_CFTABLE_MWAIT;\n\t\tentry->interface = *p & 0x0f;\n\t} else\n\t\tentry->interface = 0;\n\n\t \n\tif (++p == q)\n\t\treturn -EINVAL;\n\tfeatures = *p; p++;\n\n\t \n\tif ((features & 3) > 0) {\n\t\tp = parse_power(p, q, &entry->vcc);\n\t\tif (p == NULL)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tentry->vcc.present = 0;\n\tif ((features & 3) > 1) {\n\t\tp = parse_power(p, q, &entry->vpp1);\n\t\tif (p == NULL)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tentry->vpp1.present = 0;\n\tif ((features & 3) > 2) {\n\t\tp = parse_power(p, q, &entry->vpp2);\n\t\tif (p == NULL)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tentry->vpp2.present = 0;\n\n\t \n\tif (features & 0x04) {\n\t\tp = parse_timing(p, q, &entry->timing);\n\t\tif (p == NULL)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tentry->timing.wait = 0;\n\t\tentry->timing.ready = 0;\n\t\tentry->timing.reserved = 0;\n\t}\n\n\t \n\tif (features & 0x08) {\n\t\tp = parse_io(p, q, &entry->io);\n\t\tif (p == NULL)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tentry->io.nwin = 0;\n\n\t \n\tif (features & 0x10) {\n\t\tp = parse_irq(p, q, &entry->irq);\n\t\tif (p == NULL)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tentry->irq.IRQInfo1 = 0;\n\n\tswitch (features & 0x60) {\n\tcase 0x00:\n\t\tentry->mem.nwin = 0;\n\t\tbreak;\n\tcase 0x20:\n\t\tentry->mem.nwin = 1;\n\t\tentry->mem.win[0].len = get_unaligned_le16(p) << 8;\n\t\tentry->mem.win[0].card_addr = 0;\n\t\tentry->mem.win[0].host_addr = 0;\n\t\tp += 2;\n\t\tif (p > q)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase 0x40:\n\t\tentry->mem.nwin = 1;\n\t\tentry->mem.win[0].len = get_unaligned_le16(p) << 8;\n\t\tentry->mem.win[0].card_addr = get_unaligned_le16(p + 2) << 8;\n\t\tentry->mem.win[0].host_addr = 0;\n\t\tp += 4;\n\t\tif (p > q)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase 0x60:\n\t\tp = parse_mem(p, q, &entry->mem);\n\t\tif (p == NULL)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\t \n\tif (features & 0x80) {\n\t\tif (p == q)\n\t\t\treturn -EINVAL;\n\t\tentry->flags |= (*p << 8);\n\t\twhile (*p & 0x80)\n\t\t\tif (++p == q)\n\t\t\t\treturn -EINVAL;\n\t\tp++;\n\t}\n\n\tentry->subtuples = q-p;\n\n\treturn 0;\n}\n\n\nstatic int parse_device_geo(tuple_t *tuple, cistpl_device_geo_t *geo)\n{\n\tu_char *p, *q;\n\tint n;\n\n\tp = (u_char *)tuple->TupleData;\n\tq = p + tuple->TupleDataLen;\n\n\tfor (n = 0; n < CISTPL_MAX_DEVICES; n++) {\n\t\tif (p > q-6)\n\t\t\tbreak;\n\t\tgeo->geo[n].buswidth = p[0];\n\t\tgeo->geo[n].erase_block = 1 << (p[1]-1);\n\t\tgeo->geo[n].read_block  = 1 << (p[2]-1);\n\t\tgeo->geo[n].write_block = 1 << (p[3]-1);\n\t\tgeo->geo[n].partition   = 1 << (p[4]-1);\n\t\tgeo->geo[n].interleave  = 1 << (p[5]-1);\n\t\tp += 6;\n\t}\n\tgeo->ngeo = n;\n\treturn 0;\n}\n\n\nstatic int parse_vers_2(tuple_t *tuple, cistpl_vers_2_t *v2)\n{\n\tu_char *p, *q;\n\n\tif (tuple->TupleDataLen < 10)\n\t\treturn -EINVAL;\n\n\tp = tuple->TupleData;\n\tq = p + tuple->TupleDataLen;\n\n\tv2->vers = p[0];\n\tv2->comply = p[1];\n\tv2->dindex = get_unaligned_le16(p + 2);\n\tv2->vspec8 = p[6];\n\tv2->vspec9 = p[7];\n\tv2->nhdr = p[8];\n\tp += 9;\n\treturn parse_strings(p, q, 2, v2->str, &v2->vendor, NULL);\n}\n\n\nstatic int parse_org(tuple_t *tuple, cistpl_org_t *org)\n{\n\tu_char *p, *q;\n\tint i;\n\n\tp = tuple->TupleData;\n\tq = p + tuple->TupleDataLen;\n\tif (p == q)\n\t\treturn -EINVAL;\n\torg->data_org = *p;\n\tif (++p == q)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < 30; i++) {\n\t\torg->desc[i] = *p;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\n\t\tif (++p == q)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n\nstatic int parse_format(tuple_t *tuple, cistpl_format_t *fmt)\n{\n\tu_char *p;\n\n\tif (tuple->TupleDataLen < 10)\n\t\treturn -EINVAL;\n\n\tp = tuple->TupleData;\n\n\tfmt->type = p[0];\n\tfmt->edc = p[1];\n\tfmt->offset = get_unaligned_le32(p + 2);\n\tfmt->length = get_unaligned_le32(p + 6);\n\n\treturn 0;\n}\n\n\nint pcmcia_parse_tuple(tuple_t *tuple, cisparse_t *parse)\n{\n\tint ret = 0;\n\n\tif (tuple->TupleDataLen > tuple->TupleDataMax)\n\t\treturn -EINVAL;\n\tswitch (tuple->TupleCode) {\n\tcase CISTPL_DEVICE:\n\tcase CISTPL_DEVICE_A:\n\t\tret = parse_device(tuple, &parse->device);\n\t\tbreak;\n\tcase CISTPL_CHECKSUM:\n\t\tret = parse_checksum(tuple, &parse->checksum);\n\t\tbreak;\n\tcase CISTPL_LONGLINK_A:\n\tcase CISTPL_LONGLINK_C:\n\t\tret = parse_longlink(tuple, &parse->longlink);\n\t\tbreak;\n\tcase CISTPL_LONGLINK_MFC:\n\t\tret = parse_longlink_mfc(tuple, &parse->longlink_mfc);\n\t\tbreak;\n\tcase CISTPL_VERS_1:\n\t\tret = parse_vers_1(tuple, &parse->version_1);\n\t\tbreak;\n\tcase CISTPL_ALTSTR:\n\t\tret = parse_altstr(tuple, &parse->altstr);\n\t\tbreak;\n\tcase CISTPL_JEDEC_A:\n\tcase CISTPL_JEDEC_C:\n\t\tret = parse_jedec(tuple, &parse->jedec);\n\t\tbreak;\n\tcase CISTPL_MANFID:\n\t\tret = parse_manfid(tuple, &parse->manfid);\n\t\tbreak;\n\tcase CISTPL_FUNCID:\n\t\tret = parse_funcid(tuple, &parse->funcid);\n\t\tbreak;\n\tcase CISTPL_FUNCE:\n\t\tret = parse_funce(tuple, &parse->funce);\n\t\tbreak;\n\tcase CISTPL_CONFIG:\n\t\tret = parse_config(tuple, &parse->config);\n\t\tbreak;\n\tcase CISTPL_CFTABLE_ENTRY:\n\t\tret = parse_cftable_entry(tuple, &parse->cftable_entry);\n\t\tbreak;\n\tcase CISTPL_DEVICE_GEO:\n\tcase CISTPL_DEVICE_GEO_A:\n\t\tret = parse_device_geo(tuple, &parse->device_geo);\n\t\tbreak;\n\tcase CISTPL_VERS_2:\n\t\tret = parse_vers_2(tuple, &parse->vers_2);\n\t\tbreak;\n\tcase CISTPL_ORG:\n\t\tret = parse_org(tuple, &parse->org);\n\t\tbreak;\n\tcase CISTPL_FORMAT:\n\tcase CISTPL_FORMAT_A:\n\t\tret = parse_format(tuple, &parse->format);\n\t\tbreak;\n\tcase CISTPL_NO_LINK:\n\tcase CISTPL_LINKTARGET:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tpr_debug(\"parse_tuple failed %d\\n\", ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(pcmcia_parse_tuple);\n\n\n \nint pccard_validate_cis(struct pcmcia_socket *s, unsigned int *info)\n{\n\ttuple_t *tuple;\n\tcisparse_t *p;\n\tunsigned int count = 0;\n\tint ret, reserved, dev_ok = 0, ident_ok = 0;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\tif (s->functions || !(s->state & SOCKET_PRESENT)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmutex_lock(&s->ops_mutex);\n\tdestroy_cis_cache(s);\n\tmutex_unlock(&s->ops_mutex);\n\n\ttuple = kmalloc(sizeof(*tuple), GFP_KERNEL);\n\tif (tuple == NULL) {\n\t\tdev_warn(&s->dev, \"no memory to validate CIS\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL) {\n\t\tkfree(tuple);\n\t\tdev_warn(&s->dev, \"no memory to validate CIS\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcount = reserved = 0;\n\ttuple->DesiredTuple = RETURN_FIRST_TUPLE;\n\ttuple->Attributes = TUPLE_RETURN_COMMON;\n\tret = pccard_get_first_tuple(s, BIND_FN_ALL, tuple);\n\tif (ret != 0)\n\t\tgoto done;\n\n\t \n\tif ((tuple->TupleCode == CISTPL_DEVICE) ||\n\t    (!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_CFTABLE_ENTRY, p)) ||\n\t    (!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_CFTABLE_ENTRY_CB, p)))\n\t\tdev_ok++;\n\n\t \n\tif ((pccard_read_tuple(s, BIND_FN_ALL, CISTPL_MANFID, p) == 0) ||\n\t    (pccard_read_tuple(s, BIND_FN_ALL, CISTPL_VERS_1, p) == 0) ||\n\t    (pccard_read_tuple(s, BIND_FN_ALL, CISTPL_VERS_2, p) != -ENOSPC))\n\t\tident_ok++;\n\n\tif (!dev_ok && !ident_ok)\n\t\tgoto done;\n\n\tfor (count = 1; count < MAX_TUPLES; count++) {\n\t\tret = pccard_get_next_tuple(s, BIND_FN_ALL, tuple);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\tif (((tuple->TupleCode > 0x23) && (tuple->TupleCode < 0x40)) ||\n\t\t    ((tuple->TupleCode > 0x47) && (tuple->TupleCode < 0x80)) ||\n\t\t    ((tuple->TupleCode > 0x90) && (tuple->TupleCode < 0xff)))\n\t\t\treserved++;\n\t}\n\tif ((count == MAX_TUPLES) || (reserved > 5) ||\n\t\t((!dev_ok || !ident_ok) && (count > 10)))\n\t\tcount = 0;\n\n\tret = 0;\n\ndone:\n\t \n\tif (!dev_ok || !ident_ok || !count) {\n\t\tmutex_lock(&s->ops_mutex);\n\t\tdestroy_cis_cache(s);\n\t\tmutex_unlock(&s->ops_mutex);\n\t\t \n\t\tif (!dev_ok || !ident_ok)\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = -EFAULT;\n\t}\n\n\tif (info)\n\t\t*info = count;\n\tkfree(tuple);\n\tkfree(p);\n\treturn ret;\n}\n\n\n#define to_socket(_dev) container_of(_dev, struct pcmcia_socket, dev)\n\nstatic ssize_t pccard_extract_cis(struct pcmcia_socket *s, char *buf,\n\t\t\t\t  loff_t off, size_t count)\n{\n\ttuple_t tuple;\n\tint status, i;\n\tloff_t pointer = 0;\n\tssize_t ret = 0;\n\tu_char *tuplebuffer;\n\tu_char *tempbuffer;\n\n\ttuplebuffer = kmalloc_array(256, sizeof(u_char), GFP_KERNEL);\n\tif (!tuplebuffer)\n\t\treturn -ENOMEM;\n\n\ttempbuffer = kmalloc_array(258, sizeof(u_char), GFP_KERNEL);\n\tif (!tempbuffer) {\n\t\tret = -ENOMEM;\n\t\tgoto free_tuple;\n\t}\n\n\tmemset(&tuple, 0, sizeof(tuple_t));\n\n\ttuple.Attributes = TUPLE_RETURN_LINK | TUPLE_RETURN_COMMON;\n\ttuple.DesiredTuple = RETURN_FIRST_TUPLE;\n\ttuple.TupleOffset = 0;\n\n\tstatus = pccard_get_first_tuple(s, BIND_FN_ALL, &tuple);\n\twhile (!status) {\n\t\ttuple.TupleData = tuplebuffer;\n\t\ttuple.TupleDataMax = 255;\n\t\tmemset(tuplebuffer, 0, sizeof(u_char) * 255);\n\n\t\tstatus = pccard_get_tuple_data(s, &tuple);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tif (off < (pointer + 2 + tuple.TupleDataLen)) {\n\t\t\ttempbuffer[0] = tuple.TupleCode & 0xff;\n\t\t\ttempbuffer[1] = tuple.TupleLink & 0xff;\n\t\t\tfor (i = 0; i < tuple.TupleDataLen; i++)\n\t\t\t\ttempbuffer[i + 2] = tuplebuffer[i] & 0xff;\n\n\t\t\tfor (i = 0; i < (2 + tuple.TupleDataLen); i++) {\n\t\t\t\tif (((i + pointer) >= off) &&\n\t\t\t\t    (i + pointer) < (off + count)) {\n\t\t\t\t\tbuf[ret] = tempbuffer[i];\n\t\t\t\t\tret++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpointer += 2 + tuple.TupleDataLen;\n\n\t\tif (pointer >= (off + count))\n\t\t\tbreak;\n\n\t\tif (tuple.TupleCode == CISTPL_END)\n\t\t\tbreak;\n\t\tstatus = pccard_get_next_tuple(s, BIND_FN_ALL, &tuple);\n\t}\n\n\tkfree(tempbuffer);\n free_tuple:\n\tkfree(tuplebuffer);\n\n\treturn ret;\n}\n\n\nstatic ssize_t pccard_show_cis(struct file *filp, struct kobject *kobj,\n\t\t\t       struct bin_attribute *bin_attr,\n\t\t\t       char *buf, loff_t off, size_t count)\n{\n\tunsigned int size = 0x200;\n\n\tif (off >= size)\n\t\tcount = 0;\n\telse {\n\t\tstruct pcmcia_socket *s;\n\t\tunsigned int chains = 1;\n\n\t\tif (off + count > size)\n\t\t\tcount = size - off;\n\n\t\ts = to_socket(kobj_to_dev(kobj));\n\n\t\tif (!(s->state & SOCKET_PRESENT))\n\t\t\treturn -ENODEV;\n\t\tif (!s->functions && pccard_validate_cis(s, &chains))\n\t\t\treturn -EIO;\n\t\tif (!chains)\n\t\t\treturn -ENODATA;\n\n\t\tcount = pccard_extract_cis(s, buf, off, count);\n\t}\n\n\treturn count;\n}\n\n\nstatic ssize_t pccard_store_cis(struct file *filp, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr,\n\t\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct pcmcia_socket *s;\n\tint error;\n\n\terror = security_locked_down(LOCKDOWN_PCMCIA_CIS);\n\tif (error)\n\t\treturn error;\n\n\ts = to_socket(kobj_to_dev(kobj));\n\n\tif (off)\n\t\treturn -EINVAL;\n\n\tif (count >= CISTPL_MAX_CIS_SIZE)\n\t\treturn -EINVAL;\n\n\tif (!(s->state & SOCKET_PRESENT))\n\t\treturn -ENODEV;\n\n\terror = pcmcia_replace_cis(s, buf, count);\n\tif (error)\n\t\treturn -EIO;\n\n\tpcmcia_parse_uevents(s, PCMCIA_UEVENT_REQUERY);\n\n\treturn count;\n}\n\n\nconst struct bin_attribute pccard_cis_attr = {\n\t.attr = { .name = \"cis\", .mode = S_IRUGO | S_IWUSR },\n\t.size = 0x200,\n\t.read = pccard_show_cis,\n\t.write = pccard_store_cis,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}