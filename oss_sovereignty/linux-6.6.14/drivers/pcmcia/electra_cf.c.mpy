{
  "module_name": "electra_cf.c",
  "hash_id": "ec26b0b6ee0bda8c8baeb252d6d00a8814003b0d6da7fd54d58cd97defcc423f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/electra_cf.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/platform_device.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/slab.h>\n\n#include <pcmcia/ss.h>\n\nstatic const char driver_name[] = \"electra-cf\";\n\nstruct electra_cf_socket {\n\tstruct pcmcia_socket\tsocket;\n\n\tstruct timer_list\ttimer;\n\tunsigned\t\tpresent:1;\n\tunsigned\t\tactive:1;\n\n\tstruct platform_device\t*ofdev;\n\tunsigned long\t\tmem_phys;\n\tvoid __iomem\t\t*mem_base;\n\tunsigned long\t\tmem_size;\n\tvoid __iomem\t\t*io_virt;\n\tunsigned int\t\tio_base;\n\tunsigned int\t\tio_size;\n\tu_int\t\t\tirq;\n\tstruct resource\t\tiomem;\n\tvoid __iomem\t\t*gpio_base;\n\tint\t\t\tgpio_detect;\n\tint\t\t\tgpio_vsense;\n\tint\t\t\tgpio_3v;\n\tint\t\t\tgpio_5v;\n};\n\n#define\tPOLL_INTERVAL\t\t(2 * HZ)\n\n\nstatic int electra_cf_present(struct electra_cf_socket *cf)\n{\n\tunsigned int gpio;\n\n\tgpio = in_le32(cf->gpio_base+0x40);\n\treturn !(gpio & (1 << cf->gpio_detect));\n}\n\nstatic int electra_cf_ss_init(struct pcmcia_socket *s)\n{\n\treturn 0;\n}\n\n \nstatic void electra_cf_timer(struct timer_list *t)\n{\n\tstruct electra_cf_socket *cf = from_timer(cf, t, timer);\n\tint present = electra_cf_present(cf);\n\n\tif (present != cf->present) {\n\t\tcf->present = present;\n\t\tpcmcia_parse_events(&cf->socket, SS_DETECT);\n\t}\n\n\tif (cf->active)\n\t\tmod_timer(&cf->timer, jiffies + POLL_INTERVAL);\n}\n\nstatic irqreturn_t electra_cf_irq(int irq, void *_cf)\n{\n\tstruct electra_cf_socket *cf = _cf;\n\n\telectra_cf_timer(&cf->timer);\n\treturn IRQ_HANDLED;\n}\n\nstatic int electra_cf_get_status(struct pcmcia_socket *s, u_int *sp)\n{\n\tstruct electra_cf_socket *cf;\n\n\tif (!sp)\n\t\treturn -EINVAL;\n\n\tcf = container_of(s, struct electra_cf_socket, socket);\n\n\t \n\tif (electra_cf_present(cf)) {\n\t\t*sp = SS_READY | SS_DETECT | SS_POWERON | SS_3VCARD;\n\n\t\ts->pci_irq = cf->irq;\n\t} else\n\t\t*sp = 0;\n\treturn 0;\n}\n\nstatic int electra_cf_set_socket(struct pcmcia_socket *sock,\n\t\t\t\t struct socket_state_t *s)\n{\n\tunsigned int gpio;\n\tunsigned int vcc;\n\tstruct electra_cf_socket *cf;\n\n\tcf = container_of(sock, struct electra_cf_socket, socket);\n\n\t \n\tvcc = (s->flags & SS_RESET) ? 0 : s->Vcc;\n\n\tswitch (vcc) {\n\tcase 0:\n\t\tgpio = 0;\n\t\tbreak;\n\tcase 33:\n\t\tgpio = (1 << cf->gpio_3v);\n\t\tbreak;\n\tcase 5:\n\t\tgpio = (1 << cf->gpio_5v);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tgpio |= 1 << (cf->gpio_3v + 16);  \n\tgpio |= 1 << (cf->gpio_5v + 16);  \n\tout_le32(cf->gpio_base+0x90, gpio);\n\n\tpr_debug(\"%s: Vcc %d, io_irq %d, flags %04x csc %04x\\n\",\n\t\tdriver_name, s->Vcc, s->io_irq, s->flags, s->csc_mask);\n\n\treturn 0;\n}\n\nstatic int electra_cf_set_io_map(struct pcmcia_socket *s,\n\t\t\t\t struct pccard_io_map *io)\n{\n\treturn 0;\n}\n\nstatic int electra_cf_set_mem_map(struct pcmcia_socket *s,\n\t\t\t\t  struct pccard_mem_map *map)\n{\n\tstruct electra_cf_socket *cf;\n\n\tif (map->card_start)\n\t\treturn -EINVAL;\n\tcf = container_of(s, struct electra_cf_socket, socket);\n\tmap->static_start = cf->mem_phys;\n\tmap->flags &= MAP_ACTIVE|MAP_ATTRIB;\n\tif (!(map->flags & MAP_ATTRIB))\n\t\tmap->static_start += 0x800;\n\treturn 0;\n}\n\nstatic struct pccard_operations electra_cf_ops = {\n\t.init\t\t\t= electra_cf_ss_init,\n\t.get_status\t\t= electra_cf_get_status,\n\t.set_socket\t\t= electra_cf_set_socket,\n\t.set_io_map\t\t= electra_cf_set_io_map,\n\t.set_mem_map\t\t= electra_cf_set_mem_map,\n};\n\nstatic int electra_cf_probe(struct platform_device *ofdev)\n{\n\tstruct device *device = &ofdev->dev;\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct electra_cf_socket   *cf;\n\tstruct resource mem, io;\n\tint status = -ENOMEM;\n\tconst unsigned int *prop;\n\tint err;\n\n\terr = of_address_to_resource(np, 0, &mem);\n\tif (err)\n\t\treturn -EINVAL;\n\n\terr = of_address_to_resource(np, 1, &io);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tcf = kzalloc(sizeof(*cf), GFP_KERNEL);\n\tif (!cf)\n\t\treturn -ENOMEM;\n\n\ttimer_setup(&cf->timer, electra_cf_timer, 0);\n\tcf->irq = 0;\n\n\tcf->ofdev = ofdev;\n\tcf->mem_phys = mem.start;\n\tcf->mem_size = PAGE_ALIGN(resource_size(&mem));\n\tcf->mem_base = ioremap(cf->mem_phys, cf->mem_size);\n\tif (!cf->mem_base)\n\t\tgoto out_free_cf;\n\tcf->io_size = PAGE_ALIGN(resource_size(&io));\n\tcf->io_virt = ioremap_phb(io.start, cf->io_size);\n\tif (!cf->io_virt)\n\t\tgoto out_unmap_mem;\n\n\tcf->gpio_base = ioremap(0xfc103000, 0x1000);\n\tif (!cf->gpio_base)\n\t\tgoto out_unmap_virt;\n\tdev_set_drvdata(device, cf);\n\n\tcf->io_base = (unsigned long)cf->io_virt - VMALLOC_END;\n\tcf->iomem.start = (unsigned long)cf->mem_base;\n\tcf->iomem.end = (unsigned long)cf->mem_base + (mem.end - mem.start);\n\tcf->iomem.flags = IORESOURCE_MEM;\n\n\tcf->irq = irq_of_parse_and_map(np, 0);\n\n\tstatus = request_irq(cf->irq, electra_cf_irq, IRQF_SHARED,\n\t\t\t     driver_name, cf);\n\tif (status < 0) {\n\t\tdev_err(device, \"request_irq failed\\n\");\n\t\tgoto fail1;\n\t}\n\n\tcf->socket.pci_irq = cf->irq;\n\n\tstatus = -EINVAL;\n\n\tprop = of_get_property(np, \"card-detect-gpio\", NULL);\n\tif (!prop)\n\t\tgoto fail1;\n\tcf->gpio_detect = *prop;\n\n\tprop = of_get_property(np, \"card-vsense-gpio\", NULL);\n\tif (!prop)\n\t\tgoto fail1;\n\tcf->gpio_vsense = *prop;\n\n\tprop = of_get_property(np, \"card-3v-gpio\", NULL);\n\tif (!prop)\n\t\tgoto fail1;\n\tcf->gpio_3v = *prop;\n\n\tprop = of_get_property(np, \"card-5v-gpio\", NULL);\n\tif (!prop)\n\t\tgoto fail1;\n\tcf->gpio_5v = *prop;\n\n\tcf->socket.io_offset = cf->io_base;\n\n\t \n\tif (!request_mem_region(cf->mem_phys, cf->mem_size, driver_name)) {\n\t\tstatus = -ENXIO;\n\t\tdev_err(device, \"Can't claim memory region\\n\");\n\t\tgoto fail1;\n\t}\n\n\tif (!request_region(cf->io_base, cf->io_size, driver_name)) {\n\t\tstatus = -ENXIO;\n\t\tdev_err(device, \"Can't claim I/O region\\n\");\n\t\tgoto fail2;\n\t}\n\n\tcf->socket.owner = THIS_MODULE;\n\tcf->socket.dev.parent = &ofdev->dev;\n\tcf->socket.ops = &electra_cf_ops;\n\tcf->socket.resource_ops = &pccard_static_ops;\n\tcf->socket.features = SS_CAP_PCCARD | SS_CAP_STATIC_MAP |\n\t\t\t\tSS_CAP_MEM_ALIGN;\n\tcf->socket.map_size = 0x800;\n\n\tstatus = pcmcia_register_socket(&cf->socket);\n\tif (status < 0) {\n\t\tdev_err(device, \"pcmcia_register_socket failed\\n\");\n\t\tgoto fail3;\n\t}\n\n\tdev_info(device, \"at mem 0x%lx io 0x%llx irq %d\\n\",\n\t\t cf->mem_phys, io.start, cf->irq);\n\n\tcf->active = 1;\n\telectra_cf_timer(&cf->timer);\n\treturn 0;\n\nfail3:\n\trelease_region(cf->io_base, cf->io_size);\nfail2:\n\trelease_mem_region(cf->mem_phys, cf->mem_size);\nfail1:\n\tif (cf->irq)\n\t\tfree_irq(cf->irq, cf);\n\n\tiounmap(cf->gpio_base);\nout_unmap_virt:\n\tdevice_init_wakeup(&ofdev->dev, 0);\n\tiounmap(cf->io_virt);\nout_unmap_mem:\n\tiounmap(cf->mem_base);\nout_free_cf:\n\tkfree(cf);\n\treturn status;\n\n}\n\nstatic int electra_cf_remove(struct platform_device *ofdev)\n{\n\tstruct device *device = &ofdev->dev;\n\tstruct electra_cf_socket *cf;\n\n\tcf = dev_get_drvdata(device);\n\n\tcf->active = 0;\n\tpcmcia_unregister_socket(&cf->socket);\n\tfree_irq(cf->irq, cf);\n\ttimer_shutdown_sync(&cf->timer);\n\n\tiounmap(cf->io_virt);\n\tiounmap(cf->mem_base);\n\tiounmap(cf->gpio_base);\n\trelease_mem_region(cf->mem_phys, cf->mem_size);\n\trelease_region(cf->io_base, cf->io_size);\n\n\tkfree(cf);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id electra_cf_match[] = {\n\t{\n\t\t.compatible   = \"electra-cf\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, electra_cf_match);\n\nstatic struct platform_driver electra_cf_driver = {\n\t.driver = {\n\t\t.name = driver_name,\n\t\t.of_match_table = electra_cf_match,\n\t},\n\t.probe\t  = electra_cf_probe,\n\t.remove   = electra_cf_remove,\n};\n\nmodule_platform_driver(electra_cf_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Olof Johansson <olof@lixom.net>\");\nMODULE_DESCRIPTION(\"PA Semi Electra CF driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}