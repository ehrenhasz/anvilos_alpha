{
  "module_name": "pd6729.c",
  "hash_id": "c8392e11e5bc369a2158fc8060ce80f90b4d8f73f6ff8116c1361e1777f56f9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/pd6729.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/io.h>\n\n#include <pcmcia/ss.h>\n\n\n#include \"pd6729.h\"\n#include \"i82365.h\"\n#include \"cirrus.h\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Driver for the Cirrus PD6729 PCI-PCMCIA bridge\");\nMODULE_AUTHOR(\"Jun Komuro <komurojun-mbn@nifty.com>\");\n\n#define MAX_SOCKETS 2\n\n \n#define to_cycles(ns)\t((ns)/120)\n\n#ifndef NO_IRQ\n#define NO_IRQ\t((unsigned int)(0))\n#endif\n\n \n\nstatic int irq_mode = 1;  \n\nmodule_param(irq_mode, int, 0444);\nMODULE_PARM_DESC(irq_mode,\n\t\t\"interrupt delivery mode. 0 = ISA, 1 = PCI. default is 1\");\n\nstatic DEFINE_SPINLOCK(port_lock);\n\n \n\nstatic unsigned char indirect_read(struct pd6729_socket *socket,\n\t\t\t\t   unsigned short reg)\n{\n\tunsigned long port;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port_lock, flags);\n\treg += socket->number * 0x40;\n\tport = socket->io_base;\n\toutb(reg, port);\n\tval = inb(port + 1);\n\tspin_unlock_irqrestore(&port_lock, flags);\n\n\treturn val;\n}\n\nstatic unsigned short indirect_read16(struct pd6729_socket *socket,\n\t\t\t\t      unsigned short reg)\n{\n\tunsigned long port;\n\tunsigned short tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port_lock, flags);\n\treg  = reg + socket->number * 0x40;\n\tport = socket->io_base;\n\toutb(reg, port);\n\ttmp = inb(port + 1);\n\treg++;\n\toutb(reg, port);\n\ttmp = tmp | (inb(port + 1) << 8);\n\tspin_unlock_irqrestore(&port_lock, flags);\n\n\treturn tmp;\n}\n\nstatic void indirect_write(struct pd6729_socket *socket, unsigned short reg,\n\t\t\t   unsigned char value)\n{\n\tunsigned long port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port_lock, flags);\n\treg = reg + socket->number * 0x40;\n\tport = socket->io_base;\n\toutb(reg, port);\n\toutb(value, port + 1);\n\tspin_unlock_irqrestore(&port_lock, flags);\n}\n\nstatic void indirect_setbit(struct pd6729_socket *socket, unsigned short reg,\n\t\t\t    unsigned char mask)\n{\n\tunsigned long port;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port_lock, flags);\n\treg = reg + socket->number * 0x40;\n\tport = socket->io_base;\n\toutb(reg, port);\n\tval = inb(port + 1);\n\tval |= mask;\n\toutb(reg, port);\n\toutb(val, port + 1);\n\tspin_unlock_irqrestore(&port_lock, flags);\n}\n\nstatic void indirect_resetbit(struct pd6729_socket *socket, unsigned short reg,\n\t\t\t      unsigned char mask)\n{\n\tunsigned long port;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port_lock, flags);\n\treg = reg + socket->number * 0x40;\n\tport = socket->io_base;\n\toutb(reg, port);\n\tval = inb(port + 1);\n\tval &= ~mask;\n\toutb(reg, port);\n\toutb(val, port + 1);\n\tspin_unlock_irqrestore(&port_lock, flags);\n}\n\nstatic void indirect_write16(struct pd6729_socket *socket, unsigned short reg,\n\t\t\t     unsigned short value)\n{\n\tunsigned long port;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port_lock, flags);\n\treg = reg + socket->number * 0x40;\n\tport = socket->io_base;\n\n\toutb(reg, port);\n\tval = value & 255;\n\toutb(val, port + 1);\n\n\treg++;\n\n\toutb(reg, port);\n\tval = value >> 8;\n\toutb(val, port + 1);\n\tspin_unlock_irqrestore(&port_lock, flags);\n}\n\n \n\nstatic irqreturn_t pd6729_interrupt(int irq, void *dev)\n{\n\tstruct pd6729_socket *socket = (struct pd6729_socket *)dev;\n\tint i;\n\tint loopcount = 0;\n\tint handled = 0;\n\tunsigned int events, active = 0;\n\n\twhile (1) {\n\t\tloopcount++;\n\t\tif (loopcount > 20) {\n\t\t\tprintk(KERN_ERR \"pd6729: infinite eventloop \"\n\t\t\t       \"in interrupt\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tactive = 0;\n\n\t\tfor (i = 0; i < MAX_SOCKETS; i++) {\n\t\t\tunsigned int csc;\n\n\t\t\t \n\t\t\tcsc = indirect_read(&socket[i], I365_CSC);\n\t\t\tif (csc == 0)   \n\t\t\t\tcontinue;\n\n\t\t\thandled = 1;\n\t\t\tevents = 0;\n\n\t\t\tif (csc & I365_CSC_DETECT) {\n\t\t\t\tevents |= SS_DETECT;\n\t\t\t\tdev_vdbg(&socket[i].socket.dev,\n\t\t\t\t\t\"Card detected in socket %i!\\n\", i);\n\t\t\t}\n\n\t\t\tif (indirect_read(&socket[i], I365_INTCTL)\n\t\t\t\t\t\t& I365_PC_IOCARD) {\n\t\t\t\t \n\t\t\t\tevents |= (csc & I365_CSC_STSCHG)\n\t\t\t\t\t\t? SS_STSCHG : 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tevents |= (csc & I365_CSC_BVD1)\n\t\t\t\t\t\t? SS_BATDEAD : 0;\n\t\t\t\tevents |= (csc & I365_CSC_BVD2)\n\t\t\t\t\t\t? SS_BATWARN : 0;\n\t\t\t\tevents |= (csc & I365_CSC_READY)\n\t\t\t\t\t\t? SS_READY : 0;\n\t\t\t}\n\n\t\t\tif (events)\n\t\t\t\tpcmcia_parse_events(&socket[i].socket, events);\n\n\t\t\tactive |= events;\n\t\t}\n\n\t\tif (active == 0)  \n\t\t\tbreak;\n\t}\n\treturn IRQ_RETVAL(handled);\n}\n\n \n\nstatic void pd6729_interrupt_wrapper(struct timer_list *t)\n{\n\tstruct pd6729_socket *socket = from_timer(socket, t, poll_timer);\n\n\tpd6729_interrupt(0, (void *)socket);\n\tmod_timer(&socket->poll_timer, jiffies + HZ);\n}\n\nstatic int pd6729_get_status(struct pcmcia_socket *sock, u_int *value)\n{\n\tstruct pd6729_socket *socket\n\t\t\t= container_of(sock, struct pd6729_socket, socket);\n\tunsigned int status;\n\tunsigned int data;\n\tstruct pd6729_socket *t;\n\n\t \n\tstatus = indirect_read(socket, I365_STATUS);\n\t*value = 0;\n\n\tif ((status & I365_CS_DETECT) == I365_CS_DETECT)\n\t\t*value |= SS_DETECT;\n\n\t \n\tif (indirect_read(socket, I365_INTCTL) & I365_PC_IOCARD) {\n\t\t \n\t\tif (!(status & I365_CS_STSCHG))\n\t\t\t*value |= SS_STSCHG;\n\t} else {\n\t\t \n\t\tif (!(status & I365_CS_BVD1))\n\t\t\t*value |= SS_BATDEAD;\n\t\tif (!(status & I365_CS_BVD2))\n\t\t\t*value |= SS_BATWARN;\n\t}\n\n\tif (status & I365_CS_WRPROT)\n\t\t*value |= SS_WRPROT;\t \n\n\tif (status & I365_CS_READY)\n\t\t*value |= SS_READY;\t \n\n\tif (status & I365_CS_POWERON)\n\t\t*value |= SS_POWERON;\t \n\n\tt = (socket->number) ? socket : socket + 1;\n\tindirect_write(t, PD67_EXT_INDEX, PD67_EXTERN_DATA);\n\tdata = indirect_read16(t, PD67_EXT_DATA);\n\t*value |= (data & PD67_EXD_VS1(socket->number)) ? 0 : SS_3VCARD;\n\n\treturn 0;\n}\n\n\nstatic int pd6729_set_socket(struct pcmcia_socket *sock, socket_state_t *state)\n{\n\tstruct pd6729_socket *socket\n\t\t\t= container_of(sock, struct pd6729_socket, socket);\n\tunsigned char reg, data;\n\n\t \n\tindirect_write(socket, I365_GBLCTL, 0x00);\n\tindirect_write(socket, I365_GENCTL, 0x00);\n\n\t \n\tsocket->card_irq = state->io_irq;\n\n\treg = 0;\n\t \n\tif (!(state->flags & SS_RESET))\n\t\treg |= I365_PC_RESET;\n\tif (state->flags & SS_IOCARD)\n\t\treg |= I365_PC_IOCARD;\n\n\t \n\tindirect_write(socket, I365_INTCTL, reg);\n\n\t \n\n\treg = I365_PWR_NORESET;  \n\n\tif (state->flags & SS_PWR_AUTO) {\n\t\tdev_dbg(&sock->dev, \"Auto power\\n\");\n\t\treg |= I365_PWR_AUTO;\t \n\t}\n\tif (state->flags & SS_OUTPUT_ENA) {\n\t\tdev_dbg(&sock->dev, \"Power Enabled\\n\");\n\t\treg |= I365_PWR_OUT;\t \n\t}\n\n\tswitch (state->Vcc) {\n\tcase 0:\n\t\tbreak;\n\tcase 33:\n\t\tdev_dbg(&sock->dev,\n\t\t\t\"setting voltage to Vcc to 3.3V on socket %i\\n\",\n\t\t\tsocket->number);\n\t\treg |= I365_VCC_5V;\n\t\tindirect_setbit(socket, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);\n\t\tbreak;\n\tcase 50:\n\t\tdev_dbg(&sock->dev,\n\t\t\t\"setting voltage to Vcc to 5V on socket %i\\n\",\n\t\t\tsocket->number);\n\t\treg |= I365_VCC_5V;\n\t\tindirect_resetbit(socket, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&sock->dev,\n\t\t\t\"pd6729_set_socket called with invalid VCC power \"\n\t\t\t\"value: %i\\n\", state->Vcc);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (state->Vpp) {\n\tcase 0:\n\t\tdev_dbg(&sock->dev, \"not setting Vpp on socket %i\\n\",\n\t\t\tsocket->number);\n\t\tbreak;\n\tcase 33:\n\tcase 50:\n\t\tdev_dbg(&sock->dev, \"setting Vpp to Vcc for socket %i\\n\",\n\t\t\tsocket->number);\n\t\treg |= I365_VPP1_5V;\n\t\tbreak;\n\tcase 120:\n\t\tdev_dbg(&sock->dev, \"setting Vpp to 12.0\\n\");\n\t\treg |= I365_VPP1_12V;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&sock->dev, \"pd6729: pd6729_set_socket called with \"\n\t\t\t\"invalid VPP power value: %i\\n\", state->Vpp);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (reg != indirect_read(socket, I365_POWER))\n\t\tindirect_write(socket, I365_POWER, reg);\n\n\tif (irq_mode == 1) {\n\t\t \n\t\tdata = PD67_EC1_INV_MGMT_IRQ | PD67_EC1_INV_CARD_IRQ;\n\t} else\n\t\tdata = 0;\n\n\tindirect_write(socket, PD67_EXT_INDEX, PD67_EXT_CTL_1);\n\tindirect_write(socket, PD67_EXT_DATA, data);\n\n\t \n\n\treg = 0x00;\n\tif (state->csc_mask & SS_DETECT)\n\t\treg |= I365_CSC_DETECT;\n\n\tif (state->flags & SS_IOCARD) {\n\t\tif (state->csc_mask & SS_STSCHG)\n\t\t\treg |= I365_CSC_STSCHG;\n\t} else {\n\t\tif (state->csc_mask & SS_BATDEAD)\n\t\t\treg |= I365_CSC_BVD1;\n\t\tif (state->csc_mask & SS_BATWARN)\n\t\t\treg |= I365_CSC_BVD2;\n\t\tif (state->csc_mask & SS_READY)\n\t\t\treg |= I365_CSC_READY;\n\t}\n\tif (irq_mode == 1)\n\t\treg |= 0x30;\t \n\tindirect_write(socket, I365_CSCINT, reg);\n\n\treg = indirect_read(socket, I365_INTCTL);\n\tif (irq_mode == 1)\n\t\treg |= 0x03;\t \n\telse\n\t\treg |= socket->card_irq;\n\tindirect_write(socket, I365_INTCTL, reg);\n\n\t \n\t(void)indirect_read(socket, I365_CSC);\n\n\treturn 0;\n}\n\nstatic int pd6729_set_io_map(struct pcmcia_socket *sock,\n\t\t\t     struct pccard_io_map *io)\n{\n\tstruct pd6729_socket *socket\n\t\t\t= container_of(sock, struct pd6729_socket, socket);\n\tunsigned char map, ioctl;\n\n\tmap = io->map;\n\n\t \n\tif (map > 1) {\n\t\tdev_dbg(&sock->dev, \"pd6729_set_io_map with invalid map\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (indirect_read(socket, I365_ADDRWIN) & I365_ENA_IO(map))\n\t\tindirect_resetbit(socket, I365_ADDRWIN, I365_ENA_IO(map));\n\n\t \n\n\t \n\tindirect_write16(socket, I365_IO(map)+I365_W_START, io->start);\n\tindirect_write16(socket, I365_IO(map)+I365_W_STOP, io->stop);\n\n\tioctl = indirect_read(socket, I365_IOCTL) & ~I365_IOCTL_MASK(map);\n\n\tif (io->flags & MAP_0WS)\n\t\tioctl |= I365_IOCTL_0WS(map);\n\tif (io->flags & MAP_16BIT)\n\t\tioctl |= I365_IOCTL_16BIT(map);\n\tif (io->flags & MAP_AUTOSZ)\n\t\tioctl |= I365_IOCTL_IOCS16(map);\n\n\tindirect_write(socket, I365_IOCTL, ioctl);\n\n\t \n\tif (io->flags & MAP_ACTIVE)\n\t\tindirect_setbit(socket, I365_ADDRWIN, I365_ENA_IO(map));\n\n\treturn 0;\n}\n\nstatic int pd6729_set_mem_map(struct pcmcia_socket *sock,\n\t\t\t      struct pccard_mem_map *mem)\n{\n\tstruct pd6729_socket *socket\n\t\t\t = container_of(sock, struct pd6729_socket, socket);\n\tunsigned short base, i;\n\tunsigned char map;\n\n\tmap = mem->map;\n\tif (map > 4) {\n\t\tdev_warn(&sock->dev, \"invalid map requested\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((mem->res->start > mem->res->end) || (mem->speed > 1000)) {\n\t\tdev_warn(&sock->dev, \"invalid invalid address / speed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (indirect_read(socket, I365_ADDRWIN) & I365_ENA_MEM(map))\n\t\tindirect_resetbit(socket, I365_ADDRWIN, I365_ENA_MEM(map));\n\n\t \n\tbase = I365_MEM(map);\n\ti = (mem->res->start >> 12) & 0x0fff;\n\tif (mem->flags & MAP_16BIT)\n\t\ti |= I365_MEM_16BIT;\n\tif (mem->flags & MAP_0WS)\n\t\ti |= I365_MEM_0WS;\n\tindirect_write16(socket, base + I365_W_START, i);\n\n\t \n\n\ti = (mem->res->end >> 12) & 0x0fff;\n\tswitch (to_cycles(mem->speed)) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\ti |= I365_MEM_WS0;\n\t\tbreak;\n\tcase 2:\n\t\ti |= I365_MEM_WS1;\n\t\tbreak;\n\tdefault:\n\t\ti |= I365_MEM_WS1 | I365_MEM_WS0;\n\t\tbreak;\n\t}\n\n\tindirect_write16(socket, base + I365_W_STOP, i);\n\n\t \n\tindirect_write(socket, PD67_EXT_INDEX, PD67_MEM_PAGE(map));\n\tindirect_write(socket, PD67_EXT_DATA, mem->res->start >> 24);\n\n\t \n\n\ti = ((mem->card_start - mem->res->start) >> 12) & 0x3fff;\n\tif (mem->flags & MAP_WRPROT)\n\t\ti |= I365_MEM_WRPROT;\n\tif (mem->flags & MAP_ATTRIB) {\n\t\t \n\t\ti |= I365_MEM_REG;\n\t} else {\n\t\t \n\t}\n\tindirect_write16(socket, base + I365_W_OFF, i);\n\n\t \n\tif (mem->flags & MAP_ACTIVE)\n\t\tindirect_setbit(socket, I365_ADDRWIN, I365_ENA_MEM(map));\n\n\treturn 0;\n}\n\nstatic int pd6729_init(struct pcmcia_socket *sock)\n{\n\tint i;\n\tstruct resource res = { .end = 0x0fff };\n\tpccard_io_map io = { 0, 0, 0, 0, 1 };\n\tpccard_mem_map mem = { .res = &res, };\n\n\tpd6729_set_socket(sock, &dead_socket);\n\tfor (i = 0; i < 2; i++) {\n\t\tio.map = i;\n\t\tpd6729_set_io_map(sock, &io);\n\t}\n\tfor (i = 0; i < 5; i++) {\n\t\tmem.map = i;\n\t\tpd6729_set_mem_map(sock, &mem);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic struct pccard_operations pd6729_operations = {\n\t.init\t\t\t= pd6729_init,\n\t.get_status\t\t= pd6729_get_status,\n\t.set_socket\t\t= pd6729_set_socket,\n\t.set_io_map\t\t= pd6729_set_io_map,\n\t.set_mem_map\t\t= pd6729_set_mem_map,\n};\n\nstatic irqreturn_t pd6729_test(int irq, void *dev)\n{\n\tpr_devel(\"-> hit on irq %d\\n\", irq);\n\treturn IRQ_HANDLED;\n}\n\nstatic int pd6729_check_irq(int irq)\n{\n\tint ret;\n\n\tret = request_irq(irq, pd6729_test, IRQF_PROBE_SHARED, \"x\",\n\t\t\t  pd6729_test);\n\tif (ret)\n\t\treturn -1;\n\n\tfree_irq(irq, pd6729_test);\n\treturn 0;\n}\n\nstatic u_int pd6729_isa_scan(void)\n{\n\tu_int mask0, mask = 0;\n\tint i;\n\n\tif (irq_mode == 1) {\n\t\tprintk(KERN_INFO \"pd6729: PCI card interrupts, \"\n\t\t       \"PCI status changes\\n\");\n\t\treturn 0;\n\t}\n\n\tmask0 = PD67_MASK;\n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\tif ((mask0 & (1 << i)) && (pd6729_check_irq(i) == 0))\n\t\t\tmask |= (1 << i);\n\n\tprintk(KERN_INFO \"pd6729: ISA irqs = \");\n\tfor (i = 0; i < 16; i++)\n\t\tif (mask & (1<<i))\n\t\t\tprintk(\"%s%d\", ((mask & ((1<<i)-1)) ? \",\" : \"\"), i);\n\n\tif (mask == 0)\n\t\tprintk(\"none!\");\n\telse\n\t\tprintk(\"  polling status changes.\\n\");\n\n\treturn mask;\n}\n\nstatic int pd6729_pci_probe(struct pci_dev *dev,\n\t\t\t\t      const struct pci_device_id *id)\n{\n\tint i, j, ret;\n\tu_int mask;\n\tchar configbyte;\n\tstruct pd6729_socket *socket;\n\n\tsocket = kcalloc(MAX_SOCKETS, sizeof(struct pd6729_socket),\n\t\t\t GFP_KERNEL);\n\tif (!socket) {\n\t\tdev_warn(&dev->dev, \"failed to kzalloc socket.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = pci_enable_device(dev);\n\tif (ret) {\n\t\tdev_warn(&dev->dev, \"failed to enable pci_device.\\n\");\n\t\tgoto err_out_free_mem;\n\t}\n\n\tif (!pci_resource_start(dev, 0)) {\n\t\tdev_warn(&dev->dev, \"refusing to load the driver as the \"\n\t\t\t\"io_base is NULL.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_out_disable;\n\t}\n\n\tdev_info(&dev->dev, \"Cirrus PD6729 PCI to PCMCIA Bridge at 0x%llx \"\n\t\t\"on irq %d\\n\",\n\t\t(unsigned long long)pci_resource_start(dev, 0), dev->irq);\n\t \n\tpci_read_config_byte(dev, PCI_COMMAND, &configbyte);\n\tif (!(configbyte & PCI_COMMAND_MEMORY)) {\n\t\tdev_dbg(&dev->dev, \"pd6729: Enabling PCI_COMMAND_MEMORY.\\n\");\n\t\tconfigbyte |= PCI_COMMAND_MEMORY;\n\t\tpci_write_config_byte(dev, PCI_COMMAND, configbyte);\n\t}\n\n\tret = pci_request_regions(dev, \"pd6729\");\n\tif (ret) {\n\t\tdev_warn(&dev->dev, \"pci request region failed.\\n\");\n\t\tgoto err_out_disable;\n\t}\n\n\tif (dev->irq == NO_IRQ)\n\t\tirq_mode = 0;\t \n\n\tmask = pd6729_isa_scan();\n\tif (irq_mode == 0 && mask == 0) {\n\t\tdev_warn(&dev->dev, \"no ISA interrupt is available.\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_out_free_res;\n\t}\n\n\tfor (i = 0; i < MAX_SOCKETS; i++) {\n\t\tsocket[i].io_base = pci_resource_start(dev, 0);\n\t\tsocket[i].socket.features |= SS_CAP_PAGE_REGS | SS_CAP_PCCARD;\n\t\tsocket[i].socket.map_size = 0x1000;\n\t\tsocket[i].socket.irq_mask = mask;\n\t\tsocket[i].socket.pci_irq  = dev->irq;\n\t\tsocket[i].socket.cb_dev = dev;\n\t\tsocket[i].socket.owner = THIS_MODULE;\n\n\t\tsocket[i].number = i;\n\n\t\tsocket[i].socket.ops = &pd6729_operations;\n\t\tsocket[i].socket.resource_ops = &pccard_nonstatic_ops;\n\t\tsocket[i].socket.dev.parent = &dev->dev;\n\t\tsocket[i].socket.driver_data = &socket[i];\n\t}\n\n\tpci_set_drvdata(dev, socket);\n\tif (irq_mode == 1) {\n\t\t \n\t\tret = request_irq(dev->irq, pd6729_interrupt, IRQF_SHARED,\n\t\t\t\t  \"pd6729\", socket);\n\t\tif (ret) {\n\t\t\tdev_err(&dev->dev, \"Failed to register irq %d\\n\",\n\t\t\t\tdev->irq);\n\t\t\tgoto err_out_free_res;\n\t\t}\n\t} else {\n\t\t \n\t\ttimer_setup(&socket->poll_timer, pd6729_interrupt_wrapper, 0);\n\t\tmod_timer(&socket->poll_timer, jiffies + HZ);\n\t}\n\n\tfor (i = 0; i < MAX_SOCKETS; i++) {\n\t\tret = pcmcia_register_socket(&socket[i].socket);\n\t\tif (ret) {\n\t\t\tdev_warn(&dev->dev, \"pcmcia_register_socket failed.\\n\");\n\t\t\tfor (j = 0; j < i ; j++)\n\t\t\t\tpcmcia_unregister_socket(&socket[j].socket);\n\t\t\tgoto err_out_free_res2;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_out_free_res2:\n\tif (irq_mode == 1)\n\t\tfree_irq(dev->irq, socket);\n\telse\n\t\ttimer_shutdown_sync(&socket->poll_timer);\nerr_out_free_res:\n\tpci_release_regions(dev);\nerr_out_disable:\n\tpci_disable_device(dev);\n\nerr_out_free_mem:\n\tkfree(socket);\n\treturn ret;\n}\n\nstatic void pd6729_pci_remove(struct pci_dev *dev)\n{\n\tint i;\n\tstruct pd6729_socket *socket = pci_get_drvdata(dev);\n\n\tfor (i = 0; i < MAX_SOCKETS; i++) {\n\t\t \n\t\tindirect_write(&socket[i], I365_CSCINT, 0);\n\t\tindirect_write(&socket[i], I365_INTCTL, 0);\n\n\t\tpcmcia_unregister_socket(&socket[i].socket);\n\t}\n\n\tif (irq_mode == 1)\n\t\tfree_irq(dev->irq, socket);\n\telse\n\t\ttimer_shutdown_sync(&socket->poll_timer);\n\tpci_release_regions(dev);\n\tpci_disable_device(dev);\n\n\tkfree(socket);\n}\n\nstatic const struct pci_device_id pd6729_pci_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CIRRUS, PCI_DEVICE_ID_CIRRUS_6729) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, pd6729_pci_ids);\n\nstatic struct pci_driver pd6729_pci_driver = {\n\t.name\t\t= \"pd6729\",\n\t.id_table\t= pd6729_pci_ids,\n\t.probe\t\t= pd6729_pci_probe,\n\t.remove\t\t= pd6729_pci_remove,\n};\n\nmodule_pci_driver(pd6729_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}