{
  "module_name": "ds.c",
  "hash_id": "87f27ce32bdd8ebbedf4dff9a915763c068d1b0b760773858df0f1444fb4d497",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/ds.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/crc32.h>\n#include <linux/firmware.h>\n#include <linux/kref.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n#include <pcmcia/ss.h>\n\n#include \"cs_internal.h\"\n\n \n\n \n\nMODULE_AUTHOR(\"David Hinds <dahinds@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"PCMCIA Driver Services\");\nMODULE_LICENSE(\"GPL\");\n\n\n \n\nstatic void pcmcia_check_driver(struct pcmcia_driver *p_drv)\n{\n\tconst struct pcmcia_device_id *did = p_drv->id_table;\n\tunsigned int i;\n\tu32 hash;\n\n\tif (!p_drv->probe || !p_drv->remove)\n\t\tprintk(KERN_DEBUG \"pcmcia: %s lacks a requisite callback \"\n\t\t       \"function\\n\", p_drv->name);\n\n\twhile (did && did->match_flags) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (!did->prod_id[i])\n\t\t\t\tcontinue;\n\n\t\t\thash = crc32(0, did->prod_id[i], strlen(did->prod_id[i]));\n\t\t\tif (hash == did->prod_id_hash[i])\n\t\t\t\tcontinue;\n\n\t\t\tprintk(KERN_DEBUG \"pcmcia: %s: invalid hash for \"\n\t\t\t       \"product string \\\"%s\\\": is 0x%x, should \"\n\t\t\t       \"be 0x%x\\n\", p_drv->name, did->prod_id[i],\n\t\t\t       did->prod_id_hash[i], hash);\n\t\t\tprintk(KERN_DEBUG \"pcmcia: see \"\n\t\t\t\t\"Documentation/pcmcia/devicetable.rst for \"\n\t\t\t\t\"details\\n\");\n\t\t}\n\t\tdid++;\n\t}\n\n\treturn;\n}\n\n\n \n\n\nstruct pcmcia_dynid {\n\tstruct list_head\t\tnode;\n\tstruct pcmcia_device_id\t\tid;\n};\n\n \nstatic ssize_t\nnew_id_store(struct device_driver *driver, const char *buf, size_t count)\n{\n\tstruct pcmcia_dynid *dynid;\n\tstruct pcmcia_driver *pdrv = to_pcmcia_drv(driver);\n\t__u16 match_flags, manf_id, card_id;\n\t__u8 func_id, function, device_no;\n\t__u32 prod_id_hash[4] = {0, 0, 0, 0};\n\tint fields = 0;\n\tint retval = 0;\n\n\tfields = sscanf(buf, \"%hx %hx %hx %hhx %hhx %hhx %x %x %x %x\",\n\t\t\t&match_flags, &manf_id, &card_id, &func_id, &function, &device_no,\n\t\t\t&prod_id_hash[0], &prod_id_hash[1], &prod_id_hash[2], &prod_id_hash[3]);\n\tif (fields < 6)\n\t\treturn -EINVAL;\n\n\tdynid = kzalloc(sizeof(struct pcmcia_dynid), GFP_KERNEL);\n\tif (!dynid)\n\t\treturn -ENOMEM;\n\n\tdynid->id.match_flags = match_flags;\n\tdynid->id.manf_id = manf_id;\n\tdynid->id.card_id = card_id;\n\tdynid->id.func_id = func_id;\n\tdynid->id.function = function;\n\tdynid->id.device_no = device_no;\n\tmemcpy(dynid->id.prod_id_hash, prod_id_hash, sizeof(__u32) * 4);\n\n\tmutex_lock(&pdrv->dynids.lock);\n\tlist_add_tail(&dynid->node, &pdrv->dynids.list);\n\tmutex_unlock(&pdrv->dynids.lock);\n\n\tretval = driver_attach(&pdrv->drv);\n\n\tif (retval)\n\t\treturn retval;\n\treturn count;\n}\nstatic DRIVER_ATTR_WO(new_id);\n\nstatic void\npcmcia_free_dynids(struct pcmcia_driver *drv)\n{\n\tstruct pcmcia_dynid *dynid, *n;\n\n\tmutex_lock(&drv->dynids.lock);\n\tlist_for_each_entry_safe(dynid, n, &drv->dynids.list, node) {\n\t\tlist_del(&dynid->node);\n\t\tkfree(dynid);\n\t}\n\tmutex_unlock(&drv->dynids.lock);\n}\n\nstatic int\npcmcia_create_newid_file(struct pcmcia_driver *drv)\n{\n\tint error = 0;\n\tif (drv->probe != NULL)\n\t\terror = driver_create_file(&drv->drv, &driver_attr_new_id);\n\treturn error;\n}\n\nstatic void\npcmcia_remove_newid_file(struct pcmcia_driver *drv)\n{\n\tdriver_remove_file(&drv->drv, &driver_attr_new_id);\n}\n\n \nint pcmcia_register_driver(struct pcmcia_driver *driver)\n{\n\tint error;\n\n\tif (!driver)\n\t\treturn -EINVAL;\n\n\tpcmcia_check_driver(driver);\n\n\t \n\tdriver->drv.bus = &pcmcia_bus_type;\n\tdriver->drv.owner = driver->owner;\n\tdriver->drv.name = driver->name;\n\tmutex_init(&driver->dynids.lock);\n\tINIT_LIST_HEAD(&driver->dynids.list);\n\n\tpr_debug(\"registering driver %s\\n\", driver->name);\n\n\terror = driver_register(&driver->drv);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = pcmcia_create_newid_file(driver);\n\tif (error)\n\t\tdriver_unregister(&driver->drv);\n\n\treturn error;\n}\nEXPORT_SYMBOL(pcmcia_register_driver);\n\n \nvoid pcmcia_unregister_driver(struct pcmcia_driver *driver)\n{\n\tpr_debug(\"unregistering driver %s\\n\", driver->name);\n\tpcmcia_remove_newid_file(driver);\n\tdriver_unregister(&driver->drv);\n\tpcmcia_free_dynids(driver);\n}\nEXPORT_SYMBOL(pcmcia_unregister_driver);\n\n\n \n\nstatic struct pcmcia_device *pcmcia_get_dev(struct pcmcia_device *p_dev)\n{\n\tstruct device *tmp_dev;\n\ttmp_dev = get_device(&p_dev->dev);\n\tif (!tmp_dev)\n\t\treturn NULL;\n\treturn to_pcmcia_dev(tmp_dev);\n}\n\nstatic void pcmcia_put_dev(struct pcmcia_device *p_dev)\n{\n\tif (p_dev)\n\t\tput_device(&p_dev->dev);\n}\n\nstatic void pcmcia_release_function(struct kref *ref)\n{\n\tstruct config_t *c = container_of(ref, struct config_t, ref);\n\tpr_debug(\"releasing config_t\\n\");\n\tkfree(c);\n}\n\nstatic void pcmcia_release_dev(struct device *dev)\n{\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\n\tint i;\n\tdev_dbg(dev, \"releasing device\\n\");\n\tpcmcia_put_socket(p_dev->socket);\n\tfor (i = 0; i < 4; i++)\n\t\tkfree(p_dev->prod_id[i]);\n\tkfree(p_dev->devname);\n\tkref_put(&p_dev->function_config->ref, pcmcia_release_function);\n\tkfree(p_dev);\n}\n\n\nstatic int pcmcia_device_probe(struct device *dev)\n{\n\tstruct pcmcia_device *p_dev;\n\tstruct pcmcia_driver *p_drv;\n\tstruct pcmcia_socket *s;\n\tcistpl_config_t cis_config;\n\tint ret = 0;\n\n\tdev = get_device(dev);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tp_dev = to_pcmcia_dev(dev);\n\tp_drv = to_pcmcia_drv(dev->driver);\n\ts = p_dev->socket;\n\n\tdev_dbg(dev, \"trying to bind to %s\\n\", p_drv->name);\n\n\tif ((!p_drv->probe) || (!p_dev->function_config) ||\n\t    (!try_module_get(p_drv->owner))) {\n\t\tret = -EINVAL;\n\t\tgoto put_dev;\n\t}\n\n\t \n\tret = pccard_read_tuple(p_dev->socket, p_dev->func, CISTPL_CONFIG,\n\t\t\t\t&cis_config);\n\tif (!ret) {\n\t\tp_dev->config_base = cis_config.base;\n\t\tp_dev->config_regs = cis_config.rmask[0];\n\t\tdev_dbg(dev, \"base %x, regs %x\", p_dev->config_base,\n\t\t\tp_dev->config_regs);\n\t} else {\n\t\tdev_info(dev,\n\t\t\t \"pcmcia: could not parse base and rmask0 of CIS\\n\");\n\t\tp_dev->config_base = 0;\n\t\tp_dev->config_regs = 0;\n\t}\n\n\tret = p_drv->probe(p_dev);\n\tif (ret) {\n\t\tdev_dbg(dev, \"binding to %s failed with %d\\n\",\n\t\t\t   p_drv->name, ret);\n\t\tgoto put_module;\n\t}\n\tdev_dbg(dev, \"%s bound: Vpp %d.%d, idx %x, IRQ %d\", p_drv->name,\n\t\tp_dev->vpp/10, p_dev->vpp%10, p_dev->config_index, p_dev->irq);\n\tdev_dbg(dev, \"resources: ioport %pR %pR iomem %pR %pR %pR\",\n\t\tp_dev->resource[0], p_dev->resource[1], p_dev->resource[2],\n\t\tp_dev->resource[3], p_dev->resource[4]);\n\n\tmutex_lock(&s->ops_mutex);\n\tif ((s->pcmcia_pfc) &&\n\t    (p_dev->socket->device_count == 1) && (p_dev->device_no == 0))\n\t\tpcmcia_parse_uevents(s, PCMCIA_UEVENT_REQUERY);\n\tmutex_unlock(&s->ops_mutex);\n\nput_module:\n\tif (ret)\n\t\tmodule_put(p_drv->owner);\nput_dev:\n\tif (ret)\n\t\tput_device(dev);\n\treturn ret;\n}\n\n\n \nstatic void pcmcia_card_remove(struct pcmcia_socket *s, struct pcmcia_device *leftover)\n{\n\tstruct pcmcia_device\t*p_dev;\n\tstruct pcmcia_device\t*tmp;\n\n\tdev_dbg(leftover ? &leftover->dev : &s->dev,\n\t\t   \"pcmcia_card_remove(%d) %s\\n\", s->sock,\n\t\t   leftover ? leftover->devname : \"\");\n\n\tmutex_lock(&s->ops_mutex);\n\tif (!leftover)\n\t\ts->device_count = 0;\n\telse\n\t\ts->device_count = 1;\n\tmutex_unlock(&s->ops_mutex);\n\n\t \n\tlist_for_each_entry_safe(p_dev, tmp, &s->devices_list, socket_device_list) {\n\t\tif (p_dev == leftover)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&s->ops_mutex);\n\t\tlist_del(&p_dev->socket_device_list);\n\t\tmutex_unlock(&s->ops_mutex);\n\n\t\tdev_dbg(&p_dev->dev, \"unregistering device\\n\");\n\t\tdevice_unregister(&p_dev->dev);\n\t}\n\n\treturn;\n}\n\nstatic void pcmcia_device_remove(struct device *dev)\n{\n\tstruct pcmcia_device *p_dev;\n\tstruct pcmcia_driver *p_drv;\n\tint i;\n\n\tp_dev = to_pcmcia_dev(dev);\n\tp_drv = to_pcmcia_drv(dev->driver);\n\n\tdev_dbg(dev, \"removing device\\n\");\n\n\t \n\tif ((p_dev->socket->pcmcia_pfc) &&\n\t    (p_dev->socket->device_count > 0) &&\n\t    (p_dev->device_no == 0))\n\t\tpcmcia_card_remove(p_dev->socket, p_dev);\n\n\t \n\tif (p_drv->remove)\n\t\tp_drv->remove(p_dev);\n\n\t \n\tif (p_dev->_irq || p_dev->_io || p_dev->_locked)\n\t\tdev_info(dev,\n\t\t\t \"pcmcia: driver %s did not release config properly\\n\",\n\t\t\t p_drv->name);\n\n\tfor (i = 0; i < MAX_WIN; i++)\n\t\tif (p_dev->_win & CLIENT_WIN_REQ(i))\n\t\t\tdev_info(dev,\n\t\t\t\t \"pcmcia: driver %s did not release window properly\\n\",\n\t\t\t\t p_drv->name);\n\n\t \n\tpcmcia_put_dev(p_dev);\n\tmodule_put(p_drv->owner);\n}\n\n\n \nstatic int pcmcia_device_query(struct pcmcia_device *p_dev)\n{\n\tcistpl_manfid_t manf_id;\n\tcistpl_funcid_t func_id;\n\tcistpl_vers_1_t\t*vers1;\n\tunsigned int i;\n\n\tvers1 = kmalloc(sizeof(*vers1), GFP_KERNEL);\n\tif (!vers1)\n\t\treturn -ENOMEM;\n\n\tif (!pccard_read_tuple(p_dev->socket, BIND_FN_ALL,\n\t\t\t       CISTPL_MANFID, &manf_id)) {\n\t\tmutex_lock(&p_dev->socket->ops_mutex);\n\t\tp_dev->manf_id = manf_id.manf;\n\t\tp_dev->card_id = manf_id.card;\n\t\tp_dev->has_manf_id = 1;\n\t\tp_dev->has_card_id = 1;\n\t\tmutex_unlock(&p_dev->socket->ops_mutex);\n\t}\n\n\tif (!pccard_read_tuple(p_dev->socket, p_dev->func,\n\t\t\t       CISTPL_FUNCID, &func_id)) {\n\t\tmutex_lock(&p_dev->socket->ops_mutex);\n\t\tp_dev->func_id = func_id.func;\n\t\tp_dev->has_func_id = 1;\n\t\tmutex_unlock(&p_dev->socket->ops_mutex);\n\t} else {\n\t\t \n\t\tcistpl_device_geo_t *devgeo;\n\n\t\tdevgeo = kmalloc(sizeof(*devgeo), GFP_KERNEL);\n\t\tif (!devgeo) {\n\t\t\tkfree(vers1);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (!pccard_read_tuple(p_dev->socket, p_dev->func,\n\t\t\t\t      CISTPL_DEVICE_GEO, devgeo)) {\n\t\t\tdev_dbg(&p_dev->dev,\n\t\t\t\t   \"mem device geometry probably means \"\n\t\t\t\t   \"FUNCID_MEMORY\\n\");\n\t\t\tmutex_lock(&p_dev->socket->ops_mutex);\n\t\t\tp_dev->func_id = CISTPL_FUNCID_MEMORY;\n\t\t\tp_dev->has_func_id = 1;\n\t\t\tmutex_unlock(&p_dev->socket->ops_mutex);\n\t\t}\n\t\tkfree(devgeo);\n\t}\n\n\tif (!pccard_read_tuple(p_dev->socket, BIND_FN_ALL, CISTPL_VERS_1,\n\t\t\t       vers1)) {\n\t\tmutex_lock(&p_dev->socket->ops_mutex);\n\t\tfor (i = 0; i < min_t(unsigned int, 4, vers1->ns); i++) {\n\t\t\tchar *tmp;\n\t\t\tunsigned int length;\n\t\t\tchar *new;\n\n\t\t\ttmp = vers1->str + vers1->ofs[i];\n\n\t\t\tlength = strlen(tmp) + 1;\n\t\t\tif ((length < 2) || (length > 255))\n\t\t\t\tcontinue;\n\n\t\t\tnew = kstrdup(tmp, GFP_KERNEL);\n\t\t\tif (!new)\n\t\t\t\tcontinue;\n\n\t\t\ttmp = p_dev->prod_id[i];\n\t\t\tp_dev->prod_id[i] = new;\n\t\t\tkfree(tmp);\n\t\t}\n\t\tmutex_unlock(&p_dev->socket->ops_mutex);\n\t}\n\n\tkfree(vers1);\n\treturn 0;\n}\n\n\nstatic struct pcmcia_device *pcmcia_device_add(struct pcmcia_socket *s,\n\t\t\t\t\t       unsigned int function)\n{\n\tstruct pcmcia_device *p_dev, *tmp_dev;\n\tint i;\n\n\ts = pcmcia_get_socket(s);\n\tif (!s)\n\t\treturn NULL;\n\n\tpr_debug(\"adding device to %d, function %d\\n\", s->sock, function);\n\n\tp_dev = kzalloc(sizeof(struct pcmcia_device), GFP_KERNEL);\n\tif (!p_dev)\n\t\tgoto err_put;\n\n\tmutex_lock(&s->ops_mutex);\n\tp_dev->device_no = (s->device_count++);\n\tmutex_unlock(&s->ops_mutex);\n\n\t \n\tif ((p_dev->device_no >= 2) && (function == 0))\n\t\tgoto err_free;\n\n\t \n\tif (p_dev->device_no >= 4)\n\t\tgoto err_free;\n\n\tp_dev->socket = s;\n\tp_dev->func   = function;\n\n\tp_dev->dev.bus = &pcmcia_bus_type;\n\tp_dev->dev.parent = s->dev.parent;\n\tp_dev->dev.release = pcmcia_release_dev;\n\t \n\tp_dev->dma_mask = 0;\n\tp_dev->dev.dma_mask = &p_dev->dma_mask;\n\tp_dev->devname = kasprintf(GFP_KERNEL, \"pcmcia%s\", dev_name(&p_dev->dev));\n\tif (!p_dev->devname)\n\t\tgoto err_free;\n\tdev_dbg(&p_dev->dev, \"devname is %s\\n\", p_dev->devname);\n\n\tmutex_lock(&s->ops_mutex);\n\n\t \n\tlist_for_each_entry(tmp_dev, &s->devices_list, socket_device_list)\n\t\tif (p_dev->func == tmp_dev->func) {\n\t\t\tp_dev->function_config = tmp_dev->function_config;\n\t\t\tp_dev->irq = tmp_dev->irq;\n\t\t\tkref_get(&p_dev->function_config->ref);\n\t\t}\n\n\t \n\tlist_add(&p_dev->socket_device_list, &s->devices_list);\n\n\tif (pcmcia_setup_irq(p_dev))\n\t\tdev_warn(&p_dev->dev,\n\t\t\t\"IRQ setup failed -- device might not work\\n\");\n\n\tif (!p_dev->function_config) {\n\t\tconfig_t *c;\n\t\tdev_dbg(&p_dev->dev, \"creating config_t\\n\");\n\t\tc = kzalloc(sizeof(struct config_t), GFP_KERNEL);\n\t\tif (!c) {\n\t\t\tmutex_unlock(&s->ops_mutex);\n\t\t\tgoto err_unreg;\n\t\t}\n\t\tp_dev->function_config = c;\n\t\tkref_init(&c->ref);\n\t\tfor (i = 0; i < MAX_IO_WIN; i++) {\n\t\t\tc->io[i].name = p_dev->devname;\n\t\t\tc->io[i].flags = IORESOURCE_IO;\n\t\t}\n\t\tfor (i = 0; i < MAX_WIN; i++) {\n\t\t\tc->mem[i].name = p_dev->devname;\n\t\t\tc->mem[i].flags = IORESOURCE_MEM;\n\t\t}\n\t}\n\tfor (i = 0; i < MAX_IO_WIN; i++)\n\t\tp_dev->resource[i] = &p_dev->function_config->io[i];\n\tfor (; i < (MAX_IO_WIN + MAX_WIN); i++)\n\t\tp_dev->resource[i] = &p_dev->function_config->mem[i-MAX_IO_WIN];\n\n\tmutex_unlock(&s->ops_mutex);\n\n\tdev_notice(&p_dev->dev, \"pcmcia: registering new device %s (IRQ: %d)\\n\",\n\t\t   p_dev->devname, p_dev->irq);\n\n\tpcmcia_device_query(p_dev);\n\n\tdev_set_name(&p_dev->dev, \"%d.%d\", p_dev->socket->sock, p_dev->device_no);\n\tif (device_register(&p_dev->dev)) {\n\t\tmutex_lock(&s->ops_mutex);\n\t\tlist_del(&p_dev->socket_device_list);\n\t\ts->device_count--;\n\t\tmutex_unlock(&s->ops_mutex);\n\t\tput_device(&p_dev->dev);\n\t\treturn NULL;\n\t}\n\n\treturn p_dev;\n\n err_unreg:\n\tmutex_lock(&s->ops_mutex);\n\tlist_del(&p_dev->socket_device_list);\n\tmutex_unlock(&s->ops_mutex);\n\n err_free:\n\tmutex_lock(&s->ops_mutex);\n\ts->device_count--;\n\tmutex_unlock(&s->ops_mutex);\n\n\tfor (i = 0; i < 4; i++)\n\t\tkfree(p_dev->prod_id[i]);\n\tkfree(p_dev->devname);\n\tkfree(p_dev);\n err_put:\n\tpcmcia_put_socket(s);\n\n\treturn NULL;\n}\n\n\nstatic int pcmcia_card_add(struct pcmcia_socket *s)\n{\n\tcistpl_longlink_mfc_t mfc;\n\tunsigned int no_funcs, i, no_chains;\n\tint ret = -EAGAIN;\n\n\tmutex_lock(&s->ops_mutex);\n\tif (!(s->resource_setup_done)) {\n\t\tdev_dbg(&s->dev,\n\t\t\t   \"no resources available, delaying card_add\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EAGAIN;  \n\t}\n\n\tif (pcmcia_validate_mem(s)) {\n\t\tdev_dbg(&s->dev, \"validating mem resources failed, \"\n\t\t       \"delaying card_add\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EAGAIN;  \n\t}\n\tmutex_unlock(&s->ops_mutex);\n\n\tret = pccard_validate_cis(s, &no_chains);\n\tif (ret || !no_chains) {\n#if defined(CONFIG_MTD_PCMCIA_ANONYMOUS)\n\t\t \n\t\tif (ret == -EIO) {\n\t\t\tdev_info(&s->dev, \"no CIS, assuming an anonymous memory card.\\n\");\n\t\t\tpcmcia_replace_cis(s, \"\\xFF\", 1);\n\t\t\tno_chains = 1;\n\t\t\tret = 0;\n\t\t} else\n#endif\n\t\t{\n\t\t\tdev_dbg(&s->dev, \"invalid CIS or invalid resources\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_LONGLINK_MFC, &mfc))\n\t\tno_funcs = mfc.nfn;\n\telse\n\t\tno_funcs = 1;\n\ts->functions = no_funcs;\n\n\tfor (i = 0; i < no_funcs; i++)\n\t\tpcmcia_device_add(s, i);\n\n\treturn ret;\n}\n\n\nstatic int pcmcia_requery_callback(struct device *dev, void *_data)\n{\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\n\tif (!p_dev->dev.driver) {\n\t\tdev_dbg(dev, \"update device information\\n\");\n\t\tpcmcia_device_query(p_dev);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void pcmcia_requery(struct pcmcia_socket *s)\n{\n\tint has_pfc;\n\n\tif (!(s->state & SOCKET_PRESENT))\n\t\treturn;\n\n\tif (s->functions == 0) {\n\t\tpcmcia_card_add(s);\n\t\treturn;\n\t}\n\n\t \n\tbus_for_each_dev(&pcmcia_bus_type, NULL, NULL, pcmcia_requery_callback);\n\n\t \n\tif (s->fake_cis) {\n\t\tint old_funcs, new_funcs;\n\t\tcistpl_longlink_mfc_t mfc;\n\n\t\t \n\t\told_funcs = s->functions;\n\n\t\tif (!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_LONGLINK_MFC,\n\t\t\t\t\t&mfc))\n\t\t\tnew_funcs = mfc.nfn;\n\t\telse\n\t\t\tnew_funcs = 1;\n\t\tif (old_funcs != new_funcs) {\n\t\t\t \n\t\t\tpcmcia_card_remove(s, NULL);\n\t\t\ts->functions = 0;\n\t\t\tpcmcia_card_add(s);\n\t\t}\n\t}\n\n\t \n\tmutex_lock(&s->ops_mutex);\n\thas_pfc = s->pcmcia_pfc;\n\tmutex_unlock(&s->ops_mutex);\n\tif (has_pfc)\n\t\tpcmcia_device_add(s, 0);\n\n\t \n\tif (bus_rescan_devices(&pcmcia_bus_type))\n\t\tdev_warn(&s->dev, \"rescanning the bus failed\\n\");\n}\n\n\n#ifdef CONFIG_PCMCIA_LOAD_CIS\n\n \nstatic int pcmcia_load_firmware(struct pcmcia_device *dev, char *filename)\n{\n\tstruct pcmcia_socket *s = dev->socket;\n\tconst struct firmware *fw;\n\tint ret = -ENOMEM;\n\tcistpl_longlink_mfc_t mfc;\n\tint old_funcs, new_funcs = 1;\n\n\tif (!filename)\n\t\treturn -EINVAL;\n\n\tdev_dbg(&dev->dev, \"trying to load CIS file %s\\n\", filename);\n\n\tif (request_firmware(&fw, filename, &dev->dev) == 0) {\n\t\tif (fw->size >= CISTPL_MAX_CIS_SIZE) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(&dev->dev, \"pcmcia: CIS override is too big\\n\");\n\t\t\tgoto release;\n\t\t}\n\n\t\tif (!pcmcia_replace_cis(s, fw->data, fw->size))\n\t\t\tret = 0;\n\t\telse {\n\t\t\tdev_err(&dev->dev, \"pcmcia: CIS override failed\\n\");\n\t\t\tgoto release;\n\t\t}\n\n\t\t \n\t\told_funcs = s->functions;\n\t\tif (!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_LONGLINK_MFC,\n\t\t\t\t\t&mfc))\n\t\t\tnew_funcs = mfc.nfn;\n\n\t\tif (old_funcs != new_funcs)\n\t\t\tret = -EBUSY;\n\n\t\t \n\t\tpcmcia_device_query(dev);\n\n\t\t \n\t\tpcmcia_parse_uevents(s, PCMCIA_UEVENT_REQUERY);\n\t}\n release:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\n#else  \n\nstatic inline int pcmcia_load_firmware(struct pcmcia_device *dev,\n\t\t\t\t       char *filename)\n{\n\treturn -ENODEV;\n}\n\n#endif\n\n\nstatic inline int pcmcia_devmatch(struct pcmcia_device *dev,\n\t\t\t\t  const struct pcmcia_device_id *did)\n{\n\tif (did->match_flags & PCMCIA_DEV_ID_MATCH_MANF_ID) {\n\t\tif ((!dev->has_manf_id) || (dev->manf_id != did->manf_id))\n\t\t\treturn 0;\n\t}\n\n\tif (did->match_flags & PCMCIA_DEV_ID_MATCH_CARD_ID) {\n\t\tif ((!dev->has_card_id) || (dev->card_id != did->card_id))\n\t\t\treturn 0;\n\t}\n\n\tif (did->match_flags & PCMCIA_DEV_ID_MATCH_FUNCTION) {\n\t\tif (dev->func != did->function)\n\t\t\treturn 0;\n\t}\n\n\tif (did->match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID1) {\n\t\tif (!dev->prod_id[0])\n\t\t\treturn 0;\n\t\tif (strcmp(did->prod_id[0], dev->prod_id[0]))\n\t\t\treturn 0;\n\t}\n\n\tif (did->match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID2) {\n\t\tif (!dev->prod_id[1])\n\t\t\treturn 0;\n\t\tif (strcmp(did->prod_id[1], dev->prod_id[1]))\n\t\t\treturn 0;\n\t}\n\n\tif (did->match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID3) {\n\t\tif (!dev->prod_id[2])\n\t\t\treturn 0;\n\t\tif (strcmp(did->prod_id[2], dev->prod_id[2]))\n\t\t\treturn 0;\n\t}\n\n\tif (did->match_flags & PCMCIA_DEV_ID_MATCH_PROD_ID4) {\n\t\tif (!dev->prod_id[3])\n\t\t\treturn 0;\n\t\tif (strcmp(did->prod_id[3], dev->prod_id[3]))\n\t\t\treturn 0;\n\t}\n\n\tif (did->match_flags & PCMCIA_DEV_ID_MATCH_DEVICE_NO) {\n\t\tdev_dbg(&dev->dev, \"this is a pseudo-multi-function device\\n\");\n\t\tmutex_lock(&dev->socket->ops_mutex);\n\t\tdev->socket->pcmcia_pfc = 1;\n\t\tmutex_unlock(&dev->socket->ops_mutex);\n\t\tif (dev->device_no != did->device_no)\n\t\t\treturn 0;\n\t}\n\n\tif (did->match_flags & PCMCIA_DEV_ID_MATCH_FUNC_ID) {\n\t\tint ret;\n\n\t\tif ((!dev->has_func_id) || (dev->func_id != did->func_id))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (dev->socket->pcmcia_pfc)\n\t\t\treturn 0;\n\t\tif (dev->device_no)\n\t\t\treturn 0;\n\n\t\t \n\t\tmutex_lock(&dev->socket->ops_mutex);\n\t\tret = dev->allow_func_id_match;\n\t\tmutex_unlock(&dev->socket->ops_mutex);\n\n\t\tif (!ret) {\n\t\t\tdev_dbg(&dev->dev,\n\t\t\t\t\"skipping FUNC_ID match until userspace ACK\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (did->match_flags & PCMCIA_DEV_ID_MATCH_FAKE_CIS) {\n\t\tdev_dbg(&dev->dev, \"device needs a fake CIS\\n\");\n\t\tif (!dev->socket->fake_cis)\n\t\t\tif (pcmcia_load_firmware(dev, did->cisfile))\n\t\t\t\treturn 0;\n\t}\n\n\tif (did->match_flags & PCMCIA_DEV_ID_MATCH_ANONYMOUS) {\n\t\tint i;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tif (dev->prod_id[i])\n\t\t\t\treturn 0;\n\t\tif (dev->has_manf_id || dev->has_card_id || dev->has_func_id)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\nstatic int pcmcia_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\n\tstruct pcmcia_driver *p_drv = to_pcmcia_drv(drv);\n\tconst struct pcmcia_device_id *did = p_drv->id_table;\n\tstruct pcmcia_dynid *dynid;\n\n\t \n\tmutex_lock(&p_drv->dynids.lock);\n\tlist_for_each_entry(dynid, &p_drv->dynids.list, node) {\n\t\tdev_dbg(dev, \"trying to match to %s\\n\", drv->name);\n\t\tif (pcmcia_devmatch(p_dev, &dynid->id)) {\n\t\t\tdev_dbg(dev, \"matched to %s\\n\", drv->name);\n\t\t\tmutex_unlock(&p_drv->dynids.lock);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tmutex_unlock(&p_drv->dynids.lock);\n\n\twhile (did && did->match_flags) {\n\t\tdev_dbg(dev, \"trying to match to %s\\n\", drv->name);\n\t\tif (pcmcia_devmatch(p_dev, did)) {\n\t\t\tdev_dbg(dev, \"matched to %s\\n\", drv->name);\n\t\t\treturn 1;\n\t\t}\n\t\tdid++;\n\t}\n\n\treturn 0;\n}\n\nstatic int pcmcia_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct pcmcia_device *p_dev;\n\tint i;\n\tu32 hash[4] = { 0, 0, 0, 0};\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tp_dev = to_pcmcia_dev(dev);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (!p_dev->prod_id[i])\n\t\t\tcontinue;\n\t\thash[i] = crc32(0, p_dev->prod_id[i], strlen(p_dev->prod_id[i]));\n\t}\n\n\tif (add_uevent_var(env, \"SOCKET_NO=%u\", p_dev->socket->sock))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"DEVICE_NO=%02X\", p_dev->device_no))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"MODALIAS=pcmcia:m%04Xc%04Xf%02Xfn%02Xpfn%02X\"\n\t\t\t   \"pa%08Xpb%08Xpc%08Xpd%08X\",\n\t\t\t   p_dev->has_manf_id ? p_dev->manf_id : 0,\n\t\t\t   p_dev->has_card_id ? p_dev->card_id : 0,\n\t\t\t   p_dev->has_func_id ? p_dev->func_id : 0,\n\t\t\t   p_dev->func,\n\t\t\t   p_dev->device_no,\n\t\t\t   hash[0],\n\t\t\t   hash[1],\n\t\t\t   hash[2],\n\t\t\t   hash[3]))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \n\nstatic int pcmcia_dev_suspend(struct device *dev);\nstatic int pcmcia_dev_resume(struct device *dev);\n\nstatic int runtime_suspend(struct device *dev)\n{\n\tint rc;\n\n\tdevice_lock(dev);\n\trc = pcmcia_dev_suspend(dev);\n\tdevice_unlock(dev);\n\treturn rc;\n}\n\nstatic int runtime_resume(struct device *dev)\n{\n\tint rc;\n\n\tdevice_lock(dev);\n\trc = pcmcia_dev_resume(dev);\n\tdevice_unlock(dev);\n\treturn rc;\n}\n\n \n\n#define pcmcia_device_attr(field, test, format)\t\t\t\t\\\nstatic ssize_t field##_show (struct device *dev, struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\t\t\\\n\treturn p_dev->test ? sysfs_emit(buf, format, p_dev->field) : -ENODEV; \\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(field);\n\n#define pcmcia_device_stringattr(name, field)\t\t\t\t\t\\\nstatic ssize_t name##_show (struct device *dev, struct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\t\t\\\n\treturn p_dev->field ? sysfs_emit(buf, \"%s\\n\", p_dev->field) : -ENODEV; \\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name);\n\npcmcia_device_attr(func_id, has_func_id, \"0x%02x\\n\");\npcmcia_device_attr(manf_id, has_manf_id, \"0x%04x\\n\");\npcmcia_device_attr(card_id, has_card_id, \"0x%04x\\n\");\npcmcia_device_stringattr(prod_id1, prod_id[0]);\npcmcia_device_stringattr(prod_id2, prod_id[1]);\npcmcia_device_stringattr(prod_id3, prod_id[2]);\npcmcia_device_stringattr(prod_id4, prod_id[3]);\n\nstatic ssize_t function_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\n\treturn p_dev->socket ? sysfs_emit(buf, \"0x%02x\\n\", p_dev->func) : -ENODEV;\n}\nstatic DEVICE_ATTR_RO(function);\n\nstatic ssize_t resources_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\n\tint i, at = 0;\n\n\tfor (i = 0; i < PCMCIA_NUM_RESOURCES; i++)\n\t\tat += sysfs_emit_at(buf, at, \"%pr\\n\", p_dev->resource[i]);\n\n\treturn at;\n}\nstatic DEVICE_ATTR_RO(resources);\n\nstatic ssize_t pm_state_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\n\n\tif (p_dev->suspended)\n\t\treturn sysfs_emit(buf, \"off\\n\");\n\telse\n\t\treturn sysfs_emit(buf, \"on\\n\");\n}\n\nstatic ssize_t pm_state_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\n\tint ret = 0;\n\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tif ((!p_dev->suspended) && !strncmp(buf, \"off\", 3))\n\t\tret = runtime_suspend(dev);\n\telse if (p_dev->suspended && !strncmp(buf, \"on\", 2))\n\t\tret = runtime_resume(dev);\n\n\treturn ret ? ret : count;\n}\nstatic DEVICE_ATTR_RW(pm_state);\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\n\tint i;\n\tu32 hash[4] = { 0, 0, 0, 0};\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (!p_dev->prod_id[i])\n\t\t\tcontinue;\n\t\thash[i] = crc32(0, p_dev->prod_id[i],\n\t\t\t\tstrlen(p_dev->prod_id[i]));\n\t}\n\treturn sysfs_emit(buf, \"pcmcia:m%04Xc%04Xf%02Xfn%02Xpfn%02Xpa%08Xpb%08Xpc%08Xpd%08X\\n\",\n\t\t\t\tp_dev->has_manf_id ? p_dev->manf_id : 0,\n\t\t\t\tp_dev->has_card_id ? p_dev->card_id : 0,\n\t\t\t\tp_dev->has_func_id ? p_dev->func_id : 0,\n\t\t\t\tp_dev->func, p_dev->device_no,\n\t\t\t\thash[0], hash[1], hash[2], hash[3]);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t allow_func_id_match_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\n\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&p_dev->socket->ops_mutex);\n\tp_dev->allow_func_id_match = 1;\n\tmutex_unlock(&p_dev->socket->ops_mutex);\n\tpcmcia_parse_uevents(p_dev->socket, PCMCIA_UEVENT_REQUERY);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(allow_func_id_match);\n\nstatic struct attribute *pcmcia_dev_attrs[] = {\n\t&dev_attr_resources.attr,\n\t&dev_attr_pm_state.attr,\n\t&dev_attr_function.attr,\n\t&dev_attr_func_id.attr,\n\t&dev_attr_manf_id.attr,\n\t&dev_attr_card_id.attr,\n\t&dev_attr_prod_id1.attr,\n\t&dev_attr_prod_id2.attr,\n\t&dev_attr_prod_id3.attr,\n\t&dev_attr_prod_id4.attr,\n\t&dev_attr_modalias.attr,\n\t&dev_attr_allow_func_id_match.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(pcmcia_dev);\n\n \n\nstatic int pcmcia_dev_suspend(struct device *dev)\n{\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\n\tstruct pcmcia_driver *p_drv = NULL;\n\tint ret = 0;\n\n\tmutex_lock(&p_dev->socket->ops_mutex);\n\tif (p_dev->suspended) {\n\t\tmutex_unlock(&p_dev->socket->ops_mutex);\n\t\treturn 0;\n\t}\n\tp_dev->suspended = 1;\n\tmutex_unlock(&p_dev->socket->ops_mutex);\n\n\tdev_dbg(dev, \"suspending\\n\");\n\n\tif (dev->driver)\n\t\tp_drv = to_pcmcia_drv(dev->driver);\n\n\tif (!p_drv)\n\t\tgoto out;\n\n\tif (p_drv->suspend) {\n\t\tret = p_drv->suspend(p_dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"pcmcia: device %s (driver %s) did not want to go to sleep (%d)\\n\",\n\t\t\t\tp_dev->devname, p_drv->name, ret);\n\t\t\tmutex_lock(&p_dev->socket->ops_mutex);\n\t\t\tp_dev->suspended = 0;\n\t\t\tmutex_unlock(&p_dev->socket->ops_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (p_dev->device_no == p_dev->func) {\n\t\tdev_dbg(dev, \"releasing configuration\\n\");\n\t\tpcmcia_release_configuration(p_dev);\n\t}\n\n out:\n\treturn ret;\n}\n\n\nstatic int pcmcia_dev_resume(struct device *dev)\n{\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\n\tstruct pcmcia_driver *p_drv = NULL;\n\tint ret = 0;\n\n\tmutex_lock(&p_dev->socket->ops_mutex);\n\tif (!p_dev->suspended) {\n\t\tmutex_unlock(&p_dev->socket->ops_mutex);\n\t\treturn 0;\n\t}\n\tp_dev->suspended = 0;\n\tmutex_unlock(&p_dev->socket->ops_mutex);\n\n\tdev_dbg(dev, \"resuming\\n\");\n\n\tif (dev->driver)\n\t\tp_drv = to_pcmcia_drv(dev->driver);\n\n\tif (!p_drv)\n\t\tgoto out;\n\n\tif (p_dev->device_no == p_dev->func) {\n\t\tdev_dbg(dev, \"requesting configuration\\n\");\n\t\tret = pcmcia_enable_device(p_dev);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (p_drv->resume)\n\t\tret = p_drv->resume(p_dev);\n\n out:\n\treturn ret;\n}\n\n\nstatic int pcmcia_bus_suspend_callback(struct device *dev, void *_data)\n{\n\tstruct pcmcia_socket *skt = _data;\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\n\n\tif (p_dev->socket != skt || p_dev->suspended)\n\t\treturn 0;\n\n\treturn runtime_suspend(dev);\n}\n\nstatic int pcmcia_bus_resume_callback(struct device *dev, void *_data)\n{\n\tstruct pcmcia_socket *skt = _data;\n\tstruct pcmcia_device *p_dev = to_pcmcia_dev(dev);\n\n\tif (p_dev->socket != skt || !p_dev->suspended)\n\t\treturn 0;\n\n\truntime_resume(dev);\n\n\treturn 0;\n}\n\nstatic int pcmcia_bus_resume(struct pcmcia_socket *skt)\n{\n\tdev_dbg(&skt->dev, \"resuming socket %d\\n\", skt->sock);\n\tbus_for_each_dev(&pcmcia_bus_type, NULL, skt, pcmcia_bus_resume_callback);\n\treturn 0;\n}\n\nstatic int pcmcia_bus_suspend(struct pcmcia_socket *skt)\n{\n\tdev_dbg(&skt->dev, \"suspending socket %d\\n\", skt->sock);\n\tif (bus_for_each_dev(&pcmcia_bus_type, NULL, skt,\n\t\t\t     pcmcia_bus_suspend_callback)) {\n\t\tpcmcia_bus_resume(skt);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int pcmcia_bus_remove(struct pcmcia_socket *skt)\n{\n\tatomic_set(&skt->present, 0);\n\tpcmcia_card_remove(skt, NULL);\n\n\tmutex_lock(&skt->ops_mutex);\n\tdestroy_cis_cache(skt);\n\tpcmcia_cleanup_irq(skt);\n\tmutex_unlock(&skt->ops_mutex);\n\n\treturn 0;\n}\n\nstatic int pcmcia_bus_add(struct pcmcia_socket *skt)\n{\n\tatomic_set(&skt->present, 1);\n\n\tmutex_lock(&skt->ops_mutex);\n\tskt->pcmcia_pfc = 0;\n\tdestroy_cis_cache(skt);  \n\tmutex_unlock(&skt->ops_mutex);\n\n\tpcmcia_card_add(skt);\n\n\treturn 0;\n}\n\nstatic int pcmcia_bus_early_resume(struct pcmcia_socket *skt)\n{\n\tif (!verify_cis_cache(skt))\n\t\treturn 0;\n\n\tdev_dbg(&skt->dev, \"cis mismatch - different card\\n\");\n\n\t \n\tpcmcia_bus_remove(skt);\n\n\tmutex_lock(&skt->ops_mutex);\n\tdestroy_cis_cache(skt);\n\tkfree(skt->fake_cis);\n\tskt->fake_cis = NULL;\n\tskt->functions = 0;\n\tmutex_unlock(&skt->ops_mutex);\n\n\t \n\tpcmcia_bus_add(skt);\n\treturn 0;\n}\n\n\n \nstruct pcmcia_device *pcmcia_dev_present(struct pcmcia_device *_p_dev)\n{\n\tstruct pcmcia_device *p_dev;\n\tstruct pcmcia_device *ret = NULL;\n\n\tp_dev = pcmcia_get_dev(_p_dev);\n\tif (!p_dev)\n\t\treturn NULL;\n\n\tif (atomic_read(&p_dev->socket->present) != 0)\n\t\tret = p_dev;\n\n\tpcmcia_put_dev(p_dev);\n\treturn ret;\n}\nEXPORT_SYMBOL(pcmcia_dev_present);\n\n\nstatic struct pcmcia_callback pcmcia_bus_callback = {\n\t.owner = THIS_MODULE,\n\t.add = pcmcia_bus_add,\n\t.remove = pcmcia_bus_remove,\n\t.requery = pcmcia_requery,\n\t.validate = pccard_validate_cis,\n\t.suspend = pcmcia_bus_suspend,\n\t.early_resume = pcmcia_bus_early_resume,\n\t.resume = pcmcia_bus_resume,\n};\n\nstatic int pcmcia_bus_add_socket(struct device *dev)\n{\n\tstruct pcmcia_socket *socket = dev_get_drvdata(dev);\n\tint ret;\n\n\tsocket = pcmcia_get_socket(socket);\n\tif (!socket) {\n\t\tdev_err(dev, \"PCMCIA obtaining reference to socket failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = sysfs_create_bin_file(&dev->kobj, &pccard_cis_attr);\n\tif (ret) {\n\t\tdev_err(dev, \"PCMCIA registration failed\\n\");\n\t\tpcmcia_put_socket(socket);\n\t\treturn ret;\n\t}\n\n\tINIT_LIST_HEAD(&socket->devices_list);\n\tsocket->pcmcia_pfc = 0;\n\tsocket->device_count = 0;\n\tatomic_set(&socket->present, 0);\n\n\tret = pccard_register_pcmcia(socket, &pcmcia_bus_callback);\n\tif (ret) {\n\t\tdev_err(dev, \"PCMCIA registration failed\\n\");\n\t\tpcmcia_put_socket(socket);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void pcmcia_bus_remove_socket(struct device *dev)\n{\n\tstruct pcmcia_socket *socket = dev_get_drvdata(dev);\n\n\tif (!socket)\n\t\treturn;\n\n\tpccard_register_pcmcia(socket, NULL);\n\n\t \n\tmutex_lock(&socket->skt_mutex);\n\tpcmcia_card_remove(socket, NULL);\n\trelease_cis_mem(socket);\n\tmutex_unlock(&socket->skt_mutex);\n\n\tsysfs_remove_bin_file(&dev->kobj, &pccard_cis_attr);\n\n\tpcmcia_put_socket(socket);\n\n\treturn;\n}\n\n\n \nstatic struct class_interface pcmcia_bus_interface __refdata = {\n\t.class = &pcmcia_socket_class,\n\t.add_dev = &pcmcia_bus_add_socket,\n\t.remove_dev = &pcmcia_bus_remove_socket,\n};\n\nstatic const struct dev_pm_ops pcmcia_bus_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pcmcia_dev_suspend, pcmcia_dev_resume)\n};\n\nstruct bus_type pcmcia_bus_type = {\n\t.name = \"pcmcia\",\n\t.uevent = pcmcia_bus_uevent,\n\t.match = pcmcia_bus_match,\n\t.dev_groups = pcmcia_dev_groups,\n\t.probe = pcmcia_device_probe,\n\t.remove = pcmcia_device_remove,\n\t.pm = &pcmcia_bus_pm_ops,\n};\n\n\nstatic int __init init_pcmcia_bus(void)\n{\n\tint ret;\n\n\tret = bus_register(&pcmcia_bus_type);\n\tif (ret < 0) {\n\t\tprintk(KERN_WARNING \"pcmcia: bus_register error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = class_interface_register(&pcmcia_bus_interface);\n\tif (ret < 0) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"pcmcia: class_interface_register error: %d\\n\", ret);\n\t\tbus_unregister(&pcmcia_bus_type);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nfs_initcall(init_pcmcia_bus);  \n\n\nstatic void __exit exit_pcmcia_bus(void)\n{\n\tclass_interface_unregister(&pcmcia_bus_interface);\n\n\tbus_unregister(&pcmcia_bus_type);\n}\nmodule_exit(exit_pcmcia_bus);\n\n\nMODULE_ALIAS(\"ds\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}