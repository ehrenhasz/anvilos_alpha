{
  "module_name": "cs.c",
  "hash_id": "a74289f6492225b6e190bc72439f24f8dce0b7bbd9e77c7c301c830f6949af71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/cs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/major.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/timer.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/device.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <asm/irq.h>\n\n#include <pcmcia/ss.h>\n#include <pcmcia/cistpl.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ds.h>\n#include \"cs_internal.h\"\n\n\n \n\nMODULE_AUTHOR(\"David Hinds <dahinds@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"Linux Kernel Card Services\");\nMODULE_LICENSE(\"GPL\");\n\n#define INT_MODULE_PARM(n, v) static int n = v; module_param(n, int, 0444)\n\nINT_MODULE_PARM(setup_delay,\t10);\t\t \nINT_MODULE_PARM(resume_delay,\t20);\t\t \nINT_MODULE_PARM(shutdown_delay,\t3);\t\t \nINT_MODULE_PARM(vcc_settle,\t40);\t\t \nINT_MODULE_PARM(reset_time,\t10);\t\t \nINT_MODULE_PARM(unreset_delay,\t10);\t\t \nINT_MODULE_PARM(unreset_check,\t10);\t\t \nINT_MODULE_PARM(unreset_limit,\t30);\t\t \n\n \nINT_MODULE_PARM(cis_speed,\t300);\t\t \n\n\nsocket_state_t dead_socket = {\n\t.csc_mask\t= SS_DETECT,\n};\nEXPORT_SYMBOL(dead_socket);\n\n\n \nLIST_HEAD(pcmcia_socket_list);\nEXPORT_SYMBOL(pcmcia_socket_list);\n\nDECLARE_RWSEM(pcmcia_socket_list_rwsem);\nEXPORT_SYMBOL(pcmcia_socket_list_rwsem);\n\n\nstruct pcmcia_socket *pcmcia_get_socket(struct pcmcia_socket *skt)\n{\n\tstruct device *dev = get_device(&skt->dev);\n\tif (!dev)\n\t\treturn NULL;\n\treturn dev_get_drvdata(dev);\n}\nEXPORT_SYMBOL(pcmcia_get_socket);\n\n\nvoid pcmcia_put_socket(struct pcmcia_socket *skt)\n{\n\tput_device(&skt->dev);\n}\nEXPORT_SYMBOL(pcmcia_put_socket);\n\n\nstatic void pcmcia_release_socket(struct device *dev)\n{\n\tstruct pcmcia_socket *socket = dev_get_drvdata(dev);\n\n\tcomplete(&socket->socket_released);\n}\n\nstatic int pccardd(void *__skt);\n\n \nint pcmcia_register_socket(struct pcmcia_socket *socket)\n{\n\tstruct task_struct *tsk;\n\tint ret;\n\n\tif (!socket || !socket->ops || !socket->dev.parent || !socket->resource_ops)\n\t\treturn -EINVAL;\n\n\tdev_dbg(&socket->dev, \"pcmcia_register_socket(0x%p)\\n\", socket->ops);\n\n\t \n\tdown_write(&pcmcia_socket_list_rwsem);\n\tif (list_empty(&pcmcia_socket_list))\n\t\tsocket->sock = 0;\n\telse {\n\t\tunsigned int found, i = 1;\n\t\tstruct pcmcia_socket *tmp;\n\t\tdo {\n\t\t\tfound = 1;\n\t\t\tlist_for_each_entry(tmp, &pcmcia_socket_list, socket_list) {\n\t\t\t\tif (tmp->sock == i)\n\t\t\t\t\tfound = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t} while (!found);\n\t\tsocket->sock = i - 1;\n\t}\n\tlist_add_tail(&socket->socket_list, &pcmcia_socket_list);\n\tup_write(&pcmcia_socket_list_rwsem);\n\n#ifndef CONFIG_CARDBUS\n\t \n\tsocket->features &= ~SS_CAP_CARDBUS;\n#endif\n\n\t \n\tdev_set_drvdata(&socket->dev, socket);\n\tsocket->dev.class = &pcmcia_socket_class;\n\tdev_set_name(&socket->dev, \"pcmcia_socket%u\", socket->sock);\n\n\t \n\tsocket->cis_mem.flags = 0;\n\tsocket->cis_mem.speed = cis_speed;\n\n\tINIT_LIST_HEAD(&socket->cis_cache);\n\n\tinit_completion(&socket->socket_released);\n\tinit_completion(&socket->thread_done);\n\tmutex_init(&socket->skt_mutex);\n\tmutex_init(&socket->ops_mutex);\n\tspin_lock_init(&socket->thread_lock);\n\n\tif (socket->resource_ops->init) {\n\t\tmutex_lock(&socket->ops_mutex);\n\t\tret = socket->resource_ops->init(socket);\n\t\tmutex_unlock(&socket->ops_mutex);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ttsk = kthread_run(pccardd, socket, \"pccardd\");\n\tif (IS_ERR(tsk)) {\n\t\tret = PTR_ERR(tsk);\n\t\tgoto err;\n\t}\n\n\twait_for_completion(&socket->thread_done);\n\tif (!socket->thread) {\n\t\tdev_warn(&socket->dev,\n\t\t\t \"PCMCIA: warning: socket thread did not start\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpcmcia_parse_events(socket, SS_DETECT);\n\n\t \n\trequest_module_nowait(\"pcmcia\");\n\n\treturn 0;\n\n err:\n\tdown_write(&pcmcia_socket_list_rwsem);\n\tlist_del(&socket->socket_list);\n\tup_write(&pcmcia_socket_list_rwsem);\n\treturn ret;\n}  \nEXPORT_SYMBOL(pcmcia_register_socket);\n\n\n \nvoid pcmcia_unregister_socket(struct pcmcia_socket *socket)\n{\n\tif (!socket)\n\t\treturn;\n\n\tdev_dbg(&socket->dev, \"pcmcia_unregister_socket(0x%p)\\n\", socket->ops);\n\n\tif (socket->thread)\n\t\tkthread_stop(socket->thread);\n\n\t \n\tdown_write(&pcmcia_socket_list_rwsem);\n\tlist_del(&socket->socket_list);\n\tup_write(&pcmcia_socket_list_rwsem);\n\n\t \n\tif (socket->resource_ops->exit) {\n\t\tmutex_lock(&socket->ops_mutex);\n\t\tsocket->resource_ops->exit(socket);\n\t\tmutex_unlock(&socket->ops_mutex);\n\t}\n\twait_for_completion(&socket->socket_released);\n}  \nEXPORT_SYMBOL(pcmcia_unregister_socket);\n\n\nstruct pcmcia_socket *pcmcia_get_socket_by_nr(unsigned int nr)\n{\n\tstruct pcmcia_socket *s;\n\n\tdown_read(&pcmcia_socket_list_rwsem);\n\tlist_for_each_entry(s, &pcmcia_socket_list, socket_list)\n\t\tif (s->sock == nr) {\n\t\t\tup_read(&pcmcia_socket_list_rwsem);\n\t\t\treturn s;\n\t\t}\n\tup_read(&pcmcia_socket_list_rwsem);\n\n\treturn NULL;\n\n}\nEXPORT_SYMBOL(pcmcia_get_socket_by_nr);\n\nstatic int socket_reset(struct pcmcia_socket *skt)\n{\n\tint status, i;\n\n\tdev_dbg(&skt->dev, \"reset\\n\");\n\n\tskt->socket.flags |= SS_OUTPUT_ENA | SS_RESET;\n\tskt->ops->set_socket(skt, &skt->socket);\n\tudelay((long)reset_time);\n\n\tskt->socket.flags &= ~SS_RESET;\n\tskt->ops->set_socket(skt, &skt->socket);\n\n\tmsleep(unreset_delay * 10);\n\tfor (i = 0; i < unreset_limit; i++) {\n\t\tskt->ops->get_status(skt, &status);\n\n\t\tif (!(status & SS_DETECT))\n\t\t\treturn -ENODEV;\n\n\t\tif (status & SS_READY)\n\t\t\treturn 0;\n\n\t\tmsleep(unreset_check * 10);\n\t}\n\n\tdev_err(&skt->dev, \"time out after reset\\n\");\n\treturn -ETIMEDOUT;\n}\n\n \nstatic void socket_shutdown(struct pcmcia_socket *s)\n{\n\tint status;\n\n\tdev_dbg(&s->dev, \"shutdown\\n\");\n\n\tif (s->callback)\n\t\ts->callback->remove(s);\n\n\tmutex_lock(&s->ops_mutex);\n\ts->state &= SOCKET_INUSE | SOCKET_PRESENT;\n\tmsleep(shutdown_delay * 10);\n\ts->state &= SOCKET_INUSE;\n\n\t \n\ts->socket = dead_socket;\n\ts->ops->init(s);\n\ts->ops->set_socket(s, &s->socket);\n\ts->lock_count = 0;\n\tkfree(s->fake_cis);\n\ts->fake_cis = NULL;\n\ts->functions = 0;\n\n\t \n\tmutex_unlock(&s->ops_mutex);\n\n#ifdef CONFIG_CARDBUS\n\tcb_free(s);\n#endif\n\n\t \n\tmsleep(100);\n\n\ts->ops->get_status(s, &status);\n\tif (status & SS_POWERON) {\n\t\tdev_err(&s->dev,\n\t\t\t\"*** DANGER *** unable to remove socket power\\n\");\n\t}\n\n\ts->state &= ~SOCKET_INUSE;\n}\n\nstatic int socket_setup(struct pcmcia_socket *skt, int initial_delay)\n{\n\tint status, i;\n\n\tdev_dbg(&skt->dev, \"setup\\n\");\n\n\tskt->ops->get_status(skt, &status);\n\tif (!(status & SS_DETECT))\n\t\treturn -ENODEV;\n\n\tmsleep(initial_delay * 10);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tskt->ops->get_status(skt, &status);\n\t\tif (!(status & SS_DETECT))\n\t\t\treturn -ENODEV;\n\n\t\tif (!(status & SS_PENDING))\n\t\t\tbreak;\n\n\t\tmsleep(100);\n\t}\n\n\tif (status & SS_PENDING) {\n\t\tdev_err(&skt->dev, \"voltage interrogation timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (status & SS_CARDBUS) {\n\t\tif (!(skt->features & SS_CAP_CARDBUS)) {\n\t\t\tdev_err(&skt->dev, \"cardbus cards are not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tskt->state |= SOCKET_CARDBUS;\n\t} else\n\t\tskt->state &= ~SOCKET_CARDBUS;\n\n\t \n\tif (status & SS_3VCARD)\n\t\tskt->socket.Vcc = skt->socket.Vpp = 33;\n\telse if (!(status & SS_XVCARD))\n\t\tskt->socket.Vcc = skt->socket.Vpp = 50;\n\telse {\n\t\tdev_err(&skt->dev, \"unsupported voltage key\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (skt->power_hook)\n\t\tskt->power_hook(skt, HOOK_POWER_PRE);\n\n\tskt->socket.flags = 0;\n\tskt->ops->set_socket(skt, &skt->socket);\n\n\t \n\tmsleep(vcc_settle * 10);\n\n\tskt->ops->get_status(skt, &status);\n\tif (!(status & SS_POWERON)) {\n\t\tdev_err(&skt->dev, \"unable to apply power\\n\");\n\t\treturn -EIO;\n\t}\n\n\tstatus = socket_reset(skt);\n\n\tif (skt->power_hook)\n\t\tskt->power_hook(skt, HOOK_POWER_POST);\n\n\treturn status;\n}\n\n \nstatic int socket_insert(struct pcmcia_socket *skt)\n{\n\tint ret;\n\n\tdev_dbg(&skt->dev, \"insert\\n\");\n\n\tmutex_lock(&skt->ops_mutex);\n\tif (skt->state & SOCKET_INUSE) {\n\t\tmutex_unlock(&skt->ops_mutex);\n\t\treturn -EINVAL;\n\t}\n\tskt->state |= SOCKET_INUSE;\n\n\tret = socket_setup(skt, setup_delay);\n\tif (ret == 0) {\n\t\tskt->state |= SOCKET_PRESENT;\n\n\t\tdev_notice(&skt->dev, \"pccard: %s card inserted into slot %d\\n\",\n\t\t\t   (skt->state & SOCKET_CARDBUS) ? \"CardBus\" : \"PCMCIA\",\n\t\t\t   skt->sock);\n\n#ifdef CONFIG_CARDBUS\n\t\tif (skt->state & SOCKET_CARDBUS) {\n\t\t\tcb_alloc(skt);\n\t\t\tskt->state |= SOCKET_CARDBUS_CONFIG;\n\t\t}\n#endif\n\t\tdev_dbg(&skt->dev, \"insert done\\n\");\n\t\tmutex_unlock(&skt->ops_mutex);\n\n\t\tif (!(skt->state & SOCKET_CARDBUS) && (skt->callback))\n\t\t\tskt->callback->add(skt);\n\t} else {\n\t\tmutex_unlock(&skt->ops_mutex);\n\t\tsocket_shutdown(skt);\n\t}\n\n\treturn ret;\n}\n\nstatic int socket_suspend(struct pcmcia_socket *skt)\n{\n\tif ((skt->state & SOCKET_SUSPEND) && !(skt->state & SOCKET_IN_RESUME))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&skt->ops_mutex);\n\t \n\tif (!(skt->state & SOCKET_IN_RESUME))\n\t\tskt->suspended_state = skt->state;\n\n\tskt->socket = dead_socket;\n\tskt->ops->set_socket(skt, &skt->socket);\n\tif (skt->ops->suspend)\n\t\tskt->ops->suspend(skt);\n\tskt->state |= SOCKET_SUSPEND;\n\tskt->state &= ~SOCKET_IN_RESUME;\n\tmutex_unlock(&skt->ops_mutex);\n\treturn 0;\n}\n\nstatic int socket_early_resume(struct pcmcia_socket *skt)\n{\n\tmutex_lock(&skt->ops_mutex);\n\tskt->socket = dead_socket;\n\tskt->ops->init(skt);\n\tskt->ops->set_socket(skt, &skt->socket);\n\tif (skt->state & SOCKET_PRESENT)\n\t\tskt->resume_status = socket_setup(skt, resume_delay);\n\tskt->state |= SOCKET_IN_RESUME;\n\tmutex_unlock(&skt->ops_mutex);\n\treturn 0;\n}\n\nstatic int socket_late_resume(struct pcmcia_socket *skt)\n{\n\tint ret = 0;\n\n\tmutex_lock(&skt->ops_mutex);\n\tskt->state &= ~(SOCKET_SUSPEND | SOCKET_IN_RESUME);\n\tmutex_unlock(&skt->ops_mutex);\n\n\tif (!(skt->state & SOCKET_PRESENT)) {\n\t\tret = socket_insert(skt);\n\t\tif (ret == -ENODEV)\n\t\t\tret = 0;\n\t\treturn ret;\n\t}\n\n\tif (skt->resume_status) {\n\t\tsocket_shutdown(skt);\n\t\treturn 0;\n\t}\n\n\tif (skt->suspended_state != skt->state) {\n\t\tdev_dbg(&skt->dev,\n\t\t\t\"suspend state 0x%x != resume state 0x%x\\n\",\n\t\t\tskt->suspended_state, skt->state);\n\n\t\tsocket_shutdown(skt);\n\t\treturn socket_insert(skt);\n\t}\n\n\tif (!(skt->state & SOCKET_CARDBUS) && (skt->callback))\n\t\tret = skt->callback->early_resume(skt);\n\treturn ret;\n}\n\n \nstatic int socket_complete_resume(struct pcmcia_socket *skt)\n{\n\tint ret = 0;\n#ifdef CONFIG_CARDBUS\n\tif (skt->state & SOCKET_CARDBUS) {\n\t\t \n\t\tcb_free(skt);\n\t\tret = cb_alloc(skt);\n\t\tif (ret)\n\t\t\tcb_free(skt);\n\t}\n#endif\n\treturn ret;\n}\n\n \nstatic int socket_resume(struct pcmcia_socket *skt)\n{\n\tint err;\n\tif (!(skt->state & SOCKET_SUSPEND))\n\t\treturn -EBUSY;\n\n\tsocket_early_resume(skt);\n\terr = socket_late_resume(skt);\n\tif (!err)\n\t\terr = socket_complete_resume(skt);\n\treturn err;\n}\n\nstatic void socket_remove(struct pcmcia_socket *skt)\n{\n\tdev_notice(&skt->dev, \"pccard: card ejected from slot %d\\n\", skt->sock);\n\tsocket_shutdown(skt);\n}\n\n \nstatic void socket_detect_change(struct pcmcia_socket *skt)\n{\n\tif (!(skt->state & SOCKET_SUSPEND)) {\n\t\tint status;\n\n\t\tif (!(skt->state & SOCKET_PRESENT))\n\t\t\tmsleep(20);\n\n\t\tskt->ops->get_status(skt, &status);\n\t\tif ((skt->state & SOCKET_PRESENT) &&\n\t\t     !(status & SS_DETECT))\n\t\t\tsocket_remove(skt);\n\t\tif (!(skt->state & SOCKET_PRESENT) &&\n\t\t    (status & SS_DETECT))\n\t\t\tsocket_insert(skt);\n\t}\n}\n\nstatic int pccardd(void *__skt)\n{\n\tstruct pcmcia_socket *skt = __skt;\n\tint ret;\n\n\tskt->thread = current;\n\tskt->socket = dead_socket;\n\tskt->ops->init(skt);\n\tskt->ops->set_socket(skt, &skt->socket);\n\n\t \n\tret = device_register(&skt->dev);\n\tif (ret) {\n\t\tdev_warn(&skt->dev, \"PCMCIA: unable to register socket\\n\");\n\t\tskt->thread = NULL;\n\t\tcomplete(&skt->thread_done);\n\t\tput_device(&skt->dev);\n\t\treturn 0;\n\t}\n\tret = pccard_sysfs_add_socket(&skt->dev);\n\tif (ret)\n\t\tdev_warn(&skt->dev, \"err %d adding socket attributes\\n\", ret);\n\n\tcomplete(&skt->thread_done);\n\n\t \n\tmsleep(250);\n\n\tset_freezable();\n\tfor (;;) {\n\t\tunsigned long flags;\n\t\tunsigned int events;\n\t\tunsigned int sysfs_events;\n\n\t\tspin_lock_irqsave(&skt->thread_lock, flags);\n\t\tevents = skt->thread_events;\n\t\tskt->thread_events = 0;\n\t\tsysfs_events = skt->sysfs_events;\n\t\tskt->sysfs_events = 0;\n\t\tspin_unlock_irqrestore(&skt->thread_lock, flags);\n\n\t\tmutex_lock(&skt->skt_mutex);\n\t\tif (events & SS_DETECT)\n\t\t\tsocket_detect_change(skt);\n\n\t\tif (sysfs_events) {\n\t\t\tif (sysfs_events & PCMCIA_UEVENT_EJECT)\n\t\t\t\tsocket_remove(skt);\n\t\t\tif (sysfs_events & PCMCIA_UEVENT_INSERT)\n\t\t\t\tsocket_insert(skt);\n\t\t\tif ((sysfs_events & PCMCIA_UEVENT_SUSPEND) &&\n\t\t\t\t!(skt->state & SOCKET_CARDBUS)) {\n\t\t\t\tif (skt->callback)\n\t\t\t\t\tret = skt->callback->suspend(skt);\n\t\t\t\telse\n\t\t\t\t\tret = 0;\n\t\t\t\tif (!ret) {\n\t\t\t\t\tsocket_suspend(skt);\n\t\t\t\t\tmsleep(100);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((sysfs_events & PCMCIA_UEVENT_RESUME) &&\n\t\t\t\t!(skt->state & SOCKET_CARDBUS)) {\n\t\t\t\tret = socket_resume(skt);\n\t\t\t\tif (!ret && skt->callback)\n\t\t\t\t\tskt->callback->resume(skt);\n\t\t\t}\n\t\t\tif ((sysfs_events & PCMCIA_UEVENT_REQUERY) &&\n\t\t\t\t!(skt->state & SOCKET_CARDBUS)) {\n\t\t\t\tif (!ret && skt->callback)\n\t\t\t\t\tskt->callback->requery(skt);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&skt->skt_mutex);\n\n\t\tif (events || sysfs_events)\n\t\t\tcontinue;\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tschedule();\n\n\t\ttry_to_freeze();\n\t}\n\t \n\t__set_current_state(TASK_RUNNING);\n\n\t \n\tif (skt->state & SOCKET_PRESENT) {\n\t\tmutex_lock(&skt->skt_mutex);\n\t\tsocket_remove(skt);\n\t\tmutex_unlock(&skt->skt_mutex);\n\t}\n\n\t \n\tpccard_sysfs_remove_socket(&skt->dev);\n\tdevice_unregister(&skt->dev);\n\n\treturn 0;\n}\n\n \nvoid pcmcia_parse_events(struct pcmcia_socket *s, u_int events)\n{\n\tunsigned long flags;\n\tdev_dbg(&s->dev, \"parse_events: events %08x\\n\", events);\n\tif (s->thread) {\n\t\tspin_lock_irqsave(&s->thread_lock, flags);\n\t\ts->thread_events |= events;\n\t\tspin_unlock_irqrestore(&s->thread_lock, flags);\n\n\t\twake_up_process(s->thread);\n\t}\n}  \nEXPORT_SYMBOL(pcmcia_parse_events);\n\n \nvoid pcmcia_parse_uevents(struct pcmcia_socket *s, u_int events)\n{\n\tunsigned long flags;\n\tdev_dbg(&s->dev, \"parse_uevents: events %08x\\n\", events);\n\tif (s->thread) {\n\t\tspin_lock_irqsave(&s->thread_lock, flags);\n\t\ts->sysfs_events |= events;\n\t\tspin_unlock_irqrestore(&s->thread_lock, flags);\n\n\t\twake_up_process(s->thread);\n\t}\n}\nEXPORT_SYMBOL(pcmcia_parse_uevents);\n\n\n \nint pccard_register_pcmcia(struct pcmcia_socket *s, struct pcmcia_callback *c)\n{\n\tint ret = 0;\n\n\t \n\tmutex_lock(&s->skt_mutex);\n\n\tif (c) {\n\t\t \n\t\tif (s->callback) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\n\t\ts->callback = c;\n\n\t\tif ((s->state & (SOCKET_PRESENT|SOCKET_CARDBUS)) == SOCKET_PRESENT)\n\t\t\ts->callback->add(s);\n\t} else\n\t\ts->callback = NULL;\n err:\n\tmutex_unlock(&s->skt_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(pccard_register_pcmcia);\n\n\n \n\nint pcmcia_reset_card(struct pcmcia_socket *skt)\n{\n\tint ret;\n\n\tdev_dbg(&skt->dev, \"resetting socket\\n\");\n\n\tmutex_lock(&skt->skt_mutex);\n\tdo {\n\t\tif (!(skt->state & SOCKET_PRESENT)) {\n\t\t\tdev_dbg(&skt->dev, \"can't reset, not present\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tif (skt->state & SOCKET_SUSPEND) {\n\t\t\tdev_dbg(&skt->dev, \"can't reset, suspended\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t\tif (skt->state & SOCKET_CARDBUS) {\n\t\t\tdev_dbg(&skt->dev, \"can't reset, is cardbus\\n\");\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (skt->callback)\n\t\t\tskt->callback->suspend(skt);\n\t\tmutex_lock(&skt->ops_mutex);\n\t\tret = socket_reset(skt);\n\t\tmutex_unlock(&skt->ops_mutex);\n\t\tif ((ret == 0) && (skt->callback))\n\t\t\tskt->callback->resume(skt);\n\n\t\tret = 0;\n\t} while (0);\n\tmutex_unlock(&skt->skt_mutex);\n\n\treturn ret;\n}  \nEXPORT_SYMBOL(pcmcia_reset_card);\n\n\nstatic int pcmcia_socket_uevent(const struct device *dev,\n\t\t\t\tstruct kobj_uevent_env *env)\n{\n\tconst struct pcmcia_socket *s = container_of(dev, struct pcmcia_socket, dev);\n\n\tif (add_uevent_var(env, \"SOCKET_NO=%u\", s->sock))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n\nstatic struct completion pcmcia_unload;\n\nstatic void pcmcia_release_socket_class(const struct class *data)\n{\n\tcomplete(&pcmcia_unload);\n}\n\n\n#ifdef CONFIG_PM\n\nstatic int __pcmcia_pm_op(struct device *dev,\n\t\t\t  int (*callback) (struct pcmcia_socket *skt))\n{\n\tstruct pcmcia_socket *s = container_of(dev, struct pcmcia_socket, dev);\n\tint ret;\n\n\tmutex_lock(&s->skt_mutex);\n\tret = callback(s);\n\tmutex_unlock(&s->skt_mutex);\n\n\treturn ret;\n}\n\nstatic int pcmcia_socket_dev_suspend_noirq(struct device *dev)\n{\n\treturn __pcmcia_pm_op(dev, socket_suspend);\n}\n\nstatic int pcmcia_socket_dev_resume_noirq(struct device *dev)\n{\n\treturn __pcmcia_pm_op(dev, socket_early_resume);\n}\n\nstatic int __used pcmcia_socket_dev_resume(struct device *dev)\n{\n\treturn __pcmcia_pm_op(dev, socket_late_resume);\n}\n\nstatic void __used pcmcia_socket_dev_complete(struct device *dev)\n{\n\tWARN(__pcmcia_pm_op(dev, socket_complete_resume),\n\t\t\"failed to complete resume\");\n}\n\nstatic const struct dev_pm_ops pcmcia_socket_pm_ops = {\n\t \n\tSET_SYSTEM_SLEEP_PM_OPS(NULL,\n\t\t\t\tpcmcia_socket_dev_resume)\n\n\t \n\t.suspend_noirq = pcmcia_socket_dev_suspend_noirq,\n\t.freeze_noirq = pcmcia_socket_dev_suspend_noirq,\n\t.poweroff_noirq = pcmcia_socket_dev_suspend_noirq,\n\n\t \n\t.resume_noirq = pcmcia_socket_dev_resume_noirq,\n\t.thaw_noirq = pcmcia_socket_dev_resume_noirq,\n\t.restore_noirq = pcmcia_socket_dev_resume_noirq,\n\t.complete = pcmcia_socket_dev_complete,\n};\n\n#define PCMCIA_SOCKET_CLASS_PM_OPS (&pcmcia_socket_pm_ops)\n\n#else  \n\n#define PCMCIA_SOCKET_CLASS_PM_OPS NULL\n\n#endif  \n\nstruct class pcmcia_socket_class = {\n\t.name = \"pcmcia_socket\",\n\t.dev_uevent = pcmcia_socket_uevent,\n\t.dev_release = pcmcia_release_socket,\n\t.class_release = pcmcia_release_socket_class,\n\t.pm = PCMCIA_SOCKET_CLASS_PM_OPS,\n};\nEXPORT_SYMBOL(pcmcia_socket_class);\n\n\nstatic int __init init_pcmcia_cs(void)\n{\n\tinit_completion(&pcmcia_unload);\n\treturn class_register(&pcmcia_socket_class);\n}\n\nstatic void __exit exit_pcmcia_cs(void)\n{\n\tclass_unregister(&pcmcia_socket_class);\n\twait_for_completion(&pcmcia_unload);\n}\n\nsubsys_initcall(init_pcmcia_cs);\nmodule_exit(exit_pcmcia_cs);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}