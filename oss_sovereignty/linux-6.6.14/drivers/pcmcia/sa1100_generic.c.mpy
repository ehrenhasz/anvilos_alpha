{
  "module_name": "sa1100_generic.c",
  "hash_id": "604d0a8186428ba11a1d7ace0ca6b897438cb3b67c16e21802b019930335a876",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/sa1100_generic.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n\n#include <pcmcia/ss.h>\n\n#include <asm/hardware/scoop.h>\n\n#include \"sa1100_generic.h\"\n\nstatic const char *sa11x0_cf_gpio_names[] = {\n\t[SOC_STAT_CD] = \"detect\",\n\t[SOC_STAT_BVD1] = \"bvd1\",\n\t[SOC_STAT_BVD2] = \"bvd2\",\n\t[SOC_STAT_RDY] = \"ready\",\n};\n\nstatic int sa11x0_cf_hw_init(struct soc_pcmcia_socket *skt)\n{\n\tstruct device *dev = skt->socket.dev.parent;\n\tint i;\n\n\tskt->gpio_reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(skt->gpio_reset))\n\t\treturn PTR_ERR(skt->gpio_reset);\n\n\tskt->gpio_bus_enable = devm_gpiod_get_optional(dev, \"bus-enable\",\n\t\t\t\t\t\t       GPIOD_OUT_HIGH);\n\tif (IS_ERR(skt->gpio_bus_enable))\n\t\treturn PTR_ERR(skt->gpio_bus_enable);\n\n\tskt->vcc.reg = devm_regulator_get_optional(dev, \"vcc\");\n\tif (IS_ERR(skt->vcc.reg))\n\t\treturn PTR_ERR(skt->vcc.reg);\n\n\tif (!skt->vcc.reg)\n\t\tdev_warn(dev,\n\t\t\t \"no Vcc regulator provided, ignoring Vcc controls\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(sa11x0_cf_gpio_names); i++) {\n\t\tskt->stat[i].name = sa11x0_cf_gpio_names[i];\n\t\tskt->stat[i].desc = devm_gpiod_get_optional(dev,\n\t\t\t\t\tsa11x0_cf_gpio_names[i], GPIOD_IN);\n\t\tif (IS_ERR(skt->stat[i].desc))\n\t\t\treturn PTR_ERR(skt->stat[i].desc);\n\t}\n\treturn 0;\n}\n\nstatic int sa11x0_cf_configure_socket(struct soc_pcmcia_socket *skt,\n\tconst socket_state_t *state)\n{\n\treturn soc_pcmcia_regulator_set(skt, &skt->vcc, state->Vcc);\n}\n\nstatic struct pcmcia_low_level sa11x0_cf_ops = {\n\t.owner = THIS_MODULE,\n\t.hw_init = sa11x0_cf_hw_init,\n\t.socket_state = soc_common_cf_socket_state,\n\t.configure_socket = sa11x0_cf_configure_socket,\n};\n\nint __init pcmcia_collie_init(struct device *dev);\n\nstatic int (*sa11x0_pcmcia_legacy_hw_init[])(struct device *dev) = {\n#ifdef CONFIG_SA1100_H3600\n\tpcmcia_h3600_init,\n#endif\n#ifdef CONFIG_SA1100_COLLIE\n       pcmcia_collie_init,\n#endif\n};\n\nstatic int sa11x0_drv_pcmcia_legacy_probe(struct platform_device *dev)\n{\n\tint i, ret = -ENODEV;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(sa11x0_pcmcia_legacy_hw_init); i++) {\n\t\tret = sa11x0_pcmcia_legacy_hw_init[i](&dev->dev);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void sa11x0_drv_pcmcia_legacy_remove(struct platform_device *dev)\n{\n\tstruct skt_dev_info *sinfo = platform_get_drvdata(dev);\n\tint i;\n\n\tplatform_set_drvdata(dev, NULL);\n\n\tfor (i = 0; i < sinfo->nskt; i++)\n\t\tsoc_pcmcia_remove_one(&sinfo->skt[i]);\n}\n\nstatic int sa11x0_drv_pcmcia_probe(struct platform_device *pdev)\n{\n\tstruct soc_pcmcia_socket *skt;\n\tstruct device *dev = &pdev->dev;\n\n\tif (pdev->id == -1)\n\t\treturn sa11x0_drv_pcmcia_legacy_probe(pdev);\n\n\tskt = devm_kzalloc(dev, sizeof(*skt), GFP_KERNEL);\n\tif (!skt)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, skt);\n\n\tskt->nr = pdev->id;\n\tskt->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(skt->clk))\n\t\treturn PTR_ERR(skt->clk);\n\n\tsa11xx_drv_pcmcia_ops(&sa11x0_cf_ops);\n\tsoc_pcmcia_init_one(skt, &sa11x0_cf_ops, dev);\n\n\treturn sa11xx_drv_pcmcia_add_one(skt);\n}\n\nstatic int sa11x0_drv_pcmcia_remove(struct platform_device *dev)\n{\n\tstruct soc_pcmcia_socket *skt;\n\n\tif (dev->id == -1) {\n\t\tsa11x0_drv_pcmcia_legacy_remove(dev);\n\t\treturn 0;\n\t}\n\n\tskt = platform_get_drvdata(dev);\n\n\tsoc_pcmcia_remove_one(skt);\n\n\treturn 0;\n}\n\nstatic struct platform_driver sa11x0_pcmcia_driver = {\n\t.driver = {\n\t\t.name\t\t= \"sa11x0-pcmcia\",\n\t},\n\t.probe\t\t= sa11x0_drv_pcmcia_probe,\n\t.remove\t\t= sa11x0_drv_pcmcia_remove,\n};\n\n \nstatic int __init sa11x0_pcmcia_init(void)\n{\n\treturn platform_driver_register(&sa11x0_pcmcia_driver);\n}\n\n \nstatic void __exit sa11x0_pcmcia_exit(void)\n{\n\tplatform_driver_unregister(&sa11x0_pcmcia_driver);\n}\n\nMODULE_AUTHOR(\"John Dorsey <john+@cs.cmu.edu>\");\nMODULE_DESCRIPTION(\"Linux PCMCIA Card Services: SA-11x0 Socket Controller\");\nMODULE_LICENSE(\"Dual MPL/GPL\");\n\nfs_initcall(sa11x0_pcmcia_init);\nmodule_exit(sa11x0_pcmcia_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}