{
  "module_name": "max1600.c",
  "hash_id": "6785d25bcc8a82518d265a2e228cab1a26f53bd9e3aecb7692bdb42aef5afbee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/max1600.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n#include \"max1600.h\"\n\nstatic const char *max1600_gpio_name[2][MAX1600_GPIO_MAX] = {\n\t{ \"a0vcc\", \"a1vcc\", \"a0vpp\", \"a1vpp\" },\n\t{ \"b0vcc\", \"b1vcc\", \"b0vpp\", \"b1vpp\" },\n};\n\nint max1600_init(struct device *dev, struct max1600 **ptr,\n\tunsigned int channel, unsigned int code)\n{\n\tstruct max1600 *m;\n\tint chan;\n\tint i;\n\n\tswitch (channel) {\n\tcase MAX1600_CHAN_A:\n\t\tchan = 0;\n\t\tbreak;\n\tcase MAX1600_CHAN_B:\n\t\tchan = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (code != MAX1600_CODE_LOW && code != MAX1600_CODE_HIGH)\n\t\treturn -EINVAL;\n\n\tm = devm_kzalloc(dev, sizeof(*m), GFP_KERNEL);\n\tif (!m)\n\t\treturn -ENOMEM;\n\n\tm->dev = dev;\n\tm->code = code;\n\n\tfor (i = 0; i < MAX1600_GPIO_MAX; i++) {\n\t\tconst char *name;\n\n\t\tname = max1600_gpio_name[chan][i];\n\t\tif (i != MAX1600_GPIO_0VPP) {\n\t\t\tm->gpio[i] = devm_gpiod_get(dev, name, GPIOD_OUT_LOW);\n\t\t} else {\n\t\t\tm->gpio[i] = devm_gpiod_get_optional(dev, name,\n\t\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\t\t\tif (!m->gpio[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (IS_ERR(m->gpio[i]))\n\t\t\treturn PTR_ERR(m->gpio[i]);\n\t}\n\n\t*ptr = m;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(max1600_init);\n\nint max1600_configure(struct max1600 *m, unsigned int vcc, unsigned int vpp)\n{\n\tDECLARE_BITMAP(values, MAX1600_GPIO_MAX) = { 0, };\n\tint n = MAX1600_GPIO_0VPP;\n\n\tif (m->gpio[MAX1600_GPIO_0VPP]) {\n\t\tif (vpp == 0) {\n\t\t\t__assign_bit(MAX1600_GPIO_0VPP, values, 0);\n\t\t\t__assign_bit(MAX1600_GPIO_1VPP, values, 0);\n\t\t} else if (vpp == 120) {\n\t\t\t__assign_bit(MAX1600_GPIO_0VPP, values, 0);\n\t\t\t__assign_bit(MAX1600_GPIO_1VPP, values, 1);\n\t\t} else if (vpp == vcc) {\n\t\t\t__assign_bit(MAX1600_GPIO_0VPP, values, 1);\n\t\t\t__assign_bit(MAX1600_GPIO_1VPP, values, 0);\n\t\t} else {\n\t\t\tdev_err(m->dev, \"unrecognised Vpp %u.%uV\\n\",\n\t\t\t\tvpp / 10, vpp % 10);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tn = MAX1600_GPIO_MAX;\n\t} else if (vpp != vcc && vpp != 0) {\n\t\tdev_err(m->dev, \"no VPP control\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vcc == 0) {\n\t\t__assign_bit(MAX1600_GPIO_0VCC, values, 0);\n\t\t__assign_bit(MAX1600_GPIO_1VCC, values, 0);\n\t} else if (vcc == 33) {  \n\t\t__assign_bit(MAX1600_GPIO_0VCC, values, 1);\n\t\t__assign_bit(MAX1600_GPIO_1VCC, values, 0);\n\t} else if (vcc == 50) {  \n\t\t__assign_bit(MAX1600_GPIO_0VCC, values, 0);\n\t\t__assign_bit(MAX1600_GPIO_1VCC, values, 1);\n\t} else {\n\t\tdev_err(m->dev, \"unrecognised Vcc %u.%uV\\n\",\n\t\t\tvcc / 10, vcc % 10);\n\t\treturn -EINVAL;\n\t}\n\n\tif (m->code == MAX1600_CODE_HIGH) {\n\t\t \n\t\t__change_bit(MAX1600_GPIO_0VCC, values);\n\t\t__change_bit(MAX1600_GPIO_1VCC, values);\n\t}\n\n\treturn gpiod_set_array_value_cansleep(n, m->gpio, NULL, values);\n}\nEXPORT_SYMBOL_GPL(max1600_configure);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}