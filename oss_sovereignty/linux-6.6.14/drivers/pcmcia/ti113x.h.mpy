{
  "module_name": "ti113x.h",
  "hash_id": "19b64cccb11b69509e845304f2992f080da71a3a954084462d854caceac5a9f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/ti113x.h",
  "human_readable_source": " \n\n#ifndef _LINUX_TI113X_H\n#define _LINUX_TI113X_H\n\n\n \n\n \n#define TI113X_SYSTEM_CONTROL\t\t0x0080\t \n#define  TI113X_SCR_SMIROUTE\t\t0x04000000\n#define  TI113X_SCR_SMISTATUS\t\t0x02000000\n#define  TI113X_SCR_SMIENB\t\t0x01000000\n#define  TI113X_SCR_VCCPROT\t\t0x00200000\n#define  TI113X_SCR_REDUCEZV\t\t0x00100000\n#define  TI113X_SCR_CDREQEN\t\t0x00080000\n#define  TI113X_SCR_CDMACHAN\t\t0x00070000\n#define  TI113X_SCR_SOCACTIVE\t\t0x00002000\n#define  TI113X_SCR_PWRSTREAM\t\t0x00000800\n#define  TI113X_SCR_DELAYUP\t\t0x00000400\n#define  TI113X_SCR_DELAYDOWN\t\t0x00000200\n#define  TI113X_SCR_INTERROGATE\t\t0x00000100\n#define  TI113X_SCR_CLKRUN_SEL\t\t0x00000080\n#define  TI113X_SCR_PWRSAVINGS\t\t0x00000040\n#define  TI113X_SCR_SUBSYSRW\t\t0x00000020\n#define  TI113X_SCR_CB_DPAR\t\t0x00000010\n#define  TI113X_SCR_CDMA_EN\t\t0x00000008\n#define  TI113X_SCR_ASYNC_IRQ\t\t0x00000004\n#define  TI113X_SCR_KEEPCLK\t\t0x00000002\n#define  TI113X_SCR_CLKRUN_ENA\t\t0x00000001  \n\n#define  TI122X_SCR_SER_STEP\t\t0xc0000000\n#define  TI122X_SCR_INTRTIE\t\t0x20000000\n#define  TIXX21_SCR_TIEALL\t\t0x10000000\n#define  TI122X_SCR_CBRSVD\t\t0x00400000\n#define  TI122X_SCR_MRBURSTDN\t\t0x00008000\n#define  TI122X_SCR_MRBURSTUP\t\t0x00004000\n#define  TI122X_SCR_RIMUX\t\t0x00000001\n\n \n#define TI1250_MULTIMEDIA_CTL\t\t0x0084\t \n#define  TI1250_MMC_ZVOUTEN\t\t0x80\n#define  TI1250_MMC_PORTSEL\t\t0x40\n#define  TI1250_MMC_ZVEN1\t\t0x02\n#define  TI1250_MMC_ZVEN0\t\t0x01\n\n#define TI1250_GENERAL_STATUS\t\t0x0085\t \n#define TI1250_GPIO0_CONTROL\t\t0x0088\t \n#define TI1250_GPIO1_CONTROL\t\t0x0089\t \n#define TI1250_GPIO2_CONTROL\t\t0x008a\t \n#define TI1250_GPIO3_CONTROL\t\t0x008b\t \n#define TI1250_GPIO_MODE_MASK\t\t0xc0\n\n \n#define TI122X_MFUNC\t\t\t0x008c\t \n#define TI122X_MFUNC0_MASK\t\t0x0000000f\n#define TI122X_MFUNC1_MASK\t\t0x000000f0\n#define TI122X_MFUNC2_MASK\t\t0x00000f00\n#define TI122X_MFUNC3_MASK\t\t0x0000f000\n#define TI122X_MFUNC4_MASK\t\t0x000f0000\n#define TI122X_MFUNC5_MASK\t\t0x00f00000\n#define TI122X_MFUNC6_MASK\t\t0x0f000000\n\n#define TI122X_MFUNC0_INTA\t\t0x00000002\n#define TI125X_MFUNC0_INTB\t\t0x00000001\n#define TI122X_MFUNC1_INTB\t\t0x00000020\n#define TI122X_MFUNC3_IRQSER\t\t0x00001000\n\n\n \n#define TI113X_RETRY_STATUS\t\t0x0090\t \n#define  TI113X_RSR_PCIRETRY\t\t0x80\n#define  TI113X_RSR_CBRETRY\t\t0x40\n#define  TI113X_RSR_TEXP_CBB\t\t0x20\n#define  TI113X_RSR_MEXP_CBB\t\t0x10\n#define  TI113X_RSR_TEXP_CBA\t\t0x08\n#define  TI113X_RSR_MEXP_CBA\t\t0x04\n#define  TI113X_RSR_TEXP_PCI\t\t0x02\n#define  TI113X_RSR_MEXP_PCI\t\t0x01\n\n \n#define TI113X_CARD_CONTROL\t\t0x0091\t \n#define  TI113X_CCR_RIENB\t\t0x80\n#define  TI113X_CCR_ZVENABLE\t\t0x40\n#define  TI113X_CCR_PCI_IRQ_ENA\t\t0x20\n#define  TI113X_CCR_PCI_IREQ\t\t0x10\n#define  TI113X_CCR_PCI_CSC\t\t0x08\n#define  TI113X_CCR_SPKROUTEN\t\t0x02\n#define  TI113X_CCR_IFG\t\t\t0x01\n\n#define  TI1220_CCR_PORT_SEL\t\t0x20\n#define  TI122X_CCR_AUD2MUX\t\t0x04\n\n \n#define TI113X_DEVICE_CONTROL\t\t0x0092\t \n#define  TI113X_DCR_5V_FORCE\t\t0x40\n#define  TI113X_DCR_3V_FORCE\t\t0x20\n#define  TI113X_DCR_IMODE_MASK\t\t0x06\n#define  TI113X_DCR_IMODE_ISA\t\t0x02\n#define  TI113X_DCR_IMODE_SERIAL\t0x04\n\n#define  TI12XX_DCR_IMODE_PCI_ONLY\t0x00\n#define  TI12XX_DCR_IMODE_ALL_SERIAL\t0x06\n\n \n#define TI113X_BUFFER_CONTROL\t\t0x0093\t \n#define  TI113X_BCR_CB_READ_DEPTH\t0x08\n#define  TI113X_BCR_CB_WRITE_DEPTH\t0x04\n#define  TI113X_BCR_PCI_READ_DEPTH\t0x02\n#define  TI113X_BCR_PCI_WRITE_DEPTH\t0x01\n\n \n#define TI1250_DIAGNOSTIC\t\t0x0093\t \n#define  TI1250_DIAG_TRUE_VALUE\t\t0x80\n#define  TI1250_DIAG_PCI_IREQ\t\t0x40\n#define  TI1250_DIAG_PCI_CSC\t\t0x20\n#define  TI1250_DIAG_ASYNC_CSC\t\t0x01\n\n \n#define TI113X_DMA_0\t\t\t0x0094\t \n#define TI113X_DMA_1\t\t\t0x0098\t \n\n \n#define TI113X_IO_OFFSET(map)\t\t(0x36+((map)<<1))\n\n \n#define ENE_TEST_C9\t\t\t0xc9\t \n#define ENE_TEST_C9_TLTENABLE\t\t0x02\n#define ENE_TEST_C9_PFENABLE_F0\t\t0x04\n#define ENE_TEST_C9_PFENABLE_F1\t\t0x08\n#define ENE_TEST_C9_PFENABLE\t\t(ENE_TEST_C9_PFENABLE_F0 | ENE_TEST_C9_PFENABLE_F1)\n#define ENE_TEST_C9_WPDISALBLE_F0\t0x40\n#define ENE_TEST_C9_WPDISALBLE_F1\t0x80\n#define ENE_TEST_C9_WPDISALBLE\t\t(ENE_TEST_C9_WPDISALBLE_F0 | ENE_TEST_C9_WPDISALBLE_F1)\n\n \n#define ti_sysctl(socket)\t((socket)->private[0])\n#define ti_cardctl(socket)\t((socket)->private[1])\n#define ti_devctl(socket)\t((socket)->private[2])\n#define ti_diag(socket)\t\t((socket)->private[3])\n#define ti_mfunc(socket)\t((socket)->private[4])\n#define ene_test_c9(socket)\t((socket)->private[5])\n\n \nstatic void ti_save_state(struct yenta_socket *socket)\n{\n\tti_sysctl(socket) = config_readl(socket, TI113X_SYSTEM_CONTROL);\n\tti_mfunc(socket) = config_readl(socket, TI122X_MFUNC);\n\tti_cardctl(socket) = config_readb(socket, TI113X_CARD_CONTROL);\n\tti_devctl(socket) = config_readb(socket, TI113X_DEVICE_CONTROL);\n\tti_diag(socket) = config_readb(socket, TI1250_DIAGNOSTIC);\n\n\tif (socket->dev->vendor == PCI_VENDOR_ID_ENE)\n\t\tene_test_c9(socket) = config_readb(socket, ENE_TEST_C9);\n}\n\nstatic void ti_restore_state(struct yenta_socket *socket)\n{\n\tconfig_writel(socket, TI113X_SYSTEM_CONTROL, ti_sysctl(socket));\n\tconfig_writel(socket, TI122X_MFUNC, ti_mfunc(socket));\n\tconfig_writeb(socket, TI113X_CARD_CONTROL, ti_cardctl(socket));\n\tconfig_writeb(socket, TI113X_DEVICE_CONTROL, ti_devctl(socket));\n\tconfig_writeb(socket, TI1250_DIAGNOSTIC, ti_diag(socket));\n\n\tif (socket->dev->vendor == PCI_VENDOR_ID_ENE)\n\t\tconfig_writeb(socket, ENE_TEST_C9, ene_test_c9(socket));\n}\n\n \n\nstatic void ti_zoom_video(struct pcmcia_socket *sock, int onoff)\n{\n\tu8 reg;\n\tstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\n\n\t \n\treg = config_readb(socket, TI113X_CARD_CONTROL);\n\tif (onoff)\n\t\t \n\t\treg |= TI113X_CCR_ZVENABLE;\n\telse\n\t\treg &= ~TI113X_CCR_ZVENABLE;\n\tconfig_writeb(socket, TI113X_CARD_CONTROL, reg);\n}\n\n \n \nstatic void ti1250_zoom_video(struct pcmcia_socket *sock, int onoff)\n{\t\n\tstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\n\tint shift = 0;\n\tu8 reg;\n\n\tti_zoom_video(sock, onoff);\n\n\treg = config_readb(socket, TI1250_MULTIMEDIA_CTL);\n\treg |= TI1250_MMC_ZVOUTEN;\t \n\n\tif(PCI_FUNC(socket->dev->devfn)==1)\n\t\tshift = 1;\n\t\n\tif(onoff)\n\t{\n\t\treg &= ~(1<<6); \t \n\t\treg |= shift<<6;\t \n\t\treg |= 1<<shift;\t \n\t}\n\telse\n\t{\n\t\treg &= ~(1<<6); \t \n\t\treg |= (1^shift)<<6;\t \n\t\treg &= ~(1<<shift);\t \n\t}\n\n\tconfig_writeb(socket, TI1250_MULTIMEDIA_CTL, reg);\n}\n\nstatic void ti_set_zv(struct yenta_socket *socket)\n{\n\tif(socket->dev->vendor == PCI_VENDOR_ID_TI)\n\t{\n\t\tswitch(socket->dev->device)\n\t\t{\n\t\t\t \n\t\t\tcase PCI_DEVICE_ID_TI_1220:\n\t\t\tcase PCI_DEVICE_ID_TI_1221:\n\t\t\tcase PCI_DEVICE_ID_TI_1225:\n\t\t\tcase PCI_DEVICE_ID_TI_4510:\n\t\t\t\tsocket->socket.zoom_video = ti_zoom_video;\n\t\t\t\tbreak;\t\n\t\t\tcase PCI_DEVICE_ID_TI_1250:\n\t\t\tcase PCI_DEVICE_ID_TI_1251A:\n\t\t\tcase PCI_DEVICE_ID_TI_1251B:\n\t\t\tcase PCI_DEVICE_ID_TI_1450:\n\t\t\t\tsocket->socket.zoom_video = ti1250_zoom_video;\n\t\t}\n\t}\n}\n\n\n \nstatic int ti_init(struct yenta_socket *socket)\n{\n\tu8 new, reg = exca_readb(socket, I365_INTCTL);\n\n\tnew = reg & ~I365_INTR_ENA;\n\tif (socket->dev->irq)\n\t\tnew |= I365_INTR_ENA;\n\tif (new != reg)\n\t\texca_writeb(socket, I365_INTCTL, new);\n\treturn 0;\n}\n\nstatic int ti_override(struct yenta_socket *socket)\n{\n\tu8 new, reg = exca_readb(socket, I365_INTCTL);\n\n\tnew = reg & ~I365_INTR_ENA;\n\tif (new != reg)\n\t\texca_writeb(socket, I365_INTCTL, new);\n\n\tti_set_zv(socket);\n\n\treturn 0;\n}\n\nstatic void ti113x_use_isa_irq(struct yenta_socket *socket)\n{\n\tint isa_irq = -1;\n\tu8 intctl;\n\tu32 isa_irq_mask = 0;\n\n\tif (!isa_probe)\n\t\treturn;\n\n\t \n\tisa_irq_mask = yenta_probe_irq(socket, isa_interrupts);\n\tif (!isa_irq_mask)\n\t\treturn;  \n\n\t \n\tfor (; isa_irq_mask; isa_irq++)\n\t\tisa_irq_mask >>= 1;\n\tsocket->cb_irq = isa_irq;\n\n\texca_writeb(socket, I365_CSCINT, (isa_irq << 4));\n\n\tintctl = exca_readb(socket, I365_INTCTL);\n\tintctl &= ~(I365_INTR_ENA | I365_IRQ_MASK);      \n\texca_writeb(socket, I365_INTCTL, intctl);\n\n\tdev_info(&socket->dev->dev,\n\t\t\"Yenta TI113x: using isa irq %d for CardBus\\n\", isa_irq);\n}\n\n\nstatic int ti113x_override(struct yenta_socket *socket)\n{\n\tu8 cardctl;\n\n\tcardctl = config_readb(socket, TI113X_CARD_CONTROL);\n\tcardctl &= ~(TI113X_CCR_PCI_IRQ_ENA | TI113X_CCR_PCI_IREQ | TI113X_CCR_PCI_CSC);\n\tif (socket->dev->irq)\n\t\tcardctl |= TI113X_CCR_PCI_IRQ_ENA | TI113X_CCR_PCI_CSC | TI113X_CCR_PCI_IREQ;\n\telse\n\t\tti113x_use_isa_irq(socket);\n\n\tconfig_writeb(socket, TI113X_CARD_CONTROL, cardctl);\n\n\treturn ti_override(socket);\n}\n\n\n \nstatic void ti12xx_irqroute_func0(struct yenta_socket *socket)\n{\n\tu32 mfunc, mfunc_old, devctl;\n\tu8 gpio3, gpio3_old;\n\tint pci_irq_status;\n\n\tmfunc = mfunc_old = config_readl(socket, TI122X_MFUNC);\n\tdevctl = config_readb(socket, TI113X_DEVICE_CONTROL);\n\tdev_info(&socket->dev->dev, \"TI: mfunc 0x%08x, devctl 0x%02x\\n\",\n\t\t mfunc, devctl);\n\n\t \n\tti_init(socket);\n\n\t \n\tpci_irq_status = yenta_probe_cb_irq(socket);\n\tif (pci_irq_status)\n\t\tgoto out;\n\n\t \n\tdev_info(&socket->dev->dev,\n\t\t \"TI: probing PCI interrupt failed, trying to fix\\n\");\n\n\t \n\tif ((devctl & TI113X_DCR_IMODE_MASK) == TI12XX_DCR_IMODE_ALL_SERIAL) {\n\t\tswitch (socket->dev->device) {\n\t\tcase PCI_DEVICE_ID_TI_1250:\n\t\tcase PCI_DEVICE_ID_TI_1251A:\n\t\tcase PCI_DEVICE_ID_TI_1251B:\n\t\tcase PCI_DEVICE_ID_TI_1450:\n\t\tcase PCI_DEVICE_ID_TI_1451A:\n\t\tcase PCI_DEVICE_ID_TI_4450:\n\t\tcase PCI_DEVICE_ID_TI_4451:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmfunc = (mfunc & ~TI122X_MFUNC3_MASK) | TI122X_MFUNC3_IRQSER;\n\n\t\t\t \n\t\t\tif (mfunc != mfunc_old) {\n\t\t\t\tconfig_writel(socket, TI122X_MFUNC, mfunc);\n\n\t\t\t\tpci_irq_status = yenta_probe_cb_irq(socket);\n\t\t\t\tif (pci_irq_status == 1) {\n\t\t\t\t\tdev_info(&socket->dev->dev,\n\t\t\t\t\t\t \"TI: all-serial interrupts ok\\n\");\n\t\t\t\t\tmfunc_old = mfunc;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tmfunc = mfunc_old;\n\t\t\t\tconfig_writel(socket, TI122X_MFUNC, mfunc);\n\n\t\t\t\tif (pci_irq_status == -1)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdev_info(&socket->dev->dev,\n\t\t\t \"TI: falling back to parallel PCI interrupts\\n\");\n\t\tdevctl &= ~TI113X_DCR_IMODE_MASK;\n\t\tdevctl |= TI113X_DCR_IMODE_SERIAL;  \n\t\tconfig_writeb(socket, TI113X_DEVICE_CONTROL, devctl);\n\t}\n\n\t \n\tswitch (socket->dev->device) {\n\tcase PCI_DEVICE_ID_TI_1250:\n\tcase PCI_DEVICE_ID_TI_1251A:\n\tcase PCI_DEVICE_ID_TI_1251B:\n\tcase PCI_DEVICE_ID_TI_1450:\n\t\t \n\t\tgpio3 = gpio3_old = config_readb(socket, TI1250_GPIO3_CONTROL);\n\t\tgpio3 &= ~TI1250_GPIO_MODE_MASK;\n\t\tif (gpio3 != gpio3_old)\n\t\t\tconfig_writeb(socket, TI1250_GPIO3_CONTROL, gpio3);\n\t\tbreak;\n\n\tdefault:\n\t\tgpio3 = gpio3_old = 0;\n\n\t\tmfunc = (mfunc & ~TI122X_MFUNC0_MASK) | TI122X_MFUNC0_INTA;\n\t\tif (mfunc != mfunc_old)\n\t\t\tconfig_writel(socket, TI122X_MFUNC, mfunc);\n\t}\n\n\t \n\tpci_irq_status = yenta_probe_cb_irq(socket);\n\tif (pci_irq_status == 1) {\n\t\tmfunc_old = mfunc;\n\t\tdev_info(&socket->dev->dev, \"TI: parallel PCI interrupts ok\\n\");\n\t} else {\n\t\t \n\t\tmfunc = mfunc_old;\n\t\tconfig_writel(socket, TI122X_MFUNC, mfunc);\n\t\tif (gpio3 != gpio3_old)\n\t\t\tconfig_writeb(socket, TI1250_GPIO3_CONTROL, gpio3_old);\n\t}\n\nout:\n\tif (pci_irq_status < 1) {\n\t\tsocket->cb_irq = 0;\n\t\tdev_info(&socket->dev->dev,\n\t\t\t \"Yenta TI: no PCI interrupts. Fish. Please report.\\n\");\n\t}\n}\n\n\n \nstatic int ti12xx_align_irqs(struct yenta_socket *socket, int *old_irq)\n{\n\tstruct pci_dev *func0;\n\n\t \n\tfunc0 = pci_get_slot(socket->dev->bus, socket->dev->devfn & ~0x07);\n\tif (!func0)\n\t\treturn 0;\n\n\tif (old_irq)\n\t\t*old_irq = socket->cb_irq;\n\tsocket->cb_irq = socket->dev->irq = func0->irq;\n\n\tpci_dev_put(func0);\n\n\treturn 1;\n}\n\n \nstatic int ti12xx_tie_interrupts(struct yenta_socket *socket, int *old_irq)\n{\n\tu32 sysctl;\n\tint ret;\n\n\tsysctl = config_readl(socket, TI113X_SYSTEM_CONTROL);\n\tif (sysctl & TI122X_SCR_INTRTIE)\n\t\treturn 0;\n\n\t \n\tret = ti12xx_align_irqs(socket, old_irq);\n\tif (!ret)\n\t\treturn 0;\n\n\t \n\tsysctl |= TI122X_SCR_INTRTIE;\n\tconfig_writel(socket, TI113X_SYSTEM_CONTROL, sysctl);\n\n\treturn 1;\n}\n\n \nstatic void ti12xx_untie_interrupts(struct yenta_socket *socket, int old_irq)\n{\n\tu32 sysctl = config_readl(socket, TI113X_SYSTEM_CONTROL);\n\tsysctl &= ~TI122X_SCR_INTRTIE;\n\tconfig_writel(socket, TI113X_SYSTEM_CONTROL, sysctl);\n\n\tsocket->cb_irq = socket->dev->irq = old_irq;\n}\n\n \nstatic void ti12xx_irqroute_func1(struct yenta_socket *socket)\n{\n\tu32 mfunc, mfunc_old, devctl, sysctl;\n\tint pci_irq_status;\n\n\tmfunc = mfunc_old = config_readl(socket, TI122X_MFUNC);\n\tdevctl = config_readb(socket, TI113X_DEVICE_CONTROL);\n\tdev_info(&socket->dev->dev, \"TI: mfunc 0x%08x, devctl 0x%02x\\n\",\n\t\t mfunc, devctl);\n\n\t \n\tsysctl = config_readl(socket, TI113X_SYSTEM_CONTROL);\n\tif (sysctl & TI122X_SCR_INTRTIE)\n\t\tti12xx_align_irqs(socket, NULL);\n\n\t \n\tti_init(socket);\n\n\t \n\tpci_irq_status = yenta_probe_cb_irq(socket);\n\tif (pci_irq_status)\n\t\tgoto out;\n\n\t \n\tdev_info(&socket->dev->dev,\n\t\t \"TI: probing PCI interrupt failed, trying to fix\\n\");\n\n\t \n\tif ((devctl & TI113X_DCR_IMODE_MASK) == TI12XX_DCR_IMODE_ALL_SERIAL) {\n\t\tint old_irq;\n\n\t\tif (ti12xx_tie_interrupts(socket, &old_irq)) {\n\t\t\tpci_irq_status = yenta_probe_cb_irq(socket);\n\t\t\tif (pci_irq_status == 1) {\n\t\t\t\tdev_info(&socket->dev->dev,\n\t\t\t\t\t \"TI: all-serial interrupts, tied ok\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tti12xx_untie_interrupts(socket, old_irq);\n\t\t}\n\t}\n\t \n\telse {\n\t\tint old_irq;\n\n\t\tswitch (socket->dev->device) {\n\t\tcase PCI_DEVICE_ID_TI_1250:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase PCI_DEVICE_ID_TI_1251A:\n\t\tcase PCI_DEVICE_ID_TI_1251B:\n\t\tcase PCI_DEVICE_ID_TI_1450:\n\t\t\t \n\t\t\tmfunc = (mfunc & ~TI122X_MFUNC0_MASK) | TI125X_MFUNC0_INTB;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmfunc = (mfunc & ~TI122X_MFUNC1_MASK) | TI122X_MFUNC1_INTB;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (mfunc != mfunc_old) {\n\t\t\tconfig_writel(socket, TI122X_MFUNC, mfunc);\n\n\t\t\tpci_irq_status = yenta_probe_cb_irq(socket);\n\t\t\tif (pci_irq_status == 1) {\n\t\t\t\tdev_info(&socket->dev->dev,\n\t\t\t\t\t \"TI: parallel PCI interrupts ok\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmfunc = mfunc_old;\n\t\t\tconfig_writel(socket, TI122X_MFUNC, mfunc);\n\n\t\t\tif (pci_irq_status == -1)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (ti12xx_tie_interrupts(socket, &old_irq)) {\n\t\t\tpci_irq_status = yenta_probe_cb_irq(socket);\n\t\t\tif (pci_irq_status == 1) {\n\t\t\t\tdev_info(&socket->dev->dev,\n\t\t\t\t\t \"TI: parallel PCI interrupts, tied ok\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tti12xx_untie_interrupts(socket, old_irq);\n\t\t}\n\t}\n\nout:\n\tif (pci_irq_status < 1) {\n\t\tsocket->cb_irq = 0;\n\t\tdev_info(&socket->dev->dev,\n\t\t\t \"TI: no PCI interrupts. Fish. Please report.\\n\");\n\t}\n}\n\n\n \nstatic int ti12xx_2nd_slot_empty(struct yenta_socket *socket)\n{\n\tstruct pci_dev *func;\n\tstruct yenta_socket *slot2;\n\tint devfn;\n\tunsigned int state;\n\tint ret = 1;\n\tu32 sysctl;\n\n\t \n\tswitch (socket->dev->device) {\n\tcase PCI_DEVICE_ID_TI_1220:\n\tcase PCI_DEVICE_ID_TI_1221:\n\tcase PCI_DEVICE_ID_TI_1225:\n\tcase PCI_DEVICE_ID_TI_1251A:\n\tcase PCI_DEVICE_ID_TI_1251B:\n\tcase PCI_DEVICE_ID_TI_1420:\n\tcase PCI_DEVICE_ID_TI_1450:\n\tcase PCI_DEVICE_ID_TI_1451A:\n\tcase PCI_DEVICE_ID_TI_1520:\n\tcase PCI_DEVICE_ID_TI_1620:\n\tcase PCI_DEVICE_ID_TI_4520:\n\tcase PCI_DEVICE_ID_TI_4450:\n\tcase PCI_DEVICE_ID_TI_4451:\n\t\t \n\t\tbreak;\n\n\tcase PCI_DEVICE_ID_TI_XX12:\n\tcase PCI_DEVICE_ID_TI_X515:\n\tcase PCI_DEVICE_ID_TI_X420:\n\tcase PCI_DEVICE_ID_TI_X620:\n\tcase PCI_DEVICE_ID_TI_XX21_XX11:\n\tcase PCI_DEVICE_ID_TI_7410:\n\tcase PCI_DEVICE_ID_TI_7610:\n\t\t \n\t\tsysctl = config_readl(socket, TI113X_SYSTEM_CONTROL);\n\t\tif (sysctl & TIXX21_SCR_TIEALL)\n\t\t\treturn 0;\n\n\t\tbreak;\n\n\t \n\tdefault:\n\t\treturn 1;\n\t}\n\n\t \n\tdevfn = socket->dev->devfn & ~0x07;\n\tfunc = pci_get_slot(socket->dev->bus,\n\t                    (socket->dev->devfn & 0x07) ? devfn : devfn | 0x01);\n\tif (!func)\n\t\treturn 1;\n\n\t \n\tif (socket->dev->device != func->device)\n\t\tgoto out;\n\n\tslot2 = pci_get_drvdata(func);\n\tif (!slot2)\n\t\tgoto out;\n\n\t \n\tyenta_get_status(&slot2->socket, &state);\n\tif (state & SS_DETECT) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\nout:\n\tpci_dev_put(func);\n\treturn ret;\n}\n\n \nstatic int ti12xx_power_hook(struct pcmcia_socket *sock, int operation)\n{\n\tstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\n\tu32 mfunc, devctl, sysctl;\n\tu8 gpio3;\n\n\t \n\tif ((operation != HOOK_POWER_PRE) && (operation != HOOK_POWER_POST))\n\t\treturn 0;\n\n\tdevctl = config_readb(socket, TI113X_DEVICE_CONTROL);\n\tsysctl = config_readl(socket, TI113X_SYSTEM_CONTROL);\n\tmfunc = config_readl(socket, TI122X_MFUNC);\n\n\t \n\tif (((devctl & TI113X_DCR_IMODE_MASK) == TI12XX_DCR_IMODE_ALL_SERIAL) &&\n\t    (pwr_irqs_off || ti12xx_2nd_slot_empty(socket))) {\n\t\tswitch (socket->dev->device) {\n\t\tcase PCI_DEVICE_ID_TI_1250:\n\t\tcase PCI_DEVICE_ID_TI_1251A:\n\t\tcase PCI_DEVICE_ID_TI_1251B:\n\t\tcase PCI_DEVICE_ID_TI_1450:\n\t\tcase PCI_DEVICE_ID_TI_1451A:\n\t\tcase PCI_DEVICE_ID_TI_4450:\n\t\tcase PCI_DEVICE_ID_TI_4451:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (operation == HOOK_POWER_PRE)\n\t\t\t\tmfunc = (mfunc & ~TI122X_MFUNC3_MASK);\n\t\t\telse\n\t\t\t\tmfunc = (mfunc & ~TI122X_MFUNC3_MASK) | TI122X_MFUNC3_IRQSER;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tif ((PCI_FUNC(socket->dev->devfn) == 0) ||\n\t    ((sysctl & TI122X_SCR_INTRTIE) &&\n\t     (pwr_irqs_off || ti12xx_2nd_slot_empty(socket)))) {\n\t\t \n\t\tswitch (socket->dev->device) {\n\t\tcase PCI_DEVICE_ID_TI_1250:\n\t\tcase PCI_DEVICE_ID_TI_1251A:\n\t\tcase PCI_DEVICE_ID_TI_1251B:\n\t\tcase PCI_DEVICE_ID_TI_1450:\n\t\t\t \n\t\t\tgpio3 = config_readb(socket, TI1250_GPIO3_CONTROL);\n\t\t\tif (operation == HOOK_POWER_PRE)\n\t\t\t\tgpio3 = (gpio3 & ~TI1250_GPIO_MODE_MASK) | 0x40;\n\t\t\telse\n\t\t\t\tgpio3 &= ~TI1250_GPIO_MODE_MASK;\n\t\t\tconfig_writeb(socket, TI1250_GPIO3_CONTROL, gpio3);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tif (operation == HOOK_POWER_PRE)\n\t\t\t\tmfunc &= ~TI122X_MFUNC0_MASK;\n\t\t\telse\n\t\t\t\tmfunc |= TI122X_MFUNC0_INTA;\n\t\t\tconfig_writel(socket, TI122X_MFUNC, mfunc);\n\t\t}\n\t} else {\n\t\tswitch (socket->dev->device) {\n\t\tcase PCI_DEVICE_ID_TI_1251A:\n\t\tcase PCI_DEVICE_ID_TI_1251B:\n\t\tcase PCI_DEVICE_ID_TI_1450:\n\t\t\t \n\t\t\tif (operation == HOOK_POWER_PRE)\n\t\t\t\tmfunc &= ~TI122X_MFUNC0_MASK;\n\t\t\telse\n\t\t\t\tmfunc |= TI125X_MFUNC0_INTB;\n\t\t\tconfig_writel(socket, TI122X_MFUNC, mfunc);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tif (operation == HOOK_POWER_PRE)\n\t\t\t\tmfunc &= ~TI122X_MFUNC1_MASK;\n\t\t\telse\n\t\t\t\tmfunc |= TI122X_MFUNC1_INTB;\n\t\t\tconfig_writel(socket, TI122X_MFUNC, mfunc);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ti12xx_override(struct yenta_socket *socket)\n{\n\tu32 val, val_orig;\n\n\t \n\tval_orig = val = config_readl(socket, TI113X_SYSTEM_CONTROL);\n\tif (disable_clkrun && PCI_FUNC(socket->dev->devfn) == 0) {\n\t\tdev_info(&socket->dev->dev, \"Disabling CLKRUN feature\\n\");\n\t\tval |= TI113X_SCR_KEEPCLK;\n\t}\n\tif (!(val & TI122X_SCR_MRBURSTUP)) {\n\t\tdev_info(&socket->dev->dev,\n\t\t\t \"Enabling burst memory read transactions\\n\");\n\t\tval |= TI122X_SCR_MRBURSTUP;\n\t}\n\tif (val_orig != val)\n\t\tconfig_writel(socket, TI113X_SYSTEM_CONTROL, val);\n\n\t \n\tval = config_readb(socket, TI1250_DIAGNOSTIC);\n\tdev_info(&socket->dev->dev, \"Using %s to route CSC interrupts to PCI\\n\",\n\t\t (val & TI1250_DIAG_PCI_CSC) ? \"CSCINT\" : \"INTVAL\");\n\tdev_info(&socket->dev->dev, \"Routing CardBus interrupts to %s\\n\",\n\t\t (val & TI1250_DIAG_PCI_IREQ) ? \"PCI\" : \"ISA\");\n\n\t \n\tif (PCI_FUNC(socket->dev->devfn) == 0)\n\t\tti12xx_irqroute_func0(socket);\n\telse\n\t\tti12xx_irqroute_func1(socket);\n\n\t \n\tsocket->socket.power_hook = ti12xx_power_hook;\n\n\treturn ti_override(socket);\n}\n\n\nstatic int ti1250_override(struct yenta_socket *socket)\n{\n\tu8 old, diag;\n\n\told = config_readb(socket, TI1250_DIAGNOSTIC);\n\tdiag = old & ~(TI1250_DIAG_PCI_CSC | TI1250_DIAG_PCI_IREQ);\n\tif (socket->cb_irq)\n\t\tdiag |= TI1250_DIAG_PCI_CSC | TI1250_DIAG_PCI_IREQ;\n\n\tif (diag != old) {\n\t\tdev_info(&socket->dev->dev,\n\t\t\t \"adjusting diagnostic: %02x -> %02x\\n\",\n\t\t\t old, diag);\n\t\tconfig_writeb(socket, TI1250_DIAGNOSTIC, diag);\n\t}\n\n\treturn ti12xx_override(socket);\n}\n\n\n \n\n#ifdef CONFIG_YENTA_ENE_TUNE\n \n \n#define DEVID(_vend,_dev,_subvend,_subdev,mask,bits) {\t\t\\\n\t\t.vendor\t\t= _vend,\t\t\t\\\n\t\t.device\t\t= _dev,\t\t\t\t\\\n\t\t.subvendor\t= _subvend,\t\t\t\\\n\t\t.subdevice\t= _subdev,\t\t\t\\\n\t\t.driver_data\t= ((mask) << 8 | (bits)),\t\\\n\t}\nstatic struct pci_device_id ene_tune_tbl[] = {\n\t \n\tDEVID(PCI_VENDOR_ID_MOTOROLA, 0x1801, 0xECC0, PCI_ANY_ID,\n\t\tENE_TEST_C9_TLTENABLE | ENE_TEST_C9_PFENABLE, ENE_TEST_C9_TLTENABLE),\n\tDEVID(PCI_VENDOR_ID_MOTOROLA, 0x3410, 0xECC0, PCI_ANY_ID,\n\t\tENE_TEST_C9_TLTENABLE | ENE_TEST_C9_PFENABLE, ENE_TEST_C9_TLTENABLE),\n\n\t{}\n};\n\nstatic void ene_tune_bridge(struct pcmcia_socket *sock, struct pci_bus *bus)\n{\n\tstruct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);\n\tstruct pci_dev *dev;\n\tstruct pci_device_id *id = NULL;\n\tu8 test_c9, old_c9, mask, bits;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tid = (struct pci_device_id *) pci_match_id(ene_tune_tbl, dev);\n\t\tif (id)\n\t\t\tbreak;\n\t}\n\n\ttest_c9 = old_c9 = config_readb(socket, ENE_TEST_C9);\n\tif (id) {\n\t\tmask = (id->driver_data >> 8) & 0xFF;\n\t\tbits = id->driver_data & 0xFF;\n\n\t\ttest_c9 = (test_c9 & ~mask) | bits;\n\t}\n\telse\n\t\t \n\t\ttest_c9 &= ~ENE_TEST_C9_TLTENABLE;\n\n\tdev_info(&socket->dev->dev,\n\t\t \"EnE: changing testregister 0xC9, %02x -> %02x\\n\",\n\t\t old_c9, test_c9);\n\tconfig_writeb(socket, ENE_TEST_C9, test_c9);\n}\n\nstatic int ene_override(struct yenta_socket *socket)\n{\n\t \n\tsocket->socket.tune_bridge = ene_tune_bridge;\n\n\treturn ti1250_override(socket);\n}\n#else\n#  define ene_override ti1250_override\n#endif  \n\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}