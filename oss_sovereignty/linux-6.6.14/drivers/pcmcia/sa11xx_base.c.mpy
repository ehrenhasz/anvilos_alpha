{
  "module_name": "sa11xx_base.c",
  "hash_id": "2c173b9d468a2a7805f2edc130b01cb368d9f61b31f6517806611460ae6fb407",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/sa11xx_base.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#include <mach/hardware.h>\n#include <asm/irq.h>\n\n#include \"soc_common.h\"\n#include \"sa11xx_base.h\"\n\n\n \nstatic unsigned int\nsa1100_pcmcia_default_mecr_timing(struct soc_pcmcia_socket *skt,\n\t\t\t\t  unsigned int cpu_speed,\n\t\t\t\t  unsigned int cmd_time)\n{\n\treturn sa1100_pcmcia_mecr_bs(cmd_time, cpu_speed);\n}\n\n \nstatic int\nsa1100_pcmcia_set_mecr(struct soc_pcmcia_socket *skt, unsigned int cpu_clock)\n{\n\tstruct soc_pcmcia_timing timing;\n\tu32 mecr, old_mecr;\n\tunsigned long flags;\n\tunsigned int bs_io, bs_mem, bs_attr;\n\n\tsoc_common_pcmcia_get_timing(skt, &timing);\n\n\tbs_io = skt->ops->get_timing(skt, cpu_clock, timing.io);\n\tbs_mem = skt->ops->get_timing(skt, cpu_clock, timing.mem);\n\tbs_attr = skt->ops->get_timing(skt, cpu_clock, timing.attr);\n\n\tlocal_irq_save(flags);\n\n\told_mecr = mecr = MECR;\n\tMECR_FAST_SET(mecr, skt->nr, 0);\n\tMECR_BSIO_SET(mecr, skt->nr, bs_io);\n\tMECR_BSA_SET(mecr, skt->nr, bs_attr);\n\tMECR_BSM_SET(mecr, skt->nr, bs_mem);\n\tif (old_mecr != mecr)\n\t\tMECR = mecr;\n\n\tlocal_irq_restore(flags);\n\n\tdebug(skt, 2, \"FAST %X  BSM %X  BSA %X  BSIO %X\\n\",\n\t      MECR_FAST_GET(mecr, skt->nr),\n\t      MECR_BSM_GET(mecr, skt->nr), MECR_BSA_GET(mecr, skt->nr),\n\t      MECR_BSIO_GET(mecr, skt->nr));\n\n\treturn 0;\n}\n\n#ifdef CONFIG_CPU_FREQ\nstatic int\nsa1100_pcmcia_frequency_change(struct soc_pcmcia_socket *skt,\n\t\t\t       unsigned long val,\n\t\t\t       struct cpufreq_freqs *freqs)\n{\n\tswitch (val) {\n\tcase CPUFREQ_PRECHANGE:\n\t\tif (freqs->new > freqs->old)\n\t\t\tsa1100_pcmcia_set_mecr(skt, freqs->new);\n\t\tbreak;\n\n\tcase CPUFREQ_POSTCHANGE:\n\t\tif (freqs->new < freqs->old)\n\t\t\tsa1100_pcmcia_set_mecr(skt, freqs->new);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#endif\n\nstatic int\nsa1100_pcmcia_set_timing(struct soc_pcmcia_socket *skt)\n{\n\tunsigned long clk = clk_get_rate(skt->clk);\n\n\treturn sa1100_pcmcia_set_mecr(skt, clk / 1000);\n}\n\nstatic int\nsa1100_pcmcia_show_timing(struct soc_pcmcia_socket *skt, char *buf)\n{\n\tstruct soc_pcmcia_timing timing;\n\tunsigned int clock = clk_get_rate(skt->clk) / 1000;\n\tunsigned long mecr = MECR;\n\tchar *p = buf;\n\n\tsoc_common_pcmcia_get_timing(skt, &timing);\n\n\tp+=sprintf(p, \"I/O      : %uns (%uns)\\n\", timing.io,\n\t\t   sa1100_pcmcia_cmd_time(clock, MECR_BSIO_GET(mecr, skt->nr)));\n\n\tp+=sprintf(p, \"attribute: %uns (%uns)\\n\", timing.attr,\n\t\t   sa1100_pcmcia_cmd_time(clock, MECR_BSA_GET(mecr, skt->nr)));\n\n\tp+=sprintf(p, \"common   : %uns (%uns)\\n\", timing.mem,\n\t\t   sa1100_pcmcia_cmd_time(clock, MECR_BSM_GET(mecr, skt->nr)));\n\n\treturn p - buf;\n}\n\nstatic const char *skt_names[] = {\n\t\"PCMCIA socket 0\",\n\t\"PCMCIA socket 1\",\n};\n\n#define SKT_DEV_INFO_SIZE(n) \\\n\t(sizeof(struct skt_dev_info) + (n)*sizeof(struct soc_pcmcia_socket))\n\nint sa11xx_drv_pcmcia_add_one(struct soc_pcmcia_socket *skt)\n{\n\tskt->res_skt.start = _PCMCIA(skt->nr);\n\tskt->res_skt.end = _PCMCIA(skt->nr) + PCMCIASp - 1;\n\tskt->res_skt.name = skt_names[skt->nr];\n\tskt->res_skt.flags = IORESOURCE_MEM;\n\n\tskt->res_io.start = _PCMCIAIO(skt->nr);\n\tskt->res_io.end = _PCMCIAIO(skt->nr) + PCMCIAIOSp - 1;\n\tskt->res_io.name = \"io\";\n\tskt->res_io.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\n\tskt->res_mem.start = _PCMCIAMem(skt->nr);\n\tskt->res_mem.end = _PCMCIAMem(skt->nr) + PCMCIAMemSp - 1;\n\tskt->res_mem.name = \"memory\";\n\tskt->res_mem.flags = IORESOURCE_MEM;\n\n\tskt->res_attr.start = _PCMCIAAttr(skt->nr);\n\tskt->res_attr.end = _PCMCIAAttr(skt->nr) + PCMCIAAttrSp - 1;\n\tskt->res_attr.name = \"attribute\";\n\tskt->res_attr.flags = IORESOURCE_MEM;\n\n\treturn soc_pcmcia_add_one(skt);\n}\nEXPORT_SYMBOL(sa11xx_drv_pcmcia_add_one);\n\nvoid sa11xx_drv_pcmcia_ops(struct pcmcia_low_level *ops)\n{\n\t \n\tif (!ops->get_timing)\n\t\tops->get_timing = sa1100_pcmcia_default_mecr_timing;\n\n\t \n\tops->set_timing  = sa1100_pcmcia_set_timing;\n\tops->show_timing = sa1100_pcmcia_show_timing;\n#ifdef CONFIG_CPU_FREQ\n\tops->frequency_change = sa1100_pcmcia_frequency_change;\n#endif\n}\nEXPORT_SYMBOL(sa11xx_drv_pcmcia_ops);\n\nint sa11xx_drv_pcmcia_probe(struct device *dev, struct pcmcia_low_level *ops,\n\t\t\t    int first, int nr)\n{\n\tstruct skt_dev_info *sinfo;\n\tstruct soc_pcmcia_socket *skt;\n\tint i, ret = 0;\n\tstruct clk *clk;\n\n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tsa11xx_drv_pcmcia_ops(ops);\n\n\tsinfo = devm_kzalloc(dev, SKT_DEV_INFO_SIZE(nr), GFP_KERNEL);\n\tif (!sinfo)\n\t\treturn -ENOMEM;\n\n\tsinfo->nskt = nr;\n\n\t \n\tfor (i = 0; i < nr; i++) {\n\t\tskt = &sinfo->skt[i];\n\n\t\tskt->nr = first + i;\n\t\tskt->clk = clk;\n\t\tsoc_pcmcia_init_one(skt, ops, dev);\n\n\t\tret = sa11xx_drv_pcmcia_add_one(skt);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\twhile (--i >= 0)\n\t\t\tsoc_pcmcia_remove_one(&sinfo->skt[i]);\n\t} else {\n\t\tdev_set_drvdata(dev, sinfo);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(sa11xx_drv_pcmcia_probe);\n\nMODULE_AUTHOR(\"John Dorsey <john+@cs.cmu.edu>\");\nMODULE_DESCRIPTION(\"Linux PCMCIA Card Services: SA-11xx core socket driver\");\nMODULE_LICENSE(\"Dual MPL/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}