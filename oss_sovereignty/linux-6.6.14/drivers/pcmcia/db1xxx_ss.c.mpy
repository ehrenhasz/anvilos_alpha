{
  "module_name": "db1xxx_ss.c",
  "hash_id": "dd4603a83b0b855ddf78cbc331277d9a21fdb5b79748458d6fee2a649cfcfec1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/db1xxx_ss.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/interrupt.h>\n#include <linux/pm.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/resource.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <pcmcia/ss.h>\n\n#include <asm/mach-au1x00/au1000.h>\n#include <asm/mach-db1x00/bcsr.h>\n\n#define MEM_MAP_SIZE\t0x400000\n#define IO_MAP_SIZE\t0x1000\n\nstruct db1x_pcmcia_sock {\n\tstruct pcmcia_socket\tsocket;\n\tint\t\tnr;\t\t \n\tvoid\t\t*virt_io;\n\n\tphys_addr_t\tphys_io;\n\tphys_addr_t\tphys_attr;\n\tphys_addr_t\tphys_mem;\n\n\t \n\tunsigned int old_flags;\n\n\t \n\tint\tinsert_irq;\t \n\tint\tstschg_irq;\t \n\tint\tcard_irq;\t \n\tint\teject_irq;\t \n\tint\tinsert_gpio;\t \n\n#define BOARD_TYPE_DEFAULT\t0\t \n#define BOARD_TYPE_DB1200\t1\t \n#define BOARD_TYPE_PB1100\t2\t \n#define BOARD_TYPE_DB1300\t3\t \n\tint\tboard_type;\n};\n\n#define to_db1x_socket(x) container_of(x, struct db1x_pcmcia_sock, socket)\n\nstatic int db1300_card_inserted(struct db1x_pcmcia_sock *sock)\n{\n\treturn bcsr_read(BCSR_SIGSTAT) & (1 << 8);\n}\n\n \nstatic int db1200_card_inserted(struct db1x_pcmcia_sock *sock)\n{\n\tunsigned short sigstat;\n\n\tsigstat = bcsr_read(BCSR_SIGSTAT);\n\treturn sigstat & 1 << (8 + 2 * sock->nr);\n}\n\n \nstatic int db1000_card_inserted(struct db1x_pcmcia_sock *sock)\n{\n\treturn !gpio_get_value(sock->insert_gpio);\n}\n\nstatic int db1x_card_inserted(struct db1x_pcmcia_sock *sock)\n{\n\tswitch (sock->board_type) {\n\tcase BOARD_TYPE_DB1200:\n\t\treturn db1200_card_inserted(sock);\n\tcase BOARD_TYPE_DB1300:\n\t\treturn db1300_card_inserted(sock);\n\tdefault:\n\t\treturn db1000_card_inserted(sock);\n\t}\n}\n\n \nstatic inline void set_stschg(struct db1x_pcmcia_sock *sock, int en)\n{\n\tif (sock->stschg_irq != -1) {\n\t\tif (en)\n\t\t\tenable_irq(sock->stschg_irq);\n\t\telse\n\t\t\tdisable_irq(sock->stschg_irq);\n\t}\n}\n\nstatic irqreturn_t db1000_pcmcia_cdirq(int irq, void *data)\n{\n\tstruct db1x_pcmcia_sock *sock = data;\n\n\tpcmcia_parse_events(&sock->socket, SS_DETECT);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t db1000_pcmcia_stschgirq(int irq, void *data)\n{\n\tstruct db1x_pcmcia_sock *sock = data;\n\n\tpcmcia_parse_events(&sock->socket, SS_STSCHG);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t db1200_pcmcia_cdirq(int irq, void *data)\n{\n\tdisable_irq_nosync(irq);\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t db1200_pcmcia_cdirq_fn(int irq, void *data)\n{\n\tstruct db1x_pcmcia_sock *sock = data;\n\n\t \n\tmsleep(100);\n\tif (irq == sock->insert_irq)\n\t\tenable_irq(sock->eject_irq);\n\telse\n\t\tenable_irq(sock->insert_irq);\n\n\tpcmcia_parse_events(&sock->socket, SS_DETECT);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int db1x_pcmcia_setup_irqs(struct db1x_pcmcia_sock *sock)\n{\n\tint ret;\n\n\tif (sock->stschg_irq != -1) {\n\t\tret = request_irq(sock->stschg_irq, db1000_pcmcia_stschgirq,\n\t\t\t\t  0, \"pcmcia_stschg\", sock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif ((sock->board_type == BOARD_TYPE_DB1200) ||\n\t    (sock->board_type == BOARD_TYPE_DB1300)) {\n\t\tret = request_threaded_irq(sock->insert_irq, db1200_pcmcia_cdirq,\n\t\t\tdb1200_pcmcia_cdirq_fn, 0, \"pcmcia_insert\", sock);\n\t\tif (ret)\n\t\t\tgoto out1;\n\n\t\tret = request_threaded_irq(sock->eject_irq, db1200_pcmcia_cdirq,\n\t\t\tdb1200_pcmcia_cdirq_fn, 0, \"pcmcia_eject\", sock);\n\t\tif (ret) {\n\t\t\tfree_irq(sock->insert_irq, sock);\n\t\t\tgoto out1;\n\t\t}\n\n\t\t \n\t\tif (db1x_card_inserted(sock))\n\t\t\tenable_irq(sock->eject_irq);\n\t\telse\n\t\t\tenable_irq(sock->insert_irq);\n\t} else {\n\t\t \n\t\tirq_set_irq_type(sock->insert_irq, IRQ_TYPE_EDGE_BOTH);\n\t\tret = request_irq(sock->insert_irq, db1000_pcmcia_cdirq,\n\t\t\t\t  0, \"pcmcia_carddetect\", sock);\n\n\t\tif (ret)\n\t\t\tgoto out1;\n\t}\n\n\treturn 0;\t \n\nout1:\n\tif (sock->stschg_irq != -1)\n\t\tfree_irq(sock->stschg_irq, sock);\n\n\treturn ret;\n}\n\nstatic void db1x_pcmcia_free_irqs(struct db1x_pcmcia_sock *sock)\n{\n\tif (sock->stschg_irq != -1)\n\t\tfree_irq(sock->stschg_irq, sock);\n\n\tfree_irq(sock->insert_irq, sock);\n\tif (sock->eject_irq != -1)\n\t\tfree_irq(sock->eject_irq, sock);\n}\n\n \nstatic int db1x_pcmcia_configure(struct pcmcia_socket *skt,\n\t\t\t\t struct socket_state_t *state)\n{\n\tstruct db1x_pcmcia_sock *sock = to_db1x_socket(skt);\n\tunsigned short cr_clr, cr_set;\n\tunsigned int changed;\n\tint v, p, ret;\n\n\t \n\tcr_clr = (0xf << (sock->nr * 8));  \n\tcr_set = 0;\n\tv = p = ret = 0;\n\n\tswitch (state->Vcc) {\n\tcase 50:\n\t\t++v;\n\t\tfallthrough;\n\tcase 33:\n\t\t++v;\n\t\tfallthrough;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_INFO \"pcmcia%d unsupported Vcc %d\\n\",\n\t\t\tsock->nr, state->Vcc);\n\t}\n\n\tswitch (state->Vpp) {\n\tcase 12:\n\t\t++p;\n\t\tfallthrough;\n\tcase 33:\n\tcase 50:\n\t\t++p;\n\t\tfallthrough;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_INFO \"pcmcia%d unsupported Vpp %d\\n\",\n\t\t\tsock->nr, state->Vpp);\n\t}\n\n\t \n\tif (((state->Vcc == 33) && (state->Vpp == 50)) ||\n\t    ((state->Vcc == 50) && (state->Vpp == 33))) {\n\t\tprintk(KERN_INFO \"pcmcia%d bad Vcc/Vpp combo (%d %d)\\n\",\n\t\t\tsock->nr, state->Vcc, state->Vpp);\n\t\tv = p = 0;\n\t\tret = -EINVAL;\n\t}\n\n\t \n\tif (sock->board_type != BOARD_TYPE_DB1300)\n\t\tcr_set |= ((v << 2) | p) << (sock->nr * 8);\n\n\tchanged = state->flags ^ sock->old_flags;\n\n\tif (changed & SS_RESET) {\n\t\tif (state->flags & SS_RESET) {\n\t\t\tset_stschg(sock, 0);\n\t\t\t \n\t\t\tcr_clr |= (1 << (7 + (sock->nr * 8)));\n\t\t\tcr_clr |= (1 << (4 + (sock->nr * 8)));\n\t\t} else {\n\t\t\t \n\t\t\tcr_set |= 1 << (7 + (sock->nr * 8));\n\t\t\tcr_set |= 1 << (4 + (sock->nr * 8));\n\t\t}\n\t}\n\n\t \n\tbcsr_mod(BCSR_PCMCIA, cr_clr, cr_set);\n\n\tsock->old_flags = state->flags;\n\n\t \n\tif ((changed & SS_RESET) && !(state->flags & SS_RESET)) {\n\t\tmsleep(500);\n\t\tset_stschg(sock, 1);\n\t}\n\n\treturn ret;\n}\n\n \n#define GET_VCC(cr, socknr)\t\t\\\n\t((((cr) >> 2) >> ((socknr) * 8)) & 3)\n\n \n#define GET_VS(sr, socknr)\t\t\\\n\t(((sr) >> (2 * (socknr))) & 3)\n\n \n#define GET_RESET(cr, socknr)\t\t\\\n\t((cr) & (1 << (7 + (8 * (socknr)))))\n\nstatic int db1x_pcmcia_get_status(struct pcmcia_socket *skt,\n\t\t\t\t  unsigned int *value)\n{\n\tstruct db1x_pcmcia_sock *sock = to_db1x_socket(skt);\n\tunsigned short cr, sr;\n\tunsigned int status;\n\n\tstatus = db1x_card_inserted(sock) ? SS_DETECT : 0;\n\n\tcr = bcsr_read(BCSR_PCMCIA);\n\tsr = bcsr_read(BCSR_STATUS);\n\n\t \n\tif (sock->board_type == BOARD_TYPE_PB1100)\n\t\tsr >>= 4;\n\n\t \n\tswitch (GET_VS(sr, sock->nr)) {\n\tcase 0:\n\tcase 2:\n\t\tstatus |= SS_3VCARD;\t \n\t\tbreak;\n\tcase 3:\n\t\tbreak;\t\t\t \n\tdefault:\n\t\tstatus |= SS_XVCARD;\t \n\t}\n\n\t \n\tstatus |= GET_VCC(cr, sock->nr) ? SS_POWERON : 0;\n\n\t \n\tif ((sock->board_type == BOARD_TYPE_DB1300) && (status & SS_DETECT))\n\t\tstatus = SS_POWERON | SS_3VCARD | SS_DETECT;\n\n\t \n\tstatus |= (GET_RESET(cr, sock->nr)) ? SS_READY : SS_RESET;\n\n\t*value = status;\n\n\treturn 0;\n}\n\nstatic int db1x_pcmcia_sock_init(struct pcmcia_socket *skt)\n{\n\treturn 0;\n}\n\nstatic int db1x_pcmcia_sock_suspend(struct pcmcia_socket *skt)\n{\n\treturn 0;\n}\n\nstatic int au1x00_pcmcia_set_io_map(struct pcmcia_socket *skt,\n\t\t\t\t    struct pccard_io_map *map)\n{\n\tstruct db1x_pcmcia_sock *sock = to_db1x_socket(skt);\n\n\tmap->start = (u32)sock->virt_io;\n\tmap->stop = map->start + IO_MAP_SIZE;\n\n\treturn 0;\n}\n\nstatic int au1x00_pcmcia_set_mem_map(struct pcmcia_socket *skt,\n\t\t\t\t     struct pccard_mem_map *map)\n{\n\tstruct db1x_pcmcia_sock *sock = to_db1x_socket(skt);\n\n\tif (map->flags & MAP_ATTRIB)\n\t\tmap->static_start = sock->phys_attr + map->card_start;\n\telse\n\t\tmap->static_start = sock->phys_mem + map->card_start;\n\n\treturn 0;\n}\n\nstatic struct pccard_operations db1x_pcmcia_operations = {\n\t.init\t\t\t= db1x_pcmcia_sock_init,\n\t.suspend\t\t= db1x_pcmcia_sock_suspend,\n\t.get_status\t\t= db1x_pcmcia_get_status,\n\t.set_socket\t\t= db1x_pcmcia_configure,\n\t.set_io_map\t\t= au1x00_pcmcia_set_io_map,\n\t.set_mem_map\t\t= au1x00_pcmcia_set_mem_map,\n};\n\nstatic int db1x_pcmcia_socket_probe(struct platform_device *pdev)\n{\n\tstruct db1x_pcmcia_sock *sock;\n\tstruct resource *r;\n\tint ret, bid;\n\n\tsock = kzalloc(sizeof(struct db1x_pcmcia_sock), GFP_KERNEL);\n\tif (!sock)\n\t\treturn -ENOMEM;\n\n\tsock->nr = pdev->id;\n\n\tbid = BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI));\n\tswitch (bid) {\n\tcase BCSR_WHOAMI_PB1500:\n\tcase BCSR_WHOAMI_PB1500R2:\n\tcase BCSR_WHOAMI_PB1100:\n\t\tsock->board_type = BOARD_TYPE_PB1100;\n\t\tbreak;\n\tcase BCSR_WHOAMI_DB1000 ... BCSR_WHOAMI_PB1550_SDR:\n\t\tsock->board_type = BOARD_TYPE_DEFAULT;\n\t\tbreak;\n\tcase BCSR_WHOAMI_PB1200 ... BCSR_WHOAMI_DB1200:\n\t\tsock->board_type = BOARD_TYPE_DB1200;\n\t\tbreak;\n\tcase BCSR_WHOAMI_DB1300:\n\t\tsock->board_type = BOARD_TYPE_DB1300;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_INFO \"db1xxx-ss: unknown board %d!\\n\", bid);\n\t\tret = -ENODEV;\n\t\tgoto out0;\n\t}\n\n\t \n\n\t \n\tr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, \"card\");\n\tsock->card_irq = r ? r->start : 0;\n\n\t \n\tr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, \"insert\");\n\tsock->insert_irq = r ? r->start : -1;\n\tif (sock->board_type == BOARD_TYPE_DEFAULT) {\n\t\tsock->insert_gpio = r ? r->start : -1;\n\t\tsock->insert_irq = r ? gpio_to_irq(r->start) : -1;\n\t}\n\n\t \n\tr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, \"stschg\");\n\tsock->stschg_irq = r ? r->start : -1;\n\n\t \n\tr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, \"eject\");\n\tsock->eject_irq = r ? r->start : -1;\n\n\tret = -ENODEV;\n\n\t \n\tr = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"pcmcia-attr\");\n\tif (!r) {\n\t\tprintk(KERN_ERR \"pcmcia%d has no 'pseudo-attr' resource!\\n\",\n\t\t\tsock->nr);\n\t\tgoto out0;\n\t}\n\tsock->phys_attr = r->start;\n\n\t \n\tr = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"pcmcia-mem\");\n\tif (!r) {\n\t\tprintk(KERN_ERR \"pcmcia%d has no 'pseudo-mem' resource!\\n\",\n\t\t\tsock->nr);\n\t\tgoto out0;\n\t}\n\tsock->phys_mem = r->start;\n\n\t \n\tr = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"pcmcia-io\");\n\tif (!r) {\n\t\tprintk(KERN_ERR \"pcmcia%d has no 'pseudo-io' resource!\\n\",\n\t\t\tsock->nr);\n\t\tgoto out0;\n\t}\n\tsock->phys_io = r->start;\n\n\t \n\tsock->virt_io = (void *)(ioremap(sock->phys_io, IO_MAP_SIZE) -\n\t\t\t\t mips_io_port_base);\n\n\tif (!sock->virt_io) {\n\t\tprintk(KERN_ERR \"pcmcia%d: cannot remap IO area\\n\",\n\t\t\tsock->nr);\n\t\tret = -ENOMEM;\n\t\tgoto out0;\n\t}\n\n\tsock->socket.ops\t= &db1x_pcmcia_operations;\n\tsock->socket.owner\t= THIS_MODULE;\n\tsock->socket.pci_irq\t= sock->card_irq;\n\tsock->socket.features\t= SS_CAP_STATIC_MAP | SS_CAP_PCCARD;\n\tsock->socket.map_size\t= MEM_MAP_SIZE;\n\tsock->socket.io_offset\t= (unsigned long)sock->virt_io;\n\tsock->socket.dev.parent\t= &pdev->dev;\n\tsock->socket.resource_ops = &pccard_static_ops;\n\n\tplatform_set_drvdata(pdev, sock);\n\n\tret = db1x_pcmcia_setup_irqs(sock);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"pcmcia%d cannot setup interrupts\\n\",\n\t\t\tsock->nr);\n\t\tgoto out1;\n\t}\n\n\tset_stschg(sock, 0);\n\n\tret = pcmcia_register_socket(&sock->socket);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"pcmcia%d failed to register\\n\", sock->nr);\n\t\tgoto out2;\n\t}\n\n\tprintk(KERN_INFO \"Alchemy Db/Pb1xxx pcmcia%d @ io/attr/mem %09llx\"\n\t\t\"(%p) %09llx %09llx  card/insert/stschg/eject irqs @ %d \"\n\t\t\"%d %d %d\\n\", sock->nr, sock->phys_io, sock->virt_io,\n\t\tsock->phys_attr, sock->phys_mem, sock->card_irq,\n\t\tsock->insert_irq, sock->stschg_irq, sock->eject_irq);\n\n\treturn 0;\n\nout2:\n\tdb1x_pcmcia_free_irqs(sock);\nout1:\n\tiounmap((void *)(sock->virt_io + (u32)mips_io_port_base));\nout0:\n\tkfree(sock);\n\treturn ret;\n}\n\nstatic int db1x_pcmcia_socket_remove(struct platform_device *pdev)\n{\n\tstruct db1x_pcmcia_sock *sock = platform_get_drvdata(pdev);\n\n\tdb1x_pcmcia_free_irqs(sock);\n\tpcmcia_unregister_socket(&sock->socket);\n\tiounmap((void *)(sock->virt_io + (u32)mips_io_port_base));\n\tkfree(sock);\n\n\treturn 0;\n}\n\nstatic struct platform_driver db1x_pcmcia_socket_driver = {\n\t.driver\t= {\n\t\t.name\t= \"db1xxx_pcmcia\",\n\t},\n\t.probe\t\t= db1x_pcmcia_socket_probe,\n\t.remove\t\t= db1x_pcmcia_socket_remove,\n};\n\nmodule_platform_driver(db1x_pcmcia_socket_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"PCMCIA Socket Services for Alchemy Db/Pb1x00 boards\");\nMODULE_AUTHOR(\"Manuel Lauss\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}