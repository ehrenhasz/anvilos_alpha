{
  "module_name": "pcmcia_cis.c",
  "hash_id": "bfe3a6edd6686a9e75a537e1710f33e51bf3899bf793f3817d8177d2ec989099",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/pcmcia_cis.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n\n#include <pcmcia/cisreg.h>\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ss.h>\n#include <pcmcia/ds.h>\n#include \"cs_internal.h\"\n\n\n \nint pccard_read_tuple(struct pcmcia_socket *s, unsigned int function,\n\t\tcisdata_t code, void *parse)\n{\n\ttuple_t tuple;\n\tcisdata_t *buf;\n\tint ret;\n\n\tbuf = kmalloc(256, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tdev_warn(&s->dev, \"no memory to read tuple\\n\");\n\t\treturn -ENOMEM;\n\t}\n\ttuple.DesiredTuple = code;\n\ttuple.Attributes = 0;\n\tif (function == BIND_FN_ALL)\n\t\ttuple.Attributes = TUPLE_RETURN_COMMON;\n\tret = pccard_get_first_tuple(s, function, &tuple);\n\tif (ret != 0)\n\t\tgoto done;\n\ttuple.TupleData = buf;\n\ttuple.TupleOffset = 0;\n\ttuple.TupleDataMax = 255;\n\tret = pccard_get_tuple_data(s, &tuple);\n\tif (ret != 0)\n\t\tgoto done;\n\tret = pcmcia_parse_tuple(&tuple, parse);\ndone:\n\tkfree(buf);\n\treturn ret;\n}\n\n\n \nstatic int pccard_loop_tuple(struct pcmcia_socket *s, unsigned int function,\n\t\t\t     cisdata_t code, cisparse_t *parse, void *priv_data,\n\t\t\t     int (*loop_tuple) (tuple_t *tuple,\n\t\t\t\t\t cisparse_t *parse,\n\t\t\t\t\t void *priv_data))\n{\n\ttuple_t tuple;\n\tcisdata_t *buf;\n\tint ret;\n\n\tbuf = kzalloc(256, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tdev_warn(&s->dev, \"no memory to read tuple\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttuple.TupleData = buf;\n\ttuple.TupleDataMax = 255;\n\ttuple.TupleOffset = 0;\n\ttuple.DesiredTuple = code;\n\ttuple.Attributes = 0;\n\n\tret = pccard_get_first_tuple(s, function, &tuple);\n\twhile (!ret) {\n\t\tif (pccard_get_tuple_data(s, &tuple))\n\t\t\tgoto next_entry;\n\n\t\tif (parse)\n\t\t\tif (pcmcia_parse_tuple(&tuple, parse))\n\t\t\t\tgoto next_entry;\n\n\t\tret = loop_tuple(&tuple, parse, priv_data);\n\t\tif (!ret)\n\t\t\tbreak;\n\nnext_entry:\n\t\tret = pccard_get_next_tuple(s, function, &tuple);\n\t}\n\n\tkfree(buf);\n\treturn ret;\n}\n\n\n \nstatic int pcmcia_io_cfg_data_width(unsigned int flags)\n{\n\tif (!(flags & CISTPL_IO_8BIT))\n\t\treturn IO_DATA_PATH_WIDTH_16;\n\tif (!(flags & CISTPL_IO_16BIT))\n\t\treturn IO_DATA_PATH_WIDTH_8;\n\treturn IO_DATA_PATH_WIDTH_AUTO;\n}\n\n\nstruct pcmcia_cfg_mem {\n\tstruct pcmcia_device *p_dev;\n\tint (*conf_check) (struct pcmcia_device *p_dev, void *priv_data);\n\tvoid *priv_data;\n\tcisparse_t parse;\n\tcistpl_cftable_entry_t dflt;\n};\n\n \nstatic int pcmcia_do_loop_config(tuple_t *tuple, cisparse_t *parse, void *priv)\n{\n\tstruct pcmcia_cfg_mem *cfg_mem = priv;\n\tstruct pcmcia_device *p_dev = cfg_mem->p_dev;\n\tcistpl_cftable_entry_t *cfg = &parse->cftable_entry;\n\tcistpl_cftable_entry_t *dflt = &cfg_mem->dflt;\n\tunsigned int flags = p_dev->config_flags;\n\tunsigned int vcc = p_dev->socket->socket.Vcc;\n\n\tdev_dbg(&p_dev->dev, \"testing configuration %x, autoconf %x\\n\",\n\t\tcfg->index, flags);\n\n\t \n\tcfg_mem->p_dev->config_index = cfg->index;\n\tif (cfg->flags & CISTPL_CFTABLE_DEFAULT)\n\t\tcfg_mem->dflt = *cfg;\n\n\t \n\tif (flags & CONF_AUTO_CHECK_VCC) {\n\t\tif (cfg->vcc.present & (1 << CISTPL_POWER_VNOM)) {\n\t\t\tif (vcc != cfg->vcc.param[CISTPL_POWER_VNOM] / 10000)\n\t\t\t\treturn -ENODEV;\n\t\t} else if (dflt->vcc.present & (1 << CISTPL_POWER_VNOM)) {\n\t\t\tif (vcc != dflt->vcc.param[CISTPL_POWER_VNOM] / 10000)\n\t\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tif (flags & CONF_AUTO_SET_VPP) {\n\t\tif (cfg->vpp1.present & (1 << CISTPL_POWER_VNOM))\n\t\t\tp_dev->vpp = cfg->vpp1.param[CISTPL_POWER_VNOM] / 10000;\n\t\telse if (dflt->vpp1.present & (1 << CISTPL_POWER_VNOM))\n\t\t\tp_dev->vpp =\n\t\t\t\tdflt->vpp1.param[CISTPL_POWER_VNOM] / 10000;\n\t}\n\n\t \n\tif ((flags & CONF_AUTO_AUDIO) && (cfg->flags & CISTPL_CFTABLE_AUDIO))\n\t\tp_dev->config_flags |= CONF_ENABLE_SPKR;\n\n\n\t \n\tif (flags & CONF_AUTO_SET_IO) {\n\t\tcistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt->io;\n\t\tint i = 0;\n\n\t\tp_dev->resource[0]->start = p_dev->resource[0]->end = 0;\n\t\tp_dev->resource[1]->start = p_dev->resource[1]->end = 0;\n\t\tif (io->nwin == 0)\n\t\t\treturn -ENODEV;\n\n\t\tp_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\t\tp_dev->resource[0]->flags |=\n\t\t\t\t\tpcmcia_io_cfg_data_width(io->flags);\n\t\tif (io->nwin > 1) {\n\t\t\t \n\t\t\ti = (io->win[1].len > io->win[0].len);\n\t\t\tp_dev->resource[1]->flags = p_dev->resource[0]->flags;\n\t\t\tp_dev->resource[1]->start = io->win[1-i].base;\n\t\t\tp_dev->resource[1]->end = io->win[1-i].len;\n\t\t}\n\t\tp_dev->resource[0]->start = io->win[i].base;\n\t\tp_dev->resource[0]->end = io->win[i].len;\n\t\tp_dev->io_lines = io->flags & CISTPL_IO_LINES_MASK;\n\t}\n\n\t \n\tif (flags & CONF_AUTO_SET_IOMEM) {\n\t\t \n\t\tcistpl_mem_t *mem = (cfg->mem.nwin) ? &cfg->mem : &dflt->mem;\n\n\t\tp_dev->resource[2]->start = p_dev->resource[2]->end = 0;\n\t\tif (mem->nwin == 0)\n\t\t\treturn -ENODEV;\n\n\t\tp_dev->resource[2]->start = mem->win[0].host_addr;\n\t\tp_dev->resource[2]->end = mem->win[0].len;\n\t\tif (p_dev->resource[2]->end < 0x1000)\n\t\t\tp_dev->resource[2]->end = 0x1000;\n\t\tp_dev->card_addr = mem->win[0].card_addr;\n\t}\n\n\tdev_dbg(&p_dev->dev,\n\t\t\"checking configuration %x: %pr %pr %pr (%d lines)\\n\",\n\t\tp_dev->config_index, p_dev->resource[0], p_dev->resource[1],\n\t\tp_dev->resource[2], p_dev->io_lines);\n\n\treturn cfg_mem->conf_check(p_dev, cfg_mem->priv_data);\n}\n\n \nint pcmcia_loop_config(struct pcmcia_device *p_dev,\n\t\t       int\t(*conf_check)\t(struct pcmcia_device *p_dev,\n\t\t\t\t\t\t void *priv_data),\n\t\t       void *priv_data)\n{\n\tstruct pcmcia_cfg_mem *cfg_mem;\n\tint ret;\n\n\tcfg_mem = kzalloc(sizeof(struct pcmcia_cfg_mem), GFP_KERNEL);\n\tif (cfg_mem == NULL)\n\t\treturn -ENOMEM;\n\n\tcfg_mem->p_dev = p_dev;\n\tcfg_mem->conf_check = conf_check;\n\tcfg_mem->priv_data = priv_data;\n\n\tret = pccard_loop_tuple(p_dev->socket, p_dev->func,\n\t\t\t\tCISTPL_CFTABLE_ENTRY, &cfg_mem->parse,\n\t\t\t\tcfg_mem, pcmcia_do_loop_config);\n\n\tkfree(cfg_mem);\n\treturn ret;\n}\nEXPORT_SYMBOL(pcmcia_loop_config);\n\n\nstruct pcmcia_loop_mem {\n\tstruct pcmcia_device *p_dev;\n\tvoid *priv_data;\n\tint (*loop_tuple) (struct pcmcia_device *p_dev,\n\t\t\t   tuple_t *tuple,\n\t\t\t   void *priv_data);\n};\n\n \nstatic int pcmcia_do_loop_tuple(tuple_t *tuple, cisparse_t *parse, void *priv)\n{\n\tstruct pcmcia_loop_mem *loop = priv;\n\n\treturn loop->loop_tuple(loop->p_dev, tuple, loop->priv_data);\n};\n\n \nint pcmcia_loop_tuple(struct pcmcia_device *p_dev, cisdata_t code,\n\t\t      int (*loop_tuple) (struct pcmcia_device *p_dev,\n\t\t\t\t\t tuple_t *tuple,\n\t\t\t\t\t void *priv_data),\n\t\t      void *priv_data)\n{\n\tstruct pcmcia_loop_mem loop = {\n\t\t.p_dev = p_dev,\n\t\t.loop_tuple = loop_tuple,\n\t\t.priv_data = priv_data};\n\n\treturn pccard_loop_tuple(p_dev->socket, p_dev->func, code, NULL,\n\t\t\t\t &loop, pcmcia_do_loop_tuple);\n}\nEXPORT_SYMBOL(pcmcia_loop_tuple);\n\n\nstruct pcmcia_loop_get {\n\tsize_t len;\n\tcisdata_t **buf;\n};\n\n \nstatic int pcmcia_do_get_tuple(struct pcmcia_device *p_dev, tuple_t *tuple,\n\t\t\t       void *priv)\n{\n\tstruct pcmcia_loop_get *get = priv;\n\n\t*get->buf = kzalloc(tuple->TupleDataLen, GFP_KERNEL);\n\tif (*get->buf) {\n\t\tget->len = tuple->TupleDataLen;\n\t\tmemcpy(*get->buf, tuple->TupleData, tuple->TupleDataLen);\n\t} else\n\t\tdev_dbg(&p_dev->dev, \"do_get_tuple: out of memory\\n\");\n\treturn 0;\n}\n\n \nsize_t pcmcia_get_tuple(struct pcmcia_device *p_dev, cisdata_t code,\n\t\t\tunsigned char **buf)\n{\n\tstruct pcmcia_loop_get get = {\n\t\t.len = 0,\n\t\t.buf = buf,\n\t};\n\n\t*get.buf = NULL;\n\tpcmcia_loop_tuple(p_dev, code, pcmcia_do_get_tuple, &get);\n\n\treturn get.len;\n}\nEXPORT_SYMBOL(pcmcia_get_tuple);\n\n#ifdef CONFIG_NET\n \nstatic int pcmcia_do_get_mac(struct pcmcia_device *p_dev, tuple_t *tuple,\n\t\t\t     void *priv)\n{\n\tstruct net_device *dev = priv;\n\n\tif (tuple->TupleData[0] != CISTPL_FUNCE_LAN_NODE_ID)\n\t\treturn -EINVAL;\n\tif (tuple->TupleDataLen < ETH_ALEN + 2) {\n\t\tdev_warn(&p_dev->dev, \"Invalid CIS tuple length for \"\n\t\t\t\"LAN_NODE_ID\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tuple->TupleData[1] != ETH_ALEN) {\n\t\tdev_warn(&p_dev->dev, \"Invalid header for LAN_NODE_ID\\n\");\n\t\treturn -EINVAL;\n\t}\n\teth_hw_addr_set(dev, &tuple->TupleData[2]);\n\treturn 0;\n}\n\n \nint pcmcia_get_mac_from_cis(struct pcmcia_device *p_dev, struct net_device *dev)\n{\n\treturn pcmcia_loop_tuple(p_dev, CISTPL_FUNCE, pcmcia_do_get_mac, dev);\n}\nEXPORT_SYMBOL(pcmcia_get_mac_from_cis);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}