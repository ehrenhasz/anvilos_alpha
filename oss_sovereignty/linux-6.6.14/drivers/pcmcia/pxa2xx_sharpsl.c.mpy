{
  "module_name": "pxa2xx_sharpsl.c",
  "hash_id": "1fb05f483a55e959126f8d38a10796e0257406eb87a5f7cc0d2c7d0856bfe444",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/pxa2xx_sharpsl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n\n#include <asm/mach-types.h>\n#include <asm/irq.h>\n#include <asm/hardware/scoop.h>\n\n#include <pcmcia/soc_common.h>\n\n#define\tNO_KEEP_VS 0x0001\n#define SCOOP_DEV platform_scoop_config->devs\n\nstatic void sharpsl_pcmcia_init_reset(struct soc_pcmcia_socket *skt)\n{\n\tstruct scoop_pcmcia_dev *scoopdev = &SCOOP_DEV[skt->nr];\n\n\treset_scoop(scoopdev->dev);\n\n\t \n\tif (platform_scoop_config->power_ctrl)\n\t\tplatform_scoop_config->power_ctrl(scoopdev->dev, 0x0000, skt->nr);\n\telse\n\t\twrite_scoop_reg(scoopdev->dev, SCOOP_CPR, 0x0000);\n\n\tscoopdev->keep_vs = NO_KEEP_VS;\n\tscoopdev->keep_rd = 0;\n}\n\nstatic int sharpsl_pcmcia_hw_init(struct soc_pcmcia_socket *skt)\n{\n\tif (SCOOP_DEV[skt->nr].cd_irq >= 0) {\n\t\tskt->stat[SOC_STAT_CD].irq = SCOOP_DEV[skt->nr].cd_irq;\n\t\tskt->stat[SOC_STAT_CD].name = SCOOP_DEV[skt->nr].cd_irq_str;\n\t}\n\n\tskt->socket.pci_irq = SCOOP_DEV[skt->nr].irq;\n\n\treturn 0;\n}\n\nstatic void sharpsl_pcmcia_socket_state(struct soc_pcmcia_socket *skt,\n\t\t\t\t    struct pcmcia_state *state)\n{\n\tunsigned short cpr, csr;\n\tstruct device *scoop = SCOOP_DEV[skt->nr].dev;\n\n\tcpr = read_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_CPR);\n\n\twrite_scoop_reg(scoop, SCOOP_IRM, 0x00FF);\n\twrite_scoop_reg(scoop, SCOOP_ISR, 0x0000);\n\twrite_scoop_reg(scoop, SCOOP_IRM, 0x0000);\n\tcsr = read_scoop_reg(scoop, SCOOP_CSR);\n\tif (csr & 0x0004) {\n\t\t \n\t\twrite_scoop_reg(scoop, SCOOP_CDR, 0x0000);\n\t\tSCOOP_DEV[skt->nr].keep_vs = NO_KEEP_VS;\n\t}\n\telse if (!(SCOOP_DEV[skt->nr].keep_vs & NO_KEEP_VS)) {\n\t\t \n\t\twrite_scoop_reg(scoop, SCOOP_CDR, 0x0000);\n\t\tcsr |= SCOOP_DEV[skt->nr].keep_vs;\n\t}\n\telse if (cpr & 0x0003) {\n\t\t \n\t\twrite_scoop_reg(scoop, SCOOP_CDR, 0x0000);\n\t\tSCOOP_DEV[skt->nr].keep_vs = (csr & 0x00C0);\n\t}\n\telse {\n\t\t \n\t        if ((machine_is_spitz() || machine_is_borzoi()) && skt->nr == 1) {\n\t                write_scoop_reg(scoop, SCOOP_CDR, 0x0000);\n\t        } else {\n\t\t        write_scoop_reg(scoop, SCOOP_CDR, 0x0002);\n\t        }\n\t}\n\n\tstate->detect = (csr & 0x0004) ? 0 : 1;\n\tstate->ready  = (csr & 0x0002) ? 1 : 0;\n\tstate->bvd1   = (csr & 0x0010) ? 1 : 0;\n\tstate->bvd2   = (csr & 0x0020) ? 1 : 0;\n\tstate->wrprot = (csr & 0x0008) ? 1 : 0;\n\tstate->vs_3v  = (csr & 0x0040) ? 0 : 1;\n\tstate->vs_Xv  = (csr & 0x0080) ? 0 : 1;\n\n\tif ((cpr & 0x0080) && ((cpr & 0x8040) != 0x8040)) {\n\t\tprintk(KERN_ERR \"sharpsl_pcmcia_socket_state(): CPR=%04X, Low voltage!\\n\", cpr);\n\t}\n}\n\n\nstatic int sharpsl_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,\n\t\t\t\t       const socket_state_t *state)\n{\n\tunsigned long flags;\n\tstruct device *scoop = SCOOP_DEV[skt->nr].dev;\n\n\tunsigned short cpr, ncpr, ccr, nccr, mcr, nmcr, imr, nimr;\n\n\tswitch (state->Vcc) {\n\tcase\t0:  \tbreak;\n\tcase \t33: \tbreak;\n\tcase\t50: \tbreak;\n\tdefault:\n\t\t printk(KERN_ERR \"sharpsl_pcmcia_configure_socket(): bad Vcc %u\\n\", state->Vcc);\n\t\t return -1;\n\t}\n\n\tif ((state->Vpp!=state->Vcc) && (state->Vpp!=0)) {\n\t\tprintk(KERN_ERR \"CF slot cannot support Vpp %u\\n\", state->Vpp);\n\t\treturn -1;\n\t}\n\n\tlocal_irq_save(flags);\n\n\tnmcr = (mcr = read_scoop_reg(scoop, SCOOP_MCR)) & ~0x0010;\n\tncpr = (cpr = read_scoop_reg(scoop, SCOOP_CPR)) & ~0x0083;\n\tnccr = (ccr = read_scoop_reg(scoop, SCOOP_CCR)) & ~0x0080;\n\tnimr = (imr = read_scoop_reg(scoop, SCOOP_IMR)) & ~0x003E;\n\n\tif ((machine_is_spitz() || machine_is_borzoi() || machine_is_akita()) && skt->nr == 0) {\n\t        ncpr |= (state->Vcc == 33) ? 0x0002 :\n\t\t        (state->Vcc == 50) ? 0x0002 : 0;\n\t} else {\n\t        ncpr |= (state->Vcc == 33) ? 0x0001 :\n\t\t        (state->Vcc == 50) ? 0x0002 : 0;\n\t}\n\tnmcr |= (state->flags&SS_IOCARD) ? 0x0010 : 0;\n\tncpr |= (state->flags&SS_OUTPUT_ENA) ? 0x0080 : 0;\n\tnccr |= (state->flags&SS_RESET)? 0x0080: 0;\n\tnimr |=\t((skt->status&SS_DETECT) ? 0x0004 : 0)|\n\t\t\t((skt->status&SS_READY)  ? 0x0002 : 0)|\n\t\t\t((skt->status&SS_BATDEAD)? 0x0010 : 0)|\n\t\t\t((skt->status&SS_BATWARN)? 0x0020 : 0)|\n\t\t\t((skt->status&SS_STSCHG) ? 0x0010 : 0)|\n\t\t\t((skt->status&SS_WRPROT) ? 0x0008 : 0);\n\n\tif (!(ncpr & 0x0003)) {\n\t\tSCOOP_DEV[skt->nr].keep_rd = 0;\n\t} else if (!SCOOP_DEV[skt->nr].keep_rd) {\n\t\tif (nccr & 0x0080)\n\t\t\tSCOOP_DEV[skt->nr].keep_rd = 1;\n\t\telse\n\t\t\tnccr |= 0x0080;\n\t}\n\n\tif (mcr != nmcr)\n\t\twrite_scoop_reg(scoop, SCOOP_MCR, nmcr);\n\tif (cpr != ncpr) {\n\t\tif (platform_scoop_config->power_ctrl)\n\t\t\tplatform_scoop_config->power_ctrl(scoop, ncpr , skt->nr);\n\t\telse\n\t\t        write_scoop_reg(scoop, SCOOP_CPR, ncpr);\n\t}\n\tif (ccr != nccr)\n\t\twrite_scoop_reg(scoop, SCOOP_CCR, nccr);\n\tif (imr != nimr)\n\t\twrite_scoop_reg(scoop, SCOOP_IMR, nimr);\n\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\nstatic void sharpsl_pcmcia_socket_init(struct soc_pcmcia_socket *skt)\n{\n\tsharpsl_pcmcia_init_reset(skt);\n\n\t \n\twrite_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_IMR, 0x00C0);\n\twrite_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_MCR, 0x0101);\n\tSCOOP_DEV[skt->nr].keep_vs = NO_KEEP_VS;\n}\n\nstatic void sharpsl_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)\n{\n\tsharpsl_pcmcia_init_reset(skt);\n}\n\nstatic struct pcmcia_low_level sharpsl_pcmcia_ops = {\n\t.owner                  = THIS_MODULE,\n\t.hw_init                = sharpsl_pcmcia_hw_init,\n\t.socket_state           = sharpsl_pcmcia_socket_state,\n\t.configure_socket       = sharpsl_pcmcia_configure_socket,\n\t.socket_init            = sharpsl_pcmcia_socket_init,\n\t.socket_suspend         = sharpsl_pcmcia_socket_suspend,\n\t.first                  = 0,\n\t.nr                     = 0,\n};\n\n#ifdef CONFIG_SA1100_COLLIE\n#include \"sa11xx_base.h\"\n\nint pcmcia_collie_init(struct device *dev)\n{\n       int ret = -ENODEV;\n\n       if (machine_is_collie())\n               ret = sa11xx_drv_pcmcia_probe(dev, &sharpsl_pcmcia_ops, 0, 1);\n\n       return ret;\n}\n\n#else\n\nstatic struct platform_device *sharpsl_pcmcia_device;\n\nstatic int __init sharpsl_pcmcia_init(void)\n{\n\tint ret;\n\n\tif (!platform_scoop_config)\n\t\treturn -ENODEV;\n\n\tsharpsl_pcmcia_ops.nr = platform_scoop_config->num_devs;\n\tsharpsl_pcmcia_device = platform_device_alloc(\"pxa2xx-pcmcia\", -1);\n\n\tif (!sharpsl_pcmcia_device)\n\t\treturn -ENOMEM;\n\n\tret = platform_device_add_data(sharpsl_pcmcia_device,\n\t\t\t&sharpsl_pcmcia_ops, sizeof(sharpsl_pcmcia_ops));\n\tif (ret == 0) {\n\t\tsharpsl_pcmcia_device->dev.parent = platform_scoop_config->devs[0].dev;\n\t\tret = platform_device_add(sharpsl_pcmcia_device);\n\t}\n\n\tif (ret)\n\t\tplatform_device_put(sharpsl_pcmcia_device);\n\n\treturn ret;\n}\n\nstatic void __exit sharpsl_pcmcia_exit(void)\n{\n\tplatform_device_unregister(sharpsl_pcmcia_device);\n}\n\nfs_initcall(sharpsl_pcmcia_init);\nmodule_exit(sharpsl_pcmcia_exit);\n#endif\n\nMODULE_DESCRIPTION(\"Sharp SL Series PCMCIA Support\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pxa2xx-pcmcia\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}