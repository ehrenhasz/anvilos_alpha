{
  "module_name": "pcmcia_resource.c",
  "hash_id": "5f2b3a19172beb325e06122ef424fb4685a85d2c9a36f564f4af0172720c8e92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/pcmcia_resource.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n\n#include <asm/irq.h>\n\n#include <pcmcia/ss.h>\n#include <pcmcia/cistpl.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ds.h>\n\n#include \"cs_internal.h\"\n\n\n \nstatic int io_speed;\nmodule_param(io_speed, int, 0444);\n\n\nint pcmcia_validate_mem(struct pcmcia_socket *s)\n{\n\tif (s->resource_ops->validate_mem)\n\t\treturn s->resource_ops->validate_mem(s);\n\t \n\treturn 0;\n}\n\nstruct resource *pcmcia_find_mem_region(u_long base, u_long num, u_long align,\n\t\t\t\t int low, struct pcmcia_socket *s)\n{\n\tif (s->resource_ops->find_mem)\n\t\treturn s->resource_ops->find_mem(base, num, align, low, s);\n\treturn NULL;\n}\n\n\n \nstatic void release_io_space(struct pcmcia_socket *s, struct resource *res)\n{\n\tresource_size_t num = resource_size(res);\n\tint i;\n\n\tdev_dbg(&s->dev, \"release_io_space for %pR\\n\", res);\n\n\tfor (i = 0; i < MAX_IO_WIN; i++) {\n\t\tif (!s->io[i].res)\n\t\t\tcontinue;\n\t\tif ((s->io[i].res->start <= res->start) &&\n\t\t    (s->io[i].res->end >= res->end)) {\n\t\t\ts->io[i].InUse -= num;\n\t\t\tif (res->parent)\n\t\t\t\trelease_resource(res);\n\t\t\tres->start = res->end = 0;\n\t\t\tres->flags = IORESOURCE_IO;\n\t\t\t \n\t\t\tif (s->io[i].InUse == 0) {\n\t\t\t\trelease_resource(s->io[i].res);\n\t\t\t\tkfree(s->io[i].res);\n\t\t\t\ts->io[i].res = NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n \nstatic int alloc_io_space(struct pcmcia_socket *s, struct resource *res,\n\t\t\tunsigned int lines)\n{\n\tunsigned int align;\n\tunsigned int base = res->start;\n\tunsigned int num = res->end;\n\tint ret;\n\n\tres->flags |= IORESOURCE_IO;\n\n\tdev_dbg(&s->dev, \"alloc_io_space request for %pR, %d lines\\n\",\n\t\tres, lines);\n\n\talign = base ? (lines ? 1<<lines : 0) : 1;\n\tif (align && (align < num)) {\n\t\tif (base) {\n\t\t\tdev_dbg(&s->dev, \"odd IO request\\n\");\n\t\t\talign = 0;\n\t\t} else\n\t\t\twhile (align && (align < num))\n\t\t\t\talign <<= 1;\n\t}\n\tif (base & ~(align-1)) {\n\t\tdev_dbg(&s->dev, \"odd IO request\\n\");\n\t\talign = 0;\n\t}\n\n\tret = s->resource_ops->find_io(s, res->flags, &base, num, align,\n\t\t\t\t&res->parent);\n\tif (ret) {\n\t\tdev_dbg(&s->dev, \"alloc_io_space request failed (%d)\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tres->start = base;\n\tres->end = res->start + num - 1;\n\n\tif (res->parent) {\n\t\tret = request_resource(res->parent, res);\n\t\tif (ret) {\n\t\t\tdev_warn(&s->dev,\n\t\t\t\t\"request_resource %pR failed: %d\\n\", res, ret);\n\t\t\tres->parent = NULL;\n\t\t\trelease_io_space(s, res);\n\t\t}\n\t}\n\tdev_dbg(&s->dev, \"alloc_io_space request result %d: %pR\\n\", ret, res);\n\treturn ret;\n}\n\n\n \nstatic int pcmcia_access_config(struct pcmcia_device *p_dev,\n\t\t\t\toff_t where, u8 *val,\n\t\t\t\tint (*accessf) (struct pcmcia_socket *s,\n\t\t\t\t\t\tint attr, unsigned int addr,\n\t\t\t\t\t\tunsigned int len, void *ptr))\n{\n\tstruct pcmcia_socket *s;\n\tconfig_t *c;\n\tint addr;\n\tint ret = 0;\n\n\ts = p_dev->socket;\n\n\tmutex_lock(&s->ops_mutex);\n\tc = p_dev->function_config;\n\n\tif (!(c->state & CONFIG_LOCKED)) {\n\t\tdev_dbg(&p_dev->dev, \"Configuration isn't locked\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EACCES;\n\t}\n\n\taddr = (p_dev->config_base + where) >> 1;\n\n\tret = accessf(s, 1, addr, 1, val);\n\n\tmutex_unlock(&s->ops_mutex);\n\n\treturn ret;\n}\n\n\n \nint pcmcia_read_config_byte(struct pcmcia_device *p_dev, off_t where, u8 *val)\n{\n\treturn pcmcia_access_config(p_dev, where, val, pcmcia_read_cis_mem);\n}\nEXPORT_SYMBOL(pcmcia_read_config_byte);\n\n\n \nint pcmcia_write_config_byte(struct pcmcia_device *p_dev, off_t where, u8 val)\n{\n\treturn pcmcia_access_config(p_dev, where, &val, pcmcia_write_cis_mem);\n}\nEXPORT_SYMBOL(pcmcia_write_config_byte);\n\n\n \nint pcmcia_map_mem_page(struct pcmcia_device *p_dev, struct resource *res,\n\t\t\tunsigned int offset)\n{\n\tstruct pcmcia_socket *s = p_dev->socket;\n\tunsigned int w;\n\tint ret;\n\n\tw = ((res->flags & IORESOURCE_BITS & WIN_FLAGS_REQ) >> 2) - 1;\n\tif (w >= MAX_WIN)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&s->ops_mutex);\n\ts->win[w].card_start = offset;\n\tret = s->ops->set_mem_map(s, &s->win[w]);\n\tif (ret)\n\t\tdev_warn(&p_dev->dev, \"failed to set_mem_map\\n\");\n\tmutex_unlock(&s->ops_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(pcmcia_map_mem_page);\n\n\n \nint pcmcia_fixup_iowidth(struct pcmcia_device *p_dev)\n{\n\tstruct pcmcia_socket *s = p_dev->socket;\n\tpccard_io_map io_off = { 0, 0, 0, 0, 1 };\n\tpccard_io_map io_on;\n\tint i, ret = 0;\n\n\tmutex_lock(&s->ops_mutex);\n\n\tdev_dbg(&p_dev->dev, \"fixup iowidth to 8bit\\n\");\n\n\tif (!(s->state & SOCKET_PRESENT) ||\n\t\t!(p_dev->function_config->state & CONFIG_LOCKED)) {\n\t\tdev_dbg(&p_dev->dev, \"No card? Config not locked?\\n\");\n\t\tret = -EACCES;\n\t\tgoto unlock;\n\t}\n\n\tio_on.speed = io_speed;\n\tfor (i = 0; i < MAX_IO_WIN; i++) {\n\t\tif (!s->io[i].res)\n\t\t\tcontinue;\n\t\tio_off.map = i;\n\t\tio_on.map = i;\n\n\t\tio_on.flags = MAP_ACTIVE | IO_DATA_PATH_WIDTH_8;\n\t\tio_on.start = s->io[i].res->start;\n\t\tio_on.stop = s->io[i].res->end;\n\n\t\ts->ops->set_io_map(s, &io_off);\n\t\tmsleep(40);\n\t\ts->ops->set_io_map(s, &io_on);\n\t}\nunlock:\n\tmutex_unlock(&s->ops_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(pcmcia_fixup_iowidth);\n\n\n \nint pcmcia_fixup_vpp(struct pcmcia_device *p_dev, unsigned char new_vpp)\n{\n\tstruct pcmcia_socket *s = p_dev->socket;\n\tint ret = 0;\n\n\tmutex_lock(&s->ops_mutex);\n\n\tdev_dbg(&p_dev->dev, \"fixup Vpp to %d\\n\", new_vpp);\n\n\tif (!(s->state & SOCKET_PRESENT) ||\n\t\t!(p_dev->function_config->state & CONFIG_LOCKED)) {\n\t\tdev_dbg(&p_dev->dev, \"No card? Config not locked?\\n\");\n\t\tret = -EACCES;\n\t\tgoto unlock;\n\t}\n\n\ts->socket.Vpp = new_vpp;\n\tif (s->ops->set_socket(s, &s->socket)) {\n\t\tdev_warn(&p_dev->dev, \"Unable to set VPP\\n\");\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\tp_dev->vpp = new_vpp;\n\nunlock:\n\tmutex_unlock(&s->ops_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(pcmcia_fixup_vpp);\n\n\n \nint pcmcia_release_configuration(struct pcmcia_device *p_dev)\n{\n\tpccard_io_map io = { 0, 0, 0, 0, 1 };\n\tstruct pcmcia_socket *s = p_dev->socket;\n\tconfig_t *c;\n\tint i;\n\n\tmutex_lock(&s->ops_mutex);\n\tc = p_dev->function_config;\n\tif (p_dev->_locked) {\n\t\tp_dev->_locked = 0;\n\t\tif (--(s->lock_count) == 0) {\n\t\t\ts->socket.flags = SS_OUTPUT_ENA;  \n\t\t\ts->socket.Vpp = 0;\n\t\t\ts->socket.io_irq = 0;\n\t\t\ts->ops->set_socket(s, &s->socket);\n\t\t}\n\t}\n\tif (c->state & CONFIG_LOCKED) {\n\t\tc->state &= ~CONFIG_LOCKED;\n\t\tif (c->state & CONFIG_IO_REQ)\n\t\t\tfor (i = 0; i < MAX_IO_WIN; i++) {\n\t\t\t\tif (!s->io[i].res)\n\t\t\t\t\tcontinue;\n\t\t\t\ts->io[i].Config--;\n\t\t\t\tif (s->io[i].Config != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tio.map = i;\n\t\t\t\ts->ops->set_io_map(s, &io);\n\t\t\t}\n\t}\n\tmutex_unlock(&s->ops_mutex);\n\n\treturn 0;\n}\n\n\n \nstatic void pcmcia_release_io(struct pcmcia_device *p_dev)\n{\n\tstruct pcmcia_socket *s = p_dev->socket;\n\tconfig_t *c;\n\n\tmutex_lock(&s->ops_mutex);\n\tif (!p_dev->_io)\n\t\tgoto out;\n\n\tc = p_dev->function_config;\n\n\trelease_io_space(s, &c->io[0]);\n\n\tif (c->io[1].end)\n\t\trelease_io_space(s, &c->io[1]);\n\n\tp_dev->_io = 0;\n\tc->state &= ~CONFIG_IO_REQ;\n\nout:\n\tmutex_unlock(&s->ops_mutex);\n}  \n\n\n \nint pcmcia_release_window(struct pcmcia_device *p_dev, struct resource *res)\n{\n\tstruct pcmcia_socket *s = p_dev->socket;\n\tpccard_mem_map *win;\n\tunsigned int w;\n\n\tdev_dbg(&p_dev->dev, \"releasing window %pR\\n\", res);\n\n\tw = ((res->flags & IORESOURCE_BITS & WIN_FLAGS_REQ) >> 2) - 1;\n\tif (w >= MAX_WIN)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&s->ops_mutex);\n\twin = &s->win[w];\n\n\tif (!(p_dev->_win & CLIENT_WIN_REQ(w))) {\n\t\tdev_dbg(&p_dev->dev, \"not releasing unknown window\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twin->flags &= ~MAP_ACTIVE;\n\ts->ops->set_mem_map(s, win);\n\ts->state &= ~SOCKET_WIN_REQ(w);\n\n\t \n\tif (win->res) {\n\t\trelease_resource(res);\n\t\trelease_resource(win->res);\n\t\tkfree(win->res);\n\t\twin->res = NULL;\n\t}\n\tres->start = res->end = 0;\n\tres->flags = IORESOURCE_MEM;\n\tp_dev->_win &= ~CLIENT_WIN_REQ(w);\n\tmutex_unlock(&s->ops_mutex);\n\n\treturn 0;\n}  \nEXPORT_SYMBOL(pcmcia_release_window);\n\n\n \nint pcmcia_enable_device(struct pcmcia_device *p_dev)\n{\n\tint i;\n\tunsigned int base;\n\tstruct pcmcia_socket *s = p_dev->socket;\n\tconfig_t *c;\n\tpccard_io_map iomap;\n\tunsigned char status = 0;\n\tunsigned char ext_status = 0;\n\tunsigned char option = 0;\n\tunsigned int flags = p_dev->config_flags;\n\n\tif (!(s->state & SOCKET_PRESENT))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&s->ops_mutex);\n\tc = p_dev->function_config;\n\tif (c->state & CONFIG_LOCKED) {\n\t\tmutex_unlock(&s->ops_mutex);\n\t\tdev_dbg(&p_dev->dev, \"Configuration is locked\\n\");\n\t\treturn -EACCES;\n\t}\n\n\t \n\ts->socket.Vpp = p_dev->vpp;\n\tif (s->ops->set_socket(s, &s->socket)) {\n\t\tmutex_unlock(&s->ops_mutex);\n\t\tdev_warn(&p_dev->dev, \"Unable to set socket state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (p_dev->_io || flags & CONF_ENABLE_IRQ)\n\t\tflags |= CONF_ENABLE_IOCARD;\n\tif (flags & CONF_ENABLE_IOCARD)\n\t\ts->socket.flags |= SS_IOCARD;\n\tif (flags & CONF_ENABLE_ZVCARD)\n\t\ts->socket.flags |= SS_ZVCARD | SS_IOCARD;\n\tif (flags & CONF_ENABLE_SPKR) {\n\t\ts->socket.flags |= SS_SPKR_ENA;\n\t\tstatus = CCSR_AUDIO_ENA;\n\t\tif (!(p_dev->config_regs & PRESENT_STATUS))\n\t\t\tdev_warn(&p_dev->dev, \"speaker requested, but \"\n\t\t\t\t\t      \"PRESENT_STATUS not set!\\n\");\n\t}\n\tif (flags & CONF_ENABLE_IRQ)\n\t\ts->socket.io_irq = s->pcmcia_irq;\n\telse\n\t\ts->socket.io_irq = 0;\n\tif (flags & CONF_ENABLE_ESR) {\n\t\tp_dev->config_regs |= PRESENT_EXT_STATUS;\n\t\text_status = ESR_REQ_ATTN_ENA;\n\t}\n\ts->ops->set_socket(s, &s->socket);\n\ts->lock_count++;\n\n\tdev_dbg(&p_dev->dev,\n\t\t\"enable_device: V %d, flags %x, base %x, regs %x, idx %x\\n\",\n\t\tp_dev->vpp, flags, p_dev->config_base, p_dev->config_regs,\n\t\tp_dev->config_index);\n\n\t \n\tbase = p_dev->config_base;\n\tif (p_dev->config_regs & PRESENT_COPY) {\n\t\tu16 tmp = 0;\n\t\tdev_dbg(&p_dev->dev, \"clearing CISREG_SCR\\n\");\n\t\tpcmcia_write_cis_mem(s, 1, (base + CISREG_SCR)>>1, 1, &tmp);\n\t}\n\tif (p_dev->config_regs & PRESENT_PIN_REPLACE) {\n\t\tu16 tmp = 0;\n\t\tdev_dbg(&p_dev->dev, \"clearing CISREG_PRR\\n\");\n\t\tpcmcia_write_cis_mem(s, 1, (base + CISREG_PRR)>>1, 1, &tmp);\n\t}\n\tif (p_dev->config_regs & PRESENT_OPTION) {\n\t\tif (s->functions == 1) {\n\t\t\toption = p_dev->config_index & COR_CONFIG_MASK;\n\t\t} else {\n\t\t\toption = p_dev->config_index & COR_MFC_CONFIG_MASK;\n\t\t\toption |= COR_FUNC_ENA|COR_IREQ_ENA;\n\t\t\tif (p_dev->config_regs & PRESENT_IOBASE_0)\n\t\t\t\toption |= COR_ADDR_DECODE;\n\t\t}\n\t\tif ((flags & CONF_ENABLE_IRQ) &&\n\t\t\t!(flags & CONF_ENABLE_PULSE_IRQ))\n\t\t\toption |= COR_LEVEL_REQ;\n\t\tpcmcia_write_cis_mem(s, 1, (base + CISREG_COR)>>1, 1, &option);\n\t\tmsleep(40);\n\t}\n\tif (p_dev->config_regs & PRESENT_STATUS)\n\t\tpcmcia_write_cis_mem(s, 1, (base + CISREG_CCSR)>>1, 1, &status);\n\n\tif (p_dev->config_regs & PRESENT_EXT_STATUS)\n\t\tpcmcia_write_cis_mem(s, 1, (base + CISREG_ESR)>>1, 1,\n\t\t\t\t\t&ext_status);\n\n\tif (p_dev->config_regs & PRESENT_IOBASE_0) {\n\t\tu8 b = c->io[0].start & 0xff;\n\t\tpcmcia_write_cis_mem(s, 1, (base + CISREG_IOBASE_0)>>1, 1, &b);\n\t\tb = (c->io[0].start >> 8) & 0xff;\n\t\tpcmcia_write_cis_mem(s, 1, (base + CISREG_IOBASE_1)>>1, 1, &b);\n\t}\n\tif (p_dev->config_regs & PRESENT_IOSIZE) {\n\t\tu8 b = resource_size(&c->io[0]) + resource_size(&c->io[1]) - 1;\n\t\tpcmcia_write_cis_mem(s, 1, (base + CISREG_IOSIZE)>>1, 1, &b);\n\t}\n\n\t \n\tif (c->state & CONFIG_IO_REQ) {\n\t\tiomap.speed = io_speed;\n\t\tfor (i = 0; i < MAX_IO_WIN; i++)\n\t\t\tif (s->io[i].res) {\n\t\t\t\tiomap.map = i;\n\t\t\t\tiomap.flags = MAP_ACTIVE;\n\t\t\t\tswitch (s->io[i].res->flags & IO_DATA_PATH_WIDTH) {\n\t\t\t\tcase IO_DATA_PATH_WIDTH_16:\n\t\t\t\t\tiomap.flags |= MAP_16BIT; break;\n\t\t\t\tcase IO_DATA_PATH_WIDTH_AUTO:\n\t\t\t\t\tiomap.flags |= MAP_AUTOSZ; break;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiomap.start = s->io[i].res->start;\n\t\t\t\tiomap.stop = s->io[i].res->end;\n\t\t\t\ts->ops->set_io_map(s, &iomap);\n\t\t\t\ts->io[i].Config++;\n\t\t\t}\n\t}\n\n\tc->state |= CONFIG_LOCKED;\n\tp_dev->_locked = 1;\n\tmutex_unlock(&s->ops_mutex);\n\treturn 0;\n}  \nEXPORT_SYMBOL(pcmcia_enable_device);\n\n\n \nint pcmcia_request_io(struct pcmcia_device *p_dev)\n{\n\tstruct pcmcia_socket *s = p_dev->socket;\n\tconfig_t *c = p_dev->function_config;\n\tint ret = -EINVAL;\n\n\tmutex_lock(&s->ops_mutex);\n\tdev_dbg(&p_dev->dev, \"pcmcia_request_io: %pR , %pR\",\n\t\t&c->io[0], &c->io[1]);\n\n\tif (!(s->state & SOCKET_PRESENT)) {\n\t\tdev_dbg(&p_dev->dev, \"pcmcia_request_io: No card present\\n\");\n\t\tgoto out;\n\t}\n\n\tif (c->state & CONFIG_LOCKED) {\n\t\tdev_dbg(&p_dev->dev, \"Configuration is locked\\n\");\n\t\tgoto out;\n\t}\n\tif (c->state & CONFIG_IO_REQ) {\n\t\tdev_dbg(&p_dev->dev, \"IO already configured\\n\");\n\t\tgoto out;\n\t}\n\n\tret = alloc_io_space(s, &c->io[0], p_dev->io_lines);\n\tif (ret)\n\t\tgoto out;\n\n\tif (c->io[1].end) {\n\t\tret = alloc_io_space(s, &c->io[1], p_dev->io_lines);\n\t\tif (ret) {\n\t\t\tstruct resource tmp = c->io[0];\n\t\t\t \n\t\t\trelease_io_space(s, &c->io[0]);\n\t\t\t \n\t\t\tc->io[0].end = resource_size(&tmp);\n\t\t\tc->io[0].start = tmp.start;\n\t\t\tc->io[0].flags = tmp.flags;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tc->io[1].start = 0;\n\n\tc->state |= CONFIG_IO_REQ;\n\tp_dev->_io = 1;\n\n\tdev_dbg(&p_dev->dev, \"pcmcia_request_io succeeded: %pR , %pR\",\n\t\t&c->io[0], &c->io[1]);\nout:\n\tmutex_unlock(&s->ops_mutex);\n\n\treturn ret;\n}  \nEXPORT_SYMBOL(pcmcia_request_io);\n\n\n \nint __must_check pcmcia_request_irq(struct pcmcia_device *p_dev,\n\t\t\t\t    irq_handler_t handler)\n{\n\tint ret;\n\n\tif (!p_dev->irq)\n\t\treturn -EINVAL;\n\n\tret = request_irq(p_dev->irq, handler, IRQF_SHARED,\n\t\t\tp_dev->devname, p_dev->priv);\n\tif (!ret)\n\t\tp_dev->_irq = 1;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(pcmcia_request_irq);\n\n\n#ifdef CONFIG_PCMCIA_PROBE\n\n \nstatic u8 pcmcia_used_irq[32];\n\nstatic irqreturn_t test_action(int cpl, void *dev_id)\n{\n\treturn IRQ_NONE;\n}\n\n \nstatic int pcmcia_setup_isa_irq(struct pcmcia_device *p_dev, int type)\n{\n\tstruct pcmcia_socket *s = p_dev->socket;\n\tunsigned int try, irq;\n\tu32 mask = s->irq_mask;\n\tint ret = -ENODEV;\n\n\tfor (try = 0; try < 64; try++) {\n\t\tirq = try % 32;\n\n\t\tif (irq > NR_IRQS)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!((mask >> irq) & 1))\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((try < 32) && pcmcia_used_irq[irq])\n\t\t\tcontinue;\n\n\t\t \n\t\tret = request_irq(irq, test_action, type, p_dev->devname,\n\t\t\t\t  p_dev);\n\t\tif (!ret) {\n\t\t\tfree_irq(irq, p_dev);\n\t\t\tp_dev->irq = s->pcmcia_irq = irq;\n\t\t\tpcmcia_used_irq[irq]++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid pcmcia_cleanup_irq(struct pcmcia_socket *s)\n{\n\tpcmcia_used_irq[s->pcmcia_irq]--;\n\ts->pcmcia_irq = 0;\n}\n\n#else  \n\nstatic int pcmcia_setup_isa_irq(struct pcmcia_device *p_dev, int type)\n{\n\treturn -EINVAL;\n}\n\nvoid pcmcia_cleanup_irq(struct pcmcia_socket *s)\n{\n\ts->pcmcia_irq = 0;\n\treturn;\n}\n\n#endif   \n\n\n \nint pcmcia_setup_irq(struct pcmcia_device *p_dev)\n{\n\tstruct pcmcia_socket *s = p_dev->socket;\n\n\tif (p_dev->irq)\n\t\treturn 0;\n\n\t \n\tif (s->pcmcia_irq) {\n\t\tp_dev->irq = s->pcmcia_irq;\n\t\treturn 0;\n\t}\n\n\t \n\tif (!pcmcia_setup_isa_irq(p_dev, 0))\n\t\treturn 0;\n\n\t \n\tif (!pcmcia_setup_isa_irq(p_dev, IRQF_SHARED))\n\t\treturn 0;\n\n\t \n\tif (s->pci_irq) {\n\t\tp_dev->irq = s->pcmcia_irq = s->pci_irq;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n\n \nint pcmcia_request_window(struct pcmcia_device *p_dev, struct resource *res,\n\t\t\tunsigned int speed)\n{\n\tstruct pcmcia_socket *s = p_dev->socket;\n\tpccard_mem_map *win;\n\tu_long align;\n\tint w;\n\n\tdev_dbg(&p_dev->dev, \"request_window %pR %d\\n\", res, speed);\n\n\tif (!(s->state & SOCKET_PRESENT)) {\n\t\tdev_dbg(&p_dev->dev, \"No card present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (res->end == 0)\n\t\tres->end = s->map_size;\n\talign = (s->features & SS_CAP_MEM_ALIGN) ? res->end : s->map_size;\n\tif (res->end & (s->map_size-1)) {\n\t\tdev_dbg(&p_dev->dev, \"invalid map size\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((res->start && (s->features & SS_CAP_STATIC_MAP)) ||\n\t    (res->start & (align-1))) {\n\t\tdev_dbg(&p_dev->dev, \"invalid base address\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (res->start)\n\t\talign = 0;\n\n\t \n\tmutex_lock(&s->ops_mutex);\n\tfor (w = 0; w < MAX_WIN; w++)\n\t\tif (!(s->state & SOCKET_WIN_REQ(w)))\n\t\t\tbreak;\n\tif (w == MAX_WIN) {\n\t\tdev_dbg(&p_dev->dev, \"all windows are used already\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\twin = &s->win[w];\n\n\tif (!(s->features & SS_CAP_STATIC_MAP)) {\n\t\twin->res = pcmcia_find_mem_region(res->start, res->end, align,\n\t\t\t\t\t\t0, s);\n\t\tif (!win->res) {\n\t\t\tdev_dbg(&p_dev->dev, \"allocating mem region failed\\n\");\n\t\t\tmutex_unlock(&s->ops_mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tp_dev->_win |= CLIENT_WIN_REQ(w);\n\n\t \n\twin->map = w+1;\n\twin->flags = res->flags & WIN_FLAGS_MAP;\n\twin->speed = speed;\n\twin->card_start = 0;\n\n\tif (s->ops->set_mem_map(s, win) != 0) {\n\t\tdev_dbg(&p_dev->dev, \"failed to set memory mapping\\n\");\n\t\tmutex_unlock(&s->ops_mutex);\n\t\treturn -EIO;\n\t}\n\ts->state |= SOCKET_WIN_REQ(w);\n\n\t \n\tif (s->features & SS_CAP_STATIC_MAP)\n\t\tres->start = win->static_start;\n\telse\n\t\tres->start = win->res->start;\n\n\t \n\tres->end += res->start - 1;\n\tres->flags &= ~WIN_FLAGS_REQ;\n\tres->flags |= (win->map << 2) | IORESOURCE_MEM;\n\tres->parent = win->res;\n\tif (win->res)\n\t\trequest_resource(&iomem_resource, res);\n\n\tdev_dbg(&p_dev->dev, \"request_window results in %pR\\n\", res);\n\n\tmutex_unlock(&s->ops_mutex);\n\n\treturn 0;\n}  \nEXPORT_SYMBOL(pcmcia_request_window);\n\n\n \nvoid pcmcia_disable_device(struct pcmcia_device *p_dev)\n{\n\tint i;\n\n\tdev_dbg(&p_dev->dev, \"disabling device\\n\");\n\n\tfor (i = 0; i < MAX_WIN; i++) {\n\t\tstruct resource *res = p_dev->resource[MAX_IO_WIN + i];\n\t\tif (res->flags & WIN_FLAGS_REQ)\n\t\t\tpcmcia_release_window(p_dev, res);\n\t}\n\n\tpcmcia_release_configuration(p_dev);\n\tpcmcia_release_io(p_dev);\n\tif (p_dev->_irq) {\n\t\tfree_irq(p_dev->irq, p_dev->priv);\n\t\tp_dev->_irq = 0;\n\t}\n}\nEXPORT_SYMBOL(pcmcia_disable_device);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}