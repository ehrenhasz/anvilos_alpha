{
  "module_name": "rsrc_iodyn.c",
  "hash_id": "374095d5eb215386b0f99842543a5911d3c28fc181f415e42d6e47d89c6acb93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/rsrc_iodyn.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include <pcmcia/ss.h>\n#include <pcmcia/cistpl.h>\n#include \"cs_internal.h\"\n\n\nstruct pcmcia_align_data {\n\tunsigned long\tmask;\n\tunsigned long\toffset;\n};\n\nstatic resource_size_t pcmcia_align(void *align_data,\n\t\t\t\tconst struct resource *res,\n\t\t\t\tresource_size_t size, resource_size_t align)\n{\n\tstruct pcmcia_align_data *data = align_data;\n\tresource_size_t start;\n\n\tstart = (res->start & ~data->mask) + data->offset;\n\tif (start < res->start)\n\t\tstart += data->mask + 1;\n\n#ifdef CONFIG_X86\n\tif (res->flags & IORESOURCE_IO) {\n\t\tif (start & 0x300)\n\t\t\tstart = (start + 0x3ff) & ~0x3ff;\n\t}\n#endif\n\n#ifdef CONFIG_M68K\n\tif (res->flags & IORESOURCE_IO) {\n\t\tif ((res->start + size - 1) >= 1024)\n\t\t\tstart = res->end;\n\t}\n#endif\n\n\treturn start;\n}\n\n\nstatic struct resource *__iodyn_find_io_region(struct pcmcia_socket *s,\n\t\t\t\t\tunsigned long base, int num,\n\t\t\t\t\tunsigned long align)\n{\n\tstruct resource *res = pcmcia_make_resource(0, num, IORESOURCE_IO,\n\t\t\t\t\t\tdev_name(&s->dev));\n\tstruct pcmcia_align_data data;\n\tunsigned long min = base;\n\tint ret;\n\n\tdata.mask = align - 1;\n\tdata.offset = base & data.mask;\n\n#ifdef CONFIG_PCI\n\tif (s->cb_dev) {\n\t\tret = pci_bus_alloc_resource(s->cb_dev->bus, res, num, 1,\n\t\t\t\t\t     min, 0, pcmcia_align, &data);\n\t} else\n#endif\n\t\tret = allocate_resource(&ioport_resource, res, num, min, ~0UL,\n\t\t\t\t\t1, pcmcia_align, &data);\n\n\tif (ret != 0) {\n\t\tkfree(res);\n\t\tres = NULL;\n\t}\n\treturn res;\n}\n\nstatic int iodyn_find_io(struct pcmcia_socket *s, unsigned int attr,\n\t\t\tunsigned int *base, unsigned int num,\n\t\t\tunsigned int align, struct resource **parent)\n{\n\tint i, ret = 0;\n\n\t \n\tfor (i = 0; i < MAX_IO_WIN; i++) {\n\t\tif (!s->io[i].res)\n\t\t\tcontinue;\n\n\t\tif (!*base)\n\t\t\tcontinue;\n\n\t\tif ((s->io[i].res->start & (align-1)) == *base)\n\t\t\treturn -EBUSY;\n\t}\n\n\tfor (i = 0; i < MAX_IO_WIN; i++) {\n\t\tstruct resource *res = s->io[i].res;\n\t\tunsigned int try;\n\n\t\tif (res && (res->flags & IORESOURCE_BITS) !=\n\t\t\t(attr & IORESOURCE_BITS))\n\t\t\tcontinue;\n\n\t\tif (!res) {\n\t\t\tif (align == 0)\n\t\t\t\talign = 0x10000;\n\n\t\t\tres = s->io[i].res = __iodyn_find_io_region(s, *base,\n\t\t\t\t\t\t\t\tnum, align);\n\t\t\tif (!res)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t*base = res->start;\n\t\t\ts->io[i].res->flags =\n\t\t\t\t((res->flags & ~IORESOURCE_BITS) |\n\t\t\t\t\t(attr & IORESOURCE_BITS));\n\t\t\ts->io[i].InUse = num;\n\t\t\t*parent = res;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\ttry = res->end + 1;\n\t\tif ((*base == 0) || (*base == try)) {\n\t\t\tif (adjust_resource(s->io[i].res, res->start,\n\t\t\t\t\t    resource_size(res) + num))\n\t\t\t\tcontinue;\n\t\t\t*base = try;\n\t\t\ts->io[i].InUse += num;\n\t\t\t*parent = res;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\ttry = res->start - num;\n\t\tif ((*base == 0) || (*base == try)) {\n\t\t\tif (adjust_resource(s->io[i].res,\n\t\t\t\t\t    res->start - num,\n\t\t\t\t\t    resource_size(res) + num))\n\t\t\t\tcontinue;\n\t\t\t*base = try;\n\t\t\ts->io[i].InUse += num;\n\t\t\t*parent = res;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n\nstruct pccard_resource_ops pccard_iodyn_ops = {\n\t.validate_mem = NULL,\n\t.find_io = iodyn_find_io,\n\t.find_mem = NULL,\n\t.init = static_init,\n\t.exit = NULL,\n};\nEXPORT_SYMBOL(pccard_iodyn_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}