{
  "module_name": "Kconfig",
  "hash_id": "acbb579afd487d7b35a3bc77ef93243d2f78dc6b90837da8387f7cbfcb52436a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# PCCARD (PCMCIA/CardBus) bus subsystem configuration\n#\n\nmenuconfig PCCARD\n\ttristate \"PCCard (PCMCIA/CardBus) support\"\n\thelp\n\t  Say Y here if you want to attach PCMCIA- or PC-cards to your Linux\n\t  computer.  These are credit-card size devices such as network cards,\n\t  modems or hard drives often used with laptops computers.  There are\n\t  actually two varieties of these cards: 16 bit PCMCIA and 32 bit\n\t  CardBus cards.\n\n\t  To compile this driver as modules, choose M here: the\n\t  module will be called pcmcia_core.\n\nif PCCARD\n\nconfig PCMCIA\n\ttristate \"16-bit PCMCIA support\"\n\tdepends on HAS_IOMEM\n\tselect CRC32\n\tdefault y\n\thelp\n\t   This option enables support for 16-bit PCMCIA cards. Most older\n\t   PC-cards are such 16-bit PCMCIA cards, so unless you know you're\n\t   only using 32-bit CardBus cards, say Y or M here.\n\n\t   To use 16-bit PCMCIA cards, you will need supporting software in\n\t   most cases. (see the file <file:Documentation/Changes> for\n\t   location and details).\n\n\t   To compile this driver as modules, choose M here: the\n\t   module will be called pcmcia.\n\n\t   If unsure, say Y.\n\nconfig PCMCIA_LOAD_CIS\n\tbool \"Load CIS updates from userspace\"\n\tdepends on PCMCIA\n\tselect FW_LOADER\n\tdefault y\n\thelp\n\t  Some PCMCIA cards require an updated Card Information Structure (CIS)\n\t  to be loaded from userspace to work correctly. If you say Y here,\n\t  and your userspace is arranged correctly, this will be loaded\n\t  automatically using the in-kernel firmware loader and the hotplug\n\t  subsystem, instead of relying on cardmgr from pcmcia-cs to do so.\n\n\t  If unsure, say Y.\n\nconfig CARDBUS\n\tbool \"32-bit CardBus support\"\n\tdepends on PCI\n\tdefault y\n\thelp\n\t  CardBus is a bus mastering architecture for PC-cards, which allows\n\t  for 32 bit PC-cards (the original PCMCIA standard specifies only\n\t  a 16 bit wide bus). Many newer PC-cards are actually CardBus cards.\n\n\t  To use 32 bit PC-cards, you also need a CardBus compatible host\n\t  bridge. Virtually all modern PCMCIA bridges do this, and most of\n\t  them are \"yenta-compatible\", so say Y or M there, too.\n\n\t  If unsure, say Y.\n\nconfig PCMCIA_MAX1600\n\ttristate\n\ncomment \"PC-card bridges\"\n\nconfig YENTA\n\ttristate \"CardBus yenta-compatible bridge support\"\n\tdepends on PCI\n\tselect CARDBUS if !EXPERT\n\tselect PCCARD_NONSTATIC if PCMCIA != n\n\thelp\n\t  This option enables support for CardBus host bridges.  Virtually\n\t  all modern PCMCIA bridges are CardBus compatible.  A \"bridge\" is\n\t  the hardware inside your computer that PCMCIA cards are plugged\n\t  into.\n\n\t  To compile this driver as modules, choose M here: the\n\t  module will be called yenta_socket.\n\n\t  If unsure, say Y.\n\nconfig YENTA_O2\n\tdefault y\n\tbool \"Special initialization for O2Micro bridges\" if EXPERT\n\tdepends on YENTA\n\nconfig YENTA_RICOH\n\tdefault y\n\tbool \"Special initialization for Ricoh bridges\" if EXPERT\n\tdepends on YENTA\n\nconfig YENTA_TI\n\tdefault y\n\tbool \"Special initialization for TI and EnE bridges\" if EXPERT\n\tdepends on YENTA\n\nconfig YENTA_ENE_TUNE\n\tdefault y\n\tbool \"Auto-tune EnE bridges for CB cards\" if EXPERT\n\tdepends on YENTA_TI && CARDBUS\n\nconfig YENTA_TOSHIBA\n\tdefault y\n\tbool \"Special initialization for Toshiba ToPIC bridges\" if EXPERT\n\tdepends on YENTA\n\nconfig PD6729\n\ttristate \"Cirrus PD6729 compatible bridge support\"\n\tdepends on PCMCIA && PCI && HAS_IOPORT\n\tselect PCCARD_NONSTATIC\n\thelp\n\t  This provides support for the Cirrus PD6729 PCI-to-PCMCIA bridge\n\t  device, found in some older laptops and PCMCIA card readers.\n\nconfig I82092\n\ttristate \"i82092 compatible bridge support\"\n\tdepends on PCMCIA && PCI && HAS_IOPORT\n\tselect PCCARD_NONSTATIC\n\thelp\n\t  This provides support for the Intel I82092AA PCI-to-PCMCIA bridge device,\n\t  found in some older laptops and more commonly in evaluation boards for the\n\t  chip.\n\nconfig I82365\n\ttristate \"i82365 compatible bridge support\"\n\tdepends on PCMCIA && ISA\n\tselect PCCARD_NONSTATIC\n\thelp\n\t  Say Y here to include support for ISA-bus PCMCIA host bridges that\n\t  are register compatible with the Intel i82365.  These are found on\n\t  older laptops and ISA-bus card readers for desktop systems.  A\n\t  \"bridge\" is the hardware inside your computer that PCMCIA cards are\n\t  plugged into. If unsure, say N.\n\nconfig TCIC\n\ttristate \"Databook TCIC host bridge support\"\n\tdepends on PCMCIA && ISA\n\tselect PCCARD_NONSTATIC\n\thelp\n\t  Say Y here to include support for the Databook TCIC family of PCMCIA\n\t  host bridges. These are only found on a handful of old systems.\n\t  \"Bridge\" is the name used for the hardware inside your computer that\n\t  PCMCIA cards are plugged into. If unsure, say N.\n\nconfig PCMCIA_ALCHEMY_DEVBOARD\n\ttristate \"Alchemy Db/Pb1xxx PCMCIA socket services\"\n\tdepends on MIPS_DB1XXX && PCMCIA\n\thelp\n\t  Enable this driver of you want PCMCIA support on your Alchemy\n\t  Db1000, Db/Pb1100, Db/Pb1500, Db/Pb1550, Db/Pb1200, DB1300\n\t  board.  NOT suitable for the PB1000!\n\n\t  This driver is also available as a module called db1xxx_ss.ko\n\nconfig PCMCIA_XXS1500\n\ttristate \"MyCable XXS1500 PCMCIA socket support\"\n\tdepends on PCMCIA && MIPS_XXS1500\n\thelp\n\t  Support for the PCMCIA/CF socket interface on MyCable XXS1500\n\t  systems.\n\n\t  This driver is also available as a module called xxs1500_ss.ko\n\nconfig PCMCIA_BCM63XX\n\ttristate \"bcm63xx pcmcia support\"\n\tdepends on BCM63XX && PCMCIA\n\nconfig PCMCIA_SOC_COMMON\n\ttristate\n\nconfig PCMCIA_SA11XX_BASE\n\ttristate\n\nconfig PCMCIA_SA1100\n\ttristate \"SA1100 support\"\n\tdepends on ARM && ARCH_SA1100 && PCMCIA\n\tselect PCMCIA_SOC_COMMON\n\tselect PCMCIA_SA11XX_BASE\n\thelp\n\t  Say Y here to include support for SA11x0-based PCMCIA or CF\n\t  sockets, found on HP iPAQs, Yopy, and other StrongARM(R)/\n\t  Xscale(R) embedded machines.\n\n\t  This driver is also available as a module called sa1100_cs.\n\nconfig PCMCIA_SA1111\n\ttristate \"SA1111 support\"\n\tdepends on ARM && SA1111 && PCMCIA\n\tselect PCMCIA_SOC_COMMON\n\tselect PCMCIA_SA11XX_BASE\n\tselect PCMCIA_MAX1600 if ASSABET_NEPONSET\n\thelp\n\t  Say Y  here to include support for SA1111-based PCMCIA or CF\n\t  sockets, found on the Jornada 720, Graphicsmaster and other\n\t  StrongARM(R)/Xscale(R) embedded machines.\n\n\t  This driver is also available as a module called sa1111_cs.\n\nconfig PCMCIA_PXA2XX\n\ttristate \"PXA2xx support\"\n\tdepends on ARM && ARCH_PXA && PCMCIA && PXA_SHARPSL\n\tselect PCMCIA_SOC_COMMON\n\thelp\n\t  Say Y here to include support for the PXA2xx PCMCIA controller\n\nconfig PCMCIA_DEBUG\n\tbool \"Enable debugging\"\n\tdepends on (PCMCIA_SA1111 || PCMCIA_SA1100 || PCMCIA_PXA2XX)\n\thelp\n\t  Say Y here to enable debugging for the SoC PCMCIA layer.\n\t  You will need to choose the debugging level either via the\n\t  kernel command line, or module options depending whether\n\t  you build the drivers as modules.\n\n\t  The kernel command line options are:\n\t    sa11xx_core.pc_debug=N\n\t    pxa2xx_core.pc_debug=N\n\n\t  The module option is called pc_debug=N\n\n\t  In all the above examples, N is the debugging verbosity\n\t  level.\n\nconfig PCMCIA_PROBE\n\tbool\n\tdefault y if ISA && !ARCH_SA1100 && !PARISC\n\nconfig OMAP_CF\n\ttristate \"OMAP CompactFlash Controller\"\n\tdepends on PCMCIA\n\tdepends on ARCH_OMAP16XX || (ARM && COMPILE_TEST)\n\thelp\n\t  Say Y here to support the CompactFlash controller on OMAP.\n\t  Note that this doesn't support \"True IDE\" mode.\n\nconfig ELECTRA_CF\n\ttristate \"Electra CompactFlash Controller\"\n\tdepends on PCMCIA && PPC_PASEMI\n\thelp\n\t  Say Y here to support the CompactFlash controller on the\n\t  PA Semi Electra eval board.\n\nconfig PCCARD_NONSTATIC\n\tbool\n\nconfig PCCARD_IODYN\n\tbool\n\nendif\t# PCCARD\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}