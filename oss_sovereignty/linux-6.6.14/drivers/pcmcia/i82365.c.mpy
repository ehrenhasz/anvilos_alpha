{
  "module_name": "i82365.c",
  "hash_id": "eaf949e9a6fa2aa4abf4f38de561ef0e12f087752510fcea64c19252d71c088b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/i82365.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/bitops.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n\n#include <pcmcia/ss.h>\n\n#include <linux/isapnp.h>\n\n \n#include \"i82365.h\"\n#include \"cirrus.h\"\n#include \"vg468.h\"\n#include \"ricoh.h\"\n\n\nstatic irqreturn_t i365_count_irq(int, void *);\nstatic inline int _check_irq(int irq, int flags)\n{\n    if (request_irq(irq, i365_count_irq, flags, \"x\", i365_count_irq) != 0)\n\treturn -1;\n    free_irq(irq, i365_count_irq);\n    return 0;\n}\n\n \n\n \n\n \nstatic unsigned long i365_base = 0x3e0;\n \nstatic int extra_sockets = 0;\n \nstatic int ignore = -1;\n \nstatic u_int irq_mask = 0xffff;\nstatic int irq_list[16];\nstatic unsigned int irq_list_count;\n \nstatic int cs_irq = 0;\n\n \nstatic int do_scan = 1;\n \nstatic int poll_interval = 0;\n \nstatic int cycle_time = 120;\n\n \nstatic int has_dma = -1;\nstatic int has_led = -1;\nstatic int has_ring = -1;\nstatic int dynamic_mode = 0;\nstatic int freq_bypass = -1;\nstatic int setup_time = -1;\nstatic int cmd_time = -1;\nstatic int recov_time = -1;\n\n \nstatic int async_clock = -1;\nstatic int cable_mode = -1;\nstatic int wakeup = 0;\n\nmodule_param_hw(i365_base, ulong, ioport, 0444);\nmodule_param(ignore, int, 0444);\nmodule_param(extra_sockets, int, 0444);\nmodule_param_hw(irq_mask, int, other, 0444);\nmodule_param_hw_array(irq_list, int, irq, &irq_list_count, 0444);\nmodule_param_hw(cs_irq, int, irq, 0444);\nmodule_param(async_clock, int, 0444);\nmodule_param(cable_mode, int, 0444);\nmodule_param(wakeup, int, 0444);\n\nmodule_param(do_scan, int, 0444);\nmodule_param(poll_interval, int, 0444);\nmodule_param(cycle_time, int, 0444);\nmodule_param(has_dma, int, 0444);\nmodule_param(has_led, int, 0444);\nmodule_param(has_ring, int, 0444);\nmodule_param(dynamic_mode, int, 0444);\nmodule_param(freq_bypass, int, 0444);\nmodule_param(setup_time, int, 0444);\nmodule_param(cmd_time, int, 0444);\nmodule_param(recov_time, int, 0444);\n\n \n\nstruct cirrus_state {\n    u_char\t\tmisc1, misc2;\n    u_char\t\ttimer[6];\n};\n\nstruct vg46x_state {\n    u_char\t\tctl, ema;\n};\n\nstruct i82365_socket {\n    u_short\t\ttype, flags;\n    struct pcmcia_socket\tsocket;\n    unsigned int\tnumber;\n    unsigned int\tioaddr;\n    u_short\t\tpsock;\n    u_char\t\tcs_irq, intr;\n    union {\n\tstruct cirrus_state\t\tcirrus;\n\tstruct vg46x_state\t\tvg46x;\n    } state;\n};\n\n \nstatic int sockets = 0;\nstatic struct i82365_socket socket[8] = {\n    { 0, },  \n};\n\n \n#define I365_MASK\t0xdeb8\t \n\nstatic int grab_irq;\nstatic DEFINE_SPINLOCK(isa_lock);\n#define ISA_LOCK(n, f) spin_lock_irqsave(&isa_lock, f)\n#define ISA_UNLOCK(n, f) spin_unlock_irqrestore(&isa_lock, f)\n\nstatic struct timer_list poll_timer;\n\n \n\n \nenum pcic_id {\n    IS_I82365A, IS_I82365B, IS_I82365DF,\n    IS_IBM, IS_RF5Cx96, IS_VLSI, IS_VG468, IS_VG469,\n    IS_PD6710, IS_PD672X, IS_VT83C469,\n};\n\n \n#define IS_VADEM\t0x0001\n#define IS_CIRRUS\t0x0002\n#define IS_VIA\t\t0x0010\n#define IS_UNKNOWN\t0x0400\n#define IS_VG_PWR\t0x0800\n#define IS_DF_PWR\t0x1000\n#define IS_REGISTERED\t0x2000\n#define IS_ALIVE\t0x8000\n\nstruct pcic {\n    char\t\t*name;\n    u_short\t\tflags;\n};\n\nstatic struct pcic pcic[] = {\n    { \"Intel i82365sl A step\", 0 },\n    { \"Intel i82365sl B step\", 0 },\n    { \"Intel i82365sl DF\", IS_DF_PWR },\n    { \"IBM Clone\", 0 },\n    { \"Ricoh RF5C296/396\", 0 },\n    { \"VLSI 82C146\", 0 },\n    { \"Vadem VG-468\", IS_VADEM },\n    { \"Vadem VG-469\", IS_VADEM|IS_VG_PWR },\n    { \"Cirrus PD6710\", IS_CIRRUS },\n    { \"Cirrus PD672x\", IS_CIRRUS },\n    { \"VIA VT83C469\", IS_CIRRUS|IS_VIA },\n};\n\n#define PCIC_COUNT\tARRAY_SIZE(pcic)\n\n \n\nstatic DEFINE_SPINLOCK(bus_lock);\n\nstatic u_char i365_get(u_short sock, u_short reg)\n{\n    unsigned long flags;\n    spin_lock_irqsave(&bus_lock,flags);\n    {\n\tunsigned int port = socket[sock].ioaddr;\n\tu_char val;\n\treg = I365_REG(socket[sock].psock, reg);\n\toutb(reg, port); val = inb(port+1);\n\tspin_unlock_irqrestore(&bus_lock,flags);\n\treturn val;\n    }\n}\n\nstatic void i365_set(u_short sock, u_short reg, u_char data)\n{\n    unsigned long flags;\n    spin_lock_irqsave(&bus_lock,flags);\n    {\n\tunsigned int port = socket[sock].ioaddr;\n\tu_char val = I365_REG(socket[sock].psock, reg);\n\toutb(val, port); outb(data, port+1);\n\tspin_unlock_irqrestore(&bus_lock,flags);\n    }\n}\n\nstatic void i365_bset(u_short sock, u_short reg, u_char mask)\n{\n    u_char d = i365_get(sock, reg);\n    d |= mask;\n    i365_set(sock, reg, d);\n}\n\nstatic void i365_bclr(u_short sock, u_short reg, u_char mask)\n{\n    u_char d = i365_get(sock, reg);\n    d &= ~mask;\n    i365_set(sock, reg, d);\n}\n\nstatic void i365_bflip(u_short sock, u_short reg, u_char mask, int b)\n{\n    u_char d = i365_get(sock, reg);\n    if (b)\n\td |= mask;\n    else\n\td &= ~mask;\n    i365_set(sock, reg, d);\n}\n\nstatic u_short i365_get_pair(u_short sock, u_short reg)\n{\n    u_short a, b;\n    a = i365_get(sock, reg);\n    b = i365_get(sock, reg+1);\n    return (a + (b<<8));\n}\n\nstatic void i365_set_pair(u_short sock, u_short reg, u_short data)\n{\n    i365_set(sock, reg, data & 0xff);\n    i365_set(sock, reg+1, data >> 8);\n}\n\n \n\n#define flip(v,b,f) (v = ((f)<0) ? v : ((f) ? ((v)|(b)) : ((v)&(~b))))\n\nstatic void cirrus_get_state(u_short s)\n{\n    int i;\n    struct cirrus_state *p = &socket[s].state.cirrus;\n    p->misc1 = i365_get(s, PD67_MISC_CTL_1);\n    p->misc1 &= (PD67_MC1_MEDIA_ENA | PD67_MC1_INPACK_ENA);\n    p->misc2 = i365_get(s, PD67_MISC_CTL_2);\n    for (i = 0; i < 6; i++)\n\tp->timer[i] = i365_get(s, PD67_TIME_SETUP(0)+i);\n}\n\nstatic void cirrus_set_state(u_short s)\n{\n    int i;\n    u_char misc;\n    struct cirrus_state *p = &socket[s].state.cirrus;\n\n    misc = i365_get(s, PD67_MISC_CTL_2);\n    i365_set(s, PD67_MISC_CTL_2, p->misc2);\n    if (misc & PD67_MC2_SUSPEND) mdelay(50);\n    misc = i365_get(s, PD67_MISC_CTL_1);\n    misc &= ~(PD67_MC1_MEDIA_ENA | PD67_MC1_INPACK_ENA);\n    i365_set(s, PD67_MISC_CTL_1, misc | p->misc1);\n    for (i = 0; i < 6; i++)\n\ti365_set(s, PD67_TIME_SETUP(0)+i, p->timer[i]);\n}\n\nstatic u_int __init cirrus_set_opts(u_short s, char *buf)\n{\n    struct i82365_socket *t = &socket[s];\n    struct cirrus_state *p = &socket[s].state.cirrus;\n    u_int mask = 0xffff;\n\n    if (has_ring == -1) has_ring = 1;\n    flip(p->misc2, PD67_MC2_IRQ15_RI, has_ring);\n    flip(p->misc2, PD67_MC2_DYNAMIC_MODE, dynamic_mode);\n    flip(p->misc2, PD67_MC2_FREQ_BYPASS, freq_bypass);\n    if (p->misc2 & PD67_MC2_IRQ15_RI)\n\tstrcat(buf, \" [ring]\");\n    if (p->misc2 & PD67_MC2_DYNAMIC_MODE)\n\tstrcat(buf, \" [dyn mode]\");\n    if (p->misc2 & PD67_MC2_FREQ_BYPASS)\n\tstrcat(buf, \" [freq bypass]\");\n    if (p->misc1 & PD67_MC1_INPACK_ENA)\n\tstrcat(buf, \" [inpack]\");\n    if (p->misc2 & PD67_MC2_IRQ15_RI)\n\tmask &= ~0x8000;\n    if (has_led > 0) {\n\tstrcat(buf, \" [led]\");\n\tmask &= ~0x1000;\n    }\n    if (has_dma > 0) {\n\tstrcat(buf, \" [dma]\");\n\tmask &= ~0x0600;\n    }\n    if (!(t->flags & IS_VIA)) {\n\tif (setup_time >= 0)\n\t    p->timer[0] = p->timer[3] = setup_time;\n\tif (cmd_time > 0) {\n\t    p->timer[1] = cmd_time;\n\t    p->timer[4] = cmd_time*2+4;\n\t}\n\tif (p->timer[1] == 0) {\n\t    p->timer[1] = 6; p->timer[4] = 16;\n\t    if (p->timer[0] == 0)\n\t\tp->timer[0] = p->timer[3] = 1;\n\t}\n\tif (recov_time >= 0)\n\t    p->timer[2] = p->timer[5] = recov_time;\n\tbuf += strlen(buf);\n\tsprintf(buf, \" [%d/%d/%d] [%d/%d/%d]\", p->timer[0], p->timer[1],\n\t\tp->timer[2], p->timer[3], p->timer[4], p->timer[5]);\n    }\n    return mask;\n}\n\n \n\nstatic void vg46x_get_state(u_short s)\n{\n    struct vg46x_state *p = &socket[s].state.vg46x;\n    p->ctl = i365_get(s, VG468_CTL);\n    if (socket[s].type == IS_VG469)\n\tp->ema = i365_get(s, VG469_EXT_MODE);\n}\n\nstatic void vg46x_set_state(u_short s)\n{\n    struct vg46x_state *p = &socket[s].state.vg46x;\n    i365_set(s, VG468_CTL, p->ctl);\n    if (socket[s].type == IS_VG469)\n\ti365_set(s, VG469_EXT_MODE, p->ema);\n}\n\nstatic u_int __init vg46x_set_opts(u_short s, char *buf)\n{\n    struct vg46x_state *p = &socket[s].state.vg46x;\n    \n    flip(p->ctl, VG468_CTL_ASYNC, async_clock);\n    flip(p->ema, VG469_MODE_CABLE, cable_mode);\n    if (p->ctl & VG468_CTL_ASYNC)\n\tstrcat(buf, \" [async]\");\n    if (p->ctl & VG468_CTL_INPACK)\n\tstrcat(buf, \" [inpack]\");\n    if (socket[s].type == IS_VG469) {\n\tu_char vsel = i365_get(s, VG469_VSELECT);\n\tif (vsel & VG469_VSEL_EXT_STAT) {\n\t    strcat(buf, \" [ext mode]\");\n\t    if (vsel & VG469_VSEL_EXT_BUS)\n\t\tstrcat(buf, \" [isa buf]\");\n\t}\n\tif (p->ema & VG469_MODE_CABLE)\n\t    strcat(buf, \" [cable]\");\n\tif (p->ema & VG469_MODE_COMPAT)\n\t    strcat(buf, \" [c step]\");\n    }\n    return 0xffff;\n}\n\n \n\nstatic void get_bridge_state(u_short s)\n{\n    struct i82365_socket *t = &socket[s];\n    if (t->flags & IS_CIRRUS)\n\tcirrus_get_state(s);\n    else if (t->flags & IS_VADEM)\n\tvg46x_get_state(s);\n}\n\nstatic void set_bridge_state(u_short s)\n{\n    struct i82365_socket *t = &socket[s];\n    if (t->flags & IS_CIRRUS)\n\tcirrus_set_state(s);\n    else {\n\ti365_set(s, I365_GBLCTL, 0x00);\n\ti365_set(s, I365_GENCTL, 0x00);\n    }\n    i365_bflip(s, I365_INTCTL, I365_INTR_ENA, t->intr);\n    if (t->flags & IS_VADEM)\n\tvg46x_set_state(s);\n}\n\nstatic u_int __init set_bridge_opts(u_short s, u_short ns)\n{\n    u_short i;\n    u_int m = 0xffff;\n    char buf[128];\n\n    for (i = s; i < s+ns; i++) {\n\tif (socket[i].flags & IS_ALIVE) {\n\t    printk(KERN_INFO \"    host opts [%d]: already alive!\\n\", i);\n\t    continue;\n\t}\n\tbuf[0] = '\\0';\n\tget_bridge_state(i);\n\tif (socket[i].flags & IS_CIRRUS)\n\t    m = cirrus_set_opts(i, buf);\n\telse if (socket[i].flags & IS_VADEM)\n\t    m = vg46x_set_opts(i, buf);\n\tset_bridge_state(i);\n\tprintk(KERN_INFO \"    host opts [%d]:%s\\n\", i,\n\t       (*buf) ? buf : \" none\");\n    }\n    return m;\n}\n\n \n\nstatic volatile u_int irq_hits;\nstatic u_short irq_sock;\n\nstatic irqreturn_t i365_count_irq(int irq, void *dev)\n{\n    i365_get(irq_sock, I365_CSC);\n    irq_hits++;\n    pr_debug(\"i82365: -> hit on irq %d\\n\", irq);\n    return IRQ_HANDLED;\n}\n\nstatic u_int __init test_irq(u_short sock, int irq)\n{\n    pr_debug(\"i82365:  testing ISA irq %d\\n\", irq);\n    if (request_irq(irq, i365_count_irq, IRQF_PROBE_SHARED, \"scan\",\n\t\t\ti365_count_irq) != 0)\n\treturn 1;\n    irq_hits = 0; irq_sock = sock;\n    msleep(10);\n    if (irq_hits) {\n\tfree_irq(irq, i365_count_irq);\n\tpr_debug(\"i82365:    spurious hit!\\n\");\n\treturn 1;\n    }\n\n     \n    i365_set(sock, I365_CSCINT, I365_CSC_DETECT | (irq << 4));\n    i365_bset(sock, I365_GENCTL, I365_CTL_SW_IRQ);\n    udelay(1000);\n\n    free_irq(irq, i365_count_irq);\n\n     \n    i365_set(sock, I365_CSCINT, 0);\n    pr_debug(\"i82365:    hits = %d\\n\", irq_hits);\n    \n    return (irq_hits != 1);\n}\n\nstatic u_int __init isa_scan(u_short sock, u_int mask0)\n{\n    u_int mask1 = 0;\n    int i;\n\n#ifdef __alpha__\n#define PIC 0x4d0\n     \n    mask0 &= ~(inb(PIC) | (inb(PIC+1) << 8));\n#endif\n    \n    if (do_scan) {\n\tset_bridge_state(sock);\n\ti365_set(sock, I365_CSCINT, 0);\n\tfor (i = 0; i < 16; i++)\n\t    if ((mask0 & (1 << i)) && (test_irq(sock, i) == 0))\n\t\tmask1 |= (1 << i);\n\tfor (i = 0; i < 16; i++)\n\t    if ((mask1 & (1 << i)) && (test_irq(sock, i) != 0))\n\t\tmask1 ^= (1 << i);\n    }\n    \n    printk(KERN_INFO \"    ISA irqs (\");\n    if (mask1) {\n\tprintk(\"scanned\");\n    } else {\n\t \n\tfor (i = 0; i < 16; i++)\n\t    if ((mask0 & (1 << i)) && (_check_irq(i, IRQF_PROBE_SHARED) == 0))\n\t\tmask1 |= (1 << i);\n\tprintk(\"default\");\n\t \n\tif (!cs_irq && (poll_interval == 0)) poll_interval = HZ;\n    }\n    printk(\") = \");\n    \n    for (i = 0; i < 16; i++)\n\tif (mask1 & (1<<i))\n\t    printk(\"%s%d\", ((mask1 & ((1<<i)-1)) ? \",\" : \"\"), i);\n    if (mask1 == 0) printk(\"none!\");\n    \n    return mask1;\n}\n\n \n\n \n\nstatic int to_cycles(int ns)\n{\n    return ns/cycle_time;\n}\n\n \n\nstatic int __init identify(unsigned int port, u_short sock)\n{\n    u_char val;\n    int type = -1;\n\n     \n    socket[sockets].ioaddr = port;\n    socket[sockets].psock = sock;\n    \n     \n    if (wakeup) {\n\ti365_bclr(sockets, PD67_MISC_CTL_2, PD67_MC2_SUSPEND);\n\t \n\tmdelay(50);\n    }\n    \n    if ((val = i365_get(sockets, I365_IDENT)) & 0x70)\n\treturn -1;\n    switch (val) {\n    case 0x82:\n\ttype = IS_I82365A; break;\n    case 0x83:\n\ttype = IS_I82365B; break;\n    case 0x84:\n\ttype = IS_I82365DF; break;\n    case 0x88: case 0x89: case 0x8a:\n\ttype = IS_IBM; break;\n    }\n    \n     \n    outb(0x0e, port);\n    outb(0x37, port);\n    i365_bset(sockets, VG468_MISC, VG468_MISC_VADEMREV);\n    val = i365_get(sockets, I365_IDENT);\n    if (val & I365_IDENT_VADEM) {\n\ti365_bclr(sockets, VG468_MISC, VG468_MISC_VADEMREV);\n\ttype = ((val & 7) >= 4) ? IS_VG469 : IS_VG468;\n    }\n\n     \n    val = i365_get(sockets, RF5C_CHIP_ID);\n    if ((val == RF5C_CHIP_RF5C296) || (val == RF5C_CHIP_RF5C396))\n\ttype = IS_RF5Cx96;\n    \n     \n    i365_set(sockets, PD67_CHIP_INFO, 0);\n    val = i365_get(sockets, PD67_CHIP_INFO);\n    if ((val & PD67_INFO_CHIP_ID) == PD67_INFO_CHIP_ID) {\n\tval = i365_get(sockets, PD67_CHIP_INFO);\n\tif ((val & PD67_INFO_CHIP_ID) == 0) {\n\t    type = (val & PD67_INFO_SLOTS) ? IS_PD672X : IS_PD6710;\n\t    i365_set(sockets, PD67_EXT_INDEX, 0xe5);\n\t    if (i365_get(sockets, PD67_EXT_INDEX) != 0xe5)\n\t\ttype = IS_VT83C469;\n\t}\n    }\n    return type;\n}  \n\n \n\nstatic int __init is_alive(u_short sock)\n{\n    u_char stat;\n    unsigned int start, stop;\n    \n    stat = i365_get(sock, I365_STATUS);\n    start = i365_get_pair(sock, I365_IO(0)+I365_W_START);\n    stop = i365_get_pair(sock, I365_IO(0)+I365_W_STOP);\n    if ((stat & I365_CS_DETECT) && (stat & I365_CS_POWERON) &&\n\t(i365_get(sock, I365_INTCTL) & I365_PC_IOCARD) &&\n\t(i365_get(sock, I365_ADDRWIN) & I365_ENA_IO(0)) &&\n\t((start & 0xfeef) != 0x02e8)) {\n\tif (!request_region(start, stop-start+1, \"i82365\"))\n\t    return 1;\n\trelease_region(start, stop-start+1);\n    }\n\n    return 0;\n}\n\n \n\nstatic void __init add_socket(unsigned int port, int psock, int type)\n{\n    socket[sockets].ioaddr = port;\n    socket[sockets].psock = psock;\n    socket[sockets].type = type;\n    socket[sockets].flags = pcic[type].flags;\n    if (is_alive(sockets))\n\tsocket[sockets].flags |= IS_ALIVE;\n    sockets++;\n}\n\nstatic void __init add_pcic(int ns, int type)\n{\n    u_int mask = 0, i, base;\n    int isa_irq = 0;\n    struct i82365_socket *t = &socket[sockets-ns];\n\n    base = sockets-ns;\n    if (base == 0) printk(\"\\n\");\n    printk(KERN_INFO \"  %s\", pcic[type].name);\n    printk(\" ISA-to-PCMCIA at port %#x ofs 0x%02x\",\n\t       t->ioaddr, t->psock*0x40);\n    printk(\", %d socket%s\\n\", ns, ((ns > 1) ? \"s\" : \"\"));\n\n     \n    if (irq_list_count == 0)\n\tmask = irq_mask;\n    else\n\tfor (i = mask = 0; i < irq_list_count; i++)\n\t    mask |= (1<<irq_list[i]);\n    mask &= I365_MASK & set_bridge_opts(base, ns);\n     \n    mask = isa_scan(base, mask);\n        \n     \n    if (!poll_interval) {\n\tu_int tmp = (mask & 0xff20);\n\ttmp = tmp & (tmp-1);\n\tif ((tmp & (tmp-1)) == 0)\n\t    poll_interval = HZ;\n    }\n     \n    if (!grab_irq && (cs_irq || !poll_interval)) {\n\t \n\tu_int cs_mask = mask & ((cs_irq) ? (1<<cs_irq) : ~(1<<12));\n\tfor (cs_irq = 15; cs_irq > 0; cs_irq--)\n\t    if ((cs_mask & (1 << cs_irq)) &&\n\t\t(_check_irq(cs_irq, IRQF_PROBE_SHARED) == 0))\n\t\tbreak;\n\tif (cs_irq) {\n\t    grab_irq = 1;\n\t    isa_irq = cs_irq;\n\t    printk(\" status change on irq %d\\n\", cs_irq);\n\t}\n    }\n    \n    if (!isa_irq) {\n\tif (poll_interval == 0)\n\t    poll_interval = HZ;\n\tprintk(\" polling interval = %d ms\\n\",\n\t       poll_interval * 1000 / HZ);\n\t\n    }\n    \n     \n    for (i = 0; i < ns; i++) {\n\tt[i].socket.features |= SS_CAP_PCCARD;\n\tt[i].socket.map_size = 0x1000;\n\tt[i].socket.irq_mask = mask;\n\tt[i].cs_irq = isa_irq;\n    }\n\n}  \n\n \n\n#ifdef CONFIG_PNP\nstatic struct isapnp_device_id id_table[] __initdata = {\n\t{ \tISAPNP_ANY_ID, ISAPNP_ANY_ID, ISAPNP_VENDOR('P', 'N', 'P'),\n\t\tISAPNP_FUNCTION(0x0e00), (unsigned long) \"Intel 82365-Compatible\" },\n\t{ \tISAPNP_ANY_ID, ISAPNP_ANY_ID, ISAPNP_VENDOR('P', 'N', 'P'),\n\t\tISAPNP_FUNCTION(0x0e01), (unsigned long) \"Cirrus Logic CL-PD6720\" },\n\t{ \tISAPNP_ANY_ID, ISAPNP_ANY_ID, ISAPNP_VENDOR('P', 'N', 'P'),\n\t\tISAPNP_FUNCTION(0x0e02), (unsigned long) \"VLSI VL82C146\" },\n\t{\t0 }\n};\nMODULE_DEVICE_TABLE(isapnp, id_table);\n\nstatic struct pnp_dev *i82365_pnpdev;\n#endif\n\nstatic void __init isa_probe(void)\n{\n    int i, j, sock, k, ns, id;\n    unsigned int port;\n#ifdef CONFIG_PNP\n    struct isapnp_device_id *devid;\n    struct pnp_dev *dev;\n\n    for (devid = id_table; devid->vendor; devid++) {\n\tif ((dev = pnp_find_dev(NULL, devid->vendor, devid->function, NULL))) {\n\t\n\t    if (pnp_device_attach(dev) < 0)\n\t    \tcontinue;\n\n\t    if (pnp_activate_dev(dev) < 0) {\n\t\tprintk(\"activate failed\\n\");\n\t\tpnp_device_detach(dev);\n\t\tbreak;\n\t    }\n\n\t    if (!pnp_port_valid(dev, 0)) {\n\t\tprintk(\"invalid resources ?\\n\");\n\t\tpnp_device_detach(dev);\n\t\tbreak;\n\t    }\n\t    i365_base = pnp_port_start(dev, 0);\n\t    i82365_pnpdev = dev;\n\t    break;\n\t}\n    }\n#endif\n\n    if (!request_region(i365_base, 2, \"i82365\")) {\n\tif (sockets == 0)\n\t    printk(\"port conflict at %#lx\\n\", i365_base);\n\treturn;\n    }\n\n    id = identify(i365_base, 0);\n    if ((id == IS_I82365DF) && (identify(i365_base, 1) != id)) {\n\tfor (i = 0; i < 4; i++) {\n\t    if (i == ignore) continue;\n\t    port = i365_base + ((i & 1) << 2) + ((i & 2) << 1);\n\t    sock = (i & 1) << 1;\n\t    if (identify(port, sock) == IS_I82365DF) {\n\t\tadd_socket(port, sock, IS_VLSI);\n\t\tadd_pcic(1, IS_VLSI);\n\t    }\n\t}\n    } else {\n\tfor (i = 0; i < 8; i += 2) {\n\t    if (sockets && !extra_sockets && (i == 4))\n\t\tbreak;\n\t    port = i365_base + 2*(i>>2);\n\t    sock = (i & 3);\n\t    id = identify(port, sock);\n\t    if (id < 0) continue;\n\n\t    for (j = ns = 0; j < 2; j++) {\n\t\t \n\t\tif ((ignore == i+j) || (identify(port, sock+j) < 0))\n\t\t    continue;\n\t\t \n\t\tfor (k = 0; k <= sockets; k++)\n\t\t    i365_set(k, I365_MEM(0)+I365_W_OFF, k);\n\t\tfor (k = 0; k <= sockets; k++)\n\t\t    if (i365_get(k, I365_MEM(0)+I365_W_OFF) != k)\n\t\t\tbreak;\n\t\tif (k <= sockets) break;\n\t\tadd_socket(port, sock+j, id); ns++;\n\t    }\n\t    if (ns != 0) add_pcic(ns, id);\n\t}\n    }\n}\n\n \n\nstatic irqreturn_t pcic_interrupt(int irq, void *dev)\n{\n    int i, j, csc;\n    u_int events, active;\n    u_long flags = 0;\n    int handled = 0;\n\n    pr_debug(\"pcic_interrupt(%d)\\n\", irq);\n\n    for (j = 0; j < 20; j++) {\n\tactive = 0;\n\tfor (i = 0; i < sockets; i++) {\n\t    if (socket[i].cs_irq != irq)\n\t\tcontinue;\n\t    handled = 1;\n\t    ISA_LOCK(i, flags);\n\t    csc = i365_get(i, I365_CSC);\n\t    if ((csc == 0) || (i365_get(i, I365_IDENT) & 0x70)) {\n\t\tISA_UNLOCK(i, flags);\n\t\tcontinue;\n\t    }\n\t    events = (csc & I365_CSC_DETECT) ? SS_DETECT : 0;\n\n\t    if (i365_get(i, I365_INTCTL) & I365_PC_IOCARD)\n\t\tevents |= (csc & I365_CSC_STSCHG) ? SS_STSCHG : 0;\n\t    else {\n\t\tevents |= (csc & I365_CSC_BVD1) ? SS_BATDEAD : 0;\n\t\tevents |= (csc & I365_CSC_BVD2) ? SS_BATWARN : 0;\n\t\tevents |= (csc & I365_CSC_READY) ? SS_READY : 0;\n\t    }\n\t    ISA_UNLOCK(i, flags);\n\t    pr_debug(\"socket %d event 0x%02x\\n\", i, events);\n\n\t    if (events)\n\t\tpcmcia_parse_events(&socket[i].socket, events);\n\n\t    active |= events;\n\t}\n\tif (!active) break;\n    }\n    if (j == 20)\n\tprintk(KERN_NOTICE \"i82365: infinite loop in interrupt handler\\n\");\n\n    pr_debug(\"pcic_interrupt done\\n\");\n    return IRQ_RETVAL(handled);\n}  \n\nstatic void pcic_interrupt_wrapper(struct timer_list *unused)\n{\n    pcic_interrupt(0, NULL);\n    poll_timer.expires = jiffies + poll_interval;\n    add_timer(&poll_timer);\n}\n\n \n\nstatic int i365_get_status(u_short sock, u_int *value)\n{\n    u_int status;\n    \n    status = i365_get(sock, I365_STATUS);\n    *value = ((status & I365_CS_DETECT) == I365_CS_DETECT)\n\t? SS_DETECT : 0;\n\t\n    if (i365_get(sock, I365_INTCTL) & I365_PC_IOCARD)\n\t*value |= (status & I365_CS_STSCHG) ? 0 : SS_STSCHG;\n    else {\n\t*value |= (status & I365_CS_BVD1) ? 0 : SS_BATDEAD;\n\t*value |= (status & I365_CS_BVD2) ? 0 : SS_BATWARN;\n    }\n    *value |= (status & I365_CS_WRPROT) ? SS_WRPROT : 0;\n    *value |= (status & I365_CS_READY) ? SS_READY : 0;\n    *value |= (status & I365_CS_POWERON) ? SS_POWERON : 0;\n\n    if (socket[sock].type == IS_VG469) {\n\tstatus = i365_get(sock, VG469_VSENSE);\n\tif (socket[sock].psock & 1) {\n\t    *value |= (status & VG469_VSENSE_B_VS1) ? 0 : SS_3VCARD;\n\t    *value |= (status & VG469_VSENSE_B_VS2) ? 0 : SS_XVCARD;\n\t} else {\n\t    *value |= (status & VG469_VSENSE_A_VS1) ? 0 : SS_3VCARD;\n\t    *value |= (status & VG469_VSENSE_A_VS2) ? 0 : SS_XVCARD;\n\t}\n    }\n    \n    pr_debug(\"GetStatus(%d) = %#4.4x\\n\", sock, *value);\n    return 0;\n}  \n\n \n\nstatic int i365_set_socket(u_short sock, socket_state_t *state)\n{\n    struct i82365_socket *t = &socket[sock];\n    u_char reg;\n    \n    pr_debug(\"SetSocket(%d, flags %#3.3x, Vcc %d, Vpp %d, \"\n\t  \"io_irq %d, csc_mask %#2.2x)\\n\", sock, state->flags,\n\t  state->Vcc, state->Vpp, state->io_irq, state->csc_mask);\n    \n     \n    set_bridge_state(sock);\n    \n     \n    reg = t->intr;\n    reg |= state->io_irq;\n    reg |= (state->flags & SS_RESET) ? 0 : I365_PC_RESET;\n    reg |= (state->flags & SS_IOCARD) ? I365_PC_IOCARD : 0;\n    i365_set(sock, I365_INTCTL, reg);\n    \n    reg = I365_PWR_NORESET;\n    if (state->flags & SS_PWR_AUTO) reg |= I365_PWR_AUTO;\n    if (state->flags & SS_OUTPUT_ENA) reg |= I365_PWR_OUT;\n\n    if (t->flags & IS_CIRRUS) {\n\tif (state->Vpp != 0) {\n\t    if (state->Vpp == 120)\n\t\treg |= I365_VPP1_12V;\n\t    else if (state->Vpp == state->Vcc)\n\t\treg |= I365_VPP1_5V;\n\t    else return -EINVAL;\n\t}\n\tif (state->Vcc != 0) {\n\t    reg |= I365_VCC_5V;\n\t    if (state->Vcc == 33)\n\t\ti365_bset(sock, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);\n\t    else if (state->Vcc == 50)\n\t\ti365_bclr(sock, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);\n\t    else return -EINVAL;\n\t}\n    } else if (t->flags & IS_VG_PWR) {\n\tif (state->Vpp != 0) {\n\t    if (state->Vpp == 120)\n\t\treg |= I365_VPP1_12V;\n\t    else if (state->Vpp == state->Vcc)\n\t\treg |= I365_VPP1_5V;\n\t    else return -EINVAL;\n\t}\n\tif (state->Vcc != 0) {\n\t    reg |= I365_VCC_5V;\n\t    if (state->Vcc == 33)\n\t\ti365_bset(sock, VG469_VSELECT, VG469_VSEL_VCC);\n\t    else if (state->Vcc == 50)\n\t\ti365_bclr(sock, VG469_VSELECT, VG469_VSEL_VCC);\n\t    else return -EINVAL;\n\t}\n    } else if (t->flags & IS_DF_PWR) {\n\tswitch (state->Vcc) {\n\tcase 0:\t\tbreak;\n\tcase 33:   \treg |= I365_VCC_3V; break;\n\tcase 50:\treg |= I365_VCC_5V; break;\n\tdefault:\treturn -EINVAL;\n\t}\n\tswitch (state->Vpp) {\n\tcase 0:\t\tbreak;\n\tcase 50:   \treg |= I365_VPP1_5V; break;\n\tcase 120:\treg |= I365_VPP1_12V; break;\n\tdefault:\treturn -EINVAL;\n\t}\n    } else {\n\tswitch (state->Vcc) {\n\tcase 0:\t\tbreak;\n\tcase 50:\treg |= I365_VCC_5V; break;\n\tdefault:\treturn -EINVAL;\n\t}\n\tswitch (state->Vpp) {\n\tcase 0:\t\tbreak;\n\tcase 50:\treg |= I365_VPP1_5V | I365_VPP2_5V; break;\n\tcase 120:\treg |= I365_VPP1_12V | I365_VPP2_12V; break;\n\tdefault:\treturn -EINVAL;\n\t}\n    }\n    \n    if (reg != i365_get(sock, I365_POWER))\n\ti365_set(sock, I365_POWER, reg);\n\n     \n    if (t->flags & IS_CIRRUS) {\n\t \n\ti365_bflip(sock, PD67_MISC_CTL_1, PD67_MC1_SPKR_ENA,\n\t\t   state->flags & SS_SPKR_ENA);\n    }\n    \n     \n    reg = t->cs_irq << 4;\n    if (state->csc_mask & SS_DETECT) reg |= I365_CSC_DETECT;\n    if (state->flags & SS_IOCARD) {\n\tif (state->csc_mask & SS_STSCHG) reg |= I365_CSC_STSCHG;\n    } else {\n\tif (state->csc_mask & SS_BATDEAD) reg |= I365_CSC_BVD1;\n\tif (state->csc_mask & SS_BATWARN) reg |= I365_CSC_BVD2;\n\tif (state->csc_mask & SS_READY) reg |= I365_CSC_READY;\n    }\n    i365_set(sock, I365_CSCINT, reg);\n    i365_get(sock, I365_CSC);\n    \n    return 0;\n}  \n\n \n\nstatic int i365_set_io_map(u_short sock, struct pccard_io_map *io)\n{\n    u_char map, ioctl;\n    \n    pr_debug(\"SetIOMap(%d, %d, %#2.2x, %d ns, \"\n\t  \"%#llx-%#llx)\\n\", sock, io->map, io->flags, io->speed,\n\t  (unsigned long long)io->start, (unsigned long long)io->stop);\n    map = io->map;\n    if ((map > 1) || (io->start > 0xffff) || (io->stop > 0xffff) ||\n\t(io->stop < io->start)) return -EINVAL;\n     \n    if (i365_get(sock, I365_ADDRWIN) & I365_ENA_IO(map))\n\ti365_bclr(sock, I365_ADDRWIN, I365_ENA_IO(map));\n    i365_set_pair(sock, I365_IO(map)+I365_W_START, io->start);\n    i365_set_pair(sock, I365_IO(map)+I365_W_STOP, io->stop);\n    ioctl = i365_get(sock, I365_IOCTL) & ~I365_IOCTL_MASK(map);\n    if (io->speed) ioctl |= I365_IOCTL_WAIT(map);\n    if (io->flags & MAP_0WS) ioctl |= I365_IOCTL_0WS(map);\n    if (io->flags & MAP_16BIT) ioctl |= I365_IOCTL_16BIT(map);\n    if (io->flags & MAP_AUTOSZ) ioctl |= I365_IOCTL_IOCS16(map);\n    i365_set(sock, I365_IOCTL, ioctl);\n     \n    if (io->flags & MAP_ACTIVE)\n\ti365_bset(sock, I365_ADDRWIN, I365_ENA_IO(map));\n    return 0;\n}  \n\n \n\nstatic int i365_set_mem_map(u_short sock, struct pccard_mem_map *mem)\n{\n    u_short base, i;\n    u_char map;\n    \n    pr_debug(\"SetMemMap(%d, %d, %#2.2x, %d ns, %#llx-%#llx, \"\n\t  \"%#x)\\n\", sock, mem->map, mem->flags, mem->speed,\n\t  (unsigned long long)mem->res->start,\n\t  (unsigned long long)mem->res->end, mem->card_start);\n\n    map = mem->map;\n    if ((map > 4) || (mem->card_start > 0x3ffffff) ||\n\t(mem->res->start > mem->res->end) || (mem->speed > 1000))\n\treturn -EINVAL;\n    if ((mem->res->start > 0xffffff) || (mem->res->end > 0xffffff))\n\treturn -EINVAL;\n\t\n     \n    if (i365_get(sock, I365_ADDRWIN) & I365_ENA_MEM(map))\n\ti365_bclr(sock, I365_ADDRWIN, I365_ENA_MEM(map));\n    \n    base = I365_MEM(map);\n    i = (mem->res->start >> 12) & 0x0fff;\n    if (mem->flags & MAP_16BIT) i |= I365_MEM_16BIT;\n    if (mem->flags & MAP_0WS) i |= I365_MEM_0WS;\n    i365_set_pair(sock, base+I365_W_START, i);\n    \n    i = (mem->res->end >> 12) & 0x0fff;\n    switch (to_cycles(mem->speed)) {\n    case 0:\tbreak;\n    case 1:\ti |= I365_MEM_WS0; break;\n    case 2:\ti |= I365_MEM_WS1; break;\n    default:\ti |= I365_MEM_WS1 | I365_MEM_WS0; break;\n    }\n    i365_set_pair(sock, base+I365_W_STOP, i);\n    \n    i = ((mem->card_start - mem->res->start) >> 12) & 0x3fff;\n    if (mem->flags & MAP_WRPROT) i |= I365_MEM_WRPROT;\n    if (mem->flags & MAP_ATTRIB) i |= I365_MEM_REG;\n    i365_set_pair(sock, base+I365_W_OFF, i);\n    \n     \n    if (mem->flags & MAP_ACTIVE)\n\ti365_bset(sock, I365_ADDRWIN, I365_ENA_MEM(map));\n    return 0;\n}  \n\n#if 0  \n \n\nstatic ssize_t show_info(struct class_device *class_dev, char *buf)\n{\n\tstruct i82365_socket *s = container_of(class_dev, struct i82365_socket, socket.dev);\n\treturn sprintf(buf, \"type:     %s\\npsock:    %d\\n\",\n\t\t       pcic[s->type].name, s->psock);\n}\n\nstatic ssize_t show_exca(struct class_device *class_dev, char *buf)\n{\n\tstruct i82365_socket *s = container_of(class_dev, struct i82365_socket, socket.dev);\n\tunsigned short sock;\n\tint i;\n\tssize_t ret = 0;\n\tunsigned long flags = 0;\n\n\tsock = s->number;\n\n\tISA_LOCK(sock, flags);\n\tfor (i = 0; i < 0x40; i += 4) {\n\t\tret += sprintf(buf, \"%02x %02x %02x %02x%s\",\n\t\t\t       i365_get(sock,i), i365_get(sock,i+1),\n\t\t\t       i365_get(sock,i+2), i365_get(sock,i+3),\n\t\t\t       ((i % 16) == 12) ? \"\\n\" : \" \");\n\t\tbuf += ret;\n\t}\n\tISA_UNLOCK(sock, flags);\n\n\treturn ret;\n}\n\nstatic CLASS_DEVICE_ATTR(exca, S_IRUGO, show_exca, NULL);\nstatic CLASS_DEVICE_ATTR(info, S_IRUGO, show_info, NULL);\n#endif\n\n \n\n \n#define LOCKED(x) do { \\\n\tint retval; \\\n\tunsigned long flags; \\\n\tspin_lock_irqsave(&isa_lock, flags); \\\n\tretval = x; \\\n\tspin_unlock_irqrestore(&isa_lock, flags); \\\n\treturn retval; \\\n} while (0)\n\t\n\nstatic int pcic_get_status(struct pcmcia_socket *s, u_int *value)\n{\n\tunsigned int sock = container_of(s, struct i82365_socket, socket)->number;\n\n\tif (socket[sock].flags & IS_ALIVE) {\n\t\t*value = 0;\n\t\treturn -EINVAL;\n\t}\n\n\tLOCKED(i365_get_status(sock, value));\n}\n\nstatic int pcic_set_socket(struct pcmcia_socket *s, socket_state_t *state)\n{\n\tunsigned int sock = container_of(s, struct i82365_socket, socket)->number;\n\n\tif (socket[sock].flags & IS_ALIVE)\n\t\treturn -EINVAL;\n\n\tLOCKED(i365_set_socket(sock, state));\n}\n\nstatic int pcic_set_io_map(struct pcmcia_socket *s, struct pccard_io_map *io)\n{\n\tunsigned int sock = container_of(s, struct i82365_socket, socket)->number;\n\tif (socket[sock].flags & IS_ALIVE)\n\t\treturn -EINVAL;\n\n\tLOCKED(i365_set_io_map(sock, io));\n}\n\nstatic int pcic_set_mem_map(struct pcmcia_socket *s, struct pccard_mem_map *mem)\n{\n\tunsigned int sock = container_of(s, struct i82365_socket, socket)->number;\n\tif (socket[sock].flags & IS_ALIVE)\n\t\treturn -EINVAL;\n\n\tLOCKED(i365_set_mem_map(sock, mem));\n}\n\nstatic int pcic_init(struct pcmcia_socket *s)\n{\n\tint i;\n\tstruct resource res = { .start = 0, .end = 0x1000 };\n\tpccard_io_map io = { 0, 0, 0, 0, 1 };\n\tpccard_mem_map mem = { .res = &res, };\n\n\tfor (i = 0; i < 2; i++) {\n\t\tio.map = i;\n\t\tpcic_set_io_map(s, &io);\n\t}\n\tfor (i = 0; i < 5; i++) {\n\t\tmem.map = i;\n\t\tpcic_set_mem_map(s, &mem);\n\t}\n\treturn 0;\n}\n\n\nstatic struct pccard_operations pcic_operations = {\n\t.init\t\t\t= pcic_init,\n\t.get_status\t\t= pcic_get_status,\n\t.set_socket\t\t= pcic_set_socket,\n\t.set_io_map\t\t= pcic_set_io_map,\n\t.set_mem_map\t\t= pcic_set_mem_map,\n};\n\n \n\nstatic struct platform_driver i82365_driver = {\n\t.driver = {\n\t\t.name = \"i82365\",\n\t},\n};\n\nstatic struct platform_device *i82365_device;\n\nstatic int __init init_i82365(void)\n{\n    int i, ret;\n\n    ret = platform_driver_register(&i82365_driver);\n    if (ret)\n\tgoto err_out;\n\n    i82365_device = platform_device_alloc(\"i82365\", 0);\n    if (i82365_device) {\n\t    ret = platform_device_add(i82365_device);\n\t    if (ret)\n\t\t    platform_device_put(i82365_device);\n    } else\n\t    ret = -ENOMEM;\n\n    if (ret)\n\tgoto err_driver_unregister;\n\n    printk(KERN_INFO \"Intel ISA PCIC probe: \");\n    sockets = 0;\n\n    isa_probe();\n\n    if (sockets == 0) {\n\tprintk(\"not found.\\n\");\n\tret = -ENODEV;\n\tgoto err_dev_unregister;\n    }\n\n     \n    if (grab_irq != 0)\n\tret = request_irq(cs_irq, pcic_interrupt, 0, \"i82365\", pcic_interrupt);\n\n    if (ret)\n\tgoto err_socket_release;\n\n     \n    for (i = 0; i < sockets; i++) {\n\t    socket[i].socket.dev.parent = &i82365_device->dev;\n\t    socket[i].socket.ops = &pcic_operations;\n\t    socket[i].socket.resource_ops = &pccard_nonstatic_ops;\n\t    socket[i].socket.owner = THIS_MODULE;\n\t    socket[i].number = i;\n\t    ret = pcmcia_register_socket(&socket[i].socket);\n\t    if (!ret)\n\t\t    socket[i].flags |= IS_REGISTERED;\n    }\n\n     \n    if (poll_interval != 0) {\n\ttimer_setup(&poll_timer, pcic_interrupt_wrapper, 0);\n    \tpoll_timer.expires = jiffies + poll_interval;\n\tadd_timer(&poll_timer);\n    }\n    \n    return 0;\nerr_socket_release:\n    for (i = 0; i < sockets; i++) {\n\t \n\ti365_set(i, I365_CSCINT, 0);\n\trelease_region(socket[i].ioaddr, 2);\n    }\nerr_dev_unregister:\n    platform_device_unregister(i82365_device);\n    release_region(i365_base, 2);\n#ifdef CONFIG_PNP\n    if (i82365_pnpdev)\n\tpnp_disable_dev(i82365_pnpdev);\n#endif\nerr_driver_unregister:\n    platform_driver_unregister(&i82365_driver);\nerr_out:\n    return ret;\n}  \n\nstatic void __exit exit_i82365(void)\n{\n    int i;\n\n    for (i = 0; i < sockets; i++) {\n\t    if (socket[i].flags & IS_REGISTERED)\n\t\t    pcmcia_unregister_socket(&socket[i].socket);\n    }\n    platform_device_unregister(i82365_device);\n    if (poll_interval != 0)\n\tdel_timer_sync(&poll_timer);\n    if (grab_irq != 0)\n\tfree_irq(cs_irq, pcic_interrupt);\n    for (i = 0; i < sockets; i++) {\n\t \n\ti365_set(i, I365_CSCINT, 0);\n\trelease_region(socket[i].ioaddr, 2);\n    }\n    release_region(i365_base, 2);\n#ifdef CONFIG_PNP\n    if (i82365_pnpdev)\n    \t\tpnp_disable_dev(i82365_pnpdev);\n#endif\n    platform_driver_unregister(&i82365_driver);\n}  \n\nmodule_init(init_i82365);\nmodule_exit(exit_i82365);\nMODULE_LICENSE(\"Dual MPL/GPL\");\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}