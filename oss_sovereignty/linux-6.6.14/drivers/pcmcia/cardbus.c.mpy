{
  "module_name": "cardbus.c",
  "hash_id": "bdac0c6cc03686ad326aaed31679043c4d48c4c23b36734e7fae0864faae3c26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/cardbus.c",
  "human_readable_source": "\n \n\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include <pcmcia/ss.h>\n#include <pcmcia/cistpl.h>\n\n#include \"cs_internal.h\"\n\nstatic void cardbus_config_irq_and_cls(struct pci_bus *bus, int irq)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tu8 irq_pin;\n\n\t\t \n\t\tpci_read_config_byte(dev, PCI_INTERRUPT_PIN, &irq_pin);\n\t\tif (irq_pin) {\n\t\t\tdev->irq = irq;\n\t\t\tpci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);\n\t\t}\n\n\t\t \n\t\tpci_set_cacheline_size(dev);\n\n\t\tif (dev->subordinate)\n\t\t\tcardbus_config_irq_and_cls(dev->subordinate, irq);\n\t}\n}\n\n \nint __ref cb_alloc(struct pcmcia_socket *s)\n{\n\tstruct pci_bus *bus = s->cb_dev->subordinate;\n\tstruct pci_dev *dev;\n\tunsigned int max, pass;\n\n\tpci_lock_rescan_remove();\n\n\ts->functions = pci_scan_slot(bus, PCI_DEVFN(0, 0));\n\tpci_fixup_cardbus(bus);\n\n\tmax = bus->busn_res.start;\n\tfor (pass = 0; pass < 2; pass++)\n\t\tfor_each_pci_bridge(dev, bus)\n\t\t\tmax = pci_scan_bridge(bus, dev, max, pass);\n\n\t \n\tpci_bus_size_bridges(bus);\n\tpci_bus_assign_resources(bus);\n\tcardbus_config_irq_and_cls(bus, s->pci_irq);\n\n\t \n\tif (s->tune_bridge)\n\t\ts->tune_bridge(s, bus);\n\n\tpci_bus_add_devices(bus);\n\n\tpci_unlock_rescan_remove();\n\treturn 0;\n}\n\n \nvoid cb_free(struct pcmcia_socket *s)\n{\n\tstruct pci_dev *bridge, *dev, *tmp;\n\tstruct pci_bus *bus;\n\n\tbridge = s->cb_dev;\n\tif (!bridge)\n\t\treturn;\n\n\tbus = bridge->subordinate;\n\tif (!bus)\n\t\treturn;\n\n\tpci_lock_rescan_remove();\n\n\tlist_for_each_entry_safe(dev, tmp, &bus->devices, bus_list)\n\t\tpci_stop_and_remove_bus_device(dev);\n\n\tpci_unlock_rescan_remove();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}