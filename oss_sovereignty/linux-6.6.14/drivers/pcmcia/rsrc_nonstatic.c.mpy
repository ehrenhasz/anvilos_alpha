{
  "module_name": "rsrc_nonstatic.c",
  "hash_id": "0cc44ab97d8d5a1a96b556f25b46cd15fc36d81729a19f514d0500cb9c006a53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/rsrc_nonstatic.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/timer.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include <linux/io.h>\n\n#include <asm/irq.h>\n\n#include <pcmcia/ss.h>\n#include <pcmcia/cistpl.h>\n#include \"cs_internal.h\"\n\n \n\n \n\n#define INT_MODULE_PARM(n, v) static int n = v; module_param(n, int, 0444)\n\nINT_MODULE_PARM(probe_mem,\t1);\t\t \n#ifdef CONFIG_PCMCIA_PROBE\nINT_MODULE_PARM(probe_io,\t1);\t\t \nINT_MODULE_PARM(mem_limit,\t0x10000);\n#endif\n\n \nstruct resource_map {\n\tu_long\t\t\tbase, num;\n\tstruct resource_map\t*next;\n};\n\nstruct socket_data {\n\tstruct resource_map\t\tmem_db;\n\tstruct resource_map\t\tmem_db_valid;\n\tstruct resource_map\t\tio_db;\n};\n\n#define MEM_PROBE_LOW\t(1 << 0)\n#define MEM_PROBE_HIGH\t(1 << 1)\n\n \n#define REMOVE_MANAGED_RESOURCE\t\t1\n#define ADD_MANAGED_RESOURCE\t\t2\n\n \n\nstatic struct resource *\nclaim_region(struct pcmcia_socket *s, resource_size_t base,\n\t\tresource_size_t size, int type, char *name)\n{\n\tstruct resource *res, *parent;\n\n\tparent = type & IORESOURCE_MEM ? &iomem_resource : &ioport_resource;\n\tres = pcmcia_make_resource(base, size, type | IORESOURCE_BUSY, name);\n\n\tif (res) {\n#ifdef CONFIG_PCI\n\t\tif (s && s->cb_dev)\n\t\t\tparent = pci_find_parent_resource(s->cb_dev, res);\n#endif\n\t\tif (!parent || request_resource(parent, res)) {\n\t\t\tkfree(res);\n\t\t\tres = NULL;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic void free_region(struct resource *res)\n{\n\tif (res) {\n\t\trelease_resource(res);\n\t\tkfree(res);\n\t}\n}\n\n \n\nstatic int add_interval(struct resource_map *map, u_long base, u_long num)\n{\n\tstruct resource_map *p, *q;\n\n\tfor (p = map; ; p = p->next) {\n\t\tif ((p != map) && (p->base+p->num >= base)) {\n\t\t\tp->num = max(num + base - p->base, p->num);\n\t\t\treturn 0;\n\t\t}\n\t\tif ((p->next == map) || (p->next->base > base+num-1))\n\t\t\tbreak;\n\t}\n\tq = kmalloc(sizeof(struct resource_map), GFP_KERNEL);\n\tif (!q) {\n\t\tprintk(KERN_WARNING \"out of memory to update resources\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tq->base = base; q->num = num;\n\tq->next = p->next; p->next = q;\n\treturn 0;\n}\n\n \n\nstatic int sub_interval(struct resource_map *map, u_long base, u_long num)\n{\n\tstruct resource_map *p, *q;\n\n\tfor (p = map; ; p = q) {\n\t\tq = p->next;\n\t\tif (q == map)\n\t\t\tbreak;\n\t\tif ((q->base+q->num > base) && (base+num > q->base)) {\n\t\t\tif (q->base >= base) {\n\t\t\t\tif (q->base+q->num <= base+num) {\n\t\t\t\t\t \n\t\t\t\t\tp->next = q->next;\n\t\t\t\t\tkfree(q);\n\t\t\t\t\t \n\t\t\t\t\tq = p;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tq->num = q->base + q->num - base - num;\n\t\t\t\t\tq->base = base + num;\n\t\t\t\t}\n\t\t\t} else if (q->base+q->num <= base+num) {\n\t\t\t\t \n\t\t\t\tq->num = base - q->base;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tp = kmalloc(sizeof(struct resource_map),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (!p) {\n\t\t\t\t\tprintk(KERN_WARNING \"out of memory to update resources\\n\");\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\tp->base = base+num;\n\t\t\t\tp->num = q->base+q->num - p->base;\n\t\t\t\tq->num = base - q->base;\n\t\t\t\tp->next = q->next ; q->next = p;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_PCMCIA_PROBE\nstatic void do_io_probe(struct pcmcia_socket *s, unsigned int base,\n\t\t\tunsigned int num)\n{\n\tstruct resource *res;\n\tstruct socket_data *s_data = s->resource_data;\n\tunsigned int i, j, bad;\n\tint any;\n\tu_char *b, hole, most;\n\n\tdev_info(&s->dev, \"cs: IO port probe %#x-%#x:\", base, base+num-1);\n\n\t \n\tb = kzalloc(256, GFP_KERNEL);\n\tif (!b) {\n\t\tpr_cont(\"\\n\");\n\t\tdev_err(&s->dev, \"do_io_probe: unable to kmalloc 256 bytes\\n\");\n\t\treturn;\n\t}\n\tfor (i = base, most = 0; i < base+num; i += 8) {\n\t\tres = claim_region(s, i, 8, IORESOURCE_IO, \"PCMCIA ioprobe\");\n\t\tif (!res)\n\t\t\tcontinue;\n\t\thole = inb(i);\n\t\tfor (j = 1; j < 8; j++)\n\t\t\tif (inb(i+j) != hole)\n\t\t\t\tbreak;\n\t\tfree_region(res);\n\t\tif ((j == 8) && (++b[hole] > b[most]))\n\t\t\tmost = hole;\n\t\tif (b[most] == 127)\n\t\t\tbreak;\n\t}\n\tkfree(b);\n\n\tbad = any = 0;\n\tfor (i = base; i < base+num; i += 8) {\n\t\tres = claim_region(s, i, 8, IORESOURCE_IO, \"PCMCIA ioprobe\");\n\t\tif (!res) {\n\t\t\tif (!any)\n\t\t\t\tpr_cont(\" excluding\");\n\t\t\tif (!bad)\n\t\t\t\tbad = any = i;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tif (inb(i+j) != most)\n\t\t\t\tbreak;\n\t\tfree_region(res);\n\t\tif (j < 8) {\n\t\t\tif (!any)\n\t\t\t\tpr_cont(\" excluding\");\n\t\t\tif (!bad)\n\t\t\t\tbad = any = i;\n\t\t} else {\n\t\t\tif (bad) {\n\t\t\t\tsub_interval(&s_data->io_db, bad, i-bad);\n\t\t\t\tpr_cont(\" %#x-%#x\", bad, i-1);\n\t\t\t\tbad = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (bad) {\n\t\tif ((num > 16) && (bad == base) && (i == base+num)) {\n\t\t\tsub_interval(&s_data->io_db, bad, i-bad);\n\t\t\tpr_cont(\" nothing: probe failed.\\n\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tsub_interval(&s_data->io_db, bad, i-bad);\n\t\t\tpr_cont(\" %#x-%#x\", bad, i-1);\n\t\t}\n\t}\n\n\tpr_cont(\"%s\\n\", !any ? \" clean\" : \"\");\n}\n#endif\n\n \n\n \nstatic int readable(struct pcmcia_socket *s, struct resource *res,\n\t\t    unsigned int *count)\n{\n\tint ret = -EINVAL;\n\n\tif (s->fake_cis) {\n\t\tdev_dbg(&s->dev, \"fake CIS is being used: can't validate mem\\n\");\n\t\treturn 0;\n\t}\n\n\ts->cis_mem.res = res;\n\ts->cis_virt = ioremap(res->start, s->map_size);\n\tif (s->cis_virt) {\n\t\tmutex_unlock(&s->ops_mutex);\n\t\t \n\t\tif (s->callback->validate)\n\t\t\tret = s->callback->validate(s, count);\n\t\t \n\t\tmutex_lock(&s->ops_mutex);\n\t\tiounmap(s->cis_virt);\n\t\ts->cis_virt = NULL;\n\t}\n\ts->cis_mem.res = NULL;\n\tif ((ret) || (*count == 0))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic int checksum(struct pcmcia_socket *s, struct resource *res,\n\t\t    unsigned int *value)\n{\n\tpccard_mem_map map;\n\tint i, a = 0, b = -1, d;\n\tvoid __iomem *virt;\n\n\tvirt = ioremap(res->start, s->map_size);\n\tif (virt) {\n\t\tmap.map = 0;\n\t\tmap.flags = MAP_ACTIVE;\n\t\tmap.speed = 0;\n\t\tmap.res = res;\n\t\tmap.card_start = 0;\n\t\ts->ops->set_mem_map(s, &map);\n\n\t\t \n\t\tfor (i = 0; i < s->map_size; i += 44) {\n\t\t\td = readl(virt+i);\n\t\t\ta += d;\n\t\t\tb &= d;\n\t\t}\n\n\t\tmap.flags = 0;\n\t\ts->ops->set_mem_map(s, &map);\n\n\t\tiounmap(virt);\n\t}\n\n\tif (b == -1)\n\t\treturn -EINVAL;\n\n\t*value = a;\n\n\treturn 0;\n}\n\n \nstatic int do_validate_mem(struct pcmcia_socket *s,\n\t\t\t   unsigned long base, unsigned long size,\n\t\t\t   int (*validate)(struct pcmcia_socket *s,\n\t\t\t\t\t   struct resource *res,\n\t\t\t\t\t   unsigned int *value))\n{\n\tstruct socket_data *s_data = s->resource_data;\n\tstruct resource *res1, *res2;\n\tunsigned int info1 = 1, info2 = 1;\n\tint ret = -EINVAL;\n\n\tres1 = claim_region(s, base, size/2, IORESOURCE_MEM, \"PCMCIA memprobe\");\n\tres2 = claim_region(s, base + size/2, size/2, IORESOURCE_MEM,\n\t\t\t\"PCMCIA memprobe\");\n\n\tif (res1 && res2) {\n\t\tret = 0;\n\t\tif (validate) {\n\t\t\tret = validate(s, res1, &info1);\n\t\t\tret += validate(s, res2, &info2);\n\t\t}\n\t}\n\n\tdev_dbg(&s->dev, \"cs: memory probe 0x%06lx-0x%06lx: %pr %pr %u %u %u\",\n\t\tbase, base+size-1, res1, res2, ret, info1, info2);\n\n\tfree_region(res2);\n\tfree_region(res1);\n\n\tif ((ret) || (info1 != info2) || (info1 == 0))\n\t\treturn -EINVAL;\n\n\tif (validate && !s->fake_cis) {\n\t\t \n\t\tadd_interval(&s_data->mem_db_valid, base, size);\n\t\tsub_interval(&s_data->mem_db, base, size);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int do_mem_probe(struct pcmcia_socket *s, u_long base, u_long num,\n\t\t\tint (*validate)(struct pcmcia_socket *s,\n\t\t\t\t\tstruct resource *res,\n\t\t\t\t\tunsigned int *value),\n\t\t\tint (*fallback)(struct pcmcia_socket *s,\n\t\t\t\t\tstruct resource *res,\n\t\t\t\t\tunsigned int *value))\n{\n\tstruct socket_data *s_data = s->resource_data;\n\tu_long i, j, bad, fail, step;\n\n\tdev_info(&s->dev, \"cs: memory probe 0x%06lx-0x%06lx:\",\n\t\t base, base+num-1);\n\tbad = fail = 0;\n\tstep = (num < 0x20000) ? 0x2000 : ((num>>4) & ~0x1fff);\n\t \n\tif (step > 0x800000)\n\t\tstep = 0x800000;\n\t \n\tif (step < 2 * s->map_size)\n\t\tstep = 2 * s->map_size;\n\tfor (i = j = base; i < base+num; i = j + step) {\n\t\tif (!fail) {\n\t\t\tfor (j = i; j < base+num; j += step) {\n\t\t\t\tif (!do_validate_mem(s, j, step, validate))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfail = ((i == base) && (j == base+num));\n\t\t}\n\t\tif ((fail) && (fallback)) {\n\t\t\tfor (j = i; j < base+num; j += step)\n\t\t\t\tif (!do_validate_mem(s, j, step, fallback))\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif (i != j) {\n\t\t\tif (!bad)\n\t\t\t\tpr_cont(\" excluding\");\n\t\t\tpr_cont(\" %#05lx-%#05lx\", i, j-1);\n\t\t\tsub_interval(&s_data->mem_db, i, j-i);\n\t\t\tbad += j-i;\n\t\t}\n\t}\n\tpr_cont(\"%s\\n\", !bad ? \" clean\" : \"\");\n\treturn num - bad;\n}\n\n\n#ifdef CONFIG_PCMCIA_PROBE\n\n \nstatic u_long inv_probe(struct resource_map *m, struct pcmcia_socket *s)\n{\n\tstruct socket_data *s_data = s->resource_data;\n\tu_long ok;\n\tif (m == &s_data->mem_db)\n\t\treturn 0;\n\tok = inv_probe(m->next, s);\n\tif (ok) {\n\t\tif (m->base >= 0x100000)\n\t\t\tsub_interval(&s_data->mem_db, m->base, m->num);\n\t\treturn ok;\n\t}\n\tif (m->base < 0x100000)\n\t\treturn 0;\n\treturn do_mem_probe(s, m->base, m->num, readable, checksum);\n}\n\n \nstatic int validate_mem(struct pcmcia_socket *s, unsigned int probe_mask)\n{\n\tstruct resource_map *m, mm;\n\tstatic unsigned char order[] = { 0xd0, 0xe0, 0xc0, 0xf0 };\n\tunsigned long b, i, ok = 0;\n\tstruct socket_data *s_data = s->resource_data;\n\n\t \n\tif (probe_mask & MEM_PROBE_HIGH) {\n\t\tif (inv_probe(s_data->mem_db.next, s) > 0)\n\t\t\treturn 0;\n\t\tif (s_data->mem_db_valid.next != &s_data->mem_db_valid)\n\t\t\treturn 0;\n\t\tdev_notice(&s->dev,\n\t\t\t   \"cs: warning: no high memory space available!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (m = s_data->mem_db.next; m != &s_data->mem_db; m = mm.next) {\n\t\tmm = *m;\n\t\t \n\t\tif (mm.base >= 0x100000)\n\t\t\tcontinue;\n\t\tif ((mm.base | mm.num) & 0xffff) {\n\t\t\tok += do_mem_probe(s, mm.base, mm.num, readable,\n\t\t\t\t\t   checksum);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tb = order[i] << 12;\n\t\t\tif ((b >= mm.base) && (b+0x10000 <= mm.base+mm.num)) {\n\t\t\t\tif (ok >= mem_limit)\n\t\t\t\t\tsub_interval(&s_data->mem_db, b, 0x10000);\n\t\t\t\telse\n\t\t\t\t\tok += do_mem_probe(s, b, 0x10000,\n\t\t\t\t\t\t\t   readable, checksum);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ok > 0)\n\t\treturn 0;\n\n\treturn -ENODEV;\n}\n\n#else  \n\n \nstatic int validate_mem(struct pcmcia_socket *s, unsigned int probe_mask)\n{\n\tstruct resource_map *m, mm;\n\tstruct socket_data *s_data = s->resource_data;\n\tunsigned long ok = 0;\n\n\tfor (m = s_data->mem_db.next; m != &s_data->mem_db; m = mm.next) {\n\t\tmm = *m;\n\t\tok += do_mem_probe(s, mm.base, mm.num, readable, checksum);\n\t}\n\tif (ok > 0)\n\t\treturn 0;\n\treturn -ENODEV;\n}\n\n#endif  \n\n\n \nstatic int pcmcia_nonstatic_validate_mem(struct pcmcia_socket *s)\n{\n\tstruct socket_data *s_data = s->resource_data;\n\tunsigned int probe_mask = MEM_PROBE_LOW;\n\tint ret;\n\n\tif (!probe_mem || !(s->state & SOCKET_PRESENT))\n\t\treturn 0;\n\n\tif (s->features & SS_CAP_PAGE_REGS)\n\t\tprobe_mask = MEM_PROBE_HIGH;\n\n\tret = validate_mem(s, probe_mask);\n\n\tif (s_data->mem_db_valid.next != &s_data->mem_db_valid)\n\t\treturn 0;\n\n\treturn ret;\n}\n\nstruct pcmcia_align_data {\n\tunsigned long\tmask;\n\tunsigned long\toffset;\n\tstruct resource_map\t*map;\n};\n\nstatic resource_size_t pcmcia_common_align(struct pcmcia_align_data *align_data,\n\t\t\t\t\tresource_size_t start)\n{\n\tresource_size_t ret;\n\t \n\tret = (start & ~align_data->mask) + align_data->offset;\n\tif (ret < start)\n\t\tret += align_data->mask + 1;\n\treturn ret;\n}\n\nstatic resource_size_t\npcmcia_align(void *align_data, const struct resource *res,\n\tresource_size_t size, resource_size_t align)\n{\n\tstruct pcmcia_align_data *data = align_data;\n\tstruct resource_map *m;\n\tresource_size_t start;\n\n\tstart = pcmcia_common_align(data, res->start);\n\n\tfor (m = data->map->next; m != data->map; m = m->next) {\n\t\tunsigned long map_start = m->base;\n\t\tunsigned long map_end = m->base + m->num - 1;\n\n\t\t \n\t\tif (start < map_start)\n\t\t\tstart = pcmcia_common_align(data, map_start);\n\n\t\t \n\t\tif (start >= res->end)\n\t\t\tbreak;\n\n\t\tif ((start + size - 1) <= map_end)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (m == data->map)\n\t\tstart = res->end;\n\n\treturn start;\n}\n\n \nstatic int __nonstatic_adjust_io_region(struct pcmcia_socket *s,\n\t\t\t\t\tunsigned long r_start,\n\t\t\t\t\tunsigned long r_end)\n{\n\tstruct resource_map *m;\n\tstruct socket_data *s_data = s->resource_data;\n\tint ret = -ENOMEM;\n\n\tfor (m = s_data->io_db.next; m != &s_data->io_db; m = m->next) {\n\t\tunsigned long start = m->base;\n\t\tunsigned long end = m->base + m->num - 1;\n\n\t\tif (start > r_start || r_end > end)\n\t\t\tcontinue;\n\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic struct resource *__nonstatic_find_io_region(struct pcmcia_socket *s,\n\t\t\t\t\t\tunsigned long base, int num,\n\t\t\t\t\t\tunsigned long align)\n{\n\tstruct resource *res = pcmcia_make_resource(0, num, IORESOURCE_IO,\n\t\t\t\t\t\tdev_name(&s->dev));\n\tstruct socket_data *s_data = s->resource_data;\n\tstruct pcmcia_align_data data;\n\tunsigned long min = base;\n\tint ret;\n\n\tif (!res)\n\t\treturn NULL;\n\n\tdata.mask = align - 1;\n\tdata.offset = base & data.mask;\n\tdata.map = &s_data->io_db;\n\n#ifdef CONFIG_PCI\n\tif (s->cb_dev) {\n\t\tret = pci_bus_alloc_resource(s->cb_dev->bus, res, num, 1,\n\t\t\t\t\t     min, 0, pcmcia_align, &data);\n\t} else\n#endif\n\t\tret = allocate_resource(&ioport_resource, res, num, min, ~0UL,\n\t\t\t\t\t1, pcmcia_align, &data);\n\n\tif (ret != 0) {\n\t\tkfree(res);\n\t\tres = NULL;\n\t}\n\treturn res;\n}\n\nstatic int nonstatic_find_io(struct pcmcia_socket *s, unsigned int attr,\n\t\t\tunsigned int *base, unsigned int num,\n\t\t\tunsigned int align, struct resource **parent)\n{\n\tint i, ret = 0;\n\n\t \n\tfor (i = 0; i < MAX_IO_WIN; i++) {\n\t\tif (!s->io[i].res)\n\t\t\tcontinue;\n\n\t\tif (!*base)\n\t\t\tcontinue;\n\n\t\tif ((s->io[i].res->start & (align-1)) == *base)\n\t\t\treturn -EBUSY;\n\t}\n\n\tfor (i = 0; i < MAX_IO_WIN; i++) {\n\t\tstruct resource *res = s->io[i].res;\n\t\tunsigned int try;\n\n\t\tif (res && (res->flags & IORESOURCE_BITS) !=\n\t\t\t(attr & IORESOURCE_BITS))\n\t\t\tcontinue;\n\n\t\tif (!res) {\n\t\t\tif (align == 0)\n\t\t\t\talign = 0x10000;\n\n\t\t\tres = s->io[i].res = __nonstatic_find_io_region(s,\n\t\t\t\t\t\t\t\t*base, num,\n\t\t\t\t\t\t\t\talign);\n\t\t\tif (!res)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t*base = res->start;\n\t\t\ts->io[i].res->flags =\n\t\t\t\t((res->flags & ~IORESOURCE_BITS) |\n\t\t\t\t\t(attr & IORESOURCE_BITS));\n\t\t\ts->io[i].InUse = num;\n\t\t\t*parent = res;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\ttry = res->end + 1;\n\t\tif ((*base == 0) || (*base == try)) {\n\t\t\tret =  __nonstatic_adjust_io_region(s, res->start,\n\t\t\t\t\t\t\tres->end + num);\n\t\t\tif (!ret) {\n\t\t\t\tret = adjust_resource(s->io[i].res, res->start,\n\t\t\t\t\t\t      resource_size(res) + num);\n\t\t\t\tif (ret)\n\t\t\t\t\tcontinue;\n\t\t\t\t*base = try;\n\t\t\t\ts->io[i].InUse += num;\n\t\t\t\t*parent = res;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttry = res->start - num;\n\t\tif ((*base == 0) || (*base == try)) {\n\t\t\tret =  __nonstatic_adjust_io_region(s,\n\t\t\t\t\t\t\tres->start - num,\n\t\t\t\t\t\t\tres->end);\n\t\t\tif (!ret) {\n\t\t\t\tret = adjust_resource(s->io[i].res,\n\t\t\t\t\t\t      res->start - num,\n\t\t\t\t\t\t      resource_size(res) + num);\n\t\t\t\tif (ret)\n\t\t\t\t\tcontinue;\n\t\t\t\t*base = try;\n\t\t\t\ts->io[i].InUse += num;\n\t\t\t\t*parent = res;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n\nstatic struct resource *nonstatic_find_mem_region(u_long base, u_long num,\n\t\tu_long align, int low, struct pcmcia_socket *s)\n{\n\tstruct resource *res = pcmcia_make_resource(0, num, IORESOURCE_MEM,\n\t\t\t\t\t\tdev_name(&s->dev));\n\tstruct socket_data *s_data = s->resource_data;\n\tstruct pcmcia_align_data data;\n\tunsigned long min, max;\n\tint ret, i, j;\n\n\tif (!res)\n\t\treturn NULL;\n\n\tlow = low || !(s->features & SS_CAP_PAGE_REGS);\n\n\tdata.mask = align - 1;\n\tdata.offset = base & data.mask;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tdata.map = &s_data->mem_db_valid;\n\t\tif (low) {\n\t\t\tmax = 0x100000UL;\n\t\t\tmin = base < max ? base : 0;\n\t\t} else {\n\t\t\tmax = ~0UL;\n\t\t\tmin = 0x100000UL + base;\n\t\t}\n\n\t\tfor (j = 0; j < 2; j++) {\n#ifdef CONFIG_PCI\n\t\t\tif (s->cb_dev) {\n\t\t\t\tret = pci_bus_alloc_resource(s->cb_dev->bus,\n\t\t\t\t\t\t\tres, num, 1, min, 0,\n\t\t\t\t\t\t\tpcmcia_align, &data);\n\t\t\t} else\n#endif\n\t\t\t{\n\t\t\t\tret = allocate_resource(&iomem_resource,\n\t\t\t\t\t\t\tres, num, min, max, 1,\n\t\t\t\t\t\t\tpcmcia_align, &data);\n\t\t\t}\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tdata.map = &s_data->mem_db;\n\t\t}\n\t\tif (ret == 0 || low)\n\t\t\tbreak;\n\t\tlow = 1;\n\t}\n\n\tif (ret != 0) {\n\t\tkfree(res);\n\t\tres = NULL;\n\t}\n\treturn res;\n}\n\n\nstatic int adjust_memory(struct pcmcia_socket *s, unsigned int action, unsigned long start, unsigned long end)\n{\n\tstruct socket_data *data = s->resource_data;\n\tunsigned long size = end - start + 1;\n\tint ret = 0;\n\n\tif (end < start)\n\t\treturn -EINVAL;\n\n\tswitch (action) {\n\tcase ADD_MANAGED_RESOURCE:\n\t\tret = add_interval(&data->mem_db, start, size);\n\t\tif (!ret)\n\t\t\tdo_mem_probe(s, start, size, NULL, NULL);\n\t\tbreak;\n\tcase REMOVE_MANAGED_RESOURCE:\n\t\tret = sub_interval(&data->mem_db, start, size);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n\nstatic int adjust_io(struct pcmcia_socket *s, unsigned int action, unsigned long start, unsigned long end)\n{\n\tstruct socket_data *data = s->resource_data;\n\tunsigned long size;\n\tint ret = 0;\n\n#if defined(CONFIG_X86)\n\t \n\tif (start < 0x100)\n\t\tstart = 0x100;\n#endif\n\n\tsize = end - start + 1;\n\n\tif (end < start)\n\t\treturn -EINVAL;\n\n\tif (end > IO_SPACE_LIMIT)\n\t\treturn -EINVAL;\n\n\tswitch (action) {\n\tcase ADD_MANAGED_RESOURCE:\n\t\tif (add_interval(&data->io_db, start, size) != 0) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n#ifdef CONFIG_PCMCIA_PROBE\n\t\tif (probe_io)\n\t\t\tdo_io_probe(s, start, size);\n#endif\n\t\tbreak;\n\tcase REMOVE_MANAGED_RESOURCE:\n\t\tsub_interval(&data->io_db, start, size);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n\n#ifdef CONFIG_PCI\nstatic int nonstatic_autoadd_resources(struct pcmcia_socket *s)\n{\n\tstruct resource *res;\n\tint i, done = 0;\n\n\tif (!s->cb_dev || !s->cb_dev->bus)\n\t\treturn -ENODEV;\n\n#if defined(CONFIG_X86)\n\t \n\tif (s->cb_dev->bus->number == 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {\n\t\tres = s->cb_dev->bus->resource[i];\n#else\n\tpci_bus_for_each_resource(s->cb_dev->bus, res, i) {\n#endif\n\t\tif (!res)\n\t\t\tcontinue;\n\n\t\tif (res->flags & IORESOURCE_IO) {\n\t\t\t \n\t\t\tif (res == &ioport_resource)\n\t\t\t\tcontinue;\n\n\t\t\tdev_info(&s->cb_dev->dev,\n\t\t\t\t \"pcmcia: parent PCI bridge window: %pR\\n\",\n\t\t\t\t res);\n\t\t\tif (!adjust_io(s, ADD_MANAGED_RESOURCE, res->start, res->end))\n\t\t\t\tdone |= IORESOURCE_IO;\n\n\t\t}\n\n\t\tif (res->flags & IORESOURCE_MEM) {\n\t\t\t \n\t\t\tif (res == &iomem_resource)\n\t\t\t\tcontinue;\n\n\t\t\tdev_info(&s->cb_dev->dev,\n\t\t\t\t \"pcmcia: parent PCI bridge window: %pR\\n\",\n\t\t\t\t res);\n\t\t\tif (!adjust_memory(s, ADD_MANAGED_RESOURCE, res->start, res->end))\n\t\t\t\tdone |= IORESOURCE_MEM;\n\t\t}\n\t}\n\n\t \n\tif (done == (IORESOURCE_MEM | IORESOURCE_IO))\n\t\ts->resource_setup_done = 1;\n\n\treturn 0;\n}\n\n#else\n\nstatic inline int nonstatic_autoadd_resources(struct pcmcia_socket *s)\n{\n\treturn -ENODEV;\n}\n\n#endif\n\n\nstatic int nonstatic_init(struct pcmcia_socket *s)\n{\n\tstruct socket_data *data;\n\n\tdata = kzalloc(sizeof(struct socket_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->mem_db.next = &data->mem_db;\n\tdata->mem_db_valid.next = &data->mem_db_valid;\n\tdata->io_db.next = &data->io_db;\n\n\ts->resource_data = (void *) data;\n\n\tnonstatic_autoadd_resources(s);\n\n\treturn 0;\n}\n\nstatic void nonstatic_release_resource_db(struct pcmcia_socket *s)\n{\n\tstruct socket_data *data = s->resource_data;\n\tstruct resource_map *p, *q;\n\n\tfor (p = data->mem_db_valid.next; p != &data->mem_db_valid; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n\tfor (p = data->mem_db.next; p != &data->mem_db; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n\tfor (p = data->io_db.next; p != &data->io_db; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n\n\tkfree(data);\n}\n\n\nstruct pccard_resource_ops pccard_nonstatic_ops = {\n\t.validate_mem = pcmcia_nonstatic_validate_mem,\n\t.find_io = nonstatic_find_io,\n\t.find_mem = nonstatic_find_mem_region,\n\t.init = nonstatic_init,\n\t.exit = nonstatic_release_resource_db,\n};\nEXPORT_SYMBOL(pccard_nonstatic_ops);\n\n\n \n\nstatic ssize_t show_io_db(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct pcmcia_socket *s = dev_get_drvdata(dev);\n\tstruct socket_data *data;\n\tstruct resource_map *p;\n\tssize_t ret = 0;\n\n\tmutex_lock(&s->ops_mutex);\n\tdata = s->resource_data;\n\n\tfor (p = data->io_db.next; p != &data->io_db; p = p->next) {\n\t\tif (ret > (PAGE_SIZE - 10))\n\t\t\tcontinue;\n\t\tret += sysfs_emit_at(buf, ret,\n\t\t\t\t\"0x%08lx - 0x%08lx\\n\",\n\t\t\t\t((unsigned long) p->base),\n\t\t\t\t((unsigned long) p->base + p->num - 1));\n\t}\n\n\tmutex_unlock(&s->ops_mutex);\n\treturn ret;\n}\n\nstatic ssize_t store_io_db(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct pcmcia_socket *s = dev_get_drvdata(dev);\n\tunsigned long start_addr, end_addr;\n\tunsigned int add = ADD_MANAGED_RESOURCE;\n\tssize_t ret = 0;\n\n\tret = sscanf(buf, \"+ 0x%lx - 0x%lx\", &start_addr, &end_addr);\n\tif (ret != 2) {\n\t\tret = sscanf(buf, \"- 0x%lx - 0x%lx\", &start_addr, &end_addr);\n\t\tadd = REMOVE_MANAGED_RESOURCE;\n\t\tif (ret != 2) {\n\t\t\tret = sscanf(buf, \"0x%lx - 0x%lx\", &start_addr,\n\t\t\t\t&end_addr);\n\t\t\tadd = ADD_MANAGED_RESOURCE;\n\t\t\tif (ret != 2)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (end_addr < start_addr)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&s->ops_mutex);\n\tret = adjust_io(s, add, start_addr, end_addr);\n\tmutex_unlock(&s->ops_mutex);\n\n\treturn ret ? ret : count;\n}\nstatic DEVICE_ATTR(available_resources_io, 0600, show_io_db, store_io_db);\n\nstatic ssize_t show_mem_db(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct pcmcia_socket *s = dev_get_drvdata(dev);\n\tstruct socket_data *data;\n\tstruct resource_map *p;\n\tssize_t ret = 0;\n\n\tmutex_lock(&s->ops_mutex);\n\tdata = s->resource_data;\n\n\tfor (p = data->mem_db_valid.next; p != &data->mem_db_valid;\n\t     p = p->next) {\n\t\tif (ret > (PAGE_SIZE - 10))\n\t\t\tcontinue;\n\t\tret += sysfs_emit_at(buf, ret,\n\t\t\t\t\"0x%08lx - 0x%08lx\\n\",\n\t\t\t\t((unsigned long) p->base),\n\t\t\t\t((unsigned long) p->base + p->num - 1));\n\t}\n\n\tfor (p = data->mem_db.next; p != &data->mem_db; p = p->next) {\n\t\tif (ret > (PAGE_SIZE - 10))\n\t\t\tcontinue;\n\t\tret += sysfs_emit_at(buf, ret,\n\t\t\t\t\"0x%08lx - 0x%08lx\\n\",\n\t\t\t\t((unsigned long) p->base),\n\t\t\t\t((unsigned long) p->base + p->num - 1));\n\t}\n\n\tmutex_unlock(&s->ops_mutex);\n\treturn ret;\n}\n\nstatic ssize_t store_mem_db(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct pcmcia_socket *s = dev_get_drvdata(dev);\n\tunsigned long start_addr, end_addr;\n\tunsigned int add = ADD_MANAGED_RESOURCE;\n\tssize_t ret = 0;\n\n\tret = sscanf(buf, \"+ 0x%lx - 0x%lx\", &start_addr, &end_addr);\n\tif (ret != 2) {\n\t\tret = sscanf(buf, \"- 0x%lx - 0x%lx\", &start_addr, &end_addr);\n\t\tadd = REMOVE_MANAGED_RESOURCE;\n\t\tif (ret != 2) {\n\t\t\tret = sscanf(buf, \"0x%lx - 0x%lx\", &start_addr,\n\t\t\t\t&end_addr);\n\t\t\tadd = ADD_MANAGED_RESOURCE;\n\t\t\tif (ret != 2)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (end_addr < start_addr)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&s->ops_mutex);\n\tret = adjust_memory(s, add, start_addr, end_addr);\n\tmutex_unlock(&s->ops_mutex);\n\n\treturn ret ? ret : count;\n}\nstatic DEVICE_ATTR(available_resources_mem, 0600, show_mem_db, store_mem_db);\n\nstatic struct attribute *pccard_rsrc_attributes[] = {\n\t&dev_attr_available_resources_io.attr,\n\t&dev_attr_available_resources_mem.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rsrc_attributes = {\n\t.attrs = pccard_rsrc_attributes,\n};\n\nstatic int pccard_sysfs_add_rsrc(struct device *dev)\n{\n\tstruct pcmcia_socket *s = dev_get_drvdata(dev);\n\n\tif (s->resource_ops != &pccard_nonstatic_ops)\n\t\treturn 0;\n\treturn sysfs_create_group(&dev->kobj, &rsrc_attributes);\n}\n\nstatic void pccard_sysfs_remove_rsrc(struct device *dev)\n{\n\tstruct pcmcia_socket *s = dev_get_drvdata(dev);\n\n\tif (s->resource_ops != &pccard_nonstatic_ops)\n\t\treturn;\n\tsysfs_remove_group(&dev->kobj, &rsrc_attributes);\n}\n\nstatic struct class_interface pccard_rsrc_interface __refdata = {\n\t.class = &pcmcia_socket_class,\n\t.add_dev = &pccard_sysfs_add_rsrc,\n\t.remove_dev = &pccard_sysfs_remove_rsrc,\n};\n\nstatic int __init nonstatic_sysfs_init(void)\n{\n\treturn class_interface_register(&pccard_rsrc_interface);\n}\n\nstatic void __exit nonstatic_sysfs_exit(void)\n{\n\tclass_interface_unregister(&pccard_rsrc_interface);\n}\n\nmodule_init(nonstatic_sysfs_init);\nmodule_exit(nonstatic_sysfs_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}