{
  "module_name": "xxs1500_ss.c",
  "hash_id": "addad454451661269e82281d283115e11c6db79f536060404bbba175dd0eb172",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/xxs1500_ss.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/resource.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <pcmcia/ss.h>\n#include <pcmcia/cistpl.h>\n\n#include <asm/irq.h>\n#include <asm/mach-au1x00/au1000.h>\n\n#define MEM_MAP_SIZE\t0x400000\n#define IO_MAP_SIZE\t0x1000\n\n\n \n#define GPIO_CDA\t0\n#define GPIO_CDB\t1\n#define GPIO_CARDIRQ\t4\n#define GPIO_RESET\t204\n#define GPIO_OUTEN\t205\n#define GPIO_VSL\t208\n#define GPIO_VSH\t209\n#define GPIO_BATTDEAD\t210\n#define GPIO_BATTWARN\t211\n#define GPIO_POWER\t214\n\nstruct xxs1500_pcmcia_sock {\n\tstruct pcmcia_socket\tsocket;\n\tvoid\t\t*virt_io;\n\n\tphys_addr_t\tphys_io;\n\tphys_addr_t\tphys_attr;\n\tphys_addr_t\tphys_mem;\n\n\t \n\tunsigned int old_flags;\n};\n\n#define to_xxs_socket(x) container_of(x, struct xxs1500_pcmcia_sock, socket)\n\nstatic irqreturn_t cdirq(int irq, void *data)\n{\n\tstruct xxs1500_pcmcia_sock *sock = data;\n\n\tpcmcia_parse_events(&sock->socket, SS_DETECT);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int xxs1500_pcmcia_configure(struct pcmcia_socket *skt,\n\t\t\t\t    struct socket_state_t *state)\n{\n\tstruct xxs1500_pcmcia_sock *sock = to_xxs_socket(skt);\n\tunsigned int changed;\n\n\t \n\tswitch (state->Vcc) {\n\tcase 0:\n\t\tgpio_set_value(GPIO_POWER, 1);\t \n\t\tbreak;\n\tcase 33:\n\t\tgpio_set_value(GPIO_POWER, 0);\t \n\t\tbreak;\n\tcase 50:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tchanged = state->flags ^ sock->old_flags;\n\n\tif (changed & SS_RESET) {\n\t\tif (state->flags & SS_RESET) {\n\t\t\tgpio_set_value(GPIO_RESET, 1);\t \n\t\t\tgpio_set_value(GPIO_OUTEN, 1);\t \n\t\t} else {\n\t\t\tgpio_set_value(GPIO_RESET, 0);\t \n\t\t\tgpio_set_value(GPIO_OUTEN, 0);\t \n\t\t\tmsleep(500);\n\t\t}\n\t}\n\n\tsock->old_flags = state->flags;\n\n\treturn 0;\n}\n\nstatic int xxs1500_pcmcia_get_status(struct pcmcia_socket *skt,\n\t\t\t\t     unsigned int *value)\n{\n\tunsigned int status;\n\tint i;\n\n\tstatus = 0;\n\n\t \n\tif (!gpio_get_value(GPIO_CDA) && !gpio_get_value(GPIO_CDB))\n\t\tstatus |= SS_DETECT;\n\n\t \n\ti = (!!gpio_get_value(GPIO_VSL)) | ((!!gpio_get_value(GPIO_VSH)) << 1);\n\n\tswitch (i) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tstatus |= SS_3VCARD;\t \n\t\tbreak;\n\tcase 3:\t\t\t\t \n\tdefault:\n\t\tstatus |= SS_XVCARD;\t \n\t}\n\n\t \n\tstatus |= gpio_get_value(GPIO_POWER) ? 0 : SS_POWERON;\n\n\t \n\tstatus |= gpio_get_value(GPIO_RESET) ? SS_RESET : SS_READY;\n\n\t \n\tstatus |= gpio_get_value(GPIO_BATTDEAD) ? 0 : SS_BATDEAD;\n\tstatus |= gpio_get_value(GPIO_BATTWARN) ? 0 : SS_BATWARN;\n\n\t*value = status;\n\n\treturn 0;\n}\n\nstatic int xxs1500_pcmcia_sock_init(struct pcmcia_socket *skt)\n{\n\tgpio_direction_input(GPIO_CDA);\n\tgpio_direction_input(GPIO_CDB);\n\tgpio_direction_input(GPIO_VSL);\n\tgpio_direction_input(GPIO_VSH);\n\tgpio_direction_input(GPIO_BATTDEAD);\n\tgpio_direction_input(GPIO_BATTWARN);\n\tgpio_direction_output(GPIO_RESET, 1);\t \n\tgpio_direction_output(GPIO_OUTEN, 1);\t \n\tgpio_direction_output(GPIO_POWER, 1);\t \n\n\treturn 0;\n}\n\nstatic int xxs1500_pcmcia_sock_suspend(struct pcmcia_socket *skt)\n{\n\treturn 0;\n}\n\nstatic int au1x00_pcmcia_set_io_map(struct pcmcia_socket *skt,\n\t\t\t\t    struct pccard_io_map *map)\n{\n\tstruct xxs1500_pcmcia_sock *sock = to_xxs_socket(skt);\n\n\tmap->start = (u32)sock->virt_io;\n\tmap->stop = map->start + IO_MAP_SIZE;\n\n\treturn 0;\n}\n\nstatic int au1x00_pcmcia_set_mem_map(struct pcmcia_socket *skt,\n\t\t\t\t     struct pccard_mem_map *map)\n{\n\tstruct xxs1500_pcmcia_sock *sock = to_xxs_socket(skt);\n\n\tif (map->flags & MAP_ATTRIB)\n\t\tmap->static_start = sock->phys_attr + map->card_start;\n\telse\n\t\tmap->static_start = sock->phys_mem + map->card_start;\n\n\treturn 0;\n}\n\nstatic struct pccard_operations xxs1500_pcmcia_operations = {\n\t.init\t\t\t= xxs1500_pcmcia_sock_init,\n\t.suspend\t\t= xxs1500_pcmcia_sock_suspend,\n\t.get_status\t\t= xxs1500_pcmcia_get_status,\n\t.set_socket\t\t= xxs1500_pcmcia_configure,\n\t.set_io_map\t\t= au1x00_pcmcia_set_io_map,\n\t.set_mem_map\t\t= au1x00_pcmcia_set_mem_map,\n};\n\nstatic int xxs1500_pcmcia_probe(struct platform_device *pdev)\n{\n\tstruct xxs1500_pcmcia_sock *sock;\n\tstruct resource *r;\n\tint ret, irq;\n\n\tsock = kzalloc(sizeof(struct xxs1500_pcmcia_sock), GFP_KERNEL);\n\tif (!sock)\n\t\treturn -ENOMEM;\n\n\tret = -ENODEV;\n\n\t \n\tr = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"pcmcia-attr\");\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"missing 'pcmcia-attr' resource!\\n\");\n\t\tgoto out0;\n\t}\n\tsock->phys_attr = r->start;\n\n\t \n\tr = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"pcmcia-mem\");\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"missing 'pcmcia-mem' resource!\\n\");\n\t\tgoto out0;\n\t}\n\tsock->phys_mem = r->start;\n\n\t \n\tr = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"pcmcia-io\");\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"missing 'pcmcia-io' resource!\\n\");\n\t\tgoto out0;\n\t}\n\tsock->phys_io = r->start;\n\n\n\t \n\tsock->virt_io = (void *)(ioremap(sock->phys_io, IO_MAP_SIZE) -\n\t\t\t\t mips_io_port_base);\n\n\tif (!sock->virt_io) {\n\t\tdev_err(&pdev->dev, \"cannot remap IO area\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out0;\n\t}\n\n\tsock->socket.ops\t= &xxs1500_pcmcia_operations;\n\tsock->socket.owner\t= THIS_MODULE;\n\tsock->socket.pci_irq\t= gpio_to_irq(GPIO_CARDIRQ);\n\tsock->socket.features\t= SS_CAP_STATIC_MAP | SS_CAP_PCCARD;\n\tsock->socket.map_size\t= MEM_MAP_SIZE;\n\tsock->socket.io_offset\t= (unsigned long)sock->virt_io;\n\tsock->socket.dev.parent\t= &pdev->dev;\n\tsock->socket.resource_ops = &pccard_static_ops;\n\n\tplatform_set_drvdata(pdev, sock);\n\n\t \n\tirq = gpio_to_irq(GPIO_CDA);\n\tirq_set_irq_type(irq, IRQ_TYPE_EDGE_BOTH);\n\tret = request_irq(irq, cdirq, 0, \"pcmcia_carddetect\", sock);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot setup cd irq\\n\");\n\t\tgoto out1;\n\t}\n\n\tret = pcmcia_register_socket(&sock->socket);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register\\n\");\n\t\tgoto out2;\n\t}\n\n\tprintk(KERN_INFO \"MyCable XXS1500 PCMCIA socket services\\n\");\n\n\treturn 0;\n\nout2:\n\tfree_irq(gpio_to_irq(GPIO_CDA), sock);\nout1:\n\tiounmap((void *)(sock->virt_io + (u32)mips_io_port_base));\nout0:\n\tkfree(sock);\n\treturn ret;\n}\n\nstatic int xxs1500_pcmcia_remove(struct platform_device *pdev)\n{\n\tstruct xxs1500_pcmcia_sock *sock = platform_get_drvdata(pdev);\n\n\tpcmcia_unregister_socket(&sock->socket);\n\tfree_irq(gpio_to_irq(GPIO_CDA), sock);\n\tiounmap((void *)(sock->virt_io + (u32)mips_io_port_base));\n\tkfree(sock);\n\n\treturn 0;\n}\n\nstatic struct platform_driver xxs1500_pcmcia_socket_driver = {\n\t.driver\t= {\n\t\t.name\t= \"xxs1500_pcmcia\",\n\t},\n\t.probe\t\t= xxs1500_pcmcia_probe,\n\t.remove\t\t= xxs1500_pcmcia_remove,\n};\n\nmodule_platform_driver(xxs1500_pcmcia_socket_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"PCMCIA Socket Services for MyCable XXS1500 systems\");\nMODULE_AUTHOR(\"Manuel Lauss\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}