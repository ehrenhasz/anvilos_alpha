{
  "module_name": "i82092.c",
  "hash_id": "546c6c24e6de9b32ffbd26e5c4ab39314b37c13a15a82151bd8f173b03590397",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/i82092.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n\n#include <pcmcia/ss.h>\n\n#include <linux/io.h>\n\n#include \"i82092aa.h\"\n#include \"i82365.h\"\n\nMODULE_LICENSE(\"GPL\");\n\n \nstatic const struct pci_device_id i82092aa_pci_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82092AA_0) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, i82092aa_pci_ids);\n\nstatic struct pci_driver i82092aa_pci_driver = {\n\t.name\t\t= \"i82092aa\",\n\t.id_table\t= i82092aa_pci_ids,\n\t.probe\t\t= i82092aa_pci_probe,\n\t.remove\t= i82092aa_pci_remove,\n};\n\n\n \nstatic struct pccard_operations i82092aa_operations = {\n\t.init\t\t\t= i82092aa_init,\n\t.get_status\t\t= i82092aa_get_status,\n\t.set_socket\t\t= i82092aa_set_socket,\n\t.set_io_map\t\t= i82092aa_set_io_map,\n\t.set_mem_map\t\t= i82092aa_set_mem_map,\n};\n\n \n\nstruct socket_info {\n\tint\tnumber;\n\tint\tcard_state;\n\t\t \n\tunsigned int io_base;\t \n\n\tstruct pcmcia_socket socket;\n\tstruct pci_dev *dev;\t \n};\n\n#define MAX_SOCKETS 4\nstatic struct socket_info sockets[MAX_SOCKETS];\nstatic int socket_count;\t \n\n\nstatic int i82092aa_pci_probe(struct pci_dev *dev,\n\t\t\t      const struct pci_device_id *id)\n{\n\tunsigned char configbyte;\n\tint i, ret;\n\n\tret = pci_enable_device(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpci_read_config_byte(dev, 0x40, &configbyte);\n\n\tswitch (configbyte&6) {\n\tcase 0:\n\t\tsocket_count = 2;\n\t\tbreak;\n\tcase 2:\n\t\tsocket_count = 1;\n\t\tbreak;\n\tcase 4:\n\tcase 6:\n\t\tsocket_count = 4;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&dev->dev,\n\t\t\t\"Oops, you did something we didn't think of.\\n\");\n\t\tret = -EIO;\n\t\tgoto err_out_disable;\n\t}\n\tdev_info(&dev->dev, \"configured as a %d socket device.\\n\",\n\t\t socket_count);\n\n\tif (!request_region(pci_resource_start(dev, 0), 2, \"i82092aa\")) {\n\t\tret = -EBUSY;\n\t\tgoto err_out_disable;\n\t}\n\n\tfor (i = 0; i < socket_count; i++) {\n\t\tsockets[i].card_state = 1;  \n\t\tsockets[i].io_base = pci_resource_start(dev, 0);\n\t\tsockets[i].dev = dev;\n\t\tsockets[i].socket.features |= SS_CAP_PCCARD;\n\t\tsockets[i].socket.map_size = 0x1000;\n\t\tsockets[i].socket.irq_mask = 0;\n\t\tsockets[i].socket.pci_irq  = dev->irq;\n\t\tsockets[i].socket.cb_dev  = dev;\n\t\tsockets[i].socket.owner = THIS_MODULE;\n\n\t\tsockets[i].number = i;\n\n\t\tif (card_present(i)) {\n\t\t\tsockets[i].card_state = 3;\n\t\t\tdev_dbg(&dev->dev, \"slot %i is occupied\\n\", i);\n\t\t} else {\n\t\t\tdev_dbg(&dev->dev, \"slot %i is vacant\\n\", i);\n\t\t}\n\t}\n\n\t \n\tconfigbyte = 0xFF;\n\n\t \n\tpci_write_config_byte(dev, 0x50, configbyte);\n\n\t \n\tdev_dbg(&dev->dev, \"Requesting interrupt %i\\n\", dev->irq);\n\tret = request_irq(dev->irq, i82092aa_interrupt, IRQF_SHARED,\n\t\t\t  \"i82092aa\", i82092aa_interrupt);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"Failed to register IRQ %d, aborting\\n\",\n\t\t\tdev->irq);\n\t\tgoto err_out_free_res;\n\t}\n\n\tfor (i = 0; i < socket_count; i++) {\n\t\tsockets[i].socket.dev.parent = &dev->dev;\n\t\tsockets[i].socket.ops = &i82092aa_operations;\n\t\tsockets[i].socket.resource_ops = &pccard_nonstatic_ops;\n\t\tret = pcmcia_register_socket(&sockets[i].socket);\n\t\tif (ret)\n\t\t\tgoto err_out_free_sockets;\n\t}\n\n\treturn 0;\n\nerr_out_free_sockets:\n\tif (i) {\n\t\tfor (i--; i >= 0; i--)\n\t\t\tpcmcia_unregister_socket(&sockets[i].socket);\n\t}\n\tfree_irq(dev->irq, i82092aa_interrupt);\nerr_out_free_res:\n\trelease_region(pci_resource_start(dev, 0), 2);\nerr_out_disable:\n\tpci_disable_device(dev);\n\treturn ret;\n}\n\nstatic void i82092aa_pci_remove(struct pci_dev *dev)\n{\n\tint i;\n\n\tfree_irq(dev->irq, i82092aa_interrupt);\n\n\tfor (i = 0; i < socket_count; i++)\n\t\tpcmcia_unregister_socket(&sockets[i].socket);\n}\n\nstatic DEFINE_SPINLOCK(port_lock);\n\n \n\nstatic unsigned char indirect_read(int socket, unsigned short reg)\n{\n\tunsigned short int port;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port_lock, flags);\n\treg += socket * 0x40;\n\tport = sockets[socket].io_base;\n\toutb(reg, port);\n\tval = inb(port+1);\n\tspin_unlock_irqrestore(&port_lock, flags);\n\treturn val;\n}\n\nstatic void indirect_write(int socket, unsigned short reg, unsigned char value)\n{\n\tunsigned short int port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port_lock, flags);\n\treg = reg + socket * 0x40;\n\tport = sockets[socket].io_base;\n\toutb(reg, port);\n\toutb(value, port+1);\n\tspin_unlock_irqrestore(&port_lock, flags);\n}\n\nstatic void indirect_setbit(int socket, unsigned short reg, unsigned char mask)\n{\n\tunsigned short int port;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port_lock, flags);\n\treg = reg + socket * 0x40;\n\tport = sockets[socket].io_base;\n\toutb(reg, port);\n\tval = inb(port+1);\n\tval |= mask;\n\toutb(reg, port);\n\toutb(val, port+1);\n\tspin_unlock_irqrestore(&port_lock, flags);\n}\n\n\nstatic void indirect_resetbit(int socket,\n\t\t\t      unsigned short reg, unsigned char mask)\n{\n\tunsigned short int port;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port_lock, flags);\n\treg = reg + socket * 0x40;\n\tport = sockets[socket].io_base;\n\toutb(reg, port);\n\tval = inb(port+1);\n\tval &= ~mask;\n\toutb(reg, port);\n\toutb(val, port+1);\n\tspin_unlock_irqrestore(&port_lock, flags);\n}\n\nstatic void indirect_write16(int socket,\n\t\t\t     unsigned short reg, unsigned short value)\n{\n\tunsigned short int port;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port_lock, flags);\n\treg = reg + socket * 0x40;\n\tport = sockets[socket].io_base;\n\n\toutb(reg, port);\n\tval = value & 255;\n\toutb(val, port+1);\n\n\treg++;\n\n\toutb(reg, port);\n\tval = value>>8;\n\toutb(val, port+1);\n\tspin_unlock_irqrestore(&port_lock, flags);\n}\n\n \n \nstatic int cycle_time = 120;\n\nstatic int to_cycles(int ns)\n{\n\tif (cycle_time != 0)\n\t\treturn ns/cycle_time;\n\telse\n\t\treturn 0;\n}\n\n\n \n\nstatic irqreturn_t i82092aa_interrupt(int irq, void *dev)\n{\n\tint i;\n\tint loopcount = 0;\n\tint handled = 0;\n\n\tunsigned int events, active = 0;\n\n\twhile (1) {\n\t\tloopcount++;\n\t\tif (loopcount > 20) {\n\t\t\tpr_err(\"i82092aa: infinite eventloop in interrupt\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tactive = 0;\n\n\t\tfor (i = 0; i < socket_count; i++) {\n\t\t\tint csc;\n\n\t\t\t \n\t\t\tif (sockets[i].card_state == 0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tcsc = indirect_read(i, I365_CSC);\n\n\t\t\tif (csc == 0)   \n\t\t\t\tcontinue;\n\t\t\thandled = 1;\n\t\t\tevents = 0;\n\n\t\t\tif (csc & I365_CSC_DETECT) {\n\t\t\t\tevents |= SS_DETECT;\n\t\t\t\tdev_info(&sockets[i].dev->dev,\n\t\t\t\t\t \"Card detected in socket %i!\\n\", i);\n\t\t\t}\n\n\t\t\tif (indirect_read(i, I365_INTCTL) & I365_PC_IOCARD) {\n\t\t\t\t \n\t\t\t\tif (csc & I365_CSC_STSCHG)\n\t\t\t\t\tevents |= SS_STSCHG;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (csc & I365_CSC_BVD1)\n\t\t\t\t\tevents |= SS_BATDEAD;\n\t\t\t\tif (csc & I365_CSC_BVD2)\n\t\t\t\t\tevents |= SS_BATWARN;\n\t\t\t\tif (csc & I365_CSC_READY)\n\t\t\t\t\tevents |= SS_READY;\n\t\t\t}\n\n\t\t\tif (events)\n\t\t\t\tpcmcia_parse_events(&sockets[i].socket, events);\n\t\t\tactive |= events;\n\t\t}\n\n\t\tif (active == 0)  \n\t\t\tbreak;\n\t}\n\treturn IRQ_RETVAL(handled);\n}\n\n\n\n \n\nstatic int card_present(int socketno)\n{\n\tunsigned int val;\n\n\tif ((socketno < 0) || (socketno >= MAX_SOCKETS))\n\t\treturn 0;\n\tif (sockets[socketno].io_base == 0)\n\t\treturn 0;\n\n\n\tval = indirect_read(socketno, 1);  \n\tif ((val&12) == 12)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void set_bridge_state(int sock)\n{\n\tindirect_write(sock, I365_GBLCTL, 0x00);\n\tindirect_write(sock, I365_GENCTL, 0x00);\n\n\tindirect_setbit(sock, I365_INTCTL, 0x08);\n}\n\n\nstatic int i82092aa_init(struct pcmcia_socket *sock)\n{\n\tint i;\n\tstruct resource res = { .start = 0, .end = 0x0fff };\n\tpccard_io_map io = { 0, 0, 0, 0, 1 };\n\tpccard_mem_map mem = { .res = &res, };\n\n\tfor (i = 0; i < 2; i++) {\n\t\tio.map = i;\n\t\ti82092aa_set_io_map(sock, &io);\n\t}\n\tfor (i = 0; i < 5; i++) {\n\t\tmem.map = i;\n\t\ti82092aa_set_mem_map(sock, &mem);\n\t}\n\n\treturn 0;\n}\n\nstatic int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)\n{\n\tunsigned int sock = container_of(socket,\n\t\t\t\tstruct socket_info, socket)->number;\n\tunsigned int status;\n\n\t \n\tstatus = indirect_read(sock, I365_STATUS);\n\n\t*value = 0;\n\n\tif ((status & I365_CS_DETECT) == I365_CS_DETECT)\n\t\t*value |= SS_DETECT;\n\n\t \n\t \n\tif (indirect_read(sock, I365_INTCTL) & I365_PC_IOCARD) {\n\t\t \n\t\tif (!(status & I365_CS_STSCHG))\n\t\t\t*value |= SS_STSCHG;\n\t} else {  \n\t\tif (!(status & I365_CS_BVD1))\n\t\t\t*value |= SS_BATDEAD;\n\t\tif (!(status & I365_CS_BVD2))\n\t\t\t*value |= SS_BATWARN;\n\t}\n\n\tif (status & I365_CS_WRPROT)\n\t\t(*value) |= SS_WRPROT;\t \n\n\tif (status & I365_CS_READY)\n\t\t(*value) |= SS_READY;     \n\n\tif (status & I365_CS_POWERON)\n\t\t(*value) |= SS_POWERON;   \n\n\treturn 0;\n}\n\n\nstatic int i82092aa_set_socket(struct pcmcia_socket *socket,\n\t\t\t       socket_state_t *state)\n{\n\tstruct socket_info *sock_info = container_of(socket, struct socket_info,\n\t\t\t\t\t\t     socket);\n\tunsigned int sock = sock_info->number;\n\tunsigned char reg;\n\n\t \n\n\tset_bridge_state(sock);\n\n\t \n\n\treg = 0;\n\n\t \n\tif (!(state->flags & SS_RESET))\n\t\treg = reg | I365_PC_RESET;\n\tif (state->flags & SS_IOCARD)\n\t\treg = reg | I365_PC_IOCARD;\n\n\t \n\tindirect_write(sock, I365_INTCTL, reg);\n\n\t \n\n\treg = I365_PWR_NORESET;  \n\n\tif (state->flags & SS_PWR_AUTO) {\n\t\tdev_info(&sock_info->dev->dev, \"Auto power\\n\");\n\t\treg |= I365_PWR_AUTO;\t \n\t}\n\tif (state->flags & SS_OUTPUT_ENA) {\n\t\tdev_info(&sock_info->dev->dev, \"Power Enabled\\n\");\n\t\treg |= I365_PWR_OUT;\t \n\t}\n\n\tswitch (state->Vcc) {\n\tcase 0:\n\t\tbreak;\n\tcase 50:\n\t\tdev_info(&sock_info->dev->dev,\n\t\t\t \"setting voltage to Vcc to 5V on socket %i\\n\",\n\t\t\t sock);\n\t\treg |= I365_VCC_5V;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&sock_info->dev->dev,\n\t\t\t\"%s called with invalid VCC power value: %i\",\n\t\t\t__func__, state->Vcc);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (state->Vpp) {\n\tcase 0:\n\t\tdev_info(&sock_info->dev->dev,\n\t\t\t \"not setting Vpp on socket %i\\n\", sock);\n\t\tbreak;\n\tcase 50:\n\t\tdev_info(&sock_info->dev->dev,\n\t\t\t \"setting Vpp to 5.0 for socket %i\\n\", sock);\n\t\treg |= I365_VPP1_5V | I365_VPP2_5V;\n\t\tbreak;\n\tcase 120:\n\t\tdev_info(&sock_info->dev->dev, \"setting Vpp to 12.0\\n\");\n\t\treg |= I365_VPP1_12V | I365_VPP2_12V;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&sock_info->dev->dev,\n\t\t\t\"%s called with invalid VPP power value: %i\",\n\t\t\t__func__, state->Vcc);\n\t\treturn -EINVAL;\n\t}\n\n\tif (reg != indirect_read(sock, I365_POWER))  \n\t\tindirect_write(sock, I365_POWER, reg);\n\n\t \n\n\treg = 0x00;\n\tif (state->csc_mask & SS_DETECT)\n\t\treg |= I365_CSC_DETECT;\n\tif (state->flags & SS_IOCARD) {\n\t\tif (state->csc_mask & SS_STSCHG)\n\t\t\treg |= I365_CSC_STSCHG;\n\t} else {\n\t\tif (state->csc_mask & SS_BATDEAD)\n\t\t\treg |= I365_CSC_BVD1;\n\t\tif (state->csc_mask & SS_BATWARN)\n\t\t\treg |= I365_CSC_BVD2;\n\t\tif (state->csc_mask & SS_READY)\n\t\t\treg |= I365_CSC_READY;\n\n\t}\n\n\t \n\n\tindirect_write(sock, I365_CSCINT, reg);\n\t(void)indirect_read(sock, I365_CSC);\n\n\treturn 0;\n}\n\nstatic int i82092aa_set_io_map(struct pcmcia_socket *socket,\n\t\t\t       struct pccard_io_map *io)\n{\n\tstruct socket_info *sock_info = container_of(socket, struct socket_info,\n\t\t\t\t\t\t     socket);\n\tunsigned int sock = sock_info->number;\n\tunsigned char map, ioctl;\n\n\tmap = io->map;\n\n\t \n\tif (map > 1)\n\t\treturn -EINVAL;\n\n\tif ((io->start > 0xffff) || (io->stop > 0xffff)\n\t\t\t\t || (io->stop < io->start))\n\t\treturn -EINVAL;\n\n\t \n\tif (indirect_read(sock, I365_ADDRWIN) & I365_ENA_IO(map))\n\t\tindirect_resetbit(sock, I365_ADDRWIN, I365_ENA_IO(map));\n\n\t \n\tindirect_write16(sock, I365_IO(map)+I365_W_START, io->start);\n\tindirect_write16(sock, I365_IO(map)+I365_W_STOP, io->stop);\n\n\tioctl = indirect_read(sock, I365_IOCTL) & ~I365_IOCTL_MASK(map);\n\n\tif (io->flags & (MAP_16BIT|MAP_AUTOSZ))\n\t\tioctl |= I365_IOCTL_16BIT(map);\n\n\tindirect_write(sock, I365_IOCTL, ioctl);\n\n\t \n\tif (io->flags & MAP_ACTIVE)\n\t\tindirect_setbit(sock, I365_ADDRWIN, I365_ENA_IO(map));\n\n\treturn 0;\n}\n\nstatic int i82092aa_set_mem_map(struct pcmcia_socket *socket,\n\t\t\t\tstruct pccard_mem_map *mem)\n{\n\tstruct socket_info *sock_info = container_of(socket, struct socket_info,\n\t\t\t\t\t\t     socket);\n\tunsigned int sock = sock_info->number;\n\tstruct pci_bus_region region;\n\tunsigned short base, i;\n\tunsigned char map;\n\n\tpcibios_resource_to_bus(sock_info->dev->bus, &region, mem->res);\n\n\tmap = mem->map;\n\tif (map > 4)\n\t\treturn -EINVAL;\n\n\tif ((mem->card_start > 0x3ffffff) || (region.start > region.end) ||\n\t     (mem->speed > 1000)) {\n\t\tdev_err(&sock_info->dev->dev,\n\t\t\t\"invalid mem map for socket %i: %llx to %llx with a start of %x\\n\",\n\t\t\tsock,\n\t\t\t(unsigned long long)region.start,\n\t\t\t(unsigned long long)region.end,\n\t\t\tmem->card_start);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (indirect_read(sock, I365_ADDRWIN) & I365_ENA_MEM(map))\n\t\tindirect_resetbit(sock, I365_ADDRWIN, I365_ENA_MEM(map));\n\n\t \n\tbase = I365_MEM(map);\n\ti = (region.start >> 12) & 0x0fff;\n\tif (mem->flags & MAP_16BIT)\n\t\ti |= I365_MEM_16BIT;\n\tif (mem->flags & MAP_0WS)\n\t\ti |= I365_MEM_0WS;\n\tindirect_write16(sock, base+I365_W_START, i);\n\n\t \n\n\ti = (region.end >> 12) & 0x0fff;\n\tswitch (to_cycles(mem->speed)) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\ti |= I365_MEM_WS0;\n\t\tbreak;\n\tcase 2:\n\t\ti |= I365_MEM_WS1;\n\t\tbreak;\n\tdefault:\n\t\ti |= I365_MEM_WS1 | I365_MEM_WS0;\n\t\tbreak;\n\t}\n\n\tindirect_write16(sock, base+I365_W_STOP, i);\n\n\t \n\n\ti = ((mem->card_start - region.start) >> 12) & 0x3fff;\n\tif (mem->flags & MAP_WRPROT)\n\t\ti |= I365_MEM_WRPROT;\n\tif (mem->flags & MAP_ATTRIB)\n\t\ti |= I365_MEM_REG;\n\tindirect_write16(sock, base+I365_W_OFF, i);\n\n\t \n\tif (mem->flags & MAP_ACTIVE)\n\t\tindirect_setbit(sock, I365_ADDRWIN, I365_ENA_MEM(map));\n\n\treturn 0;\n}\n\nstatic int __init i82092aa_module_init(void)\n{\n\treturn pci_register_driver(&i82092aa_pci_driver);\n}\n\nstatic void __exit i82092aa_module_exit(void)\n{\n\tpci_unregister_driver(&i82092aa_pci_driver);\n\tif (sockets[0].io_base > 0)\n\t\trelease_region(sockets[0].io_base, 2);\n}\n\nmodule_init(i82092aa_module_init);\nmodule_exit(i82092aa_module_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}