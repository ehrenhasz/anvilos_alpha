{
  "module_name": "bcm63xx_pcmcia.c",
  "hash_id": "931b0b8c80dc3df74404b867ba346db81614b7bc83c1dbb480bba4a7defbdf74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pcmcia/bcm63xx_pcmcia.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/timer.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/gpio.h>\n\n#include <bcm63xx_regs.h>\n#include <bcm63xx_io.h>\n#include \"bcm63xx_pcmcia.h\"\n\n#define PFX\t\"bcm63xx_pcmcia: \"\n\n#ifdef CONFIG_CARDBUS\n \nstatic struct pci_dev *bcm63xx_cb_dev;\n#endif\n\n \nstatic inline u32 pcmcia_readl(struct bcm63xx_pcmcia_socket *skt, u32 off)\n{\n\treturn bcm_readl(skt->base + off);\n}\n\nstatic inline void pcmcia_writel(struct bcm63xx_pcmcia_socket *skt,\n\t\t\t\t u32 val, u32 off)\n{\n\tbcm_writel(val, skt->base + off);\n}\n\n \nstatic int bcm63xx_pcmcia_sock_init(struct pcmcia_socket *sock)\n{\n\treturn 0;\n}\n\n \nstatic int bcm63xx_pcmcia_suspend(struct pcmcia_socket *sock)\n{\n\treturn 0;\n}\n\n \nstatic int bcm63xx_pcmcia_set_socket(struct pcmcia_socket *sock,\n\t\t\t\t     socket_state_t *state)\n{\n\tstruct bcm63xx_pcmcia_socket *skt;\n\tunsigned long flags;\n\tu32 val;\n\n\tskt = sock->driver_data;\n\n\tspin_lock_irqsave(&skt->lock, flags);\n\n\t \n\n\t \n\tval = pcmcia_readl(skt, PCMCIA_C1_REG);\n\tif (state->flags & SS_RESET)\n\t\tval |= PCMCIA_C1_RESET_MASK;\n\telse\n\t\tval &= ~PCMCIA_C1_RESET_MASK;\n\n\t \n\tif (skt->card_detected && (skt->card_type & CARD_CARDBUS))\n\t\tval ^= PCMCIA_C1_RESET_MASK;\n\n\tpcmcia_writel(skt, val, PCMCIA_C1_REG);\n\n\t \n\tskt->requested_state = *state;\n\n\tspin_unlock_irqrestore(&skt->lock, flags);\n\n\treturn 0;\n}\n\n \nenum {\n\tIN_VS1 = (1 << 0),\n\tIN_VS2 = (1 << 1),\n\tIN_CD1_VS2H = (1 << 2),\n\tIN_CD2_VS2H = (1 << 3),\n\tIN_CD1_VS1H = (1 << 4),\n\tIN_CD2_VS1H = (1 << 5),\n};\n\nstatic const u8 vscd_to_cardtype[] = {\n\n\t \n\t[IN_VS1 | IN_VS2] = (CARD_PCCARD | CARD_5V),\n\n\t \n\t[IN_VS2] = (CARD_PCCARD | CARD_5V | CARD_3V),\n\n\t \n\t[0] = (CARD_PCCARD | CARD_5V | CARD_3V | CARD_XV),\n\n\t \n\t[IN_VS1 | IN_VS2 | IN_CD1_VS1H] = (CARD_CARDBUS | CARD_3V),\n\n\t \n\t[IN_VS2 | IN_CD2_VS2H] = (CARD_CARDBUS | CARD_3V | CARD_XV),\n\n\t \n\t[IN_VS1 | IN_CD2_VS1H] = (CARD_CARDBUS | CARD_3V | CARD_XV | CARD_YV),\n\n\t \n\t[IN_VS1] = (CARD_PCCARD | CARD_XV),\n\n\t \n\t[IN_VS1 | IN_VS2 | IN_CD2_VS2H] = (CARD_CARDBUS | CARD_3V),\n\n\t \n\t[IN_VS1 | IN_VS2 | IN_CD1_VS2H] = (CARD_CARDBUS | CARD_XV | CARD_YV),\n\n\t \n\t[IN_VS1 | IN_VS2 | IN_CD2_VS1H] = (CARD_CARDBUS | CARD_YV),\n\n\t \n\t[IN_VS1 | IN_CD1_VS1H] = 0,  \n};\n\n \nstatic unsigned int __get_socket_status(struct bcm63xx_pcmcia_socket *skt)\n{\n\tunsigned int stat;\n\tu32 val;\n\n\tstat = 0;\n\n\t \n\tval = pcmcia_readl(skt, PCMCIA_C1_REG);\n\n\tif (!(val & PCMCIA_C1_CD1_MASK) && !(val & PCMCIA_C1_CD2_MASK))\n\t\tstat |= SS_DETECT;\n\n\t \n\tif ((stat & SS_DETECT) && !skt->card_detected) {\n\t\tunsigned int stat = 0;\n\n\t\t \n\t\tval |= PCMCIA_C1_VS1OE_MASK;\n\t\tval |= PCMCIA_C1_VS2OE_MASK;\n\t\tpcmcia_writel(skt, val, PCMCIA_C1_REG);\n\n\t\t \n\t\tudelay(10);\n\t\tval = pcmcia_readl(skt, PCMCIA_C1_REG);\n\t\tstat |= (val & PCMCIA_C1_VS1_MASK) ? IN_VS1 : 0;\n\t\tstat |= (val & PCMCIA_C1_VS2_MASK) ? IN_VS2 : 0;\n\n\t\t \n\t\tval &= ~PCMCIA_C1_VS1OE_MASK;\n\t\tval |= PCMCIA_C1_VS2OE_MASK;\n\t\tpcmcia_writel(skt, val, PCMCIA_C1_REG);\n\n\t\t \n\t\tudelay(10);\n\t\tval = pcmcia_readl(skt, PCMCIA_C1_REG);\n\t\tstat |= (val & PCMCIA_C1_CD1_MASK) ? IN_CD1_VS2H : 0;\n\t\tstat |= (val & PCMCIA_C1_CD2_MASK) ? IN_CD2_VS2H : 0;\n\n\t\t \n\t\tval |= PCMCIA_C1_VS1OE_MASK;\n\t\tval &= ~PCMCIA_C1_VS2OE_MASK;\n\t\tpcmcia_writel(skt, val, PCMCIA_C1_REG);\n\n\t\t \n\t\tudelay(10);\n\t\tval = pcmcia_readl(skt, PCMCIA_C1_REG);\n\t\tstat |= (val & PCMCIA_C1_CD1_MASK) ? IN_CD1_VS1H : 0;\n\t\tstat |= (val & PCMCIA_C1_CD2_MASK) ? IN_CD2_VS1H : 0;\n\n\t\t \n\t\tskt->card_type = vscd_to_cardtype[stat];\n\t\tif (!skt->card_type)\n\t\t\tdev_err(&skt->socket.dev, \"unsupported card type\\n\");\n\n\t\t \n\t\tval &= ~(PCMCIA_C1_VS1OE_MASK | PCMCIA_C1_VS2OE_MASK);\n\n\t\t \n\t\tval &= ~(PCMCIA_C1_EN_PCMCIA_MASK | PCMCIA_C1_EN_CARDBUS_MASK);\n\t\tif (skt->card_type & CARD_PCCARD)\n\t\t\tval |= PCMCIA_C1_EN_PCMCIA_MASK;\n\t\telse\n\t\t\tval |= PCMCIA_C1_EN_CARDBUS_MASK;\n\n\t\tpcmcia_writel(skt, val, PCMCIA_C1_REG);\n\t}\n\tskt->card_detected = (stat & SS_DETECT) ? 1 : 0;\n\n\t \n\tif (skt->card_type & CARD_CARDBUS)\n\t\tstat |= SS_CARDBUS;\n\tif (skt->card_type & CARD_3V)\n\t\tstat |= SS_3VCARD;\n\tif (skt->card_type & CARD_XV)\n\t\tstat |= SS_XVCARD;\n\tstat |= SS_POWERON;\n\n\tif (gpio_get_value(skt->pd->ready_gpio))\n\t\tstat |= SS_READY;\n\n\treturn stat;\n}\n\n \nstatic int bcm63xx_pcmcia_get_status(struct pcmcia_socket *sock,\n\t\t\t\t     unsigned int *status)\n{\n\tstruct bcm63xx_pcmcia_socket *skt;\n\n\tskt = sock->driver_data;\n\n\tspin_lock_bh(&skt->lock);\n\t*status = __get_socket_status(skt);\n\tspin_unlock_bh(&skt->lock);\n\n\treturn 0;\n}\n\n \nstatic void bcm63xx_pcmcia_poll(struct timer_list *t)\n{\n\tstruct bcm63xx_pcmcia_socket *skt;\n\tunsigned int stat, events;\n\n\tskt = from_timer(skt, t, timer);\n\n\tspin_lock_bh(&skt->lock);\n\n\tstat = __get_socket_status(skt);\n\n\t \n\tevents = (stat ^ skt->old_status) & skt->requested_state.csc_mask;\n\tskt->old_status = stat;\n\tspin_unlock_bh(&skt->lock);\n\n\tif (events)\n\t\tpcmcia_parse_events(&skt->socket, events);\n\n\tmod_timer(&skt->timer,\n\t\t  jiffies + msecs_to_jiffies(BCM63XX_PCMCIA_POLL_RATE));\n}\n\nstatic int bcm63xx_pcmcia_set_io_map(struct pcmcia_socket *sock,\n\t\t\t\t     struct pccard_io_map *map)\n{\n\t \n\treturn 0;\n}\n\nstatic int bcm63xx_pcmcia_set_mem_map(struct pcmcia_socket *sock,\n\t\t\t\t      struct pccard_mem_map *map)\n{\n\tstruct bcm63xx_pcmcia_socket *skt;\n\tstruct resource *res;\n\n\tskt = sock->driver_data;\n\tif (map->flags & MAP_ATTRIB)\n\t\tres = skt->attr_res;\n\telse\n\t\tres = skt->common_res;\n\n\tmap->static_start = res->start + map->card_start;\n\treturn 0;\n}\n\nstatic struct pccard_operations bcm63xx_pcmcia_operations = {\n\t.init\t\t\t= bcm63xx_pcmcia_sock_init,\n\t.suspend\t\t= bcm63xx_pcmcia_suspend,\n\t.get_status\t\t= bcm63xx_pcmcia_get_status,\n\t.set_socket\t\t= bcm63xx_pcmcia_set_socket,\n\t.set_io_map\t\t= bcm63xx_pcmcia_set_io_map,\n\t.set_mem_map\t\t= bcm63xx_pcmcia_set_mem_map,\n};\n\n \nstatic int bcm63xx_drv_pcmcia_probe(struct platform_device *pdev)\n{\n\tstruct bcm63xx_pcmcia_socket *skt;\n\tstruct pcmcia_socket *sock;\n\tstruct resource *res;\n\tunsigned int regmem_size = 0, iomem_size = 0;\n\tu32 val;\n\tint ret;\n\tint irq;\n\n\tskt = kzalloc(sizeof(*skt), GFP_KERNEL);\n\tif (!skt)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&skt->lock);\n\tsock = &skt->socket;\n\tsock->driver_data = skt;\n\n\t \n\tskt->common_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tskt->attr_res = platform_get_resource(pdev, IORESOURCE_MEM, 2);\n\tirq = platform_get_irq(pdev, 0);\n\tskt->pd = pdev->dev.platform_data;\n\tif (!skt->common_res || !skt->attr_res || (irq < 0) || !skt->pd) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tregmem_size = resource_size(res);\n\tif (!request_mem_region(res->start, regmem_size, \"bcm63xx_pcmcia\")) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tskt->reg_res = res;\n\n\tskt->base = ioremap(res->start, regmem_size);\n\tif (!skt->base) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 3);\n\tiomem_size = resource_size(res);\n\tskt->io_base = ioremap(res->start, iomem_size);\n\tif (!skt->io_base) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tsock->resource_ops = &pccard_static_ops;\n\tsock->ops = &bcm63xx_pcmcia_operations;\n\tsock->owner = THIS_MODULE;\n\tsock->dev.parent = &pdev->dev;\n\tsock->features = SS_CAP_STATIC_MAP | SS_CAP_PCCARD;\n\tsock->io_offset = (unsigned long)skt->io_base;\n\tsock->pci_irq = irq;\n\n#ifdef CONFIG_CARDBUS\n\tsock->cb_dev = bcm63xx_cb_dev;\n\tif (bcm63xx_cb_dev)\n\t\tsock->features |= SS_CAP_CARDBUS;\n#endif\n\n\t \n\tsock->map_size = resource_size(skt->common_res);\n\n\t \n\ttimer_setup(&skt->timer, bcm63xx_pcmcia_poll, 0);\n\n\t \n\tval = pcmcia_readl(skt, PCMCIA_C1_REG);\n\tval &= PCMCIA_C1_CBIDSEL_MASK;\n\tval |= PCMCIA_C1_EN_PCMCIA_GPIO_MASK;\n\tpcmcia_writel(skt, val, PCMCIA_C1_REG);\n\n\t \n\tval = PCMCIA_C2_DATA16_MASK;\n\tval |= 10 << PCMCIA_C2_RWCOUNT_SHIFT;\n\tval |= 6 << PCMCIA_C2_INACTIVE_SHIFT;\n\tval |= 3 << PCMCIA_C2_SETUP_SHIFT;\n\tval |= 3 << PCMCIA_C2_HOLD_SHIFT;\n\tpcmcia_writel(skt, val, PCMCIA_C2_REG);\n\n\tret = pcmcia_register_socket(sock);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tmod_timer(&skt->timer,\n\t\t  jiffies + msecs_to_jiffies(BCM63XX_PCMCIA_POLL_RATE));\n\n\tplatform_set_drvdata(pdev, skt);\n\treturn 0;\n\nerr:\n\tif (skt->io_base)\n\t\tiounmap(skt->io_base);\n\tif (skt->base)\n\t\tiounmap(skt->base);\n\tif (skt->reg_res)\n\t\trelease_mem_region(skt->reg_res->start, regmem_size);\n\tkfree(skt);\n\treturn ret;\n}\n\nstatic int bcm63xx_drv_pcmcia_remove(struct platform_device *pdev)\n{\n\tstruct bcm63xx_pcmcia_socket *skt;\n\tstruct resource *res;\n\n\tskt = platform_get_drvdata(pdev);\n\ttimer_shutdown_sync(&skt->timer);\n\tiounmap(skt->base);\n\tiounmap(skt->io_base);\n\tres = skt->reg_res;\n\trelease_mem_region(res->start, resource_size(res));\n\tkfree(skt);\n\treturn 0;\n}\n\nstruct platform_driver bcm63xx_pcmcia_driver = {\n\t.probe\t= bcm63xx_drv_pcmcia_probe,\n\t.remove\t= bcm63xx_drv_pcmcia_remove,\n\t.driver\t= {\n\t\t.name\t= \"bcm63xx_pcmcia\",\n\t\t.owner  = THIS_MODULE,\n\t},\n};\n\n#ifdef CONFIG_CARDBUS\nstatic int bcm63xx_cb_probe(struct pci_dev *dev,\n\t\t\t\t      const struct pci_device_id *id)\n{\n\t \n\tbcm63xx_cb_dev = dev;\n\treturn platform_driver_register(&bcm63xx_pcmcia_driver);\n}\n\nstatic void bcm63xx_cb_exit(struct pci_dev *dev)\n{\n\tplatform_driver_unregister(&bcm63xx_pcmcia_driver);\n\tbcm63xx_cb_dev = NULL;\n}\n\nstatic const struct pci_device_id bcm63xx_cb_table[] = {\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_BROADCOM,\n\t\t.device\t\t= BCM6348_CPU_ID,\n\t\t.subvendor\t= PCI_VENDOR_ID_BROADCOM,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t\t.class\t\t= PCI_CLASS_BRIDGE_CARDBUS << 8,\n\t\t.class_mask\t= ~0,\n\t},\n\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_BROADCOM,\n\t\t.device\t\t= BCM6358_CPU_ID,\n\t\t.subvendor\t= PCI_VENDOR_ID_BROADCOM,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t\t.class\t\t= PCI_CLASS_BRIDGE_CARDBUS << 8,\n\t\t.class_mask\t= ~0,\n\t},\n\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(pci, bcm63xx_cb_table);\n\nstatic struct pci_driver bcm63xx_cardbus_driver = {\n\t.name\t\t= \"bcm63xx_cardbus\",\n\t.id_table\t= bcm63xx_cb_table,\n\t.probe\t\t= bcm63xx_cb_probe,\n\t.remove\t\t= bcm63xx_cb_exit,\n};\n#endif\n\n \nstatic int __init bcm63xx_pcmcia_init(void)\n{\n#ifdef CONFIG_CARDBUS\n\treturn pci_register_driver(&bcm63xx_cardbus_driver);\n#else\n\treturn platform_driver_register(&bcm63xx_pcmcia_driver);\n#endif\n}\n\nstatic void __exit bcm63xx_pcmcia_exit(void)\n{\n#ifdef CONFIG_CARDBUS\n\treturn pci_unregister_driver(&bcm63xx_cardbus_driver);\n#else\n\tplatform_driver_unregister(&bcm63xx_pcmcia_driver);\n#endif\n}\n\nmodule_init(bcm63xx_pcmcia_init);\nmodule_exit(bcm63xx_pcmcia_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Maxime Bizon <mbizon@freebox.fr>\");\nMODULE_DESCRIPTION(\"Linux PCMCIA Card Services: bcm63xx Socket Controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}