{
  "module_name": "atmel-i2c.c",
  "hash_id": "f520a9023cf13eef091274446dd5d9a5b4f823a76f69188e44a31a974a522cec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/atmel-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/bitrev.h>\n#include <linux/crc16.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include \"atmel-i2c.h\"\n\nstatic const struct {\n\tu8 value;\n\tconst char *error_text;\n} error_list[] = {\n\t{ 0x01, \"CheckMac or Verify miscompare\" },\n\t{ 0x03, \"Parse Error\" },\n\t{ 0x05, \"ECC Fault\" },\n\t{ 0x0F, \"Execution Error\" },\n\t{ 0xEE, \"Watchdog about to expire\" },\n\t{ 0xFF, \"CRC or other communication error\" },\n};\n\n \nstatic void atmel_i2c_checksum(struct atmel_i2c_cmd *cmd)\n{\n\tu8 *data = &cmd->count;\n\tsize_t len = cmd->count - CRC_SIZE;\n\t__le16 *__crc16 = (__le16 *)(data + len);\n\n\t*__crc16 = cpu_to_le16(bitrev16(crc16(0, data, len)));\n}\n\nvoid atmel_i2c_init_read_cmd(struct atmel_i2c_cmd *cmd)\n{\n\tcmd->word_addr = COMMAND;\n\tcmd->opcode = OPCODE_READ;\n\t \n\tcmd->param1 = CONFIGURATION_ZONE;\n\tcmd->param2 = cpu_to_le16(DEVICE_LOCK_ADDR);\n\tcmd->count = READ_COUNT;\n\n\tatmel_i2c_checksum(cmd);\n\n\tcmd->msecs = MAX_EXEC_TIME_READ;\n\tcmd->rxsize = READ_RSP_SIZE;\n}\nEXPORT_SYMBOL(atmel_i2c_init_read_cmd);\n\nvoid atmel_i2c_init_random_cmd(struct atmel_i2c_cmd *cmd)\n{\n\tcmd->word_addr = COMMAND;\n\tcmd->opcode = OPCODE_RANDOM;\n\tcmd->param1 = 0;\n\tcmd->param2 = 0;\n\tcmd->count = RANDOM_COUNT;\n\n\tatmel_i2c_checksum(cmd);\n\n\tcmd->msecs = MAX_EXEC_TIME_RANDOM;\n\tcmd->rxsize = RANDOM_RSP_SIZE;\n}\nEXPORT_SYMBOL(atmel_i2c_init_random_cmd);\n\nvoid atmel_i2c_init_genkey_cmd(struct atmel_i2c_cmd *cmd, u16 keyid)\n{\n\tcmd->word_addr = COMMAND;\n\tcmd->count = GENKEY_COUNT;\n\tcmd->opcode = OPCODE_GENKEY;\n\tcmd->param1 = GENKEY_MODE_PRIVATE;\n\t \n\tcmd->param2 = cpu_to_le16(keyid);\n\n\tatmel_i2c_checksum(cmd);\n\n\tcmd->msecs = MAX_EXEC_TIME_GENKEY;\n\tcmd->rxsize = GENKEY_RSP_SIZE;\n}\nEXPORT_SYMBOL(atmel_i2c_init_genkey_cmd);\n\nint atmel_i2c_init_ecdh_cmd(struct atmel_i2c_cmd *cmd,\n\t\t\t    struct scatterlist *pubkey)\n{\n\tsize_t copied;\n\n\tcmd->word_addr = COMMAND;\n\tcmd->count = ECDH_COUNT;\n\tcmd->opcode = OPCODE_ECDH;\n\tcmd->param1 = ECDH_PREFIX_MODE;\n\t \n\tcmd->param2 = cpu_to_le16(DATA_SLOT_2);\n\n\t \n\tcopied = sg_copy_to_buffer(pubkey,\n\t\t\t\t   sg_nents_for_len(pubkey,\n\t\t\t\t\t\t    ATMEL_ECC_PUBKEY_SIZE),\n\t\t\t\t   cmd->data, ATMEL_ECC_PUBKEY_SIZE);\n\tif (copied != ATMEL_ECC_PUBKEY_SIZE)\n\t\treturn -EINVAL;\n\n\tatmel_i2c_checksum(cmd);\n\n\tcmd->msecs = MAX_EXEC_TIME_ECDH;\n\tcmd->rxsize = ECDH_RSP_SIZE;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(atmel_i2c_init_ecdh_cmd);\n\n \nstatic int atmel_i2c_status(struct device *dev, u8 *status)\n{\n\tsize_t err_list_len = ARRAY_SIZE(error_list);\n\tint i;\n\tu8 err_id = status[1];\n\n\tif (*status != STATUS_SIZE)\n\t\treturn 0;\n\n\tif (err_id == STATUS_WAKE_SUCCESSFUL || err_id == STATUS_NOERR)\n\t\treturn 0;\n\n\tfor (i = 0; i < err_list_len; i++)\n\t\tif (error_list[i].value == err_id)\n\t\t\tbreak;\n\n\t \n\tif (i != err_list_len) {\n\t\tdev_err(dev, \"%02x: %s:\\n\", err_id, error_list[i].error_text);\n\t\treturn err_id;\n\t}\n\n\treturn 0;\n}\n\nstatic int atmel_i2c_wakeup(struct i2c_client *client)\n{\n\tstruct atmel_i2c_client_priv *i2c_priv = i2c_get_clientdata(client);\n\tu8 status[STATUS_RSP_SIZE];\n\tint ret;\n\n\t \n\ti2c_transfer_buffer_flags(client, i2c_priv->wake_token,\n\t\t\t\ti2c_priv->wake_token_sz, I2C_M_IGNORE_NAK);\n\n\t \n\tusleep_range(TWHI_MIN, TWHI_MAX);\n\n\tret = i2c_master_recv(client, status, STATUS_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn atmel_i2c_status(&client->dev, status);\n}\n\nstatic int atmel_i2c_sleep(struct i2c_client *client)\n{\n\tu8 sleep = SLEEP_TOKEN;\n\n\treturn i2c_master_send(client, &sleep, 1);\n}\n\n \nint atmel_i2c_send_receive(struct i2c_client *client, struct atmel_i2c_cmd *cmd)\n{\n\tstruct atmel_i2c_client_priv *i2c_priv = i2c_get_clientdata(client);\n\tint ret;\n\n\tmutex_lock(&i2c_priv->lock);\n\n\tret = atmel_i2c_wakeup(client);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = i2c_master_send(client, (u8 *)cmd, cmd->count + WORD_ADDR_SIZE);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tmsleep(cmd->msecs);\n\n\t \n\tret = i2c_master_recv(client, cmd->data, cmd->rxsize);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = atmel_i2c_sleep(client);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmutex_unlock(&i2c_priv->lock);\n\treturn atmel_i2c_status(&client->dev, cmd->data);\nerr:\n\tmutex_unlock(&i2c_priv->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(atmel_i2c_send_receive);\n\nstatic void atmel_i2c_work_handler(struct work_struct *work)\n{\n\tstruct atmel_i2c_work_data *work_data =\n\t\t\tcontainer_of(work, struct atmel_i2c_work_data, work);\n\tstruct atmel_i2c_cmd *cmd = &work_data->cmd;\n\tstruct i2c_client *client = work_data->client;\n\tint status;\n\n\tstatus = atmel_i2c_send_receive(client, cmd);\n\twork_data->cbk(work_data, work_data->areq, status);\n}\n\nstatic struct workqueue_struct *atmel_wq;\n\nvoid atmel_i2c_enqueue(struct atmel_i2c_work_data *work_data,\n\t\t       void (*cbk)(struct atmel_i2c_work_data *work_data,\n\t\t\t\t   void *areq, int status),\n\t\t       void *areq)\n{\n\twork_data->cbk = (void *)cbk;\n\twork_data->areq = areq;\n\n\tINIT_WORK(&work_data->work, atmel_i2c_work_handler);\n\tqueue_work(atmel_wq, &work_data->work);\n}\nEXPORT_SYMBOL(atmel_i2c_enqueue);\n\nvoid atmel_i2c_flush_queue(void)\n{\n\tflush_workqueue(atmel_wq);\n}\nEXPORT_SYMBOL(atmel_i2c_flush_queue);\n\nstatic inline size_t atmel_i2c_wake_token_sz(u32 bus_clk_rate)\n{\n\tu32 no_of_bits = DIV_ROUND_UP(TWLO_USEC * bus_clk_rate, USEC_PER_SEC);\n\n\t \n\treturn DIV_ROUND_UP(no_of_bits, 8);\n}\n\nstatic int device_sanity_check(struct i2c_client *client)\n{\n\tstruct atmel_i2c_cmd *cmd;\n\tint ret;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tatmel_i2c_init_read_cmd(cmd);\n\n\tret = atmel_i2c_send_receive(client, cmd);\n\tif (ret)\n\t\tgoto free_cmd;\n\n\t \n\tif (cmd->data[LOCK_CONFIG_IDX] || cmd->data[LOCK_VALUE_IDX]) {\n\t\tdev_err(&client->dev, \"Configuration or Data and OTP zones are unlocked!\\n\");\n\t\tret = -ENOTSUPP;\n\t}\n\n\t \nfree_cmd:\n\tkfree(cmd);\n\treturn ret;\n}\n\nint atmel_i2c_probe(struct i2c_client *client)\n{\n\tstruct atmel_i2c_client_priv *i2c_priv;\n\tstruct device *dev = &client->dev;\n\tint ret;\n\tu32 bus_clk_rate;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(dev, \"I2C_FUNC_I2C not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbus_clk_rate = i2c_acpi_find_bus_speed(&client->adapter->dev);\n\tif (!bus_clk_rate) {\n\t\tret = device_property_read_u32(&client->adapter->dev,\n\t\t\t\t\t       \"clock-frequency\", &bus_clk_rate);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to read clock-frequency property\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (bus_clk_rate > 1000000L) {\n\t\tdev_err(dev, \"%u exceeds maximum supported clock frequency (1MHz)\\n\",\n\t\t\tbus_clk_rate);\n\t\treturn -EINVAL;\n\t}\n\n\ti2c_priv = devm_kmalloc(dev, sizeof(*i2c_priv), GFP_KERNEL);\n\tif (!i2c_priv)\n\t\treturn -ENOMEM;\n\n\ti2c_priv->client = client;\n\tmutex_init(&i2c_priv->lock);\n\n\t \n\ti2c_priv->wake_token_sz = atmel_i2c_wake_token_sz(bus_clk_rate);\n\n\tmemset(i2c_priv->wake_token, 0, sizeof(i2c_priv->wake_token));\n\n\tatomic_set(&i2c_priv->tfm_count, 0);\n\n\ti2c_set_clientdata(client, i2c_priv);\n\n\treturn device_sanity_check(client);\n}\nEXPORT_SYMBOL(atmel_i2c_probe);\n\nstatic int __init atmel_i2c_init(void)\n{\n\tatmel_wq = alloc_workqueue(\"atmel_wq\", 0, 0);\n\treturn atmel_wq ? 0 : -ENOMEM;\n}\n\nstatic void __exit atmel_i2c_exit(void)\n{\n\tdestroy_workqueue(atmel_wq);\n}\n\nmodule_init(atmel_i2c_init);\nmodule_exit(atmel_i2c_exit);\n\nMODULE_AUTHOR(\"Tudor Ambarus\");\nMODULE_DESCRIPTION(\"Microchip / Atmel ECC (I2C) driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}