{
  "module_name": "rk3288_crypto.c",
  "hash_id": "ea3e55252120a2a562c77a5187d2cdef7e3cecc7be2f94ab87efc1b2ea5bd1a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/rockchip/rk3288_crypto.c",
  "human_readable_source": "\n \n\n#include \"rk3288_crypto.h\"\n#include <crypto/engine.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n\nstatic struct rockchip_ip rocklist = {\n\t.dev_list = LIST_HEAD_INIT(rocklist.dev_list),\n\t.lock = __SPIN_LOCK_UNLOCKED(rocklist.lock),\n};\n\nstruct rk_crypto_info *get_rk_crypto(void)\n{\n\tstruct rk_crypto_info *first;\n\n\tspin_lock(&rocklist.lock);\n\tfirst = list_first_entry_or_null(&rocklist.dev_list,\n\t\t\t\t\t struct rk_crypto_info, list);\n\tlist_rotate_left(&rocklist.dev_list);\n\tspin_unlock(&rocklist.lock);\n\treturn first;\n}\n\nstatic const struct rk_variant rk3288_variant = {\n\t.num_clks = 4,\n\t.rkclks = {\n\t\t{ \"sclk\", 150000000},\n\t}\n};\n\nstatic const struct rk_variant rk3328_variant = {\n\t.num_clks = 3,\n};\n\nstatic const struct rk_variant rk3399_variant = {\n\t.num_clks = 3,\n};\n\nstatic int rk_crypto_get_clks(struct rk_crypto_info *dev)\n{\n\tint i, j, err;\n\tunsigned long cr;\n\n\tdev->num_clks = devm_clk_bulk_get_all(dev->dev, &dev->clks);\n\tif (dev->num_clks < dev->variant->num_clks) {\n\t\tdev_err(dev->dev, \"Missing clocks, got %d instead of %d\\n\",\n\t\t\tdev->num_clks, dev->variant->num_clks);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < dev->num_clks; i++) {\n\t\tcr = clk_get_rate(dev->clks[i].clk);\n\t\tfor (j = 0; j < ARRAY_SIZE(dev->variant->rkclks); j++) {\n\t\t\tif (dev->variant->rkclks[j].max == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(dev->variant->rkclks[j].name, dev->clks[i].id))\n\t\t\t\tcontinue;\n\t\t\tif (cr > dev->variant->rkclks[j].max) {\n\t\t\t\terr = clk_set_rate(dev->clks[i].clk,\n\t\t\t\t\t\t   dev->variant->rkclks[j].max);\n\t\t\t\tif (err)\n\t\t\t\t\tdev_err(dev->dev, \"Fail downclocking %s from %lu to %lu\\n\",\n\t\t\t\t\t\tdev->variant->rkclks[j].name, cr,\n\t\t\t\t\t\tdev->variant->rkclks[j].max);\n\t\t\t\telse\n\t\t\t\t\tdev_info(dev->dev, \"Downclocking %s from %lu to %lu\\n\",\n\t\t\t\t\t\t dev->variant->rkclks[j].name, cr,\n\t\t\t\t\t\t dev->variant->rkclks[j].max);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int rk_crypto_enable_clk(struct rk_crypto_info *dev)\n{\n\tint err;\n\n\terr = clk_bulk_prepare_enable(dev->num_clks, dev->clks);\n\tif (err)\n\t\tdev_err(dev->dev, \"Could not enable clock clks\\n\");\n\n\treturn err;\n}\n\nstatic void rk_crypto_disable_clk(struct rk_crypto_info *dev)\n{\n\tclk_bulk_disable_unprepare(dev->num_clks, dev->clks);\n}\n\n \nstatic int rk_crypto_pm_suspend(struct device *dev)\n{\n\tstruct rk_crypto_info *rkdev = dev_get_drvdata(dev);\n\n\trk_crypto_disable_clk(rkdev);\n\treset_control_assert(rkdev->rst);\n\n\treturn 0;\n}\n\nstatic int rk_crypto_pm_resume(struct device *dev)\n{\n\tstruct rk_crypto_info *rkdev = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = rk_crypto_enable_clk(rkdev);\n\tif (ret)\n\t\treturn ret;\n\n\treset_control_deassert(rkdev->rst);\n\treturn 0;\n\n}\n\nstatic const struct dev_pm_ops rk_crypto_pm_ops = {\n\tSET_RUNTIME_PM_OPS(rk_crypto_pm_suspend, rk_crypto_pm_resume, NULL)\n};\n\nstatic int rk_crypto_pm_init(struct rk_crypto_info *rkdev)\n{\n\tint err;\n\n\tpm_runtime_use_autosuspend(rkdev->dev);\n\tpm_runtime_set_autosuspend_delay(rkdev->dev, 2000);\n\n\terr = pm_runtime_set_suspended(rkdev->dev);\n\tif (err)\n\t\treturn err;\n\tpm_runtime_enable(rkdev->dev);\n\treturn err;\n}\n\nstatic void rk_crypto_pm_exit(struct rk_crypto_info *rkdev)\n{\n\tpm_runtime_disable(rkdev->dev);\n}\n\nstatic irqreturn_t rk_crypto_irq_handle(int irq, void *dev_id)\n{\n\tstruct rk_crypto_info *dev  = platform_get_drvdata(dev_id);\n\tu32 interrupt_status;\n\n\tinterrupt_status = CRYPTO_READ(dev, RK_CRYPTO_INTSTS);\n\tCRYPTO_WRITE(dev, RK_CRYPTO_INTSTS, interrupt_status);\n\n\tdev->status = 1;\n\tif (interrupt_status & 0x0a) {\n\t\tdev_warn(dev->dev, \"DMA Error\\n\");\n\t\tdev->status = 0;\n\t}\n\tcomplete(&dev->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct rk_crypto_tmp *rk_cipher_algs[] = {\n\t&rk_ecb_aes_alg,\n\t&rk_cbc_aes_alg,\n\t&rk_ecb_des_alg,\n\t&rk_cbc_des_alg,\n\t&rk_ecb_des3_ede_alg,\n\t&rk_cbc_des3_ede_alg,\n\t&rk_ahash_sha1,\n\t&rk_ahash_sha256,\n\t&rk_ahash_md5,\n};\n\nstatic int rk_crypto_debugfs_show(struct seq_file *seq, void *v)\n{\n\tstruct rk_crypto_info *dd;\n\tunsigned int i;\n\n\tspin_lock(&rocklist.lock);\n\tlist_for_each_entry(dd, &rocklist.dev_list, list) {\n\t\tseq_printf(seq, \"%s %s requests: %lu\\n\",\n\t\t\t   dev_driver_string(dd->dev), dev_name(dd->dev),\n\t\t\t   dd->nreq);\n\t}\n\tspin_unlock(&rocklist.lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(rk_cipher_algs); i++) {\n\t\tif (!rk_cipher_algs[i]->dev)\n\t\t\tcontinue;\n\t\tswitch (rk_cipher_algs[i]->type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tseq_printf(seq, \"%s %s reqs=%lu fallback=%lu\\n\",\n\t\t\t\t   rk_cipher_algs[i]->alg.skcipher.base.base.cra_driver_name,\n\t\t\t\t   rk_cipher_algs[i]->alg.skcipher.base.base.cra_name,\n\t\t\t\t   rk_cipher_algs[i]->stat_req, rk_cipher_algs[i]->stat_fb);\n\t\t\tseq_printf(seq, \"\\tfallback due to length: %lu\\n\",\n\t\t\t\t   rk_cipher_algs[i]->stat_fb_len);\n\t\t\tseq_printf(seq, \"\\tfallback due to alignment: %lu\\n\",\n\t\t\t\t   rk_cipher_algs[i]->stat_fb_align);\n\t\t\tseq_printf(seq, \"\\tfallback due to SGs: %lu\\n\",\n\t\t\t\t   rk_cipher_algs[i]->stat_fb_sgdiff);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\tseq_printf(seq, \"%s %s reqs=%lu fallback=%lu\\n\",\n\t\t\t\t   rk_cipher_algs[i]->alg.hash.base.halg.base.cra_driver_name,\n\t\t\t\t   rk_cipher_algs[i]->alg.hash.base.halg.base.cra_name,\n\t\t\t\t   rk_cipher_algs[i]->stat_req, rk_cipher_algs[i]->stat_fb);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(rk_crypto_debugfs);\n\nstatic void register_debugfs(struct rk_crypto_info *crypto_info)\n{\n\tstruct dentry *dbgfs_dir __maybe_unused;\n\tstruct dentry *dbgfs_stats __maybe_unused;\n\n\t \n\tdbgfs_dir = debugfs_create_dir(\"rk3288_crypto\", NULL);\n\tdbgfs_stats = debugfs_create_file(\"stats\", 0444, dbgfs_dir, &rocklist,\n\t\t\t\t\t  &rk_crypto_debugfs_fops);\n\n#ifdef CONFIG_CRYPTO_DEV_ROCKCHIP_DEBUG\n\trocklist.dbgfs_dir = dbgfs_dir;\n\trocklist.dbgfs_stats = dbgfs_stats;\n#endif\n}\n\nstatic int rk_crypto_register(struct rk_crypto_info *crypto_info)\n{\n\tunsigned int i, k;\n\tint err = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(rk_cipher_algs); i++) {\n\t\trk_cipher_algs[i]->dev = crypto_info;\n\t\tswitch (rk_cipher_algs[i]->type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tdev_info(crypto_info->dev, \"Register %s as %s\\n\",\n\t\t\t\t rk_cipher_algs[i]->alg.skcipher.base.base.cra_name,\n\t\t\t\t rk_cipher_algs[i]->alg.skcipher.base.base.cra_driver_name);\n\t\t\terr = crypto_engine_register_skcipher(&rk_cipher_algs[i]->alg.skcipher);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\tdev_info(crypto_info->dev, \"Register %s as %s\\n\",\n\t\t\t\t rk_cipher_algs[i]->alg.hash.base.halg.base.cra_name,\n\t\t\t\t rk_cipher_algs[i]->alg.hash.base.halg.base.cra_driver_name);\n\t\t\terr = crypto_engine_register_ahash(&rk_cipher_algs[i]->alg.hash);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(crypto_info->dev, \"unknown algorithm\\n\");\n\t\t}\n\t\tif (err)\n\t\t\tgoto err_cipher_algs;\n\t}\n\treturn 0;\n\nerr_cipher_algs:\n\tfor (k = 0; k < i; k++) {\n\t\tif (rk_cipher_algs[i]->type == CRYPTO_ALG_TYPE_SKCIPHER)\n\t\t\tcrypto_engine_unregister_skcipher(&rk_cipher_algs[k]->alg.skcipher);\n\t\telse\n\t\t\tcrypto_engine_unregister_ahash(&rk_cipher_algs[i]->alg.hash);\n\t}\n\treturn err;\n}\n\nstatic void rk_crypto_unregister(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rk_cipher_algs); i++) {\n\t\tif (rk_cipher_algs[i]->type == CRYPTO_ALG_TYPE_SKCIPHER)\n\t\t\tcrypto_engine_unregister_skcipher(&rk_cipher_algs[i]->alg.skcipher);\n\t\telse\n\t\t\tcrypto_engine_unregister_ahash(&rk_cipher_algs[i]->alg.hash);\n\t}\n}\n\nstatic const struct of_device_id crypto_of_id_table[] = {\n\t{ .compatible = \"rockchip,rk3288-crypto\",\n\t  .data = &rk3288_variant,\n\t},\n\t{ .compatible = \"rockchip,rk3328-crypto\",\n\t  .data = &rk3328_variant,\n\t},\n\t{ .compatible = \"rockchip,rk3399-crypto\",\n\t  .data = &rk3399_variant,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, crypto_of_id_table);\n\nstatic int rk_crypto_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rk_crypto_info *crypto_info, *first;\n\tint err = 0;\n\n\tcrypto_info = devm_kzalloc(&pdev->dev,\n\t\t\t\t   sizeof(*crypto_info), GFP_KERNEL);\n\tif (!crypto_info) {\n\t\terr = -ENOMEM;\n\t\tgoto err_crypto;\n\t}\n\n\tcrypto_info->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, crypto_info);\n\n\tcrypto_info->variant = of_device_get_match_data(&pdev->dev);\n\tif (!crypto_info->variant) {\n\t\tdev_err(&pdev->dev, \"Missing variant\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcrypto_info->rst = devm_reset_control_array_get_exclusive(dev);\n\tif (IS_ERR(crypto_info->rst)) {\n\t\terr = PTR_ERR(crypto_info->rst);\n\t\tgoto err_crypto;\n\t}\n\n\treset_control_assert(crypto_info->rst);\n\tusleep_range(10, 20);\n\treset_control_deassert(crypto_info->rst);\n\n\tcrypto_info->reg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(crypto_info->reg)) {\n\t\terr = PTR_ERR(crypto_info->reg);\n\t\tgoto err_crypto;\n\t}\n\n\terr = rk_crypto_get_clks(crypto_info);\n\tif (err)\n\t\tgoto err_crypto;\n\n\tcrypto_info->irq = platform_get_irq(pdev, 0);\n\tif (crypto_info->irq < 0) {\n\t\terr = crypto_info->irq;\n\t\tgoto err_crypto;\n\t}\n\n\terr = devm_request_irq(&pdev->dev, crypto_info->irq,\n\t\t\t       rk_crypto_irq_handle, IRQF_SHARED,\n\t\t\t       \"rk-crypto\", pdev);\n\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"irq request failed.\\n\");\n\t\tgoto err_crypto;\n\t}\n\n\tcrypto_info->engine = crypto_engine_alloc_init(&pdev->dev, true);\n\tcrypto_engine_start(crypto_info->engine);\n\tinit_completion(&crypto_info->complete);\n\n\terr = rk_crypto_pm_init(crypto_info);\n\tif (err)\n\t\tgoto err_pm;\n\n\tspin_lock(&rocklist.lock);\n\tfirst = list_first_entry_or_null(&rocklist.dev_list,\n\t\t\t\t\t struct rk_crypto_info, list);\n\tlist_add_tail(&crypto_info->list, &rocklist.dev_list);\n\tspin_unlock(&rocklist.lock);\n\n\tif (!first) {\n\t\terr = rk_crypto_register(crypto_info);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Fail to register crypto algorithms\");\n\t\t\tgoto err_register_alg;\n\t\t}\n\n\t\tregister_debugfs(crypto_info);\n\t}\n\n\treturn 0;\n\nerr_register_alg:\n\trk_crypto_pm_exit(crypto_info);\nerr_pm:\n\tcrypto_engine_exit(crypto_info->engine);\nerr_crypto:\n\tdev_err(dev, \"Crypto Accelerator not successfully registered\\n\");\n\treturn err;\n}\n\nstatic int rk_crypto_remove(struct platform_device *pdev)\n{\n\tstruct rk_crypto_info *crypto_tmp = platform_get_drvdata(pdev);\n\tstruct rk_crypto_info *first;\n\n\tspin_lock_bh(&rocklist.lock);\n\tlist_del(&crypto_tmp->list);\n\tfirst = list_first_entry_or_null(&rocklist.dev_list,\n\t\t\t\t\t struct rk_crypto_info, list);\n\tspin_unlock_bh(&rocklist.lock);\n\n\tif (!first) {\n#ifdef CONFIG_CRYPTO_DEV_ROCKCHIP_DEBUG\n\t\tdebugfs_remove_recursive(rocklist.dbgfs_dir);\n#endif\n\t\trk_crypto_unregister();\n\t}\n\trk_crypto_pm_exit(crypto_tmp);\n\tcrypto_engine_exit(crypto_tmp->engine);\n\treturn 0;\n}\n\nstatic struct platform_driver crypto_driver = {\n\t.probe\t\t= rk_crypto_probe,\n\t.remove\t\t= rk_crypto_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"rk3288-crypto\",\n\t\t.pm\t\t= &rk_crypto_pm_ops,\n\t\t.of_match_table\t= crypto_of_id_table,\n\t},\n};\n\nmodule_platform_driver(crypto_driver);\n\nMODULE_AUTHOR(\"Zain Wang <zain.wang@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Support for Rockchip's cryptographic engine\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}