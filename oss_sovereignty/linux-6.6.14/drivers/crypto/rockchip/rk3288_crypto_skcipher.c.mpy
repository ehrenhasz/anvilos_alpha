{
  "module_name": "rk3288_crypto_skcipher.c",
  "hash_id": "323408b666ef244ec71945e2ad231dfd065400958019e50b2e4c2e18c63e37c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/rockchip/rk3288_crypto_skcipher.c",
  "human_readable_source": "\n \n\n#include <crypto/engine.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include \"rk3288_crypto.h\"\n\n#define RK_CRYPTO_DEC\t\t\tBIT(0)\n\nstatic int rk_cipher_need_fallback(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(tfm);\n\tstruct rk_crypto_tmp *algt = container_of(alg, struct rk_crypto_tmp, alg.skcipher.base);\n\tstruct scatterlist *sgs, *sgd;\n\tunsigned int stodo, dtodo, len;\n\tunsigned int bs = crypto_skcipher_blocksize(tfm);\n\n\tif (!req->cryptlen)\n\t\treturn true;\n\n\tlen = req->cryptlen;\n\tsgs = req->src;\n\tsgd = req->dst;\n\twhile (sgs && sgd) {\n\t\tif (!IS_ALIGNED(sgs->offset, sizeof(u32))) {\n\t\t\talgt->stat_fb_align++;\n\t\t\treturn true;\n\t\t}\n\t\tif (!IS_ALIGNED(sgd->offset, sizeof(u32))) {\n\t\t\talgt->stat_fb_align++;\n\t\t\treturn true;\n\t\t}\n\t\tstodo = min(len, sgs->length);\n\t\tif (stodo % bs) {\n\t\t\talgt->stat_fb_len++;\n\t\t\treturn true;\n\t\t}\n\t\tdtodo = min(len, sgd->length);\n\t\tif (dtodo % bs) {\n\t\t\talgt->stat_fb_len++;\n\t\t\treturn true;\n\t\t}\n\t\tif (stodo != dtodo) {\n\t\t\talgt->stat_fb_sgdiff++;\n\t\t\treturn true;\n\t\t}\n\t\tlen -= stodo;\n\t\tsgs = sg_next(sgs);\n\t\tsgd = sg_next(sgd);\n\t}\n\treturn false;\n}\n\nstatic int rk_cipher_fallback(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct rk_cipher_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(areq);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(tfm);\n\tstruct rk_crypto_tmp *algt = container_of(alg, struct rk_crypto_tmp, alg.skcipher.base);\n\tint err;\n\n\talgt->stat_fb++;\n\n\tskcipher_request_set_tfm(&rctx->fallback_req, op->fallback_tfm);\n\tskcipher_request_set_callback(&rctx->fallback_req, areq->base.flags,\n\t\t\t\t      areq->base.complete, areq->base.data);\n\tskcipher_request_set_crypt(&rctx->fallback_req, areq->src, areq->dst,\n\t\t\t\t   areq->cryptlen, areq->iv);\n\tif (rctx->mode & RK_CRYPTO_DEC)\n\t\terr = crypto_skcipher_decrypt(&rctx->fallback_req);\n\telse\n\t\terr = crypto_skcipher_encrypt(&rctx->fallback_req);\n\treturn err;\n}\n\nstatic int rk_cipher_handle_req(struct skcipher_request *req)\n{\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\tstruct rk_crypto_info *rkc;\n\tstruct crypto_engine *engine;\n\n\tif (rk_cipher_need_fallback(req))\n\t\treturn rk_cipher_fallback(req);\n\n\trkc = get_rk_crypto();\n\n\tengine = rkc->engine;\n\trctx->dev = rkc;\n\n\treturn crypto_transfer_skcipher_request_to_engine(engine, req);\n}\n\nstatic int rk_aes_setkey(struct crypto_skcipher *cipher,\n\t\t\t const u8 *key, unsigned int keylen)\n{\n\tstruct crypto_tfm *tfm = crypto_skcipher_tfm(cipher);\n\tstruct rk_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tif (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&\n\t    keylen != AES_KEYSIZE_256)\n\t\treturn -EINVAL;\n\tctx->keylen = keylen;\n\tmemcpy(ctx->key, key, keylen);\n\n\treturn crypto_skcipher_setkey(ctx->fallback_tfm, key, keylen);\n}\n\nstatic int rk_des_setkey(struct crypto_skcipher *cipher,\n\t\t\t const u8 *key, unsigned int keylen)\n{\n\tstruct rk_cipher_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tint err;\n\n\terr = verify_skcipher_des_key(cipher, key);\n\tif (err)\n\t\treturn err;\n\n\tctx->keylen = keylen;\n\tmemcpy(ctx->key, key, keylen);\n\n\treturn crypto_skcipher_setkey(ctx->fallback_tfm, key, keylen);\n}\n\nstatic int rk_tdes_setkey(struct crypto_skcipher *cipher,\n\t\t\t  const u8 *key, unsigned int keylen)\n{\n\tstruct rk_cipher_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tint err;\n\n\terr = verify_skcipher_des3_key(cipher, key);\n\tif (err)\n\t\treturn err;\n\n\tctx->keylen = keylen;\n\tmemcpy(ctx->key, key, keylen);\n\n\treturn crypto_skcipher_setkey(ctx->fallback_tfm, key, keylen);\n}\n\nstatic int rk_aes_ecb_encrypt(struct skcipher_request *req)\n{\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\n\trctx->mode = RK_CRYPTO_AES_ECB_MODE;\n\treturn rk_cipher_handle_req(req);\n}\n\nstatic int rk_aes_ecb_decrypt(struct skcipher_request *req)\n{\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\n\trctx->mode = RK_CRYPTO_AES_ECB_MODE | RK_CRYPTO_DEC;\n\treturn rk_cipher_handle_req(req);\n}\n\nstatic int rk_aes_cbc_encrypt(struct skcipher_request *req)\n{\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\n\trctx->mode = RK_CRYPTO_AES_CBC_MODE;\n\treturn rk_cipher_handle_req(req);\n}\n\nstatic int rk_aes_cbc_decrypt(struct skcipher_request *req)\n{\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\n\trctx->mode = RK_CRYPTO_AES_CBC_MODE | RK_CRYPTO_DEC;\n\treturn rk_cipher_handle_req(req);\n}\n\nstatic int rk_des_ecb_encrypt(struct skcipher_request *req)\n{\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\n\trctx->mode = 0;\n\treturn rk_cipher_handle_req(req);\n}\n\nstatic int rk_des_ecb_decrypt(struct skcipher_request *req)\n{\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\n\trctx->mode = RK_CRYPTO_DEC;\n\treturn rk_cipher_handle_req(req);\n}\n\nstatic int rk_des_cbc_encrypt(struct skcipher_request *req)\n{\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\n\trctx->mode = RK_CRYPTO_TDES_CHAINMODE_CBC;\n\treturn rk_cipher_handle_req(req);\n}\n\nstatic int rk_des_cbc_decrypt(struct skcipher_request *req)\n{\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\n\trctx->mode = RK_CRYPTO_TDES_CHAINMODE_CBC | RK_CRYPTO_DEC;\n\treturn rk_cipher_handle_req(req);\n}\n\nstatic int rk_des3_ede_ecb_encrypt(struct skcipher_request *req)\n{\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\n\trctx->mode = RK_CRYPTO_TDES_SELECT;\n\treturn rk_cipher_handle_req(req);\n}\n\nstatic int rk_des3_ede_ecb_decrypt(struct skcipher_request *req)\n{\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\n\trctx->mode = RK_CRYPTO_TDES_SELECT | RK_CRYPTO_DEC;\n\treturn rk_cipher_handle_req(req);\n}\n\nstatic int rk_des3_ede_cbc_encrypt(struct skcipher_request *req)\n{\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\n\trctx->mode = RK_CRYPTO_TDES_SELECT | RK_CRYPTO_TDES_CHAINMODE_CBC;\n\treturn rk_cipher_handle_req(req);\n}\n\nstatic int rk_des3_ede_cbc_decrypt(struct skcipher_request *req)\n{\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\n\trctx->mode = RK_CRYPTO_TDES_SELECT | RK_CRYPTO_TDES_CHAINMODE_CBC |\n\t\t    RK_CRYPTO_DEC;\n\treturn rk_cipher_handle_req(req);\n}\n\nstatic void rk_cipher_hw_init(struct rk_crypto_info *dev, struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *cipher = crypto_skcipher_reqtfm(req);\n\tstruct crypto_tfm *tfm = crypto_skcipher_tfm(cipher);\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(req);\n\tstruct rk_cipher_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tu32 block, conf_reg = 0;\n\n\tblock = crypto_tfm_alg_blocksize(tfm);\n\n\tif (block == DES_BLOCK_SIZE) {\n\t\trctx->mode |= RK_CRYPTO_TDES_FIFO_MODE |\n\t\t\t     RK_CRYPTO_TDES_BYTESWAP_KEY |\n\t\t\t     RK_CRYPTO_TDES_BYTESWAP_IV;\n\t\tCRYPTO_WRITE(dev, RK_CRYPTO_TDES_CTRL, rctx->mode);\n\t\tmemcpy_toio(dev->reg + RK_CRYPTO_TDES_KEY1_0, ctx->key, ctx->keylen);\n\t\tconf_reg = RK_CRYPTO_DESSEL;\n\t} else {\n\t\trctx->mode |= RK_CRYPTO_AES_FIFO_MODE |\n\t\t\t     RK_CRYPTO_AES_KEY_CHANGE |\n\t\t\t     RK_CRYPTO_AES_BYTESWAP_KEY |\n\t\t\t     RK_CRYPTO_AES_BYTESWAP_IV;\n\t\tif (ctx->keylen == AES_KEYSIZE_192)\n\t\t\trctx->mode |= RK_CRYPTO_AES_192BIT_key;\n\t\telse if (ctx->keylen == AES_KEYSIZE_256)\n\t\t\trctx->mode |= RK_CRYPTO_AES_256BIT_key;\n\t\tCRYPTO_WRITE(dev, RK_CRYPTO_AES_CTRL, rctx->mode);\n\t\tmemcpy_toio(dev->reg + RK_CRYPTO_AES_KEY_0, ctx->key, ctx->keylen);\n\t}\n\tconf_reg |= RK_CRYPTO_BYTESWAP_BTFIFO |\n\t\t    RK_CRYPTO_BYTESWAP_BRFIFO;\n\tCRYPTO_WRITE(dev, RK_CRYPTO_CONF, conf_reg);\n\tCRYPTO_WRITE(dev, RK_CRYPTO_INTENA,\n\t\t     RK_CRYPTO_BCDMA_ERR_ENA | RK_CRYPTO_BCDMA_DONE_ENA);\n}\n\nstatic void crypto_dma_start(struct rk_crypto_info *dev,\n\t\t\t     struct scatterlist *sgs,\n\t\t\t     struct scatterlist *sgd, unsigned int todo)\n{\n\tCRYPTO_WRITE(dev, RK_CRYPTO_BRDMAS, sg_dma_address(sgs));\n\tCRYPTO_WRITE(dev, RK_CRYPTO_BRDMAL, todo);\n\tCRYPTO_WRITE(dev, RK_CRYPTO_BTDMAS, sg_dma_address(sgd));\n\tCRYPTO_WRITE(dev, RK_CRYPTO_CTRL, RK_CRYPTO_BLOCK_START |\n\t\t     _SBF(RK_CRYPTO_BLOCK_START, 16));\n}\n\nstatic int rk_cipher_run(struct crypto_engine *engine, void *async_req)\n{\n\tstruct skcipher_request *areq = container_of(async_req, struct skcipher_request, base);\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct rk_cipher_rctx *rctx = skcipher_request_ctx(areq);\n\tstruct scatterlist *sgs, *sgd;\n\tint err = 0;\n\tint ivsize = crypto_skcipher_ivsize(tfm);\n\tint offset;\n\tu8 iv[AES_BLOCK_SIZE];\n\tu8 biv[AES_BLOCK_SIZE];\n\tu8 *ivtouse = areq->iv;\n\tunsigned int len = areq->cryptlen;\n\tunsigned int todo;\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(tfm);\n\tstruct rk_crypto_tmp *algt = container_of(alg, struct rk_crypto_tmp, alg.skcipher.base);\n\tstruct rk_crypto_info *rkc = rctx->dev;\n\n\terr = pm_runtime_resume_and_get(rkc->dev);\n\tif (err)\n\t\treturn err;\n\n\talgt->stat_req++;\n\trkc->nreq++;\n\n\tivsize = crypto_skcipher_ivsize(tfm);\n\tif (areq->iv && crypto_skcipher_ivsize(tfm) > 0) {\n\t\tif (rctx->mode & RK_CRYPTO_DEC) {\n\t\t\toffset = areq->cryptlen - ivsize;\n\t\t\tscatterwalk_map_and_copy(rctx->backup_iv, areq->src,\n\t\t\t\t\t\t offset, ivsize, 0);\n\t\t}\n\t}\n\n\tsgs = areq->src;\n\tsgd = areq->dst;\n\n\twhile (sgs && sgd && len) {\n\t\tif (!sgs->length) {\n\t\t\tsgs = sg_next(sgs);\n\t\t\tsgd = sg_next(sgd);\n\t\t\tcontinue;\n\t\t}\n\t\tif (rctx->mode & RK_CRYPTO_DEC) {\n\t\t\t \n\t\t\toffset = sgs->length - ivsize;\n\t\t\tscatterwalk_map_and_copy(biv, sgs, offset, ivsize, 0);\n\t\t}\n\t\tif (sgs == sgd) {\n\t\t\terr = dma_map_sg(rkc->dev, sgs, 1, DMA_BIDIRECTIONAL);\n\t\t\tif (err <= 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto theend_iv;\n\t\t\t}\n\t\t} else {\n\t\t\terr = dma_map_sg(rkc->dev, sgs, 1, DMA_TO_DEVICE);\n\t\t\tif (err <= 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto theend_iv;\n\t\t\t}\n\t\t\terr = dma_map_sg(rkc->dev, sgd, 1, DMA_FROM_DEVICE);\n\t\t\tif (err <= 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto theend_sgs;\n\t\t\t}\n\t\t}\n\t\terr = 0;\n\t\trk_cipher_hw_init(rkc, areq);\n\t\tif (ivsize) {\n\t\t\tif (ivsize == DES_BLOCK_SIZE)\n\t\t\t\tmemcpy_toio(rkc->reg + RK_CRYPTO_TDES_IV_0, ivtouse, ivsize);\n\t\t\telse\n\t\t\t\tmemcpy_toio(rkc->reg + RK_CRYPTO_AES_IV_0, ivtouse, ivsize);\n\t\t}\n\t\treinit_completion(&rkc->complete);\n\t\trkc->status = 0;\n\n\t\ttodo = min(sg_dma_len(sgs), len);\n\t\tlen -= todo;\n\t\tcrypto_dma_start(rkc, sgs, sgd, todo / 4);\n\t\twait_for_completion_interruptible_timeout(&rkc->complete,\n\t\t\t\t\t\t\t  msecs_to_jiffies(2000));\n\t\tif (!rkc->status) {\n\t\t\tdev_err(rkc->dev, \"DMA timeout\\n\");\n\t\t\terr = -EFAULT;\n\t\t\tgoto theend;\n\t\t}\n\t\tif (sgs == sgd) {\n\t\t\tdma_unmap_sg(rkc->dev, sgs, 1, DMA_BIDIRECTIONAL);\n\t\t} else {\n\t\t\tdma_unmap_sg(rkc->dev, sgs, 1, DMA_TO_DEVICE);\n\t\t\tdma_unmap_sg(rkc->dev, sgd, 1, DMA_FROM_DEVICE);\n\t\t}\n\t\tif (rctx->mode & RK_CRYPTO_DEC) {\n\t\t\tmemcpy(iv, biv, ivsize);\n\t\t\tivtouse = iv;\n\t\t} else {\n\t\t\toffset = sgd->length - ivsize;\n\t\t\tscatterwalk_map_and_copy(iv, sgd, offset, ivsize, 0);\n\t\t\tivtouse = iv;\n\t\t}\n\t\tsgs = sg_next(sgs);\n\t\tsgd = sg_next(sgd);\n\t}\n\n\tif (areq->iv && ivsize > 0) {\n\t\toffset = areq->cryptlen - ivsize;\n\t\tif (rctx->mode & RK_CRYPTO_DEC) {\n\t\t\tmemcpy(areq->iv, rctx->backup_iv, ivsize);\n\t\t\tmemzero_explicit(rctx->backup_iv, ivsize);\n\t\t} else {\n\t\t\tscatterwalk_map_and_copy(areq->iv, areq->dst, offset,\n\t\t\t\t\t\t ivsize, 0);\n\t\t}\n\t}\n\ntheend:\n\tpm_runtime_put_autosuspend(rkc->dev);\n\n\tlocal_bh_disable();\n\tcrypto_finalize_skcipher_request(engine, areq, err);\n\tlocal_bh_enable();\n\treturn 0;\n\ntheend_sgs:\n\tif (sgs == sgd) {\n\t\tdma_unmap_sg(rkc->dev, sgs, 1, DMA_BIDIRECTIONAL);\n\t} else {\n\t\tdma_unmap_sg(rkc->dev, sgs, 1, DMA_TO_DEVICE);\n\t\tdma_unmap_sg(rkc->dev, sgd, 1, DMA_FROM_DEVICE);\n\t}\ntheend_iv:\n\treturn err;\n}\n\nstatic int rk_cipher_tfm_init(struct crypto_skcipher *tfm)\n{\n\tstruct rk_cipher_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tconst char *name = crypto_tfm_alg_name(&tfm->base);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(tfm);\n\tstruct rk_crypto_tmp *algt = container_of(alg, struct rk_crypto_tmp, alg.skcipher.base);\n\n\tctx->fallback_tfm = crypto_alloc_skcipher(name, 0, CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(ctx->fallback_tfm)) {\n\t\tdev_err(algt->dev->dev, \"ERROR: Cannot allocate fallback for %s %ld\\n\",\n\t\t\tname, PTR_ERR(ctx->fallback_tfm));\n\t\treturn PTR_ERR(ctx->fallback_tfm);\n\t}\n\n\ttfm->reqsize = sizeof(struct rk_cipher_rctx) +\n\t\tcrypto_skcipher_reqsize(ctx->fallback_tfm);\n\n\treturn 0;\n}\n\nstatic void rk_cipher_tfm_exit(struct crypto_skcipher *tfm)\n{\n\tstruct rk_cipher_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\tmemzero_explicit(ctx->key, ctx->keylen);\n\tcrypto_free_skcipher(ctx->fallback_tfm);\n}\n\nstruct rk_crypto_tmp rk_ecb_aes_alg = {\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.alg.skcipher.base = {\n\t\t.base.cra_name\t\t= \"ecb(aes)\",\n\t\t.base.cra_driver_name\t= \"ecb-aes-rk\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK,\n\t\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct rk_cipher_ctx),\n\t\t.base.cra_alignmask\t= 0x0f,\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.init\t\t\t= rk_cipher_tfm_init,\n\t\t.exit\t\t\t= rk_cipher_tfm_exit,\n\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t.setkey\t\t\t= rk_aes_setkey,\n\t\t.encrypt\t\t= rk_aes_ecb_encrypt,\n\t\t.decrypt\t\t= rk_aes_ecb_decrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = rk_cipher_run,\n\t},\n};\n\nstruct rk_crypto_tmp rk_cbc_aes_alg = {\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.alg.skcipher.base = {\n\t\t.base.cra_name\t\t= \"cbc(aes)\",\n\t\t.base.cra_driver_name\t= \"cbc-aes-rk\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK,\n\t\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct rk_cipher_ctx),\n\t\t.base.cra_alignmask\t= 0x0f,\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.init\t\t\t= rk_cipher_tfm_init,\n\t\t.exit\t\t\t= rk_cipher_tfm_exit,\n\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t\t.setkey\t\t\t= rk_aes_setkey,\n\t\t.encrypt\t\t= rk_aes_cbc_encrypt,\n\t\t.decrypt\t\t= rk_aes_cbc_decrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = rk_cipher_run,\n\t},\n};\n\nstruct rk_crypto_tmp rk_ecb_des_alg = {\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.alg.skcipher.base = {\n\t\t.base.cra_name\t\t= \"ecb(des)\",\n\t\t.base.cra_driver_name\t= \"ecb-des-rk\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK,\n\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct rk_cipher_ctx),\n\t\t.base.cra_alignmask\t= 0x07,\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.init\t\t\t= rk_cipher_tfm_init,\n\t\t.exit\t\t\t= rk_cipher_tfm_exit,\n\t\t.min_keysize\t\t= DES_KEY_SIZE,\n\t\t.max_keysize\t\t= DES_KEY_SIZE,\n\t\t.setkey\t\t\t= rk_des_setkey,\n\t\t.encrypt\t\t= rk_des_ecb_encrypt,\n\t\t.decrypt\t\t= rk_des_ecb_decrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = rk_cipher_run,\n\t},\n};\n\nstruct rk_crypto_tmp rk_cbc_des_alg = {\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.alg.skcipher.base = {\n\t\t.base.cra_name\t\t= \"cbc(des)\",\n\t\t.base.cra_driver_name\t= \"cbc-des-rk\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK,\n\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct rk_cipher_ctx),\n\t\t.base.cra_alignmask\t= 0x07,\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.init\t\t\t= rk_cipher_tfm_init,\n\t\t.exit\t\t\t= rk_cipher_tfm_exit,\n\t\t.min_keysize\t\t= DES_KEY_SIZE,\n\t\t.max_keysize\t\t= DES_KEY_SIZE,\n\t\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t\t.setkey\t\t\t= rk_des_setkey,\n\t\t.encrypt\t\t= rk_des_cbc_encrypt,\n\t\t.decrypt\t\t= rk_des_cbc_decrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = rk_cipher_run,\n\t},\n};\n\nstruct rk_crypto_tmp rk_ecb_des3_ede_alg = {\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.alg.skcipher.base = {\n\t\t.base.cra_name\t\t= \"ecb(des3_ede)\",\n\t\t.base.cra_driver_name\t= \"ecb-des3-ede-rk\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK,\n\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct rk_cipher_ctx),\n\t\t.base.cra_alignmask\t= 0x07,\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.init\t\t\t= rk_cipher_tfm_init,\n\t\t.exit\t\t\t= rk_cipher_tfm_exit,\n\t\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.setkey\t\t\t= rk_tdes_setkey,\n\t\t.encrypt\t\t= rk_des3_ede_ecb_encrypt,\n\t\t.decrypt\t\t= rk_des3_ede_ecb_decrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = rk_cipher_run,\n\t},\n};\n\nstruct rk_crypto_tmp rk_cbc_des3_ede_alg = {\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.alg.skcipher.base = {\n\t\t.base.cra_name\t\t= \"cbc(des3_ede)\",\n\t\t.base.cra_driver_name\t= \"cbc-des3-ede-rk\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK,\n\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct rk_cipher_ctx),\n\t\t.base.cra_alignmask\t= 0x07,\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.init\t\t\t= rk_cipher_tfm_init,\n\t\t.exit\t\t\t= rk_cipher_tfm_exit,\n\t\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t\t.setkey\t\t\t= rk_tdes_setkey,\n\t\t.encrypt\t\t= rk_des3_ede_cbc_encrypt,\n\t\t.decrypt\t\t= rk_des3_ede_cbc_decrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = rk_cipher_run,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}