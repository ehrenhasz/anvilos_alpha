{
  "module_name": "cesa.c",
  "hash_id": "27fda1ab81feb67aaf5b6c4a38d90514eec8fc11efccef41307ea9c68cbdc11e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/cesa/cesa.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/genalloc.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kthread.h>\n#include <linux/mbus.h>\n#include <linux/platform_device.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_irq.h>\n\n#include \"cesa.h\"\n\n \n#define CESA_CRYPTO_DEFAULT_MAX_QLEN 128\n\nstruct mv_cesa_dev *cesa_dev;\n\nstruct crypto_async_request *\nmv_cesa_dequeue_req_locked(struct mv_cesa_engine *engine,\n\t\t\t   struct crypto_async_request **backlog)\n{\n\tstruct crypto_async_request *req;\n\n\t*backlog = crypto_get_backlog(&engine->queue);\n\treq = crypto_dequeue_request(&engine->queue);\n\n\tif (!req)\n\t\treturn NULL;\n\n\treturn req;\n}\n\nstatic void mv_cesa_rearm_engine(struct mv_cesa_engine *engine)\n{\n\tstruct crypto_async_request *req = NULL, *backlog = NULL;\n\tstruct mv_cesa_ctx *ctx;\n\n\n\tspin_lock_bh(&engine->lock);\n\tif (!engine->req) {\n\t\treq = mv_cesa_dequeue_req_locked(engine, &backlog);\n\t\tengine->req = req;\n\t}\n\tspin_unlock_bh(&engine->lock);\n\n\tif (!req)\n\t\treturn;\n\n\tif (backlog)\n\t\tcrypto_request_complete(backlog, -EINPROGRESS);\n\n\tctx = crypto_tfm_ctx(req->tfm);\n\tctx->ops->step(req);\n}\n\nstatic int mv_cesa_std_process(struct mv_cesa_engine *engine, u32 status)\n{\n\tstruct crypto_async_request *req;\n\tstruct mv_cesa_ctx *ctx;\n\tint res;\n\n\treq = engine->req;\n\tctx = crypto_tfm_ctx(req->tfm);\n\tres = ctx->ops->process(req, status);\n\n\tif (res == 0) {\n\t\tctx->ops->complete(req);\n\t\tmv_cesa_engine_enqueue_complete_request(engine, req);\n\t} else if (res == -EINPROGRESS) {\n\t\tctx->ops->step(req);\n\t}\n\n\treturn res;\n}\n\nstatic int mv_cesa_int_process(struct mv_cesa_engine *engine, u32 status)\n{\n\tif (engine->chain.first && engine->chain.last)\n\t\treturn mv_cesa_tdma_process(engine, status);\n\n\treturn mv_cesa_std_process(engine, status);\n}\n\nstatic inline void\nmv_cesa_complete_req(struct mv_cesa_ctx *ctx, struct crypto_async_request *req,\n\t\t     int res)\n{\n\tctx->ops->cleanup(req);\n\tlocal_bh_disable();\n\tcrypto_request_complete(req, res);\n\tlocal_bh_enable();\n}\n\nstatic irqreturn_t mv_cesa_int(int irq, void *priv)\n{\n\tstruct mv_cesa_engine *engine = priv;\n\tstruct crypto_async_request *req;\n\tstruct mv_cesa_ctx *ctx;\n\tu32 status, mask;\n\tirqreturn_t ret = IRQ_NONE;\n\n\twhile (true) {\n\t\tint res;\n\n\t\tmask = mv_cesa_get_int_mask(engine);\n\t\tstatus = readl(engine->regs + CESA_SA_INT_STATUS);\n\n\t\tif (!(status & mask))\n\t\t\tbreak;\n\n\t\t \n\t\twritel(~status, engine->regs + CESA_SA_FPGA_INT_STATUS);\n\t\twritel(~status, engine->regs + CESA_SA_INT_STATUS);\n\n\t\t \n\t\tres = mv_cesa_int_process(engine, status & mask);\n\t\tret = IRQ_HANDLED;\n\n\t\tspin_lock_bh(&engine->lock);\n\t\treq = engine->req;\n\t\tif (res != -EINPROGRESS)\n\t\t\tengine->req = NULL;\n\t\tspin_unlock_bh(&engine->lock);\n\n\t\tctx = crypto_tfm_ctx(req->tfm);\n\n\t\tif (res && res != -EINPROGRESS)\n\t\t\tmv_cesa_complete_req(ctx, req, res);\n\n\t\t \n\t\tmv_cesa_rearm_engine(engine);\n\n\t\t \n\t\twhile (true) {\n\t\t\treq = mv_cesa_engine_dequeue_complete_request(engine);\n\t\t\tif (!req)\n\t\t\t\tbreak;\n\n\t\t\tctx = crypto_tfm_ctx(req->tfm);\n\t\t\tmv_cesa_complete_req(ctx, req, 0);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint mv_cesa_queue_req(struct crypto_async_request *req,\n\t\t      struct mv_cesa_req *creq)\n{\n\tint ret;\n\tstruct mv_cesa_engine *engine = creq->engine;\n\n\tspin_lock_bh(&engine->lock);\n\tret = crypto_enqueue_request(&engine->queue, req);\n\tif ((mv_cesa_req_get_type(creq) == CESA_DMA_REQ) &&\n\t    (ret == -EINPROGRESS || ret == -EBUSY))\n\t\tmv_cesa_tdma_chain(engine, creq);\n\tspin_unlock_bh(&engine->lock);\n\n\tif (ret != -EINPROGRESS)\n\t\treturn ret;\n\n\tmv_cesa_rearm_engine(engine);\n\n\treturn -EINPROGRESS;\n}\n\nstatic int mv_cesa_add_algs(struct mv_cesa_dev *cesa)\n{\n\tint ret;\n\tint i, j;\n\n\tfor (i = 0; i < cesa->caps->ncipher_algs; i++) {\n\t\tret = crypto_register_skcipher(cesa->caps->cipher_algs[i]);\n\t\tif (ret)\n\t\t\tgoto err_unregister_crypto;\n\t}\n\n\tfor (i = 0; i < cesa->caps->nahash_algs; i++) {\n\t\tret = crypto_register_ahash(cesa->caps->ahash_algs[i]);\n\t\tif (ret)\n\t\t\tgoto err_unregister_ahash;\n\t}\n\n\treturn 0;\n\nerr_unregister_ahash:\n\tfor (j = 0; j < i; j++)\n\t\tcrypto_unregister_ahash(cesa->caps->ahash_algs[j]);\n\ti = cesa->caps->ncipher_algs;\n\nerr_unregister_crypto:\n\tfor (j = 0; j < i; j++)\n\t\tcrypto_unregister_skcipher(cesa->caps->cipher_algs[j]);\n\n\treturn ret;\n}\n\nstatic void mv_cesa_remove_algs(struct mv_cesa_dev *cesa)\n{\n\tint i;\n\n\tfor (i = 0; i < cesa->caps->nahash_algs; i++)\n\t\tcrypto_unregister_ahash(cesa->caps->ahash_algs[i]);\n\n\tfor (i = 0; i < cesa->caps->ncipher_algs; i++)\n\t\tcrypto_unregister_skcipher(cesa->caps->cipher_algs[i]);\n}\n\nstatic struct skcipher_alg *orion_cipher_algs[] = {\n\t&mv_cesa_ecb_des_alg,\n\t&mv_cesa_cbc_des_alg,\n\t&mv_cesa_ecb_des3_ede_alg,\n\t&mv_cesa_cbc_des3_ede_alg,\n\t&mv_cesa_ecb_aes_alg,\n\t&mv_cesa_cbc_aes_alg,\n};\n\nstatic struct ahash_alg *orion_ahash_algs[] = {\n\t&mv_md5_alg,\n\t&mv_sha1_alg,\n\t&mv_ahmac_md5_alg,\n\t&mv_ahmac_sha1_alg,\n};\n\nstatic struct skcipher_alg *armada_370_cipher_algs[] = {\n\t&mv_cesa_ecb_des_alg,\n\t&mv_cesa_cbc_des_alg,\n\t&mv_cesa_ecb_des3_ede_alg,\n\t&mv_cesa_cbc_des3_ede_alg,\n\t&mv_cesa_ecb_aes_alg,\n\t&mv_cesa_cbc_aes_alg,\n};\n\nstatic struct ahash_alg *armada_370_ahash_algs[] = {\n\t&mv_md5_alg,\n\t&mv_sha1_alg,\n\t&mv_sha256_alg,\n\t&mv_ahmac_md5_alg,\n\t&mv_ahmac_sha1_alg,\n\t&mv_ahmac_sha256_alg,\n};\n\nstatic const struct mv_cesa_caps orion_caps = {\n\t.nengines = 1,\n\t.cipher_algs = orion_cipher_algs,\n\t.ncipher_algs = ARRAY_SIZE(orion_cipher_algs),\n\t.ahash_algs = orion_ahash_algs,\n\t.nahash_algs = ARRAY_SIZE(orion_ahash_algs),\n\t.has_tdma = false,\n};\n\nstatic const struct mv_cesa_caps kirkwood_caps = {\n\t.nengines = 1,\n\t.cipher_algs = orion_cipher_algs,\n\t.ncipher_algs = ARRAY_SIZE(orion_cipher_algs),\n\t.ahash_algs = orion_ahash_algs,\n\t.nahash_algs = ARRAY_SIZE(orion_ahash_algs),\n\t.has_tdma = true,\n};\n\nstatic const struct mv_cesa_caps armada_370_caps = {\n\t.nengines = 1,\n\t.cipher_algs = armada_370_cipher_algs,\n\t.ncipher_algs = ARRAY_SIZE(armada_370_cipher_algs),\n\t.ahash_algs = armada_370_ahash_algs,\n\t.nahash_algs = ARRAY_SIZE(armada_370_ahash_algs),\n\t.has_tdma = true,\n};\n\nstatic const struct mv_cesa_caps armada_xp_caps = {\n\t.nengines = 2,\n\t.cipher_algs = armada_370_cipher_algs,\n\t.ncipher_algs = ARRAY_SIZE(armada_370_cipher_algs),\n\t.ahash_algs = armada_370_ahash_algs,\n\t.nahash_algs = ARRAY_SIZE(armada_370_ahash_algs),\n\t.has_tdma = true,\n};\n\nstatic const struct of_device_id mv_cesa_of_match_table[] = {\n\t{ .compatible = \"marvell,orion-crypto\", .data = &orion_caps },\n\t{ .compatible = \"marvell,kirkwood-crypto\", .data = &kirkwood_caps },\n\t{ .compatible = \"marvell,dove-crypto\", .data = &kirkwood_caps },\n\t{ .compatible = \"marvell,armada-370-crypto\", .data = &armada_370_caps },\n\t{ .compatible = \"marvell,armada-xp-crypto\", .data = &armada_xp_caps },\n\t{ .compatible = \"marvell,armada-375-crypto\", .data = &armada_xp_caps },\n\t{ .compatible = \"marvell,armada-38x-crypto\", .data = &armada_xp_caps },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mv_cesa_of_match_table);\n\nstatic void\nmv_cesa_conf_mbus_windows(struct mv_cesa_engine *engine,\n\t\t\t  const struct mbus_dram_target_info *dram)\n{\n\tvoid __iomem *iobase = engine->regs;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\twritel(0, iobase + CESA_TDMA_WINDOW_CTRL(i));\n\t\twritel(0, iobase + CESA_TDMA_WINDOW_BASE(i));\n\t}\n\n\tfor (i = 0; i < dram->num_cs; i++) {\n\t\tconst struct mbus_dram_window *cs = dram->cs + i;\n\n\t\twritel(((cs->size - 1) & 0xffff0000) |\n\t\t       (cs->mbus_attr << 8) |\n\t\t       (dram->mbus_dram_target_id << 4) | 1,\n\t\t       iobase + CESA_TDMA_WINDOW_CTRL(i));\n\t\twritel(cs->base, iobase + CESA_TDMA_WINDOW_BASE(i));\n\t}\n}\n\nstatic int mv_cesa_dev_dma_init(struct mv_cesa_dev *cesa)\n{\n\tstruct device *dev = cesa->dev;\n\tstruct mv_cesa_dev_dma *dma;\n\n\tif (!cesa->caps->has_tdma)\n\t\treturn 0;\n\n\tdma = devm_kzalloc(dev, sizeof(*dma), GFP_KERNEL);\n\tif (!dma)\n\t\treturn -ENOMEM;\n\n\tdma->tdma_desc_pool = dmam_pool_create(\"tdma_desc\", dev,\n\t\t\t\t\tsizeof(struct mv_cesa_tdma_desc),\n\t\t\t\t\t16, 0);\n\tif (!dma->tdma_desc_pool)\n\t\treturn -ENOMEM;\n\n\tdma->op_pool = dmam_pool_create(\"cesa_op\", dev,\n\t\t\t\t\tsizeof(struct mv_cesa_op_ctx), 16, 0);\n\tif (!dma->op_pool)\n\t\treturn -ENOMEM;\n\n\tdma->cache_pool = dmam_pool_create(\"cesa_cache\", dev,\n\t\t\t\t\t   CESA_MAX_HASH_BLOCK_SIZE, 1, 0);\n\tif (!dma->cache_pool)\n\t\treturn -ENOMEM;\n\n\tdma->padding_pool = dmam_pool_create(\"cesa_padding\", dev, 72, 1, 0);\n\tif (!dma->padding_pool)\n\t\treturn -ENOMEM;\n\n\tcesa->dma = dma;\n\n\treturn 0;\n}\n\nstatic int mv_cesa_get_sram(struct platform_device *pdev, int idx)\n{\n\tstruct mv_cesa_dev *cesa = platform_get_drvdata(pdev);\n\tstruct mv_cesa_engine *engine = &cesa->engines[idx];\n\tconst char *res_name = \"sram\";\n\tstruct resource *res;\n\n\tengine->pool = of_gen_pool_get(cesa->dev->of_node,\n\t\t\t\t       \"marvell,crypto-srams\", idx);\n\tif (engine->pool) {\n\t\tengine->sram_pool = gen_pool_dma_alloc(engine->pool,\n\t\t\t\t\t\t       cesa->sram_size,\n\t\t\t\t\t\t       &engine->sram_dma);\n\t\tif (engine->sram_pool)\n\t\t\treturn 0;\n\n\t\tengine->pool = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tif (cesa->caps->nengines > 1) {\n\t\tif (!idx)\n\t\t\tres_name = \"sram0\";\n\t\telse\n\t\t\tres_name = \"sram1\";\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t   res_name);\n\tif (!res || resource_size(res) < cesa->sram_size)\n\t\treturn -EINVAL;\n\n\tengine->sram = devm_ioremap_resource(cesa->dev, res);\n\tif (IS_ERR(engine->sram))\n\t\treturn PTR_ERR(engine->sram);\n\n\tengine->sram_dma = dma_map_resource(cesa->dev, res->start,\n\t\t\t\t\t    cesa->sram_size,\n\t\t\t\t\t    DMA_BIDIRECTIONAL, 0);\n\tif (dma_mapping_error(cesa->dev, engine->sram_dma))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void mv_cesa_put_sram(struct platform_device *pdev, int idx)\n{\n\tstruct mv_cesa_dev *cesa = platform_get_drvdata(pdev);\n\tstruct mv_cesa_engine *engine = &cesa->engines[idx];\n\n\tif (engine->pool)\n\t\tgen_pool_free(engine->pool, (unsigned long)engine->sram_pool,\n\t\t\t      cesa->sram_size);\n\telse\n\t\tdma_unmap_resource(cesa->dev, engine->sram_dma,\n\t\t\t\t   cesa->sram_size, DMA_BIDIRECTIONAL, 0);\n}\n\nstatic int mv_cesa_probe(struct platform_device *pdev)\n{\n\tconst struct mv_cesa_caps *caps = &orion_caps;\n\tconst struct mbus_dram_target_info *dram;\n\tconst struct of_device_id *match;\n\tstruct device *dev = &pdev->dev;\n\tstruct mv_cesa_dev *cesa;\n\tstruct mv_cesa_engine *engines;\n\tint irq, ret, i, cpu;\n\tu32 sram_size;\n\n\tif (cesa_dev) {\n\t\tdev_err(&pdev->dev, \"Only one CESA device authorized\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\tif (dev->of_node) {\n\t\tmatch = of_match_node(mv_cesa_of_match_table, dev->of_node);\n\t\tif (!match || !match->data)\n\t\t\treturn -ENOTSUPP;\n\n\t\tcaps = match->data;\n\t}\n\n\tcesa = devm_kzalloc(dev, sizeof(*cesa), GFP_KERNEL);\n\tif (!cesa)\n\t\treturn -ENOMEM;\n\n\tcesa->caps = caps;\n\tcesa->dev = dev;\n\n\tsram_size = CESA_SA_DEFAULT_SRAM_SIZE;\n\tof_property_read_u32(cesa->dev->of_node, \"marvell,crypto-sram-size\",\n\t\t\t     &sram_size);\n\tif (sram_size < CESA_SA_MIN_SRAM_SIZE)\n\t\tsram_size = CESA_SA_MIN_SRAM_SIZE;\n\n\tcesa->sram_size = sram_size;\n\tcesa->engines = devm_kcalloc(dev, caps->nengines, sizeof(*engines),\n\t\t\t\t     GFP_KERNEL);\n\tif (!cesa->engines)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&cesa->lock);\n\n\tcesa->regs = devm_platform_ioremap_resource_byname(pdev, \"regs\");\n\tif (IS_ERR(cesa->regs))\n\t\treturn PTR_ERR(cesa->regs);\n\n\tret = mv_cesa_dev_dma_init(cesa);\n\tif (ret)\n\t\treturn ret;\n\n\tdram = mv_mbus_dram_info_nooverlap();\n\n\tplatform_set_drvdata(pdev, cesa);\n\n\tfor (i = 0; i < caps->nengines; i++) {\n\t\tstruct mv_cesa_engine *engine = &cesa->engines[i];\n\t\tchar res_name[7];\n\n\t\tengine->id = i;\n\t\tspin_lock_init(&engine->lock);\n\n\t\tret = mv_cesa_get_sram(pdev, i);\n\t\tif (ret)\n\t\t\tgoto err_cleanup;\n\n\t\tirq = platform_get_irq(pdev, i);\n\t\tif (irq < 0) {\n\t\t\tret = irq;\n\t\t\tgoto err_cleanup;\n\t\t}\n\n\t\tengine->irq = irq;\n\n\t\t \n\t\tsnprintf(res_name, sizeof(res_name), \"cesa%d\", i);\n\t\tengine->clk = devm_clk_get(dev, res_name);\n\t\tif (IS_ERR(engine->clk)) {\n\t\t\tengine->clk = devm_clk_get(dev, NULL);\n\t\t\tif (IS_ERR(engine->clk))\n\t\t\t\tengine->clk = NULL;\n\t\t}\n\n\t\tsnprintf(res_name, sizeof(res_name), \"cesaz%d\", i);\n\t\tengine->zclk = devm_clk_get(dev, res_name);\n\t\tif (IS_ERR(engine->zclk))\n\t\t\tengine->zclk = NULL;\n\n\t\tret = clk_prepare_enable(engine->clk);\n\t\tif (ret)\n\t\t\tgoto err_cleanup;\n\n\t\tret = clk_prepare_enable(engine->zclk);\n\t\tif (ret)\n\t\t\tgoto err_cleanup;\n\n\t\tengine->regs = cesa->regs + CESA_ENGINE_OFF(i);\n\n\t\tif (dram && cesa->caps->has_tdma)\n\t\t\tmv_cesa_conf_mbus_windows(engine, dram);\n\n\t\twritel(0, engine->regs + CESA_SA_INT_STATUS);\n\t\twritel(CESA_SA_CFG_STOP_DIG_ERR,\n\t\t       engine->regs + CESA_SA_CFG);\n\t\twritel(engine->sram_dma & CESA_SA_SRAM_MSK,\n\t\t       engine->regs + CESA_SA_DESC_P0);\n\n\t\tret = devm_request_threaded_irq(dev, irq, NULL, mv_cesa_int,\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(&pdev->dev),\n\t\t\t\t\t\tengine);\n\t\tif (ret)\n\t\t\tgoto err_cleanup;\n\n\t\t \n\t\tcpu = cpumask_local_spread(engine->id, NUMA_NO_NODE);\n\t\tirq_set_affinity_hint(irq, get_cpu_mask(cpu));\n\n\t\tcrypto_init_queue(&engine->queue, CESA_CRYPTO_DEFAULT_MAX_QLEN);\n\t\tatomic_set(&engine->load, 0);\n\t\tINIT_LIST_HEAD(&engine->complete_queue);\n\t}\n\n\tcesa_dev = cesa;\n\n\tret = mv_cesa_add_algs(cesa);\n\tif (ret) {\n\t\tcesa_dev = NULL;\n\t\tgoto err_cleanup;\n\t}\n\n\tdev_info(dev, \"CESA device successfully registered\\n\");\n\n\treturn 0;\n\nerr_cleanup:\n\tfor (i = 0; i < caps->nengines; i++) {\n\t\tclk_disable_unprepare(cesa->engines[i].zclk);\n\t\tclk_disable_unprepare(cesa->engines[i].clk);\n\t\tmv_cesa_put_sram(pdev, i);\n\t\tif (cesa->engines[i].irq > 0)\n\t\t\tirq_set_affinity_hint(cesa->engines[i].irq, NULL);\n\t}\n\n\treturn ret;\n}\n\nstatic int mv_cesa_remove(struct platform_device *pdev)\n{\n\tstruct mv_cesa_dev *cesa = platform_get_drvdata(pdev);\n\tint i;\n\n\tmv_cesa_remove_algs(cesa);\n\n\tfor (i = 0; i < cesa->caps->nengines; i++) {\n\t\tclk_disable_unprepare(cesa->engines[i].zclk);\n\t\tclk_disable_unprepare(cesa->engines[i].clk);\n\t\tmv_cesa_put_sram(pdev, i);\n\t\tirq_set_affinity_hint(cesa->engines[i].irq, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id mv_cesa_plat_id_table[] = {\n\t{ .name = \"mv_crypto\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(platform, mv_cesa_plat_id_table);\n\nstatic struct platform_driver marvell_cesa = {\n\t.probe\t\t= mv_cesa_probe,\n\t.remove\t\t= mv_cesa_remove,\n\t.id_table\t= mv_cesa_plat_id_table,\n\t.driver\t\t= {\n\t\t.name\t= \"marvell-cesa\",\n\t\t.of_match_table = mv_cesa_of_match_table,\n\t},\n};\nmodule_platform_driver(marvell_cesa);\n\nMODULE_AUTHOR(\"Boris Brezillon <boris.brezillon@free-electrons.com>\");\nMODULE_AUTHOR(\"Arnaud Ebalard <arno@natisbad.org>\");\nMODULE_DESCRIPTION(\"Support for Marvell's cryptographic engine\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}