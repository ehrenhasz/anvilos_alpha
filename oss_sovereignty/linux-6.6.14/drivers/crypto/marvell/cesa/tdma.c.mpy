{
  "module_name": "tdma.c",
  "hash_id": "b0f44e5959f7d8cb578b6be66b7024e16b12b09e5a7fe050ef8228acaad2aa53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/cesa/tdma.c",
  "human_readable_source": "\n \n\n#include \"cesa.h\"\n\nbool mv_cesa_req_dma_iter_next_transfer(struct mv_cesa_dma_iter *iter,\n\t\t\t\t\tstruct mv_cesa_sg_dma_iter *sgiter,\n\t\t\t\t\tunsigned int len)\n{\n\tif (!sgiter->sg)\n\t\treturn false;\n\n\tsgiter->op_offset += len;\n\tsgiter->offset += len;\n\tif (sgiter->offset == sg_dma_len(sgiter->sg)) {\n\t\tif (sg_is_last(sgiter->sg))\n\t\t\treturn false;\n\t\tsgiter->offset = 0;\n\t\tsgiter->sg = sg_next(sgiter->sg);\n\t}\n\n\tif (sgiter->op_offset == iter->op_len)\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid mv_cesa_dma_step(struct mv_cesa_req *dreq)\n{\n\tstruct mv_cesa_engine *engine = dreq->engine;\n\n\twritel_relaxed(0, engine->regs + CESA_SA_CFG);\n\n\tmv_cesa_set_int_mask(engine, CESA_SA_INT_ACC0_IDMA_DONE);\n\twritel_relaxed(CESA_TDMA_DST_BURST_128B | CESA_TDMA_SRC_BURST_128B |\n\t\t       CESA_TDMA_NO_BYTE_SWAP | CESA_TDMA_EN,\n\t\t       engine->regs + CESA_TDMA_CONTROL);\n\n\twritel_relaxed(CESA_SA_CFG_ACT_CH0_IDMA | CESA_SA_CFG_MULTI_PKT |\n\t\t       CESA_SA_CFG_CH0_W_IDMA | CESA_SA_CFG_PARA_DIS,\n\t\t       engine->regs + CESA_SA_CFG);\n\twritel_relaxed(dreq->chain.first->cur_dma,\n\t\t       engine->regs + CESA_TDMA_NEXT_ADDR);\n\tWARN_ON(readl(engine->regs + CESA_SA_CMD) &\n\t\tCESA_SA_CMD_EN_CESA_SA_ACCL0);\n\twritel(CESA_SA_CMD_EN_CESA_SA_ACCL0, engine->regs + CESA_SA_CMD);\n}\n\nvoid mv_cesa_dma_cleanup(struct mv_cesa_req *dreq)\n{\n\tstruct mv_cesa_tdma_desc *tdma;\n\n\tfor (tdma = dreq->chain.first; tdma;) {\n\t\tstruct mv_cesa_tdma_desc *old_tdma = tdma;\n\t\tu32 type = tdma->flags & CESA_TDMA_TYPE_MSK;\n\n\t\tif (type == CESA_TDMA_OP)\n\t\t\tdma_pool_free(cesa_dev->dma->op_pool, tdma->op,\n\t\t\t\t      le32_to_cpu(tdma->src));\n\n\t\ttdma = tdma->next;\n\t\tdma_pool_free(cesa_dev->dma->tdma_desc_pool, old_tdma,\n\t\t\t      old_tdma->cur_dma);\n\t}\n\n\tdreq->chain.first = NULL;\n\tdreq->chain.last = NULL;\n}\n\nvoid mv_cesa_dma_prepare(struct mv_cesa_req *dreq,\n\t\t\t struct mv_cesa_engine *engine)\n{\n\tstruct mv_cesa_tdma_desc *tdma;\n\n\tfor (tdma = dreq->chain.first; tdma; tdma = tdma->next) {\n\t\tif (tdma->flags & CESA_TDMA_DST_IN_SRAM)\n\t\t\ttdma->dst = cpu_to_le32(tdma->dst_dma + engine->sram_dma);\n\n\t\tif (tdma->flags & CESA_TDMA_SRC_IN_SRAM)\n\t\t\ttdma->src = cpu_to_le32(tdma->src_dma + engine->sram_dma);\n\n\t\tif ((tdma->flags & CESA_TDMA_TYPE_MSK) == CESA_TDMA_OP)\n\t\t\tmv_cesa_adjust_op(engine, tdma->op);\n\t}\n}\n\nvoid mv_cesa_tdma_chain(struct mv_cesa_engine *engine,\n\t\t\tstruct mv_cesa_req *dreq)\n{\n\tif (engine->chain.first == NULL && engine->chain.last == NULL) {\n\t\tengine->chain.first = dreq->chain.first;\n\t\tengine->chain.last  = dreq->chain.last;\n\t} else {\n\t\tstruct mv_cesa_tdma_desc *last;\n\n\t\tlast = engine->chain.last;\n\t\tlast->next = dreq->chain.first;\n\t\tengine->chain.last = dreq->chain.last;\n\n\t\t \n\t\tif (!(last->flags & CESA_TDMA_BREAK_CHAIN) &&\n\t\t    !(dreq->chain.first->flags & CESA_TDMA_SET_STATE))\n\t\t\tlast->next_dma = cpu_to_le32(dreq->chain.first->cur_dma);\n\t}\n}\n\nint mv_cesa_tdma_process(struct mv_cesa_engine *engine, u32 status)\n{\n\tstruct crypto_async_request *req = NULL;\n\tstruct mv_cesa_tdma_desc *tdma = NULL, *next = NULL;\n\tdma_addr_t tdma_cur;\n\tint res = 0;\n\n\ttdma_cur = readl(engine->regs + CESA_TDMA_CUR);\n\n\tfor (tdma = engine->chain.first; tdma; tdma = next) {\n\t\tspin_lock_bh(&engine->lock);\n\t\tnext = tdma->next;\n\t\tspin_unlock_bh(&engine->lock);\n\n\t\tif (tdma->flags & CESA_TDMA_END_OF_REQ) {\n\t\t\tstruct crypto_async_request *backlog = NULL;\n\t\t\tstruct mv_cesa_ctx *ctx;\n\t\t\tu32 current_status;\n\n\t\t\tspin_lock_bh(&engine->lock);\n\t\t\t \n\t\t\tif (!req)\n\t\t\t\treq = engine->req;\n\t\t\telse\n\t\t\t\treq = mv_cesa_dequeue_req_locked(engine,\n\t\t\t\t\t\t\t\t &backlog);\n\n\t\t\t \n\t\t\tengine->chain.first = tdma->next;\n\t\t\ttdma->next = NULL;\n\n\t\t\t \n\t\t\tif (engine->chain.first == NULL)\n\t\t\t\tengine->chain.last  = NULL;\n\t\t\tspin_unlock_bh(&engine->lock);\n\n\t\t\tctx = crypto_tfm_ctx(req->tfm);\n\t\t\tcurrent_status = (tdma->cur_dma == tdma_cur) ?\n\t\t\t\t\t  status : CESA_SA_INT_ACC0_IDMA_DONE;\n\t\t\tres = ctx->ops->process(req, current_status);\n\t\t\tctx->ops->complete(req);\n\n\t\t\tif (res == 0)\n\t\t\t\tmv_cesa_engine_enqueue_complete_request(engine,\n\t\t\t\t\t\t\t\t\treq);\n\n\t\t\tif (backlog)\n\t\t\t\tcrypto_request_complete(backlog, -EINPROGRESS);\n\t\t}\n\n\t\tif (res || tdma->cur_dma == tdma_cur)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (res) {\n\t\tspin_lock_bh(&engine->lock);\n\t\tengine->req = req;\n\t\tspin_unlock_bh(&engine->lock);\n\t}\n\n\treturn res;\n}\n\nstatic struct mv_cesa_tdma_desc *\nmv_cesa_dma_add_desc(struct mv_cesa_tdma_chain *chain, gfp_t flags)\n{\n\tstruct mv_cesa_tdma_desc *new_tdma = NULL;\n\tdma_addr_t dma_handle;\n\n\tnew_tdma = dma_pool_zalloc(cesa_dev->dma->tdma_desc_pool, flags,\n\t\t\t\t   &dma_handle);\n\tif (!new_tdma)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnew_tdma->cur_dma = dma_handle;\n\tif (chain->last) {\n\t\tchain->last->next_dma = cpu_to_le32(dma_handle);\n\t\tchain->last->next = new_tdma;\n\t} else {\n\t\tchain->first = new_tdma;\n\t}\n\n\tchain->last = new_tdma;\n\n\treturn new_tdma;\n}\n\nint mv_cesa_dma_add_result_op(struct mv_cesa_tdma_chain *chain, dma_addr_t src,\n\t\t\t  u32 size, u32 flags, gfp_t gfp_flags)\n{\n\tstruct mv_cesa_tdma_desc *tdma, *op_desc;\n\n\ttdma = mv_cesa_dma_add_desc(chain, gfp_flags);\n\tif (IS_ERR(tdma))\n\t\treturn PTR_ERR(tdma);\n\n\t \n\tfor (op_desc = chain->first; op_desc; op_desc = op_desc->next) {\n\t\tu32 type = op_desc->flags & CESA_TDMA_TYPE_MSK;\n\n\t\tif (type == CESA_TDMA_OP)\n\t\t\tbreak;\n\t}\n\n\tif (!op_desc)\n\t\treturn -EIO;\n\n\ttdma->byte_cnt = cpu_to_le32(size | BIT(31));\n\ttdma->src_dma = src;\n\ttdma->dst_dma = op_desc->src_dma;\n\ttdma->op = op_desc->op;\n\n\tflags &= (CESA_TDMA_DST_IN_SRAM | CESA_TDMA_SRC_IN_SRAM);\n\ttdma->flags = flags | CESA_TDMA_RESULT;\n\treturn 0;\n}\n\nstruct mv_cesa_op_ctx *mv_cesa_dma_add_op(struct mv_cesa_tdma_chain *chain,\n\t\t\t\t\tconst struct mv_cesa_op_ctx *op_templ,\n\t\t\t\t\tbool skip_ctx,\n\t\t\t\t\tgfp_t flags)\n{\n\tstruct mv_cesa_tdma_desc *tdma;\n\tstruct mv_cesa_op_ctx *op;\n\tdma_addr_t dma_handle;\n\tunsigned int size;\n\n\ttdma = mv_cesa_dma_add_desc(chain, flags);\n\tif (IS_ERR(tdma))\n\t\treturn ERR_CAST(tdma);\n\n\top = dma_pool_alloc(cesa_dev->dma->op_pool, flags, &dma_handle);\n\tif (!op)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t*op = *op_templ;\n\n\tsize = skip_ctx ? sizeof(op->desc) : sizeof(*op);\n\n\ttdma = chain->last;\n\ttdma->op = op;\n\ttdma->byte_cnt = cpu_to_le32(size | BIT(31));\n\ttdma->src = cpu_to_le32(dma_handle);\n\ttdma->dst_dma = CESA_SA_CFG_SRAM_OFFSET;\n\ttdma->flags = CESA_TDMA_DST_IN_SRAM | CESA_TDMA_OP;\n\n\treturn op;\n}\n\nint mv_cesa_dma_add_data_transfer(struct mv_cesa_tdma_chain *chain,\n\t\t\t\t  dma_addr_t dst, dma_addr_t src, u32 size,\n\t\t\t\t  u32 flags, gfp_t gfp_flags)\n{\n\tstruct mv_cesa_tdma_desc *tdma;\n\n\ttdma = mv_cesa_dma_add_desc(chain, gfp_flags);\n\tif (IS_ERR(tdma))\n\t\treturn PTR_ERR(tdma);\n\n\ttdma->byte_cnt = cpu_to_le32(size | BIT(31));\n\ttdma->src_dma = src;\n\ttdma->dst_dma = dst;\n\n\tflags &= (CESA_TDMA_DST_IN_SRAM | CESA_TDMA_SRC_IN_SRAM);\n\ttdma->flags = flags | CESA_TDMA_DATA;\n\n\treturn 0;\n}\n\nint mv_cesa_dma_add_dummy_launch(struct mv_cesa_tdma_chain *chain, gfp_t flags)\n{\n\tstruct mv_cesa_tdma_desc *tdma;\n\n\ttdma = mv_cesa_dma_add_desc(chain, flags);\n\treturn PTR_ERR_OR_ZERO(tdma);\n}\n\nint mv_cesa_dma_add_dummy_end(struct mv_cesa_tdma_chain *chain, gfp_t flags)\n{\n\tstruct mv_cesa_tdma_desc *tdma;\n\n\ttdma = mv_cesa_dma_add_desc(chain, flags);\n\tif (IS_ERR(tdma))\n\t\treturn PTR_ERR(tdma);\n\n\ttdma->byte_cnt = cpu_to_le32(BIT(31));\n\n\treturn 0;\n}\n\nint mv_cesa_dma_add_op_transfers(struct mv_cesa_tdma_chain *chain,\n\t\t\t\t struct mv_cesa_dma_iter *dma_iter,\n\t\t\t\t struct mv_cesa_sg_dma_iter *sgiter,\n\t\t\t\t gfp_t gfp_flags)\n{\n\tu32 flags = sgiter->dir == DMA_TO_DEVICE ?\n\t\t    CESA_TDMA_DST_IN_SRAM : CESA_TDMA_SRC_IN_SRAM;\n\tunsigned int len;\n\n\tdo {\n\t\tdma_addr_t dst, src;\n\t\tint ret;\n\n\t\tlen = mv_cesa_req_dma_iter_transfer_len(dma_iter, sgiter);\n\t\tif (sgiter->dir == DMA_TO_DEVICE) {\n\t\t\tdst = CESA_SA_DATA_SRAM_OFFSET + sgiter->op_offset;\n\t\t\tsrc = sg_dma_address(sgiter->sg) + sgiter->offset;\n\t\t} else {\n\t\t\tdst = sg_dma_address(sgiter->sg) + sgiter->offset;\n\t\t\tsrc = CESA_SA_DATA_SRAM_OFFSET + sgiter->op_offset;\n\t\t}\n\n\t\tret = mv_cesa_dma_add_data_transfer(chain, dst, src, len,\n\t\t\t\t\t\t    flags, gfp_flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t} while (mv_cesa_req_dma_iter_next_transfer(dma_iter, sgiter, len));\n\n\treturn 0;\n}\n\nsize_t mv_cesa_sg_copy(struct mv_cesa_engine *engine,\n\t\t       struct scatterlist *sgl, unsigned int nents,\n\t\t       unsigned int sram_off, size_t buflen, off_t skip,\n\t\t       bool to_sram)\n{\n\tunsigned int sg_flags = SG_MITER_ATOMIC;\n\tstruct sg_mapping_iter miter;\n\tunsigned int offset = 0;\n\n\tif (to_sram)\n\t\tsg_flags |= SG_MITER_FROM_SG;\n\telse\n\t\tsg_flags |= SG_MITER_TO_SG;\n\n\tsg_miter_start(&miter, sgl, nents, sg_flags);\n\n\tif (!sg_miter_skip(&miter, skip))\n\t\treturn 0;\n\n\twhile ((offset < buflen) && sg_miter_next(&miter)) {\n\t\tunsigned int len;\n\n\t\tlen = min(miter.length, buflen - offset);\n\n\t\tif (to_sram) {\n\t\t\tif (engine->pool)\n\t\t\t\tmemcpy(engine->sram_pool + sram_off + offset,\n\t\t\t\t       miter.addr, len);\n\t\t\telse\n\t\t\t\tmemcpy_toio(engine->sram + sram_off + offset,\n\t\t\t\t\t    miter.addr, len);\n\t\t} else {\n\t\t\tif (engine->pool)\n\t\t\t\tmemcpy(miter.addr,\n\t\t\t\t       engine->sram_pool + sram_off + offset,\n\t\t\t\t       len);\n\t\t\telse\n\t\t\t\tmemcpy_fromio(miter.addr,\n\t\t\t\t\t      engine->sram + sram_off + offset,\n\t\t\t\t\t      len);\n\t\t}\n\n\t\toffset += len;\n\t}\n\n\tsg_miter_stop(&miter);\n\n\treturn offset;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}