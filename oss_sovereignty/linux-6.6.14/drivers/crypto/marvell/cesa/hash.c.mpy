{
  "module_name": "hash.c",
  "hash_id": "00775447e2a0baab537b26da672ea5878d02bb5acb07f73c447f3026dcca45b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/cesa/hash.c",
  "human_readable_source": "\n \n\n#include <crypto/hmac.h>\n#include <crypto/md5.h>\n#include <crypto/sha1.h>\n#include <crypto/sha2.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n\n#include \"cesa.h\"\n\nstruct mv_cesa_ahash_dma_iter {\n\tstruct mv_cesa_dma_iter base;\n\tstruct mv_cesa_sg_dma_iter src;\n};\n\nstatic inline void\nmv_cesa_ahash_req_iter_init(struct mv_cesa_ahash_dma_iter *iter,\n\t\t\t    struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tunsigned int len = req->nbytes + creq->cache_ptr;\n\n\tif (!creq->last_req)\n\t\tlen &= ~CESA_HASH_BLOCK_SIZE_MSK;\n\n\tmv_cesa_req_dma_iter_init(&iter->base, len);\n\tmv_cesa_sg_dma_iter_init(&iter->src, req->src, DMA_TO_DEVICE);\n\titer->src.op_offset = creq->cache_ptr;\n}\n\nstatic inline bool\nmv_cesa_ahash_req_iter_next_op(struct mv_cesa_ahash_dma_iter *iter)\n{\n\titer->src.op_offset = 0;\n\n\treturn mv_cesa_req_dma_iter_next_op(&iter->base);\n}\n\nstatic inline int\nmv_cesa_ahash_dma_alloc_cache(struct mv_cesa_ahash_dma_req *req, gfp_t flags)\n{\n\treq->cache = dma_pool_alloc(cesa_dev->dma->cache_pool, flags,\n\t\t\t\t    &req->cache_dma);\n\tif (!req->cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic inline void\nmv_cesa_ahash_dma_free_cache(struct mv_cesa_ahash_dma_req *req)\n{\n\tif (!req->cache)\n\t\treturn;\n\n\tdma_pool_free(cesa_dev->dma->cache_pool, req->cache,\n\t\t      req->cache_dma);\n}\n\nstatic int mv_cesa_ahash_dma_alloc_padding(struct mv_cesa_ahash_dma_req *req,\n\t\t\t\t\t   gfp_t flags)\n{\n\tif (req->padding)\n\t\treturn 0;\n\n\treq->padding = dma_pool_alloc(cesa_dev->dma->padding_pool, flags,\n\t\t\t\t      &req->padding_dma);\n\tif (!req->padding)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void mv_cesa_ahash_dma_free_padding(struct mv_cesa_ahash_dma_req *req)\n{\n\tif (!req->padding)\n\t\treturn;\n\n\tdma_pool_free(cesa_dev->dma->padding_pool, req->padding,\n\t\t      req->padding_dma);\n\treq->padding = NULL;\n}\n\nstatic inline void mv_cesa_ahash_dma_last_cleanup(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\n\tmv_cesa_ahash_dma_free_padding(&creq->req.dma);\n}\n\nstatic inline void mv_cesa_ahash_dma_cleanup(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\n\tdma_unmap_sg(cesa_dev->dev, req->src, creq->src_nents, DMA_TO_DEVICE);\n\tmv_cesa_ahash_dma_free_cache(&creq->req.dma);\n\tmv_cesa_dma_cleanup(&creq->base);\n}\n\nstatic inline void mv_cesa_ahash_cleanup(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\n\tif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ)\n\t\tmv_cesa_ahash_dma_cleanup(req);\n}\n\nstatic void mv_cesa_ahash_last_cleanup(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\n\tif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ)\n\t\tmv_cesa_ahash_dma_last_cleanup(req);\n}\n\nstatic int mv_cesa_ahash_pad_len(struct mv_cesa_ahash_req *creq)\n{\n\tunsigned int index, padlen;\n\n\tindex = creq->len & CESA_HASH_BLOCK_SIZE_MSK;\n\tpadlen = (index < 56) ? (56 - index) : (64 + 56 - index);\n\n\treturn padlen;\n}\n\nstatic int mv_cesa_ahash_pad_req(struct mv_cesa_ahash_req *creq, u8 *buf)\n{\n\tunsigned int padlen;\n\n\tbuf[0] = 0x80;\n\t \n\tpadlen = mv_cesa_ahash_pad_len(creq);\n\tmemset(buf + 1, 0, padlen - 1);\n\n\tif (creq->algo_le) {\n\t\t__le64 bits = cpu_to_le64(creq->len << 3);\n\n\t\tmemcpy(buf + padlen, &bits, sizeof(bits));\n\t} else {\n\t\t__be64 bits = cpu_to_be64(creq->len << 3);\n\n\t\tmemcpy(buf + padlen, &bits, sizeof(bits));\n\t}\n\n\treturn padlen + 8;\n}\n\nstatic void mv_cesa_ahash_std_step(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tstruct mv_cesa_ahash_std_req *sreq = &creq->req.std;\n\tstruct mv_cesa_engine *engine = creq->base.engine;\n\tstruct mv_cesa_op_ctx *op;\n\tunsigned int new_cache_ptr = 0;\n\tu32 frag_mode;\n\tsize_t  len;\n\tunsigned int digsize;\n\tint i;\n\n\tmv_cesa_adjust_op(engine, &creq->op_tmpl);\n\tif (engine->pool)\n\t\tmemcpy(engine->sram_pool, &creq->op_tmpl,\n\t\t       sizeof(creq->op_tmpl));\n\telse\n\t\tmemcpy_toio(engine->sram, &creq->op_tmpl,\n\t\t\t    sizeof(creq->op_tmpl));\n\n\tif (!sreq->offset) {\n\t\tdigsize = crypto_ahash_digestsize(crypto_ahash_reqtfm(req));\n\t\tfor (i = 0; i < digsize / 4; i++)\n\t\t\twritel_relaxed(creq->state[i],\n\t\t\t\t       engine->regs + CESA_IVDIG(i));\n\t}\n\n\tif (creq->cache_ptr) {\n\t\tif (engine->pool)\n\t\t\tmemcpy(engine->sram_pool + CESA_SA_DATA_SRAM_OFFSET,\n\t\t\t       creq->cache, creq->cache_ptr);\n\t\telse\n\t\t\tmemcpy_toio(engine->sram + CESA_SA_DATA_SRAM_OFFSET,\n\t\t\t\t    creq->cache, creq->cache_ptr);\n\t}\n\n\tlen = min_t(size_t, req->nbytes + creq->cache_ptr - sreq->offset,\n\t\t    CESA_SA_SRAM_PAYLOAD_SIZE);\n\n\tif (!creq->last_req) {\n\t\tnew_cache_ptr = len & CESA_HASH_BLOCK_SIZE_MSK;\n\t\tlen &= ~CESA_HASH_BLOCK_SIZE_MSK;\n\t}\n\n\tif (len - creq->cache_ptr)\n\t\tsreq->offset += mv_cesa_sg_copy_to_sram(\n\t\t\tengine, req->src, creq->src_nents,\n\t\t\tCESA_SA_DATA_SRAM_OFFSET + creq->cache_ptr,\n\t\t\tlen - creq->cache_ptr, sreq->offset);\n\n\top = &creq->op_tmpl;\n\n\tfrag_mode = mv_cesa_get_op_cfg(op) & CESA_SA_DESC_CFG_FRAG_MSK;\n\n\tif (creq->last_req && sreq->offset == req->nbytes &&\n\t    creq->len <= CESA_SA_DESC_MAC_SRC_TOTAL_LEN_MAX) {\n\t\tif (frag_mode == CESA_SA_DESC_CFG_FIRST_FRAG)\n\t\t\tfrag_mode = CESA_SA_DESC_CFG_NOT_FRAG;\n\t\telse if (frag_mode == CESA_SA_DESC_CFG_MID_FRAG)\n\t\t\tfrag_mode = CESA_SA_DESC_CFG_LAST_FRAG;\n\t}\n\n\tif (frag_mode == CESA_SA_DESC_CFG_NOT_FRAG ||\n\t    frag_mode == CESA_SA_DESC_CFG_LAST_FRAG) {\n\t\tif (len &&\n\t\t    creq->len <= CESA_SA_DESC_MAC_SRC_TOTAL_LEN_MAX) {\n\t\t\tmv_cesa_set_mac_op_total_len(op, creq->len);\n\t\t} else {\n\t\t\tint trailerlen = mv_cesa_ahash_pad_len(creq) + 8;\n\n\t\t\tif (len + trailerlen > CESA_SA_SRAM_PAYLOAD_SIZE) {\n\t\t\t\tlen &= CESA_HASH_BLOCK_SIZE_MSK;\n\t\t\t\tnew_cache_ptr = 64 - trailerlen;\n\t\t\t\tif (engine->pool)\n\t\t\t\t\tmemcpy(creq->cache,\n\t\t\t\t\t       engine->sram_pool +\n\t\t\t\t\t       CESA_SA_DATA_SRAM_OFFSET + len,\n\t\t\t\t\t       new_cache_ptr);\n\t\t\t\telse\n\t\t\t\t\tmemcpy_fromio(creq->cache,\n\t\t\t\t\t\t      engine->sram +\n\t\t\t\t\t\t      CESA_SA_DATA_SRAM_OFFSET +\n\t\t\t\t\t\t      len,\n\t\t\t\t\t\t      new_cache_ptr);\n\t\t\t} else {\n\t\t\t\ti = mv_cesa_ahash_pad_req(creq, creq->cache);\n\t\t\t\tlen += i;\n\t\t\t\tif (engine->pool)\n\t\t\t\t\tmemcpy(engine->sram_pool + len +\n\t\t\t\t\t       CESA_SA_DATA_SRAM_OFFSET,\n\t\t\t\t\t       creq->cache, i);\n\t\t\t\telse\n\t\t\t\t\tmemcpy_toio(engine->sram + len +\n\t\t\t\t\t\t    CESA_SA_DATA_SRAM_OFFSET,\n\t\t\t\t\t\t    creq->cache, i);\n\t\t\t}\n\n\t\t\tif (frag_mode == CESA_SA_DESC_CFG_LAST_FRAG)\n\t\t\t\tfrag_mode = CESA_SA_DESC_CFG_MID_FRAG;\n\t\t\telse\n\t\t\t\tfrag_mode = CESA_SA_DESC_CFG_FIRST_FRAG;\n\t\t}\n\t}\n\n\tmv_cesa_set_mac_op_frag_len(op, len);\n\tmv_cesa_update_op_cfg(op, frag_mode, CESA_SA_DESC_CFG_FRAG_MSK);\n\n\t \n\tif (engine->pool)\n\t\tmemcpy(engine->sram_pool, op, sizeof(*op));\n\telse\n\t\tmemcpy_toio(engine->sram, op, sizeof(*op));\n\n\tif (frag_mode == CESA_SA_DESC_CFG_FIRST_FRAG)\n\t\tmv_cesa_update_op_cfg(op, CESA_SA_DESC_CFG_MID_FRAG,\n\t\t\t\t      CESA_SA_DESC_CFG_FRAG_MSK);\n\n\tcreq->cache_ptr = new_cache_ptr;\n\n\tmv_cesa_set_int_mask(engine, CESA_SA_INT_ACCEL0_DONE);\n\twritel_relaxed(CESA_SA_CFG_PARA_DIS, engine->regs + CESA_SA_CFG);\n\tWARN_ON(readl(engine->regs + CESA_SA_CMD) &\n\t\tCESA_SA_CMD_EN_CESA_SA_ACCL0);\n\twritel(CESA_SA_CMD_EN_CESA_SA_ACCL0, engine->regs + CESA_SA_CMD);\n}\n\nstatic int mv_cesa_ahash_std_process(struct ahash_request *req, u32 status)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tstruct mv_cesa_ahash_std_req *sreq = &creq->req.std;\n\n\tif (sreq->offset < (req->nbytes - creq->cache_ptr))\n\t\treturn -EINPROGRESS;\n\n\treturn 0;\n}\n\nstatic inline void mv_cesa_ahash_dma_prepare(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tstruct mv_cesa_req *basereq = &creq->base;\n\n\tmv_cesa_dma_prepare(basereq, basereq->engine);\n}\n\nstatic void mv_cesa_ahash_std_prepare(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tstruct mv_cesa_ahash_std_req *sreq = &creq->req.std;\n\n\tsreq->offset = 0;\n}\n\nstatic void mv_cesa_ahash_dma_step(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tstruct mv_cesa_req *base = &creq->base;\n\n\t \n\tif (base->chain.first->flags & CESA_TDMA_SET_STATE) {\n\t\tstruct mv_cesa_engine *engine = base->engine;\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(creq->state); i++)\n\t\t\twritel_relaxed(creq->state[i], engine->regs +\n\t\t\t\t       CESA_IVDIG(i));\n\t}\n\n\tmv_cesa_dma_step(base);\n}\n\nstatic void mv_cesa_ahash_step(struct crypto_async_request *req)\n{\n\tstruct ahash_request *ahashreq = ahash_request_cast(req);\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(ahashreq);\n\n\tif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ)\n\t\tmv_cesa_ahash_dma_step(ahashreq);\n\telse\n\t\tmv_cesa_ahash_std_step(ahashreq);\n}\n\nstatic int mv_cesa_ahash_process(struct crypto_async_request *req, u32 status)\n{\n\tstruct ahash_request *ahashreq = ahash_request_cast(req);\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(ahashreq);\n\n\tif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ)\n\t\treturn mv_cesa_dma_process(&creq->base, status);\n\n\treturn mv_cesa_ahash_std_process(ahashreq, status);\n}\n\nstatic void mv_cesa_ahash_complete(struct crypto_async_request *req)\n{\n\tstruct ahash_request *ahashreq = ahash_request_cast(req);\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(ahashreq);\n\tstruct mv_cesa_engine *engine = creq->base.engine;\n\tunsigned int digsize;\n\tint i;\n\n\tdigsize = crypto_ahash_digestsize(crypto_ahash_reqtfm(ahashreq));\n\n\tif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ &&\n\t    (creq->base.chain.last->flags & CESA_TDMA_TYPE_MSK) ==\n\t     CESA_TDMA_RESULT) {\n\t\t__le32 *data = NULL;\n\n\t\t \n\t\tdata = creq->base.chain.last->op->ctx.hash.hash;\n\t\tfor (i = 0; i < digsize / 4; i++)\n\t\t\tcreq->state[i] = le32_to_cpu(data[i]);\n\n\t\tmemcpy(ahashreq->result, data, digsize);\n\t} else {\n\t\tfor (i = 0; i < digsize / 4; i++)\n\t\t\tcreq->state[i] = readl_relaxed(engine->regs +\n\t\t\t\t\t\t       CESA_IVDIG(i));\n\t\tif (creq->last_req) {\n\t\t\t \n\t\t\tif (creq->algo_le) {\n\t\t\t\t__le32 *result = (void *)ahashreq->result;\n\n\t\t\t\tfor (i = 0; i < digsize / 4; i++)\n\t\t\t\t\tresult[i] = cpu_to_le32(creq->state[i]);\n\t\t\t} else {\n\t\t\t\t__be32 *result = (void *)ahashreq->result;\n\n\t\t\t\tfor (i = 0; i < digsize / 4; i++)\n\t\t\t\t\tresult[i] = cpu_to_be32(creq->state[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tatomic_sub(ahashreq->nbytes, &engine->load);\n}\n\nstatic void mv_cesa_ahash_prepare(struct crypto_async_request *req,\n\t\t\t\t  struct mv_cesa_engine *engine)\n{\n\tstruct ahash_request *ahashreq = ahash_request_cast(req);\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(ahashreq);\n\n\tcreq->base.engine = engine;\n\n\tif (mv_cesa_req_get_type(&creq->base) == CESA_DMA_REQ)\n\t\tmv_cesa_ahash_dma_prepare(ahashreq);\n\telse\n\t\tmv_cesa_ahash_std_prepare(ahashreq);\n}\n\nstatic void mv_cesa_ahash_req_cleanup(struct crypto_async_request *req)\n{\n\tstruct ahash_request *ahashreq = ahash_request_cast(req);\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(ahashreq);\n\n\tif (creq->last_req)\n\t\tmv_cesa_ahash_last_cleanup(ahashreq);\n\n\tmv_cesa_ahash_cleanup(ahashreq);\n\n\tif (creq->cache_ptr)\n\t\tsg_pcopy_to_buffer(ahashreq->src, creq->src_nents,\n\t\t\t\t   creq->cache,\n\t\t\t\t   creq->cache_ptr,\n\t\t\t\t   ahashreq->nbytes - creq->cache_ptr);\n}\n\nstatic const struct mv_cesa_req_ops mv_cesa_ahash_req_ops = {\n\t.step = mv_cesa_ahash_step,\n\t.process = mv_cesa_ahash_process,\n\t.cleanup = mv_cesa_ahash_req_cleanup,\n\t.complete = mv_cesa_ahash_complete,\n};\n\nstatic void mv_cesa_ahash_init(struct ahash_request *req,\n\t\t\t      struct mv_cesa_op_ctx *tmpl, bool algo_le)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\n\tmemset(creq, 0, sizeof(*creq));\n\tmv_cesa_update_op_cfg(tmpl,\n\t\t\t      CESA_SA_DESC_CFG_OP_MAC_ONLY |\n\t\t\t      CESA_SA_DESC_CFG_FIRST_FRAG,\n\t\t\t      CESA_SA_DESC_CFG_OP_MSK |\n\t\t\t      CESA_SA_DESC_CFG_FRAG_MSK);\n\tmv_cesa_set_mac_op_total_len(tmpl, 0);\n\tmv_cesa_set_mac_op_frag_len(tmpl, 0);\n\tcreq->op_tmpl = *tmpl;\n\tcreq->len = 0;\n\tcreq->algo_le = algo_le;\n}\n\nstatic inline int mv_cesa_ahash_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct mv_cesa_hash_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tctx->base.ops = &mv_cesa_ahash_req_ops;\n\n\tcrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\n\t\t\t\t sizeof(struct mv_cesa_ahash_req));\n\treturn 0;\n}\n\nstatic bool mv_cesa_ahash_cache_req(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tbool cached = false;\n\n\tif (creq->cache_ptr + req->nbytes < CESA_MAX_HASH_BLOCK_SIZE &&\n\t    !creq->last_req) {\n\t\tcached = true;\n\n\t\tif (!req->nbytes)\n\t\t\treturn cached;\n\n\t\tsg_pcopy_to_buffer(req->src, creq->src_nents,\n\t\t\t\t   creq->cache + creq->cache_ptr,\n\t\t\t\t   req->nbytes, 0);\n\n\t\tcreq->cache_ptr += req->nbytes;\n\t}\n\n\treturn cached;\n}\n\nstatic struct mv_cesa_op_ctx *\nmv_cesa_dma_add_frag(struct mv_cesa_tdma_chain *chain,\n\t\t     struct mv_cesa_op_ctx *tmpl, unsigned int frag_len,\n\t\t     gfp_t flags)\n{\n\tstruct mv_cesa_op_ctx *op;\n\tint ret;\n\n\top = mv_cesa_dma_add_op(chain, tmpl, false, flags);\n\tif (IS_ERR(op))\n\t\treturn op;\n\n\t \n\tmv_cesa_set_mac_op_frag_len(op, frag_len);\n\n\t \n\tret = mv_cesa_dma_add_dummy_launch(chain, flags);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (mv_cesa_mac_op_is_first_frag(tmpl))\n\t\tmv_cesa_update_op_cfg(tmpl,\n\t\t\t\t      CESA_SA_DESC_CFG_MID_FRAG,\n\t\t\t\t      CESA_SA_DESC_CFG_FRAG_MSK);\n\n\treturn op;\n}\n\nstatic int\nmv_cesa_ahash_dma_add_cache(struct mv_cesa_tdma_chain *chain,\n\t\t\t    struct mv_cesa_ahash_req *creq,\n\t\t\t    gfp_t flags)\n{\n\tstruct mv_cesa_ahash_dma_req *ahashdreq = &creq->req.dma;\n\tint ret;\n\n\tif (!creq->cache_ptr)\n\t\treturn 0;\n\n\tret = mv_cesa_ahash_dma_alloc_cache(ahashdreq, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(ahashdreq->cache, creq->cache, creq->cache_ptr);\n\n\treturn mv_cesa_dma_add_data_transfer(chain,\n\t\t\t\t\t     CESA_SA_DATA_SRAM_OFFSET,\n\t\t\t\t\t     ahashdreq->cache_dma,\n\t\t\t\t\t     creq->cache_ptr,\n\t\t\t\t\t     CESA_TDMA_DST_IN_SRAM,\n\t\t\t\t\t     flags);\n}\n\nstatic struct mv_cesa_op_ctx *\nmv_cesa_ahash_dma_last_req(struct mv_cesa_tdma_chain *chain,\n\t\t\t   struct mv_cesa_ahash_dma_iter *dma_iter,\n\t\t\t   struct mv_cesa_ahash_req *creq,\n\t\t\t   unsigned int frag_len, gfp_t flags)\n{\n\tstruct mv_cesa_ahash_dma_req *ahashdreq = &creq->req.dma;\n\tunsigned int len, trailerlen, padoff = 0;\n\tstruct mv_cesa_op_ctx *op;\n\tint ret;\n\n\t \n\tif (creq->len <= CESA_SA_DESC_MAC_SRC_TOTAL_LEN_MAX && frag_len) {\n\t\top = mv_cesa_dma_add_frag(chain, &creq->op_tmpl, frag_len,\n\t\t\t\t\t  flags);\n\t\tif (IS_ERR(op))\n\t\t\treturn op;\n\n\t\tmv_cesa_set_mac_op_total_len(op, creq->len);\n\t\tmv_cesa_update_op_cfg(op, mv_cesa_mac_op_is_first_frag(op) ?\n\t\t\t\t\t\tCESA_SA_DESC_CFG_NOT_FRAG :\n\t\t\t\t\t\tCESA_SA_DESC_CFG_LAST_FRAG,\n\t\t\t\t      CESA_SA_DESC_CFG_FRAG_MSK);\n\n\t\tret = mv_cesa_dma_add_result_op(chain,\n\t\t\t\t\t\tCESA_SA_CFG_SRAM_OFFSET,\n\t\t\t\t\t\tCESA_SA_DATA_SRAM_OFFSET,\n\t\t\t\t\t\tCESA_TDMA_SRC_IN_SRAM, flags);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\treturn op;\n\t}\n\n\t \n\tret = mv_cesa_ahash_dma_alloc_padding(ahashdreq, flags);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\ttrailerlen = mv_cesa_ahash_pad_req(creq, ahashdreq->padding);\n\n\tlen = min(CESA_SA_SRAM_PAYLOAD_SIZE - frag_len, trailerlen);\n\tif (len) {\n\t\tret = mv_cesa_dma_add_data_transfer(chain,\n\t\t\t\t\t\tCESA_SA_DATA_SRAM_OFFSET +\n\t\t\t\t\t\tfrag_len,\n\t\t\t\t\t\tahashdreq->padding_dma,\n\t\t\t\t\t\tlen, CESA_TDMA_DST_IN_SRAM,\n\t\t\t\t\t\tflags);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\n\t\top = mv_cesa_dma_add_frag(chain, &creq->op_tmpl, frag_len + len,\n\t\t\t\t\t  flags);\n\t\tif (IS_ERR(op))\n\t\t\treturn op;\n\n\t\tif (len == trailerlen)\n\t\t\treturn op;\n\n\t\tpadoff += len;\n\t}\n\n\tret = mv_cesa_dma_add_data_transfer(chain,\n\t\t\t\t\t    CESA_SA_DATA_SRAM_OFFSET,\n\t\t\t\t\t    ahashdreq->padding_dma +\n\t\t\t\t\t    padoff,\n\t\t\t\t\t    trailerlen - padoff,\n\t\t\t\t\t    CESA_TDMA_DST_IN_SRAM,\n\t\t\t\t\t    flags);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn mv_cesa_dma_add_frag(chain, &creq->op_tmpl, trailerlen - padoff,\n\t\t\t\t    flags);\n}\n\nstatic int mv_cesa_ahash_dma_req_init(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t      GFP_KERNEL : GFP_ATOMIC;\n\tstruct mv_cesa_req *basereq = &creq->base;\n\tstruct mv_cesa_ahash_dma_iter iter;\n\tstruct mv_cesa_op_ctx *op = NULL;\n\tunsigned int frag_len;\n\tbool set_state = false;\n\tint ret;\n\tu32 type;\n\n\tbasereq->chain.first = NULL;\n\tbasereq->chain.last = NULL;\n\n\tif (!mv_cesa_mac_op_is_first_frag(&creq->op_tmpl))\n\t\tset_state = true;\n\n\tif (creq->src_nents) {\n\t\tret = dma_map_sg(cesa_dev->dev, req->src, creq->src_nents,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tif (!ret) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tmv_cesa_tdma_desc_iter_init(&basereq->chain);\n\tmv_cesa_ahash_req_iter_init(&iter, req);\n\n\t \n\tret = mv_cesa_ahash_dma_add_cache(&basereq->chain, creq, flags);\n\tif (ret)\n\t\tgoto err_free_tdma;\n\n\tif (iter.src.sg) {\n\t\t \n\t\twhile (true) {\n\t\t\tret = mv_cesa_dma_add_op_transfers(&basereq->chain,\n\t\t\t\t\t\t\t   &iter.base,\n\t\t\t\t\t\t\t   &iter.src, flags);\n\t\t\tif (ret)\n\t\t\t\tgoto err_free_tdma;\n\n\t\t\tfrag_len = iter.base.op_len;\n\n\t\t\tif (!mv_cesa_ahash_req_iter_next_op(&iter))\n\t\t\t\tbreak;\n\n\t\t\top = mv_cesa_dma_add_frag(&basereq->chain,\n\t\t\t\t\t\t  &creq->op_tmpl,\n\t\t\t\t\t\t  frag_len, flags);\n\t\t\tif (IS_ERR(op)) {\n\t\t\t\tret = PTR_ERR(op);\n\t\t\t\tgoto err_free_tdma;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tfrag_len = iter.base.op_len;\n\t}\n\n\t \n\tif (creq->last_req)\n\t\top = mv_cesa_ahash_dma_last_req(&basereq->chain, &iter, creq,\n\t\t\t\t\t\tfrag_len, flags);\n\telse if (frag_len)\n\t\top = mv_cesa_dma_add_frag(&basereq->chain, &creq->op_tmpl,\n\t\t\t\t\t  frag_len, flags);\n\n\tif (IS_ERR(op)) {\n\t\tret = PTR_ERR(op);\n\t\tgoto err_free_tdma;\n\t}\n\n\t \n\ttype = basereq->chain.last->flags & CESA_TDMA_TYPE_MSK;\n\n\tif (op && type != CESA_TDMA_RESULT) {\n\t\t \n\t\tret = mv_cesa_dma_add_dummy_end(&basereq->chain, flags);\n\t\tif (ret)\n\t\t\tgoto err_free_tdma;\n\t}\n\n\tif (!creq->last_req)\n\t\tcreq->cache_ptr = req->nbytes + creq->cache_ptr -\n\t\t\t\t  iter.base.len;\n\telse\n\t\tcreq->cache_ptr = 0;\n\n\tbasereq->chain.last->flags |= CESA_TDMA_END_OF_REQ;\n\n\tif (type != CESA_TDMA_RESULT)\n\t\tbasereq->chain.last->flags |= CESA_TDMA_BREAK_CHAIN;\n\n\tif (set_state) {\n\t\t \n\t\tbasereq->chain.first->flags |= CESA_TDMA_SET_STATE;\n\t}\n\n\treturn 0;\n\nerr_free_tdma:\n\tmv_cesa_dma_cleanup(basereq);\n\tdma_unmap_sg(cesa_dev->dev, req->src, creq->src_nents, DMA_TO_DEVICE);\n\nerr:\n\tmv_cesa_ahash_last_cleanup(req);\n\n\treturn ret;\n}\n\nstatic int mv_cesa_ahash_req_init(struct ahash_request *req, bool *cached)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\n\tcreq->src_nents = sg_nents_for_len(req->src, req->nbytes);\n\tif (creq->src_nents < 0) {\n\t\tdev_err(cesa_dev->dev, \"Invalid number of src SG\");\n\t\treturn creq->src_nents;\n\t}\n\n\t*cached = mv_cesa_ahash_cache_req(req);\n\n\tif (*cached)\n\t\treturn 0;\n\n\tif (cesa_dev->caps->has_tdma)\n\t\treturn mv_cesa_ahash_dma_req_init(req);\n\telse\n\t\treturn 0;\n}\n\nstatic int mv_cesa_ahash_queue_req(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tstruct mv_cesa_engine *engine;\n\tbool cached = false;\n\tint ret;\n\n\tret = mv_cesa_ahash_req_init(req, &cached);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cached)\n\t\treturn 0;\n\n\tengine = mv_cesa_select_engine(req->nbytes);\n\tmv_cesa_ahash_prepare(&req->base, engine);\n\n\tret = mv_cesa_queue_req(&req->base, &creq->base);\n\n\tif (mv_cesa_req_needs_cleanup(&req->base, ret))\n\t\tmv_cesa_ahash_cleanup(req);\n\n\treturn ret;\n}\n\nstatic int mv_cesa_ahash_update(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\n\tcreq->len += req->nbytes;\n\n\treturn mv_cesa_ahash_queue_req(req);\n}\n\nstatic int mv_cesa_ahash_final(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tstruct mv_cesa_op_ctx *tmpl = &creq->op_tmpl;\n\n\tmv_cesa_set_mac_op_total_len(tmpl, creq->len);\n\tcreq->last_req = true;\n\treq->nbytes = 0;\n\n\treturn mv_cesa_ahash_queue_req(req);\n}\n\nstatic int mv_cesa_ahash_finup(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tstruct mv_cesa_op_ctx *tmpl = &creq->op_tmpl;\n\n\tcreq->len += req->nbytes;\n\tmv_cesa_set_mac_op_total_len(tmpl, creq->len);\n\tcreq->last_req = true;\n\n\treturn mv_cesa_ahash_queue_req(req);\n}\n\nstatic int mv_cesa_ahash_export(struct ahash_request *req, void *hash,\n\t\t\t\tu64 *len, void *cache)\n{\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tunsigned int digsize = crypto_ahash_digestsize(ahash);\n\tunsigned int blocksize;\n\n\tblocksize = crypto_ahash_blocksize(ahash);\n\n\t*len = creq->len;\n\tmemcpy(hash, creq->state, digsize);\n\tmemset(cache, 0, blocksize);\n\tmemcpy(cache, creq->cache, creq->cache_ptr);\n\n\treturn 0;\n}\n\nstatic int mv_cesa_ahash_import(struct ahash_request *req, const void *hash,\n\t\t\t\tu64 len, const void *cache)\n{\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tunsigned int digsize = crypto_ahash_digestsize(ahash);\n\tunsigned int blocksize;\n\tunsigned int cache_ptr;\n\tint ret;\n\n\tret = crypto_ahash_init(req);\n\tif (ret)\n\t\treturn ret;\n\n\tblocksize = crypto_ahash_blocksize(ahash);\n\tif (len >= blocksize)\n\t\tmv_cesa_update_op_cfg(&creq->op_tmpl,\n\t\t\t\t      CESA_SA_DESC_CFG_MID_FRAG,\n\t\t\t\t      CESA_SA_DESC_CFG_FRAG_MSK);\n\n\tcreq->len = len;\n\tmemcpy(creq->state, hash, digsize);\n\tcreq->cache_ptr = 0;\n\n\tcache_ptr = do_div(len, blocksize);\n\tif (!cache_ptr)\n\t\treturn 0;\n\n\tmemcpy(creq->cache, cache, cache_ptr);\n\tcreq->cache_ptr = cache_ptr;\n\n\treturn 0;\n}\n\nstatic int mv_cesa_md5_init(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tstruct mv_cesa_op_ctx tmpl = { };\n\n\tmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_MACM_MD5);\n\n\tmv_cesa_ahash_init(req, &tmpl, true);\n\n\tcreq->state[0] = MD5_H0;\n\tcreq->state[1] = MD5_H1;\n\tcreq->state[2] = MD5_H2;\n\tcreq->state[3] = MD5_H3;\n\n\treturn 0;\n}\n\nstatic int mv_cesa_md5_export(struct ahash_request *req, void *out)\n{\n\tstruct md5_state *out_state = out;\n\n\treturn mv_cesa_ahash_export(req, out_state->hash,\n\t\t\t\t    &out_state->byte_count, out_state->block);\n}\n\nstatic int mv_cesa_md5_import(struct ahash_request *req, const void *in)\n{\n\tconst struct md5_state *in_state = in;\n\n\treturn mv_cesa_ahash_import(req, in_state->hash, in_state->byte_count,\n\t\t\t\t    in_state->block);\n}\n\nstatic int mv_cesa_md5_digest(struct ahash_request *req)\n{\n\tint ret;\n\n\tret = mv_cesa_md5_init(req);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mv_cesa_ahash_finup(req);\n}\n\nstruct ahash_alg mv_md5_alg = {\n\t.init = mv_cesa_md5_init,\n\t.update = mv_cesa_ahash_update,\n\t.final = mv_cesa_ahash_final,\n\t.finup = mv_cesa_ahash_finup,\n\t.digest = mv_cesa_md5_digest,\n\t.export = mv_cesa_md5_export,\n\t.import = mv_cesa_md5_import,\n\t.halg = {\n\t\t.digestsize = MD5_DIGEST_SIZE,\n\t\t.statesize = sizeof(struct md5_state),\n\t\t.base = {\n\t\t\t.cra_name = \"md5\",\n\t\t\t.cra_driver_name = \"mv-md5\",\n\t\t\t.cra_priority = 300,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = MD5_HMAC_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct mv_cesa_hash_ctx),\n\t\t\t.cra_init = mv_cesa_ahash_cra_init,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t}\n\t}\n};\n\nstatic int mv_cesa_sha1_init(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tstruct mv_cesa_op_ctx tmpl = { };\n\n\tmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_MACM_SHA1);\n\n\tmv_cesa_ahash_init(req, &tmpl, false);\n\n\tcreq->state[0] = SHA1_H0;\n\tcreq->state[1] = SHA1_H1;\n\tcreq->state[2] = SHA1_H2;\n\tcreq->state[3] = SHA1_H3;\n\tcreq->state[4] = SHA1_H4;\n\n\treturn 0;\n}\n\nstatic int mv_cesa_sha1_export(struct ahash_request *req, void *out)\n{\n\tstruct sha1_state *out_state = out;\n\n\treturn mv_cesa_ahash_export(req, out_state->state, &out_state->count,\n\t\t\t\t    out_state->buffer);\n}\n\nstatic int mv_cesa_sha1_import(struct ahash_request *req, const void *in)\n{\n\tconst struct sha1_state *in_state = in;\n\n\treturn mv_cesa_ahash_import(req, in_state->state, in_state->count,\n\t\t\t\t    in_state->buffer);\n}\n\nstatic int mv_cesa_sha1_digest(struct ahash_request *req)\n{\n\tint ret;\n\n\tret = mv_cesa_sha1_init(req);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mv_cesa_ahash_finup(req);\n}\n\nstruct ahash_alg mv_sha1_alg = {\n\t.init = mv_cesa_sha1_init,\n\t.update = mv_cesa_ahash_update,\n\t.final = mv_cesa_ahash_final,\n\t.finup = mv_cesa_ahash_finup,\n\t.digest = mv_cesa_sha1_digest,\n\t.export = mv_cesa_sha1_export,\n\t.import = mv_cesa_sha1_import,\n\t.halg = {\n\t\t.digestsize = SHA1_DIGEST_SIZE,\n\t\t.statesize = sizeof(struct sha1_state),\n\t\t.base = {\n\t\t\t.cra_name = \"sha1\",\n\t\t\t.cra_driver_name = \"mv-sha1\",\n\t\t\t.cra_priority = 300,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = SHA1_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct mv_cesa_hash_ctx),\n\t\t\t.cra_init = mv_cesa_ahash_cra_init,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t}\n\t}\n};\n\nstatic int mv_cesa_sha256_init(struct ahash_request *req)\n{\n\tstruct mv_cesa_ahash_req *creq = ahash_request_ctx(req);\n\tstruct mv_cesa_op_ctx tmpl = { };\n\n\tmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_MACM_SHA256);\n\n\tmv_cesa_ahash_init(req, &tmpl, false);\n\n\tcreq->state[0] = SHA256_H0;\n\tcreq->state[1] = SHA256_H1;\n\tcreq->state[2] = SHA256_H2;\n\tcreq->state[3] = SHA256_H3;\n\tcreq->state[4] = SHA256_H4;\n\tcreq->state[5] = SHA256_H5;\n\tcreq->state[6] = SHA256_H6;\n\tcreq->state[7] = SHA256_H7;\n\n\treturn 0;\n}\n\nstatic int mv_cesa_sha256_digest(struct ahash_request *req)\n{\n\tint ret;\n\n\tret = mv_cesa_sha256_init(req);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mv_cesa_ahash_finup(req);\n}\n\nstatic int mv_cesa_sha256_export(struct ahash_request *req, void *out)\n{\n\tstruct sha256_state *out_state = out;\n\n\treturn mv_cesa_ahash_export(req, out_state->state, &out_state->count,\n\t\t\t\t    out_state->buf);\n}\n\nstatic int mv_cesa_sha256_import(struct ahash_request *req, const void *in)\n{\n\tconst struct sha256_state *in_state = in;\n\n\treturn mv_cesa_ahash_import(req, in_state->state, in_state->count,\n\t\t\t\t    in_state->buf);\n}\n\nstruct ahash_alg mv_sha256_alg = {\n\t.init = mv_cesa_sha256_init,\n\t.update = mv_cesa_ahash_update,\n\t.final = mv_cesa_ahash_final,\n\t.finup = mv_cesa_ahash_finup,\n\t.digest = mv_cesa_sha256_digest,\n\t.export = mv_cesa_sha256_export,\n\t.import = mv_cesa_sha256_import,\n\t.halg = {\n\t\t.digestsize = SHA256_DIGEST_SIZE,\n\t\t.statesize = sizeof(struct sha256_state),\n\t\t.base = {\n\t\t\t.cra_name = \"sha256\",\n\t\t\t.cra_driver_name = \"mv-sha256\",\n\t\t\t.cra_priority = 300,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = SHA256_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct mv_cesa_hash_ctx),\n\t\t\t.cra_init = mv_cesa_ahash_cra_init,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t}\n\t}\n};\n\nstatic int mv_cesa_ahmac_iv_state_init(struct ahash_request *req, u8 *pad,\n\t\t\t\t       void *state, unsigned int blocksize)\n{\n\tDECLARE_CRYPTO_WAIT(result);\n\tstruct scatterlist sg;\n\tint ret;\n\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t   crypto_req_done, &result);\n\tsg_init_one(&sg, pad, blocksize);\n\tahash_request_set_crypt(req, &sg, pad, blocksize);\n\n\tret = crypto_ahash_init(req);\n\tif (ret)\n\t\treturn ret;\n\n\tret = crypto_ahash_update(req);\n\tret = crypto_wait_req(ret, &result);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = crypto_ahash_export(req, state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mv_cesa_ahmac_pad_init(struct ahash_request *req,\n\t\t\t\t  const u8 *key, unsigned int keylen,\n\t\t\t\t  u8 *ipad, u8 *opad,\n\t\t\t\t  unsigned int blocksize)\n{\n\tDECLARE_CRYPTO_WAIT(result);\n\tstruct scatterlist sg;\n\tint ret;\n\tint i;\n\n\tif (keylen <= blocksize) {\n\t\tmemcpy(ipad, key, keylen);\n\t} else {\n\t\tu8 *keydup = kmemdup(key, keylen, GFP_KERNEL);\n\n\t\tif (!keydup)\n\t\t\treturn -ENOMEM;\n\n\t\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t\t   crypto_req_done, &result);\n\t\tsg_init_one(&sg, keydup, keylen);\n\t\tahash_request_set_crypt(req, &sg, ipad, keylen);\n\n\t\tret = crypto_ahash_digest(req);\n\t\tret = crypto_wait_req(ret, &result);\n\n\t\t \n\t\tkfree_sensitive(keydup);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tkeylen = crypto_ahash_digestsize(crypto_ahash_reqtfm(req));\n\t}\n\n\tmemset(ipad + keylen, 0, blocksize - keylen);\n\tmemcpy(opad, ipad, blocksize);\n\n\tfor (i = 0; i < blocksize; i++) {\n\t\tipad[i] ^= HMAC_IPAD_VALUE;\n\t\topad[i] ^= HMAC_OPAD_VALUE;\n\t}\n\n\treturn 0;\n}\n\nstatic int mv_cesa_ahmac_setkey(const char *hash_alg_name,\n\t\t\t\tconst u8 *key, unsigned int keylen,\n\t\t\t\tvoid *istate, void *ostate)\n{\n\tstruct ahash_request *req;\n\tstruct crypto_ahash *tfm;\n\tunsigned int blocksize;\n\tu8 *ipad = NULL;\n\tu8 *opad;\n\tint ret;\n\n\ttfm = crypto_alloc_ahash(hash_alg_name, 0, 0);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\treq = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto free_ahash;\n\t}\n\n\tcrypto_ahash_clear_flags(tfm, ~0);\n\n\tblocksize = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));\n\n\tipad = kcalloc(2, blocksize, GFP_KERNEL);\n\tif (!ipad) {\n\t\tret = -ENOMEM;\n\t\tgoto free_req;\n\t}\n\n\topad = ipad + blocksize;\n\n\tret = mv_cesa_ahmac_pad_init(req, key, keylen, ipad, opad, blocksize);\n\tif (ret)\n\t\tgoto free_ipad;\n\n\tret = mv_cesa_ahmac_iv_state_init(req, ipad, istate, blocksize);\n\tif (ret)\n\t\tgoto free_ipad;\n\n\tret = mv_cesa_ahmac_iv_state_init(req, opad, ostate, blocksize);\n\nfree_ipad:\n\tkfree(ipad);\nfree_req:\n\tahash_request_free(req);\nfree_ahash:\n\tcrypto_free_ahash(tfm);\n\n\treturn ret;\n}\n\nstatic int mv_cesa_ahmac_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tctx->base.ops = &mv_cesa_ahash_req_ops;\n\n\tcrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\n\t\t\t\t sizeof(struct mv_cesa_ahash_req));\n\treturn 0;\n}\n\nstatic int mv_cesa_ahmac_md5_init(struct ahash_request *req)\n{\n\tstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\n\tstruct mv_cesa_op_ctx tmpl = { };\n\n\tmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_MACM_HMAC_MD5);\n\tmemcpy(tmpl.ctx.hash.iv, ctx->iv, sizeof(ctx->iv));\n\n\tmv_cesa_ahash_init(req, &tmpl, true);\n\n\treturn 0;\n}\n\nstatic int mv_cesa_ahmac_md5_setkey(struct crypto_ahash *tfm, const u8 *key,\n\t\t\t\t    unsigned int keylen)\n{\n\tstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(crypto_ahash_tfm(tfm));\n\tstruct md5_state istate, ostate;\n\tint ret, i;\n\n\tret = mv_cesa_ahmac_setkey(\"mv-md5\", key, keylen, &istate, &ostate);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(istate.hash); i++)\n\t\tctx->iv[i] = cpu_to_be32(istate.hash[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(ostate.hash); i++)\n\t\tctx->iv[i + 8] = cpu_to_be32(ostate.hash[i]);\n\n\treturn 0;\n}\n\nstatic int mv_cesa_ahmac_md5_digest(struct ahash_request *req)\n{\n\tint ret;\n\n\tret = mv_cesa_ahmac_md5_init(req);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mv_cesa_ahash_finup(req);\n}\n\nstruct ahash_alg mv_ahmac_md5_alg = {\n\t.init = mv_cesa_ahmac_md5_init,\n\t.update = mv_cesa_ahash_update,\n\t.final = mv_cesa_ahash_final,\n\t.finup = mv_cesa_ahash_finup,\n\t.digest = mv_cesa_ahmac_md5_digest,\n\t.setkey = mv_cesa_ahmac_md5_setkey,\n\t.export = mv_cesa_md5_export,\n\t.import = mv_cesa_md5_import,\n\t.halg = {\n\t\t.digestsize = MD5_DIGEST_SIZE,\n\t\t.statesize = sizeof(struct md5_state),\n\t\t.base = {\n\t\t\t.cra_name = \"hmac(md5)\",\n\t\t\t.cra_driver_name = \"mv-hmac-md5\",\n\t\t\t.cra_priority = 300,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = MD5_HMAC_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct mv_cesa_hmac_ctx),\n\t\t\t.cra_init = mv_cesa_ahmac_cra_init,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t}\n\t}\n};\n\nstatic int mv_cesa_ahmac_sha1_init(struct ahash_request *req)\n{\n\tstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\n\tstruct mv_cesa_op_ctx tmpl = { };\n\n\tmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_MACM_HMAC_SHA1);\n\tmemcpy(tmpl.ctx.hash.iv, ctx->iv, sizeof(ctx->iv));\n\n\tmv_cesa_ahash_init(req, &tmpl, false);\n\n\treturn 0;\n}\n\nstatic int mv_cesa_ahmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,\n\t\t\t\t     unsigned int keylen)\n{\n\tstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(crypto_ahash_tfm(tfm));\n\tstruct sha1_state istate, ostate;\n\tint ret, i;\n\n\tret = mv_cesa_ahmac_setkey(\"mv-sha1\", key, keylen, &istate, &ostate);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(istate.state); i++)\n\t\tctx->iv[i] = cpu_to_be32(istate.state[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(ostate.state); i++)\n\t\tctx->iv[i + 8] = cpu_to_be32(ostate.state[i]);\n\n\treturn 0;\n}\n\nstatic int mv_cesa_ahmac_sha1_digest(struct ahash_request *req)\n{\n\tint ret;\n\n\tret = mv_cesa_ahmac_sha1_init(req);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mv_cesa_ahash_finup(req);\n}\n\nstruct ahash_alg mv_ahmac_sha1_alg = {\n\t.init = mv_cesa_ahmac_sha1_init,\n\t.update = mv_cesa_ahash_update,\n\t.final = mv_cesa_ahash_final,\n\t.finup = mv_cesa_ahash_finup,\n\t.digest = mv_cesa_ahmac_sha1_digest,\n\t.setkey = mv_cesa_ahmac_sha1_setkey,\n\t.export = mv_cesa_sha1_export,\n\t.import = mv_cesa_sha1_import,\n\t.halg = {\n\t\t.digestsize = SHA1_DIGEST_SIZE,\n\t\t.statesize = sizeof(struct sha1_state),\n\t\t.base = {\n\t\t\t.cra_name = \"hmac(sha1)\",\n\t\t\t.cra_driver_name = \"mv-hmac-sha1\",\n\t\t\t.cra_priority = 300,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = SHA1_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct mv_cesa_hmac_ctx),\n\t\t\t.cra_init = mv_cesa_ahmac_cra_init,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t}\n\t}\n};\n\nstatic int mv_cesa_ahmac_sha256_setkey(struct crypto_ahash *tfm, const u8 *key,\n\t\t\t\t       unsigned int keylen)\n{\n\tstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(crypto_ahash_tfm(tfm));\n\tstruct sha256_state istate, ostate;\n\tint ret, i;\n\n\tret = mv_cesa_ahmac_setkey(\"mv-sha256\", key, keylen, &istate, &ostate);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(istate.state); i++)\n\t\tctx->iv[i] = cpu_to_be32(istate.state[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(ostate.state); i++)\n\t\tctx->iv[i + 8] = cpu_to_be32(ostate.state[i]);\n\n\treturn 0;\n}\n\nstatic int mv_cesa_ahmac_sha256_init(struct ahash_request *req)\n{\n\tstruct mv_cesa_hmac_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\n\tstruct mv_cesa_op_ctx tmpl = { };\n\n\tmv_cesa_set_op_cfg(&tmpl, CESA_SA_DESC_CFG_MACM_HMAC_SHA256);\n\tmemcpy(tmpl.ctx.hash.iv, ctx->iv, sizeof(ctx->iv));\n\n\tmv_cesa_ahash_init(req, &tmpl, false);\n\n\treturn 0;\n}\n\nstatic int mv_cesa_ahmac_sha256_digest(struct ahash_request *req)\n{\n\tint ret;\n\n\tret = mv_cesa_ahmac_sha256_init(req);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mv_cesa_ahash_finup(req);\n}\n\nstruct ahash_alg mv_ahmac_sha256_alg = {\n\t.init = mv_cesa_ahmac_sha256_init,\n\t.update = mv_cesa_ahash_update,\n\t.final = mv_cesa_ahash_final,\n\t.finup = mv_cesa_ahash_finup,\n\t.digest = mv_cesa_ahmac_sha256_digest,\n\t.setkey = mv_cesa_ahmac_sha256_setkey,\n\t.export = mv_cesa_sha256_export,\n\t.import = mv_cesa_sha256_import,\n\t.halg = {\n\t\t.digestsize = SHA256_DIGEST_SIZE,\n\t\t.statesize = sizeof(struct sha256_state),\n\t\t.base = {\n\t\t\t.cra_name = \"hmac(sha256)\",\n\t\t\t.cra_driver_name = \"mv-hmac-sha256\",\n\t\t\t.cra_priority = 300,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = SHA256_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct mv_cesa_hmac_ctx),\n\t\t\t.cra_init = mv_cesa_ahmac_cra_init,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t}\n\t}\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}