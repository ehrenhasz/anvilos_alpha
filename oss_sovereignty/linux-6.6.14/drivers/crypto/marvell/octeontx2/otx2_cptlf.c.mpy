{
  "module_name": "otx2_cptlf.c",
  "hash_id": "ac3a9c344a689404dddeedf1bdca5f6cefad87490d01a43922a2f385a973a21d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/octeontx2/otx2_cptlf.c",
  "human_readable_source": "\n \n\n#include \"otx2_cpt_common.h\"\n#include \"otx2_cptlf.h\"\n#include \"rvu_reg.h\"\n\n#define CPT_TIMER_HOLD 0x03F\n#define CPT_COUNT_HOLD 32\n\nstatic void cptlf_do_set_done_time_wait(struct otx2_cptlf_info *lf,\n\t\t\t\t\tint time_wait)\n{\n\tunion otx2_cptx_lf_done_wait done_wait;\n\n\tdone_wait.u = otx2_cpt_read64(lf->lfs->reg_base, lf->lfs->blkaddr,\n\t\t\t\t      lf->slot, OTX2_CPT_LF_DONE_WAIT);\n\tdone_wait.s.time_wait = time_wait;\n\totx2_cpt_write64(lf->lfs->reg_base, lf->lfs->blkaddr, lf->slot,\n\t\t\t OTX2_CPT_LF_DONE_WAIT, done_wait.u);\n}\n\nstatic void cptlf_do_set_done_num_wait(struct otx2_cptlf_info *lf, int num_wait)\n{\n\tunion otx2_cptx_lf_done_wait done_wait;\n\n\tdone_wait.u = otx2_cpt_read64(lf->lfs->reg_base, lf->lfs->blkaddr,\n\t\t\t\t      lf->slot, OTX2_CPT_LF_DONE_WAIT);\n\tdone_wait.s.num_wait = num_wait;\n\totx2_cpt_write64(lf->lfs->reg_base, lf->lfs->blkaddr, lf->slot,\n\t\t\t OTX2_CPT_LF_DONE_WAIT, done_wait.u);\n}\n\nstatic void cptlf_set_done_time_wait(struct otx2_cptlfs_info *lfs,\n\t\t\t\t     int time_wait)\n{\n\tint slot;\n\n\tfor (slot = 0; slot < lfs->lfs_num; slot++)\n\t\tcptlf_do_set_done_time_wait(&lfs->lf[slot], time_wait);\n}\n\nstatic void cptlf_set_done_num_wait(struct otx2_cptlfs_info *lfs, int num_wait)\n{\n\tint slot;\n\n\tfor (slot = 0; slot < lfs->lfs_num; slot++)\n\t\tcptlf_do_set_done_num_wait(&lfs->lf[slot], num_wait);\n}\n\nstatic int cptlf_set_pri(struct otx2_cptlf_info *lf, int pri)\n{\n\tstruct otx2_cptlfs_info *lfs = lf->lfs;\n\tunion otx2_cptx_af_lf_ctrl lf_ctrl;\n\tint ret;\n\n\tret = otx2_cpt_read_af_reg(lfs->mbox, lfs->pdev,\n\t\t\t\t   CPT_AF_LFX_CTL(lf->slot),\n\t\t\t\t   &lf_ctrl.u, lfs->blkaddr);\n\tif (ret)\n\t\treturn ret;\n\n\tlf_ctrl.s.pri = pri ? 1 : 0;\n\n\tret = otx2_cpt_write_af_reg(lfs->mbox, lfs->pdev,\n\t\t\t\t    CPT_AF_LFX_CTL(lf->slot),\n\t\t\t\t    lf_ctrl.u, lfs->blkaddr);\n\treturn ret;\n}\n\nstatic int cptlf_set_eng_grps_mask(struct otx2_cptlf_info *lf,\n\t\t\t\t   int eng_grps_mask)\n{\n\tstruct otx2_cptlfs_info *lfs = lf->lfs;\n\tunion otx2_cptx_af_lf_ctrl lf_ctrl;\n\tint ret;\n\n\tret = otx2_cpt_read_af_reg(lfs->mbox, lfs->pdev,\n\t\t\t\t   CPT_AF_LFX_CTL(lf->slot),\n\t\t\t\t   &lf_ctrl.u, lfs->blkaddr);\n\tif (ret)\n\t\treturn ret;\n\n\tlf_ctrl.s.grp = eng_grps_mask;\n\n\tret = otx2_cpt_write_af_reg(lfs->mbox, lfs->pdev,\n\t\t\t\t    CPT_AF_LFX_CTL(lf->slot),\n\t\t\t\t    lf_ctrl.u, lfs->blkaddr);\n\treturn ret;\n}\n\nstatic int cptlf_set_grp_and_pri(struct otx2_cptlfs_info *lfs,\n\t\t\t\t int eng_grp_mask, int pri)\n{\n\tint slot, ret = 0;\n\n\tfor (slot = 0; slot < lfs->lfs_num; slot++) {\n\t\tret = cptlf_set_pri(&lfs->lf[slot], pri);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = cptlf_set_eng_grps_mask(&lfs->lf[slot], eng_grp_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic void cptlf_hw_init(struct otx2_cptlfs_info *lfs)\n{\n\t \n\totx2_cptlf_disable_iqueues(lfs);\n\n\t \n\totx2_cptlf_set_iqueues_base_addr(lfs);\n\n\t \n\totx2_cptlf_set_iqueues_size(lfs);\n\n\t \n\tcptlf_set_done_time_wait(lfs, CPT_TIMER_HOLD);\n\n\t \n\tcptlf_set_done_num_wait(lfs, CPT_COUNT_HOLD);\n\n\t \n\totx2_cptlf_enable_iqueues(lfs);\n}\n\nstatic void cptlf_hw_cleanup(struct otx2_cptlfs_info *lfs)\n{\n\t \n\totx2_cptlf_disable_iqueues(lfs);\n}\n\nstatic void cptlf_set_misc_intrs(struct otx2_cptlfs_info *lfs, u8 enable)\n{\n\tunion otx2_cptx_lf_misc_int_ena_w1s irq_misc = { .u = 0x0 };\n\tu64 reg = enable ? OTX2_CPT_LF_MISC_INT_ENA_W1S :\n\t\t\t   OTX2_CPT_LF_MISC_INT_ENA_W1C;\n\tint slot;\n\n\tirq_misc.s.fault = 0x1;\n\tirq_misc.s.hwerr = 0x1;\n\tirq_misc.s.irde = 0x1;\n\tirq_misc.s.nqerr = 0x1;\n\tirq_misc.s.nwrp = 0x1;\n\n\tfor (slot = 0; slot < lfs->lfs_num; slot++)\n\t\totx2_cpt_write64(lfs->reg_base, lfs->blkaddr, slot, reg,\n\t\t\t\t irq_misc.u);\n}\n\nstatic void cptlf_enable_intrs(struct otx2_cptlfs_info *lfs)\n{\n\tint slot;\n\n\t \n\tfor (slot = 0; slot < lfs->lfs_num; slot++)\n\t\totx2_cpt_write64(lfs->reg_base, lfs->blkaddr, slot,\n\t\t\t\t OTX2_CPT_LF_DONE_INT_ENA_W1S, 0x1);\n\t \n\tcptlf_set_misc_intrs(lfs, true);\n}\n\nstatic void cptlf_disable_intrs(struct otx2_cptlfs_info *lfs)\n{\n\tint slot;\n\n\tfor (slot = 0; slot < lfs->lfs_num; slot++)\n\t\totx2_cpt_write64(lfs->reg_base, lfs->blkaddr, slot,\n\t\t\t\t OTX2_CPT_LF_DONE_INT_ENA_W1C, 0x1);\n\tcptlf_set_misc_intrs(lfs, false);\n}\n\nstatic inline int cptlf_read_done_cnt(struct otx2_cptlf_info *lf)\n{\n\tunion otx2_cptx_lf_done irq_cnt;\n\n\tirq_cnt.u = otx2_cpt_read64(lf->lfs->reg_base, lf->lfs->blkaddr, lf->slot,\n\t\t\t\t    OTX2_CPT_LF_DONE);\n\treturn irq_cnt.s.done;\n}\n\nstatic irqreturn_t cptlf_misc_intr_handler(int __always_unused irq, void *arg)\n{\n\tunion otx2_cptx_lf_misc_int irq_misc, irq_misc_ack;\n\tstruct otx2_cptlf_info *lf = arg;\n\tstruct device *dev;\n\n\tdev = &lf->lfs->pdev->dev;\n\tirq_misc.u = otx2_cpt_read64(lf->lfs->reg_base, lf->lfs->blkaddr,\n\t\t\t\t     lf->slot, OTX2_CPT_LF_MISC_INT);\n\tirq_misc_ack.u = 0x0;\n\n\tif (irq_misc.s.fault) {\n\t\tdev_err(dev, \"Memory error detected while executing CPT_INST_S, LF %d.\\n\",\n\t\t\tlf->slot);\n\t\tirq_misc_ack.s.fault = 0x1;\n\n\t} else if (irq_misc.s.hwerr) {\n\t\tdev_err(dev, \"HW error from an engine executing CPT_INST_S, LF %d.\",\n\t\t\tlf->slot);\n\t\tirq_misc_ack.s.hwerr = 0x1;\n\n\t} else if (irq_misc.s.nwrp) {\n\t\tdev_err(dev, \"SMMU fault while writing CPT_RES_S to CPT_INST_S[RES_ADDR], LF %d.\\n\",\n\t\t\tlf->slot);\n\t\tirq_misc_ack.s.nwrp = 0x1;\n\n\t} else if (irq_misc.s.irde) {\n\t\tdev_err(dev, \"Memory error when accessing instruction memory queue CPT_LF_Q_BASE[ADDR].\\n\");\n\t\tirq_misc_ack.s.irde = 0x1;\n\n\t} else if (irq_misc.s.nqerr) {\n\t\tdev_err(dev, \"Error enqueuing an instruction received at CPT_LF_NQ.\\n\");\n\t\tirq_misc_ack.s.nqerr = 0x1;\n\n\t} else {\n\t\tdev_err(dev, \"Unhandled interrupt in CPT LF %d\\n\", lf->slot);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\totx2_cpt_write64(lf->lfs->reg_base, lf->lfs->blkaddr, lf->slot,\n\t\t\t OTX2_CPT_LF_MISC_INT, irq_misc_ack.u);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cptlf_done_intr_handler(int irq, void *arg)\n{\n\tunion otx2_cptx_lf_done_wait done_wait;\n\tstruct otx2_cptlf_info *lf = arg;\n\tint irq_cnt;\n\n\t \n\tirq_cnt = cptlf_read_done_cnt(lf);\n\tif (irq_cnt) {\n\t\tdone_wait.u = otx2_cpt_read64(lf->lfs->reg_base, lf->lfs->blkaddr,\n\t\t\t\t\t      lf->slot, OTX2_CPT_LF_DONE_WAIT);\n\t\t \n\t\totx2_cpt_write64(lf->lfs->reg_base, lf->lfs->blkaddr, lf->slot,\n\t\t\t\t OTX2_CPT_LF_DONE_ACK, irq_cnt);\n\n\t\totx2_cpt_write64(lf->lfs->reg_base, lf->lfs->blkaddr, lf->slot,\n\t\t\t\t OTX2_CPT_LF_DONE_WAIT, done_wait.u);\n\t\tif (unlikely(!lf->wqe)) {\n\t\t\tdev_err(&lf->lfs->pdev->dev, \"No work for LF %d\\n\",\n\t\t\t\tlf->slot);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\n\t\t \n\t\ttasklet_hi_schedule(&lf->wqe->work);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nvoid otx2_cptlf_unregister_interrupts(struct otx2_cptlfs_info *lfs)\n{\n\tint i, offs, vector;\n\n\tfor (i = 0; i < lfs->lfs_num; i++) {\n\t\tfor (offs = 0; offs < OTX2_CPT_LF_MSIX_VECTORS; offs++) {\n\t\t\tif (!lfs->lf[i].is_irq_reg[offs])\n\t\t\t\tcontinue;\n\n\t\t\tvector = pci_irq_vector(lfs->pdev,\n\t\t\t\t\t\tlfs->lf[i].msix_offset + offs);\n\t\t\tfree_irq(vector, &lfs->lf[i]);\n\t\t\tlfs->lf[i].is_irq_reg[offs] = false;\n\t\t}\n\t}\n\tcptlf_disable_intrs(lfs);\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cptlf_unregister_interrupts,\n\t\t     CRYPTO_DEV_OCTEONTX2_CPT);\n\nstatic int cptlf_do_register_interrrupts(struct otx2_cptlfs_info *lfs,\n\t\t\t\t\t int lf_num, int irq_offset,\n\t\t\t\t\t irq_handler_t handler)\n{\n\tint ret, vector;\n\n\tvector = pci_irq_vector(lfs->pdev, lfs->lf[lf_num].msix_offset +\n\t\t\t\tirq_offset);\n\tret = request_irq(vector, handler, 0,\n\t\t\t  lfs->lf[lf_num].irq_name[irq_offset],\n\t\t\t  &lfs->lf[lf_num]);\n\tif (ret)\n\t\treturn ret;\n\n\tlfs->lf[lf_num].is_irq_reg[irq_offset] = true;\n\n\treturn ret;\n}\n\nint otx2_cptlf_register_interrupts(struct otx2_cptlfs_info *lfs)\n{\n\tint irq_offs, ret, i;\n\n\tfor (i = 0; i < lfs->lfs_num; i++) {\n\t\tirq_offs = OTX2_CPT_LF_INT_VEC_E_MISC;\n\t\tsnprintf(lfs->lf[i].irq_name[irq_offs], 32, \"CPTLF Misc%d\", i);\n\t\tret = cptlf_do_register_interrrupts(lfs, i, irq_offs,\n\t\t\t\t\t\t    cptlf_misc_intr_handler);\n\t\tif (ret)\n\t\t\tgoto free_irq;\n\n\t\tirq_offs = OTX2_CPT_LF_INT_VEC_E_DONE;\n\t\tsnprintf(lfs->lf[i].irq_name[irq_offs], 32, \"OTX2_CPTLF Done%d\",\n\t\t\t i);\n\t\tret = cptlf_do_register_interrrupts(lfs, i, irq_offs,\n\t\t\t\t\t\t    cptlf_done_intr_handler);\n\t\tif (ret)\n\t\t\tgoto free_irq;\n\t}\n\tcptlf_enable_intrs(lfs);\n\treturn 0;\n\nfree_irq:\n\totx2_cptlf_unregister_interrupts(lfs);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cptlf_register_interrupts, CRYPTO_DEV_OCTEONTX2_CPT);\n\nvoid otx2_cptlf_free_irqs_affinity(struct otx2_cptlfs_info *lfs)\n{\n\tint slot, offs;\n\n\tfor (slot = 0; slot < lfs->lfs_num; slot++) {\n\t\tfor (offs = 0; offs < OTX2_CPT_LF_MSIX_VECTORS; offs++)\n\t\t\tirq_set_affinity_hint(pci_irq_vector(lfs->pdev,\n\t\t\t\t\t      lfs->lf[slot].msix_offset +\n\t\t\t\t\t      offs), NULL);\n\t\tfree_cpumask_var(lfs->lf[slot].affinity_mask);\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cptlf_free_irqs_affinity, CRYPTO_DEV_OCTEONTX2_CPT);\n\nint otx2_cptlf_set_irqs_affinity(struct otx2_cptlfs_info *lfs)\n{\n\tstruct otx2_cptlf_info *lf = lfs->lf;\n\tint slot, offs, ret;\n\n\tfor (slot = 0; slot < lfs->lfs_num; slot++) {\n\t\tif (!zalloc_cpumask_var(&lf[slot].affinity_mask, GFP_KERNEL)) {\n\t\t\tdev_err(&lfs->pdev->dev,\n\t\t\t\t\"cpumask allocation failed for LF %d\", slot);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_affinity_mask;\n\t\t}\n\n\t\tcpumask_set_cpu(cpumask_local_spread(slot,\n\t\t\t\tdev_to_node(&lfs->pdev->dev)),\n\t\t\t\tlf[slot].affinity_mask);\n\n\t\tfor (offs = 0; offs < OTX2_CPT_LF_MSIX_VECTORS; offs++) {\n\t\t\tret = irq_set_affinity_hint(pci_irq_vector(lfs->pdev,\n\t\t\t\t\t\tlf[slot].msix_offset + offs),\n\t\t\t\t\t\tlf[slot].affinity_mask);\n\t\t\tif (ret)\n\t\t\t\tgoto free_affinity_mask;\n\t\t}\n\t}\n\treturn 0;\n\nfree_affinity_mask:\n\totx2_cptlf_free_irqs_affinity(lfs);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cptlf_set_irqs_affinity, CRYPTO_DEV_OCTEONTX2_CPT);\n\nint otx2_cptlf_init(struct otx2_cptlfs_info *lfs, u8 eng_grp_mask, int pri,\n\t\t    int lfs_num)\n{\n\tint slot, ret;\n\n\tif (!lfs->pdev || !lfs->reg_base)\n\t\treturn -EINVAL;\n\n\tlfs->lfs_num = lfs_num;\n\tfor (slot = 0; slot < lfs->lfs_num; slot++) {\n\t\tlfs->lf[slot].lfs = lfs;\n\t\tlfs->lf[slot].slot = slot;\n\t\tif (lfs->lmt_base)\n\t\t\tlfs->lf[slot].lmtline = lfs->lmt_base +\n\t\t\t\t\t\t(slot * LMTLINE_SIZE);\n\t\telse\n\t\t\tlfs->lf[slot].lmtline = lfs->reg_base +\n\t\t\t\tOTX2_CPT_RVU_FUNC_ADDR_S(BLKADDR_LMT, slot,\n\t\t\t\t\t\t OTX2_CPT_LMT_LF_LMTLINEX(0));\n\n\t\tlfs->lf[slot].ioreg = lfs->reg_base +\n\t\t\tOTX2_CPT_RVU_FUNC_ADDR_S(lfs->blkaddr, slot,\n\t\t\t\t\t\t OTX2_CPT_LF_NQX(0));\n\t}\n\t \n\tret = otx2_cpt_attach_rscrs_msg(lfs);\n\tif (ret)\n\t\tgoto clear_lfs_num;\n\n\tret = otx2_cpt_alloc_instruction_queues(lfs);\n\tif (ret) {\n\t\tdev_err(&lfs->pdev->dev,\n\t\t\t\"Allocating instruction queues failed\\n\");\n\t\tgoto detach_rsrcs;\n\t}\n\tcptlf_hw_init(lfs);\n\t \n\tret = cptlf_set_grp_and_pri(lfs, eng_grp_mask, pri);\n\tif (ret)\n\t\tgoto free_iq;\n\n\treturn 0;\n\nfree_iq:\n\totx2_cpt_free_instruction_queues(lfs);\n\tcptlf_hw_cleanup(lfs);\ndetach_rsrcs:\n\totx2_cpt_detach_rsrcs_msg(lfs);\nclear_lfs_num:\n\tlfs->lfs_num = 0;\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cptlf_init, CRYPTO_DEV_OCTEONTX2_CPT);\n\nvoid otx2_cptlf_shutdown(struct otx2_cptlfs_info *lfs)\n{\n\tlfs->lfs_num = 0;\n\t \n\tcptlf_hw_cleanup(lfs);\n\t \n\totx2_cpt_detach_rsrcs_msg(lfs);\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cptlf_shutdown, CRYPTO_DEV_OCTEONTX2_CPT);\n\nMODULE_AUTHOR(\"Marvell\");\nMODULE_DESCRIPTION(\"Marvell RVU CPT Common module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}