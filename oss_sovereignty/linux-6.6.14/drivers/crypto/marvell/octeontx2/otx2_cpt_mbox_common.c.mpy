{
  "module_name": "otx2_cpt_mbox_common.c",
  "hash_id": "15c94a475855f35c1659dc996ee9a0cdb9173497cda2e7e5ed616108f5dc2ff1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/octeontx2/otx2_cpt_mbox_common.c",
  "human_readable_source": "\n \n\n#include \"otx2_cpt_common.h\"\n#include \"otx2_cptlf.h\"\n\nint otx2_cpt_send_mbox_msg(struct otx2_mbox *mbox, struct pci_dev *pdev)\n{\n\tint ret;\n\n\totx2_mbox_msg_send(mbox, 0);\n\tret = otx2_mbox_wait_for_rsp(mbox, 0);\n\tif (ret == -EIO) {\n\t\tdev_err(&pdev->dev, \"RVU MBOX timeout.\\n\");\n\t\treturn ret;\n\t} else if (ret) {\n\t\tdev_err(&pdev->dev, \"RVU MBOX error: %d.\\n\", ret);\n\t\treturn -EFAULT;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cpt_send_mbox_msg, CRYPTO_DEV_OCTEONTX2_CPT);\n\nint otx2_cpt_send_ready_msg(struct otx2_mbox *mbox, struct pci_dev *pdev)\n{\n\tstruct mbox_msghdr *req;\n\n\treq = otx2_mbox_alloc_msg_rsp(mbox, 0, sizeof(*req),\n\t\t\t\t      sizeof(struct ready_msg_rsp));\n\tif (req == NULL) {\n\t\tdev_err(&pdev->dev, \"RVU MBOX failed to get message.\\n\");\n\t\treturn -EFAULT;\n\t}\n\treq->id = MBOX_MSG_READY;\n\treq->sig = OTX2_MBOX_REQ_SIG;\n\treq->pcifunc = 0;\n\n\treturn otx2_cpt_send_mbox_msg(mbox, pdev);\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cpt_send_ready_msg, CRYPTO_DEV_OCTEONTX2_CPT);\n\nint otx2_cpt_send_af_reg_requests(struct otx2_mbox *mbox, struct pci_dev *pdev)\n{\n\treturn otx2_cpt_send_mbox_msg(mbox, pdev);\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cpt_send_af_reg_requests, CRYPTO_DEV_OCTEONTX2_CPT);\n\nstatic int otx2_cpt_add_read_af_reg(struct otx2_mbox *mbox,\n\t\t\t\t    struct pci_dev *pdev, u64 reg,\n\t\t\t\t    u64 *val, int blkaddr)\n{\n\tstruct cpt_rd_wr_reg_msg *reg_msg;\n\n\treg_msg = (struct cpt_rd_wr_reg_msg *)\n\t\t\totx2_mbox_alloc_msg_rsp(mbox, 0, sizeof(*reg_msg),\n\t\t\t\t\t\tsizeof(*reg_msg));\n\tif (reg_msg == NULL) {\n\t\tdev_err(&pdev->dev, \"RVU MBOX failed to get message.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treg_msg->hdr.id = MBOX_MSG_CPT_RD_WR_REGISTER;\n\treg_msg->hdr.sig = OTX2_MBOX_REQ_SIG;\n\treg_msg->hdr.pcifunc = 0;\n\n\treg_msg->is_write = 0;\n\treg_msg->reg_offset = reg;\n\treg_msg->ret_val = val;\n\treg_msg->blkaddr = blkaddr;\n\n\treturn 0;\n}\n\nint otx2_cpt_add_write_af_reg(struct otx2_mbox *mbox, struct pci_dev *pdev,\n\t\t\t      u64 reg, u64 val, int blkaddr)\n{\n\tstruct cpt_rd_wr_reg_msg *reg_msg;\n\n\treg_msg = (struct cpt_rd_wr_reg_msg *)\n\t\t\totx2_mbox_alloc_msg_rsp(mbox, 0, sizeof(*reg_msg),\n\t\t\t\t\t\tsizeof(*reg_msg));\n\tif (reg_msg == NULL) {\n\t\tdev_err(&pdev->dev, \"RVU MBOX failed to get message.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treg_msg->hdr.id = MBOX_MSG_CPT_RD_WR_REGISTER;\n\treg_msg->hdr.sig = OTX2_MBOX_REQ_SIG;\n\treg_msg->hdr.pcifunc = 0;\n\n\treg_msg->is_write = 1;\n\treg_msg->reg_offset = reg;\n\treg_msg->val = val;\n\treg_msg->blkaddr = blkaddr;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cpt_add_write_af_reg, CRYPTO_DEV_OCTEONTX2_CPT);\n\nint otx2_cpt_read_af_reg(struct otx2_mbox *mbox, struct pci_dev *pdev,\n\t\t\t u64 reg, u64 *val, int blkaddr)\n{\n\tint ret;\n\n\tret = otx2_cpt_add_read_af_reg(mbox, pdev, reg, val, blkaddr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn otx2_cpt_send_mbox_msg(mbox, pdev);\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cpt_read_af_reg, CRYPTO_DEV_OCTEONTX2_CPT);\n\nint otx2_cpt_write_af_reg(struct otx2_mbox *mbox, struct pci_dev *pdev,\n\t\t\t  u64 reg, u64 val, int blkaddr)\n{\n\tint ret;\n\n\tret = otx2_cpt_add_write_af_reg(mbox, pdev, reg, val, blkaddr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn otx2_cpt_send_mbox_msg(mbox, pdev);\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cpt_write_af_reg, CRYPTO_DEV_OCTEONTX2_CPT);\n\nint otx2_cpt_attach_rscrs_msg(struct otx2_cptlfs_info *lfs)\n{\n\tstruct otx2_mbox *mbox = lfs->mbox;\n\tstruct rsrc_attach *req;\n\tint ret;\n\n\treq = (struct rsrc_attach *)\n\t\t\totx2_mbox_alloc_msg_rsp(mbox, 0, sizeof(*req),\n\t\t\t\t\t\tsizeof(struct msg_rsp));\n\tif (req == NULL) {\n\t\tdev_err(&lfs->pdev->dev, \"RVU MBOX failed to get message.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treq->hdr.id = MBOX_MSG_ATTACH_RESOURCES;\n\treq->hdr.sig = OTX2_MBOX_REQ_SIG;\n\treq->hdr.pcifunc = 0;\n\treq->cptlfs = lfs->lfs_num;\n\treq->cpt_blkaddr = lfs->blkaddr;\n\treq->modify = 1;\n\tret = otx2_cpt_send_mbox_msg(mbox, lfs->pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!lfs->are_lfs_attached)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nint otx2_cpt_detach_rsrcs_msg(struct otx2_cptlfs_info *lfs)\n{\n\tstruct otx2_mbox *mbox = lfs->mbox;\n\tstruct rsrc_detach *req;\n\tint ret;\n\n\treq = (struct rsrc_detach *)\n\t\t\t\totx2_mbox_alloc_msg_rsp(mbox, 0, sizeof(*req),\n\t\t\t\t\t\t\tsizeof(struct msg_rsp));\n\tif (req == NULL) {\n\t\tdev_err(&lfs->pdev->dev, \"RVU MBOX failed to get message.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treq->hdr.id = MBOX_MSG_DETACH_RESOURCES;\n\treq->hdr.sig = OTX2_MBOX_REQ_SIG;\n\treq->hdr.pcifunc = 0;\n\treq->cptlfs = 1;\n\tret = otx2_cpt_send_mbox_msg(mbox, lfs->pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (lfs->are_lfs_attached)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cpt_detach_rsrcs_msg, CRYPTO_DEV_OCTEONTX2_CPT);\n\nint otx2_cpt_msix_offset_msg(struct otx2_cptlfs_info *lfs)\n{\n\tstruct otx2_mbox *mbox = lfs->mbox;\n\tstruct pci_dev *pdev = lfs->pdev;\n\tstruct mbox_msghdr *req;\n\tint ret, i;\n\n\treq = otx2_mbox_alloc_msg_rsp(mbox, 0, sizeof(*req),\n\t\t\t\t      sizeof(struct msix_offset_rsp));\n\tif (req == NULL) {\n\t\tdev_err(&pdev->dev, \"RVU MBOX failed to get message.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treq->id = MBOX_MSG_MSIX_OFFSET;\n\treq->sig = OTX2_MBOX_REQ_SIG;\n\treq->pcifunc = 0;\n\tret = otx2_cpt_send_mbox_msg(mbox, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < lfs->lfs_num; i++) {\n\t\tif (lfs->lf[i].msix_offset == MSIX_VECTOR_INVALID) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Invalid msix offset %d for LF %d\\n\",\n\t\t\t\tlfs->lf[i].msix_offset, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cpt_msix_offset_msg, CRYPTO_DEV_OCTEONTX2_CPT);\n\nint otx2_cpt_sync_mbox_msg(struct otx2_mbox *mbox)\n{\n\tint err;\n\n\tif (!otx2_mbox_nonempty(mbox, 0))\n\t\treturn 0;\n\totx2_mbox_msg_send(mbox, 0);\n\terr = otx2_mbox_wait_for_rsp(mbox, 0);\n\tif (err)\n\t\treturn err;\n\n\treturn otx2_mbox_check_rsp_msgs(mbox, 0);\n}\nEXPORT_SYMBOL_NS_GPL(otx2_cpt_sync_mbox_msg, CRYPTO_DEV_OCTEONTX2_CPT);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}