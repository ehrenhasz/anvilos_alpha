{
  "module_name": "otx2_cptpf_mbox.c",
  "hash_id": "fc8165b54c99fd7eb77ee49e7960d025269f38d8c21eb5763ce65a42d0df8988",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/octeontx2/otx2_cptpf_mbox.c",
  "human_readable_source": "\n \n\n#include \"otx2_cpt_common.h\"\n#include \"otx2_cptpf.h\"\n#include \"rvu_reg.h\"\n\n \n#define CPT_INLINE_RX_OPCODE (0x26 | (1 << 6))\n#define CN10K_CPT_INLINE_RX_OPCODE (0x29 | (1 << 6))\n\n#define cpt_inline_rx_opcode(pdev)                      \\\n({                                                      \\\n\tu8 opcode;                                      \\\n\tif (is_dev_otx2(pdev))                          \\\n\t\topcode = CPT_INLINE_RX_OPCODE;          \\\n\telse                                            \\\n\t\topcode = CN10K_CPT_INLINE_RX_OPCODE;    \\\n\t(opcode);                                       \\\n})\n\n \n#define OTX2_CPT_PF_DRV_VERSION 0x1\n\nstatic int forward_to_af(struct otx2_cptpf_dev *cptpf,\n\t\t\t struct otx2_cptvf_info *vf,\n\t\t\t struct mbox_msghdr *req, int size)\n{\n\tstruct mbox_msghdr *msg;\n\tint ret;\n\n\tmutex_lock(&cptpf->lock);\n\tmsg = otx2_mbox_alloc_msg(&cptpf->afpf_mbox, 0, size);\n\tif (msg == NULL) {\n\t\tmutex_unlock(&cptpf->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy((uint8_t *)msg + sizeof(struct mbox_msghdr),\n\t       (uint8_t *)req + sizeof(struct mbox_msghdr), size);\n\tmsg->id = req->id;\n\tmsg->pcifunc = req->pcifunc;\n\tmsg->sig = req->sig;\n\tmsg->ver = req->ver;\n\n\tret = otx2_cpt_sync_mbox_msg(&cptpf->afpf_mbox);\n\t \n\tif (ret == -EIO) {\n\t\tdev_warn(&cptpf->pdev->dev,\n\t\t\t \"AF not responding to VF%d messages\\n\", vf->vf_id);\n\t\tmutex_unlock(&cptpf->lock);\n\t\treturn ret;\n\t}\n\tmutex_unlock(&cptpf->lock);\n\treturn 0;\n}\n\nstatic int handle_msg_get_caps(struct otx2_cptpf_dev *cptpf,\n\t\t\t       struct otx2_cptvf_info *vf,\n\t\t\t       struct mbox_msghdr *req)\n{\n\tstruct otx2_cpt_caps_rsp *rsp;\n\n\trsp = (struct otx2_cpt_caps_rsp *)\n\t      otx2_mbox_alloc_msg(&cptpf->vfpf_mbox, vf->vf_id,\n\t\t\t\t  sizeof(*rsp));\n\tif (!rsp)\n\t\treturn -ENOMEM;\n\n\trsp->hdr.id = MBOX_MSG_GET_CAPS;\n\trsp->hdr.sig = OTX2_MBOX_RSP_SIG;\n\trsp->hdr.pcifunc = req->pcifunc;\n\trsp->cpt_pf_drv_version = OTX2_CPT_PF_DRV_VERSION;\n\trsp->cpt_revision = cptpf->pdev->revision;\n\tmemcpy(&rsp->eng_caps, &cptpf->eng_caps, sizeof(rsp->eng_caps));\n\n\treturn 0;\n}\n\nstatic int handle_msg_get_eng_grp_num(struct otx2_cptpf_dev *cptpf,\n\t\t\t\t      struct otx2_cptvf_info *vf,\n\t\t\t\t      struct mbox_msghdr *req)\n{\n\tstruct otx2_cpt_egrp_num_msg *grp_req;\n\tstruct otx2_cpt_egrp_num_rsp *rsp;\n\n\tgrp_req = (struct otx2_cpt_egrp_num_msg *)req;\n\trsp = (struct otx2_cpt_egrp_num_rsp *)\n\t       otx2_mbox_alloc_msg(&cptpf->vfpf_mbox, vf->vf_id, sizeof(*rsp));\n\tif (!rsp)\n\t\treturn -ENOMEM;\n\n\trsp->hdr.id = MBOX_MSG_GET_ENG_GRP_NUM;\n\trsp->hdr.sig = OTX2_MBOX_RSP_SIG;\n\trsp->hdr.pcifunc = req->pcifunc;\n\trsp->eng_type = grp_req->eng_type;\n\trsp->eng_grp_num = otx2_cpt_get_eng_grp(&cptpf->eng_grps,\n\t\t\t\t\t\tgrp_req->eng_type);\n\n\treturn 0;\n}\n\nstatic int handle_msg_kvf_limits(struct otx2_cptpf_dev *cptpf,\n\t\t\t\t struct otx2_cptvf_info *vf,\n\t\t\t\t struct mbox_msghdr *req)\n{\n\tstruct otx2_cpt_kvf_limits_rsp *rsp;\n\n\trsp = (struct otx2_cpt_kvf_limits_rsp *)\n\t      otx2_mbox_alloc_msg(&cptpf->vfpf_mbox, vf->vf_id, sizeof(*rsp));\n\tif (!rsp)\n\t\treturn -ENOMEM;\n\n\trsp->hdr.id = MBOX_MSG_GET_KVF_LIMITS;\n\trsp->hdr.sig = OTX2_MBOX_RSP_SIG;\n\trsp->hdr.pcifunc = req->pcifunc;\n\trsp->kvf_limits = cptpf->kvf_limits;\n\n\treturn 0;\n}\n\nstatic int send_inline_ipsec_inbound_msg(struct otx2_cptpf_dev *cptpf,\n\t\t\t\t\t int sso_pf_func, u8 slot)\n{\n\tstruct cpt_inline_ipsec_cfg_msg *req;\n\tstruct pci_dev *pdev = cptpf->pdev;\n\n\treq = (struct cpt_inline_ipsec_cfg_msg *)\n\t      otx2_mbox_alloc_msg_rsp(&cptpf->afpf_mbox, 0,\n\t\t\t\t      sizeof(*req), sizeof(struct msg_rsp));\n\tif (req == NULL) {\n\t\tdev_err(&pdev->dev, \"RVU MBOX failed to get message.\\n\");\n\t\treturn -EFAULT;\n\t}\n\tmemset(req, 0, sizeof(*req));\n\treq->hdr.id = MBOX_MSG_CPT_INLINE_IPSEC_CFG;\n\treq->hdr.sig = OTX2_MBOX_REQ_SIG;\n\treq->hdr.pcifunc = OTX2_CPT_RVU_PFFUNC(cptpf->pf_id, 0);\n\treq->dir = CPT_INLINE_INBOUND;\n\treq->slot = slot;\n\treq->sso_pf_func_ovrd = cptpf->sso_pf_func_ovrd;\n\treq->sso_pf_func = sso_pf_func;\n\treq->enable = 1;\n\n\treturn otx2_cpt_send_mbox_msg(&cptpf->afpf_mbox, pdev);\n}\n\nstatic int rx_inline_ipsec_lf_cfg(struct otx2_cptpf_dev *cptpf, u8 egrp,\n\t\t\t\t  struct otx2_cpt_rx_inline_lf_cfg *req)\n{\n\tstruct nix_inline_ipsec_cfg *nix_req;\n\tstruct pci_dev *pdev = cptpf->pdev;\n\tint ret;\n\n\tnix_req = (struct nix_inline_ipsec_cfg *)\n\t\t   otx2_mbox_alloc_msg_rsp(&cptpf->afpf_mbox, 0,\n\t\t\t\t\t   sizeof(*nix_req),\n\t\t\t\t\t   sizeof(struct msg_rsp));\n\tif (nix_req == NULL) {\n\t\tdev_err(&pdev->dev, \"RVU MBOX failed to get message.\\n\");\n\t\treturn -EFAULT;\n\t}\n\tmemset(nix_req, 0, sizeof(*nix_req));\n\tnix_req->hdr.id = MBOX_MSG_NIX_INLINE_IPSEC_CFG;\n\tnix_req->hdr.sig = OTX2_MBOX_REQ_SIG;\n\tnix_req->enable = 1;\n\tif (!req->credit || req->credit > OTX2_CPT_INST_QLEN_MSGS)\n\t\tnix_req->cpt_credit = OTX2_CPT_INST_QLEN_MSGS - 1;\n\telse\n\t\tnix_req->cpt_credit = req->credit - 1;\n\tnix_req->gen_cfg.egrp = egrp;\n\tif (req->opcode)\n\t\tnix_req->gen_cfg.opcode = req->opcode;\n\telse\n\t\tnix_req->gen_cfg.opcode = cpt_inline_rx_opcode(pdev);\n\tnix_req->gen_cfg.param1 = req->param1;\n\tnix_req->gen_cfg.param2 = req->param2;\n\tnix_req->inst_qsel.cpt_pf_func = OTX2_CPT_RVU_PFFUNC(cptpf->pf_id, 0);\n\tnix_req->inst_qsel.cpt_slot = 0;\n\tret = otx2_cpt_send_mbox_msg(&cptpf->afpf_mbox, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cptpf->has_cpt1) {\n\t\tret = send_inline_ipsec_inbound_msg(cptpf, req->sso_pf_func, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn send_inline_ipsec_inbound_msg(cptpf, req->sso_pf_func, 0);\n}\n\nstatic int handle_msg_rx_inline_ipsec_lf_cfg(struct otx2_cptpf_dev *cptpf,\n\t\t\t\t\t     struct mbox_msghdr *req)\n{\n\tstruct otx2_cpt_rx_inline_lf_cfg *cfg_req;\n\tu8 egrp;\n\tint ret;\n\n\tcfg_req = (struct otx2_cpt_rx_inline_lf_cfg *)req;\n\tif (cptpf->lfs.lfs_num) {\n\t\tdev_err(&cptpf->pdev->dev,\n\t\t\t\"LF is already configured for RX inline ipsec.\\n\");\n\t\treturn -EEXIST;\n\t}\n\t \n\tegrp = otx2_cpt_get_eng_grp(&cptpf->eng_grps, OTX2_CPT_IE_TYPES);\n\tif (egrp == OTX2_CPT_INVALID_CRYPTO_ENG_GRP) {\n\t\tdev_err(&cptpf->pdev->dev,\n\t\t\t\"Engine group for inline ipsec is not available\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\totx2_cptlf_set_dev_info(&cptpf->lfs, cptpf->pdev, cptpf->reg_base,\n\t\t\t\t&cptpf->afpf_mbox, BLKADDR_CPT0);\n\tret = otx2_cptlf_init(&cptpf->lfs, 1 << egrp, OTX2_CPT_QUEUE_HI_PRIO,\n\t\t\t      1);\n\tif (ret) {\n\t\tdev_err(&cptpf->pdev->dev,\n\t\t\t\"LF configuration failed for RX inline ipsec.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (cptpf->has_cpt1) {\n\t\tcptpf->rsrc_req_blkaddr = BLKADDR_CPT1;\n\t\totx2_cptlf_set_dev_info(&cptpf->cpt1_lfs, cptpf->pdev,\n\t\t\t\t\tcptpf->reg_base, &cptpf->afpf_mbox,\n\t\t\t\t\tBLKADDR_CPT1);\n\t\tret = otx2_cptlf_init(&cptpf->cpt1_lfs, 1 << egrp,\n\t\t\t\t      OTX2_CPT_QUEUE_HI_PRIO, 1);\n\t\tif (ret) {\n\t\t\tdev_err(&cptpf->pdev->dev,\n\t\t\t\t\"LF configuration failed for RX inline ipsec.\\n\");\n\t\t\tgoto lf_cleanup;\n\t\t}\n\t\tcptpf->rsrc_req_blkaddr = 0;\n\t}\n\n\tret = rx_inline_ipsec_lf_cfg(cptpf, egrp, cfg_req);\n\tif (ret)\n\t\tgoto lf1_cleanup;\n\n\treturn 0;\n\nlf1_cleanup:\n\totx2_cptlf_shutdown(&cptpf->cpt1_lfs);\nlf_cleanup:\n\totx2_cptlf_shutdown(&cptpf->lfs);\n\treturn ret;\n}\n\nstatic int cptpf_handle_vf_req(struct otx2_cptpf_dev *cptpf,\n\t\t\t       struct otx2_cptvf_info *vf,\n\t\t\t       struct mbox_msghdr *req, int size)\n{\n\tint err = 0;\n\n\t \n\tif (req->sig != OTX2_MBOX_REQ_SIG)\n\t\tgoto inval_msg;\n\n\tswitch (req->id) {\n\tcase MBOX_MSG_GET_ENG_GRP_NUM:\n\t\terr = handle_msg_get_eng_grp_num(cptpf, vf, req);\n\t\tbreak;\n\tcase MBOX_MSG_GET_CAPS:\n\t\terr = handle_msg_get_caps(cptpf, vf, req);\n\t\tbreak;\n\tcase MBOX_MSG_GET_KVF_LIMITS:\n\t\terr = handle_msg_kvf_limits(cptpf, vf, req);\n\t\tbreak;\n\tcase MBOX_MSG_RX_INLINE_IPSEC_LF_CFG:\n\t\terr = handle_msg_rx_inline_ipsec_lf_cfg(cptpf, req);\n\t\tbreak;\n\n\tdefault:\n\t\terr = forward_to_af(cptpf, vf, req, size);\n\t\tbreak;\n\t}\n\treturn err;\n\ninval_msg:\n\totx2_reply_invalid_msg(&cptpf->vfpf_mbox, vf->vf_id, 0, req->id);\n\totx2_mbox_msg_send(&cptpf->vfpf_mbox, vf->vf_id);\n\treturn err;\n}\n\nirqreturn_t otx2_cptpf_vfpf_mbox_intr(int __always_unused irq, void *arg)\n{\n\tstruct otx2_cptpf_dev *cptpf = arg;\n\tstruct otx2_cptvf_info *vf;\n\tint i, vf_idx;\n\tu64 intr;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\t \n\t\tintr = otx2_cpt_read64(cptpf->reg_base, BLKADDR_RVUM, 0,\n\t\t\t\t       RVU_PF_VFPF_MBOX_INTX(i));\n\n\t\tfor (vf_idx = i * 64; vf_idx < cptpf->enabled_vfs; vf_idx++) {\n\t\t\tvf = &cptpf->vf[vf_idx];\n\t\t\tif (intr & (1ULL << vf->intr_idx)) {\n\t\t\t\tqueue_work(cptpf->vfpf_mbox_wq,\n\t\t\t\t\t   &vf->vfpf_mbox_work);\n\t\t\t\t \n\t\t\t\totx2_cpt_write64(cptpf->reg_base, BLKADDR_RVUM,\n\t\t\t\t\t\t 0, RVU_PF_VFPF_MBOX_INTX(i),\n\t\t\t\t\t\t BIT_ULL(vf->intr_idx));\n\t\t\t}\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nvoid otx2_cptpf_vfpf_mbox_handler(struct work_struct *work)\n{\n\tstruct otx2_cptpf_dev *cptpf;\n\tstruct otx2_cptvf_info *vf;\n\tstruct otx2_mbox_dev *mdev;\n\tstruct mbox_hdr *req_hdr;\n\tstruct mbox_msghdr *msg;\n\tstruct otx2_mbox *mbox;\n\tint offset, i, err;\n\n\tvf = container_of(work, struct otx2_cptvf_info, vfpf_mbox_work);\n\tcptpf = vf->cptpf;\n\tmbox = &cptpf->vfpf_mbox;\n\t \n\tsmp_rmb();\n\tmdev = &mbox->dev[vf->vf_id];\n\t \n\treq_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);\n\toffset = mbox->rx_start + ALIGN(sizeof(*req_hdr), MBOX_MSG_ALIGN);\n\n\tfor (i = 0; i < req_hdr->num_msgs; i++) {\n\t\tmsg = (struct mbox_msghdr *)(mdev->mbase + offset);\n\n\t\t \n\t\tmsg->pcifunc = ((u16)cptpf->pf_id << RVU_PFVF_PF_SHIFT) |\n\t\t\t\t((vf->vf_id + 1) & RVU_PFVF_FUNC_MASK);\n\n\t\terr = cptpf_handle_vf_req(cptpf, vf, msg,\n\t\t\t\t\t  msg->next_msgoff - offset);\n\t\t \n\t\tif (err == -ENOMEM || err == -EIO)\n\t\t\tbreak;\n\t\toffset = msg->next_msgoff;\n\t\t \n\t\tsmp_wmb();\n\t}\n\t \n\tif (mdev->num_msgs)\n\t\totx2_mbox_msg_send(mbox, vf->vf_id);\n}\n\nirqreturn_t otx2_cptpf_afpf_mbox_intr(int __always_unused irq, void *arg)\n{\n\tstruct otx2_cptpf_dev *cptpf = arg;\n\tstruct otx2_mbox_dev *mdev;\n\tstruct otx2_mbox *mbox;\n\tstruct mbox_hdr *hdr;\n\tu64 intr;\n\n\t \n\tintr = otx2_cpt_read64(cptpf->reg_base, BLKADDR_RVUM, 0, RVU_PF_INT);\n\n\tif (intr & 0x1ULL) {\n\t\tmbox = &cptpf->afpf_mbox;\n\t\tmdev = &mbox->dev[0];\n\t\thdr = mdev->mbase + mbox->rx_start;\n\t\tif (hdr->num_msgs)\n\t\t\t \n\t\t\tqueue_work(cptpf->afpf_mbox_wq, &cptpf->afpf_mbox_work);\n\n\t\tmbox = &cptpf->afpf_mbox_up;\n\t\tmdev = &mbox->dev[0];\n\t\thdr = mdev->mbase + mbox->rx_start;\n\t\tif (hdr->num_msgs)\n\t\t\t \n\t\t\tqueue_work(cptpf->afpf_mbox_wq, &cptpf->afpf_mbox_up_work);\n\t\t \n\t\totx2_cpt_write64(cptpf->reg_base, BLKADDR_RVUM, 0, RVU_PF_INT,\n\t\t\t\t 0x1ULL);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void process_afpf_mbox_msg(struct otx2_cptpf_dev *cptpf,\n\t\t\t\t  struct mbox_msghdr *msg)\n{\n\tstruct otx2_cptlfs_info *lfs = &cptpf->lfs;\n\tstruct device *dev = &cptpf->pdev->dev;\n\tstruct cpt_rd_wr_reg_msg *rsp_rd_wr;\n\n\tif (msg->id >= MBOX_MSG_MAX) {\n\t\tdev_err(dev, \"MBOX msg with unknown ID %d\\n\", msg->id);\n\t\treturn;\n\t}\n\tif (msg->sig != OTX2_MBOX_RSP_SIG) {\n\t\tdev_err(dev, \"MBOX msg with wrong signature %x, ID %d\\n\",\n\t\t\tmsg->sig, msg->id);\n\t\treturn;\n\t}\n\tif (cptpf->rsrc_req_blkaddr == BLKADDR_CPT1)\n\t\tlfs = &cptpf->cpt1_lfs;\n\n\tswitch (msg->id) {\n\tcase MBOX_MSG_READY:\n\t\tcptpf->pf_id = (msg->pcifunc >> RVU_PFVF_PF_SHIFT) &\n\t\t\t\tRVU_PFVF_PF_MASK;\n\t\tbreak;\n\tcase MBOX_MSG_CPT_RD_WR_REGISTER:\n\t\trsp_rd_wr = (struct cpt_rd_wr_reg_msg *)msg;\n\t\tif (msg->rc) {\n\t\t\tdev_err(dev, \"Reg %llx rd/wr(%d) failed %d\\n\",\n\t\t\t\trsp_rd_wr->reg_offset, rsp_rd_wr->is_write,\n\t\t\t\tmsg->rc);\n\t\t\treturn;\n\t\t}\n\t\tif (!rsp_rd_wr->is_write)\n\t\t\t*rsp_rd_wr->ret_val = rsp_rd_wr->val;\n\t\tbreak;\n\tcase MBOX_MSG_ATTACH_RESOURCES:\n\t\tif (!msg->rc)\n\t\t\tlfs->are_lfs_attached = 1;\n\t\tbreak;\n\tcase MBOX_MSG_DETACH_RESOURCES:\n\t\tif (!msg->rc)\n\t\t\tlfs->are_lfs_attached = 0;\n\t\tbreak;\n\tcase MBOX_MSG_CPT_INLINE_IPSEC_CFG:\n\tcase MBOX_MSG_NIX_INLINE_IPSEC_CFG:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev,\n\t\t\t\"Unsupported msg %d received.\\n\", msg->id);\n\t\tbreak;\n\t}\n}\n\nstatic void forward_to_vf(struct otx2_cptpf_dev *cptpf, struct mbox_msghdr *msg,\n\t\t\t  int vf_id, int size)\n{\n\tstruct otx2_mbox *vfpf_mbox;\n\tstruct mbox_msghdr *fwd;\n\n\tif (msg->id >= MBOX_MSG_MAX) {\n\t\tdev_err(&cptpf->pdev->dev,\n\t\t\t\"MBOX msg with unknown ID %d\\n\", msg->id);\n\t\treturn;\n\t}\n\tif (msg->sig != OTX2_MBOX_RSP_SIG) {\n\t\tdev_err(&cptpf->pdev->dev,\n\t\t\t\"MBOX msg with wrong signature %x, ID %d\\n\",\n\t\t\tmsg->sig, msg->id);\n\t\treturn;\n\t}\n\tvfpf_mbox = &cptpf->vfpf_mbox;\n\tvf_id--;\n\tif (vf_id >= cptpf->enabled_vfs) {\n\t\tdev_err(&cptpf->pdev->dev,\n\t\t\t\"MBOX msg to unknown VF: %d >= %d\\n\",\n\t\t\tvf_id, cptpf->enabled_vfs);\n\t\treturn;\n\t}\n\tif (msg->id == MBOX_MSG_VF_FLR)\n\t\treturn;\n\n\tfwd = otx2_mbox_alloc_msg(vfpf_mbox, vf_id, size);\n\tif (!fwd) {\n\t\tdev_err(&cptpf->pdev->dev,\n\t\t\t\"Forwarding to VF%d failed.\\n\", vf_id);\n\t\treturn;\n\t}\n\tmemcpy((uint8_t *)fwd + sizeof(struct mbox_msghdr),\n\t\t(uint8_t *)msg + sizeof(struct mbox_msghdr), size);\n\tfwd->id = msg->id;\n\tfwd->pcifunc = msg->pcifunc;\n\tfwd->sig = msg->sig;\n\tfwd->ver = msg->ver;\n\tfwd->rc = msg->rc;\n}\n\n \nvoid otx2_cptpf_afpf_mbox_handler(struct work_struct *work)\n{\n\tstruct otx2_cptpf_dev *cptpf;\n\tstruct otx2_mbox *afpf_mbox;\n\tstruct otx2_mbox_dev *mdev;\n\tstruct mbox_hdr *rsp_hdr;\n\tstruct mbox_msghdr *msg;\n\tint offset, vf_id, i;\n\n\tcptpf = container_of(work, struct otx2_cptpf_dev, afpf_mbox_work);\n\tafpf_mbox = &cptpf->afpf_mbox;\n\tmdev = &afpf_mbox->dev[0];\n\t \n\tsmp_wmb();\n\n\trsp_hdr = (struct mbox_hdr *)(mdev->mbase + afpf_mbox->rx_start);\n\toffset = ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);\n\n\tfor (i = 0; i < rsp_hdr->num_msgs; i++) {\n\t\tmsg = (struct mbox_msghdr *)(mdev->mbase + afpf_mbox->rx_start +\n\t\t\t\t\t     offset);\n\t\tvf_id = (msg->pcifunc >> RVU_PFVF_FUNC_SHIFT) &\n\t\t\t RVU_PFVF_FUNC_MASK;\n\t\tif (vf_id > 0)\n\t\t\tforward_to_vf(cptpf, msg, vf_id,\n\t\t\t\t      msg->next_msgoff - offset);\n\t\telse\n\t\t\tprocess_afpf_mbox_msg(cptpf, msg);\n\n\t\toffset = msg->next_msgoff;\n\t\t \n\t\tsmp_wmb();\n\t\tmdev->msgs_acked++;\n\t}\n\totx2_mbox_reset(afpf_mbox, 0);\n}\n\nstatic void handle_msg_cpt_inst_lmtst(struct otx2_cptpf_dev *cptpf,\n\t\t\t\t      struct mbox_msghdr *msg)\n{\n\tstruct cpt_inst_lmtst_req *req = (struct cpt_inst_lmtst_req *)msg;\n\tstruct otx2_cptlfs_info *lfs = &cptpf->lfs;\n\tstruct msg_rsp *rsp;\n\n\tif (cptpf->lfs.lfs_num)\n\t\tlfs->ops->send_cmd((union otx2_cpt_inst_s *)req->inst, 1,\n\t\t\t\t   &lfs->lf[0]);\n\n\trsp = (struct msg_rsp *)otx2_mbox_alloc_msg(&cptpf->afpf_mbox_up, 0,\n\t\t\t\t\t\t    sizeof(*rsp));\n\tif (!rsp)\n\t\treturn;\n\n\trsp->hdr.id = msg->id;\n\trsp->hdr.sig = OTX2_MBOX_RSP_SIG;\n\trsp->hdr.pcifunc = 0;\n\trsp->hdr.rc = 0;\n}\n\nstatic void process_afpf_mbox_up_msg(struct otx2_cptpf_dev *cptpf,\n\t\t\t\t     struct mbox_msghdr *msg)\n{\n\tif (msg->id >= MBOX_MSG_MAX) {\n\t\tdev_err(&cptpf->pdev->dev,\n\t\t\t\"MBOX msg with unknown ID %d\\n\", msg->id);\n\t\treturn;\n\t}\n\n\tswitch (msg->id) {\n\tcase MBOX_MSG_CPT_INST_LMTST:\n\t\thandle_msg_cpt_inst_lmtst(cptpf, msg);\n\t\tbreak;\n\tdefault:\n\t\totx2_reply_invalid_msg(&cptpf->afpf_mbox_up, 0, 0, msg->id);\n\t}\n}\n\nvoid otx2_cptpf_afpf_mbox_up_handler(struct work_struct *work)\n{\n\tstruct otx2_cptpf_dev *cptpf;\n\tstruct otx2_mbox_dev *mdev;\n\tstruct mbox_hdr *rsp_hdr;\n\tstruct mbox_msghdr *msg;\n\tstruct otx2_mbox *mbox;\n\tint offset, i;\n\n\tcptpf = container_of(work, struct otx2_cptpf_dev, afpf_mbox_up_work);\n\tmbox = &cptpf->afpf_mbox_up;\n\tmdev = &mbox->dev[0];\n\t \n\tsmp_wmb();\n\n\trsp_hdr = (struct mbox_hdr *)(mdev->mbase + mbox->rx_start);\n\toffset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);\n\n\tfor (i = 0; i < rsp_hdr->num_msgs; i++) {\n\t\tmsg = (struct mbox_msghdr *)(mdev->mbase + offset);\n\n\t\tprocess_afpf_mbox_up_msg(cptpf, msg);\n\n\t\toffset = mbox->rx_start + msg->next_msgoff;\n\t}\n\totx2_mbox_msg_send(mbox, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}