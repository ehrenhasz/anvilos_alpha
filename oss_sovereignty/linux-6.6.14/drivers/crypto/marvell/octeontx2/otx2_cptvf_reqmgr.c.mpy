{
  "module_name": "otx2_cptvf_reqmgr.c",
  "hash_id": "86c999243e85c2356e4b7c548dec974e91a1532a8cb730b23f374e8ec8a7c06e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/octeontx2/otx2_cptvf_reqmgr.c",
  "human_readable_source": "\n \n\n#include \"otx2_cptvf.h\"\n#include \"otx2_cpt_common.h\"\n\n \n#define SG_LIST_HDR_SIZE\t8\n\n \n#define CPT_PENTRY_TIMEOUT\t1000\n#define CPT_PENTRY_STEP\t\t50\n\n \n#define CPT_IQ_STOP_MARGIN\t128\n#define CPT_IQ_RESUME_MARGIN\t512\n\n \n#define CPT_COMMAND_TIMEOUT\t4\n#define CPT_TIME_IN_RESET_COUNT 5\n\nstatic void otx2_cpt_dump_sg_list(struct pci_dev *pdev,\n\t\t\t\t  struct otx2_cpt_req_info *req)\n{\n\tint i;\n\n\tpr_debug(\"Gather list size %d\\n\", req->in_cnt);\n\tfor (i = 0; i < req->in_cnt; i++) {\n\t\tpr_debug(\"Buffer %d size %d, vptr 0x%p, dmaptr 0x%p\\n\", i,\n\t\t\t req->in[i].size, req->in[i].vptr,\n\t\t\t (void *) req->in[i].dma_addr);\n\t\tpr_debug(\"Buffer hexdump (%d bytes)\\n\",\n\t\t\t req->in[i].size);\n\t\tprint_hex_dump_debug(\"\", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t\t     req->in[i].vptr, req->in[i].size, false);\n\t}\n\tpr_debug(\"Scatter list size %d\\n\", req->out_cnt);\n\tfor (i = 0; i < req->out_cnt; i++) {\n\t\tpr_debug(\"Buffer %d size %d, vptr 0x%p, dmaptr 0x%p\\n\", i,\n\t\t\t req->out[i].size, req->out[i].vptr,\n\t\t\t (void *) req->out[i].dma_addr);\n\t\tpr_debug(\"Buffer hexdump (%d bytes)\\n\", req->out[i].size);\n\t\tprint_hex_dump_debug(\"\", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t\t     req->out[i].vptr, req->out[i].size, false);\n\t}\n}\n\nstatic inline struct otx2_cpt_pending_entry *get_free_pending_entry(\n\t\t\t\t\tstruct otx2_cpt_pending_queue *q,\n\t\t\t\t\tint qlen)\n{\n\tstruct otx2_cpt_pending_entry *ent = NULL;\n\n\tent = &q->head[q->rear];\n\tif (unlikely(ent->busy))\n\t\treturn NULL;\n\n\tq->rear++;\n\tif (unlikely(q->rear == qlen))\n\t\tq->rear = 0;\n\n\treturn ent;\n}\n\nstatic inline u32 modulo_inc(u32 index, u32 length, u32 inc)\n{\n\tif (WARN_ON(inc > length))\n\t\tinc = length;\n\n\tindex += inc;\n\tif (unlikely(index >= length))\n\t\tindex -= length;\n\n\treturn index;\n}\n\nstatic inline void free_pentry(struct otx2_cpt_pending_entry *pentry)\n{\n\tpentry->completion_addr = NULL;\n\tpentry->info = NULL;\n\tpentry->callback = NULL;\n\tpentry->areq = NULL;\n\tpentry->resume_sender = false;\n\tpentry->busy = false;\n}\n\nstatic inline int setup_sgio_components(struct pci_dev *pdev,\n\t\t\t\t\tstruct otx2_cpt_buf_ptr *list,\n\t\t\t\t\tint buf_count, u8 *buffer)\n{\n\tstruct otx2_cpt_sglist_component *sg_ptr = NULL;\n\tint ret = 0, i, j;\n\tint components;\n\n\tif (unlikely(!list)) {\n\t\tdev_err(&pdev->dev, \"Input list pointer is NULL\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < buf_count; i++) {\n\t\tif (unlikely(!list[i].vptr))\n\t\t\tcontinue;\n\t\tlist[i].dma_addr = dma_map_single(&pdev->dev, list[i].vptr,\n\t\t\t\t\t\t  list[i].size,\n\t\t\t\t\t\t  DMA_BIDIRECTIONAL);\n\t\tif (unlikely(dma_mapping_error(&pdev->dev, list[i].dma_addr))) {\n\t\t\tdev_err(&pdev->dev, \"Dma mapping failed\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto sg_cleanup;\n\t\t}\n\t}\n\tcomponents = buf_count / 4;\n\tsg_ptr = (struct otx2_cpt_sglist_component *)buffer;\n\tfor (i = 0; i < components; i++) {\n\t\tsg_ptr->len0 = cpu_to_be16(list[i * 4 + 0].size);\n\t\tsg_ptr->len1 = cpu_to_be16(list[i * 4 + 1].size);\n\t\tsg_ptr->len2 = cpu_to_be16(list[i * 4 + 2].size);\n\t\tsg_ptr->len3 = cpu_to_be16(list[i * 4 + 3].size);\n\t\tsg_ptr->ptr0 = cpu_to_be64(list[i * 4 + 0].dma_addr);\n\t\tsg_ptr->ptr1 = cpu_to_be64(list[i * 4 + 1].dma_addr);\n\t\tsg_ptr->ptr2 = cpu_to_be64(list[i * 4 + 2].dma_addr);\n\t\tsg_ptr->ptr3 = cpu_to_be64(list[i * 4 + 3].dma_addr);\n\t\tsg_ptr++;\n\t}\n\tcomponents = buf_count % 4;\n\n\tswitch (components) {\n\tcase 3:\n\t\tsg_ptr->len2 = cpu_to_be16(list[i * 4 + 2].size);\n\t\tsg_ptr->ptr2 = cpu_to_be64(list[i * 4 + 2].dma_addr);\n\t\tfallthrough;\n\tcase 2:\n\t\tsg_ptr->len1 = cpu_to_be16(list[i * 4 + 1].size);\n\t\tsg_ptr->ptr1 = cpu_to_be64(list[i * 4 + 1].dma_addr);\n\t\tfallthrough;\n\tcase 1:\n\t\tsg_ptr->len0 = cpu_to_be16(list[i * 4 + 0].size);\n\t\tsg_ptr->ptr0 = cpu_to_be64(list[i * 4 + 0].dma_addr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n\nsg_cleanup:\n\tfor (j = 0; j < i; j++) {\n\t\tif (list[j].dma_addr) {\n\t\t\tdma_unmap_single(&pdev->dev, list[j].dma_addr,\n\t\t\t\t\t list[j].size, DMA_BIDIRECTIONAL);\n\t\t}\n\n\t\tlist[j].dma_addr = 0;\n\t}\n\treturn ret;\n}\n\nstatic inline struct otx2_cpt_inst_info *info_create(struct pci_dev *pdev,\n\t\t\t\t\t      struct otx2_cpt_req_info *req,\n\t\t\t\t\t      gfp_t gfp)\n{\n\tint align = OTX2_CPT_DMA_MINALIGN;\n\tstruct otx2_cpt_inst_info *info;\n\tu32 dlen, align_dlen, info_len;\n\tu16 g_sz_bytes, s_sz_bytes;\n\tu32 total_mem_len;\n\n\tif (unlikely(req->in_cnt > OTX2_CPT_MAX_SG_IN_CNT ||\n\t\t     req->out_cnt > OTX2_CPT_MAX_SG_OUT_CNT)) {\n\t\tdev_err(&pdev->dev, \"Error too many sg components\\n\");\n\t\treturn NULL;\n\t}\n\n\tg_sz_bytes = ((req->in_cnt + 3) / 4) *\n\t\t      sizeof(struct otx2_cpt_sglist_component);\n\ts_sz_bytes = ((req->out_cnt + 3) / 4) *\n\t\t      sizeof(struct otx2_cpt_sglist_component);\n\n\tdlen = g_sz_bytes + s_sz_bytes + SG_LIST_HDR_SIZE;\n\talign_dlen = ALIGN(dlen, align);\n\tinfo_len = ALIGN(sizeof(*info), align);\n\ttotal_mem_len = align_dlen + info_len + sizeof(union otx2_cpt_res_s);\n\n\tinfo = kzalloc(total_mem_len, gfp);\n\tif (unlikely(!info))\n\t\treturn NULL;\n\n\tinfo->dlen = dlen;\n\tinfo->in_buffer = (u8 *)info + info_len;\n\n\t((u16 *)info->in_buffer)[0] = req->out_cnt;\n\t((u16 *)info->in_buffer)[1] = req->in_cnt;\n\t((u16 *)info->in_buffer)[2] = 0;\n\t((u16 *)info->in_buffer)[3] = 0;\n\tcpu_to_be64s((u64 *)info->in_buffer);\n\n\t \n\tif (setup_sgio_components(pdev, req->in, req->in_cnt,\n\t\t\t\t  &info->in_buffer[8])) {\n\t\tdev_err(&pdev->dev, \"Failed to setup gather list\\n\");\n\t\tgoto destroy_info;\n\t}\n\n\tif (setup_sgio_components(pdev, req->out, req->out_cnt,\n\t\t\t\t  &info->in_buffer[8 + g_sz_bytes])) {\n\t\tdev_err(&pdev->dev, \"Failed to setup scatter list\\n\");\n\t\tgoto destroy_info;\n\t}\n\n\tinfo->dma_len = total_mem_len - info_len;\n\tinfo->dptr_baddr = dma_map_single(&pdev->dev, info->in_buffer,\n\t\t\t\t\t  info->dma_len, DMA_BIDIRECTIONAL);\n\tif (unlikely(dma_mapping_error(&pdev->dev, info->dptr_baddr))) {\n\t\tdev_err(&pdev->dev, \"DMA Mapping failed for cpt req\\n\");\n\t\tgoto destroy_info;\n\t}\n\t \n\tinfo->completion_addr = info->in_buffer + align_dlen;\n\tinfo->comp_baddr = info->dptr_baddr + align_dlen;\n\n\treturn info;\n\ndestroy_info:\n\totx2_cpt_info_destroy(pdev, info);\n\treturn NULL;\n}\n\nstatic int process_request(struct pci_dev *pdev, struct otx2_cpt_req_info *req,\n\t\t\t   struct otx2_cpt_pending_queue *pqueue,\n\t\t\t   struct otx2_cptlf_info *lf)\n{\n\tstruct otx2_cptvf_request *cpt_req = &req->req;\n\tstruct otx2_cpt_pending_entry *pentry = NULL;\n\tunion otx2_cpt_ctrl_info *ctrl = &req->ctrl;\n\tstruct otx2_cpt_inst_info *info = NULL;\n\tunion otx2_cpt_res_s *result = NULL;\n\tstruct otx2_cpt_iq_command iq_cmd;\n\tunion otx2_cpt_inst_s cptinst;\n\tint retry, ret = 0;\n\tu8 resume_sender;\n\tgfp_t gfp;\n\n\tgfp = (req->areq->flags & CRYPTO_TFM_REQ_MAY_SLEEP) ? GFP_KERNEL :\n\t\t\t\t\t\t\t      GFP_ATOMIC;\n\tif (unlikely(!otx2_cptlf_started(lf->lfs)))\n\t\treturn -ENODEV;\n\n\tinfo = info_create(pdev, req, gfp);\n\tif (unlikely(!info)) {\n\t\tdev_err(&pdev->dev, \"Setting up cpt inst info failed\");\n\t\treturn -ENOMEM;\n\t}\n\tcpt_req->dlen = info->dlen;\n\n\tresult = info->completion_addr;\n\tresult->s.compcode = OTX2_CPT_COMPLETION_CODE_INIT;\n\n\tspin_lock_bh(&pqueue->lock);\n\tpentry = get_free_pending_entry(pqueue, pqueue->qlen);\n\tretry = CPT_PENTRY_TIMEOUT / CPT_PENTRY_STEP;\n\twhile (unlikely(!pentry) && retry--) {\n\t\tspin_unlock_bh(&pqueue->lock);\n\t\tudelay(CPT_PENTRY_STEP);\n\t\tspin_lock_bh(&pqueue->lock);\n\t\tpentry = get_free_pending_entry(pqueue, pqueue->qlen);\n\t}\n\n\tif (unlikely(!pentry)) {\n\t\tret = -ENOSPC;\n\t\tgoto destroy_info;\n\t}\n\n\t \n\tif (gfp == GFP_KERNEL &&\n\t    pqueue->pending_count > (pqueue->qlen - CPT_IQ_STOP_MARGIN)) {\n\t\tpentry->resume_sender = true;\n\t} else\n\t\tpentry->resume_sender = false;\n\tresume_sender = pentry->resume_sender;\n\tpqueue->pending_count++;\n\n\tpentry->completion_addr = info->completion_addr;\n\tpentry->info = info;\n\tpentry->callback = req->callback;\n\tpentry->areq = req->areq;\n\tpentry->busy = true;\n\tinfo->pentry = pentry;\n\tinfo->time_in = jiffies;\n\tinfo->req = req;\n\n\t \n\tiq_cmd.cmd.u = 0;\n\tiq_cmd.cmd.s.opcode = cpu_to_be16(cpt_req->opcode.flags);\n\tiq_cmd.cmd.s.param1 = cpu_to_be16(cpt_req->param1);\n\tiq_cmd.cmd.s.param2 = cpu_to_be16(cpt_req->param2);\n\tiq_cmd.cmd.s.dlen   = cpu_to_be16(cpt_req->dlen);\n\n\t \n\tcpu_to_be64s(&iq_cmd.cmd.u);\n\tiq_cmd.dptr = info->dptr_baddr;\n\tiq_cmd.rptr = 0;\n\tiq_cmd.cptr.u = 0;\n\tiq_cmd.cptr.s.grp = ctrl->s.grp;\n\n\t \n\totx2_cpt_fill_inst(&cptinst, &iq_cmd, info->comp_baddr);\n\n\t \n\totx2_cpt_dump_sg_list(pdev, req);\n\tpr_debug(\"Cpt_inst_s hexdump (%d bytes)\\n\", OTX2_CPT_INST_SIZE);\n\tprint_hex_dump_debug(\"\", 0, 16, 1, &cptinst, OTX2_CPT_INST_SIZE, false);\n\tpr_debug(\"Dptr hexdump (%d bytes)\\n\", cpt_req->dlen);\n\tprint_hex_dump_debug(\"\", 0, 16, 1, info->in_buffer,\n\t\t\t     cpt_req->dlen, false);\n\n\t \n\tlf->lfs->ops->send_cmd(&cptinst, 1, lf);\n\n\t \n\tspin_unlock_bh(&pqueue->lock);\n\n\tret = resume_sender ? -EBUSY : -EINPROGRESS;\n\treturn ret;\n\ndestroy_info:\n\tspin_unlock_bh(&pqueue->lock);\n\totx2_cpt_info_destroy(pdev, info);\n\treturn ret;\n}\n\nint otx2_cpt_do_request(struct pci_dev *pdev, struct otx2_cpt_req_info *req,\n\t\t\tint cpu_num)\n{\n\tstruct otx2_cptvf_dev *cptvf = pci_get_drvdata(pdev);\n\tstruct otx2_cptlfs_info *lfs = &cptvf->lfs;\n\n\treturn process_request(lfs->pdev, req, &lfs->lf[cpu_num].pqueue,\n\t\t\t       &lfs->lf[cpu_num]);\n}\n\nstatic int cpt_process_ccode(struct otx2_cptlfs_info *lfs,\n\t\t\t     union otx2_cpt_res_s *cpt_status,\n\t\t\t     struct otx2_cpt_inst_info *info,\n\t\t\t     u32 *res_code)\n{\n\tu8 uc_ccode = lfs->ops->cpt_get_uc_compcode(cpt_status);\n\tu8 ccode = lfs->ops->cpt_get_compcode(cpt_status);\n\tstruct pci_dev *pdev = lfs->pdev;\n\n\tswitch (ccode) {\n\tcase OTX2_CPT_COMP_E_FAULT:\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Request failed with DMA fault\\n\");\n\t\totx2_cpt_dump_sg_list(pdev, info->req);\n\t\tbreak;\n\n\tcase OTX2_CPT_COMP_E_HWERR:\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Request failed with hardware error\\n\");\n\t\totx2_cpt_dump_sg_list(pdev, info->req);\n\t\tbreak;\n\n\tcase OTX2_CPT_COMP_E_INSTERR:\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Request failed with instruction error\\n\");\n\t\totx2_cpt_dump_sg_list(pdev, info->req);\n\t\tbreak;\n\n\tcase OTX2_CPT_COMP_E_NOTDONE:\n\t\t \n\t\tif (time_after_eq(jiffies, info->time_in +\n\t\t\t\t  CPT_COMMAND_TIMEOUT * HZ))\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Request timed out 0x%p\", info->req);\n\t\telse if (info->extra_time < CPT_TIME_IN_RESET_COUNT) {\n\t\t\tinfo->time_in = jiffies;\n\t\t\tinfo->extra_time++;\n\t\t}\n\t\treturn 1;\n\n\tcase OTX2_CPT_COMP_E_GOOD:\n\tcase OTX2_CPT_COMP_E_WARN:\n\t\t \n\t\tif (uc_ccode != OTX2_CPT_UCC_SUCCESS) {\n\t\t\t \n\t\t\tif (info->req->is_trunc_hmac &&\n\t\t\t    uc_ccode == OTX2_CPT_UCC_SG_WRITE_LENGTH) {\n\t\t\t\t*res_code = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Request failed with software error code 0x%x\\n\",\n\t\t\t\tcpt_status->s.uc_compcode);\n\t\t\totx2_cpt_dump_sg_list(pdev, info->req);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\t*res_code = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Request returned invalid status %d\\n\", ccode);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic inline void process_pending_queue(struct otx2_cptlfs_info *lfs,\n\t\t\t\t\t struct otx2_cpt_pending_queue *pqueue)\n{\n\tstruct otx2_cpt_pending_entry *resume_pentry = NULL;\n\tvoid (*callback)(int status, void *arg, void *req);\n\tstruct otx2_cpt_pending_entry *pentry = NULL;\n\tunion otx2_cpt_res_s *cpt_status = NULL;\n\tstruct otx2_cpt_inst_info *info = NULL;\n\tstruct otx2_cpt_req_info *req = NULL;\n\tstruct crypto_async_request *areq;\n\tstruct pci_dev *pdev = lfs->pdev;\n\tu32 res_code, resume_index;\n\n\twhile (1) {\n\t\tspin_lock_bh(&pqueue->lock);\n\t\tpentry = &pqueue->head[pqueue->front];\n\n\t\tif (WARN_ON(!pentry)) {\n\t\t\tspin_unlock_bh(&pqueue->lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tres_code = -EINVAL;\n\t\tif (unlikely(!pentry->busy)) {\n\t\t\tspin_unlock_bh(&pqueue->lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(!pentry->callback)) {\n\t\t\tdev_err(&pdev->dev, \"Callback NULL\\n\");\n\t\t\tgoto process_pentry;\n\t\t}\n\n\t\tinfo = pentry->info;\n\t\tif (unlikely(!info)) {\n\t\t\tdev_err(&pdev->dev, \"Pending entry post arg NULL\\n\");\n\t\t\tgoto process_pentry;\n\t\t}\n\n\t\treq = info->req;\n\t\tif (unlikely(!req)) {\n\t\t\tdev_err(&pdev->dev, \"Request NULL\\n\");\n\t\t\tgoto process_pentry;\n\t\t}\n\n\t\tcpt_status = pentry->completion_addr;\n\t\tif (unlikely(!cpt_status)) {\n\t\t\tdev_err(&pdev->dev, \"Completion address NULL\\n\");\n\t\t\tgoto process_pentry;\n\t\t}\n\n\t\tif (cpt_process_ccode(lfs, cpt_status, info, &res_code)) {\n\t\t\tspin_unlock_bh(&pqueue->lock);\n\t\t\treturn;\n\t\t}\n\t\tinfo->pdev = pdev;\n\nprocess_pentry:\n\t\t \n\t\tresume_index = modulo_inc(pqueue->front, pqueue->qlen,\n\t\t\t\t\t  CPT_IQ_RESUME_MARGIN);\n\t\tresume_pentry = &pqueue->head[resume_index];\n\t\tif (resume_pentry &&\n\t\t    resume_pentry->resume_sender) {\n\t\t\tresume_pentry->resume_sender = false;\n\t\t\tcallback = resume_pentry->callback;\n\t\t\tareq = resume_pentry->areq;\n\n\t\t\tif (callback) {\n\t\t\t\tspin_unlock_bh(&pqueue->lock);\n\n\t\t\t\t \n\t\t\t\tcallback(-EINPROGRESS, areq, info);\n\t\t\t\tspin_lock_bh(&pqueue->lock);\n\t\t\t}\n\t\t}\n\n\t\tcallback = pentry->callback;\n\t\tareq = pentry->areq;\n\t\tfree_pentry(pentry);\n\n\t\tpqueue->pending_count--;\n\t\tpqueue->front = modulo_inc(pqueue->front, pqueue->qlen, 1);\n\t\tspin_unlock_bh(&pqueue->lock);\n\n\t\t \n\t\tif (callback)\n\t\t\tcallback(res_code, areq, info);\n\t}\n}\n\nvoid otx2_cpt_post_process(struct otx2_cptlf_wqe *wqe)\n{\n\tprocess_pending_queue(wqe->lfs,\n\t\t\t      &wqe->lfs->lf[wqe->lf_num].pqueue);\n}\n\nint otx2_cpt_get_kcrypto_eng_grp_num(struct pci_dev *pdev)\n{\n\tstruct otx2_cptvf_dev *cptvf = pci_get_drvdata(pdev);\n\n\treturn cptvf->lfs.kcrypto_eng_grp_num;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}