{
  "module_name": "otx2_cptpf_ucode.c",
  "hash_id": "28b83127ee2a064a970b3dcdbd14311626da832bd85267b5fac1244ea4e34f22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/octeontx2/otx2_cptpf_ucode.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/firmware.h>\n#include \"otx2_cptpf_ucode.h\"\n#include \"otx2_cpt_common.h\"\n#include \"otx2_cptpf.h\"\n#include \"otx2_cptlf.h\"\n#include \"otx2_cpt_reqmgr.h\"\n#include \"rvu_reg.h\"\n\n#define CSR_DELAY 30\n\n#define LOADFVC_RLEN 8\n#define LOADFVC_MAJOR_OP 0x01\n#define LOADFVC_MINOR_OP 0x08\n\n#define CTX_FLUSH_TIMER_CNT 0xFFFFFF\n\nstruct fw_info_t {\n\tstruct list_head ucodes;\n};\n\nstatic struct otx2_cpt_bitmap get_cores_bmap(struct device *dev,\n\t\t\t\t\tstruct otx2_cpt_eng_grp_info *eng_grp)\n{\n\tstruct otx2_cpt_bitmap bmap = { {0} };\n\tbool found = false;\n\tint i;\n\n\tif (eng_grp->g->engs_num < 0 ||\n\t    eng_grp->g->engs_num > OTX2_CPT_MAX_ENGINES) {\n\t\tdev_err(dev, \"unsupported number of engines %d on octeontx2\\n\",\n\t\t\teng_grp->g->engs_num);\n\t\treturn bmap;\n\t}\n\n\tfor (i = 0; i  < OTX2_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tif (eng_grp->engs[i].type) {\n\t\t\tbitmap_or(bmap.bits, bmap.bits,\n\t\t\t\t  eng_grp->engs[i].bmap,\n\t\t\t\t  eng_grp->g->engs_num);\n\t\t\tbmap.size = eng_grp->g->engs_num;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tdev_err(dev, \"No engines reserved for engine group %d\\n\",\n\t\t\teng_grp->idx);\n\treturn bmap;\n}\n\nstatic int is_eng_type(int val, int eng_type)\n{\n\treturn val & (1 << eng_type);\n}\n\nstatic int is_2nd_ucode_used(struct otx2_cpt_eng_grp_info *eng_grp)\n{\n\tif (eng_grp->ucode[1].type)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void set_ucode_filename(struct otx2_cpt_ucode *ucode,\n\t\t\t       const char *filename)\n{\n\tstrscpy(ucode->filename, filename, OTX2_CPT_NAME_LENGTH);\n}\n\nstatic char *get_eng_type_str(int eng_type)\n{\n\tchar *str = \"unknown\";\n\n\tswitch (eng_type) {\n\tcase OTX2_CPT_SE_TYPES:\n\t\tstr = \"SE\";\n\t\tbreak;\n\n\tcase OTX2_CPT_IE_TYPES:\n\t\tstr = \"IE\";\n\t\tbreak;\n\n\tcase OTX2_CPT_AE_TYPES:\n\t\tstr = \"AE\";\n\t\tbreak;\n\t}\n\treturn str;\n}\n\nstatic char *get_ucode_type_str(int ucode_type)\n{\n\tchar *str = \"unknown\";\n\n\tswitch (ucode_type) {\n\tcase (1 << OTX2_CPT_SE_TYPES):\n\t\tstr = \"SE\";\n\t\tbreak;\n\n\tcase (1 << OTX2_CPT_IE_TYPES):\n\t\tstr = \"IE\";\n\t\tbreak;\n\n\tcase (1 << OTX2_CPT_AE_TYPES):\n\t\tstr = \"AE\";\n\t\tbreak;\n\n\tcase (1 << OTX2_CPT_SE_TYPES | 1 << OTX2_CPT_IE_TYPES):\n\t\tstr = \"SE+IPSEC\";\n\t\tbreak;\n\t}\n\treturn str;\n}\n\nstatic int get_ucode_type(struct device *dev,\n\t\t\t  struct otx2_cpt_ucode_hdr *ucode_hdr,\n\t\t\t  int *ucode_type)\n{\n\tstruct otx2_cptpf_dev *cptpf = dev_get_drvdata(dev);\n\tchar ver_str_prefix[OTX2_CPT_UCODE_VER_STR_SZ];\n\tchar tmp_ver_str[OTX2_CPT_UCODE_VER_STR_SZ];\n\tstruct pci_dev *pdev = cptpf->pdev;\n\tint i, val = 0;\n\tu8 nn;\n\n\tstrscpy(tmp_ver_str, ucode_hdr->ver_str, OTX2_CPT_UCODE_VER_STR_SZ);\n\tfor (i = 0; i < strlen(tmp_ver_str); i++)\n\t\ttmp_ver_str[i] = tolower(tmp_ver_str[i]);\n\n\tsprintf(ver_str_prefix, \"ocpt-%02d\", pdev->revision);\n\tif (!strnstr(tmp_ver_str, ver_str_prefix, OTX2_CPT_UCODE_VER_STR_SZ))\n\t\treturn -EINVAL;\n\n\tnn = ucode_hdr->ver_num.nn;\n\tif (strnstr(tmp_ver_str, \"se-\", OTX2_CPT_UCODE_VER_STR_SZ) &&\n\t    (nn == OTX2_CPT_SE_UC_TYPE1 || nn == OTX2_CPT_SE_UC_TYPE2 ||\n\t     nn == OTX2_CPT_SE_UC_TYPE3))\n\t\tval |= 1 << OTX2_CPT_SE_TYPES;\n\tif (strnstr(tmp_ver_str, \"ie-\", OTX2_CPT_UCODE_VER_STR_SZ) &&\n\t    (nn == OTX2_CPT_IE_UC_TYPE1 || nn == OTX2_CPT_IE_UC_TYPE2 ||\n\t     nn == OTX2_CPT_IE_UC_TYPE3))\n\t\tval |= 1 << OTX2_CPT_IE_TYPES;\n\tif (strnstr(tmp_ver_str, \"ae\", OTX2_CPT_UCODE_VER_STR_SZ) &&\n\t    nn == OTX2_CPT_AE_UC_TYPE)\n\t\tval |= 1 << OTX2_CPT_AE_TYPES;\n\n\t*ucode_type = val;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __write_ucode_base(struct otx2_cptpf_dev *cptpf, int eng,\n\t\t\t      dma_addr_t dma_addr, int blkaddr)\n{\n\treturn otx2_cpt_write_af_reg(&cptpf->afpf_mbox, cptpf->pdev,\n\t\t\t\t     CPT_AF_EXEX_UCODE_BASE(eng),\n\t\t\t\t     (u64)dma_addr, blkaddr);\n}\n\nstatic int cptx_set_ucode_base(struct otx2_cpt_eng_grp_info *eng_grp,\n\t\t\t       struct otx2_cptpf_dev *cptpf, int blkaddr)\n{\n\tstruct otx2_cpt_engs_rsvd *engs;\n\tdma_addr_t dma_addr;\n\tint i, bit, ret;\n\n\t \n\tret = otx2_cpt_write_af_reg(&cptpf->afpf_mbox, cptpf->pdev,\n\t\t\t\t    CPT_AF_PF_FUNC,\n\t\t\t\t    cptpf->pf_id << RVU_PFVF_PF_SHIFT, blkaddr);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < OTX2_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tengs = &eng_grp->engs[i];\n\t\tif (!engs->type)\n\t\t\tcontinue;\n\n\t\tdma_addr = engs->ucode->dma;\n\n\t\t \n\t\tfor_each_set_bit(bit, engs->bmap, eng_grp->g->engs_num)\n\t\t\tif (!eng_grp->g->eng_ref_cnt[bit]) {\n\t\t\t\tret = __write_ucode_base(cptpf, bit, dma_addr,\n\t\t\t\t\t\t\t blkaddr);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int cpt_set_ucode_base(struct otx2_cpt_eng_grp_info *eng_grp, void *obj)\n{\n\tstruct otx2_cptpf_dev *cptpf = obj;\n\tint ret;\n\n\tif (cptpf->has_cpt1) {\n\t\tret = cptx_set_ucode_base(eng_grp, cptpf, BLKADDR_CPT1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn cptx_set_ucode_base(eng_grp, cptpf, BLKADDR_CPT0);\n}\n\nstatic int cptx_detach_and_disable_cores(struct otx2_cpt_eng_grp_info *eng_grp,\n\t\t\t\t\t struct otx2_cptpf_dev *cptpf,\n\t\t\t\t\t struct otx2_cpt_bitmap bmap,\n\t\t\t\t\t int blkaddr)\n{\n\tint i, timeout = 10;\n\tint busy, ret;\n\tu64 reg = 0;\n\n\t \n\tfor_each_set_bit(i, bmap.bits, bmap.size) {\n\t\tret = otx2_cpt_read_af_reg(&cptpf->afpf_mbox, cptpf->pdev,\n\t\t\t\t\t   CPT_AF_EXEX_CTL2(i), &reg, blkaddr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (reg & (1ull << eng_grp->idx)) {\n\t\t\teng_grp->g->eng_ref_cnt[i]--;\n\t\t\treg &= ~(1ull << eng_grp->idx);\n\n\t\t\tret = otx2_cpt_write_af_reg(&cptpf->afpf_mbox,\n\t\t\t\t\t\t    cptpf->pdev,\n\t\t\t\t\t\t    CPT_AF_EXEX_CTL2(i), reg,\n\t\t\t\t\t\t    blkaddr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tdo {\n\t\tbusy = 0;\n\t\tusleep_range(10000, 20000);\n\t\tif (timeout-- < 0)\n\t\t\treturn -EBUSY;\n\n\t\tfor_each_set_bit(i, bmap.bits, bmap.size) {\n\t\t\tret = otx2_cpt_read_af_reg(&cptpf->afpf_mbox,\n\t\t\t\t\t\t   cptpf->pdev,\n\t\t\t\t\t\t   CPT_AF_EXEX_STS(i), &reg,\n\t\t\t\t\t\t   blkaddr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (reg & 0x1) {\n\t\t\t\tbusy = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (busy);\n\n\t \n\tfor_each_set_bit(i, bmap.bits, bmap.size) {\n\t\tif (!eng_grp->g->eng_ref_cnt[i]) {\n\t\t\tret = otx2_cpt_write_af_reg(&cptpf->afpf_mbox,\n\t\t\t\t\t\t    cptpf->pdev,\n\t\t\t\t\t\t    CPT_AF_EXEX_CTL(i), 0x0,\n\t\t\t\t\t\t    blkaddr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cpt_detach_and_disable_cores(struct otx2_cpt_eng_grp_info *eng_grp,\n\t\t\t\t\tvoid *obj)\n{\n\tstruct otx2_cptpf_dev *cptpf = obj;\n\tstruct otx2_cpt_bitmap bmap;\n\tint ret;\n\n\tbmap = get_cores_bmap(&cptpf->pdev->dev, eng_grp);\n\tif (!bmap.size)\n\t\treturn -EINVAL;\n\n\tif (cptpf->has_cpt1) {\n\t\tret = cptx_detach_and_disable_cores(eng_grp, cptpf, bmap,\n\t\t\t\t\t\t    BLKADDR_CPT1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn cptx_detach_and_disable_cores(eng_grp, cptpf, bmap,\n\t\t\t\t\t     BLKADDR_CPT0);\n}\n\nstatic int cptx_attach_and_enable_cores(struct otx2_cpt_eng_grp_info *eng_grp,\n\t\t\t\t\tstruct otx2_cptpf_dev *cptpf,\n\t\t\t\t\tstruct otx2_cpt_bitmap bmap,\n\t\t\t\t\tint blkaddr)\n{\n\tu64 reg = 0;\n\tint i, ret;\n\n\t \n\tfor_each_set_bit(i, bmap.bits, bmap.size) {\n\t\tret = otx2_cpt_read_af_reg(&cptpf->afpf_mbox, cptpf->pdev,\n\t\t\t\t\t   CPT_AF_EXEX_CTL2(i), &reg, blkaddr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!(reg & (1ull << eng_grp->idx))) {\n\t\t\teng_grp->g->eng_ref_cnt[i]++;\n\t\t\treg |= 1ull << eng_grp->idx;\n\n\t\t\tret = otx2_cpt_write_af_reg(&cptpf->afpf_mbox,\n\t\t\t\t\t\t    cptpf->pdev,\n\t\t\t\t\t\t    CPT_AF_EXEX_CTL2(i), reg,\n\t\t\t\t\t\t    blkaddr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tfor_each_set_bit(i, bmap.bits, bmap.size) {\n\t\tret = otx2_cpt_add_write_af_reg(&cptpf->afpf_mbox, cptpf->pdev,\n\t\t\t\t\t\tCPT_AF_EXEX_CTL(i), 0x1,\n\t\t\t\t\t\tblkaddr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn otx2_cpt_send_af_reg_requests(&cptpf->afpf_mbox, cptpf->pdev);\n}\n\nstatic int cpt_attach_and_enable_cores(struct otx2_cpt_eng_grp_info *eng_grp,\n\t\t\t\t       void *obj)\n{\n\tstruct otx2_cptpf_dev *cptpf = obj;\n\tstruct otx2_cpt_bitmap bmap;\n\tint ret;\n\n\tbmap = get_cores_bmap(&cptpf->pdev->dev, eng_grp);\n\tif (!bmap.size)\n\t\treturn -EINVAL;\n\n\tif (cptpf->has_cpt1) {\n\t\tret = cptx_attach_and_enable_cores(eng_grp, cptpf, bmap,\n\t\t\t\t\t\t   BLKADDR_CPT1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn cptx_attach_and_enable_cores(eng_grp, cptpf, bmap, BLKADDR_CPT0);\n}\n\nstatic int load_fw(struct device *dev, struct fw_info_t *fw_info,\n\t\t   char *filename)\n{\n\tstruct otx2_cpt_ucode_hdr *ucode_hdr;\n\tstruct otx2_cpt_uc_info_t *uc_info;\n\tint ucode_type, ucode_size;\n\tint ret;\n\n\tuc_info = kzalloc(sizeof(*uc_info), GFP_KERNEL);\n\tif (!uc_info)\n\t\treturn -ENOMEM;\n\n\tret = request_firmware(&uc_info->fw, filename, dev);\n\tif (ret)\n\t\tgoto free_uc_info;\n\n\tucode_hdr = (struct otx2_cpt_ucode_hdr *)uc_info->fw->data;\n\tret = get_ucode_type(dev, ucode_hdr, &ucode_type);\n\tif (ret)\n\t\tgoto release_fw;\n\n\tucode_size = ntohl(ucode_hdr->code_length) * 2;\n\tif (!ucode_size) {\n\t\tdev_err(dev, \"Ucode %s invalid size\\n\", filename);\n\t\tret = -EINVAL;\n\t\tgoto release_fw;\n\t}\n\n\tset_ucode_filename(&uc_info->ucode, filename);\n\tmemcpy(uc_info->ucode.ver_str, ucode_hdr->ver_str,\n\t       OTX2_CPT_UCODE_VER_STR_SZ);\n\tuc_info->ucode.ver_num = ucode_hdr->ver_num;\n\tuc_info->ucode.type = ucode_type;\n\tuc_info->ucode.size = ucode_size;\n\tlist_add_tail(&uc_info->list, &fw_info->ucodes);\n\n\treturn 0;\n\nrelease_fw:\n\trelease_firmware(uc_info->fw);\nfree_uc_info:\n\tkfree(uc_info);\n\treturn ret;\n}\n\nstatic void cpt_ucode_release_fw(struct fw_info_t *fw_info)\n{\n\tstruct otx2_cpt_uc_info_t *curr, *temp;\n\n\tif (!fw_info)\n\t\treturn;\n\n\tlist_for_each_entry_safe(curr, temp, &fw_info->ucodes, list) {\n\t\tlist_del(&curr->list);\n\t\trelease_firmware(curr->fw);\n\t\tkfree(curr);\n\t}\n}\n\nstatic struct otx2_cpt_uc_info_t *get_ucode(struct fw_info_t *fw_info,\n\t\t\t\t\t    int ucode_type)\n{\n\tstruct otx2_cpt_uc_info_t *curr;\n\n\tlist_for_each_entry(curr, &fw_info->ucodes, list) {\n\t\tif (!is_eng_type(curr->ucode.type, ucode_type))\n\t\t\tcontinue;\n\n\t\treturn curr;\n\t}\n\treturn NULL;\n}\n\nstatic void print_uc_info(struct fw_info_t *fw_info)\n{\n\tstruct otx2_cpt_uc_info_t *curr;\n\n\tlist_for_each_entry(curr, &fw_info->ucodes, list) {\n\t\tpr_debug(\"Ucode filename %s\\n\", curr->ucode.filename);\n\t\tpr_debug(\"Ucode version string %s\\n\", curr->ucode.ver_str);\n\t\tpr_debug(\"Ucode version %d.%d.%d.%d\\n\",\n\t\t\t curr->ucode.ver_num.nn, curr->ucode.ver_num.xx,\n\t\t\t curr->ucode.ver_num.yy, curr->ucode.ver_num.zz);\n\t\tpr_debug(\"Ucode type (%d) %s\\n\", curr->ucode.type,\n\t\t\t get_ucode_type_str(curr->ucode.type));\n\t\tpr_debug(\"Ucode size %d\\n\", curr->ucode.size);\n\t\tpr_debug(\"Ucode ptr %p\\n\", curr->fw->data);\n\t}\n}\n\nstatic int cpt_ucode_load_fw(struct pci_dev *pdev, struct fw_info_t *fw_info)\n{\n\tchar filename[OTX2_CPT_NAME_LENGTH];\n\tchar eng_type[8] = {0};\n\tint ret, e, i;\n\n\tINIT_LIST_HEAD(&fw_info->ucodes);\n\n\tfor (e = 1; e < OTX2_CPT_MAX_ENG_TYPES; e++) {\n\t\tstrcpy(eng_type, get_eng_type_str(e));\n\t\tfor (i = 0; i < strlen(eng_type); i++)\n\t\t\teng_type[i] = tolower(eng_type[i]);\n\n\t\tsnprintf(filename, sizeof(filename), \"mrvl/cpt%02d/%s.out\",\n\t\t\t pdev->revision, eng_type);\n\t\t \n\t\tret = load_fw(&pdev->dev, fw_info, filename);\n\t\tif (ret)\n\t\t\tgoto release_fw;\n\t}\n\tprint_uc_info(fw_info);\n\treturn 0;\n\nrelease_fw:\n\tcpt_ucode_release_fw(fw_info);\n\treturn ret;\n}\n\nstruct otx2_cpt_engs_rsvd *find_engines_by_type(\n\t\t\t\t\tstruct otx2_cpt_eng_grp_info *eng_grp,\n\t\t\t\t\tint eng_type)\n{\n\tint i;\n\n\tfor (i = 0; i < OTX2_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tif (!eng_grp->engs[i].type)\n\t\t\tcontinue;\n\n\t\tif (eng_grp->engs[i].type == eng_type)\n\t\t\treturn &eng_grp->engs[i];\n\t}\n\treturn NULL;\n}\n\nstatic int eng_grp_has_eng_type(struct otx2_cpt_eng_grp_info *eng_grp,\n\t\t\t\tint eng_type)\n{\n\tstruct otx2_cpt_engs_rsvd *engs;\n\n\tengs = find_engines_by_type(eng_grp, eng_type);\n\n\treturn (engs != NULL ? 1 : 0);\n}\n\nstatic int update_engines_avail_count(struct device *dev,\n\t\t\t\t      struct otx2_cpt_engs_available *avail,\n\t\t\t\t      struct otx2_cpt_engs_rsvd *engs, int val)\n{\n\tswitch (engs->type) {\n\tcase OTX2_CPT_SE_TYPES:\n\t\tavail->se_cnt += val;\n\t\tbreak;\n\n\tcase OTX2_CPT_IE_TYPES:\n\t\tavail->ie_cnt += val;\n\t\tbreak;\n\n\tcase OTX2_CPT_AE_TYPES:\n\t\tavail->ae_cnt += val;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid engine type %d\\n\", engs->type);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int update_engines_offset(struct device *dev,\n\t\t\t\t struct otx2_cpt_engs_available *avail,\n\t\t\t\t struct otx2_cpt_engs_rsvd *engs)\n{\n\tswitch (engs->type) {\n\tcase OTX2_CPT_SE_TYPES:\n\t\tengs->offset = 0;\n\t\tbreak;\n\n\tcase OTX2_CPT_IE_TYPES:\n\t\tengs->offset = avail->max_se_cnt;\n\t\tbreak;\n\n\tcase OTX2_CPT_AE_TYPES:\n\t\tengs->offset = avail->max_se_cnt + avail->max_ie_cnt;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid engine type %d\\n\", engs->type);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int release_engines(struct device *dev,\n\t\t\t   struct otx2_cpt_eng_grp_info *grp)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < OTX2_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tif (!grp->engs[i].type)\n\t\t\tcontinue;\n\n\t\tif (grp->engs[i].count > 0) {\n\t\t\tret = update_engines_avail_count(dev, &grp->g->avail,\n\t\t\t\t\t\t\t &grp->engs[i],\n\t\t\t\t\t\t\t grp->engs[i].count);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tgrp->engs[i].type = 0;\n\t\tgrp->engs[i].count = 0;\n\t\tgrp->engs[i].offset = 0;\n\t\tgrp->engs[i].ucode = NULL;\n\t\tbitmap_zero(grp->engs[i].bmap, grp->g->engs_num);\n\t}\n\treturn 0;\n}\n\nstatic int do_reserve_engines(struct device *dev,\n\t\t\t      struct otx2_cpt_eng_grp_info *grp,\n\t\t\t      struct otx2_cpt_engines *req_engs)\n{\n\tstruct otx2_cpt_engs_rsvd *engs = NULL;\n\tint i, ret;\n\n\tfor (i = 0; i < OTX2_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tif (!grp->engs[i].type) {\n\t\t\tengs = &grp->engs[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!engs)\n\t\treturn -ENOMEM;\n\n\tengs->type = req_engs->type;\n\tengs->count = req_engs->count;\n\n\tret = update_engines_offset(dev, &grp->g->avail, engs);\n\tif (ret)\n\t\treturn ret;\n\n\tif (engs->count > 0) {\n\t\tret = update_engines_avail_count(dev, &grp->g->avail, engs,\n\t\t\t\t\t\t -engs->count);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_engines_availability(struct device *dev,\n\t\t\t\t      struct otx2_cpt_eng_grp_info *grp,\n\t\t\t\t      struct otx2_cpt_engines *req_eng)\n{\n\tint avail_cnt = 0;\n\n\tswitch (req_eng->type) {\n\tcase OTX2_CPT_SE_TYPES:\n\t\tavail_cnt = grp->g->avail.se_cnt;\n\t\tbreak;\n\n\tcase OTX2_CPT_IE_TYPES:\n\t\tavail_cnt = grp->g->avail.ie_cnt;\n\t\tbreak;\n\n\tcase OTX2_CPT_AE_TYPES:\n\t\tavail_cnt = grp->g->avail.ae_cnt;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid engine type %d\\n\", req_eng->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (avail_cnt < req_eng->count) {\n\t\tdev_err(dev,\n\t\t\t\"Error available %s engines %d < than requested %d\\n\",\n\t\t\tget_eng_type_str(req_eng->type),\n\t\t\tavail_cnt, req_eng->count);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int reserve_engines(struct device *dev,\n\t\t\t   struct otx2_cpt_eng_grp_info *grp,\n\t\t\t   struct otx2_cpt_engines *req_engs, int ucodes_cnt)\n{\n\tint i, ret = 0;\n\n\t \n\tfor (i = 0; i < ucodes_cnt; i++) {\n\t\tret = check_engines_availability(dev, grp, &req_engs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < ucodes_cnt; i++) {\n\t\tret = do_reserve_engines(dev, grp, &req_engs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void ucode_unload(struct device *dev, struct otx2_cpt_ucode *ucode)\n{\n\tif (ucode->va) {\n\t\tdma_free_coherent(dev, OTX2_CPT_UCODE_SZ, ucode->va,\n\t\t\t\t  ucode->dma);\n\t\tucode->va = NULL;\n\t\tucode->dma = 0;\n\t\tucode->size = 0;\n\t}\n\n\tmemset(&ucode->ver_str, 0, OTX2_CPT_UCODE_VER_STR_SZ);\n\tmemset(&ucode->ver_num, 0, sizeof(struct otx2_cpt_ucode_ver_num));\n\tset_ucode_filename(ucode, \"\");\n\tucode->type = 0;\n}\n\nstatic int copy_ucode_to_dma_mem(struct device *dev,\n\t\t\t\t struct otx2_cpt_ucode *ucode,\n\t\t\t\t const u8 *ucode_data)\n{\n\tu32 i;\n\n\t \n\tucode->va = dma_alloc_coherent(dev, OTX2_CPT_UCODE_SZ, &ucode->dma,\n\t\t\t\t       GFP_KERNEL);\n\tif (!ucode->va)\n\t\treturn -ENOMEM;\n\n\tmemcpy(ucode->va, ucode_data + sizeof(struct otx2_cpt_ucode_hdr),\n\t       ucode->size);\n\n\t \n\tfor (i = 0; i < (ucode->size / 8); i++)\n\t\tcpu_to_be64s(&((u64 *)ucode->va)[i]);\n\t \n\tfor (i = 0; i < (ucode->size / 2); i++)\n\t\tcpu_to_be16s(&((u16 *)ucode->va)[i]);\n\treturn 0;\n}\n\nstatic int enable_eng_grp(struct otx2_cpt_eng_grp_info *eng_grp,\n\t\t\t  void *obj)\n{\n\tint ret;\n\n\t \n\tret = cpt_set_ucode_base(eng_grp, obj);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = cpt_attach_and_enable_cores(eng_grp, obj);\n\n\treturn ret;\n}\n\nstatic int disable_eng_grp(struct device *dev,\n\t\t\t   struct otx2_cpt_eng_grp_info *eng_grp,\n\t\t\t   void *obj)\n{\n\tint i, ret;\n\n\t \n\tret = cpt_detach_and_disable_cores(eng_grp, obj);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tucode_unload(dev, &eng_grp->ucode[0]);\n\tucode_unload(dev, &eng_grp->ucode[1]);\n\n\tfor (i = 0; i < OTX2_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tif (!eng_grp->engs[i].type)\n\t\t\tcontinue;\n\n\t\teng_grp->engs[i].ucode = &eng_grp->ucode[0];\n\t}\n\n\t \n\tret = cpt_set_ucode_base(eng_grp, obj);\n\n\treturn ret;\n}\n\nstatic void setup_eng_grp_mirroring(struct otx2_cpt_eng_grp_info *dst_grp,\n\t\t\t\t    struct otx2_cpt_eng_grp_info *src_grp)\n{\n\t \n\tsrc_grp->mirror.is_ena = false;\n\tsrc_grp->mirror.idx = 0;\n\tsrc_grp->mirror.ref_count++;\n\n\t \n\tdst_grp->mirror.is_ena = true;\n\tdst_grp->mirror.idx = src_grp->idx;\n\tdst_grp->mirror.ref_count = 0;\n}\n\nstatic void remove_eng_grp_mirroring(struct otx2_cpt_eng_grp_info *dst_grp)\n{\n\tstruct otx2_cpt_eng_grp_info *src_grp;\n\n\tif (!dst_grp->mirror.is_ena)\n\t\treturn;\n\n\tsrc_grp = &dst_grp->g->grp[dst_grp->mirror.idx];\n\n\tsrc_grp->mirror.ref_count--;\n\tdst_grp->mirror.is_ena = false;\n\tdst_grp->mirror.idx = 0;\n\tdst_grp->mirror.ref_count = 0;\n}\n\nstatic void update_requested_engs(struct otx2_cpt_eng_grp_info *mirror_eng_grp,\n\t\t\t\t  struct otx2_cpt_engines *engs, int engs_cnt)\n{\n\tstruct otx2_cpt_engs_rsvd *mirrored_engs;\n\tint i;\n\n\tfor (i = 0; i < engs_cnt; i++) {\n\t\tmirrored_engs = find_engines_by_type(mirror_eng_grp,\n\t\t\t\t\t\t     engs[i].type);\n\t\tif (!mirrored_engs)\n\t\t\tcontinue;\n\n\t\t \n\t\tengs[i].count -= mirrored_engs->count;\n\t}\n}\n\nstatic struct otx2_cpt_eng_grp_info *find_mirrored_eng_grp(\n\t\t\t\t\tstruct otx2_cpt_eng_grp_info *grp)\n{\n\tstruct otx2_cpt_eng_grps *eng_grps = grp->g;\n\tint i;\n\n\tfor (i = 0; i < OTX2_CPT_MAX_ENGINE_GROUPS; i++) {\n\t\tif (!eng_grps->grp[i].is_enabled)\n\t\t\tcontinue;\n\t\tif (eng_grps->grp[i].ucode[0].type &&\n\t\t    eng_grps->grp[i].ucode[1].type)\n\t\t\tcontinue;\n\t\tif (grp->idx == i)\n\t\t\tcontinue;\n\t\tif (!strncasecmp(eng_grps->grp[i].ucode[0].ver_str,\n\t\t\t\t grp->ucode[0].ver_str,\n\t\t\t\t OTX2_CPT_UCODE_VER_STR_SZ))\n\t\t\treturn &eng_grps->grp[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic struct otx2_cpt_eng_grp_info *find_unused_eng_grp(\n\t\t\t\t\tstruct otx2_cpt_eng_grps *eng_grps)\n{\n\tint i;\n\n\tfor (i = 0; i < OTX2_CPT_MAX_ENGINE_GROUPS; i++) {\n\t\tif (!eng_grps->grp[i].is_enabled)\n\t\t\treturn &eng_grps->grp[i];\n\t}\n\treturn NULL;\n}\n\nstatic int eng_grp_update_masks(struct device *dev,\n\t\t\t\tstruct otx2_cpt_eng_grp_info *eng_grp)\n{\n\tstruct otx2_cpt_engs_rsvd *engs, *mirrored_engs;\n\tstruct otx2_cpt_bitmap tmp_bmap = { {0} };\n\tint i, j, cnt, max_cnt;\n\tint bit;\n\n\tfor (i = 0; i < OTX2_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tengs = &eng_grp->engs[i];\n\t\tif (!engs->type)\n\t\t\tcontinue;\n\t\tif (engs->count <= 0)\n\t\t\tcontinue;\n\n\t\tswitch (engs->type) {\n\t\tcase OTX2_CPT_SE_TYPES:\n\t\t\tmax_cnt = eng_grp->g->avail.max_se_cnt;\n\t\t\tbreak;\n\n\t\tcase OTX2_CPT_IE_TYPES:\n\t\t\tmax_cnt = eng_grp->g->avail.max_ie_cnt;\n\t\t\tbreak;\n\n\t\tcase OTX2_CPT_AE_TYPES:\n\t\t\tmax_cnt = eng_grp->g->avail.max_ae_cnt;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(dev, \"Invalid engine type %d\\n\", engs->type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcnt = engs->count;\n\t\tWARN_ON(engs->offset + max_cnt > OTX2_CPT_MAX_ENGINES);\n\t\tbitmap_zero(tmp_bmap.bits, eng_grp->g->engs_num);\n\t\tfor (j = engs->offset; j < engs->offset + max_cnt; j++) {\n\t\t\tif (!eng_grp->g->eng_ref_cnt[j]) {\n\t\t\t\tbitmap_set(tmp_bmap.bits, j, 1);\n\t\t\t\tcnt--;\n\t\t\t\tif (!cnt)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cnt)\n\t\t\treturn -ENOSPC;\n\n\t\tbitmap_copy(engs->bmap, tmp_bmap.bits, eng_grp->g->engs_num);\n\t}\n\n\tif (!eng_grp->mirror.is_ena)\n\t\treturn 0;\n\n\tfor (i = 0; i < OTX2_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tengs = &eng_grp->engs[i];\n\t\tif (!engs->type)\n\t\t\tcontinue;\n\n\t\tmirrored_engs = find_engines_by_type(\n\t\t\t\t\t&eng_grp->g->grp[eng_grp->mirror.idx],\n\t\t\t\t\tengs->type);\n\t\tWARN_ON(!mirrored_engs && engs->count <= 0);\n\t\tif (!mirrored_engs)\n\t\t\tcontinue;\n\n\t\tbitmap_copy(tmp_bmap.bits, mirrored_engs->bmap,\n\t\t\t    eng_grp->g->engs_num);\n\t\tif (engs->count < 0) {\n\t\t\tbit = find_first_bit(mirrored_engs->bmap,\n\t\t\t\t\t     eng_grp->g->engs_num);\n\t\t\tbitmap_clear(tmp_bmap.bits, bit, -engs->count);\n\t\t}\n\t\tbitmap_or(engs->bmap, engs->bmap, tmp_bmap.bits,\n\t\t\t  eng_grp->g->engs_num);\n\t}\n\treturn 0;\n}\n\nstatic int delete_engine_group(struct device *dev,\n\t\t\t       struct otx2_cpt_eng_grp_info *eng_grp)\n{\n\tint ret;\n\n\tif (!eng_grp->is_enabled)\n\t\treturn 0;\n\n\tif (eng_grp->mirror.ref_count)\n\t\treturn -EINVAL;\n\n\t \n\tremove_eng_grp_mirroring(eng_grp);\n\n\t \n\tret = disable_eng_grp(dev, eng_grp, eng_grp->g->obj);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = release_engines(dev, eng_grp);\n\tif (ret)\n\t\treturn ret;\n\n\teng_grp->is_enabled = false;\n\n\treturn 0;\n}\n\nstatic void update_ucode_ptrs(struct otx2_cpt_eng_grp_info *eng_grp)\n{\n\tstruct otx2_cpt_ucode *ucode;\n\n\tif (eng_grp->mirror.is_ena)\n\t\tucode = &eng_grp->g->grp[eng_grp->mirror.idx].ucode[0];\n\telse\n\t\tucode = &eng_grp->ucode[0];\n\tWARN_ON(!eng_grp->engs[0].type);\n\teng_grp->engs[0].ucode = ucode;\n\n\tif (eng_grp->engs[1].type) {\n\t\tif (is_2nd_ucode_used(eng_grp))\n\t\t\teng_grp->engs[1].ucode = &eng_grp->ucode[1];\n\t\telse\n\t\t\teng_grp->engs[1].ucode = ucode;\n\t}\n}\n\nstatic int create_engine_group(struct device *dev,\n\t\t\t       struct otx2_cpt_eng_grps *eng_grps,\n\t\t\t       struct otx2_cpt_engines *engs, int ucodes_cnt,\n\t\t\t       void *ucode_data[], int is_print)\n{\n\tstruct otx2_cpt_eng_grp_info *mirrored_eng_grp;\n\tstruct otx2_cpt_eng_grp_info *eng_grp;\n\tstruct otx2_cpt_uc_info_t *uc_info;\n\tint i, ret = 0;\n\n\t \n\teng_grp = find_unused_eng_grp(eng_grps);\n\tif (!eng_grp) {\n\t\tdev_err(dev, \"Error all engine groups are being used\\n\");\n\t\treturn -ENOSPC;\n\t}\n\t \n\tfor (i = 0; i < ucodes_cnt; i++) {\n\t\tuc_info = (struct otx2_cpt_uc_info_t *) ucode_data[i];\n\t\teng_grp->ucode[i] = uc_info->ucode;\n\t\tret = copy_ucode_to_dma_mem(dev, &eng_grp->ucode[i],\n\t\t\t\t\t    uc_info->fw->data);\n\t\tif (ret)\n\t\t\tgoto unload_ucode;\n\t}\n\n\t \n\tmirrored_eng_grp = find_mirrored_eng_grp(eng_grp);\n\tif (mirrored_eng_grp) {\n\t\t \n\t\tsetup_eng_grp_mirroring(eng_grp, mirrored_eng_grp);\n\n\t\t \n\t\tupdate_requested_engs(mirrored_eng_grp, engs, ucodes_cnt);\n\t}\n\tret = reserve_engines(dev, eng_grp, engs, ucodes_cnt);\n\tif (ret)\n\t\tgoto unload_ucode;\n\n\t \n\tupdate_ucode_ptrs(eng_grp);\n\n\t \n\tret = eng_grp_update_masks(dev, eng_grp);\n\tif (ret)\n\t\tgoto release_engs;\n\n\t \n\tret = enable_eng_grp(eng_grp, eng_grps->obj);\n\tif (ret)\n\t\tgoto release_engs;\n\n\t \n\tif (eng_grp->mirror.is_ena)\n\t\tucode_unload(dev, &eng_grp->ucode[0]);\n\n\teng_grp->is_enabled = true;\n\n\tif (!is_print)\n\t\treturn 0;\n\n\tif (mirrored_eng_grp)\n\t\tdev_info(dev,\n\t\t\t \"Engine_group%d: reuse microcode %s from group %d\\n\",\n\t\t\t eng_grp->idx, mirrored_eng_grp->ucode[0].ver_str,\n\t\t\t mirrored_eng_grp->idx);\n\telse\n\t\tdev_info(dev, \"Engine_group%d: microcode loaded %s\\n\",\n\t\t\t eng_grp->idx, eng_grp->ucode[0].ver_str);\n\tif (is_2nd_ucode_used(eng_grp))\n\t\tdev_info(dev, \"Engine_group%d: microcode loaded %s\\n\",\n\t\t\t eng_grp->idx, eng_grp->ucode[1].ver_str);\n\n\treturn 0;\n\nrelease_engs:\n\trelease_engines(dev, eng_grp);\nunload_ucode:\n\tucode_unload(dev, &eng_grp->ucode[0]);\n\tucode_unload(dev, &eng_grp->ucode[1]);\n\treturn ret;\n}\n\nstatic void delete_engine_grps(struct pci_dev *pdev,\n\t\t\t       struct otx2_cpt_eng_grps *eng_grps)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < OTX2_CPT_MAX_ENGINE_GROUPS; i++)\n\t\tif (eng_grps->grp[i].mirror.is_ena)\n\t\t\tdelete_engine_group(&pdev->dev, &eng_grps->grp[i]);\n\n\t \n\tfor (i = 0; i < OTX2_CPT_MAX_ENGINE_GROUPS; i++)\n\t\tdelete_engine_group(&pdev->dev, &eng_grps->grp[i]);\n}\n\n#define PCI_DEVID_CN10K_RNM 0xA098\n#define RNM_ENTROPY_STATUS  0x8\n\nstatic void rnm_to_cpt_errata_fixup(struct device *dev)\n{\n\tstruct pci_dev *pdev;\n\tvoid __iomem *base;\n\tint timeout = 5000;\n\n\tpdev = pci_get_device(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_CN10K_RNM, NULL);\n\tif (!pdev)\n\t\treturn;\n\n\tbase = pci_ioremap_bar(pdev, 0);\n\tif (!base)\n\t\tgoto put_pdev;\n\n\twhile ((readq(base + RNM_ENTROPY_STATUS) & 0x7F) != 0x40) {\n\t\tcpu_relax();\n\t\tudelay(1);\n\t\ttimeout--;\n\t\tif (!timeout) {\n\t\t\tdev_warn(dev, \"RNM is not producing entropy\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tiounmap(base);\n\nput_pdev:\n\tpci_dev_put(pdev);\n}\n\nint otx2_cpt_get_eng_grp(struct otx2_cpt_eng_grps *eng_grps, int eng_type)\n{\n\n\tint eng_grp_num = OTX2_CPT_INVALID_CRYPTO_ENG_GRP;\n\tstruct otx2_cpt_eng_grp_info *grp;\n\tint i;\n\n\tfor (i = 0; i < OTX2_CPT_MAX_ENGINE_GROUPS; i++) {\n\t\tgrp = &eng_grps->grp[i];\n\t\tif (!grp->is_enabled)\n\t\t\tcontinue;\n\n\t\tif (eng_type == OTX2_CPT_SE_TYPES) {\n\t\t\tif (eng_grp_has_eng_type(grp, eng_type) &&\n\t\t\t    !eng_grp_has_eng_type(grp, OTX2_CPT_IE_TYPES)) {\n\t\t\t\teng_grp_num = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (eng_grp_has_eng_type(grp, eng_type)) {\n\t\t\t\teng_grp_num = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn eng_grp_num;\n}\n\nint otx2_cpt_create_eng_grps(struct otx2_cptpf_dev *cptpf,\n\t\t\t     struct otx2_cpt_eng_grps *eng_grps)\n{\n\tstruct otx2_cpt_uc_info_t *uc_info[OTX2_CPT_MAX_ETYPES_PER_GRP] = {  };\n\tstruct otx2_cpt_engines engs[OTX2_CPT_MAX_ETYPES_PER_GRP] = { {0} };\n\tstruct pci_dev *pdev = cptpf->pdev;\n\tstruct fw_info_t fw_info;\n\tu64 reg_val;\n\tint ret = 0;\n\n\tmutex_lock(&eng_grps->lock);\n\t \n\tif (eng_grps->is_grps_created)\n\t\tgoto unlock;\n\n\tret = cpt_ucode_load_fw(pdev, &fw_info);\n\tif (ret)\n\t\tgoto unlock;\n\n\t \n\tuc_info[0] = get_ucode(&fw_info, OTX2_CPT_SE_TYPES);\n\tif (uc_info[0] == NULL) {\n\t\tdev_err(&pdev->dev, \"Unable to find firmware for SE\\n\");\n\t\tret = -EINVAL;\n\t\tgoto release_fw;\n\t}\n\tengs[0].type = OTX2_CPT_SE_TYPES;\n\tengs[0].count = eng_grps->avail.max_se_cnt;\n\n\tret = create_engine_group(&pdev->dev, eng_grps, engs, 1,\n\t\t\t\t  (void **) uc_info, 1);\n\tif (ret)\n\t\tgoto release_fw;\n\n\t \n\tuc_info[0] = get_ucode(&fw_info, OTX2_CPT_SE_TYPES);\n\tuc_info[1] = get_ucode(&fw_info, OTX2_CPT_IE_TYPES);\n\n\tif (uc_info[1] == NULL) {\n\t\tdev_err(&pdev->dev, \"Unable to find firmware for IE\");\n\t\tret = -EINVAL;\n\t\tgoto delete_eng_grp;\n\t}\n\tengs[0].type = OTX2_CPT_SE_TYPES;\n\tengs[0].count = eng_grps->avail.max_se_cnt;\n\tengs[1].type = OTX2_CPT_IE_TYPES;\n\tengs[1].count = eng_grps->avail.max_ie_cnt;\n\n\tret = create_engine_group(&pdev->dev, eng_grps, engs, 2,\n\t\t\t\t  (void **) uc_info, 1);\n\tif (ret)\n\t\tgoto delete_eng_grp;\n\n\t \n\tuc_info[0] = get_ucode(&fw_info, OTX2_CPT_AE_TYPES);\n\tif (uc_info[0] == NULL) {\n\t\tdev_err(&pdev->dev, \"Unable to find firmware for AE\");\n\t\tret = -EINVAL;\n\t\tgoto delete_eng_grp;\n\t}\n\tengs[0].type = OTX2_CPT_AE_TYPES;\n\tengs[0].count = eng_grps->avail.max_ae_cnt;\n\n\tret = create_engine_group(&pdev->dev, eng_grps, engs, 1,\n\t\t\t\t  (void **) uc_info, 1);\n\tif (ret)\n\t\tgoto delete_eng_grp;\n\n\teng_grps->is_grps_created = true;\n\n\tcpt_ucode_release_fw(&fw_info);\n\n\tif (is_dev_otx2(pdev))\n\t\tgoto unlock;\n\n\t \n\trnm_to_cpt_errata_fixup(&pdev->dev);\n\n\t \n\totx2_cpt_write_af_reg(&cptpf->afpf_mbox, pdev, CPT_AF_CTL,\n\t\t\t      OTX2_CPT_ALL_ENG_GRPS_MASK << 3 | BIT_ULL(16),\n\t\t\t      BLKADDR_CPT0);\n\t \n\totx2_cpt_write_af_reg(&cptpf->afpf_mbox, pdev, CPT_AF_CTX_FLUSH_TIMER,\n\t\t\t      CTX_FLUSH_TIMER_CNT, BLKADDR_CPT0);\n\n\t \n\totx2_cpt_read_af_reg(&cptpf->afpf_mbox, pdev, CPT_AF_DIAG, &reg_val,\n\t\t\t     BLKADDR_CPT0);\n\totx2_cpt_write_af_reg(&cptpf->afpf_mbox, pdev, CPT_AF_DIAG,\n\t\t\t      reg_val | BIT_ULL(24), BLKADDR_CPT0);\n\n\tmutex_unlock(&eng_grps->lock);\n\treturn 0;\n\ndelete_eng_grp:\n\tdelete_engine_grps(pdev, eng_grps);\nrelease_fw:\n\tcpt_ucode_release_fw(&fw_info);\nunlock:\n\tmutex_unlock(&eng_grps->lock);\n\treturn ret;\n}\n\nstatic int cptx_disable_all_cores(struct otx2_cptpf_dev *cptpf, int total_cores,\n\t\t\t\t  int blkaddr)\n{\n\tint timeout = 10, ret;\n\tint i, busy;\n\tu64 reg;\n\n\t \n\tfor (i = 0; i < total_cores; i++) {\n\t\tret = otx2_cpt_add_write_af_reg(&cptpf->afpf_mbox, cptpf->pdev,\n\t\t\t\t\t\tCPT_AF_EXEX_CTL2(i), 0x0,\n\t\t\t\t\t\tblkaddr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcptpf->eng_grps.eng_ref_cnt[i] = 0;\n\t}\n\tret = otx2_cpt_send_af_reg_requests(&cptpf->afpf_mbox, cptpf->pdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdo {\n\t\tbusy = 0;\n\t\tusleep_range(10000, 20000);\n\t\tif (timeout-- < 0)\n\t\t\treturn -EBUSY;\n\n\t\tfor (i = 0; i < total_cores; i++) {\n\t\t\tret = otx2_cpt_read_af_reg(&cptpf->afpf_mbox,\n\t\t\t\t\t\t   cptpf->pdev,\n\t\t\t\t\t\t   CPT_AF_EXEX_STS(i), &reg,\n\t\t\t\t\t\t   blkaddr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (reg & 0x1) {\n\t\t\t\tbusy = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (busy);\n\n\t \n\tfor (i = 0; i < total_cores; i++) {\n\t\tret = otx2_cpt_add_write_af_reg(&cptpf->afpf_mbox, cptpf->pdev,\n\t\t\t\t\t\tCPT_AF_EXEX_CTL(i), 0x0,\n\t\t\t\t\t\tblkaddr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn otx2_cpt_send_af_reg_requests(&cptpf->afpf_mbox, cptpf->pdev);\n}\n\nint otx2_cpt_disable_all_cores(struct otx2_cptpf_dev *cptpf)\n{\n\tint total_cores, ret;\n\n\ttotal_cores = cptpf->eng_grps.avail.max_se_cnt +\n\t\t      cptpf->eng_grps.avail.max_ie_cnt +\n\t\t      cptpf->eng_grps.avail.max_ae_cnt;\n\n\tif (cptpf->has_cpt1) {\n\t\tret = cptx_disable_all_cores(cptpf, total_cores, BLKADDR_CPT1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn cptx_disable_all_cores(cptpf, total_cores, BLKADDR_CPT0);\n}\n\nvoid otx2_cpt_cleanup_eng_grps(struct pci_dev *pdev,\n\t\t\t       struct otx2_cpt_eng_grps *eng_grps)\n{\n\tstruct otx2_cpt_eng_grp_info *grp;\n\tint i, j;\n\n\tmutex_lock(&eng_grps->lock);\n\tdelete_engine_grps(pdev, eng_grps);\n\t \n\tfor (i = 0; i < OTX2_CPT_MAX_ENGINE_GROUPS; i++) {\n\t\tgrp = &eng_grps->grp[i];\n\t\tfor (j = 0; j < OTX2_CPT_MAX_ETYPES_PER_GRP; j++) {\n\t\t\tkfree(grp->engs[j].bmap);\n\t\t\tgrp->engs[j].bmap = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&eng_grps->lock);\n}\n\nint otx2_cpt_init_eng_grps(struct pci_dev *pdev,\n\t\t\t   struct otx2_cpt_eng_grps *eng_grps)\n{\n\tstruct otx2_cpt_eng_grp_info *grp;\n\tint i, j, ret;\n\n\tmutex_init(&eng_grps->lock);\n\teng_grps->obj = pci_get_drvdata(pdev);\n\teng_grps->avail.se_cnt = eng_grps->avail.max_se_cnt;\n\teng_grps->avail.ie_cnt = eng_grps->avail.max_ie_cnt;\n\teng_grps->avail.ae_cnt = eng_grps->avail.max_ae_cnt;\n\n\teng_grps->engs_num = eng_grps->avail.max_se_cnt +\n\t\t\t     eng_grps->avail.max_ie_cnt +\n\t\t\t     eng_grps->avail.max_ae_cnt;\n\tif (eng_grps->engs_num > OTX2_CPT_MAX_ENGINES) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Number of engines %d > than max supported %d\\n\",\n\t\t\teng_grps->engs_num, OTX2_CPT_MAX_ENGINES);\n\t\tret = -EINVAL;\n\t\tgoto cleanup_eng_grps;\n\t}\n\n\tfor (i = 0; i < OTX2_CPT_MAX_ENGINE_GROUPS; i++) {\n\t\tgrp = &eng_grps->grp[i];\n\t\tgrp->g = eng_grps;\n\t\tgrp->idx = i;\n\n\t\tfor (j = 0; j < OTX2_CPT_MAX_ETYPES_PER_GRP; j++) {\n\t\t\tgrp->engs[j].bmap =\n\t\t\t\tkcalloc(BITS_TO_LONGS(eng_grps->engs_num),\n\t\t\t\t\tsizeof(long), GFP_KERNEL);\n\t\t\tif (!grp->engs[j].bmap) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto cleanup_eng_grps;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\ncleanup_eng_grps:\n\totx2_cpt_cleanup_eng_grps(pdev, eng_grps);\n\treturn ret;\n}\n\nstatic int create_eng_caps_discovery_grps(struct pci_dev *pdev,\n\t\t\t\t\t  struct otx2_cpt_eng_grps *eng_grps)\n{\n\tstruct otx2_cpt_uc_info_t *uc_info[OTX2_CPT_MAX_ETYPES_PER_GRP] = {  };\n\tstruct otx2_cpt_engines engs[OTX2_CPT_MAX_ETYPES_PER_GRP] = { {0} };\n\tstruct fw_info_t fw_info;\n\tint ret;\n\n\tmutex_lock(&eng_grps->lock);\n\tret = cpt_ucode_load_fw(pdev, &fw_info);\n\tif (ret) {\n\t\tmutex_unlock(&eng_grps->lock);\n\t\treturn ret;\n\t}\n\n\tuc_info[0] = get_ucode(&fw_info, OTX2_CPT_AE_TYPES);\n\tif (uc_info[0] == NULL) {\n\t\tdev_err(&pdev->dev, \"Unable to find firmware for AE\\n\");\n\t\tret = -EINVAL;\n\t\tgoto release_fw;\n\t}\n\tengs[0].type = OTX2_CPT_AE_TYPES;\n\tengs[0].count = 2;\n\n\tret = create_engine_group(&pdev->dev, eng_grps, engs, 1,\n\t\t\t\t  (void **) uc_info, 0);\n\tif (ret)\n\t\tgoto release_fw;\n\n\tuc_info[0] = get_ucode(&fw_info, OTX2_CPT_SE_TYPES);\n\tif (uc_info[0] == NULL) {\n\t\tdev_err(&pdev->dev, \"Unable to find firmware for SE\\n\");\n\t\tret = -EINVAL;\n\t\tgoto delete_eng_grp;\n\t}\n\tengs[0].type = OTX2_CPT_SE_TYPES;\n\tengs[0].count = 2;\n\n\tret = create_engine_group(&pdev->dev, eng_grps, engs, 1,\n\t\t\t\t  (void **) uc_info, 0);\n\tif (ret)\n\t\tgoto delete_eng_grp;\n\n\tuc_info[0] = get_ucode(&fw_info, OTX2_CPT_IE_TYPES);\n\tif (uc_info[0] == NULL) {\n\t\tdev_err(&pdev->dev, \"Unable to find firmware for IE\\n\");\n\t\tret = -EINVAL;\n\t\tgoto delete_eng_grp;\n\t}\n\tengs[0].type = OTX2_CPT_IE_TYPES;\n\tengs[0].count = 2;\n\n\tret = create_engine_group(&pdev->dev, eng_grps, engs, 1,\n\t\t\t\t  (void **) uc_info, 0);\n\tif (ret)\n\t\tgoto delete_eng_grp;\n\n\tcpt_ucode_release_fw(&fw_info);\n\tmutex_unlock(&eng_grps->lock);\n\treturn 0;\n\ndelete_eng_grp:\n\tdelete_engine_grps(pdev, eng_grps);\nrelease_fw:\n\tcpt_ucode_release_fw(&fw_info);\n\tmutex_unlock(&eng_grps->lock);\n\treturn ret;\n}\n\n \nint otx2_cpt_discover_eng_capabilities(struct otx2_cptpf_dev *cptpf)\n{\n\tstruct otx2_cptlfs_info *lfs = &cptpf->lfs;\n\tstruct otx2_cpt_iq_command iq_cmd;\n\tunion otx2_cpt_opcode opcode;\n\tunion otx2_cpt_res_s *result;\n\tunion otx2_cpt_inst_s inst;\n\tdma_addr_t rptr_baddr;\n\tstruct pci_dev *pdev;\n\tu32 len, compl_rlen;\n\tint ret, etype;\n\tvoid *rptr;\n\n\t \n\tif (cptpf->is_eng_caps_discovered)\n\t\treturn 0;\n\n\tpdev = cptpf->pdev;\n\t \n\tret = create_eng_caps_discovery_grps(pdev, &cptpf->eng_grps);\n\tif (ret)\n\t\tgoto delete_grps;\n\n\totx2_cptlf_set_dev_info(lfs, cptpf->pdev, cptpf->reg_base,\n\t\t\t\t&cptpf->afpf_mbox, BLKADDR_CPT0);\n\tret = otx2_cptlf_init(lfs, OTX2_CPT_ALL_ENG_GRPS_MASK,\n\t\t\t      OTX2_CPT_QUEUE_HI_PRIO, 1);\n\tif (ret)\n\t\tgoto delete_grps;\n\n\tcompl_rlen = ALIGN(sizeof(union otx2_cpt_res_s), OTX2_CPT_DMA_MINALIGN);\n\tlen = compl_rlen + LOADFVC_RLEN;\n\n\tresult = kzalloc(len, GFP_KERNEL);\n\tif (!result) {\n\t\tret = -ENOMEM;\n\t\tgoto lf_cleanup;\n\t}\n\trptr_baddr = dma_map_single(&pdev->dev, (void *)result, len,\n\t\t\t\t    DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(&pdev->dev, rptr_baddr)) {\n\t\tdev_err(&pdev->dev, \"DMA mapping failed\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_result;\n\t}\n\trptr = (u8 *)result + compl_rlen;\n\n\t \n\topcode.s.major = LOADFVC_MAJOR_OP;\n\topcode.s.minor = LOADFVC_MINOR_OP;\n\n\tiq_cmd.cmd.u = 0;\n\tiq_cmd.cmd.s.opcode = cpu_to_be16(opcode.flags);\n\n\t \n\tcpu_to_be64s(&iq_cmd.cmd.u);\n\tiq_cmd.dptr = 0;\n\tiq_cmd.rptr = rptr_baddr + compl_rlen;\n\tiq_cmd.cptr.u = 0;\n\n\tfor (etype = 1; etype < OTX2_CPT_MAX_ENG_TYPES; etype++) {\n\t\tresult->s.compcode = OTX2_CPT_COMPLETION_CODE_INIT;\n\t\tiq_cmd.cptr.s.grp = otx2_cpt_get_eng_grp(&cptpf->eng_grps,\n\t\t\t\t\t\t\t etype);\n\t\totx2_cpt_fill_inst(&inst, &iq_cmd, rptr_baddr);\n\t\tlfs->ops->send_cmd(&inst, 1, &cptpf->lfs.lf[0]);\n\n\t\twhile (lfs->ops->cpt_get_compcode(result) ==\n\t\t\t\t\t\tOTX2_CPT_COMPLETION_CODE_INIT)\n\t\t\tcpu_relax();\n\n\t\tcptpf->eng_caps[etype].u = be64_to_cpup(rptr);\n\t}\n\tdma_unmap_single(&pdev->dev, rptr_baddr, len, DMA_BIDIRECTIONAL);\n\tcptpf->is_eng_caps_discovered = true;\n\nfree_result:\n\tkfree(result);\nlf_cleanup:\n\totx2_cptlf_shutdown(lfs);\ndelete_grps:\n\tdelete_engine_grps(pdev, &cptpf->eng_grps);\n\n\treturn ret;\n}\n\nint otx2_cpt_dl_custom_egrp_create(struct otx2_cptpf_dev *cptpf,\n\t\t\t\t   struct devlink_param_gset_ctx *ctx)\n{\n\tstruct otx2_cpt_engines engs[OTX2_CPT_MAX_ETYPES_PER_GRP] = { { 0 } };\n\tstruct otx2_cpt_uc_info_t *uc_info[OTX2_CPT_MAX_ETYPES_PER_GRP] = {};\n\tstruct otx2_cpt_eng_grps *eng_grps = &cptpf->eng_grps;\n\tchar *ucode_filename[OTX2_CPT_MAX_ETYPES_PER_GRP];\n\tchar tmp_buf[OTX2_CPT_NAME_LENGTH] = { 0 };\n\tstruct device *dev = &cptpf->pdev->dev;\n\tchar *start, *val, *err_msg, *tmp;\n\tint grp_idx = 0, ret = -EINVAL;\n\tbool has_se, has_ie, has_ae;\n\tstruct fw_info_t fw_info;\n\tint ucode_idx = 0;\n\n\tif (!eng_grps->is_grps_created) {\n\t\tdev_err(dev, \"Not allowed before creating the default groups\\n\");\n\t\treturn -EINVAL;\n\t}\n\terr_msg = \"Invalid engine group format\";\n\tstrscpy(tmp_buf, ctx->val.vstr, strlen(ctx->val.vstr) + 1);\n\tstart = tmp_buf;\n\n\thas_se = has_ie = has_ae = false;\n\n\tfor (;;) {\n\t\tval = strsep(&start, \";\");\n\t\tif (!val)\n\t\t\tbreak;\n\t\tval = strim(val);\n\t\tif (!*val)\n\t\t\tcontinue;\n\n\t\tif (!strncasecmp(val, \"se\", 2) && strchr(val, ':')) {\n\t\t\tif (has_se || ucode_idx)\n\t\t\t\tgoto err_print;\n\t\t\ttmp = strsep(&val, \":\");\n\t\t\tif (!tmp)\n\t\t\t\tgoto err_print;\n\t\t\ttmp = strim(tmp);\n\t\t\tif (!val)\n\t\t\t\tgoto err_print;\n\t\t\tif (strlen(tmp) != 2)\n\t\t\t\tgoto err_print;\n\t\t\tif (kstrtoint(strim(val), 10, &engs[grp_idx].count))\n\t\t\t\tgoto err_print;\n\t\t\tengs[grp_idx++].type = OTX2_CPT_SE_TYPES;\n\t\t\thas_se = true;\n\t\t} else if (!strncasecmp(val, \"ae\", 2) && strchr(val, ':')) {\n\t\t\tif (has_ae || ucode_idx)\n\t\t\t\tgoto err_print;\n\t\t\ttmp = strsep(&val, \":\");\n\t\t\tif (!tmp)\n\t\t\t\tgoto err_print;\n\t\t\ttmp = strim(tmp);\n\t\t\tif (!val)\n\t\t\t\tgoto err_print;\n\t\t\tif (strlen(tmp) != 2)\n\t\t\t\tgoto err_print;\n\t\t\tif (kstrtoint(strim(val), 10, &engs[grp_idx].count))\n\t\t\t\tgoto err_print;\n\t\t\tengs[grp_idx++].type = OTX2_CPT_AE_TYPES;\n\t\t\thas_ae = true;\n\t\t} else if (!strncasecmp(val, \"ie\", 2) && strchr(val, ':')) {\n\t\t\tif (has_ie || ucode_idx)\n\t\t\t\tgoto err_print;\n\t\t\ttmp = strsep(&val, \":\");\n\t\t\tif (!tmp)\n\t\t\t\tgoto err_print;\n\t\t\ttmp = strim(tmp);\n\t\t\tif (!val)\n\t\t\t\tgoto err_print;\n\t\t\tif (strlen(tmp) != 2)\n\t\t\t\tgoto err_print;\n\t\t\tif (kstrtoint(strim(val), 10, &engs[grp_idx].count))\n\t\t\t\tgoto err_print;\n\t\t\tengs[grp_idx++].type = OTX2_CPT_IE_TYPES;\n\t\t\thas_ie = true;\n\t\t} else {\n\t\t\tif (ucode_idx > 1)\n\t\t\t\tgoto err_print;\n\t\t\tif (!strlen(val))\n\t\t\t\tgoto err_print;\n\t\t\tif (strnstr(val, \" \", strlen(val)))\n\t\t\t\tgoto err_print;\n\t\t\tucode_filename[ucode_idx++] = val;\n\t\t}\n\t}\n\n\t \n\tif (!(grp_idx && ucode_idx))\n\t\tgoto err_print;\n\n\tif (ucode_idx > 1 && grp_idx < 2)\n\t\tgoto err_print;\n\n\tif (grp_idx > OTX2_CPT_MAX_ETYPES_PER_GRP) {\n\t\terr_msg = \"Error max 2 engine types can be attached\";\n\t\tgoto err_print;\n\t}\n\n\tif (grp_idx > 1) {\n\t\tif ((engs[0].type + engs[1].type) !=\n\t\t    (OTX2_CPT_SE_TYPES + OTX2_CPT_IE_TYPES)) {\n\t\t\terr_msg = \"Only combination of SE+IE engines is allowed\";\n\t\t\tgoto err_print;\n\t\t}\n\t\t \n\t\tif (engs[1].type == OTX2_CPT_SE_TYPES)\n\t\t\tswap(engs[0], engs[1]);\n\t}\n\tmutex_lock(&eng_grps->lock);\n\n\tif (cptpf->enabled_vfs) {\n\t\tdev_err(dev, \"Disable VFs before modifying engine groups\\n\");\n\t\tret = -EACCES;\n\t\tgoto err_unlock;\n\t}\n\tINIT_LIST_HEAD(&fw_info.ucodes);\n\tret = load_fw(dev, &fw_info, ucode_filename[0]);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to load firmware %s\\n\", ucode_filename[0]);\n\t\tgoto err_unlock;\n\t}\n\tif (ucode_idx > 1) {\n\t\tret = load_fw(dev, &fw_info, ucode_filename[1]);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Unable to load firmware %s\\n\",\n\t\t\t\tucode_filename[1]);\n\t\t\tgoto release_fw;\n\t\t}\n\t}\n\tuc_info[0] = get_ucode(&fw_info, engs[0].type);\n\tif (uc_info[0] == NULL) {\n\t\tdev_err(dev, \"Unable to find firmware for %s\\n\",\n\t\t\tget_eng_type_str(engs[0].type));\n\t\tret = -EINVAL;\n\t\tgoto release_fw;\n\t}\n\tif (ucode_idx > 1) {\n\t\tuc_info[1] = get_ucode(&fw_info, engs[1].type);\n\t\tif (uc_info[1] == NULL) {\n\t\t\tdev_err(dev, \"Unable to find firmware for %s\\n\",\n\t\t\t\tget_eng_type_str(engs[1].type));\n\t\t\tret = -EINVAL;\n\t\t\tgoto release_fw;\n\t\t}\n\t}\n\tret = create_engine_group(dev, eng_grps, engs, grp_idx,\n\t\t\t\t  (void **)uc_info, 1);\n\nrelease_fw:\n\tcpt_ucode_release_fw(&fw_info);\nerr_unlock:\n\tmutex_unlock(&eng_grps->lock);\n\treturn ret;\nerr_print:\n\tdev_err(dev, \"%s\\n\", err_msg);\n\treturn ret;\n}\n\nint otx2_cpt_dl_custom_egrp_delete(struct otx2_cptpf_dev *cptpf,\n\t\t\t\t   struct devlink_param_gset_ctx *ctx)\n{\n\tstruct otx2_cpt_eng_grps *eng_grps = &cptpf->eng_grps;\n\tstruct device *dev = &cptpf->pdev->dev;\n\tchar *tmp, *err_msg;\n\tint egrp;\n\tint ret;\n\n\terr_msg = \"Invalid input string format(ex: egrp:0)\";\n\tif (strncasecmp(ctx->val.vstr, \"egrp\", 4))\n\t\tgoto err_print;\n\ttmp = ctx->val.vstr;\n\tstrsep(&tmp, \":\");\n\tif (!tmp)\n\t\tgoto err_print;\n\tif (kstrtoint(tmp, 10, &egrp))\n\t\tgoto err_print;\n\n\tif (egrp < 0 || egrp >= OTX2_CPT_MAX_ENGINE_GROUPS) {\n\t\tdev_err(dev, \"Invalid engine group %d\", egrp);\n\t\treturn -EINVAL;\n\t}\n\tif (!eng_grps->grp[egrp].is_enabled) {\n\t\tdev_err(dev, \"Error engine_group%d is not configured\", egrp);\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&eng_grps->lock);\n\tret = delete_engine_group(dev, &eng_grps->grp[egrp]);\n\tmutex_unlock(&eng_grps->lock);\n\n\treturn ret;\n\nerr_print:\n\tdev_err(dev, \"%s\\n\", err_msg);\n\treturn -EINVAL;\n}\n\nstatic void get_engs_info(struct otx2_cpt_eng_grp_info *eng_grp, char *buf,\n\t\t\t  int size, int idx)\n{\n\tstruct otx2_cpt_engs_rsvd *mirrored_engs = NULL;\n\tstruct otx2_cpt_engs_rsvd *engs;\n\tint len, i;\n\n\tbuf[0] = '\\0';\n\tfor (i = 0; i < OTX2_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tengs = &eng_grp->engs[i];\n\t\tif (!engs->type)\n\t\t\tcontinue;\n\t\tif (idx != -1 && idx != i)\n\t\t\tcontinue;\n\n\t\tif (eng_grp->mirror.is_ena)\n\t\t\tmirrored_engs = find_engines_by_type(\n\t\t\t\t&eng_grp->g->grp[eng_grp->mirror.idx],\n\t\t\t\tengs->type);\n\t\tif (i > 0 && idx == -1) {\n\t\t\tlen = strlen(buf);\n\t\t\tscnprintf(buf + len, size - len, \", \");\n\t\t}\n\n\t\tlen = strlen(buf);\n\t\tscnprintf(buf + len, size - len, \"%d %s \",\n\t\t\t  mirrored_engs ? engs->count + mirrored_engs->count :\n\t\t\t\t\t  engs->count,\n\t\t\t  get_eng_type_str(engs->type));\n\t\tif (mirrored_engs) {\n\t\t\tlen = strlen(buf);\n\t\t\tscnprintf(buf + len, size - len,\n\t\t\t\t  \"(%d shared with engine_group%d) \",\n\t\t\t\t  engs->count <= 0 ?\n\t\t\t\t\t  engs->count + mirrored_engs->count :\n\t\t\t\t\t  mirrored_engs->count,\n\t\t\t\t  eng_grp->mirror.idx);\n\t\t}\n\t}\n}\n\nvoid otx2_cpt_print_uc_dbg_info(struct otx2_cptpf_dev *cptpf)\n{\n\tstruct otx2_cpt_eng_grps *eng_grps = &cptpf->eng_grps;\n\tstruct otx2_cpt_eng_grp_info *mirrored_grp;\n\tchar engs_info[2 * OTX2_CPT_NAME_LENGTH];\n\tstruct otx2_cpt_eng_grp_info *grp;\n\tstruct otx2_cpt_engs_rsvd *engs;\n\tint i, j;\n\n\tpr_debug(\"Engine groups global info\");\n\tpr_debug(\"max SE %d, max IE %d, max AE %d\", eng_grps->avail.max_se_cnt,\n\t\t eng_grps->avail.max_ie_cnt, eng_grps->avail.max_ae_cnt);\n\tpr_debug(\"free SE %d\", eng_grps->avail.se_cnt);\n\tpr_debug(\"free IE %d\", eng_grps->avail.ie_cnt);\n\tpr_debug(\"free AE %d\", eng_grps->avail.ae_cnt);\n\n\tfor (i = 0; i < OTX2_CPT_MAX_ENGINE_GROUPS; i++) {\n\t\tgrp = &eng_grps->grp[i];\n\t\tpr_debug(\"engine_group%d, state %s\", i,\n\t\t\t grp->is_enabled ? \"enabled\" : \"disabled\");\n\t\tif (grp->is_enabled) {\n\t\t\tmirrored_grp = &eng_grps->grp[grp->mirror.idx];\n\t\t\tpr_debug(\"Ucode0 filename %s, version %s\",\n\t\t\t\t grp->mirror.is_ena ?\n\t\t\t\t\t mirrored_grp->ucode[0].filename :\n\t\t\t\t\t grp->ucode[0].filename,\n\t\t\t\t grp->mirror.is_ena ?\n\t\t\t\t\t mirrored_grp->ucode[0].ver_str :\n\t\t\t\t\t grp->ucode[0].ver_str);\n\t\t\tif (is_2nd_ucode_used(grp))\n\t\t\t\tpr_debug(\"Ucode1 filename %s, version %s\",\n\t\t\t\t\t grp->ucode[1].filename,\n\t\t\t\t\t grp->ucode[1].ver_str);\n\t\t}\n\n\t\tfor (j = 0; j < OTX2_CPT_MAX_ETYPES_PER_GRP; j++) {\n\t\t\tengs = &grp->engs[j];\n\t\t\tif (engs->type) {\n\t\t\t\tu32 mask[5] = { };\n\n\t\t\t\tget_engs_info(grp, engs_info,\n\t\t\t\t\t      2 * OTX2_CPT_NAME_LENGTH, j);\n\t\t\t\tpr_debug(\"Slot%d: %s\", j, engs_info);\n\t\t\t\tbitmap_to_arr32(mask, engs->bmap,\n\t\t\t\t\t\teng_grps->engs_num);\n\t\t\t\tif (is_dev_otx2(cptpf->pdev))\n\t\t\t\t\tpr_debug(\"Mask: %8.8x %8.8x %8.8x %8.8x\",\n\t\t\t\t\t\t mask[3], mask[2], mask[1],\n\t\t\t\t\t\t mask[0]);\n\t\t\t\telse\n\t\t\t\t\tpr_debug(\"Mask: %8.8x %8.8x %8.8x %8.8x %8.8x\",\n\t\t\t\t\t\t mask[4], mask[3], mask[2], mask[1],\n\t\t\t\t\t\t mask[0]);\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}