{
  "module_name": "otx2_cptvf_mbox.c",
  "hash_id": "ea531da3a5175a954cf08b9188e77ff7bbb9bb758b8b742eab840785010116f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/octeontx2/otx2_cptvf_mbox.c",
  "human_readable_source": "\n \n\n#include \"otx2_cpt_common.h\"\n#include \"otx2_cptvf.h\"\n#include <rvu_reg.h>\n\nint otx2_cpt_mbox_bbuf_init(struct otx2_cptvf_dev *cptvf, struct pci_dev *pdev)\n{\n\tstruct otx2_mbox_dev *mdev;\n\tstruct otx2_mbox *otx2_mbox;\n\n\tcptvf->bbuf_base = devm_kmalloc(&pdev->dev, MBOX_SIZE, GFP_KERNEL);\n\tif (!cptvf->bbuf_base)\n\t\treturn -ENOMEM;\n\t \n\totx2_mbox = &cptvf->pfvf_mbox;\n\tmdev = &otx2_mbox->dev[0];\n\tmdev->mbase = cptvf->bbuf_base;\n\n\treturn 0;\n}\n\nstatic void otx2_cpt_sync_mbox_bbuf(struct otx2_mbox *mbox, int devid)\n{\n\tu16 msgs_offset = ALIGN(sizeof(struct mbox_hdr), MBOX_MSG_ALIGN);\n\tvoid *hw_mbase = mbox->hwbase + (devid * MBOX_SIZE);\n\tstruct otx2_mbox_dev *mdev = &mbox->dev[devid];\n\tstruct mbox_hdr *hdr;\n\tu64 msg_size;\n\n\tif (mdev->mbase == hw_mbase)\n\t\treturn;\n\n\thdr = hw_mbase + mbox->rx_start;\n\tmsg_size = hdr->msg_size;\n\n\tif (msg_size > mbox->rx_size - msgs_offset)\n\t\tmsg_size = mbox->rx_size - msgs_offset;\n\n\t \n\tmemcpy(mdev->mbase + mbox->rx_start,\n\t       hw_mbase + mbox->rx_start, msg_size + msgs_offset);\n}\n\nirqreturn_t otx2_cptvf_pfvf_mbox_intr(int __always_unused irq, void *arg)\n{\n\tstruct otx2_cptvf_dev *cptvf = arg;\n\tu64 intr;\n\n\t \n\tintr = otx2_cpt_read64(cptvf->reg_base, BLKADDR_RVUM, 0,\n\t\t\t       OTX2_RVU_VF_INT);\n\n\tif (intr & 0x1ULL) {\n\t\t \n\t\tqueue_work(cptvf->pfvf_mbox_wq, &cptvf->pfvf_mbox_work);\n\t\t \n\t\totx2_cpt_write64(cptvf->reg_base, BLKADDR_RVUM, 0,\n\t\t\t\t OTX2_RVU_VF_INT, 0x1ULL);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void process_pfvf_mbox_mbox_msg(struct otx2_cptvf_dev *cptvf,\n\t\t\t\t       struct mbox_msghdr *msg)\n{\n\tstruct otx2_cptlfs_info *lfs = &cptvf->lfs;\n\tstruct otx2_cpt_kvf_limits_rsp *rsp_limits;\n\tstruct otx2_cpt_egrp_num_rsp *rsp_grp;\n\tstruct cpt_rd_wr_reg_msg *rsp_reg;\n\tstruct msix_offset_rsp *rsp_msix;\n\tint i;\n\n\tif (msg->id >= MBOX_MSG_MAX) {\n\t\tdev_err(&cptvf->pdev->dev,\n\t\t\t\"MBOX msg with unknown ID %d\\n\", msg->id);\n\t\treturn;\n\t}\n\tif (msg->sig != OTX2_MBOX_RSP_SIG) {\n\t\tdev_err(&cptvf->pdev->dev,\n\t\t\t\"MBOX msg with wrong signature %x, ID %d\\n\",\n\t\t\tmsg->sig, msg->id);\n\t\treturn;\n\t}\n\tswitch (msg->id) {\n\tcase MBOX_MSG_READY:\n\t\tcptvf->vf_id = ((msg->pcifunc >> RVU_PFVF_FUNC_SHIFT)\n\t\t\t\t& RVU_PFVF_FUNC_MASK) - 1;\n\t\tbreak;\n\tcase MBOX_MSG_ATTACH_RESOURCES:\n\t\t \n\t\tif (!msg->rc)\n\t\t\tlfs->are_lfs_attached = 1;\n\t\tbreak;\n\tcase MBOX_MSG_DETACH_RESOURCES:\n\t\t \n\t\tif (!msg->rc)\n\t\t\tlfs->are_lfs_attached = 0;\n\t\tbreak;\n\tcase MBOX_MSG_MSIX_OFFSET:\n\t\trsp_msix = (struct msix_offset_rsp *) msg;\n\t\tfor (i = 0; i < rsp_msix->cptlfs; i++)\n\t\t\tlfs->lf[i].msix_offset = rsp_msix->cptlf_msixoff[i];\n\t\tbreak;\n\tcase MBOX_MSG_CPT_RD_WR_REGISTER:\n\t\trsp_reg = (struct cpt_rd_wr_reg_msg *) msg;\n\t\tif (msg->rc) {\n\t\t\tdev_err(&cptvf->pdev->dev,\n\t\t\t\t\"Reg %llx rd/wr(%d) failed %d\\n\",\n\t\t\t\trsp_reg->reg_offset, rsp_reg->is_write,\n\t\t\t\tmsg->rc);\n\t\t\treturn;\n\t\t}\n\t\tif (!rsp_reg->is_write)\n\t\t\t*rsp_reg->ret_val = rsp_reg->val;\n\t\tbreak;\n\tcase MBOX_MSG_GET_ENG_GRP_NUM:\n\t\trsp_grp = (struct otx2_cpt_egrp_num_rsp *) msg;\n\t\tcptvf->lfs.kcrypto_eng_grp_num = rsp_grp->eng_grp_num;\n\t\tbreak;\n\tcase MBOX_MSG_GET_KVF_LIMITS:\n\t\trsp_limits = (struct otx2_cpt_kvf_limits_rsp *) msg;\n\t\tcptvf->lfs.kvf_limits = rsp_limits->kvf_limits;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&cptvf->pdev->dev, \"Unsupported msg %d received.\\n\",\n\t\t\tmsg->id);\n\t\tbreak;\n\t}\n}\n\nvoid otx2_cptvf_pfvf_mbox_handler(struct work_struct *work)\n{\n\tstruct otx2_cptvf_dev *cptvf;\n\tstruct otx2_mbox *pfvf_mbox;\n\tstruct otx2_mbox_dev *mdev;\n\tstruct mbox_hdr *rsp_hdr;\n\tstruct mbox_msghdr *msg;\n\tint offset, i;\n\n\t \n\tsmp_rmb();\n\n\tcptvf = container_of(work, struct otx2_cptvf_dev, pfvf_mbox_work);\n\tpfvf_mbox = &cptvf->pfvf_mbox;\n\totx2_cpt_sync_mbox_bbuf(pfvf_mbox, 0);\n\tmdev = &pfvf_mbox->dev[0];\n\trsp_hdr = (struct mbox_hdr *)(mdev->mbase + pfvf_mbox->rx_start);\n\tif (rsp_hdr->num_msgs == 0)\n\t\treturn;\n\toffset = ALIGN(sizeof(struct mbox_hdr), MBOX_MSG_ALIGN);\n\n\tfor (i = 0; i < rsp_hdr->num_msgs; i++) {\n\t\tmsg = (struct mbox_msghdr *)(mdev->mbase + pfvf_mbox->rx_start +\n\t\t\t\t\t     offset);\n\t\tprocess_pfvf_mbox_mbox_msg(cptvf, msg);\n\t\toffset = msg->next_msgoff;\n\t\tmdev->msgs_acked++;\n\t}\n\totx2_mbox_reset(pfvf_mbox, 0);\n}\n\nint otx2_cptvf_send_eng_grp_num_msg(struct otx2_cptvf_dev *cptvf, int eng_type)\n{\n\tstruct otx2_mbox *mbox = &cptvf->pfvf_mbox;\n\tstruct pci_dev *pdev = cptvf->pdev;\n\tstruct otx2_cpt_egrp_num_msg *req;\n\n\treq = (struct otx2_cpt_egrp_num_msg *)\n\t      otx2_mbox_alloc_msg_rsp(mbox, 0, sizeof(*req),\n\t\t\t\t      sizeof(struct otx2_cpt_egrp_num_rsp));\n\tif (req == NULL) {\n\t\tdev_err(&pdev->dev, \"RVU MBOX failed to get message.\\n\");\n\t\treturn -EFAULT;\n\t}\n\treq->hdr.id = MBOX_MSG_GET_ENG_GRP_NUM;\n\treq->hdr.sig = OTX2_MBOX_REQ_SIG;\n\treq->hdr.pcifunc = OTX2_CPT_RVU_PFFUNC(cptvf->vf_id, 0);\n\treq->eng_type = eng_type;\n\n\treturn otx2_cpt_send_mbox_msg(mbox, pdev);\n}\n\nint otx2_cptvf_send_kvf_limits_msg(struct otx2_cptvf_dev *cptvf)\n{\n\tstruct otx2_mbox *mbox = &cptvf->pfvf_mbox;\n\tstruct pci_dev *pdev = cptvf->pdev;\n\tstruct mbox_msghdr *req;\n\n\treq = (struct mbox_msghdr *)\n\t      otx2_mbox_alloc_msg_rsp(mbox, 0, sizeof(*req),\n\t\t\t\t      sizeof(struct otx2_cpt_kvf_limits_rsp));\n\tif (req == NULL) {\n\t\tdev_err(&pdev->dev, \"RVU MBOX failed to get message.\\n\");\n\t\treturn -EFAULT;\n\t}\n\treq->id = MBOX_MSG_GET_KVF_LIMITS;\n\treq->sig = OTX2_MBOX_REQ_SIG;\n\treq->pcifunc = OTX2_CPT_RVU_PFFUNC(cptvf->vf_id, 0);\n\n\treturn otx2_cpt_send_mbox_msg(mbox, pdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}