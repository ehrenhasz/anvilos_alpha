{
  "module_name": "otx2_cptvf_main.c",
  "hash_id": "45f2f90ca4409b4b421df921caaeb83abcfce0308464f908ab701c3134e8aeca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/octeontx2/otx2_cptvf_main.c",
  "human_readable_source": "\n \n\n#include \"otx2_cpt_common.h\"\n#include \"otx2_cptvf.h\"\n#include \"otx2_cptlf.h\"\n#include \"otx2_cptvf_algs.h\"\n#include \"cn10k_cpt.h\"\n#include <rvu_reg.h>\n\n#define OTX2_CPTVF_DRV_NAME \"rvu_cptvf\"\n\nstatic void cptvf_enable_pfvf_mbox_intrs(struct otx2_cptvf_dev *cptvf)\n{\n\t \n\totx2_cpt_write64(cptvf->reg_base, BLKADDR_RVUM, 0, OTX2_RVU_VF_INT,\n\t\t\t 0x1ULL);\n\n\t \n\totx2_cpt_write64(cptvf->reg_base, BLKADDR_RVUM, 0,\n\t\t\t OTX2_RVU_VF_INT_ENA_W1S, 0x1ULL);\n}\n\nstatic void cptvf_disable_pfvf_mbox_intrs(struct otx2_cptvf_dev *cptvf)\n{\n\t \n\totx2_cpt_write64(cptvf->reg_base, BLKADDR_RVUM, 0,\n\t\t\t OTX2_RVU_VF_INT_ENA_W1C, 0x1ULL);\n\n\t \n\totx2_cpt_write64(cptvf->reg_base, BLKADDR_RVUM, 0, OTX2_RVU_VF_INT,\n\t\t\t 0x1ULL);\n}\n\nstatic int cptvf_register_interrupts(struct otx2_cptvf_dev *cptvf)\n{\n\tint ret, irq;\n\tint num_vec;\n\n\tnum_vec = pci_msix_vec_count(cptvf->pdev);\n\tif (num_vec <= 0)\n\t\treturn -EINVAL;\n\n\t \n\tret = pci_alloc_irq_vectors(cptvf->pdev, num_vec, num_vec,\n\t\t\t\t    PCI_IRQ_MSIX);\n\tif (ret < 0) {\n\t\tdev_err(&cptvf->pdev->dev,\n\t\t\t\"Request for %d msix vectors failed\\n\", num_vec);\n\t\treturn ret;\n\t}\n\tirq = pci_irq_vector(cptvf->pdev, OTX2_CPT_VF_INT_VEC_E_MBOX);\n\t \n\tret = devm_request_irq(&cptvf->pdev->dev, irq,\n\t\t\t       otx2_cptvf_pfvf_mbox_intr, 0,\n\t\t\t       \"CPTPFVF Mbox\", cptvf);\n\tif (ret)\n\t\treturn ret;\n\t \n\tcptvf_enable_pfvf_mbox_intrs(cptvf);\n\n\tret = otx2_cpt_send_ready_msg(&cptvf->pfvf_mbox, cptvf->pdev);\n\tif (ret) {\n\t\tdev_warn(&cptvf->pdev->dev,\n\t\t\t \"PF not responding to mailbox, deferring probe\\n\");\n\t\tcptvf_disable_pfvf_mbox_intrs(cptvf);\n\t\treturn -EPROBE_DEFER;\n\t}\n\treturn 0;\n}\n\nstatic int cptvf_pfvf_mbox_init(struct otx2_cptvf_dev *cptvf)\n{\n\tstruct pci_dev *pdev = cptvf->pdev;\n\tresource_size_t offset, size;\n\tint ret;\n\n\tcptvf->pfvf_mbox_wq =\n\t\talloc_ordered_workqueue(\"cpt_pfvf_mailbox\",\n\t\t\t\t\tWQ_HIGHPRI | WQ_MEM_RECLAIM);\n\tif (!cptvf->pfvf_mbox_wq)\n\t\treturn -ENOMEM;\n\n\tif (test_bit(CN10K_MBOX, &cptvf->cap_flag)) {\n\t\t \n\t\tcptvf->pfvf_mbox_base = cptvf->reg_base +\n\t\t\t\t\tCN10K_CPT_VF_MBOX_REGION;\n\t} else {\n\t\toffset = pci_resource_start(pdev, PCI_MBOX_BAR_NUM);\n\t\tsize = pci_resource_len(pdev, PCI_MBOX_BAR_NUM);\n\t\t \n\t\tcptvf->pfvf_mbox_base = devm_ioremap_wc(&pdev->dev, offset,\n\t\t\t\t\t\t\tsize);\n\t\tif (!cptvf->pfvf_mbox_base) {\n\t\t\tdev_err(&pdev->dev, \"Unable to map BAR4\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_wqe;\n\t\t}\n\t}\n\n\tret = otx2_mbox_init(&cptvf->pfvf_mbox, cptvf->pfvf_mbox_base,\n\t\t\t     pdev, cptvf->reg_base, MBOX_DIR_VFPF, 1);\n\tif (ret)\n\t\tgoto free_wqe;\n\n\tret = otx2_cpt_mbox_bbuf_init(cptvf, pdev);\n\tif (ret)\n\t\tgoto destroy_mbox;\n\n\tINIT_WORK(&cptvf->pfvf_mbox_work, otx2_cptvf_pfvf_mbox_handler);\n\treturn 0;\n\ndestroy_mbox:\n\totx2_mbox_destroy(&cptvf->pfvf_mbox);\nfree_wqe:\n\tdestroy_workqueue(cptvf->pfvf_mbox_wq);\n\treturn ret;\n}\n\nstatic void cptvf_pfvf_mbox_destroy(struct otx2_cptvf_dev *cptvf)\n{\n\tdestroy_workqueue(cptvf->pfvf_mbox_wq);\n\totx2_mbox_destroy(&cptvf->pfvf_mbox);\n}\n\nstatic void cptlf_work_handler(unsigned long data)\n{\n\totx2_cpt_post_process((struct otx2_cptlf_wqe *) data);\n}\n\nstatic void cleanup_tasklet_work(struct otx2_cptlfs_info *lfs)\n{\n\tint i;\n\n\tfor (i = 0; i <  lfs->lfs_num; i++) {\n\t\tif (!lfs->lf[i].wqe)\n\t\t\tcontinue;\n\n\t\ttasklet_kill(&lfs->lf[i].wqe->work);\n\t\tkfree(lfs->lf[i].wqe);\n\t\tlfs->lf[i].wqe = NULL;\n\t}\n}\n\nstatic int init_tasklet_work(struct otx2_cptlfs_info *lfs)\n{\n\tstruct otx2_cptlf_wqe *wqe;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < lfs->lfs_num; i++) {\n\t\twqe = kzalloc(sizeof(struct otx2_cptlf_wqe), GFP_KERNEL);\n\t\tif (!wqe) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto cleanup_tasklet;\n\t\t}\n\n\t\ttasklet_init(&wqe->work, cptlf_work_handler, (u64) wqe);\n\t\twqe->lfs = lfs;\n\t\twqe->lf_num = i;\n\t\tlfs->lf[i].wqe = wqe;\n\t}\n\treturn 0;\n\ncleanup_tasklet:\n\tcleanup_tasklet_work(lfs);\n\treturn ret;\n}\n\nstatic void free_pending_queues(struct otx2_cptlfs_info *lfs)\n{\n\tint i;\n\n\tfor (i = 0; i < lfs->lfs_num; i++) {\n\t\tkfree(lfs->lf[i].pqueue.head);\n\t\tlfs->lf[i].pqueue.head = NULL;\n\t}\n}\n\nstatic int alloc_pending_queues(struct otx2_cptlfs_info *lfs)\n{\n\tint size, ret, i;\n\n\tif (!lfs->lfs_num)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < lfs->lfs_num; i++) {\n\t\tlfs->lf[i].pqueue.qlen = OTX2_CPT_INST_QLEN_MSGS;\n\t\tsize = lfs->lf[i].pqueue.qlen *\n\t\t       sizeof(struct otx2_cpt_pending_entry);\n\n\t\tlfs->lf[i].pqueue.head = kzalloc(size, GFP_KERNEL);\n\t\tif (!lfs->lf[i].pqueue.head) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tspin_lock_init(&lfs->lf[i].pqueue.lock);\n\t}\n\treturn 0;\n\nerror:\n\tfree_pending_queues(lfs);\n\treturn ret;\n}\n\nstatic void lf_sw_cleanup(struct otx2_cptlfs_info *lfs)\n{\n\tcleanup_tasklet_work(lfs);\n\tfree_pending_queues(lfs);\n}\n\nstatic int lf_sw_init(struct otx2_cptlfs_info *lfs)\n{\n\tint ret;\n\n\tret = alloc_pending_queues(lfs);\n\tif (ret) {\n\t\tdev_err(&lfs->pdev->dev,\n\t\t\t\"Allocating pending queues failed\\n\");\n\t\treturn ret;\n\t}\n\tret = init_tasklet_work(lfs);\n\tif (ret) {\n\t\tdev_err(&lfs->pdev->dev,\n\t\t\t\"Tasklet work init failed\\n\");\n\t\tgoto pending_queues_free;\n\t}\n\treturn 0;\n\npending_queues_free:\n\tfree_pending_queues(lfs);\n\treturn ret;\n}\n\nstatic void cptvf_lf_shutdown(struct otx2_cptlfs_info *lfs)\n{\n\tatomic_set(&lfs->state, OTX2_CPTLF_IN_RESET);\n\n\t \n\totx2_cptlf_free_irqs_affinity(lfs);\n\t \n\totx2_cptlf_disable_iqueues(lfs);\n\t \n\totx2_cpt_crypto_exit(lfs->pdev, THIS_MODULE);\n\t \n\totx2_cptlf_unregister_interrupts(lfs);\n\t \n\tlf_sw_cleanup(lfs);\n\t \n\totx2_cpt_detach_rsrcs_msg(lfs);\n}\n\nstatic int cptvf_lf_init(struct otx2_cptvf_dev *cptvf)\n{\n\tstruct otx2_cptlfs_info *lfs = &cptvf->lfs;\n\tstruct device *dev = &cptvf->pdev->dev;\n\tint ret, lfs_num;\n\tu8 eng_grp_msk;\n\n\t \n\tcptvf->lfs.kcrypto_eng_grp_num = OTX2_CPT_INVALID_CRYPTO_ENG_GRP;\n\tret = otx2_cptvf_send_eng_grp_num_msg(cptvf, OTX2_CPT_SE_TYPES);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cptvf->lfs.kcrypto_eng_grp_num == OTX2_CPT_INVALID_CRYPTO_ENG_GRP) {\n\t\tdev_err(dev, \"Engine group for kernel crypto not available\\n\");\n\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\teng_grp_msk = 1 << cptvf->lfs.kcrypto_eng_grp_num;\n\n\tret = otx2_cptvf_send_kvf_limits_msg(cptvf);\n\tif (ret)\n\t\treturn ret;\n\n\tlfs_num = cptvf->lfs.kvf_limits ? cptvf->lfs.kvf_limits :\n\t\t  num_online_cpus();\n\n\totx2_cptlf_set_dev_info(lfs, cptvf->pdev, cptvf->reg_base,\n\t\t\t\t&cptvf->pfvf_mbox, cptvf->blkaddr);\n\tret = otx2_cptlf_init(lfs, eng_grp_msk, OTX2_CPT_QUEUE_HI_PRIO,\n\t\t\t      lfs_num);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = otx2_cpt_msix_offset_msg(lfs);\n\tif (ret)\n\t\tgoto cleanup_lf;\n\n\t \n\tret = lf_sw_init(lfs);\n\tif (ret)\n\t\tgoto cleanup_lf;\n\n\t \n\tret = otx2_cptlf_register_interrupts(lfs);\n\tif (ret)\n\t\tgoto cleanup_lf_sw;\n\n\t \n\tret = otx2_cptlf_set_irqs_affinity(lfs);\n\tif (ret)\n\t\tgoto unregister_intr;\n\n\tatomic_set(&lfs->state, OTX2_CPTLF_STARTED);\n\t \n\tret = otx2_cpt_crypto_init(lfs->pdev, THIS_MODULE, lfs_num, 1);\n\tif (ret) {\n\t\tdev_err(&lfs->pdev->dev, \"algorithms registration failed\\n\");\n\t\tgoto disable_irqs;\n\t}\n\treturn 0;\n\ndisable_irqs:\n\totx2_cptlf_free_irqs_affinity(lfs);\nunregister_intr:\n\totx2_cptlf_unregister_interrupts(lfs);\ncleanup_lf_sw:\n\tlf_sw_cleanup(lfs);\ncleanup_lf:\n\totx2_cptlf_shutdown(lfs);\n\n\treturn ret;\n}\n\nstatic int otx2_cptvf_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct otx2_cptvf_dev *cptvf;\n\tint ret;\n\n\tcptvf = devm_kzalloc(dev, sizeof(*cptvf), GFP_KERNEL);\n\tif (!cptvf)\n\t\treturn -ENOMEM;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable PCI device\\n\");\n\t\tgoto clear_drvdata;\n\t}\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(48));\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to get usable DMA configuration\\n\");\n\t\tgoto clear_drvdata;\n\t}\n\t \n\tret = pcim_iomap_regions_request_all(pdev, 1 << PCI_PF_REG_BAR_NUM,\n\t\t\t\t\t     OTX2_CPTVF_DRV_NAME);\n\tif (ret) {\n\t\tdev_err(dev, \"Couldn't get PCI resources 0x%x\\n\", ret);\n\t\tgoto clear_drvdata;\n\t}\n\tpci_set_master(pdev);\n\tpci_set_drvdata(pdev, cptvf);\n\tcptvf->pdev = pdev;\n\n\tcptvf->reg_base = pcim_iomap_table(pdev)[PCI_PF_REG_BAR_NUM];\n\n\totx2_cpt_set_hw_caps(pdev, &cptvf->cap_flag);\n\n\tret = cn10k_cptvf_lmtst_init(cptvf);\n\tif (ret)\n\t\tgoto clear_drvdata;\n\n\t \n\tret = cptvf_pfvf_mbox_init(cptvf);\n\tif (ret)\n\t\tgoto clear_drvdata;\n\n\t \n\tret = cptvf_register_interrupts(cptvf);\n\tif (ret)\n\t\tgoto destroy_pfvf_mbox;\n\n\tcptvf->blkaddr = BLKADDR_CPT0;\n\t \n\tret = cptvf_lf_init(cptvf);\n\tif (ret)\n\t\tgoto unregister_interrupts;\n\n\treturn 0;\n\nunregister_interrupts:\n\tcptvf_disable_pfvf_mbox_intrs(cptvf);\ndestroy_pfvf_mbox:\n\tcptvf_pfvf_mbox_destroy(cptvf);\nclear_drvdata:\n\tpci_set_drvdata(pdev, NULL);\n\n\treturn ret;\n}\n\nstatic void otx2_cptvf_remove(struct pci_dev *pdev)\n{\n\tstruct otx2_cptvf_dev *cptvf = pci_get_drvdata(pdev);\n\n\tif (!cptvf) {\n\t\tdev_err(&pdev->dev, \"Invalid CPT VF device.\\n\");\n\t\treturn;\n\t}\n\tcptvf_lf_shutdown(&cptvf->lfs);\n\t \n\tcptvf_disable_pfvf_mbox_intrs(cptvf);\n\t \n\tcptvf_pfvf_mbox_destroy(cptvf);\n\tpci_set_drvdata(pdev, NULL);\n}\n\n \nstatic const struct pci_device_id otx2_cptvf_id_table[] = {\n\t{PCI_VDEVICE(CAVIUM, OTX2_CPT_PCI_VF_DEVICE_ID), 0},\n\t{PCI_VDEVICE(CAVIUM, CN10K_CPT_PCI_VF_DEVICE_ID), 0},\n\t{ 0, }   \n};\n\nstatic struct pci_driver otx2_cptvf_pci_driver = {\n\t.name = OTX2_CPTVF_DRV_NAME,\n\t.id_table = otx2_cptvf_id_table,\n\t.probe = otx2_cptvf_probe,\n\t.remove = otx2_cptvf_remove,\n};\n\nmodule_pci_driver(otx2_cptvf_pci_driver);\n\nMODULE_IMPORT_NS(CRYPTO_DEV_OCTEONTX2_CPT);\n\nMODULE_AUTHOR(\"Marvell\");\nMODULE_DESCRIPTION(\"Marvell RVU CPT Virtual Function Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(pci, otx2_cptvf_id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}