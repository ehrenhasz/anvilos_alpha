{
  "module_name": "otx_cptpf_main.c",
  "hash_id": "117065b215a8231ec820700262838338b160ddedf8a727cad8527cbc681bb951",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/octeontx/otx_cptpf_main.c",
  "human_readable_source": "\n \n\n#include \"otx_cpt_common.h\"\n#include \"otx_cptpf.h\"\n\n#define DRV_NAME\t\"octeontx-cpt\"\n#define DRV_VERSION\t\"1.0\"\n\nstatic void otx_cpt_disable_mbox_interrupts(struct otx_cpt_device *cpt)\n{\n\t \n\twriteq(~0ull, cpt->reg_base + OTX_CPT_PF_MBOX_ENA_W1CX(0));\n}\n\nstatic void otx_cpt_enable_mbox_interrupts(struct otx_cpt_device *cpt)\n{\n\t \n\twriteq(~0ull, cpt->reg_base + OTX_CPT_PF_MBOX_ENA_W1SX(0));\n}\n\nstatic irqreturn_t otx_cpt_mbx0_intr_handler(int __always_unused irq,\n\t\t\t\t\t     void *cpt)\n{\n\totx_cpt_mbox_intr_handler(cpt, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void otx_cpt_reset(struct otx_cpt_device *cpt)\n{\n\twriteq(1, cpt->reg_base + OTX_CPT_PF_RESET);\n}\n\nstatic void otx_cpt_find_max_enabled_cores(struct otx_cpt_device *cpt)\n{\n\tunion otx_cptx_pf_constants pf_cnsts = {0};\n\n\tpf_cnsts.u = readq(cpt->reg_base + OTX_CPT_PF_CONSTANTS);\n\tcpt->eng_grps.avail.max_se_cnt = pf_cnsts.s.se;\n\tcpt->eng_grps.avail.max_ae_cnt = pf_cnsts.s.ae;\n}\n\nstatic u32 otx_cpt_check_bist_status(struct otx_cpt_device *cpt)\n{\n\tunion otx_cptx_pf_bist_status bist_sts = {0};\n\n\tbist_sts.u = readq(cpt->reg_base + OTX_CPT_PF_BIST_STATUS);\n\treturn bist_sts.u;\n}\n\nstatic u64 otx_cpt_check_exe_bist_status(struct otx_cpt_device *cpt)\n{\n\tunion otx_cptx_pf_exe_bist_status bist_sts = {0};\n\n\tbist_sts.u = readq(cpt->reg_base + OTX_CPT_PF_EXE_BIST_STATUS);\n\treturn bist_sts.u;\n}\n\nstatic int otx_cpt_device_init(struct otx_cpt_device *cpt)\n{\n\tstruct device *dev = &cpt->pdev->dev;\n\tu16 sdevid;\n\tu64 bist;\n\n\t \n\totx_cpt_reset(cpt);\n\tmdelay(100);\n\n\tpci_read_config_word(cpt->pdev, PCI_SUBSYSTEM_ID, &sdevid);\n\n\t \n\tbist = (u64)otx_cpt_check_bist_status(cpt);\n\tif (bist) {\n\t\tdev_err(dev, \"RAM BIST failed with code 0x%llx\\n\", bist);\n\t\treturn -ENODEV;\n\t}\n\n\tbist = otx_cpt_check_exe_bist_status(cpt);\n\tif (bist) {\n\t\tdev_err(dev, \"Engine BIST failed with code 0x%llx\\n\", bist);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\totx_cpt_find_max_enabled_cores(cpt);\n\n\tif ((sdevid == OTX_CPT_PCI_PF_SUBSYS_ID) &&\n\t    (cpt->eng_grps.avail.max_se_cnt == 0)) {\n\t\tcpt->pf_type = OTX_CPT_AE;\n\t} else if ((sdevid == OTX_CPT_PCI_PF_SUBSYS_ID) &&\n\t\t   (cpt->eng_grps.avail.max_ae_cnt == 0)) {\n\t\tcpt->pf_type = OTX_CPT_SE;\n\t}\n\n\t \n\tcpt->max_vfs = pci_sriov_get_totalvfs(cpt->pdev);\n\n\t \n\totx_cpt_disable_all_cores(cpt);\n\n\treturn 0;\n}\n\nstatic int otx_cpt_register_interrupts(struct otx_cpt_device *cpt)\n{\n\tstruct device *dev = &cpt->pdev->dev;\n\tu32 mbox_int_idx = OTX_CPT_PF_MBOX_INT;\n\tu32 num_vec = OTX_CPT_PF_MSIX_VECTORS;\n\tint ret;\n\n\t \n\tret = pci_alloc_irq_vectors(cpt->pdev, num_vec, num_vec, PCI_IRQ_MSIX);\n\tif (ret < 0) {\n\t\tdev_err(&cpt->pdev->dev,\n\t\t\t\"Request for #%d msix vectors failed\\n\",\n\t\t\tnum_vec);\n\t\treturn ret;\n\t}\n\n\t \n\tret = request_irq(pci_irq_vector(cpt->pdev,\n\t\t\t\tOTX_CPT_PF_INT_VEC_E_MBOXX(mbox_int_idx, 0)),\n\t\t\t\totx_cpt_mbx0_intr_handler, 0, \"CPT Mbox0\", cpt);\n\tif (ret) {\n\t\tdev_err(dev, \"Request irq failed\\n\");\n\t\tpci_free_irq_vectors(cpt->pdev);\n\t\treturn ret;\n\t}\n\t \n\totx_cpt_enable_mbox_interrupts(cpt);\n\treturn 0;\n}\n\nstatic void otx_cpt_unregister_interrupts(struct otx_cpt_device *cpt)\n{\n\tu32 mbox_int_idx = OTX_CPT_PF_MBOX_INT;\n\n\totx_cpt_disable_mbox_interrupts(cpt);\n\tfree_irq(pci_irq_vector(cpt->pdev,\n\t\t\t\tOTX_CPT_PF_INT_VEC_E_MBOXX(mbox_int_idx, 0)),\n\t\t\t\tcpt);\n\tpci_free_irq_vectors(cpt->pdev);\n}\n\n\nstatic int otx_cpt_sriov_configure(struct pci_dev *pdev, int numvfs)\n{\n\tstruct otx_cpt_device *cpt = pci_get_drvdata(pdev);\n\tint ret = 0;\n\n\tif (numvfs > cpt->max_vfs)\n\t\tnumvfs = cpt->max_vfs;\n\n\tif (numvfs > 0) {\n\t\tret = otx_cpt_try_create_default_eng_grps(cpt->pdev,\n\t\t\t\t\t\t\t  &cpt->eng_grps,\n\t\t\t\t\t\t\t  cpt->pf_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcpt->vfs_enabled = numvfs;\n\t\tret = pci_enable_sriov(pdev, numvfs);\n\t\tif (ret) {\n\t\t\tcpt->vfs_enabled = 0;\n\t\t\treturn ret;\n\t\t}\n\t\totx_cpt_set_eng_grps_is_rdonly(&cpt->eng_grps, true);\n\t\ttry_module_get(THIS_MODULE);\n\t\tret = numvfs;\n\t} else {\n\t\tpci_disable_sriov(pdev);\n\t\totx_cpt_set_eng_grps_is_rdonly(&cpt->eng_grps, false);\n\t\tmodule_put(THIS_MODULE);\n\t\tcpt->vfs_enabled = 0;\n\t}\n\tdev_notice(&cpt->pdev->dev, \"VFs enabled: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int otx_cpt_probe(struct pci_dev *pdev,\n\t\t\t const struct pci_device_id __always_unused *ent)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct otx_cpt_device *cpt;\n\tint err;\n\n\tcpt = devm_kzalloc(dev, sizeof(*cpt), GFP_KERNEL);\n\tif (!cpt)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(pdev, cpt);\n\tcpt->pdev = pdev;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to enable PCI device\\n\");\n\t\tgoto err_clear_drvdata;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\tdev_err(dev, \"PCI request regions failed 0x%x\\n\", err);\n\t\tgoto err_disable_device;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(48));\n\tif (err) {\n\t\tdev_err(dev, \"Unable to get usable 48-bit DMA configuration\\n\");\n\t\tgoto err_release_regions;\n\t}\n\n\t \n\tcpt->reg_base = pci_iomap(pdev, OTX_CPT_PF_PCI_CFG_BAR, 0);\n\tif (!cpt->reg_base) {\n\t\tdev_err(dev, \"Cannot map config register space, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_release_regions;\n\t}\n\n\t \n\terr = otx_cpt_device_init(cpt);\n\tif (err)\n\t\tgoto err_unmap_region;\n\n\t \n\terr = otx_cpt_register_interrupts(cpt);\n\tif (err)\n\t\tgoto err_unmap_region;\n\n\t \n\terr = otx_cpt_init_eng_grps(pdev, &cpt->eng_grps, cpt->pf_type);\n\tif (err)\n\t\tgoto err_unregister_interrupts;\n\n\treturn 0;\n\nerr_unregister_interrupts:\n\totx_cpt_unregister_interrupts(cpt);\nerr_unmap_region:\n\tpci_iounmap(pdev, cpt->reg_base);\nerr_release_regions:\n\tpci_release_regions(pdev);\nerr_disable_device:\n\tpci_disable_device(pdev);\nerr_clear_drvdata:\n\tpci_set_drvdata(pdev, NULL);\n\n\treturn err;\n}\n\nstatic void otx_cpt_remove(struct pci_dev *pdev)\n{\n\tstruct otx_cpt_device *cpt = pci_get_drvdata(pdev);\n\n\tif (!cpt)\n\t\treturn;\n\n\t \n\tpci_disable_sriov(pdev);\n\t \n\totx_cpt_cleanup_eng_grps(pdev, &cpt->eng_grps);\n\t \n\totx_cpt_unregister_interrupts(cpt);\n\t \n\totx_cpt_disable_all_cores(cpt);\n\tpci_iounmap(pdev, cpt->reg_base);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_drvdata(pdev, NULL);\n}\n\n \nstatic const struct pci_device_id otx_cpt_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, OTX_CPT_PCI_PF_DEVICE_ID) },\n\t{ 0, }   \n};\n\nstatic struct pci_driver otx_cpt_pci_driver = {\n\t.name = DRV_NAME,\n\t.id_table = otx_cpt_id_table,\n\t.probe = otx_cpt_probe,\n\t.remove = otx_cpt_remove,\n\t.sriov_configure = otx_cpt_sriov_configure\n};\n\nmodule_pci_driver(otx_cpt_pci_driver);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell OcteonTX CPT Physical Function Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_DEVICE_TABLE(pci, otx_cpt_id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}