{
  "module_name": "otx_cptpf_ucode.c",
  "hash_id": "13cdef3e09b3a64ce050601ae725e606c2b0c9ed753d5ac3adf0cfac635a2695",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/octeontx/otx_cptpf_ucode.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/firmware.h>\n#include \"otx_cpt_common.h\"\n#include \"otx_cptpf_ucode.h\"\n#include \"otx_cptpf.h\"\n\n#define CSR_DELAY 30\n \n#define TAR_MAGIC\t\t\"ustar\"\n#define TAR_MAGIC_LEN\t\t6\n#define TAR_BLOCK_LEN\t\t512\n#define REGTYPE\t\t\t'0'\n#define AREGTYPE\t\t'\\0'\n\n \nstruct tar_hdr_t {\n\tchar name[100];\n\tchar mode[8];\n\tchar uid[8];\n\tchar gid[8];\n\tchar size[12];\n\tchar mtime[12];\n\tchar chksum[8];\n\tchar typeflag;\n\tchar linkname[100];\n\tchar magic[6];\n\tchar version[2];\n\tchar uname[32];\n\tchar gname[32];\n\tchar devmajor[8];\n\tchar devminor[8];\n\tchar prefix[155];\n};\n\nstruct tar_blk_t {\n\tunion {\n\t\tstruct tar_hdr_t hdr;\n\t\tchar block[TAR_BLOCK_LEN];\n\t};\n};\n\nstruct tar_arch_info_t {\n\tstruct list_head ucodes;\n\tconst struct firmware *fw;\n};\n\nstatic struct otx_cpt_bitmap get_cores_bmap(struct device *dev,\n\t\t\t\t\t   struct otx_cpt_eng_grp_info *eng_grp)\n{\n\tstruct otx_cpt_bitmap bmap = { {0} };\n\tbool found = false;\n\tint i;\n\n\tif (eng_grp->g->engs_num > OTX_CPT_MAX_ENGINES) {\n\t\tdev_err(dev, \"unsupported number of engines %d on octeontx\\n\",\n\t\t\teng_grp->g->engs_num);\n\t\treturn bmap;\n\t}\n\n\tfor (i = 0; i < OTX_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tif (eng_grp->engs[i].type) {\n\t\t\tbitmap_or(bmap.bits, bmap.bits,\n\t\t\t\t  eng_grp->engs[i].bmap,\n\t\t\t\t  eng_grp->g->engs_num);\n\t\t\tbmap.size = eng_grp->g->engs_num;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tdev_err(dev, \"No engines reserved for engine group %d\\n\",\n\t\t\teng_grp->idx);\n\treturn bmap;\n}\n\nstatic int is_eng_type(int val, int eng_type)\n{\n\treturn val & (1 << eng_type);\n}\n\nstatic int dev_supports_eng_type(struct otx_cpt_eng_grps *eng_grps,\n\t\t\t\t int eng_type)\n{\n\treturn is_eng_type(eng_grps->eng_types_supported, eng_type);\n}\n\nstatic void set_ucode_filename(struct otx_cpt_ucode *ucode,\n\t\t\t       const char *filename)\n{\n\tstrscpy(ucode->filename, filename, OTX_CPT_UCODE_NAME_LENGTH);\n}\n\nstatic char *get_eng_type_str(int eng_type)\n{\n\tchar *str = \"unknown\";\n\n\tswitch (eng_type) {\n\tcase OTX_CPT_SE_TYPES:\n\t\tstr = \"SE\";\n\t\tbreak;\n\n\tcase OTX_CPT_AE_TYPES:\n\t\tstr = \"AE\";\n\t\tbreak;\n\t}\n\treturn str;\n}\n\nstatic char *get_ucode_type_str(int ucode_type)\n{\n\tchar *str = \"unknown\";\n\n\tswitch (ucode_type) {\n\tcase (1 << OTX_CPT_SE_TYPES):\n\t\tstr = \"SE\";\n\t\tbreak;\n\n\tcase (1 << OTX_CPT_AE_TYPES):\n\t\tstr = \"AE\";\n\t\tbreak;\n\t}\n\treturn str;\n}\n\nstatic int get_ucode_type(struct otx_cpt_ucode_hdr *ucode_hdr, int *ucode_type)\n{\n\tchar tmp_ver_str[OTX_CPT_UCODE_VER_STR_SZ];\n\tu32 i, val = 0;\n\tu8 nn;\n\n\tstrscpy(tmp_ver_str, ucode_hdr->ver_str, OTX_CPT_UCODE_VER_STR_SZ);\n\tfor (i = 0; i < strlen(tmp_ver_str); i++)\n\t\ttmp_ver_str[i] = tolower(tmp_ver_str[i]);\n\n\tnn = ucode_hdr->ver_num.nn;\n\tif (strnstr(tmp_ver_str, \"se-\", OTX_CPT_UCODE_VER_STR_SZ) &&\n\t    (nn == OTX_CPT_SE_UC_TYPE1 || nn == OTX_CPT_SE_UC_TYPE2 ||\n\t     nn == OTX_CPT_SE_UC_TYPE3))\n\t\tval |= 1 << OTX_CPT_SE_TYPES;\n\tif (strnstr(tmp_ver_str, \"ae\", OTX_CPT_UCODE_VER_STR_SZ) &&\n\t    nn == OTX_CPT_AE_UC_TYPE)\n\t\tval |= 1 << OTX_CPT_AE_TYPES;\n\n\t*ucode_type = val;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\tif (is_eng_type(val, OTX_CPT_AE_TYPES) &&\n\t    is_eng_type(val, OTX_CPT_SE_TYPES))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int is_mem_zero(const char *ptr, int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (ptr[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int cpt_set_ucode_base(struct otx_cpt_eng_grp_info *eng_grp, void *obj)\n{\n\tstruct otx_cpt_device *cpt = (struct otx_cpt_device *) obj;\n\tdma_addr_t dma_addr;\n\tstruct otx_cpt_bitmap bmap;\n\tint i;\n\n\tbmap = get_cores_bmap(&cpt->pdev->dev, eng_grp);\n\tif (!bmap.size)\n\t\treturn -EINVAL;\n\n\tif (eng_grp->mirror.is_ena)\n\t\tdma_addr =\n\t\t       eng_grp->g->grp[eng_grp->mirror.idx].ucode[0].align_dma;\n\telse\n\t\tdma_addr = eng_grp->ucode[0].align_dma;\n\n\t \n\tfor_each_set_bit(i, bmap.bits, bmap.size)\n\t\tif (!eng_grp->g->eng_ref_cnt[i])\n\t\t\twriteq((u64) dma_addr, cpt->reg_base +\n\t\t\t\tOTX_CPT_PF_ENGX_UCODE_BASE(i));\n\treturn 0;\n}\n\nstatic int cpt_detach_and_disable_cores(struct otx_cpt_eng_grp_info *eng_grp,\n\t\t\t\t\tvoid *obj)\n{\n\tstruct otx_cpt_device *cpt = (struct otx_cpt_device *) obj;\n\tstruct otx_cpt_bitmap bmap = { {0} };\n\tint timeout = 10;\n\tint i, busy;\n\tu64 reg;\n\n\tbmap = get_cores_bmap(&cpt->pdev->dev, eng_grp);\n\tif (!bmap.size)\n\t\treturn -EINVAL;\n\n\t \n\treg = readq(cpt->reg_base + OTX_CPT_PF_GX_EN(eng_grp->idx));\n\tfor_each_set_bit(i, bmap.bits, bmap.size) {\n\t\tif (reg & (1ull << i)) {\n\t\t\teng_grp->g->eng_ref_cnt[i]--;\n\t\t\treg &= ~(1ull << i);\n\t\t}\n\t}\n\twriteq(reg, cpt->reg_base + OTX_CPT_PF_GX_EN(eng_grp->idx));\n\n\t \n\tdo {\n\t\tbusy = 0;\n\t\tusleep_range(10000, 20000);\n\t\tif (timeout-- < 0)\n\t\t\treturn -EBUSY;\n\n\t\treg = readq(cpt->reg_base + OTX_CPT_PF_EXEC_BUSY);\n\t\tfor_each_set_bit(i, bmap.bits, bmap.size)\n\t\t\tif (reg & (1ull << i)) {\n\t\t\t\tbusy = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t} while (busy);\n\n\t \n\treg = readq(cpt->reg_base + OTX_CPT_PF_EXE_CTL);\n\tfor_each_set_bit(i, bmap.bits, bmap.size)\n\t\tif (!eng_grp->g->eng_ref_cnt[i])\n\t\t\treg &= ~(1ull << i);\n\twriteq(reg, cpt->reg_base + OTX_CPT_PF_EXE_CTL);\n\n\treturn 0;\n}\n\nstatic int cpt_attach_and_enable_cores(struct otx_cpt_eng_grp_info *eng_grp,\n\t\t\t\t       void *obj)\n{\n\tstruct otx_cpt_device *cpt = (struct otx_cpt_device *) obj;\n\tstruct otx_cpt_bitmap bmap;\n\tu64 reg;\n\tint i;\n\n\tbmap = get_cores_bmap(&cpt->pdev->dev, eng_grp);\n\tif (!bmap.size)\n\t\treturn -EINVAL;\n\n\t \n\treg = readq(cpt->reg_base + OTX_CPT_PF_GX_EN(eng_grp->idx));\n\tfor_each_set_bit(i, bmap.bits, bmap.size) {\n\t\tif (!(reg & (1ull << i))) {\n\t\t\teng_grp->g->eng_ref_cnt[i]++;\n\t\t\treg |= 1ull << i;\n\t\t}\n\t}\n\twriteq(reg, cpt->reg_base + OTX_CPT_PF_GX_EN(eng_grp->idx));\n\n\t \n\treg = readq(cpt->reg_base + OTX_CPT_PF_EXE_CTL);\n\tfor_each_set_bit(i, bmap.bits, bmap.size)\n\t\treg |= 1ull << i;\n\twriteq(reg, cpt->reg_base + OTX_CPT_PF_EXE_CTL);\n\n\treturn 0;\n}\n\nstatic int process_tar_file(struct device *dev,\n\t\t\t    struct tar_arch_info_t *tar_arch, char *filename,\n\t\t\t    const u8 *data, u32 size)\n{\n\tstruct tar_ucode_info_t *tar_info;\n\tstruct otx_cpt_ucode_hdr *ucode_hdr;\n\tint ucode_type, ucode_size;\n\tunsigned int code_length;\n\n\t \n\tif (size < sizeof(struct otx_cpt_ucode_hdr))\n\t\treturn 0;\n\n\tucode_hdr = (struct otx_cpt_ucode_hdr *) data;\n\t \n\tif (get_ucode_type(ucode_hdr, &ucode_type))\n\t\treturn 0;\n\n\tcode_length = ntohl(ucode_hdr->code_length);\n\tif (code_length >= INT_MAX / 2) {\n\t\tdev_err(dev, \"Invalid code_length %u\\n\", code_length);\n\t\treturn -EINVAL;\n\t}\n\n\tucode_size = code_length * 2;\n\tif (!ucode_size || (size < round_up(ucode_size, 16) +\n\t    sizeof(struct otx_cpt_ucode_hdr) + OTX_CPT_UCODE_SIGN_LEN)) {\n\t\tdev_err(dev, \"Ucode %s invalid size\\n\", filename);\n\t\treturn -EINVAL;\n\t}\n\n\ttar_info = kzalloc(sizeof(struct tar_ucode_info_t), GFP_KERNEL);\n\tif (!tar_info)\n\t\treturn -ENOMEM;\n\n\ttar_info->ucode_ptr = data;\n\tset_ucode_filename(&tar_info->ucode, filename);\n\tmemcpy(tar_info->ucode.ver_str, ucode_hdr->ver_str,\n\t       OTX_CPT_UCODE_VER_STR_SZ);\n\ttar_info->ucode.ver_num = ucode_hdr->ver_num;\n\ttar_info->ucode.type = ucode_type;\n\ttar_info->ucode.size = ucode_size;\n\tlist_add_tail(&tar_info->list, &tar_arch->ucodes);\n\n\treturn 0;\n}\n\nstatic void release_tar_archive(struct tar_arch_info_t *tar_arch)\n{\n\tstruct tar_ucode_info_t *curr, *temp;\n\n\tif (!tar_arch)\n\t\treturn;\n\n\tlist_for_each_entry_safe(curr, temp, &tar_arch->ucodes, list) {\n\t\tlist_del(&curr->list);\n\t\tkfree(curr);\n\t}\n\n\trelease_firmware(tar_arch->fw);\n\tkfree(tar_arch);\n}\n\nstatic struct tar_ucode_info_t *get_uc_from_tar_archive(\n\t\t\t\t\tstruct tar_arch_info_t *tar_arch,\n\t\t\t\t\tint ucode_type)\n{\n\tstruct tar_ucode_info_t *curr, *uc_found = NULL;\n\n\tlist_for_each_entry(curr, &tar_arch->ucodes, list) {\n\t\tif (!is_eng_type(curr->ucode.type, ucode_type))\n\t\t\tcontinue;\n\n\t\tif (!uc_found) {\n\t\t\tuc_found = curr;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (ucode_type) {\n\t\tcase OTX_CPT_AE_TYPES:\n\t\t\tbreak;\n\n\t\tcase OTX_CPT_SE_TYPES:\n\t\t\tif (uc_found->ucode.ver_num.nn == OTX_CPT_SE_UC_TYPE2 ||\n\t\t\t    (uc_found->ucode.ver_num.nn == OTX_CPT_SE_UC_TYPE3\n\t\t\t     && curr->ucode.ver_num.nn == OTX_CPT_SE_UC_TYPE1))\n\t\t\t\tuc_found = curr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn uc_found;\n}\n\nstatic void print_tar_dbg_info(struct tar_arch_info_t *tar_arch,\n\t\t\t       char *tar_filename)\n{\n\tstruct tar_ucode_info_t *curr;\n\n\tpr_debug(\"Tar archive filename %s\\n\", tar_filename);\n\tpr_debug(\"Tar archive pointer %p, size %ld\\n\", tar_arch->fw->data,\n\t\t tar_arch->fw->size);\n\tlist_for_each_entry(curr, &tar_arch->ucodes, list) {\n\t\tpr_debug(\"Ucode filename %s\\n\", curr->ucode.filename);\n\t\tpr_debug(\"Ucode version string %s\\n\", curr->ucode.ver_str);\n\t\tpr_debug(\"Ucode version %d.%d.%d.%d\\n\",\n\t\t\t curr->ucode.ver_num.nn, curr->ucode.ver_num.xx,\n\t\t\t curr->ucode.ver_num.yy, curr->ucode.ver_num.zz);\n\t\tpr_debug(\"Ucode type (%d) %s\\n\", curr->ucode.type,\n\t\t\t get_ucode_type_str(curr->ucode.type));\n\t\tpr_debug(\"Ucode size %d\\n\", curr->ucode.size);\n\t\tpr_debug(\"Ucode ptr %p\\n\", curr->ucode_ptr);\n\t}\n}\n\nstatic struct tar_arch_info_t *load_tar_archive(struct device *dev,\n\t\t\t\t\t\tchar *tar_filename)\n{\n\tstruct tar_arch_info_t *tar_arch = NULL;\n\tstruct tar_blk_t *tar_blk;\n\tunsigned int cur_size;\n\tsize_t tar_offs = 0;\n\tsize_t tar_size;\n\tint ret;\n\n\ttar_arch = kzalloc(sizeof(struct tar_arch_info_t), GFP_KERNEL);\n\tif (!tar_arch)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&tar_arch->ucodes);\n\n\t \n\tret = request_firmware(&tar_arch->fw, tar_filename, dev);\n\tif (ret)\n\t\tgoto release_tar_arch;\n\n\tif (tar_arch->fw->size < TAR_BLOCK_LEN) {\n\t\tdev_err(dev, \"Invalid tar archive %s\\n\", tar_filename);\n\t\tgoto release_tar_arch;\n\t}\n\n\ttar_size = tar_arch->fw->size;\n\ttar_blk = (struct tar_blk_t *) tar_arch->fw->data;\n\tif (strncmp(tar_blk->hdr.magic, TAR_MAGIC, TAR_MAGIC_LEN - 1)) {\n\t\tdev_err(dev, \"Unsupported format of tar archive %s\\n\",\n\t\t\ttar_filename);\n\t\tgoto release_tar_arch;\n\t}\n\n\twhile (1) {\n\t\t \n\t\tret = kstrtouint(tar_blk->hdr.size, 8, &cur_size);\n\t\tif (ret)\n\t\t\tgoto release_tar_arch;\n\n\t\tif (tar_offs + cur_size > tar_size ||\n\t\t    tar_offs + 2*TAR_BLOCK_LEN > tar_size) {\n\t\t\tdev_err(dev, \"Invalid tar archive %s\\n\", tar_filename);\n\t\t\tgoto release_tar_arch;\n\t\t}\n\n\t\ttar_offs += TAR_BLOCK_LEN;\n\t\tif (tar_blk->hdr.typeflag == REGTYPE ||\n\t\t    tar_blk->hdr.typeflag == AREGTYPE) {\n\t\t\tret = process_tar_file(dev, tar_arch,\n\t\t\t\t\t       tar_blk->hdr.name,\n\t\t\t\t\t       &tar_arch->fw->data[tar_offs],\n\t\t\t\t\t       cur_size);\n\t\t\tif (ret)\n\t\t\t\tgoto release_tar_arch;\n\t\t}\n\n\t\ttar_offs += (cur_size/TAR_BLOCK_LEN) * TAR_BLOCK_LEN;\n\t\tif (cur_size % TAR_BLOCK_LEN)\n\t\t\ttar_offs += TAR_BLOCK_LEN;\n\n\t\t \n\t\tif (tar_offs + 2*TAR_BLOCK_LEN > tar_size) {\n\t\t\tdev_err(dev, \"Invalid tar archive %s\\n\", tar_filename);\n\t\t\tgoto release_tar_arch;\n\t\t}\n\n\t\tif (is_mem_zero(&tar_arch->fw->data[tar_offs],\n\t\t    2*TAR_BLOCK_LEN))\n\t\t\tbreak;\n\n\t\t \n\t\ttar_blk = (struct tar_blk_t *) &tar_arch->fw->data[tar_offs];\n\t}\n\n\tprint_tar_dbg_info(tar_arch, tar_filename);\n\treturn tar_arch;\nrelease_tar_arch:\n\trelease_tar_archive(tar_arch);\n\treturn NULL;\n}\n\nstatic struct otx_cpt_engs_rsvd *find_engines_by_type(\n\t\t\t\t\tstruct otx_cpt_eng_grp_info *eng_grp,\n\t\t\t\t\tint eng_type)\n{\n\tint i;\n\n\tfor (i = 0; i < OTX_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tif (!eng_grp->engs[i].type)\n\t\t\tcontinue;\n\n\t\tif (eng_grp->engs[i].type == eng_type)\n\t\t\treturn &eng_grp->engs[i];\n\t}\n\treturn NULL;\n}\n\nint otx_cpt_uc_supports_eng_type(struct otx_cpt_ucode *ucode, int eng_type)\n{\n\treturn is_eng_type(ucode->type, eng_type);\n}\nEXPORT_SYMBOL_GPL(otx_cpt_uc_supports_eng_type);\n\nint otx_cpt_eng_grp_has_eng_type(struct otx_cpt_eng_grp_info *eng_grp,\n\t\t\t\t int eng_type)\n{\n\tstruct otx_cpt_engs_rsvd *engs;\n\n\tengs = find_engines_by_type(eng_grp, eng_type);\n\n\treturn (engs != NULL ? 1 : 0);\n}\nEXPORT_SYMBOL_GPL(otx_cpt_eng_grp_has_eng_type);\n\nstatic void print_ucode_info(struct otx_cpt_eng_grp_info *eng_grp,\n\t\t\t     char *buf, int size)\n{\n\tif (eng_grp->mirror.is_ena) {\n\t\tscnprintf(buf, size, \"%s (shared with engine_group%d)\",\n\t\t\t  eng_grp->g->grp[eng_grp->mirror.idx].ucode[0].ver_str,\n\t\t\t  eng_grp->mirror.idx);\n\t} else {\n\t\tscnprintf(buf, size, \"%s\", eng_grp->ucode[0].ver_str);\n\t}\n}\n\nstatic void print_engs_info(struct otx_cpt_eng_grp_info *eng_grp,\n\t\t\t    char *buf, int size, int idx)\n{\n\tstruct otx_cpt_engs_rsvd *mirrored_engs = NULL;\n\tstruct otx_cpt_engs_rsvd *engs;\n\tint len, i;\n\n\tbuf[0] = '\\0';\n\tfor (i = 0; i < OTX_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tengs = &eng_grp->engs[i];\n\t\tif (!engs->type)\n\t\t\tcontinue;\n\t\tif (idx != -1 && idx != i)\n\t\t\tcontinue;\n\n\t\tif (eng_grp->mirror.is_ena)\n\t\t\tmirrored_engs = find_engines_by_type(\n\t\t\t\t\t&eng_grp->g->grp[eng_grp->mirror.idx],\n\t\t\t\t\tengs->type);\n\t\tif (i > 0 && idx == -1) {\n\t\t\tlen = strlen(buf);\n\t\t\tscnprintf(buf+len, size-len, \", \");\n\t\t}\n\n\t\tlen = strlen(buf);\n\t\tscnprintf(buf+len, size-len, \"%d %s \", mirrored_engs ?\n\t\t\t  engs->count + mirrored_engs->count : engs->count,\n\t\t\t  get_eng_type_str(engs->type));\n\t\tif (mirrored_engs) {\n\t\t\tlen = strlen(buf);\n\t\t\tscnprintf(buf+len, size-len,\n\t\t\t\t  \"(%d shared with engine_group%d) \",\n\t\t\t\t  engs->count <= 0 ? engs->count +\n\t\t\t\t  mirrored_engs->count : mirrored_engs->count,\n\t\t\t\t  eng_grp->mirror.idx);\n\t\t}\n\t}\n}\n\nstatic void print_ucode_dbg_info(struct otx_cpt_ucode *ucode)\n{\n\tpr_debug(\"Ucode info\\n\");\n\tpr_debug(\"Ucode version string %s\\n\", ucode->ver_str);\n\tpr_debug(\"Ucode version %d.%d.%d.%d\\n\", ucode->ver_num.nn,\n\t\t ucode->ver_num.xx, ucode->ver_num.yy, ucode->ver_num.zz);\n\tpr_debug(\"Ucode type %s\\n\", get_ucode_type_str(ucode->type));\n\tpr_debug(\"Ucode size %d\\n\", ucode->size);\n\tpr_debug(\"Ucode virt address %16.16llx\\n\", (u64)ucode->align_va);\n\tpr_debug(\"Ucode phys address %16.16llx\\n\", ucode->align_dma);\n}\n\nstatic void cpt_print_engines_mask(struct otx_cpt_eng_grp_info *eng_grp,\n\t\t\t\t   struct device *dev, char *buf, int size)\n{\n\tstruct otx_cpt_bitmap bmap;\n\tu32 mask[2];\n\n\tbmap = get_cores_bmap(dev, eng_grp);\n\tif (!bmap.size) {\n\t\tscnprintf(buf, size, \"unknown\");\n\t\treturn;\n\t}\n\tbitmap_to_arr32(mask, bmap.bits, bmap.size);\n\tscnprintf(buf, size, \"%8.8x %8.8x\", mask[1], mask[0]);\n}\n\n\nstatic void print_dbg_info(struct device *dev,\n\t\t\t   struct otx_cpt_eng_grps *eng_grps)\n{\n\tchar engs_info[2*OTX_CPT_UCODE_NAME_LENGTH];\n\tstruct otx_cpt_eng_grp_info *mirrored_grp;\n\tchar engs_mask[OTX_CPT_UCODE_NAME_LENGTH];\n\tstruct otx_cpt_eng_grp_info *grp;\n\tstruct otx_cpt_engs_rsvd *engs;\n\tu32 mask[4];\n\tint i, j;\n\n\tpr_debug(\"Engine groups global info\\n\");\n\tpr_debug(\"max SE %d, max AE %d\\n\",\n\t\t eng_grps->avail.max_se_cnt, eng_grps->avail.max_ae_cnt);\n\tpr_debug(\"free SE %d\\n\", eng_grps->avail.se_cnt);\n\tpr_debug(\"free AE %d\\n\", eng_grps->avail.ae_cnt);\n\n\tfor (i = 0; i < OTX_CPT_MAX_ENGINE_GROUPS; i++) {\n\t\tgrp = &eng_grps->grp[i];\n\t\tpr_debug(\"engine_group%d, state %s\\n\", i, grp->is_enabled ?\n\t\t\t \"enabled\" : \"disabled\");\n\t\tif (grp->is_enabled) {\n\t\t\tmirrored_grp = &eng_grps->grp[grp->mirror.idx];\n\t\t\tpr_debug(\"Ucode0 filename %s, version %s\\n\",\n\t\t\t\t grp->mirror.is_ena ?\n\t\t\t\t mirrored_grp->ucode[0].filename :\n\t\t\t\t grp->ucode[0].filename,\n\t\t\t\t grp->mirror.is_ena ?\n\t\t\t\t mirrored_grp->ucode[0].ver_str :\n\t\t\t\t grp->ucode[0].ver_str);\n\t\t}\n\n\t\tfor (j = 0; j < OTX_CPT_MAX_ETYPES_PER_GRP; j++) {\n\t\t\tengs = &grp->engs[j];\n\t\t\tif (engs->type) {\n\t\t\t\tprint_engs_info(grp, engs_info,\n\t\t\t\t\t\t2*OTX_CPT_UCODE_NAME_LENGTH, j);\n\t\t\t\tpr_debug(\"Slot%d: %s\\n\", j, engs_info);\n\t\t\t\tbitmap_to_arr32(mask, engs->bmap,\n\t\t\t\t\t\teng_grps->engs_num);\n\t\t\t\tpr_debug(\"Mask: %8.8x %8.8x %8.8x %8.8x\\n\",\n\t\t\t\t\t mask[3], mask[2], mask[1], mask[0]);\n\t\t\t} else\n\t\t\t\tpr_debug(\"Slot%d not used\\n\", j);\n\t\t}\n\t\tif (grp->is_enabled) {\n\t\t\tcpt_print_engines_mask(grp, dev, engs_mask,\n\t\t\t\t\t       OTX_CPT_UCODE_NAME_LENGTH);\n\t\t\tpr_debug(\"Cmask: %s\\n\", engs_mask);\n\t\t}\n\t}\n}\n\nstatic int update_engines_avail_count(struct device *dev,\n\t\t\t\t      struct otx_cpt_engs_available *avail,\n\t\t\t\t      struct otx_cpt_engs_rsvd *engs, int val)\n{\n\tswitch (engs->type) {\n\tcase OTX_CPT_SE_TYPES:\n\t\tavail->se_cnt += val;\n\t\tbreak;\n\n\tcase OTX_CPT_AE_TYPES:\n\t\tavail->ae_cnt += val;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid engine type %d\\n\", engs->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int update_engines_offset(struct device *dev,\n\t\t\t\t struct otx_cpt_engs_available *avail,\n\t\t\t\t struct otx_cpt_engs_rsvd *engs)\n{\n\tswitch (engs->type) {\n\tcase OTX_CPT_SE_TYPES:\n\t\tengs->offset = 0;\n\t\tbreak;\n\n\tcase OTX_CPT_AE_TYPES:\n\t\tengs->offset = avail->max_se_cnt;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid engine type %d\\n\", engs->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int release_engines(struct device *dev, struct otx_cpt_eng_grp_info *grp)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < OTX_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tif (!grp->engs[i].type)\n\t\t\tcontinue;\n\n\t\tif (grp->engs[i].count > 0) {\n\t\t\tret = update_engines_avail_count(dev, &grp->g->avail,\n\t\t\t\t\t\t\t &grp->engs[i],\n\t\t\t\t\t\t\t grp->engs[i].count);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tgrp->engs[i].type = 0;\n\t\tgrp->engs[i].count = 0;\n\t\tgrp->engs[i].offset = 0;\n\t\tgrp->engs[i].ucode = NULL;\n\t\tbitmap_zero(grp->engs[i].bmap, grp->g->engs_num);\n\t}\n\n\treturn 0;\n}\n\nstatic int do_reserve_engines(struct device *dev,\n\t\t\t      struct otx_cpt_eng_grp_info *grp,\n\t\t\t      struct otx_cpt_engines *req_engs)\n{\n\tstruct otx_cpt_engs_rsvd *engs = NULL;\n\tint i, ret;\n\n\tfor (i = 0; i < OTX_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tif (!grp->engs[i].type) {\n\t\t\tengs = &grp->engs[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!engs)\n\t\treturn -ENOMEM;\n\n\tengs->type = req_engs->type;\n\tengs->count = req_engs->count;\n\n\tret = update_engines_offset(dev, &grp->g->avail, engs);\n\tif (ret)\n\t\treturn ret;\n\n\tif (engs->count > 0) {\n\t\tret = update_engines_avail_count(dev, &grp->g->avail, engs,\n\t\t\t\t\t\t -engs->count);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_engines_availability(struct device *dev,\n\t\t\t\t      struct otx_cpt_eng_grp_info *grp,\n\t\t\t\t      struct otx_cpt_engines *req_eng)\n{\n\tint avail_cnt = 0;\n\n\tswitch (req_eng->type) {\n\tcase OTX_CPT_SE_TYPES:\n\t\tavail_cnt = grp->g->avail.se_cnt;\n\t\tbreak;\n\n\tcase OTX_CPT_AE_TYPES:\n\t\tavail_cnt = grp->g->avail.ae_cnt;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Invalid engine type %d\\n\", req_eng->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (avail_cnt < req_eng->count) {\n\t\tdev_err(dev,\n\t\t\t\"Error available %s engines %d < than requested %d\\n\",\n\t\t\tget_eng_type_str(req_eng->type),\n\t\t\tavail_cnt, req_eng->count);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int reserve_engines(struct device *dev, struct otx_cpt_eng_grp_info *grp,\n\t\t\t   struct otx_cpt_engines *req_engs, int req_cnt)\n{\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < req_cnt; i++) {\n\t\tret = check_engines_availability(dev, grp, &req_engs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < req_cnt; i++) {\n\t\tret = do_reserve_engines(dev, grp, &req_engs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t eng_grp_info_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tchar ucode_info[2*OTX_CPT_UCODE_NAME_LENGTH];\n\tchar engs_info[2*OTX_CPT_UCODE_NAME_LENGTH];\n\tchar engs_mask[OTX_CPT_UCODE_NAME_LENGTH];\n\tstruct otx_cpt_eng_grp_info *eng_grp;\n\tint ret;\n\n\teng_grp = container_of(attr, struct otx_cpt_eng_grp_info, info_attr);\n\tmutex_lock(&eng_grp->g->lock);\n\n\tprint_engs_info(eng_grp, engs_info, 2*OTX_CPT_UCODE_NAME_LENGTH, -1);\n\tprint_ucode_info(eng_grp, ucode_info, 2*OTX_CPT_UCODE_NAME_LENGTH);\n\tcpt_print_engines_mask(eng_grp, dev, engs_mask,\n\t\t\t       OTX_CPT_UCODE_NAME_LENGTH);\n\tret = scnprintf(buf, PAGE_SIZE,\n\t\t\t\"Microcode : %s\\nEngines: %s\\nEngines mask: %s\\n\",\n\t\t\tucode_info, engs_info, engs_mask);\n\n\tmutex_unlock(&eng_grp->g->lock);\n\treturn ret;\n}\n\nstatic int create_sysfs_eng_grps_info(struct device *dev,\n\t\t\t\t      struct otx_cpt_eng_grp_info *eng_grp)\n{\n\teng_grp->info_attr.show = eng_grp_info_show;\n\teng_grp->info_attr.store = NULL;\n\teng_grp->info_attr.attr.name = eng_grp->sysfs_info_name;\n\teng_grp->info_attr.attr.mode = 0440;\n\tsysfs_attr_init(&eng_grp->info_attr.attr);\n\treturn device_create_file(dev, &eng_grp->info_attr);\n}\n\nstatic void ucode_unload(struct device *dev, struct otx_cpt_ucode *ucode)\n{\n\tif (ucode->va) {\n\t\tdma_free_coherent(dev, ucode->size + OTX_CPT_UCODE_ALIGNMENT,\n\t\t\t\t  ucode->va, ucode->dma);\n\t\tucode->va = NULL;\n\t\tucode->align_va = NULL;\n\t\tucode->dma = 0;\n\t\tucode->align_dma = 0;\n\t\tucode->size = 0;\n\t}\n\n\tmemset(&ucode->ver_str, 0, OTX_CPT_UCODE_VER_STR_SZ);\n\tmemset(&ucode->ver_num, 0, sizeof(struct otx_cpt_ucode_ver_num));\n\tset_ucode_filename(ucode, \"\");\n\tucode->type = 0;\n}\n\nstatic int copy_ucode_to_dma_mem(struct device *dev,\n\t\t\t\t struct otx_cpt_ucode *ucode,\n\t\t\t\t const u8 *ucode_data)\n{\n\tu32 i;\n\n\t \n\tucode->va = dma_alloc_coherent(dev, ucode->size +\n\t\t\t\t       OTX_CPT_UCODE_ALIGNMENT,\n\t\t\t\t       &ucode->dma, GFP_KERNEL);\n\tif (!ucode->va) {\n\t\tdev_err(dev, \"Unable to allocate space for microcode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tucode->align_va = PTR_ALIGN(ucode->va, OTX_CPT_UCODE_ALIGNMENT);\n\tucode->align_dma = PTR_ALIGN(ucode->dma, OTX_CPT_UCODE_ALIGNMENT);\n\n\tmemcpy((void *) ucode->align_va, (void *) ucode_data +\n\t       sizeof(struct otx_cpt_ucode_hdr), ucode->size);\n\n\t \n\tfor (i = 0; i < (ucode->size / 8); i++)\n\t\t((__be64 *)ucode->align_va)[i] =\n\t\t\t\tcpu_to_be64(((u64 *)ucode->align_va)[i]);\n\t \n\tfor (i = 0; i < (ucode->size / 2); i++)\n\t\t((__be16 *)ucode->align_va)[i] =\n\t\t\t\tcpu_to_be16(((u16 *)ucode->align_va)[i]);\n\treturn 0;\n}\n\nstatic int ucode_load(struct device *dev, struct otx_cpt_ucode *ucode,\n\t\t      const char *ucode_filename)\n{\n\tstruct otx_cpt_ucode_hdr *ucode_hdr;\n\tconst struct firmware *fw;\n\tunsigned int code_length;\n\tint ret;\n\n\tset_ucode_filename(ucode, ucode_filename);\n\tret = request_firmware(&fw, ucode->filename, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tucode_hdr = (struct otx_cpt_ucode_hdr *) fw->data;\n\tmemcpy(ucode->ver_str, ucode_hdr->ver_str, OTX_CPT_UCODE_VER_STR_SZ);\n\tucode->ver_num = ucode_hdr->ver_num;\n\tcode_length = ntohl(ucode_hdr->code_length);\n\tif (code_length >= INT_MAX / 2) {\n\t\tdev_err(dev, \"Ucode invalid code_length %u\\n\", code_length);\n\t\tret = -EINVAL;\n\t\tgoto release_fw;\n\t}\n\tucode->size = code_length * 2;\n\tif (!ucode->size || (fw->size < round_up(ucode->size, 16)\n\t    + sizeof(struct otx_cpt_ucode_hdr) + OTX_CPT_UCODE_SIGN_LEN)) {\n\t\tdev_err(dev, \"Ucode %s invalid size\\n\", ucode_filename);\n\t\tret = -EINVAL;\n\t\tgoto release_fw;\n\t}\n\n\tret = get_ucode_type(ucode_hdr, &ucode->type);\n\tif (ret) {\n\t\tdev_err(dev, \"Microcode %s unknown type 0x%x\\n\",\n\t\t\tucode->filename, ucode->type);\n\t\tgoto release_fw;\n\t}\n\n\tret = copy_ucode_to_dma_mem(dev, ucode, fw->data);\n\tif (ret)\n\t\tgoto release_fw;\n\n\tprint_ucode_dbg_info(ucode);\nrelease_fw:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic int enable_eng_grp(struct otx_cpt_eng_grp_info *eng_grp,\n\t\t\t  void *obj)\n{\n\tint ret;\n\n\tret = cpt_set_ucode_base(eng_grp, obj);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cpt_attach_and_enable_cores(eng_grp, obj);\n\treturn ret;\n}\n\nstatic int disable_eng_grp(struct device *dev,\n\t\t\t   struct otx_cpt_eng_grp_info *eng_grp,\n\t\t\t   void *obj)\n{\n\tint i, ret;\n\n\tret = cpt_detach_and_disable_cores(eng_grp, obj);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tucode_unload(dev, &eng_grp->ucode[0]);\n\n\tfor (i = 0; i < OTX_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tif (!eng_grp->engs[i].type)\n\t\t\tcontinue;\n\n\t\teng_grp->engs[i].ucode = &eng_grp->ucode[0];\n\t}\n\n\tret = cpt_set_ucode_base(eng_grp, obj);\n\n\treturn ret;\n}\n\nstatic void setup_eng_grp_mirroring(struct otx_cpt_eng_grp_info *dst_grp,\n\t\t\t\t    struct otx_cpt_eng_grp_info *src_grp)\n{\n\t \n\tsrc_grp->mirror.is_ena = false;\n\tsrc_grp->mirror.idx = 0;\n\tsrc_grp->mirror.ref_count++;\n\n\t \n\tdst_grp->mirror.is_ena = true;\n\tdst_grp->mirror.idx = src_grp->idx;\n\tdst_grp->mirror.ref_count = 0;\n}\n\nstatic void remove_eng_grp_mirroring(struct otx_cpt_eng_grp_info *dst_grp)\n{\n\tstruct otx_cpt_eng_grp_info *src_grp;\n\n\tif (!dst_grp->mirror.is_ena)\n\t\treturn;\n\n\tsrc_grp = &dst_grp->g->grp[dst_grp->mirror.idx];\n\n\tsrc_grp->mirror.ref_count--;\n\tdst_grp->mirror.is_ena = false;\n\tdst_grp->mirror.idx = 0;\n\tdst_grp->mirror.ref_count = 0;\n}\n\nstatic void update_requested_engs(struct otx_cpt_eng_grp_info *mirrored_eng_grp,\n\t\t\t\t  struct otx_cpt_engines *engs, int engs_cnt)\n{\n\tstruct otx_cpt_engs_rsvd *mirrored_engs;\n\tint i;\n\n\tfor (i = 0; i < engs_cnt; i++) {\n\t\tmirrored_engs = find_engines_by_type(mirrored_eng_grp,\n\t\t\t\t\t\t     engs[i].type);\n\t\tif (!mirrored_engs)\n\t\t\tcontinue;\n\n\t\t \n\t\tengs[i].count -= mirrored_engs->count;\n\t}\n}\n\nstatic struct otx_cpt_eng_grp_info *find_mirrored_eng_grp(\n\t\t\t\t\tstruct otx_cpt_eng_grp_info *grp)\n{\n\tstruct otx_cpt_eng_grps *eng_grps = grp->g;\n\tint i;\n\n\tfor (i = 0; i < OTX_CPT_MAX_ENGINE_GROUPS; i++) {\n\t\tif (!eng_grps->grp[i].is_enabled)\n\t\t\tcontinue;\n\t\tif (eng_grps->grp[i].ucode[0].type)\n\t\t\tcontinue;\n\t\tif (grp->idx == i)\n\t\t\tcontinue;\n\t\tif (!strncasecmp(eng_grps->grp[i].ucode[0].ver_str,\n\t\t\t\t grp->ucode[0].ver_str,\n\t\t\t\t OTX_CPT_UCODE_VER_STR_SZ))\n\t\t\treturn &eng_grps->grp[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic struct otx_cpt_eng_grp_info *find_unused_eng_grp(\n\t\t\t\t\tstruct otx_cpt_eng_grps *eng_grps)\n{\n\tint i;\n\n\tfor (i = 0; i < OTX_CPT_MAX_ENGINE_GROUPS; i++) {\n\t\tif (!eng_grps->grp[i].is_enabled)\n\t\t\treturn &eng_grps->grp[i];\n\t}\n\treturn NULL;\n}\n\nstatic int eng_grp_update_masks(struct device *dev,\n\t\t\t\tstruct otx_cpt_eng_grp_info *eng_grp)\n{\n\tstruct otx_cpt_engs_rsvd *engs, *mirrored_engs;\n\tstruct otx_cpt_bitmap tmp_bmap = { {0} };\n\tint i, j, cnt, max_cnt;\n\tint bit;\n\n\tfor (i = 0; i < OTX_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tengs = &eng_grp->engs[i];\n\t\tif (!engs->type)\n\t\t\tcontinue;\n\t\tif (engs->count <= 0)\n\t\t\tcontinue;\n\n\t\tswitch (engs->type) {\n\t\tcase OTX_CPT_SE_TYPES:\n\t\t\tmax_cnt = eng_grp->g->avail.max_se_cnt;\n\t\t\tbreak;\n\n\t\tcase OTX_CPT_AE_TYPES:\n\t\t\tmax_cnt = eng_grp->g->avail.max_ae_cnt;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(dev, \"Invalid engine type %d\\n\", engs->type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcnt = engs->count;\n\t\tWARN_ON(engs->offset + max_cnt > OTX_CPT_MAX_ENGINES);\n\t\tbitmap_zero(tmp_bmap.bits, eng_grp->g->engs_num);\n\t\tfor (j = engs->offset; j < engs->offset + max_cnt; j++) {\n\t\t\tif (!eng_grp->g->eng_ref_cnt[j]) {\n\t\t\t\tbitmap_set(tmp_bmap.bits, j, 1);\n\t\t\t\tcnt--;\n\t\t\t\tif (!cnt)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cnt)\n\t\t\treturn -ENOSPC;\n\n\t\tbitmap_copy(engs->bmap, tmp_bmap.bits, eng_grp->g->engs_num);\n\t}\n\n\tif (!eng_grp->mirror.is_ena)\n\t\treturn 0;\n\n\tfor (i = 0; i < OTX_CPT_MAX_ETYPES_PER_GRP; i++) {\n\t\tengs = &eng_grp->engs[i];\n\t\tif (!engs->type)\n\t\t\tcontinue;\n\n\t\tmirrored_engs = find_engines_by_type(\n\t\t\t\t\t&eng_grp->g->grp[eng_grp->mirror.idx],\n\t\t\t\t\tengs->type);\n\t\tWARN_ON(!mirrored_engs && engs->count <= 0);\n\t\tif (!mirrored_engs)\n\t\t\tcontinue;\n\n\t\tbitmap_copy(tmp_bmap.bits, mirrored_engs->bmap,\n\t\t\t    eng_grp->g->engs_num);\n\t\tif (engs->count < 0) {\n\t\t\tbit = find_first_bit(mirrored_engs->bmap,\n\t\t\t\t\t     eng_grp->g->engs_num);\n\t\t\tbitmap_clear(tmp_bmap.bits, bit, -engs->count);\n\t\t}\n\t\tbitmap_or(engs->bmap, engs->bmap, tmp_bmap.bits,\n\t\t\t  eng_grp->g->engs_num);\n\t}\n\treturn 0;\n}\n\nstatic int delete_engine_group(struct device *dev,\n\t\t\t       struct otx_cpt_eng_grp_info *eng_grp)\n{\n\tint i, ret;\n\n\tif (!eng_grp->is_enabled)\n\t\treturn -EINVAL;\n\n\tif (eng_grp->mirror.ref_count) {\n\t\tdev_err(dev, \"Can't delete engine_group%d as it is used by engine_group(s):\",\n\t\t\teng_grp->idx);\n\t\tfor (i = 0; i < OTX_CPT_MAX_ENGINE_GROUPS; i++) {\n\t\t\tif (eng_grp->g->grp[i].mirror.is_ena &&\n\t\t\t    eng_grp->g->grp[i].mirror.idx == eng_grp->idx)\n\t\t\t\tpr_cont(\" %d\", i);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tremove_eng_grp_mirroring(eng_grp);\n\n\t \n\tret = disable_eng_grp(dev, eng_grp, eng_grp->g->obj);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = release_engines(dev, eng_grp);\n\tif (ret)\n\t\treturn ret;\n\n\tdevice_remove_file(dev, &eng_grp->info_attr);\n\teng_grp->is_enabled = false;\n\n\treturn 0;\n}\n\nstatic int validate_1_ucode_scenario(struct device *dev,\n\t\t\t\t     struct otx_cpt_eng_grp_info *eng_grp,\n\t\t\t\t     struct otx_cpt_engines *engs, int engs_cnt)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < engs_cnt; i++) {\n\t\tif (!otx_cpt_uc_supports_eng_type(&eng_grp->ucode[0],\n\t\t\t\t\t\t  engs[i].type)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Microcode %s does not support %s engines\\n\",\n\t\t\t\teng_grp->ucode[0].filename,\n\t\t\t\tget_eng_type_str(engs[i].type));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void update_ucode_ptrs(struct otx_cpt_eng_grp_info *eng_grp)\n{\n\tstruct otx_cpt_ucode *ucode;\n\n\tif (eng_grp->mirror.is_ena)\n\t\tucode = &eng_grp->g->grp[eng_grp->mirror.idx].ucode[0];\n\telse\n\t\tucode = &eng_grp->ucode[0];\n\tWARN_ON(!eng_grp->engs[0].type);\n\teng_grp->engs[0].ucode = ucode;\n}\n\nstatic int create_engine_group(struct device *dev,\n\t\t\t       struct otx_cpt_eng_grps *eng_grps,\n\t\t\t       struct otx_cpt_engines *engs, int engs_cnt,\n\t\t\t       void *ucode_data[], int ucodes_cnt,\n\t\t\t       bool use_uc_from_tar_arch)\n{\n\tstruct otx_cpt_eng_grp_info *mirrored_eng_grp;\n\tstruct tar_ucode_info_t *tar_info;\n\tstruct otx_cpt_eng_grp_info *eng_grp;\n\tint i, ret = 0;\n\n\tif (ucodes_cnt > OTX_CPT_MAX_ETYPES_PER_GRP)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < engs_cnt; i++)\n\t\tif (!dev_supports_eng_type(eng_grps, engs[i].type)) {\n\t\t\tdev_err(dev, \"Device does not support %s engines\\n\",\n\t\t\t\tget_eng_type_str(engs[i].type));\n\t\t\treturn -EPERM;\n\t\t}\n\n\t \n\teng_grp = find_unused_eng_grp(eng_grps);\n\tif (!eng_grp) {\n\t\tdev_err(dev, \"Error all engine groups are being used\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\tfor (i = 0; i < ucodes_cnt; i++) {\n\t\tif (use_uc_from_tar_arch) {\n\t\t\ttar_info = (struct tar_ucode_info_t *) ucode_data[i];\n\t\t\teng_grp->ucode[i] = tar_info->ucode;\n\t\t\tret = copy_ucode_to_dma_mem(dev, &eng_grp->ucode[i],\n\t\t\t\t\t\t    tar_info->ucode_ptr);\n\t\t} else\n\t\t\tret = ucode_load(dev, &eng_grp->ucode[i],\n\t\t\t\t\t (char *) ucode_data[i]);\n\t\tif (ret)\n\t\t\tgoto err_ucode_unload;\n\t}\n\n\t \n\tret = validate_1_ucode_scenario(dev, eng_grp, engs, engs_cnt);\n\tif (ret)\n\t\tgoto err_ucode_unload;\n\n\t \n\tmirrored_eng_grp = find_mirrored_eng_grp(eng_grp);\n\tif (mirrored_eng_grp) {\n\t\t \n\t\tsetup_eng_grp_mirroring(eng_grp, mirrored_eng_grp);\n\n\t\t \n\t\tupdate_requested_engs(mirrored_eng_grp, engs, engs_cnt);\n\t}\n\n\t \n\tret = reserve_engines(dev, eng_grp, engs, engs_cnt);\n\tif (ret)\n\t\tgoto err_ucode_unload;\n\n\t \n\tupdate_ucode_ptrs(eng_grp);\n\n\t \n\tret = eng_grp_update_masks(dev, eng_grp);\n\tif (ret)\n\t\tgoto err_release_engs;\n\n\t \n\tret = create_sysfs_eng_grps_info(dev, eng_grp);\n\tif (ret)\n\t\tgoto err_release_engs;\n\n\t \n\tret = enable_eng_grp(eng_grp, eng_grps->obj);\n\tif (ret)\n\t\tgoto err_release_engs;\n\n\t \n\tif (eng_grp->mirror.is_ena)\n\t\tucode_unload(dev, &eng_grp->ucode[0]);\n\n\teng_grp->is_enabled = true;\n\tif (eng_grp->mirror.is_ena)\n\t\tdev_info(dev,\n\t\t\t \"Engine_group%d: reuse microcode %s from group %d\\n\",\n\t\t\t eng_grp->idx, mirrored_eng_grp->ucode[0].ver_str,\n\t\t\t mirrored_eng_grp->idx);\n\telse\n\t\tdev_info(dev, \"Engine_group%d: microcode loaded %s\\n\",\n\t\t\t eng_grp->idx, eng_grp->ucode[0].ver_str);\n\n\treturn 0;\n\nerr_release_engs:\n\trelease_engines(dev, eng_grp);\nerr_ucode_unload:\n\tucode_unload(dev, &eng_grp->ucode[0]);\n\treturn ret;\n}\n\nstatic ssize_t ucode_load_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct otx_cpt_engines engs[OTX_CPT_MAX_ETYPES_PER_GRP] = { {0} };\n\tchar *ucode_filename[OTX_CPT_MAX_ETYPES_PER_GRP];\n\tchar tmp_buf[OTX_CPT_UCODE_NAME_LENGTH] = { 0 };\n\tchar *start, *val, *err_msg, *tmp;\n\tstruct otx_cpt_eng_grps *eng_grps;\n\tint grp_idx = 0, ret = -EINVAL;\n\tbool has_se, has_ie, has_ae;\n\tint del_grp_idx = -1;\n\tint ucode_idx = 0;\n\n\tif (strlen(buf) > OTX_CPT_UCODE_NAME_LENGTH)\n\t\treturn -EINVAL;\n\n\teng_grps = container_of(attr, struct otx_cpt_eng_grps, ucode_load_attr);\n\terr_msg = \"Invalid engine group format\";\n\tstrscpy(tmp_buf, buf, OTX_CPT_UCODE_NAME_LENGTH);\n\tstart = tmp_buf;\n\n\thas_se = has_ie = has_ae = false;\n\n\tfor (;;) {\n\t\tval = strsep(&start, \";\");\n\t\tif (!val)\n\t\t\tbreak;\n\t\tval = strim(val);\n\t\tif (!*val)\n\t\t\tcontinue;\n\n\t\tif (!strncasecmp(val, \"engine_group\", 12)) {\n\t\t\tif (del_grp_idx != -1)\n\t\t\t\tgoto err_print;\n\t\t\ttmp = strim(strsep(&val, \":\"));\n\t\t\tif (!val)\n\t\t\t\tgoto err_print;\n\t\t\tif (strlen(tmp) != 13)\n\t\t\t\tgoto err_print;\n\t\t\tif (kstrtoint((tmp + 12), 10, &del_grp_idx))\n\t\t\t\tgoto err_print;\n\t\t\tval = strim(val);\n\t\t\tif (strncasecmp(val, \"null\", 4))\n\t\t\t\tgoto err_print;\n\t\t\tif (strlen(val) != 4)\n\t\t\t\tgoto err_print;\n\t\t} else if (!strncasecmp(val, \"se\", 2) && strchr(val, ':')) {\n\t\t\tif (has_se || ucode_idx)\n\t\t\t\tgoto err_print;\n\t\t\ttmp = strim(strsep(&val, \":\"));\n\t\t\tif (!val)\n\t\t\t\tgoto err_print;\n\t\t\tif (strlen(tmp) != 2)\n\t\t\t\tgoto err_print;\n\t\t\tif (kstrtoint(strim(val), 10, &engs[grp_idx].count))\n\t\t\t\tgoto err_print;\n\t\t\tengs[grp_idx++].type = OTX_CPT_SE_TYPES;\n\t\t\thas_se = true;\n\t\t} else if (!strncasecmp(val, \"ae\", 2) && strchr(val, ':')) {\n\t\t\tif (has_ae || ucode_idx)\n\t\t\t\tgoto err_print;\n\t\t\ttmp = strim(strsep(&val, \":\"));\n\t\t\tif (!val)\n\t\t\t\tgoto err_print;\n\t\t\tif (strlen(tmp) != 2)\n\t\t\t\tgoto err_print;\n\t\t\tif (kstrtoint(strim(val), 10, &engs[grp_idx].count))\n\t\t\t\tgoto err_print;\n\t\t\tengs[grp_idx++].type = OTX_CPT_AE_TYPES;\n\t\t\thas_ae = true;\n\t\t} else {\n\t\t\tif (ucode_idx > 1)\n\t\t\t\tgoto err_print;\n\t\t\tif (!strlen(val))\n\t\t\t\tgoto err_print;\n\t\t\tif (strnstr(val, \" \", strlen(val)))\n\t\t\t\tgoto err_print;\n\t\t\tucode_filename[ucode_idx++] = val;\n\t\t}\n\t}\n\n\t \n\tif (del_grp_idx == -1) {\n\t\tif (!(grp_idx && ucode_idx))\n\t\t\tgoto err_print;\n\n\t\tif (ucode_idx > 1 && grp_idx < 2)\n\t\t\tgoto err_print;\n\n\t\tif (grp_idx > OTX_CPT_MAX_ETYPES_PER_GRP) {\n\t\t\terr_msg = \"Error max 2 engine types can be attached\";\n\t\t\tgoto err_print;\n\t\t}\n\n\t} else {\n\t\tif (del_grp_idx < 0 ||\n\t\t    del_grp_idx >= OTX_CPT_MAX_ENGINE_GROUPS) {\n\t\t\tdev_err(dev, \"Invalid engine group index %d\\n\",\n\t\t\t\tdel_grp_idx);\n\t\t\tret = -EINVAL;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!eng_grps->grp[del_grp_idx].is_enabled) {\n\t\t\tdev_err(dev, \"Error engine_group%d is not configured\\n\",\n\t\t\t\tdel_grp_idx);\n\t\t\tret = -EINVAL;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (grp_idx || ucode_idx)\n\t\t\tgoto err_print;\n\t}\n\n\tmutex_lock(&eng_grps->lock);\n\n\tif (eng_grps->is_rdonly) {\n\t\tdev_err(dev, \"Disable VFs before modifying engine groups\\n\");\n\t\tret = -EACCES;\n\t\tgoto err_unlock;\n\t}\n\n\tif (del_grp_idx == -1)\n\t\t \n\t\tret = create_engine_group(dev, eng_grps, engs, grp_idx,\n\t\t\t\t\t  (void **) ucode_filename,\n\t\t\t\t\t  ucode_idx, false);\n\telse\n\t\t \n\t\tret = delete_engine_group(dev, &eng_grps->grp[del_grp_idx]);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tprint_dbg_info(dev, eng_grps);\nerr_unlock:\n\tmutex_unlock(&eng_grps->lock);\n\treturn ret ? ret : count;\nerr_print:\n\tdev_err(dev, \"%s\\n\", err_msg);\n\n\treturn ret;\n}\n\nint otx_cpt_try_create_default_eng_grps(struct pci_dev *pdev,\n\t\t\t\t\tstruct otx_cpt_eng_grps *eng_grps,\n\t\t\t\t\tint pf_type)\n{\n\tstruct tar_ucode_info_t *tar_info[OTX_CPT_MAX_ETYPES_PER_GRP] = {};\n\tstruct otx_cpt_engines engs[OTX_CPT_MAX_ETYPES_PER_GRP] = {};\n\tstruct tar_arch_info_t *tar_arch = NULL;\n\tchar *tar_filename;\n\tint i, ret = 0;\n\n\tmutex_lock(&eng_grps->lock);\n\n\t \n\tif (eng_grps->is_first_try)\n\t\tgoto unlock_mutex;\n\teng_grps->is_first_try = true;\n\n\t \n\tfor (i = 0; i < OTX_CPT_MAX_ENGINE_GROUPS; i++)\n\t\tif (eng_grps->grp[i].is_enabled)\n\t\t\tgoto unlock_mutex;\n\n\tswitch (pf_type) {\n\tcase OTX_CPT_AE:\n\tcase OTX_CPT_SE:\n\t\ttar_filename = OTX_CPT_UCODE_TAR_FILE_NAME;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unknown PF type %d\\n\", pf_type);\n\t\tret = -EINVAL;\n\t\tgoto unlock_mutex;\n\t}\n\n\ttar_arch = load_tar_archive(&pdev->dev, tar_filename);\n\tif (!tar_arch)\n\t\tgoto unlock_mutex;\n\n\t \n\ttar_info[0] = get_uc_from_tar_archive(tar_arch, OTX_CPT_SE_TYPES);\n\tif (tar_info[0] &&\n\t    dev_supports_eng_type(eng_grps, OTX_CPT_SE_TYPES)) {\n\n\t\tengs[0].type = OTX_CPT_SE_TYPES;\n\t\tengs[0].count = eng_grps->avail.max_se_cnt;\n\n\t\tret = create_engine_group(&pdev->dev, eng_grps, engs, 1,\n\t\t\t\t\t  (void **) tar_info, 1, true);\n\t\tif (ret)\n\t\t\tgoto release_tar_arch;\n\t}\n\t \n\ttar_info[0] = get_uc_from_tar_archive(tar_arch, OTX_CPT_AE_TYPES);\n\tif (tar_info[0] &&\n\t    dev_supports_eng_type(eng_grps, OTX_CPT_AE_TYPES)) {\n\n\t\tengs[0].type = OTX_CPT_AE_TYPES;\n\t\tengs[0].count = eng_grps->avail.max_ae_cnt;\n\n\t\tret = create_engine_group(&pdev->dev, eng_grps, engs, 1,\n\t\t\t\t\t  (void **) tar_info, 1, true);\n\t\tif (ret)\n\t\t\tgoto release_tar_arch;\n\t}\n\n\tprint_dbg_info(&pdev->dev, eng_grps);\nrelease_tar_arch:\n\trelease_tar_archive(tar_arch);\nunlock_mutex:\n\tmutex_unlock(&eng_grps->lock);\n\treturn ret;\n}\n\nvoid otx_cpt_set_eng_grps_is_rdonly(struct otx_cpt_eng_grps *eng_grps,\n\t\t\t\t    bool is_rdonly)\n{\n\tmutex_lock(&eng_grps->lock);\n\n\teng_grps->is_rdonly = is_rdonly;\n\n\tmutex_unlock(&eng_grps->lock);\n}\n\nvoid otx_cpt_disable_all_cores(struct otx_cpt_device *cpt)\n{\n\tint grp, timeout = 100;\n\tu64 reg;\n\n\t \n\tfor (grp = 0; grp < OTX_CPT_MAX_ENGINE_GROUPS; grp++) {\n\t\twriteq(0, cpt->reg_base + OTX_CPT_PF_GX_EN(grp));\n\t\tudelay(CSR_DELAY);\n\t}\n\n\treg = readq(cpt->reg_base + OTX_CPT_PF_EXEC_BUSY);\n\twhile (reg) {\n\t\tudelay(CSR_DELAY);\n\t\treg = readq(cpt->reg_base + OTX_CPT_PF_EXEC_BUSY);\n\t\tif (timeout--) {\n\t\t\tdev_warn(&cpt->pdev->dev, \"Cores still busy\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\twriteq(0, cpt->reg_base + OTX_CPT_PF_EXE_CTL);\n}\n\nvoid otx_cpt_cleanup_eng_grps(struct pci_dev *pdev,\n\t\t\t      struct otx_cpt_eng_grps *eng_grps)\n{\n\tstruct otx_cpt_eng_grp_info *grp;\n\tint i, j;\n\n\tmutex_lock(&eng_grps->lock);\n\tif (eng_grps->is_ucode_load_created) {\n\t\tdevice_remove_file(&pdev->dev,\n\t\t\t\t   &eng_grps->ucode_load_attr);\n\t\teng_grps->is_ucode_load_created = false;\n\t}\n\n\t \n\tfor (i = 0; i < OTX_CPT_MAX_ENGINE_GROUPS; i++)\n\t\tif (eng_grps->grp[i].mirror.is_ena)\n\t\t\tdelete_engine_group(&pdev->dev, &eng_grps->grp[i]);\n\n\t \n\tfor (i = 0; i < OTX_CPT_MAX_ENGINE_GROUPS; i++)\n\t\tdelete_engine_group(&pdev->dev, &eng_grps->grp[i]);\n\n\t \n\tfor (i = 0; i < OTX_CPT_MAX_ENGINE_GROUPS; i++) {\n\t\tgrp = &eng_grps->grp[i];\n\t\tfor (j = 0; j < OTX_CPT_MAX_ETYPES_PER_GRP; j++) {\n\t\t\tkfree(grp->engs[j].bmap);\n\t\t\tgrp->engs[j].bmap = NULL;\n\t\t}\n\t}\n\n\tmutex_unlock(&eng_grps->lock);\n}\n\nint otx_cpt_init_eng_grps(struct pci_dev *pdev,\n\t\t\t  struct otx_cpt_eng_grps *eng_grps, int pf_type)\n{\n\tstruct otx_cpt_eng_grp_info *grp;\n\tint i, j, ret = 0;\n\n\tmutex_init(&eng_grps->lock);\n\teng_grps->obj = pci_get_drvdata(pdev);\n\teng_grps->avail.se_cnt = eng_grps->avail.max_se_cnt;\n\teng_grps->avail.ae_cnt = eng_grps->avail.max_ae_cnt;\n\n\teng_grps->engs_num = eng_grps->avail.max_se_cnt +\n\t\t\t     eng_grps->avail.max_ae_cnt;\n\tif (eng_grps->engs_num > OTX_CPT_MAX_ENGINES) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Number of engines %d > than max supported %d\\n\",\n\t\t\teng_grps->engs_num, OTX_CPT_MAX_ENGINES);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < OTX_CPT_MAX_ENGINE_GROUPS; i++) {\n\t\tgrp = &eng_grps->grp[i];\n\t\tgrp->g = eng_grps;\n\t\tgrp->idx = i;\n\n\t\tsnprintf(grp->sysfs_info_name, OTX_CPT_UCODE_NAME_LENGTH,\n\t\t\t \"engine_group%d\", i);\n\t\tfor (j = 0; j < OTX_CPT_MAX_ETYPES_PER_GRP; j++) {\n\t\t\tgrp->engs[j].bmap =\n\t\t\t\tkcalloc(BITS_TO_LONGS(eng_grps->engs_num),\n\t\t\t\t\tsizeof(long), GFP_KERNEL);\n\t\t\tif (!grp->engs[j].bmap) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (pf_type) {\n\tcase OTX_CPT_SE:\n\t\t \n\t\teng_grps->eng_types_supported = 1 << OTX_CPT_SE_TYPES;\n\t\tbreak;\n\n\tcase OTX_CPT_AE:\n\t\t \n\t\teng_grps->eng_types_supported = 1 << OTX_CPT_AE_TYPES;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unknown PF type %d\\n\", pf_type);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\teng_grps->ucode_load_attr.show = NULL;\n\teng_grps->ucode_load_attr.store = ucode_load_store;\n\teng_grps->ucode_load_attr.attr.name = \"ucode_load\";\n\teng_grps->ucode_load_attr.attr.mode = 0220;\n\tsysfs_attr_init(&eng_grps->ucode_load_attr.attr);\n\tret = device_create_file(&pdev->dev,\n\t\t\t\t &eng_grps->ucode_load_attr);\n\tif (ret)\n\t\tgoto err;\n\teng_grps->is_ucode_load_created = true;\n\n\tprint_dbg_info(&pdev->dev, eng_grps);\n\treturn ret;\nerr:\n\totx_cpt_cleanup_eng_grps(pdev, eng_grps);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}