{
  "module_name": "otx_cptpf_mbox.c",
  "hash_id": "a76a27818c96ec0845a629f991055d2774c8a7d684816ff4f65c2c57f9daa7b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/octeontx/otx_cptpf_mbox.c",
  "human_readable_source": "\n \n\n#include \"otx_cpt_common.h\"\n#include \"otx_cptpf.h\"\n\nstatic char *get_mbox_opcode_str(int msg_opcode)\n{\n\tchar *str = \"Unknown\";\n\n\tswitch (msg_opcode) {\n\tcase OTX_CPT_MSG_VF_UP:\n\t\tstr = \"UP\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_VF_DOWN:\n\t\tstr = \"DOWN\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_READY:\n\t\tstr = \"READY\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_QLEN:\n\t\tstr = \"QLEN\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_QBIND_GRP:\n\t\tstr = \"QBIND_GRP\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_VQ_PRIORITY:\n\t\tstr = \"VQ_PRIORITY\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_PF_TYPE:\n\t\tstr = \"PF_TYPE\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_ACK:\n\t\tstr = \"ACK\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_NACK:\n\t\tstr = \"NACK\";\n\t\tbreak;\n\t}\n\n\treturn str;\n}\n\nstatic void dump_mbox_msg(struct otx_cpt_mbox *mbox_msg, int vf_id)\n{\n\tchar raw_data_str[OTX_CPT_MAX_MBOX_DATA_STR_SIZE];\n\n\thex_dump_to_buffer(mbox_msg, sizeof(struct otx_cpt_mbox), 16, 8,\n\t\t\t   raw_data_str, OTX_CPT_MAX_MBOX_DATA_STR_SIZE, false);\n\tif (vf_id >= 0)\n\t\tpr_debug(\"MBOX opcode %s received from VF%d raw_data %s\\n\",\n\t\t\t get_mbox_opcode_str(mbox_msg->msg), vf_id,\n\t\t\t raw_data_str);\n\telse\n\t\tpr_debug(\"MBOX opcode %s received from PF raw_data %s\\n\",\n\t\t\t get_mbox_opcode_str(mbox_msg->msg), raw_data_str);\n}\n\nstatic void otx_cpt_send_msg_to_vf(struct otx_cpt_device *cpt, int vf,\n\t\t\t\t   struct otx_cpt_mbox *mbx)\n{\n\t \n\twriteq(mbx->data, cpt->reg_base + OTX_CPT_PF_VFX_MBOXX(vf, 1));\n\twriteq(mbx->msg, cpt->reg_base + OTX_CPT_PF_VFX_MBOXX(vf, 0));\n}\n\n \nstatic void otx_cpt_mbox_send_ack(struct otx_cpt_device *cpt, int vf,\n\t\t\t      struct otx_cpt_mbox *mbx)\n{\n\tmbx->data = 0ull;\n\tmbx->msg = OTX_CPT_MSG_ACK;\n\totx_cpt_send_msg_to_vf(cpt, vf, mbx);\n}\n\n \nstatic void otx_cptpf_mbox_send_nack(struct otx_cpt_device *cpt, int vf,\n\t\t\t\t     struct otx_cpt_mbox *mbx)\n{\n\tmbx->data = 0ull;\n\tmbx->msg = OTX_CPT_MSG_NACK;\n\totx_cpt_send_msg_to_vf(cpt, vf, mbx);\n}\n\nstatic void otx_cpt_clear_mbox_intr(struct otx_cpt_device *cpt, u32 vf)\n{\n\t \n\twriteq(1ull << vf, cpt->reg_base + OTX_CPT_PF_MBOX_INTX(0));\n}\n\n \nstatic void otx_cpt_cfg_qlen_for_vf(struct otx_cpt_device *cpt, int vf,\n\t\t\t\t    u32 size)\n{\n\tunion otx_cptx_pf_qx_ctl pf_qx_ctl;\n\n\tpf_qx_ctl.u = readq(cpt->reg_base + OTX_CPT_PF_QX_CTL(vf));\n\tpf_qx_ctl.s.size = size;\n\tpf_qx_ctl.s.cont_err = true;\n\twriteq(pf_qx_ctl.u, cpt->reg_base + OTX_CPT_PF_QX_CTL(vf));\n}\n\n \nstatic void otx_cpt_cfg_vq_priority(struct otx_cpt_device *cpt, int vf, u32 pri)\n{\n\tunion otx_cptx_pf_qx_ctl pf_qx_ctl;\n\n\tpf_qx_ctl.u = readq(cpt->reg_base + OTX_CPT_PF_QX_CTL(vf));\n\tpf_qx_ctl.s.pri = pri;\n\twriteq(pf_qx_ctl.u, cpt->reg_base + OTX_CPT_PF_QX_CTL(vf));\n}\n\nstatic int otx_cpt_bind_vq_to_grp(struct otx_cpt_device *cpt, u8 q, u8 grp)\n{\n\tstruct device *dev = &cpt->pdev->dev;\n\tstruct otx_cpt_eng_grp_info *eng_grp;\n\tunion otx_cptx_pf_qx_ctl pf_qx_ctl;\n\tstruct otx_cpt_ucode *ucode;\n\n\tif (q >= cpt->max_vfs) {\n\t\tdev_err(dev, \"Requested queue %d is > than maximum avail %d\\n\",\n\t\t\tq, cpt->max_vfs);\n\t\treturn -EINVAL;\n\t}\n\n\tif (grp >= OTX_CPT_MAX_ENGINE_GROUPS) {\n\t\tdev_err(dev, \"Requested group %d is > than maximum avail %d\\n\",\n\t\t\tgrp, OTX_CPT_MAX_ENGINE_GROUPS);\n\t\treturn -EINVAL;\n\t}\n\n\teng_grp = &cpt->eng_grps.grp[grp];\n\tif (!eng_grp->is_enabled) {\n\t\tdev_err(dev, \"Requested engine group %d is disabled\\n\", grp);\n\t\treturn -EINVAL;\n\t}\n\n\tpf_qx_ctl.u = readq(cpt->reg_base + OTX_CPT_PF_QX_CTL(q));\n\tpf_qx_ctl.s.grp = grp;\n\twriteq(pf_qx_ctl.u, cpt->reg_base + OTX_CPT_PF_QX_CTL(q));\n\n\tif (eng_grp->mirror.is_ena)\n\t\tucode = &eng_grp->g->grp[eng_grp->mirror.idx].ucode[0];\n\telse\n\t\tucode = &eng_grp->ucode[0];\n\n\tif (otx_cpt_uc_supports_eng_type(ucode, OTX_CPT_SE_TYPES))\n\t\treturn OTX_CPT_SE_TYPES;\n\telse if (otx_cpt_uc_supports_eng_type(ucode, OTX_CPT_AE_TYPES))\n\t\treturn OTX_CPT_AE_TYPES;\n\telse\n\t\treturn BAD_OTX_CPTVF_TYPE;\n}\n\n \nstatic void otx_cpt_handle_mbox_intr(struct otx_cpt_device *cpt, int vf)\n{\n\tint vftype = 0;\n\tstruct otx_cpt_mbox mbx = {};\n\tstruct device *dev = &cpt->pdev->dev;\n\t \n\tmbx.msg  = readq(cpt->reg_base + OTX_CPT_PF_VFX_MBOXX(vf, 0));\n\tmbx.data = readq(cpt->reg_base + OTX_CPT_PF_VFX_MBOXX(vf, 1));\n\n\tdump_mbox_msg(&mbx, vf);\n\n\tswitch (mbx.msg) {\n\tcase OTX_CPT_MSG_VF_UP:\n\t\tmbx.msg  = OTX_CPT_MSG_VF_UP;\n\t\tmbx.data = cpt->vfs_enabled;\n\t\totx_cpt_send_msg_to_vf(cpt, vf, &mbx);\n\t\tbreak;\n\tcase OTX_CPT_MSG_READY:\n\t\tmbx.msg  = OTX_CPT_MSG_READY;\n\t\tmbx.data = vf;\n\t\totx_cpt_send_msg_to_vf(cpt, vf, &mbx);\n\t\tbreak;\n\tcase OTX_CPT_MSG_VF_DOWN:\n\t\t \n\t\totx_cpt_mbox_send_ack(cpt, vf, &mbx);\n\t\tbreak;\n\tcase OTX_CPT_MSG_QLEN:\n\t\totx_cpt_cfg_qlen_for_vf(cpt, vf, mbx.data);\n\t\totx_cpt_mbox_send_ack(cpt, vf, &mbx);\n\t\tbreak;\n\tcase OTX_CPT_MSG_QBIND_GRP:\n\t\tvftype = otx_cpt_bind_vq_to_grp(cpt, vf, (u8)mbx.data);\n\t\tif ((vftype != OTX_CPT_AE_TYPES) &&\n\t\t    (vftype != OTX_CPT_SE_TYPES)) {\n\t\t\tdev_err(dev, \"VF%d binding to eng group %llu failed\\n\",\n\t\t\t\tvf, mbx.data);\n\t\t\totx_cptpf_mbox_send_nack(cpt, vf, &mbx);\n\t\t} else {\n\t\t\tmbx.msg = OTX_CPT_MSG_QBIND_GRP;\n\t\t\tmbx.data = vftype;\n\t\t\totx_cpt_send_msg_to_vf(cpt, vf, &mbx);\n\t\t}\n\t\tbreak;\n\tcase OTX_CPT_MSG_PF_TYPE:\n\t\tmbx.msg = OTX_CPT_MSG_PF_TYPE;\n\t\tmbx.data = cpt->pf_type;\n\t\totx_cpt_send_msg_to_vf(cpt, vf, &mbx);\n\t\tbreak;\n\tcase OTX_CPT_MSG_VQ_PRIORITY:\n\t\totx_cpt_cfg_vq_priority(cpt, vf, mbx.data);\n\t\totx_cpt_mbox_send_ack(cpt, vf, &mbx);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&cpt->pdev->dev, \"Invalid msg from VF%d, msg 0x%llx\\n\",\n\t\t\tvf, mbx.msg);\n\t\tbreak;\n\t}\n}\n\nvoid otx_cpt_mbox_intr_handler (struct otx_cpt_device *cpt, int mbx)\n{\n\tu64 intr;\n\tu8  vf;\n\n\tintr = readq(cpt->reg_base + OTX_CPT_PF_MBOX_INTX(0));\n\tpr_debug(\"PF interrupt mbox%d mask 0x%llx\\n\", mbx, intr);\n\tfor (vf = 0; vf < cpt->max_vfs; vf++) {\n\t\tif (intr & (1ULL << vf)) {\n\t\t\totx_cpt_handle_mbox_intr(cpt, vf);\n\t\t\totx_cpt_clear_mbox_intr(cpt, vf);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}