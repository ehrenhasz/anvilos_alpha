{
  "module_name": "otx_cptvf_mbox.c",
  "hash_id": "e926cbe04a81aaa36885fcadb4106e16cc035b3e390a152a746f1ef6eec11e7c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/octeontx/otx_cptvf_mbox.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include \"otx_cptvf.h\"\n\n#define CPT_MBOX_MSG_TIMEOUT 2000\n\nstatic char *get_mbox_opcode_str(int msg_opcode)\n{\n\tchar *str = \"Unknown\";\n\n\tswitch (msg_opcode) {\n\tcase OTX_CPT_MSG_VF_UP:\n\t\tstr = \"UP\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_VF_DOWN:\n\t\tstr = \"DOWN\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_READY:\n\t\tstr = \"READY\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_QLEN:\n\t\tstr = \"QLEN\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_QBIND_GRP:\n\t\tstr = \"QBIND_GRP\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_VQ_PRIORITY:\n\t\tstr = \"VQ_PRIORITY\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_PF_TYPE:\n\t\tstr = \"PF_TYPE\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_ACK:\n\t\tstr = \"ACK\";\n\t\tbreak;\n\n\tcase OTX_CPT_MSG_NACK:\n\t\tstr = \"NACK\";\n\t\tbreak;\n\t}\n\treturn str;\n}\n\nstatic void dump_mbox_msg(struct otx_cpt_mbox *mbox_msg, int vf_id)\n{\n\tchar raw_data_str[OTX_CPT_MAX_MBOX_DATA_STR_SIZE];\n\n\thex_dump_to_buffer(mbox_msg, sizeof(struct otx_cpt_mbox), 16, 8,\n\t\t\t   raw_data_str, OTX_CPT_MAX_MBOX_DATA_STR_SIZE, false);\n\tif (vf_id >= 0)\n\t\tpr_debug(\"MBOX msg %s received from VF%d raw_data %s\",\n\t\t\t get_mbox_opcode_str(mbox_msg->msg), vf_id,\n\t\t\t raw_data_str);\n\telse\n\t\tpr_debug(\"MBOX msg %s received from PF raw_data %s\",\n\t\t\t get_mbox_opcode_str(mbox_msg->msg), raw_data_str);\n}\n\nstatic void cptvf_send_msg_to_pf(struct otx_cptvf *cptvf,\n\t\t\t\t     struct otx_cpt_mbox *mbx)\n{\n\t \n\twriteq(mbx->msg, cptvf->reg_base + OTX_CPT_VFX_PF_MBOXX(0, 0));\n\twriteq(mbx->data, cptvf->reg_base + OTX_CPT_VFX_PF_MBOXX(0, 1));\n}\n\n \nvoid otx_cptvf_handle_mbox_intr(struct otx_cptvf *cptvf)\n{\n\tstruct otx_cpt_mbox mbx = {};\n\n\t \n\tmbx.msg  = readq(cptvf->reg_base + OTX_CPT_VFX_PF_MBOXX(0, 0));\n\tmbx.data = readq(cptvf->reg_base + OTX_CPT_VFX_PF_MBOXX(0, 1));\n\n\tdump_mbox_msg(&mbx, -1);\n\n\tswitch (mbx.msg) {\n\tcase OTX_CPT_MSG_VF_UP:\n\t\tcptvf->pf_acked = true;\n\t\tcptvf->num_vfs = mbx.data;\n\t\tbreak;\n\tcase OTX_CPT_MSG_READY:\n\t\tcptvf->pf_acked = true;\n\t\tcptvf->vfid = mbx.data;\n\t\tdev_dbg(&cptvf->pdev->dev, \"Received VFID %d\\n\", cptvf->vfid);\n\t\tbreak;\n\tcase OTX_CPT_MSG_QBIND_GRP:\n\t\tcptvf->pf_acked = true;\n\t\tcptvf->vftype = mbx.data;\n\t\tdev_dbg(&cptvf->pdev->dev, \"VF %d type %s group %d\\n\",\n\t\t\tcptvf->vfid,\n\t\t\t((mbx.data == OTX_CPT_SE_TYPES) ? \"SE\" : \"AE\"),\n\t\t\tcptvf->vfgrp);\n\t\tbreak;\n\tcase OTX_CPT_MSG_ACK:\n\t\tcptvf->pf_acked = true;\n\t\tbreak;\n\tcase OTX_CPT_MSG_NACK:\n\t\tcptvf->pf_nacked = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&cptvf->pdev->dev, \"Invalid msg from PF, msg 0x%llx\\n\",\n\t\t\tmbx.msg);\n\t\tbreak;\n\t}\n}\n\nstatic int cptvf_send_msg_to_pf_timeout(struct otx_cptvf *cptvf,\n\t\t\t\t\tstruct otx_cpt_mbox *mbx)\n{\n\tint timeout = CPT_MBOX_MSG_TIMEOUT;\n\tint sleep = 10;\n\n\tcptvf->pf_acked = false;\n\tcptvf->pf_nacked = false;\n\tcptvf_send_msg_to_pf(cptvf, mbx);\n\t \n\twhile (!cptvf->pf_acked) {\n\t\tif (cptvf->pf_nacked)\n\t\t\treturn -EINVAL;\n\t\tmsleep(sleep);\n\t\tif (cptvf->pf_acked)\n\t\t\tbreak;\n\t\ttimeout -= sleep;\n\t\tif (!timeout) {\n\t\t\tdev_err(&cptvf->pdev->dev,\n\t\t\t\t\"PF didn't ack to mbox msg %llx from VF%u\\n\",\n\t\t\t\tmbx->msg, cptvf->vfid);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint otx_cptvf_check_pf_ready(struct otx_cptvf *cptvf)\n{\n\tstruct otx_cpt_mbox mbx = {};\n\n\tmbx.msg = OTX_CPT_MSG_READY;\n\n\treturn cptvf_send_msg_to_pf_timeout(cptvf, &mbx);\n}\n\n \nint otx_cptvf_send_vq_size_msg(struct otx_cptvf *cptvf)\n{\n\tstruct otx_cpt_mbox mbx = {};\n\n\tmbx.msg = OTX_CPT_MSG_QLEN;\n\tmbx.data = cptvf->qsize;\n\n\treturn cptvf_send_msg_to_pf_timeout(cptvf, &mbx);\n}\n\n \nint otx_cptvf_send_vf_to_grp_msg(struct otx_cptvf *cptvf, int group)\n{\n\tstruct otx_cpt_mbox mbx = {};\n\tint ret;\n\n\tmbx.msg = OTX_CPT_MSG_QBIND_GRP;\n\t \n\tmbx.data = group;\n\tret = cptvf_send_msg_to_pf_timeout(cptvf, &mbx);\n\tif (ret)\n\t\treturn ret;\n\tcptvf->vfgrp = group;\n\n\treturn 0;\n}\n\n \nint otx_cptvf_send_vf_priority_msg(struct otx_cptvf *cptvf)\n{\n\tstruct otx_cpt_mbox mbx = {};\n\n\tmbx.msg = OTX_CPT_MSG_VQ_PRIORITY;\n\t \n\tmbx.data = cptvf->priority;\n\n\treturn cptvf_send_msg_to_pf_timeout(cptvf, &mbx);\n}\n\n \nint otx_cptvf_send_vf_up(struct otx_cptvf *cptvf)\n{\n\tstruct otx_cpt_mbox mbx = {};\n\n\tmbx.msg = OTX_CPT_MSG_VF_UP;\n\n\treturn cptvf_send_msg_to_pf_timeout(cptvf, &mbx);\n}\n\n \nint otx_cptvf_send_vf_down(struct otx_cptvf *cptvf)\n{\n\tstruct otx_cpt_mbox mbx = {};\n\n\tmbx.msg = OTX_CPT_MSG_VF_DOWN;\n\n\treturn cptvf_send_msg_to_pf_timeout(cptvf, &mbx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}