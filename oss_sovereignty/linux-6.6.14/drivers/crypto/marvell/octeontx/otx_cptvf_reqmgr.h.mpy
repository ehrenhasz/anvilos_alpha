{
  "module_name": "otx_cptvf_reqmgr.h",
  "hash_id": "3ccb0fa8a5e468806b069d8215064cc503cb7817ea34424561c4701ecfe8d63f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/marvell/octeontx/otx_cptvf_reqmgr.h",
  "human_readable_source": " \n\n#ifndef __OTX_CPTVF_REQUEST_MANAGER_H\n#define __OTX_CPTVF_REQUEST_MANAGER_H\n\n#include <linux/types.h>\n#include <linux/crypto.h>\n#include <linux/pci.h>\n#include \"otx_cpt_hw_types.h\"\n\n \n#define OTX_CPT_MAX_SG_IN_CNT\t\t50\n#define OTX_CPT_MAX_SG_OUT_CNT\t\t50\n\n \n#define OTX_CPT_DMA_DIRECT_DIRECT\t0\n#define OTX_CPT_DMA_GATHER_SCATTER\t1\n\n \n#define OTX_CPT_FROM_CPTR\t\t0\n#define OTX_CPT_FROM_DPTR\t\t1\n\n \n#define OTX_CPT_INST_Q_ALIGNMENT\t128\n#define OTX_CPT_MAX_REQ_SIZE\t\t65535\n\n \n#define OTX_CPT_COMMAND_TIMEOUT\t\t4\n#define OTX_CPT_TIMER_HOLD\t\t0x03F\n#define OTX_CPT_COUNT_HOLD\t\t32\n#define OTX_CPT_TIME_IN_RESET_COUNT     5\n\n \n#define OTX_CPT_COALESC_MIN_TIME_WAIT\t0x0\n#define OTX_CPT_COALESC_MAX_TIME_WAIT\t((1<<16)-1)\n#define OTX_CPT_COALESC_MIN_NUM_WAIT\t0x0\n#define OTX_CPT_COALESC_MAX_NUM_WAIT\t((1<<20)-1)\n\nunion otx_cpt_opcode_info {\n\tu16 flags;\n\tstruct {\n\t\tu8 major;\n\t\tu8 minor;\n\t} s;\n};\n\nstruct otx_cptvf_request {\n\tu32 param1;\n\tu32 param2;\n\tu16 dlen;\n\tunion otx_cpt_opcode_info opcode;\n};\n\nstruct otx_cpt_buf_ptr {\n\tu8 *vptr;\n\tdma_addr_t dma_addr;\n\tu16 size;\n};\n\nunion otx_cpt_ctrl_info {\n\tu32 flags;\n\tstruct {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t\tu32 reserved0:26;\n\t\tu32 grp:3;\t \n\t\tu32 dma_mode:2;\t \n\t\tu32 se_req:1;\t \n#else\n\t\tu32 se_req:1;\t \n\t\tu32 dma_mode:2;\t \n\t\tu32 grp:3;\t \n\t\tu32 reserved0:26;\n#endif\n\t} s;\n};\n\n \nunion otx_cpt_iq_cmd_word0 {\n\tu64 u64;\n\tstruct {\n\t\t__be16 opcode;\n\t\t__be16 param1;\n\t\t__be16 param2;\n\t\t__be16 dlen;\n\t} s;\n};\n\nunion otx_cpt_iq_cmd_word3 {\n\tu64 u64;\n\tstruct {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t\tu64 grp:3;\n\t\tu64 cptr:61;\n#else\n\t\tu64 cptr:61;\n\t\tu64 grp:3;\n#endif\n\t} s;\n};\n\nstruct otx_cpt_iq_cmd {\n\tunion otx_cpt_iq_cmd_word0 cmd;\n\tu64 dptr;\n\tu64 rptr;\n\tunion otx_cpt_iq_cmd_word3 cptr;\n};\n\nstruct otx_cpt_sglist_component {\n\tunion {\n\t\tu64 len;\n\t\tstruct {\n\t\t\t__be16 len0;\n\t\t\t__be16 len1;\n\t\t\t__be16 len2;\n\t\t\t__be16 len3;\n\t\t} s;\n\t} u;\n\t__be64 ptr0;\n\t__be64 ptr1;\n\t__be64 ptr2;\n\t__be64 ptr3;\n};\n\nstruct otx_cpt_pending_entry {\n\tu64 *completion_addr;\t \n\tstruct otx_cpt_info_buffer *info;\n\t \n\tvoid (*callback)(int status, void *arg1, void *arg2);\n\tstruct crypto_async_request *areq;  \n\tu8 resume_sender;\t \n\tu8 busy;\t\t \n};\n\nstruct otx_cpt_pending_queue {\n\tstruct otx_cpt_pending_entry *head;\t \n\tu32 front;\t\t\t \n\tu32 rear;\t\t\t \n\tu32 pending_count;\t\t \n\tu32 qlen;\t\t\t \n\tspinlock_t lock;\t\t \n};\n\nstruct otx_cpt_req_info {\n\t \n\tvoid (*callback)(int status, void *arg1, void *arg2);\n\tstruct crypto_async_request *areq;  \n\tstruct otx_cptvf_request req; \n\tunion otx_cpt_ctrl_info ctrl; \n\tstruct otx_cpt_buf_ptr in[OTX_CPT_MAX_SG_IN_CNT];\n\tstruct otx_cpt_buf_ptr out[OTX_CPT_MAX_SG_OUT_CNT];\n\tu8 *iv_out;      \n\tu16 rlen;\t \n\tu8 incnt;\t \n\tu8 outcnt;\t \n\tu8 req_type;\t \n\tu8 is_enc;\t \n\tu8 is_trunc_hmac; \n};\n\nstruct otx_cpt_info_buffer {\n\tstruct otx_cpt_pending_entry *pentry;\n\tstruct otx_cpt_req_info *req;\n\tstruct pci_dev *pdev;\n\tu64 *completion_addr;\n\tu8 *out_buffer;\n\tu8 *in_buffer;\n\tdma_addr_t dptr_baddr;\n\tdma_addr_t rptr_baddr;\n\tdma_addr_t comp_baddr;\n\tunsigned long time_in;\n\tu32 dlen;\n\tu32 dma_len;\n\tu8 extra_time;\n};\n\nstatic inline void do_request_cleanup(struct pci_dev *pdev,\n\t\t\t\t      struct otx_cpt_info_buffer *info)\n{\n\tstruct otx_cpt_req_info *req;\n\tint i;\n\n\tif (info->dptr_baddr)\n\t\tdma_unmap_single(&pdev->dev, info->dptr_baddr,\n\t\t\t\t info->dma_len, DMA_BIDIRECTIONAL);\n\n\tif (info->req) {\n\t\treq = info->req;\n\t\tfor (i = 0; i < req->outcnt; i++) {\n\t\t\tif (req->out[i].dma_addr)\n\t\t\t\tdma_unmap_single(&pdev->dev,\n\t\t\t\t\t\t req->out[i].dma_addr,\n\t\t\t\t\t\t req->out[i].size,\n\t\t\t\t\t\t DMA_BIDIRECTIONAL);\n\t\t}\n\n\t\tfor (i = 0; i < req->incnt; i++) {\n\t\t\tif (req->in[i].dma_addr)\n\t\t\t\tdma_unmap_single(&pdev->dev,\n\t\t\t\t\t\t req->in[i].dma_addr,\n\t\t\t\t\t\t req->in[i].size,\n\t\t\t\t\t\t DMA_BIDIRECTIONAL);\n\t\t}\n\t}\n\tkfree_sensitive(info);\n}\n\nstruct otx_cptvf_wqe;\nvoid otx_cpt_dump_sg_list(struct pci_dev *pdev, struct otx_cpt_req_info *req);\nvoid otx_cpt_post_process(struct otx_cptvf_wqe *wqe);\nint otx_cpt_do_request(struct pci_dev *pdev, struct otx_cpt_req_info *req,\n\t\t       int cpu_num);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}