{
  "module_name": "sun8i-ce-core.c",
  "hash_id": "16606b8c9aa8d2cb6eeb84a74335f132ce3ef8fd682d4e578b94860539470be1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/allwinner/sun8i-ce/sun8i-ce-core.c",
  "human_readable_source": "\n \n\n#include <crypto/engine.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/rng.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include \"sun8i-ce.h\"\n\n \nstatic const struct ce_variant ce_h3_variant = {\n\t.alg_cipher = { CE_ALG_AES, CE_ALG_DES, CE_ALG_3DES,\n\t},\n\t.alg_hash = { CE_ALG_MD5, CE_ALG_SHA1, CE_ALG_SHA224, CE_ALG_SHA256,\n\t\tCE_ALG_SHA384, CE_ALG_SHA512\n\t},\n\t.op_mode = { CE_OP_ECB, CE_OP_CBC\n\t},\n\t.ce_clks = {\n\t\t{ \"bus\", 0, 200000000 },\n\t\t{ \"mod\", 50000000, 0 },\n\t\t},\n\t.esr = ESR_H3,\n\t.prng = CE_ALG_PRNG,\n\t.trng = CE_ID_NOTSUPP,\n};\n\nstatic const struct ce_variant ce_h5_variant = {\n\t.alg_cipher = { CE_ALG_AES, CE_ALG_DES, CE_ALG_3DES,\n\t},\n\t.alg_hash = { CE_ALG_MD5, CE_ALG_SHA1, CE_ALG_SHA224, CE_ALG_SHA256,\n\t\tCE_ID_NOTSUPP, CE_ID_NOTSUPP\n\t},\n\t.op_mode = { CE_OP_ECB, CE_OP_CBC\n\t},\n\t.ce_clks = {\n\t\t{ \"bus\", 0, 200000000 },\n\t\t{ \"mod\", 300000000, 0 },\n\t\t},\n\t.esr = ESR_H5,\n\t.prng = CE_ALG_PRNG,\n\t.trng = CE_ID_NOTSUPP,\n};\n\nstatic const struct ce_variant ce_h6_variant = {\n\t.alg_cipher = { CE_ALG_AES, CE_ALG_DES, CE_ALG_3DES,\n\t},\n\t.alg_hash = { CE_ALG_MD5, CE_ALG_SHA1, CE_ALG_SHA224, CE_ALG_SHA256,\n\t\tCE_ALG_SHA384, CE_ALG_SHA512\n\t},\n\t.op_mode = { CE_OP_ECB, CE_OP_CBC\n\t},\n\t.cipher_t_dlen_in_bytes = true,\n\t.hash_t_dlen_in_bits = true,\n\t.prng_t_dlen_in_bytes = true,\n\t.trng_t_dlen_in_bytes = true,\n\t.ce_clks = {\n\t\t{ \"bus\", 0, 200000000 },\n\t\t{ \"mod\", 300000000, 0 },\n\t\t{ \"ram\", 0, 400000000 },\n\t\t},\n\t.esr = ESR_H6,\n\t.prng = CE_ALG_PRNG_V2,\n\t.trng = CE_ALG_TRNG_V2,\n};\n\nstatic const struct ce_variant ce_a64_variant = {\n\t.alg_cipher = { CE_ALG_AES, CE_ALG_DES, CE_ALG_3DES,\n\t},\n\t.alg_hash = { CE_ALG_MD5, CE_ALG_SHA1, CE_ALG_SHA224, CE_ALG_SHA256,\n\t\tCE_ID_NOTSUPP, CE_ID_NOTSUPP\n\t},\n\t.op_mode = { CE_OP_ECB, CE_OP_CBC\n\t},\n\t.ce_clks = {\n\t\t{ \"bus\", 0, 200000000 },\n\t\t{ \"mod\", 300000000, 0 },\n\t\t},\n\t.esr = ESR_A64,\n\t.prng = CE_ALG_PRNG,\n\t.trng = CE_ID_NOTSUPP,\n};\n\nstatic const struct ce_variant ce_d1_variant = {\n\t.alg_cipher = { CE_ALG_AES, CE_ALG_DES, CE_ALG_3DES,\n\t},\n\t.alg_hash = { CE_ALG_MD5, CE_ALG_SHA1, CE_ALG_SHA224, CE_ALG_SHA256,\n\t\tCE_ALG_SHA384, CE_ALG_SHA512\n\t},\n\t.op_mode = { CE_OP_ECB, CE_OP_CBC\n\t},\n\t.ce_clks = {\n\t\t{ \"bus\", 0, 200000000 },\n\t\t{ \"mod\", 300000000, 0 },\n\t\t{ \"ram\", 0, 400000000 },\n\t\t{ \"trng\", 0, 0 },\n\t\t},\n\t.esr = ESR_D1,\n\t.prng = CE_ALG_PRNG,\n\t.trng = CE_ALG_TRNG,\n};\n\nstatic const struct ce_variant ce_r40_variant = {\n\t.alg_cipher = { CE_ALG_AES, CE_ALG_DES, CE_ALG_3DES,\n\t},\n\t.alg_hash = { CE_ALG_MD5, CE_ALG_SHA1, CE_ALG_SHA224, CE_ALG_SHA256,\n\t\tCE_ID_NOTSUPP, CE_ID_NOTSUPP\n\t},\n\t.op_mode = { CE_OP_ECB, CE_OP_CBC\n\t},\n\t.ce_clks = {\n\t\t{ \"bus\", 0, 200000000 },\n\t\t{ \"mod\", 300000000, 0 },\n\t\t},\n\t.esr = ESR_R40,\n\t.prng = CE_ALG_PRNG,\n\t.trng = CE_ID_NOTSUPP,\n};\n\n \nint sun8i_ce_get_engine_number(struct sun8i_ce_dev *ce)\n{\n\treturn atomic_inc_return(&ce->flow) % (MAXFLOW - 1);\n}\n\nint sun8i_ce_run_task(struct sun8i_ce_dev *ce, int flow, const char *name)\n{\n\tu32 v;\n\tint err = 0;\n\tstruct ce_task *cet = ce->chanlist[flow].tl;\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG\n\tce->chanlist[flow].stat_req++;\n#endif\n\n\tmutex_lock(&ce->mlock);\n\n\tv = readl(ce->base + CE_ICR);\n\tv |= 1 << flow;\n\twritel(v, ce->base + CE_ICR);\n\n\treinit_completion(&ce->chanlist[flow].complete);\n\twritel(ce->chanlist[flow].t_phy, ce->base + CE_TDQ);\n\n\tce->chanlist[flow].status = 0;\n\t \n\twmb();\n\n\t \n\tv = 1 | ((le32_to_cpu(ce->chanlist[flow].tl->t_common_ctl) & 0x7F) << 8);\n\twritel(v, ce->base + CE_TLR);\n\tmutex_unlock(&ce->mlock);\n\n\twait_for_completion_interruptible_timeout(&ce->chanlist[flow].complete,\n\t\t\tmsecs_to_jiffies(ce->chanlist[flow].timeout));\n\n\tif (ce->chanlist[flow].status == 0) {\n\t\tdev_err(ce->dev, \"DMA timeout for %s (tm=%d) on flow %d\\n\", name,\n\t\t\tce->chanlist[flow].timeout, flow);\n\t\terr = -EFAULT;\n\t}\n\t \n\tv = readl(ce->base + CE_ESR);\n\tswitch (ce->variant->esr) {\n\tcase ESR_H3:\n\t\t \n\t\tif (v) {\n\t\t\tdev_err(ce->dev, \"CE ERROR: %x for flow %x\\n\", v, flow);\n\t\t\terr = -EFAULT;\n\t\t\tprint_hex_dump(KERN_INFO, \"TASK: \", DUMP_PREFIX_NONE, 16, 4,\n\t\t\t\t       cet, sizeof(struct ce_task), false);\n\t\t}\n\t\tif (v & CE_ERR_ALGO_NOTSUP)\n\t\t\tdev_err(ce->dev, \"CE ERROR: algorithm not supported\\n\");\n\t\tif (v & CE_ERR_DATALEN)\n\t\t\tdev_err(ce->dev, \"CE ERROR: data length error\\n\");\n\t\tif (v & CE_ERR_KEYSRAM)\n\t\t\tdev_err(ce->dev, \"CE ERROR: keysram access error for AES\\n\");\n\t\tbreak;\n\tcase ESR_A64:\n\tcase ESR_D1:\n\tcase ESR_H5:\n\tcase ESR_R40:\n\t\tv >>= (flow * 4);\n\t\tv &= 0xF;\n\t\tif (v) {\n\t\t\tdev_err(ce->dev, \"CE ERROR: %x for flow %x\\n\", v, flow);\n\t\t\terr = -EFAULT;\n\t\t\tprint_hex_dump(KERN_INFO, \"TASK: \", DUMP_PREFIX_NONE, 16, 4,\n\t\t\t\t       cet, sizeof(struct ce_task), false);\n\t\t}\n\t\tif (v & CE_ERR_ALGO_NOTSUP)\n\t\t\tdev_err(ce->dev, \"CE ERROR: algorithm not supported\\n\");\n\t\tif (v & CE_ERR_DATALEN)\n\t\t\tdev_err(ce->dev, \"CE ERROR: data length error\\n\");\n\t\tif (v & CE_ERR_KEYSRAM)\n\t\t\tdev_err(ce->dev, \"CE ERROR: keysram access error for AES\\n\");\n\t\tbreak;\n\tcase ESR_H6:\n\t\tv >>= (flow * 8);\n\t\tv &= 0xFF;\n\t\tif (v) {\n\t\t\tdev_err(ce->dev, \"CE ERROR: %x for flow %x\\n\", v, flow);\n\t\t\terr = -EFAULT;\n\t\t\tprint_hex_dump(KERN_INFO, \"TASK: \", DUMP_PREFIX_NONE, 16, 4,\n\t\t\t\t       cet, sizeof(struct ce_task), false);\n\t\t}\n\t\tif (v & CE_ERR_ALGO_NOTSUP)\n\t\t\tdev_err(ce->dev, \"CE ERROR: algorithm not supported\\n\");\n\t\tif (v & CE_ERR_DATALEN)\n\t\t\tdev_err(ce->dev, \"CE ERROR: data length error\\n\");\n\t\tif (v & CE_ERR_KEYSRAM)\n\t\t\tdev_err(ce->dev, \"CE ERROR: keysram access error for AES\\n\");\n\t\tif (v & CE_ERR_ADDR_INVALID)\n\t\t\tdev_err(ce->dev, \"CE ERROR: address invalid\\n\");\n\t\tif (v & CE_ERR_KEYLADDER)\n\t\t\tdev_err(ce->dev, \"CE ERROR: key ladder configuration error\\n\");\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic irqreturn_t ce_irq_handler(int irq, void *data)\n{\n\tstruct sun8i_ce_dev *ce = (struct sun8i_ce_dev *)data;\n\tint flow = 0;\n\tu32 p;\n\n\tp = readl(ce->base + CE_ISR);\n\tfor (flow = 0; flow < MAXFLOW; flow++) {\n\t\tif (p & (BIT(flow))) {\n\t\t\twritel(BIT(flow), ce->base + CE_ISR);\n\t\t\tce->chanlist[flow].status = 1;\n\t\t\tcomplete(&ce->chanlist[flow].complete);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct sun8i_ce_alg_template ce_algs[] = {\n{\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.ce_algo_id = CE_ID_CIPHER_AES,\n\t.ce_blockmode = CE_ID_OP_CBC,\n\t.alg.skcipher.base = {\n\t\t.base = {\n\t\t\t.cra_name = \"cbc(aes)\",\n\t\t\t.cra_driver_name = \"cbc-aes-sun8i-ce\",\n\t\t\t.cra_priority = 400,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun8i_cipher_tfm_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 0xf,\n\t\t\t.cra_init = sun8i_ce_cipher_init,\n\t\t\t.cra_exit = sun8i_ce_cipher_exit,\n\t\t},\n\t\t.min_keysize\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.setkey\t\t= sun8i_ce_aes_setkey,\n\t\t.encrypt\t= sun8i_ce_skencrypt,\n\t\t.decrypt\t= sun8i_ce_skdecrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = sun8i_ce_cipher_do_one,\n\t},\n},\n{\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.ce_algo_id = CE_ID_CIPHER_AES,\n\t.ce_blockmode = CE_ID_OP_ECB,\n\t.alg.skcipher.base = {\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(aes)\",\n\t\t\t.cra_driver_name = \"ecb-aes-sun8i-ce\",\n\t\t\t.cra_priority = 400,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun8i_cipher_tfm_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 0xf,\n\t\t\t.cra_init = sun8i_ce_cipher_init,\n\t\t\t.cra_exit = sun8i_ce_cipher_exit,\n\t\t},\n\t\t.min_keysize\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t= AES_MAX_KEY_SIZE,\n\t\t.setkey\t\t= sun8i_ce_aes_setkey,\n\t\t.encrypt\t= sun8i_ce_skencrypt,\n\t\t.decrypt\t= sun8i_ce_skdecrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = sun8i_ce_cipher_do_one,\n\t},\n},\n{\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.ce_algo_id = CE_ID_CIPHER_DES3,\n\t.ce_blockmode = CE_ID_OP_CBC,\n\t.alg.skcipher.base = {\n\t\t.base = {\n\t\t\t.cra_name = \"cbc(des3_ede)\",\n\t\t\t.cra_driver_name = \"cbc-des3-sun8i-ce\",\n\t\t\t.cra_priority = 400,\n\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun8i_cipher_tfm_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 0xf,\n\t\t\t.cra_init = sun8i_ce_cipher_init,\n\t\t\t.cra_exit = sun8i_ce_cipher_exit,\n\t\t},\n\t\t.min_keysize\t= DES3_EDE_KEY_SIZE,\n\t\t.max_keysize\t= DES3_EDE_KEY_SIZE,\n\t\t.ivsize\t\t= DES3_EDE_BLOCK_SIZE,\n\t\t.setkey\t\t= sun8i_ce_des3_setkey,\n\t\t.encrypt\t= sun8i_ce_skencrypt,\n\t\t.decrypt\t= sun8i_ce_skdecrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = sun8i_ce_cipher_do_one,\n\t},\n},\n{\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.ce_algo_id = CE_ID_CIPHER_DES3,\n\t.ce_blockmode = CE_ID_OP_ECB,\n\t.alg.skcipher.base = {\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(des3_ede)\",\n\t\t\t.cra_driver_name = \"ecb-des3-sun8i-ce\",\n\t\t\t.cra_priority = 400,\n\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun8i_cipher_tfm_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 0xf,\n\t\t\t.cra_init = sun8i_ce_cipher_init,\n\t\t\t.cra_exit = sun8i_ce_cipher_exit,\n\t\t},\n\t\t.min_keysize\t= DES3_EDE_KEY_SIZE,\n\t\t.max_keysize\t= DES3_EDE_KEY_SIZE,\n\t\t.setkey\t\t= sun8i_ce_des3_setkey,\n\t\t.encrypt\t= sun8i_ce_skencrypt,\n\t\t.decrypt\t= sun8i_ce_skdecrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = sun8i_ce_cipher_do_one,\n\t},\n},\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_HASH\n{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t.ce_algo_id = CE_ID_HASH_MD5,\n\t.alg.hash.base = {\n\t\t.init = sun8i_ce_hash_init,\n\t\t.update = sun8i_ce_hash_update,\n\t\t.final = sun8i_ce_hash_final,\n\t\t.finup = sun8i_ce_hash_finup,\n\t\t.digest = sun8i_ce_hash_digest,\n\t\t.export = sun8i_ce_hash_export,\n\t\t.import = sun8i_ce_hash_import,\n\t\t.init_tfm = sun8i_ce_hash_init_tfm,\n\t\t.exit_tfm = sun8i_ce_hash_exit_tfm,\n\t\t.halg = {\n\t\t\t.digestsize = MD5_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct md5_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"md5\",\n\t\t\t\t.cra_driver_name = \"md5-sun8i-ce\",\n\t\t\t\t.cra_priority = 300,\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_flags = CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize = MD5_HMAC_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct sun8i_ce_hash_tfm_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t}\n\t},\n\t.alg.hash.op = {\n\t\t.do_one_request = sun8i_ce_hash_run,\n\t},\n\n},\n{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t.ce_algo_id = CE_ID_HASH_SHA1,\n\t.alg.hash.base = {\n\t\t.init = sun8i_ce_hash_init,\n\t\t.update = sun8i_ce_hash_update,\n\t\t.final = sun8i_ce_hash_final,\n\t\t.finup = sun8i_ce_hash_finup,\n\t\t.digest = sun8i_ce_hash_digest,\n\t\t.export = sun8i_ce_hash_export,\n\t\t.import = sun8i_ce_hash_import,\n\t\t.init_tfm = sun8i_ce_hash_init_tfm,\n\t\t.exit_tfm = sun8i_ce_hash_exit_tfm,\n\t\t.halg = {\n\t\t\t.digestsize = SHA1_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct sha1_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha1\",\n\t\t\t\t.cra_driver_name = \"sha1-sun8i-ce\",\n\t\t\t\t.cra_priority = 300,\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_flags = CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize = SHA1_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct sun8i_ce_hash_tfm_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t}\n\t},\n\t.alg.hash.op = {\n\t\t.do_one_request = sun8i_ce_hash_run,\n\t},\n},\n{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t.ce_algo_id = CE_ID_HASH_SHA224,\n\t.alg.hash.base = {\n\t\t.init = sun8i_ce_hash_init,\n\t\t.update = sun8i_ce_hash_update,\n\t\t.final = sun8i_ce_hash_final,\n\t\t.finup = sun8i_ce_hash_finup,\n\t\t.digest = sun8i_ce_hash_digest,\n\t\t.export = sun8i_ce_hash_export,\n\t\t.import = sun8i_ce_hash_import,\n\t\t.init_tfm = sun8i_ce_hash_init_tfm,\n\t\t.exit_tfm = sun8i_ce_hash_exit_tfm,\n\t\t.halg = {\n\t\t\t.digestsize = SHA224_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct sha256_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha224\",\n\t\t\t\t.cra_driver_name = \"sha224-sun8i-ce\",\n\t\t\t\t.cra_priority = 300,\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_flags = CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize = SHA224_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct sun8i_ce_hash_tfm_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t}\n\t},\n\t.alg.hash.op = {\n\t\t.do_one_request = sun8i_ce_hash_run,\n\t},\n},\n{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t.ce_algo_id = CE_ID_HASH_SHA256,\n\t.alg.hash.base = {\n\t\t.init = sun8i_ce_hash_init,\n\t\t.update = sun8i_ce_hash_update,\n\t\t.final = sun8i_ce_hash_final,\n\t\t.finup = sun8i_ce_hash_finup,\n\t\t.digest = sun8i_ce_hash_digest,\n\t\t.export = sun8i_ce_hash_export,\n\t\t.import = sun8i_ce_hash_import,\n\t\t.init_tfm = sun8i_ce_hash_init_tfm,\n\t\t.exit_tfm = sun8i_ce_hash_exit_tfm,\n\t\t.halg = {\n\t\t\t.digestsize = SHA256_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct sha256_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha256\",\n\t\t\t\t.cra_driver_name = \"sha256-sun8i-ce\",\n\t\t\t\t.cra_priority = 300,\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_flags = CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize = SHA256_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct sun8i_ce_hash_tfm_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t}\n\t},\n\t.alg.hash.op = {\n\t\t.do_one_request = sun8i_ce_hash_run,\n\t},\n},\n{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t.ce_algo_id = CE_ID_HASH_SHA384,\n\t.alg.hash.base = {\n\t\t.init = sun8i_ce_hash_init,\n\t\t.update = sun8i_ce_hash_update,\n\t\t.final = sun8i_ce_hash_final,\n\t\t.finup = sun8i_ce_hash_finup,\n\t\t.digest = sun8i_ce_hash_digest,\n\t\t.export = sun8i_ce_hash_export,\n\t\t.import = sun8i_ce_hash_import,\n\t\t.init_tfm = sun8i_ce_hash_init_tfm,\n\t\t.exit_tfm = sun8i_ce_hash_exit_tfm,\n\t\t.halg = {\n\t\t\t.digestsize = SHA384_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct sha512_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha384\",\n\t\t\t\t.cra_driver_name = \"sha384-sun8i-ce\",\n\t\t\t\t.cra_priority = 300,\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_flags = CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize = SHA384_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct sun8i_ce_hash_tfm_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t}\n\t},\n\t.alg.hash.op = {\n\t\t.do_one_request = sun8i_ce_hash_run,\n\t},\n},\n{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t.ce_algo_id = CE_ID_HASH_SHA512,\n\t.alg.hash.base = {\n\t\t.init = sun8i_ce_hash_init,\n\t\t.update = sun8i_ce_hash_update,\n\t\t.final = sun8i_ce_hash_final,\n\t\t.finup = sun8i_ce_hash_finup,\n\t\t.digest = sun8i_ce_hash_digest,\n\t\t.export = sun8i_ce_hash_export,\n\t\t.import = sun8i_ce_hash_import,\n\t\t.init_tfm = sun8i_ce_hash_init_tfm,\n\t\t.exit_tfm = sun8i_ce_hash_exit_tfm,\n\t\t.halg = {\n\t\t\t.digestsize = SHA512_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct sha512_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha512\",\n\t\t\t\t.cra_driver_name = \"sha512-sun8i-ce\",\n\t\t\t\t.cra_priority = 300,\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_flags = CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize = SHA512_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct sun8i_ce_hash_tfm_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t}\n\t},\n\t.alg.hash.op = {\n\t\t.do_one_request = sun8i_ce_hash_run,\n\t},\n},\n#endif\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_PRNG\n{\n\t.type = CRYPTO_ALG_TYPE_RNG,\n\t.alg.rng = {\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"stdrng\",\n\t\t\t.cra_driver_name\t= \"sun8i-ce-prng\",\n\t\t\t.cra_priority\t\t= 300,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct sun8i_ce_rng_tfm_ctx),\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t\t.cra_init\t\t= sun8i_ce_prng_init,\n\t\t\t.cra_exit\t\t= sun8i_ce_prng_exit,\n\t\t},\n\t\t.generate               = sun8i_ce_prng_generate,\n\t\t.seed                   = sun8i_ce_prng_seed,\n\t\t.seedsize               = PRNG_SEED_SIZE,\n\t}\n},\n#endif\n};\n\nstatic int sun8i_ce_debugfs_show(struct seq_file *seq, void *v)\n{\n\tstruct sun8i_ce_dev *ce __maybe_unused = seq->private;\n\tunsigned int i;\n\n\tfor (i = 0; i < MAXFLOW; i++)\n\t\tseq_printf(seq, \"Channel %d: nreq %lu\\n\", i,\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG\n\t\t\t   ce->chanlist[i].stat_req);\n#else\n\t\t\t   0ul);\n#endif\n\n\tfor (i = 0; i < ARRAY_SIZE(ce_algs); i++) {\n\t\tif (!ce_algs[i].ce)\n\t\t\tcontinue;\n\t\tswitch (ce_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tseq_printf(seq, \"%s %s reqs=%lu fallback=%lu\\n\",\n\t\t\t\t   ce_algs[i].alg.skcipher.base.base.cra_driver_name,\n\t\t\t\t   ce_algs[i].alg.skcipher.base.base.cra_name,\n\t\t\t\t   ce_algs[i].stat_req, ce_algs[i].stat_fb);\n\t\t\tseq_printf(seq, \"\\tLast fallback is: %s\\n\",\n\t\t\t\t   ce_algs[i].fbname);\n\t\t\tseq_printf(seq, \"\\tFallback due to 0 length: %lu\\n\",\n\t\t\t\t   ce_algs[i].stat_fb_len0);\n\t\t\tseq_printf(seq, \"\\tFallback due to length !mod16: %lu\\n\",\n\t\t\t\t   ce_algs[i].stat_fb_mod16);\n\t\t\tseq_printf(seq, \"\\tFallback due to length < IV: %lu\\n\",\n\t\t\t\t   ce_algs[i].stat_fb_leniv);\n\t\t\tseq_printf(seq, \"\\tFallback due to source alignment: %lu\\n\",\n\t\t\t\t   ce_algs[i].stat_fb_srcali);\n\t\t\tseq_printf(seq, \"\\tFallback due to dest alignment: %lu\\n\",\n\t\t\t\t   ce_algs[i].stat_fb_dstali);\n\t\t\tseq_printf(seq, \"\\tFallback due to source length: %lu\\n\",\n\t\t\t\t   ce_algs[i].stat_fb_srclen);\n\t\t\tseq_printf(seq, \"\\tFallback due to dest length: %lu\\n\",\n\t\t\t\t   ce_algs[i].stat_fb_dstlen);\n\t\t\tseq_printf(seq, \"\\tFallback due to SG numbers: %lu\\n\",\n\t\t\t\t   ce_algs[i].stat_fb_maxsg);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\tseq_printf(seq, \"%s %s reqs=%lu fallback=%lu\\n\",\n\t\t\t\t   ce_algs[i].alg.hash.base.halg.base.cra_driver_name,\n\t\t\t\t   ce_algs[i].alg.hash.base.halg.base.cra_name,\n\t\t\t\t   ce_algs[i].stat_req, ce_algs[i].stat_fb);\n\t\t\tseq_printf(seq, \"\\tLast fallback is: %s\\n\",\n\t\t\t\t   ce_algs[i].fbname);\n\t\t\tseq_printf(seq, \"\\tFallback due to 0 length: %lu\\n\",\n\t\t\t\t   ce_algs[i].stat_fb_len0);\n\t\t\tseq_printf(seq, \"\\tFallback due to length: %lu\\n\",\n\t\t\t\t   ce_algs[i].stat_fb_srclen);\n\t\t\tseq_printf(seq, \"\\tFallback due to alignment: %lu\\n\",\n\t\t\t\t   ce_algs[i].stat_fb_srcali);\n\t\t\tseq_printf(seq, \"\\tFallback due to SG numbers: %lu\\n\",\n\t\t\t\t   ce_algs[i].stat_fb_maxsg);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_RNG:\n\t\t\tseq_printf(seq, \"%s %s reqs=%lu bytes=%lu\\n\",\n\t\t\t\t   ce_algs[i].alg.rng.base.cra_driver_name,\n\t\t\t\t   ce_algs[i].alg.rng.base.cra_name,\n\t\t\t\t   ce_algs[i].stat_req, ce_algs[i].stat_bytes);\n\t\t\tbreak;\n\t\t}\n\t}\n#if defined(CONFIG_CRYPTO_DEV_SUN8I_CE_TRNG) && \\\n    defined(CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG)\n\tseq_printf(seq, \"HWRNG %lu %lu\\n\",\n\t\t   ce->hwrng_stat_req, ce->hwrng_stat_bytes);\n#endif\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(sun8i_ce_debugfs);\n\nstatic void sun8i_ce_free_chanlist(struct sun8i_ce_dev *ce, int i)\n{\n\twhile (i >= 0) {\n\t\tcrypto_engine_exit(ce->chanlist[i].engine);\n\t\tif (ce->chanlist[i].tl)\n\t\t\tdma_free_coherent(ce->dev, sizeof(struct ce_task),\n\t\t\t\t\t  ce->chanlist[i].tl,\n\t\t\t\t\t  ce->chanlist[i].t_phy);\n\t\ti--;\n\t}\n}\n\n \nstatic int sun8i_ce_allocate_chanlist(struct sun8i_ce_dev *ce)\n{\n\tint i, err;\n\n\tce->chanlist = devm_kcalloc(ce->dev, MAXFLOW,\n\t\t\t\t    sizeof(struct sun8i_ce_flow), GFP_KERNEL);\n\tif (!ce->chanlist)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < MAXFLOW; i++) {\n\t\tinit_completion(&ce->chanlist[i].complete);\n\n\t\tce->chanlist[i].engine = crypto_engine_alloc_init(ce->dev, true);\n\t\tif (!ce->chanlist[i].engine) {\n\t\t\tdev_err(ce->dev, \"Cannot allocate engine\\n\");\n\t\t\ti--;\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_engine;\n\t\t}\n\t\terr = crypto_engine_start(ce->chanlist[i].engine);\n\t\tif (err) {\n\t\t\tdev_err(ce->dev, \"Cannot start engine\\n\");\n\t\t\tgoto error_engine;\n\t\t}\n\t\tce->chanlist[i].tl = dma_alloc_coherent(ce->dev,\n\t\t\t\t\t\t\tsizeof(struct ce_task),\n\t\t\t\t\t\t\t&ce->chanlist[i].t_phy,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!ce->chanlist[i].tl) {\n\t\t\tdev_err(ce->dev, \"Cannot get DMA memory for task %d\\n\",\n\t\t\t\ti);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_engine;\n\t\t}\n\t\tce->chanlist[i].bounce_iv = devm_kmalloc(ce->dev, AES_BLOCK_SIZE,\n\t\t\t\t\t\t\t GFP_KERNEL | GFP_DMA);\n\t\tif (!ce->chanlist[i].bounce_iv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_engine;\n\t\t}\n\t\tce->chanlist[i].backup_iv = devm_kmalloc(ce->dev, AES_BLOCK_SIZE,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ce->chanlist[i].backup_iv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_engine;\n\t\t}\n\t}\n\treturn 0;\nerror_engine:\n\tsun8i_ce_free_chanlist(ce, i);\n\treturn err;\n}\n\n \nstatic int sun8i_ce_pm_suspend(struct device *dev)\n{\n\tstruct sun8i_ce_dev *ce = dev_get_drvdata(dev);\n\tint i;\n\n\treset_control_assert(ce->reset);\n\tfor (i = 0; i < CE_MAX_CLOCKS; i++)\n\t\tclk_disable_unprepare(ce->ceclks[i]);\n\treturn 0;\n}\n\nstatic int sun8i_ce_pm_resume(struct device *dev)\n{\n\tstruct sun8i_ce_dev *ce = dev_get_drvdata(dev);\n\tint err, i;\n\n\tfor (i = 0; i < CE_MAX_CLOCKS; i++) {\n\t\tif (!ce->variant->ce_clks[i].name)\n\t\t\tcontinue;\n\t\terr = clk_prepare_enable(ce->ceclks[i]);\n\t\tif (err) {\n\t\t\tdev_err(ce->dev, \"Cannot prepare_enable %s\\n\",\n\t\t\t\tce->variant->ce_clks[i].name);\n\t\t\tgoto error;\n\t\t}\n\t}\n\terr = reset_control_deassert(ce->reset);\n\tif (err) {\n\t\tdev_err(ce->dev, \"Cannot deassert reset control\\n\");\n\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tsun8i_ce_pm_suspend(dev);\n\treturn err;\n}\n\nstatic const struct dev_pm_ops sun8i_ce_pm_ops = {\n\tSET_RUNTIME_PM_OPS(sun8i_ce_pm_suspend, sun8i_ce_pm_resume, NULL)\n};\n\nstatic int sun8i_ce_pm_init(struct sun8i_ce_dev *ce)\n{\n\tint err;\n\n\tpm_runtime_use_autosuspend(ce->dev);\n\tpm_runtime_set_autosuspend_delay(ce->dev, 2000);\n\n\terr = pm_runtime_set_suspended(ce->dev);\n\tif (err)\n\t\treturn err;\n\tpm_runtime_enable(ce->dev);\n\treturn err;\n}\n\nstatic void sun8i_ce_pm_exit(struct sun8i_ce_dev *ce)\n{\n\tpm_runtime_disable(ce->dev);\n}\n\nstatic int sun8i_ce_get_clks(struct sun8i_ce_dev *ce)\n{\n\tunsigned long cr;\n\tint err, i;\n\n\tfor (i = 0; i < CE_MAX_CLOCKS; i++) {\n\t\tif (!ce->variant->ce_clks[i].name)\n\t\t\tcontinue;\n\t\tce->ceclks[i] = devm_clk_get(ce->dev, ce->variant->ce_clks[i].name);\n\t\tif (IS_ERR(ce->ceclks[i])) {\n\t\t\terr = PTR_ERR(ce->ceclks[i]);\n\t\t\tdev_err(ce->dev, \"Cannot get %s CE clock err=%d\\n\",\n\t\t\t\tce->variant->ce_clks[i].name, err);\n\t\t\treturn err;\n\t\t}\n\t\tcr = clk_get_rate(ce->ceclks[i]);\n\t\tif (!cr)\n\t\t\treturn -EINVAL;\n\t\tif (ce->variant->ce_clks[i].freq > 0 &&\n\t\t    cr != ce->variant->ce_clks[i].freq) {\n\t\t\tdev_info(ce->dev, \"Set %s clock to %lu (%lu Mhz) from %lu (%lu Mhz)\\n\",\n\t\t\t\t ce->variant->ce_clks[i].name,\n\t\t\t\t ce->variant->ce_clks[i].freq,\n\t\t\t\t ce->variant->ce_clks[i].freq / 1000000,\n\t\t\t\t cr, cr / 1000000);\n\t\t\terr = clk_set_rate(ce->ceclks[i], ce->variant->ce_clks[i].freq);\n\t\t\tif (err)\n\t\t\t\tdev_err(ce->dev, \"Fail to set %s clk speed to %lu hz\\n\",\n\t\t\t\t\tce->variant->ce_clks[i].name,\n\t\t\t\t\tce->variant->ce_clks[i].freq);\n\t\t}\n\t\tif (ce->variant->ce_clks[i].max_freq > 0 &&\n\t\t    cr > ce->variant->ce_clks[i].max_freq)\n\t\t\tdev_warn(ce->dev, \"Frequency for %s (%lu hz) is higher than datasheet's recommendation (%lu hz)\",\n\t\t\t\t ce->variant->ce_clks[i].name, cr,\n\t\t\t\t ce->variant->ce_clks[i].max_freq);\n\t}\n\treturn 0;\n}\n\nstatic int sun8i_ce_register_algs(struct sun8i_ce_dev *ce)\n{\n\tint ce_method, err, id;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ce_algs); i++) {\n\t\tce_algs[i].ce = ce;\n\t\tswitch (ce_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tid = ce_algs[i].ce_algo_id;\n\t\t\tce_method = ce->variant->alg_cipher[id];\n\t\t\tif (ce_method == CE_ID_NOTSUPP) {\n\t\t\t\tdev_dbg(ce->dev,\n\t\t\t\t\t\"DEBUG: Algo of %s not supported\\n\",\n\t\t\t\t\tce_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\t\tce_algs[i].ce = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tid = ce_algs[i].ce_blockmode;\n\t\t\tce_method = ce->variant->op_mode[id];\n\t\t\tif (ce_method == CE_ID_NOTSUPP) {\n\t\t\t\tdev_dbg(ce->dev, \"DEBUG: Blockmode of %s not supported\\n\",\n\t\t\t\t\tce_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\t\tce_algs[i].ce = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_info(ce->dev, \"Register %s\\n\",\n\t\t\t\t ce_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\terr = crypto_engine_register_skcipher(&ce_algs[i].alg.skcipher);\n\t\t\tif (err) {\n\t\t\t\tdev_err(ce->dev, \"ERROR: Fail to register %s\\n\",\n\t\t\t\t\tce_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\t\tce_algs[i].ce = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\tid = ce_algs[i].ce_algo_id;\n\t\t\tce_method = ce->variant->alg_hash[id];\n\t\t\tif (ce_method == CE_ID_NOTSUPP) {\n\t\t\t\tdev_info(ce->dev,\n\t\t\t\t\t \"DEBUG: Algo of %s not supported\\n\",\n\t\t\t\t\t ce_algs[i].alg.hash.base.halg.base.cra_name);\n\t\t\t\tce_algs[i].ce = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_info(ce->dev, \"Register %s\\n\",\n\t\t\t\t ce_algs[i].alg.hash.base.halg.base.cra_name);\n\t\t\terr = crypto_engine_register_ahash(&ce_algs[i].alg.hash);\n\t\t\tif (err) {\n\t\t\t\tdev_err(ce->dev, \"ERROR: Fail to register %s\\n\",\n\t\t\t\t\tce_algs[i].alg.hash.base.halg.base.cra_name);\n\t\t\t\tce_algs[i].ce = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_RNG:\n\t\t\tif (ce->variant->prng == CE_ID_NOTSUPP) {\n\t\t\t\tdev_info(ce->dev,\n\t\t\t\t\t \"DEBUG: Algo of %s not supported\\n\",\n\t\t\t\t\t ce_algs[i].alg.rng.base.cra_name);\n\t\t\t\tce_algs[i].ce = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_info(ce->dev, \"Register %s\\n\",\n\t\t\t\t ce_algs[i].alg.rng.base.cra_name);\n\t\t\terr = crypto_register_rng(&ce_algs[i].alg.rng);\n\t\t\tif (err) {\n\t\t\t\tdev_err(ce->dev, \"Fail to register %s\\n\",\n\t\t\t\t\tce_algs[i].alg.rng.base.cra_name);\n\t\t\t\tce_algs[i].ce = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tce_algs[i].ce = NULL;\n\t\t\tdev_err(ce->dev, \"ERROR: tried to register an unknown algo\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sun8i_ce_unregister_algs(struct sun8i_ce_dev *ce)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ce_algs); i++) {\n\t\tif (!ce_algs[i].ce)\n\t\t\tcontinue;\n\t\tswitch (ce_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tdev_info(ce->dev, \"Unregister %d %s\\n\", i,\n\t\t\t\t ce_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\tcrypto_engine_unregister_skcipher(&ce_algs[i].alg.skcipher);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\tdev_info(ce->dev, \"Unregister %d %s\\n\", i,\n\t\t\t\t ce_algs[i].alg.hash.base.halg.base.cra_name);\n\t\t\tcrypto_engine_unregister_ahash(&ce_algs[i].alg.hash);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_RNG:\n\t\t\tdev_info(ce->dev, \"Unregister %d %s\\n\", i,\n\t\t\t\t ce_algs[i].alg.rng.base.cra_name);\n\t\t\tcrypto_unregister_rng(&ce_algs[i].alg.rng);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int sun8i_ce_probe(struct platform_device *pdev)\n{\n\tstruct sun8i_ce_dev *ce;\n\tint err, irq;\n\tu32 v;\n\n\tce = devm_kzalloc(&pdev->dev, sizeof(*ce), GFP_KERNEL);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\n\tce->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ce);\n\n\tce->variant = of_device_get_match_data(&pdev->dev);\n\tif (!ce->variant) {\n\t\tdev_err(&pdev->dev, \"Missing Crypto Engine variant\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tce->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ce->base))\n\t\treturn PTR_ERR(ce->base);\n\n\terr = sun8i_ce_get_clks(ce);\n\tif (err)\n\t\treturn err;\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tce->reset = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(ce->reset))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(ce->reset),\n\t\t\t\t     \"No reset control found\\n\");\n\n\tmutex_init(&ce->mlock);\n\tmutex_init(&ce->rnglock);\n\n\terr = sun8i_ce_allocate_chanlist(ce);\n\tif (err)\n\t\treturn err;\n\n\terr = sun8i_ce_pm_init(ce);\n\tif (err)\n\t\tgoto error_pm;\n\n\terr = devm_request_irq(&pdev->dev, irq, ce_irq_handler, 0,\n\t\t\t       \"sun8i-ce-ns\", ce);\n\tif (err) {\n\t\tdev_err(ce->dev, \"Cannot request CryptoEngine Non-secure IRQ (err=%d)\\n\", err);\n\t\tgoto error_irq;\n\t}\n\n\terr = sun8i_ce_register_algs(ce);\n\tif (err)\n\t\tgoto error_alg;\n\n\terr = pm_runtime_resume_and_get(ce->dev);\n\tif (err < 0)\n\t\tgoto error_alg;\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_TRNG\n\tsun8i_ce_hwrng_register(ce);\n#endif\n\n\tv = readl(ce->base + CE_CTR);\n\tv >>= CE_DIE_ID_SHIFT;\n\tv &= CE_DIE_ID_MASK;\n\tdev_info(&pdev->dev, \"CryptoEngine Die ID %x\\n\", v);\n\n\tpm_runtime_put_sync(ce->dev);\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG)) {\n\t\tstruct dentry *dbgfs_dir __maybe_unused;\n\t\tstruct dentry *dbgfs_stats __maybe_unused;\n\n\t\t \n\t\tdbgfs_dir = debugfs_create_dir(\"sun8i-ce\", NULL);\n\t\tdbgfs_stats = debugfs_create_file(\"stats\", 0444,\n\t\t\t\t\t\t  dbgfs_dir, ce,\n\t\t\t\t\t\t  &sun8i_ce_debugfs_fops);\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG\n\t\tce->dbgfs_dir = dbgfs_dir;\n\t\tce->dbgfs_stats = dbgfs_stats;\n#endif\n\t}\n\n\treturn 0;\nerror_alg:\n\tsun8i_ce_unregister_algs(ce);\nerror_irq:\n\tsun8i_ce_pm_exit(ce);\nerror_pm:\n\tsun8i_ce_free_chanlist(ce, MAXFLOW - 1);\n\treturn err;\n}\n\nstatic int sun8i_ce_remove(struct platform_device *pdev)\n{\n\tstruct sun8i_ce_dev *ce = platform_get_drvdata(pdev);\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_TRNG\n\tsun8i_ce_hwrng_unregister(ce);\n#endif\n\n\tsun8i_ce_unregister_algs(ce);\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG\n\tdebugfs_remove_recursive(ce->dbgfs_dir);\n#endif\n\n\tsun8i_ce_free_chanlist(ce, MAXFLOW - 1);\n\n\tsun8i_ce_pm_exit(ce);\n\treturn 0;\n}\n\nstatic const struct of_device_id sun8i_ce_crypto_of_match_table[] = {\n\t{ .compatible = \"allwinner,sun8i-h3-crypto\",\n\t  .data = &ce_h3_variant },\n\t{ .compatible = \"allwinner,sun8i-r40-crypto\",\n\t  .data = &ce_r40_variant },\n\t{ .compatible = \"allwinner,sun20i-d1-crypto\",\n\t  .data = &ce_d1_variant },\n\t{ .compatible = \"allwinner,sun50i-a64-crypto\",\n\t  .data = &ce_a64_variant },\n\t{ .compatible = \"allwinner,sun50i-h5-crypto\",\n\t  .data = &ce_h5_variant },\n\t{ .compatible = \"allwinner,sun50i-h6-crypto\",\n\t  .data = &ce_h6_variant },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sun8i_ce_crypto_of_match_table);\n\nstatic struct platform_driver sun8i_ce_driver = {\n\t.probe\t\t = sun8i_ce_probe,\n\t.remove\t\t = sun8i_ce_remove,\n\t.driver\t\t = {\n\t\t.name\t\t= \"sun8i-ce\",\n\t\t.pm\t\t= &sun8i_ce_pm_ops,\n\t\t.of_match_table\t= sun8i_ce_crypto_of_match_table,\n\t},\n};\n\nmodule_platform_driver(sun8i_ce_driver);\n\nMODULE_DESCRIPTION(\"Allwinner Crypto Engine cryptographic offloader\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Corentin Labbe <clabbe.montjoie@gmail.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}