{
  "module_name": "sun8i-ce-trng.c",
  "hash_id": "4f489d9e37199a432f0315ac584d0a61b6d6755ae55d320a0185d83d7757d36a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/allwinner/sun8i-ce/sun8i-ce-trng.c",
  "human_readable_source": "\n \n#include \"sun8i-ce.h\"\n#include <linux/dma-mapping.h>\n#include <linux/pm_runtime.h>\n#include <linux/hw_random.h>\n \n\nstatic int sun8i_ce_trng_read(struct hwrng *rng, void *data, size_t max, bool wait)\n{\n\tstruct sun8i_ce_dev *ce;\n\tdma_addr_t dma_dst;\n\tint err = 0;\n\tint flow = 3;\n\tunsigned int todo;\n\tstruct sun8i_ce_flow *chan;\n\tstruct ce_task *cet;\n\tu32 common;\n\tvoid *d;\n\n\tce = container_of(rng, struct sun8i_ce_dev, trng);\n\n\t \n\ttodo = max + 32;\n\ttodo -= todo % 32;\n\n\td = kzalloc(todo, GFP_KERNEL | GFP_DMA);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG\n\tce->hwrng_stat_req++;\n\tce->hwrng_stat_bytes += todo;\n#endif\n\n\tdma_dst = dma_map_single(ce->dev, d, todo, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(ce->dev, dma_dst)) {\n\t\tdev_err(ce->dev, \"Cannot DMA MAP DST\\n\");\n\t\terr = -EFAULT;\n\t\tgoto err_dst;\n\t}\n\n\terr = pm_runtime_resume_and_get(ce->dev);\n\tif (err < 0)\n\t\tgoto err_pm;\n\n\tmutex_lock(&ce->rnglock);\n\tchan = &ce->chanlist[flow];\n\n\tcet = &chan->tl[0];\n\tmemset(cet, 0, sizeof(struct ce_task));\n\n\tcet->t_id = cpu_to_le32(flow);\n\tcommon = ce->variant->trng | CE_COMM_INT;\n\tcet->t_common_ctl = cpu_to_le32(common);\n\n\t \n\tif (ce->variant->trng_t_dlen_in_bytes)\n\t\tcet->t_dlen = cpu_to_le32(todo);\n\telse\n\t\tcet->t_dlen = cpu_to_le32(todo / 4);\n\n\tcet->t_sym_ctl = 0;\n\tcet->t_asym_ctl = 0;\n\n\tcet->t_dst[0].addr = cpu_to_le32(dma_dst);\n\tcet->t_dst[0].len = cpu_to_le32(todo / 4);\n\tce->chanlist[flow].timeout = todo;\n\n\terr = sun8i_ce_run_task(ce, 3, \"TRNG\");\n\tmutex_unlock(&ce->rnglock);\n\n\tpm_runtime_put(ce->dev);\n\nerr_pm:\n\tdma_unmap_single(ce->dev, dma_dst, todo, DMA_FROM_DEVICE);\n\n\tif (!err) {\n\t\tmemcpy(data, d, max);\n\t\terr = max;\n\t}\nerr_dst:\n\tkfree_sensitive(d);\n\treturn err;\n}\n\nint sun8i_ce_hwrng_register(struct sun8i_ce_dev *ce)\n{\n\tint ret;\n\n\tif (ce->variant->trng == CE_ID_NOTSUPP) {\n\t\tdev_info(ce->dev, \"TRNG not supported\\n\");\n\t\treturn 0;\n\t}\n\tce->trng.name = \"sun8i Crypto Engine TRNG\";\n\tce->trng.read = sun8i_ce_trng_read;\n\n\tret = hwrng_register(&ce->trng);\n\tif (ret)\n\t\tdev_err(ce->dev, \"Fail to register the TRNG\\n\");\n\treturn ret;\n}\n\nvoid sun8i_ce_hwrng_unregister(struct sun8i_ce_dev *ce)\n{\n\tif (ce->variant->trng == CE_ID_NOTSUPP)\n\t\treturn;\n\thwrng_unregister(&ce->trng);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}