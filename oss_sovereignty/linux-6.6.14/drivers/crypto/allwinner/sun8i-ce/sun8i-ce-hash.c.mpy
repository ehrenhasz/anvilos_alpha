{
  "module_name": "sun8i-ce-hash.c",
  "hash_id": "01ffc303b1ffbeee288fead3e7c0cda040be9d42c9ae35923abff2e5c7337def",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/allwinner/sun8i-ce/sun8i-ce-hash.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/hash.h>\n#include <crypto/md5.h>\n#include <crypto/sha1.h>\n#include <crypto/sha2.h>\n#include <linux/bottom_half.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/pm_runtime.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include \"sun8i-ce.h\"\n\nint sun8i_ce_hash_init_tfm(struct crypto_ahash *tfm)\n{\n\tstruct sun8i_ce_hash_tfm_ctx *op = crypto_ahash_ctx(tfm);\n\tstruct ahash_alg *alg = crypto_ahash_alg(tfm);\n\tstruct sun8i_ce_alg_template *algt;\n\tint err;\n\n\talgt = container_of(alg, struct sun8i_ce_alg_template, alg.hash.base);\n\top->ce = algt->ce;\n\n\t \n\top->fallback_tfm = crypto_alloc_ahash(crypto_ahash_alg_name(tfm), 0,\n\t\t\t\t\t      CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(op->fallback_tfm)) {\n\t\tdev_err(algt->ce->dev, \"Fallback driver could no be loaded\\n\");\n\t\treturn PTR_ERR(op->fallback_tfm);\n\t}\n\n\tcrypto_ahash_set_statesize(tfm,\n\t\t\t\t   crypto_ahash_statesize(op->fallback_tfm));\n\n\tcrypto_ahash_set_reqsize(tfm,\n\t\t\t\t sizeof(struct sun8i_ce_hash_reqctx) +\n\t\t\t\t crypto_ahash_reqsize(op->fallback_tfm));\n\n\tmemcpy(algt->fbname, crypto_ahash_driver_name(op->fallback_tfm),\n\t       CRYPTO_MAX_ALG_NAME);\n\n\terr = pm_runtime_get_sync(op->ce->dev);\n\tif (err < 0)\n\t\tgoto error_pm;\n\treturn 0;\nerror_pm:\n\tpm_runtime_put_noidle(op->ce->dev);\n\tcrypto_free_ahash(op->fallback_tfm);\n\treturn err;\n}\n\nvoid sun8i_ce_hash_exit_tfm(struct crypto_ahash *tfm)\n{\n\tstruct sun8i_ce_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tcrypto_free_ahash(tfmctx->fallback_tfm);\n\tpm_runtime_put_sync_suspend(tfmctx->ce->dev);\n}\n\nint sun8i_ce_hash_init(struct ahash_request *areq)\n{\n\tstruct sun8i_ce_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ce_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tmemset(rctx, 0, sizeof(struct sun8i_ce_hash_reqctx));\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\treturn crypto_ahash_init(&rctx->fallback_req);\n}\n\nint sun8i_ce_hash_export(struct ahash_request *areq, void *out)\n{\n\tstruct sun8i_ce_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ce_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\treturn crypto_ahash_export(&rctx->fallback_req, out);\n}\n\nint sun8i_ce_hash_import(struct ahash_request *areq, const void *in)\n{\n\tstruct sun8i_ce_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ce_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\treturn crypto_ahash_import(&rctx->fallback_req, in);\n}\n\nint sun8i_ce_hash_final(struct ahash_request *areq)\n{\n\tstruct sun8i_ce_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ce_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags &\n\t\t\t\t\tCRYPTO_TFM_REQ_MAY_SLEEP;\n\trctx->fallback_req.result = areq->result;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG)) {\n\t\tstruct sun8i_ce_alg_template *algt __maybe_unused;\n\t\tstruct ahash_alg *alg = crypto_ahash_alg(tfm);\n\n\t\talgt = container_of(alg, struct sun8i_ce_alg_template,\n\t\t\t\t    alg.hash.base);\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG\n\t\talgt->stat_fb++;\n#endif\n\t}\n\n\treturn crypto_ahash_final(&rctx->fallback_req);\n}\n\nint sun8i_ce_hash_update(struct ahash_request *areq)\n{\n\tstruct sun8i_ce_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ce_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags &\n\t\t\t\t\tCRYPTO_TFM_REQ_MAY_SLEEP;\n\trctx->fallback_req.nbytes = areq->nbytes;\n\trctx->fallback_req.src = areq->src;\n\n\treturn crypto_ahash_update(&rctx->fallback_req);\n}\n\nint sun8i_ce_hash_finup(struct ahash_request *areq)\n{\n\tstruct sun8i_ce_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ce_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags &\n\t\t\t\t\tCRYPTO_TFM_REQ_MAY_SLEEP;\n\n\trctx->fallback_req.nbytes = areq->nbytes;\n\trctx->fallback_req.src = areq->src;\n\trctx->fallback_req.result = areq->result;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG)) {\n\t\tstruct sun8i_ce_alg_template *algt __maybe_unused;\n\t\tstruct ahash_alg *alg = crypto_ahash_alg(tfm);\n\n\t\talgt = container_of(alg, struct sun8i_ce_alg_template,\n\t\t\t\t    alg.hash.base);\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG\n\t\talgt->stat_fb++;\n#endif\n\t}\n\n\treturn crypto_ahash_finup(&rctx->fallback_req);\n}\n\nstatic int sun8i_ce_hash_digest_fb(struct ahash_request *areq)\n{\n\tstruct sun8i_ce_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ce_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags &\n\t\t\t\t\tCRYPTO_TFM_REQ_MAY_SLEEP;\n\n\trctx->fallback_req.nbytes = areq->nbytes;\n\trctx->fallback_req.src = areq->src;\n\trctx->fallback_req.result = areq->result;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG)) {\n\t\tstruct sun8i_ce_alg_template *algt __maybe_unused;\n\t\tstruct ahash_alg *alg = crypto_ahash_alg(tfm);\n\n\t\talgt = container_of(alg, struct sun8i_ce_alg_template,\n\t\t\t\t    alg.hash.base);\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG\n\t\talgt->stat_fb++;\n#endif\n\t}\n\n\treturn crypto_ahash_digest(&rctx->fallback_req);\n}\n\nstatic bool sun8i_ce_hash_need_fallback(struct ahash_request *areq)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct ahash_alg *alg = __crypto_ahash_alg(tfm->base.__crt_alg);\n\tstruct sun8i_ce_alg_template *algt;\n\tstruct scatterlist *sg;\n\n\talgt = container_of(alg, struct sun8i_ce_alg_template, alg.hash.base);\n\n\tif (areq->nbytes == 0) {\n\t\talgt->stat_fb_len0++;\n\t\treturn true;\n\t}\n\t \n\tif (sg_nents_for_len(areq->src, areq->nbytes) > MAX_SG - 1) {\n\t\talgt->stat_fb_maxsg++;\n\t\treturn true;\n\t}\n\tsg = areq->src;\n\twhile (sg) {\n\t\tif (sg->length % 4) {\n\t\t\talgt->stat_fb_srclen++;\n\t\t\treturn true;\n\t\t}\n\t\tif (!IS_ALIGNED(sg->offset, sizeof(u32))) {\n\t\t\talgt->stat_fb_srcali++;\n\t\t\treturn true;\n\t\t}\n\t\tsg = sg_next(sg);\n\t}\n\treturn false;\n}\n\nint sun8i_ce_hash_digest(struct ahash_request *areq)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct ahash_alg *alg = __crypto_ahash_alg(tfm->base.__crt_alg);\n\tstruct sun8i_ce_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct sun8i_ce_alg_template *algt;\n\tstruct sun8i_ce_dev *ce;\n\tstruct crypto_engine *engine;\n\tstruct scatterlist *sg;\n\tint nr_sgs, e, i;\n\n\tif (sun8i_ce_hash_need_fallback(areq))\n\t\treturn sun8i_ce_hash_digest_fb(areq);\n\n\tnr_sgs = sg_nents_for_len(areq->src, areq->nbytes);\n\tif (nr_sgs > MAX_SG - 1)\n\t\treturn sun8i_ce_hash_digest_fb(areq);\n\n\tfor_each_sg(areq->src, sg, nr_sgs, i) {\n\t\tif (sg->length % 4 || !IS_ALIGNED(sg->offset, sizeof(u32)))\n\t\t\treturn sun8i_ce_hash_digest_fb(areq);\n\t}\n\n\talgt = container_of(alg, struct sun8i_ce_alg_template, alg.hash.base);\n\tce = algt->ce;\n\n\te = sun8i_ce_get_engine_number(ce);\n\trctx->flow = e;\n\tengine = ce->chanlist[e].engine;\n\n\treturn crypto_transfer_hash_request_to_engine(engine, areq);\n}\n\nstatic u64 hash_pad(__le32 *buf, unsigned int bufsize, u64 padi, u64 byte_count, bool le, int bs)\n{\n\tu64 fill, min_fill, j, k;\n\t__be64 *bebits;\n\t__le64 *lebits;\n\n\tj = padi;\n\tbuf[j++] = cpu_to_le32(0x80);\n\n\tif (bs == 64) {\n\t\tfill = 64 - (byte_count % 64);\n\t\tmin_fill = 2 * sizeof(u32) + sizeof(u32);\n\t} else {\n\t\tfill = 128 - (byte_count % 128);\n\t\tmin_fill = 4 * sizeof(u32) + sizeof(u32);\n\t}\n\n\tif (fill < min_fill)\n\t\tfill += bs;\n\n\tk = j;\n\tj += (fill - min_fill) / sizeof(u32);\n\tif (j * 4 > bufsize) {\n\t\tpr_err(\"%s OVERFLOW %llu\\n\", __func__, j);\n\t\treturn 0;\n\t}\n\tfor (; k < j; k++)\n\t\tbuf[k] = 0;\n\n\tif (le) {\n\t\t \n\t\tlebits = (__le64 *)&buf[j];\n\t\t*lebits = cpu_to_le64(byte_count << 3);\n\t\tj += 2;\n\t} else {\n\t\tif (bs == 64) {\n\t\t\t \n\t\t\tbebits = (__be64 *)&buf[j];\n\t\t\t*bebits = cpu_to_be64(byte_count << 3);\n\t\t\tj += 2;\n\t\t} else {\n\t\t\t \n\t\t\tbebits = (__be64 *)&buf[j];\n\t\t\t*bebits = cpu_to_be64(byte_count >> 61);\n\t\t\tj += 2;\n\t\t\tbebits = (__be64 *)&buf[j];\n\t\t\t*bebits = cpu_to_be64(byte_count << 3);\n\t\t\tj += 2;\n\t\t}\n\t}\n\tif (j * 4 > bufsize) {\n\t\tpr_err(\"%s OVERFLOW %llu\\n\", __func__, j);\n\t\treturn 0;\n\t}\n\n\treturn j;\n}\n\nint sun8i_ce_hash_run(struct crypto_engine *engine, void *breq)\n{\n\tstruct ahash_request *areq = container_of(breq, struct ahash_request, base);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct ahash_alg *alg = __crypto_ahash_alg(tfm->base.__crt_alg);\n\tstruct sun8i_ce_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct sun8i_ce_alg_template *algt;\n\tstruct sun8i_ce_dev *ce;\n\tstruct sun8i_ce_flow *chan;\n\tstruct ce_task *cet;\n\tstruct scatterlist *sg;\n\tint nr_sgs, flow, err;\n\tunsigned int len;\n\tu32 common;\n\tu64 byte_count;\n\t__le32 *bf;\n\tvoid *buf = NULL;\n\tint j, i, todo;\n\tvoid *result = NULL;\n\tu64 bs;\n\tint digestsize;\n\tdma_addr_t addr_res, addr_pad;\n\tint ns = sg_nents_for_len(areq->src, areq->nbytes);\n\n\talgt = container_of(alg, struct sun8i_ce_alg_template, alg.hash.base);\n\tce = algt->ce;\n\n\tbs = algt->alg.hash.base.halg.base.cra_blocksize;\n\tdigestsize = algt->alg.hash.base.halg.digestsize;\n\tif (digestsize == SHA224_DIGEST_SIZE)\n\t\tdigestsize = SHA256_DIGEST_SIZE;\n\tif (digestsize == SHA384_DIGEST_SIZE)\n\t\tdigestsize = SHA512_DIGEST_SIZE;\n\n\t \n\tbuf = kzalloc(bs * 2, GFP_KERNEL | GFP_DMA);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto theend;\n\t}\n\tbf = (__le32 *)buf;\n\n\tresult = kzalloc(digestsize, GFP_KERNEL | GFP_DMA);\n\tif (!result) {\n\t\terr = -ENOMEM;\n\t\tgoto theend;\n\t}\n\n\tflow = rctx->flow;\n\tchan = &ce->chanlist[flow];\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG\n\talgt->stat_req++;\n#endif\n\tdev_dbg(ce->dev, \"%s %s len=%d\\n\", __func__, crypto_tfm_alg_name(areq->base.tfm), areq->nbytes);\n\n\tcet = chan->tl;\n\tmemset(cet, 0, sizeof(struct ce_task));\n\n\tcet->t_id = cpu_to_le32(flow);\n\tcommon = ce->variant->alg_hash[algt->ce_algo_id];\n\tcommon |= CE_COMM_INT;\n\tcet->t_common_ctl = cpu_to_le32(common);\n\n\tcet->t_sym_ctl = 0;\n\tcet->t_asym_ctl = 0;\n\n\tnr_sgs = dma_map_sg(ce->dev, areq->src, ns, DMA_TO_DEVICE);\n\tif (nr_sgs <= 0 || nr_sgs > MAX_SG) {\n\t\tdev_err(ce->dev, \"Invalid sg number %d\\n\", nr_sgs);\n\t\terr = -EINVAL;\n\t\tgoto theend;\n\t}\n\n\tlen = areq->nbytes;\n\tfor_each_sg(areq->src, sg, nr_sgs, i) {\n\t\tcet->t_src[i].addr = cpu_to_le32(sg_dma_address(sg));\n\t\ttodo = min(len, sg_dma_len(sg));\n\t\tcet->t_src[i].len = cpu_to_le32(todo / 4);\n\t\tlen -= todo;\n\t}\n\tif (len > 0) {\n\t\tdev_err(ce->dev, \"remaining len %d\\n\", len);\n\t\terr = -EINVAL;\n\t\tgoto theend;\n\t}\n\taddr_res = dma_map_single(ce->dev, result, digestsize, DMA_FROM_DEVICE);\n\tcet->t_dst[0].addr = cpu_to_le32(addr_res);\n\tcet->t_dst[0].len = cpu_to_le32(digestsize / 4);\n\tif (dma_mapping_error(ce->dev, addr_res)) {\n\t\tdev_err(ce->dev, \"DMA map dest\\n\");\n\t\terr = -EINVAL;\n\t\tgoto theend;\n\t}\n\n\tbyte_count = areq->nbytes;\n\tj = 0;\n\n\tswitch (algt->ce_algo_id) {\n\tcase CE_ID_HASH_MD5:\n\t\tj = hash_pad(bf, 2 * bs, j, byte_count, true, bs);\n\t\tbreak;\n\tcase CE_ID_HASH_SHA1:\n\tcase CE_ID_HASH_SHA224:\n\tcase CE_ID_HASH_SHA256:\n\t\tj = hash_pad(bf, 2 * bs, j, byte_count, false, bs);\n\t\tbreak;\n\tcase CE_ID_HASH_SHA384:\n\tcase CE_ID_HASH_SHA512:\n\t\tj = hash_pad(bf, 2 * bs, j, byte_count, false, bs);\n\t\tbreak;\n\t}\n\tif (!j) {\n\t\terr = -EINVAL;\n\t\tgoto theend;\n\t}\n\n\taddr_pad = dma_map_single(ce->dev, buf, j * 4, DMA_TO_DEVICE);\n\tcet->t_src[i].addr = cpu_to_le32(addr_pad);\n\tcet->t_src[i].len = cpu_to_le32(j);\n\tif (dma_mapping_error(ce->dev, addr_pad)) {\n\t\tdev_err(ce->dev, \"DMA error on padding SG\\n\");\n\t\terr = -EINVAL;\n\t\tgoto theend;\n\t}\n\n\tif (ce->variant->hash_t_dlen_in_bits)\n\t\tcet->t_dlen = cpu_to_le32((areq->nbytes + j * 4) * 8);\n\telse\n\t\tcet->t_dlen = cpu_to_le32(areq->nbytes / 4 + j);\n\n\tchan->timeout = areq->nbytes;\n\n\terr = sun8i_ce_run_task(ce, flow, crypto_ahash_alg_name(tfm));\n\n\tdma_unmap_single(ce->dev, addr_pad, j * 4, DMA_TO_DEVICE);\n\tdma_unmap_sg(ce->dev, areq->src, ns, DMA_TO_DEVICE);\n\tdma_unmap_single(ce->dev, addr_res, digestsize, DMA_FROM_DEVICE);\n\n\n\tmemcpy(areq->result, result, algt->alg.hash.base.halg.digestsize);\ntheend:\n\tkfree(buf);\n\tkfree(result);\n\tlocal_bh_disable();\n\tcrypto_finalize_hash_request(engine, breq, err);\n\tlocal_bh_enable();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}