{
  "module_name": "sun8i-ce-prng.c",
  "hash_id": "4393a1416dee0af014683039b6ef89ed0e92288eb0143c1faa8cfc70f0626805",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/allwinner/sun8i-ce/sun8i-ce-prng.c",
  "human_readable_source": "\n \n#include \"sun8i-ce.h\"\n#include <linux/dma-mapping.h>\n#include <linux/pm_runtime.h>\n#include <crypto/internal/rng.h>\n\nint sun8i_ce_prng_init(struct crypto_tfm *tfm)\n{\n\tstruct sun8i_ce_rng_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tmemset(ctx, 0, sizeof(struct sun8i_ce_rng_tfm_ctx));\n\treturn 0;\n}\n\nvoid sun8i_ce_prng_exit(struct crypto_tfm *tfm)\n{\n\tstruct sun8i_ce_rng_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tkfree_sensitive(ctx->seed);\n\tctx->seed = NULL;\n\tctx->slen = 0;\n}\n\nint sun8i_ce_prng_seed(struct crypto_rng *tfm, const u8 *seed,\n\t\t       unsigned int slen)\n{\n\tstruct sun8i_ce_rng_tfm_ctx *ctx = crypto_rng_ctx(tfm);\n\n\tif (ctx->seed && ctx->slen != slen) {\n\t\tkfree_sensitive(ctx->seed);\n\t\tctx->slen = 0;\n\t\tctx->seed = NULL;\n\t}\n\tif (!ctx->seed)\n\t\tctx->seed = kmalloc(slen, GFP_KERNEL | GFP_DMA);\n\tif (!ctx->seed)\n\t\treturn -ENOMEM;\n\n\tmemcpy(ctx->seed, seed, slen);\n\tctx->slen = slen;\n\n\treturn 0;\n}\n\nint sun8i_ce_prng_generate(struct crypto_rng *tfm, const u8 *src,\n\t\t\t   unsigned int slen, u8 *dst, unsigned int dlen)\n{\n\tstruct sun8i_ce_rng_tfm_ctx *ctx = crypto_rng_ctx(tfm);\n\tstruct rng_alg *alg = crypto_rng_alg(tfm);\n\tstruct sun8i_ce_alg_template *algt;\n\tstruct sun8i_ce_dev *ce;\n\tdma_addr_t dma_iv, dma_dst;\n\tint err = 0;\n\tint flow = 3;\n\tunsigned int todo;\n\tstruct sun8i_ce_flow *chan;\n\tstruct ce_task *cet;\n\tu32 common, sym;\n\tvoid *d;\n\n\talgt = container_of(alg, struct sun8i_ce_alg_template, alg.rng);\n\tce = algt->ce;\n\n\tif (ctx->slen == 0) {\n\t\tdev_err(ce->dev, \"not seeded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttodo = dlen + ctx->slen + PRNG_DATA_SIZE * 2;\n\ttodo -= todo % PRNG_DATA_SIZE;\n\n\td = kzalloc(todo, GFP_KERNEL | GFP_DMA);\n\tif (!d) {\n\t\terr = -ENOMEM;\n\t\tgoto err_mem;\n\t}\n\n\tdev_dbg(ce->dev, \"%s PRNG slen=%u dlen=%u todo=%u multi=%u\\n\", __func__,\n\t\tslen, dlen, todo, todo / PRNG_DATA_SIZE);\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_CE_DEBUG\n\talgt->stat_req++;\n\talgt->stat_bytes += todo;\n#endif\n\n\tdma_iv = dma_map_single(ce->dev, ctx->seed, ctx->slen, DMA_TO_DEVICE);\n\tif (dma_mapping_error(ce->dev, dma_iv)) {\n\t\tdev_err(ce->dev, \"Cannot DMA MAP IV\\n\");\n\t\terr = -EFAULT;\n\t\tgoto err_iv;\n\t}\n\n\tdma_dst = dma_map_single(ce->dev, d, todo, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(ce->dev, dma_dst)) {\n\t\tdev_err(ce->dev, \"Cannot DMA MAP DST\\n\");\n\t\terr = -EFAULT;\n\t\tgoto err_dst;\n\t}\n\n\terr = pm_runtime_resume_and_get(ce->dev);\n\tif (err < 0)\n\t\tgoto err_pm;\n\n\tmutex_lock(&ce->rnglock);\n\tchan = &ce->chanlist[flow];\n\n\tcet = &chan->tl[0];\n\tmemset(cet, 0, sizeof(struct ce_task));\n\n\tcet->t_id = cpu_to_le32(flow);\n\tcommon = ce->variant->prng | CE_COMM_INT;\n\tcet->t_common_ctl = cpu_to_le32(common);\n\n\t \n\tif (ce->variant->prng_t_dlen_in_bytes)\n\t\tcet->t_dlen = cpu_to_le32(todo);\n\telse\n\t\tcet->t_dlen = cpu_to_le32(todo / 4);\n\n\tsym = PRNG_LD;\n\tcet->t_sym_ctl = cpu_to_le32(sym);\n\tcet->t_asym_ctl = 0;\n\n\tcet->t_key = cpu_to_le32(dma_iv);\n\tcet->t_iv = cpu_to_le32(dma_iv);\n\n\tcet->t_dst[0].addr = cpu_to_le32(dma_dst);\n\tcet->t_dst[0].len = cpu_to_le32(todo / 4);\n\tce->chanlist[flow].timeout = 2000;\n\n\terr = sun8i_ce_run_task(ce, 3, \"PRNG\");\n\tmutex_unlock(&ce->rnglock);\n\n\tpm_runtime_put(ce->dev);\n\nerr_pm:\n\tdma_unmap_single(ce->dev, dma_dst, todo, DMA_FROM_DEVICE);\nerr_dst:\n\tdma_unmap_single(ce->dev, dma_iv, ctx->slen, DMA_TO_DEVICE);\n\n\tif (!err) {\n\t\tmemcpy(dst, d, dlen);\n\t\tmemcpy(ctx->seed, d + dlen, ctx->slen);\n\t}\nerr_iv:\n\tkfree_sensitive(d);\nerr_mem:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}