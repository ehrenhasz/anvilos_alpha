{
  "module_name": "sun8i-ss-prng.c",
  "hash_id": "99ce68d7779996505941043918ab211526a06bdc8302ad338ffd178853fda555",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/allwinner/sun8i-ss/sun8i-ss-prng.c",
  "human_readable_source": "\n \n#include \"sun8i-ss.h\"\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/pm_runtime.h>\n#include <crypto/internal/rng.h>\n\nint sun8i_ss_prng_seed(struct crypto_rng *tfm, const u8 *seed,\n\t\t       unsigned int slen)\n{\n\tstruct sun8i_ss_rng_tfm_ctx *ctx = crypto_rng_ctx(tfm);\n\n\tif (ctx->seed && ctx->slen != slen) {\n\t\tkfree_sensitive(ctx->seed);\n\t\tctx->slen = 0;\n\t\tctx->seed = NULL;\n\t}\n\tif (!ctx->seed)\n\t\tctx->seed = kmalloc(slen, GFP_KERNEL);\n\tif (!ctx->seed)\n\t\treturn -ENOMEM;\n\n\tmemcpy(ctx->seed, seed, slen);\n\tctx->slen = slen;\n\n\treturn 0;\n}\n\nint sun8i_ss_prng_init(struct crypto_tfm *tfm)\n{\n\tstruct sun8i_ss_rng_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tmemset(ctx, 0, sizeof(struct sun8i_ss_rng_tfm_ctx));\n\treturn 0;\n}\n\nvoid sun8i_ss_prng_exit(struct crypto_tfm *tfm)\n{\n\tstruct sun8i_ss_rng_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tkfree_sensitive(ctx->seed);\n\tctx->seed = NULL;\n\tctx->slen = 0;\n}\n\nint sun8i_ss_prng_generate(struct crypto_rng *tfm, const u8 *src,\n\t\t\t   unsigned int slen, u8 *dst, unsigned int dlen)\n{\n\tstruct sun8i_ss_rng_tfm_ctx *ctx = crypto_rng_ctx(tfm);\n\tstruct rng_alg *alg = crypto_rng_alg(tfm);\n\tstruct sun8i_ss_alg_template *algt;\n\tunsigned int todo_with_padding;\n\tstruct sun8i_ss_dev *ss;\n\tdma_addr_t dma_iv, dma_dst;\n\tunsigned int todo;\n\tint err = 0;\n\tint flow;\n\tvoid *d;\n\tu32 v;\n\n\talgt = container_of(alg, struct sun8i_ss_alg_template, alg.rng);\n\tss = algt->ss;\n\n\tif (ctx->slen == 0) {\n\t\tdev_err(ss->dev, \"The PRNG is not seeded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttodo = dlen + PRNG_SEED_SIZE + PRNG_DATA_SIZE;\n\ttodo -= todo % PRNG_DATA_SIZE;\n\n\ttodo_with_padding = ALIGN(todo, dma_get_cache_alignment());\n\tif (todo_with_padding < todo || todo < dlen)\n\t\treturn -EOVERFLOW;\n\n\td = kzalloc(todo_with_padding, GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\tflow = sun8i_ss_get_engine_number(ss);\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG\n\talgt->stat_req++;\n\talgt->stat_bytes += todo;\n#endif\n\n\tv = SS_ALG_PRNG | SS_PRNG_CONTINUE | SS_START;\n\tif (flow)\n\t\tv |= SS_FLOW1;\n\telse\n\t\tv |= SS_FLOW0;\n\n\tdma_iv = dma_map_single(ss->dev, ctx->seed, ctx->slen, DMA_TO_DEVICE);\n\tif (dma_mapping_error(ss->dev, dma_iv)) {\n\t\tdev_err(ss->dev, \"Cannot DMA MAP IV\\n\");\n\t\terr = -EFAULT;\n\t\tgoto err_free;\n\t}\n\n\tdma_dst = dma_map_single(ss->dev, d, todo, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(ss->dev, dma_dst)) {\n\t\tdev_err(ss->dev, \"Cannot DMA MAP DST\\n\");\n\t\terr = -EFAULT;\n\t\tgoto err_iv;\n\t}\n\n\terr = pm_runtime_resume_and_get(ss->dev);\n\tif (err < 0)\n\t\tgoto err_pm;\n\terr = 0;\n\n\tmutex_lock(&ss->mlock);\n\twritel(dma_iv, ss->base + SS_IV_ADR_REG);\n\t \n\twritel(dma_iv, ss->base + SS_KEY_ADR_REG);\n\twritel(dma_dst, ss->base + SS_DST_ADR_REG);\n\twritel(todo / 4, ss->base + SS_LEN_ADR_REG);\n\n\treinit_completion(&ss->flows[flow].complete);\n\tss->flows[flow].status = 0;\n\t \n\twmb();\n\n\twritel(v, ss->base + SS_CTL_REG);\n\n\twait_for_completion_interruptible_timeout(&ss->flows[flow].complete,\n\t\t\t\t\t\t  msecs_to_jiffies(todo));\n\tif (ss->flows[flow].status == 0) {\n\t\tdev_err(ss->dev, \"DMA timeout for PRNG (size=%u)\\n\", todo);\n\t\terr = -EFAULT;\n\t}\n\t \n\tmutex_unlock(&ss->mlock);\n\n\tpm_runtime_put(ss->dev);\n\nerr_pm:\n\tdma_unmap_single(ss->dev, dma_dst, todo, DMA_FROM_DEVICE);\nerr_iv:\n\tdma_unmap_single(ss->dev, dma_iv, ctx->slen, DMA_TO_DEVICE);\n\n\tif (!err) {\n\t\tmemcpy(dst, d, dlen);\n\t\t \n\t\tmemcpy(ctx->seed, d + dlen, ctx->slen);\n\t}\nerr_free:\n\tkfree_sensitive(d);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}