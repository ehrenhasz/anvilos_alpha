{
  "module_name": "sun8i-ss-hash.c",
  "hash_id": "06c2a240d5d372bbbbaccf779261786d59a6de3a3ea785e6b051512e76540366",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/allwinner/sun8i-ss/sun8i-ss-hash.c",
  "human_readable_source": "\n \n\n#include <crypto/hmac.h>\n#include <crypto/internal/hash.h>\n#include <crypto/md5.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/sha1.h>\n#include <crypto/sha2.h>\n#include <linux/bottom_half.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/pm_runtime.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include \"sun8i-ss.h\"\n\nstatic int sun8i_ss_hashkey(struct sun8i_ss_hash_tfm_ctx *tfmctx, const u8 *key,\n\t\t\t    unsigned int keylen)\n{\n\tstruct crypto_shash *xtfm;\n\tstruct shash_desc *sdesc;\n\tsize_t len;\n\tint ret = 0;\n\n\txtfm = crypto_alloc_shash(\"sha1\", 0, CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(xtfm))\n\t\treturn PTR_ERR(xtfm);\n\n\tlen = sizeof(*sdesc) + crypto_shash_descsize(xtfm);\n\tsdesc = kmalloc(len, GFP_KERNEL);\n\tif (!sdesc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_hashkey_sdesc;\n\t}\n\tsdesc->tfm = xtfm;\n\n\tret = crypto_shash_init(sdesc);\n\tif (ret) {\n\t\tdev_err(tfmctx->ss->dev, \"shash init error ret=%d\\n\", ret);\n\t\tgoto err_hashkey;\n\t}\n\tret = crypto_shash_finup(sdesc, key, keylen, tfmctx->key);\n\tif (ret)\n\t\tdev_err(tfmctx->ss->dev, \"shash finup error\\n\");\nerr_hashkey:\n\tkfree(sdesc);\nerr_hashkey_sdesc:\n\tcrypto_free_shash(xtfm);\n\treturn ret;\n}\n\nint sun8i_ss_hmac_setkey(struct crypto_ahash *ahash, const u8 *key,\n\t\t\t unsigned int keylen)\n{\n\tstruct sun8i_ss_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(ahash);\n\tint digestsize, i;\n\tint bs = crypto_ahash_blocksize(ahash);\n\tint ret;\n\n\tdigestsize = crypto_ahash_digestsize(ahash);\n\n\tif (keylen > bs) {\n\t\tret = sun8i_ss_hashkey(tfmctx, key, keylen);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttfmctx->keylen = digestsize;\n\t} else {\n\t\ttfmctx->keylen = keylen;\n\t\tmemcpy(tfmctx->key, key, keylen);\n\t}\n\n\ttfmctx->ipad = kzalloc(bs, GFP_KERNEL);\n\tif (!tfmctx->ipad)\n\t\treturn -ENOMEM;\n\ttfmctx->opad = kzalloc(bs, GFP_KERNEL);\n\tif (!tfmctx->opad) {\n\t\tret = -ENOMEM;\n\t\tgoto err_opad;\n\t}\n\n\tmemset(tfmctx->key + tfmctx->keylen, 0, bs - tfmctx->keylen);\n\tmemcpy(tfmctx->ipad, tfmctx->key, tfmctx->keylen);\n\tmemcpy(tfmctx->opad, tfmctx->key, tfmctx->keylen);\n\tfor (i = 0; i < bs; i++) {\n\t\ttfmctx->ipad[i] ^= HMAC_IPAD_VALUE;\n\t\ttfmctx->opad[i] ^= HMAC_OPAD_VALUE;\n\t}\n\n\tret = crypto_ahash_setkey(tfmctx->fallback_tfm, key, keylen);\n\tif (!ret)\n\t\treturn 0;\n\n\tmemzero_explicit(tfmctx->key, keylen);\n\tkfree_sensitive(tfmctx->opad);\nerr_opad:\n\tkfree_sensitive(tfmctx->ipad);\n\treturn ret;\n}\n\nint sun8i_ss_hash_init_tfm(struct crypto_ahash *tfm)\n{\n\tstruct sun8i_ss_hash_tfm_ctx *op = crypto_ahash_ctx(tfm);\n\tstruct ahash_alg *alg = crypto_ahash_alg(tfm);\n\tstruct sun8i_ss_alg_template *algt;\n\tint err;\n\n\talgt = container_of(alg, struct sun8i_ss_alg_template, alg.hash.base);\n\top->ss = algt->ss;\n\n\t \n\top->fallback_tfm = crypto_alloc_ahash(crypto_ahash_alg_name(tfm), 0,\n\t\t\t\t\t      CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(op->fallback_tfm)) {\n\t\tdev_err(algt->ss->dev, \"Fallback driver could no be loaded\\n\");\n\t\treturn PTR_ERR(op->fallback_tfm);\n\t}\n\n\tcrypto_ahash_set_statesize(tfm,\n\t\t\t\t   crypto_ahash_statesize(op->fallback_tfm));\n\n\tcrypto_ahash_set_reqsize(tfm,\n\t\t\t\t sizeof(struct sun8i_ss_hash_reqctx) +\n\t\t\t\t crypto_ahash_reqsize(op->fallback_tfm));\n\n\tmemcpy(algt->fbname, crypto_ahash_driver_name(op->fallback_tfm),\n\t       CRYPTO_MAX_ALG_NAME);\n\n\terr = pm_runtime_get_sync(op->ss->dev);\n\tif (err < 0)\n\t\tgoto error_pm;\n\treturn 0;\nerror_pm:\n\tpm_runtime_put_noidle(op->ss->dev);\n\tcrypto_free_ahash(op->fallback_tfm);\n\treturn err;\n}\n\nvoid sun8i_ss_hash_exit_tfm(struct crypto_ahash *tfm)\n{\n\tstruct sun8i_ss_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tkfree_sensitive(tfmctx->ipad);\n\tkfree_sensitive(tfmctx->opad);\n\n\tcrypto_free_ahash(tfmctx->fallback_tfm);\n\tpm_runtime_put_sync_suspend(tfmctx->ss->dev);\n}\n\nint sun8i_ss_hash_init(struct ahash_request *areq)\n{\n\tstruct sun8i_ss_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ss_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tmemset(rctx, 0, sizeof(struct sun8i_ss_hash_reqctx));\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\treturn crypto_ahash_init(&rctx->fallback_req);\n}\n\nint sun8i_ss_hash_export(struct ahash_request *areq, void *out)\n{\n\tstruct sun8i_ss_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ss_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\treturn crypto_ahash_export(&rctx->fallback_req, out);\n}\n\nint sun8i_ss_hash_import(struct ahash_request *areq, const void *in)\n{\n\tstruct sun8i_ss_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ss_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\treturn crypto_ahash_import(&rctx->fallback_req, in);\n}\n\nint sun8i_ss_hash_final(struct ahash_request *areq)\n{\n\tstruct sun8i_ss_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ss_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags &\n\t\t\t\t\tCRYPTO_TFM_REQ_MAY_SLEEP;\n\trctx->fallback_req.result = areq->result;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG)) {\n\t\tstruct ahash_alg *alg = crypto_ahash_alg(tfm);\n\t\tstruct sun8i_ss_alg_template *algt __maybe_unused;\n\n\t\talgt = container_of(alg, struct sun8i_ss_alg_template,\n\t\t\t\t    alg.hash.base);\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG\n\t\talgt->stat_fb++;\n#endif\n\t}\n\n\treturn crypto_ahash_final(&rctx->fallback_req);\n}\n\nint sun8i_ss_hash_update(struct ahash_request *areq)\n{\n\tstruct sun8i_ss_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ss_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags &\n\t\t\t\t\tCRYPTO_TFM_REQ_MAY_SLEEP;\n\trctx->fallback_req.nbytes = areq->nbytes;\n\trctx->fallback_req.src = areq->src;\n\n\treturn crypto_ahash_update(&rctx->fallback_req);\n}\n\nint sun8i_ss_hash_finup(struct ahash_request *areq)\n{\n\tstruct sun8i_ss_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ss_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags &\n\t\t\t\t\tCRYPTO_TFM_REQ_MAY_SLEEP;\n\n\trctx->fallback_req.nbytes = areq->nbytes;\n\trctx->fallback_req.src = areq->src;\n\trctx->fallback_req.result = areq->result;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG)) {\n\t\tstruct ahash_alg *alg = crypto_ahash_alg(tfm);\n\t\tstruct sun8i_ss_alg_template *algt __maybe_unused;\n\n\t\talgt = container_of(alg, struct sun8i_ss_alg_template,\n\t\t\t\t    alg.hash.base);\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG\n\t\talgt->stat_fb++;\n#endif\n\t}\n\n\treturn crypto_ahash_finup(&rctx->fallback_req);\n}\n\nstatic int sun8i_ss_hash_digest_fb(struct ahash_request *areq)\n{\n\tstruct sun8i_ss_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ss_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, tfmctx->fallback_tfm);\n\trctx->fallback_req.base.flags = areq->base.flags &\n\t\t\t\t\tCRYPTO_TFM_REQ_MAY_SLEEP;\n\n\trctx->fallback_req.nbytes = areq->nbytes;\n\trctx->fallback_req.src = areq->src;\n\trctx->fallback_req.result = areq->result;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG)) {\n\t\tstruct ahash_alg *alg = crypto_ahash_alg(tfm);\n\t\tstruct sun8i_ss_alg_template *algt __maybe_unused;\n\n\t\talgt = container_of(alg, struct sun8i_ss_alg_template,\n\t\t\t\t    alg.hash.base);\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG\n\t\talgt->stat_fb++;\n#endif\n\t}\n\n\treturn crypto_ahash_digest(&rctx->fallback_req);\n}\n\nstatic int sun8i_ss_run_hash_task(struct sun8i_ss_dev *ss,\n\t\t\t\t  struct sun8i_ss_hash_reqctx *rctx,\n\t\t\t\t  const char *name)\n{\n\tint flow = rctx->flow;\n\tu32 v = SS_START;\n\tint i;\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG\n\tss->flows[flow].stat_req++;\n#endif\n\n\t \n\tif (flow)\n\t\tv |= SS_FLOW1;\n\telse\n\t\tv |= SS_FLOW0;\n\n\tv |= rctx->method;\n\n\tfor (i = 0; i < MAX_SG; i++) {\n\t\tif (!rctx->t_dst[i].addr)\n\t\t\tbreak;\n\n\t\tmutex_lock(&ss->mlock);\n\t\tif (i > 0) {\n\t\t\tv |= BIT(17);\n\t\t\twritel(rctx->t_dst[i - 1].addr, ss->base + SS_KEY_ADR_REG);\n\t\t\twritel(rctx->t_dst[i - 1].addr, ss->base + SS_IV_ADR_REG);\n\t\t}\n\n\t\tdev_dbg(ss->dev,\n\t\t\t\"Processing SG %d on flow %d %s ctl=%x %d to %d method=%x src=%x dst=%x\\n\",\n\t\t\ti, flow, name, v,\n\t\t\trctx->t_src[i].len, rctx->t_dst[i].len,\n\t\t\trctx->method, rctx->t_src[i].addr, rctx->t_dst[i].addr);\n\n\t\twritel(rctx->t_src[i].addr, ss->base + SS_SRC_ADR_REG);\n\t\twritel(rctx->t_dst[i].addr, ss->base + SS_DST_ADR_REG);\n\t\twritel(rctx->t_src[i].len, ss->base + SS_LEN_ADR_REG);\n\t\twritel(BIT(0) | BIT(1), ss->base + SS_INT_CTL_REG);\n\n\t\treinit_completion(&ss->flows[flow].complete);\n\t\tss->flows[flow].status = 0;\n\t\twmb();\n\n\t\twritel(v, ss->base + SS_CTL_REG);\n\t\tmutex_unlock(&ss->mlock);\n\t\twait_for_completion_interruptible_timeout(&ss->flows[flow].complete,\n\t\t\t\t\t\t\t  msecs_to_jiffies(2000));\n\t\tif (ss->flows[flow].status == 0) {\n\t\t\tdev_err(ss->dev, \"DMA timeout for %s\\n\", name);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool sun8i_ss_hash_need_fallback(struct ahash_request *areq)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct ahash_alg *alg = crypto_ahash_alg(tfm);\n\tstruct sun8i_ss_alg_template *algt;\n\tstruct scatterlist *sg;\n\n\talgt = container_of(alg, struct sun8i_ss_alg_template, alg.hash.base);\n\n\tif (areq->nbytes == 0) {\n\t\talgt->stat_fb_len++;\n\t\treturn true;\n\t}\n\n\tif (areq->nbytes >= MAX_PAD_SIZE - 64) {\n\t\talgt->stat_fb_len++;\n\t\treturn true;\n\t}\n\n\t \n\tif (sg_nents(areq->src) > MAX_SG - 1) {\n\t\talgt->stat_fb_sgnum++;\n\t\treturn true;\n\t}\n\n\tsg = areq->src;\n\twhile (sg) {\n\t\t \n\t\t \n\t\tif (sg->length % 64 && sg_next(sg)) {\n\t\t\talgt->stat_fb_sglen++;\n\t\t\treturn true;\n\t\t}\n\t\tif (!IS_ALIGNED(sg->offset, sizeof(u32))) {\n\t\t\talgt->stat_fb_align++;\n\t\t\treturn true;\n\t\t}\n\t\tif (sg->length % 4) {\n\t\t\talgt->stat_fb_sglen++;\n\t\t\treturn true;\n\t\t}\n\t\tsg = sg_next(sg);\n\t}\n\treturn false;\n}\n\nint sun8i_ss_hash_digest(struct ahash_request *areq)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ss_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct ahash_alg *alg = crypto_ahash_alg(tfm);\n\tstruct sun8i_ss_alg_template *algt;\n\tstruct sun8i_ss_dev *ss;\n\tstruct crypto_engine *engine;\n\tint e;\n\n\tif (sun8i_ss_hash_need_fallback(areq))\n\t\treturn sun8i_ss_hash_digest_fb(areq);\n\n\talgt = container_of(alg, struct sun8i_ss_alg_template, alg.hash.base);\n\tss = algt->ss;\n\n\te = sun8i_ss_get_engine_number(ss);\n\trctx->flow = e;\n\tengine = ss->flows[e].engine;\n\n\treturn crypto_transfer_hash_request_to_engine(engine, areq);\n}\n\nstatic u64 hash_pad(__le32 *buf, unsigned int bufsize, u64 padi, u64 byte_count, bool le, int bs)\n{\n\tu64 fill, min_fill, j, k;\n\t__be64 *bebits;\n\t__le64 *lebits;\n\n\tj = padi;\n\tbuf[j++] = cpu_to_le32(0x80);\n\n\tif (bs == 64) {\n\t\tfill = 64 - (byte_count % 64);\n\t\tmin_fill = 2 * sizeof(u32) + sizeof(u32);\n\t} else {\n\t\tfill = 128 - (byte_count % 128);\n\t\tmin_fill = 4 * sizeof(u32) + sizeof(u32);\n\t}\n\n\tif (fill < min_fill)\n\t\tfill += bs;\n\n\tk = j;\n\tj += (fill - min_fill) / sizeof(u32);\n\tif (j * 4 > bufsize) {\n\t\tpr_err(\"%s OVERFLOW %llu\\n\", __func__, j);\n\t\treturn 0;\n\t}\n\tfor (; k < j; k++)\n\t\tbuf[k] = 0;\n\n\tif (le) {\n\t\t \n\t\tlebits = (__le64 *)&buf[j];\n\t\t*lebits = cpu_to_le64(byte_count << 3);\n\t\tj += 2;\n\t} else {\n\t\tif (bs == 64) {\n\t\t\t \n\t\t\tbebits = (__be64 *)&buf[j];\n\t\t\t*bebits = cpu_to_be64(byte_count << 3);\n\t\t\tj += 2;\n\t\t} else {\n\t\t\t \n\t\t\tbebits = (__be64 *)&buf[j];\n\t\t\t*bebits = cpu_to_be64(byte_count >> 61);\n\t\t\tj += 2;\n\t\t\tbebits = (__be64 *)&buf[j];\n\t\t\t*bebits = cpu_to_be64(byte_count << 3);\n\t\t\tj += 2;\n\t\t}\n\t}\n\tif (j * 4 > bufsize) {\n\t\tpr_err(\"%s OVERFLOW %llu\\n\", __func__, j);\n\t\treturn 0;\n\t}\n\n\treturn j;\n}\n\n \nint sun8i_ss_hash_run(struct crypto_engine *engine, void *breq)\n{\n\tstruct ahash_request *areq = container_of(breq, struct ahash_request, base);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct sun8i_ss_hash_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\tstruct sun8i_ss_hash_reqctx *rctx = ahash_request_ctx(areq);\n\tstruct ahash_alg *alg = crypto_ahash_alg(tfm);\n\tstruct sun8i_ss_alg_template *algt;\n\tstruct sun8i_ss_dev *ss;\n\tstruct scatterlist *sg;\n\tint bs = crypto_ahash_blocksize(tfm);\n\tint nr_sgs, err, digestsize;\n\tunsigned int len;\n\tu64 byte_count;\n\tvoid *pad, *result;\n\tint j, i, k, todo;\n\tdma_addr_t addr_res, addr_pad, addr_xpad;\n\t__le32 *bf;\n\t \n\tint hmac = 0;\n\n\talgt = container_of(alg, struct sun8i_ss_alg_template, alg.hash.base);\n\tss = algt->ss;\n\n\tdigestsize = crypto_ahash_digestsize(tfm);\n\tif (digestsize == SHA224_DIGEST_SIZE)\n\t\tdigestsize = SHA256_DIGEST_SIZE;\n\n\tresult = ss->flows[rctx->flow].result;\n\tpad = ss->flows[rctx->flow].pad;\n\tbf = (__le32 *)pad;\n\n\tfor (i = 0; i < MAX_SG; i++) {\n\t\trctx->t_dst[i].addr = 0;\n\t\trctx->t_dst[i].len = 0;\n\t}\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG\n\talgt->stat_req++;\n#endif\n\n\trctx->method = ss->variant->alg_hash[algt->ss_algo_id];\n\n\tnr_sgs = dma_map_sg(ss->dev, areq->src, sg_nents(areq->src), DMA_TO_DEVICE);\n\tif (nr_sgs <= 0 || nr_sgs > MAX_SG) {\n\t\tdev_err(ss->dev, \"Invalid sg number %d\\n\", nr_sgs);\n\t\terr = -EINVAL;\n\t\tgoto theend;\n\t}\n\n\taddr_res = dma_map_single(ss->dev, result, digestsize, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(ss->dev, addr_res)) {\n\t\tdev_err(ss->dev, \"DMA map dest\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_dma_result;\n\t}\n\n\tj = 0;\n\tlen = areq->nbytes;\n\tsg = areq->src;\n\ti = 0;\n\twhile (len > 0 && sg) {\n\t\tif (sg_dma_len(sg) == 0) {\n\t\t\tsg = sg_next(sg);\n\t\t\tcontinue;\n\t\t}\n\t\ttodo = min(len, sg_dma_len(sg));\n\t\t \n\t\tif (todo % 64 == 0) {\n\t\t\trctx->t_src[i].addr = sg_dma_address(sg);\n\t\t\trctx->t_src[i].len = todo / 4;\n\t\t\trctx->t_dst[i].addr = addr_res;\n\t\t\trctx->t_dst[i].len = digestsize / 4;\n\t\t\tlen -= todo;\n\t\t} else {\n\t\t\tscatterwalk_map_and_copy(bf, sg, 0, todo, 0);\n\t\t\tj += todo / 4;\n\t\t\tlen -= todo;\n\t\t}\n\t\tsg = sg_next(sg);\n\t\ti++;\n\t}\n\tif (len > 0) {\n\t\tdev_err(ss->dev, \"remaining len %d\\n\", len);\n\t\terr = -EINVAL;\n\t\tgoto theend;\n\t}\n\n\tif (j > 0)\n\t\ti--;\n\nretry:\n\tbyte_count = areq->nbytes;\n\tif (tfmctx->keylen && hmac == 0) {\n\t\thmac = 1;\n\t\t \n\t\tfor (k = 6; k >= 0; k--) {\n\t\t\trctx->t_src[k + 1].addr = rctx->t_src[k].addr;\n\t\t\trctx->t_src[k + 1].len = rctx->t_src[k].len;\n\t\t\trctx->t_dst[k + 1].addr = rctx->t_dst[k].addr;\n\t\t\trctx->t_dst[k + 1].len = rctx->t_dst[k].len;\n\t\t}\n\t\taddr_xpad = dma_map_single(ss->dev, tfmctx->ipad, bs, DMA_TO_DEVICE);\n\t\terr = dma_mapping_error(ss->dev, addr_xpad);\n\t\tif (err) {\n\t\t\tdev_err(ss->dev, \"Fail to create DMA mapping of ipad\\n\");\n\t\t\tgoto err_dma_xpad;\n\t\t}\n\t\trctx->t_src[0].addr = addr_xpad;\n\t\trctx->t_src[0].len = bs / 4;\n\t\trctx->t_dst[0].addr = addr_res;\n\t\trctx->t_dst[0].len = digestsize / 4;\n\t\ti++;\n\t\tbyte_count = areq->nbytes + bs;\n\t}\n\tif (tfmctx->keylen && hmac == 2) {\n\t\tfor (i = 0; i < MAX_SG; i++) {\n\t\t\trctx->t_src[i].addr = 0;\n\t\t\trctx->t_src[i].len = 0;\n\t\t\trctx->t_dst[i].addr = 0;\n\t\t\trctx->t_dst[i].len = 0;\n\t\t}\n\n\t\taddr_res = dma_map_single(ss->dev, result, digestsize, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(ss->dev, addr_res)) {\n\t\t\tdev_err(ss->dev, \"Fail to create DMA mapping of result\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_dma_result;\n\t\t}\n\t\taddr_xpad = dma_map_single(ss->dev, tfmctx->opad, bs, DMA_TO_DEVICE);\n\t\terr = dma_mapping_error(ss->dev, addr_xpad);\n\t\tif (err) {\n\t\t\tdev_err(ss->dev, \"Fail to create DMA mapping of opad\\n\");\n\t\t\tgoto err_dma_xpad;\n\t\t}\n\t\trctx->t_src[0].addr = addr_xpad;\n\t\trctx->t_src[0].len = bs / 4;\n\n\t\tmemcpy(bf, result, digestsize);\n\t\tj = digestsize / 4;\n\t\ti = 1;\n\t\tbyte_count = digestsize + bs;\n\n\t\trctx->t_dst[0].addr = addr_res;\n\t\trctx->t_dst[0].len = digestsize / 4;\n\t}\n\n\tswitch (algt->ss_algo_id) {\n\tcase SS_ID_HASH_MD5:\n\t\tj = hash_pad(bf, 4096, j, byte_count, true, bs);\n\t\tbreak;\n\tcase SS_ID_HASH_SHA1:\n\tcase SS_ID_HASH_SHA224:\n\tcase SS_ID_HASH_SHA256:\n\t\tj = hash_pad(bf, 4096, j, byte_count, false, bs);\n\t\tbreak;\n\t}\n\tif (!j) {\n\t\terr = -EINVAL;\n\t\tgoto theend;\n\t}\n\n\taddr_pad = dma_map_single(ss->dev, pad, j * 4, DMA_TO_DEVICE);\n\tif (dma_mapping_error(ss->dev, addr_pad)) {\n\t\tdev_err(ss->dev, \"DMA error on padding SG\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_dma_pad;\n\t}\n\trctx->t_src[i].addr = addr_pad;\n\trctx->t_src[i].len = j;\n\trctx->t_dst[i].addr = addr_res;\n\trctx->t_dst[i].len = digestsize / 4;\n\n\terr = sun8i_ss_run_hash_task(ss, rctx, crypto_tfm_alg_name(areq->base.tfm));\n\n\t \n\n\tdma_unmap_single(ss->dev, addr_pad, j * 4, DMA_TO_DEVICE);\n\nerr_dma_pad:\n\tif (hmac > 0)\n\t\tdma_unmap_single(ss->dev, addr_xpad, bs, DMA_TO_DEVICE);\nerr_dma_xpad:\n\tdma_unmap_single(ss->dev, addr_res, digestsize, DMA_FROM_DEVICE);\nerr_dma_result:\n\tif (hmac < 2)\n\t\tdma_unmap_sg(ss->dev, areq->src, sg_nents(areq->src),\n\t\t\t     DMA_TO_DEVICE);\n\tif (hmac == 1 && !err) {\n\t\thmac = 2;\n\t\tgoto retry;\n\t}\n\n\tif (!err)\n\t\tmemcpy(areq->result, result, crypto_ahash_digestsize(tfm));\ntheend:\n\tlocal_bh_disable();\n\tcrypto_finalize_hash_request(engine, breq, err);\n\tlocal_bh_enable();\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}