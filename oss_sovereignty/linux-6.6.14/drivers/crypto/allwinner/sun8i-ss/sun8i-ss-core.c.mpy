{
  "module_name": "sun8i-ss-core.c",
  "hash_id": "389b35945b4fd7ff44dce06247dfe8ae8313de09b831adc8ea47b810ff75eb54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/allwinner/sun8i-ss/sun8i-ss-core.c",
  "human_readable_source": "\n \n\n#include <crypto/engine.h>\n#include <crypto/internal/rng.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include \"sun8i-ss.h\"\n\nstatic const struct ss_variant ss_a80_variant = {\n\t.alg_cipher = { SS_ALG_AES, SS_ALG_DES, SS_ALG_3DES,\n\t},\n\t.alg_hash = { SS_ID_NOTSUPP, SS_ID_NOTSUPP, SS_ID_NOTSUPP, SS_ID_NOTSUPP,\n\t},\n\t.op_mode = { SS_OP_ECB, SS_OP_CBC,\n\t},\n\t.ss_clks = {\n\t\t{ \"bus\", 0, 300 * 1000 * 1000 },\n\t\t{ \"mod\", 0, 300 * 1000 * 1000 },\n\t}\n};\n\nstatic const struct ss_variant ss_a83t_variant = {\n\t.alg_cipher = { SS_ALG_AES, SS_ALG_DES, SS_ALG_3DES,\n\t},\n\t.alg_hash = { SS_ALG_MD5, SS_ALG_SHA1, SS_ALG_SHA224, SS_ALG_SHA256,\n\t},\n\t.op_mode = { SS_OP_ECB, SS_OP_CBC,\n\t},\n\t.ss_clks = {\n\t\t{ \"bus\", 0, 300 * 1000 * 1000 },\n\t\t{ \"mod\", 0, 300 * 1000 * 1000 },\n\t}\n};\n\n \nint sun8i_ss_get_engine_number(struct sun8i_ss_dev *ss)\n{\n\treturn atomic_inc_return(&ss->flow) % MAXFLOW;\n}\n\nint sun8i_ss_run_task(struct sun8i_ss_dev *ss, struct sun8i_cipher_req_ctx *rctx,\n\t\t      const char *name)\n{\n\tint flow = rctx->flow;\n\tunsigned int ivlen = rctx->ivlen;\n\tu32 v = SS_START;\n\tint i;\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG\n\tss->flows[flow].stat_req++;\n#endif\n\n\t \n\tif (flow)\n\t\tv |= SS_FLOW1;\n\telse\n\t\tv |= SS_FLOW0;\n\n\tv |= rctx->op_mode;\n\tv |= rctx->method;\n\n\tif (rctx->op_dir)\n\t\tv |= SS_DECRYPTION;\n\n\tswitch (rctx->keylen) {\n\tcase 128 / 8:\n\t\tv |= SS_AES_128BITS << 7;\n\t\tbreak;\n\tcase 192 / 8:\n\t\tv |= SS_AES_192BITS << 7;\n\t\tbreak;\n\tcase 256 / 8:\n\t\tv |= SS_AES_256BITS << 7;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < MAX_SG; i++) {\n\t\tif (!rctx->t_dst[i].addr)\n\t\t\tbreak;\n\n\t\tmutex_lock(&ss->mlock);\n\t\twritel(rctx->p_key, ss->base + SS_KEY_ADR_REG);\n\n\t\tif (ivlen) {\n\t\t\tif (rctx->op_dir == SS_ENCRYPTION) {\n\t\t\t\tif (i == 0)\n\t\t\t\t\twritel(rctx->p_iv[0], ss->base + SS_IV_ADR_REG);\n\t\t\t\telse\n\t\t\t\t\twritel(rctx->t_dst[i - 1].addr + rctx->t_dst[i - 1].len * 4 - ivlen, ss->base + SS_IV_ADR_REG);\n\t\t\t} else {\n\t\t\t\twritel(rctx->p_iv[i], ss->base + SS_IV_ADR_REG);\n\t\t\t}\n\t\t}\n\n\t\tdev_dbg(ss->dev,\n\t\t\t\"Processing SG %d on flow %d %s ctl=%x %d to %d method=%x opmode=%x opdir=%x srclen=%d\\n\",\n\t\t\ti, flow, name, v,\n\t\t\trctx->t_src[i].len, rctx->t_dst[i].len,\n\t\t\trctx->method, rctx->op_mode,\n\t\t\trctx->op_dir, rctx->t_src[i].len);\n\n\t\twritel(rctx->t_src[i].addr, ss->base + SS_SRC_ADR_REG);\n\t\twritel(rctx->t_dst[i].addr, ss->base + SS_DST_ADR_REG);\n\t\twritel(rctx->t_src[i].len, ss->base + SS_LEN_ADR_REG);\n\n\t\treinit_completion(&ss->flows[flow].complete);\n\t\tss->flows[flow].status = 0;\n\t\twmb();\n\n\t\twritel(v, ss->base + SS_CTL_REG);\n\t\tmutex_unlock(&ss->mlock);\n\t\twait_for_completion_interruptible_timeout(&ss->flows[flow].complete,\n\t\t\t\t\t\t\t  msecs_to_jiffies(2000));\n\t\tif (ss->flows[flow].status == 0) {\n\t\t\tdev_err(ss->dev, \"DMA timeout for %s\\n\", name);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t ss_irq_handler(int irq, void *data)\n{\n\tstruct sun8i_ss_dev *ss = (struct sun8i_ss_dev *)data;\n\tint flow = 0;\n\tu32 p;\n\n\tp = readl(ss->base + SS_INT_STA_REG);\n\tfor (flow = 0; flow < MAXFLOW; flow++) {\n\t\tif (p & (BIT(flow))) {\n\t\t\twritel(BIT(flow), ss->base + SS_INT_STA_REG);\n\t\t\tss->flows[flow].status = 1;\n\t\t\tcomplete(&ss->flows[flow].complete);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct sun8i_ss_alg_template ss_algs[] = {\n{\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.ss_algo_id = SS_ID_CIPHER_AES,\n\t.ss_blockmode = SS_ID_OP_CBC,\n\t.alg.skcipher.base = {\n\t\t.base = {\n\t\t\t.cra_name = \"cbc(aes)\",\n\t\t\t.cra_driver_name = \"cbc-aes-sun8i-ss\",\n\t\t\t.cra_priority = 400,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\tCRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun8i_cipher_tfm_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 0xf,\n\t\t\t.cra_init = sun8i_ss_cipher_init,\n\t\t\t.cra_exit = sun8i_ss_cipher_exit,\n\t\t},\n\t\t.min_keysize\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.setkey\t\t= sun8i_ss_aes_setkey,\n\t\t.encrypt\t= sun8i_ss_skencrypt,\n\t\t.decrypt\t= sun8i_ss_skdecrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = sun8i_ss_handle_cipher_request,\n\t},\n},\n{\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.ss_algo_id = SS_ID_CIPHER_AES,\n\t.ss_blockmode = SS_ID_OP_ECB,\n\t.alg.skcipher.base = {\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(aes)\",\n\t\t\t.cra_driver_name = \"ecb-aes-sun8i-ss\",\n\t\t\t.cra_priority = 400,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\tCRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun8i_cipher_tfm_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 0xf,\n\t\t\t.cra_init = sun8i_ss_cipher_init,\n\t\t\t.cra_exit = sun8i_ss_cipher_exit,\n\t\t},\n\t\t.min_keysize\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t= AES_MAX_KEY_SIZE,\n\t\t.setkey\t\t= sun8i_ss_aes_setkey,\n\t\t.encrypt\t= sun8i_ss_skencrypt,\n\t\t.decrypt\t= sun8i_ss_skdecrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = sun8i_ss_handle_cipher_request,\n\t},\n},\n{\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.ss_algo_id = SS_ID_CIPHER_DES3,\n\t.ss_blockmode = SS_ID_OP_CBC,\n\t.alg.skcipher.base = {\n\t\t.base = {\n\t\t\t.cra_name = \"cbc(des3_ede)\",\n\t\t\t.cra_driver_name = \"cbc-des3-sun8i-ss\",\n\t\t\t.cra_priority = 400,\n\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\tCRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun8i_cipher_tfm_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 0xf,\n\t\t\t.cra_init = sun8i_ss_cipher_init,\n\t\t\t.cra_exit = sun8i_ss_cipher_exit,\n\t\t},\n\t\t.min_keysize\t= DES3_EDE_KEY_SIZE,\n\t\t.max_keysize\t= DES3_EDE_KEY_SIZE,\n\t\t.ivsize\t\t= DES3_EDE_BLOCK_SIZE,\n\t\t.setkey\t\t= sun8i_ss_des3_setkey,\n\t\t.encrypt\t= sun8i_ss_skencrypt,\n\t\t.decrypt\t= sun8i_ss_skdecrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = sun8i_ss_handle_cipher_request,\n\t},\n},\n{\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.ss_algo_id = SS_ID_CIPHER_DES3,\n\t.ss_blockmode = SS_ID_OP_ECB,\n\t.alg.skcipher.base = {\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(des3_ede)\",\n\t\t\t.cra_driver_name = \"ecb-des3-sun8i-ss\",\n\t\t\t.cra_priority = 400,\n\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\tCRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun8i_cipher_tfm_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 0xf,\n\t\t\t.cra_init = sun8i_ss_cipher_init,\n\t\t\t.cra_exit = sun8i_ss_cipher_exit,\n\t\t},\n\t\t.min_keysize\t= DES3_EDE_KEY_SIZE,\n\t\t.max_keysize\t= DES3_EDE_KEY_SIZE,\n\t\t.setkey\t\t= sun8i_ss_des3_setkey,\n\t\t.encrypt\t= sun8i_ss_skencrypt,\n\t\t.decrypt\t= sun8i_ss_skdecrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = sun8i_ss_handle_cipher_request,\n\t},\n},\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_SS_PRNG\n{\n\t.type = CRYPTO_ALG_TYPE_RNG,\n\t.alg.rng = {\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"stdrng\",\n\t\t\t.cra_driver_name\t= \"sun8i-ss-prng\",\n\t\t\t.cra_priority\t\t= 300,\n\t\t\t.cra_ctxsize = sizeof(struct sun8i_ss_rng_tfm_ctx),\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t\t.cra_init\t\t= sun8i_ss_prng_init,\n\t\t\t.cra_exit\t\t= sun8i_ss_prng_exit,\n\t\t},\n\t\t.generate               = sun8i_ss_prng_generate,\n\t\t.seed                   = sun8i_ss_prng_seed,\n\t\t.seedsize               = PRNG_SEED_SIZE,\n\t}\n},\n#endif\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_SS_HASH\n{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t.ss_algo_id = SS_ID_HASH_MD5,\n\t.alg.hash.base = {\n\t\t.init = sun8i_ss_hash_init,\n\t\t.update = sun8i_ss_hash_update,\n\t\t.final = sun8i_ss_hash_final,\n\t\t.finup = sun8i_ss_hash_finup,\n\t\t.digest = sun8i_ss_hash_digest,\n\t\t.export = sun8i_ss_hash_export,\n\t\t.import = sun8i_ss_hash_import,\n\t\t.init_tfm = sun8i_ss_hash_init_tfm,\n\t\t.exit_tfm = sun8i_ss_hash_exit_tfm,\n\t\t.halg = {\n\t\t\t.digestsize = MD5_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct md5_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"md5\",\n\t\t\t\t.cra_driver_name = \"md5-sun8i-ss\",\n\t\t\t\t.cra_priority = 300,\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_flags = CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize = MD5_HMAC_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct sun8i_ss_hash_tfm_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t}\n\t},\n\t.alg.hash.op = {\n\t\t.do_one_request = sun8i_ss_hash_run,\n\t},\n},\n{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t.ss_algo_id = SS_ID_HASH_SHA1,\n\t.alg.hash.base = {\n\t\t.init = sun8i_ss_hash_init,\n\t\t.update = sun8i_ss_hash_update,\n\t\t.final = sun8i_ss_hash_final,\n\t\t.finup = sun8i_ss_hash_finup,\n\t\t.digest = sun8i_ss_hash_digest,\n\t\t.export = sun8i_ss_hash_export,\n\t\t.import = sun8i_ss_hash_import,\n\t\t.init_tfm = sun8i_ss_hash_init_tfm,\n\t\t.exit_tfm = sun8i_ss_hash_exit_tfm,\n\t\t.halg = {\n\t\t\t.digestsize = SHA1_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct sha1_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha1\",\n\t\t\t\t.cra_driver_name = \"sha1-sun8i-ss\",\n\t\t\t\t.cra_priority = 300,\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_flags = CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize = SHA1_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct sun8i_ss_hash_tfm_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t}\n\t},\n\t.alg.hash.op = {\n\t\t.do_one_request = sun8i_ss_hash_run,\n\t},\n},\n{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t.ss_algo_id = SS_ID_HASH_SHA224,\n\t.alg.hash.base = {\n\t\t.init = sun8i_ss_hash_init,\n\t\t.update = sun8i_ss_hash_update,\n\t\t.final = sun8i_ss_hash_final,\n\t\t.finup = sun8i_ss_hash_finup,\n\t\t.digest = sun8i_ss_hash_digest,\n\t\t.export = sun8i_ss_hash_export,\n\t\t.import = sun8i_ss_hash_import,\n\t\t.init_tfm = sun8i_ss_hash_init_tfm,\n\t\t.exit_tfm = sun8i_ss_hash_exit_tfm,\n\t\t.halg = {\n\t\t\t.digestsize = SHA224_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct sha256_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha224\",\n\t\t\t\t.cra_driver_name = \"sha224-sun8i-ss\",\n\t\t\t\t.cra_priority = 300,\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_flags = CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize = SHA224_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct sun8i_ss_hash_tfm_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t}\n\t},\n\t.alg.hash.op = {\n\t\t.do_one_request = sun8i_ss_hash_run,\n\t},\n},\n{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t.ss_algo_id = SS_ID_HASH_SHA256,\n\t.alg.hash.base = {\n\t\t.init = sun8i_ss_hash_init,\n\t\t.update = sun8i_ss_hash_update,\n\t\t.final = sun8i_ss_hash_final,\n\t\t.finup = sun8i_ss_hash_finup,\n\t\t.digest = sun8i_ss_hash_digest,\n\t\t.export = sun8i_ss_hash_export,\n\t\t.import = sun8i_ss_hash_import,\n\t\t.init_tfm = sun8i_ss_hash_init_tfm,\n\t\t.exit_tfm = sun8i_ss_hash_exit_tfm,\n\t\t.halg = {\n\t\t\t.digestsize = SHA256_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct sha256_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha256\",\n\t\t\t\t.cra_driver_name = \"sha256-sun8i-ss\",\n\t\t\t\t.cra_priority = 300,\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_flags = CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize = SHA256_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct sun8i_ss_hash_tfm_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t}\n\t},\n\t.alg.hash.op = {\n\t\t.do_one_request = sun8i_ss_hash_run,\n\t},\n},\n{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t.ss_algo_id = SS_ID_HASH_SHA1,\n\t.alg.hash.base = {\n\t\t.init = sun8i_ss_hash_init,\n\t\t.update = sun8i_ss_hash_update,\n\t\t.final = sun8i_ss_hash_final,\n\t\t.finup = sun8i_ss_hash_finup,\n\t\t.digest = sun8i_ss_hash_digest,\n\t\t.export = sun8i_ss_hash_export,\n\t\t.import = sun8i_ss_hash_import,\n\t\t.init_tfm = sun8i_ss_hash_init_tfm,\n\t\t.exit_tfm = sun8i_ss_hash_exit_tfm,\n\t\t.setkey = sun8i_ss_hmac_setkey,\n\t\t.halg = {\n\t\t\t.digestsize = SHA1_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct sha1_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"hmac(sha1)\",\n\t\t\t\t.cra_driver_name = \"hmac-sha1-sun8i-ss\",\n\t\t\t\t.cra_priority = 300,\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_flags = CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize = SHA1_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct sun8i_ss_hash_tfm_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t}\n\t},\n\t.alg.hash.op = {\n\t\t.do_one_request = sun8i_ss_hash_run,\n\t},\n},\n#endif\n};\n\nstatic int sun8i_ss_debugfs_show(struct seq_file *seq, void *v)\n{\n\tstruct sun8i_ss_dev *ss __maybe_unused = seq->private;\n\tunsigned int i;\n\n\tfor (i = 0; i < MAXFLOW; i++)\n\t\tseq_printf(seq, \"Channel %d: nreq %lu\\n\", i,\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG\n\t\t\t   ss->flows[i].stat_req);\n#else\n\t\t\t   0ul);\n#endif\n\n\tfor (i = 0; i < ARRAY_SIZE(ss_algs); i++) {\n\t\tif (!ss_algs[i].ss)\n\t\t\tcontinue;\n\t\tswitch (ss_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tseq_printf(seq, \"%s %s reqs=%lu fallback=%lu\\n\",\n\t\t\t\t   ss_algs[i].alg.skcipher.base.base.cra_driver_name,\n\t\t\t\t   ss_algs[i].alg.skcipher.base.base.cra_name,\n\t\t\t\t   ss_algs[i].stat_req, ss_algs[i].stat_fb);\n\n\t\t\tseq_printf(seq, \"\\tLast fallback is: %s\\n\",\n\t\t\t\t   ss_algs[i].fbname);\n\t\t\tseq_printf(seq, \"\\tFallback due to length: %lu\\n\",\n\t\t\t\t   ss_algs[i].stat_fb_len);\n\t\t\tseq_printf(seq, \"\\tFallback due to SG length: %lu\\n\",\n\t\t\t\t   ss_algs[i].stat_fb_sglen);\n\t\t\tseq_printf(seq, \"\\tFallback due to alignment: %lu\\n\",\n\t\t\t\t   ss_algs[i].stat_fb_align);\n\t\t\tseq_printf(seq, \"\\tFallback due to SG numbers: %lu\\n\",\n\t\t\t\t   ss_algs[i].stat_fb_sgnum);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_RNG:\n\t\t\tseq_printf(seq, \"%s %s reqs=%lu tsize=%lu\\n\",\n\t\t\t\t   ss_algs[i].alg.rng.base.cra_driver_name,\n\t\t\t\t   ss_algs[i].alg.rng.base.cra_name,\n\t\t\t\t   ss_algs[i].stat_req, ss_algs[i].stat_bytes);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\tseq_printf(seq, \"%s %s reqs=%lu fallback=%lu\\n\",\n\t\t\t\t   ss_algs[i].alg.hash.base.halg.base.cra_driver_name,\n\t\t\t\t   ss_algs[i].alg.hash.base.halg.base.cra_name,\n\t\t\t\t   ss_algs[i].stat_req, ss_algs[i].stat_fb);\n\t\t\tseq_printf(seq, \"\\tLast fallback is: %s\\n\",\n\t\t\t\t   ss_algs[i].fbname);\n\t\t\tseq_printf(seq, \"\\tFallback due to length: %lu\\n\",\n\t\t\t\t   ss_algs[i].stat_fb_len);\n\t\t\tseq_printf(seq, \"\\tFallback due to SG length: %lu\\n\",\n\t\t\t\t   ss_algs[i].stat_fb_sglen);\n\t\t\tseq_printf(seq, \"\\tFallback due to alignment: %lu\\n\",\n\t\t\t\t   ss_algs[i].stat_fb_align);\n\t\t\tseq_printf(seq, \"\\tFallback due to SG numbers: %lu\\n\",\n\t\t\t\t   ss_algs[i].stat_fb_sgnum);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(sun8i_ss_debugfs);\n\nstatic void sun8i_ss_free_flows(struct sun8i_ss_dev *ss, int i)\n{\n\twhile (i >= 0) {\n\t\tcrypto_engine_exit(ss->flows[i].engine);\n\t\ti--;\n\t}\n}\n\n \nstatic int allocate_flows(struct sun8i_ss_dev *ss)\n{\n\tint i, j, err;\n\n\tss->flows = devm_kcalloc(ss->dev, MAXFLOW, sizeof(struct sun8i_ss_flow),\n\t\t\t\t GFP_KERNEL);\n\tif (!ss->flows)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < MAXFLOW; i++) {\n\t\tinit_completion(&ss->flows[i].complete);\n\n\t\tss->flows[i].biv = devm_kmalloc(ss->dev, AES_BLOCK_SIZE,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!ss->flows[i].biv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_engine;\n\t\t}\n\n\t\tfor (j = 0; j < MAX_SG; j++) {\n\t\t\tss->flows[i].iv[j] = devm_kmalloc(ss->dev, AES_BLOCK_SIZE,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!ss->flows[i].iv[j]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error_engine;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tss->flows[i].pad = devm_kmalloc(ss->dev, MAX_PAD_SIZE,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!ss->flows[i].pad) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_engine;\n\t\t}\n\t\tss->flows[i].result =\n\t\t\tdevm_kmalloc(ss->dev, max(SHA256_DIGEST_SIZE,\n\t\t\t\t\t\t  dma_get_cache_alignment()),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!ss->flows[i].result) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_engine;\n\t\t}\n\n\t\tss->flows[i].engine = crypto_engine_alloc_init(ss->dev, true);\n\t\tif (!ss->flows[i].engine) {\n\t\t\tdev_err(ss->dev, \"Cannot allocate engine\\n\");\n\t\t\ti--;\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error_engine;\n\t\t}\n\t\terr = crypto_engine_start(ss->flows[i].engine);\n\t\tif (err) {\n\t\t\tdev_err(ss->dev, \"Cannot start engine\\n\");\n\t\t\tgoto error_engine;\n\t\t}\n\t}\n\treturn 0;\nerror_engine:\n\tsun8i_ss_free_flows(ss, i);\n\treturn err;\n}\n\n \nstatic int sun8i_ss_pm_suspend(struct device *dev)\n{\n\tstruct sun8i_ss_dev *ss = dev_get_drvdata(dev);\n\tint i;\n\n\treset_control_assert(ss->reset);\n\tfor (i = 0; i < SS_MAX_CLOCKS; i++)\n\t\tclk_disable_unprepare(ss->ssclks[i]);\n\treturn 0;\n}\n\nstatic int sun8i_ss_pm_resume(struct device *dev)\n{\n\tstruct sun8i_ss_dev *ss = dev_get_drvdata(dev);\n\tint err, i;\n\n\tfor (i = 0; i < SS_MAX_CLOCKS; i++) {\n\t\tif (!ss->variant->ss_clks[i].name)\n\t\t\tcontinue;\n\t\terr = clk_prepare_enable(ss->ssclks[i]);\n\t\tif (err) {\n\t\t\tdev_err(ss->dev, \"Cannot prepare_enable %s\\n\",\n\t\t\t\tss->variant->ss_clks[i].name);\n\t\t\tgoto error;\n\t\t}\n\t}\n\terr = reset_control_deassert(ss->reset);\n\tif (err) {\n\t\tdev_err(ss->dev, \"Cannot deassert reset control\\n\");\n\t\tgoto error;\n\t}\n\t \n\twritel(BIT(0) | BIT(1), ss->base + SS_INT_CTL_REG);\n\n\treturn 0;\nerror:\n\tsun8i_ss_pm_suspend(dev);\n\treturn err;\n}\n\nstatic const struct dev_pm_ops sun8i_ss_pm_ops = {\n\tSET_RUNTIME_PM_OPS(sun8i_ss_pm_suspend, sun8i_ss_pm_resume, NULL)\n};\n\nstatic int sun8i_ss_pm_init(struct sun8i_ss_dev *ss)\n{\n\tint err;\n\n\tpm_runtime_use_autosuspend(ss->dev);\n\tpm_runtime_set_autosuspend_delay(ss->dev, 2000);\n\n\terr = pm_runtime_set_suspended(ss->dev);\n\tif (err)\n\t\treturn err;\n\tpm_runtime_enable(ss->dev);\n\treturn err;\n}\n\nstatic void sun8i_ss_pm_exit(struct sun8i_ss_dev *ss)\n{\n\tpm_runtime_disable(ss->dev);\n}\n\nstatic int sun8i_ss_register_algs(struct sun8i_ss_dev *ss)\n{\n\tint ss_method, err, id;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ss_algs); i++) {\n\t\tss_algs[i].ss = ss;\n\t\tswitch (ss_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tid = ss_algs[i].ss_algo_id;\n\t\t\tss_method = ss->variant->alg_cipher[id];\n\t\t\tif (ss_method == SS_ID_NOTSUPP) {\n\t\t\t\tdev_info(ss->dev,\n\t\t\t\t\t \"DEBUG: Algo of %s not supported\\n\",\n\t\t\t\t\t ss_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\t\tss_algs[i].ss = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tid = ss_algs[i].ss_blockmode;\n\t\t\tss_method = ss->variant->op_mode[id];\n\t\t\tif (ss_method == SS_ID_NOTSUPP) {\n\t\t\t\tdev_info(ss->dev, \"DEBUG: Blockmode of %s not supported\\n\",\n\t\t\t\t\t ss_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\t\tss_algs[i].ss = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_info(ss->dev, \"DEBUG: Register %s\\n\",\n\t\t\t\t ss_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\terr = crypto_engine_register_skcipher(&ss_algs[i].alg.skcipher);\n\t\t\tif (err) {\n\t\t\t\tdev_err(ss->dev, \"Fail to register %s\\n\",\n\t\t\t\t\tss_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\t\tss_algs[i].ss = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_RNG:\n\t\t\terr = crypto_register_rng(&ss_algs[i].alg.rng);\n\t\t\tif (err) {\n\t\t\t\tdev_err(ss->dev, \"Fail to register %s\\n\",\n\t\t\t\t\tss_algs[i].alg.rng.base.cra_name);\n\t\t\t\tss_algs[i].ss = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\tid = ss_algs[i].ss_algo_id;\n\t\t\tss_method = ss->variant->alg_hash[id];\n\t\t\tif (ss_method == SS_ID_NOTSUPP) {\n\t\t\t\tdev_info(ss->dev,\n\t\t\t\t\t\"DEBUG: Algo of %s not supported\\n\",\n\t\t\t\t\tss_algs[i].alg.hash.base.halg.base.cra_name);\n\t\t\t\tss_algs[i].ss = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_info(ss->dev, \"Register %s\\n\",\n\t\t\t\t ss_algs[i].alg.hash.base.halg.base.cra_name);\n\t\t\terr = crypto_engine_register_ahash(&ss_algs[i].alg.hash);\n\t\t\tif (err) {\n\t\t\t\tdev_err(ss->dev, \"ERROR: Fail to register %s\\n\",\n\t\t\t\t\tss_algs[i].alg.hash.base.halg.base.cra_name);\n\t\t\t\tss_algs[i].ss = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tss_algs[i].ss = NULL;\n\t\t\tdev_err(ss->dev, \"ERROR: tried to register an unknown algo\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sun8i_ss_unregister_algs(struct sun8i_ss_dev *ss)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ss_algs); i++) {\n\t\tif (!ss_algs[i].ss)\n\t\t\tcontinue;\n\t\tswitch (ss_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tdev_info(ss->dev, \"Unregister %d %s\\n\", i,\n\t\t\t\t ss_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\tcrypto_engine_unregister_skcipher(&ss_algs[i].alg.skcipher);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_RNG:\n\t\t\tdev_info(ss->dev, \"Unregister %d %s\\n\", i,\n\t\t\t\t ss_algs[i].alg.rng.base.cra_name);\n\t\t\tcrypto_unregister_rng(&ss_algs[i].alg.rng);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\tdev_info(ss->dev, \"Unregister %d %s\\n\", i,\n\t\t\t\t ss_algs[i].alg.hash.base.halg.base.cra_name);\n\t\t\tcrypto_engine_unregister_ahash(&ss_algs[i].alg.hash);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int sun8i_ss_get_clks(struct sun8i_ss_dev *ss)\n{\n\tunsigned long cr;\n\tint err, i;\n\n\tfor (i = 0; i < SS_MAX_CLOCKS; i++) {\n\t\tif (!ss->variant->ss_clks[i].name)\n\t\t\tcontinue;\n\t\tss->ssclks[i] = devm_clk_get(ss->dev, ss->variant->ss_clks[i].name);\n\t\tif (IS_ERR(ss->ssclks[i])) {\n\t\t\terr = PTR_ERR(ss->ssclks[i]);\n\t\t\tdev_err(ss->dev, \"Cannot get %s SS clock err=%d\\n\",\n\t\t\t\tss->variant->ss_clks[i].name, err);\n\t\t\treturn err;\n\t\t}\n\t\tcr = clk_get_rate(ss->ssclks[i]);\n\t\tif (!cr)\n\t\t\treturn -EINVAL;\n\t\tif (ss->variant->ss_clks[i].freq > 0 &&\n\t\t    cr != ss->variant->ss_clks[i].freq) {\n\t\t\tdev_info(ss->dev, \"Set %s clock to %lu (%lu Mhz) from %lu (%lu Mhz)\\n\",\n\t\t\t\t ss->variant->ss_clks[i].name,\n\t\t\t\t ss->variant->ss_clks[i].freq,\n\t\t\t\t ss->variant->ss_clks[i].freq / 1000000,\n\t\t\t\t cr, cr / 1000000);\n\t\t\terr = clk_set_rate(ss->ssclks[i], ss->variant->ss_clks[i].freq);\n\t\t\tif (err)\n\t\t\t\tdev_err(ss->dev, \"Fail to set %s clk speed to %lu hz\\n\",\n\t\t\t\t\tss->variant->ss_clks[i].name,\n\t\t\t\t\tss->variant->ss_clks[i].freq);\n\t\t}\n\t\tif (ss->variant->ss_clks[i].max_freq > 0 &&\n\t\t    cr > ss->variant->ss_clks[i].max_freq)\n\t\t\tdev_warn(ss->dev, \"Frequency for %s (%lu hz) is higher than datasheet's recommendation (%lu hz)\",\n\t\t\t\t ss->variant->ss_clks[i].name, cr,\n\t\t\t\t ss->variant->ss_clks[i].max_freq);\n\t}\n\treturn 0;\n}\n\nstatic int sun8i_ss_probe(struct platform_device *pdev)\n{\n\tstruct sun8i_ss_dev *ss;\n\tint err, irq;\n\tu32 v;\n\n\tss = devm_kzalloc(&pdev->dev, sizeof(*ss), GFP_KERNEL);\n\tif (!ss)\n\t\treturn -ENOMEM;\n\n\tss->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ss);\n\n\tss->variant = of_device_get_match_data(&pdev->dev);\n\tif (!ss->variant) {\n\t\tdev_err(&pdev->dev, \"Missing Crypto Engine variant\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tss->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ss->base))\n\t\treturn PTR_ERR(ss->base);\n\n\terr = sun8i_ss_get_clks(ss);\n\tif (err)\n\t\treturn err;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tss->reset = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(ss->reset))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(ss->reset),\n\t\t\t\t     \"No reset control found\\n\");\n\n\tmutex_init(&ss->mlock);\n\n\terr = allocate_flows(ss);\n\tif (err)\n\t\treturn err;\n\n\terr = sun8i_ss_pm_init(ss);\n\tif (err)\n\t\tgoto error_pm;\n\n\terr = devm_request_irq(&pdev->dev, irq, ss_irq_handler, 0, \"sun8i-ss\", ss);\n\tif (err) {\n\t\tdev_err(ss->dev, \"Cannot request SecuritySystem IRQ (err=%d)\\n\", err);\n\t\tgoto error_irq;\n\t}\n\n\terr = sun8i_ss_register_algs(ss);\n\tif (err)\n\t\tgoto error_alg;\n\n\terr = pm_runtime_resume_and_get(ss->dev);\n\tif (err < 0)\n\t\tgoto error_alg;\n\n\tv = readl(ss->base + SS_CTL_REG);\n\tv >>= SS_DIE_ID_SHIFT;\n\tv &= SS_DIE_ID_MASK;\n\tdev_info(&pdev->dev, \"Security System Die ID %x\\n\", v);\n\n\tpm_runtime_put_sync(ss->dev);\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG)) {\n\t\tstruct dentry *dbgfs_dir __maybe_unused;\n\t\tstruct dentry *dbgfs_stats __maybe_unused;\n\n\t\t \n\t\tdbgfs_dir = debugfs_create_dir(\"sun8i-ss\", NULL);\n\t\tdbgfs_stats = debugfs_create_file(\"stats\", 0444,\n\t\t\t\t\t\t   dbgfs_dir, ss,\n\t\t\t\t\t\t   &sun8i_ss_debugfs_fops);\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG\n\t\tss->dbgfs_dir = dbgfs_dir;\n\t\tss->dbgfs_stats = dbgfs_stats;\n#endif\n\t}\n\n\treturn 0;\nerror_alg:\n\tsun8i_ss_unregister_algs(ss);\nerror_irq:\n\tsun8i_ss_pm_exit(ss);\nerror_pm:\n\tsun8i_ss_free_flows(ss, MAXFLOW - 1);\n\treturn err;\n}\n\nstatic int sun8i_ss_remove(struct platform_device *pdev)\n{\n\tstruct sun8i_ss_dev *ss = platform_get_drvdata(pdev);\n\n\tsun8i_ss_unregister_algs(ss);\n\n#ifdef CONFIG_CRYPTO_DEV_SUN8I_SS_DEBUG\n\tdebugfs_remove_recursive(ss->dbgfs_dir);\n#endif\n\n\tsun8i_ss_free_flows(ss, MAXFLOW - 1);\n\n\tsun8i_ss_pm_exit(ss);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sun8i_ss_crypto_of_match_table[] = {\n\t{ .compatible = \"allwinner,sun8i-a83t-crypto\",\n\t  .data = &ss_a83t_variant },\n\t{ .compatible = \"allwinner,sun9i-a80-crypto\",\n\t  .data = &ss_a80_variant },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sun8i_ss_crypto_of_match_table);\n\nstatic struct platform_driver sun8i_ss_driver = {\n\t.probe\t\t = sun8i_ss_probe,\n\t.remove\t\t = sun8i_ss_remove,\n\t.driver\t\t = {\n\t\t.name\t\t= \"sun8i-ss\",\n\t\t.pm             = &sun8i_ss_pm_ops,\n\t\t.of_match_table\t= sun8i_ss_crypto_of_match_table,\n\t},\n};\n\nmodule_platform_driver(sun8i_ss_driver);\n\nMODULE_DESCRIPTION(\"Allwinner SecuritySystem cryptographic offloader\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Corentin Labbe <clabbe.montjoie@gmail.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}