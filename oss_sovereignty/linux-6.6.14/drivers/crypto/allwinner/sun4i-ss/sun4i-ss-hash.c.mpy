{
  "module_name": "sun4i-ss-hash.c",
  "hash_id": "7b6bbc6524a56870f1350d787f404e5ca01e5e3d8c662c877de08938bd215028",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/allwinner/sun4i-ss/sun4i-ss-hash.c",
  "human_readable_source": "\n \n#include \"sun4i-ss.h\"\n#include <asm/unaligned.h>\n#include <linux/scatterlist.h>\n\n \n#define SS_TIMEOUT 100\n\nint sun4i_hash_crainit(struct crypto_tfm *tfm)\n{\n\tstruct sun4i_tfm_ctx *op = crypto_tfm_ctx(tfm);\n\tstruct ahash_alg *alg = __crypto_ahash_alg(tfm->__crt_alg);\n\tstruct sun4i_ss_alg_template *algt;\n\tint err;\n\n\tmemset(op, 0, sizeof(struct sun4i_tfm_ctx));\n\n\talgt = container_of(alg, struct sun4i_ss_alg_template, alg.hash);\n\top->ss = algt->ss;\n\n\terr = pm_runtime_resume_and_get(op->ss->dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tcrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\n\t\t\t\t sizeof(struct sun4i_req_ctx));\n\treturn 0;\n}\n\nvoid sun4i_hash_craexit(struct crypto_tfm *tfm)\n{\n\tstruct sun4i_tfm_ctx *op = crypto_tfm_ctx(tfm);\n\n\tpm_runtime_put(op->ss->dev);\n}\n\n \nint sun4i_hash_init(struct ahash_request *areq)\n{\n\tstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct ahash_alg *alg = __crypto_ahash_alg(tfm->base.__crt_alg);\n\tstruct sun4i_ss_alg_template *algt;\n\n\tmemset(op, 0, sizeof(struct sun4i_req_ctx));\n\n\talgt = container_of(alg, struct sun4i_ss_alg_template, alg.hash);\n\top->mode = algt->mode;\n\n\treturn 0;\n}\n\nint sun4i_hash_export_md5(struct ahash_request *areq, void *out)\n{\n\tstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\n\tstruct md5_state *octx = out;\n\tint i;\n\n\toctx->byte_count = op->byte_count + op->len;\n\n\tmemcpy(octx->block, op->buf, op->len);\n\n\tif (op->byte_count) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\toctx->hash[i] = op->hash[i];\n\t} else {\n\t\toctx->hash[0] = SHA1_H0;\n\t\toctx->hash[1] = SHA1_H1;\n\t\toctx->hash[2] = SHA1_H2;\n\t\toctx->hash[3] = SHA1_H3;\n\t}\n\n\treturn 0;\n}\n\nint sun4i_hash_import_md5(struct ahash_request *areq, const void *in)\n{\n\tstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\n\tconst struct md5_state *ictx = in;\n\tint i;\n\n\tsun4i_hash_init(areq);\n\n\top->byte_count = ictx->byte_count & ~0x3F;\n\top->len = ictx->byte_count & 0x3F;\n\n\tmemcpy(op->buf, ictx->block, op->len);\n\n\tfor (i = 0; i < 4; i++)\n\t\top->hash[i] = ictx->hash[i];\n\n\treturn 0;\n}\n\nint sun4i_hash_export_sha1(struct ahash_request *areq, void *out)\n{\n\tstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\n\tstruct sha1_state *octx = out;\n\tint i;\n\n\toctx->count = op->byte_count + op->len;\n\n\tmemcpy(octx->buffer, op->buf, op->len);\n\n\tif (op->byte_count) {\n\t\tfor (i = 0; i < 5; i++)\n\t\t\toctx->state[i] = op->hash[i];\n\t} else {\n\t\toctx->state[0] = SHA1_H0;\n\t\toctx->state[1] = SHA1_H1;\n\t\toctx->state[2] = SHA1_H2;\n\t\toctx->state[3] = SHA1_H3;\n\t\toctx->state[4] = SHA1_H4;\n\t}\n\n\treturn 0;\n}\n\nint sun4i_hash_import_sha1(struct ahash_request *areq, const void *in)\n{\n\tstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\n\tconst struct sha1_state *ictx = in;\n\tint i;\n\n\tsun4i_hash_init(areq);\n\n\top->byte_count = ictx->count & ~0x3F;\n\top->len = ictx->count & 0x3F;\n\n\tmemcpy(op->buf, ictx->buffer, op->len);\n\n\tfor (i = 0; i < 5; i++)\n\t\top->hash[i] = ictx->state[i];\n\n\treturn 0;\n}\n\n#define SS_HASH_UPDATE 1\n#define SS_HASH_FINAL 2\n\n \nstatic int sun4i_hash(struct ahash_request *areq)\n{\n\t \n\tunsigned int i = 0, end, fill, min_fill, nwait, nbw = 0, j = 0, todo;\n\tunsigned int in_i = 0;\n\tu32 spaces, rx_cnt = SS_RX_DEFAULT, bf[32] = {0}, v, ivmode = 0;\n\tstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct ahash_alg *alg = __crypto_ahash_alg(tfm->base.__crt_alg);\n\tstruct sun4i_tfm_ctx *tfmctx = crypto_ahash_ctx(tfm);\n\tstruct sun4i_ss_ctx *ss = tfmctx->ss;\n\tstruct sun4i_ss_alg_template *algt;\n\tstruct scatterlist *in_sg = areq->src;\n\tstruct sg_mapping_iter mi;\n\tint in_r, err = 0;\n\tsize_t copied = 0;\n\tu32 wb = 0;\n\n\tdev_dbg(ss->dev, \"%s %s bc=%llu len=%u mode=%x wl=%u h0=%0x\",\n\t\t__func__, crypto_tfm_alg_name(areq->base.tfm),\n\t\top->byte_count, areq->nbytes, op->mode,\n\t\top->len, op->hash[0]);\n\n\tif (unlikely(!areq->nbytes) && !(op->flags & SS_HASH_FINAL))\n\t\treturn 0;\n\n\t \n\tif (unlikely(areq->nbytes > UINT_MAX - op->len)) {\n\t\tdev_err(ss->dev, \"Cannot process too large request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (op->len + areq->nbytes < 64 && !(op->flags & SS_HASH_FINAL)) {\n\t\t \n\t\tcopied = sg_pcopy_to_buffer(areq->src, sg_nents(areq->src),\n\t\t\t\t\t    op->buf + op->len, areq->nbytes, 0);\n\t\top->len += copied;\n\t\treturn 0;\n\t}\n\n\tspin_lock_bh(&ss->slock);\n\n\t \n\tif (op->byte_count) {\n\t\tivmode = SS_IV_ARBITRARY;\n\t\tfor (i = 0; i < crypto_ahash_digestsize(tfm) / 4; i++)\n\t\t\twritel(op->hash[i], ss->base + SS_IV0 + i * 4);\n\t}\n\t \n\twritel(op->mode | SS_ENABLED | ivmode, ss->base + SS_CTL);\n\n\tif (!(op->flags & SS_HASH_UPDATE))\n\t\tgoto hash_final;\n\n\t \n\tif (!(op->flags & SS_HASH_FINAL)) {\n\t\tend = ((areq->nbytes + op->len) / 64) * 64 - op->len;\n\n\t\tif (end > areq->nbytes || areq->nbytes - end > 63) {\n\t\t\tdev_err(ss->dev, \"ERROR: Bound error %u %u\\n\",\n\t\t\t\tend, areq->nbytes);\n\t\t\terr = -EINVAL;\n\t\t\tgoto release_ss;\n\t\t}\n\t} else {\n\t\t \n\t\tif (areq->nbytes < 4)\n\t\t\tend = 0;\n\t\telse\n\t\t\tend = ((areq->nbytes + op->len) / 4) * 4 - op->len;\n\t}\n\n\t \n\ti = 1;\n\twhile (in_sg && i == 1) {\n\t\tif (in_sg->length % 4)\n\t\t\ti = 0;\n\t\tin_sg = sg_next(in_sg);\n\t}\n\tif (i == 1 && !op->len && areq->nbytes)\n\t\tdev_dbg(ss->dev, \"We can DMA\\n\");\n\n\ti = 0;\n\tsg_miter_start(&mi, areq->src, sg_nents(areq->src),\n\t\t       SG_MITER_FROM_SG | SG_MITER_ATOMIC);\n\tsg_miter_next(&mi);\n\tin_i = 0;\n\n\tdo {\n\t\t \n\t\tif (op->len || (mi.length - in_i) < 4) {\n\t\t\t \n\t\t\twhile (op->len < 64 && i < end) {\n\t\t\t\t \n\t\t\t\tin_r = min(end - i, 64 - op->len);\n\t\t\t\tin_r = min_t(size_t, mi.length - in_i, in_r);\n\t\t\t\tmemcpy(op->buf + op->len, mi.addr + in_i, in_r);\n\t\t\t\top->len += in_r;\n\t\t\t\ti += in_r;\n\t\t\t\tin_i += in_r;\n\t\t\t\tif (in_i == mi.length) {\n\t\t\t\t\tsg_miter_next(&mi);\n\t\t\t\t\tin_i = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op->len > 3 && !(op->len % 4)) {\n\t\t\t\t \n\t\t\t\twritesl(ss->base + SS_RXFIFO, op->buf,\n\t\t\t\t\top->len / 4);\n\t\t\t\top->byte_count += op->len;\n\t\t\t\top->len = 0;\n\t\t\t}\n\t\t}\n\t\tif (mi.length - in_i > 3 && i < end) {\n\t\t\t \n\t\t\tin_r = min_t(size_t, mi.length - in_i, areq->nbytes - i);\n\t\t\tin_r = min_t(size_t, ((mi.length - in_i) / 4) * 4, in_r);\n\t\t\t \n\t\t\ttodo = min3((u32)(end - i) / 4, rx_cnt, (u32)in_r / 4);\n\t\t\twritesl(ss->base + SS_RXFIFO, mi.addr + in_i, todo);\n\t\t\top->byte_count += todo * 4;\n\t\t\ti += todo * 4;\n\t\t\tin_i += todo * 4;\n\t\t\trx_cnt -= todo;\n\t\t\tif (!rx_cnt) {\n\t\t\t\tspaces = readl(ss->base + SS_FCSR);\n\t\t\t\trx_cnt = SS_RXFIFO_SPACES(spaces);\n\t\t\t}\n\t\t\tif (in_i == mi.length) {\n\t\t\t\tsg_miter_next(&mi);\n\t\t\t\tin_i = 0;\n\t\t\t}\n\t\t}\n\t} while (i < end);\n\n\t \n\tif ((areq->nbytes - i) < 64) {\n\t\twhile (i < areq->nbytes && in_i < mi.length && op->len < 64) {\n\t\t\t \n\t\t\tin_r = min(areq->nbytes - i, 64 - op->len);\n\t\t\tin_r = min_t(size_t, mi.length - in_i, in_r);\n\t\t\tmemcpy(op->buf + op->len, mi.addr + in_i, in_r);\n\t\t\top->len += in_r;\n\t\t\ti += in_r;\n\t\t\tin_i += in_r;\n\t\t\tif (in_i == mi.length) {\n\t\t\t\tsg_miter_next(&mi);\n\t\t\t\tin_i = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tsg_miter_stop(&mi);\n\n\t \n\tif (op->flags & SS_HASH_FINAL)\n\t\tgoto hash_final;\n\n\twritel(op->mode | SS_ENABLED | SS_DATA_END, ss->base + SS_CTL);\n\ti = 0;\n\tdo {\n\t\tv = readl(ss->base + SS_CTL);\n\t\ti++;\n\t} while (i < SS_TIMEOUT && (v & SS_DATA_END));\n\tif (unlikely(i >= SS_TIMEOUT)) {\n\t\tdev_err_ratelimited(ss->dev,\n\t\t\t\t    \"ERROR: hash end timeout %d>%d ctl=%x len=%u\\n\",\n\t\t\t\t    i, SS_TIMEOUT, v, areq->nbytes);\n\t\terr = -EIO;\n\t\tgoto release_ss;\n\t}\n\n\t \n\tndelay(1);\n\n\tfor (i = 0; i < crypto_ahash_digestsize(tfm) / 4; i++)\n\t\top->hash[i] = readl(ss->base + SS_MD0 + i * 4);\n\n\tgoto release_ss;\n\n \n\nhash_final:\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_SUN4I_SS_DEBUG)) {\n\t\talgt = container_of(alg, struct sun4i_ss_alg_template, alg.hash);\n\t\talgt->stat_req++;\n\t}\n\n\t \n\tif (op->len) {\n\t\tnwait = op->len / 4;\n\t\tif (nwait) {\n\t\t\twritesl(ss->base + SS_RXFIFO, op->buf, nwait);\n\t\t\top->byte_count += 4 * nwait;\n\t\t}\n\n\t\tnbw = op->len - 4 * nwait;\n\t\tif (nbw) {\n\t\t\twb = le32_to_cpup((__le32 *)(op->buf + nwait * 4));\n\t\t\twb &= GENMASK((nbw * 8) - 1, 0);\n\n\t\t\top->byte_count += nbw;\n\t\t}\n\t}\n\n\t \n\twb |= ((1 << 7) << (nbw * 8));\n\t((__le32 *)bf)[j++] = cpu_to_le32(wb);\n\n\t \n\n\t \n\tfill = 64 - (op->byte_count % 64);\n\tmin_fill = 2 * sizeof(u32) + (nbw ? 0 : sizeof(u32));\n\n\t \n\tif (fill < min_fill)\n\t\tfill += 64;\n\n\tj += (fill - min_fill) / sizeof(u32);\n\n\t \n\tif (op->mode == SS_OP_SHA1) {\n\t\t__be64 *bits = (__be64 *)&bf[j];\n\t\t*bits = cpu_to_be64(op->byte_count << 3);\n\t\tj += 2;\n\t} else {\n\t\t__le64 *bits = (__le64 *)&bf[j];\n\t\t*bits = cpu_to_le64(op->byte_count << 3);\n\t\tj += 2;\n\t}\n\twritesl(ss->base + SS_RXFIFO, bf, j);\n\n\t \n\twritel(op->mode | SS_ENABLED | SS_DATA_END, ss->base + SS_CTL);\n\n\t \n\ti = 0;\n\tdo {\n\t\tv = readl(ss->base + SS_CTL);\n\t\ti++;\n\t} while (i < SS_TIMEOUT && (v & SS_DATA_END));\n\tif (unlikely(i >= SS_TIMEOUT)) {\n\t\tdev_err_ratelimited(ss->dev,\n\t\t\t\t    \"ERROR: hash end timeout %d>%d ctl=%x len=%u\\n\",\n\t\t\t\t    i, SS_TIMEOUT, v, areq->nbytes);\n\t\terr = -EIO;\n\t\tgoto release_ss;\n\t}\n\n\t \n\tndelay(1);\n\n\t \n\tif (op->mode == SS_OP_SHA1) {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tv = readl(ss->base + SS_MD0 + i * 4);\n\t\t\tif (ss->variant->sha1_in_be)\n\t\t\t\tput_unaligned_le32(v, areq->result + i * 4);\n\t\t\telse\n\t\t\t\tput_unaligned_be32(v, areq->result + i * 4);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tv = readl(ss->base + SS_MD0 + i * 4);\n\t\t\tput_unaligned_le32(v, areq->result + i * 4);\n\t\t}\n\t}\n\nrelease_ss:\n\twritel(0, ss->base + SS_CTL);\n\tspin_unlock_bh(&ss->slock);\n\treturn err;\n}\n\nint sun4i_hash_final(struct ahash_request *areq)\n{\n\tstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\n\n\top->flags = SS_HASH_FINAL;\n\treturn sun4i_hash(areq);\n}\n\nint sun4i_hash_update(struct ahash_request *areq)\n{\n\tstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\n\n\top->flags = SS_HASH_UPDATE;\n\treturn sun4i_hash(areq);\n}\n\n \nint sun4i_hash_finup(struct ahash_request *areq)\n{\n\tstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\n\n\top->flags = SS_HASH_UPDATE | SS_HASH_FINAL;\n\treturn sun4i_hash(areq);\n}\n\n \nint sun4i_hash_digest(struct ahash_request *areq)\n{\n\tint err;\n\tstruct sun4i_req_ctx *op = ahash_request_ctx(areq);\n\n\terr = sun4i_hash_init(areq);\n\tif (err)\n\t\treturn err;\n\n\top->flags = SS_HASH_UPDATE | SS_HASH_FINAL;\n\treturn sun4i_hash(areq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}