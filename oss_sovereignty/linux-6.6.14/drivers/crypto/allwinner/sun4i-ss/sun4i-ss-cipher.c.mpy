{
  "module_name": "sun4i-ss-cipher.c",
  "hash_id": "cf30fa87f9fcaf4b0c9219919175ef82335c825590c20d09b2d64b823eced7ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/allwinner/sun4i-ss/sun4i-ss-cipher.c",
  "human_readable_source": "\n \n#include \"sun4i-ss.h\"\n\nstatic int noinline_for_stack sun4i_ss_opti_poll(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_ss_ctx *ss = op->ss;\n\tunsigned int ivsize = crypto_skcipher_ivsize(tfm);\n\tstruct sun4i_cipher_req_ctx *ctx = skcipher_request_ctx(areq);\n\tu32 mode = ctx->mode;\n\t \n\tu32 rx_cnt = SS_RX_DEFAULT;\n\tu32 tx_cnt = 0;\n\tu32 spaces;\n\tu32 v;\n\tint err = 0;\n\tunsigned int i;\n\tunsigned int ileft = areq->cryptlen;\n\tunsigned int oleft = areq->cryptlen;\n\tunsigned int todo;\n\tunsigned long pi = 0, po = 0;  \n\tbool miter_err;\n\tstruct sg_mapping_iter mi, mo;\n\tunsigned int oi, oo;  \n\tunsigned long flags;\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(tfm);\n\tstruct sun4i_ss_alg_template *algt;\n\n\tif (!areq->cryptlen)\n\t\treturn 0;\n\n\tif (!areq->src || !areq->dst) {\n\t\tdev_err_ratelimited(ss->dev, \"ERROR: Some SGs are NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (areq->iv && ivsize > 0 && mode & SS_DECRYPTION) {\n\t\tscatterwalk_map_and_copy(ctx->backup_iv, areq->src,\n\t\t\t\t\t areq->cryptlen - ivsize, ivsize, 0);\n\t}\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_SUN4I_SS_DEBUG)) {\n\t\talgt = container_of(alg, struct sun4i_ss_alg_template, alg.crypto);\n\t\talgt->stat_opti++;\n\t\talgt->stat_bytes += areq->cryptlen;\n\t}\n\n\tspin_lock_irqsave(&ss->slock, flags);\n\n\tfor (i = 0; i < op->keylen / 4; i++)\n\t\twritesl(ss->base + SS_KEY0 + i * 4, &op->key[i], 1);\n\n\tif (areq->iv) {\n\t\tfor (i = 0; i < 4 && i < ivsize / 4; i++) {\n\t\t\tv = *(u32 *)(areq->iv + i * 4);\n\t\t\twritesl(ss->base + SS_IV0 + i * 4, &v, 1);\n\t\t}\n\t}\n\twritel(mode, ss->base + SS_CTL);\n\n\n\tileft = areq->cryptlen / 4;\n\toleft = areq->cryptlen / 4;\n\toi = 0;\n\too = 0;\n\tdo {\n\t\tif (ileft) {\n\t\t\tsg_miter_start(&mi, areq->src, sg_nents(areq->src),\n\t\t\t\t\tSG_MITER_FROM_SG | SG_MITER_ATOMIC);\n\t\t\tif (pi)\n\t\t\t\tsg_miter_skip(&mi, pi);\n\t\t\tmiter_err = sg_miter_next(&mi);\n\t\t\tif (!miter_err || !mi.addr) {\n\t\t\t\tdev_err_ratelimited(ss->dev, \"ERROR: sg_miter return null\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto release_ss;\n\t\t\t}\n\t\t\ttodo = min(rx_cnt, ileft);\n\t\t\ttodo = min_t(size_t, todo, (mi.length - oi) / 4);\n\t\t\tif (todo) {\n\t\t\t\tileft -= todo;\n\t\t\t\twritesl(ss->base + SS_RXFIFO, mi.addr + oi, todo);\n\t\t\t\toi += todo * 4;\n\t\t\t}\n\t\t\tif (oi == mi.length) {\n\t\t\t\tpi += mi.length;\n\t\t\t\toi = 0;\n\t\t\t}\n\t\t\tsg_miter_stop(&mi);\n\t\t}\n\n\t\tspaces = readl(ss->base + SS_FCSR);\n\t\trx_cnt = SS_RXFIFO_SPACES(spaces);\n\t\ttx_cnt = SS_TXFIFO_SPACES(spaces);\n\n\t\tsg_miter_start(&mo, areq->dst, sg_nents(areq->dst),\n\t\t\t       SG_MITER_TO_SG | SG_MITER_ATOMIC);\n\t\tif (po)\n\t\t\tsg_miter_skip(&mo, po);\n\t\tmiter_err = sg_miter_next(&mo);\n\t\tif (!miter_err || !mo.addr) {\n\t\t\tdev_err_ratelimited(ss->dev, \"ERROR: sg_miter return null\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto release_ss;\n\t\t}\n\t\ttodo = min(tx_cnt, oleft);\n\t\ttodo = min_t(size_t, todo, (mo.length - oo) / 4);\n\t\tif (todo) {\n\t\t\toleft -= todo;\n\t\t\treadsl(ss->base + SS_TXFIFO, mo.addr + oo, todo);\n\t\t\too += todo * 4;\n\t\t}\n\t\tif (oo == mo.length) {\n\t\t\too = 0;\n\t\t\tpo += mo.length;\n\t\t}\n\t\tsg_miter_stop(&mo);\n\t} while (oleft);\n\n\tif (areq->iv) {\n\t\tif (mode & SS_DECRYPTION) {\n\t\t\tmemcpy(areq->iv, ctx->backup_iv, ivsize);\n\t\t\tmemzero_explicit(ctx->backup_iv, ivsize);\n\t\t} else {\n\t\t\tscatterwalk_map_and_copy(areq->iv, areq->dst, areq->cryptlen - ivsize,\n\t\t\t\t\t\t ivsize, 0);\n\t\t}\n\t}\n\nrelease_ss:\n\twritel(0, ss->base + SS_CTL);\n\tspin_unlock_irqrestore(&ss->slock, flags);\n\treturn err;\n}\n\nstatic int noinline_for_stack sun4i_ss_cipher_poll_fallback(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_cipher_req_ctx *ctx = skcipher_request_ctx(areq);\n\tint err;\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(tfm);\n\tstruct sun4i_ss_alg_template *algt;\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_SUN4I_SS_DEBUG)) {\n\t\talgt = container_of(alg, struct sun4i_ss_alg_template, alg.crypto);\n\t\talgt->stat_fb++;\n\t}\n\n\tskcipher_request_set_tfm(&ctx->fallback_req, op->fallback_tfm);\n\tskcipher_request_set_callback(&ctx->fallback_req, areq->base.flags,\n\t\t\t\t      areq->base.complete, areq->base.data);\n\tskcipher_request_set_crypt(&ctx->fallback_req, areq->src, areq->dst,\n\t\t\t\t   areq->cryptlen, areq->iv);\n\tif (ctx->mode & SS_DECRYPTION)\n\t\terr = crypto_skcipher_decrypt(&ctx->fallback_req);\n\telse\n\t\terr = crypto_skcipher_encrypt(&ctx->fallback_req);\n\n\treturn err;\n}\n\n \nstatic int sun4i_ss_cipher_poll(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_ss_ctx *ss = op->ss;\n\tint no_chunk = 1;\n\tstruct scatterlist *in_sg = areq->src;\n\tstruct scatterlist *out_sg = areq->dst;\n\tunsigned int ivsize = crypto_skcipher_ivsize(tfm);\n\tstruct sun4i_cipher_req_ctx *ctx = skcipher_request_ctx(areq);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(tfm);\n\tstruct sun4i_ss_alg_template *algt;\n\tu32 mode = ctx->mode;\n\t \n\tu32 rx_cnt = SS_RX_DEFAULT;\n\tu32 tx_cnt = 0;\n\tu32 v;\n\tu32 spaces;\n\tint err = 0;\n\tunsigned int i;\n\tunsigned int ileft = areq->cryptlen;\n\tunsigned int oleft = areq->cryptlen;\n\tunsigned int todo;\n\tstruct sg_mapping_iter mi, mo;\n\tunsigned long pi = 0, po = 0;  \n\tbool miter_err;\n\tunsigned int oi, oo;\t \n\tunsigned int ob = 0;\t \n\tunsigned int obo = 0;\t \n\tunsigned int obl = 0;\t \n\tunsigned long flags;\n\tbool need_fallback = false;\n\n\tif (!areq->cryptlen)\n\t\treturn 0;\n\n\tif (!areq->src || !areq->dst) {\n\t\tdev_err_ratelimited(ss->dev, \"ERROR: Some SGs are NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\talgt = container_of(alg, struct sun4i_ss_alg_template, alg.crypto);\n\tif (areq->cryptlen % algt->alg.crypto.base.cra_blocksize)\n\t\tneed_fallback = true;\n\n\t \n\twhile (in_sg && no_chunk == 1) {\n\t\tif ((in_sg->length | in_sg->offset) & 3u)\n\t\t\tno_chunk = 0;\n\t\tin_sg = sg_next(in_sg);\n\t}\n\twhile (out_sg && no_chunk == 1) {\n\t\tif ((out_sg->length | out_sg->offset) & 3u)\n\t\t\tno_chunk = 0;\n\t\tout_sg = sg_next(out_sg);\n\t}\n\n\tif (no_chunk == 1 && !need_fallback)\n\t\treturn sun4i_ss_opti_poll(areq);\n\n\tif (need_fallback)\n\t\treturn sun4i_ss_cipher_poll_fallback(areq);\n\n\tif (areq->iv && ivsize > 0 && mode & SS_DECRYPTION) {\n\t\tscatterwalk_map_and_copy(ctx->backup_iv, areq->src,\n\t\t\t\t\t areq->cryptlen - ivsize, ivsize, 0);\n\t}\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_SUN4I_SS_DEBUG)) {\n\t\talgt->stat_req++;\n\t\talgt->stat_bytes += areq->cryptlen;\n\t}\n\n\tspin_lock_irqsave(&ss->slock, flags);\n\n\tfor (i = 0; i < op->keylen / 4; i++)\n\t\twritesl(ss->base + SS_KEY0 + i * 4, &op->key[i], 1);\n\n\tif (areq->iv) {\n\t\tfor (i = 0; i < 4 && i < ivsize / 4; i++) {\n\t\t\tv = *(u32 *)(areq->iv + i * 4);\n\t\t\twritesl(ss->base + SS_IV0 + i * 4, &v, 1);\n\t\t}\n\t}\n\twritel(mode, ss->base + SS_CTL);\n\n\tileft = areq->cryptlen;\n\toleft = areq->cryptlen;\n\toi = 0;\n\too = 0;\n\n\twhile (oleft) {\n\t\tif (ileft) {\n\t\t\tsg_miter_start(&mi, areq->src, sg_nents(areq->src),\n\t\t\t\t       SG_MITER_FROM_SG | SG_MITER_ATOMIC);\n\t\t\tif (pi)\n\t\t\t\tsg_miter_skip(&mi, pi);\n\t\t\tmiter_err = sg_miter_next(&mi);\n\t\t\tif (!miter_err || !mi.addr) {\n\t\t\t\tdev_err_ratelimited(ss->dev, \"ERROR: sg_miter return null\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto release_ss;\n\t\t\t}\n\t\t\t \n\t\t\ttodo = min(rx_cnt, ileft / 4);\n\t\t\ttodo = min_t(size_t, todo, (mi.length - oi) / 4);\n\t\t\tif (todo && !ob) {\n\t\t\t\twritesl(ss->base + SS_RXFIFO, mi.addr + oi,\n\t\t\t\t\ttodo);\n\t\t\t\tileft -= todo * 4;\n\t\t\t\toi += todo * 4;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttodo = min(rx_cnt * 4 - ob, ileft);\n\t\t\t\ttodo = min_t(size_t, todo, mi.length - oi);\n\t\t\t\tmemcpy(ss->buf + ob, mi.addr + oi, todo);\n\t\t\t\tileft -= todo;\n\t\t\t\toi += todo;\n\t\t\t\tob += todo;\n\t\t\t\tif (!(ob % 4)) {\n\t\t\t\t\twritesl(ss->base + SS_RXFIFO, ss->buf,\n\t\t\t\t\t\tob / 4);\n\t\t\t\t\tob = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (oi == mi.length) {\n\t\t\t\tpi += mi.length;\n\t\t\t\toi = 0;\n\t\t\t}\n\t\t\tsg_miter_stop(&mi);\n\t\t}\n\n\t\tspaces = readl(ss->base + SS_FCSR);\n\t\trx_cnt = SS_RXFIFO_SPACES(spaces);\n\t\ttx_cnt = SS_TXFIFO_SPACES(spaces);\n\n\t\tif (!tx_cnt)\n\t\t\tcontinue;\n\t\tsg_miter_start(&mo, areq->dst, sg_nents(areq->dst),\n\t\t\t       SG_MITER_TO_SG | SG_MITER_ATOMIC);\n\t\tif (po)\n\t\t\tsg_miter_skip(&mo, po);\n\t\tmiter_err = sg_miter_next(&mo);\n\t\tif (!miter_err || !mo.addr) {\n\t\t\tdev_err_ratelimited(ss->dev, \"ERROR: sg_miter return null\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto release_ss;\n\t\t}\n\t\t \n\t\ttodo = min(tx_cnt, oleft / 4);\n\t\ttodo = min_t(size_t, todo, (mo.length - oo) / 4);\n\n\t\tif (todo) {\n\t\t\treadsl(ss->base + SS_TXFIFO, mo.addr + oo, todo);\n\t\t\toleft -= todo * 4;\n\t\t\too += todo * 4;\n\t\t\tif (oo == mo.length) {\n\t\t\t\tpo += mo.length;\n\t\t\t\too = 0;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\treadsl(ss->base + SS_TXFIFO, ss->bufo, tx_cnt);\n\t\t\tobl = tx_cnt * 4;\n\t\t\tobo = 0;\n\t\t\tdo {\n\t\t\t\t \n\t\t\t\ttodo = min_t(size_t,\n\t\t\t\t\t     mo.length - oo, obl - obo);\n\t\t\t\tmemcpy(mo.addr + oo, ss->bufo + obo, todo);\n\t\t\t\toleft -= todo;\n\t\t\t\tobo += todo;\n\t\t\t\too += todo;\n\t\t\t\tif (oo == mo.length) {\n\t\t\t\t\tpo += mo.length;\n\t\t\t\t\tsg_miter_next(&mo);\n\t\t\t\t\too = 0;\n\t\t\t\t}\n\t\t\t} while (obo < obl);\n\t\t\t \n\t\t}\n\t\tsg_miter_stop(&mo);\n\t}\n\tif (areq->iv) {\n\t\tif (mode & SS_DECRYPTION) {\n\t\t\tmemcpy(areq->iv, ctx->backup_iv, ivsize);\n\t\t\tmemzero_explicit(ctx->backup_iv, ivsize);\n\t\t} else {\n\t\t\tscatterwalk_map_and_copy(areq->iv, areq->dst, areq->cryptlen - ivsize,\n\t\t\t\t\t\t ivsize, 0);\n\t\t}\n\t}\n\nrelease_ss:\n\twritel(0, ss->base + SS_CTL);\n\tspin_unlock_irqrestore(&ss->slock, flags);\n\n\treturn err;\n}\n\n \nint sun4i_ss_cbc_aes_encrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_cipher_req_ctx *rctx = skcipher_request_ctx(areq);\n\n\trctx->mode = SS_OP_AES | SS_CBC | SS_ENABLED | SS_ENCRYPTION |\n\t\top->keymode;\n\treturn sun4i_ss_cipher_poll(areq);\n}\n\nint sun4i_ss_cbc_aes_decrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_cipher_req_ctx *rctx = skcipher_request_ctx(areq);\n\n\trctx->mode = SS_OP_AES | SS_CBC | SS_ENABLED | SS_DECRYPTION |\n\t\top->keymode;\n\treturn sun4i_ss_cipher_poll(areq);\n}\n\n \nint sun4i_ss_ecb_aes_encrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_cipher_req_ctx *rctx = skcipher_request_ctx(areq);\n\n\trctx->mode = SS_OP_AES | SS_ECB | SS_ENABLED | SS_ENCRYPTION |\n\t\top->keymode;\n\treturn sun4i_ss_cipher_poll(areq);\n}\n\nint sun4i_ss_ecb_aes_decrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_cipher_req_ctx *rctx = skcipher_request_ctx(areq);\n\n\trctx->mode = SS_OP_AES | SS_ECB | SS_ENABLED | SS_DECRYPTION |\n\t\top->keymode;\n\treturn sun4i_ss_cipher_poll(areq);\n}\n\n \nint sun4i_ss_cbc_des_encrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_cipher_req_ctx *rctx = skcipher_request_ctx(areq);\n\n\trctx->mode = SS_OP_DES | SS_CBC | SS_ENABLED | SS_ENCRYPTION |\n\t\top->keymode;\n\treturn sun4i_ss_cipher_poll(areq);\n}\n\nint sun4i_ss_cbc_des_decrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_cipher_req_ctx *rctx = skcipher_request_ctx(areq);\n\n\trctx->mode = SS_OP_DES | SS_CBC | SS_ENABLED | SS_DECRYPTION |\n\t\top->keymode;\n\treturn sun4i_ss_cipher_poll(areq);\n}\n\n \nint sun4i_ss_ecb_des_encrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_cipher_req_ctx *rctx = skcipher_request_ctx(areq);\n\n\trctx->mode = SS_OP_DES | SS_ECB | SS_ENABLED | SS_ENCRYPTION |\n\t\top->keymode;\n\treturn sun4i_ss_cipher_poll(areq);\n}\n\nint sun4i_ss_ecb_des_decrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_cipher_req_ctx *rctx = skcipher_request_ctx(areq);\n\n\trctx->mode = SS_OP_DES | SS_ECB | SS_ENABLED | SS_DECRYPTION |\n\t\top->keymode;\n\treturn sun4i_ss_cipher_poll(areq);\n}\n\n \nint sun4i_ss_cbc_des3_encrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_cipher_req_ctx *rctx = skcipher_request_ctx(areq);\n\n\trctx->mode = SS_OP_3DES | SS_CBC | SS_ENABLED | SS_ENCRYPTION |\n\t\top->keymode;\n\treturn sun4i_ss_cipher_poll(areq);\n}\n\nint sun4i_ss_cbc_des3_decrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_cipher_req_ctx *rctx = skcipher_request_ctx(areq);\n\n\trctx->mode = SS_OP_3DES | SS_CBC | SS_ENABLED | SS_DECRYPTION |\n\t\top->keymode;\n\treturn sun4i_ss_cipher_poll(areq);\n}\n\n \nint sun4i_ss_ecb_des3_encrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_cipher_req_ctx *rctx = skcipher_request_ctx(areq);\n\n\trctx->mode = SS_OP_3DES | SS_ECB | SS_ENABLED | SS_ENCRYPTION |\n\t\top->keymode;\n\treturn sun4i_ss_cipher_poll(areq);\n}\n\nint sun4i_ss_ecb_des3_decrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(areq);\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_cipher_req_ctx *rctx = skcipher_request_ctx(areq);\n\n\trctx->mode = SS_OP_3DES | SS_ECB | SS_ENABLED | SS_DECRYPTION |\n\t\top->keymode;\n\treturn sun4i_ss_cipher_poll(areq);\n}\n\nint sun4i_ss_cipher_init(struct crypto_tfm *tfm)\n{\n\tstruct sun4i_tfm_ctx *op = crypto_tfm_ctx(tfm);\n\tstruct sun4i_ss_alg_template *algt;\n\tconst char *name = crypto_tfm_alg_name(tfm);\n\tint err;\n\n\tmemset(op, 0, sizeof(struct sun4i_tfm_ctx));\n\n\talgt = container_of(tfm->__crt_alg, struct sun4i_ss_alg_template,\n\t\t\t    alg.crypto.base);\n\top->ss = algt->ss;\n\n\top->fallback_tfm = crypto_alloc_skcipher(name, 0, CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(op->fallback_tfm)) {\n\t\tdev_err(op->ss->dev, \"ERROR: Cannot allocate fallback for %s %ld\\n\",\n\t\t\tname, PTR_ERR(op->fallback_tfm));\n\t\treturn PTR_ERR(op->fallback_tfm);\n\t}\n\n\tcrypto_skcipher_set_reqsize(__crypto_skcipher_cast(tfm),\n\t\t\t\t    sizeof(struct sun4i_cipher_req_ctx) +\n\t\t\t\t    crypto_skcipher_reqsize(op->fallback_tfm));\n\n\terr = pm_runtime_resume_and_get(op->ss->dev);\n\tif (err < 0)\n\t\tgoto error_pm;\n\n\treturn 0;\nerror_pm:\n\tcrypto_free_skcipher(op->fallback_tfm);\n\treturn err;\n}\n\nvoid sun4i_ss_cipher_exit(struct crypto_tfm *tfm)\n{\n\tstruct sun4i_tfm_ctx *op = crypto_tfm_ctx(tfm);\n\n\tcrypto_free_skcipher(op->fallback_tfm);\n\tpm_runtime_put(op->ss->dev);\n}\n\n \nint sun4i_ss_aes_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\tunsigned int keylen)\n{\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tstruct sun4i_ss_ctx *ss = op->ss;\n\n\tswitch (keylen) {\n\tcase 128 / 8:\n\t\top->keymode = SS_AES_128BITS;\n\t\tbreak;\n\tcase 192 / 8:\n\t\top->keymode = SS_AES_192BITS;\n\t\tbreak;\n\tcase 256 / 8:\n\t\top->keymode = SS_AES_256BITS;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(ss->dev, \"ERROR: Invalid keylen %u\\n\", keylen);\n\t\treturn -EINVAL;\n\t}\n\top->keylen = keylen;\n\tmemcpy(op->key, key, keylen);\n\n\tcrypto_skcipher_clear_flags(op->fallback_tfm, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(op->fallback_tfm, tfm->base.crt_flags & CRYPTO_TFM_REQ_MASK);\n\n\treturn crypto_skcipher_setkey(op->fallback_tfm, key, keylen);\n}\n\n \nint sun4i_ss_des_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\tunsigned int keylen)\n{\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tint err;\n\n\terr = verify_skcipher_des_key(tfm, key);\n\tif (err)\n\t\treturn err;\n\n\top->keylen = keylen;\n\tmemcpy(op->key, key, keylen);\n\n\tcrypto_skcipher_clear_flags(op->fallback_tfm, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(op->fallback_tfm, tfm->base.crt_flags & CRYPTO_TFM_REQ_MASK);\n\n\treturn crypto_skcipher_setkey(op->fallback_tfm, key, keylen);\n}\n\n \nint sun4i_ss_des3_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t unsigned int keylen)\n{\n\tstruct sun4i_tfm_ctx *op = crypto_skcipher_ctx(tfm);\n\tint err;\n\n\terr = verify_skcipher_des3_key(tfm, key);\n\tif (err)\n\t\treturn err;\n\n\top->keylen = keylen;\n\tmemcpy(op->key, key, keylen);\n\n\tcrypto_skcipher_clear_flags(op->fallback_tfm, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(op->fallback_tfm, tfm->base.crt_flags & CRYPTO_TFM_REQ_MASK);\n\n\treturn crypto_skcipher_setkey(op->fallback_tfm, key, keylen);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}