{
  "module_name": "sun4i-ss-core.c",
  "hash_id": "8503e6ce501731e8897d14e433542d3e4d95485f55509cb6912363b5156b9e83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/allwinner/sun4i-ss/sun4i-ss-core.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/crypto.h>\n#include <linux/debugfs.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <crypto/scatterwalk.h>\n#include <linux/scatterlist.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/reset.h>\n\n#include \"sun4i-ss.h\"\n\nstatic const struct ss_variant ss_a10_variant = {\n\t.sha1_in_be = false,\n};\n\nstatic const struct ss_variant ss_a33_variant = {\n\t.sha1_in_be = true,\n};\n\nstatic struct sun4i_ss_alg_template ss_algs[] = {\n{       .type = CRYPTO_ALG_TYPE_AHASH,\n\t.mode = SS_OP_MD5,\n\t.alg.hash = {\n\t\t.init = sun4i_hash_init,\n\t\t.update = sun4i_hash_update,\n\t\t.final = sun4i_hash_final,\n\t\t.finup = sun4i_hash_finup,\n\t\t.digest = sun4i_hash_digest,\n\t\t.export = sun4i_hash_export_md5,\n\t\t.import = sun4i_hash_import_md5,\n\t\t.halg = {\n\t\t\t.digestsize = MD5_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct md5_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"md5\",\n\t\t\t\t.cra_driver_name = \"md5-sun4i-ss\",\n\t\t\t\t.cra_priority = 300,\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_blocksize = MD5_HMAC_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct sun4i_req_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t\t.cra_init = sun4i_hash_crainit,\n\t\t\t\t.cra_exit = sun4i_hash_craexit,\n\t\t\t}\n\t\t}\n\t}\n},\n{       .type = CRYPTO_ALG_TYPE_AHASH,\n\t.mode = SS_OP_SHA1,\n\t.alg.hash = {\n\t\t.init = sun4i_hash_init,\n\t\t.update = sun4i_hash_update,\n\t\t.final = sun4i_hash_final,\n\t\t.finup = sun4i_hash_finup,\n\t\t.digest = sun4i_hash_digest,\n\t\t.export = sun4i_hash_export_sha1,\n\t\t.import = sun4i_hash_import_sha1,\n\t\t.halg = {\n\t\t\t.digestsize = SHA1_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct sha1_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha1\",\n\t\t\t\t.cra_driver_name = \"sha1-sun4i-ss\",\n\t\t\t\t.cra_priority = 300,\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_blocksize = SHA1_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct sun4i_req_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t\t.cra_init = sun4i_hash_crainit,\n\t\t\t\t.cra_exit = sun4i_hash_craexit,\n\t\t\t}\n\t\t}\n\t}\n},\n{       .type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.alg.crypto = {\n\t\t.setkey         = sun4i_ss_aes_setkey,\n\t\t.encrypt        = sun4i_ss_cbc_aes_encrypt,\n\t\t.decrypt        = sun4i_ss_cbc_aes_decrypt,\n\t\t.min_keysize\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"cbc(aes)\",\n\t\t\t.cra_driver_name = \"cbc-aes-sun4i-ss\",\n\t\t\t.cra_priority = 300,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_KERN_DRIVER_ONLY | CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun4i_tfm_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 3,\n\t\t\t.cra_init = sun4i_ss_cipher_init,\n\t\t\t.cra_exit = sun4i_ss_cipher_exit,\n\t\t}\n\t}\n},\n{       .type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.alg.crypto = {\n\t\t.setkey         = sun4i_ss_aes_setkey,\n\t\t.encrypt        = sun4i_ss_ecb_aes_encrypt,\n\t\t.decrypt        = sun4i_ss_ecb_aes_decrypt,\n\t\t.min_keysize\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t= AES_MAX_KEY_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(aes)\",\n\t\t\t.cra_driver_name = \"ecb-aes-sun4i-ss\",\n\t\t\t.cra_priority = 300,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_KERN_DRIVER_ONLY | CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun4i_tfm_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 3,\n\t\t\t.cra_init = sun4i_ss_cipher_init,\n\t\t\t.cra_exit = sun4i_ss_cipher_exit,\n\t\t}\n\t}\n},\n{       .type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.alg.crypto = {\n\t\t.setkey         = sun4i_ss_des_setkey,\n\t\t.encrypt        = sun4i_ss_cbc_des_encrypt,\n\t\t.decrypt        = sun4i_ss_cbc_des_decrypt,\n\t\t.min_keysize    = DES_KEY_SIZE,\n\t\t.max_keysize    = DES_KEY_SIZE,\n\t\t.ivsize         = DES_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"cbc(des)\",\n\t\t\t.cra_driver_name = \"cbc-des-sun4i-ss\",\n\t\t\t.cra_priority = 300,\n\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_KERN_DRIVER_ONLY | CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun4i_req_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 3,\n\t\t\t.cra_init = sun4i_ss_cipher_init,\n\t\t\t.cra_exit = sun4i_ss_cipher_exit,\n\t\t}\n\t}\n},\n{       .type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.alg.crypto = {\n\t\t.setkey         = sun4i_ss_des_setkey,\n\t\t.encrypt        = sun4i_ss_ecb_des_encrypt,\n\t\t.decrypt        = sun4i_ss_ecb_des_decrypt,\n\t\t.min_keysize    = DES_KEY_SIZE,\n\t\t.max_keysize    = DES_KEY_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(des)\",\n\t\t\t.cra_driver_name = \"ecb-des-sun4i-ss\",\n\t\t\t.cra_priority = 300,\n\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_KERN_DRIVER_ONLY | CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun4i_req_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 3,\n\t\t\t.cra_init = sun4i_ss_cipher_init,\n\t\t\t.cra_exit = sun4i_ss_cipher_exit,\n\t\t}\n\t}\n},\n{       .type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.alg.crypto = {\n\t\t.setkey         = sun4i_ss_des3_setkey,\n\t\t.encrypt        = sun4i_ss_cbc_des3_encrypt,\n\t\t.decrypt        = sun4i_ss_cbc_des3_decrypt,\n\t\t.min_keysize    = DES3_EDE_KEY_SIZE,\n\t\t.max_keysize    = DES3_EDE_KEY_SIZE,\n\t\t.ivsize         = DES3_EDE_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"cbc(des3_ede)\",\n\t\t\t.cra_driver_name = \"cbc-des3-sun4i-ss\",\n\t\t\t.cra_priority = 300,\n\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_KERN_DRIVER_ONLY | CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun4i_req_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 3,\n\t\t\t.cra_init = sun4i_ss_cipher_init,\n\t\t\t.cra_exit = sun4i_ss_cipher_exit,\n\t\t}\n\t}\n},\n{       .type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.alg.crypto = {\n\t\t.setkey         = sun4i_ss_des3_setkey,\n\t\t.encrypt        = sun4i_ss_ecb_des3_encrypt,\n\t\t.decrypt        = sun4i_ss_ecb_des3_decrypt,\n\t\t.min_keysize    = DES3_EDE_KEY_SIZE,\n\t\t.max_keysize    = DES3_EDE_KEY_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(des3_ede)\",\n\t\t\t.cra_driver_name = \"ecb-des3-sun4i-ss\",\n\t\t\t.cra_priority = 300,\n\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_KERN_DRIVER_ONLY | CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sun4i_req_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 3,\n\t\t\t.cra_init = sun4i_ss_cipher_init,\n\t\t\t.cra_exit = sun4i_ss_cipher_exit,\n\t\t}\n\t}\n},\n#ifdef CONFIG_CRYPTO_DEV_SUN4I_SS_PRNG\n{\n\t.type = CRYPTO_ALG_TYPE_RNG,\n\t.alg.rng = {\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"stdrng\",\n\t\t\t.cra_driver_name\t= \"sun4i_ss_rng\",\n\t\t\t.cra_priority\t\t= 300,\n\t\t\t.cra_ctxsize\t\t= 0,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t},\n\t\t.generate               = sun4i_ss_prng_generate,\n\t\t.seed                   = sun4i_ss_prng_seed,\n\t\t.seedsize               = SS_SEED_LEN / BITS_PER_BYTE,\n\t}\n},\n#endif\n};\n\nstatic int sun4i_ss_debugfs_show(struct seq_file *seq, void *v)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ss_algs); i++) {\n\t\tif (!ss_algs[i].ss)\n\t\t\tcontinue;\n\t\tswitch (ss_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tseq_printf(seq, \"%s %s reqs=%lu opti=%lu fallback=%lu tsize=%lu\\n\",\n\t\t\t\t   ss_algs[i].alg.crypto.base.cra_driver_name,\n\t\t\t\t   ss_algs[i].alg.crypto.base.cra_name,\n\t\t\t\t   ss_algs[i].stat_req, ss_algs[i].stat_opti, ss_algs[i].stat_fb,\n\t\t\t\t   ss_algs[i].stat_bytes);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_RNG:\n\t\t\tseq_printf(seq, \"%s %s reqs=%lu tsize=%lu\\n\",\n\t\t\t\t   ss_algs[i].alg.rng.base.cra_driver_name,\n\t\t\t\t   ss_algs[i].alg.rng.base.cra_name,\n\t\t\t\t   ss_algs[i].stat_req, ss_algs[i].stat_bytes);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\tseq_printf(seq, \"%s %s reqs=%lu\\n\",\n\t\t\t\t   ss_algs[i].alg.hash.halg.base.cra_driver_name,\n\t\t\t\t   ss_algs[i].alg.hash.halg.base.cra_name,\n\t\t\t\t   ss_algs[i].stat_req);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(sun4i_ss_debugfs);\n\n \nstatic int sun4i_ss_pm_suspend(struct device *dev)\n{\n\tstruct sun4i_ss_ctx *ss = dev_get_drvdata(dev);\n\n\treset_control_assert(ss->reset);\n\n\tclk_disable_unprepare(ss->ssclk);\n\tclk_disable_unprepare(ss->busclk);\n\treturn 0;\n}\n\nstatic int sun4i_ss_pm_resume(struct device *dev)\n{\n\tstruct sun4i_ss_ctx *ss = dev_get_drvdata(dev);\n\n\tint err;\n\n\terr = clk_prepare_enable(ss->busclk);\n\tif (err) {\n\t\tdev_err(ss->dev, \"Cannot prepare_enable busclk\\n\");\n\t\tgoto err_enable;\n\t}\n\n\terr = clk_prepare_enable(ss->ssclk);\n\tif (err) {\n\t\tdev_err(ss->dev, \"Cannot prepare_enable ssclk\\n\");\n\t\tgoto err_enable;\n\t}\n\n\terr = reset_control_deassert(ss->reset);\n\tif (err) {\n\t\tdev_err(ss->dev, \"Cannot deassert reset control\\n\");\n\t\tgoto err_enable;\n\t}\n\n\treturn err;\nerr_enable:\n\tsun4i_ss_pm_suspend(dev);\n\treturn err;\n}\n\nstatic const struct dev_pm_ops sun4i_ss_pm_ops = {\n\tSET_RUNTIME_PM_OPS(sun4i_ss_pm_suspend, sun4i_ss_pm_resume, NULL)\n};\n\n \nstatic int sun4i_ss_pm_init(struct sun4i_ss_ctx *ss)\n{\n\tint err;\n\n\tpm_runtime_use_autosuspend(ss->dev);\n\tpm_runtime_set_autosuspend_delay(ss->dev, 2000);\n\n\terr = pm_runtime_set_suspended(ss->dev);\n\tif (err)\n\t\treturn err;\n\tpm_runtime_enable(ss->dev);\n\treturn err;\n}\n\nstatic void sun4i_ss_pm_exit(struct sun4i_ss_ctx *ss)\n{\n\tpm_runtime_disable(ss->dev);\n}\n\nstatic int sun4i_ss_probe(struct platform_device *pdev)\n{\n\tu32 v;\n\tint err, i;\n\tunsigned long cr;\n\tconst unsigned long cr_ahb = 24 * 1000 * 1000;\n\tconst unsigned long cr_mod = 150 * 1000 * 1000;\n\tstruct sun4i_ss_ctx *ss;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tss = devm_kzalloc(&pdev->dev, sizeof(*ss), GFP_KERNEL);\n\tif (!ss)\n\t\treturn -ENOMEM;\n\n\tss->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ss->base)) {\n\t\tdev_err(&pdev->dev, \"Cannot request MMIO\\n\");\n\t\treturn PTR_ERR(ss->base);\n\t}\n\n\tss->variant = of_device_get_match_data(&pdev->dev);\n\tif (!ss->variant) {\n\t\tdev_err(&pdev->dev, \"Missing Security System variant\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tss->ssclk = devm_clk_get(&pdev->dev, \"mod\");\n\tif (IS_ERR(ss->ssclk)) {\n\t\terr = PTR_ERR(ss->ssclk);\n\t\tdev_err(&pdev->dev, \"Cannot get SS clock err=%d\\n\", err);\n\t\treturn err;\n\t}\n\tdev_dbg(&pdev->dev, \"clock ss acquired\\n\");\n\n\tss->busclk = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(ss->busclk)) {\n\t\terr = PTR_ERR(ss->busclk);\n\t\tdev_err(&pdev->dev, \"Cannot get AHB SS clock err=%d\\n\", err);\n\t\treturn err;\n\t}\n\tdev_dbg(&pdev->dev, \"clock ahb_ss acquired\\n\");\n\n\tss->reset = devm_reset_control_get_optional(&pdev->dev, \"ahb\");\n\tif (IS_ERR(ss->reset))\n\t\treturn PTR_ERR(ss->reset);\n\tif (!ss->reset)\n\t\tdev_info(&pdev->dev, \"no reset control found\\n\");\n\n\t \n\terr = clk_set_rate(ss->ssclk, cr_mod);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot set clock rate to ssclk\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tcr = clk_get_rate(ss->busclk);\n\tif (cr >= cr_ahb)\n\t\tdev_dbg(&pdev->dev, \"Clock bus %lu (%lu MHz) (must be >= %lu)\\n\",\n\t\t\tcr, cr / 1000000, cr_ahb);\n\telse\n\t\tdev_warn(&pdev->dev, \"Clock bus %lu (%lu MHz) (must be >= %lu)\\n\",\n\t\t\t cr, cr / 1000000, cr_ahb);\n\n\tcr = clk_get_rate(ss->ssclk);\n\tif (cr <= cr_mod)\n\t\tif (cr < cr_mod)\n\t\t\tdev_warn(&pdev->dev, \"Clock ss %lu (%lu MHz) (must be <= %lu)\\n\",\n\t\t\t\t cr, cr / 1000000, cr_mod);\n\t\telse\n\t\t\tdev_dbg(&pdev->dev, \"Clock ss %lu (%lu MHz) (must be <= %lu)\\n\",\n\t\t\t\tcr, cr / 1000000, cr_mod);\n\telse\n\t\tdev_warn(&pdev->dev, \"Clock ss is at %lu (%lu MHz) (must be <= %lu)\\n\",\n\t\t\t cr, cr / 1000000, cr_mod);\n\n\tss->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ss);\n\n\tspin_lock_init(&ss->slock);\n\n\terr = sun4i_ss_pm_init(ss);\n\tif (err)\n\t\treturn err;\n\n\t \n\n\terr = pm_runtime_resume_and_get(ss->dev);\n\tif (err < 0)\n\t\tgoto error_pm;\n\n\twritel(SS_ENABLED, ss->base + SS_CTL);\n\tv = readl(ss->base + SS_CTL);\n\tv >>= 16;\n\tv &= 0x07;\n\tdev_info(&pdev->dev, \"Die ID %d\\n\", v);\n\twritel(0, ss->base + SS_CTL);\n\n\tpm_runtime_put_sync(ss->dev);\n\n\tfor (i = 0; i < ARRAY_SIZE(ss_algs); i++) {\n\t\tss_algs[i].ss = ss;\n\t\tswitch (ss_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\terr = crypto_register_skcipher(&ss_algs[i].alg.crypto);\n\t\t\tif (err) {\n\t\t\t\tdev_err(ss->dev, \"Fail to register %s\\n\",\n\t\t\t\t\tss_algs[i].alg.crypto.base.cra_name);\n\t\t\t\tgoto error_alg;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\terr = crypto_register_ahash(&ss_algs[i].alg.hash);\n\t\t\tif (err) {\n\t\t\t\tdev_err(ss->dev, \"Fail to register %s\\n\",\n\t\t\t\t\tss_algs[i].alg.hash.halg.base.cra_name);\n\t\t\t\tgoto error_alg;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_RNG:\n\t\t\terr = crypto_register_rng(&ss_algs[i].alg.rng);\n\t\t\tif (err) {\n\t\t\t\tdev_err(ss->dev, \"Fail to register %s\\n\",\n\t\t\t\t\tss_algs[i].alg.rng.base.cra_name);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tss->dbgfs_dir = debugfs_create_dir(\"sun4i-ss\", NULL);\n\tss->dbgfs_stats = debugfs_create_file(\"stats\", 0444, ss->dbgfs_dir, ss,\n\t\t\t\t\t      &sun4i_ss_debugfs_fops);\n\n\treturn 0;\nerror_alg:\n\ti--;\n\tfor (; i >= 0; i--) {\n\t\tswitch (ss_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tcrypto_unregister_skcipher(&ss_algs[i].alg.crypto);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\tcrypto_unregister_ahash(&ss_algs[i].alg.hash);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_RNG:\n\t\t\tcrypto_unregister_rng(&ss_algs[i].alg.rng);\n\t\t\tbreak;\n\t\t}\n\t}\nerror_pm:\n\tsun4i_ss_pm_exit(ss);\n\treturn err;\n}\n\nstatic int sun4i_ss_remove(struct platform_device *pdev)\n{\n\tint i;\n\tstruct sun4i_ss_ctx *ss = platform_get_drvdata(pdev);\n\n\tfor (i = 0; i < ARRAY_SIZE(ss_algs); i++) {\n\t\tswitch (ss_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tcrypto_unregister_skcipher(&ss_algs[i].alg.crypto);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\tcrypto_unregister_ahash(&ss_algs[i].alg.hash);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_RNG:\n\t\t\tcrypto_unregister_rng(&ss_algs[i].alg.rng);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsun4i_ss_pm_exit(ss);\n\treturn 0;\n}\n\nstatic const struct of_device_id a20ss_crypto_of_match_table[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-crypto\",\n\t  .data = &ss_a10_variant\n\t},\n\t{ .compatible = \"allwinner,sun8i-a33-crypto\",\n\t  .data = &ss_a33_variant\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, a20ss_crypto_of_match_table);\n\nstatic struct platform_driver sun4i_ss_driver = {\n\t.probe          = sun4i_ss_probe,\n\t.remove         = sun4i_ss_remove,\n\t.driver         = {\n\t\t.name           = \"sun4i-ss\",\n\t\t.pm\t\t= &sun4i_ss_pm_ops,\n\t\t.of_match_table\t= a20ss_crypto_of_match_table,\n\t},\n};\n\nmodule_platform_driver(sun4i_ss_driver);\n\nMODULE_ALIAS(\"platform:sun4i-ss\");\nMODULE_DESCRIPTION(\"Allwinner Security System cryptographic accelerator\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Corentin LABBE <clabbe.montjoie@gmail.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}