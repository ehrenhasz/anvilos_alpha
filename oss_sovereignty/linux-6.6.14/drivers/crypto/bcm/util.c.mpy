{
  "module_name": "util.c",
  "hash_id": "daf88fdf1c4e848764a841df955b1f882e5db4efe550309e308c64fd7f5469bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/bcm/util.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n\n#include \"cipher.h\"\n#include \"util.h\"\n\n \n#define SPU_OFIFO_CTRL      0x40\n#define SPU_FIFO_WATERMARK  0x1FF\n\n \nint spu_sg_at_offset(struct scatterlist *sg, unsigned int skip,\n\t\t     struct scatterlist **sge, unsigned int *sge_offset)\n{\n\t \n\tunsigned int index = 0;\n\t \n\tunsigned int next_index;\n\n\tnext_index = sg->length;\n\twhile (next_index <= skip) {\n\t\tsg = sg_next(sg);\n\t\tindex = next_index;\n\t\tif (!sg)\n\t\t\treturn -EINVAL;\n\t\tnext_index += sg->length;\n\t}\n\n\t*sge_offset = skip - index;\n\t*sge = sg;\n\treturn 0;\n}\n\n \nvoid sg_copy_part_to_buf(struct scatterlist *src, u8 *dest,\n\t\t\t unsigned int len, unsigned int skip)\n{\n\tsize_t copied;\n\tunsigned int nents = sg_nents(src);\n\n\tcopied = sg_pcopy_to_buffer(src, nents, dest, len, skip);\n\tif (copied != len) {\n\t\tflow_log(\"%s copied %u bytes of %u requested. \",\n\t\t\t __func__, (u32)copied, len);\n\t\tflow_log(\"sg with %u entries and skip %u\\n\", nents, skip);\n\t}\n}\n\n \nvoid sg_copy_part_from_buf(struct scatterlist *dest, u8 *src,\n\t\t\t   unsigned int len, unsigned int skip)\n{\n\tsize_t copied;\n\tunsigned int nents = sg_nents(dest);\n\n\tcopied = sg_pcopy_from_buffer(dest, nents, src, len, skip);\n\tif (copied != len) {\n\t\tflow_log(\"%s copied %u bytes of %u requested. \",\n\t\t\t __func__, (u32)copied, len);\n\t\tflow_log(\"sg with %u entries and skip %u\\n\", nents, skip);\n\t}\n}\n\n \nint spu_sg_count(struct scatterlist *sg_list, unsigned int skip, int nbytes)\n{\n\tstruct scatterlist *sg;\n\tint sg_nents = 0;\n\tunsigned int offset;\n\n\tif (!sg_list)\n\t\treturn 0;\n\n\tif (spu_sg_at_offset(sg_list, skip, &sg, &offset) < 0)\n\t\treturn 0;\n\n\twhile (sg && (nbytes > 0)) {\n\t\tsg_nents++;\n\t\tnbytes -= (sg->length - offset);\n\t\toffset = 0;\n\t\tsg = sg_next(sg);\n\t}\n\treturn sg_nents;\n}\n\n \nu32 spu_msg_sg_add(struct scatterlist **to_sg,\n\t\t   struct scatterlist **from_sg, u32 *from_skip,\n\t\t   u8 from_nents, u32 length)\n{\n\tstruct scatterlist *sg;\t \n\tstruct scatterlist *to = *to_sg;\n\tstruct scatterlist *from = *from_sg;\n\tu32 skip = *from_skip;\n\tu32 offset;\n\tint i;\n\tu32 entry_len = 0;\n\tu32 frag_len = 0;\t \n\tu32 copied = 0;\t\t \n\n\tif (length == 0)\n\t\treturn 0;\n\n\tfor_each_sg(from, sg, from_nents, i) {\n\t\t \n\t\tentry_len = sg->length - skip;\n\t\tfrag_len = min(entry_len, length - copied);\n\t\toffset = sg->offset + skip;\n\t\tif (frag_len)\n\t\t\tsg_set_page(to++, sg_page(sg), frag_len, offset);\n\t\tcopied += frag_len;\n\t\tif (copied == entry_len) {\n\t\t\t \n\t\t\tskip = 0;\t \n\t\t}\n\t\tif (copied == length)\n\t\t\tbreak;\n\t}\n\t*to_sg = to;\n\t*from_sg = sg;\n\tif (frag_len < entry_len)\n\t\t*from_skip = skip + frag_len;\n\telse\n\t\t*from_skip = 0;\n\n\treturn copied;\n}\n\nvoid add_to_ctr(u8 *ctr_pos, unsigned int increment)\n{\n\t__be64 *high_be = (__be64 *)ctr_pos;\n\t__be64 *low_be = high_be + 1;\n\tu64 orig_low = __be64_to_cpu(*low_be);\n\tu64 new_low = orig_low + (u64)increment;\n\n\t*low_be = __cpu_to_be64(new_low);\n\tif (new_low < orig_low)\n\t\t \n\t\t*high_be = __cpu_to_be64(__be64_to_cpu(*high_be) + 1);\n}\n\nstruct sdesc {\n\tstruct shash_desc shash;\n\tchar ctx[];\n};\n\n \nint do_shash(unsigned char *name, unsigned char *result,\n\t     const u8 *data1, unsigned int data1_len,\n\t     const u8 *data2, unsigned int data2_len,\n\t     const u8 *key, unsigned int key_len)\n{\n\tint rc;\n\tunsigned int size;\n\tstruct crypto_shash *hash;\n\tstruct sdesc *sdesc;\n\n\thash = crypto_alloc_shash(name, 0, 0);\n\tif (IS_ERR(hash)) {\n\t\trc = PTR_ERR(hash);\n\t\tpr_err(\"%s: Crypto %s allocation error %d\\n\", __func__, name, rc);\n\t\treturn rc;\n\t}\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(hash);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc) {\n\t\trc = -ENOMEM;\n\t\tgoto do_shash_err;\n\t}\n\tsdesc->shash.tfm = hash;\n\n\tif (key_len > 0) {\n\t\trc = crypto_shash_setkey(hash, key, key_len);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Could not setkey %s shash\\n\", __func__, name);\n\t\t\tgoto do_shash_err;\n\t\t}\n\t}\n\n\trc = crypto_shash_init(&sdesc->shash);\n\tif (rc) {\n\t\tpr_err(\"%s: Could not init %s shash\\n\", __func__, name);\n\t\tgoto do_shash_err;\n\t}\n\trc = crypto_shash_update(&sdesc->shash, data1, data1_len);\n\tif (rc) {\n\t\tpr_err(\"%s: Could not update1\\n\", __func__);\n\t\tgoto do_shash_err;\n\t}\n\tif (data2 && data2_len) {\n\t\trc = crypto_shash_update(&sdesc->shash, data2, data2_len);\n\t\tif (rc) {\n\t\t\tpr_err(\"%s: Could not update2\\n\", __func__);\n\t\t\tgoto do_shash_err;\n\t\t}\n\t}\n\trc = crypto_shash_final(&sdesc->shash, result);\n\tif (rc)\n\t\tpr_err(\"%s: Could not generate %s hash\\n\", __func__, name);\n\ndo_shash_err:\n\tcrypto_free_shash(hash);\n\tkfree(sdesc);\n\n\treturn rc;\n}\n\n#ifdef DEBUG\n \nvoid __dump_sg(struct scatterlist *sg, unsigned int skip, unsigned int len)\n{\n\tu8 dbuf[16];\n\tunsigned int idx = skip;\n\tunsigned int num_out = 0;\t \n\tunsigned int count;\n\n\tif (packet_debug_logging) {\n\t\twhile (num_out < len) {\n\t\t\tcount = (len - num_out > 16) ? 16 : len - num_out;\n\t\t\tsg_copy_part_to_buf(sg, dbuf, count, idx);\n\t\t\tnum_out += count;\n\t\t\tprint_hex_dump(KERN_ALERT, \"  sg: \", DUMP_PREFIX_NONE,\n\t\t\t\t       4, 1, dbuf, count, false);\n\t\t\tidx += 16;\n\t\t}\n\t}\n\tif (debug_logging_sleep)\n\t\tmsleep(debug_logging_sleep);\n}\n#endif\n\n \nchar *spu_alg_name(enum spu_cipher_alg alg, enum spu_cipher_mode mode)\n{\n\tswitch (alg) {\n\tcase CIPHER_ALG_RC4:\n\t\treturn \"rc4\";\n\tcase CIPHER_ALG_AES:\n\t\tswitch (mode) {\n\t\tcase CIPHER_MODE_CBC:\n\t\t\treturn \"cbc(aes)\";\n\t\tcase CIPHER_MODE_ECB:\n\t\t\treturn \"ecb(aes)\";\n\t\tcase CIPHER_MODE_OFB:\n\t\t\treturn \"ofb(aes)\";\n\t\tcase CIPHER_MODE_CFB:\n\t\t\treturn \"cfb(aes)\";\n\t\tcase CIPHER_MODE_CTR:\n\t\t\treturn \"ctr(aes)\";\n\t\tcase CIPHER_MODE_XTS:\n\t\t\treturn \"xts(aes)\";\n\t\tcase CIPHER_MODE_GCM:\n\t\t\treturn \"gcm(aes)\";\n\t\tdefault:\n\t\t\treturn \"aes\";\n\t\t}\n\t\tbreak;\n\tcase CIPHER_ALG_DES:\n\t\tswitch (mode) {\n\t\tcase CIPHER_MODE_CBC:\n\t\t\treturn \"cbc(des)\";\n\t\tcase CIPHER_MODE_ECB:\n\t\t\treturn \"ecb(des)\";\n\t\tcase CIPHER_MODE_CTR:\n\t\t\treturn \"ctr(des)\";\n\t\tdefault:\n\t\t\treturn \"des\";\n\t\t}\n\t\tbreak;\n\tcase CIPHER_ALG_3DES:\n\t\tswitch (mode) {\n\t\tcase CIPHER_MODE_CBC:\n\t\t\treturn \"cbc(des3_ede)\";\n\t\tcase CIPHER_MODE_ECB:\n\t\t\treturn \"ecb(des3_ede)\";\n\t\tcase CIPHER_MODE_CTR:\n\t\t\treturn \"ctr(des3_ede)\";\n\t\tdefault:\n\t\t\treturn \"3des\";\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn \"other\";\n\t}\n}\n\nstatic ssize_t spu_debugfs_read(struct file *filp, char __user *ubuf,\n\t\t\t\tsize_t count, loff_t *offp)\n{\n\tstruct bcm_device_private *ipriv;\n\tchar *buf;\n\tssize_t ret, out_offset, out_count;\n\tint i;\n\tu32 fifo_len;\n\tu32 spu_ofifo_ctrl;\n\tu32 alg;\n\tu32 mode;\n\tu32 op_cnt;\n\n\tout_count = 2048;\n\n\tbuf = kmalloc(out_count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tipriv = filp->private_data;\n\tout_offset = 0;\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"Number of SPUs.........%u\\n\",\n\t\t\t       ipriv->spu.num_spu);\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"Current sessions.......%u\\n\",\n\t\t\t       atomic_read(&ipriv->session_count));\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"Session count..........%u\\n\",\n\t\t\t       atomic_read(&ipriv->stream_count));\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"Cipher setkey..........%u\\n\",\n\t\t\t       atomic_read(&ipriv->setkey_cnt[SPU_OP_CIPHER]));\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"Cipher Ops.............%u\\n\",\n\t\t\t       atomic_read(&ipriv->op_counts[SPU_OP_CIPHER]));\n\tfor (alg = 0; alg < CIPHER_ALG_LAST; alg++) {\n\t\tfor (mode = 0; mode < CIPHER_MODE_LAST; mode++) {\n\t\t\top_cnt = atomic_read(&ipriv->cipher_cnt[alg][mode]);\n\t\t\tif (op_cnt) {\n\t\t\t\tout_offset += scnprintf(buf + out_offset,\n\t\t\t\t\t\t       out_count - out_offset,\n\t\t\t       \"  %-13s%11u\\n\",\n\t\t\t       spu_alg_name(alg, mode), op_cnt);\n\t\t\t}\n\t\t}\n\t}\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"Hash Ops...............%u\\n\",\n\t\t\t       atomic_read(&ipriv->op_counts[SPU_OP_HASH]));\n\tfor (alg = 0; alg < HASH_ALG_LAST; alg++) {\n\t\top_cnt = atomic_read(&ipriv->hash_cnt[alg]);\n\t\tif (op_cnt) {\n\t\t\tout_offset += scnprintf(buf + out_offset,\n\t\t\t\t\t       out_count - out_offset,\n\t\t       \"  %-13s%11u\\n\",\n\t\t       hash_alg_name[alg], op_cnt);\n\t\t}\n\t}\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"HMAC setkey............%u\\n\",\n\t\t\t       atomic_read(&ipriv->setkey_cnt[SPU_OP_HMAC]));\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"HMAC Ops...............%u\\n\",\n\t\t\t       atomic_read(&ipriv->op_counts[SPU_OP_HMAC]));\n\tfor (alg = 0; alg < HASH_ALG_LAST; alg++) {\n\t\top_cnt = atomic_read(&ipriv->hmac_cnt[alg]);\n\t\tif (op_cnt) {\n\t\t\tout_offset += scnprintf(buf + out_offset,\n\t\t\t\t\t       out_count - out_offset,\n\t\t       \"  %-13s%11u\\n\",\n\t\t       hash_alg_name[alg], op_cnt);\n\t\t}\n\t}\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"AEAD setkey............%u\\n\",\n\t\t\t       atomic_read(&ipriv->setkey_cnt[SPU_OP_AEAD]));\n\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"AEAD Ops...............%u\\n\",\n\t\t\t       atomic_read(&ipriv->op_counts[SPU_OP_AEAD]));\n\tfor (alg = 0; alg < AEAD_TYPE_LAST; alg++) {\n\t\top_cnt = atomic_read(&ipriv->aead_cnt[alg]);\n\t\tif (op_cnt) {\n\t\t\tout_offset += scnprintf(buf + out_offset,\n\t\t\t\t\t       out_count - out_offset,\n\t\t       \"  %-13s%11u\\n\",\n\t\t       aead_alg_name[alg], op_cnt);\n\t\t}\n\t}\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"Bytes of req data......%llu\\n\",\n\t\t\t       (u64)atomic64_read(&ipriv->bytes_out));\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"Bytes of resp data.....%llu\\n\",\n\t\t\t       (u64)atomic64_read(&ipriv->bytes_in));\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"Mailbox full...........%u\\n\",\n\t\t\t       atomic_read(&ipriv->mb_no_spc));\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"Mailbox send failures..%u\\n\",\n\t\t\t       atomic_read(&ipriv->mb_send_fail));\n\tout_offset += scnprintf(buf + out_offset, out_count - out_offset,\n\t\t\t       \"Check ICV errors.......%u\\n\",\n\t\t\t       atomic_read(&ipriv->bad_icv));\n\tif (ipriv->spu.spu_type == SPU_TYPE_SPUM)\n\t\tfor (i = 0; i < ipriv->spu.num_spu; i++) {\n\t\t\tspu_ofifo_ctrl = ioread32(ipriv->spu.reg_vbase[i] +\n\t\t\t\t\t\t  SPU_OFIFO_CTRL);\n\t\t\tfifo_len = spu_ofifo_ctrl & SPU_FIFO_WATERMARK;\n\t\t\tout_offset += scnprintf(buf + out_offset,\n\t\t\t\t\t       out_count - out_offset,\n\t\t\t\t       \"SPU %d output FIFO high water.....%u\\n\",\n\t\t\t\t       i, fifo_len);\n\t\t}\n\n\tif (out_offset > out_count)\n\t\tout_offset = out_count;\n\n\tret = simple_read_from_buffer(ubuf, count, offp, buf, out_offset);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations spu_debugfs_stats = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = spu_debugfs_read,\n};\n\n \nvoid spu_setup_debugfs(void)\n{\n\tif (!debugfs_initialized())\n\t\treturn;\n\n\tif (!iproc_priv.debugfs_dir)\n\t\tiproc_priv.debugfs_dir = debugfs_create_dir(KBUILD_MODNAME,\n\t\t\t\t\t\t\t    NULL);\n\n\tif (!iproc_priv.debugfs_stats)\n\t\t \n\t\tdebugfs_create_file(\"stats\", 0400, iproc_priv.debugfs_dir,\n\t\t\t\t    &iproc_priv, &spu_debugfs_stats);\n}\n\nvoid spu_free_debugfs(void)\n{\n\tdebugfs_remove_recursive(iproc_priv.debugfs_dir);\n\tiproc_priv.debugfs_dir = NULL;\n}\n\n \nvoid format_value_ccm(unsigned int val, u8 *buf, u8 len)\n{\n\tint i;\n\n\t \n\tmemset(buf, 0, len);\n\n\t \n\tfor (i = 0; i < len; i++) {\n\t\tbuf[len - i - 1] = (val >> (8 * i)) & 0xff;\n\t\tif (i >= 3)\n\t\t\tbreak;   \n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}