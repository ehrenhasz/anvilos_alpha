{
  "module_name": "spu.c",
  "hash_id": "62b14d6abed020a8f5eba01a06f4ff5ebfc298973a7a63be71a5e3deb670e6ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/bcm/spu.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/string.h>\n\n#include \"util.h\"\n#include \"spu.h\"\n#include \"spum.h\"\n#include \"cipher.h\"\n\nchar *hash_alg_name[] = { \"None\", \"md5\", \"sha1\", \"sha224\", \"sha256\", \"aes\",\n\t\"sha384\", \"sha512\", \"sha3_224\", \"sha3_256\", \"sha3_384\", \"sha3_512\" };\n\nchar *aead_alg_name[] = { \"ccm(aes)\", \"gcm(aes)\", \"authenc\" };\n\n \nvoid spum_dump_msg_hdr(u8 *buf, unsigned int buf_len)\n{\n\tu8 *ptr = buf;\n\tstruct SPUHEADER *spuh = (struct SPUHEADER *)buf;\n\tunsigned int hash_key_len = 0;\n\tunsigned int hash_state_len = 0;\n\tunsigned int cipher_key_len = 0;\n\tunsigned int iv_len;\n\tu32 pflags;\n\tu32 cflags;\n\tu32 ecf;\n\tu32 cipher_alg;\n\tu32 cipher_mode;\n\tu32 cipher_type;\n\tu32 hash_alg;\n\tu32 hash_mode;\n\tu32 hash_type;\n\tu32 sctx_size;    \n\tu32 sctx_pl_len;  \n\n\tpacket_log(\"\\n\");\n\tpacket_log(\"SPU Message header %p len: %u\\n\", buf, buf_len);\n\n\t \n\tpacket_log(\"  MH 0x%08x\\n\", be32_to_cpup((__be32 *)ptr));\n\tif (spuh->mh.flags & MH_SCTX_PRES)\n\t\tpacket_log(\"    SCTX  present\\n\");\n\tif (spuh->mh.flags & MH_BDESC_PRES)\n\t\tpacket_log(\"    BDESC present\\n\");\n\tif (spuh->mh.flags & MH_MFM_PRES)\n\t\tpacket_log(\"    MFM   present\\n\");\n\tif (spuh->mh.flags & MH_BD_PRES)\n\t\tpacket_log(\"    BD    present\\n\");\n\tif (spuh->mh.flags & MH_HASH_PRES)\n\t\tpacket_log(\"    HASH  present\\n\");\n\tif (spuh->mh.flags & MH_SUPDT_PRES)\n\t\tpacket_log(\"    SUPDT present\\n\");\n\tpacket_log(\"    Opcode 0x%02x\\n\", spuh->mh.op_code);\n\n\tptr += sizeof(spuh->mh) + sizeof(spuh->emh);   \n\n\t \n\tif (spuh->mh.flags & MH_SCTX_PRES) {\n\t\tpflags = be32_to_cpu(spuh->sa.proto_flags);\n\t\tpacket_log(\"  SCTX[0] 0x%08x\\n\", pflags);\n\t\tsctx_size = pflags & SCTX_SIZE;\n\t\tpacket_log(\"    Size %u words\\n\", sctx_size);\n\n\t\tcflags = be32_to_cpu(spuh->sa.cipher_flags);\n\t\tpacket_log(\"  SCTX[1] 0x%08x\\n\", cflags);\n\t\tpacket_log(\"    Inbound:%lu (1:decrypt/vrfy 0:encrypt/auth)\\n\",\n\t\t\t   (cflags & CIPHER_INBOUND) >> CIPHER_INBOUND_SHIFT);\n\t\tpacket_log(\"    Order:%lu (1:AuthFirst 0:EncFirst)\\n\",\n\t\t\t   (cflags & CIPHER_ORDER) >> CIPHER_ORDER_SHIFT);\n\t\tpacket_log(\"    ICV_IS_512:%lx\\n\",\n\t\t\t   (cflags & ICV_IS_512) >> ICV_IS_512_SHIFT);\n\t\tcipher_alg = (cflags & CIPHER_ALG) >> CIPHER_ALG_SHIFT;\n\t\tcipher_mode = (cflags & CIPHER_MODE) >> CIPHER_MODE_SHIFT;\n\t\tcipher_type = (cflags & CIPHER_TYPE) >> CIPHER_TYPE_SHIFT;\n\t\tpacket_log(\"    Crypto Alg:%u Mode:%u Type:%u\\n\",\n\t\t\t   cipher_alg, cipher_mode, cipher_type);\n\t\thash_alg = (cflags & HASH_ALG) >> HASH_ALG_SHIFT;\n\t\thash_mode = (cflags & HASH_MODE) >> HASH_MODE_SHIFT;\n\t\thash_type = (cflags & HASH_TYPE) >> HASH_TYPE_SHIFT;\n\t\tpacket_log(\"    Hash   Alg:%x Mode:%x Type:%x\\n\",\n\t\t\t   hash_alg, hash_mode, hash_type);\n\t\tpacket_log(\"    UPDT_Offset:%u\\n\", cflags & UPDT_OFST);\n\n\t\tecf = be32_to_cpu(spuh->sa.ecf);\n\t\tpacket_log(\"  SCTX[2] 0x%08x\\n\", ecf);\n\t\tpacket_log(\"    WriteICV:%lu CheckICV:%lu ICV_SIZE:%u \",\n\t\t\t   (ecf & INSERT_ICV) >> INSERT_ICV_SHIFT,\n\t\t\t   (ecf & CHECK_ICV) >> CHECK_ICV_SHIFT,\n\t\t\t   (ecf & ICV_SIZE) >> ICV_SIZE_SHIFT);\n\t\tpacket_log(\"BD_SUPPRESS:%lu\\n\",\n\t\t\t   (ecf & BD_SUPPRESS) >> BD_SUPPRESS_SHIFT);\n\t\tpacket_log(\"    SCTX_IV:%lu ExplicitIV:%lu GenIV:%lu \",\n\t\t\t   (ecf & SCTX_IV) >> SCTX_IV_SHIFT,\n\t\t\t   (ecf & EXPLICIT_IV) >> EXPLICIT_IV_SHIFT,\n\t\t\t   (ecf & GEN_IV) >> GEN_IV_SHIFT);\n\t\tpacket_log(\"IV_OV_OFST:%lu EXP_IV_SIZE:%u\\n\",\n\t\t\t   (ecf & IV_OFFSET) >> IV_OFFSET_SHIFT,\n\t\t\t   ecf & EXP_IV_SIZE);\n\n\t\tptr += sizeof(struct SCTX);\n\n\t\tif (hash_alg && hash_mode) {\n\t\t\tchar *name = \"NONE\";\n\n\t\t\tswitch (hash_alg) {\n\t\t\tcase HASH_ALG_MD5:\n\t\t\t\thash_key_len = 16;\n\t\t\t\tname = \"MD5\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_SHA1:\n\t\t\t\thash_key_len = 20;\n\t\t\t\tname = \"SHA1\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_SHA224:\n\t\t\t\thash_key_len = 28;\n\t\t\t\tname = \"SHA224\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_SHA256:\n\t\t\t\thash_key_len = 32;\n\t\t\t\tname = \"SHA256\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_SHA384:\n\t\t\t\thash_key_len = 48;\n\t\t\t\tname = \"SHA384\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_SHA512:\n\t\t\t\thash_key_len = 64;\n\t\t\t\tname = \"SHA512\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_AES:\n\t\t\t\thash_key_len = 0;\n\t\t\t\tname = \"AES\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_NONE:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpacket_log(\"    Auth Key Type:%s Length:%u Bytes\\n\",\n\t\t\t\t   name, hash_key_len);\n\t\t\tpacket_dump(\"    KEY: \", ptr, hash_key_len);\n\t\t\tptr += hash_key_len;\n\t\t} else if ((hash_alg == HASH_ALG_AES) &&\n\t\t\t   (hash_mode == HASH_MODE_XCBC)) {\n\t\t\tchar *name = \"NONE\";\n\n\t\t\tswitch (cipher_type) {\n\t\t\tcase CIPHER_TYPE_AES128:\n\t\t\t\thash_key_len = 16;\n\t\t\t\tname = \"AES128-XCBC\";\n\t\t\t\tbreak;\n\t\t\tcase CIPHER_TYPE_AES192:\n\t\t\t\thash_key_len = 24;\n\t\t\t\tname = \"AES192-XCBC\";\n\t\t\t\tbreak;\n\t\t\tcase CIPHER_TYPE_AES256:\n\t\t\t\thash_key_len = 32;\n\t\t\t\tname = \"AES256-XCBC\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpacket_log(\"    Auth Key Type:%s Length:%u Bytes\\n\",\n\t\t\t\t   name, hash_key_len);\n\t\t\tpacket_dump(\"    KEY: \", ptr, hash_key_len);\n\t\t\tptr += hash_key_len;\n\t\t}\n\n\t\tif (hash_alg && (hash_mode == HASH_MODE_NONE) &&\n\t\t    (hash_type == HASH_TYPE_UPDT)) {\n\t\t\tchar *name = \"NONE\";\n\n\t\t\tswitch (hash_alg) {\n\t\t\tcase HASH_ALG_MD5:\n\t\t\t\thash_state_len = 16;\n\t\t\t\tname = \"MD5\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_SHA1:\n\t\t\t\thash_state_len = 20;\n\t\t\t\tname = \"SHA1\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_SHA224:\n\t\t\t\thash_state_len = 32;\n\t\t\t\tname = \"SHA224\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_SHA256:\n\t\t\t\thash_state_len = 32;\n\t\t\t\tname = \"SHA256\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_SHA384:\n\t\t\t\thash_state_len = 48;\n\t\t\t\tname = \"SHA384\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_SHA512:\n\t\t\t\thash_state_len = 64;\n\t\t\t\tname = \"SHA512\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_AES:\n\t\t\t\thash_state_len = 0;\n\t\t\t\tname = \"AES\";\n\t\t\t\tbreak;\n\t\t\tcase HASH_ALG_NONE:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpacket_log(\"    Auth State Type:%s Length:%u Bytes\\n\",\n\t\t\t\t   name, hash_state_len);\n\t\t\tpacket_dump(\"    State: \", ptr, hash_state_len);\n\t\t\tptr += hash_state_len;\n\t\t}\n\n\t\tif (cipher_alg) {\n\t\t\tchar *name = \"NONE\";\n\n\t\t\tswitch (cipher_alg) {\n\t\t\tcase CIPHER_ALG_DES:\n\t\t\t\tcipher_key_len = 8;\n\t\t\t\tname = \"DES\";\n\t\t\t\tbreak;\n\t\t\tcase CIPHER_ALG_3DES:\n\t\t\t\tcipher_key_len = 24;\n\t\t\t\tname = \"3DES\";\n\t\t\t\tbreak;\n\t\t\tcase CIPHER_ALG_AES:\n\t\t\t\tswitch (cipher_type) {\n\t\t\t\tcase CIPHER_TYPE_AES128:\n\t\t\t\t\tcipher_key_len = 16;\n\t\t\t\t\tname = \"AES128\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase CIPHER_TYPE_AES192:\n\t\t\t\t\tcipher_key_len = 24;\n\t\t\t\t\tname = \"AES192\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase CIPHER_TYPE_AES256:\n\t\t\t\t\tcipher_key_len = 32;\n\t\t\t\t\tname = \"AES256\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CIPHER_ALG_NONE:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpacket_log(\"    Cipher Key Type:%s Length:%u Bytes\\n\",\n\t\t\t\t   name, cipher_key_len);\n\n\t\t\t \n\t\t\tif (cipher_mode == CIPHER_MODE_XTS) {\n\t\t\t\tpacket_dump(\"    KEY2: \", ptr, cipher_key_len);\n\t\t\t\tptr += cipher_key_len;\n\t\t\t\tpacket_dump(\"    KEY1: \", ptr, cipher_key_len);\n\t\t\t\tptr += cipher_key_len;\n\n\t\t\t\tcipher_key_len *= 2;\n\t\t\t} else {\n\t\t\t\tpacket_dump(\"    KEY: \", ptr, cipher_key_len);\n\t\t\t\tptr += cipher_key_len;\n\t\t\t}\n\n\t\t\tif (ecf & SCTX_IV) {\n\t\t\t\tsctx_pl_len = sctx_size * sizeof(u32) -\n\t\t\t\t\tsizeof(struct SCTX);\n\t\t\t\tiv_len = sctx_pl_len -\n\t\t\t\t\t(hash_key_len + hash_state_len +\n\t\t\t\t\t cipher_key_len);\n\t\t\t\tpacket_log(\"    IV Length:%u Bytes\\n\", iv_len);\n\t\t\t\tpacket_dump(\"    IV: \", ptr, iv_len);\n\t\t\t\tptr += iv_len;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (spuh->mh.flags & MH_BDESC_PRES) {\n\t\tstruct BDESC_HEADER *bdesc = (struct BDESC_HEADER *)ptr;\n\n\t\tpacket_log(\"  BDESC[0] 0x%08x\\n\", be32_to_cpup((__be32 *)ptr));\n\t\tpacket_log(\"    OffsetMAC:%u LengthMAC:%u\\n\",\n\t\t\t   be16_to_cpu(bdesc->offset_mac),\n\t\t\t   be16_to_cpu(bdesc->length_mac));\n\t\tptr += sizeof(u32);\n\n\t\tpacket_log(\"  BDESC[1] 0x%08x\\n\", be32_to_cpup((__be32 *)ptr));\n\t\tpacket_log(\"    OffsetCrypto:%u LengthCrypto:%u\\n\",\n\t\t\t   be16_to_cpu(bdesc->offset_crypto),\n\t\t\t   be16_to_cpu(bdesc->length_crypto));\n\t\tptr += sizeof(u32);\n\n\t\tpacket_log(\"  BDESC[2] 0x%08x\\n\", be32_to_cpup((__be32 *)ptr));\n\t\tpacket_log(\"    OffsetICV:%u OffsetIV:%u\\n\",\n\t\t\t   be16_to_cpu(bdesc->offset_icv),\n\t\t\t   be16_to_cpu(bdesc->offset_iv));\n\t\tptr += sizeof(u32);\n\t}\n\n\t \n\tif (spuh->mh.flags & MH_BD_PRES) {\n\t\tstruct BD_HEADER *bd = (struct BD_HEADER *)ptr;\n\n\t\tpacket_log(\"  BD[0] 0x%08x\\n\", be32_to_cpup((__be32 *)ptr));\n\t\tpacket_log(\"    Size:%ubytes PrevLength:%u\\n\",\n\t\t\t   be16_to_cpu(bd->size), be16_to_cpu(bd->prev_length));\n\t\tptr += 4;\n\t}\n\n\t \n\tif (buf + buf_len != ptr) {\n\t\tpacket_log(\" Packet parsed incorrectly. \");\n\t\tpacket_log(\"buf:%p buf_len:%u buf+buf_len:%p ptr:%p\\n\",\n\t\t\t   buf, buf_len, buf + buf_len, ptr);\n\t}\n\n\tpacket_log(\"\\n\");\n}\n\n \nu32 spum_ns2_ctx_max_payload(enum spu_cipher_alg cipher_alg,\n\t\t\t     enum spu_cipher_mode cipher_mode,\n\t\t\t     unsigned int blocksize)\n{\n\tu32 max_payload = SPUM_NS2_MAX_PAYLOAD;\n\tu32 excess;\n\n\t \n\tif (cipher_mode == CIPHER_MODE_XTS)\n\t\tmax_payload -= SPU_XTS_TWEAK_SIZE;\n\n\texcess = max_payload % blocksize;\n\n\treturn max_payload - excess;\n}\n\n \nu32 spum_nsp_ctx_max_payload(enum spu_cipher_alg cipher_alg,\n\t\t\t     enum spu_cipher_mode cipher_mode,\n\t\t\t     unsigned int blocksize)\n{\n\tu32 max_payload = SPUM_NSP_MAX_PAYLOAD;\n\tu32 excess;\n\n\t \n\tif (cipher_mode == CIPHER_MODE_XTS)\n\t\tmax_payload -= SPU_XTS_TWEAK_SIZE;\n\n\texcess = max_payload % blocksize;\n\n\treturn max_payload - excess;\n}\n\n \nu32 spum_payload_length(u8 *spu_hdr)\n{\n\tstruct BD_HEADER *bd;\n\tu32 pl_len;\n\n\t \n\tbd = (struct BD_HEADER *)(spu_hdr + 8);\n\tpl_len = be16_to_cpu(bd->size);\n\n\treturn pl_len;\n}\n\n \nu16 spum_response_hdr_len(u16 auth_key_len, u16 enc_key_len, bool is_hash)\n{\n\tif (is_hash)\n\t\treturn SPU_HASH_RESP_HDR_LEN;\n\telse\n\t\treturn SPU_RESP_HDR_LEN;\n}\n\n \nu16 spum_hash_pad_len(enum hash_alg hash_alg, enum hash_mode hash_mode,\n\t\t      u32 chunksize, u16 hash_block_size)\n{\n\tunsigned int length_len;\n\tunsigned int used_space_last_block;\n\tint hash_pad_len;\n\n\t \n\tif ((hash_alg == HASH_ALG_AES) && (hash_mode == HASH_MODE_XCBC)) {\n\t\tused_space_last_block = chunksize % hash_block_size;\n\t\thash_pad_len = hash_block_size - used_space_last_block;\n\t\tif (hash_pad_len >= hash_block_size)\n\t\t\thash_pad_len -= hash_block_size;\n\t\treturn hash_pad_len;\n\t}\n\n\tused_space_last_block = chunksize % hash_block_size + 1;\n\tif ((hash_alg == HASH_ALG_SHA384) || (hash_alg == HASH_ALG_SHA512))\n\t\tlength_len = 2 * sizeof(u64);\n\telse\n\t\tlength_len = sizeof(u64);\n\n\tused_space_last_block += length_len;\n\thash_pad_len = hash_block_size - used_space_last_block;\n\tif (hash_pad_len < 0)\n\t\thash_pad_len += hash_block_size;\n\n\thash_pad_len += 1 + length_len;\n\treturn hash_pad_len;\n}\n\n \nu32 spum_gcm_ccm_pad_len(enum spu_cipher_mode cipher_mode,\n\t\t\t unsigned int data_size)\n{\n\tu32 pad_len = 0;\n\tu32 m1 = SPU_GCM_CCM_ALIGN - 1;\n\n\tif ((cipher_mode == CIPHER_MODE_GCM) ||\n\t    (cipher_mode == CIPHER_MODE_CCM))\n\t\tpad_len = ((data_size + m1) & ~m1) - data_size;\n\n\treturn pad_len;\n}\n\n \nu32 spum_assoc_resp_len(enum spu_cipher_mode cipher_mode,\n\t\t\tunsigned int assoc_len, unsigned int iv_len,\n\t\t\tbool is_encrypt)\n{\n\tu32 buflen = 0;\n\tu32 pad;\n\n\tif (assoc_len)\n\t\tbuflen = assoc_len;\n\n\tif (cipher_mode == CIPHER_MODE_GCM) {\n\t\t \n\t\tpad = spum_gcm_ccm_pad_len(cipher_mode, buflen);\n\t\tbuflen += pad;\n\t}\n\tif (cipher_mode == CIPHER_MODE_CCM) {\n\t\t \n\t\tpad = spum_gcm_ccm_pad_len(cipher_mode, buflen + 2);\n\t\tbuflen += pad;\n\t}\n\n\treturn buflen;\n}\n\n \nu8 spum_aead_ivlen(enum spu_cipher_mode cipher_mode, u16 iv_len)\n{\n\treturn 0;\n}\n\n \nenum hash_type spum_hash_type(u32 src_sent)\n{\n\treturn src_sent ? HASH_TYPE_UPDT : HASH_TYPE_INIT;\n}\n\n \nu32 spum_digest_size(u32 alg_digest_size, enum hash_alg alg,\n\t\t     enum hash_type htype)\n{\n\tu32 digestsize = alg_digest_size;\n\n\t \n\tif ((htype == HASH_TYPE_INIT) || (htype == HASH_TYPE_UPDT)) {\n\t\tif (alg == HASH_ALG_SHA224)\n\t\t\tdigestsize = SHA256_DIGEST_SIZE;\n\t\telse if (alg == HASH_ALG_SHA384)\n\t\t\tdigestsize = SHA512_DIGEST_SIZE;\n\t}\n\treturn digestsize;\n}\n\n \nu32 spum_create_request(u8 *spu_hdr,\n\t\t\tstruct spu_request_opts *req_opts,\n\t\t\tstruct spu_cipher_parms *cipher_parms,\n\t\t\tstruct spu_hash_parms *hash_parms,\n\t\t\tstruct spu_aead_parms *aead_parms,\n\t\t\tunsigned int data_size)\n{\n\tstruct SPUHEADER *spuh;\n\tstruct BDESC_HEADER *bdesc;\n\tstruct BD_HEADER *bd;\n\n\tu8 *ptr;\n\tu32 protocol_bits = 0;\n\tu32 cipher_bits = 0;\n\tu32 ecf_bits = 0;\n\tu8 sctx_words = 0;\n\tunsigned int buf_len = 0;\n\n\t \n\tunsigned int cipher_len = hash_parms->prebuf_len + data_size +\n\t\t\t\thash_parms->pad_len;\n\n\t \n\tunsigned int cipher_offset = aead_parms->assoc_size +\n\t\taead_parms->iv_len + aead_parms->aad_pad_len;\n\n\t \n\tunsigned int real_db_size = spu_real_db_size(aead_parms->assoc_size,\n\t\t\t\t\t\t aead_parms->iv_len,\n\t\t\t\t\t\t hash_parms->prebuf_len,\n\t\t\t\t\t\t data_size,\n\t\t\t\t\t\t aead_parms->aad_pad_len,\n\t\t\t\t\t\t aead_parms->data_pad_len,\n\t\t\t\t\t\t hash_parms->pad_len);\n\n\tunsigned int auth_offset = 0;\n\tunsigned int offset_iv = 0;\n\n\t \n\tunsigned int auth_len;\n\n\tauth_len = real_db_size;\n\n\tif (req_opts->is_aead && req_opts->is_inbound)\n\t\tcipher_len -= hash_parms->digestsize;\n\n\tif (req_opts->is_aead && req_opts->is_inbound)\n\t\tauth_len -= hash_parms->digestsize;\n\n\tif ((hash_parms->alg == HASH_ALG_AES) &&\n\t    (hash_parms->mode == HASH_MODE_XCBC)) {\n\t\tauth_len -= hash_parms->pad_len;\n\t\tcipher_len -= hash_parms->pad_len;\n\t}\n\n\tflow_log(\"%s()\\n\", __func__);\n\tflow_log(\"  in:%u authFirst:%u\\n\",\n\t\t req_opts->is_inbound, req_opts->auth_first);\n\tflow_log(\"  %s. cipher alg:%u mode:%u type %u\\n\",\n\t\t spu_alg_name(cipher_parms->alg, cipher_parms->mode),\n\t\t cipher_parms->alg, cipher_parms->mode, cipher_parms->type);\n\tflow_log(\"    key: %d\\n\", cipher_parms->key_len);\n\tflow_dump(\"    key: \", cipher_parms->key_buf, cipher_parms->key_len);\n\tflow_log(\"    iv: %d\\n\", cipher_parms->iv_len);\n\tflow_dump(\"    iv: \", cipher_parms->iv_buf, cipher_parms->iv_len);\n\tflow_log(\"  auth alg:%u mode:%u type %u\\n\",\n\t\t hash_parms->alg, hash_parms->mode, hash_parms->type);\n\tflow_log(\"  digestsize: %u\\n\", hash_parms->digestsize);\n\tflow_log(\"  authkey: %d\\n\", hash_parms->key_len);\n\tflow_dump(\"  authkey: \", hash_parms->key_buf, hash_parms->key_len);\n\tflow_log(\"  assoc_size:%u\\n\", aead_parms->assoc_size);\n\tflow_log(\"  prebuf_len:%u\\n\", hash_parms->prebuf_len);\n\tflow_log(\"  data_size:%u\\n\", data_size);\n\tflow_log(\"  hash_pad_len:%u\\n\", hash_parms->pad_len);\n\tflow_log(\"  real_db_size:%u\\n\", real_db_size);\n\tflow_log(\" auth_offset:%u auth_len:%u cipher_offset:%u cipher_len:%u\\n\",\n\t\t auth_offset, auth_len, cipher_offset, cipher_len);\n\tflow_log(\"  aead_iv: %u\\n\", aead_parms->iv_len);\n\n\t \n\tptr = spu_hdr;\n\tmemset(ptr, 0, sizeof(struct SPUHEADER));\n\n\t \n\t \n\tspuh = (struct SPUHEADER *)ptr;\n\tptr += sizeof(struct SPUHEADER);\n\tbuf_len += sizeof(struct SPUHEADER);\n\n\tspuh->mh.op_code = SPU_CRYPTO_OPERATION_GENERIC;\n\tspuh->mh.flags |= (MH_SCTX_PRES | MH_BDESC_PRES | MH_BD_PRES);\n\n\t \n\tsctx_words = 3;\t\t \n\n\t \n\tif (req_opts->is_inbound)\n\t\tcipher_bits |= CIPHER_INBOUND;\n\tif (req_opts->auth_first)\n\t\tcipher_bits |= CIPHER_ORDER;\n\n\t \n\tcipher_bits |= cipher_parms->alg << CIPHER_ALG_SHIFT;\n\tcipher_bits |= cipher_parms->mode << CIPHER_MODE_SHIFT;\n\tcipher_bits |= cipher_parms->type << CIPHER_TYPE_SHIFT;\n\n\t \n\tcipher_bits |= hash_parms->alg << HASH_ALG_SHIFT;\n\tcipher_bits |= hash_parms->mode << HASH_MODE_SHIFT;\n\tcipher_bits |= hash_parms->type << HASH_TYPE_SHIFT;\n\n\t \n\tif (hash_parms->alg) {\n\t\t \n\t\tif (hash_parms->key_len) {\n\t\t\tmemcpy(ptr, hash_parms->key_buf, hash_parms->key_len);\n\t\t\tptr += hash_parms->key_len;\n\t\t\tbuf_len += hash_parms->key_len;\n\t\t\tsctx_words += hash_parms->key_len / 4;\n\t\t}\n\n\t\tif ((cipher_parms->mode == CIPHER_MODE_GCM) ||\n\t\t    (cipher_parms->mode == CIPHER_MODE_CCM))\n\t\t\t \n\t\t\toffset_iv = aead_parms->assoc_size;\n\n\t\t \n\t\tif (!req_opts->is_inbound) {\n\t\t\tif ((cipher_parms->mode == CIPHER_MODE_GCM) ||\n\t\t\t    (cipher_parms->mode == CIPHER_MODE_CCM))\n\t\t\t\tecf_bits |= 1 << INSERT_ICV_SHIFT;\n\t\t} else {\n\t\t\tecf_bits |= CHECK_ICV;\n\t\t}\n\n\t\t \n\t\tif (hash_parms->digestsize == 64)\n\t\t\tcipher_bits |= ICV_IS_512;\n\t\telse\n\t\t\tecf_bits |=\n\t\t\t(hash_parms->digestsize / 4) << ICV_SIZE_SHIFT;\n\t}\n\n\tif (req_opts->bd_suppress)\n\t\tecf_bits |= BD_SUPPRESS;\n\n\t \n\tif (cipher_parms->alg) {\n\t\tif (cipher_parms->key_len) {\n\t\t\tmemcpy(ptr, cipher_parms->key_buf,\n\t\t\t       cipher_parms->key_len);\n\t\t\tptr += cipher_parms->key_len;\n\t\t\tbuf_len += cipher_parms->key_len;\n\t\t\tsctx_words += cipher_parms->key_len / 4;\n\t\t}\n\n\t\t \n\t\tif (cipher_parms->iv_buf && cipher_parms->iv_len) {\n\t\t\t \n\t\t\tecf_bits |= SCTX_IV;\n\n\t\t\t \n\t\t\tmemcpy(ptr, cipher_parms->iv_buf, cipher_parms->iv_len);\n\n\t\t\tptr += cipher_parms->iv_len;\n\t\t\tbuf_len += cipher_parms->iv_len;\n\t\t\tsctx_words += cipher_parms->iv_len / 4;\n\t\t}\n\t}\n\n\t \n\tif (req_opts->is_rfc4543) {\n\t\tif (req_opts->is_inbound)\n\t\t\tdata_size -= hash_parms->digestsize;\n\t\toffset_iv = aead_parms->assoc_size + data_size;\n\t\tcipher_len = 0;\n\t\tcipher_offset = offset_iv;\n\t\tauth_len = cipher_offset + aead_parms->data_pad_len;\n\t}\n\n\t \n\tprotocol_bits |= sctx_words;\n\n\t \n\tspuh->sa.proto_flags = cpu_to_be32(protocol_bits);\n\tspuh->sa.cipher_flags = cpu_to_be32(cipher_bits);\n\tspuh->sa.ecf = cpu_to_be32(ecf_bits);\n\n\t \n\tbdesc = (struct BDESC_HEADER *)ptr;\n\n\tbdesc->offset_mac = cpu_to_be16(auth_offset);\n\tbdesc->length_mac = cpu_to_be16(auth_len);\n\tbdesc->offset_crypto = cpu_to_be16(cipher_offset);\n\tbdesc->length_crypto = cpu_to_be16(cipher_len);\n\n\t \n\tif (cipher_parms->mode == CIPHER_MODE_CCM)\n\t\tauth_len += spum_wordalign_padlen(auth_len);\n\n\tbdesc->offset_icv = cpu_to_be16(auth_len);\n\tbdesc->offset_iv = cpu_to_be16(offset_iv);\n\n\tptr += sizeof(struct BDESC_HEADER);\n\tbuf_len += sizeof(struct BDESC_HEADER);\n\n\t \n\n\t \n\n\t \n\tbd = (struct BD_HEADER *)ptr;\n\tbd->size = cpu_to_be16(real_db_size);\n\tbd->prev_length = 0;\n\n\tptr += sizeof(struct BD_HEADER);\n\tbuf_len += sizeof(struct BD_HEADER);\n\n\tpacket_dump(\"  SPU request header: \", spu_hdr, buf_len);\n\n\treturn buf_len;\n}\n\n \nu16 spum_cipher_req_init(u8 *spu_hdr, struct spu_cipher_parms *cipher_parms)\n{\n\tstruct SPUHEADER *spuh;\n\tu32 protocol_bits = 0;\n\tu32 cipher_bits = 0;\n\tu32 ecf_bits = 0;\n\tu8 sctx_words = 0;\n\tu8 *ptr = spu_hdr;\n\n\tflow_log(\"%s()\\n\", __func__);\n\tflow_log(\"  cipher alg:%u mode:%u type %u\\n\", cipher_parms->alg,\n\t\t cipher_parms->mode, cipher_parms->type);\n\tflow_log(\"  cipher_iv_len: %u\\n\", cipher_parms->iv_len);\n\tflow_log(\"    key: %d\\n\", cipher_parms->key_len);\n\tflow_dump(\"    key: \", cipher_parms->key_buf, cipher_parms->key_len);\n\n\t \n\tmemset(spu_hdr, 0, sizeof(struct SPUHEADER));\n\tptr += sizeof(struct SPUHEADER);\n\n\t \n\t \n\tspuh = (struct SPUHEADER *)spu_hdr;\n\n\tspuh->mh.op_code = SPU_CRYPTO_OPERATION_GENERIC;\n\tspuh->mh.flags |= (MH_SCTX_PRES | MH_BDESC_PRES | MH_BD_PRES);\n\n\t \n\tsctx_words = 3;\t\t \n\n\t \n\tif (cipher_parms->alg) {\n\t\tif (cipher_parms->key_len) {\n\t\t\tptr += cipher_parms->key_len;\n\t\t\tsctx_words += cipher_parms->key_len / 4;\n\t\t}\n\n\t\t \n\t\tif (cipher_parms->iv_len) {\n\t\t\t \n\t\t\tecf_bits |= SCTX_IV;\n\t\t\tptr += cipher_parms->iv_len;\n\t\t\tsctx_words += cipher_parms->iv_len / 4;\n\t\t}\n\t}\n\n\t \n\tcipher_bits |= cipher_parms->alg << CIPHER_ALG_SHIFT;\n\tcipher_bits |= cipher_parms->mode << CIPHER_MODE_SHIFT;\n\tcipher_bits |= cipher_parms->type << CIPHER_TYPE_SHIFT;\n\n\t \n\tif (cipher_parms->alg && cipher_parms->key_len)\n\t\tmemcpy(spuh + 1, cipher_parms->key_buf, cipher_parms->key_len);\n\n\t \n\tprotocol_bits |= sctx_words;\n\n\t \n\tspuh->sa.proto_flags = cpu_to_be32(protocol_bits);\n\n\t \n\tspuh->sa.cipher_flags = cpu_to_be32(cipher_bits);\n\tspuh->sa.ecf = cpu_to_be32(ecf_bits);\n\n\tpacket_dump(\"  SPU request header: \", spu_hdr,\n\t\t    sizeof(struct SPUHEADER));\n\n\treturn sizeof(struct SPUHEADER) + cipher_parms->key_len +\n\t\tcipher_parms->iv_len + sizeof(struct BDESC_HEADER) +\n\t\tsizeof(struct BD_HEADER);\n}\n\n \nvoid spum_cipher_req_finish(u8 *spu_hdr,\n\t\t\t    u16 spu_req_hdr_len,\n\t\t\t    unsigned int is_inbound,\n\t\t\t    struct spu_cipher_parms *cipher_parms,\n\t\t\t    unsigned int data_size)\n{\n\tstruct SPUHEADER *spuh;\n\tstruct BDESC_HEADER *bdesc;\n\tstruct BD_HEADER *bd;\n\tu8 *bdesc_ptr = spu_hdr + spu_req_hdr_len -\n\t    (sizeof(struct BD_HEADER) + sizeof(struct BDESC_HEADER));\n\n\tu32 cipher_bits;\n\n\tflow_log(\"%s()\\n\", __func__);\n\tflow_log(\" in: %u\\n\", is_inbound);\n\tflow_log(\" cipher alg: %u, cipher_type: %u\\n\", cipher_parms->alg,\n\t\t cipher_parms->type);\n\n\t \n\tif (cipher_parms->mode == CIPHER_MODE_XTS)\n\t\tmemset(cipher_parms->iv_buf, 0, cipher_parms->iv_len);\n\n\tflow_log(\" iv len: %d\\n\", cipher_parms->iv_len);\n\tflow_dump(\"    iv: \", cipher_parms->iv_buf, cipher_parms->iv_len);\n\tflow_log(\" data_size: %u\\n\", data_size);\n\n\t \n\t \n\tspuh = (struct SPUHEADER *)spu_hdr;\n\n\t \n\tcipher_bits = be32_to_cpu(spuh->sa.cipher_flags);\n\n\t \n\tif (is_inbound)\n\t\tcipher_bits |= CIPHER_INBOUND;\n\telse\n\t\tcipher_bits &= ~CIPHER_INBOUND;\n\n\tif (cipher_parms->alg && cipher_parms->iv_buf && cipher_parms->iv_len)\n\t\t \n\t\tmemcpy(bdesc_ptr - cipher_parms->iv_len, cipher_parms->iv_buf,\n\t\t       cipher_parms->iv_len);\n\n\tspuh->sa.cipher_flags = cpu_to_be32(cipher_bits);\n\n\t \n\tbdesc = (struct BDESC_HEADER *)bdesc_ptr;\n\tbdesc->offset_mac = 0;\n\tbdesc->length_mac = 0;\n\tbdesc->offset_crypto = 0;\n\n\t \n\tif (cipher_parms->mode == CIPHER_MODE_XTS)\n\t\tbdesc->length_crypto = cpu_to_be16(data_size +\n\t\t\t\t\t\t  SPU_XTS_TWEAK_SIZE);\n\telse\n\t\tbdesc->length_crypto = cpu_to_be16(data_size);\n\n\tbdesc->offset_icv = 0;\n\tbdesc->offset_iv = 0;\n\n\t \n\n\t \n\t \n\tbd = (struct BD_HEADER *)(bdesc_ptr + sizeof(struct BDESC_HEADER));\n\tbd->size = cpu_to_be16(data_size);\n\n\t \n\tif (cipher_parms->mode == CIPHER_MODE_XTS)\n\t\tbd->size = cpu_to_be16(data_size + SPU_XTS_TWEAK_SIZE);\n\telse\n\t\tbd->size = cpu_to_be16(data_size);\n\n\tbd->prev_length = 0;\n\n\tpacket_dump(\"  SPU request header: \", spu_hdr, spu_req_hdr_len);\n}\n\n \nvoid spum_request_pad(u8 *pad_start,\n\t\t      u32 gcm_ccm_padding,\n\t\t      u32 hash_pad_len,\n\t\t      enum hash_alg auth_alg,\n\t\t      enum hash_mode auth_mode,\n\t\t      unsigned int total_sent, u32 status_padding)\n{\n\tu8 *ptr = pad_start;\n\n\t \n\tif (gcm_ccm_padding > 0) {\n\t\tflow_log(\"  GCM: padding to 16 byte alignment: %u bytes\\n\",\n\t\t\t gcm_ccm_padding);\n\t\tmemset(ptr, 0, gcm_ccm_padding);\n\t\tptr += gcm_ccm_padding;\n\t}\n\n\tif (hash_pad_len > 0) {\n\t\t \n\t\tmemset(ptr, 0, hash_pad_len);\n\n\t\tif ((auth_alg == HASH_ALG_AES) &&\n\t\t    (auth_mode == HASH_MODE_XCBC)) {\n\t\t\t \n\t\t\tptr += hash_pad_len;\n\t\t} else {\n\t\t\t \n\t\t\t*ptr = 0x80;\n\t\t\tptr += (hash_pad_len - sizeof(u64));\n\n\t\t\t \n\t\t\tif (auth_alg == HASH_ALG_MD5)\n\t\t\t\t*(__le64 *)ptr = cpu_to_le64(total_sent * 8ull);\n\t\t\telse\t\t \n\t\t\t\t*(__be64 *)ptr = cpu_to_be64(total_sent * 8ull);\n\t\t\tptr += sizeof(u64);\n\t\t}\n\t}\n\n\t \n\tif (status_padding > 0) {\n\t\tflow_log(\"  STAT: padding to 4 byte alignment: %u bytes\\n\",\n\t\t\t status_padding);\n\n\t\tmemset(ptr, 0, status_padding);\n\t\tptr += status_padding;\n\t}\n}\n\n \nu8 spum_xts_tweak_in_payload(void)\n{\n\treturn 1;\n}\n\n \nu8 spum_tx_status_len(void)\n{\n\treturn SPU_TX_STATUS_LEN;\n}\n\n \nu8 spum_rx_status_len(void)\n{\n\treturn SPU_RX_STATUS_LEN;\n}\n\n \nint spum_status_process(u8 *statp)\n{\n\tu32 status;\n\n\tstatus = __be32_to_cpu(*(__be32 *)statp);\n\tflow_log(\"SPU response STATUS %#08x\\n\", status);\n\tif (status & SPU_STATUS_ERROR_FLAG) {\n\t\tpr_err(\"%s() Warning: Error result from SPU: %#08x\\n\",\n\t\t       __func__, status);\n\t\tif (status & SPU_STATUS_INVALID_ICV)\n\t\t\treturn SPU_INVALID_ICV;\n\t\treturn -EBADMSG;\n\t}\n\treturn 0;\n}\n\n \nvoid spum_ccm_update_iv(unsigned int digestsize,\n\t\t\tstruct spu_cipher_parms *cipher_parms,\n\t\t\tunsigned int assoclen,\n\t\t\tunsigned int chunksize,\n\t\t\tbool is_encrypt,\n\t\t\tbool is_esp)\n{\n\tu8 L;\t\t \n\tu8 mprime;\t \n\tu8 adata;\n\n\tif (cipher_parms->iv_len != CCM_AES_IV_SIZE) {\n\t\tpr_err(\"%s(): Invalid IV len %d for CCM mode, should be %d\\n\",\n\t\t       __func__, cipher_parms->iv_len, CCM_AES_IV_SIZE);\n\t\treturn;\n\t}\n\n\t \n\tif (is_esp) {\n\t\tL = CCM_ESP_L_VALUE;\t \n\t} else {\n\t\t \n\t\tL = ((cipher_parms->iv_buf[0] & CCM_B0_L_PRIME) >>\n\t\t      CCM_B0_L_PRIME_SHIFT) + 1;\n\t}\n\n\tmprime = (digestsize - 2) >> 1;   \n\tadata = (assoclen > 0);   \n\n\tcipher_parms->iv_buf[0] = (adata << CCM_B0_ADATA_SHIFT) |\n\t\t\t\t  (mprime << CCM_B0_M_PRIME_SHIFT) |\n\t\t\t\t  ((L - 1) << CCM_B0_L_PRIME_SHIFT);\n\n\t \n\n\t \n\tif (!is_encrypt)\n\t\tchunksize -= digestsize;\n\n\t \n\tformat_value_ccm(chunksize, &cipher_parms->iv_buf[15 - L + 1], L);\n}\n\n \nu32 spum_wordalign_padlen(u32 data_size)\n{\n\treturn ((data_size + 3) & ~3) - data_size;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}