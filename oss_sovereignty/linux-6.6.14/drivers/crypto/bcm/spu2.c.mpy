{
  "module_name": "spu2.c",
  "hash_id": "c927cb46e1e0ac1e9583def10a89a60cda36c297b477da032a6c2e758aae6fe1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/bcm/spu2.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/string.h>\n\n#include \"util.h\"\n#include \"spu.h\"\n#include \"spu2.h\"\n\n#define SPU2_TX_STATUS_LEN  0\t \n\n \n#define SPU2_RX_STATUS_LEN  2\n\nenum spu2_proto_sel {\n\tSPU2_PROTO_RESV = 0,\n\tSPU2_MACSEC_SECTAG8_ECB = 1,\n\tSPU2_MACSEC_SECTAG8_SCB = 2,\n\tSPU2_MACSEC_SECTAG16 = 3,\n\tSPU2_MACSEC_SECTAG16_8_XPN = 4,\n\tSPU2_IPSEC = 5,\n\tSPU2_IPSEC_ESN = 6,\n\tSPU2_TLS_CIPHER = 7,\n\tSPU2_TLS_AEAD = 8,\n\tSPU2_DTLS_CIPHER = 9,\n\tSPU2_DTLS_AEAD = 10\n};\n\nstatic char *spu2_cipher_type_names[] = { \"None\", \"AES128\", \"AES192\", \"AES256\",\n\t\"DES\", \"3DES\"\n};\n\nstatic char *spu2_cipher_mode_names[] = { \"ECB\", \"CBC\", \"CTR\", \"CFB\", \"OFB\",\n\t\"XTS\", \"CCM\", \"GCM\"\n};\n\nstatic char *spu2_hash_type_names[] = { \"None\", \"AES128\", \"AES192\", \"AES256\",\n\t\"Reserved\", \"Reserved\", \"MD5\", \"SHA1\", \"SHA224\", \"SHA256\", \"SHA384\",\n\t\"SHA512\", \"SHA512/224\", \"SHA512/256\", \"SHA3-224\", \"SHA3-256\",\n\t\"SHA3-384\", \"SHA3-512\"\n};\n\nstatic char *spu2_hash_mode_names[] = { \"CMAC\", \"CBC-MAC\", \"XCBC-MAC\", \"HMAC\",\n\t\"Rabin\", \"CCM\", \"GCM\", \"Reserved\"\n};\n\nstatic char *spu2_ciph_type_name(enum spu2_cipher_type cipher_type)\n{\n\tif (cipher_type >= SPU2_CIPHER_TYPE_LAST)\n\t\treturn \"Reserved\";\n\treturn spu2_cipher_type_names[cipher_type];\n}\n\nstatic char *spu2_ciph_mode_name(enum spu2_cipher_mode cipher_mode)\n{\n\tif (cipher_mode >= SPU2_CIPHER_MODE_LAST)\n\t\treturn \"Reserved\";\n\treturn spu2_cipher_mode_names[cipher_mode];\n}\n\nstatic char *spu2_hash_type_name(enum spu2_hash_type hash_type)\n{\n\tif (hash_type >= SPU2_HASH_TYPE_LAST)\n\t\treturn \"Reserved\";\n\treturn spu2_hash_type_names[hash_type];\n}\n\nstatic char *spu2_hash_mode_name(enum spu2_hash_mode hash_mode)\n{\n\tif (hash_mode >= SPU2_HASH_MODE_LAST)\n\t\treturn \"Reserved\";\n\treturn spu2_hash_mode_names[hash_mode];\n}\n\n \nstatic int spu2_cipher_mode_xlate(enum spu_cipher_mode cipher_mode,\n\t\t\t\t  enum spu2_cipher_mode *spu2_mode)\n{\n\tswitch (cipher_mode) {\n\tcase CIPHER_MODE_ECB:\n\t\t*spu2_mode = SPU2_CIPHER_MODE_ECB;\n\t\tbreak;\n\tcase CIPHER_MODE_CBC:\n\t\t*spu2_mode = SPU2_CIPHER_MODE_CBC;\n\t\tbreak;\n\tcase CIPHER_MODE_OFB:\n\t\t*spu2_mode = SPU2_CIPHER_MODE_OFB;\n\t\tbreak;\n\tcase CIPHER_MODE_CFB:\n\t\t*spu2_mode = SPU2_CIPHER_MODE_CFB;\n\t\tbreak;\n\tcase CIPHER_MODE_CTR:\n\t\t*spu2_mode = SPU2_CIPHER_MODE_CTR;\n\t\tbreak;\n\tcase CIPHER_MODE_CCM:\n\t\t*spu2_mode = SPU2_CIPHER_MODE_CCM;\n\t\tbreak;\n\tcase CIPHER_MODE_GCM:\n\t\t*spu2_mode = SPU2_CIPHER_MODE_GCM;\n\t\tbreak;\n\tcase CIPHER_MODE_XTS:\n\t\t*spu2_mode = SPU2_CIPHER_MODE_XTS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int spu2_cipher_xlate(enum spu_cipher_alg cipher_alg,\n\t\t\t     enum spu_cipher_mode cipher_mode,\n\t\t\t     enum spu_cipher_type cipher_type,\n\t\t\t     enum spu2_cipher_type *spu2_type,\n\t\t\t     enum spu2_cipher_mode *spu2_mode)\n{\n\tint err;\n\n\terr = spu2_cipher_mode_xlate(cipher_mode, spu2_mode);\n\tif (err) {\n\t\tflow_log(\"Invalid cipher mode %d\\n\", cipher_mode);\n\t\treturn err;\n\t}\n\n\tswitch (cipher_alg) {\n\tcase CIPHER_ALG_NONE:\n\t\t*spu2_type = SPU2_CIPHER_TYPE_NONE;\n\t\tbreak;\n\tcase CIPHER_ALG_RC4:\n\t\t \n\t\terr = -EINVAL;\n\t\t*spu2_type = SPU2_CIPHER_TYPE_NONE;\n\t\tbreak;\n\tcase CIPHER_ALG_DES:\n\t\t*spu2_type = SPU2_CIPHER_TYPE_DES;\n\t\tbreak;\n\tcase CIPHER_ALG_3DES:\n\t\t*spu2_type = SPU2_CIPHER_TYPE_3DES;\n\t\tbreak;\n\tcase CIPHER_ALG_AES:\n\t\tswitch (cipher_type) {\n\t\tcase CIPHER_TYPE_AES128:\n\t\t\t*spu2_type = SPU2_CIPHER_TYPE_AES128;\n\t\t\tbreak;\n\t\tcase CIPHER_TYPE_AES192:\n\t\t\t*spu2_type = SPU2_CIPHER_TYPE_AES192;\n\t\t\tbreak;\n\t\tcase CIPHER_TYPE_AES256:\n\t\t\t*spu2_type = SPU2_CIPHER_TYPE_AES256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase CIPHER_ALG_LAST:\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\tflow_log(\"Invalid cipher alg %d or type %d\\n\",\n\t\t\t cipher_alg, cipher_type);\n\treturn err;\n}\n\n \nstatic int spu2_hash_mode_xlate(enum hash_mode hash_mode,\n\t\t\t\tenum spu2_hash_mode *spu2_mode)\n{\n\tswitch (hash_mode) {\n\tcase HASH_MODE_XCBC:\n\t\t*spu2_mode = SPU2_HASH_MODE_XCBC_MAC;\n\t\tbreak;\n\tcase HASH_MODE_CMAC:\n\t\t*spu2_mode = SPU2_HASH_MODE_CMAC;\n\t\tbreak;\n\tcase HASH_MODE_HMAC:\n\t\t*spu2_mode = SPU2_HASH_MODE_HMAC;\n\t\tbreak;\n\tcase HASH_MODE_CCM:\n\t\t*spu2_mode = SPU2_HASH_MODE_CCM;\n\t\tbreak;\n\tcase HASH_MODE_GCM:\n\t\t*spu2_mode = SPU2_HASH_MODE_GCM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nspu2_hash_xlate(enum hash_alg hash_alg, enum hash_mode hash_mode,\n\t\tenum hash_type hash_type, enum spu_cipher_type ciph_type,\n\t\tenum spu2_hash_type *spu2_type, enum spu2_hash_mode *spu2_mode)\n{\n\tint err;\n\n\terr = spu2_hash_mode_xlate(hash_mode, spu2_mode);\n\tif (err) {\n\t\tflow_log(\"Invalid hash mode %d\\n\", hash_mode);\n\t\treturn err;\n\t}\n\n\tswitch (hash_alg) {\n\tcase HASH_ALG_NONE:\n\t\t*spu2_type = SPU2_HASH_TYPE_NONE;\n\t\tbreak;\n\tcase HASH_ALG_MD5:\n\t\t*spu2_type = SPU2_HASH_TYPE_MD5;\n\t\tbreak;\n\tcase HASH_ALG_SHA1:\n\t\t*spu2_type = SPU2_HASH_TYPE_SHA1;\n\t\tbreak;\n\tcase HASH_ALG_SHA224:\n\t\t*spu2_type = SPU2_HASH_TYPE_SHA224;\n\t\tbreak;\n\tcase HASH_ALG_SHA256:\n\t\t*spu2_type = SPU2_HASH_TYPE_SHA256;\n\t\tbreak;\n\tcase HASH_ALG_SHA384:\n\t\t*spu2_type = SPU2_HASH_TYPE_SHA384;\n\t\tbreak;\n\tcase HASH_ALG_SHA512:\n\t\t*spu2_type = SPU2_HASH_TYPE_SHA512;\n\t\tbreak;\n\tcase HASH_ALG_AES:\n\t\tswitch (ciph_type) {\n\t\tcase CIPHER_TYPE_AES128:\n\t\t\t*spu2_type = SPU2_HASH_TYPE_AES128;\n\t\t\tbreak;\n\t\tcase CIPHER_TYPE_AES192:\n\t\t\t*spu2_type = SPU2_HASH_TYPE_AES192;\n\t\t\tbreak;\n\t\tcase CIPHER_TYPE_AES256:\n\t\t\t*spu2_type = SPU2_HASH_TYPE_AES256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase HASH_ALG_SHA3_224:\n\t\t*spu2_type = SPU2_HASH_TYPE_SHA3_224;\n\t\tbreak;\n\tcase HASH_ALG_SHA3_256:\n\t\t*spu2_type = SPU2_HASH_TYPE_SHA3_256;\n\t\tbreak;\n\tcase HASH_ALG_SHA3_384:\n\t\t*spu2_type = SPU2_HASH_TYPE_SHA3_384;\n\t\tbreak;\n\tcase HASH_ALG_SHA3_512:\n\t\t*spu2_type = SPU2_HASH_TYPE_SHA3_512;\n\t\tbreak;\n\tcase HASH_ALG_LAST:\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\tflow_log(\"Invalid hash alg %d or type %d\\n\",\n\t\t\t hash_alg, hash_type);\n\treturn err;\n}\n\n \nstatic void spu2_dump_fmd_ctrl0(u64 ctrl0)\n{\n\tenum spu2_cipher_type ciph_type;\n\tenum spu2_cipher_mode ciph_mode;\n\tenum spu2_hash_type hash_type;\n\tenum spu2_hash_mode hash_mode;\n\tchar *ciph_name;\n\tchar *ciph_mode_name;\n\tchar *hash_name;\n\tchar *hash_mode_name;\n\tu8 cfb;\n\tu8 proto;\n\n\tpacket_log(\" FMD CTRL0 %#16llx\\n\", ctrl0);\n\tif (ctrl0 & SPU2_CIPH_ENCRYPT_EN)\n\t\tpacket_log(\"  encrypt\\n\");\n\telse\n\t\tpacket_log(\"  decrypt\\n\");\n\n\tciph_type = (ctrl0 & SPU2_CIPH_TYPE) >> SPU2_CIPH_TYPE_SHIFT;\n\tciph_name = spu2_ciph_type_name(ciph_type);\n\tpacket_log(\"  Cipher type: %s\\n\", ciph_name);\n\n\tif (ciph_type != SPU2_CIPHER_TYPE_NONE) {\n\t\tciph_mode = (ctrl0 & SPU2_CIPH_MODE) >> SPU2_CIPH_MODE_SHIFT;\n\t\tciph_mode_name = spu2_ciph_mode_name(ciph_mode);\n\t\tpacket_log(\"  Cipher mode: %s\\n\", ciph_mode_name);\n\t}\n\n\tcfb = (ctrl0 & SPU2_CFB_MASK) >> SPU2_CFB_MASK_SHIFT;\n\tpacket_log(\"  CFB %#x\\n\", cfb);\n\n\tproto = (ctrl0 & SPU2_PROTO_SEL) >> SPU2_PROTO_SEL_SHIFT;\n\tpacket_log(\"  protocol %#x\\n\", proto);\n\n\tif (ctrl0 & SPU2_HASH_FIRST)\n\t\tpacket_log(\"  hash first\\n\");\n\telse\n\t\tpacket_log(\"  cipher first\\n\");\n\n\tif (ctrl0 & SPU2_CHK_TAG)\n\t\tpacket_log(\"  check tag\\n\");\n\n\thash_type = (ctrl0 & SPU2_HASH_TYPE) >> SPU2_HASH_TYPE_SHIFT;\n\thash_name = spu2_hash_type_name(hash_type);\n\tpacket_log(\"  Hash type: %s\\n\", hash_name);\n\n\tif (hash_type != SPU2_HASH_TYPE_NONE) {\n\t\thash_mode = (ctrl0 & SPU2_HASH_MODE) >> SPU2_HASH_MODE_SHIFT;\n\t\thash_mode_name = spu2_hash_mode_name(hash_mode);\n\t\tpacket_log(\"  Hash mode: %s\\n\", hash_mode_name);\n\t}\n\n\tif (ctrl0 & SPU2_CIPH_PAD_EN) {\n\t\tpacket_log(\"  Cipher pad: %#2llx\\n\",\n\t\t\t   (ctrl0 & SPU2_CIPH_PAD) >> SPU2_CIPH_PAD_SHIFT);\n\t}\n}\n\n \nstatic void spu2_dump_fmd_ctrl1(u64 ctrl1)\n{\n\tu8 hash_key_len;\n\tu8 ciph_key_len;\n\tu8 ret_iv_len;\n\tu8 iv_offset;\n\tu8 iv_len;\n\tu8 hash_tag_len;\n\tu8 ret_md;\n\n\tpacket_log(\" FMD CTRL1 %#16llx\\n\", ctrl1);\n\tif (ctrl1 & SPU2_TAG_LOC)\n\t\tpacket_log(\"  Tag after payload\\n\");\n\n\tpacket_log(\"  Msg includes \");\n\tif (ctrl1 & SPU2_HAS_FR_DATA)\n\t\tpacket_log(\"FD \");\n\tif (ctrl1 & SPU2_HAS_AAD1)\n\t\tpacket_log(\"AAD1 \");\n\tif (ctrl1 & SPU2_HAS_NAAD)\n\t\tpacket_log(\"NAAD \");\n\tif (ctrl1 & SPU2_HAS_AAD2)\n\t\tpacket_log(\"AAD2 \");\n\tif (ctrl1 & SPU2_HAS_ESN)\n\t\tpacket_log(\"ESN \");\n\tpacket_log(\"\\n\");\n\n\thash_key_len = (ctrl1 & SPU2_HASH_KEY_LEN) >> SPU2_HASH_KEY_LEN_SHIFT;\n\tpacket_log(\"  Hash key len %u\\n\", hash_key_len);\n\n\tciph_key_len = (ctrl1 & SPU2_CIPH_KEY_LEN) >> SPU2_CIPH_KEY_LEN_SHIFT;\n\tpacket_log(\"  Cipher key len %u\\n\", ciph_key_len);\n\n\tif (ctrl1 & SPU2_GENIV)\n\t\tpacket_log(\"  Generate IV\\n\");\n\n\tif (ctrl1 & SPU2_HASH_IV)\n\t\tpacket_log(\"  IV included in hash\\n\");\n\n\tif (ctrl1 & SPU2_RET_IV)\n\t\tpacket_log(\"  Return IV in output before payload\\n\");\n\n\tret_iv_len = (ctrl1 & SPU2_RET_IV_LEN) >> SPU2_RET_IV_LEN_SHIFT;\n\tpacket_log(\"  Length of returned IV %u bytes\\n\",\n\t\t   ret_iv_len ? ret_iv_len : 16);\n\n\tiv_offset = (ctrl1 & SPU2_IV_OFFSET) >> SPU2_IV_OFFSET_SHIFT;\n\tpacket_log(\"  IV offset %u\\n\", iv_offset);\n\n\tiv_len = (ctrl1 & SPU2_IV_LEN) >> SPU2_IV_LEN_SHIFT;\n\tpacket_log(\"  Input IV len %u bytes\\n\", iv_len);\n\n\thash_tag_len = (ctrl1 & SPU2_HASH_TAG_LEN) >> SPU2_HASH_TAG_LEN_SHIFT;\n\tpacket_log(\"  Hash tag length %u bytes\\n\", hash_tag_len);\n\n\tpacket_log(\"  Return \");\n\tret_md = (ctrl1 & SPU2_RETURN_MD) >> SPU2_RETURN_MD_SHIFT;\n\tif (ret_md)\n\t\tpacket_log(\"FMD \");\n\tif (ret_md == SPU2_RET_FMD_OMD)\n\t\tpacket_log(\"OMD \");\n\telse if (ret_md == SPU2_RET_FMD_OMD_IV)\n\t\tpacket_log(\"OMD IV \");\n\tif (ctrl1 & SPU2_RETURN_FD)\n\t\tpacket_log(\"FD \");\n\tif (ctrl1 & SPU2_RETURN_AAD1)\n\t\tpacket_log(\"AAD1 \");\n\tif (ctrl1 & SPU2_RETURN_NAAD)\n\t\tpacket_log(\"NAAD \");\n\tif (ctrl1 & SPU2_RETURN_AAD2)\n\t\tpacket_log(\"AAD2 \");\n\tif (ctrl1 & SPU2_RETURN_PAY)\n\t\tpacket_log(\"Payload\");\n\tpacket_log(\"\\n\");\n}\n\n \nstatic void spu2_dump_fmd_ctrl2(u64 ctrl2)\n{\n\tpacket_log(\" FMD CTRL2 %#16llx\\n\", ctrl2);\n\n\tpacket_log(\"  AAD1 offset %llu length %llu bytes\\n\",\n\t\t   ctrl2 & SPU2_AAD1_OFFSET,\n\t\t   (ctrl2 & SPU2_AAD1_LEN) >> SPU2_AAD1_LEN_SHIFT);\n\tpacket_log(\"  AAD2 offset %llu\\n\",\n\t\t   (ctrl2 & SPU2_AAD2_OFFSET) >> SPU2_AAD2_OFFSET_SHIFT);\n\tpacket_log(\"  Payload offset %llu\\n\",\n\t\t   (ctrl2 & SPU2_PL_OFFSET) >> SPU2_PL_OFFSET_SHIFT);\n}\n\n \nstatic void spu2_dump_fmd_ctrl3(u64 ctrl3)\n{\n\tpacket_log(\" FMD CTRL3 %#16llx\\n\", ctrl3);\n\n\tpacket_log(\"  Payload length %llu bytes\\n\", ctrl3 & SPU2_PL_LEN);\n\tpacket_log(\"  TLS length %llu bytes\\n\",\n\t\t   (ctrl3 & SPU2_TLS_LEN) >> SPU2_TLS_LEN_SHIFT);\n}\n\nstatic void spu2_dump_fmd(struct SPU2_FMD *fmd)\n{\n\tspu2_dump_fmd_ctrl0(le64_to_cpu(fmd->ctrl0));\n\tspu2_dump_fmd_ctrl1(le64_to_cpu(fmd->ctrl1));\n\tspu2_dump_fmd_ctrl2(le64_to_cpu(fmd->ctrl2));\n\tspu2_dump_fmd_ctrl3(le64_to_cpu(fmd->ctrl3));\n}\n\nstatic void spu2_dump_omd(u8 *omd, u16 hash_key_len, u16 ciph_key_len,\n\t\t\t  u16 hash_iv_len, u16 ciph_iv_len)\n{\n\tu8 *ptr = omd;\n\n\tpacket_log(\" OMD:\\n\");\n\n\tif (hash_key_len) {\n\t\tpacket_log(\"  Hash Key Length %u bytes\\n\", hash_key_len);\n\t\tpacket_dump(\"  KEY: \", ptr, hash_key_len);\n\t\tptr += hash_key_len;\n\t}\n\n\tif (ciph_key_len) {\n\t\tpacket_log(\"  Cipher Key Length %u bytes\\n\", ciph_key_len);\n\t\tpacket_dump(\"  KEY: \", ptr, ciph_key_len);\n\t\tptr += ciph_key_len;\n\t}\n\n\tif (hash_iv_len) {\n\t\tpacket_log(\"  Hash IV Length %u bytes\\n\", hash_iv_len);\n\t\tpacket_dump(\"  hash IV: \", ptr, hash_iv_len);\n\t\tptr += ciph_key_len;\n\t}\n\n\tif (ciph_iv_len) {\n\t\tpacket_log(\"  Cipher IV Length %u bytes\\n\", ciph_iv_len);\n\t\tpacket_dump(\"  cipher IV: \", ptr, ciph_iv_len);\n\t}\n}\n\n \nvoid spu2_dump_msg_hdr(u8 *buf, unsigned int buf_len)\n{\n\tstruct SPU2_FMD *fmd = (struct SPU2_FMD *)buf;\n\tu8 *omd;\n\tu64 ctrl1;\n\tu16 hash_key_len;\n\tu16 ciph_key_len;\n\tu16 hash_iv_len;\n\tu16 ciph_iv_len;\n\tu16 omd_len;\n\n\tpacket_log(\"\\n\");\n\tpacket_log(\"SPU2 message header %p len: %u\\n\", buf, buf_len);\n\n\tspu2_dump_fmd(fmd);\n\tomd = (u8 *)(fmd + 1);\n\n\tctrl1 = le64_to_cpu(fmd->ctrl1);\n\thash_key_len = (ctrl1 & SPU2_HASH_KEY_LEN) >> SPU2_HASH_KEY_LEN_SHIFT;\n\tciph_key_len = (ctrl1 & SPU2_CIPH_KEY_LEN) >> SPU2_CIPH_KEY_LEN_SHIFT;\n\thash_iv_len = 0;\n\tciph_iv_len = (ctrl1 & SPU2_IV_LEN) >> SPU2_IV_LEN_SHIFT;\n\tspu2_dump_omd(omd, hash_key_len, ciph_key_len, hash_iv_len,\n\t\t      ciph_iv_len);\n\n\t \n\tomd_len = hash_key_len + ciph_key_len + hash_iv_len + ciph_iv_len;\n\tif (FMD_SIZE + omd_len != buf_len) {\n\t\tpacket_log\n\t\t    (\" Packet parsed incorrectly. buf_len %u, sum of MD %zu\\n\",\n\t\t     buf_len, FMD_SIZE + omd_len);\n\t}\n\tpacket_log(\"\\n\");\n}\n\n \nstatic int spu2_fmd_init(struct SPU2_FMD *fmd,\n\t\t\t enum spu2_cipher_type spu2_type,\n\t\t\t enum spu2_cipher_mode spu2_mode,\n\t\t\t u32 cipher_key_len, u32 cipher_iv_len)\n{\n\tu64 ctrl0;\n\tu64 ctrl1;\n\tu64 ctrl2;\n\tu64 ctrl3;\n\tu32 aad1_offset;\n\tu32 aad2_offset;\n\tu16 aad1_len = 0;\n\tu64 payload_offset;\n\n\tctrl0 = (spu2_type << SPU2_CIPH_TYPE_SHIFT) |\n\t    (spu2_mode << SPU2_CIPH_MODE_SHIFT);\n\n\tctrl1 = (cipher_key_len << SPU2_CIPH_KEY_LEN_SHIFT) |\n\t    ((u64)cipher_iv_len << SPU2_IV_LEN_SHIFT) |\n\t    ((u64)SPU2_RET_FMD_ONLY << SPU2_RETURN_MD_SHIFT) | SPU2_RETURN_PAY;\n\n\t \n\taad1_offset = 0;\n\taad2_offset = aad1_offset;\n\tpayload_offset = 0;\n\tctrl2 = aad1_offset |\n\t    (aad1_len << SPU2_AAD1_LEN_SHIFT) |\n\t    (aad2_offset << SPU2_AAD2_OFFSET_SHIFT) |\n\t    (payload_offset << SPU2_PL_OFFSET_SHIFT);\n\n\tctrl3 = 0;\n\n\tfmd->ctrl0 = cpu_to_le64(ctrl0);\n\tfmd->ctrl1 = cpu_to_le64(ctrl1);\n\tfmd->ctrl2 = cpu_to_le64(ctrl2);\n\tfmd->ctrl3 = cpu_to_le64(ctrl3);\n\n\treturn 0;\n}\n\n \nstatic void spu2_fmd_ctrl0_write(struct SPU2_FMD *fmd,\n\t\t\t\t bool is_inbound, bool auth_first,\n\t\t\t\t enum spu2_proto_sel protocol,\n\t\t\t\t enum spu2_cipher_type cipher_type,\n\t\t\t\t enum spu2_cipher_mode cipher_mode,\n\t\t\t\t enum spu2_hash_type auth_type,\n\t\t\t\t enum spu2_hash_mode auth_mode)\n{\n\tu64 ctrl0 = 0;\n\n\tif ((cipher_type != SPU2_CIPHER_TYPE_NONE) && !is_inbound)\n\t\tctrl0 |= SPU2_CIPH_ENCRYPT_EN;\n\n\tctrl0 |= ((u64)cipher_type << SPU2_CIPH_TYPE_SHIFT) |\n\t    ((u64)cipher_mode << SPU2_CIPH_MODE_SHIFT);\n\n\tif (protocol)\n\t\tctrl0 |= (u64)protocol << SPU2_PROTO_SEL_SHIFT;\n\n\tif (auth_first)\n\t\tctrl0 |= SPU2_HASH_FIRST;\n\n\tif (is_inbound && (auth_type != SPU2_HASH_TYPE_NONE))\n\t\tctrl0 |= SPU2_CHK_TAG;\n\n\tctrl0 |= (((u64)auth_type << SPU2_HASH_TYPE_SHIFT) |\n\t\t  ((u64)auth_mode << SPU2_HASH_MODE_SHIFT));\n\n\tfmd->ctrl0 = cpu_to_le64(ctrl0);\n}\n\n \nstatic void spu2_fmd_ctrl1_write(struct SPU2_FMD *fmd, bool is_inbound,\n\t\t\t\t u64 assoc_size,\n\t\t\t\t u64 auth_key_len, u64 cipher_key_len,\n\t\t\t\t bool gen_iv, bool hash_iv, bool return_iv,\n\t\t\t\t u64 ret_iv_len, u64 ret_iv_offset,\n\t\t\t\t u64 cipher_iv_len, u64 digest_size,\n\t\t\t\t bool return_payload, bool return_md)\n{\n\tu64 ctrl1 = 0;\n\n\tif (is_inbound && digest_size)\n\t\tctrl1 |= SPU2_TAG_LOC;\n\n\tif (assoc_size) {\n\t\tctrl1 |= SPU2_HAS_AAD2;\n\t\tctrl1 |= SPU2_RETURN_AAD2;   \n\t}\n\n\tif (auth_key_len)\n\t\tctrl1 |= ((auth_key_len << SPU2_HASH_KEY_LEN_SHIFT) &\n\t\t\t  SPU2_HASH_KEY_LEN);\n\n\tif (cipher_key_len)\n\t\tctrl1 |= ((cipher_key_len << SPU2_CIPH_KEY_LEN_SHIFT) &\n\t\t\t  SPU2_CIPH_KEY_LEN);\n\n\tif (gen_iv)\n\t\tctrl1 |= SPU2_GENIV;\n\n\tif (hash_iv)\n\t\tctrl1 |= SPU2_HASH_IV;\n\n\tif (return_iv) {\n\t\tctrl1 |= SPU2_RET_IV;\n\t\tctrl1 |= ret_iv_len << SPU2_RET_IV_LEN_SHIFT;\n\t\tctrl1 |= ret_iv_offset << SPU2_IV_OFFSET_SHIFT;\n\t}\n\n\tctrl1 |= ((cipher_iv_len << SPU2_IV_LEN_SHIFT) & SPU2_IV_LEN);\n\n\tif (digest_size)\n\t\tctrl1 |= ((digest_size << SPU2_HASH_TAG_LEN_SHIFT) &\n\t\t\t  SPU2_HASH_TAG_LEN);\n\n\t \n\tif (return_md)\n\t\tctrl1 |= ((u64)SPU2_RET_FMD_ONLY << SPU2_RETURN_MD_SHIFT);\n\telse\n\t\tctrl1 |= ((u64)SPU2_RET_NO_MD << SPU2_RETURN_MD_SHIFT);\n\n\t \n\n\tif (return_payload)\n\t\tctrl1 |= SPU2_RETURN_PAY;\n\n\tfmd->ctrl1 = cpu_to_le64(ctrl1);\n}\n\n \nstatic void spu2_fmd_ctrl2_write(struct SPU2_FMD *fmd, u64 cipher_offset,\n\t\t\t\t u64 auth_key_len, u64 auth_iv_len,\n\t\t\t\t u64 cipher_key_len, u64 cipher_iv_len)\n{\n\tu64 ctrl2;\n\tu64 aad1_offset;\n\tu64 aad2_offset;\n\tu16 aad1_len = 0;\n\tu64 payload_offset;\n\n\t \n\taad1_offset = 0;\n\n\taad2_offset = aad1_offset;\n\tpayload_offset = cipher_offset;\n\tctrl2 = aad1_offset |\n\t    (aad1_len << SPU2_AAD1_LEN_SHIFT) |\n\t    (aad2_offset << SPU2_AAD2_OFFSET_SHIFT) |\n\t    (payload_offset << SPU2_PL_OFFSET_SHIFT);\n\n\tfmd->ctrl2 = cpu_to_le64(ctrl2);\n}\n\n \nstatic void spu2_fmd_ctrl3_write(struct SPU2_FMD *fmd, u64 payload_len)\n{\n\tu64 ctrl3;\n\n\tctrl3 = payload_len & SPU2_PL_LEN;\n\n\tfmd->ctrl3 = cpu_to_le64(ctrl3);\n}\n\n \nu32 spu2_ctx_max_payload(enum spu_cipher_alg cipher_alg,\n\t\t\t enum spu_cipher_mode cipher_mode,\n\t\t\t unsigned int blocksize)\n{\n\tif ((cipher_alg == CIPHER_ALG_AES) &&\n\t    (cipher_mode == CIPHER_MODE_CCM)) {\n\t\tu32 excess = SPU2_MAX_PAYLOAD % blocksize;\n\n\t\treturn SPU2_MAX_PAYLOAD - excess;\n\t} else {\n\t\treturn SPU_MAX_PAYLOAD_INF;\n\t}\n}\n\n \nu32 spu2_payload_length(u8 *spu_hdr)\n{\n\tstruct SPU2_FMD *fmd = (struct SPU2_FMD *)spu_hdr;\n\tu32 pl_len;\n\tu64 ctrl3;\n\n\tctrl3 = le64_to_cpu(fmd->ctrl3);\n\tpl_len = ctrl3 & SPU2_PL_LEN;\n\n\treturn pl_len;\n}\n\n \nu16 spu2_response_hdr_len(u16 auth_key_len, u16 enc_key_len, bool is_hash)\n{\n\treturn FMD_SIZE;\n}\n\n \nu16 spu2_hash_pad_len(enum hash_alg hash_alg, enum hash_mode hash_mode,\n\t\t      u32 chunksize, u16 hash_block_size)\n{\n\treturn 0;\n}\n\n \nu32 spu2_gcm_ccm_pad_len(enum spu_cipher_mode cipher_mode,\n\t\t\t unsigned int data_size)\n{\n\treturn 0;\n}\n\n \nu32 spu2_assoc_resp_len(enum spu_cipher_mode cipher_mode,\n\t\t\tunsigned int assoc_len, unsigned int iv_len,\n\t\t\tbool is_encrypt)\n{\n\tu32 resp_len = assoc_len;\n\n\tif (is_encrypt)\n\t\t \n\t\tresp_len += iv_len;\n\treturn resp_len;\n}\n\n \nu8 spu2_aead_ivlen(enum spu_cipher_mode cipher_mode, u16 iv_len)\n{\n\treturn 0;\n}\n\n \nenum hash_type spu2_hash_type(u32 src_sent)\n{\n\treturn HASH_TYPE_FULL;\n}\n\n \nu32 spu2_digest_size(u32 alg_digest_size, enum hash_alg alg,\n\t\t     enum hash_type htype)\n{\n\treturn alg_digest_size;\n}\n\n \nu32 spu2_create_request(u8 *spu_hdr,\n\t\t\tstruct spu_request_opts *req_opts,\n\t\t\tstruct spu_cipher_parms *cipher_parms,\n\t\t\tstruct spu_hash_parms *hash_parms,\n\t\t\tstruct spu_aead_parms *aead_parms,\n\t\t\tunsigned int data_size)\n{\n\tstruct SPU2_FMD *fmd;\n\tu8 *ptr;\n\tunsigned int buf_len;\n\tint err;\n\tenum spu2_cipher_type spu2_ciph_type = SPU2_CIPHER_TYPE_NONE;\n\tenum spu2_cipher_mode spu2_ciph_mode;\n\tenum spu2_hash_type spu2_auth_type = SPU2_HASH_TYPE_NONE;\n\tenum spu2_hash_mode spu2_auth_mode;\n\tbool return_md = true;\n\tenum spu2_proto_sel proto = SPU2_PROTO_RESV;\n\n\t \n\tunsigned int payload_len =\n\t    hash_parms->prebuf_len + data_size + hash_parms->pad_len -\n\t    ((req_opts->is_aead && req_opts->is_inbound) ?\n\t     hash_parms->digestsize : 0);\n\n\t \n\tunsigned int cipher_offset = aead_parms->assoc_size +\n\t\t\taead_parms->aad_pad_len + aead_parms->iv_len;\n\n\t \n\tunsigned int real_db_size = spu_real_db_size(aead_parms->assoc_size,\n\t\t\t\t\t\t aead_parms->iv_len,\n\t\t\t\t\t\t hash_parms->prebuf_len,\n\t\t\t\t\t\t data_size,\n\t\t\t\t\t\t aead_parms->aad_pad_len,\n\t\t\t\t\t\t aead_parms->data_pad_len,\n\t\t\t\t\t\t hash_parms->pad_len);\n\tunsigned int assoc_size = aead_parms->assoc_size;\n\n\tif (req_opts->is_aead &&\n\t    (cipher_parms->alg == CIPHER_ALG_AES) &&\n\t    (cipher_parms->mode == CIPHER_MODE_GCM))\n\t\t \n\t\treq_opts->auth_first = req_opts->is_inbound;\n\n\t \n\tif (req_opts->is_aead &&\n\t    (cipher_parms->alg == CIPHER_ALG_AES) &&\n\t    (cipher_parms->mode == CIPHER_MODE_CCM))\n\t\treq_opts->auth_first = !req_opts->is_inbound;\n\n\tflow_log(\"%s()\\n\", __func__);\n\tflow_log(\"  in:%u authFirst:%u\\n\",\n\t\t req_opts->is_inbound, req_opts->auth_first);\n\tflow_log(\"  cipher alg:%u mode:%u type %u\\n\", cipher_parms->alg,\n\t\t cipher_parms->mode, cipher_parms->type);\n\tflow_log(\"  is_esp: %s\\n\", req_opts->is_esp ? \"yes\" : \"no\");\n\tflow_log(\"    key: %d\\n\", cipher_parms->key_len);\n\tflow_dump(\"    key: \", cipher_parms->key_buf, cipher_parms->key_len);\n\tflow_log(\"    iv: %d\\n\", cipher_parms->iv_len);\n\tflow_dump(\"    iv: \", cipher_parms->iv_buf, cipher_parms->iv_len);\n\tflow_log(\"  auth alg:%u mode:%u type %u\\n\",\n\t\t hash_parms->alg, hash_parms->mode, hash_parms->type);\n\tflow_log(\"  digestsize: %u\\n\", hash_parms->digestsize);\n\tflow_log(\"  authkey: %d\\n\", hash_parms->key_len);\n\tflow_dump(\"  authkey: \", hash_parms->key_buf, hash_parms->key_len);\n\tflow_log(\"  assoc_size:%u\\n\", assoc_size);\n\tflow_log(\"  prebuf_len:%u\\n\", hash_parms->prebuf_len);\n\tflow_log(\"  data_size:%u\\n\", data_size);\n\tflow_log(\"  hash_pad_len:%u\\n\", hash_parms->pad_len);\n\tflow_log(\"  real_db_size:%u\\n\", real_db_size);\n\tflow_log(\"  cipher_offset:%u payload_len:%u\\n\",\n\t\t cipher_offset, payload_len);\n\tflow_log(\"  aead_iv: %u\\n\", aead_parms->iv_len);\n\n\t \n\terr = spu2_cipher_xlate(cipher_parms->alg, cipher_parms->mode,\n\t\t\t\tcipher_parms->type,\n\t\t\t\t&spu2_ciph_type, &spu2_ciph_mode);\n\n\t \n\tif ((req_opts->is_rfc4543) ||\n\t    ((spu2_ciph_mode == SPU2_CIPHER_MODE_GCM) &&\n\t    (payload_len == 0))) {\n\t\t \n\t\tspu2_ciph_type = SPU2_CIPHER_TYPE_NONE;\n\t\thash_parms->key_len = cipher_parms->key_len;\n\t\tmemcpy(hash_parms->key_buf, cipher_parms->key_buf,\n\t\t       cipher_parms->key_len);\n\t\tcipher_parms->key_len = 0;\n\n\t\tif (req_opts->is_rfc4543)\n\t\t\tpayload_len += assoc_size;\n\t\telse\n\t\t\tpayload_len = assoc_size;\n\t\tcipher_offset = 0;\n\t\tassoc_size = 0;\n\t}\n\n\tif (err)\n\t\treturn 0;\n\n\tflow_log(\"spu2 cipher type %s, cipher mode %s\\n\",\n\t\t spu2_ciph_type_name(spu2_ciph_type),\n\t\t spu2_ciph_mode_name(spu2_ciph_mode));\n\n\terr = spu2_hash_xlate(hash_parms->alg, hash_parms->mode,\n\t\t\t      hash_parms->type,\n\t\t\t      cipher_parms->type,\n\t\t\t      &spu2_auth_type, &spu2_auth_mode);\n\tif (err)\n\t\treturn 0;\n\n\tflow_log(\"spu2 hash type %s, hash mode %s\\n\",\n\t\t spu2_hash_type_name(spu2_auth_type),\n\t\t spu2_hash_mode_name(spu2_auth_mode));\n\n\tfmd = (struct SPU2_FMD *)spu_hdr;\n\n\tspu2_fmd_ctrl0_write(fmd, req_opts->is_inbound, req_opts->auth_first,\n\t\t\t     proto, spu2_ciph_type, spu2_ciph_mode,\n\t\t\t     spu2_auth_type, spu2_auth_mode);\n\n\tspu2_fmd_ctrl1_write(fmd, req_opts->is_inbound, assoc_size,\n\t\t\t     hash_parms->key_len, cipher_parms->key_len,\n\t\t\t     false, false,\n\t\t\t     aead_parms->return_iv, aead_parms->ret_iv_len,\n\t\t\t     aead_parms->ret_iv_off,\n\t\t\t     cipher_parms->iv_len, hash_parms->digestsize,\n\t\t\t     !req_opts->bd_suppress, return_md);\n\n\tspu2_fmd_ctrl2_write(fmd, cipher_offset, hash_parms->key_len, 0,\n\t\t\t     cipher_parms->key_len, cipher_parms->iv_len);\n\n\tspu2_fmd_ctrl3_write(fmd, payload_len);\n\n\tptr = (u8 *)(fmd + 1);\n\tbuf_len = sizeof(struct SPU2_FMD);\n\n\t \n\tif (hash_parms->key_len) {\n\t\tmemcpy(ptr, hash_parms->key_buf, hash_parms->key_len);\n\t\tptr += hash_parms->key_len;\n\t\tbuf_len += hash_parms->key_len;\n\t}\n\tif (cipher_parms->key_len) {\n\t\tmemcpy(ptr, cipher_parms->key_buf, cipher_parms->key_len);\n\t\tptr += cipher_parms->key_len;\n\t\tbuf_len += cipher_parms->key_len;\n\t}\n\tif (cipher_parms->iv_len) {\n\t\tmemcpy(ptr, cipher_parms->iv_buf, cipher_parms->iv_len);\n\t\tptr += cipher_parms->iv_len;\n\t\tbuf_len += cipher_parms->iv_len;\n\t}\n\n\tpacket_dump(\"  SPU request header: \", spu_hdr, buf_len);\n\n\treturn buf_len;\n}\n\n \nu16 spu2_cipher_req_init(u8 *spu_hdr, struct spu_cipher_parms *cipher_parms)\n{\n\tstruct SPU2_FMD *fmd;\n\tu8 *omd;\n\tenum spu2_cipher_type spu2_type = SPU2_CIPHER_TYPE_NONE;\n\tenum spu2_cipher_mode spu2_mode;\n\tint err;\n\n\tflow_log(\"%s()\\n\", __func__);\n\tflow_log(\"  cipher alg:%u mode:%u type %u\\n\", cipher_parms->alg,\n\t\t cipher_parms->mode, cipher_parms->type);\n\tflow_log(\"  cipher_iv_len: %u\\n\", cipher_parms->iv_len);\n\tflow_log(\"    key: %d\\n\", cipher_parms->key_len);\n\tflow_dump(\"    key: \", cipher_parms->key_buf, cipher_parms->key_len);\n\n\t \n\terr = spu2_cipher_xlate(cipher_parms->alg, cipher_parms->mode,\n\t\t\t\tcipher_parms->type, &spu2_type, &spu2_mode);\n\tif (err)\n\t\treturn 0;\n\n\tflow_log(\"spu2 cipher type %s, cipher mode %s\\n\",\n\t\t spu2_ciph_type_name(spu2_type),\n\t\t spu2_ciph_mode_name(spu2_mode));\n\n\t \n\tfmd = (struct SPU2_FMD *)spu_hdr;\n\terr = spu2_fmd_init(fmd, spu2_type, spu2_mode, cipher_parms->key_len,\n\t\t\t    cipher_parms->iv_len);\n\tif (err)\n\t\treturn 0;\n\n\t \n\tomd = (u8 *)(fmd + 1);\n\tif (cipher_parms->key_buf && cipher_parms->key_len)\n\t\tmemcpy(omd, cipher_parms->key_buf, cipher_parms->key_len);\n\n\tpacket_dump(\"  SPU request header: \", spu_hdr,\n\t\t    FMD_SIZE + cipher_parms->key_len + cipher_parms->iv_len);\n\n\treturn FMD_SIZE + cipher_parms->key_len + cipher_parms->iv_len;\n}\n\n \nvoid spu2_cipher_req_finish(u8 *spu_hdr,\n\t\t\t    u16 spu_req_hdr_len,\n\t\t\t    unsigned int is_inbound,\n\t\t\t    struct spu_cipher_parms *cipher_parms,\n\t\t\t    unsigned int data_size)\n{\n\tstruct SPU2_FMD *fmd;\n\tu8 *omd;\t\t \n\tu64 ctrl0;\n\tu64 ctrl3;\n\n\tflow_log(\"%s()\\n\", __func__);\n\tflow_log(\" in: %u\\n\", is_inbound);\n\tflow_log(\" cipher alg: %u, cipher_type: %u\\n\", cipher_parms->alg,\n\t\t cipher_parms->type);\n\tflow_log(\" iv len: %d\\n\", cipher_parms->iv_len);\n\tflow_dump(\"    iv: \", cipher_parms->iv_buf, cipher_parms->iv_len);\n\tflow_log(\" data_size: %u\\n\", data_size);\n\n\tfmd = (struct SPU2_FMD *)spu_hdr;\n\tomd = (u8 *)(fmd + 1);\n\n\t \n\tctrl0 = le64_to_cpu(fmd->ctrl0);\n\tif (is_inbound)\n\t\tctrl0 &= ~SPU2_CIPH_ENCRYPT_EN;\t \n\telse\n\t\tctrl0 |= SPU2_CIPH_ENCRYPT_EN;\t \n\tfmd->ctrl0 = cpu_to_le64(ctrl0);\n\n\tif (cipher_parms->alg && cipher_parms->iv_buf && cipher_parms->iv_len) {\n\t\t \n\t\tmemcpy(omd + cipher_parms->key_len, cipher_parms->iv_buf,\n\t\t       cipher_parms->iv_len);\n\t}\n\n\tctrl3 = le64_to_cpu(fmd->ctrl3);\n\tdata_size &= SPU2_PL_LEN;\n\tctrl3 |= data_size;\n\tfmd->ctrl3 = cpu_to_le64(ctrl3);\n\n\tpacket_dump(\"  SPU request header: \", spu_hdr, spu_req_hdr_len);\n}\n\n \nvoid spu2_request_pad(u8 *pad_start, u32 gcm_padding, u32 hash_pad_len,\n\t\t      enum hash_alg auth_alg, enum hash_mode auth_mode,\n\t\t      unsigned int total_sent, u32 status_padding)\n{\n\tu8 *ptr = pad_start;\n\n\t \n\tif (gcm_padding > 0) {\n\t\tflow_log(\"  GCM: padding to 16 byte alignment: %u bytes\\n\",\n\t\t\t gcm_padding);\n\t\tmemset(ptr, 0, gcm_padding);\n\t\tptr += gcm_padding;\n\t}\n\n\tif (hash_pad_len > 0) {\n\t\t \n\t\tmemset(ptr, 0, hash_pad_len);\n\n\t\t \n\t\t*ptr = 0x80;\n\t\tptr += (hash_pad_len - sizeof(u64));\n\n\t\t \n\t\tif (auth_alg == HASH_ALG_MD5)\n\t\t\t*(__le64 *)ptr = cpu_to_le64(total_sent * 8ull);\n\t\telse\t\t \n\t\t\t*(__be64 *)ptr = cpu_to_be64(total_sent * 8ull);\n\t\tptr += sizeof(u64);\n\t}\n\n\t \n\tif (status_padding > 0) {\n\t\tflow_log(\"  STAT: padding to 4 byte alignment: %u bytes\\n\",\n\t\t\t status_padding);\n\n\t\tmemset(ptr, 0, status_padding);\n\t\tptr += status_padding;\n\t}\n}\n\n \nu8 spu2_xts_tweak_in_payload(void)\n{\n\treturn 0;\n}\n\n \nu8 spu2_tx_status_len(void)\n{\n\treturn SPU2_TX_STATUS_LEN;\n}\n\n \nu8 spu2_rx_status_len(void)\n{\n\treturn SPU2_RX_STATUS_LEN;\n}\n\n \nint spu2_status_process(u8 *statp)\n{\n\t \n\tu16 status = le16_to_cpu(*(__le16 *)statp);\n\n\tif (status == 0)\n\t\treturn 0;\n\n\tflow_log(\"rx status is %#x\\n\", status);\n\tif (status == SPU2_INVALID_ICV)\n\t\treturn SPU_INVALID_ICV;\n\n\treturn -EBADMSG;\n}\n\n \nvoid spu2_ccm_update_iv(unsigned int digestsize,\n\t\t\tstruct spu_cipher_parms *cipher_parms,\n\t\t\tunsigned int assoclen, unsigned int chunksize,\n\t\t\tbool is_encrypt, bool is_esp)\n{\n\tint L;   \n\n\t \n\tif (is_esp)\n\t\tL = CCM_ESP_L_VALUE;\n\telse\n\t\tL = ((cipher_parms->iv_buf[0] & CCM_B0_L_PRIME) >>\n\t\t      CCM_B0_L_PRIME_SHIFT) + 1;\n\n\t \n\tcipher_parms->iv_len -= (1 + L);\n\tmemmove(cipher_parms->iv_buf, &cipher_parms->iv_buf[1],\n\t\tcipher_parms->iv_len);\n}\n\n \nu32 spu2_wordalign_padlen(u32 data_size)\n{\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}