{
  "module_name": "hifn_795x.c",
  "hash_id": "c6b09b683a6b61555e81c16f7033a23336adbeeb8d500e541bcfa7faf6182d4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/hifn_795x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mod_devicetable.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/highmem.h>\n#include <linux/crypto.h>\n#include <linux/hw_random.h>\n#include <linux/ktime.h>\n\n#include <crypto/algapi.h>\n#include <crypto/internal/des.h>\n#include <crypto/internal/skcipher.h>\n\nstatic char hifn_pll_ref[sizeof(\"extNNN\")] = \"ext\";\nmodule_param_string(hifn_pll_ref, hifn_pll_ref, sizeof(hifn_pll_ref), 0444);\nMODULE_PARM_DESC(hifn_pll_ref,\n\t\t \"PLL reference clock (pci[freq] or ext[freq], default ext)\");\n\nstatic atomic_t hifn_dev_number;\n\n#define ACRYPTO_OP_DECRYPT\t0\n#define ACRYPTO_OP_ENCRYPT\t1\n#define ACRYPTO_OP_HMAC\t\t2\n#define ACRYPTO_OP_RNG\t\t3\n\n#define ACRYPTO_MODE_ECB\t\t0\n#define ACRYPTO_MODE_CBC\t\t1\n#define ACRYPTO_MODE_CFB\t\t2\n#define ACRYPTO_MODE_OFB\t\t3\n\n#define ACRYPTO_TYPE_AES_128\t0\n#define ACRYPTO_TYPE_AES_192\t1\n#define ACRYPTO_TYPE_AES_256\t2\n#define ACRYPTO_TYPE_3DES\t3\n#define ACRYPTO_TYPE_DES\t4\n\n#define PCI_VENDOR_ID_HIFN\t\t0x13A3\n#define PCI_DEVICE_ID_HIFN_7955\t\t0x0020\n#define\tPCI_DEVICE_ID_HIFN_7956\t\t0x001d\n\n \n\n#define HIFN_BAR0_SIZE\t\t\t0x1000\n#define HIFN_BAR1_SIZE\t\t\t0x2000\n#define HIFN_BAR2_SIZE\t\t\t0x8000\n\n \n\n#define HIFN_DMA_CRA\t\t\t0x0C\t \n#define HIFN_DMA_SDRA\t\t\t0x1C\t \n#define HIFN_DMA_RRA\t\t\t0x2C\t \n#define HIFN_DMA_DDRA\t\t\t0x3C\t \n#define HIFN_DMA_STCTL\t\t\t0x40\t \n#define HIFN_DMA_INTREN\t\t\t0x44\t \n#define HIFN_DMA_CFG1\t\t\t0x48\t \n#define HIFN_DMA_CFG2\t\t\t0x6C\t \n#define HIFN_CHIP_ID\t\t\t0x98\t \n\n \n#define\tHIFN_0_PUDATA\t\t0x00\t \n#define\tHIFN_0_PUCTRL\t\t0x04\t \n#define\tHIFN_0_PUISR\t\t0x08\t \n#define\tHIFN_0_PUCNFG\t\t0x0c\t \n#define\tHIFN_0_PUIER\t\t0x10\t \n#define\tHIFN_0_PUSTAT\t\t0x14\t \n#define\tHIFN_0_FIFOSTAT\t\t0x18\t \n#define\tHIFN_0_FIFOCNFG\t\t0x1c\t \n#define\tHIFN_0_SPACESIZE\t0x20\t \n\n \n#define\tHIFN_PUCTRL_CLRSRCFIFO\t0x0010\t \n#define\tHIFN_PUCTRL_STOP\t0x0008\t \n#define\tHIFN_PUCTRL_LOCKRAM\t0x0004\t \n#define\tHIFN_PUCTRL_DMAENA\t0x0002\t \n#define\tHIFN_PUCTRL_RESET\t0x0001\t \n\n \n#define\tHIFN_PUISR_CMDINVAL\t0x8000\t \n#define\tHIFN_PUISR_DATAERR\t0x4000\t \n#define\tHIFN_PUISR_SRCFIFO\t0x2000\t \n#define\tHIFN_PUISR_DSTFIFO\t0x1000\t \n#define\tHIFN_PUISR_DSTOVER\t0x0200\t \n#define\tHIFN_PUISR_SRCCMD\t0x0080\t \n#define\tHIFN_PUISR_SRCCTX\t0x0040\t \n#define\tHIFN_PUISR_SRCDATA\t0x0020\t \n#define\tHIFN_PUISR_DSTDATA\t0x0010\t \n#define\tHIFN_PUISR_DSTRESULT\t0x0004\t \n\n \n#define\tHIFN_PUCNFG_DRAMMASK\t0xe000\t \n#define\tHIFN_PUCNFG_DSZ_256K\t0x0000\t \n#define\tHIFN_PUCNFG_DSZ_512K\t0x2000\t \n#define\tHIFN_PUCNFG_DSZ_1M\t0x4000\t \n#define\tHIFN_PUCNFG_DSZ_2M\t0x6000\t \n#define\tHIFN_PUCNFG_DSZ_4M\t0x8000\t \n#define\tHIFN_PUCNFG_DSZ_8M\t0xa000\t \n#define\tHIFN_PUNCFG_DSZ_16M\t0xc000\t \n#define\tHIFN_PUCNFG_DSZ_32M\t0xe000\t \n#define\tHIFN_PUCNFG_DRAMREFRESH\t0x1800\t \n#define\tHIFN_PUCNFG_DRFR_512\t0x0000\t \n#define\tHIFN_PUCNFG_DRFR_256\t0x0800\t \n#define\tHIFN_PUCNFG_DRFR_128\t0x1000\t \n#define\tHIFN_PUCNFG_TCALLPHASES\t0x0200\t \n#define\tHIFN_PUCNFG_TCDRVTOTEM\t0x0100\t \n#define\tHIFN_PUCNFG_BIGENDIAN\t0x0080\t \n#define\tHIFN_PUCNFG_BUS32\t0x0040\t \n#define\tHIFN_PUCNFG_BUS16\t0x0000\t \n#define\tHIFN_PUCNFG_CHIPID\t0x0020\t \n#define\tHIFN_PUCNFG_DRAM\t0x0010\t \n#define\tHIFN_PUCNFG_SRAM\t0x0000\t \n#define\tHIFN_PUCNFG_COMPSING\t0x0004\t \n#define\tHIFN_PUCNFG_ENCCNFG\t0x0002\t \n\n \n#define\tHIFN_PUIER_CMDINVAL\t0x8000\t \n#define\tHIFN_PUIER_DATAERR\t0x4000\t \n#define\tHIFN_PUIER_SRCFIFO\t0x2000\t \n#define\tHIFN_PUIER_DSTFIFO\t0x1000\t \n#define\tHIFN_PUIER_DSTOVER\t0x0200\t \n#define\tHIFN_PUIER_SRCCMD\t0x0080\t \n#define\tHIFN_PUIER_SRCCTX\t0x0040\t \n#define\tHIFN_PUIER_SRCDATA\t0x0020\t \n#define\tHIFN_PUIER_DSTDATA\t0x0010\t \n#define\tHIFN_PUIER_DSTRESULT\t0x0004\t \n\n \n#define\tHIFN_PUSTAT_CMDINVAL\t0x8000\t \n#define\tHIFN_PUSTAT_DATAERR\t0x4000\t \n#define\tHIFN_PUSTAT_SRCFIFO\t0x2000\t \n#define\tHIFN_PUSTAT_DSTFIFO\t0x1000\t \n#define\tHIFN_PUSTAT_DSTOVER\t0x0200\t \n#define\tHIFN_PUSTAT_SRCCMD\t0x0080\t \n#define\tHIFN_PUSTAT_SRCCTX\t0x0040\t \n#define\tHIFN_PUSTAT_SRCDATA\t0x0020\t \n#define\tHIFN_PUSTAT_DSTDATA\t0x0010\t \n#define\tHIFN_PUSTAT_DSTRESULT\t0x0004\t \n#define\tHIFN_PUSTAT_CHIPREV\t0x00ff\t \n#define\tHIFN_PUSTAT_CHIPENA\t0xff00\t \n#define\tHIFN_PUSTAT_ENA_2\t0x1100\t \n#define\tHIFN_PUSTAT_ENA_1\t0x1000\t \n#define\tHIFN_PUSTAT_ENA_0\t0x3000\t \n#define\tHIFN_PUSTAT_REV_2\t0x0020\t \n#define\tHIFN_PUSTAT_REV_3\t0x0030\t \n\n \n#define\tHIFN_FIFOSTAT_SRC\t0x7f00\t \n#define\tHIFN_FIFOSTAT_DST\t0x007f\t \n\n \n#define\tHIFN_FIFOCNFG_THRESHOLD\t0x0400\t \n\n \n#define\tHIFN_1_DMA_CRAR\t\t0x0c\t \n#define\tHIFN_1_DMA_SRAR\t\t0x1c\t \n#define\tHIFN_1_DMA_RRAR\t\t0x2c\t \n#define\tHIFN_1_DMA_DRAR\t\t0x3c\t \n#define\tHIFN_1_DMA_CSR\t\t0x40\t \n#define\tHIFN_1_DMA_IER\t\t0x44\t \n#define\tHIFN_1_DMA_CNFG\t\t0x48\t \n#define\tHIFN_1_PLL\t\t0x4c\t \n#define\tHIFN_1_7811_RNGENA\t0x60\t \n#define\tHIFN_1_7811_RNGCFG\t0x64\t \n#define\tHIFN_1_7811_RNGDAT\t0x68\t \n#define\tHIFN_1_7811_RNGSTS\t0x6c\t \n#define\tHIFN_1_7811_MIPSRST\t0x94\t \n#define\tHIFN_1_REVID\t\t0x98\t \n#define\tHIFN_1_UNLOCK_SECRET1\t0xf4\n#define\tHIFN_1_UNLOCK_SECRET2\t0xfc\n#define\tHIFN_1_PUB_RESET\t0x204\t \n#define\tHIFN_1_PUB_BASE\t\t0x300\t \n#define\tHIFN_1_PUB_OPLEN\t0x304\t \n#define\tHIFN_1_PUB_OP\t\t0x308\t \n#define\tHIFN_1_PUB_STATUS\t0x30c\t \n#define\tHIFN_1_PUB_IEN\t\t0x310\t \n#define\tHIFN_1_RNG_CONFIG\t0x314\t \n#define\tHIFN_1_RNG_DATA\t\t0x318\t \n#define\tHIFN_1_PUB_MEM\t\t0x400\t \n#define\tHIFN_1_PUB_MEMEND\t0xbff\t \n\n \n#define\tHIFN_DMACSR_D_CTRLMASK\t0xc0000000\t \n#define\tHIFN_DMACSR_D_CTRL_NOP\t0x00000000\t \n#define\tHIFN_DMACSR_D_CTRL_DIS\t0x40000000\t \n#define\tHIFN_DMACSR_D_CTRL_ENA\t0x80000000\t \n#define\tHIFN_DMACSR_D_ABORT\t0x20000000\t \n#define\tHIFN_DMACSR_D_DONE\t0x10000000\t \n#define\tHIFN_DMACSR_D_LAST\t0x08000000\t \n#define\tHIFN_DMACSR_D_WAIT\t0x04000000\t \n#define\tHIFN_DMACSR_D_OVER\t0x02000000\t \n#define\tHIFN_DMACSR_R_CTRL\t0x00c00000\t \n#define\tHIFN_DMACSR_R_CTRL_NOP\t0x00000000\t \n#define\tHIFN_DMACSR_R_CTRL_DIS\t0x00400000\t \n#define\tHIFN_DMACSR_R_CTRL_ENA\t0x00800000\t \n#define\tHIFN_DMACSR_R_ABORT\t0x00200000\t \n#define\tHIFN_DMACSR_R_DONE\t0x00100000\t \n#define\tHIFN_DMACSR_R_LAST\t0x00080000\t \n#define\tHIFN_DMACSR_R_WAIT\t0x00040000\t \n#define\tHIFN_DMACSR_R_OVER\t0x00020000\t \n#define\tHIFN_DMACSR_S_CTRL\t0x0000c000\t \n#define\tHIFN_DMACSR_S_CTRL_NOP\t0x00000000\t \n#define\tHIFN_DMACSR_S_CTRL_DIS\t0x00004000\t \n#define\tHIFN_DMACSR_S_CTRL_ENA\t0x00008000\t \n#define\tHIFN_DMACSR_S_ABORT\t0x00002000\t \n#define\tHIFN_DMACSR_S_DONE\t0x00001000\t \n#define\tHIFN_DMACSR_S_LAST\t0x00000800\t \n#define\tHIFN_DMACSR_S_WAIT\t0x00000400\t \n#define\tHIFN_DMACSR_ILLW\t0x00000200\t \n#define\tHIFN_DMACSR_ILLR\t0x00000100\t \n#define\tHIFN_DMACSR_C_CTRL\t0x000000c0\t \n#define\tHIFN_DMACSR_C_CTRL_NOP\t0x00000000\t \n#define\tHIFN_DMACSR_C_CTRL_DIS\t0x00000040\t \n#define\tHIFN_DMACSR_C_CTRL_ENA\t0x00000080\t \n#define\tHIFN_DMACSR_C_ABORT\t0x00000020\t \n#define\tHIFN_DMACSR_C_DONE\t0x00000010\t \n#define\tHIFN_DMACSR_C_LAST\t0x00000008\t \n#define\tHIFN_DMACSR_C_WAIT\t0x00000004\t \n#define\tHIFN_DMACSR_PUBDONE\t0x00000002\t \n#define\tHIFN_DMACSR_ENGINE\t0x00000001\t \n\n \n#define\tHIFN_DMAIER_D_ABORT\t0x20000000\t \n#define\tHIFN_DMAIER_D_DONE\t0x10000000\t \n#define\tHIFN_DMAIER_D_LAST\t0x08000000\t \n#define\tHIFN_DMAIER_D_WAIT\t0x04000000\t \n#define\tHIFN_DMAIER_D_OVER\t0x02000000\t \n#define\tHIFN_DMAIER_R_ABORT\t0x00200000\t \n#define\tHIFN_DMAIER_R_DONE\t0x00100000\t \n#define\tHIFN_DMAIER_R_LAST\t0x00080000\t \n#define\tHIFN_DMAIER_R_WAIT\t0x00040000\t \n#define\tHIFN_DMAIER_R_OVER\t0x00020000\t \n#define\tHIFN_DMAIER_S_ABORT\t0x00002000\t \n#define\tHIFN_DMAIER_S_DONE\t0x00001000\t \n#define\tHIFN_DMAIER_S_LAST\t0x00000800\t \n#define\tHIFN_DMAIER_S_WAIT\t0x00000400\t \n#define\tHIFN_DMAIER_ILLW\t0x00000200\t \n#define\tHIFN_DMAIER_ILLR\t0x00000100\t \n#define\tHIFN_DMAIER_C_ABORT\t0x00000020\t \n#define\tHIFN_DMAIER_C_DONE\t0x00000010\t \n#define\tHIFN_DMAIER_C_LAST\t0x00000008\t \n#define\tHIFN_DMAIER_C_WAIT\t0x00000004\t \n#define\tHIFN_DMAIER_PUBDONE\t0x00000002\t \n#define\tHIFN_DMAIER_ENGINE\t0x00000001\t \n\n \n#define\tHIFN_DMACNFG_BIGENDIAN\t0x10000000\t \n#define\tHIFN_DMACNFG_POLLFREQ\t0x00ff0000\t \n#define\tHIFN_DMACNFG_UNLOCK\t0x00000800\n#define\tHIFN_DMACNFG_POLLINVAL\t0x00000700\t \n#define\tHIFN_DMACNFG_LAST\t0x00000010\t \n#define\tHIFN_DMACNFG_MODE\t0x00000004\t \n#define\tHIFN_DMACNFG_DMARESET\t0x00000002\t \n#define\tHIFN_DMACNFG_MSTRESET\t0x00000001\t \n\n \n#define HIFN_PLL_REF_CLK_HBI\t0x00000000\t \n#define HIFN_PLL_REF_CLK_PLL\t0x00000001\t \n#define HIFN_PLL_BP\t\t0x00000002\t \n#define HIFN_PLL_PK_CLK_HBI\t0x00000000\t \n#define HIFN_PLL_PK_CLK_PLL\t0x00000008\t \n#define HIFN_PLL_PE_CLK_HBI\t0x00000000\t \n#define HIFN_PLL_PE_CLK_PLL\t0x00000010\t \n#define HIFN_PLL_RESERVED_1\t0x00000400\t \n#define HIFN_PLL_ND_SHIFT\t11\t\t \n#define HIFN_PLL_ND_MULT_2\t0x00000000\t \n#define HIFN_PLL_ND_MULT_4\t0x00000800\t \n#define HIFN_PLL_ND_MULT_6\t0x00001000\t \n#define HIFN_PLL_ND_MULT_8\t0x00001800\t \n#define HIFN_PLL_ND_MULT_10\t0x00002000\t \n#define HIFN_PLL_ND_MULT_12\t0x00002800\t \n#define HIFN_PLL_IS_1_8\t\t0x00000000\t \n#define HIFN_PLL_IS_9_12\t0x00010000\t \n\n#define HIFN_PLL_FCK_MAX\t266\t\t \n\n \n#define\tHIFN_PUBRST_RESET\t0x00000001\t \n\n \n#define\tHIFN_PUBBASE_ADDR\t0x00003fff\t \n\n \n#define\tHIFN_PUBOPLEN_MOD_M\t0x0000007f\t \n#define\tHIFN_PUBOPLEN_MOD_S\t0\t\t \n#define\tHIFN_PUBOPLEN_EXP_M\t0x0003ff80\t \n#define\tHIFN_PUBOPLEN_EXP_S\t7\t\t \n#define\tHIFN_PUBOPLEN_RED_M\t0x003c0000\t \n#define\tHIFN_PUBOPLEN_RED_S\t18\t\t \n\n \n#define\tHIFN_PUBOP_AOFFSET_M\t0x0000007f\t \n#define\tHIFN_PUBOP_AOFFSET_S\t0\t\t \n#define\tHIFN_PUBOP_BOFFSET_M\t0x00000f80\t \n#define\tHIFN_PUBOP_BOFFSET_S\t7\t\t \n#define\tHIFN_PUBOP_MOFFSET_M\t0x0003f000\t \n#define\tHIFN_PUBOP_MOFFSET_S\t12\t\t \n#define\tHIFN_PUBOP_OP_MASK\t0x003c0000\t \n#define\tHIFN_PUBOP_OP_NOP\t0x00000000\t \n#define\tHIFN_PUBOP_OP_ADD\t0x00040000\t \n#define\tHIFN_PUBOP_OP_ADDC\t0x00080000\t \n#define\tHIFN_PUBOP_OP_SUB\t0x000c0000\t \n#define\tHIFN_PUBOP_OP_SUBC\t0x00100000\t \n#define\tHIFN_PUBOP_OP_MODADD\t0x00140000\t \n#define\tHIFN_PUBOP_OP_MODSUB\t0x00180000\t \n#define\tHIFN_PUBOP_OP_INCA\t0x001c0000\t \n#define\tHIFN_PUBOP_OP_DECA\t0x00200000\t \n#define\tHIFN_PUBOP_OP_MULT\t0x00240000\t \n#define\tHIFN_PUBOP_OP_MODMULT\t0x00280000\t \n#define\tHIFN_PUBOP_OP_MODRED\t0x002c0000\t \n#define\tHIFN_PUBOP_OP_MODEXP\t0x00300000\t \n\n \n#define\tHIFN_PUBSTS_DONE\t0x00000001\t \n#define\tHIFN_PUBSTS_CARRY\t0x00000002\t \n\n \n#define\tHIFN_PUBIEN_DONE\t0x00000001\t \n\n \n#define\tHIFN_RNGCFG_ENA\t\t0x00000001\t \n\n#define HIFN_NAMESIZE\t\t\t32\n#define HIFN_MAX_RESULT_ORDER\t\t5\n\n#define\tHIFN_D_CMD_RSIZE\t\t(24 * 1)\n#define\tHIFN_D_SRC_RSIZE\t\t(80 * 1)\n#define\tHIFN_D_DST_RSIZE\t\t(80 * 1)\n#define\tHIFN_D_RES_RSIZE\t\t(24 * 1)\n\n#define HIFN_D_DST_DALIGN\t\t4\n\n#define HIFN_QUEUE_LENGTH\t\t(HIFN_D_CMD_RSIZE - 1)\n\n#define AES_MIN_KEY_SIZE\t\t16\n#define AES_MAX_KEY_SIZE\t\t32\n\n#define HIFN_DES_KEY_LENGTH\t\t8\n#define HIFN_3DES_KEY_LENGTH\t\t24\n#define HIFN_MAX_CRYPT_KEY_LENGTH\tAES_MAX_KEY_SIZE\n#define HIFN_IV_LENGTH\t\t\t8\n#define HIFN_AES_IV_LENGTH\t\t16\n#define\tHIFN_MAX_IV_LENGTH\t\tHIFN_AES_IV_LENGTH\n\n#define HIFN_MAC_KEY_LENGTH\t\t64\n#define HIFN_MD5_LENGTH\t\t\t16\n#define HIFN_SHA1_LENGTH\t\t20\n#define HIFN_MAC_TRUNC_LENGTH\t\t12\n\n#define\tHIFN_MAX_COMMAND\t\t(8 + 8 + 8 + 64 + 260)\n#define\tHIFN_MAX_RESULT\t\t\t(8 + 4 + 4 + 20 + 4)\n#define HIFN_USED_RESULT\t\t12\n\nstruct hifn_desc {\n\tvolatile __le32\t\tl;\n\tvolatile __le32\t\tp;\n};\n\nstruct hifn_dma {\n\tstruct hifn_desc\tcmdr[HIFN_D_CMD_RSIZE + 1];\n\tstruct hifn_desc\tsrcr[HIFN_D_SRC_RSIZE + 1];\n\tstruct hifn_desc\tdstr[HIFN_D_DST_RSIZE + 1];\n\tstruct hifn_desc\tresr[HIFN_D_RES_RSIZE + 1];\n\n\tu8\t\t\tcommand_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_COMMAND];\n\tu8\t\t\tresult_bufs[HIFN_D_CMD_RSIZE][HIFN_MAX_RESULT];\n\n\t \n\tvolatile int\t\tcmdi, srci, dsti, resi;\n\tvolatile int\t\tcmdu, srcu, dstu, resu;\n\tint\t\t\tcmdk, srck, dstk, resk;\n};\n\n#define HIFN_FLAG_CMD_BUSY\t(1 << 0)\n#define HIFN_FLAG_SRC_BUSY\t(1 << 1)\n#define HIFN_FLAG_DST_BUSY\t(1 << 2)\n#define HIFN_FLAG_RES_BUSY\t(1 << 3)\n#define HIFN_FLAG_OLD_KEY\t(1 << 4)\n\n#define HIFN_DEFAULT_ACTIVE_NUM\t5\n\nstruct hifn_device {\n\tchar\t\t\tname[HIFN_NAMESIZE];\n\n\tint\t\t\tirq;\n\n\tstruct pci_dev\t\t*pdev;\n\tvoid __iomem\t\t*bar[3];\n\n\tvoid\t\t\t*desc_virt;\n\tdma_addr_t\t\tdesc_dma;\n\n\tu32\t\t\tdmareg;\n\n\tvoid\t\t\t*sa[HIFN_D_RES_RSIZE];\n\n\tspinlock_t\t\tlock;\n\n\tu32\t\t\tflags;\n\tint\t\t\tactive, started;\n\tstruct delayed_work\twork;\n\tunsigned long\t\treset;\n\tunsigned long\t\tsuccess;\n\tunsigned long\t\tprev_success;\n\n\tu8\t\t\tsnum;\n\n\tstruct tasklet_struct\ttasklet;\n\n\tstruct crypto_queue\tqueue;\n\tstruct list_head\talg_list;\n\n\tunsigned int\t\tpk_clk_freq;\n\n#ifdef CONFIG_CRYPTO_DEV_HIFN_795X_RNG\n\tunsigned int\t\trng_wait_time;\n\tktime_t\t\t\trngtime;\n\tstruct hwrng\t\trng;\n#endif\n};\n\n#define\tHIFN_D_LENGTH\t\t\t0x0000ffff\n#define\tHIFN_D_NOINVALID\t\t0x01000000\n#define\tHIFN_D_MASKDONEIRQ\t\t0x02000000\n#define\tHIFN_D_DESTOVER\t\t\t0x04000000\n#define\tHIFN_D_OVER\t\t\t0x08000000\n#define\tHIFN_D_LAST\t\t\t0x20000000\n#define\tHIFN_D_JUMP\t\t\t0x40000000\n#define\tHIFN_D_VALID\t\t\t0x80000000\n\nstruct hifn_base_command {\n\tvolatile __le16\t\tmasks;\n\tvolatile __le16\t\tsession_num;\n\tvolatile __le16\t\ttotal_source_count;\n\tvolatile __le16\t\ttotal_dest_count;\n};\n\n#define\tHIFN_BASE_CMD_COMP\t\t0x0100\t \n#define\tHIFN_BASE_CMD_PAD\t\t0x0200\t \n#define\tHIFN_BASE_CMD_MAC\t\t0x0400\t \n#define\tHIFN_BASE_CMD_CRYPT\t\t0x0800\t \n#define\tHIFN_BASE_CMD_DECODE\t\t0x2000\n#define\tHIFN_BASE_CMD_SRCLEN_M\t\t0xc000\n#define\tHIFN_BASE_CMD_SRCLEN_S\t\t14\n#define\tHIFN_BASE_CMD_DSTLEN_M\t\t0x3000\n#define\tHIFN_BASE_CMD_DSTLEN_S\t\t12\n#define\tHIFN_BASE_CMD_LENMASK_HI\t0x30000\n#define\tHIFN_BASE_CMD_LENMASK_LO\t0x0ffff\n\n \nstruct hifn_crypt_command {\n\tvolatile __le16\t\tmasks;\n\tvolatile __le16\t\theader_skip;\n\tvolatile __le16\t\tsource_count;\n\tvolatile __le16\t\treserved;\n};\n\n#define\tHIFN_CRYPT_CMD_ALG_MASK\t\t0x0003\t\t \n#define\tHIFN_CRYPT_CMD_ALG_DES\t\t0x0000\t\t \n#define\tHIFN_CRYPT_CMD_ALG_3DES\t\t0x0001\t\t \n#define\tHIFN_CRYPT_CMD_ALG_RC4\t\t0x0002\t\t \n#define\tHIFN_CRYPT_CMD_ALG_AES\t\t0x0003\t\t \n#define\tHIFN_CRYPT_CMD_MODE_MASK\t0x0018\t\t \n#define\tHIFN_CRYPT_CMD_MODE_ECB\t\t0x0000\t\t \n#define\tHIFN_CRYPT_CMD_MODE_CBC\t\t0x0008\t\t \n#define\tHIFN_CRYPT_CMD_MODE_CFB\t\t0x0010\t\t \n#define\tHIFN_CRYPT_CMD_MODE_OFB\t\t0x0018\t\t \n#define\tHIFN_CRYPT_CMD_CLR_CTX\t\t0x0040\t\t \n#define\tHIFN_CRYPT_CMD_KSZ_MASK\t\t0x0600\t\t \n#define\tHIFN_CRYPT_CMD_KSZ_128\t\t0x0000\t\t \n#define\tHIFN_CRYPT_CMD_KSZ_192\t\t0x0200\t\t \n#define\tHIFN_CRYPT_CMD_KSZ_256\t\t0x0400\t\t \n#define\tHIFN_CRYPT_CMD_NEW_KEY\t\t0x0800\t\t \n#define\tHIFN_CRYPT_CMD_NEW_IV\t\t0x1000\t\t \n#define\tHIFN_CRYPT_CMD_SRCLEN_M\t\t0xc000\n#define\tHIFN_CRYPT_CMD_SRCLEN_S\t\t14\n\n \nstruct hifn_mac_command {\n\tvolatile __le16\tmasks;\n\tvolatile __le16\theader_skip;\n\tvolatile __le16\tsource_count;\n\tvolatile __le16\treserved;\n};\n\n#define\tHIFN_MAC_CMD_ALG_MASK\t\t0x0001\n#define\tHIFN_MAC_CMD_ALG_SHA1\t\t0x0000\n#define\tHIFN_MAC_CMD_ALG_MD5\t\t0x0001\n#define\tHIFN_MAC_CMD_MODE_MASK\t\t0x000c\n#define\tHIFN_MAC_CMD_MODE_HMAC\t\t0x0000\n#define\tHIFN_MAC_CMD_MODE_SSL_MAC\t0x0004\n#define\tHIFN_MAC_CMD_MODE_HASH\t\t0x0008\n#define\tHIFN_MAC_CMD_MODE_FULL\t\t0x0004\n#define\tHIFN_MAC_CMD_TRUNC\t\t0x0010\n#define\tHIFN_MAC_CMD_RESULT\t\t0x0020\n#define\tHIFN_MAC_CMD_APPEND\t\t0x0040\n#define\tHIFN_MAC_CMD_SRCLEN_M\t\t0xc000\n#define\tHIFN_MAC_CMD_SRCLEN_S\t\t14\n\n \n#define\tHIFN_MAC_CMD_POS_IPSEC\t\t0x0200\n#define\tHIFN_MAC_CMD_NEW_KEY\t\t0x0800\n\nstruct hifn_comp_command {\n\tvolatile __le16\t\tmasks;\n\tvolatile __le16\t\theader_skip;\n\tvolatile __le16\t\tsource_count;\n\tvolatile __le16\t\treserved;\n};\n\n#define\tHIFN_COMP_CMD_SRCLEN_M\t\t0xc000\n#define\tHIFN_COMP_CMD_SRCLEN_S\t\t14\n#define\tHIFN_COMP_CMD_ONE\t\t0x0100\t \n#define\tHIFN_COMP_CMD_CLEARHIST\t\t0x0010\t \n#define\tHIFN_COMP_CMD_UPDATEHIST\t0x0008\t \n#define\tHIFN_COMP_CMD_LZS_STRIP0\t0x0004\t \n#define\tHIFN_COMP_CMD_MPPC_RESTART\t0x0004\t \n#define\tHIFN_COMP_CMD_ALG_MASK\t\t0x0001\t \n#define\tHIFN_COMP_CMD_ALG_MPPC\t\t0x0001\t \n#define\tHIFN_COMP_CMD_ALG_LZS\t\t0x0000\t \n\nstruct hifn_base_result {\n\tvolatile __le16\t\tflags;\n\tvolatile __le16\t\tsession;\n\tvolatile __le16\t\tsrc_cnt;\t\t \n\tvolatile __le16\t\tdst_cnt;\t\t \n};\n\n#define\tHIFN_BASE_RES_DSTOVERRUN\t0x0200\t \n#define\tHIFN_BASE_RES_SRCLEN_M\t\t0xc000\t \n#define\tHIFN_BASE_RES_SRCLEN_S\t\t14\n#define\tHIFN_BASE_RES_DSTLEN_M\t\t0x3000\t \n#define\tHIFN_BASE_RES_DSTLEN_S\t\t12\n\nstruct hifn_comp_result {\n\tvolatile __le16\t\tflags;\n\tvolatile __le16\t\tcrc;\n};\n\n#define\tHIFN_COMP_RES_LCB_M\t\t0xff00\t \n#define\tHIFN_COMP_RES_LCB_S\t\t8\n#define\tHIFN_COMP_RES_RESTART\t\t0x0004\t \n#define\tHIFN_COMP_RES_ENDMARKER\t\t0x0002\t \n#define\tHIFN_COMP_RES_SRC_NOTZERO\t0x0001\t \n\nstruct hifn_mac_result {\n\tvolatile __le16\t\tflags;\n\tvolatile __le16\t\treserved;\n\t \n};\n\n#define\tHIFN_MAC_RES_MISCOMPARE\t\t0x0002\t \n#define\tHIFN_MAC_RES_SRC_NOTZERO\t0x0001\t \n\nstruct hifn_crypt_result {\n\tvolatile __le16\t\tflags;\n\tvolatile __le16\t\treserved;\n};\n\n#define\tHIFN_CRYPT_RES_SRC_NOTZERO\t0x0001\t \n\n#ifndef HIFN_POLL_FREQUENCY\n#define\tHIFN_POLL_FREQUENCY\t0x1\n#endif\n\n#ifndef HIFN_POLL_SCALAR\n#define\tHIFN_POLL_SCALAR\t0x0\n#endif\n\n#define\tHIFN_MAX_SEGLEN\t\t0xffff\t\t \n#define\tHIFN_MAX_DMALEN\t\t0x3ffff\t\t \n\nstruct hifn_crypto_alg {\n\tstruct list_head\tentry;\n\tstruct skcipher_alg\talg;\n\tstruct hifn_device\t*dev;\n};\n\n#define ASYNC_SCATTERLIST_CACHE\t16\n\n#define ASYNC_FLAGS_MISALIGNED\t(1 << 0)\n\nstruct hifn_cipher_walk {\n\tstruct scatterlist\tcache[ASYNC_SCATTERLIST_CACHE];\n\tu32\t\t\tflags;\n\tint\t\t\tnum;\n};\n\nstruct hifn_context {\n\tu8\t\t\tkey[HIFN_MAX_CRYPT_KEY_LENGTH];\n\tstruct hifn_device\t*dev;\n\tunsigned int\t\tkeysize;\n};\n\nstruct hifn_request_context {\n\tu8\t\t\t*iv;\n\tunsigned int\t\tivsize;\n\tu8\t\t\top, type, mode, unused;\n\tstruct hifn_cipher_walk\twalk;\n};\n\n#define crypto_alg_to_hifn(a)\tcontainer_of(a, struct hifn_crypto_alg, alg)\n\nstatic inline u32 hifn_read_0(struct hifn_device *dev, u32 reg)\n{\n\treturn readl(dev->bar[0] + reg);\n}\n\nstatic inline u32 hifn_read_1(struct hifn_device *dev, u32 reg)\n{\n\treturn readl(dev->bar[1] + reg);\n}\n\nstatic inline void hifn_write_0(struct hifn_device *dev, u32 reg, u32 val)\n{\n\twritel((__force u32)cpu_to_le32(val), dev->bar[0] + reg);\n}\n\nstatic inline void hifn_write_1(struct hifn_device *dev, u32 reg, u32 val)\n{\n\twritel((__force u32)cpu_to_le32(val), dev->bar[1] + reg);\n}\n\nstatic void hifn_wait_puc(struct hifn_device *dev)\n{\n\tint i;\n\tu32 ret;\n\n\tfor (i = 10000; i > 0; --i) {\n\t\tret = hifn_read_0(dev, HIFN_0_PUCTRL);\n\t\tif (!(ret & HIFN_PUCTRL_RESET))\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t}\n\n\tif (!i)\n\t\tdev_err(&dev->pdev->dev, \"Failed to reset PUC unit.\\n\");\n}\n\nstatic void hifn_reset_puc(struct hifn_device *dev)\n{\n\thifn_write_0(dev, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);\n\thifn_wait_puc(dev);\n}\n\nstatic void hifn_stop_device(struct hifn_device *dev)\n{\n\thifn_write_1(dev, HIFN_1_DMA_CSR,\n\t\tHIFN_DMACSR_D_CTRL_DIS | HIFN_DMACSR_R_CTRL_DIS |\n\t\tHIFN_DMACSR_S_CTRL_DIS | HIFN_DMACSR_C_CTRL_DIS);\n\thifn_write_0(dev, HIFN_0_PUIER, 0);\n\thifn_write_1(dev, HIFN_1_DMA_IER, 0);\n}\n\nstatic void hifn_reset_dma(struct hifn_device *dev, int full)\n{\n\thifn_stop_device(dev);\n\n\t \n\thifn_write_1(dev, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t\t\tHIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\tmdelay(1);\n\n\t \n\tif (full) {\n\t\thifn_write_1(dev, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE);\n\t\tmdelay(1);\n\t} else {\n\t\thifn_write_1(dev, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MODE |\n\t\t\t\tHIFN_DMACNFG_MSTRESET);\n\t\thifn_reset_puc(dev);\n\t}\n\n\thifn_write_1(dev, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t\t\tHIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\n\thifn_reset_puc(dev);\n}\n\nstatic u32 hifn_next_signature(u32 a, u_int cnt)\n{\n\tint i;\n\tu32 v;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\t \n\t\tv = a & 0x80080125;\n\t\tv ^= v >> 16;\n\t\tv ^= v >> 8;\n\t\tv ^= v >> 4;\n\t\tv ^= v >> 2;\n\t\tv ^= v >> 1;\n\n\t\ta = (v & 1) ^ (a << 1);\n\t}\n\n\treturn a;\n}\n\nstatic struct pci2id {\n\tu_short\t\tpci_vendor;\n\tu_short\t\tpci_prod;\n\tchar\t\tcard_id[13];\n} pci2id[] = {\n\t{\n\t\tPCI_VENDOR_ID_HIFN,\n\t\tPCI_DEVICE_ID_HIFN_7955,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t},\n\t{\n\t\tPCI_VENDOR_ID_HIFN,\n\t\tPCI_DEVICE_ID_HIFN_7956,\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t  0x00, 0x00, 0x00, 0x00, 0x00 }\n\t}\n};\n\n#ifdef CONFIG_CRYPTO_DEV_HIFN_795X_RNG\nstatic int hifn_rng_data_present(struct hwrng *rng, int wait)\n{\n\tstruct hifn_device *dev = (struct hifn_device *)rng->priv;\n\ts64 nsec;\n\n\tnsec = ktime_to_ns(ktime_sub(ktime_get(), dev->rngtime));\n\tnsec -= dev->rng_wait_time;\n\tif (nsec <= 0)\n\t\treturn 1;\n\tif (!wait)\n\t\treturn 0;\n\tndelay(nsec);\n\treturn 1;\n}\n\nstatic int hifn_rng_data_read(struct hwrng *rng, u32 *data)\n{\n\tstruct hifn_device *dev = (struct hifn_device *)rng->priv;\n\n\t*data = hifn_read_1(dev, HIFN_1_RNG_DATA);\n\tdev->rngtime = ktime_get();\n\treturn 4;\n}\n\nstatic int hifn_register_rng(struct hifn_device *dev)\n{\n\t \n\tdev->rng_wait_time\t= DIV_ROUND_UP_ULL(NSEC_PER_SEC,\n\t\t\t\t\t\t   dev->pk_clk_freq) * 256;\n\n\tdev->rng.name\t\t= dev->name;\n\tdev->rng.data_present\t= hifn_rng_data_present;\n\tdev->rng.data_read\t= hifn_rng_data_read;\n\tdev->rng.priv\t\t= (unsigned long)dev;\n\n\treturn hwrng_register(&dev->rng);\n}\n\nstatic void hifn_unregister_rng(struct hifn_device *dev)\n{\n\thwrng_unregister(&dev->rng);\n}\n#else\n#define hifn_register_rng(dev)\t\t0\n#define hifn_unregister_rng(dev)\n#endif\n\nstatic int hifn_init_pubrng(struct hifn_device *dev)\n{\n\tint i;\n\n\thifn_write_1(dev, HIFN_1_PUB_RESET, hifn_read_1(dev, HIFN_1_PUB_RESET) |\n\t\t\tHIFN_PUBRST_RESET);\n\n\tfor (i = 100; i > 0; --i) {\n\t\tmdelay(1);\n\n\t\tif ((hifn_read_1(dev, HIFN_1_PUB_RESET) & HIFN_PUBRST_RESET) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (!i) {\n\t\tdev_err(&dev->pdev->dev, \"Failed to initialise public key engine.\\n\");\n\t} else {\n\t\thifn_write_1(dev, HIFN_1_PUB_IEN, HIFN_PUBIEN_DONE);\n\t\tdev->dmareg |= HIFN_DMAIER_PUBDONE;\n\t\thifn_write_1(dev, HIFN_1_DMA_IER, dev->dmareg);\n\n\t\tdev_dbg(&dev->pdev->dev, \"Public key engine has been successfully initialised.\\n\");\n\t}\n\n\t \n\n\thifn_write_1(dev, HIFN_1_RNG_CONFIG,\n\t\t\thifn_read_1(dev, HIFN_1_RNG_CONFIG) | HIFN_RNGCFG_ENA);\n\tdev_dbg(&dev->pdev->dev, \"RNG engine has been successfully initialised.\\n\");\n\n#ifdef CONFIG_CRYPTO_DEV_HIFN_795X_RNG\n\t \n\thifn_read_1(dev, HIFN_1_RNG_DATA);\n\tdev->rngtime = ktime_get();\n#endif\n\treturn 0;\n}\n\nstatic int hifn_enable_crypto(struct hifn_device *dev)\n{\n\tu32 dmacfg, addr;\n\tchar *offtbl = NULL;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pci2id); i++) {\n\t\tif (pci2id[i].pci_vendor == dev->pdev->vendor &&\n\t\t\t\tpci2id[i].pci_prod == dev->pdev->device) {\n\t\t\tofftbl = pci2id[i].card_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!offtbl) {\n\t\tdev_err(&dev->pdev->dev, \"Unknown card!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdmacfg = hifn_read_1(dev, HIFN_1_DMA_CNFG);\n\n\thifn_write_1(dev, HIFN_1_DMA_CNFG,\n\t\t\tHIFN_DMACNFG_UNLOCK | HIFN_DMACNFG_MSTRESET |\n\t\t\tHIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);\n\tmdelay(1);\n\taddr = hifn_read_1(dev, HIFN_1_UNLOCK_SECRET1);\n\tmdelay(1);\n\thifn_write_1(dev, HIFN_1_UNLOCK_SECRET2, 0);\n\tmdelay(1);\n\n\tfor (i = 0; i < 12; ++i) {\n\t\taddr = hifn_next_signature(addr, offtbl[i] + 0x101);\n\t\thifn_write_1(dev, HIFN_1_UNLOCK_SECRET2, addr);\n\n\t\tmdelay(1);\n\t}\n\thifn_write_1(dev, HIFN_1_DMA_CNFG, dmacfg);\n\n\tdev_dbg(&dev->pdev->dev, \"%s %s.\\n\", dev->name, pci_name(dev->pdev));\n\n\treturn 0;\n}\n\nstatic void hifn_init_dma(struct hifn_device *dev)\n{\n\tstruct hifn_dma *dma = dev->desc_virt;\n\tu32 dptr = dev->desc_dma;\n\tint i;\n\n\tfor (i = 0; i < HIFN_D_CMD_RSIZE; ++i)\n\t\tdma->cmdr[i].p = __cpu_to_le32(dptr +\n\t\t\t\toffsetof(struct hifn_dma, command_bufs[i][0]));\n\tfor (i = 0; i < HIFN_D_RES_RSIZE; ++i)\n\t\tdma->resr[i].p = __cpu_to_le32(dptr +\n\t\t\t\toffsetof(struct hifn_dma, result_bufs[i][0]));\n\n\t \n\tdma->cmdr[HIFN_D_CMD_RSIZE].p = __cpu_to_le32(dptr +\n\t\t\toffsetof(struct hifn_dma, cmdr[0]));\n\tdma->srcr[HIFN_D_SRC_RSIZE].p = __cpu_to_le32(dptr +\n\t\t\toffsetof(struct hifn_dma, srcr[0]));\n\tdma->dstr[HIFN_D_DST_RSIZE].p = __cpu_to_le32(dptr +\n\t\t\toffsetof(struct hifn_dma, dstr[0]));\n\tdma->resr[HIFN_D_RES_RSIZE].p = __cpu_to_le32(dptr +\n\t\t\toffsetof(struct hifn_dma, resr[0]));\n\n\tdma->cmdu = dma->srcu = dma->dstu = dma->resu = 0;\n\tdma->cmdi = dma->srci = dma->dsti = dma->resi = 0;\n\tdma->cmdk = dma->srck = dma->dstk = dma->resk = 0;\n}\n\n \nstatic void hifn_init_pll(struct hifn_device *dev)\n{\n\tunsigned int freq, m;\n\tu32 pllcfg;\n\n\tpllcfg = HIFN_1_PLL | HIFN_PLL_RESERVED_1;\n\n\tif (strncmp(hifn_pll_ref, \"ext\", 3) == 0)\n\t\tpllcfg |= HIFN_PLL_REF_CLK_PLL;\n\telse\n\t\tpllcfg |= HIFN_PLL_REF_CLK_HBI;\n\n\tif (hifn_pll_ref[3] != '\\0')\n\t\tfreq = simple_strtoul(hifn_pll_ref + 3, NULL, 10);\n\telse {\n\t\tfreq = 66;\n\t\tdev_info(&dev->pdev->dev, \"assuming %uMHz clock speed, override with hifn_pll_ref=%.3s<frequency>\\n\",\n\t\t\t freq, hifn_pll_ref);\n\t}\n\n\tm = HIFN_PLL_FCK_MAX / freq;\n\n\tpllcfg |= (m / 2 - 1) << HIFN_PLL_ND_SHIFT;\n\tif (m <= 8)\n\t\tpllcfg |= HIFN_PLL_IS_1_8;\n\telse\n\t\tpllcfg |= HIFN_PLL_IS_9_12;\n\n\t \n\thifn_write_1(dev, HIFN_1_PLL, pllcfg |\n\t\t     HIFN_PLL_PK_CLK_HBI | HIFN_PLL_PE_CLK_HBI | HIFN_PLL_BP);\n\n\t \n\tmdelay(10);\n\n\t \n\thifn_write_1(dev, HIFN_1_PLL, pllcfg |\n\t\t     HIFN_PLL_PK_CLK_HBI | HIFN_PLL_PE_CLK_HBI);\n\n\t \n\thifn_write_1(dev, HIFN_1_PLL, pllcfg |\n\t\t     HIFN_PLL_PK_CLK_PLL | HIFN_PLL_PE_CLK_PLL);\n\n\t \n\tdev->pk_clk_freq = 1000000 * (freq + 1) * m / 2;\n}\n\nstatic void hifn_init_registers(struct hifn_device *dev)\n{\n\tu32 dptr = dev->desc_dma;\n\n\t \n\thifn_write_0(dev, HIFN_0_PUCTRL, HIFN_PUCTRL_DMAENA);\n\thifn_write_0(dev, HIFN_0_FIFOCNFG, HIFN_FIFOCNFG_THRESHOLD);\n\thifn_write_0(dev, HIFN_0_PUIER, HIFN_PUIER_DSTOVER);\n\n\t \n\thifn_write_1(dev, HIFN_1_DMA_CRAR, dptr +\n\t\t\t\toffsetof(struct hifn_dma, cmdr[0]));\n\thifn_write_1(dev, HIFN_1_DMA_SRAR, dptr +\n\t\t\t\toffsetof(struct hifn_dma, srcr[0]));\n\thifn_write_1(dev, HIFN_1_DMA_DRAR, dptr +\n\t\t\t\toffsetof(struct hifn_dma, dstr[0]));\n\thifn_write_1(dev, HIFN_1_DMA_RRAR, dptr +\n\t\t\t\toffsetof(struct hifn_dma, resr[0]));\n\n\tmdelay(2);\n#if 0\n\thifn_write_1(dev, HIFN_1_DMA_CSR,\n\t    HIFN_DMACSR_D_CTRL_DIS | HIFN_DMACSR_R_CTRL_DIS |\n\t    HIFN_DMACSR_S_CTRL_DIS | HIFN_DMACSR_C_CTRL_DIS |\n\t    HIFN_DMACSR_D_ABORT | HIFN_DMACSR_D_DONE | HIFN_DMACSR_D_LAST |\n\t    HIFN_DMACSR_D_WAIT | HIFN_DMACSR_D_OVER |\n\t    HIFN_DMACSR_R_ABORT | HIFN_DMACSR_R_DONE | HIFN_DMACSR_R_LAST |\n\t    HIFN_DMACSR_R_WAIT | HIFN_DMACSR_R_OVER |\n\t    HIFN_DMACSR_S_ABORT | HIFN_DMACSR_S_DONE | HIFN_DMACSR_S_LAST |\n\t    HIFN_DMACSR_S_WAIT |\n\t    HIFN_DMACSR_C_ABORT | HIFN_DMACSR_C_DONE | HIFN_DMACSR_C_LAST |\n\t    HIFN_DMACSR_C_WAIT |\n\t    HIFN_DMACSR_ENGINE |\n\t    HIFN_DMACSR_PUBDONE);\n#else\n\thifn_write_1(dev, HIFN_1_DMA_CSR,\n\t    HIFN_DMACSR_C_CTRL_ENA | HIFN_DMACSR_S_CTRL_ENA |\n\t    HIFN_DMACSR_D_CTRL_ENA | HIFN_DMACSR_R_CTRL_ENA |\n\t    HIFN_DMACSR_D_ABORT | HIFN_DMACSR_D_DONE | HIFN_DMACSR_D_LAST |\n\t    HIFN_DMACSR_D_WAIT | HIFN_DMACSR_D_OVER |\n\t    HIFN_DMACSR_R_ABORT | HIFN_DMACSR_R_DONE | HIFN_DMACSR_R_LAST |\n\t    HIFN_DMACSR_R_WAIT | HIFN_DMACSR_R_OVER |\n\t    HIFN_DMACSR_S_ABORT | HIFN_DMACSR_S_DONE | HIFN_DMACSR_S_LAST |\n\t    HIFN_DMACSR_S_WAIT |\n\t    HIFN_DMACSR_C_ABORT | HIFN_DMACSR_C_DONE | HIFN_DMACSR_C_LAST |\n\t    HIFN_DMACSR_C_WAIT |\n\t    HIFN_DMACSR_ENGINE |\n\t    HIFN_DMACSR_PUBDONE);\n#endif\n\thifn_read_1(dev, HIFN_1_DMA_CSR);\n\n\tdev->dmareg |= HIFN_DMAIER_R_DONE | HIFN_DMAIER_C_ABORT |\n\t    HIFN_DMAIER_D_OVER | HIFN_DMAIER_R_OVER |\n\t    HIFN_DMAIER_S_ABORT | HIFN_DMAIER_D_ABORT | HIFN_DMAIER_R_ABORT |\n\t    HIFN_DMAIER_ENGINE;\n\tdev->dmareg &= ~HIFN_DMAIER_C_WAIT;\n\n\thifn_write_1(dev, HIFN_1_DMA_IER, dev->dmareg);\n\thifn_read_1(dev, HIFN_1_DMA_IER);\n#if 0\n\thifn_write_0(dev, HIFN_0_PUCNFG, HIFN_PUCNFG_ENCCNFG |\n\t\t    HIFN_PUCNFG_DRFR_128 | HIFN_PUCNFG_TCALLPHASES |\n\t\t    HIFN_PUCNFG_TCDRVTOTEM | HIFN_PUCNFG_BUS32 |\n\t\t    HIFN_PUCNFG_DRAM);\n#else\n\thifn_write_0(dev, HIFN_0_PUCNFG, 0x10342);\n#endif\n\thifn_init_pll(dev);\n\n\thifn_write_0(dev, HIFN_0_PUISR, HIFN_PUISR_DSTOVER);\n\thifn_write_1(dev, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |\n\t    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE | HIFN_DMACNFG_LAST |\n\t    ((HIFN_POLL_FREQUENCY << 16 ) & HIFN_DMACNFG_POLLFREQ) |\n\t    ((HIFN_POLL_SCALAR << 8) & HIFN_DMACNFG_POLLINVAL));\n}\n\nstatic int hifn_setup_base_command(struct hifn_device *dev, u8 *buf,\n\t\tunsigned dlen, unsigned slen, u16 mask, u8 snum)\n{\n\tstruct hifn_base_command *base_cmd;\n\tu8 *buf_pos = buf;\n\n\tbase_cmd = (struct hifn_base_command *)buf_pos;\n\tbase_cmd->masks = __cpu_to_le16(mask);\n\tbase_cmd->total_source_count =\n\t\t__cpu_to_le16(slen & HIFN_BASE_CMD_LENMASK_LO);\n\tbase_cmd->total_dest_count =\n\t\t__cpu_to_le16(dlen & HIFN_BASE_CMD_LENMASK_LO);\n\n\tdlen >>= 16;\n\tslen >>= 16;\n\tbase_cmd->session_num = __cpu_to_le16(snum |\n\t    ((slen << HIFN_BASE_CMD_SRCLEN_S) & HIFN_BASE_CMD_SRCLEN_M) |\n\t    ((dlen << HIFN_BASE_CMD_DSTLEN_S) & HIFN_BASE_CMD_DSTLEN_M));\n\n\treturn sizeof(struct hifn_base_command);\n}\n\nstatic int hifn_setup_crypto_command(struct hifn_device *dev,\n\t\tu8 *buf, unsigned dlen, unsigned slen,\n\t\tu8 *key, int keylen, u8 *iv, int ivsize, u16 mode)\n{\n\tstruct hifn_dma *dma = dev->desc_virt;\n\tstruct hifn_crypt_command *cry_cmd;\n\tu8 *buf_pos = buf;\n\tu16 cmd_len;\n\n\tcry_cmd = (struct hifn_crypt_command *)buf_pos;\n\n\tcry_cmd->source_count = __cpu_to_le16(dlen & 0xffff);\n\tdlen >>= 16;\n\tcry_cmd->masks = __cpu_to_le16(mode |\n\t\t\t((dlen << HIFN_CRYPT_CMD_SRCLEN_S) &\n\t\t\t HIFN_CRYPT_CMD_SRCLEN_M));\n\tcry_cmd->header_skip = 0;\n\tcry_cmd->reserved = 0;\n\n\tbuf_pos += sizeof(struct hifn_crypt_command);\n\n\tdma->cmdu++;\n\tif (dma->cmdu > 1) {\n\t\tdev->dmareg |= HIFN_DMAIER_C_WAIT;\n\t\thifn_write_1(dev, HIFN_1_DMA_IER, dev->dmareg);\n\t}\n\n\tif (keylen) {\n\t\tmemcpy(buf_pos, key, keylen);\n\t\tbuf_pos += keylen;\n\t}\n\tif (ivsize) {\n\t\tmemcpy(buf_pos, iv, ivsize);\n\t\tbuf_pos += ivsize;\n\t}\n\n\tcmd_len = buf_pos - buf;\n\n\treturn cmd_len;\n}\n\nstatic int hifn_setup_cmd_desc(struct hifn_device *dev,\n\t\tstruct hifn_context *ctx, struct hifn_request_context *rctx,\n\t\tvoid *priv, unsigned int nbytes)\n{\n\tstruct hifn_dma *dma = dev->desc_virt;\n\tint cmd_len, sa_idx;\n\tu8 *buf, *buf_pos;\n\tu16 mask;\n\n\tsa_idx = dma->cmdi;\n\tbuf_pos = buf = dma->command_bufs[dma->cmdi];\n\n\tmask = 0;\n\tswitch (rctx->op) {\n\tcase ACRYPTO_OP_DECRYPT:\n\t\tmask = HIFN_BASE_CMD_CRYPT | HIFN_BASE_CMD_DECODE;\n\t\tbreak;\n\tcase ACRYPTO_OP_ENCRYPT:\n\t\tmask = HIFN_BASE_CMD_CRYPT;\n\t\tbreak;\n\tcase ACRYPTO_OP_HMAC:\n\t\tmask = HIFN_BASE_CMD_MAC;\n\t\tbreak;\n\tdefault:\n\t\tgoto err_out;\n\t}\n\n\tbuf_pos += hifn_setup_base_command(dev, buf_pos, nbytes,\n\t\t\tnbytes, mask, dev->snum);\n\n\tif (rctx->op == ACRYPTO_OP_ENCRYPT || rctx->op == ACRYPTO_OP_DECRYPT) {\n\t\tu16 md = 0;\n\n\t\tif (ctx->keysize)\n\t\t\tmd |= HIFN_CRYPT_CMD_NEW_KEY;\n\t\tif (rctx->iv && rctx->mode != ACRYPTO_MODE_ECB)\n\t\t\tmd |= HIFN_CRYPT_CMD_NEW_IV;\n\n\t\tswitch (rctx->mode) {\n\t\tcase ACRYPTO_MODE_ECB:\n\t\t\tmd |= HIFN_CRYPT_CMD_MODE_ECB;\n\t\t\tbreak;\n\t\tcase ACRYPTO_MODE_CBC:\n\t\t\tmd |= HIFN_CRYPT_CMD_MODE_CBC;\n\t\t\tbreak;\n\t\tcase ACRYPTO_MODE_CFB:\n\t\t\tmd |= HIFN_CRYPT_CMD_MODE_CFB;\n\t\t\tbreak;\n\t\tcase ACRYPTO_MODE_OFB:\n\t\t\tmd |= HIFN_CRYPT_CMD_MODE_OFB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tswitch (rctx->type) {\n\t\tcase ACRYPTO_TYPE_AES_128:\n\t\t\tif (ctx->keysize != 16)\n\t\t\t\tgoto err_out;\n\t\t\tmd |= HIFN_CRYPT_CMD_KSZ_128 |\n\t\t\t\tHIFN_CRYPT_CMD_ALG_AES;\n\t\t\tbreak;\n\t\tcase ACRYPTO_TYPE_AES_192:\n\t\t\tif (ctx->keysize != 24)\n\t\t\t\tgoto err_out;\n\t\t\tmd |= HIFN_CRYPT_CMD_KSZ_192 |\n\t\t\t\tHIFN_CRYPT_CMD_ALG_AES;\n\t\t\tbreak;\n\t\tcase ACRYPTO_TYPE_AES_256:\n\t\t\tif (ctx->keysize != 32)\n\t\t\t\tgoto err_out;\n\t\t\tmd |= HIFN_CRYPT_CMD_KSZ_256 |\n\t\t\t\tHIFN_CRYPT_CMD_ALG_AES;\n\t\t\tbreak;\n\t\tcase ACRYPTO_TYPE_3DES:\n\t\t\tif (ctx->keysize != 24)\n\t\t\t\tgoto err_out;\n\t\t\tmd |= HIFN_CRYPT_CMD_ALG_3DES;\n\t\t\tbreak;\n\t\tcase ACRYPTO_TYPE_DES:\n\t\t\tif (ctx->keysize != 8)\n\t\t\t\tgoto err_out;\n\t\t\tmd |= HIFN_CRYPT_CMD_ALG_DES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tbuf_pos += hifn_setup_crypto_command(dev, buf_pos,\n\t\t\t\tnbytes, nbytes, ctx->key, ctx->keysize,\n\t\t\t\trctx->iv, rctx->ivsize, md);\n\t}\n\n\tdev->sa[sa_idx] = priv;\n\tdev->started++;\n\n\tcmd_len = buf_pos - buf;\n\tdma->cmdr[dma->cmdi].l = __cpu_to_le32(cmd_len | HIFN_D_VALID |\n\t\t\tHIFN_D_LAST | HIFN_D_MASKDONEIRQ);\n\n\tif (++dma->cmdi == HIFN_D_CMD_RSIZE) {\n\t\tdma->cmdr[dma->cmdi].l = __cpu_to_le32(\n\t\t\tHIFN_D_VALID | HIFN_D_LAST |\n\t\t\tHIFN_D_MASKDONEIRQ | HIFN_D_JUMP);\n\t\tdma->cmdi = 0;\n\t} else {\n\t\tdma->cmdr[dma->cmdi - 1].l |= __cpu_to_le32(HIFN_D_VALID);\n\t}\n\n\tif (!(dev->flags & HIFN_FLAG_CMD_BUSY)) {\n\t\thifn_write_1(dev, HIFN_1_DMA_CSR, HIFN_DMACSR_C_CTRL_ENA);\n\t\tdev->flags |= HIFN_FLAG_CMD_BUSY;\n\t}\n\treturn 0;\n\nerr_out:\n\treturn -EINVAL;\n}\n\nstatic int hifn_setup_src_desc(struct hifn_device *dev, struct page *page,\n\t\tunsigned int offset, unsigned int size, int last)\n{\n\tstruct hifn_dma *dma = dev->desc_virt;\n\tint idx;\n\tdma_addr_t addr;\n\n\taddr = dma_map_page(&dev->pdev->dev, page, offset, size,\n\t\t\t    DMA_TO_DEVICE);\n\n\tidx = dma->srci;\n\n\tdma->srcr[idx].p = __cpu_to_le32(addr);\n\tdma->srcr[idx].l = __cpu_to_le32(size | HIFN_D_VALID |\n\t\t\tHIFN_D_MASKDONEIRQ | (last ? HIFN_D_LAST : 0));\n\n\tif (++idx == HIFN_D_SRC_RSIZE) {\n\t\tdma->srcr[idx].l = __cpu_to_le32(HIFN_D_VALID |\n\t\t\t\tHIFN_D_JUMP | HIFN_D_MASKDONEIRQ |\n\t\t\t\t(last ? HIFN_D_LAST : 0));\n\t\tidx = 0;\n\t}\n\n\tdma->srci = idx;\n\tdma->srcu++;\n\n\tif (!(dev->flags & HIFN_FLAG_SRC_BUSY)) {\n\t\thifn_write_1(dev, HIFN_1_DMA_CSR, HIFN_DMACSR_S_CTRL_ENA);\n\t\tdev->flags |= HIFN_FLAG_SRC_BUSY;\n\t}\n\n\treturn size;\n}\n\nstatic void hifn_setup_res_desc(struct hifn_device *dev)\n{\n\tstruct hifn_dma *dma = dev->desc_virt;\n\n\tdma->resr[dma->resi].l = __cpu_to_le32(HIFN_USED_RESULT |\n\t\t\tHIFN_D_VALID | HIFN_D_LAST);\n\t \n\n\tif (++dma->resi == HIFN_D_RES_RSIZE) {\n\t\tdma->resr[HIFN_D_RES_RSIZE].l = __cpu_to_le32(HIFN_D_VALID |\n\t\t\t\tHIFN_D_JUMP | HIFN_D_MASKDONEIRQ | HIFN_D_LAST);\n\t\tdma->resi = 0;\n\t}\n\n\tdma->resu++;\n\n\tif (!(dev->flags & HIFN_FLAG_RES_BUSY)) {\n\t\thifn_write_1(dev, HIFN_1_DMA_CSR, HIFN_DMACSR_R_CTRL_ENA);\n\t\tdev->flags |= HIFN_FLAG_RES_BUSY;\n\t}\n}\n\nstatic void hifn_setup_dst_desc(struct hifn_device *dev, struct page *page,\n\t\tunsigned offset, unsigned size, int last)\n{\n\tstruct hifn_dma *dma = dev->desc_virt;\n\tint idx;\n\tdma_addr_t addr;\n\n\taddr = dma_map_page(&dev->pdev->dev, page, offset, size,\n\t\t\t    DMA_FROM_DEVICE);\n\n\tidx = dma->dsti;\n\tdma->dstr[idx].p = __cpu_to_le32(addr);\n\tdma->dstr[idx].l = __cpu_to_le32(size |\tHIFN_D_VALID |\n\t\t\tHIFN_D_MASKDONEIRQ | (last ? HIFN_D_LAST : 0));\n\n\tif (++idx == HIFN_D_DST_RSIZE) {\n\t\tdma->dstr[idx].l = __cpu_to_le32(HIFN_D_VALID |\n\t\t\t\tHIFN_D_JUMP | HIFN_D_MASKDONEIRQ |\n\t\t\t\t(last ? HIFN_D_LAST : 0));\n\t\tidx = 0;\n\t}\n\tdma->dsti = idx;\n\tdma->dstu++;\n\n\tif (!(dev->flags & HIFN_FLAG_DST_BUSY)) {\n\t\thifn_write_1(dev, HIFN_1_DMA_CSR, HIFN_DMACSR_D_CTRL_ENA);\n\t\tdev->flags |= HIFN_FLAG_DST_BUSY;\n\t}\n}\n\nstatic int hifn_setup_dma(struct hifn_device *dev,\n\t\tstruct hifn_context *ctx, struct hifn_request_context *rctx,\n\t\tstruct scatterlist *src, struct scatterlist *dst,\n\t\tunsigned int nbytes, void *priv)\n{\n\tstruct scatterlist *t;\n\tstruct page *spage, *dpage;\n\tunsigned int soff, doff;\n\tunsigned int n, len;\n\n\tn = nbytes;\n\twhile (n) {\n\t\tspage = sg_page(src);\n\t\tsoff = src->offset;\n\t\tlen = min(src->length, n);\n\n\t\thifn_setup_src_desc(dev, spage, soff, len, n - len == 0);\n\n\t\tsrc++;\n\t\tn -= len;\n\t}\n\n\tt = &rctx->walk.cache[0];\n\tn = nbytes;\n\twhile (n) {\n\t\tif (t->length && rctx->walk.flags & ASYNC_FLAGS_MISALIGNED) {\n\t\t\tBUG_ON(!sg_page(t));\n\t\t\tdpage = sg_page(t);\n\t\t\tdoff = 0;\n\t\t\tlen = t->length;\n\t\t} else {\n\t\t\tBUG_ON(!sg_page(dst));\n\t\t\tdpage = sg_page(dst);\n\t\t\tdoff = dst->offset;\n\t\t\tlen = dst->length;\n\t\t}\n\t\tlen = min(len, n);\n\n\t\thifn_setup_dst_desc(dev, dpage, doff, len, n - len == 0);\n\n\t\tdst++;\n\t\tt++;\n\t\tn -= len;\n\t}\n\n\thifn_setup_cmd_desc(dev, ctx, rctx, priv, nbytes);\n\thifn_setup_res_desc(dev);\n\treturn 0;\n}\n\nstatic int hifn_cipher_walk_init(struct hifn_cipher_walk *w,\n\t\tint num, gfp_t gfp_flags)\n{\n\tint i;\n\n\tnum = min(ASYNC_SCATTERLIST_CACHE, num);\n\tsg_init_table(w->cache, num);\n\n\tw->num = 0;\n\tfor (i = 0; i < num; ++i) {\n\t\tstruct page *page = alloc_page(gfp_flags);\n\t\tstruct scatterlist *s;\n\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\ts = &w->cache[i];\n\n\t\tsg_set_page(s, page, PAGE_SIZE, 0);\n\t\tw->num++;\n\t}\n\n\treturn i;\n}\n\nstatic void hifn_cipher_walk_exit(struct hifn_cipher_walk *w)\n{\n\tint i;\n\n\tfor (i = 0; i < w->num; ++i) {\n\t\tstruct scatterlist *s = &w->cache[i];\n\n\t\t__free_page(sg_page(s));\n\n\t\ts->length = 0;\n\t}\n\n\tw->num = 0;\n}\n\nstatic int skcipher_add(unsigned int *drestp, struct scatterlist *dst,\n\t\tunsigned int size, unsigned int *nbytesp)\n{\n\tunsigned int copy, drest = *drestp, nbytes = *nbytesp;\n\tint idx = 0;\n\n\tif (drest < size || size > nbytes)\n\t\treturn -EINVAL;\n\n\twhile (size) {\n\t\tcopy = min3(drest, size, dst->length);\n\n\t\tsize -= copy;\n\t\tdrest -= copy;\n\t\tnbytes -= copy;\n\n\t\tpr_debug(\"%s: copy: %u, size: %u, drest: %u, nbytes: %u.\\n\",\n\t\t\t __func__, copy, size, drest, nbytes);\n\n\t\tdst++;\n\t\tidx++;\n\t}\n\n\t*nbytesp = nbytes;\n\t*drestp = drest;\n\n\treturn idx;\n}\n\nstatic int hifn_cipher_walk(struct skcipher_request *req,\n\t\tstruct hifn_cipher_walk *w)\n{\n\tstruct scatterlist *dst, *t;\n\tunsigned int nbytes = req->cryptlen, offset, copy, diff;\n\tint idx, tidx, err;\n\n\ttidx = idx = 0;\n\toffset = 0;\n\twhile (nbytes) {\n\t\tif (idx >= w->num && (w->flags & ASYNC_FLAGS_MISALIGNED))\n\t\t\treturn -EINVAL;\n\n\t\tdst = &req->dst[idx];\n\n\t\tpr_debug(\"\\n%s: dlen: %u, doff: %u, offset: %u, nbytes: %u.\\n\",\n\t\t\t __func__, dst->length, dst->offset, offset, nbytes);\n\n\t\tif (!IS_ALIGNED(dst->offset, HIFN_D_DST_DALIGN) ||\n\t\t    !IS_ALIGNED(dst->length, HIFN_D_DST_DALIGN) ||\n\t\t    offset) {\n\t\t\tunsigned slen = min(dst->length - offset, nbytes);\n\t\t\tunsigned dlen = PAGE_SIZE;\n\n\t\t\tt = &w->cache[idx];\n\n\t\t\terr = skcipher_add(&dlen, dst, slen, &nbytes);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tidx += err;\n\n\t\t\tcopy = slen & ~(HIFN_D_DST_DALIGN - 1);\n\t\t\tdiff = slen & (HIFN_D_DST_DALIGN - 1);\n\n\t\t\tif (dlen < nbytes) {\n\t\t\t\t \n\t\t\t\tnbytes += diff;\n\n\t\t\t\t \n\t\t\t\tpr_err(\"%s: dlen: %u, nbytes: %u, slen: %u, offset: %u.\\n\",\n\t\t\t\t       __func__, dlen, nbytes, slen, offset);\n\t\t\t\tpr_err(\"%s: please contact author to fix this \"\n\t\t\t\t       \"issue, generally you should not catch \"\n\t\t\t\t       \"this path under any condition but who \"\n\t\t\t\t       \"knows how did you use crypto code.\\n\"\n\t\t\t\t       \"Thank you.\\n\",\t__func__);\n\t\t\t\tBUG();\n\t\t\t} else {\n\t\t\t\tcopy += diff + nbytes;\n\n\t\t\t\tdst = &req->dst[idx];\n\n\t\t\t\terr = skcipher_add(&dlen, dst, nbytes, &nbytes);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\n\t\t\t\tidx += err;\n\t\t\t}\n\n\t\t\tt->length = copy;\n\t\t\tt->offset = offset;\n\t\t} else {\n\t\t\tnbytes -= min(dst->length, nbytes);\n\t\t\tidx++;\n\t\t}\n\n\t\ttidx++;\n\t}\n\n\treturn tidx;\n}\n\nstatic int hifn_setup_session(struct skcipher_request *req)\n{\n\tstruct hifn_context *ctx = crypto_tfm_ctx(req->base.tfm);\n\tstruct hifn_request_context *rctx = skcipher_request_ctx(req);\n\tstruct hifn_device *dev = ctx->dev;\n\tunsigned long dlen, flags;\n\tunsigned int nbytes = req->cryptlen, idx = 0;\n\tint err = -EINVAL, sg_num;\n\tstruct scatterlist *dst;\n\n\tif (rctx->iv && !rctx->ivsize && rctx->mode != ACRYPTO_MODE_ECB)\n\t\tgoto err_out_exit;\n\n\trctx->walk.flags = 0;\n\n\twhile (nbytes) {\n\t\tdst = &req->dst[idx];\n\t\tdlen = min(dst->length, nbytes);\n\n\t\tif (!IS_ALIGNED(dst->offset, HIFN_D_DST_DALIGN) ||\n\t\t    !IS_ALIGNED(dlen, HIFN_D_DST_DALIGN))\n\t\t\trctx->walk.flags |= ASYNC_FLAGS_MISALIGNED;\n\n\t\tnbytes -= dlen;\n\t\tidx++;\n\t}\n\n\tif (rctx->walk.flags & ASYNC_FLAGS_MISALIGNED) {\n\t\terr = hifn_cipher_walk_init(&rctx->walk, idx, GFP_ATOMIC);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tsg_num = hifn_cipher_walk(req, &rctx->walk);\n\tif (sg_num < 0) {\n\t\terr = sg_num;\n\t\tgoto err_out_exit;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->started + sg_num > HIFN_QUEUE_LENGTH) {\n\t\terr = -EAGAIN;\n\t\tgoto err_out;\n\t}\n\n\terr = hifn_setup_dma(dev, ctx, rctx, req->src, req->dst, req->cryptlen, req);\n\tif (err)\n\t\tgoto err_out;\n\n\tdev->snum++;\n\n\tdev->active = HIFN_DEFAULT_ACTIVE_NUM;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n\nerr_out:\n\tspin_unlock_irqrestore(&dev->lock, flags);\nerr_out_exit:\n\tif (err) {\n\t\tdev_info(&dev->pdev->dev, \"iv: %p [%d], key: %p [%d], mode: %u, op: %u, \"\n\t\t\t \"type: %u, err: %d.\\n\",\n\t\t\t rctx->iv, rctx->ivsize,\n\t\t\t ctx->key, ctx->keysize,\n\t\t\t rctx->mode, rctx->op, rctx->type, err);\n\t}\n\n\treturn err;\n}\n\nstatic int hifn_start_device(struct hifn_device *dev)\n{\n\tint err;\n\n\tdev->started = dev->active = 0;\n\thifn_reset_dma(dev, 1);\n\n\terr = hifn_enable_crypto(dev);\n\tif (err)\n\t\treturn err;\n\n\thifn_reset_puc(dev);\n\n\thifn_init_dma(dev);\n\n\thifn_init_registers(dev);\n\n\thifn_init_pubrng(dev);\n\n\treturn 0;\n}\n\nstatic int skcipher_get(void *saddr, unsigned int *srestp, unsigned int offset,\n\t\tstruct scatterlist *dst, unsigned int size, unsigned int *nbytesp)\n{\n\tunsigned int srest = *srestp, nbytes = *nbytesp, copy;\n\tvoid *daddr;\n\tint idx = 0;\n\n\tif (srest < size || size > nbytes)\n\t\treturn -EINVAL;\n\n\twhile (size) {\n\t\tcopy = min3(srest, dst->length, size);\n\n\t\tdaddr = kmap_atomic(sg_page(dst));\n\t\tmemcpy(daddr + dst->offset + offset, saddr, copy);\n\t\tkunmap_atomic(daddr);\n\n\t\tnbytes -= copy;\n\t\tsize -= copy;\n\t\tsrest -= copy;\n\t\tsaddr += copy;\n\t\toffset = 0;\n\n\t\tpr_debug(\"%s: copy: %u, size: %u, srest: %u, nbytes: %u.\\n\",\n\t\t\t __func__, copy, size, srest, nbytes);\n\n\t\tdst++;\n\t\tidx++;\n\t}\n\n\t*nbytesp = nbytes;\n\t*srestp = srest;\n\n\treturn idx;\n}\n\nstatic inline void hifn_complete_sa(struct hifn_device *dev, int i)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdev->sa[i] = NULL;\n\tdev->started--;\n\tif (dev->started < 0)\n\t\tdev_info(&dev->pdev->dev, \"%s: started: %d.\\n\", __func__,\n\t\t\t dev->started);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tBUG_ON(dev->started < 0);\n}\n\nstatic void hifn_process_ready(struct skcipher_request *req, int error)\n{\n\tstruct hifn_request_context *rctx = skcipher_request_ctx(req);\n\n\tif (rctx->walk.flags & ASYNC_FLAGS_MISALIGNED) {\n\t\tunsigned int nbytes = req->cryptlen;\n\t\tint idx = 0, err;\n\t\tstruct scatterlist *dst, *t;\n\t\tvoid *saddr;\n\n\t\twhile (nbytes) {\n\t\t\tt = &rctx->walk.cache[idx];\n\t\t\tdst = &req->dst[idx];\n\n\t\t\tpr_debug(\"\\n%s: sg_page(t): %p, t->length: %u, \"\n\t\t\t\t\"sg_page(dst): %p, dst->length: %u, \"\n\t\t\t\t\"nbytes: %u.\\n\",\n\t\t\t\t__func__, sg_page(t), t->length,\n\t\t\t\tsg_page(dst), dst->length, nbytes);\n\n\t\t\tif (!t->length) {\n\t\t\t\tnbytes -= min(dst->length, nbytes);\n\t\t\t\tidx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsaddr = kmap_atomic(sg_page(t));\n\n\t\t\terr = skcipher_get(saddr, &t->length, t->offset,\n\t\t\t\t\tdst, nbytes, &nbytes);\n\t\t\tif (err < 0) {\n\t\t\t\tkunmap_atomic(saddr);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tidx += err;\n\t\t\tkunmap_atomic(saddr);\n\t\t}\n\n\t\thifn_cipher_walk_exit(&rctx->walk);\n\t}\n\n\tskcipher_request_complete(req, error);\n}\n\nstatic void hifn_clear_rings(struct hifn_device *dev, int error)\n{\n\tstruct hifn_dma *dma = dev->desc_virt;\n\tint i, u;\n\n\tdev_dbg(&dev->pdev->dev, \"ring cleanup 1: i: %d.%d.%d.%d, u: %d.%d.%d.%d, \"\n\t\t\t\"k: %d.%d.%d.%d.\\n\",\n\t\t\tdma->cmdi, dma->srci, dma->dsti, dma->resi,\n\t\t\tdma->cmdu, dma->srcu, dma->dstu, dma->resu,\n\t\t\tdma->cmdk, dma->srck, dma->dstk, dma->resk);\n\n\ti = dma->resk; u = dma->resu;\n\twhile (u != 0) {\n\t\tif (dma->resr[i].l & __cpu_to_le32(HIFN_D_VALID))\n\t\t\tbreak;\n\n\t\tif (dev->sa[i]) {\n\t\t\tdev->success++;\n\t\t\tdev->reset = 0;\n\t\t\thifn_process_ready(dev->sa[i], error);\n\t\t\thifn_complete_sa(dev, i);\n\t\t}\n\n\t\tif (++i == HIFN_D_RES_RSIZE)\n\t\t\ti = 0;\n\t\tu--;\n\t}\n\tdma->resk = i; dma->resu = u;\n\n\ti = dma->srck; u = dma->srcu;\n\twhile (u != 0) {\n\t\tif (dma->srcr[i].l & __cpu_to_le32(HIFN_D_VALID))\n\t\t\tbreak;\n\t\tif (++i == HIFN_D_SRC_RSIZE)\n\t\t\ti = 0;\n\t\tu--;\n\t}\n\tdma->srck = i; dma->srcu = u;\n\n\ti = dma->cmdk; u = dma->cmdu;\n\twhile (u != 0) {\n\t\tif (dma->cmdr[i].l & __cpu_to_le32(HIFN_D_VALID))\n\t\t\tbreak;\n\t\tif (++i == HIFN_D_CMD_RSIZE)\n\t\t\ti = 0;\n\t\tu--;\n\t}\n\tdma->cmdk = i; dma->cmdu = u;\n\n\ti = dma->dstk; u = dma->dstu;\n\twhile (u != 0) {\n\t\tif (dma->dstr[i].l & __cpu_to_le32(HIFN_D_VALID))\n\t\t\tbreak;\n\t\tif (++i == HIFN_D_DST_RSIZE)\n\t\t\ti = 0;\n\t\tu--;\n\t}\n\tdma->dstk = i; dma->dstu = u;\n\n\tdev_dbg(&dev->pdev->dev, \"ring cleanup 2: i: %d.%d.%d.%d, u: %d.%d.%d.%d, \"\n\t\t\t\"k: %d.%d.%d.%d.\\n\",\n\t\t\tdma->cmdi, dma->srci, dma->dsti, dma->resi,\n\t\t\tdma->cmdu, dma->srcu, dma->dstu, dma->resu,\n\t\t\tdma->cmdk, dma->srck, dma->dstk, dma->resk);\n}\n\nstatic void hifn_work(struct work_struct *work)\n{\n\tstruct delayed_work *dw = to_delayed_work(work);\n\tstruct hifn_device *dev = container_of(dw, struct hifn_device, work);\n\tunsigned long flags;\n\tint reset = 0;\n\tu32 r = 0;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->active == 0) {\n\t\tstruct hifn_dma *dma = dev->desc_virt;\n\n\t\tif (dma->cmdu == 0 && (dev->flags & HIFN_FLAG_CMD_BUSY)) {\n\t\t\tdev->flags &= ~HIFN_FLAG_CMD_BUSY;\n\t\t\tr |= HIFN_DMACSR_C_CTRL_DIS;\n\t\t}\n\t\tif (dma->srcu == 0 && (dev->flags & HIFN_FLAG_SRC_BUSY)) {\n\t\t\tdev->flags &= ~HIFN_FLAG_SRC_BUSY;\n\t\t\tr |= HIFN_DMACSR_S_CTRL_DIS;\n\t\t}\n\t\tif (dma->dstu == 0 && (dev->flags & HIFN_FLAG_DST_BUSY)) {\n\t\t\tdev->flags &= ~HIFN_FLAG_DST_BUSY;\n\t\t\tr |= HIFN_DMACSR_D_CTRL_DIS;\n\t\t}\n\t\tif (dma->resu == 0 && (dev->flags & HIFN_FLAG_RES_BUSY)) {\n\t\t\tdev->flags &= ~HIFN_FLAG_RES_BUSY;\n\t\t\tr |= HIFN_DMACSR_R_CTRL_DIS;\n\t\t}\n\t\tif (r)\n\t\t\thifn_write_1(dev, HIFN_1_DMA_CSR, r);\n\t} else\n\t\tdev->active--;\n\n\tif ((dev->prev_success == dev->success) && dev->started)\n\t\treset = 1;\n\tdev->prev_success = dev->success;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (reset) {\n\t\tif (++dev->reset >= 5) {\n\t\t\tint i;\n\t\t\tstruct hifn_dma *dma = dev->desc_virt;\n\n\t\t\tdev_info(&dev->pdev->dev,\n\t\t\t\t \"r: %08x, active: %d, started: %d, \"\n\t\t\t\t \"success: %lu: qlen: %u/%u, reset: %d.\\n\",\n\t\t\t\t r, dev->active, dev->started,\n\t\t\t\t dev->success, dev->queue.qlen, dev->queue.max_qlen,\n\t\t\t\t reset);\n\n\t\t\tdev_info(&dev->pdev->dev, \"%s: res: \", __func__);\n\t\t\tfor (i = 0; i < HIFN_D_RES_RSIZE; ++i) {\n\t\t\t\tpr_info(\"%x.%p \", dma->resr[i].l, dev->sa[i]);\n\t\t\t\tif (dev->sa[i]) {\n\t\t\t\t\thifn_process_ready(dev->sa[i], -ENODEV);\n\t\t\t\t\thifn_complete_sa(dev, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr_info(\"\\n\");\n\n\t\t\thifn_reset_dma(dev, 1);\n\t\t\thifn_stop_device(dev);\n\t\t\thifn_start_device(dev);\n\t\t\tdev->reset = 0;\n\t\t}\n\n\t\ttasklet_schedule(&dev->tasklet);\n\t}\n\n\tschedule_delayed_work(&dev->work, HZ);\n}\n\nstatic irqreturn_t hifn_interrupt(int irq, void *data)\n{\n\tstruct hifn_device *dev = data;\n\tstruct hifn_dma *dma = dev->desc_virt;\n\tu32 dmacsr, restart;\n\n\tdmacsr = hifn_read_1(dev, HIFN_1_DMA_CSR);\n\n\tdev_dbg(&dev->pdev->dev, \"1 dmacsr: %08x, dmareg: %08x, res: %08x [%d], \"\n\t\t\t\"i: %d.%d.%d.%d, u: %d.%d.%d.%d.\\n\",\n\t\tdmacsr, dev->dmareg, dmacsr & dev->dmareg, dma->cmdi,\n\t\tdma->cmdi, dma->srci, dma->dsti, dma->resi,\n\t\tdma->cmdu, dma->srcu, dma->dstu, dma->resu);\n\n\tif ((dmacsr & dev->dmareg) == 0)\n\t\treturn IRQ_NONE;\n\n\thifn_write_1(dev, HIFN_1_DMA_CSR, dmacsr & dev->dmareg);\n\n\tif (dmacsr & HIFN_DMACSR_ENGINE)\n\t\thifn_write_0(dev, HIFN_0_PUISR, hifn_read_0(dev, HIFN_0_PUISR));\n\tif (dmacsr & HIFN_DMACSR_PUBDONE)\n\t\thifn_write_1(dev, HIFN_1_PUB_STATUS,\n\t\t\thifn_read_1(dev, HIFN_1_PUB_STATUS) | HIFN_PUBSTS_DONE);\n\n\trestart = dmacsr & (HIFN_DMACSR_R_OVER | HIFN_DMACSR_D_OVER);\n\tif (restart) {\n\t\tu32 puisr = hifn_read_0(dev, HIFN_0_PUISR);\n\n\t\tdev_warn(&dev->pdev->dev, \"overflow: r: %d, d: %d, puisr: %08x, d: %u.\\n\",\n\t\t\t !!(dmacsr & HIFN_DMACSR_R_OVER),\n\t\t\t !!(dmacsr & HIFN_DMACSR_D_OVER),\n\t\t\tpuisr, !!(puisr & HIFN_PUISR_DSTOVER));\n\t\tif (!!(puisr & HIFN_PUISR_DSTOVER))\n\t\t\thifn_write_0(dev, HIFN_0_PUISR, HIFN_PUISR_DSTOVER);\n\t\thifn_write_1(dev, HIFN_1_DMA_CSR, dmacsr & (HIFN_DMACSR_R_OVER |\n\t\t\t\t\tHIFN_DMACSR_D_OVER));\n\t}\n\n\trestart = dmacsr & (HIFN_DMACSR_C_ABORT | HIFN_DMACSR_S_ABORT |\n\t\t\tHIFN_DMACSR_D_ABORT | HIFN_DMACSR_R_ABORT);\n\tif (restart) {\n\t\tdev_warn(&dev->pdev->dev, \"abort: c: %d, s: %d, d: %d, r: %d.\\n\",\n\t\t\t !!(dmacsr & HIFN_DMACSR_C_ABORT),\n\t\t\t !!(dmacsr & HIFN_DMACSR_S_ABORT),\n\t\t\t !!(dmacsr & HIFN_DMACSR_D_ABORT),\n\t\t\t !!(dmacsr & HIFN_DMACSR_R_ABORT));\n\t\thifn_reset_dma(dev, 1);\n\t\thifn_init_dma(dev);\n\t\thifn_init_registers(dev);\n\t}\n\n\tif ((dmacsr & HIFN_DMACSR_C_WAIT) && (dma->cmdu == 0)) {\n\t\tdev_dbg(&dev->pdev->dev, \"wait on command.\\n\");\n\t\tdev->dmareg &= ~(HIFN_DMAIER_C_WAIT);\n\t\thifn_write_1(dev, HIFN_1_DMA_IER, dev->dmareg);\n\t}\n\n\ttasklet_schedule(&dev->tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void hifn_flush(struct hifn_device *dev)\n{\n\tunsigned long flags;\n\tstruct crypto_async_request *async_req;\n\tstruct skcipher_request *req;\n\tstruct hifn_dma *dma = dev->desc_virt;\n\tint i;\n\n\tfor (i = 0; i < HIFN_D_RES_RSIZE; ++i) {\n\t\tstruct hifn_desc *d = &dma->resr[i];\n\n\t\tif (dev->sa[i]) {\n\t\t\thifn_process_ready(dev->sa[i],\n\t\t\t\t(d->l & __cpu_to_le32(HIFN_D_VALID)) ? -ENODEV : 0);\n\t\t\thifn_complete_sa(dev, i);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\twhile ((async_req = crypto_dequeue_request(&dev->queue))) {\n\t\treq = skcipher_request_cast(async_req);\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\thifn_process_ready(req, -ENODEV);\n\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\n\nstatic int hifn_setkey(struct crypto_skcipher *cipher, const u8 *key,\n\t\tunsigned int len)\n{\n\tstruct hifn_context *ctx = crypto_skcipher_ctx(cipher);\n\tstruct hifn_device *dev = ctx->dev;\n\tint err;\n\n\terr = verify_skcipher_des_key(cipher, key);\n\tif (err)\n\t\treturn err;\n\n\tdev->flags &= ~HIFN_FLAG_OLD_KEY;\n\n\tmemcpy(ctx->key, key, len);\n\tctx->keysize = len;\n\n\treturn 0;\n}\n\nstatic int hifn_des3_setkey(struct crypto_skcipher *cipher, const u8 *key,\n\t\t\t    unsigned int len)\n{\n\tstruct hifn_context *ctx = crypto_skcipher_ctx(cipher);\n\tstruct hifn_device *dev = ctx->dev;\n\tint err;\n\n\terr = verify_skcipher_des3_key(cipher, key);\n\tif (err)\n\t\treturn err;\n\n\tdev->flags &= ~HIFN_FLAG_OLD_KEY;\n\n\tmemcpy(ctx->key, key, len);\n\tctx->keysize = len;\n\n\treturn 0;\n}\n\nstatic int hifn_handle_req(struct skcipher_request *req)\n{\n\tstruct hifn_context *ctx = crypto_tfm_ctx(req->base.tfm);\n\tstruct hifn_device *dev = ctx->dev;\n\tint err = -EAGAIN;\n\n\tif (dev->started + DIV_ROUND_UP(req->cryptlen, PAGE_SIZE) <= HIFN_QUEUE_LENGTH)\n\t\terr = hifn_setup_session(req);\n\n\tif (err == -EAGAIN) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\terr = crypto_enqueue_request(&dev->queue, &req->base);\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t}\n\n\treturn err;\n}\n\nstatic int hifn_setup_crypto_req(struct skcipher_request *req, u8 op,\n\t\tu8 type, u8 mode)\n{\n\tstruct hifn_context *ctx = crypto_tfm_ctx(req->base.tfm);\n\tstruct hifn_request_context *rctx = skcipher_request_ctx(req);\n\tunsigned ivsize;\n\n\tivsize = crypto_skcipher_ivsize(crypto_skcipher_reqtfm(req));\n\n\tif (req->iv && mode != ACRYPTO_MODE_ECB) {\n\t\tif (type == ACRYPTO_TYPE_AES_128)\n\t\t\tivsize = HIFN_AES_IV_LENGTH;\n\t\telse if (type == ACRYPTO_TYPE_DES)\n\t\t\tivsize = HIFN_DES_KEY_LENGTH;\n\t\telse if (type == ACRYPTO_TYPE_3DES)\n\t\t\tivsize = HIFN_3DES_KEY_LENGTH;\n\t}\n\n\tif (ctx->keysize != 16 && type == ACRYPTO_TYPE_AES_128) {\n\t\tif (ctx->keysize == 24)\n\t\t\ttype = ACRYPTO_TYPE_AES_192;\n\t\telse if (ctx->keysize == 32)\n\t\t\ttype = ACRYPTO_TYPE_AES_256;\n\t}\n\n\trctx->op = op;\n\trctx->mode = mode;\n\trctx->type = type;\n\trctx->iv = req->iv;\n\trctx->ivsize = ivsize;\n\n\t \n\n\treturn hifn_handle_req(req);\n}\n\nstatic int hifn_process_queue(struct hifn_device *dev)\n{\n\tstruct crypto_async_request *async_req, *backlog;\n\tstruct skcipher_request *req;\n\tunsigned long flags;\n\tint err = 0;\n\n\twhile (dev->started < HIFN_QUEUE_LENGTH) {\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\tbacklog = crypto_get_backlog(&dev->queue);\n\t\tasync_req = crypto_dequeue_request(&dev->queue);\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\tif (!async_req)\n\t\t\tbreak;\n\n\t\tif (backlog)\n\t\t\tcrypto_request_complete(backlog, -EINPROGRESS);\n\n\t\treq = skcipher_request_cast(async_req);\n\n\t\terr = hifn_handle_req(req);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int hifn_setup_crypto(struct skcipher_request *req, u8 op,\n\t\tu8 type, u8 mode)\n{\n\tint err;\n\tstruct hifn_context *ctx = crypto_tfm_ctx(req->base.tfm);\n\tstruct hifn_device *dev = ctx->dev;\n\n\terr = hifn_setup_crypto_req(req, op, type, mode);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->started < HIFN_QUEUE_LENGTH &&\tdev->queue.qlen)\n\t\thifn_process_queue(dev);\n\n\treturn -EINPROGRESS;\n}\n\n \nstatic inline int hifn_encrypt_aes_ecb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,\n\t\t\tACRYPTO_TYPE_AES_128, ACRYPTO_MODE_ECB);\n}\nstatic inline int hifn_encrypt_aes_cbc(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,\n\t\t\tACRYPTO_TYPE_AES_128, ACRYPTO_MODE_CBC);\n}\nstatic inline int hifn_encrypt_aes_cfb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,\n\t\t\tACRYPTO_TYPE_AES_128, ACRYPTO_MODE_CFB);\n}\nstatic inline int hifn_encrypt_aes_ofb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,\n\t\t\tACRYPTO_TYPE_AES_128, ACRYPTO_MODE_OFB);\n}\n\n \nstatic inline int hifn_decrypt_aes_ecb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,\n\t\t\tACRYPTO_TYPE_AES_128, ACRYPTO_MODE_ECB);\n}\nstatic inline int hifn_decrypt_aes_cbc(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,\n\t\t\tACRYPTO_TYPE_AES_128, ACRYPTO_MODE_CBC);\n}\nstatic inline int hifn_decrypt_aes_cfb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,\n\t\t\tACRYPTO_TYPE_AES_128, ACRYPTO_MODE_CFB);\n}\nstatic inline int hifn_decrypt_aes_ofb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,\n\t\t\tACRYPTO_TYPE_AES_128, ACRYPTO_MODE_OFB);\n}\n\n \nstatic inline int hifn_encrypt_des_ecb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,\n\t\t\tACRYPTO_TYPE_DES, ACRYPTO_MODE_ECB);\n}\nstatic inline int hifn_encrypt_des_cbc(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,\n\t\t\tACRYPTO_TYPE_DES, ACRYPTO_MODE_CBC);\n}\nstatic inline int hifn_encrypt_des_cfb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,\n\t\t\tACRYPTO_TYPE_DES, ACRYPTO_MODE_CFB);\n}\nstatic inline int hifn_encrypt_des_ofb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,\n\t\t\tACRYPTO_TYPE_DES, ACRYPTO_MODE_OFB);\n}\n\n \nstatic inline int hifn_decrypt_des_ecb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,\n\t\t\tACRYPTO_TYPE_DES, ACRYPTO_MODE_ECB);\n}\nstatic inline int hifn_decrypt_des_cbc(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,\n\t\t\tACRYPTO_TYPE_DES, ACRYPTO_MODE_CBC);\n}\nstatic inline int hifn_decrypt_des_cfb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,\n\t\t\tACRYPTO_TYPE_DES, ACRYPTO_MODE_CFB);\n}\nstatic inline int hifn_decrypt_des_ofb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,\n\t\t\tACRYPTO_TYPE_DES, ACRYPTO_MODE_OFB);\n}\n\n \nstatic inline int hifn_encrypt_3des_ecb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,\n\t\t\tACRYPTO_TYPE_3DES, ACRYPTO_MODE_ECB);\n}\nstatic inline int hifn_encrypt_3des_cbc(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,\n\t\t\tACRYPTO_TYPE_3DES, ACRYPTO_MODE_CBC);\n}\nstatic inline int hifn_encrypt_3des_cfb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,\n\t\t\tACRYPTO_TYPE_3DES, ACRYPTO_MODE_CFB);\n}\nstatic inline int hifn_encrypt_3des_ofb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,\n\t\t\tACRYPTO_TYPE_3DES, ACRYPTO_MODE_OFB);\n}\n\n \nstatic inline int hifn_decrypt_3des_ecb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,\n\t\t\tACRYPTO_TYPE_3DES, ACRYPTO_MODE_ECB);\n}\nstatic inline int hifn_decrypt_3des_cbc(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,\n\t\t\tACRYPTO_TYPE_3DES, ACRYPTO_MODE_CBC);\n}\nstatic inline int hifn_decrypt_3des_cfb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,\n\t\t\tACRYPTO_TYPE_3DES, ACRYPTO_MODE_CFB);\n}\nstatic inline int hifn_decrypt_3des_ofb(struct skcipher_request *req)\n{\n\treturn hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,\n\t\t\tACRYPTO_TYPE_3DES, ACRYPTO_MODE_OFB);\n}\n\nstruct hifn_alg_template {\n\tchar name[CRYPTO_MAX_ALG_NAME];\n\tchar drv_name[CRYPTO_MAX_ALG_NAME];\n\tunsigned int bsize;\n\tstruct skcipher_alg skcipher;\n};\n\nstatic const struct hifn_alg_template hifn_alg_templates[] = {\n\t \n\t{\n\t\t.name = \"cfb(des3_ede)\", .drv_name = \"cfb-3des\", .bsize = 8,\n\t\t.skcipher = {\n\t\t\t.min_keysize\t=\tHIFN_3DES_KEY_LENGTH,\n\t\t\t.max_keysize\t=\tHIFN_3DES_KEY_LENGTH,\n\t\t\t.setkey\t\t=\thifn_des3_setkey,\n\t\t\t.encrypt\t=\thifn_encrypt_3des_cfb,\n\t\t\t.decrypt\t=\thifn_decrypt_3des_cfb,\n\t\t},\n\t},\n\t{\n\t\t.name = \"ofb(des3_ede)\", .drv_name = \"ofb-3des\", .bsize = 8,\n\t\t.skcipher = {\n\t\t\t.min_keysize\t=\tHIFN_3DES_KEY_LENGTH,\n\t\t\t.max_keysize\t=\tHIFN_3DES_KEY_LENGTH,\n\t\t\t.setkey\t\t=\thifn_des3_setkey,\n\t\t\t.encrypt\t=\thifn_encrypt_3des_ofb,\n\t\t\t.decrypt\t=\thifn_decrypt_3des_ofb,\n\t\t},\n\t},\n\t{\n\t\t.name = \"cbc(des3_ede)\", .drv_name = \"cbc-3des\", .bsize = 8,\n\t\t.skcipher = {\n\t\t\t.ivsize\t\t=\tHIFN_IV_LENGTH,\n\t\t\t.min_keysize\t=\tHIFN_3DES_KEY_LENGTH,\n\t\t\t.max_keysize\t=\tHIFN_3DES_KEY_LENGTH,\n\t\t\t.setkey\t\t=\thifn_des3_setkey,\n\t\t\t.encrypt\t=\thifn_encrypt_3des_cbc,\n\t\t\t.decrypt\t=\thifn_decrypt_3des_cbc,\n\t\t},\n\t},\n\t{\n\t\t.name = \"ecb(des3_ede)\", .drv_name = \"ecb-3des\", .bsize = 8,\n\t\t.skcipher = {\n\t\t\t.min_keysize\t=\tHIFN_3DES_KEY_LENGTH,\n\t\t\t.max_keysize\t=\tHIFN_3DES_KEY_LENGTH,\n\t\t\t.setkey\t\t=\thifn_des3_setkey,\n\t\t\t.encrypt\t=\thifn_encrypt_3des_ecb,\n\t\t\t.decrypt\t=\thifn_decrypt_3des_ecb,\n\t\t},\n\t},\n\n\t \n\t{\n\t\t.name = \"cfb(des)\", .drv_name = \"cfb-des\", .bsize = 8,\n\t\t.skcipher = {\n\t\t\t.min_keysize\t=\tHIFN_DES_KEY_LENGTH,\n\t\t\t.max_keysize\t=\tHIFN_DES_KEY_LENGTH,\n\t\t\t.setkey\t\t=\thifn_setkey,\n\t\t\t.encrypt\t=\thifn_encrypt_des_cfb,\n\t\t\t.decrypt\t=\thifn_decrypt_des_cfb,\n\t\t},\n\t},\n\t{\n\t\t.name = \"ofb(des)\", .drv_name = \"ofb-des\", .bsize = 8,\n\t\t.skcipher = {\n\t\t\t.min_keysize\t=\tHIFN_DES_KEY_LENGTH,\n\t\t\t.max_keysize\t=\tHIFN_DES_KEY_LENGTH,\n\t\t\t.setkey\t\t=\thifn_setkey,\n\t\t\t.encrypt\t=\thifn_encrypt_des_ofb,\n\t\t\t.decrypt\t=\thifn_decrypt_des_ofb,\n\t\t},\n\t},\n\t{\n\t\t.name = \"cbc(des)\", .drv_name = \"cbc-des\", .bsize = 8,\n\t\t.skcipher = {\n\t\t\t.ivsize\t\t=\tHIFN_IV_LENGTH,\n\t\t\t.min_keysize\t=\tHIFN_DES_KEY_LENGTH,\n\t\t\t.max_keysize\t=\tHIFN_DES_KEY_LENGTH,\n\t\t\t.setkey\t\t=\thifn_setkey,\n\t\t\t.encrypt\t=\thifn_encrypt_des_cbc,\n\t\t\t.decrypt\t=\thifn_decrypt_des_cbc,\n\t\t},\n\t},\n\t{\n\t\t.name = \"ecb(des)\", .drv_name = \"ecb-des\", .bsize = 8,\n\t\t.skcipher = {\n\t\t\t.min_keysize\t=\tHIFN_DES_KEY_LENGTH,\n\t\t\t.max_keysize\t=\tHIFN_DES_KEY_LENGTH,\n\t\t\t.setkey\t\t=\thifn_setkey,\n\t\t\t.encrypt\t=\thifn_encrypt_des_ecb,\n\t\t\t.decrypt\t=\thifn_decrypt_des_ecb,\n\t\t},\n\t},\n\n\t \n\t{\n\t\t.name = \"ecb(aes)\", .drv_name = \"ecb-aes\", .bsize = 16,\n\t\t.skcipher = {\n\t\t\t.min_keysize\t=\tAES_MIN_KEY_SIZE,\n\t\t\t.max_keysize\t=\tAES_MAX_KEY_SIZE,\n\t\t\t.setkey\t\t=\thifn_setkey,\n\t\t\t.encrypt\t=\thifn_encrypt_aes_ecb,\n\t\t\t.decrypt\t=\thifn_decrypt_aes_ecb,\n\t\t},\n\t},\n\t{\n\t\t.name = \"cbc(aes)\", .drv_name = \"cbc-aes\", .bsize = 16,\n\t\t.skcipher = {\n\t\t\t.ivsize\t\t=\tHIFN_AES_IV_LENGTH,\n\t\t\t.min_keysize\t=\tAES_MIN_KEY_SIZE,\n\t\t\t.max_keysize\t=\tAES_MAX_KEY_SIZE,\n\t\t\t.setkey\t\t=\thifn_setkey,\n\t\t\t.encrypt\t=\thifn_encrypt_aes_cbc,\n\t\t\t.decrypt\t=\thifn_decrypt_aes_cbc,\n\t\t},\n\t},\n\t{\n\t\t.name = \"cfb(aes)\", .drv_name = \"cfb-aes\", .bsize = 16,\n\t\t.skcipher = {\n\t\t\t.min_keysize\t=\tAES_MIN_KEY_SIZE,\n\t\t\t.max_keysize\t=\tAES_MAX_KEY_SIZE,\n\t\t\t.setkey\t\t=\thifn_setkey,\n\t\t\t.encrypt\t=\thifn_encrypt_aes_cfb,\n\t\t\t.decrypt\t=\thifn_decrypt_aes_cfb,\n\t\t},\n\t},\n\t{\n\t\t.name = \"ofb(aes)\", .drv_name = \"ofb-aes\", .bsize = 16,\n\t\t.skcipher = {\n\t\t\t.min_keysize\t=\tAES_MIN_KEY_SIZE,\n\t\t\t.max_keysize\t=\tAES_MAX_KEY_SIZE,\n\t\t\t.setkey\t\t=\thifn_setkey,\n\t\t\t.encrypt\t=\thifn_encrypt_aes_ofb,\n\t\t\t.decrypt\t=\thifn_decrypt_aes_ofb,\n\t\t},\n\t},\n};\n\nstatic int hifn_init_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(tfm);\n\tstruct hifn_crypto_alg *ha = crypto_alg_to_hifn(alg);\n\tstruct hifn_context *ctx = crypto_skcipher_ctx(tfm);\n\n\tctx->dev = ha->dev;\n\tcrypto_skcipher_set_reqsize(tfm, sizeof(struct hifn_request_context));\n\n\treturn 0;\n}\n\nstatic int hifn_alg_alloc(struct hifn_device *dev, const struct hifn_alg_template *t)\n{\n\tstruct hifn_crypto_alg *alg;\n\tint err;\n\n\talg = kzalloc(sizeof(*alg), GFP_KERNEL);\n\tif (!alg)\n\t\treturn -ENOMEM;\n\n\talg->alg = t->skcipher;\n\talg->alg.init = hifn_init_tfm;\n\n\tsnprintf(alg->alg.base.cra_name, CRYPTO_MAX_ALG_NAME, \"%s\", t->name);\n\tsnprintf(alg->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME, \"%s-%s\",\n\t\t t->drv_name, dev->name);\n\n\talg->alg.base.cra_priority = 300;\n\talg->alg.base.cra_flags = CRYPTO_ALG_KERN_DRIVER_ONLY | CRYPTO_ALG_ASYNC;\n\talg->alg.base.cra_blocksize = t->bsize;\n\talg->alg.base.cra_ctxsize = sizeof(struct hifn_context);\n\talg->alg.base.cra_alignmask = 0;\n\talg->alg.base.cra_module = THIS_MODULE;\n\n\talg->dev = dev;\n\n\tlist_add_tail(&alg->entry, &dev->alg_list);\n\n\terr = crypto_register_skcipher(&alg->alg);\n\tif (err) {\n\t\tlist_del(&alg->entry);\n\t\tkfree(alg);\n\t}\n\n\treturn err;\n}\n\nstatic void hifn_unregister_alg(struct hifn_device *dev)\n{\n\tstruct hifn_crypto_alg *a, *n;\n\n\tlist_for_each_entry_safe(a, n, &dev->alg_list, entry) {\n\t\tlist_del(&a->entry);\n\t\tcrypto_unregister_skcipher(&a->alg);\n\t\tkfree(a);\n\t}\n}\n\nstatic int hifn_register_alg(struct hifn_device *dev)\n{\n\tint i, err;\n\n\tfor (i = 0; i < ARRAY_SIZE(hifn_alg_templates); ++i) {\n\t\terr = hifn_alg_alloc(dev, &hifn_alg_templates[i]);\n\t\tif (err)\n\t\t\tgoto err_out_exit;\n\t}\n\n\treturn 0;\n\nerr_out_exit:\n\thifn_unregister_alg(dev);\n\treturn err;\n}\n\nstatic void hifn_tasklet_callback(unsigned long data)\n{\n\tstruct hifn_device *dev = (struct hifn_device *)data;\n\n\t \n\thifn_clear_rings(dev, 0);\n\n\tif (dev->started < HIFN_QUEUE_LENGTH &&\tdev->queue.qlen)\n\t\thifn_process_queue(dev);\n}\n\nstatic int hifn_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint err, i;\n\tstruct hifn_device *dev;\n\tchar name[8];\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\tpci_set_master(pdev);\n\n\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err)\n\t\tgoto err_out_disable_pci_device;\n\n\tsnprintf(name, sizeof(name), \"hifn%d\",\n\t\t\tatomic_inc_return(&hifn_dev_number) - 1);\n\n\terr = pci_request_regions(pdev, name);\n\tif (err)\n\t\tgoto err_out_disable_pci_device;\n\n\tif (pci_resource_len(pdev, 0) < HIFN_BAR0_SIZE ||\n\t    pci_resource_len(pdev, 1) < HIFN_BAR1_SIZE ||\n\t    pci_resource_len(pdev, 2) < HIFN_BAR2_SIZE) {\n\t\tdev_err(&pdev->dev, \"Broken hardware - I/O regions are too small.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_free_regions;\n\t}\n\n\tdev = kzalloc(sizeof(struct hifn_device) + sizeof(struct crypto_alg),\n\t\t\tGFP_KERNEL);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_regions;\n\t}\n\n\tINIT_LIST_HEAD(&dev->alg_list);\n\n\tsnprintf(dev->name, sizeof(dev->name), \"%s\", name);\n\tspin_lock_init(&dev->lock);\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tunsigned long addr, size;\n\n\t\taddr = pci_resource_start(pdev, i);\n\t\tsize = pci_resource_len(pdev, i);\n\n\t\tdev->bar[i] = ioremap(addr, size);\n\t\tif (!dev->bar[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out_unmap_bars;\n\t\t}\n\t}\n\n\tdev->desc_virt = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t    sizeof(struct hifn_dma),\n\t\t\t\t\t    &dev->desc_dma, GFP_KERNEL);\n\tif (!dev->desc_virt) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate descriptor rings.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_unmap_bars;\n\t}\n\n\tdev->pdev = pdev;\n\tdev->irq = pdev->irq;\n\n\tfor (i = 0; i < HIFN_D_RES_RSIZE; ++i)\n\t\tdev->sa[i] = NULL;\n\n\tpci_set_drvdata(pdev, dev);\n\n\ttasklet_init(&dev->tasklet, hifn_tasklet_callback, (unsigned long)dev);\n\n\tcrypto_init_queue(&dev->queue, 1);\n\n\terr = request_irq(dev->irq, hifn_interrupt, IRQF_SHARED, dev->name, dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to request IRQ%d: err: %d.\\n\",\n\t\t\tdev->irq, err);\n\t\tdev->irq = 0;\n\t\tgoto err_out_free_desc;\n\t}\n\n\terr = hifn_start_device(dev);\n\tif (err)\n\t\tgoto err_out_free_irq;\n\n\terr = hifn_register_rng(dev);\n\tif (err)\n\t\tgoto err_out_stop_device;\n\n\terr = hifn_register_alg(dev);\n\tif (err)\n\t\tgoto err_out_unregister_rng;\n\n\tINIT_DELAYED_WORK(&dev->work, hifn_work);\n\tschedule_delayed_work(&dev->work, HZ);\n\n\tdev_dbg(&pdev->dev, \"HIFN crypto accelerator card at %s has been \"\n\t\t\"successfully registered as %s.\\n\",\n\t\tpci_name(pdev), dev->name);\n\n\treturn 0;\n\nerr_out_unregister_rng:\n\thifn_unregister_rng(dev);\nerr_out_stop_device:\n\thifn_reset_dma(dev, 1);\n\thifn_stop_device(dev);\nerr_out_free_irq:\n\tfree_irq(dev->irq, dev);\n\ttasklet_kill(&dev->tasklet);\nerr_out_free_desc:\n\tdma_free_coherent(&pdev->dev, sizeof(struct hifn_dma), dev->desc_virt,\n\t\t\t  dev->desc_dma);\n\nerr_out_unmap_bars:\n\tfor (i = 0; i < 3; ++i)\n\t\tif (dev->bar[i])\n\t\t\tiounmap(dev->bar[i]);\n\tkfree(dev);\n\nerr_out_free_regions:\n\tpci_release_regions(pdev);\n\nerr_out_disable_pci_device:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic void hifn_remove(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct hifn_device *dev;\n\n\tdev = pci_get_drvdata(pdev);\n\n\tif (dev) {\n\t\tcancel_delayed_work_sync(&dev->work);\n\n\t\thifn_unregister_rng(dev);\n\t\thifn_unregister_alg(dev);\n\t\thifn_reset_dma(dev, 1);\n\t\thifn_stop_device(dev);\n\n\t\tfree_irq(dev->irq, dev);\n\t\ttasklet_kill(&dev->tasklet);\n\n\t\thifn_flush(dev);\n\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct hifn_dma),\n\t\t\t\t  dev->desc_virt, dev->desc_dma);\n\t\tfor (i = 0; i < 3; ++i)\n\t\t\tif (dev->bar[i])\n\t\t\t\tiounmap(dev->bar[i]);\n\n\t\tkfree(dev);\n\t}\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_device_id hifn_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HIFN, PCI_DEVICE_ID_HIFN_7955) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HIFN, PCI_DEVICE_ID_HIFN_7956) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, hifn_pci_tbl);\n\nstatic struct pci_driver hifn_pci_driver = {\n\t.name     = \"hifn795x\",\n\t.id_table = hifn_pci_tbl,\n\t.probe    = hifn_probe,\n\t.remove   = hifn_remove,\n};\n\nstatic int __init hifn_init(void)\n{\n\tunsigned int freq;\n\tint err;\n\n\tif (strncmp(hifn_pll_ref, \"ext\", 3) &&\n\t    strncmp(hifn_pll_ref, \"pci\", 3)) {\n\t\tpr_err(\"hifn795x: invalid hifn_pll_ref clock, must be pci or ext\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (hifn_pll_ref[3] != '\\0') {\n\t\tfreq = simple_strtoul(hifn_pll_ref + 3, NULL, 10);\n\t\tif (freq < 20 || freq > 100) {\n\t\t\tpr_err(\"hifn795x: invalid hifn_pll_ref frequency, must\"\n\t\t\t       \"be in the range of 20-100\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\terr = pci_register_driver(&hifn_pci_driver);\n\tif (err < 0) {\n\t\tpr_err(\"Failed to register PCI driver for %s device.\\n\",\n\t\t       hifn_pci_driver.name);\n\t\treturn -ENODEV;\n\t}\n\n\tpr_info(\"Driver for HIFN 795x crypto accelerator chip \"\n\t\t\"has been successfully registered.\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit hifn_fini(void)\n{\n\tpci_unregister_driver(&hifn_pci_driver);\n\n\tpr_info(\"Driver for HIFN 795x crypto accelerator chip \"\n\t\t\"has been successfully unregistered.\\n\");\n}\n\nmodule_init(hifn_init);\nmodule_exit(hifn_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Evgeniy Polyakov <johnpol@2ka.mipt.ru>\");\nMODULE_DESCRIPTION(\"Driver for HIFN 795x crypto accelerator chip.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}