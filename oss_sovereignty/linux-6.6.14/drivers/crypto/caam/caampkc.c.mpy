{
  "module_name": "caampkc.c",
  "hash_id": "40c48348b385d0b6589e8bccd150575b60ac00c99747240477283ef84ffe7428",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/caam/caampkc.c",
  "human_readable_source": "\n \n#include \"compat.h\"\n#include \"regs.h\"\n#include \"intern.h\"\n#include \"jr.h\"\n#include \"error.h\"\n#include \"desc_constr.h\"\n#include \"sg_sw_sec4.h\"\n#include \"caampkc.h\"\n#include <crypto/internal/engine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#define DESC_RSA_PUB_LEN\t(2 * CAAM_CMD_SZ + SIZEOF_RSA_PUB_PDB)\n#define DESC_RSA_PRIV_F1_LEN\t(2 * CAAM_CMD_SZ + \\\n\t\t\t\t SIZEOF_RSA_PRIV_F1_PDB)\n#define DESC_RSA_PRIV_F2_LEN\t(2 * CAAM_CMD_SZ + \\\n\t\t\t\t SIZEOF_RSA_PRIV_F2_PDB)\n#define DESC_RSA_PRIV_F3_LEN\t(2 * CAAM_CMD_SZ + \\\n\t\t\t\t SIZEOF_RSA_PRIV_F3_PDB)\n#define CAAM_RSA_MAX_INPUT_SIZE\t512  \n\n \nstatic u8 *zero_buffer;\n\n \nstatic bool init_done;\n\nstruct caam_akcipher_alg {\n\tstruct akcipher_engine_alg akcipher;\n\tbool registered;\n};\n\nstatic void rsa_io_unmap(struct device *dev, struct rsa_edesc *edesc,\n\t\t\t struct akcipher_request *req)\n{\n\tstruct caam_rsa_req_ctx *req_ctx = akcipher_request_ctx(req);\n\n\tdma_unmap_sg(dev, req->dst, edesc->dst_nents, DMA_FROM_DEVICE);\n\tdma_unmap_sg(dev, req_ctx->fixup_src, edesc->src_nents, DMA_TO_DEVICE);\n\n\tif (edesc->sec4_sg_bytes)\n\t\tdma_unmap_single(dev, edesc->sec4_sg_dma, edesc->sec4_sg_bytes,\n\t\t\t\t DMA_TO_DEVICE);\n}\n\nstatic void rsa_pub_unmap(struct device *dev, struct rsa_edesc *edesc,\n\t\t\t  struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct caam_rsa_key *key = &ctx->key;\n\tstruct rsa_pub_pdb *pdb = &edesc->pdb.pub;\n\n\tdma_unmap_single(dev, pdb->n_dma, key->n_sz, DMA_TO_DEVICE);\n\tdma_unmap_single(dev, pdb->e_dma, key->e_sz, DMA_TO_DEVICE);\n}\n\nstatic void rsa_priv_f1_unmap(struct device *dev, struct rsa_edesc *edesc,\n\t\t\t      struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct caam_rsa_key *key = &ctx->key;\n\tstruct rsa_priv_f1_pdb *pdb = &edesc->pdb.priv_f1;\n\n\tdma_unmap_single(dev, pdb->n_dma, key->n_sz, DMA_TO_DEVICE);\n\tdma_unmap_single(dev, pdb->d_dma, key->d_sz, DMA_TO_DEVICE);\n}\n\nstatic void rsa_priv_f2_unmap(struct device *dev, struct rsa_edesc *edesc,\n\t\t\t      struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct caam_rsa_key *key = &ctx->key;\n\tstruct rsa_priv_f2_pdb *pdb = &edesc->pdb.priv_f2;\n\tsize_t p_sz = key->p_sz;\n\tsize_t q_sz = key->q_sz;\n\n\tdma_unmap_single(dev, pdb->d_dma, key->d_sz, DMA_TO_DEVICE);\n\tdma_unmap_single(dev, pdb->p_dma, p_sz, DMA_TO_DEVICE);\n\tdma_unmap_single(dev, pdb->q_dma, q_sz, DMA_TO_DEVICE);\n\tdma_unmap_single(dev, pdb->tmp1_dma, p_sz, DMA_BIDIRECTIONAL);\n\tdma_unmap_single(dev, pdb->tmp2_dma, q_sz, DMA_BIDIRECTIONAL);\n}\n\nstatic void rsa_priv_f3_unmap(struct device *dev, struct rsa_edesc *edesc,\n\t\t\t      struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct caam_rsa_key *key = &ctx->key;\n\tstruct rsa_priv_f3_pdb *pdb = &edesc->pdb.priv_f3;\n\tsize_t p_sz = key->p_sz;\n\tsize_t q_sz = key->q_sz;\n\n\tdma_unmap_single(dev, pdb->p_dma, p_sz, DMA_TO_DEVICE);\n\tdma_unmap_single(dev, pdb->q_dma, q_sz, DMA_TO_DEVICE);\n\tdma_unmap_single(dev, pdb->dp_dma, p_sz, DMA_TO_DEVICE);\n\tdma_unmap_single(dev, pdb->dq_dma, q_sz, DMA_TO_DEVICE);\n\tdma_unmap_single(dev, pdb->c_dma, p_sz, DMA_TO_DEVICE);\n\tdma_unmap_single(dev, pdb->tmp1_dma, p_sz, DMA_BIDIRECTIONAL);\n\tdma_unmap_single(dev, pdb->tmp2_dma, q_sz, DMA_BIDIRECTIONAL);\n}\n\n \nstatic void rsa_pub_done(struct device *dev, u32 *desc, u32 err, void *context)\n{\n\tstruct akcipher_request *req = context;\n\tstruct caam_rsa_req_ctx *req_ctx = akcipher_request_ctx(req);\n\tstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\n\tstruct rsa_edesc *edesc;\n\tint ecode = 0;\n\tbool has_bklog;\n\n\tif (err)\n\t\tecode = caam_jr_strstatus(dev, err);\n\n\tedesc = req_ctx->edesc;\n\thas_bklog = edesc->bklog;\n\n\trsa_pub_unmap(dev, edesc, req);\n\trsa_io_unmap(dev, edesc, req);\n\tkfree(edesc);\n\n\t \n\tif (!has_bklog)\n\t\takcipher_request_complete(req, ecode);\n\telse\n\t\tcrypto_finalize_akcipher_request(jrp->engine, req, ecode);\n}\n\nstatic void rsa_priv_f_done(struct device *dev, u32 *desc, u32 err,\n\t\t\t    void *context)\n{\n\tstruct akcipher_request *req = context;\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct caam_rsa_key *key = &ctx->key;\n\tstruct caam_rsa_req_ctx *req_ctx = akcipher_request_ctx(req);\n\tstruct rsa_edesc *edesc;\n\tint ecode = 0;\n\tbool has_bklog;\n\n\tif (err)\n\t\tecode = caam_jr_strstatus(dev, err);\n\n\tedesc = req_ctx->edesc;\n\thas_bklog = edesc->bklog;\n\n\tswitch (key->priv_form) {\n\tcase FORM1:\n\t\trsa_priv_f1_unmap(dev, edesc, req);\n\t\tbreak;\n\tcase FORM2:\n\t\trsa_priv_f2_unmap(dev, edesc, req);\n\t\tbreak;\n\tcase FORM3:\n\t\trsa_priv_f3_unmap(dev, edesc, req);\n\t}\n\n\trsa_io_unmap(dev, edesc, req);\n\tkfree(edesc);\n\n\t \n\tif (!has_bklog)\n\t\takcipher_request_complete(req, ecode);\n\telse\n\t\tcrypto_finalize_akcipher_request(jrp->engine, req, ecode);\n}\n\n \nstatic int caam_rsa_count_leading_zeros(struct scatterlist *sgl,\n\t\t\t\t\tunsigned int nbytes,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct sg_mapping_iter miter;\n\tint lzeros, ents;\n\tunsigned int len;\n\tunsigned int tbytes = nbytes;\n\tconst u8 *buff;\n\n\tents = sg_nents_for_len(sgl, nbytes);\n\tif (ents < 0)\n\t\treturn ents;\n\n\tsg_miter_start(&miter, sgl, ents, SG_MITER_FROM_SG | flags);\n\n\tlzeros = 0;\n\tlen = 0;\n\twhile (nbytes > 0) {\n\t\t \n\t\twhile (len && !*buff && lzeros < nbytes) {\n\t\t\tlzeros++;\n\t\t\tlen--;\n\t\t\tbuff++;\n\t\t}\n\n\t\tif (len && *buff)\n\t\t\tbreak;\n\n\t\tif (!sg_miter_next(&miter))\n\t\t\tbreak;\n\n\t\tbuff = miter.addr;\n\t\tlen = miter.length;\n\n\t\tnbytes -= lzeros;\n\t\tlzeros = 0;\n\t}\n\n\tmiter.consumed = lzeros;\n\tsg_miter_stop(&miter);\n\tnbytes -= lzeros;\n\n\treturn tbytes - nbytes;\n}\n\nstatic struct rsa_edesc *rsa_edesc_alloc(struct akcipher_request *req,\n\t\t\t\t\t size_t desclen)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct device *dev = ctx->dev;\n\tstruct caam_rsa_req_ctx *req_ctx = akcipher_request_ctx(req);\n\tstruct caam_rsa_key *key = &ctx->key;\n\tstruct rsa_edesc *edesc;\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t       GFP_KERNEL : GFP_ATOMIC;\n\tint sg_flags = (flags == GFP_ATOMIC) ? SG_MITER_ATOMIC : 0;\n\tint sec4_sg_index, sec4_sg_len = 0, sec4_sg_bytes;\n\tint src_nents, dst_nents;\n\tint mapped_src_nents, mapped_dst_nents;\n\tunsigned int diff_size = 0;\n\tint lzeros;\n\n\tif (req->src_len > key->n_sz) {\n\t\t \n\t\tlzeros = caam_rsa_count_leading_zeros(req->src, req->src_len -\n\t\t\t\t\t\t      key->n_sz, sg_flags);\n\t\tif (lzeros < 0)\n\t\t\treturn ERR_PTR(lzeros);\n\n\t\treq_ctx->fixup_src = scatterwalk_ffwd(req_ctx->src, req->src,\n\t\t\t\t\t\t      lzeros);\n\t\treq_ctx->fixup_src_len = req->src_len - lzeros;\n\t} else {\n\t\t \n\t\tdiff_size = key->n_sz - req->src_len;\n\t\treq_ctx->fixup_src = req->src;\n\t\treq_ctx->fixup_src_len = req->src_len;\n\t}\n\n\tsrc_nents = sg_nents_for_len(req_ctx->fixup_src,\n\t\t\t\t     req_ctx->fixup_src_len);\n\tdst_nents = sg_nents_for_len(req->dst, req->dst_len);\n\n\tmapped_src_nents = dma_map_sg(dev, req_ctx->fixup_src, src_nents,\n\t\t\t\t      DMA_TO_DEVICE);\n\tif (unlikely(!mapped_src_nents)) {\n\t\tdev_err(dev, \"unable to map source\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmapped_dst_nents = dma_map_sg(dev, req->dst, dst_nents,\n\t\t\t\t      DMA_FROM_DEVICE);\n\tif (unlikely(!mapped_dst_nents)) {\n\t\tdev_err(dev, \"unable to map destination\\n\");\n\t\tgoto src_fail;\n\t}\n\n\tif (!diff_size && mapped_src_nents == 1)\n\t\tsec4_sg_len = 0;  \n\telse\n\t\tsec4_sg_len = mapped_src_nents + !!diff_size;\n\tsec4_sg_index = sec4_sg_len;\n\n\tif (mapped_dst_nents > 1)\n\t\tsec4_sg_len += pad_sg_nents(mapped_dst_nents);\n\telse\n\t\tsec4_sg_len = pad_sg_nents(sec4_sg_len);\n\n\tsec4_sg_bytes = sec4_sg_len * sizeof(struct sec4_sg_entry);\n\n\t \n\tedesc = kzalloc(sizeof(*edesc) + desclen + sec4_sg_bytes, flags);\n\tif (!edesc)\n\t\tgoto dst_fail;\n\n\tedesc->sec4_sg = (void *)edesc + sizeof(*edesc) + desclen;\n\tif (diff_size)\n\t\tdma_to_sec4_sg_one(edesc->sec4_sg, ctx->padding_dma, diff_size,\n\t\t\t\t   0);\n\n\tif (sec4_sg_index)\n\t\tsg_to_sec4_sg_last(req_ctx->fixup_src, req_ctx->fixup_src_len,\n\t\t\t\t   edesc->sec4_sg + !!diff_size, 0);\n\n\tif (mapped_dst_nents > 1)\n\t\tsg_to_sec4_sg_last(req->dst, req->dst_len,\n\t\t\t\t   edesc->sec4_sg + sec4_sg_index, 0);\n\n\t \n\tedesc->src_nents = src_nents;\n\tedesc->dst_nents = dst_nents;\n\n\treq_ctx->edesc = edesc;\n\n\tif (!sec4_sg_bytes)\n\t\treturn edesc;\n\n\tedesc->mapped_src_nents = mapped_src_nents;\n\tedesc->mapped_dst_nents = mapped_dst_nents;\n\n\tedesc->sec4_sg_dma = dma_map_single(dev, edesc->sec4_sg,\n\t\t\t\t\t    sec4_sg_bytes, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, edesc->sec4_sg_dma)) {\n\t\tdev_err(dev, \"unable to map S/G table\\n\");\n\t\tgoto sec4_sg_fail;\n\t}\n\n\tedesc->sec4_sg_bytes = sec4_sg_bytes;\n\n\tprint_hex_dump_debug(\"caampkc sec4_sg@\" __stringify(__LINE__) \": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, edesc->sec4_sg,\n\t\t\t     edesc->sec4_sg_bytes, 1);\n\n\treturn edesc;\n\nsec4_sg_fail:\n\tkfree(edesc);\ndst_fail:\n\tdma_unmap_sg(dev, req->dst, dst_nents, DMA_FROM_DEVICE);\nsrc_fail:\n\tdma_unmap_sg(dev, req_ctx->fixup_src, src_nents, DMA_TO_DEVICE);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic int akcipher_do_one_req(struct crypto_engine *engine, void *areq)\n{\n\tstruct akcipher_request *req = container_of(areq,\n\t\t\t\t\t\t    struct akcipher_request,\n\t\t\t\t\t\t    base);\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_req_ctx *req_ctx = akcipher_request_ctx(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct device *jrdev = ctx->dev;\n\tu32 *desc = req_ctx->edesc->hw_desc;\n\tint ret;\n\n\treq_ctx->edesc->bklog = true;\n\n\tret = caam_jr_enqueue(jrdev, desc, req_ctx->akcipher_op_done, req);\n\n\tif (ret == -ENOSPC && engine->retry_support)\n\t\treturn ret;\n\n\tif (ret != -EINPROGRESS) {\n\t\trsa_pub_unmap(jrdev, req_ctx->edesc, req);\n\t\trsa_io_unmap(jrdev, req_ctx->edesc, req);\n\t\tkfree(req_ctx->edesc);\n\t} else {\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int set_rsa_pub_pdb(struct akcipher_request *req,\n\t\t\t   struct rsa_edesc *edesc)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_req_ctx *req_ctx = akcipher_request_ctx(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct caam_rsa_key *key = &ctx->key;\n\tstruct device *dev = ctx->dev;\n\tstruct rsa_pub_pdb *pdb = &edesc->pdb.pub;\n\tint sec4_sg_index = 0;\n\n\tpdb->n_dma = dma_map_single(dev, key->n, key->n_sz, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, pdb->n_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA modulus memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpdb->e_dma = dma_map_single(dev, key->e, key->e_sz, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, pdb->e_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA public exponent memory\\n\");\n\t\tdma_unmap_single(dev, pdb->n_dma, key->n_sz, DMA_TO_DEVICE);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (edesc->mapped_src_nents > 1) {\n\t\tpdb->sgf |= RSA_PDB_SGF_F;\n\t\tpdb->f_dma = edesc->sec4_sg_dma;\n\t\tsec4_sg_index += edesc->mapped_src_nents;\n\t} else {\n\t\tpdb->f_dma = sg_dma_address(req_ctx->fixup_src);\n\t}\n\n\tif (edesc->mapped_dst_nents > 1) {\n\t\tpdb->sgf |= RSA_PDB_SGF_G;\n\t\tpdb->g_dma = edesc->sec4_sg_dma +\n\t\t\t     sec4_sg_index * sizeof(struct sec4_sg_entry);\n\t} else {\n\t\tpdb->g_dma = sg_dma_address(req->dst);\n\t}\n\n\tpdb->sgf |= (key->e_sz << RSA_PDB_E_SHIFT) | key->n_sz;\n\tpdb->f_len = req_ctx->fixup_src_len;\n\n\treturn 0;\n}\n\nstatic int set_rsa_priv_f1_pdb(struct akcipher_request *req,\n\t\t\t       struct rsa_edesc *edesc)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct caam_rsa_key *key = &ctx->key;\n\tstruct device *dev = ctx->dev;\n\tstruct rsa_priv_f1_pdb *pdb = &edesc->pdb.priv_f1;\n\tint sec4_sg_index = 0;\n\n\tpdb->n_dma = dma_map_single(dev, key->n, key->n_sz, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, pdb->n_dma)) {\n\t\tdev_err(dev, \"Unable to map modulus memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpdb->d_dma = dma_map_single(dev, key->d, key->d_sz, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, pdb->d_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA private exponent memory\\n\");\n\t\tdma_unmap_single(dev, pdb->n_dma, key->n_sz, DMA_TO_DEVICE);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (edesc->mapped_src_nents > 1) {\n\t\tpdb->sgf |= RSA_PRIV_PDB_SGF_G;\n\t\tpdb->g_dma = edesc->sec4_sg_dma;\n\t\tsec4_sg_index += edesc->mapped_src_nents;\n\n\t} else {\n\t\tstruct caam_rsa_req_ctx *req_ctx = akcipher_request_ctx(req);\n\n\t\tpdb->g_dma = sg_dma_address(req_ctx->fixup_src);\n\t}\n\n\tif (edesc->mapped_dst_nents > 1) {\n\t\tpdb->sgf |= RSA_PRIV_PDB_SGF_F;\n\t\tpdb->f_dma = edesc->sec4_sg_dma +\n\t\t\t     sec4_sg_index * sizeof(struct sec4_sg_entry);\n\t} else {\n\t\tpdb->f_dma = sg_dma_address(req->dst);\n\t}\n\n\tpdb->sgf |= (key->d_sz << RSA_PDB_D_SHIFT) | key->n_sz;\n\n\treturn 0;\n}\n\nstatic int set_rsa_priv_f2_pdb(struct akcipher_request *req,\n\t\t\t       struct rsa_edesc *edesc)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct caam_rsa_key *key = &ctx->key;\n\tstruct device *dev = ctx->dev;\n\tstruct rsa_priv_f2_pdb *pdb = &edesc->pdb.priv_f2;\n\tint sec4_sg_index = 0;\n\tsize_t p_sz = key->p_sz;\n\tsize_t q_sz = key->q_sz;\n\n\tpdb->d_dma = dma_map_single(dev, key->d, key->d_sz, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, pdb->d_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA private exponent memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpdb->p_dma = dma_map_single(dev, key->p, p_sz, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, pdb->p_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA prime factor p memory\\n\");\n\t\tgoto unmap_d;\n\t}\n\n\tpdb->q_dma = dma_map_single(dev, key->q, q_sz, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, pdb->q_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA prime factor q memory\\n\");\n\t\tgoto unmap_p;\n\t}\n\n\tpdb->tmp1_dma = dma_map_single(dev, key->tmp1, p_sz, DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dev, pdb->tmp1_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA tmp1 memory\\n\");\n\t\tgoto unmap_q;\n\t}\n\n\tpdb->tmp2_dma = dma_map_single(dev, key->tmp2, q_sz, DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dev, pdb->tmp2_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA tmp2 memory\\n\");\n\t\tgoto unmap_tmp1;\n\t}\n\n\tif (edesc->mapped_src_nents > 1) {\n\t\tpdb->sgf |= RSA_PRIV_PDB_SGF_G;\n\t\tpdb->g_dma = edesc->sec4_sg_dma;\n\t\tsec4_sg_index += edesc->mapped_src_nents;\n\t} else {\n\t\tstruct caam_rsa_req_ctx *req_ctx = akcipher_request_ctx(req);\n\n\t\tpdb->g_dma = sg_dma_address(req_ctx->fixup_src);\n\t}\n\n\tif (edesc->mapped_dst_nents > 1) {\n\t\tpdb->sgf |= RSA_PRIV_PDB_SGF_F;\n\t\tpdb->f_dma = edesc->sec4_sg_dma +\n\t\t\t     sec4_sg_index * sizeof(struct sec4_sg_entry);\n\t} else {\n\t\tpdb->f_dma = sg_dma_address(req->dst);\n\t}\n\n\tpdb->sgf |= (key->d_sz << RSA_PDB_D_SHIFT) | key->n_sz;\n\tpdb->p_q_len = (q_sz << RSA_PDB_Q_SHIFT) | p_sz;\n\n\treturn 0;\n\nunmap_tmp1:\n\tdma_unmap_single(dev, pdb->tmp1_dma, p_sz, DMA_BIDIRECTIONAL);\nunmap_q:\n\tdma_unmap_single(dev, pdb->q_dma, q_sz, DMA_TO_DEVICE);\nunmap_p:\n\tdma_unmap_single(dev, pdb->p_dma, p_sz, DMA_TO_DEVICE);\nunmap_d:\n\tdma_unmap_single(dev, pdb->d_dma, key->d_sz, DMA_TO_DEVICE);\n\n\treturn -ENOMEM;\n}\n\nstatic int set_rsa_priv_f3_pdb(struct akcipher_request *req,\n\t\t\t       struct rsa_edesc *edesc)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct caam_rsa_key *key = &ctx->key;\n\tstruct device *dev = ctx->dev;\n\tstruct rsa_priv_f3_pdb *pdb = &edesc->pdb.priv_f3;\n\tint sec4_sg_index = 0;\n\tsize_t p_sz = key->p_sz;\n\tsize_t q_sz = key->q_sz;\n\n\tpdb->p_dma = dma_map_single(dev, key->p, p_sz, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, pdb->p_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA prime factor p memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpdb->q_dma = dma_map_single(dev, key->q, q_sz, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, pdb->q_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA prime factor q memory\\n\");\n\t\tgoto unmap_p;\n\t}\n\n\tpdb->dp_dma = dma_map_single(dev, key->dp, p_sz, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, pdb->dp_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA exponent dp memory\\n\");\n\t\tgoto unmap_q;\n\t}\n\n\tpdb->dq_dma = dma_map_single(dev, key->dq, q_sz, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, pdb->dq_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA exponent dq memory\\n\");\n\t\tgoto unmap_dp;\n\t}\n\n\tpdb->c_dma = dma_map_single(dev, key->qinv, p_sz, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, pdb->c_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA CRT coefficient qinv memory\\n\");\n\t\tgoto unmap_dq;\n\t}\n\n\tpdb->tmp1_dma = dma_map_single(dev, key->tmp1, p_sz, DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dev, pdb->tmp1_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA tmp1 memory\\n\");\n\t\tgoto unmap_qinv;\n\t}\n\n\tpdb->tmp2_dma = dma_map_single(dev, key->tmp2, q_sz, DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dev, pdb->tmp2_dma)) {\n\t\tdev_err(dev, \"Unable to map RSA tmp2 memory\\n\");\n\t\tgoto unmap_tmp1;\n\t}\n\n\tif (edesc->mapped_src_nents > 1) {\n\t\tpdb->sgf |= RSA_PRIV_PDB_SGF_G;\n\t\tpdb->g_dma = edesc->sec4_sg_dma;\n\t\tsec4_sg_index += edesc->mapped_src_nents;\n\t} else {\n\t\tstruct caam_rsa_req_ctx *req_ctx = akcipher_request_ctx(req);\n\n\t\tpdb->g_dma = sg_dma_address(req_ctx->fixup_src);\n\t}\n\n\tif (edesc->mapped_dst_nents > 1) {\n\t\tpdb->sgf |= RSA_PRIV_PDB_SGF_F;\n\t\tpdb->f_dma = edesc->sec4_sg_dma +\n\t\t\t     sec4_sg_index * sizeof(struct sec4_sg_entry);\n\t} else {\n\t\tpdb->f_dma = sg_dma_address(req->dst);\n\t}\n\n\tpdb->sgf |= key->n_sz;\n\tpdb->p_q_len = (q_sz << RSA_PDB_Q_SHIFT) | p_sz;\n\n\treturn 0;\n\nunmap_tmp1:\n\tdma_unmap_single(dev, pdb->tmp1_dma, p_sz, DMA_BIDIRECTIONAL);\nunmap_qinv:\n\tdma_unmap_single(dev, pdb->c_dma, p_sz, DMA_TO_DEVICE);\nunmap_dq:\n\tdma_unmap_single(dev, pdb->dq_dma, q_sz, DMA_TO_DEVICE);\nunmap_dp:\n\tdma_unmap_single(dev, pdb->dp_dma, p_sz, DMA_TO_DEVICE);\nunmap_q:\n\tdma_unmap_single(dev, pdb->q_dma, q_sz, DMA_TO_DEVICE);\nunmap_p:\n\tdma_unmap_single(dev, pdb->p_dma, p_sz, DMA_TO_DEVICE);\n\n\treturn -ENOMEM;\n}\n\nstatic int akcipher_enqueue_req(struct device *jrdev,\n\t\t\t\tvoid (*cbk)(struct device *jrdev, u32 *desc,\n\t\t\t\t\t    u32 err, void *context),\n\t\t\t\tstruct akcipher_request *req)\n{\n\tstruct caam_drv_private_jr *jrpriv = dev_get_drvdata(jrdev);\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct caam_rsa_key *key = &ctx->key;\n\tstruct caam_rsa_req_ctx *req_ctx = akcipher_request_ctx(req);\n\tstruct rsa_edesc *edesc = req_ctx->edesc;\n\tu32 *desc = edesc->hw_desc;\n\tint ret;\n\n\treq_ctx->akcipher_op_done = cbk;\n\t \n\tif (req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)\n\t\tret = crypto_transfer_akcipher_request_to_engine(jrpriv->engine,\n\t\t\t\t\t\t\t\t req);\n\telse\n\t\tret = caam_jr_enqueue(jrdev, desc, cbk, req);\n\n\tif ((ret != -EINPROGRESS) && (ret != -EBUSY)) {\n\t\tswitch (key->priv_form) {\n\t\tcase FORM1:\n\t\t\trsa_priv_f1_unmap(jrdev, edesc, req);\n\t\t\tbreak;\n\t\tcase FORM2:\n\t\t\trsa_priv_f2_unmap(jrdev, edesc, req);\n\t\t\tbreak;\n\t\tcase FORM3:\n\t\t\trsa_priv_f3_unmap(jrdev, edesc, req);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trsa_pub_unmap(jrdev, edesc, req);\n\t\t}\n\t\trsa_io_unmap(jrdev, edesc, req);\n\t\tkfree(edesc);\n\t}\n\n\treturn ret;\n}\n\nstatic int caam_rsa_enc(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct caam_rsa_key *key = &ctx->key;\n\tstruct device *jrdev = ctx->dev;\n\tstruct rsa_edesc *edesc;\n\tint ret;\n\n\tif (unlikely(!key->n || !key->e))\n\t\treturn -EINVAL;\n\n\tif (req->dst_len < key->n_sz) {\n\t\treq->dst_len = key->n_sz;\n\t\tdev_err(jrdev, \"Output buffer length less than parameter n\\n\");\n\t\treturn -EOVERFLOW;\n\t}\n\n\t \n\tedesc = rsa_edesc_alloc(req, DESC_RSA_PUB_LEN);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\t \n\tret = set_rsa_pub_pdb(req, edesc);\n\tif (ret)\n\t\tgoto init_fail;\n\n\t \n\tinit_rsa_pub_desc(edesc->hw_desc, &edesc->pdb.pub);\n\n\treturn akcipher_enqueue_req(jrdev, rsa_pub_done, req);\n\ninit_fail:\n\trsa_io_unmap(jrdev, edesc, req);\n\tkfree(edesc);\n\treturn ret;\n}\n\nstatic int caam_rsa_dec_priv_f1(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct device *jrdev = ctx->dev;\n\tstruct rsa_edesc *edesc;\n\tint ret;\n\n\t \n\tedesc = rsa_edesc_alloc(req, DESC_RSA_PRIV_F1_LEN);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\t \n\tret = set_rsa_priv_f1_pdb(req, edesc);\n\tif (ret)\n\t\tgoto init_fail;\n\n\t \n\tinit_rsa_priv_f1_desc(edesc->hw_desc, &edesc->pdb.priv_f1);\n\n\treturn akcipher_enqueue_req(jrdev, rsa_priv_f_done, req);\n\ninit_fail:\n\trsa_io_unmap(jrdev, edesc, req);\n\tkfree(edesc);\n\treturn ret;\n}\n\nstatic int caam_rsa_dec_priv_f2(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct device *jrdev = ctx->dev;\n\tstruct rsa_edesc *edesc;\n\tint ret;\n\n\t \n\tedesc = rsa_edesc_alloc(req, DESC_RSA_PRIV_F2_LEN);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\t \n\tret = set_rsa_priv_f2_pdb(req, edesc);\n\tif (ret)\n\t\tgoto init_fail;\n\n\t \n\tinit_rsa_priv_f2_desc(edesc->hw_desc, &edesc->pdb.priv_f2);\n\n\treturn akcipher_enqueue_req(jrdev, rsa_priv_f_done, req);\n\ninit_fail:\n\trsa_io_unmap(jrdev, edesc, req);\n\tkfree(edesc);\n\treturn ret;\n}\n\nstatic int caam_rsa_dec_priv_f3(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct device *jrdev = ctx->dev;\n\tstruct rsa_edesc *edesc;\n\tint ret;\n\n\t \n\tedesc = rsa_edesc_alloc(req, DESC_RSA_PRIV_F3_LEN);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\t \n\tret = set_rsa_priv_f3_pdb(req, edesc);\n\tif (ret)\n\t\tgoto init_fail;\n\n\t \n\tinit_rsa_priv_f3_desc(edesc->hw_desc, &edesc->pdb.priv_f3);\n\n\treturn akcipher_enqueue_req(jrdev, rsa_priv_f_done, req);\n\ninit_fail:\n\trsa_io_unmap(jrdev, edesc, req);\n\tkfree(edesc);\n\treturn ret;\n}\n\nstatic int caam_rsa_dec(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct caam_rsa_key *key = &ctx->key;\n\tint ret;\n\n\tif (unlikely(!key->n || !key->d))\n\t\treturn -EINVAL;\n\n\tif (req->dst_len < key->n_sz) {\n\t\treq->dst_len = key->n_sz;\n\t\tdev_err(ctx->dev, \"Output buffer length less than parameter n\\n\");\n\t\treturn -EOVERFLOW;\n\t}\n\n\tif (key->priv_form == FORM3)\n\t\tret = caam_rsa_dec_priv_f3(req);\n\telse if (key->priv_form == FORM2)\n\t\tret = caam_rsa_dec_priv_f2(req);\n\telse\n\t\tret = caam_rsa_dec_priv_f1(req);\n\n\treturn ret;\n}\n\nstatic void caam_rsa_free_key(struct caam_rsa_key *key)\n{\n\tkfree_sensitive(key->d);\n\tkfree_sensitive(key->p);\n\tkfree_sensitive(key->q);\n\tkfree_sensitive(key->dp);\n\tkfree_sensitive(key->dq);\n\tkfree_sensitive(key->qinv);\n\tkfree_sensitive(key->tmp1);\n\tkfree_sensitive(key->tmp2);\n\tkfree(key->e);\n\tkfree(key->n);\n\tmemset(key, 0, sizeof(*key));\n}\n\nstatic void caam_rsa_drop_leading_zeros(const u8 **ptr, size_t *nbytes)\n{\n\twhile (!**ptr && *nbytes) {\n\t\t(*ptr)++;\n\t\t(*nbytes)--;\n\t}\n}\n\n \nstatic u8 *caam_read_rsa_crt(const u8 *ptr, size_t nbytes, size_t dstlen)\n{\n\tu8 *dst;\n\n\tcaam_rsa_drop_leading_zeros(&ptr, &nbytes);\n\tif (!nbytes)\n\t\treturn NULL;\n\n\tdst = kzalloc(dstlen, GFP_KERNEL);\n\tif (!dst)\n\t\treturn NULL;\n\n\tmemcpy(dst + (dstlen - nbytes), ptr, nbytes);\n\n\treturn dst;\n}\n\n \nstatic inline u8 *caam_read_raw_data(const u8 *buf, size_t *nbytes)\n{\n\n\tcaam_rsa_drop_leading_zeros(&buf, nbytes);\n\tif (!*nbytes)\n\t\treturn NULL;\n\n\treturn kmemdup(buf, *nbytes, GFP_KERNEL);\n}\n\nstatic int caam_rsa_check_key_length(unsigned int len)\n{\n\tif (len > 4096)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int caam_rsa_set_pub_key(struct crypto_akcipher *tfm, const void *key,\n\t\t\t\tunsigned int keylen)\n{\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct rsa_key raw_key = {NULL};\n\tstruct caam_rsa_key *rsa_key = &ctx->key;\n\tint ret;\n\n\t \n\tcaam_rsa_free_key(rsa_key);\n\n\tret = rsa_parse_pub_key(&raw_key, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trsa_key->e = kmemdup(raw_key.e, raw_key.e_sz, GFP_KERNEL);\n\tif (!rsa_key->e)\n\t\tgoto err;\n\n\t \n\trsa_key->n = caam_read_raw_data(raw_key.n, &raw_key.n_sz);\n\tif (!rsa_key->n)\n\t\tgoto err;\n\n\tif (caam_rsa_check_key_length(raw_key.n_sz << 3)) {\n\t\tcaam_rsa_free_key(rsa_key);\n\t\treturn -EINVAL;\n\t}\n\n\trsa_key->e_sz = raw_key.e_sz;\n\trsa_key->n_sz = raw_key.n_sz;\n\n\treturn 0;\nerr:\n\tcaam_rsa_free_key(rsa_key);\n\treturn -ENOMEM;\n}\n\nstatic void caam_rsa_set_priv_key_form(struct caam_rsa_ctx *ctx,\n\t\t\t\t       struct rsa_key *raw_key)\n{\n\tstruct caam_rsa_key *rsa_key = &ctx->key;\n\tsize_t p_sz = raw_key->p_sz;\n\tsize_t q_sz = raw_key->q_sz;\n\tunsigned aligned_size;\n\n\trsa_key->p = caam_read_raw_data(raw_key->p, &p_sz);\n\tif (!rsa_key->p)\n\t\treturn;\n\trsa_key->p_sz = p_sz;\n\n\trsa_key->q = caam_read_raw_data(raw_key->q, &q_sz);\n\tif (!rsa_key->q)\n\t\tgoto free_p;\n\trsa_key->q_sz = q_sz;\n\n\taligned_size = ALIGN(raw_key->p_sz, dma_get_cache_alignment());\n\trsa_key->tmp1 = kzalloc(aligned_size, GFP_KERNEL);\n\tif (!rsa_key->tmp1)\n\t\tgoto free_q;\n\n\taligned_size = ALIGN(raw_key->q_sz, dma_get_cache_alignment());\n\trsa_key->tmp2 = kzalloc(aligned_size, GFP_KERNEL);\n\tif (!rsa_key->tmp2)\n\t\tgoto free_tmp1;\n\n\trsa_key->priv_form = FORM2;\n\n\trsa_key->dp = caam_read_rsa_crt(raw_key->dp, raw_key->dp_sz, p_sz);\n\tif (!rsa_key->dp)\n\t\tgoto free_tmp2;\n\n\trsa_key->dq = caam_read_rsa_crt(raw_key->dq, raw_key->dq_sz, q_sz);\n\tif (!rsa_key->dq)\n\t\tgoto free_dp;\n\n\trsa_key->qinv = caam_read_rsa_crt(raw_key->qinv, raw_key->qinv_sz,\n\t\t\t\t\t  q_sz);\n\tif (!rsa_key->qinv)\n\t\tgoto free_dq;\n\n\trsa_key->priv_form = FORM3;\n\n\treturn;\n\nfree_dq:\n\tkfree_sensitive(rsa_key->dq);\nfree_dp:\n\tkfree_sensitive(rsa_key->dp);\nfree_tmp2:\n\tkfree_sensitive(rsa_key->tmp2);\nfree_tmp1:\n\tkfree_sensitive(rsa_key->tmp1);\nfree_q:\n\tkfree_sensitive(rsa_key->q);\nfree_p:\n\tkfree_sensitive(rsa_key->p);\n}\n\nstatic int caam_rsa_set_priv_key(struct crypto_akcipher *tfm, const void *key,\n\t\t\t\t unsigned int keylen)\n{\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct rsa_key raw_key = {NULL};\n\tstruct caam_rsa_key *rsa_key = &ctx->key;\n\tint ret;\n\n\t \n\tcaam_rsa_free_key(rsa_key);\n\n\tret = rsa_parse_priv_key(&raw_key, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trsa_key->d = kmemdup(raw_key.d, raw_key.d_sz, GFP_KERNEL);\n\tif (!rsa_key->d)\n\t\tgoto err;\n\n\trsa_key->e = kmemdup(raw_key.e, raw_key.e_sz, GFP_KERNEL);\n\tif (!rsa_key->e)\n\t\tgoto err;\n\n\t \n\trsa_key->n = caam_read_raw_data(raw_key.n, &raw_key.n_sz);\n\tif (!rsa_key->n)\n\t\tgoto err;\n\n\tif (caam_rsa_check_key_length(raw_key.n_sz << 3)) {\n\t\tcaam_rsa_free_key(rsa_key);\n\t\treturn -EINVAL;\n\t}\n\n\trsa_key->d_sz = raw_key.d_sz;\n\trsa_key->e_sz = raw_key.e_sz;\n\trsa_key->n_sz = raw_key.n_sz;\n\n\tcaam_rsa_set_priv_key_form(ctx, &raw_key);\n\n\treturn 0;\n\nerr:\n\tcaam_rsa_free_key(rsa_key);\n\treturn -ENOMEM;\n}\n\nstatic unsigned int caam_rsa_max_size(struct crypto_akcipher *tfm)\n{\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\n\treturn ctx->key.n_sz;\n}\n\n \nstatic int caam_rsa_init_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\n\takcipher_set_reqsize(tfm, sizeof(struct caam_rsa_req_ctx));\n\n\tctx->dev = caam_jr_alloc();\n\n\tif (IS_ERR(ctx->dev)) {\n\t\tpr_err(\"Job Ring Device allocation for transform failed\\n\");\n\t\treturn PTR_ERR(ctx->dev);\n\t}\n\n\tctx->padding_dma = dma_map_single(ctx->dev, zero_buffer,\n\t\t\t\t\t  CAAM_RSA_MAX_INPUT_SIZE - 1,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(ctx->dev, ctx->padding_dma)) {\n\t\tdev_err(ctx->dev, \"unable to map padding\\n\");\n\t\tcaam_jr_free(ctx->dev);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void caam_rsa_exit_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct caam_rsa_key *key = &ctx->key;\n\n\tdma_unmap_single(ctx->dev, ctx->padding_dma, CAAM_RSA_MAX_INPUT_SIZE -\n\t\t\t 1, DMA_TO_DEVICE);\n\tcaam_rsa_free_key(key);\n\tcaam_jr_free(ctx->dev);\n}\n\nstatic struct caam_akcipher_alg caam_rsa = {\n\t.akcipher.base = {\n\t\t.encrypt = caam_rsa_enc,\n\t\t.decrypt = caam_rsa_dec,\n\t\t.set_pub_key = caam_rsa_set_pub_key,\n\t\t.set_priv_key = caam_rsa_set_priv_key,\n\t\t.max_size = caam_rsa_max_size,\n\t\t.init = caam_rsa_init_tfm,\n\t\t.exit = caam_rsa_exit_tfm,\n\t\t.base = {\n\t\t\t.cra_name = \"rsa\",\n\t\t\t.cra_driver_name = \"rsa-caam\",\n\t\t\t.cra_priority = 3000,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_ctxsize = sizeof(struct caam_rsa_ctx) +\n\t\t\t\t       CRYPTO_DMA_PADDING,\n\t\t},\n\t},\n\t.akcipher.op = {\n\t\t.do_one_request = akcipher_do_one_req,\n\t},\n};\n\n \nint caam_pkc_init(struct device *ctrldev)\n{\n\tstruct caam_drv_private *priv = dev_get_drvdata(ctrldev);\n\tu32 pk_inst, pkha;\n\tint err;\n\tinit_done = false;\n\n\t \n\tif (priv->era < 10) {\n\t\tpk_inst = (rd_reg32(&priv->jr[0]->perfmon.cha_num_ls) &\n\t\t\t   CHA_ID_LS_PK_MASK) >> CHA_ID_LS_PK_SHIFT;\n\t} else {\n\t\tpkha = rd_reg32(&priv->jr[0]->vreg.pkha);\n\t\tpk_inst = pkha & CHA_VER_NUM_MASK;\n\n\t\t \n\t\tif (pkha & CHA_VER_MISC_PKHA_NO_CRYPT)\n\t\t\tpk_inst = 0;\n\t}\n\n\t \n\tif (!pk_inst)\n\t\treturn 0;\n\n\t \n\tzero_buffer = kzalloc(CAAM_RSA_MAX_INPUT_SIZE - 1, GFP_KERNEL);\n\tif (!zero_buffer)\n\t\treturn -ENOMEM;\n\n\terr = crypto_engine_register_akcipher(&caam_rsa.akcipher);\n\n\tif (err) {\n\t\tkfree(zero_buffer);\n\t\tdev_warn(ctrldev, \"%s alg registration failed\\n\",\n\t\t\t caam_rsa.akcipher.base.base.cra_driver_name);\n\t} else {\n\t\tinit_done = true;\n\t\tcaam_rsa.registered = true;\n\t\tdev_info(ctrldev, \"caam pkc algorithms registered in /proc/crypto\\n\");\n\t}\n\n\treturn err;\n}\n\nvoid caam_pkc_exit(void)\n{\n\tif (!init_done)\n\t\treturn;\n\n\tif (caam_rsa.registered)\n\t\tcrypto_engine_unregister_akcipher(&caam_rsa.akcipher);\n\n\tkfree(zero_buffer);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}