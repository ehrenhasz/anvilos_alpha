{
  "module_name": "caamrng.c",
  "hash_id": "19f6d77ea54fdd6a85a41ee8e8fad639399332fa22398b3d461fc75db9cf70f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/caam/caamrng.c",
  "human_readable_source": "\n \n\n#include <linux/hw_random.h>\n#include <linux/completion.h>\n#include <linux/atomic.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/kfifo.h>\n\n#include \"compat.h\"\n\n#include \"regs.h\"\n#include \"intern.h\"\n#include \"desc_constr.h\"\n#include \"jr.h\"\n#include \"error.h\"\n\n#define CAAM_RNG_MAX_FIFO_STORE_SIZE\t16\n\n \n#define CAAM_RNG_DESC_LEN (CAAM_CMD_SZ +\t\t\t\t\\\n\t\t\t   CAAM_CMD_SZ +\t\t\t\t\\\n\t\t\t   CAAM_CMD_SZ + CAAM_PTR_SZ_MAX)\n\n \nstruct caam_rng_ctx {\n\tstruct hwrng rng;\n\tstruct device *jrdev;\n\tstruct device *ctrldev;\n\tvoid *desc_async;\n\tvoid *desc_sync;\n\tstruct work_struct worker;\n\tstruct kfifo fifo;\n};\n\nstruct caam_rng_job_ctx {\n\tstruct completion *done;\n\tint *err;\n};\n\nstatic struct caam_rng_ctx *to_caam_rng_ctx(struct hwrng *r)\n{\n\treturn (struct caam_rng_ctx *)r->priv;\n}\n\nstatic void caam_rng_done(struct device *jrdev, u32 *desc, u32 err,\n\t\t\t  void *context)\n{\n\tstruct caam_rng_job_ctx *jctx = context;\n\n\tif (err)\n\t\t*jctx->err = caam_jr_strstatus(jrdev, err);\n\n\tcomplete(jctx->done);\n}\n\nstatic u32 *caam_init_desc(u32 *desc, dma_addr_t dst_dma)\n{\n\tinit_job_desc(desc, 0);\t \n\t \n\tappend_operation(desc, OP_ALG_ALGSEL_RNG | OP_TYPE_CLASS1_ALG |\n\t\t\t OP_ALG_PR_ON);\n\t \n\tappend_fifo_store(desc, dst_dma,\n\t\t\t  CAAM_RNG_MAX_FIFO_STORE_SIZE, FIFOST_TYPE_RNGSTORE);\n\n\tprint_hex_dump_debug(\"rng job desc@: \", DUMP_PREFIX_ADDRESS,\n\t\t\t     16, 4, desc, desc_bytes(desc), 1);\n\n\treturn desc;\n}\n\nstatic int caam_rng_read_one(struct device *jrdev,\n\t\t\t     void *dst, int len,\n\t\t\t     void *desc,\n\t\t\t     struct completion *done)\n{\n\tdma_addr_t dst_dma;\n\tint err, ret = 0;\n\tstruct caam_rng_job_ctx jctx = {\n\t\t.done = done,\n\t\t.err  = &ret,\n\t};\n\n\tlen = CAAM_RNG_MAX_FIFO_STORE_SIZE;\n\n\tdst_dma = dma_map_single(jrdev, dst, len, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(jrdev, dst_dma)) {\n\t\tdev_err(jrdev, \"unable to map destination memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_completion(done);\n\terr = caam_jr_enqueue(jrdev,\n\t\t\t      caam_init_desc(desc, dst_dma),\n\t\t\t      caam_rng_done, &jctx);\n\tif (err == -EINPROGRESS) {\n\t\twait_for_completion(done);\n\t\terr = 0;\n\t}\n\n\tdma_unmap_single(jrdev, dst_dma, len, DMA_FROM_DEVICE);\n\n\treturn err ?: (ret ?: len);\n}\n\nstatic void caam_rng_fill_async(struct caam_rng_ctx *ctx)\n{\n\tstruct scatterlist sg[1];\n\tstruct completion done;\n\tint len, nents;\n\n\tsg_init_table(sg, ARRAY_SIZE(sg));\n\tnents = kfifo_dma_in_prepare(&ctx->fifo, sg, ARRAY_SIZE(sg),\n\t\t\t\t     CAAM_RNG_MAX_FIFO_STORE_SIZE);\n\tif (!nents)\n\t\treturn;\n\n\tlen = caam_rng_read_one(ctx->jrdev, sg_virt(&sg[0]),\n\t\t\t\tsg[0].length,\n\t\t\t\tctx->desc_async,\n\t\t\t\t&done);\n\tif (len < 0)\n\t\treturn;\n\n\tkfifo_dma_in_finish(&ctx->fifo, len);\n}\n\nstatic void caam_rng_worker(struct work_struct *work)\n{\n\tstruct caam_rng_ctx *ctx = container_of(work, struct caam_rng_ctx,\n\t\t\t\t\t\tworker);\n\tcaam_rng_fill_async(ctx);\n}\n\nstatic int caam_read(struct hwrng *rng, void *dst, size_t max, bool wait)\n{\n\tstruct caam_rng_ctx *ctx = to_caam_rng_ctx(rng);\n\tint out;\n\n\tif (wait) {\n\t\tstruct completion done;\n\n\t\treturn caam_rng_read_one(ctx->jrdev, dst, max,\n\t\t\t\t\t ctx->desc_sync, &done);\n\t}\n\n\tout = kfifo_out(&ctx->fifo, dst, max);\n\tif (kfifo_is_empty(&ctx->fifo))\n\t\tschedule_work(&ctx->worker);\n\n\treturn out;\n}\n\nstatic void caam_cleanup(struct hwrng *rng)\n{\n\tstruct caam_rng_ctx *ctx = to_caam_rng_ctx(rng);\n\n\tflush_work(&ctx->worker);\n\tcaam_jr_free(ctx->jrdev);\n\tkfifo_free(&ctx->fifo);\n}\n\n#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_TEST\nstatic inline void test_len(struct hwrng *rng, size_t len, bool wait)\n{\n\tu8 *buf;\n\tint read_len;\n\tstruct caam_rng_ctx *ctx = to_caam_rng_ctx(rng);\n\tstruct device *dev = ctx->ctrldev;\n\n\tbuf = kcalloc(CAAM_RNG_MAX_FIFO_STORE_SIZE, sizeof(u8), GFP_KERNEL);\n\n\twhile (len > 0) {\n\t\tread_len = rng->read(rng, buf, len, wait);\n\n\t\tif (read_len < 0 || (read_len == 0 && wait)) {\n\t\t\tdev_err(dev, \"RNG Read FAILED received %d bytes\\n\",\n\t\t\t\tread_len);\n\t\t\tkfree(buf);\n\t\t\treturn;\n\t\t}\n\n\t\tprint_hex_dump_debug(\"random bytes@: \",\n\t\t\tDUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\tbuf, read_len, 1);\n\n\t\tlen = len - read_len;\n\t}\n\n\tkfree(buf);\n}\n\nstatic inline void test_mode_once(struct hwrng *rng, bool wait)\n{\n\ttest_len(rng, 32, wait);\n\ttest_len(rng, 64, wait);\n\ttest_len(rng, 128, wait);\n}\n\nstatic void self_test(struct hwrng *rng)\n{\n\tpr_info(\"Executing RNG SELF-TEST with wait\\n\");\n\ttest_mode_once(rng, true);\n}\n#endif\n\nstatic int caam_init(struct hwrng *rng)\n{\n\tstruct caam_rng_ctx *ctx = to_caam_rng_ctx(rng);\n\tint err;\n\n\tctx->desc_sync = devm_kzalloc(ctx->ctrldev, CAAM_RNG_DESC_LEN,\n\t\t\t\t      GFP_KERNEL);\n\tif (!ctx->desc_sync)\n\t\treturn -ENOMEM;\n\n\tctx->desc_async = devm_kzalloc(ctx->ctrldev, CAAM_RNG_DESC_LEN,\n\t\t\t\t       GFP_KERNEL);\n\tif (!ctx->desc_async)\n\t\treturn -ENOMEM;\n\n\tif (kfifo_alloc(&ctx->fifo, ALIGN(CAAM_RNG_MAX_FIFO_STORE_SIZE,\n\t\t\t\t\t  dma_get_cache_alignment()),\n\t\t\tGFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&ctx->worker, caam_rng_worker);\n\n\tctx->jrdev = caam_jr_alloc();\n\terr = PTR_ERR_OR_ZERO(ctx->jrdev);\n\tif (err) {\n\t\tkfifo_free(&ctx->fifo);\n\t\tpr_err(\"Job Ring Device allocation for transform failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tcaam_rng_fill_async(ctx);\n\n\treturn 0;\n}\n\nint caam_rng_init(struct device *ctrldev);\n\nvoid caam_rng_exit(struct device *ctrldev)\n{\n\tdevres_release_group(ctrldev, caam_rng_init);\n}\n\nint caam_rng_init(struct device *ctrldev)\n{\n\tstruct caam_rng_ctx *ctx;\n\tu32 rng_inst;\n\tstruct caam_drv_private *priv = dev_get_drvdata(ctrldev);\n\tint ret;\n\n\t \n\tif (priv->era < 10)\n\t\trng_inst = (rd_reg32(&priv->jr[0]->perfmon.cha_num_ls) &\n\t\t\t    CHA_ID_LS_RNG_MASK) >> CHA_ID_LS_RNG_SHIFT;\n\telse\n\t\trng_inst = rd_reg32(&priv->jr[0]->vreg.rng) & CHA_VER_NUM_MASK;\n\n\tif (!rng_inst)\n\t\treturn 0;\n\n\tif (!devres_open_group(ctrldev, caam_rng_init, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tctx = devm_kzalloc(ctrldev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ctrldev = ctrldev;\n\n\tctx->rng.name    = \"rng-caam\";\n\tctx->rng.init    = caam_init;\n\tctx->rng.cleanup = caam_cleanup;\n\tctx->rng.read    = caam_read;\n\tctx->rng.priv    = (unsigned long)ctx;\n\n\tdev_info(ctrldev, \"registering rng-caam\\n\");\n\n\tret = devm_hwrng_register(ctrldev, &ctx->rng);\n\tif (ret) {\n\t\tcaam_rng_exit(ctrldev);\n\t\treturn ret;\n\t}\n\n#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_TEST\n\tself_test(&ctx->rng);\n#endif\n\n\tdevres_close_group(ctrldev, caam_rng_init);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}