{
  "module_name": "caamalg_qi.c",
  "hash_id": "d9f5b81abb4bbe494197a0bcb6910aaff84d8f3b32395ed23e8ed5adaf3c8fe6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/caam/caamalg_qi.c",
  "human_readable_source": "\n \n\n#include \"compat.h\"\n#include \"ctrl.h\"\n#include \"regs.h\"\n#include \"intern.h\"\n#include \"desc_constr.h\"\n#include \"error.h\"\n#include \"sg_sw_qm.h\"\n#include \"key_gen.h\"\n#include \"qi.h\"\n#include \"jr.h\"\n#include \"caamalg_desc.h\"\n#include <crypto/xts.h>\n#include <asm/unaligned.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\n \n#define CAAM_CRA_PRIORITY\t\t2000\n \n#define CAAM_MAX_KEY_SIZE\t\t(AES_MAX_KEY_SIZE + \\\n\t\t\t\t\t SHA512_DIGEST_SIZE * 2)\n\n#define DESC_MAX_USED_BYTES\t\t(DESC_QI_AEAD_GIVENC_LEN + \\\n\t\t\t\t\t CAAM_MAX_KEY_SIZE)\n#define DESC_MAX_USED_LEN\t\t(DESC_MAX_USED_BYTES / CAAM_CMD_SZ)\n\nstruct caam_alg_entry {\n\tint class1_alg_type;\n\tint class2_alg_type;\n\tbool rfc3686;\n\tbool geniv;\n\tbool nodkp;\n};\n\nstruct caam_aead_alg {\n\tstruct aead_alg aead;\n\tstruct caam_alg_entry caam;\n\tbool registered;\n};\n\nstruct caam_skcipher_alg {\n\tstruct skcipher_alg skcipher;\n\tstruct caam_alg_entry caam;\n\tbool registered;\n};\n\n \nstruct caam_ctx {\n\tstruct device *jrdev;\n\tu32 sh_desc_enc[DESC_MAX_USED_LEN];\n\tu32 sh_desc_dec[DESC_MAX_USED_LEN];\n\tu8 key[CAAM_MAX_KEY_SIZE];\n\tdma_addr_t key_dma;\n\tenum dma_data_direction dir;\n\tstruct alginfo adata;\n\tstruct alginfo cdata;\n\tunsigned int authsize;\n\tstruct device *qidev;\n\tspinlock_t lock;\t \n\tstruct caam_drv_ctx *drv_ctx[NUM_OP];\n\tbool xts_key_fallback;\n\tstruct crypto_skcipher *fallback;\n};\n\nstruct caam_skcipher_req_ctx {\n\tstruct skcipher_request fallback_req;\n};\n\nstatic int aead_set_sh_desc(struct crypto_aead *aead)\n{\n\tstruct caam_aead_alg *alg = container_of(crypto_aead_alg(aead),\n\t\t\t\t\t\t typeof(*alg), aead);\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tunsigned int ivsize = crypto_aead_ivsize(aead);\n\tu32 ctx1_iv_off = 0;\n\tu32 *nonce = NULL;\n\tunsigned int data_len[2];\n\tu32 inl_mask;\n\tconst bool ctr_mode = ((ctx->cdata.algtype & OP_ALG_AAI_MASK) ==\n\t\t\t       OP_ALG_AAI_CTR_MOD128);\n\tconst bool is_rfc3686 = alg->caam.rfc3686;\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(ctx->jrdev->parent);\n\n\tif (!ctx->cdata.keylen || !ctx->authsize)\n\t\treturn 0;\n\n\t \n\tif (ctr_mode)\n\t\tctx1_iv_off = 16;\n\n\t \n\tif (is_rfc3686) {\n\t\tctx1_iv_off = 16 + CTR_RFC3686_NONCE_SIZE;\n\t\tnonce = (u32 *)((void *)ctx->key + ctx->adata.keylen_pad +\n\t\t\t\tctx->cdata.keylen - CTR_RFC3686_NONCE_SIZE);\n\t}\n\n\t \n\tctx->adata.key_virt = ctx->key;\n\tctx->adata.key_dma = ctx->key_dma;\n\n\tctx->cdata.key_virt = ctx->key + ctx->adata.keylen_pad;\n\tctx->cdata.key_dma = ctx->key_dma + ctx->adata.keylen_pad;\n\n\tdata_len[0] = ctx->adata.keylen_pad;\n\tdata_len[1] = ctx->cdata.keylen;\n\n\tif (alg->caam.geniv)\n\t\tgoto skip_enc;\n\n\t \n\tif (desc_inline_query(DESC_QI_AEAD_ENC_LEN +\n\t\t\t      (is_rfc3686 ? DESC_AEAD_CTR_RFC3686_LEN : 0),\n\t\t\t      DESC_JOB_IO_LEN, data_len, &inl_mask,\n\t\t\t      ARRAY_SIZE(data_len)) < 0)\n\t\treturn -EINVAL;\n\n\tctx->adata.key_inline = !!(inl_mask & 1);\n\tctx->cdata.key_inline = !!(inl_mask & 2);\n\n\tcnstr_shdsc_aead_encap(ctx->sh_desc_enc, &ctx->cdata, &ctx->adata,\n\t\t\t       ivsize, ctx->authsize, is_rfc3686, nonce,\n\t\t\t       ctx1_iv_off, true, ctrlpriv->era);\n\nskip_enc:\n\t \n\tif (desc_inline_query(DESC_QI_AEAD_DEC_LEN +\n\t\t\t      (is_rfc3686 ? DESC_AEAD_CTR_RFC3686_LEN : 0),\n\t\t\t      DESC_JOB_IO_LEN, data_len, &inl_mask,\n\t\t\t      ARRAY_SIZE(data_len)) < 0)\n\t\treturn -EINVAL;\n\n\tctx->adata.key_inline = !!(inl_mask & 1);\n\tctx->cdata.key_inline = !!(inl_mask & 2);\n\n\tcnstr_shdsc_aead_decap(ctx->sh_desc_dec, &ctx->cdata, &ctx->adata,\n\t\t\t       ivsize, ctx->authsize, alg->caam.geniv,\n\t\t\t       is_rfc3686, nonce, ctx1_iv_off, true,\n\t\t\t       ctrlpriv->era);\n\n\tif (!alg->caam.geniv)\n\t\tgoto skip_givenc;\n\n\t \n\tif (desc_inline_query(DESC_QI_AEAD_GIVENC_LEN +\n\t\t\t      (is_rfc3686 ? DESC_AEAD_CTR_RFC3686_LEN : 0),\n\t\t\t      DESC_JOB_IO_LEN, data_len, &inl_mask,\n\t\t\t      ARRAY_SIZE(data_len)) < 0)\n\t\treturn -EINVAL;\n\n\tctx->adata.key_inline = !!(inl_mask & 1);\n\tctx->cdata.key_inline = !!(inl_mask & 2);\n\n\tcnstr_shdsc_aead_givencap(ctx->sh_desc_enc, &ctx->cdata, &ctx->adata,\n\t\t\t\t  ivsize, ctx->authsize, is_rfc3686, nonce,\n\t\t\t\t  ctx1_iv_off, true, ctrlpriv->era);\n\nskip_givenc:\n\treturn 0;\n}\n\nstatic int aead_setauthsize(struct crypto_aead *authenc, unsigned int authsize)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(authenc);\n\n\tctx->authsize = authsize;\n\taead_set_sh_desc(authenc);\n\n\treturn 0;\n}\n\nstatic int aead_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t       unsigned int keylen)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct device *jrdev = ctx->jrdev;\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(jrdev->parent);\n\tstruct crypto_authenc_keys keys;\n\tint ret = 0;\n\n\tif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\n\t\tgoto badkey;\n\n\tdev_dbg(jrdev, \"keylen %d enckeylen %d authkeylen %d\\n\",\n\t\tkeys.authkeylen + keys.enckeylen, keys.enckeylen,\n\t\tkeys.authkeylen);\n\tprint_hex_dump_debug(\"key in @\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\n\n\t \n\tif (ctrlpriv->era >= 6) {\n\t\tctx->adata.keylen = keys.authkeylen;\n\t\tctx->adata.keylen_pad = split_key_len(ctx->adata.algtype &\n\t\t\t\t\t\t      OP_ALG_ALGSEL_MASK);\n\n\t\tif (ctx->adata.keylen_pad + keys.enckeylen > CAAM_MAX_KEY_SIZE)\n\t\t\tgoto badkey;\n\n\t\tmemcpy(ctx->key, keys.authkey, keys.authkeylen);\n\t\tmemcpy(ctx->key + ctx->adata.keylen_pad, keys.enckey,\n\t\t       keys.enckeylen);\n\t\tdma_sync_single_for_device(jrdev->parent, ctx->key_dma,\n\t\t\t\t\t   ctx->adata.keylen_pad +\n\t\t\t\t\t   keys.enckeylen, ctx->dir);\n\t\tgoto skip_split_key;\n\t}\n\n\tret = gen_split_key(jrdev, ctx->key, &ctx->adata, keys.authkey,\n\t\t\t    keys.authkeylen, CAAM_MAX_KEY_SIZE -\n\t\t\t    keys.enckeylen);\n\tif (ret)\n\t\tgoto badkey;\n\n\t \n\tmemcpy(ctx->key + ctx->adata.keylen_pad, keys.enckey, keys.enckeylen);\n\tdma_sync_single_for_device(jrdev->parent, ctx->key_dma,\n\t\t\t\t   ctx->adata.keylen_pad + keys.enckeylen,\n\t\t\t\t   ctx->dir);\n\n\tprint_hex_dump_debug(\"ctx.key@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, ctx->key,\n\t\t\t     ctx->adata.keylen_pad + keys.enckeylen, 1);\n\nskip_split_key:\n\tctx->cdata.keylen = keys.enckeylen;\n\n\tret = aead_set_sh_desc(aead);\n\tif (ret)\n\t\tgoto badkey;\n\n\t \n\tif (ctx->drv_ctx[ENCRYPT]) {\n\t\tret = caam_drv_ctx_update(ctx->drv_ctx[ENCRYPT],\n\t\t\t\t\t  ctx->sh_desc_enc);\n\t\tif (ret) {\n\t\t\tdev_err(jrdev, \"driver enc context update failed\\n\");\n\t\t\tgoto badkey;\n\t\t}\n\t}\n\n\tif (ctx->drv_ctx[DECRYPT]) {\n\t\tret = caam_drv_ctx_update(ctx->drv_ctx[DECRYPT],\n\t\t\t\t\t  ctx->sh_desc_dec);\n\t\tif (ret) {\n\t\t\tdev_err(jrdev, \"driver dec context update failed\\n\");\n\t\t\tgoto badkey;\n\t\t}\n\t}\n\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn ret;\nbadkey:\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn -EINVAL;\n}\n\nstatic int des3_aead_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t\t    unsigned int keylen)\n{\n\tstruct crypto_authenc_keys keys;\n\tint err;\n\n\terr = crypto_authenc_extractkeys(&keys, key, keylen);\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = verify_aead_des3_key(aead, keys.enckey, keys.enckeylen) ?:\n\t      aead_setkey(aead, key, keylen);\n\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn err;\n}\n\nstatic int gcm_set_sh_desc(struct crypto_aead *aead)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tunsigned int ivsize = crypto_aead_ivsize(aead);\n\tint rem_bytes = CAAM_DESC_BYTES_MAX - DESC_JOB_IO_LEN -\n\t\t\tctx->cdata.keylen;\n\n\tif (!ctx->cdata.keylen || !ctx->authsize)\n\t\treturn 0;\n\n\t \n\tif (rem_bytes >= DESC_QI_GCM_ENC_LEN) {\n\t\tctx->cdata.key_inline = true;\n\t\tctx->cdata.key_virt = ctx->key;\n\t} else {\n\t\tctx->cdata.key_inline = false;\n\t\tctx->cdata.key_dma = ctx->key_dma;\n\t}\n\n\tcnstr_shdsc_gcm_encap(ctx->sh_desc_enc, &ctx->cdata, ivsize,\n\t\t\t      ctx->authsize, true);\n\n\t \n\tif (rem_bytes >= DESC_QI_GCM_DEC_LEN) {\n\t\tctx->cdata.key_inline = true;\n\t\tctx->cdata.key_virt = ctx->key;\n\t} else {\n\t\tctx->cdata.key_inline = false;\n\t\tctx->cdata.key_dma = ctx->key_dma;\n\t}\n\n\tcnstr_shdsc_gcm_decap(ctx->sh_desc_dec, &ctx->cdata, ivsize,\n\t\t\t      ctx->authsize, true);\n\n\treturn 0;\n}\n\nstatic int gcm_setauthsize(struct crypto_aead *authenc, unsigned int authsize)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(authenc);\n\tint err;\n\n\terr = crypto_gcm_check_authsize(authsize);\n\tif (err)\n\t\treturn err;\n\n\tctx->authsize = authsize;\n\tgcm_set_sh_desc(authenc);\n\n\treturn 0;\n}\n\nstatic int gcm_setkey(struct crypto_aead *aead,\n\t\t      const u8 *key, unsigned int keylen)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct device *jrdev = ctx->jrdev;\n\tint ret;\n\n\tret = aes_check_keylen(keylen);\n\tif (ret)\n\t\treturn ret;\n\n\tprint_hex_dump_debug(\"key in @\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\n\n\tmemcpy(ctx->key, key, keylen);\n\tdma_sync_single_for_device(jrdev->parent, ctx->key_dma, keylen,\n\t\t\t\t   ctx->dir);\n\tctx->cdata.keylen = keylen;\n\n\tret = gcm_set_sh_desc(aead);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ctx->drv_ctx[ENCRYPT]) {\n\t\tret = caam_drv_ctx_update(ctx->drv_ctx[ENCRYPT],\n\t\t\t\t\t  ctx->sh_desc_enc);\n\t\tif (ret) {\n\t\t\tdev_err(jrdev, \"driver enc context update failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (ctx->drv_ctx[DECRYPT]) {\n\t\tret = caam_drv_ctx_update(ctx->drv_ctx[DECRYPT],\n\t\t\t\t\t  ctx->sh_desc_dec);\n\t\tif (ret) {\n\t\t\tdev_err(jrdev, \"driver dec context update failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rfc4106_set_sh_desc(struct crypto_aead *aead)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tunsigned int ivsize = crypto_aead_ivsize(aead);\n\tint rem_bytes = CAAM_DESC_BYTES_MAX - DESC_JOB_IO_LEN -\n\t\t\tctx->cdata.keylen;\n\n\tif (!ctx->cdata.keylen || !ctx->authsize)\n\t\treturn 0;\n\n\tctx->cdata.key_virt = ctx->key;\n\n\t \n\tif (rem_bytes >= DESC_QI_RFC4106_ENC_LEN) {\n\t\tctx->cdata.key_inline = true;\n\t} else {\n\t\tctx->cdata.key_inline = false;\n\t\tctx->cdata.key_dma = ctx->key_dma;\n\t}\n\n\tcnstr_shdsc_rfc4106_encap(ctx->sh_desc_enc, &ctx->cdata, ivsize,\n\t\t\t\t  ctx->authsize, true);\n\n\t \n\tif (rem_bytes >= DESC_QI_RFC4106_DEC_LEN) {\n\t\tctx->cdata.key_inline = true;\n\t} else {\n\t\tctx->cdata.key_inline = false;\n\t\tctx->cdata.key_dma = ctx->key_dma;\n\t}\n\n\tcnstr_shdsc_rfc4106_decap(ctx->sh_desc_dec, &ctx->cdata, ivsize,\n\t\t\t\t  ctx->authsize, true);\n\n\treturn 0;\n}\n\nstatic int rfc4106_setauthsize(struct crypto_aead *authenc,\n\t\t\t       unsigned int authsize)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(authenc);\n\tint err;\n\n\terr = crypto_rfc4106_check_authsize(authsize);\n\tif (err)\n\t\treturn err;\n\n\tctx->authsize = authsize;\n\trfc4106_set_sh_desc(authenc);\n\n\treturn 0;\n}\n\nstatic int rfc4106_setkey(struct crypto_aead *aead,\n\t\t\t  const u8 *key, unsigned int keylen)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct device *jrdev = ctx->jrdev;\n\tint ret;\n\n\tret = aes_check_keylen(keylen - 4);\n\tif (ret)\n\t\treturn ret;\n\n\tprint_hex_dump_debug(\"key in @\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\n\n\tmemcpy(ctx->key, key, keylen);\n\t \n\tctx->cdata.keylen = keylen - 4;\n\tdma_sync_single_for_device(jrdev->parent, ctx->key_dma,\n\t\t\t\t   ctx->cdata.keylen, ctx->dir);\n\n\tret = rfc4106_set_sh_desc(aead);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ctx->drv_ctx[ENCRYPT]) {\n\t\tret = caam_drv_ctx_update(ctx->drv_ctx[ENCRYPT],\n\t\t\t\t\t  ctx->sh_desc_enc);\n\t\tif (ret) {\n\t\t\tdev_err(jrdev, \"driver enc context update failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (ctx->drv_ctx[DECRYPT]) {\n\t\tret = caam_drv_ctx_update(ctx->drv_ctx[DECRYPT],\n\t\t\t\t\t  ctx->sh_desc_dec);\n\t\tif (ret) {\n\t\t\tdev_err(jrdev, \"driver dec context update failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rfc4543_set_sh_desc(struct crypto_aead *aead)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tunsigned int ivsize = crypto_aead_ivsize(aead);\n\tint rem_bytes = CAAM_DESC_BYTES_MAX - DESC_JOB_IO_LEN -\n\t\t\tctx->cdata.keylen;\n\n\tif (!ctx->cdata.keylen || !ctx->authsize)\n\t\treturn 0;\n\n\tctx->cdata.key_virt = ctx->key;\n\n\t \n\tif (rem_bytes >= DESC_QI_RFC4543_ENC_LEN) {\n\t\tctx->cdata.key_inline = true;\n\t} else {\n\t\tctx->cdata.key_inline = false;\n\t\tctx->cdata.key_dma = ctx->key_dma;\n\t}\n\n\tcnstr_shdsc_rfc4543_encap(ctx->sh_desc_enc, &ctx->cdata, ivsize,\n\t\t\t\t  ctx->authsize, true);\n\n\t \n\tif (rem_bytes >= DESC_QI_RFC4543_DEC_LEN) {\n\t\tctx->cdata.key_inline = true;\n\t} else {\n\t\tctx->cdata.key_inline = false;\n\t\tctx->cdata.key_dma = ctx->key_dma;\n\t}\n\n\tcnstr_shdsc_rfc4543_decap(ctx->sh_desc_dec, &ctx->cdata, ivsize,\n\t\t\t\t  ctx->authsize, true);\n\n\treturn 0;\n}\n\nstatic int rfc4543_setauthsize(struct crypto_aead *authenc,\n\t\t\t       unsigned int authsize)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(authenc);\n\n\tif (authsize != 16)\n\t\treturn -EINVAL;\n\n\tctx->authsize = authsize;\n\trfc4543_set_sh_desc(authenc);\n\n\treturn 0;\n}\n\nstatic int rfc4543_setkey(struct crypto_aead *aead,\n\t\t\t  const u8 *key, unsigned int keylen)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct device *jrdev = ctx->jrdev;\n\tint ret;\n\n\tret = aes_check_keylen(keylen - 4);\n\tif (ret)\n\t\treturn ret;\n\n\tprint_hex_dump_debug(\"key in @\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\n\n\tmemcpy(ctx->key, key, keylen);\n\t \n\tctx->cdata.keylen = keylen - 4;\n\tdma_sync_single_for_device(jrdev->parent, ctx->key_dma,\n\t\t\t\t   ctx->cdata.keylen, ctx->dir);\n\n\tret = rfc4543_set_sh_desc(aead);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ctx->drv_ctx[ENCRYPT]) {\n\t\tret = caam_drv_ctx_update(ctx->drv_ctx[ENCRYPT],\n\t\t\t\t\t  ctx->sh_desc_enc);\n\t\tif (ret) {\n\t\t\tdev_err(jrdev, \"driver enc context update failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (ctx->drv_ctx[DECRYPT]) {\n\t\tret = caam_drv_ctx_update(ctx->drv_ctx[DECRYPT],\n\t\t\t\t\t  ctx->sh_desc_dec);\n\t\tif (ret) {\n\t\t\tdev_err(jrdev, \"driver dec context update failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int skcipher_setkey(struct crypto_skcipher *skcipher, const u8 *key,\n\t\t\t   unsigned int keylen, const u32 ctx1_iv_off)\n{\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(skcipher);\n\tstruct caam_skcipher_alg *alg =\n\t\tcontainer_of(crypto_skcipher_alg(skcipher), typeof(*alg),\n\t\t\t     skcipher);\n\tstruct device *jrdev = ctx->jrdev;\n\tunsigned int ivsize = crypto_skcipher_ivsize(skcipher);\n\tconst bool is_rfc3686 = alg->caam.rfc3686;\n\tint ret = 0;\n\n\tprint_hex_dump_debug(\"key in @\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\n\n\tctx->cdata.keylen = keylen;\n\tctx->cdata.key_virt = key;\n\tctx->cdata.key_inline = true;\n\n\t \n\tcnstr_shdsc_skcipher_encap(ctx->sh_desc_enc, &ctx->cdata, ivsize,\n\t\t\t\t   is_rfc3686, ctx1_iv_off);\n\tcnstr_shdsc_skcipher_decap(ctx->sh_desc_dec, &ctx->cdata, ivsize,\n\t\t\t\t   is_rfc3686, ctx1_iv_off);\n\n\t \n\tif (ctx->drv_ctx[ENCRYPT]) {\n\t\tret = caam_drv_ctx_update(ctx->drv_ctx[ENCRYPT],\n\t\t\t\t\t  ctx->sh_desc_enc);\n\t\tif (ret) {\n\t\t\tdev_err(jrdev, \"driver enc context update failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ctx->drv_ctx[DECRYPT]) {\n\t\tret = caam_drv_ctx_update(ctx->drv_ctx[DECRYPT],\n\t\t\t\t\t  ctx->sh_desc_dec);\n\t\tif (ret) {\n\t\t\tdev_err(jrdev, \"driver dec context update failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int aes_skcipher_setkey(struct crypto_skcipher *skcipher,\n\t\t\t       const u8 *key, unsigned int keylen)\n{\n\tint err;\n\n\terr = aes_check_keylen(keylen);\n\tif (err)\n\t\treturn err;\n\n\treturn skcipher_setkey(skcipher, key, keylen, 0);\n}\n\nstatic int rfc3686_skcipher_setkey(struct crypto_skcipher *skcipher,\n\t\t\t\t   const u8 *key, unsigned int keylen)\n{\n\tu32 ctx1_iv_off;\n\tint err;\n\n\t \n\tctx1_iv_off = 16 + CTR_RFC3686_NONCE_SIZE;\n\tkeylen -= CTR_RFC3686_NONCE_SIZE;\n\n\terr = aes_check_keylen(keylen);\n\tif (err)\n\t\treturn err;\n\n\treturn skcipher_setkey(skcipher, key, keylen, ctx1_iv_off);\n}\n\nstatic int ctr_skcipher_setkey(struct crypto_skcipher *skcipher,\n\t\t\t       const u8 *key, unsigned int keylen)\n{\n\tu32 ctx1_iv_off;\n\tint err;\n\n\t \n\tctx1_iv_off = 16;\n\n\terr = aes_check_keylen(keylen);\n\tif (err)\n\t\treturn err;\n\n\treturn skcipher_setkey(skcipher, key, keylen, ctx1_iv_off);\n}\n\nstatic int des3_skcipher_setkey(struct crypto_skcipher *skcipher,\n\t\t\t\tconst u8 *key, unsigned int keylen)\n{\n\treturn verify_skcipher_des3_key(skcipher, key) ?:\n\t       skcipher_setkey(skcipher, key, keylen, 0);\n}\n\nstatic int des_skcipher_setkey(struct crypto_skcipher *skcipher,\n\t\t\t       const u8 *key, unsigned int keylen)\n{\n\treturn verify_skcipher_des_key(skcipher, key) ?:\n\t       skcipher_setkey(skcipher, key, keylen, 0);\n}\n\nstatic int xts_skcipher_setkey(struct crypto_skcipher *skcipher, const u8 *key,\n\t\t\t       unsigned int keylen)\n{\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(skcipher);\n\tstruct device *jrdev = ctx->jrdev;\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(jrdev->parent);\n\tint ret = 0;\n\tint err;\n\n\terr = xts_verify_key(skcipher, key, keylen);\n\tif (err) {\n\t\tdev_dbg(jrdev, \"key size mismatch\\n\");\n\t\treturn err;\n\t}\n\n\tif (keylen != 2 * AES_KEYSIZE_128 && keylen != 2 * AES_KEYSIZE_256)\n\t\tctx->xts_key_fallback = true;\n\n\tif (ctrlpriv->era <= 8 || ctx->xts_key_fallback) {\n\t\terr = crypto_skcipher_setkey(ctx->fallback, key, keylen);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tctx->cdata.keylen = keylen;\n\tctx->cdata.key_virt = key;\n\tctx->cdata.key_inline = true;\n\n\t \n\tcnstr_shdsc_xts_skcipher_encap(ctx->sh_desc_enc, &ctx->cdata);\n\tcnstr_shdsc_xts_skcipher_decap(ctx->sh_desc_dec, &ctx->cdata);\n\n\t \n\tif (ctx->drv_ctx[ENCRYPT]) {\n\t\tret = caam_drv_ctx_update(ctx->drv_ctx[ENCRYPT],\n\t\t\t\t\t  ctx->sh_desc_enc);\n\t\tif (ret) {\n\t\t\tdev_err(jrdev, \"driver enc context update failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ctx->drv_ctx[DECRYPT]) {\n\t\tret = caam_drv_ctx_update(ctx->drv_ctx[DECRYPT],\n\t\t\t\t\t  ctx->sh_desc_dec);\n\t\tif (ret) {\n\t\t\tdev_err(jrdev, \"driver dec context update failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstruct aead_edesc {\n\tint src_nents;\n\tint dst_nents;\n\tdma_addr_t iv_dma;\n\tint qm_sg_bytes;\n\tdma_addr_t qm_sg_dma;\n\tunsigned int assoclen;\n\tdma_addr_t assoclen_dma;\n\tstruct caam_drv_req drv_req;\n\tstruct qm_sg_entry sgt[];\n};\n\n \nstruct skcipher_edesc {\n\tint src_nents;\n\tint dst_nents;\n\tdma_addr_t iv_dma;\n\tint qm_sg_bytes;\n\tdma_addr_t qm_sg_dma;\n\tstruct caam_drv_req drv_req;\n\tstruct qm_sg_entry sgt[];\n};\n\nstatic struct caam_drv_ctx *get_drv_ctx(struct caam_ctx *ctx,\n\t\t\t\t\tenum optype type)\n{\n\t \n\tstruct caam_drv_ctx *drv_ctx = ctx->drv_ctx[type];\n\tu32 *desc;\n\n\tif (unlikely(!drv_ctx)) {\n\t\tspin_lock(&ctx->lock);\n\n\t\t \n\t\tdrv_ctx = ctx->drv_ctx[type];\n\t\tif (!drv_ctx) {\n\t\t\tint cpu;\n\n\t\t\tif (type == ENCRYPT)\n\t\t\t\tdesc = ctx->sh_desc_enc;\n\t\t\telse  \n\t\t\t\tdesc = ctx->sh_desc_dec;\n\n\t\t\tcpu = smp_processor_id();\n\t\t\tdrv_ctx = caam_drv_ctx_init(ctx->qidev, &cpu, desc);\n\t\t\tif (!IS_ERR(drv_ctx))\n\t\t\t\tdrv_ctx->op_type = type;\n\n\t\t\tctx->drv_ctx[type] = drv_ctx;\n\t\t}\n\n\t\tspin_unlock(&ctx->lock);\n\t}\n\n\treturn drv_ctx;\n}\n\nstatic void caam_unmap(struct device *dev, struct scatterlist *src,\n\t\t       struct scatterlist *dst, int src_nents,\n\t\t       int dst_nents, dma_addr_t iv_dma, int ivsize,\n\t\t       enum dma_data_direction iv_dir, dma_addr_t qm_sg_dma,\n\t\t       int qm_sg_bytes)\n{\n\tif (dst != src) {\n\t\tif (src_nents)\n\t\t\tdma_unmap_sg(dev, src, src_nents, DMA_TO_DEVICE);\n\t\tif (dst_nents)\n\t\t\tdma_unmap_sg(dev, dst, dst_nents, DMA_FROM_DEVICE);\n\t} else {\n\t\tdma_unmap_sg(dev, src, src_nents, DMA_BIDIRECTIONAL);\n\t}\n\n\tif (iv_dma)\n\t\tdma_unmap_single(dev, iv_dma, ivsize, iv_dir);\n\tif (qm_sg_bytes)\n\t\tdma_unmap_single(dev, qm_sg_dma, qm_sg_bytes, DMA_TO_DEVICE);\n}\n\nstatic void aead_unmap(struct device *dev,\n\t\t       struct aead_edesc *edesc,\n\t\t       struct aead_request *req)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tint ivsize = crypto_aead_ivsize(aead);\n\n\tcaam_unmap(dev, req->src, req->dst, edesc->src_nents, edesc->dst_nents,\n\t\t   edesc->iv_dma, ivsize, DMA_TO_DEVICE, edesc->qm_sg_dma,\n\t\t   edesc->qm_sg_bytes);\n\tdma_unmap_single(dev, edesc->assoclen_dma, 4, DMA_TO_DEVICE);\n}\n\nstatic void skcipher_unmap(struct device *dev, struct skcipher_edesc *edesc,\n\t\t\t   struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tint ivsize = crypto_skcipher_ivsize(skcipher);\n\n\tcaam_unmap(dev, req->src, req->dst, edesc->src_nents, edesc->dst_nents,\n\t\t   edesc->iv_dma, ivsize, DMA_BIDIRECTIONAL, edesc->qm_sg_dma,\n\t\t   edesc->qm_sg_bytes);\n}\n\nstatic void aead_done(struct caam_drv_req *drv_req, u32 status)\n{\n\tstruct device *qidev;\n\tstruct aead_edesc *edesc;\n\tstruct aead_request *aead_req = drv_req->app_ctx;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(aead_req);\n\tstruct caam_ctx *caam_ctx = crypto_aead_ctx_dma(aead);\n\tint ecode = 0;\n\n\tqidev = caam_ctx->qidev;\n\n\tif (unlikely(status))\n\t\tecode = caam_jr_strstatus(qidev, status);\n\n\tedesc = container_of(drv_req, typeof(*edesc), drv_req);\n\taead_unmap(qidev, edesc, aead_req);\n\n\taead_request_complete(aead_req, ecode);\n\tqi_cache_free(edesc);\n}\n\n \nstatic struct aead_edesc *aead_edesc_alloc(struct aead_request *req,\n\t\t\t\t\t   bool encrypt)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct caam_aead_alg *alg = container_of(crypto_aead_alg(aead),\n\t\t\t\t\t\t typeof(*alg), aead);\n\tstruct device *qidev = ctx->qidev;\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t       GFP_KERNEL : GFP_ATOMIC;\n\tint src_nents, mapped_src_nents, dst_nents = 0, mapped_dst_nents = 0;\n\tint src_len, dst_len = 0;\n\tstruct aead_edesc *edesc;\n\tdma_addr_t qm_sg_dma, iv_dma = 0;\n\tint ivsize = 0;\n\tunsigned int authsize = ctx->authsize;\n\tint qm_sg_index = 0, qm_sg_ents = 0, qm_sg_bytes;\n\tint in_len, out_len;\n\tstruct qm_sg_entry *sg_table, *fd_sgt;\n\tstruct caam_drv_ctx *drv_ctx;\n\n\tdrv_ctx = get_drv_ctx(ctx, encrypt ? ENCRYPT : DECRYPT);\n\tif (IS_ERR(drv_ctx))\n\t\treturn (struct aead_edesc *)drv_ctx;\n\n\t \n\tedesc = qi_cache_alloc(flags);\n\tif (unlikely(!edesc)) {\n\t\tdev_err(qidev, \"could not allocate extended descriptor\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (likely(req->src == req->dst)) {\n\t\tsrc_len = req->assoclen + req->cryptlen +\n\t\t\t  (encrypt ? authsize : 0);\n\n\t\tsrc_nents = sg_nents_for_len(req->src, src_len);\n\t\tif (unlikely(src_nents < 0)) {\n\t\t\tdev_err(qidev, \"Insufficient bytes (%d) in src S/G\\n\",\n\t\t\t\tsrc_len);\n\t\t\tqi_cache_free(edesc);\n\t\t\treturn ERR_PTR(src_nents);\n\t\t}\n\n\t\tmapped_src_nents = dma_map_sg(qidev, req->src, src_nents,\n\t\t\t\t\t      DMA_BIDIRECTIONAL);\n\t\tif (unlikely(!mapped_src_nents)) {\n\t\t\tdev_err(qidev, \"unable to map source\\n\");\n\t\t\tqi_cache_free(edesc);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t} else {\n\t\tsrc_len = req->assoclen + req->cryptlen;\n\t\tdst_len = src_len + (encrypt ? authsize : (-authsize));\n\n\t\tsrc_nents = sg_nents_for_len(req->src, src_len);\n\t\tif (unlikely(src_nents < 0)) {\n\t\t\tdev_err(qidev, \"Insufficient bytes (%d) in src S/G\\n\",\n\t\t\t\tsrc_len);\n\t\t\tqi_cache_free(edesc);\n\t\t\treturn ERR_PTR(src_nents);\n\t\t}\n\n\t\tdst_nents = sg_nents_for_len(req->dst, dst_len);\n\t\tif (unlikely(dst_nents < 0)) {\n\t\t\tdev_err(qidev, \"Insufficient bytes (%d) in dst S/G\\n\",\n\t\t\t\tdst_len);\n\t\t\tqi_cache_free(edesc);\n\t\t\treturn ERR_PTR(dst_nents);\n\t\t}\n\n\t\tif (src_nents) {\n\t\t\tmapped_src_nents = dma_map_sg(qidev, req->src,\n\t\t\t\t\t\t      src_nents, DMA_TO_DEVICE);\n\t\t\tif (unlikely(!mapped_src_nents)) {\n\t\t\t\tdev_err(qidev, \"unable to map source\\n\");\n\t\t\t\tqi_cache_free(edesc);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t} else {\n\t\t\tmapped_src_nents = 0;\n\t\t}\n\n\t\tif (dst_nents) {\n\t\t\tmapped_dst_nents = dma_map_sg(qidev, req->dst,\n\t\t\t\t\t\t      dst_nents,\n\t\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\t\tif (unlikely(!mapped_dst_nents)) {\n\t\t\t\tdev_err(qidev, \"unable to map destination\\n\");\n\t\t\t\tdma_unmap_sg(qidev, req->src, src_nents,\n\t\t\t\t\t     DMA_TO_DEVICE);\n\t\t\t\tqi_cache_free(edesc);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t} else {\n\t\t\tmapped_dst_nents = 0;\n\t\t}\n\t}\n\n\tif ((alg->caam.rfc3686 && encrypt) || !alg->caam.geniv)\n\t\tivsize = crypto_aead_ivsize(aead);\n\n\t \n\tqm_sg_ents = 1 + !!ivsize + mapped_src_nents;\n\tif (mapped_dst_nents > 1)\n\t\tqm_sg_ents += pad_sg_nents(mapped_dst_nents);\n\telse if ((req->src == req->dst) && (mapped_src_nents > 1))\n\t\tqm_sg_ents = max(pad_sg_nents(qm_sg_ents),\n\t\t\t\t 1 + !!ivsize + pad_sg_nents(mapped_src_nents));\n\telse\n\t\tqm_sg_ents = pad_sg_nents(qm_sg_ents);\n\n\tsg_table = &edesc->sgt[0];\n\tqm_sg_bytes = qm_sg_ents * sizeof(*sg_table);\n\tif (unlikely(offsetof(struct aead_edesc, sgt) + qm_sg_bytes + ivsize >\n\t\t     CAAM_QI_MEMCACHE_SIZE)) {\n\t\tdev_err(qidev, \"No space for %d S/G entries and/or %dB IV\\n\",\n\t\t\tqm_sg_ents, ivsize);\n\t\tcaam_unmap(qidev, req->src, req->dst, src_nents, dst_nents, 0,\n\t\t\t   0, DMA_NONE, 0, 0);\n\t\tqi_cache_free(edesc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (ivsize) {\n\t\tu8 *iv = (u8 *)(sg_table + qm_sg_ents);\n\n\t\t \n\t\tmemcpy(iv, req->iv, ivsize);\n\n\t\tiv_dma = dma_map_single(qidev, iv, ivsize, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(qidev, iv_dma)) {\n\t\t\tdev_err(qidev, \"unable to map IV\\n\");\n\t\t\tcaam_unmap(qidev, req->src, req->dst, src_nents,\n\t\t\t\t   dst_nents, 0, 0, DMA_NONE, 0, 0);\n\t\t\tqi_cache_free(edesc);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\tedesc->src_nents = src_nents;\n\tedesc->dst_nents = dst_nents;\n\tedesc->iv_dma = iv_dma;\n\tedesc->drv_req.app_ctx = req;\n\tedesc->drv_req.cbk = aead_done;\n\tedesc->drv_req.drv_ctx = drv_ctx;\n\n\tedesc->assoclen = cpu_to_caam32(req->assoclen);\n\tedesc->assoclen_dma = dma_map_single(qidev, &edesc->assoclen, 4,\n\t\t\t\t\t     DMA_TO_DEVICE);\n\tif (dma_mapping_error(qidev, edesc->assoclen_dma)) {\n\t\tdev_err(qidev, \"unable to map assoclen\\n\");\n\t\tcaam_unmap(qidev, req->src, req->dst, src_nents, dst_nents,\n\t\t\t   iv_dma, ivsize, DMA_TO_DEVICE, 0, 0);\n\t\tqi_cache_free(edesc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdma_to_qm_sg_one(sg_table, edesc->assoclen_dma, 4, 0);\n\tqm_sg_index++;\n\tif (ivsize) {\n\t\tdma_to_qm_sg_one(sg_table + qm_sg_index, iv_dma, ivsize, 0);\n\t\tqm_sg_index++;\n\t}\n\tsg_to_qm_sg_last(req->src, src_len, sg_table + qm_sg_index, 0);\n\tqm_sg_index += mapped_src_nents;\n\n\tif (mapped_dst_nents > 1)\n\t\tsg_to_qm_sg_last(req->dst, dst_len, sg_table + qm_sg_index, 0);\n\n\tqm_sg_dma = dma_map_single(qidev, sg_table, qm_sg_bytes, DMA_TO_DEVICE);\n\tif (dma_mapping_error(qidev, qm_sg_dma)) {\n\t\tdev_err(qidev, \"unable to map S/G table\\n\");\n\t\tdma_unmap_single(qidev, edesc->assoclen_dma, 4, DMA_TO_DEVICE);\n\t\tcaam_unmap(qidev, req->src, req->dst, src_nents, dst_nents,\n\t\t\t   iv_dma, ivsize, DMA_TO_DEVICE, 0, 0);\n\t\tqi_cache_free(edesc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tedesc->qm_sg_dma = qm_sg_dma;\n\tedesc->qm_sg_bytes = qm_sg_bytes;\n\n\tout_len = req->assoclen + req->cryptlen +\n\t\t  (encrypt ? ctx->authsize : (-ctx->authsize));\n\tin_len = 4 + ivsize + req->assoclen + req->cryptlen;\n\n\tfd_sgt = &edesc->drv_req.fd_sgt[0];\n\tdma_to_qm_sg_one_last_ext(&fd_sgt[1], qm_sg_dma, in_len, 0);\n\n\tif (req->dst == req->src) {\n\t\tif (mapped_src_nents == 1)\n\t\t\tdma_to_qm_sg_one(&fd_sgt[0], sg_dma_address(req->src),\n\t\t\t\t\t out_len, 0);\n\t\telse\n\t\t\tdma_to_qm_sg_one_ext(&fd_sgt[0], qm_sg_dma +\n\t\t\t\t\t     (1 + !!ivsize) * sizeof(*sg_table),\n\t\t\t\t\t     out_len, 0);\n\t} else if (mapped_dst_nents <= 1) {\n\t\tdma_to_qm_sg_one(&fd_sgt[0], sg_dma_address(req->dst), out_len,\n\t\t\t\t 0);\n\t} else {\n\t\tdma_to_qm_sg_one_ext(&fd_sgt[0], qm_sg_dma + sizeof(*sg_table) *\n\t\t\t\t     qm_sg_index, out_len, 0);\n\t}\n\n\treturn edesc;\n}\n\nstatic inline int aead_crypt(struct aead_request *req, bool encrypt)\n{\n\tstruct aead_edesc *edesc;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tint ret;\n\n\tif (unlikely(caam_congested))\n\t\treturn -EAGAIN;\n\n\t \n\tedesc = aead_edesc_alloc(req, encrypt);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\t \n\tret = caam_qi_enqueue(ctx->qidev, &edesc->drv_req);\n\tif (!ret) {\n\t\tret = -EINPROGRESS;\n\t} else {\n\t\taead_unmap(ctx->qidev, edesc, req);\n\t\tqi_cache_free(edesc);\n\t}\n\n\treturn ret;\n}\n\nstatic int aead_encrypt(struct aead_request *req)\n{\n\treturn aead_crypt(req, true);\n}\n\nstatic int aead_decrypt(struct aead_request *req)\n{\n\treturn aead_crypt(req, false);\n}\n\nstatic int ipsec_gcm_encrypt(struct aead_request *req)\n{\n\treturn crypto_ipsec_check_assoclen(req->assoclen) ? : aead_crypt(req,\n\t\t\t\t\t   true);\n}\n\nstatic int ipsec_gcm_decrypt(struct aead_request *req)\n{\n\treturn crypto_ipsec_check_assoclen(req->assoclen) ? : aead_crypt(req,\n\t\t\t\t\t   false);\n}\n\nstatic inline u8 *skcipher_edesc_iv(struct skcipher_edesc *edesc)\n{\n\treturn PTR_ALIGN((u8 *)&edesc->sgt[0] + edesc->qm_sg_bytes,\n\t\t\t dma_get_cache_alignment());\n}\n\nstatic void skcipher_done(struct caam_drv_req *drv_req, u32 status)\n{\n\tstruct skcipher_edesc *edesc;\n\tstruct skcipher_request *req = drv_req->app_ctx;\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tstruct caam_ctx *caam_ctx = crypto_skcipher_ctx_dma(skcipher);\n\tstruct device *qidev = caam_ctx->qidev;\n\tint ivsize = crypto_skcipher_ivsize(skcipher);\n\tint ecode = 0;\n\n\tdev_dbg(qidev, \"%s %d: status 0x%x\\n\", __func__, __LINE__, status);\n\n\tedesc = container_of(drv_req, typeof(*edesc), drv_req);\n\n\tif (status)\n\t\tecode = caam_jr_strstatus(qidev, status);\n\n\tprint_hex_dump_debug(\"dstiv  @\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, req->iv,\n\t\t\t     edesc->src_nents > 1 ? 100 : ivsize, 1);\n\tcaam_dump_sg(\"dst    @\" __stringify(__LINE__)\": \",\n\t\t     DUMP_PREFIX_ADDRESS, 16, 4, req->dst,\n\t\t     edesc->dst_nents > 1 ? 100 : req->cryptlen, 1);\n\n\tskcipher_unmap(qidev, edesc, req);\n\n\t \n\tif (!ecode)\n\t\tmemcpy(req->iv, skcipher_edesc_iv(edesc), ivsize);\n\n\tqi_cache_free(edesc);\n\tskcipher_request_complete(req, ecode);\n}\n\nstatic struct skcipher_edesc *skcipher_edesc_alloc(struct skcipher_request *req,\n\t\t\t\t\t\t   bool encrypt)\n{\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(skcipher);\n\tstruct device *qidev = ctx->qidev;\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t       GFP_KERNEL : GFP_ATOMIC;\n\tint src_nents, mapped_src_nents, dst_nents = 0, mapped_dst_nents = 0;\n\tstruct skcipher_edesc *edesc;\n\tdma_addr_t iv_dma;\n\tu8 *iv;\n\tint ivsize = crypto_skcipher_ivsize(skcipher);\n\tint dst_sg_idx, qm_sg_ents, qm_sg_bytes;\n\tstruct qm_sg_entry *sg_table, *fd_sgt;\n\tstruct caam_drv_ctx *drv_ctx;\n\tunsigned int len;\n\n\tdrv_ctx = get_drv_ctx(ctx, encrypt ? ENCRYPT : DECRYPT);\n\tif (IS_ERR(drv_ctx))\n\t\treturn (struct skcipher_edesc *)drv_ctx;\n\n\tsrc_nents = sg_nents_for_len(req->src, req->cryptlen);\n\tif (unlikely(src_nents < 0)) {\n\t\tdev_err(qidev, \"Insufficient bytes (%d) in src S/G\\n\",\n\t\t\treq->cryptlen);\n\t\treturn ERR_PTR(src_nents);\n\t}\n\n\tif (unlikely(req->src != req->dst)) {\n\t\tdst_nents = sg_nents_for_len(req->dst, req->cryptlen);\n\t\tif (unlikely(dst_nents < 0)) {\n\t\t\tdev_err(qidev, \"Insufficient bytes (%d) in dst S/G\\n\",\n\t\t\t\treq->cryptlen);\n\t\t\treturn ERR_PTR(dst_nents);\n\t\t}\n\n\t\tmapped_src_nents = dma_map_sg(qidev, req->src, src_nents,\n\t\t\t\t\t      DMA_TO_DEVICE);\n\t\tif (unlikely(!mapped_src_nents)) {\n\t\t\tdev_err(qidev, \"unable to map source\\n\");\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tmapped_dst_nents = dma_map_sg(qidev, req->dst, dst_nents,\n\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\tif (unlikely(!mapped_dst_nents)) {\n\t\t\tdev_err(qidev, \"unable to map destination\\n\");\n\t\t\tdma_unmap_sg(qidev, req->src, src_nents, DMA_TO_DEVICE);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t} else {\n\t\tmapped_src_nents = dma_map_sg(qidev, req->src, src_nents,\n\t\t\t\t\t      DMA_BIDIRECTIONAL);\n\t\tif (unlikely(!mapped_src_nents)) {\n\t\t\tdev_err(qidev, \"unable to map source\\n\");\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\tqm_sg_ents = 1 + mapped_src_nents;\n\tdst_sg_idx = qm_sg_ents;\n\n\t \n\tif (req->src != req->dst)\n\t\tqm_sg_ents += pad_sg_nents(mapped_dst_nents + 1);\n\telse\n\t\tqm_sg_ents = 1 + pad_sg_nents(qm_sg_ents);\n\n\tqm_sg_bytes = qm_sg_ents * sizeof(struct qm_sg_entry);\n\n\tlen = offsetof(struct skcipher_edesc, sgt) + qm_sg_bytes;\n\tlen = ALIGN(len, dma_get_cache_alignment());\n\tlen += ivsize;\n\n\tif (unlikely(len > CAAM_QI_MEMCACHE_SIZE)) {\n\t\tdev_err(qidev, \"No space for %d S/G entries and/or %dB IV\\n\",\n\t\t\tqm_sg_ents, ivsize);\n\t\tcaam_unmap(qidev, req->src, req->dst, src_nents, dst_nents, 0,\n\t\t\t   0, DMA_NONE, 0, 0);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tedesc = qi_cache_alloc(flags);\n\tif (unlikely(!edesc)) {\n\t\tdev_err(qidev, \"could not allocate extended descriptor\\n\");\n\t\tcaam_unmap(qidev, req->src, req->dst, src_nents, dst_nents, 0,\n\t\t\t   0, DMA_NONE, 0, 0);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tedesc->src_nents = src_nents;\n\tedesc->dst_nents = dst_nents;\n\tedesc->qm_sg_bytes = qm_sg_bytes;\n\tedesc->drv_req.app_ctx = req;\n\tedesc->drv_req.cbk = skcipher_done;\n\tedesc->drv_req.drv_ctx = drv_ctx;\n\n\t \n\tsg_table = &edesc->sgt[0];\n\tiv = skcipher_edesc_iv(edesc);\n\tmemcpy(iv, req->iv, ivsize);\n\n\tiv_dma = dma_map_single(qidev, iv, ivsize, DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(qidev, iv_dma)) {\n\t\tdev_err(qidev, \"unable to map IV\\n\");\n\t\tcaam_unmap(qidev, req->src, req->dst, src_nents, dst_nents, 0,\n\t\t\t   0, DMA_NONE, 0, 0);\n\t\tqi_cache_free(edesc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tedesc->iv_dma = iv_dma;\n\n\tdma_to_qm_sg_one(sg_table, iv_dma, ivsize, 0);\n\tsg_to_qm_sg(req->src, req->cryptlen, sg_table + 1, 0);\n\n\tif (req->src != req->dst)\n\t\tsg_to_qm_sg(req->dst, req->cryptlen, sg_table + dst_sg_idx, 0);\n\n\tdma_to_qm_sg_one(sg_table + dst_sg_idx + mapped_dst_nents, iv_dma,\n\t\t\t ivsize, 0);\n\n\tedesc->qm_sg_dma = dma_map_single(qidev, sg_table, edesc->qm_sg_bytes,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(qidev, edesc->qm_sg_dma)) {\n\t\tdev_err(qidev, \"unable to map S/G table\\n\");\n\t\tcaam_unmap(qidev, req->src, req->dst, src_nents, dst_nents,\n\t\t\t   iv_dma, ivsize, DMA_BIDIRECTIONAL, 0, 0);\n\t\tqi_cache_free(edesc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfd_sgt = &edesc->drv_req.fd_sgt[0];\n\n\tdma_to_qm_sg_one_last_ext(&fd_sgt[1], edesc->qm_sg_dma,\n\t\t\t\t  ivsize + req->cryptlen, 0);\n\n\tif (req->src == req->dst)\n\t\tdma_to_qm_sg_one_ext(&fd_sgt[0], edesc->qm_sg_dma +\n\t\t\t\t     sizeof(*sg_table), req->cryptlen + ivsize,\n\t\t\t\t     0);\n\telse\n\t\tdma_to_qm_sg_one_ext(&fd_sgt[0], edesc->qm_sg_dma + dst_sg_idx *\n\t\t\t\t     sizeof(*sg_table), req->cryptlen + ivsize,\n\t\t\t\t     0);\n\n\treturn edesc;\n}\n\nstatic inline bool xts_skcipher_ivsize(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tunsigned int ivsize = crypto_skcipher_ivsize(skcipher);\n\n\treturn !!get_unaligned((u64 *)(req->iv + (ivsize / 2)));\n}\n\nstatic inline int skcipher_crypt(struct skcipher_request *req, bool encrypt)\n{\n\tstruct skcipher_edesc *edesc;\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(skcipher);\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(ctx->jrdev->parent);\n\tint ret;\n\n\t \n\tif (!req->cryptlen && !ctx->fallback)\n\t\treturn 0;\n\n\tif (ctx->fallback && ((ctrlpriv->era <= 8 && xts_skcipher_ivsize(req)) ||\n\t\t\t      ctx->xts_key_fallback)) {\n\t\tstruct caam_skcipher_req_ctx *rctx = skcipher_request_ctx(req);\n\n\t\tskcipher_request_set_tfm(&rctx->fallback_req, ctx->fallback);\n\t\tskcipher_request_set_callback(&rctx->fallback_req,\n\t\t\t\t\t      req->base.flags,\n\t\t\t\t\t      req->base.complete,\n\t\t\t\t\t      req->base.data);\n\t\tskcipher_request_set_crypt(&rctx->fallback_req, req->src,\n\t\t\t\t\t   req->dst, req->cryptlen, req->iv);\n\n\t\treturn encrypt ? crypto_skcipher_encrypt(&rctx->fallback_req) :\n\t\t\t\t crypto_skcipher_decrypt(&rctx->fallback_req);\n\t}\n\n\tif (unlikely(caam_congested))\n\t\treturn -EAGAIN;\n\n\t \n\tedesc = skcipher_edesc_alloc(req, encrypt);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\tret = caam_qi_enqueue(ctx->qidev, &edesc->drv_req);\n\tif (!ret) {\n\t\tret = -EINPROGRESS;\n\t} else {\n\t\tskcipher_unmap(ctx->qidev, edesc, req);\n\t\tqi_cache_free(edesc);\n\t}\n\n\treturn ret;\n}\n\nstatic int skcipher_encrypt(struct skcipher_request *req)\n{\n\treturn skcipher_crypt(req, true);\n}\n\nstatic int skcipher_decrypt(struct skcipher_request *req)\n{\n\treturn skcipher_crypt(req, false);\n}\n\nstatic struct caam_skcipher_alg driver_algs[] = {\n\t{\n\t\t.skcipher = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"cbc(aes)\",\n\t\t\t\t.cra_driver_name = \"cbc-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aes_skcipher_setkey,\n\t\t\t.encrypt = skcipher_encrypt,\n\t\t\t.decrypt = skcipher_decrypt,\n\t\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t},\n\t{\n\t\t.skcipher = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"cbc(des3_ede)\",\n\t\t\t\t.cra_driver_name = \"cbc-3des-caam-qi\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_skcipher_setkey,\n\t\t\t.encrypt = skcipher_encrypt,\n\t\t\t.decrypt = skcipher_decrypt,\n\t\t\t.min_keysize = DES3_EDE_KEY_SIZE,\n\t\t\t.max_keysize = DES3_EDE_KEY_SIZE,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t},\n\t\t.caam.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t},\n\t{\n\t\t.skcipher = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"cbc(des)\",\n\t\t\t\t.cra_driver_name = \"cbc-des-caam-qi\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des_skcipher_setkey,\n\t\t\t.encrypt = skcipher_encrypt,\n\t\t\t.decrypt = skcipher_decrypt,\n\t\t\t.min_keysize = DES_KEY_SIZE,\n\t\t\t.max_keysize = DES_KEY_SIZE,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t},\n\t\t.caam.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t},\n\t{\n\t\t.skcipher = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"ctr(aes)\",\n\t\t\t\t.cra_driver_name = \"ctr-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = ctr_skcipher_setkey,\n\t\t\t.encrypt = skcipher_encrypt,\n\t\t\t.decrypt = skcipher_decrypt,\n\t\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.chunksize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\tOP_ALG_AAI_CTR_MOD128,\n\t},\n\t{\n\t\t.skcipher = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"rfc3686(ctr(aes))\",\n\t\t\t\t.cra_driver_name = \"rfc3686-ctr-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = rfc3686_skcipher_setkey,\n\t\t\t.encrypt = skcipher_encrypt,\n\t\t\t.decrypt = skcipher_decrypt,\n\t\t\t.min_keysize = AES_MIN_KEY_SIZE +\n\t\t\t\t       CTR_RFC3686_NONCE_SIZE,\n\t\t\t.max_keysize = AES_MAX_KEY_SIZE +\n\t\t\t\t       CTR_RFC3686_NONCE_SIZE,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.chunksize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.rfc3686 = true,\n\t\t},\n\t},\n\t{\n\t\t.skcipher = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"xts(aes)\",\n\t\t\t\t.cra_driver_name = \"xts-aes-caam-qi\",\n\t\t\t\t.cra_flags = CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = xts_skcipher_setkey,\n\t\t\t.encrypt = skcipher_encrypt,\n\t\t\t.decrypt = skcipher_decrypt,\n\t\t\t.min_keysize = 2 * AES_MIN_KEY_SIZE,\n\t\t\t.max_keysize = 2 * AES_MAX_KEY_SIZE,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_XTS,\n\t},\n};\n\nstatic struct caam_aead_alg driver_aeads[] = {\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"rfc4106(gcm(aes))\",\n\t\t\t\t.cra_driver_name = \"rfc4106-gcm-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = rfc4106_setkey,\n\t\t\t.setauthsize = rfc4106_setauthsize,\n\t\t\t.encrypt = ipsec_gcm_encrypt,\n\t\t\t.decrypt = ipsec_gcm_decrypt,\n\t\t\t.ivsize = 8,\n\t\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_GCM,\n\t\t\t.nodkp = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"rfc4543(gcm(aes))\",\n\t\t\t\t.cra_driver_name = \"rfc4543-gcm-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = rfc4543_setkey,\n\t\t\t.setauthsize = rfc4543_setauthsize,\n\t\t\t.encrypt = ipsec_gcm_encrypt,\n\t\t\t.decrypt = ipsec_gcm_decrypt,\n\t\t\t.ivsize = 8,\n\t\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_GCM,\n\t\t\t.nodkp = true,\n\t\t},\n\t},\n\t \n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"gcm(aes)\",\n\t\t\t\t.cra_driver_name = \"gcm-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = gcm_setkey,\n\t\t\t.setauthsize = gcm_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = 12,\n\t\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_GCM,\n\t\t\t.nodkp = true,\n\t\t}\n\t},\n\t \n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(md5),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(md5),\"\n\t\t\t\t\t    \"cbc(aes)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha1),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha1-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha1),\"\n\t\t\t\t\t    \"cbc(aes)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha1-cbc-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha224),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha224-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha224),\"\n\t\t\t\t\t    \"cbc(aes)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha224-cbc-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha256),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha256-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha256),\"\n\t\t\t\t\t    \"cbc(aes)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha256-cbc-aes-\"\n\t\t\t\t\t\t   \"caam-qi\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha384),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha384-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha384),\"\n\t\t\t\t\t    \"cbc(aes)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha384-cbc-aes-\"\n\t\t\t\t\t\t   \"caam-qi\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha512),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha512-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha512),\"\n\t\t\t\t\t    \"cbc(aes)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha512-cbc-aes-\"\n\t\t\t\t\t\t   \"caam-qi\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(md5),cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(md5),\"\n\t\t\t\t\t    \"cbc(des3_ede)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha1),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha1-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha1),\"\n\t\t\t\t\t    \"cbc(des3_ede)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha1-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha224),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha224-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha224),\"\n\t\t\t\t\t    \"cbc(des3_ede)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha224-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha256),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha256-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha256),\"\n\t\t\t\t\t    \"cbc(des3_ede)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha256-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha384),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha384-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha384),\"\n\t\t\t\t\t    \"cbc(des3_ede)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha384-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha512),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha512-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha512),\"\n\t\t\t\t\t    \"cbc(des3_ede)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha512-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(md5),cbc(des))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(md5),\"\n\t\t\t\t\t    \"cbc(des)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha1),cbc(des))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha1-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha1),\"\n\t\t\t\t\t    \"cbc(des)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha1-cbc-des-caam-qi\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha224),cbc(des))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha224-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha224),\"\n\t\t\t\t\t    \"cbc(des)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha224-cbc-des-\"\n\t\t\t\t\t\t   \"caam-qi\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha256),cbc(des))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha256-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha256),\"\n\t\t\t\t\t    \"cbc(des)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha256-cbc-des-\"\n\t\t\t\t\t\t   \"caam-qi\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha384),cbc(des))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha384-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha384),\"\n\t\t\t\t\t    \"cbc(des)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha384-cbc-des-\"\n\t\t\t\t\t\t   \"caam-qi\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha512),cbc(des))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha512-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha512),\"\n\t\t\t\t\t    \"cbc(des)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha512-cbc-des-\"\n\t\t\t\t\t\t   \"caam-qi\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n};\n\nstatic int caam_init_common(struct caam_ctx *ctx, struct caam_alg_entry *caam,\n\t\t\t    bool uses_dkp)\n{\n\tstruct caam_drv_private *priv;\n\tstruct device *dev;\n\n\t \n\tctx->jrdev = caam_jr_alloc();\n\tif (IS_ERR(ctx->jrdev)) {\n\t\tpr_err(\"Job Ring Device allocation for transform failed\\n\");\n\t\treturn PTR_ERR(ctx->jrdev);\n\t}\n\n\tdev = ctx->jrdev->parent;\n\tpriv = dev_get_drvdata(dev);\n\tif (priv->era >= 6 && uses_dkp)\n\t\tctx->dir = DMA_BIDIRECTIONAL;\n\telse\n\t\tctx->dir = DMA_TO_DEVICE;\n\n\tctx->key_dma = dma_map_single(dev, ctx->key, sizeof(ctx->key),\n\t\t\t\t      ctx->dir);\n\tif (dma_mapping_error(dev, ctx->key_dma)) {\n\t\tdev_err(dev, \"unable to map key\\n\");\n\t\tcaam_jr_free(ctx->jrdev);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tctx->cdata.algtype = OP_TYPE_CLASS1_ALG | caam->class1_alg_type;\n\tctx->adata.algtype = OP_TYPE_CLASS2_ALG | caam->class2_alg_type;\n\n\tctx->qidev = dev;\n\n\tspin_lock_init(&ctx->lock);\n\tctx->drv_ctx[ENCRYPT] = NULL;\n\tctx->drv_ctx[DECRYPT] = NULL;\n\n\treturn 0;\n}\n\nstatic int caam_cra_init(struct crypto_skcipher *tfm)\n{\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(tfm);\n\tstruct caam_skcipher_alg *caam_alg =\n\t\tcontainer_of(alg, typeof(*caam_alg), skcipher);\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(tfm);\n\tu32 alg_aai = caam_alg->caam.class1_alg_type & OP_ALG_AAI_MASK;\n\tint ret = 0;\n\n\tif (alg_aai == OP_ALG_AAI_XTS) {\n\t\tconst char *tfm_name = crypto_tfm_alg_name(&tfm->base);\n\t\tstruct crypto_skcipher *fallback;\n\n\t\tfallback = crypto_alloc_skcipher(tfm_name, 0,\n\t\t\t\t\t\t CRYPTO_ALG_NEED_FALLBACK);\n\t\tif (IS_ERR(fallback)) {\n\t\t\tpr_err(\"Failed to allocate %s fallback: %ld\\n\",\n\t\t\t       tfm_name, PTR_ERR(fallback));\n\t\t\treturn PTR_ERR(fallback);\n\t\t}\n\n\t\tctx->fallback = fallback;\n\t\tcrypto_skcipher_set_reqsize(tfm, sizeof(struct caam_skcipher_req_ctx) +\n\t\t\t\t\t    crypto_skcipher_reqsize(fallback));\n\t}\n\n\tret = caam_init_common(ctx, &caam_alg->caam, false);\n\tif (ret && ctx->fallback)\n\t\tcrypto_free_skcipher(ctx->fallback);\n\n\treturn ret;\n}\n\nstatic int caam_aead_init(struct crypto_aead *tfm)\n{\n\tstruct aead_alg *alg = crypto_aead_alg(tfm);\n\tstruct caam_aead_alg *caam_alg = container_of(alg, typeof(*caam_alg),\n\t\t\t\t\t\t      aead);\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(tfm);\n\n\treturn caam_init_common(ctx, &caam_alg->caam, !caam_alg->caam.nodkp);\n}\n\nstatic void caam_exit_common(struct caam_ctx *ctx)\n{\n\tcaam_drv_ctx_rel(ctx->drv_ctx[ENCRYPT]);\n\tcaam_drv_ctx_rel(ctx->drv_ctx[DECRYPT]);\n\n\tdma_unmap_single(ctx->jrdev->parent, ctx->key_dma, sizeof(ctx->key),\n\t\t\t ctx->dir);\n\n\tcaam_jr_free(ctx->jrdev);\n}\n\nstatic void caam_cra_exit(struct crypto_skcipher *tfm)\n{\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(tfm);\n\n\tif (ctx->fallback)\n\t\tcrypto_free_skcipher(ctx->fallback);\n\tcaam_exit_common(ctx);\n}\n\nstatic void caam_aead_exit(struct crypto_aead *tfm)\n{\n\tcaam_exit_common(crypto_aead_ctx_dma(tfm));\n}\n\nvoid caam_qi_algapi_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(driver_aeads); i++) {\n\t\tstruct caam_aead_alg *t_alg = driver_aeads + i;\n\n\t\tif (t_alg->registered)\n\t\t\tcrypto_unregister_aead(&t_alg->aead);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(driver_algs); i++) {\n\t\tstruct caam_skcipher_alg *t_alg = driver_algs + i;\n\n\t\tif (t_alg->registered)\n\t\t\tcrypto_unregister_skcipher(&t_alg->skcipher);\n\t}\n}\n\nstatic void caam_skcipher_alg_init(struct caam_skcipher_alg *t_alg)\n{\n\tstruct skcipher_alg *alg = &t_alg->skcipher;\n\n\talg->base.cra_module = THIS_MODULE;\n\talg->base.cra_priority = CAAM_CRA_PRIORITY;\n\talg->base.cra_ctxsize = sizeof(struct caam_ctx) + crypto_dma_padding();\n\talg->base.cra_flags |= (CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY);\n\n\talg->init = caam_cra_init;\n\talg->exit = caam_cra_exit;\n}\n\nstatic void caam_aead_alg_init(struct caam_aead_alg *t_alg)\n{\n\tstruct aead_alg *alg = &t_alg->aead;\n\n\talg->base.cra_module = THIS_MODULE;\n\talg->base.cra_priority = CAAM_CRA_PRIORITY;\n\talg->base.cra_ctxsize = sizeof(struct caam_ctx) + crypto_dma_padding();\n\talg->base.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t      CRYPTO_ALG_KERN_DRIVER_ONLY;\n\n\talg->init = caam_aead_init;\n\talg->exit = caam_aead_exit;\n}\n\nint caam_qi_algapi_init(struct device *ctrldev)\n{\n\tstruct caam_drv_private *priv = dev_get_drvdata(ctrldev);\n\tint i = 0, err = 0;\n\tu32 aes_vid, aes_inst, des_inst, md_vid, md_inst;\n\tunsigned int md_limit = SHA512_DIGEST_SIZE;\n\tbool registered = false;\n\n\t \n\tif (!priv->qi_present || caam_dpaa2)\n\t\treturn 0;\n\n\t \n\tif (priv->era < 10) {\n\t\tu32 cha_vid, cha_inst;\n\n\t\tcha_vid = rd_reg32(&priv->ctrl->perfmon.cha_id_ls);\n\t\taes_vid = cha_vid & CHA_ID_LS_AES_MASK;\n\t\tmd_vid = (cha_vid & CHA_ID_LS_MD_MASK) >> CHA_ID_LS_MD_SHIFT;\n\n\t\tcha_inst = rd_reg32(&priv->ctrl->perfmon.cha_num_ls);\n\t\tdes_inst = (cha_inst & CHA_ID_LS_DES_MASK) >>\n\t\t\t   CHA_ID_LS_DES_SHIFT;\n\t\taes_inst = cha_inst & CHA_ID_LS_AES_MASK;\n\t\tmd_inst = (cha_inst & CHA_ID_LS_MD_MASK) >> CHA_ID_LS_MD_SHIFT;\n\t} else {\n\t\tu32 aesa, mdha;\n\n\t\taesa = rd_reg32(&priv->ctrl->vreg.aesa);\n\t\tmdha = rd_reg32(&priv->ctrl->vreg.mdha);\n\n\t\taes_vid = (aesa & CHA_VER_VID_MASK) >> CHA_VER_VID_SHIFT;\n\t\tmd_vid = (mdha & CHA_VER_VID_MASK) >> CHA_VER_VID_SHIFT;\n\n\t\tdes_inst = rd_reg32(&priv->ctrl->vreg.desa) & CHA_VER_NUM_MASK;\n\t\taes_inst = aesa & CHA_VER_NUM_MASK;\n\t\tmd_inst = mdha & CHA_VER_NUM_MASK;\n\t}\n\n\t \n\tif (md_inst && md_vid  == CHA_VER_VID_MD_LP256)\n\t\tmd_limit = SHA256_DIGEST_SIZE;\n\n\tfor (i = 0; i < ARRAY_SIZE(driver_algs); i++) {\n\t\tstruct caam_skcipher_alg *t_alg = driver_algs + i;\n\t\tu32 alg_sel = t_alg->caam.class1_alg_type & OP_ALG_ALGSEL_MASK;\n\n\t\t \n\t\tif (!des_inst &&\n\t\t    ((alg_sel == OP_ALG_ALGSEL_3DES) ||\n\t\t     (alg_sel == OP_ALG_ALGSEL_DES)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!aes_inst && (alg_sel == OP_ALG_ALGSEL_AES))\n\t\t\tcontinue;\n\n\t\tcaam_skcipher_alg_init(t_alg);\n\n\t\terr = crypto_register_skcipher(&t_alg->skcipher);\n\t\tif (err) {\n\t\t\tdev_warn(ctrldev, \"%s alg registration failed\\n\",\n\t\t\t\t t_alg->skcipher.base.cra_driver_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tt_alg->registered = true;\n\t\tregistered = true;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(driver_aeads); i++) {\n\t\tstruct caam_aead_alg *t_alg = driver_aeads + i;\n\t\tu32 c1_alg_sel = t_alg->caam.class1_alg_type &\n\t\t\t\t OP_ALG_ALGSEL_MASK;\n\t\tu32 c2_alg_sel = t_alg->caam.class2_alg_type &\n\t\t\t\t OP_ALG_ALGSEL_MASK;\n\t\tu32 alg_aai = t_alg->caam.class1_alg_type & OP_ALG_AAI_MASK;\n\n\t\t \n\t\tif (!des_inst &&\n\t\t    ((c1_alg_sel == OP_ALG_ALGSEL_3DES) ||\n\t\t     (c1_alg_sel == OP_ALG_ALGSEL_DES)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!aes_inst && (c1_alg_sel == OP_ALG_ALGSEL_AES))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (aes_vid  == CHA_VER_VID_AES_LP && alg_aai == OP_ALG_AAI_GCM)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (c2_alg_sel &&\n\t\t    (!md_inst || (t_alg->aead.maxauthsize > md_limit)))\n\t\t\tcontinue;\n\n\t\tcaam_aead_alg_init(t_alg);\n\n\t\terr = crypto_register_aead(&t_alg->aead);\n\t\tif (err) {\n\t\t\tpr_warn(\"%s alg registration failed\\n\",\n\t\t\t\tt_alg->aead.base.cra_driver_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tt_alg->registered = true;\n\t\tregistered = true;\n\t}\n\n\tif (registered)\n\t\tdev_info(ctrldev, \"algorithms registered in /proc/crypto\\n\");\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}