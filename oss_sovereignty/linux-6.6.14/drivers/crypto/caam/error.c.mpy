{
  "module_name": "error.c",
  "hash_id": "f2626e0c518ef5df5ca250a0dbec1fb16ed854d1ad4d313ee3f4ecae001ed0dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/caam/error.c",
  "human_readable_source": "\n \n\n#include \"compat.h\"\n#include \"regs.h\"\n#include \"desc.h\"\n#include \"error.h\"\n\n#ifdef DEBUG\n#include <linux/highmem.h>\n\nvoid caam_dump_sg(const char *prefix_str, int prefix_type,\n\t\t  int rowsize, int groupsize, struct scatterlist *sg,\n\t\t  size_t tlen, bool ascii)\n{\n\tstruct scatterlist *it;\n\tvoid *it_page;\n\tsize_t len;\n\tvoid *buf;\n\n\tfor (it = sg; it && tlen > 0 ; it = sg_next(it)) {\n\t\t \n\t\tit_page = kmap_atomic(sg_page(it));\n\t\tif (unlikely(!it_page)) {\n\t\t\tpr_err(\"caam_dump_sg: kmap failed\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tbuf = it_page + it->offset;\n\t\tlen = min_t(size_t, tlen, it->length);\n\t\tprint_hex_dump_debug(prefix_str, prefix_type, rowsize,\n\t\t\t\t     groupsize, buf, len, ascii);\n\t\ttlen -= len;\n\n\t\tkunmap_atomic(it_page);\n\t}\n}\n#else\nvoid caam_dump_sg(const char *prefix_str, int prefix_type,\n\t\t  int rowsize, int groupsize, struct scatterlist *sg,\n\t\t  size_t tlen, bool ascii)\n{}\n#endif  \nEXPORT_SYMBOL(caam_dump_sg);\n\nbool caam_little_end;\nEXPORT_SYMBOL(caam_little_end);\n\nbool caam_imx;\nEXPORT_SYMBOL(caam_imx);\n\nsize_t caam_ptr_sz;\nEXPORT_SYMBOL(caam_ptr_sz);\n\nstatic const struct {\n\tu8 value;\n\tconst char *error_text;\n} desc_error_list[] = {\n\t{ 0x00, \"No error.\" },\n\t{ 0x01, \"SGT Length Error. The descriptor is trying to read more data than is contained in the SGT table.\" },\n\t{ 0x02, \"SGT Null Entry Error.\" },\n\t{ 0x03, \"Job Ring Control Error. There is a bad value in the Job Ring Control register.\" },\n\t{ 0x04, \"Invalid Descriptor Command. The Descriptor Command field is invalid.\" },\n\t{ 0x05, \"Reserved.\" },\n\t{ 0x06, \"Invalid KEY Command\" },\n\t{ 0x07, \"Invalid LOAD Command\" },\n\t{ 0x08, \"Invalid STORE Command\" },\n\t{ 0x09, \"Invalid OPERATION Command\" },\n\t{ 0x0A, \"Invalid FIFO LOAD Command\" },\n\t{ 0x0B, \"Invalid FIFO STORE Command\" },\n\t{ 0x0C, \"Invalid MOVE/MOVE_LEN Command\" },\n\t{ 0x0D, \"Invalid JUMP Command. A nonlocal JUMP Command is invalid because the target is not a Job Header Command, or the jump is from a Trusted Descriptor to a Job Descriptor, or because the target Descriptor contains a Shared Descriptor.\" },\n\t{ 0x0E, \"Invalid MATH Command\" },\n\t{ 0x0F, \"Invalid SIGNATURE Command\" },\n\t{ 0x10, \"Invalid Sequence Command. A SEQ IN PTR OR SEQ OUT PTR Command is invalid or a SEQ KEY, SEQ LOAD, SEQ FIFO LOAD, or SEQ FIFO STORE decremented the input or output sequence length below 0. This error may result if a built-in PROTOCOL Command has encountered a malformed PDU.\" },\n\t{ 0x11, \"Skip data type invalid. The type must be 0xE or 0xF.\"},\n\t{ 0x12, \"Shared Descriptor Header Error\" },\n\t{ 0x13, \"Header Error. Invalid length or parity, or certain other problems.\" },\n\t{ 0x14, \"Burster Error. Burster has gotten to an illegal state\" },\n\t{ 0x15, \"Context Register Length Error. The descriptor is trying to read or write past the end of the Context Register. A SEQ LOAD or SEQ STORE with the VLF bit set was executed with too large a length in the variable length register (VSOL for SEQ STORE or VSIL for SEQ LOAD).\" },\n\t{ 0x16, \"DMA Error\" },\n\t{ 0x17, \"Reserved.\" },\n\t{ 0x1A, \"Job failed due to JR reset\" },\n\t{ 0x1B, \"Job failed due to Fail Mode\" },\n\t{ 0x1C, \"DECO Watchdog timer timeout error\" },\n\t{ 0x1D, \"DECO tried to copy a key from another DECO but the other DECO's Key Registers were locked\" },\n\t{ 0x1E, \"DECO attempted to copy data from a DECO that had an unmasked Descriptor error\" },\n\t{ 0x1F, \"LIODN error. DECO was trying to share from itself or from another DECO but the two Non-SEQ LIODN values didn't match or the 'shared from' DECO's Descriptor required that the SEQ LIODNs be the same and they aren't.\" },\n\t{ 0x20, \"DECO has completed a reset initiated via the DRR register\" },\n\t{ 0x21, \"Nonce error. When using EKT (CCM) key encryption option in the FIFO STORE Command, the Nonce counter reached its maximum value and this encryption mode can no longer be used.\" },\n\t{ 0x22, \"Meta data is too large (> 511 bytes) for TLS decap (input frame; block ciphers) and IPsec decap (output frame, when doing the next header byte update) and DCRC (output frame).\" },\n\t{ 0x23, \"Read Input Frame error\" },\n\t{ 0x24, \"JDKEK, TDKEK or TDSK not loaded error\" },\n\t{ 0x80, \"DNR (do not run) error\" },\n\t{ 0x81, \"undefined protocol command\" },\n\t{ 0x82, \"invalid setting in PDB\" },\n\t{ 0x83, \"Anti-replay LATE error\" },\n\t{ 0x84, \"Anti-replay REPLAY error\" },\n\t{ 0x85, \"Sequence number overflow\" },\n\t{ 0x86, \"Sigver invalid signature\" },\n\t{ 0x87, \"DSA Sign Illegal test descriptor\" },\n\t{ 0x88, \"Protocol Format Error - A protocol has seen an error in the format of data received. When running RSA, this means that formatting with random padding was used, and did not follow the form: 0x00, 0x02, 8-to-N bytes of non-zero pad, 0x00, F data.\" },\n\t{ 0x89, \"Protocol Size Error - A protocol has seen an error in size. When running RSA, pdb size N < (size of F) when no formatting is used; or pdb size N < (F + 11) when formatting is used.\" },\n\t{ 0xC1, \"Blob Command error: Undefined mode\" },\n\t{ 0xC2, \"Blob Command error: Secure Memory Blob mode error\" },\n\t{ 0xC4, \"Blob Command error: Black Blob key or input size error\" },\n\t{ 0xC5, \"Blob Command error: Invalid key destination\" },\n\t{ 0xC8, \"Blob Command error: Trusted/Secure mode error\" },\n\t{ 0xF0, \"IPsec TTL or hop limit field either came in as 0, or was decremented to 0\" },\n\t{ 0xF1, \"3GPP HFN matches or exceeds the Threshold\" },\n};\n\nstatic const struct {\n\tu8 value;\n\tconst char *error_text;\n} qi_error_list[] = {\n\t{ 0x00, \"No error\" },\n\t{ 0x1F, \"Job terminated by FQ or ICID flush\" },\n\t{ 0x20, \"FD format error\"},\n\t{ 0x21, \"FD command format error\"},\n\t{ 0x23, \"FL format error\"},\n\t{ 0x25, \"CRJD specified in FD, but not enabled in FLC\"},\n\t{ 0x30, \"Max. buffer size too small\"},\n\t{ 0x31, \"DHR exceeds max. buffer size (allocate mode, S/G format)\"},\n\t{ 0x32, \"SGT exceeds max. buffer size (allocate mode, S/G format\"},\n\t{ 0x33, \"Size over/underflow (allocate mode)\"},\n\t{ 0x34, \"Size over/underflow (reuse mode)\"},\n\t{ 0x35, \"Length exceeds max. short length (allocate mode, S/G/ format)\"},\n\t{ 0x36, \"Memory footprint exceeds max. value (allocate mode, S/G/ format)\"},\n\t{ 0x41, \"SBC frame format not supported (allocate mode)\"},\n\t{ 0x42, \"Pool 0 invalid / pool 1 size < pool 0 size (allocate mode)\"},\n\t{ 0x43, \"Annotation output enabled but ASAR = 0 (allocate mode)\"},\n\t{ 0x44, \"Unsupported or reserved frame format or SGHR = 1 (reuse mode)\"},\n\t{ 0x45, \"DHR correction underflow (reuse mode, single buffer format)\"},\n\t{ 0x46, \"Annotation length exceeds offset (reuse mode)\"},\n\t{ 0x48, \"Annotation output enabled but ASA limited by ASAR (reuse mode)\"},\n\t{ 0x49, \"Data offset correction exceeds input frame data length (reuse mode)\"},\n\t{ 0x4B, \"Annotation output enabled but ASA cannot be expanded (frame list)\"},\n\t{ 0x51, \"Unsupported IF reuse mode\"},\n\t{ 0x52, \"Unsupported FL use mode\"},\n\t{ 0x53, \"Unsupported RJD use mode\"},\n\t{ 0x54, \"Unsupported inline descriptor use mode\"},\n\t{ 0xC0, \"Table buffer pool 0 depletion\"},\n\t{ 0xC1, \"Table buffer pool 1 depletion\"},\n\t{ 0xC2, \"Data buffer pool 0 depletion, no OF allocated\"},\n\t{ 0xC3, \"Data buffer pool 1 depletion, no OF allocated\"},\n\t{ 0xC4, \"Data buffer pool 0 depletion, partial OF allocated\"},\n\t{ 0xC5, \"Data buffer pool 1 depletion, partial OF allocated\"},\n\t{ 0xD0, \"FLC read error\"},\n\t{ 0xD1, \"FL read error\"},\n\t{ 0xD2, \"FL write error\"},\n\t{ 0xD3, \"OF SGT write error\"},\n\t{ 0xD4, \"PTA read error\"},\n\t{ 0xD5, \"PTA write error\"},\n\t{ 0xD6, \"OF SGT F-bit write error\"},\n\t{ 0xD7, \"ASA write error\"},\n\t{ 0xE1, \"FLC[ICR]=0 ICID error\"},\n\t{ 0xE2, \"FLC[ICR]=1 ICID error\"},\n\t{ 0xE4, \"source of ICID flush not trusted (BDI = 0)\"},\n};\n\nstatic const char * const cha_id_list[] = {\n\t\"\",\n\t\"AES\",\n\t\"DES\",\n\t\"ARC4\",\n\t\"MDHA\",\n\t\"RNG\",\n\t\"SNOW f8\",\n\t\"Kasumi f8/9\",\n\t\"PKHA\",\n\t\"CRCA\",\n\t\"SNOW f9\",\n\t\"ZUCE\",\n\t\"ZUCA\",\n};\n\nstatic const char * const err_id_list[] = {\n\t\"No error.\",\n\t\"Mode error.\",\n\t\"Data size error.\",\n\t\"Key size error.\",\n\t\"PKHA A memory size error.\",\n\t\"PKHA B memory size error.\",\n\t\"Data arrived out of sequence error.\",\n\t\"PKHA divide-by-zero error.\",\n\t\"PKHA modulus even error.\",\n\t\"DES key parity error.\",\n\t\"ICV check failed.\",\n\t\"Hardware error.\",\n\t\"Unsupported CCM AAD size.\",\n\t\"Class 1 CHA is not reset\",\n\t\"Invalid CHA combination was selected\",\n\t\"Invalid CHA selected.\",\n};\n\nstatic const char * const rng_err_id_list[] = {\n\t\"\",\n\t\"\",\n\t\"\",\n\t\"Instantiate\",\n\t\"Not instantiated\",\n\t\"Test instantiate\",\n\t\"Prediction resistance\",\n\t\"Prediction resistance and test request\",\n\t\"Uninstantiate\",\n\t\"Secure key generation\",\n\t\"\",\n\t\"Hardware error\",\n\t\"Continuous check\"\n};\n\nstatic int report_ccb_status(struct device *jrdev, const u32 status,\n\t\t\t     const char *error)\n{\n\tu8 cha_id = (status & JRSTA_CCBERR_CHAID_MASK) >>\n\t\t    JRSTA_CCBERR_CHAID_SHIFT;\n\tu8 err_id = status & JRSTA_CCBERR_ERRID_MASK;\n\tu8 idx = (status & JRSTA_DECOERR_INDEX_MASK) >>\n\t\t  JRSTA_DECOERR_INDEX_SHIFT;\n\tchar *idx_str;\n\tconst char *cha_str = \"unidentified cha_id value 0x\";\n\tchar cha_err_code[3] = { 0 };\n\tconst char *err_str = \"unidentified err_id value 0x\";\n\tchar err_err_code[3] = { 0 };\n\n\tif (status & JRSTA_DECOERR_JUMP)\n\t\tidx_str = \"jump tgt desc idx\";\n\telse\n\t\tidx_str = \"desc idx\";\n\n\tif (cha_id < ARRAY_SIZE(cha_id_list))\n\t\tcha_str = cha_id_list[cha_id];\n\telse\n\t\tsnprintf(cha_err_code, sizeof(cha_err_code), \"%02x\", cha_id);\n\n\tif ((cha_id << JRSTA_CCBERR_CHAID_SHIFT) == JRSTA_CCBERR_CHAID_RNG &&\n\t    err_id < ARRAY_SIZE(rng_err_id_list) &&\n\t    strlen(rng_err_id_list[err_id])) {\n\t\t \n\t\terr_str = rng_err_id_list[err_id];\n\t} else {\n\t\terr_str = err_id_list[err_id];\n\t}\n\n\t \n\tif (err_id == JRSTA_CCBERR_ERRID_ICVCHK)\n\t\treturn -EBADMSG;\n\n\tdev_err_ratelimited(jrdev, \"%08x: %s: %s %d: %s%s: %s%s\\n\", status,\n\t\t\t    error, idx_str, idx, cha_str, cha_err_code,\n\t\t\t    err_str, err_err_code);\n\n\treturn -EINVAL;\n}\n\nstatic int report_jump_status(struct device *jrdev, const u32 status,\n\t\t\t      const char *error)\n{\n\tdev_err(jrdev, \"%08x: %s: %s() not implemented\\n\",\n\t\tstatus, error, __func__);\n\n\treturn -EINVAL;\n}\n\nstatic int report_deco_status(struct device *jrdev, const u32 status,\n\t\t\t      const char *error)\n{\n\tu8 err_id = status & JRSTA_DECOERR_ERROR_MASK;\n\tu8 idx = (status & JRSTA_DECOERR_INDEX_MASK) >>\n\t\t  JRSTA_DECOERR_INDEX_SHIFT;\n\tchar *idx_str;\n\tconst char *err_str = \"unidentified error value 0x\";\n\tchar err_err_code[3] = { 0 };\n\tint i;\n\n\tif (status & JRSTA_DECOERR_JUMP)\n\t\tidx_str = \"jump tgt desc idx\";\n\telse\n\t\tidx_str = \"desc idx\";\n\n\tfor (i = 0; i < ARRAY_SIZE(desc_error_list); i++)\n\t\tif (desc_error_list[i].value == err_id)\n\t\t\tbreak;\n\n\tif (i != ARRAY_SIZE(desc_error_list) && desc_error_list[i].error_text)\n\t\terr_str = desc_error_list[i].error_text;\n\telse\n\t\tsnprintf(err_err_code, sizeof(err_err_code), \"%02x\", err_id);\n\n\tdev_err(jrdev, \"%08x: %s: %s %d: %s%s\\n\",\n\t\tstatus, error, idx_str, idx, err_str, err_err_code);\n\n\treturn -EINVAL;\n}\n\nstatic int report_qi_status(struct device *qidev, const u32 status,\n\t\t\t    const char *error)\n{\n\tu8 err_id = status & JRSTA_QIERR_ERROR_MASK;\n\tconst char *err_str = \"unidentified error value 0x\";\n\tchar err_err_code[3] = { 0 };\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(qi_error_list); i++)\n\t\tif (qi_error_list[i].value == err_id)\n\t\t\tbreak;\n\n\tif (i != ARRAY_SIZE(qi_error_list) && qi_error_list[i].error_text)\n\t\terr_str = qi_error_list[i].error_text;\n\telse\n\t\tsnprintf(err_err_code, sizeof(err_err_code), \"%02x\", err_id);\n\n\tdev_err(qidev, \"%08x: %s: %s%s\\n\",\n\t\tstatus, error, err_str, err_err_code);\n\n\treturn -EINVAL;\n}\n\nstatic int report_jr_status(struct device *jrdev, const u32 status,\n\t\t\t    const char *error)\n{\n\tdev_err(jrdev, \"%08x: %s: %s() not implemented\\n\",\n\t\tstatus, error, __func__);\n\n\treturn -EINVAL;\n}\n\nstatic int report_cond_code_status(struct device *jrdev, const u32 status,\n\t\t\t\t   const char *error)\n{\n\tdev_err(jrdev, \"%08x: %s: %s() not implemented\\n\",\n\t\tstatus, error, __func__);\n\n\treturn -EINVAL;\n}\n\nint caam_strstatus(struct device *jrdev, u32 status, bool qi_v2)\n{\n\tstatic const struct stat_src {\n\t\tint (*report_ssed)(struct device *jrdev, const u32 status,\n\t\t\t\t   const char *error);\n\t\tconst char *error;\n\t} status_src[16] = {\n\t\t{ NULL, \"No error\" },\n\t\t{ NULL, NULL },\n\t\t{ report_ccb_status, \"CCB\" },\n\t\t{ report_jump_status, \"Jump\" },\n\t\t{ report_deco_status, \"DECO\" },\n\t\t{ report_qi_status, \"Queue Manager Interface\" },\n\t\t{ report_jr_status, \"Job Ring\" },\n\t\t{ report_cond_code_status, \"Condition Code\" },\n\t\t{ NULL, NULL },\n\t\t{ NULL, NULL },\n\t\t{ NULL, NULL },\n\t\t{ NULL, NULL },\n\t\t{ NULL, NULL },\n\t\t{ NULL, NULL },\n\t\t{ NULL, NULL },\n\t\t{ NULL, NULL },\n\t};\n\tu32 ssrc = status >> JRSTA_SSRC_SHIFT;\n\tconst char *error = status_src[ssrc].error;\n\n\t \n\tif (status_src[ssrc].report_ssed)\n\t\treturn status_src[ssrc].report_ssed(jrdev, status, error);\n\n\tif (error)\n\t\tdev_err(jrdev, \"%d: %s\\n\", ssrc, error);\n\telse\n\t\tdev_err(jrdev, \"%d: unknown error source\\n\", ssrc);\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(caam_strstatus);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"FSL CAAM error reporting\");\nMODULE_AUTHOR(\"Freescale Semiconductor\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}