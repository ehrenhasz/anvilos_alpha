{
  "module_name": "caamprng.c",
  "hash_id": "f0983b4cfe11a0efdbc057ba0c1cffd2a4a16a5af75c98938b8bcfe992bcfa3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/caam/caamprng.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <crypto/internal/rng.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include \"compat.h\"\n#include \"regs.h\"\n#include \"intern.h\"\n#include \"desc_constr.h\"\n#include \"jr.h\"\n#include \"error.h\"\n\n \n#define CAAM_PRNG_MAX_DESC_LEN (CAAM_CMD_SZ +\t\t\t\t\\\n\t\t\t    CAAM_CMD_SZ +\t\t\t\t\\\n\t\t\t    CAAM_CMD_SZ + CAAM_PTR_SZ_MAX)\n\n \nstruct caam_prng_ctx {\n\tint err;\n\tstruct completion done;\n};\n\nstruct caam_prng_alg {\n\tstruct rng_alg rng;\n\tbool registered;\n};\n\nstatic void caam_prng_done(struct device *jrdev, u32 *desc, u32 err,\n\t\t\t  void *context)\n{\n\tstruct caam_prng_ctx *jctx = context;\n\n\tjctx->err = err ? caam_jr_strstatus(jrdev, err) : 0;\n\n\tcomplete(&jctx->done);\n}\n\nstatic u32 *caam_init_reseed_desc(u32 *desc)\n{\n\tinit_job_desc(desc, 0);\t \n\t \n\tappend_operation(desc, OP_TYPE_CLASS1_ALG | OP_ALG_ALGSEL_RNG |\n\t\t\tOP_ALG_AS_FINALIZE);\n\n\tprint_hex_dump_debug(\"prng reseed desc@: \", DUMP_PREFIX_ADDRESS,\n\t\t\t     16, 4, desc, desc_bytes(desc), 1);\n\n\treturn desc;\n}\n\nstatic u32 *caam_init_prng_desc(u32 *desc, dma_addr_t dst_dma, u32 len)\n{\n\tinit_job_desc(desc, 0);\t \n\t \n\tappend_operation(desc, OP_ALG_ALGSEL_RNG | OP_TYPE_CLASS1_ALG);\n\t \n\tappend_fifo_store(desc, dst_dma,\n\t\t\t  len, FIFOST_TYPE_RNGSTORE);\n\n\tprint_hex_dump_debug(\"prng job desc@: \", DUMP_PREFIX_ADDRESS,\n\t\t\t     16, 4, desc, desc_bytes(desc), 1);\n\n\treturn desc;\n}\n\nstatic int caam_prng_generate(struct crypto_rng *tfm,\n\t\t\t     const u8 *src, unsigned int slen,\n\t\t\t     u8 *dst, unsigned int dlen)\n{\n\tunsigned int aligned_dlen = ALIGN(dlen, dma_get_cache_alignment());\n\tstruct caam_prng_ctx ctx;\n\tstruct device *jrdev;\n\tdma_addr_t dst_dma;\n\tu32 *desc;\n\tu8 *buf;\n\tint ret;\n\n\tif (aligned_dlen < dlen)\n\t\treturn -EOVERFLOW;\n\n\tbuf = kzalloc(aligned_dlen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tjrdev = caam_jr_alloc();\n\tret = PTR_ERR_OR_ZERO(jrdev);\n\tif (ret) {\n\t\tpr_err(\"Job Ring Device allocation failed\\n\");\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tdesc = kzalloc(CAAM_PRNG_MAX_DESC_LEN, GFP_KERNEL);\n\tif (!desc) {\n\t\tret = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tdst_dma = dma_map_single(jrdev, buf, dlen, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(jrdev, dst_dma)) {\n\t\tdev_err(jrdev, \"Failed to map destination buffer memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tinit_completion(&ctx.done);\n\tret = caam_jr_enqueue(jrdev,\n\t\t\t      caam_init_prng_desc(desc, dst_dma, dlen),\n\t\t\t      caam_prng_done, &ctx);\n\n\tif (ret == -EINPROGRESS) {\n\t\twait_for_completion(&ctx.done);\n\t\tret = ctx.err;\n\t}\n\n\tdma_unmap_single(jrdev, dst_dma, dlen, DMA_FROM_DEVICE);\n\n\tif (!ret)\n\t\tmemcpy(dst, buf, dlen);\nout:\n\tkfree(desc);\nout1:\n\tcaam_jr_free(jrdev);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic void caam_prng_exit(struct crypto_tfm *tfm) {}\n\nstatic int caam_prng_init(struct crypto_tfm *tfm)\n{\n\treturn 0;\n}\n\nstatic int caam_prng_seed(struct crypto_rng *tfm,\n\t\t\t const u8 *seed, unsigned int slen)\n{\n\tstruct caam_prng_ctx ctx;\n\tstruct device *jrdev;\n\tu32 *desc;\n\tint ret;\n\n\tif (slen) {\n\t\tpr_err(\"Seed length should be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tjrdev = caam_jr_alloc();\n\tret = PTR_ERR_OR_ZERO(jrdev);\n\tif (ret) {\n\t\tpr_err(\"Job Ring Device allocation failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdesc = kzalloc(CAAM_PRNG_MAX_DESC_LEN, GFP_KERNEL);\n\tif (!desc) {\n\t\tcaam_jr_free(jrdev);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_completion(&ctx.done);\n\tret = caam_jr_enqueue(jrdev,\n\t\t\t      caam_init_reseed_desc(desc),\n\t\t\t      caam_prng_done, &ctx);\n\n\tif (ret == -EINPROGRESS) {\n\t\twait_for_completion(&ctx.done);\n\t\tret = ctx.err;\n\t}\n\n\tkfree(desc);\n\tcaam_jr_free(jrdev);\n\treturn ret;\n}\n\nstatic struct caam_prng_alg caam_prng_alg = {\n\t.rng = {\n\t\t.generate = caam_prng_generate,\n\t\t.seed = caam_prng_seed,\n\t\t.seedsize = 0,\n\t\t.base = {\n\t\t\t.cra_name = \"stdrng\",\n\t\t\t.cra_driver_name = \"prng-caam\",\n\t\t\t.cra_priority = 500,\n\t\t\t.cra_ctxsize = sizeof(struct caam_prng_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_init = caam_prng_init,\n\t\t\t.cra_exit = caam_prng_exit,\n\t\t},\n\t}\n};\n\nvoid caam_prng_unregister(void *data)\n{\n\tif (caam_prng_alg.registered)\n\t\tcrypto_unregister_rng(&caam_prng_alg.rng);\n}\n\nint caam_prng_register(struct device *ctrldev)\n{\n\tstruct caam_drv_private *priv = dev_get_drvdata(ctrldev);\n\tu32 rng_inst;\n\tint ret = 0;\n\n\t \n\tif (priv->era < 10)\n\t\trng_inst = (rd_reg32(&priv->jr[0]->perfmon.cha_num_ls) &\n\t\t\t    CHA_ID_LS_RNG_MASK) >> CHA_ID_LS_RNG_SHIFT;\n\telse\n\t\trng_inst = rd_reg32(&priv->jr[0]->vreg.rng) & CHA_VER_NUM_MASK;\n\n\tif (!rng_inst) {\n\t\tdev_dbg(ctrldev, \"RNG block is not available... skipping registering algorithm\\n\");\n\t\treturn ret;\n\t}\n\n\tret = crypto_register_rng(&caam_prng_alg.rng);\n\tif (ret) {\n\t\tdev_err(ctrldev,\n\t\t\t\"couldn't register rng crypto alg: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tcaam_prng_alg.registered = true;\n\n\tdev_info(ctrldev,\n\t\t \"rng crypto API alg registered %s\\n\", caam_prng_alg.rng.base.cra_driver_name);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}