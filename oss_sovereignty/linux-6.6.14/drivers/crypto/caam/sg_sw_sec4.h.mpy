{
  "module_name": "sg_sw_sec4.h",
  "hash_id": "874fd59dcfe1a7a10b5168f8e51fca10be0dae04c01b4152c12df6f9aed3d5a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/caam/sg_sw_sec4.h",
  "human_readable_source": " \n \n\n#ifndef _SG_SW_SEC4_H_\n#define _SG_SW_SEC4_H_\n\n#include \"ctrl.h\"\n#include \"regs.h\"\n#include \"sg_sw_qm2.h\"\n#include <soc/fsl/dpaa2-fd.h>\n\nstruct sec4_sg_entry {\n\tu64 ptr;\n\tu32 len;\n\tu32 bpid_offset;\n};\n\n \nstatic inline void dma_to_sec4_sg_one(struct sec4_sg_entry *sec4_sg_ptr,\n\t\t\t\t      dma_addr_t dma, u32 len, u16 offset)\n{\n\tif (caam_dpaa2) {\n\t\tdma_to_qm_sg_one((struct dpaa2_sg_entry *)sec4_sg_ptr, dma, len,\n\t\t\t\t offset);\n\t} else {\n\t\tsec4_sg_ptr->ptr = cpu_to_caam_dma64(dma);\n\t\tsec4_sg_ptr->len = cpu_to_caam32(len);\n\t\tsec4_sg_ptr->bpid_offset = cpu_to_caam32(offset &\n\t\t\t\t\t\t\t SEC4_SG_OFFSET_MASK);\n\t}\n\n\tprint_hex_dump_debug(\"sec4_sg_ptr@: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t     sec4_sg_ptr, sizeof(struct sec4_sg_entry), 1);\n}\n\n \nstatic inline struct sec4_sg_entry *\nsg_to_sec4_sg(struct scatterlist *sg, int len,\n\t      struct sec4_sg_entry *sec4_sg_ptr, u16 offset)\n{\n\tint ent_len;\n\n\twhile (len) {\n\t\tent_len = min_t(int, sg_dma_len(sg), len);\n\n\t\tdma_to_sec4_sg_one(sec4_sg_ptr, sg_dma_address(sg), ent_len,\n\t\t\t\t   offset);\n\t\tsec4_sg_ptr++;\n\t\tsg = sg_next(sg);\n\t\tlen -= ent_len;\n\t}\n\treturn sec4_sg_ptr - 1;\n}\n\nstatic inline void sg_to_sec4_set_last(struct sec4_sg_entry *sec4_sg_ptr)\n{\n\tif (caam_dpaa2)\n\t\tdpaa2_sg_set_final((struct dpaa2_sg_entry *)sec4_sg_ptr, true);\n\telse\n\t\tsec4_sg_ptr->len |= cpu_to_caam32(SEC4_SG_LEN_FIN);\n}\n\n \nstatic inline void sg_to_sec4_sg_last(struct scatterlist *sg, int len,\n\t\t\t\t      struct sec4_sg_entry *sec4_sg_ptr,\n\t\t\t\t      u16 offset)\n{\n\tsec4_sg_ptr = sg_to_sec4_sg(sg, len, sec4_sg_ptr, offset);\n\tsg_to_sec4_set_last(sec4_sg_ptr);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}