{
  "module_name": "caamalg_qi2.c",
  "hash_id": "e4e54654a981df353b9b55a8077b2558445a45a2fa226cb7748a6810bfe76356",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/caam/caamalg_qi2.c",
  "human_readable_source": "\n \n\n#include \"compat.h\"\n#include \"regs.h\"\n#include \"caamalg_qi2.h\"\n#include \"dpseci_cmd.h\"\n#include \"desc_constr.h\"\n#include \"error.h\"\n#include \"sg_sw_sec4.h\"\n#include \"sg_sw_qm2.h\"\n#include \"key_gen.h\"\n#include \"caamalg_desc.h\"\n#include \"caamhash_desc.h\"\n#include \"dpseci-debugfs.h\"\n#include <linux/dma-mapping.h>\n#include <linux/fsl/mc.h>\n#include <linux/kernel.h>\n#include <soc/fsl/dpaa2-io.h>\n#include <soc/fsl/dpaa2-fd.h>\n#include <crypto/xts.h>\n#include <asm/unaligned.h>\n\n#define CAAM_CRA_PRIORITY\t2000\n\n \n#define CAAM_MAX_KEY_SIZE\t(AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE + \\\n\t\t\t\t SHA512_DIGEST_SIZE * 2)\n\n \nstatic struct kmem_cache *qi_cache;\n\nstruct caam_alg_entry {\n\tstruct device *dev;\n\tint class1_alg_type;\n\tint class2_alg_type;\n\tbool rfc3686;\n\tbool geniv;\n\tbool nodkp;\n};\n\nstruct caam_aead_alg {\n\tstruct aead_alg aead;\n\tstruct caam_alg_entry caam;\n\tbool registered;\n};\n\nstruct caam_skcipher_alg {\n\tstruct skcipher_alg skcipher;\n\tstruct caam_alg_entry caam;\n\tbool registered;\n};\n\n \nstruct caam_ctx {\n\tstruct caam_flc flc[NUM_OP];\n\tu8 key[CAAM_MAX_KEY_SIZE];\n\tdma_addr_t flc_dma[NUM_OP];\n\tdma_addr_t key_dma;\n\tenum dma_data_direction dir;\n\tstruct device *dev;\n\tstruct alginfo adata;\n\tstruct alginfo cdata;\n\tunsigned int authsize;\n\tbool xts_key_fallback;\n\tstruct crypto_skcipher *fallback;\n};\n\nstatic void *dpaa2_caam_iova_to_virt(struct dpaa2_caam_priv *priv,\n\t\t\t\t     dma_addr_t iova_addr)\n{\n\tphys_addr_t phys_addr;\n\n\tphys_addr = priv->domain ? iommu_iova_to_phys(priv->domain, iova_addr) :\n\t\t\t\t   iova_addr;\n\n\treturn phys_to_virt(phys_addr);\n}\n\n \nstatic inline void *qi_cache_zalloc(gfp_t flags)\n{\n\treturn kmem_cache_zalloc(qi_cache, flags);\n}\n\n \nstatic inline void qi_cache_free(void *obj)\n{\n\tkmem_cache_free(qi_cache, obj);\n}\n\nstatic struct caam_request *to_caam_req(struct crypto_async_request *areq)\n{\n\tswitch (crypto_tfm_alg_type(areq->tfm)) {\n\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\treturn skcipher_request_ctx_dma(skcipher_request_cast(areq));\n\tcase CRYPTO_ALG_TYPE_AEAD:\n\t\treturn aead_request_ctx_dma(\n\t\t\tcontainer_of(areq, struct aead_request, base));\n\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\treturn ahash_request_ctx_dma(ahash_request_cast(areq));\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n}\n\nstatic void caam_unmap(struct device *dev, struct scatterlist *src,\n\t\t       struct scatterlist *dst, int src_nents,\n\t\t       int dst_nents, dma_addr_t iv_dma, int ivsize,\n\t\t       enum dma_data_direction iv_dir, dma_addr_t qm_sg_dma,\n\t\t       int qm_sg_bytes)\n{\n\tif (dst != src) {\n\t\tif (src_nents)\n\t\t\tdma_unmap_sg(dev, src, src_nents, DMA_TO_DEVICE);\n\t\tif (dst_nents)\n\t\t\tdma_unmap_sg(dev, dst, dst_nents, DMA_FROM_DEVICE);\n\t} else {\n\t\tdma_unmap_sg(dev, src, src_nents, DMA_BIDIRECTIONAL);\n\t}\n\n\tif (iv_dma)\n\t\tdma_unmap_single(dev, iv_dma, ivsize, iv_dir);\n\n\tif (qm_sg_bytes)\n\t\tdma_unmap_single(dev, qm_sg_dma, qm_sg_bytes, DMA_TO_DEVICE);\n}\n\nstatic int aead_set_sh_desc(struct crypto_aead *aead)\n{\n\tstruct caam_aead_alg *alg = container_of(crypto_aead_alg(aead),\n\t\t\t\t\t\t typeof(*alg), aead);\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tunsigned int ivsize = crypto_aead_ivsize(aead);\n\tstruct device *dev = ctx->dev;\n\tstruct dpaa2_caam_priv *priv = dev_get_drvdata(dev);\n\tstruct caam_flc *flc;\n\tu32 *desc;\n\tu32 ctx1_iv_off = 0;\n\tu32 *nonce = NULL;\n\tunsigned int data_len[2];\n\tu32 inl_mask;\n\tconst bool ctr_mode = ((ctx->cdata.algtype & OP_ALG_AAI_MASK) ==\n\t\t\t       OP_ALG_AAI_CTR_MOD128);\n\tconst bool is_rfc3686 = alg->caam.rfc3686;\n\n\tif (!ctx->cdata.keylen || !ctx->authsize)\n\t\treturn 0;\n\n\t \n\tif (ctr_mode)\n\t\tctx1_iv_off = 16;\n\n\t \n\tif (is_rfc3686) {\n\t\tctx1_iv_off = 16 + CTR_RFC3686_NONCE_SIZE;\n\t\tnonce = (u32 *)((void *)ctx->key + ctx->adata.keylen_pad +\n\t\t\t\tctx->cdata.keylen - CTR_RFC3686_NONCE_SIZE);\n\t}\n\n\t \n\tctx->adata.key_virt = ctx->key;\n\tctx->adata.key_dma = ctx->key_dma;\n\n\tctx->cdata.key_virt = ctx->key + ctx->adata.keylen_pad;\n\tctx->cdata.key_dma = ctx->key_dma + ctx->adata.keylen_pad;\n\n\tdata_len[0] = ctx->adata.keylen_pad;\n\tdata_len[1] = ctx->cdata.keylen;\n\n\t \n\tif (desc_inline_query((alg->caam.geniv ? DESC_QI_AEAD_GIVENC_LEN :\n\t\t\t\t\t\t DESC_QI_AEAD_ENC_LEN) +\n\t\t\t      (is_rfc3686 ? DESC_AEAD_CTR_RFC3686_LEN : 0),\n\t\t\t      DESC_JOB_IO_LEN, data_len, &inl_mask,\n\t\t\t      ARRAY_SIZE(data_len)) < 0)\n\t\treturn -EINVAL;\n\n\tctx->adata.key_inline = !!(inl_mask & 1);\n\tctx->cdata.key_inline = !!(inl_mask & 2);\n\n\tflc = &ctx->flc[ENCRYPT];\n\tdesc = flc->sh_desc;\n\n\tif (alg->caam.geniv)\n\t\tcnstr_shdsc_aead_givencap(desc, &ctx->cdata, &ctx->adata,\n\t\t\t\t\t  ivsize, ctx->authsize, is_rfc3686,\n\t\t\t\t\t  nonce, ctx1_iv_off, true,\n\t\t\t\t\t  priv->sec_attr.era);\n\telse\n\t\tcnstr_shdsc_aead_encap(desc, &ctx->cdata, &ctx->adata,\n\t\t\t\t       ivsize, ctx->authsize, is_rfc3686, nonce,\n\t\t\t\t       ctx1_iv_off, true, priv->sec_attr.era);\n\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[ENCRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\t \n\tif (desc_inline_query(DESC_QI_AEAD_DEC_LEN +\n\t\t\t      (is_rfc3686 ? DESC_AEAD_CTR_RFC3686_LEN : 0),\n\t\t\t      DESC_JOB_IO_LEN, data_len, &inl_mask,\n\t\t\t      ARRAY_SIZE(data_len)) < 0)\n\t\treturn -EINVAL;\n\n\tctx->adata.key_inline = !!(inl_mask & 1);\n\tctx->cdata.key_inline = !!(inl_mask & 2);\n\n\tflc = &ctx->flc[DECRYPT];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_aead_decap(desc, &ctx->cdata, &ctx->adata,\n\t\t\t       ivsize, ctx->authsize, alg->caam.geniv,\n\t\t\t       is_rfc3686, nonce, ctx1_iv_off, true,\n\t\t\t       priv->sec_attr.era);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[DECRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\treturn 0;\n}\n\nstatic int aead_setauthsize(struct crypto_aead *authenc, unsigned int authsize)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(authenc);\n\n\tctx->authsize = authsize;\n\taead_set_sh_desc(authenc);\n\n\treturn 0;\n}\n\nstatic int aead_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t       unsigned int keylen)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct device *dev = ctx->dev;\n\tstruct crypto_authenc_keys keys;\n\n\tif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\n\t\tgoto badkey;\n\n\tdev_dbg(dev, \"keylen %d enckeylen %d authkeylen %d\\n\",\n\t\tkeys.authkeylen + keys.enckeylen, keys.enckeylen,\n\t\tkeys.authkeylen);\n\tprint_hex_dump_debug(\"key in @\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\n\n\tctx->adata.keylen = keys.authkeylen;\n\tctx->adata.keylen_pad = split_key_len(ctx->adata.algtype &\n\t\t\t\t\t      OP_ALG_ALGSEL_MASK);\n\n\tif (ctx->adata.keylen_pad + keys.enckeylen > CAAM_MAX_KEY_SIZE)\n\t\tgoto badkey;\n\n\tmemcpy(ctx->key, keys.authkey, keys.authkeylen);\n\tmemcpy(ctx->key + ctx->adata.keylen_pad, keys.enckey, keys.enckeylen);\n\tdma_sync_single_for_device(dev, ctx->key_dma, ctx->adata.keylen_pad +\n\t\t\t\t   keys.enckeylen, ctx->dir);\n\tprint_hex_dump_debug(\"ctx.key@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, ctx->key,\n\t\t\t     ctx->adata.keylen_pad + keys.enckeylen, 1);\n\n\tctx->cdata.keylen = keys.enckeylen;\n\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn aead_set_sh_desc(aead);\nbadkey:\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn -EINVAL;\n}\n\nstatic int des3_aead_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t\t    unsigned int keylen)\n{\n\tstruct crypto_authenc_keys keys;\n\tint err;\n\n\terr = crypto_authenc_extractkeys(&keys, key, keylen);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (keys.enckeylen != DES3_EDE_KEY_SIZE)\n\t\tgoto out;\n\n\terr = crypto_des3_ede_verify_key(crypto_aead_tfm(aead), keys.enckey) ?:\n\t      aead_setkey(aead, key, keylen);\n\nout:\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn err;\n}\n\nstatic struct aead_edesc *aead_edesc_alloc(struct aead_request *req,\n\t\t\t\t\t   bool encrypt)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct caam_request *req_ctx = aead_request_ctx_dma(req);\n\tstruct dpaa2_fl_entry *in_fle = &req_ctx->fd_flt[1];\n\tstruct dpaa2_fl_entry *out_fle = &req_ctx->fd_flt[0];\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct caam_aead_alg *alg = container_of(crypto_aead_alg(aead),\n\t\t\t\t\t\t typeof(*alg), aead);\n\tstruct device *dev = ctx->dev;\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t      GFP_KERNEL : GFP_ATOMIC;\n\tint src_nents, mapped_src_nents, dst_nents = 0, mapped_dst_nents = 0;\n\tint src_len, dst_len = 0;\n\tstruct aead_edesc *edesc;\n\tdma_addr_t qm_sg_dma, iv_dma = 0;\n\tint ivsize = 0;\n\tunsigned int authsize = ctx->authsize;\n\tint qm_sg_index = 0, qm_sg_nents = 0, qm_sg_bytes;\n\tint in_len, out_len;\n\tstruct dpaa2_sg_entry *sg_table;\n\n\t \n\tedesc = qi_cache_zalloc(flags);\n\tif (unlikely(!edesc)) {\n\t\tdev_err(dev, \"could not allocate extended descriptor\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (unlikely(req->dst != req->src)) {\n\t\tsrc_len = req->assoclen + req->cryptlen;\n\t\tdst_len = src_len + (encrypt ? authsize : (-authsize));\n\n\t\tsrc_nents = sg_nents_for_len(req->src, src_len);\n\t\tif (unlikely(src_nents < 0)) {\n\t\t\tdev_err(dev, \"Insufficient bytes (%d) in src S/G\\n\",\n\t\t\t\tsrc_len);\n\t\t\tqi_cache_free(edesc);\n\t\t\treturn ERR_PTR(src_nents);\n\t\t}\n\n\t\tdst_nents = sg_nents_for_len(req->dst, dst_len);\n\t\tif (unlikely(dst_nents < 0)) {\n\t\t\tdev_err(dev, \"Insufficient bytes (%d) in dst S/G\\n\",\n\t\t\t\tdst_len);\n\t\t\tqi_cache_free(edesc);\n\t\t\treturn ERR_PTR(dst_nents);\n\t\t}\n\n\t\tif (src_nents) {\n\t\t\tmapped_src_nents = dma_map_sg(dev, req->src, src_nents,\n\t\t\t\t\t\t      DMA_TO_DEVICE);\n\t\t\tif (unlikely(!mapped_src_nents)) {\n\t\t\t\tdev_err(dev, \"unable to map source\\n\");\n\t\t\t\tqi_cache_free(edesc);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t} else {\n\t\t\tmapped_src_nents = 0;\n\t\t}\n\n\t\tif (dst_nents) {\n\t\t\tmapped_dst_nents = dma_map_sg(dev, req->dst, dst_nents,\n\t\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\t\tif (unlikely(!mapped_dst_nents)) {\n\t\t\t\tdev_err(dev, \"unable to map destination\\n\");\n\t\t\t\tdma_unmap_sg(dev, req->src, src_nents,\n\t\t\t\t\t     DMA_TO_DEVICE);\n\t\t\t\tqi_cache_free(edesc);\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\t}\n\t\t} else {\n\t\t\tmapped_dst_nents = 0;\n\t\t}\n\t} else {\n\t\tsrc_len = req->assoclen + req->cryptlen +\n\t\t\t  (encrypt ? authsize : 0);\n\n\t\tsrc_nents = sg_nents_for_len(req->src, src_len);\n\t\tif (unlikely(src_nents < 0)) {\n\t\t\tdev_err(dev, \"Insufficient bytes (%d) in src S/G\\n\",\n\t\t\t\tsrc_len);\n\t\t\tqi_cache_free(edesc);\n\t\t\treturn ERR_PTR(src_nents);\n\t\t}\n\n\t\tmapped_src_nents = dma_map_sg(dev, req->src, src_nents,\n\t\t\t\t\t      DMA_BIDIRECTIONAL);\n\t\tif (unlikely(!mapped_src_nents)) {\n\t\t\tdev_err(dev, \"unable to map source\\n\");\n\t\t\tqi_cache_free(edesc);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\tif ((alg->caam.rfc3686 && encrypt) || !alg->caam.geniv)\n\t\tivsize = crypto_aead_ivsize(aead);\n\n\t \n\tqm_sg_nents = 1 + !!ivsize + mapped_src_nents;\n\tif (mapped_dst_nents > 1)\n\t\tqm_sg_nents += pad_sg_nents(mapped_dst_nents);\n\telse if ((req->src == req->dst) && (mapped_src_nents > 1))\n\t\tqm_sg_nents = max(pad_sg_nents(qm_sg_nents),\n\t\t\t\t  1 + !!ivsize +\n\t\t\t\t  pad_sg_nents(mapped_src_nents));\n\telse\n\t\tqm_sg_nents = pad_sg_nents(qm_sg_nents);\n\n\tsg_table = &edesc->sgt[0];\n\tqm_sg_bytes = qm_sg_nents * sizeof(*sg_table);\n\tif (unlikely(offsetof(struct aead_edesc, sgt) + qm_sg_bytes + ivsize >\n\t\t     CAAM_QI_MEMCACHE_SIZE)) {\n\t\tdev_err(dev, \"No space for %d S/G entries and/or %dB IV\\n\",\n\t\t\tqm_sg_nents, ivsize);\n\t\tcaam_unmap(dev, req->src, req->dst, src_nents, dst_nents, 0,\n\t\t\t   0, DMA_NONE, 0, 0);\n\t\tqi_cache_free(edesc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (ivsize) {\n\t\tu8 *iv = (u8 *)(sg_table + qm_sg_nents);\n\n\t\t \n\t\tmemcpy(iv, req->iv, ivsize);\n\n\t\tiv_dma = dma_map_single(dev, iv, ivsize, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, iv_dma)) {\n\t\t\tdev_err(dev, \"unable to map IV\\n\");\n\t\t\tcaam_unmap(dev, req->src, req->dst, src_nents,\n\t\t\t\t   dst_nents, 0, 0, DMA_NONE, 0, 0);\n\t\t\tqi_cache_free(edesc);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\tedesc->src_nents = src_nents;\n\tedesc->dst_nents = dst_nents;\n\tedesc->iv_dma = iv_dma;\n\n\tif ((alg->caam.class1_alg_type & OP_ALG_ALGSEL_MASK) ==\n\t    OP_ALG_ALGSEL_CHACHA20 && ivsize != CHACHAPOLY_IV_SIZE)\n\t\t \n\t\tedesc->assoclen = cpu_to_caam32(req->assoclen - ivsize);\n\telse\n\t\tedesc->assoclen = cpu_to_caam32(req->assoclen);\n\tedesc->assoclen_dma = dma_map_single(dev, &edesc->assoclen, 4,\n\t\t\t\t\t     DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, edesc->assoclen_dma)) {\n\t\tdev_err(dev, \"unable to map assoclen\\n\");\n\t\tcaam_unmap(dev, req->src, req->dst, src_nents, dst_nents,\n\t\t\t   iv_dma, ivsize, DMA_TO_DEVICE, 0, 0);\n\t\tqi_cache_free(edesc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdma_to_qm_sg_one(sg_table, edesc->assoclen_dma, 4, 0);\n\tqm_sg_index++;\n\tif (ivsize) {\n\t\tdma_to_qm_sg_one(sg_table + qm_sg_index, iv_dma, ivsize, 0);\n\t\tqm_sg_index++;\n\t}\n\tsg_to_qm_sg_last(req->src, src_len, sg_table + qm_sg_index, 0);\n\tqm_sg_index += mapped_src_nents;\n\n\tif (mapped_dst_nents > 1)\n\t\tsg_to_qm_sg_last(req->dst, dst_len, sg_table + qm_sg_index, 0);\n\n\tqm_sg_dma = dma_map_single(dev, sg_table, qm_sg_bytes, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, qm_sg_dma)) {\n\t\tdev_err(dev, \"unable to map S/G table\\n\");\n\t\tdma_unmap_single(dev, edesc->assoclen_dma, 4, DMA_TO_DEVICE);\n\t\tcaam_unmap(dev, req->src, req->dst, src_nents, dst_nents,\n\t\t\t   iv_dma, ivsize, DMA_TO_DEVICE, 0, 0);\n\t\tqi_cache_free(edesc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tedesc->qm_sg_dma = qm_sg_dma;\n\tedesc->qm_sg_bytes = qm_sg_bytes;\n\n\tout_len = req->assoclen + req->cryptlen +\n\t\t  (encrypt ? ctx->authsize : (-ctx->authsize));\n\tin_len = 4 + ivsize + req->assoclen + req->cryptlen;\n\n\tmemset(&req_ctx->fd_flt, 0, sizeof(req_ctx->fd_flt));\n\tdpaa2_fl_set_final(in_fle, true);\n\tdpaa2_fl_set_format(in_fle, dpaa2_fl_sg);\n\tdpaa2_fl_set_addr(in_fle, qm_sg_dma);\n\tdpaa2_fl_set_len(in_fle, in_len);\n\n\tif (req->dst == req->src) {\n\t\tif (mapped_src_nents == 1) {\n\t\t\tdpaa2_fl_set_format(out_fle, dpaa2_fl_single);\n\t\t\tdpaa2_fl_set_addr(out_fle, sg_dma_address(req->src));\n\t\t} else {\n\t\t\tdpaa2_fl_set_format(out_fle, dpaa2_fl_sg);\n\t\t\tdpaa2_fl_set_addr(out_fle, qm_sg_dma +\n\t\t\t\t\t  (1 + !!ivsize) * sizeof(*sg_table));\n\t\t}\n\t} else if (!mapped_dst_nents) {\n\t\t \n\t\tgoto skip_out_fle;\n\t} else if (mapped_dst_nents == 1) {\n\t\tdpaa2_fl_set_format(out_fle, dpaa2_fl_single);\n\t\tdpaa2_fl_set_addr(out_fle, sg_dma_address(req->dst));\n\t} else {\n\t\tdpaa2_fl_set_format(out_fle, dpaa2_fl_sg);\n\t\tdpaa2_fl_set_addr(out_fle, qm_sg_dma + qm_sg_index *\n\t\t\t\t  sizeof(*sg_table));\n\t}\n\n\tdpaa2_fl_set_len(out_fle, out_len);\n\nskip_out_fle:\n\treturn edesc;\n}\n\nstatic int chachapoly_set_sh_desc(struct crypto_aead *aead)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tunsigned int ivsize = crypto_aead_ivsize(aead);\n\tstruct device *dev = ctx->dev;\n\tstruct caam_flc *flc;\n\tu32 *desc;\n\n\tif (!ctx->cdata.keylen || !ctx->authsize)\n\t\treturn 0;\n\n\tflc = &ctx->flc[ENCRYPT];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_chachapoly(desc, &ctx->cdata, &ctx->adata, ivsize,\n\t\t\t       ctx->authsize, true, true);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[ENCRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\tflc = &ctx->flc[DECRYPT];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_chachapoly(desc, &ctx->cdata, &ctx->adata, ivsize,\n\t\t\t       ctx->authsize, false, true);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[DECRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\treturn 0;\n}\n\nstatic int chachapoly_setauthsize(struct crypto_aead *aead,\n\t\t\t\t  unsigned int authsize)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\n\tif (authsize != POLY1305_DIGEST_SIZE)\n\t\treturn -EINVAL;\n\n\tctx->authsize = authsize;\n\treturn chachapoly_set_sh_desc(aead);\n}\n\nstatic int chachapoly_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t\t     unsigned int keylen)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tunsigned int ivsize = crypto_aead_ivsize(aead);\n\tunsigned int saltlen = CHACHAPOLY_IV_SIZE - ivsize;\n\n\tif (keylen != CHACHA_KEY_SIZE + saltlen)\n\t\treturn -EINVAL;\n\n\tmemcpy(ctx->key, key, keylen);\n\tctx->cdata.key_virt = ctx->key;\n\tctx->cdata.keylen = keylen - saltlen;\n\n\treturn chachapoly_set_sh_desc(aead);\n}\n\nstatic int gcm_set_sh_desc(struct crypto_aead *aead)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct device *dev = ctx->dev;\n\tunsigned int ivsize = crypto_aead_ivsize(aead);\n\tstruct caam_flc *flc;\n\tu32 *desc;\n\tint rem_bytes = CAAM_DESC_BYTES_MAX - DESC_JOB_IO_LEN -\n\t\t\tctx->cdata.keylen;\n\n\tif (!ctx->cdata.keylen || !ctx->authsize)\n\t\treturn 0;\n\n\t \n\tif (rem_bytes >= DESC_QI_GCM_ENC_LEN) {\n\t\tctx->cdata.key_inline = true;\n\t\tctx->cdata.key_virt = ctx->key;\n\t} else {\n\t\tctx->cdata.key_inline = false;\n\t\tctx->cdata.key_dma = ctx->key_dma;\n\t}\n\n\tflc = &ctx->flc[ENCRYPT];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_gcm_encap(desc, &ctx->cdata, ivsize, ctx->authsize, true);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[ENCRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\t \n\tif (rem_bytes >= DESC_QI_GCM_DEC_LEN) {\n\t\tctx->cdata.key_inline = true;\n\t\tctx->cdata.key_virt = ctx->key;\n\t} else {\n\t\tctx->cdata.key_inline = false;\n\t\tctx->cdata.key_dma = ctx->key_dma;\n\t}\n\n\tflc = &ctx->flc[DECRYPT];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_gcm_decap(desc, &ctx->cdata, ivsize, ctx->authsize, true);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[DECRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\treturn 0;\n}\n\nstatic int gcm_setauthsize(struct crypto_aead *authenc, unsigned int authsize)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(authenc);\n\tint err;\n\n\terr = crypto_gcm_check_authsize(authsize);\n\tif (err)\n\t\treturn err;\n\n\tctx->authsize = authsize;\n\tgcm_set_sh_desc(authenc);\n\n\treturn 0;\n}\n\nstatic int gcm_setkey(struct crypto_aead *aead,\n\t\t      const u8 *key, unsigned int keylen)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct device *dev = ctx->dev;\n\tint ret;\n\n\tret = aes_check_keylen(keylen);\n\tif (ret)\n\t\treturn ret;\n\tprint_hex_dump_debug(\"key in @\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\n\n\tmemcpy(ctx->key, key, keylen);\n\tdma_sync_single_for_device(dev, ctx->key_dma, keylen, ctx->dir);\n\tctx->cdata.keylen = keylen;\n\n\treturn gcm_set_sh_desc(aead);\n}\n\nstatic int rfc4106_set_sh_desc(struct crypto_aead *aead)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct device *dev = ctx->dev;\n\tunsigned int ivsize = crypto_aead_ivsize(aead);\n\tstruct caam_flc *flc;\n\tu32 *desc;\n\tint rem_bytes = CAAM_DESC_BYTES_MAX - DESC_JOB_IO_LEN -\n\t\t\tctx->cdata.keylen;\n\n\tif (!ctx->cdata.keylen || !ctx->authsize)\n\t\treturn 0;\n\n\tctx->cdata.key_virt = ctx->key;\n\n\t \n\tif (rem_bytes >= DESC_QI_RFC4106_ENC_LEN) {\n\t\tctx->cdata.key_inline = true;\n\t} else {\n\t\tctx->cdata.key_inline = false;\n\t\tctx->cdata.key_dma = ctx->key_dma;\n\t}\n\n\tflc = &ctx->flc[ENCRYPT];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_rfc4106_encap(desc, &ctx->cdata, ivsize, ctx->authsize,\n\t\t\t\t  true);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[ENCRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\t \n\tif (rem_bytes >= DESC_QI_RFC4106_DEC_LEN) {\n\t\tctx->cdata.key_inline = true;\n\t} else {\n\t\tctx->cdata.key_inline = false;\n\t\tctx->cdata.key_dma = ctx->key_dma;\n\t}\n\n\tflc = &ctx->flc[DECRYPT];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_rfc4106_decap(desc, &ctx->cdata, ivsize, ctx->authsize,\n\t\t\t\t  true);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[DECRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\treturn 0;\n}\n\nstatic int rfc4106_setauthsize(struct crypto_aead *authenc,\n\t\t\t       unsigned int authsize)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(authenc);\n\tint err;\n\n\terr = crypto_rfc4106_check_authsize(authsize);\n\tif (err)\n\t\treturn err;\n\n\tctx->authsize = authsize;\n\trfc4106_set_sh_desc(authenc);\n\n\treturn 0;\n}\n\nstatic int rfc4106_setkey(struct crypto_aead *aead,\n\t\t\t  const u8 *key, unsigned int keylen)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct device *dev = ctx->dev;\n\tint ret;\n\n\tret = aes_check_keylen(keylen - 4);\n\tif (ret)\n\t\treturn ret;\n\n\tprint_hex_dump_debug(\"key in @\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\n\n\tmemcpy(ctx->key, key, keylen);\n\t \n\tctx->cdata.keylen = keylen - 4;\n\tdma_sync_single_for_device(dev, ctx->key_dma, ctx->cdata.keylen,\n\t\t\t\t   ctx->dir);\n\n\treturn rfc4106_set_sh_desc(aead);\n}\n\nstatic int rfc4543_set_sh_desc(struct crypto_aead *aead)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct device *dev = ctx->dev;\n\tunsigned int ivsize = crypto_aead_ivsize(aead);\n\tstruct caam_flc *flc;\n\tu32 *desc;\n\tint rem_bytes = CAAM_DESC_BYTES_MAX - DESC_JOB_IO_LEN -\n\t\t\tctx->cdata.keylen;\n\n\tif (!ctx->cdata.keylen || !ctx->authsize)\n\t\treturn 0;\n\n\tctx->cdata.key_virt = ctx->key;\n\n\t \n\tif (rem_bytes >= DESC_QI_RFC4543_ENC_LEN) {\n\t\tctx->cdata.key_inline = true;\n\t} else {\n\t\tctx->cdata.key_inline = false;\n\t\tctx->cdata.key_dma = ctx->key_dma;\n\t}\n\n\tflc = &ctx->flc[ENCRYPT];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_rfc4543_encap(desc, &ctx->cdata, ivsize, ctx->authsize,\n\t\t\t\t  true);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[ENCRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\t \n\tif (rem_bytes >= DESC_QI_RFC4543_DEC_LEN) {\n\t\tctx->cdata.key_inline = true;\n\t} else {\n\t\tctx->cdata.key_inline = false;\n\t\tctx->cdata.key_dma = ctx->key_dma;\n\t}\n\n\tflc = &ctx->flc[DECRYPT];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_rfc4543_decap(desc, &ctx->cdata, ivsize, ctx->authsize,\n\t\t\t\t  true);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[DECRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\treturn 0;\n}\n\nstatic int rfc4543_setauthsize(struct crypto_aead *authenc,\n\t\t\t       unsigned int authsize)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(authenc);\n\n\tif (authsize != 16)\n\t\treturn -EINVAL;\n\n\tctx->authsize = authsize;\n\trfc4543_set_sh_desc(authenc);\n\n\treturn 0;\n}\n\nstatic int rfc4543_setkey(struct crypto_aead *aead,\n\t\t\t  const u8 *key, unsigned int keylen)\n{\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct device *dev = ctx->dev;\n\tint ret;\n\n\tret = aes_check_keylen(keylen - 4);\n\tif (ret)\n\t\treturn ret;\n\n\tprint_hex_dump_debug(\"key in @\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\n\n\tmemcpy(ctx->key, key, keylen);\n\t \n\tctx->cdata.keylen = keylen - 4;\n\tdma_sync_single_for_device(dev, ctx->key_dma, ctx->cdata.keylen,\n\t\t\t\t   ctx->dir);\n\n\treturn rfc4543_set_sh_desc(aead);\n}\n\nstatic int skcipher_setkey(struct crypto_skcipher *skcipher, const u8 *key,\n\t\t\t   unsigned int keylen, const u32 ctx1_iv_off)\n{\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(skcipher);\n\tstruct caam_skcipher_alg *alg =\n\t\tcontainer_of(crypto_skcipher_alg(skcipher),\n\t\t\t     struct caam_skcipher_alg, skcipher);\n\tstruct device *dev = ctx->dev;\n\tstruct caam_flc *flc;\n\tunsigned int ivsize = crypto_skcipher_ivsize(skcipher);\n\tu32 *desc;\n\tconst bool is_rfc3686 = alg->caam.rfc3686;\n\n\tprint_hex_dump_debug(\"key in @\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\n\n\tctx->cdata.keylen = keylen;\n\tctx->cdata.key_virt = key;\n\tctx->cdata.key_inline = true;\n\n\t \n\tflc = &ctx->flc[ENCRYPT];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_skcipher_encap(desc, &ctx->cdata, ivsize, is_rfc3686,\n\t\t\t\t   ctx1_iv_off);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[ENCRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\t \n\tflc = &ctx->flc[DECRYPT];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_skcipher_decap(desc, &ctx->cdata, ivsize, is_rfc3686,\n\t\t\t\t   ctx1_iv_off);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[DECRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\treturn 0;\n}\n\nstatic int aes_skcipher_setkey(struct crypto_skcipher *skcipher,\n\t\t\t       const u8 *key, unsigned int keylen)\n{\n\tint err;\n\n\terr = aes_check_keylen(keylen);\n\tif (err)\n\t\treturn err;\n\n\treturn skcipher_setkey(skcipher, key, keylen, 0);\n}\n\nstatic int rfc3686_skcipher_setkey(struct crypto_skcipher *skcipher,\n\t\t\t\t   const u8 *key, unsigned int keylen)\n{\n\tu32 ctx1_iv_off;\n\tint err;\n\n\t \n\tctx1_iv_off = 16 + CTR_RFC3686_NONCE_SIZE;\n\tkeylen -= CTR_RFC3686_NONCE_SIZE;\n\n\terr = aes_check_keylen(keylen);\n\tif (err)\n\t\treturn err;\n\n\treturn skcipher_setkey(skcipher, key, keylen, ctx1_iv_off);\n}\n\nstatic int ctr_skcipher_setkey(struct crypto_skcipher *skcipher,\n\t\t\t       const u8 *key, unsigned int keylen)\n{\n\tu32 ctx1_iv_off;\n\tint err;\n\n\t \n\tctx1_iv_off = 16;\n\n\terr = aes_check_keylen(keylen);\n\tif (err)\n\t\treturn err;\n\n\treturn skcipher_setkey(skcipher, key, keylen, ctx1_iv_off);\n}\n\nstatic int chacha20_skcipher_setkey(struct crypto_skcipher *skcipher,\n\t\t\t\t    const u8 *key, unsigned int keylen)\n{\n\tif (keylen != CHACHA_KEY_SIZE)\n\t\treturn -EINVAL;\n\n\treturn skcipher_setkey(skcipher, key, keylen, 0);\n}\n\nstatic int des_skcipher_setkey(struct crypto_skcipher *skcipher,\n\t\t\t       const u8 *key, unsigned int keylen)\n{\n\treturn verify_skcipher_des_key(skcipher, key) ?:\n\t       skcipher_setkey(skcipher, key, keylen, 0);\n}\n\nstatic int des3_skcipher_setkey(struct crypto_skcipher *skcipher,\n\t\t\t        const u8 *key, unsigned int keylen)\n{\n\treturn verify_skcipher_des3_key(skcipher, key) ?:\n\t       skcipher_setkey(skcipher, key, keylen, 0);\n}\n\nstatic int xts_skcipher_setkey(struct crypto_skcipher *skcipher, const u8 *key,\n\t\t\t       unsigned int keylen)\n{\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(skcipher);\n\tstruct device *dev = ctx->dev;\n\tstruct dpaa2_caam_priv *priv = dev_get_drvdata(dev);\n\tstruct caam_flc *flc;\n\tu32 *desc;\n\tint err;\n\n\terr = xts_verify_key(skcipher, key, keylen);\n\tif (err) {\n\t\tdev_dbg(dev, \"key size mismatch\\n\");\n\t\treturn err;\n\t}\n\n\tif (keylen != 2 * AES_KEYSIZE_128 && keylen != 2 * AES_KEYSIZE_256)\n\t\tctx->xts_key_fallback = true;\n\n\tif (priv->sec_attr.era <= 8 || ctx->xts_key_fallback) {\n\t\terr = crypto_skcipher_setkey(ctx->fallback, key, keylen);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tctx->cdata.keylen = keylen;\n\tctx->cdata.key_virt = key;\n\tctx->cdata.key_inline = true;\n\n\t \n\tflc = &ctx->flc[ENCRYPT];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_xts_skcipher_encap(desc, &ctx->cdata);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[ENCRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\t \n\tflc = &ctx->flc[DECRYPT];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_xts_skcipher_decap(desc, &ctx->cdata);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(dev, ctx->flc_dma[DECRYPT],\n\t\t\t\t   sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t\t   ctx->dir);\n\n\treturn 0;\n}\n\nstatic struct skcipher_edesc *skcipher_edesc_alloc(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tstruct caam_request *req_ctx = skcipher_request_ctx_dma(req);\n\tstruct dpaa2_fl_entry *in_fle = &req_ctx->fd_flt[1];\n\tstruct dpaa2_fl_entry *out_fle = &req_ctx->fd_flt[0];\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(skcipher);\n\tstruct device *dev = ctx->dev;\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t       GFP_KERNEL : GFP_ATOMIC;\n\tint src_nents, mapped_src_nents, dst_nents = 0, mapped_dst_nents = 0;\n\tstruct skcipher_edesc *edesc;\n\tdma_addr_t iv_dma;\n\tu8 *iv;\n\tint ivsize = crypto_skcipher_ivsize(skcipher);\n\tint dst_sg_idx, qm_sg_ents, qm_sg_bytes;\n\tstruct dpaa2_sg_entry *sg_table;\n\n\tsrc_nents = sg_nents_for_len(req->src, req->cryptlen);\n\tif (unlikely(src_nents < 0)) {\n\t\tdev_err(dev, \"Insufficient bytes (%d) in src S/G\\n\",\n\t\t\treq->cryptlen);\n\t\treturn ERR_PTR(src_nents);\n\t}\n\n\tif (unlikely(req->dst != req->src)) {\n\t\tdst_nents = sg_nents_for_len(req->dst, req->cryptlen);\n\t\tif (unlikely(dst_nents < 0)) {\n\t\t\tdev_err(dev, \"Insufficient bytes (%d) in dst S/G\\n\",\n\t\t\t\treq->cryptlen);\n\t\t\treturn ERR_PTR(dst_nents);\n\t\t}\n\n\t\tmapped_src_nents = dma_map_sg(dev, req->src, src_nents,\n\t\t\t\t\t      DMA_TO_DEVICE);\n\t\tif (unlikely(!mapped_src_nents)) {\n\t\t\tdev_err(dev, \"unable to map source\\n\");\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tmapped_dst_nents = dma_map_sg(dev, req->dst, dst_nents,\n\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\tif (unlikely(!mapped_dst_nents)) {\n\t\t\tdev_err(dev, \"unable to map destination\\n\");\n\t\t\tdma_unmap_sg(dev, req->src, src_nents, DMA_TO_DEVICE);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t} else {\n\t\tmapped_src_nents = dma_map_sg(dev, req->src, src_nents,\n\t\t\t\t\t      DMA_BIDIRECTIONAL);\n\t\tif (unlikely(!mapped_src_nents)) {\n\t\t\tdev_err(dev, \"unable to map source\\n\");\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\tqm_sg_ents = 1 + mapped_src_nents;\n\tdst_sg_idx = qm_sg_ents;\n\n\t \n\tif (req->src != req->dst)\n\t\tqm_sg_ents += pad_sg_nents(mapped_dst_nents + 1);\n\telse\n\t\tqm_sg_ents = 1 + pad_sg_nents(qm_sg_ents);\n\n\tqm_sg_bytes = qm_sg_ents * sizeof(struct dpaa2_sg_entry);\n\tif (unlikely(offsetof(struct skcipher_edesc, sgt) + qm_sg_bytes +\n\t\t     ivsize > CAAM_QI_MEMCACHE_SIZE)) {\n\t\tdev_err(dev, \"No space for %d S/G entries and/or %dB IV\\n\",\n\t\t\tqm_sg_ents, ivsize);\n\t\tcaam_unmap(dev, req->src, req->dst, src_nents, dst_nents, 0,\n\t\t\t   0, DMA_NONE, 0, 0);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tedesc = qi_cache_zalloc(flags);\n\tif (unlikely(!edesc)) {\n\t\tdev_err(dev, \"could not allocate extended descriptor\\n\");\n\t\tcaam_unmap(dev, req->src, req->dst, src_nents, dst_nents, 0,\n\t\t\t   0, DMA_NONE, 0, 0);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tsg_table = &edesc->sgt[0];\n\tiv = (u8 *)(sg_table + qm_sg_ents);\n\tmemcpy(iv, req->iv, ivsize);\n\n\tiv_dma = dma_map_single(dev, iv, ivsize, DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dev, iv_dma)) {\n\t\tdev_err(dev, \"unable to map IV\\n\");\n\t\tcaam_unmap(dev, req->src, req->dst, src_nents, dst_nents, 0,\n\t\t\t   0, DMA_NONE, 0, 0);\n\t\tqi_cache_free(edesc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tedesc->src_nents = src_nents;\n\tedesc->dst_nents = dst_nents;\n\tedesc->iv_dma = iv_dma;\n\tedesc->qm_sg_bytes = qm_sg_bytes;\n\n\tdma_to_qm_sg_one(sg_table, iv_dma, ivsize, 0);\n\tsg_to_qm_sg(req->src, req->cryptlen, sg_table + 1, 0);\n\n\tif (req->src != req->dst)\n\t\tsg_to_qm_sg(req->dst, req->cryptlen, sg_table + dst_sg_idx, 0);\n\n\tdma_to_qm_sg_one(sg_table + dst_sg_idx + mapped_dst_nents, iv_dma,\n\t\t\t ivsize, 0);\n\n\tedesc->qm_sg_dma = dma_map_single(dev, sg_table, edesc->qm_sg_bytes,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, edesc->qm_sg_dma)) {\n\t\tdev_err(dev, \"unable to map S/G table\\n\");\n\t\tcaam_unmap(dev, req->src, req->dst, src_nents, dst_nents,\n\t\t\t   iv_dma, ivsize, DMA_BIDIRECTIONAL, 0, 0);\n\t\tqi_cache_free(edesc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tmemset(&req_ctx->fd_flt, 0, sizeof(req_ctx->fd_flt));\n\tdpaa2_fl_set_final(in_fle, true);\n\tdpaa2_fl_set_len(in_fle, req->cryptlen + ivsize);\n\tdpaa2_fl_set_len(out_fle, req->cryptlen + ivsize);\n\n\tdpaa2_fl_set_format(in_fle, dpaa2_fl_sg);\n\tdpaa2_fl_set_addr(in_fle, edesc->qm_sg_dma);\n\n\tdpaa2_fl_set_format(out_fle, dpaa2_fl_sg);\n\n\tif (req->src == req->dst)\n\t\tdpaa2_fl_set_addr(out_fle, edesc->qm_sg_dma +\n\t\t\t\t  sizeof(*sg_table));\n\telse\n\t\tdpaa2_fl_set_addr(out_fle, edesc->qm_sg_dma + dst_sg_idx *\n\t\t\t\t  sizeof(*sg_table));\n\n\treturn edesc;\n}\n\nstatic void aead_unmap(struct device *dev, struct aead_edesc *edesc,\n\t\t       struct aead_request *req)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tint ivsize = crypto_aead_ivsize(aead);\n\n\tcaam_unmap(dev, req->src, req->dst, edesc->src_nents, edesc->dst_nents,\n\t\t   edesc->iv_dma, ivsize, DMA_TO_DEVICE, edesc->qm_sg_dma,\n\t\t   edesc->qm_sg_bytes);\n\tdma_unmap_single(dev, edesc->assoclen_dma, 4, DMA_TO_DEVICE);\n}\n\nstatic void skcipher_unmap(struct device *dev, struct skcipher_edesc *edesc,\n\t\t\t   struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tint ivsize = crypto_skcipher_ivsize(skcipher);\n\n\tcaam_unmap(dev, req->src, req->dst, edesc->src_nents, edesc->dst_nents,\n\t\t   edesc->iv_dma, ivsize, DMA_BIDIRECTIONAL, edesc->qm_sg_dma,\n\t\t   edesc->qm_sg_bytes);\n}\n\nstatic void aead_encrypt_done(void *cbk_ctx, u32 status)\n{\n\tstruct crypto_async_request *areq = cbk_ctx;\n\tstruct aead_request *req = container_of(areq, struct aead_request,\n\t\t\t\t\t\tbase);\n\tstruct caam_request *req_ctx = to_caam_req(areq);\n\tstruct aead_edesc *edesc = req_ctx->edesc;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tint ecode = 0;\n\n\tdev_dbg(ctx->dev, \"%s %d: err 0x%x\\n\", __func__, __LINE__, status);\n\n\tif (unlikely(status))\n\t\tecode = caam_qi2_strstatus(ctx->dev, status);\n\n\taead_unmap(ctx->dev, edesc, req);\n\tqi_cache_free(edesc);\n\taead_request_complete(req, ecode);\n}\n\nstatic void aead_decrypt_done(void *cbk_ctx, u32 status)\n{\n\tstruct crypto_async_request *areq = cbk_ctx;\n\tstruct aead_request *req = container_of(areq, struct aead_request,\n\t\t\t\t\t\tbase);\n\tstruct caam_request *req_ctx = to_caam_req(areq);\n\tstruct aead_edesc *edesc = req_ctx->edesc;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tint ecode = 0;\n\n\tdev_dbg(ctx->dev, \"%s %d: err 0x%x\\n\", __func__, __LINE__, status);\n\n\tif (unlikely(status))\n\t\tecode = caam_qi2_strstatus(ctx->dev, status);\n\n\taead_unmap(ctx->dev, edesc, req);\n\tqi_cache_free(edesc);\n\taead_request_complete(req, ecode);\n}\n\nstatic int aead_encrypt(struct aead_request *req)\n{\n\tstruct aead_edesc *edesc;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct caam_request *caam_req = aead_request_ctx_dma(req);\n\tint ret;\n\n\t \n\tedesc = aead_edesc_alloc(req, true);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\tcaam_req->flc = &ctx->flc[ENCRYPT];\n\tcaam_req->flc_dma = ctx->flc_dma[ENCRYPT];\n\tcaam_req->cbk = aead_encrypt_done;\n\tcaam_req->ctx = &req->base;\n\tcaam_req->edesc = edesc;\n\tret = dpaa2_caam_enqueue(ctx->dev, caam_req);\n\tif (ret != -EINPROGRESS &&\n\t    !(ret == -EBUSY && req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)) {\n\t\taead_unmap(ctx->dev, edesc, req);\n\t\tqi_cache_free(edesc);\n\t}\n\n\treturn ret;\n}\n\nstatic int aead_decrypt(struct aead_request *req)\n{\n\tstruct aead_edesc *edesc;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct caam_ctx *ctx = crypto_aead_ctx_dma(aead);\n\tstruct caam_request *caam_req = aead_request_ctx_dma(req);\n\tint ret;\n\n\t \n\tedesc = aead_edesc_alloc(req, false);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\tcaam_req->flc = &ctx->flc[DECRYPT];\n\tcaam_req->flc_dma = ctx->flc_dma[DECRYPT];\n\tcaam_req->cbk = aead_decrypt_done;\n\tcaam_req->ctx = &req->base;\n\tcaam_req->edesc = edesc;\n\tret = dpaa2_caam_enqueue(ctx->dev, caam_req);\n\tif (ret != -EINPROGRESS &&\n\t    !(ret == -EBUSY && req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)) {\n\t\taead_unmap(ctx->dev, edesc, req);\n\t\tqi_cache_free(edesc);\n\t}\n\n\treturn ret;\n}\n\nstatic int ipsec_gcm_encrypt(struct aead_request *req)\n{\n\treturn crypto_ipsec_check_assoclen(req->assoclen) ? : aead_encrypt(req);\n}\n\nstatic int ipsec_gcm_decrypt(struct aead_request *req)\n{\n\treturn crypto_ipsec_check_assoclen(req->assoclen) ? : aead_decrypt(req);\n}\n\nstatic void skcipher_encrypt_done(void *cbk_ctx, u32 status)\n{\n\tstruct crypto_async_request *areq = cbk_ctx;\n\tstruct skcipher_request *req = skcipher_request_cast(areq);\n\tstruct caam_request *req_ctx = to_caam_req(areq);\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(skcipher);\n\tstruct skcipher_edesc *edesc = req_ctx->edesc;\n\tint ecode = 0;\n\tint ivsize = crypto_skcipher_ivsize(skcipher);\n\n\tdev_dbg(ctx->dev, \"%s %d: err 0x%x\\n\", __func__, __LINE__, status);\n\n\tif (unlikely(status))\n\t\tecode = caam_qi2_strstatus(ctx->dev, status);\n\n\tprint_hex_dump_debug(\"dstiv  @\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, req->iv,\n\t\t\t     edesc->src_nents > 1 ? 100 : ivsize, 1);\n\tcaam_dump_sg(\"dst    @\" __stringify(__LINE__)\": \",\n\t\t     DUMP_PREFIX_ADDRESS, 16, 4, req->dst,\n\t\t     edesc->dst_nents > 1 ? 100 : req->cryptlen, 1);\n\n\tskcipher_unmap(ctx->dev, edesc, req);\n\n\t \n\tif (!ecode)\n\t\tmemcpy(req->iv, (u8 *)&edesc->sgt[0] + edesc->qm_sg_bytes,\n\t\t       ivsize);\n\n\tqi_cache_free(edesc);\n\tskcipher_request_complete(req, ecode);\n}\n\nstatic void skcipher_decrypt_done(void *cbk_ctx, u32 status)\n{\n\tstruct crypto_async_request *areq = cbk_ctx;\n\tstruct skcipher_request *req = skcipher_request_cast(areq);\n\tstruct caam_request *req_ctx = to_caam_req(areq);\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(skcipher);\n\tstruct skcipher_edesc *edesc = req_ctx->edesc;\n\tint ecode = 0;\n\tint ivsize = crypto_skcipher_ivsize(skcipher);\n\n\tdev_dbg(ctx->dev, \"%s %d: err 0x%x\\n\", __func__, __LINE__, status);\n\n\tif (unlikely(status))\n\t\tecode = caam_qi2_strstatus(ctx->dev, status);\n\n\tprint_hex_dump_debug(\"dstiv  @\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, req->iv,\n\t\t\t     edesc->src_nents > 1 ? 100 : ivsize, 1);\n\tcaam_dump_sg(\"dst    @\" __stringify(__LINE__)\": \",\n\t\t     DUMP_PREFIX_ADDRESS, 16, 4, req->dst,\n\t\t     edesc->dst_nents > 1 ? 100 : req->cryptlen, 1);\n\n\tskcipher_unmap(ctx->dev, edesc, req);\n\n\t \n\tif (!ecode)\n\t\tmemcpy(req->iv, (u8 *)&edesc->sgt[0] + edesc->qm_sg_bytes,\n\t\t       ivsize);\n\n\tqi_cache_free(edesc);\n\tskcipher_request_complete(req, ecode);\n}\n\nstatic inline bool xts_skcipher_ivsize(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tunsigned int ivsize = crypto_skcipher_ivsize(skcipher);\n\n\treturn !!get_unaligned((u64 *)(req->iv + (ivsize / 2)));\n}\n\nstatic int skcipher_encrypt(struct skcipher_request *req)\n{\n\tstruct skcipher_edesc *edesc;\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(skcipher);\n\tstruct caam_request *caam_req = skcipher_request_ctx_dma(req);\n\tstruct dpaa2_caam_priv *priv = dev_get_drvdata(ctx->dev);\n\tint ret;\n\n\t \n\tif (!req->cryptlen && !ctx->fallback)\n\t\treturn 0;\n\n\tif (ctx->fallback && ((priv->sec_attr.era <= 8 && xts_skcipher_ivsize(req)) ||\n\t\t\t      ctx->xts_key_fallback)) {\n\t\tskcipher_request_set_tfm(&caam_req->fallback_req, ctx->fallback);\n\t\tskcipher_request_set_callback(&caam_req->fallback_req,\n\t\t\t\t\t      req->base.flags,\n\t\t\t\t\t      req->base.complete,\n\t\t\t\t\t      req->base.data);\n\t\tskcipher_request_set_crypt(&caam_req->fallback_req, req->src,\n\t\t\t\t\t   req->dst, req->cryptlen, req->iv);\n\n\t\treturn crypto_skcipher_encrypt(&caam_req->fallback_req);\n\t}\n\n\t \n\tedesc = skcipher_edesc_alloc(req);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\tcaam_req->flc = &ctx->flc[ENCRYPT];\n\tcaam_req->flc_dma = ctx->flc_dma[ENCRYPT];\n\tcaam_req->cbk = skcipher_encrypt_done;\n\tcaam_req->ctx = &req->base;\n\tcaam_req->edesc = edesc;\n\tret = dpaa2_caam_enqueue(ctx->dev, caam_req);\n\tif (ret != -EINPROGRESS &&\n\t    !(ret == -EBUSY && req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)) {\n\t\tskcipher_unmap(ctx->dev, edesc, req);\n\t\tqi_cache_free(edesc);\n\t}\n\n\treturn ret;\n}\n\nstatic int skcipher_decrypt(struct skcipher_request *req)\n{\n\tstruct skcipher_edesc *edesc;\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(skcipher);\n\tstruct caam_request *caam_req = skcipher_request_ctx_dma(req);\n\tstruct dpaa2_caam_priv *priv = dev_get_drvdata(ctx->dev);\n\tint ret;\n\n\t \n\tif (!req->cryptlen && !ctx->fallback)\n\t\treturn 0;\n\n\tif (ctx->fallback && ((priv->sec_attr.era <= 8 && xts_skcipher_ivsize(req)) ||\n\t\t\t      ctx->xts_key_fallback)) {\n\t\tskcipher_request_set_tfm(&caam_req->fallback_req, ctx->fallback);\n\t\tskcipher_request_set_callback(&caam_req->fallback_req,\n\t\t\t\t\t      req->base.flags,\n\t\t\t\t\t      req->base.complete,\n\t\t\t\t\t      req->base.data);\n\t\tskcipher_request_set_crypt(&caam_req->fallback_req, req->src,\n\t\t\t\t\t   req->dst, req->cryptlen, req->iv);\n\n\t\treturn crypto_skcipher_decrypt(&caam_req->fallback_req);\n\t}\n\n\t \n\tedesc = skcipher_edesc_alloc(req);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\tcaam_req->flc = &ctx->flc[DECRYPT];\n\tcaam_req->flc_dma = ctx->flc_dma[DECRYPT];\n\tcaam_req->cbk = skcipher_decrypt_done;\n\tcaam_req->ctx = &req->base;\n\tcaam_req->edesc = edesc;\n\tret = dpaa2_caam_enqueue(ctx->dev, caam_req);\n\tif (ret != -EINPROGRESS &&\n\t    !(ret == -EBUSY && req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)) {\n\t\tskcipher_unmap(ctx->dev, edesc, req);\n\t\tqi_cache_free(edesc);\n\t}\n\n\treturn ret;\n}\n\nstatic int caam_cra_init(struct caam_ctx *ctx, struct caam_alg_entry *caam,\n\t\t\t bool uses_dkp)\n{\n\tdma_addr_t dma_addr;\n\tint i;\n\n\t \n\tctx->cdata.algtype = OP_TYPE_CLASS1_ALG | caam->class1_alg_type;\n\tctx->adata.algtype = OP_TYPE_CLASS2_ALG | caam->class2_alg_type;\n\n\tctx->dev = caam->dev;\n\tctx->dir = uses_dkp ? DMA_BIDIRECTIONAL : DMA_TO_DEVICE;\n\n\tdma_addr = dma_map_single_attrs(ctx->dev, ctx->flc,\n\t\t\t\t\toffsetof(struct caam_ctx, flc_dma),\n\t\t\t\t\tctx->dir, DMA_ATTR_SKIP_CPU_SYNC);\n\tif (dma_mapping_error(ctx->dev, dma_addr)) {\n\t\tdev_err(ctx->dev, \"unable to map key, shared descriptors\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < NUM_OP; i++)\n\t\tctx->flc_dma[i] = dma_addr + i * sizeof(ctx->flc[i]);\n\tctx->key_dma = dma_addr + NUM_OP * sizeof(ctx->flc[0]);\n\n\treturn 0;\n}\n\nstatic int caam_cra_init_skcipher(struct crypto_skcipher *tfm)\n{\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(tfm);\n\tstruct caam_skcipher_alg *caam_alg =\n\t\tcontainer_of(alg, typeof(*caam_alg), skcipher);\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(tfm);\n\tu32 alg_aai = caam_alg->caam.class1_alg_type & OP_ALG_AAI_MASK;\n\tint ret = 0;\n\n\tif (alg_aai == OP_ALG_AAI_XTS) {\n\t\tconst char *tfm_name = crypto_tfm_alg_name(&tfm->base);\n\t\tstruct crypto_skcipher *fallback;\n\n\t\tfallback = crypto_alloc_skcipher(tfm_name, 0,\n\t\t\t\t\t\t CRYPTO_ALG_NEED_FALLBACK);\n\t\tif (IS_ERR(fallback)) {\n\t\t\tdev_err(caam_alg->caam.dev,\n\t\t\t\t\"Failed to allocate %s fallback: %ld\\n\",\n\t\t\t\ttfm_name, PTR_ERR(fallback));\n\t\t\treturn PTR_ERR(fallback);\n\t\t}\n\n\t\tctx->fallback = fallback;\n\t\tcrypto_skcipher_set_reqsize_dma(\n\t\t\ttfm, sizeof(struct caam_request) +\n\t\t\t     crypto_skcipher_reqsize(fallback));\n\t} else {\n\t\tcrypto_skcipher_set_reqsize_dma(tfm,\n\t\t\t\t\t\tsizeof(struct caam_request));\n\t}\n\n\tret = caam_cra_init(ctx, &caam_alg->caam, false);\n\tif (ret && ctx->fallback)\n\t\tcrypto_free_skcipher(ctx->fallback);\n\n\treturn ret;\n}\n\nstatic int caam_cra_init_aead(struct crypto_aead *tfm)\n{\n\tstruct aead_alg *alg = crypto_aead_alg(tfm);\n\tstruct caam_aead_alg *caam_alg = container_of(alg, typeof(*caam_alg),\n\t\t\t\t\t\t      aead);\n\n\tcrypto_aead_set_reqsize_dma(tfm, sizeof(struct caam_request));\n\treturn caam_cra_init(crypto_aead_ctx_dma(tfm), &caam_alg->caam,\n\t\t\t     !caam_alg->caam.nodkp);\n}\n\nstatic void caam_exit_common(struct caam_ctx *ctx)\n{\n\tdma_unmap_single_attrs(ctx->dev, ctx->flc_dma[0],\n\t\t\t       offsetof(struct caam_ctx, flc_dma), ctx->dir,\n\t\t\t       DMA_ATTR_SKIP_CPU_SYNC);\n}\n\nstatic void caam_cra_exit(struct crypto_skcipher *tfm)\n{\n\tstruct caam_ctx *ctx = crypto_skcipher_ctx_dma(tfm);\n\n\tif (ctx->fallback)\n\t\tcrypto_free_skcipher(ctx->fallback);\n\tcaam_exit_common(ctx);\n}\n\nstatic void caam_cra_exit_aead(struct crypto_aead *tfm)\n{\n\tcaam_exit_common(crypto_aead_ctx_dma(tfm));\n}\n\nstatic struct caam_skcipher_alg driver_algs[] = {\n\t{\n\t\t.skcipher = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"cbc(aes)\",\n\t\t\t\t.cra_driver_name = \"cbc-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aes_skcipher_setkey,\n\t\t\t.encrypt = skcipher_encrypt,\n\t\t\t.decrypt = skcipher_decrypt,\n\t\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t},\n\t{\n\t\t.skcipher = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"cbc(des3_ede)\",\n\t\t\t\t.cra_driver_name = \"cbc-3des-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_skcipher_setkey,\n\t\t\t.encrypt = skcipher_encrypt,\n\t\t\t.decrypt = skcipher_decrypt,\n\t\t\t.min_keysize = DES3_EDE_KEY_SIZE,\n\t\t\t.max_keysize = DES3_EDE_KEY_SIZE,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t},\n\t\t.caam.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t},\n\t{\n\t\t.skcipher = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"cbc(des)\",\n\t\t\t\t.cra_driver_name = \"cbc-des-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des_skcipher_setkey,\n\t\t\t.encrypt = skcipher_encrypt,\n\t\t\t.decrypt = skcipher_decrypt,\n\t\t\t.min_keysize = DES_KEY_SIZE,\n\t\t\t.max_keysize = DES_KEY_SIZE,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t},\n\t\t.caam.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t},\n\t{\n\t\t.skcipher = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"ctr(aes)\",\n\t\t\t\t.cra_driver_name = \"ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = ctr_skcipher_setkey,\n\t\t\t.encrypt = skcipher_encrypt,\n\t\t\t.decrypt = skcipher_decrypt,\n\t\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.chunksize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\tOP_ALG_AAI_CTR_MOD128,\n\t},\n\t{\n\t\t.skcipher = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"rfc3686(ctr(aes))\",\n\t\t\t\t.cra_driver_name = \"rfc3686-ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = rfc3686_skcipher_setkey,\n\t\t\t.encrypt = skcipher_encrypt,\n\t\t\t.decrypt = skcipher_decrypt,\n\t\t\t.min_keysize = AES_MIN_KEY_SIZE +\n\t\t\t\t       CTR_RFC3686_NONCE_SIZE,\n\t\t\t.max_keysize = AES_MAX_KEY_SIZE +\n\t\t\t\t       CTR_RFC3686_NONCE_SIZE,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.chunksize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.rfc3686 = true,\n\t\t},\n\t},\n\t{\n\t\t.skcipher = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"xts(aes)\",\n\t\t\t\t.cra_driver_name = \"xts-aes-caam-qi2\",\n\t\t\t\t.cra_flags = CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = xts_skcipher_setkey,\n\t\t\t.encrypt = skcipher_encrypt,\n\t\t\t.decrypt = skcipher_decrypt,\n\t\t\t.min_keysize = 2 * AES_MIN_KEY_SIZE,\n\t\t\t.max_keysize = 2 * AES_MAX_KEY_SIZE,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_XTS,\n\t},\n\t{\n\t\t.skcipher = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"chacha20\",\n\t\t\t\t.cra_driver_name = \"chacha20-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = chacha20_skcipher_setkey,\n\t\t\t.encrypt = skcipher_encrypt,\n\t\t\t.decrypt = skcipher_decrypt,\n\t\t\t.min_keysize = CHACHA_KEY_SIZE,\n\t\t\t.max_keysize = CHACHA_KEY_SIZE,\n\t\t\t.ivsize = CHACHA_IV_SIZE,\n\t\t},\n\t\t.caam.class1_alg_type = OP_ALG_ALGSEL_CHACHA20,\n\t},\n};\n\nstatic struct caam_aead_alg driver_aeads[] = {\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"rfc4106(gcm(aes))\",\n\t\t\t\t.cra_driver_name = \"rfc4106-gcm-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = rfc4106_setkey,\n\t\t\t.setauthsize = rfc4106_setauthsize,\n\t\t\t.encrypt = ipsec_gcm_encrypt,\n\t\t\t.decrypt = ipsec_gcm_decrypt,\n\t\t\t.ivsize = 8,\n\t\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_GCM,\n\t\t\t.nodkp = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"rfc4543(gcm(aes))\",\n\t\t\t\t.cra_driver_name = \"rfc4543-gcm-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = rfc4543_setkey,\n\t\t\t.setauthsize = rfc4543_setauthsize,\n\t\t\t.encrypt = ipsec_gcm_encrypt,\n\t\t\t.decrypt = ipsec_gcm_decrypt,\n\t\t\t.ivsize = 8,\n\t\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_GCM,\n\t\t\t.nodkp = true,\n\t\t},\n\t},\n\t \n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"gcm(aes)\",\n\t\t\t\t.cra_driver_name = \"gcm-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = gcm_setkey,\n\t\t\t.setauthsize = gcm_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = 12,\n\t\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_GCM,\n\t\t\t.nodkp = true,\n\t\t}\n\t},\n\t \n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(md5),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(md5),\"\n\t\t\t\t\t    \"cbc(aes)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha1),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha1-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha1),\"\n\t\t\t\t\t    \"cbc(aes)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha1-cbc-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha224),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha224-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha224),\"\n\t\t\t\t\t    \"cbc(aes)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha224-cbc-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha256),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha256-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha256),\"\n\t\t\t\t\t    \"cbc(aes)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha256-cbc-aes-\"\n\t\t\t\t\t\t   \"caam-qi2\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha384),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha384-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha384),\"\n\t\t\t\t\t    \"cbc(aes)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha384-cbc-aes-\"\n\t\t\t\t\t\t   \"caam-qi2\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha512),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha512-\"\n\t\t\t\t\t\t   \"cbc-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha512),\"\n\t\t\t\t\t    \"cbc(aes)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha512-cbc-aes-\"\n\t\t\t\t\t\t   \"caam-qi2\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(md5),cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(md5),\"\n\t\t\t\t\t    \"cbc(des3_ede)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha1),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha1-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha1),\"\n\t\t\t\t\t    \"cbc(des3_ede)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha1-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha224),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha224-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha224),\"\n\t\t\t\t\t    \"cbc(des3_ede)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha224-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha256),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha256-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha256),\"\n\t\t\t\t\t    \"cbc(des3_ede)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha256-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha384),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha384-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha384),\"\n\t\t\t\t\t    \"cbc(des3_ede)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha384-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha512),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha512-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha512),\"\n\t\t\t\t\t    \"cbc(des3_ede)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha512-\"\n\t\t\t\t\t\t   \"cbc-des3_ede-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = des3_aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(md5),cbc(des))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(md5),\"\n\t\t\t\t\t    \"cbc(des)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha1),cbc(des))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha1-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha1),\"\n\t\t\t\t\t    \"cbc(des)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha1-cbc-des-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha224),cbc(des))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha224-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha224),\"\n\t\t\t\t\t    \"cbc(des)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha224-cbc-des-\"\n\t\t\t\t\t\t   \"caam-qi2\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha256),cbc(des))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha256-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha256),\"\n\t\t\t\t\t    \"cbc(des)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha256-cbc-des-\"\n\t\t\t\t\t\t   \"caam-qi2\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha384),cbc(des))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha384-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha384),\"\n\t\t\t\t\t    \"cbc(des)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha384-cbc-des-\"\n\t\t\t\t\t\t   \"caam-qi2\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha512),cbc(des))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha512-\"\n\t\t\t\t\t\t   \"cbc-des-caam-qi2\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"echainiv(authenc(hmac(sha512),\"\n\t\t\t\t\t    \"cbc(des)))\",\n\t\t\t\t.cra_driver_name = \"echainiv-authenc-\"\n\t\t\t\t\t\t   \"hmac-sha512-cbc-des-\"\n\t\t\t\t\t\t   \"caam-qi2\",\n\t\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.geniv = true,\n\t\t}\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(md5),\"\n\t\t\t\t\t    \"rfc3686(ctr(aes)))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"rfc3686-ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.rfc3686 = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"seqiv(authenc(\"\n\t\t\t\t\t    \"hmac(md5),rfc3686(ctr(aes))))\",\n\t\t\t\t.cra_driver_name = \"seqiv-authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"rfc3686-ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_MD5 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.rfc3686 = true,\n\t\t\t.geniv = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha1),\"\n\t\t\t\t\t    \"rfc3686(ctr(aes)))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha1-\"\n\t\t\t\t\t\t   \"rfc3686-ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.rfc3686 = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"seqiv(authenc(\"\n\t\t\t\t\t    \"hmac(sha1),rfc3686(ctr(aes))))\",\n\t\t\t\t.cra_driver_name = \"seqiv-authenc-hmac-sha1-\"\n\t\t\t\t\t\t   \"rfc3686-ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA1 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.rfc3686 = true,\n\t\t\t.geniv = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha224),\"\n\t\t\t\t\t    \"rfc3686(ctr(aes)))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha224-\"\n\t\t\t\t\t\t   \"rfc3686-ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.rfc3686 = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"seqiv(authenc(\"\n\t\t\t\t\t    \"hmac(sha224),rfc3686(ctr(aes))))\",\n\t\t\t\t.cra_driver_name = \"seqiv-authenc-hmac-sha224-\"\n\t\t\t\t\t\t   \"rfc3686-ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA224 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.rfc3686 = true,\n\t\t\t.geniv = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha256),\"\n\t\t\t\t\t    \"rfc3686(ctr(aes)))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha256-\"\n\t\t\t\t\t\t   \"rfc3686-ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.rfc3686 = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"seqiv(authenc(hmac(sha256),\"\n\t\t\t\t\t    \"rfc3686(ctr(aes))))\",\n\t\t\t\t.cra_driver_name = \"seqiv-authenc-hmac-sha256-\"\n\t\t\t\t\t\t   \"rfc3686-ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA256 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.rfc3686 = true,\n\t\t\t.geniv = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha384),\"\n\t\t\t\t\t    \"rfc3686(ctr(aes)))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha384-\"\n\t\t\t\t\t\t   \"rfc3686-ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.rfc3686 = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"seqiv(authenc(hmac(sha384),\"\n\t\t\t\t\t    \"rfc3686(ctr(aes))))\",\n\t\t\t\t.cra_driver_name = \"seqiv-authenc-hmac-sha384-\"\n\t\t\t\t\t\t   \"rfc3686-ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA384 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.rfc3686 = true,\n\t\t\t.geniv = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"rfc7539(chacha20,poly1305)\",\n\t\t\t\t.cra_driver_name = \"rfc7539-chacha20-poly1305-\"\n\t\t\t\t\t\t   \"caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = chachapoly_setkey,\n\t\t\t.setauthsize = chachapoly_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = CHACHAPOLY_IV_SIZE,\n\t\t\t.maxauthsize = POLY1305_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_CHACHA20 |\n\t\t\t\t\t   OP_ALG_AAI_AEAD,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_POLY1305 |\n\t\t\t\t\t   OP_ALG_AAI_AEAD,\n\t\t\t.nodkp = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"rfc7539esp(chacha20,poly1305)\",\n\t\t\t\t.cra_driver_name = \"rfc7539esp-chacha20-\"\n\t\t\t\t\t\t   \"poly1305-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = chachapoly_setkey,\n\t\t\t.setauthsize = chachapoly_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = 8,\n\t\t\t.maxauthsize = POLY1305_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_CHACHA20 |\n\t\t\t\t\t   OP_ALG_AAI_AEAD,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_POLY1305 |\n\t\t\t\t\t   OP_ALG_AAI_AEAD,\n\t\t\t.nodkp = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha512),\"\n\t\t\t\t\t    \"rfc3686(ctr(aes)))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha512-\"\n\t\t\t\t\t\t   \"rfc3686-ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.rfc3686 = true,\n\t\t},\n\t},\n\t{\n\t\t.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"seqiv(authenc(hmac(sha512),\"\n\t\t\t\t\t    \"rfc3686(ctr(aes))))\",\n\t\t\t\t.cra_driver_name = \"seqiv-authenc-hmac-sha512-\"\n\t\t\t\t\t\t   \"rfc3686-ctr-aes-caam-qi2\",\n\t\t\t\t.cra_blocksize = 1,\n\t\t\t},\n\t\t\t.setkey = aead_setkey,\n\t\t\t.setauthsize = aead_setauthsize,\n\t\t\t.encrypt = aead_encrypt,\n\t\t\t.decrypt = aead_decrypt,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.caam = {\n\t\t\t.class1_alg_type = OP_ALG_ALGSEL_AES |\n\t\t\t\t\t   OP_ALG_AAI_CTR_MOD128,\n\t\t\t.class2_alg_type = OP_ALG_ALGSEL_SHA512 |\n\t\t\t\t\t   OP_ALG_AAI_HMAC_PRECOMP,\n\t\t\t.rfc3686 = true,\n\t\t\t.geniv = true,\n\t\t},\n\t},\n};\n\nstatic void caam_skcipher_alg_init(struct caam_skcipher_alg *t_alg)\n{\n\tstruct skcipher_alg *alg = &t_alg->skcipher;\n\n\talg->base.cra_module = THIS_MODULE;\n\talg->base.cra_priority = CAAM_CRA_PRIORITY;\n\talg->base.cra_ctxsize = sizeof(struct caam_ctx) + crypto_dma_padding();\n\talg->base.cra_flags |= (CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t      CRYPTO_ALG_KERN_DRIVER_ONLY);\n\n\talg->init = caam_cra_init_skcipher;\n\talg->exit = caam_cra_exit;\n}\n\nstatic void caam_aead_alg_init(struct caam_aead_alg *t_alg)\n{\n\tstruct aead_alg *alg = &t_alg->aead;\n\n\talg->base.cra_module = THIS_MODULE;\n\talg->base.cra_priority = CAAM_CRA_PRIORITY;\n\talg->base.cra_ctxsize = sizeof(struct caam_ctx) + crypto_dma_padding();\n\talg->base.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t      CRYPTO_ALG_KERN_DRIVER_ONLY;\n\n\talg->init = caam_cra_init_aead;\n\talg->exit = caam_cra_exit_aead;\n}\n\n \n#define CAAM_MAX_HASH_KEY_SIZE\t\t(SHA512_DIGEST_SIZE * 2)\n\n#define CAAM_MAX_HASH_BLOCK_SIZE\tSHA512_BLOCK_SIZE\n\n \n#define HASH_MSG_LEN\t\t\t8\n#define MAX_CTX_LEN\t\t\t(HASH_MSG_LEN + SHA512_DIGEST_SIZE)\n\nenum hash_optype {\n\tUPDATE = 0,\n\tUPDATE_FIRST,\n\tFINALIZE,\n\tDIGEST,\n\tHASH_NUM_OP\n};\n\n \nstruct caam_hash_ctx {\n\tstruct caam_flc flc[HASH_NUM_OP];\n\tu8 key[CAAM_MAX_HASH_BLOCK_SIZE] ____cacheline_aligned;\n\tdma_addr_t flc_dma[HASH_NUM_OP];\n\tstruct device *dev;\n\tint ctx_len;\n\tstruct alginfo adata;\n};\n\n \nstruct caam_hash_state {\n\tstruct caam_request caam_req;\n\tdma_addr_t buf_dma;\n\tdma_addr_t ctx_dma;\n\tint ctx_dma_len;\n\tu8 buf[CAAM_MAX_HASH_BLOCK_SIZE] ____cacheline_aligned;\n\tint buflen;\n\tint next_buflen;\n\tu8 caam_ctx[MAX_CTX_LEN] ____cacheline_aligned;\n\tint (*update)(struct ahash_request *req);\n\tint (*final)(struct ahash_request *req);\n\tint (*finup)(struct ahash_request *req);\n};\n\nstruct caam_export_state {\n\tu8 buf[CAAM_MAX_HASH_BLOCK_SIZE];\n\tu8 caam_ctx[MAX_CTX_LEN];\n\tint buflen;\n\tint (*update)(struct ahash_request *req);\n\tint (*final)(struct ahash_request *req);\n\tint (*finup)(struct ahash_request *req);\n};\n\n \nstatic inline int buf_map_to_qm_sg(struct device *dev,\n\t\t\t\t   struct dpaa2_sg_entry *qm_sg,\n\t\t\t\t   struct caam_hash_state *state)\n{\n\tint buflen = state->buflen;\n\n\tif (!buflen)\n\t\treturn 0;\n\n\tstate->buf_dma = dma_map_single(dev, state->buf, buflen,\n\t\t\t\t\tDMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, state->buf_dma)) {\n\t\tdev_err(dev, \"unable to map buf\\n\");\n\t\tstate->buf_dma = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tdma_to_qm_sg_one(qm_sg, state->buf_dma, buflen, 0);\n\n\treturn 0;\n}\n\n \nstatic inline int ctx_map_to_qm_sg(struct device *dev,\n\t\t\t\t   struct caam_hash_state *state, int ctx_len,\n\t\t\t\t   struct dpaa2_sg_entry *qm_sg, u32 flag)\n{\n\tstate->ctx_dma_len = ctx_len;\n\tstate->ctx_dma = dma_map_single(dev, state->caam_ctx, ctx_len, flag);\n\tif (dma_mapping_error(dev, state->ctx_dma)) {\n\t\tdev_err(dev, \"unable to map ctx\\n\");\n\t\tstate->ctx_dma = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tdma_to_qm_sg_one(qm_sg, state->ctx_dma, ctx_len, 0);\n\n\treturn 0;\n}\n\nstatic int ahash_set_sh_desc(struct crypto_ahash *ahash)\n{\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tint digestsize = crypto_ahash_digestsize(ahash);\n\tstruct dpaa2_caam_priv *priv = dev_get_drvdata(ctx->dev);\n\tstruct caam_flc *flc;\n\tu32 *desc;\n\n\t \n\tflc = &ctx->flc[UPDATE];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_ahash(desc, &ctx->adata, OP_ALG_AS_UPDATE, ctx->ctx_len,\n\t\t\t  ctx->ctx_len, true, priv->sec_attr.era);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(ctx->dev, ctx->flc_dma[UPDATE],\n\t\t\t\t   desc_bytes(desc), DMA_BIDIRECTIONAL);\n\tprint_hex_dump_debug(\"ahash update shdesc@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, desc, desc_bytes(desc),\n\t\t\t     1);\n\n\t \n\tflc = &ctx->flc[UPDATE_FIRST];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_ahash(desc, &ctx->adata, OP_ALG_AS_INIT, ctx->ctx_len,\n\t\t\t  ctx->ctx_len, false, priv->sec_attr.era);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(ctx->dev, ctx->flc_dma[UPDATE_FIRST],\n\t\t\t\t   desc_bytes(desc), DMA_BIDIRECTIONAL);\n\tprint_hex_dump_debug(\"ahash update first shdesc@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, desc, desc_bytes(desc),\n\t\t\t     1);\n\n\t \n\tflc = &ctx->flc[FINALIZE];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_ahash(desc, &ctx->adata, OP_ALG_AS_FINALIZE, digestsize,\n\t\t\t  ctx->ctx_len, true, priv->sec_attr.era);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(ctx->dev, ctx->flc_dma[FINALIZE],\n\t\t\t\t   desc_bytes(desc), DMA_BIDIRECTIONAL);\n\tprint_hex_dump_debug(\"ahash final shdesc@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, desc, desc_bytes(desc),\n\t\t\t     1);\n\n\t \n\tflc = &ctx->flc[DIGEST];\n\tdesc = flc->sh_desc;\n\tcnstr_shdsc_ahash(desc, &ctx->adata, OP_ALG_AS_INITFINAL, digestsize,\n\t\t\t  ctx->ctx_len, false, priv->sec_attr.era);\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tdma_sync_single_for_device(ctx->dev, ctx->flc_dma[DIGEST],\n\t\t\t\t   desc_bytes(desc), DMA_BIDIRECTIONAL);\n\tprint_hex_dump_debug(\"ahash digest shdesc@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, desc, desc_bytes(desc),\n\t\t\t     1);\n\n\treturn 0;\n}\n\nstruct split_key_sh_result {\n\tstruct completion completion;\n\tint err;\n\tstruct device *dev;\n};\n\nstatic void split_key_sh_done(void *cbk_ctx, u32 err)\n{\n\tstruct split_key_sh_result *res = cbk_ctx;\n\n\tdev_dbg(res->dev, \"%s %d: err 0x%x\\n\", __func__, __LINE__, err);\n\n\tres->err = err ? caam_qi2_strstatus(res->dev, err) : 0;\n\tcomplete(&res->completion);\n}\n\n \nstatic int hash_digest_key(struct caam_hash_ctx *ctx, u32 *keylen, u8 *key,\n\t\t\t   u32 digestsize)\n{\n\tstruct caam_request *req_ctx;\n\tu32 *desc;\n\tstruct split_key_sh_result result;\n\tdma_addr_t key_dma;\n\tstruct caam_flc *flc;\n\tdma_addr_t flc_dma;\n\tint ret = -ENOMEM;\n\tstruct dpaa2_fl_entry *in_fle, *out_fle;\n\n\treq_ctx = kzalloc(sizeof(*req_ctx), GFP_KERNEL);\n\tif (!req_ctx)\n\t\treturn -ENOMEM;\n\n\tin_fle = &req_ctx->fd_flt[1];\n\tout_fle = &req_ctx->fd_flt[0];\n\n\tflc = kzalloc(sizeof(*flc), GFP_KERNEL);\n\tif (!flc)\n\t\tgoto err_flc;\n\n\tkey_dma = dma_map_single(ctx->dev, key, *keylen, DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(ctx->dev, key_dma)) {\n\t\tdev_err(ctx->dev, \"unable to map key memory\\n\");\n\t\tgoto err_key_dma;\n\t}\n\n\tdesc = flc->sh_desc;\n\n\tinit_sh_desc(desc, 0);\n\n\t \n\tappend_operation(desc, ctx->adata.algtype | OP_ALG_ENCRYPT |\n\t\t\t OP_ALG_AS_INITFINAL);\n\tappend_seq_fifo_load(desc, *keylen, FIFOLD_CLASS_CLASS2 |\n\t\t\t     FIFOLD_TYPE_LAST2 | FIFOLD_TYPE_MSG);\n\tappend_seq_store(desc, digestsize, LDST_CLASS_2_CCB |\n\t\t\t LDST_SRCDST_BYTE_CONTEXT);\n\n\tflc->flc[1] = cpu_to_caam32(desc_len(desc));  \n\tflc_dma = dma_map_single(ctx->dev, flc, sizeof(flc->flc) +\n\t\t\t\t desc_bytes(desc), DMA_TO_DEVICE);\n\tif (dma_mapping_error(ctx->dev, flc_dma)) {\n\t\tdev_err(ctx->dev, \"unable to map shared descriptor\\n\");\n\t\tgoto err_flc_dma;\n\t}\n\n\tdpaa2_fl_set_final(in_fle, true);\n\tdpaa2_fl_set_format(in_fle, dpaa2_fl_single);\n\tdpaa2_fl_set_addr(in_fle, key_dma);\n\tdpaa2_fl_set_len(in_fle, *keylen);\n\tdpaa2_fl_set_format(out_fle, dpaa2_fl_single);\n\tdpaa2_fl_set_addr(out_fle, key_dma);\n\tdpaa2_fl_set_len(out_fle, digestsize);\n\n\tprint_hex_dump_debug(\"key_in@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, key, *keylen, 1);\n\tprint_hex_dump_debug(\"shdesc@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, desc, desc_bytes(desc),\n\t\t\t     1);\n\n\tresult.err = 0;\n\tinit_completion(&result.completion);\n\tresult.dev = ctx->dev;\n\n\treq_ctx->flc = flc;\n\treq_ctx->flc_dma = flc_dma;\n\treq_ctx->cbk = split_key_sh_done;\n\treq_ctx->ctx = &result;\n\n\tret = dpaa2_caam_enqueue(ctx->dev, req_ctx);\n\tif (ret == -EINPROGRESS) {\n\t\t \n\t\twait_for_completion(&result.completion);\n\t\tret = result.err;\n\t\tprint_hex_dump_debug(\"digested key@\" __stringify(__LINE__)\": \",\n\t\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, key,\n\t\t\t\t     digestsize, 1);\n\t}\n\n\tdma_unmap_single(ctx->dev, flc_dma, sizeof(flc->flc) + desc_bytes(desc),\n\t\t\t DMA_TO_DEVICE);\nerr_flc_dma:\n\tdma_unmap_single(ctx->dev, key_dma, *keylen, DMA_BIDIRECTIONAL);\nerr_key_dma:\n\tkfree(flc);\nerr_flc:\n\tkfree(req_ctx);\n\n\t*keylen = digestsize;\n\n\treturn ret;\n}\n\nstatic int ahash_setkey(struct crypto_ahash *ahash, const u8 *key,\n\t\t\tunsigned int keylen)\n{\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tunsigned int blocksize = crypto_tfm_alg_blocksize(&ahash->base);\n\tunsigned int digestsize = crypto_ahash_digestsize(ahash);\n\tint ret;\n\tu8 *hashed_key = NULL;\n\n\tdev_dbg(ctx->dev, \"keylen %d blocksize %d\\n\", keylen, blocksize);\n\n\tif (keylen > blocksize) {\n\t\tunsigned int aligned_len =\n\t\t\tALIGN(keylen, dma_get_cache_alignment());\n\n\t\tif (aligned_len < keylen)\n\t\t\treturn -EOVERFLOW;\n\n\t\thashed_key = kmemdup(key, aligned_len, GFP_KERNEL);\n\t\tif (!hashed_key)\n\t\t\treturn -ENOMEM;\n\t\tret = hash_digest_key(ctx, &keylen, hashed_key, digestsize);\n\t\tif (ret)\n\t\t\tgoto bad_free_key;\n\t\tkey = hashed_key;\n\t}\n\n\tctx->adata.keylen = keylen;\n\tctx->adata.keylen_pad = split_key_len(ctx->adata.algtype &\n\t\t\t\t\t      OP_ALG_ALGSEL_MASK);\n\tif (ctx->adata.keylen_pad > CAAM_MAX_HASH_KEY_SIZE)\n\t\tgoto bad_free_key;\n\n\tctx->adata.key_virt = key;\n\tctx->adata.key_inline = true;\n\n\t \n\tif (keylen > ctx->adata.keylen_pad) {\n\t\tmemcpy(ctx->key, key, keylen);\n\t\tdma_sync_single_for_device(ctx->dev, ctx->adata.key_dma,\n\t\t\t\t\t   ctx->adata.keylen_pad,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t}\n\n\tret = ahash_set_sh_desc(ahash);\n\tkfree(hashed_key);\n\treturn ret;\nbad_free_key:\n\tkfree(hashed_key);\n\treturn -EINVAL;\n}\n\nstatic inline void ahash_unmap(struct device *dev, struct ahash_edesc *edesc,\n\t\t\t       struct ahash_request *req)\n{\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\n\tif (edesc->src_nents)\n\t\tdma_unmap_sg(dev, req->src, edesc->src_nents, DMA_TO_DEVICE);\n\n\tif (edesc->qm_sg_bytes)\n\t\tdma_unmap_single(dev, edesc->qm_sg_dma, edesc->qm_sg_bytes,\n\t\t\t\t DMA_TO_DEVICE);\n\n\tif (state->buf_dma) {\n\t\tdma_unmap_single(dev, state->buf_dma, state->buflen,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tstate->buf_dma = 0;\n\t}\n}\n\nstatic inline void ahash_unmap_ctx(struct device *dev,\n\t\t\t\t   struct ahash_edesc *edesc,\n\t\t\t\t   struct ahash_request *req, u32 flag)\n{\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\n\tif (state->ctx_dma) {\n\t\tdma_unmap_single(dev, state->ctx_dma, state->ctx_dma_len, flag);\n\t\tstate->ctx_dma = 0;\n\t}\n\tahash_unmap(dev, edesc, req);\n}\n\nstatic void ahash_done(void *cbk_ctx, u32 status)\n{\n\tstruct crypto_async_request *areq = cbk_ctx;\n\tstruct ahash_request *req = ahash_request_cast(areq);\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tstruct ahash_edesc *edesc = state->caam_req.edesc;\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tint digestsize = crypto_ahash_digestsize(ahash);\n\tint ecode = 0;\n\n\tdev_dbg(ctx->dev, \"%s %d: err 0x%x\\n\", __func__, __LINE__, status);\n\n\tif (unlikely(status))\n\t\tecode = caam_qi2_strstatus(ctx->dev, status);\n\n\tahash_unmap_ctx(ctx->dev, edesc, req, DMA_FROM_DEVICE);\n\tmemcpy(req->result, state->caam_ctx, digestsize);\n\tqi_cache_free(edesc);\n\n\tprint_hex_dump_debug(\"ctx@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, state->caam_ctx,\n\t\t\t     ctx->ctx_len, 1);\n\n\tahash_request_complete(req, ecode);\n}\n\nstatic void ahash_done_bi(void *cbk_ctx, u32 status)\n{\n\tstruct crypto_async_request *areq = cbk_ctx;\n\tstruct ahash_request *req = ahash_request_cast(areq);\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tstruct ahash_edesc *edesc = state->caam_req.edesc;\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tint ecode = 0;\n\n\tdev_dbg(ctx->dev, \"%s %d: err 0x%x\\n\", __func__, __LINE__, status);\n\n\tif (unlikely(status))\n\t\tecode = caam_qi2_strstatus(ctx->dev, status);\n\n\tahash_unmap_ctx(ctx->dev, edesc, req, DMA_BIDIRECTIONAL);\n\tqi_cache_free(edesc);\n\n\tscatterwalk_map_and_copy(state->buf, req->src,\n\t\t\t\t req->nbytes - state->next_buflen,\n\t\t\t\t state->next_buflen, 0);\n\tstate->buflen = state->next_buflen;\n\n\tprint_hex_dump_debug(\"buf@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, state->buf,\n\t\t\t     state->buflen, 1);\n\n\tprint_hex_dump_debug(\"ctx@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, state->caam_ctx,\n\t\t\t     ctx->ctx_len, 1);\n\tif (req->result)\n\t\tprint_hex_dump_debug(\"result@\" __stringify(__LINE__)\": \",\n\t\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, req->result,\n\t\t\t\t     crypto_ahash_digestsize(ahash), 1);\n\n\tahash_request_complete(req, ecode);\n}\n\nstatic void ahash_done_ctx_src(void *cbk_ctx, u32 status)\n{\n\tstruct crypto_async_request *areq = cbk_ctx;\n\tstruct ahash_request *req = ahash_request_cast(areq);\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tstruct ahash_edesc *edesc = state->caam_req.edesc;\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tint digestsize = crypto_ahash_digestsize(ahash);\n\tint ecode = 0;\n\n\tdev_dbg(ctx->dev, \"%s %d: err 0x%x\\n\", __func__, __LINE__, status);\n\n\tif (unlikely(status))\n\t\tecode = caam_qi2_strstatus(ctx->dev, status);\n\n\tahash_unmap_ctx(ctx->dev, edesc, req, DMA_BIDIRECTIONAL);\n\tmemcpy(req->result, state->caam_ctx, digestsize);\n\tqi_cache_free(edesc);\n\n\tprint_hex_dump_debug(\"ctx@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, state->caam_ctx,\n\t\t\t     ctx->ctx_len, 1);\n\n\tahash_request_complete(req, ecode);\n}\n\nstatic void ahash_done_ctx_dst(void *cbk_ctx, u32 status)\n{\n\tstruct crypto_async_request *areq = cbk_ctx;\n\tstruct ahash_request *req = ahash_request_cast(areq);\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tstruct ahash_edesc *edesc = state->caam_req.edesc;\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tint ecode = 0;\n\n\tdev_dbg(ctx->dev, \"%s %d: err 0x%x\\n\", __func__, __LINE__, status);\n\n\tif (unlikely(status))\n\t\tecode = caam_qi2_strstatus(ctx->dev, status);\n\n\tahash_unmap_ctx(ctx->dev, edesc, req, DMA_FROM_DEVICE);\n\tqi_cache_free(edesc);\n\n\tscatterwalk_map_and_copy(state->buf, req->src,\n\t\t\t\t req->nbytes - state->next_buflen,\n\t\t\t\t state->next_buflen, 0);\n\tstate->buflen = state->next_buflen;\n\n\tprint_hex_dump_debug(\"buf@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, state->buf,\n\t\t\t     state->buflen, 1);\n\n\tprint_hex_dump_debug(\"ctx@\" __stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, state->caam_ctx,\n\t\t\t     ctx->ctx_len, 1);\n\tif (req->result)\n\t\tprint_hex_dump_debug(\"result@\" __stringify(__LINE__)\": \",\n\t\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, req->result,\n\t\t\t\t     crypto_ahash_digestsize(ahash), 1);\n\n\tahash_request_complete(req, ecode);\n}\n\nstatic int ahash_update_ctx(struct ahash_request *req)\n{\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tstruct caam_request *req_ctx = &state->caam_req;\n\tstruct dpaa2_fl_entry *in_fle = &req_ctx->fd_flt[1];\n\tstruct dpaa2_fl_entry *out_fle = &req_ctx->fd_flt[0];\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t      GFP_KERNEL : GFP_ATOMIC;\n\tu8 *buf = state->buf;\n\tint *buflen = &state->buflen;\n\tint *next_buflen = &state->next_buflen;\n\tint in_len = *buflen + req->nbytes, to_hash;\n\tint src_nents, mapped_nents, qm_sg_bytes, qm_sg_src_index;\n\tstruct ahash_edesc *edesc;\n\tint ret = 0;\n\n\t*next_buflen = in_len & (crypto_tfm_alg_blocksize(&ahash->base) - 1);\n\tto_hash = in_len - *next_buflen;\n\n\tif (to_hash) {\n\t\tstruct dpaa2_sg_entry *sg_table;\n\t\tint src_len = req->nbytes - *next_buflen;\n\n\t\tsrc_nents = sg_nents_for_len(req->src, src_len);\n\t\tif (src_nents < 0) {\n\t\t\tdev_err(ctx->dev, \"Invalid number of src SG.\\n\");\n\t\t\treturn src_nents;\n\t\t}\n\n\t\tif (src_nents) {\n\t\t\tmapped_nents = dma_map_sg(ctx->dev, req->src, src_nents,\n\t\t\t\t\t\t  DMA_TO_DEVICE);\n\t\t\tif (!mapped_nents) {\n\t\t\t\tdev_err(ctx->dev, \"unable to DMA map source\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\tmapped_nents = 0;\n\t\t}\n\n\t\t \n\t\tedesc = qi_cache_zalloc(flags);\n\t\tif (!edesc) {\n\t\t\tdma_unmap_sg(ctx->dev, req->src, src_nents,\n\t\t\t\t     DMA_TO_DEVICE);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tedesc->src_nents = src_nents;\n\t\tqm_sg_src_index = 1 + (*buflen ? 1 : 0);\n\t\tqm_sg_bytes = pad_sg_nents(qm_sg_src_index + mapped_nents) *\n\t\t\t      sizeof(*sg_table);\n\t\tsg_table = &edesc->sgt[0];\n\n\t\tret = ctx_map_to_qm_sg(ctx->dev, state, ctx->ctx_len, sg_table,\n\t\t\t\t       DMA_BIDIRECTIONAL);\n\t\tif (ret)\n\t\t\tgoto unmap_ctx;\n\n\t\tret = buf_map_to_qm_sg(ctx->dev, sg_table + 1, state);\n\t\tif (ret)\n\t\t\tgoto unmap_ctx;\n\n\t\tif (mapped_nents) {\n\t\t\tsg_to_qm_sg_last(req->src, src_len,\n\t\t\t\t\t sg_table + qm_sg_src_index, 0);\n\t\t} else {\n\t\t\tdpaa2_sg_set_final(sg_table + qm_sg_src_index - 1,\n\t\t\t\t\t   true);\n\t\t}\n\n\t\tedesc->qm_sg_dma = dma_map_single(ctx->dev, sg_table,\n\t\t\t\t\t\t  qm_sg_bytes, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(ctx->dev, edesc->qm_sg_dma)) {\n\t\t\tdev_err(ctx->dev, \"unable to map S/G table\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unmap_ctx;\n\t\t}\n\t\tedesc->qm_sg_bytes = qm_sg_bytes;\n\n\t\tmemset(&req_ctx->fd_flt, 0, sizeof(req_ctx->fd_flt));\n\t\tdpaa2_fl_set_final(in_fle, true);\n\t\tdpaa2_fl_set_format(in_fle, dpaa2_fl_sg);\n\t\tdpaa2_fl_set_addr(in_fle, edesc->qm_sg_dma);\n\t\tdpaa2_fl_set_len(in_fle, ctx->ctx_len + to_hash);\n\t\tdpaa2_fl_set_format(out_fle, dpaa2_fl_single);\n\t\tdpaa2_fl_set_addr(out_fle, state->ctx_dma);\n\t\tdpaa2_fl_set_len(out_fle, ctx->ctx_len);\n\n\t\treq_ctx->flc = &ctx->flc[UPDATE];\n\t\treq_ctx->flc_dma = ctx->flc_dma[UPDATE];\n\t\treq_ctx->cbk = ahash_done_bi;\n\t\treq_ctx->ctx = &req->base;\n\t\treq_ctx->edesc = edesc;\n\n\t\tret = dpaa2_caam_enqueue(ctx->dev, req_ctx);\n\t\tif (ret != -EINPROGRESS &&\n\t\t    !(ret == -EBUSY &&\n\t\t      req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG))\n\t\t\tgoto unmap_ctx;\n\t} else if (*next_buflen) {\n\t\tscatterwalk_map_and_copy(buf + *buflen, req->src, 0,\n\t\t\t\t\t req->nbytes, 0);\n\t\t*buflen = *next_buflen;\n\n\t\tprint_hex_dump_debug(\"buf@\" __stringify(__LINE__)\": \",\n\t\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, buf,\n\t\t\t\t     *buflen, 1);\n\t}\n\n\treturn ret;\nunmap_ctx:\n\tahash_unmap_ctx(ctx->dev, edesc, req, DMA_BIDIRECTIONAL);\n\tqi_cache_free(edesc);\n\treturn ret;\n}\n\nstatic int ahash_final_ctx(struct ahash_request *req)\n{\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tstruct caam_request *req_ctx = &state->caam_req;\n\tstruct dpaa2_fl_entry *in_fle = &req_ctx->fd_flt[1];\n\tstruct dpaa2_fl_entry *out_fle = &req_ctx->fd_flt[0];\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t      GFP_KERNEL : GFP_ATOMIC;\n\tint buflen = state->buflen;\n\tint qm_sg_bytes;\n\tint digestsize = crypto_ahash_digestsize(ahash);\n\tstruct ahash_edesc *edesc;\n\tstruct dpaa2_sg_entry *sg_table;\n\tint ret;\n\n\t \n\tedesc = qi_cache_zalloc(flags);\n\tif (!edesc)\n\t\treturn -ENOMEM;\n\n\tqm_sg_bytes = pad_sg_nents(1 + (buflen ? 1 : 0)) * sizeof(*sg_table);\n\tsg_table = &edesc->sgt[0];\n\n\tret = ctx_map_to_qm_sg(ctx->dev, state, ctx->ctx_len, sg_table,\n\t\t\t       DMA_BIDIRECTIONAL);\n\tif (ret)\n\t\tgoto unmap_ctx;\n\n\tret = buf_map_to_qm_sg(ctx->dev, sg_table + 1, state);\n\tif (ret)\n\t\tgoto unmap_ctx;\n\n\tdpaa2_sg_set_final(sg_table + (buflen ? 1 : 0), true);\n\n\tedesc->qm_sg_dma = dma_map_single(ctx->dev, sg_table, qm_sg_bytes,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(ctx->dev, edesc->qm_sg_dma)) {\n\t\tdev_err(ctx->dev, \"unable to map S/G table\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto unmap_ctx;\n\t}\n\tedesc->qm_sg_bytes = qm_sg_bytes;\n\n\tmemset(&req_ctx->fd_flt, 0, sizeof(req_ctx->fd_flt));\n\tdpaa2_fl_set_final(in_fle, true);\n\tdpaa2_fl_set_format(in_fle, dpaa2_fl_sg);\n\tdpaa2_fl_set_addr(in_fle, edesc->qm_sg_dma);\n\tdpaa2_fl_set_len(in_fle, ctx->ctx_len + buflen);\n\tdpaa2_fl_set_format(out_fle, dpaa2_fl_single);\n\tdpaa2_fl_set_addr(out_fle, state->ctx_dma);\n\tdpaa2_fl_set_len(out_fle, digestsize);\n\n\treq_ctx->flc = &ctx->flc[FINALIZE];\n\treq_ctx->flc_dma = ctx->flc_dma[FINALIZE];\n\treq_ctx->cbk = ahash_done_ctx_src;\n\treq_ctx->ctx = &req->base;\n\treq_ctx->edesc = edesc;\n\n\tret = dpaa2_caam_enqueue(ctx->dev, req_ctx);\n\tif (ret == -EINPROGRESS ||\n\t    (ret == -EBUSY && req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG))\n\t\treturn ret;\n\nunmap_ctx:\n\tahash_unmap_ctx(ctx->dev, edesc, req, DMA_BIDIRECTIONAL);\n\tqi_cache_free(edesc);\n\treturn ret;\n}\n\nstatic int ahash_finup_ctx(struct ahash_request *req)\n{\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tstruct caam_request *req_ctx = &state->caam_req;\n\tstruct dpaa2_fl_entry *in_fle = &req_ctx->fd_flt[1];\n\tstruct dpaa2_fl_entry *out_fle = &req_ctx->fd_flt[0];\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t      GFP_KERNEL : GFP_ATOMIC;\n\tint buflen = state->buflen;\n\tint qm_sg_bytes, qm_sg_src_index;\n\tint src_nents, mapped_nents;\n\tint digestsize = crypto_ahash_digestsize(ahash);\n\tstruct ahash_edesc *edesc;\n\tstruct dpaa2_sg_entry *sg_table;\n\tint ret;\n\n\tsrc_nents = sg_nents_for_len(req->src, req->nbytes);\n\tif (src_nents < 0) {\n\t\tdev_err(ctx->dev, \"Invalid number of src SG.\\n\");\n\t\treturn src_nents;\n\t}\n\n\tif (src_nents) {\n\t\tmapped_nents = dma_map_sg(ctx->dev, req->src, src_nents,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\t\tif (!mapped_nents) {\n\t\t\tdev_err(ctx->dev, \"unable to DMA map source\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tmapped_nents = 0;\n\t}\n\n\t \n\tedesc = qi_cache_zalloc(flags);\n\tif (!edesc) {\n\t\tdma_unmap_sg(ctx->dev, req->src, src_nents, DMA_TO_DEVICE);\n\t\treturn -ENOMEM;\n\t}\n\n\tedesc->src_nents = src_nents;\n\tqm_sg_src_index = 1 + (buflen ? 1 : 0);\n\tqm_sg_bytes = pad_sg_nents(qm_sg_src_index + mapped_nents) *\n\t\t      sizeof(*sg_table);\n\tsg_table = &edesc->sgt[0];\n\n\tret = ctx_map_to_qm_sg(ctx->dev, state, ctx->ctx_len, sg_table,\n\t\t\t       DMA_BIDIRECTIONAL);\n\tif (ret)\n\t\tgoto unmap_ctx;\n\n\tret = buf_map_to_qm_sg(ctx->dev, sg_table + 1, state);\n\tif (ret)\n\t\tgoto unmap_ctx;\n\n\tsg_to_qm_sg_last(req->src, req->nbytes, sg_table + qm_sg_src_index, 0);\n\n\tedesc->qm_sg_dma = dma_map_single(ctx->dev, sg_table, qm_sg_bytes,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(ctx->dev, edesc->qm_sg_dma)) {\n\t\tdev_err(ctx->dev, \"unable to map S/G table\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto unmap_ctx;\n\t}\n\tedesc->qm_sg_bytes = qm_sg_bytes;\n\n\tmemset(&req_ctx->fd_flt, 0, sizeof(req_ctx->fd_flt));\n\tdpaa2_fl_set_final(in_fle, true);\n\tdpaa2_fl_set_format(in_fle, dpaa2_fl_sg);\n\tdpaa2_fl_set_addr(in_fle, edesc->qm_sg_dma);\n\tdpaa2_fl_set_len(in_fle, ctx->ctx_len + buflen + req->nbytes);\n\tdpaa2_fl_set_format(out_fle, dpaa2_fl_single);\n\tdpaa2_fl_set_addr(out_fle, state->ctx_dma);\n\tdpaa2_fl_set_len(out_fle, digestsize);\n\n\treq_ctx->flc = &ctx->flc[FINALIZE];\n\treq_ctx->flc_dma = ctx->flc_dma[FINALIZE];\n\treq_ctx->cbk = ahash_done_ctx_src;\n\treq_ctx->ctx = &req->base;\n\treq_ctx->edesc = edesc;\n\n\tret = dpaa2_caam_enqueue(ctx->dev, req_ctx);\n\tif (ret == -EINPROGRESS ||\n\t    (ret == -EBUSY && req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG))\n\t\treturn ret;\n\nunmap_ctx:\n\tahash_unmap_ctx(ctx->dev, edesc, req, DMA_BIDIRECTIONAL);\n\tqi_cache_free(edesc);\n\treturn ret;\n}\n\nstatic int ahash_digest(struct ahash_request *req)\n{\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tstruct caam_request *req_ctx = &state->caam_req;\n\tstruct dpaa2_fl_entry *in_fle = &req_ctx->fd_flt[1];\n\tstruct dpaa2_fl_entry *out_fle = &req_ctx->fd_flt[0];\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t      GFP_KERNEL : GFP_ATOMIC;\n\tint digestsize = crypto_ahash_digestsize(ahash);\n\tint src_nents, mapped_nents;\n\tstruct ahash_edesc *edesc;\n\tint ret = -ENOMEM;\n\n\tstate->buf_dma = 0;\n\n\tsrc_nents = sg_nents_for_len(req->src, req->nbytes);\n\tif (src_nents < 0) {\n\t\tdev_err(ctx->dev, \"Invalid number of src SG.\\n\");\n\t\treturn src_nents;\n\t}\n\n\tif (src_nents) {\n\t\tmapped_nents = dma_map_sg(ctx->dev, req->src, src_nents,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\t\tif (!mapped_nents) {\n\t\t\tdev_err(ctx->dev, \"unable to map source for DMA\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tmapped_nents = 0;\n\t}\n\n\t \n\tedesc = qi_cache_zalloc(flags);\n\tif (!edesc) {\n\t\tdma_unmap_sg(ctx->dev, req->src, src_nents, DMA_TO_DEVICE);\n\t\treturn ret;\n\t}\n\n\tedesc->src_nents = src_nents;\n\tmemset(&req_ctx->fd_flt, 0, sizeof(req_ctx->fd_flt));\n\n\tif (mapped_nents > 1) {\n\t\tint qm_sg_bytes;\n\t\tstruct dpaa2_sg_entry *sg_table = &edesc->sgt[0];\n\n\t\tqm_sg_bytes = pad_sg_nents(mapped_nents) * sizeof(*sg_table);\n\t\tsg_to_qm_sg_last(req->src, req->nbytes, sg_table, 0);\n\t\tedesc->qm_sg_dma = dma_map_single(ctx->dev, sg_table,\n\t\t\t\t\t\t  qm_sg_bytes, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(ctx->dev, edesc->qm_sg_dma)) {\n\t\t\tdev_err(ctx->dev, \"unable to map S/G table\\n\");\n\t\t\tgoto unmap;\n\t\t}\n\t\tedesc->qm_sg_bytes = qm_sg_bytes;\n\t\tdpaa2_fl_set_format(in_fle, dpaa2_fl_sg);\n\t\tdpaa2_fl_set_addr(in_fle, edesc->qm_sg_dma);\n\t} else {\n\t\tdpaa2_fl_set_format(in_fle, dpaa2_fl_single);\n\t\tdpaa2_fl_set_addr(in_fle, sg_dma_address(req->src));\n\t}\n\n\tstate->ctx_dma_len = digestsize;\n\tstate->ctx_dma = dma_map_single(ctx->dev, state->caam_ctx, digestsize,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\tif (dma_mapping_error(ctx->dev, state->ctx_dma)) {\n\t\tdev_err(ctx->dev, \"unable to map ctx\\n\");\n\t\tstate->ctx_dma = 0;\n\t\tgoto unmap;\n\t}\n\n\tdpaa2_fl_set_final(in_fle, true);\n\tdpaa2_fl_set_len(in_fle, req->nbytes);\n\tdpaa2_fl_set_format(out_fle, dpaa2_fl_single);\n\tdpaa2_fl_set_addr(out_fle, state->ctx_dma);\n\tdpaa2_fl_set_len(out_fle, digestsize);\n\n\treq_ctx->flc = &ctx->flc[DIGEST];\n\treq_ctx->flc_dma = ctx->flc_dma[DIGEST];\n\treq_ctx->cbk = ahash_done;\n\treq_ctx->ctx = &req->base;\n\treq_ctx->edesc = edesc;\n\tret = dpaa2_caam_enqueue(ctx->dev, req_ctx);\n\tif (ret == -EINPROGRESS ||\n\t    (ret == -EBUSY && req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG))\n\t\treturn ret;\n\nunmap:\n\tahash_unmap_ctx(ctx->dev, edesc, req, DMA_FROM_DEVICE);\n\tqi_cache_free(edesc);\n\treturn ret;\n}\n\nstatic int ahash_final_no_ctx(struct ahash_request *req)\n{\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tstruct caam_request *req_ctx = &state->caam_req;\n\tstruct dpaa2_fl_entry *in_fle = &req_ctx->fd_flt[1];\n\tstruct dpaa2_fl_entry *out_fle = &req_ctx->fd_flt[0];\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t      GFP_KERNEL : GFP_ATOMIC;\n\tu8 *buf = state->buf;\n\tint buflen = state->buflen;\n\tint digestsize = crypto_ahash_digestsize(ahash);\n\tstruct ahash_edesc *edesc;\n\tint ret = -ENOMEM;\n\n\t \n\tedesc = qi_cache_zalloc(flags);\n\tif (!edesc)\n\t\treturn ret;\n\n\tif (buflen) {\n\t\tstate->buf_dma = dma_map_single(ctx->dev, buf, buflen,\n\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\tif (dma_mapping_error(ctx->dev, state->buf_dma)) {\n\t\t\tdev_err(ctx->dev, \"unable to map src\\n\");\n\t\t\tgoto unmap;\n\t\t}\n\t}\n\n\tstate->ctx_dma_len = digestsize;\n\tstate->ctx_dma = dma_map_single(ctx->dev, state->caam_ctx, digestsize,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\tif (dma_mapping_error(ctx->dev, state->ctx_dma)) {\n\t\tdev_err(ctx->dev, \"unable to map ctx\\n\");\n\t\tstate->ctx_dma = 0;\n\t\tgoto unmap;\n\t}\n\n\tmemset(&req_ctx->fd_flt, 0, sizeof(req_ctx->fd_flt));\n\tdpaa2_fl_set_final(in_fle, true);\n\t \n\tif (buflen) {\n\t\tdpaa2_fl_set_format(in_fle, dpaa2_fl_single);\n\t\tdpaa2_fl_set_addr(in_fle, state->buf_dma);\n\t\tdpaa2_fl_set_len(in_fle, buflen);\n\t}\n\tdpaa2_fl_set_format(out_fle, dpaa2_fl_single);\n\tdpaa2_fl_set_addr(out_fle, state->ctx_dma);\n\tdpaa2_fl_set_len(out_fle, digestsize);\n\n\treq_ctx->flc = &ctx->flc[DIGEST];\n\treq_ctx->flc_dma = ctx->flc_dma[DIGEST];\n\treq_ctx->cbk = ahash_done;\n\treq_ctx->ctx = &req->base;\n\treq_ctx->edesc = edesc;\n\n\tret = dpaa2_caam_enqueue(ctx->dev, req_ctx);\n\tif (ret == -EINPROGRESS ||\n\t    (ret == -EBUSY && req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG))\n\t\treturn ret;\n\nunmap:\n\tahash_unmap_ctx(ctx->dev, edesc, req, DMA_FROM_DEVICE);\n\tqi_cache_free(edesc);\n\treturn ret;\n}\n\nstatic int ahash_update_no_ctx(struct ahash_request *req)\n{\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tstruct caam_request *req_ctx = &state->caam_req;\n\tstruct dpaa2_fl_entry *in_fle = &req_ctx->fd_flt[1];\n\tstruct dpaa2_fl_entry *out_fle = &req_ctx->fd_flt[0];\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t      GFP_KERNEL : GFP_ATOMIC;\n\tu8 *buf = state->buf;\n\tint *buflen = &state->buflen;\n\tint *next_buflen = &state->next_buflen;\n\tint in_len = *buflen + req->nbytes, to_hash;\n\tint qm_sg_bytes, src_nents, mapped_nents;\n\tstruct ahash_edesc *edesc;\n\tint ret = 0;\n\n\t*next_buflen = in_len & (crypto_tfm_alg_blocksize(&ahash->base) - 1);\n\tto_hash = in_len - *next_buflen;\n\n\tif (to_hash) {\n\t\tstruct dpaa2_sg_entry *sg_table;\n\t\tint src_len = req->nbytes - *next_buflen;\n\n\t\tsrc_nents = sg_nents_for_len(req->src, src_len);\n\t\tif (src_nents < 0) {\n\t\t\tdev_err(ctx->dev, \"Invalid number of src SG.\\n\");\n\t\t\treturn src_nents;\n\t\t}\n\n\t\tif (src_nents) {\n\t\t\tmapped_nents = dma_map_sg(ctx->dev, req->src, src_nents,\n\t\t\t\t\t\t  DMA_TO_DEVICE);\n\t\t\tif (!mapped_nents) {\n\t\t\t\tdev_err(ctx->dev, \"unable to DMA map source\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\tmapped_nents = 0;\n\t\t}\n\n\t\t \n\t\tedesc = qi_cache_zalloc(flags);\n\t\tif (!edesc) {\n\t\t\tdma_unmap_sg(ctx->dev, req->src, src_nents,\n\t\t\t\t     DMA_TO_DEVICE);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tedesc->src_nents = src_nents;\n\t\tqm_sg_bytes = pad_sg_nents(1 + mapped_nents) *\n\t\t\t      sizeof(*sg_table);\n\t\tsg_table = &edesc->sgt[0];\n\n\t\tret = buf_map_to_qm_sg(ctx->dev, sg_table, state);\n\t\tif (ret)\n\t\t\tgoto unmap_ctx;\n\n\t\tsg_to_qm_sg_last(req->src, src_len, sg_table + 1, 0);\n\n\t\tedesc->qm_sg_dma = dma_map_single(ctx->dev, sg_table,\n\t\t\t\t\t\t  qm_sg_bytes, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(ctx->dev, edesc->qm_sg_dma)) {\n\t\t\tdev_err(ctx->dev, \"unable to map S/G table\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unmap_ctx;\n\t\t}\n\t\tedesc->qm_sg_bytes = qm_sg_bytes;\n\n\t\tstate->ctx_dma_len = ctx->ctx_len;\n\t\tstate->ctx_dma = dma_map_single(ctx->dev, state->caam_ctx,\n\t\t\t\t\t\tctx->ctx_len, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(ctx->dev, state->ctx_dma)) {\n\t\t\tdev_err(ctx->dev, \"unable to map ctx\\n\");\n\t\t\tstate->ctx_dma = 0;\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unmap_ctx;\n\t\t}\n\n\t\tmemset(&req_ctx->fd_flt, 0, sizeof(req_ctx->fd_flt));\n\t\tdpaa2_fl_set_final(in_fle, true);\n\t\tdpaa2_fl_set_format(in_fle, dpaa2_fl_sg);\n\t\tdpaa2_fl_set_addr(in_fle, edesc->qm_sg_dma);\n\t\tdpaa2_fl_set_len(in_fle, to_hash);\n\t\tdpaa2_fl_set_format(out_fle, dpaa2_fl_single);\n\t\tdpaa2_fl_set_addr(out_fle, state->ctx_dma);\n\t\tdpaa2_fl_set_len(out_fle, ctx->ctx_len);\n\n\t\treq_ctx->flc = &ctx->flc[UPDATE_FIRST];\n\t\treq_ctx->flc_dma = ctx->flc_dma[UPDATE_FIRST];\n\t\treq_ctx->cbk = ahash_done_ctx_dst;\n\t\treq_ctx->ctx = &req->base;\n\t\treq_ctx->edesc = edesc;\n\n\t\tret = dpaa2_caam_enqueue(ctx->dev, req_ctx);\n\t\tif (ret != -EINPROGRESS &&\n\t\t    !(ret == -EBUSY &&\n\t\t      req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG))\n\t\t\tgoto unmap_ctx;\n\n\t\tstate->update = ahash_update_ctx;\n\t\tstate->finup = ahash_finup_ctx;\n\t\tstate->final = ahash_final_ctx;\n\t} else if (*next_buflen) {\n\t\tscatterwalk_map_and_copy(buf + *buflen, req->src, 0,\n\t\t\t\t\t req->nbytes, 0);\n\t\t*buflen = *next_buflen;\n\n\t\tprint_hex_dump_debug(\"buf@\" __stringify(__LINE__)\": \",\n\t\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, buf,\n\t\t\t\t     *buflen, 1);\n\t}\n\n\treturn ret;\nunmap_ctx:\n\tahash_unmap_ctx(ctx->dev, edesc, req, DMA_TO_DEVICE);\n\tqi_cache_free(edesc);\n\treturn ret;\n}\n\nstatic int ahash_finup_no_ctx(struct ahash_request *req)\n{\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tstruct caam_request *req_ctx = &state->caam_req;\n\tstruct dpaa2_fl_entry *in_fle = &req_ctx->fd_flt[1];\n\tstruct dpaa2_fl_entry *out_fle = &req_ctx->fd_flt[0];\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t      GFP_KERNEL : GFP_ATOMIC;\n\tint buflen = state->buflen;\n\tint qm_sg_bytes, src_nents, mapped_nents;\n\tint digestsize = crypto_ahash_digestsize(ahash);\n\tstruct ahash_edesc *edesc;\n\tstruct dpaa2_sg_entry *sg_table;\n\tint ret = -ENOMEM;\n\n\tsrc_nents = sg_nents_for_len(req->src, req->nbytes);\n\tif (src_nents < 0) {\n\t\tdev_err(ctx->dev, \"Invalid number of src SG.\\n\");\n\t\treturn src_nents;\n\t}\n\n\tif (src_nents) {\n\t\tmapped_nents = dma_map_sg(ctx->dev, req->src, src_nents,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\t\tif (!mapped_nents) {\n\t\t\tdev_err(ctx->dev, \"unable to DMA map source\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tmapped_nents = 0;\n\t}\n\n\t \n\tedesc = qi_cache_zalloc(flags);\n\tif (!edesc) {\n\t\tdma_unmap_sg(ctx->dev, req->src, src_nents, DMA_TO_DEVICE);\n\t\treturn ret;\n\t}\n\n\tedesc->src_nents = src_nents;\n\tqm_sg_bytes = pad_sg_nents(2 + mapped_nents) * sizeof(*sg_table);\n\tsg_table = &edesc->sgt[0];\n\n\tret = buf_map_to_qm_sg(ctx->dev, sg_table, state);\n\tif (ret)\n\t\tgoto unmap;\n\n\tsg_to_qm_sg_last(req->src, req->nbytes, sg_table + 1, 0);\n\n\tedesc->qm_sg_dma = dma_map_single(ctx->dev, sg_table, qm_sg_bytes,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(ctx->dev, edesc->qm_sg_dma)) {\n\t\tdev_err(ctx->dev, \"unable to map S/G table\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto unmap;\n\t}\n\tedesc->qm_sg_bytes = qm_sg_bytes;\n\n\tstate->ctx_dma_len = digestsize;\n\tstate->ctx_dma = dma_map_single(ctx->dev, state->caam_ctx, digestsize,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\tif (dma_mapping_error(ctx->dev, state->ctx_dma)) {\n\t\tdev_err(ctx->dev, \"unable to map ctx\\n\");\n\t\tstate->ctx_dma = 0;\n\t\tret = -ENOMEM;\n\t\tgoto unmap;\n\t}\n\n\tmemset(&req_ctx->fd_flt, 0, sizeof(req_ctx->fd_flt));\n\tdpaa2_fl_set_final(in_fle, true);\n\tdpaa2_fl_set_format(in_fle, dpaa2_fl_sg);\n\tdpaa2_fl_set_addr(in_fle, edesc->qm_sg_dma);\n\tdpaa2_fl_set_len(in_fle, buflen + req->nbytes);\n\tdpaa2_fl_set_format(out_fle, dpaa2_fl_single);\n\tdpaa2_fl_set_addr(out_fle, state->ctx_dma);\n\tdpaa2_fl_set_len(out_fle, digestsize);\n\n\treq_ctx->flc = &ctx->flc[DIGEST];\n\treq_ctx->flc_dma = ctx->flc_dma[DIGEST];\n\treq_ctx->cbk = ahash_done;\n\treq_ctx->ctx = &req->base;\n\treq_ctx->edesc = edesc;\n\tret = dpaa2_caam_enqueue(ctx->dev, req_ctx);\n\tif (ret != -EINPROGRESS &&\n\t    !(ret == -EBUSY && req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG))\n\t\tgoto unmap;\n\n\treturn ret;\nunmap:\n\tahash_unmap_ctx(ctx->dev, edesc, req, DMA_FROM_DEVICE);\n\tqi_cache_free(edesc);\n\treturn ret;\n}\n\nstatic int ahash_update_first(struct ahash_request *req)\n{\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct caam_hash_ctx *ctx = crypto_ahash_ctx_dma(ahash);\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tstruct caam_request *req_ctx = &state->caam_req;\n\tstruct dpaa2_fl_entry *in_fle = &req_ctx->fd_flt[1];\n\tstruct dpaa2_fl_entry *out_fle = &req_ctx->fd_flt[0];\n\tgfp_t flags = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t      GFP_KERNEL : GFP_ATOMIC;\n\tu8 *buf = state->buf;\n\tint *buflen = &state->buflen;\n\tint *next_buflen = &state->next_buflen;\n\tint to_hash;\n\tint src_nents, mapped_nents;\n\tstruct ahash_edesc *edesc;\n\tint ret = 0;\n\n\t*next_buflen = req->nbytes & (crypto_tfm_alg_blocksize(&ahash->base) -\n\t\t\t\t      1);\n\tto_hash = req->nbytes - *next_buflen;\n\n\tif (to_hash) {\n\t\tstruct dpaa2_sg_entry *sg_table;\n\t\tint src_len = req->nbytes - *next_buflen;\n\n\t\tsrc_nents = sg_nents_for_len(req->src, src_len);\n\t\tif (src_nents < 0) {\n\t\t\tdev_err(ctx->dev, \"Invalid number of src SG.\\n\");\n\t\t\treturn src_nents;\n\t\t}\n\n\t\tif (src_nents) {\n\t\t\tmapped_nents = dma_map_sg(ctx->dev, req->src, src_nents,\n\t\t\t\t\t\t  DMA_TO_DEVICE);\n\t\t\tif (!mapped_nents) {\n\t\t\t\tdev_err(ctx->dev, \"unable to map source for DMA\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\tmapped_nents = 0;\n\t\t}\n\n\t\t \n\t\tedesc = qi_cache_zalloc(flags);\n\t\tif (!edesc) {\n\t\t\tdma_unmap_sg(ctx->dev, req->src, src_nents,\n\t\t\t\t     DMA_TO_DEVICE);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tedesc->src_nents = src_nents;\n\t\tsg_table = &edesc->sgt[0];\n\n\t\tmemset(&req_ctx->fd_flt, 0, sizeof(req_ctx->fd_flt));\n\t\tdpaa2_fl_set_final(in_fle, true);\n\t\tdpaa2_fl_set_len(in_fle, to_hash);\n\n\t\tif (mapped_nents > 1) {\n\t\t\tint qm_sg_bytes;\n\n\t\t\tsg_to_qm_sg_last(req->src, src_len, sg_table, 0);\n\t\t\tqm_sg_bytes = pad_sg_nents(mapped_nents) *\n\t\t\t\t      sizeof(*sg_table);\n\t\t\tedesc->qm_sg_dma = dma_map_single(ctx->dev, sg_table,\n\t\t\t\t\t\t\t  qm_sg_bytes,\n\t\t\t\t\t\t\t  DMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(ctx->dev, edesc->qm_sg_dma)) {\n\t\t\t\tdev_err(ctx->dev, \"unable to map S/G table\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto unmap_ctx;\n\t\t\t}\n\t\t\tedesc->qm_sg_bytes = qm_sg_bytes;\n\t\t\tdpaa2_fl_set_format(in_fle, dpaa2_fl_sg);\n\t\t\tdpaa2_fl_set_addr(in_fle, edesc->qm_sg_dma);\n\t\t} else {\n\t\t\tdpaa2_fl_set_format(in_fle, dpaa2_fl_single);\n\t\t\tdpaa2_fl_set_addr(in_fle, sg_dma_address(req->src));\n\t\t}\n\n\t\tstate->ctx_dma_len = ctx->ctx_len;\n\t\tstate->ctx_dma = dma_map_single(ctx->dev, state->caam_ctx,\n\t\t\t\t\t\tctx->ctx_len, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(ctx->dev, state->ctx_dma)) {\n\t\t\tdev_err(ctx->dev, \"unable to map ctx\\n\");\n\t\t\tstate->ctx_dma = 0;\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unmap_ctx;\n\t\t}\n\n\t\tdpaa2_fl_set_format(out_fle, dpaa2_fl_single);\n\t\tdpaa2_fl_set_addr(out_fle, state->ctx_dma);\n\t\tdpaa2_fl_set_len(out_fle, ctx->ctx_len);\n\n\t\treq_ctx->flc = &ctx->flc[UPDATE_FIRST];\n\t\treq_ctx->flc_dma = ctx->flc_dma[UPDATE_FIRST];\n\t\treq_ctx->cbk = ahash_done_ctx_dst;\n\t\treq_ctx->ctx = &req->base;\n\t\treq_ctx->edesc = edesc;\n\n\t\tret = dpaa2_caam_enqueue(ctx->dev, req_ctx);\n\t\tif (ret != -EINPROGRESS &&\n\t\t    !(ret == -EBUSY && req->base.flags &\n\t\t      CRYPTO_TFM_REQ_MAY_BACKLOG))\n\t\t\tgoto unmap_ctx;\n\n\t\tstate->update = ahash_update_ctx;\n\t\tstate->finup = ahash_finup_ctx;\n\t\tstate->final = ahash_final_ctx;\n\t} else if (*next_buflen) {\n\t\tstate->update = ahash_update_no_ctx;\n\t\tstate->finup = ahash_finup_no_ctx;\n\t\tstate->final = ahash_final_no_ctx;\n\t\tscatterwalk_map_and_copy(buf, req->src, 0,\n\t\t\t\t\t req->nbytes, 0);\n\t\t*buflen = *next_buflen;\n\n\t\tprint_hex_dump_debug(\"buf@\" __stringify(__LINE__)\": \",\n\t\t\t\t     DUMP_PREFIX_ADDRESS, 16, 4, buf,\n\t\t\t\t     *buflen, 1);\n\t}\n\n\treturn ret;\nunmap_ctx:\n\tahash_unmap_ctx(ctx->dev, edesc, req, DMA_TO_DEVICE);\n\tqi_cache_free(edesc);\n\treturn ret;\n}\n\nstatic int ahash_finup_first(struct ahash_request *req)\n{\n\treturn ahash_digest(req);\n}\n\nstatic int ahash_init(struct ahash_request *req)\n{\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\n\tstate->update = ahash_update_first;\n\tstate->finup = ahash_finup_first;\n\tstate->final = ahash_final_no_ctx;\n\n\tstate->ctx_dma = 0;\n\tstate->ctx_dma_len = 0;\n\tstate->buf_dma = 0;\n\tstate->buflen = 0;\n\tstate->next_buflen = 0;\n\n\treturn 0;\n}\n\nstatic int ahash_update(struct ahash_request *req)\n{\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\n\treturn state->update(req);\n}\n\nstatic int ahash_finup(struct ahash_request *req)\n{\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\n\treturn state->finup(req);\n}\n\nstatic int ahash_final(struct ahash_request *req)\n{\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\n\treturn state->final(req);\n}\n\nstatic int ahash_export(struct ahash_request *req, void *out)\n{\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tstruct caam_export_state *export = out;\n\tu8 *buf = state->buf;\n\tint len = state->buflen;\n\n\tmemcpy(export->buf, buf, len);\n\tmemcpy(export->caam_ctx, state->caam_ctx, sizeof(export->caam_ctx));\n\texport->buflen = len;\n\texport->update = state->update;\n\texport->final = state->final;\n\texport->finup = state->finup;\n\n\treturn 0;\n}\n\nstatic int ahash_import(struct ahash_request *req, const void *in)\n{\n\tstruct caam_hash_state *state = ahash_request_ctx_dma(req);\n\tconst struct caam_export_state *export = in;\n\n\tmemset(state, 0, sizeof(*state));\n\tmemcpy(state->buf, export->buf, export->buflen);\n\tmemcpy(state->caam_ctx, export->caam_ctx, sizeof(state->caam_ctx));\n\tstate->buflen = export->buflen;\n\tstate->update = export->update;\n\tstate->final = export->final;\n\tstate->finup = export->finup;\n\n\treturn 0;\n}\n\nstruct caam_hash_template {\n\tchar name[CRYPTO_MAX_ALG_NAME];\n\tchar driver_name[CRYPTO_MAX_ALG_NAME];\n\tchar hmac_name[CRYPTO_MAX_ALG_NAME];\n\tchar hmac_driver_name[CRYPTO_MAX_ALG_NAME];\n\tunsigned int blocksize;\n\tstruct ahash_alg template_ahash;\n\tu32 alg_type;\n};\n\n \nstatic struct caam_hash_template driver_hash[] = {\n\t{\n\t\t.name = \"sha1\",\n\t\t.driver_name = \"sha1-caam-qi2\",\n\t\t.hmac_name = \"hmac(sha1)\",\n\t\t.hmac_driver_name = \"hmac-sha1-caam-qi2\",\n\t\t.blocksize = SHA1_BLOCK_SIZE,\n\t\t.template_ahash = {\n\t\t\t.init = ahash_init,\n\t\t\t.update = ahash_update,\n\t\t\t.final = ahash_final,\n\t\t\t.finup = ahash_finup,\n\t\t\t.digest = ahash_digest,\n\t\t\t.export = ahash_export,\n\t\t\t.import = ahash_import,\n\t\t\t.setkey = ahash_setkey,\n\t\t\t.halg = {\n\t\t\t\t.digestsize = SHA1_DIGEST_SIZE,\n\t\t\t\t.statesize = sizeof(struct caam_export_state),\n\t\t\t},\n\t\t},\n\t\t.alg_type = OP_ALG_ALGSEL_SHA1,\n\t}, {\n\t\t.name = \"sha224\",\n\t\t.driver_name = \"sha224-caam-qi2\",\n\t\t.hmac_name = \"hmac(sha224)\",\n\t\t.hmac_driver_name = \"hmac-sha224-caam-qi2\",\n\t\t.blocksize = SHA224_BLOCK_SIZE,\n\t\t.template_ahash = {\n\t\t\t.init = ahash_init,\n\t\t\t.update = ahash_update,\n\t\t\t.final = ahash_final,\n\t\t\t.finup = ahash_finup,\n\t\t\t.digest = ahash_digest,\n\t\t\t.export = ahash_export,\n\t\t\t.import = ahash_import,\n\t\t\t.setkey = ahash_setkey,\n\t\t\t.halg = {\n\t\t\t\t.digestsize = SHA224_DIGEST_SIZE,\n\t\t\t\t.statesize = sizeof(struct caam_export_state),\n\t\t\t},\n\t\t},\n\t\t.alg_type = OP_ALG_ALGSEL_SHA224,\n\t}, {\n\t\t.name = \"sha256\",\n\t\t.driver_name = \"sha256-caam-qi2\",\n\t\t.hmac_name = \"hmac(sha256)\",\n\t\t.hmac_driver_name = \"hmac-sha256-caam-qi2\",\n\t\t.blocksize = SHA256_BLOCK_SIZE,\n\t\t.template_ahash = {\n\t\t\t.init = ahash_init,\n\t\t\t.update = ahash_update,\n\t\t\t.final = ahash_final,\n\t\t\t.finup = ahash_finup,\n\t\t\t.digest = ahash_digest,\n\t\t\t.export = ahash_export,\n\t\t\t.import = ahash_import,\n\t\t\t.setkey = ahash_setkey,\n\t\t\t.halg = {\n\t\t\t\t.digestsize = SHA256_DIGEST_SIZE,\n\t\t\t\t.statesize = sizeof(struct caam_export_state),\n\t\t\t},\n\t\t},\n\t\t.alg_type = OP_ALG_ALGSEL_SHA256,\n\t}, {\n\t\t.name = \"sha384\",\n\t\t.driver_name = \"sha384-caam-qi2\",\n\t\t.hmac_name = \"hmac(sha384)\",\n\t\t.hmac_driver_name = \"hmac-sha384-caam-qi2\",\n\t\t.blocksize = SHA384_BLOCK_SIZE,\n\t\t.template_ahash = {\n\t\t\t.init = ahash_init,\n\t\t\t.update = ahash_update,\n\t\t\t.final = ahash_final,\n\t\t\t.finup = ahash_finup,\n\t\t\t.digest = ahash_digest,\n\t\t\t.export = ahash_export,\n\t\t\t.import = ahash_import,\n\t\t\t.setkey = ahash_setkey,\n\t\t\t.halg = {\n\t\t\t\t.digestsize = SHA384_DIGEST_SIZE,\n\t\t\t\t.statesize = sizeof(struct caam_export_state),\n\t\t\t},\n\t\t},\n\t\t.alg_type = OP_ALG_ALGSEL_SHA384,\n\t}, {\n\t\t.name = \"sha512\",\n\t\t.driver_name = \"sha512-caam-qi2\",\n\t\t.hmac_name = \"hmac(sha512)\",\n\t\t.hmac_driver_name = \"hmac-sha512-caam-qi2\",\n\t\t.blocksize = SHA512_BLOCK_SIZE,\n\t\t.template_ahash = {\n\t\t\t.init = ahash_init,\n\t\t\t.update = ahash_update,\n\t\t\t.final = ahash_final,\n\t\t\t.finup = ahash_finup,\n\t\t\t.digest = ahash_digest,\n\t\t\t.export = ahash_export,\n\t\t\t.import = ahash_import,\n\t\t\t.setkey = ahash_setkey,\n\t\t\t.halg = {\n\t\t\t\t.digestsize = SHA512_DIGEST_SIZE,\n\t\t\t\t.statesize = sizeof(struct caam_export_state),\n\t\t\t},\n\t\t},\n\t\t.alg_type = OP_ALG_ALGSEL_SHA512,\n\t}, {\n\t\t.name = \"md5\",\n\t\t.driver_name = \"md5-caam-qi2\",\n\t\t.hmac_name = \"hmac(md5)\",\n\t\t.hmac_driver_name = \"hmac-md5-caam-qi2\",\n\t\t.blocksize = MD5_BLOCK_WORDS * 4,\n\t\t.template_ahash = {\n\t\t\t.init = ahash_init,\n\t\t\t.update = ahash_update,\n\t\t\t.final = ahash_final,\n\t\t\t.finup = ahash_finup,\n\t\t\t.digest = ahash_digest,\n\t\t\t.export = ahash_export,\n\t\t\t.import = ahash_import,\n\t\t\t.setkey = ahash_setkey,\n\t\t\t.halg = {\n\t\t\t\t.digestsize = MD5_DIGEST_SIZE,\n\t\t\t\t.statesize = sizeof(struct caam_export_state),\n\t\t\t},\n\t\t},\n\t\t.alg_type = OP_ALG_ALGSEL_MD5,\n\t}\n};\n\nstruct caam_hash_alg {\n\tstruct list_head entry;\n\tstruct device *dev;\n\tint alg_type;\n\tstruct ahash_alg ahash_alg;\n};\n\nstatic int caam_hash_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct crypto_ahash *ahash = __crypto_ahash_cast(tfm);\n\tstruct crypto_alg *base = tfm->__crt_alg;\n\tstruct hash_alg_common *halg =\n\t\t container_of(base, struct hash_alg_common, base);\n\tstruct ahash_alg *alg =\n\t\t container_of(halg, struct ahash_alg, halg);\n\tstruct caam_hash_alg *caam_hash =\n\t\t container_of(alg, struct caam_hash_alg, ahash_alg);\n\tstruct caam_hash_ctx *ctx = crypto_tfm_ctx_dma(tfm);\n\t \n\tstatic const u8 runninglen[] = { HASH_MSG_LEN + MD5_DIGEST_SIZE,\n\t\t\t\t\t HASH_MSG_LEN + SHA1_DIGEST_SIZE,\n\t\t\t\t\t HASH_MSG_LEN + 32,\n\t\t\t\t\t HASH_MSG_LEN + SHA256_DIGEST_SIZE,\n\t\t\t\t\t HASH_MSG_LEN + 64,\n\t\t\t\t\t HASH_MSG_LEN + SHA512_DIGEST_SIZE };\n\tdma_addr_t dma_addr;\n\tint i;\n\n\tctx->dev = caam_hash->dev;\n\n\tif (alg->setkey) {\n\t\tctx->adata.key_dma = dma_map_single_attrs(ctx->dev, ctx->key,\n\t\t\t\t\t\t\t  ARRAY_SIZE(ctx->key),\n\t\t\t\t\t\t\t  DMA_TO_DEVICE,\n\t\t\t\t\t\t\t  DMA_ATTR_SKIP_CPU_SYNC);\n\t\tif (dma_mapping_error(ctx->dev, ctx->adata.key_dma)) {\n\t\t\tdev_err(ctx->dev, \"unable to map key\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tdma_addr = dma_map_single_attrs(ctx->dev, ctx->flc, sizeof(ctx->flc),\n\t\t\t\t\tDMA_BIDIRECTIONAL,\n\t\t\t\t\tDMA_ATTR_SKIP_CPU_SYNC);\n\tif (dma_mapping_error(ctx->dev, dma_addr)) {\n\t\tdev_err(ctx->dev, \"unable to map shared descriptors\\n\");\n\t\tif (ctx->adata.key_dma)\n\t\t\tdma_unmap_single_attrs(ctx->dev, ctx->adata.key_dma,\n\t\t\t\t\t       ARRAY_SIZE(ctx->key),\n\t\t\t\t\t       DMA_TO_DEVICE,\n\t\t\t\t\t       DMA_ATTR_SKIP_CPU_SYNC);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < HASH_NUM_OP; i++)\n\t\tctx->flc_dma[i] = dma_addr + i * sizeof(ctx->flc[i]);\n\n\t \n\tctx->adata.algtype = OP_TYPE_CLASS2_ALG | caam_hash->alg_type;\n\n\tctx->ctx_len = runninglen[(ctx->adata.algtype &\n\t\t\t\t   OP_ALG_ALGSEL_SUBMASK) >>\n\t\t\t\t  OP_ALG_ALGSEL_SHIFT];\n\n\tcrypto_ahash_set_reqsize_dma(ahash, sizeof(struct caam_hash_state));\n\n\t \n\treturn alg->setkey ? 0 : ahash_set_sh_desc(ahash);\n}\n\nstatic void caam_hash_cra_exit(struct crypto_tfm *tfm)\n{\n\tstruct caam_hash_ctx *ctx = crypto_tfm_ctx_dma(tfm);\n\n\tdma_unmap_single_attrs(ctx->dev, ctx->flc_dma[0], sizeof(ctx->flc),\n\t\t\t       DMA_BIDIRECTIONAL, DMA_ATTR_SKIP_CPU_SYNC);\n\tif (ctx->adata.key_dma)\n\t\tdma_unmap_single_attrs(ctx->dev, ctx->adata.key_dma,\n\t\t\t\t       ARRAY_SIZE(ctx->key), DMA_TO_DEVICE,\n\t\t\t\t       DMA_ATTR_SKIP_CPU_SYNC);\n}\n\nstatic struct caam_hash_alg *caam_hash_alloc(struct device *dev,\n\tstruct caam_hash_template *template, bool keyed)\n{\n\tstruct caam_hash_alg *t_alg;\n\tstruct ahash_alg *halg;\n\tstruct crypto_alg *alg;\n\n\tt_alg = kzalloc(sizeof(*t_alg), GFP_KERNEL);\n\tif (!t_alg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tt_alg->ahash_alg = template->template_ahash;\n\thalg = &t_alg->ahash_alg;\n\talg = &halg->halg.base;\n\n\tif (keyed) {\n\t\tsnprintf(alg->cra_name, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t\t template->hmac_name);\n\t\tsnprintf(alg->cra_driver_name, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t\t template->hmac_driver_name);\n\t} else {\n\t\tsnprintf(alg->cra_name, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t\t template->name);\n\t\tsnprintf(alg->cra_driver_name, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t\t template->driver_name);\n\t\tt_alg->ahash_alg.setkey = NULL;\n\t}\n\talg->cra_module = THIS_MODULE;\n\talg->cra_init = caam_hash_cra_init;\n\talg->cra_exit = caam_hash_cra_exit;\n\talg->cra_ctxsize = sizeof(struct caam_hash_ctx) + crypto_dma_padding();\n\talg->cra_priority = CAAM_CRA_PRIORITY;\n\talg->cra_blocksize = template->blocksize;\n\talg->cra_alignmask = 0;\n\talg->cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY;\n\n\tt_alg->alg_type = template->alg_type;\n\tt_alg->dev = dev;\n\n\treturn t_alg;\n}\n\nstatic void dpaa2_caam_fqdan_cb(struct dpaa2_io_notification_ctx *nctx)\n{\n\tstruct dpaa2_caam_priv_per_cpu *ppriv;\n\n\tppriv = container_of(nctx, struct dpaa2_caam_priv_per_cpu, nctx);\n\tnapi_schedule_irqoff(&ppriv->napi);\n}\n\nstatic int __cold dpaa2_dpseci_dpio_setup(struct dpaa2_caam_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\tstruct dpaa2_io_notification_ctx *nctx;\n\tstruct dpaa2_caam_priv_per_cpu *ppriv;\n\tint err, i = 0, cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\tppriv = per_cpu_ptr(priv->ppriv, cpu);\n\t\tppriv->priv = priv;\n\t\tnctx = &ppriv->nctx;\n\t\tnctx->is_cdan = 0;\n\t\tnctx->id = ppriv->rsp_fqid;\n\t\tnctx->desired_cpu = cpu;\n\t\tnctx->cb = dpaa2_caam_fqdan_cb;\n\n\t\t \n\t\tppriv->dpio = dpaa2_io_service_select(cpu);\n\t\terr = dpaa2_io_service_register(ppriv->dpio, nctx, dev);\n\t\tif (unlikely(err)) {\n\t\t\tdev_dbg(dev, \"No affine DPIO for cpu %d\\n\", cpu);\n\t\t\tnctx->cb = NULL;\n\t\t\t \n\t\t\terr = -EPROBE_DEFER;\n\t\t\tgoto err;\n\t\t}\n\n\t\tppriv->store = dpaa2_io_store_create(DPAA2_CAAM_STORE_SIZE,\n\t\t\t\t\t\t     dev);\n\t\tif (unlikely(!ppriv->store)) {\n\t\t\tdev_err(dev, \"dpaa2_io_store_create() failed\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (++i == priv->num_pairs)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor_each_online_cpu(cpu) {\n\t\tppriv = per_cpu_ptr(priv->ppriv, cpu);\n\t\tif (!ppriv->nctx.cb)\n\t\t\tbreak;\n\t\tdpaa2_io_service_deregister(ppriv->dpio, &ppriv->nctx, dev);\n\t}\n\n\tfor_each_online_cpu(cpu) {\n\t\tppriv = per_cpu_ptr(priv->ppriv, cpu);\n\t\tif (!ppriv->store)\n\t\t\tbreak;\n\t\tdpaa2_io_store_destroy(ppriv->store);\n\t}\n\n\treturn err;\n}\n\nstatic void __cold dpaa2_dpseci_dpio_free(struct dpaa2_caam_priv *priv)\n{\n\tstruct dpaa2_caam_priv_per_cpu *ppriv;\n\tint i = 0, cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\tppriv = per_cpu_ptr(priv->ppriv, cpu);\n\t\tdpaa2_io_service_deregister(ppriv->dpio, &ppriv->nctx,\n\t\t\t\t\t    priv->dev);\n\t\tdpaa2_io_store_destroy(ppriv->store);\n\n\t\tif (++i == priv->num_pairs)\n\t\t\treturn;\n\t}\n}\n\nstatic int dpaa2_dpseci_bind(struct dpaa2_caam_priv *priv)\n{\n\tstruct dpseci_rx_queue_cfg rx_queue_cfg;\n\tstruct device *dev = priv->dev;\n\tstruct fsl_mc_device *ls_dev = to_fsl_mc_device(dev);\n\tstruct dpaa2_caam_priv_per_cpu *ppriv;\n\tint err = 0, i = 0, cpu;\n\n\t \n\tfor_each_online_cpu(cpu) {\n\t\tppriv = per_cpu_ptr(priv->ppriv, cpu);\n\n\t\trx_queue_cfg.options = DPSECI_QUEUE_OPT_DEST |\n\t\t\t\t       DPSECI_QUEUE_OPT_USER_CTX;\n\t\trx_queue_cfg.order_preservation_en = 0;\n\t\trx_queue_cfg.dest_cfg.dest_type = DPSECI_DEST_DPIO;\n\t\trx_queue_cfg.dest_cfg.dest_id = ppriv->nctx.dpio_id;\n\t\t \n\t\trx_queue_cfg.dest_cfg.priority = 0;\n\t\trx_queue_cfg.user_ctx = ppriv->nctx.qman64;\n\n\t\terr = dpseci_set_rx_queue(priv->mc_io, 0, ls_dev->mc_handle, i,\n\t\t\t\t\t  &rx_queue_cfg);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"dpseci_set_rx_queue() failed with err %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (++i == priv->num_pairs)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void dpaa2_dpseci_congestion_free(struct dpaa2_caam_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\n\tif (!priv->cscn_mem)\n\t\treturn;\n\n\tdma_unmap_single(dev, priv->cscn_dma, DPAA2_CSCN_SIZE, DMA_FROM_DEVICE);\n\tkfree(priv->cscn_mem);\n}\n\nstatic void dpaa2_dpseci_free(struct dpaa2_caam_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\tstruct fsl_mc_device *ls_dev = to_fsl_mc_device(dev);\n\tint err;\n\n\tif (DPSECI_VER(priv->major_ver, priv->minor_ver) > DPSECI_VER(5, 3)) {\n\t\terr = dpseci_reset(priv->mc_io, 0, ls_dev->mc_handle);\n\t\tif (err)\n\t\t\tdev_err(dev, \"dpseci_reset() failed\\n\");\n\t}\n\n\tdpaa2_dpseci_congestion_free(priv);\n\tdpseci_close(priv->mc_io, 0, ls_dev->mc_handle);\n}\n\nstatic void dpaa2_caam_process_fd(struct dpaa2_caam_priv *priv,\n\t\t\t\t  const struct dpaa2_fd *fd)\n{\n\tstruct caam_request *req;\n\tu32 fd_err;\n\n\tif (dpaa2_fd_get_format(fd) != dpaa2_fd_list) {\n\t\tdev_err(priv->dev, \"Only Frame List FD format is supported!\\n\");\n\t\treturn;\n\t}\n\n\tfd_err = dpaa2_fd_get_ctrl(fd) & FD_CTRL_ERR_MASK;\n\tif (unlikely(fd_err))\n\t\tdev_err_ratelimited(priv->dev, \"FD error: %08x\\n\", fd_err);\n\n\t \n\treq = dpaa2_caam_iova_to_virt(priv, dpaa2_fd_get_addr(fd));\n\tdma_unmap_single(priv->dev, req->fd_flt_dma, sizeof(req->fd_flt),\n\t\t\t DMA_BIDIRECTIONAL);\n\treq->cbk(req->ctx, dpaa2_fd_get_frc(fd));\n}\n\nstatic int dpaa2_caam_pull_fq(struct dpaa2_caam_priv_per_cpu *ppriv)\n{\n\tint err;\n\n\t \n\tdo {\n\t\terr = dpaa2_io_service_pull_fq(ppriv->dpio, ppriv->rsp_fqid,\n\t\t\t\t\t       ppriv->store);\n\t} while (err == -EBUSY);\n\n\tif (unlikely(err))\n\t\tdev_err(ppriv->priv->dev, \"dpaa2_io_service_pull err %d\", err);\n\n\treturn err;\n}\n\nstatic int dpaa2_caam_store_consume(struct dpaa2_caam_priv_per_cpu *ppriv)\n{\n\tstruct dpaa2_dq *dq;\n\tint cleaned = 0, is_last;\n\n\tdo {\n\t\tdq = dpaa2_io_store_next(ppriv->store, &is_last);\n\t\tif (unlikely(!dq)) {\n\t\t\tif (unlikely(!is_last)) {\n\t\t\t\tdev_dbg(ppriv->priv->dev,\n\t\t\t\t\t\"FQ %d returned no valid frames\\n\",\n\t\t\t\t\tppriv->rsp_fqid);\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tdpaa2_caam_process_fd(ppriv->priv, dpaa2_dq_fd(dq));\n\t\tcleaned++;\n\t} while (!is_last);\n\n\treturn cleaned;\n}\n\nstatic int dpaa2_dpseci_poll(struct napi_struct *napi, int budget)\n{\n\tstruct dpaa2_caam_priv_per_cpu *ppriv;\n\tstruct dpaa2_caam_priv *priv;\n\tint err, cleaned = 0, store_cleaned;\n\n\tppriv = container_of(napi, struct dpaa2_caam_priv_per_cpu, napi);\n\tpriv = ppriv->priv;\n\n\tif (unlikely(dpaa2_caam_pull_fq(ppriv)))\n\t\treturn 0;\n\n\tdo {\n\t\tstore_cleaned = dpaa2_caam_store_consume(ppriv);\n\t\tcleaned += store_cleaned;\n\n\t\tif (store_cleaned == 0 ||\n\t\t    cleaned > budget - DPAA2_CAAM_STORE_SIZE)\n\t\t\tbreak;\n\n\t\t \n\t\terr = dpaa2_caam_pull_fq(ppriv);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t} while (1);\n\n\tif (cleaned < budget) {\n\t\tnapi_complete_done(napi, cleaned);\n\t\terr = dpaa2_io_service_rearm(ppriv->dpio, &ppriv->nctx);\n\t\tif (unlikely(err))\n\t\t\tdev_err(priv->dev, \"Notification rearm failed: %d\\n\",\n\t\t\t\terr);\n\t}\n\n\treturn cleaned;\n}\n\nstatic int dpaa2_dpseci_congestion_setup(struct dpaa2_caam_priv *priv,\n\t\t\t\t\t u16 token)\n{\n\tstruct dpseci_congestion_notification_cfg cong_notif_cfg = { 0 };\n\tstruct device *dev = priv->dev;\n\tunsigned int alignmask;\n\tint err;\n\n\t \n\tif ((DPSECI_VER(priv->major_ver, priv->minor_ver) < DPSECI_VER(5, 1)) ||\n\t    !(priv->dpseci_attr.options & DPSECI_OPT_HAS_CG))\n\t\treturn 0;\n\n\talignmask = DPAA2_CSCN_ALIGN - 1;\n\talignmask |= dma_get_cache_alignment() - 1;\n\tpriv->cscn_mem = kzalloc(ALIGN(DPAA2_CSCN_SIZE, alignmask + 1),\n\t\t\t\t GFP_KERNEL);\n\tif (!priv->cscn_mem)\n\t\treturn -ENOMEM;\n\n\tpriv->cscn_dma = dma_map_single(dev, priv->cscn_mem,\n\t\t\t\t\tDPAA2_CSCN_SIZE, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, priv->cscn_dma)) {\n\t\tdev_err(dev, \"Error mapping CSCN memory area\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_dma_map;\n\t}\n\n\tcong_notif_cfg.units = DPSECI_CONGESTION_UNIT_BYTES;\n\tcong_notif_cfg.threshold_entry = DPAA2_SEC_CONG_ENTRY_THRESH;\n\tcong_notif_cfg.threshold_exit = DPAA2_SEC_CONG_EXIT_THRESH;\n\tcong_notif_cfg.message_ctx = (uintptr_t)priv;\n\tcong_notif_cfg.message_iova = priv->cscn_dma;\n\tcong_notif_cfg.notification_mode = DPSECI_CGN_MODE_WRITE_MEM_ON_ENTER |\n\t\t\t\t\tDPSECI_CGN_MODE_WRITE_MEM_ON_EXIT |\n\t\t\t\t\tDPSECI_CGN_MODE_COHERENT_WRITE;\n\n\terr = dpseci_set_congestion_notification(priv->mc_io, 0, token,\n\t\t\t\t\t\t &cong_notif_cfg);\n\tif (err) {\n\t\tdev_err(dev, \"dpseci_set_congestion_notification failed\\n\");\n\t\tgoto err_set_cong;\n\t}\n\n\treturn 0;\n\nerr_set_cong:\n\tdma_unmap_single(dev, priv->cscn_dma, DPAA2_CSCN_SIZE, DMA_FROM_DEVICE);\nerr_dma_map:\n\tkfree(priv->cscn_mem);\n\n\treturn err;\n}\n\nstatic int __cold dpaa2_dpseci_setup(struct fsl_mc_device *ls_dev)\n{\n\tstruct device *dev = &ls_dev->dev;\n\tstruct dpaa2_caam_priv *priv;\n\tstruct dpaa2_caam_priv_per_cpu *ppriv;\n\tint err, cpu;\n\tu8 i;\n\n\tpriv = dev_get_drvdata(dev);\n\n\tpriv->dev = dev;\n\tpriv->dpsec_id = ls_dev->obj_desc.id;\n\n\t \n\terr = dpseci_open(priv->mc_io, 0, priv->dpsec_id, &ls_dev->mc_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dpseci_open() failed: %d\\n\", err);\n\t\tgoto err_open;\n\t}\n\n\terr = dpseci_get_api_version(priv->mc_io, 0, &priv->major_ver,\n\t\t\t\t     &priv->minor_ver);\n\tif (err) {\n\t\tdev_err(dev, \"dpseci_get_api_version() failed\\n\");\n\t\tgoto err_get_vers;\n\t}\n\n\tdev_info(dev, \"dpseci v%d.%d\\n\", priv->major_ver, priv->minor_ver);\n\n\tif (DPSECI_VER(priv->major_ver, priv->minor_ver) > DPSECI_VER(5, 3)) {\n\t\terr = dpseci_reset(priv->mc_io, 0, ls_dev->mc_handle);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"dpseci_reset() failed\\n\");\n\t\t\tgoto err_get_vers;\n\t\t}\n\t}\n\n\terr = dpseci_get_attributes(priv->mc_io, 0, ls_dev->mc_handle,\n\t\t\t\t    &priv->dpseci_attr);\n\tif (err) {\n\t\tdev_err(dev, \"dpseci_get_attributes() failed\\n\");\n\t\tgoto err_get_vers;\n\t}\n\n\terr = dpseci_get_sec_attr(priv->mc_io, 0, ls_dev->mc_handle,\n\t\t\t\t  &priv->sec_attr);\n\tif (err) {\n\t\tdev_err(dev, \"dpseci_get_sec_attr() failed\\n\");\n\t\tgoto err_get_vers;\n\t}\n\n\terr = dpaa2_dpseci_congestion_setup(priv, ls_dev->mc_handle);\n\tif (err) {\n\t\tdev_err(dev, \"setup_congestion() failed\\n\");\n\t\tgoto err_get_vers;\n\t}\n\n\tpriv->num_pairs = min(priv->dpseci_attr.num_rx_queues,\n\t\t\t      priv->dpseci_attr.num_tx_queues);\n\tif (priv->num_pairs > num_online_cpus()) {\n\t\tdev_warn(dev, \"%d queues won't be used\\n\",\n\t\t\t priv->num_pairs - num_online_cpus());\n\t\tpriv->num_pairs = num_online_cpus();\n\t}\n\n\tfor (i = 0; i < priv->dpseci_attr.num_rx_queues; i++) {\n\t\terr = dpseci_get_rx_queue(priv->mc_io, 0, ls_dev->mc_handle, i,\n\t\t\t\t\t  &priv->rx_queue_attr[i]);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"dpseci_get_rx_queue() failed\\n\");\n\t\t\tgoto err_get_rx_queue;\n\t\t}\n\t}\n\n\tfor (i = 0; i < priv->dpseci_attr.num_tx_queues; i++) {\n\t\terr = dpseci_get_tx_queue(priv->mc_io, 0, ls_dev->mc_handle, i,\n\t\t\t\t\t  &priv->tx_queue_attr[i]);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"dpseci_get_tx_queue() failed\\n\");\n\t\t\tgoto err_get_rx_queue;\n\t\t}\n\t}\n\n\ti = 0;\n\tfor_each_online_cpu(cpu) {\n\t\tu8 j;\n\n\t\tj = i % priv->num_pairs;\n\n\t\tppriv = per_cpu_ptr(priv->ppriv, cpu);\n\t\tppriv->req_fqid = priv->tx_queue_attr[j].fqid;\n\n\t\t \n\t\tif (++i > priv->num_pairs)\n\t\t\tcontinue;\n\n\t\tppriv->rsp_fqid = priv->rx_queue_attr[j].fqid;\n\t\tppriv->prio = j;\n\n\t\tdev_dbg(dev, \"pair %d: rx queue %d, tx queue %d\\n\", j,\n\t\t\tpriv->rx_queue_attr[j].fqid,\n\t\t\tpriv->tx_queue_attr[j].fqid);\n\n\t\tppriv->net_dev.dev = *dev;\n\t\tINIT_LIST_HEAD(&ppriv->net_dev.napi_list);\n\t\tnetif_napi_add_tx_weight(&ppriv->net_dev, &ppriv->napi,\n\t\t\t\t\t dpaa2_dpseci_poll,\n\t\t\t\t\t DPAA2_CAAM_NAPI_WEIGHT);\n\t}\n\n\treturn 0;\n\nerr_get_rx_queue:\n\tdpaa2_dpseci_congestion_free(priv);\nerr_get_vers:\n\tdpseci_close(priv->mc_io, 0, ls_dev->mc_handle);\nerr_open:\n\treturn err;\n}\n\nstatic int dpaa2_dpseci_enable(struct dpaa2_caam_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\tstruct fsl_mc_device *ls_dev = to_fsl_mc_device(dev);\n\tstruct dpaa2_caam_priv_per_cpu *ppriv;\n\tint i;\n\n\tfor (i = 0; i < priv->num_pairs; i++) {\n\t\tppriv = per_cpu_ptr(priv->ppriv, i);\n\t\tnapi_enable(&ppriv->napi);\n\t}\n\n\treturn dpseci_enable(priv->mc_io, 0, ls_dev->mc_handle);\n}\n\nstatic int __cold dpaa2_dpseci_disable(struct dpaa2_caam_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\tstruct dpaa2_caam_priv_per_cpu *ppriv;\n\tstruct fsl_mc_device *ls_dev = to_fsl_mc_device(dev);\n\tint i, err = 0, enabled;\n\n\terr = dpseci_disable(priv->mc_io, 0, ls_dev->mc_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dpseci_disable() failed\\n\");\n\t\treturn err;\n\t}\n\n\terr = dpseci_is_enabled(priv->mc_io, 0, ls_dev->mc_handle, &enabled);\n\tif (err) {\n\t\tdev_err(dev, \"dpseci_is_enabled() failed\\n\");\n\t\treturn err;\n\t}\n\n\tdev_dbg(dev, \"disable: %s\\n\", enabled ? \"false\" : \"true\");\n\n\tfor (i = 0; i < priv->num_pairs; i++) {\n\t\tppriv = per_cpu_ptr(priv->ppriv, i);\n\t\tnapi_disable(&ppriv->napi);\n\t\tnetif_napi_del(&ppriv->napi);\n\t}\n\n\treturn 0;\n}\n\nstatic struct list_head hash_list;\n\nstatic int dpaa2_caam_probe(struct fsl_mc_device *dpseci_dev)\n{\n\tstruct device *dev;\n\tstruct dpaa2_caam_priv *priv;\n\tint i, err = 0;\n\tbool registered = false;\n\n\t \n\tcaam_little_end = true;\n\n\tcaam_imx = false;\n\n\tdev = &dpseci_dev->dev;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, priv);\n\n\tpriv->domain = iommu_get_domain_for_dev(dev);\n\n\tqi_cache = kmem_cache_create(\"dpaa2_caamqicache\", CAAM_QI_MEMCACHE_SIZE,\n\t\t\t\t     0, 0, NULL);\n\tif (!qi_cache) {\n\t\tdev_err(dev, \"Can't allocate SEC cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(49));\n\tif (err) {\n\t\tdev_err(dev, \"dma_set_mask_and_coherent() failed\\n\");\n\t\tgoto err_dma_mask;\n\t}\n\n\t \n\terr = fsl_mc_portal_allocate(dpseci_dev, 0, &priv->mc_io);\n\tif (err) {\n\t\tif (err == -ENXIO)\n\t\t\terr = -EPROBE_DEFER;\n\t\telse\n\t\t\tdev_err(dev, \"MC portal allocation failed\\n\");\n\n\t\tgoto err_dma_mask;\n\t}\n\n\tpriv->ppriv = alloc_percpu(*priv->ppriv);\n\tif (!priv->ppriv) {\n\t\tdev_err(dev, \"alloc_percpu() failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_ppriv;\n\t}\n\n\t \n\terr = dpaa2_dpseci_setup(dpseci_dev);\n\tif (err) {\n\t\tdev_err(dev, \"dpaa2_dpseci_setup() failed\\n\");\n\t\tgoto err_dpseci_setup;\n\t}\n\n\t \n\terr = dpaa2_dpseci_dpio_setup(priv);\n\tif (err) {\n\t\tdev_err_probe(dev, err, \"dpaa2_dpseci_dpio_setup() failed\\n\");\n\t\tgoto err_dpio_setup;\n\t}\n\n\t \n\terr = dpaa2_dpseci_bind(priv);\n\tif (err) {\n\t\tdev_err(dev, \"dpaa2_dpseci_bind() failed\\n\");\n\t\tgoto err_bind;\n\t}\n\n\t \n\terr = dpaa2_dpseci_enable(priv);\n\tif (err) {\n\t\tdev_err(dev, \"dpaa2_dpseci_enable() failed\\n\");\n\t\tgoto err_bind;\n\t}\n\n\tdpaa2_dpseci_debugfs_init(priv);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(driver_algs); i++) {\n\t\tstruct caam_skcipher_alg *t_alg = driver_algs + i;\n\t\tu32 alg_sel = t_alg->caam.class1_alg_type & OP_ALG_ALGSEL_MASK;\n\n\t\t \n\t\tif (!priv->sec_attr.des_acc_num &&\n\t\t    (alg_sel == OP_ALG_ALGSEL_3DES ||\n\t\t     alg_sel == OP_ALG_ALGSEL_DES))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!priv->sec_attr.aes_acc_num &&\n\t\t    alg_sel == OP_ALG_ALGSEL_AES)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (alg_sel == OP_ALG_ALGSEL_CHACHA20 &&\n\t\t    !priv->sec_attr.ccha_acc_num)\n\t\t\tcontinue;\n\n\t\tt_alg->caam.dev = dev;\n\t\tcaam_skcipher_alg_init(t_alg);\n\n\t\terr = crypto_register_skcipher(&t_alg->skcipher);\n\t\tif (err) {\n\t\t\tdev_warn(dev, \"%s alg registration failed: %d\\n\",\n\t\t\t\t t_alg->skcipher.base.cra_driver_name, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\tt_alg->registered = true;\n\t\tregistered = true;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(driver_aeads); i++) {\n\t\tstruct caam_aead_alg *t_alg = driver_aeads + i;\n\t\tu32 c1_alg_sel = t_alg->caam.class1_alg_type &\n\t\t\t\t OP_ALG_ALGSEL_MASK;\n\t\tu32 c2_alg_sel = t_alg->caam.class2_alg_type &\n\t\t\t\t OP_ALG_ALGSEL_MASK;\n\n\t\t \n\t\tif (!priv->sec_attr.des_acc_num &&\n\t\t    (c1_alg_sel == OP_ALG_ALGSEL_3DES ||\n\t\t     c1_alg_sel == OP_ALG_ALGSEL_DES))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!priv->sec_attr.aes_acc_num &&\n\t\t    c1_alg_sel == OP_ALG_ALGSEL_AES)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (c1_alg_sel == OP_ALG_ALGSEL_CHACHA20 &&\n\t\t    !priv->sec_attr.ccha_acc_num)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (c2_alg_sel == OP_ALG_ALGSEL_POLY1305 &&\n\t\t    !priv->sec_attr.ptha_acc_num)\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((c2_alg_sel & ~OP_ALG_ALGSEL_SUBMASK) == 0x40 &&\n\t\t    !priv->sec_attr.md_acc_num)\n\t\t\tcontinue;\n\n\t\tt_alg->caam.dev = dev;\n\t\tcaam_aead_alg_init(t_alg);\n\n\t\terr = crypto_register_aead(&t_alg->aead);\n\t\tif (err) {\n\t\t\tdev_warn(dev, \"%s alg registration failed: %d\\n\",\n\t\t\t\t t_alg->aead.base.cra_driver_name, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\tt_alg->registered = true;\n\t\tregistered = true;\n\t}\n\tif (registered)\n\t\tdev_info(dev, \"algorithms registered in /proc/crypto\\n\");\n\n\t \n\tINIT_LIST_HEAD(&hash_list);\n\n\t \n\tif (!priv->sec_attr.md_acc_num)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(driver_hash); i++) {\n\t\tstruct caam_hash_alg *t_alg;\n\t\tstruct caam_hash_template *alg = driver_hash + i;\n\n\t\t \n\t\tt_alg = caam_hash_alloc(dev, alg, true);\n\t\tif (IS_ERR(t_alg)) {\n\t\t\terr = PTR_ERR(t_alg);\n\t\t\tdev_warn(dev, \"%s hash alg allocation failed: %d\\n\",\n\t\t\t\t alg->hmac_driver_name, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = crypto_register_ahash(&t_alg->ahash_alg);\n\t\tif (err) {\n\t\t\tdev_warn(dev, \"%s alg registration failed: %d\\n\",\n\t\t\t\t t_alg->ahash_alg.halg.base.cra_driver_name,\n\t\t\t\t err);\n\t\t\tkfree(t_alg);\n\t\t} else {\n\t\t\tlist_add_tail(&t_alg->entry, &hash_list);\n\t\t}\n\n\t\t \n\t\tt_alg = caam_hash_alloc(dev, alg, false);\n\t\tif (IS_ERR(t_alg)) {\n\t\t\terr = PTR_ERR(t_alg);\n\t\t\tdev_warn(dev, \"%s alg allocation failed: %d\\n\",\n\t\t\t\t alg->driver_name, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = crypto_register_ahash(&t_alg->ahash_alg);\n\t\tif (err) {\n\t\t\tdev_warn(dev, \"%s alg registration failed: %d\\n\",\n\t\t\t\t t_alg->ahash_alg.halg.base.cra_driver_name,\n\t\t\t\t err);\n\t\t\tkfree(t_alg);\n\t\t} else {\n\t\t\tlist_add_tail(&t_alg->entry, &hash_list);\n\t\t}\n\t}\n\tif (!list_empty(&hash_list))\n\t\tdev_info(dev, \"hash algorithms registered in /proc/crypto\\n\");\n\n\treturn err;\n\nerr_bind:\n\tdpaa2_dpseci_dpio_free(priv);\nerr_dpio_setup:\n\tdpaa2_dpseci_free(priv);\nerr_dpseci_setup:\n\tfree_percpu(priv->ppriv);\nerr_alloc_ppriv:\n\tfsl_mc_portal_free(priv->mc_io);\nerr_dma_mask:\n\tkmem_cache_destroy(qi_cache);\n\n\treturn err;\n}\n\nstatic void __cold dpaa2_caam_remove(struct fsl_mc_device *ls_dev)\n{\n\tstruct device *dev;\n\tstruct dpaa2_caam_priv *priv;\n\tint i;\n\n\tdev = &ls_dev->dev;\n\tpriv = dev_get_drvdata(dev);\n\n\tdpaa2_dpseci_debugfs_exit(priv);\n\n\tfor (i = 0; i < ARRAY_SIZE(driver_aeads); i++) {\n\t\tstruct caam_aead_alg *t_alg = driver_aeads + i;\n\n\t\tif (t_alg->registered)\n\t\t\tcrypto_unregister_aead(&t_alg->aead);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(driver_algs); i++) {\n\t\tstruct caam_skcipher_alg *t_alg = driver_algs + i;\n\n\t\tif (t_alg->registered)\n\t\t\tcrypto_unregister_skcipher(&t_alg->skcipher);\n\t}\n\n\tif (hash_list.next) {\n\t\tstruct caam_hash_alg *t_hash_alg, *p;\n\n\t\tlist_for_each_entry_safe(t_hash_alg, p, &hash_list, entry) {\n\t\t\tcrypto_unregister_ahash(&t_hash_alg->ahash_alg);\n\t\t\tlist_del(&t_hash_alg->entry);\n\t\t\tkfree(t_hash_alg);\n\t\t}\n\t}\n\n\tdpaa2_dpseci_disable(priv);\n\tdpaa2_dpseci_dpio_free(priv);\n\tdpaa2_dpseci_free(priv);\n\tfree_percpu(priv->ppriv);\n\tfsl_mc_portal_free(priv->mc_io);\n\tkmem_cache_destroy(qi_cache);\n}\n\nint dpaa2_caam_enqueue(struct device *dev, struct caam_request *req)\n{\n\tstruct dpaa2_fd fd;\n\tstruct dpaa2_caam_priv *priv = dev_get_drvdata(dev);\n\tstruct dpaa2_caam_priv_per_cpu *ppriv;\n\tint err = 0, i;\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tif (priv->cscn_mem) {\n\t\tdma_sync_single_for_cpu(priv->dev, priv->cscn_dma,\n\t\t\t\t\tDPAA2_CSCN_SIZE,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tif (unlikely(dpaa2_cscn_state_congested(priv->cscn_mem))) {\n\t\t\tdev_dbg_ratelimited(dev, \"Dropping request\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tdpaa2_fl_set_flc(&req->fd_flt[1], req->flc_dma);\n\n\treq->fd_flt_dma = dma_map_single(dev, req->fd_flt, sizeof(req->fd_flt),\n\t\t\t\t\t DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dev, req->fd_flt_dma)) {\n\t\tdev_err(dev, \"DMA mapping error for QI enqueue request\\n\");\n\t\tgoto err_out;\n\t}\n\n\tmemset(&fd, 0, sizeof(fd));\n\tdpaa2_fd_set_format(&fd, dpaa2_fd_list);\n\tdpaa2_fd_set_addr(&fd, req->fd_flt_dma);\n\tdpaa2_fd_set_len(&fd, dpaa2_fl_get_len(&req->fd_flt[1]));\n\tdpaa2_fd_set_flc(&fd, req->flc_dma);\n\n\tppriv = raw_cpu_ptr(priv->ppriv);\n\tfor (i = 0; i < (priv->dpseci_attr.num_tx_queues << 1); i++) {\n\t\terr = dpaa2_io_service_enqueue_fq(ppriv->dpio, ppriv->req_fqid,\n\t\t\t\t\t\t  &fd);\n\t\tif (err != -EBUSY)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\tif (unlikely(err)) {\n\t\tdev_err_ratelimited(dev, \"Error enqueuing frame: %d\\n\", err);\n\t\tgoto err_out;\n\t}\n\n\treturn -EINPROGRESS;\n\nerr_out:\n\tdma_unmap_single(dev, req->fd_flt_dma, sizeof(req->fd_flt),\n\t\t\t DMA_BIDIRECTIONAL);\n\treturn -EIO;\n}\nEXPORT_SYMBOL(dpaa2_caam_enqueue);\n\nstatic const struct fsl_mc_device_id dpaa2_caam_match_id_table[] = {\n\t{\n\t\t.vendor = FSL_MC_VENDOR_FREESCALE,\n\t\t.obj_type = \"dpseci\",\n\t},\n\t{ .vendor = 0x0 }\n};\nMODULE_DEVICE_TABLE(fslmc, dpaa2_caam_match_id_table);\n\nstatic struct fsl_mc_driver dpaa2_caam_driver = {\n\t.driver = {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.owner\t\t= THIS_MODULE,\n\t},\n\t.probe\t\t= dpaa2_caam_probe,\n\t.remove\t\t= dpaa2_caam_remove,\n\t.match_id_table = dpaa2_caam_match_id_table\n};\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc\");\nMODULE_DESCRIPTION(\"Freescale DPAA2 CAAM Driver\");\n\nmodule_fsl_mc_driver(dpaa2_caam_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}