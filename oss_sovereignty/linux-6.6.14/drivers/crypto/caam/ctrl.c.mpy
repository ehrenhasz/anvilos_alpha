{
  "module_name": "ctrl.c",
  "hash_id": "8977e15cbbc81997013fde2661a7ca324a3632efc2d41531c85f05aab3b44e26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/caam/ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/sys_soc.h>\n#include <linux/fsl/mc.h>\n\n#include \"compat.h\"\n#include \"debugfs.h\"\n#include \"regs.h\"\n#include \"intern.h\"\n#include \"jr.h\"\n#include \"desc_constr.h\"\n#include \"ctrl.h\"\n\nbool caam_dpaa2;\nEXPORT_SYMBOL(caam_dpaa2);\n\n#ifdef CONFIG_CAAM_QI\n#include \"qi.h\"\n#endif\n\n \nstatic void build_instantiation_desc(u32 *desc, int handle, int do_sk)\n{\n\tu32 *jump_cmd, op_flags;\n\n\tinit_job_desc(desc, 0);\n\n\top_flags = OP_TYPE_CLASS1_ALG | OP_ALG_ALGSEL_RNG |\n\t\t\t(handle << OP_ALG_AAI_SHIFT) | OP_ALG_AS_INIT |\n\t\t\tOP_ALG_PR_ON;\n\n\t \n\tappend_operation(desc, op_flags);\n\n\tif (!handle && do_sk) {\n\t\t \n\n\t\t \n\t\tjump_cmd = append_jump(desc, JUMP_CLASS_CLASS1);\n\t\tset_jump_tgt_here(desc, jump_cmd);\n\n\t\t \n\t\tappend_load_imm_u32(desc, 1, LDST_SRCDST_WORD_CLRW);\n\n\t\t \n\t\tappend_operation(desc, OP_TYPE_CLASS1_ALG | OP_ALG_ALGSEL_RNG |\n\t\t\t\t OP_ALG_AAI_RNG4_SK);\n\t}\n\n\tappend_jump(desc, JUMP_CLASS_CLASS1 | JUMP_TYPE_HALT);\n}\n\n \nstatic void build_deinstantiation_desc(u32 *desc, int handle)\n{\n\tinit_job_desc(desc, 0);\n\n\t \n\tappend_operation(desc, OP_TYPE_CLASS1_ALG | OP_ALG_ALGSEL_RNG |\n\t\t\t (handle << OP_ALG_AAI_SHIFT) | OP_ALG_AS_INITFINAL);\n\n\tappend_jump(desc, JUMP_CLASS_CLASS1 | JUMP_TYPE_HALT);\n}\n\nstatic const struct of_device_id imx8m_machine_match[] = {\n\t{ .compatible = \"fsl,imx8mm\", },\n\t{ .compatible = \"fsl,imx8mn\", },\n\t{ .compatible = \"fsl,imx8mp\", },\n\t{ .compatible = \"fsl,imx8mq\", },\n\t{ .compatible = \"fsl,imx8ulp\", },\n\t{ }\n};\n\n \nstatic inline int run_descriptor_deco0(struct device *ctrldev, u32 *desc,\n\t\t\t\t\tu32 *status)\n{\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(ctrldev);\n\tstruct caam_ctrl __iomem *ctrl = ctrlpriv->ctrl;\n\tstruct caam_deco __iomem *deco = ctrlpriv->deco;\n\tunsigned int timeout = 100000;\n\tu32 deco_dbg_reg, deco_state, flags;\n\tint i;\n\n\n\tif (ctrlpriv->virt_en == 1 ||\n\t     \n\t    of_match_node(imx8m_machine_match, of_root)) {\n\t\tclrsetbits_32(&ctrl->deco_rsr, 0, DECORSR_JR0);\n\n\t\twhile (!(rd_reg32(&ctrl->deco_rsr) & DECORSR_VALID) &&\n\t\t       --timeout)\n\t\t\tcpu_relax();\n\n\t\ttimeout = 100000;\n\t}\n\n\tclrsetbits_32(&ctrl->deco_rq, 0, DECORR_RQD0ENABLE);\n\n\twhile (!(rd_reg32(&ctrl->deco_rq) & DECORR_DEN0) &&\n\t\t\t\t\t\t\t\t --timeout)\n\t\tcpu_relax();\n\n\tif (!timeout) {\n\t\tdev_err(ctrldev, \"failed to acquire DECO 0\\n\");\n\t\tclrsetbits_32(&ctrl->deco_rq, DECORR_RQD0ENABLE, 0);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < desc_len(desc); i++)\n\t\twr_reg32(&deco->descbuf[i], caam32_to_cpu(*(desc + i)));\n\n\tflags = DECO_JQCR_WHL;\n\t \n\tif (desc_len(desc) >= 4)\n\t\tflags |= DECO_JQCR_FOUR;\n\n\t \n\tclrsetbits_32(&deco->jr_ctl_hi, 0, flags);\n\n\ttimeout = 10000000;\n\tdo {\n\t\tdeco_dbg_reg = rd_reg32(&deco->desc_dbg);\n\n\t\tif (ctrlpriv->era < 10)\n\t\t\tdeco_state = (deco_dbg_reg & DESC_DBG_DECO_STAT_MASK) >>\n\t\t\t\t     DESC_DBG_DECO_STAT_SHIFT;\n\t\telse\n\t\t\tdeco_state = (rd_reg32(&deco->dbg_exec) &\n\t\t\t\t      DESC_DER_DECO_STAT_MASK) >>\n\t\t\t\t     DESC_DER_DECO_STAT_SHIFT;\n\n\t\t \n\t\tif (deco_state == DECO_STAT_HOST_ERR)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t} while ((deco_dbg_reg & DESC_DBG_DECO_STAT_VALID) && --timeout);\n\n\t*status = rd_reg32(&deco->op_status_hi) &\n\t\t  DECO_OP_STATUS_HI_ERR_MASK;\n\n\tif (ctrlpriv->virt_en == 1)\n\t\tclrsetbits_32(&ctrl->deco_rsr, DECORSR_JR0, 0);\n\n\t \n\tclrsetbits_32(&ctrl->deco_rq, DECORR_RQD0ENABLE, 0);\n\n\tif (!timeout)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\n \nstatic int deinstantiate_rng(struct device *ctrldev, int state_handle_mask)\n{\n\tu32 *desc, status;\n\tint sh_idx, ret = 0;\n\n\tdesc = kmalloc(CAAM_CMD_SZ * 3, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tfor (sh_idx = 0; sh_idx < RNG4_MAX_HANDLES; sh_idx++) {\n\t\t \n\t\tif ((1 << sh_idx) & state_handle_mask) {\n\t\t\t \n\t\t\tbuild_deinstantiation_desc(desc, sh_idx);\n\n\t\t\t \n\t\t\tret = run_descriptor_deco0(ctrldev, desc, &status);\n\n\t\t\tif (ret ||\n\t\t\t    (status && status != JRSTA_SSRC_JUMP_HALT_CC)) {\n\t\t\t\tdev_err(ctrldev,\n\t\t\t\t\t\"Failed to deinstantiate RNG4 SH%d\\n\",\n\t\t\t\t\tsh_idx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_info(ctrldev, \"Deinstantiated RNG4 SH%d\\n\", sh_idx);\n\t\t}\n\t}\n\n\tkfree(desc);\n\n\treturn ret;\n}\n\nstatic void devm_deinstantiate_rng(void *data)\n{\n\tstruct device *ctrldev = data;\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(ctrldev);\n\n\t \n\tif (ctrlpriv->rng4_sh_init)\n\t\tdeinstantiate_rng(ctrldev, ctrlpriv->rng4_sh_init);\n}\n\n \nstatic int instantiate_rng(struct device *ctrldev, int state_handle_mask,\n\t\t\t   int gen_sk)\n{\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(ctrldev);\n\tstruct caam_ctrl __iomem *ctrl;\n\tu32 *desc, status = 0, rdsta_val;\n\tint ret = 0, sh_idx;\n\n\tctrl = (struct caam_ctrl __iomem *)ctrlpriv->ctrl;\n\tdesc = kmalloc(CAAM_CMD_SZ * 7, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tfor (sh_idx = 0; sh_idx < RNG4_MAX_HANDLES; sh_idx++) {\n\t\tconst u32 rdsta_if = RDSTA_IF0 << sh_idx;\n\t\tconst u32 rdsta_pr = RDSTA_PR0 << sh_idx;\n\t\tconst u32 rdsta_mask = rdsta_if | rdsta_pr;\n\n\t\t \n\t\tmemset(desc, 0x00, CAAM_CMD_SZ * 7);\n\n\t\t \n\t\tif (rdsta_if & state_handle_mask) {\n\t\t\tif (rdsta_pr & state_handle_mask)\n\t\t\t\tcontinue;\n\n\t\t\tdev_info(ctrldev,\n\t\t\t\t \"RNG4 SH%d was previously instantiated without prediction resistance. Tearing it down\\n\",\n\t\t\t\t sh_idx);\n\n\t\t\tret = deinstantiate_rng(ctrldev, rdsta_if);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tbuild_instantiation_desc(desc, sh_idx, gen_sk);\n\n\t\t \n\t\tret = run_descriptor_deco0(ctrldev, desc, &status);\n\n\t\t \n\t\tif (ret)\n\t\t\tbreak;\n\n\t\trdsta_val = rd_reg32(&ctrl->r4tst[0].rdsta) & RDSTA_MASK;\n\t\tif ((status && status != JRSTA_SSRC_JUMP_HALT_CC) ||\n\t\t    (rdsta_val & rdsta_mask) != rdsta_mask) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_info(ctrldev, \"Instantiated RNG4 SH%d\\n\", sh_idx);\n\t}\n\n\tkfree(desc);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(ctrldev, devm_deinstantiate_rng, ctrldev);\n}\n\n \nstatic void kick_trng(struct device *dev, int ent_delay)\n{\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(dev);\n\tstruct caam_ctrl __iomem *ctrl;\n\tstruct rng4tst __iomem *r4tst;\n\tu32 val, rtsdctl;\n\n\tctrl = (struct caam_ctrl __iomem *)ctrlpriv->ctrl;\n\tr4tst = &ctrl->r4tst[0];\n\n\t \n\tclrsetbits_32(&r4tst->rtmctl, 0, RTMCTL_PRGM | RTMCTL_ACC);\n\n\t \n\trtsdctl = rd_reg32(&r4tst->rtsdctl);\n\tval = (rtsdctl & RTSDCTL_ENT_DLY_MASK) >> RTSDCTL_ENT_DLY_SHIFT;\n\tif (ent_delay > val) {\n\t\tval = ent_delay;\n\t\t \n\t\twr_reg32(&r4tst->rtfrqmin, val >> 2);\n\t\t \n\t\twr_reg32(&r4tst->rtfrqmax, RTFRQMAX_DISABLE);\n\t}\n\n\twr_reg32(&r4tst->rtsdctl, (val << RTSDCTL_ENT_DLY_SHIFT) |\n\t\t RTSDCTL_SAMP_SIZE_VAL);\n\n\t \n\tif ((rtsdctl & RTSDCTL_SAMP_SIZE_MASK) != RTSDCTL_SAMP_SIZE_VAL) {\n\t\twr_reg32(&r4tst->rtscmisc, (2 << 16) | 32);\n\t\twr_reg32(&r4tst->rtpkrrng, 570);\n\t\twr_reg32(&r4tst->rtpkrmax, 1600);\n\t\twr_reg32(&r4tst->rtscml, (122 << 16) | 317);\n\t\twr_reg32(&r4tst->rtscrl[0], (80 << 16) | 107);\n\t\twr_reg32(&r4tst->rtscrl[1], (57 << 16) | 62);\n\t\twr_reg32(&r4tst->rtscrl[2], (39 << 16) | 39);\n\t\twr_reg32(&r4tst->rtscrl[3], (27 << 16) | 26);\n\t\twr_reg32(&r4tst->rtscrl[4], (19 << 16) | 18);\n\t\twr_reg32(&r4tst->rtscrl[5], (18 << 16) | 17);\n\t}\n\n\t \n\tclrsetbits_32(&r4tst->rtmctl, RTMCTL_PRGM | RTMCTL_ACC,\n\t\t      RTMCTL_SAMP_MODE_RAW_ES_SC);\n}\n\nstatic int caam_get_era_from_hw(struct caam_perfmon __iomem *perfmon)\n{\n\tstatic const struct {\n\t\tu16 ip_id;\n\t\tu8 maj_rev;\n\t\tu8 era;\n\t} id[] = {\n\t\t{0x0A10, 1, 1},\n\t\t{0x0A10, 2, 2},\n\t\t{0x0A12, 1, 3},\n\t\t{0x0A14, 1, 3},\n\t\t{0x0A14, 2, 4},\n\t\t{0x0A16, 1, 4},\n\t\t{0x0A10, 3, 4},\n\t\t{0x0A11, 1, 4},\n\t\t{0x0A18, 1, 4},\n\t\t{0x0A11, 2, 5},\n\t\t{0x0A12, 2, 5},\n\t\t{0x0A13, 1, 5},\n\t\t{0x0A1C, 1, 5}\n\t};\n\tu32 ccbvid, id_ms;\n\tu8 maj_rev, era;\n\tu16 ip_id;\n\tint i;\n\n\tccbvid = rd_reg32(&perfmon->ccb_id);\n\tera = (ccbvid & CCBVID_ERA_MASK) >> CCBVID_ERA_SHIFT;\n\tif (era)\t \n\t\treturn era;\n\n\tid_ms = rd_reg32(&perfmon->caam_id_ms);\n\tip_id = (id_ms & SECVID_MS_IPID_MASK) >> SECVID_MS_IPID_SHIFT;\n\tmaj_rev = (id_ms & SECVID_MS_MAJ_REV_MASK) >> SECVID_MS_MAJ_REV_SHIFT;\n\n\tfor (i = 0; i < ARRAY_SIZE(id); i++)\n\t\tif (id[i].ip_id == ip_id && id[i].maj_rev == maj_rev)\n\t\t\treturn id[i].era;\n\n\treturn -ENOTSUPP;\n}\n\n \nstatic int caam_get_era(struct caam_perfmon __iomem *perfmon)\n{\n\tstruct device_node *caam_node;\n\tint ret;\n\tu32 prop;\n\n\tcaam_node = of_find_compatible_node(NULL, NULL, \"fsl,sec-v4.0\");\n\tret = of_property_read_u32(caam_node, \"fsl,sec-era\", &prop);\n\tof_node_put(caam_node);\n\n\tif (!ret)\n\t\treturn prop;\n\telse\n\t\treturn caam_get_era_from_hw(perfmon);\n}\n\n \nstatic void handle_imx6_err005766(u32 __iomem *mcr)\n{\n\tif (of_machine_is_compatible(\"fsl,imx6q\") ||\n\t    of_machine_is_compatible(\"fsl,imx6dl\") ||\n\t    of_machine_is_compatible(\"fsl,imx6qp\"))\n\t\tclrsetbits_32(mcr, MCFGR_AXIPIPE_MASK,\n\t\t\t      1 << MCFGR_AXIPIPE_SHIFT);\n}\n\nstatic const struct of_device_id caam_match[] = {\n\t{\n\t\t.compatible = \"fsl,sec-v4.0\",\n\t},\n\t{\n\t\t.compatible = \"fsl,sec4.0\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, caam_match);\n\nstruct caam_imx_data {\n\tconst struct clk_bulk_data *clks;\n\tint num_clks;\n};\n\nstatic const struct clk_bulk_data caam_imx6_clks[] = {\n\t{ .id = \"ipg\" },\n\t{ .id = \"mem\" },\n\t{ .id = \"aclk\" },\n\t{ .id = \"emi_slow\" },\n};\n\nstatic const struct caam_imx_data caam_imx6_data = {\n\t.clks = caam_imx6_clks,\n\t.num_clks = ARRAY_SIZE(caam_imx6_clks),\n};\n\nstatic const struct clk_bulk_data caam_imx7_clks[] = {\n\t{ .id = \"ipg\" },\n\t{ .id = \"aclk\" },\n};\n\nstatic const struct caam_imx_data caam_imx7_data = {\n\t.clks = caam_imx7_clks,\n\t.num_clks = ARRAY_SIZE(caam_imx7_clks),\n};\n\nstatic const struct clk_bulk_data caam_imx6ul_clks[] = {\n\t{ .id = \"ipg\" },\n\t{ .id = \"mem\" },\n\t{ .id = \"aclk\" },\n};\n\nstatic const struct caam_imx_data caam_imx6ul_data = {\n\t.clks = caam_imx6ul_clks,\n\t.num_clks = ARRAY_SIZE(caam_imx6ul_clks),\n};\n\nstatic const struct clk_bulk_data caam_vf610_clks[] = {\n\t{ .id = \"ipg\" },\n};\n\nstatic const struct caam_imx_data caam_vf610_data = {\n\t.clks = caam_vf610_clks,\n\t.num_clks = ARRAY_SIZE(caam_vf610_clks),\n};\n\nstatic const struct soc_device_attribute caam_imx_soc_table[] = {\n\t{ .soc_id = \"i.MX6UL\", .data = &caam_imx6ul_data },\n\t{ .soc_id = \"i.MX6*\",  .data = &caam_imx6_data },\n\t{ .soc_id = \"i.MX7*\",  .data = &caam_imx7_data },\n\t{ .soc_id = \"i.MX8M*\", .data = &caam_imx7_data },\n\t{ .soc_id = \"VF*\",     .data = &caam_vf610_data },\n\t{ .family = \"Freescale i.MX\" },\n\t{   }\n};\n\nstatic void disable_clocks(void *data)\n{\n\tstruct caam_drv_private *ctrlpriv = data;\n\n\tclk_bulk_disable_unprepare(ctrlpriv->num_clks, ctrlpriv->clks);\n}\n\nstatic int init_clocks(struct device *dev, const struct caam_imx_data *data)\n{\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(dev);\n\tint ret;\n\n\tctrlpriv->num_clks = data->num_clks;\n\tctrlpriv->clks = devm_kmemdup(dev, data->clks,\n\t\t\t\t      data->num_clks * sizeof(data->clks[0]),\n\t\t\t\t      GFP_KERNEL);\n\tif (!ctrlpriv->clks)\n\t\treturn -ENOMEM;\n\n\tret = devm_clk_bulk_get(dev, ctrlpriv->num_clks, ctrlpriv->clks);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to request all necessary clocks\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_bulk_prepare_enable(ctrlpriv->num_clks, ctrlpriv->clks);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to prepare/enable all necessary clocks\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_add_action_or_reset(dev, disable_clocks, ctrlpriv);\n}\n\nstatic void caam_remove_debugfs(void *root)\n{\n\tdebugfs_remove_recursive(root);\n}\n\n#ifdef CONFIG_FSL_MC_BUS\nstatic bool check_version(struct fsl_mc_version *mc_version, u32 major,\n\t\t\t  u32 minor, u32 revision)\n{\n\tif (mc_version->major > major)\n\t\treturn true;\n\n\tif (mc_version->major == major) {\n\t\tif (mc_version->minor > minor)\n\t\t\treturn true;\n\n\t\tif (mc_version->minor == minor &&\n\t\t    mc_version->revision > revision)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n#endif\n\nstatic bool needs_entropy_delay_adjustment(void)\n{\n\tif (of_machine_is_compatible(\"fsl,imx6sx\"))\n\t\treturn true;\n\treturn false;\n}\n\nstatic int caam_ctrl_rng_init(struct device *dev)\n{\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(dev);\n\tstruct caam_ctrl __iomem *ctrl = ctrlpriv->ctrl;\n\tint ret, gen_sk, ent_delay = RTSDCTL_ENT_DLY_MIN;\n\tu8 rng_vid;\n\n\tif (ctrlpriv->era < 10) {\n\t\tstruct caam_perfmon __iomem *perfmon;\n\n\t\tperfmon = ctrlpriv->total_jobrs ?\n\t\t\t  (struct caam_perfmon __iomem *)&ctrlpriv->jr[0]->perfmon :\n\t\t\t  (struct caam_perfmon __iomem *)&ctrl->perfmon;\n\n\t\trng_vid = (rd_reg32(&perfmon->cha_id_ls) &\n\t\t\t   CHA_ID_LS_RNG_MASK) >> CHA_ID_LS_RNG_SHIFT;\n\t} else {\n\t\tstruct version_regs __iomem *vreg;\n\n\t\tvreg = ctrlpriv->total_jobrs ?\n\t\t\t(struct version_regs __iomem *)&ctrlpriv->jr[0]->vreg :\n\t\t\t(struct version_regs __iomem *)&ctrl->vreg;\n\n\t\trng_vid = (rd_reg32(&vreg->rng) & CHA_VER_VID_MASK) >>\n\t\t\t  CHA_VER_VID_SHIFT;\n\t}\n\n\t \n\tif (!(ctrlpriv->mc_en && ctrlpriv->pr_support) && rng_vid >= 4) {\n\t\tctrlpriv->rng4_sh_init =\n\t\t\trd_reg32(&ctrl->r4tst[0].rdsta);\n\t\t \n\t\tgen_sk = ctrlpriv->rng4_sh_init & RDSTA_SKVN ? 0 : 1;\n\t\tctrlpriv->rng4_sh_init &= RDSTA_MASK;\n\t\tdo {\n\t\t\tint inst_handles =\n\t\t\t\trd_reg32(&ctrl->r4tst[0].rdsta) & RDSTA_MASK;\n\t\t\t \n\t\t\tif (needs_entropy_delay_adjustment())\n\t\t\t\tent_delay = 12000;\n\t\t\tif (!(ctrlpriv->rng4_sh_init || inst_handles)) {\n\t\t\t\tdev_info(dev,\n\t\t\t\t\t \"Entropy delay = %u\\n\",\n\t\t\t\t\t ent_delay);\n\t\t\t\tkick_trng(dev, ent_delay);\n\t\t\t\tent_delay += 400;\n\t\t\t}\n\t\t\t \n\t\t\tret = instantiate_rng(dev, inst_handles,\n\t\t\t\t\t      gen_sk);\n\t\t\t \n\t\t\tif (needs_entropy_delay_adjustment())\n\t\t\t\tbreak;\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\t \n\t\t\t\tcpu_relax();\n\t\t} while ((ret == -EAGAIN) && (ent_delay < RTSDCTL_ENT_DLY_MAX));\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to instantiate RNG\");\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tctrlpriv->rng4_sh_init = ~ctrlpriv->rng4_sh_init & RDSTA_MASK;\n\n\t\t \n\t\tclrsetbits_32(&ctrl->scfgr, 0, SCFGR_RDBENABLE);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int caam_off_during_pm(void)\n{\n\tbool not_off_during_pm = of_machine_is_compatible(\"fsl,imx6q\") ||\n\t\t\t\t of_machine_is_compatible(\"fsl,imx6qp\") ||\n\t\t\t\t of_machine_is_compatible(\"fsl,imx6dl\");\n\n\treturn not_off_during_pm ? 0 : 1;\n}\n\nstatic void caam_state_save(struct device *dev)\n{\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(dev);\n\tstruct caam_ctl_state *state = &ctrlpriv->state;\n\tstruct caam_ctrl __iomem *ctrl = ctrlpriv->ctrl;\n\tu32 deco_inst, jr_inst;\n\tint i;\n\n\tstate->mcr = rd_reg32(&ctrl->mcr);\n\tstate->scfgr = rd_reg32(&ctrl->scfgr);\n\n\tdeco_inst = (rd_reg32(&ctrl->perfmon.cha_num_ms) &\n\t\t     CHA_ID_MS_DECO_MASK) >> CHA_ID_MS_DECO_SHIFT;\n\tfor (i = 0; i < deco_inst; i++) {\n\t\tstate->deco_mid[i].liodn_ms =\n\t\t\trd_reg32(&ctrl->deco_mid[i].liodn_ms);\n\t\tstate->deco_mid[i].liodn_ls =\n\t\t\trd_reg32(&ctrl->deco_mid[i].liodn_ls);\n\t}\n\n\tjr_inst = (rd_reg32(&ctrl->perfmon.cha_num_ms) &\n\t\t   CHA_ID_MS_JR_MASK) >> CHA_ID_MS_JR_SHIFT;\n\tfor (i = 0; i < jr_inst; i++) {\n\t\tstate->jr_mid[i].liodn_ms =\n\t\t\trd_reg32(&ctrl->jr_mid[i].liodn_ms);\n\t\tstate->jr_mid[i].liodn_ls =\n\t\t\trd_reg32(&ctrl->jr_mid[i].liodn_ls);\n\t}\n}\n\nstatic void caam_state_restore(const struct device *dev)\n{\n\tconst struct caam_drv_private *ctrlpriv = dev_get_drvdata(dev);\n\tconst struct caam_ctl_state *state = &ctrlpriv->state;\n\tstruct caam_ctrl __iomem *ctrl = ctrlpriv->ctrl;\n\tu32 deco_inst, jr_inst;\n\tint i;\n\n\twr_reg32(&ctrl->mcr, state->mcr);\n\twr_reg32(&ctrl->scfgr, state->scfgr);\n\n\tdeco_inst = (rd_reg32(&ctrl->perfmon.cha_num_ms) &\n\t\t     CHA_ID_MS_DECO_MASK) >> CHA_ID_MS_DECO_SHIFT;\n\tfor (i = 0; i < deco_inst; i++) {\n\t\twr_reg32(&ctrl->deco_mid[i].liodn_ms,\n\t\t\t state->deco_mid[i].liodn_ms);\n\t\twr_reg32(&ctrl->deco_mid[i].liodn_ls,\n\t\t\t state->deco_mid[i].liodn_ls);\n\t}\n\n\tjr_inst = (rd_reg32(&ctrl->perfmon.cha_num_ms) &\n\t\t   CHA_ID_MS_JR_MASK) >> CHA_ID_MS_JR_SHIFT;\n\tfor (i = 0; i < jr_inst; i++) {\n\t\twr_reg32(&ctrl->jr_mid[i].liodn_ms,\n\t\t\t state->jr_mid[i].liodn_ms);\n\t\twr_reg32(&ctrl->jr_mid[i].liodn_ls,\n\t\t\t state->jr_mid[i].liodn_ls);\n\t}\n\n\tif (ctrlpriv->virt_en == 1)\n\t\tclrsetbits_32(&ctrl->jrstart, 0, JRSTART_JR0_START |\n\t\t\t      JRSTART_JR1_START | JRSTART_JR2_START |\n\t\t\t      JRSTART_JR3_START);\n}\n\nstatic int caam_ctrl_suspend(struct device *dev)\n{\n\tconst struct caam_drv_private *ctrlpriv = dev_get_drvdata(dev);\n\n\tif (ctrlpriv->caam_off_during_pm && !ctrlpriv->optee_en)\n\t\tcaam_state_save(dev);\n\n\treturn 0;\n}\n\nstatic int caam_ctrl_resume(struct device *dev)\n{\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (ctrlpriv->caam_off_during_pm && !ctrlpriv->optee_en) {\n\t\tcaam_state_restore(dev);\n\n\t\t \n\t\tdevm_remove_action(dev, devm_deinstantiate_rng, dev);\n\t\tret = caam_ctrl_rng_init(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(caam_ctrl_pm_ops, caam_ctrl_suspend, caam_ctrl_resume);\n\n \nstatic int caam_probe(struct platform_device *pdev)\n{\n\tint ret, ring;\n\tu64 caam_id;\n\tconst struct soc_device_attribute *imx_soc_match;\n\tstruct device *dev;\n\tstruct device_node *nprop, *np;\n\tstruct caam_ctrl __iomem *ctrl;\n\tstruct caam_drv_private *ctrlpriv;\n\tstruct caam_perfmon __iomem *perfmon;\n\tstruct dentry *dfs_root;\n\tu32 scfgr, comp_params;\n\tint pg_size;\n\tint BLOCK_OFFSET = 0;\n\tbool reg_access = true;\n\n\tctrlpriv = devm_kzalloc(&pdev->dev, sizeof(*ctrlpriv), GFP_KERNEL);\n\tif (!ctrlpriv)\n\t\treturn -ENOMEM;\n\n\tdev = &pdev->dev;\n\tdev_set_drvdata(dev, ctrlpriv);\n\tnprop = pdev->dev.of_node;\n\n\timx_soc_match = soc_device_match(caam_imx_soc_table);\n\tif (!imx_soc_match && of_match_node(imx8m_machine_match, of_root))\n\t\treturn -EPROBE_DEFER;\n\n\tcaam_imx = (bool)imx_soc_match;\n\n\tctrlpriv->caam_off_during_pm = caam_imx && caam_off_during_pm();\n\n\tif (imx_soc_match) {\n\t\t \n\t\tnp = of_find_compatible_node(NULL, NULL, \"linaro,optee-tz\");\n\t\tctrlpriv->optee_en = !!np;\n\t\tof_node_put(np);\n\n\t\treg_access = !ctrlpriv->optee_en;\n\n\t\tif (!imx_soc_match->data) {\n\t\t\tdev_err(dev, \"No clock data provided for i.MX SoC\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = init_clocks(dev, imx_soc_match->data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\n\t \n\t \n\tctrl = devm_of_iomap(dev, nprop, 0, NULL);\n\tret = PTR_ERR_OR_ZERO(ctrl);\n\tif (ret) {\n\t\tdev_err(dev, \"caam: of_iomap() failed\\n\");\n\t\treturn ret;\n\t}\n\n\tring = 0;\n\tfor_each_available_child_of_node(nprop, np)\n\t\tif (of_device_is_compatible(np, \"fsl,sec-v4.0-job-ring\") ||\n\t\t    of_device_is_compatible(np, \"fsl,sec4.0-job-ring\")) {\n\t\t\tu32 reg;\n\n\t\t\tif (of_property_read_u32_index(np, \"reg\", 0, &reg)) {\n\t\t\t\tdev_err(dev, \"%s read reg property error\\n\",\n\t\t\t\t\tnp->full_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tctrlpriv->jr[ring] = (struct caam_job_ring __iomem __force *)\n\t\t\t\t\t     ((__force uint8_t *)ctrl + reg);\n\n\t\t\tctrlpriv->total_jobrs++;\n\t\t\tring++;\n\t\t}\n\n\t \n\tperfmon = ring ? (struct caam_perfmon __iomem *)&ctrlpriv->jr[0]->perfmon :\n\t\t\t (struct caam_perfmon __iomem *)&ctrl->perfmon;\n\n\tcaam_little_end = !(bool)(rd_reg32(&perfmon->status) &\n\t\t\t\t  (CSTA_PLEND | CSTA_ALT_PLEND));\n\tcomp_params = rd_reg32(&perfmon->comp_parms_ms);\n\tif (reg_access && comp_params & CTPR_MS_PS &&\n\t    rd_reg32(&ctrl->mcr) & MCFGR_LONG_PTR)\n\t\tcaam_ptr_sz = sizeof(u64);\n\telse\n\t\tcaam_ptr_sz = sizeof(u32);\n\tcaam_dpaa2 = !!(comp_params & CTPR_MS_DPAA2);\n\tctrlpriv->qi_present = !!(comp_params & CTPR_MS_QI_MASK);\n\n#ifdef CONFIG_CAAM_QI\n\t \n\tif (ctrlpriv->qi_present && !caam_dpaa2) {\n\t\tret = qman_is_probed();\n\t\tif (!ret) {\n\t\t\treturn -EPROBE_DEFER;\n\t\t} else if (ret < 0) {\n\t\t\tdev_err(dev, \"failing probe due to qman probe error\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tret = qman_portals_probed();\n\t\tif (!ret) {\n\t\t\treturn -EPROBE_DEFER;\n\t\t} else if (ret < 0) {\n\t\t\tdev_err(dev, \"failing probe due to qman portals probe error\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n#endif\n\n\t \n\tpg_size = (comp_params & CTPR_MS_PG_SZ_MASK) >> CTPR_MS_PG_SZ_SHIFT;\n\tif (pg_size == 0)\n\t\tBLOCK_OFFSET = PG_SIZE_4K;\n\telse\n\t\tBLOCK_OFFSET = PG_SIZE_64K;\n\n\tctrlpriv->ctrl = (struct caam_ctrl __iomem __force *)ctrl;\n\tctrlpriv->assure = (struct caam_assurance __iomem __force *)\n\t\t\t   ((__force uint8_t *)ctrl +\n\t\t\t    BLOCK_OFFSET * ASSURE_BLOCK_NUMBER\n\t\t\t   );\n\tctrlpriv->deco = (struct caam_deco __iomem __force *)\n\t\t\t ((__force uint8_t *)ctrl +\n\t\t\t BLOCK_OFFSET * DECO_BLOCK_NUMBER\n\t\t\t );\n\n\t \n\tctrlpriv->secvio_irq = irq_of_parse_and_map(nprop, 0);\n\tnp = of_find_compatible_node(NULL, NULL, \"fsl,qoriq-mc\");\n\tctrlpriv->mc_en = !!np;\n\tof_node_put(np);\n\n#ifdef CONFIG_FSL_MC_BUS\n\tif (ctrlpriv->mc_en) {\n\t\tstruct fsl_mc_version *mc_version;\n\n\t\tmc_version = fsl_mc_get_version();\n\t\tif (mc_version)\n\t\t\tctrlpriv->pr_support = check_version(mc_version, 10, 20,\n\t\t\t\t\t\t\t     0);\n\t\telse\n\t\t\treturn -EPROBE_DEFER;\n\t}\n#endif\n\n\tif (!reg_access)\n\t\tgoto set_dma_mask;\n\n\t \n\tif (!ctrlpriv->mc_en)\n\t\tclrsetbits_32(&ctrl->mcr, MCFGR_AWCACHE_MASK,\n\t\t\t      MCFGR_AWCACHE_CACH | MCFGR_AWCACHE_BUFF |\n\t\t\t      MCFGR_WDENABLE | MCFGR_LARGE_BURST);\n\n\thandle_imx6_err005766(&ctrl->mcr);\n\n\t \n\tscfgr = rd_reg32(&ctrl->scfgr);\n\n\tctrlpriv->virt_en = 0;\n\tif (comp_params & CTPR_MS_VIRT_EN_INCL) {\n\t\t \n\t\tif ((comp_params & CTPR_MS_VIRT_EN_POR) ||\n\t\t    (!(comp_params & CTPR_MS_VIRT_EN_POR) &&\n\t\t       (scfgr & SCFGR_VIRT_EN)))\n\t\t\t\tctrlpriv->virt_en = 1;\n\t} else {\n\t\t \n\t\tif (comp_params & CTPR_MS_VIRT_EN_POR)\n\t\t\t\tctrlpriv->virt_en = 1;\n\t}\n\n\tif (ctrlpriv->virt_en == 1)\n\t\tclrsetbits_32(&ctrl->jrstart, 0, JRSTART_JR0_START |\n\t\t\t      JRSTART_JR1_START | JRSTART_JR2_START |\n\t\t\t      JRSTART_JR3_START);\n\nset_dma_mask:\n\tret = dma_set_mask_and_coherent(dev, caam_get_dma_mask(dev));\n\tif (ret) {\n\t\tdev_err(dev, \"dma_set_mask_and_coherent failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tctrlpriv->era = caam_get_era(perfmon);\n\tctrlpriv->domain = iommu_get_domain_for_dev(dev);\n\n\tdfs_root = debugfs_create_dir(dev_name(dev), NULL);\n\tif (IS_ENABLED(CONFIG_DEBUG_FS)) {\n\t\tret = devm_add_action_or_reset(dev, caam_remove_debugfs,\n\t\t\t\t\t       dfs_root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcaam_debugfs_init(ctrlpriv, perfmon, dfs_root);\n\n\t \n\tif (ctrlpriv->qi_present && !caam_dpaa2) {\n\t\tctrlpriv->qi = (struct caam_queue_if __iomem __force *)\n\t\t\t       ((__force uint8_t *)ctrl +\n\t\t\t\t BLOCK_OFFSET * QI_BLOCK_NUMBER\n\t\t\t       );\n\t\t \n\t\twr_reg32(&ctrlpriv->qi->qi_control_lo, QICTL_DQEN);\n\n\t\t \n#ifdef CONFIG_CAAM_QI\n\t\tret = caam_qi_init(pdev);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"caam qi i/f init failed: %d\\n\", ret);\n#endif\n\t}\n\n\t \n\tif ((!ctrlpriv->qi_present) && (!ctrlpriv->total_jobrs)) {\n\t\tdev_err(dev, \"no queues configured, terminating\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcomp_params = rd_reg32(&perfmon->comp_parms_ls);\n\tctrlpriv->blob_present = !!(comp_params & CTPR_LS_BLOB);\n\n\t \n\tif (ctrlpriv->era < 10) {\n\t\tctrlpriv->blob_present = ctrlpriv->blob_present &&\n\t\t\t(rd_reg32(&perfmon->cha_num_ls) & CHA_ID_LS_AES_MASK);\n\t} else {\n\t\tstruct version_regs __iomem *vreg;\n\n\t\tvreg =  ctrlpriv->total_jobrs ?\n\t\t\t(struct version_regs __iomem *)&ctrlpriv->jr[0]->vreg :\n\t\t\t(struct version_regs __iomem *)&ctrl->vreg;\n\n\t\tctrlpriv->blob_present = ctrlpriv->blob_present &&\n\t\t\t(rd_reg32(&vreg->aesa) & CHA_VER_MISC_AES_NUM_MASK);\n\t}\n\n\tif (reg_access) {\n\t\tret = caam_ctrl_rng_init(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcaam_id = (u64)rd_reg32(&perfmon->caam_id_ms) << 32 |\n\t\t  (u64)rd_reg32(&perfmon->caam_id_ls);\n\n\t \n\tdev_info(dev, \"device ID = 0x%016llx (Era %d)\\n\", caam_id,\n\t\t ctrlpriv->era);\n\tdev_info(dev, \"job rings = %d, qi = %d\\n\",\n\t\t ctrlpriv->total_jobrs, ctrlpriv->qi_present);\n\n\tret = devm_of_platform_populate(dev);\n\tif (ret)\n\t\tdev_err(dev, \"JR platform devices creation error\\n\");\n\n\treturn ret;\n}\n\nstatic struct platform_driver caam_driver = {\n\t.driver = {\n\t\t.name = \"caam\",\n\t\t.of_match_table = caam_match,\n\t\t.pm = pm_ptr(&caam_ctrl_pm_ops),\n\t},\n\t.probe       = caam_probe,\n};\n\nmodule_platform_driver(caam_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"FSL CAAM request backend\");\nMODULE_AUTHOR(\"Freescale Semiconductor - NMG/STC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}