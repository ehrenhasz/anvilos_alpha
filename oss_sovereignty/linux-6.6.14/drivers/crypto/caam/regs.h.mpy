{
  "module_name": "regs.h",
  "hash_id": "f91b7e7d5fa74c115064b39a0d73e81a16cbf97b3725ba390693ae664506a869",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/caam/regs.h",
  "human_readable_source": " \n \n\n#ifndef REGS_H\n#define REGS_H\n\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/io-64-nonatomic-hi-lo.h>\n\n \n\nextern bool caam_little_end;\nextern bool caam_imx;\nextern size_t caam_ptr_sz;\n\n#define caam_to_cpu(len)\t\t\t\t\t\t\\\nstatic inline u##len caam##len ## _to_cpu(u##len val)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (caam_little_end)\t\t\t\t\t\t\\\n\t\treturn le##len ## _to_cpu((__force __le##len)val);\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\treturn be##len ## _to_cpu((__force __be##len)val);\t\\\n}\n\n#define cpu_to_caam(len)\t\t\t\t\t\\\nstatic inline u##len cpu_to_caam##len(u##len val)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tif (caam_little_end)\t\t\t\t\t\\\n\t\treturn (__force u##len)cpu_to_le##len(val);\t\\\n\telse\t\t\t\t\t\t\t\\\n\t\treturn (__force u##len)cpu_to_be##len(val);\t\\\n}\n\ncaam_to_cpu(16)\ncaam_to_cpu(32)\ncaam_to_cpu(64)\ncpu_to_caam(16)\ncpu_to_caam(32)\ncpu_to_caam(64)\n\nstatic inline void wr_reg32(void __iomem *reg, u32 data)\n{\n\tif (caam_little_end)\n\t\tiowrite32(data, reg);\n\telse\n\t\tiowrite32be(data, reg);\n}\n\nstatic inline u32 rd_reg32(void __iomem *reg)\n{\n\tif (caam_little_end)\n\t\treturn ioread32(reg);\n\n\treturn ioread32be(reg);\n}\n\nstatic inline void clrsetbits_32(void __iomem *reg, u32 clear, u32 set)\n{\n\tif (caam_little_end)\n\t\tiowrite32((ioread32(reg) & ~clear) | set, reg);\n\telse\n\t\tiowrite32be((ioread32be(reg) & ~clear) | set, reg);\n}\n\n \nstatic inline void wr_reg64(void __iomem *reg, u64 data)\n{\n\tif (caam_little_end) {\n\t\tif (caam_imx) {\n\t\t\tiowrite32(data >> 32, (u32 __iomem *)(reg));\n\t\t\tiowrite32(data, (u32 __iomem *)(reg) + 1);\n\t\t} else {\n\t\t\tiowrite64(data, reg);\n\t\t}\n\t} else {\n\t\tiowrite64be(data, reg);\n\t}\n}\n\nstatic inline u64 rd_reg64(void __iomem *reg)\n{\n\tif (caam_little_end) {\n\t\tif (caam_imx) {\n\t\t\tu32 low, high;\n\n\t\t\thigh = ioread32(reg);\n\t\t\tlow  = ioread32(reg + sizeof(u32));\n\n\t\t\treturn low + ((u64)high << 32);\n\t\t} else {\n\t\t\treturn ioread64(reg);\n\t\t}\n\t} else {\n\t\treturn ioread64be(reg);\n\t}\n}\n\nstatic inline u64 cpu_to_caam_dma64(dma_addr_t value)\n{\n\tif (caam_imx) {\n\t\tu64 ret_val = (u64)cpu_to_caam32(lower_32_bits(value)) << 32;\n\n\t\tif (IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT))\n\t\t\tret_val |= (u64)cpu_to_caam32(upper_32_bits(value));\n\n\t\treturn ret_val;\n\t}\n\n\treturn cpu_to_caam64(value);\n}\n\nstatic inline u64 caam_dma64_to_cpu(u64 value)\n{\n\tif (caam_imx)\n\t\treturn (((u64)caam32_to_cpu(lower_32_bits(value)) << 32) |\n\t\t\t (u64)caam32_to_cpu(upper_32_bits(value)));\n\n\treturn caam64_to_cpu(value);\n}\n\nstatic inline u64 cpu_to_caam_dma(u64 value)\n{\n\tif (IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT) &&\n\t    caam_ptr_sz == sizeof(u64))\n\t\treturn cpu_to_caam_dma64(value);\n\telse\n\t\treturn cpu_to_caam32(value);\n}\n\nstatic inline u64 caam_dma_to_cpu(u64 value)\n{\n\tif (IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT) &&\n\t    caam_ptr_sz == sizeof(u64))\n\t\treturn caam_dma64_to_cpu(value);\n\telse\n\t\treturn caam32_to_cpu(value);\n}\n\n \n\nstatic inline void jr_outentry_get(void *outring, int hw_idx, dma_addr_t *desc,\n\t\t\t\t   u32 *jrstatus)\n{\n\n\tif (caam_ptr_sz == sizeof(u32)) {\n\t\tstruct {\n\t\t\tu32 desc;\n\t\t\tu32 jrstatus;\n\t\t} __packed *outentry = outring;\n\n\t\t*desc = outentry[hw_idx].desc;\n\t\t*jrstatus = outentry[hw_idx].jrstatus;\n\t} else {\n\t\tstruct {\n\t\t\tdma_addr_t desc; \n\t\t\tu32 jrstatus;\t \n\t\t} __packed *outentry = outring;\n\n\t\t*desc = outentry[hw_idx].desc;\n\t\t*jrstatus = outentry[hw_idx].jrstatus;\n\t}\n}\n\n#define SIZEOF_JR_OUTENTRY\t(caam_ptr_sz + sizeof(u32))\n\nstatic inline dma_addr_t jr_outentry_desc(void *outring, int hw_idx)\n{\n\tdma_addr_t desc;\n\tu32 unused;\n\n\tjr_outentry_get(outring, hw_idx, &desc, &unused);\n\n\treturn desc;\n}\n\nstatic inline u32 jr_outentry_jrstatus(void *outring, int hw_idx)\n{\n\tdma_addr_t unused;\n\tu32 jrstatus;\n\n\tjr_outentry_get(outring, hw_idx, &unused, &jrstatus);\n\n\treturn jrstatus;\n}\n\nstatic inline void jr_inpentry_set(void *inpring, int hw_idx, dma_addr_t val)\n{\n\tif (caam_ptr_sz == sizeof(u32)) {\n\t\tu32 *inpentry = inpring;\n\n\t\tinpentry[hw_idx] = val;\n\t} else {\n\t\tdma_addr_t *inpentry = inpring;\n\n\t\tinpentry[hw_idx] = val;\n\t}\n}\n\n#define SIZEOF_JR_INPENTRY\tcaam_ptr_sz\n\n\n \nstruct version_regs {\n\tu32 crca;\t \n\tu32 afha;\t \n\tu32 kfha;\t \n\tu32 pkha;\t \n\tu32 aesa;\t \n\tu32 mdha;\t \n\tu32 desa;\t \n\tu32 snw8a;\t \n\tu32 snw9a;\t \n\tu32 zuce;\t \n\tu32 zuca;\t \n\tu32 ccha;\t \n\tu32 ptha;\t \n\tu32 rng;\t \n\tu32 trng;\t \n\tu32 aaha;\t \n\tu32 rsvd[10];\n\tu32 sr;\t\t \n\tu32 dma;\t \n\tu32 ai;\t\t \n\tu32 qi;\t\t \n\tu32 jr;\t\t \n\tu32 deco;\t \n};\n\n \n\n \n#define CHA_VER_NUM_MASK\t0xffull\n \n#define CHA_VER_MISC_SHIFT\t8\n#define CHA_VER_MISC_MASK\t(0xffull << CHA_VER_MISC_SHIFT)\n \n#define CHA_VER_REV_SHIFT\t16\n#define CHA_VER_REV_MASK\t(0xffull << CHA_VER_REV_SHIFT)\n \n#define CHA_VER_VID_SHIFT\t24\n#define CHA_VER_VID_MASK\t(0xffull << CHA_VER_VID_SHIFT)\n\n \n#define CHA_VER_MISC_AES_NUM_MASK\tGENMASK(7, 0)\n#define CHA_VER_MISC_AES_GCM\t\tBIT(1 + CHA_VER_MISC_SHIFT)\n\n \n#define CHA_VER_MISC_PKHA_NO_CRYPT\tBIT(7 + CHA_VER_MISC_SHIFT)\n\n \n\n \n#define CHA_NUM_MS_DECONUM_SHIFT\t24\n#define CHA_NUM_MS_DECONUM_MASK\t(0xfull << CHA_NUM_MS_DECONUM_SHIFT)\n\n \n#define CHA_ID_LS_AES_SHIFT\t0\n#define CHA_ID_LS_AES_MASK\t(0xfull << CHA_ID_LS_AES_SHIFT)\n\n#define CHA_ID_LS_DES_SHIFT\t4\n#define CHA_ID_LS_DES_MASK\t(0xfull << CHA_ID_LS_DES_SHIFT)\n\n#define CHA_ID_LS_ARC4_SHIFT\t8\n#define CHA_ID_LS_ARC4_MASK\t(0xfull << CHA_ID_LS_ARC4_SHIFT)\n\n#define CHA_ID_LS_MD_SHIFT\t12\n#define CHA_ID_LS_MD_MASK\t(0xfull << CHA_ID_LS_MD_SHIFT)\n\n#define CHA_ID_LS_RNG_SHIFT\t16\n#define CHA_ID_LS_RNG_MASK\t(0xfull << CHA_ID_LS_RNG_SHIFT)\n\n#define CHA_ID_LS_SNW8_SHIFT\t20\n#define CHA_ID_LS_SNW8_MASK\t(0xfull << CHA_ID_LS_SNW8_SHIFT)\n\n#define CHA_ID_LS_KAS_SHIFT\t24\n#define CHA_ID_LS_KAS_MASK\t(0xfull << CHA_ID_LS_KAS_SHIFT)\n\n#define CHA_ID_LS_PK_SHIFT\t28\n#define CHA_ID_LS_PK_MASK\t(0xfull << CHA_ID_LS_PK_SHIFT)\n\n#define CHA_ID_MS_CRC_SHIFT\t0\n#define CHA_ID_MS_CRC_MASK\t(0xfull << CHA_ID_MS_CRC_SHIFT)\n\n#define CHA_ID_MS_SNW9_SHIFT\t4\n#define CHA_ID_MS_SNW9_MASK\t(0xfull << CHA_ID_MS_SNW9_SHIFT)\n\n#define CHA_ID_MS_DECO_SHIFT\t24\n#define CHA_ID_MS_DECO_MASK\t(0xfull << CHA_ID_MS_DECO_SHIFT)\n\n#define CHA_ID_MS_JR_SHIFT\t28\n#define CHA_ID_MS_JR_MASK\t(0xfull << CHA_ID_MS_JR_SHIFT)\n\n \n#define CHA_VER_VID_AES_LP\t0x3ull\n#define CHA_VER_VID_AES_HP\t0x4ull\n#define CHA_VER_VID_MD_LP256\t0x0ull\n#define CHA_VER_VID_MD_LP512\t0x1ull\n#define CHA_VER_VID_MD_HP\t0x2ull\n\nstruct sec_vid {\n\tu16 ip_id;\n\tu8 maj_rev;\n\tu8 min_rev;\n};\n\nstruct caam_perfmon {\n\t \n\tu64 req_dequeued;\t \n\tu64 ob_enc_req;\t \n\tu64 ib_dec_req;\t \n\tu64 ob_enc_bytes;\t \n\tu64 ob_prot_bytes;\t \n\tu64 ib_dec_bytes;\t \n\tu64 ib_valid_bytes;\t \n\tu64 rsvd[13];\n\n\t \n\tu32 cha_rev_ms;\t\t \n\tu32 cha_rev_ls;\t\t \n#define CTPR_MS_QI_SHIFT\t25\n#define CTPR_MS_QI_MASK\t\t(0x1ull << CTPR_MS_QI_SHIFT)\n#define CTPR_MS_PS\t\tBIT(17)\n#define CTPR_MS_DPAA2\t\tBIT(13)\n#define CTPR_MS_VIRT_EN_INCL\t0x00000001\n#define CTPR_MS_VIRT_EN_POR\t0x00000002\n#define CTPR_MS_PG_SZ_MASK\t0x10\n#define CTPR_MS_PG_SZ_SHIFT\t4\n\tu32 comp_parms_ms;\t \n#define CTPR_LS_BLOB           BIT(1)\n\tu32 comp_parms_ls;\t \n\tu64 rsvd1[2];\n\n\t \n\tu64 faultaddr;\t \n\tu32 faultliodn;\t \n\tu32 faultdetail;\t \n\tu32 rsvd2;\n#define CSTA_PLEND\t\tBIT(10)\n#define CSTA_ALT_PLEND\t\tBIT(18)\n#define CSTA_MOO\t\tGENMASK(9, 8)\n#define CSTA_MOO_SECURE\t1\n#define CSTA_MOO_TRUSTED\t2\n\tu32 status;\t\t \n\tu64 rsvd3;\n\n\t \n\tu32 rtic_id;\t\t \n#define CCBVID_ERA_MASK\t\t0xff000000\n#define CCBVID_ERA_SHIFT\t24\n\tu32 ccb_id;\t\t \n\tu32 cha_id_ms;\t\t \n\tu32 cha_id_ls;\t\t \n\tu32 cha_num_ms;\t\t \n\tu32 cha_num_ls;\t\t \n#define SECVID_MS_IPID_MASK\t0xffff0000\n#define SECVID_MS_IPID_SHIFT\t16\n#define SECVID_MS_MAJ_REV_MASK\t0x0000ff00\n#define SECVID_MS_MAJ_REV_SHIFT\t8\n\tu32 caam_id_ms;\t\t \n\tu32 caam_id_ls;\t\t \n};\n\n \n#define MSTRID_LOCK_LIODN\t0x80000000\n#define MSTRID_LOCK_MAKETRUSTED\t0x00010000\t \n\n#define MSTRID_LIODN_MASK\t0x0fff\nstruct masterid {\n\tu32 liodn_ms;\t \n\tu32 liodn_ls;\t \n};\n\n \n \nstruct rngtst {\n\tu32 mode;\t\t \n\tu32 rsvd1[3];\n\tu32 reset;\t\t \n\tu32 rsvd2[3];\n\tu32 status;\t\t \n\tu32 rsvd3;\n\tu32 errstat;\t\t \n\tu32 rsvd4;\n\tu32 errctl;\t\t \n\tu32 rsvd5;\n\tu32 entropy;\t\t \n\tu32 rsvd6[15];\n\tu32 verifctl;\t \n\tu32 rsvd7;\n\tu32 verifstat;\t \n\tu32 rsvd8;\n\tu32 verifdata;\t \n\tu32 rsvd9;\n\tu32 xkey;\t\t \n\tu32 rsvd10;\n\tu32 oscctctl;\t \n\tu32 rsvd11;\n\tu32 oscct;\t\t \n\tu32 rsvd12;\n\tu32 oscctstat;\t \n\tu32 rsvd13[2];\n\tu32 ofifo[4];\t \n\tu32 rsvd14[15];\n};\n\n \nstruct rng4tst {\n#define RTMCTL_ACC  BIT(5)   \n#define RTMCTL_PRGM BIT(16)  \n#define RTMCTL_SAMP_MODE_VON_NEUMANN_ES_SC\t0  \n#define RTMCTL_SAMP_MODE_RAW_ES_SC\t\t1  \n#define RTMCTL_SAMP_MODE_VON_NEUMANN_ES_RAW_SC\t2  \n#define RTMCTL_SAMP_MODE_INVALID\t\t3  \n\tu32 rtmctl;\t\t \n\tu32 rtscmisc;\t\t \n\tu32 rtpkrrng;\t\t \n\tunion {\n\t\tu32 rtpkrmax;\t \n\t\tu32 rtpkrsq;\t \n\t};\n#define RTSDCTL_ENT_DLY_SHIFT 16\n#define RTSDCTL_ENT_DLY_MASK (0xffff << RTSDCTL_ENT_DLY_SHIFT)\n#define RTSDCTL_ENT_DLY_MIN 3200\n#define RTSDCTL_ENT_DLY_MAX 12800\n#define RTSDCTL_SAMP_SIZE_MASK 0xffff\n#define RTSDCTL_SAMP_SIZE_VAL 512\n\tu32 rtsdctl;\t\t \n\tunion {\n\t\tu32 rtsblim;\t \n\t\tu32 rttotsam;\t \n\t};\n\tu32 rtfrqmin;\t\t \n#define RTFRQMAX_DISABLE\t(1 << 20)\n\tunion {\n\t\tu32 rtfrqmax;\t \n\t\tu32 rtfrqcnt;\t \n\t};\n\tunion {\n\t\tu32 rtscmc;\t \n\t\tu32 rtscml;\t \n\t};\n\tunion {\n\t\tu32 rtscrc[6];\t \n\t\tu32 rtscrl[6];\t \n\t};\n\tu32 rsvd1[33];\n#define RDSTA_SKVT 0x80000000\n#define RDSTA_SKVN 0x40000000\n#define RDSTA_PR0 BIT(4)\n#define RDSTA_PR1 BIT(5)\n#define RDSTA_IF0 0x00000001\n#define RDSTA_IF1 0x00000002\n#define RDSTA_MASK (RDSTA_PR1 | RDSTA_PR0 | RDSTA_IF1 | RDSTA_IF0)\n\tu32 rdsta;\n\tu32 rsvd2[15];\n};\n\n \n\n#define KEK_KEY_SIZE\t\t8\n#define TKEK_KEY_SIZE\t\t8\n#define TDSK_KEY_SIZE\t\t8\n\n#define DECO_RESET\t1\t \n#define DECO_RESET_0\t(DECO_RESET << 0)\n#define DECO_RESET_1\t(DECO_RESET << 1)\n#define DECO_RESET_2\t(DECO_RESET << 2)\n#define DECO_RESET_3\t(DECO_RESET << 3)\n#define DECO_RESET_4\t(DECO_RESET << 4)\n\nstruct caam_ctrl {\n\t \n\t \n\tu32 rsvd1;\n\tu32 mcr;\t\t \n\tu32 rsvd2;\n\tu32 scfgr;\t\t \n\n\t \n\t \n\tstruct masterid jr_mid[4];\t \n\tu32 rsvd3[11];\n\tu32 jrstart;\t\t\t \n\tstruct masterid rtic_mid[4];\t \n\tu32 rsvd4[5];\n\tu32 deco_rsr;\t\t\t \n\tu32 rsvd11;\n\tu32 deco_rq;\t\t\t \n\tstruct masterid deco_mid[16];\t \n\n\t \n\tu32 deco_avail;\t\t \n\tu32 deco_reset;\t\t \n\tu32 rsvd6[182];\n\n\t \n\t \n\tu32 kek[KEK_KEY_SIZE];\t \n\tu32 tkek[TKEK_KEY_SIZE];\t \n\tu32 tdsk[TDSK_KEY_SIZE];\t \n\tu32 rsvd7[32];\n\tu64 sknonce;\t\t\t \n\tu32 rsvd8[70];\n\n\t \n\t \n\tunion {\n\t\tstruct rngtst rtst[2];\n\t\tstruct rng4tst r4tst[2];\n\t};\n\n\tu32 rsvd9[416];\n\n\t \n\tstruct version_regs vreg;\n\t \n\tstruct caam_perfmon perfmon;\n};\n\n \n#define MCFGR_SWRESET\t\t0x80000000  \n#define MCFGR_WDENABLE\t\t0x40000000  \n#define MCFGR_WDFAIL\t\t0x20000000  \n#define MCFGR_DMA_RESET\t\t0x10000000\n#define MCFGR_LONG_PTR\t\t0x00010000  \n#define SCFGR_RDBENABLE\t\t0x00000400\n#define SCFGR_VIRT_EN\t\t0x00008000\n#define DECORR_RQD0ENABLE\t0x00000001  \n#define DECORSR_JR0\t\t0x00000001  \n#define DECORSR_VALID\t\t0x80000000\n#define DECORR_DEN0\t\t0x00010000  \n\n \n#define MCFGR_ARCACHE_SHIFT\t12\n#define MCFGR_ARCACHE_MASK\t(0xf << MCFGR_ARCACHE_SHIFT)\n#define MCFGR_ARCACHE_BUFF\t(0x1 << MCFGR_ARCACHE_SHIFT)\n#define MCFGR_ARCACHE_CACH\t(0x2 << MCFGR_ARCACHE_SHIFT)\n#define MCFGR_ARCACHE_RALL\t(0x4 << MCFGR_ARCACHE_SHIFT)\n\n \n#define MCFGR_AWCACHE_SHIFT\t8\n#define MCFGR_AWCACHE_MASK\t(0xf << MCFGR_AWCACHE_SHIFT)\n#define MCFGR_AWCACHE_BUFF\t(0x1 << MCFGR_AWCACHE_SHIFT)\n#define MCFGR_AWCACHE_CACH\t(0x2 << MCFGR_AWCACHE_SHIFT)\n#define MCFGR_AWCACHE_WALL\t(0x8 << MCFGR_AWCACHE_SHIFT)\n\n \n#define MCFGR_AXIPIPE_SHIFT\t4\n#define MCFGR_AXIPIPE_MASK\t(0xf << MCFGR_AXIPIPE_SHIFT)\n\n#define MCFGR_AXIPRI\t\t0x00000008  \n#define MCFGR_LARGE_BURST\t0x00000004  \n#define MCFGR_BURST_64\t\t0x00000001  \n\n \n#define JRSTART_JR0_START       0x00000001  \n#define JRSTART_JR1_START       0x00000002  \n#define JRSTART_JR2_START       0x00000004  \n#define JRSTART_JR3_START       0x00000008  \n\n \nstruct caam_job_ring {\n\t \n\tu64 inpring_base;\t \n\tu32 rsvd1;\n\tu32 inpring_size;\t \n\tu32 rsvd2;\n\tu32 inpring_avail;\t \n\tu32 rsvd3;\n\tu32 inpring_jobadd;\t \n\n\t \n\tu64 outring_base;\t \n\tu32 rsvd4;\n\tu32 outring_size;\t \n\tu32 rsvd5;\n\tu32 outring_rmvd;\t \n\tu32 rsvd6;\n\tu32 outring_used;\t \n\n\t \n\tu32 rsvd7;\n\tu32 jroutstatus;\t \n\tu32 rsvd8;\n\tu32 jrintstatus;\t \n\tu32 rconfig_hi;\t \n\tu32 rconfig_lo;\n\n\t \n\tu32 rsvd9;\n\tu32 inp_rdidx;\t \n\tu32 rsvd10;\n\tu32 out_wtidx;\t \n\n\t \n\tu32 rsvd11;\n\tu32 jrcommand;\t \n\n\tu32 rsvd12[900];\n\n\t \n\tstruct version_regs vreg;\n\t \n\tstruct caam_perfmon perfmon;\n};\n\n#define JR_RINGSIZE_MASK\t0x03ff\n \n#define JRSTA_SSRC_SHIFT            28\n#define JRSTA_SSRC_MASK             0xf0000000\n\n#define JRSTA_SSRC_NONE             0x00000000\n#define JRSTA_SSRC_CCB_ERROR        0x20000000\n#define JRSTA_SSRC_JUMP_HALT_USER   0x30000000\n#define JRSTA_SSRC_DECO             0x40000000\n#define JRSTA_SSRC_QI               0x50000000\n#define JRSTA_SSRC_JRERROR          0x60000000\n#define JRSTA_SSRC_JUMP_HALT_CC     0x70000000\n\n#define JRSTA_DECOERR_JUMP          0x08000000\n#define JRSTA_DECOERR_INDEX_SHIFT   8\n#define JRSTA_DECOERR_INDEX_MASK    0xff00\n#define JRSTA_DECOERR_ERROR_MASK    0x00ff\n\n#define JRSTA_DECOERR_NONE          0x00\n#define JRSTA_DECOERR_LINKLEN       0x01\n#define JRSTA_DECOERR_LINKPTR       0x02\n#define JRSTA_DECOERR_JRCTRL        0x03\n#define JRSTA_DECOERR_DESCCMD       0x04\n#define JRSTA_DECOERR_ORDER         0x05\n#define JRSTA_DECOERR_KEYCMD        0x06\n#define JRSTA_DECOERR_LOADCMD       0x07\n#define JRSTA_DECOERR_STORECMD      0x08\n#define JRSTA_DECOERR_OPCMD         0x09\n#define JRSTA_DECOERR_FIFOLDCMD     0x0a\n#define JRSTA_DECOERR_FIFOSTCMD     0x0b\n#define JRSTA_DECOERR_MOVECMD       0x0c\n#define JRSTA_DECOERR_JUMPCMD       0x0d\n#define JRSTA_DECOERR_MATHCMD       0x0e\n#define JRSTA_DECOERR_SHASHCMD      0x0f\n#define JRSTA_DECOERR_SEQCMD        0x10\n#define JRSTA_DECOERR_DECOINTERNAL  0x11\n#define JRSTA_DECOERR_SHDESCHDR     0x12\n#define JRSTA_DECOERR_HDRLEN        0x13\n#define JRSTA_DECOERR_BURSTER       0x14\n#define JRSTA_DECOERR_DESCSIGNATURE 0x15\n#define JRSTA_DECOERR_DMA           0x16\n#define JRSTA_DECOERR_BURSTFIFO     0x17\n#define JRSTA_DECOERR_JRRESET       0x1a\n#define JRSTA_DECOERR_JOBFAIL       0x1b\n#define JRSTA_DECOERR_DNRERR        0x80\n#define JRSTA_DECOERR_UNDEFPCL      0x81\n#define JRSTA_DECOERR_PDBERR        0x82\n#define JRSTA_DECOERR_ANRPLY_LATE   0x83\n#define JRSTA_DECOERR_ANRPLY_REPLAY 0x84\n#define JRSTA_DECOERR_SEQOVF        0x85\n#define JRSTA_DECOERR_INVSIGN       0x86\n#define JRSTA_DECOERR_DSASIGN       0x87\n\n#define JRSTA_QIERR_ERROR_MASK      0x00ff\n\n#define JRSTA_CCBERR_JUMP           0x08000000\n#define JRSTA_CCBERR_INDEX_MASK     0xff00\n#define JRSTA_CCBERR_INDEX_SHIFT    8\n#define JRSTA_CCBERR_CHAID_MASK     0x00f0\n#define JRSTA_CCBERR_CHAID_SHIFT    4\n#define JRSTA_CCBERR_ERRID_MASK     0x000f\n\n#define JRSTA_CCBERR_CHAID_AES      (0x01 << JRSTA_CCBERR_CHAID_SHIFT)\n#define JRSTA_CCBERR_CHAID_DES      (0x02 << JRSTA_CCBERR_CHAID_SHIFT)\n#define JRSTA_CCBERR_CHAID_ARC4     (0x03 << JRSTA_CCBERR_CHAID_SHIFT)\n#define JRSTA_CCBERR_CHAID_MD       (0x04 << JRSTA_CCBERR_CHAID_SHIFT)\n#define JRSTA_CCBERR_CHAID_RNG      (0x05 << JRSTA_CCBERR_CHAID_SHIFT)\n#define JRSTA_CCBERR_CHAID_SNOW     (0x06 << JRSTA_CCBERR_CHAID_SHIFT)\n#define JRSTA_CCBERR_CHAID_KASUMI   (0x07 << JRSTA_CCBERR_CHAID_SHIFT)\n#define JRSTA_CCBERR_CHAID_PK       (0x08 << JRSTA_CCBERR_CHAID_SHIFT)\n#define JRSTA_CCBERR_CHAID_CRC      (0x09 << JRSTA_CCBERR_CHAID_SHIFT)\n\n#define JRSTA_CCBERR_ERRID_NONE     0x00\n#define JRSTA_CCBERR_ERRID_MODE     0x01\n#define JRSTA_CCBERR_ERRID_DATASIZ  0x02\n#define JRSTA_CCBERR_ERRID_KEYSIZ   0x03\n#define JRSTA_CCBERR_ERRID_PKAMEMSZ 0x04\n#define JRSTA_CCBERR_ERRID_PKBMEMSZ 0x05\n#define JRSTA_CCBERR_ERRID_SEQUENCE 0x06\n#define JRSTA_CCBERR_ERRID_PKDIVZRO 0x07\n#define JRSTA_CCBERR_ERRID_PKMODEVN 0x08\n#define JRSTA_CCBERR_ERRID_KEYPARIT 0x09\n#define JRSTA_CCBERR_ERRID_ICVCHK   0x0a\n#define JRSTA_CCBERR_ERRID_HARDWARE 0x0b\n#define JRSTA_CCBERR_ERRID_CCMAAD   0x0c\n#define JRSTA_CCBERR_ERRID_INVCHA   0x0f\n\n#define JRINT_ERR_INDEX_MASK        0x3fff0000\n#define JRINT_ERR_INDEX_SHIFT       16\n#define JRINT_ERR_TYPE_MASK         0xf00\n#define JRINT_ERR_TYPE_SHIFT        8\n#define JRINT_ERR_HALT_MASK         0xc\n#define JRINT_ERR_HALT_SHIFT        2\n#define JRINT_ERR_HALT_INPROGRESS   0x4\n#define JRINT_ERR_HALT_COMPLETE     0x8\n#define JRINT_JR_ERROR              0x02\n#define JRINT_JR_INT                0x01\n\n#define JRINT_ERR_TYPE_WRITE        1\n#define JRINT_ERR_TYPE_BAD_INPADDR  3\n#define JRINT_ERR_TYPE_BAD_OUTADDR  4\n#define JRINT_ERR_TYPE_INV_INPWRT   5\n#define JRINT_ERR_TYPE_INV_OUTWRT   6\n#define JRINT_ERR_TYPE_RESET        7\n#define JRINT_ERR_TYPE_REMOVE_OFL   8\n#define JRINT_ERR_TYPE_ADD_OFL      9\n\n#define JRCFG_SOE\t\t0x04\n#define JRCFG_ICEN\t\t0x02\n#define JRCFG_IMSK\t\t0x01\n#define JRCFG_ICDCT_SHIFT\t8\n#define JRCFG_ICTT_SHIFT\t16\n\n#define JRCR_RESET                  0x01\n\n \n\nstruct rtic_element {\n\tu64 address;\n\tu32 rsvd;\n\tu32 length;\n};\n\nstruct rtic_block {\n\tstruct rtic_element element[2];\n};\n\nstruct rtic_memhash {\n\tu32 memhash_be[32];\n\tu32 memhash_le[32];\n};\n\nstruct caam_assurance {\n     \n\tu32 rsvd1;\n\tu32 status;\t\t \n\tu32 rsvd2;\n\tu32 cmd;\t\t \n\tu32 rsvd3;\n\tu32 ctrl;\t\t \n\tu32 rsvd4;\n\tu32 throttle;\t \n\tu32 rsvd5[2];\n\tu64 watchdog;\t \n\tu32 rsvd6;\n\tu32 rend;\t\t \n\tu32 rsvd7[50];\n\n\t \n\tstruct rtic_block memblk[4];\t \n\tu32 rsvd8[32];\n\n\t \n\tstruct rtic_memhash hash[4];\t \n\tu32 rsvd_3[640];\n};\n\n \n\nstruct caam_queue_if {\n\tu32 qi_control_hi;\t \n\tu32 qi_control_lo;\n\tu32 rsvd1;\n\tu32 qi_status;\t \n\tu32 qi_deq_cfg_hi;\t \n\tu32 qi_deq_cfg_lo;\n\tu32 qi_enq_cfg_hi;\t \n\tu32 qi_enq_cfg_lo;\n\tu32 rsvd2[1016];\n};\n\n \n#define QICTL_DQEN      0x01               \n#define QICTL_STOP      0x02               \n#define QICTL_SOE       0x04               \n\n \n#define QICTL_MBSI\t0x01\n#define QICTL_MHWSI\t0x02\n#define QICTL_MWSI\t0x04\n#define QICTL_MDWSI\t0x08\n#define QICTL_CBSI\t0x10\t\t \n#define QICTL_CHWSI\t0x20\t\t \n#define QICTL_CWSI\t0x40\t\t \n#define QICTL_CDWSI\t0x80\t\t \n#define QICTL_MBSO\t0x0100\n#define QICTL_MHWSO\t0x0200\n#define QICTL_MWSO\t0x0400\n#define QICTL_MDWSO\t0x0800\n#define QICTL_CBSO\t0x1000\t\t \n#define QICTL_CHWSO\t0x2000\t\t \n#define QICTL_CWSO\t0x4000\t\t \n#define QICTL_CDWSO     0x8000\t\t \n#define QICTL_DMBS\t0x010000\n#define QICTL_EPO\t0x020000\n\n \n#define QISTA_PHRDERR   0x01               \n#define QISTA_CFRDERR   0x02               \n#define QISTA_OFWRERR   0x04               \n#define QISTA_BPDERR    0x08               \n#define QISTA_BTSERR    0x10               \n#define QISTA_CFWRERR   0x20               \n#define QISTA_STOPD     0x80000000         \n\n \nstruct deco_sg_table {\n\tu64 addr;\t\t \n\tu32 elen;\t\t \n\tu32 bpid_offset;\t \n};\n\n \nstruct caam_deco {\n\tu32 rsvd1;\n\tu32 cls1_mode;\t \n\tu32 rsvd2;\n\tu32 cls1_keysize;\t \n\tu32 cls1_datasize_hi;\t \n\tu32 cls1_datasize_lo;\n\tu32 rsvd3;\n\tu32 cls1_icvsize;\t \n\tu32 rsvd4[5];\n\tu32 cha_ctrl;\t \n\tu32 rsvd5;\n\tu32 irq_crtl;\t \n\tu32 rsvd6;\n\tu32 clr_written;\t \n\tu32 ccb_status_hi;\t \n\tu32 ccb_status_lo;\n\tu32 rsvd7[3];\n\tu32 aad_size;\t \n\tu32 rsvd8;\n\tu32 cls1_iv_size;\t \n\tu32 rsvd9[7];\n\tu32 pkha_a_size;\t \n\tu32 rsvd10;\n\tu32 pkha_b_size;\t \n\tu32 rsvd11;\n\tu32 pkha_n_size;\t \n\tu32 rsvd12;\n\tu32 pkha_e_size;\t \n\tu32 rsvd13[24];\n\tu32 cls1_ctx[16];\t \n\tu32 rsvd14[48];\n\tu32 cls1_key[8];\t \n\tu32 rsvd15[121];\n\tu32 cls2_mode;\t \n\tu32 rsvd16;\n\tu32 cls2_keysize;\t \n\tu32 cls2_datasize_hi;\t \n\tu32 cls2_datasize_lo;\n\tu32 rsvd17;\n\tu32 cls2_icvsize;\t \n\tu32 rsvd18[56];\n\tu32 cls2_ctx[18];\t \n\tu32 rsvd19[46];\n\tu32 cls2_key[32];\t \n\tu32 rsvd20[84];\n\tu32 inp_infofifo_hi;\t \n\tu32 inp_infofifo_lo;\n\tu32 rsvd21[2];\n\tu64 inp_datafifo;\t \n\tu32 rsvd22[2];\n\tu64 out_datafifo;\t \n\tu32 rsvd23[2];\n\tu32 jr_ctl_hi;\t \n\tu32 jr_ctl_lo;\n\tu64 jr_descaddr;\t \n#define DECO_OP_STATUS_HI_ERR_MASK 0xF00000FF\n\tu32 op_status_hi;\t \n\tu32 op_status_lo;\n\tu32 rsvd24[2];\n\tu32 liodn;\t\t \n\tu32 td_liodn;\t \n\tu32 rsvd26[6];\n\tu64 math[4];\t\t \n\tu32 rsvd27[8];\n\tstruct deco_sg_table gthr_tbl[4];\t \n\tu32 rsvd28[16];\n\tstruct deco_sg_table sctr_tbl[4];\t \n\tu32 rsvd29[48];\n\tu32 descbuf[64];\t \n\tu32 rscvd30[193];\n#define DESC_DBG_DECO_STAT_VALID\t0x80000000\n#define DESC_DBG_DECO_STAT_MASK\t\t0x00F00000\n#define DESC_DBG_DECO_STAT_SHIFT\t20\n\tu32 desc_dbg;\t\t \n\tu32 rsvd31[13];\n#define DESC_DER_DECO_STAT_MASK\t\t0x000F0000\n#define DESC_DER_DECO_STAT_SHIFT\t16\n\tu32 dbg_exec;\t\t \n\tu32 rsvd32[112];\n};\n\n#define DECO_STAT_HOST_ERR\t0xD\n\n#define DECO_JQCR_WHL\t\t0x20000000\n#define DECO_JQCR_FOUR\t\t0x10000000\n\n#define JR_BLOCK_NUMBER\t\t1\n#define ASSURE_BLOCK_NUMBER\t6\n#define QI_BLOCK_NUMBER\t\t7\n#define DECO_BLOCK_NUMBER\t8\n#define PG_SIZE_4K\t\t0x1000\n#define PG_SIZE_64K\t\t0x10000\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}