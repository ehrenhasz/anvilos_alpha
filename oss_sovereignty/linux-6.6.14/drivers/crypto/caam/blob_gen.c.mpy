{
  "module_name": "blob_gen.c",
  "hash_id": "20ce9afbf962a3d6182dbec6aa87070f7be805bc1ae0c82c45948d4ea18f2e33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/caam/blob_gen.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"caam blob_gen: \" fmt\n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <soc/fsl/caam-blob.h>\n\n#include \"compat.h\"\n#include \"desc_constr.h\"\n#include \"desc.h\"\n#include \"error.h\"\n#include \"intern.h\"\n#include \"jr.h\"\n#include \"regs.h\"\n\n#define CAAM_BLOB_DESC_BYTES_MAX\t\t\t\t\t\\\n\t \t\\\n\t(CAAM_CMD_SZ +\t\t\t\t\t\t\t\\\n\t \t\\\n\t CAAM_CMD_SZ + CAAM_BLOB_KEYMOD_LENGTH +\t\t\t\\\n\t \t\\\n\t CAAM_CMD_SZ + CAAM_PTR_SZ_MAX +\t\t\t\t\\\n\t \t\\\n\t CAAM_CMD_SZ + CAAM_PTR_SZ_MAX +\t\t\t\t\\\n\t \t\t\\\n\t CAAM_CMD_SZ)\n\nstruct caam_blob_priv {\n\tstruct device jrdev;\n};\n\nstruct caam_blob_job_result {\n\tint err;\n\tstruct completion completion;\n};\n\nstatic void caam_blob_job_done(struct device *dev, u32 *desc, u32 err, void *context)\n{\n\tstruct caam_blob_job_result *res = context;\n\tint ecode = 0;\n\n\tdev_dbg(dev, \"%s %d: err 0x%x\\n\", __func__, __LINE__, err);\n\n\tif (err)\n\t\tecode = caam_jr_strstatus(dev, err);\n\n\tres->err = ecode;\n\n\t \n\tcomplete(&res->completion);\n}\n\nint caam_process_blob(struct caam_blob_priv *priv,\n\t\t      struct caam_blob_info *info, bool encap)\n{\n\tconst struct caam_drv_private *ctrlpriv;\n\tstruct caam_blob_job_result testres;\n\tstruct device *jrdev = &priv->jrdev;\n\tdma_addr_t dma_in, dma_out;\n\tint op = OP_PCLID_BLOB;\n\tsize_t output_len;\n\tu32 *desc;\n\tu32 moo;\n\tint ret;\n\n\tif (info->key_mod_len > CAAM_BLOB_KEYMOD_LENGTH)\n\t\treturn -EINVAL;\n\n\tif (encap) {\n\t\top |= OP_TYPE_ENCAP_PROTOCOL;\n\t\toutput_len = info->input_len + CAAM_BLOB_OVERHEAD;\n\t} else {\n\t\top |= OP_TYPE_DECAP_PROTOCOL;\n\t\toutput_len = info->input_len - CAAM_BLOB_OVERHEAD;\n\t}\n\n\tdesc = kzalloc(CAAM_BLOB_DESC_BYTES_MAX, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tdma_in = dma_map_single(jrdev, info->input, info->input_len,\n\t\t\t\tDMA_TO_DEVICE);\n\tif (dma_mapping_error(jrdev, dma_in)) {\n\t\tdev_err(jrdev, \"unable to map input DMA buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tdma_out = dma_map_single(jrdev, info->output, output_len,\n\t\t\t\t DMA_FROM_DEVICE);\n\tif (dma_mapping_error(jrdev, dma_out)) {\n\t\tdev_err(jrdev, \"unable to map output DMA buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap_in;\n\t}\n\n\tctrlpriv = dev_get_drvdata(jrdev->parent);\n\tmoo = FIELD_GET(CSTA_MOO, rd_reg32(&ctrlpriv->ctrl->perfmon.status));\n\tif (moo != CSTA_MOO_SECURE && moo != CSTA_MOO_TRUSTED)\n\t\tdev_warn(jrdev,\n\t\t\t \"using insecure test key, enable HAB to use unique device key!\\n\");\n\n\t \n\n\tinit_job_desc(desc, 0);\n\tappend_key_as_imm(desc, info->key_mod, info->key_mod_len,\n\t\t\t  info->key_mod_len, CLASS_2 | KEY_DEST_CLASS_REG);\n\tappend_seq_in_ptr_intlen(desc, dma_in, info->input_len, 0);\n\tappend_seq_out_ptr_intlen(desc, dma_out, output_len, 0);\n\tappend_operation(desc, op);\n\n\tprint_hex_dump_debug(\"data@\"__stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 1, info->input,\n\t\t\t     info->input_len, false);\n\tprint_hex_dump_debug(\"jobdesc@\"__stringify(__LINE__)\": \",\n\t\t\t     DUMP_PREFIX_ADDRESS, 16, 1, desc,\n\t\t\t     desc_bytes(desc), false);\n\n\ttestres.err = 0;\n\tinit_completion(&testres.completion);\n\n\tret = caam_jr_enqueue(jrdev, desc, caam_blob_job_done, &testres);\n\tif (ret == -EINPROGRESS) {\n\t\twait_for_completion(&testres.completion);\n\t\tret = testres.err;\n\t\tprint_hex_dump_debug(\"output@\"__stringify(__LINE__)\": \",\n\t\t\t\t     DUMP_PREFIX_ADDRESS, 16, 1, info->output,\n\t\t\t\t     output_len, false);\n\t}\n\n\tif (ret == 0)\n\t\tinfo->output_len = output_len;\n\n\tdma_unmap_single(jrdev, dma_out, output_len, DMA_FROM_DEVICE);\nout_unmap_in:\n\tdma_unmap_single(jrdev, dma_in, info->input_len, DMA_TO_DEVICE);\nout_free:\n\tkfree(desc);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(caam_process_blob);\n\nstruct caam_blob_priv *caam_blob_gen_init(void)\n{\n\tstruct caam_drv_private *ctrlpriv;\n\tstruct device *jrdev;\n\n\t \n\n\tjrdev = caam_jr_alloc();\n\tif (IS_ERR(jrdev)) {\n\t\tpr_info(\"job ring requested, but none currently available\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tctrlpriv = dev_get_drvdata(jrdev->parent);\n\tif (!ctrlpriv->blob_present) {\n\t\tdev_info(jrdev, \"no hardware blob generation support\\n\");\n\t\tcaam_jr_free(jrdev);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\treturn container_of(jrdev, struct caam_blob_priv, jrdev);\n}\nEXPORT_SYMBOL(caam_blob_gen_init);\n\nvoid caam_blob_gen_exit(struct caam_blob_priv *priv)\n{\n\tcaam_jr_free(&priv->jrdev);\n}\nEXPORT_SYMBOL(caam_blob_gen_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}