{
  "module_name": "desc_constr.h",
  "hash_id": "3789a6d2ef13721cdf70e8963573974861669d063851ec12ff89aee2fb1341e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/caam/desc_constr.h",
  "human_readable_source": " \n \n\n#ifndef DESC_CONSTR_H\n#define DESC_CONSTR_H\n\n#include \"desc.h\"\n#include \"regs.h\"\n\n#define IMMEDIATE (1 << 23)\n#define CAAM_CMD_SZ sizeof(u32)\n#define CAAM_PTR_SZ caam_ptr_sz\n#define CAAM_PTR_SZ_MAX sizeof(dma_addr_t)\n#define CAAM_PTR_SZ_MIN sizeof(u32)\n#define CAAM_DESC_BYTES_MAX (CAAM_CMD_SZ * MAX_CAAM_DESCSIZE)\n#define __DESC_JOB_IO_LEN(n) (CAAM_CMD_SZ * 5 + (n) * 3)\n#define DESC_JOB_IO_LEN __DESC_JOB_IO_LEN(CAAM_PTR_SZ)\n#define DESC_JOB_IO_LEN_MAX __DESC_JOB_IO_LEN(CAAM_PTR_SZ_MAX)\n#define DESC_JOB_IO_LEN_MIN __DESC_JOB_IO_LEN(CAAM_PTR_SZ_MIN)\n\n \n#define MAX_SDLEN\t((CAAM_DESC_BYTES_MAX - DESC_JOB_IO_LEN_MIN) / CAAM_CMD_SZ)\n\n#ifdef DEBUG\n#define PRINT_POS do { printk(KERN_DEBUG \"%02d: %s\\n\", desc_len(desc),\\\n\t\t\t      &__func__[sizeof(\"append\")]); } while (0)\n#else\n#define PRINT_POS\n#endif\n\n#define SET_OK_NO_PROP_ERRORS (IMMEDIATE | LDST_CLASS_DECO | \\\n\t\t\t       LDST_SRCDST_WORD_DECOCTRL | \\\n\t\t\t       (LDOFF_CHG_SHARE_OK_NO_PROP << \\\n\t\t\t\tLDST_OFFSET_SHIFT))\n#define DISABLE_AUTO_INFO_FIFO (IMMEDIATE | LDST_CLASS_DECO | \\\n\t\t\t\tLDST_SRCDST_WORD_DECOCTRL | \\\n\t\t\t\t(LDOFF_DISABLE_AUTO_NFIFO << LDST_OFFSET_SHIFT))\n#define ENABLE_AUTO_INFO_FIFO (IMMEDIATE | LDST_CLASS_DECO | \\\n\t\t\t       LDST_SRCDST_WORD_DECOCTRL | \\\n\t\t\t       (LDOFF_ENABLE_AUTO_NFIFO << LDST_OFFSET_SHIFT))\n\nextern bool caam_little_end;\nextern size_t caam_ptr_sz;\n\n \nstatic inline int pad_sg_nents(int sg_nents)\n{\n\treturn ALIGN(sg_nents, 4);\n}\n\nstatic inline int desc_len(u32 * const desc)\n{\n\treturn caam32_to_cpu(*desc) & HDR_DESCLEN_MASK;\n}\n\nstatic inline int desc_bytes(void * const desc)\n{\n\treturn desc_len(desc) * CAAM_CMD_SZ;\n}\n\nstatic inline u32 *desc_end(u32 * const desc)\n{\n\treturn desc + desc_len(desc);\n}\n\nstatic inline void *sh_desc_pdb(u32 * const desc)\n{\n\treturn desc + 1;\n}\n\nstatic inline void init_desc(u32 * const desc, u32 options)\n{\n\t*desc = cpu_to_caam32((options | HDR_ONE) + 1);\n}\n\nstatic inline void init_sh_desc(u32 * const desc, u32 options)\n{\n\tPRINT_POS;\n\tinit_desc(desc, CMD_SHARED_DESC_HDR | options);\n}\n\nstatic inline void init_sh_desc_pdb(u32 * const desc, u32 options,\n\t\t\t\t    size_t pdb_bytes)\n{\n\tu32 pdb_len = (pdb_bytes + CAAM_CMD_SZ - 1) / CAAM_CMD_SZ;\n\n\tinit_sh_desc(desc, (((pdb_len + 1) << HDR_START_IDX_SHIFT) + pdb_len) |\n\t\t     options);\n}\n\nstatic inline void init_job_desc(u32 * const desc, u32 options)\n{\n\tinit_desc(desc, CMD_DESC_HDR | options);\n}\n\nstatic inline void init_job_desc_pdb(u32 * const desc, u32 options,\n\t\t\t\t     size_t pdb_bytes)\n{\n\tu32 pdb_len = (pdb_bytes + CAAM_CMD_SZ - 1) / CAAM_CMD_SZ;\n\n\tinit_job_desc(desc, (((pdb_len + 1) << HDR_START_IDX_SHIFT)) | options);\n}\n\nstatic inline void append_ptr(u32 * const desc, dma_addr_t ptr)\n{\n\tif (caam_ptr_sz == sizeof(dma_addr_t)) {\n\t\tdma_addr_t *offset = (dma_addr_t *)desc_end(desc);\n\n\t\t*offset = cpu_to_caam_dma(ptr);\n\t} else {\n\t\tu32 *offset = (u32 *)desc_end(desc);\n\n\t\t*offset = cpu_to_caam_dma(ptr);\n\t}\n\n\t(*desc) = cpu_to_caam32(caam32_to_cpu(*desc) +\n\t\t\t\tCAAM_PTR_SZ / CAAM_CMD_SZ);\n}\n\nstatic inline void init_job_desc_shared(u32 * const desc, dma_addr_t ptr,\n\t\t\t\t\tint len, u32 options)\n{\n\tPRINT_POS;\n\tinit_job_desc(desc, HDR_SHARED | options |\n\t\t      (len << HDR_START_IDX_SHIFT));\n\tappend_ptr(desc, ptr);\n}\n\nstatic inline void append_data(u32 * const desc, const void *data, int len)\n{\n\tu32 *offset = desc_end(desc);\n\n\t \n\tif (!IS_ENABLED(CONFIG_CRYPTO_DEV_FSL_CAAM_DEBUG) || data)\n\t\tmemcpy(offset, data, len);\n\n\t(*desc) = cpu_to_caam32(caam32_to_cpu(*desc) +\n\t\t\t\t(len + CAAM_CMD_SZ - 1) / CAAM_CMD_SZ);\n}\n\nstatic inline void append_cmd(u32 * const desc, u32 command)\n{\n\tu32 *cmd = desc_end(desc);\n\n\t*cmd = cpu_to_caam32(command);\n\n\t(*desc) = cpu_to_caam32(caam32_to_cpu(*desc) + 1);\n}\n\n#define append_u32 append_cmd\n\nstatic inline void append_u64(u32 * const desc, u64 data)\n{\n\tu32 *offset = desc_end(desc);\n\n\t \n\tif (caam_little_end) {\n\t\t*offset = cpu_to_caam32(lower_32_bits(data));\n\t\t*(++offset) = cpu_to_caam32(upper_32_bits(data));\n\t} else {\n\t\t*offset = cpu_to_caam32(upper_32_bits(data));\n\t\t*(++offset) = cpu_to_caam32(lower_32_bits(data));\n\t}\n\n\t(*desc) = cpu_to_caam32(caam32_to_cpu(*desc) + 2);\n}\n\n \nstatic inline u32 *write_cmd(u32 * const desc, u32 command)\n{\n\t*desc = cpu_to_caam32(command);\n\n\treturn desc + 1;\n}\n\nstatic inline void append_cmd_ptr(u32 * const desc, dma_addr_t ptr, int len,\n\t\t\t\t  u32 command)\n{\n\tappend_cmd(desc, command | len);\n\tappend_ptr(desc, ptr);\n}\n\n \nstatic inline void append_cmd_ptr_extlen(u32 * const desc, dma_addr_t ptr,\n\t\t\t\t\t unsigned int len, u32 command)\n{\n\tappend_cmd(desc, command);\n\tif (!(command & (SQIN_RTO | SQIN_PRE)))\n\t\tappend_ptr(desc, ptr);\n\tappend_cmd(desc, len);\n}\n\nstatic inline void append_cmd_data(u32 * const desc, const void *data, int len,\n\t\t\t\t   u32 command)\n{\n\tappend_cmd(desc, command | IMMEDIATE | len);\n\tappend_data(desc, data, len);\n}\n\n#define APPEND_CMD_RET(cmd, op) \\\nstatic inline u32 *append_##cmd(u32 * const desc, u32 options) \\\n{ \\\n\tu32 *cmd = desc_end(desc); \\\n\tPRINT_POS; \\\n\tappend_cmd(desc, CMD_##op | options); \\\n\treturn cmd; \\\n}\nAPPEND_CMD_RET(jump, JUMP)\nAPPEND_CMD_RET(move, MOVE)\nAPPEND_CMD_RET(move_len, MOVE_LEN)\n\nstatic inline void set_jump_tgt_here(u32 * const desc, u32 *jump_cmd)\n{\n\t*jump_cmd = cpu_to_caam32(caam32_to_cpu(*jump_cmd) |\n\t\t\t\t  (desc_len(desc) - (jump_cmd - desc)));\n}\n\nstatic inline void set_move_tgt_here(u32 * const desc, u32 *move_cmd)\n{\n\tu32 val = caam32_to_cpu(*move_cmd);\n\n\tval &= ~MOVE_OFFSET_MASK;\n\tval |= (desc_len(desc) << (MOVE_OFFSET_SHIFT + 2)) & MOVE_OFFSET_MASK;\n\t*move_cmd = cpu_to_caam32(val);\n}\n\n#define APPEND_CMD(cmd, op) \\\nstatic inline void append_##cmd(u32 * const desc, u32 options) \\\n{ \\\n\tPRINT_POS; \\\n\tappend_cmd(desc, CMD_##op | options); \\\n}\nAPPEND_CMD(operation, OPERATION)\n\n#define APPEND_CMD_LEN(cmd, op) \\\nstatic inline void append_##cmd(u32 * const desc, unsigned int len, \\\n\t\t\t\tu32 options) \\\n{ \\\n\tPRINT_POS; \\\n\tappend_cmd(desc, CMD_##op | len | options); \\\n}\n\nAPPEND_CMD_LEN(seq_load, SEQ_LOAD)\nAPPEND_CMD_LEN(seq_store, SEQ_STORE)\nAPPEND_CMD_LEN(seq_fifo_load, SEQ_FIFO_LOAD)\nAPPEND_CMD_LEN(seq_fifo_store, SEQ_FIFO_STORE)\n\n#define APPEND_CMD_PTR(cmd, op) \\\nstatic inline void append_##cmd(u32 * const desc, dma_addr_t ptr, \\\n\t\t\t\tunsigned int len, u32 options) \\\n{ \\\n\tPRINT_POS; \\\n\tappend_cmd_ptr(desc, ptr, len, CMD_##op | options); \\\n}\nAPPEND_CMD_PTR(key, KEY)\nAPPEND_CMD_PTR(load, LOAD)\nAPPEND_CMD_PTR(fifo_load, FIFO_LOAD)\nAPPEND_CMD_PTR(fifo_store, FIFO_STORE)\n\nstatic inline void append_store(u32 * const desc, dma_addr_t ptr,\n\t\t\t\tunsigned int len, u32 options)\n{\n\tu32 cmd_src;\n\n\tcmd_src = options & LDST_SRCDST_MASK;\n\n\tappend_cmd(desc, CMD_STORE | options | len);\n\n\t \n\tif (!(cmd_src == LDST_SRCDST_WORD_DESCBUF_SHARED ||\n\t      cmd_src == LDST_SRCDST_WORD_DESCBUF_JOB    ||\n\t      cmd_src == LDST_SRCDST_WORD_DESCBUF_JOB_WE ||\n\t      cmd_src == LDST_SRCDST_WORD_DESCBUF_SHARED_WE))\n\t\tappend_ptr(desc, ptr);\n}\n\n#define APPEND_SEQ_PTR_INTLEN(cmd, op) \\\nstatic inline void append_seq_##cmd##_ptr_intlen(u32 * const desc, \\\n\t\t\t\t\t\t dma_addr_t ptr, \\\n\t\t\t\t\t\t unsigned int len, \\\n\t\t\t\t\t\t u32 options) \\\n{ \\\n\tPRINT_POS; \\\n\tif (options & (SQIN_RTO | SQIN_PRE)) \\\n\t\tappend_cmd(desc, CMD_SEQ_##op##_PTR | len | options); \\\n\telse \\\n\t\tappend_cmd_ptr(desc, ptr, len, CMD_SEQ_##op##_PTR | options); \\\n}\nAPPEND_SEQ_PTR_INTLEN(in, IN)\nAPPEND_SEQ_PTR_INTLEN(out, OUT)\n\n#define APPEND_CMD_PTR_TO_IMM(cmd, op) \\\nstatic inline void append_##cmd##_as_imm(u32 * const desc, const void *data, \\\n\t\t\t\t\t unsigned int len, u32 options) \\\n{ \\\n\tPRINT_POS; \\\n\tappend_cmd_data(desc, data, len, CMD_##op | options); \\\n}\nAPPEND_CMD_PTR_TO_IMM(load, LOAD);\nAPPEND_CMD_PTR_TO_IMM(fifo_load, FIFO_LOAD);\n\n#define APPEND_CMD_PTR_EXTLEN(cmd, op) \\\nstatic inline void append_##cmd##_extlen(u32 * const desc, dma_addr_t ptr, \\\n\t\t\t\t\t unsigned int len, u32 options) \\\n{ \\\n\tPRINT_POS; \\\n\tappend_cmd_ptr_extlen(desc, ptr, len, CMD_##op | SQIN_EXT | options); \\\n}\nAPPEND_CMD_PTR_EXTLEN(seq_in_ptr, SEQ_IN_PTR)\nAPPEND_CMD_PTR_EXTLEN(seq_out_ptr, SEQ_OUT_PTR)\n\n \n#define APPEND_CMD_PTR_LEN(cmd, op, type) \\\nstatic inline void append_##cmd(u32 * const desc, dma_addr_t ptr, \\\n\t\t\t\ttype len, u32 options) \\\n{ \\\n\tPRINT_POS; \\\n\tif (sizeof(type) > sizeof(u16)) \\\n\t\tappend_##cmd##_extlen(desc, ptr, len, options); \\\n\telse \\\n\t\tappend_##cmd##_intlen(desc, ptr, len, options); \\\n}\nAPPEND_CMD_PTR_LEN(seq_in_ptr, SEQ_IN_PTR, u32)\nAPPEND_CMD_PTR_LEN(seq_out_ptr, SEQ_OUT_PTR, u32)\n\n \n#define APPEND_CMD_PTR_TO_IMM2(cmd, op) \\\nstatic inline void append_##cmd##_as_imm(u32 * const desc, const void *data, \\\n\t\t\t\t\t unsigned int data_len, \\\n\t\t\t\t\t unsigned int len, u32 options) \\\n{ \\\n\tPRINT_POS; \\\n\tappend_cmd(desc, CMD_##op | IMMEDIATE | len | options); \\\n\tappend_data(desc, data, data_len); \\\n}\nAPPEND_CMD_PTR_TO_IMM2(key, KEY);\n\n#define APPEND_CMD_RAW_IMM(cmd, op, type) \\\nstatic inline void append_##cmd##_imm_##type(u32 * const desc, type immediate, \\\n\t\t\t\t\t     u32 options) \\\n{ \\\n\tPRINT_POS; \\\n\tif (options & LDST_LEN_MASK) \\\n\t\tappend_cmd(desc, CMD_##op | IMMEDIATE | options); \\\n\telse \\\n\t\tappend_cmd(desc, CMD_##op | IMMEDIATE | options | \\\n\t\t\t   sizeof(type)); \\\n\tappend_cmd(desc, immediate); \\\n}\nAPPEND_CMD_RAW_IMM(load, LOAD, u32);\n\n \n#define APPEND_CMD_RAW_IMM2(cmd, op, ee, size) \\\nstatic inline void append_##cmd##_imm_##ee##size(u32 *desc, \\\n\t\t\t\t\t\t   u##size immediate, \\\n\t\t\t\t\t\t   u32 options) \\\n{ \\\n\t__##ee##size data = cpu_to_##ee##size(immediate); \\\n\tPRINT_POS; \\\n\tappend_cmd(desc, CMD_##op | IMMEDIATE | options | sizeof(data)); \\\n\tappend_data(desc, &data, sizeof(data)); \\\n}\n\nAPPEND_CMD_RAW_IMM2(load, LOAD, be, 32);\n\n \n#define APPEND_MATH(op, desc, dest, src_0, src_1, len) \\\nappend_cmd(desc, CMD_MATH | MATH_FUN_##op | MATH_DEST_##dest | \\\n\tMATH_SRC0_##src_0 | MATH_SRC1_##src_1 | (u32)len);\n\n#define append_math_add(desc, dest, src0, src1, len) \\\n\tAPPEND_MATH(ADD, desc, dest, src0, src1, len)\n#define append_math_sub(desc, dest, src0, src1, len) \\\n\tAPPEND_MATH(SUB, desc, dest, src0, src1, len)\n#define append_math_add_c(desc, dest, src0, src1, len) \\\n\tAPPEND_MATH(ADDC, desc, dest, src0, src1, len)\n#define append_math_sub_b(desc, dest, src0, src1, len) \\\n\tAPPEND_MATH(SUBB, desc, dest, src0, src1, len)\n#define append_math_and(desc, dest, src0, src1, len) \\\n\tAPPEND_MATH(AND, desc, dest, src0, src1, len)\n#define append_math_or(desc, dest, src0, src1, len) \\\n\tAPPEND_MATH(OR, desc, dest, src0, src1, len)\n#define append_math_xor(desc, dest, src0, src1, len) \\\n\tAPPEND_MATH(XOR, desc, dest, src0, src1, len)\n#define append_math_lshift(desc, dest, src0, src1, len) \\\n\tAPPEND_MATH(LSHIFT, desc, dest, src0, src1, len)\n#define append_math_rshift(desc, dest, src0, src1, len) \\\n\tAPPEND_MATH(RSHIFT, desc, dest, src0, src1, len)\n#define append_math_ldshift(desc, dest, src0, src1, len) \\\n\tAPPEND_MATH(SHLD, desc, dest, src0, src1, len)\n\n \n#define APPEND_MATH_IMM_u32(op, desc, dest, src_0, src_1, data) \\\ndo { \\\n\tAPPEND_MATH(op, desc, dest, src_0, src_1, CAAM_CMD_SZ); \\\n\tappend_cmd(desc, data); \\\n} while (0)\n\n#define append_math_add_imm_u32(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u32(ADD, desc, dest, src0, src1, data)\n#define append_math_sub_imm_u32(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u32(SUB, desc, dest, src0, src1, data)\n#define append_math_add_c_imm_u32(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u32(ADDC, desc, dest, src0, src1, data)\n#define append_math_sub_b_imm_u32(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u32(SUBB, desc, dest, src0, src1, data)\n#define append_math_and_imm_u32(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u32(AND, desc, dest, src0, src1, data)\n#define append_math_or_imm_u32(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u32(OR, desc, dest, src0, src1, data)\n#define append_math_xor_imm_u32(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u32(XOR, desc, dest, src0, src1, data)\n#define append_math_lshift_imm_u32(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u32(LSHIFT, desc, dest, src0, src1, data)\n#define append_math_rshift_imm_u32(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u32(RSHIFT, desc, dest, src0, src1, data)\n\n \n#define APPEND_MATH_IMM_u64(op, desc, dest, src_0, src_1, data) \\\ndo { \\\n\tu32 upper = (data >> 16) >> 16; \\\n\tAPPEND_MATH(op, desc, dest, src_0, src_1, CAAM_CMD_SZ * 2 | \\\n\t\t    (upper ? 0 : MATH_IFB)); \\\n\tif (upper) \\\n\t\tappend_u64(desc, data); \\\n\telse \\\n\t\tappend_u32(desc, lower_32_bits(data)); \\\n} while (0)\n\n#define append_math_add_imm_u64(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u64(ADD, desc, dest, src0, src1, data)\n#define append_math_sub_imm_u64(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u64(SUB, desc, dest, src0, src1, data)\n#define append_math_add_c_imm_u64(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u64(ADDC, desc, dest, src0, src1, data)\n#define append_math_sub_b_imm_u64(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u64(SUBB, desc, dest, src0, src1, data)\n#define append_math_and_imm_u64(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u64(AND, desc, dest, src0, src1, data)\n#define append_math_or_imm_u64(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u64(OR, desc, dest, src0, src1, data)\n#define append_math_xor_imm_u64(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u64(XOR, desc, dest, src0, src1, data)\n#define append_math_lshift_imm_u64(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u64(LSHIFT, desc, dest, src0, src1, data)\n#define append_math_rshift_imm_u64(desc, dest, src0, src1, data) \\\n\tAPPEND_MATH_IMM_u64(RSHIFT, desc, dest, src0, src1, data)\n\n \nstruct alginfo {\n\tu32 algtype;\n\tunsigned int keylen;\n\tunsigned int keylen_pad;\n\tdma_addr_t key_dma;\n\tconst void *key_virt;\n\tbool key_inline;\n};\n\n \nstatic inline int desc_inline_query(unsigned int sd_base_len,\n\t\t\t\t    unsigned int jd_len, unsigned int *data_len,\n\t\t\t\t    u32 *inl_mask, unsigned int count)\n{\n\tint rem_bytes = (int)(CAAM_DESC_BYTES_MAX - sd_base_len - jd_len);\n\tunsigned int i;\n\n\t*inl_mask = 0;\n\tfor (i = 0; (i < count) && (rem_bytes > 0); i++) {\n\t\tif (rem_bytes - (int)(data_len[i] +\n\t\t\t(count - i - 1) * CAAM_PTR_SZ) >= 0) {\n\t\t\trem_bytes -= data_len[i];\n\t\t\t*inl_mask |= (1 << i);\n\t\t} else {\n\t\t\trem_bytes -= CAAM_PTR_SZ;\n\t\t}\n\t}\n\n\treturn (rem_bytes >= 0) ? 0 : -1;\n}\n\n \nstatic inline void append_proto_dkp(u32 * const desc, struct alginfo *adata)\n{\n\tu32 protid;\n\n\t \n\tprotid = (adata->algtype & OP_ALG_ALGSEL_SUBMASK) |\n\t\t (0x20 << OP_ALG_ALGSEL_SHIFT);\n\n\tif (adata->key_inline) {\n\t\tint words;\n\n\t\tif (adata->keylen > adata->keylen_pad) {\n\t\t\tappend_operation(desc, OP_TYPE_UNI_PROTOCOL | protid |\n\t\t\t\t\t OP_PCL_DKP_SRC_PTR |\n\t\t\t\t\t OP_PCL_DKP_DST_IMM | adata->keylen);\n\t\t\tappend_ptr(desc, adata->key_dma);\n\n\t\t\twords = (ALIGN(adata->keylen_pad, CAAM_CMD_SZ) -\n\t\t\t\t CAAM_PTR_SZ) / CAAM_CMD_SZ;\n\t\t} else {\n\t\t\tappend_operation(desc, OP_TYPE_UNI_PROTOCOL | protid |\n\t\t\t\t\t OP_PCL_DKP_SRC_IMM |\n\t\t\t\t\t OP_PCL_DKP_DST_IMM | adata->keylen);\n\t\t\tappend_data(desc, adata->key_virt, adata->keylen);\n\n\t\t\twords = (ALIGN(adata->keylen_pad, CAAM_CMD_SZ) -\n\t\t\t\t ALIGN(adata->keylen, CAAM_CMD_SZ)) /\n\t\t\t\tCAAM_CMD_SZ;\n\t\t}\n\n\t\t \n\t\tif (words)\n\t\t\t(*desc) = cpu_to_caam32(caam32_to_cpu(*desc) + words);\n\t} else {\n\t\tappend_operation(desc, OP_TYPE_UNI_PROTOCOL | protid |\n\t\t\t\t OP_PCL_DKP_SRC_PTR | OP_PCL_DKP_DST_PTR |\n\t\t\t\t adata->keylen);\n\t\tappend_ptr(desc, adata->key_dma);\n\t}\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}