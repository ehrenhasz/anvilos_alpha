{
  "module_name": "jr.c",
  "hash_id": "143932ab2353858d86e9490b529010f1c7df821c4b1076dfcdc0d722d1b8c898",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/caam/jr.c",
  "human_readable_source": "\n \n\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n\n#include \"compat.h\"\n#include \"ctrl.h\"\n#include \"regs.h\"\n#include \"jr.h\"\n#include \"desc.h\"\n#include \"intern.h\"\n\nstruct jr_driver_data {\n\t \n\tstruct list_head\tjr_list;\n\tspinlock_t\t\tjr_alloc_lock;\t \n} ____cacheline_aligned;\n\nstatic struct jr_driver_data driver_data;\nstatic DEFINE_MUTEX(algs_lock);\nstatic unsigned int active_devs;\n\nstatic void register_algs(struct caam_drv_private_jr *jrpriv,\n\t\t\t  struct device *dev)\n{\n\tmutex_lock(&algs_lock);\n\n\tif (++active_devs != 1)\n\t\tgoto algs_unlock;\n\n\tcaam_algapi_init(dev);\n\tcaam_algapi_hash_init(dev);\n\tcaam_pkc_init(dev);\n\tjrpriv->hwrng = !caam_rng_init(dev);\n\tcaam_prng_register(dev);\n\tcaam_qi_algapi_init(dev);\n\nalgs_unlock:\n\tmutex_unlock(&algs_lock);\n}\n\nstatic void unregister_algs(void)\n{\n\tmutex_lock(&algs_lock);\n\n\tif (--active_devs != 0)\n\t\tgoto algs_unlock;\n\n\tcaam_qi_algapi_exit();\n\tcaam_prng_unregister(NULL);\n\tcaam_pkc_exit();\n\tcaam_algapi_hash_exit();\n\tcaam_algapi_exit();\n\nalgs_unlock:\n\tmutex_unlock(&algs_lock);\n}\n\nstatic void caam_jr_crypto_engine_exit(void *data)\n{\n\tstruct device *jrdev = data;\n\tstruct caam_drv_private_jr *jrpriv = dev_get_drvdata(jrdev);\n\n\t \n\tcrypto_engine_exit(jrpriv->engine);\n}\n\n \nstatic int caam_jr_stop_processing(struct device *dev, u32 jrcr_bits)\n{\n\tstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\n\tunsigned int timeout = 100000;\n\n\t \n\tif (rd_reg32(&jrp->rregs->jrintstatus) & JRINT_ERR_HALT_INPROGRESS)\n\t\tgoto wait_quiesce_completion;\n\n\t \n\tclrsetbits_32(&jrp->rregs->jrintstatus, JRINT_ERR_HALT_MASK, 0);\n\n\t \n\twr_reg32(&jrp->rregs->jrcommand, jrcr_bits);\n\nwait_quiesce_completion:\n\twhile (((rd_reg32(&jrp->rregs->jrintstatus) & JRINT_ERR_HALT_MASK) ==\n\t\tJRINT_ERR_HALT_INPROGRESS) && --timeout)\n\t\tcpu_relax();\n\n\tif ((rd_reg32(&jrp->rregs->jrintstatus) & JRINT_ERR_HALT_MASK) !=\n\t    JRINT_ERR_HALT_COMPLETE || timeout == 0) {\n\t\tdev_err(dev, \"failed to flush job ring %d\\n\", jrp->ridx);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int caam_jr_flush(struct device *dev)\n{\n\treturn caam_jr_stop_processing(dev, JRCR_RESET);\n}\n\n \nstatic int caam_jr_restart_processing(struct device *dev)\n{\n\tstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\n\tu32 halt_status = rd_reg32(&jrp->rregs->jrintstatus) &\n\t\t\t  JRINT_ERR_HALT_MASK;\n\n\t \n\tif (halt_status != JRINT_ERR_HALT_COMPLETE)\n\t\treturn -1;\n\n\t \n\tclrsetbits_32(&jrp->rregs->jrintstatus, 0, JRINT_ERR_HALT_COMPLETE);\n\n\treturn 0;\n}\n\nstatic int caam_reset_hw_jr(struct device *dev)\n{\n\tstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\n\tunsigned int timeout = 100000;\n\tint err;\n\t \n\tclrsetbits_32(&jrp->rregs->rconfig_lo, 0, JRCFG_IMSK);\n\terr = caam_jr_flush(dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\twr_reg32(&jrp->rregs->jrcommand, JRCR_RESET);\n\twhile ((rd_reg32(&jrp->rregs->jrcommand) & JRCR_RESET) && --timeout)\n\t\tcpu_relax();\n\n\tif (timeout == 0) {\n\t\tdev_err(dev, \"failed to reset job ring %d\\n\", jrp->ridx);\n\t\treturn -EIO;\n\t}\n\n\t \n\tclrsetbits_32(&jrp->rregs->rconfig_lo, JRCFG_IMSK, 0);\n\n\treturn 0;\n}\n\n \nstatic int caam_jr_shutdown(struct device *dev)\n{\n\tstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = caam_reset_hw_jr(dev);\n\n\ttasklet_kill(&jrp->irqtask);\n\n\treturn ret;\n}\n\nstatic int caam_jr_remove(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct device *jrdev;\n\tstruct caam_drv_private_jr *jrpriv;\n\n\tjrdev = &pdev->dev;\n\tjrpriv = dev_get_drvdata(jrdev);\n\n\tif (jrpriv->hwrng)\n\t\tcaam_rng_exit(jrdev->parent);\n\n\t \n\tif (atomic_read(&jrpriv->tfm_count)) {\n\t\tdev_err(jrdev, \"Device is busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tunregister_algs();\n\n\t \n\tspin_lock(&driver_data.jr_alloc_lock);\n\tlist_del(&jrpriv->list_node);\n\tspin_unlock(&driver_data.jr_alloc_lock);\n\n\t \n\tret = caam_jr_shutdown(jrdev);\n\tif (ret)\n\t\tdev_err(jrdev, \"Failed to shut down job ring\\n\");\n\n\treturn ret;\n}\n\nstatic void caam_jr_platform_shutdown(struct platform_device *pdev)\n{\n\tcaam_jr_remove(pdev);\n}\n\n \nstatic irqreturn_t caam_jr_interrupt(int irq, void *st_dev)\n{\n\tstruct device *dev = st_dev;\n\tstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\n\tu32 irqstate;\n\n\t \n\tirqstate = rd_reg32(&jrp->rregs->jrintstatus);\n\tif (!(irqstate & JRINT_JR_INT))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (irqstate & JRINT_JR_ERROR) {\n\t\tdev_err(dev, \"job ring error: irqstate: %08x\\n\", irqstate);\n\t\tBUG();\n\t}\n\n\t \n\tclrsetbits_32(&jrp->rregs->rconfig_lo, 0, JRCFG_IMSK);\n\n\t \n\twr_reg32(&jrp->rregs->jrintstatus, irqstate);\n\n\tpreempt_disable();\n\ttasklet_schedule(&jrp->irqtask);\n\tpreempt_enable();\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void caam_jr_dequeue(unsigned long devarg)\n{\n\tint hw_idx, sw_idx, i, head, tail;\n\tstruct caam_jr_dequeue_params *params = (void *)devarg;\n\tstruct device *dev = params->dev;\n\tstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\n\tvoid (*usercall)(struct device *dev, u32 *desc, u32 status, void *arg);\n\tu32 *userdesc, userstatus;\n\tvoid *userarg;\n\tu32 outring_used = 0;\n\n\twhile (outring_used ||\n\t       (outring_used = rd_reg32(&jrp->rregs->outring_used))) {\n\n\t\thead = READ_ONCE(jrp->head);\n\n\t\tsw_idx = tail = jrp->tail;\n\t\thw_idx = jrp->out_ring_read_index;\n\n\t\tfor (i = 0; CIRC_CNT(head, tail + i, JOBR_DEPTH) >= 1; i++) {\n\t\t\tsw_idx = (tail + i) & (JOBR_DEPTH - 1);\n\n\t\t\tif (jr_outentry_desc(jrp->outring, hw_idx) ==\n\t\t\t    caam_dma_to_cpu(jrp->entinfo[sw_idx].desc_addr_dma))\n\t\t\t\tbreak;  \n\t\t}\n\t\t \n\t\tBUG_ON(CIRC_CNT(head, tail + i, JOBR_DEPTH) <= 0);\n\n\t\t \n\t\tdma_unmap_single(dev,\n\t\t\t\t caam_dma_to_cpu(jr_outentry_desc(jrp->outring,\n\t\t\t\t\t\t\t\t  hw_idx)),\n\t\t\t\t jrp->entinfo[sw_idx].desc_size,\n\t\t\t\t DMA_TO_DEVICE);\n\n\t\t \n\t\tjrp->entinfo[sw_idx].desc_addr_dma = 0;\n\n\t\t \n\t\tusercall = jrp->entinfo[sw_idx].callbk;\n\t\tuserarg = jrp->entinfo[sw_idx].cbkarg;\n\t\tuserdesc = jrp->entinfo[sw_idx].desc_addr_virt;\n\t\tuserstatus = caam32_to_cpu(jr_outentry_jrstatus(jrp->outring,\n\t\t\t\t\t\t\t\thw_idx));\n\n\t\t \n\t\tmb();\n\n\t\t \n\t\twr_reg32(&jrp->rregs->outring_rmvd, 1);\n\n\t\tjrp->out_ring_read_index = (jrp->out_ring_read_index + 1) &\n\t\t\t\t\t   (JOBR_DEPTH - 1);\n\n\t\t \n\t\tif (sw_idx == tail) {\n\t\t\tdo {\n\t\t\t\ttail = (tail + 1) & (JOBR_DEPTH - 1);\n\t\t\t} while (CIRC_CNT(head, tail, JOBR_DEPTH) >= 1 &&\n\t\t\t\t jrp->entinfo[tail].desc_addr_dma == 0);\n\n\t\t\tjrp->tail = tail;\n\t\t}\n\n\t\t \n\t\tusercall(dev, userdesc, userstatus, userarg);\n\t\toutring_used--;\n\t}\n\n\tif (params->enable_itr)\n\t\t \n\t\tclrsetbits_32(&jrp->rregs->rconfig_lo, JRCFG_IMSK, 0);\n}\n\n \nstruct device *caam_jr_alloc(void)\n{\n\tstruct caam_drv_private_jr *jrpriv, *min_jrpriv = NULL;\n\tstruct device *dev = ERR_PTR(-ENODEV);\n\tint min_tfm_cnt\t= INT_MAX;\n\tint tfm_cnt;\n\n\tspin_lock(&driver_data.jr_alloc_lock);\n\n\tif (list_empty(&driver_data.jr_list)) {\n\t\tspin_unlock(&driver_data.jr_alloc_lock);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tlist_for_each_entry(jrpriv, &driver_data.jr_list, list_node) {\n\t\ttfm_cnt = atomic_read(&jrpriv->tfm_count);\n\t\tif (tfm_cnt < min_tfm_cnt) {\n\t\t\tmin_tfm_cnt = tfm_cnt;\n\t\t\tmin_jrpriv = jrpriv;\n\t\t}\n\t\tif (!min_tfm_cnt)\n\t\t\tbreak;\n\t}\n\n\tif (min_jrpriv) {\n\t\tatomic_inc(&min_jrpriv->tfm_count);\n\t\tdev = min_jrpriv->dev;\n\t}\n\tspin_unlock(&driver_data.jr_alloc_lock);\n\n\treturn dev;\n}\nEXPORT_SYMBOL(caam_jr_alloc);\n\n \nvoid caam_jr_free(struct device *rdev)\n{\n\tstruct caam_drv_private_jr *jrpriv = dev_get_drvdata(rdev);\n\n\tatomic_dec(&jrpriv->tfm_count);\n}\nEXPORT_SYMBOL(caam_jr_free);\n\n \nint caam_jr_enqueue(struct device *dev, u32 *desc,\n\t\t    void (*cbk)(struct device *dev, u32 *desc,\n\t\t\t\tu32 status, void *areq),\n\t\t    void *areq)\n{\n\tstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\n\tstruct caam_jrentry_info *head_entry;\n\tint head, tail, desc_size;\n\tdma_addr_t desc_dma;\n\n\tdesc_size = (caam32_to_cpu(*desc) & HDR_JD_LENGTH_MASK) * sizeof(u32);\n\tdesc_dma = dma_map_single(dev, desc, desc_size, DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, desc_dma)) {\n\t\tdev_err(dev, \"caam_jr_enqueue(): can't map jobdesc\\n\");\n\t\treturn -EIO;\n\t}\n\n\tspin_lock_bh(&jrp->inplock);\n\n\thead = jrp->head;\n\ttail = READ_ONCE(jrp->tail);\n\n\tif (!jrp->inpring_avail ||\n\t    CIRC_SPACE(head, tail, JOBR_DEPTH) <= 0) {\n\t\tspin_unlock_bh(&jrp->inplock);\n\t\tdma_unmap_single(dev, desc_dma, desc_size, DMA_TO_DEVICE);\n\t\treturn -ENOSPC;\n\t}\n\n\thead_entry = &jrp->entinfo[head];\n\thead_entry->desc_addr_virt = desc;\n\thead_entry->desc_size = desc_size;\n\thead_entry->callbk = (void *)cbk;\n\thead_entry->cbkarg = areq;\n\thead_entry->desc_addr_dma = desc_dma;\n\n\tjr_inpentry_set(jrp->inpring, head, cpu_to_caam_dma(desc_dma));\n\n\t \n\twmb();\n\n\tjrp->head = (head + 1) & (JOBR_DEPTH - 1);\n\n\t \n\n\twr_reg32(&jrp->rregs->inpring_jobadd, 1);\n\n\tjrp->inpring_avail--;\n\tif (!jrp->inpring_avail)\n\t\tjrp->inpring_avail = rd_reg32(&jrp->rregs->inpring_avail);\n\n\tspin_unlock_bh(&jrp->inplock);\n\n\treturn -EINPROGRESS;\n}\nEXPORT_SYMBOL(caam_jr_enqueue);\n\nstatic void caam_jr_init_hw(struct device *dev, dma_addr_t inpbusaddr,\n\t\t\t    dma_addr_t outbusaddr)\n{\n\tstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\n\n\twr_reg64(&jrp->rregs->inpring_base, inpbusaddr);\n\twr_reg64(&jrp->rregs->outring_base, outbusaddr);\n\twr_reg32(&jrp->rregs->inpring_size, JOBR_DEPTH);\n\twr_reg32(&jrp->rregs->outring_size, JOBR_DEPTH);\n\n\t \n\tclrsetbits_32(&jrp->rregs->rconfig_lo, 0, JOBR_INTC |\n\t\t      (JOBR_INTC_COUNT_THLD << JRCFG_ICDCT_SHIFT) |\n\t\t      (JOBR_INTC_TIME_THLD << JRCFG_ICTT_SHIFT));\n}\n\nstatic void caam_jr_reset_index(struct caam_drv_private_jr *jrp)\n{\n\tjrp->out_ring_read_index = 0;\n\tjrp->head = 0;\n\tjrp->tail = 0;\n}\n\n \nstatic int caam_jr_init(struct device *dev)\n{\n\tstruct caam_drv_private_jr *jrp;\n\tdma_addr_t inpbusaddr, outbusaddr;\n\tint i, error;\n\n\tjrp = dev_get_drvdata(dev);\n\n\terror = caam_reset_hw_jr(dev);\n\tif (error)\n\t\treturn error;\n\n\tjrp->inpring = dmam_alloc_coherent(dev, SIZEOF_JR_INPENTRY *\n\t\t\t\t\t   JOBR_DEPTH, &inpbusaddr,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!jrp->inpring)\n\t\treturn -ENOMEM;\n\n\tjrp->outring = dmam_alloc_coherent(dev, SIZEOF_JR_OUTENTRY *\n\t\t\t\t\t   JOBR_DEPTH, &outbusaddr,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!jrp->outring)\n\t\treturn -ENOMEM;\n\n\tjrp->entinfo = devm_kcalloc(dev, JOBR_DEPTH, sizeof(*jrp->entinfo),\n\t\t\t\t    GFP_KERNEL);\n\tif (!jrp->entinfo)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < JOBR_DEPTH; i++)\n\t\tjrp->entinfo[i].desc_addr_dma = !0;\n\n\t \n\tcaam_jr_reset_index(jrp);\n\tjrp->inpring_avail = JOBR_DEPTH;\n\tcaam_jr_init_hw(dev, inpbusaddr, outbusaddr);\n\n\tspin_lock_init(&jrp->inplock);\n\n\tjrp->tasklet_params.dev = dev;\n\tjrp->tasklet_params.enable_itr = 1;\n\ttasklet_init(&jrp->irqtask, caam_jr_dequeue,\n\t\t     (unsigned long)&jrp->tasklet_params);\n\n\t \n\terror = devm_request_irq(dev, jrp->irq, caam_jr_interrupt, IRQF_SHARED,\n\t\t\t\t dev_name(dev), dev);\n\tif (error) {\n\t\tdev_err(dev, \"can't connect JobR %d interrupt (%d)\\n\",\n\t\t\tjrp->ridx, jrp->irq);\n\t\ttasklet_kill(&jrp->irqtask);\n\t}\n\n\treturn error;\n}\n\nstatic void caam_jr_irq_dispose_mapping(void *data)\n{\n\tirq_dispose_mapping((unsigned long)data);\n}\n\n \nstatic int caam_jr_probe(struct platform_device *pdev)\n{\n\tstruct device *jrdev;\n\tstruct device_node *nprop;\n\tstruct caam_job_ring __iomem *ctrl;\n\tstruct caam_drv_private_jr *jrpriv;\n\tstatic int total_jobrs;\n\tstruct resource *r;\n\tint error;\n\n\tjrdev = &pdev->dev;\n\tjrpriv = devm_kzalloc(jrdev, sizeof(*jrpriv), GFP_KERNEL);\n\tif (!jrpriv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(jrdev, jrpriv);\n\n\t \n\tjrpriv->ridx = total_jobrs++;\n\n\tnprop = pdev->dev.of_node;\n\t \n\t \n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tdev_err(jrdev, \"platform_get_resource() failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tctrl = devm_ioremap(jrdev, r->start, resource_size(r));\n\tif (!ctrl) {\n\t\tdev_err(jrdev, \"devm_ioremap() failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tjrpriv->rregs = (struct caam_job_ring __iomem __force *)ctrl;\n\n\terror = dma_set_mask_and_coherent(jrdev, caam_get_dma_mask(jrdev));\n\tif (error) {\n\t\tdev_err(jrdev, \"dma_set_mask_and_coherent failed (%d)\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\t \n\tjrpriv->engine = crypto_engine_alloc_init_and_set(jrdev, true, NULL,\n\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t  CRYPTO_ENGINE_MAX_QLEN);\n\tif (!jrpriv->engine) {\n\t\tdev_err(jrdev, \"Could not init crypto-engine\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terror = devm_add_action_or_reset(jrdev, caam_jr_crypto_engine_exit,\n\t\t\t\t\t jrdev);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = crypto_engine_start(jrpriv->engine);\n\tif (error) {\n\t\tdev_err(jrdev, \"Could not start crypto-engine\\n\");\n\t\treturn error;\n\t}\n\n\t \n\tjrpriv->irq = irq_of_parse_and_map(nprop, 0);\n\tif (!jrpriv->irq) {\n\t\tdev_err(jrdev, \"irq_of_parse_and_map failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terror = devm_add_action_or_reset(jrdev, caam_jr_irq_dispose_mapping,\n\t\t\t\t\t (void *)(unsigned long)jrpriv->irq);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = caam_jr_init(jrdev);  \n\tif (error)\n\t\treturn error;\n\n\tjrpriv->dev = jrdev;\n\tspin_lock(&driver_data.jr_alloc_lock);\n\tlist_add_tail(&jrpriv->list_node, &driver_data.jr_list);\n\tspin_unlock(&driver_data.jr_alloc_lock);\n\n\tatomic_set(&jrpriv->tfm_count, 0);\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\tdevice_set_wakeup_enable(&pdev->dev, false);\n\n\tregister_algs(jrpriv, jrdev->parent);\n\n\treturn 0;\n}\n\nstatic void caam_jr_get_hw_state(struct device *dev)\n{\n\tstruct caam_drv_private_jr *jrp = dev_get_drvdata(dev);\n\n\tjrp->state.inpbusaddr = rd_reg64(&jrp->rregs->inpring_base);\n\tjrp->state.outbusaddr = rd_reg64(&jrp->rregs->outring_base);\n}\n\nstatic int caam_jr_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct caam_drv_private_jr *jrpriv = platform_get_drvdata(pdev);\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(dev->parent);\n\tstruct caam_jr_dequeue_params suspend_params = {\n\t\t.dev = dev,\n\t\t.enable_itr = 0,\n\t};\n\n\t \n\tspin_lock(&driver_data.jr_alloc_lock);\n\tlist_del(&jrpriv->list_node);\n\tspin_unlock(&driver_data.jr_alloc_lock);\n\n\tif (jrpriv->hwrng)\n\t\tcaam_rng_exit(dev->parent);\n\n\tif (ctrlpriv->caam_off_during_pm) {\n\t\tint err;\n\n\t\ttasklet_disable(&jrpriv->irqtask);\n\n\t\t \n\t\tclrsetbits_32(&jrpriv->rregs->rconfig_lo, 0, JRCFG_IMSK);\n\n\t\t \n\t\terr = caam_jr_flush(dev);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to flush\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tcaam_jr_dequeue((unsigned long)&suspend_params);\n\n\t\t \n\t\tcaam_jr_get_hw_state(dev);\n\t} else if (device_may_wakeup(&pdev->dev)) {\n\t\tenable_irq_wake(jrpriv->irq);\n\t}\n\n\treturn 0;\n}\n\nstatic int caam_jr_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct caam_drv_private_jr *jrpriv = platform_get_drvdata(pdev);\n\tstruct caam_drv_private *ctrlpriv = dev_get_drvdata(dev->parent);\n\n\tif (ctrlpriv->caam_off_during_pm) {\n\t\tu64 inp_addr;\n\t\tint err;\n\n\t\t \n\t\tinp_addr = rd_reg64(&jrpriv->rregs->inpring_base);\n\t\tif (inp_addr != 0) {\n\t\t\t \n\t\t\tif (inp_addr == jrpriv->state.inpbusaddr) {\n\t\t\t\t \n\t\t\t\terr = caam_jr_restart_processing(dev);\n\t\t\t\tif (err) {\n\t\t\t\t\tdev_err(dev,\n\t\t\t\t\t\t\"Restart processing failed\\n\");\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\n\t\t\t\ttasklet_enable(&jrpriv->irqtask);\n\n\t\t\t\tclrsetbits_32(&jrpriv->rregs->rconfig_lo,\n\t\t\t\t\t      JRCFG_IMSK, 0);\n\n\t\t\t\tgoto add_jr;\n\t\t\t} else if (ctrlpriv->optee_en) {\n\t\t\t\t \n\t\t\t\terr = caam_reset_hw_jr(dev);\n\t\t\t\tif (err) {\n\t\t\t\t\tdev_err(dev, \"Failed to reset JR\\n\");\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\tcaam_jr_reset_index(jrpriv);\n\t\tcaam_jr_init_hw(dev, jrpriv->state.inpbusaddr,\n\t\t\t\tjrpriv->state.outbusaddr);\n\n\t\ttasklet_enable(&jrpriv->irqtask);\n\t} else if (device_may_wakeup(&pdev->dev)) {\n\t\tdisable_irq_wake(jrpriv->irq);\n\t}\n\nadd_jr:\n\tspin_lock(&driver_data.jr_alloc_lock);\n\tlist_add_tail(&jrpriv->list_node, &driver_data.jr_list);\n\tspin_unlock(&driver_data.jr_alloc_lock);\n\n\tif (jrpriv->hwrng)\n\t\tjrpriv->hwrng = !caam_rng_init(dev->parent);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(caam_jr_pm_ops, caam_jr_suspend, caam_jr_resume);\n\nstatic const struct of_device_id caam_jr_match[] = {\n\t{\n\t\t.compatible = \"fsl,sec-v4.0-job-ring\",\n\t},\n\t{\n\t\t.compatible = \"fsl,sec4.0-job-ring\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, caam_jr_match);\n\nstatic struct platform_driver caam_jr_driver = {\n\t.driver = {\n\t\t.name = \"caam_jr\",\n\t\t.of_match_table = caam_jr_match,\n\t\t.pm = pm_ptr(&caam_jr_pm_ops),\n\t},\n\t.probe       = caam_jr_probe,\n\t.remove      = caam_jr_remove,\n\t.shutdown    = caam_jr_platform_shutdown,\n};\n\nstatic int __init jr_driver_init(void)\n{\n\tspin_lock_init(&driver_data.jr_alloc_lock);\n\tINIT_LIST_HEAD(&driver_data.jr_list);\n\treturn platform_driver_register(&caam_jr_driver);\n}\n\nstatic void __exit jr_driver_exit(void)\n{\n\tplatform_driver_unregister(&caam_jr_driver);\n}\n\nmodule_init(jr_driver_init);\nmodule_exit(jr_driver_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"FSL CAAM JR request backend\");\nMODULE_AUTHOR(\"Freescale Semiconductor - NMG/STC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}