{
  "module_name": "sa2ul.c",
  "hash_id": "e806e30e7b8ef45f8a4828e46c3a5412fad89ba7fe7b1dbe60af52a5596e2270",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/sa2ul.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/dmapool.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <crypto/aes.h>\n#include <crypto/authenc.h>\n#include <crypto/des.h>\n#include <crypto/internal/aead.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/sha1.h>\n#include <crypto/sha2.h>\n\n#include \"sa2ul.h\"\n\n \n#define SC_ENC_KEY_OFFSET (1 + 27 + 4)\n \n#define SC_ENC_AUX1_OFFSET (1 + 27 + 4 + 32)\n\n#define SA_CMDL_UPD_ENC         0x0001\n#define SA_CMDL_UPD_AUTH        0x0002\n#define SA_CMDL_UPD_ENC_IV      0x0004\n#define SA_CMDL_UPD_AUTH_IV     0x0008\n#define SA_CMDL_UPD_AUX_KEY     0x0010\n\n#define SA_AUTH_SUBKEY_LEN\t16\n#define SA_CMDL_PAYLOAD_LENGTH_MASK\t0xFFFF\n#define SA_CMDL_SOP_BYPASS_LEN_MASK\t0xFF000000\n\n#define MODE_CONTROL_BYTES\t27\n#define SA_HASH_PROCESSING\t0\n#define SA_CRYPTO_PROCESSING\t0\n#define SA_UPLOAD_HASH_TO_TLR\tBIT(6)\n\n#define SA_SW0_FLAGS_MASK\t0xF0000\n#define SA_SW0_CMDL_INFO_MASK\t0x1F00000\n#define SA_SW0_CMDL_PRESENT\tBIT(4)\n#define SA_SW0_ENG_ID_MASK\t0x3E000000\n#define SA_SW0_DEST_INFO_PRESENT\tBIT(30)\n#define SA_SW2_EGRESS_LENGTH\t\t0xFF000000\n#define SA_BASIC_HASH\t\t0x10\n\n#define SHA256_DIGEST_WORDS    8\n \n#define SA_MK_U32(b0, b1, b2, b3) (((b0) << 24) | ((b1) << 16) | \\\n\t\t\t\t   ((b2) << 8) | (b3))\n\n \n#define SA_SCCTL_SZ 16\n\n \n#define SA_MAX_AUTH_TAG_SZ 64\n\nenum sa_algo_id {\n\tSA_ALG_CBC_AES = 0,\n\tSA_ALG_EBC_AES,\n\tSA_ALG_CBC_DES3,\n\tSA_ALG_ECB_DES3,\n\tSA_ALG_SHA1,\n\tSA_ALG_SHA256,\n\tSA_ALG_SHA512,\n\tSA_ALG_AUTHENC_SHA1_AES,\n\tSA_ALG_AUTHENC_SHA256_AES,\n};\n\nstruct sa_match_data {\n\tu8 priv;\n\tu8 priv_id;\n\tu32 supported_algos;\n};\n\nstatic struct device *sa_k3_dev;\n\n \nstruct sa_cmdl_cfg {\n\tint aalg;\n\tu8 enc_eng_id;\n\tu8 auth_eng_id;\n\tu8 iv_size;\n\tconst u8 *akey;\n\tu16 akey_len;\n\tbool enc;\n};\n\n \nstruct algo_data {\n\tstruct sa_eng_info enc_eng;\n\tstruct sa_eng_info auth_eng;\n\tu8 auth_ctrl;\n\tu8 hash_size;\n\tu8 iv_idx;\n\tu8 iv_out_size;\n\tu8 ealg_id;\n\tu8 aalg_id;\n\tu8 *mci_enc;\n\tu8 *mci_dec;\n\tbool inv_key;\n\tstruct sa_tfm_ctx *ctx;\n\tbool keyed_mac;\n\tvoid (*prep_iopad)(struct algo_data *algo, const u8 *key,\n\t\t\t   u16 key_sz, __be32 *ipad, __be32 *opad);\n};\n\n \nstruct sa_alg_tmpl {\n\tu32 type;\t\t \n\tunion {\n\t\tstruct skcipher_alg skcipher;\n\t\tstruct ahash_alg ahash;\n\t\tstruct aead_alg aead;\n\t} alg;\n\tbool registered;\n};\n\n \nstruct sa_mapped_sg {\n\tbool mapped;\n\tenum dma_data_direction dir;\n\tstruct scatterlist static_sg;\n\tstruct scatterlist *split_sg;\n\tstruct sg_table sgt;\n};\n \nstruct sa_rx_data {\n\tvoid *req;\n\tstruct device *ddev;\n\tstruct dma_async_tx_descriptor *tx_in;\n\tstruct sa_mapped_sg mapped_sg[2];\n\tu8 enc;\n\tu8 enc_iv_size;\n\tu8 iv_idx;\n};\n\n \nstruct sa_req {\n\tstruct device *dev;\n\tu16 size;\n\tu8 enc_offset;\n\tu16 enc_size;\n\tu8 *enc_iv;\n\tu8 auth_offset;\n\tu16 auth_size;\n\tu8 *auth_iv;\n\tu32 type;\n\tu32 *cmdl;\n\tstruct crypto_async_request *base;\n\tstruct sa_tfm_ctx *ctx;\n\tbool enc;\n\tstruct scatterlist *src;\n\tstruct scatterlist *dst;\n\tdma_async_tx_callback callback;\n\tu16 mdata_size;\n};\n\n \nstatic u8 mci_cbc_enc_array[3][MODE_CONTROL_BYTES] = {\n\t{\t0x61, 0x00, 0x00, 0x18, 0x88, 0x0a, 0xaa, 0x4b, 0x7e, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n\t{\t0x61, 0x00, 0x00, 0x18, 0x88, 0x4a, 0xaa, 0x4b, 0x7e, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n\t{\t0x61, 0x00, 0x00, 0x18, 0x88, 0x8a, 0xaa, 0x4b, 0x7e, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n};\n\n \nstatic u8 mci_cbc_dec_array[3][MODE_CONTROL_BYTES] = {\n\t{\t0x71, 0x00, 0x00, 0x80, 0x8a, 0xca, 0x98, 0xf4, 0x40, 0xc0,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n\t{\t0x71, 0x00, 0x00, 0x84, 0x8a, 0xca, 0x98, 0xf4, 0x40, 0xc0,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n\t{\t0x71, 0x00, 0x00, 0x88, 0x8a, 0xca, 0x98, 0xf4, 0x40, 0xc0,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n};\n\n \nstatic u8 mci_cbc_enc_no_iv_array[3][MODE_CONTROL_BYTES] = {\n\t{\t0x21, 0x00, 0x00, 0x18, 0x88, 0x0a, 0xaa, 0x4b, 0x7e, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n\t{\t0x21, 0x00, 0x00, 0x18, 0x88, 0x4a, 0xaa, 0x4b, 0x7e, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n\t{\t0x21, 0x00, 0x00, 0x18, 0x88, 0x8a, 0xaa, 0x4b, 0x7e, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n};\n\n \nstatic u8 mci_cbc_dec_no_iv_array[3][MODE_CONTROL_BYTES] = {\n\t{\t0x31, 0x00, 0x00, 0x80, 0x8a, 0xca, 0x98, 0xf4, 0x40, 0xc0,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n\t{\t0x31, 0x00, 0x00, 0x84, 0x8a, 0xca, 0x98, 0xf4, 0x40, 0xc0,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n\t{\t0x31, 0x00, 0x00, 0x88, 0x8a, 0xca, 0x98, 0xf4, 0x40, 0xc0,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n};\n\n \nstatic u8 mci_ecb_enc_array[3][27] = {\n\t{\t0x21, 0x00, 0x00, 0x80, 0x8a, 0x04, 0xb7, 0x90, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n\t{\t0x21, 0x00, 0x00, 0x84, 0x8a, 0x04, 0xb7, 0x90, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n\t{\t0x21, 0x00, 0x00, 0x88, 0x8a, 0x04, 0xb7, 0x90, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n};\n\n \nstatic u8 mci_ecb_dec_array[3][27] = {\n\t{\t0x31, 0x00, 0x00, 0x80, 0x8a, 0x04, 0xb7, 0x90, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n\t{\t0x31, 0x00, 0x00, 0x84, 0x8a, 0x04, 0xb7, 0x90, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n\t{\t0x31, 0x00, 0x00, 0x88, 0x8a, 0x04, 0xb7, 0x90, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\t},\n};\n\n \nstatic u8 mci_cbc_3des_enc_array[MODE_CONTROL_BYTES] = {\n\t0x60, 0x00, 0x00, 0x18, 0x88, 0x52, 0xaa, 0x4b, 0x7e, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,\n};\n\nstatic u8 mci_cbc_3des_dec_array[MODE_CONTROL_BYTES] = {\n\t0x70, 0x00, 0x00, 0x85, 0x0a, 0xca, 0x98, 0xf4, 0x40, 0xc0, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,\n};\n\nstatic u8 mci_ecb_3des_enc_array[MODE_CONTROL_BYTES] = {\n\t0x20, 0x00, 0x00, 0x85, 0x0a, 0x04, 0xb7, 0x90, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,\n};\n\nstatic u8 mci_ecb_3des_dec_array[MODE_CONTROL_BYTES] = {\n\t0x30, 0x00, 0x00, 0x85, 0x0a, 0x04, 0xb7, 0x90, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00,\n};\n\n \nstatic void sa_swiz_128(u8 *in, u16 len)\n{\n\tu8 data[16];\n\tint i, j;\n\n\tfor (i = 0; i < len; i += 16) {\n\t\tmemcpy(data, &in[i], 16);\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tin[i + j] = data[15 - j];\n\t}\n}\n\n \nstatic void prepare_kipad(u8 *k_ipad, const u8 *key, u16 key_sz)\n{\n\tint i;\n\n\tfor (i = 0; i < key_sz; i++)\n\t\tk_ipad[i] = key[i] ^ 0x36;\n\n\t \n\tfor (; i < SHA1_BLOCK_SIZE; i++)\n\t\tk_ipad[i] = 0x36;\n}\n\nstatic void prepare_kopad(u8 *k_opad, const u8 *key, u16 key_sz)\n{\n\tint i;\n\n\tfor (i = 0; i < key_sz; i++)\n\t\tk_opad[i] = key[i] ^ 0x5c;\n\n\t \n\tfor (; i < SHA1_BLOCK_SIZE; i++)\n\t\tk_opad[i] = 0x5c;\n}\n\nstatic void sa_export_shash(void *state, struct shash_desc *hash,\n\t\t\t    int digest_size, __be32 *out)\n{\n\tstruct sha1_state *sha1;\n\tstruct sha256_state *sha256;\n\tu32 *result;\n\n\tswitch (digest_size) {\n\tcase SHA1_DIGEST_SIZE:\n\t\tsha1 = state;\n\t\tresult = sha1->state;\n\t\tbreak;\n\tcase SHA256_DIGEST_SIZE:\n\t\tsha256 = state;\n\t\tresult = sha256->state;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sa_k3_dev, \"%s: bad digest_size=%d\\n\", __func__,\n\t\t\tdigest_size);\n\t\treturn;\n\t}\n\n\tcrypto_shash_export(hash, state);\n\n\tcpu_to_be32_array(out, result, digest_size / 4);\n}\n\nstatic void sa_prepare_iopads(struct algo_data *data, const u8 *key,\n\t\t\t      u16 key_sz, __be32 *ipad, __be32 *opad)\n{\n\tSHASH_DESC_ON_STACK(shash, data->ctx->shash);\n\tint block_size = crypto_shash_blocksize(data->ctx->shash);\n\tint digest_size = crypto_shash_digestsize(data->ctx->shash);\n\tunion {\n\t\tstruct sha1_state sha1;\n\t\tstruct sha256_state sha256;\n\t\tu8 k_pad[SHA1_BLOCK_SIZE];\n\t} sha;\n\n\tshash->tfm = data->ctx->shash;\n\n\tprepare_kipad(sha.k_pad, key, key_sz);\n\n\tcrypto_shash_init(shash);\n\tcrypto_shash_update(shash, sha.k_pad, block_size);\n\tsa_export_shash(&sha, shash, digest_size, ipad);\n\n\tprepare_kopad(sha.k_pad, key, key_sz);\n\n\tcrypto_shash_init(shash);\n\tcrypto_shash_update(shash, sha.k_pad, block_size);\n\n\tsa_export_shash(&sha, shash, digest_size, opad);\n\n\tmemzero_explicit(&sha, sizeof(sha));\n}\n\n \nstatic inline int sa_aes_inv_key(u8 *inv_key, const u8 *key, u16 key_sz)\n{\n\tstruct crypto_aes_ctx ctx;\n\tint key_pos;\n\n\tif (aes_expandkey(&ctx, key, key_sz)) {\n\t\tdev_err(sa_k3_dev, \"%s: bad key len(%d)\\n\", __func__, key_sz);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (key_sz == AES_KEYSIZE_192) {\n\t\tctx.key_enc[52] = ctx.key_enc[51] ^ ctx.key_enc[46];\n\t\tctx.key_enc[53] = ctx.key_enc[52] ^ ctx.key_enc[47];\n\t}\n\n\t \n\tswitch (key_sz) {\n\tcase AES_KEYSIZE_128:\n\tcase AES_KEYSIZE_192:\n\t\tkey_pos = key_sz + 24;\n\t\tbreak;\n\n\tcase AES_KEYSIZE_256:\n\t\tkey_pos = key_sz + 24 - 4;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(sa_k3_dev, \"%s: bad key len(%d)\\n\", __func__, key_sz);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(inv_key, &ctx.key_enc[key_pos], key_sz);\n\treturn 0;\n}\n\n \nstatic int sa_set_sc_enc(struct algo_data *ad, const u8 *key, u16 key_sz,\n\t\t\t u8 enc, u8 *sc_buf)\n{\n\tconst u8 *mci = NULL;\n\n\t \n\tsc_buf[0] = SA_CRYPTO_PROCESSING;\n\n\tif (enc)\n\t\tmci = ad->mci_enc;\n\telse\n\t\tmci = ad->mci_dec;\n\t \n\tif (mci)\n\t\tmemcpy(&sc_buf[1], mci, MODE_CONTROL_BYTES);\n\n\t \n\tif (ad->inv_key && !enc) {\n\t\tif (sa_aes_inv_key(&sc_buf[SC_ENC_KEY_OFFSET], key, key_sz))\n\t\t\treturn -EINVAL;\n\t \n\t} else {\n\t\tmemcpy(&sc_buf[SC_ENC_KEY_OFFSET], key, key_sz);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void sa_set_sc_auth(struct algo_data *ad, const u8 *key, u16 key_sz,\n\t\t\t   u8 *sc_buf)\n{\n\t__be32 *ipad = (void *)(sc_buf + 32);\n\t__be32 *opad = (void *)(sc_buf + 64);\n\n\t \n\tsc_buf[0] = SA_HASH_PROCESSING;\n\t \n\tsc_buf[1] = SA_UPLOAD_HASH_TO_TLR;\n\tsc_buf[1] |= ad->auth_ctrl;\n\n\t \n\tif (ad->keyed_mac)\n\t\tad->prep_iopad(ad, key, key_sz, ipad, opad);\n\telse {\n\t\t \n\t\tsc_buf[1] |= SA_BASIC_HASH;\n\t}\n}\n\nstatic inline void sa_copy_iv(__be32 *out, const u8 *iv, bool size16)\n{\n\tint j;\n\n\tfor (j = 0; j < ((size16) ? 4 : 2); j++) {\n\t\t*out = cpu_to_be32(*((u32 *)iv));\n\t\tiv += 4;\n\t\tout++;\n\t}\n}\n\n \nstatic int sa_format_cmdl_gen(struct sa_cmdl_cfg *cfg, u8 *cmdl,\n\t\t\t      struct sa_cmdl_upd_info *upd_info)\n{\n\tu8 enc_offset = 0, auth_offset = 0, total = 0;\n\tu8 enc_next_eng = SA_ENG_ID_OUTPORT2;\n\tu8 auth_next_eng = SA_ENG_ID_OUTPORT2;\n\tu32 *word_ptr = (u32 *)cmdl;\n\tint i;\n\n\t \n\tmemzero_explicit(cmdl, (SA_MAX_CMDL_WORDS * sizeof(u32)));\n\n\t \n\tmemzero_explicit(upd_info, sizeof(*upd_info));\n\n\tif (cfg->enc_eng_id && cfg->auth_eng_id) {\n\t\tif (cfg->enc) {\n\t\t\tauth_offset = SA_CMDL_HEADER_SIZE_BYTES;\n\t\t\tenc_next_eng = cfg->auth_eng_id;\n\n\t\t\tif (cfg->iv_size)\n\t\t\t\tauth_offset += cfg->iv_size;\n\t\t} else {\n\t\t\tenc_offset = SA_CMDL_HEADER_SIZE_BYTES;\n\t\t\tauth_next_eng = cfg->enc_eng_id;\n\t\t}\n\t}\n\n\tif (cfg->enc_eng_id) {\n\t\tupd_info->flags |= SA_CMDL_UPD_ENC;\n\t\tupd_info->enc_size.index = enc_offset >> 2;\n\t\tupd_info->enc_offset.index = upd_info->enc_size.index + 1;\n\t\t \n\t\tcmdl[enc_offset + SA_CMDL_OFFSET_NESC] = enc_next_eng;\n\n\t\t \n\t\tif (cfg->iv_size) {\n\t\t\tupd_info->flags |= SA_CMDL_UPD_ENC_IV;\n\t\t\tupd_info->enc_iv.index =\n\t\t\t\t(enc_offset + SA_CMDL_HEADER_SIZE_BYTES) >> 2;\n\t\t\tupd_info->enc_iv.size = cfg->iv_size;\n\n\t\t\tcmdl[enc_offset + SA_CMDL_OFFSET_LABEL_LEN] =\n\t\t\t\tSA_CMDL_HEADER_SIZE_BYTES + cfg->iv_size;\n\n\t\t\tcmdl[enc_offset + SA_CMDL_OFFSET_OPTION_CTRL1] =\n\t\t\t\t(SA_CTX_ENC_AUX2_OFFSET | (cfg->iv_size >> 3));\n\t\t\ttotal += SA_CMDL_HEADER_SIZE_BYTES + cfg->iv_size;\n\t\t} else {\n\t\t\tcmdl[enc_offset + SA_CMDL_OFFSET_LABEL_LEN] =\n\t\t\t\t\t\tSA_CMDL_HEADER_SIZE_BYTES;\n\t\t\ttotal += SA_CMDL_HEADER_SIZE_BYTES;\n\t\t}\n\t}\n\n\tif (cfg->auth_eng_id) {\n\t\tupd_info->flags |= SA_CMDL_UPD_AUTH;\n\t\tupd_info->auth_size.index = auth_offset >> 2;\n\t\tupd_info->auth_offset.index = upd_info->auth_size.index + 1;\n\t\tcmdl[auth_offset + SA_CMDL_OFFSET_NESC] = auth_next_eng;\n\t\tcmdl[auth_offset + SA_CMDL_OFFSET_LABEL_LEN] =\n\t\t\tSA_CMDL_HEADER_SIZE_BYTES;\n\t\ttotal += SA_CMDL_HEADER_SIZE_BYTES;\n\t}\n\n\ttotal = roundup(total, 8);\n\n\tfor (i = 0; i < total / 4; i++)\n\t\tword_ptr[i] = swab32(word_ptr[i]);\n\n\treturn total;\n}\n\n \nstatic inline void sa_update_cmdl(struct sa_req *req, u32 *cmdl,\n\t\t\t\t  struct sa_cmdl_upd_info *upd_info)\n{\n\tint i = 0, j;\n\n\tif (likely(upd_info->flags & SA_CMDL_UPD_ENC)) {\n\t\tcmdl[upd_info->enc_size.index] &= ~SA_CMDL_PAYLOAD_LENGTH_MASK;\n\t\tcmdl[upd_info->enc_size.index] |= req->enc_size;\n\t\tcmdl[upd_info->enc_offset.index] &=\n\t\t\t\t\t\t~SA_CMDL_SOP_BYPASS_LEN_MASK;\n\t\tcmdl[upd_info->enc_offset.index] |=\n\t\t\tFIELD_PREP(SA_CMDL_SOP_BYPASS_LEN_MASK,\n\t\t\t\t   req->enc_offset);\n\n\t\tif (likely(upd_info->flags & SA_CMDL_UPD_ENC_IV)) {\n\t\t\t__be32 *data = (__be32 *)&cmdl[upd_info->enc_iv.index];\n\t\t\tu32 *enc_iv = (u32 *)req->enc_iv;\n\n\t\t\tfor (j = 0; i < upd_info->enc_iv.size; i += 4, j++) {\n\t\t\t\tdata[j] = cpu_to_be32(*enc_iv);\n\t\t\t\tenc_iv++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (likely(upd_info->flags & SA_CMDL_UPD_AUTH)) {\n\t\tcmdl[upd_info->auth_size.index] &= ~SA_CMDL_PAYLOAD_LENGTH_MASK;\n\t\tcmdl[upd_info->auth_size.index] |= req->auth_size;\n\t\tcmdl[upd_info->auth_offset.index] &=\n\t\t\t~SA_CMDL_SOP_BYPASS_LEN_MASK;\n\t\tcmdl[upd_info->auth_offset.index] |=\n\t\t\tFIELD_PREP(SA_CMDL_SOP_BYPASS_LEN_MASK,\n\t\t\t\t   req->auth_offset);\n\t\tif (upd_info->flags & SA_CMDL_UPD_AUTH_IV) {\n\t\t\tsa_copy_iv((void *)&cmdl[upd_info->auth_iv.index],\n\t\t\t\t   req->auth_iv,\n\t\t\t\t   (upd_info->auth_iv.size > 8));\n\t\t}\n\t\tif (upd_info->flags & SA_CMDL_UPD_AUX_KEY) {\n\t\t\tint offset = (req->auth_size & 0xF) ? 4 : 0;\n\n\t\t\tmemcpy(&cmdl[upd_info->aux_key_info.index],\n\t\t\t       &upd_info->aux_key[offset], 16);\n\t\t}\n\t}\n}\n\n \nstatic\nvoid sa_set_swinfo(u8 eng_id, u16 sc_id, dma_addr_t sc_phys,\n\t\t   u8 cmdl_present, u8 cmdl_offset, u8 flags,\n\t\t   u8 hash_size, u32 *swinfo)\n{\n\tswinfo[0] = sc_id;\n\tswinfo[0] |= FIELD_PREP(SA_SW0_FLAGS_MASK, flags);\n\tif (likely(cmdl_present))\n\t\tswinfo[0] |= FIELD_PREP(SA_SW0_CMDL_INFO_MASK,\n\t\t\t\t\tcmdl_offset | SA_SW0_CMDL_PRESENT);\n\tswinfo[0] |= FIELD_PREP(SA_SW0_ENG_ID_MASK, eng_id);\n\n\tswinfo[0] |= SA_SW0_DEST_INFO_PRESENT;\n\tswinfo[1] = (u32)(sc_phys & 0xFFFFFFFFULL);\n\tswinfo[2] = (u32)((sc_phys & 0xFFFFFFFF00000000ULL) >> 32);\n\tswinfo[2] |= FIELD_PREP(SA_SW2_EGRESS_LENGTH, hash_size);\n}\n\n \nstatic void sa_dump_sc(u8 *buf, dma_addr_t dma_addr)\n{\n#ifdef DEBUG\n\tdev_info(sa_k3_dev, \"Security context dump:: 0x%pad\\n\", &dma_addr);\n\tprint_hex_dump(KERN_CONT, \"\", DUMP_PREFIX_OFFSET,\n\t\t       16, 1, buf, SA_CTX_MAX_SZ, false);\n#endif\n}\n\nstatic\nint sa_init_sc(struct sa_ctx_info *ctx, const struct sa_match_data *match_data,\n\t       const u8 *enc_key, u16 enc_key_sz,\n\t       const u8 *auth_key, u16 auth_key_sz,\n\t       struct algo_data *ad, u8 enc, u32 *swinfo)\n{\n\tint enc_sc_offset = 0;\n\tint auth_sc_offset = 0;\n\tu8 *sc_buf = ctx->sc;\n\tu16 sc_id = ctx->sc_id;\n\tu8 first_engine = 0;\n\n\tmemzero_explicit(sc_buf, SA_CTX_MAX_SZ);\n\n\tif (ad->auth_eng.eng_id) {\n\t\tif (enc)\n\t\t\tfirst_engine = ad->enc_eng.eng_id;\n\t\telse\n\t\t\tfirst_engine = ad->auth_eng.eng_id;\n\n\t\tenc_sc_offset = SA_CTX_PHP_PE_CTX_SZ;\n\t\tauth_sc_offset = enc_sc_offset + ad->enc_eng.sc_size;\n\t\tsc_buf[1] = SA_SCCTL_FE_AUTH_ENC;\n\t\tif (!ad->hash_size)\n\t\t\treturn -EINVAL;\n\t\tad->hash_size = roundup(ad->hash_size, 8);\n\n\t} else if (ad->enc_eng.eng_id && !ad->auth_eng.eng_id) {\n\t\tenc_sc_offset = SA_CTX_PHP_PE_CTX_SZ;\n\t\tfirst_engine = ad->enc_eng.eng_id;\n\t\tsc_buf[1] = SA_SCCTL_FE_ENC;\n\t\tad->hash_size = ad->iv_out_size;\n\t}\n\n\t \n\tsc_buf[SA_CTX_SCCTL_OWNER_OFFSET] = 0;\n\tmemcpy(&sc_buf[2], &sc_id, 2);\n\tsc_buf[4] = 0x0;\n\tsc_buf[5] = match_data->priv_id;\n\tsc_buf[6] = match_data->priv;\n\tsc_buf[7] = 0x0;\n\n\t \n\tif (ad->enc_eng.sc_size) {\n\t\tif (sa_set_sc_enc(ad, enc_key, enc_key_sz, enc,\n\t\t\t\t  &sc_buf[enc_sc_offset]))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ad->auth_eng.sc_size)\n\t\tsa_set_sc_auth(ad, auth_key, auth_key_sz,\n\t\t\t       &sc_buf[auth_sc_offset]);\n\n\t \n\tsc_buf[SA_CTX_SCCTL_OWNER_OFFSET] = 0x80;\n\n\t \n\tsa_swiz_128(sc_buf, SA_CTX_MAX_SZ);\n\n\tsa_set_swinfo(first_engine, ctx->sc_id, ctx->sc_phys, 1, 0,\n\t\t      SA_SW_INFO_FLAG_EVICT, ad->hash_size, swinfo);\n\n\tsa_dump_sc(sc_buf, ctx->sc_phys);\n\n\treturn 0;\n}\n\n \nstatic void sa_free_ctx_info(struct sa_ctx_info *ctx,\n\t\t\t     struct sa_crypto_data *data)\n{\n\tunsigned long bn;\n\n\tbn = ctx->sc_id - data->sc_id_start;\n\tspin_lock(&data->scid_lock);\n\t__clear_bit(bn, data->ctx_bm);\n\tdata->sc_id--;\n\tspin_unlock(&data->scid_lock);\n\n\tif (ctx->sc) {\n\t\tdma_pool_free(data->sc_pool, ctx->sc, ctx->sc_phys);\n\t\tctx->sc = NULL;\n\t}\n}\n\nstatic int sa_init_ctx_info(struct sa_ctx_info *ctx,\n\t\t\t    struct sa_crypto_data *data)\n{\n\tunsigned long bn;\n\tint err;\n\n\tspin_lock(&data->scid_lock);\n\tbn = find_first_zero_bit(data->ctx_bm, SA_MAX_NUM_CTX);\n\t__set_bit(bn, data->ctx_bm);\n\tdata->sc_id++;\n\tspin_unlock(&data->scid_lock);\n\n\tctx->sc_id = (u16)(data->sc_id_start + bn);\n\n\tctx->sc = dma_pool_alloc(data->sc_pool, GFP_KERNEL, &ctx->sc_phys);\n\tif (!ctx->sc) {\n\t\tdev_err(&data->pdev->dev, \"Failed to allocate SC memory\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto scid_rollback;\n\t}\n\n\treturn 0;\n\nscid_rollback:\n\tspin_lock(&data->scid_lock);\n\t__clear_bit(bn, data->ctx_bm);\n\tdata->sc_id--;\n\tspin_unlock(&data->scid_lock);\n\n\treturn err;\n}\n\nstatic void sa_cipher_cra_exit(struct crypto_skcipher *tfm)\n{\n\tstruct sa_tfm_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct sa_crypto_data *data = dev_get_drvdata(sa_k3_dev);\n\n\tdev_dbg(sa_k3_dev, \"%s(0x%p) sc-ids(0x%x(0x%pad), 0x%x(0x%pad))\\n\",\n\t\t__func__, tfm, ctx->enc.sc_id, &ctx->enc.sc_phys,\n\t\tctx->dec.sc_id, &ctx->dec.sc_phys);\n\n\tsa_free_ctx_info(&ctx->enc, data);\n\tsa_free_ctx_info(&ctx->dec, data);\n\n\tcrypto_free_skcipher(ctx->fallback.skcipher);\n}\n\nstatic int sa_cipher_cra_init(struct crypto_skcipher *tfm)\n{\n\tstruct sa_tfm_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct sa_crypto_data *data = dev_get_drvdata(sa_k3_dev);\n\tconst char *name = crypto_tfm_alg_name(&tfm->base);\n\tstruct crypto_skcipher *child;\n\tint ret;\n\n\tmemzero_explicit(ctx, sizeof(*ctx));\n\tctx->dev_data = data;\n\n\tret = sa_init_ctx_info(&ctx->enc, data);\n\tif (ret)\n\t\treturn ret;\n\tret = sa_init_ctx_info(&ctx->dec, data);\n\tif (ret) {\n\t\tsa_free_ctx_info(&ctx->enc, data);\n\t\treturn ret;\n\t}\n\n\tchild = crypto_alloc_skcipher(name, 0, CRYPTO_ALG_NEED_FALLBACK);\n\n\tif (IS_ERR(child)) {\n\t\tdev_err(sa_k3_dev, \"Error allocating fallback algo %s\\n\", name);\n\t\treturn PTR_ERR(child);\n\t}\n\n\tctx->fallback.skcipher = child;\n\tcrypto_skcipher_set_reqsize(tfm, crypto_skcipher_reqsize(child) +\n\t\t\t\t\t sizeof(struct skcipher_request));\n\n\tdev_dbg(sa_k3_dev, \"%s(0x%p) sc-ids(0x%x(0x%pad), 0x%x(0x%pad))\\n\",\n\t\t__func__, tfm, ctx->enc.sc_id, &ctx->enc.sc_phys,\n\t\tctx->dec.sc_id, &ctx->dec.sc_phys);\n\treturn 0;\n}\n\nstatic int sa_cipher_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t    unsigned int keylen, struct algo_data *ad)\n{\n\tstruct sa_tfm_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct crypto_skcipher *child = ctx->fallback.skcipher;\n\tint cmdl_len;\n\tstruct sa_cmdl_cfg cfg;\n\tint ret;\n\n\tif (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&\n\t    keylen != AES_KEYSIZE_256)\n\t\treturn -EINVAL;\n\n\tad->enc_eng.eng_id = SA_ENG_ID_EM1;\n\tad->enc_eng.sc_size = SA_CTX_ENC_TYPE1_SZ;\n\n\tmemzero_explicit(&cfg, sizeof(cfg));\n\tcfg.enc_eng_id = ad->enc_eng.eng_id;\n\tcfg.iv_size = crypto_skcipher_ivsize(tfm);\n\n\tcrypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(child, tfm->base.crt_flags &\n\t\t\t\t\t CRYPTO_TFM_REQ_MASK);\n\tret = crypto_skcipher_setkey(child, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (sa_init_sc(&ctx->enc, ctx->dev_data->match_data, key, keylen, NULL, 0,\n\t\t       ad, 1, &ctx->enc.epib[1]))\n\t\tgoto badkey;\n\n\tcmdl_len = sa_format_cmdl_gen(&cfg,\n\t\t\t\t      (u8 *)ctx->enc.cmdl,\n\t\t\t\t      &ctx->enc.cmdl_upd_info);\n\tif (cmdl_len <= 0 || (cmdl_len > SA_MAX_CMDL_WORDS * sizeof(u32)))\n\t\tgoto badkey;\n\n\tctx->enc.cmdl_size = cmdl_len;\n\n\t \n\tif (sa_init_sc(&ctx->dec, ctx->dev_data->match_data, key, keylen, NULL, 0,\n\t\t       ad, 0, &ctx->dec.epib[1]))\n\t\tgoto badkey;\n\n\tcfg.enc_eng_id = ad->enc_eng.eng_id;\n\tcmdl_len = sa_format_cmdl_gen(&cfg, (u8 *)ctx->dec.cmdl,\n\t\t\t\t      &ctx->dec.cmdl_upd_info);\n\n\tif (cmdl_len <= 0 || (cmdl_len > SA_MAX_CMDL_WORDS * sizeof(u32)))\n\t\tgoto badkey;\n\n\tctx->dec.cmdl_size = cmdl_len;\n\tctx->iv_idx = ad->iv_idx;\n\n\treturn 0;\n\nbadkey:\n\tdev_err(sa_k3_dev, \"%s: badkey\\n\", __func__);\n\treturn -EINVAL;\n}\n\nstatic int sa_aes_cbc_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t     unsigned int keylen)\n{\n\tstruct algo_data ad = { 0 };\n\t \n\tint key_idx = (keylen >> 3) - 2;\n\n\tif (key_idx >= 3)\n\t\treturn -EINVAL;\n\n\tad.mci_enc = mci_cbc_enc_array[key_idx];\n\tad.mci_dec = mci_cbc_dec_array[key_idx];\n\tad.inv_key = true;\n\tad.ealg_id = SA_EALG_ID_AES_CBC;\n\tad.iv_idx = 4;\n\tad.iv_out_size = 16;\n\n\treturn sa_cipher_setkey(tfm, key, keylen, &ad);\n}\n\nstatic int sa_aes_ecb_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t     unsigned int keylen)\n{\n\tstruct algo_data ad = { 0 };\n\t \n\tint key_idx = (keylen >> 3) - 2;\n\n\tif (key_idx >= 3)\n\t\treturn -EINVAL;\n\n\tad.mci_enc = mci_ecb_enc_array[key_idx];\n\tad.mci_dec = mci_ecb_dec_array[key_idx];\n\tad.inv_key = true;\n\tad.ealg_id = SA_EALG_ID_AES_ECB;\n\n\treturn sa_cipher_setkey(tfm, key, keylen, &ad);\n}\n\nstatic int sa_3des_cbc_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t      unsigned int keylen)\n{\n\tstruct algo_data ad = { 0 };\n\n\tad.mci_enc = mci_cbc_3des_enc_array;\n\tad.mci_dec = mci_cbc_3des_dec_array;\n\tad.ealg_id = SA_EALG_ID_3DES_CBC;\n\tad.iv_idx = 6;\n\tad.iv_out_size = 8;\n\n\treturn sa_cipher_setkey(tfm, key, keylen, &ad);\n}\n\nstatic int sa_3des_ecb_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t      unsigned int keylen)\n{\n\tstruct algo_data ad = { 0 };\n\n\tad.mci_enc = mci_ecb_3des_enc_array;\n\tad.mci_dec = mci_ecb_3des_dec_array;\n\n\treturn sa_cipher_setkey(tfm, key, keylen, &ad);\n}\n\nstatic void sa_sync_from_device(struct sa_rx_data *rxd)\n{\n\tstruct sg_table *sgt;\n\n\tif (rxd->mapped_sg[0].dir == DMA_BIDIRECTIONAL)\n\t\tsgt = &rxd->mapped_sg[0].sgt;\n\telse\n\t\tsgt = &rxd->mapped_sg[1].sgt;\n\n\tdma_sync_sgtable_for_cpu(rxd->ddev, sgt, DMA_FROM_DEVICE);\n}\n\nstatic void sa_free_sa_rx_data(struct sa_rx_data *rxd)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rxd->mapped_sg); i++) {\n\t\tstruct sa_mapped_sg *mapped_sg = &rxd->mapped_sg[i];\n\n\t\tif (mapped_sg->mapped) {\n\t\t\tdma_unmap_sgtable(rxd->ddev, &mapped_sg->sgt,\n\t\t\t\t\t  mapped_sg->dir, 0);\n\t\t\tkfree(mapped_sg->split_sg);\n\t\t}\n\t}\n\n\tkfree(rxd);\n}\n\nstatic void sa_aes_dma_in_callback(void *data)\n{\n\tstruct sa_rx_data *rxd = data;\n\tstruct skcipher_request *req;\n\tu32 *result;\n\t__be32 *mdptr;\n\tsize_t ml, pl;\n\tint i;\n\n\tsa_sync_from_device(rxd);\n\treq = container_of(rxd->req, struct skcipher_request, base);\n\n\tif (req->iv) {\n\t\tmdptr = (__be32 *)dmaengine_desc_get_metadata_ptr(rxd->tx_in, &pl,\n\t\t\t\t\t\t\t       &ml);\n\t\tresult = (u32 *)req->iv;\n\n\t\tfor (i = 0; i < (rxd->enc_iv_size / 4); i++)\n\t\t\tresult[i] = be32_to_cpu(mdptr[i + rxd->iv_idx]);\n\t}\n\n\tsa_free_sa_rx_data(rxd);\n\n\tskcipher_request_complete(req, 0);\n}\n\nstatic void\nsa_prepare_tx_desc(u32 *mdptr, u32 pslen, u32 *psdata, u32 epiblen, u32 *epib)\n{\n\tu32 *out, *in;\n\tint i;\n\n\tfor (out = mdptr, in = epib, i = 0; i < epiblen / sizeof(u32); i++)\n\t\t*out++ = *in++;\n\n\tmdptr[4] = (0xFFFF << 16);\n\tfor (out = &mdptr[5], in = psdata, i = 0;\n\t     i < pslen / sizeof(u32); i++)\n\t\t*out++ = *in++;\n}\n\nstatic int sa_run(struct sa_req *req)\n{\n\tstruct sa_rx_data *rxd;\n\tgfp_t gfp_flags;\n\tu32 cmdl[SA_MAX_CMDL_WORDS];\n\tstruct sa_crypto_data *pdata = dev_get_drvdata(sa_k3_dev);\n\tstruct device *ddev;\n\tstruct dma_chan *dma_rx;\n\tint sg_nents, src_nents, dst_nents;\n\tstruct scatterlist *src, *dst;\n\tsize_t pl, ml, split_size;\n\tstruct sa_ctx_info *sa_ctx = req->enc ? &req->ctx->enc : &req->ctx->dec;\n\tint ret;\n\tstruct dma_async_tx_descriptor *tx_out;\n\tu32 *mdptr;\n\tbool diff_dst;\n\tenum dma_data_direction dir_src;\n\tstruct sa_mapped_sg *mapped_sg;\n\n\tgfp_flags = req->base->flags & CRYPTO_TFM_REQ_MAY_SLEEP ?\n\t\tGFP_KERNEL : GFP_ATOMIC;\n\n\trxd = kzalloc(sizeof(*rxd), gfp_flags);\n\tif (!rxd)\n\t\treturn -ENOMEM;\n\n\tif (req->src != req->dst) {\n\t\tdiff_dst = true;\n\t\tdir_src = DMA_TO_DEVICE;\n\t} else {\n\t\tdiff_dst = false;\n\t\tdir_src = DMA_BIDIRECTIONAL;\n\t}\n\n\t \n\tif (req->size >= 256)\n\t\tdma_rx = pdata->dma_rx2;\n\telse\n\t\tdma_rx = pdata->dma_rx1;\n\n\tddev = dmaengine_get_dma_device(pdata->dma_tx);\n\trxd->ddev = ddev;\n\n\tmemcpy(cmdl, sa_ctx->cmdl, sa_ctx->cmdl_size);\n\n\tsa_update_cmdl(req, cmdl, &sa_ctx->cmdl_upd_info);\n\n\tif (req->type != CRYPTO_ALG_TYPE_AHASH) {\n\t\tif (req->enc)\n\t\t\treq->type |=\n\t\t\t\t(SA_REQ_SUBTYPE_ENC << SA_REQ_SUBTYPE_SHIFT);\n\t\telse\n\t\t\treq->type |=\n\t\t\t\t(SA_REQ_SUBTYPE_DEC << SA_REQ_SUBTYPE_SHIFT);\n\t}\n\n\tcmdl[sa_ctx->cmdl_size / sizeof(u32)] = req->type;\n\n\t \n\tsrc = req->src;\n\tsg_nents = sg_nents_for_len(src, req->size);\n\n\tsplit_size = req->size;\n\n\tmapped_sg = &rxd->mapped_sg[0];\n\tif (sg_nents == 1 && split_size <= req->src->length) {\n\t\tsrc = &mapped_sg->static_sg;\n\t\tsrc_nents = 1;\n\t\tsg_init_table(src, 1);\n\t\tsg_set_page(src, sg_page(req->src), split_size,\n\t\t\t    req->src->offset);\n\n\t\tmapped_sg->sgt.sgl = src;\n\t\tmapped_sg->sgt.orig_nents = src_nents;\n\t\tret = dma_map_sgtable(ddev, &mapped_sg->sgt, dir_src, 0);\n\t\tif (ret) {\n\t\t\tkfree(rxd);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmapped_sg->dir = dir_src;\n\t\tmapped_sg->mapped = true;\n\t} else {\n\t\tmapped_sg->sgt.sgl = req->src;\n\t\tmapped_sg->sgt.orig_nents = sg_nents;\n\t\tret = dma_map_sgtable(ddev, &mapped_sg->sgt, dir_src, 0);\n\t\tif (ret) {\n\t\t\tkfree(rxd);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmapped_sg->dir = dir_src;\n\t\tmapped_sg->mapped = true;\n\n\t\tret = sg_split(mapped_sg->sgt.sgl, mapped_sg->sgt.nents, 0, 1,\n\t\t\t       &split_size, &src, &src_nents, gfp_flags);\n\t\tif (ret) {\n\t\t\tsrc_nents = mapped_sg->sgt.nents;\n\t\t\tsrc = mapped_sg->sgt.sgl;\n\t\t} else {\n\t\t\tmapped_sg->split_sg = src;\n\t\t}\n\t}\n\n\tdma_sync_sgtable_for_device(ddev, &mapped_sg->sgt, DMA_TO_DEVICE);\n\n\tif (!diff_dst) {\n\t\tdst_nents = src_nents;\n\t\tdst = src;\n\t} else {\n\t\tdst_nents = sg_nents_for_len(req->dst, req->size);\n\t\tmapped_sg = &rxd->mapped_sg[1];\n\n\t\tif (dst_nents == 1 && split_size <= req->dst->length) {\n\t\t\tdst = &mapped_sg->static_sg;\n\t\t\tdst_nents = 1;\n\t\t\tsg_init_table(dst, 1);\n\t\t\tsg_set_page(dst, sg_page(req->dst), split_size,\n\t\t\t\t    req->dst->offset);\n\n\t\t\tmapped_sg->sgt.sgl = dst;\n\t\t\tmapped_sg->sgt.orig_nents = dst_nents;\n\t\t\tret = dma_map_sgtable(ddev, &mapped_sg->sgt,\n\t\t\t\t\t      DMA_FROM_DEVICE, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto err_cleanup;\n\n\t\t\tmapped_sg->dir = DMA_FROM_DEVICE;\n\t\t\tmapped_sg->mapped = true;\n\t\t} else {\n\t\t\tmapped_sg->sgt.sgl = req->dst;\n\t\t\tmapped_sg->sgt.orig_nents = dst_nents;\n\t\t\tret = dma_map_sgtable(ddev, &mapped_sg->sgt,\n\t\t\t\t\t      DMA_FROM_DEVICE, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto err_cleanup;\n\n\t\t\tmapped_sg->dir = DMA_FROM_DEVICE;\n\t\t\tmapped_sg->mapped = true;\n\n\t\t\tret = sg_split(mapped_sg->sgt.sgl, mapped_sg->sgt.nents,\n\t\t\t\t       0, 1, &split_size, &dst, &dst_nents,\n\t\t\t\t       gfp_flags);\n\t\t\tif (ret) {\n\t\t\t\tdst_nents = mapped_sg->sgt.nents;\n\t\t\t\tdst = mapped_sg->sgt.sgl;\n\t\t\t} else {\n\t\t\t\tmapped_sg->split_sg = dst;\n\t\t\t}\n\t\t}\n\t}\n\n\trxd->tx_in = dmaengine_prep_slave_sg(dma_rx, dst, dst_nents,\n\t\t\t\t\t     DMA_DEV_TO_MEM,\n\t\t\t\t\t     DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!rxd->tx_in) {\n\t\tdev_err(pdata->dev, \"IN prep_slave_sg() failed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_cleanup;\n\t}\n\n\trxd->req = (void *)req->base;\n\trxd->enc = req->enc;\n\trxd->iv_idx = req->ctx->iv_idx;\n\trxd->enc_iv_size = sa_ctx->cmdl_upd_info.enc_iv.size;\n\trxd->tx_in->callback = req->callback;\n\trxd->tx_in->callback_param = rxd;\n\n\ttx_out = dmaengine_prep_slave_sg(pdata->dma_tx, src,\n\t\t\t\t\t src_nents, DMA_MEM_TO_DEV,\n\t\t\t\t\t DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\n\tif (!tx_out) {\n\t\tdev_err(pdata->dev, \"OUT prep_slave_sg() failed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_cleanup;\n\t}\n\n\t \n\tmdptr = (u32 *)dmaengine_desc_get_metadata_ptr(tx_out, &pl, &ml);\n\n\tsa_prepare_tx_desc(mdptr, (sa_ctx->cmdl_size + (SA_PSDATA_CTX_WORDS *\n\t\t\t\t   sizeof(u32))), cmdl, sizeof(sa_ctx->epib),\n\t\t\t   sa_ctx->epib);\n\n\tml = sa_ctx->cmdl_size + (SA_PSDATA_CTX_WORDS * sizeof(u32));\n\tdmaengine_desc_set_metadata_len(tx_out, req->mdata_size);\n\n\tdmaengine_submit(tx_out);\n\tdmaengine_submit(rxd->tx_in);\n\n\tdma_async_issue_pending(dma_rx);\n\tdma_async_issue_pending(pdata->dma_tx);\n\n\treturn -EINPROGRESS;\n\nerr_cleanup:\n\tsa_free_sa_rx_data(rxd);\n\n\treturn ret;\n}\n\nstatic int sa_cipher_run(struct skcipher_request *req, u8 *iv, int enc)\n{\n\tstruct sa_tfm_ctx *ctx =\n\t    crypto_skcipher_ctx(crypto_skcipher_reqtfm(req));\n\tstruct crypto_alg *alg = req->base.tfm->__crt_alg;\n\tstruct sa_req sa_req = { 0 };\n\n\tif (!req->cryptlen)\n\t\treturn 0;\n\n\tif (req->cryptlen % alg->cra_blocksize)\n\t\treturn -EINVAL;\n\n\t \n\tif (req->cryptlen > SA_MAX_DATA_SZ ||\n\t    (req->cryptlen >= SA_UNSAFE_DATA_SZ_MIN &&\n\t     req->cryptlen <= SA_UNSAFE_DATA_SZ_MAX)) {\n\t\tstruct skcipher_request *subreq = skcipher_request_ctx(req);\n\n\t\tskcipher_request_set_tfm(subreq, ctx->fallback.skcipher);\n\t\tskcipher_request_set_callback(subreq, req->base.flags,\n\t\t\t\t\t      req->base.complete,\n\t\t\t\t\t      req->base.data);\n\t\tskcipher_request_set_crypt(subreq, req->src, req->dst,\n\t\t\t\t\t   req->cryptlen, req->iv);\n\t\tif (enc)\n\t\t\treturn crypto_skcipher_encrypt(subreq);\n\t\telse\n\t\t\treturn crypto_skcipher_decrypt(subreq);\n\t}\n\n\tsa_req.size = req->cryptlen;\n\tsa_req.enc_size = req->cryptlen;\n\tsa_req.src = req->src;\n\tsa_req.dst = req->dst;\n\tsa_req.enc_iv = iv;\n\tsa_req.type = CRYPTO_ALG_TYPE_SKCIPHER;\n\tsa_req.enc = enc;\n\tsa_req.callback = sa_aes_dma_in_callback;\n\tsa_req.mdata_size = 44;\n\tsa_req.base = &req->base;\n\tsa_req.ctx = ctx;\n\n\treturn sa_run(&sa_req);\n}\n\nstatic int sa_encrypt(struct skcipher_request *req)\n{\n\treturn sa_cipher_run(req, req->iv, 1);\n}\n\nstatic int sa_decrypt(struct skcipher_request *req)\n{\n\treturn sa_cipher_run(req, req->iv, 0);\n}\n\nstatic void sa_sha_dma_in_callback(void *data)\n{\n\tstruct sa_rx_data *rxd = data;\n\tstruct ahash_request *req;\n\tstruct crypto_ahash *tfm;\n\tunsigned int authsize;\n\tint i;\n\tsize_t ml, pl;\n\tu32 *result;\n\t__be32 *mdptr;\n\n\tsa_sync_from_device(rxd);\n\treq = container_of(rxd->req, struct ahash_request, base);\n\ttfm = crypto_ahash_reqtfm(req);\n\tauthsize = crypto_ahash_digestsize(tfm);\n\n\tmdptr = (__be32 *)dmaengine_desc_get_metadata_ptr(rxd->tx_in, &pl, &ml);\n\tresult = (u32 *)req->result;\n\n\tfor (i = 0; i < (authsize / 4); i++)\n\t\tresult[i] = be32_to_cpu(mdptr[i + 4]);\n\n\tsa_free_sa_rx_data(rxd);\n\n\tahash_request_complete(req, 0);\n}\n\nstatic int zero_message_process(struct ahash_request *req)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tint sa_digest_size = crypto_ahash_digestsize(tfm);\n\n\tswitch (sa_digest_size) {\n\tcase SHA1_DIGEST_SIZE:\n\t\tmemcpy(req->result, sha1_zero_message_hash, sa_digest_size);\n\t\tbreak;\n\tcase SHA256_DIGEST_SIZE:\n\t\tmemcpy(req->result, sha256_zero_message_hash, sa_digest_size);\n\t\tbreak;\n\tcase SHA512_DIGEST_SIZE:\n\t\tmemcpy(req->result, sha512_zero_message_hash, sa_digest_size);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sa_sha_run(struct ahash_request *req)\n{\n\tstruct sa_tfm_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));\n\tstruct sa_sha_req_ctx *rctx = ahash_request_ctx(req);\n\tstruct sa_req sa_req = { 0 };\n\tsize_t auth_len;\n\n\tauth_len = req->nbytes;\n\n\tif (!auth_len)\n\t\treturn zero_message_process(req);\n\n\tif (auth_len > SA_MAX_DATA_SZ ||\n\t    (auth_len >= SA_UNSAFE_DATA_SZ_MIN &&\n\t     auth_len <= SA_UNSAFE_DATA_SZ_MAX)) {\n\t\tstruct ahash_request *subreq = &rctx->fallback_req;\n\t\tint ret = 0;\n\n\t\tahash_request_set_tfm(subreq, ctx->fallback.ahash);\n\t\tsubreq->base.flags = req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\t\tcrypto_ahash_init(subreq);\n\n\t\tsubreq->nbytes = auth_len;\n\t\tsubreq->src = req->src;\n\t\tsubreq->result = req->result;\n\n\t\tret |= crypto_ahash_update(subreq);\n\n\t\tsubreq->nbytes = 0;\n\n\t\tret |= crypto_ahash_final(subreq);\n\n\t\treturn ret;\n\t}\n\n\tsa_req.size = auth_len;\n\tsa_req.auth_size = auth_len;\n\tsa_req.src = req->src;\n\tsa_req.dst = req->src;\n\tsa_req.enc = true;\n\tsa_req.type = CRYPTO_ALG_TYPE_AHASH;\n\tsa_req.callback = sa_sha_dma_in_callback;\n\tsa_req.mdata_size = 28;\n\tsa_req.ctx = ctx;\n\tsa_req.base = &req->base;\n\n\treturn sa_run(&sa_req);\n}\n\nstatic int sa_sha_setup(struct sa_tfm_ctx *ctx, struct  algo_data *ad)\n{\n\tint bs = crypto_shash_blocksize(ctx->shash);\n\tint cmdl_len;\n\tstruct sa_cmdl_cfg cfg;\n\n\tad->enc_eng.sc_size = SA_CTX_ENC_TYPE1_SZ;\n\tad->auth_eng.eng_id = SA_ENG_ID_AM1;\n\tad->auth_eng.sc_size = SA_CTX_AUTH_TYPE2_SZ;\n\n\tmemset(ctx->authkey, 0, bs);\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.aalg = ad->aalg_id;\n\tcfg.enc_eng_id = ad->enc_eng.eng_id;\n\tcfg.auth_eng_id = ad->auth_eng.eng_id;\n\tcfg.iv_size = 0;\n\tcfg.akey = NULL;\n\tcfg.akey_len = 0;\n\n\tctx->dev_data = dev_get_drvdata(sa_k3_dev);\n\t \n\tif (sa_init_sc(&ctx->enc, ctx->dev_data->match_data, NULL, 0, NULL, 0,\n\t\t       ad, 0, &ctx->enc.epib[1]))\n\t\tgoto badkey;\n\n\tcmdl_len = sa_format_cmdl_gen(&cfg,\n\t\t\t\t      (u8 *)ctx->enc.cmdl,\n\t\t\t\t      &ctx->enc.cmdl_upd_info);\n\tif (cmdl_len <= 0 || (cmdl_len > SA_MAX_CMDL_WORDS * sizeof(u32)))\n\t\tgoto badkey;\n\n\tctx->enc.cmdl_size = cmdl_len;\n\n\treturn 0;\n\nbadkey:\n\tdev_err(sa_k3_dev, \"%s: badkey\\n\", __func__);\n\treturn -EINVAL;\n}\n\nstatic int sa_sha_cra_init_alg(struct crypto_tfm *tfm, const char *alg_base)\n{\n\tstruct sa_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct sa_crypto_data *data = dev_get_drvdata(sa_k3_dev);\n\tint ret;\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->dev_data = data;\n\tret = sa_init_ctx_info(&ctx->enc, data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (alg_base) {\n\t\tctx->shash = crypto_alloc_shash(alg_base, 0,\n\t\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK);\n\t\tif (IS_ERR(ctx->shash)) {\n\t\t\tdev_err(sa_k3_dev, \"base driver %s couldn't be loaded\\n\",\n\t\t\t\talg_base);\n\t\t\treturn PTR_ERR(ctx->shash);\n\t\t}\n\t\t \n\t\tctx->fallback.ahash =\n\t\t\tcrypto_alloc_ahash(alg_base, 0,\n\t\t\t\t\t   CRYPTO_ALG_NEED_FALLBACK);\n\t\tif (IS_ERR(ctx->fallback.ahash)) {\n\t\t\tdev_err(ctx->dev_data->dev,\n\t\t\t\t\"Could not load fallback driver\\n\");\n\t\t\treturn PTR_ERR(ctx->fallback.ahash);\n\t\t}\n\t}\n\n\tdev_dbg(sa_k3_dev, \"%s(0x%p) sc-ids(0x%x(0x%pad), 0x%x(0x%pad))\\n\",\n\t\t__func__, tfm, ctx->enc.sc_id, &ctx->enc.sc_phys,\n\t\tctx->dec.sc_id, &ctx->dec.sc_phys);\n\n\tcrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\n\t\t\t\t sizeof(struct sa_sha_req_ctx) +\n\t\t\t\t crypto_ahash_reqsize(ctx->fallback.ahash));\n\n\treturn 0;\n}\n\nstatic int sa_sha_digest(struct ahash_request *req)\n{\n\treturn sa_sha_run(req);\n}\n\nstatic int sa_sha_init(struct ahash_request *req)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct sa_sha_req_ctx *rctx = ahash_request_ctx(req);\n\tstruct sa_tfm_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tdev_dbg(sa_k3_dev, \"init: digest size: %u, rctx=%p\\n\",\n\t\tcrypto_ahash_digestsize(tfm), rctx);\n\n\tahash_request_set_tfm(&rctx->fallback_req, ctx->fallback.ahash);\n\trctx->fallback_req.base.flags =\n\t\treq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\treturn crypto_ahash_init(&rctx->fallback_req);\n}\n\nstatic int sa_sha_update(struct ahash_request *req)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct sa_sha_req_ctx *rctx = ahash_request_ctx(req);\n\tstruct sa_tfm_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, ctx->fallback.ahash);\n\trctx->fallback_req.base.flags =\n\t\treq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP;\n\trctx->fallback_req.nbytes = req->nbytes;\n\trctx->fallback_req.src = req->src;\n\n\treturn crypto_ahash_update(&rctx->fallback_req);\n}\n\nstatic int sa_sha_final(struct ahash_request *req)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct sa_sha_req_ctx *rctx = ahash_request_ctx(req);\n\tstruct sa_tfm_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, ctx->fallback.ahash);\n\trctx->fallback_req.base.flags =\n\t\treq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP;\n\trctx->fallback_req.result = req->result;\n\n\treturn crypto_ahash_final(&rctx->fallback_req);\n}\n\nstatic int sa_sha_finup(struct ahash_request *req)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct sa_sha_req_ctx *rctx = ahash_request_ctx(req);\n\tstruct sa_tfm_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, ctx->fallback.ahash);\n\trctx->fallback_req.base.flags =\n\t\treq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\trctx->fallback_req.nbytes = req->nbytes;\n\trctx->fallback_req.src = req->src;\n\trctx->fallback_req.result = req->result;\n\n\treturn crypto_ahash_finup(&rctx->fallback_req);\n}\n\nstatic int sa_sha_import(struct ahash_request *req, const void *in)\n{\n\tstruct sa_sha_req_ctx *rctx = ahash_request_ctx(req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct sa_tfm_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->fallback_req, ctx->fallback.ahash);\n\trctx->fallback_req.base.flags = req->base.flags &\n\t\tCRYPTO_TFM_REQ_MAY_SLEEP;\n\n\treturn crypto_ahash_import(&rctx->fallback_req, in);\n}\n\nstatic int sa_sha_export(struct ahash_request *req, void *out)\n{\n\tstruct sa_sha_req_ctx *rctx = ahash_request_ctx(req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct sa_tfm_ctx *ctx = crypto_ahash_ctx(tfm);\n\tstruct ahash_request *subreq = &rctx->fallback_req;\n\n\tahash_request_set_tfm(subreq, ctx->fallback.ahash);\n\tsubreq->base.flags = req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\treturn crypto_ahash_export(subreq, out);\n}\n\nstatic int sa_sha1_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct algo_data ad = { 0 };\n\tstruct sa_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsa_sha_cra_init_alg(tfm, \"sha1\");\n\n\tad.aalg_id = SA_AALG_ID_SHA1;\n\tad.hash_size = SHA1_DIGEST_SIZE;\n\tad.auth_ctrl = SA_AUTH_SW_CTRL_SHA1;\n\n\tsa_sha_setup(ctx, &ad);\n\n\treturn 0;\n}\n\nstatic int sa_sha256_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct algo_data ad = { 0 };\n\tstruct sa_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsa_sha_cra_init_alg(tfm, \"sha256\");\n\n\tad.aalg_id = SA_AALG_ID_SHA2_256;\n\tad.hash_size = SHA256_DIGEST_SIZE;\n\tad.auth_ctrl = SA_AUTH_SW_CTRL_SHA256;\n\n\tsa_sha_setup(ctx, &ad);\n\n\treturn 0;\n}\n\nstatic int sa_sha512_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct algo_data ad = { 0 };\n\tstruct sa_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsa_sha_cra_init_alg(tfm, \"sha512\");\n\n\tad.aalg_id = SA_AALG_ID_SHA2_512;\n\tad.hash_size = SHA512_DIGEST_SIZE;\n\tad.auth_ctrl = SA_AUTH_SW_CTRL_SHA512;\n\n\tsa_sha_setup(ctx, &ad);\n\n\treturn 0;\n}\n\nstatic void sa_sha_cra_exit(struct crypto_tfm *tfm)\n{\n\tstruct sa_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct sa_crypto_data *data = dev_get_drvdata(sa_k3_dev);\n\n\tdev_dbg(sa_k3_dev, \"%s(0x%p) sc-ids(0x%x(0x%pad), 0x%x(0x%pad))\\n\",\n\t\t__func__, tfm, ctx->enc.sc_id, &ctx->enc.sc_phys,\n\t\tctx->dec.sc_id, &ctx->dec.sc_phys);\n\n\tif (crypto_tfm_alg_type(tfm) == CRYPTO_ALG_TYPE_AHASH)\n\t\tsa_free_ctx_info(&ctx->enc, data);\n\n\tcrypto_free_shash(ctx->shash);\n\tcrypto_free_ahash(ctx->fallback.ahash);\n}\n\nstatic void sa_aead_dma_in_callback(void *data)\n{\n\tstruct sa_rx_data *rxd = data;\n\tstruct aead_request *req;\n\tstruct crypto_aead *tfm;\n\tunsigned int start;\n\tunsigned int authsize;\n\tu8 auth_tag[SA_MAX_AUTH_TAG_SZ];\n\tsize_t pl, ml;\n\tint i;\n\tint err = 0;\n\tu32 *mdptr;\n\n\tsa_sync_from_device(rxd);\n\treq = container_of(rxd->req, struct aead_request, base);\n\ttfm = crypto_aead_reqtfm(req);\n\tstart = req->assoclen + req->cryptlen;\n\tauthsize = crypto_aead_authsize(tfm);\n\n\tmdptr = (u32 *)dmaengine_desc_get_metadata_ptr(rxd->tx_in, &pl, &ml);\n\tfor (i = 0; i < (authsize / 4); i++)\n\t\tmdptr[i + 4] = swab32(mdptr[i + 4]);\n\n\tif (rxd->enc) {\n\t\tscatterwalk_map_and_copy(&mdptr[4], req->dst, start, authsize,\n\t\t\t\t\t 1);\n\t} else {\n\t\tstart -= authsize;\n\t\tscatterwalk_map_and_copy(auth_tag, req->src, start, authsize,\n\t\t\t\t\t 0);\n\n\t\terr = memcmp(&mdptr[4], auth_tag, authsize) ? -EBADMSG : 0;\n\t}\n\n\tsa_free_sa_rx_data(rxd);\n\n\taead_request_complete(req, err);\n}\n\nstatic int sa_cra_init_aead(struct crypto_aead *tfm, const char *hash,\n\t\t\t    const char *fallback)\n{\n\tstruct sa_tfm_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct sa_crypto_data *data = dev_get_drvdata(sa_k3_dev);\n\tint ret;\n\n\tmemzero_explicit(ctx, sizeof(*ctx));\n\tctx->dev_data = data;\n\n\tctx->shash = crypto_alloc_shash(hash, 0, CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(ctx->shash)) {\n\t\tdev_err(sa_k3_dev, \"base driver %s couldn't be loaded\\n\", hash);\n\t\treturn PTR_ERR(ctx->shash);\n\t}\n\n\tctx->fallback.aead = crypto_alloc_aead(fallback, 0,\n\t\t\t\t\t       CRYPTO_ALG_NEED_FALLBACK);\n\n\tif (IS_ERR(ctx->fallback.aead)) {\n\t\tdev_err(sa_k3_dev, \"fallback driver %s couldn't be loaded\\n\",\n\t\t\tfallback);\n\t\treturn PTR_ERR(ctx->fallback.aead);\n\t}\n\n\tcrypto_aead_set_reqsize(tfm, sizeof(struct aead_request) +\n\t\t\t\tcrypto_aead_reqsize(ctx->fallback.aead));\n\n\tret = sa_init_ctx_info(&ctx->enc, data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sa_init_ctx_info(&ctx->dec, data);\n\tif (ret) {\n\t\tsa_free_ctx_info(&ctx->enc, data);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(sa_k3_dev, \"%s(0x%p) sc-ids(0x%x(0x%pad), 0x%x(0x%pad))\\n\",\n\t\t__func__, tfm, ctx->enc.sc_id, &ctx->enc.sc_phys,\n\t\tctx->dec.sc_id, &ctx->dec.sc_phys);\n\n\treturn ret;\n}\n\nstatic int sa_cra_init_aead_sha1(struct crypto_aead *tfm)\n{\n\treturn sa_cra_init_aead(tfm, \"sha1\",\n\t\t\t\t\"authenc(hmac(sha1-ce),cbc(aes-ce))\");\n}\n\nstatic int sa_cra_init_aead_sha256(struct crypto_aead *tfm)\n{\n\treturn sa_cra_init_aead(tfm, \"sha256\",\n\t\t\t\t\"authenc(hmac(sha256-ce),cbc(aes-ce))\");\n}\n\nstatic void sa_exit_tfm_aead(struct crypto_aead *tfm)\n{\n\tstruct sa_tfm_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct sa_crypto_data *data = dev_get_drvdata(sa_k3_dev);\n\n\tcrypto_free_shash(ctx->shash);\n\tcrypto_free_aead(ctx->fallback.aead);\n\n\tsa_free_ctx_info(&ctx->enc, data);\n\tsa_free_ctx_info(&ctx->dec, data);\n}\n\n \nstatic int sa_aead_setkey(struct crypto_aead *authenc,\n\t\t\t  const u8 *key, unsigned int keylen,\n\t\t\t  struct algo_data *ad)\n{\n\tstruct sa_tfm_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct crypto_authenc_keys keys;\n\tint cmdl_len;\n\tstruct sa_cmdl_cfg cfg;\n\tint key_idx;\n\n\tif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\n\t\treturn -EINVAL;\n\n\t \n\tkey_idx = (keys.enckeylen >> 3) - 2;\n\tif (key_idx >= 3)\n\t\treturn -EINVAL;\n\n\tad->ctx = ctx;\n\tad->enc_eng.eng_id = SA_ENG_ID_EM1;\n\tad->enc_eng.sc_size = SA_CTX_ENC_TYPE1_SZ;\n\tad->auth_eng.eng_id = SA_ENG_ID_AM1;\n\tad->auth_eng.sc_size = SA_CTX_AUTH_TYPE2_SZ;\n\tad->mci_enc = mci_cbc_enc_no_iv_array[key_idx];\n\tad->mci_dec = mci_cbc_dec_no_iv_array[key_idx];\n\tad->inv_key = true;\n\tad->keyed_mac = true;\n\tad->ealg_id = SA_EALG_ID_AES_CBC;\n\tad->prep_iopad = sa_prepare_iopads;\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.enc = true;\n\tcfg.aalg = ad->aalg_id;\n\tcfg.enc_eng_id = ad->enc_eng.eng_id;\n\tcfg.auth_eng_id = ad->auth_eng.eng_id;\n\tcfg.iv_size = crypto_aead_ivsize(authenc);\n\tcfg.akey = keys.authkey;\n\tcfg.akey_len = keys.authkeylen;\n\n\t \n\tif (sa_init_sc(&ctx->enc, ctx->dev_data->match_data, keys.enckey,\n\t\t       keys.enckeylen, keys.authkey, keys.authkeylen,\n\t\t       ad, 1, &ctx->enc.epib[1]))\n\t\treturn -EINVAL;\n\n\tcmdl_len = sa_format_cmdl_gen(&cfg,\n\t\t\t\t      (u8 *)ctx->enc.cmdl,\n\t\t\t\t      &ctx->enc.cmdl_upd_info);\n\tif (cmdl_len <= 0 || (cmdl_len > SA_MAX_CMDL_WORDS * sizeof(u32)))\n\t\treturn -EINVAL;\n\n\tctx->enc.cmdl_size = cmdl_len;\n\n\t \n\tif (sa_init_sc(&ctx->dec, ctx->dev_data->match_data, keys.enckey,\n\t\t       keys.enckeylen, keys.authkey, keys.authkeylen,\n\t\t       ad, 0, &ctx->dec.epib[1]))\n\t\treturn -EINVAL;\n\n\tcfg.enc = false;\n\tcmdl_len = sa_format_cmdl_gen(&cfg, (u8 *)ctx->dec.cmdl,\n\t\t\t\t      &ctx->dec.cmdl_upd_info);\n\n\tif (cmdl_len <= 0 || (cmdl_len > SA_MAX_CMDL_WORDS * sizeof(u32)))\n\t\treturn -EINVAL;\n\n\tctx->dec.cmdl_size = cmdl_len;\n\n\tcrypto_aead_clear_flags(ctx->fallback.aead, CRYPTO_TFM_REQ_MASK);\n\tcrypto_aead_set_flags(ctx->fallback.aead,\n\t\t\t      crypto_aead_get_flags(authenc) &\n\t\t\t      CRYPTO_TFM_REQ_MASK);\n\n\treturn crypto_aead_setkey(ctx->fallback.aead, key, keylen);\n}\n\nstatic int sa_aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)\n{\n\tstruct sa_tfm_ctx *ctx = crypto_tfm_ctx(crypto_aead_tfm(tfm));\n\n\treturn crypto_aead_setauthsize(ctx->fallback.aead, authsize);\n}\n\nstatic int sa_aead_cbc_sha1_setkey(struct crypto_aead *authenc,\n\t\t\t\t   const u8 *key, unsigned int keylen)\n{\n\tstruct algo_data ad = { 0 };\n\n\tad.ealg_id = SA_EALG_ID_AES_CBC;\n\tad.aalg_id = SA_AALG_ID_HMAC_SHA1;\n\tad.hash_size = SHA1_DIGEST_SIZE;\n\tad.auth_ctrl = SA_AUTH_SW_CTRL_SHA1;\n\n\treturn sa_aead_setkey(authenc, key, keylen, &ad);\n}\n\nstatic int sa_aead_cbc_sha256_setkey(struct crypto_aead *authenc,\n\t\t\t\t     const u8 *key, unsigned int keylen)\n{\n\tstruct algo_data ad = { 0 };\n\n\tad.ealg_id = SA_EALG_ID_AES_CBC;\n\tad.aalg_id = SA_AALG_ID_HMAC_SHA2_256;\n\tad.hash_size = SHA256_DIGEST_SIZE;\n\tad.auth_ctrl = SA_AUTH_SW_CTRL_SHA256;\n\n\treturn sa_aead_setkey(authenc, key, keylen, &ad);\n}\n\nstatic int sa_aead_run(struct aead_request *req, u8 *iv, int enc)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct sa_tfm_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct sa_req sa_req = { 0 };\n\tsize_t auth_size, enc_size;\n\n\tenc_size = req->cryptlen;\n\tauth_size = req->assoclen + req->cryptlen;\n\n\tif (!enc) {\n\t\tenc_size -= crypto_aead_authsize(tfm);\n\t\tauth_size -= crypto_aead_authsize(tfm);\n\t}\n\n\tif (auth_size > SA_MAX_DATA_SZ ||\n\t    (auth_size >= SA_UNSAFE_DATA_SZ_MIN &&\n\t     auth_size <= SA_UNSAFE_DATA_SZ_MAX)) {\n\t\tstruct aead_request *subreq = aead_request_ctx(req);\n\t\tint ret;\n\n\t\taead_request_set_tfm(subreq, ctx->fallback.aead);\n\t\taead_request_set_callback(subreq, req->base.flags,\n\t\t\t\t\t  req->base.complete, req->base.data);\n\t\taead_request_set_crypt(subreq, req->src, req->dst,\n\t\t\t\t       req->cryptlen, req->iv);\n\t\taead_request_set_ad(subreq, req->assoclen);\n\n\t\tret = enc ? crypto_aead_encrypt(subreq) :\n\t\t\tcrypto_aead_decrypt(subreq);\n\t\treturn ret;\n\t}\n\n\tsa_req.enc_offset = req->assoclen;\n\tsa_req.enc_size = enc_size;\n\tsa_req.auth_size = auth_size;\n\tsa_req.size = auth_size;\n\tsa_req.enc_iv = iv;\n\tsa_req.type = CRYPTO_ALG_TYPE_AEAD;\n\tsa_req.enc = enc;\n\tsa_req.callback = sa_aead_dma_in_callback;\n\tsa_req.mdata_size = 52;\n\tsa_req.base = &req->base;\n\tsa_req.ctx = ctx;\n\tsa_req.src = req->src;\n\tsa_req.dst = req->dst;\n\n\treturn sa_run(&sa_req);\n}\n\n \nstatic int sa_aead_encrypt(struct aead_request *req)\n{\n\treturn sa_aead_run(req, req->iv, 1);\n}\n\n \nstatic int sa_aead_decrypt(struct aead_request *req)\n{\n\treturn sa_aead_run(req, req->iv, 0);\n}\n\nstatic struct sa_alg_tmpl sa_algs[] = {\n\t[SA_ALG_CBC_AES] = {\n\t\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t\t.alg.skcipher = {\n\t\t\t.base.cra_name\t\t= \"cbc(aes)\",\n\t\t\t.base.cra_driver_name\t= \"cbc-aes-sa2ul\",\n\t\t\t.base.cra_priority\t= 30000,\n\t\t\t.base.cra_flags\t\t= CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t\t  CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t\t\t.base.cra_ctxsize\t= sizeof(struct sa_tfm_ctx),\n\t\t\t.base.cra_module\t= THIS_MODULE,\n\t\t\t.init\t\t\t= sa_cipher_cra_init,\n\t\t\t.exit\t\t\t= sa_cipher_cra_exit,\n\t\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t\t\t.setkey\t\t\t= sa_aes_cbc_setkey,\n\t\t\t.encrypt\t\t= sa_encrypt,\n\t\t\t.decrypt\t\t= sa_decrypt,\n\t\t}\n\t},\n\t[SA_ALG_EBC_AES] = {\n\t\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t\t.alg.skcipher = {\n\t\t\t.base.cra_name\t\t= \"ecb(aes)\",\n\t\t\t.base.cra_driver_name\t= \"ecb-aes-sa2ul\",\n\t\t\t.base.cra_priority\t= 30000,\n\t\t\t.base.cra_flags\t\t= CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t\t  CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t\t\t.base.cra_ctxsize\t= sizeof(struct sa_tfm_ctx),\n\t\t\t.base.cra_module\t= THIS_MODULE,\n\t\t\t.init\t\t\t= sa_cipher_cra_init,\n\t\t\t.exit\t\t\t= sa_cipher_cra_exit,\n\t\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t\t.setkey\t\t\t= sa_aes_ecb_setkey,\n\t\t\t.encrypt\t\t= sa_encrypt,\n\t\t\t.decrypt\t\t= sa_decrypt,\n\t\t}\n\t},\n\t[SA_ALG_CBC_DES3] = {\n\t\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t\t.alg.skcipher = {\n\t\t\t.base.cra_name\t\t= \"cbc(des3_ede)\",\n\t\t\t.base.cra_driver_name\t= \"cbc-des3-sa2ul\",\n\t\t\t.base.cra_priority\t= 30000,\n\t\t\t.base.cra_flags\t\t= CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t\t  CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t\t.base.cra_ctxsize\t= sizeof(struct sa_tfm_ctx),\n\t\t\t.base.cra_module\t= THIS_MODULE,\n\t\t\t.init\t\t\t= sa_cipher_cra_init,\n\t\t\t.exit\t\t\t= sa_cipher_cra_exit,\n\t\t\t.min_keysize\t\t= 3 * DES_KEY_SIZE,\n\t\t\t.max_keysize\t\t= 3 * DES_KEY_SIZE,\n\t\t\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t\t\t.setkey\t\t\t= sa_3des_cbc_setkey,\n\t\t\t.encrypt\t\t= sa_encrypt,\n\t\t\t.decrypt\t\t= sa_decrypt,\n\t\t}\n\t},\n\t[SA_ALG_ECB_DES3] = {\n\t\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t\t.alg.skcipher = {\n\t\t\t.base.cra_name\t\t= \"ecb(des3_ede)\",\n\t\t\t.base.cra_driver_name\t= \"ecb-des3-sa2ul\",\n\t\t\t.base.cra_priority\t= 30000,\n\t\t\t.base.cra_flags\t\t= CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t\t  CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t\t.base.cra_ctxsize\t= sizeof(struct sa_tfm_ctx),\n\t\t\t.base.cra_module\t= THIS_MODULE,\n\t\t\t.init\t\t\t= sa_cipher_cra_init,\n\t\t\t.exit\t\t\t= sa_cipher_cra_exit,\n\t\t\t.min_keysize\t\t= 3 * DES_KEY_SIZE,\n\t\t\t.max_keysize\t\t= 3 * DES_KEY_SIZE,\n\t\t\t.setkey\t\t\t= sa_3des_ecb_setkey,\n\t\t\t.encrypt\t\t= sa_encrypt,\n\t\t\t.decrypt\t\t= sa_decrypt,\n\t\t}\n\t},\n\t[SA_ALG_SHA1] = {\n\t\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.ahash = {\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name\t= \"sha1\",\n\t\t\t\t.cra_driver_name\t= \"sha1-sa2ul\",\n\t\t\t\t.cra_priority\t= 400,\n\t\t\t\t.cra_flags\t= CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\t\t  CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize\t= SHA1_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize\t= sizeof(struct sa_tfm_ctx),\n\t\t\t\t.cra_module\t= THIS_MODULE,\n\t\t\t\t.cra_init\t= sa_sha1_cra_init,\n\t\t\t\t.cra_exit\t= sa_sha_cra_exit,\n\t\t\t},\n\t\t\t.halg.digestsize\t= SHA1_DIGEST_SIZE,\n\t\t\t.halg.statesize\t\t= sizeof(struct sa_sha_req_ctx) +\n\t\t\t\t\t\t  sizeof(struct sha1_state),\n\t\t\t.init\t\t\t= sa_sha_init,\n\t\t\t.update\t\t\t= sa_sha_update,\n\t\t\t.final\t\t\t= sa_sha_final,\n\t\t\t.finup\t\t\t= sa_sha_finup,\n\t\t\t.digest\t\t\t= sa_sha_digest,\n\t\t\t.export\t\t\t= sa_sha_export,\n\t\t\t.import\t\t\t= sa_sha_import,\n\t\t},\n\t},\n\t[SA_ALG_SHA256] = {\n\t\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.ahash = {\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name\t= \"sha256\",\n\t\t\t\t.cra_driver_name\t= \"sha256-sa2ul\",\n\t\t\t\t.cra_priority\t= 400,\n\t\t\t\t.cra_flags\t= CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\t\t  CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize\t= SHA256_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize\t= sizeof(struct sa_tfm_ctx),\n\t\t\t\t.cra_module\t= THIS_MODULE,\n\t\t\t\t.cra_init\t= sa_sha256_cra_init,\n\t\t\t\t.cra_exit\t= sa_sha_cra_exit,\n\t\t\t},\n\t\t\t.halg.digestsize\t= SHA256_DIGEST_SIZE,\n\t\t\t.halg.statesize\t\t= sizeof(struct sa_sha_req_ctx) +\n\t\t\t\t\t\t  sizeof(struct sha256_state),\n\t\t\t.init\t\t\t= sa_sha_init,\n\t\t\t.update\t\t\t= sa_sha_update,\n\t\t\t.final\t\t\t= sa_sha_final,\n\t\t\t.finup\t\t\t= sa_sha_finup,\n\t\t\t.digest\t\t\t= sa_sha_digest,\n\t\t\t.export\t\t\t= sa_sha_export,\n\t\t\t.import\t\t\t= sa_sha_import,\n\t\t},\n\t},\n\t[SA_ALG_SHA512] = {\n\t\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.ahash = {\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name\t= \"sha512\",\n\t\t\t\t.cra_driver_name\t= \"sha512-sa2ul\",\n\t\t\t\t.cra_priority\t= 400,\n\t\t\t\t.cra_flags\t= CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\t\t  CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_blocksize\t= SHA512_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize\t= sizeof(struct sa_tfm_ctx),\n\t\t\t\t.cra_module\t= THIS_MODULE,\n\t\t\t\t.cra_init\t= sa_sha512_cra_init,\n\t\t\t\t.cra_exit\t= sa_sha_cra_exit,\n\t\t\t},\n\t\t\t.halg.digestsize\t= SHA512_DIGEST_SIZE,\n\t\t\t.halg.statesize\t\t= sizeof(struct sa_sha_req_ctx) +\n\t\t\t\t\t\t  sizeof(struct sha512_state),\n\t\t\t.init\t\t\t= sa_sha_init,\n\t\t\t.update\t\t\t= sa_sha_update,\n\t\t\t.final\t\t\t= sa_sha_final,\n\t\t\t.finup\t\t\t= sa_sha_finup,\n\t\t\t.digest\t\t\t= sa_sha_digest,\n\t\t\t.export\t\t\t= sa_sha_export,\n\t\t\t.import\t\t\t= sa_sha_import,\n\t\t},\n\t},\n\t[SA_ALG_AUTHENC_SHA1_AES] = {\n\t\t.type\t= CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha1),cbc(aes))\",\n\t\t\t\t.cra_driver_name =\n\t\t\t\t\t\"authenc(hmac(sha1),cbc(aes))-sa2ul\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_TYPE_AEAD |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_ctxsize = sizeof(struct sa_tfm_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t\t.cra_priority = 3000,\n\t\t\t},\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\n\t\t\t.init = sa_cra_init_aead_sha1,\n\t\t\t.exit = sa_exit_tfm_aead,\n\t\t\t.setkey = sa_aead_cbc_sha1_setkey,\n\t\t\t.setauthsize = sa_aead_setauthsize,\n\t\t\t.encrypt = sa_aead_encrypt,\n\t\t\t.decrypt = sa_aead_decrypt,\n\t\t},\n\t},\n\t[SA_ALG_AUTHENC_SHA256_AES] = {\n\t\t.type\t= CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha256),cbc(aes))\",\n\t\t\t\t.cra_driver_name =\n\t\t\t\t\t\"authenc(hmac(sha256),cbc(aes))-sa2ul\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_TYPE_AEAD |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK,\n\t\t\t\t.cra_ctxsize = sizeof(struct sa_tfm_ctx),\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t\t.cra_alignmask = 0,\n\t\t\t\t.cra_priority = 3000,\n\t\t\t},\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\n\t\t\t.init = sa_cra_init_aead_sha256,\n\t\t\t.exit = sa_exit_tfm_aead,\n\t\t\t.setkey = sa_aead_cbc_sha256_setkey,\n\t\t\t.setauthsize = sa_aead_setauthsize,\n\t\t\t.encrypt = sa_aead_encrypt,\n\t\t\t.decrypt = sa_aead_decrypt,\n\t\t},\n\t},\n};\n\n \nstatic void sa_register_algos(struct sa_crypto_data *dev_data)\n{\n\tconst struct sa_match_data *match_data = dev_data->match_data;\n\tstruct device *dev = dev_data->dev;\n\tchar *alg_name;\n\tu32 type;\n\tint i, err;\n\n\tfor (i = 0; i < ARRAY_SIZE(sa_algs); i++) {\n\t\t \n\t\tif (!(match_data->supported_algos & BIT(i)))\n\t\t\tcontinue;\n\n\t\ttype = sa_algs[i].type;\n\t\tif (type == CRYPTO_ALG_TYPE_SKCIPHER) {\n\t\t\talg_name = sa_algs[i].alg.skcipher.base.cra_name;\n\t\t\terr = crypto_register_skcipher(&sa_algs[i].alg.skcipher);\n\t\t} else if (type == CRYPTO_ALG_TYPE_AHASH) {\n\t\t\talg_name = sa_algs[i].alg.ahash.halg.base.cra_name;\n\t\t\terr = crypto_register_ahash(&sa_algs[i].alg.ahash);\n\t\t} else if (type == CRYPTO_ALG_TYPE_AEAD) {\n\t\t\talg_name = sa_algs[i].alg.aead.base.cra_name;\n\t\t\terr = crypto_register_aead(&sa_algs[i].alg.aead);\n\t\t} else {\n\t\t\tdev_err(dev,\n\t\t\t\t\"un-supported crypto algorithm (%d)\",\n\t\t\t\tsa_algs[i].type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (err)\n\t\t\tdev_err(dev, \"Failed to register '%s'\\n\", alg_name);\n\t\telse\n\t\t\tsa_algs[i].registered = true;\n\t}\n}\n\n \nstatic void sa_unregister_algos(const struct device *dev)\n{\n\tu32 type;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sa_algs); i++) {\n\t\ttype = sa_algs[i].type;\n\t\tif (!sa_algs[i].registered)\n\t\t\tcontinue;\n\t\tif (type == CRYPTO_ALG_TYPE_SKCIPHER)\n\t\t\tcrypto_unregister_skcipher(&sa_algs[i].alg.skcipher);\n\t\telse if (type == CRYPTO_ALG_TYPE_AHASH)\n\t\t\tcrypto_unregister_ahash(&sa_algs[i].alg.ahash);\n\t\telse if (type == CRYPTO_ALG_TYPE_AEAD)\n\t\t\tcrypto_unregister_aead(&sa_algs[i].alg.aead);\n\n\t\tsa_algs[i].registered = false;\n\t}\n}\n\nstatic int sa_init_mem(struct sa_crypto_data *dev_data)\n{\n\tstruct device *dev = &dev_data->pdev->dev;\n\t \n\tdev_data->sc_pool = dma_pool_create(\"keystone-sc\", dev,\n\t\t\t\t\t    SA_CTX_MAX_SZ, 64, 0);\n\tif (!dev_data->sc_pool) {\n\t\tdev_err(dev, \"Failed to create dma pool\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int sa_dma_init(struct sa_crypto_data *dd)\n{\n\tint ret;\n\tstruct dma_slave_config cfg;\n\n\tdd->dma_rx1 = NULL;\n\tdd->dma_tx = NULL;\n\tdd->dma_rx2 = NULL;\n\n\tret = dma_coerce_mask_and_coherent(dd->dev, DMA_BIT_MASK(48));\n\tif (ret)\n\t\treturn ret;\n\n\tdd->dma_rx1 = dma_request_chan(dd->dev, \"rx1\");\n\tif (IS_ERR(dd->dma_rx1))\n\t\treturn dev_err_probe(dd->dev, PTR_ERR(dd->dma_rx1),\n\t\t\t\t     \"Unable to request rx1 DMA channel\\n\");\n\n\tdd->dma_rx2 = dma_request_chan(dd->dev, \"rx2\");\n\tif (IS_ERR(dd->dma_rx2)) {\n\t\tret = dev_err_probe(dd->dev, PTR_ERR(dd->dma_rx2),\n\t\t\t\t    \"Unable to request rx2 DMA channel\\n\");\n\t\tgoto err_dma_rx2;\n\t}\n\n\tdd->dma_tx = dma_request_chan(dd->dev, \"tx\");\n\tif (IS_ERR(dd->dma_tx)) {\n\t\tret = dev_err_probe(dd->dev, PTR_ERR(dd->dma_tx),\n\t\t\t\t    \"Unable to request tx DMA channel\\n\");\n\t\tgoto err_dma_tx;\n\t}\n\n\tmemzero_explicit(&cfg, sizeof(cfg));\n\n\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tcfg.src_maxburst = 4;\n\tcfg.dst_maxburst = 4;\n\n\tret = dmaengine_slave_config(dd->dma_rx1, &cfg);\n\tif (ret) {\n\t\tdev_err(dd->dev, \"can't configure IN dmaengine slave: %d\\n\",\n\t\t\tret);\n\t\tgoto err_dma_config;\n\t}\n\n\tret = dmaengine_slave_config(dd->dma_rx2, &cfg);\n\tif (ret) {\n\t\tdev_err(dd->dev, \"can't configure IN dmaengine slave: %d\\n\",\n\t\t\tret);\n\t\tgoto err_dma_config;\n\t}\n\n\tret = dmaengine_slave_config(dd->dma_tx, &cfg);\n\tif (ret) {\n\t\tdev_err(dd->dev, \"can't configure OUT dmaengine slave: %d\\n\",\n\t\t\tret);\n\t\tgoto err_dma_config;\n\t}\n\n\treturn 0;\n\nerr_dma_config:\n\tdma_release_channel(dd->dma_tx);\nerr_dma_tx:\n\tdma_release_channel(dd->dma_rx2);\nerr_dma_rx2:\n\tdma_release_channel(dd->dma_rx1);\n\n\treturn ret;\n}\n\nstatic int sa_link_child(struct device *dev, void *data)\n{\n\tstruct device *parent = data;\n\n\tdevice_link_add(dev, parent, DL_FLAG_AUTOPROBE_CONSUMER);\n\n\treturn 0;\n}\n\nstatic struct sa_match_data am654_match_data = {\n\t.priv = 1,\n\t.priv_id = 1,\n\t.supported_algos = BIT(SA_ALG_CBC_AES) |\n\t\t\t   BIT(SA_ALG_EBC_AES) |\n\t\t\t   BIT(SA_ALG_CBC_DES3) |\n\t\t\t   BIT(SA_ALG_ECB_DES3) |\n\t\t\t   BIT(SA_ALG_SHA1) |\n\t\t\t   BIT(SA_ALG_SHA256) |\n\t\t\t   BIT(SA_ALG_SHA512) |\n\t\t\t   BIT(SA_ALG_AUTHENC_SHA1_AES) |\n\t\t\t   BIT(SA_ALG_AUTHENC_SHA256_AES),\n};\n\nstatic struct sa_match_data am64_match_data = {\n\t.priv = 0,\n\t.priv_id = 0,\n\t.supported_algos = BIT(SA_ALG_CBC_AES) |\n\t\t\t   BIT(SA_ALG_EBC_AES) |\n\t\t\t   BIT(SA_ALG_SHA256) |\n\t\t\t   BIT(SA_ALG_SHA512) |\n\t\t\t   BIT(SA_ALG_AUTHENC_SHA256_AES),\n};\n\nstatic const struct of_device_id of_match[] = {\n\t{ .compatible = \"ti,j721e-sa2ul\", .data = &am654_match_data, },\n\t{ .compatible = \"ti,am654-sa2ul\", .data = &am654_match_data, },\n\t{ .compatible = \"ti,am64-sa2ul\", .data = &am64_match_data, },\n\t{ .compatible = \"ti,am62-sa3ul\", .data = &am64_match_data, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_match);\n\nstatic int sa_ul_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstatic void __iomem *saul_base;\n\tstruct sa_crypto_data *dev_data;\n\tu32 status, val;\n\tint ret;\n\n\tdev_data = devm_kzalloc(dev, sizeof(*dev_data), GFP_KERNEL);\n\tif (!dev_data)\n\t\treturn -ENOMEM;\n\n\tdev_data->match_data = of_device_get_match_data(dev);\n\tif (!dev_data->match_data)\n\t\treturn -ENODEV;\n\n\tsaul_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(saul_base))\n\t\treturn PTR_ERR(saul_base);\n\n\tsa_k3_dev = dev;\n\tdev_data->dev = dev;\n\tdev_data->pdev = pdev;\n\tdev_data->base = saul_base;\n\tplatform_set_drvdata(pdev, dev_data);\n\tdev_set_drvdata(sa_k3_dev, dev_data);\n\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: failed to get sync: %d\\n\", __func__, ret);\n\t\tpm_runtime_disable(dev);\n\t\treturn ret;\n\t}\n\n\tsa_init_mem(dev_data);\n\tret = sa_dma_init(dev_data);\n\tif (ret)\n\t\tgoto destroy_dma_pool;\n\n\tspin_lock_init(&dev_data->scid_lock);\n\n\tval = SA_EEC_ENCSS_EN | SA_EEC_AUTHSS_EN | SA_EEC_CTXCACH_EN |\n\t      SA_EEC_CPPI_PORT_IN_EN | SA_EEC_CPPI_PORT_OUT_EN |\n\t      SA_EEC_TRNG_EN;\n\tstatus = readl_relaxed(saul_base + SA_ENGINE_STATUS);\n\t \n\tif (val & ~status)\n\t\twritel_relaxed(val, saul_base + SA_ENGINE_ENABLE_CONTROL);\n\n\tsa_register_algos(dev_data);\n\n\tret = of_platform_populate(node, NULL, NULL, dev);\n\tif (ret)\n\t\tgoto release_dma;\n\n\tdevice_for_each_child(dev, dev, sa_link_child);\n\n\treturn 0;\n\nrelease_dma:\n\tsa_unregister_algos(dev);\n\n\tdma_release_channel(dev_data->dma_rx2);\n\tdma_release_channel(dev_data->dma_rx1);\n\tdma_release_channel(dev_data->dma_tx);\n\ndestroy_dma_pool:\n\tdma_pool_destroy(dev_data->sc_pool);\n\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic int sa_ul_remove(struct platform_device *pdev)\n{\n\tstruct sa_crypto_data *dev_data = platform_get_drvdata(pdev);\n\n\tof_platform_depopulate(&pdev->dev);\n\n\tsa_unregister_algos(&pdev->dev);\n\n\tdma_release_channel(dev_data->dma_rx2);\n\tdma_release_channel(dev_data->dma_rx1);\n\tdma_release_channel(dev_data->dma_tx);\n\n\tdma_pool_destroy(dev_data->sc_pool);\n\n\tplatform_set_drvdata(pdev, NULL);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver sa_ul_driver = {\n\t.probe = sa_ul_probe,\n\t.remove = sa_ul_remove,\n\t.driver = {\n\t\t   .name = \"saul-crypto\",\n\t\t   .of_match_table = of_match,\n\t\t   },\n};\nmodule_platform_driver(sa_ul_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}