{
  "module_name": "nx-842.c",
  "hash_id": "17fbc101fc65aca9369065c345f1fc0b1749c97a36361475e8cf0dca9a430949",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/nx/nx-842.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/vmalloc.h>\n#include <linux/sw842.h>\n#include <linux/spinlock.h>\n\n#include \"nx-842.h\"\n\n \n#define NX842_CRYPTO_MAGIC\t(0xf842)\n#define NX842_CRYPTO_HEADER_SIZE(g)\t\t\t\t\\\n\t(sizeof(struct nx842_crypto_header) +\t\t\t\\\n\t sizeof(struct nx842_crypto_header_group) * (g))\n#define NX842_CRYPTO_HEADER_MAX_SIZE\t\t\t\t\\\n\tNX842_CRYPTO_HEADER_SIZE(NX842_CRYPTO_GROUP_MAX)\n\n \n#define BOUNCE_BUFFER_ORDER\t(2)\n#define BOUNCE_BUFFER_SIZE\t\t\t\t\t\\\n\t((unsigned int)(PAGE_SIZE << BOUNCE_BUFFER_ORDER))\n\n \n#define COMP_BUSY_TIMEOUT\t(250)  \n#define DECOMP_BUSY_TIMEOUT\t(50)  \n\nstruct nx842_crypto_param {\n\tu8 *in;\n\tunsigned int iremain;\n\tu8 *out;\n\tunsigned int oremain;\n\tunsigned int ototal;\n};\n\nstatic int update_param(struct nx842_crypto_param *p,\n\t\t\tunsigned int slen, unsigned int dlen)\n{\n\tif (p->iremain < slen)\n\t\treturn -EOVERFLOW;\n\tif (p->oremain < dlen)\n\t\treturn -ENOSPC;\n\n\tp->in += slen;\n\tp->iremain -= slen;\n\tp->out += dlen;\n\tp->oremain -= dlen;\n\tp->ototal += dlen;\n\n\treturn 0;\n}\n\nint nx842_crypto_init(struct crypto_tfm *tfm, struct nx842_driver *driver)\n{\n\tstruct nx842_crypto_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tspin_lock_init(&ctx->lock);\n\tctx->driver = driver;\n\tctx->wmem = kmalloc(driver->workmem_size, GFP_KERNEL);\n\tctx->sbounce = (u8 *)__get_free_pages(GFP_KERNEL, BOUNCE_BUFFER_ORDER);\n\tctx->dbounce = (u8 *)__get_free_pages(GFP_KERNEL, BOUNCE_BUFFER_ORDER);\n\tif (!ctx->wmem || !ctx->sbounce || !ctx->dbounce) {\n\t\tkfree(ctx->wmem);\n\t\tfree_page((unsigned long)ctx->sbounce);\n\t\tfree_page((unsigned long)ctx->dbounce);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nx842_crypto_init);\n\nvoid nx842_crypto_exit(struct crypto_tfm *tfm)\n{\n\tstruct nx842_crypto_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tkfree(ctx->wmem);\n\tfree_page((unsigned long)ctx->sbounce);\n\tfree_page((unsigned long)ctx->dbounce);\n}\nEXPORT_SYMBOL_GPL(nx842_crypto_exit);\n\nstatic void check_constraints(struct nx842_constraints *c)\n{\n\t \n\tif (c->maximum > BOUNCE_BUFFER_SIZE)\n\t\tc->maximum = BOUNCE_BUFFER_SIZE;\n}\n\nstatic int nx842_crypto_add_header(struct nx842_crypto_header *hdr, u8 *buf)\n{\n\tint s = NX842_CRYPTO_HEADER_SIZE(hdr->groups);\n\n\t \n\tif (s > be16_to_cpu(hdr->group[0].padding)) {\n\t\tpr_err(\"Internal error: no space for header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(buf, hdr, s);\n\n\tprint_hex_dump_debug(\"header \", DUMP_PREFIX_OFFSET, 16, 1, buf, s, 0);\n\n\treturn 0;\n}\n\nstatic int compress(struct nx842_crypto_ctx *ctx,\n\t\t    struct nx842_crypto_param *p,\n\t\t    struct nx842_crypto_header_group *g,\n\t\t    struct nx842_constraints *c,\n\t\t    u16 *ignore,\n\t\t    unsigned int hdrsize)\n{\n\tunsigned int slen = p->iremain, dlen = p->oremain, tmplen;\n\tunsigned int adj_slen = slen;\n\tu8 *src = p->in, *dst = p->out;\n\tint ret, dskip = 0;\n\tktime_t timeout;\n\n\tif (p->iremain == 0)\n\t\treturn -EOVERFLOW;\n\n\tif (p->oremain == 0 || hdrsize + c->minimum > dlen)\n\t\treturn -ENOSPC;\n\n\tif (slen % c->multiple)\n\t\tadj_slen = round_up(slen, c->multiple);\n\tif (slen < c->minimum)\n\t\tadj_slen = c->minimum;\n\tif (slen > c->maximum)\n\t\tadj_slen = slen = c->maximum;\n\tif (adj_slen > slen || (u64)src % c->alignment) {\n\t\tadj_slen = min(adj_slen, BOUNCE_BUFFER_SIZE);\n\t\tslen = min(slen, BOUNCE_BUFFER_SIZE);\n\t\tif (adj_slen > slen)\n\t\t\tmemset(ctx->sbounce + slen, 0, adj_slen - slen);\n\t\tmemcpy(ctx->sbounce, src, slen);\n\t\tsrc = ctx->sbounce;\n\t\tslen = adj_slen;\n\t\tpr_debug(\"using comp sbounce buffer, len %x\\n\", slen);\n\t}\n\n\tdst += hdrsize;\n\tdlen -= hdrsize;\n\n\tif ((u64)dst % c->alignment) {\n\t\tdskip = (int)(PTR_ALIGN(dst, c->alignment) - dst);\n\t\tdst += dskip;\n\t\tdlen -= dskip;\n\t}\n\tif (dlen % c->multiple)\n\t\tdlen = round_down(dlen, c->multiple);\n\tif (dlen < c->minimum) {\nnospc:\n\t\tdst = ctx->dbounce;\n\t\tdlen = min(p->oremain, BOUNCE_BUFFER_SIZE);\n\t\tdlen = round_down(dlen, c->multiple);\n\t\tdskip = 0;\n\t\tpr_debug(\"using comp dbounce buffer, len %x\\n\", dlen);\n\t}\n\tif (dlen > c->maximum)\n\t\tdlen = c->maximum;\n\n\ttmplen = dlen;\n\ttimeout = ktime_add_ms(ktime_get(), COMP_BUSY_TIMEOUT);\n\tdo {\n\t\tdlen = tmplen;  \n\t\tret = ctx->driver->compress(src, slen, dst, &dlen, ctx->wmem);\n\t\t \n\t\tif (ret == -ENOSPC && dst != ctx->dbounce)\n\t\t\tgoto nospc;\n\t} while (ret == -EBUSY && ktime_before(ktime_get(), timeout));\n\tif (ret)\n\t\treturn ret;\n\n\tdskip += hdrsize;\n\n\tif (dst == ctx->dbounce)\n\t\tmemcpy(p->out + dskip, dst, dlen);\n\n\tg->padding = cpu_to_be16(dskip);\n\tg->compressed_length = cpu_to_be32(dlen);\n\tg->uncompressed_length = cpu_to_be32(slen);\n\n\tif (p->iremain < slen) {\n\t\t*ignore = slen - p->iremain;\n\t\tslen = p->iremain;\n\t}\n\n\tpr_debug(\"compress slen %x ignore %x dlen %x padding %x\\n\",\n\t\t slen, *ignore, dlen, dskip);\n\n\treturn update_param(p, slen, dskip + dlen);\n}\n\nint nx842_crypto_compress(struct crypto_tfm *tfm,\n\t\t\t  const u8 *src, unsigned int slen,\n\t\t\t  u8 *dst, unsigned int *dlen)\n{\n\tstruct nx842_crypto_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct nx842_crypto_header *hdr = &ctx->header;\n\tstruct nx842_crypto_param p;\n\tstruct nx842_constraints c = *ctx->driver->constraints;\n\tunsigned int groups, hdrsize, h;\n\tint ret, n;\n\tbool add_header;\n\tu16 ignore = 0;\n\n\tcheck_constraints(&c);\n\n\tp.in = (u8 *)src;\n\tp.iremain = slen;\n\tp.out = dst;\n\tp.oremain = *dlen;\n\tp.ototal = 0;\n\n\t*dlen = 0;\n\n\tgroups = min_t(unsigned int, NX842_CRYPTO_GROUP_MAX,\n\t\t       DIV_ROUND_UP(p.iremain, c.maximum));\n\thdrsize = NX842_CRYPTO_HEADER_SIZE(groups);\n\n\tspin_lock_bh(&ctx->lock);\n\n\t \n\tadd_header = (p.iremain % c.multiple\t||\n\t\t      p.iremain < c.minimum\t||\n\t\t      p.iremain > c.maximum\t||\n\t\t      (u64)p.in % c.alignment\t||\n\t\t      p.oremain % c.multiple\t||\n\t\t      p.oremain < c.minimum\t||\n\t\t      p.oremain > c.maximum\t||\n\t\t      (u64)p.out % c.alignment);\n\n\thdr->magic = cpu_to_be16(NX842_CRYPTO_MAGIC);\n\thdr->groups = 0;\n\thdr->ignore = 0;\n\n\twhile (p.iremain > 0) {\n\t\tn = hdr->groups++;\n\t\tret = -ENOSPC;\n\t\tif (hdr->groups > NX842_CRYPTO_GROUP_MAX)\n\t\t\tgoto unlock;\n\n\t\t \n\t\th = !n && add_header ? hdrsize : 0;\n\n\t\tif (ignore)\n\t\t\tpr_warn(\"internal error, ignore is set %x\\n\", ignore);\n\n\t\tret = compress(ctx, &p, &hdr->group[n], &c, &ignore, h);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tif (!add_header && hdr->groups > 1) {\n\t\tpr_err(\"Internal error: No header but multiple groups\\n\");\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\t \n\thdr->ignore = cpu_to_be16(ignore);\n\tif (ignore)\n\t\tpr_debug(\"marked %d bytes as ignore\\n\", ignore);\n\n\tif (add_header)\n\t\tret = nx842_crypto_add_header(hdr, dst);\n\tif (ret)\n\t\tgoto unlock;\n\n\t*dlen = p.ototal;\n\n\tpr_debug(\"compress total slen %x dlen %x\\n\", slen, *dlen);\n\nunlock:\n\tspin_unlock_bh(&ctx->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nx842_crypto_compress);\n\nstatic int decompress(struct nx842_crypto_ctx *ctx,\n\t\t      struct nx842_crypto_param *p,\n\t\t      struct nx842_crypto_header_group *g,\n\t\t      struct nx842_constraints *c,\n\t\t      u16 ignore)\n{\n\tunsigned int slen = be32_to_cpu(g->compressed_length);\n\tunsigned int required_len = be32_to_cpu(g->uncompressed_length);\n\tunsigned int dlen = p->oremain, tmplen;\n\tunsigned int adj_slen = slen;\n\tu8 *src = p->in, *dst = p->out;\n\tu16 padding = be16_to_cpu(g->padding);\n\tint ret, spadding = 0;\n\tktime_t timeout;\n\n\tif (!slen || !required_len)\n\t\treturn -EINVAL;\n\n\tif (p->iremain <= 0 || padding + slen > p->iremain)\n\t\treturn -EOVERFLOW;\n\n\tif (p->oremain <= 0 || required_len - ignore > p->oremain)\n\t\treturn -ENOSPC;\n\n\tsrc += padding;\n\n\tif (slen % c->multiple)\n\t\tadj_slen = round_up(slen, c->multiple);\n\tif (slen < c->minimum)\n\t\tadj_slen = c->minimum;\n\tif (slen > c->maximum)\n\t\tgoto usesw;\n\tif (slen < adj_slen || (u64)src % c->alignment) {\n\t\t \n\t\tif (slen < adj_slen)\n\t\t\tmemset(ctx->sbounce + slen, 0, adj_slen - slen);\n\t\tmemcpy(ctx->sbounce, src, slen);\n\t\tsrc = ctx->sbounce;\n\t\tspadding = adj_slen - slen;\n\t\tslen = adj_slen;\n\t\tpr_debug(\"using decomp sbounce buffer, len %x\\n\", slen);\n\t}\n\n\tif (dlen % c->multiple)\n\t\tdlen = round_down(dlen, c->multiple);\n\tif (dlen < required_len || (u64)dst % c->alignment) {\n\t\tdst = ctx->dbounce;\n\t\tdlen = min(required_len, BOUNCE_BUFFER_SIZE);\n\t\tpr_debug(\"using decomp dbounce buffer, len %x\\n\", dlen);\n\t}\n\tif (dlen < c->minimum)\n\t\tgoto usesw;\n\tif (dlen > c->maximum)\n\t\tdlen = c->maximum;\n\n\ttmplen = dlen;\n\ttimeout = ktime_add_ms(ktime_get(), DECOMP_BUSY_TIMEOUT);\n\tdo {\n\t\tdlen = tmplen;  \n\t\tret = ctx->driver->decompress(src, slen, dst, &dlen, ctx->wmem);\n\t} while (ret == -EBUSY && ktime_before(ktime_get(), timeout));\n\tif (ret) {\nusesw:\n\t\t \n\t\tsrc = p->in + padding;\n\t\tslen = be32_to_cpu(g->compressed_length);\n\t\tspadding = 0;\n\t\tdst = p->out;\n\t\tdlen = p->oremain;\n\t\tif (dlen < required_len) {  \n\t\t\tdst = ctx->dbounce;\n\t\t\tdlen = BOUNCE_BUFFER_SIZE;\n\t\t}\n\t\tpr_info_ratelimited(\"using software 842 decompression\\n\");\n\t\tret = sw842_decompress(src, slen, dst, &dlen);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tslen -= spadding;\n\n\tdlen -= ignore;\n\tif (ignore)\n\t\tpr_debug(\"ignoring last %x bytes\\n\", ignore);\n\n\tif (dst == ctx->dbounce)\n\t\tmemcpy(p->out, dst, dlen);\n\n\tpr_debug(\"decompress slen %x padding %x dlen %x ignore %x\\n\",\n\t\t slen, padding, dlen, ignore);\n\n\treturn update_param(p, slen + padding, dlen);\n}\n\nint nx842_crypto_decompress(struct crypto_tfm *tfm,\n\t\t\t    const u8 *src, unsigned int slen,\n\t\t\t    u8 *dst, unsigned int *dlen)\n{\n\tstruct nx842_crypto_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct nx842_crypto_header *hdr;\n\tstruct nx842_crypto_param p;\n\tstruct nx842_constraints c = *ctx->driver->constraints;\n\tint n, ret, hdr_len;\n\tu16 ignore = 0;\n\n\tcheck_constraints(&c);\n\n\tp.in = (u8 *)src;\n\tp.iremain = slen;\n\tp.out = dst;\n\tp.oremain = *dlen;\n\tp.ototal = 0;\n\n\t*dlen = 0;\n\n\thdr = (struct nx842_crypto_header *)src;\n\n\tspin_lock_bh(&ctx->lock);\n\n\t \n\tif (be16_to_cpu(hdr->magic) != NX842_CRYPTO_MAGIC) {\n\t\tstruct nx842_crypto_header_group g = {\n\t\t\t.padding =\t\t0,\n\t\t\t.compressed_length =\tcpu_to_be32(p.iremain),\n\t\t\t.uncompressed_length =\tcpu_to_be32(p.oremain),\n\t\t};\n\n\t\tret = decompress(ctx, &p, &g, &c, 0);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tgoto success;\n\t}\n\n\tif (!hdr->groups) {\n\t\tpr_err(\"header has no groups\\n\");\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\tif (hdr->groups > NX842_CRYPTO_GROUP_MAX) {\n\t\tpr_err(\"header has too many groups %x, max %x\\n\",\n\t\t       hdr->groups, NX842_CRYPTO_GROUP_MAX);\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\thdr_len = NX842_CRYPTO_HEADER_SIZE(hdr->groups);\n\tif (hdr_len > slen) {\n\t\tret = -EOVERFLOW;\n\t\tgoto unlock;\n\t}\n\n\tmemcpy(&ctx->header, src, hdr_len);\n\thdr = &ctx->header;\n\n\tfor (n = 0; n < hdr->groups; n++) {\n\t\t \n\t\tif (n + 1 == hdr->groups)\n\t\t\tignore = be16_to_cpu(hdr->ignore);\n\n\t\tret = decompress(ctx, &p, &hdr->group[n], &c, ignore);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\nsuccess:\n\t*dlen = p.ototal;\n\n\tpr_debug(\"decompress total slen %x dlen %x\\n\", slen, *dlen);\n\n\tret = 0;\n\nunlock:\n\tspin_unlock_bh(&ctx->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nx842_crypto_decompress);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"IBM PowerPC Nest (NX) 842 Hardware Compression Driver\");\nMODULE_AUTHOR(\"Dan Streetman <ddstreet@ieee.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}