{
  "module_name": "nx-sha256.c",
  "hash_id": "8bfc526a2c49da8e197228ba205162fc304c99af749a628347e4747ddf19beae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/nx/nx-sha256.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/hash.h>\n#include <crypto/sha2.h>\n#include <linux/module.h>\n#include <asm/vio.h>\n#include <asm/byteorder.h>\n\n#include \"nx_csbcpb.h\"\n#include \"nx.h\"\n\nstruct sha256_state_be {\n\t__be32 state[SHA256_DIGEST_SIZE / 4];\n\tu64 count;\n\tu8 buf[SHA256_BLOCK_SIZE];\n};\n\nstatic int nx_crypto_ctx_sha256_init(struct crypto_tfm *tfm)\n{\n\tstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(tfm);\n\tint err;\n\n\terr = nx_crypto_ctx_sha_init(tfm);\n\tif (err)\n\t\treturn err;\n\n\tnx_ctx_init(nx_ctx, HCOP_FC_SHA);\n\n\tnx_ctx->ap = &nx_ctx->props[NX_PROPS_SHA256];\n\n\tNX_CPB_SET_DIGEST_SIZE(nx_ctx->csbcpb, NX_DS_SHA256);\n\n\treturn 0;\n}\n\nstatic int nx_sha256_init(struct shash_desc *desc) {\n\tstruct sha256_state_be *sctx = shash_desc_ctx(desc);\n\n\tmemset(sctx, 0, sizeof *sctx);\n\n\tsctx->state[0] = __cpu_to_be32(SHA256_H0);\n\tsctx->state[1] = __cpu_to_be32(SHA256_H1);\n\tsctx->state[2] = __cpu_to_be32(SHA256_H2);\n\tsctx->state[3] = __cpu_to_be32(SHA256_H3);\n\tsctx->state[4] = __cpu_to_be32(SHA256_H4);\n\tsctx->state[5] = __cpu_to_be32(SHA256_H5);\n\tsctx->state[6] = __cpu_to_be32(SHA256_H6);\n\tsctx->state[7] = __cpu_to_be32(SHA256_H7);\n\tsctx->count = 0;\n\n\treturn 0;\n}\n\nstatic int nx_sha256_update(struct shash_desc *desc, const u8 *data,\n\t\t\t    unsigned int len)\n{\n\tstruct sha256_state_be *sctx = shash_desc_ctx(desc);\n\tstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&desc->tfm->base);\n\tstruct nx_csbcpb *csbcpb = (struct nx_csbcpb *)nx_ctx->csbcpb;\n\tstruct nx_sg *out_sg;\n\tu64 to_process = 0, leftover, total;\n\tunsigned long irq_flags;\n\tint rc = 0;\n\tint data_len;\n\tu32 max_sg_len;\n\tu64 buf_len = (sctx->count % SHA256_BLOCK_SIZE);\n\n\tspin_lock_irqsave(&nx_ctx->lock, irq_flags);\n\n\t \n\ttotal = (sctx->count % SHA256_BLOCK_SIZE) + len;\n\tif (total < SHA256_BLOCK_SIZE) {\n\t\tmemcpy(sctx->buf + buf_len, data, len);\n\t\tsctx->count += len;\n\t\tgoto out;\n\t}\n\n\tmemcpy(csbcpb->cpb.sha256.message_digest, sctx->state, SHA256_DIGEST_SIZE);\n\tNX_CPB_FDM(csbcpb) |= NX_FDM_INTERMEDIATE;\n\tNX_CPB_FDM(csbcpb) |= NX_FDM_CONTINUATION;\n\n\tmax_sg_len = min_t(u64, nx_ctx->ap->sglen,\n\t\t\tnx_driver.of.max_sg_len/sizeof(struct nx_sg));\n\tmax_sg_len = min_t(u64, max_sg_len,\n\t\t\tnx_ctx->ap->databytelen/NX_PAGE_SIZE);\n\n\tdata_len = SHA256_DIGEST_SIZE;\n\tout_sg = nx_build_sg_list(nx_ctx->out_sg, (u8 *)sctx->state,\n\t\t\t\t  &data_len, max_sg_len);\n\tnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\n\n\tif (data_len != SHA256_DIGEST_SIZE) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tint used_sgs = 0;\n\t\tstruct nx_sg *in_sg = nx_ctx->in_sg;\n\n\t\tif (buf_len) {\n\t\t\tdata_len = buf_len;\n\t\t\tin_sg = nx_build_sg_list(in_sg,\n\t\t\t\t\t\t (u8 *) sctx->buf,\n\t\t\t\t\t\t &data_len,\n\t\t\t\t\t\t max_sg_len);\n\n\t\t\tif (data_len != buf_len) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tused_sgs = in_sg - nx_ctx->in_sg;\n\t\t}\n\n\t\t \n\t\tto_process = min_t(u64, total,\n\t\t\t(max_sg_len - 1 - used_sgs) * NX_PAGE_SIZE);\n\t\tto_process = to_process & ~(SHA256_BLOCK_SIZE - 1);\n\n\t\tdata_len = to_process - buf_len;\n\t\tin_sg = nx_build_sg_list(in_sg, (u8 *) data,\n\t\t\t\t\t &data_len, max_sg_len);\n\n\t\tnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) * sizeof(struct nx_sg);\n\n\t\tto_process = data_len + buf_len;\n\t\tleftover = total - to_process;\n\n\t\t \n\t\tmemcpy(csbcpb->cpb.sha256.input_partial_digest,\n\t\t\t       csbcpb->cpb.sha256.message_digest,\n\t\t\t       SHA256_DIGEST_SIZE);\n\n\t\tif (!nx_ctx->op.inlen || !nx_ctx->op.outlen) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = nx_hcall_sync(nx_ctx, &nx_ctx->op, 0);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tatomic_inc(&(nx_ctx->stats->sha256_ops));\n\n\t\ttotal -= to_process;\n\t\tdata += to_process - buf_len;\n\t\tbuf_len = 0;\n\n\t} while (leftover >= SHA256_BLOCK_SIZE);\n\n\t \n\tif (leftover)\n\t\tmemcpy(sctx->buf, data, leftover);\n\n\tsctx->count += len;\n\tmemcpy(sctx->state, csbcpb->cpb.sha256.message_digest, SHA256_DIGEST_SIZE);\nout:\n\tspin_unlock_irqrestore(&nx_ctx->lock, irq_flags);\n\treturn rc;\n}\n\nstatic int nx_sha256_final(struct shash_desc *desc, u8 *out)\n{\n\tstruct sha256_state_be *sctx = shash_desc_ctx(desc);\n\tstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&desc->tfm->base);\n\tstruct nx_csbcpb *csbcpb = (struct nx_csbcpb *)nx_ctx->csbcpb;\n\tstruct nx_sg *in_sg, *out_sg;\n\tunsigned long irq_flags;\n\tu32 max_sg_len;\n\tint rc = 0;\n\tint len;\n\n\tspin_lock_irqsave(&nx_ctx->lock, irq_flags);\n\n\tmax_sg_len = min_t(u64, nx_ctx->ap->sglen,\n\t\t\tnx_driver.of.max_sg_len/sizeof(struct nx_sg));\n\tmax_sg_len = min_t(u64, max_sg_len,\n\t\t\tnx_ctx->ap->databytelen/NX_PAGE_SIZE);\n\n\t \n\tif (sctx->count >= SHA256_BLOCK_SIZE) {\n\t\t \n\t\tmemcpy(csbcpb->cpb.sha256.input_partial_digest, sctx->state, SHA256_DIGEST_SIZE);\n\t\tNX_CPB_FDM(csbcpb) &= ~NX_FDM_INTERMEDIATE;\n\t\tNX_CPB_FDM(csbcpb) |= NX_FDM_CONTINUATION;\n\t} else {\n\t\tNX_CPB_FDM(csbcpb) &= ~NX_FDM_INTERMEDIATE;\n\t\tNX_CPB_FDM(csbcpb) &= ~NX_FDM_CONTINUATION;\n\t}\n\n\tcsbcpb->cpb.sha256.message_bit_length = (u64) (sctx->count * 8);\n\n\tlen = sctx->count & (SHA256_BLOCK_SIZE - 1);\n\tin_sg = nx_build_sg_list(nx_ctx->in_sg, (u8 *) sctx->buf,\n\t\t\t\t &len, max_sg_len);\n\n\tif (len != (sctx->count & (SHA256_BLOCK_SIZE - 1))) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = SHA256_DIGEST_SIZE;\n\tout_sg = nx_build_sg_list(nx_ctx->out_sg, out, &len, max_sg_len);\n\n\tif (len != SHA256_DIGEST_SIZE) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) * sizeof(struct nx_sg);\n\tnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\n\tif (!nx_ctx->op.outlen) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = nx_hcall_sync(nx_ctx, &nx_ctx->op, 0);\n\tif (rc)\n\t\tgoto out;\n\n\tatomic_inc(&(nx_ctx->stats->sha256_ops));\n\n\tatomic64_add(sctx->count, &(nx_ctx->stats->sha256_bytes));\n\tmemcpy(out, csbcpb->cpb.sha256.message_digest, SHA256_DIGEST_SIZE);\nout:\n\tspin_unlock_irqrestore(&nx_ctx->lock, irq_flags);\n\treturn rc;\n}\n\nstatic int nx_sha256_export(struct shash_desc *desc, void *out)\n{\n\tstruct sha256_state_be *sctx = shash_desc_ctx(desc);\n\n\tmemcpy(out, sctx, sizeof(*sctx));\n\n\treturn 0;\n}\n\nstatic int nx_sha256_import(struct shash_desc *desc, const void *in)\n{\n\tstruct sha256_state_be *sctx = shash_desc_ctx(desc);\n\n\tmemcpy(sctx, in, sizeof(*sctx));\n\n\treturn 0;\n}\n\nstruct shash_alg nx_shash_sha256_alg = {\n\t.digestsize = SHA256_DIGEST_SIZE,\n\t.init       = nx_sha256_init,\n\t.update     = nx_sha256_update,\n\t.final      = nx_sha256_final,\n\t.export     = nx_sha256_export,\n\t.import     = nx_sha256_import,\n\t.descsize   = sizeof(struct sha256_state_be),\n\t.statesize  = sizeof(struct sha256_state_be),\n\t.base       = {\n\t\t.cra_name        = \"sha256\",\n\t\t.cra_driver_name = \"sha256-nx\",\n\t\t.cra_priority    = 300,\n\t\t.cra_blocksize   = SHA256_BLOCK_SIZE,\n\t\t.cra_module      = THIS_MODULE,\n\t\t.cra_ctxsize     = sizeof(struct nx_crypto_ctx),\n\t\t.cra_init        = nx_crypto_ctx_sha256_init,\n\t\t.cra_exit        = nx_crypto_ctx_exit,\n\t}\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}