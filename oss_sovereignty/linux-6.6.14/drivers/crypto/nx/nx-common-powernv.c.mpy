{
  "module_name": "nx-common-powernv.c",
  "hash_id": "45f4e6e56dc78a0cb7506787ea2075b2999a901a954872eb585337e4b4d05332",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/nx/nx-common-powernv.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"nx-842.h\"\n\n#include <linux/timer.h>\n\n#include <asm/prom.h>\n#include <asm/icswx.h>\n#include <asm/vas.h>\n#include <asm/reg.h>\n#include <asm/opal-api.h>\n#include <asm/opal.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Dan Streetman <ddstreet@ieee.org>\");\nMODULE_DESCRIPTION(\"H/W Compression driver for IBM PowerNV processors\");\nMODULE_ALIAS_CRYPTO(\"842\");\nMODULE_ALIAS_CRYPTO(\"842-nx\");\n\n#define WORKMEM_ALIGN\t(CRB_ALIGN)\n#define CSB_WAIT_MAX\t(5000)  \n#define VAS_RETRIES\t(10)\n\nstruct nx842_workmem {\n\t \n\tstruct coprocessor_request_block crb;  \n\tstruct data_descriptor_entry ddl_in[DDL_LEN_MAX];  \n\tstruct data_descriptor_entry ddl_out[DDL_LEN_MAX];  \n\t \n\n\tktime_t start;\n\n\tchar padding[WORKMEM_ALIGN];  \n} __packed __aligned(WORKMEM_ALIGN);\n\nstruct nx_coproc {\n\tunsigned int chip_id;\n\tunsigned int ct;\t \n\tunsigned int ci;\t \n\tstruct {\n\t\tstruct vas_window *rxwin;\n\t\tint id;\n\t} vas;\n\tstruct list_head list;\n};\n\n \nstatic DEFINE_PER_CPU(struct vas_window *, cpu_txwin);\n\n \nstatic LIST_HEAD(nx_coprocs);\nstatic unsigned int nx842_ct;\t \n\n \n#define NX_CT_GZIP\t(2)\t \n#define NX_CT_842\t(3)\n\nstatic int (*nx842_powernv_exec)(const unsigned char *in,\n\t\t\t\tunsigned int inlen, unsigned char *out,\n\t\t\t\tunsigned int *outlenp, void *workmem, int fc);\n\n \nstatic void setup_indirect_dde(struct data_descriptor_entry *dde,\n\t\t\t       struct data_descriptor_entry *ddl,\n\t\t\t       unsigned int dde_count, unsigned int byte_count)\n{\n\tdde->flags = 0;\n\tdde->count = dde_count;\n\tdde->index = 0;\n\tdde->length = cpu_to_be32(byte_count);\n\tdde->address = cpu_to_be64(nx842_get_pa(ddl));\n}\n\n \nstatic unsigned int setup_direct_dde(struct data_descriptor_entry *dde,\n\t\t\t\t     unsigned long pa, unsigned int len)\n{\n\tunsigned int l = min_t(unsigned int, len, LEN_ON_PAGE(pa));\n\n\tdde->flags = 0;\n\tdde->count = 0;\n\tdde->index = 0;\n\tdde->length = cpu_to_be32(l);\n\tdde->address = cpu_to_be64(pa);\n\n\treturn l;\n}\n\n \nstatic int setup_ddl(struct data_descriptor_entry *dde,\n\t\t     struct data_descriptor_entry *ddl,\n\t\t     unsigned char *buf, unsigned int len,\n\t\t     bool in)\n{\n\tunsigned long pa = nx842_get_pa(buf);\n\tint i, ret, total_len = len;\n\n\tif (!IS_ALIGNED(pa, DDE_BUFFER_ALIGN)) {\n\t\tpr_debug(\"%s buffer pa 0x%lx not 0x%x-byte aligned\\n\",\n\t\t\t in ? \"input\" : \"output\", pa, DDE_BUFFER_ALIGN);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (len % DDE_BUFFER_LAST_MULT) {\n\t\tpr_debug(\"%s buffer len 0x%x not a multiple of 0x%x\\n\",\n\t\t\t in ? \"input\" : \"output\", len, DDE_BUFFER_LAST_MULT);\n\t\tif (in)\n\t\t\treturn -EINVAL;\n\t\tlen = round_down(len, DDE_BUFFER_LAST_MULT);\n\t}\n\n\t \n\tif (len <= LEN_ON_PAGE(pa)) {\n\t\tret = setup_direct_dde(dde, pa, len);\n\t\tWARN_ON(ret < len);\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < DDL_LEN_MAX && len > 0; i++) {\n\t\tret = setup_direct_dde(&ddl[i], pa, len);\n\t\tbuf += ret;\n\t\tlen -= ret;\n\t\tpa = nx842_get_pa(buf);\n\t}\n\n\tif (len > 0) {\n\t\tpr_debug(\"0x%x total %s bytes 0x%x too many for DDL.\\n\",\n\t\t\t total_len, in ? \"input\" : \"output\", len);\n\t\tif (in)\n\t\t\treturn -EMSGSIZE;\n\t\ttotal_len -= len;\n\t}\n\tsetup_indirect_dde(dde, ddl, i, total_len);\n\n\treturn 0;\n}\n\n#define CSB_ERR(csb, msg, ...)\t\t\t\t\t\\\n\tpr_err(\"ERROR: \" msg \" : %02x %02x %02x %02x %08x\\n\",\t\\\n\t       ##__VA_ARGS__, (csb)->flags,\t\t\t\\\n\t       (csb)->cs, (csb)->cc, (csb)->ce,\t\t\t\\\n\t       be32_to_cpu((csb)->count))\n\n#define CSB_ERR_ADDR(csb, msg, ...)\t\t\t\t\\\n\tCSB_ERR(csb, msg \" at %lx\", ##__VA_ARGS__,\t\t\\\n\t\t(unsigned long)be64_to_cpu((csb)->address))\n\nstatic int wait_for_csb(struct nx842_workmem *wmem,\n\t\t\tstruct coprocessor_status_block *csb)\n{\n\tktime_t start = wmem->start, now = ktime_get();\n\tktime_t timeout = ktime_add_ms(start, CSB_WAIT_MAX);\n\n\twhile (!(READ_ONCE(csb->flags) & CSB_V)) {\n\t\tcpu_relax();\n\t\tnow = ktime_get();\n\t\tif (ktime_after(now, timeout))\n\t\t\tbreak;\n\t}\n\n\t \n\tbarrier();\n\n\t \n\tif (!(csb->flags & CSB_V)) {\n\t\tCSB_ERR(csb, \"CSB still not valid after %ld us, giving up\",\n\t\t\t(long)ktime_us_delta(now, start));\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (csb->flags & CSB_F) {\n\t\tCSB_ERR(csb, \"Invalid CSB format\");\n\t\treturn -EPROTO;\n\t}\n\tif (csb->flags & CSB_CH) {\n\t\tCSB_ERR(csb, \"Invalid CSB chaining state\");\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tif (csb->cs) {\n\t\tCSB_ERR(csb, \"Invalid CSB completion sequence\");\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tswitch (csb->cc) {\n\t \n\tcase CSB_CC_SUCCESS:\n\t\tbreak;\n\tcase CSB_CC_TPBC_GT_SPBC:\n\t\t \n\t\tbreak;\n\n\t \n\tcase CSB_CC_OPERAND_OVERLAP:\n\t\t \n\t\tCSB_ERR(csb, \"Operand Overlap error\");\n\t\treturn -EINVAL;\n\tcase CSB_CC_INVALID_OPERAND:\n\t\tCSB_ERR(csb, \"Invalid operand\");\n\t\treturn -EINVAL;\n\tcase CSB_CC_NOSPC:\n\t\t \n\t\treturn -ENOSPC;\n\tcase CSB_CC_ABORT:\n\t\tCSB_ERR(csb, \"Function aborted\");\n\t\treturn -EINTR;\n\tcase CSB_CC_CRC_MISMATCH:\n\t\tCSB_ERR(csb, \"CRC mismatch\");\n\t\treturn -EINVAL;\n\tcase CSB_CC_TEMPL_INVALID:\n\t\tCSB_ERR(csb, \"Compressed data template invalid\");\n\t\treturn -EINVAL;\n\tcase CSB_CC_TEMPL_OVERFLOW:\n\t\tCSB_ERR(csb, \"Compressed data template shows data past end\");\n\t\treturn -EINVAL;\n\tcase CSB_CC_EXCEED_BYTE_COUNT:\t \n\t\t \n\t\tCSB_ERR(csb, \"DDE byte count exceeds the limit\");\n\t\treturn -EINVAL;\n\n\t \n\tcase CSB_CC_INVALID_ALIGN:\n\t\t \n\t\tCSB_ERR_ADDR(csb, \"Invalid alignment\");\n\t\treturn -EINVAL;\n\tcase CSB_CC_DATA_LENGTH:\n\t\t \n\t\tCSB_ERR(csb, \"Invalid data length\");\n\t\treturn -EINVAL;\n\tcase CSB_CC_WR_TRANSLATION:\n\tcase CSB_CC_TRANSLATION:\n\tcase CSB_CC_TRANSLATION_DUP1:\n\tcase CSB_CC_TRANSLATION_DUP2:\n\tcase CSB_CC_TRANSLATION_DUP3:\n\tcase CSB_CC_TRANSLATION_DUP4:\n\tcase CSB_CC_TRANSLATION_DUP5:\n\tcase CSB_CC_TRANSLATION_DUP6:\n\t\t \n\t\tCSB_ERR_ADDR(csb, \"Translation error\");\n\t\treturn -EPROTO;\n\tcase CSB_CC_WR_PROTECTION:\n\tcase CSB_CC_PROTECTION:\n\tcase CSB_CC_PROTECTION_DUP1:\n\tcase CSB_CC_PROTECTION_DUP2:\n\tcase CSB_CC_PROTECTION_DUP3:\n\tcase CSB_CC_PROTECTION_DUP4:\n\tcase CSB_CC_PROTECTION_DUP5:\n\tcase CSB_CC_PROTECTION_DUP6:\n\t\t \n\t\tCSB_ERR_ADDR(csb, \"Protection error\");\n\t\treturn -EPROTO;\n\tcase CSB_CC_PRIVILEGE:\n\t\t \n\t\tCSB_ERR(csb, \"Insufficient Privilege error\");\n\t\treturn -EPROTO;\n\tcase CSB_CC_EXCESSIVE_DDE:\n\t\t \n\t\tCSB_ERR(csb, \"Too many DDEs in DDL\");\n\t\treturn -EINVAL;\n\tcase CSB_CC_TRANSPORT:\n\tcase CSB_CC_INVALID_CRB:\t \n\t\t \n\t\tCSB_ERR(csb, \"Invalid CRB\");\n\t\treturn -EINVAL;\n\tcase CSB_CC_INVALID_DDE:\t \n\t\t \n\t\tCSB_ERR(csb, \"Invalid DDE\");\n\t\treturn -EINVAL;\n\tcase CSB_CC_SEGMENTED_DDL:\n\t\t \n\t\tCSB_ERR(csb, \"Segmented DDL error\");\n\t\treturn -EINVAL;\n\tcase CSB_CC_DDE_OVERFLOW:\n\t\t \n\t\tCSB_ERR(csb, \"DDE overflow error\");\n\t\treturn -EINVAL;\n\tcase CSB_CC_SESSION:\n\t\t \n\t\tCSB_ERR(csb, \"Session violation error\");\n\t\treturn -EPROTO;\n\tcase CSB_CC_CHAIN:\n\t\t \n\t\tCSB_ERR(csb, \"Chained CRB error\");\n\t\treturn -EPROTO;\n\tcase CSB_CC_SEQUENCE:\n\t\t \n\t\tCSB_ERR(csb, \"CRB sequence number error\");\n\t\treturn -EPROTO;\n\tcase CSB_CC_UNKNOWN_CODE:\n\t\tCSB_ERR(csb, \"Unknown subfunction code\");\n\t\treturn -EPROTO;\n\n\t \n\tcase CSB_CC_RD_EXTERNAL:\n\tcase CSB_CC_RD_EXTERNAL_DUP1:\n\tcase CSB_CC_RD_EXTERNAL_DUP2:\n\tcase CSB_CC_RD_EXTERNAL_DUP3:\n\t\tCSB_ERR_ADDR(csb, \"Read error outside coprocessor\");\n\t\treturn -EPROTO;\n\tcase CSB_CC_WR_EXTERNAL:\n\t\tCSB_ERR_ADDR(csb, \"Write error outside coprocessor\");\n\t\treturn -EPROTO;\n\tcase CSB_CC_INTERNAL:\n\t\tCSB_ERR(csb, \"Internal error in coprocessor\");\n\t\treturn -EPROTO;\n\tcase CSB_CC_PROVISION:\n\t\tCSB_ERR(csb, \"Storage provision error\");\n\t\treturn -EPROTO;\n\tcase CSB_CC_HW:\n\t\tCSB_ERR(csb, \"Correctable hardware error\");\n\t\treturn -EPROTO;\n\tcase CSB_CC_HW_EXPIRED_TIMER:\t \n\t\tCSB_ERR(csb, \"Job did not finish within allowed time\");\n\t\treturn -EPROTO;\n\n\tdefault:\n\t\tCSB_ERR(csb, \"Invalid CC %d\", csb->cc);\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tif (csb->ce & CSB_CE_TERMINATION) {\n\t\tCSB_ERR(csb, \"CSB request was terminated\");\n\t\treturn -EPROTO;\n\t}\n\tif (csb->ce & CSB_CE_INCOMPLETE) {\n\t\tCSB_ERR(csb, \"CSB request not complete\");\n\t\treturn -EPROTO;\n\t}\n\tif (!(csb->ce & CSB_CE_TPBC)) {\n\t\tCSB_ERR(csb, \"TPBC not provided, unknown target length\");\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tpr_debug_ratelimited(\"Processed %u bytes in %lu us\\n\",\n\t\t\t     be32_to_cpu(csb->count),\n\t\t\t     (unsigned long)ktime_us_delta(now, start));\n\n\treturn 0;\n}\n\nstatic int nx842_config_crb(const unsigned char *in, unsigned int inlen,\n\t\t\tunsigned char *out, unsigned int outlen,\n\t\t\tstruct nx842_workmem *wmem)\n{\n\tstruct coprocessor_request_block *crb;\n\tstruct coprocessor_status_block *csb;\n\tu64 csb_addr;\n\tint ret;\n\n\tcrb = &wmem->crb;\n\tcsb = &crb->csb;\n\n\t \n\tmemset(crb, 0, sizeof(*crb));\n\n\t \n\tret = setup_ddl(&crb->source, wmem->ddl_in,\n\t\t\t(unsigned char *)in, inlen, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = setup_ddl(&crb->target, wmem->ddl_out,\n\t\t\tout, outlen, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcsb_addr = nx842_get_pa(csb) & CRB_CSB_ADDRESS;\n\tcsb_addr |= CRB_CSB_AT;  \n\tcrb->csb_addr = cpu_to_be64(csb_addr);\n\n\treturn 0;\n}\n\n \nstatic int nx842_exec_icswx(const unsigned char *in, unsigned int inlen,\n\t\t\t\t  unsigned char *out, unsigned int *outlenp,\n\t\t\t\t  void *workmem, int fc)\n{\n\tstruct coprocessor_request_block *crb;\n\tstruct coprocessor_status_block *csb;\n\tstruct nx842_workmem *wmem;\n\tint ret;\n\tu32 ccw;\n\tunsigned int outlen = *outlenp;\n\n\twmem = PTR_ALIGN(workmem, WORKMEM_ALIGN);\n\n\t*outlenp = 0;\n\n\t \n\tif (!nx842_ct) {\n\t\tpr_err_ratelimited(\"coprocessor CT is 0\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = nx842_config_crb(in, inlen, out, outlen, wmem);\n\tif (ret)\n\t\treturn ret;\n\n\tcrb = &wmem->crb;\n\tcsb = &crb->csb;\n\n\t \n\tccw = 0;\n\tccw = SET_FIELD(CCW_CT, ccw, nx842_ct);\n\tccw = SET_FIELD(CCW_CI_842, ccw, 0);  \n\tccw = SET_FIELD(CCW_FC_842, ccw, fc);\n\n\twmem->start = ktime_get();\n\n\t \n\tret = icswx(cpu_to_be32(ccw), crb);\n\n\tpr_debug_ratelimited(\"icswx CR %x ccw %x crb->ccw %x\\n\", ret,\n\t\t\t     (unsigned int)ccw,\n\t\t\t     (unsigned int)be32_to_cpu(crb->ccw));\n\n\t \n\tret &= ~ICSWX_XERS0;\n\n\tswitch (ret) {\n\tcase ICSWX_INITIATED:\n\t\tret = wait_for_csb(wmem, csb);\n\t\tbreak;\n\tcase ICSWX_BUSY:\n\t\tpr_debug_ratelimited(\"842 Coprocessor busy\\n\");\n\t\tret = -EBUSY;\n\t\tbreak;\n\tcase ICSWX_REJECTED:\n\t\tpr_err_ratelimited(\"ICSWX rejected\\n\");\n\t\tret = -EPROTO;\n\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\t*outlenp = be32_to_cpu(csb->count);\n\n\treturn ret;\n}\n\n \nstatic int nx842_exec_vas(const unsigned char *in, unsigned int inlen,\n\t\t\t\t  unsigned char *out, unsigned int *outlenp,\n\t\t\t\t  void *workmem, int fc)\n{\n\tstruct coprocessor_request_block *crb;\n\tstruct coprocessor_status_block *csb;\n\tstruct nx842_workmem *wmem;\n\tstruct vas_window *txwin;\n\tint ret, i = 0;\n\tu32 ccw;\n\tunsigned int outlen = *outlenp;\n\n\twmem = PTR_ALIGN(workmem, WORKMEM_ALIGN);\n\n\t*outlenp = 0;\n\n\tcrb = &wmem->crb;\n\tcsb = &crb->csb;\n\n\tret = nx842_config_crb(in, inlen, out, outlen, wmem);\n\tif (ret)\n\t\treturn ret;\n\n\tccw = 0;\n\tccw = SET_FIELD(CCW_FC_842, ccw, fc);\n\tcrb->ccw = cpu_to_be32(ccw);\n\n\tdo {\n\t\twmem->start = ktime_get();\n\t\tpreempt_disable();\n\t\ttxwin = this_cpu_read(cpu_txwin);\n\n\t\t \n\t\tvas_copy_crb(crb, 0);\n\n\t\t \n\t\tret = vas_paste_crb(txwin, 0, 1);\n\t\tpreempt_enable();\n\t\t \n\t} while (ret && (i++ < VAS_RETRIES));\n\n\tif (ret) {\n\t\tpr_err_ratelimited(\"VAS copy/paste failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = wait_for_csb(wmem, csb);\n\tif (!ret)\n\t\t*outlenp = be32_to_cpu(csb->count);\n\n\treturn ret;\n}\n\n \nstatic int nx842_powernv_compress(const unsigned char *in, unsigned int inlen,\n\t\t\t\t  unsigned char *out, unsigned int *outlenp,\n\t\t\t\t  void *wmem)\n{\n\treturn nx842_powernv_exec(in, inlen, out, outlenp,\n\t\t\t\t      wmem, CCW_FC_842_COMP_CRC);\n}\n\n \nstatic int nx842_powernv_decompress(const unsigned char *in, unsigned int inlen,\n\t\t\t\t    unsigned char *out, unsigned int *outlenp,\n\t\t\t\t    void *wmem)\n{\n\treturn nx842_powernv_exec(in, inlen, out, outlenp,\n\t\t\t\t      wmem, CCW_FC_842_DECOMP_CRC);\n}\n\nstatic inline void nx_add_coprocs_list(struct nx_coproc *coproc,\n\t\t\t\t\tint chipid)\n{\n\tcoproc->chip_id = chipid;\n\tINIT_LIST_HEAD(&coproc->list);\n\tlist_add(&coproc->list, &nx_coprocs);\n}\n\nstatic struct vas_window *nx_alloc_txwin(struct nx_coproc *coproc)\n{\n\tstruct vas_window *txwin = NULL;\n\tstruct vas_tx_win_attr txattr;\n\n\t \n\tvas_init_tx_win_attr(&txattr, coproc->ct);\n\ttxattr.lpid = 0;\t \n\n\t \n\ttxwin = vas_tx_win_open(coproc->vas.id, coproc->ct, &txattr);\n\tif (IS_ERR(txwin))\n\t\tpr_err(\"ibm,nx-842: Can not open TX window: %ld\\n\",\n\t\t\t\tPTR_ERR(txwin));\n\n\treturn txwin;\n}\n\n \nstatic int nx_open_percpu_txwins(void)\n{\n\tstruct nx_coproc *coproc, *n;\n\tunsigned int i, chip_id;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct vas_window *txwin = NULL;\n\n\t\tchip_id = cpu_to_chip_id(i);\n\n\t\tlist_for_each_entry_safe(coproc, n, &nx_coprocs, list) {\n\t\t\t \n\n\t\t\tif (coproc->ct != VAS_COP_TYPE_842_HIPRI)\n\t\t\t\tcontinue;\n\n\t\t\tif (coproc->chip_id == chip_id) {\n\t\t\t\ttxwin = nx_alloc_txwin(coproc);\n\t\t\t\tif (IS_ERR(txwin))\n\t\t\t\t\treturn PTR_ERR(txwin);\n\n\t\t\t\tper_cpu(cpu_txwin, i) = txwin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!per_cpu(cpu_txwin, i)) {\n\t\t\t \n\t\t\tpr_err(\"NX engine is not available for CPU %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __init nx_set_ct(struct nx_coproc *coproc, const char *priority,\n\t\t\t\tint high, int normal)\n{\n\tif (!strcmp(priority, \"High\"))\n\t\tcoproc->ct = high;\n\telse if (!strcmp(priority, \"Normal\"))\n\t\tcoproc->ct = normal;\n\telse {\n\t\tpr_err(\"Invalid RxFIFO priority value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init vas_cfg_coproc_info(struct device_node *dn, int chip_id,\n\t\t\t\t\tint vasid, int type, int *ct)\n{\n\tstruct vas_window *rxwin = NULL;\n\tstruct vas_rx_win_attr rxattr;\n\tu32 lpid, pid, tid, fifo_size;\n\tstruct nx_coproc *coproc;\n\tu64 rx_fifo;\n\tconst char *priority;\n\tint ret;\n\n\tret = of_property_read_u64(dn, \"rx-fifo-address\", &rx_fifo);\n\tif (ret) {\n\t\tpr_err(\"Missing rx-fifo-address property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(dn, \"rx-fifo-size\", &fifo_size);\n\tif (ret) {\n\t\tpr_err(\"Missing rx-fifo-size property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(dn, \"lpid\", &lpid);\n\tif (ret) {\n\t\tpr_err(\"Missing lpid property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(dn, \"pid\", &pid);\n\tif (ret) {\n\t\tpr_err(\"Missing pid property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(dn, \"tid\", &tid);\n\tif (ret) {\n\t\tpr_err(\"Missing tid property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_string(dn, \"priority\", &priority);\n\tif (ret) {\n\t\tpr_err(\"Missing priority property\\n\");\n\t\treturn ret;\n\t}\n\n\tcoproc = kzalloc(sizeof(*coproc), GFP_KERNEL);\n\tif (!coproc)\n\t\treturn -ENOMEM;\n\n\tif (type == NX_CT_842)\n\t\tret = nx_set_ct(coproc, priority, VAS_COP_TYPE_842_HIPRI,\n\t\t\tVAS_COP_TYPE_842);\n\telse if (type == NX_CT_GZIP)\n\t\tret = nx_set_ct(coproc, priority, VAS_COP_TYPE_GZIP_HIPRI,\n\t\t\t\tVAS_COP_TYPE_GZIP);\n\n\tif (ret)\n\t\tgoto err_out;\n\n\tvas_init_rx_win_attr(&rxattr, coproc->ct);\n\trxattr.rx_fifo = rx_fifo;\n\trxattr.rx_fifo_size = fifo_size;\n\trxattr.lnotify_lpid = lpid;\n\trxattr.lnotify_pid = pid;\n\trxattr.lnotify_tid = tid;\n\t \n\trxattr.wcreds_max = fifo_size / CRB_SIZE;\n\n\t \n\trxwin = vas_rx_win_open(vasid, coproc->ct, &rxattr);\n\tif (IS_ERR(rxwin)) {\n\t\tret = PTR_ERR(rxwin);\n\t\tpr_err(\"setting RxFIFO with VAS failed: %d\\n\",\n\t\t\tret);\n\t\tgoto err_out;\n\t}\n\n\tcoproc->vas.rxwin = rxwin;\n\tcoproc->vas.id = vasid;\n\tnx_add_coprocs_list(coproc, chip_id);\n\n\t \n\t*ct = pid;\n\n\treturn 0;\n\nerr_out:\n\tkfree(coproc);\n\treturn ret;\n}\n\nstatic int __init nx_coproc_init(int chip_id, int ct_842, int ct_gzip)\n{\n\tint ret = 0;\n\n\tif (opal_check_token(OPAL_NX_COPROC_INIT)) {\n\t\tret = opal_nx_coproc_init(chip_id, ct_842);\n\n\t\tif (!ret)\n\t\t\tret = opal_nx_coproc_init(chip_id, ct_gzip);\n\n\t\tif (ret) {\n\t\t\tret = opal_error_code(ret);\n\t\t\tpr_err(\"Failed to initialize NX for chip(%d): %d\\n\",\n\t\t\t\tchip_id, ret);\n\t\t}\n\t} else\n\t\tpr_warn(\"Firmware doesn't support NX initialization\\n\");\n\n\treturn ret;\n}\n\nstatic int __init find_nx_device_tree(struct device_node *dn, int chip_id,\n\t\t\t\t\tint vasid, int type, char *devname,\n\t\t\t\t\tint *ct)\n{\n\tint ret = 0;\n\n\tif (of_device_is_compatible(dn, devname)) {\n\t\tret  = vas_cfg_coproc_info(dn, chip_id, vasid, type, ct);\n\t\tif (ret)\n\t\t\tof_node_put(dn);\n\t}\n\n\treturn ret;\n}\n\nstatic int __init nx_powernv_probe_vas(struct device_node *pn)\n{\n\tint chip_id, vasid, ret = 0;\n\tint ct_842 = 0, ct_gzip = 0;\n\tstruct device_node *dn;\n\n\tchip_id = of_get_ibm_chip_id(pn);\n\tif (chip_id < 0) {\n\t\tpr_err(\"ibm,chip-id missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvasid = chip_to_vas_id(chip_id);\n\tif (vasid < 0) {\n\t\tpr_err(\"Unable to map chip_id %d to vasid\\n\", chip_id);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_child_of_node(pn, dn) {\n\t\tret = find_nx_device_tree(dn, chip_id, vasid, NX_CT_842,\n\t\t\t\t\t\"ibm,p9-nx-842\", &ct_842);\n\n\t\tif (!ret)\n\t\t\tret = find_nx_device_tree(dn, chip_id, vasid,\n\t\t\t\tNX_CT_GZIP, \"ibm,p9-nx-gzip\", &ct_gzip);\n\n\t\tif (ret) {\n\t\t\tof_node_put(dn);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!ct_842 || !ct_gzip) {\n\t\tpr_err(\"NX FIFO nodes are missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = nx_coproc_init(chip_id, ct_842, ct_gzip);\n\n\treturn ret;\n}\n\nstatic int __init nx842_powernv_probe(struct device_node *dn)\n{\n\tstruct nx_coproc *coproc;\n\tunsigned int ct, ci;\n\tint chip_id;\n\n\tchip_id = of_get_ibm_chip_id(dn);\n\tif (chip_id < 0) {\n\t\tpr_err(\"ibm,chip-id missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(dn, \"ibm,842-coprocessor-type\", &ct)) {\n\t\tpr_err(\"ibm,842-coprocessor-type missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(dn, \"ibm,842-coprocessor-instance\", &ci)) {\n\t\tpr_err(\"ibm,842-coprocessor-instance missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcoproc = kzalloc(sizeof(*coproc), GFP_KERNEL);\n\tif (!coproc)\n\t\treturn -ENOMEM;\n\n\tcoproc->ct = ct;\n\tcoproc->ci = ci;\n\tnx_add_coprocs_list(coproc, chip_id);\n\n\tpr_info(\"coprocessor found on chip %d, CT %d CI %d\\n\", chip_id, ct, ci);\n\n\tif (!nx842_ct)\n\t\tnx842_ct = ct;\n\telse if (nx842_ct != ct)\n\t\tpr_err(\"NX842 chip %d, CT %d != first found CT %d\\n\",\n\t\t       chip_id, ct, nx842_ct);\n\n\treturn 0;\n}\n\nstatic void nx_delete_coprocs(void)\n{\n\tstruct nx_coproc *coproc, *n;\n\tstruct vas_window *txwin;\n\tint i;\n\n\t \n\tfor_each_possible_cpu(i) {\n\t\ttxwin = per_cpu(cpu_txwin, i);\n\t\tif (txwin)\n\t\t\tvas_win_close(txwin);\n\n\t\tper_cpu(cpu_txwin, i) = NULL;\n\t}\n\n\tlist_for_each_entry_safe(coproc, n, &nx_coprocs, list) {\n\t\tif (coproc->vas.rxwin)\n\t\t\tvas_win_close(coproc->vas.rxwin);\n\n\t\tlist_del(&coproc->list);\n\t\tkfree(coproc);\n\t}\n}\n\nstatic struct nx842_constraints nx842_powernv_constraints = {\n\t.alignment =\tDDE_BUFFER_ALIGN,\n\t.multiple =\tDDE_BUFFER_LAST_MULT,\n\t.minimum =\tDDE_BUFFER_LAST_MULT,\n\t.maximum =\t(DDL_LEN_MAX - 1) * PAGE_SIZE,\n};\n\nstatic struct nx842_driver nx842_powernv_driver = {\n\t.name =\t\tKBUILD_MODNAME,\n\t.owner =\tTHIS_MODULE,\n\t.workmem_size =\tsizeof(struct nx842_workmem),\n\t.constraints =\t&nx842_powernv_constraints,\n\t.compress =\tnx842_powernv_compress,\n\t.decompress =\tnx842_powernv_decompress,\n};\n\nstatic int nx842_powernv_crypto_init(struct crypto_tfm *tfm)\n{\n\treturn nx842_crypto_init(tfm, &nx842_powernv_driver);\n}\n\nstatic struct crypto_alg nx842_powernv_alg = {\n\t.cra_name\t\t= \"842\",\n\t.cra_driver_name\t= \"842-nx\",\n\t.cra_priority\t\t= 300,\n\t.cra_flags\t\t= CRYPTO_ALG_TYPE_COMPRESS,\n\t.cra_ctxsize\t\t= sizeof(struct nx842_crypto_ctx),\n\t.cra_module\t\t= THIS_MODULE,\n\t.cra_init\t\t= nx842_powernv_crypto_init,\n\t.cra_exit\t\t= nx842_crypto_exit,\n\t.cra_u\t\t\t= { .compress = {\n\t.coa_compress\t\t= nx842_crypto_compress,\n\t.coa_decompress\t\t= nx842_crypto_decompress } }\n};\n\nstatic __init int nx_compress_powernv_init(void)\n{\n\tstruct device_node *dn;\n\tint ret;\n\n\t \n\tBUILD_BUG_ON(WORKMEM_ALIGN % CRB_ALIGN);\n\tBUILD_BUG_ON(CRB_ALIGN % DDE_ALIGN);\n\tBUILD_BUG_ON(CRB_SIZE % DDE_ALIGN);\n\t \n\tBUILD_BUG_ON(PAGE_SIZE % DDE_BUFFER_ALIGN);\n\tBUILD_BUG_ON(DDE_BUFFER_ALIGN % DDE_BUFFER_SIZE_MULT);\n\tBUILD_BUG_ON(DDE_BUFFER_SIZE_MULT % DDE_BUFFER_LAST_MULT);\n\n\tfor_each_compatible_node(dn, NULL, \"ibm,power9-nx\") {\n\t\tret = nx_powernv_probe_vas(dn);\n\t\tif (ret) {\n\t\t\tnx_delete_coprocs();\n\t\t\tof_node_put(dn);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (list_empty(&nx_coprocs)) {\n\t\tfor_each_compatible_node(dn, NULL, \"ibm,power-nx\")\n\t\t\tnx842_powernv_probe(dn);\n\n\t\tif (!nx842_ct)\n\t\t\treturn -ENODEV;\n\n\t\tnx842_powernv_exec = nx842_exec_icswx;\n\t} else {\n\t\t \n\t\tret = vas_register_api_powernv(THIS_MODULE, VAS_COP_TYPE_GZIP,\n\t\t\t\t\t       \"nx-gzip\");\n\n\t\t \n\t\tif (!ret)\n\t\t\tret = nx_open_percpu_txwins();\n\n\t\tif (ret) {\n\t\t\tnx_delete_coprocs();\n\t\t\treturn ret;\n\t\t}\n\n\t\tnx842_powernv_exec = nx842_exec_vas;\n\t}\n\n\tret = crypto_register_alg(&nx842_powernv_alg);\n\tif (ret) {\n\t\tnx_delete_coprocs();\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(nx_compress_powernv_init);\n\nstatic void __exit nx_compress_powernv_exit(void)\n{\n\t \n\tif (!nx842_ct)\n\t\tvas_unregister_api_powernv();\n\n\tcrypto_unregister_alg(&nx842_powernv_alg);\n\n\tnx_delete_coprocs();\n}\nmodule_exit(nx_compress_powernv_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}