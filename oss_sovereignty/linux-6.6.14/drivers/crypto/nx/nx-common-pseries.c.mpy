{
  "module_name": "nx-common-pseries.c",
  "hash_id": "3c26cf511a1d1ad1465c1c645ed592c5530817097a0399dfbaf7625f6e273d57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/nx/nx-common-pseries.c",
  "human_readable_source": "\n \n\n#include <asm/vio.h>\n#include <asm/hvcall.h>\n#include <asm/vas.h>\n\n#include \"nx-842.h\"\n#include \"nx_csbcpb.h\"  \n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Robert Jennings <rcj@linux.vnet.ibm.com>\");\nMODULE_DESCRIPTION(\"842 H/W Compression driver for IBM Power processors\");\nMODULE_ALIAS_CRYPTO(\"842\");\nMODULE_ALIAS_CRYPTO(\"842-nx\");\n\n \nstruct hv_nx_cop_caps {\n\t__be64\tdescriptor;\n\t__be64\treq_max_processed_len;\t \n\t__be64\tmin_compress_len;\t \n\t__be64\tmin_decompress_len;\t \n} __packed __aligned(0x1000);\n\n \nstruct nx_cop_caps {\n\tu64\tdescriptor;\n\tu64\treq_max_processed_len;\t \n\tu64\tmin_compress_len;\t \n\tu64\tmin_decompress_len;\t \n};\n\nstatic u64 caps_feat;\nstatic struct nx_cop_caps nx_cop_caps;\n\nstatic struct nx842_constraints nx842_pseries_constraints = {\n\t.alignment =\tDDE_BUFFER_ALIGN,\n\t.multiple =\tDDE_BUFFER_LAST_MULT,\n\t.minimum =\tDDE_BUFFER_LAST_MULT,\n\t.maximum =\tPAGE_SIZE,  \n};\n\nstatic int check_constraints(unsigned long buf, unsigned int *len, bool in)\n{\n\tif (!IS_ALIGNED(buf, nx842_pseries_constraints.alignment)) {\n\t\tpr_debug(\"%s buffer 0x%lx not aligned to 0x%x\\n\",\n\t\t\t in ? \"input\" : \"output\", buf,\n\t\t\t nx842_pseries_constraints.alignment);\n\t\treturn -EINVAL;\n\t}\n\tif (*len % nx842_pseries_constraints.multiple) {\n\t\tpr_debug(\"%s buffer len 0x%x not multiple of 0x%x\\n\",\n\t\t\t in ? \"input\" : \"output\", *len,\n\t\t\t nx842_pseries_constraints.multiple);\n\t\tif (in)\n\t\t\treturn -EINVAL;\n\t\t*len = round_down(*len, nx842_pseries_constraints.multiple);\n\t}\n\tif (*len < nx842_pseries_constraints.minimum) {\n\t\tpr_debug(\"%s buffer len 0x%x under minimum 0x%x\\n\",\n\t\t\t in ? \"input\" : \"output\", *len,\n\t\t\t nx842_pseries_constraints.minimum);\n\t\treturn -EINVAL;\n\t}\n\tif (*len > nx842_pseries_constraints.maximum) {\n\t\tpr_debug(\"%s buffer len 0x%x over maximum 0x%x\\n\",\n\t\t\t in ? \"input\" : \"output\", *len,\n\t\t\t nx842_pseries_constraints.maximum);\n\t\tif (in)\n\t\t\treturn -EINVAL;\n\t\t*len = nx842_pseries_constraints.maximum;\n\t}\n\treturn 0;\n}\n\n \n#define WORKMEM_ALIGN\t(256)\n\nstruct nx842_workmem {\n\t \n\tchar slin[4096];\n\tchar slout[4096];\n\t \n\tstruct nx_csbcpb csbcpb;\n\n\tchar padding[WORKMEM_ALIGN];\n} __aligned(WORKMEM_ALIGN);\n\n \n \n#define NX842_CSBCBP_VALID_CHK(x) (x & BIT_MASK(7))\n\n \n#define NX842_CSBCPB_CE0(x)\t(x & BIT_MASK(7))\n#define NX842_CSBCPB_CE1(x)\t(x & BIT_MASK(6))\n#define NX842_CSBCPB_CE2(x)\t(x & BIT_MASK(5))\n\n \n#define NX842_HW_PAGE_SIZE\t(4096)\n#define NX842_HW_PAGE_MASK\t(~(NX842_HW_PAGE_SIZE-1))\n\nstruct ibm_nx842_counters {\n\tatomic64_t comp_complete;\n\tatomic64_t comp_failed;\n\tatomic64_t decomp_complete;\n\tatomic64_t decomp_failed;\n\tatomic64_t swdecomp;\n\tatomic64_t comp_times[32];\n\tatomic64_t decomp_times[32];\n};\n\nstruct nx842_devdata {\n\tstruct vio_dev *vdev;\n\tstruct device *dev;\n\tstruct ibm_nx842_counters *counters;\n\tunsigned int max_sg_len;\n\tunsigned int max_sync_size;\n\tunsigned int max_sync_sg;\n};\n\nstatic struct nx842_devdata __rcu *devdata;\nstatic DEFINE_SPINLOCK(devdata_mutex);\n\n#define NX842_COUNTER_INC(_x) \\\nstatic inline void nx842_inc_##_x( \\\n\tconst struct nx842_devdata *dev) { \\\n\tif (dev) \\\n\t\tatomic64_inc(&dev->counters->_x); \\\n}\nNX842_COUNTER_INC(comp_complete);\nNX842_COUNTER_INC(comp_failed);\nNX842_COUNTER_INC(decomp_complete);\nNX842_COUNTER_INC(decomp_failed);\nNX842_COUNTER_INC(swdecomp);\n\n#define NX842_HIST_SLOTS 16\n\nstatic void ibm_nx842_incr_hist(atomic64_t *times, unsigned int time)\n{\n\tint bucket = fls(time);\n\n\tif (bucket)\n\t\tbucket = min((NX842_HIST_SLOTS - 1), bucket - 1);\n\n\tatomic64_inc(&times[bucket]);\n}\n\n \n#define NX842_OP_COMPRESS\t0x0\n#define NX842_OP_CRC\t\t0x1\n#define NX842_OP_DECOMPRESS\t0x2\n#define NX842_OP_COMPRESS_CRC   (NX842_OP_COMPRESS | NX842_OP_CRC)\n#define NX842_OP_DECOMPRESS_CRC (NX842_OP_DECOMPRESS | NX842_OP_CRC)\n#define NX842_OP_ASYNC\t\t(1<<23)\n#define NX842_OP_NOTIFY\t\t(1<<22)\n#define NX842_OP_NOTIFY_INT(x)\t((x & 0xff)<<8)\n\nstatic unsigned long nx842_get_desired_dma(struct vio_dev *viodev)\n{\n\t \n\treturn 0;\n}\n\nstruct nx842_slentry {\n\t__be64 ptr;  \n\t__be64 len;\n};\n\n \nstruct nx842_scatterlist {\n\tint entry_nr;  \n\tstruct nx842_slentry *entries;  \n};\n\n \nstatic inline unsigned long nx842_get_scatterlist_size(\n\t\t\t\tstruct nx842_scatterlist *sl)\n{\n\treturn sl->entry_nr * sizeof(struct nx842_slentry);\n}\n\nstatic int nx842_build_scatterlist(unsigned long buf, int len,\n\t\t\tstruct nx842_scatterlist *sl)\n{\n\tunsigned long entrylen;\n\tstruct nx842_slentry *entry;\n\n\tsl->entry_nr = 0;\n\n\tentry = sl->entries;\n\twhile (len) {\n\t\tentry->ptr = cpu_to_be64(nx842_get_pa((void *)buf));\n\t\tentrylen = min_t(int, len,\n\t\t\t\t LEN_ON_SIZE(buf, NX842_HW_PAGE_SIZE));\n\t\tentry->len = cpu_to_be64(entrylen);\n\n\t\tlen -= entrylen;\n\t\tbuf += entrylen;\n\n\t\tsl->entry_nr++;\n\t\tentry++;\n\t}\n\n\treturn 0;\n}\n\nstatic int nx842_validate_result(struct device *dev,\n\tstruct cop_status_block *csb)\n{\n\t \n\tif (!NX842_CSBCBP_VALID_CHK(csb->valid)) {\n\t\tdev_err(dev, \"%s: cspcbp not valid upon completion.\\n\",\n\t\t\t\t__func__);\n\t\tdev_dbg(dev, \"valid:0x%02x cs:0x%02x cc:0x%02x ce:0x%02x\\n\",\n\t\t\t\tcsb->valid,\n\t\t\t\tcsb->crb_seq_number,\n\t\t\t\tcsb->completion_code,\n\t\t\t\tcsb->completion_extension);\n\t\tdev_dbg(dev, \"processed_bytes:%d address:0x%016lx\\n\",\n\t\t\t\tbe32_to_cpu(csb->processed_byte_count),\n\t\t\t\t(unsigned long)be64_to_cpu(csb->address));\n\t\treturn -EIO;\n\t}\n\n\t \n\tswitch (csb->completion_code) {\n\tcase 0:\t \n\t\tbreak;\n\tcase 64:  \n\t\tdev_dbg(dev, \"%s: output size larger than input size\\n\",\n\t\t\t\t\t__func__);\n\t\tbreak;\n\tcase 13:  \n\t\tdev_dbg(dev, \"%s: Out of space in output buffer\\n\",\n\t\t\t\t\t__func__);\n\t\treturn -ENOSPC;\n\tcase 65:  \n\t\tdev_dbg(dev, \"%s: CRC mismatch for decompression\\n\",\n\t\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\tcase 66:  \n\tcase 67:  \n\t\tdev_dbg(dev, \"%s: Bad data for decompression (code:%d)\\n\",\n\t\t\t\t\t__func__, csb->completion_code);\n\t\treturn -EINVAL;\n\tdefault:\n\t\tdev_dbg(dev, \"%s: Unspecified error (code:%d)\\n\",\n\t\t\t\t\t__func__, csb->completion_code);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (!NX842_CSBCPB_CE2(csb->completion_extension)) {\n\t\tdev_err(dev, \"%s: No error returned by hardware, but \"\n\t\t\t\t\"data returned is unusable, contact support.\\n\"\n\t\t\t\t\"(Additional info: csbcbp->processed bytes \"\n\t\t\t\t\"does not specify processed bytes for the \"\n\t\t\t\t\"target buffer.)\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int nx842_pseries_compress(const unsigned char *in, unsigned int inlen,\n\t\t\t\t  unsigned char *out, unsigned int *outlen,\n\t\t\t\t  void *wmem)\n{\n\tstruct nx842_devdata *local_devdata;\n\tstruct device *dev = NULL;\n\tstruct nx842_workmem *workmem;\n\tstruct nx842_scatterlist slin, slout;\n\tstruct nx_csbcpb *csbcpb;\n\tint ret = 0;\n\tunsigned long inbuf, outbuf;\n\tstruct vio_pfo_op op = {\n\t\t.done = NULL,\n\t\t.handle = 0,\n\t\t.timeout = 0,\n\t};\n\tunsigned long start = get_tb();\n\n\tinbuf = (unsigned long)in;\n\tif (check_constraints(inbuf, &inlen, true))\n\t\treturn -EINVAL;\n\n\toutbuf = (unsigned long)out;\n\tif (check_constraints(outbuf, outlen, false))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tlocal_devdata = rcu_dereference(devdata);\n\tif (!local_devdata || !local_devdata->dev) {\n\t\trcu_read_unlock();\n\t\treturn -ENODEV;\n\t}\n\tdev = local_devdata->dev;\n\n\t \n\tworkmem = PTR_ALIGN(wmem, WORKMEM_ALIGN);\n\tslin.entries = (struct nx842_slentry *)workmem->slin;\n\tslout.entries = (struct nx842_slentry *)workmem->slout;\n\n\t \n\top.flags = NX842_OP_COMPRESS_CRC;\n\tcsbcpb = &workmem->csbcpb;\n\tmemset(csbcpb, 0, sizeof(*csbcpb));\n\top.csbcpb = nx842_get_pa(csbcpb);\n\n\tif ((inbuf & NX842_HW_PAGE_MASK) ==\n\t    ((inbuf + inlen - 1) & NX842_HW_PAGE_MASK)) {\n\t\t \n\t\top.in = nx842_get_pa((void *)inbuf);\n\t\top.inlen = inlen;\n\t} else {\n\t\t \n\t\tnx842_build_scatterlist(inbuf, inlen, &slin);\n\t\top.in = nx842_get_pa(slin.entries);\n\t\top.inlen = -nx842_get_scatterlist_size(&slin);\n\t}\n\n\tif ((outbuf & NX842_HW_PAGE_MASK) ==\n\t    ((outbuf + *outlen - 1) & NX842_HW_PAGE_MASK)) {\n\t\t \n\t\top.out = nx842_get_pa((void *)outbuf);\n\t\top.outlen = *outlen;\n\t} else {\n\t\t \n\t\tnx842_build_scatterlist(outbuf, *outlen, &slout);\n\t\top.out = nx842_get_pa(slout.entries);\n\t\top.outlen = -nx842_get_scatterlist_size(&slout);\n\t}\n\n\tdev_dbg(dev, \"%s: op.in %lx op.inlen %ld op.out %lx op.outlen %ld\\n\",\n\t\t__func__, (unsigned long)op.in, (long)op.inlen,\n\t\t(unsigned long)op.out, (long)op.outlen);\n\n\t \n\tret = vio_h_cop_sync(local_devdata->vdev, &op);\n\n\t \n\tif (ret) {\n\t\tdev_dbg(dev, \"%s: vio_h_cop_sync error (ret=%d, hret=%ld)\\n\",\n\t\t\t__func__, ret, op.hcall_err);\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\t \n\tret = nx842_validate_result(dev, &csbcpb->csb);\n\tif (ret)\n\t\tgoto unlock;\n\n\t*outlen = be32_to_cpu(csbcpb->csb.processed_byte_count);\n\tdev_dbg(dev, \"%s: processed_bytes=%d\\n\", __func__, *outlen);\n\nunlock:\n\tif (ret)\n\t\tnx842_inc_comp_failed(local_devdata);\n\telse {\n\t\tnx842_inc_comp_complete(local_devdata);\n\t\tibm_nx842_incr_hist(local_devdata->counters->comp_times,\n\t\t\t(get_tb() - start) / tb_ticks_per_usec);\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic int nx842_pseries_decompress(const unsigned char *in, unsigned int inlen,\n\t\t\t\t    unsigned char *out, unsigned int *outlen,\n\t\t\t\t    void *wmem)\n{\n\tstruct nx842_devdata *local_devdata;\n\tstruct device *dev = NULL;\n\tstruct nx842_workmem *workmem;\n\tstruct nx842_scatterlist slin, slout;\n\tstruct nx_csbcpb *csbcpb;\n\tint ret = 0;\n\tunsigned long inbuf, outbuf;\n\tstruct vio_pfo_op op = {\n\t\t.done = NULL,\n\t\t.handle = 0,\n\t\t.timeout = 0,\n\t};\n\tunsigned long start = get_tb();\n\n\t \n\tinbuf = (unsigned long)in;\n\tif (check_constraints(inbuf, &inlen, true))\n\t\treturn -EINVAL;\n\n\toutbuf = (unsigned long)out;\n\tif (check_constraints(outbuf, outlen, false))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tlocal_devdata = rcu_dereference(devdata);\n\tif (!local_devdata || !local_devdata->dev) {\n\t\trcu_read_unlock();\n\t\treturn -ENODEV;\n\t}\n\tdev = local_devdata->dev;\n\n\tworkmem = PTR_ALIGN(wmem, WORKMEM_ALIGN);\n\n\t \n\tslin.entries = (struct nx842_slentry *)workmem->slin;\n\tslout.entries = (struct nx842_slentry *)workmem->slout;\n\n\t \n\top.flags = NX842_OP_DECOMPRESS_CRC;\n\tcsbcpb = &workmem->csbcpb;\n\tmemset(csbcpb, 0, sizeof(*csbcpb));\n\top.csbcpb = nx842_get_pa(csbcpb);\n\n\tif ((inbuf & NX842_HW_PAGE_MASK) ==\n\t    ((inbuf + inlen - 1) & NX842_HW_PAGE_MASK)) {\n\t\t \n\t\top.in = nx842_get_pa((void *)inbuf);\n\t\top.inlen = inlen;\n\t} else {\n\t\t \n\t\tnx842_build_scatterlist(inbuf, inlen, &slin);\n\t\top.in = nx842_get_pa(slin.entries);\n\t\top.inlen = -nx842_get_scatterlist_size(&slin);\n\t}\n\n\tif ((outbuf & NX842_HW_PAGE_MASK) ==\n\t    ((outbuf + *outlen - 1) & NX842_HW_PAGE_MASK)) {\n\t\t \n\t\top.out = nx842_get_pa((void *)outbuf);\n\t\top.outlen = *outlen;\n\t} else {\n\t\t \n\t\tnx842_build_scatterlist(outbuf, *outlen, &slout);\n\t\top.out = nx842_get_pa(slout.entries);\n\t\top.outlen = -nx842_get_scatterlist_size(&slout);\n\t}\n\n\tdev_dbg(dev, \"%s: op.in %lx op.inlen %ld op.out %lx op.outlen %ld\\n\",\n\t\t__func__, (unsigned long)op.in, (long)op.inlen,\n\t\t(unsigned long)op.out, (long)op.outlen);\n\n\t \n\tret = vio_h_cop_sync(local_devdata->vdev, &op);\n\n\t \n\tif (ret) {\n\t\tdev_dbg(dev, \"%s: vio_h_cop_sync error (ret=%d, hret=%ld)\\n\",\n\t\t\t__func__, ret, op.hcall_err);\n\t\tgoto unlock;\n\t}\n\n\t \n\tret = nx842_validate_result(dev, &csbcpb->csb);\n\tif (ret)\n\t\tgoto unlock;\n\n\t*outlen = be32_to_cpu(csbcpb->csb.processed_byte_count);\n\nunlock:\n\tif (ret)\n\t\t \n\t\tnx842_inc_decomp_failed(local_devdata);\n\telse {\n\t\tnx842_inc_decomp_complete(local_devdata);\n\t\tibm_nx842_incr_hist(local_devdata->counters->decomp_times,\n\t\t\t(get_tb() - start) / tb_ticks_per_usec);\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nstatic int nx842_OF_set_defaults(struct nx842_devdata *devdata)\n{\n\tif (devdata) {\n\t\tdevdata->max_sync_size = 0;\n\t\tdevdata->max_sync_sg = 0;\n\t\tdevdata->max_sg_len = 0;\n\t\treturn 0;\n\t} else\n\t\treturn -ENOENT;\n}\n\n \nstatic int nx842_OF_upd_status(struct nx842_devdata *devdata,\n\t\t\t       struct property *prop)\n{\n\tconst char *status = (const char *)prop->value;\n\n\tif (!strncmp(status, \"okay\", (size_t)prop->length))\n\t\treturn 0;\n\tif (!strncmp(status, \"disabled\", (size_t)prop->length))\n\t\treturn -ENODEV;\n\tdev_info(devdata->dev, \"%s: unknown status '%s'\\n\", __func__, status);\n\n\treturn -EINVAL;\n}\n\n \nstatic int nx842_OF_upd_maxsglen(struct nx842_devdata *devdata,\n\t\t\t\t\tstruct property *prop) {\n\tint ret = 0;\n\tconst unsigned int maxsglen = of_read_number(prop->value, 1);\n\n\tif (prop->length != sizeof(maxsglen)) {\n\t\tdev_err(devdata->dev, \"%s: unexpected format for ibm,max-sg-len property\\n\", __func__);\n\t\tdev_dbg(devdata->dev, \"%s: ibm,max-sg-len is %d bytes long, expected %lu bytes\\n\", __func__,\n\t\t\t\tprop->length, sizeof(maxsglen));\n\t\tret = -EINVAL;\n\t} else {\n\t\tdevdata->max_sg_len = min_t(unsigned int,\n\t\t\t\t\t    maxsglen, NX842_HW_PAGE_SIZE);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int nx842_OF_upd_maxsyncop(struct nx842_devdata *devdata,\n\t\t\t\t\tstruct property *prop) {\n\tint ret = 0;\n\tunsigned int comp_data_limit, decomp_data_limit;\n\tunsigned int comp_sg_limit, decomp_sg_limit;\n\tconst struct maxsynccop_t {\n\t\t__be32 comp_elements;\n\t\t__be32 comp_data_limit;\n\t\t__be32 comp_sg_limit;\n\t\t__be32 decomp_elements;\n\t\t__be32 decomp_data_limit;\n\t\t__be32 decomp_sg_limit;\n\t} *maxsynccop;\n\n\tif (prop->length != sizeof(*maxsynccop)) {\n\t\tdev_err(devdata->dev, \"%s: unexpected format for ibm,max-sync-cop property\\n\", __func__);\n\t\tdev_dbg(devdata->dev, \"%s: ibm,max-sync-cop is %d bytes long, expected %lu bytes\\n\", __func__, prop->length,\n\t\t\t\tsizeof(*maxsynccop));\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmaxsynccop = (const struct maxsynccop_t *)prop->value;\n\tcomp_data_limit = be32_to_cpu(maxsynccop->comp_data_limit);\n\tcomp_sg_limit = be32_to_cpu(maxsynccop->comp_sg_limit);\n\tdecomp_data_limit = be32_to_cpu(maxsynccop->decomp_data_limit);\n\tdecomp_sg_limit = be32_to_cpu(maxsynccop->decomp_sg_limit);\n\n\t \n\tdevdata->max_sync_size = min(comp_data_limit, decomp_data_limit);\n\n\tdevdata->max_sync_size = min_t(unsigned int, devdata->max_sync_size,\n\t\t\t\t\t65536);\n\n\tif (devdata->max_sync_size < 4096) {\n\t\tdev_err(devdata->dev, \"%s: hardware max data size (%u) is \"\n\t\t\t\t\"less than the driver minimum, unable to use \"\n\t\t\t\t\"the hardware device\\n\",\n\t\t\t\t__func__, devdata->max_sync_size);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnx842_pseries_constraints.maximum = devdata->max_sync_size;\n\n\tdevdata->max_sync_sg = min(comp_sg_limit, decomp_sg_limit);\n\tif (devdata->max_sync_sg < 1) {\n\t\tdev_err(devdata->dev, \"%s: hardware max sg size (%u) is \"\n\t\t\t\t\"less than the driver minimum, unable to use \"\n\t\t\t\t\"the hardware device\\n\",\n\t\t\t\t__func__, devdata->max_sync_sg);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstatic int nx842_OF_upd(struct property *new_prop)\n{\n\tstruct nx842_devdata *old_devdata = NULL;\n\tstruct nx842_devdata *new_devdata = NULL;\n\tstruct device_node *of_node = NULL;\n\tstruct property *status = NULL;\n\tstruct property *maxsglen = NULL;\n\tstruct property *maxsyncop = NULL;\n\tint ret = 0;\n\tunsigned long flags;\n\n\tnew_devdata = kzalloc(sizeof(*new_devdata), GFP_NOFS);\n\tif (!new_devdata)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&devdata_mutex, flags);\n\told_devdata = rcu_dereference_check(devdata,\n\t\t\tlockdep_is_held(&devdata_mutex));\n\tif (old_devdata)\n\t\tof_node = old_devdata->dev->of_node;\n\n\tif (!old_devdata || !of_node) {\n\t\tpr_err(\"%s: device is not available\\n\", __func__);\n\t\tspin_unlock_irqrestore(&devdata_mutex, flags);\n\t\tkfree(new_devdata);\n\t\treturn -ENODEV;\n\t}\n\n\tmemcpy(new_devdata, old_devdata, sizeof(*old_devdata));\n\tnew_devdata->counters = old_devdata->counters;\n\n\t \n\tstatus = of_find_property(of_node, \"status\", NULL);\n\tmaxsglen = of_find_property(of_node, \"ibm,max-sg-len\", NULL);\n\tmaxsyncop = of_find_property(of_node, \"ibm,max-sync-cop\", NULL);\n\tif (!status || !maxsglen || !maxsyncop) {\n\t\tdev_err(old_devdata->dev, \"%s: Could not locate device properties\\n\", __func__);\n\t\tret = -EINVAL;\n\t\tgoto error_out;\n\t}\n\n\t \n\tif (new_prop && (strncmp(new_prop->name, \"status\", new_prop->length) ||\n\t\t         strncmp(new_prop->name, \"ibm,max-sg-len\", new_prop->length) ||\n\t\t         strncmp(new_prop->name, \"ibm,max-sync-cop\", new_prop->length)))\n\t\tgoto out;\n\n\t \n\tret = nx842_OF_upd_status(new_devdata, status);\n\tif (ret)\n\t\tgoto error_out;\n\n\tret = nx842_OF_upd_maxsglen(new_devdata, maxsglen);\n\tif (ret)\n\t\tgoto error_out;\n\n\tret = nx842_OF_upd_maxsyncop(new_devdata, maxsyncop);\n\tif (ret)\n\t\tgoto error_out;\n\nout:\n\tdev_info(old_devdata->dev, \"%s: max_sync_size new:%u old:%u\\n\",\n\t\t\t__func__, new_devdata->max_sync_size,\n\t\t\told_devdata->max_sync_size);\n\tdev_info(old_devdata->dev, \"%s: max_sync_sg new:%u old:%u\\n\",\n\t\t\t__func__, new_devdata->max_sync_sg,\n\t\t\told_devdata->max_sync_sg);\n\tdev_info(old_devdata->dev, \"%s: max_sg_len new:%u old:%u\\n\",\n\t\t\t__func__, new_devdata->max_sg_len,\n\t\t\told_devdata->max_sg_len);\n\n\trcu_assign_pointer(devdata, new_devdata);\n\tspin_unlock_irqrestore(&devdata_mutex, flags);\n\tsynchronize_rcu();\n\tdev_set_drvdata(new_devdata->dev, new_devdata);\n\tkfree(old_devdata);\n\treturn 0;\n\nerror_out:\n\tif (new_devdata) {\n\t\tdev_info(old_devdata->dev, \"%s: device disabled\\n\", __func__);\n\t\tnx842_OF_set_defaults(new_devdata);\n\t\trcu_assign_pointer(devdata, new_devdata);\n\t\tspin_unlock_irqrestore(&devdata_mutex, flags);\n\t\tsynchronize_rcu();\n\t\tdev_set_drvdata(new_devdata->dev, new_devdata);\n\t\tkfree(old_devdata);\n\t} else {\n\t\tdev_err(old_devdata->dev, \"%s: could not update driver from hardware\\n\", __func__);\n\t\tspin_unlock_irqrestore(&devdata_mutex, flags);\n\t}\n\n\tif (!ret)\n\t\tret = -EINVAL;\n\treturn ret;\n}\n\n \nstatic int nx842_OF_notifier(struct notifier_block *np, unsigned long action,\n\t\t\t     void *data)\n{\n\tstruct of_reconfig_data *upd = data;\n\tstruct nx842_devdata *local_devdata;\n\tstruct device_node *node = NULL;\n\n\trcu_read_lock();\n\tlocal_devdata = rcu_dereference(devdata);\n\tif (local_devdata)\n\t\tnode = local_devdata->dev->of_node;\n\n\tif (local_devdata &&\n\t\t\taction == OF_RECONFIG_UPDATE_PROPERTY &&\n\t\t\t!strcmp(upd->dn->name, node->name)) {\n\t\trcu_read_unlock();\n\t\tnx842_OF_upd(upd->prop);\n\t} else\n\t\trcu_read_unlock();\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block nx842_of_nb = {\n\t.notifier_call = nx842_OF_notifier,\n};\n\n#define nx842_counter_read(_name)\t\t\t\t\t\\\nstatic ssize_t nx842_##_name##_show(struct device *dev,\t\t\\\n\t\tstruct device_attribute *attr,\t\t\t\t\\\n\t\tchar *buf) {\t\t\t\t\t\t\\\n\tstruct nx842_devdata *local_devdata;\t\t\t\\\n\tint p = 0;\t\t\t\t\t\t\t\\\n\trcu_read_lock();\t\t\t\t\t\t\\\n\tlocal_devdata = rcu_dereference(devdata);\t\t\t\\\n\tif (local_devdata)\t\t\t\t\t\t\\\n\t\tp = snprintf(buf, PAGE_SIZE, \"%lld\\n\",\t\t\t\\\n\t\t       atomic64_read(&local_devdata->counters->_name));\t\\\n\trcu_read_unlock();\t\t\t\t\t\t\\\n\treturn p;\t\t\t\t\t\t\t\\\n}\n\n#define NX842DEV_COUNTER_ATTR_RO(_name)\t\t\t\t\t\\\n\tnx842_counter_read(_name);\t\t\t\t\t\\\n\tstatic struct device_attribute dev_attr_##_name = __ATTR(_name,\t\\\n\t\t\t\t\t\t0444,\t\t\t\\\n\t\t\t\t\t\tnx842_##_name##_show,\\\n\t\t\t\t\t\tNULL);\n\nNX842DEV_COUNTER_ATTR_RO(comp_complete);\nNX842DEV_COUNTER_ATTR_RO(comp_failed);\nNX842DEV_COUNTER_ATTR_RO(decomp_complete);\nNX842DEV_COUNTER_ATTR_RO(decomp_failed);\nNX842DEV_COUNTER_ATTR_RO(swdecomp);\n\nstatic ssize_t nx842_timehist_show(struct device *,\n\t\tstruct device_attribute *, char *);\n\nstatic struct device_attribute dev_attr_comp_times = __ATTR(comp_times, 0444,\n\t\tnx842_timehist_show, NULL);\nstatic struct device_attribute dev_attr_decomp_times = __ATTR(decomp_times,\n\t\t0444, nx842_timehist_show, NULL);\n\nstatic ssize_t nx842_timehist_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf) {\n\tchar *p = buf;\n\tstruct nx842_devdata *local_devdata;\n\tatomic64_t *times;\n\tint bytes_remain = PAGE_SIZE;\n\tint bytes;\n\tint i;\n\n\trcu_read_lock();\n\tlocal_devdata = rcu_dereference(devdata);\n\tif (!local_devdata) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tif (attr == &dev_attr_comp_times)\n\t\ttimes = local_devdata->counters->comp_times;\n\telse if (attr == &dev_attr_decomp_times)\n\t\ttimes = local_devdata->counters->decomp_times;\n\telse {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < (NX842_HIST_SLOTS - 2); i++) {\n\t\tbytes = snprintf(p, bytes_remain, \"%u-%uus:\\t%lld\\n\",\n\t\t\t       i ? (2<<(i-1)) : 0, (2<<i)-1,\n\t\t\t       atomic64_read(&times[i]));\n\t\tbytes_remain -= bytes;\n\t\tp += bytes;\n\t}\n\t \n\tbytes = snprintf(p, bytes_remain, \"%uus - :\\t%lld\\n\",\n\t\t\t2<<(NX842_HIST_SLOTS - 2),\n\t\t\tatomic64_read(&times[(NX842_HIST_SLOTS - 1)]));\n\tp += bytes;\n\n\trcu_read_unlock();\n\treturn p - buf;\n}\n\nstatic struct attribute *nx842_sysfs_entries[] = {\n\t&dev_attr_comp_complete.attr,\n\t&dev_attr_comp_failed.attr,\n\t&dev_attr_decomp_complete.attr,\n\t&dev_attr_decomp_failed.attr,\n\t&dev_attr_swdecomp.attr,\n\t&dev_attr_comp_times.attr,\n\t&dev_attr_decomp_times.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group nx842_attribute_group = {\n\t.name = NULL,\t\t \n\t.attrs = nx842_sysfs_entries,\n};\n\n#define\tnxcop_caps_read(_name)\t\t\t\t\t\t\\\nstatic ssize_t nxcop_##_name##_show(struct device *dev,\t\t\t\\\n\t\t\tstruct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%lld\\n\", nx_cop_caps._name);\t\t\\\n}\n\n#define NXCT_ATTR_RO(_name)\t\t\t\t\t\t\\\n\tnxcop_caps_read(_name);\t\t\t\t\t\t\\\n\tstatic struct device_attribute dev_attr_##_name = __ATTR(_name,\t\\\n\t\t\t\t\t\t0444,\t\t\t\\\n\t\t\t\t\t\tnxcop_##_name##_show,\t\\\n\t\t\t\t\t\tNULL);\n\nNXCT_ATTR_RO(req_max_processed_len);\nNXCT_ATTR_RO(min_compress_len);\nNXCT_ATTR_RO(min_decompress_len);\n\nstatic struct attribute *nxcop_caps_sysfs_entries[] = {\n\t&dev_attr_req_max_processed_len.attr,\n\t&dev_attr_min_compress_len.attr,\n\t&dev_attr_min_decompress_len.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group nxcop_caps_attr_group = {\n\t.name\t=\t\"nx_gzip_caps\",\n\t.attrs\t=\tnxcop_caps_sysfs_entries,\n};\n\nstatic struct nx842_driver nx842_pseries_driver = {\n\t.name =\t\tKBUILD_MODNAME,\n\t.owner =\tTHIS_MODULE,\n\t.workmem_size =\tsizeof(struct nx842_workmem),\n\t.constraints =\t&nx842_pseries_constraints,\n\t.compress =\tnx842_pseries_compress,\n\t.decompress =\tnx842_pseries_decompress,\n};\n\nstatic int nx842_pseries_crypto_init(struct crypto_tfm *tfm)\n{\n\treturn nx842_crypto_init(tfm, &nx842_pseries_driver);\n}\n\nstatic struct crypto_alg nx842_pseries_alg = {\n\t.cra_name\t\t= \"842\",\n\t.cra_driver_name\t= \"842-nx\",\n\t.cra_priority\t\t= 300,\n\t.cra_flags\t\t= CRYPTO_ALG_TYPE_COMPRESS,\n\t.cra_ctxsize\t\t= sizeof(struct nx842_crypto_ctx),\n\t.cra_module\t\t= THIS_MODULE,\n\t.cra_init\t\t= nx842_pseries_crypto_init,\n\t.cra_exit\t\t= nx842_crypto_exit,\n\t.cra_u\t\t\t= { .compress = {\n\t.coa_compress\t\t= nx842_crypto_compress,\n\t.coa_decompress\t\t= nx842_crypto_decompress } }\n};\n\nstatic int nx842_probe(struct vio_dev *viodev,\n\t\t       const struct vio_device_id *id)\n{\n\tstruct nx842_devdata *old_devdata, *new_devdata = NULL;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tnew_devdata = kzalloc(sizeof(*new_devdata), GFP_NOFS);\n\tif (!new_devdata)\n\t\treturn -ENOMEM;\n\n\tnew_devdata->counters = kzalloc(sizeof(*new_devdata->counters),\n\t\t\tGFP_NOFS);\n\tif (!new_devdata->counters) {\n\t\tkfree(new_devdata);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&devdata_mutex, flags);\n\told_devdata = rcu_dereference_check(devdata,\n\t\t\tlockdep_is_held(&devdata_mutex));\n\n\tif (old_devdata && old_devdata->vdev != NULL) {\n\t\tdev_err(&viodev->dev, \"%s: Attempt to register more than one instance of the hardware\\n\", __func__);\n\t\tret = -1;\n\t\tgoto error_unlock;\n\t}\n\n\tdev_set_drvdata(&viodev->dev, NULL);\n\n\tnew_devdata->vdev = viodev;\n\tnew_devdata->dev = &viodev->dev;\n\tnx842_OF_set_defaults(new_devdata);\n\n\trcu_assign_pointer(devdata, new_devdata);\n\tspin_unlock_irqrestore(&devdata_mutex, flags);\n\tsynchronize_rcu();\n\tkfree(old_devdata);\n\n\tof_reconfig_notifier_register(&nx842_of_nb);\n\n\tret = nx842_OF_upd(NULL);\n\tif (ret)\n\t\tgoto error;\n\n\tret = crypto_register_alg(&nx842_pseries_alg);\n\tif (ret) {\n\t\tdev_err(&viodev->dev, \"could not register comp alg: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\trcu_read_lock();\n\tdev_set_drvdata(&viodev->dev, rcu_dereference(devdata));\n\trcu_read_unlock();\n\n\tif (sysfs_create_group(&viodev->dev.kobj, &nx842_attribute_group)) {\n\t\tdev_err(&viodev->dev, \"could not create sysfs device attributes\\n\");\n\t\tret = -1;\n\t\tgoto error;\n\t}\n\n\tif (caps_feat) {\n\t\tif (sysfs_create_group(&viodev->dev.kobj,\n\t\t\t\t\t&nxcop_caps_attr_group)) {\n\t\t\tdev_err(&viodev->dev,\n\t\t\t\t\"Could not create sysfs NX capability entries\\n\");\n\t\t\tret = -1;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_unlock:\n\tspin_unlock_irqrestore(&devdata_mutex, flags);\n\tif (new_devdata)\n\t\tkfree(new_devdata->counters);\n\tkfree(new_devdata);\nerror:\n\treturn ret;\n}\n\nstatic void nx842_remove(struct vio_dev *viodev)\n{\n\tstruct nx842_devdata *old_devdata;\n\tunsigned long flags;\n\n\tpr_info(\"Removing IBM Power 842 compression device\\n\");\n\tsysfs_remove_group(&viodev->dev.kobj, &nx842_attribute_group);\n\n\tif (caps_feat)\n\t\tsysfs_remove_group(&viodev->dev.kobj, &nxcop_caps_attr_group);\n\n\tcrypto_unregister_alg(&nx842_pseries_alg);\n\n\tspin_lock_irqsave(&devdata_mutex, flags);\n\told_devdata = rcu_dereference_check(devdata,\n\t\t\tlockdep_is_held(&devdata_mutex));\n\tof_reconfig_notifier_unregister(&nx842_of_nb);\n\tRCU_INIT_POINTER(devdata, NULL);\n\tspin_unlock_irqrestore(&devdata_mutex, flags);\n\tsynchronize_rcu();\n\tdev_set_drvdata(&viodev->dev, NULL);\n\tif (old_devdata)\n\t\tkfree(old_devdata->counters);\n\tkfree(old_devdata);\n}\n\n \nstatic void __init nxcop_get_capabilities(void)\n{\n\tstruct hv_vas_all_caps *hv_caps;\n\tstruct hv_nx_cop_caps *hv_nxc;\n\tint rc;\n\n\thv_caps = kmalloc(sizeof(*hv_caps), GFP_KERNEL);\n\tif (!hv_caps)\n\t\treturn;\n\t \n\trc = h_query_vas_capabilities(H_QUERY_NX_CAPABILITIES, 0,\n\t\t\t\t\t  (u64)virt_to_phys(hv_caps));\n\tif (rc)\n\t\tgoto out;\n\n\tcaps_feat = be64_to_cpu(hv_caps->feat_type);\n\t \n\tif (caps_feat & VAS_NX_GZIP_FEAT_BIT) {\n\t\thv_nxc = kmalloc(sizeof(*hv_nxc), GFP_KERNEL);\n\t\tif (!hv_nxc)\n\t\t\tgoto out;\n\t\t \n\t\trc = h_query_vas_capabilities(H_QUERY_NX_CAPABILITIES,\n\t\t\t\t\t\t  VAS_NX_GZIP_FEAT,\n\t\t\t\t\t\t  (u64)virt_to_phys(hv_nxc));\n\t} else {\n\t\tpr_err(\"NX-GZIP feature is not available\\n\");\n\t\trc = -EINVAL;\n\t}\n\n\tif (!rc) {\n\t\tnx_cop_caps.descriptor = be64_to_cpu(hv_nxc->descriptor);\n\t\tnx_cop_caps.req_max_processed_len =\n\t\t\t\tbe64_to_cpu(hv_nxc->req_max_processed_len);\n\t\tnx_cop_caps.min_compress_len =\n\t\t\t\tbe64_to_cpu(hv_nxc->min_compress_len);\n\t\tnx_cop_caps.min_decompress_len =\n\t\t\t\tbe64_to_cpu(hv_nxc->min_decompress_len);\n\t} else {\n\t\tcaps_feat = 0;\n\t}\n\n\tkfree(hv_nxc);\nout:\n\tkfree(hv_caps);\n}\n\nstatic const struct vio_device_id nx842_vio_driver_ids[] = {\n\t{\"ibm,compression-v1\", \"ibm,compression\"},\n\t{\"\", \"\"},\n};\nMODULE_DEVICE_TABLE(vio, nx842_vio_driver_ids);\n\nstatic struct vio_driver nx842_vio_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = nx842_probe,\n\t.remove = nx842_remove,\n\t.get_desired_dma = nx842_get_desired_dma,\n\t.id_table = nx842_vio_driver_ids,\n};\n\nstatic int __init nx842_pseries_init(void)\n{\n\tstruct nx842_devdata *new_devdata;\n\tstruct device_node *np;\n\tint ret;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"ibm,compression\");\n\tif (!np)\n\t\treturn -ENODEV;\n\tof_node_put(np);\n\n\tRCU_INIT_POINTER(devdata, NULL);\n\tnew_devdata = kzalloc(sizeof(*new_devdata), GFP_KERNEL);\n\tif (!new_devdata)\n\t\treturn -ENOMEM;\n\n\tRCU_INIT_POINTER(devdata, new_devdata);\n\t \n\tnxcop_get_capabilities();\n\n\tret = vio_register_driver(&nx842_vio_driver);\n\tif (ret) {\n\t\tpr_err(\"Could not register VIO driver %d\\n\", ret);\n\n\t\tkfree(new_devdata);\n\t\treturn ret;\n\t}\n\n\tret = vas_register_api_pseries(THIS_MODULE, VAS_COP_TYPE_GZIP,\n\t\t\t\t       \"nx-gzip\");\n\n\tif (ret)\n\t\tpr_err(\"NX-GZIP is not supported. Returned=%d\\n\", ret);\n\n\treturn 0;\n}\n\nmodule_init(nx842_pseries_init);\n\nstatic void __exit nx842_pseries_exit(void)\n{\n\tstruct nx842_devdata *old_devdata;\n\tunsigned long flags;\n\n\tvas_unregister_api_pseries();\n\n\tcrypto_unregister_alg(&nx842_pseries_alg);\n\n\tspin_lock_irqsave(&devdata_mutex, flags);\n\told_devdata = rcu_dereference_check(devdata,\n\t\t\tlockdep_is_held(&devdata_mutex));\n\tRCU_INIT_POINTER(devdata, NULL);\n\tspin_unlock_irqrestore(&devdata_mutex, flags);\n\tsynchronize_rcu();\n\tif (old_devdata && old_devdata->dev)\n\t\tdev_set_drvdata(old_devdata->dev, NULL);\n\tkfree(old_devdata);\n\tvio_unregister_driver(&nx842_vio_driver);\n}\n\nmodule_exit(nx842_pseries_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}