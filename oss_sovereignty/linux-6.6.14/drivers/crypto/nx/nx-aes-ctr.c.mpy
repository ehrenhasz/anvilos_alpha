{
  "module_name": "nx-aes-ctr.c",
  "hash_id": "29df704c718d3fc380e6eab9f080bd05847795d79b3b1a43381cbc3124272a3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/nx/nx-aes-ctr.c",
  "human_readable_source": "\n \n\n#include <crypto/aes.h>\n#include <crypto/ctr.h>\n#include <crypto/algapi.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/crypto.h>\n#include <asm/vio.h>\n\n#include \"nx_csbcpb.h\"\n#include \"nx.h\"\n\n\nstatic int ctr_aes_nx_set_key(struct crypto_skcipher *tfm,\n\t\t\t      const u8               *in_key,\n\t\t\t      unsigned int            key_len)\n{\n\tstruct nx_crypto_ctx *nx_ctx = crypto_skcipher_ctx(tfm);\n\tstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\n\n\tnx_ctx_init(nx_ctx, HCOP_FC_AES);\n\n\tswitch (key_len) {\n\tcase AES_KEYSIZE_128:\n\t\tNX_CPB_SET_KEY_SIZE(csbcpb, NX_KS_AES_128);\n\t\tnx_ctx->ap = &nx_ctx->props[NX_PROPS_AES_128];\n\t\tbreak;\n\tcase AES_KEYSIZE_192:\n\t\tNX_CPB_SET_KEY_SIZE(csbcpb, NX_KS_AES_192);\n\t\tnx_ctx->ap = &nx_ctx->props[NX_PROPS_AES_192];\n\t\tbreak;\n\tcase AES_KEYSIZE_256:\n\t\tNX_CPB_SET_KEY_SIZE(csbcpb, NX_KS_AES_256);\n\t\tnx_ctx->ap = &nx_ctx->props[NX_PROPS_AES_256];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcsbcpb->cpb.hdr.mode = NX_MODE_AES_CTR;\n\tmemcpy(csbcpb->cpb.aes_ctr.key, in_key, key_len);\n\n\treturn 0;\n}\n\nstatic int ctr3686_aes_nx_set_key(struct crypto_skcipher *tfm,\n\t\t\t\t  const u8               *in_key,\n\t\t\t\t  unsigned int            key_len)\n{\n\tstruct nx_crypto_ctx *nx_ctx = crypto_skcipher_ctx(tfm);\n\n\tif (key_len < CTR_RFC3686_NONCE_SIZE)\n\t\treturn -EINVAL;\n\n\tmemcpy(nx_ctx->priv.ctr.nonce,\n\t       in_key + key_len - CTR_RFC3686_NONCE_SIZE,\n\t       CTR_RFC3686_NONCE_SIZE);\n\n\tkey_len -= CTR_RFC3686_NONCE_SIZE;\n\n\treturn ctr_aes_nx_set_key(tfm, in_key, key_len);\n}\n\nstatic int ctr_aes_nx_crypt(struct skcipher_request *req, u8 *iv)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct nx_crypto_ctx *nx_ctx = crypto_skcipher_ctx(tfm);\n\tstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\n\tunsigned long irq_flags;\n\tunsigned int processed = 0, to_process;\n\tint rc;\n\n\tspin_lock_irqsave(&nx_ctx->lock, irq_flags);\n\n\tdo {\n\t\tto_process = req->cryptlen - processed;\n\n\t\trc = nx_build_sg_lists(nx_ctx, iv, req->dst, req->src,\n\t\t\t\t       &to_process, processed,\n\t\t\t\t       csbcpb->cpb.aes_ctr.iv);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tif (!nx_ctx->op.inlen || !nx_ctx->op.outlen) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = nx_hcall_sync(nx_ctx, &nx_ctx->op,\n\t\t\t\t   req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tmemcpy(iv, csbcpb->cpb.aes_cbc.cv, AES_BLOCK_SIZE);\n\n\t\tatomic_inc(&(nx_ctx->stats->aes_ops));\n\t\tatomic64_add(be32_to_cpu(csbcpb->csb.processed_byte_count),\n\t\t\t     &(nx_ctx->stats->aes_bytes));\n\n\t\tprocessed += to_process;\n\t} while (processed < req->cryptlen);\nout:\n\tspin_unlock_irqrestore(&nx_ctx->lock, irq_flags);\n\treturn rc;\n}\n\nstatic int ctr3686_aes_nx_crypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct nx_crypto_ctx *nx_ctx = crypto_skcipher_ctx(tfm);\n\tu8 iv[16];\n\n\tmemcpy(iv, nx_ctx->priv.ctr.nonce, CTR_RFC3686_NONCE_SIZE);\n\tmemcpy(iv + CTR_RFC3686_NONCE_SIZE, req->iv, CTR_RFC3686_IV_SIZE);\n\tiv[12] = iv[13] = iv[14] = 0;\n\tiv[15] = 1;\n\n\treturn ctr_aes_nx_crypt(req, iv);\n}\n\nstruct skcipher_alg nx_ctr3686_aes_alg = {\n\t.base.cra_name\t\t= \"rfc3686(ctr(aes))\",\n\t.base.cra_driver_name\t= \"rfc3686-ctr-aes-nx\",\n\t.base.cra_priority\t= 300,\n\t.base.cra_blocksize\t= 1,\n\t.base.cra_ctxsize\t= sizeof(struct nx_crypto_ctx),\n\t.base.cra_module\t= THIS_MODULE,\n\t.init\t\t\t= nx_crypto_ctx_aes_ctr_init,\n\t.exit\t\t\t= nx_crypto_ctx_skcipher_exit,\n\t.min_keysize\t\t= AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,\n\t.max_keysize\t\t= AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,\n\t.ivsize\t\t\t= CTR_RFC3686_IV_SIZE,\n\t.setkey\t\t\t= ctr3686_aes_nx_set_key,\n\t.encrypt\t\t= ctr3686_aes_nx_crypt,\n\t.decrypt\t\t= ctr3686_aes_nx_crypt,\n\t.chunksize\t\t= AES_BLOCK_SIZE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}