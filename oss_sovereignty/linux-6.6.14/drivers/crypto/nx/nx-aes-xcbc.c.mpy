{
  "module_name": "nx-aes-xcbc.c",
  "hash_id": "12b2ebd1d27a75b3abddbbc5d8a27cd9985e2f0633ffa0943b7ffaa0a6b8cafa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/nx/nx-aes-xcbc.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/hash.h>\n#include <crypto/aes.h>\n#include <crypto/algapi.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/crypto.h>\n#include <asm/vio.h>\n\n#include \"nx_csbcpb.h\"\n#include \"nx.h\"\n\n\nstruct xcbc_state {\n\tu8 state[AES_BLOCK_SIZE];\n\tunsigned int count;\n\tu8 buffer[AES_BLOCK_SIZE];\n};\n\nstatic int nx_xcbc_set_key(struct crypto_shash *desc,\n\t\t\t   const u8            *in_key,\n\t\t\t   unsigned int         key_len)\n{\n\tstruct nx_crypto_ctx *nx_ctx = crypto_shash_ctx(desc);\n\tstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\n\n\tswitch (key_len) {\n\tcase AES_KEYSIZE_128:\n\t\tnx_ctx->ap = &nx_ctx->props[NX_PROPS_AES_128];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(csbcpb->cpb.aes_xcbc.key, in_key, key_len);\n\n\treturn 0;\n}\n\n \nstatic int nx_xcbc_empty(struct shash_desc *desc, u8 *out)\n{\n\tstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&desc->tfm->base);\n\tstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\n\tstruct nx_sg *in_sg, *out_sg;\n\tu8 keys[2][AES_BLOCK_SIZE];\n\tu8 key[32];\n\tint rc = 0;\n\tint len;\n\n\t \n\tcsbcpb->cpb.hdr.mode = NX_MODE_AES_ECB;\n\tmemcpy(key, csbcpb->cpb.aes_xcbc.key, AES_BLOCK_SIZE);\n\tmemcpy(csbcpb->cpb.aes_ecb.key, key, AES_BLOCK_SIZE);\n\tNX_CPB_FDM(csbcpb) |= NX_FDM_ENDE_ENCRYPT;\n\n\t \n\tmemset(keys[0], 0x01, sizeof(keys[0]));\n\tmemset(keys[1], 0x03, sizeof(keys[1]));\n\n\tlen = sizeof(keys);\n\t \n\tin_sg = nx_build_sg_list(nx_ctx->in_sg, (u8 *) keys, &len,\n\t\t\t\t nx_ctx->ap->sglen);\n\n\tif (len != sizeof(keys))\n\t\treturn -EINVAL;\n\n\tout_sg = nx_build_sg_list(nx_ctx->out_sg, (u8 *) keys, &len,\n\t\t\t\t  nx_ctx->ap->sglen);\n\n\tif (len != sizeof(keys))\n\t\treturn -EINVAL;\n\n\tnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) * sizeof(struct nx_sg);\n\tnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\n\n\trc = nx_hcall_sync(nx_ctx, &nx_ctx->op, 0);\n\tif (rc)\n\t\tgoto out;\n\tatomic_inc(&(nx_ctx->stats->aes_ops));\n\n\t \n\tkeys[1][0] ^= 0x80;\n\n\tlen = sizeof(keys[1]);\n\n\t \n\tmemcpy(csbcpb->cpb.aes_ecb.key, keys[0], AES_BLOCK_SIZE);\n\tin_sg = nx_build_sg_list(nx_ctx->in_sg, (u8 *) keys[1], &len,\n\t\t\t\t nx_ctx->ap->sglen);\n\n\tif (len != sizeof(keys[1]))\n\t\treturn -EINVAL;\n\n\tlen = AES_BLOCK_SIZE;\n\tout_sg = nx_build_sg_list(nx_ctx->out_sg, out, &len,\n\t\t\t\t  nx_ctx->ap->sglen);\n\n\tif (len != AES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) * sizeof(struct nx_sg);\n\tnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\n\n\trc = nx_hcall_sync(nx_ctx, &nx_ctx->op, 0);\n\tif (rc)\n\t\tgoto out;\n\tatomic_inc(&(nx_ctx->stats->aes_ops));\n\nout:\n\t \n\tcsbcpb->cpb.hdr.mode = NX_MODE_AES_XCBC_MAC;\n\tmemcpy(csbcpb->cpb.aes_xcbc.key, key, AES_BLOCK_SIZE);\n\tNX_CPB_FDM(csbcpb) &= ~NX_FDM_ENDE_ENCRYPT;\n\n\treturn rc;\n}\n\nstatic int nx_crypto_ctx_aes_xcbc_init2(struct crypto_tfm *tfm)\n{\n\tstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(tfm);\n\tstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\n\tint err;\n\n\terr = nx_crypto_ctx_aes_xcbc_init(tfm);\n\tif (err)\n\t\treturn err;\n\n\tnx_ctx_init(nx_ctx, HCOP_FC_AES);\n\n\tNX_CPB_SET_KEY_SIZE(csbcpb, NX_KS_AES_128);\n\tcsbcpb->cpb.hdr.mode = NX_MODE_AES_XCBC_MAC;\n\n\treturn 0;\n}\n\nstatic int nx_xcbc_init(struct shash_desc *desc)\n{\n\tstruct xcbc_state *sctx = shash_desc_ctx(desc);\n\n\tmemset(sctx, 0, sizeof *sctx);\n\n\treturn 0;\n}\n\nstatic int nx_xcbc_update(struct shash_desc *desc,\n\t\t\t  const u8          *data,\n\t\t\t  unsigned int       len)\n{\n\tstruct xcbc_state *sctx = shash_desc_ctx(desc);\n\tstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&desc->tfm->base);\n\tstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\n\tstruct nx_sg *in_sg;\n\tstruct nx_sg *out_sg;\n\tu32 to_process = 0, leftover, total;\n\tunsigned int max_sg_len;\n\tunsigned long irq_flags;\n\tint rc = 0;\n\tint data_len;\n\n\tspin_lock_irqsave(&nx_ctx->lock, irq_flags);\n\n\n\ttotal = sctx->count + len;\n\n\t \n\tif (total <= AES_BLOCK_SIZE) {\n\t\tmemcpy(sctx->buffer + sctx->count, data, len);\n\t\tsctx->count += len;\n\t\tgoto out;\n\t}\n\n\tin_sg = nx_ctx->in_sg;\n\tmax_sg_len = min_t(u64, nx_driver.of.max_sg_len/sizeof(struct nx_sg),\n\t\t\t\tnx_ctx->ap->sglen);\n\tmax_sg_len = min_t(u64, max_sg_len,\n\t\t\t\tnx_ctx->ap->databytelen/NX_PAGE_SIZE);\n\n\tdata_len = AES_BLOCK_SIZE;\n\tout_sg = nx_build_sg_list(nx_ctx->out_sg, (u8 *)sctx->state,\n\t\t\t\t  &len, nx_ctx->ap->sglen);\n\n\tif (data_len != AES_BLOCK_SIZE) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\n\n\tdo {\n\t\tto_process = total - to_process;\n\t\tto_process = to_process & ~(AES_BLOCK_SIZE - 1);\n\n\t\tleftover = total - to_process;\n\n\t\t \n\t\tif (!leftover) {\n\t\t\tto_process -= AES_BLOCK_SIZE;\n\t\t\tleftover = AES_BLOCK_SIZE;\n\t\t}\n\n\t\tif (sctx->count) {\n\t\t\tdata_len = sctx->count;\n\t\t\tin_sg = nx_build_sg_list(nx_ctx->in_sg,\n\t\t\t\t\t\t(u8 *) sctx->buffer,\n\t\t\t\t\t\t&data_len,\n\t\t\t\t\t\tmax_sg_len);\n\t\t\tif (data_len != sctx->count) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tdata_len = to_process - sctx->count;\n\t\tin_sg = nx_build_sg_list(in_sg,\n\t\t\t\t\t(u8 *) data,\n\t\t\t\t\t&data_len,\n\t\t\t\t\tmax_sg_len);\n\n\t\tif (data_len != to_process - sctx->count) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) *\n\t\t\t\t\tsizeof(struct nx_sg);\n\n\t\t \n\t\tif (NX_CPB_FDM(csbcpb) & NX_FDM_CONTINUATION) {\n\t\t\tmemcpy(csbcpb->cpb.aes_xcbc.cv,\n\t\t\t\tcsbcpb->cpb.aes_xcbc.out_cv_mac,\n\t\t\t\tAES_BLOCK_SIZE);\n\t\t}\n\n\t\tNX_CPB_FDM(csbcpb) |= NX_FDM_INTERMEDIATE;\n\t\tif (!nx_ctx->op.inlen || !nx_ctx->op.outlen) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = nx_hcall_sync(nx_ctx, &nx_ctx->op, 0);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tatomic_inc(&(nx_ctx->stats->aes_ops));\n\n\t\t \n\t\tNX_CPB_FDM(csbcpb) |= NX_FDM_CONTINUATION;\n\n\t\ttotal -= to_process;\n\t\tdata += to_process - sctx->count;\n\t\tsctx->count = 0;\n\t\tin_sg = nx_ctx->in_sg;\n\t} while (leftover > AES_BLOCK_SIZE);\n\n\t \n\tmemcpy(sctx->buffer, data, leftover);\n\tsctx->count = leftover;\n\nout:\n\tspin_unlock_irqrestore(&nx_ctx->lock, irq_flags);\n\treturn rc;\n}\n\nstatic int nx_xcbc_final(struct shash_desc *desc, u8 *out)\n{\n\tstruct xcbc_state *sctx = shash_desc_ctx(desc);\n\tstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&desc->tfm->base);\n\tstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\n\tstruct nx_sg *in_sg, *out_sg;\n\tunsigned long irq_flags;\n\tint rc = 0;\n\tint len;\n\n\tspin_lock_irqsave(&nx_ctx->lock, irq_flags);\n\n\tif (NX_CPB_FDM(csbcpb) & NX_FDM_CONTINUATION) {\n\t\t \n\t\tmemcpy(csbcpb->cpb.aes_xcbc.cv,\n\t\t       csbcpb->cpb.aes_xcbc.out_cv_mac, AES_BLOCK_SIZE);\n\t} else if (sctx->count == 0) {\n\t\t \n\t\trc = nx_xcbc_empty(desc, out);\n\t\tgoto out;\n\t}\n\n\t \n\tNX_CPB_FDM(csbcpb) &= ~NX_FDM_INTERMEDIATE;\n\n\tlen = sctx->count;\n\tin_sg = nx_build_sg_list(nx_ctx->in_sg, (u8 *)sctx->buffer,\n\t\t\t\t &len, nx_ctx->ap->sglen);\n\n\tif (len != sctx->count) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = AES_BLOCK_SIZE;\n\tout_sg = nx_build_sg_list(nx_ctx->out_sg, out, &len,\n\t\t\t\t  nx_ctx->ap->sglen);\n\n\tif (len != AES_BLOCK_SIZE) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) * sizeof(struct nx_sg);\n\tnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\n\n\tif (!nx_ctx->op.outlen) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = nx_hcall_sync(nx_ctx, &nx_ctx->op, 0);\n\tif (rc)\n\t\tgoto out;\n\n\tatomic_inc(&(nx_ctx->stats->aes_ops));\n\n\tmemcpy(out, csbcpb->cpb.aes_xcbc.out_cv_mac, AES_BLOCK_SIZE);\nout:\n\tspin_unlock_irqrestore(&nx_ctx->lock, irq_flags);\n\treturn rc;\n}\n\nstruct shash_alg nx_shash_aes_xcbc_alg = {\n\t.digestsize = AES_BLOCK_SIZE,\n\t.init       = nx_xcbc_init,\n\t.update     = nx_xcbc_update,\n\t.final      = nx_xcbc_final,\n\t.setkey     = nx_xcbc_set_key,\n\t.descsize   = sizeof(struct xcbc_state),\n\t.statesize  = sizeof(struct xcbc_state),\n\t.base       = {\n\t\t.cra_name        = \"xcbc(aes)\",\n\t\t.cra_driver_name = \"xcbc-aes-nx\",\n\t\t.cra_priority    = 300,\n\t\t.cra_blocksize   = AES_BLOCK_SIZE,\n\t\t.cra_module      = THIS_MODULE,\n\t\t.cra_ctxsize     = sizeof(struct nx_crypto_ctx),\n\t\t.cra_init        = nx_crypto_ctx_aes_xcbc_init2,\n\t\t.cra_exit        = nx_crypto_ctx_exit,\n\t}\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}