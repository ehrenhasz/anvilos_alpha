{
  "module_name": "nx-aes-cbc.c",
  "hash_id": "3c3ef14764c8201c285a2cc07db4b114519c25ea67d177eea7ae4c75d5e10713",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/nx/nx-aes-cbc.c",
  "human_readable_source": "\n \n\n#include <crypto/aes.h>\n#include <crypto/algapi.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/crypto.h>\n#include <asm/vio.h>\n\n#include \"nx_csbcpb.h\"\n#include \"nx.h\"\n\n\nstatic int cbc_aes_nx_set_key(struct crypto_skcipher *tfm,\n\t\t\t      const u8               *in_key,\n\t\t\t      unsigned int            key_len)\n{\n\tstruct nx_crypto_ctx *nx_ctx = crypto_skcipher_ctx(tfm);\n\tstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\n\n\tnx_ctx_init(nx_ctx, HCOP_FC_AES);\n\n\tswitch (key_len) {\n\tcase AES_KEYSIZE_128:\n\t\tNX_CPB_SET_KEY_SIZE(csbcpb, NX_KS_AES_128);\n\t\tnx_ctx->ap = &nx_ctx->props[NX_PROPS_AES_128];\n\t\tbreak;\n\tcase AES_KEYSIZE_192:\n\t\tNX_CPB_SET_KEY_SIZE(csbcpb, NX_KS_AES_192);\n\t\tnx_ctx->ap = &nx_ctx->props[NX_PROPS_AES_192];\n\t\tbreak;\n\tcase AES_KEYSIZE_256:\n\t\tNX_CPB_SET_KEY_SIZE(csbcpb, NX_KS_AES_256);\n\t\tnx_ctx->ap = &nx_ctx->props[NX_PROPS_AES_256];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcsbcpb->cpb.hdr.mode = NX_MODE_AES_CBC;\n\tmemcpy(csbcpb->cpb.aes_cbc.key, in_key, key_len);\n\n\treturn 0;\n}\n\nstatic int cbc_aes_nx_crypt(struct skcipher_request *req,\n\t\t\t    int                      enc)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct nx_crypto_ctx *nx_ctx = crypto_skcipher_ctx(tfm);\n\tstruct nx_csbcpb *csbcpb = nx_ctx->csbcpb;\n\tunsigned long irq_flags;\n\tunsigned int processed = 0, to_process;\n\tint rc;\n\n\tspin_lock_irqsave(&nx_ctx->lock, irq_flags);\n\n\tif (enc)\n\t\tNX_CPB_FDM(csbcpb) |= NX_FDM_ENDE_ENCRYPT;\n\telse\n\t\tNX_CPB_FDM(csbcpb) &= ~NX_FDM_ENDE_ENCRYPT;\n\n\tdo {\n\t\tto_process = req->cryptlen - processed;\n\n\t\trc = nx_build_sg_lists(nx_ctx, req->iv, req->dst, req->src,\n\t\t\t\t       &to_process, processed,\n\t\t\t\t       csbcpb->cpb.aes_cbc.iv);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tif (!nx_ctx->op.inlen || !nx_ctx->op.outlen) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = nx_hcall_sync(nx_ctx, &nx_ctx->op,\n\t\t\t\t   req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tmemcpy(req->iv, csbcpb->cpb.aes_cbc.cv, AES_BLOCK_SIZE);\n\t\tatomic_inc(&(nx_ctx->stats->aes_ops));\n\t\tatomic64_add(be32_to_cpu(csbcpb->csb.processed_byte_count),\n\t\t\t     &(nx_ctx->stats->aes_bytes));\n\n\t\tprocessed += to_process;\n\t} while (processed < req->cryptlen);\nout:\n\tspin_unlock_irqrestore(&nx_ctx->lock, irq_flags);\n\treturn rc;\n}\n\nstatic int cbc_aes_nx_encrypt(struct skcipher_request *req)\n{\n\treturn cbc_aes_nx_crypt(req, 1);\n}\n\nstatic int cbc_aes_nx_decrypt(struct skcipher_request *req)\n{\n\treturn cbc_aes_nx_crypt(req, 0);\n}\n\nstruct skcipher_alg nx_cbc_aes_alg = {\n\t.base.cra_name\t\t= \"cbc(aes)\",\n\t.base.cra_driver_name\t= \"cbc-aes-nx\",\n\t.base.cra_priority\t= 300,\n\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t.base.cra_ctxsize\t= sizeof(struct nx_crypto_ctx),\n\t.base.cra_alignmask\t= 0xf,\n\t.base.cra_module\t= THIS_MODULE,\n\t.init\t\t\t= nx_crypto_ctx_aes_cbc_init,\n\t.exit\t\t\t= nx_crypto_ctx_skcipher_exit,\n\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t.setkey\t\t\t= cbc_aes_nx_set_key,\n\t.encrypt\t\t= cbc_aes_nx_encrypt,\n\t.decrypt\t\t= cbc_aes_nx_decrypt,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}