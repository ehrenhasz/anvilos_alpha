{
  "module_name": "atmel-tdes.c",
  "hash_id": "90cdd391dafbbc6a240c002e5cdec1ded38815624125cbdc80ef9e2bafcc7da7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/atmel-tdes.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/hw_random.h>\n#include <linux/platform_device.h>\n\n#include <linux/device.h>\n#include <linux/dmaengine.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-mapping.h>\n#include <linux/mod_devicetable.h>\n#include <linux/delay.h>\n#include <linux/crypto.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/algapi.h>\n#include <crypto/internal/des.h>\n#include <crypto/internal/skcipher.h>\n#include \"atmel-tdes-regs.h\"\n\n#define ATMEL_TDES_PRIORITY\t300\n\n \n \n#define TDES_FLAGS_ENCRYPT\tTDES_MR_CYPHER_ENC\n#define TDES_FLAGS_OPMODE_MASK\t(TDES_MR_OPMOD_MASK | TDES_MR_CFBS_MASK)\n#define TDES_FLAGS_ECB\t\tTDES_MR_OPMOD_ECB\n#define TDES_FLAGS_CBC\t\tTDES_MR_OPMOD_CBC\n#define TDES_FLAGS_OFB\t\tTDES_MR_OPMOD_OFB\n#define TDES_FLAGS_CFB64\t(TDES_MR_OPMOD_CFB | TDES_MR_CFBS_64b)\n#define TDES_FLAGS_CFB32\t(TDES_MR_OPMOD_CFB | TDES_MR_CFBS_32b)\n#define TDES_FLAGS_CFB16\t(TDES_MR_OPMOD_CFB | TDES_MR_CFBS_16b)\n#define TDES_FLAGS_CFB8\t\t(TDES_MR_OPMOD_CFB | TDES_MR_CFBS_8b)\n\n#define TDES_FLAGS_MODE_MASK\t(TDES_FLAGS_OPMODE_MASK | TDES_FLAGS_ENCRYPT)\n\n#define TDES_FLAGS_INIT\t\tBIT(3)\n#define TDES_FLAGS_FAST\t\tBIT(4)\n#define TDES_FLAGS_BUSY\t\tBIT(5)\n#define TDES_FLAGS_DMA\t\tBIT(6)\n\n#define ATMEL_TDES_QUEUE_LENGTH\t50\n\n#define CFB8_BLOCK_SIZE\t\t1\n#define CFB16_BLOCK_SIZE\t2\n#define CFB32_BLOCK_SIZE\t4\n\nstruct atmel_tdes_caps {\n\tbool\thas_dma;\n\tu32\t\thas_cfb_3keys;\n};\n\nstruct atmel_tdes_dev;\n\nstruct atmel_tdes_ctx {\n\tstruct atmel_tdes_dev *dd;\n\n\tint\t\tkeylen;\n\tu32\t\tkey[DES3_EDE_KEY_SIZE / sizeof(u32)];\n\tunsigned long\tflags;\n\n\tu16\t\tblock_size;\n};\n\nstruct atmel_tdes_reqctx {\n\tunsigned long mode;\n\tu8 lastc[DES_BLOCK_SIZE];\n};\n\nstruct atmel_tdes_dma {\n\tstruct dma_chan\t\t\t*chan;\n\tstruct dma_slave_config dma_conf;\n};\n\nstruct atmel_tdes_dev {\n\tstruct list_head\tlist;\n\tunsigned long\t\tphys_base;\n\tvoid __iomem\t\t*io_base;\n\n\tstruct atmel_tdes_ctx\t*ctx;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t\t*iclk;\n\tint\t\t\t\t\tirq;\n\n\tunsigned long\t\tflags;\n\n\tspinlock_t\t\tlock;\n\tstruct crypto_queue\tqueue;\n\n\tstruct tasklet_struct\tdone_task;\n\tstruct tasklet_struct\tqueue_task;\n\n\tstruct skcipher_request\t*req;\n\tsize_t\t\t\t\ttotal;\n\n\tstruct scatterlist\t*in_sg;\n\tunsigned int\t\tnb_in_sg;\n\tsize_t\t\t\t\tin_offset;\n\tstruct scatterlist\t*out_sg;\n\tunsigned int\t\tnb_out_sg;\n\tsize_t\t\t\t\tout_offset;\n\n\tsize_t\tbuflen;\n\tsize_t\tdma_size;\n\n\tvoid\t*buf_in;\n\tint\t\tdma_in;\n\tdma_addr_t\tdma_addr_in;\n\tstruct atmel_tdes_dma\tdma_lch_in;\n\n\tvoid\t*buf_out;\n\tint\t\tdma_out;\n\tdma_addr_t\tdma_addr_out;\n\tstruct atmel_tdes_dma\tdma_lch_out;\n\n\tstruct atmel_tdes_caps\tcaps;\n\n\tu32\thw_version;\n};\n\nstruct atmel_tdes_drv {\n\tstruct list_head\tdev_list;\n\tspinlock_t\t\tlock;\n};\n\nstatic struct atmel_tdes_drv atmel_tdes = {\n\t.dev_list = LIST_HEAD_INIT(atmel_tdes.dev_list),\n\t.lock = __SPIN_LOCK_UNLOCKED(atmel_tdes.lock),\n};\n\nstatic int atmel_tdes_sg_copy(struct scatterlist **sg, size_t *offset,\n\t\t\tvoid *buf, size_t buflen, size_t total, int out)\n{\n\tsize_t count, off = 0;\n\n\twhile (buflen && total) {\n\t\tcount = min((*sg)->length - *offset, total);\n\t\tcount = min(count, buflen);\n\n\t\tif (!count)\n\t\t\treturn off;\n\n\t\tscatterwalk_map_and_copy(buf + off, *sg, *offset, count, out);\n\n\t\toff += count;\n\t\tbuflen -= count;\n\t\t*offset += count;\n\t\ttotal -= count;\n\n\t\tif (*offset == (*sg)->length) {\n\t\t\t*sg = sg_next(*sg);\n\t\t\tif (*sg)\n\t\t\t\t*offset = 0;\n\t\t\telse\n\t\t\t\ttotal = 0;\n\t\t}\n\t}\n\n\treturn off;\n}\n\nstatic inline u32 atmel_tdes_read(struct atmel_tdes_dev *dd, u32 offset)\n{\n\treturn readl_relaxed(dd->io_base + offset);\n}\n\nstatic inline void atmel_tdes_write(struct atmel_tdes_dev *dd,\n\t\t\t\t\tu32 offset, u32 value)\n{\n\twritel_relaxed(value, dd->io_base + offset);\n}\n\nstatic void atmel_tdes_write_n(struct atmel_tdes_dev *dd, u32 offset,\n\t\t\t       const u32 *value, int count)\n{\n\tfor (; count--; value++, offset += 4)\n\t\tatmel_tdes_write(dd, offset, *value);\n}\n\nstatic struct atmel_tdes_dev *atmel_tdes_dev_alloc(void)\n{\n\tstruct atmel_tdes_dev *tdes_dd;\n\n\tspin_lock_bh(&atmel_tdes.lock);\n\t \n\ttdes_dd = list_first_entry_or_null(&atmel_tdes.dev_list,\n\t\t\t\t\t   struct atmel_tdes_dev, list);\n\tspin_unlock_bh(&atmel_tdes.lock);\n\treturn tdes_dd;\n}\n\nstatic int atmel_tdes_hw_init(struct atmel_tdes_dev *dd)\n{\n\tint err;\n\n\terr = clk_prepare_enable(dd->iclk);\n\tif (err)\n\t\treturn err;\n\n\tif (!(dd->flags & TDES_FLAGS_INIT)) {\n\t\tatmel_tdes_write(dd, TDES_CR, TDES_CR_SWRST);\n\t\tdd->flags |= TDES_FLAGS_INIT;\n\t}\n\n\treturn 0;\n}\n\nstatic inline unsigned int atmel_tdes_get_version(struct atmel_tdes_dev *dd)\n{\n\treturn atmel_tdes_read(dd, TDES_HW_VERSION) & 0x00000fff;\n}\n\nstatic int atmel_tdes_hw_version_init(struct atmel_tdes_dev *dd)\n{\n\tint err;\n\n\terr = atmel_tdes_hw_init(dd);\n\tif (err)\n\t\treturn err;\n\n\tdd->hw_version = atmel_tdes_get_version(dd);\n\n\tdev_info(dd->dev,\n\t\t\t\"version: 0x%x\\n\", dd->hw_version);\n\n\tclk_disable_unprepare(dd->iclk);\n\n\treturn 0;\n}\n\nstatic void atmel_tdes_dma_callback(void *data)\n{\n\tstruct atmel_tdes_dev *dd = data;\n\n\t \n\ttasklet_schedule(&dd->done_task);\n}\n\nstatic int atmel_tdes_write_ctrl(struct atmel_tdes_dev *dd)\n{\n\tint err;\n\tu32 valmr = TDES_MR_SMOD_PDC;\n\n\terr = atmel_tdes_hw_init(dd);\n\n\tif (err)\n\t\treturn err;\n\n\tif (!dd->caps.has_dma)\n\t\tatmel_tdes_write(dd, TDES_PTCR,\n\t\t\tTDES_PTCR_TXTDIS | TDES_PTCR_RXTDIS);\n\n\t \n\tif (dd->ctx->keylen > (DES_KEY_SIZE << 1)) {\n\t\tvalmr |= TDES_MR_KEYMOD_3KEY;\n\t\tvalmr |= TDES_MR_TDESMOD_TDES;\n\t} else if (dd->ctx->keylen > DES_KEY_SIZE) {\n\t\tvalmr |= TDES_MR_KEYMOD_2KEY;\n\t\tvalmr |= TDES_MR_TDESMOD_TDES;\n\t} else {\n\t\tvalmr |= TDES_MR_TDESMOD_DES;\n\t}\n\n\tvalmr |= dd->flags & TDES_FLAGS_MODE_MASK;\n\n\tatmel_tdes_write(dd, TDES_MR, valmr);\n\n\tatmel_tdes_write_n(dd, TDES_KEY1W1R, dd->ctx->key,\n\t\t\t\t\t\tdd->ctx->keylen >> 2);\n\n\tif (dd->req->iv && (valmr & TDES_MR_OPMOD_MASK) != TDES_MR_OPMOD_ECB)\n\t\tatmel_tdes_write_n(dd, TDES_IV1R, (void *)dd->req->iv, 2);\n\n\treturn 0;\n}\n\nstatic int atmel_tdes_crypt_pdc_stop(struct atmel_tdes_dev *dd)\n{\n\tint err = 0;\n\tsize_t count;\n\n\tatmel_tdes_write(dd, TDES_PTCR, TDES_PTCR_TXTDIS|TDES_PTCR_RXTDIS);\n\n\tif (dd->flags & TDES_FLAGS_FAST) {\n\t\tdma_unmap_sg(dd->dev, dd->out_sg, 1, DMA_FROM_DEVICE);\n\t\tdma_unmap_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);\n\t} else {\n\t\tdma_sync_single_for_device(dd->dev, dd->dma_addr_out,\n\t\t\t\t\t   dd->dma_size, DMA_FROM_DEVICE);\n\n\t\t \n\t\tcount = atmel_tdes_sg_copy(&dd->out_sg, &dd->out_offset,\n\t\t\t\tdd->buf_out, dd->buflen, dd->dma_size, 1);\n\t\tif (count != dd->dma_size) {\n\t\t\terr = -EINVAL;\n\t\t\tdev_dbg(dd->dev, \"not all data converted: %zu\\n\", count);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int atmel_tdes_buff_init(struct atmel_tdes_dev *dd)\n{\n\tint err = -ENOMEM;\n\n\tdd->buf_in = (void *)__get_free_pages(GFP_KERNEL, 0);\n\tdd->buf_out = (void *)__get_free_pages(GFP_KERNEL, 0);\n\tdd->buflen = PAGE_SIZE;\n\tdd->buflen &= ~(DES_BLOCK_SIZE - 1);\n\n\tif (!dd->buf_in || !dd->buf_out) {\n\t\tdev_dbg(dd->dev, \"unable to alloc pages.\\n\");\n\t\tgoto err_alloc;\n\t}\n\n\t \n\tdd->dma_addr_in = dma_map_single(dd->dev, dd->buf_in,\n\t\t\t\t\tdd->buflen, DMA_TO_DEVICE);\n\terr = dma_mapping_error(dd->dev, dd->dma_addr_in);\n\tif (err) {\n\t\tdev_dbg(dd->dev, \"dma %zd bytes error\\n\", dd->buflen);\n\t\tgoto err_map_in;\n\t}\n\n\tdd->dma_addr_out = dma_map_single(dd->dev, dd->buf_out,\n\t\t\t\t\tdd->buflen, DMA_FROM_DEVICE);\n\terr = dma_mapping_error(dd->dev, dd->dma_addr_out);\n\tif (err) {\n\t\tdev_dbg(dd->dev, \"dma %zd bytes error\\n\", dd->buflen);\n\t\tgoto err_map_out;\n\t}\n\n\treturn 0;\n\nerr_map_out:\n\tdma_unmap_single(dd->dev, dd->dma_addr_in, dd->buflen,\n\t\tDMA_TO_DEVICE);\nerr_map_in:\nerr_alloc:\n\tfree_page((unsigned long)dd->buf_out);\n\tfree_page((unsigned long)dd->buf_in);\n\treturn err;\n}\n\nstatic void atmel_tdes_buff_cleanup(struct atmel_tdes_dev *dd)\n{\n\tdma_unmap_single(dd->dev, dd->dma_addr_out, dd->buflen,\n\t\t\t DMA_FROM_DEVICE);\n\tdma_unmap_single(dd->dev, dd->dma_addr_in, dd->buflen,\n\t\tDMA_TO_DEVICE);\n\tfree_page((unsigned long)dd->buf_out);\n\tfree_page((unsigned long)dd->buf_in);\n}\n\nstatic int atmel_tdes_crypt_pdc(struct atmel_tdes_dev *dd,\n\t\t\t\tdma_addr_t dma_addr_in,\n\t\t\t\tdma_addr_t dma_addr_out, int length)\n{\n\tstruct atmel_tdes_reqctx *rctx = skcipher_request_ctx(dd->req);\n\tint len32;\n\n\tdd->dma_size = length;\n\n\tif (!(dd->flags & TDES_FLAGS_FAST)) {\n\t\tdma_sync_single_for_device(dd->dev, dma_addr_in, length,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t}\n\n\tswitch (rctx->mode & TDES_FLAGS_OPMODE_MASK) {\n\tcase TDES_FLAGS_CFB8:\n\t\tlen32 = DIV_ROUND_UP(length, sizeof(u8));\n\t\tbreak;\n\n\tcase TDES_FLAGS_CFB16:\n\t\tlen32 = DIV_ROUND_UP(length, sizeof(u16));\n\t\tbreak;\n\n\tdefault:\n\t\tlen32 = DIV_ROUND_UP(length, sizeof(u32));\n\t\tbreak;\n\t}\n\n\tatmel_tdes_write(dd, TDES_PTCR, TDES_PTCR_TXTDIS|TDES_PTCR_RXTDIS);\n\tatmel_tdes_write(dd, TDES_TPR, dma_addr_in);\n\tatmel_tdes_write(dd, TDES_TCR, len32);\n\tatmel_tdes_write(dd, TDES_RPR, dma_addr_out);\n\tatmel_tdes_write(dd, TDES_RCR, len32);\n\n\t \n\tatmel_tdes_write(dd, TDES_IER, TDES_INT_ENDRX);\n\n\t \n\tatmel_tdes_write(dd, TDES_PTCR, TDES_PTCR_TXTEN | TDES_PTCR_RXTEN);\n\n\treturn 0;\n}\n\nstatic int atmel_tdes_crypt_dma(struct atmel_tdes_dev *dd,\n\t\t\t\tdma_addr_t dma_addr_in,\n\t\t\t\tdma_addr_t dma_addr_out, int length)\n{\n\tstruct atmel_tdes_reqctx *rctx = skcipher_request_ctx(dd->req);\n\tstruct scatterlist sg[2];\n\tstruct dma_async_tx_descriptor\t*in_desc, *out_desc;\n\tenum dma_slave_buswidth addr_width;\n\n\tdd->dma_size = length;\n\n\tif (!(dd->flags & TDES_FLAGS_FAST)) {\n\t\tdma_sync_single_for_device(dd->dev, dma_addr_in, length,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t}\n\n\tswitch (rctx->mode & TDES_FLAGS_OPMODE_MASK) {\n\tcase TDES_FLAGS_CFB8:\n\t\taddr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\t\tbreak;\n\n\tcase TDES_FLAGS_CFB16:\n\t\taddr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tbreak;\n\n\tdefault:\n\t\taddr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tbreak;\n\t}\n\n\tdd->dma_lch_in.dma_conf.dst_addr_width = addr_width;\n\tdd->dma_lch_out.dma_conf.src_addr_width = addr_width;\n\n\tdmaengine_slave_config(dd->dma_lch_in.chan, &dd->dma_lch_in.dma_conf);\n\tdmaengine_slave_config(dd->dma_lch_out.chan, &dd->dma_lch_out.dma_conf);\n\n\tdd->flags |= TDES_FLAGS_DMA;\n\n\tsg_init_table(&sg[0], 1);\n\tsg_dma_address(&sg[0]) = dma_addr_in;\n\tsg_dma_len(&sg[0]) = length;\n\n\tsg_init_table(&sg[1], 1);\n\tsg_dma_address(&sg[1]) = dma_addr_out;\n\tsg_dma_len(&sg[1]) = length;\n\n\tin_desc = dmaengine_prep_slave_sg(dd->dma_lch_in.chan, &sg[0],\n\t\t\t\t1, DMA_MEM_TO_DEV,\n\t\t\t\tDMA_PREP_INTERRUPT  |  DMA_CTRL_ACK);\n\tif (!in_desc)\n\t\treturn -EINVAL;\n\n\tout_desc = dmaengine_prep_slave_sg(dd->dma_lch_out.chan, &sg[1],\n\t\t\t\t1, DMA_DEV_TO_MEM,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!out_desc)\n\t\treturn -EINVAL;\n\n\tout_desc->callback = atmel_tdes_dma_callback;\n\tout_desc->callback_param = dd;\n\n\tdmaengine_submit(out_desc);\n\tdma_async_issue_pending(dd->dma_lch_out.chan);\n\n\tdmaengine_submit(in_desc);\n\tdma_async_issue_pending(dd->dma_lch_in.chan);\n\n\treturn 0;\n}\n\nstatic int atmel_tdes_crypt_start(struct atmel_tdes_dev *dd)\n{\n\tint err, fast = 0, in, out;\n\tsize_t count;\n\tdma_addr_t addr_in, addr_out;\n\n\tif ((!dd->in_offset) && (!dd->out_offset)) {\n\t\t \n\t\tin = IS_ALIGNED((u32)dd->in_sg->offset, sizeof(u32)) &&\n\t\t\tIS_ALIGNED(dd->in_sg->length, dd->ctx->block_size);\n\t\tout = IS_ALIGNED((u32)dd->out_sg->offset, sizeof(u32)) &&\n\t\t\tIS_ALIGNED(dd->out_sg->length, dd->ctx->block_size);\n\t\tfast = in && out;\n\n\t\tif (sg_dma_len(dd->in_sg) != sg_dma_len(dd->out_sg))\n\t\t\tfast = 0;\n\t}\n\n\n\tif (fast)  {\n\t\tcount = min_t(size_t, dd->total, sg_dma_len(dd->in_sg));\n\t\tcount = min_t(size_t, count, sg_dma_len(dd->out_sg));\n\n\t\terr = dma_map_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);\n\t\tif (!err) {\n\t\t\tdev_dbg(dd->dev, \"dma_map_sg() error\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = dma_map_sg(dd->dev, dd->out_sg, 1,\n\t\t\t\tDMA_FROM_DEVICE);\n\t\tif (!err) {\n\t\t\tdev_dbg(dd->dev, \"dma_map_sg() error\\n\");\n\t\t\tdma_unmap_sg(dd->dev, dd->in_sg, 1,\n\t\t\t\tDMA_TO_DEVICE);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\taddr_in = sg_dma_address(dd->in_sg);\n\t\taddr_out = sg_dma_address(dd->out_sg);\n\n\t\tdd->flags |= TDES_FLAGS_FAST;\n\n\t} else {\n\t\t \n\t\tcount = atmel_tdes_sg_copy(&dd->in_sg, &dd->in_offset,\n\t\t\t\tdd->buf_in, dd->buflen, dd->total, 0);\n\n\t\taddr_in = dd->dma_addr_in;\n\t\taddr_out = dd->dma_addr_out;\n\n\t\tdd->flags &= ~TDES_FLAGS_FAST;\n\t}\n\n\tdd->total -= count;\n\n\tif (dd->caps.has_dma)\n\t\terr = atmel_tdes_crypt_dma(dd, addr_in, addr_out, count);\n\telse\n\t\terr = atmel_tdes_crypt_pdc(dd, addr_in, addr_out, count);\n\n\tif (err && (dd->flags & TDES_FLAGS_FAST)) {\n\t\tdma_unmap_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);\n\t\tdma_unmap_sg(dd->dev, dd->out_sg, 1, DMA_TO_DEVICE);\n\t}\n\n\treturn err;\n}\n\nstatic void\natmel_tdes_set_iv_as_last_ciphertext_block(struct atmel_tdes_dev *dd)\n{\n\tstruct skcipher_request *req = dd->req;\n\tstruct atmel_tdes_reqctx *rctx = skcipher_request_ctx(req);\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tunsigned int ivsize = crypto_skcipher_ivsize(skcipher);\n\n\tif (req->cryptlen < ivsize)\n\t\treturn;\n\n\tif (rctx->mode & TDES_FLAGS_ENCRYPT)\n\t\tscatterwalk_map_and_copy(req->iv, req->dst,\n\t\t\t\t\t req->cryptlen - ivsize, ivsize, 0);\n\telse\n\t\tmemcpy(req->iv, rctx->lastc, ivsize);\n\n}\n\nstatic void atmel_tdes_finish_req(struct atmel_tdes_dev *dd, int err)\n{\n\tstruct skcipher_request *req = dd->req;\n\tstruct atmel_tdes_reqctx *rctx = skcipher_request_ctx(req);\n\n\tclk_disable_unprepare(dd->iclk);\n\n\tdd->flags &= ~TDES_FLAGS_BUSY;\n\n\tif (!err && (rctx->mode & TDES_FLAGS_OPMODE_MASK) != TDES_FLAGS_ECB)\n\t\tatmel_tdes_set_iv_as_last_ciphertext_block(dd);\n\n\tskcipher_request_complete(req, err);\n}\n\nstatic int atmel_tdes_handle_queue(struct atmel_tdes_dev *dd,\n\t\t\t       struct skcipher_request *req)\n{\n\tstruct crypto_async_request *async_req, *backlog;\n\tstruct atmel_tdes_ctx *ctx;\n\tstruct atmel_tdes_reqctx *rctx;\n\tunsigned long flags;\n\tint err, ret = 0;\n\n\tspin_lock_irqsave(&dd->lock, flags);\n\tif (req)\n\t\tret = crypto_enqueue_request(&dd->queue, &req->base);\n\tif (dd->flags & TDES_FLAGS_BUSY) {\n\t\tspin_unlock_irqrestore(&dd->lock, flags);\n\t\treturn ret;\n\t}\n\tbacklog = crypto_get_backlog(&dd->queue);\n\tasync_req = crypto_dequeue_request(&dd->queue);\n\tif (async_req)\n\t\tdd->flags |= TDES_FLAGS_BUSY;\n\tspin_unlock_irqrestore(&dd->lock, flags);\n\n\tif (!async_req)\n\t\treturn ret;\n\n\tif (backlog)\n\t\tcrypto_request_complete(backlog, -EINPROGRESS);\n\n\treq = skcipher_request_cast(async_req);\n\n\t \n\tdd->req = req;\n\tdd->total = req->cryptlen;\n\tdd->in_offset = 0;\n\tdd->in_sg = req->src;\n\tdd->out_offset = 0;\n\tdd->out_sg = req->dst;\n\n\trctx = skcipher_request_ctx(req);\n\tctx = crypto_skcipher_ctx(crypto_skcipher_reqtfm(req));\n\trctx->mode &= TDES_FLAGS_MODE_MASK;\n\tdd->flags = (dd->flags & ~TDES_FLAGS_MODE_MASK) | rctx->mode;\n\tdd->ctx = ctx;\n\n\terr = atmel_tdes_write_ctrl(dd);\n\tif (!err)\n\t\terr = atmel_tdes_crypt_start(dd);\n\tif (err) {\n\t\t \n\t\tatmel_tdes_finish_req(dd, err);\n\t\ttasklet_schedule(&dd->queue_task);\n\t}\n\n\treturn ret;\n}\n\nstatic int atmel_tdes_crypt_dma_stop(struct atmel_tdes_dev *dd)\n{\n\tint err = -EINVAL;\n\tsize_t count;\n\n\tif (dd->flags & TDES_FLAGS_DMA) {\n\t\terr = 0;\n\t\tif  (dd->flags & TDES_FLAGS_FAST) {\n\t\t\tdma_unmap_sg(dd->dev, dd->out_sg, 1, DMA_FROM_DEVICE);\n\t\t\tdma_unmap_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);\n\t\t} else {\n\t\t\tdma_sync_single_for_device(dd->dev, dd->dma_addr_out,\n\t\t\t\tdd->dma_size, DMA_FROM_DEVICE);\n\n\t\t\t \n\t\t\tcount = atmel_tdes_sg_copy(&dd->out_sg, &dd->out_offset,\n\t\t\t\tdd->buf_out, dd->buflen, dd->dma_size, 1);\n\t\t\tif (count != dd->dma_size) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tdev_dbg(dd->dev, \"not all data converted: %zu\\n\", count);\n\t\t\t}\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int atmel_tdes_crypt(struct skcipher_request *req, unsigned long mode)\n{\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\tstruct atmel_tdes_ctx *ctx = crypto_skcipher_ctx(skcipher);\n\tstruct atmel_tdes_reqctx *rctx = skcipher_request_ctx(req);\n\tstruct device *dev = ctx->dd->dev;\n\n\tif (!req->cryptlen)\n\t\treturn 0;\n\n\tswitch (mode & TDES_FLAGS_OPMODE_MASK) {\n\tcase TDES_FLAGS_CFB8:\n\t\tif (!IS_ALIGNED(req->cryptlen, CFB8_BLOCK_SIZE)) {\n\t\t\tdev_dbg(dev, \"request size is not exact amount of CFB8 blocks\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctx->block_size = CFB8_BLOCK_SIZE;\n\t\tbreak;\n\n\tcase TDES_FLAGS_CFB16:\n\t\tif (!IS_ALIGNED(req->cryptlen, CFB16_BLOCK_SIZE)) {\n\t\t\tdev_dbg(dev, \"request size is not exact amount of CFB16 blocks\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctx->block_size = CFB16_BLOCK_SIZE;\n\t\tbreak;\n\n\tcase TDES_FLAGS_CFB32:\n\t\tif (!IS_ALIGNED(req->cryptlen, CFB32_BLOCK_SIZE)) {\n\t\t\tdev_dbg(dev, \"request size is not exact amount of CFB32 blocks\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctx->block_size = CFB32_BLOCK_SIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tif (!IS_ALIGNED(req->cryptlen, DES_BLOCK_SIZE)) {\n\t\t\tdev_dbg(dev, \"request size is not exact amount of DES blocks\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctx->block_size = DES_BLOCK_SIZE;\n\t\tbreak;\n\t}\n\n\trctx->mode = mode;\n\n\tif ((mode & TDES_FLAGS_OPMODE_MASK) != TDES_FLAGS_ECB &&\n\t    !(mode & TDES_FLAGS_ENCRYPT)) {\n\t\tunsigned int ivsize = crypto_skcipher_ivsize(skcipher);\n\n\t\tif (req->cryptlen >= ivsize)\n\t\t\tscatterwalk_map_and_copy(rctx->lastc, req->src,\n\t\t\t\t\t\t req->cryptlen - ivsize,\n\t\t\t\t\t\t ivsize, 0);\n\t}\n\n\treturn atmel_tdes_handle_queue(ctx->dd, req);\n}\n\nstatic int atmel_tdes_dma_init(struct atmel_tdes_dev *dd)\n{\n\tint ret;\n\n\t \n\tdd->dma_lch_in.chan = dma_request_chan(dd->dev, \"tx\");\n\tif (IS_ERR(dd->dma_lch_in.chan)) {\n\t\tret = PTR_ERR(dd->dma_lch_in.chan);\n\t\tgoto err_dma_in;\n\t}\n\n\tdd->dma_lch_in.dma_conf.dst_addr = dd->phys_base +\n\t\tTDES_IDATA1R;\n\tdd->dma_lch_in.dma_conf.src_maxburst = 1;\n\tdd->dma_lch_in.dma_conf.src_addr_width =\n\t\tDMA_SLAVE_BUSWIDTH_4_BYTES;\n\tdd->dma_lch_in.dma_conf.dst_maxburst = 1;\n\tdd->dma_lch_in.dma_conf.dst_addr_width =\n\t\tDMA_SLAVE_BUSWIDTH_4_BYTES;\n\tdd->dma_lch_in.dma_conf.device_fc = false;\n\n\tdd->dma_lch_out.chan = dma_request_chan(dd->dev, \"rx\");\n\tif (IS_ERR(dd->dma_lch_out.chan)) {\n\t\tret = PTR_ERR(dd->dma_lch_out.chan);\n\t\tgoto err_dma_out;\n\t}\n\n\tdd->dma_lch_out.dma_conf.src_addr = dd->phys_base +\n\t\tTDES_ODATA1R;\n\tdd->dma_lch_out.dma_conf.src_maxburst = 1;\n\tdd->dma_lch_out.dma_conf.src_addr_width =\n\t\tDMA_SLAVE_BUSWIDTH_4_BYTES;\n\tdd->dma_lch_out.dma_conf.dst_maxburst = 1;\n\tdd->dma_lch_out.dma_conf.dst_addr_width =\n\t\tDMA_SLAVE_BUSWIDTH_4_BYTES;\n\tdd->dma_lch_out.dma_conf.device_fc = false;\n\n\treturn 0;\n\nerr_dma_out:\n\tdma_release_channel(dd->dma_lch_in.chan);\nerr_dma_in:\n\tdev_err(dd->dev, \"no DMA channel available\\n\");\n\treturn ret;\n}\n\nstatic void atmel_tdes_dma_cleanup(struct atmel_tdes_dev *dd)\n{\n\tdma_release_channel(dd->dma_lch_in.chan);\n\tdma_release_channel(dd->dma_lch_out.chan);\n}\n\nstatic int atmel_des_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct atmel_tdes_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tint err;\n\n\terr = verify_skcipher_des_key(tfm, key);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(ctx->key, key, keylen);\n\tctx->keylen = keylen;\n\n\treturn 0;\n}\n\nstatic int atmel_tdes_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct atmel_tdes_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tint err;\n\n\terr = verify_skcipher_des3_key(tfm, key);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(ctx->key, key, keylen);\n\tctx->keylen = keylen;\n\n\treturn 0;\n}\n\nstatic int atmel_tdes_ecb_encrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_ECB | TDES_FLAGS_ENCRYPT);\n}\n\nstatic int atmel_tdes_ecb_decrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_ECB);\n}\n\nstatic int atmel_tdes_cbc_encrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_CBC | TDES_FLAGS_ENCRYPT);\n}\n\nstatic int atmel_tdes_cbc_decrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_CBC);\n}\nstatic int atmel_tdes_cfb_encrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_CFB64 | TDES_FLAGS_ENCRYPT);\n}\n\nstatic int atmel_tdes_cfb_decrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_CFB64);\n}\n\nstatic int atmel_tdes_cfb8_encrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_CFB8 | TDES_FLAGS_ENCRYPT);\n}\n\nstatic int atmel_tdes_cfb8_decrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_CFB8);\n}\n\nstatic int atmel_tdes_cfb16_encrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_CFB16 | TDES_FLAGS_ENCRYPT);\n}\n\nstatic int atmel_tdes_cfb16_decrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_CFB16);\n}\n\nstatic int atmel_tdes_cfb32_encrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_CFB32 | TDES_FLAGS_ENCRYPT);\n}\n\nstatic int atmel_tdes_cfb32_decrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_CFB32);\n}\n\nstatic int atmel_tdes_ofb_encrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_OFB | TDES_FLAGS_ENCRYPT);\n}\n\nstatic int atmel_tdes_ofb_decrypt(struct skcipher_request *req)\n{\n\treturn atmel_tdes_crypt(req, TDES_FLAGS_OFB);\n}\n\nstatic int atmel_tdes_init_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct atmel_tdes_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\tctx->dd = atmel_tdes_dev_alloc();\n\tif (!ctx->dd)\n\t\treturn -ENODEV;\n\n\tcrypto_skcipher_set_reqsize(tfm, sizeof(struct atmel_tdes_reqctx));\n\n\treturn 0;\n}\n\nstatic void atmel_tdes_skcipher_alg_init(struct skcipher_alg *alg)\n{\n\talg->base.cra_priority = ATMEL_TDES_PRIORITY;\n\talg->base.cra_flags = CRYPTO_ALG_ASYNC;\n\talg->base.cra_ctxsize = sizeof(struct atmel_tdes_ctx);\n\talg->base.cra_module = THIS_MODULE;\n\n\talg->init = atmel_tdes_init_tfm;\n}\n\nstatic struct skcipher_alg tdes_algs[] = {\n{\n\t.base.cra_name\t\t= \"ecb(des)\",\n\t.base.cra_driver_name\t= \"atmel-ecb-des\",\n\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t.base.cra_alignmask\t= 0x7,\n\n\t.min_keysize\t\t= DES_KEY_SIZE,\n\t.max_keysize\t\t= DES_KEY_SIZE,\n\t.setkey\t\t\t= atmel_des_setkey,\n\t.encrypt\t\t= atmel_tdes_ecb_encrypt,\n\t.decrypt\t\t= atmel_tdes_ecb_decrypt,\n},\n{\n\t.base.cra_name\t\t= \"cbc(des)\",\n\t.base.cra_driver_name\t= \"atmel-cbc-des\",\n\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t.base.cra_alignmask\t= 0x7,\n\n\t.min_keysize\t\t= DES_KEY_SIZE,\n\t.max_keysize\t\t= DES_KEY_SIZE,\n\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t.setkey\t\t\t= atmel_des_setkey,\n\t.encrypt\t\t= atmel_tdes_cbc_encrypt,\n\t.decrypt\t\t= atmel_tdes_cbc_decrypt,\n},\n{\n\t.base.cra_name\t\t= \"cfb(des)\",\n\t.base.cra_driver_name\t= \"atmel-cfb-des\",\n\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t.base.cra_alignmask\t= 0x7,\n\n\t.min_keysize\t\t= DES_KEY_SIZE,\n\t.max_keysize\t\t= DES_KEY_SIZE,\n\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t.setkey\t\t\t= atmel_des_setkey,\n\t.encrypt\t\t= atmel_tdes_cfb_encrypt,\n\t.decrypt\t\t= atmel_tdes_cfb_decrypt,\n},\n{\n\t.base.cra_name\t\t= \"cfb8(des)\",\n\t.base.cra_driver_name\t= \"atmel-cfb8-des\",\n\t.base.cra_blocksize\t= CFB8_BLOCK_SIZE,\n\t.base.cra_alignmask\t= 0,\n\n\t.min_keysize\t\t= DES_KEY_SIZE,\n\t.max_keysize\t\t= DES_KEY_SIZE,\n\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t.setkey\t\t\t= atmel_des_setkey,\n\t.encrypt\t\t= atmel_tdes_cfb8_encrypt,\n\t.decrypt\t\t= atmel_tdes_cfb8_decrypt,\n},\n{\n\t.base.cra_name\t\t= \"cfb16(des)\",\n\t.base.cra_driver_name\t= \"atmel-cfb16-des\",\n\t.base.cra_blocksize\t= CFB16_BLOCK_SIZE,\n\t.base.cra_alignmask\t= 0x1,\n\n\t.min_keysize\t\t= DES_KEY_SIZE,\n\t.max_keysize\t\t= DES_KEY_SIZE,\n\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t.setkey\t\t\t= atmel_des_setkey,\n\t.encrypt\t\t= atmel_tdes_cfb16_encrypt,\n\t.decrypt\t\t= atmel_tdes_cfb16_decrypt,\n},\n{\n\t.base.cra_name\t\t= \"cfb32(des)\",\n\t.base.cra_driver_name\t= \"atmel-cfb32-des\",\n\t.base.cra_blocksize\t= CFB32_BLOCK_SIZE,\n\t.base.cra_alignmask\t= 0x3,\n\n\t.min_keysize\t\t= DES_KEY_SIZE,\n\t.max_keysize\t\t= DES_KEY_SIZE,\n\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t.setkey\t\t\t= atmel_des_setkey,\n\t.encrypt\t\t= atmel_tdes_cfb32_encrypt,\n\t.decrypt\t\t= atmel_tdes_cfb32_decrypt,\n},\n{\n\t.base.cra_name\t\t= \"ofb(des)\",\n\t.base.cra_driver_name\t= \"atmel-ofb-des\",\n\t.base.cra_blocksize\t= 1,\n\t.base.cra_alignmask\t= 0x7,\n\n\t.min_keysize\t\t= DES_KEY_SIZE,\n\t.max_keysize\t\t= DES_KEY_SIZE,\n\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t.setkey\t\t\t= atmel_des_setkey,\n\t.encrypt\t\t= atmel_tdes_ofb_encrypt,\n\t.decrypt\t\t= atmel_tdes_ofb_decrypt,\n},\n{\n\t.base.cra_name\t\t= \"ecb(des3_ede)\",\n\t.base.cra_driver_name\t= \"atmel-ecb-tdes\",\n\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t.base.cra_alignmask\t= 0x7,\n\n\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t.setkey\t\t\t= atmel_tdes_setkey,\n\t.encrypt\t\t= atmel_tdes_ecb_encrypt,\n\t.decrypt\t\t= atmel_tdes_ecb_decrypt,\n},\n{\n\t.base.cra_name\t\t= \"cbc(des3_ede)\",\n\t.base.cra_driver_name\t= \"atmel-cbc-tdes\",\n\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t.base.cra_alignmask\t= 0x7,\n\n\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t.setkey\t\t\t= atmel_tdes_setkey,\n\t.encrypt\t\t= atmel_tdes_cbc_encrypt,\n\t.decrypt\t\t= atmel_tdes_cbc_decrypt,\n\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n},\n{\n\t.base.cra_name\t\t= \"ofb(des3_ede)\",\n\t.base.cra_driver_name\t= \"atmel-ofb-tdes\",\n\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t.base.cra_alignmask\t= 0x7,\n\n\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t.setkey\t\t\t= atmel_tdes_setkey,\n\t.encrypt\t\t= atmel_tdes_ofb_encrypt,\n\t.decrypt\t\t= atmel_tdes_ofb_decrypt,\n\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n},\n};\n\nstatic void atmel_tdes_queue_task(unsigned long data)\n{\n\tstruct atmel_tdes_dev *dd = (struct atmel_tdes_dev *)data;\n\n\tatmel_tdes_handle_queue(dd, NULL);\n}\n\nstatic void atmel_tdes_done_task(unsigned long data)\n{\n\tstruct atmel_tdes_dev *dd = (struct atmel_tdes_dev *) data;\n\tint err;\n\n\tif (!(dd->flags & TDES_FLAGS_DMA))\n\t\terr = atmel_tdes_crypt_pdc_stop(dd);\n\telse\n\t\terr = atmel_tdes_crypt_dma_stop(dd);\n\n\tif (dd->total && !err) {\n\t\tif (dd->flags & TDES_FLAGS_FAST) {\n\t\t\tdd->in_sg = sg_next(dd->in_sg);\n\t\t\tdd->out_sg = sg_next(dd->out_sg);\n\t\t\tif (!dd->in_sg || !dd->out_sg)\n\t\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (!err)\n\t\t\terr = atmel_tdes_crypt_start(dd);\n\t\tif (!err)\n\t\t\treturn;  \n\t}\n\n\tatmel_tdes_finish_req(dd, err);\n\tatmel_tdes_handle_queue(dd, NULL);\n}\n\nstatic irqreturn_t atmel_tdes_irq(int irq, void *dev_id)\n{\n\tstruct atmel_tdes_dev *tdes_dd = dev_id;\n\tu32 reg;\n\n\treg = atmel_tdes_read(tdes_dd, TDES_ISR);\n\tif (reg & atmel_tdes_read(tdes_dd, TDES_IMR)) {\n\t\tatmel_tdes_write(tdes_dd, TDES_IDR, reg);\n\t\tif (TDES_FLAGS_BUSY & tdes_dd->flags)\n\t\t\ttasklet_schedule(&tdes_dd->done_task);\n\t\telse\n\t\t\tdev_warn(tdes_dd->dev, \"TDES interrupt when no active requests.\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic void atmel_tdes_unregister_algs(struct atmel_tdes_dev *dd)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tdes_algs); i++)\n\t\tcrypto_unregister_skcipher(&tdes_algs[i]);\n}\n\nstatic int atmel_tdes_register_algs(struct atmel_tdes_dev *dd)\n{\n\tint err, i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(tdes_algs); i++) {\n\t\tatmel_tdes_skcipher_alg_init(&tdes_algs[i]);\n\n\t\terr = crypto_register_skcipher(&tdes_algs[i]);\n\t\tif (err)\n\t\t\tgoto err_tdes_algs;\n\t}\n\n\treturn 0;\n\nerr_tdes_algs:\n\tfor (j = 0; j < i; j++)\n\t\tcrypto_unregister_skcipher(&tdes_algs[j]);\n\n\treturn err;\n}\n\nstatic void atmel_tdes_get_cap(struct atmel_tdes_dev *dd)\n{\n\n\tdd->caps.has_dma = 0;\n\tdd->caps.has_cfb_3keys = 0;\n\n\t \n\tswitch (dd->hw_version & 0xf00) {\n\tcase 0x800:\n\tcase 0x700:\n\t\tdd->caps.has_dma = 1;\n\t\tdd->caps.has_cfb_3keys = 1;\n\t\tbreak;\n\tcase 0x600:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dd->dev,\n\t\t\t\t\"Unmanaged tdes version, set minimum capabilities\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic const struct of_device_id atmel_tdes_dt_ids[] = {\n\t{ .compatible = \"atmel,at91sam9g46-tdes\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, atmel_tdes_dt_ids);\n\nstatic int atmel_tdes_probe(struct platform_device *pdev)\n{\n\tstruct atmel_tdes_dev *tdes_dd;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *tdes_res;\n\tint err;\n\n\ttdes_dd = devm_kmalloc(&pdev->dev, sizeof(*tdes_dd), GFP_KERNEL);\n\tif (!tdes_dd)\n\t\treturn -ENOMEM;\n\n\ttdes_dd->dev = dev;\n\n\tplatform_set_drvdata(pdev, tdes_dd);\n\n\tINIT_LIST_HEAD(&tdes_dd->list);\n\tspin_lock_init(&tdes_dd->lock);\n\n\ttasklet_init(&tdes_dd->done_task, atmel_tdes_done_task,\n\t\t\t\t\t(unsigned long)tdes_dd);\n\ttasklet_init(&tdes_dd->queue_task, atmel_tdes_queue_task,\n\t\t\t\t\t(unsigned long)tdes_dd);\n\n\tcrypto_init_queue(&tdes_dd->queue, ATMEL_TDES_QUEUE_LENGTH);\n\n\ttdes_dd->io_base = devm_platform_get_and_ioremap_resource(pdev, 0, &tdes_res);\n\tif (IS_ERR(tdes_dd->io_base)) {\n\t\terr = PTR_ERR(tdes_dd->io_base);\n\t\tgoto err_tasklet_kill;\n\t}\n\ttdes_dd->phys_base = tdes_res->start;\n\n\t \n\ttdes_dd->irq = platform_get_irq(pdev,  0);\n\tif (tdes_dd->irq < 0) {\n\t\terr = tdes_dd->irq;\n\t\tgoto err_tasklet_kill;\n\t}\n\n\terr = devm_request_irq(&pdev->dev, tdes_dd->irq, atmel_tdes_irq,\n\t\t\t       IRQF_SHARED, \"atmel-tdes\", tdes_dd);\n\tif (err) {\n\t\tdev_err(dev, \"unable to request tdes irq.\\n\");\n\t\tgoto err_tasklet_kill;\n\t}\n\n\t \n\ttdes_dd->iclk = devm_clk_get(&pdev->dev, \"tdes_clk\");\n\tif (IS_ERR(tdes_dd->iclk)) {\n\t\tdev_err(dev, \"clock initialization failed.\\n\");\n\t\terr = PTR_ERR(tdes_dd->iclk);\n\t\tgoto err_tasklet_kill;\n\t}\n\n\terr = atmel_tdes_hw_version_init(tdes_dd);\n\tif (err)\n\t\tgoto err_tasklet_kill;\n\n\tatmel_tdes_get_cap(tdes_dd);\n\n\terr = atmel_tdes_buff_init(tdes_dd);\n\tif (err)\n\t\tgoto err_tasklet_kill;\n\n\tif (tdes_dd->caps.has_dma) {\n\t\terr = atmel_tdes_dma_init(tdes_dd);\n\t\tif (err)\n\t\t\tgoto err_buff_cleanup;\n\n\t\tdev_info(dev, \"using %s, %s for DMA transfers\\n\",\n\t\t\t\tdma_chan_name(tdes_dd->dma_lch_in.chan),\n\t\t\t\tdma_chan_name(tdes_dd->dma_lch_out.chan));\n\t}\n\n\tspin_lock(&atmel_tdes.lock);\n\tlist_add_tail(&tdes_dd->list, &atmel_tdes.dev_list);\n\tspin_unlock(&atmel_tdes.lock);\n\n\terr = atmel_tdes_register_algs(tdes_dd);\n\tif (err)\n\t\tgoto err_algs;\n\n\tdev_info(dev, \"Atmel DES/TDES\\n\");\n\n\treturn 0;\n\nerr_algs:\n\tspin_lock(&atmel_tdes.lock);\n\tlist_del(&tdes_dd->list);\n\tspin_unlock(&atmel_tdes.lock);\n\tif (tdes_dd->caps.has_dma)\n\t\tatmel_tdes_dma_cleanup(tdes_dd);\nerr_buff_cleanup:\n\tatmel_tdes_buff_cleanup(tdes_dd);\nerr_tasklet_kill:\n\ttasklet_kill(&tdes_dd->done_task);\n\ttasklet_kill(&tdes_dd->queue_task);\n\n\treturn err;\n}\n\nstatic int atmel_tdes_remove(struct platform_device *pdev)\n{\n\tstruct atmel_tdes_dev *tdes_dd = platform_get_drvdata(pdev);\n\n\tspin_lock(&atmel_tdes.lock);\n\tlist_del(&tdes_dd->list);\n\tspin_unlock(&atmel_tdes.lock);\n\n\tatmel_tdes_unregister_algs(tdes_dd);\n\n\ttasklet_kill(&tdes_dd->done_task);\n\ttasklet_kill(&tdes_dd->queue_task);\n\n\tif (tdes_dd->caps.has_dma)\n\t\tatmel_tdes_dma_cleanup(tdes_dd);\n\n\tatmel_tdes_buff_cleanup(tdes_dd);\n\n\treturn 0;\n}\n\nstatic struct platform_driver atmel_tdes_driver = {\n\t.probe\t\t= atmel_tdes_probe,\n\t.remove\t\t= atmel_tdes_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"atmel_tdes\",\n\t\t.of_match_table = atmel_tdes_dt_ids,\n\t},\n};\n\nmodule_platform_driver(atmel_tdes_driver);\n\nMODULE_DESCRIPTION(\"Atmel DES/TDES hw acceleration support.\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Nicolas Royer - Eukr\u00e9a Electromatique\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}