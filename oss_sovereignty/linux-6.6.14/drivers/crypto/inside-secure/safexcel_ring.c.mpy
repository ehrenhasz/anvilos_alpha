{
  "module_name": "safexcel_ring.c",
  "hash_id": "96d5878045f7c239db5d265c850d6614891ec340a98d89a50a08ecf779155519",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/inside-secure/safexcel_ring.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/spinlock.h>\n\n#include \"safexcel.h\"\n\nint safexcel_init_ring_descriptors(struct safexcel_crypto_priv *priv,\n\t\t\t\t   struct safexcel_desc_ring *cdr,\n\t\t\t\t   struct safexcel_desc_ring *rdr)\n{\n\tint i;\n\tstruct safexcel_command_desc *cdesc;\n\tdma_addr_t atok;\n\n\t \n\tcdr->offset = priv->config.cd_offset;\n\tcdr->base = dmam_alloc_coherent(priv->dev,\n\t\t\t\t\tcdr->offset * EIP197_DEFAULT_RING_SIZE,\n\t\t\t\t\t&cdr->base_dma, GFP_KERNEL);\n\tif (!cdr->base)\n\t\treturn -ENOMEM;\n\tcdr->write = cdr->base;\n\tcdr->base_end = cdr->base + cdr->offset * (EIP197_DEFAULT_RING_SIZE - 1);\n\tcdr->read = cdr->base;\n\n\t \n\tcdr->shoffset = priv->config.cdsh_offset;\n\tcdr->shbase = dmam_alloc_coherent(priv->dev,\n\t\t\t\t\t  cdr->shoffset *\n\t\t\t\t\t  EIP197_DEFAULT_RING_SIZE,\n\t\t\t\t\t  &cdr->shbase_dma, GFP_KERNEL);\n\tif (!cdr->shbase)\n\t\treturn -ENOMEM;\n\tcdr->shwrite = cdr->shbase;\n\tcdr->shbase_end = cdr->shbase + cdr->shoffset *\n\t\t\t\t\t(EIP197_DEFAULT_RING_SIZE - 1);\n\n\t \n\tcdesc = cdr->base;\n\tatok = cdr->shbase_dma;\n\tfor (i = 0; i < EIP197_DEFAULT_RING_SIZE; i++) {\n\t\tcdesc->atok_lo = lower_32_bits(atok);\n\t\tcdesc->atok_hi = upper_32_bits(atok);\n\t\tcdesc = (void *)cdesc + cdr->offset;\n\t\tatok += cdr->shoffset;\n\t}\n\n\trdr->offset = priv->config.rd_offset;\n\t \n\trdr->shoffset = priv->config.res_offset;\n\trdr->base = dmam_alloc_coherent(priv->dev,\n\t\t\t\t\trdr->offset * EIP197_DEFAULT_RING_SIZE,\n\t\t\t\t\t&rdr->base_dma, GFP_KERNEL);\n\tif (!rdr->base)\n\t\treturn -ENOMEM;\n\trdr->write = rdr->base;\n\trdr->base_end = rdr->base + rdr->offset  * (EIP197_DEFAULT_RING_SIZE - 1);\n\trdr->read = rdr->base;\n\n\treturn 0;\n}\n\ninline int safexcel_select_ring(struct safexcel_crypto_priv *priv)\n{\n\treturn (atomic_inc_return(&priv->ring_used) % priv->config.rings);\n}\n\nstatic void *safexcel_ring_next_cwptr(struct safexcel_crypto_priv *priv,\n\t\t\t\t     struct safexcel_desc_ring *ring,\n\t\t\t\t     bool first,\n\t\t\t\t     struct safexcel_token **atoken)\n{\n\tvoid *ptr = ring->write;\n\n\tif (first)\n\t\t*atoken = ring->shwrite;\n\n\tif ((ring->write == ring->read - ring->offset) ||\n\t    (ring->read == ring->base && ring->write == ring->base_end))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (ring->write == ring->base_end) {\n\t\tring->write = ring->base;\n\t\tring->shwrite = ring->shbase;\n\t} else {\n\t\tring->write += ring->offset;\n\t\tring->shwrite += ring->shoffset;\n\t}\n\n\treturn ptr;\n}\n\nstatic void *safexcel_ring_next_rwptr(struct safexcel_crypto_priv *priv,\n\t\t\t\t     struct safexcel_desc_ring *ring,\n\t\t\t\t     struct result_data_desc **rtoken)\n{\n\tvoid *ptr = ring->write;\n\n\t \n\t*rtoken = ring->write + ring->shoffset;\n\n\tif ((ring->write == ring->read - ring->offset) ||\n\t    (ring->read == ring->base && ring->write == ring->base_end))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (ring->write == ring->base_end)\n\t\tring->write = ring->base;\n\telse\n\t\tring->write += ring->offset;\n\n\treturn ptr;\n}\n\nvoid *safexcel_ring_next_rptr(struct safexcel_crypto_priv *priv,\n\t\t\t      struct safexcel_desc_ring *ring)\n{\n\tvoid *ptr = ring->read;\n\n\tif (ring->write == ring->read)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (ring->read == ring->base_end)\n\t\tring->read = ring->base;\n\telse\n\t\tring->read += ring->offset;\n\n\treturn ptr;\n}\n\ninline void *safexcel_ring_curr_rptr(struct safexcel_crypto_priv *priv,\n\t\t\t\t     int ring)\n{\n\tstruct safexcel_desc_ring *rdr = &priv->ring[ring].rdr;\n\n\treturn rdr->read;\n}\n\ninline int safexcel_ring_first_rdr_index(struct safexcel_crypto_priv *priv,\n\t\t\t\t\t int ring)\n{\n\tstruct safexcel_desc_ring *rdr = &priv->ring[ring].rdr;\n\n\treturn (rdr->read - rdr->base) / rdr->offset;\n}\n\ninline int safexcel_ring_rdr_rdesc_index(struct safexcel_crypto_priv *priv,\n\t\t\t\t\t int ring,\n\t\t\t\t\t struct safexcel_result_desc *rdesc)\n{\n\tstruct safexcel_desc_ring *rdr = &priv->ring[ring].rdr;\n\n\treturn ((void *)rdesc - rdr->base) / rdr->offset;\n}\n\nvoid safexcel_ring_rollback_wptr(struct safexcel_crypto_priv *priv,\n\t\t\t\t struct safexcel_desc_ring *ring)\n{\n\tif (ring->write == ring->read)\n\t\treturn;\n\n\tif (ring->write == ring->base) {\n\t\tring->write = ring->base_end;\n\t\tring->shwrite = ring->shbase_end;\n\t} else {\n\t\tring->write -= ring->offset;\n\t\tring->shwrite -= ring->shoffset;\n\t}\n}\n\nstruct safexcel_command_desc *safexcel_add_cdesc(struct safexcel_crypto_priv *priv,\n\t\t\t\t\t\t int ring_id,\n\t\t\t\t\t\t bool first, bool last,\n\t\t\t\t\t\t dma_addr_t data, u32 data_len,\n\t\t\t\t\t\t u32 full_data_len,\n\t\t\t\t\t\t dma_addr_t context,\n\t\t\t\t\t\t struct safexcel_token **atoken)\n{\n\tstruct safexcel_command_desc *cdesc;\n\n\tcdesc = safexcel_ring_next_cwptr(priv, &priv->ring[ring_id].cdr,\n\t\t\t\t\t first, atoken);\n\tif (IS_ERR(cdesc))\n\t\treturn cdesc;\n\n\tcdesc->particle_size = data_len;\n\tcdesc->rsvd0 = 0;\n\tcdesc->last_seg = last;\n\tcdesc->first_seg = first;\n\tcdesc->additional_cdata_size = 0;\n\tcdesc->rsvd1 = 0;\n\tcdesc->data_lo = lower_32_bits(data);\n\tcdesc->data_hi = upper_32_bits(data);\n\n\tif (first) {\n\t\t \n\t\tcdesc->control_data.packet_length = full_data_len ?: 1;\n\t\tcdesc->control_data.options = EIP197_OPTION_MAGIC_VALUE |\n\t\t\t\t\t      EIP197_OPTION_64BIT_CTX |\n\t\t\t\t\t      EIP197_OPTION_CTX_CTRL_IN_CMD |\n\t\t\t\t\t      EIP197_OPTION_RC_AUTO;\n\t\tcdesc->control_data.type = EIP197_TYPE_BCLA;\n\t\tcdesc->control_data.context_lo = lower_32_bits(context) |\n\t\t\t\t\t\t EIP197_CONTEXT_SMALL;\n\t\tcdesc->control_data.context_hi = upper_32_bits(context);\n\t}\n\n\treturn cdesc;\n}\n\nstruct safexcel_result_desc *safexcel_add_rdesc(struct safexcel_crypto_priv *priv,\n\t\t\t\t\t\tint ring_id,\n\t\t\t\t\t\tbool first, bool last,\n\t\t\t\t\t\tdma_addr_t data, u32 len)\n{\n\tstruct safexcel_result_desc *rdesc;\n\tstruct result_data_desc *rtoken;\n\n\trdesc = safexcel_ring_next_rwptr(priv, &priv->ring[ring_id].rdr,\n\t\t\t\t\t &rtoken);\n\tif (IS_ERR(rdesc))\n\t\treturn rdesc;\n\n\trdesc->particle_size = len;\n\trdesc->rsvd0 = 0;\n\trdesc->descriptor_overflow = 1;  \n\trdesc->buffer_overflow = 1;      \n\trdesc->last_seg = last;\n\trdesc->first_seg = first;\n\trdesc->result_size = EIP197_RD64_RESULT_SIZE;\n\trdesc->rsvd1 = 0;\n\trdesc->data_lo = lower_32_bits(data);\n\trdesc->data_hi = upper_32_bits(data);\n\n\t \n\trtoken->packet_length = 0;\n\t \n\trtoken->error_code = 0x7fff;\n\n\treturn rdesc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}