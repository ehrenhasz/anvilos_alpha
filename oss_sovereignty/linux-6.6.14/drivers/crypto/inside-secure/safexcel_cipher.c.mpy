{
  "module_name": "safexcel_cipher.c",
  "hash_id": "17a66878bc628b50fc90a67ec67f2c9d6ce5d5ae2de817eff98649798527758a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/inside-secure/safexcel_cipher.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <crypto/aead.h>\n#include <crypto/aes.h>\n#include <crypto/authenc.h>\n#include <crypto/chacha.h>\n#include <crypto/ctr.h>\n#include <crypto/internal/des.h>\n#include <crypto/gcm.h>\n#include <crypto/ghash.h>\n#include <crypto/poly1305.h>\n#include <crypto/sha1.h>\n#include <crypto/sha2.h>\n#include <crypto/sm3.h>\n#include <crypto/sm4.h>\n#include <crypto/xts.h>\n#include <crypto/skcipher.h>\n#include <crypto/internal/aead.h>\n#include <crypto/internal/skcipher.h>\n\n#include \"safexcel.h\"\n\nenum safexcel_cipher_direction {\n\tSAFEXCEL_ENCRYPT,\n\tSAFEXCEL_DECRYPT,\n};\n\nenum safexcel_cipher_alg {\n\tSAFEXCEL_DES,\n\tSAFEXCEL_3DES,\n\tSAFEXCEL_AES,\n\tSAFEXCEL_CHACHA20,\n\tSAFEXCEL_SM4,\n};\n\nstruct safexcel_cipher_ctx {\n\tstruct safexcel_context base;\n\tstruct safexcel_crypto_priv *priv;\n\n\tu32 mode;\n\tenum safexcel_cipher_alg alg;\n\tu8 aead;  \n\tu8 xcm;   \n\tu8 aadskip;\n\tu8 blocksz;\n\tu32 ivmask;\n\tu32 ctrinit;\n\n\t__le32 key[16];\n\tu32 nonce;\n\tunsigned int key_len, xts;\n\n\t \n\tu32 hash_alg;\n\tu32 state_sz;\n\n\tstruct crypto_aead *fback;\n};\n\nstruct safexcel_cipher_req {\n\tenum safexcel_cipher_direction direction;\n\t \n\tunsigned int rdescs;\n\tbool needs_inv;\n\tint  nr_src, nr_dst;\n};\n\nstatic int safexcel_skcipher_iv(struct safexcel_cipher_ctx *ctx, u8 *iv,\n\t\t\t\tstruct safexcel_command_desc *cdesc)\n{\n\tif (ctx->mode == CONTEXT_CONTROL_CRYPTO_MODE_CTR_LOAD) {\n\t\tcdesc->control_data.options |= EIP197_OPTION_4_TOKEN_IV_CMD;\n\t\t \n\t\tcdesc->control_data.token[0] = ctx->nonce;\n\t\t \n\t\tmemcpy(&cdesc->control_data.token[1], iv, 8);\n\t\t \n\t\tcdesc->control_data.token[3] =\n\t\t\t(__force u32)cpu_to_be32(ctx->ctrinit);\n\t\treturn 4;\n\t}\n\tif (ctx->alg == SAFEXCEL_CHACHA20) {\n\t\tcdesc->control_data.options |= EIP197_OPTION_4_TOKEN_IV_CMD;\n\t\t \n\t\tmemcpy(&cdesc->control_data.token[0], &iv[4], 12);\n\t\t \n\t\tcdesc->control_data.token[3] = *(u32 *)iv;\n\t\treturn 4;\n\t}\n\n\tcdesc->control_data.options |= ctx->ivmask;\n\tmemcpy(cdesc->control_data.token, iv, ctx->blocksz);\n\treturn ctx->blocksz / sizeof(u32);\n}\n\nstatic void safexcel_skcipher_token(struct safexcel_cipher_ctx *ctx, u8 *iv,\n\t\t\t\t    struct safexcel_command_desc *cdesc,\n\t\t\t\t    struct safexcel_token *atoken,\n\t\t\t\t    u32 length)\n{\n\tstruct safexcel_token *token;\n\tint ivlen;\n\n\tivlen = safexcel_skcipher_iv(ctx, iv, cdesc);\n\tif (ivlen == 4) {\n\t\t \n\t\tcdesc->additional_cdata_size = 1;\n\t\ttoken = atoken;\n\t} else {\n\t\t \n\t\ttoken = (struct safexcel_token *)(cdesc->control_data.token + 2);\n\t\t \n\t\teip197_noop_token(&token[1]);\n\t}\n\n\ttoken->opcode = EIP197_TOKEN_OPCODE_DIRECTION;\n\ttoken->packet_length = length;\n\ttoken->stat = EIP197_TOKEN_STAT_LAST_PACKET |\n\t\t      EIP197_TOKEN_STAT_LAST_HASH;\n\ttoken->instructions = EIP197_TOKEN_INS_LAST |\n\t\t\t      EIP197_TOKEN_INS_TYPE_CRYPTO |\n\t\t\t      EIP197_TOKEN_INS_TYPE_OUTPUT;\n}\n\nstatic void safexcel_aead_iv(struct safexcel_cipher_ctx *ctx, u8 *iv,\n\t\t\t     struct safexcel_command_desc *cdesc)\n{\n\tif (ctx->mode == CONTEXT_CONTROL_CRYPTO_MODE_CTR_LOAD ||\n\t    ctx->aead & EIP197_AEAD_TYPE_IPSEC_ESP) {  \n\t\t \n\t\tcdesc->control_data.token[0] = ctx->nonce;\n\t\t \n\t\tmemcpy(&cdesc->control_data.token[1], iv, 8);\n\t\t \n\t\tcdesc->control_data.token[3] =\n\t\t\t(__force u32)cpu_to_be32(ctx->ctrinit);\n\t\treturn;\n\t}\n\tif (ctx->xcm == EIP197_XCM_MODE_GCM || ctx->alg == SAFEXCEL_CHACHA20) {\n\t\t \n\t\tmemcpy(&cdesc->control_data.token[0], iv, 12);\n\t\t \n\t\tcdesc->control_data.token[3] =\n\t\t\t(__force u32)cpu_to_be32(ctx->ctrinit);\n\t\treturn;\n\t}\n\t \n\tmemcpy(cdesc->control_data.token, iv, ctx->blocksz);\n}\n\nstatic void safexcel_aead_token(struct safexcel_cipher_ctx *ctx, u8 *iv,\n\t\t\t\tstruct safexcel_command_desc *cdesc,\n\t\t\t\tstruct safexcel_token *atoken,\n\t\t\t\tenum safexcel_cipher_direction direction,\n\t\t\t\tu32 cryptlen, u32 assoclen, u32 digestsize)\n{\n\tstruct safexcel_token *aadref;\n\tint atoksize = 2;  \n\tint assocadj = assoclen - ctx->aadskip, aadalign;\n\n\t \n\tcdesc->control_data.options |= EIP197_OPTION_4_TOKEN_IV_CMD;\n\n\tif (direction == SAFEXCEL_DECRYPT)\n\t\tcryptlen -= digestsize;\n\n\tif (unlikely(ctx->xcm == EIP197_XCM_MODE_CCM)) {\n\t\t \n\t\tu8 *final_iv = (u8 *)cdesc->control_data.token;\n\t\tu8 *cbcmaciv = (u8 *)&atoken[1];\n\t\t__le32 *aadlen = (__le32 *)&atoken[5];\n\n\t\tif (ctx->aead == EIP197_AEAD_TYPE_IPSEC_ESP) {\n\t\t\t \n\t\t\tcdesc->control_data.token[0] = ctx->nonce;\n\t\t\t \n\t\t\t*(__le32 *)cbcmaciv =\n\t\t\t\tcpu_to_le32(ctx->nonce |\n\t\t\t\t\t    ((assocadj > 0) << 6) |\n\t\t\t\t\t    ((digestsize - 2) << 2));\n\t\t\t \n\t\t\tmemcpy(&cdesc->control_data.token[1], iv, 8);\n\t\t\tmemcpy(cbcmaciv + 4, iv, 8);\n\t\t\t \n\t\t\tcdesc->control_data.token[3] = 0;\n\t\t\t \n\t\t\t*(__be32 *)(cbcmaciv + 12) = cpu_to_be32(cryptlen);\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(final_iv, iv, 15 - iv[0]);\n\t\t\tmemcpy(cbcmaciv, iv, 15 - iv[0]);\n\t\t\t \n\t\t\tmemset(final_iv + 15 - iv[0], 0, iv[0] + 1);\n\t\t\tmemset(cbcmaciv + 15 - iv[0], 0, iv[0] - 1);\n\t\t\t \n\t\t\tcbcmaciv[0] |= ((assocadj > 0) << 6) |\n\t\t\t\t       ((digestsize - 2) << 2);\n\t\t\t \n\t\t\tcbcmaciv[14] = cryptlen >> 8;\n\t\t\tcbcmaciv[15] = cryptlen & 255;\n\t\t}\n\n\t\tatoken->opcode = EIP197_TOKEN_OPCODE_INSERT;\n\t\tatoken->packet_length = AES_BLOCK_SIZE +\n\t\t\t\t\t((assocadj > 0) << 1);\n\t\tatoken->stat = 0;\n\t\tatoken->instructions = EIP197_TOKEN_INS_ORIGIN_TOKEN |\n\t\t\t\t       EIP197_TOKEN_INS_TYPE_HASH;\n\n\t\tif (likely(assocadj)) {\n\t\t\t*aadlen = cpu_to_le32((assocadj >> 8) |\n\t\t\t\t\t      (assocadj & 255) << 8);\n\t\t\tatoken += 6;\n\t\t\tatoksize += 7;\n\t\t} else {\n\t\t\tatoken += 5;\n\t\t\tatoksize += 6;\n\t\t}\n\n\t\t \n\t\taadref = atoken;\n\t\tatoken->opcode = EIP197_TOKEN_OPCODE_DIRECTION;\n\t\tatoken->packet_length = assocadj;\n\t\tatoken->stat = 0;\n\t\tatoken->instructions = EIP197_TOKEN_INS_TYPE_HASH;\n\t\tatoken++;\n\n\t\t \n\t\tatoken->opcode = EIP197_TOKEN_OPCODE_INSERT;\n\t\taadalign = (assocadj + 2) & 15;\n\t\tatoken->packet_length = assocadj && aadalign ?\n\t\t\t\t\t\t16 - aadalign :\n\t\t\t\t\t\t0;\n\t\tif (likely(cryptlen)) {\n\t\t\tatoken->stat = 0;\n\t\t\tatoken->instructions = EIP197_TOKEN_INS_TYPE_HASH;\n\t\t} else {\n\t\t\tatoken->stat = EIP197_TOKEN_STAT_LAST_HASH;\n\t\t\tatoken->instructions = EIP197_TOKEN_INS_LAST |\n\t\t\t\t\t       EIP197_TOKEN_INS_TYPE_HASH;\n\t\t}\n\t} else {\n\t\tsafexcel_aead_iv(ctx, iv, cdesc);\n\n\t\t \n\t\taadref = atoken;\n\t\tatoken->opcode = EIP197_TOKEN_OPCODE_DIRECTION;\n\t\tatoken->packet_length = assocadj;\n\t\tatoken->stat = EIP197_TOKEN_STAT_LAST_HASH;\n\t\tatoken->instructions = EIP197_TOKEN_INS_LAST |\n\t\t\t\t       EIP197_TOKEN_INS_TYPE_HASH;\n\t}\n\tatoken++;\n\n\tif (ctx->aead == EIP197_AEAD_TYPE_IPSEC_ESP) {\n\t\t \n\t\tatoken->opcode = EIP197_TOKEN_OPCODE_DIRECTION;\n\t\tatoken->packet_length = EIP197_AEAD_IPSEC_IV_SIZE;\n\t\tatoken->stat = 0;\n\t\tatoken->instructions = 0;\n\t\tatoken++;\n\t\tatoksize++;\n\t} else if (unlikely(ctx->alg == SAFEXCEL_CHACHA20 &&\n\t\t\t    direction == SAFEXCEL_DECRYPT)) {\n\t\t \n\t\tatoken->opcode = EIP197_TOKEN_OPCODE_INSERT;\n\t\tatoken->packet_length = 16;  \n\t\tatoken->stat = 0;\n\t\tatoken->instructions = 0;\n\t\tatoken++;\n\t\tatoksize++;\n\t}\n\n\tif  (ctx->xcm) {\n\t\t \n\t\tatoken->opcode = EIP197_TOKEN_OPCODE_INSERT_REMRES;\n\t\tatoken->packet_length = 0;\n\t\tatoken->stat = 0;\n\t\tatoken->instructions = AES_BLOCK_SIZE;\n\t\tatoken++;\n\n\t\tatoken->opcode = EIP197_TOKEN_OPCODE_INSERT;\n\t\tatoken->packet_length = AES_BLOCK_SIZE;\n\t\tatoken->stat = 0;\n\t\tatoken->instructions = EIP197_TOKEN_INS_TYPE_OUTPUT |\n\t\t\t\t       EIP197_TOKEN_INS_TYPE_CRYPTO;\n\t\tatoken++;\n\t\tatoksize += 2;\n\t}\n\n\tif (likely(cryptlen || ctx->alg == SAFEXCEL_CHACHA20)) {\n\t\t \n\t\taadref->stat = 0;\n\n\t\t \n\t\tatoken->opcode = EIP197_TOKEN_OPCODE_DIRECTION;\n\t\tatoken->packet_length = cryptlen;\n\n\t\tif (unlikely(ctx->aead == EIP197_AEAD_TYPE_IPSEC_ESP_GMAC)) {\n\t\t\t \n\t\t\taadref->instructions = EIP197_TOKEN_INS_TYPE_HASH;\n\n\t\t\t \n\t\t\tatoken->instructions = EIP197_TOKEN_INS_LAST |\n\t\t\t\t\t       EIP197_TOKEN_INS_TYPE_HASH |\n\t\t\t\t\t       EIP197_TOKEN_INS_TYPE_OUTPUT;\n\t\t} else {\n\t\t\tatoken->instructions = EIP197_TOKEN_INS_LAST |\n\t\t\t\t\t       EIP197_TOKEN_INS_TYPE_CRYPTO |\n\t\t\t\t\t       EIP197_TOKEN_INS_TYPE_HASH |\n\t\t\t\t\t       EIP197_TOKEN_INS_TYPE_OUTPUT;\n\t\t}\n\n\t\tcryptlen &= 15;\n\t\tif (unlikely(ctx->xcm == EIP197_XCM_MODE_CCM && cryptlen)) {\n\t\t\tatoken->stat = 0;\n\t\t\t \n\t\t\tatoken++;\n\t\t\tatoksize++;\n\t\t\tatoken->opcode = EIP197_TOKEN_OPCODE_INSERT;\n\t\t\tatoken->packet_length = 16 - cryptlen;\n\t\t\tatoken->stat = EIP197_TOKEN_STAT_LAST_HASH;\n\t\t\tatoken->instructions = EIP197_TOKEN_INS_TYPE_HASH;\n\t\t} else {\n\t\t\tatoken->stat = EIP197_TOKEN_STAT_LAST_HASH;\n\t\t}\n\t\tatoken++;\n\t\tatoksize++;\n\t}\n\n\tif (direction == SAFEXCEL_ENCRYPT) {\n\t\t \n\t\tatoken->opcode = EIP197_TOKEN_OPCODE_INSERT;\n\t\tatoken->packet_length = digestsize;\n\t\tatoken->stat = EIP197_TOKEN_STAT_LAST_HASH |\n\t\t\t       EIP197_TOKEN_STAT_LAST_PACKET;\n\t\tatoken->instructions = EIP197_TOKEN_INS_TYPE_OUTPUT |\n\t\t\t\t       EIP197_TOKEN_INS_INSERT_HASH_DIGEST;\n\t} else {\n\t\t \n\t\tatoken->opcode = EIP197_TOKEN_OPCODE_RETRIEVE;\n\t\tatoken->packet_length = digestsize;\n\t\tatoken->stat = EIP197_TOKEN_STAT_LAST_HASH |\n\t\t\t       EIP197_TOKEN_STAT_LAST_PACKET;\n\t\tatoken->instructions = EIP197_TOKEN_INS_INSERT_HASH_DIGEST;\n\t\tatoken++;\n\t\tatoksize++;\n\n\t\t \n\t\tatoken->opcode = EIP197_TOKEN_OPCODE_VERIFY;\n\t\tatoken->packet_length = digestsize |\n\t\t\t\t\tEIP197_TOKEN_HASH_RESULT_VERIFY;\n\t\tatoken->stat = EIP197_TOKEN_STAT_LAST_HASH |\n\t\t\t       EIP197_TOKEN_STAT_LAST_PACKET;\n\t\tatoken->instructions = EIP197_TOKEN_INS_TYPE_OUTPUT;\n\t}\n\n\t \n\tcdesc->additional_cdata_size = atoksize;\n}\n\nstatic int safexcel_skcipher_aes_setkey(struct crypto_skcipher *ctfm,\n\t\t\t\t\tconst u8 *key, unsigned int len)\n{\n\tstruct crypto_tfm *tfm = crypto_skcipher_tfm(ctfm);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tstruct crypto_aes_ctx aes;\n\tint ret, i;\n\n\tret = aes_expandkey(&aes, key, len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->flags & EIP197_TRC_CACHE && ctx->base.ctxr_dma) {\n\t\tfor (i = 0; i < len / sizeof(u32); i++) {\n\t\t\tif (le32_to_cpu(ctx->key[i]) != aes.key_enc[i]) {\n\t\t\t\tctx->base.needs_inv = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < len / sizeof(u32); i++)\n\t\tctx->key[i] = cpu_to_le32(aes.key_enc[i]);\n\n\tctx->key_len = len;\n\n\tmemzero_explicit(&aes, sizeof(aes));\n\treturn 0;\n}\n\nstatic int safexcel_aead_setkey(struct crypto_aead *ctfm, const u8 *key,\n\t\t\t\tunsigned int len)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(ctfm);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tstruct crypto_authenc_keys keys;\n\tstruct crypto_aes_ctx aes;\n\tint err = -EINVAL, i;\n\tconst char *alg;\n\n\tif (unlikely(crypto_authenc_extractkeys(&keys, key, len)))\n\t\tgoto badkey;\n\n\tif (ctx->mode == CONTEXT_CONTROL_CRYPTO_MODE_CTR_LOAD) {\n\t\t \n\t\tif (unlikely(keys.enckeylen < CTR_RFC3686_NONCE_SIZE))\n\t\t\tgoto badkey;\n\t\t \n\t\tctx->nonce = *(u32 *)(keys.enckey + keys.enckeylen -\n\t\t\t\t      CTR_RFC3686_NONCE_SIZE);\n\t\t \n\t\tkeys.enckeylen -= CTR_RFC3686_NONCE_SIZE;\n\t}\n\n\t \n\tswitch (ctx->alg) {\n\tcase SAFEXCEL_DES:\n\t\terr = verify_aead_des_key(ctfm, keys.enckey, keys.enckeylen);\n\t\tif (unlikely(err))\n\t\t\tgoto badkey;\n\t\tbreak;\n\tcase SAFEXCEL_3DES:\n\t\terr = verify_aead_des3_key(ctfm, keys.enckey, keys.enckeylen);\n\t\tif (unlikely(err))\n\t\t\tgoto badkey;\n\t\tbreak;\n\tcase SAFEXCEL_AES:\n\t\terr = aes_expandkey(&aes, keys.enckey, keys.enckeylen);\n\t\tif (unlikely(err))\n\t\t\tgoto badkey;\n\t\tbreak;\n\tcase SAFEXCEL_SM4:\n\t\tif (unlikely(keys.enckeylen != SM4_KEY_SIZE))\n\t\t\tgoto badkey;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"aead: unsupported cipher algorithm\\n\");\n\t\tgoto badkey;\n\t}\n\n\tif (priv->flags & EIP197_TRC_CACHE && ctx->base.ctxr_dma) {\n\t\tfor (i = 0; i < keys.enckeylen / sizeof(u32); i++) {\n\t\t\tif (le32_to_cpu(ctx->key[i]) !=\n\t\t\t    ((u32 *)keys.enckey)[i]) {\n\t\t\t\tctx->base.needs_inv = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tswitch (ctx->hash_alg) {\n\tcase CONTEXT_CONTROL_CRYPTO_ALG_SHA1:\n\t\talg = \"safexcel-sha1\";\n\t\tbreak;\n\tcase CONTEXT_CONTROL_CRYPTO_ALG_SHA224:\n\t\talg = \"safexcel-sha224\";\n\t\tbreak;\n\tcase CONTEXT_CONTROL_CRYPTO_ALG_SHA256:\n\t\talg = \"safexcel-sha256\";\n\t\tbreak;\n\tcase CONTEXT_CONTROL_CRYPTO_ALG_SHA384:\n\t\talg = \"safexcel-sha384\";\n\t\tbreak;\n\tcase CONTEXT_CONTROL_CRYPTO_ALG_SHA512:\n\t\talg = \"safexcel-sha512\";\n\t\tbreak;\n\tcase CONTEXT_CONTROL_CRYPTO_ALG_SM3:\n\t\talg = \"safexcel-sm3\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"aead: unsupported hash algorithm\\n\");\n\t\tgoto badkey;\n\t}\n\n\tif (safexcel_hmac_setkey(&ctx->base, keys.authkey, keys.authkeylen,\n\t\t\t\t alg, ctx->state_sz))\n\t\tgoto badkey;\n\n\t \n\tfor (i = 0; i < keys.enckeylen / sizeof(u32); i++)\n\t\tctx->key[i] = cpu_to_le32(((u32 *)keys.enckey)[i]);\n\tctx->key_len = keys.enckeylen;\n\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn 0;\n\nbadkey:\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn err;\n}\n\nstatic int safexcel_context_control(struct safexcel_cipher_ctx *ctx,\n\t\t\t\t    struct crypto_async_request *async,\n\t\t\t\t    struct safexcel_cipher_req *sreq,\n\t\t\t\t    struct safexcel_command_desc *cdesc)\n{\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tint ctrl_size = ctx->key_len / sizeof(u32);\n\n\tcdesc->control_data.control1 = ctx->mode;\n\n\tif (ctx->aead) {\n\t\t \n\t\tif (ctx->xcm) {\n\t\t\tctrl_size += ctx->state_sz / sizeof(u32);\n\t\t\tcdesc->control_data.control0 =\n\t\t\t\tCONTEXT_CONTROL_KEY_EN |\n\t\t\t\tCONTEXT_CONTROL_DIGEST_XCM |\n\t\t\t\tctx->hash_alg |\n\t\t\t\tCONTEXT_CONTROL_SIZE(ctrl_size);\n\t\t} else if (ctx->alg == SAFEXCEL_CHACHA20) {\n\t\t\t \n\t\t\tcdesc->control_data.control0 =\n\t\t\t\tCONTEXT_CONTROL_KEY_EN |\n\t\t\t\tCONTEXT_CONTROL_CRYPTO_ALG_CHACHA20 |\n\t\t\t\t(sreq->direction == SAFEXCEL_ENCRYPT ?\n\t\t\t\t\tCONTEXT_CONTROL_TYPE_ENCRYPT_HASH_OUT :\n\t\t\t\t\tCONTEXT_CONTROL_TYPE_HASH_DECRYPT_IN) |\n\t\t\t\tctx->hash_alg |\n\t\t\t\tCONTEXT_CONTROL_SIZE(ctrl_size);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tctrl_size += ctx->state_sz / sizeof(u32) * 2;\n\t\t\tcdesc->control_data.control0 =\n\t\t\t\tCONTEXT_CONTROL_KEY_EN |\n\t\t\t\tCONTEXT_CONTROL_DIGEST_HMAC |\n\t\t\t\tctx->hash_alg |\n\t\t\t\tCONTEXT_CONTROL_SIZE(ctrl_size);\n\t\t}\n\n\t\tif (sreq->direction == SAFEXCEL_ENCRYPT &&\n\t\t    (ctx->xcm == EIP197_XCM_MODE_CCM ||\n\t\t     ctx->aead == EIP197_AEAD_TYPE_IPSEC_ESP_GMAC))\n\t\t\tcdesc->control_data.control0 |=\n\t\t\t\tCONTEXT_CONTROL_TYPE_HASH_ENCRYPT_OUT;\n\t\telse if (sreq->direction == SAFEXCEL_ENCRYPT)\n\t\t\tcdesc->control_data.control0 |=\n\t\t\t\tCONTEXT_CONTROL_TYPE_ENCRYPT_HASH_OUT;\n\t\telse if (ctx->xcm == EIP197_XCM_MODE_CCM)\n\t\t\tcdesc->control_data.control0 |=\n\t\t\t\tCONTEXT_CONTROL_TYPE_DECRYPT_HASH_IN;\n\t\telse\n\t\t\tcdesc->control_data.control0 |=\n\t\t\t\tCONTEXT_CONTROL_TYPE_HASH_DECRYPT_IN;\n\t} else {\n\t\tif (sreq->direction == SAFEXCEL_ENCRYPT)\n\t\t\tcdesc->control_data.control0 =\n\t\t\t\tCONTEXT_CONTROL_TYPE_CRYPTO_OUT |\n\t\t\t\tCONTEXT_CONTROL_KEY_EN |\n\t\t\t\tCONTEXT_CONTROL_SIZE(ctrl_size);\n\t\telse\n\t\t\tcdesc->control_data.control0 =\n\t\t\t\tCONTEXT_CONTROL_TYPE_CRYPTO_IN |\n\t\t\t\tCONTEXT_CONTROL_KEY_EN |\n\t\t\t\tCONTEXT_CONTROL_SIZE(ctrl_size);\n\t}\n\n\tif (ctx->alg == SAFEXCEL_DES) {\n\t\tcdesc->control_data.control0 |=\n\t\t\tCONTEXT_CONTROL_CRYPTO_ALG_DES;\n\t} else if (ctx->alg == SAFEXCEL_3DES) {\n\t\tcdesc->control_data.control0 |=\n\t\t\tCONTEXT_CONTROL_CRYPTO_ALG_3DES;\n\t} else if (ctx->alg == SAFEXCEL_AES) {\n\t\tswitch (ctx->key_len >> ctx->xts) {\n\t\tcase AES_KEYSIZE_128:\n\t\t\tcdesc->control_data.control0 |=\n\t\t\t\tCONTEXT_CONTROL_CRYPTO_ALG_AES128;\n\t\t\tbreak;\n\t\tcase AES_KEYSIZE_192:\n\t\t\tcdesc->control_data.control0 |=\n\t\t\t\tCONTEXT_CONTROL_CRYPTO_ALG_AES192;\n\t\t\tbreak;\n\t\tcase AES_KEYSIZE_256:\n\t\t\tcdesc->control_data.control0 |=\n\t\t\t\tCONTEXT_CONTROL_CRYPTO_ALG_AES256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(priv->dev, \"aes keysize not supported: %u\\n\",\n\t\t\t\tctx->key_len >> ctx->xts);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (ctx->alg == SAFEXCEL_CHACHA20) {\n\t\tcdesc->control_data.control0 |=\n\t\t\tCONTEXT_CONTROL_CRYPTO_ALG_CHACHA20;\n\t} else if (ctx->alg == SAFEXCEL_SM4) {\n\t\tcdesc->control_data.control0 |=\n\t\t\tCONTEXT_CONTROL_CRYPTO_ALG_SM4;\n\t}\n\n\treturn 0;\n}\n\nstatic int safexcel_handle_req_result(struct safexcel_crypto_priv *priv, int ring,\n\t\t\t\t      struct crypto_async_request *async,\n\t\t\t\t      struct scatterlist *src,\n\t\t\t\t      struct scatterlist *dst,\n\t\t\t\t      unsigned int cryptlen,\n\t\t\t\t      struct safexcel_cipher_req *sreq,\n\t\t\t\t      bool *should_complete, int *ret)\n{\n\tstruct skcipher_request *areq = skcipher_request_cast(async);\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(areq);\n\tstruct safexcel_cipher_ctx *ctx = crypto_skcipher_ctx(skcipher);\n\tstruct safexcel_result_desc *rdesc;\n\tint ndesc = 0;\n\n\t*ret = 0;\n\n\tif (unlikely(!sreq->rdescs))\n\t\treturn 0;\n\n\twhile (sreq->rdescs--) {\n\t\trdesc = safexcel_ring_next_rptr(priv, &priv->ring[ring].rdr);\n\t\tif (IS_ERR(rdesc)) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"cipher: result: could not retrieve the result descriptor\\n\");\n\t\t\t*ret = PTR_ERR(rdesc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (likely(!*ret))\n\t\t\t*ret = safexcel_rdesc_check_errors(priv, rdesc);\n\n\t\tndesc++;\n\t}\n\n\tsafexcel_complete(priv, ring);\n\n\tif (src == dst) {\n\t\tif (sreq->nr_src > 0)\n\t\t\tdma_unmap_sg(priv->dev, src, sreq->nr_src,\n\t\t\t\t     DMA_BIDIRECTIONAL);\n\t} else {\n\t\tif (sreq->nr_src > 0)\n\t\t\tdma_unmap_sg(priv->dev, src, sreq->nr_src,\n\t\t\t\t     DMA_TO_DEVICE);\n\t\tif (sreq->nr_dst > 0)\n\t\t\tdma_unmap_sg(priv->dev, dst, sreq->nr_dst,\n\t\t\t\t     DMA_FROM_DEVICE);\n\t}\n\n\t \n\tif ((!ctx->aead) && (ctx->mode == CONTEXT_CONTROL_CRYPTO_MODE_CBC) &&\n\t    (sreq->direction == SAFEXCEL_ENCRYPT)) {\n\t\t \n\t\tsg_pcopy_to_buffer(dst, sreq->nr_dst, areq->iv,\n\t\t\t\t   crypto_skcipher_ivsize(skcipher),\n\t\t\t\t   (cryptlen -\n\t\t\t\t    crypto_skcipher_ivsize(skcipher)));\n\t}\n\n\t*should_complete = true;\n\n\treturn ndesc;\n}\n\nstatic int safexcel_send_req(struct crypto_async_request *base, int ring,\n\t\t\t     struct safexcel_cipher_req *sreq,\n\t\t\t     struct scatterlist *src, struct scatterlist *dst,\n\t\t\t     unsigned int cryptlen, unsigned int assoclen,\n\t\t\t     unsigned int digestsize, u8 *iv, int *commands,\n\t\t\t     int *results)\n{\n\tstruct skcipher_request *areq = skcipher_request_cast(base);\n\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(areq);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(base->tfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tstruct safexcel_command_desc *cdesc;\n\tstruct safexcel_command_desc *first_cdesc = NULL;\n\tstruct safexcel_result_desc *rdesc, *first_rdesc = NULL;\n\tstruct scatterlist *sg;\n\tunsigned int totlen;\n\tunsigned int totlen_src = cryptlen + assoclen;\n\tunsigned int totlen_dst = totlen_src;\n\tstruct safexcel_token *atoken;\n\tint n_cdesc = 0, n_rdesc = 0;\n\tint queued, i, ret = 0;\n\tbool first = true;\n\n\tsreq->nr_src = sg_nents_for_len(src, totlen_src);\n\n\tif (ctx->aead) {\n\t\t \n\t\tif (sreq->direction == SAFEXCEL_DECRYPT)\n\t\t\ttotlen_dst -= digestsize;\n\t\telse\n\t\t\ttotlen_dst += digestsize;\n\n\t\tmemcpy(ctx->base.ctxr->data + ctx->key_len / sizeof(u32),\n\t\t       &ctx->base.ipad, ctx->state_sz);\n\t\tif (!ctx->xcm)\n\t\t\tmemcpy(ctx->base.ctxr->data + (ctx->key_len +\n\t\t\t       ctx->state_sz) / sizeof(u32), &ctx->base.opad,\n\t\t\t       ctx->state_sz);\n\t} else if ((ctx->mode == CONTEXT_CONTROL_CRYPTO_MODE_CBC) &&\n\t\t   (sreq->direction == SAFEXCEL_DECRYPT)) {\n\t\t \n\t\tsg_pcopy_to_buffer(src, sreq->nr_src, areq->iv,\n\t\t\t\t   crypto_skcipher_ivsize(skcipher),\n\t\t\t\t   (totlen_src -\n\t\t\t\t    crypto_skcipher_ivsize(skcipher)));\n\t}\n\n\tsreq->nr_dst = sg_nents_for_len(dst, totlen_dst);\n\n\t \n\ttotlen = totlen_src;\n\tqueued = totlen_src;\n\n\tif (src == dst) {\n\t\tsreq->nr_src = max(sreq->nr_src, sreq->nr_dst);\n\t\tsreq->nr_dst = sreq->nr_src;\n\t\tif (unlikely((totlen_src || totlen_dst) &&\n\t\t    (sreq->nr_src <= 0))) {\n\t\t\tdev_err(priv->dev, \"In-place buffer not large enough (need %d bytes)!\",\n\t\t\t\tmax(totlen_src, totlen_dst));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sreq->nr_src > 0 &&\n\t\t    !dma_map_sg(priv->dev, src, sreq->nr_src, DMA_BIDIRECTIONAL))\n\t\t\treturn -EIO;\n\t} else {\n\t\tif (unlikely(totlen_src && (sreq->nr_src <= 0))) {\n\t\t\tdev_err(priv->dev, \"Source buffer not large enough (need %d bytes)!\",\n\t\t\t\ttotlen_src);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sreq->nr_src > 0 &&\n\t\t    !dma_map_sg(priv->dev, src, sreq->nr_src, DMA_TO_DEVICE))\n\t\t\treturn -EIO;\n\n\t\tif (unlikely(totlen_dst && (sreq->nr_dst <= 0))) {\n\t\t\tdev_err(priv->dev, \"Dest buffer not large enough (need %d bytes)!\",\n\t\t\t\ttotlen_dst);\n\t\t\tret = -EINVAL;\n\t\t\tgoto unmap;\n\t\t}\n\n\t\tif (sreq->nr_dst > 0 &&\n\t\t    !dma_map_sg(priv->dev, dst, sreq->nr_dst, DMA_FROM_DEVICE)) {\n\t\t\tret = -EIO;\n\t\t\tgoto unmap;\n\t\t}\n\t}\n\n\tmemcpy(ctx->base.ctxr->data, ctx->key, ctx->key_len);\n\n\tif (!totlen) {\n\t\t \n\t\tfirst_cdesc = safexcel_add_cdesc(priv, ring,\n\t\t\t\t\t\t 1, 1, ctx->base.ctxr_dma,\n\t\t\t\t\t\t 1, 1, ctx->base.ctxr_dma,\n\t\t\t\t\t\t &atoken);\n\t\tif (IS_ERR(first_cdesc)) {\n\t\t\t \n\t\t\tret = PTR_ERR(first_cdesc);\n\t\t\tgoto cdesc_rollback;\n\t\t}\n\t\tn_cdesc = 1;\n\t\tgoto skip_cdesc;\n\t}\n\n\t \n\tfor_each_sg(src, sg, sreq->nr_src, i) {\n\t\tint len = sg_dma_len(sg);\n\n\t\t \n\t\tif (queued < len)\n\t\t\tlen = queued;\n\n\t\tcdesc = safexcel_add_cdesc(priv, ring, !n_cdesc,\n\t\t\t\t\t   !(queued - len),\n\t\t\t\t\t   sg_dma_address(sg), len, totlen,\n\t\t\t\t\t   ctx->base.ctxr_dma, &atoken);\n\t\tif (IS_ERR(cdesc)) {\n\t\t\t \n\t\t\tret = PTR_ERR(cdesc);\n\t\t\tgoto cdesc_rollback;\n\t\t}\n\n\t\tif (!n_cdesc)\n\t\t\tfirst_cdesc = cdesc;\n\n\t\tn_cdesc++;\n\t\tqueued -= len;\n\t\tif (!queued)\n\t\t\tbreak;\n\t}\nskip_cdesc:\n\t \n\tsafexcel_context_control(ctx, base, sreq, first_cdesc);\n\tif (ctx->aead)\n\t\tsafexcel_aead_token(ctx, iv, first_cdesc, atoken,\n\t\t\t\t    sreq->direction, cryptlen,\n\t\t\t\t    assoclen, digestsize);\n\telse\n\t\tsafexcel_skcipher_token(ctx, iv, first_cdesc, atoken,\n\t\t\t\t\tcryptlen);\n\n\t \n\tfor_each_sg(dst, sg, sreq->nr_dst, i) {\n\t\tbool last = (i == sreq->nr_dst - 1);\n\t\tu32 len = sg_dma_len(sg);\n\n\t\t \n\t\tif (len > totlen_dst)\n\t\t\tlen = totlen_dst;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\ttotlen_dst -= len;\n\n\t\t \n\t\tif (assoclen) {\n\t\t\tif (assoclen >= len) {\n\t\t\t\tassoclen -= len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trdesc = safexcel_add_rdesc(priv, ring, first, last,\n\t\t\t\t\t\t   sg_dma_address(sg) +\n\t\t\t\t\t\t   assoclen,\n\t\t\t\t\t\t   len - assoclen);\n\t\t\tassoclen = 0;\n\t\t} else {\n\t\t\trdesc = safexcel_add_rdesc(priv, ring, first, last,\n\t\t\t\t\t\t   sg_dma_address(sg),\n\t\t\t\t\t\t   len);\n\t\t}\n\t\tif (IS_ERR(rdesc)) {\n\t\t\t \n\t\t\tret = PTR_ERR(rdesc);\n\t\t\tgoto rdesc_rollback;\n\t\t}\n\t\tif (first) {\n\t\t\tfirst_rdesc = rdesc;\n\t\t\tfirst = false;\n\t\t}\n\t\tn_rdesc++;\n\t}\n\n\tif (unlikely(first)) {\n\t\t \n\t\trdesc = safexcel_add_rdesc(priv, ring, true, true, 0, 0);\n\t\tif (IS_ERR(rdesc)) {\n\t\t\t \n\t\t\tret = PTR_ERR(rdesc);\n\t\t\tgoto rdesc_rollback;\n\t\t}\n\t\tfirst_rdesc = rdesc;\n\t\tn_rdesc = 1;\n\t}\n\n\tsafexcel_rdr_req_set(priv, ring, first_rdesc, base);\n\n\t*commands = n_cdesc;\n\t*results = n_rdesc;\n\treturn 0;\n\nrdesc_rollback:\n\tfor (i = 0; i < n_rdesc; i++)\n\t\tsafexcel_ring_rollback_wptr(priv, &priv->ring[ring].rdr);\ncdesc_rollback:\n\tfor (i = 0; i < n_cdesc; i++)\n\t\tsafexcel_ring_rollback_wptr(priv, &priv->ring[ring].cdr);\nunmap:\n\tif (src == dst) {\n\t\tif (sreq->nr_src > 0)\n\t\t\tdma_unmap_sg(priv->dev, src, sreq->nr_src,\n\t\t\t\t     DMA_BIDIRECTIONAL);\n\t} else {\n\t\tif (sreq->nr_src > 0)\n\t\t\tdma_unmap_sg(priv->dev, src, sreq->nr_src,\n\t\t\t\t     DMA_TO_DEVICE);\n\t\tif (sreq->nr_dst > 0)\n\t\t\tdma_unmap_sg(priv->dev, dst, sreq->nr_dst,\n\t\t\t\t     DMA_FROM_DEVICE);\n\t}\n\n\treturn ret;\n}\n\nstatic int safexcel_handle_inv_result(struct safexcel_crypto_priv *priv,\n\t\t\t\t      int ring,\n\t\t\t\t      struct crypto_async_request *base,\n\t\t\t\t      struct safexcel_cipher_req *sreq,\n\t\t\t\t      bool *should_complete, int *ret)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(base->tfm);\n\tstruct safexcel_result_desc *rdesc;\n\tint ndesc = 0, enq_ret;\n\n\t*ret = 0;\n\n\tif (unlikely(!sreq->rdescs))\n\t\treturn 0;\n\n\twhile (sreq->rdescs--) {\n\t\trdesc = safexcel_ring_next_rptr(priv, &priv->ring[ring].rdr);\n\t\tif (IS_ERR(rdesc)) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"cipher: invalidate: could not retrieve the result descriptor\\n\");\n\t\t\t*ret = PTR_ERR(rdesc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (likely(!*ret))\n\t\t\t*ret = safexcel_rdesc_check_errors(priv, rdesc);\n\n\t\tndesc++;\n\t}\n\n\tsafexcel_complete(priv, ring);\n\n\tif (ctx->base.exit_inv) {\n\t\tdma_pool_free(priv->context_pool, ctx->base.ctxr,\n\t\t\t      ctx->base.ctxr_dma);\n\n\t\t*should_complete = true;\n\n\t\treturn ndesc;\n\t}\n\n\tring = safexcel_select_ring(priv);\n\tctx->base.ring = ring;\n\n\tspin_lock_bh(&priv->ring[ring].queue_lock);\n\tenq_ret = crypto_enqueue_request(&priv->ring[ring].queue, base);\n\tspin_unlock_bh(&priv->ring[ring].queue_lock);\n\n\tif (enq_ret != -EINPROGRESS)\n\t\t*ret = enq_ret;\n\n\tqueue_work(priv->ring[ring].workqueue,\n\t\t   &priv->ring[ring].work_data.work);\n\n\t*should_complete = false;\n\n\treturn ndesc;\n}\n\nstatic int safexcel_skcipher_handle_result(struct safexcel_crypto_priv *priv,\n\t\t\t\t\t   int ring,\n\t\t\t\t\t   struct crypto_async_request *async,\n\t\t\t\t\t   bool *should_complete, int *ret)\n{\n\tstruct skcipher_request *req = skcipher_request_cast(async);\n\tstruct safexcel_cipher_req *sreq = skcipher_request_ctx(req);\n\tint err;\n\n\tif (sreq->needs_inv) {\n\t\tsreq->needs_inv = false;\n\t\terr = safexcel_handle_inv_result(priv, ring, async, sreq,\n\t\t\t\t\t\t should_complete, ret);\n\t} else {\n\t\terr = safexcel_handle_req_result(priv, ring, async, req->src,\n\t\t\t\t\t\t req->dst, req->cryptlen, sreq,\n\t\t\t\t\t\t should_complete, ret);\n\t}\n\n\treturn err;\n}\n\nstatic int safexcel_aead_handle_result(struct safexcel_crypto_priv *priv,\n\t\t\t\t       int ring,\n\t\t\t\t       struct crypto_async_request *async,\n\t\t\t\t       bool *should_complete, int *ret)\n{\n\tstruct aead_request *req = aead_request_cast(async);\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct safexcel_cipher_req *sreq = aead_request_ctx(req);\n\tint err;\n\n\tif (sreq->needs_inv) {\n\t\tsreq->needs_inv = false;\n\t\terr = safexcel_handle_inv_result(priv, ring, async, sreq,\n\t\t\t\t\t\t should_complete, ret);\n\t} else {\n\t\terr = safexcel_handle_req_result(priv, ring, async, req->src,\n\t\t\t\t\t\t req->dst,\n\t\t\t\t\t\t req->cryptlen + crypto_aead_authsize(tfm),\n\t\t\t\t\t\t sreq, should_complete, ret);\n\t}\n\n\treturn err;\n}\n\nstatic int safexcel_cipher_send_inv(struct crypto_async_request *base,\n\t\t\t\t    int ring, int *commands, int *results)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(base->tfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tint ret;\n\n\tret = safexcel_invalidate_cache(base, priv, ctx->base.ctxr_dma, ring);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t*commands = 1;\n\t*results = 1;\n\n\treturn 0;\n}\n\nstatic int safexcel_skcipher_send(struct crypto_async_request *async, int ring,\n\t\t\t\t  int *commands, int *results)\n{\n\tstruct skcipher_request *req = skcipher_request_cast(async);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\n\tstruct safexcel_cipher_req *sreq = skcipher_request_ctx(req);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tint ret;\n\n\tBUG_ON(!(priv->flags & EIP197_TRC_CACHE) && sreq->needs_inv);\n\n\tif (sreq->needs_inv) {\n\t\tret = safexcel_cipher_send_inv(async, ring, commands, results);\n\t} else {\n\t\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\t\tu8 input_iv[AES_BLOCK_SIZE];\n\n\t\t \n\t\tmemcpy(input_iv, req->iv, crypto_skcipher_ivsize(skcipher));\n\n\t\tret = safexcel_send_req(async, ring, sreq, req->src,\n\t\t\t\t\treq->dst, req->cryptlen, 0, 0, input_iv,\n\t\t\t\t\tcommands, results);\n\t}\n\n\tsreq->rdescs = *results;\n\treturn ret;\n}\n\nstatic int safexcel_aead_send(struct crypto_async_request *async, int ring,\n\t\t\t      int *commands, int *results)\n{\n\tstruct aead_request *req = aead_request_cast(async);\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\n\tstruct safexcel_cipher_req *sreq = aead_request_ctx(req);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tint ret;\n\n\tBUG_ON(!(priv->flags & EIP197_TRC_CACHE) && sreq->needs_inv);\n\n\tif (sreq->needs_inv)\n\t\tret = safexcel_cipher_send_inv(async, ring, commands, results);\n\telse\n\t\tret = safexcel_send_req(async, ring, sreq, req->src, req->dst,\n\t\t\t\t\treq->cryptlen, req->assoclen,\n\t\t\t\t\tcrypto_aead_authsize(tfm), req->iv,\n\t\t\t\t\tcommands, results);\n\tsreq->rdescs = *results;\n\treturn ret;\n}\n\nstatic int safexcel_cipher_exit_inv(struct crypto_tfm *tfm,\n\t\t\t\t    struct crypto_async_request *base,\n\t\t\t\t    struct safexcel_cipher_req *sreq,\n\t\t\t\t    struct crypto_wait *result)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tint ring = ctx->base.ring;\n\tint err;\n\n\tctx = crypto_tfm_ctx(base->tfm);\n\tctx->base.exit_inv = true;\n\tsreq->needs_inv = true;\n\n\tspin_lock_bh(&priv->ring[ring].queue_lock);\n\tcrypto_enqueue_request(&priv->ring[ring].queue, base);\n\tspin_unlock_bh(&priv->ring[ring].queue_lock);\n\n\tqueue_work(priv->ring[ring].workqueue,\n\t\t   &priv->ring[ring].work_data.work);\n\n\terr = crypto_wait_req(-EINPROGRESS, result);\n\n\tif (err) {\n\t\tdev_warn(priv->dev,\n\t\t\t\"cipher: sync: invalidate: completion error %d\\n\",\n\t\t\t err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int safexcel_skcipher_exit_inv(struct crypto_tfm *tfm)\n{\n\tEIP197_REQUEST_ON_STACK(req, skcipher, EIP197_SKCIPHER_REQ_SIZE);\n\tstruct safexcel_cipher_req *sreq = skcipher_request_ctx(req);\n\tDECLARE_CRYPTO_WAIT(result);\n\n\tmemset(req, 0, sizeof(struct skcipher_request));\n\n\tskcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      crypto_req_done, &result);\n\tskcipher_request_set_tfm(req, __crypto_skcipher_cast(tfm));\n\n\treturn safexcel_cipher_exit_inv(tfm, &req->base, sreq, &result);\n}\n\nstatic int safexcel_aead_exit_inv(struct crypto_tfm *tfm)\n{\n\tEIP197_REQUEST_ON_STACK(req, aead, EIP197_AEAD_REQ_SIZE);\n\tstruct safexcel_cipher_req *sreq = aead_request_ctx(req);\n\tDECLARE_CRYPTO_WAIT(result);\n\n\tmemset(req, 0, sizeof(struct aead_request));\n\n\taead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t  crypto_req_done, &result);\n\taead_request_set_tfm(req, __crypto_aead_cast(tfm));\n\n\treturn safexcel_cipher_exit_inv(tfm, &req->base, sreq, &result);\n}\n\nstatic int safexcel_queue_req(struct crypto_async_request *base,\n\t\t\tstruct safexcel_cipher_req *sreq,\n\t\t\tenum safexcel_cipher_direction dir)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(base->tfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tint ret, ring;\n\n\tsreq->needs_inv = false;\n\tsreq->direction = dir;\n\n\tif (ctx->base.ctxr) {\n\t\tif (priv->flags & EIP197_TRC_CACHE && ctx->base.needs_inv) {\n\t\t\tsreq->needs_inv = true;\n\t\t\tctx->base.needs_inv = false;\n\t\t}\n\t} else {\n\t\tctx->base.ring = safexcel_select_ring(priv);\n\t\tctx->base.ctxr = dma_pool_zalloc(priv->context_pool,\n\t\t\t\t\t\t EIP197_GFP_FLAGS(*base),\n\t\t\t\t\t\t &ctx->base.ctxr_dma);\n\t\tif (!ctx->base.ctxr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tring = ctx->base.ring;\n\n\tspin_lock_bh(&priv->ring[ring].queue_lock);\n\tret = crypto_enqueue_request(&priv->ring[ring].queue, base);\n\tspin_unlock_bh(&priv->ring[ring].queue_lock);\n\n\tqueue_work(priv->ring[ring].workqueue,\n\t\t   &priv->ring[ring].work_data.work);\n\n\treturn ret;\n}\n\nstatic int safexcel_encrypt(struct skcipher_request *req)\n{\n\treturn safexcel_queue_req(&req->base, skcipher_request_ctx(req),\n\t\t\tSAFEXCEL_ENCRYPT);\n}\n\nstatic int safexcel_decrypt(struct skcipher_request *req)\n{\n\treturn safexcel_queue_req(&req->base, skcipher_request_ctx(req),\n\t\t\tSAFEXCEL_DECRYPT);\n}\n\nstatic int safexcel_skcipher_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct safexcel_alg_template *tmpl =\n\t\tcontainer_of(tfm->__crt_alg, struct safexcel_alg_template,\n\t\t\t     alg.skcipher.base);\n\n\tcrypto_skcipher_set_reqsize(__crypto_skcipher_cast(tfm),\n\t\t\t\t    sizeof(struct safexcel_cipher_req));\n\n\tctx->base.priv = tmpl->priv;\n\n\tctx->base.send = safexcel_skcipher_send;\n\tctx->base.handle_result = safexcel_skcipher_handle_result;\n\tctx->ivmask = EIP197_OPTION_4_TOKEN_IV_CMD;\n\tctx->ctrinit = 1;\n\treturn 0;\n}\n\nstatic int safexcel_cipher_cra_exit(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tmemzero_explicit(ctx->key, sizeof(ctx->key));\n\n\t \n\tif (!ctx->base.ctxr)\n\t\treturn -ENOMEM;\n\n\tmemzero_explicit(ctx->base.ctxr->data, sizeof(ctx->base.ctxr->data));\n\treturn 0;\n}\n\nstatic void safexcel_skcipher_cra_exit(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tint ret;\n\n\tif (safexcel_cipher_cra_exit(tfm))\n\t\treturn;\n\n\tif (priv->flags & EIP197_TRC_CACHE) {\n\t\tret = safexcel_skcipher_exit_inv(tfm);\n\t\tif (ret)\n\t\t\tdev_warn(priv->dev, \"skcipher: invalidation error %d\\n\",\n\t\t\t\t ret);\n\t} else {\n\t\tdma_pool_free(priv->context_pool, ctx->base.ctxr,\n\t\t\t      ctx->base.ctxr_dma);\n\t}\n}\n\nstatic void safexcel_aead_cra_exit(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tint ret;\n\n\tif (safexcel_cipher_cra_exit(tfm))\n\t\treturn;\n\n\tif (priv->flags & EIP197_TRC_CACHE) {\n\t\tret = safexcel_aead_exit_inv(tfm);\n\t\tif (ret)\n\t\t\tdev_warn(priv->dev, \"aead: invalidation error %d\\n\",\n\t\t\t\t ret);\n\t} else {\n\t\tdma_pool_free(priv->context_pool, ctx->base.ctxr,\n\t\t\t      ctx->base.ctxr_dma);\n\t}\n}\n\nstatic int safexcel_skcipher_aes_ecb_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_AES;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_ECB;\n\tctx->blocksz = 0;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_ecb_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_AES,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_skcipher_aes_setkey,\n\t\t.encrypt = safexcel_encrypt,\n\t\t.decrypt = safexcel_decrypt,\n\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(aes)\",\n\t\t\t.cra_driver_name = \"safexcel-ecb-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_aes_ecb_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_skcipher_aes_cbc_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_AES;\n\tctx->blocksz = AES_BLOCK_SIZE;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CBC;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_cbc_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_AES,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_skcipher_aes_setkey,\n\t\t.encrypt = safexcel_encrypt,\n\t\t.decrypt = safexcel_decrypt,\n\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"cbc(aes)\",\n\t\t\t.cra_driver_name = \"safexcel-cbc-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_aes_cbc_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_skcipher_aes_cfb_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_AES;\n\tctx->blocksz = AES_BLOCK_SIZE;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CFB;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_cfb_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_AES_XFB,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_skcipher_aes_setkey,\n\t\t.encrypt = safexcel_encrypt,\n\t\t.decrypt = safexcel_decrypt,\n\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"cfb(aes)\",\n\t\t\t.cra_driver_name = \"safexcel-cfb-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_aes_cfb_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_skcipher_aes_ofb_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_AES;\n\tctx->blocksz = AES_BLOCK_SIZE;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_OFB;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_ofb_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_AES_XFB,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_skcipher_aes_setkey,\n\t\t.encrypt = safexcel_encrypt,\n\t\t.decrypt = safexcel_decrypt,\n\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"ofb(aes)\",\n\t\t\t.cra_driver_name = \"safexcel-ofb-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_aes_ofb_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_skcipher_aesctr_setkey(struct crypto_skcipher *ctfm,\n\t\t\t\t\t   const u8 *key, unsigned int len)\n{\n\tstruct crypto_tfm *tfm = crypto_skcipher_tfm(ctfm);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tstruct crypto_aes_ctx aes;\n\tint ret, i;\n\tunsigned int keylen;\n\n\t \n\tctx->nonce = *(u32 *)(key + len - CTR_RFC3686_NONCE_SIZE);\n\t \n\tkeylen = len - CTR_RFC3686_NONCE_SIZE;\n\tret = aes_expandkey(&aes, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->flags & EIP197_TRC_CACHE && ctx->base.ctxr_dma) {\n\t\tfor (i = 0; i < keylen / sizeof(u32); i++) {\n\t\t\tif (le32_to_cpu(ctx->key[i]) != aes.key_enc[i]) {\n\t\t\t\tctx->base.needs_inv = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < keylen / sizeof(u32); i++)\n\t\tctx->key[i] = cpu_to_le32(aes.key_enc[i]);\n\n\tctx->key_len = keylen;\n\n\tmemzero_explicit(&aes, sizeof(aes));\n\treturn 0;\n}\n\nstatic int safexcel_skcipher_aes_ctr_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_AES;\n\tctx->blocksz = AES_BLOCK_SIZE;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CTR_LOAD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_ctr_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_AES,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_skcipher_aesctr_setkey,\n\t\t.encrypt = safexcel_encrypt,\n\t\t.decrypt = safexcel_decrypt,\n\t\t \n\t\t.min_keysize = AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,\n\t\t.max_keysize = AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,\n\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"rfc3686(ctr(aes))\",\n\t\t\t.cra_driver_name = \"safexcel-ctr-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_aes_ctr_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_des_setkey(struct crypto_skcipher *ctfm, const u8 *key,\n\t\t\t       unsigned int len)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_skcipher_ctx(ctfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tint ret;\n\n\tret = verify_skcipher_des_key(ctfm, key);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (priv->flags & EIP197_TRC_CACHE && ctx->base.ctxr_dma)\n\t\tif (memcmp(ctx->key, key, len))\n\t\t\tctx->base.needs_inv = true;\n\n\tmemcpy(ctx->key, key, len);\n\tctx->key_len = len;\n\n\treturn 0;\n}\n\nstatic int safexcel_skcipher_des_cbc_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_DES;\n\tctx->blocksz = DES_BLOCK_SIZE;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CBC;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_cbc_des = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_DES,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_des_setkey,\n\t\t.encrypt = safexcel_encrypt,\n\t\t.decrypt = safexcel_decrypt,\n\t\t.min_keysize = DES_KEY_SIZE,\n\t\t.max_keysize = DES_KEY_SIZE,\n\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"cbc(des)\",\n\t\t\t.cra_driver_name = \"safexcel-cbc-des\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_des_cbc_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_skcipher_des_ecb_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_DES;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_ECB;\n\tctx->blocksz = 0;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_ecb_des = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_DES,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_des_setkey,\n\t\t.encrypt = safexcel_encrypt,\n\t\t.decrypt = safexcel_decrypt,\n\t\t.min_keysize = DES_KEY_SIZE,\n\t\t.max_keysize = DES_KEY_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(des)\",\n\t\t\t.cra_driver_name = \"safexcel-ecb-des\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_des_ecb_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_des3_ede_setkey(struct crypto_skcipher *ctfm,\n\t\t\t\t   const u8 *key, unsigned int len)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_skcipher_ctx(ctfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tint err;\n\n\terr = verify_skcipher_des3_key(ctfm, key);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (priv->flags & EIP197_TRC_CACHE && ctx->base.ctxr_dma)\n\t\tif (memcmp(ctx->key, key, len))\n\t\t\tctx->base.needs_inv = true;\n\n\tmemcpy(ctx->key, key, len);\n\tctx->key_len = len;\n\n\treturn 0;\n}\n\nstatic int safexcel_skcipher_des3_cbc_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_3DES;\n\tctx->blocksz = DES3_EDE_BLOCK_SIZE;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CBC;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_cbc_des3_ede = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_DES,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_des3_ede_setkey,\n\t\t.encrypt = safexcel_encrypt,\n\t\t.decrypt = safexcel_decrypt,\n\t\t.min_keysize = DES3_EDE_KEY_SIZE,\n\t\t.max_keysize = DES3_EDE_KEY_SIZE,\n\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"cbc(des3_ede)\",\n\t\t\t.cra_driver_name = \"safexcel-cbc-des3_ede\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_des3_cbc_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_skcipher_des3_ecb_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_3DES;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_ECB;\n\tctx->blocksz = 0;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_ecb_des3_ede = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_DES,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_des3_ede_setkey,\n\t\t.encrypt = safexcel_encrypt,\n\t\t.decrypt = safexcel_decrypt,\n\t\t.min_keysize = DES3_EDE_KEY_SIZE,\n\t\t.max_keysize = DES3_EDE_KEY_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(des3_ede)\",\n\t\t\t.cra_driver_name = \"safexcel-ecb-des3_ede\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_des3_ecb_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_encrypt(struct aead_request *req)\n{\n\tstruct safexcel_cipher_req *creq = aead_request_ctx(req);\n\n\treturn safexcel_queue_req(&req->base, creq, SAFEXCEL_ENCRYPT);\n}\n\nstatic int safexcel_aead_decrypt(struct aead_request *req)\n{\n\tstruct safexcel_cipher_req *creq = aead_request_ctx(req);\n\n\treturn safexcel_queue_req(&req->base, creq, SAFEXCEL_DECRYPT);\n}\n\nstatic int safexcel_aead_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct safexcel_alg_template *tmpl =\n\t\tcontainer_of(tfm->__crt_alg, struct safexcel_alg_template,\n\t\t\t     alg.aead.base);\n\n\tcrypto_aead_set_reqsize(__crypto_aead_cast(tfm),\n\t\t\t\tsizeof(struct safexcel_cipher_req));\n\n\tctx->base.priv = tmpl->priv;\n\n\tctx->alg  = SAFEXCEL_AES;  \n\tctx->blocksz = AES_BLOCK_SIZE;\n\tctx->ivmask = EIP197_OPTION_4_TOKEN_IV_CMD;\n\tctx->ctrinit = 1;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CBC;  \n\tctx->aead = true;\n\tctx->base.send = safexcel_aead_send;\n\tctx->base.handle_result = safexcel_aead_handle_result;\n\treturn 0;\n}\n\nstatic int safexcel_aead_sha1_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_cra_init(tfm);\n\tctx->hash_alg = CONTEXT_CONTROL_CRYPTO_ALG_SHA1;\n\tctx->state_sz = SHA1_DIGEST_SIZE;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha1_cbc_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_SHA1,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha1),cbc(aes))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha1-cbc-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha1_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha256_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_cra_init(tfm);\n\tctx->hash_alg = CONTEXT_CONTROL_CRYPTO_ALG_SHA256;\n\tctx->state_sz = SHA256_DIGEST_SIZE;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha256_cbc_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_SHA2_256,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha256),cbc(aes))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha256-cbc-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha256_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha224_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_cra_init(tfm);\n\tctx->hash_alg = CONTEXT_CONTROL_CRYPTO_ALG_SHA224;\n\tctx->state_sz = SHA256_DIGEST_SIZE;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha224_cbc_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_SHA2_256,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha224),cbc(aes))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha224-cbc-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha224_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha512_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_cra_init(tfm);\n\tctx->hash_alg = CONTEXT_CONTROL_CRYPTO_ALG_SHA512;\n\tctx->state_sz = SHA512_DIGEST_SIZE;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha512_cbc_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_SHA2_512,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha512),cbc(aes))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha512-cbc-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha512_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha384_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_cra_init(tfm);\n\tctx->hash_alg = CONTEXT_CONTROL_CRYPTO_ALG_SHA384;\n\tctx->state_sz = SHA512_DIGEST_SIZE;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha384_cbc_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_SHA2_512,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha384),cbc(aes))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha384-cbc-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha384_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha1_des3_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha1_cra_init(tfm);\n\tctx->alg = SAFEXCEL_3DES;  \n\tctx->blocksz = DES3_EDE_BLOCK_SIZE;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha1_cbc_des3_ede = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_DES | SAFEXCEL_ALG_SHA1,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha1),cbc(des3_ede))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha1-cbc-des3_ede\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha1_des3_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha256_des3_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha256_cra_init(tfm);\n\tctx->alg = SAFEXCEL_3DES;  \n\tctx->blocksz = DES3_EDE_BLOCK_SIZE;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha256_cbc_des3_ede = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_DES | SAFEXCEL_ALG_SHA2_256,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha256),cbc(des3_ede))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha256-cbc-des3_ede\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha256_des3_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha224_des3_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha224_cra_init(tfm);\n\tctx->alg = SAFEXCEL_3DES;  \n\tctx->blocksz = DES3_EDE_BLOCK_SIZE;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha224_cbc_des3_ede = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_DES | SAFEXCEL_ALG_SHA2_256,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha224),cbc(des3_ede))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha224-cbc-des3_ede\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha224_des3_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha512_des3_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha512_cra_init(tfm);\n\tctx->alg = SAFEXCEL_3DES;  \n\tctx->blocksz = DES3_EDE_BLOCK_SIZE;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha512_cbc_des3_ede = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_DES | SAFEXCEL_ALG_SHA2_512,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha512),cbc(des3_ede))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha512-cbc-des3_ede\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha512_des3_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha384_des3_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha384_cra_init(tfm);\n\tctx->alg = SAFEXCEL_3DES;  \n\tctx->blocksz = DES3_EDE_BLOCK_SIZE;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha384_cbc_des3_ede = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_DES | SAFEXCEL_ALG_SHA2_512,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha384),cbc(des3_ede))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha384-cbc-des3_ede\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha384_des3_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha1_des_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha1_cra_init(tfm);\n\tctx->alg = SAFEXCEL_DES;  \n\tctx->blocksz = DES_BLOCK_SIZE;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha1_cbc_des = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_DES | SAFEXCEL_ALG_SHA1,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha1),cbc(des))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha1-cbc-des\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha1_des_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha256_des_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha256_cra_init(tfm);\n\tctx->alg = SAFEXCEL_DES;  \n\tctx->blocksz = DES_BLOCK_SIZE;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha256_cbc_des = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_DES | SAFEXCEL_ALG_SHA2_256,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha256),cbc(des))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha256-cbc-des\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha256_des_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha224_des_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha224_cra_init(tfm);\n\tctx->alg = SAFEXCEL_DES;  \n\tctx->blocksz = DES_BLOCK_SIZE;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha224_cbc_des = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_DES | SAFEXCEL_ALG_SHA2_256,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha224),cbc(des))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha224-cbc-des\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha224_des_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha512_des_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha512_cra_init(tfm);\n\tctx->alg = SAFEXCEL_DES;  \n\tctx->blocksz = DES_BLOCK_SIZE;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha512_cbc_des = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_DES | SAFEXCEL_ALG_SHA2_512,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha512),cbc(des))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha512-cbc-des\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha512_des_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha384_des_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha384_cra_init(tfm);\n\tctx->alg = SAFEXCEL_DES;  \n\tctx->blocksz = DES_BLOCK_SIZE;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha384_cbc_des = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_DES | SAFEXCEL_ALG_SHA2_512,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha384),cbc(des))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha384-cbc-des\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha384_des_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha1_ctr_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha1_cra_init(tfm);\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CTR_LOAD;  \n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha1_ctr_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_SHA1,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha1),rfc3686(ctr(aes)))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha1-ctr-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha1_ctr_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha256_ctr_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha256_cra_init(tfm);\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CTR_LOAD;  \n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha256_ctr_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_SHA2_256,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha256),rfc3686(ctr(aes)))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha256-ctr-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha256_ctr_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha224_ctr_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha224_cra_init(tfm);\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CTR_LOAD;  \n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha224_ctr_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_SHA2_256,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha224),rfc3686(ctr(aes)))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha224-ctr-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha224_ctr_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha512_ctr_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha512_cra_init(tfm);\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CTR_LOAD;  \n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha512_ctr_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_SHA2_512,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha512),rfc3686(ctr(aes)))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha512-ctr-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha512_ctr_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sha384_ctr_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sha384_cra_init(tfm);\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CTR_LOAD;  \n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha384_ctr_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_SHA2_512,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha384),rfc3686(ctr(aes)))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha384-ctr-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sha384_ctr_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_skcipher_aesxts_setkey(struct crypto_skcipher *ctfm,\n\t\t\t\t\t   const u8 *key, unsigned int len)\n{\n\tstruct crypto_tfm *tfm = crypto_skcipher_tfm(ctfm);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tstruct crypto_aes_ctx aes;\n\tint ret, i;\n\tunsigned int keylen;\n\n\t \n\tret = xts_verify_key(ctfm, key, len);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tkeylen = (len >> 1);\n\tret = aes_expandkey(&aes, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->flags & EIP197_TRC_CACHE && ctx->base.ctxr_dma) {\n\t\tfor (i = 0; i < keylen / sizeof(u32); i++) {\n\t\t\tif (le32_to_cpu(ctx->key[i]) != aes.key_enc[i]) {\n\t\t\t\tctx->base.needs_inv = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < keylen / sizeof(u32); i++)\n\t\tctx->key[i] = cpu_to_le32(aes.key_enc[i]);\n\n\t \n\tret = aes_expandkey(&aes, (u8 *)(key + keylen), keylen);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->flags & EIP197_TRC_CACHE && ctx->base.ctxr_dma) {\n\t\tfor (i = 0; i < keylen / sizeof(u32); i++) {\n\t\t\tif (le32_to_cpu(ctx->key[i + keylen / sizeof(u32)]) !=\n\t\t\t    aes.key_enc[i]) {\n\t\t\t\tctx->base.needs_inv = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < keylen / sizeof(u32); i++)\n\t\tctx->key[i + keylen / sizeof(u32)] =\n\t\t\tcpu_to_le32(aes.key_enc[i]);\n\n\tctx->key_len = keylen << 1;\n\n\tmemzero_explicit(&aes, sizeof(aes));\n\treturn 0;\n}\n\nstatic int safexcel_skcipher_aes_xts_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_AES;\n\tctx->blocksz = AES_BLOCK_SIZE;\n\tctx->xts  = 1;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_XTS;\n\treturn 0;\n}\n\nstatic int safexcel_encrypt_xts(struct skcipher_request *req)\n{\n\tif (req->cryptlen < XTS_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\treturn safexcel_queue_req(&req->base, skcipher_request_ctx(req),\n\t\t\t\t  SAFEXCEL_ENCRYPT);\n}\n\nstatic int safexcel_decrypt_xts(struct skcipher_request *req)\n{\n\tif (req->cryptlen < XTS_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\treturn safexcel_queue_req(&req->base, skcipher_request_ctx(req),\n\t\t\t\t  SAFEXCEL_DECRYPT);\n}\n\nstruct safexcel_alg_template safexcel_alg_xts_aes = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_AES_XTS,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_skcipher_aesxts_setkey,\n\t\t.encrypt = safexcel_encrypt_xts,\n\t\t.decrypt = safexcel_decrypt_xts,\n\t\t \n\t\t.min_keysize = AES_MIN_KEY_SIZE * 2,\n\t\t.max_keysize = AES_MAX_KEY_SIZE * 2,\n\t\t.ivsize = XTS_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"xts(aes)\",\n\t\t\t.cra_driver_name = \"safexcel-xts-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = XTS_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_aes_xts_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_gcm_setkey(struct crypto_aead *ctfm, const u8 *key,\n\t\t\t\t    unsigned int len)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(ctfm);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tstruct crypto_aes_ctx aes;\n\tu32 hashkey[AES_BLOCK_SIZE >> 2];\n\tint ret, i;\n\n\tret = aes_expandkey(&aes, key, len);\n\tif (ret) {\n\t\tmemzero_explicit(&aes, sizeof(aes));\n\t\treturn ret;\n\t}\n\n\tif (priv->flags & EIP197_TRC_CACHE && ctx->base.ctxr_dma) {\n\t\tfor (i = 0; i < len / sizeof(u32); i++) {\n\t\t\tif (le32_to_cpu(ctx->key[i]) != aes.key_enc[i]) {\n\t\t\t\tctx->base.needs_inv = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < len / sizeof(u32); i++)\n\t\tctx->key[i] = cpu_to_le32(aes.key_enc[i]);\n\n\tctx->key_len = len;\n\n\t \n\tmemset(hashkey, 0, AES_BLOCK_SIZE);\n\taes_encrypt(&aes, (u8 *)hashkey, (u8 *)hashkey);\n\n\tif (priv->flags & EIP197_TRC_CACHE && ctx->base.ctxr_dma) {\n\t\tfor (i = 0; i < AES_BLOCK_SIZE / sizeof(u32); i++) {\n\t\t\tif (be32_to_cpu(ctx->base.ipad.be[i]) != hashkey[i]) {\n\t\t\t\tctx->base.needs_inv = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < AES_BLOCK_SIZE / sizeof(u32); i++)\n\t\tctx->base.ipad.be[i] = cpu_to_be32(hashkey[i]);\n\n\tmemzero_explicit(hashkey, AES_BLOCK_SIZE);\n\tmemzero_explicit(&aes, sizeof(aes));\n\treturn 0;\n}\n\nstatic int safexcel_aead_gcm_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_cra_init(tfm);\n\tctx->hash_alg = CONTEXT_CONTROL_CRYPTO_ALG_GHASH;\n\tctx->state_sz = GHASH_BLOCK_SIZE;\n\tctx->xcm = EIP197_XCM_MODE_GCM;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_XCM;  \n\n\treturn 0;\n}\n\nstatic void safexcel_aead_gcm_cra_exit(struct crypto_tfm *tfm)\n{\n\tsafexcel_aead_cra_exit(tfm);\n}\n\nstatic int safexcel_aead_gcm_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t\t unsigned int authsize)\n{\n\treturn crypto_gcm_check_authsize(authsize);\n}\n\nstruct safexcel_alg_template safexcel_alg_gcm = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_GHASH,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_gcm_setkey,\n\t\t.setauthsize = safexcel_aead_gcm_setauthsize,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = GCM_AES_IV_SIZE,\n\t\t.maxauthsize = GHASH_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"gcm(aes)\",\n\t\t\t.cra_driver_name = \"safexcel-gcm-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_gcm_cra_init,\n\t\t\t.cra_exit = safexcel_aead_gcm_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_ccm_setkey(struct crypto_aead *ctfm, const u8 *key,\n\t\t\t\t    unsigned int len)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(ctfm);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\tstruct crypto_aes_ctx aes;\n\tint ret, i;\n\n\tret = aes_expandkey(&aes, key, len);\n\tif (ret) {\n\t\tmemzero_explicit(&aes, sizeof(aes));\n\t\treturn ret;\n\t}\n\n\tif (priv->flags & EIP197_TRC_CACHE && ctx->base.ctxr_dma) {\n\t\tfor (i = 0; i < len / sizeof(u32); i++) {\n\t\t\tif (le32_to_cpu(ctx->key[i]) != aes.key_enc[i]) {\n\t\t\t\tctx->base.needs_inv = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < len / sizeof(u32); i++) {\n\t\tctx->key[i] = cpu_to_le32(aes.key_enc[i]);\n\t\tctx->base.ipad.be[i + 2 * AES_BLOCK_SIZE / sizeof(u32)] =\n\t\t\tcpu_to_be32(aes.key_enc[i]);\n\t}\n\n\tctx->key_len = len;\n\tctx->state_sz = 2 * AES_BLOCK_SIZE + len;\n\n\tif (len == AES_KEYSIZE_192)\n\t\tctx->hash_alg = CONTEXT_CONTROL_CRYPTO_ALG_XCBC192;\n\telse if (len == AES_KEYSIZE_256)\n\t\tctx->hash_alg = CONTEXT_CONTROL_CRYPTO_ALG_XCBC256;\n\telse\n\t\tctx->hash_alg = CONTEXT_CONTROL_CRYPTO_ALG_XCBC128;\n\n\tmemzero_explicit(&aes, sizeof(aes));\n\treturn 0;\n}\n\nstatic int safexcel_aead_ccm_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_cra_init(tfm);\n\tctx->hash_alg = CONTEXT_CONTROL_CRYPTO_ALG_XCBC128;\n\tctx->state_sz = 3 * AES_BLOCK_SIZE;\n\tctx->xcm = EIP197_XCM_MODE_CCM;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_XCM;  \n\tctx->ctrinit = 0;\n\treturn 0;\n}\n\nstatic int safexcel_aead_ccm_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t\t unsigned int authsize)\n{\n\t \n\tswitch (authsize) {\n\tcase 4:\n\tcase 6:\n\tcase 8:\n\tcase 10:\n\tcase 12:\n\tcase 14:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int safexcel_ccm_encrypt(struct aead_request *req)\n{\n\tstruct safexcel_cipher_req *creq = aead_request_ctx(req);\n\n\tif (req->iv[0] < 1 || req->iv[0] > 7)\n\t\treturn -EINVAL;\n\n\treturn safexcel_queue_req(&req->base, creq, SAFEXCEL_ENCRYPT);\n}\n\nstatic int safexcel_ccm_decrypt(struct aead_request *req)\n{\n\tstruct safexcel_cipher_req *creq = aead_request_ctx(req);\n\n\tif (req->iv[0] < 1 || req->iv[0] > 7)\n\t\treturn -EINVAL;\n\n\treturn safexcel_queue_req(&req->base, creq, SAFEXCEL_DECRYPT);\n}\n\nstruct safexcel_alg_template safexcel_alg_ccm = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_CBC_MAC_ALL,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_ccm_setkey,\n\t\t.setauthsize = safexcel_aead_ccm_setauthsize,\n\t\t.encrypt = safexcel_ccm_encrypt,\n\t\t.decrypt = safexcel_ccm_decrypt,\n\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"ccm(aes)\",\n\t\t\t.cra_driver_name = \"safexcel-ccm-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_ccm_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic void safexcel_chacha20_setkey(struct safexcel_cipher_ctx *ctx,\n\t\t\t\t     const u8 *key)\n{\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\n\tif (priv->flags & EIP197_TRC_CACHE && ctx->base.ctxr_dma)\n\t\tif (memcmp(ctx->key, key, CHACHA_KEY_SIZE))\n\t\t\tctx->base.needs_inv = true;\n\n\tmemcpy(ctx->key, key, CHACHA_KEY_SIZE);\n\tctx->key_len = CHACHA_KEY_SIZE;\n}\n\nstatic int safexcel_skcipher_chacha20_setkey(struct crypto_skcipher *ctfm,\n\t\t\t\t\t     const u8 *key, unsigned int len)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_skcipher_ctx(ctfm);\n\n\tif (len != CHACHA_KEY_SIZE)\n\t\treturn -EINVAL;\n\n\tsafexcel_chacha20_setkey(ctx, key);\n\n\treturn 0;\n}\n\nstatic int safexcel_skcipher_chacha20_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_CHACHA20;\n\tctx->ctrinit = 0;\n\tctx->mode = CONTEXT_CONTROL_CHACHA20_MODE_256_32;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_chacha20 = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_CHACHA20,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_skcipher_chacha20_setkey,\n\t\t.encrypt = safexcel_encrypt,\n\t\t.decrypt = safexcel_decrypt,\n\t\t.min_keysize = CHACHA_KEY_SIZE,\n\t\t.max_keysize = CHACHA_KEY_SIZE,\n\t\t.ivsize = CHACHA_IV_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"chacha20\",\n\t\t\t.cra_driver_name = \"safexcel-chacha20\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_chacha20_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_chachapoly_setkey(struct crypto_aead *ctfm,\n\t\t\t\t    const u8 *key, unsigned int len)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_aead_ctx(ctfm);\n\n\tif (ctx->aead  == EIP197_AEAD_TYPE_IPSEC_ESP &&\n\t    len > EIP197_AEAD_IPSEC_NONCE_SIZE) {\n\t\t \n\t\tlen -= EIP197_AEAD_IPSEC_NONCE_SIZE;\n\t\tctx->nonce = *(u32 *)(key + len);\n\t}\n\tif (len != CHACHA_KEY_SIZE)\n\t\treturn -EINVAL;\n\n\tsafexcel_chacha20_setkey(ctx, key);\n\n\treturn 0;\n}\n\nstatic int safexcel_aead_chachapoly_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t\t unsigned int authsize)\n{\n\tif (authsize != POLY1305_DIGEST_SIZE)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int safexcel_aead_chachapoly_crypt(struct aead_request *req,\n\t\t\t\t\t  enum safexcel_cipher_direction dir)\n{\n\tstruct safexcel_cipher_req *creq = aead_request_ctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(aead);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct aead_request *subreq = aead_request_ctx(req);\n\tu32 key[CHACHA_KEY_SIZE / sizeof(u32) + 1];\n\tint ret = 0;\n\n\t \n\tif (likely((ctx->aead != EIP197_AEAD_TYPE_IPSEC_ESP ||\n\t\t    req->assoclen >= EIP197_AEAD_IPSEC_IV_SIZE) &&\n\t\t   req->cryptlen > POLY1305_DIGEST_SIZE)) {\n\t\treturn safexcel_queue_req(&req->base, creq, dir);\n\t}\n\n\t \n\tmemcpy(key, ctx->key, CHACHA_KEY_SIZE);\n\tif (ctx->aead == EIP197_AEAD_TYPE_IPSEC_ESP) {\n\t\t \n\t\tkey[CHACHA_KEY_SIZE / sizeof(u32)] = ctx->nonce;\n\t\tret = crypto_aead_setkey(ctx->fback, (u8 *)key,\n\t\t\t\t\t CHACHA_KEY_SIZE +\n\t\t\t\t\t EIP197_AEAD_IPSEC_NONCE_SIZE);\n\t} else {\n\t\tret = crypto_aead_setkey(ctx->fback, (u8 *)key,\n\t\t\t\t\t CHACHA_KEY_SIZE);\n\t}\n\tif (ret) {\n\t\tcrypto_aead_clear_flags(aead, CRYPTO_TFM_REQ_MASK);\n\t\tcrypto_aead_set_flags(aead, crypto_aead_get_flags(ctx->fback) &\n\t\t\t\t\t    CRYPTO_TFM_REQ_MASK);\n\t\treturn ret;\n\t}\n\n\taead_request_set_tfm(subreq, ctx->fback);\n\taead_request_set_callback(subreq, req->base.flags, req->base.complete,\n\t\t\t\t  req->base.data);\n\taead_request_set_crypt(subreq, req->src, req->dst, req->cryptlen,\n\t\t\t       req->iv);\n\taead_request_set_ad(subreq, req->assoclen);\n\n\treturn (dir ==  SAFEXCEL_ENCRYPT) ?\n\t\tcrypto_aead_encrypt(subreq) :\n\t\tcrypto_aead_decrypt(subreq);\n}\n\nstatic int safexcel_aead_chachapoly_encrypt(struct aead_request *req)\n{\n\treturn safexcel_aead_chachapoly_crypt(req, SAFEXCEL_ENCRYPT);\n}\n\nstatic int safexcel_aead_chachapoly_decrypt(struct aead_request *req)\n{\n\treturn safexcel_aead_chachapoly_crypt(req, SAFEXCEL_DECRYPT);\n}\n\nstatic int safexcel_aead_fallback_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct crypto_aead *aead = __crypto_aead_cast(tfm);\n\tstruct aead_alg *alg = crypto_aead_alg(aead);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_cra_init(tfm);\n\n\t \n\tctx->fback = crypto_alloc_aead(alg->base.cra_name, 0,\n\t\t\t\t       CRYPTO_ALG_ASYNC |\n\t\t\t\t       CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(ctx->fback))\n\t\treturn PTR_ERR(ctx->fback);\n\n\tcrypto_aead_set_reqsize(aead, max(sizeof(struct safexcel_cipher_req),\n\t\t\t\t\t  sizeof(struct aead_request) +\n\t\t\t\t\t  crypto_aead_reqsize(ctx->fback)));\n\n\treturn 0;\n}\n\nstatic int safexcel_aead_chachapoly_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_fallback_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_CHACHA20;\n\tctx->mode = CONTEXT_CONTROL_CHACHA20_MODE_256_32 |\n\t\t    CONTEXT_CONTROL_CHACHA20_MODE_CALC_OTK;\n\tctx->ctrinit = 0;\n\tctx->hash_alg = CONTEXT_CONTROL_CRYPTO_ALG_POLY1305;\n\tctx->state_sz = 0;  \n\treturn 0;\n}\n\nstatic void safexcel_aead_fallback_cra_exit(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tcrypto_free_aead(ctx->fback);\n\tsafexcel_aead_cra_exit(tfm);\n}\n\nstruct safexcel_alg_template safexcel_alg_chachapoly = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_CHACHA20 | SAFEXCEL_ALG_POLY1305,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_chachapoly_setkey,\n\t\t.setauthsize = safexcel_aead_chachapoly_setauthsize,\n\t\t.encrypt = safexcel_aead_chachapoly_encrypt,\n\t\t.decrypt = safexcel_aead_chachapoly_decrypt,\n\t\t.ivsize = CHACHAPOLY_IV_SIZE,\n\t\t.maxauthsize = POLY1305_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"rfc7539(chacha20,poly1305)\",\n\t\t\t.cra_driver_name = \"safexcel-chacha20-poly1305\",\n\t\t\t \n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY + 1,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t     CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_chachapoly_cra_init,\n\t\t\t.cra_exit = safexcel_aead_fallback_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_chachapolyesp_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tint ret;\n\n\tret = safexcel_aead_chachapoly_cra_init(tfm);\n\tctx->aead  = EIP197_AEAD_TYPE_IPSEC_ESP;\n\tctx->aadskip = EIP197_AEAD_IPSEC_IV_SIZE;\n\treturn ret;\n}\n\nstruct safexcel_alg_template safexcel_alg_chachapoly_esp = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_CHACHA20 | SAFEXCEL_ALG_POLY1305,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_chachapoly_setkey,\n\t\t.setauthsize = safexcel_aead_chachapoly_setauthsize,\n\t\t.encrypt = safexcel_aead_chachapoly_encrypt,\n\t\t.decrypt = safexcel_aead_chachapoly_decrypt,\n\t\t.ivsize = CHACHAPOLY_IV_SIZE - EIP197_AEAD_IPSEC_NONCE_SIZE,\n\t\t.maxauthsize = POLY1305_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"rfc7539esp(chacha20,poly1305)\",\n\t\t\t.cra_driver_name = \"safexcel-chacha20-poly1305-esp\",\n\t\t\t \n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY + 1,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t     CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_chachapolyesp_cra_init,\n\t\t\t.cra_exit = safexcel_aead_fallback_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_skcipher_sm4_setkey(struct crypto_skcipher *ctfm,\n\t\t\t\t\tconst u8 *key, unsigned int len)\n{\n\tstruct crypto_tfm *tfm = crypto_skcipher_tfm(ctfm);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct safexcel_crypto_priv *priv = ctx->base.priv;\n\n\tif (len != SM4_KEY_SIZE)\n\t\treturn -EINVAL;\n\n\tif (priv->flags & EIP197_TRC_CACHE && ctx->base.ctxr_dma)\n\t\tif (memcmp(ctx->key, key, SM4_KEY_SIZE))\n\t\t\tctx->base.needs_inv = true;\n\n\tmemcpy(ctx->key, key, SM4_KEY_SIZE);\n\tctx->key_len = SM4_KEY_SIZE;\n\n\treturn 0;\n}\n\nstatic int safexcel_sm4_blk_encrypt(struct skcipher_request *req)\n{\n\t \n\tif (req->cryptlen & (SM4_BLOCK_SIZE - 1))\n\t\treturn -EINVAL;\n\telse\n\t\treturn safexcel_queue_req(&req->base, skcipher_request_ctx(req),\n\t\t\t\t\t  SAFEXCEL_ENCRYPT);\n}\n\nstatic int safexcel_sm4_blk_decrypt(struct skcipher_request *req)\n{\n\t \n\tif (req->cryptlen & (SM4_BLOCK_SIZE - 1))\n\t\treturn -EINVAL;\n\telse\n\t\treturn safexcel_queue_req(&req->base, skcipher_request_ctx(req),\n\t\t\t\t\t  SAFEXCEL_DECRYPT);\n}\n\nstatic int safexcel_skcipher_sm4_ecb_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_SM4;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_ECB;\n\tctx->blocksz = 0;\n\tctx->ivmask = EIP197_OPTION_2_TOKEN_IV_CMD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_ecb_sm4 = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_SM4,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_skcipher_sm4_setkey,\n\t\t.encrypt = safexcel_sm4_blk_encrypt,\n\t\t.decrypt = safexcel_sm4_blk_decrypt,\n\t\t.min_keysize = SM4_KEY_SIZE,\n\t\t.max_keysize = SM4_KEY_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(sm4)\",\n\t\t\t.cra_driver_name = \"safexcel-ecb-sm4\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = SM4_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_sm4_ecb_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_skcipher_sm4_cbc_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_SM4;\n\tctx->blocksz = SM4_BLOCK_SIZE;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CBC;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_cbc_sm4 = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_SM4,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_skcipher_sm4_setkey,\n\t\t.encrypt = safexcel_sm4_blk_encrypt,\n\t\t.decrypt = safexcel_sm4_blk_decrypt,\n\t\t.min_keysize = SM4_KEY_SIZE,\n\t\t.max_keysize = SM4_KEY_SIZE,\n\t\t.ivsize = SM4_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"cbc(sm4)\",\n\t\t\t.cra_driver_name = \"safexcel-cbc-sm4\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = SM4_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_sm4_cbc_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_skcipher_sm4_ofb_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_SM4;\n\tctx->blocksz = SM4_BLOCK_SIZE;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_OFB;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_ofb_sm4 = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_SM4 | SAFEXCEL_ALG_AES_XFB,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_skcipher_sm4_setkey,\n\t\t.encrypt = safexcel_encrypt,\n\t\t.decrypt = safexcel_decrypt,\n\t\t.min_keysize = SM4_KEY_SIZE,\n\t\t.max_keysize = SM4_KEY_SIZE,\n\t\t.ivsize = SM4_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"ofb(sm4)\",\n\t\t\t.cra_driver_name = \"safexcel-ofb-sm4\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_sm4_ofb_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_skcipher_sm4_cfb_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_SM4;\n\tctx->blocksz = SM4_BLOCK_SIZE;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CFB;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_cfb_sm4 = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_SM4 | SAFEXCEL_ALG_AES_XFB,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_skcipher_sm4_setkey,\n\t\t.encrypt = safexcel_encrypt,\n\t\t.decrypt = safexcel_decrypt,\n\t\t.min_keysize = SM4_KEY_SIZE,\n\t\t.max_keysize = SM4_KEY_SIZE,\n\t\t.ivsize = SM4_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"cfb(sm4)\",\n\t\t\t.cra_driver_name = \"safexcel-cfb-sm4\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_sm4_cfb_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_skcipher_sm4ctr_setkey(struct crypto_skcipher *ctfm,\n\t\t\t\t\t   const u8 *key, unsigned int len)\n{\n\tstruct crypto_tfm *tfm = crypto_skcipher_tfm(ctfm);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t \n\tctx->nonce = *(u32 *)(key + len - CTR_RFC3686_NONCE_SIZE);\n\t \n\tlen -= CTR_RFC3686_NONCE_SIZE;\n\n\treturn safexcel_skcipher_sm4_setkey(ctfm, key, len);\n}\n\nstatic int safexcel_skcipher_sm4_ctr_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_skcipher_cra_init(tfm);\n\tctx->alg  = SAFEXCEL_SM4;\n\tctx->blocksz = SM4_BLOCK_SIZE;\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CTR_LOAD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_ctr_sm4 = {\n\t.type = SAFEXCEL_ALG_TYPE_SKCIPHER,\n\t.algo_mask = SAFEXCEL_ALG_SM4,\n\t.alg.skcipher = {\n\t\t.setkey = safexcel_skcipher_sm4ctr_setkey,\n\t\t.encrypt = safexcel_encrypt,\n\t\t.decrypt = safexcel_decrypt,\n\t\t \n\t\t.min_keysize = SM4_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,\n\t\t.max_keysize = SM4_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,\n\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"rfc3686(ctr(sm4))\",\n\t\t\t.cra_driver_name = \"safexcel-ctr-sm4\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_skcipher_sm4_ctr_cra_init,\n\t\t\t.cra_exit = safexcel_skcipher_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sm4_blk_encrypt(struct aead_request *req)\n{\n\t \n\tif (req->cryptlen & (SM4_BLOCK_SIZE - 1))\n\t\treturn -EINVAL;\n\n\treturn safexcel_queue_req(&req->base, aead_request_ctx(req),\n\t\t\t\t  SAFEXCEL_ENCRYPT);\n}\n\nstatic int safexcel_aead_sm4_blk_decrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\n\t \n\tif ((req->cryptlen - crypto_aead_authsize(tfm)) & (SM4_BLOCK_SIZE - 1))\n\t\treturn -EINVAL;\n\n\treturn safexcel_queue_req(&req->base, aead_request_ctx(req),\n\t\t\t\t  SAFEXCEL_DECRYPT);\n}\n\nstatic int safexcel_aead_sm4cbc_sha1_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_cra_init(tfm);\n\tctx->alg = SAFEXCEL_SM4;\n\tctx->blocksz = SM4_BLOCK_SIZE;\n\tctx->hash_alg = CONTEXT_CONTROL_CRYPTO_ALG_SHA1;\n\tctx->state_sz = SHA1_DIGEST_SIZE;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha1_cbc_sm4 = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_SM4 | SAFEXCEL_ALG_SHA1,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_sm4_blk_encrypt,\n\t\t.decrypt = safexcel_aead_sm4_blk_decrypt,\n\t\t.ivsize = SM4_BLOCK_SIZE,\n\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha1),cbc(sm4))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha1-cbc-sm4\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = SM4_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sm4cbc_sha1_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_fallback_setkey(struct crypto_aead *ctfm,\n\t\t\t\t\t const u8 *key, unsigned int len)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(ctfm);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t \n\treturn crypto_aead_setkey(ctx->fback, (u8 *)key, len) ?:\n\t       safexcel_aead_setkey(ctfm, key, len);\n}\n\nstatic int safexcel_aead_fallback_setauthsize(struct crypto_aead *ctfm,\n\t\t\t\t\t      unsigned int authsize)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(ctfm);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t \n\treturn crypto_aead_setauthsize(ctx->fback, authsize);\n}\n\nstatic int safexcel_aead_fallback_crypt(struct aead_request *req,\n\t\t\t\t\tenum safexcel_cipher_direction dir)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(aead);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct aead_request *subreq = aead_request_ctx(req);\n\n\taead_request_set_tfm(subreq, ctx->fback);\n\taead_request_set_callback(subreq, req->base.flags, req->base.complete,\n\t\t\t\t  req->base.data);\n\taead_request_set_crypt(subreq, req->src, req->dst, req->cryptlen,\n\t\t\t       req->iv);\n\taead_request_set_ad(subreq, req->assoclen);\n\n\treturn (dir ==  SAFEXCEL_ENCRYPT) ?\n\t\tcrypto_aead_encrypt(subreq) :\n\t\tcrypto_aead_decrypt(subreq);\n}\n\nstatic int safexcel_aead_sm4cbc_sm3_encrypt(struct aead_request *req)\n{\n\tstruct safexcel_cipher_req *creq = aead_request_ctx(req);\n\n\t \n\tif (req->cryptlen & (SM4_BLOCK_SIZE - 1))\n\t\treturn -EINVAL;\n\telse if (req->cryptlen || req->assoclen)  \n\t\treturn safexcel_queue_req(&req->base, creq, SAFEXCEL_ENCRYPT);\n\n\t \n\treturn safexcel_aead_fallback_crypt(req, SAFEXCEL_ENCRYPT);\n}\n\nstatic int safexcel_aead_sm4cbc_sm3_decrypt(struct aead_request *req)\n{\n\tstruct safexcel_cipher_req *creq = aead_request_ctx(req);\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\n\t \n\tif ((req->cryptlen - crypto_aead_authsize(tfm)) & (SM4_BLOCK_SIZE - 1))\n\t\treturn -EINVAL;\n\telse if (req->cryptlen > crypto_aead_authsize(tfm) || req->assoclen)\n\t\t \n\t\treturn safexcel_queue_req(&req->base, creq, SAFEXCEL_DECRYPT);\n\n\t \n\treturn safexcel_aead_fallback_crypt(req, SAFEXCEL_DECRYPT);\n}\n\nstatic int safexcel_aead_sm4cbc_sm3_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_fallback_cra_init(tfm);\n\tctx->alg = SAFEXCEL_SM4;\n\tctx->blocksz = SM4_BLOCK_SIZE;\n\tctx->hash_alg = CONTEXT_CONTROL_CRYPTO_ALG_SM3;\n\tctx->state_sz = SM3_DIGEST_SIZE;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sm3_cbc_sm4 = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_SM4 | SAFEXCEL_ALG_SM3,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_fallback_setkey,\n\t\t.setauthsize = safexcel_aead_fallback_setauthsize,\n\t\t.encrypt = safexcel_aead_sm4cbc_sm3_encrypt,\n\t\t.decrypt = safexcel_aead_sm4cbc_sm3_decrypt,\n\t\t.ivsize = SM4_BLOCK_SIZE,\n\t\t.maxauthsize = SM3_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sm3),cbc(sm4))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sm3-cbc-sm4\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t     CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize = SM4_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sm4cbc_sm3_cra_init,\n\t\t\t.cra_exit = safexcel_aead_fallback_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sm4ctr_sha1_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sm4cbc_sha1_cra_init(tfm);\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CTR_LOAD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sha1_ctr_sm4 = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_SM4 | SAFEXCEL_ALG_SHA1,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sha1),rfc3686(ctr(sm4)))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sha1-ctr-sm4\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sm4ctr_sha1_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_aead_sm4ctr_sm3_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tsafexcel_aead_sm4cbc_sm3_cra_init(tfm);\n\tctx->mode = CONTEXT_CONTROL_CRYPTO_MODE_CTR_LOAD;\n\treturn 0;\n}\n\nstruct safexcel_alg_template safexcel_alg_authenc_hmac_sm3_ctr_sm4 = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_SM4 | SAFEXCEL_ALG_SM3,\n\t.alg.aead = {\n\t\t.setkey = safexcel_aead_setkey,\n\t\t.encrypt = safexcel_aead_encrypt,\n\t\t.decrypt = safexcel_aead_decrypt,\n\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t.maxauthsize = SM3_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"authenc(hmac(sm3),rfc3686(ctr(sm4)))\",\n\t\t\t.cra_driver_name = \"safexcel-authenc-hmac-sm3-ctr-sm4\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_aead_sm4ctr_sm3_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n\nstatic int safexcel_rfc4106_gcm_setkey(struct crypto_aead *ctfm, const u8 *key,\n\t\t\t\t       unsigned int len)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(ctfm);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t \n\tctx->nonce = *(u32 *)(key + len - CTR_RFC3686_NONCE_SIZE);\n\n\tlen -= CTR_RFC3686_NONCE_SIZE;\n\treturn safexcel_aead_gcm_setkey(ctfm, key, len);\n}\n\nstatic int safexcel_rfc4106_gcm_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t\t    unsigned int authsize)\n{\n\treturn crypto_rfc4106_check_authsize(authsize);\n}\n\nstatic int safexcel_rfc4106_encrypt(struct aead_request *req)\n{\n\treturn crypto_ipsec_check_assoclen(req->assoclen) ?:\n\t       safexcel_aead_encrypt(req);\n}\n\nstatic int safexcel_rfc4106_decrypt(struct aead_request *req)\n{\n\treturn crypto_ipsec_check_assoclen(req->assoclen) ?:\n\t       safexcel_aead_decrypt(req);\n}\n\nstatic int safexcel_rfc4106_gcm_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tint ret;\n\n\tret = safexcel_aead_gcm_cra_init(tfm);\n\tctx->aead  = EIP197_AEAD_TYPE_IPSEC_ESP;\n\tctx->aadskip = EIP197_AEAD_IPSEC_IV_SIZE;\n\treturn ret;\n}\n\nstruct safexcel_alg_template safexcel_alg_rfc4106_gcm = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_GHASH,\n\t.alg.aead = {\n\t\t.setkey = safexcel_rfc4106_gcm_setkey,\n\t\t.setauthsize = safexcel_rfc4106_gcm_setauthsize,\n\t\t.encrypt = safexcel_rfc4106_encrypt,\n\t\t.decrypt = safexcel_rfc4106_decrypt,\n\t\t.ivsize = GCM_RFC4106_IV_SIZE,\n\t\t.maxauthsize = GHASH_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"rfc4106(gcm(aes))\",\n\t\t\t.cra_driver_name = \"safexcel-rfc4106-gcm-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_rfc4106_gcm_cra_init,\n\t\t\t.cra_exit = safexcel_aead_gcm_cra_exit,\n\t\t},\n\t},\n};\n\nstatic int safexcel_rfc4543_gcm_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t\t    unsigned int authsize)\n{\n\tif (authsize != GHASH_DIGEST_SIZE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int safexcel_rfc4543_gcm_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tint ret;\n\n\tret = safexcel_aead_gcm_cra_init(tfm);\n\tctx->aead  = EIP197_AEAD_TYPE_IPSEC_ESP_GMAC;\n\treturn ret;\n}\n\nstruct safexcel_alg_template safexcel_alg_rfc4543_gcm = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_GHASH,\n\t.alg.aead = {\n\t\t.setkey = safexcel_rfc4106_gcm_setkey,\n\t\t.setauthsize = safexcel_rfc4543_gcm_setauthsize,\n\t\t.encrypt = safexcel_rfc4106_encrypt,\n\t\t.decrypt = safexcel_rfc4106_decrypt,\n\t\t.ivsize = GCM_RFC4543_IV_SIZE,\n\t\t.maxauthsize = GHASH_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"rfc4543(gcm(aes))\",\n\t\t\t.cra_driver_name = \"safexcel-rfc4543-gcm-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_rfc4543_gcm_cra_init,\n\t\t\t.cra_exit = safexcel_aead_gcm_cra_exit,\n\t\t},\n\t},\n};\n\nstatic int safexcel_rfc4309_ccm_setkey(struct crypto_aead *ctfm, const u8 *key,\n\t\t\t\t       unsigned int len)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(ctfm);\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\t \n\t*(u8 *)&ctx->nonce = EIP197_AEAD_IPSEC_COUNTER_SIZE - 1;\n\t \n\tmemcpy((u8 *)&ctx->nonce + 1, key + len -\n\t       EIP197_AEAD_IPSEC_CCM_NONCE_SIZE,\n\t       EIP197_AEAD_IPSEC_CCM_NONCE_SIZE);\n\n\tlen -= EIP197_AEAD_IPSEC_CCM_NONCE_SIZE;\n\treturn safexcel_aead_ccm_setkey(ctfm, key, len);\n}\n\nstatic int safexcel_rfc4309_ccm_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t\t    unsigned int authsize)\n{\n\t \n\tswitch (authsize) {\n\tcase 8:\n\tcase 12:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int safexcel_rfc4309_ccm_encrypt(struct aead_request *req)\n{\n\tstruct safexcel_cipher_req *creq = aead_request_ctx(req);\n\n\t \n\tif (req->assoclen != 16 && req->assoclen != 20)\n\t\treturn -EINVAL;\n\n\treturn safexcel_queue_req(&req->base, creq, SAFEXCEL_ENCRYPT);\n}\n\nstatic int safexcel_rfc4309_ccm_decrypt(struct aead_request *req)\n{\n\tstruct safexcel_cipher_req *creq = aead_request_ctx(req);\n\n\t \n\tif (req->assoclen != 16 && req->assoclen != 20)\n\t\treturn -EINVAL;\n\n\treturn safexcel_queue_req(&req->base, creq, SAFEXCEL_DECRYPT);\n}\n\nstatic int safexcel_rfc4309_ccm_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);\n\tint ret;\n\n\tret = safexcel_aead_ccm_cra_init(tfm);\n\tctx->aead  = EIP197_AEAD_TYPE_IPSEC_ESP;\n\tctx->aadskip = EIP197_AEAD_IPSEC_IV_SIZE;\n\treturn ret;\n}\n\nstruct safexcel_alg_template safexcel_alg_rfc4309_ccm = {\n\t.type = SAFEXCEL_ALG_TYPE_AEAD,\n\t.algo_mask = SAFEXCEL_ALG_AES | SAFEXCEL_ALG_CBC_MAC_ALL,\n\t.alg.aead = {\n\t\t.setkey = safexcel_rfc4309_ccm_setkey,\n\t\t.setauthsize = safexcel_rfc4309_ccm_setauthsize,\n\t\t.encrypt = safexcel_rfc4309_ccm_encrypt,\n\t\t.decrypt = safexcel_rfc4309_ccm_decrypt,\n\t\t.ivsize = EIP197_AEAD_IPSEC_IV_SIZE,\n\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"rfc4309(ccm(aes))\",\n\t\t\t.cra_driver_name = \"safexcel-rfc4309-ccm-aes\",\n\t\t\t.cra_priority = SAFEXCEL_CRA_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct safexcel_cipher_ctx),\n\t\t\t.cra_alignmask = 0,\n\t\t\t.cra_init = safexcel_rfc4309_ccm_cra_init,\n\t\t\t.cra_exit = safexcel_aead_cra_exit,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}