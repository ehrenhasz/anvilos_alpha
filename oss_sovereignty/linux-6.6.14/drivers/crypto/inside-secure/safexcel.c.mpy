{
  "module_name": "safexcel.c",
  "hash_id": "bd82f0684418f8c14ad9abcfe7fdd484220f457d6732056ccb663fd89f4805fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/inside-secure/safexcel.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/of_irq.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n\n#include <crypto/internal/aead.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/skcipher.h>\n\n#include \"safexcel.h\"\n\nstatic u32 max_rings = EIP197_MAX_RINGS;\nmodule_param(max_rings, uint, 0644);\nMODULE_PARM_DESC(max_rings, \"Maximum number of rings to use.\");\n\nstatic void eip197_trc_cache_setupvirt(struct safexcel_crypto_priv *priv)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 4; i++)\n\t\twritel(0, priv->base + EIP197_FLUE_IFC_LUT(i));\n\n\t \n\tfor (i = 0; i < priv->config.rings; i++) {\n\t\twritel(0, priv->base + EIP197_FLUE_CACHEBASE_LO(i));\n\t\twritel(0, priv->base + EIP197_FLUE_CACHEBASE_HI(i));\n\t\twritel(EIP197_FLUE_CONFIG_MAGIC,\n\t\t       priv->base + EIP197_FLUE_CONFIG(i));\n\t}\n\twritel(0, priv->base + EIP197_FLUE_OFFSETS);\n\twritel(0, priv->base + EIP197_FLUE_ARC4_OFFSET);\n}\n\nstatic void eip197_trc_cache_banksel(struct safexcel_crypto_priv *priv,\n\t\t\t\t     u32 addrmid, int *actbank)\n{\n\tu32 val;\n\tint curbank;\n\n\tcurbank = addrmid >> 16;\n\tif (curbank != *actbank) {\n\t\tval = readl(priv->base + EIP197_CS_RAM_CTRL);\n\t\tval = (val & ~EIP197_CS_BANKSEL_MASK) |\n\t\t      (curbank << EIP197_CS_BANKSEL_OFS);\n\t\twritel(val, priv->base + EIP197_CS_RAM_CTRL);\n\t\t*actbank = curbank;\n\t}\n}\n\nstatic u32 eip197_trc_cache_probe(struct safexcel_crypto_priv *priv,\n\t\t\t\t  int maxbanks, u32 probemask, u32 stride)\n{\n\tu32 val, addrhi, addrlo, addrmid, addralias, delta, marker;\n\tint actbank;\n\n\t \n\taddrhi = 1 << (16 + maxbanks);\n\taddrlo = 0;\n\tactbank = min(maxbanks - 1, 0);\n\twhile ((addrhi - addrlo) > stride) {\n\t\t \n\t\taddrmid = (addrhi + addrlo) >> 1;\n\t\tmarker = (addrmid ^ 0xabadbabe) & probemask;  \n\t\teip197_trc_cache_banksel(priv, addrmid, &actbank);\n\t\twritel(marker,\n\t\t\tpriv->base + EIP197_CLASSIFICATION_RAMS +\n\t\t\t(addrmid & 0xffff));\n\n\t\t \n\t\tdelta = 1 << __fls(addrmid);\n\t\twhile (delta >= stride) {\n\t\t\taddralias = addrmid - delta;\n\t\t\teip197_trc_cache_banksel(priv, addralias, &actbank);\n\t\t\twritel(~marker,\n\t\t\t       priv->base + EIP197_CLASSIFICATION_RAMS +\n\t\t\t       (addralias & 0xffff));\n\t\t\tdelta >>= 1;\n\t\t}\n\n\t\t \n\t\teip197_trc_cache_banksel(priv, addrmid, &actbank);\n\t\tval = readl(priv->base + EIP197_CLASSIFICATION_RAMS +\n\t\t\t    (addrmid & 0xffff));\n\n\t\tif ((val & probemask) == marker)\n\t\t\t \n\t\t\taddrlo = addrmid;\n\t\telse\n\t\t\t \n\t\t\taddrhi = addrmid;\n\t}\n\treturn addrhi;\n}\n\nstatic void eip197_trc_cache_clear(struct safexcel_crypto_priv *priv,\n\t\t\t\t   int cs_rc_max, int cs_ht_wc)\n{\n\tint i;\n\tu32 htable_offset, val, offset;\n\n\t \n\tfor (i = 0; i < cs_rc_max; i++) {\n\t\toffset = EIP197_CLASSIFICATION_RAMS + i * EIP197_CS_RC_SIZE;\n\n\t\twritel(EIP197_CS_RC_NEXT(EIP197_RC_NULL) |\n\t\t       EIP197_CS_RC_PREV(EIP197_RC_NULL),\n\t\t       priv->base + offset);\n\n\t\tval = EIP197_CS_RC_NEXT(i + 1) | EIP197_CS_RC_PREV(i - 1);\n\t\tif (i == 0)\n\t\t\tval |= EIP197_CS_RC_PREV(EIP197_RC_NULL);\n\t\telse if (i == cs_rc_max - 1)\n\t\t\tval |= EIP197_CS_RC_NEXT(EIP197_RC_NULL);\n\t\twritel(val, priv->base + offset + 4);\n\t\t \n\t\twritel(0, priv->base + offset + 8);\n\t\twritel(0, priv->base + offset + 12);\n\t}\n\n\t \n\thtable_offset = cs_rc_max * EIP197_CS_RC_SIZE;\n\tfor (i = 0; i < cs_ht_wc; i++)\n\t\twritel(GENMASK(29, 0),\n\t\t       priv->base + EIP197_CLASSIFICATION_RAMS +\n\t\t       htable_offset + i * sizeof(u32));\n}\n\nstatic int eip197_trc_cache_init(struct safexcel_crypto_priv *priv)\n{\n\tu32 val, dsize, asize;\n\tint cs_rc_max, cs_ht_wc, cs_trc_rec_wc, cs_trc_lg_rec_wc;\n\tint cs_rc_abs_max, cs_ht_sz;\n\tint maxbanks;\n\n\t \n\teip197_trc_cache_setupvirt(priv);\n\n\t \n\tval = readl(priv->base + EIP197_CS_RAM_CTRL);\n\tval &= ~EIP197_TRC_ENABLE_MASK;\n\tval |= EIP197_TRC_ENABLE_0 | EIP197_CS_BANKSEL_MASK;\n\twritel(val, priv->base + EIP197_CS_RAM_CTRL);\n\tval = readl(priv->base + EIP197_CS_RAM_CTRL);\n\tmaxbanks = ((val&EIP197_CS_BANKSEL_MASK)>>EIP197_CS_BANKSEL_OFS) + 1;\n\n\t \n\twritel(0, priv->base + EIP197_TRC_ECCCTRL);\n\n\t \n\tval = readl(priv->base + EIP197_TRC_PARAMS);\n\tval |= EIP197_TRC_PARAMS_SW_RESET | EIP197_TRC_PARAMS_DATA_ACCESS;\n\twritel(val, priv->base + EIP197_TRC_PARAMS);\n\n\t \n\tdsize = eip197_trc_cache_probe(priv, maxbanks, 0xffffffff, 32);\n\n\t \n\tval = readl(priv->base + EIP197_TRC_PARAMS);\n\t \n\tval &= ~(EIP197_TRC_PARAMS_DATA_ACCESS | EIP197_CS_BANKSEL_MASK);\n\twritel(val, priv->base + EIP197_TRC_PARAMS);\n\n\t \n\tasize = eip197_trc_cache_probe(priv, 0, 0x3fffffff, 16) >> 4;\n\n\t \n\twritel(0, priv->base + EIP197_TRC_ECCCTRL);\n\n\t \n\tif (dsize < EIP197_MIN_DSIZE || asize < EIP197_MIN_ASIZE) {\n\t\tdev_err(priv->dev, \"Record cache probing failed (%d,%d).\",\n\t\t\tdsize, asize);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\t \n\tcs_trc_rec_wc = EIP197_CS_TRC_REC_WC;\n\tcs_trc_lg_rec_wc = EIP197_CS_TRC_REC_WC;\n\n\t \n\tcs_rc_abs_max = min_t(uint, ((dsize >> 2) / cs_trc_lg_rec_wc), 1023);\n\t \n\tcs_rc_max = min_t(uint, cs_rc_abs_max, (asize >> 1));\n\t \n\tcs_ht_sz = __fls(asize - cs_rc_max) - 2;\n\t \n\tcs_ht_wc = 16 << cs_ht_sz;  \n\t \n\tcs_rc_max = min_t(uint, cs_rc_abs_max, asize - (cs_ht_wc >> 2));\n\n\t \n\teip197_trc_cache_clear(priv, cs_rc_max, cs_ht_wc);\n\n\t \n\tval = readl(priv->base + EIP197_CS_RAM_CTRL);\n\tval &= ~EIP197_TRC_ENABLE_MASK;\n\twritel(val, priv->base + EIP197_CS_RAM_CTRL);\n\n\t \n\tval = EIP197_TRC_FREECHAIN_HEAD_PTR(0) |\n\t      EIP197_TRC_FREECHAIN_TAIL_PTR(cs_rc_max - 1);\n\twritel(val, priv->base + EIP197_TRC_FREECHAIN);\n\n\t \n\tval = EIP197_TRC_PARAMS2_RC_SZ_SMALL(cs_trc_rec_wc) |\n\t      EIP197_TRC_PARAMS2_HTABLE_PTR(cs_rc_max);\n\twritel(val, priv->base + EIP197_TRC_PARAMS2);\n\n\t \n\tval = EIP197_TRC_PARAMS_RC_SZ_LARGE(cs_trc_lg_rec_wc) |\n\t      EIP197_TRC_PARAMS_BLK_TIMER_SPEED(1) |\n\t      EIP197_TRC_PARAMS_HTABLE_SZ(cs_ht_sz);\n\twritel(val, priv->base + EIP197_TRC_PARAMS);\n\n\tdev_info(priv->dev, \"TRC init: %dd,%da (%dr,%dh)\\n\",\n\t\t dsize, asize, cs_rc_max, cs_ht_wc + cs_ht_wc);\n\treturn 0;\n}\n\nstatic void eip197_init_firmware(struct safexcel_crypto_priv *priv)\n{\n\tint pe, i;\n\tu32 val;\n\n\tfor (pe = 0; pe < priv->config.pes; pe++) {\n\t\t \n\t\twritel(3, EIP197_PE(priv) + EIP197_PE_ICE_PUTF_CTRL(pe));\n\t\twritel(0, EIP197_PE(priv) + EIP197_PE_ICE_PPTF_CTRL(pe));\n\n\t\t \n\t\tval = readl(EIP197_PE(priv) + EIP197_PE_ICE_SCRATCH_CTRL(pe));\n\t\tval |= EIP197_PE_ICE_SCRATCH_CTRL_CHANGE_TIMER |\n\t\t       EIP197_PE_ICE_SCRATCH_CTRL_TIMER_EN |\n\t\t       EIP197_PE_ICE_SCRATCH_CTRL_SCRATCH_ACCESS |\n\t\t       EIP197_PE_ICE_SCRATCH_CTRL_CHANGE_ACCESS;\n\t\twritel(val, EIP197_PE(priv) + EIP197_PE_ICE_SCRATCH_CTRL(pe));\n\n\t\t \n\t\tfor (i = 0; i < EIP197_NUM_OF_SCRATCH_BLOCKS; i++)\n\t\t\twritel(0, EIP197_PE(priv) +\n\t\t\t\t  EIP197_PE_ICE_SCRATCH_RAM(pe) + (i << 2));\n\n\t\t \n\t\twritel(EIP197_PE_ICE_x_CTRL_SW_RESET |\n\t\t       EIP197_PE_ICE_x_CTRL_CLR_ECC_CORR |\n\t\t       EIP197_PE_ICE_x_CTRL_CLR_ECC_NON_CORR,\n\t\t       EIP197_PE(priv) + EIP197_PE_ICE_FPP_CTRL(pe));\n\n\t\t \n\t\twritel(EIP197_PE_ICE_x_CTRL_SW_RESET |\n\t\t       EIP197_PE_ICE_x_CTRL_CLR_ECC_CORR |\n\t\t       EIP197_PE_ICE_x_CTRL_CLR_ECC_NON_CORR,\n\t\t       EIP197_PE(priv) + EIP197_PE_ICE_PUE_CTRL(pe));\n\n\t\t \n\t\twritel(EIP197_PE_ICE_RAM_CTRL_FPP_PROG_EN,\n\t\t       EIP197_PE(priv) + EIP197_PE_ICE_RAM_CTRL(pe));\n\n\t\t \n\t\tif (priv->flags & EIP197_OCE)\n\t\t\twritel(EIP197_DEBUG_OCE_BYPASS, EIP197_PE(priv) +\n\t\t\t\t\t\t\tEIP197_PE_DEBUG(pe));\n\t}\n\n}\n\nstatic int eip197_write_firmware(struct safexcel_crypto_priv *priv,\n\t\t\t\t  const struct firmware *fw)\n{\n\tu32 val;\n\tint i;\n\n\t \n\tfor (i = 0; i < fw->size / sizeof(u32); i++) {\n\t\tif (priv->data->fw_little_endian)\n\t\t\tval = le32_to_cpu(((const __le32 *)fw->data)[i]);\n\t\telse\n\t\t\tval = be32_to_cpu(((const __be32 *)fw->data)[i]);\n\n\t\twritel(val,\n\t\t       priv->base + EIP197_CLASSIFICATION_RAMS +\n\t\t       i * sizeof(val));\n\t}\n\n\t \n\treturn i - EIP197_FW_TERMINAL_NOPS;\n}\n\n \nstatic bool poll_fw_ready(struct safexcel_crypto_priv *priv, int fpp)\n{\n\tint pe, pollcnt;\n\tu32 base, pollofs;\n\n\tif (fpp)\n\t\tpollofs  = EIP197_FW_FPP_READY;\n\telse\n\t\tpollofs  = EIP197_FW_PUE_READY;\n\n\tfor (pe = 0; pe < priv->config.pes; pe++) {\n\t\tbase = EIP197_PE_ICE_SCRATCH_RAM(pe);\n\t\tpollcnt = EIP197_FW_START_POLLCNT;\n\t\twhile (pollcnt &&\n\t\t       (readl_relaxed(EIP197_PE(priv) + base +\n\t\t\t      pollofs) != 1)) {\n\t\t\tpollcnt--;\n\t\t}\n\t\tif (!pollcnt) {\n\t\t\tdev_err(priv->dev, \"FW(%d) for PE %d failed to start\\n\",\n\t\t\t\tfpp, pe);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool eip197_start_firmware(struct safexcel_crypto_priv *priv,\n\t\t\t\t  int ipuesz, int ifppsz, int minifw)\n{\n\tint pe;\n\tu32 val;\n\n\tfor (pe = 0; pe < priv->config.pes; pe++) {\n\t\t \n\t\twritel(0, EIP197_PE(priv) + EIP197_PE_ICE_RAM_CTRL(pe));\n\n\t\t \n\t\tif (minifw)\n\t\t\tval = 0;\n\t\telse\n\t\t\tval = EIP197_PE_ICE_UENG_START_OFFSET((ifppsz - 1) &\n\t\t\t\t\tEIP197_PE_ICE_UENG_INIT_ALIGN_MASK) |\n\t\t\t\tEIP197_PE_ICE_UENG_DEBUG_RESET;\n\t\twritel(val, EIP197_PE(priv) + EIP197_PE_ICE_FPP_CTRL(pe));\n\n\t\t \n\t\tif (minifw)\n\t\t\tval = 0;\n\t\telse\n\t\t\tval = EIP197_PE_ICE_UENG_START_OFFSET((ipuesz - 1) &\n\t\t\t\t\tEIP197_PE_ICE_UENG_INIT_ALIGN_MASK) |\n\t\t\t\tEIP197_PE_ICE_UENG_DEBUG_RESET;\n\t\twritel(val, EIP197_PE(priv) + EIP197_PE_ICE_PUE_CTRL(pe));\n\t}\n\n\t \n\tif (minifw)\n\t\treturn true;\n\n\t \n\tif (!poll_fw_ready(priv, 1))\n\t\treturn false;\n\tif (!poll_fw_ready(priv, 0))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int eip197_load_firmwares(struct safexcel_crypto_priv *priv)\n{\n\tconst char *fw_name[] = {\"ifpp.bin\", \"ipue.bin\"};\n\tconst struct firmware *fw[FW_NB];\n\tchar fw_path[37], *dir = NULL;\n\tint i, j, ret = 0, pe;\n\tint ipuesz, ifppsz, minifw = 0;\n\n\tif (priv->data->version == EIP197D_MRVL)\n\t\tdir = \"eip197d\";\n\telse if (priv->data->version == EIP197B_MRVL ||\n\t\t priv->data->version == EIP197_DEVBRD)\n\t\tdir = \"eip197b\";\n\telse if (priv->data->version == EIP197C_MXL)\n\t\tdir = \"eip197c\";\n\telse\n\t\treturn -ENODEV;\n\nretry_fw:\n\tfor (i = 0; i < FW_NB; i++) {\n\t\tsnprintf(fw_path, 37, \"inside-secure/%s/%s\", dir, fw_name[i]);\n\t\tret = firmware_request_nowarn(&fw[i], fw_path, priv->dev);\n\t\tif (ret) {\n\t\t\tif (minifw || priv->data->version != EIP197B_MRVL)\n\t\t\t\tgoto release_fw;\n\n\t\t\t \n\t\t\tret = firmware_request_nowarn(&fw[i], fw_name[i],\n\t\t\t\t\t\t      priv->dev);\n\t\t\tif (ret)\n\t\t\t\tgoto release_fw;\n\t\t}\n\t}\n\n\teip197_init_firmware(priv);\n\n\tifppsz = eip197_write_firmware(priv, fw[FW_IFPP]);\n\n\t \n\tfor (pe = 0; pe < priv->config.pes; pe++)\n\t\twritel(EIP197_PE_ICE_RAM_CTRL_PUE_PROG_EN,\n\t\t       EIP197_PE(priv) + EIP197_PE_ICE_RAM_CTRL(pe));\n\n\tipuesz = eip197_write_firmware(priv, fw[FW_IPUE]);\n\n\tif (eip197_start_firmware(priv, ipuesz, ifppsz, minifw)) {\n\t\tdev_dbg(priv->dev, \"Firmware loaded successfully\\n\");\n\t\treturn 0;\n\t}\n\n\tret = -ENODEV;\n\nrelease_fw:\n\tfor (j = 0; j < i; j++)\n\t\trelease_firmware(fw[j]);\n\n\tif (!minifw) {\n\t\t \n\t\tdev_dbg(priv->dev, \"Firmware set not (fully) present or init failed, falling back to BCLA mode\\n\");\n\t\tdir = \"eip197_minifw\";\n\t\tminifw = 1;\n\t\tgoto retry_fw;\n\t}\n\n\tdev_err(priv->dev, \"Firmware load failed.\\n\");\n\n\treturn ret;\n}\n\nstatic int safexcel_hw_setup_cdesc_rings(struct safexcel_crypto_priv *priv)\n{\n\tu32 cd_size_rnd, val;\n\tint i, cd_fetch_cnt;\n\n\tcd_size_rnd  = (priv->config.cd_size +\n\t\t\t(BIT(priv->hwconfig.hwdataw) - 1)) >>\n\t\t       priv->hwconfig.hwdataw;\n\t \n\tif (priv->flags & SAFEXCEL_HW_EIP197) {\n\t\t \n\t\tcd_fetch_cnt = (1 << priv->hwconfig.hwcfsize) / cd_size_rnd;\n\t\tcd_fetch_cnt = min_t(uint, cd_fetch_cnt,\n\t\t\t\t     (priv->config.pes * EIP197_FETCH_DEPTH));\n\t} else {\n\t\t \n\t\tcd_fetch_cnt = ((1 << priv->hwconfig.hwcfsize) /\n\t\t\t\tcd_size_rnd) - 1;\n\t}\n\t \n\tif (!cd_fetch_cnt) {\n\t\tdev_err(priv->dev, \"Unable to fit even 1 command desc!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < priv->config.rings; i++) {\n\t\t \n\t\twritel(lower_32_bits(priv->ring[i].cdr.base_dma),\n\t\t       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_LO);\n\t\twritel(upper_32_bits(priv->ring[i].cdr.base_dma),\n\t\t       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_HI);\n\n\t\twritel(EIP197_xDR_DESC_MODE_64BIT | EIP197_CDR_DESC_MODE_ADCP |\n\t\t       (priv->config.cd_offset << 14) | priv->config.cd_size,\n\t\t       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_DESC_SIZE);\n\t\twritel(((cd_fetch_cnt *\n\t\t\t (cd_size_rnd << priv->hwconfig.hwdataw)) << 16) |\n\t\t       (cd_fetch_cnt * (priv->config.cd_offset / sizeof(u32))),\n\t\t       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_CFG);\n\n\t\t \n\t\tval = EIP197_HIA_xDR_CFG_WR_CACHE(WR_CACHE_3BITS);\n\t\tval |= EIP197_HIA_xDR_CFG_RD_CACHE(RD_CACHE_3BITS);\n\t\twritel(val, EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_DMA_CFG);\n\n\t\t \n\t\twritel(GENMASK(5, 0),\n\t\t       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_STAT);\n\t}\n\n\treturn 0;\n}\n\nstatic int safexcel_hw_setup_rdesc_rings(struct safexcel_crypto_priv *priv)\n{\n\tu32 rd_size_rnd, val;\n\tint i, rd_fetch_cnt;\n\n\t \n\trd_size_rnd = (EIP197_RD64_FETCH_SIZE +\n\t\t       (BIT(priv->hwconfig.hwdataw) - 1)) >>\n\t\t      priv->hwconfig.hwdataw;\n\tif (priv->flags & SAFEXCEL_HW_EIP197) {\n\t\t \n\t\trd_fetch_cnt = (1 << priv->hwconfig.hwrfsize) / rd_size_rnd;\n\t\trd_fetch_cnt = min_t(uint, rd_fetch_cnt,\n\t\t\t\t     (priv->config.pes * EIP197_FETCH_DEPTH));\n\t} else {\n\t\t \n\t\trd_fetch_cnt = ((1 << priv->hwconfig.hwrfsize) /\n\t\t\t\trd_size_rnd) - 1;\n\t}\n\n\tfor (i = 0; i < priv->config.rings; i++) {\n\t\t \n\t\twritel(lower_32_bits(priv->ring[i].rdr.base_dma),\n\t\t       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_LO);\n\t\twritel(upper_32_bits(priv->ring[i].rdr.base_dma),\n\t\t       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_HI);\n\n\t\twritel(EIP197_xDR_DESC_MODE_64BIT | (priv->config.rd_offset << 14) |\n\t\t       priv->config.rd_size,\n\t\t       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_DESC_SIZE);\n\n\t\twritel(((rd_fetch_cnt *\n\t\t\t (rd_size_rnd << priv->hwconfig.hwdataw)) << 16) |\n\t\t       (rd_fetch_cnt * (priv->config.rd_offset / sizeof(u32))),\n\t\t       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_CFG);\n\n\t\t \n\t\tval = EIP197_HIA_xDR_CFG_WR_CACHE(WR_CACHE_3BITS);\n\t\tval |= EIP197_HIA_xDR_CFG_RD_CACHE(RD_CACHE_3BITS);\n\t\tval |= EIP197_HIA_xDR_WR_RES_BUF | EIP197_HIA_xDR_WR_CTRL_BUF;\n\t\twritel(val,\n\t\t       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_DMA_CFG);\n\n\t\t \n\t\twritel(GENMASK(7, 0),\n\t\t       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_STAT);\n\n\t\t \n\t\tval = readl(EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ENABLE_CTRL(i));\n\t\tval |= EIP197_RDR_IRQ(i);\n\t\twritel(val, EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ENABLE_CTRL(i));\n\t}\n\n\treturn 0;\n}\n\nstatic int safexcel_hw_init(struct safexcel_crypto_priv *priv)\n{\n\tu32 val;\n\tint i, ret, pe, opbuflo, opbufhi;\n\n\tdev_dbg(priv->dev, \"HW init: using %d pipe(s) and %d ring(s)\\n\",\n\t\tpriv->config.pes, priv->config.rings);\n\n\t \n\tif (priv->flags & SAFEXCEL_HW_EIP197) {\n\t\tval = readl(EIP197_HIA_AIC(priv) + EIP197_HIA_MST_CTRL);\n\t\tval |= EIP197_MST_CTRL_TX_MAX_CMD(5);\n\t\twritel(val, EIP197_HIA_AIC(priv) + EIP197_HIA_MST_CTRL);\n\t}\n\n\t \n\twritel(EIP197_MST_CTRL_RD_CACHE(RD_CACHE_4BITS) |\n\t       EIP197_MST_CTRL_WD_CACHE(WR_CACHE_4BITS),\n\t       EIP197_HIA_GEN_CFG(priv) + EIP197_MST_CTRL);\n\n\t \n\n\t \n\twritel(0, EIP197_HIA_AIC_G(priv) + EIP197_HIA_AIC_G_ENABLE_CTRL);\n\n\t \n\twritel(GENMASK(31, 0), EIP197_HIA_AIC_G(priv) + EIP197_HIA_AIC_G_ACK);\n\n\t \n\tfor (pe = 0; pe < priv->config.pes; pe++) {\n\t\t \n\n\t\t \n\t\twritel(EIP197_DxE_THR_CTRL_RESET_PE,\n\t\t       EIP197_HIA_DFE_THR(priv) + EIP197_HIA_DFE_THR_CTRL(pe));\n\n\t\tif (priv->flags & EIP197_PE_ARB)\n\t\t\t \n\t\t\twritel(EIP197_HIA_RA_PE_CTRL_RESET,\n\t\t\t       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL(pe));\n\n\t\t \n\t\tval = EIP197_HIA_DFE_CFG_DIS_DEBUG;\n\t\tval |= EIP197_HIA_DxE_CFG_MIN_DATA_SIZE(6) |\n\t\t       EIP197_HIA_DxE_CFG_MAX_DATA_SIZE(9);\n\t\tval |= EIP197_HIA_DxE_CFG_MIN_CTRL_SIZE(6) |\n\t\t       EIP197_HIA_DxE_CFG_MAX_CTRL_SIZE(7);\n\t\tval |= EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(RD_CACHE_3BITS);\n\t\tval |= EIP197_HIA_DxE_CFG_CTRL_CACHE_CTRL(RD_CACHE_3BITS);\n\t\twritel(val, EIP197_HIA_DFE(priv) + EIP197_HIA_DFE_CFG(pe));\n\n\t\t \n\t\twritel(0, EIP197_HIA_DFE_THR(priv) + EIP197_HIA_DFE_THR_CTRL(pe));\n\n\t\t \n\t\twritel(EIP197_PE_IN_xBUF_THRES_MIN(6) |\n\t\t       EIP197_PE_IN_xBUF_THRES_MAX(9),\n\t\t       EIP197_PE(priv) + EIP197_PE_IN_DBUF_THRES(pe));\n\t\twritel(EIP197_PE_IN_xBUF_THRES_MIN(6) |\n\t\t       EIP197_PE_IN_xBUF_THRES_MAX(7),\n\t\t       EIP197_PE(priv) + EIP197_PE_IN_TBUF_THRES(pe));\n\n\t\tif (priv->flags & SAFEXCEL_HW_EIP197)\n\t\t\t \n\t\t\twritel(EIP197_HIA_RA_PE_CTRL_EN |\n\t\t\t       GENMASK(priv->config.rings - 1, 0),\n\t\t\t       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL(pe));\n\n\t\t \n\n\t\t \n\t\twritel(EIP197_DxE_THR_CTRL_RESET_PE,\n\t\t       EIP197_HIA_DSE_THR(priv) + EIP197_HIA_DSE_THR_CTRL(pe));\n\n\t\t \n\t\twhile ((readl(EIP197_HIA_DSE_THR(priv) + EIP197_HIA_DSE_THR_STAT(pe)) &\n\t\t\tGENMASK(15, 12)) != GENMASK(15, 12))\n\t\t\t;\n\n\t\t \n\t\tif (priv->hwconfig.hwnumpes > 4) {\n\t\t\topbuflo = 9;\n\t\t\topbufhi = 10;\n\t\t} else {\n\t\t\topbuflo = 7;\n\t\t\topbufhi = 8;\n\t\t}\n\t\tval = EIP197_HIA_DSE_CFG_DIS_DEBUG;\n\t\tval |= EIP197_HIA_DxE_CFG_MIN_DATA_SIZE(opbuflo) |\n\t\t       EIP197_HIA_DxE_CFG_MAX_DATA_SIZE(opbufhi);\n\t\tval |= EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(WR_CACHE_3BITS);\n\t\tval |= EIP197_HIA_DSE_CFG_ALWAYS_BUFFERABLE;\n\t\t \n\t\tif (priv->flags & SAFEXCEL_HW_EIP197)\n\t\t\tval |= EIP197_HIA_DSE_CFG_EN_SINGLE_WR;\n\t\twritel(val, EIP197_HIA_DSE(priv) + EIP197_HIA_DSE_CFG(pe));\n\n\t\t \n\t\twritel(0, EIP197_HIA_DSE_THR(priv) + EIP197_HIA_DSE_THR_CTRL(pe));\n\n\t\t \n\t\twritel(EIP197_PE_OUT_DBUF_THRES_MIN(opbuflo) |\n\t\t       EIP197_PE_OUT_DBUF_THRES_MAX(opbufhi),\n\t\t       EIP197_PE(priv) + EIP197_PE_OUT_DBUF_THRES(pe));\n\n\t\t \n\n\t\t \n\t\tval = EIP197_PE_EIP96_TOKEN_CTRL_CTX_UPDATES |\n\t\t      EIP197_PE_EIP96_TOKEN_CTRL_NO_TOKEN_WAIT |\n\t\t      EIP197_PE_EIP96_TOKEN_CTRL_ENABLE_TIMEOUT;\n\t\twritel(val, EIP197_PE(priv) + EIP197_PE_EIP96_TOKEN_CTRL(pe));\n\n\t\t \n\t\twritel(EIP197_FUNCTION_ALL,\n\t\t       EIP197_PE(priv) + EIP197_PE_EIP96_FUNCTION_EN(pe));\n\t\twritel(EIP197_FUNCTION_ALL,\n\t\t       EIP197_PE(priv) + EIP197_PE_EIP96_FUNCTION2_EN(pe));\n\t}\n\n\t \n\tfor (i = 0; i < priv->config.rings; i++) {\n\t\t \n\t\twritel(GENMASK(31, 0),\n\t\t       EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ENABLE_CLR(i));\n\n\t\t \n\t\twritel(0, EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_CFG);\n\n\t\t \n\t\twritel(EIP197_xDR_PREP_CLR_COUNT,\n\t\t       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_PREP_COUNT);\n\n\t\t \n\t\twritel(EIP197_xDR_PROC_CLR_COUNT,\n\t\t       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_PROC_COUNT);\n\n\t\twritel(0,\n\t\t       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_PREP_PNTR);\n\t\twritel(0,\n\t\t       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_PROC_PNTR);\n\n\t\twritel((EIP197_DEFAULT_RING_SIZE * priv->config.cd_offset),\n\t\t       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_RING_SIZE);\n\t}\n\n\t \n\tfor (i = 0; i < priv->config.rings; i++) {\n\t\t \n\t\twritel(0, EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_CFG);\n\n\t\t \n\t\twritel(EIP197_xDR_PREP_CLR_COUNT,\n\t\t       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_PREP_COUNT);\n\n\t\t \n\t\twritel(EIP197_xDR_PROC_CLR_COUNT,\n\t\t       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_PROC_COUNT);\n\n\t\twritel(0,\n\t\t       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_PREP_PNTR);\n\t\twritel(0,\n\t\t       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_PROC_PNTR);\n\n\t\t \n\t\twritel((EIP197_DEFAULT_RING_SIZE * priv->config.rd_offset),\n\t\t       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_RING_SIZE);\n\t}\n\n\tfor (pe = 0; pe < priv->config.pes; pe++) {\n\t\t \n\t\twritel(EIP197_DxE_THR_CTRL_EN | GENMASK(priv->config.rings - 1, 0),\n\t\t       EIP197_HIA_DFE_THR(priv) + EIP197_HIA_DFE_THR_CTRL(pe));\n\n\t\t \n\t\twritel(EIP197_DxE_THR_CTRL_EN | GENMASK(priv->config.rings - 1, 0),\n\t\t       EIP197_HIA_DSE_THR(priv) + EIP197_HIA_DSE_THR_CTRL(pe));\n\t}\n\n\t \n\twritel(GENMASK(30, 20), EIP197_HIA_AIC_G(priv) + EIP197_HIA_AIC_G_ACK);\n\n\tif (priv->flags & EIP197_SIMPLE_TRC) {\n\t\twritel(EIP197_STRC_CONFIG_INIT |\n\t\t       EIP197_STRC_CONFIG_LARGE_REC(EIP197_CS_TRC_REC_WC) |\n\t\t       EIP197_STRC_CONFIG_SMALL_REC(EIP197_CS_TRC_REC_WC),\n\t\t       priv->base + EIP197_STRC_CONFIG);\n\t\twritel(EIP197_PE_EIP96_TOKEN_CTRL2_CTX_DONE,\n\t\t       EIP197_PE(priv) + EIP197_PE_EIP96_TOKEN_CTRL2(0));\n\t} else if (priv->flags & SAFEXCEL_HW_EIP197) {\n\t\tret = eip197_trc_cache_init(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (priv->flags & EIP197_ICE) {\n\t\tret = eip197_load_firmwares(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn safexcel_hw_setup_cdesc_rings(priv) ?:\n\t       safexcel_hw_setup_rdesc_rings(priv) ?:\n\t       0;\n}\n\n \nstatic void safexcel_try_push_requests(struct safexcel_crypto_priv *priv,\n\t\t\t\t       int ring)\n{\n\tint coal = min_t(int, priv->ring[ring].requests, EIP197_MAX_BATCH_SZ);\n\n\tif (!coal)\n\t\treturn;\n\n\t \n\twritel(EIP197_HIA_RDR_THRESH_PKT_MODE |\n\t       EIP197_HIA_RDR_THRESH_PROC_PKT(coal),\n\t       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_THRESH);\n}\n\nvoid safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)\n{\n\tstruct crypto_async_request *req, *backlog;\n\tstruct safexcel_context *ctx;\n\tint ret, nreq = 0, cdesc = 0, rdesc = 0, commands, results;\n\n\t \n\treq = priv->ring[ring].req;\n\tbacklog = priv->ring[ring].backlog;\n\tif (req)\n\t\tgoto handle_req;\n\n\twhile (true) {\n\t\tspin_lock_bh(&priv->ring[ring].queue_lock);\n\t\tbacklog = crypto_get_backlog(&priv->ring[ring].queue);\n\t\treq = crypto_dequeue_request(&priv->ring[ring].queue);\n\t\tspin_unlock_bh(&priv->ring[ring].queue_lock);\n\n\t\tif (!req) {\n\t\t\tpriv->ring[ring].req = NULL;\n\t\t\tpriv->ring[ring].backlog = NULL;\n\t\t\tgoto finalize;\n\t\t}\n\nhandle_req:\n\t\tctx = crypto_tfm_ctx(req->tfm);\n\t\tret = ctx->send(req, ring, &commands, &results);\n\t\tif (ret)\n\t\t\tgoto request_failed;\n\n\t\tif (backlog)\n\t\t\tcrypto_request_complete(backlog, -EINPROGRESS);\n\n\t\t \n\t\tif (!commands && !results)\n\t\t\tcontinue;\n\n\t\tcdesc += commands;\n\t\trdesc += results;\n\t\tnreq++;\n\t}\n\nrequest_failed:\n\t \n\tpriv->ring[ring].req = req;\n\tpriv->ring[ring].backlog = backlog;\n\nfinalize:\n\tif (!nreq)\n\t\treturn;\n\n\tspin_lock_bh(&priv->ring[ring].lock);\n\n\tpriv->ring[ring].requests += nreq;\n\n\tif (!priv->ring[ring].busy) {\n\t\tsafexcel_try_push_requests(priv, ring);\n\t\tpriv->ring[ring].busy = true;\n\t}\n\n\tspin_unlock_bh(&priv->ring[ring].lock);\n\n\t \n\twritel((rdesc * priv->config.rd_offset),\n\t       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_PREP_COUNT);\n\n\t \n\twritel((cdesc * priv->config.cd_offset),\n\t       EIP197_HIA_CDR(priv, ring) + EIP197_HIA_xDR_PREP_COUNT);\n}\n\ninline int safexcel_rdesc_check_errors(struct safexcel_crypto_priv *priv,\n\t\t\t\t       void *rdp)\n{\n\tstruct safexcel_result_desc *rdesc = rdp;\n\tstruct result_data_desc *result_data = rdp + priv->config.res_offset;\n\n\tif (likely((!rdesc->last_seg) ||  \n\t\t   ((!rdesc->descriptor_overflow) &&\n\t\t    (!rdesc->buffer_overflow) &&\n\t\t    (!result_data->error_code))))\n\t\treturn 0;\n\n\tif (rdesc->descriptor_overflow)\n\t\tdev_err(priv->dev, \"Descriptor overflow detected\");\n\n\tif (rdesc->buffer_overflow)\n\t\tdev_err(priv->dev, \"Buffer overflow detected\");\n\n\tif (result_data->error_code & 0x4066) {\n\t\t \n\t\tdev_err(priv->dev,\n\t\t\t\"result descriptor error (%x)\",\n\t\t\tresult_data->error_code);\n\n\t\treturn -EIO;\n\t} else if (result_data->error_code &\n\t\t   (BIT(7) | BIT(4) | BIT(3) | BIT(0))) {\n\t\t \n\t\treturn -EINVAL;\n\t} else if (result_data->error_code & BIT(9)) {\n\t\t \n\t\treturn -EBADMSG;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\ninline void safexcel_rdr_req_set(struct safexcel_crypto_priv *priv,\n\t\t\t\t int ring,\n\t\t\t\t struct safexcel_result_desc *rdesc,\n\t\t\t\t struct crypto_async_request *req)\n{\n\tint i = safexcel_ring_rdr_rdesc_index(priv, ring, rdesc);\n\n\tpriv->ring[ring].rdr_req[i] = req;\n}\n\ninline struct crypto_async_request *\nsafexcel_rdr_req_get(struct safexcel_crypto_priv *priv, int ring)\n{\n\tint i = safexcel_ring_first_rdr_index(priv, ring);\n\n\treturn priv->ring[ring].rdr_req[i];\n}\n\nvoid safexcel_complete(struct safexcel_crypto_priv *priv, int ring)\n{\n\tstruct safexcel_command_desc *cdesc;\n\n\t \n\tdo {\n\t\tcdesc = safexcel_ring_next_rptr(priv, &priv->ring[ring].cdr);\n\t\tif (IS_ERR(cdesc)) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"Could not retrieve the command descriptor\\n\");\n\t\t\treturn;\n\t\t}\n\t} while (!cdesc->last_seg);\n}\n\nint safexcel_invalidate_cache(struct crypto_async_request *async,\n\t\t\t      struct safexcel_crypto_priv *priv,\n\t\t\t      dma_addr_t ctxr_dma, int ring)\n{\n\tstruct safexcel_command_desc *cdesc;\n\tstruct safexcel_result_desc *rdesc;\n\tstruct safexcel_token  *dmmy;\n\tint ret = 0;\n\n\t \n\tcdesc = safexcel_add_cdesc(priv, ring, true, true, 0, 0, 0, ctxr_dma,\n\t\t\t\t   &dmmy);\n\tif (IS_ERR(cdesc))\n\t\treturn PTR_ERR(cdesc);\n\n\tcdesc->control_data.type = EIP197_TYPE_EXTENDED;\n\tcdesc->control_data.options = 0;\n\tcdesc->control_data.context_lo &= ~EIP197_CONTEXT_SIZE_MASK;\n\tcdesc->control_data.control0 = CONTEXT_CONTROL_INV_TR;\n\n\t \n\trdesc = safexcel_add_rdesc(priv, ring, true, true, 0, 0);\n\n\tif (IS_ERR(rdesc)) {\n\t\tret = PTR_ERR(rdesc);\n\t\tgoto cdesc_rollback;\n\t}\n\n\tsafexcel_rdr_req_set(priv, ring, rdesc, async);\n\n\treturn ret;\n\ncdesc_rollback:\n\tsafexcel_ring_rollback_wptr(priv, &priv->ring[ring].cdr);\n\n\treturn ret;\n}\n\nstatic inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv *priv,\n\t\t\t\t\t\t     int ring)\n{\n\tstruct crypto_async_request *req;\n\tstruct safexcel_context *ctx;\n\tint ret, i, nreq, ndesc, tot_descs, handled = 0;\n\tbool should_complete;\n\nhandle_results:\n\ttot_descs = 0;\n\n\tnreq = readl(EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_PROC_COUNT);\n\tnreq >>= EIP197_xDR_PROC_xD_PKT_OFFSET;\n\tnreq &= EIP197_xDR_PROC_xD_PKT_MASK;\n\tif (!nreq)\n\t\tgoto requests_left;\n\n\tfor (i = 0; i < nreq; i++) {\n\t\treq = safexcel_rdr_req_get(priv, ring);\n\n\t\tctx = crypto_tfm_ctx(req->tfm);\n\t\tndesc = ctx->handle_result(priv, ring, req,\n\t\t\t\t\t   &should_complete, &ret);\n\t\tif (ndesc < 0) {\n\t\t\tdev_err(priv->dev, \"failed to handle result (%d)\\n\",\n\t\t\t\tndesc);\n\t\t\tgoto acknowledge;\n\t\t}\n\n\t\tif (should_complete) {\n\t\t\tlocal_bh_disable();\n\t\t\tcrypto_request_complete(req, ret);\n\t\t\tlocal_bh_enable();\n\t\t}\n\n\t\ttot_descs += ndesc;\n\t\thandled++;\n\t}\n\nacknowledge:\n\tif (i)\n\t\twritel(EIP197_xDR_PROC_xD_PKT(i) |\n\t\t       (tot_descs * priv->config.rd_offset),\n\t\t       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_PROC_COUNT);\n\n\t \n\tif (nreq == EIP197_xDR_PROC_xD_PKT_MASK)\n\t\tgoto handle_results;\n\nrequests_left:\n\tspin_lock_bh(&priv->ring[ring].lock);\n\n\tpriv->ring[ring].requests -= handled;\n\tsafexcel_try_push_requests(priv, ring);\n\n\tif (!priv->ring[ring].requests)\n\t\tpriv->ring[ring].busy = false;\n\n\tspin_unlock_bh(&priv->ring[ring].lock);\n}\n\nstatic void safexcel_dequeue_work(struct work_struct *work)\n{\n\tstruct safexcel_work_data *data =\n\t\t\tcontainer_of(work, struct safexcel_work_data, work);\n\n\tsafexcel_dequeue(data->priv, data->ring);\n}\n\nstruct safexcel_ring_irq_data {\n\tstruct safexcel_crypto_priv *priv;\n\tint ring;\n};\n\nstatic irqreturn_t safexcel_irq_ring(int irq, void *data)\n{\n\tstruct safexcel_ring_irq_data *irq_data = data;\n\tstruct safexcel_crypto_priv *priv = irq_data->priv;\n\tint ring = irq_data->ring, rc = IRQ_NONE;\n\tu32 status, stat;\n\n\tstatus = readl(EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ENABLED_STAT(ring));\n\tif (!status)\n\t\treturn rc;\n\n\t \n\tif (status & EIP197_RDR_IRQ(ring)) {\n\t\tstat = readl(EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_STAT);\n\n\t\tif (unlikely(stat & EIP197_xDR_ERR)) {\n\t\t\t \n\t\t\tdev_err(priv->dev, \"RDR: fatal error.\\n\");\n\t\t} else if (likely(stat & EIP197_xDR_THRESH)) {\n\t\t\trc = IRQ_WAKE_THREAD;\n\t\t}\n\n\t\t \n\t\twritel(stat & 0xff,\n\t\t       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_STAT);\n\t}\n\n\t \n\twritel(status, EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ACK(ring));\n\n\treturn rc;\n}\n\nstatic irqreturn_t safexcel_irq_ring_thread(int irq, void *data)\n{\n\tstruct safexcel_ring_irq_data *irq_data = data;\n\tstruct safexcel_crypto_priv *priv = irq_data->priv;\n\tint ring = irq_data->ring;\n\n\tsafexcel_handle_result_descriptor(priv, ring);\n\n\tqueue_work(priv->ring[ring].workqueue,\n\t\t   &priv->ring[ring].work_data.work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int safexcel_request_ring_irq(void *pdev, int irqid,\n\t\t\t\t     int is_pci_dev,\n\t\t\t\t     int ring_id,\n\t\t\t\t     irq_handler_t handler,\n\t\t\t\t     irq_handler_t threaded_handler,\n\t\t\t\t     struct safexcel_ring_irq_data *ring_irq_priv)\n{\n\tint ret, irq, cpu;\n\tstruct device *dev;\n\n\tif (IS_ENABLED(CONFIG_PCI) && is_pci_dev) {\n\t\tstruct pci_dev *pci_pdev = pdev;\n\n\t\tdev = &pci_pdev->dev;\n\t\tirq = pci_irq_vector(pci_pdev, irqid);\n\t\tif (irq < 0) {\n\t\t\tdev_err(dev, \"unable to get device MSI IRQ %d (err %d)\\n\",\n\t\t\t\tirqid, irq);\n\t\t\treturn irq;\n\t\t}\n\t} else if (IS_ENABLED(CONFIG_OF)) {\n\t\tstruct platform_device *plf_pdev = pdev;\n\t\tchar irq_name[6] = {0};  \n\n\t\tsnprintf(irq_name, 6, \"ring%d\", irqid);\n\t\tdev = &plf_pdev->dev;\n\t\tirq = platform_get_irq_byname(plf_pdev, irq_name);\n\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\t} else {\n\t\treturn -ENXIO;\n\t}\n\n\tret = devm_request_threaded_irq(dev, irq, handler,\n\t\t\t\t\tthreaded_handler, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), ring_irq_priv);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to request IRQ %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\t \n\tcpu = cpumask_local_spread(ring_id, NUMA_NO_NODE);\n\tirq_set_affinity_hint(irq, get_cpu_mask(cpu));\n\n\treturn irq;\n}\n\nstatic struct safexcel_alg_template *safexcel_algs[] = {\n\t&safexcel_alg_ecb_des,\n\t&safexcel_alg_cbc_des,\n\t&safexcel_alg_ecb_des3_ede,\n\t&safexcel_alg_cbc_des3_ede,\n\t&safexcel_alg_ecb_aes,\n\t&safexcel_alg_cbc_aes,\n\t&safexcel_alg_cfb_aes,\n\t&safexcel_alg_ofb_aes,\n\t&safexcel_alg_ctr_aes,\n\t&safexcel_alg_md5,\n\t&safexcel_alg_sha1,\n\t&safexcel_alg_sha224,\n\t&safexcel_alg_sha256,\n\t&safexcel_alg_sha384,\n\t&safexcel_alg_sha512,\n\t&safexcel_alg_hmac_md5,\n\t&safexcel_alg_hmac_sha1,\n\t&safexcel_alg_hmac_sha224,\n\t&safexcel_alg_hmac_sha256,\n\t&safexcel_alg_hmac_sha384,\n\t&safexcel_alg_hmac_sha512,\n\t&safexcel_alg_authenc_hmac_sha1_cbc_aes,\n\t&safexcel_alg_authenc_hmac_sha224_cbc_aes,\n\t&safexcel_alg_authenc_hmac_sha256_cbc_aes,\n\t&safexcel_alg_authenc_hmac_sha384_cbc_aes,\n\t&safexcel_alg_authenc_hmac_sha512_cbc_aes,\n\t&safexcel_alg_authenc_hmac_sha1_cbc_des3_ede,\n\t&safexcel_alg_authenc_hmac_sha1_ctr_aes,\n\t&safexcel_alg_authenc_hmac_sha224_ctr_aes,\n\t&safexcel_alg_authenc_hmac_sha256_ctr_aes,\n\t&safexcel_alg_authenc_hmac_sha384_ctr_aes,\n\t&safexcel_alg_authenc_hmac_sha512_ctr_aes,\n\t&safexcel_alg_xts_aes,\n\t&safexcel_alg_gcm,\n\t&safexcel_alg_ccm,\n\t&safexcel_alg_crc32,\n\t&safexcel_alg_cbcmac,\n\t&safexcel_alg_xcbcmac,\n\t&safexcel_alg_cmac,\n\t&safexcel_alg_chacha20,\n\t&safexcel_alg_chachapoly,\n\t&safexcel_alg_chachapoly_esp,\n\t&safexcel_alg_sm3,\n\t&safexcel_alg_hmac_sm3,\n\t&safexcel_alg_ecb_sm4,\n\t&safexcel_alg_cbc_sm4,\n\t&safexcel_alg_ofb_sm4,\n\t&safexcel_alg_cfb_sm4,\n\t&safexcel_alg_ctr_sm4,\n\t&safexcel_alg_authenc_hmac_sha1_cbc_sm4,\n\t&safexcel_alg_authenc_hmac_sm3_cbc_sm4,\n\t&safexcel_alg_authenc_hmac_sha1_ctr_sm4,\n\t&safexcel_alg_authenc_hmac_sm3_ctr_sm4,\n\t&safexcel_alg_sha3_224,\n\t&safexcel_alg_sha3_256,\n\t&safexcel_alg_sha3_384,\n\t&safexcel_alg_sha3_512,\n\t&safexcel_alg_hmac_sha3_224,\n\t&safexcel_alg_hmac_sha3_256,\n\t&safexcel_alg_hmac_sha3_384,\n\t&safexcel_alg_hmac_sha3_512,\n\t&safexcel_alg_authenc_hmac_sha1_cbc_des,\n\t&safexcel_alg_authenc_hmac_sha256_cbc_des3_ede,\n\t&safexcel_alg_authenc_hmac_sha224_cbc_des3_ede,\n\t&safexcel_alg_authenc_hmac_sha512_cbc_des3_ede,\n\t&safexcel_alg_authenc_hmac_sha384_cbc_des3_ede,\n\t&safexcel_alg_authenc_hmac_sha256_cbc_des,\n\t&safexcel_alg_authenc_hmac_sha224_cbc_des,\n\t&safexcel_alg_authenc_hmac_sha512_cbc_des,\n\t&safexcel_alg_authenc_hmac_sha384_cbc_des,\n\t&safexcel_alg_rfc4106_gcm,\n\t&safexcel_alg_rfc4543_gcm,\n\t&safexcel_alg_rfc4309_ccm,\n};\n\nstatic int safexcel_register_algorithms(struct safexcel_crypto_priv *priv)\n{\n\tint i, j, ret = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(safexcel_algs); i++) {\n\t\tsafexcel_algs[i]->priv = priv;\n\n\t\t \n\t\tif ((safexcel_algs[i]->algo_mask & priv->hwconfig.algo_flags) !=\n\t\t    safexcel_algs[i]->algo_mask)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tif (safexcel_algs[i]->type == SAFEXCEL_ALG_TYPE_SKCIPHER)\n\t\t\tret = crypto_register_skcipher(&safexcel_algs[i]->alg.skcipher);\n\t\telse if (safexcel_algs[i]->type == SAFEXCEL_ALG_TYPE_AEAD)\n\t\t\tret = crypto_register_aead(&safexcel_algs[i]->alg.aead);\n\t\telse\n\t\t\tret = crypto_register_ahash(&safexcel_algs[i]->alg.ahash);\n\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tfor (j = 0; j < i; j++) {\n\t\t \n\t\tif ((safexcel_algs[j]->algo_mask & priv->hwconfig.algo_flags) !=\n\t\t    safexcel_algs[j]->algo_mask)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tif (safexcel_algs[j]->type == SAFEXCEL_ALG_TYPE_SKCIPHER)\n\t\t\tcrypto_unregister_skcipher(&safexcel_algs[j]->alg.skcipher);\n\t\telse if (safexcel_algs[j]->type == SAFEXCEL_ALG_TYPE_AEAD)\n\t\t\tcrypto_unregister_aead(&safexcel_algs[j]->alg.aead);\n\t\telse\n\t\t\tcrypto_unregister_ahash(&safexcel_algs[j]->alg.ahash);\n\t}\n\n\treturn ret;\n}\n\nstatic void safexcel_unregister_algorithms(struct safexcel_crypto_priv *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(safexcel_algs); i++) {\n\t\t \n\t\tif ((safexcel_algs[i]->algo_mask & priv->hwconfig.algo_flags) !=\n\t\t    safexcel_algs[i]->algo_mask)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tif (safexcel_algs[i]->type == SAFEXCEL_ALG_TYPE_SKCIPHER)\n\t\t\tcrypto_unregister_skcipher(&safexcel_algs[i]->alg.skcipher);\n\t\telse if (safexcel_algs[i]->type == SAFEXCEL_ALG_TYPE_AEAD)\n\t\t\tcrypto_unregister_aead(&safexcel_algs[i]->alg.aead);\n\t\telse\n\t\t\tcrypto_unregister_ahash(&safexcel_algs[i]->alg.ahash);\n\t}\n}\n\nstatic void safexcel_configure(struct safexcel_crypto_priv *priv)\n{\n\tu32 mask = BIT(priv->hwconfig.hwdataw) - 1;\n\n\tpriv->config.pes = priv->hwconfig.hwnumpes;\n\tpriv->config.rings = min_t(u32, priv->hwconfig.hwnumrings, max_rings);\n\t \n\tpriv->config.rings = min_t(u32, priv->config.rings,\n\t\t\t\t\tpriv->hwconfig.hwnumraic);\n\n\tpriv->config.cd_size = EIP197_CD64_FETCH_SIZE;\n\tpriv->config.cd_offset = (priv->config.cd_size + mask) & ~mask;\n\tpriv->config.cdsh_offset = (EIP197_MAX_TOKENS + mask) & ~mask;\n\n\t \n\tpriv->config.res_offset = (EIP197_RD64_FETCH_SIZE + mask) & ~mask;\n\t \n\tpriv->config.rd_size    = priv->config.res_offset +\n\t\t\t\t  EIP197_RD64_RESULT_SIZE;\n\tpriv->config.rd_offset = (priv->config.rd_size + mask) & ~mask;\n\n\t \n\tpriv->config.cd_offset *= sizeof(u32);\n\tpriv->config.cdsh_offset *= sizeof(u32);\n\tpriv->config.rd_offset *= sizeof(u32);\n\tpriv->config.res_offset *= sizeof(u32);\n}\n\nstatic void safexcel_init_register_offsets(struct safexcel_crypto_priv *priv)\n{\n\tstruct safexcel_register_offsets *offsets = &priv->offsets;\n\n\tif (priv->flags & SAFEXCEL_HW_EIP197) {\n\t\toffsets->hia_aic\t= EIP197_HIA_AIC_BASE;\n\t\toffsets->hia_aic_g\t= EIP197_HIA_AIC_G_BASE;\n\t\toffsets->hia_aic_r\t= EIP197_HIA_AIC_R_BASE;\n\t\toffsets->hia_aic_xdr\t= EIP197_HIA_AIC_xDR_BASE;\n\t\toffsets->hia_dfe\t= EIP197_HIA_DFE_BASE;\n\t\toffsets->hia_dfe_thr\t= EIP197_HIA_DFE_THR_BASE;\n\t\toffsets->hia_dse\t= EIP197_HIA_DSE_BASE;\n\t\toffsets->hia_dse_thr\t= EIP197_HIA_DSE_THR_BASE;\n\t\toffsets->hia_gen_cfg\t= EIP197_HIA_GEN_CFG_BASE;\n\t\toffsets->pe\t\t= EIP197_PE_BASE;\n\t\toffsets->global\t\t= EIP197_GLOBAL_BASE;\n\t} else {\n\t\toffsets->hia_aic\t= EIP97_HIA_AIC_BASE;\n\t\toffsets->hia_aic_g\t= EIP97_HIA_AIC_G_BASE;\n\t\toffsets->hia_aic_r\t= EIP97_HIA_AIC_R_BASE;\n\t\toffsets->hia_aic_xdr\t= EIP97_HIA_AIC_xDR_BASE;\n\t\toffsets->hia_dfe\t= EIP97_HIA_DFE_BASE;\n\t\toffsets->hia_dfe_thr\t= EIP97_HIA_DFE_THR_BASE;\n\t\toffsets->hia_dse\t= EIP97_HIA_DSE_BASE;\n\t\toffsets->hia_dse_thr\t= EIP97_HIA_DSE_THR_BASE;\n\t\toffsets->hia_gen_cfg\t= EIP97_HIA_GEN_CFG_BASE;\n\t\toffsets->pe\t\t= EIP97_PE_BASE;\n\t\toffsets->global\t\t= EIP97_GLOBAL_BASE;\n\t}\n}\n\n \nstatic int safexcel_probe_generic(void *pdev,\n\t\t\t\t  struct safexcel_crypto_priv *priv,\n\t\t\t\t  int is_pci_dev)\n{\n\tstruct device *dev = priv->dev;\n\tu32 peid, version, mask, val, hiaopt, hwopt, peopt;\n\tint i, ret, hwctg;\n\n\tpriv->context_pool = dmam_pool_create(\"safexcel-context\", dev,\n\t\t\t\t\t      sizeof(struct safexcel_context_record),\n\t\t\t\t\t      1, 0);\n\tif (!priv->context_pool)\n\t\treturn -ENOMEM;\n\n\t \n\tversion = readl(priv->base + EIP97_HIA_AIC_BASE + EIP197_HIA_VERSION);\n\n\tmask = 0;   \n\tif (EIP197_REG_LO16(version) == EIP197_HIA_VERSION_LE) {\n\t\tpriv->hwconfig.hiaver = EIP197_VERSION_MASK(version);\n\t} else if (EIP197_REG_HI16(version) == EIP197_HIA_VERSION_BE) {\n\t\t \n\t\tmask = EIP197_MST_CTRL_BYTE_SWAP_BITS;\n\t\tpriv->hwconfig.hiaver = EIP197_VERSION_SWAP(version);\n\t} else {\n\t\t \n\t\tversion = readl(priv->base + EIP197_HIA_AIC_BASE +\n\t\t\t\tEIP197_HIA_VERSION);\n\t\tif (EIP197_REG_LO16(version) == EIP197_HIA_VERSION_LE) {\n\t\t\tpriv->hwconfig.hiaver = EIP197_VERSION_MASK(version);\n\t\t\tpriv->flags |= SAFEXCEL_HW_EIP197;\n\t\t} else if (EIP197_REG_HI16(version) ==\n\t\t\t   EIP197_HIA_VERSION_BE) {\n\t\t\t \n\t\t\tmask = EIP197_MST_CTRL_BYTE_SWAP_BITS;\n\t\t\tpriv->hwconfig.hiaver = EIP197_VERSION_SWAP(version);\n\t\t\tpriv->flags |= SAFEXCEL_HW_EIP197;\n\t\t} else {\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tsafexcel_init_register_offsets(priv);\n\n\t \n\tif (mask) {\n\t\tval = readl(EIP197_HIA_AIC(priv) + EIP197_HIA_MST_CTRL);\n\t\tval = val ^ (mask >> 24);  \n\t\twritel(val, EIP197_HIA_AIC(priv) + EIP197_HIA_MST_CTRL);\n\t}\n\n\t \n\tversion = readl(EIP197_GLOBAL(priv) + EIP197_VERSION);\n\tif (((priv->flags & SAFEXCEL_HW_EIP197) &&\n\t     (EIP197_REG_LO16(version) != EIP197_VERSION_LE) &&\n\t     (EIP197_REG_LO16(version) != EIP196_VERSION_LE)) ||\n\t    ((!(priv->flags & SAFEXCEL_HW_EIP197) &&\n\t     (EIP197_REG_LO16(version) != EIP97_VERSION_LE)))) {\n\t\t \n\t\tdev_err(priv->dev, \"Probing for EIP97/EIP19x failed - no such device (read %08x)\\n\",\n\t\t\tversion);\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->hwconfig.hwver = EIP197_VERSION_MASK(version);\n\thwctg = version >> 28;\n\tpeid = version & 255;\n\n\t \n\tversion = readl(EIP197_PE(priv) + + EIP197_PE_VERSION(0));\n\tif (EIP197_REG_LO16(version) != EIP206_VERSION_LE) {\n\t\tdev_err(priv->dev, \"EIP%d: EIP206 not detected\\n\", peid);\n\t\treturn -ENODEV;\n\t}\n\tpriv->hwconfig.ppver = EIP197_VERSION_MASK(version);\n\n\t \n\tversion = readl(EIP197_PE(priv) + EIP197_PE_EIP96_VERSION(0));\n\tif (EIP197_REG_LO16(version) != EIP96_VERSION_LE) {\n\t\tdev_err(dev, \"EIP%d: EIP96 not detected.\\n\", peid);\n\t\treturn -ENODEV;\n\t}\n\tpriv->hwconfig.pever = EIP197_VERSION_MASK(version);\n\n\thwopt = readl(EIP197_GLOBAL(priv) + EIP197_OPTIONS);\n\thiaopt = readl(EIP197_HIA_AIC(priv) + EIP197_HIA_OPTIONS);\n\n\tpriv->hwconfig.icever = 0;\n\tpriv->hwconfig.ocever = 0;\n\tpriv->hwconfig.psever = 0;\n\tif (priv->flags & SAFEXCEL_HW_EIP197) {\n\t\t \n\t\tpeopt = readl(EIP197_PE(priv) + EIP197_PE_OPTIONS(0));\n\n\t\tpriv->hwconfig.hwdataw  = (hiaopt >> EIP197_HWDATAW_OFFSET) &\n\t\t\t\t\t  EIP197_HWDATAW_MASK;\n\t\tpriv->hwconfig.hwcfsize = ((hiaopt >> EIP197_CFSIZE_OFFSET) &\n\t\t\t\t\t   EIP197_CFSIZE_MASK) +\n\t\t\t\t\t  EIP197_CFSIZE_ADJUST;\n\t\tpriv->hwconfig.hwrfsize = ((hiaopt >> EIP197_RFSIZE_OFFSET) &\n\t\t\t\t\t   EIP197_RFSIZE_MASK) +\n\t\t\t\t\t  EIP197_RFSIZE_ADJUST;\n\t\tpriv->hwconfig.hwnumpes\t= (hiaopt >> EIP197_N_PES_OFFSET) &\n\t\t\t\t\t  EIP197_N_PES_MASK;\n\t\tpriv->hwconfig.hwnumrings = (hiaopt >> EIP197_N_RINGS_OFFSET) &\n\t\t\t\t\t    EIP197_N_RINGS_MASK;\n\t\tif (hiaopt & EIP197_HIA_OPT_HAS_PE_ARB)\n\t\t\tpriv->flags |= EIP197_PE_ARB;\n\t\tif (EIP206_OPT_ICE_TYPE(peopt) == 1) {\n\t\t\tpriv->flags |= EIP197_ICE;\n\t\t\t \n\t\t\tversion = readl(EIP197_PE(priv) +\n\t\t\t\t  EIP197_PE_ICE_VERSION(0));\n\t\t\tif (EIP197_REG_LO16(version) != EIP207_VERSION_LE) {\n\t\t\t\tdev_err(dev, \"EIP%d: ICE EIP207 not detected.\\n\",\n\t\t\t\t\tpeid);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tpriv->hwconfig.icever = EIP197_VERSION_MASK(version);\n\t\t}\n\t\tif (EIP206_OPT_OCE_TYPE(peopt) == 1) {\n\t\t\tpriv->flags |= EIP197_OCE;\n\t\t\t \n\t\t\tversion = readl(EIP197_PE(priv) + EIP197_PE_PSE_VERSION(0));\n\t\t\tif (EIP197_REG_LO16(version) != EIP96_VERSION_LE) {\n\t\t\t\tdev_err(dev, \"EIP%d: EIP96PP not detected.\\n\", peid);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tpriv->hwconfig.psever = EIP197_VERSION_MASK(version);\n\t\t\t \n\t\t\tversion = readl(EIP197_PE(priv) +\n\t\t\t\t  EIP197_PE_ICE_VERSION(0));\n\t\t\tif (EIP197_REG_LO16(version) != EIP207_VERSION_LE) {\n\t\t\t\tdev_err(dev, \"EIP%d: OCE EIP207 not detected.\\n\",\n\t\t\t\t\tpeid);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tpriv->hwconfig.ocever = EIP197_VERSION_MASK(version);\n\t\t}\n\t\t \n\t\tif (!(hwopt & EIP197_OPT_HAS_TRC))\n\t\t\tpriv->flags |= EIP197_SIMPLE_TRC;\n\t\t \n\t\tpriv->flags |= EIP197_TRC_CACHE;\n\t} else {\n\t\t \n\t\tpriv->hwconfig.hwdataw  = (hiaopt >> EIP197_HWDATAW_OFFSET) &\n\t\t\t\t\t  EIP97_HWDATAW_MASK;\n\t\tpriv->hwconfig.hwcfsize = (hiaopt >> EIP97_CFSIZE_OFFSET) &\n\t\t\t\t\t  EIP97_CFSIZE_MASK;\n\t\tpriv->hwconfig.hwrfsize = (hiaopt >> EIP97_RFSIZE_OFFSET) &\n\t\t\t\t\t  EIP97_RFSIZE_MASK;\n\t\tpriv->hwconfig.hwnumpes\t= 1;  \n\t\tpriv->hwconfig.hwnumrings = (hiaopt >> EIP197_N_RINGS_OFFSET) &\n\t\t\t\t\t    EIP197_N_RINGS_MASK;\n\t}\n\n\t \n\tfor (i = 0; i < EIP197_MAX_RING_AIC; i++) {\n\t\tversion = readl(EIP197_HIA_AIC_R(priv) +\n\t\t\t\tEIP197_HIA_AIC_R_VERSION(i));\n\t\tif (EIP197_REG_LO16(version) != EIP201_VERSION_LE)\n\t\t\tbreak;\n\t}\n\tpriv->hwconfig.hwnumraic = i;\n\t \n\tif (!priv->hwconfig.hwnumraic) {\n\t\tdev_err(priv->dev, \"No ring interrupt controller present!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpriv->hwconfig.algo_flags = readl(EIP197_PE(priv) +\n\t\t\t\t    EIP197_PE_EIP96_OPTIONS(0));\n\n\t \n\tdev_info(priv->dev, \"EIP%d:%x(%d,%d,%d,%d)-HIA:%x(%d,%d,%d),PE:%x/%x(alg:%08x)/%x/%x/%x\\n\",\n\t\t peid, priv->hwconfig.hwver, hwctg, priv->hwconfig.hwnumpes,\n\t\t priv->hwconfig.hwnumrings, priv->hwconfig.hwnumraic,\n\t\t priv->hwconfig.hiaver, priv->hwconfig.hwdataw,\n\t\t priv->hwconfig.hwcfsize, priv->hwconfig.hwrfsize,\n\t\t priv->hwconfig.ppver, priv->hwconfig.pever,\n\t\t priv->hwconfig.algo_flags, priv->hwconfig.icever,\n\t\t priv->hwconfig.ocever, priv->hwconfig.psever);\n\n\tsafexcel_configure(priv);\n\n\tif (IS_ENABLED(CONFIG_PCI) && priv->data->version == EIP197_DEVBRD) {\n\t\t \n\t\tstruct pci_dev *pci_pdev = pdev;\n\n\t\tret = pci_alloc_irq_vectors(pci_pdev,\n\t\t\t\t\t    priv->config.rings + 1,\n\t\t\t\t\t    priv->config.rings + 1,\n\t\t\t\t\t    PCI_IRQ_MSI | PCI_IRQ_MSIX);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to allocate PCI MSI interrupts\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tpriv->ring = devm_kcalloc(dev, priv->config.rings,\n\t\t\t\t  sizeof(*priv->ring),\n\t\t\t\t  GFP_KERNEL);\n\tif (!priv->ring)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < priv->config.rings; i++) {\n\t\tchar wq_name[9] = {0};\n\t\tint irq;\n\t\tstruct safexcel_ring_irq_data *ring_irq;\n\n\t\tret = safexcel_init_ring_descriptors(priv,\n\t\t\t\t\t\t     &priv->ring[i].cdr,\n\t\t\t\t\t\t     &priv->ring[i].rdr);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to initialize rings\\n\");\n\t\t\tgoto err_cleanup_rings;\n\t\t}\n\n\t\tpriv->ring[i].rdr_req = devm_kcalloc(dev,\n\t\t\tEIP197_DEFAULT_RING_SIZE,\n\t\t\tsizeof(*priv->ring[i].rdr_req),\n\t\t\tGFP_KERNEL);\n\t\tif (!priv->ring[i].rdr_req) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_cleanup_rings;\n\t\t}\n\n\t\tring_irq = devm_kzalloc(dev, sizeof(*ring_irq), GFP_KERNEL);\n\t\tif (!ring_irq) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_cleanup_rings;\n\t\t}\n\n\t\tring_irq->priv = priv;\n\t\tring_irq->ring = i;\n\n\t\tirq = safexcel_request_ring_irq(pdev,\n\t\t\t\t\t\tEIP197_IRQ_NUMBER(i, is_pci_dev),\n\t\t\t\t\t\tis_pci_dev,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tsafexcel_irq_ring,\n\t\t\t\t\t\tsafexcel_irq_ring_thread,\n\t\t\t\t\t\tring_irq);\n\t\tif (irq < 0) {\n\t\t\tdev_err(dev, \"Failed to get IRQ ID for ring %d\\n\", i);\n\t\t\tret = irq;\n\t\t\tgoto err_cleanup_rings;\n\t\t}\n\n\t\tpriv->ring[i].irq = irq;\n\t\tpriv->ring[i].work_data.priv = priv;\n\t\tpriv->ring[i].work_data.ring = i;\n\t\tINIT_WORK(&priv->ring[i].work_data.work,\n\t\t\t  safexcel_dequeue_work);\n\n\t\tsnprintf(wq_name, 9, \"wq_ring%d\", i);\n\t\tpriv->ring[i].workqueue =\n\t\t\tcreate_singlethread_workqueue(wq_name);\n\t\tif (!priv->ring[i].workqueue) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_cleanup_rings;\n\t\t}\n\n\t\tpriv->ring[i].requests = 0;\n\t\tpriv->ring[i].busy = false;\n\n\t\tcrypto_init_queue(&priv->ring[i].queue,\n\t\t\t\t  EIP197_DEFAULT_RING_SIZE);\n\n\t\tspin_lock_init(&priv->ring[i].lock);\n\t\tspin_lock_init(&priv->ring[i].queue_lock);\n\t}\n\n\tatomic_set(&priv->ring_used, 0);\n\n\tret = safexcel_hw_init(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"HW init failed (%d)\\n\", ret);\n\t\tgoto err_cleanup_rings;\n\t}\n\n\tret = safexcel_register_algorithms(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register algorithms (%d)\\n\", ret);\n\t\tgoto err_cleanup_rings;\n\t}\n\n\treturn 0;\n\nerr_cleanup_rings:\n\tfor (i = 0; i < priv->config.rings; i++) {\n\t\tif (priv->ring[i].irq)\n\t\t\tirq_set_affinity_hint(priv->ring[i].irq, NULL);\n\t\tif (priv->ring[i].workqueue)\n\t\t\tdestroy_workqueue(priv->ring[i].workqueue);\n\t}\n\n\treturn ret;\n}\n\nstatic void safexcel_hw_reset_rings(struct safexcel_crypto_priv *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->config.rings; i++) {\n\t\t \n\t\twritel(GENMASK(5, 0), EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_STAT);\n\t\twritel(GENMASK(7, 0), EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_STAT);\n\n\t\t \n\t\twritel(0, EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_LO);\n\t\twritel(0, EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_HI);\n\n\t\t \n\t\twritel(0, EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_LO);\n\t\twritel(0, EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_HI);\n\t}\n}\n\n \n\nstatic int safexcel_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct safexcel_crypto_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->data = (struct safexcel_priv_data *)of_device_get_match_data(dev);\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base)) {\n\t\tdev_err(dev, \"failed to get resource\\n\");\n\t\treturn PTR_ERR(priv->base);\n\t}\n\n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tret = PTR_ERR_OR_ZERO(priv->clk);\n\t \n\tif  (ret != -ENOENT) {\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = clk_prepare_enable(priv->clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"unable to enable clk (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpriv->reg_clk = devm_clk_get(&pdev->dev, \"reg\");\n\tret = PTR_ERR_OR_ZERO(priv->reg_clk);\n\t \n\tif  (ret != -ENOENT) {\n\t\tif (ret)\n\t\t\tgoto err_core_clk;\n\n\t\tret = clk_prepare_enable(priv->reg_clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"unable to enable reg clk (%d)\\n\", ret);\n\t\t\tgoto err_core_clk;\n\t\t}\n\t}\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));\n\tif (ret)\n\t\tgoto err_reg_clk;\n\n\t \n\tret = safexcel_probe_generic(pdev, priv, 0);\n\tif (ret)\n\t\tgoto err_reg_clk;\n\n\treturn 0;\n\nerr_reg_clk:\n\tclk_disable_unprepare(priv->reg_clk);\nerr_core_clk:\n\tclk_disable_unprepare(priv->clk);\n\treturn ret;\n}\n\nstatic int safexcel_remove(struct platform_device *pdev)\n{\n\tstruct safexcel_crypto_priv *priv = platform_get_drvdata(pdev);\n\tint i;\n\n\tsafexcel_unregister_algorithms(priv);\n\tsafexcel_hw_reset_rings(priv);\n\n\tclk_disable_unprepare(priv->reg_clk);\n\tclk_disable_unprepare(priv->clk);\n\n\tfor (i = 0; i < priv->config.rings; i++) {\n\t\tirq_set_affinity_hint(priv->ring[i].irq, NULL);\n\t\tdestroy_workqueue(priv->ring[i].workqueue);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct safexcel_priv_data eip97ies_mrvl_data = {\n\t.version = EIP97IES_MRVL,\n};\n\nstatic const struct safexcel_priv_data eip197b_mrvl_data = {\n\t.version = EIP197B_MRVL,\n};\n\nstatic const struct safexcel_priv_data eip197d_mrvl_data = {\n\t.version = EIP197D_MRVL,\n};\n\nstatic const struct safexcel_priv_data eip197_devbrd_data = {\n\t.version = EIP197_DEVBRD,\n};\n\nstatic const struct safexcel_priv_data eip197c_mxl_data = {\n\t.version = EIP197C_MXL,\n\t.fw_little_endian = true,\n};\n\nstatic const struct of_device_id safexcel_of_match_table[] = {\n\t{\n\t\t.compatible = \"inside-secure,safexcel-eip97ies\",\n\t\t.data = &eip97ies_mrvl_data,\n\t},\n\t{\n\t\t.compatible = \"inside-secure,safexcel-eip197b\",\n\t\t.data = &eip197b_mrvl_data,\n\t},\n\t{\n\t\t.compatible = \"inside-secure,safexcel-eip197d\",\n\t\t.data = &eip197d_mrvl_data,\n\t},\n\t{\n\t\t.compatible = \"inside-secure,safexcel-eip197c-mxl\",\n\t\t.data = &eip197c_mxl_data,\n\t},\n\t \n\t{\n\t\t.compatible = \"inside-secure,safexcel-eip97\",\n\t\t.data = &eip97ies_mrvl_data,\n\t},\n\t{\n\t\t.compatible = \"inside-secure,safexcel-eip197\",\n\t\t.data = &eip197b_mrvl_data,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, safexcel_of_match_table);\n\nstatic struct platform_driver  crypto_safexcel = {\n\t.probe\t\t= safexcel_probe,\n\t.remove\t\t= safexcel_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"crypto-safexcel\",\n\t\t.of_match_table = safexcel_of_match_table,\n\t},\n};\n\n \n\nstatic int safexcel_pci_probe(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *ent)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct safexcel_crypto_priv *priv;\n\tvoid __iomem *pciebase;\n\tint rc;\n\tu32 val;\n\n\tdev_dbg(dev, \"Probing PCIE device: vendor %04x, device %04x, subv %04x, subdev %04x, ctxt %lx\\n\",\n\t\tent->vendor, ent->device, ent->subvendor,\n\t\tent->subdevice, ent->driver_data);\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->data = (struct safexcel_priv_data *)ent->driver_data;\n\n\tpci_set_drvdata(pdev, priv);\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to enable PCI device\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\trc = pcim_iomap_regions(pdev, 1, \"crypto_safexcel\");\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to map IO region for BAR0\\n\");\n\t\treturn rc;\n\t}\n\tpriv->base = pcim_iomap_table(pdev)[0];\n\n\tif (priv->data->version == EIP197_DEVBRD) {\n\t\tdev_dbg(dev, \"Device identified as FPGA based development board - applying HW reset\\n\");\n\n\t\trc = pcim_iomap_regions(pdev, 4, \"crypto_safexcel\");\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Failed to map IO region for BAR4\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tpciebase = pcim_iomap_table(pdev)[2];\n\t\tval = readl(pciebase + EIP197_XLX_IRQ_BLOCK_ID_ADDR);\n\t\tif ((val >> 16) == EIP197_XLX_IRQ_BLOCK_ID_VALUE) {\n\t\t\tdev_dbg(dev, \"Detected Xilinx PCIE IRQ block version %d, multiple MSI support enabled\\n\",\n\t\t\t\t(val & 0xff));\n\n\t\t\t \n\t\t\twritel(EIP197_XLX_USER_VECT_LUT0_IDENT,\n\t\t\t       pciebase + EIP197_XLX_USER_VECT_LUT0_ADDR);\n\t\t\twritel(EIP197_XLX_USER_VECT_LUT1_IDENT,\n\t\t\t       pciebase + EIP197_XLX_USER_VECT_LUT1_ADDR);\n\t\t\twritel(EIP197_XLX_USER_VECT_LUT2_IDENT,\n\t\t\t       pciebase + EIP197_XLX_USER_VECT_LUT2_ADDR);\n\t\t\twritel(EIP197_XLX_USER_VECT_LUT3_IDENT,\n\t\t\t       pciebase + EIP197_XLX_USER_VECT_LUT3_ADDR);\n\n\t\t\t \n\t\t\twritel(GENMASK(31, 0),\n\t\t\t       pciebase + EIP197_XLX_USER_INT_ENB_MSK);\n\t\t} else {\n\t\t\tdev_err(dev, \"Unrecognised IRQ block identifier %x\\n\",\n\t\t\t\tval);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\t \n\t\twritel(1, priv->base + EIP197_XLX_GPIO_BASE);\n\t\twmb();  \n\t\t \n\t\twritel(0, priv->base + EIP197_XLX_GPIO_BASE);\n\t\twmb();  \n\t}\n\n\t \n\tpci_set_master(pdev);\n\n\t \n\trc = safexcel_probe_generic(pdev, priv, 1);\n\treturn rc;\n}\n\nstatic void safexcel_pci_remove(struct pci_dev *pdev)\n{\n\tstruct safexcel_crypto_priv *priv = pci_get_drvdata(pdev);\n\tint i;\n\n\tsafexcel_unregister_algorithms(priv);\n\n\tfor (i = 0; i < priv->config.rings; i++)\n\t\tdestroy_workqueue(priv->ring[i].workqueue);\n\n\tsafexcel_hw_reset_rings(priv);\n}\n\nstatic const struct pci_device_id safexcel_pci_ids[] = {\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_XILINX, 0x9038,\n\t\t\t       0x16ae, 0xc522),\n\t\t.driver_data = (kernel_ulong_t)&eip197_devbrd_data,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(pci, safexcel_pci_ids);\n\nstatic struct pci_driver safexcel_pci_driver = {\n\t.name          = \"crypto-safexcel\",\n\t.id_table      = safexcel_pci_ids,\n\t.probe         = safexcel_pci_probe,\n\t.remove        = safexcel_pci_remove,\n};\n\nstatic int __init safexcel_init(void)\n{\n\tint ret;\n\n\t \n\tret = pci_register_driver(&safexcel_pci_driver);\n\n\t \n\tif (IS_ENABLED(CONFIG_OF) && !ret) {\n\t\tret = platform_driver_register(&crypto_safexcel);\n\t\tif (ret)\n\t\t\tpci_unregister_driver(&safexcel_pci_driver);\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit safexcel_exit(void)\n{\n\t \n\tif (IS_ENABLED(CONFIG_OF))\n\t\tplatform_driver_unregister(&crypto_safexcel);\n\n\t \n\tpci_unregister_driver(&safexcel_pci_driver);\n}\n\nmodule_init(safexcel_init);\nmodule_exit(safexcel_exit);\n\nMODULE_AUTHOR(\"Antoine Tenart <antoine.tenart@free-electrons.com>\");\nMODULE_AUTHOR(\"Ofer Heifetz <oferh@marvell.com>\");\nMODULE_AUTHOR(\"Igal Liberman <igall@marvell.com>\");\nMODULE_DESCRIPTION(\"Support for SafeXcel cryptographic engines: EIP97 & EIP197\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n\nMODULE_FIRMWARE(\"ifpp.bin\");\nMODULE_FIRMWARE(\"ipue.bin\");\nMODULE_FIRMWARE(\"inside-secure/eip197b/ifpp.bin\");\nMODULE_FIRMWARE(\"inside-secure/eip197b/ipue.bin\");\nMODULE_FIRMWARE(\"inside-secure/eip197d/ifpp.bin\");\nMODULE_FIRMWARE(\"inside-secure/eip197d/ipue.bin\");\nMODULE_FIRMWARE(\"inside-secure/eip197_minifw/ifpp.bin\");\nMODULE_FIRMWARE(\"inside-secure/eip197_minifw/ipue.bin\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}