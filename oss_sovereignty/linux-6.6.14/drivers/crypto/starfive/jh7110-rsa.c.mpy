{
  "module_name": "jh7110-rsa.c",
  "hash_id": "46c1636b3afb0454965ff4a8b9c9dac0d1f85b12002e037d4ba973fe91e854c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/starfive/jh7110-rsa.c",
  "human_readable_source": "\n \n\n#include <linux/crypto.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-direct.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <crypto/akcipher.h>\n#include <crypto/algapi.h>\n#include <crypto/internal/akcipher.h>\n#include <crypto/internal/rsa.h>\n#include <crypto/scatterwalk.h>\n\n#include \"jh7110-cryp.h\"\n\n#define STARFIVE_PKA_REGS_OFFSET\t0x400\n#define STARFIVE_PKA_CACR_OFFSET\t(STARFIVE_PKA_REGS_OFFSET + 0x0)\n#define STARFIVE_PKA_CASR_OFFSET\t(STARFIVE_PKA_REGS_OFFSET + 0x4)\n#define STARFIVE_PKA_CAAR_OFFSET\t(STARFIVE_PKA_REGS_OFFSET + 0x8)\n#define STARFIVE_PKA_CAER_OFFSET\t(STARFIVE_PKA_REGS_OFFSET + 0x108)\n#define STARFIVE_PKA_CANR_OFFSET\t(STARFIVE_PKA_REGS_OFFSET + 0x208)\n\n\n#define CRYPTO_CMD_PRE\t\t\t0x0\n\n#define CRYPTO_CMD_ARN\t\t\t0x5\n\n#define CRYPTO_CMD_AERN\t\t\t0x6\n\n#define CRYPTO_CMD_AARN\t\t\t0x7\n\n#define STARFIVE_RSA_MAX_KEYSZ\t\t256\n#define STARFIVE_RSA_RESET\t\t0x2\n\nstatic inline int starfive_pka_wait_done(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\n\treturn wait_for_completion_timeout(&cryp->pka_done,\n\t\t\t\t\t   usecs_to_jiffies(100000));\n}\n\nstatic inline void starfive_pka_irq_mask_clear(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tu32 stat;\n\n\tstat = readl(cryp->base + STARFIVE_IE_MASK_OFFSET);\n\tstat &= ~STARFIVE_IE_MASK_PKA_DONE;\n\twritel(stat, cryp->base + STARFIVE_IE_MASK_OFFSET);\n\n\treinit_completion(&cryp->pka_done);\n}\n\nstatic void starfive_rsa_free_key(struct starfive_rsa_key *key)\n{\n\tif (key->d)\n\t\tkfree_sensitive(key->d);\n\tif (key->e)\n\t\tkfree_sensitive(key->e);\n\tif (key->n)\n\t\tkfree_sensitive(key->n);\n\tmemset(key, 0, sizeof(*key));\n}\n\nstatic unsigned int starfive_rsa_get_nbit(u8 *pa, u32 snum, int key_sz)\n{\n\tu32 i;\n\tu8 value;\n\n\ti = snum >> 3;\n\n\tvalue = pa[key_sz - i - 1];\n\tvalue >>= snum & 0x7;\n\tvalue &= 0x1;\n\n\treturn value;\n}\n\nstatic int starfive_rsa_montgomery_form(struct starfive_cryp_ctx *ctx,\n\t\t\t\t\tu32 *out, u32 *in, u8 mont,\n\t\t\t\t\tu32 *mod, int bit_len)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tstruct starfive_cryp_request_ctx *rctx = ctx->rctx;\n\tint count = rctx->total / sizeof(u32) - 1;\n\tint loop;\n\tu32 temp;\n\tu8 opsize;\n\n\topsize = (bit_len - 1) >> 5;\n\trctx->csr.pka.v = 0;\n\n\twritel(rctx->csr.pka.v, cryp->base + STARFIVE_PKA_CACR_OFFSET);\n\n\tfor (loop = 0; loop <= opsize; loop++)\n\t\twritel(mod[opsize - loop], cryp->base + STARFIVE_PKA_CANR_OFFSET + loop * 4);\n\n\tif (mont) {\n\t\trctx->csr.pka.v = 0;\n\t\trctx->csr.pka.cln_done = 1;\n\t\trctx->csr.pka.opsize = opsize;\n\t\trctx->csr.pka.exposize = opsize;\n\t\trctx->csr.pka.cmd = CRYPTO_CMD_PRE;\n\t\trctx->csr.pka.start = 1;\n\t\trctx->csr.pka.not_r2 = 1;\n\t\trctx->csr.pka.ie = 1;\n\n\t\tstarfive_pka_irq_mask_clear(ctx);\n\t\twritel(rctx->csr.pka.v, cryp->base + STARFIVE_PKA_CACR_OFFSET);\n\n\t\tif (!starfive_pka_wait_done(ctx))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tfor (loop = 0; loop <= opsize; loop++)\n\t\t\twritel(in[opsize - loop], cryp->base + STARFIVE_PKA_CAAR_OFFSET + loop * 4);\n\n\t\twritel(0x1000000, cryp->base + STARFIVE_PKA_CAER_OFFSET);\n\n\t\tfor (loop = 1; loop <= opsize; loop++)\n\t\t\twritel(0, cryp->base + STARFIVE_PKA_CAER_OFFSET + loop * 4);\n\n\t\trctx->csr.pka.v = 0;\n\t\trctx->csr.pka.cln_done = 1;\n\t\trctx->csr.pka.opsize = opsize;\n\t\trctx->csr.pka.exposize = opsize;\n\t\trctx->csr.pka.cmd = CRYPTO_CMD_AERN;\n\t\trctx->csr.pka.start = 1;\n\t\trctx->csr.pka.ie = 1;\n\n\t\tstarfive_pka_irq_mask_clear(ctx);\n\t\twritel(rctx->csr.pka.v, cryp->base + STARFIVE_PKA_CACR_OFFSET);\n\n\t\tif (!starfive_pka_wait_done(ctx))\n\t\t\treturn -ETIMEDOUT;\n\t} else {\n\t\trctx->csr.pka.v = 0;\n\t\trctx->csr.pka.cln_done = 1;\n\t\trctx->csr.pka.opsize = opsize;\n\t\trctx->csr.pka.exposize = opsize;\n\t\trctx->csr.pka.cmd = CRYPTO_CMD_PRE;\n\t\trctx->csr.pka.start = 1;\n\t\trctx->csr.pka.pre_expf = 1;\n\t\trctx->csr.pka.ie = 1;\n\n\t\tstarfive_pka_irq_mask_clear(ctx);\n\t\twritel(rctx->csr.pka.v, cryp->base + STARFIVE_PKA_CACR_OFFSET);\n\n\t\tif (!starfive_pka_wait_done(ctx))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tfor (loop = 0; loop <= count; loop++)\n\t\t\twritel(in[count - loop], cryp->base + STARFIVE_PKA_CAER_OFFSET + loop * 4);\n\n\t\t \n\t\tfor (loop = count + 1; loop <= opsize; loop++)\n\t\t\twritel(0, cryp->base + STARFIVE_PKA_CAER_OFFSET + loop * 4);\n\n\t\trctx->csr.pka.v = 0;\n\t\trctx->csr.pka.cln_done = 1;\n\t\trctx->csr.pka.opsize = opsize;\n\t\trctx->csr.pka.exposize = opsize;\n\t\trctx->csr.pka.cmd = CRYPTO_CMD_ARN;\n\t\trctx->csr.pka.start = 1;\n\t\trctx->csr.pka.ie = 1;\n\n\t\tstarfive_pka_irq_mask_clear(ctx);\n\t\twritel(rctx->csr.pka.v, cryp->base + STARFIVE_PKA_CACR_OFFSET);\n\n\t\tif (!starfive_pka_wait_done(ctx))\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\tfor (loop = 0; loop <= opsize; loop++) {\n\t\ttemp = readl(cryp->base + STARFIVE_PKA_CAAR_OFFSET + 0x4 * loop);\n\t\tout[opsize - loop] = temp;\n\t}\n\n\treturn 0;\n}\n\nstatic int starfive_rsa_cpu_start(struct starfive_cryp_ctx *ctx, u32 *result,\n\t\t\t\t  u8 *de, u32 *n, int key_sz)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tstruct starfive_cryp_request_ctx *rctx = ctx->rctx;\n\tstruct starfive_rsa_key *key = &ctx->rsa_key;\n\tu32 temp;\n\tint ret = 0;\n\tint opsize, mlen, loop;\n\tunsigned int *mta;\n\n\topsize = (key_sz - 1) >> 2;\n\n\tmta = kmalloc(key_sz, GFP_KERNEL);\n\tif (!mta)\n\t\treturn -ENOMEM;\n\n\tret = starfive_rsa_montgomery_form(ctx, mta, (u32 *)rctx->rsa_data,\n\t\t\t\t\t   0, n, key_sz << 3);\n\tif (ret) {\n\t\tdev_err_probe(cryp->dev, ret, \"Conversion to Montgomery failed\");\n\t\tgoto rsa_err;\n\t}\n\n\tfor (loop = 0; loop <= opsize; loop++)\n\t\twritel(mta[opsize - loop],\n\t\t       cryp->base + STARFIVE_PKA_CAER_OFFSET + loop * 4);\n\n\tfor (loop = key->bitlen - 1; loop > 0; loop--) {\n\t\tmlen = starfive_rsa_get_nbit(de, loop - 1, key_sz);\n\n\t\trctx->csr.pka.v = 0;\n\t\trctx->csr.pka.cln_done = 1;\n\t\trctx->csr.pka.opsize = opsize;\n\t\trctx->csr.pka.exposize = opsize;\n\t\trctx->csr.pka.cmd = CRYPTO_CMD_AARN;\n\t\trctx->csr.pka.start = 1;\n\t\trctx->csr.pka.ie = 1;\n\n\t\tstarfive_pka_irq_mask_clear(ctx);\n\t\twritel(rctx->csr.pka.v, cryp->base + STARFIVE_PKA_CACR_OFFSET);\n\n\t\tret = -ETIMEDOUT;\n\t\tif (!starfive_pka_wait_done(ctx))\n\t\t\tgoto rsa_err;\n\n\t\tif (mlen) {\n\t\t\trctx->csr.pka.v = 0;\n\t\t\trctx->csr.pka.cln_done = 1;\n\t\t\trctx->csr.pka.opsize = opsize;\n\t\t\trctx->csr.pka.exposize = opsize;\n\t\t\trctx->csr.pka.cmd = CRYPTO_CMD_AERN;\n\t\t\trctx->csr.pka.start = 1;\n\t\t\trctx->csr.pka.ie = 1;\n\n\t\t\tstarfive_pka_irq_mask_clear(ctx);\n\t\t\twritel(rctx->csr.pka.v, cryp->base + STARFIVE_PKA_CACR_OFFSET);\n\n\t\t\tif (!starfive_pka_wait_done(ctx))\n\t\t\t\tgoto rsa_err;\n\t\t}\n\t}\n\n\tfor (loop = 0; loop <= opsize; loop++) {\n\t\ttemp = readl(cryp->base + STARFIVE_PKA_CAAR_OFFSET + 0x4 * loop);\n\t\tresult[opsize - loop] = temp;\n\t}\n\n\tret = starfive_rsa_montgomery_form(ctx, result, result, 1, n, key_sz << 3);\n\tif (ret)\n\t\tdev_err_probe(cryp->dev, ret, \"Conversion from Montgomery failed\");\nrsa_err:\n\tkfree(mta);\n\treturn ret;\n}\n\nstatic int starfive_rsa_start(struct starfive_cryp_ctx *ctx, u8 *result,\n\t\t\t      u8 *de, u8 *n, int key_sz)\n{\n\treturn starfive_rsa_cpu_start(ctx, (u32 *)result, de, (u32 *)n, key_sz);\n}\n\nstatic int starfive_rsa_enc_core(struct starfive_cryp_ctx *ctx, int enc)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tstruct starfive_cryp_request_ctx *rctx = ctx->rctx;\n\tstruct starfive_rsa_key *key = &ctx->rsa_key;\n\tint ret = 0;\n\n\twritel(STARFIVE_RSA_RESET, cryp->base + STARFIVE_PKA_CACR_OFFSET);\n\n\trctx->total = sg_copy_to_buffer(rctx->in_sg, rctx->nents,\n\t\t\t\t\trctx->rsa_data, rctx->total);\n\n\tif (enc) {\n\t\tkey->bitlen = key->e_bitlen;\n\t\tret = starfive_rsa_start(ctx, rctx->rsa_data, key->e,\n\t\t\t\t\t key->n, key->key_sz);\n\t} else {\n\t\tkey->bitlen = key->d_bitlen;\n\t\tret = starfive_rsa_start(ctx, rctx->rsa_data, key->d,\n\t\t\t\t\t key->n, key->key_sz);\n\t}\n\n\tif (ret)\n\t\tgoto err_rsa_crypt;\n\n\tsg_copy_buffer(rctx->out_sg, sg_nents(rctx->out_sg),\n\t\t       rctx->rsa_data, key->key_sz, 0, 0);\n\nerr_rsa_crypt:\n\twritel(STARFIVE_RSA_RESET, cryp->base + STARFIVE_PKA_CACR_OFFSET);\n\tkfree(rctx->rsa_data);\n\treturn ret;\n}\n\nstatic int starfive_rsa_enc(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct starfive_cryp_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tstruct starfive_rsa_key *key = &ctx->rsa_key;\n\tstruct starfive_cryp_request_ctx *rctx = akcipher_request_ctx(req);\n\tint ret;\n\n\tif (!key->key_sz) {\n\t\takcipher_request_set_tfm(req, ctx->akcipher_fbk);\n\t\tret = crypto_akcipher_encrypt(req);\n\t\takcipher_request_set_tfm(req, tfm);\n\t\treturn ret;\n\t}\n\n\tif (unlikely(!key->n || !key->e))\n\t\treturn -EINVAL;\n\n\tif (req->dst_len < key->key_sz)\n\t\treturn dev_err_probe(cryp->dev, -EOVERFLOW,\n\t\t\t\t     \"Output buffer length less than parameter n\\n\");\n\n\trctx->in_sg = req->src;\n\trctx->out_sg = req->dst;\n\trctx->total = req->src_len;\n\trctx->nents = sg_nents(rctx->in_sg);\n\tctx->rctx = rctx;\n\n\treturn starfive_rsa_enc_core(ctx, 1);\n}\n\nstatic int starfive_rsa_dec(struct akcipher_request *req)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct starfive_cryp_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tstruct starfive_rsa_key *key = &ctx->rsa_key;\n\tstruct starfive_cryp_request_ctx *rctx = akcipher_request_ctx(req);\n\tint ret;\n\n\tif (!key->key_sz) {\n\t\takcipher_request_set_tfm(req, ctx->akcipher_fbk);\n\t\tret = crypto_akcipher_decrypt(req);\n\t\takcipher_request_set_tfm(req, tfm);\n\t\treturn ret;\n\t}\n\n\tif (unlikely(!key->n || !key->d))\n\t\treturn -EINVAL;\n\n\tif (req->dst_len < key->key_sz)\n\t\treturn dev_err_probe(cryp->dev, -EOVERFLOW,\n\t\t\t\t     \"Output buffer length less than parameter n\\n\");\n\n\trctx->in_sg = req->src;\n\trctx->out_sg = req->dst;\n\tctx->rctx = rctx;\n\trctx->total = req->src_len;\n\n\treturn starfive_rsa_enc_core(ctx, 0);\n}\n\nstatic int starfive_rsa_set_n(struct starfive_rsa_key *rsa_key,\n\t\t\t      const char *value, size_t vlen)\n{\n\tconst char *ptr = value;\n\tunsigned int bitslen;\n\tint ret;\n\n\twhile (!*ptr && vlen) {\n\t\tptr++;\n\t\tvlen--;\n\t}\n\trsa_key->key_sz = vlen;\n\tbitslen = rsa_key->key_sz << 3;\n\n\t \n\tif (bitslen & 0x1f)\n\t\treturn -EINVAL;\n\n\tret = -ENOMEM;\n\trsa_key->n = kmemdup(ptr, rsa_key->key_sz, GFP_KERNEL);\n\tif (!rsa_key->n)\n\t\tgoto err;\n\n\treturn 0;\n err:\n\trsa_key->key_sz = 0;\n\trsa_key->n = NULL;\n\tstarfive_rsa_free_key(rsa_key);\n\treturn ret;\n}\n\nstatic int starfive_rsa_set_e(struct starfive_rsa_key *rsa_key,\n\t\t\t      const char *value, size_t vlen)\n{\n\tconst char *ptr = value;\n\tunsigned char pt;\n\tint loop;\n\n\twhile (!*ptr && vlen) {\n\t\tptr++;\n\t\tvlen--;\n\t}\n\tpt = *ptr;\n\n\tif (!rsa_key->key_sz || !vlen || vlen > rsa_key->key_sz) {\n\t\trsa_key->e = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\trsa_key->e = kzalloc(rsa_key->key_sz, GFP_KERNEL);\n\tif (!rsa_key->e)\n\t\treturn -ENOMEM;\n\n\tfor (loop = 8; loop > 0; loop--) {\n\t\tif (pt >> (loop - 1))\n\t\t\tbreak;\n\t}\n\n\trsa_key->e_bitlen = (vlen - 1) * 8 + loop;\n\n\tmemcpy(rsa_key->e + (rsa_key->key_sz - vlen), ptr, vlen);\n\n\treturn 0;\n}\n\nstatic int starfive_rsa_set_d(struct starfive_rsa_key *rsa_key,\n\t\t\t      const char *value, size_t vlen)\n{\n\tconst char *ptr = value;\n\tunsigned char pt;\n\tint loop;\n\tint ret;\n\n\twhile (!*ptr && vlen) {\n\t\tptr++;\n\t\tvlen--;\n\t}\n\tpt = *ptr;\n\n\tret = -EINVAL;\n\tif (!rsa_key->key_sz || !vlen || vlen > rsa_key->key_sz)\n\t\tgoto err;\n\n\tret = -ENOMEM;\n\trsa_key->d = kzalloc(rsa_key->key_sz, GFP_KERNEL);\n\tif (!rsa_key->d)\n\t\tgoto err;\n\n\tfor (loop = 8; loop > 0; loop--) {\n\t\tif (pt >> (loop - 1))\n\t\t\tbreak;\n\t}\n\n\trsa_key->d_bitlen = (vlen - 1) * 8 + loop;\n\n\tmemcpy(rsa_key->d + (rsa_key->key_sz - vlen), ptr, vlen);\n\n\treturn 0;\n err:\n\trsa_key->d = NULL;\n\treturn ret;\n}\n\nstatic int starfive_rsa_setkey(struct crypto_akcipher *tfm, const void *key,\n\t\t\t       unsigned int keylen, bool private)\n{\n\tstruct starfive_cryp_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct rsa_key raw_key = {NULL};\n\tstruct starfive_rsa_key *rsa_key = &ctx->rsa_key;\n\tint ret;\n\n\tif (private)\n\t\tret = rsa_parse_priv_key(&raw_key, key, keylen);\n\telse\n\t\tret = rsa_parse_pub_key(&raw_key, key, keylen);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tstarfive_rsa_free_key(rsa_key);\n\n\t \n\tif (raw_key.n_sz > STARFIVE_RSA_MAX_KEYSZ + 1)\n\t\treturn 0;\n\n\tret = starfive_rsa_set_n(rsa_key, raw_key.n, raw_key.n_sz);\n\tif (ret)\n\t\treturn ret;\n\n\tret = starfive_rsa_set_e(rsa_key, raw_key.e, raw_key.e_sz);\n\tif (ret)\n\t\tgoto err;\n\n\tif (private) {\n\t\tret = starfive_rsa_set_d(rsa_key, raw_key.d, raw_key.d_sz);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (!rsa_key->n || !rsa_key->e) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (private && !rsa_key->d) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\treturn 0;\n err:\n\tstarfive_rsa_free_key(rsa_key);\n\treturn ret;\n}\n\nstatic int starfive_rsa_set_pub_key(struct crypto_akcipher *tfm, const void *key,\n\t\t\t\t    unsigned int keylen)\n{\n\tstruct starfive_cryp_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tint ret;\n\n\tret = crypto_akcipher_set_pub_key(ctx->akcipher_fbk, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\treturn starfive_rsa_setkey(tfm, key, keylen, false);\n}\n\nstatic int starfive_rsa_set_priv_key(struct crypto_akcipher *tfm, const void *key,\n\t\t\t\t     unsigned int keylen)\n{\n\tstruct starfive_cryp_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tint ret;\n\n\tret = crypto_akcipher_set_priv_key(ctx->akcipher_fbk, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\treturn starfive_rsa_setkey(tfm, key, keylen, true);\n}\n\nstatic unsigned int starfive_rsa_max_size(struct crypto_akcipher *tfm)\n{\n\tstruct starfive_cryp_ctx *ctx = akcipher_tfm_ctx(tfm);\n\n\tif (ctx->rsa_key.key_sz)\n\t\treturn ctx->rsa_key.key_sz;\n\n\treturn crypto_akcipher_maxsize(ctx->akcipher_fbk);\n}\n\nstatic int starfive_rsa_init_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct starfive_cryp_ctx *ctx = akcipher_tfm_ctx(tfm);\n\n\tctx->akcipher_fbk = crypto_alloc_akcipher(\"rsa-generic\", 0, 0);\n\tif (IS_ERR(ctx->akcipher_fbk))\n\t\treturn PTR_ERR(ctx->akcipher_fbk);\n\n\tctx->cryp = starfive_cryp_find_dev(ctx);\n\tif (!ctx->cryp) {\n\t\tcrypto_free_akcipher(ctx->akcipher_fbk);\n\t\treturn -ENODEV;\n\t}\n\n\takcipher_set_reqsize(tfm, sizeof(struct starfive_cryp_request_ctx) +\n\t\t\t     sizeof(struct crypto_akcipher) + 32);\n\n\treturn 0;\n}\n\nstatic void starfive_rsa_exit_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct starfive_cryp_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct starfive_rsa_key *key = (struct starfive_rsa_key *)&ctx->rsa_key;\n\n\tcrypto_free_akcipher(ctx->akcipher_fbk);\n\tstarfive_rsa_free_key(key);\n}\n\nstatic struct akcipher_alg starfive_rsa = {\n\t.encrypt = starfive_rsa_enc,\n\t.decrypt = starfive_rsa_dec,\n\t.sign = starfive_rsa_dec,\n\t.verify = starfive_rsa_enc,\n\t.set_pub_key = starfive_rsa_set_pub_key,\n\t.set_priv_key = starfive_rsa_set_priv_key,\n\t.max_size = starfive_rsa_max_size,\n\t.init = starfive_rsa_init_tfm,\n\t.exit = starfive_rsa_exit_tfm,\n\t.base = {\n\t\t.cra_name = \"rsa\",\n\t\t.cra_driver_name = \"starfive-rsa\",\n\t\t.cra_flags = CRYPTO_ALG_TYPE_AKCIPHER |\n\t\t\t     CRYPTO_ALG_NEED_FALLBACK,\n\t\t.cra_priority = 3000,\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_ctxsize = sizeof(struct starfive_cryp_ctx),\n\t},\n};\n\nint starfive_rsa_register_algs(void)\n{\n\treturn crypto_register_akcipher(&starfive_rsa);\n}\n\nvoid starfive_rsa_unregister_algs(void)\n{\n\tcrypto_unregister_akcipher(&starfive_rsa);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}