{
  "module_name": "jh7110-aes.c",
  "hash_id": "da57ad9a35c85d73ae8c31c4f8d22c2238ee61c454092496582c32e9dfb90815",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/starfive/jh7110-aes.c",
  "human_readable_source": "\n \n\n#include <crypto/engine.h>\n#include <crypto/gcm.h>\n#include <crypto/internal/aead.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include \"jh7110-cryp.h\"\n#include <linux/err.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#define STARFIVE_AES_REGS_OFFSET\t0x100\n#define STARFIVE_AES_AESDIO0R\t\t(STARFIVE_AES_REGS_OFFSET + 0x0)\n#define STARFIVE_AES_KEY0\t\t(STARFIVE_AES_REGS_OFFSET + 0x4)\n#define STARFIVE_AES_KEY1\t\t(STARFIVE_AES_REGS_OFFSET + 0x8)\n#define STARFIVE_AES_KEY2\t\t(STARFIVE_AES_REGS_OFFSET + 0xC)\n#define STARFIVE_AES_KEY3\t\t(STARFIVE_AES_REGS_OFFSET + 0x10)\n#define STARFIVE_AES_KEY4\t\t(STARFIVE_AES_REGS_OFFSET + 0x14)\n#define STARFIVE_AES_KEY5\t\t(STARFIVE_AES_REGS_OFFSET + 0x18)\n#define STARFIVE_AES_KEY6\t\t(STARFIVE_AES_REGS_OFFSET + 0x1C)\n#define STARFIVE_AES_KEY7\t\t(STARFIVE_AES_REGS_OFFSET + 0x20)\n#define STARFIVE_AES_CSR\t\t(STARFIVE_AES_REGS_OFFSET + 0x24)\n#define STARFIVE_AES_IV0\t\t(STARFIVE_AES_REGS_OFFSET + 0x28)\n#define STARFIVE_AES_IV1\t\t(STARFIVE_AES_REGS_OFFSET + 0x2C)\n#define STARFIVE_AES_IV2\t\t(STARFIVE_AES_REGS_OFFSET + 0x30)\n#define STARFIVE_AES_IV3\t\t(STARFIVE_AES_REGS_OFFSET + 0x34)\n#define STARFIVE_AES_NONCE0\t\t(STARFIVE_AES_REGS_OFFSET + 0x3C)\n#define STARFIVE_AES_NONCE1\t\t(STARFIVE_AES_REGS_OFFSET + 0x40)\n#define STARFIVE_AES_NONCE2\t\t(STARFIVE_AES_REGS_OFFSET + 0x44)\n#define STARFIVE_AES_NONCE3\t\t(STARFIVE_AES_REGS_OFFSET + 0x48)\n#define STARFIVE_AES_ALEN0\t\t(STARFIVE_AES_REGS_OFFSET + 0x4C)\n#define STARFIVE_AES_ALEN1\t\t(STARFIVE_AES_REGS_OFFSET + 0x50)\n#define STARFIVE_AES_MLEN0\t\t(STARFIVE_AES_REGS_OFFSET + 0x54)\n#define STARFIVE_AES_MLEN1\t\t(STARFIVE_AES_REGS_OFFSET + 0x58)\n#define STARFIVE_AES_IVLEN\t\t(STARFIVE_AES_REGS_OFFSET + 0x5C)\n\n#define FLG_MODE_MASK\t\t\tGENMASK(2, 0)\n#define FLG_ENCRYPT\t\t\tBIT(4)\n\n \n#define CCM_B0_ADATA\t\t\t0x40\n#define AES_BLOCK_32\t\t\t(AES_BLOCK_SIZE / sizeof(u32))\n\nstatic inline int starfive_aes_wait_busy(struct starfive_cryp_dev *cryp)\n{\n\tu32 status;\n\n\treturn readl_relaxed_poll_timeout(cryp->base + STARFIVE_AES_CSR, status,\n\t\t\t\t\t  !(status & STARFIVE_AES_BUSY), 10, 100000);\n}\n\nstatic inline int starfive_aes_wait_keydone(struct starfive_cryp_dev *cryp)\n{\n\tu32 status;\n\n\treturn readl_relaxed_poll_timeout(cryp->base + STARFIVE_AES_CSR, status,\n\t\t\t\t\t  (status & STARFIVE_AES_KEY_DONE), 10, 100000);\n}\n\nstatic inline int starfive_aes_wait_gcmdone(struct starfive_cryp_dev *cryp)\n{\n\tu32 status;\n\n\treturn readl_relaxed_poll_timeout(cryp->base + STARFIVE_AES_CSR, status,\n\t\t\t\t\t  (status & STARFIVE_AES_GCM_DONE), 10, 100000);\n}\n\nstatic inline int is_gcm(struct starfive_cryp_dev *cryp)\n{\n\treturn (cryp->flags & FLG_MODE_MASK) == STARFIVE_AES_MODE_GCM;\n}\n\nstatic inline int is_encrypt(struct starfive_cryp_dev *cryp)\n{\n\treturn cryp->flags & FLG_ENCRYPT;\n}\n\nstatic void starfive_aes_aead_hw_start(struct starfive_cryp_ctx *ctx, u32 hw_mode)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tunsigned int value;\n\n\tswitch (hw_mode) {\n\tcase STARFIVE_AES_MODE_GCM:\n\t\tvalue = readl(ctx->cryp->base + STARFIVE_AES_CSR);\n\t\tvalue |= STARFIVE_AES_GCM_START;\n\t\twritel(value, cryp->base + STARFIVE_AES_CSR);\n\t\tstarfive_aes_wait_gcmdone(cryp);\n\t\tbreak;\n\tcase STARFIVE_AES_MODE_CCM:\n\t\tvalue = readl(ctx->cryp->base + STARFIVE_AES_CSR);\n\t\tvalue |= STARFIVE_AES_CCM_START;\n\t\twritel(value, cryp->base + STARFIVE_AES_CSR);\n\t\tbreak;\n\t}\n}\n\nstatic inline void starfive_aes_set_ivlen(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\n\tif (is_gcm(cryp))\n\t\twritel(GCM_AES_IV_SIZE, cryp->base + STARFIVE_AES_IVLEN);\n\telse\n\t\twritel(AES_BLOCK_SIZE, cryp->base + STARFIVE_AES_IVLEN);\n}\n\nstatic inline void starfive_aes_set_alen(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\n\twritel(upper_32_bits(cryp->assoclen), cryp->base + STARFIVE_AES_ALEN0);\n\twritel(lower_32_bits(cryp->assoclen), cryp->base + STARFIVE_AES_ALEN1);\n}\n\nstatic inline void starfive_aes_set_mlen(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\n\twritel(upper_32_bits(cryp->total_in), cryp->base + STARFIVE_AES_MLEN0);\n\twritel(lower_32_bits(cryp->total_in), cryp->base + STARFIVE_AES_MLEN1);\n}\n\nstatic inline int starfive_aes_ccm_check_iv(const u8 *iv)\n{\n\t \n\tif (iv[0] < 1 || iv[0] > 7)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int starfive_aes_write_iv(struct starfive_cryp_ctx *ctx, u32 *iv)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\n\twritel(iv[0], cryp->base + STARFIVE_AES_IV0);\n\twritel(iv[1], cryp->base + STARFIVE_AES_IV1);\n\twritel(iv[2], cryp->base + STARFIVE_AES_IV2);\n\n\tif (is_gcm(cryp)) {\n\t\tif (starfive_aes_wait_gcmdone(cryp))\n\t\t\treturn -ETIMEDOUT;\n\n\t\treturn 0;\n\t}\n\n\twritel(iv[3], cryp->base + STARFIVE_AES_IV3);\n\n\treturn 0;\n}\n\nstatic inline void starfive_aes_get_iv(struct starfive_cryp_dev *cryp, u32 *iv)\n{\n\tiv[0] = readl(cryp->base + STARFIVE_AES_IV0);\n\tiv[1] = readl(cryp->base + STARFIVE_AES_IV1);\n\tiv[2] = readl(cryp->base + STARFIVE_AES_IV2);\n\tiv[3] = readl(cryp->base + STARFIVE_AES_IV3);\n}\n\nstatic inline void starfive_aes_write_nonce(struct starfive_cryp_ctx *ctx, u32 *nonce)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\n\twritel(nonce[0], cryp->base + STARFIVE_AES_NONCE0);\n\twritel(nonce[1], cryp->base + STARFIVE_AES_NONCE1);\n\twritel(nonce[2], cryp->base + STARFIVE_AES_NONCE2);\n\twritel(nonce[3], cryp->base + STARFIVE_AES_NONCE3);\n}\n\nstatic int starfive_aes_write_key(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tu32 *key = (u32 *)ctx->key;\n\n\tif (ctx->keylen >= AES_KEYSIZE_128) {\n\t\twritel(key[0], cryp->base + STARFIVE_AES_KEY0);\n\t\twritel(key[1], cryp->base + STARFIVE_AES_KEY1);\n\t\twritel(key[2], cryp->base + STARFIVE_AES_KEY2);\n\t\twritel(key[3], cryp->base + STARFIVE_AES_KEY3);\n\t}\n\n\tif (ctx->keylen >= AES_KEYSIZE_192) {\n\t\twritel(key[4], cryp->base + STARFIVE_AES_KEY4);\n\t\twritel(key[5], cryp->base + STARFIVE_AES_KEY5);\n\t}\n\n\tif (ctx->keylen >= AES_KEYSIZE_256) {\n\t\twritel(key[6], cryp->base + STARFIVE_AES_KEY6);\n\t\twritel(key[7], cryp->base + STARFIVE_AES_KEY7);\n\t}\n\n\tif (starfive_aes_wait_keydone(cryp))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int starfive_aes_ccm_init(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tu8 iv[AES_BLOCK_SIZE], b0[AES_BLOCK_SIZE];\n\tunsigned int textlen;\n\n\tmemcpy(iv, cryp->req.areq->iv, AES_BLOCK_SIZE);\n\tmemset(iv + AES_BLOCK_SIZE - 1 - iv[0], 0, iv[0] + 1);\n\n\t \n\tmemcpy(b0, iv, AES_BLOCK_SIZE);\n\n\tb0[0] |= (8 * ((cryp->authsize - 2) / 2));\n\n\tif (cryp->assoclen)\n\t\tb0[0] |= CCM_B0_ADATA;\n\n\ttextlen = cryp->total_in;\n\n\tb0[AES_BLOCK_SIZE - 2] = textlen >> 8;\n\tb0[AES_BLOCK_SIZE - 1] = textlen & 0xFF;\n\n\tstarfive_aes_write_nonce(ctx, (u32 *)b0);\n\n\treturn 0;\n}\n\nstatic int starfive_aes_hw_init(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_request_ctx *rctx = ctx->rctx;\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tu32 hw_mode;\n\n\t \n\trctx->csr.aes.v = 0;\n\trctx->csr.aes.aesrst = 1;\n\twritel(rctx->csr.aes.v, cryp->base + STARFIVE_AES_CSR);\n\n\t \n\thw_mode = cryp->flags & FLG_MODE_MASK;\n\n\trctx->csr.aes.v = 0;\n\n\tswitch (ctx->keylen) {\n\tcase AES_KEYSIZE_128:\n\t\trctx->csr.aes.keymode = STARFIVE_AES_KEYMODE_128;\n\t\tbreak;\n\tcase AES_KEYSIZE_192:\n\t\trctx->csr.aes.keymode = STARFIVE_AES_KEYMODE_192;\n\t\tbreak;\n\tcase AES_KEYSIZE_256:\n\t\trctx->csr.aes.keymode = STARFIVE_AES_KEYMODE_256;\n\t\tbreak;\n\t}\n\n\trctx->csr.aes.mode  = hw_mode;\n\trctx->csr.aes.cmode = !is_encrypt(cryp);\n\trctx->csr.aes.ie = 1;\n\n\tif (hw_mode == STARFIVE_AES_MODE_CFB ||\n\t    hw_mode == STARFIVE_AES_MODE_OFB)\n\t\trctx->csr.aes.stmode = STARFIVE_AES_MODE_XFB_128;\n\telse\n\t\trctx->csr.aes.stmode = STARFIVE_AES_MODE_XFB_1;\n\n\tif (cryp->side_chan) {\n\t\trctx->csr.aes.delay_aes = 1;\n\t\trctx->csr.aes.vaes_start = 1;\n\t}\n\n\twritel(rctx->csr.aes.v, cryp->base + STARFIVE_AES_CSR);\n\n\tcryp->err = starfive_aes_write_key(ctx);\n\tif (cryp->err)\n\t\treturn cryp->err;\n\n\tswitch (hw_mode) {\n\tcase STARFIVE_AES_MODE_GCM:\n\t\tstarfive_aes_set_alen(ctx);\n\t\tstarfive_aes_set_mlen(ctx);\n\t\tstarfive_aes_set_ivlen(ctx);\n\t\tstarfive_aes_aead_hw_start(ctx, hw_mode);\n\t\tstarfive_aes_write_iv(ctx, (void *)cryp->req.areq->iv);\n\t\tbreak;\n\tcase STARFIVE_AES_MODE_CCM:\n\t\tstarfive_aes_set_alen(ctx);\n\t\tstarfive_aes_set_mlen(ctx);\n\t\tstarfive_aes_ccm_init(ctx);\n\t\tstarfive_aes_aead_hw_start(ctx, hw_mode);\n\t\tbreak;\n\tcase STARFIVE_AES_MODE_OFB:\n\tcase STARFIVE_AES_MODE_CFB:\n\tcase STARFIVE_AES_MODE_CBC:\n\tcase STARFIVE_AES_MODE_CTR:\n\t\tstarfive_aes_write_iv(ctx, (void *)cryp->req.sreq->iv);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn cryp->err;\n}\n\nstatic int starfive_aes_read_authtag(struct starfive_cryp_dev *cryp)\n{\n\tint i, start_addr;\n\n\tif (starfive_aes_wait_busy(cryp))\n\t\treturn dev_err_probe(cryp->dev, -ETIMEDOUT,\n\t\t\t\t     \"Timeout waiting for tag generation.\");\n\n\tstart_addr = STARFIVE_AES_NONCE0;\n\n\tif (is_gcm(cryp))\n\t\tfor (i = 0; i < AES_BLOCK_32; i++, start_addr += 4)\n\t\t\tcryp->tag_out[i] = readl(cryp->base + start_addr);\n\telse\n\t\tfor (i = 0; i < AES_BLOCK_32; i++)\n\t\t\tcryp->tag_out[i] = readl(cryp->base + STARFIVE_AES_AESDIO0R);\n\n\tif (is_encrypt(cryp)) {\n\t\tscatterwalk_copychunks(cryp->tag_out, &cryp->out_walk, cryp->authsize, 1);\n\t} else {\n\t\tscatterwalk_copychunks(cryp->tag_in, &cryp->in_walk, cryp->authsize, 0);\n\n\t\tif (crypto_memneq(cryp->tag_in, cryp->tag_out, cryp->authsize))\n\t\t\treturn dev_err_probe(cryp->dev, -EBADMSG, \"Failed tag verification\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void starfive_aes_finish_req(struct starfive_cryp_dev *cryp)\n{\n\tunion starfive_aes_csr csr;\n\tint err = cryp->err;\n\n\tif (!err && cryp->authsize)\n\t\terr = starfive_aes_read_authtag(cryp);\n\n\tif (!err && ((cryp->flags & FLG_MODE_MASK) == STARFIVE_AES_MODE_CBC ||\n\t\t     (cryp->flags & FLG_MODE_MASK) == STARFIVE_AES_MODE_CTR))\n\t\tstarfive_aes_get_iv(cryp, (void *)cryp->req.sreq->iv);\n\n\t \n\tcsr.v = 0;\n\tcsr.aesrst = 1;\n\twritel(csr.v, cryp->base + STARFIVE_AES_CSR);\n\n\tif (cryp->authsize)\n\t\tcrypto_finalize_aead_request(cryp->engine, cryp->req.areq, err);\n\telse\n\t\tcrypto_finalize_skcipher_request(cryp->engine, cryp->req.sreq,\n\t\t\t\t\t\t err);\n}\n\nvoid starfive_aes_done_task(unsigned long param)\n{\n\tstruct starfive_cryp_dev *cryp = (struct starfive_cryp_dev *)param;\n\tu32 block[AES_BLOCK_32];\n\tu32 stat;\n\tint i;\n\n\tfor (i = 0; i < AES_BLOCK_32; i++)\n\t\tblock[i] = readl(cryp->base + STARFIVE_AES_AESDIO0R);\n\n\tscatterwalk_copychunks(block, &cryp->out_walk, min_t(size_t, AES_BLOCK_SIZE,\n\t\t\t\t\t\t\t     cryp->total_out), 1);\n\n\tcryp->total_out -= min_t(size_t, AES_BLOCK_SIZE, cryp->total_out);\n\n\tif (!cryp->total_out) {\n\t\tstarfive_aes_finish_req(cryp);\n\t\treturn;\n\t}\n\n\tmemset(block, 0, AES_BLOCK_SIZE);\n\tscatterwalk_copychunks(block, &cryp->in_walk, min_t(size_t, AES_BLOCK_SIZE,\n\t\t\t\t\t\t\t    cryp->total_in), 0);\n\tcryp->total_in -= min_t(size_t, AES_BLOCK_SIZE, cryp->total_in);\n\n\tfor (i = 0; i < AES_BLOCK_32; i++)\n\t\twritel(block[i], cryp->base + STARFIVE_AES_AESDIO0R);\n\n\tstat = readl(cryp->base + STARFIVE_IE_MASK_OFFSET);\n\tstat &= ~STARFIVE_IE_MASK_AES_DONE;\n\twritel(stat, cryp->base + STARFIVE_IE_MASK_OFFSET);\n}\n\nstatic int starfive_aes_gcm_write_adata(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tstruct starfive_cryp_request_ctx *rctx = ctx->rctx;\n\tu32 *buffer;\n\tint total_len, loop;\n\n\ttotal_len = ALIGN(cryp->assoclen, AES_BLOCK_SIZE) / sizeof(unsigned int);\n\tbuffer = (u32 *)rctx->adata;\n\n\tfor (loop = 0; loop < total_len; loop += 4) {\n\t\twritel(*buffer, cryp->base + STARFIVE_AES_NONCE0);\n\t\tbuffer++;\n\t\twritel(*buffer, cryp->base + STARFIVE_AES_NONCE1);\n\t\tbuffer++;\n\t\twritel(*buffer, cryp->base + STARFIVE_AES_NONCE2);\n\t\tbuffer++;\n\t\twritel(*buffer, cryp->base + STARFIVE_AES_NONCE3);\n\t\tbuffer++;\n\t}\n\n\tif (starfive_aes_wait_gcmdone(cryp))\n\t\treturn dev_err_probe(cryp->dev, -ETIMEDOUT,\n\t\t\t\t     \"Timeout processing gcm aad block\");\n\n\treturn 0;\n}\n\nstatic int starfive_aes_ccm_write_adata(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tstruct starfive_cryp_request_ctx *rctx = ctx->rctx;\n\tu32 *buffer;\n\tu8 *ci;\n\tint total_len, loop;\n\n\ttotal_len = cryp->assoclen;\n\n\tci = rctx->adata;\n\twriteb(*ci, cryp->base + STARFIVE_AES_AESDIO0R);\n\tci++;\n\twriteb(*ci, cryp->base + STARFIVE_AES_AESDIO0R);\n\tci++;\n\ttotal_len -= 2;\n\tbuffer = (u32 *)ci;\n\n\tfor (loop = 0; loop < 3; loop++, buffer++)\n\t\twritel(*buffer, cryp->base + STARFIVE_AES_AESDIO0R);\n\n\ttotal_len -= 12;\n\n\twhile (total_len > 0) {\n\t\tfor (loop = 0; loop < AES_BLOCK_32; loop++, buffer++)\n\t\t\twritel(*buffer, cryp->base + STARFIVE_AES_AESDIO0R);\n\n\t\ttotal_len -= AES_BLOCK_SIZE;\n\t}\n\n\tif (starfive_aes_wait_busy(cryp))\n\t\treturn dev_err_probe(cryp->dev, -ETIMEDOUT,\n\t\t\t\t     \"Timeout processing ccm aad block\");\n\n\treturn 0;\n}\n\nstatic int starfive_aes_prepare_req(struct skcipher_request *req,\n\t\t\t\t    struct aead_request *areq)\n{\n\tstruct starfive_cryp_ctx *ctx;\n\tstruct starfive_cryp_request_ctx *rctx;\n\tstruct starfive_cryp_dev *cryp;\n\n\tif (!req && !areq)\n\t\treturn -EINVAL;\n\n\tctx = req ? crypto_skcipher_ctx(crypto_skcipher_reqtfm(req)) :\n\t\t    crypto_aead_ctx(crypto_aead_reqtfm(areq));\n\n\tcryp = ctx->cryp;\n\trctx = req ? skcipher_request_ctx(req) : aead_request_ctx(areq);\n\n\tif (req) {\n\t\tcryp->req.sreq = req;\n\t\tcryp->total_in = req->cryptlen;\n\t\tcryp->total_out = req->cryptlen;\n\t\tcryp->assoclen = 0;\n\t\tcryp->authsize = 0;\n\t} else {\n\t\tcryp->req.areq = areq;\n\t\tcryp->assoclen = areq->assoclen;\n\t\tcryp->authsize = crypto_aead_authsize(crypto_aead_reqtfm(areq));\n\t\tif (is_encrypt(cryp)) {\n\t\t\tcryp->total_in = areq->cryptlen;\n\t\t\tcryp->total_out = areq->cryptlen;\n\t\t} else {\n\t\t\tcryp->total_in = areq->cryptlen - cryp->authsize;\n\t\t\tcryp->total_out = cryp->total_in;\n\t\t}\n\t}\n\n\trctx->in_sg = req ? req->src : areq->src;\n\tscatterwalk_start(&cryp->in_walk, rctx->in_sg);\n\n\trctx->out_sg = req ? req->dst : areq->dst;\n\tscatterwalk_start(&cryp->out_walk, rctx->out_sg);\n\n\tif (cryp->assoclen) {\n\t\trctx->adata = kzalloc(ALIGN(cryp->assoclen, AES_BLOCK_SIZE), GFP_KERNEL);\n\t\tif (!rctx->adata)\n\t\t\treturn dev_err_probe(cryp->dev, -ENOMEM,\n\t\t\t\t\t     \"Failed to alloc memory for adata\");\n\n\t\tscatterwalk_copychunks(rctx->adata, &cryp->in_walk, cryp->assoclen, 0);\n\t\tscatterwalk_copychunks(NULL, &cryp->out_walk, cryp->assoclen, 2);\n\t}\n\n\tctx->rctx = rctx;\n\n\treturn starfive_aes_hw_init(ctx);\n}\n\nstatic int starfive_aes_do_one_req(struct crypto_engine *engine, void *areq)\n{\n\tstruct skcipher_request *req =\n\t\tcontainer_of(areq, struct skcipher_request, base);\n\tstruct starfive_cryp_ctx *ctx =\n\t\tcrypto_skcipher_ctx(crypto_skcipher_reqtfm(req));\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tu32 block[AES_BLOCK_32];\n\tu32 stat;\n\tint err;\n\tint i;\n\n\terr = starfive_aes_prepare_req(req, NULL);\n\tif (err)\n\t\treturn err;\n\n\t \n\tscatterwalk_copychunks(block, &cryp->in_walk, min_t(size_t, AES_BLOCK_SIZE,\n\t\t\t\t\t\t\t    cryp->total_in), 0);\n\tcryp->total_in -= min_t(size_t, AES_BLOCK_SIZE, cryp->total_in);\n\n\tfor (i = 0; i < AES_BLOCK_32; i++)\n\t\twritel(block[i], cryp->base + STARFIVE_AES_AESDIO0R);\n\n\tstat = readl(cryp->base + STARFIVE_IE_MASK_OFFSET);\n\tstat &= ~STARFIVE_IE_MASK_AES_DONE;\n\twritel(stat, cryp->base + STARFIVE_IE_MASK_OFFSET);\n\n\treturn 0;\n}\n\nstatic int starfive_aes_init_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\tctx->cryp = starfive_cryp_find_dev(ctx);\n\tif (!ctx->cryp)\n\t\treturn -ENODEV;\n\n\tcrypto_skcipher_set_reqsize(tfm, sizeof(struct starfive_cryp_request_ctx) +\n\t\t\t\t    sizeof(struct skcipher_request));\n\n\treturn 0;\n}\n\nstatic int starfive_aes_aead_do_one_req(struct crypto_engine *engine, void *areq)\n{\n\tstruct aead_request *req =\n\t\tcontainer_of(areq, struct aead_request, base);\n\tstruct starfive_cryp_ctx *ctx =\n\t\tcrypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tstruct starfive_cryp_request_ctx *rctx = ctx->rctx;\n\tu32 block[AES_BLOCK_32];\n\tu32 stat;\n\tint err;\n\tint i;\n\n\terr = starfive_aes_prepare_req(NULL, req);\n\tif (err)\n\t\treturn err;\n\n\tif (!cryp->assoclen)\n\t\tgoto write_text;\n\n\tif ((cryp->flags & FLG_MODE_MASK) == STARFIVE_AES_MODE_CCM)\n\t\tcryp->err = starfive_aes_ccm_write_adata(ctx);\n\telse\n\t\tcryp->err = starfive_aes_gcm_write_adata(ctx);\n\n\tkfree(rctx->adata);\n\n\tif (cryp->err)\n\t\treturn cryp->err;\n\nwrite_text:\n\tif (!cryp->total_in)\n\t\tgoto finish_req;\n\n\t \n\tscatterwalk_copychunks(block, &cryp->in_walk, min_t(size_t, AES_BLOCK_SIZE,\n\t\t\t\t\t\t\t    cryp->total_in), 0);\n\tcryp->total_in -= min_t(size_t, AES_BLOCK_SIZE, cryp->total_in);\n\n\tfor (i = 0; i < AES_BLOCK_32; i++)\n\t\twritel(block[i], cryp->base + STARFIVE_AES_AESDIO0R);\n\n\tstat = readl(cryp->base + STARFIVE_IE_MASK_OFFSET);\n\tstat &= ~STARFIVE_IE_MASK_AES_DONE;\n\twritel(stat, cryp->base + STARFIVE_IE_MASK_OFFSET);\n\n\treturn 0;\n\nfinish_req:\n\tstarfive_aes_finish_req(cryp);\n\treturn 0;\n}\n\nstatic int starfive_aes_aead_init_tfm(struct crypto_aead *tfm)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tstruct crypto_tfm *aead = crypto_aead_tfm(tfm);\n\tstruct crypto_alg *alg = aead->__crt_alg;\n\n\tctx->cryp = starfive_cryp_find_dev(ctx);\n\tif (!ctx->cryp)\n\t\treturn -ENODEV;\n\n\tif (alg->cra_flags & CRYPTO_ALG_NEED_FALLBACK) {\n\t\tctx->aead_fbk = crypto_alloc_aead(alg->cra_name, 0,\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK);\n\t\tif (IS_ERR(ctx->aead_fbk))\n\t\t\treturn dev_err_probe(cryp->dev, PTR_ERR(ctx->aead_fbk),\n\t\t\t\t\t     \"%s() failed to allocate fallback for %s\\n\",\n\t\t\t\t\t     __func__, alg->cra_name);\n\t}\n\n\tcrypto_aead_set_reqsize(tfm, sizeof(struct starfive_cryp_ctx) +\n\t\t\t\tsizeof(struct aead_request));\n\n\treturn 0;\n}\n\nstatic void starfive_aes_aead_exit_tfm(struct crypto_aead *tfm)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tcrypto_free_aead(ctx->aead_fbk);\n}\n\nstatic int starfive_aes_crypt(struct skcipher_request *req, unsigned long flags)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct starfive_cryp_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tunsigned int blocksize_align = crypto_skcipher_blocksize(tfm) - 1;\n\n\tcryp->flags = flags;\n\n\tif ((cryp->flags & FLG_MODE_MASK) == STARFIVE_AES_MODE_ECB ||\n\t    (cryp->flags & FLG_MODE_MASK) == STARFIVE_AES_MODE_CBC)\n\t\tif (req->cryptlen & blocksize_align)\n\t\t\treturn -EINVAL;\n\n\treturn crypto_transfer_skcipher_request_to_engine(cryp->engine, req);\n}\n\nstatic int starfive_aes_aead_crypt(struct aead_request *req, unsigned long flags)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\n\tcryp->flags = flags;\n\n\t \n\tif (ctx->aead_fbk && !is_encrypt(cryp)) {\n\t\tstruct aead_request *subreq = aead_request_ctx(req);\n\n\t\taead_request_set_tfm(subreq, ctx->aead_fbk);\n\t\taead_request_set_callback(subreq, req->base.flags,\n\t\t\t\t\t  req->base.complete, req->base.data);\n\t\taead_request_set_crypt(subreq, req->src,\n\t\t\t\t       req->dst, req->cryptlen, req->iv);\n\t\taead_request_set_ad(subreq, req->assoclen);\n\n\t\treturn crypto_aead_decrypt(subreq);\n\t}\n\n\treturn crypto_transfer_aead_request_to_engine(cryp->engine, req);\n}\n\nstatic int starfive_aes_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t       unsigned int keylen)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\tif (!key || !keylen)\n\t\treturn -EINVAL;\n\n\tif (keylen != AES_KEYSIZE_128 &&\n\t    keylen != AES_KEYSIZE_192 &&\n\t    keylen != AES_KEYSIZE_256)\n\t\treturn -EINVAL;\n\n\tmemcpy(ctx->key, key, keylen);\n\tctx->keylen = keylen;\n\n\treturn 0;\n}\n\nstatic int starfive_aes_aead_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t\t    unsigned int keylen)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tif (!key || !keylen)\n\t\treturn -EINVAL;\n\n\tif (keylen != AES_KEYSIZE_128 &&\n\t    keylen != AES_KEYSIZE_192 &&\n\t    keylen != AES_KEYSIZE_256)\n\t\treturn -EINVAL;\n\n\tmemcpy(ctx->key, key, keylen);\n\tctx->keylen = keylen;\n\n\tif (ctx->aead_fbk)\n\t\treturn crypto_aead_setkey(ctx->aead_fbk, key, keylen);\n\n\treturn 0;\n}\n\nstatic int starfive_aes_gcm_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t\tunsigned int authsize)\n{\n\treturn crypto_gcm_check_authsize(authsize);\n}\n\nstatic int starfive_aes_ccm_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t\tunsigned int authsize)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tswitch (authsize) {\n\tcase 4:\n\tcase 6:\n\tcase 8:\n\tcase 10:\n\tcase 12:\n\tcase 14:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn crypto_aead_setauthsize(ctx->aead_fbk, authsize);\n}\n\nstatic int starfive_aes_ecb_encrypt(struct skcipher_request *req)\n{\n\treturn starfive_aes_crypt(req, STARFIVE_AES_MODE_ECB | FLG_ENCRYPT);\n}\n\nstatic int starfive_aes_ecb_decrypt(struct skcipher_request *req)\n{\n\treturn starfive_aes_crypt(req, STARFIVE_AES_MODE_ECB);\n}\n\nstatic int starfive_aes_cbc_encrypt(struct skcipher_request *req)\n{\n\treturn starfive_aes_crypt(req, STARFIVE_AES_MODE_CBC | FLG_ENCRYPT);\n}\n\nstatic int starfive_aes_cbc_decrypt(struct skcipher_request *req)\n{\n\treturn starfive_aes_crypt(req, STARFIVE_AES_MODE_CBC);\n}\n\nstatic int starfive_aes_cfb_encrypt(struct skcipher_request *req)\n{\n\treturn starfive_aes_crypt(req, STARFIVE_AES_MODE_CFB | FLG_ENCRYPT);\n}\n\nstatic int starfive_aes_cfb_decrypt(struct skcipher_request *req)\n{\n\treturn starfive_aes_crypt(req, STARFIVE_AES_MODE_CFB);\n}\n\nstatic int starfive_aes_ofb_encrypt(struct skcipher_request *req)\n{\n\treturn starfive_aes_crypt(req, STARFIVE_AES_MODE_OFB | FLG_ENCRYPT);\n}\n\nstatic int starfive_aes_ofb_decrypt(struct skcipher_request *req)\n{\n\treturn starfive_aes_crypt(req, STARFIVE_AES_MODE_OFB);\n}\n\nstatic int starfive_aes_ctr_encrypt(struct skcipher_request *req)\n{\n\treturn starfive_aes_crypt(req, STARFIVE_AES_MODE_CTR | FLG_ENCRYPT);\n}\n\nstatic int starfive_aes_ctr_decrypt(struct skcipher_request *req)\n{\n\treturn starfive_aes_crypt(req, STARFIVE_AES_MODE_CTR);\n}\n\nstatic int starfive_aes_gcm_encrypt(struct aead_request *req)\n{\n\treturn starfive_aes_aead_crypt(req, STARFIVE_AES_MODE_GCM | FLG_ENCRYPT);\n}\n\nstatic int starfive_aes_gcm_decrypt(struct aead_request *req)\n{\n\treturn starfive_aes_aead_crypt(req, STARFIVE_AES_MODE_GCM);\n}\n\nstatic int starfive_aes_ccm_encrypt(struct aead_request *req)\n{\n\tint ret;\n\n\tret = starfive_aes_ccm_check_iv(req->iv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn starfive_aes_aead_crypt(req, STARFIVE_AES_MODE_CCM | FLG_ENCRYPT);\n}\n\nstatic int starfive_aes_ccm_decrypt(struct aead_request *req)\n{\n\tint ret;\n\n\tret = starfive_aes_ccm_check_iv(req->iv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn starfive_aes_aead_crypt(req, STARFIVE_AES_MODE_CCM);\n}\n\nstatic struct skcipher_engine_alg skcipher_algs[] = {\n{\n\t.base.init\t\t\t= starfive_aes_init_tfm,\n\t.base.setkey\t\t\t= starfive_aes_setkey,\n\t.base.encrypt\t\t\t= starfive_aes_ecb_encrypt,\n\t.base.decrypt\t\t\t= starfive_aes_ecb_decrypt,\n\t.base.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t.base.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t.base.base = {\n\t\t.cra_name\t\t= \"ecb(aes)\",\n\t\t.cra_driver_name\t= \"starfive-ecb-aes\",\n\t\t.cra_priority\t\t= 200,\n\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.cra_blocksize\t\t= AES_BLOCK_SIZE,\n\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t.cra_alignmask\t\t= 0xf,\n\t\t.cra_module\t\t= THIS_MODULE,\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_aes_do_one_req,\n\t},\n}, {\n\t.base.init\t\t\t= starfive_aes_init_tfm,\n\t.base.setkey\t\t\t= starfive_aes_setkey,\n\t.base.encrypt\t\t\t= starfive_aes_cbc_encrypt,\n\t.base.decrypt\t\t\t= starfive_aes_cbc_decrypt,\n\t.base.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t.base.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t.base.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t.base.base = {\n\t\t.cra_name\t\t= \"cbc(aes)\",\n\t\t.cra_driver_name\t= \"starfive-cbc-aes\",\n\t\t.cra_priority\t\t= 200,\n\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.cra_blocksize\t\t= AES_BLOCK_SIZE,\n\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t.cra_alignmask\t\t= 0xf,\n\t\t.cra_module\t\t= THIS_MODULE,\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_aes_do_one_req,\n\t},\n}, {\n\t.base.init\t\t\t= starfive_aes_init_tfm,\n\t.base.setkey\t\t\t= starfive_aes_setkey,\n\t.base.encrypt\t\t\t= starfive_aes_ctr_encrypt,\n\t.base.decrypt\t\t\t= starfive_aes_ctr_decrypt,\n\t.base.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t.base.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t.base.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t.base.base = {\n\t\t.cra_name\t\t= \"ctr(aes)\",\n\t\t.cra_driver_name\t= \"starfive-ctr-aes\",\n\t\t.cra_priority\t\t= 200,\n\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.cra_blocksize\t\t= 1,\n\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t.cra_alignmask\t\t= 0xf,\n\t\t.cra_module\t\t= THIS_MODULE,\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_aes_do_one_req,\n\t},\n}, {\n\t.base.init\t\t\t= starfive_aes_init_tfm,\n\t.base.setkey\t\t\t= starfive_aes_setkey,\n\t.base.encrypt\t\t\t= starfive_aes_cfb_encrypt,\n\t.base.decrypt\t\t\t= starfive_aes_cfb_decrypt,\n\t.base.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t.base.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t.base.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t.base.base = {\n\t\t.cra_name\t\t= \"cfb(aes)\",\n\t\t.cra_driver_name\t= \"starfive-cfb-aes\",\n\t\t.cra_priority\t\t= 200,\n\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.cra_blocksize\t\t= 1,\n\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t.cra_alignmask\t\t= 0xf,\n\t\t.cra_module\t\t= THIS_MODULE,\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_aes_do_one_req,\n\t},\n}, {\n\t.base.init\t\t\t= starfive_aes_init_tfm,\n\t.base.setkey\t\t\t= starfive_aes_setkey,\n\t.base.encrypt\t\t\t= starfive_aes_ofb_encrypt,\n\t.base.decrypt\t\t\t= starfive_aes_ofb_decrypt,\n\t.base.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t.base.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t.base.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t.base.base = {\n\t\t.cra_name\t\t= \"ofb(aes)\",\n\t\t.cra_driver_name\t= \"starfive-ofb-aes\",\n\t\t.cra_priority\t\t= 200,\n\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.cra_blocksize\t\t= 1,\n\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t.cra_alignmask\t\t= 0xf,\n\t\t.cra_module\t\t= THIS_MODULE,\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_aes_do_one_req,\n\t},\n},\n};\n\nstatic struct aead_engine_alg aead_algs[] = {\n{\n\t.base.setkey\t\t\t= starfive_aes_aead_setkey,\n\t.base.setauthsize\t\t= starfive_aes_gcm_setauthsize,\n\t.base.encrypt\t\t\t= starfive_aes_gcm_encrypt,\n\t.base.decrypt\t\t\t= starfive_aes_gcm_decrypt,\n\t.base.init\t\t\t= starfive_aes_aead_init_tfm,\n\t.base.exit\t\t\t= starfive_aes_aead_exit_tfm,\n\t.base.ivsize\t\t\t= GCM_AES_IV_SIZE,\n\t.base.maxauthsize\t\t= AES_BLOCK_SIZE,\n\t.base.base = {\n\t\t.cra_name               = \"gcm(aes)\",\n\t\t.cra_driver_name        = \"starfive-gcm-aes\",\n\t\t.cra_priority           = 200,\n\t\t.cra_flags              = CRYPTO_ALG_ASYNC,\n\t\t.cra_blocksize          = 1,\n\t\t.cra_ctxsize            = sizeof(struct starfive_cryp_ctx),\n\t\t.cra_alignmask          = 0xf,\n\t\t.cra_module             = THIS_MODULE,\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_aes_aead_do_one_req,\n\t},\n}, {\n\t.base.setkey\t\t\t= starfive_aes_aead_setkey,\n\t.base.setauthsize\t\t= starfive_aes_ccm_setauthsize,\n\t.base.encrypt\t\t\t= starfive_aes_ccm_encrypt,\n\t.base.decrypt\t\t\t= starfive_aes_ccm_decrypt,\n\t.base.init\t\t\t= starfive_aes_aead_init_tfm,\n\t.base.exit\t\t\t= starfive_aes_aead_exit_tfm,\n\t.base.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t.base.maxauthsize\t\t= AES_BLOCK_SIZE,\n\t.base.base = {\n\t\t.cra_name\t\t= \"ccm(aes)\",\n\t\t.cra_driver_name\t= \"starfive-ccm-aes\",\n\t\t.cra_priority\t\t= 200,\n\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t.cra_blocksize\t\t= 1,\n\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t.cra_alignmask\t\t= 0xf,\n\t\t.cra_module\t\t= THIS_MODULE,\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_aes_aead_do_one_req,\n\t},\n},\n};\n\nint starfive_aes_register_algs(void)\n{\n\tint ret;\n\n\tret = crypto_engine_register_skciphers(skcipher_algs, ARRAY_SIZE(skcipher_algs));\n\tif (ret)\n\t\treturn ret;\n\n\tret = crypto_engine_register_aeads(aead_algs, ARRAY_SIZE(aead_algs));\n\tif (ret)\n\t\tcrypto_engine_unregister_skciphers(skcipher_algs, ARRAY_SIZE(skcipher_algs));\n\n\treturn ret;\n}\n\nvoid starfive_aes_unregister_algs(void)\n{\n\tcrypto_engine_unregister_aeads(aead_algs, ARRAY_SIZE(aead_algs));\n\tcrypto_engine_unregister_skciphers(skcipher_algs, ARRAY_SIZE(skcipher_algs));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}