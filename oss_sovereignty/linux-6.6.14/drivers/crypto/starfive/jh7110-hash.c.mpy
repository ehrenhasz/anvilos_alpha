{
  "module_name": "jh7110-hash.c",
  "hash_id": "89ca5b7927f897488e1cf8d8c995dae3d70f5e05f3e02b96c280a9039b1005d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/starfive/jh7110-hash.c",
  "human_readable_source": "\n \n\n#include <crypto/engine.h>\n#include <crypto/internal/hash.h>\n#include <crypto/scatterwalk.h>\n#include \"jh7110-cryp.h\"\n#include <linux/amba/pl080.h>\n#include <linux/clk.h>\n#include <linux/dma-direct.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#define STARFIVE_HASH_REGS_OFFSET\t0x300\n#define STARFIVE_HASH_SHACSR\t\t(STARFIVE_HASH_REGS_OFFSET + 0x0)\n#define STARFIVE_HASH_SHAWDR\t\t(STARFIVE_HASH_REGS_OFFSET + 0x4)\n#define STARFIVE_HASH_SHARDR\t\t(STARFIVE_HASH_REGS_OFFSET + 0x8)\n#define STARFIVE_HASH_SHAWSR\t\t(STARFIVE_HASH_REGS_OFFSET + 0xC)\n#define STARFIVE_HASH_SHAWLEN3\t\t(STARFIVE_HASH_REGS_OFFSET + 0x10)\n#define STARFIVE_HASH_SHAWLEN2\t\t(STARFIVE_HASH_REGS_OFFSET + 0x14)\n#define STARFIVE_HASH_SHAWLEN1\t\t(STARFIVE_HASH_REGS_OFFSET + 0x18)\n#define STARFIVE_HASH_SHAWLEN0\t\t(STARFIVE_HASH_REGS_OFFSET + 0x1C)\n#define STARFIVE_HASH_SHAWKR\t\t(STARFIVE_HASH_REGS_OFFSET + 0x20)\n#define STARFIVE_HASH_SHAWKLEN\t\t(STARFIVE_HASH_REGS_OFFSET + 0x24)\n\n#define STARFIVE_HASH_BUFLEN\t\tSHA512_BLOCK_SIZE\n#define STARFIVE_HASH_RESET\t\t0x2\n\nstatic inline int starfive_hash_wait_busy(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tu32 status;\n\n\treturn readl_relaxed_poll_timeout(cryp->base + STARFIVE_HASH_SHACSR, status,\n\t\t\t\t\t  !(status & STARFIVE_HASH_BUSY), 10, 100000);\n}\n\nstatic inline int starfive_hash_wait_key_done(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tu32 status;\n\n\treturn readl_relaxed_poll_timeout(cryp->base + STARFIVE_HASH_SHACSR, status,\n\t\t\t\t\t  (status & STARFIVE_HASH_KEY_DONE), 10, 100000);\n}\n\nstatic int starfive_hash_hmac_key(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_request_ctx *rctx = ctx->rctx;\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tint klen = ctx->keylen, loop;\n\tunsigned int *key = (unsigned int *)ctx->key;\n\tunsigned char *cl;\n\n\twritel(ctx->keylen, cryp->base + STARFIVE_HASH_SHAWKLEN);\n\n\trctx->csr.hash.hmac = 1;\n\trctx->csr.hash.key_flag = 1;\n\n\twritel(rctx->csr.hash.v, cryp->base + STARFIVE_HASH_SHACSR);\n\n\tfor (loop = 0; loop < klen / sizeof(unsigned int); loop++, key++)\n\t\twritel(*key, cryp->base + STARFIVE_HASH_SHAWKR);\n\n\tif (klen & 0x3) {\n\t\tcl = (unsigned char *)key;\n\t\tfor (loop = 0; loop < (klen & 0x3); loop++, cl++)\n\t\t\twriteb(*cl, cryp->base + STARFIVE_HASH_SHAWKR);\n\t}\n\n\tif (starfive_hash_wait_key_done(ctx))\n\t\treturn dev_err_probe(cryp->dev, -ETIMEDOUT, \"starfive_hash_wait_key_done error\\n\");\n\n\treturn 0;\n}\n\nstatic void starfive_hash_start(void *param)\n{\n\tstruct starfive_cryp_ctx *ctx = param;\n\tstruct starfive_cryp_request_ctx *rctx = ctx->rctx;\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tunion starfive_alg_cr alg_cr;\n\tunion starfive_hash_csr csr;\n\tu32 stat;\n\n\tdma_unmap_sg(cryp->dev, rctx->in_sg, rctx->in_sg_len, DMA_TO_DEVICE);\n\n\talg_cr.v = 0;\n\talg_cr.clear = 1;\n\n\twritel(alg_cr.v, cryp->base + STARFIVE_ALG_CR_OFFSET);\n\n\tcsr.v = readl(cryp->base + STARFIVE_HASH_SHACSR);\n\tcsr.firstb = 0;\n\tcsr.final = 1;\n\n\tstat = readl(cryp->base + STARFIVE_IE_MASK_OFFSET);\n\tstat &= ~STARFIVE_IE_MASK_HASH_DONE;\n\twritel(stat, cryp->base + STARFIVE_IE_MASK_OFFSET);\n\twritel(csr.v, cryp->base + STARFIVE_HASH_SHACSR);\n}\n\nstatic int starfive_hash_xmit_dma(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_request_ctx *rctx = ctx->rctx;\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tstruct dma_async_tx_descriptor\t*in_desc;\n\tunion  starfive_alg_cr alg_cr;\n\tint total_len;\n\tint ret;\n\n\tif (!rctx->total) {\n\t\tstarfive_hash_start(ctx);\n\t\treturn 0;\n\t}\n\n\twritel(rctx->total, cryp->base + STARFIVE_DMA_IN_LEN_OFFSET);\n\n\ttotal_len = rctx->total;\n\ttotal_len = (total_len & 0x3) ? (((total_len >> 2) + 1) << 2) : total_len;\n\tsg_dma_len(rctx->in_sg) = total_len;\n\n\talg_cr.v = 0;\n\talg_cr.start = 1;\n\talg_cr.hash_dma_en = 1;\n\n\twritel(alg_cr.v, cryp->base + STARFIVE_ALG_CR_OFFSET);\n\n\tret = dma_map_sg(cryp->dev, rctx->in_sg, rctx->in_sg_len, DMA_TO_DEVICE);\n\tif (!ret)\n\t\treturn dev_err_probe(cryp->dev, -EINVAL, \"dma_map_sg() error\\n\");\n\n\tcryp->cfg_in.direction = DMA_MEM_TO_DEV;\n\tcryp->cfg_in.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tcryp->cfg_in.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tcryp->cfg_in.src_maxburst = cryp->dma_maxburst;\n\tcryp->cfg_in.dst_maxburst = cryp->dma_maxburst;\n\tcryp->cfg_in.dst_addr = cryp->phys_base + STARFIVE_ALG_FIFO_OFFSET;\n\n\tdmaengine_slave_config(cryp->tx, &cryp->cfg_in);\n\n\tin_desc = dmaengine_prep_slave_sg(cryp->tx, rctx->in_sg,\n\t\t\t\t\t  ret, DMA_MEM_TO_DEV,\n\t\t\t\t\t  DMA_PREP_INTERRUPT  |  DMA_CTRL_ACK);\n\n\tif (!in_desc)\n\t\treturn -EINVAL;\n\n\tin_desc->callback = starfive_hash_start;\n\tin_desc->callback_param = ctx;\n\n\tdmaengine_submit(in_desc);\n\tdma_async_issue_pending(cryp->tx);\n\n\treturn 0;\n}\n\nstatic int starfive_hash_xmit(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_request_ctx *rctx = ctx->rctx;\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\tint ret = 0;\n\n\trctx->csr.hash.v = 0;\n\trctx->csr.hash.reset = 1;\n\twritel(rctx->csr.hash.v, cryp->base + STARFIVE_HASH_SHACSR);\n\n\tif (starfive_hash_wait_busy(ctx))\n\t\treturn dev_err_probe(cryp->dev, -ETIMEDOUT, \"Error resetting engine.\\n\");\n\n\trctx->csr.hash.v = 0;\n\trctx->csr.hash.mode = ctx->hash_mode;\n\trctx->csr.hash.ie = 1;\n\n\tif (ctx->is_hmac) {\n\t\tret = starfive_hash_hmac_key(ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\trctx->csr.hash.start = 1;\n\t\trctx->csr.hash.firstb = 1;\n\t\twritel(rctx->csr.hash.v, cryp->base + STARFIVE_HASH_SHACSR);\n\t}\n\n\treturn starfive_hash_xmit_dma(ctx);\n}\n\nstatic int starfive_hash_copy_hash(struct ahash_request *req)\n{\n\tstruct starfive_cryp_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));\n\tint count, *data;\n\tint mlen;\n\n\tif (!req->result)\n\t\treturn 0;\n\n\tmlen = rctx->digsize / sizeof(u32);\n\tdata = (u32 *)req->result;\n\n\tfor (count = 0; count < mlen; count++)\n\t\tdata[count] = readl(ctx->cryp->base + STARFIVE_HASH_SHARDR);\n\n\treturn 0;\n}\n\nvoid starfive_hash_done_task(unsigned long param)\n{\n\tstruct starfive_cryp_dev *cryp = (struct starfive_cryp_dev *)param;\n\tint err = cryp->err;\n\n\tif (!err)\n\t\terr = starfive_hash_copy_hash(cryp->req.hreq);\n\n\t \n\twritel(STARFIVE_HASH_RESET, cryp->base + STARFIVE_HASH_SHACSR);\n\n\tcrypto_finalize_hash_request(cryp->engine, cryp->req.hreq, err);\n}\n\nstatic int starfive_hash_check_aligned(struct scatterlist *sg, size_t total, size_t align)\n{\n\tint len = 0;\n\n\tif (!total)\n\t\treturn 0;\n\n\tif (!IS_ALIGNED(total, align))\n\t\treturn -EINVAL;\n\n\twhile (sg) {\n\t\tif (!IS_ALIGNED(sg->offset, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\n\t\tif (!IS_ALIGNED(sg->length, align))\n\t\t\treturn -EINVAL;\n\n\t\tlen += sg->length;\n\t\tsg = sg_next(sg);\n\t}\n\n\tif (len != total)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int starfive_hash_one_request(struct crypto_engine *engine, void *areq)\n{\n\tstruct ahash_request *req = container_of(areq, struct ahash_request,\n\t\t\t\t\t\t base);\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\n\tif (!cryp)\n\t\treturn -ENODEV;\n\n\treturn starfive_hash_xmit(ctx);\n}\n\nstatic int starfive_hash_init(struct ahash_request *req)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct starfive_cryp_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->ahash_fbk_req, ctx->ahash_fbk);\n\tahash_request_set_callback(&rctx->ahash_fbk_req,\n\t\t\t\t   req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   req->base.complete, req->base.data);\n\n\tahash_request_set_crypt(&rctx->ahash_fbk_req, req->src,\n\t\t\t\treq->result, req->nbytes);\n\n\treturn crypto_ahash_init(&rctx->ahash_fbk_req);\n}\n\nstatic int starfive_hash_update(struct ahash_request *req)\n{\n\tstruct starfive_cryp_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->ahash_fbk_req, ctx->ahash_fbk);\n\tahash_request_set_callback(&rctx->ahash_fbk_req,\n\t\t\t\t   req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   req->base.complete, req->base.data);\n\n\tahash_request_set_crypt(&rctx->ahash_fbk_req, req->src,\n\t\t\t\treq->result, req->nbytes);\n\n\treturn crypto_ahash_update(&rctx->ahash_fbk_req);\n}\n\nstatic int starfive_hash_final(struct ahash_request *req)\n{\n\tstruct starfive_cryp_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->ahash_fbk_req, ctx->ahash_fbk);\n\tahash_request_set_callback(&rctx->ahash_fbk_req,\n\t\t\t\t   req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   req->base.complete, req->base.data);\n\n\tahash_request_set_crypt(&rctx->ahash_fbk_req, req->src,\n\t\t\t\treq->result, req->nbytes);\n\n\treturn crypto_ahash_final(&rctx->ahash_fbk_req);\n}\n\nstatic int starfive_hash_finup(struct ahash_request *req)\n{\n\tstruct starfive_cryp_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->ahash_fbk_req, ctx->ahash_fbk);\n\tahash_request_set_callback(&rctx->ahash_fbk_req,\n\t\t\t\t   req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   req->base.complete, req->base.data);\n\n\tahash_request_set_crypt(&rctx->ahash_fbk_req, req->src,\n\t\t\t\treq->result, req->nbytes);\n\n\treturn crypto_ahash_finup(&rctx->ahash_fbk_req);\n}\n\nstatic int starfive_hash_digest_fb(struct ahash_request *req)\n{\n\tstruct starfive_cryp_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->ahash_fbk_req, ctx->ahash_fbk);\n\tahash_request_set_callback(&rctx->ahash_fbk_req, req->base.flags,\n\t\t\t\t   req->base.complete, req->base.data);\n\n\tahash_request_set_crypt(&rctx->ahash_fbk_req, req->src,\n\t\t\t\treq->result, req->nbytes);\n\n\treturn crypto_ahash_digest(&rctx->ahash_fbk_req);\n}\n\nstatic int starfive_hash_digest(struct ahash_request *req)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(tfm);\n\tstruct starfive_cryp_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct starfive_cryp_dev *cryp = ctx->cryp;\n\n\tmemset(rctx, 0, sizeof(struct starfive_cryp_request_ctx));\n\n\tcryp->req.hreq = req;\n\trctx->total = req->nbytes;\n\trctx->in_sg = req->src;\n\trctx->blksize = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));\n\trctx->digsize = crypto_ahash_digestsize(tfm);\n\trctx->in_sg_len = sg_nents_for_len(rctx->in_sg, rctx->total);\n\tctx->rctx = rctx;\n\n\tif (starfive_hash_check_aligned(rctx->in_sg, rctx->total, rctx->blksize))\n\t\treturn starfive_hash_digest_fb(req);\n\n\treturn crypto_transfer_hash_request_to_engine(cryp->engine, req);\n}\n\nstatic int starfive_hash_export(struct ahash_request *req, void *out)\n{\n\tstruct starfive_cryp_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->ahash_fbk_req, ctx->ahash_fbk);\n\tahash_request_set_callback(&rctx->ahash_fbk_req,\n\t\t\t\t   req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   req->base.complete, req->base.data);\n\n\treturn crypto_ahash_export(&rctx->ahash_fbk_req, out);\n}\n\nstatic int starfive_hash_import(struct ahash_request *req, const void *in)\n{\n\tstruct starfive_cryp_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tahash_request_set_tfm(&rctx->ahash_fbk_req, ctx->ahash_fbk);\n\tahash_request_set_callback(&rctx->ahash_fbk_req,\n\t\t\t\t   req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   req->base.complete, req->base.data);\n\n\treturn crypto_ahash_import(&rctx->ahash_fbk_req, in);\n}\n\nstatic int starfive_hash_init_tfm(struct crypto_ahash *hash,\n\t\t\t\t  const char *alg_name,\n\t\t\t\t  unsigned int mode)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(hash);\n\n\tctx->cryp = starfive_cryp_find_dev(ctx);\n\n\tif (!ctx->cryp)\n\t\treturn -ENODEV;\n\n\tctx->ahash_fbk = crypto_alloc_ahash(alg_name, 0,\n\t\t\t\t\t    CRYPTO_ALG_NEED_FALLBACK);\n\n\tif (IS_ERR(ctx->ahash_fbk))\n\t\treturn dev_err_probe(ctx->cryp->dev, PTR_ERR(ctx->ahash_fbk),\n\t\t\t\t     \"starfive_hash: Could not load fallback driver.\\n\");\n\n\tcrypto_ahash_set_statesize(hash, crypto_ahash_statesize(ctx->ahash_fbk));\n\tcrypto_ahash_set_reqsize(hash, sizeof(struct starfive_cryp_request_ctx) +\n\t\t\t\t crypto_ahash_reqsize(ctx->ahash_fbk));\n\n\tctx->keylen = 0;\n\tctx->hash_mode = mode;\n\n\treturn 0;\n}\n\nstatic void starfive_hash_exit_tfm(struct crypto_ahash *hash)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(hash);\n\n\tcrypto_free_ahash(ctx->ahash_fbk);\n}\n\nstatic int starfive_hash_long_setkey(struct starfive_cryp_ctx *ctx,\n\t\t\t\t     const u8 *key, unsigned int keylen,\n\t\t\t\t     const char *alg_name)\n{\n\tstruct crypto_wait wait;\n\tstruct ahash_request *req;\n\tstruct scatterlist sg;\n\tstruct crypto_ahash *ahash_tfm;\n\tu8 *buf;\n\tint ret;\n\n\tahash_tfm = crypto_alloc_ahash(alg_name, 0, 0);\n\tif (IS_ERR(ahash_tfm))\n\t\treturn PTR_ERR(ahash_tfm);\n\n\treq = ahash_request_alloc(ahash_tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_ahash;\n\t}\n\n\tcrypto_init_wait(&wait);\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t   crypto_req_done, &wait);\n\tcrypto_ahash_clear_flags(ahash_tfm, ~0);\n\n\tbuf = kzalloc(keylen + STARFIVE_HASH_BUFLEN, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_req;\n\t}\n\n\tmemcpy(buf, key, keylen);\n\tsg_init_one(&sg, buf, keylen);\n\tahash_request_set_crypt(req, &sg, ctx->key, keylen);\n\n\tret = crypto_wait_req(crypto_ahash_digest(req), &wait);\n\n\tkfree(buf);\nerr_free_req:\n\tahash_request_free(req);\nerr_free_ahash:\n\tcrypto_free_ahash(ahash_tfm);\n\treturn ret;\n}\n\nstatic int starfive_hash_setkey(struct crypto_ahash *hash,\n\t\t\t\tconst u8 *key, unsigned int keylen)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(hash);\n\tunsigned int digestsize = crypto_ahash_digestsize(hash);\n\tunsigned int blocksize = crypto_ahash_blocksize(hash);\n\tconst char *alg_name;\n\n\tcrypto_ahash_setkey(ctx->ahash_fbk, key, keylen);\n\n\tif (keylen <= blocksize) {\n\t\tmemcpy(ctx->key, key, keylen);\n\t\tctx->keylen = keylen;\n\t\treturn 0;\n\t}\n\n\tctx->keylen = digestsize;\n\n\tswitch (digestsize) {\n\tcase SHA224_DIGEST_SIZE:\n\t\talg_name = \"sha224-starfive\";\n\t\tbreak;\n\tcase SHA256_DIGEST_SIZE:\n\t\tif (ctx->hash_mode == STARFIVE_HASH_SM3)\n\t\t\talg_name = \"sm3-starfive\";\n\t\telse\n\t\t\talg_name = \"sha256-starfive\";\n\t\tbreak;\n\tcase SHA384_DIGEST_SIZE:\n\t\talg_name = \"sha384-starfive\";\n\t\tbreak;\n\tcase SHA512_DIGEST_SIZE:\n\t\talg_name = \"sha512-starfive\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn starfive_hash_long_setkey(ctx, key, keylen, alg_name);\n}\n\nstatic int starfive_sha224_init_tfm(struct crypto_ahash *hash)\n{\n\treturn starfive_hash_init_tfm(hash, \"sha224-generic\",\n\t\t\t\t      STARFIVE_HASH_SHA224);\n}\n\nstatic int starfive_sha256_init_tfm(struct crypto_ahash *hash)\n{\n\treturn starfive_hash_init_tfm(hash, \"sha256-generic\",\n\t\t\t\t      STARFIVE_HASH_SHA256);\n}\n\nstatic int starfive_sha384_init_tfm(struct crypto_ahash *hash)\n{\n\treturn starfive_hash_init_tfm(hash, \"sha384-generic\",\n\t\t\t\t      STARFIVE_HASH_SHA384);\n}\n\nstatic int starfive_sha512_init_tfm(struct crypto_ahash *hash)\n{\n\treturn starfive_hash_init_tfm(hash, \"sha512-generic\",\n\t\t\t\t      STARFIVE_HASH_SHA512);\n}\n\nstatic int starfive_sm3_init_tfm(struct crypto_ahash *hash)\n{\n\treturn starfive_hash_init_tfm(hash, \"sm3-generic\",\n\t\t\t\t      STARFIVE_HASH_SM3);\n}\n\nstatic int starfive_hmac_sha224_init_tfm(struct crypto_ahash *hash)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(hash);\n\n\tctx->is_hmac = true;\n\n\treturn starfive_hash_init_tfm(hash, \"hmac(sha224-generic)\",\n\t\t\t\t      STARFIVE_HASH_SHA224);\n}\n\nstatic int starfive_hmac_sha256_init_tfm(struct crypto_ahash *hash)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(hash);\n\n\tctx->is_hmac = true;\n\n\treturn starfive_hash_init_tfm(hash, \"hmac(sha256-generic)\",\n\t\t\t\t      STARFIVE_HASH_SHA256);\n}\n\nstatic int starfive_hmac_sha384_init_tfm(struct crypto_ahash *hash)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(hash);\n\n\tctx->is_hmac = true;\n\n\treturn starfive_hash_init_tfm(hash, \"hmac(sha384-generic)\",\n\t\t\t\t      STARFIVE_HASH_SHA384);\n}\n\nstatic int starfive_hmac_sha512_init_tfm(struct crypto_ahash *hash)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(hash);\n\n\tctx->is_hmac = true;\n\n\treturn starfive_hash_init_tfm(hash, \"hmac(sha512-generic)\",\n\t\t\t\t      STARFIVE_HASH_SHA512);\n}\n\nstatic int starfive_hmac_sm3_init_tfm(struct crypto_ahash *hash)\n{\n\tstruct starfive_cryp_ctx *ctx = crypto_ahash_ctx(hash);\n\n\tctx->is_hmac = true;\n\n\treturn starfive_hash_init_tfm(hash, \"hmac(sm3-generic)\",\n\t\t\t\t      STARFIVE_HASH_SM3);\n}\n\nstatic struct ahash_engine_alg algs_sha2_sm3[] = {\n{\n\t.base.init     = starfive_hash_init,\n\t.base.update   = starfive_hash_update,\n\t.base.final    = starfive_hash_final,\n\t.base.finup    = starfive_hash_finup,\n\t.base.digest   = starfive_hash_digest,\n\t.base.export   = starfive_hash_export,\n\t.base.import   = starfive_hash_import,\n\t.base.init_tfm = starfive_sha224_init_tfm,\n\t.base.exit_tfm = starfive_hash_exit_tfm,\n\t.base.halg = {\n\t\t.digestsize = SHA224_DIGEST_SIZE,\n\t\t.statesize  = sizeof(struct sha256_state),\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"sha224\",\n\t\t\t.cra_driver_name\t= \"sha224-starfive\",\n\t\t\t.cra_priority\t\t= 200,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize\t\t= SHA224_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t\t.cra_alignmask\t\t= 3,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t}\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_hash_one_request,\n\t},\n}, {\n\t.base.init     = starfive_hash_init,\n\t.base.update   = starfive_hash_update,\n\t.base.final    = starfive_hash_final,\n\t.base.finup    = starfive_hash_finup,\n\t.base.digest   = starfive_hash_digest,\n\t.base.export   = starfive_hash_export,\n\t.base.import   = starfive_hash_import,\n\t.base.init_tfm = starfive_hmac_sha224_init_tfm,\n\t.base.exit_tfm = starfive_hash_exit_tfm,\n\t.base.setkey   = starfive_hash_setkey,\n\t.base.halg = {\n\t\t.digestsize = SHA224_DIGEST_SIZE,\n\t\t.statesize  = sizeof(struct sha256_state),\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"hmac(sha224)\",\n\t\t\t.cra_driver_name\t= \"sha224-hmac-starfive\",\n\t\t\t.cra_priority\t\t= 200,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize\t\t= SHA224_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t\t.cra_alignmask\t\t= 3,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t}\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_hash_one_request,\n\t},\n}, {\n\t.base.init     = starfive_hash_init,\n\t.base.update   = starfive_hash_update,\n\t.base.final    = starfive_hash_final,\n\t.base.finup    = starfive_hash_finup,\n\t.base.digest   = starfive_hash_digest,\n\t.base.export   = starfive_hash_export,\n\t.base.import   = starfive_hash_import,\n\t.base.init_tfm = starfive_sha256_init_tfm,\n\t.base.exit_tfm = starfive_hash_exit_tfm,\n\t.base.halg = {\n\t\t.digestsize = SHA256_DIGEST_SIZE,\n\t\t.statesize  = sizeof(struct sha256_state),\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"sha256\",\n\t\t\t.cra_driver_name\t= \"sha256-starfive\",\n\t\t\t.cra_priority\t\t= 200,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize\t\t= SHA256_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t\t.cra_alignmask\t\t= 3,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t}\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_hash_one_request,\n\t},\n}, {\n\t.base.init     = starfive_hash_init,\n\t.base.update   = starfive_hash_update,\n\t.base.final    = starfive_hash_final,\n\t.base.finup    = starfive_hash_finup,\n\t.base.digest   = starfive_hash_digest,\n\t.base.export   = starfive_hash_export,\n\t.base.import   = starfive_hash_import,\n\t.base.init_tfm = starfive_hmac_sha256_init_tfm,\n\t.base.exit_tfm = starfive_hash_exit_tfm,\n\t.base.setkey   = starfive_hash_setkey,\n\t.base.halg = {\n\t\t.digestsize = SHA256_DIGEST_SIZE,\n\t\t.statesize  = sizeof(struct sha256_state),\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"hmac(sha256)\",\n\t\t\t.cra_driver_name\t= \"sha256-hmac-starfive\",\n\t\t\t.cra_priority\t\t= 200,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize\t\t= SHA256_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t\t.cra_alignmask\t\t= 3,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t}\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_hash_one_request,\n\t},\n}, {\n\t.base.init     = starfive_hash_init,\n\t.base.update   = starfive_hash_update,\n\t.base.final    = starfive_hash_final,\n\t.base.finup    = starfive_hash_finup,\n\t.base.digest   = starfive_hash_digest,\n\t.base.export   = starfive_hash_export,\n\t.base.import   = starfive_hash_import,\n\t.base.init_tfm = starfive_sha384_init_tfm,\n\t.base.exit_tfm = starfive_hash_exit_tfm,\n\t.base.halg = {\n\t\t.digestsize = SHA384_DIGEST_SIZE,\n\t\t.statesize  = sizeof(struct sha512_state),\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"sha384\",\n\t\t\t.cra_driver_name\t= \"sha384-starfive\",\n\t\t\t.cra_priority\t\t= 200,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize\t\t= SHA384_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t\t.cra_alignmask\t\t= 3,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t}\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_hash_one_request,\n\t},\n}, {\n\t.base.init     = starfive_hash_init,\n\t.base.update   = starfive_hash_update,\n\t.base.final    = starfive_hash_final,\n\t.base.finup    = starfive_hash_finup,\n\t.base.digest   = starfive_hash_digest,\n\t.base.export   = starfive_hash_export,\n\t.base.import   = starfive_hash_import,\n\t.base.init_tfm = starfive_hmac_sha384_init_tfm,\n\t.base.exit_tfm = starfive_hash_exit_tfm,\n\t.base.setkey   = starfive_hash_setkey,\n\t.base.halg = {\n\t\t.digestsize = SHA384_DIGEST_SIZE,\n\t\t.statesize  = sizeof(struct sha512_state),\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"hmac(sha384)\",\n\t\t\t.cra_driver_name\t= \"sha384-hmac-starfive\",\n\t\t\t.cra_priority\t\t= 200,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize\t\t= SHA384_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t\t.cra_alignmask\t\t= 3,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t}\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_hash_one_request,\n\t},\n}, {\n\t.base.init     = starfive_hash_init,\n\t.base.update   = starfive_hash_update,\n\t.base.final    = starfive_hash_final,\n\t.base.finup    = starfive_hash_finup,\n\t.base.digest   = starfive_hash_digest,\n\t.base.export   = starfive_hash_export,\n\t.base.import   = starfive_hash_import,\n\t.base.init_tfm = starfive_sha512_init_tfm,\n\t.base.exit_tfm = starfive_hash_exit_tfm,\n\t.base.halg = {\n\t\t.digestsize = SHA512_DIGEST_SIZE,\n\t\t.statesize  = sizeof(struct sha512_state),\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"sha512\",\n\t\t\t.cra_driver_name\t= \"sha512-starfive\",\n\t\t\t.cra_priority\t\t= 200,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize\t\t= SHA512_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t\t.cra_alignmask\t\t= 3,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t}\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_hash_one_request,\n\t},\n}, {\n\t.base.init     = starfive_hash_init,\n\t.base.update   = starfive_hash_update,\n\t.base.final    = starfive_hash_final,\n\t.base.finup    = starfive_hash_finup,\n\t.base.digest   = starfive_hash_digest,\n\t.base.export   = starfive_hash_export,\n\t.base.import   = starfive_hash_import,\n\t.base.init_tfm = starfive_hmac_sha512_init_tfm,\n\t.base.exit_tfm = starfive_hash_exit_tfm,\n\t.base.setkey   = starfive_hash_setkey,\n\t.base.halg = {\n\t\t.digestsize = SHA512_DIGEST_SIZE,\n\t\t.statesize  = sizeof(struct sha512_state),\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"hmac(sha512)\",\n\t\t\t.cra_driver_name\t= \"sha512-hmac-starfive\",\n\t\t\t.cra_priority\t\t= 200,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize\t\t= SHA512_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t\t.cra_alignmask\t\t= 3,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t}\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_hash_one_request,\n\t},\n}, {\n\t.base.init     = starfive_hash_init,\n\t.base.update   = starfive_hash_update,\n\t.base.final    = starfive_hash_final,\n\t.base.finup    = starfive_hash_finup,\n\t.base.digest   = starfive_hash_digest,\n\t.base.export   = starfive_hash_export,\n\t.base.import   = starfive_hash_import,\n\t.base.init_tfm = starfive_sm3_init_tfm,\n\t.base.exit_tfm = starfive_hash_exit_tfm,\n\t.base.halg = {\n\t\t.digestsize = SM3_DIGEST_SIZE,\n\t\t.statesize  = sizeof(struct sm3_state),\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"sm3\",\n\t\t\t.cra_driver_name\t= \"sm3-starfive\",\n\t\t\t.cra_priority\t\t= 200,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize\t\t= SM3_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t\t.cra_alignmask\t\t= 3,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t}\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_hash_one_request,\n\t},\n}, {\n\t.base.init\t  = starfive_hash_init,\n\t.base.update\t  = starfive_hash_update,\n\t.base.final\t  = starfive_hash_final,\n\t.base.finup\t  = starfive_hash_finup,\n\t.base.digest\t  = starfive_hash_digest,\n\t.base.export\t  = starfive_hash_export,\n\t.base.import\t  = starfive_hash_import,\n\t.base.init_tfm = starfive_hmac_sm3_init_tfm,\n\t.base.exit_tfm = starfive_hash_exit_tfm,\n\t.base.setkey\t  = starfive_hash_setkey,\n\t.base.halg = {\n\t\t.digestsize = SM3_DIGEST_SIZE,\n\t\t.statesize  = sizeof(struct sm3_state),\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"hmac(sm3)\",\n\t\t\t.cra_driver_name\t= \"sm3-hmac-starfive\",\n\t\t\t.cra_priority\t\t= 200,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_TYPE_AHASH |\n\t\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize\t\t= SM3_BLOCK_SIZE,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct starfive_cryp_ctx),\n\t\t\t.cra_alignmask\t\t= 3,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t}\n\t},\n\t.op = {\n\t\t.do_one_request = starfive_hash_one_request,\n\t},\n},\n};\n\nint starfive_hash_register_algs(void)\n{\n\treturn crypto_engine_register_ahashes(algs_sha2_sm3, ARRAY_SIZE(algs_sha2_sm3));\n}\n\nvoid starfive_hash_unregister_algs(void)\n{\n\tcrypto_engine_unregister_ahashes(algs_sha2_sm3, ARRAY_SIZE(algs_sha2_sm3));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}