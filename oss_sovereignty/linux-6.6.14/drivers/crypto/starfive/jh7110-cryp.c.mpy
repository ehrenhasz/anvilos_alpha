{
  "module_name": "jh7110-cryp.c",
  "hash_id": "c3fc0dfcef67043a443de84416d36a1e3e23e1c924da36aebeeef5e0a682b46f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/starfive/jh7110-cryp.c",
  "human_readable_source": "\n \n\n#include <crypto/engine.h>\n#include \"jh7110-cryp.h\"\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n\n#define DRIVER_NAME             \"jh7110-crypto\"\n\nstruct starfive_dev_list {\n\tstruct list_head        dev_list;\n\tspinlock_t              lock;  \n};\n\nstatic struct starfive_dev_list dev_list = {\n\t.dev_list = LIST_HEAD_INIT(dev_list.dev_list),\n\t.lock     = __SPIN_LOCK_UNLOCKED(dev_list.lock),\n};\n\nstruct starfive_cryp_dev *starfive_cryp_find_dev(struct starfive_cryp_ctx *ctx)\n{\n\tstruct starfive_cryp_dev *cryp = NULL, *tmp;\n\n\tspin_lock_bh(&dev_list.lock);\n\tif (!ctx->cryp) {\n\t\tlist_for_each_entry(tmp, &dev_list.dev_list, list) {\n\t\t\tcryp = tmp;\n\t\t\tbreak;\n\t\t}\n\t\tctx->cryp = cryp;\n\t} else {\n\t\tcryp = ctx->cryp;\n\t}\n\n\tspin_unlock_bh(&dev_list.lock);\n\n\treturn cryp;\n}\n\nstatic u16 side_chan;\nmodule_param(side_chan, ushort, 0);\nMODULE_PARM_DESC(side_chan, \"Enable side channel mitigation for AES module.\\n\"\n\t\t\t    \"Enabling this feature will reduce speed performance.\\n\"\n\t\t\t    \" 0 - Disabled\\n\"\n\t\t\t    \" other - Enabled\");\n\nstatic int starfive_dma_init(struct starfive_cryp_dev *cryp)\n{\n\tdma_cap_mask_t mask;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\tcryp->tx = dma_request_chan(cryp->dev, \"tx\");\n\tif (IS_ERR(cryp->tx))\n\t\treturn dev_err_probe(cryp->dev, PTR_ERR(cryp->tx),\n\t\t\t\t     \"Error requesting tx dma channel.\\n\");\n\n\tcryp->rx = dma_request_chan(cryp->dev, \"rx\");\n\tif (IS_ERR(cryp->rx)) {\n\t\tdma_release_channel(cryp->tx);\n\t\treturn dev_err_probe(cryp->dev, PTR_ERR(cryp->rx),\n\t\t\t\t     \"Error requesting rx dma channel.\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void starfive_dma_cleanup(struct starfive_cryp_dev *cryp)\n{\n\tdma_release_channel(cryp->tx);\n\tdma_release_channel(cryp->rx);\n}\n\nstatic irqreturn_t starfive_cryp_irq(int irq, void *priv)\n{\n\tu32 status;\n\tu32 mask;\n\tstruct starfive_cryp_dev *cryp = (struct starfive_cryp_dev *)priv;\n\n\tmask = readl(cryp->base + STARFIVE_IE_MASK_OFFSET);\n\tstatus = readl(cryp->base + STARFIVE_IE_FLAG_OFFSET);\n\tif (status & STARFIVE_IE_FLAG_AES_DONE) {\n\t\tmask |= STARFIVE_IE_MASK_AES_DONE;\n\t\twritel(mask, cryp->base + STARFIVE_IE_MASK_OFFSET);\n\t\ttasklet_schedule(&cryp->aes_done);\n\t}\n\n\tif (status & STARFIVE_IE_FLAG_HASH_DONE) {\n\t\tmask |= STARFIVE_IE_MASK_HASH_DONE;\n\t\twritel(mask, cryp->base + STARFIVE_IE_MASK_OFFSET);\n\t\ttasklet_schedule(&cryp->hash_done);\n\t}\n\n\tif (status & STARFIVE_IE_FLAG_PKA_DONE) {\n\t\tmask |= STARFIVE_IE_MASK_PKA_DONE;\n\t\twritel(mask, cryp->base + STARFIVE_IE_MASK_OFFSET);\n\t\tcomplete(&cryp->pka_done);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int starfive_cryp_probe(struct platform_device *pdev)\n{\n\tstruct starfive_cryp_dev *cryp;\n\tstruct resource *res;\n\tint irq;\n\tint ret;\n\n\tcryp = devm_kzalloc(&pdev->dev, sizeof(*cryp), GFP_KERNEL);\n\tif (!cryp)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, cryp);\n\tcryp->dev = &pdev->dev;\n\n\tcryp->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(cryp->base))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(cryp->base),\n\t\t\t\t     \"Error remapping memory for platform device\\n\");\n\n\ttasklet_init(&cryp->aes_done, starfive_aes_done_task, (unsigned long)cryp);\n\ttasklet_init(&cryp->hash_done, starfive_hash_done_task, (unsigned long)cryp);\n\n\tcryp->phys_base = res->start;\n\tcryp->dma_maxburst = 32;\n\tcryp->side_chan = side_chan;\n\n\tcryp->hclk = devm_clk_get(&pdev->dev, \"hclk\");\n\tif (IS_ERR(cryp->hclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(cryp->hclk),\n\t\t\t\t     \"Error getting hardware reference clock\\n\");\n\n\tcryp->ahb = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(cryp->ahb))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(cryp->ahb),\n\t\t\t\t     \"Error getting ahb reference clock\\n\");\n\n\tcryp->rst = devm_reset_control_get_shared(cryp->dev, NULL);\n\tif (IS_ERR(cryp->rst))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(cryp->rst),\n\t\t\t\t     \"Error getting hardware reset line\\n\");\n\n\tinit_completion(&cryp->pka_done);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, starfive_cryp_irq, 0, pdev->name,\n\t\t\t       (void *)cryp);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, irq,\n\t\t\t\t     \"Failed to register interrupt handler\\n\");\n\n\tclk_prepare_enable(cryp->hclk);\n\tclk_prepare_enable(cryp->ahb);\n\treset_control_deassert(cryp->rst);\n\n\tspin_lock(&dev_list.lock);\n\tlist_add(&cryp->list, &dev_list.dev_list);\n\tspin_unlock(&dev_list.lock);\n\n\tret = starfive_dma_init(cryp);\n\tif (ret)\n\t\tgoto err_dma_init;\n\n\t \n\tcryp->engine = crypto_engine_alloc_init(&pdev->dev, 1);\n\tif (!cryp->engine) {\n\t\tret = -ENOMEM;\n\t\tgoto err_engine;\n\t}\n\n\tret = crypto_engine_start(cryp->engine);\n\tif (ret)\n\t\tgoto err_engine_start;\n\n\tret = starfive_aes_register_algs();\n\tif (ret)\n\t\tgoto err_algs_aes;\n\n\tret = starfive_hash_register_algs();\n\tif (ret)\n\t\tgoto err_algs_hash;\n\n\tret = starfive_rsa_register_algs();\n\tif (ret)\n\t\tgoto err_algs_rsa;\n\n\treturn 0;\n\nerr_algs_rsa:\n\tstarfive_hash_unregister_algs();\nerr_algs_hash:\n\tstarfive_aes_unregister_algs();\nerr_algs_aes:\n\tcrypto_engine_stop(cryp->engine);\nerr_engine_start:\n\tcrypto_engine_exit(cryp->engine);\nerr_engine:\n\tstarfive_dma_cleanup(cryp);\nerr_dma_init:\n\tspin_lock(&dev_list.lock);\n\tlist_del(&cryp->list);\n\tspin_unlock(&dev_list.lock);\n\n\tclk_disable_unprepare(cryp->hclk);\n\tclk_disable_unprepare(cryp->ahb);\n\treset_control_assert(cryp->rst);\n\n\ttasklet_kill(&cryp->aes_done);\n\ttasklet_kill(&cryp->hash_done);\n\n\treturn ret;\n}\n\nstatic void starfive_cryp_remove(struct platform_device *pdev)\n{\n\tstruct starfive_cryp_dev *cryp = platform_get_drvdata(pdev);\n\n\tstarfive_aes_unregister_algs();\n\tstarfive_hash_unregister_algs();\n\tstarfive_rsa_unregister_algs();\n\n\ttasklet_kill(&cryp->aes_done);\n\ttasklet_kill(&cryp->hash_done);\n\n\tcrypto_engine_stop(cryp->engine);\n\tcrypto_engine_exit(cryp->engine);\n\n\tstarfive_dma_cleanup(cryp);\n\n\tspin_lock(&dev_list.lock);\n\tlist_del(&cryp->list);\n\tspin_unlock(&dev_list.lock);\n\n\tclk_disable_unprepare(cryp->hclk);\n\tclk_disable_unprepare(cryp->ahb);\n\treset_control_assert(cryp->rst);\n}\n\nstatic const struct of_device_id starfive_dt_ids[] __maybe_unused = {\n\t{ .compatible = \"starfive,jh7110-crypto\", .data = NULL},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, starfive_dt_ids);\n\nstatic struct platform_driver starfive_cryp_driver = {\n\t.probe  = starfive_cryp_probe,\n\t.remove_new = starfive_cryp_remove,\n\t.driver = {\n\t\t.name           = DRIVER_NAME,\n\t\t.of_match_table = starfive_dt_ids,\n\t},\n};\n\nmodule_platform_driver(starfive_cryp_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"StarFive JH7110 Cryptographic Module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}