{
  "module_name": "omap-des.c",
  "hash_id": "86c1213bbbe5c3f58bf6fb11991678fd091d8ef6b829a524642abbd60bbec8c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/omap-des.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#ifdef DEBUG\n#define prn(num) printk(#num \"=%d\\n\", num)\n#define prx(num) printk(#num \"=%x\\n\", num)\n#else\n#define prn(num) do { } while (0)\n#define prx(num)  do { } while (0)\n#endif\n\n#include <crypto/engine.h>\n#include <crypto/internal/des.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/scatterlist.h>\n#include <linux/string.h>\n\n#include \"omap-crypto.h\"\n\n#define DST_MAXBURST\t\t\t2\n\n#define DES_BLOCK_WORDS\t\t(DES_BLOCK_SIZE >> 2)\n\n#define _calc_walked(inout) (dd->inout##_walk.offset - dd->inout##_sg->offset)\n\n#define DES_REG_KEY(dd, x)\t\t((dd)->pdata->key_ofs - \\\n\t\t\t\t\t\t((x ^ 0x01) * 0x04))\n\n#define DES_REG_IV(dd, x)\t\t((dd)->pdata->iv_ofs + ((x) * 0x04))\n\n#define DES_REG_CTRL(dd)\t\t((dd)->pdata->ctrl_ofs)\n#define DES_REG_CTRL_CBC\t\tBIT(4)\n#define DES_REG_CTRL_TDES\t\tBIT(3)\n#define DES_REG_CTRL_DIRECTION\t\tBIT(2)\n#define DES_REG_CTRL_INPUT_READY\tBIT(1)\n#define DES_REG_CTRL_OUTPUT_READY\tBIT(0)\n\n#define DES_REG_DATA_N(dd, x)\t\t((dd)->pdata->data_ofs + ((x) * 0x04))\n\n#define DES_REG_REV(dd)\t\t\t((dd)->pdata->rev_ofs)\n\n#define DES_REG_MASK(dd)\t\t((dd)->pdata->mask_ofs)\n\n#define DES_REG_LENGTH_N(x)\t\t(0x24 + ((x) * 0x04))\n\n#define DES_REG_IRQ_STATUS(dd)         ((dd)->pdata->irq_status_ofs)\n#define DES_REG_IRQ_ENABLE(dd)         ((dd)->pdata->irq_enable_ofs)\n#define DES_REG_IRQ_DATA_IN            BIT(1)\n#define DES_REG_IRQ_DATA_OUT           BIT(2)\n\n#define FLAGS_MODE_MASK\t\t0x000f\n#define FLAGS_ENCRYPT\t\tBIT(0)\n#define FLAGS_CBC\t\tBIT(1)\n#define FLAGS_INIT\t\tBIT(4)\n#define FLAGS_BUSY\t\tBIT(6)\n\n#define DEFAULT_AUTOSUSPEND_DELAY\t1000\n\n#define FLAGS_IN_DATA_ST_SHIFT\t8\n#define FLAGS_OUT_DATA_ST_SHIFT\t10\n\nstruct omap_des_ctx {\n\tstruct omap_des_dev *dd;\n\n\tint\t\tkeylen;\n\t__le32\t\tkey[(3 * DES_KEY_SIZE) / sizeof(u32)];\n\tunsigned long\tflags;\n};\n\nstruct omap_des_reqctx {\n\tunsigned long mode;\n};\n\n#define OMAP_DES_QUEUE_LENGTH\t1\n#define OMAP_DES_CACHE_SIZE\t0\n\nstruct omap_des_algs_info {\n\tstruct skcipher_engine_alg\t*algs_list;\n\tunsigned int\t\t\tsize;\n\tunsigned int\t\t\tregistered;\n};\n\nstruct omap_des_pdata {\n\tstruct omap_des_algs_info\t*algs_info;\n\tunsigned int\talgs_info_size;\n\n\tvoid\t\t(*trigger)(struct omap_des_dev *dd, int length);\n\n\tu32\t\tkey_ofs;\n\tu32\t\tiv_ofs;\n\tu32\t\tctrl_ofs;\n\tu32\t\tdata_ofs;\n\tu32\t\trev_ofs;\n\tu32\t\tmask_ofs;\n\tu32             irq_enable_ofs;\n\tu32             irq_status_ofs;\n\n\tu32\t\tdma_enable_in;\n\tu32\t\tdma_enable_out;\n\tu32\t\tdma_start;\n\n\tu32\t\tmajor_mask;\n\tu32\t\tmajor_shift;\n\tu32\t\tminor_mask;\n\tu32\t\tminor_shift;\n};\n\nstruct omap_des_dev {\n\tstruct list_head\tlist;\n\tunsigned long\t\tphys_base;\n\tvoid __iomem\t\t*io_base;\n\tstruct omap_des_ctx\t*ctx;\n\tstruct device\t\t*dev;\n\tunsigned long\t\tflags;\n\tint\t\t\terr;\n\n\tstruct tasklet_struct\tdone_task;\n\n\tstruct skcipher_request\t*req;\n\tstruct crypto_engine\t\t*engine;\n\t \n\tsize_t                          total;\n\tsize_t                          total_save;\n\n\tstruct scatterlist\t\t*in_sg;\n\tstruct scatterlist\t\t*out_sg;\n\n\t \n\tstruct scatterlist\t\tin_sgl;\n\tstruct scatterlist\t\tout_sgl;\n\tstruct scatterlist\t\t*orig_out;\n\n\tstruct scatter_walk\t\tin_walk;\n\tstruct scatter_walk\t\tout_walk;\n\tstruct dma_chan\t\t*dma_lch_in;\n\tstruct dma_chan\t\t*dma_lch_out;\n\tint\t\t\tin_sg_len;\n\tint\t\t\tout_sg_len;\n\tint\t\t\tpio_only;\n\tconst struct omap_des_pdata\t*pdata;\n};\n\n \nstatic LIST_HEAD(dev_list);\nstatic DEFINE_SPINLOCK(list_lock);\n\n#ifdef DEBUG\n#define omap_des_read(dd, offset)                               \\\n\t({                                                              \\\n\t int _read_ret;                                          \\\n\t _read_ret = __raw_readl(dd->io_base + offset);          \\\n\t pr_err(\"omap_des_read(\" #offset \"=%#x)= %#x\\n\",       \\\n\t\t offset, _read_ret);                            \\\n\t _read_ret;                                              \\\n\t })\n#else\nstatic inline u32 omap_des_read(struct omap_des_dev *dd, u32 offset)\n{\n\treturn __raw_readl(dd->io_base + offset);\n}\n#endif\n\n#ifdef DEBUG\n#define omap_des_write(dd, offset, value)                               \\\n\tdo {                                                            \\\n\t\tpr_err(\"omap_des_write(\" #offset \"=%#x) value=%#x\\n\", \\\n\t\t\t\toffset, value);                                \\\n\t\t__raw_writel(value, dd->io_base + offset);              \\\n\t} while (0)\n#else\nstatic inline void omap_des_write(struct omap_des_dev *dd, u32 offset,\n\t\tu32 value)\n{\n\t__raw_writel(value, dd->io_base + offset);\n}\n#endif\n\nstatic inline void omap_des_write_mask(struct omap_des_dev *dd, u32 offset,\n\t\t\t\t\tu32 value, u32 mask)\n{\n\tu32 val;\n\n\tval = omap_des_read(dd, offset);\n\tval &= ~mask;\n\tval |= value;\n\tomap_des_write(dd, offset, val);\n}\n\nstatic void omap_des_write_n(struct omap_des_dev *dd, u32 offset,\n\t\t\t\t\tu32 *value, int count)\n{\n\tfor (; count--; value++, offset += 4)\n\t\tomap_des_write(dd, offset, *value);\n}\n\nstatic int omap_des_hw_init(struct omap_des_dev *dd)\n{\n\tint err;\n\n\t \n\terr = pm_runtime_resume_and_get(dd->dev);\n\tif (err < 0) {\n\t\tdev_err(dd->dev, \"%s: failed to get_sync(%d)\\n\", __func__, err);\n\t\treturn err;\n\t}\n\n\tif (!(dd->flags & FLAGS_INIT)) {\n\t\tdd->flags |= FLAGS_INIT;\n\t\tdd->err = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_des_write_ctrl(struct omap_des_dev *dd)\n{\n\tunsigned int key32;\n\tint i, err;\n\tu32 val = 0, mask = 0;\n\n\terr = omap_des_hw_init(dd);\n\tif (err)\n\t\treturn err;\n\n\tkey32 = dd->ctx->keylen / sizeof(u32);\n\n\t \n\tfor (i = 0; i < key32; i++) {\n\t\tomap_des_write(dd, DES_REG_KEY(dd, i),\n\t\t\t       __le32_to_cpu(dd->ctx->key[i]));\n\t}\n\n\tif ((dd->flags & FLAGS_CBC) && dd->req->iv)\n\t\tomap_des_write_n(dd, DES_REG_IV(dd, 0), (void *)dd->req->iv, 2);\n\n\tif (dd->flags & FLAGS_CBC)\n\t\tval |= DES_REG_CTRL_CBC;\n\tif (dd->flags & FLAGS_ENCRYPT)\n\t\tval |= DES_REG_CTRL_DIRECTION;\n\tif (key32 == 6)\n\t\tval |= DES_REG_CTRL_TDES;\n\n\tmask |= DES_REG_CTRL_CBC | DES_REG_CTRL_DIRECTION | DES_REG_CTRL_TDES;\n\n\tomap_des_write_mask(dd, DES_REG_CTRL(dd), val, mask);\n\n\treturn 0;\n}\n\nstatic void omap_des_dma_trigger_omap4(struct omap_des_dev *dd, int length)\n{\n\tu32 mask, val;\n\n\tomap_des_write(dd, DES_REG_LENGTH_N(0), length);\n\n\tval = dd->pdata->dma_start;\n\n\tif (dd->dma_lch_out != NULL)\n\t\tval |= dd->pdata->dma_enable_out;\n\tif (dd->dma_lch_in != NULL)\n\t\tval |= dd->pdata->dma_enable_in;\n\n\tmask = dd->pdata->dma_enable_out | dd->pdata->dma_enable_in |\n\t       dd->pdata->dma_start;\n\n\tomap_des_write_mask(dd, DES_REG_MASK(dd), val, mask);\n}\n\nstatic void omap_des_dma_stop(struct omap_des_dev *dd)\n{\n\tu32 mask;\n\n\tmask = dd->pdata->dma_enable_out | dd->pdata->dma_enable_in |\n\t       dd->pdata->dma_start;\n\n\tomap_des_write_mask(dd, DES_REG_MASK(dd), 0, mask);\n}\n\nstatic struct omap_des_dev *omap_des_find_dev(struct omap_des_ctx *ctx)\n{\n\tstruct omap_des_dev *dd = NULL, *tmp;\n\n\tspin_lock_bh(&list_lock);\n\tif (!ctx->dd) {\n\t\tlist_for_each_entry(tmp, &dev_list, list) {\n\t\t\t \n\t\t\tdd = tmp;\n\t\t\tbreak;\n\t\t}\n\t\tctx->dd = dd;\n\t} else {\n\t\t \n\t\tdd = ctx->dd;\n\t}\n\tspin_unlock_bh(&list_lock);\n\n\treturn dd;\n}\n\nstatic void omap_des_dma_out_callback(void *data)\n{\n\tstruct omap_des_dev *dd = data;\n\n\t \n\ttasklet_schedule(&dd->done_task);\n}\n\nstatic int omap_des_dma_init(struct omap_des_dev *dd)\n{\n\tint err;\n\n\tdd->dma_lch_out = NULL;\n\tdd->dma_lch_in = NULL;\n\n\tdd->dma_lch_in = dma_request_chan(dd->dev, \"rx\");\n\tif (IS_ERR(dd->dma_lch_in)) {\n\t\tdev_err(dd->dev, \"Unable to request in DMA channel\\n\");\n\t\treturn PTR_ERR(dd->dma_lch_in);\n\t}\n\n\tdd->dma_lch_out = dma_request_chan(dd->dev, \"tx\");\n\tif (IS_ERR(dd->dma_lch_out)) {\n\t\tdev_err(dd->dev, \"Unable to request out DMA channel\\n\");\n\t\terr = PTR_ERR(dd->dma_lch_out);\n\t\tgoto err_dma_out;\n\t}\n\n\treturn 0;\n\nerr_dma_out:\n\tdma_release_channel(dd->dma_lch_in);\n\n\treturn err;\n}\n\nstatic void omap_des_dma_cleanup(struct omap_des_dev *dd)\n{\n\tif (dd->pio_only)\n\t\treturn;\n\n\tdma_release_channel(dd->dma_lch_out);\n\tdma_release_channel(dd->dma_lch_in);\n}\n\nstatic int omap_des_crypt_dma(struct crypto_tfm *tfm,\n\t\tstruct scatterlist *in_sg, struct scatterlist *out_sg,\n\t\tint in_sg_len, int out_sg_len)\n{\n\tstruct omap_des_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct omap_des_dev *dd = ctx->dd;\n\tstruct dma_async_tx_descriptor *tx_in, *tx_out;\n\tstruct dma_slave_config cfg;\n\tint ret;\n\n\tif (dd->pio_only) {\n\t\tscatterwalk_start(&dd->in_walk, dd->in_sg);\n\t\tscatterwalk_start(&dd->out_walk, dd->out_sg);\n\n\t\t \n\t\tomap_des_write(dd, DES_REG_IRQ_ENABLE(dd), 0x2);\n\t\treturn 0;\n\t}\n\n\tdma_sync_sg_for_device(dd->dev, dd->in_sg, in_sg_len, DMA_TO_DEVICE);\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\n\tcfg.src_addr = dd->phys_base + DES_REG_DATA_N(dd, 0);\n\tcfg.dst_addr = dd->phys_base + DES_REG_DATA_N(dd, 0);\n\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tcfg.src_maxburst = DST_MAXBURST;\n\tcfg.dst_maxburst = DST_MAXBURST;\n\n\t \n\tret = dmaengine_slave_config(dd->dma_lch_in, &cfg);\n\tif (ret) {\n\t\tdev_err(dd->dev, \"can't configure IN dmaengine slave: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\ttx_in = dmaengine_prep_slave_sg(dd->dma_lch_in, in_sg, in_sg_len,\n\t\t\t\t\tDMA_MEM_TO_DEV,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!tx_in) {\n\t\tdev_err(dd->dev, \"IN prep_slave_sg() failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttx_in->callback_param = dd;\n\n\t \n\tret = dmaengine_slave_config(dd->dma_lch_out, &cfg);\n\tif (ret) {\n\t\tdev_err(dd->dev, \"can't configure OUT dmaengine slave: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\ttx_out = dmaengine_prep_slave_sg(dd->dma_lch_out, out_sg, out_sg_len,\n\t\t\t\t\tDMA_DEV_TO_MEM,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!tx_out) {\n\t\tdev_err(dd->dev, \"OUT prep_slave_sg() failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttx_out->callback = omap_des_dma_out_callback;\n\ttx_out->callback_param = dd;\n\n\tdmaengine_submit(tx_in);\n\tdmaengine_submit(tx_out);\n\n\tdma_async_issue_pending(dd->dma_lch_in);\n\tdma_async_issue_pending(dd->dma_lch_out);\n\n\t \n\tdd->pdata->trigger(dd, dd->total);\n\n\treturn 0;\n}\n\nstatic int omap_des_crypt_dma_start(struct omap_des_dev *dd)\n{\n\tstruct crypto_tfm *tfm = crypto_skcipher_tfm(\n\t\t\t\t\tcrypto_skcipher_reqtfm(dd->req));\n\tint err;\n\n\tpr_debug(\"total: %zd\\n\", dd->total);\n\n\tif (!dd->pio_only) {\n\t\terr = dma_map_sg(dd->dev, dd->in_sg, dd->in_sg_len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tif (!err) {\n\t\t\tdev_err(dd->dev, \"dma_map_sg() error\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = dma_map_sg(dd->dev, dd->out_sg, dd->out_sg_len,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tif (!err) {\n\t\t\tdev_err(dd->dev, \"dma_map_sg() error\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\terr = omap_des_crypt_dma(tfm, dd->in_sg, dd->out_sg, dd->in_sg_len,\n\t\t\t\t dd->out_sg_len);\n\tif (err && !dd->pio_only) {\n\t\tdma_unmap_sg(dd->dev, dd->in_sg, dd->in_sg_len, DMA_TO_DEVICE);\n\t\tdma_unmap_sg(dd->dev, dd->out_sg, dd->out_sg_len,\n\t\t\t     DMA_FROM_DEVICE);\n\t}\n\n\treturn err;\n}\n\nstatic void omap_des_finish_req(struct omap_des_dev *dd, int err)\n{\n\tstruct skcipher_request *req = dd->req;\n\n\tpr_debug(\"err: %d\\n\", err);\n\n\tcrypto_finalize_skcipher_request(dd->engine, req, err);\n\n\tpm_runtime_mark_last_busy(dd->dev);\n\tpm_runtime_put_autosuspend(dd->dev);\n}\n\nstatic int omap_des_crypt_dma_stop(struct omap_des_dev *dd)\n{\n\tpr_debug(\"total: %zd\\n\", dd->total);\n\n\tomap_des_dma_stop(dd);\n\n\tdmaengine_terminate_all(dd->dma_lch_in);\n\tdmaengine_terminate_all(dd->dma_lch_out);\n\n\treturn 0;\n}\n\nstatic int omap_des_handle_queue(struct omap_des_dev *dd,\n\t\t\t\t struct skcipher_request *req)\n{\n\tif (req)\n\t\treturn crypto_transfer_skcipher_request_to_engine(dd->engine, req);\n\n\treturn 0;\n}\n\nstatic int omap_des_prepare_req(struct skcipher_request *req,\n\t\t\t\tstruct omap_des_dev *dd)\n{\n\tstruct omap_des_ctx *ctx = crypto_skcipher_ctx(\n\t\t\tcrypto_skcipher_reqtfm(req));\n\tstruct omap_des_reqctx *rctx;\n\tint ret;\n\tu16 flags;\n\n\t \n\tdd->req = req;\n\tdd->total = req->cryptlen;\n\tdd->total_save = req->cryptlen;\n\tdd->in_sg = req->src;\n\tdd->out_sg = req->dst;\n\tdd->orig_out = req->dst;\n\n\tflags = OMAP_CRYPTO_COPY_DATA;\n\tif (req->src == req->dst)\n\t\tflags |= OMAP_CRYPTO_FORCE_COPY;\n\n\tret = omap_crypto_align_sg(&dd->in_sg, dd->total, DES_BLOCK_SIZE,\n\t\t\t\t   &dd->in_sgl, flags,\n\t\t\t\t   FLAGS_IN_DATA_ST_SHIFT, &dd->flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = omap_crypto_align_sg(&dd->out_sg, dd->total, DES_BLOCK_SIZE,\n\t\t\t\t   &dd->out_sgl, 0,\n\t\t\t\t   FLAGS_OUT_DATA_ST_SHIFT, &dd->flags);\n\tif (ret)\n\t\treturn ret;\n\n\tdd->in_sg_len = sg_nents_for_len(dd->in_sg, dd->total);\n\tif (dd->in_sg_len < 0)\n\t\treturn dd->in_sg_len;\n\n\tdd->out_sg_len = sg_nents_for_len(dd->out_sg, dd->total);\n\tif (dd->out_sg_len < 0)\n\t\treturn dd->out_sg_len;\n\n\trctx = skcipher_request_ctx(req);\n\tctx = crypto_skcipher_ctx(crypto_skcipher_reqtfm(req));\n\trctx->mode &= FLAGS_MODE_MASK;\n\tdd->flags = (dd->flags & ~FLAGS_MODE_MASK) | rctx->mode;\n\n\tdd->ctx = ctx;\n\tctx->dd = dd;\n\n\treturn omap_des_write_ctrl(dd);\n}\n\nstatic int omap_des_crypt_req(struct crypto_engine *engine,\n\t\t\t      void *areq)\n{\n\tstruct skcipher_request *req = container_of(areq, struct skcipher_request, base);\n\tstruct omap_des_ctx *ctx = crypto_skcipher_ctx(\n\t\t\tcrypto_skcipher_reqtfm(req));\n\tstruct omap_des_dev *dd = omap_des_find_dev(ctx);\n\n\tif (!dd)\n\t\treturn -ENODEV;\n\n\treturn omap_des_prepare_req(req, dd) ?:\n\t       omap_des_crypt_dma_start(dd);\n}\n\nstatic void omap_des_done_task(unsigned long data)\n{\n\tstruct omap_des_dev *dd = (struct omap_des_dev *)data;\n\tint i;\n\n\tpr_debug(\"enter done_task\\n\");\n\n\tif (!dd->pio_only) {\n\t\tdma_sync_sg_for_device(dd->dev, dd->out_sg, dd->out_sg_len,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\tdma_unmap_sg(dd->dev, dd->in_sg, dd->in_sg_len, DMA_TO_DEVICE);\n\t\tdma_unmap_sg(dd->dev, dd->out_sg, dd->out_sg_len,\n\t\t\t     DMA_FROM_DEVICE);\n\t\tomap_des_crypt_dma_stop(dd);\n\t}\n\n\tomap_crypto_cleanup(&dd->in_sgl, NULL, 0, dd->total_save,\n\t\t\t    FLAGS_IN_DATA_ST_SHIFT, dd->flags);\n\n\tomap_crypto_cleanup(&dd->out_sgl, dd->orig_out, 0, dd->total_save,\n\t\t\t    FLAGS_OUT_DATA_ST_SHIFT, dd->flags);\n\n\tif ((dd->flags & FLAGS_CBC) && dd->req->iv)\n\t\tfor (i = 0; i < 2; i++)\n\t\t\t((u32 *)dd->req->iv)[i] =\n\t\t\t\tomap_des_read(dd, DES_REG_IV(dd, i));\n\n\tomap_des_finish_req(dd, 0);\n\n\tpr_debug(\"exit\\n\");\n}\n\nstatic int omap_des_crypt(struct skcipher_request *req, unsigned long mode)\n{\n\tstruct omap_des_ctx *ctx = crypto_skcipher_ctx(\n\t\t\tcrypto_skcipher_reqtfm(req));\n\tstruct omap_des_reqctx *rctx = skcipher_request_ctx(req);\n\tstruct omap_des_dev *dd;\n\n\tpr_debug(\"nbytes: %d, enc: %d, cbc: %d\\n\", req->cryptlen,\n\t\t !!(mode & FLAGS_ENCRYPT),\n\t\t !!(mode & FLAGS_CBC));\n\n\tif (!req->cryptlen)\n\t\treturn 0;\n\n\tif (!IS_ALIGNED(req->cryptlen, DES_BLOCK_SIZE))\n\t\treturn -EINVAL;\n\n\tdd = omap_des_find_dev(ctx);\n\tif (!dd)\n\t\treturn -ENODEV;\n\n\trctx->mode = mode;\n\n\treturn omap_des_handle_queue(dd, req);\n}\n\n \n\nstatic int omap_des_setkey(struct crypto_skcipher *cipher, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct omap_des_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tint err;\n\n\tpr_debug(\"enter, keylen: %d\\n\", keylen);\n\n\terr = verify_skcipher_des_key(cipher, key);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(ctx->key, key, keylen);\n\tctx->keylen = keylen;\n\n\treturn 0;\n}\n\nstatic int omap_des3_setkey(struct crypto_skcipher *cipher, const u8 *key,\n\t\t\t    unsigned int keylen)\n{\n\tstruct omap_des_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tint err;\n\n\tpr_debug(\"enter, keylen: %d\\n\", keylen);\n\n\terr = verify_skcipher_des3_key(cipher, key);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(ctx->key, key, keylen);\n\tctx->keylen = keylen;\n\n\treturn 0;\n}\n\nstatic int omap_des_ecb_encrypt(struct skcipher_request *req)\n{\n\treturn omap_des_crypt(req, FLAGS_ENCRYPT);\n}\n\nstatic int omap_des_ecb_decrypt(struct skcipher_request *req)\n{\n\treturn omap_des_crypt(req, 0);\n}\n\nstatic int omap_des_cbc_encrypt(struct skcipher_request *req)\n{\n\treturn omap_des_crypt(req, FLAGS_ENCRYPT | FLAGS_CBC);\n}\n\nstatic int omap_des_cbc_decrypt(struct skcipher_request *req)\n{\n\treturn omap_des_crypt(req, FLAGS_CBC);\n}\n\nstatic int omap_des_init_tfm(struct crypto_skcipher *tfm)\n{\n\tpr_debug(\"enter\\n\");\n\n\tcrypto_skcipher_set_reqsize(tfm, sizeof(struct omap_des_reqctx));\n\n\treturn 0;\n}\n\n \n\nstatic struct skcipher_engine_alg algs_ecb_cbc[] = {\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"ecb(des)\",\n\t\t.base.cra_driver_name\t= \"ecb-des-omap\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t  CRYPTO_ALG_ASYNC,\n\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct omap_des_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.min_keysize\t\t= DES_KEY_SIZE,\n\t\t.max_keysize\t\t= DES_KEY_SIZE,\n\t\t.setkey\t\t\t= omap_des_setkey,\n\t\t.encrypt\t\t= omap_des_ecb_encrypt,\n\t\t.decrypt\t\t= omap_des_ecb_decrypt,\n\t\t.init\t\t\t= omap_des_init_tfm,\n\t},\n\t.op.do_one_request = omap_des_crypt_req,\n},\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"cbc(des)\",\n\t\t.base.cra_driver_name\t= \"cbc-des-omap\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t  CRYPTO_ALG_ASYNC,\n\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct omap_des_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.min_keysize\t\t= DES_KEY_SIZE,\n\t\t.max_keysize\t\t= DES_KEY_SIZE,\n\t\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t\t.setkey\t\t\t= omap_des_setkey,\n\t\t.encrypt\t\t= omap_des_cbc_encrypt,\n\t\t.decrypt\t\t= omap_des_cbc_decrypt,\n\t\t.init\t\t\t= omap_des_init_tfm,\n\t},\n\t.op.do_one_request = omap_des_crypt_req,\n},\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"ecb(des3_ede)\",\n\t\t.base.cra_driver_name\t= \"ecb-des3-omap\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t  CRYPTO_ALG_ASYNC,\n\t\t.base.cra_blocksize\t= DES3_EDE_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct omap_des_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.setkey\t\t\t= omap_des3_setkey,\n\t\t.encrypt\t\t= omap_des_ecb_encrypt,\n\t\t.decrypt\t\t= omap_des_ecb_decrypt,\n\t\t.init\t\t\t= omap_des_init_tfm,\n\t},\n\t.op.do_one_request = omap_des_crypt_req,\n},\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"cbc(des3_ede)\",\n\t\t.base.cra_driver_name\t= \"cbc-des3-omap\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t  CRYPTO_ALG_ASYNC,\n\t\t.base.cra_blocksize\t= DES3_EDE_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct omap_des_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t\t.ivsize\t\t\t= DES3_EDE_BLOCK_SIZE,\n\t\t.setkey\t\t\t= omap_des3_setkey,\n\t\t.encrypt\t\t= omap_des_cbc_encrypt,\n\t\t.decrypt\t\t= omap_des_cbc_decrypt,\n\t\t.init\t\t\t= omap_des_init_tfm,\n\t},\n\t.op.do_one_request = omap_des_crypt_req,\n}\n};\n\nstatic struct omap_des_algs_info omap_des_algs_info_ecb_cbc[] = {\n\t{\n\t\t.algs_list\t= algs_ecb_cbc,\n\t\t.size\t\t= ARRAY_SIZE(algs_ecb_cbc),\n\t},\n};\n\n#ifdef CONFIG_OF\nstatic const struct omap_des_pdata omap_des_pdata_omap4 = {\n\t.algs_info\t= omap_des_algs_info_ecb_cbc,\n\t.algs_info_size\t= ARRAY_SIZE(omap_des_algs_info_ecb_cbc),\n\t.trigger\t= omap_des_dma_trigger_omap4,\n\t.key_ofs\t= 0x14,\n\t.iv_ofs\t\t= 0x18,\n\t.ctrl_ofs\t= 0x20,\n\t.data_ofs\t= 0x28,\n\t.rev_ofs\t= 0x30,\n\t.mask_ofs\t= 0x34,\n\t.irq_status_ofs = 0x3c,\n\t.irq_enable_ofs = 0x40,\n\t.dma_enable_in\t= BIT(5),\n\t.dma_enable_out\t= BIT(6),\n\t.major_mask\t= 0x0700,\n\t.major_shift\t= 8,\n\t.minor_mask\t= 0x003f,\n\t.minor_shift\t= 0,\n};\n\nstatic irqreturn_t omap_des_irq(int irq, void *dev_id)\n{\n\tstruct omap_des_dev *dd = dev_id;\n\tu32 status, i;\n\tu32 *src, *dst;\n\n\tstatus = omap_des_read(dd, DES_REG_IRQ_STATUS(dd));\n\tif (status & DES_REG_IRQ_DATA_IN) {\n\t\tomap_des_write(dd, DES_REG_IRQ_ENABLE(dd), 0x0);\n\n\t\tBUG_ON(!dd->in_sg);\n\n\t\tBUG_ON(_calc_walked(in) > dd->in_sg->length);\n\n\t\tsrc = sg_virt(dd->in_sg) + _calc_walked(in);\n\n\t\tfor (i = 0; i < DES_BLOCK_WORDS; i++) {\n\t\t\tomap_des_write(dd, DES_REG_DATA_N(dd, i), *src);\n\n\t\t\tscatterwalk_advance(&dd->in_walk, 4);\n\t\t\tif (dd->in_sg->length == _calc_walked(in)) {\n\t\t\t\tdd->in_sg = sg_next(dd->in_sg);\n\t\t\t\tif (dd->in_sg) {\n\t\t\t\t\tscatterwalk_start(&dd->in_walk,\n\t\t\t\t\t\t\t  dd->in_sg);\n\t\t\t\t\tsrc = sg_virt(dd->in_sg) +\n\t\t\t\t\t      _calc_walked(in);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsrc++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tstatus &= ~DES_REG_IRQ_DATA_IN;\n\t\tomap_des_write(dd, DES_REG_IRQ_STATUS(dd), status);\n\n\t\t \n\t\tomap_des_write(dd, DES_REG_IRQ_ENABLE(dd), 0x4);\n\n\t} else if (status & DES_REG_IRQ_DATA_OUT) {\n\t\tomap_des_write(dd, DES_REG_IRQ_ENABLE(dd), 0x0);\n\n\t\tBUG_ON(!dd->out_sg);\n\n\t\tBUG_ON(_calc_walked(out) > dd->out_sg->length);\n\n\t\tdst = sg_virt(dd->out_sg) + _calc_walked(out);\n\n\t\tfor (i = 0; i < DES_BLOCK_WORDS; i++) {\n\t\t\t*dst = omap_des_read(dd, DES_REG_DATA_N(dd, i));\n\t\t\tscatterwalk_advance(&dd->out_walk, 4);\n\t\t\tif (dd->out_sg->length == _calc_walked(out)) {\n\t\t\t\tdd->out_sg = sg_next(dd->out_sg);\n\t\t\t\tif (dd->out_sg) {\n\t\t\t\t\tscatterwalk_start(&dd->out_walk,\n\t\t\t\t\t\t\t  dd->out_sg);\n\t\t\t\t\tdst = sg_virt(dd->out_sg) +\n\t\t\t\t\t      _calc_walked(out);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst++;\n\t\t\t}\n\t\t}\n\n\t\tBUG_ON(dd->total < DES_BLOCK_SIZE);\n\n\t\tdd->total -= DES_BLOCK_SIZE;\n\n\t\t \n\t\tstatus &= ~DES_REG_IRQ_DATA_OUT;\n\t\tomap_des_write(dd, DES_REG_IRQ_STATUS(dd), status);\n\n\t\tif (!dd->total)\n\t\t\t \n\t\t\ttasklet_schedule(&dd->done_task);\n\t\telse\n\t\t\t \n\t\t\tomap_des_write(dd, DES_REG_IRQ_ENABLE(dd), 0x2);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct of_device_id omap_des_of_match[] = {\n\t{\n\t\t.compatible\t= \"ti,omap4-des\",\n\t\t.data\t\t= &omap_des_pdata_omap4,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_des_of_match);\n\nstatic int omap_des_get_of(struct omap_des_dev *dd,\n\t\tstruct platform_device *pdev)\n{\n\n\tdd->pdata = of_device_get_match_data(&pdev->dev);\n\tif (!dd->pdata) {\n\t\tdev_err(&pdev->dev, \"no compatible OF match\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n#else\nstatic int omap_des_get_of(struct omap_des_dev *dd,\n\t\tstruct device *dev)\n{\n\treturn -EINVAL;\n}\n#endif\n\nstatic int omap_des_get_pdev(struct omap_des_dev *dd,\n\t\tstruct platform_device *pdev)\n{\n\t \n\tdd->pdata = pdev->dev.platform_data;\n\n\treturn 0;\n}\n\nstatic int omap_des_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct omap_des_dev *dd;\n\tstruct skcipher_engine_alg *algp;\n\tstruct resource *res;\n\tint err = -ENOMEM, i, j, irq = -1;\n\tu32 reg;\n\n\tdd = devm_kzalloc(dev, sizeof(struct omap_des_dev), GFP_KERNEL);\n\tif (dd == NULL) {\n\t\tdev_err(dev, \"unable to alloc data struct.\\n\");\n\t\tgoto err_data;\n\t}\n\tdd->dev = dev;\n\tplatform_set_drvdata(pdev, dd);\n\n\terr = (dev->of_node) ? omap_des_get_of(dd, pdev) :\n\t\t\t       omap_des_get_pdev(dd, pdev);\n\tif (err)\n\t\tgoto err_res;\n\n\tdd->io_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(dd->io_base)) {\n\t\terr = PTR_ERR(dd->io_base);\n\t\tgoto err_res;\n\t}\n\tdd->phys_base = res->start;\n\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, DEFAULT_AUTOSUSPEND_DELAY);\n\n\tpm_runtime_enable(dev);\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err < 0) {\n\t\tdev_err(dd->dev, \"%s: failed to get_sync(%d)\\n\", __func__, err);\n\t\tgoto err_get;\n\t}\n\n\tomap_des_dma_stop(dd);\n\n\treg = omap_des_read(dd, DES_REG_REV(dd));\n\n\tpm_runtime_put_sync(dev);\n\n\tdev_info(dev, \"OMAP DES hw accel rev: %u.%u\\n\",\n\t\t (reg & dd->pdata->major_mask) >> dd->pdata->major_shift,\n\t\t (reg & dd->pdata->minor_mask) >> dd->pdata->minor_shift);\n\n\ttasklet_init(&dd->done_task, omap_des_done_task, (unsigned long)dd);\n\n\terr = omap_des_dma_init(dd);\n\tif (err == -EPROBE_DEFER) {\n\t\tgoto err_irq;\n\t} else if (err && DES_REG_IRQ_STATUS(dd) && DES_REG_IRQ_ENABLE(dd)) {\n\t\tdd->pio_only = 1;\n\n\t\tirq = platform_get_irq(pdev, 0);\n\t\tif (irq < 0) {\n\t\t\terr = irq;\n\t\t\tgoto err_irq;\n\t\t}\n\n\t\terr = devm_request_irq(dev, irq, omap_des_irq, 0,\n\t\t\t\tdev_name(dev), dd);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Unable to grab omap-des IRQ\\n\");\n\t\t\tgoto err_irq;\n\t\t}\n\t}\n\n\n\tINIT_LIST_HEAD(&dd->list);\n\tspin_lock_bh(&list_lock);\n\tlist_add_tail(&dd->list, &dev_list);\n\tspin_unlock_bh(&list_lock);\n\n\t \n\tdd->engine = crypto_engine_alloc_init(dev, 1);\n\tif (!dd->engine) {\n\t\terr = -ENOMEM;\n\t\tgoto err_engine;\n\t}\n\n\terr = crypto_engine_start(dd->engine);\n\tif (err)\n\t\tgoto err_engine;\n\n\tfor (i = 0; i < dd->pdata->algs_info_size; i++) {\n\t\tfor (j = 0; j < dd->pdata->algs_info[i].size; j++) {\n\t\t\talgp = &dd->pdata->algs_info[i].algs_list[j];\n\n\t\t\tpr_debug(\"reg alg: %s\\n\", algp->base.base.cra_name);\n\n\t\t\terr = crypto_engine_register_skcipher(algp);\n\t\t\tif (err)\n\t\t\t\tgoto err_algs;\n\n\t\t\tdd->pdata->algs_info[i].registered++;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_algs:\n\tfor (i = dd->pdata->algs_info_size - 1; i >= 0; i--)\n\t\tfor (j = dd->pdata->algs_info[i].registered - 1; j >= 0; j--)\n\t\t\tcrypto_engine_unregister_skcipher(\n\t\t\t\t\t&dd->pdata->algs_info[i].algs_list[j]);\n\nerr_engine:\n\tif (dd->engine)\n\t\tcrypto_engine_exit(dd->engine);\n\n\tomap_des_dma_cleanup(dd);\nerr_irq:\n\ttasklet_kill(&dd->done_task);\nerr_get:\n\tpm_runtime_disable(dev);\nerr_res:\n\tdd = NULL;\nerr_data:\n\tdev_err(dev, \"initialization failed.\\n\");\n\treturn err;\n}\n\nstatic int omap_des_remove(struct platform_device *pdev)\n{\n\tstruct omap_des_dev *dd = platform_get_drvdata(pdev);\n\tint i, j;\n\n\tspin_lock_bh(&list_lock);\n\tlist_del(&dd->list);\n\tspin_unlock_bh(&list_lock);\n\n\tfor (i = dd->pdata->algs_info_size - 1; i >= 0; i--)\n\t\tfor (j = dd->pdata->algs_info[i].registered - 1; j >= 0; j--)\n\t\t\tcrypto_engine_unregister_skcipher(\n\t\t\t\t\t&dd->pdata->algs_info[i].algs_list[j]);\n\n\ttasklet_kill(&dd->done_task);\n\tomap_des_dma_cleanup(dd);\n\tpm_runtime_disable(dd->dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int omap_des_suspend(struct device *dev)\n{\n\tpm_runtime_put_sync(dev);\n\treturn 0;\n}\n\nstatic int omap_des_resume(struct device *dev)\n{\n\tint err;\n\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"%s: failed to get_sync(%d)\\n\", __func__, err);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(omap_des_pm_ops, omap_des_suspend, omap_des_resume);\n\nstatic struct platform_driver omap_des_driver = {\n\t.probe\t= omap_des_probe,\n\t.remove\t= omap_des_remove,\n\t.driver\t= {\n\t\t.name\t= \"omap-des\",\n\t\t.pm\t= &omap_des_pm_ops,\n\t\t.of_match_table\t= of_match_ptr(omap_des_of_match),\n\t},\n};\n\nmodule_platform_driver(omap_des_driver);\n\nMODULE_DESCRIPTION(\"OMAP DES hw acceleration support.\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Joel Fernandes <joelf@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}