{
  "module_name": "zip_deflate.c",
  "hash_id": "3d3536c9bf15075624a5402d714a9217c6e4b5c11556babebcf712e3ecde2a96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/cavium/zip/zip_deflate.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/sched.h>\n\n#include \"common.h\"\n#include \"zip_deflate.h\"\n\n \nstatic int prepare_zip_command(struct zip_operation *zip_ops,\n\t\t\t       struct zip_state *s, union zip_inst_s *zip_cmd)\n{\n\tunion zip_zres_s *result_ptr = &s->result;\n\n\tmemset(zip_cmd, 0, sizeof(s->zip_cmd));\n\tmemset(result_ptr, 0, sizeof(s->result));\n\n\t \n\t \n\tzip_cmd->s.hg = 0;\n\t \n\tzip_cmd->s.ce = 1;\n\t \n\tzip_cmd->s.sf = 1;\n\t \n\tif (zip_ops->flush == ZIP_FLUSH_FINISH) {\n\t\tzip_cmd->s.ef = 1;\n\t\tzip_cmd->s.sf = 0;\n\t}\n\n\tzip_cmd->s.cc = zip_ops->ccode;\n\t \n\tzip_cmd->s.ss = zip_ops->speed;\n\n\t \n\t \n\tzip_cmd->s.adlercrc32 = zip_ops->csum;\n\tzip_cmd->s.historylength = zip_ops->history_len;\n\tzip_cmd->s.dg = 0;\n\n\t \n\tzip_cmd->s.inp_ptr_addr.s.addr  = __pa(zip_ops->input);\n\tzip_cmd->s.inp_ptr_ctl.s.length = (zip_ops->input_len +\n\t\t\t\t\t   zip_ops->history_len);\n\tzip_cmd->s.ds = 0;\n\n\t \n\tzip_cmd->s.out_ptr_addr.s.addr  = __pa(zip_ops->output);\n\tzip_cmd->s.out_ptr_ctl.s.length = zip_ops->output_len;\n\t \n\tzip_cmd->s.totaloutputlength    = zip_ops->output_len;\n\n\t \n\tzip_cmd->s.res_ptr_addr.s.addr = __pa(result_ptr);\n\t \n\tresult_ptr->s.compcode = 0;\n\n\treturn 0;\n}\n\n \nint zip_deflate(struct zip_operation *zip_ops, struct zip_state *s,\n\t\tstruct zip_device *zip_dev)\n{\n\tunion zip_inst_s *zip_cmd = &s->zip_cmd;\n\tunion zip_zres_s *result_ptr = &s->result;\n\tu32 queue;\n\n\t \n\tprepare_zip_command(zip_ops, s, zip_cmd);\n\n\tatomic64_add(zip_ops->input_len, &zip_dev->stats.comp_in_bytes);\n\t \n\tqueue = zip_load_instr(zip_cmd, zip_dev);\n\n\t \n\tatomic64_inc(&zip_dev->stats.comp_req_submit);\n\n\t \n\tzip_poll_result(result_ptr);\n\n\t \n\tatomic64_inc(&zip_dev->stats.comp_req_complete);\n\n\tzip_ops->compcode = result_ptr->s.compcode;\n\tswitch (zip_ops->compcode) {\n\tcase ZIP_CMD_NOTDONE:\n\t\tzip_dbg(\"Zip instruction not yet completed\");\n\t\treturn ZIP_ERROR;\n\n\tcase ZIP_CMD_SUCCESS:\n\t\tzip_dbg(\"Zip instruction completed successfully\");\n\t\tzip_update_cmd_bufs(zip_dev, queue);\n\t\tbreak;\n\n\tcase ZIP_CMD_DTRUNC:\n\t\tzip_dbg(\"Output Truncate error\");\n\t\t \n\t\treturn ZIP_ERROR;\n\n\tdefault:\n\t\tzip_err(\"Zip instruction failed. Code:%d\", zip_ops->compcode);\n\t\treturn ZIP_ERROR;\n\t}\n\n\t \n\tswitch (zip_ops->format) {\n\tcase RAW_FORMAT:\n\t\tzip_dbg(\"RAW Format: %d \", zip_ops->format);\n\t\t \n\t\tzip_ops->csum = result_ptr->s.adler32;\n\t\tbreak;\n\n\tcase ZLIB_FORMAT:\n\t\tzip_dbg(\"ZLIB Format: %d \", zip_ops->format);\n\t\tzip_ops->csum = result_ptr->s.adler32;\n\t\tbreak;\n\n\tcase GZIP_FORMAT:\n\t\tzip_dbg(\"GZIP Format: %d \", zip_ops->format);\n\t\tzip_ops->csum = result_ptr->s.crc32;\n\t\tbreak;\n\n\tcase LZS_FORMAT:\n\t\tzip_dbg(\"LZS Format: %d \", zip_ops->format);\n\t\tbreak;\n\n\tdefault:\n\t\tzip_err(\"Unknown Format:%d\\n\", zip_ops->format);\n\t}\n\n\tatomic64_add(result_ptr->s.totalbyteswritten,\n\t\t     &zip_dev->stats.comp_out_bytes);\n\n\t \n\tif (zip_ops->output_len < result_ptr->s.totalbyteswritten) {\n\t\t \n\t\tzip_err(\"output_len (%d) < total bytes written(%d)\\n\",\n\t\t\tzip_ops->output_len, result_ptr->s.totalbyteswritten);\n\t\tzip_ops->output_len = 0;\n\n\t} else {\n\t\tzip_ops->output_len = result_ptr->s.totalbyteswritten;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}