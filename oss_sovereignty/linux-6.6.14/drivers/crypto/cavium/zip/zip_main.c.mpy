{
  "module_name": "zip_main.c",
  "hash_id": "cb76a7911eb8bf6b1b5d289a2f7a2bd6d54f3305f2671012b214f14b7d153790",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/cavium/zip/zip_main.c",
  "human_readable_source": " \n\n#include \"common.h\"\n#include \"zip_crypto.h\"\n\n#define DRV_NAME\t\t\"ThunderX-ZIP\"\n\nstatic struct zip_device *zip_dev[MAX_ZIP_DEVICES];\n\nstatic const struct pci_device_id zip_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDERX_ZIP) },\n\t{ 0, }\n};\n\nstatic void zip_debugfs_init(void);\nstatic void zip_debugfs_exit(void);\nstatic int zip_register_compression_device(void);\nstatic void zip_unregister_compression_device(void);\n\nvoid zip_reg_write(u64 val, u64 __iomem *addr)\n{\n\twriteq(val, addr);\n}\n\nu64 zip_reg_read(u64 __iomem *addr)\n{\n\treturn readq(addr);\n}\n\n \nstatic struct zip_device *zip_alloc_device(struct pci_dev *pdev)\n{\n\tstruct zip_device *zip = NULL;\n\tint idx;\n\n\tfor (idx = 0; idx < MAX_ZIP_DEVICES; idx++) {\n\t\tif (!zip_dev[idx])\n\t\t\tbreak;\n\t}\n\n\t \n\tif (idx < MAX_ZIP_DEVICES)\n\t\tzip = devm_kzalloc(&pdev->dev, sizeof(*zip), GFP_KERNEL);\n\n\tif (!zip)\n\t\treturn NULL;\n\n\tzip_dev[idx] = zip;\n\tzip->index = idx;\n\treturn zip;\n}\n\n \nstruct zip_device *zip_get_device(int node)\n{\n\tif ((node < MAX_ZIP_DEVICES) && (node >= 0))\n\t\treturn zip_dev[node];\n\n\tzip_err(\"ZIP device not found for node id %d\\n\", node);\n\treturn NULL;\n}\n\n \nint zip_get_node_id(void)\n{\n\treturn cpu_to_node(raw_smp_processor_id());\n}\n\n \nstatic int zip_init_hw(struct zip_device *zip)\n{\n\tunion zip_cmd_ctl    cmd_ctl;\n\tunion zip_constants  constants;\n\tunion zip_que_ena    que_ena;\n\tunion zip_quex_map   que_map;\n\tunion zip_que_pri    que_pri;\n\n\tunion zip_quex_sbuf_addr que_sbuf_addr;\n\tunion zip_quex_sbuf_ctl  que_sbuf_ctl;\n\n\tint q = 0;\n\n\t \n\tcmd_ctl.u_reg64 = zip_reg_read(zip->reg_base + ZIP_CMD_CTL);\n\tcmd_ctl.s.forceclk = 1;\n\tzip_reg_write(cmd_ctl.u_reg64 & 0xFF, (zip->reg_base + ZIP_CMD_CTL));\n\n\tzip_msg(\"ZIP_CMD_CTL  : 0x%016llx\",\n\t\tzip_reg_read(zip->reg_base + ZIP_CMD_CTL));\n\n\tconstants.u_reg64 = zip_reg_read(zip->reg_base + ZIP_CONSTANTS);\n\tzip->depth    = constants.s.depth;\n\tzip->onfsize  = constants.s.onfsize;\n\tzip->ctxsize  = constants.s.ctxsize;\n\n\tzip_msg(\"depth: 0x%016llx , onfsize : 0x%016llx , ctxsize : 0x%016llx\",\n\t\tzip->depth, zip->onfsize, zip->ctxsize);\n\n\t \n\tfor (q = 0; q < ZIP_NUM_QUEUES; q++) {\n\t\tque_sbuf_ctl.u_reg64 = 0ull;\n\t\tque_sbuf_ctl.s.size = (ZIP_CMD_QBUF_SIZE / sizeof(u64));\n\t\tque_sbuf_ctl.s.inst_be   = 0;\n\t\tque_sbuf_ctl.s.stream_id = 0;\n\t\tzip_reg_write(que_sbuf_ctl.u_reg64,\n\t\t\t      (zip->reg_base + ZIP_QUEX_SBUF_CTL(q)));\n\n\t\tzip_msg(\"QUEX_SBUF_CTL[%d]: 0x%016llx\", q,\n\t\t\tzip_reg_read(zip->reg_base + ZIP_QUEX_SBUF_CTL(q)));\n\t}\n\n\tfor (q = 0; q < ZIP_NUM_QUEUES; q++) {\n\t\tmemset(&zip->iq[q], 0x0, sizeof(struct zip_iq));\n\n\t\tspin_lock_init(&zip->iq[q].lock);\n\n\t\tif (zip_cmd_qbuf_alloc(zip, q)) {\n\t\t\twhile (q != 0) {\n\t\t\t\tq--;\n\t\t\t\tzip_cmd_qbuf_free(zip, q);\n\t\t\t}\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tzip->iq[q].sw_tail = zip->iq[q].sw_head;\n\t\tzip->iq[q].hw_tail = zip->iq[q].sw_head;\n\n\t\t \n\t\tque_sbuf_addr.u_reg64   = 0ull;\n\t\tque_sbuf_addr.s.ptr = (__pa(zip->iq[q].sw_head) >>\n\t\t\t\t       ZIP_128B_ALIGN);\n\n\t\tzip_msg(\"QUE[%d]_PTR(PHYS): 0x%016llx\", q,\n\t\t\t(u64)que_sbuf_addr.s.ptr);\n\n\t\tzip_reg_write(que_sbuf_addr.u_reg64,\n\t\t\t      (zip->reg_base + ZIP_QUEX_SBUF_ADDR(q)));\n\n\t\tzip_msg(\"QUEX_SBUF_ADDR[%d]: 0x%016llx\", q,\n\t\t\tzip_reg_read(zip->reg_base + ZIP_QUEX_SBUF_ADDR(q)));\n\n\t\tzip_dbg(\"sw_head :0x%lx sw_tail :0x%lx hw_tail :0x%lx\",\n\t\t\tzip->iq[q].sw_head, zip->iq[q].sw_tail,\n\t\t\tzip->iq[q].hw_tail);\n\t\tzip_dbg(\"sw_head phy addr : 0x%lx\", que_sbuf_addr.s.ptr);\n\t}\n\n\t \n\tque_ena.u_reg64 = 0x0ull;\n\t \n\tfor (q = 0; q < ZIP_NUM_QUEUES; q++)\n\t\tque_ena.s.ena |= (0x1 << q);\n\tzip_reg_write(que_ena.u_reg64, (zip->reg_base + ZIP_QUE_ENA));\n\n\tzip_msg(\"QUE_ENA      : 0x%016llx\",\n\t\tzip_reg_read(zip->reg_base + ZIP_QUE_ENA));\n\n\tfor (q = 0; q < ZIP_NUM_QUEUES; q++) {\n\t\tque_map.u_reg64 = 0ull;\n\t\t \n\t\tque_map.s.zce = 0x3;\n\t\tzip_reg_write(que_map.u_reg64,\n\t\t\t      (zip->reg_base + ZIP_QUEX_MAP(q)));\n\n\t\tzip_msg(\"QUE_MAP(%d)   : 0x%016llx\", q,\n\t\t\tzip_reg_read(zip->reg_base + ZIP_QUEX_MAP(q)));\n\t}\n\n\tque_pri.u_reg64 = 0ull;\n\tfor (q = 0; q < ZIP_NUM_QUEUES; q++)\n\t\tque_pri.s.pri |= (0x1 << q);  \n\tzip_reg_write(que_pri.u_reg64, (zip->reg_base + ZIP_QUE_PRI));\n\n\tzip_msg(\"QUE_PRI %016llx\", zip_reg_read(zip->reg_base + ZIP_QUE_PRI));\n\n\treturn 0;\n}\n\nstatic void zip_reset(struct zip_device *zip)\n{\n\tunion zip_cmd_ctl cmd_ctl;\n\n\tcmd_ctl.u_reg64 = 0x0ull;\n\tcmd_ctl.s.reset = 1;   \n\tzip_reg_write(cmd_ctl.u_reg64, (zip->reg_base + ZIP_CMD_CTL));\n}\n\nstatic int zip_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct zip_device *zip = NULL;\n\tint    err;\n\n\tzip = zip_alloc_device(pdev);\n\tif (!zip)\n\t\treturn -ENOMEM;\n\n\tdev_info(dev, \"Found ZIP device %d %x:%x on Node %d\\n\", zip->index,\n\t\t pdev->vendor, pdev->device, dev_to_node(dev));\n\n\tpci_set_drvdata(pdev, zip);\n\tzip->pdev = pdev;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to enable PCI device\");\n\t\tgoto err_free_device;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\tdev_err(dev, \"PCI request regions failed 0x%x\", err);\n\t\tgoto err_disable_device;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(48));\n\tif (err) {\n\t\tdev_err(dev, \"Unable to get usable 48-bit DMA configuration\\n\");\n\t\tgoto err_release_regions;\n\t}\n\n\t \n\tzip->reg_base = pci_ioremap_bar(pdev, PCI_CFG_ZIP_PF_BAR0);\n\tif (!zip->reg_base) {\n\t\tdev_err(dev, \"ZIP: Cannot map BAR0 CSR memory space, aborting\");\n\t\terr = -ENOMEM;\n\t\tgoto err_release_regions;\n\t}\n\n\t \n\terr = zip_init_hw(zip);\n\tif (err)\n\t\tgoto err_release_regions;\n\n\t \n\terr = zip_register_compression_device();\n\tif (err < 0) {\n\t\tzip_err(\"ZIP: Kernel Crypto Registration failed\\n\");\n\t\tgoto err_register;\n\t}\n\n\t \n\tzip_debugfs_init();\n\n\treturn 0;\n\nerr_register:\n\tzip_reset(zip);\n\nerr_release_regions:\n\tif (zip->reg_base)\n\t\tiounmap(zip->reg_base);\n\tpci_release_regions(pdev);\n\nerr_disable_device:\n\tpci_disable_device(pdev);\n\nerr_free_device:\n\tpci_set_drvdata(pdev, NULL);\n\n\t \n\tzip_dev[zip->index] = NULL;\n\tdevm_kfree(dev, zip);\n\n\treturn err;\n}\n\nstatic void zip_remove(struct pci_dev *pdev)\n{\n\tstruct zip_device *zip = pci_get_drvdata(pdev);\n\tint q = 0;\n\n\tif (!zip)\n\t\treturn;\n\n\tzip_debugfs_exit();\n\n\tzip_unregister_compression_device();\n\n\tif (zip->reg_base) {\n\t\tzip_reset(zip);\n\t\tiounmap(zip->reg_base);\n\t}\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\n\t \n\tfor (q = 0; q < ZIP_NUM_QUEUES; q++)\n\t\tzip_cmd_qbuf_free(zip, q);\n\n\tpci_set_drvdata(pdev, NULL);\n\t \n\tzip_dev[zip->index] = NULL;\n}\n\n \nstatic struct pci_driver zip_driver = {\n\t.name\t    =  DRV_NAME,\n\t.id_table   =  zip_id_table,\n\t.probe\t    =  zip_probe,\n\t.remove     =  zip_remove,\n};\n\n \n\nstatic struct crypto_alg zip_comp_deflate = {\n\t.cra_name\t\t= \"deflate\",\n\t.cra_driver_name\t= \"deflate-cavium\",\n\t.cra_flags\t\t= CRYPTO_ALG_TYPE_COMPRESS,\n\t.cra_ctxsize\t\t= sizeof(struct zip_kernel_ctx),\n\t.cra_priority           = 300,\n\t.cra_module\t\t= THIS_MODULE,\n\t.cra_init\t\t= zip_alloc_comp_ctx_deflate,\n\t.cra_exit\t\t= zip_free_comp_ctx,\n\t.cra_u\t\t\t= { .compress = {\n\t\t.coa_compress\t= zip_comp_compress,\n\t\t.coa_decompress\t= zip_comp_decompress\n\t\t } }\n};\n\nstatic struct crypto_alg zip_comp_lzs = {\n\t.cra_name\t\t= \"lzs\",\n\t.cra_driver_name\t= \"lzs-cavium\",\n\t.cra_flags\t\t= CRYPTO_ALG_TYPE_COMPRESS,\n\t.cra_ctxsize\t\t= sizeof(struct zip_kernel_ctx),\n\t.cra_priority           = 300,\n\t.cra_module\t\t= THIS_MODULE,\n\t.cra_init\t\t= zip_alloc_comp_ctx_lzs,\n\t.cra_exit\t\t= zip_free_comp_ctx,\n\t.cra_u\t\t\t= { .compress = {\n\t\t.coa_compress\t= zip_comp_compress,\n\t\t.coa_decompress\t= zip_comp_decompress\n\t\t } }\n};\n\nstatic struct scomp_alg zip_scomp_deflate = {\n\t.alloc_ctx\t\t= zip_alloc_scomp_ctx_deflate,\n\t.free_ctx\t\t= zip_free_scomp_ctx,\n\t.compress\t\t= zip_scomp_compress,\n\t.decompress\t\t= zip_scomp_decompress,\n\t.base\t\t\t= {\n\t\t.cra_name\t\t= \"deflate\",\n\t\t.cra_driver_name\t= \"deflate-scomp-cavium\",\n\t\t.cra_module\t\t= THIS_MODULE,\n\t\t.cra_priority           = 300,\n\t}\n};\n\nstatic struct scomp_alg zip_scomp_lzs = {\n\t.alloc_ctx\t\t= zip_alloc_scomp_ctx_lzs,\n\t.free_ctx\t\t= zip_free_scomp_ctx,\n\t.compress\t\t= zip_scomp_compress,\n\t.decompress\t\t= zip_scomp_decompress,\n\t.base\t\t\t= {\n\t\t.cra_name\t\t= \"lzs\",\n\t\t.cra_driver_name\t= \"lzs-scomp-cavium\",\n\t\t.cra_module\t\t= THIS_MODULE,\n\t\t.cra_priority           = 300,\n\t}\n};\n\nstatic int zip_register_compression_device(void)\n{\n\tint ret;\n\n\tret = crypto_register_alg(&zip_comp_deflate);\n\tif (ret < 0) {\n\t\tzip_err(\"Deflate algorithm registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = crypto_register_alg(&zip_comp_lzs);\n\tif (ret < 0) {\n\t\tzip_err(\"LZS algorithm registration failed\\n\");\n\t\tgoto err_unregister_alg_deflate;\n\t}\n\n\tret = crypto_register_scomp(&zip_scomp_deflate);\n\tif (ret < 0) {\n\t\tzip_err(\"Deflate scomp algorithm registration failed\\n\");\n\t\tgoto err_unregister_alg_lzs;\n\t}\n\n\tret = crypto_register_scomp(&zip_scomp_lzs);\n\tif (ret < 0) {\n\t\tzip_err(\"LZS scomp algorithm registration failed\\n\");\n\t\tgoto err_unregister_scomp_deflate;\n\t}\n\n\treturn ret;\n\nerr_unregister_scomp_deflate:\n\tcrypto_unregister_scomp(&zip_scomp_deflate);\nerr_unregister_alg_lzs:\n\tcrypto_unregister_alg(&zip_comp_lzs);\nerr_unregister_alg_deflate:\n\tcrypto_unregister_alg(&zip_comp_deflate);\n\n\treturn ret;\n}\n\nstatic void zip_unregister_compression_device(void)\n{\n\tcrypto_unregister_alg(&zip_comp_deflate);\n\tcrypto_unregister_alg(&zip_comp_lzs);\n\tcrypto_unregister_scomp(&zip_scomp_deflate);\n\tcrypto_unregister_scomp(&zip_scomp_lzs);\n}\n\n \n#ifdef CONFIG_DEBUG_FS\n#include <linux/debugfs.h>\n\n \nstatic int zip_stats_show(struct seq_file *s, void *unused)\n{\n\tu64 val = 0ull;\n\tu64 avg_chunk = 0ull, avg_cr = 0ull;\n\tu32 q = 0;\n\n\tint index  = 0;\n\tstruct zip_device *zip;\n\tstruct zip_stats  *st;\n\n\tfor (index = 0; index < MAX_ZIP_DEVICES; index++) {\n\t\tu64 pending = 0;\n\n\t\tif (zip_dev[index]) {\n\t\t\tzip = zip_dev[index];\n\t\t\tst  = &zip->stats;\n\n\t\t\t \n\t\t\tfor (q = 0; q < ZIP_NUM_QUEUES; q++) {\n\t\t\t\tval = zip_reg_read((zip->reg_base +\n\t\t\t\t\t\t    ZIP_DBG_QUEX_STA(q)));\n\t\t\t\tpending += val >> 32 & 0xffffff;\n\t\t\t}\n\n\t\t\tval = atomic64_read(&st->comp_req_complete);\n\t\t\tavg_chunk = (val) ? atomic64_read(&st->comp_in_bytes) / val : 0;\n\n\t\t\tval = atomic64_read(&st->comp_out_bytes);\n\t\t\tavg_cr = (val) ? atomic64_read(&st->comp_in_bytes) / val : 0;\n\t\t\tseq_printf(s, \"        ZIP Device %d Stats\\n\"\n\t\t\t\t      \"-----------------------------------\\n\"\n\t\t\t\t      \"Comp Req Submitted        : \\t%lld\\n\"\n\t\t\t\t      \"Comp Req Completed        : \\t%lld\\n\"\n\t\t\t\t      \"Compress In Bytes         : \\t%lld\\n\"\n\t\t\t\t      \"Compressed Out Bytes      : \\t%lld\\n\"\n\t\t\t\t      \"Average Chunk size        : \\t%llu\\n\"\n\t\t\t\t      \"Average Compression ratio : \\t%llu\\n\"\n\t\t\t\t      \"Decomp Req Submitted      : \\t%lld\\n\"\n\t\t\t\t      \"Decomp Req Completed      : \\t%lld\\n\"\n\t\t\t\t      \"Decompress In Bytes       : \\t%lld\\n\"\n\t\t\t\t      \"Decompressed Out Bytes    : \\t%lld\\n\"\n\t\t\t\t      \"Decompress Bad requests   : \\t%lld\\n\"\n\t\t\t\t      \"Pending Req               : \\t%lld\\n\"\n\t\t\t\t\t\"---------------------------------\\n\",\n\t\t\t\t       index,\n\t\t\t\t       (u64)atomic64_read(&st->comp_req_submit),\n\t\t\t\t       (u64)atomic64_read(&st->comp_req_complete),\n\t\t\t\t       (u64)atomic64_read(&st->comp_in_bytes),\n\t\t\t\t       (u64)atomic64_read(&st->comp_out_bytes),\n\t\t\t\t       avg_chunk,\n\t\t\t\t       avg_cr,\n\t\t\t\t       (u64)atomic64_read(&st->decomp_req_submit),\n\t\t\t\t       (u64)atomic64_read(&st->decomp_req_complete),\n\t\t\t\t       (u64)atomic64_read(&st->decomp_in_bytes),\n\t\t\t\t       (u64)atomic64_read(&st->decomp_out_bytes),\n\t\t\t\t       (u64)atomic64_read(&st->decomp_bad_reqs),\n\t\t\t\t       pending);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int zip_clear_show(struct seq_file *s, void *unused)\n{\n\tint index = 0;\n\n\tfor (index = 0; index < MAX_ZIP_DEVICES; index++) {\n\t\tif (zip_dev[index]) {\n\t\t\tmemset(&zip_dev[index]->stats, 0,\n\t\t\t       sizeof(struct zip_stats));\n\t\t\tseq_printf(s, \"Cleared stats for zip %d\\n\", index);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct zip_registers zipregs[64] = {\n\t{\"ZIP_CMD_CTL        \",  0x0000ull},\n\t{\"ZIP_THROTTLE       \",  0x0010ull},\n\t{\"ZIP_CONSTANTS      \",  0x00A0ull},\n\t{\"ZIP_QUE0_MAP       \",  0x1400ull},\n\t{\"ZIP_QUE1_MAP       \",  0x1408ull},\n\t{\"ZIP_QUE_ENA        \",  0x0500ull},\n\t{\"ZIP_QUE_PRI        \",  0x0508ull},\n\t{\"ZIP_QUE0_DONE      \",  0x2000ull},\n\t{\"ZIP_QUE1_DONE      \",  0x2008ull},\n\t{\"ZIP_QUE0_DOORBELL  \",  0x4000ull},\n\t{\"ZIP_QUE1_DOORBELL  \",  0x4008ull},\n\t{\"ZIP_QUE0_SBUF_ADDR \",  0x1000ull},\n\t{\"ZIP_QUE1_SBUF_ADDR \",  0x1008ull},\n\t{\"ZIP_QUE0_SBUF_CTL  \",  0x1200ull},\n\t{\"ZIP_QUE1_SBUF_CTL  \",  0x1208ull},\n\t{ NULL, 0}\n};\n\n \nstatic int zip_regs_show(struct seq_file *s, void *unused)\n{\n\tu64 val = 0;\n\tint i = 0, index = 0;\n\n\tfor (index = 0; index < MAX_ZIP_DEVICES; index++) {\n\t\tif (zip_dev[index]) {\n\t\t\tseq_printf(s, \"--------------------------------\\n\"\n\t\t\t\t      \"     ZIP Device %d Registers\\n\"\n\t\t\t\t      \"--------------------------------\\n\",\n\t\t\t\t      index);\n\n\t\t\ti = 0;\n\n\t\t\twhile (zipregs[i].reg_name) {\n\t\t\t\tval = zip_reg_read((zip_dev[index]->reg_base +\n\t\t\t\t\t\t    zipregs[i].reg_offset));\n\t\t\t\tseq_printf(s, \"%s: 0x%016llx\\n\",\n\t\t\t\t\t   zipregs[i].reg_name, val);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(zip_stats);\nDEFINE_SHOW_ATTRIBUTE(zip_clear);\nDEFINE_SHOW_ATTRIBUTE(zip_regs);\n\n \nstatic struct dentry *zip_debugfs_root;\n\nstatic void zip_debugfs_init(void)\n{\n\tif (!debugfs_initialized())\n\t\treturn;\n\n\tzip_debugfs_root = debugfs_create_dir(\"thunderx_zip\", NULL);\n\n\t \n\tdebugfs_create_file(\"zip_stats\", 0444, zip_debugfs_root, NULL,\n\t\t\t    &zip_stats_fops);\n\n\tdebugfs_create_file(\"zip_clear\", 0444, zip_debugfs_root, NULL,\n\t\t\t    &zip_clear_fops);\n\n\tdebugfs_create_file(\"zip_regs\", 0444, zip_debugfs_root, NULL,\n\t\t\t    &zip_regs_fops);\n\n}\n\nstatic void zip_debugfs_exit(void)\n{\n\tdebugfs_remove_recursive(zip_debugfs_root);\n}\n\n#else\nstatic void __init zip_debugfs_init(void) { }\nstatic void __exit zip_debugfs_exit(void) { }\n#endif\n \n\nmodule_pci_driver(zip_driver);\n\nMODULE_AUTHOR(\"Cavium Inc\");\nMODULE_DESCRIPTION(\"Cavium Inc ThunderX ZIP Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(pci, zip_id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}