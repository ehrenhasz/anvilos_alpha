{
  "module_name": "zip_device.c",
  "hash_id": "d4d30dfe81b3ee5767febcaa5c91b0098960395321b1694a4ec1a6359cdab5ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/cavium/zip/zip_device.c",
  "human_readable_source": " \n\n#include \"common.h\"\n#include \"zip_deflate.h\"\n\n \nstatic inline u32 zip_cmd_queue_consumed(struct zip_device *zip_dev, int queue)\n{\n\treturn ((zip_dev->iq[queue].sw_head - zip_dev->iq[queue].sw_tail) *\n\t\tsizeof(u64 *));\n}\n\n \nu32 zip_load_instr(union zip_inst_s *instr,\n\t\t   struct zip_device *zip_dev)\n{\n\tunion zip_quex_doorbell dbell;\n\tu32 queue = 0;\n\tu32 consumed = 0;\n\tu64 *ncb_ptr = NULL;\n\tunion zip_nptr_s ncp;\n\n\t \n\tif (raw_smp_processor_id() % 2 == 0)\n\t\tqueue = 0;\n\telse\n\t\tqueue = 1;\n\n\tzip_dbg(\"CPU Core: %d Queue number:%d\", raw_smp_processor_id(), queue);\n\n\t \n\tspin_lock(&zip_dev->iq[queue].lock);\n\n\t \n\tzip_dbg(\"sw_head : %lx\", zip_dev->iq[queue].sw_head);\n\tzip_dbg(\"sw_tail : %lx\", zip_dev->iq[queue].sw_tail);\n\n\tconsumed = zip_cmd_queue_consumed(zip_dev, queue);\n\t \n\tif ((consumed + 128) == (ZIP_CMD_QBUF_SIZE - 8)) {\n\t\tzip_dbg(\"Cmd queue space available for single command\");\n\t\t \n\t\tmemcpy((u8 *)zip_dev->iq[queue].sw_head, (u8 *)instr,\n\t\t       sizeof(union zip_inst_s));\n\t\tzip_dev->iq[queue].sw_head += 16;  \n\n\t\t \n\t\tncb_ptr = zip_dev->iq[queue].sw_head;\n\n\t\tzip_dbg(\"ncb addr :0x%lx sw_head addr :0x%lx\",\n\t\t\tncb_ptr, zip_dev->iq[queue].sw_head - 16);\n\n\t\t \n\t\tzip_dev->iq[queue].sw_head = zip_dev->iq[queue].sw_tail;\n\t\t \n\t\tzip_dev->iq[queue].free_flag = 1;\n\n\t\t \n\t\tncp.u_reg64 = 0ull;\n\t\tncp.s.addr = __pa(zip_dev->iq[queue].sw_head);\n\t\t*ncb_ptr = ncp.u_reg64;\n\t\tzip_dbg(\"*ncb_ptr :0x%lx sw_head[phys] :0x%lx\",\n\t\t\t*ncb_ptr, __pa(zip_dev->iq[queue].sw_head));\n\n\t\tzip_dev->iq[queue].pend_cnt++;\n\n\t} else {\n\t\tzip_dbg(\"Enough space is available for commands\");\n\t\t \n\t\tmemcpy((u8 *)zip_dev->iq[queue].sw_head, (u8 *)instr,\n\t\t       sizeof(union zip_inst_s));\n\t\tzip_dev->iq[queue].sw_head += 16;  \n\n\t\tzip_dev->iq[queue].pend_cnt++;\n\t}\n\tzip_dbg(\"sw_head :0x%lx sw_tail :0x%lx hw_tail :0x%lx\",\n\t\tzip_dev->iq[queue].sw_head, zip_dev->iq[queue].sw_tail,\n\t\tzip_dev->iq[queue].hw_tail);\n\n\tzip_dbg(\" Pushed the new cmd : pend_cnt : %d\",\n\t\tzip_dev->iq[queue].pend_cnt);\n\n\t \n\tdbell.u_reg64     = 0ull;\n\tdbell.s.dbell_cnt = 1;\n\tzip_reg_write(dbell.u_reg64,\n\t\t      (zip_dev->reg_base + ZIP_QUEX_DOORBELL(queue)));\n\n\t \n\tspin_unlock(&zip_dev->iq[queue].lock);\n\n\treturn queue;\n}\n\n \nvoid zip_update_cmd_bufs(struct zip_device *zip_dev, u32 queue)\n{\n\t \n\tspin_lock(&zip_dev->iq[queue].lock);\n\n\t \n\tif (zip_dev->iq[queue].free_flag == 1) {\n\t\tzip_dbg(\"Free flag. Free cmd buffer, adjust sw head and tail\");\n\t\t \n\t\tzip_dev->iq[queue].free_flag = 0;\n\n\t\t \n\t\tzip_dev->iq[queue].hw_tail = zip_dev->iq[queue].sw_head;\n\t} else {\n\t\tzip_dbg(\"Free flag not set. increment hw tail\");\n\t\tzip_dev->iq[queue].hw_tail += 16;  \n\t}\n\n\tzip_dev->iq[queue].done_cnt++;\n\tzip_dev->iq[queue].pend_cnt--;\n\n\tzip_dbg(\"sw_head :0x%lx sw_tail :0x%lx hw_tail :0x%lx\",\n\t\tzip_dev->iq[queue].sw_head, zip_dev->iq[queue].sw_tail,\n\t\tzip_dev->iq[queue].hw_tail);\n\tzip_dbg(\" Got CC : pend_cnt : %d\\n\", zip_dev->iq[queue].pend_cnt);\n\n\tspin_unlock(&zip_dev->iq[queue].lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}