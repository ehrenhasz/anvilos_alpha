{
  "module_name": "zip_inflate.c",
  "hash_id": "d17511260aa7c7584d5883031fbf0f69e4288e71a3661c04e71e86d729be16c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/cavium/zip/zip_inflate.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/sched.h>\n\n#include \"common.h\"\n#include \"zip_inflate.h\"\n\nstatic int prepare_inflate_zcmd(struct zip_operation *zip_ops,\n\t\t\t\tstruct zip_state *s, union zip_inst_s *zip_cmd)\n{\n\tunion zip_zres_s *result_ptr = &s->result;\n\n\tmemset(zip_cmd, 0, sizeof(s->zip_cmd));\n\tmemset(result_ptr, 0, sizeof(s->result));\n\n\t \n\n\t \n\tzip_cmd->s.hg = 0;\n\t \n\tzip_cmd->s.ce = 0;\n\t \n\tzip_cmd->s.ss = 0;\n\t \n\tzip_cmd->s.sf = 1;\n\n\t \n\tif (zip_ops->begin_file == 0)\n\t\tzip_cmd->s.bf = 0;\n\telse\n\t\tzip_cmd->s.bf = 1;\n\n\tzip_cmd->s.ef = 1;\n\t \n\tzip_cmd->s.cc = zip_ops->ccode;\n\n\t \n\n\t \n\tzip_cmd->s.adlercrc32 = zip_ops->csum;\n\n\t \n\tzip_cmd->s.historylength = 0;\n\tzip_cmd->s.ds = 0;\n\n\t \n\tzip_cmd->s.out_ptr_addr.s.addr  = __pa(zip_ops->output);\n\tzip_cmd->s.out_ptr_ctl.s.length = zip_ops->output_len;\n\n\t \n\tzip_cmd->s.totaloutputlength    = zip_ops->output_len;\n\n\tzip_dbg(\"Data Direct Input case \");\n\n\t \n\tzip_cmd->s.dg = 0;\n\tzip_cmd->s.inp_ptr_addr.s.addr  = __pa((u8 *)zip_ops->input);\n\tzip_cmd->s.inp_ptr_ctl.s.length = zip_ops->input_len;\n\n\t \n\tzip_cmd->s.res_ptr_addr.s.addr = __pa(result_ptr);\n\n\t \n\tresult_ptr->s.compcode = 0;\n\n\t \n\treturn 0;\n}\n\n \nint zip_inflate(struct zip_operation *zip_ops, struct zip_state *s,\n\t\tstruct zip_device *zip_dev)\n{\n\tunion zip_inst_s *zip_cmd    = &s->zip_cmd;\n\tunion zip_zres_s  *result_ptr = &s->result;\n\tu32 queue;\n\n\t \n\tprepare_inflate_zcmd(zip_ops, s, zip_cmd);\n\n\tatomic64_add(zip_ops->input_len, &zip_dev->stats.decomp_in_bytes);\n\n\t \n\tqueue = zip_load_instr(zip_cmd, zip_dev);\n\n\t \n\tatomic64_inc(&zip_dev->stats.decomp_req_submit);\n\n\t \n\tzip_poll_result(result_ptr);\n\n\t \n\tatomic64_inc(&zip_dev->stats.decomp_req_complete);\n\n\tzip_ops->compcode = result_ptr->s.compcode;\n\tswitch (zip_ops->compcode) {\n\tcase ZIP_CMD_NOTDONE:\n\t\tzip_dbg(\"Zip Instruction not yet completed\\n\");\n\t\treturn ZIP_ERROR;\n\n\tcase ZIP_CMD_SUCCESS:\n\t\tzip_dbg(\"Zip Instruction completed successfully\\n\");\n\t\tbreak;\n\n\tcase ZIP_CMD_DYNAMIC_STOP:\n\t\tzip_dbg(\" Dynamic stop Initiated\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tzip_dbg(\"Instruction failed. Code = %d\\n\", zip_ops->compcode);\n\t\tatomic64_inc(&zip_dev->stats.decomp_bad_reqs);\n\t\tzip_update_cmd_bufs(zip_dev, queue);\n\t\treturn ZIP_ERROR;\n\t}\n\n\tzip_update_cmd_bufs(zip_dev, queue);\n\n\tif ((zip_ops->ccode == 3) && (zip_ops->flush == 4) &&\n\t    (zip_ops->compcode != ZIP_CMD_DYNAMIC_STOP))\n\t\tresult_ptr->s.ef = 1;\n\n\tzip_ops->csum = result_ptr->s.adler32;\n\n\tatomic64_add(result_ptr->s.totalbyteswritten,\n\t\t     &zip_dev->stats.decomp_out_bytes);\n\n\tif (zip_ops->output_len < result_ptr->s.totalbyteswritten) {\n\t\tzip_err(\"output_len (%d) < total bytes written (%d)\\n\",\n\t\t\tzip_ops->output_len, result_ptr->s.totalbyteswritten);\n\t\tzip_ops->output_len = 0;\n\t} else {\n\t\tzip_ops->output_len = result_ptr->s.totalbyteswritten;\n\t}\n\n\tzip_ops->bytes_read = result_ptr->s.totalbytesread;\n\tzip_ops->bits_processed = result_ptr->s.totalbitsprocessed;\n\tzip_ops->end_file = result_ptr->s.ef;\n\tif (zip_ops->end_file) {\n\t\tswitch (zip_ops->format) {\n\t\tcase RAW_FORMAT:\n\t\t\tzip_dbg(\"RAW Format: %d \", zip_ops->format);\n\t\t\t \n\t\t\tzip_ops->csum = result_ptr->s.adler32;\n\t\t\tbreak;\n\n\t\tcase ZLIB_FORMAT:\n\t\t\tzip_dbg(\"ZLIB Format: %d \", zip_ops->format);\n\t\t\tzip_ops->csum = result_ptr->s.adler32;\n\t\t\tbreak;\n\n\t\tcase GZIP_FORMAT:\n\t\t\tzip_dbg(\"GZIP Format: %d \", zip_ops->format);\n\t\t\tzip_ops->csum = result_ptr->s.crc32;\n\t\t\tbreak;\n\n\t\tcase LZS_FORMAT:\n\t\t\tzip_dbg(\"LZS Format: %d \", zip_ops->format);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tzip_err(\"Format error:%d\\n\", zip_ops->format);\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}