{
  "module_name": "zip_crypto.c",
  "hash_id": "4ca230baf4233b361b7669dc96299bcf5ab12d7a38abe91b9804356c6e27696f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/cavium/zip/zip_crypto.c",
  "human_readable_source": " \n\n#include \"zip_crypto.h\"\n\nstatic void zip_static_init_zip_ops(struct zip_operation *zip_ops,\n\t\t\t\t    int lzs_flag)\n{\n\tzip_ops->flush        = ZIP_FLUSH_FINISH;\n\n\t \n\tzip_ops->speed          = 1;\n\n\tif (!lzs_flag) {\n\t\tzip_ops->ccode\t\t= 0;  \n\t\tzip_ops->lzs_flag\t= 0;\n\t\tzip_ops->format\t\t= ZLIB_FORMAT;\n\t} else {\n\t\tzip_ops->ccode\t\t= 3;  \n\t\tzip_ops->lzs_flag\t= 1;\n\t\tzip_ops->format\t\t= LZS_FORMAT;\n\t}\n\tzip_ops->begin_file   = 1;\n\tzip_ops->history_len  = 0;\n\tzip_ops->end_file     = 1;\n\tzip_ops->compcode     = 0;\n\tzip_ops->csum\t      = 1;  \n}\n\nstatic int zip_ctx_init(struct zip_kernel_ctx *zip_ctx, int lzs_flag)\n{\n\tstruct zip_operation  *comp_ctx   = &zip_ctx->zip_comp;\n\tstruct zip_operation  *decomp_ctx = &zip_ctx->zip_decomp;\n\n\tzip_static_init_zip_ops(comp_ctx, lzs_flag);\n\tzip_static_init_zip_ops(decomp_ctx, lzs_flag);\n\n\tcomp_ctx->input  = zip_data_buf_alloc(MAX_INPUT_BUFFER_SIZE);\n\tif (!comp_ctx->input)\n\t\treturn -ENOMEM;\n\n\tcomp_ctx->output = zip_data_buf_alloc(MAX_OUTPUT_BUFFER_SIZE);\n\tif (!comp_ctx->output)\n\t\tgoto err_comp_input;\n\n\tdecomp_ctx->input  = zip_data_buf_alloc(MAX_INPUT_BUFFER_SIZE);\n\tif (!decomp_ctx->input)\n\t\tgoto err_comp_output;\n\n\tdecomp_ctx->output = zip_data_buf_alloc(MAX_OUTPUT_BUFFER_SIZE);\n\tif (!decomp_ctx->output)\n\t\tgoto err_decomp_input;\n\n\treturn 0;\n\nerr_decomp_input:\n\tzip_data_buf_free(decomp_ctx->input, MAX_INPUT_BUFFER_SIZE);\n\nerr_comp_output:\n\tzip_data_buf_free(comp_ctx->output, MAX_OUTPUT_BUFFER_SIZE);\n\nerr_comp_input:\n\tzip_data_buf_free(comp_ctx->input, MAX_INPUT_BUFFER_SIZE);\n\n\treturn -ENOMEM;\n}\n\nstatic void zip_ctx_exit(struct zip_kernel_ctx *zip_ctx)\n{\n\tstruct zip_operation  *comp_ctx   = &zip_ctx->zip_comp;\n\tstruct zip_operation  *dec_ctx = &zip_ctx->zip_decomp;\n\n\tzip_data_buf_free(comp_ctx->input, MAX_INPUT_BUFFER_SIZE);\n\tzip_data_buf_free(comp_ctx->output, MAX_OUTPUT_BUFFER_SIZE);\n\n\tzip_data_buf_free(dec_ctx->input, MAX_INPUT_BUFFER_SIZE);\n\tzip_data_buf_free(dec_ctx->output, MAX_OUTPUT_BUFFER_SIZE);\n}\n\nstatic int zip_compress(const u8 *src, unsigned int slen,\n\t\t u8 *dst, unsigned int *dlen,\n\t\t struct zip_kernel_ctx *zip_ctx)\n{\n\tstruct zip_operation  *zip_ops   = NULL;\n\tstruct zip_state      *zip_state;\n\tstruct zip_device     *zip = NULL;\n\tint ret;\n\n\tif (!zip_ctx || !src || !dst || !dlen)\n\t\treturn -ENOMEM;\n\n\tzip = zip_get_device(zip_get_node_id());\n\tif (!zip)\n\t\treturn -ENODEV;\n\n\tzip_state = kzalloc(sizeof(*zip_state), GFP_ATOMIC);\n\tif (!zip_state)\n\t\treturn -ENOMEM;\n\n\tzip_ops = &zip_ctx->zip_comp;\n\n\tzip_ops->input_len  = slen;\n\tzip_ops->output_len = *dlen;\n\tmemcpy(zip_ops->input, src, slen);\n\n\tret = zip_deflate(zip_ops, zip_state, zip);\n\n\tif (!ret) {\n\t\t*dlen = zip_ops->output_len;\n\t\tmemcpy(dst, zip_ops->output, *dlen);\n\t}\n\tkfree(zip_state);\n\treturn ret;\n}\n\nstatic int zip_decompress(const u8 *src, unsigned int slen,\n\t\t   u8 *dst, unsigned int *dlen,\n\t\t   struct zip_kernel_ctx *zip_ctx)\n{\n\tstruct zip_operation  *zip_ops   = NULL;\n\tstruct zip_state      *zip_state;\n\tstruct zip_device     *zip = NULL;\n\tint ret;\n\n\tif (!zip_ctx || !src || !dst || !dlen)\n\t\treturn -ENOMEM;\n\n\tzip = zip_get_device(zip_get_node_id());\n\tif (!zip)\n\t\treturn -ENODEV;\n\n\tzip_state = kzalloc(sizeof(*zip_state), GFP_ATOMIC);\n\tif (!zip_state)\n\t\treturn -ENOMEM;\n\n\tzip_ops = &zip_ctx->zip_decomp;\n\tmemcpy(zip_ops->input, src, slen);\n\n\t \n\tif (zip_ops->ccode != 3)  \n\t\tzip_ops->input[slen++] = 0;\n\n\tzip_ops->input_len  = slen;\n\tzip_ops->output_len = *dlen;\n\n\tret = zip_inflate(zip_ops, zip_state, zip);\n\n\tif (!ret) {\n\t\t*dlen = zip_ops->output_len;\n\t\tmemcpy(dst, zip_ops->output, *dlen);\n\t}\n\tkfree(zip_state);\n\treturn ret;\n}\n\n \nint zip_alloc_comp_ctx_deflate(struct crypto_tfm *tfm)\n{\n\tstruct zip_kernel_ctx *zip_ctx = crypto_tfm_ctx(tfm);\n\n\treturn zip_ctx_init(zip_ctx, 0);\n}\n\nint zip_alloc_comp_ctx_lzs(struct crypto_tfm *tfm)\n{\n\tstruct zip_kernel_ctx *zip_ctx = crypto_tfm_ctx(tfm);\n\n\treturn zip_ctx_init(zip_ctx, 1);\n}\n\nvoid zip_free_comp_ctx(struct crypto_tfm *tfm)\n{\n\tstruct zip_kernel_ctx *zip_ctx = crypto_tfm_ctx(tfm);\n\n\tzip_ctx_exit(zip_ctx);\n}\n\nint  zip_comp_compress(struct crypto_tfm *tfm,\n\t\t       const u8 *src, unsigned int slen,\n\t\t       u8 *dst, unsigned int *dlen)\n{\n\tstruct zip_kernel_ctx *zip_ctx = crypto_tfm_ctx(tfm);\n\n\treturn zip_compress(src, slen, dst, dlen, zip_ctx);\n}\n\nint  zip_comp_decompress(struct crypto_tfm *tfm,\n\t\t\t const u8 *src, unsigned int slen,\n\t\t\t u8 *dst, unsigned int *dlen)\n{\n\tstruct zip_kernel_ctx *zip_ctx = crypto_tfm_ctx(tfm);\n\n\treturn zip_decompress(src, slen, dst, dlen, zip_ctx);\n}  \n\n \nvoid *zip_alloc_scomp_ctx_deflate(struct crypto_scomp *tfm)\n{\n\tint ret;\n\tstruct zip_kernel_ctx *zip_ctx;\n\n\tzip_ctx = kzalloc(sizeof(*zip_ctx), GFP_KERNEL);\n\tif (!zip_ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = zip_ctx_init(zip_ctx, 0);\n\n\tif (ret) {\n\t\tkfree_sensitive(zip_ctx);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn zip_ctx;\n}\n\nvoid *zip_alloc_scomp_ctx_lzs(struct crypto_scomp *tfm)\n{\n\tint ret;\n\tstruct zip_kernel_ctx *zip_ctx;\n\n\tzip_ctx = kzalloc(sizeof(*zip_ctx), GFP_KERNEL);\n\tif (!zip_ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = zip_ctx_init(zip_ctx, 1);\n\n\tif (ret) {\n\t\tkfree_sensitive(zip_ctx);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn zip_ctx;\n}\n\nvoid zip_free_scomp_ctx(struct crypto_scomp *tfm, void *ctx)\n{\n\tstruct zip_kernel_ctx *zip_ctx = ctx;\n\n\tzip_ctx_exit(zip_ctx);\n\tkfree_sensitive(zip_ctx);\n}\n\nint zip_scomp_compress(struct crypto_scomp *tfm,\n\t\t       const u8 *src, unsigned int slen,\n\t\t       u8 *dst, unsigned int *dlen, void *ctx)\n{\n\tstruct zip_kernel_ctx *zip_ctx  = ctx;\n\n\treturn zip_compress(src, slen, dst, dlen, zip_ctx);\n}\n\nint zip_scomp_decompress(struct crypto_scomp *tfm,\n\t\t\t const u8 *src, unsigned int slen,\n\t\t\t u8 *dst, unsigned int *dlen, void *ctx)\n{\n\tstruct zip_kernel_ctx *zip_ctx = ctx;\n\n\treturn zip_decompress(src, slen, dst, dlen, zip_ctx);\n}  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}