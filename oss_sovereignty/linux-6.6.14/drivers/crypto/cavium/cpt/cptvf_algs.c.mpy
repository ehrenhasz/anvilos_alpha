{
  "module_name": "cptvf_algs.c",
  "hash_id": "08b7e7f515659f5eefee286133a340cadf140532bd5a691600b8a1cf69bcee83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/cavium/cpt/cptvf_algs.c",
  "human_readable_source": "\n\n \n\n#include <crypto/aes.h>\n#include <crypto/algapi.h>\n#include <crypto/authenc.h>\n#include <crypto/internal/des.h>\n#include <crypto/xts.h>\n#include <linux/crypto.h>\n#include <linux/err.h>\n#include <linux/list.h>\n#include <linux/scatterlist.h>\n\n#include \"cptvf.h\"\n#include \"cptvf_algs.h\"\n\nstruct cpt_device_handle {\n\tvoid *cdev[MAX_DEVICES];\n\tu32 dev_count;\n};\n\nstatic struct cpt_device_handle dev_handle;\n\nstatic void cvm_callback(u32 status, void *arg)\n{\n\tstruct crypto_async_request *req = (struct crypto_async_request *)arg;\n\n\tcrypto_request_complete(req, !status);\n}\n\nstatic inline void update_input_iv(struct cpt_request_info *req_info,\n\t\t\t\t   u8 *iv, u32 enc_iv_len,\n\t\t\t\t   u32 *argcnt)\n{\n\t \n\treq_info->in[*argcnt].vptr = (void *)iv;\n\treq_info->in[*argcnt].size = enc_iv_len;\n\treq_info->req.dlen += enc_iv_len;\n\n\t++(*argcnt);\n}\n\nstatic inline void update_output_iv(struct cpt_request_info *req_info,\n\t\t\t\t    u8 *iv, u32 enc_iv_len,\n\t\t\t\t    u32 *argcnt)\n{\n\t \n\treq_info->out[*argcnt].vptr = (void *)iv;\n\treq_info->out[*argcnt].size = enc_iv_len;\n\treq_info->rlen += enc_iv_len;\n\n\t++(*argcnt);\n}\n\nstatic inline void update_input_data(struct cpt_request_info *req_info,\n\t\t\t\t     struct scatterlist *inp_sg,\n\t\t\t\t     u32 nbytes, u32 *argcnt)\n{\n\treq_info->req.dlen += nbytes;\n\n\twhile (nbytes) {\n\t\tu32 len = min(nbytes, inp_sg->length);\n\t\tu8 *ptr = sg_virt(inp_sg);\n\n\t\treq_info->in[*argcnt].vptr = (void *)ptr;\n\t\treq_info->in[*argcnt].size = len;\n\t\tnbytes -= len;\n\n\t\t++(*argcnt);\n\t\t++inp_sg;\n\t}\n}\n\nstatic inline void update_output_data(struct cpt_request_info *req_info,\n\t\t\t\t      struct scatterlist *outp_sg,\n\t\t\t\t      u32 nbytes, u32 *argcnt)\n{\n\treq_info->rlen += nbytes;\n\n\twhile (nbytes) {\n\t\tu32 len = min(nbytes, outp_sg->length);\n\t\tu8 *ptr = sg_virt(outp_sg);\n\n\t\treq_info->out[*argcnt].vptr = (void *)ptr;\n\t\treq_info->out[*argcnt].size = len;\n\t\tnbytes -= len;\n\t\t++(*argcnt);\n\t\t++outp_sg;\n\t}\n}\n\nstatic inline u32 create_ctx_hdr(struct skcipher_request *req, u32 enc,\n\t\t\t\t u32 *argcnt)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct cvm_enc_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct cvm_req_ctx *rctx = skcipher_request_ctx_dma(req);\n\tstruct fc_context *fctx = &rctx->fctx;\n\tu32 enc_iv_len = crypto_skcipher_ivsize(tfm);\n\tstruct cpt_request_info *req_info = &rctx->cpt_req;\n\t__be64 *ctrl_flags = NULL;\n\t__be64 *offset_control;\n\n\treq_info->ctrl.s.grp = 0;\n\treq_info->ctrl.s.dma_mode = DMA_GATHER_SCATTER;\n\treq_info->ctrl.s.se_req = SE_CORE_REQ;\n\n\treq_info->req.opcode.s.major = MAJOR_OP_FC |\n\t\t\t\t\tDMA_MODE_FLAG(DMA_GATHER_SCATTER);\n\tif (enc)\n\t\treq_info->req.opcode.s.minor = 2;\n\telse\n\t\treq_info->req.opcode.s.minor = 3;\n\n\treq_info->req.param1 = req->cryptlen;  \n\treq_info->req.param2 = 0;  \n\n\tfctx->enc.enc_ctrl.e.enc_cipher = ctx->cipher_type;\n\tfctx->enc.enc_ctrl.e.aes_key = ctx->key_type;\n\tfctx->enc.enc_ctrl.e.iv_source = FROM_DPTR;\n\n\tif (ctx->cipher_type == AES_XTS)\n\t\tmemcpy(fctx->enc.encr_key, ctx->enc_key, ctx->key_len * 2);\n\telse\n\t\tmemcpy(fctx->enc.encr_key, ctx->enc_key, ctx->key_len);\n\tctrl_flags = (__be64 *)&fctx->enc.enc_ctrl.flags;\n\t*ctrl_flags = cpu_to_be64(fctx->enc.enc_ctrl.flags);\n\n\toffset_control = (__be64 *)&rctx->control_word;\n\t*offset_control = cpu_to_be64(((u64)(enc_iv_len) << 16));\n\t \n\treq_info->in[*argcnt].vptr = (u8 *)offset_control;\n\treq_info->in[*argcnt].size = CONTROL_WORD_LEN;\n\treq_info->req.dlen += CONTROL_WORD_LEN;\n\t++(*argcnt);\n\n\treq_info->in[*argcnt].vptr = (u8 *)fctx;\n\treq_info->in[*argcnt].size = sizeof(struct fc_context);\n\treq_info->req.dlen += sizeof(struct fc_context);\n\n\t++(*argcnt);\n\n\treturn 0;\n}\n\nstatic inline u32 create_input_list(struct skcipher_request  *req, u32 enc,\n\t\t\t\t    u32 enc_iv_len)\n{\n\tstruct cvm_req_ctx *rctx = skcipher_request_ctx_dma(req);\n\tstruct cpt_request_info *req_info = &rctx->cpt_req;\n\tu32 argcnt =  0;\n\n\tcreate_ctx_hdr(req, enc, &argcnt);\n\tupdate_input_iv(req_info, req->iv, enc_iv_len, &argcnt);\n\tupdate_input_data(req_info, req->src, req->cryptlen, &argcnt);\n\treq_info->incnt = argcnt;\n\n\treturn 0;\n}\n\nstatic inline void store_cb_info(struct skcipher_request *req,\n\t\t\t\t struct cpt_request_info *req_info)\n{\n\treq_info->callback = (void *)cvm_callback;\n\treq_info->callback_arg = (void *)&req->base;\n}\n\nstatic inline void create_output_list(struct skcipher_request *req,\n\t\t\t\t      u32 enc_iv_len)\n{\n\tstruct cvm_req_ctx *rctx = skcipher_request_ctx_dma(req);\n\tstruct cpt_request_info *req_info = &rctx->cpt_req;\n\tu32 argcnt = 0;\n\n\t \n\t \n\tupdate_output_iv(req_info, req->iv, enc_iv_len, &argcnt);\n\tupdate_output_data(req_info, req->dst, req->cryptlen, &argcnt);\n\treq_info->outcnt = argcnt;\n}\n\nstatic inline int cvm_enc_dec(struct skcipher_request *req, u32 enc)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct cvm_req_ctx *rctx = skcipher_request_ctx_dma(req);\n\tu32 enc_iv_len = crypto_skcipher_ivsize(tfm);\n\tstruct fc_context *fctx = &rctx->fctx;\n\tstruct cpt_request_info *req_info = &rctx->cpt_req;\n\tvoid *cdev = NULL;\n\tint status;\n\n\tmemset(req_info, 0, sizeof(struct cpt_request_info));\n\treq_info->may_sleep = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) != 0;\n\tmemset(fctx, 0, sizeof(struct fc_context));\n\tcreate_input_list(req, enc, enc_iv_len);\n\tcreate_output_list(req, enc_iv_len);\n\tstore_cb_info(req, req_info);\n\tcdev = dev_handle.cdev[smp_processor_id()];\n\tstatus = cptvf_do_request(cdev, req_info);\n\t \n\n\tif (status)\n\t\treturn status;\n\telse\n\t\treturn -EINPROGRESS;\n}\n\nstatic int cvm_encrypt(struct skcipher_request *req)\n{\n\treturn cvm_enc_dec(req, true);\n}\n\nstatic int cvm_decrypt(struct skcipher_request *req)\n{\n\treturn cvm_enc_dec(req, false);\n}\n\nstatic int cvm_xts_setkey(struct crypto_skcipher *cipher, const u8 *key,\n\t\t   u32 keylen)\n{\n\tstruct cvm_enc_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tint err;\n\tconst u8 *key1 = key;\n\tconst u8 *key2 = key + (keylen / 2);\n\n\terr = xts_verify_key(cipher, key, keylen);\n\tif (err)\n\t\treturn err;\n\tctx->key_len = keylen;\n\tmemcpy(ctx->enc_key, key1, keylen / 2);\n\tmemcpy(ctx->enc_key + KEY2_OFFSET, key2, keylen / 2);\n\tctx->cipher_type = AES_XTS;\n\tswitch (ctx->key_len) {\n\tcase 32:\n\t\tctx->key_type = AES_128_BIT;\n\t\tbreak;\n\tcase 64:\n\t\tctx->key_type = AES_256_BIT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cvm_validate_keylen(struct cvm_enc_ctx *ctx, u32 keylen)\n{\n\tif ((keylen == 16) || (keylen == 24) || (keylen == 32)) {\n\t\tctx->key_len = keylen;\n\t\tswitch (ctx->key_len) {\n\t\tcase 16:\n\t\t\tctx->key_type = AES_128_BIT;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tctx->key_type = AES_192_BIT;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tctx->key_type = AES_256_BIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ctx->cipher_type == DES3_CBC)\n\t\t\tctx->key_type = 0;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int cvm_setkey(struct crypto_skcipher *cipher, const u8 *key,\n\t\t      u32 keylen, u8 cipher_type)\n{\n\tstruct cvm_enc_ctx *ctx = crypto_skcipher_ctx(cipher);\n\n\tctx->cipher_type = cipher_type;\n\tif (!cvm_validate_keylen(ctx, keylen)) {\n\t\tmemcpy(ctx->enc_key, key, keylen);\n\t\treturn 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int cvm_cbc_aes_setkey(struct crypto_skcipher *cipher, const u8 *key,\n\t\t\t      u32 keylen)\n{\n\treturn cvm_setkey(cipher, key, keylen, AES_CBC);\n}\n\nstatic int cvm_ecb_aes_setkey(struct crypto_skcipher *cipher, const u8 *key,\n\t\t\t      u32 keylen)\n{\n\treturn cvm_setkey(cipher, key, keylen, AES_ECB);\n}\n\nstatic int cvm_cfb_aes_setkey(struct crypto_skcipher *cipher, const u8 *key,\n\t\t\t      u32 keylen)\n{\n\treturn cvm_setkey(cipher, key, keylen, AES_CFB);\n}\n\nstatic int cvm_cbc_des3_setkey(struct crypto_skcipher *cipher, const u8 *key,\n\t\t\t       u32 keylen)\n{\n\treturn verify_skcipher_des3_key(cipher, key) ?:\n\t       cvm_setkey(cipher, key, keylen, DES3_CBC);\n}\n\nstatic int cvm_ecb_des3_setkey(struct crypto_skcipher *cipher, const u8 *key,\n\t\t\t       u32 keylen)\n{\n\treturn verify_skcipher_des3_key(cipher, key) ?:\n\t       cvm_setkey(cipher, key, keylen, DES3_ECB);\n}\n\nstatic int cvm_enc_dec_init(struct crypto_skcipher *tfm)\n{\n\tcrypto_skcipher_set_reqsize_dma(tfm, sizeof(struct cvm_req_ctx));\n\n\treturn 0;\n}\n\nstatic struct skcipher_alg algs[] = { {\n\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t.base.cra_ctxsize\t= sizeof(struct cvm_enc_ctx),\n\t.base.cra_alignmask\t= 7,\n\t.base.cra_priority\t= 4001,\n\t.base.cra_name\t\t= \"xts(aes)\",\n\t.base.cra_driver_name\t= \"cavium-xts-aes\",\n\t.base.cra_module\t= THIS_MODULE,\n\n\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t.min_keysize\t\t= 2 * AES_MIN_KEY_SIZE,\n\t.max_keysize\t\t= 2 * AES_MAX_KEY_SIZE,\n\t.setkey\t\t\t= cvm_xts_setkey,\n\t.encrypt\t\t= cvm_encrypt,\n\t.decrypt\t\t= cvm_decrypt,\n\t.init\t\t\t= cvm_enc_dec_init,\n}, {\n\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t.base.cra_ctxsize\t= sizeof(struct cvm_enc_ctx),\n\t.base.cra_alignmask\t= 7,\n\t.base.cra_priority\t= 4001,\n\t.base.cra_name\t\t= \"cbc(aes)\",\n\t.base.cra_driver_name\t= \"cavium-cbc-aes\",\n\t.base.cra_module\t= THIS_MODULE,\n\n\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t.setkey\t\t\t= cvm_cbc_aes_setkey,\n\t.encrypt\t\t= cvm_encrypt,\n\t.decrypt\t\t= cvm_decrypt,\n\t.init\t\t\t= cvm_enc_dec_init,\n}, {\n\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t.base.cra_ctxsize\t= sizeof(struct cvm_enc_ctx),\n\t.base.cra_alignmask\t= 7,\n\t.base.cra_priority\t= 4001,\n\t.base.cra_name\t\t= \"ecb(aes)\",\n\t.base.cra_driver_name\t= \"cavium-ecb-aes\",\n\t.base.cra_module\t= THIS_MODULE,\n\n\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t.setkey\t\t\t= cvm_ecb_aes_setkey,\n\t.encrypt\t\t= cvm_encrypt,\n\t.decrypt\t\t= cvm_decrypt,\n\t.init\t\t\t= cvm_enc_dec_init,\n}, {\n\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t.base.cra_ctxsize\t= sizeof(struct cvm_enc_ctx),\n\t.base.cra_alignmask\t= 7,\n\t.base.cra_priority\t= 4001,\n\t.base.cra_name\t\t= \"cfb(aes)\",\n\t.base.cra_driver_name\t= \"cavium-cfb-aes\",\n\t.base.cra_module\t= THIS_MODULE,\n\n\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t.setkey\t\t\t= cvm_cfb_aes_setkey,\n\t.encrypt\t\t= cvm_encrypt,\n\t.decrypt\t\t= cvm_decrypt,\n\t.init\t\t\t= cvm_enc_dec_init,\n}, {\n\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t.base.cra_blocksize\t= DES3_EDE_BLOCK_SIZE,\n\t.base.cra_ctxsize\t= sizeof(struct cvm_des3_ctx),\n\t.base.cra_alignmask\t= 7,\n\t.base.cra_priority\t= 4001,\n\t.base.cra_name\t\t= \"cbc(des3_ede)\",\n\t.base.cra_driver_name\t= \"cavium-cbc-des3_ede\",\n\t.base.cra_module\t= THIS_MODULE,\n\n\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t.setkey\t\t\t= cvm_cbc_des3_setkey,\n\t.encrypt\t\t= cvm_encrypt,\n\t.decrypt\t\t= cvm_decrypt,\n\t.init\t\t\t= cvm_enc_dec_init,\n}, {\n\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t.base.cra_blocksize\t= DES3_EDE_BLOCK_SIZE,\n\t.base.cra_ctxsize\t= sizeof(struct cvm_des3_ctx),\n\t.base.cra_alignmask\t= 7,\n\t.base.cra_priority\t= 4001,\n\t.base.cra_name\t\t= \"ecb(des3_ede)\",\n\t.base.cra_driver_name\t= \"cavium-ecb-des3_ede\",\n\t.base.cra_module\t= THIS_MODULE,\n\n\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t.setkey\t\t\t= cvm_ecb_des3_setkey,\n\t.encrypt\t\t= cvm_encrypt,\n\t.decrypt\t\t= cvm_decrypt,\n\t.init\t\t\t= cvm_enc_dec_init,\n} };\n\nstatic inline int cav_register_algs(void)\n{\n\treturn crypto_register_skciphers(algs, ARRAY_SIZE(algs));\n}\n\nstatic inline void cav_unregister_algs(void)\n{\n\tcrypto_unregister_skciphers(algs, ARRAY_SIZE(algs));\n}\n\nint cvm_crypto_init(struct cpt_vf *cptvf)\n{\n\tstruct pci_dev *pdev = cptvf->pdev;\n\tu32 dev_count;\n\n\tdev_count = dev_handle.dev_count;\n\tdev_handle.cdev[dev_count] = cptvf;\n\tdev_handle.dev_count++;\n\n\tif (dev_count == 3) {\n\t\tif (cav_register_algs()) {\n\t\t\tdev_err(&pdev->dev, \"Error in registering crypto algorithms\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid cvm_crypto_exit(void)\n{\n\tu32 dev_count;\n\n\tdev_count = --dev_handle.dev_count;\n\tif (!dev_count)\n\t\tcav_unregister_algs();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}