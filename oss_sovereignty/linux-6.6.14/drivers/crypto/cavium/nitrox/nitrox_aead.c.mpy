{
  "module_name": "nitrox_aead.c",
  "hash_id": "b86a5c5118a0440b8d305f943131f9d59b70d435eb8046f4f99c4345d166dcb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/cavium/nitrox/nitrox_aead.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/printk.h>\n#include <linux/crypto.h>\n#include <linux/rtnetlink.h>\n\n#include <crypto/aead.h>\n#include <crypto/authenc.h>\n#include <crypto/des.h>\n#include <crypto/internal/aead.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/gcm.h>\n\n#include \"nitrox_dev.h\"\n#include \"nitrox_common.h\"\n#include \"nitrox_req.h\"\n\n#define GCM_AES_SALT_SIZE\t4\n\nunion gph_p3 {\n\tstruct {\n#ifdef __BIG_ENDIAN_BITFIELD\n\t\tu16 iv_offset : 8;\n\t\tu16 auth_offset\t: 8;\n#else\n\t\tu16 auth_offset\t: 8;\n\t\tu16 iv_offset : 8;\n#endif\n\t};\n\tu16 param;\n};\n\nstatic int nitrox_aes_gcm_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\tint aes_keylen;\n\tstruct nitrox_crypto_ctx *nctx = crypto_aead_ctx(aead);\n\tstruct flexi_crypto_context *fctx;\n\tunion fc_ctx_flags flags;\n\n\taes_keylen = flexi_aes_keylen(keylen);\n\tif (aes_keylen < 0)\n\t\treturn -EINVAL;\n\n\t \n\tfctx = nctx->u.fctx;\n\tflags.fu = be64_to_cpu(fctx->flags.f);\n\tflags.w0.aes_keylen = aes_keylen;\n\tfctx->flags.f = cpu_to_be64(flags.fu);\n\n\t \n\tmemset(&fctx->crypto, 0, sizeof(fctx->crypto));\n\tmemcpy(fctx->crypto.u.key, key, keylen);\n\n\treturn 0;\n}\n\nstatic int nitrox_aead_setauthsize(struct crypto_aead *aead,\n\t\t\t\t   unsigned int authsize)\n{\n\tstruct nitrox_crypto_ctx *nctx = crypto_aead_ctx(aead);\n\tstruct flexi_crypto_context *fctx = nctx->u.fctx;\n\tunion fc_ctx_flags flags;\n\n\tflags.fu = be64_to_cpu(fctx->flags.f);\n\tflags.w0.mac_len = authsize;\n\tfctx->flags.f = cpu_to_be64(flags.fu);\n\n\taead->authsize = authsize;\n\n\treturn 0;\n}\n\nstatic int nitrox_aes_gcm_setauthsize(struct crypto_aead *aead,\n\t\t\t\t      unsigned int authsize)\n{\n\tswitch (authsize) {\n\tcase 4:\n\tcase 8:\n\tcase 12:\n\tcase 13:\n\tcase 14:\n\tcase 15:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn nitrox_aead_setauthsize(aead, authsize);\n}\n\nstatic int alloc_src_sglist(struct nitrox_kcrypt_request *nkreq,\n\t\t\t    struct scatterlist *src, char *iv, int ivsize,\n\t\t\t    int buflen)\n{\n\tint nents = sg_nents_for_len(src, buflen);\n\tint ret;\n\n\tif (nents < 0)\n\t\treturn nents;\n\n\t \n\tnents += 1;\n\t \n\tret = alloc_src_req_buf(nkreq, nents, ivsize);\n\tif (ret)\n\t\treturn ret;\n\n\tnitrox_creq_copy_iv(nkreq->src, iv, ivsize);\n\tnitrox_creq_set_src_sg(nkreq, nents, ivsize, src, buflen);\n\n\treturn 0;\n}\n\nstatic int alloc_dst_sglist(struct nitrox_kcrypt_request *nkreq,\n\t\t\t    struct scatterlist *dst, int ivsize, int buflen)\n{\n\tint nents = sg_nents_for_len(dst, buflen);\n\tint ret;\n\n\tif (nents < 0)\n\t\treturn nents;\n\n\t \n\tnents += 3;\n\t \n\tret = alloc_dst_req_buf(nkreq, nents);\n\tif (ret)\n\t\treturn ret;\n\n\tnitrox_creq_set_orh(nkreq);\n\tnitrox_creq_set_comp(nkreq);\n\tnitrox_creq_set_dst_sg(nkreq, nents, ivsize, dst, buflen);\n\n\treturn 0;\n}\n\nstatic void free_src_sglist(struct nitrox_kcrypt_request *nkreq)\n{\n\tkfree(nkreq->src);\n}\n\nstatic void free_dst_sglist(struct nitrox_kcrypt_request *nkreq)\n{\n\tkfree(nkreq->dst);\n}\n\nstatic int nitrox_set_creq(struct nitrox_aead_rctx *rctx)\n{\n\tstruct se_crypto_request *creq = &rctx->nkreq.creq;\n\tunion gph_p3 param3;\n\tint ret;\n\n\tcreq->flags = rctx->flags;\n\tcreq->gfp = (rctx->flags & CRYPTO_TFM_REQ_MAY_SLEEP) ? GFP_KERNEL :\n\t\t\t\t\t\t\t       GFP_ATOMIC;\n\n\tcreq->ctrl.value = 0;\n\tcreq->opcode = FLEXI_CRYPTO_ENCRYPT_HMAC;\n\tcreq->ctrl.s.arg = rctx->ctrl_arg;\n\n\tcreq->gph.param0 = cpu_to_be16(rctx->cryptlen);\n\tcreq->gph.param1 = cpu_to_be16(rctx->cryptlen + rctx->assoclen);\n\tcreq->gph.param2 = cpu_to_be16(rctx->ivsize + rctx->assoclen);\n\tparam3.iv_offset = 0;\n\tparam3.auth_offset = rctx->ivsize;\n\tcreq->gph.param3 = cpu_to_be16(param3.param);\n\n\tcreq->ctx_handle = rctx->ctx_handle;\n\tcreq->ctrl.s.ctxl = sizeof(struct flexi_crypto_context);\n\n\tret = alloc_src_sglist(&rctx->nkreq, rctx->src, rctx->iv, rctx->ivsize,\n\t\t\t       rctx->srclen);\n\tif (ret)\n\t\treturn ret;\n\n\tret = alloc_dst_sglist(&rctx->nkreq, rctx->dst, rctx->ivsize,\n\t\t\t       rctx->dstlen);\n\tif (ret) {\n\t\tfree_src_sglist(&rctx->nkreq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void nitrox_aead_callback(void *arg, int err)\n{\n\tstruct aead_request *areq = arg;\n\tstruct nitrox_aead_rctx *rctx = aead_request_ctx(areq);\n\n\tfree_src_sglist(&rctx->nkreq);\n\tfree_dst_sglist(&rctx->nkreq);\n\tif (err) {\n\t\tpr_err_ratelimited(\"request failed status 0x%0x\\n\", err);\n\t\terr = -EINVAL;\n\t}\n\n\taead_request_complete(areq, err);\n}\n\nstatic inline bool nitrox_aes_gcm_assoclen_supported(unsigned int assoclen)\n{\n\tif (assoclen <= 512)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int nitrox_aes_gcm_enc(struct aead_request *areq)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(areq);\n\tstruct nitrox_crypto_ctx *nctx = crypto_aead_ctx(aead);\n\tstruct nitrox_aead_rctx *rctx = aead_request_ctx(areq);\n\tstruct se_crypto_request *creq = &rctx->nkreq.creq;\n\tstruct flexi_crypto_context *fctx = nctx->u.fctx;\n\tint ret;\n\n\tif (!nitrox_aes_gcm_assoclen_supported(areq->assoclen))\n\t\treturn -EINVAL;\n\n\tmemcpy(fctx->crypto.iv, areq->iv, GCM_AES_SALT_SIZE);\n\n\trctx->cryptlen = areq->cryptlen;\n\trctx->assoclen = areq->assoclen;\n\trctx->srclen = areq->assoclen + areq->cryptlen;\n\trctx->dstlen = rctx->srclen + aead->authsize;\n\trctx->iv = &areq->iv[GCM_AES_SALT_SIZE];\n\trctx->ivsize = GCM_AES_IV_SIZE - GCM_AES_SALT_SIZE;\n\trctx->flags = areq->base.flags;\n\trctx->ctx_handle = nctx->u.ctx_handle;\n\trctx->src = areq->src;\n\trctx->dst = areq->dst;\n\trctx->ctrl_arg = ENCRYPT;\n\tret = nitrox_set_creq(rctx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn nitrox_process_se_request(nctx->ndev, creq, nitrox_aead_callback,\n\t\t\t\t\t areq);\n}\n\nstatic int nitrox_aes_gcm_dec(struct aead_request *areq)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(areq);\n\tstruct nitrox_crypto_ctx *nctx = crypto_aead_ctx(aead);\n\tstruct nitrox_aead_rctx *rctx = aead_request_ctx(areq);\n\tstruct se_crypto_request *creq = &rctx->nkreq.creq;\n\tstruct flexi_crypto_context *fctx = nctx->u.fctx;\n\tint ret;\n\n\tif (!nitrox_aes_gcm_assoclen_supported(areq->assoclen))\n\t\treturn -EINVAL;\n\n\tmemcpy(fctx->crypto.iv, areq->iv, GCM_AES_SALT_SIZE);\n\n\trctx->cryptlen = areq->cryptlen - aead->authsize;\n\trctx->assoclen = areq->assoclen;\n\trctx->srclen = areq->cryptlen + areq->assoclen;\n\trctx->dstlen = rctx->srclen - aead->authsize;\n\trctx->iv = &areq->iv[GCM_AES_SALT_SIZE];\n\trctx->ivsize = GCM_AES_IV_SIZE - GCM_AES_SALT_SIZE;\n\trctx->flags = areq->base.flags;\n\trctx->ctx_handle = nctx->u.ctx_handle;\n\trctx->src = areq->src;\n\trctx->dst = areq->dst;\n\trctx->ctrl_arg = DECRYPT;\n\tret = nitrox_set_creq(rctx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn nitrox_process_se_request(nctx->ndev, creq, nitrox_aead_callback,\n\t\t\t\t\t areq);\n}\n\nstatic int nitrox_aead_init(struct crypto_aead *aead)\n{\n\tstruct nitrox_crypto_ctx *nctx = crypto_aead_ctx(aead);\n\tstruct crypto_ctx_hdr *chdr;\n\n\t \n\tnctx->ndev = nitrox_get_first_device();\n\tif (!nctx->ndev)\n\t\treturn -ENODEV;\n\n\t \n\tchdr = crypto_alloc_context(nctx->ndev);\n\tif (!chdr) {\n\t\tnitrox_put_device(nctx->ndev);\n\t\treturn -ENOMEM;\n\t}\n\tnctx->chdr = chdr;\n\tnctx->u.ctx_handle = (uintptr_t)((u8 *)chdr->vaddr +\n\t\t\t\t\t sizeof(struct ctx_hdr));\n\tnctx->u.fctx->flags.f = 0;\n\n\treturn 0;\n}\n\nstatic int nitrox_gcm_common_init(struct crypto_aead *aead)\n{\n\tint ret;\n\tstruct nitrox_crypto_ctx *nctx = crypto_aead_ctx(aead);\n\tunion fc_ctx_flags *flags;\n\n\tret = nitrox_aead_init(aead);\n\tif (ret)\n\t\treturn ret;\n\n\tflags = &nctx->u.fctx->flags;\n\tflags->w0.cipher_type = CIPHER_AES_GCM;\n\tflags->w0.hash_type = AUTH_NULL;\n\tflags->w0.iv_source = IV_FROM_DPTR;\n\t \n\tflags->w0.auth_input_type = 1;\n\tflags->f = cpu_to_be64(flags->fu);\n\n\treturn 0;\n}\n\nstatic int nitrox_aes_gcm_init(struct crypto_aead *aead)\n{\n\tint ret;\n\n\tret = nitrox_gcm_common_init(aead);\n\tif (ret)\n\t\treturn ret;\n\n\tcrypto_aead_set_reqsize(aead,\n\t\t\t\tsizeof(struct aead_request) +\n\t\t\t\t\tsizeof(struct nitrox_aead_rctx));\n\n\treturn 0;\n}\n\nstatic void nitrox_aead_exit(struct crypto_aead *aead)\n{\n\tstruct nitrox_crypto_ctx *nctx = crypto_aead_ctx(aead);\n\n\t \n\tif (nctx->u.ctx_handle) {\n\t\tstruct flexi_crypto_context *fctx = nctx->u.fctx;\n\n\t\tmemzero_explicit(&fctx->crypto, sizeof(struct crypto_keys));\n\t\tmemzero_explicit(&fctx->auth, sizeof(struct auth_keys));\n\t\tcrypto_free_context((void *)nctx->chdr);\n\t}\n\tnitrox_put_device(nctx->ndev);\n\n\tnctx->u.ctx_handle = 0;\n\tnctx->ndev = NULL;\n}\n\nstatic int nitrox_rfc4106_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\tstruct nitrox_crypto_ctx *nctx = crypto_aead_ctx(aead);\n\tstruct flexi_crypto_context *fctx = nctx->u.fctx;\n\tint ret;\n\n\tif (keylen < GCM_AES_SALT_SIZE)\n\t\treturn -EINVAL;\n\n\tkeylen -= GCM_AES_SALT_SIZE;\n\tret = nitrox_aes_gcm_setkey(aead, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(fctx->crypto.iv, key + keylen, GCM_AES_SALT_SIZE);\n\treturn 0;\n}\n\nstatic int nitrox_rfc4106_setauthsize(struct crypto_aead *aead,\n\t\t\t\t      unsigned int authsize)\n{\n\tswitch (authsize) {\n\tcase 8:\n\tcase 12:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn nitrox_aead_setauthsize(aead, authsize);\n}\n\nstatic int nitrox_rfc4106_set_aead_rctx_sglist(struct aead_request *areq)\n{\n\tstruct nitrox_rfc4106_rctx *rctx = aead_request_ctx_dma(areq);\n\tstruct nitrox_aead_rctx *aead_rctx = &rctx->base;\n\tunsigned int assoclen = areq->assoclen - GCM_RFC4106_IV_SIZE;\n\tstruct scatterlist *sg;\n\n\tif (areq->assoclen != 16 && areq->assoclen != 20)\n\t\treturn -EINVAL;\n\n\tscatterwalk_map_and_copy(rctx->assoc, areq->src, 0, assoclen, 0);\n\tsg_init_table(rctx->src, 3);\n\tsg_set_buf(rctx->src, rctx->assoc, assoclen);\n\tsg = scatterwalk_ffwd(rctx->src + 1, areq->src, areq->assoclen);\n\tif (sg != rctx->src + 1)\n\t\tsg_chain(rctx->src, 2, sg);\n\n\tif (areq->src != areq->dst) {\n\t\tsg_init_table(rctx->dst, 3);\n\t\tsg_set_buf(rctx->dst, rctx->assoc, assoclen);\n\t\tsg = scatterwalk_ffwd(rctx->dst + 1, areq->dst, areq->assoclen);\n\t\tif (sg != rctx->dst + 1)\n\t\t\tsg_chain(rctx->dst, 2, sg);\n\t}\n\n\taead_rctx->src = rctx->src;\n\taead_rctx->dst = (areq->src == areq->dst) ? rctx->src : rctx->dst;\n\n\treturn 0;\n}\n\nstatic void nitrox_rfc4106_callback(void *arg, int err)\n{\n\tstruct aead_request *areq = arg;\n\tstruct nitrox_rfc4106_rctx *rctx = aead_request_ctx_dma(areq);\n\tstruct nitrox_kcrypt_request *nkreq = &rctx->base.nkreq;\n\n\tfree_src_sglist(nkreq);\n\tfree_dst_sglist(nkreq);\n\tif (err) {\n\t\tpr_err_ratelimited(\"request failed status 0x%0x\\n\", err);\n\t\terr = -EINVAL;\n\t}\n\n\taead_request_complete(areq, err);\n}\n\nstatic int nitrox_rfc4106_enc(struct aead_request *areq)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(areq);\n\tstruct nitrox_crypto_ctx *nctx = crypto_aead_ctx(aead);\n\tstruct nitrox_rfc4106_rctx *rctx = aead_request_ctx_dma(areq);\n\tstruct nitrox_aead_rctx *aead_rctx = &rctx->base;\n\tstruct se_crypto_request *creq = &aead_rctx->nkreq.creq;\n\tint ret;\n\n\taead_rctx->cryptlen = areq->cryptlen;\n\taead_rctx->assoclen = areq->assoclen - GCM_RFC4106_IV_SIZE;\n\taead_rctx->srclen = aead_rctx->assoclen + aead_rctx->cryptlen;\n\taead_rctx->dstlen = aead_rctx->srclen + aead->authsize;\n\taead_rctx->iv = areq->iv;\n\taead_rctx->ivsize = GCM_RFC4106_IV_SIZE;\n\taead_rctx->flags = areq->base.flags;\n\taead_rctx->ctx_handle = nctx->u.ctx_handle;\n\taead_rctx->ctrl_arg = ENCRYPT;\n\n\tret = nitrox_rfc4106_set_aead_rctx_sglist(areq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nitrox_set_creq(aead_rctx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn nitrox_process_se_request(nctx->ndev, creq,\n\t\t\t\t\t nitrox_rfc4106_callback, areq);\n}\n\nstatic int nitrox_rfc4106_dec(struct aead_request *areq)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(areq);\n\tstruct nitrox_crypto_ctx *nctx = crypto_aead_ctx_dma(aead);\n\tstruct nitrox_rfc4106_rctx *rctx = aead_request_ctx(areq);\n\tstruct nitrox_aead_rctx *aead_rctx = &rctx->base;\n\tstruct se_crypto_request *creq = &aead_rctx->nkreq.creq;\n\tint ret;\n\n\taead_rctx->cryptlen = areq->cryptlen - aead->authsize;\n\taead_rctx->assoclen = areq->assoclen - GCM_RFC4106_IV_SIZE;\n\taead_rctx->srclen =\n\t\tareq->cryptlen - GCM_RFC4106_IV_SIZE + areq->assoclen;\n\taead_rctx->dstlen = aead_rctx->srclen - aead->authsize;\n\taead_rctx->iv = areq->iv;\n\taead_rctx->ivsize = GCM_RFC4106_IV_SIZE;\n\taead_rctx->flags = areq->base.flags;\n\taead_rctx->ctx_handle = nctx->u.ctx_handle;\n\taead_rctx->ctrl_arg = DECRYPT;\n\n\tret = nitrox_rfc4106_set_aead_rctx_sglist(areq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nitrox_set_creq(aead_rctx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn nitrox_process_se_request(nctx->ndev, creq,\n\t\t\t\t\t nitrox_rfc4106_callback, areq);\n}\n\nstatic int nitrox_rfc4106_init(struct crypto_aead *aead)\n{\n\tint ret;\n\n\tret = nitrox_gcm_common_init(aead);\n\tif (ret)\n\t\treturn ret;\n\n\tcrypto_aead_set_reqsize_dma(aead, sizeof(struct aead_request) +\n\t\t\t\t\t  sizeof(struct nitrox_rfc4106_rctx));\n\n\treturn 0;\n}\n\nstatic struct aead_alg nitrox_aeads[] = { {\n\t.base = {\n\t\t.cra_name = \"gcm(aes)\",\n\t\t.cra_driver_name = \"n5_aes_gcm\",\n\t\t.cra_priority = PRIO,\n\t\t.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t.cra_blocksize = 1,\n\t\t.cra_ctxsize = sizeof(struct nitrox_crypto_ctx),\n\t\t.cra_alignmask = 0,\n\t\t.cra_module = THIS_MODULE,\n\t},\n\t.setkey = nitrox_aes_gcm_setkey,\n\t.setauthsize = nitrox_aes_gcm_setauthsize,\n\t.encrypt = nitrox_aes_gcm_enc,\n\t.decrypt = nitrox_aes_gcm_dec,\n\t.init = nitrox_aes_gcm_init,\n\t.exit = nitrox_aead_exit,\n\t.ivsize = GCM_AES_IV_SIZE,\n\t.maxauthsize = AES_BLOCK_SIZE,\n}, {\n\t.base = {\n\t\t.cra_name = \"rfc4106(gcm(aes))\",\n\t\t.cra_driver_name = \"n5_rfc4106\",\n\t\t.cra_priority = PRIO,\n\t\t.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t.cra_blocksize = 1,\n\t\t.cra_ctxsize = sizeof(struct nitrox_crypto_ctx),\n\t\t.cra_alignmask = 0,\n\t\t.cra_module = THIS_MODULE,\n\t},\n\t.setkey = nitrox_rfc4106_setkey,\n\t.setauthsize = nitrox_rfc4106_setauthsize,\n\t.encrypt = nitrox_rfc4106_enc,\n\t.decrypt = nitrox_rfc4106_dec,\n\t.init = nitrox_rfc4106_init,\n\t.exit = nitrox_aead_exit,\n\t.ivsize = GCM_RFC4106_IV_SIZE,\n\t.maxauthsize = AES_BLOCK_SIZE,\n} };\n\nint nitrox_register_aeads(void)\n{\n\treturn crypto_register_aeads(nitrox_aeads, ARRAY_SIZE(nitrox_aeads));\n}\n\nvoid nitrox_unregister_aeads(void)\n{\n\tcrypto_unregister_aeads(nitrox_aeads, ARRAY_SIZE(nitrox_aeads));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}