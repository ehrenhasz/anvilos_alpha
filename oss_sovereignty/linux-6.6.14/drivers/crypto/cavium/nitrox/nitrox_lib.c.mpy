{
  "module_name": "nitrox_lib.c",
  "hash_id": "c5d0012d52236ee0338aac31d5e44ae83729bebcd79fb901cc2961ccae0626f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/cavium/nitrox/nitrox_lib.c",
  "human_readable_source": "\n#include <linux/cpumask.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci_regs.h>\n#include <linux/vmalloc.h>\n#include <linux/pci.h>\n\n#include \"nitrox_dev.h\"\n#include \"nitrox_common.h\"\n#include \"nitrox_req.h\"\n#include \"nitrox_csr.h\"\n\n#define CRYPTO_CTX_SIZE\t256\n\n \n#define PKTIN_Q_ALIGN_BYTES 16\n \n#define AQM_Q_ALIGN_BYTES 32\n\nstatic int nitrox_cmdq_init(struct nitrox_cmdq *cmdq, int align_bytes)\n{\n\tstruct nitrox_device *ndev = cmdq->ndev;\n\n\tcmdq->qsize = (ndev->qlen * cmdq->instr_size) + align_bytes;\n\tcmdq->unalign_base = dma_alloc_coherent(DEV(ndev), cmdq->qsize,\n\t\t\t\t\t\t&cmdq->unalign_dma,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!cmdq->unalign_base)\n\t\treturn -ENOMEM;\n\n\tcmdq->dma = PTR_ALIGN(cmdq->unalign_dma, align_bytes);\n\tcmdq->base = cmdq->unalign_base + (cmdq->dma - cmdq->unalign_dma);\n\tcmdq->write_idx = 0;\n\n\tspin_lock_init(&cmdq->cmd_qlock);\n\tspin_lock_init(&cmdq->resp_qlock);\n\tspin_lock_init(&cmdq->backlog_qlock);\n\n\tINIT_LIST_HEAD(&cmdq->response_head);\n\tINIT_LIST_HEAD(&cmdq->backlog_head);\n\tINIT_WORK(&cmdq->backlog_qflush, backlog_qflush_work);\n\n\tatomic_set(&cmdq->pending_count, 0);\n\tatomic_set(&cmdq->backlog_count, 0);\n\treturn 0;\n}\n\nstatic void nitrox_cmdq_reset(struct nitrox_cmdq *cmdq)\n{\n\tcmdq->write_idx = 0;\n\tatomic_set(&cmdq->pending_count, 0);\n\tatomic_set(&cmdq->backlog_count, 0);\n}\n\nstatic void nitrox_cmdq_cleanup(struct nitrox_cmdq *cmdq)\n{\n\tstruct nitrox_device *ndev;\n\n\tif (!cmdq)\n\t\treturn;\n\n\tif (!cmdq->unalign_base)\n\t\treturn;\n\n\tndev = cmdq->ndev;\n\tcancel_work_sync(&cmdq->backlog_qflush);\n\n\tdma_free_coherent(DEV(ndev), cmdq->qsize,\n\t\t\t  cmdq->unalign_base, cmdq->unalign_dma);\n\tnitrox_cmdq_reset(cmdq);\n\n\tcmdq->dbell_csr_addr = NULL;\n\tcmdq->compl_cnt_csr_addr = NULL;\n\tcmdq->unalign_base = NULL;\n\tcmdq->base = NULL;\n\tcmdq->unalign_dma = 0;\n\tcmdq->dma = 0;\n\tcmdq->qsize = 0;\n\tcmdq->instr_size = 0;\n}\n\nstatic void nitrox_free_aqm_queues(struct nitrox_device *ndev)\n{\n\tint i;\n\n\tfor (i = 0; i < ndev->nr_queues; i++) {\n\t\tnitrox_cmdq_cleanup(ndev->aqmq[i]);\n\t\tkfree_sensitive(ndev->aqmq[i]);\n\t\tndev->aqmq[i] = NULL;\n\t}\n}\n\nstatic int nitrox_alloc_aqm_queues(struct nitrox_device *ndev)\n{\n\tint i, err;\n\n\tfor (i = 0; i < ndev->nr_queues; i++) {\n\t\tstruct nitrox_cmdq *cmdq;\n\t\tu64 offset;\n\n\t\tcmdq = kzalloc_node(sizeof(*cmdq), GFP_KERNEL, ndev->node);\n\t\tif (!cmdq) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto aqmq_fail;\n\t\t}\n\n\t\tcmdq->ndev = ndev;\n\t\tcmdq->qno = i;\n\t\tcmdq->instr_size = sizeof(struct aqmq_command_s);\n\n\t\t \n\t\toffset = AQMQ_DRBLX(i);\n\t\tcmdq->dbell_csr_addr = NITROX_CSR_ADDR(ndev, offset);\n\t\t \n\t\toffset = AQMQ_CMD_CNTX(i);\n\t\tcmdq->compl_cnt_csr_addr = NITROX_CSR_ADDR(ndev, offset);\n\n\t\terr = nitrox_cmdq_init(cmdq, AQM_Q_ALIGN_BYTES);\n\t\tif (err) {\n\t\t\tkfree_sensitive(cmdq);\n\t\t\tgoto aqmq_fail;\n\t\t}\n\t\tndev->aqmq[i] = cmdq;\n\t}\n\n\treturn 0;\n\naqmq_fail:\n\tnitrox_free_aqm_queues(ndev);\n\treturn err;\n}\n\nstatic void nitrox_free_pktin_queues(struct nitrox_device *ndev)\n{\n\tint i;\n\n\tfor (i = 0; i < ndev->nr_queues; i++) {\n\t\tstruct nitrox_cmdq *cmdq = &ndev->pkt_inq[i];\n\n\t\tnitrox_cmdq_cleanup(cmdq);\n\t}\n\tkfree(ndev->pkt_inq);\n\tndev->pkt_inq = NULL;\n}\n\nstatic int nitrox_alloc_pktin_queues(struct nitrox_device *ndev)\n{\n\tint i, err;\n\n\tndev->pkt_inq = kcalloc_node(ndev->nr_queues,\n\t\t\t\t     sizeof(struct nitrox_cmdq),\n\t\t\t\t     GFP_KERNEL, ndev->node);\n\tif (!ndev->pkt_inq)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ndev->nr_queues; i++) {\n\t\tstruct nitrox_cmdq *cmdq;\n\t\tu64 offset;\n\n\t\tcmdq = &ndev->pkt_inq[i];\n\t\tcmdq->ndev = ndev;\n\t\tcmdq->qno = i;\n\t\tcmdq->instr_size = sizeof(struct nps_pkt_instr);\n\n\t\t \n\t\toffset = NPS_PKT_IN_INSTR_BAOFF_DBELLX(i);\n\t\tcmdq->dbell_csr_addr = NITROX_CSR_ADDR(ndev, offset);\n\t\t \n\t\toffset = NPS_PKT_SLC_CNTSX(i);\n\t\tcmdq->compl_cnt_csr_addr = NITROX_CSR_ADDR(ndev, offset);\n\n\t\terr = nitrox_cmdq_init(cmdq, PKTIN_Q_ALIGN_BYTES);\n\t\tif (err)\n\t\t\tgoto pktq_fail;\n\t}\n\treturn 0;\n\npktq_fail:\n\tnitrox_free_pktin_queues(ndev);\n\treturn err;\n}\n\nstatic int create_crypto_dma_pool(struct nitrox_device *ndev)\n{\n\tsize_t size;\n\n\t \n\tsize = CRYPTO_CTX_SIZE + sizeof(struct ctx_hdr);\n\tndev->ctx_pool = dma_pool_create(\"nitrox-context\",\n\t\t\t\t\t DEV(ndev), size, 16, 0);\n\tif (!ndev->ctx_pool)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void destroy_crypto_dma_pool(struct nitrox_device *ndev)\n{\n\tif (!ndev->ctx_pool)\n\t\treturn;\n\n\tdma_pool_destroy(ndev->ctx_pool);\n\tndev->ctx_pool = NULL;\n}\n\n \nvoid *crypto_alloc_context(struct nitrox_device *ndev)\n{\n\tstruct ctx_hdr *ctx;\n\tstruct crypto_ctx_hdr *chdr;\n\tvoid *vaddr;\n\tdma_addr_t dma;\n\n\tchdr = kmalloc(sizeof(*chdr), GFP_KERNEL);\n\tif (!chdr)\n\t\treturn NULL;\n\n\tvaddr = dma_pool_zalloc(ndev->ctx_pool, GFP_KERNEL, &dma);\n\tif (!vaddr) {\n\t\tkfree(chdr);\n\t\treturn NULL;\n\t}\n\n\t \n\tctx = vaddr;\n\tctx->pool = ndev->ctx_pool;\n\tctx->dma = dma;\n\tctx->ctx_dma = dma + sizeof(struct ctx_hdr);\n\n\tchdr->pool = ndev->ctx_pool;\n\tchdr->dma = dma;\n\tchdr->vaddr = vaddr;\n\n\treturn chdr;\n}\n\n \nvoid crypto_free_context(void *ctx)\n{\n\tstruct crypto_ctx_hdr *ctxp;\n\n\tif (!ctx)\n\t\treturn;\n\n\tctxp = ctx;\n\tdma_pool_free(ctxp->pool, ctxp->vaddr, ctxp->dma);\n\tkfree(ctxp);\n}\n\n \nint nitrox_common_sw_init(struct nitrox_device *ndev)\n{\n\tint err = 0;\n\n\t \n\terr = create_crypto_dma_pool(ndev);\n\tif (err)\n\t\treturn err;\n\n\terr = nitrox_alloc_pktin_queues(ndev);\n\tif (err)\n\t\tdestroy_crypto_dma_pool(ndev);\n\n\terr = nitrox_alloc_aqm_queues(ndev);\n\tif (err) {\n\t\tnitrox_free_pktin_queues(ndev);\n\t\tdestroy_crypto_dma_pool(ndev);\n\t}\n\n\treturn err;\n}\n\n \nvoid nitrox_common_sw_cleanup(struct nitrox_device *ndev)\n{\n\tnitrox_free_aqm_queues(ndev);\n\tnitrox_free_pktin_queues(ndev);\n\tdestroy_crypto_dma_pool(ndev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}