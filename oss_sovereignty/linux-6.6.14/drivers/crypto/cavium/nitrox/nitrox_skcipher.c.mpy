{
  "module_name": "nitrox_skcipher.c",
  "hash_id": "8ff2b58310f1bfc4c3367629c51352d729f2ac4c9dd17006a3e21a23b540d180",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/cavium/nitrox/nitrox_skcipher.c",
  "human_readable_source": "\n#include <linux/crypto.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n\n#include <crypto/aes.h>\n#include <crypto/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/ctr.h>\n#include <crypto/internal/des.h>\n#include <crypto/xts.h>\n\n#include \"nitrox_dev.h\"\n#include \"nitrox_common.h\"\n#include \"nitrox_req.h\"\n\nstruct nitrox_cipher {\n\tconst char *name;\n\tenum flexi_cipher value;\n};\n\n \nstatic const struct nitrox_cipher flexi_cipher_table[] = {\n\t{ \"null\",\t\tCIPHER_NULL },\n\t{ \"cbc(des3_ede)\",\tCIPHER_3DES_CBC },\n\t{ \"ecb(des3_ede)\",\tCIPHER_3DES_ECB },\n\t{ \"cbc(aes)\",\t\tCIPHER_AES_CBC },\n\t{ \"ecb(aes)\",\t\tCIPHER_AES_ECB },\n\t{ \"cfb(aes)\",\t\tCIPHER_AES_CFB },\n\t{ \"rfc3686(ctr(aes))\",\tCIPHER_AES_CTR },\n\t{ \"xts(aes)\",\t\tCIPHER_AES_XTS },\n\t{ \"cts(cbc(aes))\",\tCIPHER_AES_CBC_CTS },\n\t{ NULL,\t\t\tCIPHER_INVALID }\n};\n\nstatic enum flexi_cipher flexi_cipher_type(const char *name)\n{\n\tconst struct nitrox_cipher *cipher = flexi_cipher_table;\n\n\twhile (cipher->name) {\n\t\tif (!strcmp(cipher->name, name))\n\t\t\tbreak;\n\t\tcipher++;\n\t}\n\treturn cipher->value;\n}\n\nstatic void free_src_sglist(struct skcipher_request *skreq)\n{\n\tstruct nitrox_kcrypt_request *nkreq = skcipher_request_ctx(skreq);\n\n\tkfree(nkreq->src);\n}\n\nstatic void free_dst_sglist(struct skcipher_request *skreq)\n{\n\tstruct nitrox_kcrypt_request *nkreq = skcipher_request_ctx(skreq);\n\n\tkfree(nkreq->dst);\n}\n\nstatic void nitrox_skcipher_callback(void *arg, int err)\n{\n\tstruct skcipher_request *skreq = arg;\n\n\tfree_src_sglist(skreq);\n\tfree_dst_sglist(skreq);\n\tif (err) {\n\t\tpr_err_ratelimited(\"request failed status 0x%0x\\n\", err);\n\t\terr = -EINVAL;\n\t}\n\n\tskcipher_request_complete(skreq, err);\n}\n\nstatic void nitrox_cbc_cipher_callback(void *arg, int err)\n{\n\tstruct skcipher_request *skreq = arg;\n\tstruct nitrox_kcrypt_request *nkreq = skcipher_request_ctx(skreq);\n\tstruct crypto_skcipher *cipher = crypto_skcipher_reqtfm(skreq);\n\tint ivsize = crypto_skcipher_ivsize(cipher);\n\tunsigned int start = skreq->cryptlen - ivsize;\n\n\tif (err) {\n\t\tnitrox_skcipher_callback(arg, err);\n\t\treturn;\n\t}\n\n\tif (nkreq->creq.ctrl.s.arg == ENCRYPT) {\n\t\tscatterwalk_map_and_copy(skreq->iv, skreq->dst, start, ivsize,\n\t\t\t\t\t 0);\n\t} else {\n\t\tif (skreq->src != skreq->dst) {\n\t\t\tscatterwalk_map_and_copy(skreq->iv, skreq->src, start,\n\t\t\t\t\t\t ivsize, 0);\n\t\t} else {\n\t\t\tmemcpy(skreq->iv, nkreq->iv_out, ivsize);\n\t\t\tkfree(nkreq->iv_out);\n\t\t}\n\t}\n\n\tnitrox_skcipher_callback(arg, err);\n}\n\nstatic int nitrox_skcipher_init(struct crypto_skcipher *tfm)\n{\n\tstruct nitrox_crypto_ctx *nctx = crypto_skcipher_ctx(tfm);\n\tstruct crypto_ctx_hdr *chdr;\n\n\t \n\tnctx->ndev = nitrox_get_first_device();\n\tif (!nctx->ndev)\n\t\treturn -ENODEV;\n\n\t \n\tchdr = crypto_alloc_context(nctx->ndev);\n\tif (!chdr) {\n\t\tnitrox_put_device(nctx->ndev);\n\t\treturn -ENOMEM;\n\t}\n\n\tnctx->callback = nitrox_skcipher_callback;\n\tnctx->chdr = chdr;\n\tnctx->u.ctx_handle = (uintptr_t)((u8 *)chdr->vaddr +\n\t\t\t\t\t sizeof(struct ctx_hdr));\n\tcrypto_skcipher_set_reqsize(tfm, crypto_skcipher_reqsize(tfm) +\n\t\t\t\t    sizeof(struct nitrox_kcrypt_request));\n\treturn 0;\n}\n\nstatic int nitrox_cbc_init(struct crypto_skcipher *tfm)\n{\n\tint err;\n\tstruct nitrox_crypto_ctx *nctx = crypto_skcipher_ctx(tfm);\n\n\terr = nitrox_skcipher_init(tfm);\n\tif (err)\n\t\treturn err;\n\n\tnctx->callback = nitrox_cbc_cipher_callback;\n\treturn 0;\n}\n\nstatic void nitrox_skcipher_exit(struct crypto_skcipher *tfm)\n{\n\tstruct nitrox_crypto_ctx *nctx = crypto_skcipher_ctx(tfm);\n\n\t \n\tif (nctx->u.ctx_handle) {\n\t\tstruct flexi_crypto_context *fctx = nctx->u.fctx;\n\n\t\tmemzero_explicit(&fctx->crypto, sizeof(struct crypto_keys));\n\t\tmemzero_explicit(&fctx->auth, sizeof(struct auth_keys));\n\t\tcrypto_free_context((void *)nctx->chdr);\n\t}\n\tnitrox_put_device(nctx->ndev);\n\n\tnctx->u.ctx_handle = 0;\n\tnctx->ndev = NULL;\n}\n\nstatic inline int nitrox_skcipher_setkey(struct crypto_skcipher *cipher,\n\t\t\t\t\t int aes_keylen, const u8 *key,\n\t\t\t\t\t unsigned int keylen)\n{\n\tstruct crypto_tfm *tfm = crypto_skcipher_tfm(cipher);\n\tstruct nitrox_crypto_ctx *nctx = crypto_tfm_ctx(tfm);\n\tstruct flexi_crypto_context *fctx;\n\tunion fc_ctx_flags *flags;\n\tenum flexi_cipher cipher_type;\n\tconst char *name;\n\n\tname = crypto_tfm_alg_name(tfm);\n\tcipher_type = flexi_cipher_type(name);\n\tif (unlikely(cipher_type == CIPHER_INVALID)) {\n\t\tpr_err(\"unsupported cipher: %s\\n\", name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfctx = nctx->u.fctx;\n\tflags = &fctx->flags;\n\tflags->f = 0;\n\tflags->w0.cipher_type = cipher_type;\n\tflags->w0.aes_keylen = aes_keylen;\n\tflags->w0.iv_source = IV_FROM_DPTR;\n\tflags->f = cpu_to_be64(*(u64 *)&flags->w0);\n\t \n\tmemcpy(fctx->crypto.u.key, key, keylen);\n\n\treturn 0;\n}\n\nstatic int nitrox_aes_setkey(struct crypto_skcipher *cipher, const u8 *key,\n\t\t\t     unsigned int keylen)\n{\n\tint aes_keylen;\n\n\taes_keylen = flexi_aes_keylen(keylen);\n\tif (aes_keylen < 0)\n\t\treturn -EINVAL;\n\treturn nitrox_skcipher_setkey(cipher, aes_keylen, key, keylen);\n}\n\nstatic int alloc_src_sglist(struct skcipher_request *skreq, int ivsize)\n{\n\tstruct nitrox_kcrypt_request *nkreq = skcipher_request_ctx(skreq);\n\tint nents = sg_nents(skreq->src) + 1;\n\tint ret;\n\n\t \n\tret = alloc_src_req_buf(nkreq, nents, ivsize);\n\tif (ret)\n\t\treturn ret;\n\n\tnitrox_creq_copy_iv(nkreq->src, skreq->iv, ivsize);\n\tnitrox_creq_set_src_sg(nkreq, nents, ivsize, skreq->src,\n\t\t\t       skreq->cryptlen);\n\n\treturn 0;\n}\n\nstatic int alloc_dst_sglist(struct skcipher_request *skreq, int ivsize)\n{\n\tstruct nitrox_kcrypt_request *nkreq = skcipher_request_ctx(skreq);\n\tint nents = sg_nents(skreq->dst) + 3;\n\tint ret;\n\n\t \n\tret = alloc_dst_req_buf(nkreq, nents);\n\tif (ret)\n\t\treturn ret;\n\n\tnitrox_creq_set_orh(nkreq);\n\tnitrox_creq_set_comp(nkreq);\n\tnitrox_creq_set_dst_sg(nkreq, nents, ivsize, skreq->dst,\n\t\t\t       skreq->cryptlen);\n\n\treturn 0;\n}\n\nstatic int nitrox_skcipher_crypt(struct skcipher_request *skreq, bool enc)\n{\n\tstruct crypto_skcipher *cipher = crypto_skcipher_reqtfm(skreq);\n\tstruct nitrox_crypto_ctx *nctx = crypto_skcipher_ctx(cipher);\n\tstruct nitrox_kcrypt_request *nkreq = skcipher_request_ctx(skreq);\n\tint ivsize = crypto_skcipher_ivsize(cipher);\n\tstruct se_crypto_request *creq;\n\tint ret;\n\n\tcreq = &nkreq->creq;\n\tcreq->flags = skreq->base.flags;\n\tcreq->gfp = (skreq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t     GFP_KERNEL : GFP_ATOMIC;\n\n\t \n\tcreq->ctrl.value = 0;\n\tcreq->opcode = FLEXI_CRYPTO_ENCRYPT_HMAC;\n\tcreq->ctrl.s.arg = (enc ? ENCRYPT : DECRYPT);\n\t \n\tcreq->gph.param0 = cpu_to_be16(skreq->cryptlen);\n\tcreq->gph.param1 = 0;\n\t \n\tcreq->gph.param2 = cpu_to_be16(ivsize);\n\tcreq->gph.param3 = 0;\n\n\tcreq->ctx_handle = nctx->u.ctx_handle;\n\tcreq->ctrl.s.ctxl = sizeof(struct flexi_crypto_context);\n\n\tret = alloc_src_sglist(skreq, ivsize);\n\tif (ret)\n\t\treturn ret;\n\n\tret = alloc_dst_sglist(skreq, ivsize);\n\tif (ret) {\n\t\tfree_src_sglist(skreq);\n\t\treturn ret;\n\t}\n\n\t \n\treturn nitrox_process_se_request(nctx->ndev, creq, nctx->callback,\n\t\t\t\t\t skreq);\n}\n\nstatic int nitrox_cbc_decrypt(struct skcipher_request *skreq)\n{\n\tstruct nitrox_kcrypt_request *nkreq = skcipher_request_ctx(skreq);\n\tstruct crypto_skcipher *cipher = crypto_skcipher_reqtfm(skreq);\n\tint ivsize = crypto_skcipher_ivsize(cipher);\n\tgfp_t flags = (skreq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t\tGFP_KERNEL : GFP_ATOMIC;\n\tunsigned int start = skreq->cryptlen - ivsize;\n\n\tif (skreq->src != skreq->dst)\n\t\treturn nitrox_skcipher_crypt(skreq, false);\n\n\tnkreq->iv_out = kmalloc(ivsize, flags);\n\tif (!nkreq->iv_out)\n\t\treturn -ENOMEM;\n\n\tscatterwalk_map_and_copy(nkreq->iv_out, skreq->src, start, ivsize, 0);\n\treturn nitrox_skcipher_crypt(skreq, false);\n}\n\nstatic int nitrox_aes_encrypt(struct skcipher_request *skreq)\n{\n\treturn nitrox_skcipher_crypt(skreq, true);\n}\n\nstatic int nitrox_aes_decrypt(struct skcipher_request *skreq)\n{\n\treturn nitrox_skcipher_crypt(skreq, false);\n}\n\nstatic int nitrox_3des_setkey(struct crypto_skcipher *cipher,\n\t\t\t      const u8 *key, unsigned int keylen)\n{\n\treturn verify_skcipher_des3_key(cipher, key) ?:\n\t       nitrox_skcipher_setkey(cipher, 0, key, keylen);\n}\n\nstatic int nitrox_3des_encrypt(struct skcipher_request *skreq)\n{\n\treturn nitrox_skcipher_crypt(skreq, true);\n}\n\nstatic int nitrox_3des_decrypt(struct skcipher_request *skreq)\n{\n\treturn nitrox_skcipher_crypt(skreq, false);\n}\n\nstatic int nitrox_aes_xts_setkey(struct crypto_skcipher *cipher,\n\t\t\t\t const u8 *key, unsigned int keylen)\n{\n\tstruct nitrox_crypto_ctx *nctx = crypto_skcipher_ctx(cipher);\n\tstruct flexi_crypto_context *fctx;\n\tint aes_keylen, ret;\n\n\tret = xts_verify_key(cipher, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\tkeylen /= 2;\n\n\taes_keylen = flexi_aes_keylen(keylen);\n\tif (aes_keylen < 0)\n\t\treturn -EINVAL;\n\n\tfctx = nctx->u.fctx;\n\t \n\tmemcpy(fctx->auth.u.key2, (key + keylen), keylen);\n\n\treturn nitrox_skcipher_setkey(cipher, aes_keylen, key, keylen);\n}\n\nstatic int nitrox_aes_ctr_rfc3686_setkey(struct crypto_skcipher *cipher,\n\t\t\t\t\t const u8 *key, unsigned int keylen)\n{\n\tstruct nitrox_crypto_ctx *nctx = crypto_skcipher_ctx(cipher);\n\tstruct flexi_crypto_context *fctx;\n\tint aes_keylen;\n\n\tif (keylen < CTR_RFC3686_NONCE_SIZE)\n\t\treturn -EINVAL;\n\n\tfctx = nctx->u.fctx;\n\n\tmemcpy(fctx->crypto.iv, key + (keylen - CTR_RFC3686_NONCE_SIZE),\n\t       CTR_RFC3686_NONCE_SIZE);\n\n\tkeylen -= CTR_RFC3686_NONCE_SIZE;\n\n\taes_keylen = flexi_aes_keylen(keylen);\n\tif (aes_keylen < 0)\n\t\treturn -EINVAL;\n\treturn nitrox_skcipher_setkey(cipher, aes_keylen, key, keylen);\n}\n\nstatic struct skcipher_alg nitrox_skciphers[] = { {\n\t.base = {\n\t\t.cra_name = \"cbc(aes)\",\n\t\t.cra_driver_name = \"n5_cbc(aes)\",\n\t\t.cra_priority = PRIO,\n\t\t.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t.cra_ctxsize = sizeof(struct nitrox_crypto_ctx),\n\t\t.cra_alignmask = 0,\n\t\t.cra_module = THIS_MODULE,\n\t},\n\t.min_keysize = AES_MIN_KEY_SIZE,\n\t.max_keysize = AES_MAX_KEY_SIZE,\n\t.ivsize = AES_BLOCK_SIZE,\n\t.setkey = nitrox_aes_setkey,\n\t.encrypt = nitrox_aes_encrypt,\n\t.decrypt = nitrox_cbc_decrypt,\n\t.init = nitrox_cbc_init,\n\t.exit = nitrox_skcipher_exit,\n}, {\n\t.base = {\n\t\t.cra_name = \"ecb(aes)\",\n\t\t.cra_driver_name = \"n5_ecb(aes)\",\n\t\t.cra_priority = PRIO,\n\t\t.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t.cra_ctxsize = sizeof(struct nitrox_crypto_ctx),\n\t\t.cra_alignmask = 0,\n\t\t.cra_module = THIS_MODULE,\n\t},\n\t.min_keysize = AES_MIN_KEY_SIZE,\n\t.max_keysize = AES_MAX_KEY_SIZE,\n\t.ivsize = AES_BLOCK_SIZE,\n\t.setkey = nitrox_aes_setkey,\n\t.encrypt = nitrox_aes_encrypt,\n\t.decrypt = nitrox_aes_decrypt,\n\t.init = nitrox_skcipher_init,\n\t.exit = nitrox_skcipher_exit,\n}, {\n\t.base = {\n\t\t.cra_name = \"cfb(aes)\",\n\t\t.cra_driver_name = \"n5_cfb(aes)\",\n\t\t.cra_priority = PRIO,\n\t\t.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t.cra_ctxsize = sizeof(struct nitrox_crypto_ctx),\n\t\t.cra_alignmask = 0,\n\t\t.cra_module = THIS_MODULE,\n\t},\n\t.min_keysize = AES_MIN_KEY_SIZE,\n\t.max_keysize = AES_MAX_KEY_SIZE,\n\t.ivsize = AES_BLOCK_SIZE,\n\t.setkey = nitrox_aes_setkey,\n\t.encrypt = nitrox_aes_encrypt,\n\t.decrypt = nitrox_aes_decrypt,\n\t.init = nitrox_skcipher_init,\n\t.exit = nitrox_skcipher_exit,\n}, {\n\t.base = {\n\t\t.cra_name = \"xts(aes)\",\n\t\t.cra_driver_name = \"n5_xts(aes)\",\n\t\t.cra_priority = PRIO,\n\t\t.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t.cra_ctxsize = sizeof(struct nitrox_crypto_ctx),\n\t\t.cra_alignmask = 0,\n\t\t.cra_module = THIS_MODULE,\n\t},\n\t.min_keysize = 2 * AES_MIN_KEY_SIZE,\n\t.max_keysize = 2 * AES_MAX_KEY_SIZE,\n\t.ivsize = AES_BLOCK_SIZE,\n\t.setkey = nitrox_aes_xts_setkey,\n\t.encrypt = nitrox_aes_encrypt,\n\t.decrypt = nitrox_aes_decrypt,\n\t.init = nitrox_skcipher_init,\n\t.exit = nitrox_skcipher_exit,\n}, {\n\t.base = {\n\t\t.cra_name = \"rfc3686(ctr(aes))\",\n\t\t.cra_driver_name = \"n5_rfc3686(ctr(aes))\",\n\t\t.cra_priority = PRIO,\n\t\t.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t.cra_blocksize = 1,\n\t\t.cra_ctxsize = sizeof(struct nitrox_crypto_ctx),\n\t\t.cra_alignmask = 0,\n\t\t.cra_module = THIS_MODULE,\n\t},\n\t.min_keysize = AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,\n\t.max_keysize = AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,\n\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t.init = nitrox_skcipher_init,\n\t.exit = nitrox_skcipher_exit,\n\t.setkey = nitrox_aes_ctr_rfc3686_setkey,\n\t.encrypt = nitrox_aes_encrypt,\n\t.decrypt = nitrox_aes_decrypt,\n}, {\n\t.base = {\n\t\t.cra_name = \"cts(cbc(aes))\",\n\t\t.cra_driver_name = \"n5_cts(cbc(aes))\",\n\t\t.cra_priority = PRIO,\n\t\t.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t.cra_ctxsize = sizeof(struct nitrox_crypto_ctx),\n\t\t.cra_alignmask = 0,\n\t\t.cra_module = THIS_MODULE,\n\t},\n\t.min_keysize = AES_MIN_KEY_SIZE,\n\t.max_keysize = AES_MAX_KEY_SIZE,\n\t.ivsize = AES_BLOCK_SIZE,\n\t.setkey = nitrox_aes_setkey,\n\t.encrypt = nitrox_aes_encrypt,\n\t.decrypt = nitrox_aes_decrypt,\n\t.init = nitrox_skcipher_init,\n\t.exit = nitrox_skcipher_exit,\n}, {\n\t.base = {\n\t\t.cra_name = \"cbc(des3_ede)\",\n\t\t.cra_driver_name = \"n5_cbc(des3_ede)\",\n\t\t.cra_priority = PRIO,\n\t\t.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t.cra_ctxsize = sizeof(struct nitrox_crypto_ctx),\n\t\t.cra_alignmask = 0,\n\t\t.cra_module = THIS_MODULE,\n\t},\n\t.min_keysize = DES3_EDE_KEY_SIZE,\n\t.max_keysize = DES3_EDE_KEY_SIZE,\n\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t.setkey = nitrox_3des_setkey,\n\t.encrypt = nitrox_3des_encrypt,\n\t.decrypt = nitrox_cbc_decrypt,\n\t.init = nitrox_cbc_init,\n\t.exit = nitrox_skcipher_exit,\n}, {\n\t.base = {\n\t\t.cra_name = \"ecb(des3_ede)\",\n\t\t.cra_driver_name = \"n5_ecb(des3_ede)\",\n\t\t.cra_priority = PRIO,\n\t\t.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t.cra_ctxsize = sizeof(struct nitrox_crypto_ctx),\n\t\t.cra_alignmask = 0,\n\t\t.cra_module = THIS_MODULE,\n\t},\n\t.min_keysize = DES3_EDE_KEY_SIZE,\n\t.max_keysize = DES3_EDE_KEY_SIZE,\n\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t.setkey = nitrox_3des_setkey,\n\t.encrypt = nitrox_3des_encrypt,\n\t.decrypt = nitrox_3des_decrypt,\n\t.init = nitrox_skcipher_init,\n\t.exit = nitrox_skcipher_exit,\n}\n\n};\n\nint nitrox_register_skciphers(void)\n{\n\treturn crypto_register_skciphers(nitrox_skciphers,\n\t\t\t\t\t ARRAY_SIZE(nitrox_skciphers));\n}\n\nvoid nitrox_unregister_skciphers(void)\n{\n\tcrypto_unregister_skciphers(nitrox_skciphers,\n\t\t\t\t    ARRAY_SIZE(nitrox_skciphers));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}