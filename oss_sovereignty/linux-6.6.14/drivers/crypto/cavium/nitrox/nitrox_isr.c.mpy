{
  "module_name": "nitrox_isr.c",
  "hash_id": "9f18336ac94fe58b1bf1508d4a8341b36b42b538a4254ee1522cab32e011b74b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/cavium/nitrox/nitrox_isr.c",
  "human_readable_source": "\n#include <linux/pci.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n\n#include \"nitrox_dev.h\"\n#include \"nitrox_csr.h\"\n#include \"nitrox_common.h\"\n#include \"nitrox_hal.h\"\n#include \"nitrox_isr.h\"\n#include \"nitrox_mbx.h\"\n\n \n#define NR_RING_VECTORS 3\n#define NR_NON_RING_VECTORS 1\n \n#define PKT_RING_MSIX_BASE 0\n#define NON_RING_MSIX_BASE 192\n\n \nstatic irqreturn_t nps_pkt_slc_isr(int irq, void *data)\n{\n\tstruct nitrox_q_vector *qvec = data;\n\tunion nps_pkt_slc_cnts slc_cnts;\n\tstruct nitrox_cmdq *cmdq = qvec->cmdq;\n\n\tslc_cnts.value = readq(cmdq->compl_cnt_csr_addr);\n\t \n\tif (slc_cnts.s.slc_int)\n\t\ttasklet_hi_schedule(&qvec->resp_tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void clear_nps_core_err_intr(struct nitrox_device *ndev)\n{\n\tu64 value;\n\n\t \n\tvalue = nitrox_read_csr(ndev, NPS_CORE_INT);\n\tnitrox_write_csr(ndev, NPS_CORE_INT, value);\n\n\tdev_err_ratelimited(DEV(ndev), \"NSP_CORE_INT  0x%016llx\\n\", value);\n}\n\nstatic void clear_nps_pkt_err_intr(struct nitrox_device *ndev)\n{\n\tunion nps_pkt_int pkt_int;\n\tunsigned long value, offset;\n\tint i;\n\n\tpkt_int.value = nitrox_read_csr(ndev, NPS_PKT_INT);\n\tdev_err_ratelimited(DEV(ndev), \"NPS_PKT_INT  0x%016llx\\n\",\n\t\t\t    pkt_int.value);\n\n\tif (pkt_int.s.slc_err) {\n\t\toffset = NPS_PKT_SLC_ERR_TYPE;\n\t\tvalue = nitrox_read_csr(ndev, offset);\n\t\tnitrox_write_csr(ndev, offset, value);\n\t\tdev_err_ratelimited(DEV(ndev),\n\t\t\t\t    \"NPS_PKT_SLC_ERR_TYPE  0x%016lx\\n\", value);\n\n\t\toffset = NPS_PKT_SLC_RERR_LO;\n\t\tvalue = nitrox_read_csr(ndev, offset);\n\t\tnitrox_write_csr(ndev, offset, value);\n\t\t \n\t\tfor_each_set_bit(i, &value, BITS_PER_LONG)\n\t\t\tenable_pkt_solicit_port(ndev, i);\n\n\t\tdev_err_ratelimited(DEV(ndev),\n\t\t\t\t    \"NPS_PKT_SLC_RERR_LO  0x%016lx\\n\", value);\n\n\t\toffset = NPS_PKT_SLC_RERR_HI;\n\t\tvalue = nitrox_read_csr(ndev, offset);\n\t\tnitrox_write_csr(ndev, offset, value);\n\t\tdev_err_ratelimited(DEV(ndev),\n\t\t\t\t    \"NPS_PKT_SLC_RERR_HI  0x%016lx\\n\", value);\n\t}\n\n\tif (pkt_int.s.in_err) {\n\t\toffset = NPS_PKT_IN_ERR_TYPE;\n\t\tvalue = nitrox_read_csr(ndev, offset);\n\t\tnitrox_write_csr(ndev, offset, value);\n\t\tdev_err_ratelimited(DEV(ndev),\n\t\t\t\t    \"NPS_PKT_IN_ERR_TYPE  0x%016lx\\n\", value);\n\t\toffset = NPS_PKT_IN_RERR_LO;\n\t\tvalue = nitrox_read_csr(ndev, offset);\n\t\tnitrox_write_csr(ndev, offset, value);\n\t\t \n\t\tfor_each_set_bit(i, &value, BITS_PER_LONG)\n\t\t\tenable_pkt_input_ring(ndev, i);\n\n\t\tdev_err_ratelimited(DEV(ndev),\n\t\t\t\t    \"NPS_PKT_IN_RERR_LO  0x%016lx\\n\", value);\n\n\t\toffset = NPS_PKT_IN_RERR_HI;\n\t\tvalue = nitrox_read_csr(ndev, offset);\n\t\tnitrox_write_csr(ndev, offset, value);\n\t\tdev_err_ratelimited(DEV(ndev),\n\t\t\t\t    \"NPS_PKT_IN_RERR_HI  0x%016lx\\n\", value);\n\t}\n}\n\nstatic void clear_pom_err_intr(struct nitrox_device *ndev)\n{\n\tu64 value;\n\n\tvalue = nitrox_read_csr(ndev, POM_INT);\n\tnitrox_write_csr(ndev, POM_INT, value);\n\tdev_err_ratelimited(DEV(ndev), \"POM_INT  0x%016llx\\n\", value);\n}\n\nstatic void clear_pem_err_intr(struct nitrox_device *ndev)\n{\n\tu64 value;\n\n\tvalue = nitrox_read_csr(ndev, PEM0_INT);\n\tnitrox_write_csr(ndev, PEM0_INT, value);\n\tdev_err_ratelimited(DEV(ndev), \"PEM(0)_INT  0x%016llx\\n\", value);\n}\n\nstatic void clear_lbc_err_intr(struct nitrox_device *ndev)\n{\n\tunion lbc_int lbc_int;\n\tu64 value, offset;\n\tint i;\n\n\tlbc_int.value = nitrox_read_csr(ndev, LBC_INT);\n\tdev_err_ratelimited(DEV(ndev), \"LBC_INT  0x%016llx\\n\", lbc_int.value);\n\n\tif (lbc_int.s.dma_rd_err) {\n\t\tfor (i = 0; i < NR_CLUSTERS; i++) {\n\t\t\toffset = EFL_CORE_VF_ERR_INT0X(i);\n\t\t\tvalue = nitrox_read_csr(ndev, offset);\n\t\t\tnitrox_write_csr(ndev, offset, value);\n\t\t\toffset = EFL_CORE_VF_ERR_INT1X(i);\n\t\t\tvalue = nitrox_read_csr(ndev, offset);\n\t\t\tnitrox_write_csr(ndev, offset, value);\n\t\t}\n\t}\n\n\tif (lbc_int.s.cam_soft_err) {\n\t\tdev_err_ratelimited(DEV(ndev), \"CAM_SOFT_ERR, invalidating LBC\\n\");\n\t\tinvalidate_lbc(ndev);\n\t}\n\n\tif (lbc_int.s.pref_dat_len_mismatch_err) {\n\t\toffset = LBC_PLM_VF1_64_INT;\n\t\tvalue = nitrox_read_csr(ndev, offset);\n\t\tnitrox_write_csr(ndev, offset, value);\n\t\toffset = LBC_PLM_VF65_128_INT;\n\t\tvalue = nitrox_read_csr(ndev, offset);\n\t\tnitrox_write_csr(ndev, offset, value);\n\t}\n\n\tif (lbc_int.s.rd_dat_len_mismatch_err) {\n\t\toffset = LBC_ELM_VF1_64_INT;\n\t\tvalue = nitrox_read_csr(ndev, offset);\n\t\tnitrox_write_csr(ndev, offset, value);\n\t\toffset = LBC_ELM_VF65_128_INT;\n\t\tvalue = nitrox_read_csr(ndev, offset);\n\t\tnitrox_write_csr(ndev, offset, value);\n\t}\n\tnitrox_write_csr(ndev, LBC_INT, lbc_int.value);\n}\n\nstatic void clear_efl_err_intr(struct nitrox_device *ndev)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_CLUSTERS; i++) {\n\t\tunion efl_core_int core_int;\n\t\tu64 value, offset;\n\n\t\toffset = EFL_CORE_INTX(i);\n\t\tcore_int.value = nitrox_read_csr(ndev, offset);\n\t\tnitrox_write_csr(ndev, offset, core_int.value);\n\t\tdev_err_ratelimited(DEV(ndev), \"ELF_CORE(%d)_INT  0x%016llx\\n\",\n\t\t\t\t    i, core_int.value);\n\t\tif (core_int.s.se_err) {\n\t\t\toffset = EFL_CORE_SE_ERR_INTX(i);\n\t\t\tvalue = nitrox_read_csr(ndev, offset);\n\t\t\tnitrox_write_csr(ndev, offset, value);\n\t\t}\n\t}\n}\n\nstatic void clear_bmi_err_intr(struct nitrox_device *ndev)\n{\n\tu64 value;\n\n\tvalue = nitrox_read_csr(ndev, BMI_INT);\n\tnitrox_write_csr(ndev, BMI_INT, value);\n\tdev_err_ratelimited(DEV(ndev), \"BMI_INT  0x%016llx\\n\", value);\n}\n\nstatic void nps_core_int_tasklet(unsigned long data)\n{\n\tstruct nitrox_q_vector *qvec = (void *)(uintptr_t)(data);\n\tstruct nitrox_device *ndev = qvec->ndev;\n\n\t \n\tif (ndev->mode == __NDEV_MODE_PF) {\n\t} else {\n\t\t \n\t}\n}\n\n \nstatic irqreturn_t nps_core_int_isr(int irq, void *data)\n{\n\tstruct nitrox_q_vector *qvec = data;\n\tstruct nitrox_device *ndev = qvec->ndev;\n\tunion nps_core_int_active core_int;\n\n\tcore_int.value = nitrox_read_csr(ndev, NPS_CORE_INT_ACTIVE);\n\n\tif (core_int.s.nps_core)\n\t\tclear_nps_core_err_intr(ndev);\n\n\tif (core_int.s.nps_pkt)\n\t\tclear_nps_pkt_err_intr(ndev);\n\n\tif (core_int.s.pom)\n\t\tclear_pom_err_intr(ndev);\n\n\tif (core_int.s.pem)\n\t\tclear_pem_err_intr(ndev);\n\n\tif (core_int.s.lbc)\n\t\tclear_lbc_err_intr(ndev);\n\n\tif (core_int.s.efl)\n\t\tclear_efl_err_intr(ndev);\n\n\tif (core_int.s.bmi)\n\t\tclear_bmi_err_intr(ndev);\n\n\t \n\tif (core_int.s.mbox)\n\t\tnitrox_pf2vf_mbox_handler(ndev);\n\n\t \n\tcore_int.s.resend = 1;\n\tnitrox_write_csr(ndev, NPS_CORE_INT_ACTIVE, core_int.value);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid nitrox_unregister_interrupts(struct nitrox_device *ndev)\n{\n\tstruct pci_dev *pdev = ndev->pdev;\n\tint i;\n\n\tfor (i = 0; i < ndev->num_vecs; i++) {\n\t\tstruct nitrox_q_vector *qvec;\n\t\tint vec;\n\n\t\tqvec = ndev->qvec + i;\n\t\tif (!qvec->valid)\n\t\t\tcontinue;\n\n\t\t \n\t\tvec = pci_irq_vector(pdev, i);\n\t\tirq_set_affinity_hint(vec, NULL);\n\t\tfree_irq(vec, qvec);\n\n\t\ttasklet_disable(&qvec->resp_tasklet);\n\t\ttasklet_kill(&qvec->resp_tasklet);\n\t\tqvec->valid = false;\n\t}\n\tkfree(ndev->qvec);\n\tndev->qvec = NULL;\n\tpci_free_irq_vectors(pdev);\n}\n\nint nitrox_register_interrupts(struct nitrox_device *ndev)\n{\n\tstruct pci_dev *pdev = ndev->pdev;\n\tstruct nitrox_q_vector *qvec;\n\tint nr_vecs, vec, cpu;\n\tint ret, i;\n\n\t \n\tnr_vecs = pci_msix_vec_count(pdev);\n\tif (nr_vecs < 0) {\n\t\tdev_err(DEV(ndev), \"Error in getting vec count %d\\n\", nr_vecs);\n\t\treturn nr_vecs;\n\t}\n\n\t \n\tret = pci_alloc_irq_vectors(pdev, nr_vecs, nr_vecs, PCI_IRQ_MSIX);\n\tif (ret < 0) {\n\t\tdev_err(DEV(ndev), \"msix vectors %d alloc failed\\n\", nr_vecs);\n\t\treturn ret;\n\t}\n\tndev->num_vecs = nr_vecs;\n\n\tndev->qvec = kcalloc(nr_vecs, sizeof(*qvec), GFP_KERNEL);\n\tif (!ndev->qvec) {\n\t\tpci_free_irq_vectors(pdev);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = PKT_RING_MSIX_BASE; i < (nr_vecs - 1); i += NR_RING_VECTORS) {\n\t\tqvec = &ndev->qvec[i];\n\n\t\tqvec->ring = i / NR_RING_VECTORS;\n\t\tif (qvec->ring >= ndev->nr_queues)\n\t\t\tbreak;\n\n\t\tqvec->cmdq = &ndev->pkt_inq[qvec->ring];\n\t\tsnprintf(qvec->name, IRQ_NAMESZ, \"nitrox-pkt%d\", qvec->ring);\n\t\t \n\t\tvec = pci_irq_vector(pdev, i);\n\t\tret = request_irq(vec, nps_pkt_slc_isr, 0, qvec->name, qvec);\n\t\tif (ret) {\n\t\t\tdev_err(DEV(ndev), \"irq failed for pkt ring/port%d\\n\",\n\t\t\t\tqvec->ring);\n\t\t\tgoto irq_fail;\n\t\t}\n\t\tcpu = qvec->ring % num_online_cpus();\n\t\tirq_set_affinity_hint(vec, get_cpu_mask(cpu));\n\n\t\ttasklet_init(&qvec->resp_tasklet, pkt_slc_resp_tasklet,\n\t\t\t     (unsigned long)qvec);\n\t\tqvec->valid = true;\n\t}\n\n\t \n\ti = NON_RING_MSIX_BASE;\n\tqvec = &ndev->qvec[i];\n\tqvec->ndev = ndev;\n\n\tsnprintf(qvec->name, IRQ_NAMESZ, \"nitrox-core-int%d\", i);\n\t \n\tvec = pci_irq_vector(pdev, i);\n\tret = request_irq(vec, nps_core_int_isr, 0, qvec->name, qvec);\n\tif (ret) {\n\t\tdev_err(DEV(ndev), \"irq failed for nitrox-core-int%d\\n\", i);\n\t\tgoto irq_fail;\n\t}\n\tcpu = num_online_cpus();\n\tirq_set_affinity_hint(vec, get_cpu_mask(cpu));\n\n\ttasklet_init(&qvec->resp_tasklet, nps_core_int_tasklet,\n\t\t     (unsigned long)qvec);\n\tqvec->valid = true;\n\n\treturn 0;\n\nirq_fail:\n\tnitrox_unregister_interrupts(ndev);\n\treturn ret;\n}\n\nvoid nitrox_sriov_unregister_interrupts(struct nitrox_device *ndev)\n{\n\tstruct pci_dev *pdev = ndev->pdev;\n\tint i;\n\n\tfor (i = 0; i < ndev->num_vecs; i++) {\n\t\tstruct nitrox_q_vector *qvec;\n\t\tint vec;\n\n\t\tqvec = ndev->qvec + i;\n\t\tif (!qvec->valid)\n\t\t\tcontinue;\n\n\t\tvec = ndev->iov.msix.vector;\n\t\tirq_set_affinity_hint(vec, NULL);\n\t\tfree_irq(vec, qvec);\n\n\t\ttasklet_disable(&qvec->resp_tasklet);\n\t\ttasklet_kill(&qvec->resp_tasklet);\n\t\tqvec->valid = false;\n\t}\n\tkfree(ndev->qvec);\n\tndev->qvec = NULL;\n\tpci_disable_msix(pdev);\n}\n\nint nitrox_sriov_register_interupts(struct nitrox_device *ndev)\n{\n\tstruct pci_dev *pdev = ndev->pdev;\n\tstruct nitrox_q_vector *qvec;\n\tint vec, cpu;\n\tint ret;\n\n\t \n\tndev->iov.msix.entry = NON_RING_MSIX_BASE;\n\tret = pci_enable_msix_exact(pdev, &ndev->iov.msix, NR_NON_RING_VECTORS);\n\tif (ret) {\n\t\tdev_err(DEV(ndev), \"failed to allocate nps-core-int%d\\n\",\n\t\t\tNON_RING_MSIX_BASE);\n\t\treturn ret;\n\t}\n\n\tqvec = kcalloc(NR_NON_RING_VECTORS, sizeof(*qvec), GFP_KERNEL);\n\tif (!qvec) {\n\t\tpci_disable_msix(pdev);\n\t\treturn -ENOMEM;\n\t}\n\tqvec->ndev = ndev;\n\n\tndev->qvec = qvec;\n\tndev->num_vecs = NR_NON_RING_VECTORS;\n\tsnprintf(qvec->name, IRQ_NAMESZ, \"nitrox-core-int%d\",\n\t\t NON_RING_MSIX_BASE);\n\n\tvec = ndev->iov.msix.vector;\n\tret = request_irq(vec, nps_core_int_isr, 0, qvec->name, qvec);\n\tif (ret) {\n\t\tdev_err(DEV(ndev), \"irq failed for nitrox-core-int%d\\n\",\n\t\t\tNON_RING_MSIX_BASE);\n\t\tgoto iov_irq_fail;\n\t}\n\tcpu = num_online_cpus();\n\tirq_set_affinity_hint(vec, get_cpu_mask(cpu));\n\n\ttasklet_init(&qvec->resp_tasklet, nps_core_int_tasklet,\n\t\t     (unsigned long)qvec);\n\tqvec->valid = true;\n\n\treturn 0;\n\niov_irq_fail:\n\tnitrox_sriov_unregister_interrupts(ndev);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}