{
  "module_name": "nitrox_main.c",
  "hash_id": "7b8c8e4611ca6d769f65a3c20480f454fc2a5206d89dc6b4151ba2714861caef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/cavium/nitrox/nitrox_main.c",
  "human_readable_source": "\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n\n#include \"nitrox_dev.h\"\n#include \"nitrox_common.h\"\n#include \"nitrox_csr.h\"\n#include \"nitrox_hal.h\"\n#include \"nitrox_isr.h\"\n#include \"nitrox_debugfs.h\"\n\n#define CNN55XX_DEV_ID\t0x12\n#define UCODE_HLEN 48\n#define DEFAULT_SE_GROUP 0\n#define DEFAULT_AE_GROUP 0\n\n#define DRIVER_VERSION \"1.2\"\n#define CNN55XX_UCD_BLOCK_SIZE 32768\n#define CNN55XX_MAX_UCODE_SIZE (CNN55XX_UCD_BLOCK_SIZE * 2)\n#define FW_DIR \"cavium/\"\n \n#define SE_FW\tFW_DIR \"cnn55xx_se.fw\"\n \n#define AE_FW\tFW_DIR \"cnn55xx_ae.fw\"\n\nstatic const char nitrox_driver_name[] = \"CNN55XX\";\n\nstatic LIST_HEAD(ndevlist);\nstatic DEFINE_MUTEX(devlist_lock);\nstatic unsigned int num_devices;\n\n \nstatic const struct pci_device_id nitrox_pci_tbl[] = {\n\t{PCI_VDEVICE(CAVIUM, CNN55XX_DEV_ID), 0},\n\t \n\t{0, }\n};\nMODULE_DEVICE_TABLE(pci, nitrox_pci_tbl);\n\nstatic unsigned int qlen = DEFAULT_CMD_QLEN;\nmodule_param(qlen, uint, 0644);\nMODULE_PARM_DESC(qlen, \"Command queue length - default 2048\");\n\n \nstruct ucode {\n\tu8 id;\n\tchar version[VERSION_LEN - 1];\n\t__be32 code_size;\n\tu8 raz[12];\n\tu64 code[];\n};\n\n \nstatic void write_to_ucd_unit(struct nitrox_device *ndev, u32 ucode_size,\n\t\t\t      u64 *ucode_data, int block_num)\n{\n\tu32 code_size;\n\tu64 offset, data;\n\tint i = 0;\n\n\t \n\n\t \n\toffset = UCD_UCODE_LOAD_BLOCK_NUM;\n\tnitrox_write_csr(ndev, offset, block_num);\n\n\tcode_size = roundup(ucode_size, 16);\n\twhile (code_size) {\n\t\tdata = ucode_data[i];\n\t\t \n\t\toffset = UCD_UCODE_LOAD_IDX_DATAX(i);\n\t\tnitrox_write_csr(ndev, offset, data);\n\t\tcode_size -= 8;\n\t\ti++;\n\t}\n\n\tusleep_range(300, 400);\n}\n\nstatic int nitrox_load_fw(struct nitrox_device *ndev)\n{\n\tconst struct firmware *fw;\n\tconst char *fw_name;\n\tstruct ucode *ucode;\n\tu64 *ucode_data;\n\tu64 offset;\n\tunion ucd_core_eid_ucode_block_num core_2_eid_val;\n\tunion aqm_grp_execmsk_lo aqm_grp_execmask_lo;\n\tunion aqm_grp_execmsk_hi aqm_grp_execmask_hi;\n\tu32 ucode_size;\n\tint ret, i = 0;\n\n\tfw_name = SE_FW;\n\tdev_info(DEV(ndev), \"Loading firmware \\\"%s\\\"\\n\", fw_name);\n\n\tret = request_firmware(&fw, fw_name, DEV(ndev));\n\tif (ret < 0) {\n\t\tdev_err(DEV(ndev), \"failed to get firmware %s\\n\", fw_name);\n\t\treturn ret;\n\t}\n\n\tucode = (struct ucode *)fw->data;\n\n\tucode_size = be32_to_cpu(ucode->code_size) * 2;\n\tif (!ucode_size || ucode_size > CNN55XX_MAX_UCODE_SIZE) {\n\t\tdev_err(DEV(ndev), \"Invalid ucode size: %u for firmware %s\\n\",\n\t\t\tucode_size, fw_name);\n\t\trelease_firmware(fw);\n\t\treturn -EINVAL;\n\t}\n\tucode_data = ucode->code;\n\n\t \n\tmemcpy(&ndev->hw.fw_name[0][0], ucode->version, (VERSION_LEN - 2));\n\tndev->hw.fw_name[0][VERSION_LEN - 1] = '\\0';\n\n\t \n\twrite_to_ucd_unit(ndev, ucode_size, ucode_data, 0);\n\n\trelease_firmware(fw);\n\n\t \n\toffset = POM_GRP_EXECMASKX(DEFAULT_SE_GROUP);\n\tnitrox_write_csr(ndev, offset, (~0ULL));\n\n\t \n\tcore_2_eid_val.value = 0ULL;\n\tcore_2_eid_val.ucode_blk = 0;\n\tif (ucode_size <= CNN55XX_UCD_BLOCK_SIZE)\n\t\tcore_2_eid_val.ucode_len = 1;\n\telse\n\t\tcore_2_eid_val.ucode_len = 0;\n\n\tfor (i = 0; i < ndev->hw.se_cores; i++) {\n\t\toffset = UCD_SE_EID_UCODE_BLOCK_NUMX(i);\n\t\tnitrox_write_csr(ndev, offset, core_2_eid_val.value);\n\t}\n\n\n\tfw_name = AE_FW;\n\tdev_info(DEV(ndev), \"Loading firmware \\\"%s\\\"\\n\", fw_name);\n\n\tret = request_firmware(&fw, fw_name, DEV(ndev));\n\tif (ret < 0) {\n\t\tdev_err(DEV(ndev), \"failed to get firmware %s\\n\", fw_name);\n\t\treturn ret;\n\t}\n\n\tucode = (struct ucode *)fw->data;\n\n\tucode_size = be32_to_cpu(ucode->code_size) * 2;\n\tif (!ucode_size || ucode_size > CNN55XX_MAX_UCODE_SIZE) {\n\t\tdev_err(DEV(ndev), \"Invalid ucode size: %u for firmware %s\\n\",\n\t\t\tucode_size, fw_name);\n\t\trelease_firmware(fw);\n\t\treturn -EINVAL;\n\t}\n\tucode_data = ucode->code;\n\n\t \n\tmemcpy(&ndev->hw.fw_name[1][0], ucode->version, (VERSION_LEN - 2));\n\tndev->hw.fw_name[1][VERSION_LEN - 1] = '\\0';\n\n\t \n\twrite_to_ucd_unit(ndev, ucode_size, ucode_data, 2);\n\n\trelease_firmware(fw);\n\n\t \n\toffset = AQM_GRP_EXECMSK_LOX(DEFAULT_AE_GROUP);\n\taqm_grp_execmask_lo.exec_0_to_39 = 0xFFFFFFFFFFULL;\n\tnitrox_write_csr(ndev, offset, aqm_grp_execmask_lo.value);\n\toffset = AQM_GRP_EXECMSK_HIX(DEFAULT_AE_GROUP);\n\taqm_grp_execmask_hi.exec_40_to_79 = 0xFFFFFFFFFFULL;\n\tnitrox_write_csr(ndev, offset, aqm_grp_execmask_hi.value);\n\n\t \n\tcore_2_eid_val.value = 0ULL;\n\tcore_2_eid_val.ucode_blk = 2;\n\tif (ucode_size <= CNN55XX_UCD_BLOCK_SIZE)\n\t\tcore_2_eid_val.ucode_len = 1;\n\telse\n\t\tcore_2_eid_val.ucode_len = 0;\n\n\tfor (i = 0; i < ndev->hw.ae_cores; i++) {\n\t\toffset = UCD_AE_EID_UCODE_BLOCK_NUMX(i);\n\t\tnitrox_write_csr(ndev, offset, core_2_eid_val.value);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int nitrox_add_to_devlist(struct nitrox_device *ndev)\n{\n\tstruct nitrox_device *dev;\n\tint ret = 0;\n\n\tINIT_LIST_HEAD(&ndev->list);\n\trefcount_set(&ndev->refcnt, 1);\n\n\tmutex_lock(&devlist_lock);\n\tlist_for_each_entry(dev, &ndevlist, list) {\n\t\tif (dev == ndev) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tndev->idx = num_devices++;\n\tlist_add_tail(&ndev->list, &ndevlist);\nunlock:\n\tmutex_unlock(&devlist_lock);\n\treturn ret;\n}\n\n \nstatic void nitrox_remove_from_devlist(struct nitrox_device *ndev)\n{\n\tmutex_lock(&devlist_lock);\n\tlist_del(&ndev->list);\n\tnum_devices--;\n\tmutex_unlock(&devlist_lock);\n}\n\nstruct nitrox_device *nitrox_get_first_device(void)\n{\n\tstruct nitrox_device *ndev = NULL, *iter;\n\n\tmutex_lock(&devlist_lock);\n\tlist_for_each_entry(iter, &ndevlist, list) {\n\t\tif (nitrox_ready(iter)) {\n\t\t\tndev = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&devlist_lock);\n\tif (!ndev)\n\t\treturn NULL;\n\n\trefcount_inc(&ndev->refcnt);\n\t \n\tsmp_mb__after_atomic();\n\treturn ndev;\n}\n\nvoid nitrox_put_device(struct nitrox_device *ndev)\n{\n\tif (!ndev)\n\t\treturn;\n\n\trefcount_dec(&ndev->refcnt);\n\t \n\tsmp_mb__after_atomic();\n}\n\nstatic int nitrox_device_flr(struct pci_dev *pdev)\n{\n\tint pos = 0;\n\n\tpos = pci_save_state(pdev);\n\tif (pos) {\n\t\tdev_err(&pdev->dev, \"Failed to save pci state\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpcie_reset_flr(pdev, PCI_RESET_DO_RESET);\n\n\tpci_restore_state(pdev);\n\n\treturn 0;\n}\n\nstatic int nitrox_pf_sw_init(struct nitrox_device *ndev)\n{\n\tint err;\n\n\terr = nitrox_common_sw_init(ndev);\n\tif (err)\n\t\treturn err;\n\n\terr = nitrox_register_interrupts(ndev);\n\tif (err)\n\t\tnitrox_common_sw_cleanup(ndev);\n\n\treturn err;\n}\n\nstatic void nitrox_pf_sw_cleanup(struct nitrox_device *ndev)\n{\n\tnitrox_unregister_interrupts(ndev);\n\tnitrox_common_sw_cleanup(ndev);\n}\n\n \nstatic int nitrox_bist_check(struct nitrox_device *ndev)\n{\n\tu64 value = 0;\n\tint i;\n\n\tfor (i = 0; i < NR_CLUSTERS; i++) {\n\t\tvalue += nitrox_read_csr(ndev, EMU_BIST_STATUSX(i));\n\t\tvalue += nitrox_read_csr(ndev, EFL_CORE_BIST_REGX(i));\n\t}\n\tvalue += nitrox_read_csr(ndev, UCD_BIST_STATUS);\n\tvalue += nitrox_read_csr(ndev, NPS_CORE_BIST_REG);\n\tvalue += nitrox_read_csr(ndev, NPS_CORE_NPC_BIST_REG);\n\tvalue += nitrox_read_csr(ndev, NPS_PKT_SLC_BIST_REG);\n\tvalue += nitrox_read_csr(ndev, NPS_PKT_IN_BIST_REG);\n\tvalue += nitrox_read_csr(ndev, POM_BIST_REG);\n\tvalue += nitrox_read_csr(ndev, BMI_BIST_REG);\n\tvalue += nitrox_read_csr(ndev, EFL_TOP_BIST_STAT);\n\tvalue += nitrox_read_csr(ndev, BMO_BIST_REG);\n\tvalue += nitrox_read_csr(ndev, LBC_BIST_STATUS);\n\tvalue += nitrox_read_csr(ndev, PEM_BIST_STATUSX(0));\n\tif (value)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int nitrox_pf_hw_init(struct nitrox_device *ndev)\n{\n\tint err;\n\n\terr = nitrox_bist_check(ndev);\n\tif (err) {\n\t\tdev_err(&ndev->pdev->dev, \"BIST check failed\\n\");\n\t\treturn err;\n\t}\n\t \n\tnitrox_get_hwinfo(ndev);\n\n\tnitrox_config_nps_core_unit(ndev);\n\tnitrox_config_aqm_unit(ndev);\n\tnitrox_config_nps_pkt_unit(ndev);\n\tnitrox_config_pom_unit(ndev);\n\tnitrox_config_efl_unit(ndev);\n\t \n\tnitrox_config_bmi_unit(ndev);\n\tnitrox_config_bmo_unit(ndev);\n\t \n\tnitrox_config_lbc_unit(ndev);\n\tnitrox_config_rand_unit(ndev);\n\n\t \n\terr = nitrox_load_fw(ndev);\n\tif (err)\n\t\treturn err;\n\n\tnitrox_config_emu_unit(ndev);\n\n\treturn 0;\n}\n\n \nstatic int nitrox_probe(struct pci_dev *pdev,\n\t\t\tconst struct pci_device_id *id)\n{\n\tstruct nitrox_device *ndev;\n\tint err;\n\n\tdev_info_once(&pdev->dev, \"%s driver version %s\\n\",\n\t\t      nitrox_driver_name, DRIVER_VERSION);\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = nitrox_device_flr(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"FLR failed\\n\");\n\t\tgoto flr_fail;\n\t}\n\n\tif (!dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64))) {\n\t\tdev_dbg(&pdev->dev, \"DMA to 64-BIT address\\n\");\n\t} else {\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"DMA configuration failed\\n\");\n\t\t\tgoto flr_fail;\n\t\t}\n\t}\n\n\terr = pci_request_mem_regions(pdev, nitrox_driver_name);\n\tif (err)\n\t\tgoto flr_fail;\n\tpci_set_master(pdev);\n\n\tndev = kzalloc(sizeof(*ndev), GFP_KERNEL);\n\tif (!ndev) {\n\t\terr = -ENOMEM;\n\t\tgoto ndev_fail;\n\t}\n\n\tpci_set_drvdata(pdev, ndev);\n\tndev->pdev = pdev;\n\n\t \n\tnitrox_add_to_devlist(ndev);\n\n\tndev->hw.vendor_id = pdev->vendor;\n\tndev->hw.device_id = pdev->device;\n\tndev->hw.revision_id = pdev->revision;\n\t \n\tndev->timeout = msecs_to_jiffies(CMD_TIMEOUT);\n\tndev->node = dev_to_node(&pdev->dev);\n\tif (ndev->node == NUMA_NO_NODE)\n\t\tndev->node = 0;\n\n\tndev->bar_addr = ioremap(pci_resource_start(pdev, 0),\n\t\t\t\t pci_resource_len(pdev, 0));\n\tif (!ndev->bar_addr) {\n\t\terr = -EIO;\n\t\tgoto ioremap_err;\n\t}\n\t \n\tndev->nr_queues = min_t(u32, MAX_PF_QUEUES, num_online_cpus());\n\tndev->qlen = qlen;\n\n\terr = nitrox_pf_sw_init(ndev);\n\tif (err)\n\t\tgoto pf_sw_fail;\n\n\terr = nitrox_pf_hw_init(ndev);\n\tif (err)\n\t\tgoto pf_hw_fail;\n\n\tnitrox_debugfs_init(ndev);\n\n\t \n\tatomic64_set(&ndev->stats.posted, 0);\n\tatomic64_set(&ndev->stats.completed, 0);\n\tatomic64_set(&ndev->stats.dropped, 0);\n\n\tatomic_set(&ndev->state, __NDEV_READY);\n\t \n\tsmp_mb__after_atomic();\n\n\terr = nitrox_crypto_register();\n\tif (err)\n\t\tgoto crypto_fail;\n\n\treturn 0;\n\ncrypto_fail:\n\tnitrox_debugfs_exit(ndev);\n\tatomic_set(&ndev->state, __NDEV_NOT_READY);\n\t \n\tsmp_mb__after_atomic();\npf_hw_fail:\n\tnitrox_pf_sw_cleanup(ndev);\npf_sw_fail:\n\tiounmap(ndev->bar_addr);\nioremap_err:\n\tnitrox_remove_from_devlist(ndev);\n\tkfree(ndev);\n\tpci_set_drvdata(pdev, NULL);\nndev_fail:\n\tpci_release_mem_regions(pdev);\nflr_fail:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\n \nstatic void nitrox_remove(struct pci_dev *pdev)\n{\n\tstruct nitrox_device *ndev = pci_get_drvdata(pdev);\n\n\tif (!ndev)\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&ndev->refcnt)) {\n\t\tdev_err(DEV(ndev), \"Device refcnt not zero (%d)\\n\",\n\t\t\trefcount_read(&ndev->refcnt));\n\t\treturn;\n\t}\n\n\tdev_info(DEV(ndev), \"Removing Device %x:%x\\n\",\n\t\t ndev->hw.vendor_id, ndev->hw.device_id);\n\n\tatomic_set(&ndev->state, __NDEV_NOT_READY);\n\t \n\tsmp_mb__after_atomic();\n\n\tnitrox_remove_from_devlist(ndev);\n\n\t \n\tnitrox_sriov_configure(pdev, 0);\n\tnitrox_crypto_unregister();\n\tnitrox_debugfs_exit(ndev);\n\tnitrox_pf_sw_cleanup(ndev);\n\n\tiounmap(ndev->bar_addr);\n\tkfree(ndev);\n\n\tpci_set_drvdata(pdev, NULL);\n\tpci_release_mem_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic void nitrox_shutdown(struct pci_dev *pdev)\n{\n\tpci_set_drvdata(pdev, NULL);\n\tpci_release_mem_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_driver nitrox_driver = {\n\t.name = nitrox_driver_name,\n\t.id_table = nitrox_pci_tbl,\n\t.probe = nitrox_probe,\n\t.remove\t= nitrox_remove,\n\t.shutdown = nitrox_shutdown,\n\t.sriov_configure = nitrox_sriov_configure,\n};\n\nmodule_pci_driver(nitrox_driver);\n\nMODULE_AUTHOR(\"Srikanth Jampala <Jampala.Srikanth@cavium.com>\");\nMODULE_DESCRIPTION(\"Cavium CNN55XX PF Driver\" DRIVER_VERSION \" \");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRIVER_VERSION);\nMODULE_FIRMWARE(SE_FW);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}