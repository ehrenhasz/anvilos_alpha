{
  "module_name": "nitrox_req.h",
  "hash_id": "85216ebf3795e4f45422e8731a9ac88427ea1fafd3d52cf60ffc530c55b2a412",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/cavium/nitrox/nitrox_req.h",
  "human_readable_source": " \n#ifndef __NITROX_REQ_H\n#define __NITROX_REQ_H\n\n#include <linux/dma-mapping.h>\n#include <crypto/aes.h>\n\n#include \"nitrox_dev.h\"\n\n#define PENDING_SIG\t0xFFFFFFFFFFFFFFFFUL\n#define PRIO 4001\n\ntypedef void (*sereq_completion_t)(void *req, int err);\n\n \nstruct gphdr {\n\t__be16 param0;\n\t__be16 param1;\n\t__be16 param2;\n\t__be16 param3;\n};\n\n \nunion se_req_ctrl {\n\tu64 value;\n\tstruct {\n\t\tu64 raz\t: 22;\n\t\tu64 arg\t: 8;\n\t\tu64 ctxc : 2;\n\t\tu64 unca : 1;\n\t\tu64 info : 3;\n\t\tu64 unc : 8;\n\t\tu64 ctxl : 12;\n\t\tu64 uddl : 8;\n\t} s;\n};\n\n#define MAX_IV_LEN 16\n\n \nstruct se_crypto_request {\n\tu8 opcode;\n\tgfp_t gfp;\n\tu32 flags;\n\tu64 ctx_handle;\n\n\tstruct gphdr gph;\n\tunion se_req_ctrl ctrl;\n\tu64 *orh;\n\tu64 *comp;\n\n\tstruct scatterlist *src;\n\tstruct scatterlist *dst;\n};\n\n \n#define FLEXI_CRYPTO_ENCRYPT_HMAC\t0x33\n#define ENCRYPT\t0\n#define DECRYPT 1\n\n \n#define IV_FROM_CTX\t0\n \n#define IV_FROM_DPTR\t1\n\n \nenum flexi_cipher {\n\tCIPHER_NULL = 0,\n\tCIPHER_3DES_CBC,\n\tCIPHER_3DES_ECB,\n\tCIPHER_AES_CBC,\n\tCIPHER_AES_ECB,\n\tCIPHER_AES_CFB,\n\tCIPHER_AES_CTR,\n\tCIPHER_AES_GCM,\n\tCIPHER_AES_XTS,\n\tCIPHER_AES_CCM,\n\tCIPHER_AES_CBC_CTS,\n\tCIPHER_AES_ECB_CTS,\n\tCIPHER_INVALID\n};\n\nenum flexi_auth {\n\tAUTH_NULL = 0,\n\tAUTH_MD5,\n\tAUTH_SHA1,\n\tAUTH_SHA2_SHA224,\n\tAUTH_SHA2_SHA256,\n\tAUTH_SHA2_SHA384,\n\tAUTH_SHA2_SHA512,\n\tAUTH_GMAC,\n\tAUTH_INVALID\n};\n\n \nstruct crypto_keys {\n\tunion {\n\t\tu8 key[AES_MAX_KEY_SIZE];\n\t\tu8 key1[AES_MAX_KEY_SIZE];\n\t} u;\n\tu8 iv[AES_BLOCK_SIZE];\n};\n\n \nstruct auth_keys {\n\tunion {\n\t\tu8 ipad[64];\n\t\tu8 key2[64];\n\t} u;\n\tu8 opad[64];\n};\n\nunion fc_ctx_flags {\n\t__be64 f;\n\tu64 fu;\n\tstruct {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t\tu64 cipher_type\t: 4;\n\t\tu64 reserved_59\t: 1;\n\t\tu64 aes_keylen : 2;\n\t\tu64 iv_source : 1;\n\t\tu64 hash_type : 4;\n\t\tu64 reserved_49_51 : 3;\n\t\tu64 auth_input_type: 1;\n\t\tu64 mac_len : 8;\n\t\tu64 reserved_0_39 : 40;\n#else\n\t\tu64 reserved_0_39 : 40;\n\t\tu64 mac_len : 8;\n\t\tu64 auth_input_type: 1;\n\t\tu64 reserved_49_51 : 3;\n\t\tu64 hash_type : 4;\n\t\tu64 iv_source : 1;\n\t\tu64 aes_keylen : 2;\n\t\tu64 reserved_59\t: 1;\n\t\tu64 cipher_type\t: 4;\n#endif\n\t} w0;\n};\n \nstruct flexi_crypto_context {\n\tunion fc_ctx_flags flags;\n\tstruct crypto_keys crypto;\n\tstruct auth_keys auth;\n};\n\nstruct crypto_ctx_hdr {\n\tstruct dma_pool *pool;\n\tdma_addr_t dma;\n\tvoid *vaddr;\n};\n\nstruct nitrox_crypto_ctx {\n\tstruct nitrox_device *ndev;\n\tunion {\n\t\tu64 ctx_handle;\n\t\tstruct flexi_crypto_context *fctx;\n\t} u;\n\tstruct crypto_ctx_hdr *chdr;\n\tsereq_completion_t callback;\n};\n\nstruct nitrox_kcrypt_request {\n\tstruct se_crypto_request creq;\n\tu8 *src;\n\tu8 *dst;\n\tu8 *iv_out;\n};\n\n \nstruct nitrox_aead_rctx {\n\tstruct nitrox_kcrypt_request nkreq;\n\tunsigned int cryptlen;\n\tunsigned int assoclen;\n\tunsigned int srclen;\n\tunsigned int dstlen;\n\tu8 *iv;\n\tint ivsize;\n\tu32 flags;\n\tu64 ctx_handle;\n\tstruct scatterlist *src;\n\tstruct scatterlist *dst;\n\tu8 ctrl_arg;\n};\n\n \nstruct nitrox_rfc4106_rctx {\n\tstruct nitrox_aead_rctx base;\n\tstruct scatterlist src[3];\n\tstruct scatterlist dst[3];\n\tu8 assoc[20];\n};\n\n \nunion pkt_instr_hdr {\n\t__be64 bev;\n\tu64 value;\n\tstruct {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t\tu64 raz_48_63 : 16;\n\t\tu64 g : 1;\n\t\tu64 gsz\t: 7;\n\t\tu64 ihi\t: 1;\n\t\tu64 ssz\t: 7;\n\t\tu64 raz_30_31 : 2;\n\t\tu64 fsz\t: 6;\n\t\tu64 raz_16_23 : 8;\n\t\tu64 tlen : 16;\n#else\n\t\tu64 tlen : 16;\n\t\tu64 raz_16_23 : 8;\n\t\tu64 fsz\t: 6;\n\t\tu64 raz_30_31 : 2;\n\t\tu64 ssz\t: 7;\n\t\tu64 ihi\t: 1;\n\t\tu64 gsz\t: 7;\n\t\tu64 g : 1;\n\t\tu64 raz_48_63 : 16;\n#endif\n\t} s;\n};\n\n \nunion pkt_hdr {\n\t__be64 bev[2];\n\tu64 value[2];\n\tstruct {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t\tu64 opcode : 8;\n\t\tu64 arg\t: 8;\n\t\tu64 ctxc : 2;\n\t\tu64 unca : 1;\n\t\tu64 raz_44 : 1;\n\t\tu64 info : 3;\n\t\tu64 destport : 9;\n\t\tu64 unc\t: 8;\n\t\tu64 raz_19_23 : 5;\n\t\tu64 grp\t: 3;\n\t\tu64 raz_15 : 1;\n\t\tu64 ctxl : 7;\n\t\tu64 uddl : 8;\n#else\n\t\tu64 uddl : 8;\n\t\tu64 ctxl : 7;\n\t\tu64 raz_15 : 1;\n\t\tu64 grp\t: 3;\n\t\tu64 raz_19_23 : 5;\n\t\tu64 unc\t: 8;\n\t\tu64 destport : 9;\n\t\tu64 info : 3;\n\t\tu64 raz_44 : 1;\n\t\tu64 unca : 1;\n\t\tu64 ctxc : 2;\n\t\tu64 arg\t: 8;\n\t\tu64 opcode : 8;\n#endif\n\t\t__be64 ctxp;\n\t} s;\n};\n\n \nunion slc_store_info {\n\t__be64 bev[2];\n\tu64 value[2];\n\tstruct {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t\tu64 raz_39_63 : 25;\n\t\tu64 ssz\t: 7;\n\t\tu64 raz_0_31 : 32;\n#else\n\t\tu64 raz_0_31 : 32;\n\t\tu64 ssz\t: 7;\n\t\tu64 raz_39_63 : 25;\n#endif\n\t\t__be64 rptr;\n\t} s;\n};\n\n \nstruct nps_pkt_instr {\n\t__be64 dptr0;\n\tunion pkt_instr_hdr ih;\n\tunion pkt_hdr irh;\n\tunion slc_store_info slc;\n\tu64 fdata[2];\n};\n\n \nstruct aqmq_command_s {\n\t__be16 opcode;\n\t__be16 param1;\n\t__be16 param2;\n\t__be16 dlen;\n\t__be64 dptr;\n\t__be64 rptr;\n\tunion {\n\t\t__be64 word3;\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t\tu64 grp : 3;\n\t\tu64 cptr : 61;\n#else\n\t\tu64 cptr : 61;\n\t\tu64 grp : 3;\n#endif\n\t};\n};\n\n \nstruct ctx_hdr {\n\tstruct dma_pool *pool;\n\tdma_addr_t dma;\n\tdma_addr_t ctx_dma;\n};\n\n \nstruct nitrox_sgcomp {\n\t__be16 len[4];\n\t__be64 dma[4];\n};\n\n \nstruct nitrox_sgtable {\n\tu8 sgmap_cnt;\n\tu16 total_bytes;\n\tu32 sgcomp_len;\n\tdma_addr_t sgcomp_dma;\n\tstruct scatterlist *sg;\n\tstruct nitrox_sgcomp *sgcomp;\n};\n\n \n#define ORH_HLEN\t8\n \n#define COMP_HLEN\t8\n\nstruct resp_hdr {\n\tu64 *orh;\n\tu64 *completion;\n};\n\ntypedef void (*completion_t)(void *arg, int err);\n\n \nstruct nitrox_softreq {\n\tstruct list_head response;\n\tstruct list_head backlog;\n\n\tu32 flags;\n\tgfp_t gfp;\n\tatomic_t status;\n\n\tstruct nitrox_device *ndev;\n\tstruct nitrox_cmdq *cmdq;\n\n\tstruct nps_pkt_instr instr;\n\tstruct resp_hdr resp;\n\tstruct nitrox_sgtable in;\n\tstruct nitrox_sgtable out;\n\n\tunsigned long tstamp;\n\n\tcompletion_t callback;\n\tvoid *cb_arg;\n};\n\nstatic inline int flexi_aes_keylen(int keylen)\n{\n\tint aes_keylen;\n\n\tswitch (keylen) {\n\tcase AES_KEYSIZE_128:\n\t\taes_keylen = 1;\n\t\tbreak;\n\tcase AES_KEYSIZE_192:\n\t\taes_keylen = 2;\n\t\tbreak;\n\tcase AES_KEYSIZE_256:\n\t\taes_keylen = 3;\n\t\tbreak;\n\tdefault:\n\t\taes_keylen = -EINVAL;\n\t\tbreak;\n\t}\n\treturn aes_keylen;\n}\n\nstatic inline void *alloc_req_buf(int nents, int extralen, gfp_t gfp)\n{\n\tsize_t size;\n\n\tsize = sizeof(struct scatterlist) * nents;\n\tsize += extralen;\n\n\treturn kzalloc(size, gfp);\n}\n\n \nstatic inline struct scatterlist *create_single_sg(struct scatterlist *sg,\n\t\t\t\t\t\t   void *buf, int buflen)\n{\n\tsg_set_buf(sg, buf, buflen);\n\tsg++;\n\treturn sg;\n}\n\n \nstatic inline struct scatterlist *create_multi_sg(struct scatterlist *to_sg,\n\t\t\t\t\t\t  struct scatterlist *from_sg,\n\t\t\t\t\t\t  int buflen)\n{\n\tstruct scatterlist *sg = to_sg;\n\tunsigned int sglen;\n\n\tfor (; buflen && from_sg; buflen -= sglen) {\n\t\tsglen = from_sg->length;\n\t\tif (sglen > buflen)\n\t\t\tsglen = buflen;\n\n\t\tsg_set_buf(sg, sg_virt(from_sg), sglen);\n\t\tfrom_sg = sg_next(from_sg);\n\t\tsg++;\n\t}\n\n\treturn sg;\n}\n\nstatic inline void set_orh_value(u64 *orh)\n{\n\tWRITE_ONCE(*orh, PENDING_SIG);\n}\n\nstatic inline void set_comp_value(u64 *comp)\n{\n\tWRITE_ONCE(*comp, PENDING_SIG);\n}\n\nstatic inline int alloc_src_req_buf(struct nitrox_kcrypt_request *nkreq,\n\t\t\t\t    int nents, int ivsize)\n{\n\tstruct se_crypto_request *creq = &nkreq->creq;\n\n\tnkreq->src = alloc_req_buf(nents, ivsize, creq->gfp);\n\tif (!nkreq->src)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic inline void nitrox_creq_copy_iv(char *dst, char *src, int size)\n{\n\tmemcpy(dst, src, size);\n}\n\nstatic inline struct scatterlist *nitrox_creq_src_sg(char *iv, int ivsize)\n{\n\treturn (struct scatterlist *)(iv + ivsize);\n}\n\nstatic inline void nitrox_creq_set_src_sg(struct nitrox_kcrypt_request *nkreq,\n\t\t\t\t\t  int nents, int ivsize,\n\t\t\t\t\t  struct scatterlist *src, int buflen)\n{\n\tchar *iv = nkreq->src;\n\tstruct scatterlist *sg;\n\tstruct se_crypto_request *creq = &nkreq->creq;\n\n\tcreq->src = nitrox_creq_src_sg(iv, ivsize);\n\tsg = creq->src;\n\tsg_init_table(sg, nents);\n\n\t \n\n\t \n\tsg = create_single_sg(sg, iv, ivsize);\n\t \n\tcreate_multi_sg(sg, src, buflen);\n}\n\nstatic inline int alloc_dst_req_buf(struct nitrox_kcrypt_request *nkreq,\n\t\t\t\t    int nents)\n{\n\tint extralen = ORH_HLEN + COMP_HLEN;\n\tstruct se_crypto_request *creq = &nkreq->creq;\n\n\tnkreq->dst = alloc_req_buf(nents, extralen, creq->gfp);\n\tif (!nkreq->dst)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic inline void nitrox_creq_set_orh(struct nitrox_kcrypt_request *nkreq)\n{\n\tstruct se_crypto_request *creq = &nkreq->creq;\n\n\tcreq->orh = (u64 *)(nkreq->dst);\n\tset_orh_value(creq->orh);\n}\n\nstatic inline void nitrox_creq_set_comp(struct nitrox_kcrypt_request *nkreq)\n{\n\tstruct se_crypto_request *creq = &nkreq->creq;\n\n\tcreq->comp = (u64 *)(nkreq->dst + ORH_HLEN);\n\tset_comp_value(creq->comp);\n}\n\nstatic inline struct scatterlist *nitrox_creq_dst_sg(char *dst)\n{\n\treturn (struct scatterlist *)(dst + ORH_HLEN + COMP_HLEN);\n}\n\nstatic inline void nitrox_creq_set_dst_sg(struct nitrox_kcrypt_request *nkreq,\n\t\t\t\t\t  int nents, int ivsize,\n\t\t\t\t\t  struct scatterlist *dst, int buflen)\n{\n\tstruct se_crypto_request *creq = &nkreq->creq;\n\tstruct scatterlist *sg;\n\tchar *iv = nkreq->src;\n\n\tcreq->dst = nitrox_creq_dst_sg(nkreq->dst);\n\tsg = creq->dst;\n\tsg_init_table(sg, nents);\n\n\t \n\n\t \n\tsg = create_single_sg(sg, creq->orh, ORH_HLEN);\n\t \n\tsg = create_single_sg(sg, iv, ivsize);\n\t \n\tsg = create_multi_sg(sg, dst, buflen);\n\t \n\tcreate_single_sg(sg, creq->comp, COMP_HLEN);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}