{
  "module_name": "exynos-rng.c",
  "hash_id": "5012023c53c3e855828f9a9ece057f76b50466cff2d244bc1064f1c757e06a49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/exynos-rng.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/crypto.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <crypto/internal/rng.h>\n\n#define EXYNOS_RNG_CONTROL\t\t0x0\n#define EXYNOS_RNG_STATUS\t\t0x10\n\n#define EXYNOS_RNG_SEED_CONF\t\t0x14\n#define EXYNOS_RNG_GEN_PRNG\t        BIT(1)\n\n#define EXYNOS_RNG_SEED_BASE\t\t0x140\n#define EXYNOS_RNG_SEED(n)\t\t(EXYNOS_RNG_SEED_BASE + (n * 0x4))\n#define EXYNOS_RNG_OUT_BASE\t\t0x160\n#define EXYNOS_RNG_OUT(n)\t\t(EXYNOS_RNG_OUT_BASE + (n * 0x4))\n\n \n#define EXYNOS_RNG_CONTROL_START\t0x18\n \n#define EXYNOS_RNG_STATUS_SEED_SETTING_DONE\tBIT(1)\n#define EXYNOS_RNG_STATUS_RNG_DONE\t\tBIT(5)\n\n \n#define EXYNOS_RNG_SEED_REGS\t\t5\n#define EXYNOS_RNG_SEED_SIZE\t\t(EXYNOS_RNG_SEED_REGS * 4)\n\nenum exynos_prng_type {\n\tEXYNOS_PRNG_UNKNOWN = 0,\n\tEXYNOS_PRNG_EXYNOS4,\n\tEXYNOS_PRNG_EXYNOS5,\n};\n\n \n#define EXYNOS_RNG_RESEED_TIME\t\t1000\n#define EXYNOS_RNG_RESEED_BYTES\t\t65536\n\n \n#define EXYNOS_RNG_WAIT_RETRIES\t\t100\n\n \nstruct exynos_rng_ctx {\n\tstruct exynos_rng_dev\t\t*rng;\n};\n\n \nstruct exynos_rng_dev {\n\tstruct device\t\t\t*dev;\n\tenum exynos_prng_type\t\ttype;\n\tvoid __iomem\t\t\t*mem;\n\tstruct clk\t\t\t*clk;\n\tstruct mutex \t\t\tlock;\n\t \n\tu8\t\t\t\tseed_save[EXYNOS_RNG_SEED_SIZE];\n\tunsigned int\t\t\tseed_save_len;\n\t \n\tunsigned long\t\t\tlast_seeding;\n\t \n\tunsigned long\t\t\tbytes_seeding;\n};\n\nstatic struct exynos_rng_dev *exynos_rng_dev;\n\nstatic u32 exynos_rng_readl(struct exynos_rng_dev *rng, u32 offset)\n{\n\treturn readl_relaxed(rng->mem + offset);\n}\n\nstatic void exynos_rng_writel(struct exynos_rng_dev *rng, u32 val, u32 offset)\n{\n\twritel_relaxed(val, rng->mem + offset);\n}\n\nstatic int exynos_rng_set_seed(struct exynos_rng_dev *rng,\n\t\t\t       const u8 *seed, unsigned int slen)\n{\n\tu32 val;\n\tint i;\n\n\t \n\tslen = ALIGN_DOWN(slen, 4);\n\n\tif (slen < EXYNOS_RNG_SEED_SIZE)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < slen ; i += 4) {\n\t\tunsigned int seed_reg = (i / 4) % EXYNOS_RNG_SEED_REGS;\n\n\t\tval = seed[i] << 24;\n\t\tval |= seed[i + 1] << 16;\n\t\tval |= seed[i + 2] << 8;\n\t\tval |= seed[i + 3] << 0;\n\n\t\texynos_rng_writel(rng, val, EXYNOS_RNG_SEED(seed_reg));\n\t}\n\n\tval = exynos_rng_readl(rng, EXYNOS_RNG_STATUS);\n\tif (!(val & EXYNOS_RNG_STATUS_SEED_SETTING_DONE)) {\n\t\tdev_warn(rng->dev, \"Seed setting not finished\\n\");\n\t\treturn -EIO;\n\t}\n\n\trng->last_seeding = jiffies;\n\trng->bytes_seeding = 0;\n\n\treturn 0;\n}\n\n \nstatic int exynos_rng_get_random(struct exynos_rng_dev *rng,\n\t\t\t\t u8 *dst, unsigned int dlen,\n\t\t\t\t unsigned int *read)\n{\n\tint retry = EXYNOS_RNG_WAIT_RETRIES;\n\n\tif (rng->type == EXYNOS_PRNG_EXYNOS4) {\n\t\texynos_rng_writel(rng, EXYNOS_RNG_CONTROL_START,\n\t\t\t\t  EXYNOS_RNG_CONTROL);\n\t} else if (rng->type == EXYNOS_PRNG_EXYNOS5) {\n\t\texynos_rng_writel(rng, EXYNOS_RNG_GEN_PRNG,\n\t\t\t\t  EXYNOS_RNG_SEED_CONF);\n\t}\n\n\twhile (!(exynos_rng_readl(rng,\n\t\t\tEXYNOS_RNG_STATUS) & EXYNOS_RNG_STATUS_RNG_DONE) && --retry)\n\t\tcpu_relax();\n\n\tif (!retry)\n\t\treturn -ETIMEDOUT;\n\n\t \n\texynos_rng_writel(rng, EXYNOS_RNG_STATUS_RNG_DONE,\n\t\t\t  EXYNOS_RNG_STATUS);\n\t*read = min_t(size_t, dlen, EXYNOS_RNG_SEED_SIZE);\n\tmemcpy_fromio(dst, rng->mem + EXYNOS_RNG_OUT_BASE, *read);\n\trng->bytes_seeding += *read;\n\n\treturn 0;\n}\n\n \nstatic void exynos_rng_reseed(struct exynos_rng_dev *rng)\n{\n\tunsigned long next_seeding = rng->last_seeding + \\\n\t\t\t\t     msecs_to_jiffies(EXYNOS_RNG_RESEED_TIME);\n\tunsigned long now = jiffies;\n\tunsigned int read = 0;\n\tu8 seed[EXYNOS_RNG_SEED_SIZE];\n\n\tif (time_before(now, next_seeding) &&\n\t    rng->bytes_seeding < EXYNOS_RNG_RESEED_BYTES)\n\t\treturn;\n\n\tif (exynos_rng_get_random(rng, seed, sizeof(seed), &read))\n\t\treturn;\n\n\texynos_rng_set_seed(rng, seed, read);\n\n\t \n\tmutex_unlock(&rng->lock);\n\tmutex_lock(&rng->lock);\n}\n\nstatic int exynos_rng_generate(struct crypto_rng *tfm,\n\t\t\t       const u8 *src, unsigned int slen,\n\t\t\t       u8 *dst, unsigned int dlen)\n{\n\tstruct exynos_rng_ctx *ctx = crypto_rng_ctx(tfm);\n\tstruct exynos_rng_dev *rng = ctx->rng;\n\tunsigned int read = 0;\n\tint ret;\n\n\tret = clk_prepare_enable(rng->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&rng->lock);\n\tdo {\n\t\tret = exynos_rng_get_random(rng, dst, dlen, &read);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tdlen -= read;\n\t\tdst += read;\n\n\t\texynos_rng_reseed(rng);\n\t} while (dlen > 0);\n\tmutex_unlock(&rng->lock);\n\n\tclk_disable_unprepare(rng->clk);\n\n\treturn ret;\n}\n\nstatic int exynos_rng_seed(struct crypto_rng *tfm, const u8 *seed,\n\t\t\t   unsigned int slen)\n{\n\tstruct exynos_rng_ctx *ctx = crypto_rng_ctx(tfm);\n\tstruct exynos_rng_dev *rng = ctx->rng;\n\tint ret;\n\n\tret = clk_prepare_enable(rng->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&rng->lock);\n\tret = exynos_rng_set_seed(ctx->rng, seed, slen);\n\tmutex_unlock(&rng->lock);\n\n\tclk_disable_unprepare(rng->clk);\n\n\treturn ret;\n}\n\nstatic int exynos_rng_kcapi_init(struct crypto_tfm *tfm)\n{\n\tstruct exynos_rng_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tctx->rng = exynos_rng_dev;\n\n\treturn 0;\n}\n\nstatic struct rng_alg exynos_rng_alg = {\n\t.generate\t\t= exynos_rng_generate,\n\t.seed\t\t\t= exynos_rng_seed,\n\t.seedsize\t\t= EXYNOS_RNG_SEED_SIZE,\n\t.base\t\t\t= {\n\t\t.cra_name\t\t= \"stdrng\",\n\t\t.cra_driver_name\t= \"exynos_rng\",\n\t\t.cra_priority\t\t= 300,\n\t\t.cra_ctxsize\t\t= sizeof(struct exynos_rng_ctx),\n\t\t.cra_module\t\t= THIS_MODULE,\n\t\t.cra_init\t\t= exynos_rng_kcapi_init,\n\t}\n};\n\nstatic int exynos_rng_probe(struct platform_device *pdev)\n{\n\tstruct exynos_rng_dev *rng;\n\tint ret;\n\n\tif (exynos_rng_dev)\n\t\treturn -EEXIST;\n\n\trng = devm_kzalloc(&pdev->dev, sizeof(*rng), GFP_KERNEL);\n\tif (!rng)\n\t\treturn -ENOMEM;\n\n\trng->type = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\tmutex_init(&rng->lock);\n\n\trng->dev = &pdev->dev;\n\trng->clk = devm_clk_get(&pdev->dev, \"secss\");\n\tif (IS_ERR(rng->clk)) {\n\t\tdev_err(&pdev->dev, \"Couldn't get clock.\\n\");\n\t\treturn PTR_ERR(rng->clk);\n\t}\n\n\trng->mem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rng->mem))\n\t\treturn PTR_ERR(rng->mem);\n\n\tplatform_set_drvdata(pdev, rng);\n\n\texynos_rng_dev = rng;\n\n\tret = crypto_register_rng(&exynos_rng_alg);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Couldn't register rng crypto alg: %d\\n\", ret);\n\t\texynos_rng_dev = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int exynos_rng_remove(struct platform_device *pdev)\n{\n\tcrypto_unregister_rng(&exynos_rng_alg);\n\n\texynos_rng_dev = NULL;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused exynos_rng_suspend(struct device *dev)\n{\n\tstruct exynos_rng_dev *rng = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tif (!rng->last_seeding)\n\t\treturn 0;\n\n\trng->seed_save_len = 0;\n\tret = clk_prepare_enable(rng->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&rng->lock);\n\n\t \n\texynos_rng_get_random(rng, rng->seed_save, sizeof(rng->seed_save),\n\t\t\t      &(rng->seed_save_len));\n\n\tmutex_unlock(&rng->lock);\n\n\tdev_dbg(rng->dev, \"Stored %u bytes for seeding on system resume\\n\",\n\t\trng->seed_save_len);\n\n\tclk_disable_unprepare(rng->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused exynos_rng_resume(struct device *dev)\n{\n\tstruct exynos_rng_dev *rng = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tif (!rng->last_seeding)\n\t\treturn 0;\n\n\tret = clk_prepare_enable(rng->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&rng->lock);\n\n\tret = exynos_rng_set_seed(rng, rng->seed_save, rng->seed_save_len);\n\n\tmutex_unlock(&rng->lock);\n\n\tclk_disable_unprepare(rng->clk);\n\n\treturn ret;\n}\n\nstatic SIMPLE_DEV_PM_OPS(exynos_rng_pm_ops, exynos_rng_suspend,\n\t\t\t exynos_rng_resume);\n\nstatic const struct of_device_id exynos_rng_dt_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos4-rng\",\n\t\t.data = (const void *)EXYNOS_PRNG_EXYNOS4,\n\t}, {\n\t\t.compatible = \"samsung,exynos5250-prng\",\n\t\t.data = (const void *)EXYNOS_PRNG_EXYNOS5,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, exynos_rng_dt_match);\n\nstatic struct platform_driver exynos_rng_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"exynos-rng\",\n\t\t.pm\t= &exynos_rng_pm_ops,\n\t\t.of_match_table = exynos_rng_dt_match,\n\t},\n\t.probe\t\t= exynos_rng_probe,\n\t.remove\t\t= exynos_rng_remove,\n};\n\nmodule_platform_driver(exynos_rng_driver);\n\nMODULE_DESCRIPTION(\"Exynos H/W Random Number Generator driver\");\nMODULE_AUTHOR(\"Krzysztof Kozlowski <krzk@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}