{
  "module_name": "ccp-crypto-aes-cmac.c",
  "hash_id": "561fad2d27df7c5c4947461f3e1a36cbf27102507ecabfe9cbac0fbdc2c10387",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/ccp-crypto-aes-cmac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <crypto/hash.h>\n#include <crypto/internal/hash.h>\n#include <crypto/scatterwalk.h>\n\n#include \"ccp-crypto.h\"\n\nstatic int ccp_aes_cmac_complete(struct crypto_async_request *async_req,\n\t\t\t\t int ret)\n{\n\tstruct ahash_request *req = ahash_request_cast(async_req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct ccp_aes_cmac_req_ctx *rctx = ahash_request_ctx_dma(req);\n\tunsigned int digest_size = crypto_ahash_digestsize(tfm);\n\n\tif (ret)\n\t\tgoto e_free;\n\n\tif (rctx->hash_rem) {\n\t\t \n\t\tunsigned int offset = rctx->nbytes - rctx->hash_rem;\n\n\t\tscatterwalk_map_and_copy(rctx->buf, rctx->src,\n\t\t\t\t\t offset, rctx->hash_rem, 0);\n\t\trctx->buf_count = rctx->hash_rem;\n\t} else {\n\t\trctx->buf_count = 0;\n\t}\n\n\t \n\tif (req->result && rctx->final)\n\t\tmemcpy(req->result, rctx->iv, digest_size);\n\ne_free:\n\tsg_free_table(&rctx->data_sg);\n\n\treturn ret;\n}\n\nstatic int ccp_do_cmac_update(struct ahash_request *req, unsigned int nbytes,\n\t\t\t      unsigned int final)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct ccp_ctx *ctx = crypto_ahash_ctx_dma(tfm);\n\tstruct ccp_aes_cmac_req_ctx *rctx = ahash_request_ctx_dma(req);\n\tstruct scatterlist *sg, *cmac_key_sg = NULL;\n\tunsigned int block_size =\n\t\tcrypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));\n\tunsigned int need_pad, sg_count;\n\tgfp_t gfp;\n\tu64 len;\n\tint ret;\n\n\tif (!ctx->u.aes.key_len)\n\t\treturn -EINVAL;\n\n\tif (nbytes)\n\t\trctx->null_msg = 0;\n\n\tlen = (u64)rctx->buf_count + (u64)nbytes;\n\n\tif (!final && (len <= block_size)) {\n\t\tscatterwalk_map_and_copy(rctx->buf + rctx->buf_count, req->src,\n\t\t\t\t\t 0, nbytes, 0);\n\t\trctx->buf_count += nbytes;\n\n\t\treturn 0;\n\t}\n\n\trctx->src = req->src;\n\trctx->nbytes = nbytes;\n\n\trctx->final = final;\n\trctx->hash_rem = final ? 0 : len & (block_size - 1);\n\trctx->hash_cnt = len - rctx->hash_rem;\n\tif (!final && !rctx->hash_rem) {\n\t\t \n\t\trctx->hash_cnt -= block_size;\n\t\trctx->hash_rem = block_size;\n\t}\n\n\tif (final && (rctx->null_msg || (len & (block_size - 1))))\n\t\tneed_pad = 1;\n\telse\n\t\tneed_pad = 0;\n\n\tsg_init_one(&rctx->iv_sg, rctx->iv, sizeof(rctx->iv));\n\n\t \n\tsg_count = (nbytes) ? sg_nents(req->src) + 2 : 2;\n\tgfp = req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP ?\n\t\tGFP_KERNEL : GFP_ATOMIC;\n\tret = sg_alloc_table(&rctx->data_sg, sg_count, gfp);\n\tif (ret)\n\t\treturn ret;\n\n\tsg = NULL;\n\tif (rctx->buf_count) {\n\t\tsg_init_one(&rctx->buf_sg, rctx->buf, rctx->buf_count);\n\t\tsg = ccp_crypto_sg_table_add(&rctx->data_sg, &rctx->buf_sg);\n\t\tif (!sg) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_free;\n\t\t}\n\t}\n\n\tif (nbytes) {\n\t\tsg = ccp_crypto_sg_table_add(&rctx->data_sg, req->src);\n\t\tif (!sg) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_free;\n\t\t}\n\t}\n\n\tif (need_pad) {\n\t\tint pad_length = block_size - (len & (block_size - 1));\n\n\t\trctx->hash_cnt += pad_length;\n\n\t\tmemset(rctx->pad, 0, sizeof(rctx->pad));\n\t\trctx->pad[0] = 0x80;\n\t\tsg_init_one(&rctx->pad_sg, rctx->pad, pad_length);\n\t\tsg = ccp_crypto_sg_table_add(&rctx->data_sg, &rctx->pad_sg);\n\t\tif (!sg) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_free;\n\t\t}\n\t}\n\tif (sg) {\n\t\tsg_mark_end(sg);\n\t\tsg = rctx->data_sg.sgl;\n\t}\n\n\t \n\tif (final)\n\t\tcmac_key_sg = (need_pad) ? &ctx->u.aes.k2_sg\n\t\t\t\t\t : &ctx->u.aes.k1_sg;\n\n\tmemset(&rctx->cmd, 0, sizeof(rctx->cmd));\n\tINIT_LIST_HEAD(&rctx->cmd.entry);\n\trctx->cmd.engine = CCP_ENGINE_AES;\n\trctx->cmd.u.aes.type = ctx->u.aes.type;\n\trctx->cmd.u.aes.mode = ctx->u.aes.mode;\n\trctx->cmd.u.aes.action = CCP_AES_ACTION_ENCRYPT;\n\trctx->cmd.u.aes.key = &ctx->u.aes.key_sg;\n\trctx->cmd.u.aes.key_len = ctx->u.aes.key_len;\n\trctx->cmd.u.aes.iv = &rctx->iv_sg;\n\trctx->cmd.u.aes.iv_len = AES_BLOCK_SIZE;\n\trctx->cmd.u.aes.src = sg;\n\trctx->cmd.u.aes.src_len = rctx->hash_cnt;\n\trctx->cmd.u.aes.dst = NULL;\n\trctx->cmd.u.aes.cmac_key = cmac_key_sg;\n\trctx->cmd.u.aes.cmac_key_len = ctx->u.aes.kn_len;\n\trctx->cmd.u.aes.cmac_final = final;\n\n\tret = ccp_crypto_enqueue_request(&req->base, &rctx->cmd);\n\n\treturn ret;\n\ne_free:\n\tsg_free_table(&rctx->data_sg);\n\n\treturn ret;\n}\n\nstatic int ccp_aes_cmac_init(struct ahash_request *req)\n{\n\tstruct ccp_aes_cmac_req_ctx *rctx = ahash_request_ctx_dma(req);\n\n\tmemset(rctx, 0, sizeof(*rctx));\n\n\trctx->null_msg = 1;\n\n\treturn 0;\n}\n\nstatic int ccp_aes_cmac_update(struct ahash_request *req)\n{\n\treturn ccp_do_cmac_update(req, req->nbytes, 0);\n}\n\nstatic int ccp_aes_cmac_final(struct ahash_request *req)\n{\n\treturn ccp_do_cmac_update(req, 0, 1);\n}\n\nstatic int ccp_aes_cmac_finup(struct ahash_request *req)\n{\n\treturn ccp_do_cmac_update(req, req->nbytes, 1);\n}\n\nstatic int ccp_aes_cmac_digest(struct ahash_request *req)\n{\n\tint ret;\n\n\tret = ccp_aes_cmac_init(req);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ccp_aes_cmac_finup(req);\n}\n\nstatic int ccp_aes_cmac_export(struct ahash_request *req, void *out)\n{\n\tstruct ccp_aes_cmac_req_ctx *rctx = ahash_request_ctx_dma(req);\n\tstruct ccp_aes_cmac_exp_ctx state;\n\n\t \n\tmemset(&state, 0, sizeof(state));\n\n\tstate.null_msg = rctx->null_msg;\n\tmemcpy(state.iv, rctx->iv, sizeof(state.iv));\n\tstate.buf_count = rctx->buf_count;\n\tmemcpy(state.buf, rctx->buf, sizeof(state.buf));\n\n\t \n\tmemcpy(out, &state, sizeof(state));\n\n\treturn 0;\n}\n\nstatic int ccp_aes_cmac_import(struct ahash_request *req, const void *in)\n{\n\tstruct ccp_aes_cmac_req_ctx *rctx = ahash_request_ctx_dma(req);\n\tstruct ccp_aes_cmac_exp_ctx state;\n\n\t \n\tmemcpy(&state, in, sizeof(state));\n\n\tmemset(rctx, 0, sizeof(*rctx));\n\trctx->null_msg = state.null_msg;\n\tmemcpy(rctx->iv, state.iv, sizeof(rctx->iv));\n\trctx->buf_count = state.buf_count;\n\tmemcpy(rctx->buf, state.buf, sizeof(rctx->buf));\n\n\treturn 0;\n}\n\nstatic int ccp_aes_cmac_setkey(struct crypto_ahash *tfm, const u8 *key,\n\t\t\t       unsigned int key_len)\n{\n\tstruct ccp_ctx *ctx = crypto_ahash_ctx_dma(tfm);\n\tstruct ccp_crypto_ahash_alg *alg =\n\t\tccp_crypto_ahash_alg(crypto_ahash_tfm(tfm));\n\tu64 k0_hi, k0_lo, k1_hi, k1_lo, k2_hi, k2_lo;\n\tu64 rb_hi = 0x00, rb_lo = 0x87;\n\tstruct crypto_aes_ctx aes;\n\t__be64 *gk;\n\tint ret;\n\n\tswitch (key_len) {\n\tcase AES_KEYSIZE_128:\n\t\tctx->u.aes.type = CCP_AES_TYPE_128;\n\t\tbreak;\n\tcase AES_KEYSIZE_192:\n\t\tctx->u.aes.type = CCP_AES_TYPE_192;\n\t\tbreak;\n\tcase AES_KEYSIZE_256:\n\t\tctx->u.aes.type = CCP_AES_TYPE_256;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tctx->u.aes.mode = alg->mode;\n\n\t \n\tctx->u.aes.key_len = 0;\n\n\t \n\tret = aes_expandkey(&aes, key, key_len);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmemset(ctx->u.aes.key, 0, sizeof(ctx->u.aes.key));\n\taes_encrypt(&aes, ctx->u.aes.key, ctx->u.aes.key);\n\tmemzero_explicit(&aes, sizeof(aes));\n\n\t \n\tk0_hi = be64_to_cpu(*((__be64 *)ctx->u.aes.key));\n\tk0_lo = be64_to_cpu(*((__be64 *)ctx->u.aes.key + 1));\n\n\tk1_hi = (k0_hi << 1) | (k0_lo >> 63);\n\tk1_lo = k0_lo << 1;\n\tif (ctx->u.aes.key[0] & 0x80) {\n\t\tk1_hi ^= rb_hi;\n\t\tk1_lo ^= rb_lo;\n\t}\n\tgk = (__be64 *)ctx->u.aes.k1;\n\t*gk = cpu_to_be64(k1_hi);\n\tgk++;\n\t*gk = cpu_to_be64(k1_lo);\n\n\tk2_hi = (k1_hi << 1) | (k1_lo >> 63);\n\tk2_lo = k1_lo << 1;\n\tif (ctx->u.aes.k1[0] & 0x80) {\n\t\tk2_hi ^= rb_hi;\n\t\tk2_lo ^= rb_lo;\n\t}\n\tgk = (__be64 *)ctx->u.aes.k2;\n\t*gk = cpu_to_be64(k2_hi);\n\tgk++;\n\t*gk = cpu_to_be64(k2_lo);\n\n\tctx->u.aes.kn_len = sizeof(ctx->u.aes.k1);\n\tsg_init_one(&ctx->u.aes.k1_sg, ctx->u.aes.k1, sizeof(ctx->u.aes.k1));\n\tsg_init_one(&ctx->u.aes.k2_sg, ctx->u.aes.k2, sizeof(ctx->u.aes.k2));\n\n\t \n\tmemset(ctx->u.aes.key, 0, sizeof(ctx->u.aes.key));\n\tmemcpy(ctx->u.aes.key, key, key_len);\n\tctx->u.aes.key_len = key_len;\n\tsg_init_one(&ctx->u.aes.key_sg, ctx->u.aes.key, key_len);\n\n\treturn ret;\n}\n\nstatic int ccp_aes_cmac_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct ccp_ctx *ctx = crypto_tfm_ctx_dma(tfm);\n\tstruct crypto_ahash *ahash = __crypto_ahash_cast(tfm);\n\n\tctx->complete = ccp_aes_cmac_complete;\n\tctx->u.aes.key_len = 0;\n\n\tcrypto_ahash_set_reqsize_dma(ahash,\n\t\t\t\t     sizeof(struct ccp_aes_cmac_req_ctx));\n\n\treturn 0;\n}\n\nint ccp_register_aes_cmac_algs(struct list_head *head)\n{\n\tstruct ccp_crypto_ahash_alg *ccp_alg;\n\tstruct ahash_alg *alg;\n\tstruct hash_alg_common *halg;\n\tstruct crypto_alg *base;\n\tint ret;\n\n\tccp_alg = kzalloc(sizeof(*ccp_alg), GFP_KERNEL);\n\tif (!ccp_alg)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ccp_alg->entry);\n\tccp_alg->mode = CCP_AES_MODE_CMAC;\n\n\talg = &ccp_alg->alg;\n\talg->init = ccp_aes_cmac_init;\n\talg->update = ccp_aes_cmac_update;\n\talg->final = ccp_aes_cmac_final;\n\talg->finup = ccp_aes_cmac_finup;\n\talg->digest = ccp_aes_cmac_digest;\n\talg->export = ccp_aes_cmac_export;\n\talg->import = ccp_aes_cmac_import;\n\talg->setkey = ccp_aes_cmac_setkey;\n\n\thalg = &alg->halg;\n\thalg->digestsize = AES_BLOCK_SIZE;\n\thalg->statesize = sizeof(struct ccp_aes_cmac_exp_ctx);\n\n\tbase = &halg->base;\n\tsnprintf(base->cra_name, CRYPTO_MAX_ALG_NAME, \"cmac(aes)\");\n\tsnprintf(base->cra_driver_name, CRYPTO_MAX_ALG_NAME, \"cmac-aes-ccp\");\n\tbase->cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t  CRYPTO_ALG_NEED_FALLBACK;\n\tbase->cra_blocksize = AES_BLOCK_SIZE;\n\tbase->cra_ctxsize = sizeof(struct ccp_ctx) + crypto_dma_padding();\n\tbase->cra_priority = CCP_CRA_PRIORITY;\n\tbase->cra_init = ccp_aes_cmac_cra_init;\n\tbase->cra_module = THIS_MODULE;\n\n\tret = crypto_register_ahash(alg);\n\tif (ret) {\n\t\tpr_err(\"%s ahash algorithm registration error (%d)\\n\",\n\t\t       base->cra_name, ret);\n\t\tkfree(ccp_alg);\n\t\treturn ret;\n\t}\n\n\tlist_add(&ccp_alg->entry, head);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}