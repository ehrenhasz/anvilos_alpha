{
  "module_name": "ccp-debugfs.c",
  "hash_id": "b2a18fb45ae7132218b6b89942531e86364a5cb13537afdeb662b872ee43f0ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/ccp-debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/ccp.h>\n\n#include \"ccp-dev.h\"\n\n \n#define\tOBUFP\t\t(obuf + oboff)\n#define\tOBUFLEN\t\t512\n#define\tOBUFSPC\t\t(OBUFLEN - oboff)\n#define\tOSCNPRINTF(fmt, ...) \\\n\t\tscnprintf(OBUFP, OBUFSPC, fmt, ## __VA_ARGS__)\n\n#define BUFLEN\t63\n\n#define\tRI_VERSION_NUM\t0x0000003F\n#define\tRI_AES_PRESENT\t0x00000040\n#define\tRI_3DES_PRESENT\t0x00000080\n#define\tRI_SHA_PRESENT\t0x00000100\n#define\tRI_RSA_PRESENT\t0x00000200\n#define\tRI_ECC_PRESENT\t0x00000400\n#define\tRI_ZDE_PRESENT\t0x00000800\n#define\tRI_ZCE_PRESENT\t0x00001000\n#define\tRI_TRNG_PRESENT\t0x00002000\n#define\tRI_ELFC_PRESENT\t0x00004000\n#define\tRI_ELFC_SHIFT\t14\n#define\tRI_NUM_VQM\t0x00078000\n#define\tRI_NVQM_SHIFT\t15\n#define\tRI_NVQM(r)\t(((r) * RI_NUM_VQM) >> RI_NVQM_SHIFT)\n#define\tRI_LSB_ENTRIES\t0x0FF80000\n#define\tRI_NLSB_SHIFT\t19\n#define\tRI_NLSB(r)\t(((r) * RI_LSB_ENTRIES) >> RI_NLSB_SHIFT)\n\nstatic ssize_t ccp5_debugfs_info_read(struct file *filp, char __user *ubuf,\n\t\t\t\t      size_t count, loff_t *offp)\n{\n\tstruct ccp_device *ccp = filp->private_data;\n\tunsigned int oboff = 0;\n\tunsigned int regval;\n\tssize_t ret;\n\tchar *obuf;\n\n\tif (!ccp)\n\t\treturn 0;\n\n\tobuf = kmalloc(OBUFLEN, GFP_KERNEL);\n\tif (!obuf)\n\t\treturn -ENOMEM;\n\n\toboff += OSCNPRINTF(\"Device name: %s\\n\", ccp->name);\n\toboff += OSCNPRINTF(\"   RNG name: %s\\n\", ccp->rngname);\n\toboff += OSCNPRINTF(\"   # Queues: %d\\n\", ccp->cmd_q_count);\n\toboff += OSCNPRINTF(\"     # Cmds: %d\\n\", ccp->cmd_count);\n\n\tregval = ioread32(ccp->io_regs + CMD5_PSP_CCP_VERSION);\n\toboff += OSCNPRINTF(\"    Version: %d\\n\", regval & RI_VERSION_NUM);\n\toboff += OSCNPRINTF(\"    Engines:\");\n\tif (regval & RI_AES_PRESENT)\n\t\toboff += OSCNPRINTF(\" AES\");\n\tif (regval & RI_3DES_PRESENT)\n\t\toboff += OSCNPRINTF(\" 3DES\");\n\tif (regval & RI_SHA_PRESENT)\n\t\toboff += OSCNPRINTF(\" SHA\");\n\tif (regval & RI_RSA_PRESENT)\n\t\toboff += OSCNPRINTF(\" RSA\");\n\tif (regval & RI_ECC_PRESENT)\n\t\toboff += OSCNPRINTF(\" ECC\");\n\tif (regval & RI_ZDE_PRESENT)\n\t\toboff += OSCNPRINTF(\" ZDE\");\n\tif (regval & RI_ZCE_PRESENT)\n\t\toboff += OSCNPRINTF(\" ZCE\");\n\tif (regval & RI_TRNG_PRESENT)\n\t\toboff += OSCNPRINTF(\" TRNG\");\n\toboff += OSCNPRINTF(\"\\n\");\n\toboff += OSCNPRINTF(\"     Queues: %d\\n\",\n\t\t   (regval & RI_NUM_VQM) >> RI_NVQM_SHIFT);\n\toboff += OSCNPRINTF(\"LSB Entries: %d\\n\",\n\t\t   (regval & RI_LSB_ENTRIES) >> RI_NLSB_SHIFT);\n\n\tret = simple_read_from_buffer(ubuf, count, offp, obuf, oboff);\n\tkfree(obuf);\n\n\treturn ret;\n}\n\n \nstatic ssize_t ccp5_debugfs_stats_read(struct file *filp, char __user *ubuf,\n\t\t\t\t       size_t count, loff_t *offp)\n{\n\tstruct ccp_device *ccp = filp->private_data;\n\tunsigned long total_xts_aes_ops = 0;\n\tunsigned long total_3des_ops = 0;\n\tunsigned long total_aes_ops = 0;\n\tunsigned long total_sha_ops = 0;\n\tunsigned long total_rsa_ops = 0;\n\tunsigned long total_ecc_ops = 0;\n\tunsigned long total_pt_ops = 0;\n\tunsigned long total_ops = 0;\n\tunsigned int oboff = 0;\n\tssize_t ret = 0;\n\tunsigned int i;\n\tchar *obuf;\n\n\tfor (i = 0; i < ccp->cmd_q_count; i++) {\n\t\tstruct ccp_cmd_queue *cmd_q = &ccp->cmd_q[i];\n\n\t\ttotal_ops += cmd_q->total_ops;\n\t\ttotal_aes_ops += cmd_q->total_aes_ops;\n\t\ttotal_xts_aes_ops += cmd_q->total_xts_aes_ops;\n\t\ttotal_3des_ops += cmd_q->total_3des_ops;\n\t\ttotal_sha_ops += cmd_q->total_sha_ops;\n\t\ttotal_rsa_ops += cmd_q->total_rsa_ops;\n\t\ttotal_pt_ops += cmd_q->total_pt_ops;\n\t\ttotal_ecc_ops += cmd_q->total_ecc_ops;\n\t}\n\n\tobuf = kmalloc(OBUFLEN, GFP_KERNEL);\n\tif (!obuf)\n\t\treturn -ENOMEM;\n\n\toboff += OSCNPRINTF(\"Total Interrupts Handled: %ld\\n\",\n\t\t\t    ccp->total_interrupts);\n\toboff += OSCNPRINTF(\"        Total Operations: %ld\\n\",\n\t\t\t    total_ops);\n\toboff += OSCNPRINTF(\"                     AES: %ld\\n\",\n\t\t\t    total_aes_ops);\n\toboff += OSCNPRINTF(\"                 XTS AES: %ld\\n\",\n\t\t\t    total_xts_aes_ops);\n\toboff += OSCNPRINTF(\"                     SHA: %ld\\n\",\n\t\t\t    total_3des_ops);\n\toboff += OSCNPRINTF(\"                     SHA: %ld\\n\",\n\t\t\t    total_sha_ops);\n\toboff += OSCNPRINTF(\"                     RSA: %ld\\n\",\n\t\t\t    total_rsa_ops);\n\toboff += OSCNPRINTF(\"               Pass-Thru: %ld\\n\",\n\t\t\t    total_pt_ops);\n\toboff += OSCNPRINTF(\"                     ECC: %ld\\n\",\n\t\t\t    total_ecc_ops);\n\n\tret = simple_read_from_buffer(ubuf, count, offp, obuf, oboff);\n\tkfree(obuf);\n\n\treturn ret;\n}\n\n \nstatic void ccp5_debugfs_reset_queue_stats(struct ccp_cmd_queue *cmd_q)\n{\n\tcmd_q->total_ops = 0L;\n\tcmd_q->total_aes_ops = 0L;\n\tcmd_q->total_xts_aes_ops = 0L;\n\tcmd_q->total_3des_ops = 0L;\n\tcmd_q->total_sha_ops = 0L;\n\tcmd_q->total_rsa_ops = 0L;\n\tcmd_q->total_pt_ops = 0L;\n\tcmd_q->total_ecc_ops = 0L;\n}\n\n \nstatic ssize_t ccp5_debugfs_stats_write(struct file *filp,\n\t\t\t\t\tconst char __user *ubuf,\n\t\t\t\t\tsize_t count, loff_t *offp)\n{\n\tstruct ccp_device *ccp = filp->private_data;\n\tint i;\n\n\tfor (i = 0; i < ccp->cmd_q_count; i++)\n\t\tccp5_debugfs_reset_queue_stats(&ccp->cmd_q[i]);\n\tccp->total_interrupts = 0L;\n\n\treturn count;\n}\n\n \nstatic ssize_t ccp5_debugfs_queue_read(struct file *filp, char __user *ubuf,\n\t\t\t\t       size_t count, loff_t *offp)\n{\n\tstruct ccp_cmd_queue *cmd_q = filp->private_data;\n\tunsigned int oboff = 0;\n\tunsigned int regval;\n\tssize_t ret;\n\tchar *obuf;\n\n\tif (!cmd_q)\n\t\treturn 0;\n\n\tobuf = kmalloc(OBUFLEN, GFP_KERNEL);\n\tif (!obuf)\n\t\treturn -ENOMEM;\n\n\toboff += OSCNPRINTF(\"  Total Queue Operations: %ld\\n\",\n\t\t\t    cmd_q->total_ops);\n\toboff += OSCNPRINTF(\"                     AES: %ld\\n\",\n\t\t\t    cmd_q->total_aes_ops);\n\toboff += OSCNPRINTF(\"                 XTS AES: %ld\\n\",\n\t\t\t    cmd_q->total_xts_aes_ops);\n\toboff += OSCNPRINTF(\"                     SHA: %ld\\n\",\n\t\t\t    cmd_q->total_3des_ops);\n\toboff += OSCNPRINTF(\"                     SHA: %ld\\n\",\n\t\t\t    cmd_q->total_sha_ops);\n\toboff += OSCNPRINTF(\"                     RSA: %ld\\n\",\n\t\t\t    cmd_q->total_rsa_ops);\n\toboff += OSCNPRINTF(\"               Pass-Thru: %ld\\n\",\n\t\t\t    cmd_q->total_pt_ops);\n\toboff += OSCNPRINTF(\"                     ECC: %ld\\n\",\n\t\t\t    cmd_q->total_ecc_ops);\n\n\tregval = ioread32(cmd_q->reg_int_enable);\n\toboff += OSCNPRINTF(\"      Enabled Interrupts:\");\n\tif (regval & INT_EMPTY_QUEUE)\n\t\toboff += OSCNPRINTF(\" EMPTY\");\n\tif (regval & INT_QUEUE_STOPPED)\n\t\toboff += OSCNPRINTF(\" STOPPED\");\n\tif (regval & INT_ERROR)\n\t\toboff += OSCNPRINTF(\" ERROR\");\n\tif (regval & INT_COMPLETION)\n\t\toboff += OSCNPRINTF(\" COMPLETION\");\n\toboff += OSCNPRINTF(\"\\n\");\n\n\tret = simple_read_from_buffer(ubuf, count, offp, obuf, oboff);\n\tkfree(obuf);\n\n\treturn ret;\n}\n\n \nstatic ssize_t ccp5_debugfs_queue_write(struct file *filp,\n\t\t\t\t\tconst char __user *ubuf,\n\t\t\t\t\tsize_t count, loff_t *offp)\n{\n\tstruct ccp_cmd_queue *cmd_q = filp->private_data;\n\n\tccp5_debugfs_reset_queue_stats(cmd_q);\n\n\treturn count;\n}\n\nstatic const struct file_operations ccp_debugfs_info_ops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = ccp5_debugfs_info_read,\n\t.write = NULL,\n};\n\nstatic const struct file_operations ccp_debugfs_queue_ops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = ccp5_debugfs_queue_read,\n\t.write = ccp5_debugfs_queue_write,\n};\n\nstatic const struct file_operations ccp_debugfs_stats_ops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = ccp5_debugfs_stats_read,\n\t.write = ccp5_debugfs_stats_write,\n};\n\nstatic struct dentry *ccp_debugfs_dir;\nstatic DEFINE_MUTEX(ccp_debugfs_lock);\n\n#define\tMAX_NAME_LEN\t20\n\nvoid ccp5_debugfs_setup(struct ccp_device *ccp)\n{\n\tstruct ccp_cmd_queue *cmd_q;\n\tchar name[MAX_NAME_LEN + 1];\n\tstruct dentry *debugfs_q_instance;\n\tint i;\n\n\tif (!debugfs_initialized())\n\t\treturn;\n\n\tmutex_lock(&ccp_debugfs_lock);\n\tif (!ccp_debugfs_dir)\n\t\tccp_debugfs_dir = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\tmutex_unlock(&ccp_debugfs_lock);\n\n\tccp->debugfs_instance = debugfs_create_dir(ccp->name, ccp_debugfs_dir);\n\n\tdebugfs_create_file(\"info\", 0400, ccp->debugfs_instance, ccp,\n\t\t\t    &ccp_debugfs_info_ops);\n\n\tdebugfs_create_file(\"stats\", 0600, ccp->debugfs_instance, ccp,\n\t\t\t    &ccp_debugfs_stats_ops);\n\n\tfor (i = 0; i < ccp->cmd_q_count; i++) {\n\t\tcmd_q = &ccp->cmd_q[i];\n\n\t\tsnprintf(name, MAX_NAME_LEN - 1, \"q%d\", cmd_q->id);\n\n\t\tdebugfs_q_instance =\n\t\t\tdebugfs_create_dir(name, ccp->debugfs_instance);\n\n\t\tdebugfs_create_file(\"stats\", 0600, debugfs_q_instance, cmd_q,\n\t\t\t\t    &ccp_debugfs_queue_ops);\n\t}\n\n\treturn;\n}\n\nvoid ccp5_debugfs_destroy(void)\n{\n\tdebugfs_remove_recursive(ccp_debugfs_dir);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}