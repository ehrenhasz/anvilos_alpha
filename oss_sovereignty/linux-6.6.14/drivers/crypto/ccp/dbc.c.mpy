{
  "module_name": "dbc.c",
  "hash_id": "772faabf75d92d13465baeb8b8495578ff5660bbb8209bbfe9a58f79b49b632b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/dbc.c",
  "human_readable_source": "\n \n\n#include \"dbc.h\"\n\nstruct error_map {\n\tu32 psp;\n\tint ret;\n};\n\n#define DBC_ERROR_ACCESS_DENIED\t\t0x0001\n#define DBC_ERROR_EXCESS_DATA\t\t0x0004\n#define DBC_ERROR_BAD_PARAMETERS\t0x0006\n#define DBC_ERROR_BAD_STATE\t\t0x0007\n#define DBC_ERROR_NOT_IMPLEMENTED\t0x0009\n#define DBC_ERROR_BUSY\t\t\t0x000D\n#define DBC_ERROR_MESSAGE_FAILURE\t0x0307\n#define DBC_ERROR_OVERFLOW\t\t0x300F\n#define DBC_ERROR_SIGNATURE_INVALID\t0x3072\n\nstatic struct error_map error_codes[] = {\n\t{DBC_ERROR_ACCESS_DENIED,\t-EACCES},\n\t{DBC_ERROR_EXCESS_DATA,\t\t-E2BIG},\n\t{DBC_ERROR_BAD_PARAMETERS,\t-EINVAL},\n\t{DBC_ERROR_BAD_STATE,\t\t-EAGAIN},\n\t{DBC_ERROR_MESSAGE_FAILURE,\t-ENOENT},\n\t{DBC_ERROR_NOT_IMPLEMENTED,\t-ENOENT},\n\t{DBC_ERROR_BUSY,\t\t-EBUSY},\n\t{DBC_ERROR_OVERFLOW,\t\t-ENFILE},\n\t{DBC_ERROR_SIGNATURE_INVALID,\t-EPERM},\n\t{0x0,\t0x0},\n};\n\nstatic int send_dbc_cmd(struct psp_dbc_device *dbc_dev,\n\t\t\tenum psp_platform_access_msg msg)\n{\n\tint ret;\n\n\tdbc_dev->mbox->req.header.status = 0;\n\tret = psp_send_platform_access_msg(msg, (struct psp_request *)dbc_dev->mbox);\n\tif (ret == -EIO) {\n\t\tint i;\n\n\t\tdev_dbg(dbc_dev->dev,\n\t\t\t \"msg 0x%x failed with PSP error: 0x%x\\n\",\n\t\t\t msg, dbc_dev->mbox->req.header.status);\n\n\t\tfor (i = 0; error_codes[i].psp; i++) {\n\t\t\tif (dbc_dev->mbox->req.header.status == error_codes[i].psp)\n\t\t\t\treturn error_codes[i].ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int send_dbc_nonce(struct psp_dbc_device *dbc_dev)\n{\n\tint ret;\n\n\tdbc_dev->mbox->req.header.payload_size = sizeof(dbc_dev->mbox->dbc_nonce);\n\tret = send_dbc_cmd(dbc_dev, PSP_DYNAMIC_BOOST_GET_NONCE);\n\tif (ret == -EAGAIN) {\n\t\tdev_dbg(dbc_dev->dev, \"retrying get nonce\\n\");\n\t\tret = send_dbc_cmd(dbc_dev, PSP_DYNAMIC_BOOST_GET_NONCE);\n\t}\n\n\treturn ret;\n}\n\nstatic int send_dbc_parameter(struct psp_dbc_device *dbc_dev)\n{\n\tdbc_dev->mbox->req.header.payload_size = sizeof(dbc_dev->mbox->dbc_param);\n\n\tswitch (dbc_dev->mbox->dbc_param.user.msg_index) {\n\tcase PARAM_SET_FMAX_CAP:\n\tcase PARAM_SET_PWR_CAP:\n\tcase PARAM_SET_GFX_MODE:\n\t\treturn send_dbc_cmd(dbc_dev, PSP_DYNAMIC_BOOST_SET_PARAMETER);\n\tcase PARAM_GET_FMAX_CAP:\n\tcase PARAM_GET_PWR_CAP:\n\tcase PARAM_GET_CURR_TEMP:\n\tcase PARAM_GET_FMAX_MAX:\n\tcase PARAM_GET_FMAX_MIN:\n\tcase PARAM_GET_SOC_PWR_MAX:\n\tcase PARAM_GET_SOC_PWR_MIN:\n\tcase PARAM_GET_SOC_PWR_CUR:\n\tcase PARAM_GET_GFX_MODE:\n\t\treturn send_dbc_cmd(dbc_dev, PSP_DYNAMIC_BOOST_GET_PARAMETER);\n\t}\n\n\treturn -EINVAL;\n}\n\nvoid dbc_dev_destroy(struct psp_device *psp)\n{\n\tstruct psp_dbc_device *dbc_dev = psp->dbc_data;\n\n\tif (!dbc_dev)\n\t\treturn;\n\n\tmisc_deregister(&dbc_dev->char_dev);\n\tmutex_destroy(&dbc_dev->ioctl_mutex);\n\tpsp->dbc_data = NULL;\n}\n\nstatic long dbc_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct psp_device *psp_master = psp_get_master_device();\n\tvoid __user *argp = (void __user *)arg;\n\tstruct psp_dbc_device *dbc_dev;\n\tint ret;\n\n\tif (!psp_master || !psp_master->dbc_data)\n\t\treturn -ENODEV;\n\tdbc_dev = psp_master->dbc_data;\n\n\tmutex_lock(&dbc_dev->ioctl_mutex);\n\n\tswitch (cmd) {\n\tcase DBCIOCNONCE:\n\t\tif (copy_from_user(&dbc_dev->mbox->dbc_nonce.user, argp,\n\t\t\t\t   sizeof(struct dbc_user_nonce))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tret = send_dbc_nonce(dbc_dev);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tif (copy_to_user(argp, &dbc_dev->mbox->dbc_nonce.user,\n\t\t\t\t sizeof(struct dbc_user_nonce))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto unlock;\n\t\t}\n\t\tbreak;\n\tcase DBCIOCUID:\n\t\tdbc_dev->mbox->req.header.payload_size = sizeof(dbc_dev->mbox->dbc_set_uid);\n\t\tif (copy_from_user(&dbc_dev->mbox->dbc_set_uid.user, argp,\n\t\t\t\t   sizeof(struct dbc_user_setuid))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tret = send_dbc_cmd(dbc_dev, PSP_DYNAMIC_BOOST_SET_UID);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tif (copy_to_user(argp, &dbc_dev->mbox->dbc_set_uid.user,\n\t\t\t\t sizeof(struct dbc_user_setuid))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto unlock;\n\t\t}\n\t\tbreak;\n\tcase DBCIOCPARAM:\n\t\tif (copy_from_user(&dbc_dev->mbox->dbc_param.user, argp,\n\t\t\t\t   sizeof(struct dbc_user_param))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tret = send_dbc_parameter(dbc_dev);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tif (copy_to_user(argp, &dbc_dev->mbox->dbc_param.user,\n\t\t\t\t sizeof(struct dbc_user_param)))  {\n\t\t\tret = -EFAULT;\n\t\t\tgoto unlock;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\n\t}\nunlock:\n\tmutex_unlock(&dbc_dev->ioctl_mutex);\n\n\treturn ret;\n}\n\nstatic const struct file_operations dbc_fops = {\n\t.owner\t= THIS_MODULE,\n\t.unlocked_ioctl = dbc_ioctl,\n};\n\nint dbc_dev_init(struct psp_device *psp)\n{\n\tstruct device *dev = psp->dev;\n\tstruct psp_dbc_device *dbc_dev;\n\tint ret;\n\n\tif (!PSP_FEATURE(psp, DBC))\n\t\treturn 0;\n\n\tdbc_dev = devm_kzalloc(dev, sizeof(*dbc_dev), GFP_KERNEL);\n\tif (!dbc_dev)\n\t\treturn -ENOMEM;\n\n\tBUILD_BUG_ON(sizeof(union dbc_buffer) > PAGE_SIZE);\n\tdbc_dev->mbox = (void *)devm_get_free_pages(dev, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!dbc_dev->mbox) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup_dev;\n\t}\n\n\tpsp->dbc_data = dbc_dev;\n\tdbc_dev->dev = dev;\n\n\tret = send_dbc_nonce(dbc_dev);\n\tif (ret == -EACCES) {\n\t\tdev_dbg(dbc_dev->dev,\n\t\t\t\"dynamic boost control was previously authenticated\\n\");\n\t\tret = 0;\n\t}\n\tdev_dbg(dbc_dev->dev, \"dynamic boost control is %savailable\\n\",\n\t\tret ? \"un\" : \"\");\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto cleanup_mbox;\n\t}\n\n\tdbc_dev->char_dev.minor = MISC_DYNAMIC_MINOR;\n\tdbc_dev->char_dev.name = \"dbc\";\n\tdbc_dev->char_dev.fops = &dbc_fops;\n\tdbc_dev->char_dev.mode = 0600;\n\tret = misc_register(&dbc_dev->char_dev);\n\tif (ret)\n\t\tgoto cleanup_mbox;\n\n\tmutex_init(&dbc_dev->ioctl_mutex);\n\n\treturn 0;\n\ncleanup_mbox:\n\tdevm_free_pages(dev, (unsigned long)dbc_dev->mbox);\n\ncleanup_dev:\n\tpsp->dbc_data = NULL;\n\tdevm_kfree(dev, dbc_dev);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}