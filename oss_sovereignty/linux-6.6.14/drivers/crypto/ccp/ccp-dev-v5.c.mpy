{
  "module_name": "ccp-dev-v5.c",
  "hash_id": "6e36855faf1d753385410d2fa12b02a6cfe6785fe444ea2c7587a106e0cf40ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/ccp-dev-v5.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/compiler.h>\n#include <linux/ccp.h>\n\n#include \"ccp-dev.h\"\n\n \nstatic u32 ccp_lsb_alloc(struct ccp_cmd_queue *cmd_q, unsigned int count)\n{\n\tstruct ccp_device *ccp;\n\tint start;\n\n\t \n\tif (cmd_q->lsb >= 0) {\n\t\tstart = (u32)bitmap_find_next_zero_area(cmd_q->lsbmap,\n\t\t\t\t\t\t\tLSB_SIZE,\n\t\t\t\t\t\t\t0, count, 0);\n\t\tif (start < LSB_SIZE) {\n\t\t\tbitmap_set(cmd_q->lsbmap, start, count);\n\t\t\treturn start + cmd_q->lsb * LSB_SIZE;\n\t\t}\n\t}\n\n\t \n\tccp = cmd_q->ccp;\n\tfor (;;) {\n\t\tmutex_lock(&ccp->sb_mutex);\n\n\t\tstart = (u32)bitmap_find_next_zero_area(ccp->lsbmap,\n\t\t\t\t\t\t\tMAX_LSB_CNT * LSB_SIZE,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tcount, 0);\n\t\tif (start <= MAX_LSB_CNT * LSB_SIZE) {\n\t\t\tbitmap_set(ccp->lsbmap, start, count);\n\n\t\t\tmutex_unlock(&ccp->sb_mutex);\n\t\t\treturn start;\n\t\t}\n\n\t\tccp->sb_avail = 0;\n\n\t\tmutex_unlock(&ccp->sb_mutex);\n\n\t\t \n\t\tif (wait_event_interruptible(ccp->sb_queue, ccp->sb_avail))\n\t\t\treturn 0;\n\t}\n}\n\n \nstatic void ccp_lsb_free(struct ccp_cmd_queue *cmd_q, unsigned int start,\n\t\t\t unsigned int count)\n{\n\tif (!start)\n\t\treturn;\n\n\tif (cmd_q->lsb == start) {\n\t\t \n\t\tbitmap_clear(cmd_q->lsbmap, start, count);\n\t} else {\n\t\t \n\t\tstruct ccp_device *ccp = cmd_q->ccp;\n\n\t\tmutex_lock(&ccp->sb_mutex);\n\t\tbitmap_clear(ccp->lsbmap, start, count);\n\t\tccp->sb_avail = 1;\n\t\tmutex_unlock(&ccp->sb_mutex);\n\t\twake_up_interruptible_all(&ccp->sb_queue);\n\t}\n}\n\n \nunion ccp_function {\n\tstruct {\n\t\tu16 size:7;\n\t\tu16 encrypt:1;\n\t\tu16 mode:5;\n\t\tu16 type:2;\n\t} aes;\n\tstruct {\n\t\tu16 size:7;\n\t\tu16 encrypt:1;\n\t\tu16 rsvd:5;\n\t\tu16 type:2;\n\t} aes_xts;\n\tstruct {\n\t\tu16 size:7;\n\t\tu16 encrypt:1;\n\t\tu16 mode:5;\n\t\tu16 type:2;\n\t} des3;\n\tstruct {\n\t\tu16 rsvd1:10;\n\t\tu16 type:4;\n\t\tu16 rsvd2:1;\n\t} sha;\n\tstruct {\n\t\tu16 mode:3;\n\t\tu16 size:12;\n\t} rsa;\n\tstruct {\n\t\tu16 byteswap:2;\n\t\tu16 bitwise:3;\n\t\tu16 reflect:2;\n\t\tu16 rsvd:8;\n\t} pt;\n\tstruct  {\n\t\tu16 rsvd:13;\n\t} zlib;\n\tstruct {\n\t\tu16 size:10;\n\t\tu16 type:2;\n\t\tu16 mode:3;\n\t} ecc;\n\tu16 raw;\n};\n\n#define\tCCP_AES_SIZE(p)\t\t((p)->aes.size)\n#define\tCCP_AES_ENCRYPT(p)\t((p)->aes.encrypt)\n#define\tCCP_AES_MODE(p)\t\t((p)->aes.mode)\n#define\tCCP_AES_TYPE(p)\t\t((p)->aes.type)\n#define\tCCP_XTS_SIZE(p)\t\t((p)->aes_xts.size)\n#define\tCCP_XTS_TYPE(p)\t\t((p)->aes_xts.type)\n#define\tCCP_XTS_ENCRYPT(p)\t((p)->aes_xts.encrypt)\n#define\tCCP_DES3_SIZE(p)\t((p)->des3.size)\n#define\tCCP_DES3_ENCRYPT(p)\t((p)->des3.encrypt)\n#define\tCCP_DES3_MODE(p)\t((p)->des3.mode)\n#define\tCCP_DES3_TYPE(p)\t((p)->des3.type)\n#define\tCCP_SHA_TYPE(p)\t\t((p)->sha.type)\n#define\tCCP_RSA_SIZE(p)\t\t((p)->rsa.size)\n#define\tCCP_PT_BYTESWAP(p)\t((p)->pt.byteswap)\n#define\tCCP_PT_BITWISE(p)\t((p)->pt.bitwise)\n#define\tCCP_ECC_MODE(p)\t\t((p)->ecc.mode)\n#define\tCCP_ECC_AFFINE(p)\t((p)->ecc.one)\n\n \n#define CCP5_CMD_DW0(p)\t\t((p)->dw0)\n#define CCP5_CMD_SOC(p)\t\t(CCP5_CMD_DW0(p).soc)\n#define CCP5_CMD_IOC(p)\t\t(CCP5_CMD_DW0(p).ioc)\n#define CCP5_CMD_INIT(p)\t(CCP5_CMD_DW0(p).init)\n#define CCP5_CMD_EOM(p)\t\t(CCP5_CMD_DW0(p).eom)\n#define CCP5_CMD_FUNCTION(p)\t(CCP5_CMD_DW0(p).function)\n#define CCP5_CMD_ENGINE(p)\t(CCP5_CMD_DW0(p).engine)\n#define CCP5_CMD_PROT(p)\t(CCP5_CMD_DW0(p).prot)\n\n \n#define CCP5_CMD_DW1(p)\t\t((p)->length)\n#define CCP5_CMD_LEN(p)\t\t(CCP5_CMD_DW1(p))\n\n \n#define CCP5_CMD_DW2(p)\t\t((p)->src_lo)\n#define CCP5_CMD_SRC_LO(p)\t(CCP5_CMD_DW2(p))\n\n \n#define CCP5_CMD_DW3(p)\t\t((p)->dw3)\n#define CCP5_CMD_SRC_MEM(p)\t((p)->dw3.src_mem)\n#define CCP5_CMD_SRC_HI(p)\t((p)->dw3.src_hi)\n#define CCP5_CMD_LSB_ID(p)\t((p)->dw3.lsb_cxt_id)\n#define CCP5_CMD_FIX_SRC(p)\t((p)->dw3.fixed)\n\n \n#define CCP5_CMD_DW4(p)\t\t((p)->dw4)\n#define CCP5_CMD_DST_LO(p)\t(CCP5_CMD_DW4(p).dst_lo)\n#define CCP5_CMD_DW5(p)\t\t((p)->dw5.fields.dst_hi)\n#define CCP5_CMD_DST_HI(p)\t(CCP5_CMD_DW5(p))\n#define CCP5_CMD_DST_MEM(p)\t((p)->dw5.fields.dst_mem)\n#define CCP5_CMD_FIX_DST(p)\t((p)->dw5.fields.fixed)\n#define CCP5_CMD_SHA_LO(p)\t((p)->dw4.sha_len_lo)\n#define CCP5_CMD_SHA_HI(p)\t((p)->dw5.sha_len_hi)\n\n \n#define CCP5_CMD_DW6(p)\t\t((p)->key_lo)\n#define CCP5_CMD_KEY_LO(p)\t(CCP5_CMD_DW6(p))\n#define CCP5_CMD_DW7(p)\t\t((p)->dw7)\n#define CCP5_CMD_KEY_HI(p)\t((p)->dw7.key_hi)\n#define CCP5_CMD_KEY_MEM(p)\t((p)->dw7.key_mem)\n\nstatic inline u32 low_address(unsigned long addr)\n{\n\treturn (u64)addr & 0x0ffffffff;\n}\n\nstatic inline u32 high_address(unsigned long addr)\n{\n\treturn ((u64)addr >> 32) & 0x00000ffff;\n}\n\nstatic unsigned int ccp5_get_free_slots(struct ccp_cmd_queue *cmd_q)\n{\n\tunsigned int head_idx, n;\n\tu32 head_lo, queue_start;\n\n\tqueue_start = low_address(cmd_q->qdma_tail);\n\thead_lo = ioread32(cmd_q->reg_head_lo);\n\thead_idx = (head_lo - queue_start) / sizeof(struct ccp5_desc);\n\n\tn = head_idx + COMMANDS_PER_QUEUE - cmd_q->qidx - 1;\n\n\treturn n % COMMANDS_PER_QUEUE;  \n}\n\nstatic int ccp5_do_cmd(struct ccp5_desc *desc,\n\t\t       struct ccp_cmd_queue *cmd_q)\n{\n\t__le32 *mP;\n\tu32 *dP;\n\tu32 tail;\n\tint\ti;\n\tint ret = 0;\n\n\tcmd_q->total_ops++;\n\n\tif (CCP5_CMD_SOC(desc)) {\n\t\tCCP5_CMD_IOC(desc) = 1;\n\t\tCCP5_CMD_SOC(desc) = 0;\n\t}\n\tmutex_lock(&cmd_q->q_mutex);\n\n\tmP = (__le32 *)&cmd_q->qbase[cmd_q->qidx];\n\tdP = (u32 *)desc;\n\tfor (i = 0; i < 8; i++)\n\t\tmP[i] = cpu_to_le32(dP[i]);  \n\n\tcmd_q->qidx = (cmd_q->qidx + 1) % COMMANDS_PER_QUEUE;\n\n\t \n\twmb();\n\n\t \n\ttail = low_address(cmd_q->qdma_tail + cmd_q->qidx * Q_DESC_SIZE);\n\tiowrite32(tail, cmd_q->reg_tail_lo);\n\n\t \n\tiowrite32(cmd_q->qcontrol | CMD5_Q_RUN, cmd_q->reg_control);\n\tmutex_unlock(&cmd_q->q_mutex);\n\n\tif (CCP5_CMD_IOC(desc)) {\n\t\t \n\t\tret = wait_event_interruptible(cmd_q->int_queue,\n\t\t\t\t\t       cmd_q->int_rcvd);\n\t\tif (ret || cmd_q->cmd_error) {\n\t\t\t \n\t\t\tif (cmd_q->cmd_error)\n\t\t\t\tccp_log_error(cmd_q->ccp,\n\t\t\t\t\t      cmd_q->cmd_error);\n\t\t\tiowrite32(tail, cmd_q->reg_head_lo);\n\t\t\tif (!ret)\n\t\t\t\tret = -EIO;\n\t\t}\n\t\tcmd_q->int_rcvd = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int ccp5_perform_aes(struct ccp_op *op)\n{\n\tstruct ccp5_desc desc;\n\tunion ccp_function function;\n\tu32 key_addr = op->sb_key * LSB_ITEM_SIZE;\n\n\top->cmd_q->total_aes_ops++;\n\n\t \n\tmemset(&desc, 0, Q_DESC_SIZE);\n\n\tCCP5_CMD_ENGINE(&desc) = CCP_ENGINE_AES;\n\n\tCCP5_CMD_SOC(&desc) = op->soc;\n\tCCP5_CMD_IOC(&desc) = 1;\n\tCCP5_CMD_INIT(&desc) = op->init;\n\tCCP5_CMD_EOM(&desc) = op->eom;\n\tCCP5_CMD_PROT(&desc) = 0;\n\n\tfunction.raw = 0;\n\tCCP_AES_ENCRYPT(&function) = op->u.aes.action;\n\tCCP_AES_MODE(&function) = op->u.aes.mode;\n\tCCP_AES_TYPE(&function) = op->u.aes.type;\n\tCCP_AES_SIZE(&function) = op->u.aes.size;\n\n\tCCP5_CMD_FUNCTION(&desc) = function.raw;\n\n\tCCP5_CMD_LEN(&desc) = op->src.u.dma.length;\n\n\tCCP5_CMD_SRC_LO(&desc) = ccp_addr_lo(&op->src.u.dma);\n\tCCP5_CMD_SRC_HI(&desc) = ccp_addr_hi(&op->src.u.dma);\n\tCCP5_CMD_SRC_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\n\tCCP5_CMD_DST_LO(&desc) = ccp_addr_lo(&op->dst.u.dma);\n\tCCP5_CMD_DST_HI(&desc) = ccp_addr_hi(&op->dst.u.dma);\n\tCCP5_CMD_DST_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\n\tCCP5_CMD_KEY_LO(&desc) = lower_32_bits(key_addr);\n\tCCP5_CMD_KEY_HI(&desc) = 0;\n\tCCP5_CMD_KEY_MEM(&desc) = CCP_MEMTYPE_SB;\n\tCCP5_CMD_LSB_ID(&desc) = op->sb_ctx;\n\n\treturn ccp5_do_cmd(&desc, op->cmd_q);\n}\n\nstatic int ccp5_perform_xts_aes(struct ccp_op *op)\n{\n\tstruct ccp5_desc desc;\n\tunion ccp_function function;\n\tu32 key_addr = op->sb_key * LSB_ITEM_SIZE;\n\n\top->cmd_q->total_xts_aes_ops++;\n\n\t \n\tmemset(&desc, 0, Q_DESC_SIZE);\n\n\tCCP5_CMD_ENGINE(&desc) = CCP_ENGINE_XTS_AES_128;\n\n\tCCP5_CMD_SOC(&desc) = op->soc;\n\tCCP5_CMD_IOC(&desc) = 1;\n\tCCP5_CMD_INIT(&desc) = op->init;\n\tCCP5_CMD_EOM(&desc) = op->eom;\n\tCCP5_CMD_PROT(&desc) = 0;\n\n\tfunction.raw = 0;\n\tCCP_XTS_TYPE(&function) = op->u.xts.type;\n\tCCP_XTS_ENCRYPT(&function) = op->u.xts.action;\n\tCCP_XTS_SIZE(&function) = op->u.xts.unit_size;\n\tCCP5_CMD_FUNCTION(&desc) = function.raw;\n\n\tCCP5_CMD_LEN(&desc) = op->src.u.dma.length;\n\n\tCCP5_CMD_SRC_LO(&desc) = ccp_addr_lo(&op->src.u.dma);\n\tCCP5_CMD_SRC_HI(&desc) = ccp_addr_hi(&op->src.u.dma);\n\tCCP5_CMD_SRC_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\n\tCCP5_CMD_DST_LO(&desc) = ccp_addr_lo(&op->dst.u.dma);\n\tCCP5_CMD_DST_HI(&desc) = ccp_addr_hi(&op->dst.u.dma);\n\tCCP5_CMD_DST_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\n\tCCP5_CMD_KEY_LO(&desc) = lower_32_bits(key_addr);\n\tCCP5_CMD_KEY_HI(&desc) =  0;\n\tCCP5_CMD_KEY_MEM(&desc) = CCP_MEMTYPE_SB;\n\tCCP5_CMD_LSB_ID(&desc) = op->sb_ctx;\n\n\treturn ccp5_do_cmd(&desc, op->cmd_q);\n}\n\nstatic int ccp5_perform_sha(struct ccp_op *op)\n{\n\tstruct ccp5_desc desc;\n\tunion ccp_function function;\n\n\top->cmd_q->total_sha_ops++;\n\n\t \n\tmemset(&desc, 0, Q_DESC_SIZE);\n\n\tCCP5_CMD_ENGINE(&desc) = CCP_ENGINE_SHA;\n\n\tCCP5_CMD_SOC(&desc) = op->soc;\n\tCCP5_CMD_IOC(&desc) = 1;\n\tCCP5_CMD_INIT(&desc) = 1;\n\tCCP5_CMD_EOM(&desc) = op->eom;\n\tCCP5_CMD_PROT(&desc) = 0;\n\n\tfunction.raw = 0;\n\tCCP_SHA_TYPE(&function) = op->u.sha.type;\n\tCCP5_CMD_FUNCTION(&desc) = function.raw;\n\n\tCCP5_CMD_LEN(&desc) = op->src.u.dma.length;\n\n\tCCP5_CMD_SRC_LO(&desc) = ccp_addr_lo(&op->src.u.dma);\n\tCCP5_CMD_SRC_HI(&desc) = ccp_addr_hi(&op->src.u.dma);\n\tCCP5_CMD_SRC_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\n\tCCP5_CMD_LSB_ID(&desc) = op->sb_ctx;\n\n\tif (op->eom) {\n\t\tCCP5_CMD_SHA_LO(&desc) = lower_32_bits(op->u.sha.msg_bits);\n\t\tCCP5_CMD_SHA_HI(&desc) = upper_32_bits(op->u.sha.msg_bits);\n\t} else {\n\t\tCCP5_CMD_SHA_LO(&desc) = 0;\n\t\tCCP5_CMD_SHA_HI(&desc) = 0;\n\t}\n\n\treturn ccp5_do_cmd(&desc, op->cmd_q);\n}\n\nstatic int ccp5_perform_des3(struct ccp_op *op)\n{\n\tstruct ccp5_desc desc;\n\tunion ccp_function function;\n\tu32 key_addr = op->sb_key * LSB_ITEM_SIZE;\n\n\top->cmd_q->total_3des_ops++;\n\n\t \n\tmemset(&desc, 0, sizeof(struct ccp5_desc));\n\n\tCCP5_CMD_ENGINE(&desc) = CCP_ENGINE_DES3;\n\n\tCCP5_CMD_SOC(&desc) = op->soc;\n\tCCP5_CMD_IOC(&desc) = 1;\n\tCCP5_CMD_INIT(&desc) = op->init;\n\tCCP5_CMD_EOM(&desc) = op->eom;\n\tCCP5_CMD_PROT(&desc) = 0;\n\n\tfunction.raw = 0;\n\tCCP_DES3_ENCRYPT(&function) = op->u.des3.action;\n\tCCP_DES3_MODE(&function) = op->u.des3.mode;\n\tCCP_DES3_TYPE(&function) = op->u.des3.type;\n\tCCP5_CMD_FUNCTION(&desc) = function.raw;\n\n\tCCP5_CMD_LEN(&desc) = op->src.u.dma.length;\n\n\tCCP5_CMD_SRC_LO(&desc) = ccp_addr_lo(&op->src.u.dma);\n\tCCP5_CMD_SRC_HI(&desc) = ccp_addr_hi(&op->src.u.dma);\n\tCCP5_CMD_SRC_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\n\tCCP5_CMD_DST_LO(&desc) = ccp_addr_lo(&op->dst.u.dma);\n\tCCP5_CMD_DST_HI(&desc) = ccp_addr_hi(&op->dst.u.dma);\n\tCCP5_CMD_DST_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\n\tCCP5_CMD_KEY_LO(&desc) = lower_32_bits(key_addr);\n\tCCP5_CMD_KEY_HI(&desc) = 0;\n\tCCP5_CMD_KEY_MEM(&desc) = CCP_MEMTYPE_SB;\n\tCCP5_CMD_LSB_ID(&desc) = op->sb_ctx;\n\n\treturn ccp5_do_cmd(&desc, op->cmd_q);\n}\n\nstatic int ccp5_perform_rsa(struct ccp_op *op)\n{\n\tstruct ccp5_desc desc;\n\tunion ccp_function function;\n\n\top->cmd_q->total_rsa_ops++;\n\n\t \n\tmemset(&desc, 0, Q_DESC_SIZE);\n\n\tCCP5_CMD_ENGINE(&desc) = CCP_ENGINE_RSA;\n\n\tCCP5_CMD_SOC(&desc) = op->soc;\n\tCCP5_CMD_IOC(&desc) = 1;\n\tCCP5_CMD_INIT(&desc) = 0;\n\tCCP5_CMD_EOM(&desc) = 1;\n\tCCP5_CMD_PROT(&desc) = 0;\n\n\tfunction.raw = 0;\n\tCCP_RSA_SIZE(&function) = (op->u.rsa.mod_size + 7) >> 3;\n\tCCP5_CMD_FUNCTION(&desc) = function.raw;\n\n\tCCP5_CMD_LEN(&desc) = op->u.rsa.input_len;\n\n\t \n\tCCP5_CMD_SRC_LO(&desc) = ccp_addr_lo(&op->src.u.dma);\n\tCCP5_CMD_SRC_HI(&desc) = ccp_addr_hi(&op->src.u.dma);\n\tCCP5_CMD_SRC_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\n\t \n\tCCP5_CMD_DST_LO(&desc) = ccp_addr_lo(&op->dst.u.dma);\n\tCCP5_CMD_DST_HI(&desc) = ccp_addr_hi(&op->dst.u.dma);\n\tCCP5_CMD_DST_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\n\t \n\tCCP5_CMD_KEY_LO(&desc) = ccp_addr_lo(&op->exp.u.dma);\n\tCCP5_CMD_KEY_HI(&desc) = ccp_addr_hi(&op->exp.u.dma);\n\tCCP5_CMD_KEY_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\n\treturn ccp5_do_cmd(&desc, op->cmd_q);\n}\n\nstatic int ccp5_perform_passthru(struct ccp_op *op)\n{\n\tstruct ccp5_desc desc;\n\tunion ccp_function function;\n\tstruct ccp_dma_info *saddr = &op->src.u.dma;\n\tstruct ccp_dma_info *daddr = &op->dst.u.dma;\n\n\n\top->cmd_q->total_pt_ops++;\n\n\tmemset(&desc, 0, Q_DESC_SIZE);\n\n\tCCP5_CMD_ENGINE(&desc) = CCP_ENGINE_PASSTHRU;\n\n\tCCP5_CMD_SOC(&desc) = 0;\n\tCCP5_CMD_IOC(&desc) = 1;\n\tCCP5_CMD_INIT(&desc) = 0;\n\tCCP5_CMD_EOM(&desc) = op->eom;\n\tCCP5_CMD_PROT(&desc) = 0;\n\n\tfunction.raw = 0;\n\tCCP_PT_BYTESWAP(&function) = op->u.passthru.byte_swap;\n\tCCP_PT_BITWISE(&function) = op->u.passthru.bit_mod;\n\tCCP5_CMD_FUNCTION(&desc) = function.raw;\n\n\t \n\tif (op->src.type == CCP_MEMTYPE_SYSTEM)\n\t\tCCP5_CMD_LEN(&desc) = saddr->length;\n\telse\n\t\tCCP5_CMD_LEN(&desc) = daddr->length;\n\n\tif (op->src.type == CCP_MEMTYPE_SYSTEM) {\n\t\tCCP5_CMD_SRC_LO(&desc) = ccp_addr_lo(&op->src.u.dma);\n\t\tCCP5_CMD_SRC_HI(&desc) = ccp_addr_hi(&op->src.u.dma);\n\t\tCCP5_CMD_SRC_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\n\t\tif (op->u.passthru.bit_mod != CCP_PASSTHRU_BITWISE_NOOP)\n\t\t\tCCP5_CMD_LSB_ID(&desc) = op->sb_key;\n\t} else {\n\t\tu32 key_addr = op->src.u.sb * CCP_SB_BYTES;\n\n\t\tCCP5_CMD_SRC_LO(&desc) = lower_32_bits(key_addr);\n\t\tCCP5_CMD_SRC_HI(&desc) = 0;\n\t\tCCP5_CMD_SRC_MEM(&desc) = CCP_MEMTYPE_SB;\n\t}\n\n\tif (op->dst.type == CCP_MEMTYPE_SYSTEM) {\n\t\tCCP5_CMD_DST_LO(&desc) = ccp_addr_lo(&op->dst.u.dma);\n\t\tCCP5_CMD_DST_HI(&desc) = ccp_addr_hi(&op->dst.u.dma);\n\t\tCCP5_CMD_DST_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\t} else {\n\t\tu32 key_addr = op->dst.u.sb * CCP_SB_BYTES;\n\n\t\tCCP5_CMD_DST_LO(&desc) = lower_32_bits(key_addr);\n\t\tCCP5_CMD_DST_HI(&desc) = 0;\n\t\tCCP5_CMD_DST_MEM(&desc) = CCP_MEMTYPE_SB;\n\t}\n\n\treturn ccp5_do_cmd(&desc, op->cmd_q);\n}\n\nstatic int ccp5_perform_ecc(struct ccp_op *op)\n{\n\tstruct ccp5_desc desc;\n\tunion ccp_function function;\n\n\top->cmd_q->total_ecc_ops++;\n\n\t \n\tmemset(&desc, 0, Q_DESC_SIZE);\n\n\tCCP5_CMD_ENGINE(&desc) = CCP_ENGINE_ECC;\n\n\tCCP5_CMD_SOC(&desc) = 0;\n\tCCP5_CMD_IOC(&desc) = 1;\n\tCCP5_CMD_INIT(&desc) = 0;\n\tCCP5_CMD_EOM(&desc) = 1;\n\tCCP5_CMD_PROT(&desc) = 0;\n\n\tfunction.raw = 0;\n\tfunction.ecc.mode = op->u.ecc.function;\n\tCCP5_CMD_FUNCTION(&desc) = function.raw;\n\n\tCCP5_CMD_LEN(&desc) = op->src.u.dma.length;\n\n\tCCP5_CMD_SRC_LO(&desc) = ccp_addr_lo(&op->src.u.dma);\n\tCCP5_CMD_SRC_HI(&desc) = ccp_addr_hi(&op->src.u.dma);\n\tCCP5_CMD_SRC_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\n\tCCP5_CMD_DST_LO(&desc) = ccp_addr_lo(&op->dst.u.dma);\n\tCCP5_CMD_DST_HI(&desc) = ccp_addr_hi(&op->dst.u.dma);\n\tCCP5_CMD_DST_MEM(&desc) = CCP_MEMTYPE_SYSTEM;\n\n\treturn ccp5_do_cmd(&desc, op->cmd_q);\n}\n\nstatic int ccp_find_lsb_regions(struct ccp_cmd_queue *cmd_q, u64 status)\n{\n\tint q_mask = 1 << cmd_q->id;\n\tint queues = 0;\n\tint j;\n\n\t \n\tfor (j = 1; j < MAX_LSB_CNT; j++) {\n\t\tif (status & q_mask)\n\t\t\tbitmap_set(cmd_q->lsbmask, j, 1);\n\t\tstatus >>= LSB_REGION_WIDTH;\n\t}\n\tqueues = bitmap_weight(cmd_q->lsbmask, MAX_LSB_CNT);\n\tdev_dbg(cmd_q->ccp->dev, \"Queue %d can access %d LSB regions\\n\",\n\t\t cmd_q->id, queues);\n\n\treturn queues ? 0 : -EINVAL;\n}\n\nstatic int ccp_find_and_assign_lsb_to_q(struct ccp_device *ccp,\n\t\t\t\t\tint lsb_cnt, int n_lsbs,\n\t\t\t\t\tunsigned long *lsb_pub)\n{\n\tDECLARE_BITMAP(qlsb, MAX_LSB_CNT);\n\tint bitno;\n\tint qlsb_wgt;\n\tint i;\n\n\t \n\tfor (i = 0; i < ccp->cmd_q_count; i++) {\n\t\tstruct ccp_cmd_queue *cmd_q = &ccp->cmd_q[i];\n\n\t\tqlsb_wgt = bitmap_weight(cmd_q->lsbmask, MAX_LSB_CNT);\n\n\t\tif (qlsb_wgt == lsb_cnt) {\n\t\t\tbitmap_copy(qlsb, cmd_q->lsbmask, MAX_LSB_CNT);\n\n\t\t\tbitno = find_first_bit(qlsb, MAX_LSB_CNT);\n\t\t\twhile (bitno < MAX_LSB_CNT) {\n\t\t\t\tif (test_bit(bitno, lsb_pub)) {\n\t\t\t\t\t \n\t\t\t\t\tcmd_q->lsb = bitno;\n\t\t\t\t\tbitmap_clear(lsb_pub, bitno, 1);\n\t\t\t\t\tdev_dbg(ccp->dev,\n\t\t\t\t\t\t \"Queue %d gets LSB %d\\n\",\n\t\t\t\t\t\t i, bitno);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbitmap_clear(qlsb, bitno, 1);\n\t\t\t\tbitno = find_first_bit(qlsb, MAX_LSB_CNT);\n\t\t\t}\n\t\t\tif (bitno >= MAX_LSB_CNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tn_lsbs--;\n\t\t}\n\t}\n\treturn n_lsbs;\n}\n\n \nstatic int ccp_assign_lsbs(struct ccp_device *ccp)\n{\n\tDECLARE_BITMAP(lsb_pub, MAX_LSB_CNT);\n\tDECLARE_BITMAP(qlsb, MAX_LSB_CNT);\n\tint n_lsbs = 0;\n\tint bitno;\n\tint i, lsb_cnt;\n\tint rc = 0;\n\n\tbitmap_zero(lsb_pub, MAX_LSB_CNT);\n\n\t \n\tfor (i = 0; i < ccp->cmd_q_count; i++)\n\t\tbitmap_or(lsb_pub,\n\t\t\t  lsb_pub, ccp->cmd_q[i].lsbmask,\n\t\t\t  MAX_LSB_CNT);\n\n\tn_lsbs = bitmap_weight(lsb_pub, MAX_LSB_CNT);\n\n\tif (n_lsbs >= ccp->cmd_q_count) {\n\t\t \n\t\tfor (lsb_cnt = 1;\n\t\t     n_lsbs && (lsb_cnt <= MAX_LSB_CNT);\n\t\t     lsb_cnt++) {\n\t\t\trc = ccp_find_and_assign_lsb_to_q(ccp, lsb_cnt, n_lsbs,\n\t\t\t\t\t\t\t  lsb_pub);\n\t\t\tif (rc < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tn_lsbs = rc;\n\t\t}\n\t}\n\n\trc = 0;\n\t \n\tbitmap_copy(qlsb, lsb_pub, MAX_LSB_CNT);\n\n\tbitno = find_first_zero_bit(qlsb, MAX_LSB_CNT);\n\twhile (bitno < MAX_LSB_CNT) {\n\t\tbitmap_set(ccp->lsbmap, bitno * LSB_SIZE, LSB_SIZE);\n\t\tbitmap_set(qlsb, bitno, 1);\n\t\tbitno = find_first_zero_bit(qlsb, MAX_LSB_CNT);\n\t}\n\n\treturn rc;\n}\n\nstatic void ccp5_disable_queue_interrupts(struct ccp_device *ccp)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ccp->cmd_q_count; i++)\n\t\tiowrite32(0x0, ccp->cmd_q[i].reg_int_enable);\n}\n\nstatic void ccp5_enable_queue_interrupts(struct ccp_device *ccp)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ccp->cmd_q_count; i++)\n\t\tiowrite32(SUPPORTED_INTERRUPTS, ccp->cmd_q[i].reg_int_enable);\n}\n\nstatic void ccp5_irq_bh(unsigned long data)\n{\n\tstruct ccp_device *ccp = (struct ccp_device *)data;\n\tu32 status;\n\tunsigned int i;\n\n\tfor (i = 0; i < ccp->cmd_q_count; i++) {\n\t\tstruct ccp_cmd_queue *cmd_q = &ccp->cmd_q[i];\n\n\t\tstatus = ioread32(cmd_q->reg_interrupt_status);\n\n\t\tif (status) {\n\t\t\tcmd_q->int_status = status;\n\t\t\tcmd_q->q_status = ioread32(cmd_q->reg_status);\n\t\t\tcmd_q->q_int_status = ioread32(cmd_q->reg_int_status);\n\n\t\t\t \n\t\t\tif ((status & INT_ERROR) && !cmd_q->cmd_error)\n\t\t\t\tcmd_q->cmd_error = CMD_Q_ERROR(cmd_q->q_status);\n\n\t\t\tcmd_q->int_rcvd = 1;\n\n\t\t\t \n\t\t\tiowrite32(status, cmd_q->reg_interrupt_status);\n\t\t\twake_up_interruptible(&cmd_q->int_queue);\n\t\t}\n\t}\n\tccp5_enable_queue_interrupts(ccp);\n}\n\nstatic irqreturn_t ccp5_irq_handler(int irq, void *data)\n{\n\tstruct ccp_device *ccp = (struct ccp_device *)data;\n\n\tccp5_disable_queue_interrupts(ccp);\n\tccp->total_interrupts++;\n\tif (ccp->use_tasklet)\n\t\ttasklet_schedule(&ccp->irq_tasklet);\n\telse\n\t\tccp5_irq_bh((unsigned long)ccp);\n\treturn IRQ_HANDLED;\n}\n\nstatic int ccp5_init(struct ccp_device *ccp)\n{\n\tstruct device *dev = ccp->dev;\n\tstruct ccp_cmd_queue *cmd_q;\n\tstruct dma_pool *dma_pool;\n\tchar dma_pool_name[MAX_DMAPOOL_NAME_LEN];\n\tunsigned int qmr, i;\n\tu64 status;\n\tu32 status_lo, status_hi;\n\tint ret;\n\n\t \n\tqmr = ioread32(ccp->io_regs + Q_MASK_REG);\n\t \n\tif (qmr == 0xffffffff) {\n\t\tdev_notice(dev, \"ccp: unable to access the device: you might be running a broken BIOS.\\n\");\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; (i < MAX_HW_QUEUES) && (ccp->cmd_q_count < ccp->max_q_count); i++) {\n\t\tif (!(qmr & (1 << i)))\n\t\t\tcontinue;\n\n\t\t \n\t\tsnprintf(dma_pool_name, sizeof(dma_pool_name), \"%s_q%d\",\n\t\t\t ccp->name, i);\n\t\tdma_pool = dma_pool_create(dma_pool_name, dev,\n\t\t\t\t\t   CCP_DMAPOOL_MAX_SIZE,\n\t\t\t\t\t   CCP_DMAPOOL_ALIGN, 0);\n\t\tif (!dma_pool) {\n\t\t\tdev_err(dev, \"unable to allocate dma pool\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto e_pool;\n\t\t}\n\n\t\tcmd_q = &ccp->cmd_q[ccp->cmd_q_count];\n\t\tccp->cmd_q_count++;\n\n\t\tcmd_q->ccp = ccp;\n\t\tcmd_q->id = i;\n\t\tcmd_q->dma_pool = dma_pool;\n\t\tmutex_init(&cmd_q->q_mutex);\n\n\t\t \n\t\tBUILD_BUG_ON(COMMANDS_PER_QUEUE > 128);\n\t\tcmd_q->qsize = Q_SIZE(Q_DESC_SIZE);\n\t\tcmd_q->qbase = dmam_alloc_coherent(dev, cmd_q->qsize,\n\t\t\t\t\t\t   &cmd_q->qbase_dma,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!cmd_q->qbase) {\n\t\t\tdev_err(dev, \"unable to allocate command queue\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto e_pool;\n\t\t}\n\n\t\tcmd_q->qidx = 0;\n\t\t \n\t\tcmd_q->reg_control = ccp->io_regs +\n\t\t\t\t     CMD5_Q_STATUS_INCR * (i + 1);\n\t\tcmd_q->reg_tail_lo = cmd_q->reg_control + CMD5_Q_TAIL_LO_BASE;\n\t\tcmd_q->reg_head_lo = cmd_q->reg_control + CMD5_Q_HEAD_LO_BASE;\n\t\tcmd_q->reg_int_enable = cmd_q->reg_control +\n\t\t\t\t\tCMD5_Q_INT_ENABLE_BASE;\n\t\tcmd_q->reg_interrupt_status = cmd_q->reg_control +\n\t\t\t\t\t      CMD5_Q_INTERRUPT_STATUS_BASE;\n\t\tcmd_q->reg_status = cmd_q->reg_control + CMD5_Q_STATUS_BASE;\n\t\tcmd_q->reg_int_status = cmd_q->reg_control +\n\t\t\t\t\tCMD5_Q_INT_STATUS_BASE;\n\t\tcmd_q->reg_dma_status = cmd_q->reg_control +\n\t\t\t\t\tCMD5_Q_DMA_STATUS_BASE;\n\t\tcmd_q->reg_dma_read_status = cmd_q->reg_control +\n\t\t\t\t\t     CMD5_Q_DMA_READ_STATUS_BASE;\n\t\tcmd_q->reg_dma_write_status = cmd_q->reg_control +\n\t\t\t\t\t      CMD5_Q_DMA_WRITE_STATUS_BASE;\n\n\t\tinit_waitqueue_head(&cmd_q->int_queue);\n\n\t\tdev_dbg(dev, \"queue #%u available\\n\", i);\n\t}\n\n\tif (ccp->cmd_q_count == 0) {\n\t\tdev_notice(dev, \"no command queues available\\n\");\n\t\tret = 1;\n\t\tgoto e_pool;\n\t}\n\n\t \n\tccp5_disable_queue_interrupts(ccp);\n\tfor (i = 0; i < ccp->cmd_q_count; i++) {\n\t\tcmd_q = &ccp->cmd_q[i];\n\n\t\tcmd_q->qcontrol = 0;  \n\t\tiowrite32(cmd_q->qcontrol, cmd_q->reg_control);\n\n\t\tioread32(cmd_q->reg_int_status);\n\t\tioread32(cmd_q->reg_status);\n\n\t\t \n\t\tiowrite32(SUPPORTED_INTERRUPTS, cmd_q->reg_interrupt_status);\n\t}\n\n\tdev_dbg(dev, \"Requesting an IRQ...\\n\");\n\t \n\tret = sp_request_ccp_irq(ccp->sp, ccp5_irq_handler, ccp->name, ccp);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to allocate an IRQ\\n\");\n\t\tgoto e_pool;\n\t}\n\t \n\tif (ccp->use_tasklet)\n\t\ttasklet_init(&ccp->irq_tasklet, ccp5_irq_bh,\n\t\t\t     (unsigned long)ccp);\n\n\tdev_dbg(dev, \"Loading LSB map...\\n\");\n\t \n\tstatus_lo = ioread32(ccp->io_regs + LSB_PRIVATE_MASK_LO_OFFSET);\n\tstatus_hi = ioread32(ccp->io_regs + LSB_PRIVATE_MASK_HI_OFFSET);\n\tiowrite32(status_lo, ccp->io_regs + LSB_PUBLIC_MASK_LO_OFFSET);\n\tiowrite32(status_hi, ccp->io_regs + LSB_PUBLIC_MASK_HI_OFFSET);\n\tstatus = ((u64)status_hi<<30) | (u64)status_lo;\n\n\tdev_dbg(dev, \"Configuring virtual queues...\\n\");\n\t \n\tfor (i = 0; i < ccp->cmd_q_count; i++) {\n\t\tu32 dma_addr_lo;\n\t\tu32 dma_addr_hi;\n\n\t\tcmd_q = &ccp->cmd_q[i];\n\n\t\tcmd_q->qcontrol &= ~(CMD5_Q_SIZE << CMD5_Q_SHIFT);\n\t\tcmd_q->qcontrol |= QUEUE_SIZE_VAL << CMD5_Q_SHIFT;\n\n\t\tcmd_q->qdma_tail = cmd_q->qbase_dma;\n\t\tdma_addr_lo = low_address(cmd_q->qdma_tail);\n\t\tiowrite32((u32)dma_addr_lo, cmd_q->reg_tail_lo);\n\t\tiowrite32((u32)dma_addr_lo, cmd_q->reg_head_lo);\n\n\t\tdma_addr_hi = high_address(cmd_q->qdma_tail);\n\t\tcmd_q->qcontrol |= (dma_addr_hi << 16);\n\t\tiowrite32(cmd_q->qcontrol, cmd_q->reg_control);\n\n\t\t \n\t\tccp_find_lsb_regions(cmd_q, status);\n\t\tcmd_q->lsb = -1;  \n\t}\n\n\tdev_dbg(dev, \"Assigning LSBs...\\n\");\n\tret = ccp_assign_lsbs(ccp);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to assign LSBs (%d)\\n\", ret);\n\t\tgoto e_irq;\n\t}\n\n\t \n\tfor (i = 0; i < ccp->cmd_q_count; i++) {\n\t\tccp->cmd_q[i].sb_key = ccp_lsb_alloc(&ccp->cmd_q[i], 2);\n\t\tccp->cmd_q[i].sb_ctx = ccp_lsb_alloc(&ccp->cmd_q[i], 2);\n\t}\n\n\tdev_dbg(dev, \"Starting threads...\\n\");\n\t \n\tfor (i = 0; i < ccp->cmd_q_count; i++) {\n\t\tstruct task_struct *kthread;\n\n\t\tcmd_q = &ccp->cmd_q[i];\n\n\t\tkthread = kthread_run(ccp_cmd_queue_thread, cmd_q,\n\t\t\t\t      \"%s-q%u\", ccp->name, cmd_q->id);\n\t\tif (IS_ERR(kthread)) {\n\t\t\tdev_err(dev, \"error creating queue thread (%ld)\\n\",\n\t\t\t\tPTR_ERR(kthread));\n\t\t\tret = PTR_ERR(kthread);\n\t\t\tgoto e_kthread;\n\t\t}\n\n\t\tcmd_q->kthread = kthread;\n\t}\n\n\tdev_dbg(dev, \"Enabling interrupts...\\n\");\n\tccp5_enable_queue_interrupts(ccp);\n\n\tdev_dbg(dev, \"Registering device...\\n\");\n\t \n\tccp_add_device(ccp);\n\n\tret = ccp_register_rng(ccp);\n\tif (ret)\n\t\tgoto e_kthread;\n\n\t \n\tret = ccp_dmaengine_register(ccp);\n\tif (ret)\n\t\tgoto e_hwrng;\n\n#ifdef CONFIG_CRYPTO_DEV_CCP_DEBUGFS\n\t \n\tccp5_debugfs_setup(ccp);\n#endif\n\n\treturn 0;\n\ne_hwrng:\n\tccp_unregister_rng(ccp);\n\ne_kthread:\n\tfor (i = 0; i < ccp->cmd_q_count; i++)\n\t\tif (ccp->cmd_q[i].kthread)\n\t\t\tkthread_stop(ccp->cmd_q[i].kthread);\n\ne_irq:\n\tsp_free_ccp_irq(ccp->sp, ccp);\n\ne_pool:\n\tfor (i = 0; i < ccp->cmd_q_count; i++)\n\t\tdma_pool_destroy(ccp->cmd_q[i].dma_pool);\n\n\treturn ret;\n}\n\nstatic void ccp5_destroy(struct ccp_device *ccp)\n{\n\tstruct ccp_cmd_queue *cmd_q;\n\tstruct ccp_cmd *cmd;\n\tunsigned int i;\n\n\t \n\tccp_dmaengine_unregister(ccp);\n\n\t \n\tccp_unregister_rng(ccp);\n\n\t \n\tccp_del_device(ccp);\n\n#ifdef CONFIG_CRYPTO_DEV_CCP_DEBUGFS\n\t \n\tif (ccp_present())\n\t\tccp5_debugfs_destroy();\n#endif\n\n\t \n\tccp5_disable_queue_interrupts(ccp);\n\tfor (i = 0; i < ccp->cmd_q_count; i++) {\n\t\tcmd_q = &ccp->cmd_q[i];\n\n\t\t \n\t\tiowrite32(cmd_q->qcontrol & ~CMD5_Q_RUN, cmd_q->reg_control);\n\n\t\t \n\t\tiowrite32(SUPPORTED_INTERRUPTS, cmd_q->reg_interrupt_status);\n\t\tioread32(cmd_q->reg_int_status);\n\t\tioread32(cmd_q->reg_status);\n\t}\n\n\t \n\tfor (i = 0; i < ccp->cmd_q_count; i++)\n\t\tif (ccp->cmd_q[i].kthread)\n\t\t\tkthread_stop(ccp->cmd_q[i].kthread);\n\n\tsp_free_ccp_irq(ccp->sp, ccp);\n\n\t \n\twhile (!list_empty(&ccp->cmd)) {\n\t\t \n\t\tcmd = list_first_entry(&ccp->cmd, struct ccp_cmd, entry);\n\t\tlist_del(&cmd->entry);\n\t\tcmd->callback(cmd->data, -ENODEV);\n\t}\n\twhile (!list_empty(&ccp->backlog)) {\n\t\t \n\t\tcmd = list_first_entry(&ccp->backlog, struct ccp_cmd, entry);\n\t\tlist_del(&cmd->entry);\n\t\tcmd->callback(cmd->data, -ENODEV);\n\t}\n}\n\nstatic void ccp5_config(struct ccp_device *ccp)\n{\n\t \n\tiowrite32(0x0, ccp->io_regs + CMD5_REQID_CONFIG_OFFSET);\n}\n\nstatic void ccp5other_config(struct ccp_device *ccp)\n{\n\tint i;\n\tu32 rnd;\n\n\t \n\n\tiowrite32(0x00012D57, ccp->io_regs + CMD5_TRNG_CTL_OFFSET);\n\tiowrite32(0x00000003, ccp->io_regs + CMD5_CONFIG_0_OFFSET);\n\tfor (i = 0; i < 12; i++) {\n\t\trnd = ioread32(ccp->io_regs + TRNG_OUT_REG);\n\t\tiowrite32(rnd, ccp->io_regs + CMD5_AES_MASK_OFFSET);\n\t}\n\n\tiowrite32(0x0000001F, ccp->io_regs + CMD5_QUEUE_MASK_OFFSET);\n\tiowrite32(0x00005B6D, ccp->io_regs + CMD5_QUEUE_PRIO_OFFSET);\n\tiowrite32(0x00000000, ccp->io_regs + CMD5_CMD_TIMEOUT_OFFSET);\n\n\tiowrite32(0x3FFFFFFF, ccp->io_regs + LSB_PRIVATE_MASK_LO_OFFSET);\n\tiowrite32(0x000003FF, ccp->io_regs + LSB_PRIVATE_MASK_HI_OFFSET);\n\n\tiowrite32(0x00108823, ccp->io_regs + CMD5_CLK_GATE_CTL_OFFSET);\n\n\tccp5_config(ccp);\n}\n\n \nstatic const struct ccp_actions ccp5_actions = {\n\t.aes = ccp5_perform_aes,\n\t.xts_aes = ccp5_perform_xts_aes,\n\t.sha = ccp5_perform_sha,\n\t.des3 = ccp5_perform_des3,\n\t.rsa = ccp5_perform_rsa,\n\t.passthru = ccp5_perform_passthru,\n\t.ecc = ccp5_perform_ecc,\n\t.sballoc = ccp_lsb_alloc,\n\t.sbfree = ccp_lsb_free,\n\t.init = ccp5_init,\n\t.destroy = ccp5_destroy,\n\t.get_free_slots = ccp5_get_free_slots,\n};\n\nconst struct ccp_vdata ccpv5a = {\n\t.version = CCP_VERSION(5, 0),\n\t.setup = ccp5_config,\n\t.perform = &ccp5_actions,\n\t.offset = 0x0,\n\t.rsamax = CCP5_RSA_MAX_WIDTH,\n};\n\nconst struct ccp_vdata ccpv5b = {\n\t.version = CCP_VERSION(5, 0),\n\t.dma_chan_attr = DMA_PRIVATE,\n\t.setup = ccp5other_config,\n\t.perform = &ccp5_actions,\n\t.offset = 0x0,\n\t.rsamax = CCP5_RSA_MAX_WIDTH,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}