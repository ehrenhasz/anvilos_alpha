{
  "module_name": "psp-dev.c",
  "hash_id": "fc2acb1bd1797d35f9d700d8843dd033b8dc8d901db5c224af9cf623d9b9075b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/psp-dev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/irqreturn.h>\n\n#include \"sp-dev.h\"\n#include \"psp-dev.h\"\n#include \"sev-dev.h\"\n#include \"tee-dev.h\"\n#include \"platform-access.h\"\n#include \"dbc.h\"\n\nstruct psp_device *psp_master;\n\nstatic struct psp_device *psp_alloc_struct(struct sp_device *sp)\n{\n\tstruct device *dev = sp->dev;\n\tstruct psp_device *psp;\n\n\tpsp = devm_kzalloc(dev, sizeof(*psp), GFP_KERNEL);\n\tif (!psp)\n\t\treturn NULL;\n\n\tpsp->dev = dev;\n\tpsp->sp = sp;\n\n\tsnprintf(psp->name, sizeof(psp->name), \"psp-%u\", sp->ord);\n\n\treturn psp;\n}\n\nstatic irqreturn_t psp_irq_handler(int irq, void *data)\n{\n\tstruct psp_device *psp = data;\n\tunsigned int status;\n\n\t \n\tstatus = ioread32(psp->io_regs + psp->vdata->intsts_reg);\n\n\t \n\tiowrite32(status, psp->io_regs + psp->vdata->intsts_reg);\n\n\t \n\tif (status) {\n\t\tif (psp->sev_irq_handler)\n\t\t\tpsp->sev_irq_handler(irq, psp->sev_irq_data, status);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int psp_get_capability(struct psp_device *psp)\n{\n\tunsigned int val = ioread32(psp->io_regs + psp->vdata->feature_reg);\n\n\t \n\tif (val == 0xffffffff) {\n\t\tdev_notice(psp->dev, \"psp: unable to access the device: you might be running a broken BIOS.\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpsp->capability = val;\n\n\t \n\tif (psp->capability & PSP_CAPABILITY_PSP_SECURITY_REPORTING &&\n\t    psp->capability & (PSP_SECURITY_TSME_STATUS << PSP_CAPABILITY_PSP_SECURITY_OFFSET) &&\n\t    cc_platform_has(CC_ATTR_HOST_MEM_ENCRYPT))\n\t\tdev_notice(psp->dev, \"psp: Both TSME and SME are active, SME is unnecessary when TSME is active.\\n\");\n\n\treturn 0;\n}\n\nstatic int psp_check_sev_support(struct psp_device *psp)\n{\n\t \n\tif (!(psp->capability & PSP_CAPABILITY_SEV)) {\n\t\tdev_dbg(psp->dev, \"psp does not support SEV\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int psp_check_tee_support(struct psp_device *psp)\n{\n\t \n\tif (!(psp->capability & PSP_CAPABILITY_TEE)) {\n\t\tdev_dbg(psp->dev, \"psp does not support TEE\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void psp_init_platform_access(struct psp_device *psp)\n{\n\tint ret;\n\n\tret = platform_access_dev_init(psp);\n\tif (ret) {\n\t\tdev_warn(psp->dev, \"platform access init failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tret = dbc_dev_init(psp);\n\tif (ret)\n\t\tdev_warn(psp->dev, \"failed to init dynamic boost control: %d\\n\",\n\t\t\t ret);\n}\n\nstatic int psp_init(struct psp_device *psp)\n{\n\tint ret;\n\n\tif (!psp_check_sev_support(psp)) {\n\t\tret = sev_dev_init(psp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!psp_check_tee_support(psp)) {\n\t\tret = tee_dev_init(psp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (psp->vdata->platform_access)\n\t\tpsp_init_platform_access(psp);\n\n\treturn 0;\n}\n\nint psp_dev_init(struct sp_device *sp)\n{\n\tstruct device *dev = sp->dev;\n\tstruct psp_device *psp;\n\tint ret;\n\n\tret = -ENOMEM;\n\tpsp = psp_alloc_struct(sp);\n\tif (!psp)\n\t\tgoto e_err;\n\n\tsp->psp_data = psp;\n\n\tpsp->vdata = (struct psp_vdata *)sp->dev_vdata->psp_vdata;\n\tif (!psp->vdata) {\n\t\tret = -ENODEV;\n\t\tdev_err(dev, \"missing driver data\\n\");\n\t\tgoto e_err;\n\t}\n\n\tpsp->io_regs = sp->io_map;\n\n\tret = psp_get_capability(psp);\n\tif (ret)\n\t\tgoto e_disable;\n\n\t \n\tiowrite32(0, psp->io_regs + psp->vdata->inten_reg);\n\tiowrite32(-1, psp->io_regs + psp->vdata->intsts_reg);\n\n\t \n\tret = sp_request_psp_irq(psp->sp, psp_irq_handler, psp->name, psp);\n\tif (ret) {\n\t\tdev_err(dev, \"psp: unable to allocate an IRQ\\n\");\n\t\tgoto e_err;\n\t}\n\n\t \n\tif (psp->sp->set_psp_master_device)\n\t\tpsp->sp->set_psp_master_device(psp->sp);\n\n\tret = psp_init(psp);\n\tif (ret)\n\t\tgoto e_irq;\n\n\t \n\tiowrite32(-1, psp->io_regs + psp->vdata->inten_reg);\n\n\tdev_notice(dev, \"psp enabled\\n\");\n\n\treturn 0;\n\ne_irq:\n\tif (sp->clear_psp_master_device)\n\t\tsp->clear_psp_master_device(sp);\n\n\tsp_free_psp_irq(psp->sp, psp);\ne_err:\n\tsp->psp_data = NULL;\n\n\tdev_notice(dev, \"psp initialization failed\\n\");\n\n\treturn ret;\n\ne_disable:\n\tsp->psp_data = NULL;\n\n\treturn ret;\n}\n\nvoid psp_dev_destroy(struct sp_device *sp)\n{\n\tstruct psp_device *psp = sp->psp_data;\n\n\tif (!psp)\n\t\treturn;\n\n\tsev_dev_destroy(psp);\n\n\ttee_dev_destroy(psp);\n\n\tdbc_dev_destroy(psp);\n\n\tplatform_access_dev_destroy(psp);\n\n\tsp_free_psp_irq(sp, psp);\n\n\tif (sp->clear_psp_master_device)\n\t\tsp->clear_psp_master_device(sp);\n}\n\nvoid psp_set_sev_irq_handler(struct psp_device *psp, psp_irq_handler_t handler,\n\t\t\t     void *data)\n{\n\tpsp->sev_irq_data = data;\n\tpsp->sev_irq_handler = handler;\n}\n\nvoid psp_clear_sev_irq_handler(struct psp_device *psp)\n{\n\tpsp_set_sev_irq_handler(psp, NULL, NULL);\n}\n\nstruct psp_device *psp_get_master_device(void)\n{\n\tstruct sp_device *sp = sp_get_psp_master_device();\n\n\treturn sp ? sp->psp_data : NULL;\n}\n\nvoid psp_pci_init(void)\n{\n\tpsp_master = psp_get_master_device();\n\n\tif (!psp_master)\n\t\treturn;\n\n\tsev_pci_init();\n}\n\nvoid psp_pci_exit(void)\n{\n\tif (!psp_master)\n\t\treturn;\n\n\tsev_pci_exit();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}