{
  "module_name": "ccp-crypto-rsa.c",
  "hash_id": "08036d4002c703aacac06123613f4a1c19bed7f3915943b2d26bc8b3cc4d7236",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/ccp-crypto-rsa.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <crypto/algapi.h>\n#include <crypto/internal/rsa.h>\n#include <crypto/internal/akcipher.h>\n#include <crypto/akcipher.h>\n#include <crypto/scatterwalk.h>\n\n#include \"ccp-crypto.h\"\n\nstatic inline struct akcipher_request *akcipher_request_cast(\n\tstruct crypto_async_request *req)\n{\n\treturn container_of(req, struct akcipher_request, base);\n}\n\nstatic inline int ccp_copy_and_save_keypart(u8 **kpbuf, unsigned int *kplen,\n\t\t\t\t\t    const u8 *buf, size_t sz)\n{\n\tint nskip;\n\n\tfor (nskip = 0; nskip < sz; nskip++)\n\t\tif (buf[nskip])\n\t\t\tbreak;\n\t*kplen = sz - nskip;\n\t*kpbuf = kmemdup(buf + nskip, *kplen, GFP_KERNEL);\n\tif (!*kpbuf)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int ccp_rsa_complete(struct crypto_async_request *async_req, int ret)\n{\n\tstruct akcipher_request *req = akcipher_request_cast(async_req);\n\tstruct ccp_rsa_req_ctx *rctx = akcipher_request_ctx_dma(req);\n\n\tif (ret)\n\t\treturn ret;\n\n\treq->dst_len = rctx->cmd.u.rsa.key_size >> 3;\n\n\treturn 0;\n}\n\nstatic unsigned int ccp_rsa_maxsize(struct crypto_akcipher *tfm)\n{\n\tstruct ccp_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\n\treturn ctx->u.rsa.n_len;\n}\n\nstatic int ccp_rsa_crypt(struct akcipher_request *req, bool encrypt)\n{\n\tstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\n\tstruct ccp_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct ccp_rsa_req_ctx *rctx = akcipher_request_ctx_dma(req);\n\tint ret = 0;\n\n\tmemset(&rctx->cmd, 0, sizeof(rctx->cmd));\n\tINIT_LIST_HEAD(&rctx->cmd.entry);\n\trctx->cmd.engine = CCP_ENGINE_RSA;\n\n\trctx->cmd.u.rsa.key_size = ctx->u.rsa.key_len;  \n\tif (encrypt) {\n\t\trctx->cmd.u.rsa.exp = &ctx->u.rsa.e_sg;\n\t\trctx->cmd.u.rsa.exp_len = ctx->u.rsa.e_len;\n\t} else {\n\t\trctx->cmd.u.rsa.exp = &ctx->u.rsa.d_sg;\n\t\trctx->cmd.u.rsa.exp_len = ctx->u.rsa.d_len;\n\t}\n\trctx->cmd.u.rsa.mod = &ctx->u.rsa.n_sg;\n\trctx->cmd.u.rsa.mod_len = ctx->u.rsa.n_len;\n\trctx->cmd.u.rsa.src = req->src;\n\trctx->cmd.u.rsa.src_len = req->src_len;\n\trctx->cmd.u.rsa.dst = req->dst;\n\n\tret = ccp_crypto_enqueue_request(&req->base, &rctx->cmd);\n\n\treturn ret;\n}\n\nstatic int ccp_rsa_encrypt(struct akcipher_request *req)\n{\n\treturn ccp_rsa_crypt(req, true);\n}\n\nstatic int ccp_rsa_decrypt(struct akcipher_request *req)\n{\n\treturn ccp_rsa_crypt(req, false);\n}\n\nstatic int ccp_check_key_length(unsigned int len)\n{\n\t \n\tif (len < 8 || len > 4096)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void ccp_rsa_free_key_bufs(struct ccp_ctx *ctx)\n{\n\t \n\tkfree_sensitive(ctx->u.rsa.e_buf);\n\tctx->u.rsa.e_buf = NULL;\n\tctx->u.rsa.e_len = 0;\n\tkfree_sensitive(ctx->u.rsa.n_buf);\n\tctx->u.rsa.n_buf = NULL;\n\tctx->u.rsa.n_len = 0;\n\tkfree_sensitive(ctx->u.rsa.d_buf);\n\tctx->u.rsa.d_buf = NULL;\n\tctx->u.rsa.d_len = 0;\n}\n\nstatic int ccp_rsa_setkey(struct crypto_akcipher *tfm, const void *key,\n\t\t\t  unsigned int keylen, bool private)\n{\n\tstruct ccp_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\tstruct rsa_key raw_key;\n\tint ret;\n\n\tccp_rsa_free_key_bufs(ctx);\n\tmemset(&raw_key, 0, sizeof(raw_key));\n\n\t \n\tif (private)\n\t\tret = rsa_parse_priv_key(&raw_key, key, keylen);\n\telse\n\t\tret = rsa_parse_pub_key(&raw_key, key, keylen);\n\tif (ret)\n\t\tgoto n_key;\n\n\tret = ccp_copy_and_save_keypart(&ctx->u.rsa.n_buf, &ctx->u.rsa.n_len,\n\t\t\t\t\traw_key.n, raw_key.n_sz);\n\tif (ret)\n\t\tgoto key_err;\n\tsg_init_one(&ctx->u.rsa.n_sg, ctx->u.rsa.n_buf, ctx->u.rsa.n_len);\n\n\tctx->u.rsa.key_len = ctx->u.rsa.n_len << 3;  \n\tif (ccp_check_key_length(ctx->u.rsa.key_len)) {\n\t\tret = -EINVAL;\n\t\tgoto key_err;\n\t}\n\n\tret = ccp_copy_and_save_keypart(&ctx->u.rsa.e_buf, &ctx->u.rsa.e_len,\n\t\t\t\t\traw_key.e, raw_key.e_sz);\n\tif (ret)\n\t\tgoto key_err;\n\tsg_init_one(&ctx->u.rsa.e_sg, ctx->u.rsa.e_buf, ctx->u.rsa.e_len);\n\n\tif (private) {\n\t\tret = ccp_copy_and_save_keypart(&ctx->u.rsa.d_buf,\n\t\t\t\t\t\t&ctx->u.rsa.d_len,\n\t\t\t\t\t\traw_key.d, raw_key.d_sz);\n\t\tif (ret)\n\t\t\tgoto key_err;\n\t\tsg_init_one(&ctx->u.rsa.d_sg,\n\t\t\t    ctx->u.rsa.d_buf, ctx->u.rsa.d_len);\n\t}\n\n\treturn 0;\n\nkey_err:\n\tccp_rsa_free_key_bufs(ctx);\n\nn_key:\n\treturn ret;\n}\n\nstatic int ccp_rsa_setprivkey(struct crypto_akcipher *tfm, const void *key,\n\t\t\t      unsigned int keylen)\n{\n\treturn ccp_rsa_setkey(tfm, key, keylen, true);\n}\n\nstatic int ccp_rsa_setpubkey(struct crypto_akcipher *tfm, const void *key,\n\t\t\t     unsigned int keylen)\n{\n\treturn ccp_rsa_setkey(tfm, key, keylen, false);\n}\n\nstatic int ccp_rsa_init_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct ccp_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\n\takcipher_set_reqsize_dma(tfm, sizeof(struct ccp_rsa_req_ctx));\n\tctx->complete = ccp_rsa_complete;\n\n\treturn 0;\n}\n\nstatic void ccp_rsa_exit_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct ccp_ctx *ctx = akcipher_tfm_ctx_dma(tfm);\n\n\tccp_rsa_free_key_bufs(ctx);\n}\n\nstatic struct akcipher_alg ccp_rsa_defaults = {\n\t.encrypt = ccp_rsa_encrypt,\n\t.decrypt = ccp_rsa_decrypt,\n\t.set_pub_key = ccp_rsa_setpubkey,\n\t.set_priv_key = ccp_rsa_setprivkey,\n\t.max_size = ccp_rsa_maxsize,\n\t.init = ccp_rsa_init_tfm,\n\t.exit = ccp_rsa_exit_tfm,\n\t.base = {\n\t\t.cra_name = \"rsa\",\n\t\t.cra_driver_name = \"rsa-ccp\",\n\t\t.cra_priority = CCP_CRA_PRIORITY,\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_ctxsize = 2 * sizeof(struct ccp_ctx) + CRYPTO_DMA_PADDING,\n\t},\n};\n\nstruct ccp_rsa_def {\n\tunsigned int version;\n\tconst char *name;\n\tconst char *driver_name;\n\tunsigned int reqsize;\n\tstruct akcipher_alg *alg_defaults;\n};\n\nstatic struct ccp_rsa_def rsa_algs[] = {\n\t{\n\t\t.version\t= CCP_VERSION(3, 0),\n\t\t.name\t\t= \"rsa\",\n\t\t.driver_name\t= \"rsa-ccp\",\n\t\t.reqsize\t= sizeof(struct ccp_rsa_req_ctx),\n\t\t.alg_defaults\t= &ccp_rsa_defaults,\n\t}\n};\n\nstatic int ccp_register_rsa_alg(struct list_head *head,\n\t\t\t        const struct ccp_rsa_def *def)\n{\n\tstruct ccp_crypto_akcipher_alg *ccp_alg;\n\tstruct akcipher_alg *alg;\n\tint ret;\n\n\tccp_alg = kzalloc(sizeof(*ccp_alg), GFP_KERNEL);\n\tif (!ccp_alg)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ccp_alg->entry);\n\n\talg = &ccp_alg->alg;\n\t*alg = *def->alg_defaults;\n\tsnprintf(alg->base.cra_name, CRYPTO_MAX_ALG_NAME, \"%s\", def->name);\n\tsnprintf(alg->base.cra_driver_name, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t def->driver_name);\n\tret = crypto_register_akcipher(alg);\n\tif (ret) {\n\t\tpr_err(\"%s akcipher algorithm registration error (%d)\\n\",\n\t\t       alg->base.cra_name, ret);\n\t\tkfree(ccp_alg);\n\t\treturn ret;\n\t}\n\n\tlist_add(&ccp_alg->entry, head);\n\n\treturn 0;\n}\n\nint ccp_register_rsa_algs(struct list_head *head)\n{\n\tint i, ret;\n\tunsigned int ccpversion = ccp_version();\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(rsa_algs); i++) {\n\t\tif (rsa_algs[i].version > ccpversion)\n\t\t\tcontinue;\n\t\tret = ccp_register_rsa_alg(head, &rsa_algs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}