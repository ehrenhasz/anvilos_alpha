{
  "module_name": "sp-platform.c",
  "hash_id": "f5618527aacbd5f0776e510e0946f0ba044e5d38a7562f9d01bc77d7048df932",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/sp-platform.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/dma-mapping.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/ccp.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/acpi.h>\n\n#include \"ccp-dev.h\"\n\nstruct sp_platform {\n\tint coherent;\n\tunsigned int irq_count;\n};\n\nstatic const struct sp_dev_vdata dev_vdata[] = {\n\t{\n\t\t.bar = 0,\n#ifdef CONFIG_CRYPTO_DEV_SP_CCP\n\t\t.ccp_vdata = &ccpv3_platform,\n#endif\n\t},\n};\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id sp_acpi_match[] = {\n\t{ \"AMDI0C00\", (kernel_ulong_t)&dev_vdata[0] },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, sp_acpi_match);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id sp_of_match[] = {\n\t{ .compatible = \"amd,ccp-seattle-v1a\",\n\t  .data = (const void *)&dev_vdata[0] },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sp_of_match);\n#endif\n\nstatic struct sp_dev_vdata *sp_get_of_version(struct platform_device *pdev)\n{\n#ifdef CONFIG_OF\n\tconst struct of_device_id *match;\n\n\tmatch = of_match_node(sp_of_match, pdev->dev.of_node);\n\tif (match && match->data)\n\t\treturn (struct sp_dev_vdata *)match->data;\n#endif\n\treturn NULL;\n}\n\nstatic struct sp_dev_vdata *sp_get_acpi_version(struct platform_device *pdev)\n{\n#ifdef CONFIG_ACPI\n\tconst struct acpi_device_id *match;\n\n\tmatch = acpi_match_device(sp_acpi_match, &pdev->dev);\n\tif (match && match->driver_data)\n\t\treturn (struct sp_dev_vdata *)match->driver_data;\n#endif\n\treturn NULL;\n}\n\nstatic int sp_get_irqs(struct sp_device *sp)\n{\n\tstruct sp_platform *sp_platform = sp->dev_specific;\n\tstruct device *dev = sp->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret;\n\n\tsp_platform->irq_count = platform_irq_count(pdev);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0) {\n\t\tdev_notice(dev, \"unable to get IRQ (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsp->psp_irq = ret;\n\tif (sp_platform->irq_count == 1) {\n\t\tsp->ccp_irq = ret;\n\t} else {\n\t\tret = platform_get_irq(pdev, 1);\n\t\tif (ret < 0) {\n\t\t\tdev_notice(dev, \"unable to get IRQ (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsp->ccp_irq = ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sp_platform_probe(struct platform_device *pdev)\n{\n\tstruct sp_device *sp;\n\tstruct sp_platform *sp_platform;\n\tstruct device *dev = &pdev->dev;\n\tenum dev_dma_attr attr;\n\tint ret;\n\n\tret = -ENOMEM;\n\tsp = sp_alloc_struct(dev);\n\tif (!sp)\n\t\tgoto e_err;\n\n\tsp_platform = devm_kzalloc(dev, sizeof(*sp_platform), GFP_KERNEL);\n\tif (!sp_platform)\n\t\tgoto e_err;\n\n\tsp->dev_specific = sp_platform;\n\tsp->dev_vdata = pdev->dev.of_node ? sp_get_of_version(pdev)\n\t\t\t\t\t : sp_get_acpi_version(pdev);\n\tif (!sp->dev_vdata) {\n\t\tret = -ENODEV;\n\t\tdev_err(dev, \"missing driver data\\n\");\n\t\tgoto e_err;\n\t}\n\n\tsp->io_map = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sp->io_map)) {\n\t\tret = PTR_ERR(sp->io_map);\n\t\tgoto e_err;\n\t}\n\n\tattr = device_get_dma_attr(dev);\n\tif (attr == DEV_DMA_NOT_SUPPORTED) {\n\t\tdev_err(dev, \"DMA is not supported\");\n\t\tgoto e_err;\n\t}\n\n\tsp_platform->coherent = (attr == DEV_DMA_COHERENT);\n\tif (sp_platform->coherent)\n\t\tsp->axcache = CACHE_WB_NO_ALLOC;\n\telse\n\t\tsp->axcache = CACHE_NONE;\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(48));\n\tif (ret) {\n\t\tdev_err(dev, \"dma_set_mask_and_coherent failed (%d)\\n\", ret);\n\t\tgoto e_err;\n\t}\n\n\tret = sp_get_irqs(sp);\n\tif (ret)\n\t\tgoto e_err;\n\n\tdev_set_drvdata(dev, sp);\n\n\tret = sp_init(sp);\n\tif (ret)\n\t\tgoto e_err;\n\n\tdev_notice(dev, \"enabled\\n\");\n\n\treturn 0;\n\ne_err:\n\tdev_notice(dev, \"initialization failed\\n\");\n\treturn ret;\n}\n\nstatic int sp_platform_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sp_device *sp = dev_get_drvdata(dev);\n\n\tsp_destroy(sp);\n\n\tdev_notice(dev, \"disabled\\n\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int sp_platform_suspend(struct platform_device *pdev,\n\t\t\t\tpm_message_t state)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sp_device *sp = dev_get_drvdata(dev);\n\n\treturn sp_suspend(sp);\n}\n\nstatic int sp_platform_resume(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sp_device *sp = dev_get_drvdata(dev);\n\n\treturn sp_resume(sp);\n}\n#endif\n\nstatic struct platform_driver sp_platform_driver = {\n\t.driver = {\n\t\t.name = \"ccp\",\n#ifdef CONFIG_ACPI\n\t\t.acpi_match_table = sp_acpi_match,\n#endif\n#ifdef CONFIG_OF\n\t\t.of_match_table = sp_of_match,\n#endif\n\t},\n\t.probe = sp_platform_probe,\n\t.remove = sp_platform_remove,\n#ifdef CONFIG_PM\n\t.suspend = sp_platform_suspend,\n\t.resume = sp_platform_resume,\n#endif\n};\n\nint sp_platform_init(void)\n{\n\treturn platform_driver_register(&sp_platform_driver);\n}\n\nvoid sp_platform_exit(void)\n{\n\tplatform_driver_unregister(&sp_platform_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}