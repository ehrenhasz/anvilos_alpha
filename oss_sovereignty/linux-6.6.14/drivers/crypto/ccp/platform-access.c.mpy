{
  "module_name": "platform-access.c",
  "hash_id": "e6e412bd2e20b25f3f79760e0336535949c6c1325b419bb2b91e7e38712a7c1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/platform-access.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/errno.h>\n#include <linux/iopoll.h>\n#include <linux/mutex.h>\n\n#include \"platform-access.h\"\n\n#define PSP_CMD_TIMEOUT_US\t(500 * USEC_PER_MSEC)\n#define DOORBELL_CMDRESP_STS\tGENMASK(7, 0)\n\n \nstatic int check_recovery(u32 __iomem *cmd)\n{\n\treturn FIELD_GET(PSP_CMDRESP_RECOVERY, ioread32(cmd));\n}\n\nstatic int wait_cmd(u32 __iomem *cmd)\n{\n\tu32 tmp, expected;\n\n\t \n\texpected = FIELD_PREP(PSP_CMDRESP_RESP, 1);\n\n\t \n\treturn readl_poll_timeout(cmd, tmp, (tmp & expected), 0,\n\t\t\t\t  PSP_CMD_TIMEOUT_US);\n}\n\nint psp_check_platform_access_status(void)\n{\n\tstruct psp_device *psp = psp_get_master_device();\n\n\tif (!psp || !psp->platform_access_data)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(psp_check_platform_access_status);\n\nint psp_send_platform_access_msg(enum psp_platform_access_msg msg,\n\t\t\t\t struct psp_request *req)\n{\n\tstruct psp_device *psp = psp_get_master_device();\n\tu32 __iomem *cmd, *lo, *hi;\n\tstruct psp_platform_access_device *pa_dev;\n\tphys_addr_t req_addr;\n\tu32 cmd_reg;\n\tint ret;\n\n\tif (!psp || !psp->platform_access_data)\n\t\treturn -ENODEV;\n\n\tpa_dev = psp->platform_access_data;\n\n\tif (!pa_dev->vdata->cmdresp_reg || !pa_dev->vdata->cmdbuff_addr_lo_reg ||\n\t    !pa_dev->vdata->cmdbuff_addr_hi_reg)\n\t\treturn -ENODEV;\n\n\tcmd = psp->io_regs + pa_dev->vdata->cmdresp_reg;\n\tlo = psp->io_regs + pa_dev->vdata->cmdbuff_addr_lo_reg;\n\thi = psp->io_regs + pa_dev->vdata->cmdbuff_addr_hi_reg;\n\n\tmutex_lock(&pa_dev->mailbox_mutex);\n\n\tif (check_recovery(cmd)) {\n\t\tdev_dbg(psp->dev, \"platform mailbox is in recovery\\n\");\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (wait_cmd(cmd)) {\n\t\tdev_dbg(psp->dev, \"platform mailbox is not done processing command\\n\");\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\t \n\treq_addr = __psp_pa(req);\n\tiowrite32(lower_32_bits(req_addr), lo);\n\tiowrite32(upper_32_bits(req_addr), hi);\n\n\tprint_hex_dump_debug(\"->psp \", DUMP_PREFIX_OFFSET, 16, 2, req,\n\t\t\t     req->header.payload_size, false);\n\n\t \n\tcmd_reg = FIELD_PREP(PSP_CMDRESP_CMD, msg);\n\tiowrite32(cmd_reg, cmd);\n\n\tif (wait_cmd(cmd)) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (ioread32(lo) != lower_32_bits(req_addr) ||\n\t    ioread32(hi) != upper_32_bits(req_addr)) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\t \n\tcmd_reg = ioread32(cmd);\n\treq->header.status = FIELD_GET(PSP_CMDRESP_STS, cmd_reg);\n\tif (req->header.status) {\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tprint_hex_dump_debug(\"<-psp \", DUMP_PREFIX_OFFSET, 16, 2, req,\n\t\t\t     req->header.payload_size, false);\n\n\tret = 0;\n\nunlock:\n\tmutex_unlock(&pa_dev->mailbox_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(psp_send_platform_access_msg);\n\nint psp_ring_platform_doorbell(int msg, u32 *result)\n{\n\tstruct psp_device *psp = psp_get_master_device();\n\tstruct psp_platform_access_device *pa_dev;\n\tu32 __iomem *button, *cmd;\n\tint ret, val;\n\n\tif (!psp || !psp->platform_access_data)\n\t\treturn -ENODEV;\n\n\tpa_dev = psp->platform_access_data;\n\tbutton = psp->io_regs + pa_dev->vdata->doorbell_button_reg;\n\tcmd = psp->io_regs + pa_dev->vdata->doorbell_cmd_reg;\n\n\tmutex_lock(&pa_dev->doorbell_mutex);\n\n\tif (wait_cmd(cmd)) {\n\t\tdev_err(psp->dev, \"doorbell command not done processing\\n\");\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tiowrite32(FIELD_PREP(DOORBELL_CMDRESP_STS, msg), cmd);\n\tiowrite32(PSP_DRBL_RING, button);\n\n\tif (wait_cmd(cmd)) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto unlock;\n\t}\n\n\tval = FIELD_GET(DOORBELL_CMDRESP_STS, ioread32(cmd));\n\tif (val) {\n\t\tif (result)\n\t\t\t*result = val;\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tret = 0;\nunlock:\n\tmutex_unlock(&pa_dev->doorbell_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(psp_ring_platform_doorbell);\n\nvoid platform_access_dev_destroy(struct psp_device *psp)\n{\n\tstruct psp_platform_access_device *pa_dev = psp->platform_access_data;\n\n\tif (!pa_dev)\n\t\treturn;\n\n\tmutex_destroy(&pa_dev->mailbox_mutex);\n\tmutex_destroy(&pa_dev->doorbell_mutex);\n\tpsp->platform_access_data = NULL;\n}\n\nint platform_access_dev_init(struct psp_device *psp)\n{\n\tstruct device *dev = psp->dev;\n\tstruct psp_platform_access_device *pa_dev;\n\n\tpa_dev = devm_kzalloc(dev, sizeof(*pa_dev), GFP_KERNEL);\n\tif (!pa_dev)\n\t\treturn -ENOMEM;\n\n\tpsp->platform_access_data = pa_dev;\n\tpa_dev->psp = psp;\n\tpa_dev->dev = dev;\n\n\tpa_dev->vdata = (struct platform_access_vdata *)psp->vdata->platform_access;\n\n\tmutex_init(&pa_dev->mailbox_mutex);\n\tmutex_init(&pa_dev->doorbell_mutex);\n\n\tdev_dbg(dev, \"platform access enabled\\n\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}