{
  "module_name": "sp-dev.c",
  "hash_id": "4f8d39e6bea9a05e05cc97a2047cd328d8f1793ec0086894eb7367eac87c7a4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/sp-dev.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/spinlock_types.h>\n#include <linux/types.h>\n#include <linux/ccp.h>\n\n#include \"ccp-dev.h\"\n#include \"sp-dev.h\"\n\nMODULE_AUTHOR(\"Tom Lendacky <thomas.lendacky@amd.com>\");\nMODULE_AUTHOR(\"Gary R Hook <gary.hook@amd.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1.1.0\");\nMODULE_DESCRIPTION(\"AMD Secure Processor driver\");\n\n \nstatic DEFINE_RWLOCK(sp_unit_lock);\nstatic LIST_HEAD(sp_units);\n\n \nstatic atomic_t sp_ordinal;\n\nstatic void sp_add_device(struct sp_device *sp)\n{\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&sp_unit_lock, flags);\n\n\tlist_add_tail(&sp->entry, &sp_units);\n\n\twrite_unlock_irqrestore(&sp_unit_lock, flags);\n}\n\nstatic void sp_del_device(struct sp_device *sp)\n{\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&sp_unit_lock, flags);\n\n\tlist_del(&sp->entry);\n\n\twrite_unlock_irqrestore(&sp_unit_lock, flags);\n}\n\nstatic irqreturn_t sp_irq_handler(int irq, void *data)\n{\n\tstruct sp_device *sp = data;\n\n\tif (sp->ccp_irq_handler)\n\t\tsp->ccp_irq_handler(irq, sp->ccp_irq_data);\n\n\tif (sp->psp_irq_handler)\n\t\tsp->psp_irq_handler(irq, sp->psp_irq_data);\n\n\treturn IRQ_HANDLED;\n}\n\nint sp_request_ccp_irq(struct sp_device *sp, irq_handler_t handler,\n\t\t       const char *name, void *data)\n{\n\tint ret;\n\n\tif ((sp->psp_irq == sp->ccp_irq) && sp->dev_vdata->psp_vdata) {\n\t\t \n\t\tsp->ccp_irq_data = data;\n\t\tsp->ccp_irq_handler = handler;\n\n\t\tif (!sp->irq_registered) {\n\t\t\tret = request_irq(sp->ccp_irq, sp_irq_handler, 0,\n\t\t\t\t\t  sp->name, sp);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsp->irq_registered = true;\n\t\t}\n\t} else {\n\t\t \n\t\tret = request_irq(sp->ccp_irq, handler, 0, name, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint sp_request_psp_irq(struct sp_device *sp, irq_handler_t handler,\n\t\t       const char *name, void *data)\n{\n\tint ret;\n\n\tif ((sp->psp_irq == sp->ccp_irq) && sp->dev_vdata->ccp_vdata) {\n\t\t \n\t\tsp->psp_irq_data = data;\n\t\tsp->psp_irq_handler = handler;\n\n\t\tif (!sp->irq_registered) {\n\t\t\tret = request_irq(sp->psp_irq, sp_irq_handler, 0,\n\t\t\t\t\t  sp->name, sp);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsp->irq_registered = true;\n\t\t}\n\t} else {\n\t\t \n\t\tret = request_irq(sp->psp_irq, handler, 0, name, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid sp_free_ccp_irq(struct sp_device *sp, void *data)\n{\n\tif ((sp->psp_irq == sp->ccp_irq) && sp->dev_vdata->psp_vdata) {\n\t\t \n\t\tif (!sp->psp_irq_handler) {\n\t\t\t \n\t\t\tfree_irq(sp->ccp_irq, sp);\n\n\t\t\tsp->irq_registered = false;\n\t\t}\n\n\t\tsp->ccp_irq_handler = NULL;\n\t\tsp->ccp_irq_data = NULL;\n\t} else {\n\t\t \n\t\tfree_irq(sp->ccp_irq, data);\n\t}\n}\n\nvoid sp_free_psp_irq(struct sp_device *sp, void *data)\n{\n\tif ((sp->psp_irq == sp->ccp_irq) && sp->dev_vdata->ccp_vdata) {\n\t\t \n\t\tif (!sp->ccp_irq_handler) {\n\t\t\t \n\t\t\tfree_irq(sp->psp_irq, sp);\n\n\t\t\tsp->irq_registered = false;\n\t\t}\n\n\t\tsp->psp_irq_handler = NULL;\n\t\tsp->psp_irq_data = NULL;\n\t} else {\n\t\t \n\t\tfree_irq(sp->psp_irq, data);\n\t}\n}\n\n \nstruct sp_device *sp_alloc_struct(struct device *dev)\n{\n\tstruct sp_device *sp;\n\n\tsp = devm_kzalloc(dev, sizeof(*sp), GFP_KERNEL);\n\tif (!sp)\n\t\treturn NULL;\n\n\tsp->dev = dev;\n\tsp->ord = atomic_inc_return(&sp_ordinal);\n\tsnprintf(sp->name, SP_MAX_NAME_LEN, \"sp-%u\", sp->ord);\n\n\treturn sp;\n}\n\nint sp_init(struct sp_device *sp)\n{\n\tsp_add_device(sp);\n\n\tif (sp->dev_vdata->ccp_vdata)\n\t\tccp_dev_init(sp);\n\n\tif (sp->dev_vdata->psp_vdata)\n\t\tpsp_dev_init(sp);\n\treturn 0;\n}\n\nvoid sp_destroy(struct sp_device *sp)\n{\n\tif (sp->dev_vdata->ccp_vdata)\n\t\tccp_dev_destroy(sp);\n\n\tif (sp->dev_vdata->psp_vdata)\n\t\tpsp_dev_destroy(sp);\n\n\tsp_del_device(sp);\n}\n\nint sp_suspend(struct sp_device *sp)\n{\n\tif (sp->dev_vdata->ccp_vdata) {\n\t\tccp_dev_suspend(sp);\n\t}\n\n\treturn 0;\n}\n\nint sp_resume(struct sp_device *sp)\n{\n\tif (sp->dev_vdata->ccp_vdata) {\n\t\tccp_dev_resume(sp);\n\t}\n\n\treturn 0;\n}\n\nstruct sp_device *sp_get_psp_master_device(void)\n{\n\tstruct sp_device *i, *ret = NULL;\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&sp_unit_lock, flags);\n\tif (list_empty(&sp_units))\n\t\tgoto unlock;\n\n\tlist_for_each_entry(i, &sp_units, entry) {\n\t\tif (i->psp_data && i->get_psp_master_device) {\n\t\t\tret = i->get_psp_master_device();\n\t\t\tbreak;\n\t\t}\n\t}\n\nunlock:\n\twrite_unlock_irqrestore(&sp_unit_lock, flags);\n\treturn ret;\n}\n\nstatic int __init sp_mod_init(void)\n{\n#ifdef CONFIG_X86\n\tint ret;\n\n\tret = sp_pci_init();\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_CRYPTO_DEV_SP_PSP\n\tpsp_pci_init();\n#endif\n\n\treturn 0;\n#endif\n\n#ifdef CONFIG_ARM64\n\tint ret;\n\n\tret = sp_platform_init();\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n#endif\n\n\treturn -ENODEV;\n}\n\nstatic void __exit sp_mod_exit(void)\n{\n#ifdef CONFIG_X86\n\n#ifdef CONFIG_CRYPTO_DEV_SP_PSP\n\tpsp_pci_exit();\n#endif\n\n\tsp_pci_exit();\n#endif\n\n#ifdef CONFIG_ARM64\n\tsp_platform_exit();\n#endif\n}\n\nmodule_init(sp_mod_init);\nmodule_exit(sp_mod_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}