{
  "module_name": "tee-dev.c",
  "hash_id": "5931d3daef274fa1160535c7799d2360731d5751f62bc6801f3772e2506e10ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/tee-dev.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/gfp.h>\n#include <linux/psp.h>\n#include <linux/psp-tee.h>\n\n#include \"psp-dev.h\"\n#include \"tee-dev.h\"\n\nstatic bool psp_dead;\n\nstatic int tee_alloc_ring(struct psp_tee_device *tee, int ring_size)\n{\n\tstruct ring_buf_manager *rb_mgr = &tee->rb_mgr;\n\tvoid *start_addr;\n\n\tif (!ring_size)\n\t\treturn -EINVAL;\n\n\t \n\tstart_addr = (void *)__get_free_pages(GFP_KERNEL, get_order(ring_size));\n\tif (!start_addr)\n\t\treturn -ENOMEM;\n\n\tmemset(start_addr, 0x0, ring_size);\n\trb_mgr->ring_start = start_addr;\n\trb_mgr->ring_size = ring_size;\n\trb_mgr->ring_pa = __psp_pa(start_addr);\n\tmutex_init(&rb_mgr->mutex);\n\n\treturn 0;\n}\n\nstatic void tee_free_ring(struct psp_tee_device *tee)\n{\n\tstruct ring_buf_manager *rb_mgr = &tee->rb_mgr;\n\n\tif (!rb_mgr->ring_start)\n\t\treturn;\n\n\tfree_pages((unsigned long)rb_mgr->ring_start,\n\t\t   get_order(rb_mgr->ring_size));\n\n\trb_mgr->ring_start = NULL;\n\trb_mgr->ring_size = 0;\n\trb_mgr->ring_pa = 0;\n\tmutex_destroy(&rb_mgr->mutex);\n}\n\nstatic int tee_wait_cmd_poll(struct psp_tee_device *tee, unsigned int timeout,\n\t\t\t     unsigned int *reg)\n{\n\t \n\tint nloop = timeout * 100;\n\n\twhile (--nloop) {\n\t\t*reg = ioread32(tee->io_regs + tee->vdata->cmdresp_reg);\n\t\tif (FIELD_GET(PSP_CMDRESP_RESP, *reg))\n\t\t\treturn 0;\n\n\t\tusleep_range(10000, 10100);\n\t}\n\n\tdev_err(tee->dev, \"tee: command timed out, disabling PSP\\n\");\n\tpsp_dead = true;\n\n\treturn -ETIMEDOUT;\n}\n\nstatic\nstruct tee_init_ring_cmd *tee_alloc_cmd_buffer(struct psp_tee_device *tee)\n{\n\tstruct tee_init_ring_cmd *cmd;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn NULL;\n\n\tcmd->hi_addr = upper_32_bits(tee->rb_mgr.ring_pa);\n\tcmd->low_addr = lower_32_bits(tee->rb_mgr.ring_pa);\n\tcmd->size = tee->rb_mgr.ring_size;\n\n\tdev_dbg(tee->dev, \"tee: ring address: high = 0x%x low = 0x%x size = %u\\n\",\n\t\tcmd->hi_addr, cmd->low_addr, cmd->size);\n\n\treturn cmd;\n}\n\nstatic inline void tee_free_cmd_buffer(struct tee_init_ring_cmd *cmd)\n{\n\tkfree(cmd);\n}\n\nstatic int tee_init_ring(struct psp_tee_device *tee)\n{\n\tint ring_size = MAX_RING_BUFFER_ENTRIES * sizeof(struct tee_ring_cmd);\n\tstruct tee_init_ring_cmd *cmd;\n\tphys_addr_t cmd_buffer;\n\tunsigned int reg;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct tee_ring_cmd) != 1024);\n\n\tret = tee_alloc_ring(tee, ring_size);\n\tif (ret) {\n\t\tdev_err(tee->dev, \"tee: ring allocation failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttee->rb_mgr.wptr = 0;\n\n\tcmd = tee_alloc_cmd_buffer(tee);\n\tif (!cmd) {\n\t\ttee_free_ring(tee);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd_buffer = __psp_pa((void *)cmd);\n\n\t \n\n\tiowrite32(lower_32_bits(cmd_buffer),\n\t\t  tee->io_regs + tee->vdata->cmdbuff_addr_lo_reg);\n\tiowrite32(upper_32_bits(cmd_buffer),\n\t\t  tee->io_regs + tee->vdata->cmdbuff_addr_hi_reg);\n\tiowrite32(TEE_RING_INIT_CMD,\n\t\t  tee->io_regs + tee->vdata->cmdresp_reg);\n\n\tret = tee_wait_cmd_poll(tee, TEE_DEFAULT_TIMEOUT, &reg);\n\tif (ret) {\n\t\tdev_err(tee->dev, \"tee: ring init command timed out\\n\");\n\t\ttee_free_ring(tee);\n\t\tgoto free_buf;\n\t}\n\n\tif (FIELD_GET(PSP_CMDRESP_STS, reg)) {\n\t\tdev_err(tee->dev, \"tee: ring init command failed (%#010lx)\\n\",\n\t\t\tFIELD_GET(PSP_CMDRESP_STS, reg));\n\t\ttee_free_ring(tee);\n\t\tret = -EIO;\n\t}\n\nfree_buf:\n\ttee_free_cmd_buffer(cmd);\n\n\treturn ret;\n}\n\nstatic void tee_destroy_ring(struct psp_tee_device *tee)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tif (!tee->rb_mgr.ring_start)\n\t\treturn;\n\n\tif (psp_dead)\n\t\tgoto free_ring;\n\n\tiowrite32(TEE_RING_DESTROY_CMD,\n\t\t  tee->io_regs + tee->vdata->cmdresp_reg);\n\n\tret = tee_wait_cmd_poll(tee, TEE_DEFAULT_TIMEOUT, &reg);\n\tif (ret) {\n\t\tdev_err(tee->dev, \"tee: ring destroy command timed out\\n\");\n\t} else if (FIELD_GET(PSP_CMDRESP_STS, reg)) {\n\t\tdev_err(tee->dev, \"tee: ring destroy command failed (%#010lx)\\n\",\n\t\t\tFIELD_GET(PSP_CMDRESP_STS, reg));\n\t}\n\nfree_ring:\n\ttee_free_ring(tee);\n}\n\nint tee_dev_init(struct psp_device *psp)\n{\n\tstruct device *dev = psp->dev;\n\tstruct psp_tee_device *tee;\n\tint ret;\n\n\tret = -ENOMEM;\n\ttee = devm_kzalloc(dev, sizeof(*tee), GFP_KERNEL);\n\tif (!tee)\n\t\tgoto e_err;\n\n\tpsp->tee_data = tee;\n\n\ttee->dev = dev;\n\ttee->psp = psp;\n\n\ttee->io_regs = psp->io_regs;\n\n\ttee->vdata = (struct tee_vdata *)psp->vdata->tee;\n\tif (!tee->vdata) {\n\t\tret = -ENODEV;\n\t\tdev_err(dev, \"tee: missing driver data\\n\");\n\t\tgoto e_err;\n\t}\n\n\tret = tee_init_ring(tee);\n\tif (ret) {\n\t\tdev_err(dev, \"tee: failed to init ring buffer\\n\");\n\t\tgoto e_err;\n\t}\n\n\tdev_notice(dev, \"tee enabled\\n\");\n\n\treturn 0;\n\ne_err:\n\tpsp->tee_data = NULL;\n\n\tdev_notice(dev, \"tee initialization failed\\n\");\n\n\treturn ret;\n}\n\nvoid tee_dev_destroy(struct psp_device *psp)\n{\n\tstruct psp_tee_device *tee = psp->tee_data;\n\n\tif (!tee)\n\t\treturn;\n\n\ttee_destroy_ring(tee);\n}\n\nstatic int tee_submit_cmd(struct psp_tee_device *tee, enum tee_cmd_id cmd_id,\n\t\t\t  void *buf, size_t len, struct tee_ring_cmd **resp)\n{\n\tstruct tee_ring_cmd *cmd;\n\tint nloop = 1000, ret = 0;\n\tu32 rptr;\n\n\t*resp = NULL;\n\n\tmutex_lock(&tee->rb_mgr.mutex);\n\n\t \n\tdo {\n\t\t \n\t\tcmd = (struct tee_ring_cmd *)\n\t\t\t(tee->rb_mgr.ring_start + tee->rb_mgr.wptr);\n\n\t\trptr = ioread32(tee->io_regs + tee->vdata->ring_rptr_reg);\n\n\t\t \n\t\tif (!(tee->rb_mgr.wptr + sizeof(struct tee_ring_cmd) == rptr ||\n\t\t      cmd->flag == CMD_WAITING_FOR_RESPONSE))\n\t\t\tbreak;\n\n\t\tdev_dbg(tee->dev, \"tee: ring buffer full. rptr = %u wptr = %u\\n\",\n\t\t\trptr, tee->rb_mgr.wptr);\n\n\t\t \n\t\tmutex_unlock(&tee->rb_mgr.mutex);\n\t\tschedule_timeout_interruptible(msecs_to_jiffies(10));\n\t\tmutex_lock(&tee->rb_mgr.mutex);\n\n\t} while (--nloop);\n\n\tif (!nloop &&\n\t    (tee->rb_mgr.wptr + sizeof(struct tee_ring_cmd) == rptr ||\n\t     cmd->flag == CMD_WAITING_FOR_RESPONSE)) {\n\t\tdev_err(tee->dev, \"tee: ring buffer full. rptr = %u wptr = %u response flag %u\\n\",\n\t\t\trptr, tee->rb_mgr.wptr, cmd->flag);\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (psp_dead) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\t \n\tcmd->cmd_id = cmd_id;\n\tcmd->cmd_state = TEE_CMD_STATE_INIT;\n\tmemset(&cmd->buf[0], 0, sizeof(cmd->buf));\n\tmemcpy(&cmd->buf[0], buf, len);\n\n\t \n\tcmd->flag = CMD_WAITING_FOR_RESPONSE;\n\n\t \n\ttee->rb_mgr.wptr += sizeof(struct tee_ring_cmd);\n\tif (tee->rb_mgr.wptr >= tee->rb_mgr.ring_size)\n\t\ttee->rb_mgr.wptr = 0;\n\n\t \n\tiowrite32(tee->rb_mgr.wptr, tee->io_regs + tee->vdata->ring_wptr_reg);\n\n\t \n\t*resp = cmd;\n\nunlock:\n\tmutex_unlock(&tee->rb_mgr.mutex);\n\n\treturn ret;\n}\n\nstatic int tee_wait_cmd_completion(struct psp_tee_device *tee,\n\t\t\t\t   struct tee_ring_cmd *resp,\n\t\t\t\t   unsigned int timeout)\n{\n\t \n\tint nloop = timeout * 1000;\n\n\twhile (--nloop) {\n\t\tif (resp->cmd_state == TEE_CMD_STATE_COMPLETED)\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 1100);\n\t}\n\n\tdev_err(tee->dev, \"tee: command 0x%x timed out, disabling PSP\\n\",\n\t\tresp->cmd_id);\n\n\tpsp_dead = true;\n\n\treturn -ETIMEDOUT;\n}\n\nint psp_tee_process_cmd(enum tee_cmd_id cmd_id, void *buf, size_t len,\n\t\t\tu32 *status)\n{\n\tstruct psp_device *psp = psp_get_master_device();\n\tstruct psp_tee_device *tee;\n\tstruct tee_ring_cmd *resp;\n\tint ret;\n\n\tif (!buf || !status || !len || len > sizeof(resp->buf))\n\t\treturn -EINVAL;\n\n\t*status = 0;\n\n\tif (!psp || !psp->tee_data)\n\t\treturn -ENODEV;\n\n\tif (psp_dead)\n\t\treturn -EBUSY;\n\n\ttee = psp->tee_data;\n\n\tret = tee_submit_cmd(tee, cmd_id, buf, len, &resp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tee_wait_cmd_completion(tee, resp, TEE_DEFAULT_TIMEOUT);\n\tif (ret) {\n\t\tresp->flag = CMD_RESPONSE_TIMEDOUT;\n\t\treturn ret;\n\t}\n\n\tmemcpy(buf, &resp->buf[0], len);\n\t*status = resp->status;\n\n\tresp->flag = CMD_RESPONSE_COPIED;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(psp_tee_process_cmd);\n\nint psp_check_tee_status(void)\n{\n\tstruct psp_device *psp = psp_get_master_device();\n\n\tif (!psp || !psp->tee_data)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(psp_check_tee_status);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}