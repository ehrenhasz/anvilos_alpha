{
  "module_name": "ccp-crypto-aes.c",
  "hash_id": "451498d13ca1f7de5354ba3b5d443bc154e7a45116d0dd156bf8e9ac029d55a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/ccp-crypto-aes.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <crypto/ctr.h>\n#include <crypto/scatterwalk.h>\n\n#include \"ccp-crypto.h\"\n\nstatic int ccp_aes_complete(struct crypto_async_request *async_req, int ret)\n{\n\tstruct skcipher_request *req = skcipher_request_cast(async_req);\n\tstruct ccp_ctx *ctx = crypto_skcipher_ctx_dma(\n\t\tcrypto_skcipher_reqtfm(req));\n\tstruct ccp_aes_req_ctx *rctx = skcipher_request_ctx_dma(req);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->u.aes.mode != CCP_AES_MODE_ECB)\n\t\tmemcpy(req->iv, rctx->iv, AES_BLOCK_SIZE);\n\n\treturn 0;\n}\n\nstatic int ccp_aes_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t  unsigned int key_len)\n{\n\tstruct ccp_crypto_skcipher_alg *alg = ccp_crypto_skcipher_alg(tfm);\n\tstruct ccp_ctx *ctx = crypto_skcipher_ctx_dma(tfm);\n\n\tswitch (key_len) {\n\tcase AES_KEYSIZE_128:\n\t\tctx->u.aes.type = CCP_AES_TYPE_128;\n\t\tbreak;\n\tcase AES_KEYSIZE_192:\n\t\tctx->u.aes.type = CCP_AES_TYPE_192;\n\t\tbreak;\n\tcase AES_KEYSIZE_256:\n\t\tctx->u.aes.type = CCP_AES_TYPE_256;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tctx->u.aes.mode = alg->mode;\n\tctx->u.aes.key_len = key_len;\n\n\tmemcpy(ctx->u.aes.key, key, key_len);\n\tsg_init_one(&ctx->u.aes.key_sg, ctx->u.aes.key, key_len);\n\n\treturn 0;\n}\n\nstatic int ccp_aes_crypt(struct skcipher_request *req, bool encrypt)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct ccp_ctx *ctx = crypto_skcipher_ctx_dma(tfm);\n\tstruct ccp_aes_req_ctx *rctx = skcipher_request_ctx_dma(req);\n\tstruct scatterlist *iv_sg = NULL;\n\tunsigned int iv_len = 0;\n\n\tif (!ctx->u.aes.key_len)\n\t\treturn -EINVAL;\n\n\tif (((ctx->u.aes.mode == CCP_AES_MODE_ECB) ||\n\t     (ctx->u.aes.mode == CCP_AES_MODE_CBC)) &&\n\t    (req->cryptlen & (AES_BLOCK_SIZE - 1)))\n\t\treturn -EINVAL;\n\n\tif (ctx->u.aes.mode != CCP_AES_MODE_ECB) {\n\t\tif (!req->iv)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(rctx->iv, req->iv, AES_BLOCK_SIZE);\n\t\tiv_sg = &rctx->iv_sg;\n\t\tiv_len = AES_BLOCK_SIZE;\n\t\tsg_init_one(iv_sg, rctx->iv, iv_len);\n\t}\n\n\tmemset(&rctx->cmd, 0, sizeof(rctx->cmd));\n\tINIT_LIST_HEAD(&rctx->cmd.entry);\n\trctx->cmd.engine = CCP_ENGINE_AES;\n\trctx->cmd.u.aes.type = ctx->u.aes.type;\n\trctx->cmd.u.aes.mode = ctx->u.aes.mode;\n\trctx->cmd.u.aes.action =\n\t\t(encrypt) ? CCP_AES_ACTION_ENCRYPT : CCP_AES_ACTION_DECRYPT;\n\trctx->cmd.u.aes.key = &ctx->u.aes.key_sg;\n\trctx->cmd.u.aes.key_len = ctx->u.aes.key_len;\n\trctx->cmd.u.aes.iv = iv_sg;\n\trctx->cmd.u.aes.iv_len = iv_len;\n\trctx->cmd.u.aes.src = req->src;\n\trctx->cmd.u.aes.src_len = req->cryptlen;\n\trctx->cmd.u.aes.dst = req->dst;\n\n\treturn ccp_crypto_enqueue_request(&req->base, &rctx->cmd);\n}\n\nstatic int ccp_aes_encrypt(struct skcipher_request *req)\n{\n\treturn ccp_aes_crypt(req, true);\n}\n\nstatic int ccp_aes_decrypt(struct skcipher_request *req)\n{\n\treturn ccp_aes_crypt(req, false);\n}\n\nstatic int ccp_aes_init_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct ccp_ctx *ctx = crypto_skcipher_ctx_dma(tfm);\n\n\tctx->complete = ccp_aes_complete;\n\tctx->u.aes.key_len = 0;\n\n\tcrypto_skcipher_set_reqsize(tfm, sizeof(struct ccp_aes_req_ctx));\n\n\treturn 0;\n}\n\nstatic int ccp_aes_rfc3686_complete(struct crypto_async_request *async_req,\n\t\t\t\t    int ret)\n{\n\tstruct skcipher_request *req = skcipher_request_cast(async_req);\n\tstruct ccp_aes_req_ctx *rctx = skcipher_request_ctx_dma(req);\n\n\t \n\treq->iv = rctx->rfc3686_info;\n\n\treturn ccp_aes_complete(async_req, ret);\n}\n\nstatic int ccp_aes_rfc3686_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t\t  unsigned int key_len)\n{\n\tstruct ccp_ctx *ctx = crypto_skcipher_ctx_dma(tfm);\n\n\tif (key_len < CTR_RFC3686_NONCE_SIZE)\n\t\treturn -EINVAL;\n\n\tkey_len -= CTR_RFC3686_NONCE_SIZE;\n\tmemcpy(ctx->u.aes.nonce, key + key_len, CTR_RFC3686_NONCE_SIZE);\n\n\treturn ccp_aes_setkey(tfm, key, key_len);\n}\n\nstatic int ccp_aes_rfc3686_crypt(struct skcipher_request *req, bool encrypt)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct ccp_ctx *ctx = crypto_skcipher_ctx_dma(tfm);\n\tstruct ccp_aes_req_ctx *rctx = skcipher_request_ctx_dma(req);\n\tu8 *iv;\n\n\t \n\tiv = rctx->rfc3686_iv;\n\tmemcpy(iv, ctx->u.aes.nonce, CTR_RFC3686_NONCE_SIZE);\n\n\tiv += CTR_RFC3686_NONCE_SIZE;\n\tmemcpy(iv, req->iv, CTR_RFC3686_IV_SIZE);\n\n\tiv += CTR_RFC3686_IV_SIZE;\n\t*(__be32 *)iv = cpu_to_be32(1);\n\n\t \n\trctx->rfc3686_info = req->iv;\n\treq->iv = rctx->rfc3686_iv;\n\n\treturn ccp_aes_crypt(req, encrypt);\n}\n\nstatic int ccp_aes_rfc3686_encrypt(struct skcipher_request *req)\n{\n\treturn ccp_aes_rfc3686_crypt(req, true);\n}\n\nstatic int ccp_aes_rfc3686_decrypt(struct skcipher_request *req)\n{\n\treturn ccp_aes_rfc3686_crypt(req, false);\n}\n\nstatic int ccp_aes_rfc3686_init_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct ccp_ctx *ctx = crypto_skcipher_ctx_dma(tfm);\n\n\tctx->complete = ccp_aes_rfc3686_complete;\n\tctx->u.aes.key_len = 0;\n\n\tcrypto_skcipher_set_reqsize_dma(tfm, sizeof(struct ccp_aes_req_ctx));\n\n\treturn 0;\n}\n\nstatic const struct skcipher_alg ccp_aes_defaults = {\n\t.setkey\t\t\t= ccp_aes_setkey,\n\t.encrypt\t\t= ccp_aes_encrypt,\n\t.decrypt\t\t= ccp_aes_decrypt,\n\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t.init\t\t\t= ccp_aes_init_tfm,\n\n\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t.base.cra_ctxsize\t= sizeof(struct ccp_ctx) + CRYPTO_DMA_PADDING,\n\t.base.cra_priority\t= CCP_CRA_PRIORITY,\n\t.base.cra_module\t= THIS_MODULE,\n};\n\nstatic const struct skcipher_alg ccp_aes_rfc3686_defaults = {\n\t.setkey\t\t\t= ccp_aes_rfc3686_setkey,\n\t.encrypt\t\t= ccp_aes_rfc3686_encrypt,\n\t.decrypt\t\t= ccp_aes_rfc3686_decrypt,\n\t.min_keysize\t\t= AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,\n\t.max_keysize\t\t= AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,\n\t.init\t\t\t= ccp_aes_rfc3686_init_tfm,\n\n\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t.base.cra_blocksize\t= CTR_RFC3686_BLOCK_SIZE,\n\t.base.cra_ctxsize\t= sizeof(struct ccp_ctx) + CRYPTO_DMA_PADDING,\n\t.base.cra_priority\t= CCP_CRA_PRIORITY,\n\t.base.cra_module\t= THIS_MODULE,\n};\n\nstruct ccp_aes_def {\n\tenum ccp_aes_mode mode;\n\tunsigned int version;\n\tconst char *name;\n\tconst char *driver_name;\n\tunsigned int blocksize;\n\tunsigned int ivsize;\n\tconst struct skcipher_alg *alg_defaults;\n};\n\nstatic struct ccp_aes_def aes_algs[] = {\n\t{\n\t\t.mode\t\t= CCP_AES_MODE_ECB,\n\t\t.version\t= CCP_VERSION(3, 0),\n\t\t.name\t\t= \"ecb(aes)\",\n\t\t.driver_name\t= \"ecb-aes-ccp\",\n\t\t.blocksize\t= AES_BLOCK_SIZE,\n\t\t.ivsize\t\t= 0,\n\t\t.alg_defaults\t= &ccp_aes_defaults,\n\t},\n\t{\n\t\t.mode\t\t= CCP_AES_MODE_CBC,\n\t\t.version\t= CCP_VERSION(3, 0),\n\t\t.name\t\t= \"cbc(aes)\",\n\t\t.driver_name\t= \"cbc-aes-ccp\",\n\t\t.blocksize\t= AES_BLOCK_SIZE,\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.alg_defaults\t= &ccp_aes_defaults,\n\t},\n\t{\n\t\t.mode\t\t= CCP_AES_MODE_CFB,\n\t\t.version\t= CCP_VERSION(3, 0),\n\t\t.name\t\t= \"cfb(aes)\",\n\t\t.driver_name\t= \"cfb-aes-ccp\",\n\t\t.blocksize\t= 1,\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.alg_defaults\t= &ccp_aes_defaults,\n\t},\n\t{\n\t\t.mode\t\t= CCP_AES_MODE_OFB,\n\t\t.version\t= CCP_VERSION(3, 0),\n\t\t.name\t\t= \"ofb(aes)\",\n\t\t.driver_name\t= \"ofb-aes-ccp\",\n\t\t.blocksize\t= 1,\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.alg_defaults\t= &ccp_aes_defaults,\n\t},\n\t{\n\t\t.mode\t\t= CCP_AES_MODE_CTR,\n\t\t.version\t= CCP_VERSION(3, 0),\n\t\t.name\t\t= \"ctr(aes)\",\n\t\t.driver_name\t= \"ctr-aes-ccp\",\n\t\t.blocksize\t= 1,\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.alg_defaults\t= &ccp_aes_defaults,\n\t},\n\t{\n\t\t.mode\t\t= CCP_AES_MODE_CTR,\n\t\t.version\t= CCP_VERSION(3, 0),\n\t\t.name\t\t= \"rfc3686(ctr(aes))\",\n\t\t.driver_name\t= \"rfc3686-ctr-aes-ccp\",\n\t\t.blocksize\t= 1,\n\t\t.ivsize\t\t= CTR_RFC3686_IV_SIZE,\n\t\t.alg_defaults\t= &ccp_aes_rfc3686_defaults,\n\t},\n};\n\nstatic int ccp_register_aes_alg(struct list_head *head,\n\t\t\t\tconst struct ccp_aes_def *def)\n{\n\tstruct ccp_crypto_skcipher_alg *ccp_alg;\n\tstruct skcipher_alg *alg;\n\tint ret;\n\n\tccp_alg = kzalloc(sizeof(*ccp_alg), GFP_KERNEL);\n\tif (!ccp_alg)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ccp_alg->entry);\n\n\tccp_alg->mode = def->mode;\n\n\t \n\talg = &ccp_alg->alg;\n\t*alg = *def->alg_defaults;\n\tsnprintf(alg->base.cra_name, CRYPTO_MAX_ALG_NAME, \"%s\", def->name);\n\tsnprintf(alg->base.cra_driver_name, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t def->driver_name);\n\talg->base.cra_blocksize = def->blocksize;\n\talg->ivsize = def->ivsize;\n\n\tret = crypto_register_skcipher(alg);\n\tif (ret) {\n\t\tpr_err(\"%s skcipher algorithm registration error (%d)\\n\",\n\t\t       alg->base.cra_name, ret);\n\t\tkfree(ccp_alg);\n\t\treturn ret;\n\t}\n\n\tlist_add(&ccp_alg->entry, head);\n\n\treturn 0;\n}\n\nint ccp_register_aes_algs(struct list_head *head)\n{\n\tint i, ret;\n\tunsigned int ccpversion = ccp_version();\n\n\tfor (i = 0; i < ARRAY_SIZE(aes_algs); i++) {\n\t\tif (aes_algs[i].version > ccpversion)\n\t\t\tcontinue;\n\t\tret = ccp_register_aes_alg(head, &aes_algs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}