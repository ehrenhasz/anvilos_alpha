{
  "module_name": "ccp-crypto-des3.c",
  "hash_id": "450b0f518ccd1dc70f08ff5b80c96ff51c206a65681f368ac05983c50e8bab30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/ccp-crypto-des3.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <crypto/algapi.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/internal/des.h>\n\n#include \"ccp-crypto.h\"\n\nstatic int ccp_des3_complete(struct crypto_async_request *async_req, int ret)\n{\n\tstruct skcipher_request *req = skcipher_request_cast(async_req);\n\tstruct ccp_ctx *ctx = crypto_skcipher_ctx_dma(\n\t\tcrypto_skcipher_reqtfm(req));\n\tstruct ccp_des3_req_ctx *rctx = skcipher_request_ctx_dma(req);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->u.des3.mode != CCP_DES3_MODE_ECB)\n\t\tmemcpy(req->iv, rctx->iv, DES3_EDE_BLOCK_SIZE);\n\n\treturn 0;\n}\n\nstatic int ccp_des3_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\tunsigned int key_len)\n{\n\tstruct ccp_crypto_skcipher_alg *alg = ccp_crypto_skcipher_alg(tfm);\n\tstruct ccp_ctx *ctx = crypto_skcipher_ctx_dma(tfm);\n\tint err;\n\n\terr = verify_skcipher_des3_key(tfm, key);\n\tif (err)\n\t\treturn err;\n\n\t \n\tctx->u.des3.type = CCP_DES3_TYPE_168;\n\tctx->u.des3.mode = alg->mode;\n\tctx->u.des3.key_len = key_len;\n\n\tmemcpy(ctx->u.des3.key, key, key_len);\n\tsg_init_one(&ctx->u.des3.key_sg, ctx->u.des3.key, key_len);\n\n\treturn 0;\n}\n\nstatic int ccp_des3_crypt(struct skcipher_request *req, bool encrypt)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct ccp_ctx *ctx = crypto_skcipher_ctx_dma(tfm);\n\tstruct ccp_des3_req_ctx *rctx = skcipher_request_ctx_dma(req);\n\tstruct scatterlist *iv_sg = NULL;\n\tunsigned int iv_len = 0;\n\n\tif (!ctx->u.des3.key_len)\n\t\treturn -EINVAL;\n\n\tif (((ctx->u.des3.mode == CCP_DES3_MODE_ECB) ||\n\t     (ctx->u.des3.mode == CCP_DES3_MODE_CBC)) &&\n\t    (req->cryptlen & (DES3_EDE_BLOCK_SIZE - 1)))\n\t\treturn -EINVAL;\n\n\tif (ctx->u.des3.mode != CCP_DES3_MODE_ECB) {\n\t\tif (!req->iv)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(rctx->iv, req->iv, DES3_EDE_BLOCK_SIZE);\n\t\tiv_sg = &rctx->iv_sg;\n\t\tiv_len = DES3_EDE_BLOCK_SIZE;\n\t\tsg_init_one(iv_sg, rctx->iv, iv_len);\n\t}\n\n\tmemset(&rctx->cmd, 0, sizeof(rctx->cmd));\n\tINIT_LIST_HEAD(&rctx->cmd.entry);\n\trctx->cmd.engine = CCP_ENGINE_DES3;\n\trctx->cmd.u.des3.type = ctx->u.des3.type;\n\trctx->cmd.u.des3.mode = ctx->u.des3.mode;\n\trctx->cmd.u.des3.action = (encrypt)\n\t\t\t\t  ? CCP_DES3_ACTION_ENCRYPT\n\t\t\t\t  : CCP_DES3_ACTION_DECRYPT;\n\trctx->cmd.u.des3.key = &ctx->u.des3.key_sg;\n\trctx->cmd.u.des3.key_len = ctx->u.des3.key_len;\n\trctx->cmd.u.des3.iv = iv_sg;\n\trctx->cmd.u.des3.iv_len = iv_len;\n\trctx->cmd.u.des3.src = req->src;\n\trctx->cmd.u.des3.src_len = req->cryptlen;\n\trctx->cmd.u.des3.dst = req->dst;\n\n\treturn ccp_crypto_enqueue_request(&req->base, &rctx->cmd);\n}\n\nstatic int ccp_des3_encrypt(struct skcipher_request *req)\n{\n\treturn ccp_des3_crypt(req, true);\n}\n\nstatic int ccp_des3_decrypt(struct skcipher_request *req)\n{\n\treturn ccp_des3_crypt(req, false);\n}\n\nstatic int ccp_des3_init_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct ccp_ctx *ctx = crypto_skcipher_ctx_dma(tfm);\n\n\tctx->complete = ccp_des3_complete;\n\tctx->u.des3.key_len = 0;\n\n\tcrypto_skcipher_set_reqsize_dma(tfm, sizeof(struct ccp_des3_req_ctx));\n\n\treturn 0;\n}\n\nstatic const struct skcipher_alg ccp_des3_defaults = {\n\t.setkey\t\t\t= ccp_des3_setkey,\n\t.encrypt\t\t= ccp_des3_encrypt,\n\t.decrypt\t\t= ccp_des3_decrypt,\n\t.min_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t.max_keysize\t\t= DES3_EDE_KEY_SIZE,\n\t.init\t\t\t= ccp_des3_init_tfm,\n\n\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t.base.cra_blocksize\t= DES3_EDE_BLOCK_SIZE,\n\t.base.cra_ctxsize\t= sizeof(struct ccp_ctx) + CRYPTO_DMA_PADDING,\n\t.base.cra_priority\t= CCP_CRA_PRIORITY,\n\t.base.cra_module\t= THIS_MODULE,\n};\n\nstruct ccp_des3_def {\n\tenum ccp_des3_mode mode;\n\tunsigned int version;\n\tconst char *name;\n\tconst char *driver_name;\n\tunsigned int blocksize;\n\tunsigned int ivsize;\n\tconst struct skcipher_alg *alg_defaults;\n};\n\nstatic const struct ccp_des3_def des3_algs[] = {\n\t{\n\t\t.mode\t\t= CCP_DES3_MODE_ECB,\n\t\t.version\t= CCP_VERSION(5, 0),\n\t\t.name\t\t= \"ecb(des3_ede)\",\n\t\t.driver_name\t= \"ecb-des3-ccp\",\n\t\t.blocksize\t= DES3_EDE_BLOCK_SIZE,\n\t\t.ivsize\t\t= 0,\n\t\t.alg_defaults\t= &ccp_des3_defaults,\n\t},\n\t{\n\t\t.mode\t\t= CCP_DES3_MODE_CBC,\n\t\t.version\t= CCP_VERSION(5, 0),\n\t\t.name\t\t= \"cbc(des3_ede)\",\n\t\t.driver_name\t= \"cbc-des3-ccp\",\n\t\t.blocksize\t= DES3_EDE_BLOCK_SIZE,\n\t\t.ivsize\t\t= DES3_EDE_BLOCK_SIZE,\n\t\t.alg_defaults\t= &ccp_des3_defaults,\n\t},\n};\n\nstatic int ccp_register_des3_alg(struct list_head *head,\n\t\t\t\t const struct ccp_des3_def *def)\n{\n\tstruct ccp_crypto_skcipher_alg *ccp_alg;\n\tstruct skcipher_alg *alg;\n\tint ret;\n\n\tccp_alg = kzalloc(sizeof(*ccp_alg), GFP_KERNEL);\n\tif (!ccp_alg)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ccp_alg->entry);\n\n\tccp_alg->mode = def->mode;\n\n\t \n\talg = &ccp_alg->alg;\n\t*alg = *def->alg_defaults;\n\tsnprintf(alg->base.cra_name, CRYPTO_MAX_ALG_NAME, \"%s\", def->name);\n\tsnprintf(alg->base.cra_driver_name, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t\tdef->driver_name);\n\talg->base.cra_blocksize = def->blocksize;\n\talg->ivsize = def->ivsize;\n\n\tret = crypto_register_skcipher(alg);\n\tif (ret) {\n\t\tpr_err(\"%s skcipher algorithm registration error (%d)\\n\",\n\t\t\t\talg->base.cra_name, ret);\n\t\tkfree(ccp_alg);\n\t\treturn ret;\n\t}\n\n\tlist_add(&ccp_alg->entry, head);\n\n\treturn 0;\n}\n\nint ccp_register_des3_algs(struct list_head *head)\n{\n\tint i, ret;\n\tunsigned int ccpversion = ccp_version();\n\n\tfor (i = 0; i < ARRAY_SIZE(des3_algs); i++) {\n\t\tif (des3_algs[i].version > ccpversion)\n\t\t\tcontinue;\n\t\tret = ccp_register_des3_alg(head, &des3_algs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}