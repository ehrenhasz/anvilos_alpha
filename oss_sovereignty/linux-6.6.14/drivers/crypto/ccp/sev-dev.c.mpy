{
  "module_name": "sev-dev.c",
  "hash_id": "c19b3073dfa418a7bfd7f84311eca3c8f3a6f16e2ba83f5ee83ea0b4b945a673",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/sev-dev.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/spinlock_types.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/hw_random.h>\n#include <linux/ccp.h>\n#include <linux/firmware.h>\n#include <linux/gfp.h>\n#include <linux/cpufeature.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/psp.h>\n\n#include <asm/smp.h>\n#include <asm/cacheflush.h>\n\n#include \"psp-dev.h\"\n#include \"sev-dev.h\"\n\n#define DEVICE_NAME\t\t\"sev\"\n#define SEV_FW_FILE\t\t\"amd/sev.fw\"\n#define SEV_FW_NAME_SIZE\t64\n\nstatic DEFINE_MUTEX(sev_cmd_mutex);\nstatic struct sev_misc_dev *misc_dev;\n\nstatic int psp_cmd_timeout = 100;\nmodule_param(psp_cmd_timeout, int, 0644);\nMODULE_PARM_DESC(psp_cmd_timeout, \" default timeout value, in seconds, for PSP commands\");\n\nstatic int psp_probe_timeout = 5;\nmodule_param(psp_probe_timeout, int, 0644);\nMODULE_PARM_DESC(psp_probe_timeout, \" default timeout value, in seconds, during PSP device probe\");\n\nstatic char *init_ex_path;\nmodule_param(init_ex_path, charp, 0444);\nMODULE_PARM_DESC(init_ex_path, \" Path for INIT_EX data; if set try INIT_EX\");\n\nstatic bool psp_init_on_probe = true;\nmodule_param(psp_init_on_probe, bool, 0444);\nMODULE_PARM_DESC(psp_init_on_probe, \"  if true, the PSP will be initialized on module init. Else the PSP will be initialized on the first command requiring it\");\n\nMODULE_FIRMWARE(\"amd/amd_sev_fam17h_model0xh.sbin\");  \nMODULE_FIRMWARE(\"amd/amd_sev_fam17h_model3xh.sbin\");  \nMODULE_FIRMWARE(\"amd/amd_sev_fam19h_model0xh.sbin\");  \nMODULE_FIRMWARE(\"amd/amd_sev_fam19h_model1xh.sbin\");  \n\nstatic bool psp_dead;\nstatic int psp_timeout;\n\n \n#define SEV_ES_TMR_SIZE\t\t(1024 * 1024)\nstatic void *sev_es_tmr;\n\n \n#define NV_LENGTH (32 * 1024)\nstatic void *sev_init_ex_buffer;\n\nstatic inline bool sev_version_greater_or_equal(u8 maj, u8 min)\n{\n\tstruct sev_device *sev = psp_master->sev_data;\n\n\tif (sev->api_major > maj)\n\t\treturn true;\n\n\tif (sev->api_major == maj && sev->api_minor >= min)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void sev_irq_handler(int irq, void *data, unsigned int status)\n{\n\tstruct sev_device *sev = data;\n\tint reg;\n\n\t \n\tif (!(status & SEV_CMD_COMPLETE))\n\t\treturn;\n\n\t \n\treg = ioread32(sev->io_regs + sev->vdata->cmdresp_reg);\n\tif (FIELD_GET(PSP_CMDRESP_RESP, reg)) {\n\t\tsev->int_rcvd = 1;\n\t\twake_up(&sev->int_queue);\n\t}\n}\n\nstatic int sev_wait_cmd_ioc(struct sev_device *sev,\n\t\t\t    unsigned int *reg, unsigned int timeout)\n{\n\tint ret;\n\n\tret = wait_event_timeout(sev->int_queue,\n\t\t\tsev->int_rcvd, timeout * HZ);\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\t*reg = ioread32(sev->io_regs + sev->vdata->cmdresp_reg);\n\n\treturn 0;\n}\n\nstatic int sev_cmd_buffer_len(int cmd)\n{\n\tswitch (cmd) {\n\tcase SEV_CMD_INIT:\t\t\treturn sizeof(struct sev_data_init);\n\tcase SEV_CMD_INIT_EX:                   return sizeof(struct sev_data_init_ex);\n\tcase SEV_CMD_PLATFORM_STATUS:\t\treturn sizeof(struct sev_user_data_status);\n\tcase SEV_CMD_PEK_CSR:\t\t\treturn sizeof(struct sev_data_pek_csr);\n\tcase SEV_CMD_PEK_CERT_IMPORT:\t\treturn sizeof(struct sev_data_pek_cert_import);\n\tcase SEV_CMD_PDH_CERT_EXPORT:\t\treturn sizeof(struct sev_data_pdh_cert_export);\n\tcase SEV_CMD_LAUNCH_START:\t\treturn sizeof(struct sev_data_launch_start);\n\tcase SEV_CMD_LAUNCH_UPDATE_DATA:\treturn sizeof(struct sev_data_launch_update_data);\n\tcase SEV_CMD_LAUNCH_UPDATE_VMSA:\treturn sizeof(struct sev_data_launch_update_vmsa);\n\tcase SEV_CMD_LAUNCH_FINISH:\t\treturn sizeof(struct sev_data_launch_finish);\n\tcase SEV_CMD_LAUNCH_MEASURE:\t\treturn sizeof(struct sev_data_launch_measure);\n\tcase SEV_CMD_ACTIVATE:\t\t\treturn sizeof(struct sev_data_activate);\n\tcase SEV_CMD_DEACTIVATE:\t\treturn sizeof(struct sev_data_deactivate);\n\tcase SEV_CMD_DECOMMISSION:\t\treturn sizeof(struct sev_data_decommission);\n\tcase SEV_CMD_GUEST_STATUS:\t\treturn sizeof(struct sev_data_guest_status);\n\tcase SEV_CMD_DBG_DECRYPT:\t\treturn sizeof(struct sev_data_dbg);\n\tcase SEV_CMD_DBG_ENCRYPT:\t\treturn sizeof(struct sev_data_dbg);\n\tcase SEV_CMD_SEND_START:\t\treturn sizeof(struct sev_data_send_start);\n\tcase SEV_CMD_SEND_UPDATE_DATA:\t\treturn sizeof(struct sev_data_send_update_data);\n\tcase SEV_CMD_SEND_UPDATE_VMSA:\t\treturn sizeof(struct sev_data_send_update_vmsa);\n\tcase SEV_CMD_SEND_FINISH:\t\treturn sizeof(struct sev_data_send_finish);\n\tcase SEV_CMD_RECEIVE_START:\t\treturn sizeof(struct sev_data_receive_start);\n\tcase SEV_CMD_RECEIVE_FINISH:\t\treturn sizeof(struct sev_data_receive_finish);\n\tcase SEV_CMD_RECEIVE_UPDATE_DATA:\treturn sizeof(struct sev_data_receive_update_data);\n\tcase SEV_CMD_RECEIVE_UPDATE_VMSA:\treturn sizeof(struct sev_data_receive_update_vmsa);\n\tcase SEV_CMD_LAUNCH_UPDATE_SECRET:\treturn sizeof(struct sev_data_launch_secret);\n\tcase SEV_CMD_DOWNLOAD_FIRMWARE:\t\treturn sizeof(struct sev_data_download_firmware);\n\tcase SEV_CMD_GET_ID:\t\t\treturn sizeof(struct sev_data_get_id);\n\tcase SEV_CMD_ATTESTATION_REPORT:\treturn sizeof(struct sev_data_attestation_report);\n\tcase SEV_CMD_SEND_CANCEL:\t\treturn sizeof(struct sev_data_send_cancel);\n\tdefault:\t\t\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void *sev_fw_alloc(unsigned long len)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(GFP_KERNEL, get_order(len));\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}\n\nstatic struct file *open_file_as_root(const char *filename, int flags, umode_t mode)\n{\n\tstruct file *fp;\n\tstruct path root;\n\tstruct cred *cred;\n\tconst struct cred *old_cred;\n\n\ttask_lock(&init_task);\n\tget_fs_root(init_task.fs, &root);\n\ttask_unlock(&init_task);\n\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcred->fsuid = GLOBAL_ROOT_UID;\n\told_cred = override_creds(cred);\n\n\tfp = file_open_root(&root, filename, flags, mode);\n\tpath_put(&root);\n\n\trevert_creds(old_cred);\n\n\treturn fp;\n}\n\nstatic int sev_read_init_ex_file(void)\n{\n\tstruct sev_device *sev = psp_master->sev_data;\n\tstruct file *fp;\n\tssize_t nread;\n\n\tlockdep_assert_held(&sev_cmd_mutex);\n\n\tif (!sev_init_ex_buffer)\n\t\treturn -EOPNOTSUPP;\n\n\tfp = open_file_as_root(init_ex_path, O_RDONLY, 0);\n\tif (IS_ERR(fp)) {\n\t\tint ret = PTR_ERR(fp);\n\n\t\tif (ret == -ENOENT) {\n\t\t\tdev_info(sev->dev,\n\t\t\t\t\"SEV: %s does not exist and will be created later.\\n\",\n\t\t\t\tinit_ex_path);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tdev_err(sev->dev,\n\t\t\t\t\"SEV: could not open %s for read, error %d\\n\",\n\t\t\t\tinit_ex_path, ret);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tnread = kernel_read(fp, sev_init_ex_buffer, NV_LENGTH, NULL);\n\tif (nread != NV_LENGTH) {\n\t\tdev_info(sev->dev,\n\t\t\t\"SEV: could not read %u bytes to non volatile memory area, ret %ld\\n\",\n\t\t\tNV_LENGTH, nread);\n\t}\n\n\tdev_dbg(sev->dev, \"SEV: read %ld bytes from NV file\\n\", nread);\n\tfilp_close(fp, NULL);\n\n\treturn 0;\n}\n\nstatic int sev_write_init_ex_file(void)\n{\n\tstruct sev_device *sev = psp_master->sev_data;\n\tstruct file *fp;\n\tloff_t offset = 0;\n\tssize_t nwrite;\n\n\tlockdep_assert_held(&sev_cmd_mutex);\n\n\tif (!sev_init_ex_buffer)\n\t\treturn 0;\n\n\tfp = open_file_as_root(init_ex_path, O_CREAT | O_WRONLY, 0600);\n\tif (IS_ERR(fp)) {\n\t\tint ret = PTR_ERR(fp);\n\n\t\tdev_err(sev->dev,\n\t\t\t\"SEV: could not open file for write, error %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tnwrite = kernel_write(fp, sev_init_ex_buffer, NV_LENGTH, &offset);\n\tvfs_fsync(fp, 0);\n\tfilp_close(fp, NULL);\n\n\tif (nwrite != NV_LENGTH) {\n\t\tdev_err(sev->dev,\n\t\t\t\"SEV: failed to write %u bytes to non volatile memory area, ret %ld\\n\",\n\t\t\tNV_LENGTH, nwrite);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(sev->dev, \"SEV: write successful to NV file\\n\");\n\n\treturn 0;\n}\n\nstatic int sev_write_init_ex_file_if_required(int cmd_id)\n{\n\tlockdep_assert_held(&sev_cmd_mutex);\n\n\tif (!sev_init_ex_buffer)\n\t\treturn 0;\n\n\t \n\tswitch (cmd_id) {\n\tcase SEV_CMD_FACTORY_RESET:\n\tcase SEV_CMD_INIT_EX:\n\tcase SEV_CMD_PDH_GEN:\n\tcase SEV_CMD_PEK_CERT_IMPORT:\n\tcase SEV_CMD_PEK_GEN:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn sev_write_init_ex_file();\n}\n\nstatic int __sev_do_cmd_locked(int cmd, void *data, int *psp_ret)\n{\n\tstruct psp_device *psp = psp_master;\n\tstruct sev_device *sev;\n\tunsigned int phys_lsb, phys_msb;\n\tunsigned int reg, ret = 0;\n\tint buf_len;\n\n\tif (!psp || !psp->sev_data)\n\t\treturn -ENODEV;\n\n\tif (psp_dead)\n\t\treturn -EBUSY;\n\n\tsev = psp->sev_data;\n\n\tbuf_len = sev_cmd_buffer_len(cmd);\n\tif (WARN_ON_ONCE(!data != !buf_len))\n\t\treturn -EINVAL;\n\n\t \n\tif (data)\n\t\tmemcpy(sev->cmd_buf, data, buf_len);\n\n\t \n\tphys_lsb = data ? lower_32_bits(__psp_pa(sev->cmd_buf)) : 0;\n\tphys_msb = data ? upper_32_bits(__psp_pa(sev->cmd_buf)) : 0;\n\n\tdev_dbg(sev->dev, \"sev command id %#x buffer 0x%08x%08x timeout %us\\n\",\n\t\tcmd, phys_msb, phys_lsb, psp_timeout);\n\n\tprint_hex_dump_debug(\"(in):  \", DUMP_PREFIX_OFFSET, 16, 2, data,\n\t\t\t     buf_len, false);\n\n\tiowrite32(phys_lsb, sev->io_regs + sev->vdata->cmdbuff_addr_lo_reg);\n\tiowrite32(phys_msb, sev->io_regs + sev->vdata->cmdbuff_addr_hi_reg);\n\n\tsev->int_rcvd = 0;\n\n\treg = FIELD_PREP(SEV_CMDRESP_CMD, cmd) | SEV_CMDRESP_IOC;\n\tiowrite32(reg, sev->io_regs + sev->vdata->cmdresp_reg);\n\n\t \n\tret = sev_wait_cmd_ioc(sev, &reg, psp_timeout);\n\tif (ret) {\n\t\tif (psp_ret)\n\t\t\t*psp_ret = 0;\n\n\t\tdev_err(sev->dev, \"sev command %#x timed out, disabling PSP\\n\", cmd);\n\t\tpsp_dead = true;\n\n\t\treturn ret;\n\t}\n\n\tpsp_timeout = psp_cmd_timeout;\n\n\tif (psp_ret)\n\t\t*psp_ret = FIELD_GET(PSP_CMDRESP_STS, reg);\n\n\tif (FIELD_GET(PSP_CMDRESP_STS, reg)) {\n\t\tdev_dbg(sev->dev, \"sev command %#x failed (%#010lx)\\n\",\n\t\t\tcmd, FIELD_GET(PSP_CMDRESP_STS, reg));\n\t\tret = -EIO;\n\t} else {\n\t\tret = sev_write_init_ex_file_if_required(cmd);\n\t}\n\n\tprint_hex_dump_debug(\"(out): \", DUMP_PREFIX_OFFSET, 16, 2, data,\n\t\t\t     buf_len, false);\n\n\t \n\tif (data)\n\t\tmemcpy(data, sev->cmd_buf, buf_len);\n\n\treturn ret;\n}\n\nstatic int sev_do_cmd(int cmd, void *data, int *psp_ret)\n{\n\tint rc;\n\n\tmutex_lock(&sev_cmd_mutex);\n\trc = __sev_do_cmd_locked(cmd, data, psp_ret);\n\tmutex_unlock(&sev_cmd_mutex);\n\n\treturn rc;\n}\n\nstatic int __sev_init_locked(int *error)\n{\n\tstruct sev_data_init data;\n\n\tmemset(&data, 0, sizeof(data));\n\tif (sev_es_tmr) {\n\t\t \n\t\tdata.tmr_address = __pa(sev_es_tmr);\n\n\t\tdata.flags |= SEV_INIT_FLAGS_SEV_ES;\n\t\tdata.tmr_len = SEV_ES_TMR_SIZE;\n\t}\n\n\treturn __sev_do_cmd_locked(SEV_CMD_INIT, &data, error);\n}\n\nstatic int __sev_init_ex_locked(int *error)\n{\n\tstruct sev_data_init_ex data;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.length = sizeof(data);\n\tdata.nv_address = __psp_pa(sev_init_ex_buffer);\n\tdata.nv_len = NV_LENGTH;\n\n\tif (sev_es_tmr) {\n\t\t \n\t\tdata.tmr_address = __pa(sev_es_tmr);\n\n\t\tdata.flags |= SEV_INIT_FLAGS_SEV_ES;\n\t\tdata.tmr_len = SEV_ES_TMR_SIZE;\n\t}\n\n\treturn __sev_do_cmd_locked(SEV_CMD_INIT_EX, &data, error);\n}\n\nstatic inline int __sev_do_init_locked(int *psp_ret)\n{\n\tif (sev_init_ex_buffer)\n\t\treturn __sev_init_ex_locked(psp_ret);\n\telse\n\t\treturn __sev_init_locked(psp_ret);\n}\n\nstatic int __sev_platform_init_locked(int *error)\n{\n\tint rc = 0, psp_ret = SEV_RET_NO_FW_CALL;\n\tstruct psp_device *psp = psp_master;\n\tstruct sev_device *sev;\n\n\tif (!psp || !psp->sev_data)\n\t\treturn -ENODEV;\n\n\tsev = psp->sev_data;\n\n\tif (sev->state == SEV_STATE_INIT)\n\t\treturn 0;\n\n\tif (sev_init_ex_buffer) {\n\t\trc = sev_read_init_ex_file();\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = __sev_do_init_locked(&psp_ret);\n\tif (rc && psp_ret == SEV_RET_SECURE_DATA_INVALID) {\n\t\t \n\t\tdev_err(sev->dev,\n\"SEV: retrying INIT command because of SECURE_DATA_INVALID error. Retrying once to reset PSP SEV state.\");\n\t\trc = __sev_do_init_locked(&psp_ret);\n\t}\n\n\tif (error)\n\t\t*error = psp_ret;\n\n\tif (rc)\n\t\treturn rc;\n\n\tsev->state = SEV_STATE_INIT;\n\n\t \n\twbinvd_on_all_cpus();\n\trc = __sev_do_cmd_locked(SEV_CMD_DF_FLUSH, NULL, error);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_dbg(sev->dev, \"SEV firmware initialized\\n\");\n\n\tdev_info(sev->dev, \"SEV API:%d.%d build:%d\\n\", sev->api_major,\n\t\t sev->api_minor, sev->build);\n\n\treturn 0;\n}\n\nint sev_platform_init(int *error)\n{\n\tint rc;\n\n\tmutex_lock(&sev_cmd_mutex);\n\trc = __sev_platform_init_locked(error);\n\tmutex_unlock(&sev_cmd_mutex);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(sev_platform_init);\n\nstatic int __sev_platform_shutdown_locked(int *error)\n{\n\tstruct sev_device *sev = psp_master->sev_data;\n\tint ret;\n\n\tif (!sev || sev->state == SEV_STATE_UNINIT)\n\t\treturn 0;\n\n\tret = __sev_do_cmd_locked(SEV_CMD_SHUTDOWN, NULL, error);\n\tif (ret)\n\t\treturn ret;\n\n\tsev->state = SEV_STATE_UNINIT;\n\tdev_dbg(sev->dev, \"SEV firmware shutdown\\n\");\n\n\treturn ret;\n}\n\nstatic int sev_platform_shutdown(int *error)\n{\n\tint rc;\n\n\tmutex_lock(&sev_cmd_mutex);\n\trc = __sev_platform_shutdown_locked(NULL);\n\tmutex_unlock(&sev_cmd_mutex);\n\n\treturn rc;\n}\n\nstatic int sev_get_platform_state(int *state, int *error)\n{\n\tstruct sev_user_data_status data;\n\tint rc;\n\n\trc = __sev_do_cmd_locked(SEV_CMD_PLATFORM_STATUS, &data, error);\n\tif (rc)\n\t\treturn rc;\n\n\t*state = data.state;\n\treturn rc;\n}\n\nstatic int sev_ioctl_do_reset(struct sev_issue_cmd *argp, bool writable)\n{\n\tint state, rc;\n\n\tif (!writable)\n\t\treturn -EPERM;\n\n\t \n\trc = sev_get_platform_state(&state, &argp->error);\n\tif (rc)\n\t\treturn rc;\n\n\tif (state == SEV_STATE_WORKING)\n\t\treturn -EBUSY;\n\n\tif (state == SEV_STATE_INIT) {\n\t\trc = __sev_platform_shutdown_locked(&argp->error);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn __sev_do_cmd_locked(SEV_CMD_FACTORY_RESET, NULL, &argp->error);\n}\n\nstatic int sev_ioctl_do_platform_status(struct sev_issue_cmd *argp)\n{\n\tstruct sev_user_data_status data;\n\tint ret;\n\n\tmemset(&data, 0, sizeof(data));\n\n\tret = __sev_do_cmd_locked(SEV_CMD_PLATFORM_STATUS, &data, &argp->error);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_to_user((void __user *)argp->data, &data, sizeof(data)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic int sev_ioctl_do_pek_pdh_gen(int cmd, struct sev_issue_cmd *argp, bool writable)\n{\n\tstruct sev_device *sev = psp_master->sev_data;\n\tint rc;\n\n\tif (!writable)\n\t\treturn -EPERM;\n\n\tif (sev->state == SEV_STATE_UNINIT) {\n\t\trc = __sev_platform_init_locked(&argp->error);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn __sev_do_cmd_locked(cmd, NULL, &argp->error);\n}\n\nstatic int sev_ioctl_do_pek_csr(struct sev_issue_cmd *argp, bool writable)\n{\n\tstruct sev_device *sev = psp_master->sev_data;\n\tstruct sev_user_data_pek_csr input;\n\tstruct sev_data_pek_csr data;\n\tvoid __user *input_address;\n\tvoid *blob = NULL;\n\tint ret;\n\n\tif (!writable)\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))\n\t\treturn -EFAULT;\n\n\tmemset(&data, 0, sizeof(data));\n\n\t \n\tif (!input.address || !input.length)\n\t\tgoto cmd;\n\n\t \n\tinput_address = (void __user *)input.address;\n\tif (input.length > SEV_FW_BLOB_MAX_SIZE)\n\t\treturn -EFAULT;\n\n\tblob = kzalloc(input.length, GFP_KERNEL);\n\tif (!blob)\n\t\treturn -ENOMEM;\n\n\tdata.address = __psp_pa(blob);\n\tdata.len = input.length;\n\ncmd:\n\tif (sev->state == SEV_STATE_UNINIT) {\n\t\tret = __sev_platform_init_locked(&argp->error);\n\t\tif (ret)\n\t\t\tgoto e_free_blob;\n\t}\n\n\tret = __sev_do_cmd_locked(SEV_CMD_PEK_CSR, &data, &argp->error);\n\n\t  \n\tinput.length = data.len;\n\n\tif (copy_to_user((void __user *)argp->data, &input, sizeof(input))) {\n\t\tret = -EFAULT;\n\t\tgoto e_free_blob;\n\t}\n\n\tif (blob) {\n\t\tif (copy_to_user(input_address, blob, input.length))\n\t\t\tret = -EFAULT;\n\t}\n\ne_free_blob:\n\tkfree(blob);\n\treturn ret;\n}\n\nvoid *psp_copy_user_blob(u64 uaddr, u32 len)\n{\n\tif (!uaddr || !len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (len > SEV_FW_BLOB_MAX_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn memdup_user((void __user *)uaddr, len);\n}\nEXPORT_SYMBOL_GPL(psp_copy_user_blob);\n\nstatic int sev_get_api_version(void)\n{\n\tstruct sev_device *sev = psp_master->sev_data;\n\tstruct sev_user_data_status status;\n\tint error = 0, ret;\n\n\tret = sev_platform_status(&status, &error);\n\tif (ret) {\n\t\tdev_err(sev->dev,\n\t\t\t\"SEV: failed to get status. Error: %#x\\n\", error);\n\t\treturn 1;\n\t}\n\n\tsev->api_major = status.api_major;\n\tsev->api_minor = status.api_minor;\n\tsev->build = status.build;\n\tsev->state = status.state;\n\n\treturn 0;\n}\n\nstatic int sev_get_firmware(struct device *dev,\n\t\t\t    const struct firmware **firmware)\n{\n\tchar fw_name_specific[SEV_FW_NAME_SIZE];\n\tchar fw_name_subset[SEV_FW_NAME_SIZE];\n\n\tsnprintf(fw_name_specific, sizeof(fw_name_specific),\n\t\t \"amd/amd_sev_fam%.2xh_model%.2xh.sbin\",\n\t\t boot_cpu_data.x86, boot_cpu_data.x86_model);\n\n\tsnprintf(fw_name_subset, sizeof(fw_name_subset),\n\t\t \"amd/amd_sev_fam%.2xh_model%.1xxh.sbin\",\n\t\t boot_cpu_data.x86, (boot_cpu_data.x86_model & 0xf0) >> 4);\n\n\t \n\tif ((firmware_request_nowarn(firmware, fw_name_specific, dev) >= 0) ||\n\t    (firmware_request_nowarn(firmware, fw_name_subset, dev) >= 0) ||\n\t    (firmware_request_nowarn(firmware, SEV_FW_FILE, dev) >= 0))\n\t\treturn 0;\n\n\treturn -ENOENT;\n}\n\n \nstatic int sev_update_firmware(struct device *dev)\n{\n\tstruct sev_data_download_firmware *data;\n\tconst struct firmware *firmware;\n\tint ret, error, order;\n\tstruct page *p;\n\tu64 data_size;\n\n\tif (!sev_version_greater_or_equal(0, 15)) {\n\t\tdev_dbg(dev, \"DOWNLOAD_FIRMWARE not supported\\n\");\n\t\treturn -1;\n\t}\n\n\tif (sev_get_firmware(dev, &firmware) == -ENOENT) {\n\t\tdev_dbg(dev, \"No SEV firmware file present\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tdata_size = ALIGN(sizeof(struct sev_data_download_firmware), 32);\n\n\torder = get_order(firmware->size + data_size);\n\tp = alloc_pages(GFP_KERNEL, order);\n\tif (!p) {\n\t\tret = -1;\n\t\tgoto fw_err;\n\t}\n\n\t \n\tdata = page_address(p);\n\tmemcpy(page_address(p) + data_size, firmware->data, firmware->size);\n\n\tdata->address = __psp_pa(page_address(p) + data_size);\n\tdata->len = firmware->size;\n\n\tret = sev_do_cmd(SEV_CMD_DOWNLOAD_FIRMWARE, data, &error);\n\n\t \n\tif (!ret && !sev_version_greater_or_equal(1, 50))\n\t\tret = sev_do_cmd(SEV_CMD_DOWNLOAD_FIRMWARE, data, &error);\n\n\tif (ret)\n\t\tdev_dbg(dev, \"Failed to update SEV firmware: %#x\\n\", error);\n\telse\n\t\tdev_info(dev, \"SEV firmware update successful\\n\");\n\n\t__free_pages(p, order);\n\nfw_err:\n\trelease_firmware(firmware);\n\n\treturn ret;\n}\n\nstatic int sev_ioctl_do_pek_import(struct sev_issue_cmd *argp, bool writable)\n{\n\tstruct sev_device *sev = psp_master->sev_data;\n\tstruct sev_user_data_pek_cert_import input;\n\tstruct sev_data_pek_cert_import data;\n\tvoid *pek_blob, *oca_blob;\n\tint ret;\n\n\tif (!writable)\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))\n\t\treturn -EFAULT;\n\n\t \n\tpek_blob = psp_copy_user_blob(input.pek_cert_address, input.pek_cert_len);\n\tif (IS_ERR(pek_blob))\n\t\treturn PTR_ERR(pek_blob);\n\n\tdata.reserved = 0;\n\tdata.pek_cert_address = __psp_pa(pek_blob);\n\tdata.pek_cert_len = input.pek_cert_len;\n\n\t \n\toca_blob = psp_copy_user_blob(input.oca_cert_address, input.oca_cert_len);\n\tif (IS_ERR(oca_blob)) {\n\t\tret = PTR_ERR(oca_blob);\n\t\tgoto e_free_pek;\n\t}\n\n\tdata.oca_cert_address = __psp_pa(oca_blob);\n\tdata.oca_cert_len = input.oca_cert_len;\n\n\t \n\tif (sev->state != SEV_STATE_INIT) {\n\t\tret = __sev_platform_init_locked(&argp->error);\n\t\tif (ret)\n\t\t\tgoto e_free_oca;\n\t}\n\n\tret = __sev_do_cmd_locked(SEV_CMD_PEK_CERT_IMPORT, &data, &argp->error);\n\ne_free_oca:\n\tkfree(oca_blob);\ne_free_pek:\n\tkfree(pek_blob);\n\treturn ret;\n}\n\nstatic int sev_ioctl_do_get_id2(struct sev_issue_cmd *argp)\n{\n\tstruct sev_user_data_get_id2 input;\n\tstruct sev_data_get_id data;\n\tvoid __user *input_address;\n\tvoid *id_blob = NULL;\n\tint ret;\n\n\t \n\tif (!sev_version_greater_or_equal(0, 16))\n\t\treturn -ENOTSUPP;\n\n\tif (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))\n\t\treturn -EFAULT;\n\n\tinput_address = (void __user *)input.address;\n\n\tif (input.address && input.length) {\n\t\t \n\t\tid_blob = kzalloc(input.length, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!id_blob)\n\t\t\treturn -ENOMEM;\n\n\t\tdata.address = __psp_pa(id_blob);\n\t\tdata.len = input.length;\n\t} else {\n\t\tdata.address = 0;\n\t\tdata.len = 0;\n\t}\n\n\tret = __sev_do_cmd_locked(SEV_CMD_GET_ID, &data, &argp->error);\n\n\t \n\tinput.length = data.len;\n\n\tif (copy_to_user((void __user *)argp->data, &input, sizeof(input))) {\n\t\tret = -EFAULT;\n\t\tgoto e_free;\n\t}\n\n\tif (id_blob) {\n\t\tif (copy_to_user(input_address, id_blob, data.len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto e_free;\n\t\t}\n\t}\n\ne_free:\n\tkfree(id_blob);\n\n\treturn ret;\n}\n\nstatic int sev_ioctl_do_get_id(struct sev_issue_cmd *argp)\n{\n\tstruct sev_data_get_id *data;\n\tu64 data_size, user_size;\n\tvoid *id_blob, *mem;\n\tint ret;\n\n\t \n\tif (!sev_version_greater_or_equal(0, 16))\n\t\treturn -ENOTSUPP;\n\n\t \n\tdata_size = ALIGN(sizeof(struct sev_data_get_id), 8);\n\tuser_size = sizeof(struct sev_user_data_get_id);\n\n\tmem = kzalloc(data_size + user_size, GFP_KERNEL);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\tdata = mem;\n\tid_blob = mem + data_size;\n\n\tdata->address = __psp_pa(id_blob);\n\tdata->len = user_size;\n\n\tret = __sev_do_cmd_locked(SEV_CMD_GET_ID, data, &argp->error);\n\tif (!ret) {\n\t\tif (copy_to_user((void __user *)argp->data, id_blob, data->len))\n\t\t\tret = -EFAULT;\n\t}\n\n\tkfree(mem);\n\n\treturn ret;\n}\n\nstatic int sev_ioctl_do_pdh_export(struct sev_issue_cmd *argp, bool writable)\n{\n\tstruct sev_device *sev = psp_master->sev_data;\n\tstruct sev_user_data_pdh_cert_export input;\n\tvoid *pdh_blob = NULL, *cert_blob = NULL;\n\tstruct sev_data_pdh_cert_export data;\n\tvoid __user *input_cert_chain_address;\n\tvoid __user *input_pdh_cert_address;\n\tint ret;\n\n\t \n\tif (sev->state != SEV_STATE_INIT) {\n\t\tif (!writable)\n\t\t\treturn -EPERM;\n\n\t\tret = __sev_platform_init_locked(&argp->error);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (copy_from_user(&input, (void __user *)argp->data, sizeof(input)))\n\t\treturn -EFAULT;\n\n\tmemset(&data, 0, sizeof(data));\n\n\t \n\tif (!input.pdh_cert_address ||\n\t    !input.pdh_cert_len ||\n\t    !input.cert_chain_address)\n\t\tgoto cmd;\n\n\tinput_pdh_cert_address = (void __user *)input.pdh_cert_address;\n\tinput_cert_chain_address = (void __user *)input.cert_chain_address;\n\n\t \n\tif (input.pdh_cert_len > SEV_FW_BLOB_MAX_SIZE)\n\t\treturn -EFAULT;\n\n\t \n\tif (input.cert_chain_len > SEV_FW_BLOB_MAX_SIZE)\n\t\treturn -EFAULT;\n\n\tpdh_blob = kzalloc(input.pdh_cert_len, GFP_KERNEL);\n\tif (!pdh_blob)\n\t\treturn -ENOMEM;\n\n\tdata.pdh_cert_address = __psp_pa(pdh_blob);\n\tdata.pdh_cert_len = input.pdh_cert_len;\n\n\tcert_blob = kzalloc(input.cert_chain_len, GFP_KERNEL);\n\tif (!cert_blob) {\n\t\tret = -ENOMEM;\n\t\tgoto e_free_pdh;\n\t}\n\n\tdata.cert_chain_address = __psp_pa(cert_blob);\n\tdata.cert_chain_len = input.cert_chain_len;\n\ncmd:\n\tret = __sev_do_cmd_locked(SEV_CMD_PDH_CERT_EXPORT, &data, &argp->error);\n\n\t \n\tinput.cert_chain_len = data.cert_chain_len;\n\tinput.pdh_cert_len = data.pdh_cert_len;\n\n\tif (copy_to_user((void __user *)argp->data, &input, sizeof(input))) {\n\t\tret = -EFAULT;\n\t\tgoto e_free_cert;\n\t}\n\n\tif (pdh_blob) {\n\t\tif (copy_to_user(input_pdh_cert_address,\n\t\t\t\t pdh_blob, input.pdh_cert_len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto e_free_cert;\n\t\t}\n\t}\n\n\tif (cert_blob) {\n\t\tif (copy_to_user(input_cert_chain_address,\n\t\t\t\t cert_blob, input.cert_chain_len))\n\t\t\tret = -EFAULT;\n\t}\n\ne_free_cert:\n\tkfree(cert_blob);\ne_free_pdh:\n\tkfree(pdh_blob);\n\treturn ret;\n}\n\nstatic long sev_ioctl(struct file *file, unsigned int ioctl, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tstruct sev_issue_cmd input;\n\tint ret = -EFAULT;\n\tbool writable = file->f_mode & FMODE_WRITE;\n\n\tif (!psp_master || !psp_master->sev_data)\n\t\treturn -ENODEV;\n\n\tif (ioctl != SEV_ISSUE_CMD)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&input, argp, sizeof(struct sev_issue_cmd)))\n\t\treturn -EFAULT;\n\n\tif (input.cmd > SEV_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sev_cmd_mutex);\n\n\tswitch (input.cmd) {\n\n\tcase SEV_FACTORY_RESET:\n\t\tret = sev_ioctl_do_reset(&input, writable);\n\t\tbreak;\n\tcase SEV_PLATFORM_STATUS:\n\t\tret = sev_ioctl_do_platform_status(&input);\n\t\tbreak;\n\tcase SEV_PEK_GEN:\n\t\tret = sev_ioctl_do_pek_pdh_gen(SEV_CMD_PEK_GEN, &input, writable);\n\t\tbreak;\n\tcase SEV_PDH_GEN:\n\t\tret = sev_ioctl_do_pek_pdh_gen(SEV_CMD_PDH_GEN, &input, writable);\n\t\tbreak;\n\tcase SEV_PEK_CSR:\n\t\tret = sev_ioctl_do_pek_csr(&input, writable);\n\t\tbreak;\n\tcase SEV_PEK_CERT_IMPORT:\n\t\tret = sev_ioctl_do_pek_import(&input, writable);\n\t\tbreak;\n\tcase SEV_PDH_CERT_EXPORT:\n\t\tret = sev_ioctl_do_pdh_export(&input, writable);\n\t\tbreak;\n\tcase SEV_GET_ID:\n\t\tpr_warn_once(\"SEV_GET_ID command is deprecated, use SEV_GET_ID2\\n\");\n\t\tret = sev_ioctl_do_get_id(&input);\n\t\tbreak;\n\tcase SEV_GET_ID2:\n\t\tret = sev_ioctl_do_get_id2(&input);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(argp, &input, sizeof(struct sev_issue_cmd)))\n\t\tret = -EFAULT;\nout:\n\tmutex_unlock(&sev_cmd_mutex);\n\n\treturn ret;\n}\n\nstatic const struct file_operations sev_fops = {\n\t.owner\t= THIS_MODULE,\n\t.unlocked_ioctl = sev_ioctl,\n};\n\nint sev_platform_status(struct sev_user_data_status *data, int *error)\n{\n\treturn sev_do_cmd(SEV_CMD_PLATFORM_STATUS, data, error);\n}\nEXPORT_SYMBOL_GPL(sev_platform_status);\n\nint sev_guest_deactivate(struct sev_data_deactivate *data, int *error)\n{\n\treturn sev_do_cmd(SEV_CMD_DEACTIVATE, data, error);\n}\nEXPORT_SYMBOL_GPL(sev_guest_deactivate);\n\nint sev_guest_activate(struct sev_data_activate *data, int *error)\n{\n\treturn sev_do_cmd(SEV_CMD_ACTIVATE, data, error);\n}\nEXPORT_SYMBOL_GPL(sev_guest_activate);\n\nint sev_guest_decommission(struct sev_data_decommission *data, int *error)\n{\n\treturn sev_do_cmd(SEV_CMD_DECOMMISSION, data, error);\n}\nEXPORT_SYMBOL_GPL(sev_guest_decommission);\n\nint sev_guest_df_flush(int *error)\n{\n\treturn sev_do_cmd(SEV_CMD_DF_FLUSH, NULL, error);\n}\nEXPORT_SYMBOL_GPL(sev_guest_df_flush);\n\nstatic void sev_exit(struct kref *ref)\n{\n\tmisc_deregister(&misc_dev->misc);\n\tkfree(misc_dev);\n\tmisc_dev = NULL;\n}\n\nstatic int sev_misc_init(struct sev_device *sev)\n{\n\tstruct device *dev = sev->dev;\n\tint ret;\n\n\t \n\tif (!misc_dev) {\n\t\tstruct miscdevice *misc;\n\n\t\tmisc_dev = kzalloc(sizeof(*misc_dev), GFP_KERNEL);\n\t\tif (!misc_dev)\n\t\t\treturn -ENOMEM;\n\n\t\tmisc = &misc_dev->misc;\n\t\tmisc->minor = MISC_DYNAMIC_MINOR;\n\t\tmisc->name = DEVICE_NAME;\n\t\tmisc->fops = &sev_fops;\n\n\t\tret = misc_register(misc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tkref_init(&misc_dev->refcount);\n\t} else {\n\t\tkref_get(&misc_dev->refcount);\n\t}\n\n\tinit_waitqueue_head(&sev->int_queue);\n\tsev->misc = misc_dev;\n\tdev_dbg(dev, \"registered SEV device\\n\");\n\n\treturn 0;\n}\n\nint sev_dev_init(struct psp_device *psp)\n{\n\tstruct device *dev = psp->dev;\n\tstruct sev_device *sev;\n\tint ret = -ENOMEM;\n\n\tif (!boot_cpu_has(X86_FEATURE_SEV)) {\n\t\tdev_info_once(dev, \"SEV: memory encryption not enabled by BIOS\\n\");\n\t\treturn 0;\n\t}\n\n\tsev = devm_kzalloc(dev, sizeof(*sev), GFP_KERNEL);\n\tif (!sev)\n\t\tgoto e_err;\n\n\tsev->cmd_buf = (void *)devm_get_free_pages(dev, GFP_KERNEL, 0);\n\tif (!sev->cmd_buf)\n\t\tgoto e_sev;\n\n\tpsp->sev_data = sev;\n\n\tsev->dev = dev;\n\tsev->psp = psp;\n\n\tsev->io_regs = psp->io_regs;\n\n\tsev->vdata = (struct sev_vdata *)psp->vdata->sev;\n\tif (!sev->vdata) {\n\t\tret = -ENODEV;\n\t\tdev_err(dev, \"sev: missing driver data\\n\");\n\t\tgoto e_buf;\n\t}\n\n\tpsp_set_sev_irq_handler(psp, sev_irq_handler, sev);\n\n\tret = sev_misc_init(sev);\n\tif (ret)\n\t\tgoto e_irq;\n\n\tdev_notice(dev, \"sev enabled\\n\");\n\n\treturn 0;\n\ne_irq:\n\tpsp_clear_sev_irq_handler(psp);\ne_buf:\n\tdevm_free_pages(dev, (unsigned long)sev->cmd_buf);\ne_sev:\n\tdevm_kfree(dev, sev);\ne_err:\n\tpsp->sev_data = NULL;\n\n\tdev_notice(dev, \"sev initialization failed\\n\");\n\n\treturn ret;\n}\n\nstatic void sev_firmware_shutdown(struct sev_device *sev)\n{\n\tsev_platform_shutdown(NULL);\n\n\tif (sev_es_tmr) {\n\t\t \n\t\twbinvd_on_all_cpus();\n\n\t\tfree_pages((unsigned long)sev_es_tmr,\n\t\t\t   get_order(SEV_ES_TMR_SIZE));\n\t\tsev_es_tmr = NULL;\n\t}\n\n\tif (sev_init_ex_buffer) {\n\t\tfree_pages((unsigned long)sev_init_ex_buffer,\n\t\t\t   get_order(NV_LENGTH));\n\t\tsev_init_ex_buffer = NULL;\n\t}\n}\n\nvoid sev_dev_destroy(struct psp_device *psp)\n{\n\tstruct sev_device *sev = psp->sev_data;\n\n\tif (!sev)\n\t\treturn;\n\n\tsev_firmware_shutdown(sev);\n\n\tif (sev->misc)\n\t\tkref_put(&misc_dev->refcount, sev_exit);\n\n\tpsp_clear_sev_irq_handler(psp);\n}\n\nint sev_issue_cmd_external_user(struct file *filep, unsigned int cmd,\n\t\t\t\tvoid *data, int *error)\n{\n\tif (!filep || filep->f_op != &sev_fops)\n\t\treturn -EBADF;\n\n\treturn sev_do_cmd(cmd, data, error);\n}\nEXPORT_SYMBOL_GPL(sev_issue_cmd_external_user);\n\nvoid sev_pci_init(void)\n{\n\tstruct sev_device *sev = psp_master->sev_data;\n\tint error, rc;\n\n\tif (!sev)\n\t\treturn;\n\n\tpsp_timeout = psp_probe_timeout;\n\n\tif (sev_get_api_version())\n\t\tgoto err;\n\n\tif (sev_update_firmware(sev->dev) == 0)\n\t\tsev_get_api_version();\n\n\t \n\tif (init_ex_path) {\n\t\tsev_init_ex_buffer = sev_fw_alloc(NV_LENGTH);\n\t\tif (!sev_init_ex_buffer) {\n\t\t\tdev_err(sev->dev,\n\t\t\t\t\"SEV: INIT_EX NV memory allocation failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tsev_es_tmr = sev_fw_alloc(SEV_ES_TMR_SIZE);\n\tif (sev_es_tmr)\n\t\t \n\t\tclflush_cache_range(sev_es_tmr, SEV_ES_TMR_SIZE);\n\telse\n\t\tdev_warn(sev->dev,\n\t\t\t \"SEV: TMR allocation failed, SEV-ES support unavailable\\n\");\n\n\tif (!psp_init_on_probe)\n\t\treturn;\n\n\t \n\trc = sev_platform_init(&error);\n\tif (rc)\n\t\tdev_err(sev->dev, \"SEV: failed to INIT error %#x, rc %d\\n\",\n\t\t\terror, rc);\n\n\treturn;\n\nerr:\n\tpsp_master->sev_data = NULL;\n}\n\nvoid sev_pci_exit(void)\n{\n\tstruct sev_device *sev = psp_master->sev_data;\n\n\tif (!sev)\n\t\treturn;\n\n\tsev_firmware_shutdown(sev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}