{
  "module_name": "ccp-crypto-aes-galois.c",
  "hash_id": "225405dfb1140d926b85c95cd35df6115fbeca30bed8cb7cf73824a60a37f7d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/ccp-crypto-aes-galois.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <crypto/internal/aead.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <crypto/ctr.h>\n#include <crypto/gcm.h>\n#include <crypto/scatterwalk.h>\n\n#include \"ccp-crypto.h\"\n\nstatic int ccp_aes_gcm_complete(struct crypto_async_request *async_req, int ret)\n{\n\treturn ret;\n}\n\nstatic int ccp_aes_gcm_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t      unsigned int key_len)\n{\n\tstruct ccp_ctx *ctx = crypto_aead_ctx_dma(tfm);\n\n\tswitch (key_len) {\n\tcase AES_KEYSIZE_128:\n\t\tctx->u.aes.type = CCP_AES_TYPE_128;\n\t\tbreak;\n\tcase AES_KEYSIZE_192:\n\t\tctx->u.aes.type = CCP_AES_TYPE_192;\n\t\tbreak;\n\tcase AES_KEYSIZE_256:\n\t\tctx->u.aes.type = CCP_AES_TYPE_256;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tctx->u.aes.mode = CCP_AES_MODE_GCM;\n\tctx->u.aes.key_len = key_len;\n\n\tmemcpy(ctx->u.aes.key, key, key_len);\n\tsg_init_one(&ctx->u.aes.key_sg, ctx->u.aes.key, key_len);\n\n\treturn 0;\n}\n\nstatic int ccp_aes_gcm_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t   unsigned int authsize)\n{\n\tswitch (authsize) {\n\tcase 16:\n\tcase 15:\n\tcase 14:\n\tcase 13:\n\tcase 12:\n\tcase 8:\n\tcase 4:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccp_aes_gcm_crypt(struct aead_request *req, bool encrypt)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct ccp_ctx *ctx = crypto_aead_ctx_dma(tfm);\n\tstruct ccp_aes_req_ctx *rctx = aead_request_ctx_dma(req);\n\tstruct scatterlist *iv_sg = NULL;\n\tunsigned int iv_len = 0;\n\tint i;\n\tint ret = 0;\n\n\tif (!ctx->u.aes.key_len)\n\t\treturn -EINVAL;\n\n\tif (ctx->u.aes.mode != CCP_AES_MODE_GCM)\n\t\treturn -EINVAL;\n\n\tif (!req->iv)\n\t\treturn -EINVAL;\n\n\t \n\n\t \n\tmemcpy(rctx->iv, req->iv, GCM_AES_IV_SIZE);\n\tfor (i = 0; i < 3; i++)\n\t\trctx->iv[i + GCM_AES_IV_SIZE] = 0;\n\trctx->iv[AES_BLOCK_SIZE - 1] = 1;\n\n\t \n\tiv_sg = &rctx->iv_sg;\n\tiv_len = AES_BLOCK_SIZE;\n\tsg_init_one(iv_sg, rctx->iv, iv_len);\n\n\t \n\tmemset(&rctx->cmd, 0, sizeof(rctx->cmd));\n\tINIT_LIST_HEAD(&rctx->cmd.entry);\n\trctx->cmd.engine = CCP_ENGINE_AES;\n\trctx->cmd.u.aes.authsize = crypto_aead_authsize(tfm);\n\trctx->cmd.u.aes.type = ctx->u.aes.type;\n\trctx->cmd.u.aes.mode = ctx->u.aes.mode;\n\trctx->cmd.u.aes.action = encrypt;\n\trctx->cmd.u.aes.key = &ctx->u.aes.key_sg;\n\trctx->cmd.u.aes.key_len = ctx->u.aes.key_len;\n\trctx->cmd.u.aes.iv = iv_sg;\n\trctx->cmd.u.aes.iv_len = iv_len;\n\trctx->cmd.u.aes.src = req->src;\n\trctx->cmd.u.aes.src_len = req->cryptlen;\n\trctx->cmd.u.aes.aad_len = req->assoclen;\n\n\t \n\trctx->cmd.u.aes.dst = req->dst;\n\n\tret = ccp_crypto_enqueue_request(&req->base, &rctx->cmd);\n\n\treturn ret;\n}\n\nstatic int ccp_aes_gcm_encrypt(struct aead_request *req)\n{\n\treturn ccp_aes_gcm_crypt(req, CCP_AES_ACTION_ENCRYPT);\n}\n\nstatic int ccp_aes_gcm_decrypt(struct aead_request *req)\n{\n\treturn ccp_aes_gcm_crypt(req, CCP_AES_ACTION_DECRYPT);\n}\n\nstatic int ccp_aes_gcm_cra_init(struct crypto_aead *tfm)\n{\n\tstruct ccp_ctx *ctx = crypto_aead_ctx_dma(tfm);\n\n\tctx->complete = ccp_aes_gcm_complete;\n\tctx->u.aes.key_len = 0;\n\n\tcrypto_aead_set_reqsize_dma(tfm, sizeof(struct ccp_aes_req_ctx));\n\n\treturn 0;\n}\n\nstatic void ccp_aes_gcm_cra_exit(struct crypto_tfm *tfm)\n{\n}\n\nstatic struct aead_alg ccp_aes_gcm_defaults = {\n\t.setkey = ccp_aes_gcm_setkey,\n\t.setauthsize = ccp_aes_gcm_setauthsize,\n\t.encrypt = ccp_aes_gcm_encrypt,\n\t.decrypt = ccp_aes_gcm_decrypt,\n\t.init = ccp_aes_gcm_cra_init,\n\t.ivsize = GCM_AES_IV_SIZE,\n\t.maxauthsize = AES_BLOCK_SIZE,\n\t.base = {\n\t\t.cra_flags\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t.cra_blocksize\t= AES_BLOCK_SIZE,\n\t\t.cra_ctxsize\t= sizeof(struct ccp_ctx) + CRYPTO_DMA_PADDING,\n\t\t.cra_priority\t= CCP_CRA_PRIORITY,\n\t\t.cra_exit\t= ccp_aes_gcm_cra_exit,\n\t\t.cra_module\t= THIS_MODULE,\n\t},\n};\n\nstruct ccp_aes_aead_def {\n\tenum ccp_aes_mode mode;\n\tunsigned int version;\n\tconst char *name;\n\tconst char *driver_name;\n\tunsigned int blocksize;\n\tunsigned int ivsize;\n\tstruct aead_alg *alg_defaults;\n};\n\nstatic struct ccp_aes_aead_def aes_aead_algs[] = {\n\t{\n\t\t.mode\t\t= CCP_AES_MODE_GHASH,\n\t\t.version\t= CCP_VERSION(5, 0),\n\t\t.name\t\t= \"gcm(aes)\",\n\t\t.driver_name\t= \"gcm-aes-ccp\",\n\t\t.blocksize\t= 1,\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.alg_defaults\t= &ccp_aes_gcm_defaults,\n\t},\n};\n\nstatic int ccp_register_aes_aead(struct list_head *head,\n\t\t\t\t const struct ccp_aes_aead_def *def)\n{\n\tstruct ccp_crypto_aead *ccp_aead;\n\tstruct aead_alg *alg;\n\tint ret;\n\n\tccp_aead = kzalloc(sizeof(*ccp_aead), GFP_KERNEL);\n\tif (!ccp_aead)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ccp_aead->entry);\n\n\tccp_aead->mode = def->mode;\n\n\t \n\talg = &ccp_aead->alg;\n\t*alg = *def->alg_defaults;\n\tsnprintf(alg->base.cra_name, CRYPTO_MAX_ALG_NAME, \"%s\", def->name);\n\tsnprintf(alg->base.cra_driver_name, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t def->driver_name);\n\talg->base.cra_blocksize = def->blocksize;\n\n\tret = crypto_register_aead(alg);\n\tif (ret) {\n\t\tpr_err(\"%s aead algorithm registration error (%d)\\n\",\n\t\t       alg->base.cra_name, ret);\n\t\tkfree(ccp_aead);\n\t\treturn ret;\n\t}\n\n\tlist_add(&ccp_aead->entry, head);\n\n\treturn 0;\n}\n\nint ccp_register_aes_aeads(struct list_head *head)\n{\n\tint i, ret;\n\tunsigned int ccpversion = ccp_version();\n\n\tfor (i = 0; i < ARRAY_SIZE(aes_aead_algs); i++) {\n\t\tif (aes_aead_algs[i].version > ccpversion)\n\t\t\tcontinue;\n\t\tret = ccp_register_aes_aead(head, &aes_aead_algs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}