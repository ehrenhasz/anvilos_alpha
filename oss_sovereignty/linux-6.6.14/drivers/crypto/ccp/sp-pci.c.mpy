{
  "module_name": "sp-pci.c",
  "hash_id": "ead06e1e75cc10ba200428b0a2b8fcb7c6488052ecaaff0492858abc33acd514",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/sp-pci.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/dma-mapping.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/ccp.h>\n\n#include \"ccp-dev.h\"\n#include \"psp-dev.h\"\n\n \n#define AA\t\t\t\tGENMASK(31, 24)\n#define BB\t\t\t\tGENMASK(23, 16)\n#define CC\t\t\t\tGENMASK(15, 8)\n#define DD\t\t\t\tGENMASK(7, 0)\n\n#define MSIX_VECTORS\t\t\t2\n\nstruct sp_pci {\n\tint msix_count;\n\tstruct msix_entry msix_entry[MSIX_VECTORS];\n};\nstatic struct sp_device *sp_dev_master;\n\n#define security_attribute_show(name, def)\t\t\t\t\t\\\nstatic ssize_t name##_show(struct device *d, struct device_attribute *attr,\t\\\n\t\t\t   char *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct sp_device *sp = dev_get_drvdata(d);\t\t\t\t\\\n\tstruct psp_device *psp = sp->psp_data;\t\t\t\t\t\\\n\tint bit = PSP_SECURITY_##def << PSP_CAPABILITY_PSP_SECURITY_OFFSET;\t\\\n\treturn sysfs_emit(buf, \"%d\\n\", (psp->capability & bit) > 0);\t\t\\\n}\n\nsecurity_attribute_show(fused_part, FUSED_PART)\nstatic DEVICE_ATTR_RO(fused_part);\nsecurity_attribute_show(debug_lock_on, DEBUG_LOCK_ON)\nstatic DEVICE_ATTR_RO(debug_lock_on);\nsecurity_attribute_show(tsme_status, TSME_STATUS)\nstatic DEVICE_ATTR_RO(tsme_status);\nsecurity_attribute_show(anti_rollback_status, ANTI_ROLLBACK_STATUS)\nstatic DEVICE_ATTR_RO(anti_rollback_status);\nsecurity_attribute_show(rpmc_production_enabled, RPMC_PRODUCTION_ENABLED)\nstatic DEVICE_ATTR_RO(rpmc_production_enabled);\nsecurity_attribute_show(rpmc_spirom_available, RPMC_SPIROM_AVAILABLE)\nstatic DEVICE_ATTR_RO(rpmc_spirom_available);\nsecurity_attribute_show(hsp_tpm_available, HSP_TPM_AVAILABLE)\nstatic DEVICE_ATTR_RO(hsp_tpm_available);\nsecurity_attribute_show(rom_armor_enforced, ROM_ARMOR_ENFORCED)\nstatic DEVICE_ATTR_RO(rom_armor_enforced);\n\nstatic struct attribute *psp_security_attrs[] = {\n\t&dev_attr_fused_part.attr,\n\t&dev_attr_debug_lock_on.attr,\n\t&dev_attr_tsme_status.attr,\n\t&dev_attr_anti_rollback_status.attr,\n\t&dev_attr_rpmc_production_enabled.attr,\n\t&dev_attr_rpmc_spirom_available.attr,\n\t&dev_attr_hsp_tpm_available.attr,\n\t&dev_attr_rom_armor_enforced.attr,\n\tNULL\n};\n\nstatic umode_t psp_security_is_visible(struct kobject *kobj, struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct sp_device *sp = dev_get_drvdata(dev);\n\tstruct psp_device *psp = sp->psp_data;\n\n\tif (psp && (psp->capability & PSP_CAPABILITY_PSP_SECURITY_REPORTING))\n\t\treturn 0444;\n\n\treturn 0;\n}\n\nstatic struct attribute_group psp_security_attr_group = {\n\t.attrs = psp_security_attrs,\n\t.is_visible = psp_security_is_visible,\n};\n\n#define version_attribute_show(name, _offset)\t\t\t\t\t\\\nstatic ssize_t name##_show(struct device *d, struct device_attribute *attr,\t\\\n\t\t\t   char *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\tstruct sp_device *sp = dev_get_drvdata(d);\t\t\t\t\\\n\tstruct psp_device *psp = sp->psp_data;\t\t\t\t\t\\\n\tunsigned int val = ioread32(psp->io_regs + _offset);\t\t\t\\\n\treturn sysfs_emit(buf, \"%02lx.%02lx.%02lx.%02lx\\n\",\t\t\t\\\n\t\t\t  FIELD_GET(AA, val),\t\t\t\\\n\t\t\t  FIELD_GET(BB, val),\t\t\t\\\n\t\t\t  FIELD_GET(CC, val),\t\t\t\\\n\t\t\t  FIELD_GET(DD, val));\t\t\t\\\n}\n\nversion_attribute_show(bootloader_version, psp->vdata->bootloader_info_reg)\nstatic DEVICE_ATTR_RO(bootloader_version);\nversion_attribute_show(tee_version, psp->vdata->tee->info_reg)\nstatic DEVICE_ATTR_RO(tee_version);\n\nstatic struct attribute *psp_firmware_attrs[] = {\n\t&dev_attr_bootloader_version.attr,\n\t&dev_attr_tee_version.attr,\n\tNULL,\n};\n\nstatic umode_t psp_firmware_is_visible(struct kobject *kobj, struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct sp_device *sp = dev_get_drvdata(dev);\n\tstruct psp_device *psp = sp->psp_data;\n\tunsigned int val = 0xffffffff;\n\n\tif (!psp)\n\t\treturn 0;\n\n\tif (attr == &dev_attr_bootloader_version.attr &&\n\t    psp->vdata->bootloader_info_reg)\n\t\tval = ioread32(psp->io_regs + psp->vdata->bootloader_info_reg);\n\n\tif (attr == &dev_attr_tee_version.attr &&\n\t    psp->capability & PSP_CAPABILITY_TEE &&\n\t    psp->vdata->tee->info_reg)\n\t\tval = ioread32(psp->io_regs + psp->vdata->tee->info_reg);\n\n\t \n\tif (val != 0xffffffff)\n\t\treturn 0444;\n\n\treturn 0;\n}\n\nstatic struct attribute_group psp_firmware_attr_group = {\n\t.attrs = psp_firmware_attrs,\n\t.is_visible = psp_firmware_is_visible,\n};\n\nstatic const struct attribute_group *psp_groups[] = {\n\t&psp_security_attr_group,\n\t&psp_firmware_attr_group,\n\tNULL,\n};\n\nstatic int sp_get_msix_irqs(struct sp_device *sp)\n{\n\tstruct sp_pci *sp_pci = sp->dev_specific;\n\tstruct device *dev = sp->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint v, ret;\n\n\tfor (v = 0; v < ARRAY_SIZE(sp_pci->msix_entry); v++)\n\t\tsp_pci->msix_entry[v].entry = v;\n\n\tret = pci_enable_msix_range(pdev, sp_pci->msix_entry, 1, v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsp_pci->msix_count = ret;\n\tsp->use_tasklet = true;\n\n\tsp->psp_irq = sp_pci->msix_entry[0].vector;\n\tsp->ccp_irq = (sp_pci->msix_count > 1) ? sp_pci->msix_entry[1].vector\n\t\t\t\t\t       : sp_pci->msix_entry[0].vector;\n\treturn 0;\n}\n\nstatic int sp_get_msi_irq(struct sp_device *sp)\n{\n\tstruct device *dev = sp->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint ret;\n\n\tret = pci_enable_msi(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tsp->ccp_irq = pdev->irq;\n\tsp->psp_irq = pdev->irq;\n\n\treturn 0;\n}\n\nstatic int sp_get_irqs(struct sp_device *sp)\n{\n\tstruct device *dev = sp->dev;\n\tint ret;\n\n\tret = sp_get_msix_irqs(sp);\n\tif (!ret)\n\t\treturn 0;\n\n\t \n\tdev_notice(dev, \"could not enable MSI-X (%d), trying MSI\\n\", ret);\n\tret = sp_get_msi_irq(sp);\n\tif (!ret)\n\t\treturn 0;\n\n\t \n\tdev_notice(dev, \"could not enable MSI (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void sp_free_irqs(struct sp_device *sp)\n{\n\tstruct sp_pci *sp_pci = sp->dev_specific;\n\tstruct device *dev = sp->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tif (sp_pci->msix_count)\n\t\tpci_disable_msix(pdev);\n\telse if (sp->psp_irq)\n\t\tpci_disable_msi(pdev);\n\n\tsp->ccp_irq = 0;\n\tsp->psp_irq = 0;\n}\n\nstatic bool sp_pci_is_master(struct sp_device *sp)\n{\n\tstruct device *dev_cur, *dev_new;\n\tstruct pci_dev *pdev_cur, *pdev_new;\n\n\tdev_new = sp->dev;\n\tdev_cur = sp_dev_master->dev;\n\n\tpdev_new = to_pci_dev(dev_new);\n\tpdev_cur = to_pci_dev(dev_cur);\n\n\tif (pdev_new->bus->number < pdev_cur->bus->number)\n\t\treturn true;\n\n\tif (PCI_SLOT(pdev_new->devfn) < PCI_SLOT(pdev_cur->devfn))\n\t\treturn true;\n\n\tif (PCI_FUNC(pdev_new->devfn) < PCI_FUNC(pdev_cur->devfn))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void psp_set_master(struct sp_device *sp)\n{\n\tif (!sp_dev_master) {\n\t\tsp_dev_master = sp;\n\t\treturn;\n\t}\n\n\tif (sp_pci_is_master(sp))\n\t\tsp_dev_master = sp;\n}\n\nstatic struct sp_device *psp_get_master(void)\n{\n\treturn sp_dev_master;\n}\n\nstatic void psp_clear_master(struct sp_device *sp)\n{\n\tif (sp == sp_dev_master) {\n\t\tsp_dev_master = NULL;\n\t\tdev_dbg(sp->dev, \"Cleared sp_dev_master\\n\");\n\t}\n}\n\nstatic int sp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct sp_device *sp;\n\tstruct sp_pci *sp_pci;\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem * const *iomap_table;\n\tint bar_mask;\n\tint ret;\n\n\tret = -ENOMEM;\n\tsp = sp_alloc_struct(dev);\n\tif (!sp)\n\t\tgoto e_err;\n\n\tsp_pci = devm_kzalloc(dev, sizeof(*sp_pci), GFP_KERNEL);\n\tif (!sp_pci)\n\t\tgoto e_err;\n\n\tsp->dev_specific = sp_pci;\n\tsp->dev_vdata = (struct sp_dev_vdata *)id->driver_data;\n\tif (!sp->dev_vdata) {\n\t\tret = -ENODEV;\n\t\tdev_err(dev, \"missing driver data\\n\");\n\t\tgoto e_err;\n\t}\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"pcim_enable_device failed (%d)\\n\", ret);\n\t\tgoto e_err;\n\t}\n\n\tbar_mask = pci_select_bars(pdev, IORESOURCE_MEM);\n\tret = pcim_iomap_regions(pdev, bar_mask, \"ccp\");\n\tif (ret) {\n\t\tdev_err(dev, \"pcim_iomap_regions failed (%d)\\n\", ret);\n\t\tgoto e_err;\n\t}\n\n\tiomap_table = pcim_iomap_table(pdev);\n\tif (!iomap_table) {\n\t\tdev_err(dev, \"pcim_iomap_table failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto e_err;\n\t}\n\n\tsp->io_map = iomap_table[sp->dev_vdata->bar];\n\tif (!sp->io_map) {\n\t\tdev_err(dev, \"ioremap failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto e_err;\n\t}\n\n\tret = sp_get_irqs(sp);\n\tif (ret)\n\t\tgoto e_err;\n\n\tpci_set_master(pdev);\n\tsp->set_psp_master_device = psp_set_master;\n\tsp->get_psp_master_device = psp_get_master;\n\tsp->clear_psp_master_device = psp_clear_master;\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(48));\n\tif (ret) {\n\t\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"dma_set_mask_and_coherent failed (%d)\\n\",\n\t\t\t\tret);\n\t\t\tgoto free_irqs;\n\t\t}\n\t}\n\n\tdev_set_drvdata(dev, sp);\n\n\tret = sp_init(sp);\n\tif (ret)\n\t\tgoto free_irqs;\n\n\treturn 0;\n\nfree_irqs:\n\tsp_free_irqs(sp);\ne_err:\n\tdev_notice(dev, \"initialization failed\\n\");\n\treturn ret;\n}\n\nstatic void sp_pci_shutdown(struct pci_dev *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sp_device *sp = dev_get_drvdata(dev);\n\n\tif (!sp)\n\t\treturn;\n\n\tsp_destroy(sp);\n}\n\nstatic void sp_pci_remove(struct pci_dev *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sp_device *sp = dev_get_drvdata(dev);\n\n\tif (!sp)\n\t\treturn;\n\n\tsp_destroy(sp);\n\n\tsp_free_irqs(sp);\n}\n\nstatic int __maybe_unused sp_pci_suspend(struct device *dev)\n{\n\tstruct sp_device *sp = dev_get_drvdata(dev);\n\n\treturn sp_suspend(sp);\n}\n\nstatic int __maybe_unused sp_pci_resume(struct device *dev)\n{\n\tstruct sp_device *sp = dev_get_drvdata(dev);\n\n\treturn sp_resume(sp);\n}\n\n#ifdef CONFIG_CRYPTO_DEV_SP_PSP\nstatic const struct sev_vdata sevv1 = {\n\t.cmdresp_reg\t\t= 0x10580,\t \n\t.cmdbuff_addr_lo_reg\t= 0x105e0,\t \n\t.cmdbuff_addr_hi_reg\t= 0x105e4,\t \n};\n\nstatic const struct sev_vdata sevv2 = {\n\t.cmdresp_reg\t\t= 0x10980,\t \n\t.cmdbuff_addr_lo_reg\t= 0x109e0,\t \n\t.cmdbuff_addr_hi_reg\t= 0x109e4,\t \n};\n\nstatic const struct tee_vdata teev1 = {\n\t.cmdresp_reg\t\t= 0x10544,\t \n\t.cmdbuff_addr_lo_reg\t= 0x10548,\t \n\t.cmdbuff_addr_hi_reg\t= 0x1054c,\t \n\t.ring_wptr_reg          = 0x10550,\t \n\t.ring_rptr_reg          = 0x10554,\t \n\t.info_reg\t\t= 0x109e8,\t \n};\n\nstatic const struct tee_vdata teev2 = {\n\t.cmdresp_reg\t\t= 0x10944,\t \n\t.cmdbuff_addr_lo_reg\t= 0x10948,\t \n\t.cmdbuff_addr_hi_reg\t= 0x1094c,\t \n\t.ring_wptr_reg\t\t= 0x10950,\t \n\t.ring_rptr_reg\t\t= 0x10954,\t \n};\n\nstatic const struct platform_access_vdata pa_v1 = {\n\t.cmdresp_reg\t\t= 0x10570,\t \n\t.cmdbuff_addr_lo_reg\t= 0x10574,\t \n\t.cmdbuff_addr_hi_reg\t= 0x10578,\t \n\t.doorbell_button_reg\t= 0x10a24,\t \n\t.doorbell_cmd_reg\t= 0x10a40,\t \n};\n\nstatic const struct platform_access_vdata pa_v2 = {\n\t.doorbell_button_reg\t= 0x10a24,\t \n\t.doorbell_cmd_reg\t= 0x10a40,\t \n};\n\nstatic const struct psp_vdata pspv1 = {\n\t.sev\t\t\t= &sevv1,\n\t.bootloader_info_reg\t= 0x105ec,\t \n\t.feature_reg\t\t= 0x105fc,\t \n\t.inten_reg\t\t= 0x10610,\t \n\t.intsts_reg\t\t= 0x10614,\t \n};\n\nstatic const struct psp_vdata pspv2 = {\n\t.sev\t\t\t= &sevv2,\n\t.bootloader_info_reg\t= 0x109ec,\t \n\t.feature_reg\t\t= 0x109fc,\t \n\t.inten_reg\t\t= 0x10690,\t \n\t.intsts_reg\t\t= 0x10694,\t \n};\n\nstatic const struct psp_vdata pspv3 = {\n\t.tee\t\t\t= &teev1,\n\t.platform_access\t= &pa_v1,\n\t.bootloader_info_reg\t= 0x109ec,\t \n\t.feature_reg\t\t= 0x109fc,\t \n\t.inten_reg\t\t= 0x10690,\t \n\t.intsts_reg\t\t= 0x10694,\t \n\t.platform_features\t= PLATFORM_FEATURE_DBC,\n};\n\nstatic const struct psp_vdata pspv4 = {\n\t.sev\t\t\t= &sevv2,\n\t.tee\t\t\t= &teev1,\n\t.bootloader_info_reg\t= 0x109ec,\t \n\t.feature_reg\t\t= 0x109fc,\t \n\t.inten_reg\t\t= 0x10690,\t \n\t.intsts_reg\t\t= 0x10694,\t \n};\n\nstatic const struct psp_vdata pspv5 = {\n\t.tee\t\t\t= &teev2,\n\t.platform_access\t= &pa_v2,\n\t.feature_reg\t\t= 0x109fc,\t \n\t.inten_reg\t\t= 0x10510,\t \n\t.intsts_reg\t\t= 0x10514,\t \n};\n\nstatic const struct psp_vdata pspv6 = {\n\t.sev                    = &sevv2,\n\t.tee                    = &teev2,\n\t.feature_reg            = 0x109fc,\t \n\t.inten_reg              = 0x10510,\t \n\t.intsts_reg             = 0x10514,\t \n};\n\n#endif\n\nstatic const struct sp_dev_vdata dev_vdata[] = {\n\t{\t \n\t\t.bar = 2,\n#ifdef CONFIG_CRYPTO_DEV_SP_CCP\n\t\t.ccp_vdata = &ccpv3,\n#endif\n\t},\n\t{\t \n\t\t.bar = 2,\n#ifdef CONFIG_CRYPTO_DEV_SP_CCP\n\t\t.ccp_vdata = &ccpv5a,\n#endif\n#ifdef CONFIG_CRYPTO_DEV_SP_PSP\n\t\t.psp_vdata = &pspv1,\n#endif\n\t},\n\t{\t \n\t\t.bar = 2,\n#ifdef CONFIG_CRYPTO_DEV_SP_CCP\n\t\t.ccp_vdata = &ccpv5b,\n#endif\n\t},\n\t{\t \n\t\t.bar = 2,\n#ifdef CONFIG_CRYPTO_DEV_SP_CCP\n\t\t.ccp_vdata = &ccpv5a,\n#endif\n#ifdef CONFIG_CRYPTO_DEV_SP_PSP\n\t\t.psp_vdata = &pspv2,\n#endif\n\t},\n\t{\t \n\t\t.bar = 2,\n#ifdef CONFIG_CRYPTO_DEV_SP_CCP\n\t\t.ccp_vdata = &ccpv5a,\n#endif\n#ifdef CONFIG_CRYPTO_DEV_SP_PSP\n\t\t.psp_vdata = &pspv3,\n#endif\n\t},\n\t{\t \n\t\t.bar = 2,\n#ifdef CONFIG_CRYPTO_DEV_SP_PSP\n\t\t.psp_vdata = &pspv4,\n#endif\n\t},\n\t{\t \n\t\t.bar = 2,\n#ifdef CONFIG_CRYPTO_DEV_SP_PSP\n\t\t.psp_vdata = &pspv3,\n#endif\n\t},\n\t{\t \n\t\t.bar = 2,\n#ifdef CONFIG_CRYPTO_DEV_SP_PSP\n\t\t.psp_vdata = &pspv5,\n#endif\n\t},\n\t{\t \n\t\t.bar = 2,\n#ifdef CONFIG_CRYPTO_DEV_SP_PSP\n\t\t.psp_vdata = &pspv6,\n#endif\n\t},\n};\nstatic const struct pci_device_id sp_pci_table[] = {\n\t{ PCI_VDEVICE(AMD, 0x1537), (kernel_ulong_t)&dev_vdata[0] },\n\t{ PCI_VDEVICE(AMD, 0x1456), (kernel_ulong_t)&dev_vdata[1] },\n\t{ PCI_VDEVICE(AMD, 0x1468), (kernel_ulong_t)&dev_vdata[2] },\n\t{ PCI_VDEVICE(AMD, 0x1486), (kernel_ulong_t)&dev_vdata[3] },\n\t{ PCI_VDEVICE(AMD, 0x15DF), (kernel_ulong_t)&dev_vdata[4] },\n\t{ PCI_VDEVICE(AMD, 0x14CA), (kernel_ulong_t)&dev_vdata[5] },\n\t{ PCI_VDEVICE(AMD, 0x15C7), (kernel_ulong_t)&dev_vdata[6] },\n\t{ PCI_VDEVICE(AMD, 0x1649), (kernel_ulong_t)&dev_vdata[6] },\n\t{ PCI_VDEVICE(AMD, 0x17E0), (kernel_ulong_t)&dev_vdata[7] },\n\t{ PCI_VDEVICE(AMD, 0x156E), (kernel_ulong_t)&dev_vdata[8] },\n\t \n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, sp_pci_table);\n\nstatic SIMPLE_DEV_PM_OPS(sp_pci_pm_ops, sp_pci_suspend, sp_pci_resume);\n\nstatic struct pci_driver sp_pci_driver = {\n\t.name = \"ccp\",\n\t.id_table = sp_pci_table,\n\t.probe = sp_pci_probe,\n\t.remove = sp_pci_remove,\n\t.shutdown = sp_pci_shutdown,\n\t.driver.pm = &sp_pci_pm_ops,\n\t.dev_groups = psp_groups,\n};\n\nint sp_pci_init(void)\n{\n\treturn pci_register_driver(&sp_pci_driver);\n}\n\nvoid sp_pci_exit(void)\n{\n\tpci_unregister_driver(&sp_pci_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}