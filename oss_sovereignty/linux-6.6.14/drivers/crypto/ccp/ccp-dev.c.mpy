{
  "module_name": "ccp-dev.c",
  "hash_id": "971df7bf67b3f9e92af5f2f33191ab41d521f117e664b72df5fc1396cd6035bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccp/ccp-dev.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/spinlock_types.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/hw_random.h>\n#include <linux/cpu.h>\n#include <linux/atomic.h>\n#ifdef CONFIG_X86\n#include <asm/cpu_device_id.h>\n#endif\n#include <linux/ccp.h>\n\n#include \"ccp-dev.h\"\n\n#define MAX_CCPS 32\n\n \nstatic unsigned int nqueues;\nmodule_param(nqueues, uint, 0444);\nMODULE_PARM_DESC(nqueues, \"Number of queues per CCP (minimum 1; default: all available)\");\n\n \nstatic atomic_t dev_count = ATOMIC_INIT(0);\nstatic unsigned int max_devs = MAX_CCPS;\nmodule_param(max_devs, uint, 0444);\nMODULE_PARM_DESC(max_devs, \"Maximum number of CCPs to enable (default: all; 0 disables all CCPs)\");\n\nstruct ccp_tasklet_data {\n\tstruct completion completion;\n\tstruct ccp_cmd *cmd;\n};\n\n \n#define CCP_MAX_ERROR_CODE\t64\nstatic char *ccp_error_codes[] = {\n\t\"\",\n\t\"ILLEGAL_ENGINE\",\n\t\"ILLEGAL_KEY_ID\",\n\t\"ILLEGAL_FUNCTION_TYPE\",\n\t\"ILLEGAL_FUNCTION_MODE\",\n\t\"ILLEGAL_FUNCTION_ENCRYPT\",\n\t\"ILLEGAL_FUNCTION_SIZE\",\n\t\"Zlib_MISSING_INIT_EOM\",\n\t\"ILLEGAL_FUNCTION_RSVD\",\n\t\"ILLEGAL_BUFFER_LENGTH\",\n\t\"VLSB_FAULT\",\n\t\"ILLEGAL_MEM_ADDR\",\n\t\"ILLEGAL_MEM_SEL\",\n\t\"ILLEGAL_CONTEXT_ID\",\n\t\"ILLEGAL_KEY_ADDR\",\n\t\"0xF Reserved\",\n\t\"Zlib_ILLEGAL_MULTI_QUEUE\",\n\t\"Zlib_ILLEGAL_JOBID_CHANGE\",\n\t\"CMD_TIMEOUT\",\n\t\"IDMA0_AXI_SLVERR\",\n\t\"IDMA0_AXI_DECERR\",\n\t\"0x15 Reserved\",\n\t\"IDMA1_AXI_SLAVE_FAULT\",\n\t\"IDMA1_AIXI_DECERR\",\n\t\"0x18 Reserved\",\n\t\"ZLIBVHB_AXI_SLVERR\",\n\t\"ZLIBVHB_AXI_DECERR\",\n\t\"0x1B Reserved\",\n\t\"ZLIB_UNEXPECTED_EOM\",\n\t\"ZLIB_EXTRA_DATA\",\n\t\"ZLIB_BTYPE\",\n\t\"ZLIB_UNDEFINED_SYMBOL\",\n\t\"ZLIB_UNDEFINED_DISTANCE_S\",\n\t\"ZLIB_CODE_LENGTH_SYMBOL\",\n\t\"ZLIB _VHB_ILLEGAL_FETCH\",\n\t\"ZLIB_UNCOMPRESSED_LEN\",\n\t\"ZLIB_LIMIT_REACHED\",\n\t\"ZLIB_CHECKSUM_MISMATCH0\",\n\t\"ODMA0_AXI_SLVERR\",\n\t\"ODMA0_AXI_DECERR\",\n\t\"0x28 Reserved\",\n\t\"ODMA1_AXI_SLVERR\",\n\t\"ODMA1_AXI_DECERR\",\n};\n\nvoid ccp_log_error(struct ccp_device *d, unsigned int e)\n{\n\tif (WARN_ON(e >= CCP_MAX_ERROR_CODE))\n\t\treturn;\n\n\tif (e < ARRAY_SIZE(ccp_error_codes))\n\t\tdev_err(d->dev, \"CCP error %d: %s\\n\", e, ccp_error_codes[e]);\n\telse\n\t\tdev_err(d->dev, \"CCP error %d: Unknown Error\\n\", e);\n}\n\n \nstatic DEFINE_RWLOCK(ccp_unit_lock);\nstatic LIST_HEAD(ccp_units);\n\n \nstatic DEFINE_SPINLOCK(ccp_rr_lock);\nstatic struct ccp_device *ccp_rr;\n\n \nvoid ccp_add_device(struct ccp_device *ccp)\n{\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&ccp_unit_lock, flags);\n\tlist_add_tail(&ccp->entry, &ccp_units);\n\tif (!ccp_rr)\n\t\t \n\t\tccp_rr = ccp;\n\twrite_unlock_irqrestore(&ccp_unit_lock, flags);\n}\n\n \nvoid ccp_del_device(struct ccp_device *ccp)\n{\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&ccp_unit_lock, flags);\n\tif (ccp_rr == ccp) {\n\t\t \n\t\tif (list_is_last(&ccp_rr->entry, &ccp_units))\n\t\t\tccp_rr = list_first_entry(&ccp_units, struct ccp_device,\n\t\t\t\t\t\t  entry);\n\t\telse\n\t\t\tccp_rr = list_next_entry(ccp_rr, entry);\n\t}\n\tlist_del(&ccp->entry);\n\tif (list_empty(&ccp_units))\n\t\tccp_rr = NULL;\n\twrite_unlock_irqrestore(&ccp_unit_lock, flags);\n}\n\n\n\nint ccp_register_rng(struct ccp_device *ccp)\n{\n\tint ret = 0;\n\n\tdev_dbg(ccp->dev, \"Registering RNG...\\n\");\n\t \n\tccp->hwrng.name = ccp->rngname;\n\tccp->hwrng.read = ccp_trng_read;\n\tret = hwrng_register(&ccp->hwrng);\n\tif (ret)\n\t\tdev_err(ccp->dev, \"error registering hwrng (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nvoid ccp_unregister_rng(struct ccp_device *ccp)\n{\n\tif (ccp->hwrng.name)\n\t\thwrng_unregister(&ccp->hwrng);\n}\n\nstatic struct ccp_device *ccp_get_device(void)\n{\n\tunsigned long flags;\n\tstruct ccp_device *dp = NULL;\n\n\t \n\tread_lock_irqsave(&ccp_unit_lock, flags);\n\tif (!list_empty(&ccp_units)) {\n\t\tspin_lock(&ccp_rr_lock);\n\t\tdp = ccp_rr;\n\t\tif (list_is_last(&ccp_rr->entry, &ccp_units))\n\t\t\tccp_rr = list_first_entry(&ccp_units, struct ccp_device,\n\t\t\t\t\t\t  entry);\n\t\telse\n\t\t\tccp_rr = list_next_entry(ccp_rr, entry);\n\t\tspin_unlock(&ccp_rr_lock);\n\t}\n\tread_unlock_irqrestore(&ccp_unit_lock, flags);\n\n\treturn dp;\n}\n\n \nint ccp_present(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tread_lock_irqsave(&ccp_unit_lock, flags);\n\tret = list_empty(&ccp_units);\n\tread_unlock_irqrestore(&ccp_unit_lock, flags);\n\n\treturn ret ? -ENODEV : 0;\n}\nEXPORT_SYMBOL_GPL(ccp_present);\n\n \nunsigned int ccp_version(void)\n{\n\tstruct ccp_device *dp;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tread_lock_irqsave(&ccp_unit_lock, flags);\n\tif (!list_empty(&ccp_units)) {\n\t\tdp = list_first_entry(&ccp_units, struct ccp_device, entry);\n\t\tret = dp->vdata->version;\n\t}\n\tread_unlock_irqrestore(&ccp_unit_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ccp_version);\n\n \nint ccp_enqueue_cmd(struct ccp_cmd *cmd)\n{\n\tstruct ccp_device *ccp;\n\tunsigned long flags;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tccp = cmd->ccp ? cmd->ccp : ccp_get_device();\n\n\tif (!ccp)\n\t\treturn -ENODEV;\n\n\t \n\tif (!cmd->callback)\n\t\treturn -EINVAL;\n\n\tcmd->ccp = ccp;\n\n\tspin_lock_irqsave(&ccp->cmd_lock, flags);\n\n\ti = ccp->cmd_q_count;\n\n\tif (ccp->cmd_count >= MAX_CMD_QLEN) {\n\t\tif (cmd->flags & CCP_CMD_MAY_BACKLOG) {\n\t\t\tret = -EBUSY;\n\t\t\tlist_add_tail(&cmd->entry, &ccp->backlog);\n\t\t} else {\n\t\t\tret = -ENOSPC;\n\t\t}\n\t} else {\n\t\tret = -EINPROGRESS;\n\t\tccp->cmd_count++;\n\t\tlist_add_tail(&cmd->entry, &ccp->cmd);\n\n\t\t \n\t\tif (!ccp->suspending) {\n\t\t\tfor (i = 0; i < ccp->cmd_q_count; i++) {\n\t\t\t\tif (ccp->cmd_q[i].active)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&ccp->cmd_lock, flags);\n\n\t \n\tif (i < ccp->cmd_q_count)\n\t\twake_up_process(ccp->cmd_q[i].kthread);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ccp_enqueue_cmd);\n\nstatic void ccp_do_cmd_backlog(struct work_struct *work)\n{\n\tstruct ccp_cmd *cmd = container_of(work, struct ccp_cmd, work);\n\tstruct ccp_device *ccp = cmd->ccp;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tcmd->callback(cmd->data, -EINPROGRESS);\n\n\tspin_lock_irqsave(&ccp->cmd_lock, flags);\n\n\tccp->cmd_count++;\n\tlist_add_tail(&cmd->entry, &ccp->cmd);\n\n\t \n\tfor (i = 0; i < ccp->cmd_q_count; i++) {\n\t\tif (ccp->cmd_q[i].active)\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&ccp->cmd_lock, flags);\n\n\t \n\tif (i < ccp->cmd_q_count)\n\t\twake_up_process(ccp->cmd_q[i].kthread);\n}\n\nstatic struct ccp_cmd *ccp_dequeue_cmd(struct ccp_cmd_queue *cmd_q)\n{\n\tstruct ccp_device *ccp = cmd_q->ccp;\n\tstruct ccp_cmd *cmd = NULL;\n\tstruct ccp_cmd *backlog = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ccp->cmd_lock, flags);\n\n\tcmd_q->active = 0;\n\n\tif (ccp->suspending) {\n\t\tcmd_q->suspended = 1;\n\n\t\tspin_unlock_irqrestore(&ccp->cmd_lock, flags);\n\t\twake_up_interruptible(&ccp->suspend_queue);\n\n\t\treturn NULL;\n\t}\n\n\tif (ccp->cmd_count) {\n\t\tcmd_q->active = 1;\n\n\t\tcmd = list_first_entry(&ccp->cmd, struct ccp_cmd, entry);\n\t\tlist_del(&cmd->entry);\n\n\t\tccp->cmd_count--;\n\t}\n\n\tif (!list_empty(&ccp->backlog)) {\n\t\tbacklog = list_first_entry(&ccp->backlog, struct ccp_cmd,\n\t\t\t\t\t   entry);\n\t\tlist_del(&backlog->entry);\n\t}\n\n\tspin_unlock_irqrestore(&ccp->cmd_lock, flags);\n\n\tif (backlog) {\n\t\tINIT_WORK(&backlog->work, ccp_do_cmd_backlog);\n\t\tschedule_work(&backlog->work);\n\t}\n\n\treturn cmd;\n}\n\nstatic void ccp_do_cmd_complete(unsigned long data)\n{\n\tstruct ccp_tasklet_data *tdata = (struct ccp_tasklet_data *)data;\n\tstruct ccp_cmd *cmd = tdata->cmd;\n\n\tcmd->callback(cmd->data, cmd->ret);\n\n\tcomplete(&tdata->completion);\n}\n\n \nint ccp_cmd_queue_thread(void *data)\n{\n\tstruct ccp_cmd_queue *cmd_q = (struct ccp_cmd_queue *)data;\n\tstruct ccp_cmd *cmd;\n\tstruct ccp_tasklet_data tdata;\n\tstruct tasklet_struct tasklet;\n\n\ttasklet_init(&tasklet, ccp_do_cmd_complete, (unsigned long)&tdata);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tcmd = ccp_dequeue_cmd(cmd_q);\n\t\tif (!cmd)\n\t\t\tcontinue;\n\n\t\t__set_current_state(TASK_RUNNING);\n\n\t\t \n\t\tcmd->ret = ccp_run_cmd(cmd_q, cmd);\n\n\t\t \n\t\ttdata.cmd = cmd;\n\t\tinit_completion(&tdata.completion);\n\t\ttasklet_schedule(&tasklet);\n\t\twait_for_completion(&tdata.completion);\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}\n\n \nstruct ccp_device *ccp_alloc_struct(struct sp_device *sp)\n{\n\tstruct device *dev = sp->dev;\n\tstruct ccp_device *ccp;\n\n\tccp = devm_kzalloc(dev, sizeof(*ccp), GFP_KERNEL);\n\tif (!ccp)\n\t\treturn NULL;\n\tccp->dev = dev;\n\tccp->sp = sp;\n\tccp->axcache = sp->axcache;\n\n\tINIT_LIST_HEAD(&ccp->cmd);\n\tINIT_LIST_HEAD(&ccp->backlog);\n\n\tspin_lock_init(&ccp->cmd_lock);\n\tmutex_init(&ccp->req_mutex);\n\tmutex_init(&ccp->sb_mutex);\n\tccp->sb_count = KSB_COUNT;\n\tccp->sb_start = 0;\n\n\t \n\tinit_waitqueue_head(&ccp->sb_queue);\n\tinit_waitqueue_head(&ccp->suspend_queue);\n\n\tsnprintf(ccp->name, MAX_CCP_NAME_LEN, \"ccp-%u\", sp->ord);\n\tsnprintf(ccp->rngname, MAX_CCP_NAME_LEN, \"ccp-%u-rng\", sp->ord);\n\n\treturn ccp;\n}\n\nint ccp_trng_read(struct hwrng *rng, void *data, size_t max, bool wait)\n{\n\tstruct ccp_device *ccp = container_of(rng, struct ccp_device, hwrng);\n\tu32 trng_value;\n\tint len = min_t(int, sizeof(trng_value), max);\n\n\t \n\ttrng_value = ioread32(ccp->io_regs + TRNG_OUT_REG);\n\tif (!trng_value) {\n\t\t \n\t\tif (ccp->hwrng_retries++ > TRNG_RETRIES)\n\t\t\treturn -EIO;\n\n\t\treturn 0;\n\t}\n\n\t \n\tccp->hwrng_retries = 0;\n\tmemcpy(data, &trng_value, len);\n\n\treturn len;\n}\n\nbool ccp_queues_suspended(struct ccp_device *ccp)\n{\n\tunsigned int suspended = 0;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&ccp->cmd_lock, flags);\n\n\tfor (i = 0; i < ccp->cmd_q_count; i++)\n\t\tif (ccp->cmd_q[i].suspended)\n\t\t\tsuspended++;\n\n\tspin_unlock_irqrestore(&ccp->cmd_lock, flags);\n\n\treturn ccp->cmd_q_count == suspended;\n}\n\nvoid ccp_dev_suspend(struct sp_device *sp)\n{\n\tstruct ccp_device *ccp = sp->ccp_data;\n\tunsigned long flags;\n\tunsigned int i;\n\n\t \n\tif (!ccp)\n\t\treturn;\n\n\tspin_lock_irqsave(&ccp->cmd_lock, flags);\n\n\tccp->suspending = 1;\n\n\t \n\tfor (i = 0; i < ccp->cmd_q_count; i++)\n\t\twake_up_process(ccp->cmd_q[i].kthread);\n\n\tspin_unlock_irqrestore(&ccp->cmd_lock, flags);\n\n\t \n\twhile (!ccp_queues_suspended(ccp))\n\t\twait_event_interruptible(ccp->suspend_queue,\n\t\t\t\t\t ccp_queues_suspended(ccp));\n}\n\nvoid ccp_dev_resume(struct sp_device *sp)\n{\n\tstruct ccp_device *ccp = sp->ccp_data;\n\tunsigned long flags;\n\tunsigned int i;\n\n\t \n\tif (!ccp)\n\t\treturn;\n\n\tspin_lock_irqsave(&ccp->cmd_lock, flags);\n\n\tccp->suspending = 0;\n\n\t \n\tfor (i = 0; i < ccp->cmd_q_count; i++) {\n\t\tccp->cmd_q[i].suspended = 0;\n\t\twake_up_process(ccp->cmd_q[i].kthread);\n\t}\n\n\tspin_unlock_irqrestore(&ccp->cmd_lock, flags);\n}\n\nint ccp_dev_init(struct sp_device *sp)\n{\n\tstruct device *dev = sp->dev;\n\tstruct ccp_device *ccp;\n\tint ret;\n\n\t \n\tif (atomic_inc_return(&dev_count) > max_devs)\n\t\treturn 0;  \n\n\tret = -ENOMEM;\n\tccp = ccp_alloc_struct(sp);\n\tif (!ccp)\n\t\tgoto e_err;\n\tsp->ccp_data = ccp;\n\n\tif (!nqueues || (nqueues > MAX_HW_QUEUES))\n\t\tccp->max_q_count = MAX_HW_QUEUES;\n\telse\n\t\tccp->max_q_count = nqueues;\n\n\tccp->vdata = (struct ccp_vdata *)sp->dev_vdata->ccp_vdata;\n\tif (!ccp->vdata || !ccp->vdata->version) {\n\t\tret = -ENODEV;\n\t\tdev_err(dev, \"missing driver data\\n\");\n\t\tgoto e_err;\n\t}\n\n\tccp->use_tasklet = sp->use_tasklet;\n\n\tccp->io_regs = sp->io_map + ccp->vdata->offset;\n\tif (ccp->vdata->setup)\n\t\tccp->vdata->setup(ccp);\n\n\tret = ccp->vdata->perform->init(ccp);\n\tif (ret) {\n\t\t \n\t\tif (ret > 0)\n\t\t\tgoto e_quiet;\n\n\t\t \n\t\tgoto e_err;\n\t}\n\n\tdev_notice(dev, \"ccp enabled\\n\");\n\n\treturn 0;\n\ne_err:\n\tdev_notice(dev, \"ccp initialization failed\\n\");\n\ne_quiet:\n\tsp->ccp_data = NULL;\n\n\treturn ret;\n}\n\nvoid ccp_dev_destroy(struct sp_device *sp)\n{\n\tstruct ccp_device *ccp = sp->ccp_data;\n\n\tif (!ccp)\n\t\treturn;\n\n\tccp->vdata->perform->destroy(ccp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}