{
  "module_name": "omap-crypto.c",
  "hash_id": "d54439c914ef9195514c76443e6dbf44e2eea2dc9e58a8cf02bf42a25167e82f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/omap-crypto.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/scatterlist.h>\n#include <crypto/scatterwalk.h>\n\n#include \"omap-crypto.h\"\n\nstatic int omap_crypto_copy_sg_lists(int total, int bs,\n\t\t\t\t     struct scatterlist **sg,\n\t\t\t\t     struct scatterlist *new_sg, u16 flags)\n{\n\tint n = sg_nents(*sg);\n\tstruct scatterlist *tmp;\n\n\tif (!(flags & OMAP_CRYPTO_FORCE_SINGLE_ENTRY)) {\n\t\tnew_sg = kmalloc_array(n, sizeof(*sg), GFP_KERNEL);\n\t\tif (!new_sg)\n\t\t\treturn -ENOMEM;\n\n\t\tsg_init_table(new_sg, n);\n\t}\n\n\ttmp = new_sg;\n\n\twhile (*sg && total) {\n\t\tint len = (*sg)->length;\n\n\t\tif (total < len)\n\t\t\tlen = total;\n\n\t\tif (len > 0) {\n\t\t\ttotal -= len;\n\t\t\tsg_set_page(tmp, sg_page(*sg), len, (*sg)->offset);\n\t\t\tif (total <= 0)\n\t\t\t\tsg_mark_end(tmp);\n\t\t\ttmp = sg_next(tmp);\n\t\t}\n\n\t\t*sg = sg_next(*sg);\n\t}\n\n\t*sg = new_sg;\n\n\treturn 0;\n}\n\nstatic int omap_crypto_copy_sgs(int total, int bs, struct scatterlist **sg,\n\t\t\t\tstruct scatterlist *new_sg, u16 flags)\n{\n\tvoid *buf;\n\tint pages;\n\tint new_len;\n\n\tnew_len = ALIGN(total, bs);\n\tpages = get_order(new_len);\n\n\tbuf = (void *)__get_free_pages(GFP_ATOMIC, pages);\n\tif (!buf) {\n\t\tpr_err(\"%s: Couldn't allocate pages for unaligned cases.\\n\",\n\t\t       __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (flags & OMAP_CRYPTO_COPY_DATA) {\n\t\tscatterwalk_map_and_copy(buf, *sg, 0, total, 0);\n\t\tif (flags & OMAP_CRYPTO_ZERO_BUF)\n\t\t\tmemset(buf + total, 0, new_len - total);\n\t}\n\n\tif (!(flags & OMAP_CRYPTO_FORCE_SINGLE_ENTRY))\n\t\tsg_init_table(new_sg, 1);\n\n\tsg_set_buf(new_sg, buf, new_len);\n\n\t*sg = new_sg;\n\n\treturn 0;\n}\n\nstatic int omap_crypto_check_sg(struct scatterlist *sg, int total, int bs,\n\t\t\t\tu16 flags)\n{\n\tint len = 0;\n\tint num_sg = 0;\n\n\tif (!IS_ALIGNED(total, bs))\n\t\treturn OMAP_CRYPTO_NOT_ALIGNED;\n\n\twhile (sg) {\n\t\tnum_sg++;\n\n\t\tif (!IS_ALIGNED(sg->offset, 4))\n\t\t\treturn OMAP_CRYPTO_NOT_ALIGNED;\n\t\tif (!IS_ALIGNED(sg->length, bs))\n\t\t\treturn OMAP_CRYPTO_NOT_ALIGNED;\n#ifdef CONFIG_ZONE_DMA\n\t\tif (page_zonenum(sg_page(sg)) != ZONE_DMA)\n\t\t\treturn OMAP_CRYPTO_NOT_ALIGNED;\n#endif\n\n\t\tlen += sg->length;\n\t\tsg = sg_next(sg);\n\n\t\tif (len >= total)\n\t\t\tbreak;\n\t}\n\n\tif ((flags & OMAP_CRYPTO_FORCE_SINGLE_ENTRY) && num_sg > 1)\n\t\treturn OMAP_CRYPTO_NOT_ALIGNED;\n\n\tif (len != total)\n\t\treturn OMAP_CRYPTO_BAD_DATA_LENGTH;\n\n\treturn 0;\n}\n\nint omap_crypto_align_sg(struct scatterlist **sg, int total, int bs,\n\t\t\t struct scatterlist *new_sg, u16 flags,\n\t\t\t u8 flags_shift, unsigned long *dd_flags)\n{\n\tint ret;\n\n\t*dd_flags &= ~(OMAP_CRYPTO_COPY_MASK << flags_shift);\n\n\tif (flags & OMAP_CRYPTO_FORCE_COPY)\n\t\tret = OMAP_CRYPTO_NOT_ALIGNED;\n\telse\n\t\tret = omap_crypto_check_sg(*sg, total, bs, flags);\n\n\tif (ret == OMAP_CRYPTO_NOT_ALIGNED) {\n\t\tret = omap_crypto_copy_sgs(total, bs, sg, new_sg, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*dd_flags |= OMAP_CRYPTO_DATA_COPIED << flags_shift;\n\t} else if (ret == OMAP_CRYPTO_BAD_DATA_LENGTH) {\n\t\tret = omap_crypto_copy_sg_lists(total, bs, sg, new_sg, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (!(flags & OMAP_CRYPTO_FORCE_SINGLE_ENTRY))\n\t\t\t*dd_flags |= OMAP_CRYPTO_SG_COPIED << flags_shift;\n\t} else if (flags & OMAP_CRYPTO_FORCE_SINGLE_ENTRY) {\n\t\tsg_set_buf(new_sg, sg_virt(*sg), (*sg)->length);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(omap_crypto_align_sg);\n\nstatic void omap_crypto_copy_data(struct scatterlist *src,\n\t\t\t\t  struct scatterlist *dst,\n\t\t\t\t  int offset, int len)\n{\n\tint amt;\n\tvoid *srcb, *dstb;\n\tint srco = 0, dsto = offset;\n\n\twhile (src && dst && len) {\n\t\tif (srco >= src->length) {\n\t\t\tsrco -= src->length;\n\t\t\tsrc = sg_next(src);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dsto >= dst->length) {\n\t\t\tdsto -= dst->length;\n\t\t\tdst = sg_next(dst);\n\t\t\tcontinue;\n\t\t}\n\n\t\tamt = min(src->length - srco, dst->length - dsto);\n\t\tamt = min(len, amt);\n\n\t\tsrcb = kmap_atomic(sg_page(src)) + srco + src->offset;\n\t\tdstb = kmap_atomic(sg_page(dst)) + dsto + dst->offset;\n\n\t\tmemcpy(dstb, srcb, amt);\n\n\t\tflush_dcache_page(sg_page(dst));\n\n\t\tkunmap_atomic(srcb);\n\t\tkunmap_atomic(dstb);\n\n\t\tsrco += amt;\n\t\tdsto += amt;\n\t\tlen -= amt;\n\t}\n}\n\nvoid omap_crypto_cleanup(struct scatterlist *sg, struct scatterlist *orig,\n\t\t\t int offset, int len, u8 flags_shift,\n\t\t\t unsigned long flags)\n{\n\tvoid *buf;\n\tint pages;\n\n\tflags >>= flags_shift;\n\tflags &= OMAP_CRYPTO_COPY_MASK;\n\n\tif (!flags)\n\t\treturn;\n\n\tbuf = sg_virt(sg);\n\tpages = get_order(len);\n\n\tif (orig && (flags & OMAP_CRYPTO_DATA_COPIED))\n\t\tomap_crypto_copy_data(sg, orig, offset, len);\n\n\tif (flags & OMAP_CRYPTO_DATA_COPIED)\n\t\tfree_pages((unsigned long)buf, pages);\n\telse if (flags & OMAP_CRYPTO_SG_COPIED)\n\t\tkfree(sg);\n}\nEXPORT_SYMBOL_GPL(omap_crypto_cleanup);\n\nMODULE_DESCRIPTION(\"OMAP crypto support library.\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Tero Kristo <t-kristo@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}