{
  "module_name": "aspeed-hace.c",
  "hash_id": "0ce83347e6d35836a20135003e7eb142d968136a2dd60316e931703da09583b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/aspeed/aspeed-hace.c",
  "human_readable_source": "\n \n\n#include \"aspeed-hace.h\"\n#include <crypto/engine.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#ifdef CONFIG_CRYPTO_DEV_ASPEED_DEBUG\n#define HACE_DBG(d, fmt, ...)\t\\\n\tdev_info((d)->dev, \"%s() \" fmt, __func__, ##__VA_ARGS__)\n#else\n#define HACE_DBG(d, fmt, ...)\t\\\n\tdev_dbg((d)->dev, \"%s() \" fmt, __func__, ##__VA_ARGS__)\n#endif\n\n \nstatic irqreturn_t aspeed_hace_irq(int irq, void *dev)\n{\n\tstruct aspeed_hace_dev *hace_dev = (struct aspeed_hace_dev *)dev;\n\tstruct aspeed_engine_crypto *crypto_engine = &hace_dev->crypto_engine;\n\tstruct aspeed_engine_hash *hash_engine = &hace_dev->hash_engine;\n\tu32 sts;\n\n\tsts = ast_hace_read(hace_dev, ASPEED_HACE_STS);\n\tast_hace_write(hace_dev, sts, ASPEED_HACE_STS);\n\n\tHACE_DBG(hace_dev, \"irq status: 0x%x\\n\", sts);\n\n\tif (sts & HACE_HASH_ISR) {\n\t\tif (hash_engine->flags & CRYPTO_FLAGS_BUSY)\n\t\t\ttasklet_schedule(&hash_engine->done_task);\n\t\telse\n\t\t\tdev_warn(hace_dev->dev, \"HASH no active requests.\\n\");\n\t}\n\n\tif (sts & HACE_CRYPTO_ISR) {\n\t\tif (crypto_engine->flags & CRYPTO_FLAGS_BUSY)\n\t\t\ttasklet_schedule(&crypto_engine->done_task);\n\t\telse\n\t\t\tdev_warn(hace_dev->dev, \"CRYPTO no active requests.\\n\");\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void aspeed_hace_crypto_done_task(unsigned long data)\n{\n\tstruct aspeed_hace_dev *hace_dev = (struct aspeed_hace_dev *)data;\n\tstruct aspeed_engine_crypto *crypto_engine = &hace_dev->crypto_engine;\n\n\tcrypto_engine->resume(hace_dev);\n}\n\nstatic void aspeed_hace_hash_done_task(unsigned long data)\n{\n\tstruct aspeed_hace_dev *hace_dev = (struct aspeed_hace_dev *)data;\n\tstruct aspeed_engine_hash *hash_engine = &hace_dev->hash_engine;\n\n\thash_engine->resume(hace_dev);\n}\n\nstatic void aspeed_hace_register(struct aspeed_hace_dev *hace_dev)\n{\n#ifdef CONFIG_CRYPTO_DEV_ASPEED_HACE_HASH\n\taspeed_register_hace_hash_algs(hace_dev);\n#endif\n#ifdef CONFIG_CRYPTO_DEV_ASPEED_HACE_CRYPTO\n\taspeed_register_hace_crypto_algs(hace_dev);\n#endif\n}\n\nstatic void aspeed_hace_unregister(struct aspeed_hace_dev *hace_dev)\n{\n#ifdef CONFIG_CRYPTO_DEV_ASPEED_HACE_HASH\n\taspeed_unregister_hace_hash_algs(hace_dev);\n#endif\n#ifdef CONFIG_CRYPTO_DEV_ASPEED_HACE_CRYPTO\n\taspeed_unregister_hace_crypto_algs(hace_dev);\n#endif\n}\n\nstatic const struct of_device_id aspeed_hace_of_matches[] = {\n\t{ .compatible = \"aspeed,ast2500-hace\", .data = (void *)5, },\n\t{ .compatible = \"aspeed,ast2600-hace\", .data = (void *)6, },\n\t{},\n};\n\nstatic int aspeed_hace_probe(struct platform_device *pdev)\n{\n\tstruct aspeed_engine_crypto *crypto_engine;\n\tconst struct of_device_id *hace_dev_id;\n\tstruct aspeed_engine_hash *hash_engine;\n\tstruct aspeed_hace_dev *hace_dev;\n\tint rc;\n\n\thace_dev = devm_kzalloc(&pdev->dev, sizeof(struct aspeed_hace_dev),\n\t\t\t\tGFP_KERNEL);\n\tif (!hace_dev)\n\t\treturn -ENOMEM;\n\n\thace_dev_id = of_match_device(aspeed_hace_of_matches, &pdev->dev);\n\tif (!hace_dev_id) {\n\t\tdev_err(&pdev->dev, \"Failed to match hace dev id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thace_dev->dev = &pdev->dev;\n\thace_dev->version = (unsigned long)hace_dev_id->data;\n\thash_engine = &hace_dev->hash_engine;\n\tcrypto_engine = &hace_dev->crypto_engine;\n\n\tplatform_set_drvdata(pdev, hace_dev);\n\n\thace_dev->regs = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(hace_dev->regs))\n\t\treturn PTR_ERR(hace_dev->regs);\n\n\t \n\thace_dev->irq = platform_get_irq(pdev, 0);\n\tif (hace_dev->irq < 0)\n\t\treturn -ENXIO;\n\n\trc = devm_request_irq(&pdev->dev, hace_dev->irq, aspeed_hace_irq, 0,\n\t\t\t      dev_name(&pdev->dev), hace_dev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Failed to request interrupt\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\thace_dev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(hace_dev->clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get clk\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trc = clk_prepare_enable(hace_dev->clk);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Failed to enable clock 0x%x\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\thace_dev->crypt_engine_hash = crypto_engine_alloc_init(hace_dev->dev,\n\t\t\t\t\t\t\t       true);\n\tif (!hace_dev->crypt_engine_hash) {\n\t\trc = -ENOMEM;\n\t\tgoto clk_exit;\n\t}\n\n\trc = crypto_engine_start(hace_dev->crypt_engine_hash);\n\tif (rc)\n\t\tgoto err_engine_hash_start;\n\n\ttasklet_init(&hash_engine->done_task, aspeed_hace_hash_done_task,\n\t\t     (unsigned long)hace_dev);\n\n\t \n\thace_dev->crypt_engine_crypto = crypto_engine_alloc_init(hace_dev->dev,\n\t\t\t\t\t\t\t\t true);\n\tif (!hace_dev->crypt_engine_crypto) {\n\t\trc = -ENOMEM;\n\t\tgoto err_engine_hash_start;\n\t}\n\n\trc = crypto_engine_start(hace_dev->crypt_engine_crypto);\n\tif (rc)\n\t\tgoto err_engine_crypto_start;\n\n\ttasklet_init(&crypto_engine->done_task, aspeed_hace_crypto_done_task,\n\t\t     (unsigned long)hace_dev);\n\n\t \n\thash_engine->ahash_src_addr =\n\t\tdmam_alloc_coherent(&pdev->dev,\n\t\t\t\t    ASPEED_HASH_SRC_DMA_BUF_LEN,\n\t\t\t\t    &hash_engine->ahash_src_dma_addr,\n\t\t\t\t    GFP_KERNEL);\n\tif (!hash_engine->ahash_src_addr) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate dma buffer\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_engine_crypto_start;\n\t}\n\n\t \n\tcrypto_engine->cipher_ctx =\n\t\tdmam_alloc_coherent(&pdev->dev,\n\t\t\t\t    PAGE_SIZE,\n\t\t\t\t    &crypto_engine->cipher_ctx_dma,\n\t\t\t\t    GFP_KERNEL);\n\tif (!crypto_engine->cipher_ctx) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate cipher ctx dma\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_engine_crypto_start;\n\t}\n\n\t \n\tcrypto_engine->cipher_addr =\n\t\tdmam_alloc_coherent(&pdev->dev,\n\t\t\t\t    ASPEED_CRYPTO_SRC_DMA_BUF_LEN,\n\t\t\t\t    &crypto_engine->cipher_dma_addr,\n\t\t\t\t    GFP_KERNEL);\n\tif (!crypto_engine->cipher_addr) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate cipher addr dma\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_engine_crypto_start;\n\t}\n\n\t \n\tif (hace_dev->version == AST2600_VERSION) {\n\t\tcrypto_engine->dst_sg_addr =\n\t\t\tdmam_alloc_coherent(&pdev->dev,\n\t\t\t\t\t    ASPEED_CRYPTO_DST_DMA_BUF_LEN,\n\t\t\t\t\t    &crypto_engine->dst_sg_dma_addr,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!crypto_engine->dst_sg_addr) {\n\t\t\tdev_err(&pdev->dev, \"Failed to allocate dst_sg dma\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_engine_crypto_start;\n\t\t}\n\t}\n\n\taspeed_hace_register(hace_dev);\n\n\tdev_info(&pdev->dev, \"Aspeed Crypto Accelerator successfully registered\\n\");\n\n\treturn 0;\n\nerr_engine_crypto_start:\n\tcrypto_engine_exit(hace_dev->crypt_engine_crypto);\nerr_engine_hash_start:\n\tcrypto_engine_exit(hace_dev->crypt_engine_hash);\nclk_exit:\n\tclk_disable_unprepare(hace_dev->clk);\n\n\treturn rc;\n}\n\nstatic int aspeed_hace_remove(struct platform_device *pdev)\n{\n\tstruct aspeed_hace_dev *hace_dev = platform_get_drvdata(pdev);\n\tstruct aspeed_engine_crypto *crypto_engine = &hace_dev->crypto_engine;\n\tstruct aspeed_engine_hash *hash_engine = &hace_dev->hash_engine;\n\n\taspeed_hace_unregister(hace_dev);\n\n\tcrypto_engine_exit(hace_dev->crypt_engine_hash);\n\tcrypto_engine_exit(hace_dev->crypt_engine_crypto);\n\n\ttasklet_kill(&hash_engine->done_task);\n\ttasklet_kill(&crypto_engine->done_task);\n\n\tclk_disable_unprepare(hace_dev->clk);\n\n\treturn 0;\n}\n\nMODULE_DEVICE_TABLE(of, aspeed_hace_of_matches);\n\nstatic struct platform_driver aspeed_hace_driver = {\n\t.probe\t\t= aspeed_hace_probe,\n\t.remove\t\t= aspeed_hace_remove,\n\t.driver         = {\n\t\t.name   = KBUILD_MODNAME,\n\t\t.of_match_table = aspeed_hace_of_matches,\n\t},\n};\n\nmodule_platform_driver(aspeed_hace_driver);\n\nMODULE_AUTHOR(\"Neal Liu <neal_liu@aspeedtech.com>\");\nMODULE_DESCRIPTION(\"Aspeed HACE driver Crypto Accelerator\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}