{
  "module_name": "ghash.c",
  "hash_id": "a22d6d1812650ee967e564befa4a6280a9a6f242dd6fb2e536784c4ef3894bbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/vmx/ghash.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/err.h>\n#include <linux/crypto.h>\n#include <linux/delay.h>\n#include <asm/simd.h>\n#include <asm/switch_to.h>\n#include <crypto/aes.h>\n#include <crypto/ghash.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/simd.h>\n#include <crypto/b128ops.h>\n#include \"aesp8-ppc.h\"\n\nvoid gcm_init_p8(u128 htable[16], const u64 Xi[2]);\nvoid gcm_gmult_p8(u64 Xi[2], const u128 htable[16]);\nvoid gcm_ghash_p8(u64 Xi[2], const u128 htable[16],\n\t\t  const u8 *in, size_t len);\n\nstruct p8_ghash_ctx {\n\t \n\tu128 htable[16];\n\t \n\tbe128 key;\n};\n\nstruct p8_ghash_desc_ctx {\n\tu64 shash[2];\n\tu8 buffer[GHASH_DIGEST_SIZE];\n\tint bytes;\n};\n\nstatic int p8_ghash_init(struct shash_desc *desc)\n{\n\tstruct p8_ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\tdctx->bytes = 0;\n\tmemset(dctx->shash, 0, GHASH_DIGEST_SIZE);\n\treturn 0;\n}\n\nstatic int p8_ghash_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct p8_ghash_ctx *ctx = crypto_tfm_ctx(crypto_shash_tfm(tfm));\n\n\tif (keylen != GHASH_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tpreempt_disable();\n\tpagefault_disable();\n\tenable_kernel_vsx();\n\tgcm_init_p8(ctx->htable, (const u64 *) key);\n\tdisable_kernel_vsx();\n\tpagefault_enable();\n\tpreempt_enable();\n\n\tmemcpy(&ctx->key, key, GHASH_BLOCK_SIZE);\n\n\treturn 0;\n}\n\nstatic inline void __ghash_block(struct p8_ghash_ctx *ctx,\n\t\t\t\t struct p8_ghash_desc_ctx *dctx)\n{\n\tif (crypto_simd_usable()) {\n\t\tpreempt_disable();\n\t\tpagefault_disable();\n\t\tenable_kernel_vsx();\n\t\tgcm_ghash_p8(dctx->shash, ctx->htable,\n\t\t\t\tdctx->buffer, GHASH_DIGEST_SIZE);\n\t\tdisable_kernel_vsx();\n\t\tpagefault_enable();\n\t\tpreempt_enable();\n\t} else {\n\t\tcrypto_xor((u8 *)dctx->shash, dctx->buffer, GHASH_BLOCK_SIZE);\n\t\tgf128mul_lle((be128 *)dctx->shash, &ctx->key);\n\t}\n}\n\nstatic inline void __ghash_blocks(struct p8_ghash_ctx *ctx,\n\t\t\t\t  struct p8_ghash_desc_ctx *dctx,\n\t\t\t\t  const u8 *src, unsigned int srclen)\n{\n\tif (crypto_simd_usable()) {\n\t\tpreempt_disable();\n\t\tpagefault_disable();\n\t\tenable_kernel_vsx();\n\t\tgcm_ghash_p8(dctx->shash, ctx->htable,\n\t\t\t\tsrc, srclen);\n\t\tdisable_kernel_vsx();\n\t\tpagefault_enable();\n\t\tpreempt_enable();\n\t} else {\n\t\twhile (srclen >= GHASH_BLOCK_SIZE) {\n\t\t\tcrypto_xor((u8 *)dctx->shash, src, GHASH_BLOCK_SIZE);\n\t\t\tgf128mul_lle((be128 *)dctx->shash, &ctx->key);\n\t\t\tsrclen -= GHASH_BLOCK_SIZE;\n\t\t\tsrc += GHASH_BLOCK_SIZE;\n\t\t}\n\t}\n}\n\nstatic int p8_ghash_update(struct shash_desc *desc,\n\t\t\t   const u8 *src, unsigned int srclen)\n{\n\tunsigned int len;\n\tstruct p8_ghash_ctx *ctx = crypto_tfm_ctx(crypto_shash_tfm(desc->tfm));\n\tstruct p8_ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\tif (dctx->bytes) {\n\t\tif (dctx->bytes + srclen < GHASH_DIGEST_SIZE) {\n\t\t\tmemcpy(dctx->buffer + dctx->bytes, src,\n\t\t\t\tsrclen);\n\t\t\tdctx->bytes += srclen;\n\t\t\treturn 0;\n\t\t}\n\t\tmemcpy(dctx->buffer + dctx->bytes, src,\n\t\t\tGHASH_DIGEST_SIZE - dctx->bytes);\n\n\t\t__ghash_block(ctx, dctx);\n\n\t\tsrc += GHASH_DIGEST_SIZE - dctx->bytes;\n\t\tsrclen -= GHASH_DIGEST_SIZE - dctx->bytes;\n\t\tdctx->bytes = 0;\n\t}\n\tlen = srclen & ~(GHASH_DIGEST_SIZE - 1);\n\tif (len) {\n\t\t__ghash_blocks(ctx, dctx, src, len);\n\t\tsrc += len;\n\t\tsrclen -= len;\n\t}\n\tif (srclen) {\n\t\tmemcpy(dctx->buffer, src, srclen);\n\t\tdctx->bytes = srclen;\n\t}\n\treturn 0;\n}\n\nstatic int p8_ghash_final(struct shash_desc *desc, u8 *out)\n{\n\tint i;\n\tstruct p8_ghash_ctx *ctx = crypto_tfm_ctx(crypto_shash_tfm(desc->tfm));\n\tstruct p8_ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\tif (dctx->bytes) {\n\t\tfor (i = dctx->bytes; i < GHASH_DIGEST_SIZE; i++)\n\t\t\tdctx->buffer[i] = 0;\n\t\t__ghash_block(ctx, dctx);\n\t\tdctx->bytes = 0;\n\t}\n\tmemcpy(out, dctx->shash, GHASH_DIGEST_SIZE);\n\treturn 0;\n}\n\nstruct shash_alg p8_ghash_alg = {\n\t.digestsize = GHASH_DIGEST_SIZE,\n\t.init = p8_ghash_init,\n\t.update = p8_ghash_update,\n\t.final = p8_ghash_final,\n\t.setkey = p8_ghash_setkey,\n\t.descsize = sizeof(struct p8_ghash_desc_ctx)\n\t\t+ sizeof(struct ghash_desc_ctx),\n\t.base = {\n\t\t .cra_name = \"ghash\",\n\t\t .cra_driver_name = \"p8_ghash\",\n\t\t .cra_priority = 1000,\n\t\t .cra_blocksize = GHASH_BLOCK_SIZE,\n\t\t .cra_ctxsize = sizeof(struct p8_ghash_ctx),\n\t\t .cra_module = THIS_MODULE,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}