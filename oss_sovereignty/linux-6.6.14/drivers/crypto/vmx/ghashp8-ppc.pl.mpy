{
  "module_name": "ghashp8-ppc.pl",
  "hash_id": "72b68a6afe4f356f3fbda58834fe6e2d11df5ab93227f36265c508e9e79ca6c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/vmx/ghashp8-ppc.pl",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n\n# This code is taken from the OpenSSL project but the author (Andy Polyakov)\n# has relicensed it under the GPLv2. Therefore this program is free software;\n# you can redistribute it and/or modify it under the terms of the GNU General\n# Public License version 2 as published by the Free Software Foundation.\n#\n# The original headers, including the original license headers, are\n# included below for completeness.\n\n# ====================================================================\n# Written by Andy Polyakov <appro@openssl.org> for the OpenSSL\n# project. The module is, however, dual licensed under OpenSSL and\n# CRYPTOGAMS licenses depending on where you obtain it. For further\n# details see https://www.openssl.org/~appro/cryptogams/.\n# ====================================================================\n#\n# GHASH for PowerISA v2.07.\n#\n# July 2014\n#\n# Accurate performance measurements are problematic, because it's\n# always virtualized setup with possibly throttled processor.\n# Relative comparison is therefore more informative. This initial\n# version is ~2.1x slower than hardware-assisted AES-128-CTR, ~12x\n# faster than \"4-bit\" integer-only compiler-generated 64-bit code.\n# \"Initial version\" means that there is room for futher improvement.\n\n$flavour=shift;\n$output =shift;\n\nif ($flavour =~ /64/) {\n\t$SIZE_T=8;\n\t$LRSAVE=2*$SIZE_T;\n\t$STU=\"stdu\";\n\t$POP=\"ld\";\n\t$PUSH=\"std\";\n} elsif ($flavour =~ /32/) {\n\t$SIZE_T=4;\n\t$LRSAVE=$SIZE_T;\n\t$STU=\"stwu\";\n\t$POP=\"lwz\";\n\t$PUSH=\"stw\";\n} else { die \"nonsense $flavour\"; }\n\n$0 =~ m/(.*[\\/\\\\])[^\\/\\\\]+$/; $dir=$1;\n( $xlate=\"${dir}ppc-xlate.pl\" and -f $xlate ) or\n( $xlate=\"${dir}../../perlasm/ppc-xlate.pl\" and -f $xlate) or\ndie \"can't locate ppc-xlate.pl\";\n\nopen STDOUT,\"| $^X $xlate $flavour $output\" || die \"can't call $xlate: $!\";\n\nmy ($Xip,$Htbl,$inp,$len)=map(\"r$_\",(3..6));\t# argument block\n\nmy ($Xl,$Xm,$Xh,$IN)=map(\"v$_\",(0..3));\nmy ($zero,$t0,$t1,$t2,$xC2,$H,$Hh,$Hl,$lemask)=map(\"v$_\",(4..12));\nmy $vrsave=\"r12\";\n\n$code=<<___;\n.machine\t\"any\"\n\n.text\n\n.globl\t.gcm_init_p8\n\tlis\t\tr0,0xfff0\n\tli\t\tr8,0x10\n\tmfspr\t\t$vrsave,256\n\tli\t\tr9,0x20\n\tmtspr\t\t256,r0\n\tli\t\tr10,0x30\n\tlvx_u\t\t$H,0,r4\t\t\t# load H\n\tle?xor\t\tr7,r7,r7\n\tle?addi\t\tr7,r7,0x8\t\t# need a vperm start with 08\n\tle?lvsr\t\t5,0,r7\n\tle?vspltisb\t6,0x0f\n\tle?vxor\t\t5,5,6\t\t\t# set a b-endian mask\n\tle?vperm\t$H,$H,$H,5\n\n\tvspltisb\t$xC2,-16\t\t# 0xf0\n\tvspltisb\t$t0,1\t\t\t# one\n\tvaddubm\t\t$xC2,$xC2,$xC2\t\t# 0xe0\n\tvxor\t\t$zero,$zero,$zero\n\tvor\t\t$xC2,$xC2,$t0\t\t# 0xe1\n\tvsldoi\t\t$xC2,$xC2,$zero,15\t# 0xe1...\n\tvsldoi\t\t$t1,$zero,$t0,1\t\t# ...1\n\tvaddubm\t\t$xC2,$xC2,$xC2\t\t# 0xc2...\n\tvspltisb\t$t2,7\n\tvor\t\t$xC2,$xC2,$t1\t\t# 0xc2....01\n\tvspltb\t\t$t1,$H,0\t\t# most significant byte\n\tvsl\t\t$H,$H,$t0\t\t# H<<=1\n\tvsrab\t\t$t1,$t1,$t2\t\t# broadcast carry bit\n\tvand\t\t$t1,$t1,$xC2\n\tvxor\t\t$H,$H,$t1\t\t# twisted H\n\n\tvsldoi\t\t$H,$H,$H,8\t\t# twist even more ...\n\tvsldoi\t\t$xC2,$zero,$xC2,8\t# 0xc2.0\n\tvsldoi\t\t$Hl,$zero,$H,8\t\t# ... and split\n\tvsldoi\t\t$Hh,$H,$zero,8\n\n\tstvx_u\t\t$xC2,0,r3\t\t# save pre-computed table\n\tstvx_u\t\t$Hl,r8,r3\n\tstvx_u\t\t$H, r9,r3\n\tstvx_u\t\t$Hh,r10,r3\n\n\tmtspr\t\t256,$vrsave\n\tblr\n\t.long\t\t0\n\t.byte\t\t0,12,0x14,0,0,0,2,0\n\t.long\t\t0\n.size\t.gcm_init_p8,.-.gcm_init_p8\n\n.globl\t.gcm_gmult_p8\n\tlis\t\tr0,0xfff8\n\tli\t\tr8,0x10\n\tmfspr\t\t$vrsave,256\n\tli\t\tr9,0x20\n\tmtspr\t\t256,r0\n\tli\t\tr10,0x30\n\tlvx_u\t\t$IN,0,$Xip\t\t# load Xi\n\n\tlvx_u\t\t$Hl,r8,$Htbl\t\t# load pre-computed table\n\t le?lvsl\t$lemask,r0,r0\n\tlvx_u\t\t$H, r9,$Htbl\n\t le?vspltisb\t$t0,0x07\n\tlvx_u\t\t$Hh,r10,$Htbl\n\t le?vxor\t$lemask,$lemask,$t0\n\tlvx_u\t\t$xC2,0,$Htbl\n\t le?vperm\t$IN,$IN,$IN,$lemask\n\tvxor\t\t$zero,$zero,$zero\n\n\tvpmsumd\t\t$Xl,$IN,$Hl\t\t# H.lo\u00b7Xi.lo\n\tvpmsumd\t\t$Xm,$IN,$H\t\t# H.hi\u00b7Xi.lo+H.lo\u00b7Xi.hi\n\tvpmsumd\t\t$Xh,$IN,$Hh\t\t# H.hi\u00b7Xi.hi\n\n\tvpmsumd\t\t$t2,$Xl,$xC2\t\t# 1st phase\n\n\tvsldoi\t\t$t0,$Xm,$zero,8\n\tvsldoi\t\t$t1,$zero,$Xm,8\n\tvxor\t\t$Xl,$Xl,$t0\n\tvxor\t\t$Xh,$Xh,$t1\n\n\tvsldoi\t\t$Xl,$Xl,$Xl,8\n\tvxor\t\t$Xl,$Xl,$t2\n\n\tvsldoi\t\t$t1,$Xl,$Xl,8\t\t# 2nd phase\n\tvpmsumd\t\t$Xl,$Xl,$xC2\n\tvxor\t\t$t1,$t1,$Xh\n\tvxor\t\t$Xl,$Xl,$t1\n\n\tle?vperm\t$Xl,$Xl,$Xl,$lemask\n\tstvx_u\t\t$Xl,0,$Xip\t\t# write out Xi\n\n\tmtspr\t\t256,$vrsave\n\tblr\n\t.long\t\t0\n\t.byte\t\t0,12,0x14,0,0,0,2,0\n\t.long\t\t0\n.size\t.gcm_gmult_p8,.-.gcm_gmult_p8\n\n.globl\t.gcm_ghash_p8\n\tlis\t\tr0,0xfff8\n\tli\t\tr8,0x10\n\tmfspr\t\t$vrsave,256\n\tli\t\tr9,0x20\n\tmtspr\t\t256,r0\n\tli\t\tr10,0x30\n\tlvx_u\t\t$Xl,0,$Xip\t\t# load Xi\n\n\tlvx_u\t\t$Hl,r8,$Htbl\t\t# load pre-computed table\n\t le?lvsl\t$lemask,r0,r0\n\tlvx_u\t\t$H, r9,$Htbl\n\t le?vspltisb\t$t0,0x07\n\tlvx_u\t\t$Hh,r10,$Htbl\n\t le?vxor\t$lemask,$lemask,$t0\n\tlvx_u\t\t$xC2,0,$Htbl\n\t le?vperm\t$Xl,$Xl,$Xl,$lemask\n\tvxor\t\t$zero,$zero,$zero\n\n\tlvx_u\t\t$IN,0,$inp\n\taddi\t\t$inp,$inp,16\n\tsubi\t\t$len,$len,16\n\t le?vperm\t$IN,$IN,$IN,$lemask\n\tvxor\t\t$IN,$IN,$Xl\n\tb\t\tLoop\n\n.align\t5\nLoop:\n\t subic\t\t$len,$len,16\n\tvpmsumd\t\t$Xl,$IN,$Hl\t\t# H.lo\u00b7Xi.lo\n\t subfe.\t\tr0,r0,r0\t\t# borrow?-1:0\n\tvpmsumd\t\t$Xm,$IN,$H\t\t# H.hi\u00b7Xi.lo+H.lo\u00b7Xi.hi\n\t and\t\tr0,r0,$len\n\tvpmsumd\t\t$Xh,$IN,$Hh\t\t# H.hi\u00b7Xi.hi\n\t add\t\t$inp,$inp,r0\n\n\tvpmsumd\t\t$t2,$Xl,$xC2\t\t# 1st phase\n\n\tvsldoi\t\t$t0,$Xm,$zero,8\n\tvsldoi\t\t$t1,$zero,$Xm,8\n\tvxor\t\t$Xl,$Xl,$t0\n\tvxor\t\t$Xh,$Xh,$t1\n\n\tvsldoi\t\t$Xl,$Xl,$Xl,8\n\tvxor\t\t$Xl,$Xl,$t2\n\t lvx_u\t\t$IN,0,$inp\n\t addi\t\t$inp,$inp,16\n\n\tvsldoi\t\t$t1,$Xl,$Xl,8\t\t# 2nd phase\n\tvpmsumd\t\t$Xl,$Xl,$xC2\n\t le?vperm\t$IN,$IN,$IN,$lemask\n\tvxor\t\t$t1,$t1,$Xh\n\tvxor\t\t$IN,$IN,$t1\n\tvxor\t\t$IN,$IN,$Xl\n\tbeq\t\tLoop\t\t\t# did $len-=16 borrow?\n\n\tvxor\t\t$Xl,$Xl,$t1\n\tle?vperm\t$Xl,$Xl,$Xl,$lemask\n\tstvx_u\t\t$Xl,0,$Xip\t\t# write out Xi\n\n\tmtspr\t\t256,$vrsave\n\tblr\n\t.long\t\t0\n\t.byte\t\t0,12,0x14,0,0,0,4,0\n\t.long\t\t0\n.size\t.gcm_ghash_p8,.-.gcm_ghash_p8\n\n.asciz  \"GHASH for PowerISA 2.07, CRYPTOGAMS by <appro\\@openssl.org>\"\n.align  2\n___\n\nforeach (split(\"\\n\",$code)) {\n\tif ($flavour =~ /le$/o) {\t# little-endian\n\t    s/le\\?//o\t\tor\n\t    s/be\\?/#be#/o;\n\t} else {\n\t    s/le\\?/#le#/o\tor\n\t    s/be\\?//o;\n\t}\n\tprint $_,\"\\n\";\n}\n\nclose STDOUT; # enforce flush\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}