{
  "module_name": "ppc-xlate.pl",
  "hash_id": "f3a8243ebc120bc03bb7bc6b4b4bfcdf67e84c3f95336342bf751e1a45224381",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/vmx/ppc-xlate.pl",
  "human_readable_source": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n\n# PowerPC assembler distiller by <appro>.\n\nmy $flavour = shift;\nmy $output = shift;\nopen STDOUT,\">$output\" || die \"can't open $output: $!\";\n\nmy %GLOBALS;\nmy $dotinlocallabels=($flavour=~/linux/)?1:0;\nmy $elfv2abi=(($flavour =~ /linux-ppc64le/) or ($flavour =~ /linux-ppc64-elfv2/))?1:0;\nmy $dotfunctions=($elfv2abi=~1)?0:1;\n\n################################################################\n# directives which need special treatment on different platforms\n################################################################\nmy $globl = sub {\n    my $junk = shift;\n    my $name = shift;\n    my $global = \\$GLOBALS{$name};\n    my $ret;\n\n    $name =~ s|^[\\.\\_]||;\n \n    SWITCH: for ($flavour) {\n\t/aix/\t\t&& do { $name = \".$name\";\n\t\t\t\tlast;\n\t\t\t      };\n\t/osx/\t\t&& do { $name = \"_$name\";\n\t\t\t\tlast;\n\t\t\t      };\n\t/linux/\n\t\t\t&& do {\t$ret = \"_GLOBAL($name)\";\n\t\t\t\tlast;\n\t\t\t      };\n    }\n\n    $ret = \".globl\t$name\\nalign 5\\n$name:\" if (!$ret);\n    $$global = $name;\n    $ret;\n};\nmy $text = sub {\n    my $ret = ($flavour =~ /aix/) ? \".csect\\t.text[PR],7\" : \".text\";\n    $ret = \".abiversion\t2\\n\".$ret\tif ($elfv2abi);\n    $ret;\n};\nmy $machine = sub {\n    my $junk = shift;\n    my $arch = shift;\n    if ($flavour =~ /osx/)\n    {\t$arch =~ s/\\\"//g;\n\t$arch = ($flavour=~/64/) ? \"ppc970-64\" : \"ppc970\" if ($arch eq \"any\");\n    }\n    \".machine\t$arch\";\n};\nmy $size = sub {\n    if ($flavour =~ /linux/)\n    {\tshift;\n\tmy $name = shift; $name =~ s|^[\\.\\_]||;\n\tmy $ret  = \".size\t$name,.-\".($dotfunctions?\".\":\"\").$name;\n\t$ret .= \"\\n.size\t.$name,.-.$name\" if ($dotfunctions);\n\t$ret;\n    }\n    else\n    {\t\"\";\t}\n};\nmy $asciz = sub {\n    shift;\n    my $line = join(\",\",@_);\n    if ($line =~ /^\"(.*)\"$/)\n    {\t\".byte\t\" . join(\",\",unpack(\"C*\",$1),0) . \"\\n.align\t2\";\t}\n    else\n    {\t\"\";\t}\n};\nmy $quad = sub {\n    shift;\n    my @ret;\n    my ($hi,$lo);\n    for (@_) {\n\tif (/^0x([0-9a-f]*?)([0-9a-f]{1,8})$/io)\n\t{  $hi=$1?\"0x$1\":\"0\"; $lo=\"0x$2\";  }\n\telsif (/^([0-9]+)$/o)\n\t{  $hi=$1>>32; $lo=$1&0xffffffff;  } # error-prone with 32-bit perl\n\telse\n\t{  $hi=undef; $lo=$_; }\n\n\tif (defined($hi))\n\t{  push(@ret,$flavour=~/le$/o?\".long\\t$lo,$hi\":\".long\\t$hi,$lo\");  }\n\telse\n\t{  push(@ret,\".quad\t$lo\");  }\n    }\n    join(\"\\n\",@ret);\n};\n\n################################################################\n# simplified mnemonics not handled by at least one assembler\n################################################################\nmy $cmplw = sub {\n    my $f = shift;\n    my $cr = 0; $cr = shift if ($#_>1);\n    # Some out-of-date 32-bit GNU assembler just can't handle cmplw...\n    ($flavour =~ /linux.*32/) ?\n\t\"\t.long\t\".sprintf \"0x%x\",31<<26|$cr<<23|$_[0]<<16|$_[1]<<11|64 :\n\t\"\tcmplw\t\".join(',',$cr,@_);\n};\nmy $bdnz = sub {\n    my $f = shift;\n    my $bo = $f=~/[\\+\\-]/ ? 16+9 : 16;\t# optional \"to be taken\" hint\n    \"\tbc\t$bo,0,\".shift;\n} if ($flavour!~/linux/);\nmy $bltlr = sub {\n    my $f = shift;\n    my $bo = $f=~/\\-/ ? 12+2 : 12;\t# optional \"not to be taken\" hint\n    ($flavour =~ /linux/) ?\t\t# GNU as doesn't allow most recent hints\n\t\"\t.long\t\".sprintf \"0x%x\",19<<26|$bo<<21|16<<1 :\n\t\"\tbclr\t$bo,0\";\n};\nmy $bnelr = sub {\n    my $f = shift;\n    my $bo = $f=~/\\-/ ? 4+2 : 4;\t# optional \"not to be taken\" hint\n    ($flavour =~ /linux/) ?\t\t# GNU as doesn't allow most recent hints\n\t\"\t.long\t\".sprintf \"0x%x\",19<<26|$bo<<21|2<<16|16<<1 :\n\t\"\tbclr\t$bo,2\";\n};\nmy $beqlr = sub {\n    my $f = shift;\n    my $bo = $f=~/-/ ? 12+2 : 12;\t# optional \"not to be taken\" hint\n    ($flavour =~ /linux/) ?\t\t# GNU as doesn't allow most recent hints\n\t\"\t.long\t\".sprintf \"0x%X\",19<<26|$bo<<21|2<<16|16<<1 :\n\t\"\tbclr\t$bo,2\";\n};\n# GNU assembler can't handle extrdi rA,rS,16,48, or when sum of last two\n# arguments is 64, with \"operand out of range\" error.\nmy $extrdi = sub {\n    my ($f,$ra,$rs,$n,$b) = @_;\n    $b = ($b+$n)&63; $n = 64-$n;\n    \"\trldicl\t$ra,$rs,$b,$n\";\n};\nmy $vmr = sub {\n    my ($f,$vx,$vy) = @_;\n    \"\tvor\t$vx,$vy,$vy\";\n};\n\n# Some ABIs specify vrsave, special-purpose register #256, as reserved\n# for system use.\nmy $no_vrsave = ($elfv2abi);\nmy $mtspr = sub {\n    my ($f,$idx,$ra) = @_;\n    if ($idx == 256 && $no_vrsave) {\n\t\"\tor\t$ra,$ra,$ra\";\n    } else {\n\t\"\tmtspr\t$idx,$ra\";\n    }\n};\nmy $mfspr = sub {\n    my ($f,$rd,$idx) = @_;\n    if ($idx == 256 && $no_vrsave) {\n\t\"\tli\t$rd,-1\";\n    } else {\n\t\"\tmfspr\t$rd,$idx\";\n    }\n};\n\n# PowerISA 2.06 stuff\nsub vsxmem_op {\n    my ($f, $vrt, $ra, $rb, $op) = @_;\n    \"\t.long\t\".sprintf \"0x%X\",(31<<26)|($vrt<<21)|($ra<<16)|($rb<<11)|($op*2+1);\n}\n# made-up unaligned memory reference AltiVec/VMX instructions\nmy $lvx_u\t= sub {\tvsxmem_op(@_, 844); };\t# lxvd2x\nmy $stvx_u\t= sub {\tvsxmem_op(@_, 972); };\t# stxvd2x\nmy $lvdx_u\t= sub {\tvsxmem_op(@_, 588); };\t# lxsdx\nmy $stvdx_u\t= sub {\tvsxmem_op(@_, 716); };\t# stxsdx\nmy $lvx_4w\t= sub { vsxmem_op(@_, 780); };\t# lxvw4x\nmy $stvx_4w\t= sub { vsxmem_op(@_, 908); };\t# stxvw4x\n\n# PowerISA 2.07 stuff\nsub vcrypto_op {\n    my ($f, $vrt, $vra, $vrb, $op) = @_;\n    \"\t.long\t\".sprintf \"0x%X\",(4<<26)|($vrt<<21)|($vra<<16)|($vrb<<11)|$op;\n}\nmy $vcipher\t= sub { vcrypto_op(@_, 1288); };\nmy $vcipherlast\t= sub { vcrypto_op(@_, 1289); };\nmy $vncipher\t= sub { vcrypto_op(@_, 1352); };\nmy $vncipherlast= sub { vcrypto_op(@_, 1353); };\nmy $vsbox\t= sub { vcrypto_op(@_, 0, 1480); };\nmy $vshasigmad\t= sub { my ($st,$six)=splice(@_,-2); vcrypto_op(@_, $st<<4|$six, 1730); };\nmy $vshasigmaw\t= sub { my ($st,$six)=splice(@_,-2); vcrypto_op(@_, $st<<4|$six, 1666); };\nmy $vpmsumb\t= sub { vcrypto_op(@_, 1032); };\nmy $vpmsumd\t= sub { vcrypto_op(@_, 1224); };\nmy $vpmsubh\t= sub { vcrypto_op(@_, 1096); };\nmy $vpmsumw\t= sub { vcrypto_op(@_, 1160); };\nmy $vaddudm\t= sub { vcrypto_op(@_, 192);  };\nmy $vadduqm\t= sub { vcrypto_op(@_, 256);  };\n\nmy $mtsle\t= sub {\n    my ($f, $arg) = @_;\n    \"\t.long\t\".sprintf \"0x%X\",(31<<26)|($arg<<21)|(147*2);\n};\n\nprint \"#include <asm/ppc_asm.h>\\n\" if $flavour =~ /linux/;\n\nwhile($line=<>) {\n\n    $line =~ s|[#!;].*$||;\t# get rid of asm-style comments...\n    $line =~ s|/\\*.*\\*/||;\t# ... and C-style comments...\n    $line =~ s|^\\s+||;\t\t# ... and skip white spaces in beginning...\n    $line =~ s|\\s+$||;\t\t# ... and at the end\n\n    {\n\t$line =~ s|\\b\\.L(\\w+)|L$1|g;\t# common denominator for Locallabel\n\t$line =~ s|\\bL(\\w+)|\\.L$1|g\tif ($dotinlocallabels);\n    }\n\n    {\n\t$line =~ s|^\\s*(\\.?)(\\w+)([\\.\\+\\-]?)\\s*||;\n\tmy $c = $1; $c = \"\\t\" if ($c eq \"\");\n\tmy $mnemonic = $2;\n\tmy $f = $3;\n\tmy $opcode = eval(\"\\$$mnemonic\");\n\t$line =~ s/\\b(c?[rf]|v|vs)([0-9]+)\\b/$2/g if ($c ne \".\" and $flavour !~ /osx/);\n\tif (ref($opcode) eq 'CODE') { $line = &$opcode($f,split(',',$line)); }\n\telsif ($mnemonic)           { $line = $c.$mnemonic.$f.\"\\t\".$line; }\n    }\n\n    print $line if ($line);\n    print \"\\n\";\n}\n\nclose STDOUT;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}