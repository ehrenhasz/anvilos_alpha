{
  "module_name": "omap-aes.c",
  "hash_id": "9941cbc0e24d48170d8aad5957d16075bc831c8d8deab8ee889d7d4087f3966e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/omap-aes.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%20s: \" fmt, __func__\n#define prn(num) pr_debug(#num \"=%d\\n\", num)\n#define prx(num) pr_debug(#num \"=%x\\n\", num)\n\n#include <crypto/aes.h>\n#include <crypto/gcm.h>\n#include <crypto/internal/aead.h>\n#include <crypto/internal/engine.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/scatterlist.h>\n#include <linux/string.h>\n\n#include \"omap-crypto.h\"\n#include \"omap-aes.h\"\n\n \nstatic LIST_HEAD(dev_list);\nstatic DEFINE_SPINLOCK(list_lock);\n\nstatic int aes_fallback_sz = 200;\n\n#ifdef DEBUG\n#define omap_aes_read(dd, offset)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tint _read_ret;\t\t\t\t\t\t\\\n\t_read_ret = __raw_readl(dd->io_base + offset);\t\t\\\n\tpr_debug(\"omap_aes_read(\" #offset \"=%#x)= %#x\\n\",\t\\\n\t\t offset, _read_ret);\t\t\t\t\\\n\t_read_ret;\t\t\t\t\t\t\\\n})\n#else\ninline u32 omap_aes_read(struct omap_aes_dev *dd, u32 offset)\n{\n\treturn __raw_readl(dd->io_base + offset);\n}\n#endif\n\n#ifdef DEBUG\n#define omap_aes_write(dd, offset, value)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tpr_debug(\"omap_aes_write(\" #offset \"=%#x) value=%#x\\n\",\t\\\n\t\t\t offset, value);\t\t\t\t\\\n\t\t__raw_writel(value, dd->io_base + offset);\t\t\\\n\t} while (0)\n#else\ninline void omap_aes_write(struct omap_aes_dev *dd, u32 offset,\n\t\t\t\t  u32 value)\n{\n\t__raw_writel(value, dd->io_base + offset);\n}\n#endif\n\nstatic inline void omap_aes_write_mask(struct omap_aes_dev *dd, u32 offset,\n\t\t\t\t\tu32 value, u32 mask)\n{\n\tu32 val;\n\n\tval = omap_aes_read(dd, offset);\n\tval &= ~mask;\n\tval |= value;\n\tomap_aes_write(dd, offset, val);\n}\n\nstatic void omap_aes_write_n(struct omap_aes_dev *dd, u32 offset,\n\t\t\t\t\tu32 *value, int count)\n{\n\tfor (; count--; value++, offset += 4)\n\t\tomap_aes_write(dd, offset, *value);\n}\n\nstatic int omap_aes_hw_init(struct omap_aes_dev *dd)\n{\n\tint err;\n\n\tif (!(dd->flags & FLAGS_INIT)) {\n\t\tdd->flags |= FLAGS_INIT;\n\t\tdd->err = 0;\n\t}\n\n\terr = pm_runtime_resume_and_get(dd->dev);\n\tif (err < 0) {\n\t\tdev_err(dd->dev, \"failed to get sync: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid omap_aes_clear_copy_flags(struct omap_aes_dev *dd)\n{\n\tdd->flags &= ~(OMAP_CRYPTO_COPY_MASK << FLAGS_IN_DATA_ST_SHIFT);\n\tdd->flags &= ~(OMAP_CRYPTO_COPY_MASK << FLAGS_OUT_DATA_ST_SHIFT);\n\tdd->flags &= ~(OMAP_CRYPTO_COPY_MASK << FLAGS_ASSOC_DATA_ST_SHIFT);\n}\n\nint omap_aes_write_ctrl(struct omap_aes_dev *dd)\n{\n\tstruct omap_aes_reqctx *rctx;\n\tunsigned int key32;\n\tint i, err;\n\tu32 val;\n\n\terr = omap_aes_hw_init(dd);\n\tif (err)\n\t\treturn err;\n\n\tkey32 = dd->ctx->keylen / sizeof(u32);\n\n\t \n\tif (dd->flags & FLAGS_GCM)\n\t\tfor (i = 0; i < 0x40; i = i + 4)\n\t\t\tomap_aes_write(dd, i, 0x0);\n\n\tfor (i = 0; i < key32; i++) {\n\t\tomap_aes_write(dd, AES_REG_KEY(dd, i),\n\t\t\t       (__force u32)cpu_to_le32(dd->ctx->key[i]));\n\t}\n\n\tif ((dd->flags & (FLAGS_CBC | FLAGS_CTR)) && dd->req->iv)\n\t\tomap_aes_write_n(dd, AES_REG_IV(dd, 0), (void *)dd->req->iv, 4);\n\n\tif ((dd->flags & (FLAGS_GCM)) && dd->aead_req->iv) {\n\t\trctx = aead_request_ctx(dd->aead_req);\n\t\tomap_aes_write_n(dd, AES_REG_IV(dd, 0), (u32 *)rctx->iv, 4);\n\t}\n\n\tval = FLD_VAL(((dd->ctx->keylen >> 3) - 1), 4, 3);\n\tif (dd->flags & FLAGS_CBC)\n\t\tval |= AES_REG_CTRL_CBC;\n\n\tif (dd->flags & (FLAGS_CTR | FLAGS_GCM))\n\t\tval |= AES_REG_CTRL_CTR | AES_REG_CTRL_CTR_WIDTH_128;\n\n\tif (dd->flags & FLAGS_GCM)\n\t\tval |= AES_REG_CTRL_GCM;\n\n\tif (dd->flags & FLAGS_ENCRYPT)\n\t\tval |= AES_REG_CTRL_DIRECTION;\n\n\tomap_aes_write_mask(dd, AES_REG_CTRL(dd), val, AES_REG_CTRL_MASK);\n\n\treturn 0;\n}\n\nstatic void omap_aes_dma_trigger_omap2(struct omap_aes_dev *dd, int length)\n{\n\tu32 mask, val;\n\n\tval = dd->pdata->dma_start;\n\n\tif (dd->dma_lch_out != NULL)\n\t\tval |= dd->pdata->dma_enable_out;\n\tif (dd->dma_lch_in != NULL)\n\t\tval |= dd->pdata->dma_enable_in;\n\n\tmask = dd->pdata->dma_enable_out | dd->pdata->dma_enable_in |\n\t       dd->pdata->dma_start;\n\n\tomap_aes_write_mask(dd, AES_REG_MASK(dd), val, mask);\n\n}\n\nstatic void omap_aes_dma_trigger_omap4(struct omap_aes_dev *dd, int length)\n{\n\tomap_aes_write(dd, AES_REG_LENGTH_N(0), length);\n\tomap_aes_write(dd, AES_REG_LENGTH_N(1), 0);\n\tif (dd->flags & FLAGS_GCM)\n\t\tomap_aes_write(dd, AES_REG_A_LEN, dd->assoc_len);\n\n\tomap_aes_dma_trigger_omap2(dd, length);\n}\n\nstatic void omap_aes_dma_stop(struct omap_aes_dev *dd)\n{\n\tu32 mask;\n\n\tmask = dd->pdata->dma_enable_out | dd->pdata->dma_enable_in |\n\t       dd->pdata->dma_start;\n\n\tomap_aes_write_mask(dd, AES_REG_MASK(dd), 0, mask);\n}\n\nstruct omap_aes_dev *omap_aes_find_dev(struct omap_aes_reqctx *rctx)\n{\n\tstruct omap_aes_dev *dd;\n\n\tspin_lock_bh(&list_lock);\n\tdd = list_first_entry(&dev_list, struct omap_aes_dev, list);\n\tlist_move_tail(&dd->list, &dev_list);\n\trctx->dd = dd;\n\tspin_unlock_bh(&list_lock);\n\n\treturn dd;\n}\n\nstatic void omap_aes_dma_out_callback(void *data)\n{\n\tstruct omap_aes_dev *dd = data;\n\n\t \n\ttasklet_schedule(&dd->done_task);\n}\n\nstatic int omap_aes_dma_init(struct omap_aes_dev *dd)\n{\n\tint err;\n\n\tdd->dma_lch_out = NULL;\n\tdd->dma_lch_in = NULL;\n\n\tdd->dma_lch_in = dma_request_chan(dd->dev, \"rx\");\n\tif (IS_ERR(dd->dma_lch_in)) {\n\t\tdev_err(dd->dev, \"Unable to request in DMA channel\\n\");\n\t\treturn PTR_ERR(dd->dma_lch_in);\n\t}\n\n\tdd->dma_lch_out = dma_request_chan(dd->dev, \"tx\");\n\tif (IS_ERR(dd->dma_lch_out)) {\n\t\tdev_err(dd->dev, \"Unable to request out DMA channel\\n\");\n\t\terr = PTR_ERR(dd->dma_lch_out);\n\t\tgoto err_dma_out;\n\t}\n\n\treturn 0;\n\nerr_dma_out:\n\tdma_release_channel(dd->dma_lch_in);\n\n\treturn err;\n}\n\nstatic void omap_aes_dma_cleanup(struct omap_aes_dev *dd)\n{\n\tif (dd->pio_only)\n\t\treturn;\n\n\tdma_release_channel(dd->dma_lch_out);\n\tdma_release_channel(dd->dma_lch_in);\n}\n\nstatic int omap_aes_crypt_dma(struct omap_aes_dev *dd,\n\t\t\t      struct scatterlist *in_sg,\n\t\t\t      struct scatterlist *out_sg,\n\t\t\t      int in_sg_len, int out_sg_len)\n{\n\tstruct dma_async_tx_descriptor *tx_in, *tx_out = NULL, *cb_desc;\n\tstruct dma_slave_config cfg;\n\tint ret;\n\n\tif (dd->pio_only) {\n\t\tscatterwalk_start(&dd->in_walk, dd->in_sg);\n\t\tif (out_sg_len)\n\t\t\tscatterwalk_start(&dd->out_walk, dd->out_sg);\n\n\t\t \n\t\tomap_aes_write(dd, AES_REG_IRQ_ENABLE(dd), 0x2);\n\t\treturn 0;\n\t}\n\n\tdma_sync_sg_for_device(dd->dev, dd->in_sg, in_sg_len, DMA_TO_DEVICE);\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\n\tcfg.src_addr = dd->phys_base + AES_REG_DATA_N(dd, 0);\n\tcfg.dst_addr = dd->phys_base + AES_REG_DATA_N(dd, 0);\n\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tcfg.src_maxburst = DST_MAXBURST;\n\tcfg.dst_maxburst = DST_MAXBURST;\n\n\t \n\tret = dmaengine_slave_config(dd->dma_lch_in, &cfg);\n\tif (ret) {\n\t\tdev_err(dd->dev, \"can't configure IN dmaengine slave: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\ttx_in = dmaengine_prep_slave_sg(dd->dma_lch_in, in_sg, in_sg_len,\n\t\t\t\t\tDMA_MEM_TO_DEV,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!tx_in) {\n\t\tdev_err(dd->dev, \"IN prep_slave_sg() failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttx_in->callback_param = dd;\n\ttx_in->callback = NULL;\n\n\t \n\tif (out_sg_len) {\n\t\tret = dmaengine_slave_config(dd->dma_lch_out, &cfg);\n\t\tif (ret) {\n\t\t\tdev_err(dd->dev, \"can't configure OUT dmaengine slave: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\ttx_out = dmaengine_prep_slave_sg(dd->dma_lch_out, out_sg,\n\t\t\t\t\t\t out_sg_len,\n\t\t\t\t\t\t DMA_DEV_TO_MEM,\n\t\t\t\t\t\t DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (!tx_out) {\n\t\t\tdev_err(dd->dev, \"OUT prep_slave_sg() failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcb_desc = tx_out;\n\t} else {\n\t\tcb_desc = tx_in;\n\t}\n\n\tif (dd->flags & FLAGS_GCM)\n\t\tcb_desc->callback = omap_aes_gcm_dma_out_callback;\n\telse\n\t\tcb_desc->callback = omap_aes_dma_out_callback;\n\tcb_desc->callback_param = dd;\n\n\n\tdmaengine_submit(tx_in);\n\tif (tx_out)\n\t\tdmaengine_submit(tx_out);\n\n\tdma_async_issue_pending(dd->dma_lch_in);\n\tif (out_sg_len)\n\t\tdma_async_issue_pending(dd->dma_lch_out);\n\n\t \n\tdd->pdata->trigger(dd, dd->total);\n\n\treturn 0;\n}\n\nint omap_aes_crypt_dma_start(struct omap_aes_dev *dd)\n{\n\tint err;\n\n\tpr_debug(\"total: %zu\\n\", dd->total);\n\n\tif (!dd->pio_only) {\n\t\terr = dma_map_sg(dd->dev, dd->in_sg, dd->in_sg_len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tif (!err) {\n\t\t\tdev_err(dd->dev, \"dma_map_sg() error\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (dd->out_sg_len) {\n\t\t\terr = dma_map_sg(dd->dev, dd->out_sg, dd->out_sg_len,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tif (!err) {\n\t\t\t\tdev_err(dd->dev, \"dma_map_sg() error\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\terr = omap_aes_crypt_dma(dd, dd->in_sg, dd->out_sg, dd->in_sg_len,\n\t\t\t\t dd->out_sg_len);\n\tif (err && !dd->pio_only) {\n\t\tdma_unmap_sg(dd->dev, dd->in_sg, dd->in_sg_len, DMA_TO_DEVICE);\n\t\tif (dd->out_sg_len)\n\t\t\tdma_unmap_sg(dd->dev, dd->out_sg, dd->out_sg_len,\n\t\t\t\t     DMA_FROM_DEVICE);\n\t}\n\n\treturn err;\n}\n\nstatic void omap_aes_finish_req(struct omap_aes_dev *dd, int err)\n{\n\tstruct skcipher_request *req = dd->req;\n\n\tpr_debug(\"err: %d\\n\", err);\n\n\tcrypto_finalize_skcipher_request(dd->engine, req, err);\n\n\tpm_runtime_mark_last_busy(dd->dev);\n\tpm_runtime_put_autosuspend(dd->dev);\n}\n\nint omap_aes_crypt_dma_stop(struct omap_aes_dev *dd)\n{\n\tpr_debug(\"total: %zu\\n\", dd->total);\n\n\tomap_aes_dma_stop(dd);\n\n\n\treturn 0;\n}\n\nstatic int omap_aes_handle_queue(struct omap_aes_dev *dd,\n\t\t\t\t struct skcipher_request *req)\n{\n\tif (req)\n\t\treturn crypto_transfer_skcipher_request_to_engine(dd->engine, req);\n\n\treturn 0;\n}\n\nstatic int omap_aes_prepare_req(struct skcipher_request *req,\n\t\t\t\tstruct omap_aes_dev *dd)\n{\n\tstruct omap_aes_ctx *ctx = crypto_skcipher_ctx(\n\t\t\tcrypto_skcipher_reqtfm(req));\n\tstruct omap_aes_reqctx *rctx = skcipher_request_ctx(req);\n\tint ret;\n\tu16 flags;\n\n\t \n\tdd->req = req;\n\tdd->total = req->cryptlen;\n\tdd->total_save = req->cryptlen;\n\tdd->in_sg = req->src;\n\tdd->out_sg = req->dst;\n\tdd->orig_out = req->dst;\n\n\tflags = OMAP_CRYPTO_COPY_DATA;\n\tif (req->src == req->dst)\n\t\tflags |= OMAP_CRYPTO_FORCE_COPY;\n\n\tret = omap_crypto_align_sg(&dd->in_sg, dd->total, AES_BLOCK_SIZE,\n\t\t\t\t   dd->in_sgl, flags,\n\t\t\t\t   FLAGS_IN_DATA_ST_SHIFT, &dd->flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = omap_crypto_align_sg(&dd->out_sg, dd->total, AES_BLOCK_SIZE,\n\t\t\t\t   &dd->out_sgl, 0,\n\t\t\t\t   FLAGS_OUT_DATA_ST_SHIFT, &dd->flags);\n\tif (ret)\n\t\treturn ret;\n\n\tdd->in_sg_len = sg_nents_for_len(dd->in_sg, dd->total);\n\tif (dd->in_sg_len < 0)\n\t\treturn dd->in_sg_len;\n\n\tdd->out_sg_len = sg_nents_for_len(dd->out_sg, dd->total);\n\tif (dd->out_sg_len < 0)\n\t\treturn dd->out_sg_len;\n\n\trctx->mode &= FLAGS_MODE_MASK;\n\tdd->flags = (dd->flags & ~FLAGS_MODE_MASK) | rctx->mode;\n\n\tdd->ctx = ctx;\n\trctx->dd = dd;\n\n\treturn omap_aes_write_ctrl(dd);\n}\n\nstatic int omap_aes_crypt_req(struct crypto_engine *engine,\n\t\t\t      void *areq)\n{\n\tstruct skcipher_request *req = container_of(areq, struct skcipher_request, base);\n\tstruct omap_aes_reqctx *rctx = skcipher_request_ctx(req);\n\tstruct omap_aes_dev *dd = rctx->dd;\n\n\tif (!dd)\n\t\treturn -ENODEV;\n\n\treturn omap_aes_prepare_req(req, dd) ?:\n\t       omap_aes_crypt_dma_start(dd);\n}\n\nstatic void omap_aes_copy_ivout(struct omap_aes_dev *dd, u8 *ivbuf)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\t((u32 *)ivbuf)[i] = omap_aes_read(dd, AES_REG_IV(dd, i));\n}\n\nstatic void omap_aes_done_task(unsigned long data)\n{\n\tstruct omap_aes_dev *dd = (struct omap_aes_dev *)data;\n\n\tpr_debug(\"enter done_task\\n\");\n\n\tif (!dd->pio_only) {\n\t\tdma_sync_sg_for_device(dd->dev, dd->out_sg, dd->out_sg_len,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\tdma_unmap_sg(dd->dev, dd->in_sg, dd->in_sg_len, DMA_TO_DEVICE);\n\t\tdma_unmap_sg(dd->dev, dd->out_sg, dd->out_sg_len,\n\t\t\t     DMA_FROM_DEVICE);\n\t\tomap_aes_crypt_dma_stop(dd);\n\t}\n\n\tomap_crypto_cleanup(dd->in_sg, NULL, 0, dd->total_save,\n\t\t\t    FLAGS_IN_DATA_ST_SHIFT, dd->flags);\n\n\tomap_crypto_cleanup(dd->out_sg, dd->orig_out, 0, dd->total_save,\n\t\t\t    FLAGS_OUT_DATA_ST_SHIFT, dd->flags);\n\n\t \n\tif (dd->flags & (FLAGS_CBC | FLAGS_CTR))\n\t\tomap_aes_copy_ivout(dd, dd->req->iv);\n\n\tomap_aes_finish_req(dd, 0);\n\n\tpr_debug(\"exit\\n\");\n}\n\nstatic int omap_aes_crypt(struct skcipher_request *req, unsigned long mode)\n{\n\tstruct omap_aes_ctx *ctx = crypto_skcipher_ctx(\n\t\t\tcrypto_skcipher_reqtfm(req));\n\tstruct omap_aes_reqctx *rctx = skcipher_request_ctx(req);\n\tstruct omap_aes_dev *dd;\n\tint ret;\n\n\tif ((req->cryptlen % AES_BLOCK_SIZE) && !(mode & FLAGS_CTR))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"nbytes: %d, enc: %d, cbc: %d\\n\", req->cryptlen,\n\t\t  !!(mode & FLAGS_ENCRYPT),\n\t\t  !!(mode & FLAGS_CBC));\n\n\tif (req->cryptlen < aes_fallback_sz) {\n\t\tskcipher_request_set_tfm(&rctx->fallback_req, ctx->fallback);\n\t\tskcipher_request_set_callback(&rctx->fallback_req,\n\t\t\t\t\t      req->base.flags,\n\t\t\t\t\t      req->base.complete,\n\t\t\t\t\t      req->base.data);\n\t\tskcipher_request_set_crypt(&rctx->fallback_req, req->src,\n\t\t\t\t\t   req->dst, req->cryptlen, req->iv);\n\n\t\tif (mode & FLAGS_ENCRYPT)\n\t\t\tret = crypto_skcipher_encrypt(&rctx->fallback_req);\n\t\telse\n\t\t\tret = crypto_skcipher_decrypt(&rctx->fallback_req);\n\t\treturn ret;\n\t}\n\tdd = omap_aes_find_dev(rctx);\n\tif (!dd)\n\t\treturn -ENODEV;\n\n\trctx->mode = mode;\n\n\treturn omap_aes_handle_queue(dd, req);\n}\n\n \n\nstatic int omap_aes_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct omap_aes_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tint ret;\n\n\tif (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&\n\t\t   keylen != AES_KEYSIZE_256)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"enter, keylen: %d\\n\", keylen);\n\n\tmemcpy(ctx->key, key, keylen);\n\tctx->keylen = keylen;\n\n\tcrypto_skcipher_clear_flags(ctx->fallback, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(ctx->fallback, tfm->base.crt_flags &\n\t\t\t\t\t\t CRYPTO_TFM_REQ_MASK);\n\n\tret = crypto_skcipher_setkey(ctx->fallback, key, keylen);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn 0;\n}\n\nstatic int omap_aes_ecb_encrypt(struct skcipher_request *req)\n{\n\treturn omap_aes_crypt(req, FLAGS_ENCRYPT);\n}\n\nstatic int omap_aes_ecb_decrypt(struct skcipher_request *req)\n{\n\treturn omap_aes_crypt(req, 0);\n}\n\nstatic int omap_aes_cbc_encrypt(struct skcipher_request *req)\n{\n\treturn omap_aes_crypt(req, FLAGS_ENCRYPT | FLAGS_CBC);\n}\n\nstatic int omap_aes_cbc_decrypt(struct skcipher_request *req)\n{\n\treturn omap_aes_crypt(req, FLAGS_CBC);\n}\n\nstatic int omap_aes_ctr_encrypt(struct skcipher_request *req)\n{\n\treturn omap_aes_crypt(req, FLAGS_ENCRYPT | FLAGS_CTR);\n}\n\nstatic int omap_aes_ctr_decrypt(struct skcipher_request *req)\n{\n\treturn omap_aes_crypt(req, FLAGS_CTR);\n}\n\nstatic int omap_aes_init_tfm(struct crypto_skcipher *tfm)\n{\n\tconst char *name = crypto_tfm_alg_name(&tfm->base);\n\tstruct omap_aes_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tstruct crypto_skcipher *blk;\n\n\tblk = crypto_alloc_skcipher(name, 0, CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(blk))\n\t\treturn PTR_ERR(blk);\n\n\tctx->fallback = blk;\n\n\tcrypto_skcipher_set_reqsize(tfm, sizeof(struct omap_aes_reqctx) +\n\t\t\t\t\t crypto_skcipher_reqsize(blk));\n\n\treturn 0;\n}\n\nstatic void omap_aes_exit_tfm(struct crypto_skcipher *tfm)\n{\n\tstruct omap_aes_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\tif (ctx->fallback)\n\t\tcrypto_free_skcipher(ctx->fallback);\n\n\tctx->fallback = NULL;\n}\n\n \n\nstatic struct skcipher_engine_alg algs_ecb_cbc[] = {\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"ecb(aes)\",\n\t\t.base.cra_driver_name\t= \"ecb-aes-omap\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t  CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct omap_aes_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t.setkey\t\t\t= omap_aes_setkey,\n\t\t.encrypt\t\t= omap_aes_ecb_encrypt,\n\t\t.decrypt\t\t= omap_aes_ecb_decrypt,\n\t\t.init\t\t\t= omap_aes_init_tfm,\n\t\t.exit\t\t\t= omap_aes_exit_tfm,\n\t},\n\t.op.do_one_request = omap_aes_crypt_req,\n},\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"cbc(aes)\",\n\t\t.base.cra_driver_name\t= \"cbc-aes-omap\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t  CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct omap_aes_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t\t.setkey\t\t\t= omap_aes_setkey,\n\t\t.encrypt\t\t= omap_aes_cbc_encrypt,\n\t\t.decrypt\t\t= omap_aes_cbc_decrypt,\n\t\t.init\t\t\t= omap_aes_init_tfm,\n\t\t.exit\t\t\t= omap_aes_exit_tfm,\n\t},\n\t.op.do_one_request = omap_aes_crypt_req,\n}\n};\n\nstatic struct skcipher_engine_alg algs_ctr[] = {\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"ctr(aes)\",\n\t\t.base.cra_driver_name\t= \"ctr-aes-omap\",\n\t\t.base.cra_priority\t= 300,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t  CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t.base.cra_blocksize\t= 1,\n\t\t.base.cra_ctxsize\t= sizeof(struct omap_aes_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t\t.setkey\t\t\t= omap_aes_setkey,\n\t\t.encrypt\t\t= omap_aes_ctr_encrypt,\n\t\t.decrypt\t\t= omap_aes_ctr_decrypt,\n\t\t.init\t\t\t= omap_aes_init_tfm,\n\t\t.exit\t\t\t= omap_aes_exit_tfm,\n\t},\n\t.op.do_one_request = omap_aes_crypt_req,\n}\n};\n\nstatic struct omap_aes_algs_info omap_aes_algs_info_ecb_cbc[] = {\n\t{\n\t\t.algs_list\t= algs_ecb_cbc,\n\t\t.size\t\t= ARRAY_SIZE(algs_ecb_cbc),\n\t},\n};\n\nstatic struct aead_engine_alg algs_aead_gcm[] = {\n{\n\t.base = {\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"gcm(aes)\",\n\t\t\t.cra_driver_name\t= \"gcm-aes-omap\",\n\t\t\t.cra_priority\t\t= 300,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize\t\t= 1,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct omap_aes_gcm_ctx),\n\t\t\t.cra_alignmask\t\t= 0xf,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t},\n\t\t.init\t\t= omap_aes_gcm_cra_init,\n\t\t.ivsize\t\t= GCM_AES_IV_SIZE,\n\t\t.maxauthsize\t= AES_BLOCK_SIZE,\n\t\t.setkey\t\t= omap_aes_gcm_setkey,\n\t\t.setauthsize\t= omap_aes_gcm_setauthsize,\n\t\t.encrypt\t= omap_aes_gcm_encrypt,\n\t\t.decrypt\t= omap_aes_gcm_decrypt,\n\t},\n\t.op.do_one_request = omap_aes_gcm_crypt_req,\n},\n{\n\t.base = {\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"rfc4106(gcm(aes))\",\n\t\t\t.cra_driver_name\t= \"rfc4106-gcm-aes-omap\",\n\t\t\t.cra_priority\t\t= 300,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize\t\t= 1,\n\t\t\t.cra_ctxsize\t\t= sizeof(struct omap_aes_gcm_ctx),\n\t\t\t.cra_alignmask\t\t= 0xf,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t},\n\t\t.init\t\t= omap_aes_gcm_cra_init,\n\t\t.maxauthsize\t= AES_BLOCK_SIZE,\n\t\t.ivsize\t\t= GCM_RFC4106_IV_SIZE,\n\t\t.setkey\t\t= omap_aes_4106gcm_setkey,\n\t\t.setauthsize\t= omap_aes_4106gcm_setauthsize,\n\t\t.encrypt\t= omap_aes_4106gcm_encrypt,\n\t\t.decrypt\t= omap_aes_4106gcm_decrypt,\n\t},\n\t.op.do_one_request = omap_aes_gcm_crypt_req,\n},\n};\n\nstatic struct omap_aes_aead_algs omap_aes_aead_info = {\n\t.algs_list\t=\talgs_aead_gcm,\n\t.size\t\t=\tARRAY_SIZE(algs_aead_gcm),\n};\n\nstatic const struct omap_aes_pdata omap_aes_pdata_omap2 = {\n\t.algs_info\t= omap_aes_algs_info_ecb_cbc,\n\t.algs_info_size\t= ARRAY_SIZE(omap_aes_algs_info_ecb_cbc),\n\t.trigger\t= omap_aes_dma_trigger_omap2,\n\t.key_ofs\t= 0x1c,\n\t.iv_ofs\t\t= 0x20,\n\t.ctrl_ofs\t= 0x30,\n\t.data_ofs\t= 0x34,\n\t.rev_ofs\t= 0x44,\n\t.mask_ofs\t= 0x48,\n\t.dma_enable_in\t= BIT(2),\n\t.dma_enable_out\t= BIT(3),\n\t.dma_start\t= BIT(5),\n\t.major_mask\t= 0xf0,\n\t.major_shift\t= 4,\n\t.minor_mask\t= 0x0f,\n\t.minor_shift\t= 0,\n};\n\n#ifdef CONFIG_OF\nstatic struct omap_aes_algs_info omap_aes_algs_info_ecb_cbc_ctr[] = {\n\t{\n\t\t.algs_list\t= algs_ecb_cbc,\n\t\t.size\t\t= ARRAY_SIZE(algs_ecb_cbc),\n\t},\n\t{\n\t\t.algs_list\t= algs_ctr,\n\t\t.size\t\t= ARRAY_SIZE(algs_ctr),\n\t},\n};\n\nstatic const struct omap_aes_pdata omap_aes_pdata_omap3 = {\n\t.algs_info\t= omap_aes_algs_info_ecb_cbc_ctr,\n\t.algs_info_size\t= ARRAY_SIZE(omap_aes_algs_info_ecb_cbc_ctr),\n\t.trigger\t= omap_aes_dma_trigger_omap2,\n\t.key_ofs\t= 0x1c,\n\t.iv_ofs\t\t= 0x20,\n\t.ctrl_ofs\t= 0x30,\n\t.data_ofs\t= 0x34,\n\t.rev_ofs\t= 0x44,\n\t.mask_ofs\t= 0x48,\n\t.dma_enable_in\t= BIT(2),\n\t.dma_enable_out\t= BIT(3),\n\t.dma_start\t= BIT(5),\n\t.major_mask\t= 0xf0,\n\t.major_shift\t= 4,\n\t.minor_mask\t= 0x0f,\n\t.minor_shift\t= 0,\n};\n\nstatic const struct omap_aes_pdata omap_aes_pdata_omap4 = {\n\t.algs_info\t= omap_aes_algs_info_ecb_cbc_ctr,\n\t.algs_info_size\t= ARRAY_SIZE(omap_aes_algs_info_ecb_cbc_ctr),\n\t.aead_algs_info\t= &omap_aes_aead_info,\n\t.trigger\t= omap_aes_dma_trigger_omap4,\n\t.key_ofs\t= 0x3c,\n\t.iv_ofs\t\t= 0x40,\n\t.ctrl_ofs\t= 0x50,\n\t.data_ofs\t= 0x60,\n\t.rev_ofs\t= 0x80,\n\t.mask_ofs\t= 0x84,\n\t.irq_status_ofs = 0x8c,\n\t.irq_enable_ofs = 0x90,\n\t.dma_enable_in\t= BIT(5),\n\t.dma_enable_out\t= BIT(6),\n\t.major_mask\t= 0x0700,\n\t.major_shift\t= 8,\n\t.minor_mask\t= 0x003f,\n\t.minor_shift\t= 0,\n};\n\nstatic irqreturn_t omap_aes_irq(int irq, void *dev_id)\n{\n\tstruct omap_aes_dev *dd = dev_id;\n\tu32 status, i;\n\tu32 *src, *dst;\n\n\tstatus = omap_aes_read(dd, AES_REG_IRQ_STATUS(dd));\n\tif (status & AES_REG_IRQ_DATA_IN) {\n\t\tomap_aes_write(dd, AES_REG_IRQ_ENABLE(dd), 0x0);\n\n\t\tBUG_ON(!dd->in_sg);\n\n\t\tBUG_ON(_calc_walked(in) > dd->in_sg->length);\n\n\t\tsrc = sg_virt(dd->in_sg) + _calc_walked(in);\n\n\t\tfor (i = 0; i < AES_BLOCK_WORDS; i++) {\n\t\t\tomap_aes_write(dd, AES_REG_DATA_N(dd, i), *src);\n\n\t\t\tscatterwalk_advance(&dd->in_walk, 4);\n\t\t\tif (dd->in_sg->length == _calc_walked(in)) {\n\t\t\t\tdd->in_sg = sg_next(dd->in_sg);\n\t\t\t\tif (dd->in_sg) {\n\t\t\t\t\tscatterwalk_start(&dd->in_walk,\n\t\t\t\t\t\t\t  dd->in_sg);\n\t\t\t\t\tsrc = sg_virt(dd->in_sg) +\n\t\t\t\t\t      _calc_walked(in);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsrc++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tstatus &= ~AES_REG_IRQ_DATA_IN;\n\t\tomap_aes_write(dd, AES_REG_IRQ_STATUS(dd), status);\n\n\t\t \n\t\tomap_aes_write(dd, AES_REG_IRQ_ENABLE(dd), 0x4);\n\n\t} else if (status & AES_REG_IRQ_DATA_OUT) {\n\t\tomap_aes_write(dd, AES_REG_IRQ_ENABLE(dd), 0x0);\n\n\t\tBUG_ON(!dd->out_sg);\n\n\t\tBUG_ON(_calc_walked(out) > dd->out_sg->length);\n\n\t\tdst = sg_virt(dd->out_sg) + _calc_walked(out);\n\n\t\tfor (i = 0; i < AES_BLOCK_WORDS; i++) {\n\t\t\t*dst = omap_aes_read(dd, AES_REG_DATA_N(dd, i));\n\t\t\tscatterwalk_advance(&dd->out_walk, 4);\n\t\t\tif (dd->out_sg->length == _calc_walked(out)) {\n\t\t\t\tdd->out_sg = sg_next(dd->out_sg);\n\t\t\t\tif (dd->out_sg) {\n\t\t\t\t\tscatterwalk_start(&dd->out_walk,\n\t\t\t\t\t\t\t  dd->out_sg);\n\t\t\t\t\tdst = sg_virt(dd->out_sg) +\n\t\t\t\t\t      _calc_walked(out);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdst++;\n\t\t\t}\n\t\t}\n\n\t\tdd->total -= min_t(size_t, AES_BLOCK_SIZE, dd->total);\n\n\t\t \n\t\tstatus &= ~AES_REG_IRQ_DATA_OUT;\n\t\tomap_aes_write(dd, AES_REG_IRQ_STATUS(dd), status);\n\n\t\tif (!dd->total)\n\t\t\t \n\t\t\ttasklet_schedule(&dd->done_task);\n\t\telse\n\t\t\t \n\t\t\tomap_aes_write(dd, AES_REG_IRQ_ENABLE(dd), 0x2);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct of_device_id omap_aes_of_match[] = {\n\t{\n\t\t.compatible\t= \"ti,omap2-aes\",\n\t\t.data\t\t= &omap_aes_pdata_omap2,\n\t},\n\t{\n\t\t.compatible\t= \"ti,omap3-aes\",\n\t\t.data\t\t= &omap_aes_pdata_omap3,\n\t},\n\t{\n\t\t.compatible\t= \"ti,omap4-aes\",\n\t\t.data\t\t= &omap_aes_pdata_omap4,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_aes_of_match);\n\nstatic int omap_aes_get_res_of(struct omap_aes_dev *dd,\n\t\tstruct device *dev, struct resource *res)\n{\n\tstruct device_node *node = dev->of_node;\n\tint err = 0;\n\n\tdd->pdata = of_device_get_match_data(dev);\n\tif (!dd->pdata) {\n\t\tdev_err(dev, \"no compatible OF match\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\terr = of_address_to_resource(node, 0, res);\n\tif (err < 0) {\n\t\tdev_err(dev, \"can't translate OF node address\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\nerr:\n\treturn err;\n}\n#else\nstatic const struct of_device_id omap_aes_of_match[] = {\n\t{},\n};\n\nstatic int omap_aes_get_res_of(struct omap_aes_dev *dd,\n\t\tstruct device *dev, struct resource *res)\n{\n\treturn -EINVAL;\n}\n#endif\n\nstatic int omap_aes_get_res_pdev(struct omap_aes_dev *dd,\n\t\tstruct platform_device *pdev, struct resource *res)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *r;\n\tint err = 0;\n\n\t \n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tdev_err(dev, \"no MEM resource info\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err;\n\t}\n\tmemcpy(res, r, sizeof(*res));\n\n\t \n\tdd->pdata = &omap_aes_pdata_omap2;\n\nerr:\n\treturn err;\n}\n\nstatic ssize_t fallback_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", aes_fallback_sz);\n}\n\nstatic ssize_t fallback_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t size)\n{\n\tssize_t status;\n\tlong value;\n\n\tstatus = kstrtol(buf, 0, &value);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (value < 9) {\n\t\tdev_err(dev, \"minimum fallback size 9\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taes_fallback_sz = value;\n\n\treturn size;\n}\n\nstatic ssize_t queue_len_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct omap_aes_dev *dd = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", dd->engine->queue.max_qlen);\n}\n\nstatic ssize_t queue_len_store(struct device *dev,\n\t\t\t       struct device_attribute *attr, const char *buf,\n\t\t\t       size_t size)\n{\n\tstruct omap_aes_dev *dd;\n\tssize_t status;\n\tlong value;\n\tunsigned long flags;\n\n\tstatus = kstrtol(buf, 0, &value);\n\tif (status)\n\t\treturn status;\n\n\tif (value < 1)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock_bh(&list_lock);\n\tlist_for_each_entry(dd, &dev_list, list) {\n\t\tspin_lock_irqsave(&dd->lock, flags);\n\t\tdd->engine->queue.max_qlen = value;\n\t\tdd->aead_queue.base.max_qlen = value;\n\t\tspin_unlock_irqrestore(&dd->lock, flags);\n\t}\n\tspin_unlock_bh(&list_lock);\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(queue_len);\nstatic DEVICE_ATTR_RW(fallback);\n\nstatic struct attribute *omap_aes_attrs[] = {\n\t&dev_attr_queue_len.attr,\n\t&dev_attr_fallback.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group omap_aes_attr_group = {\n\t.attrs = omap_aes_attrs,\n};\n\nstatic int omap_aes_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct omap_aes_dev *dd;\n\tstruct skcipher_engine_alg *algp;\n\tstruct aead_engine_alg *aalg;\n\tstruct resource res;\n\tint err = -ENOMEM, i, j, irq = -1;\n\tu32 reg;\n\n\tdd = devm_kzalloc(dev, sizeof(struct omap_aes_dev), GFP_KERNEL);\n\tif (dd == NULL) {\n\t\tdev_err(dev, \"unable to alloc data struct.\\n\");\n\t\tgoto err_data;\n\t}\n\tdd->dev = dev;\n\tplatform_set_drvdata(pdev, dd);\n\n\taead_init_queue(&dd->aead_queue, OMAP_AES_QUEUE_LENGTH);\n\n\terr = (dev->of_node) ? omap_aes_get_res_of(dd, dev, &res) :\n\t\t\t       omap_aes_get_res_pdev(dd, pdev, &res);\n\tif (err)\n\t\tgoto err_res;\n\n\tdd->io_base = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(dd->io_base)) {\n\t\terr = PTR_ERR(dd->io_base);\n\t\tgoto err_res;\n\t}\n\tdd->phys_base = res.start;\n\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, DEFAULT_AUTOSUSPEND_DELAY);\n\n\tpm_runtime_enable(dev);\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"%s: failed to get_sync(%d)\\n\",\n\t\t\t__func__, err);\n\t\tgoto err_pm_disable;\n\t}\n\n\tomap_aes_dma_stop(dd);\n\n\treg = omap_aes_read(dd, AES_REG_REV(dd));\n\n\tpm_runtime_put_sync(dev);\n\n\tdev_info(dev, \"OMAP AES hw accel rev: %u.%u\\n\",\n\t\t (reg & dd->pdata->major_mask) >> dd->pdata->major_shift,\n\t\t (reg & dd->pdata->minor_mask) >> dd->pdata->minor_shift);\n\n\ttasklet_init(&dd->done_task, omap_aes_done_task, (unsigned long)dd);\n\n\terr = omap_aes_dma_init(dd);\n\tif (err == -EPROBE_DEFER) {\n\t\tgoto err_irq;\n\t} else if (err && AES_REG_IRQ_STATUS(dd) && AES_REG_IRQ_ENABLE(dd)) {\n\t\tdd->pio_only = 1;\n\n\t\tirq = platform_get_irq(pdev, 0);\n\t\tif (irq < 0) {\n\t\t\terr = irq;\n\t\t\tgoto err_irq;\n\t\t}\n\n\t\terr = devm_request_irq(dev, irq, omap_aes_irq, 0,\n\t\t\t\tdev_name(dev), dd);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Unable to grab omap-aes IRQ\\n\");\n\t\t\tgoto err_irq;\n\t\t}\n\t}\n\n\tspin_lock_init(&dd->lock);\n\n\tINIT_LIST_HEAD(&dd->list);\n\tspin_lock_bh(&list_lock);\n\tlist_add_tail(&dd->list, &dev_list);\n\tspin_unlock_bh(&list_lock);\n\n\t \n\tdd->engine = crypto_engine_alloc_init(dev, 1);\n\tif (!dd->engine) {\n\t\terr = -ENOMEM;\n\t\tgoto err_engine;\n\t}\n\n\terr = crypto_engine_start(dd->engine);\n\tif (err)\n\t\tgoto err_engine;\n\n\tfor (i = 0; i < dd->pdata->algs_info_size; i++) {\n\t\tif (!dd->pdata->algs_info[i].registered) {\n\t\t\tfor (j = 0; j < dd->pdata->algs_info[i].size; j++) {\n\t\t\t\talgp = &dd->pdata->algs_info[i].algs_list[j];\n\n\t\t\t\tpr_debug(\"reg alg: %s\\n\", algp->base.base.cra_name);\n\n\t\t\t\terr = crypto_engine_register_skcipher(algp);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto err_algs;\n\n\t\t\t\tdd->pdata->algs_info[i].registered++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dd->pdata->aead_algs_info &&\n\t    !dd->pdata->aead_algs_info->registered) {\n\t\tfor (i = 0; i < dd->pdata->aead_algs_info->size; i++) {\n\t\t\taalg = &dd->pdata->aead_algs_info->algs_list[i];\n\n\t\t\tpr_debug(\"reg alg: %s\\n\", aalg->base.base.cra_name);\n\n\t\t\terr = crypto_engine_register_aead(aalg);\n\t\t\tif (err)\n\t\t\t\tgoto err_aead_algs;\n\n\t\t\tdd->pdata->aead_algs_info->registered++;\n\t\t}\n\t}\n\n\terr = sysfs_create_group(&dev->kobj, &omap_aes_attr_group);\n\tif (err) {\n\t\tdev_err(dev, \"could not create sysfs device attrs\\n\");\n\t\tgoto err_aead_algs;\n\t}\n\n\treturn 0;\nerr_aead_algs:\n\tfor (i = dd->pdata->aead_algs_info->registered - 1; i >= 0; i--) {\n\t\taalg = &dd->pdata->aead_algs_info->algs_list[i];\n\t\tcrypto_engine_unregister_aead(aalg);\n\t}\nerr_algs:\n\tfor (i = dd->pdata->algs_info_size - 1; i >= 0; i--)\n\t\tfor (j = dd->pdata->algs_info[i].registered - 1; j >= 0; j--)\n\t\t\tcrypto_engine_unregister_skcipher(\n\t\t\t\t\t&dd->pdata->algs_info[i].algs_list[j]);\n\nerr_engine:\n\tif (dd->engine)\n\t\tcrypto_engine_exit(dd->engine);\n\n\tomap_aes_dma_cleanup(dd);\nerr_irq:\n\ttasklet_kill(&dd->done_task);\nerr_pm_disable:\n\tpm_runtime_disable(dev);\nerr_res:\n\tdd = NULL;\nerr_data:\n\tdev_err(dev, \"initialization failed.\\n\");\n\treturn err;\n}\n\nstatic int omap_aes_remove(struct platform_device *pdev)\n{\n\tstruct omap_aes_dev *dd = platform_get_drvdata(pdev);\n\tstruct aead_engine_alg *aalg;\n\tint i, j;\n\n\tspin_lock_bh(&list_lock);\n\tlist_del(&dd->list);\n\tspin_unlock_bh(&list_lock);\n\n\tfor (i = dd->pdata->algs_info_size - 1; i >= 0; i--)\n\t\tfor (j = dd->pdata->algs_info[i].registered - 1; j >= 0; j--) {\n\t\t\tcrypto_engine_unregister_skcipher(\n\t\t\t\t\t&dd->pdata->algs_info[i].algs_list[j]);\n\t\t\tdd->pdata->algs_info[i].registered--;\n\t\t}\n\n\tfor (i = dd->pdata->aead_algs_info->registered - 1; i >= 0; i--) {\n\t\taalg = &dd->pdata->aead_algs_info->algs_list[i];\n\t\tcrypto_engine_unregister_aead(aalg);\n\t\tdd->pdata->aead_algs_info->registered--;\n\t}\n\n\tcrypto_engine_exit(dd->engine);\n\n\ttasklet_kill(&dd->done_task);\n\tomap_aes_dma_cleanup(dd);\n\tpm_runtime_disable(dd->dev);\n\n\tsysfs_remove_group(&dd->dev->kobj, &omap_aes_attr_group);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int omap_aes_suspend(struct device *dev)\n{\n\tpm_runtime_put_sync(dev);\n\treturn 0;\n}\n\nstatic int omap_aes_resume(struct device *dev)\n{\n\tpm_runtime_get_sync(dev);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(omap_aes_pm_ops, omap_aes_suspend, omap_aes_resume);\n\nstatic struct platform_driver omap_aes_driver = {\n\t.probe\t= omap_aes_probe,\n\t.remove\t= omap_aes_remove,\n\t.driver\t= {\n\t\t.name\t= \"omap-aes\",\n\t\t.pm\t= &omap_aes_pm_ops,\n\t\t.of_match_table\t= omap_aes_of_match,\n\t},\n};\n\nmodule_platform_driver(omap_aes_driver);\n\nMODULE_DESCRIPTION(\"OMAP AES hw acceleration support.\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Dmitry Kasatkin\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}