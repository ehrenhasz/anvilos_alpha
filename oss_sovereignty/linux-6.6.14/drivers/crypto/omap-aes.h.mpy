{
  "module_name": "omap-aes.h",
  "hash_id": "4dbb5cbede260c03eeacc55069595b91f9c642084da7e0596abf9343c9e562fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/omap-aes.h",
  "human_readable_source": " \n \n#ifndef __OMAP_AES_H__\n#define __OMAP_AES_H__\n\n#include <crypto/aes.h>\n\n#define DST_MAXBURST\t\t\t4\n#define DMA_MIN\t\t\t\t(DST_MAXBURST * sizeof(u32))\n\n#define _calc_walked(inout) (dd->inout##_walk.offset - dd->inout##_sg->offset)\n\n \n#define FLD_MASK(start, end)\t(((1 << ((start) - (end) + 1)) - 1) << (end))\n#define FLD_VAL(val, start, end) (((val) << (end)) & FLD_MASK(start, end))\n\n#define AES_REG_KEY(dd, x)\t\t((dd)->pdata->key_ofs - \\\n\t\t\t\t\t\t(((x) ^ 0x01) * 0x04))\n#define AES_REG_IV(dd, x)\t\t((dd)->pdata->iv_ofs + ((x) * 0x04))\n\n#define AES_REG_CTRL(dd)\t\t((dd)->pdata->ctrl_ofs)\n#define AES_REG_CTRL_CONTEXT_READY\tBIT(31)\n#define AES_REG_CTRL_CTR_WIDTH_MASK\tGENMASK(8, 7)\n#define AES_REG_CTRL_CTR_WIDTH_32\t0\n#define AES_REG_CTRL_CTR_WIDTH_64\tBIT(7)\n#define AES_REG_CTRL_CTR_WIDTH_96\tBIT(8)\n#define AES_REG_CTRL_CTR_WIDTH_128\tGENMASK(8, 7)\n#define AES_REG_CTRL_GCM\t\tGENMASK(17, 16)\n#define AES_REG_CTRL_CTR\t\tBIT(6)\n#define AES_REG_CTRL_CBC\t\tBIT(5)\n#define AES_REG_CTRL_KEY_SIZE\t\tGENMASK(4, 3)\n#define AES_REG_CTRL_DIRECTION\t\tBIT(2)\n#define AES_REG_CTRL_INPUT_READY\tBIT(1)\n#define AES_REG_CTRL_OUTPUT_READY\tBIT(0)\n#define AES_REG_CTRL_MASK\t\tGENMASK(24, 2)\n\n#define AES_REG_C_LEN_0\t\t\t0x54\n#define AES_REG_C_LEN_1\t\t\t0x58\n#define AES_REG_A_LEN\t\t\t0x5C\n\n#define AES_REG_DATA_N(dd, x)\t\t((dd)->pdata->data_ofs + ((x) * 0x04))\n#define AES_REG_TAG_N(dd, x)\t\t(0x70 + ((x) * 0x04))\n\n#define AES_REG_REV(dd)\t\t\t((dd)->pdata->rev_ofs)\n\n#define AES_REG_MASK(dd)\t\t((dd)->pdata->mask_ofs)\n#define AES_REG_MASK_SIDLE\t\tBIT(6)\n#define AES_REG_MASK_START\t\tBIT(5)\n#define AES_REG_MASK_DMA_OUT_EN\t\tBIT(3)\n#define AES_REG_MASK_DMA_IN_EN\t\tBIT(2)\n#define AES_REG_MASK_SOFTRESET\t\tBIT(1)\n#define AES_REG_AUTOIDLE\t\tBIT(0)\n\n#define AES_REG_LENGTH_N(x)\t\t(0x54 + ((x) * 0x04))\n\n#define AES_REG_IRQ_STATUS(dd)         ((dd)->pdata->irq_status_ofs)\n#define AES_REG_IRQ_ENABLE(dd)         ((dd)->pdata->irq_enable_ofs)\n#define AES_REG_IRQ_DATA_IN            BIT(1)\n#define AES_REG_IRQ_DATA_OUT           BIT(2)\n#define DEFAULT_TIMEOUT\t\t(5 * HZ)\n\n#define DEFAULT_AUTOSUSPEND_DELAY\t1000\n\n#define FLAGS_MODE_MASK\t\t0x001f\n#define FLAGS_ENCRYPT\t\tBIT(0)\n#define FLAGS_CBC\t\tBIT(1)\n#define FLAGS_CTR\t\tBIT(2)\n#define FLAGS_GCM\t\tBIT(3)\n#define FLAGS_RFC4106_GCM\tBIT(4)\n\n#define FLAGS_INIT\t\tBIT(5)\n#define FLAGS_FAST\t\tBIT(6)\n\n#define FLAGS_IN_DATA_ST_SHIFT\t8\n#define FLAGS_OUT_DATA_ST_SHIFT\t10\n#define FLAGS_ASSOC_DATA_ST_SHIFT\t12\n\n#define AES_BLOCK_WORDS\t\t(AES_BLOCK_SIZE >> 2)\n\nstruct omap_aes_gcm_result {\n\tstruct completion completion;\n\tint err;\n};\n\nstruct omap_aes_ctx {\n\tint\t\tkeylen;\n\tu32\t\tkey[AES_KEYSIZE_256 / sizeof(u32)];\n\tu8\t\tnonce[4];\n\tstruct crypto_skcipher\t*fallback;\n};\n\nstruct omap_aes_gcm_ctx {\n\tstruct omap_aes_ctx\toctx;\n\tstruct crypto_aes_ctx\tactx;\n};\n\nstruct omap_aes_reqctx {\n\tstruct omap_aes_dev *dd;\n\tunsigned long mode;\n\tu8 iv[AES_BLOCK_SIZE];\n\tu32 auth_tag[AES_BLOCK_SIZE / sizeof(u32)];\n\tstruct skcipher_request fallback_req;\t\n};\n\n#define OMAP_AES_QUEUE_LENGTH\t1\n#define OMAP_AES_CACHE_SIZE\t0\n\nstruct omap_aes_algs_info {\n\tstruct skcipher_engine_alg\t*algs_list;\n\tunsigned int\t\t\tsize;\n\tunsigned int\t\t\tregistered;\n};\n\nstruct omap_aes_aead_algs {\n\tstruct aead_engine_alg\t\t*algs_list;\n\tunsigned int\t\t\tsize;\n\tunsigned int\t\t\tregistered;\n};\n\nstruct omap_aes_pdata {\n\tstruct omap_aes_algs_info\t*algs_info;\n\tunsigned int\talgs_info_size;\n\tstruct omap_aes_aead_algs\t*aead_algs_info;\n\n\tvoid\t\t(*trigger)(struct omap_aes_dev *dd, int length);\n\n\tu32\t\tkey_ofs;\n\tu32\t\tiv_ofs;\n\tu32\t\tctrl_ofs;\n\tu32\t\tdata_ofs;\n\tu32\t\trev_ofs;\n\tu32\t\tmask_ofs;\n\tu32             irq_enable_ofs;\n\tu32             irq_status_ofs;\n\n\tu32\t\tdma_enable_in;\n\tu32\t\tdma_enable_out;\n\tu32\t\tdma_start;\n\n\tu32\t\tmajor_mask;\n\tu32\t\tmajor_shift;\n\tu32\t\tminor_mask;\n\tu32\t\tminor_shift;\n};\n\nstruct omap_aes_dev {\n\tstruct list_head\tlist;\n\tunsigned long\t\tphys_base;\n\tvoid __iomem\t\t*io_base;\n\tstruct omap_aes_ctx\t*ctx;\n\tstruct device\t\t*dev;\n\tunsigned long\t\tflags;\n\tint\t\t\terr;\n\n\tstruct tasklet_struct\tdone_task;\n\tstruct aead_queue\taead_queue;\n\tspinlock_t\t\tlock;\n\n\tstruct skcipher_request\t\t*req;\n\tstruct aead_request\t\t*aead_req;\n\tstruct crypto_engine\t\t*engine;\n\n\t \n\tsize_t\t\t\t\ttotal;\n\tsize_t\t\t\t\ttotal_save;\n\tsize_t\t\t\t\tassoc_len;\n\tsize_t\t\t\t\tauthsize;\n\n\tstruct scatterlist\t\t*in_sg;\n\tstruct scatterlist\t\t*out_sg;\n\n\t \n\tstruct scatterlist\t\tin_sgl[2];\n\tstruct scatterlist\t\tout_sgl;\n\tstruct scatterlist\t\t*orig_out;\n\n\tstruct scatter_walk\t\tin_walk;\n\tstruct scatter_walk\t\tout_walk;\n\tstruct dma_chan\t\t*dma_lch_in;\n\tstruct dma_chan\t\t*dma_lch_out;\n\tint\t\t\tin_sg_len;\n\tint\t\t\tout_sg_len;\n\tint\t\t\tpio_only;\n\tconst struct omap_aes_pdata\t*pdata;\n};\n\nu32 omap_aes_read(struct omap_aes_dev *dd, u32 offset);\nvoid omap_aes_write(struct omap_aes_dev *dd, u32 offset, u32 value);\nstruct omap_aes_dev *omap_aes_find_dev(struct omap_aes_reqctx *rctx);\nint omap_aes_gcm_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\tunsigned int keylen);\nint omap_aes_4106gcm_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t    unsigned int keylen);\nint omap_aes_gcm_encrypt(struct aead_request *req);\nint omap_aes_gcm_decrypt(struct aead_request *req);\nint omap_aes_gcm_setauthsize(struct crypto_aead *tfm, unsigned int authsize);\nint omap_aes_4106gcm_encrypt(struct aead_request *req);\nint omap_aes_4106gcm_decrypt(struct aead_request *req);\nint omap_aes_4106gcm_setauthsize(struct crypto_aead *parent,\n\t\t\t\t unsigned int authsize);\nint omap_aes_gcm_cra_init(struct crypto_aead *tfm);\nint omap_aes_write_ctrl(struct omap_aes_dev *dd);\nint omap_aes_crypt_dma_start(struct omap_aes_dev *dd);\nint omap_aes_crypt_dma_stop(struct omap_aes_dev *dd);\nvoid omap_aes_gcm_dma_out_callback(void *data);\nvoid omap_aes_clear_copy_flags(struct omap_aes_dev *dd);\nint omap_aes_gcm_crypt_req(struct crypto_engine *engine, void *areq);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}