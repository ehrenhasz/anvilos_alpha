{
  "module_name": "sl3516-ce-core.c",
  "hash_id": "79cb0a8147b13186d5e4409f021c5fa1118438c2799e5af4ca6ed1a02ca4ac28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/gemini/sl3516-ce-core.c",
  "human_readable_source": "\n \n\n#include <crypto/engine.h>\n#include <crypto/internal/rng.h>\n#include <crypto/internal/skcipher.h>\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/dev_printk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include \"sl3516-ce.h\"\n\nstatic int sl3516_ce_desc_init(struct sl3516_ce_dev *ce)\n{\n\tconst size_t sz = sizeof(struct descriptor) * MAXDESC;\n\tint i;\n\n\tce->tx = dma_alloc_coherent(ce->dev, sz, &ce->dtx, GFP_KERNEL);\n\tif (!ce->tx)\n\t\treturn -ENOMEM;\n\tce->rx = dma_alloc_coherent(ce->dev, sz, &ce->drx, GFP_KERNEL);\n\tif (!ce->rx)\n\t\tgoto err_rx;\n\n\tfor (i = 0; i < MAXDESC; i++) {\n\t\tce->tx[i].frame_ctrl.bits.own = CE_CPU;\n\t\tce->tx[i].next_desc.next_descriptor = ce->dtx + (i + 1) * sizeof(struct descriptor);\n\t}\n\tce->tx[MAXDESC - 1].next_desc.next_descriptor = ce->dtx;\n\n\tfor (i = 0; i < MAXDESC; i++) {\n\t\tce->rx[i].frame_ctrl.bits.own = CE_CPU;\n\t\tce->rx[i].next_desc.next_descriptor = ce->drx + (i + 1) * sizeof(struct descriptor);\n\t}\n\tce->rx[MAXDESC - 1].next_desc.next_descriptor = ce->drx;\n\n\tce->pctrl = dma_alloc_coherent(ce->dev, sizeof(struct pkt_control_ecb),\n\t\t\t\t       &ce->dctrl, GFP_KERNEL);\n\tif (!ce->pctrl)\n\t\tgoto err_pctrl;\n\n\treturn 0;\nerr_pctrl:\n\tdma_free_coherent(ce->dev, sz, ce->rx, ce->drx);\nerr_rx:\n\tdma_free_coherent(ce->dev, sz, ce->tx, ce->dtx);\n\treturn -ENOMEM;\n}\n\nstatic void sl3516_ce_free_descs(struct sl3516_ce_dev *ce)\n{\n\tconst size_t sz = sizeof(struct descriptor) * MAXDESC;\n\n\tdma_free_coherent(ce->dev, sz, ce->tx, ce->dtx);\n\tdma_free_coherent(ce->dev, sz, ce->rx, ce->drx);\n\tdma_free_coherent(ce->dev, sizeof(struct pkt_control_ecb), ce->pctrl,\n\t\t\t  ce->dctrl);\n}\n\nstatic void start_dma_tx(struct sl3516_ce_dev *ce)\n{\n\tu32 v;\n\n\tv = TXDMA_CTRL_START | TXDMA_CTRL_CHAIN_MODE | TXDMA_CTRL_CONTINUE | \\\n\t\tTXDMA_CTRL_INT_FAIL | TXDMA_CTRL_INT_PERR | TXDMA_CTRL_BURST_UNK;\n\n\twritel(v, ce->base + IPSEC_TXDMA_CTRL);\n}\n\nstatic void start_dma_rx(struct sl3516_ce_dev *ce)\n{\n\tu32 v;\n\n\tv = RXDMA_CTRL_START | RXDMA_CTRL_CHAIN_MODE | RXDMA_CTRL_CONTINUE | \\\n\t\tRXDMA_CTRL_BURST_UNK | RXDMA_CTRL_INT_FINISH | \\\n\t\tRXDMA_CTRL_INT_FAIL | RXDMA_CTRL_INT_PERR | \\\n\t\tRXDMA_CTRL_INT_EOD | RXDMA_CTRL_INT_EOF;\n\n\twritel(v, ce->base + IPSEC_RXDMA_CTRL);\n}\n\nstatic struct descriptor *get_desc_tx(struct sl3516_ce_dev *ce)\n{\n\tstruct descriptor *dd;\n\n\tdd = &ce->tx[ce->ctx];\n\tce->ctx++;\n\tif (ce->ctx >= MAXDESC)\n\t\tce->ctx = 0;\n\treturn dd;\n}\n\nstatic struct descriptor *get_desc_rx(struct sl3516_ce_dev *ce)\n{\n\tstruct descriptor *rdd;\n\n\trdd = &ce->rx[ce->crx];\n\tce->crx++;\n\tif (ce->crx >= MAXDESC)\n\t\tce->crx = 0;\n\treturn rdd;\n}\n\nint sl3516_ce_run_task(struct sl3516_ce_dev *ce, struct sl3516_ce_cipher_req_ctx *rctx,\n\t\t       const char *name)\n{\n\tstruct descriptor *dd, *rdd = NULL;\n\tu32 v;\n\tint i, err = 0;\n\n\tce->stat_req++;\n\n\treinit_completion(&ce->complete);\n\tce->status = 0;\n\n\tfor (i = 0; i < rctx->nr_sgd; i++) {\n\t\tdev_dbg(ce->dev, \"%s handle DST SG %d/%d len=%d\\n\", __func__,\n\t\t\ti, rctx->nr_sgd, rctx->t_dst[i].len);\n\t\trdd = get_desc_rx(ce);\n\t\trdd->buf_adr = rctx->t_dst[i].addr;\n\t\trdd->frame_ctrl.bits.buffer_size = rctx->t_dst[i].len;\n\t\trdd->frame_ctrl.bits.own = CE_DMA;\n\t}\n\trdd->next_desc.bits.eofie = 1;\n\n\tfor (i = 0; i < rctx->nr_sgs; i++) {\n\t\tdev_dbg(ce->dev, \"%s handle SRC SG %d/%d len=%d\\n\", __func__,\n\t\t\ti, rctx->nr_sgs, rctx->t_src[i].len);\n\t\trctx->h->algorithm_len = rctx->t_src[i].len;\n\n\t\tdd = get_desc_tx(ce);\n\t\tdd->frame_ctrl.raw = 0;\n\t\tdd->flag_status.raw = 0;\n\t\tdd->frame_ctrl.bits.buffer_size = rctx->pctrllen;\n\t\tdd->buf_adr = ce->dctrl;\n\t\tdd->flag_status.tx_flag.tqflag = rctx->tqflag;\n\t\tdd->next_desc.bits.eofie = 0;\n\t\tdd->next_desc.bits.dec = 0;\n\t\tdd->next_desc.bits.sof_eof = DESC_FIRST | DESC_LAST;\n\t\tdd->frame_ctrl.bits.own = CE_DMA;\n\n\t\tdd = get_desc_tx(ce);\n\t\tdd->frame_ctrl.raw = 0;\n\t\tdd->flag_status.raw = 0;\n\t\tdd->frame_ctrl.bits.buffer_size = rctx->t_src[i].len;\n\t\tdd->buf_adr = rctx->t_src[i].addr;\n\t\tdd->flag_status.tx_flag.tqflag = 0;\n\t\tdd->next_desc.bits.eofie = 0;\n\t\tdd->next_desc.bits.dec = 0;\n\t\tdd->next_desc.bits.sof_eof = DESC_FIRST | DESC_LAST;\n\t\tdd->frame_ctrl.bits.own = CE_DMA;\n\t\tstart_dma_tx(ce);\n\t\tstart_dma_rx(ce);\n\t}\n\twait_for_completion_interruptible_timeout(&ce->complete,\n\t\t\t\t\t\t  msecs_to_jiffies(5000));\n\tif (ce->status == 0) {\n\t\tdev_err(ce->dev, \"DMA timeout for %s\\n\", name);\n\t\terr = -EFAULT;\n\t}\n\tv = readl(ce->base + IPSEC_STATUS_REG);\n\tif (v & 0xFFF) {\n\t\tdev_err(ce->dev, \"IPSEC_STATUS_REG %x\\n\", v);\n\t\terr = -EFAULT;\n\t}\n\n\treturn err;\n}\n\nstatic irqreturn_t ce_irq_handler(int irq, void *data)\n{\n\tstruct sl3516_ce_dev *ce = (struct sl3516_ce_dev *)data;\n\tu32 v;\n\n\tce->stat_irq++;\n\n\tv = readl(ce->base + IPSEC_DMA_STATUS);\n\twritel(v, ce->base + IPSEC_DMA_STATUS);\n\n\tif (v & DMA_STATUS_TS_DERR)\n\t\tdev_err(ce->dev, \"AHB bus Error While Tx !!!\\n\");\n\tif (v & DMA_STATUS_TS_PERR)\n\t\tdev_err(ce->dev, \"Tx Descriptor Protocol Error !!!\\n\");\n\tif (v & DMA_STATUS_RS_DERR)\n\t\tdev_err(ce->dev, \"AHB bus Error While Rx !!!\\n\");\n\tif (v & DMA_STATUS_RS_PERR)\n\t\tdev_err(ce->dev, \"Rx Descriptor Protocol Error !!!\\n\");\n\n\tif (v & DMA_STATUS_TS_EOFI)\n\t\tce->stat_irq_tx++;\n\tif (v & DMA_STATUS_RS_EOFI) {\n\t\tce->status = 1;\n\t\tcomplete(&ce->complete);\n\t\tce->stat_irq_rx++;\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct sl3516_ce_alg_template ce_algs[] = {\n{\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.mode = ECB_AES,\n\t.alg.skcipher.base = {\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(aes)\",\n\t\t\t.cra_driver_name = \"ecb-aes-sl3516\",\n\t\t\t.cra_priority = 400,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_flags = CRYPTO_ALG_TYPE_SKCIPHER |\n\t\t\t\tCRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_ctxsize = sizeof(struct sl3516_ce_cipher_tfm_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t\t.cra_alignmask = 0xf,\n\t\t\t.cra_init = sl3516_ce_cipher_init,\n\t\t\t.cra_exit = sl3516_ce_cipher_exit,\n\t\t},\n\t\t.min_keysize\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t= AES_MAX_KEY_SIZE,\n\t\t.setkey\t\t= sl3516_ce_aes_setkey,\n\t\t.encrypt\t= sl3516_ce_skencrypt,\n\t\t.decrypt\t= sl3516_ce_skdecrypt,\n\t},\n\t.alg.skcipher.op = {\n\t\t.do_one_request = sl3516_ce_handle_cipher_request,\n\t},\n},\n};\n\nstatic int sl3516_ce_debugfs_show(struct seq_file *seq, void *v)\n{\n\tstruct sl3516_ce_dev *ce = seq->private;\n\tunsigned int i;\n\n\tseq_printf(seq, \"HWRNG %lu %lu\\n\",\n\t\t   ce->hwrng_stat_req, ce->hwrng_stat_bytes);\n\tseq_printf(seq, \"IRQ %lu\\n\", ce->stat_irq);\n\tseq_printf(seq, \"IRQ TX %lu\\n\", ce->stat_irq_tx);\n\tseq_printf(seq, \"IRQ RX %lu\\n\", ce->stat_irq_rx);\n\tseq_printf(seq, \"nreq %lu\\n\", ce->stat_req);\n\tseq_printf(seq, \"fallback SG count TX %lu\\n\", ce->fallback_sg_count_tx);\n\tseq_printf(seq, \"fallback SG count RX %lu\\n\", ce->fallback_sg_count_rx);\n\tseq_printf(seq, \"fallback modulo16 %lu\\n\", ce->fallback_mod16);\n\tseq_printf(seq, \"fallback align16 %lu\\n\", ce->fallback_align16);\n\tseq_printf(seq, \"fallback not same len %lu\\n\", ce->fallback_not_same_len);\n\n\tfor (i = 0; i < ARRAY_SIZE(ce_algs); i++) {\n\t\tif (!ce_algs[i].ce)\n\t\t\tcontinue;\n\t\tswitch (ce_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tseq_printf(seq, \"%s %s reqs=%lu fallback=%lu\\n\",\n\t\t\t\t   ce_algs[i].alg.skcipher.base.base.cra_driver_name,\n\t\t\t\t   ce_algs[i].alg.skcipher.base.base.cra_name,\n\t\t\t\t   ce_algs[i].stat_req, ce_algs[i].stat_fb);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(sl3516_ce_debugfs);\n\nstatic int sl3516_ce_register_algs(struct sl3516_ce_dev *ce)\n{\n\tint err;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ce_algs); i++) {\n\t\tce_algs[i].ce = ce;\n\t\tswitch (ce_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tdev_info(ce->dev, \"DEBUG: Register %s\\n\",\n\t\t\t\t ce_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\terr = crypto_engine_register_skcipher(&ce_algs[i].alg.skcipher);\n\t\t\tif (err) {\n\t\t\t\tdev_err(ce->dev, \"Fail to register %s\\n\",\n\t\t\t\t\tce_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\t\tce_algs[i].ce = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tce_algs[i].ce = NULL;\n\t\t\tdev_err(ce->dev, \"ERROR: tried to register an unknown algo\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sl3516_ce_unregister_algs(struct sl3516_ce_dev *ce)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ce_algs); i++) {\n\t\tif (!ce_algs[i].ce)\n\t\t\tcontinue;\n\t\tswitch (ce_algs[i].type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tdev_info(ce->dev, \"Unregister %d %s\\n\", i,\n\t\t\t\t ce_algs[i].alg.skcipher.base.base.cra_name);\n\t\t\tcrypto_engine_unregister_skcipher(&ce_algs[i].alg.skcipher);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void sl3516_ce_start(struct sl3516_ce_dev *ce)\n{\n\tce->ctx = 0;\n\tce->crx = 0;\n\twritel(ce->dtx, ce->base + IPSEC_TXDMA_CURR_DESC);\n\twritel(ce->drx, ce->base + IPSEC_RXDMA_CURR_DESC);\n\twritel(0, ce->base + IPSEC_DMA_STATUS);\n}\n\n \nstatic int sl3516_ce_pm_suspend(struct device *dev)\n{\n\tstruct sl3516_ce_dev *ce = dev_get_drvdata(dev);\n\n\treset_control_assert(ce->reset);\n\tclk_disable_unprepare(ce->clks);\n\treturn 0;\n}\n\nstatic int sl3516_ce_pm_resume(struct device *dev)\n{\n\tstruct sl3516_ce_dev *ce = dev_get_drvdata(dev);\n\tint err;\n\n\terr = clk_prepare_enable(ce->clks);\n\tif (err) {\n\t\tdev_err(ce->dev, \"Cannot prepare_enable\\n\");\n\t\tgoto error;\n\t}\n\terr = reset_control_deassert(ce->reset);\n\tif (err) {\n\t\tdev_err(ce->dev, \"Cannot deassert reset control\\n\");\n\t\tgoto error;\n\t}\n\n\tsl3516_ce_start(ce);\n\n\treturn 0;\nerror:\n\tsl3516_ce_pm_suspend(dev);\n\treturn err;\n}\n\nstatic const struct dev_pm_ops sl3516_ce_pm_ops = {\n\tSET_RUNTIME_PM_OPS(sl3516_ce_pm_suspend, sl3516_ce_pm_resume, NULL)\n};\n\nstatic int sl3516_ce_pm_init(struct sl3516_ce_dev *ce)\n{\n\tint err;\n\n\tpm_runtime_use_autosuspend(ce->dev);\n\tpm_runtime_set_autosuspend_delay(ce->dev, 2000);\n\n\terr = pm_runtime_set_suspended(ce->dev);\n\tif (err)\n\t\treturn err;\n\tpm_runtime_enable(ce->dev);\n\treturn err;\n}\n\nstatic void sl3516_ce_pm_exit(struct sl3516_ce_dev *ce)\n{\n\tpm_runtime_disable(ce->dev);\n}\n\nstatic int sl3516_ce_probe(struct platform_device *pdev)\n{\n\tstruct sl3516_ce_dev *ce;\n\tint err, irq;\n\tu32 v;\n\n\tce = devm_kzalloc(&pdev->dev, sizeof(*ce), GFP_KERNEL);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\n\tce->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ce);\n\n\tce->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ce->base))\n\t\treturn PTR_ERR(ce->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\terr = devm_request_irq(&pdev->dev, irq, ce_irq_handler, 0, \"crypto\", ce);\n\tif (err) {\n\t\tdev_err(ce->dev, \"Cannot request Crypto Engine IRQ (err=%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tce->reset = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(ce->reset))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(ce->reset),\n\t\t\t\t     \"No reset control found\\n\");\n\tce->clks = devm_clk_get(ce->dev, NULL);\n\tif (IS_ERR(ce->clks)) {\n\t\terr = PTR_ERR(ce->clks);\n\t\tdev_err(ce->dev, \"Cannot get clock err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = sl3516_ce_desc_init(ce);\n\tif (err)\n\t\treturn err;\n\n\terr = sl3516_ce_pm_init(ce);\n\tif (err)\n\t\tgoto error_pm;\n\n\tinit_completion(&ce->complete);\n\n\tce->engine = crypto_engine_alloc_init(ce->dev, true);\n\tif (!ce->engine) {\n\t\tdev_err(ce->dev, \"Cannot allocate engine\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto error_engine;\n\t}\n\n\terr = crypto_engine_start(ce->engine);\n\tif (err) {\n\t\tdev_err(ce->dev, \"Cannot start engine\\n\");\n\t\tgoto error_engine;\n\t}\n\n\terr = sl3516_ce_register_algs(ce);\n\tif (err)\n\t\tgoto error_alg;\n\n\terr = sl3516_ce_rng_register(ce);\n\tif (err)\n\t\tgoto error_rng;\n\n\terr = pm_runtime_resume_and_get(ce->dev);\n\tif (err < 0)\n\t\tgoto error_pmuse;\n\n\tv = readl(ce->base + IPSEC_ID);\n\tdev_info(ce->dev, \"SL3516 dev %lx rev %lx\\n\",\n\t\t v & GENMASK(31, 4),\n\t\t v & GENMASK(3, 0));\n\tv = readl(ce->base + IPSEC_DMA_DEVICE_ID);\n\tdev_info(ce->dev, \"SL3516 DMA dev %lx rev %lx\\n\",\n\t\t v & GENMASK(15, 4),\n\t\t v & GENMASK(3, 0));\n\n\tpm_runtime_put_sync(ce->dev);\n\n\tif (IS_ENABLED(CONFIG_CRYPTO_DEV_SL3516_DEBUG)) {\n\t\tstruct dentry *dbgfs_dir __maybe_unused;\n\t\tstruct dentry *dbgfs_stats __maybe_unused;\n\n\t\t \n\t\tdbgfs_dir = debugfs_create_dir(\"sl3516\", NULL);\n\t\tdbgfs_stats = debugfs_create_file(\"stats\", 0444,\n\t\t\t\t\t\t  dbgfs_dir, ce,\n\t\t\t\t\t\t  &sl3516_ce_debugfs_fops);\n#ifdef CONFIG_CRYPTO_DEV_SL3516_DEBUG\n\t\tce->dbgfs_dir = dbgfs_dir;\n\t\tce->dbgfs_stats = dbgfs_stats;\n#endif\n\t}\n\n\treturn 0;\nerror_pmuse:\n\tsl3516_ce_rng_unregister(ce);\nerror_rng:\n\tsl3516_ce_unregister_algs(ce);\nerror_alg:\n\tcrypto_engine_exit(ce->engine);\nerror_engine:\n\tsl3516_ce_pm_exit(ce);\nerror_pm:\n\tsl3516_ce_free_descs(ce);\n\treturn err;\n}\n\nstatic int sl3516_ce_remove(struct platform_device *pdev)\n{\n\tstruct sl3516_ce_dev *ce = platform_get_drvdata(pdev);\n\n\tsl3516_ce_rng_unregister(ce);\n\tsl3516_ce_unregister_algs(ce);\n\tcrypto_engine_exit(ce->engine);\n\tsl3516_ce_pm_exit(ce);\n\tsl3516_ce_free_descs(ce);\n\n#ifdef CONFIG_CRYPTO_DEV_SL3516_DEBUG\n\tdebugfs_remove_recursive(ce->dbgfs_dir);\n#endif\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sl3516_ce_crypto_of_match_table[] = {\n\t{ .compatible = \"cortina,sl3516-crypto\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sl3516_ce_crypto_of_match_table);\n\nstatic struct platform_driver sl3516_ce_driver = {\n\t.probe\t\t = sl3516_ce_probe,\n\t.remove\t\t = sl3516_ce_remove,\n\t.driver\t\t = {\n\t\t.name\t\t= \"sl3516-crypto\",\n\t\t.pm\t\t= &sl3516_ce_pm_ops,\n\t\t.of_match_table\t= sl3516_ce_crypto_of_match_table,\n\t},\n};\n\nmodule_platform_driver(sl3516_ce_driver);\n\nMODULE_DESCRIPTION(\"SL3516 cryptographic offloader\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Corentin Labbe <clabbe@baylibre.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}