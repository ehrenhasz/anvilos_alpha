{
  "module_name": "qm.c",
  "hash_id": "82fcbbd299e053be6457eeaefed76eac6094d04cea355179c701b5438d387f5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/hisilicon/qm.c",
  "human_readable_source": "\n \n#include <asm/page.h>\n#include <linux/acpi.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/idr.h>\n#include <linux/io.h>\n#include <linux/irqreturn.h>\n#include <linux/log2.h>\n#include <linux/pm_runtime.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/uacce.h>\n#include <linux/uaccess.h>\n#include <uapi/misc/uacce/hisi_qm.h>\n#include <linux/hisi_acc_qm.h>\n#include \"qm_common.h\"\n\n \n#define QM_VF_AEQ_INT_SOURCE\t\t0x0\n#define QM_VF_AEQ_INT_MASK\t\t0x4\n#define QM_VF_EQ_INT_SOURCE\t\t0x8\n#define QM_VF_EQ_INT_MASK\t\t0xc\n\n#define QM_IRQ_VECTOR_MASK\t\tGENMASK(15, 0)\n#define QM_IRQ_TYPE_MASK\t\tGENMASK(15, 0)\n#define QM_IRQ_TYPE_SHIFT\t\t16\n#define QM_ABN_IRQ_TYPE_MASK\t\tGENMASK(7, 0)\n\n \n#define QM_MB_PING_ALL_VFS\t\t0xffff\n#define QM_MB_CMD_DATA_SHIFT\t\t32\n#define QM_MB_CMD_DATA_MASK\t\tGENMASK(31, 0)\n#define QM_MB_STATUS_MASK\t\tGENMASK(12, 9)\n\n \n#define QM_SQ_HOP_NUM_SHIFT\t\t0\n#define QM_SQ_PAGE_SIZE_SHIFT\t\t4\n#define QM_SQ_BUF_SIZE_SHIFT\t\t8\n#define QM_SQ_SQE_SIZE_SHIFT\t\t12\n#define QM_SQ_PRIORITY_SHIFT\t\t0\n#define QM_SQ_ORDERS_SHIFT\t\t4\n#define QM_SQ_TYPE_SHIFT\t\t8\n#define QM_QC_PASID_ENABLE\t\t0x1\n#define QM_QC_PASID_ENABLE_SHIFT\t7\n\n#define QM_SQ_TYPE_MASK\t\t\tGENMASK(3, 0)\n#define QM_SQ_TAIL_IDX(sqc)\t\t((le16_to_cpu((sqc)->w11) >> 6) & 0x1)\n\n \n#define QM_CQ_HOP_NUM_SHIFT\t\t0\n#define QM_CQ_PAGE_SIZE_SHIFT\t\t4\n#define QM_CQ_BUF_SIZE_SHIFT\t\t8\n#define QM_CQ_CQE_SIZE_SHIFT\t\t12\n#define QM_CQ_PHASE_SHIFT\t\t0\n#define QM_CQ_FLAG_SHIFT\t\t1\n\n#define QM_CQE_PHASE(cqe)\t\t(le16_to_cpu((cqe)->w7) & 0x1)\n#define QM_QC_CQE_SIZE\t\t\t4\n#define QM_CQ_TAIL_IDX(cqc)\t\t((le16_to_cpu((cqc)->w11) >> 6) & 0x1)\n\n \n#define QM_EQE_AEQE_SIZE\t\t(2UL << 12)\n#define QM_EQC_PHASE_SHIFT\t\t16\n\n#define QM_EQE_PHASE(eqe)\t\t((le32_to_cpu((eqe)->dw0) >> 16) & 0x1)\n#define QM_EQE_CQN_MASK\t\t\tGENMASK(15, 0)\n\n#define QM_AEQE_PHASE(aeqe)\t\t((le32_to_cpu((aeqe)->dw0) >> 16) & 0x1)\n#define QM_AEQE_TYPE_SHIFT\t\t17\n#define QM_AEQE_CQN_MASK\t\tGENMASK(15, 0)\n#define QM_CQ_OVERFLOW\t\t\t0\n#define QM_EQ_OVERFLOW\t\t\t1\n#define QM_CQE_ERROR\t\t\t2\n\n#define QM_XQ_DEPTH_SHIFT\t\t16\n#define QM_XQ_DEPTH_MASK\t\tGENMASK(15, 0)\n\n#define QM_DOORBELL_CMD_SQ\t\t0\n#define QM_DOORBELL_CMD_CQ\t\t1\n#define QM_DOORBELL_CMD_EQ\t\t2\n#define QM_DOORBELL_CMD_AEQ\t\t3\n\n#define QM_DOORBELL_BASE_V1\t\t0x340\n#define QM_DB_CMD_SHIFT_V1\t\t16\n#define QM_DB_INDEX_SHIFT_V1\t\t32\n#define QM_DB_PRIORITY_SHIFT_V1\t\t48\n#define QM_PAGE_SIZE\t\t\t0x0034\n#define QM_QP_DB_INTERVAL\t\t0x10000\n#define QM_DB_TIMEOUT_CFG\t\t0x100074\n#define QM_DB_TIMEOUT_SET\t\t0x1fffff\n\n#define QM_MEM_START_INIT\t\t0x100040\n#define QM_MEM_INIT_DONE\t\t0x100044\n#define QM_VFT_CFG_RDY\t\t\t0x10006c\n#define QM_VFT_CFG_OP_WR\t\t0x100058\n#define QM_VFT_CFG_TYPE\t\t\t0x10005c\n#define QM_VFT_CFG\t\t\t0x100060\n#define QM_VFT_CFG_OP_ENABLE\t\t0x100054\n#define QM_PM_CTRL\t\t\t0x100148\n#define QM_IDLE_DISABLE\t\t\tBIT(9)\n\n#define QM_VFT_CFG_DATA_L\t\t0x100064\n#define QM_VFT_CFG_DATA_H\t\t0x100068\n#define QM_SQC_VFT_BUF_SIZE\t\t(7ULL << 8)\n#define QM_SQC_VFT_SQC_SIZE\t\t(5ULL << 12)\n#define QM_SQC_VFT_INDEX_NUMBER\t\t(1ULL << 16)\n#define QM_SQC_VFT_START_SQN_SHIFT\t28\n#define QM_SQC_VFT_VALID\t\t(1ULL << 44)\n#define QM_SQC_VFT_SQN_SHIFT\t\t45\n#define QM_CQC_VFT_BUF_SIZE\t\t(7ULL << 8)\n#define QM_CQC_VFT_SQC_SIZE\t\t(5ULL << 12)\n#define QM_CQC_VFT_INDEX_NUMBER\t\t(1ULL << 16)\n#define QM_CQC_VFT_VALID\t\t(1ULL << 28)\n\n#define QM_SQC_VFT_BASE_SHIFT_V2\t28\n#define QM_SQC_VFT_BASE_MASK_V2\t\tGENMASK(15, 0)\n#define QM_SQC_VFT_NUM_SHIFT_V2\t\t45\n#define QM_SQC_VFT_NUM_MASK_V2\t\tGENMASK(9, 0)\n\n#define QM_ABNORMAL_INT_SOURCE\t\t0x100000\n#define QM_ABNORMAL_INT_MASK\t\t0x100004\n#define QM_ABNORMAL_INT_MASK_VALUE\t0x7fff\n#define QM_ABNORMAL_INT_STATUS\t\t0x100008\n#define QM_ABNORMAL_INT_SET\t\t0x10000c\n#define QM_ABNORMAL_INF00\t\t0x100010\n#define QM_FIFO_OVERFLOW_TYPE\t\t0xc0\n#define QM_FIFO_OVERFLOW_TYPE_SHIFT\t6\n#define QM_FIFO_OVERFLOW_VF\t\t0x3f\n#define QM_ABNORMAL_INF01\t\t0x100014\n#define QM_DB_TIMEOUT_TYPE\t\t0xc0\n#define QM_DB_TIMEOUT_TYPE_SHIFT\t6\n#define QM_DB_TIMEOUT_VF\t\t0x3f\n#define QM_RAS_CE_ENABLE\t\t0x1000ec\n#define QM_RAS_FE_ENABLE\t\t0x1000f0\n#define QM_RAS_NFE_ENABLE\t\t0x1000f4\n#define QM_RAS_CE_THRESHOLD\t\t0x1000f8\n#define QM_RAS_CE_TIMES_PER_IRQ\t\t1\n#define QM_OOO_SHUTDOWN_SEL\t\t0x1040f8\n#define QM_ECC_MBIT\t\t\tBIT(2)\n#define QM_DB_TIMEOUT\t\t\tBIT(10)\n#define QM_OF_FIFO_OF\t\t\tBIT(11)\n\n#define QM_RESET_WAIT_TIMEOUT\t\t400\n#define QM_PEH_VENDOR_ID\t\t0x1000d8\n#define ACC_VENDOR_ID_VALUE\t\t0x5a5a\n#define QM_PEH_DFX_INFO0\t\t0x1000fc\n#define QM_PEH_DFX_INFO1\t\t0x100100\n#define QM_PEH_DFX_MASK\t\t\t(BIT(0) | BIT(2))\n#define QM_PEH_MSI_FINISH_MASK\t\tGENMASK(19, 16)\n#define ACC_PEH_SRIOV_CTRL_VF_MSE_SHIFT\t3\n#define ACC_PEH_MSI_DISABLE\t\tGENMASK(31, 0)\n#define ACC_MASTER_GLOBAL_CTRL_SHUTDOWN\t0x1\n#define ACC_MASTER_TRANS_RETURN_RW\t3\n#define ACC_MASTER_TRANS_RETURN\t\t0x300150\n#define ACC_MASTER_GLOBAL_CTRL\t\t0x300000\n#define ACC_AM_CFG_PORT_WR_EN\t\t0x30001c\n#define QM_RAS_NFE_MBIT_DISABLE\t\t~QM_ECC_MBIT\n#define ACC_AM_ROB_ECC_INT_STS\t\t0x300104\n#define ACC_ROB_ECC_ERR_MULTPL\t\tBIT(1)\n#define QM_MSI_CAP_ENABLE\t\tBIT(16)\n\n \n#define QM_IFC_READY_STATUS\t\t0x100128\n#define QM_IFC_INT_SET_P\t\t0x100130\n#define QM_IFC_INT_CFG\t\t\t0x100134\n#define QM_IFC_INT_SOURCE_P\t\t0x100138\n#define QM_IFC_INT_SOURCE_V\t\t0x0020\n#define QM_IFC_INT_MASK\t\t\t0x0024\n#define QM_IFC_INT_STATUS\t\t0x0028\n#define QM_IFC_INT_SET_V\t\t0x002C\n#define QM_IFC_SEND_ALL_VFS\t\tGENMASK(6, 0)\n#define QM_IFC_INT_SOURCE_CLR\t\tGENMASK(63, 0)\n#define QM_IFC_INT_SOURCE_MASK\t\tBIT(0)\n#define QM_IFC_INT_DISABLE\t\tBIT(0)\n#define QM_IFC_INT_STATUS_MASK\t\tBIT(0)\n#define QM_IFC_INT_SET_MASK\t\tBIT(0)\n#define QM_WAIT_DST_ACK\t\t\t10\n#define QM_MAX_PF_WAIT_COUNT\t\t10\n#define QM_MAX_VF_WAIT_COUNT\t\t40\n#define QM_VF_RESET_WAIT_US            20000\n#define QM_VF_RESET_WAIT_CNT           3000\n#define QM_VF_RESET_WAIT_TIMEOUT_US    \\\n\t(QM_VF_RESET_WAIT_US * QM_VF_RESET_WAIT_CNT)\n\n#define POLL_PERIOD\t\t\t10\n#define POLL_TIMEOUT\t\t\t1000\n#define WAIT_PERIOD_US_MAX\t\t200\n#define WAIT_PERIOD_US_MIN\t\t100\n#define MAX_WAIT_COUNTS\t\t\t1000\n#define QM_CACHE_WB_START\t\t0x204\n#define QM_CACHE_WB_DONE\t\t0x208\n#define QM_FUNC_CAPS_REG\t\t0x3100\n#define QM_CAPBILITY_VERSION\t\tGENMASK(7, 0)\n\n#define PCI_BAR_2\t\t\t2\n#define PCI_BAR_4\t\t\t4\n#define QMC_ALIGN(sz)\t\t\tALIGN(sz, 32)\n\n#define QM_DBG_READ_LEN\t\t256\n#define QM_PCI_COMMAND_INVALID\t\t~0\n#define QM_RESET_STOP_TX_OFFSET\t\t1\n#define QM_RESET_STOP_RX_OFFSET\t\t2\n\n#define WAIT_PERIOD\t\t\t20\n#define REMOVE_WAIT_DELAY\t\t10\n\n#define QM_QOS_PARAM_NUM\t\t2\n#define QM_QOS_MAX_VAL\t\t\t1000\n#define QM_QOS_RATE\t\t\t100\n#define QM_QOS_EXPAND_RATE\t\t1000\n#define QM_SHAPER_CIR_B_MASK\t\tGENMASK(7, 0)\n#define QM_SHAPER_CIR_U_MASK\t\tGENMASK(10, 8)\n#define QM_SHAPER_CIR_S_MASK\t\tGENMASK(14, 11)\n#define QM_SHAPER_FACTOR_CIR_U_SHIFT\t8\n#define QM_SHAPER_FACTOR_CIR_S_SHIFT\t11\n#define QM_SHAPER_FACTOR_CBS_B_SHIFT\t15\n#define QM_SHAPER_FACTOR_CBS_S_SHIFT\t19\n#define QM_SHAPER_CBS_B\t\t\t1\n#define QM_SHAPER_VFT_OFFSET\t\t6\n#define QM_QOS_MIN_ERROR_RATE\t\t5\n#define QM_SHAPER_MIN_CBS_S\t\t8\n#define QM_QOS_TICK\t\t\t0x300U\n#define QM_QOS_DIVISOR_CLK\t\t0x1f40U\n#define QM_QOS_MAX_CIR_B\t\t200\n#define QM_QOS_MIN_CIR_B\t\t100\n#define QM_QOS_MAX_CIR_U\t\t6\n#define QM_AUTOSUSPEND_DELAY\t\t3000\n\n#define QM_DEV_ALG_MAX_LEN\t\t256\n\n#define QM_MK_CQC_DW3_V1(hop_num, pg_sz, buf_sz, cqe_sz) \\\n\t(((hop_num) << QM_CQ_HOP_NUM_SHIFT) | \\\n\t((pg_sz) << QM_CQ_PAGE_SIZE_SHIFT) | \\\n\t((buf_sz) << QM_CQ_BUF_SIZE_SHIFT) | \\\n\t((cqe_sz) << QM_CQ_CQE_SIZE_SHIFT))\n\n#define QM_MK_CQC_DW3_V2(cqe_sz, cq_depth) \\\n\t((((u32)cq_depth) - 1) | ((cqe_sz) << QM_CQ_CQE_SIZE_SHIFT))\n\n#define QM_MK_SQC_W13(priority, orders, alg_type) \\\n\t(((priority) << QM_SQ_PRIORITY_SHIFT) | \\\n\t((orders) << QM_SQ_ORDERS_SHIFT) | \\\n\t(((alg_type) & QM_SQ_TYPE_MASK) << QM_SQ_TYPE_SHIFT))\n\n#define QM_MK_SQC_DW3_V1(hop_num, pg_sz, buf_sz, sqe_sz) \\\n\t(((hop_num) << QM_SQ_HOP_NUM_SHIFT) | \\\n\t((pg_sz) << QM_SQ_PAGE_SIZE_SHIFT) | \\\n\t((buf_sz) << QM_SQ_BUF_SIZE_SHIFT) | \\\n\t((u32)ilog2(sqe_sz) << QM_SQ_SQE_SIZE_SHIFT))\n\n#define QM_MK_SQC_DW3_V2(sqe_sz, sq_depth) \\\n\t((((u32)sq_depth) - 1) | ((u32)ilog2(sqe_sz) << QM_SQ_SQE_SIZE_SHIFT))\n\n#define INIT_QC_COMMON(qc, base, pasid) do {\t\t\t\\\n\t(qc)->head = 0;\t\t\t\t\t\t\\\n\t(qc)->tail = 0;\t\t\t\t\t\t\\\n\t(qc)->base_l = cpu_to_le32(lower_32_bits(base));\t\\\n\t(qc)->base_h = cpu_to_le32(upper_32_bits(base));\t\\\n\t(qc)->dw3 = 0;\t\t\t\t\t\t\\\n\t(qc)->w8 = 0;\t\t\t\t\t\t\\\n\t(qc)->rsvd0 = 0;\t\t\t\t\t\\\n\t(qc)->pasid = cpu_to_le16(pasid);\t\t\t\\\n\t(qc)->w11 = 0;\t\t\t\t\t\t\\\n\t(qc)->rsvd1 = 0;\t\t\t\t\t\\\n} while (0)\n\nenum vft_type {\n\tSQC_VFT = 0,\n\tCQC_VFT,\n\tSHAPER_VFT,\n};\n\nenum acc_err_result {\n\tACC_ERR_NONE,\n\tACC_ERR_NEED_RESET,\n\tACC_ERR_RECOVERED,\n};\n\nenum qm_alg_type {\n\tALG_TYPE_0,\n\tALG_TYPE_1,\n};\n\nenum qm_mb_cmd {\n\tQM_PF_FLR_PREPARE = 0x01,\n\tQM_PF_SRST_PREPARE,\n\tQM_PF_RESET_DONE,\n\tQM_VF_PREPARE_DONE,\n\tQM_VF_PREPARE_FAIL,\n\tQM_VF_START_DONE,\n\tQM_VF_START_FAIL,\n\tQM_PF_SET_QOS,\n\tQM_VF_GET_QOS,\n};\n\nenum qm_basic_type {\n\tQM_TOTAL_QP_NUM_CAP = 0x0,\n\tQM_FUNC_MAX_QP_CAP,\n\tQM_XEQ_DEPTH_CAP,\n\tQM_QP_DEPTH_CAP,\n\tQM_EQ_IRQ_TYPE_CAP,\n\tQM_AEQ_IRQ_TYPE_CAP,\n\tQM_ABN_IRQ_TYPE_CAP,\n\tQM_PF2VF_IRQ_TYPE_CAP,\n\tQM_PF_IRQ_NUM_CAP,\n\tQM_VF_IRQ_NUM_CAP,\n};\n\nenum qm_pre_store_cap_idx {\n\tQM_EQ_IRQ_TYPE_CAP_IDX = 0x0,\n\tQM_AEQ_IRQ_TYPE_CAP_IDX,\n\tQM_ABN_IRQ_TYPE_CAP_IDX,\n\tQM_PF2VF_IRQ_TYPE_CAP_IDX,\n};\n\nstatic const struct hisi_qm_cap_info qm_cap_info_comm[] = {\n\t{QM_SUPPORT_DB_ISOLATION, 0x30,   0, BIT(0),  0x0, 0x0, 0x0},\n\t{QM_SUPPORT_FUNC_QOS,     0x3100, 0, BIT(8),  0x0, 0x0, 0x1},\n\t{QM_SUPPORT_STOP_QP,      0x3100, 0, BIT(9),  0x0, 0x0, 0x1},\n\t{QM_SUPPORT_MB_COMMAND,   0x3100, 0, BIT(11), 0x0, 0x0, 0x1},\n\t{QM_SUPPORT_SVA_PREFETCH, 0x3100, 0, BIT(14), 0x0, 0x0, 0x1},\n};\n\nstatic const struct hisi_qm_cap_info qm_cap_info_pf[] = {\n\t{QM_SUPPORT_RPM, 0x3100, 0, BIT(13), 0x0, 0x0, 0x1},\n};\n\nstatic const struct hisi_qm_cap_info qm_cap_info_vf[] = {\n\t{QM_SUPPORT_RPM, 0x3100, 0, BIT(12), 0x0, 0x0, 0x0},\n};\n\nstatic const struct hisi_qm_cap_info qm_basic_info[] = {\n\t{QM_TOTAL_QP_NUM_CAP,   0x100158, 0,  GENMASK(10, 0), 0x1000,    0x400,     0x400},\n\t{QM_FUNC_MAX_QP_CAP,    0x100158, 11, GENMASK(10, 0), 0x1000,    0x400,     0x400},\n\t{QM_XEQ_DEPTH_CAP,      0x3104,   0,  GENMASK(31, 0), 0x800,     0x4000800, 0x4000800},\n\t{QM_QP_DEPTH_CAP,       0x3108,   0,  GENMASK(31, 0), 0x4000400, 0x4000400, 0x4000400},\n\t{QM_EQ_IRQ_TYPE_CAP,    0x310c,   0,  GENMASK(31, 0), 0x10000,   0x10000,   0x10000},\n\t{QM_AEQ_IRQ_TYPE_CAP,   0x3110,   0,  GENMASK(31, 0), 0x0,       0x10001,   0x10001},\n\t{QM_ABN_IRQ_TYPE_CAP,   0x3114,   0,  GENMASK(31, 0), 0x0,       0x10003,   0x10003},\n\t{QM_PF2VF_IRQ_TYPE_CAP, 0x3118,   0,  GENMASK(31, 0), 0x0,       0x0,       0x10002},\n\t{QM_PF_IRQ_NUM_CAP,     0x311c,   16, GENMASK(15, 0), 0x1,       0x4,       0x4},\n\t{QM_VF_IRQ_NUM_CAP,     0x311c,   0,  GENMASK(15, 0), 0x1,       0x2,       0x3},\n};\n\nstatic const u32 qm_pre_store_caps[] = {\n\tQM_EQ_IRQ_TYPE_CAP,\n\tQM_AEQ_IRQ_TYPE_CAP,\n\tQM_ABN_IRQ_TYPE_CAP,\n\tQM_PF2VF_IRQ_TYPE_CAP,\n};\n\nstruct qm_mailbox {\n\t__le16 w0;\n\t__le16 queue_num;\n\t__le32 base_l;\n\t__le32 base_h;\n\t__le32 rsvd;\n};\n\nstruct qm_doorbell {\n\t__le16 queue_num;\n\t__le16 cmd;\n\t__le16 index;\n\t__le16 priority;\n};\n\nstruct hisi_qm_resource {\n\tstruct hisi_qm *qm;\n\tint distance;\n\tstruct list_head list;\n};\n\n \nstruct qm_hw_err {\n\tstruct list_head list;\n\tunsigned long long timestamp;\n};\n\nstruct hisi_qm_hw_ops {\n\tint (*get_vft)(struct hisi_qm *qm, u32 *base, u32 *number);\n\tvoid (*qm_db)(struct hisi_qm *qm, u16 qn,\n\t\t      u8 cmd, u16 index, u8 priority);\n\tint (*debug_init)(struct hisi_qm *qm);\n\tvoid (*hw_error_init)(struct hisi_qm *qm);\n\tvoid (*hw_error_uninit)(struct hisi_qm *qm);\n\tenum acc_err_result (*hw_error_handle)(struct hisi_qm *qm);\n\tint (*set_msi)(struct hisi_qm *qm, bool set);\n};\n\nstruct hisi_qm_hw_error {\n\tu32 int_msk;\n\tconst char *msg;\n};\n\nstatic const struct hisi_qm_hw_error qm_hw_error[] = {\n\t{ .int_msk = BIT(0), .msg = \"qm_axi_rresp\" },\n\t{ .int_msk = BIT(1), .msg = \"qm_axi_bresp\" },\n\t{ .int_msk = BIT(2), .msg = \"qm_ecc_mbit\" },\n\t{ .int_msk = BIT(3), .msg = \"qm_ecc_1bit\" },\n\t{ .int_msk = BIT(4), .msg = \"qm_acc_get_task_timeout\" },\n\t{ .int_msk = BIT(5), .msg = \"qm_acc_do_task_timeout\" },\n\t{ .int_msk = BIT(6), .msg = \"qm_acc_wb_not_ready_timeout\" },\n\t{ .int_msk = BIT(7), .msg = \"qm_sq_cq_vf_invalid\" },\n\t{ .int_msk = BIT(8), .msg = \"qm_cq_vf_invalid\" },\n\t{ .int_msk = BIT(9), .msg = \"qm_sq_vf_invalid\" },\n\t{ .int_msk = BIT(10), .msg = \"qm_db_timeout\" },\n\t{ .int_msk = BIT(11), .msg = \"qm_of_fifo_of\" },\n\t{ .int_msk = BIT(12), .msg = \"qm_db_random_invalid\" },\n\t{ .int_msk = BIT(13), .msg = \"qm_mailbox_timeout\" },\n\t{ .int_msk = BIT(14), .msg = \"qm_flr_timeout\" },\n\t{   }\n};\n\nstatic const char * const qm_db_timeout[] = {\n\t\"sq\", \"cq\", \"eq\", \"aeq\",\n};\n\nstatic const char * const qm_fifo_overflow[] = {\n\t\"cq\", \"eq\", \"aeq\",\n};\n\nstatic const char * const qp_s[] = {\n\t\"none\", \"init\", \"start\", \"stop\", \"close\",\n};\n\nstruct qm_typical_qos_table {\n\tu32 start;\n\tu32 end;\n\tu32 val;\n};\n\n \nstatic struct qm_typical_qos_table shaper_cir_s[] = {\n\t{100, 100, 4},\n\t{200, 200, 3},\n\t{300, 500, 2},\n\t{600, 1000, 1},\n\t{1100, 100000, 0},\n};\n\nstatic struct qm_typical_qos_table shaper_cbs_s[] = {\n\t{100, 200, 9},\n\t{300, 500, 11},\n\t{600, 1000, 12},\n\t{1100, 10000, 16},\n\t{10100, 25000, 17},\n\t{25100, 50000, 18},\n\t{50100, 100000, 19}\n};\n\nstatic void qm_irqs_unregister(struct hisi_qm *qm);\n\nstatic bool qm_avail_state(struct hisi_qm *qm, enum qm_state new)\n{\n\tenum qm_state curr = atomic_read(&qm->status.flags);\n\tbool avail = false;\n\n\tswitch (curr) {\n\tcase QM_INIT:\n\t\tif (new == QM_START || new == QM_CLOSE)\n\t\t\tavail = true;\n\t\tbreak;\n\tcase QM_START:\n\t\tif (new == QM_STOP)\n\t\t\tavail = true;\n\t\tbreak;\n\tcase QM_STOP:\n\t\tif (new == QM_CLOSE || new == QM_START)\n\t\t\tavail = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_dbg(&qm->pdev->dev, \"change qm state from %s to %s\\n\",\n\t\tqm_s[curr], qm_s[new]);\n\n\tif (!avail)\n\t\tdev_warn(&qm->pdev->dev, \"Can not change qm state from %s to %s\\n\",\n\t\t\t qm_s[curr], qm_s[new]);\n\n\treturn avail;\n}\n\nstatic bool qm_qp_avail_state(struct hisi_qm *qm, struct hisi_qp *qp,\n\t\t\t      enum qp_state new)\n{\n\tenum qm_state qm_curr = atomic_read(&qm->status.flags);\n\tenum qp_state qp_curr = 0;\n\tbool avail = false;\n\n\tif (qp)\n\t\tqp_curr = atomic_read(&qp->qp_status.flags);\n\n\tswitch (new) {\n\tcase QP_INIT:\n\t\tif (qm_curr == QM_START || qm_curr == QM_INIT)\n\t\t\tavail = true;\n\t\tbreak;\n\tcase QP_START:\n\t\tif ((qm_curr == QM_START && qp_curr == QP_INIT) ||\n\t\t    (qm_curr == QM_START && qp_curr == QP_STOP))\n\t\t\tavail = true;\n\t\tbreak;\n\tcase QP_STOP:\n\t\tif ((qm_curr == QM_START && qp_curr == QP_START) ||\n\t\t    (qp_curr == QP_INIT))\n\t\t\tavail = true;\n\t\tbreak;\n\tcase QP_CLOSE:\n\t\tif ((qm_curr == QM_START && qp_curr == QP_INIT) ||\n\t\t    (qm_curr == QM_START && qp_curr == QP_STOP) ||\n\t\t    (qm_curr == QM_STOP && qp_curr == QP_STOP)  ||\n\t\t    (qm_curr == QM_STOP && qp_curr == QP_INIT))\n\t\t\tavail = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_dbg(&qm->pdev->dev, \"change qp state from %s to %s in QM %s\\n\",\n\t\tqp_s[qp_curr], qp_s[new], qm_s[qm_curr]);\n\n\tif (!avail)\n\t\tdev_warn(&qm->pdev->dev,\n\t\t\t \"Can not change qp state from %s to %s in QM %s\\n\",\n\t\t\t qp_s[qp_curr], qp_s[new], qm_s[qm_curr]);\n\n\treturn avail;\n}\n\nstatic u32 qm_get_hw_error_status(struct hisi_qm *qm)\n{\n\treturn readl(qm->io_base + QM_ABNORMAL_INT_STATUS);\n}\n\nstatic u32 qm_get_dev_err_status(struct hisi_qm *qm)\n{\n\treturn qm->err_ini->get_dev_hw_err_status(qm);\n}\n\n \nstatic bool qm_check_dev_error(struct hisi_qm *qm)\n{\n\tu32 val, dev_val;\n\n\tif (qm->fun_type == QM_HW_VF)\n\t\treturn false;\n\n\tval = qm_get_hw_error_status(qm) & qm->err_info.qm_shutdown_mask;\n\tdev_val = qm_get_dev_err_status(qm) & qm->err_info.dev_shutdown_mask;\n\n\treturn val || dev_val;\n}\n\nstatic int qm_wait_reset_finish(struct hisi_qm *qm)\n{\n\tint delay = 0;\n\n\t \n\twhile (test_and_set_bit(QM_RESETTING, &qm->misc_ctl)) {\n\t\tmsleep(++delay);\n\t\tif (delay > QM_RESET_WAIT_TIMEOUT)\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int qm_reset_prepare_ready(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tstruct hisi_qm *pf_qm = pci_get_drvdata(pci_physfn(pdev));\n\n\t \n\tif (qm->ver < QM_HW_V3)\n\t\treturn qm_wait_reset_finish(pf_qm);\n\n\treturn qm_wait_reset_finish(qm);\n}\n\nstatic void qm_reset_bit_clear(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tstruct hisi_qm *pf_qm = pci_get_drvdata(pci_physfn(pdev));\n\n\tif (qm->ver < QM_HW_V3)\n\t\tclear_bit(QM_RESETTING, &pf_qm->misc_ctl);\n\n\tclear_bit(QM_RESETTING, &qm->misc_ctl);\n}\n\nstatic void qm_mb_pre_init(struct qm_mailbox *mailbox, u8 cmd,\n\t\t\t   u64 base, u16 queue, bool op)\n{\n\tmailbox->w0 = cpu_to_le16((cmd) |\n\t\t((op) ? 0x1 << QM_MB_OP_SHIFT : 0) |\n\t\t(0x1 << QM_MB_BUSY_SHIFT));\n\tmailbox->queue_num = cpu_to_le16(queue);\n\tmailbox->base_l = cpu_to_le32(lower_32_bits(base));\n\tmailbox->base_h = cpu_to_le32(upper_32_bits(base));\n\tmailbox->rsvd = 0;\n}\n\n \nint hisi_qm_wait_mb_ready(struct hisi_qm *qm)\n{\n\tu32 val;\n\n\treturn readl_relaxed_poll_timeout(qm->io_base + QM_MB_CMD_SEND_BASE,\n\t\t\t\t\t  val, !((val >> QM_MB_BUSY_SHIFT) &\n\t\t\t\t\t  0x1), POLL_PERIOD, POLL_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_wait_mb_ready);\n\n \nstatic void qm_mb_write(struct hisi_qm *qm, const void *src)\n{\n\tvoid __iomem *fun_base = qm->io_base + QM_MB_CMD_SEND_BASE;\n\n#if IS_ENABLED(CONFIG_ARM64)\n\tunsigned long tmp0 = 0, tmp1 = 0;\n#endif\n\n\tif (!IS_ENABLED(CONFIG_ARM64)) {\n\t\tmemcpy_toio(fun_base, src, 16);\n\t\tdma_wmb();\n\t\treturn;\n\t}\n\n#if IS_ENABLED(CONFIG_ARM64)\n\tasm volatile(\"ldp %0, %1, %3\\n\"\n\t\t     \"stp %0, %1, %2\\n\"\n\t\t     \"dmb oshst\\n\"\n\t\t     : \"=&r\" (tmp0),\n\t\t       \"=&r\" (tmp1),\n\t\t       \"+Q\" (*((char __iomem *)fun_base))\n\t\t     : \"Q\" (*((char *)src))\n\t\t     : \"memory\");\n#endif\n}\n\nstatic int qm_mb_nolock(struct hisi_qm *qm, struct qm_mailbox *mailbox)\n{\n\tint ret;\n\tu32 val;\n\n\tif (unlikely(hisi_qm_wait_mb_ready(qm))) {\n\t\tdev_err(&qm->pdev->dev, \"QM mailbox is busy to start!\\n\");\n\t\tret = -EBUSY;\n\t\tgoto mb_busy;\n\t}\n\n\tqm_mb_write(qm, mailbox);\n\n\tif (unlikely(hisi_qm_wait_mb_ready(qm))) {\n\t\tdev_err(&qm->pdev->dev, \"QM mailbox operation timeout!\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto mb_busy;\n\t}\n\n\tval = readl(qm->io_base + QM_MB_CMD_SEND_BASE);\n\tif (val & QM_MB_STATUS_MASK) {\n\t\tdev_err(&qm->pdev->dev, \"QM mailbox operation failed!\\n\");\n\t\tret = -EIO;\n\t\tgoto mb_busy;\n\t}\n\n\treturn 0;\n\nmb_busy:\n\tatomic64_inc(&qm->debug.dfx.mb_err_cnt);\n\treturn ret;\n}\n\nint hisi_qm_mb(struct hisi_qm *qm, u8 cmd, dma_addr_t dma_addr, u16 queue,\n\t       bool op)\n{\n\tstruct qm_mailbox mailbox;\n\tint ret;\n\n\tdev_dbg(&qm->pdev->dev, \"QM mailbox request to q%u: %u-%llx\\n\",\n\t\tqueue, cmd, (unsigned long long)dma_addr);\n\n\tqm_mb_pre_init(&mailbox, cmd, dma_addr, queue, op);\n\n\tmutex_lock(&qm->mailbox_lock);\n\tret = qm_mb_nolock(qm, &mailbox);\n\tmutex_unlock(&qm->mailbox_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_mb);\n\nstatic void qm_db_v1(struct hisi_qm *qm, u16 qn, u8 cmd, u16 index, u8 priority)\n{\n\tu64 doorbell;\n\n\tdoorbell = qn | ((u64)cmd << QM_DB_CMD_SHIFT_V1) |\n\t\t   ((u64)index << QM_DB_INDEX_SHIFT_V1)  |\n\t\t   ((u64)priority << QM_DB_PRIORITY_SHIFT_V1);\n\n\twriteq(doorbell, qm->io_base + QM_DOORBELL_BASE_V1);\n}\n\nstatic void qm_db_v2(struct hisi_qm *qm, u16 qn, u8 cmd, u16 index, u8 priority)\n{\n\tvoid __iomem *io_base = qm->io_base;\n\tu16 randata = 0;\n\tu64 doorbell;\n\n\tif (cmd == QM_DOORBELL_CMD_SQ || cmd == QM_DOORBELL_CMD_CQ)\n\t\tio_base = qm->db_io_base + (u64)qn * qm->db_interval +\n\t\t\t  QM_DOORBELL_SQ_CQ_BASE_V2;\n\telse\n\t\tio_base += QM_DOORBELL_EQ_AEQ_BASE_V2;\n\n\tdoorbell = qn | ((u64)cmd << QM_DB_CMD_SHIFT_V2) |\n\t\t   ((u64)randata << QM_DB_RAND_SHIFT_V2) |\n\t\t   ((u64)index << QM_DB_INDEX_SHIFT_V2) |\n\t\t   ((u64)priority << QM_DB_PRIORITY_SHIFT_V2);\n\n\twriteq(doorbell, io_base);\n}\n\nstatic void qm_db(struct hisi_qm *qm, u16 qn, u8 cmd, u16 index, u8 priority)\n{\n\tdev_dbg(&qm->pdev->dev, \"QM doorbell request: qn=%u, cmd=%u, index=%u\\n\",\n\t\tqn, cmd, index);\n\n\tqm->ops->qm_db(qm, qn, cmd, index, priority);\n}\n\nstatic void qm_disable_clock_gate(struct hisi_qm *qm)\n{\n\tu32 val;\n\n\t \n\tif (qm->ver < QM_HW_V3)\n\t\treturn;\n\n\tval = readl(qm->io_base + QM_PM_CTRL);\n\tval |= QM_IDLE_DISABLE;\n\twritel(val, qm->io_base +  QM_PM_CTRL);\n}\n\nstatic int qm_dev_mem_reset(struct hisi_qm *qm)\n{\n\tu32 val;\n\n\twritel(0x1, qm->io_base + QM_MEM_START_INIT);\n\treturn readl_relaxed_poll_timeout(qm->io_base + QM_MEM_INIT_DONE, val,\n\t\t\t\t\t  val & BIT(0), POLL_PERIOD,\n\t\t\t\t\t  POLL_TIMEOUT);\n}\n\n \nu32 hisi_qm_get_hw_info(struct hisi_qm *qm,\n\t\t\tconst struct hisi_qm_cap_info *info_table,\n\t\t\tu32 index, bool is_read)\n{\n\tu32 val;\n\n\tswitch (qm->ver) {\n\tcase QM_HW_V1:\n\t\treturn info_table[index].v1_val;\n\tcase QM_HW_V2:\n\t\treturn info_table[index].v2_val;\n\tdefault:\n\t\tif (!is_read)\n\t\t\treturn info_table[index].v3_val;\n\n\t\tval = readl(qm->io_base + info_table[index].offset);\n\t\treturn (val >> info_table[index].shift) & info_table[index].mask;\n\t}\n}\nEXPORT_SYMBOL_GPL(hisi_qm_get_hw_info);\n\nstatic void qm_get_xqc_depth(struct hisi_qm *qm, u16 *low_bits,\n\t\t\t     u16 *high_bits, enum qm_basic_type type)\n{\n\tu32 depth;\n\n\tdepth = hisi_qm_get_hw_info(qm, qm_basic_info, type, qm->cap_ver);\n\t*low_bits = depth & QM_XQ_DEPTH_MASK;\n\t*high_bits = (depth >> QM_XQ_DEPTH_SHIFT) & QM_XQ_DEPTH_MASK;\n}\n\nint hisi_qm_set_algs(struct hisi_qm *qm, u64 alg_msk, const struct qm_dev_alg *dev_algs,\n\t\t     u32 dev_algs_size)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tchar *algs, *ptr;\n\tint i;\n\n\tif (!qm->uacce)\n\t\treturn 0;\n\n\tif (dev_algs_size >= QM_DEV_ALG_MAX_LEN) {\n\t\tdev_err(dev, \"algs size %u is equal or larger than %d.\\n\",\n\t\t\tdev_algs_size, QM_DEV_ALG_MAX_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\talgs = devm_kzalloc(dev, QM_DEV_ALG_MAX_LEN * sizeof(char), GFP_KERNEL);\n\tif (!algs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < dev_algs_size; i++)\n\t\tif (alg_msk & dev_algs[i].alg_msk)\n\t\t\tstrcat(algs, dev_algs[i].alg);\n\n\tptr = strrchr(algs, '\\n');\n\tif (ptr) {\n\t\t*ptr = '\\0';\n\t\tqm->uacce->algs = algs;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_set_algs);\n\nstatic u32 qm_get_irq_num(struct hisi_qm *qm)\n{\n\tif (qm->fun_type == QM_HW_PF)\n\t\treturn hisi_qm_get_hw_info(qm, qm_basic_info, QM_PF_IRQ_NUM_CAP, qm->cap_ver);\n\n\treturn hisi_qm_get_hw_info(qm, qm_basic_info, QM_VF_IRQ_NUM_CAP, qm->cap_ver);\n}\n\nstatic int qm_pm_get_sync(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tint ret;\n\n\tif (!test_bit(QM_SUPPORT_RPM, &qm->caps))\n\t\treturn 0;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get_sync(%d).\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void qm_pm_put_sync(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\n\tif (!test_bit(QM_SUPPORT_RPM, &qm->caps))\n\t\treturn;\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n}\n\nstatic void qm_cq_head_update(struct hisi_qp *qp)\n{\n\tif (qp->qp_status.cq_head == qp->cq_depth - 1) {\n\t\tqp->qp_status.cqc_phase = !qp->qp_status.cqc_phase;\n\t\tqp->qp_status.cq_head = 0;\n\t} else {\n\t\tqp->qp_status.cq_head++;\n\t}\n}\n\nstatic void qm_poll_req_cb(struct hisi_qp *qp)\n{\n\tstruct qm_cqe *cqe = qp->cqe + qp->qp_status.cq_head;\n\tstruct hisi_qm *qm = qp->qm;\n\n\twhile (QM_CQE_PHASE(cqe) == qp->qp_status.cqc_phase) {\n\t\tdma_rmb();\n\t\tqp->req_cb(qp, qp->sqe + qm->sqe_size *\n\t\t\t   le16_to_cpu(cqe->sq_head));\n\t\tqm_cq_head_update(qp);\n\t\tcqe = qp->cqe + qp->qp_status.cq_head;\n\t\tqm_db(qm, qp->qp_id, QM_DOORBELL_CMD_CQ,\n\t\t      qp->qp_status.cq_head, 0);\n\t\tatomic_dec(&qp->qp_status.used);\n\n\t\tcond_resched();\n\t}\n\n\t \n\tqm_db(qm, qp->qp_id, QM_DOORBELL_CMD_CQ, qp->qp_status.cq_head, 1);\n}\n\nstatic void qm_work_process(struct work_struct *work)\n{\n\tstruct hisi_qm_poll_data *poll_data =\n\t\tcontainer_of(work, struct hisi_qm_poll_data, work);\n\tstruct hisi_qm *qm = poll_data->qm;\n\tu16 eqe_num = poll_data->eqe_num;\n\tstruct hisi_qp *qp;\n\tint i;\n\n\tfor (i = eqe_num - 1; i >= 0; i--) {\n\t\tqp = &qm->qp_array[poll_data->qp_finish_id[i]];\n\t\tif (unlikely(atomic_read(&qp->qp_status.flags) == QP_STOP))\n\t\t\tcontinue;\n\n\t\tif (qp->event_cb) {\n\t\t\tqp->event_cb(qp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (likely(qp->req_cb))\n\t\t\tqm_poll_req_cb(qp);\n\t}\n}\n\nstatic void qm_get_complete_eqe_num(struct hisi_qm *qm)\n{\n\tstruct qm_eqe *eqe = qm->eqe + qm->status.eq_head;\n\tstruct hisi_qm_poll_data *poll_data = NULL;\n\tu16 eq_depth = qm->eq_depth;\n\tu16 cqn, eqe_num = 0;\n\n\tif (QM_EQE_PHASE(eqe) != qm->status.eqc_phase) {\n\t\tatomic64_inc(&qm->debug.dfx.err_irq_cnt);\n\t\tqm_db(qm, 0, QM_DOORBELL_CMD_EQ, qm->status.eq_head, 0);\n\t\treturn;\n\t}\n\n\tcqn = le32_to_cpu(eqe->dw0) & QM_EQE_CQN_MASK;\n\tif (unlikely(cqn >= qm->qp_num))\n\t\treturn;\n\tpoll_data = &qm->poll_data[cqn];\n\n\twhile (QM_EQE_PHASE(eqe) == qm->status.eqc_phase) {\n\t\tcqn = le32_to_cpu(eqe->dw0) & QM_EQE_CQN_MASK;\n\t\tpoll_data->qp_finish_id[eqe_num] = cqn;\n\t\teqe_num++;\n\n\t\tif (qm->status.eq_head == eq_depth - 1) {\n\t\t\tqm->status.eqc_phase = !qm->status.eqc_phase;\n\t\t\teqe = qm->eqe;\n\t\t\tqm->status.eq_head = 0;\n\t\t} else {\n\t\t\teqe++;\n\t\t\tqm->status.eq_head++;\n\t\t}\n\n\t\tif (eqe_num == (eq_depth >> 1) - 1)\n\t\t\tbreak;\n\t}\n\n\tpoll_data->eqe_num = eqe_num;\n\tqueue_work(qm->wq, &poll_data->work);\n\tqm_db(qm, 0, QM_DOORBELL_CMD_EQ, qm->status.eq_head, 0);\n}\n\nstatic irqreturn_t qm_eq_irq(int irq, void *data)\n{\n\tstruct hisi_qm *qm = data;\n\n\t \n\tqm_get_complete_eqe_num(qm);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t qm_mb_cmd_irq(int irq, void *data)\n{\n\tstruct hisi_qm *qm = data;\n\tu32 val;\n\n\tval = readl(qm->io_base + QM_IFC_INT_STATUS);\n\tval &= QM_IFC_INT_STATUS_MASK;\n\tif (!val)\n\t\treturn IRQ_NONE;\n\n\tif (test_bit(QM_DRIVER_REMOVING, &qm->misc_ctl)) {\n\t\tdev_warn(&qm->pdev->dev, \"Driver is down, message cannot be processed!\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tschedule_work(&qm->cmd_process);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void qm_set_qp_disable(struct hisi_qp *qp, int offset)\n{\n\tu32 *addr;\n\n\tif (qp->is_in_kernel)\n\t\treturn;\n\n\taddr = (u32 *)(qp->qdma.va + qp->qdma.size) - offset;\n\t*addr = 1;\n\n\t \n\tsmp_wmb();\n}\n\nstatic void qm_disable_qp(struct hisi_qm *qm, u32 qp_id)\n{\n\tstruct hisi_qp *qp = &qm->qp_array[qp_id];\n\n\tqm_set_qp_disable(qp, QM_RESET_STOP_TX_OFFSET);\n\thisi_qm_stop_qp(qp);\n\tqm_set_qp_disable(qp, QM_RESET_STOP_RX_OFFSET);\n}\n\nstatic void qm_reset_function(struct hisi_qm *qm)\n{\n\tstruct hisi_qm *pf_qm = pci_get_drvdata(pci_physfn(qm->pdev));\n\tstruct device *dev = &qm->pdev->dev;\n\tint ret;\n\n\tif (qm_check_dev_error(pf_qm))\n\t\treturn;\n\n\tret = qm_reset_prepare_ready(qm);\n\tif (ret) {\n\t\tdev_err(dev, \"reset function not ready\\n\");\n\t\treturn;\n\t}\n\n\tret = hisi_qm_stop(qm, QM_DOWN);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to stop qm when reset function\\n\");\n\t\tgoto clear_bit;\n\t}\n\n\tret = hisi_qm_start(qm);\n\tif (ret)\n\t\tdev_err(dev, \"failed to start qm when reset function\\n\");\n\nclear_bit:\n\tqm_reset_bit_clear(qm);\n}\n\nstatic irqreturn_t qm_aeq_thread(int irq, void *data)\n{\n\tstruct hisi_qm *qm = data;\n\tstruct qm_aeqe *aeqe = qm->aeqe + qm->status.aeq_head;\n\tu16 aeq_depth = qm->aeq_depth;\n\tu32 type, qp_id;\n\n\tatomic64_inc(&qm->debug.dfx.aeq_irq_cnt);\n\n\twhile (QM_AEQE_PHASE(aeqe) == qm->status.aeqc_phase) {\n\t\ttype = le32_to_cpu(aeqe->dw0) >> QM_AEQE_TYPE_SHIFT;\n\t\tqp_id = le32_to_cpu(aeqe->dw0) & QM_AEQE_CQN_MASK;\n\n\t\tswitch (type) {\n\t\tcase QM_EQ_OVERFLOW:\n\t\t\tdev_err(&qm->pdev->dev, \"eq overflow, reset function\\n\");\n\t\t\tqm_reset_function(qm);\n\t\t\treturn IRQ_HANDLED;\n\t\tcase QM_CQ_OVERFLOW:\n\t\t\tdev_err(&qm->pdev->dev, \"cq overflow, stop qp(%u)\\n\",\n\t\t\t\tqp_id);\n\t\t\tfallthrough;\n\t\tcase QM_CQE_ERROR:\n\t\t\tqm_disable_qp(qm, qp_id);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&qm->pdev->dev, \"unknown error type %u\\n\",\n\t\t\t\ttype);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (qm->status.aeq_head == aeq_depth - 1) {\n\t\t\tqm->status.aeqc_phase = !qm->status.aeqc_phase;\n\t\t\taeqe = qm->aeqe;\n\t\t\tqm->status.aeq_head = 0;\n\t\t} else {\n\t\t\taeqe++;\n\t\t\tqm->status.aeq_head++;\n\t\t}\n\t}\n\n\tqm_db(qm, 0, QM_DOORBELL_CMD_AEQ, qm->status.aeq_head, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void qm_init_qp_status(struct hisi_qp *qp)\n{\n\tstruct hisi_qp_status *qp_status = &qp->qp_status;\n\n\tqp_status->sq_tail = 0;\n\tqp_status->cq_head = 0;\n\tqp_status->cqc_phase = true;\n\tatomic_set(&qp_status->used, 0);\n}\n\nstatic void qm_init_prefetch(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tu32 page_type = 0x0;\n\n\tif (!test_bit(QM_SUPPORT_SVA_PREFETCH, &qm->caps))\n\t\treturn;\n\n\tswitch (PAGE_SIZE) {\n\tcase SZ_4K:\n\t\tpage_type = 0x0;\n\t\tbreak;\n\tcase SZ_16K:\n\t\tpage_type = 0x1;\n\t\tbreak;\n\tcase SZ_64K:\n\t\tpage_type = 0x2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"system page size is not support: %lu, default set to 4KB\",\n\t\t\tPAGE_SIZE);\n\t}\n\n\twritel(page_type, qm->io_base + QM_PAGE_SIZE);\n}\n\n \nstatic u32 acc_shaper_para_calc(u64 cir_b, u64 cir_u, u64 cir_s)\n{\n\treturn ((cir_b * QM_QOS_DIVISOR_CLK) * (1 << cir_u)) /\n\t\t\t\t\t(QM_QOS_TICK * (1 << cir_s));\n}\n\nstatic u32 acc_shaper_calc_cbs_s(u32 ir)\n{\n\tint table_size = ARRAY_SIZE(shaper_cbs_s);\n\tint i;\n\n\tfor (i = 0; i < table_size; i++) {\n\t\tif (ir >= shaper_cbs_s[i].start && ir <= shaper_cbs_s[i].end)\n\t\t\treturn shaper_cbs_s[i].val;\n\t}\n\n\treturn QM_SHAPER_MIN_CBS_S;\n}\n\nstatic u32 acc_shaper_calc_cir_s(u32 ir)\n{\n\tint table_size = ARRAY_SIZE(shaper_cir_s);\n\tint i;\n\n\tfor (i = 0; i < table_size; i++) {\n\t\tif (ir >= shaper_cir_s[i].start && ir <= shaper_cir_s[i].end)\n\t\t\treturn shaper_cir_s[i].val;\n\t}\n\n\treturn 0;\n}\n\nstatic int qm_get_shaper_para(u32 ir, struct qm_shaper_factor *factor)\n{\n\tu32 cir_b, cir_u, cir_s, ir_calc;\n\tu32 error_rate;\n\n\tfactor->cbs_s = acc_shaper_calc_cbs_s(ir);\n\tcir_s = acc_shaper_calc_cir_s(ir);\n\n\tfor (cir_b = QM_QOS_MIN_CIR_B; cir_b <= QM_QOS_MAX_CIR_B; cir_b++) {\n\t\tfor (cir_u = 0; cir_u <= QM_QOS_MAX_CIR_U; cir_u++) {\n\t\t\tir_calc = acc_shaper_para_calc(cir_b, cir_u, cir_s);\n\n\t\t\terror_rate = QM_QOS_EXPAND_RATE * (u32)abs(ir_calc - ir) / ir;\n\t\t\tif (error_rate <= QM_QOS_MIN_ERROR_RATE) {\n\t\t\t\tfactor->cir_b = cir_b;\n\t\t\t\tfactor->cir_u = cir_u;\n\t\t\t\tfactor->cir_s = cir_s;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void qm_vft_data_cfg(struct hisi_qm *qm, enum vft_type type, u32 base,\n\t\t\t    u32 number, struct qm_shaper_factor *factor)\n{\n\tu64 tmp = 0;\n\n\tif (number > 0) {\n\t\tswitch (type) {\n\t\tcase SQC_VFT:\n\t\t\tif (qm->ver == QM_HW_V1) {\n\t\t\t\ttmp = QM_SQC_VFT_BUF_SIZE\t|\n\t\t\t\t      QM_SQC_VFT_SQC_SIZE\t|\n\t\t\t\t      QM_SQC_VFT_INDEX_NUMBER\t|\n\t\t\t\t      QM_SQC_VFT_VALID\t\t|\n\t\t\t\t      (u64)base << QM_SQC_VFT_START_SQN_SHIFT;\n\t\t\t} else {\n\t\t\t\ttmp = (u64)base << QM_SQC_VFT_START_SQN_SHIFT |\n\t\t\t\t      QM_SQC_VFT_VALID |\n\t\t\t\t      (u64)(number - 1) << QM_SQC_VFT_SQN_SHIFT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CQC_VFT:\n\t\t\tif (qm->ver == QM_HW_V1) {\n\t\t\t\ttmp = QM_CQC_VFT_BUF_SIZE\t|\n\t\t\t\t      QM_CQC_VFT_SQC_SIZE\t|\n\t\t\t\t      QM_CQC_VFT_INDEX_NUMBER\t|\n\t\t\t\t      QM_CQC_VFT_VALID;\n\t\t\t} else {\n\t\t\t\ttmp = QM_CQC_VFT_VALID;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SHAPER_VFT:\n\t\t\tif (factor) {\n\t\t\t\ttmp = factor->cir_b |\n\t\t\t\t(factor->cir_u << QM_SHAPER_FACTOR_CIR_U_SHIFT) |\n\t\t\t\t(factor->cir_s << QM_SHAPER_FACTOR_CIR_S_SHIFT) |\n\t\t\t\t(QM_SHAPER_CBS_B << QM_SHAPER_FACTOR_CBS_B_SHIFT) |\n\t\t\t\t(factor->cbs_s << QM_SHAPER_FACTOR_CBS_S_SHIFT);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twritel(lower_32_bits(tmp), qm->io_base + QM_VFT_CFG_DATA_L);\n\twritel(upper_32_bits(tmp), qm->io_base + QM_VFT_CFG_DATA_H);\n}\n\nstatic int qm_set_vft_common(struct hisi_qm *qm, enum vft_type type,\n\t\t\t     u32 fun_num, u32 base, u32 number)\n{\n\tstruct qm_shaper_factor *factor = NULL;\n\tunsigned int val;\n\tint ret;\n\n\tif (type == SHAPER_VFT && test_bit(QM_SUPPORT_FUNC_QOS, &qm->caps))\n\t\tfactor = &qm->factor[fun_num];\n\n\tret = readl_relaxed_poll_timeout(qm->io_base + QM_VFT_CFG_RDY, val,\n\t\t\t\t\t val & BIT(0), POLL_PERIOD,\n\t\t\t\t\t POLL_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(0x0, qm->io_base + QM_VFT_CFG_OP_WR);\n\twritel(type, qm->io_base + QM_VFT_CFG_TYPE);\n\tif (type == SHAPER_VFT)\n\t\tfun_num |= base << QM_SHAPER_VFT_OFFSET;\n\n\twritel(fun_num, qm->io_base + QM_VFT_CFG);\n\n\tqm_vft_data_cfg(qm, type, base, number, factor);\n\n\twritel(0x0, qm->io_base + QM_VFT_CFG_RDY);\n\twritel(0x1, qm->io_base + QM_VFT_CFG_OP_ENABLE);\n\n\treturn readl_relaxed_poll_timeout(qm->io_base + QM_VFT_CFG_RDY, val,\n\t\t\t\t\t  val & BIT(0), POLL_PERIOD,\n\t\t\t\t\t  POLL_TIMEOUT);\n}\n\nstatic int qm_shaper_init_vft(struct hisi_qm *qm, u32 fun_num)\n{\n\tu32 qos = qm->factor[fun_num].func_qos;\n\tint ret, i;\n\n\tret = qm_get_shaper_para(qos * QM_QOS_RATE, &qm->factor[fun_num]);\n\tif (ret) {\n\t\tdev_err(&qm->pdev->dev, \"failed to calculate shaper parameter!\\n\");\n\t\treturn ret;\n\t}\n\twritel(qm->type_rate, qm->io_base + QM_SHAPER_CFG);\n\tfor (i = ALG_TYPE_0; i <= ALG_TYPE_1; i++) {\n\t\t \n\t\tret = qm_set_vft_common(qm, SHAPER_VFT, fun_num, i, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int qm_set_sqc_cqc_vft(struct hisi_qm *qm, u32 fun_num, u32 base,\n\t\t\t      u32 number)\n{\n\tint ret, i;\n\n\tfor (i = SQC_VFT; i <= CQC_VFT; i++) {\n\t\tret = qm_set_vft_common(qm, i, fun_num, base, number);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (test_bit(QM_SUPPORT_FUNC_QOS, &qm->caps)) {\n\t\tret = qm_shaper_init_vft(qm, fun_num);\n\t\tif (ret)\n\t\t\tgoto back_sqc_cqc;\n\t}\n\n\treturn 0;\nback_sqc_cqc:\n\tfor (i = SQC_VFT; i <= CQC_VFT; i++)\n\t\tqm_set_vft_common(qm, i, fun_num, 0, 0);\n\n\treturn ret;\n}\n\nstatic int qm_get_vft_v2(struct hisi_qm *qm, u32 *base, u32 *number)\n{\n\tu64 sqc_vft;\n\tint ret;\n\n\tret = hisi_qm_mb(qm, QM_MB_CMD_SQC_VFT_V2, 0, 0, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tsqc_vft = readl(qm->io_base + QM_MB_CMD_DATA_ADDR_L) |\n\t\t  ((u64)readl(qm->io_base + QM_MB_CMD_DATA_ADDR_H) << 32);\n\t*base = QM_SQC_VFT_BASE_MASK_V2 & (sqc_vft >> QM_SQC_VFT_BASE_SHIFT_V2);\n\t*number = (QM_SQC_VFT_NUM_MASK_V2 &\n\t\t   (sqc_vft >> QM_SQC_VFT_NUM_SHIFT_V2)) + 1;\n\n\treturn 0;\n}\n\nvoid *hisi_qm_ctx_alloc(struct hisi_qm *qm, size_t ctx_size,\n\t\t\t  dma_addr_t *dma_addr)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tvoid *ctx_addr;\n\n\tctx_addr = kzalloc(ctx_size, GFP_KERNEL);\n\tif (!ctx_addr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t*dma_addr = dma_map_single(dev, ctx_addr, ctx_size, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, *dma_addr)) {\n\t\tdev_err(dev, \"DMA mapping error!\\n\");\n\t\tkfree(ctx_addr);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn ctx_addr;\n}\n\nvoid hisi_qm_ctx_free(struct hisi_qm *qm, size_t ctx_size,\n\t\t\tconst void *ctx_addr, dma_addr_t *dma_addr)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\n\tdma_unmap_single(dev, *dma_addr, ctx_size, DMA_FROM_DEVICE);\n\tkfree(ctx_addr);\n}\n\nstatic int qm_dump_sqc_raw(struct hisi_qm *qm, dma_addr_t dma_addr, u16 qp_id)\n{\n\treturn hisi_qm_mb(qm, QM_MB_CMD_SQC, dma_addr, qp_id, 1);\n}\n\nstatic int qm_dump_cqc_raw(struct hisi_qm *qm, dma_addr_t dma_addr, u16 qp_id)\n{\n\treturn hisi_qm_mb(qm, QM_MB_CMD_CQC, dma_addr, qp_id, 1);\n}\n\nstatic void qm_hw_error_init_v1(struct hisi_qm *qm)\n{\n\twritel(QM_ABNORMAL_INT_MASK_VALUE, qm->io_base + QM_ABNORMAL_INT_MASK);\n}\n\nstatic void qm_hw_error_cfg(struct hisi_qm *qm)\n{\n\tstruct hisi_qm_err_info *err_info = &qm->err_info;\n\n\tqm->error_mask = err_info->nfe | err_info->ce | err_info->fe;\n\t \n\twritel(qm->error_mask, qm->io_base + QM_ABNORMAL_INT_SOURCE);\n\n\t \n\twritel(err_info->ce, qm->io_base + QM_RAS_CE_ENABLE);\n\twritel(QM_RAS_CE_TIMES_PER_IRQ, qm->io_base + QM_RAS_CE_THRESHOLD);\n\twritel(err_info->nfe, qm->io_base + QM_RAS_NFE_ENABLE);\n\twritel(err_info->fe, qm->io_base + QM_RAS_FE_ENABLE);\n}\n\nstatic void qm_hw_error_init_v2(struct hisi_qm *qm)\n{\n\tu32 irq_unmask;\n\n\tqm_hw_error_cfg(qm);\n\n\tirq_unmask = ~qm->error_mask;\n\tirq_unmask &= readl(qm->io_base + QM_ABNORMAL_INT_MASK);\n\twritel(irq_unmask, qm->io_base + QM_ABNORMAL_INT_MASK);\n}\n\nstatic void qm_hw_error_uninit_v2(struct hisi_qm *qm)\n{\n\tu32 irq_mask = qm->error_mask;\n\n\tirq_mask |= readl(qm->io_base + QM_ABNORMAL_INT_MASK);\n\twritel(irq_mask, qm->io_base + QM_ABNORMAL_INT_MASK);\n}\n\nstatic void qm_hw_error_init_v3(struct hisi_qm *qm)\n{\n\tu32 irq_unmask;\n\n\tqm_hw_error_cfg(qm);\n\n\t \n\twritel(qm->err_info.qm_shutdown_mask, qm->io_base + QM_OOO_SHUTDOWN_SEL);\n\n\tirq_unmask = ~qm->error_mask;\n\tirq_unmask &= readl(qm->io_base + QM_ABNORMAL_INT_MASK);\n\twritel(irq_unmask, qm->io_base + QM_ABNORMAL_INT_MASK);\n}\n\nstatic void qm_hw_error_uninit_v3(struct hisi_qm *qm)\n{\n\tu32 irq_mask = qm->error_mask;\n\n\tirq_mask |= readl(qm->io_base + QM_ABNORMAL_INT_MASK);\n\twritel(irq_mask, qm->io_base + QM_ABNORMAL_INT_MASK);\n\n\t \n\twritel(0x0, qm->io_base + QM_OOO_SHUTDOWN_SEL);\n}\n\nstatic void qm_log_hw_error(struct hisi_qm *qm, u32 error_status)\n{\n\tconst struct hisi_qm_hw_error *err;\n\tstruct device *dev = &qm->pdev->dev;\n\tu32 reg_val, type, vf_num;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(qm_hw_error); i++) {\n\t\terr = &qm_hw_error[i];\n\t\tif (!(err->int_msk & error_status))\n\t\t\tcontinue;\n\n\t\tdev_err(dev, \"%s [error status=0x%x] found\\n\",\n\t\t\terr->msg, err->int_msk);\n\n\t\tif (err->int_msk & QM_DB_TIMEOUT) {\n\t\t\treg_val = readl(qm->io_base + QM_ABNORMAL_INF01);\n\t\t\ttype = (reg_val & QM_DB_TIMEOUT_TYPE) >>\n\t\t\t       QM_DB_TIMEOUT_TYPE_SHIFT;\n\t\t\tvf_num = reg_val & QM_DB_TIMEOUT_VF;\n\t\t\tdev_err(dev, \"qm %s doorbell timeout in function %u\\n\",\n\t\t\t\tqm_db_timeout[type], vf_num);\n\t\t} else if (err->int_msk & QM_OF_FIFO_OF) {\n\t\t\treg_val = readl(qm->io_base + QM_ABNORMAL_INF00);\n\t\t\ttype = (reg_val & QM_FIFO_OVERFLOW_TYPE) >>\n\t\t\t       QM_FIFO_OVERFLOW_TYPE_SHIFT;\n\t\t\tvf_num = reg_val & QM_FIFO_OVERFLOW_VF;\n\n\t\t\tif (type < ARRAY_SIZE(qm_fifo_overflow))\n\t\t\t\tdev_err(dev, \"qm %s fifo overflow in function %u\\n\",\n\t\t\t\t\tqm_fifo_overflow[type], vf_num);\n\t\t\telse\n\t\t\t\tdev_err(dev, \"unknown error type\\n\");\n\t\t}\n\t}\n}\n\nstatic enum acc_err_result qm_hw_error_handle_v2(struct hisi_qm *qm)\n{\n\tu32 error_status, tmp;\n\n\t \n\ttmp = readl(qm->io_base + QM_ABNORMAL_INT_STATUS);\n\terror_status = qm->error_mask & tmp;\n\n\tif (error_status) {\n\t\tif (error_status & QM_ECC_MBIT)\n\t\t\tqm->err_status.is_qm_ecc_mbit = true;\n\n\t\tqm_log_hw_error(qm, error_status);\n\t\tif (error_status & qm->err_info.qm_reset_mask)\n\t\t\treturn ACC_ERR_NEED_RESET;\n\n\t\twritel(error_status, qm->io_base + QM_ABNORMAL_INT_SOURCE);\n\t\twritel(qm->err_info.nfe, qm->io_base + QM_RAS_NFE_ENABLE);\n\t}\n\n\treturn ACC_ERR_RECOVERED;\n}\n\nstatic int qm_get_mb_cmd(struct hisi_qm *qm, u64 *msg, u16 fun_num)\n{\n\tstruct qm_mailbox mailbox;\n\tint ret;\n\n\tqm_mb_pre_init(&mailbox, QM_MB_CMD_DST, 0, fun_num, 0);\n\tmutex_lock(&qm->mailbox_lock);\n\tret = qm_mb_nolock(qm, &mailbox);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\t*msg = readl(qm->io_base + QM_MB_CMD_DATA_ADDR_L) |\n\t\t  ((u64)readl(qm->io_base + QM_MB_CMD_DATA_ADDR_H) << 32);\n\nerr_unlock:\n\tmutex_unlock(&qm->mailbox_lock);\n\treturn ret;\n}\n\nstatic void qm_clear_cmd_interrupt(struct hisi_qm *qm, u64 vf_mask)\n{\n\tu32 val;\n\n\tif (qm->fun_type == QM_HW_PF)\n\t\twriteq(vf_mask, qm->io_base + QM_IFC_INT_SOURCE_P);\n\n\tval = readl(qm->io_base + QM_IFC_INT_SOURCE_V);\n\tval |= QM_IFC_INT_SOURCE_MASK;\n\twritel(val, qm->io_base + QM_IFC_INT_SOURCE_V);\n}\n\nstatic void qm_handle_vf_msg(struct hisi_qm *qm, u32 vf_id)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tu32 cmd;\n\tu64 msg;\n\tint ret;\n\n\tret = qm_get_mb_cmd(qm, &msg, vf_id);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get msg from VF(%u)!\\n\", vf_id);\n\t\treturn;\n\t}\n\n\tcmd = msg & QM_MB_CMD_DATA_MASK;\n\tswitch (cmd) {\n\tcase QM_VF_PREPARE_FAIL:\n\t\tdev_err(dev, \"failed to stop VF(%u)!\\n\", vf_id);\n\t\tbreak;\n\tcase QM_VF_START_FAIL:\n\t\tdev_err(dev, \"failed to start VF(%u)!\\n\", vf_id);\n\t\tbreak;\n\tcase QM_VF_PREPARE_DONE:\n\tcase QM_VF_START_DONE:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported cmd %u sent by VF(%u)!\\n\", cmd, vf_id);\n\t\tbreak;\n\t}\n}\n\nstatic int qm_wait_vf_prepare_finish(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tu32 vfs_num = qm->vfs_num;\n\tint cnt = 0;\n\tint ret = 0;\n\tu64 val;\n\tu32 i;\n\n\tif (!qm->vfs_num || !test_bit(QM_SUPPORT_MB_COMMAND, &qm->caps))\n\t\treturn 0;\n\n\twhile (true) {\n\t\tval = readq(qm->io_base + QM_IFC_INT_SOURCE_P);\n\t\t \n\t\tif ((val & GENMASK(vfs_num, 1)) == GENMASK(vfs_num, 1))\n\t\t\tbreak;\n\n\t\tif (++cnt > QM_MAX_PF_WAIT_COUNT) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(QM_WAIT_DST_ACK);\n\t}\n\n\t \n\tfor (i = 1; i <= vfs_num; i++) {\n\t\tif (val & BIT(i))\n\t\t\tqm_handle_vf_msg(qm, i);\n\t\telse\n\t\t\tdev_err(dev, \"VF(%u) not ping PF!\\n\", i);\n\t}\n\n\t \n\tqm_clear_cmd_interrupt(qm, val);\n\n\treturn ret;\n}\n\nstatic void qm_trigger_vf_interrupt(struct hisi_qm *qm, u32 fun_num)\n{\n\tu32 val;\n\n\tval = readl(qm->io_base + QM_IFC_INT_CFG);\n\tval &= ~QM_IFC_SEND_ALL_VFS;\n\tval |= fun_num;\n\twritel(val, qm->io_base + QM_IFC_INT_CFG);\n\n\tval = readl(qm->io_base + QM_IFC_INT_SET_P);\n\tval |= QM_IFC_INT_SET_MASK;\n\twritel(val, qm->io_base + QM_IFC_INT_SET_P);\n}\n\nstatic void qm_trigger_pf_interrupt(struct hisi_qm *qm)\n{\n\tu32 val;\n\n\tval = readl(qm->io_base + QM_IFC_INT_SET_V);\n\tval |= QM_IFC_INT_SET_MASK;\n\twritel(val, qm->io_base + QM_IFC_INT_SET_V);\n}\n\nstatic int qm_ping_single_vf(struct hisi_qm *qm, u64 cmd, u32 fun_num)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tstruct qm_mailbox mailbox;\n\tint cnt = 0;\n\tu64 val;\n\tint ret;\n\n\tqm_mb_pre_init(&mailbox, QM_MB_CMD_SRC, cmd, fun_num, 0);\n\tmutex_lock(&qm->mailbox_lock);\n\tret = qm_mb_nolock(qm, &mailbox);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to send command to vf(%u)!\\n\", fun_num);\n\t\tgoto err_unlock;\n\t}\n\n\tqm_trigger_vf_interrupt(qm, fun_num);\n\twhile (true) {\n\t\tmsleep(QM_WAIT_DST_ACK);\n\t\tval = readq(qm->io_base + QM_IFC_READY_STATUS);\n\t\t \n\t\tif (!(val & BIT(fun_num)))\n\t\t\tgoto err_unlock;\n\n\t\tif (++cnt > QM_MAX_PF_WAIT_COUNT) {\n\t\t\tdev_err(dev, \"failed to get response from VF(%u)!\\n\", fun_num);\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\nerr_unlock:\n\tmutex_unlock(&qm->mailbox_lock);\n\treturn ret;\n}\n\nstatic int qm_ping_all_vfs(struct hisi_qm *qm, u64 cmd)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tu32 vfs_num = qm->vfs_num;\n\tstruct qm_mailbox mailbox;\n\tu64 val = 0;\n\tint cnt = 0;\n\tint ret;\n\tu32 i;\n\n\tqm_mb_pre_init(&mailbox, QM_MB_CMD_SRC, cmd, QM_MB_PING_ALL_VFS, 0);\n\tmutex_lock(&qm->mailbox_lock);\n\t \n\tret = qm_mb_nolock(qm, &mailbox);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to send command to VFs!\\n\");\n\t\tmutex_unlock(&qm->mailbox_lock);\n\t\treturn ret;\n\t}\n\n\tqm_trigger_vf_interrupt(qm, QM_IFC_SEND_ALL_VFS);\n\twhile (true) {\n\t\tmsleep(QM_WAIT_DST_ACK);\n\t\tval = readq(qm->io_base + QM_IFC_READY_STATUS);\n\t\t \n\t\tif (!(val & GENMASK(vfs_num, 1))) {\n\t\t\tmutex_unlock(&qm->mailbox_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (++cnt > QM_MAX_PF_WAIT_COUNT)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&qm->mailbox_lock);\n\n\t \n\tfor (i = 1; i <= vfs_num; i++) {\n\t\tif (val & BIT(i))\n\t\t\tdev_err(dev, \"failed to get response from VF(%u)!\\n\", i);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int qm_ping_pf(struct hisi_qm *qm, u64 cmd)\n{\n\tstruct qm_mailbox mailbox;\n\tint cnt = 0;\n\tu32 val;\n\tint ret;\n\n\tqm_mb_pre_init(&mailbox, QM_MB_CMD_SRC, cmd, 0, 0);\n\tmutex_lock(&qm->mailbox_lock);\n\tret = qm_mb_nolock(qm, &mailbox);\n\tif (ret) {\n\t\tdev_err(&qm->pdev->dev, \"failed to send command to PF!\\n\");\n\t\tgoto unlock;\n\t}\n\n\tqm_trigger_pf_interrupt(qm);\n\t \n\twhile (true) {\n\t\tmsleep(QM_WAIT_DST_ACK);\n\t\tval = readl(qm->io_base + QM_IFC_INT_SET_V);\n\t\tif (!(val & QM_IFC_INT_STATUS_MASK))\n\t\t\tbreak;\n\n\t\tif (++cnt > QM_MAX_VF_WAIT_COUNT) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\nunlock:\n\tmutex_unlock(&qm->mailbox_lock);\n\treturn ret;\n}\n\nstatic int qm_stop_qp(struct hisi_qp *qp)\n{\n\treturn hisi_qm_mb(qp->qm, QM_MB_CMD_STOP_QP, 0, qp->qp_id, 0);\n}\n\nstatic int qm_set_msi(struct hisi_qm *qm, bool set)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\n\tif (set) {\n\t\tpci_write_config_dword(pdev, pdev->msi_cap + PCI_MSI_MASK_64,\n\t\t\t\t       0);\n\t} else {\n\t\tpci_write_config_dword(pdev, pdev->msi_cap + PCI_MSI_MASK_64,\n\t\t\t\t       ACC_PEH_MSI_DISABLE);\n\t\tif (qm->err_status.is_qm_ecc_mbit ||\n\t\t    qm->err_status.is_dev_ecc_mbit)\n\t\t\treturn 0;\n\n\t\tmdelay(1);\n\t\tif (readl(qm->io_base + QM_PEH_DFX_INFO0))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic void qm_wait_msi_finish(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tu32 cmd = ~0;\n\tint cnt = 0;\n\tu32 val;\n\tint ret;\n\n\twhile (true) {\n\t\tpci_read_config_dword(pdev, pdev->msi_cap +\n\t\t\t\t      PCI_MSI_PENDING_64, &cmd);\n\t\tif (!cmd)\n\t\t\tbreak;\n\n\t\tif (++cnt > MAX_WAIT_COUNTS) {\n\t\t\tpci_warn(pdev, \"failed to empty MSI PENDING!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tudelay(1);\n\t}\n\n\tret = readl_relaxed_poll_timeout(qm->io_base + QM_PEH_DFX_INFO0,\n\t\t\t\t\t val, !(val & QM_PEH_DFX_MASK),\n\t\t\t\t\t POLL_PERIOD, POLL_TIMEOUT);\n\tif (ret)\n\t\tpci_warn(pdev, \"failed to empty PEH MSI!\\n\");\n\n\tret = readl_relaxed_poll_timeout(qm->io_base + QM_PEH_DFX_INFO1,\n\t\t\t\t\t val, !(val & QM_PEH_MSI_FINISH_MASK),\n\t\t\t\t\t POLL_PERIOD, POLL_TIMEOUT);\n\tif (ret)\n\t\tpci_warn(pdev, \"failed to finish MSI operation!\\n\");\n}\n\nstatic int qm_set_msi_v3(struct hisi_qm *qm, bool set)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tint ret = -ETIMEDOUT;\n\tu32 cmd, i;\n\n\tpci_read_config_dword(pdev, pdev->msi_cap, &cmd);\n\tif (set)\n\t\tcmd |= QM_MSI_CAP_ENABLE;\n\telse\n\t\tcmd &= ~QM_MSI_CAP_ENABLE;\n\n\tpci_write_config_dword(pdev, pdev->msi_cap, cmd);\n\tif (set) {\n\t\tfor (i = 0; i < MAX_WAIT_COUNTS; i++) {\n\t\t\tpci_read_config_dword(pdev, pdev->msi_cap, &cmd);\n\t\t\tif (cmd & QM_MSI_CAP_ENABLE)\n\t\t\t\treturn 0;\n\n\t\t\tudelay(1);\n\t\t}\n\t} else {\n\t\tudelay(WAIT_PERIOD_US_MIN);\n\t\tqm_wait_msi_finish(qm);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct hisi_qm_hw_ops qm_hw_ops_v1 = {\n\t.qm_db = qm_db_v1,\n\t.hw_error_init = qm_hw_error_init_v1,\n\t.set_msi = qm_set_msi,\n};\n\nstatic const struct hisi_qm_hw_ops qm_hw_ops_v2 = {\n\t.get_vft = qm_get_vft_v2,\n\t.qm_db = qm_db_v2,\n\t.hw_error_init = qm_hw_error_init_v2,\n\t.hw_error_uninit = qm_hw_error_uninit_v2,\n\t.hw_error_handle = qm_hw_error_handle_v2,\n\t.set_msi = qm_set_msi,\n};\n\nstatic const struct hisi_qm_hw_ops qm_hw_ops_v3 = {\n\t.get_vft = qm_get_vft_v2,\n\t.qm_db = qm_db_v2,\n\t.hw_error_init = qm_hw_error_init_v3,\n\t.hw_error_uninit = qm_hw_error_uninit_v3,\n\t.hw_error_handle = qm_hw_error_handle_v2,\n\t.set_msi = qm_set_msi_v3,\n};\n\nstatic void *qm_get_avail_sqe(struct hisi_qp *qp)\n{\n\tstruct hisi_qp_status *qp_status = &qp->qp_status;\n\tu16 sq_tail = qp_status->sq_tail;\n\n\tif (unlikely(atomic_read(&qp->qp_status.used) == qp->sq_depth - 1))\n\t\treturn NULL;\n\n\treturn qp->sqe + sq_tail * qp->qm->sqe_size;\n}\n\nstatic void hisi_qm_unset_hw_reset(struct hisi_qp *qp)\n{\n\tu64 *addr;\n\n\t \n\taddr = (u64 *)(qp->qdma.va + qp->qdma.size) - QM_RESET_STOP_TX_OFFSET;\n\t*addr = 0;\n}\n\nstatic struct hisi_qp *qm_create_qp_nolock(struct hisi_qm *qm, u8 alg_type)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tstruct hisi_qp *qp;\n\tint qp_id;\n\n\tif (!qm_qp_avail_state(qm, NULL, QP_INIT))\n\t\treturn ERR_PTR(-EPERM);\n\n\tif (qm->qp_in_used == qm->qp_num) {\n\t\tdev_info_ratelimited(dev, \"All %u queues of QM are busy!\\n\",\n\t\t\t\t     qm->qp_num);\n\t\tatomic64_inc(&qm->debug.dfx.create_qp_err_cnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tqp_id = idr_alloc_cyclic(&qm->qp_idr, NULL, 0, qm->qp_num, GFP_ATOMIC);\n\tif (qp_id < 0) {\n\t\tdev_info_ratelimited(dev, \"All %u queues of QM are busy!\\n\",\n\t\t\t\t    qm->qp_num);\n\t\tatomic64_inc(&qm->debug.dfx.create_qp_err_cnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tqp = &qm->qp_array[qp_id];\n\thisi_qm_unset_hw_reset(qp);\n\tmemset(qp->cqe, 0, sizeof(struct qm_cqe) * qp->cq_depth);\n\n\tqp->event_cb = NULL;\n\tqp->req_cb = NULL;\n\tqp->qp_id = qp_id;\n\tqp->alg_type = alg_type;\n\tqp->is_in_kernel = true;\n\tqm->qp_in_used++;\n\tatomic_set(&qp->qp_status.flags, QP_INIT);\n\n\treturn qp;\n}\n\n \nstatic struct hisi_qp *hisi_qm_create_qp(struct hisi_qm *qm, u8 alg_type)\n{\n\tstruct hisi_qp *qp;\n\tint ret;\n\n\tret = qm_pm_get_sync(qm);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdown_write(&qm->qps_lock);\n\tqp = qm_create_qp_nolock(qm, alg_type);\n\tup_write(&qm->qps_lock);\n\n\tif (IS_ERR(qp))\n\t\tqm_pm_put_sync(qm);\n\n\treturn qp;\n}\n\n \nstatic void hisi_qm_release_qp(struct hisi_qp *qp)\n{\n\tstruct hisi_qm *qm = qp->qm;\n\n\tdown_write(&qm->qps_lock);\n\n\tif (!qm_qp_avail_state(qm, qp, QP_CLOSE)) {\n\t\tup_write(&qm->qps_lock);\n\t\treturn;\n\t}\n\n\tqm->qp_in_used--;\n\tidr_remove(&qm->qp_idr, qp->qp_id);\n\n\tup_write(&qm->qps_lock);\n\n\tqm_pm_put_sync(qm);\n}\n\nstatic int qm_sq_ctx_cfg(struct hisi_qp *qp, int qp_id, u32 pasid)\n{\n\tstruct hisi_qm *qm = qp->qm;\n\tstruct device *dev = &qm->pdev->dev;\n\tenum qm_hw_ver ver = qm->ver;\n\tstruct qm_sqc *sqc;\n\tdma_addr_t sqc_dma;\n\tint ret;\n\n\tsqc = kzalloc(sizeof(struct qm_sqc), GFP_KERNEL);\n\tif (!sqc)\n\t\treturn -ENOMEM;\n\n\tINIT_QC_COMMON(sqc, qp->sqe_dma, pasid);\n\tif (ver == QM_HW_V1) {\n\t\tsqc->dw3 = cpu_to_le32(QM_MK_SQC_DW3_V1(0, 0, 0, qm->sqe_size));\n\t\tsqc->w8 = cpu_to_le16(qp->sq_depth - 1);\n\t} else {\n\t\tsqc->dw3 = cpu_to_le32(QM_MK_SQC_DW3_V2(qm->sqe_size, qp->sq_depth));\n\t\tsqc->w8 = 0;  \n\t}\n\tsqc->cq_num = cpu_to_le16(qp_id);\n\tsqc->w13 = cpu_to_le16(QM_MK_SQC_W13(0, 1, qp->alg_type));\n\n\tif (ver >= QM_HW_V3 && qm->use_sva && !qp->is_in_kernel)\n\t\tsqc->w11 = cpu_to_le16(QM_QC_PASID_ENABLE <<\n\t\t\t\t       QM_QC_PASID_ENABLE_SHIFT);\n\n\tsqc_dma = dma_map_single(dev, sqc, sizeof(struct qm_sqc),\n\t\t\t\t DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, sqc_dma)) {\n\t\tkfree(sqc);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = hisi_qm_mb(qm, QM_MB_CMD_SQC, sqc_dma, qp_id, 0);\n\tdma_unmap_single(dev, sqc_dma, sizeof(struct qm_sqc), DMA_TO_DEVICE);\n\tkfree(sqc);\n\n\treturn ret;\n}\n\nstatic int qm_cq_ctx_cfg(struct hisi_qp *qp, int qp_id, u32 pasid)\n{\n\tstruct hisi_qm *qm = qp->qm;\n\tstruct device *dev = &qm->pdev->dev;\n\tenum qm_hw_ver ver = qm->ver;\n\tstruct qm_cqc *cqc;\n\tdma_addr_t cqc_dma;\n\tint ret;\n\n\tcqc = kzalloc(sizeof(struct qm_cqc), GFP_KERNEL);\n\tif (!cqc)\n\t\treturn -ENOMEM;\n\n\tINIT_QC_COMMON(cqc, qp->cqe_dma, pasid);\n\tif (ver == QM_HW_V1) {\n\t\tcqc->dw3 = cpu_to_le32(QM_MK_CQC_DW3_V1(0, 0, 0,\n\t\t\t\t\t\t\tQM_QC_CQE_SIZE));\n\t\tcqc->w8 = cpu_to_le16(qp->cq_depth - 1);\n\t} else {\n\t\tcqc->dw3 = cpu_to_le32(QM_MK_CQC_DW3_V2(QM_QC_CQE_SIZE, qp->cq_depth));\n\t\tcqc->w8 = 0;  \n\t}\n\tcqc->dw6 = cpu_to_le32(1 << QM_CQ_PHASE_SHIFT | 1 << QM_CQ_FLAG_SHIFT);\n\n\tif (ver >= QM_HW_V3 && qm->use_sva && !qp->is_in_kernel)\n\t\tcqc->w11 = cpu_to_le16(QM_QC_PASID_ENABLE);\n\n\tcqc_dma = dma_map_single(dev, cqc, sizeof(struct qm_cqc),\n\t\t\t\t DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, cqc_dma)) {\n\t\tkfree(cqc);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = hisi_qm_mb(qm, QM_MB_CMD_CQC, cqc_dma, qp_id, 0);\n\tdma_unmap_single(dev, cqc_dma, sizeof(struct qm_cqc), DMA_TO_DEVICE);\n\tkfree(cqc);\n\n\treturn ret;\n}\n\nstatic int qm_qp_ctx_cfg(struct hisi_qp *qp, int qp_id, u32 pasid)\n{\n\tint ret;\n\n\tqm_init_qp_status(qp);\n\n\tret = qm_sq_ctx_cfg(qp, qp_id, pasid);\n\tif (ret)\n\t\treturn ret;\n\n\treturn qm_cq_ctx_cfg(qp, qp_id, pasid);\n}\n\nstatic int qm_start_qp_nolock(struct hisi_qp *qp, unsigned long arg)\n{\n\tstruct hisi_qm *qm = qp->qm;\n\tstruct device *dev = &qm->pdev->dev;\n\tint qp_id = qp->qp_id;\n\tu32 pasid = arg;\n\tint ret;\n\n\tif (!qm_qp_avail_state(qm, qp, QP_START))\n\t\treturn -EPERM;\n\n\tret = qm_qp_ctx_cfg(qp, qp_id, pasid);\n\tif (ret)\n\t\treturn ret;\n\n\tatomic_set(&qp->qp_status.flags, QP_START);\n\tdev_dbg(dev, \"queue %d started\\n\", qp_id);\n\n\treturn 0;\n}\n\n \nint hisi_qm_start_qp(struct hisi_qp *qp, unsigned long arg)\n{\n\tstruct hisi_qm *qm = qp->qm;\n\tint ret;\n\n\tdown_write(&qm->qps_lock);\n\tret = qm_start_qp_nolock(qp, arg);\n\tup_write(&qm->qps_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_start_qp);\n\n \nstatic void qp_stop_fail_cb(struct hisi_qp *qp)\n{\n\tint qp_used = atomic_read(&qp->qp_status.used);\n\tu16 cur_tail = qp->qp_status.sq_tail;\n\tu16 sq_depth = qp->sq_depth;\n\tu16 cur_head = (cur_tail + sq_depth - qp_used) % sq_depth;\n\tstruct hisi_qm *qm = qp->qm;\n\tu16 pos;\n\tint i;\n\n\tfor (i = 0; i < qp_used; i++) {\n\t\tpos = (i + cur_head) % sq_depth;\n\t\tqp->req_cb(qp, qp->sqe + (u32)(qm->sqe_size * pos));\n\t\tatomic_dec(&qp->qp_status.used);\n\t}\n}\n\n \nstatic int qm_drain_qp(struct hisi_qp *qp)\n{\n\tsize_t size = sizeof(struct qm_sqc) + sizeof(struct qm_cqc);\n\tstruct hisi_qm *qm = qp->qm;\n\tstruct device *dev = &qm->pdev->dev;\n\tstruct qm_sqc *sqc;\n\tstruct qm_cqc *cqc;\n\tdma_addr_t dma_addr;\n\tint ret = 0, i = 0;\n\tvoid *addr;\n\n\t \n\tif (qm_check_dev_error(qm))\n\t\treturn 0;\n\n\t \n\tif (test_bit(QM_SUPPORT_STOP_QP, &qm->caps)) {\n\t\tret = qm_stop_qp(qp);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Failed to stop qp(%u)!\\n\", qp->qp_id);\n\t\treturn ret;\n\t}\n\n\taddr = hisi_qm_ctx_alloc(qm, size, &dma_addr);\n\tif (IS_ERR(addr)) {\n\t\tdev_err(dev, \"Failed to alloc ctx for sqc and cqc!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (++i) {\n\t\tret = qm_dump_sqc_raw(qm, dma_addr, qp->qp_id);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(dev, \"Failed to dump sqc!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tsqc = addr;\n\n\t\tret = qm_dump_cqc_raw(qm, (dma_addr + sizeof(struct qm_sqc)),\n\t\t\t\t      qp->qp_id);\n\t\tif (ret) {\n\t\t\tdev_err_ratelimited(dev, \"Failed to dump cqc!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcqc = addr + sizeof(struct qm_sqc);\n\n\t\tif ((sqc->tail == cqc->tail) &&\n\t\t    (QM_SQ_TAIL_IDX(sqc) == QM_CQ_TAIL_IDX(cqc)))\n\t\t\tbreak;\n\n\t\tif (i == MAX_WAIT_COUNTS) {\n\t\t\tdev_err(dev, \"Fail to empty queue %u!\\n\", qp->qp_id);\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(WAIT_PERIOD_US_MIN, WAIT_PERIOD_US_MAX);\n\t}\n\n\thisi_qm_ctx_free(qm, size, addr, &dma_addr);\n\n\treturn ret;\n}\n\nstatic int qm_stop_qp_nolock(struct hisi_qp *qp)\n{\n\tstruct device *dev = &qp->qm->pdev->dev;\n\tint ret;\n\n\t \n\tif (atomic_read(&qp->qp_status.flags) == QP_STOP) {\n\t\tqp->is_resetting = false;\n\t\treturn 0;\n\t}\n\n\tif (!qm_qp_avail_state(qp->qm, qp, QP_STOP))\n\t\treturn -EPERM;\n\n\tatomic_set(&qp->qp_status.flags, QP_STOP);\n\n\tret = qm_drain_qp(qp);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to drain out data for stopping!\\n\");\n\n\n\tflush_workqueue(qp->qm->wq);\n\tif (unlikely(qp->is_resetting && atomic_read(&qp->qp_status.used)))\n\t\tqp_stop_fail_cb(qp);\n\n\tdev_dbg(dev, \"stop queue %u!\", qp->qp_id);\n\n\treturn 0;\n}\n\n \nint hisi_qm_stop_qp(struct hisi_qp *qp)\n{\n\tint ret;\n\n\tdown_write(&qp->qm->qps_lock);\n\tret = qm_stop_qp_nolock(qp);\n\tup_write(&qp->qm->qps_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_stop_qp);\n\n \nint hisi_qp_send(struct hisi_qp *qp, const void *msg)\n{\n\tstruct hisi_qp_status *qp_status = &qp->qp_status;\n\tu16 sq_tail = qp_status->sq_tail;\n\tu16 sq_tail_next = (sq_tail + 1) % qp->sq_depth;\n\tvoid *sqe = qm_get_avail_sqe(qp);\n\n\tif (unlikely(atomic_read(&qp->qp_status.flags) == QP_STOP ||\n\t\t     atomic_read(&qp->qm->status.flags) == QM_STOP ||\n\t\t     qp->is_resetting)) {\n\t\tdev_info_ratelimited(&qp->qm->pdev->dev, \"QP is stopped or resetting\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!sqe)\n\t\treturn -EBUSY;\n\n\tmemcpy(sqe, msg, qp->qm->sqe_size);\n\n\tqm_db(qp->qm, qp->qp_id, QM_DOORBELL_CMD_SQ, sq_tail_next, 0);\n\tatomic_inc(&qp->qp_status.used);\n\tqp_status->sq_tail = sq_tail_next;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hisi_qp_send);\n\nstatic void hisi_qm_cache_wb(struct hisi_qm *qm)\n{\n\tunsigned int val;\n\n\tif (qm->ver == QM_HW_V1)\n\t\treturn;\n\n\twritel(0x1, qm->io_base + QM_CACHE_WB_START);\n\tif (readl_relaxed_poll_timeout(qm->io_base + QM_CACHE_WB_DONE,\n\t\t\t\t       val, val & BIT(0), POLL_PERIOD,\n\t\t\t\t       POLL_TIMEOUT))\n\t\tdev_err(&qm->pdev->dev, \"QM writeback sqc cache fail!\\n\");\n}\n\nstatic void qm_qp_event_notifier(struct hisi_qp *qp)\n{\n\twake_up_interruptible(&qp->uacce_q->wait);\n}\n\n  \nstatic int hisi_qm_get_available_instances(struct uacce_device *uacce)\n{\n\tstruct hisi_qm *qm = uacce->priv;\n\tint ret;\n\n\tdown_read(&qm->qps_lock);\n\tret = qm->qp_num - qm->qp_in_used;\n\tup_read(&qm->qps_lock);\n\n\treturn ret;\n}\n\nstatic void hisi_qm_set_hw_reset(struct hisi_qm *qm, int offset)\n{\n\tint i;\n\n\tfor (i = 0; i < qm->qp_num; i++)\n\t\tqm_set_qp_disable(&qm->qp_array[i], offset);\n}\n\nstatic int hisi_qm_uacce_get_queue(struct uacce_device *uacce,\n\t\t\t\t   unsigned long arg,\n\t\t\t\t   struct uacce_queue *q)\n{\n\tstruct hisi_qm *qm = uacce->priv;\n\tstruct hisi_qp *qp;\n\tu8 alg_type = 0;\n\n\tqp = hisi_qm_create_qp(qm, alg_type);\n\tif (IS_ERR(qp))\n\t\treturn PTR_ERR(qp);\n\n\tq->priv = qp;\n\tq->uacce = uacce;\n\tqp->uacce_q = q;\n\tqp->event_cb = qm_qp_event_notifier;\n\tqp->pasid = arg;\n\tqp->is_in_kernel = false;\n\n\treturn 0;\n}\n\nstatic void hisi_qm_uacce_put_queue(struct uacce_queue *q)\n{\n\tstruct hisi_qp *qp = q->priv;\n\n\thisi_qm_release_qp(qp);\n}\n\n \nstatic int hisi_qm_uacce_mmap(struct uacce_queue *q,\n\t\t\t      struct vm_area_struct *vma,\n\t\t\t      struct uacce_qfile_region *qfr)\n{\n\tstruct hisi_qp *qp = q->priv;\n\tstruct hisi_qm *qm = qp->qm;\n\tresource_size_t phys_base = qm->db_phys_base +\n\t\t\t\t    qp->qp_id * qm->db_interval;\n\tsize_t sz = vma->vm_end - vma->vm_start;\n\tstruct pci_dev *pdev = qm->pdev;\n\tstruct device *dev = &pdev->dev;\n\tunsigned long vm_pgoff;\n\tint ret;\n\n\tswitch (qfr->type) {\n\tcase UACCE_QFRT_MMIO:\n\t\tif (qm->ver == QM_HW_V1) {\n\t\t\tif (sz > PAGE_SIZE * QM_DOORBELL_PAGE_NR)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!test_bit(QM_SUPPORT_DB_ISOLATION, &qm->caps)) {\n\t\t\tif (sz > PAGE_SIZE * (QM_DOORBELL_PAGE_NR +\n\t\t\t    QM_DOORBELL_SQ_CQ_BASE_V2 / PAGE_SIZE))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (sz > qm->db_interval)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvm_flags_set(vma, VM_IO);\n\n\t\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\t\t       phys_base >> PAGE_SHIFT,\n\t\t\t\t       sz, pgprot_noncached(vma->vm_page_prot));\n\tcase UACCE_QFRT_DUS:\n\t\tif (sz != qp->qdma.size)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tvm_pgoff = vma->vm_pgoff;\n\t\tvma->vm_pgoff = 0;\n\t\tret = dma_mmap_coherent(dev, vma, qp->qdma.va,\n\t\t\t\t\tqp->qdma.dma, sz);\n\t\tvma->vm_pgoff = vm_pgoff;\n\t\treturn ret;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int hisi_qm_uacce_start_queue(struct uacce_queue *q)\n{\n\tstruct hisi_qp *qp = q->priv;\n\n\treturn hisi_qm_start_qp(qp, qp->pasid);\n}\n\nstatic void hisi_qm_uacce_stop_queue(struct uacce_queue *q)\n{\n\thisi_qm_stop_qp(q->priv);\n}\n\nstatic int hisi_qm_is_q_updated(struct uacce_queue *q)\n{\n\tstruct hisi_qp *qp = q->priv;\n\tstruct qm_cqe *cqe = qp->cqe + qp->qp_status.cq_head;\n\tint updated = 0;\n\n\twhile (QM_CQE_PHASE(cqe) == qp->qp_status.cqc_phase) {\n\t\t \n\t\tdma_rmb();\n\t\tqm_cq_head_update(qp);\n\t\tcqe = qp->cqe + qp->qp_status.cq_head;\n\t\tupdated = 1;\n\t}\n\n\treturn updated;\n}\n\nstatic void qm_set_sqctype(struct uacce_queue *q, u16 type)\n{\n\tstruct hisi_qm *qm = q->uacce->priv;\n\tstruct hisi_qp *qp = q->priv;\n\n\tdown_write(&qm->qps_lock);\n\tqp->alg_type = type;\n\tup_write(&qm->qps_lock);\n}\n\nstatic long hisi_qm_uacce_ioctl(struct uacce_queue *q, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct hisi_qp *qp = q->priv;\n\tstruct hisi_qp_info qp_info;\n\tstruct hisi_qp_ctx qp_ctx;\n\n\tif (cmd == UACCE_CMD_QM_SET_QP_CTX) {\n\t\tif (copy_from_user(&qp_ctx, (void __user *)arg,\n\t\t\t\t   sizeof(struct hisi_qp_ctx)))\n\t\t\treturn -EFAULT;\n\n\t\tif (qp_ctx.qc_type != 0 && qp_ctx.qc_type != 1)\n\t\t\treturn -EINVAL;\n\n\t\tqm_set_sqctype(q, qp_ctx.qc_type);\n\t\tqp_ctx.id = qp->qp_id;\n\n\t\tif (copy_to_user((void __user *)arg, &qp_ctx,\n\t\t\t\t sizeof(struct hisi_qp_ctx)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t} else if (cmd == UACCE_CMD_QM_SET_QP_INFO) {\n\t\tif (copy_from_user(&qp_info, (void __user *)arg,\n\t\t\t\t   sizeof(struct hisi_qp_info)))\n\t\t\treturn -EFAULT;\n\n\t\tqp_info.sqe_size = qp->qm->sqe_size;\n\t\tqp_info.sq_depth = qp->sq_depth;\n\t\tqp_info.cq_depth = qp->cq_depth;\n\n\t\tif (copy_to_user((void __user *)arg, &qp_info,\n\t\t\t\t  sizeof(struct hisi_qp_info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int qm_hw_err_isolate(struct hisi_qm *qm)\n{\n\tstruct qm_hw_err *err, *tmp, *hw_err;\n\tstruct qm_err_isolate *isolate;\n\tu32 count = 0;\n\n\tisolate = &qm->isolate_data;\n\n#define SECONDS_PER_HOUR\t3600\n\n\t \n\tif (qm->uacce->is_vf || isolate->is_isolate || !isolate->err_threshold)\n\t\treturn 0;\n\n\thw_err = kzalloc(sizeof(*hw_err), GFP_KERNEL);\n\tif (!hw_err)\n\t\treturn -ENOMEM;\n\n\t \n\tmutex_lock(&isolate->isolate_lock);\n\thw_err->timestamp = jiffies;\n\tlist_for_each_entry_safe(err, tmp, &isolate->qm_hw_errs, list) {\n\t\tif ((hw_err->timestamp - err->timestamp) / HZ >\n\t\t    SECONDS_PER_HOUR) {\n\t\t\tlist_del(&err->list);\n\t\t\tkfree(err);\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\t}\n\tlist_add(&hw_err->list, &isolate->qm_hw_errs);\n\tmutex_unlock(&isolate->isolate_lock);\n\n\tif (count >= isolate->err_threshold)\n\t\tisolate->is_isolate = true;\n\n\treturn 0;\n}\n\nstatic void qm_hw_err_destroy(struct hisi_qm *qm)\n{\n\tstruct qm_hw_err *err, *tmp;\n\n\tmutex_lock(&qm->isolate_data.isolate_lock);\n\tlist_for_each_entry_safe(err, tmp, &qm->isolate_data.qm_hw_errs, list) {\n\t\tlist_del(&err->list);\n\t\tkfree(err);\n\t}\n\tmutex_unlock(&qm->isolate_data.isolate_lock);\n}\n\nstatic enum uacce_dev_state hisi_qm_get_isolate_state(struct uacce_device *uacce)\n{\n\tstruct hisi_qm *qm = uacce->priv;\n\tstruct hisi_qm *pf_qm;\n\n\tif (uacce->is_vf)\n\t\tpf_qm = pci_get_drvdata(pci_physfn(qm->pdev));\n\telse\n\t\tpf_qm = qm;\n\n\treturn pf_qm->isolate_data.is_isolate ?\n\t\t\tUACCE_DEV_ISOLATE : UACCE_DEV_NORMAL;\n}\n\nstatic int hisi_qm_isolate_threshold_write(struct uacce_device *uacce, u32 num)\n{\n\tstruct hisi_qm *qm = uacce->priv;\n\n\t \n\tif (uacce->is_vf)\n\t\treturn -EPERM;\n\n\tif (qm->isolate_data.is_isolate)\n\t\treturn -EPERM;\n\n\tqm->isolate_data.err_threshold = num;\n\n\t \n\tqm_hw_err_destroy(qm);\n\n\treturn 0;\n}\n\nstatic u32 hisi_qm_isolate_threshold_read(struct uacce_device *uacce)\n{\n\tstruct hisi_qm *qm = uacce->priv;\n\tstruct hisi_qm *pf_qm;\n\n\tif (uacce->is_vf) {\n\t\tpf_qm = pci_get_drvdata(pci_physfn(qm->pdev));\n\t\treturn pf_qm->isolate_data.err_threshold;\n\t}\n\n\treturn qm->isolate_data.err_threshold;\n}\n\nstatic const struct uacce_ops uacce_qm_ops = {\n\t.get_available_instances = hisi_qm_get_available_instances,\n\t.get_queue = hisi_qm_uacce_get_queue,\n\t.put_queue = hisi_qm_uacce_put_queue,\n\t.start_queue = hisi_qm_uacce_start_queue,\n\t.stop_queue = hisi_qm_uacce_stop_queue,\n\t.mmap = hisi_qm_uacce_mmap,\n\t.ioctl = hisi_qm_uacce_ioctl,\n\t.is_q_updated = hisi_qm_is_q_updated,\n\t.get_isolate_state = hisi_qm_get_isolate_state,\n\t.isolate_err_threshold_write = hisi_qm_isolate_threshold_write,\n\t.isolate_err_threshold_read = hisi_qm_isolate_threshold_read,\n};\n\nstatic void qm_remove_uacce(struct hisi_qm *qm)\n{\n\tstruct uacce_device *uacce = qm->uacce;\n\n\tif (qm->use_sva) {\n\t\tqm_hw_err_destroy(qm);\n\t\tuacce_remove(uacce);\n\t\tqm->uacce = NULL;\n\t}\n}\n\nstatic int qm_alloc_uacce(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tstruct uacce_device *uacce;\n\tunsigned long mmio_page_nr;\n\tunsigned long dus_page_nr;\n\tu16 sq_depth, cq_depth;\n\tstruct uacce_interface interface = {\n\t\t.flags = UACCE_DEV_SVA,\n\t\t.ops = &uacce_qm_ops,\n\t};\n\tint ret;\n\n\tret = strscpy(interface.name, dev_driver_string(&pdev->dev),\n\t\t      sizeof(interface.name));\n\tif (ret < 0)\n\t\treturn -ENAMETOOLONG;\n\n\tuacce = uacce_alloc(&pdev->dev, &interface);\n\tif (IS_ERR(uacce))\n\t\treturn PTR_ERR(uacce);\n\n\tif (uacce->flags & UACCE_DEV_SVA) {\n\t\tqm->use_sva = true;\n\t} else {\n\t\t \n\t\tqm_remove_uacce(qm);\n\t\treturn -EINVAL;\n\t}\n\n\tuacce->is_vf = pdev->is_virtfn;\n\tuacce->priv = qm;\n\n\tif (qm->ver == QM_HW_V1)\n\t\tuacce->api_ver = HISI_QM_API_VER_BASE;\n\telse if (qm->ver == QM_HW_V2)\n\t\tuacce->api_ver = HISI_QM_API_VER2_BASE;\n\telse\n\t\tuacce->api_ver = HISI_QM_API_VER3_BASE;\n\n\tif (qm->ver == QM_HW_V1)\n\t\tmmio_page_nr = QM_DOORBELL_PAGE_NR;\n\telse if (!test_bit(QM_SUPPORT_DB_ISOLATION, &qm->caps))\n\t\tmmio_page_nr = QM_DOORBELL_PAGE_NR +\n\t\t\tQM_DOORBELL_SQ_CQ_BASE_V2 / PAGE_SIZE;\n\telse\n\t\tmmio_page_nr = qm->db_interval / PAGE_SIZE;\n\n\tqm_get_xqc_depth(qm, &sq_depth, &cq_depth, QM_QP_DEPTH_CAP);\n\n\t \n\tdus_page_nr = (PAGE_SIZE - 1 + qm->sqe_size * sq_depth +\n\t\t       sizeof(struct qm_cqe) * cq_depth  + PAGE_SIZE) >>\n\t\t\t\t\t PAGE_SHIFT;\n\n\tuacce->qf_pg_num[UACCE_QFRT_MMIO] = mmio_page_nr;\n\tuacce->qf_pg_num[UACCE_QFRT_DUS]  = dus_page_nr;\n\n\tqm->uacce = uacce;\n\tINIT_LIST_HEAD(&qm->isolate_data.qm_hw_errs);\n\tmutex_init(&qm->isolate_data.isolate_lock);\n\n\treturn 0;\n}\n\n \nstatic int qm_frozen(struct hisi_qm *qm)\n{\n\tif (test_bit(QM_DRIVER_REMOVING, &qm->misc_ctl))\n\t\treturn 0;\n\n\tdown_write(&qm->qps_lock);\n\n\tif (!qm->qp_in_used) {\n\t\tqm->qp_in_used = qm->qp_num;\n\t\tup_write(&qm->qps_lock);\n\t\tset_bit(QM_DRIVER_REMOVING, &qm->misc_ctl);\n\t\treturn 0;\n\t}\n\n\tup_write(&qm->qps_lock);\n\n\treturn -EBUSY;\n}\n\nstatic int qm_try_frozen_vfs(struct pci_dev *pdev,\n\t\t\t     struct hisi_qm_list *qm_list)\n{\n\tstruct hisi_qm *qm, *vf_qm;\n\tstruct pci_dev *dev;\n\tint ret = 0;\n\n\tif (!qm_list || !pdev)\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&qm_list->lock);\n\tlist_for_each_entry(qm, &qm_list->list, list) {\n\t\tdev = qm->pdev;\n\t\tif (dev == pdev)\n\t\t\tcontinue;\n\t\tif (pci_physfn(dev) == pdev) {\n\t\t\tvf_qm = pci_get_drvdata(dev);\n\t\t\tret = qm_frozen(vf_qm);\n\t\t\tif (ret)\n\t\t\t\tgoto frozen_fail;\n\t\t}\n\t}\n\nfrozen_fail:\n\tmutex_unlock(&qm_list->lock);\n\n\treturn ret;\n}\n\n \nvoid hisi_qm_wait_task_finish(struct hisi_qm *qm, struct hisi_qm_list *qm_list)\n{\n\twhile (qm_frozen(qm) ||\n\t       ((qm->fun_type == QM_HW_PF) &&\n\t       qm_try_frozen_vfs(qm->pdev, qm_list))) {\n\t\tmsleep(WAIT_PERIOD);\n\t}\n\n\twhile (test_bit(QM_RST_SCHED, &qm->misc_ctl) ||\n\t       test_bit(QM_RESETTING, &qm->misc_ctl))\n\t\tmsleep(WAIT_PERIOD);\n\n\tif (test_bit(QM_SUPPORT_MB_COMMAND, &qm->caps))\n\t\tflush_work(&qm->cmd_process);\n\n\tudelay(REMOVE_WAIT_DELAY);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_wait_task_finish);\n\nstatic void hisi_qp_memory_uninit(struct hisi_qm *qm, int num)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tstruct qm_dma *qdma;\n\tint i;\n\n\tfor (i = num - 1; i >= 0; i--) {\n\t\tqdma = &qm->qp_array[i].qdma;\n\t\tdma_free_coherent(dev, qdma->size, qdma->va, qdma->dma);\n\t\tkfree(qm->poll_data[i].qp_finish_id);\n\t}\n\n\tkfree(qm->poll_data);\n\tkfree(qm->qp_array);\n}\n\nstatic int hisi_qp_memory_init(struct hisi_qm *qm, size_t dma_size, int id,\n\t\t\t       u16 sq_depth, u16 cq_depth)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tsize_t off = qm->sqe_size * sq_depth;\n\tstruct hisi_qp *qp;\n\tint ret = -ENOMEM;\n\n\tqm->poll_data[id].qp_finish_id = kcalloc(qm->qp_num, sizeof(u16),\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!qm->poll_data[id].qp_finish_id)\n\t\treturn -ENOMEM;\n\n\tqp = &qm->qp_array[id];\n\tqp->qdma.va = dma_alloc_coherent(dev, dma_size, &qp->qdma.dma,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!qp->qdma.va)\n\t\tgoto err_free_qp_finish_id;\n\n\tqp->sqe = qp->qdma.va;\n\tqp->sqe_dma = qp->qdma.dma;\n\tqp->cqe = qp->qdma.va + off;\n\tqp->cqe_dma = qp->qdma.dma + off;\n\tqp->qdma.size = dma_size;\n\tqp->sq_depth = sq_depth;\n\tqp->cq_depth = cq_depth;\n\tqp->qm = qm;\n\tqp->qp_id = id;\n\n\treturn 0;\n\nerr_free_qp_finish_id:\n\tkfree(qm->poll_data[id].qp_finish_id);\n\treturn ret;\n}\n\nstatic void hisi_qm_pre_init(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\n\tif (qm->ver == QM_HW_V1)\n\t\tqm->ops = &qm_hw_ops_v1;\n\telse if (qm->ver == QM_HW_V2)\n\t\tqm->ops = &qm_hw_ops_v2;\n\telse\n\t\tqm->ops = &qm_hw_ops_v3;\n\n\tpci_set_drvdata(pdev, qm);\n\tmutex_init(&qm->mailbox_lock);\n\tinit_rwsem(&qm->qps_lock);\n\tqm->qp_in_used = 0;\n\tif (test_bit(QM_SUPPORT_RPM, &qm->caps)) {\n\t\tif (!acpi_device_power_manageable(ACPI_COMPANION(&pdev->dev)))\n\t\t\tdev_info(&pdev->dev, \"_PS0 and _PR0 are not defined\");\n\t}\n}\n\nstatic void qm_cmd_uninit(struct hisi_qm *qm)\n{\n\tu32 val;\n\n\tif (!test_bit(QM_SUPPORT_MB_COMMAND, &qm->caps))\n\t\treturn;\n\n\tval = readl(qm->io_base + QM_IFC_INT_MASK);\n\tval |= QM_IFC_INT_DISABLE;\n\twritel(val, qm->io_base + QM_IFC_INT_MASK);\n}\n\nstatic void qm_cmd_init(struct hisi_qm *qm)\n{\n\tu32 val;\n\n\tif (!test_bit(QM_SUPPORT_MB_COMMAND, &qm->caps))\n\t\treturn;\n\n\t \n\tqm_clear_cmd_interrupt(qm, QM_IFC_INT_SOURCE_CLR);\n\n\t \n\tval = readl(qm->io_base + QM_IFC_INT_MASK);\n\tval &= ~QM_IFC_INT_DISABLE;\n\twritel(val, qm->io_base + QM_IFC_INT_MASK);\n}\n\nstatic void qm_put_pci_res(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\n\tif (test_bit(QM_SUPPORT_DB_ISOLATION, &qm->caps))\n\t\tiounmap(qm->db_io_base);\n\n\tiounmap(qm->io_base);\n\tpci_release_mem_regions(pdev);\n}\n\nstatic void hisi_qm_pci_uninit(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\n\tpci_free_irq_vectors(pdev);\n\tqm_put_pci_res(qm);\n\tpci_disable_device(pdev);\n}\n\nstatic void hisi_qm_set_state(struct hisi_qm *qm, u8 state)\n{\n\tif (qm->ver > QM_HW_V2 && qm->fun_type == QM_HW_VF)\n\t\twritel(state, qm->io_base + QM_VF_STATE);\n}\n\nstatic void hisi_qm_unint_work(struct hisi_qm *qm)\n{\n\tdestroy_workqueue(qm->wq);\n}\n\nstatic void hisi_qm_memory_uninit(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\n\thisi_qp_memory_uninit(qm, qm->qp_num);\n\tif (qm->qdma.va) {\n\t\thisi_qm_cache_wb(qm);\n\t\tdma_free_coherent(dev, qm->qdma.size,\n\t\t\t\t  qm->qdma.va, qm->qdma.dma);\n\t}\n\n\tidr_destroy(&qm->qp_idr);\n\n\tif (test_bit(QM_SUPPORT_FUNC_QOS, &qm->caps))\n\t\tkfree(qm->factor);\n}\n\n \nvoid hisi_qm_uninit(struct hisi_qm *qm)\n{\n\tqm_cmd_uninit(qm);\n\thisi_qm_unint_work(qm);\n\tdown_write(&qm->qps_lock);\n\n\tif (!qm_avail_state(qm, QM_CLOSE)) {\n\t\tup_write(&qm->qps_lock);\n\t\treturn;\n\t}\n\n\thisi_qm_memory_uninit(qm);\n\thisi_qm_set_state(qm, QM_NOT_READY);\n\tup_write(&qm->qps_lock);\n\n\tqm_irqs_unregister(qm);\n\thisi_qm_pci_uninit(qm);\n\tif (qm->use_sva) {\n\t\tuacce_remove(qm->uacce);\n\t\tqm->uacce = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(hisi_qm_uninit);\n\n \nstatic int hisi_qm_get_vft(struct hisi_qm *qm, u32 *base, u32 *number)\n{\n\tif (!base || !number)\n\t\treturn -EINVAL;\n\n\tif (!qm->ops->get_vft) {\n\t\tdev_err(&qm->pdev->dev, \"Don't support vft read!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn qm->ops->get_vft(qm, base, number);\n}\n\n \nstatic int hisi_qm_set_vft(struct hisi_qm *qm, u32 fun_num, u32 base,\n\t\t    u32 number)\n{\n\tu32 max_q_num = qm->ctrl_qp_num;\n\n\tif (base >= max_q_num || number > max_q_num ||\n\t    (base + number) > max_q_num)\n\t\treturn -EINVAL;\n\n\treturn qm_set_sqc_cqc_vft(qm, fun_num, base, number);\n}\n\nstatic void qm_init_eq_aeq_status(struct hisi_qm *qm)\n{\n\tstruct hisi_qm_status *status = &qm->status;\n\n\tstatus->eq_head = 0;\n\tstatus->aeq_head = 0;\n\tstatus->eqc_phase = true;\n\tstatus->aeqc_phase = true;\n}\n\nstatic void qm_enable_eq_aeq_interrupts(struct hisi_qm *qm)\n{\n\t \n\tqm_db(qm, 0, QM_DOORBELL_CMD_AEQ, qm->status.aeq_head, 0);\n\tqm_db(qm, 0, QM_DOORBELL_CMD_EQ, qm->status.eq_head, 0);\n\n\twritel(0x0, qm->io_base + QM_VF_EQ_INT_MASK);\n\twritel(0x0, qm->io_base + QM_VF_AEQ_INT_MASK);\n}\n\nstatic void qm_disable_eq_aeq_interrupts(struct hisi_qm *qm)\n{\n\twritel(0x1, qm->io_base + QM_VF_EQ_INT_MASK);\n\twritel(0x1, qm->io_base + QM_VF_AEQ_INT_MASK);\n}\n\nstatic int qm_eq_ctx_cfg(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tstruct qm_eqc *eqc;\n\tdma_addr_t eqc_dma;\n\tint ret;\n\n\teqc = kzalloc(sizeof(struct qm_eqc), GFP_KERNEL);\n\tif (!eqc)\n\t\treturn -ENOMEM;\n\n\teqc->base_l = cpu_to_le32(lower_32_bits(qm->eqe_dma));\n\teqc->base_h = cpu_to_le32(upper_32_bits(qm->eqe_dma));\n\tif (qm->ver == QM_HW_V1)\n\t\teqc->dw3 = cpu_to_le32(QM_EQE_AEQE_SIZE);\n\teqc->dw6 = cpu_to_le32(((u32)qm->eq_depth - 1) | (1 << QM_EQC_PHASE_SHIFT));\n\n\teqc_dma = dma_map_single(dev, eqc, sizeof(struct qm_eqc),\n\t\t\t\t DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, eqc_dma)) {\n\t\tkfree(eqc);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = hisi_qm_mb(qm, QM_MB_CMD_EQC, eqc_dma, 0, 0);\n\tdma_unmap_single(dev, eqc_dma, sizeof(struct qm_eqc), DMA_TO_DEVICE);\n\tkfree(eqc);\n\n\treturn ret;\n}\n\nstatic int qm_aeq_ctx_cfg(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tstruct qm_aeqc *aeqc;\n\tdma_addr_t aeqc_dma;\n\tint ret;\n\n\taeqc = kzalloc(sizeof(struct qm_aeqc), GFP_KERNEL);\n\tif (!aeqc)\n\t\treturn -ENOMEM;\n\n\taeqc->base_l = cpu_to_le32(lower_32_bits(qm->aeqe_dma));\n\taeqc->base_h = cpu_to_le32(upper_32_bits(qm->aeqe_dma));\n\taeqc->dw6 = cpu_to_le32(((u32)qm->aeq_depth - 1) | (1 << QM_EQC_PHASE_SHIFT));\n\n\taeqc_dma = dma_map_single(dev, aeqc, sizeof(struct qm_aeqc),\n\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, aeqc_dma)) {\n\t\tkfree(aeqc);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = hisi_qm_mb(qm, QM_MB_CMD_AEQC, aeqc_dma, 0, 0);\n\tdma_unmap_single(dev, aeqc_dma, sizeof(struct qm_aeqc), DMA_TO_DEVICE);\n\tkfree(aeqc);\n\n\treturn ret;\n}\n\nstatic int qm_eq_aeq_ctx_cfg(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tint ret;\n\n\tqm_init_eq_aeq_status(qm);\n\n\tret = qm_eq_ctx_cfg(qm);\n\tif (ret) {\n\t\tdev_err(dev, \"Set eqc failed!\\n\");\n\t\treturn ret;\n\t}\n\n\treturn qm_aeq_ctx_cfg(qm);\n}\n\nstatic int __hisi_qm_start(struct hisi_qm *qm)\n{\n\tint ret;\n\n\tWARN_ON(!qm->qdma.va);\n\n\tif (qm->fun_type == QM_HW_PF) {\n\t\tret = hisi_qm_set_vft(qm, 0, qm->qp_base, qm->qp_num);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = qm_eq_aeq_ctx_cfg(qm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_qm_mb(qm, QM_MB_CMD_SQC_BT, qm->sqc_dma, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_qm_mb(qm, QM_MB_CMD_CQC_BT, qm->cqc_dma, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tqm_init_prefetch(qm);\n\tqm_enable_eq_aeq_interrupts(qm);\n\n\treturn 0;\n}\n\n \nint hisi_qm_start(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tint ret = 0;\n\n\tdown_write(&qm->qps_lock);\n\n\tif (!qm_avail_state(qm, QM_START)) {\n\t\tup_write(&qm->qps_lock);\n\t\treturn -EPERM;\n\t}\n\n\tdev_dbg(dev, \"qm start with %u queue pairs\\n\", qm->qp_num);\n\n\tif (!qm->qp_num) {\n\t\tdev_err(dev, \"qp_num should not be 0\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\n\tret = __hisi_qm_start(qm);\n\tif (!ret)\n\t\tatomic_set(&qm->status.flags, QM_START);\n\n\thisi_qm_set_state(qm, QM_READY);\nerr_unlock:\n\tup_write(&qm->qps_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_start);\n\nstatic int qm_restart(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tstruct hisi_qp *qp;\n\tint ret, i;\n\n\tret = hisi_qm_start(qm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdown_write(&qm->qps_lock);\n\tfor (i = 0; i < qm->qp_num; i++) {\n\t\tqp = &qm->qp_array[i];\n\t\tif (atomic_read(&qp->qp_status.flags) == QP_STOP &&\n\t\t    qp->is_resetting == true) {\n\t\t\tret = qm_start_qp_nolock(qp, 0);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Failed to start qp%d!\\n\", i);\n\n\t\t\t\tup_write(&qm->qps_lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tqp->is_resetting = false;\n\t\t}\n\t}\n\tup_write(&qm->qps_lock);\n\n\treturn 0;\n}\n\n \nstatic int qm_stop_started_qp(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tstruct hisi_qp *qp;\n\tint i, ret;\n\n\tfor (i = 0; i < qm->qp_num; i++) {\n\t\tqp = &qm->qp_array[i];\n\t\tif (qp && atomic_read(&qp->qp_status.flags) == QP_START) {\n\t\t\tqp->is_resetting = true;\n\t\t\tret = qm_stop_qp_nolock(qp);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Failed to stop qp%d!\\n\", i);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void qm_clear_queues(struct hisi_qm *qm)\n{\n\tstruct hisi_qp *qp;\n\tint i;\n\n\tfor (i = 0; i < qm->qp_num; i++) {\n\t\tqp = &qm->qp_array[i];\n\t\tif (qp->is_in_kernel && qp->is_resetting)\n\t\t\tmemset(qp->qdma.va, 0, qp->qdma.size);\n\t}\n\n\tmemset(qm->qdma.va, 0, qm->qdma.size);\n}\n\n \nint hisi_qm_stop(struct hisi_qm *qm, enum qm_stop_reason r)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tint ret = 0;\n\n\tdown_write(&qm->qps_lock);\n\n\tqm->status.stop_reason = r;\n\tif (!qm_avail_state(qm, QM_STOP)) {\n\t\tret = -EPERM;\n\t\tgoto err_unlock;\n\t}\n\n\tif (qm->status.stop_reason == QM_SOFT_RESET ||\n\t    qm->status.stop_reason == QM_DOWN) {\n\t\thisi_qm_set_hw_reset(qm, QM_RESET_STOP_TX_OFFSET);\n\t\tret = qm_stop_started_qp(qm);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to stop started qp!\\n\");\n\t\t\tgoto err_unlock;\n\t\t}\n\t\thisi_qm_set_hw_reset(qm, QM_RESET_STOP_RX_OFFSET);\n\t}\n\n\tqm_disable_eq_aeq_interrupts(qm);\n\tif (qm->fun_type == QM_HW_PF) {\n\t\tret = hisi_qm_set_vft(qm, 0, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to set vft!\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\tqm_clear_queues(qm);\n\tatomic_set(&qm->status.flags, QM_STOP);\n\nerr_unlock:\n\tup_write(&qm->qps_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_stop);\n\nstatic void qm_hw_error_init(struct hisi_qm *qm)\n{\n\tif (!qm->ops->hw_error_init) {\n\t\tdev_err(&qm->pdev->dev, \"QM doesn't support hw error handling!\\n\");\n\t\treturn;\n\t}\n\n\tqm->ops->hw_error_init(qm);\n}\n\nstatic void qm_hw_error_uninit(struct hisi_qm *qm)\n{\n\tif (!qm->ops->hw_error_uninit) {\n\t\tdev_err(&qm->pdev->dev, \"Unexpected QM hw error uninit!\\n\");\n\t\treturn;\n\t}\n\n\tqm->ops->hw_error_uninit(qm);\n}\n\nstatic enum acc_err_result qm_hw_error_handle(struct hisi_qm *qm)\n{\n\tif (!qm->ops->hw_error_handle) {\n\t\tdev_err(&qm->pdev->dev, \"QM doesn't support hw error report!\\n\");\n\t\treturn ACC_ERR_NONE;\n\t}\n\n\treturn qm->ops->hw_error_handle(qm);\n}\n\n \nvoid hisi_qm_dev_err_init(struct hisi_qm *qm)\n{\n\tif (qm->fun_type == QM_HW_VF)\n\t\treturn;\n\n\tqm_hw_error_init(qm);\n\n\tif (!qm->err_ini->hw_err_enable) {\n\t\tdev_err(&qm->pdev->dev, \"Device doesn't support hw error init!\\n\");\n\t\treturn;\n\t}\n\tqm->err_ini->hw_err_enable(qm);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_dev_err_init);\n\n \nvoid hisi_qm_dev_err_uninit(struct hisi_qm *qm)\n{\n\tif (qm->fun_type == QM_HW_VF)\n\t\treturn;\n\n\tqm_hw_error_uninit(qm);\n\n\tif (!qm->err_ini->hw_err_disable) {\n\t\tdev_err(&qm->pdev->dev, \"Unexpected device hw error uninit!\\n\");\n\t\treturn;\n\t}\n\tqm->err_ini->hw_err_disable(qm);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_dev_err_uninit);\n\n \nvoid hisi_qm_free_qps(struct hisi_qp **qps, int qp_num)\n{\n\tint i;\n\n\tif (!qps || qp_num <= 0)\n\t\treturn;\n\n\tfor (i = qp_num - 1; i >= 0; i--)\n\t\thisi_qm_release_qp(qps[i]);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_free_qps);\n\nstatic void free_list(struct list_head *head)\n{\n\tstruct hisi_qm_resource *res, *tmp;\n\n\tlist_for_each_entry_safe(res, tmp, head, list) {\n\t\tlist_del(&res->list);\n\t\tkfree(res);\n\t}\n}\n\nstatic int hisi_qm_sort_devices(int node, struct list_head *head,\n\t\t\t\tstruct hisi_qm_list *qm_list)\n{\n\tstruct hisi_qm_resource *res, *tmp;\n\tstruct hisi_qm *qm;\n\tstruct list_head *n;\n\tstruct device *dev;\n\tint dev_node;\n\n\tlist_for_each_entry(qm, &qm_list->list, list) {\n\t\tdev = &qm->pdev->dev;\n\n\t\tdev_node = dev_to_node(dev);\n\t\tif (dev_node < 0)\n\t\t\tdev_node = 0;\n\n\t\tres = kzalloc(sizeof(*res), GFP_KERNEL);\n\t\tif (!res)\n\t\t\treturn -ENOMEM;\n\n\t\tres->qm = qm;\n\t\tres->distance = node_distance(dev_node, node);\n\t\tn = head;\n\t\tlist_for_each_entry(tmp, head, list) {\n\t\t\tif (res->distance < tmp->distance) {\n\t\t\t\tn = &tmp->list;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist_add_tail(&res->list, n);\n\t}\n\n\treturn 0;\n}\n\n \nint hisi_qm_alloc_qps_node(struct hisi_qm_list *qm_list, int qp_num,\n\t\t\t   u8 alg_type, int node, struct hisi_qp **qps)\n{\n\tstruct hisi_qm_resource *tmp;\n\tint ret = -ENODEV;\n\tLIST_HEAD(head);\n\tint i;\n\n\tif (!qps || !qm_list || qp_num <= 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&qm_list->lock);\n\tif (hisi_qm_sort_devices(node, &head, qm_list)) {\n\t\tmutex_unlock(&qm_list->lock);\n\t\tgoto err;\n\t}\n\n\tlist_for_each_entry(tmp, &head, list) {\n\t\tfor (i = 0; i < qp_num; i++) {\n\t\t\tqps[i] = hisi_qm_create_qp(tmp->qm, alg_type);\n\t\t\tif (IS_ERR(qps[i])) {\n\t\t\t\thisi_qm_free_qps(qps, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == qp_num) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&qm_list->lock);\n\tif (ret)\n\t\tpr_info(\"Failed to create qps, node[%d], alg[%u], qp[%d]!\\n\",\n\t\t\tnode, alg_type, qp_num);\n\nerr:\n\tfree_list(&head);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_alloc_qps_node);\n\nstatic int qm_vf_q_assign(struct hisi_qm *qm, u32 num_vfs)\n{\n\tu32 remain_q_num, vfs_q_num, act_q_num, q_num, i, j;\n\tu32 max_qp_num = qm->max_qp_num;\n\tu32 q_base = qm->qp_num;\n\tint ret;\n\n\tif (!num_vfs)\n\t\treturn -EINVAL;\n\n\tvfs_q_num = qm->ctrl_qp_num - qm->qp_num;\n\n\t \n\tif (vfs_q_num < num_vfs)\n\t\treturn -EINVAL;\n\n\tq_num = vfs_q_num / num_vfs;\n\tremain_q_num = vfs_q_num % num_vfs;\n\n\tfor (i = num_vfs; i > 0; i--) {\n\t\t \n\t\tif (i == num_vfs && q_num + remain_q_num <= max_qp_num) {\n\t\t\tact_q_num = q_num + remain_q_num;\n\t\t\tremain_q_num = 0;\n\t\t} else if (remain_q_num > 0) {\n\t\t\tact_q_num = q_num + 1;\n\t\t\tremain_q_num--;\n\t\t} else {\n\t\t\tact_q_num = q_num;\n\t\t}\n\n\t\tact_q_num = min(act_q_num, max_qp_num);\n\t\tret = hisi_qm_set_vft(qm, i, q_base, act_q_num);\n\t\tif (ret) {\n\t\t\tfor (j = num_vfs; j > i; j--)\n\t\t\t\thisi_qm_set_vft(qm, j, 0, 0);\n\t\t\treturn ret;\n\t\t}\n\t\tq_base += act_q_num;\n\t}\n\n\treturn 0;\n}\n\nstatic int qm_clear_vft_config(struct hisi_qm *qm)\n{\n\tint ret;\n\tu32 i;\n\n\tfor (i = 1; i <= qm->vfs_num; i++) {\n\t\tret = hisi_qm_set_vft(qm, i, 0, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tqm->vfs_num = 0;\n\n\treturn 0;\n}\n\nstatic int qm_func_shaper_enable(struct hisi_qm *qm, u32 fun_index, u32 qos)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tu32 ir = qos * QM_QOS_RATE;\n\tint ret, total_vfs, i;\n\n\ttotal_vfs = pci_sriov_get_totalvfs(qm->pdev);\n\tif (fun_index > total_vfs)\n\t\treturn -EINVAL;\n\n\tqm->factor[fun_index].func_qos = qos;\n\n\tret = qm_get_shaper_para(ir, &qm->factor[fun_index]);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to calculate shaper parameter!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = ALG_TYPE_0; i <= ALG_TYPE_1; i++) {\n\t\t \n\t\tret = qm_set_vft_common(qm, SHAPER_VFT, fun_index, i, 1);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"type: %d, failed to set shaper vft!\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic u32 qm_get_shaper_vft_qos(struct hisi_qm *qm, u32 fun_index)\n{\n\tu64 cir_u = 0, cir_b = 0, cir_s = 0;\n\tu64 shaper_vft, ir_calc, ir;\n\tunsigned int val;\n\tu32 error_rate;\n\tint ret;\n\n\tret = readl_relaxed_poll_timeout(qm->io_base + QM_VFT_CFG_RDY, val,\n\t\t\t\t\t val & BIT(0), POLL_PERIOD,\n\t\t\t\t\t POLL_TIMEOUT);\n\tif (ret)\n\t\treturn 0;\n\n\twritel(0x1, qm->io_base + QM_VFT_CFG_OP_WR);\n\twritel(SHAPER_VFT, qm->io_base + QM_VFT_CFG_TYPE);\n\twritel(fun_index, qm->io_base + QM_VFT_CFG);\n\n\twritel(0x0, qm->io_base + QM_VFT_CFG_RDY);\n\twritel(0x1, qm->io_base + QM_VFT_CFG_OP_ENABLE);\n\n\tret = readl_relaxed_poll_timeout(qm->io_base + QM_VFT_CFG_RDY, val,\n\t\t\t\t\t val & BIT(0), POLL_PERIOD,\n\t\t\t\t\t POLL_TIMEOUT);\n\tif (ret)\n\t\treturn 0;\n\n\tshaper_vft = readl(qm->io_base + QM_VFT_CFG_DATA_L) |\n\t\t  ((u64)readl(qm->io_base + QM_VFT_CFG_DATA_H) << 32);\n\n\tcir_b = shaper_vft & QM_SHAPER_CIR_B_MASK;\n\tcir_u = shaper_vft & QM_SHAPER_CIR_U_MASK;\n\tcir_u = cir_u >> QM_SHAPER_FACTOR_CIR_U_SHIFT;\n\n\tcir_s = shaper_vft & QM_SHAPER_CIR_S_MASK;\n\tcir_s = cir_s >> QM_SHAPER_FACTOR_CIR_S_SHIFT;\n\n\tir_calc = acc_shaper_para_calc(cir_b, cir_u, cir_s);\n\n\tir = qm->factor[fun_index].func_qos * QM_QOS_RATE;\n\n\terror_rate = QM_QOS_EXPAND_RATE * (u32)abs(ir_calc - ir) / ir;\n\tif (error_rate > QM_QOS_MIN_ERROR_RATE) {\n\t\tpci_err(qm->pdev, \"error_rate: %u, get function qos is error!\\n\", error_rate);\n\t\treturn 0;\n\t}\n\n\treturn ir;\n}\n\nstatic void qm_vf_get_qos(struct hisi_qm *qm, u32 fun_num)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tu64 mb_cmd;\n\tu32 qos;\n\tint ret;\n\n\tqos = qm_get_shaper_vft_qos(qm, fun_num);\n\tif (!qos) {\n\t\tdev_err(dev, \"function(%u) failed to get qos by PF!\\n\", fun_num);\n\t\treturn;\n\t}\n\n\tmb_cmd = QM_PF_SET_QOS | (u64)qos << QM_MB_CMD_DATA_SHIFT;\n\tret = qm_ping_single_vf(qm, mb_cmd, fun_num);\n\tif (ret)\n\t\tdev_err(dev, \"failed to send cmd to VF(%u)!\\n\", fun_num);\n}\n\nstatic int qm_vf_read_qos(struct hisi_qm *qm)\n{\n\tint cnt = 0;\n\tint ret = -EINVAL;\n\n\t \n\tqm->mb_qos = 0;\n\n\t \n\tret = qm_ping_pf(qm, QM_VF_GET_QOS);\n\tif (ret) {\n\t\tpci_err(qm->pdev, \"failed to send cmd to PF to get qos!\\n\");\n\t\treturn ret;\n\t}\n\n\twhile (true) {\n\t\tmsleep(QM_WAIT_DST_ACK);\n\t\tif (qm->mb_qos)\n\t\t\tbreak;\n\n\t\tif (++cnt > QM_MAX_VF_WAIT_COUNT) {\n\t\t\tpci_err(qm->pdev, \"PF ping VF timeout!\\n\");\n\t\t\treturn  -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t qm_algqos_read(struct file *filp, char __user *buf,\n\t\t\t       size_t count, loff_t *pos)\n{\n\tstruct hisi_qm *qm = filp->private_data;\n\tchar tbuf[QM_DBG_READ_LEN];\n\tu32 qos_val, ir;\n\tint ret;\n\n\tret = hisi_qm_get_dfx_access(qm);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (test_and_set_bit(QM_RESETTING, &qm->misc_ctl)) {\n\t\tpci_err(qm->pdev, \"dev resetting, read alg qos failed!\\n\");\n\t\tret = -EAGAIN;\n\t\tgoto err_put_dfx_access;\n\t}\n\n\tif (qm->fun_type == QM_HW_PF) {\n\t\tir = qm_get_shaper_vft_qos(qm, 0);\n\t} else {\n\t\tret = qm_vf_read_qos(qm);\n\t\tif (ret)\n\t\t\tgoto err_get_status;\n\t\tir = qm->mb_qos;\n\t}\n\n\tqos_val = ir / QM_QOS_RATE;\n\tret = scnprintf(tbuf, QM_DBG_READ_LEN, \"%u\\n\", qos_val);\n\n\tret = simple_read_from_buffer(buf, count, pos, tbuf, ret);\n\nerr_get_status:\n\tclear_bit(QM_RESETTING, &qm->misc_ctl);\nerr_put_dfx_access:\n\thisi_qm_put_dfx_access(qm);\n\treturn ret;\n}\n\nstatic ssize_t qm_get_qos_value(struct hisi_qm *qm, const char *buf,\n\t\t\t       unsigned long *val,\n\t\t\t       unsigned int *fun_index)\n{\n\tconst struct bus_type *bus_type = qm->pdev->dev.bus;\n\tchar tbuf_bdf[QM_DBG_READ_LEN] = {0};\n\tchar val_buf[QM_DBG_READ_LEN] = {0};\n\tstruct pci_dev *pdev;\n\tstruct device *dev;\n\tint ret;\n\n\tret = sscanf(buf, \"%s %s\", tbuf_bdf, val_buf);\n\tif (ret != QM_QOS_PARAM_NUM)\n\t\treturn -EINVAL;\n\n\tret = kstrtoul(val_buf, 10, val);\n\tif (ret || *val == 0 || *val > QM_QOS_MAX_VAL) {\n\t\tpci_err(qm->pdev, \"input qos value is error, please set 1~1000!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = bus_find_device_by_name(bus_type, NULL, tbuf_bdf);\n\tif (!dev) {\n\t\tpci_err(qm->pdev, \"input pci bdf number is error!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpdev = container_of(dev, struct pci_dev, dev);\n\n\t*fun_index = pdev->devfn;\n\n\treturn 0;\n}\n\nstatic ssize_t qm_algqos_write(struct file *filp, const char __user *buf,\n\t\t\t       size_t count, loff_t *pos)\n{\n\tstruct hisi_qm *qm = filp->private_data;\n\tchar tbuf[QM_DBG_READ_LEN];\n\tunsigned int fun_index;\n\tunsigned long val;\n\tint len, ret;\n\n\tif (*pos != 0)\n\t\treturn 0;\n\n\tif (count >= QM_DBG_READ_LEN)\n\t\treturn -ENOSPC;\n\n\tlen = simple_write_to_buffer(tbuf, QM_DBG_READ_LEN - 1, pos, buf, count);\n\tif (len < 0)\n\t\treturn len;\n\n\ttbuf[len] = '\\0';\n\tret = qm_get_qos_value(qm, tbuf, &val, &fun_index);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (test_and_set_bit(QM_RESETTING, &qm->misc_ctl)) {\n\t\tpci_err(qm->pdev, \"dev resetting, write alg qos failed!\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tret = qm_pm_get_sync(qm);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tgoto err_get_status;\n\t}\n\n\tret = qm_func_shaper_enable(qm, fun_index, val);\n\tif (ret) {\n\t\tpci_err(qm->pdev, \"failed to enable function shaper!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_put_sync;\n\t}\n\n\tpci_info(qm->pdev, \"the qos value of function%u is set to %lu.\\n\",\n\t\t fun_index, val);\n\tret = count;\n\nerr_put_sync:\n\tqm_pm_put_sync(qm);\nerr_get_status:\n\tclear_bit(QM_RESETTING, &qm->misc_ctl);\n\treturn ret;\n}\n\nstatic const struct file_operations qm_algqos_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = qm_algqos_read,\n\t.write = qm_algqos_write,\n};\n\n \nvoid hisi_qm_set_algqos_init(struct hisi_qm *qm)\n{\n\tif (qm->fun_type == QM_HW_PF)\n\t\tdebugfs_create_file(\"alg_qos\", 0644, qm->debug.debug_root,\n\t\t\t\t    qm, &qm_algqos_fops);\n\telse if (test_bit(QM_SUPPORT_MB_COMMAND, &qm->caps))\n\t\tdebugfs_create_file(\"alg_qos\", 0444, qm->debug.debug_root,\n\t\t\t\t    qm, &qm_algqos_fops);\n}\n\nstatic void hisi_qm_init_vf_qos(struct hisi_qm *qm, int total_func)\n{\n\tint i;\n\n\tfor (i = 1; i <= total_func; i++)\n\t\tqm->factor[i].func_qos = QM_QOS_MAX_VAL;\n}\n\n \nint hisi_qm_sriov_enable(struct pci_dev *pdev, int max_vfs)\n{\n\tstruct hisi_qm *qm = pci_get_drvdata(pdev);\n\tint pre_existing_vfs, num_vfs, total_vfs, ret;\n\n\tret = qm_pm_get_sync(qm);\n\tif (ret)\n\t\treturn ret;\n\n\ttotal_vfs = pci_sriov_get_totalvfs(pdev);\n\tpre_existing_vfs = pci_num_vf(pdev);\n\tif (pre_existing_vfs) {\n\t\tpci_err(pdev, \"%d VFs already enabled. Please disable pre-enabled VFs!\\n\",\n\t\t\tpre_existing_vfs);\n\t\tgoto err_put_sync;\n\t}\n\n\tif (max_vfs > total_vfs) {\n\t\tpci_err(pdev, \"%d VFs is more than total VFs %d!\\n\", max_vfs, total_vfs);\n\t\tret = -ERANGE;\n\t\tgoto err_put_sync;\n\t}\n\n\tnum_vfs = max_vfs;\n\n\tif (test_bit(QM_SUPPORT_FUNC_QOS, &qm->caps))\n\t\thisi_qm_init_vf_qos(qm, num_vfs);\n\n\tret = qm_vf_q_assign(qm, num_vfs);\n\tif (ret) {\n\t\tpci_err(pdev, \"Can't assign queues for VF!\\n\");\n\t\tgoto err_put_sync;\n\t}\n\n\tqm->vfs_num = num_vfs;\n\n\tret = pci_enable_sriov(pdev, num_vfs);\n\tif (ret) {\n\t\tpci_err(pdev, \"Can't enable VF!\\n\");\n\t\tqm_clear_vft_config(qm);\n\t\tgoto err_put_sync;\n\t}\n\n\tpci_info(pdev, \"VF enabled, vfs_num(=%d)!\\n\", num_vfs);\n\n\treturn num_vfs;\n\nerr_put_sync:\n\tqm_pm_put_sync(qm);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_sriov_enable);\n\n \nint hisi_qm_sriov_disable(struct pci_dev *pdev, bool is_frozen)\n{\n\tstruct hisi_qm *qm = pci_get_drvdata(pdev);\n\tint ret;\n\n\tif (pci_vfs_assigned(pdev)) {\n\t\tpci_err(pdev, \"Failed to disable VFs as VFs are assigned!\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (!is_frozen && qm_try_frozen_vfs(pdev, qm->qm_list)) {\n\t\tpci_err(pdev, \"Task is using its VF!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tpci_disable_sriov(pdev);\n\n\tret = qm_clear_vft_config(qm);\n\tif (ret)\n\t\treturn ret;\n\n\tqm_pm_put_sync(qm);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_sriov_disable);\n\n \nint hisi_qm_sriov_configure(struct pci_dev *pdev, int num_vfs)\n{\n\tif (num_vfs == 0)\n\t\treturn hisi_qm_sriov_disable(pdev, false);\n\telse\n\t\treturn hisi_qm_sriov_enable(pdev, num_vfs);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_sriov_configure);\n\nstatic enum acc_err_result qm_dev_err_handle(struct hisi_qm *qm)\n{\n\tu32 err_sts;\n\n\tif (!qm->err_ini->get_dev_hw_err_status) {\n\t\tdev_err(&qm->pdev->dev, \"Device doesn't support get hw error status!\\n\");\n\t\treturn ACC_ERR_NONE;\n\t}\n\n\t \n\terr_sts = qm->err_ini->get_dev_hw_err_status(qm);\n\tif (err_sts) {\n\t\tif (err_sts & qm->err_info.ecc_2bits_mask)\n\t\t\tqm->err_status.is_dev_ecc_mbit = true;\n\n\t\tif (qm->err_ini->log_dev_hw_err)\n\t\t\tqm->err_ini->log_dev_hw_err(qm, err_sts);\n\n\t\tif (err_sts & qm->err_info.dev_reset_mask)\n\t\t\treturn ACC_ERR_NEED_RESET;\n\n\t\tif (qm->err_ini->clear_dev_hw_err_status)\n\t\t\tqm->err_ini->clear_dev_hw_err_status(qm, err_sts);\n\t}\n\n\treturn ACC_ERR_RECOVERED;\n}\n\nstatic enum acc_err_result qm_process_dev_error(struct hisi_qm *qm)\n{\n\tenum acc_err_result qm_ret, dev_ret;\n\n\t \n\tqm_ret = qm_hw_error_handle(qm);\n\n\t \n\tdev_ret = qm_dev_err_handle(qm);\n\n\treturn (qm_ret == ACC_ERR_NEED_RESET ||\n\t\tdev_ret == ACC_ERR_NEED_RESET) ?\n\t\tACC_ERR_NEED_RESET : ACC_ERR_RECOVERED;\n}\n\n \npci_ers_result_t hisi_qm_dev_err_detected(struct pci_dev *pdev,\n\t\t\t\t\t  pci_channel_state_t state)\n{\n\tstruct hisi_qm *qm = pci_get_drvdata(pdev);\n\tenum acc_err_result ret;\n\n\tif (pdev->is_virtfn)\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\tpci_info(pdev, \"PCI error detected, state(=%u)!!\\n\", state);\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tret = qm_process_dev_error(qm);\n\tif (ret == ACC_ERR_NEED_RESET)\n\t\treturn PCI_ERS_RESULT_NEED_RESET;\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_dev_err_detected);\n\nstatic int qm_check_req_recv(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tint ret;\n\tu32 val;\n\n\tif (qm->ver >= QM_HW_V3)\n\t\treturn 0;\n\n\twritel(ACC_VENDOR_ID_VALUE, qm->io_base + QM_PEH_VENDOR_ID);\n\tret = readl_relaxed_poll_timeout(qm->io_base + QM_PEH_VENDOR_ID, val,\n\t\t\t\t\t (val == ACC_VENDOR_ID_VALUE),\n\t\t\t\t\t POLL_PERIOD, POLL_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Fails to read QM reg!\\n\");\n\t\treturn ret;\n\t}\n\n\twritel(PCI_VENDOR_ID_HUAWEI, qm->io_base + QM_PEH_VENDOR_ID);\n\tret = readl_relaxed_poll_timeout(qm->io_base + QM_PEH_VENDOR_ID, val,\n\t\t\t\t\t (val == PCI_VENDOR_ID_HUAWEI),\n\t\t\t\t\t POLL_PERIOD, POLL_TIMEOUT);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Fails to read QM reg in the second time!\\n\");\n\n\treturn ret;\n}\n\nstatic int qm_set_pf_mse(struct hisi_qm *qm, bool set)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tu16 cmd;\n\tint i;\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tif (set)\n\t\tcmd |= PCI_COMMAND_MEMORY;\n\telse\n\t\tcmd &= ~PCI_COMMAND_MEMORY;\n\n\tpci_write_config_word(pdev, PCI_COMMAND, cmd);\n\tfor (i = 0; i < MAX_WAIT_COUNTS; i++) {\n\t\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\t\tif (set == ((cmd & PCI_COMMAND_MEMORY) >> 1))\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int qm_set_vf_mse(struct hisi_qm *qm, bool set)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tu16 sriov_ctrl;\n\tint pos;\n\tint i;\n\n\tpos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);\n\tpci_read_config_word(pdev, pos + PCI_SRIOV_CTRL, &sriov_ctrl);\n\tif (set)\n\t\tsriov_ctrl |= PCI_SRIOV_CTRL_MSE;\n\telse\n\t\tsriov_ctrl &= ~PCI_SRIOV_CTRL_MSE;\n\tpci_write_config_word(pdev, pos + PCI_SRIOV_CTRL, sriov_ctrl);\n\n\tfor (i = 0; i < MAX_WAIT_COUNTS; i++) {\n\t\tpci_read_config_word(pdev, pos + PCI_SRIOV_CTRL, &sriov_ctrl);\n\t\tif (set == (sriov_ctrl & PCI_SRIOV_CTRL_MSE) >>\n\t\t    ACC_PEH_SRIOV_CTRL_VF_MSE_SHIFT)\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int qm_vf_reset_prepare(struct hisi_qm *qm,\n\t\t\t       enum qm_stop_reason stop_reason)\n{\n\tstruct hisi_qm_list *qm_list = qm->qm_list;\n\tstruct pci_dev *pdev = qm->pdev;\n\tstruct pci_dev *virtfn;\n\tstruct hisi_qm *vf_qm;\n\tint ret = 0;\n\n\tmutex_lock(&qm_list->lock);\n\tlist_for_each_entry(vf_qm, &qm_list->list, list) {\n\t\tvirtfn = vf_qm->pdev;\n\t\tif (virtfn == pdev)\n\t\t\tcontinue;\n\n\t\tif (pci_physfn(virtfn) == pdev) {\n\t\t\t \n\t\t\tpci_save_state(virtfn);\n\n\t\t\tret = hisi_qm_stop(vf_qm, stop_reason);\n\t\t\tif (ret)\n\t\t\t\tgoto stop_fail;\n\t\t}\n\t}\n\nstop_fail:\n\tmutex_unlock(&qm_list->lock);\n\treturn ret;\n}\n\nstatic int qm_try_stop_vfs(struct hisi_qm *qm, u64 cmd,\n\t\t\t   enum qm_stop_reason stop_reason)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tint ret;\n\n\tif (!qm->vfs_num)\n\t\treturn 0;\n\n\t \n\tif (test_bit(QM_SUPPORT_MB_COMMAND, &qm->caps)) {\n\t\tret = qm_ping_all_vfs(qm, cmd);\n\t\tif (ret)\n\t\t\tpci_err(pdev, \"failed to send cmd to all VFs before PF reset!\\n\");\n\t} else {\n\t\tret = qm_vf_reset_prepare(qm, stop_reason);\n\t\tif (ret)\n\t\t\tpci_err(pdev, \"failed to prepare reset, ret = %d.\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int qm_controller_reset_prepare(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tint ret;\n\n\tret = qm_reset_prepare_ready(qm);\n\tif (ret) {\n\t\tpci_err(pdev, \"Controller reset not ready!\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tqm_cmd_uninit(qm);\n\n\t \n\tret = qm_try_stop_vfs(qm, QM_PF_SRST_PREPARE, QM_SOFT_RESET);\n\tif (ret)\n\t\tpci_err(pdev, \"failed to stop vfs by pf in soft reset.\\n\");\n\n\tret = hisi_qm_stop(qm, QM_SOFT_RESET);\n\tif (ret) {\n\t\tpci_err(pdev, \"Fails to stop QM!\\n\");\n\t\tqm_reset_bit_clear(qm);\n\t\treturn ret;\n\t}\n\n\tif (qm->use_sva) {\n\t\tret = qm_hw_err_isolate(qm);\n\t\tif (ret)\n\t\t\tpci_err(pdev, \"failed to isolate hw err!\\n\");\n\t}\n\n\tret = qm_wait_vf_prepare_finish(qm);\n\tif (ret)\n\t\tpci_err(pdev, \"failed to stop by vfs in soft reset!\\n\");\n\n\tclear_bit(QM_RST_SCHED, &qm->misc_ctl);\n\n\treturn 0;\n}\n\nstatic void qm_dev_ecc_mbit_handle(struct hisi_qm *qm)\n{\n\tu32 nfe_enb = 0;\n\n\t \n\tif (qm->ver >= QM_HW_V3)\n\t\treturn;\n\n\tif (!qm->err_status.is_dev_ecc_mbit &&\n\t    qm->err_status.is_qm_ecc_mbit &&\n\t    qm->err_ini->close_axi_master_ooo) {\n\t\tqm->err_ini->close_axi_master_ooo(qm);\n\t} else if (qm->err_status.is_dev_ecc_mbit &&\n\t\t   !qm->err_status.is_qm_ecc_mbit &&\n\t\t   !qm->err_ini->close_axi_master_ooo) {\n\t\tnfe_enb = readl(qm->io_base + QM_RAS_NFE_ENABLE);\n\t\twritel(nfe_enb & QM_RAS_NFE_MBIT_DISABLE,\n\t\t       qm->io_base + QM_RAS_NFE_ENABLE);\n\t\twritel(QM_ECC_MBIT, qm->io_base + QM_ABNORMAL_INT_SET);\n\t}\n}\n\nstatic int qm_soft_reset(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tint ret;\n\tu32 val;\n\n\t \n\tret = qm_check_req_recv(qm);\n\tif (ret)\n\t\treturn ret;\n\n\tif (qm->vfs_num) {\n\t\tret = qm_set_vf_mse(qm, false);\n\t\tif (ret) {\n\t\t\tpci_err(pdev, \"Fails to disable vf MSE bit.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = qm->ops->set_msi(qm, false);\n\tif (ret) {\n\t\tpci_err(pdev, \"Fails to disable PEH MSI bit.\\n\");\n\t\treturn ret;\n\t}\n\n\tqm_dev_ecc_mbit_handle(qm);\n\n\t \n\twritel(ACC_MASTER_GLOBAL_CTRL_SHUTDOWN,\n\t       qm->io_base + ACC_MASTER_GLOBAL_CTRL);\n\n\t \n\tret = readl_relaxed_poll_timeout(qm->io_base + ACC_MASTER_TRANS_RETURN,\n\t\t\t\t\t val,\n\t\t\t\t\t (val == ACC_MASTER_TRANS_RETURN_RW),\n\t\t\t\t\t POLL_PERIOD, POLL_TIMEOUT);\n\tif (ret) {\n\t\tpci_emerg(pdev, \"Bus lock! Please reset system.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (qm->err_ini->close_sva_prefetch)\n\t\tqm->err_ini->close_sva_prefetch(qm);\n\n\tret = qm_set_pf_mse(qm, false);\n\tif (ret) {\n\t\tpci_err(pdev, \"Fails to disable pf MSE bit.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (ACPI_HANDLE(&pdev->dev)) {\n\t\tunsigned long long value = 0;\n\t\tacpi_status s;\n\n\t\ts = acpi_evaluate_integer(ACPI_HANDLE(&pdev->dev),\n\t\t\t\t\t  qm->err_info.acpi_rst,\n\t\t\t\t\t  NULL, &value);\n\t\tif (ACPI_FAILURE(s)) {\n\t\t\tpci_err(pdev, \"NO controller reset method!\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (value) {\n\t\t\tpci_err(pdev, \"Reset step %llu failed!\\n\", value);\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\tpci_err(pdev, \"No reset method!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int qm_vf_reset_done(struct hisi_qm *qm)\n{\n\tstruct hisi_qm_list *qm_list = qm->qm_list;\n\tstruct pci_dev *pdev = qm->pdev;\n\tstruct pci_dev *virtfn;\n\tstruct hisi_qm *vf_qm;\n\tint ret = 0;\n\n\tmutex_lock(&qm_list->lock);\n\tlist_for_each_entry(vf_qm, &qm_list->list, list) {\n\t\tvirtfn = vf_qm->pdev;\n\t\tif (virtfn == pdev)\n\t\t\tcontinue;\n\n\t\tif (pci_physfn(virtfn) == pdev) {\n\t\t\t \n\t\t\tpci_restore_state(virtfn);\n\n\t\t\tret = qm_restart(vf_qm);\n\t\t\tif (ret)\n\t\t\t\tgoto restart_fail;\n\t\t}\n\t}\n\nrestart_fail:\n\tmutex_unlock(&qm_list->lock);\n\treturn ret;\n}\n\nstatic int qm_try_start_vfs(struct hisi_qm *qm, enum qm_mb_cmd cmd)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tint ret;\n\n\tif (!qm->vfs_num)\n\t\treturn 0;\n\n\tret = qm_vf_q_assign(qm, qm->vfs_num);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to assign VFs, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (test_bit(QM_SUPPORT_MB_COMMAND, &qm->caps)) {\n\t\tret = qm_ping_all_vfs(qm, cmd);\n\t\tif (ret)\n\t\t\tpci_warn(pdev, \"failed to send cmd to all VFs after PF reset!\\n\");\n\t} else {\n\t\tret = qm_vf_reset_done(qm);\n\t\tif (ret)\n\t\t\tpci_warn(pdev, \"failed to start vfs, ret = %d.\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int qm_dev_hw_init(struct hisi_qm *qm)\n{\n\treturn qm->err_ini->hw_init(qm);\n}\n\nstatic void qm_restart_prepare(struct hisi_qm *qm)\n{\n\tu32 value;\n\n\tif (qm->err_ini->open_sva_prefetch)\n\t\tqm->err_ini->open_sva_prefetch(qm);\n\n\tif (qm->ver >= QM_HW_V3)\n\t\treturn;\n\n\tif (!qm->err_status.is_qm_ecc_mbit &&\n\t    !qm->err_status.is_dev_ecc_mbit)\n\t\treturn;\n\n\t \n\tvalue = readl(qm->io_base + ACC_AM_CFG_PORT_WR_EN);\n\twritel(value & ~qm->err_info.msi_wr_port,\n\t       qm->io_base + ACC_AM_CFG_PORT_WR_EN);\n\n\t \n\tvalue = qm_get_dev_err_status(qm) & qm->err_info.ecc_2bits_mask;\n\tif (value && qm->err_ini->clear_dev_hw_err_status)\n\t\tqm->err_ini->clear_dev_hw_err_status(qm, value);\n\n\t \n\twritel(QM_ECC_MBIT, qm->io_base + QM_ABNORMAL_INT_SOURCE);\n\n\t \n\twritel(ACC_ROB_ECC_ERR_MULTPL, qm->io_base + ACC_AM_ROB_ECC_INT_STS);\n}\n\nstatic void qm_restart_done(struct hisi_qm *qm)\n{\n\tu32 value;\n\n\tif (qm->ver >= QM_HW_V3)\n\t\tgoto clear_flags;\n\n\tif (!qm->err_status.is_qm_ecc_mbit &&\n\t    !qm->err_status.is_dev_ecc_mbit)\n\t\treturn;\n\n\t \n\tvalue = readl(qm->io_base + ACC_AM_CFG_PORT_WR_EN);\n\tvalue |= qm->err_info.msi_wr_port;\n\twritel(value, qm->io_base + ACC_AM_CFG_PORT_WR_EN);\n\nclear_flags:\n\tqm->err_status.is_qm_ecc_mbit = false;\n\tqm->err_status.is_dev_ecc_mbit = false;\n}\n\nstatic int qm_controller_reset_done(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tint ret;\n\n\tret = qm->ops->set_msi(qm, true);\n\tif (ret) {\n\t\tpci_err(pdev, \"Fails to enable PEH MSI bit!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = qm_set_pf_mse(qm, true);\n\tif (ret) {\n\t\tpci_err(pdev, \"Fails to enable pf MSE bit!\\n\");\n\t\treturn ret;\n\t}\n\n\tif (qm->vfs_num) {\n\t\tret = qm_set_vf_mse(qm, true);\n\t\tif (ret) {\n\t\t\tpci_err(pdev, \"Fails to enable vf MSE bit!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = qm_dev_hw_init(qm);\n\tif (ret) {\n\t\tpci_err(pdev, \"Failed to init device\\n\");\n\t\treturn ret;\n\t}\n\n\tqm_restart_prepare(qm);\n\thisi_qm_dev_err_init(qm);\n\tif (qm->err_ini->open_axi_master_ooo)\n\t\tqm->err_ini->open_axi_master_ooo(qm);\n\n\tret = qm_dev_mem_reset(qm);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to reset device memory\\n\");\n\t\treturn ret;\n\t}\n\n\tret = qm_restart(qm);\n\tif (ret) {\n\t\tpci_err(pdev, \"Failed to start QM!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = qm_try_start_vfs(qm, QM_PF_RESET_DONE);\n\tif (ret)\n\t\tpci_err(pdev, \"failed to start vfs by pf in soft reset.\\n\");\n\n\tret = qm_wait_vf_prepare_finish(qm);\n\tif (ret)\n\t\tpci_err(pdev, \"failed to start by vfs in soft reset!\\n\");\n\n\tqm_cmd_init(qm);\n\tqm_restart_done(qm);\n\n\tqm_reset_bit_clear(qm);\n\n\treturn 0;\n}\n\nstatic int qm_controller_reset(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tint ret;\n\n\tpci_info(pdev, \"Controller resetting...\\n\");\n\n\tret = qm_controller_reset_prepare(qm);\n\tif (ret) {\n\t\thisi_qm_set_hw_reset(qm, QM_RESET_STOP_TX_OFFSET);\n\t\thisi_qm_set_hw_reset(qm, QM_RESET_STOP_RX_OFFSET);\n\t\tclear_bit(QM_RST_SCHED, &qm->misc_ctl);\n\t\treturn ret;\n\t}\n\n\thisi_qm_show_last_dfx_regs(qm);\n\tif (qm->err_ini->show_last_dfx_regs)\n\t\tqm->err_ini->show_last_dfx_regs(qm);\n\n\tret = qm_soft_reset(qm);\n\tif (ret)\n\t\tgoto err_reset;\n\n\tret = qm_controller_reset_done(qm);\n\tif (ret)\n\t\tgoto err_reset;\n\n\tpci_info(pdev, \"Controller reset complete\\n\");\n\n\treturn 0;\n\nerr_reset:\n\tpci_err(pdev, \"Controller reset failed (%d)\\n\", ret);\n\tqm_reset_bit_clear(qm);\n\n\t \n\tif (qm->use_sva)\n\t\tqm->isolate_data.is_isolate = true;\n\treturn ret;\n}\n\n \npci_ers_result_t hisi_qm_dev_slot_reset(struct pci_dev *pdev)\n{\n\tstruct hisi_qm *qm = pci_get_drvdata(pdev);\n\tint ret;\n\n\tif (pdev->is_virtfn)\n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\n\t \n\tret = qm_controller_reset(qm);\n\tif (ret) {\n\t\tpci_err(pdev, \"Controller reset failed (%d)\\n\", ret);\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_dev_slot_reset);\n\nvoid hisi_qm_reset_prepare(struct pci_dev *pdev)\n{\n\tstruct hisi_qm *pf_qm = pci_get_drvdata(pci_physfn(pdev));\n\tstruct hisi_qm *qm = pci_get_drvdata(pdev);\n\tu32 delay = 0;\n\tint ret;\n\n\thisi_qm_dev_err_uninit(pf_qm);\n\n\t \n\twhile (qm_check_dev_error(pf_qm)) {\n\t\tmsleep(++delay);\n\t\tif (delay > QM_RESET_WAIT_TIMEOUT)\n\t\t\treturn;\n\t}\n\n\tret = qm_reset_prepare_ready(qm);\n\tif (ret) {\n\t\tpci_err(pdev, \"FLR not ready!\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (qm->fun_type == QM_HW_PF)\n\t\tqm_cmd_uninit(qm);\n\n\tret = qm_try_stop_vfs(qm, QM_PF_FLR_PREPARE, QM_DOWN);\n\tif (ret)\n\t\tpci_err(pdev, \"failed to stop vfs by pf in FLR.\\n\");\n\n\tret = hisi_qm_stop(qm, QM_DOWN);\n\tif (ret) {\n\t\tpci_err(pdev, \"Failed to stop QM, ret = %d.\\n\", ret);\n\t\thisi_qm_set_hw_reset(qm, QM_RESET_STOP_TX_OFFSET);\n\t\thisi_qm_set_hw_reset(qm, QM_RESET_STOP_RX_OFFSET);\n\t\treturn;\n\t}\n\n\tret = qm_wait_vf_prepare_finish(qm);\n\tif (ret)\n\t\tpci_err(pdev, \"failed to stop by vfs in FLR!\\n\");\n\n\tpci_info(pdev, \"FLR resetting...\\n\");\n}\nEXPORT_SYMBOL_GPL(hisi_qm_reset_prepare);\n\nstatic bool qm_flr_reset_complete(struct pci_dev *pdev)\n{\n\tstruct pci_dev *pf_pdev = pci_physfn(pdev);\n\tstruct hisi_qm *qm = pci_get_drvdata(pf_pdev);\n\tu32 id;\n\n\tpci_read_config_dword(qm->pdev, PCI_COMMAND, &id);\n\tif (id == QM_PCI_COMMAND_INVALID) {\n\t\tpci_err(pdev, \"Device can not be used!\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid hisi_qm_reset_done(struct pci_dev *pdev)\n{\n\tstruct hisi_qm *pf_qm = pci_get_drvdata(pci_physfn(pdev));\n\tstruct hisi_qm *qm = pci_get_drvdata(pdev);\n\tint ret;\n\n\tif (qm->fun_type == QM_HW_PF) {\n\t\tret = qm_dev_hw_init(qm);\n\t\tif (ret) {\n\t\t\tpci_err(pdev, \"Failed to init PF, ret = %d.\\n\", ret);\n\t\t\tgoto flr_done;\n\t\t}\n\t}\n\n\thisi_qm_dev_err_init(pf_qm);\n\n\tret = qm_restart(qm);\n\tif (ret) {\n\t\tpci_err(pdev, \"Failed to start QM, ret = %d.\\n\", ret);\n\t\tgoto flr_done;\n\t}\n\n\tret = qm_try_start_vfs(qm, QM_PF_RESET_DONE);\n\tif (ret)\n\t\tpci_err(pdev, \"failed to start vfs by pf in FLR.\\n\");\n\n\tret = qm_wait_vf_prepare_finish(qm);\n\tif (ret)\n\t\tpci_err(pdev, \"failed to start by vfs in FLR!\\n\");\n\nflr_done:\n\tif (qm->fun_type == QM_HW_PF)\n\t\tqm_cmd_init(qm);\n\n\tif (qm_flr_reset_complete(pdev))\n\t\tpci_info(pdev, \"FLR reset complete\\n\");\n\n\tqm_reset_bit_clear(qm);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_reset_done);\n\nstatic irqreturn_t qm_abnormal_irq(int irq, void *data)\n{\n\tstruct hisi_qm *qm = data;\n\tenum acc_err_result ret;\n\n\tatomic64_inc(&qm->debug.dfx.abnormal_irq_cnt);\n\tret = qm_process_dev_error(qm);\n\tif (ret == ACC_ERR_NEED_RESET &&\n\t    !test_bit(QM_DRIVER_REMOVING, &qm->misc_ctl) &&\n\t    !test_and_set_bit(QM_RST_SCHED, &qm->misc_ctl))\n\t\tschedule_work(&qm->rst_work);\n\n\treturn IRQ_HANDLED;\n}\n\n \nvoid hisi_qm_dev_shutdown(struct pci_dev *pdev)\n{\n\tstruct hisi_qm *qm = pci_get_drvdata(pdev);\n\tint ret;\n\n\tret = hisi_qm_stop(qm, QM_DOWN);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Fail to stop qm in shutdown!\\n\");\n\n\thisi_qm_cache_wb(qm);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_dev_shutdown);\n\nstatic void hisi_qm_controller_reset(struct work_struct *rst_work)\n{\n\tstruct hisi_qm *qm = container_of(rst_work, struct hisi_qm, rst_work);\n\tint ret;\n\n\tret = qm_pm_get_sync(qm);\n\tif (ret) {\n\t\tclear_bit(QM_RST_SCHED, &qm->misc_ctl);\n\t\treturn;\n\t}\n\n\t \n\tret = qm_controller_reset(qm);\n\tif (ret)\n\t\tdev_err(&qm->pdev->dev, \"controller reset failed (%d)\\n\", ret);\n\n\tqm_pm_put_sync(qm);\n}\n\nstatic void qm_pf_reset_vf_prepare(struct hisi_qm *qm,\n\t\t\t\t   enum qm_stop_reason stop_reason)\n{\n\tenum qm_mb_cmd cmd = QM_VF_PREPARE_DONE;\n\tstruct pci_dev *pdev = qm->pdev;\n\tint ret;\n\n\tret = qm_reset_prepare_ready(qm);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"reset prepare not ready!\\n\");\n\t\tatomic_set(&qm->status.flags, QM_STOP);\n\t\tcmd = QM_VF_PREPARE_FAIL;\n\t\tgoto err_prepare;\n\t}\n\n\tret = hisi_qm_stop(qm, stop_reason);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to stop QM, ret = %d.\\n\", ret);\n\t\tatomic_set(&qm->status.flags, QM_STOP);\n\t\tcmd = QM_VF_PREPARE_FAIL;\n\t\tgoto err_prepare;\n\t} else {\n\t\tgoto out;\n\t}\n\nerr_prepare:\n\thisi_qm_set_hw_reset(qm, QM_RESET_STOP_TX_OFFSET);\n\thisi_qm_set_hw_reset(qm, QM_RESET_STOP_RX_OFFSET);\nout:\n\tpci_save_state(pdev);\n\tret = qm_ping_pf(qm, cmd);\n\tif (ret)\n\t\tdev_warn(&pdev->dev, \"PF responds timeout in reset prepare!\\n\");\n}\n\nstatic void qm_pf_reset_vf_done(struct hisi_qm *qm)\n{\n\tenum qm_mb_cmd cmd = QM_VF_START_DONE;\n\tstruct pci_dev *pdev = qm->pdev;\n\tint ret;\n\n\tpci_restore_state(pdev);\n\tret = hisi_qm_start(qm);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to start QM, ret = %d.\\n\", ret);\n\t\tcmd = QM_VF_START_FAIL;\n\t}\n\n\tqm_cmd_init(qm);\n\tret = qm_ping_pf(qm, cmd);\n\tif (ret)\n\t\tdev_warn(&pdev->dev, \"PF responds timeout in reset done!\\n\");\n\n\tqm_reset_bit_clear(qm);\n}\n\nstatic int qm_wait_pf_reset_finish(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tu32 val, cmd;\n\tu64 msg;\n\tint ret;\n\n\t \n\tret = readl_relaxed_poll_timeout(qm->io_base + QM_IFC_INT_SOURCE_V, val,\n\t\t\t\t\t val == BIT(0), QM_VF_RESET_WAIT_US,\n\t\t\t\t\t QM_VF_RESET_WAIT_TIMEOUT_US);\n\t \n\tif (ret) {\n\t\tdev_err(dev, \"couldn't get reset done status from PF, timeout!\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tret = qm_get_mb_cmd(qm, &msg, 0);\n\tqm_clear_cmd_interrupt(qm, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get msg from PF in reset done!\\n\");\n\t\treturn ret;\n\t}\n\n\tcmd = msg & QM_MB_CMD_DATA_MASK;\n\tif (cmd != QM_PF_RESET_DONE) {\n\t\tdev_err(dev, \"the cmd(%u) is not reset done!\\n\", cmd);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void qm_pf_reset_vf_process(struct hisi_qm *qm,\n\t\t\t\t   enum qm_stop_reason stop_reason)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tint ret;\n\n\tdev_info(dev, \"device reset start...\\n\");\n\n\t \n\tqm_cmd_uninit(qm);\n\tqm_pf_reset_vf_prepare(qm, stop_reason);\n\n\tret = qm_wait_pf_reset_finish(qm);\n\tif (ret)\n\t\tgoto err_get_status;\n\n\tqm_pf_reset_vf_done(qm);\n\n\tdev_info(dev, \"device reset done.\\n\");\n\n\treturn;\n\nerr_get_status:\n\tqm_cmd_init(qm);\n\tqm_reset_bit_clear(qm);\n}\n\nstatic void qm_handle_cmd_msg(struct hisi_qm *qm, u32 fun_num)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tu64 msg;\n\tu32 cmd;\n\tint ret;\n\n\t \n\tret = qm_get_mb_cmd(qm, &msg, fun_num);\n\tqm_clear_cmd_interrupt(qm, BIT(fun_num));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get msg from source!\\n\");\n\t\treturn;\n\t}\n\n\tcmd = msg & QM_MB_CMD_DATA_MASK;\n\tswitch (cmd) {\n\tcase QM_PF_FLR_PREPARE:\n\t\tqm_pf_reset_vf_process(qm, QM_DOWN);\n\t\tbreak;\n\tcase QM_PF_SRST_PREPARE:\n\t\tqm_pf_reset_vf_process(qm, QM_SOFT_RESET);\n\t\tbreak;\n\tcase QM_VF_GET_QOS:\n\t\tqm_vf_get_qos(qm, fun_num);\n\t\tbreak;\n\tcase QM_PF_SET_QOS:\n\t\tqm->mb_qos = msg >> QM_MB_CMD_DATA_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported cmd %u sent by function(%u)!\\n\", cmd, fun_num);\n\t\tbreak;\n\t}\n}\n\nstatic void qm_cmd_process(struct work_struct *cmd_process)\n{\n\tstruct hisi_qm *qm = container_of(cmd_process,\n\t\t\t\t\tstruct hisi_qm, cmd_process);\n\tu32 vfs_num = qm->vfs_num;\n\tu64 val;\n\tu32 i;\n\n\tif (qm->fun_type == QM_HW_PF) {\n\t\tval = readq(qm->io_base + QM_IFC_INT_SOURCE_P);\n\t\tif (!val)\n\t\t\treturn;\n\n\t\tfor (i = 1; i <= vfs_num; i++) {\n\t\t\tif (val & BIT(i))\n\t\t\t\tqm_handle_cmd_msg(qm, i);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tqm_handle_cmd_msg(qm, 0);\n}\n\n \nint hisi_qm_alg_register(struct hisi_qm *qm, struct hisi_qm_list *qm_list)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tint flag = 0;\n\tint ret = 0;\n\n\tmutex_lock(&qm_list->lock);\n\tif (list_empty(&qm_list->list))\n\t\tflag = 1;\n\tlist_add_tail(&qm->list, &qm_list->list);\n\tmutex_unlock(&qm_list->lock);\n\n\tif (qm->ver <= QM_HW_V2 && qm->use_sva) {\n\t\tdev_info(dev, \"HW V2 not both use uacce sva mode and hardware crypto algs.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (flag) {\n\t\tret = qm_list->register_to_crypto(qm);\n\t\tif (ret) {\n\t\t\tmutex_lock(&qm_list->lock);\n\t\t\tlist_del(&qm->list);\n\t\t\tmutex_unlock(&qm_list->lock);\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_alg_register);\n\n \nvoid hisi_qm_alg_unregister(struct hisi_qm *qm, struct hisi_qm_list *qm_list)\n{\n\tmutex_lock(&qm_list->lock);\n\tlist_del(&qm->list);\n\tmutex_unlock(&qm_list->lock);\n\n\tif (qm->ver <= QM_HW_V2 && qm->use_sva)\n\t\treturn;\n\n\tif (list_empty(&qm_list->list))\n\t\tqm_list->unregister_from_crypto(qm);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_alg_unregister);\n\nstatic void qm_unregister_abnormal_irq(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tu32 irq_vector, val;\n\n\tif (qm->fun_type == QM_HW_VF)\n\t\treturn;\n\n\tval = qm->cap_tables.qm_cap_table[QM_ABN_IRQ_TYPE_CAP_IDX].cap_val;\n\tif (!((val >> QM_IRQ_TYPE_SHIFT) & QM_ABN_IRQ_TYPE_MASK))\n\t\treturn;\n\n\tirq_vector = val & QM_IRQ_VECTOR_MASK;\n\tfree_irq(pci_irq_vector(pdev, irq_vector), qm);\n}\n\nstatic int qm_register_abnormal_irq(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tu32 irq_vector, val;\n\tint ret;\n\n\tif (qm->fun_type == QM_HW_VF)\n\t\treturn 0;\n\n\tval = qm->cap_tables.qm_cap_table[QM_ABN_IRQ_TYPE_CAP_IDX].cap_val;\n\tif (!((val >> QM_IRQ_TYPE_SHIFT) & QM_ABN_IRQ_TYPE_MASK))\n\t\treturn 0;\n\n\tirq_vector = val & QM_IRQ_VECTOR_MASK;\n\tret = request_irq(pci_irq_vector(pdev, irq_vector), qm_abnormal_irq, 0, qm->dev_name, qm);\n\tif (ret)\n\t\tdev_err(&qm->pdev->dev, \"failed to request abnormal irq, ret = %d\", ret);\n\n\treturn ret;\n}\n\nstatic void qm_unregister_mb_cmd_irq(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tu32 irq_vector, val;\n\n\tval = qm->cap_tables.qm_cap_table[QM_PF2VF_IRQ_TYPE_CAP_IDX].cap_val;\n\tif (!((val >> QM_IRQ_TYPE_SHIFT) & QM_IRQ_TYPE_MASK))\n\t\treturn;\n\n\tirq_vector = val & QM_IRQ_VECTOR_MASK;\n\tfree_irq(pci_irq_vector(pdev, irq_vector), qm);\n}\n\nstatic int qm_register_mb_cmd_irq(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tu32 irq_vector, val;\n\tint ret;\n\n\tval = qm->cap_tables.qm_cap_table[QM_PF2VF_IRQ_TYPE_CAP_IDX].cap_val;\n\tif (!((val >> QM_IRQ_TYPE_SHIFT) & QM_IRQ_TYPE_MASK))\n\t\treturn 0;\n\n\tirq_vector = val & QM_IRQ_VECTOR_MASK;\n\tret = request_irq(pci_irq_vector(pdev, irq_vector), qm_mb_cmd_irq, 0, qm->dev_name, qm);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to request function communication irq, ret = %d\", ret);\n\n\treturn ret;\n}\n\nstatic void qm_unregister_aeq_irq(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tu32 irq_vector, val;\n\n\tval = qm->cap_tables.qm_cap_table[QM_AEQ_IRQ_TYPE_CAP_IDX].cap_val;\n\tif (!((val >> QM_IRQ_TYPE_SHIFT) & QM_IRQ_TYPE_MASK))\n\t\treturn;\n\n\tirq_vector = val & QM_IRQ_VECTOR_MASK;\n\tfree_irq(pci_irq_vector(pdev, irq_vector), qm);\n}\n\nstatic int qm_register_aeq_irq(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tu32 irq_vector, val;\n\tint ret;\n\n\tval = qm->cap_tables.qm_cap_table[QM_AEQ_IRQ_TYPE_CAP_IDX].cap_val;\n\tif (!((val >> QM_IRQ_TYPE_SHIFT) & QM_IRQ_TYPE_MASK))\n\t\treturn 0;\n\n\tirq_vector = val & QM_IRQ_VECTOR_MASK;\n\tret = request_threaded_irq(pci_irq_vector(pdev, irq_vector), NULL,\n\t\t\t\t\t\t   qm_aeq_thread, IRQF_ONESHOT, qm->dev_name, qm);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to request eq irq, ret = %d\", ret);\n\n\treturn ret;\n}\n\nstatic void qm_unregister_eq_irq(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tu32 irq_vector, val;\n\n\tval = qm->cap_tables.qm_cap_table[QM_EQ_IRQ_TYPE_CAP_IDX].cap_val;\n\tif (!((val >> QM_IRQ_TYPE_SHIFT) & QM_IRQ_TYPE_MASK))\n\t\treturn;\n\n\tirq_vector = val & QM_IRQ_VECTOR_MASK;\n\tfree_irq(pci_irq_vector(pdev, irq_vector), qm);\n}\n\nstatic int qm_register_eq_irq(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tu32 irq_vector, val;\n\tint ret;\n\n\tval = qm->cap_tables.qm_cap_table[QM_EQ_IRQ_TYPE_CAP_IDX].cap_val;\n\tif (!((val >> QM_IRQ_TYPE_SHIFT) & QM_IRQ_TYPE_MASK))\n\t\treturn 0;\n\n\tirq_vector = val & QM_IRQ_VECTOR_MASK;\n\tret = request_irq(pci_irq_vector(pdev, irq_vector), qm_eq_irq, 0, qm->dev_name, qm);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"failed to request eq irq, ret = %d\", ret);\n\n\treturn ret;\n}\n\nstatic void qm_irqs_unregister(struct hisi_qm *qm)\n{\n\tqm_unregister_mb_cmd_irq(qm);\n\tqm_unregister_abnormal_irq(qm);\n\tqm_unregister_aeq_irq(qm);\n\tqm_unregister_eq_irq(qm);\n}\n\nstatic int qm_irqs_register(struct hisi_qm *qm)\n{\n\tint ret;\n\n\tret = qm_register_eq_irq(qm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qm_register_aeq_irq(qm);\n\tif (ret)\n\t\tgoto free_eq_irq;\n\n\tret = qm_register_abnormal_irq(qm);\n\tif (ret)\n\t\tgoto free_aeq_irq;\n\n\tret = qm_register_mb_cmd_irq(qm);\n\tif (ret)\n\t\tgoto free_abnormal_irq;\n\n\treturn 0;\n\nfree_abnormal_irq:\n\tqm_unregister_abnormal_irq(qm);\nfree_aeq_irq:\n\tqm_unregister_aeq_irq(qm);\nfree_eq_irq:\n\tqm_unregister_eq_irq(qm);\n\treturn ret;\n}\n\nstatic int qm_get_qp_num(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tbool is_db_isolation;\n\n\t \n\tif (qm->fun_type == QM_HW_VF) {\n\t\tif (qm->ver != QM_HW_V1)\n\t\t\t \n\t\t\treturn hisi_qm_get_vft(qm, &qm->qp_base, &qm->qp_num);\n\n\t\treturn 0;\n\t}\n\n\tis_db_isolation = test_bit(QM_SUPPORT_DB_ISOLATION, &qm->caps);\n\tqm->ctrl_qp_num = hisi_qm_get_hw_info(qm, qm_basic_info, QM_TOTAL_QP_NUM_CAP, true);\n\tqm->max_qp_num = hisi_qm_get_hw_info(qm, qm_basic_info,\n\t\t\t\t\t     QM_FUNC_MAX_QP_CAP, is_db_isolation);\n\n\tif (qm->qp_num <= qm->max_qp_num)\n\t\treturn 0;\n\n\tif (test_bit(QM_MODULE_PARAM, &qm->misc_ctl)) {\n\t\t \n\t\tdev_err(dev, \"qp num(%u) is more than max qp num(%u)!\\n\",\n\t\t\tqm->qp_num, qm->max_qp_num);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(dev, \"Default qp num(%u) is too big, reset it to Function's max qp num(%u)!\\n\",\n\t\t qm->qp_num, qm->max_qp_num);\n\tqm->qp_num = qm->max_qp_num;\n\tqm->debug.curr_qm_qp_num = qm->qp_num;\n\n\treturn 0;\n}\n\nstatic int qm_pre_store_irq_type_caps(struct hisi_qm *qm)\n{\n\tstruct hisi_qm_cap_record *qm_cap;\n\tstruct pci_dev *pdev = qm->pdev;\n\tsize_t i, size;\n\n\tsize = ARRAY_SIZE(qm_pre_store_caps);\n\tqm_cap = devm_kzalloc(&pdev->dev, sizeof(*qm_cap) * size, GFP_KERNEL);\n\tif (!qm_cap)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < size; i++) {\n\t\tqm_cap[i].type = qm_pre_store_caps[i];\n\t\tqm_cap[i].cap_val = hisi_qm_get_hw_info(qm, qm_basic_info,\n\t\t\t\t\t\t\tqm_pre_store_caps[i], qm->cap_ver);\n\t}\n\n\tqm->cap_tables.qm_cap_table = qm_cap;\n\n\treturn 0;\n}\n\nstatic int qm_get_hw_caps(struct hisi_qm *qm)\n{\n\tconst struct hisi_qm_cap_info *cap_info = qm->fun_type == QM_HW_PF ?\n\t\t\t\t\t\t  qm_cap_info_pf : qm_cap_info_vf;\n\tu32 size = qm->fun_type == QM_HW_PF ? ARRAY_SIZE(qm_cap_info_pf) :\n\t\t\t\t   ARRAY_SIZE(qm_cap_info_vf);\n\tu32 val, i;\n\n\t \n\tval = hisi_qm_get_hw_info(qm, qm_cap_info_comm, QM_SUPPORT_DB_ISOLATION, true);\n\tif (val)\n\t\tset_bit(QM_SUPPORT_DB_ISOLATION, &qm->caps);\n\n\tif (qm->ver >= QM_HW_V3) {\n\t\tval = readl(qm->io_base + QM_FUNC_CAPS_REG);\n\t\tqm->cap_ver = val & QM_CAPBILITY_VERSION;\n\t}\n\n\t \n\tfor (i = 1; i < ARRAY_SIZE(qm_cap_info_comm); i++) {\n\t\tval = hisi_qm_get_hw_info(qm, qm_cap_info_comm, i, qm->cap_ver);\n\t\tif (val)\n\t\t\tset_bit(qm_cap_info_comm[i].type, &qm->caps);\n\t}\n\n\t \n\tfor (i = 0; i < size; i++) {\n\t\tval = hisi_qm_get_hw_info(qm, cap_info, i, qm->cap_ver);\n\t\tif (val)\n\t\t\tset_bit(cap_info[i].type, &qm->caps);\n\t}\n\n\t \n\treturn qm_pre_store_irq_type_caps(qm);\n}\n\nstatic int qm_get_pci_res(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tret = pci_request_mem_regions(pdev, qm->dev_name);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to request mem regions!\\n\");\n\t\treturn ret;\n\t}\n\n\tqm->phys_base = pci_resource_start(pdev, PCI_BAR_2);\n\tqm->io_base = ioremap(qm->phys_base, pci_resource_len(pdev, PCI_BAR_2));\n\tif (!qm->io_base) {\n\t\tret = -EIO;\n\t\tgoto err_request_mem_regions;\n\t}\n\n\tret = qm_get_hw_caps(qm);\n\tif (ret)\n\t\tgoto err_ioremap;\n\n\tif (test_bit(QM_SUPPORT_DB_ISOLATION, &qm->caps)) {\n\t\tqm->db_interval = QM_QP_DB_INTERVAL;\n\t\tqm->db_phys_base = pci_resource_start(pdev, PCI_BAR_4);\n\t\tqm->db_io_base = ioremap(qm->db_phys_base,\n\t\t\t\t\t pci_resource_len(pdev, PCI_BAR_4));\n\t\tif (!qm->db_io_base) {\n\t\t\tret = -EIO;\n\t\t\tgoto err_ioremap;\n\t\t}\n\t} else {\n\t\tqm->db_phys_base = qm->phys_base;\n\t\tqm->db_io_base = qm->io_base;\n\t\tqm->db_interval = 0;\n\t}\n\n\tret = qm_get_qp_num(qm);\n\tif (ret)\n\t\tgoto err_db_ioremap;\n\n\treturn 0;\n\nerr_db_ioremap:\n\tif (test_bit(QM_SUPPORT_DB_ISOLATION, &qm->caps))\n\t\tiounmap(qm->db_io_base);\nerr_ioremap:\n\tiounmap(qm->io_base);\nerr_request_mem_regions:\n\tpci_release_mem_regions(pdev);\n\treturn ret;\n}\n\nstatic int hisi_qm_pci_init(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tstruct device *dev = &pdev->dev;\n\tunsigned int num_vec;\n\tint ret;\n\n\tret = pci_enable_device_mem(pdev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to enable device mem!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = qm_get_pci_res(qm);\n\tif (ret)\n\t\tgoto err_disable_pcidev;\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));\n\tif (ret < 0)\n\t\tgoto err_get_pci_res;\n\tpci_set_master(pdev);\n\n\tnum_vec = qm_get_irq_num(qm);\n\tret = pci_alloc_irq_vectors(pdev, num_vec, num_vec, PCI_IRQ_MSI);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to enable MSI vectors!\\n\");\n\t\tgoto err_get_pci_res;\n\t}\n\n\treturn 0;\n\nerr_get_pci_res:\n\tqm_put_pci_res(qm);\nerr_disable_pcidev:\n\tpci_disable_device(pdev);\n\treturn ret;\n}\n\nstatic int hisi_qm_init_work(struct hisi_qm *qm)\n{\n\tint i;\n\n\tfor (i = 0; i < qm->qp_num; i++)\n\t\tINIT_WORK(&qm->poll_data[i].work, qm_work_process);\n\n\tif (qm->fun_type == QM_HW_PF)\n\t\tINIT_WORK(&qm->rst_work, hisi_qm_controller_reset);\n\n\tif (qm->ver > QM_HW_V2)\n\t\tINIT_WORK(&qm->cmd_process, qm_cmd_process);\n\n\tqm->wq = alloc_workqueue(\"%s\", WQ_HIGHPRI | WQ_MEM_RECLAIM |\n\t\t\t\t WQ_UNBOUND, num_online_cpus(),\n\t\t\t\t pci_name(qm->pdev));\n\tif (!qm->wq) {\n\t\tpci_err(qm->pdev, \"failed to alloc workqueue!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int hisi_qp_alloc_memory(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tu16 sq_depth, cq_depth;\n\tsize_t qp_dma_size;\n\tint i, ret;\n\n\tqm->qp_array = kcalloc(qm->qp_num, sizeof(struct hisi_qp), GFP_KERNEL);\n\tif (!qm->qp_array)\n\t\treturn -ENOMEM;\n\n\tqm->poll_data = kcalloc(qm->qp_num, sizeof(struct hisi_qm_poll_data), GFP_KERNEL);\n\tif (!qm->poll_data) {\n\t\tkfree(qm->qp_array);\n\t\treturn -ENOMEM;\n\t}\n\n\tqm_get_xqc_depth(qm, &sq_depth, &cq_depth, QM_QP_DEPTH_CAP);\n\n\t \n\tqp_dma_size = qm->sqe_size * sq_depth + sizeof(struct qm_cqe) * cq_depth;\n\tqp_dma_size = PAGE_ALIGN(qp_dma_size) + PAGE_SIZE;\n\tfor (i = 0; i < qm->qp_num; i++) {\n\t\tqm->poll_data[i].qm = qm;\n\t\tret = hisi_qp_memory_init(qm, qp_dma_size, i, sq_depth, cq_depth);\n\t\tif (ret)\n\t\t\tgoto err_init_qp_mem;\n\n\t\tdev_dbg(dev, \"allocate qp dma buf size=%zx)\\n\", qp_dma_size);\n\t}\n\n\treturn 0;\nerr_init_qp_mem:\n\thisi_qp_memory_uninit(qm, i);\n\n\treturn ret;\n}\n\nstatic int hisi_qm_memory_init(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tint ret, total_func;\n\tsize_t off = 0;\n\n\tif (test_bit(QM_SUPPORT_FUNC_QOS, &qm->caps)) {\n\t\ttotal_func = pci_sriov_get_totalvfs(qm->pdev) + 1;\n\t\tqm->factor = kcalloc(total_func, sizeof(struct qm_shaper_factor), GFP_KERNEL);\n\t\tif (!qm->factor)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tqm->factor[0].func_qos = QM_QOS_MAX_VAL;\n\t}\n\n#define QM_INIT_BUF(qm, type, num) do { \\\n\t(qm)->type = ((qm)->qdma.va + (off)); \\\n\t(qm)->type##_dma = (qm)->qdma.dma + (off); \\\n\toff += QMC_ALIGN(sizeof(struct qm_##type) * (num)); \\\n} while (0)\n\n\tidr_init(&qm->qp_idr);\n\tqm_get_xqc_depth(qm, &qm->eq_depth, &qm->aeq_depth, QM_XEQ_DEPTH_CAP);\n\tqm->qdma.size = QMC_ALIGN(sizeof(struct qm_eqe) * qm->eq_depth) +\n\t\t\tQMC_ALIGN(sizeof(struct qm_aeqe) * qm->aeq_depth) +\n\t\t\tQMC_ALIGN(sizeof(struct qm_sqc) * qm->qp_num) +\n\t\t\tQMC_ALIGN(sizeof(struct qm_cqc) * qm->qp_num);\n\tqm->qdma.va = dma_alloc_coherent(dev, qm->qdma.size, &qm->qdma.dma,\n\t\t\t\t\t GFP_ATOMIC);\n\tdev_dbg(dev, \"allocate qm dma buf size=%zx)\\n\", qm->qdma.size);\n\tif (!qm->qdma.va) {\n\t\tret = -ENOMEM;\n\t\tgoto err_destroy_idr;\n\t}\n\n\tQM_INIT_BUF(qm, eqe, qm->eq_depth);\n\tQM_INIT_BUF(qm, aeqe, qm->aeq_depth);\n\tQM_INIT_BUF(qm, sqc, qm->qp_num);\n\tQM_INIT_BUF(qm, cqc, qm->qp_num);\n\n\tret = hisi_qp_alloc_memory(qm);\n\tif (ret)\n\t\tgoto err_alloc_qp_array;\n\n\treturn 0;\n\nerr_alloc_qp_array:\n\tdma_free_coherent(dev, qm->qdma.size, qm->qdma.va, qm->qdma.dma);\nerr_destroy_idr:\n\tidr_destroy(&qm->qp_idr);\n\tif (test_bit(QM_SUPPORT_FUNC_QOS, &qm->caps))\n\t\tkfree(qm->factor);\n\n\treturn ret;\n}\n\n \nint hisi_qm_init(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\thisi_qm_pre_init(qm);\n\n\tret = hisi_qm_pci_init(qm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qm_irqs_register(qm);\n\tif (ret)\n\t\tgoto err_pci_init;\n\n\tif (qm->fun_type == QM_HW_PF) {\n\t\t \n\t\twritel(QM_DB_TIMEOUT_SET, qm->io_base + QM_DB_TIMEOUT_CFG);\n\t\tqm_disable_clock_gate(qm);\n\t\tret = qm_dev_mem_reset(qm);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to reset device memory\\n\");\n\t\t\tgoto err_irq_register;\n\t\t}\n\t}\n\n\tif (qm->mode == UACCE_MODE_SVA) {\n\t\tret = qm_alloc_uacce(qm);\n\t\tif (ret < 0)\n\t\t\tdev_warn(dev, \"fail to alloc uacce (%d)\\n\", ret);\n\t}\n\n\tret = hisi_qm_memory_init(qm);\n\tif (ret)\n\t\tgoto err_alloc_uacce;\n\n\tret = hisi_qm_init_work(qm);\n\tif (ret)\n\t\tgoto err_free_qm_memory;\n\n\tqm_cmd_init(qm);\n\tatomic_set(&qm->status.flags, QM_INIT);\n\n\treturn 0;\n\nerr_free_qm_memory:\n\thisi_qm_memory_uninit(qm);\nerr_alloc_uacce:\n\tqm_remove_uacce(qm);\nerr_irq_register:\n\tqm_irqs_unregister(qm);\nerr_pci_init:\n\thisi_qm_pci_uninit(qm);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_init);\n\n \nint hisi_qm_get_dfx_access(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\n\tif (pm_runtime_suspended(dev)) {\n\t\tdev_info(dev, \"can not read/write - device in suspended.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\treturn qm_pm_get_sync(qm);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_get_dfx_access);\n\n \nvoid hisi_qm_put_dfx_access(struct hisi_qm *qm)\n{\n\tqm_pm_put_sync(qm);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_put_dfx_access);\n\n \nvoid hisi_qm_pm_init(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\n\tif (!test_bit(QM_SUPPORT_RPM, &qm->caps))\n\t\treturn;\n\n\tpm_runtime_set_autosuspend_delay(dev, QM_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_put_noidle(dev);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_pm_init);\n\n \nvoid hisi_qm_pm_uninit(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\n\tif (!test_bit(QM_SUPPORT_RPM, &qm->caps))\n\t\treturn;\n\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_dont_use_autosuspend(dev);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_pm_uninit);\n\nstatic int qm_prepare_for_suspend(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tint ret;\n\tu32 val;\n\n\tret = qm->ops->set_msi(qm, false);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to disable MSI before suspending!\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\twritel(ACC_MASTER_GLOBAL_CTRL_SHUTDOWN,\n\t       qm->io_base + ACC_MASTER_GLOBAL_CTRL);\n\n\tret = readl_relaxed_poll_timeout(qm->io_base + ACC_MASTER_TRANS_RETURN,\n\t\t\t\t\t val,\n\t\t\t\t\t (val == ACC_MASTER_TRANS_RETURN_RW),\n\t\t\t\t\t POLL_PERIOD, POLL_TIMEOUT);\n\tif (ret) {\n\t\tpci_emerg(pdev, \"Bus lock! Please reset system.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = qm_set_pf_mse(qm, false);\n\tif (ret)\n\t\tpci_err(pdev, \"failed to disable MSE before suspending!\\n\");\n\n\treturn ret;\n}\n\nstatic int qm_rebuild_for_resume(struct hisi_qm *qm)\n{\n\tstruct pci_dev *pdev = qm->pdev;\n\tint ret;\n\n\tret = qm_set_pf_mse(qm, true);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to enable MSE after resuming!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = qm->ops->set_msi(qm, true);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to enable MSI after resuming!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = qm_dev_hw_init(qm);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to init device after resuming\\n\");\n\t\treturn ret;\n\t}\n\n\tqm_cmd_init(qm);\n\thisi_qm_dev_err_init(qm);\n\t \n\twritel(QM_DB_TIMEOUT_SET, qm->io_base + QM_DB_TIMEOUT_CFG);\n\tqm_disable_clock_gate(qm);\n\tret = qm_dev_mem_reset(qm);\n\tif (ret)\n\t\tpci_err(pdev, \"failed to reset device memory\\n\");\n\n\treturn ret;\n}\n\n \nint hisi_qm_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct hisi_qm *qm = pci_get_drvdata(pdev);\n\tint ret;\n\n\tpci_info(pdev, \"entering suspended state\\n\");\n\n\tret = hisi_qm_stop(qm, QM_NORMAL);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to stop qm(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = qm_prepare_for_suspend(qm);\n\tif (ret)\n\t\tpci_err(pdev, \"failed to prepare suspended(%d)\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_suspend);\n\n \nint hisi_qm_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct hisi_qm *qm = pci_get_drvdata(pdev);\n\tint ret;\n\n\tpci_info(pdev, \"resuming from suspend state\\n\");\n\n\tret = qm_rebuild_for_resume(qm);\n\tif (ret) {\n\t\tpci_err(pdev, \"failed to rebuild resume(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hisi_qm_start(qm);\n\tif (ret) {\n\t\tif (qm_check_dev_error(qm)) {\n\t\t\tpci_info(pdev, \"failed to start qm due to device error, device will be reset!\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tpci_err(pdev, \"failed to start qm(%d)!\\n\", ret);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_resume);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Zhou Wang <wangzhou1@hisilicon.com>\");\nMODULE_DESCRIPTION(\"HiSilicon Accelerator queue manager driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}