{
  "module_name": "debugfs.c",
  "hash_id": "582bdd7e2b26d3b10055ae6c256bc49e00f85f239b2fa90e7be25018c8d4d090",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/hisilicon/debugfs.c",
  "human_readable_source": "\n \n#include <linux/hisi_acc_qm.h>\n#include \"qm_common.h\"\n\n#define QM_DFX_BASE\t\t\t0x0100000\n#define QM_DFX_STATE1\t\t\t0x0104000\n#define QM_DFX_STATE2\t\t\t0x01040C8\n#define QM_DFX_COMMON\t\t\t0x0000\n#define QM_DFX_BASE_LEN\t\t\t0x5A\n#define QM_DFX_STATE1_LEN\t\t0x2E\n#define QM_DFX_STATE2_LEN\t\t0x11\n#define QM_DFX_COMMON_LEN\t\t0xC3\n#define QM_DFX_REGS_LEN\t\t\t4UL\n#define QM_DBG_TMP_BUF_LEN\t\t22\n#define CURRENT_FUN_MASK\t\tGENMASK(5, 0)\n#define CURRENT_Q_MASK\t\t\tGENMASK(31, 16)\n#define QM_SQE_ADDR_MASK\t\tGENMASK(7, 0)\n\n#define QM_DFX_MB_CNT_VF\t\t0x104010\n#define QM_DFX_DB_CNT_VF\t\t0x104020\n#define QM_DFX_SQE_CNT_VF_SQN\t\t0x104030\n#define QM_DFX_CQE_CNT_VF_CQN\t\t0x104040\n#define QM_DFX_QN_SHIFT\t\t\t16\n#define QM_DFX_CNT_CLR_CE\t\t0x100118\n#define QM_DBG_WRITE_LEN\t\t1024\n\nstatic const char * const qm_debug_file_name[] = {\n\t[CURRENT_QM]   = \"current_qm\",\n\t[CURRENT_Q]    = \"current_q\",\n\t[CLEAR_ENABLE] = \"clear_enable\",\n};\n\nstruct qm_dfx_item {\n\tconst char *name;\n\tu32 offset;\n};\n\nstruct qm_cmd_dump_item {\n\tconst char *cmd;\n\tchar *info_name;\n\tint (*dump_fn)(struct hisi_qm *qm, char *cmd, char *info_name);\n};\n\nstatic struct qm_dfx_item qm_dfx_files[] = {\n\t{\"err_irq\", offsetof(struct qm_dfx, err_irq_cnt)},\n\t{\"aeq_irq\", offsetof(struct qm_dfx, aeq_irq_cnt)},\n\t{\"abnormal_irq\", offsetof(struct qm_dfx, abnormal_irq_cnt)},\n\t{\"create_qp_err\", offsetof(struct qm_dfx, create_qp_err_cnt)},\n\t{\"mb_err\", offsetof(struct qm_dfx, mb_err_cnt)},\n};\n\n#define CNT_CYC_REGS_NUM\t\t10\nstatic const struct debugfs_reg32 qm_dfx_regs[] = {\n\t \n\t{\"QM_ECC_1BIT_CNT               \",  0x104000ull},\n\t{\"QM_ECC_MBIT_CNT               \",  0x104008ull},\n\t{\"QM_DFX_MB_CNT                 \",  0x104018ull},\n\t{\"QM_DFX_DB_CNT                 \",  0x104028ull},\n\t{\"QM_DFX_SQE_CNT                \",  0x104038ull},\n\t{\"QM_DFX_CQE_CNT                \",  0x104048ull},\n\t{\"QM_DFX_SEND_SQE_TO_ACC_CNT    \",  0x104050ull},\n\t{\"QM_DFX_WB_SQE_FROM_ACC_CNT    \",  0x104058ull},\n\t{\"QM_DFX_ACC_FINISH_CNT         \",  0x104060ull},\n\t{\"QM_DFX_CQE_ERR_CNT            \",  0x1040b4ull},\n\t{\"QM_DFX_FUNS_ACTIVE_ST         \",  0x200ull},\n\t{\"QM_ECC_1BIT_INF               \",  0x104004ull},\n\t{\"QM_ECC_MBIT_INF               \",  0x10400cull},\n\t{\"QM_DFX_ACC_RDY_VLD0           \",  0x1040a0ull},\n\t{\"QM_DFX_ACC_RDY_VLD1           \",  0x1040a4ull},\n\t{\"QM_DFX_AXI_RDY_VLD            \",  0x1040a8ull},\n\t{\"QM_DFX_FF_ST0                 \",  0x1040c8ull},\n\t{\"QM_DFX_FF_ST1                 \",  0x1040ccull},\n\t{\"QM_DFX_FF_ST2                 \",  0x1040d0ull},\n\t{\"QM_DFX_FF_ST3                 \",  0x1040d4ull},\n\t{\"QM_DFX_FF_ST4                 \",  0x1040d8ull},\n\t{\"QM_DFX_FF_ST5                 \",  0x1040dcull},\n\t{\"QM_DFX_FF_ST6                 \",  0x1040e0ull},\n\t{\"QM_IN_IDLE_ST                 \",  0x1040e4ull},\n};\n\nstatic const struct debugfs_reg32 qm_vf_dfx_regs[] = {\n\t{\"QM_DFX_FUNS_ACTIVE_ST         \",  0x200ull},\n};\n\n \nstatic struct dfx_diff_registers qm_diff_regs[] = {\n\t{\n\t\t.reg_offset = QM_DFX_BASE,\n\t\t.reg_len = QM_DFX_BASE_LEN,\n\t}, {\n\t\t.reg_offset = QM_DFX_STATE1,\n\t\t.reg_len = QM_DFX_STATE1_LEN,\n\t}, {\n\t\t.reg_offset = QM_DFX_STATE2,\n\t\t.reg_len = QM_DFX_STATE2_LEN,\n\t}, {\n\t\t.reg_offset = QM_DFX_COMMON,\n\t\t.reg_len = QM_DFX_COMMON_LEN,\n\t},\n};\n\nstatic struct hisi_qm *file_to_qm(struct debugfs_file *file)\n{\n\tstruct qm_debug *debug = file->debug;\n\n\treturn container_of(debug, struct hisi_qm, debug);\n}\n\nstatic ssize_t qm_cmd_read(struct file *filp, char __user *buffer,\n\t\t\t   size_t count, loff_t *pos)\n{\n\tchar buf[QM_DBG_READ_LEN];\n\tint len;\n\n\tlen = scnprintf(buf, QM_DBG_READ_LEN, \"%s\\n\",\n\t\t\t\"Please echo help to cmd to get help information\");\n\n\treturn simple_read_from_buffer(buffer, count, pos, buf, len);\n}\n\nstatic void dump_show(struct hisi_qm *qm, void *info,\n\t\t     unsigned int info_size, char *info_name)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tu8 *info_curr = info;\n\tu32 i;\n#define BYTE_PER_DW\t4\n\n\tdev_info(dev, \"%s DUMP\\n\", info_name);\n\tfor (i = 0; i < info_size; i += BYTE_PER_DW, info_curr += BYTE_PER_DW) {\n\t\tpr_info(\"DW%u: %02X%02X %02X%02X\\n\", i / BYTE_PER_DW,\n\t\t\t*(info_curr + 3), *(info_curr + 2), *(info_curr + 1), *(info_curr));\n\t}\n}\n\nstatic int qm_sqc_dump(struct hisi_qm *qm, char *s, char *name)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tstruct qm_sqc *sqc, *sqc_curr;\n\tdma_addr_t sqc_dma;\n\tu32 qp_id;\n\tint ret;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\tret = kstrtou32(s, 0, &qp_id);\n\tif (ret || qp_id >= qm->qp_num) {\n\t\tdev_err(dev, \"Please input qp num (0-%u)\", qm->qp_num - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tsqc = hisi_qm_ctx_alloc(qm, sizeof(*sqc), &sqc_dma);\n\tif (IS_ERR(sqc))\n\t\treturn PTR_ERR(sqc);\n\n\tret = hisi_qm_mb(qm, QM_MB_CMD_SQC, sqc_dma, qp_id, 1);\n\tif (ret) {\n\t\tdown_read(&qm->qps_lock);\n\t\tif (qm->sqc) {\n\t\t\tsqc_curr = qm->sqc + qp_id;\n\n\t\t\tdump_show(qm, sqc_curr, sizeof(*sqc), \"SOFT SQC\");\n\t\t}\n\t\tup_read(&qm->qps_lock);\n\n\t\tgoto free_ctx;\n\t}\n\n\tdump_show(qm, sqc, sizeof(*sqc), name);\n\nfree_ctx:\n\thisi_qm_ctx_free(qm, sizeof(*sqc), sqc, &sqc_dma);\n\treturn 0;\n}\n\nstatic int qm_cqc_dump(struct hisi_qm *qm, char *s, char *name)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tstruct qm_cqc *cqc, *cqc_curr;\n\tdma_addr_t cqc_dma;\n\tu32 qp_id;\n\tint ret;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\tret = kstrtou32(s, 0, &qp_id);\n\tif (ret || qp_id >= qm->qp_num) {\n\t\tdev_err(dev, \"Please input qp num (0-%u)\", qm->qp_num - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tcqc = hisi_qm_ctx_alloc(qm, sizeof(*cqc), &cqc_dma);\n\tif (IS_ERR(cqc))\n\t\treturn PTR_ERR(cqc);\n\n\tret = hisi_qm_mb(qm, QM_MB_CMD_CQC, cqc_dma, qp_id, 1);\n\tif (ret) {\n\t\tdown_read(&qm->qps_lock);\n\t\tif (qm->cqc) {\n\t\t\tcqc_curr = qm->cqc + qp_id;\n\n\t\t\tdump_show(qm, cqc_curr, sizeof(*cqc), \"SOFT CQC\");\n\t\t}\n\t\tup_read(&qm->qps_lock);\n\n\t\tgoto free_ctx;\n\t}\n\n\tdump_show(qm, cqc, sizeof(*cqc), name);\n\nfree_ctx:\n\thisi_qm_ctx_free(qm, sizeof(*cqc), cqc, &cqc_dma);\n\treturn 0;\n}\n\nstatic int qm_eqc_aeqc_dump(struct hisi_qm *qm, char *s, char *name)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tdma_addr_t xeqc_dma;\n\tsize_t size;\n\tvoid *xeqc;\n\tint ret;\n\tu8 cmd;\n\n\tif (strsep(&s, \" \")) {\n\t\tdev_err(dev, \"Please do not input extra characters!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!strcmp(name, \"EQC\")) {\n\t\tcmd = QM_MB_CMD_EQC;\n\t\tsize = sizeof(struct qm_eqc);\n\t} else {\n\t\tcmd = QM_MB_CMD_AEQC;\n\t\tsize = sizeof(struct qm_aeqc);\n\t}\n\n\txeqc = hisi_qm_ctx_alloc(qm, size, &xeqc_dma);\n\tif (IS_ERR(xeqc))\n\t\treturn PTR_ERR(xeqc);\n\n\tret = hisi_qm_mb(qm, cmd, xeqc_dma, 0, 1);\n\tif (ret)\n\t\tgoto err_free_ctx;\n\n\tdump_show(qm, xeqc, size, name);\n\nerr_free_ctx:\n\thisi_qm_ctx_free(qm, size, xeqc, &xeqc_dma);\n\treturn ret;\n}\n\nstatic int q_dump_param_parse(struct hisi_qm *qm, char *s,\n\t\t\t      u32 *e_id, u32 *q_id, u16 q_depth)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tunsigned int qp_num = qm->qp_num;\n\tchar *presult;\n\tint ret;\n\n\tpresult = strsep(&s, \" \");\n\tif (!presult) {\n\t\tdev_err(dev, \"Please input qp number!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = kstrtou32(presult, 0, q_id);\n\tif (ret || *q_id >= qp_num) {\n\t\tdev_err(dev, \"Please input qp num (0-%u)\", qp_num - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tpresult = strsep(&s, \" \");\n\tif (!presult) {\n\t\tdev_err(dev, \"Please input sqe number!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = kstrtou32(presult, 0, e_id);\n\tif (ret || *e_id >= q_depth) {\n\t\tdev_err(dev, \"Please input sqe num (0-%u)\", q_depth - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (strsep(&s, \" \")) {\n\t\tdev_err(dev, \"Please do not input extra characters!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int qm_sq_dump(struct hisi_qm *qm, char *s, char *name)\n{\n\tu16 sq_depth = qm->qp_array->cq_depth;\n\tvoid *sqe, *sqe_curr;\n\tstruct hisi_qp *qp;\n\tu32 qp_id, sqe_id;\n\tint ret;\n\n\tret = q_dump_param_parse(qm, s, &sqe_id, &qp_id, sq_depth);\n\tif (ret)\n\t\treturn ret;\n\n\tsqe = kzalloc(qm->sqe_size * sq_depth, GFP_KERNEL);\n\tif (!sqe)\n\t\treturn -ENOMEM;\n\n\tqp = &qm->qp_array[qp_id];\n\tmemcpy(sqe, qp->sqe, qm->sqe_size * sq_depth);\n\tsqe_curr = sqe + (u32)(sqe_id * qm->sqe_size);\n\tmemset(sqe_curr + qm->debug.sqe_mask_offset, QM_SQE_ADDR_MASK,\n\t       qm->debug.sqe_mask_len);\n\n\tdump_show(qm, sqe_curr, qm->sqe_size, name);\n\n\tkfree(sqe);\n\n\treturn 0;\n}\n\nstatic int qm_cq_dump(struct hisi_qm *qm, char *s, char *name)\n{\n\tstruct qm_cqe *cqe_curr;\n\tstruct hisi_qp *qp;\n\tu32 qp_id, cqe_id;\n\tint ret;\n\n\tret = q_dump_param_parse(qm, s, &cqe_id, &qp_id, qm->qp_array->cq_depth);\n\tif (ret)\n\t\treturn ret;\n\n\tqp = &qm->qp_array[qp_id];\n\tcqe_curr = qp->cqe + cqe_id;\n\tdump_show(qm, cqe_curr, sizeof(struct qm_cqe), name);\n\n\treturn 0;\n}\n\nstatic int qm_eq_aeq_dump(struct hisi_qm *qm, char *s, char *name)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tu16 xeq_depth;\n\tsize_t size;\n\tvoid *xeqe;\n\tu32 xeqe_id;\n\tint ret;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\tret = kstrtou32(s, 0, &xeqe_id);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(name, \"EQE\")) {\n\t\txeq_depth = qm->eq_depth;\n\t\tsize = sizeof(struct qm_eqe);\n\t} else {\n\t\txeq_depth = qm->aeq_depth;\n\t\tsize = sizeof(struct qm_aeqe);\n\t}\n\n\tif (xeqe_id >= xeq_depth) {\n\t\tdev_err(dev, \"Please input eqe or aeqe num (0-%u)\", xeq_depth - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tdown_read(&qm->qps_lock);\n\n\tif (qm->eqe && !strcmp(name, \"EQE\")) {\n\t\txeqe = qm->eqe + xeqe_id;\n\t} else if (qm->aeqe && !strcmp(name, \"AEQE\")) {\n\t\txeqe = qm->aeqe + xeqe_id;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\n\tdump_show(qm, xeqe, size, name);\n\nerr_unlock:\n\tup_read(&qm->qps_lock);\n\treturn ret;\n}\n\nstatic int qm_dbg_help(struct hisi_qm *qm, char *s)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\n\tif (strsep(&s, \" \")) {\n\t\tdev_err(dev, \"Please do not input extra characters!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(dev, \"available commands:\\n\");\n\tdev_info(dev, \"sqc <num>\\n\");\n\tdev_info(dev, \"cqc <num>\\n\");\n\tdev_info(dev, \"eqc\\n\");\n\tdev_info(dev, \"aeqc\\n\");\n\tdev_info(dev, \"sq <num> <e>\\n\");\n\tdev_info(dev, \"cq <num> <e>\\n\");\n\tdev_info(dev, \"eq <e>\\n\");\n\tdev_info(dev, \"aeq <e>\\n\");\n\n\treturn 0;\n}\n\nstatic const struct qm_cmd_dump_item qm_cmd_dump_table[] = {\n\t{\n\t\t.cmd = \"sqc\",\n\t\t.info_name = \"SQC\",\n\t\t.dump_fn = qm_sqc_dump,\n\t}, {\n\t\t.cmd = \"cqc\",\n\t\t.info_name = \"CQC\",\n\t\t.dump_fn = qm_cqc_dump,\n\t}, {\n\t\t.cmd = \"eqc\",\n\t\t.info_name = \"EQC\",\n\t\t.dump_fn = qm_eqc_aeqc_dump,\n\t}, {\n\t\t.cmd = \"aeqc\",\n\t\t.info_name = \"AEQC\",\n\t\t.dump_fn = qm_eqc_aeqc_dump,\n\t}, {\n\t\t.cmd = \"sq\",\n\t\t.info_name = \"SQE\",\n\t\t.dump_fn = qm_sq_dump,\n\t}, {\n\t\t.cmd = \"cq\",\n\t\t.info_name = \"CQE\",\n\t\t.dump_fn = qm_cq_dump,\n\t}, {\n\t\t.cmd = \"eq\",\n\t\t.info_name = \"EQE\",\n\t\t.dump_fn = qm_eq_aeq_dump,\n\t}, {\n\t\t.cmd = \"aeq\",\n\t\t.info_name = \"AEQE\",\n\t\t.dump_fn = qm_eq_aeq_dump,\n\t},\n};\n\nstatic int qm_cmd_write_dump(struct hisi_qm *qm, const char *cmd_buf)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tchar *presult, *s, *s_tmp;\n\tint table_size, i, ret;\n\n\ts = kstrdup(cmd_buf, GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ts_tmp = s;\n\tpresult = strsep(&s, \" \");\n\tif (!presult) {\n\t\tret = -EINVAL;\n\t\tgoto err_buffer_free;\n\t}\n\n\tif (!strcmp(presult, \"help\")) {\n\t\tret = qm_dbg_help(qm, s);\n\t\tgoto err_buffer_free;\n\t}\n\n\ttable_size = ARRAY_SIZE(qm_cmd_dump_table);\n\tfor (i = 0; i < table_size; i++) {\n\t\tif (!strcmp(presult, qm_cmd_dump_table[i].cmd)) {\n\t\t\tret = qm_cmd_dump_table[i].dump_fn(qm, s,\n\t\t\t\tqm_cmd_dump_table[i].info_name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == table_size) {\n\t\tdev_info(dev, \"Please echo help\\n\");\n\t\tret = -EINVAL;\n\t}\n\nerr_buffer_free:\n\tkfree(s_tmp);\n\n\treturn ret;\n}\n\nstatic ssize_t qm_cmd_write(struct file *filp, const char __user *buffer,\n\t\t\t    size_t count, loff_t *pos)\n{\n\tstruct hisi_qm *qm = filp->private_data;\n\tchar *cmd_buf, *cmd_buf_tmp;\n\tint ret;\n\n\tif (*pos)\n\t\treturn 0;\n\n\tret = hisi_qm_get_dfx_access(qm);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (unlikely(atomic_read(&qm->status.flags) == QM_STOP)) {\n\t\tret = 0;\n\t\tgoto put_dfx_access;\n\t}\n\n\tif (count > QM_DBG_WRITE_LEN) {\n\t\tret = -ENOSPC;\n\t\tgoto put_dfx_access;\n\t}\n\n\tcmd_buf = memdup_user_nul(buffer, count);\n\tif (IS_ERR(cmd_buf)) {\n\t\tret = PTR_ERR(cmd_buf);\n\t\tgoto put_dfx_access;\n\t}\n\n\tcmd_buf_tmp = strchr(cmd_buf, '\\n');\n\tif (cmd_buf_tmp) {\n\t\t*cmd_buf_tmp = '\\0';\n\t\tcount = cmd_buf_tmp - cmd_buf + 1;\n\t}\n\n\tret = qm_cmd_write_dump(qm, cmd_buf);\n\tif (ret) {\n\t\tkfree(cmd_buf);\n\t\tgoto put_dfx_access;\n\t}\n\n\tkfree(cmd_buf);\n\n\tret = count;\n\nput_dfx_access:\n\thisi_qm_put_dfx_access(qm);\n\treturn ret;\n}\n\nstatic const struct file_operations qm_cmd_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = qm_cmd_read,\n\t.write = qm_cmd_write,\n};\n\n \nvoid hisi_qm_regs_dump(struct seq_file *s, struct debugfs_regset32 *regset)\n{\n\tstruct pci_dev *pdev = to_pci_dev(regset->dev);\n\tstruct hisi_qm *qm = pci_get_drvdata(pdev);\n\tconst struct debugfs_reg32 *regs = regset->regs;\n\tint regs_len = regset->nregs;\n\tint i, ret;\n\tu32 val;\n\n\tret = hisi_qm_get_dfx_access(qm);\n\tif (ret)\n\t\treturn;\n\n\tfor (i = 0; i < regs_len; i++) {\n\t\tval = readl(regset->base + regs[i].offset);\n\t\tseq_printf(s, \"%s= 0x%08x\\n\", regs[i].name, val);\n\t}\n\n\thisi_qm_put_dfx_access(qm);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_regs_dump);\n\nstatic int qm_regs_show(struct seq_file *s, void *unused)\n{\n\tstruct hisi_qm *qm = s->private;\n\tstruct debugfs_regset32 regset;\n\n\tif (qm->fun_type == QM_HW_PF) {\n\t\tregset.regs = qm_dfx_regs;\n\t\tregset.nregs = ARRAY_SIZE(qm_dfx_regs);\n\t} else {\n\t\tregset.regs = qm_vf_dfx_regs;\n\t\tregset.nregs = ARRAY_SIZE(qm_vf_dfx_regs);\n\t}\n\n\tregset.base = qm->io_base;\n\tregset.dev = &qm->pdev->dev;\n\n\thisi_qm_regs_dump(s, &regset);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(qm_regs);\n\nstatic u32 current_q_read(struct hisi_qm *qm)\n{\n\treturn readl(qm->io_base + QM_DFX_SQE_CNT_VF_SQN) >> QM_DFX_QN_SHIFT;\n}\n\nstatic int current_q_write(struct hisi_qm *qm, u32 val)\n{\n\tu32 tmp;\n\n\tif (val >= qm->debug.curr_qm_qp_num)\n\t\treturn -EINVAL;\n\n\ttmp = val << QM_DFX_QN_SHIFT |\n\t      (readl(qm->io_base + QM_DFX_SQE_CNT_VF_SQN) & CURRENT_FUN_MASK);\n\twritel(tmp, qm->io_base + QM_DFX_SQE_CNT_VF_SQN);\n\n\ttmp = val << QM_DFX_QN_SHIFT |\n\t      (readl(qm->io_base + QM_DFX_CQE_CNT_VF_CQN) & CURRENT_FUN_MASK);\n\twritel(tmp, qm->io_base + QM_DFX_CQE_CNT_VF_CQN);\n\n\treturn 0;\n}\n\nstatic u32 clear_enable_read(struct hisi_qm *qm)\n{\n\treturn readl(qm->io_base + QM_DFX_CNT_CLR_CE);\n}\n\n \nstatic int clear_enable_write(struct hisi_qm *qm, u32 rd_clr_ctrl)\n{\n\tif (rd_clr_ctrl > 1)\n\t\treturn -EINVAL;\n\n\twritel(rd_clr_ctrl, qm->io_base + QM_DFX_CNT_CLR_CE);\n\n\treturn 0;\n}\n\nstatic u32 current_qm_read(struct hisi_qm *qm)\n{\n\treturn readl(qm->io_base + QM_DFX_MB_CNT_VF);\n}\n\nstatic int qm_get_vf_qp_num(struct hisi_qm *qm, u32 fun_num)\n{\n\tu32 remain_q_num, vfq_num;\n\tu32 num_vfs = qm->vfs_num;\n\n\tvfq_num = (qm->ctrl_qp_num - qm->qp_num) / num_vfs;\n\tif (vfq_num >= qm->max_qp_num)\n\t\treturn qm->max_qp_num;\n\n\tremain_q_num = (qm->ctrl_qp_num - qm->qp_num) % num_vfs;\n\tif (vfq_num + remain_q_num <= qm->max_qp_num)\n\t\treturn fun_num == num_vfs ? vfq_num + remain_q_num : vfq_num;\n\n\t \n\treturn fun_num + remain_q_num > num_vfs ? vfq_num + 1 : vfq_num;\n}\n\nstatic int current_qm_write(struct hisi_qm *qm, u32 val)\n{\n\tu32 tmp;\n\n\tif (val > qm->vfs_num)\n\t\treturn -EINVAL;\n\n\t \n\tif (!val)\n\t\tqm->debug.curr_qm_qp_num = qm->qp_num;\n\telse\n\t\tqm->debug.curr_qm_qp_num = qm_get_vf_qp_num(qm, val);\n\n\twritel(val, qm->io_base + QM_DFX_MB_CNT_VF);\n\twritel(val, qm->io_base + QM_DFX_DB_CNT_VF);\n\n\ttmp = val |\n\t      (readl(qm->io_base + QM_DFX_SQE_CNT_VF_SQN) & CURRENT_Q_MASK);\n\twritel(tmp, qm->io_base + QM_DFX_SQE_CNT_VF_SQN);\n\n\ttmp = val |\n\t      (readl(qm->io_base + QM_DFX_CQE_CNT_VF_CQN) & CURRENT_Q_MASK);\n\twritel(tmp, qm->io_base + QM_DFX_CQE_CNT_VF_CQN);\n\n\treturn 0;\n}\n\nstatic ssize_t qm_debug_read(struct file *filp, char __user *buf,\n\t\t\t     size_t count, loff_t *pos)\n{\n\tstruct debugfs_file *file = filp->private_data;\n\tenum qm_debug_file index = file->index;\n\tstruct hisi_qm *qm = file_to_qm(file);\n\tchar tbuf[QM_DBG_TMP_BUF_LEN];\n\tu32 val;\n\tint ret;\n\n\tret = hisi_qm_get_dfx_access(qm);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&file->lock);\n\tswitch (index) {\n\tcase CURRENT_QM:\n\t\tval = current_qm_read(qm);\n\t\tbreak;\n\tcase CURRENT_Q:\n\t\tval = current_q_read(qm);\n\t\tbreak;\n\tcase CLEAR_ENABLE:\n\t\tval = clear_enable_read(qm);\n\t\tbreak;\n\tdefault:\n\t\tgoto err_input;\n\t}\n\tmutex_unlock(&file->lock);\n\n\thisi_qm_put_dfx_access(qm);\n\tret = scnprintf(tbuf, QM_DBG_TMP_BUF_LEN, \"%u\\n\", val);\n\treturn simple_read_from_buffer(buf, count, pos, tbuf, ret);\n\nerr_input:\n\tmutex_unlock(&file->lock);\n\thisi_qm_put_dfx_access(qm);\n\treturn -EINVAL;\n}\n\nstatic ssize_t qm_debug_write(struct file *filp, const char __user *buf,\n\t\t\t      size_t count, loff_t *pos)\n{\n\tstruct debugfs_file *file = filp->private_data;\n\tenum qm_debug_file index = file->index;\n\tstruct hisi_qm *qm = file_to_qm(file);\n\tunsigned long val;\n\tchar tbuf[QM_DBG_TMP_BUF_LEN];\n\tint len, ret;\n\n\tif (*pos != 0)\n\t\treturn 0;\n\n\tif (count >= QM_DBG_TMP_BUF_LEN)\n\t\treturn -ENOSPC;\n\n\tlen = simple_write_to_buffer(tbuf, QM_DBG_TMP_BUF_LEN - 1, pos, buf,\n\t\t\t\t     count);\n\tif (len < 0)\n\t\treturn len;\n\n\ttbuf[len] = '\\0';\n\tif (kstrtoul(tbuf, 0, &val))\n\t\treturn -EFAULT;\n\n\tret = hisi_qm_get_dfx_access(qm);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&file->lock);\n\tswitch (index) {\n\tcase CURRENT_QM:\n\t\tret = current_qm_write(qm, val);\n\t\tbreak;\n\tcase CURRENT_Q:\n\t\tret = current_q_write(qm, val);\n\t\tbreak;\n\tcase CLEAR_ENABLE:\n\t\tret = clear_enable_write(qm, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&file->lock);\n\n\thisi_qm_put_dfx_access(qm);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic const struct file_operations qm_debug_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = qm_debug_read,\n\t.write = qm_debug_write,\n};\n\nstatic void dfx_regs_uninit(struct hisi_qm *qm,\n\t\tstruct dfx_diff_registers *dregs, int reg_len)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < reg_len; i++) {\n\t\tkfree(dregs[i].regs);\n\t\tdregs[i].regs = NULL;\n\t}\n\tkfree(dregs);\n}\n\nstatic struct dfx_diff_registers *dfx_regs_init(struct hisi_qm *qm,\n\tconst struct dfx_diff_registers *cregs, u32 reg_len)\n{\n\tstruct dfx_diff_registers *diff_regs;\n\tu32 j, base_offset;\n\tint i;\n\n\tdiff_regs = kcalloc(reg_len, sizeof(*diff_regs), GFP_KERNEL);\n\tif (!diff_regs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < reg_len; i++) {\n\t\tif (!cregs[i].reg_len)\n\t\t\tcontinue;\n\n\t\tdiff_regs[i].reg_offset = cregs[i].reg_offset;\n\t\tdiff_regs[i].reg_len = cregs[i].reg_len;\n\t\tdiff_regs[i].regs = kcalloc(QM_DFX_REGS_LEN, cregs[i].reg_len,\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!diff_regs[i].regs)\n\t\t\tgoto alloc_error;\n\n\t\tfor (j = 0; j < diff_regs[i].reg_len; j++) {\n\t\t\tbase_offset = diff_regs[i].reg_offset +\n\t\t\t\t\tj * QM_DFX_REGS_LEN;\n\t\t\tdiff_regs[i].regs[j] = readl(qm->io_base + base_offset);\n\t\t}\n\t}\n\n\treturn diff_regs;\n\nalloc_error:\n\twhile (i > 0) {\n\t\ti--;\n\t\tkfree(diff_regs[i].regs);\n\t}\n\tkfree(diff_regs);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic int qm_diff_regs_init(struct hisi_qm *qm,\n\t\tstruct dfx_diff_registers *dregs, u32 reg_len)\n{\n\tqm->debug.qm_diff_regs = dfx_regs_init(qm, qm_diff_regs, ARRAY_SIZE(qm_diff_regs));\n\tif (IS_ERR(qm->debug.qm_diff_regs))\n\t\treturn PTR_ERR(qm->debug.qm_diff_regs);\n\n\tqm->debug.acc_diff_regs = dfx_regs_init(qm, dregs, reg_len);\n\tif (IS_ERR(qm->debug.acc_diff_regs)) {\n\t\tdfx_regs_uninit(qm, qm->debug.qm_diff_regs, ARRAY_SIZE(qm_diff_regs));\n\t\treturn PTR_ERR(qm->debug.acc_diff_regs);\n\t}\n\n\treturn 0;\n}\n\nstatic void qm_last_regs_uninit(struct hisi_qm *qm)\n{\n\tstruct qm_debug *debug = &qm->debug;\n\n\tif (qm->fun_type == QM_HW_VF || !debug->qm_last_words)\n\t\treturn;\n\n\tkfree(debug->qm_last_words);\n\tdebug->qm_last_words = NULL;\n}\n\nstatic int qm_last_regs_init(struct hisi_qm *qm)\n{\n\tint dfx_regs_num = ARRAY_SIZE(qm_dfx_regs);\n\tstruct qm_debug *debug = &qm->debug;\n\tint i;\n\n\tif (qm->fun_type == QM_HW_VF)\n\t\treturn 0;\n\n\tdebug->qm_last_words = kcalloc(dfx_regs_num, sizeof(unsigned int), GFP_KERNEL);\n\tif (!debug->qm_last_words)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < dfx_regs_num; i++) {\n\t\tdebug->qm_last_words[i] = readl_relaxed(qm->io_base +\n\t\t\tqm_dfx_regs[i].offset);\n\t}\n\n\treturn 0;\n}\n\nstatic void qm_diff_regs_uninit(struct hisi_qm *qm, u32 reg_len)\n{\n\tdfx_regs_uninit(qm, qm->debug.acc_diff_regs, reg_len);\n\tdfx_regs_uninit(qm, qm->debug.qm_diff_regs, ARRAY_SIZE(qm_diff_regs));\n}\n\n \nint hisi_qm_regs_debugfs_init(struct hisi_qm *qm,\n\t\tstruct dfx_diff_registers *dregs, u32 reg_len)\n{\n\tint ret;\n\n\tif (!qm || !dregs)\n\t\treturn -EINVAL;\n\n\tif (qm->fun_type != QM_HW_PF)\n\t\treturn 0;\n\n\tret = qm_last_regs_init(qm);\n\tif (ret) {\n\t\tdev_info(&qm->pdev->dev, \"failed to init qm words memory!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = qm_diff_regs_init(qm, dregs, reg_len);\n\tif (ret) {\n\t\tqm_last_regs_uninit(qm);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hisi_qm_regs_debugfs_init);\n\n \nvoid hisi_qm_regs_debugfs_uninit(struct hisi_qm *qm, u32 reg_len)\n{\n\tif (!qm || qm->fun_type != QM_HW_PF)\n\t\treturn;\n\n\tqm_diff_regs_uninit(qm, reg_len);\n\tqm_last_regs_uninit(qm);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_regs_debugfs_uninit);\n\n \nvoid hisi_qm_acc_diff_regs_dump(struct hisi_qm *qm, struct seq_file *s,\n\tstruct dfx_diff_registers *dregs, u32 regs_len)\n{\n\tu32 j, val, base_offset;\n\tint i, ret;\n\n\tif (!qm || !s || !dregs)\n\t\treturn;\n\n\tret = hisi_qm_get_dfx_access(qm);\n\tif (ret)\n\t\treturn;\n\n\tdown_read(&qm->qps_lock);\n\tfor (i = 0; i < regs_len; i++) {\n\t\tif (!dregs[i].reg_len)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < dregs[i].reg_len; j++) {\n\t\t\tbase_offset = dregs[i].reg_offset + j * QM_DFX_REGS_LEN;\n\t\t\tval = readl(qm->io_base + base_offset);\n\t\t\tif (val != dregs[i].regs[j])\n\t\t\t\tseq_printf(s, \"0x%08x = 0x%08x ---> 0x%08x\\n\",\n\t\t\t\t\t   base_offset, dregs[i].regs[j], val);\n\t\t}\n\t}\n\tup_read(&qm->qps_lock);\n\n\thisi_qm_put_dfx_access(qm);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_acc_diff_regs_dump);\n\nvoid hisi_qm_show_last_dfx_regs(struct hisi_qm *qm)\n{\n\tstruct qm_debug *debug = &qm->debug;\n\tstruct pci_dev *pdev = qm->pdev;\n\tu32 val;\n\tint i;\n\n\tif (qm->fun_type == QM_HW_VF || !debug->qm_last_words)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(qm_dfx_regs); i++) {\n\t\tval = readl_relaxed(qm->io_base + qm_dfx_regs[i].offset);\n\t\tif (debug->qm_last_words[i] != val)\n\t\t\tpci_info(pdev, \"%s \\t= 0x%08x => 0x%08x\\n\",\n\t\t\tqm_dfx_regs[i].name, debug->qm_last_words[i], val);\n\t}\n}\n\nstatic int qm_diff_regs_show(struct seq_file *s, void *unused)\n{\n\tstruct hisi_qm *qm = s->private;\n\n\thisi_qm_acc_diff_regs_dump(qm, s, qm->debug.qm_diff_regs,\n\t\t\t\t\tARRAY_SIZE(qm_diff_regs));\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(qm_diff_regs);\n\nstatic ssize_t qm_status_read(struct file *filp, char __user *buffer,\n\t\t\t      size_t count, loff_t *pos)\n{\n\tstruct hisi_qm *qm = filp->private_data;\n\tchar buf[QM_DBG_READ_LEN];\n\tint val, len;\n\n\tval = atomic_read(&qm->status.flags);\n\tlen = scnprintf(buf, QM_DBG_READ_LEN, \"%s\\n\", qm_s[val]);\n\n\treturn simple_read_from_buffer(buffer, count, pos, buf, len);\n}\n\nstatic const struct file_operations qm_status_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = qm_status_read,\n};\n\nstatic void qm_create_debugfs_file(struct hisi_qm *qm, struct dentry *dir,\n\t\t\t\t   enum qm_debug_file index)\n{\n\tstruct debugfs_file *file = qm->debug.files + index;\n\n\tdebugfs_create_file(qm_debug_file_name[index], 0600, dir, file,\n\t\t\t    &qm_debug_fops);\n\n\tfile->index = index;\n\tmutex_init(&file->lock);\n\tfile->debug = &qm->debug;\n}\n\nstatic int qm_debugfs_atomic64_set(void *data, u64 val)\n{\n\tif (val)\n\t\treturn -EINVAL;\n\n\tatomic64_set((atomic64_t *)data, 0);\n\n\treturn 0;\n}\n\nstatic int qm_debugfs_atomic64_get(void *data, u64 *val)\n{\n\t*val = atomic64_read((atomic64_t *)data);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(qm_atomic64_ops, qm_debugfs_atomic64_get,\n\t\t\t qm_debugfs_atomic64_set, \"%llu\\n\");\n\n \nvoid hisi_qm_debug_init(struct hisi_qm *qm)\n{\n\tstruct dfx_diff_registers *qm_regs = qm->debug.qm_diff_regs;\n\tstruct qm_dfx *dfx = &qm->debug.dfx;\n\tstruct dentry *qm_d;\n\tvoid *data;\n\tint i;\n\n\tqm_d = debugfs_create_dir(\"qm\", qm->debug.debug_root);\n\tqm->debug.qm_d = qm_d;\n\n\t \n\tif (qm->fun_type == QM_HW_PF) {\n\t\tqm_create_debugfs_file(qm, qm->debug.debug_root, CURRENT_QM);\n\t\tfor (i = CURRENT_Q; i < DEBUG_FILE_NUM; i++)\n\t\t\tqm_create_debugfs_file(qm, qm->debug.qm_d, i);\n\t}\n\n\tif (qm_regs)\n\t\tdebugfs_create_file(\"diff_regs\", 0444, qm->debug.qm_d,\n\t\t\t\t\tqm, &qm_diff_regs_fops);\n\n\tdebugfs_create_file(\"regs\", 0444, qm->debug.qm_d, qm, &qm_regs_fops);\n\n\tdebugfs_create_file(\"cmd\", 0600, qm->debug.qm_d, qm, &qm_cmd_fops);\n\n\tdebugfs_create_file(\"status\", 0444, qm->debug.qm_d, qm,\n\t\t\t&qm_status_fops);\n\tfor (i = 0; i < ARRAY_SIZE(qm_dfx_files); i++) {\n\t\tdata = (atomic64_t *)((uintptr_t)dfx + qm_dfx_files[i].offset);\n\t\tdebugfs_create_file(qm_dfx_files[i].name,\n\t\t\t0644,\n\t\t\tqm_d,\n\t\t\tdata,\n\t\t\t&qm_atomic64_ops);\n\t}\n\n\tif (test_bit(QM_SUPPORT_FUNC_QOS, &qm->caps))\n\t\thisi_qm_set_algqos_init(qm);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_debug_init);\n\n \nvoid hisi_qm_debug_regs_clear(struct hisi_qm *qm)\n{\n\tconst struct debugfs_reg32 *regs;\n\tint i;\n\n\t \n\twritel(0x0, qm->io_base + QM_DFX_MB_CNT_VF);\n\twritel(0x0, qm->io_base + QM_DFX_DB_CNT_VF);\n\n\t \n\twritel(0x0, qm->io_base + QM_DFX_SQE_CNT_VF_SQN);\n\twritel(0x0, qm->io_base + QM_DFX_CQE_CNT_VF_CQN);\n\n\t \n\twritel(0x1, qm->io_base + QM_DFX_CNT_CLR_CE);\n\n\tregs = qm_dfx_regs;\n\tfor (i = 0; i < CNT_CYC_REGS_NUM; i++) {\n\t\treadl(qm->io_base + regs->offset);\n\t\tregs++;\n\t}\n\n\t \n\twritel(0x0, qm->io_base + QM_DFX_CNT_CLR_CE);\n}\nEXPORT_SYMBOL_GPL(hisi_qm_debug_regs_clear);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}