{
  "module_name": "trng.c",
  "hash_id": "3c6cd6dcbdde87df902c13e58baa5e3c63923ce53c5f4a26e877786d18146a8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/hisilicon/trng/trng.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/crypto.h>\n#include <linux/err.h>\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/random.h>\n#include <crypto/internal/rng.h>\n\n#define HISI_TRNG_REG\t\t0x00F0\n#define HISI_TRNG_BYTES\t\t4\n#define HISI_TRNG_QUALITY\t512\n#define HISI_TRNG_VERSION\t0x01B8\n#define HISI_TRNG_VER_V1\tGENMASK(31, 0)\n#define SLEEP_US\t\t10\n#define TIMEOUT_US\t\t10000\n#define SW_DRBG_NUM_SHIFT\t2\n#define SW_DRBG_KEY_BASE\t0x082C\n#define SW_DRBG_SEED(n)         (SW_DRBG_KEY_BASE - ((n) << SW_DRBG_NUM_SHIFT))\n#define SW_DRBG_SEED_REGS_NUM\t12\n#define SW_DRBG_SEED_SIZE\t48\n#define SW_DRBG_BLOCKS\t\t0x0830\n#define SW_DRBG_INIT\t\t0x0834\n#define SW_DRBG_GEN\t\t0x083c\n#define SW_DRBG_STATUS\t\t0x0840\n#define SW_DRBG_BLOCKS_NUM\t4095\n#define SW_DRBG_DATA_BASE\t0x0850\n#define SW_DRBG_DATA_NUM\t4\n#define SW_DRBG_DATA(n)\t\t(SW_DRBG_DATA_BASE - ((n) << SW_DRBG_NUM_SHIFT))\n#define SW_DRBG_BYTES\t\t16\n#define SW_DRBG_ENABLE_SHIFT\t12\n#define SEED_SHIFT_24\t\t24\n#define SEED_SHIFT_16\t\t16\n#define SEED_SHIFT_8\t\t8\n\nstruct hisi_trng_list {\n\tstruct mutex lock;\n\tstruct list_head list;\n\tbool is_init;\n};\n\nstruct hisi_trng {\n\tvoid __iomem *base;\n\tstruct hisi_trng_list *trng_list;\n\tstruct list_head list;\n\tstruct hwrng rng;\n\tu32 ver;\n\tbool is_used;\n\tstruct mutex mutex;\n};\n\nstruct hisi_trng_ctx {\n\tstruct hisi_trng *trng;\n};\n\nstatic atomic_t trng_active_devs;\nstatic struct hisi_trng_list trng_devices;\n\nstatic void hisi_trng_set_seed(struct hisi_trng *trng, const u8 *seed)\n{\n\tu32 val, seed_reg, i;\n\n\tfor (i = 0; i < SW_DRBG_SEED_SIZE;\n\t     i += SW_DRBG_SEED_SIZE / SW_DRBG_SEED_REGS_NUM) {\n\t\tval = seed[i] << SEED_SHIFT_24;\n\t\tval |= seed[i + 1UL] << SEED_SHIFT_16;\n\t\tval |= seed[i + 2UL] << SEED_SHIFT_8;\n\t\tval |= seed[i + 3UL];\n\n\t\tseed_reg = (i >> SW_DRBG_NUM_SHIFT) % SW_DRBG_SEED_REGS_NUM;\n\t\twritel(val, trng->base + SW_DRBG_SEED(seed_reg));\n\t}\n}\n\nstatic int hisi_trng_seed(struct crypto_rng *tfm, const u8 *seed,\n\t\t\t  unsigned int slen)\n{\n\tstruct hisi_trng_ctx *ctx = crypto_rng_ctx(tfm);\n\tstruct hisi_trng *trng = ctx->trng;\n\tu32 val = 0;\n\tint ret = 0;\n\n\tif (slen < SW_DRBG_SEED_SIZE) {\n\t\tpr_err(\"slen(%u) is not matched with trng(%d)\\n\", slen,\n\t\t\tSW_DRBG_SEED_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\twritel(0x0, trng->base + SW_DRBG_BLOCKS);\n\thisi_trng_set_seed(trng, seed);\n\n\twritel(SW_DRBG_BLOCKS_NUM | (0x1 << SW_DRBG_ENABLE_SHIFT),\n\t       trng->base + SW_DRBG_BLOCKS);\n\twritel(0x1, trng->base + SW_DRBG_INIT);\n\n\tret = readl_relaxed_poll_timeout(trng->base + SW_DRBG_STATUS,\n\t\t\t\t\tval, val & BIT(0), SLEEP_US, TIMEOUT_US);\n\tif (ret)\n\t\tpr_err(\"fail to init trng(%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hisi_trng_generate(struct crypto_rng *tfm, const u8 *src,\n\t\t\t      unsigned int slen, u8 *dstn, unsigned int dlen)\n{\n\tstruct hisi_trng_ctx *ctx = crypto_rng_ctx(tfm);\n\tstruct hisi_trng *trng = ctx->trng;\n\tu32 data[SW_DRBG_DATA_NUM];\n\tu32 currsize = 0;\n\tu32 val = 0;\n\tint ret;\n\tu32 i;\n\n\tif (dlen > SW_DRBG_BLOCKS_NUM * SW_DRBG_BYTES || dlen == 0) {\n\t\tpr_err(\"dlen(%d) exceeds limit(%d)!\\n\", dlen,\n\t\t\tSW_DRBG_BLOCKS_NUM * SW_DRBG_BYTES);\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tret = readl_relaxed_poll_timeout(trng->base + SW_DRBG_STATUS,\n\t\t     val, val & BIT(1), SLEEP_US, TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tpr_err(\"fail to generate random number(%d)!\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < SW_DRBG_DATA_NUM; i++)\n\t\t\tdata[i] = readl(trng->base + SW_DRBG_DATA(i));\n\n\t\tif (dlen - currsize >= SW_DRBG_BYTES) {\n\t\t\tmemcpy(dstn + currsize, data, SW_DRBG_BYTES);\n\t\t\tcurrsize += SW_DRBG_BYTES;\n\t\t} else {\n\t\t\tmemcpy(dstn + currsize, data, dlen - currsize);\n\t\t\tcurrsize = dlen;\n\t\t}\n\n\t\twritel(0x1, trng->base + SW_DRBG_GEN);\n\t} while (currsize < dlen);\n\n\treturn ret;\n}\n\nstatic int hisi_trng_init(struct crypto_tfm *tfm)\n{\n\tstruct hisi_trng_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct hisi_trng *trng;\n\tint ret = -EBUSY;\n\n\tmutex_lock(&trng_devices.lock);\n\tlist_for_each_entry(trng, &trng_devices.list, list) {\n\t\tif (!trng->is_used) {\n\t\t\ttrng->is_used = true;\n\t\t\tctx->trng = trng;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trng_devices.lock);\n\n\treturn ret;\n}\n\nstatic void hisi_trng_exit(struct crypto_tfm *tfm)\n{\n\tstruct hisi_trng_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tmutex_lock(&trng_devices.lock);\n\tctx->trng->is_used = false;\n\tmutex_unlock(&trng_devices.lock);\n}\n\nstatic int hisi_trng_read(struct hwrng *rng, void *buf, size_t max, bool wait)\n{\n\tstruct hisi_trng *trng;\n\tint currsize = 0;\n\tu32 val = 0;\n\tint ret;\n\n\ttrng = container_of(rng, struct hisi_trng, rng);\n\n\tdo {\n\t\tret = readl_poll_timeout(trng->base + HISI_TRNG_REG, val,\n\t\t\t\t\t val, SLEEP_US, TIMEOUT_US);\n\t\tif (ret)\n\t\t\treturn currsize;\n\n\t\tif (max - currsize >= HISI_TRNG_BYTES) {\n\t\t\tmemcpy(buf + currsize, &val, HISI_TRNG_BYTES);\n\t\t\tcurrsize += HISI_TRNG_BYTES;\n\t\t\tif (currsize == max)\n\t\t\t\treturn currsize;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmemcpy(buf + currsize, &val, max - currsize);\n\t\tcurrsize = max;\n\t} while (currsize < max);\n\n\treturn currsize;\n}\n\nstatic struct rng_alg hisi_trng_alg = {\n\t.generate = hisi_trng_generate,\n\t.seed =\thisi_trng_seed,\n\t.seedsize = SW_DRBG_SEED_SIZE,\n\t.base = {\n\t\t.cra_name = \"stdrng\",\n\t\t.cra_driver_name = \"hisi_stdrng\",\n\t\t.cra_priority = 300,\n\t\t.cra_ctxsize = sizeof(struct hisi_trng_ctx),\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_init = hisi_trng_init,\n\t\t.cra_exit = hisi_trng_exit,\n\t},\n};\n\nstatic void hisi_trng_add_to_list(struct hisi_trng *trng)\n{\n\tmutex_lock(&trng_devices.lock);\n\tlist_add_tail(&trng->list, &trng_devices.list);\n\tmutex_unlock(&trng_devices.lock);\n}\n\nstatic int hisi_trng_del_from_list(struct hisi_trng *trng)\n{\n\tint ret = -EBUSY;\n\n\tmutex_lock(&trng_devices.lock);\n\tif (!trng->is_used) {\n\t\tlist_del(&trng->list);\n\t\tret = 0;\n\t}\n\tmutex_unlock(&trng_devices.lock);\n\n\treturn ret;\n}\n\nstatic int hisi_trng_probe(struct platform_device *pdev)\n{\n\tstruct hisi_trng *trng;\n\tint ret;\n\n\ttrng = devm_kzalloc(&pdev->dev, sizeof(*trng), GFP_KERNEL);\n\tif (!trng)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, trng);\n\n\ttrng->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(trng->base))\n\t\treturn PTR_ERR(trng->base);\n\n\ttrng->is_used = false;\n\ttrng->ver = readl(trng->base + HISI_TRNG_VERSION);\n\tif (!trng_devices.is_init) {\n\t\tINIT_LIST_HEAD(&trng_devices.list);\n\t\tmutex_init(&trng_devices.lock);\n\t\ttrng_devices.is_init = true;\n\t}\n\n\thisi_trng_add_to_list(trng);\n\tif (trng->ver != HISI_TRNG_VER_V1 &&\n\t    atomic_inc_return(&trng_active_devs) == 1) {\n\t\tret = crypto_register_rng(&hisi_trng_alg);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to register crypto(%d)\\n\", ret);\n\t\t\tatomic_dec_return(&trng_active_devs);\n\t\t\tgoto err_remove_from_list;\n\t\t}\n\t}\n\n\ttrng->rng.name = pdev->name;\n\ttrng->rng.read = hisi_trng_read;\n\ttrng->rng.quality = HISI_TRNG_QUALITY;\n\tret = devm_hwrng_register(&pdev->dev, &trng->rng);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register hwrng: %d!\\n\", ret);\n\t\tgoto err_crypto_unregister;\n\t}\n\n\treturn ret;\n\nerr_crypto_unregister:\n\tif (trng->ver != HISI_TRNG_VER_V1 &&\n\t    atomic_dec_return(&trng_active_devs) == 0)\n\t\tcrypto_unregister_rng(&hisi_trng_alg);\n\nerr_remove_from_list:\n\thisi_trng_del_from_list(trng);\n\treturn ret;\n}\n\nstatic int hisi_trng_remove(struct platform_device *pdev)\n{\n\tstruct hisi_trng *trng = platform_get_drvdata(pdev);\n\n\t \n\twhile (hisi_trng_del_from_list(trng))\n\t\t;\n\n\tif (trng->ver != HISI_TRNG_VER_V1 &&\n\t    atomic_dec_return(&trng_active_devs) == 0)\n\t\tcrypto_unregister_rng(&hisi_trng_alg);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id hisi_trng_acpi_match[] = {\n\t{ \"HISI02B3\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, hisi_trng_acpi_match);\n\nstatic struct platform_driver hisi_trng_driver = {\n\t.probe\t\t= hisi_trng_probe,\n\t.remove         = hisi_trng_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"hisi-trng-v2\",\n\t\t.acpi_match_table = ACPI_PTR(hisi_trng_acpi_match),\n\t},\n};\n\nmodule_platform_driver(hisi_trng_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Weili Qian <qianweili@huawei.com>\");\nMODULE_AUTHOR(\"Zaibo Xu <xuzaibo@huawei.com>\");\nMODULE_DESCRIPTION(\"HiSilicon true random number generator V2 driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}