{
  "module_name": "zip_main.c",
  "hash_id": "72bbfe327d560d14da662a9227b2e6c20f458b765eb546a604273968d78b08c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/hisilicon/zip/zip_main.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/debugfs.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/uacce.h>\n#include \"zip.h\"\n\n#define PCI_DEVICE_ID_HUAWEI_ZIP_PF\t0xa250\n\n#define HZIP_QUEUE_NUM_V1\t\t4096\n\n#define HZIP_CLOCK_GATE_CTRL\t\t0x301004\n#define HZIP_DECOMP_CHECK_ENABLE\tBIT(16)\n#define HZIP_FSM_MAX_CNT\t\t0x301008\n\n#define HZIP_PORT_ARCA_CHE_0\t\t0x301040\n#define HZIP_PORT_ARCA_CHE_1\t\t0x301044\n#define HZIP_PORT_AWCA_CHE_0\t\t0x301060\n#define HZIP_PORT_AWCA_CHE_1\t\t0x301064\n#define HZIP_CACHE_ALL_EN\t\t0xffffffff\n\n#define HZIP_BD_RUSER_32_63\t\t0x301110\n#define HZIP_SGL_RUSER_32_63\t\t0x30111c\n#define HZIP_DATA_RUSER_32_63\t\t0x301128\n#define HZIP_DATA_WUSER_32_63\t\t0x301134\n#define HZIP_BD_WUSER_32_63\t\t0x301140\n\n#define HZIP_QM_IDEL_STATUS\t\t0x3040e4\n\n#define HZIP_CORE_DFX_BASE\t\t0x301000\n#define HZIP_CLOCK_GATED_CONTL\t\t0X301004\n#define HZIP_CORE_DFX_COMP_0\t\t0x302000\n#define HZIP_CORE_DFX_COMP_1\t\t0x303000\n#define HZIP_CORE_DFX_DECOMP_0\t\t0x304000\n#define HZIP_CORE_DFX_DECOMP_1\t\t0x305000\n#define HZIP_CORE_DFX_DECOMP_2\t\t0x306000\n#define HZIP_CORE_DFX_DECOMP_3\t\t0x307000\n#define HZIP_CORE_DFX_DECOMP_4\t\t0x308000\n#define HZIP_CORE_DFX_DECOMP_5\t\t0x309000\n#define HZIP_CORE_REGS_BASE_LEN\t\t0xB0\n#define HZIP_CORE_REGS_DFX_LEN\t\t0x28\n\n#define HZIP_CORE_INT_SOURCE\t\t0x3010A0\n#define HZIP_CORE_INT_MASK_REG\t\t0x3010A4\n#define HZIP_CORE_INT_SET\t\t0x3010A8\n#define HZIP_CORE_INT_STATUS\t\t0x3010AC\n#define HZIP_CORE_INT_STATUS_M_ECC\tBIT(1)\n#define HZIP_CORE_SRAM_ECC_ERR_INFO\t0x301148\n#define HZIP_CORE_INT_RAS_CE_ENB\t0x301160\n#define HZIP_CORE_INT_RAS_NFE_ENB\t0x301164\n#define HZIP_CORE_INT_RAS_FE_ENB        0x301168\n#define HZIP_CORE_INT_RAS_FE_ENB_MASK\t0x0\n#define HZIP_OOO_SHUTDOWN_SEL\t\t0x30120C\n#define HZIP_SRAM_ECC_ERR_NUM_SHIFT\t16\n#define HZIP_SRAM_ECC_ERR_ADDR_SHIFT\t24\n#define HZIP_CORE_INT_MASK_ALL\t\tGENMASK(12, 0)\n#define HZIP_SQE_SIZE\t\t\t128\n#define HZIP_PF_DEF_Q_NUM\t\t64\n#define HZIP_PF_DEF_Q_BASE\t\t0\n\n#define HZIP_SOFT_CTRL_CNT_CLR_CE\t0x301000\n#define HZIP_SOFT_CTRL_CNT_CLR_CE_BIT\tBIT(0)\n#define HZIP_SOFT_CTRL_ZIP_CONTROL\t0x30100C\n#define HZIP_AXI_SHUTDOWN_ENABLE\tBIT(14)\n#define HZIP_WR_PORT\t\t\tBIT(11)\n\n#define HZIP_ALG_ZLIB_BIT\t\tGENMASK(1, 0)\n#define HZIP_ALG_GZIP_BIT\t\tGENMASK(3, 2)\n#define HZIP_ALG_DEFLATE_BIT\t\tGENMASK(5, 4)\n#define HZIP_ALG_LZ77_BIT\t\tGENMASK(7, 6)\n\n#define HZIP_BUF_SIZE\t\t\t22\n#define HZIP_SQE_MASK_OFFSET\t\t64\n#define HZIP_SQE_MASK_LEN\t\t48\n\n#define HZIP_CNT_CLR_CE_EN\t\tBIT(0)\n#define HZIP_RO_CNT_CLR_CE_EN\t\tBIT(2)\n#define HZIP_RD_CNT_CLR_CE_EN\t\t(HZIP_CNT_CLR_CE_EN | \\\n\t\t\t\t\t HZIP_RO_CNT_CLR_CE_EN)\n\n#define HZIP_PREFETCH_CFG\t\t0x3011B0\n#define HZIP_SVA_TRANS\t\t\t0x3011C4\n#define HZIP_PREFETCH_ENABLE\t\t(~(BIT(26) | BIT(17) | BIT(0)))\n#define HZIP_SVA_PREFETCH_DISABLE\tBIT(26)\n#define HZIP_SVA_DISABLE_READY\t\t(BIT(26) | BIT(30))\n#define HZIP_SHAPER_RATE_COMPRESS\t750\n#define HZIP_SHAPER_RATE_DECOMPRESS\t140\n#define HZIP_DELAY_1_US\t\t1\n#define HZIP_POLL_TIMEOUT_US\t1000\n\n \n#define HZIP_PEH_CFG_AUTO_GATE\t\t0x3011A8\n#define HZIP_PEH_CFG_AUTO_GATE_EN\tBIT(0)\n#define HZIP_CORE_GATED_EN\t\tGENMASK(15, 8)\n#define HZIP_CORE_GATED_OOO_EN\t\tBIT(29)\n#define HZIP_CLOCK_GATED_EN\t\t(HZIP_CORE_GATED_EN | \\\n\t\t\t\t\t HZIP_CORE_GATED_OOO_EN)\n\n \n#define HZIP_HIGH_PERF_OFFSET\t\t0x301208\n\nenum {\n\tHZIP_HIGH_COMP_RATE,\n\tHZIP_HIGH_COMP_PERF,\n};\n\nstatic const char hisi_zip_name[] = \"hisi_zip\";\nstatic struct dentry *hzip_debugfs_root;\n\nstruct hisi_zip_hw_error {\n\tu32 int_msk;\n\tconst char *msg;\n};\n\nstruct zip_dfx_item {\n\tconst char *name;\n\tu32 offset;\n};\n\nstatic const struct qm_dev_alg zip_dev_algs[] = { {\n\t\t.alg_msk = HZIP_ALG_ZLIB_BIT,\n\t\t.alg = \"zlib\\n\",\n\t}, {\n\t\t.alg_msk = HZIP_ALG_GZIP_BIT,\n\t\t.alg = \"gzip\\n\",\n\t}, {\n\t\t.alg_msk = HZIP_ALG_DEFLATE_BIT,\n\t\t.alg = \"deflate\\n\",\n\t}, {\n\t\t.alg_msk = HZIP_ALG_LZ77_BIT,\n\t\t.alg = \"lz77_zstd\\n\",\n\t},\n};\n\nstatic struct hisi_qm_list zip_devices = {\n\t.register_to_crypto\t= hisi_zip_register_to_crypto,\n\t.unregister_from_crypto\t= hisi_zip_unregister_from_crypto,\n};\n\nstatic struct zip_dfx_item zip_dfx_files[] = {\n\t{\"send_cnt\", offsetof(struct hisi_zip_dfx, send_cnt)},\n\t{\"recv_cnt\", offsetof(struct hisi_zip_dfx, recv_cnt)},\n\t{\"send_busy_cnt\", offsetof(struct hisi_zip_dfx, send_busy_cnt)},\n\t{\"err_bd_cnt\", offsetof(struct hisi_zip_dfx, err_bd_cnt)},\n};\n\nstatic const struct hisi_zip_hw_error zip_hw_error[] = {\n\t{ .int_msk = BIT(0), .msg = \"zip_ecc_1bitt_err\" },\n\t{ .int_msk = BIT(1), .msg = \"zip_ecc_2bit_err\" },\n\t{ .int_msk = BIT(2), .msg = \"zip_axi_rresp_err\" },\n\t{ .int_msk = BIT(3), .msg = \"zip_axi_bresp_err\" },\n\t{ .int_msk = BIT(4), .msg = \"zip_src_addr_parse_err\" },\n\t{ .int_msk = BIT(5), .msg = \"zip_dst_addr_parse_err\" },\n\t{ .int_msk = BIT(6), .msg = \"zip_pre_in_addr_err\" },\n\t{ .int_msk = BIT(7), .msg = \"zip_pre_in_data_err\" },\n\t{ .int_msk = BIT(8), .msg = \"zip_com_inf_err\" },\n\t{ .int_msk = BIT(9), .msg = \"zip_enc_inf_err\" },\n\t{ .int_msk = BIT(10), .msg = \"zip_pre_out_err\" },\n\t{ .int_msk = BIT(11), .msg = \"zip_axi_poison_err\" },\n\t{ .int_msk = BIT(12), .msg = \"zip_sva_err\" },\n\t{   }\n};\n\nenum ctrl_debug_file_index {\n\tHZIP_CLEAR_ENABLE,\n\tHZIP_DEBUG_FILE_NUM,\n};\n\nstatic const char * const ctrl_debug_file_name[] = {\n\t[HZIP_CLEAR_ENABLE] = \"clear_enable\",\n};\n\nstruct ctrl_debug_file {\n\tenum ctrl_debug_file_index index;\n\tspinlock_t lock;\n\tstruct hisi_zip_ctrl *ctrl;\n};\n\n \nstruct hisi_zip_ctrl {\n\tstruct hisi_zip *hisi_zip;\n\tstruct ctrl_debug_file files[HZIP_DEBUG_FILE_NUM];\n};\n\nenum zip_cap_type {\n\tZIP_QM_NFE_MASK_CAP = 0x0,\n\tZIP_QM_RESET_MASK_CAP,\n\tZIP_QM_OOO_SHUTDOWN_MASK_CAP,\n\tZIP_QM_CE_MASK_CAP,\n\tZIP_NFE_MASK_CAP,\n\tZIP_RESET_MASK_CAP,\n\tZIP_OOO_SHUTDOWN_MASK_CAP,\n\tZIP_CE_MASK_CAP,\n\tZIP_CLUSTER_NUM_CAP,\n\tZIP_CORE_TYPE_NUM_CAP,\n\tZIP_CORE_NUM_CAP,\n\tZIP_CLUSTER_COMP_NUM_CAP,\n\tZIP_CLUSTER_DECOMP_NUM_CAP,\n\tZIP_DECOMP_ENABLE_BITMAP,\n\tZIP_COMP_ENABLE_BITMAP,\n\tZIP_DRV_ALG_BITMAP,\n\tZIP_DEV_ALG_BITMAP,\n\tZIP_CORE1_ALG_BITMAP,\n\tZIP_CORE2_ALG_BITMAP,\n\tZIP_CORE3_ALG_BITMAP,\n\tZIP_CORE4_ALG_BITMAP,\n\tZIP_CORE5_ALG_BITMAP,\n\tZIP_CAP_MAX\n};\n\nstatic struct hisi_qm_cap_info zip_basic_cap_info[] = {\n\t{ZIP_QM_NFE_MASK_CAP, 0x3124, 0, GENMASK(31, 0), 0x0, 0x1C57, 0x7C77},\n\t{ZIP_QM_RESET_MASK_CAP, 0x3128, 0, GENMASK(31, 0), 0x0, 0xC57, 0x6C77},\n\t{ZIP_QM_OOO_SHUTDOWN_MASK_CAP, 0x3128, 0, GENMASK(31, 0), 0x0, 0x4, 0x6C77},\n\t{ZIP_QM_CE_MASK_CAP, 0x312C, 0, GENMASK(31, 0), 0x0, 0x8, 0x8},\n\t{ZIP_NFE_MASK_CAP, 0x3130, 0, GENMASK(31, 0), 0x0, 0x7FE, 0x1FFE},\n\t{ZIP_RESET_MASK_CAP, 0x3134, 0, GENMASK(31, 0), 0x0, 0x7FE, 0x7FE},\n\t{ZIP_OOO_SHUTDOWN_MASK_CAP, 0x3134, 0, GENMASK(31, 0), 0x0, 0x2, 0x7FE},\n\t{ZIP_CE_MASK_CAP, 0x3138, 0, GENMASK(31, 0), 0x0, 0x1, 0x1},\n\t{ZIP_CLUSTER_NUM_CAP, 0x313C, 28, GENMASK(3, 0), 0x1, 0x1, 0x1},\n\t{ZIP_CORE_TYPE_NUM_CAP, 0x313C, 24, GENMASK(3, 0), 0x2, 0x2, 0x2},\n\t{ZIP_CORE_NUM_CAP, 0x313C, 16, GENMASK(7, 0), 0x8, 0x8, 0x5},\n\t{ZIP_CLUSTER_COMP_NUM_CAP, 0x313C, 8, GENMASK(7, 0), 0x2, 0x2, 0x2},\n\t{ZIP_CLUSTER_DECOMP_NUM_CAP, 0x313C, 0, GENMASK(7, 0), 0x6, 0x6, 0x3},\n\t{ZIP_DECOMP_ENABLE_BITMAP, 0x3140, 16, GENMASK(15, 0), 0xFC, 0xFC, 0x1C},\n\t{ZIP_COMP_ENABLE_BITMAP, 0x3140, 0, GENMASK(15, 0), 0x3, 0x3, 0x3},\n\t{ZIP_DRV_ALG_BITMAP, 0x3144, 0, GENMASK(31, 0), 0xF, 0xF, 0xF},\n\t{ZIP_DEV_ALG_BITMAP, 0x3148, 0, GENMASK(31, 0), 0xF, 0xF, 0xFF},\n\t{ZIP_CORE1_ALG_BITMAP, 0x314C, 0, GENMASK(31, 0), 0x5, 0x5, 0xD5},\n\t{ZIP_CORE2_ALG_BITMAP, 0x3150, 0, GENMASK(31, 0), 0x5, 0x5, 0xD5},\n\t{ZIP_CORE3_ALG_BITMAP, 0x3154, 0, GENMASK(31, 0), 0xA, 0xA, 0x2A},\n\t{ZIP_CORE4_ALG_BITMAP, 0x3158, 0, GENMASK(31, 0), 0xA, 0xA, 0x2A},\n\t{ZIP_CORE5_ALG_BITMAP, 0x315C, 0, GENMASK(31, 0), 0xA, 0xA, 0x2A},\n\t{ZIP_CAP_MAX, 0x317c, 0, GENMASK(0, 0), 0x0, 0x0, 0x0}\n};\n\nenum zip_pre_store_cap_idx {\n\tZIP_CORE_NUM_CAP_IDX = 0x0,\n\tZIP_CLUSTER_COMP_NUM_CAP_IDX,\n\tZIP_CLUSTER_DECOMP_NUM_CAP_IDX,\n\tZIP_DECOMP_ENABLE_BITMAP_IDX,\n\tZIP_COMP_ENABLE_BITMAP_IDX,\n\tZIP_DRV_ALG_BITMAP_IDX,\n\tZIP_DEV_ALG_BITMAP_IDX,\n};\n\nstatic const u32 zip_pre_store_caps[] = {\n\tZIP_CORE_NUM_CAP,\n\tZIP_CLUSTER_COMP_NUM_CAP,\n\tZIP_CLUSTER_DECOMP_NUM_CAP,\n\tZIP_DECOMP_ENABLE_BITMAP,\n\tZIP_COMP_ENABLE_BITMAP,\n\tZIP_DRV_ALG_BITMAP,\n\tZIP_DEV_ALG_BITMAP,\n};\n\nenum {\n\tHZIP_COMP_CORE0,\n\tHZIP_COMP_CORE1,\n\tHZIP_DECOMP_CORE0,\n\tHZIP_DECOMP_CORE1,\n\tHZIP_DECOMP_CORE2,\n\tHZIP_DECOMP_CORE3,\n\tHZIP_DECOMP_CORE4,\n\tHZIP_DECOMP_CORE5,\n};\n\nstatic const u64 core_offsets[] = {\n\t[HZIP_COMP_CORE0]   = 0x302000,\n\t[HZIP_COMP_CORE1]   = 0x303000,\n\t[HZIP_DECOMP_CORE0] = 0x304000,\n\t[HZIP_DECOMP_CORE1] = 0x305000,\n\t[HZIP_DECOMP_CORE2] = 0x306000,\n\t[HZIP_DECOMP_CORE3] = 0x307000,\n\t[HZIP_DECOMP_CORE4] = 0x308000,\n\t[HZIP_DECOMP_CORE5] = 0x309000,\n};\n\nstatic const struct debugfs_reg32 hzip_dfx_regs[] = {\n\t{\"HZIP_GET_BD_NUM                \",  0x00ull},\n\t{\"HZIP_GET_RIGHT_BD              \",  0x04ull},\n\t{\"HZIP_GET_ERROR_BD              \",  0x08ull},\n\t{\"HZIP_DONE_BD_NUM               \",  0x0cull},\n\t{\"HZIP_WORK_CYCLE                \",  0x10ull},\n\t{\"HZIP_IDLE_CYCLE                \",  0x18ull},\n\t{\"HZIP_MAX_DELAY                 \",  0x20ull},\n\t{\"HZIP_MIN_DELAY                 \",  0x24ull},\n\t{\"HZIP_AVG_DELAY                 \",  0x28ull},\n\t{\"HZIP_MEM_VISIBLE_DATA          \",  0x30ull},\n\t{\"HZIP_MEM_VISIBLE_ADDR          \",  0x34ull},\n\t{\"HZIP_CONSUMED_BYTE             \",  0x38ull},\n\t{\"HZIP_PRODUCED_BYTE             \",  0x40ull},\n\t{\"HZIP_COMP_INF                  \",  0x70ull},\n\t{\"HZIP_PRE_OUT                   \",  0x78ull},\n\t{\"HZIP_BD_RD                     \",  0x7cull},\n\t{\"HZIP_BD_WR                     \",  0x80ull},\n\t{\"HZIP_GET_BD_AXI_ERR_NUM        \",  0x84ull},\n\t{\"HZIP_GET_BD_PARSE_ERR_NUM      \",  0x88ull},\n\t{\"HZIP_ADD_BD_AXI_ERR_NUM        \",  0x8cull},\n\t{\"HZIP_DECOMP_STF_RELOAD_CURR_ST \",  0x94ull},\n\t{\"HZIP_DECOMP_LZ77_CURR_ST       \",  0x9cull},\n};\n\nstatic const struct debugfs_reg32 hzip_com_dfx_regs[] = {\n\t{\"HZIP_CLOCK_GATE_CTRL           \",  0x301004},\n\t{\"HZIP_CORE_INT_RAS_CE_ENB       \",  0x301160},\n\t{\"HZIP_CORE_INT_RAS_NFE_ENB      \",  0x301164},\n\t{\"HZIP_CORE_INT_RAS_FE_ENB       \",  0x301168},\n\t{\"HZIP_UNCOM_ERR_RAS_CTRL        \",  0x30116C},\n};\n\nstatic const struct debugfs_reg32 hzip_dump_dfx_regs[] = {\n\t{\"HZIP_GET_BD_NUM                \",  0x00ull},\n\t{\"HZIP_GET_RIGHT_BD              \",  0x04ull},\n\t{\"HZIP_GET_ERROR_BD              \",  0x08ull},\n\t{\"HZIP_DONE_BD_NUM               \",  0x0cull},\n\t{\"HZIP_MAX_DELAY                 \",  0x20ull},\n};\n\n \nstatic struct dfx_diff_registers hzip_diff_regs[] = {\n\t{\n\t\t.reg_offset = HZIP_CORE_DFX_BASE,\n\t\t.reg_len = HZIP_CORE_REGS_BASE_LEN,\n\t}, {\n\t\t.reg_offset = HZIP_CORE_DFX_COMP_0,\n\t\t.reg_len = HZIP_CORE_REGS_DFX_LEN,\n\t}, {\n\t\t.reg_offset = HZIP_CORE_DFX_COMP_1,\n\t\t.reg_len = HZIP_CORE_REGS_DFX_LEN,\n\t}, {\n\t\t.reg_offset = HZIP_CORE_DFX_DECOMP_0,\n\t\t.reg_len = HZIP_CORE_REGS_DFX_LEN,\n\t}, {\n\t\t.reg_offset = HZIP_CORE_DFX_DECOMP_1,\n\t\t.reg_len = HZIP_CORE_REGS_DFX_LEN,\n\t}, {\n\t\t.reg_offset = HZIP_CORE_DFX_DECOMP_2,\n\t\t.reg_len = HZIP_CORE_REGS_DFX_LEN,\n\t}, {\n\t\t.reg_offset = HZIP_CORE_DFX_DECOMP_3,\n\t\t.reg_len = HZIP_CORE_REGS_DFX_LEN,\n\t}, {\n\t\t.reg_offset = HZIP_CORE_DFX_DECOMP_4,\n\t\t.reg_len = HZIP_CORE_REGS_DFX_LEN,\n\t}, {\n\t\t.reg_offset = HZIP_CORE_DFX_DECOMP_5,\n\t\t.reg_len = HZIP_CORE_REGS_DFX_LEN,\n\t},\n};\n\nstatic int hzip_diff_regs_show(struct seq_file *s, void *unused)\n{\n\tstruct hisi_qm *qm = s->private;\n\n\thisi_qm_acc_diff_regs_dump(qm, s, qm->debug.acc_diff_regs,\n\t\t\t\t\tARRAY_SIZE(hzip_diff_regs));\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(hzip_diff_regs);\n\nstatic int perf_mode_set(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tu32 n;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tret = kstrtou32(val, 10, &n);\n\tif (ret != 0 || (n != HZIP_HIGH_COMP_PERF &&\n\t\t\t n != HZIP_HIGH_COMP_RATE))\n\t\treturn -EINVAL;\n\n\treturn param_set_int(val, kp);\n}\n\nstatic const struct kernel_param_ops zip_com_perf_ops = {\n\t.set = perf_mode_set,\n\t.get = param_get_int,\n};\n\n \nstatic u32 perf_mode = HZIP_HIGH_COMP_RATE;\nmodule_param_cb(perf_mode, &zip_com_perf_ops, &perf_mode, 0444);\nMODULE_PARM_DESC(perf_mode, \"ZIP high perf mode 0(default), 1(enable)\");\n\nstatic const struct kernel_param_ops zip_uacce_mode_ops = {\n\t.set = uacce_mode_set,\n\t.get = param_get_int,\n};\n\n \nstatic u32 uacce_mode = UACCE_MODE_NOUACCE;\nmodule_param_cb(uacce_mode, &zip_uacce_mode_ops, &uacce_mode, 0444);\nMODULE_PARM_DESC(uacce_mode, UACCE_MODE_DESC);\n\nstatic bool pf_q_num_flag;\nstatic int pf_q_num_set(const char *val, const struct kernel_param *kp)\n{\n\tpf_q_num_flag = true;\n\n\treturn q_num_set(val, kp, PCI_DEVICE_ID_HUAWEI_ZIP_PF);\n}\n\nstatic const struct kernel_param_ops pf_q_num_ops = {\n\t.set = pf_q_num_set,\n\t.get = param_get_int,\n};\n\nstatic u32 pf_q_num = HZIP_PF_DEF_Q_NUM;\nmodule_param_cb(pf_q_num, &pf_q_num_ops, &pf_q_num, 0444);\nMODULE_PARM_DESC(pf_q_num, \"Number of queues in PF(v1 2-4096, v2 2-1024)\");\n\nstatic const struct kernel_param_ops vfs_num_ops = {\n\t.set = vfs_num_set,\n\t.get = param_get_int,\n};\n\nstatic u32 vfs_num;\nmodule_param_cb(vfs_num, &vfs_num_ops, &vfs_num, 0444);\nMODULE_PARM_DESC(vfs_num, \"Number of VFs to enable(1-63), 0(default)\");\n\nstatic const struct pci_device_id hisi_zip_dev_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HUAWEI, PCI_DEVICE_ID_HUAWEI_ZIP_PF) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_HUAWEI, PCI_DEVICE_ID_HUAWEI_ZIP_VF) },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, hisi_zip_dev_ids);\n\nint zip_create_qps(struct hisi_qp **qps, int qp_num, int node)\n{\n\tif (node == NUMA_NO_NODE)\n\t\tnode = cpu_to_node(smp_processor_id());\n\n\treturn hisi_qm_alloc_qps_node(&zip_devices, qp_num, 0, node, qps);\n}\n\nbool hisi_zip_alg_support(struct hisi_qm *qm, u32 alg)\n{\n\tu32 cap_val;\n\n\tcap_val = qm->cap_tables.dev_cap_table[ZIP_DRV_ALG_BITMAP_IDX].cap_val;\n\tif ((alg & cap_val) == alg)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int hisi_zip_set_high_perf(struct hisi_qm *qm)\n{\n\tu32 val;\n\tint ret;\n\n\tval = readl_relaxed(qm->io_base + HZIP_HIGH_PERF_OFFSET);\n\tif (perf_mode == HZIP_HIGH_COMP_PERF)\n\t\tval |= HZIP_HIGH_COMP_PERF;\n\telse\n\t\tval &= ~HZIP_HIGH_COMP_PERF;\n\n\t \n\twritel(val, qm->io_base + HZIP_HIGH_PERF_OFFSET);\n\tret = readl_relaxed_poll_timeout(qm->io_base + HZIP_HIGH_PERF_OFFSET,\n\t\t\t\t\t val, val == perf_mode, HZIP_DELAY_1_US,\n\t\t\t\t\t HZIP_POLL_TIMEOUT_US);\n\tif (ret)\n\t\tpci_err(qm->pdev, \"failed to set perf mode\\n\");\n\n\treturn ret;\n}\n\nstatic void hisi_zip_open_sva_prefetch(struct hisi_qm *qm)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!test_bit(QM_SUPPORT_SVA_PREFETCH, &qm->caps))\n\t\treturn;\n\n\t \n\tval = readl_relaxed(qm->io_base + HZIP_PREFETCH_CFG);\n\tval &= HZIP_PREFETCH_ENABLE;\n\twritel(val, qm->io_base + HZIP_PREFETCH_CFG);\n\n\tret = readl_relaxed_poll_timeout(qm->io_base + HZIP_PREFETCH_CFG,\n\t\t\t\t\t val, !(val & HZIP_SVA_PREFETCH_DISABLE),\n\t\t\t\t\t HZIP_DELAY_1_US, HZIP_POLL_TIMEOUT_US);\n\tif (ret)\n\t\tpci_err(qm->pdev, \"failed to open sva prefetch\\n\");\n}\n\nstatic void hisi_zip_close_sva_prefetch(struct hisi_qm *qm)\n{\n\tu32 val;\n\tint ret;\n\n\tif (!test_bit(QM_SUPPORT_SVA_PREFETCH, &qm->caps))\n\t\treturn;\n\n\tval = readl_relaxed(qm->io_base + HZIP_PREFETCH_CFG);\n\tval |= HZIP_SVA_PREFETCH_DISABLE;\n\twritel(val, qm->io_base + HZIP_PREFETCH_CFG);\n\n\tret = readl_relaxed_poll_timeout(qm->io_base + HZIP_SVA_TRANS,\n\t\t\t\t\t val, !(val & HZIP_SVA_DISABLE_READY),\n\t\t\t\t\t HZIP_DELAY_1_US, HZIP_POLL_TIMEOUT_US);\n\tif (ret)\n\t\tpci_err(qm->pdev, \"failed to close sva prefetch\\n\");\n}\n\nstatic void hisi_zip_enable_clock_gate(struct hisi_qm *qm)\n{\n\tu32 val;\n\n\tif (qm->ver < QM_HW_V3)\n\t\treturn;\n\n\tval = readl(qm->io_base + HZIP_CLOCK_GATE_CTRL);\n\tval |= HZIP_CLOCK_GATED_EN;\n\twritel(val, qm->io_base + HZIP_CLOCK_GATE_CTRL);\n\n\tval = readl(qm->io_base + HZIP_PEH_CFG_AUTO_GATE);\n\tval |= HZIP_PEH_CFG_AUTO_GATE_EN;\n\twritel(val, qm->io_base + HZIP_PEH_CFG_AUTO_GATE);\n}\n\nstatic int hisi_zip_set_user_domain_and_cache(struct hisi_qm *qm)\n{\n\tvoid __iomem *base = qm->io_base;\n\tu32 dcomp_bm, comp_bm;\n\n\t \n\twritel(AXUSER_BASE, base + QM_ARUSER_M_CFG_1);\n\twritel(ARUSER_M_CFG_ENABLE, base + QM_ARUSER_M_CFG_ENABLE);\n\twritel(AXUSER_BASE, base + QM_AWUSER_M_CFG_1);\n\twritel(AWUSER_M_CFG_ENABLE, base + QM_AWUSER_M_CFG_ENABLE);\n\twritel(WUSER_M_CFG_ENABLE, base + QM_WUSER_M_CFG_ENABLE);\n\n\t \n\twritel(AXI_M_CFG, base + QM_AXI_M_CFG);\n\twritel(AXI_M_CFG_ENABLE, base + QM_AXI_M_CFG_ENABLE);\n\n\t \n\twritel(PEH_AXUSER_CFG, base + QM_PEH_AXUSER_CFG);\n\twritel(PEH_AXUSER_CFG_ENABLE, base + QM_PEH_AXUSER_CFG_ENABLE);\n\n\t \n\twritel(HZIP_CACHE_ALL_EN, base + HZIP_PORT_ARCA_CHE_0);\n\twritel(HZIP_CACHE_ALL_EN, base + HZIP_PORT_ARCA_CHE_1);\n\twritel(HZIP_CACHE_ALL_EN, base + HZIP_PORT_AWCA_CHE_0);\n\twritel(HZIP_CACHE_ALL_EN, base + HZIP_PORT_AWCA_CHE_1);\n\n\t \n\twritel(AXUSER_BASE, base + HZIP_BD_RUSER_32_63);\n\twritel(AXUSER_BASE, base + HZIP_BD_WUSER_32_63);\n\n\tif (qm->use_sva && qm->ver == QM_HW_V2) {\n\t\twritel(AXUSER_BASE | AXUSER_SSV, base + HZIP_DATA_RUSER_32_63);\n\t\twritel(AXUSER_BASE | AXUSER_SSV, base + HZIP_DATA_WUSER_32_63);\n\t\twritel(AXUSER_BASE | AXUSER_SSV, base + HZIP_SGL_RUSER_32_63);\n\t} else {\n\t\twritel(AXUSER_BASE, base + HZIP_DATA_RUSER_32_63);\n\t\twritel(AXUSER_BASE, base + HZIP_DATA_WUSER_32_63);\n\t\twritel(AXUSER_BASE, base + HZIP_SGL_RUSER_32_63);\n\t}\n\n\t \n\tdcomp_bm = qm->cap_tables.dev_cap_table[ZIP_DECOMP_ENABLE_BITMAP_IDX].cap_val;\n\tcomp_bm = qm->cap_tables.dev_cap_table[ZIP_COMP_ENABLE_BITMAP_IDX].cap_val;\n\twritel(HZIP_DECOMP_CHECK_ENABLE | dcomp_bm | comp_bm, base + HZIP_CLOCK_GATE_CTRL);\n\n\t \n\twritel(SQC_CACHE_ENABLE | CQC_CACHE_ENABLE | SQC_CACHE_WB_ENABLE |\n\t       CQC_CACHE_WB_ENABLE | FIELD_PREP(SQC_CACHE_WB_THRD, 1) |\n\t       FIELD_PREP(CQC_CACHE_WB_THRD, 1), base + QM_CACHE_CTL);\n\n\thisi_zip_enable_clock_gate(qm);\n\n\treturn 0;\n}\n\nstatic void hisi_zip_master_ooo_ctrl(struct hisi_qm *qm, bool enable)\n{\n\tu32 val1, val2;\n\n\tval1 = readl(qm->io_base + HZIP_SOFT_CTRL_ZIP_CONTROL);\n\tif (enable) {\n\t\tval1 |= HZIP_AXI_SHUTDOWN_ENABLE;\n\t\tval2 = hisi_qm_get_hw_info(qm, zip_basic_cap_info,\n\t\t\t\tZIP_OOO_SHUTDOWN_MASK_CAP, qm->cap_ver);\n\t} else {\n\t\tval1 &= ~HZIP_AXI_SHUTDOWN_ENABLE;\n\t\tval2 = 0x0;\n\t}\n\n\tif (qm->ver > QM_HW_V2)\n\t\twritel(val2, qm->io_base + HZIP_OOO_SHUTDOWN_SEL);\n\n\twritel(val1, qm->io_base + HZIP_SOFT_CTRL_ZIP_CONTROL);\n}\n\nstatic void hisi_zip_hw_error_enable(struct hisi_qm *qm)\n{\n\tu32 nfe, ce;\n\n\tif (qm->ver == QM_HW_V1) {\n\t\twritel(HZIP_CORE_INT_MASK_ALL,\n\t\t       qm->io_base + HZIP_CORE_INT_MASK_REG);\n\t\tdev_info(&qm->pdev->dev, \"Does not support hw error handle\\n\");\n\t\treturn;\n\t}\n\n\tnfe = hisi_qm_get_hw_info(qm, zip_basic_cap_info, ZIP_NFE_MASK_CAP, qm->cap_ver);\n\tce = hisi_qm_get_hw_info(qm, zip_basic_cap_info, ZIP_CE_MASK_CAP, qm->cap_ver);\n\n\t \n\twritel(ce | nfe | HZIP_CORE_INT_RAS_FE_ENB_MASK, qm->io_base + HZIP_CORE_INT_SOURCE);\n\n\t \n\twritel(ce, qm->io_base + HZIP_CORE_INT_RAS_CE_ENB);\n\twritel(HZIP_CORE_INT_RAS_FE_ENB_MASK, qm->io_base + HZIP_CORE_INT_RAS_FE_ENB);\n\twritel(nfe, qm->io_base + HZIP_CORE_INT_RAS_NFE_ENB);\n\n\thisi_zip_master_ooo_ctrl(qm, true);\n\n\t \n\twritel(0, qm->io_base + HZIP_CORE_INT_MASK_REG);\n}\n\nstatic void hisi_zip_hw_error_disable(struct hisi_qm *qm)\n{\n\tu32 nfe, ce;\n\n\t \n\tnfe = hisi_qm_get_hw_info(qm, zip_basic_cap_info, ZIP_NFE_MASK_CAP, qm->cap_ver);\n\tce = hisi_qm_get_hw_info(qm, zip_basic_cap_info, ZIP_CE_MASK_CAP, qm->cap_ver);\n\twritel(ce | nfe | HZIP_CORE_INT_RAS_FE_ENB_MASK, qm->io_base + HZIP_CORE_INT_MASK_REG);\n\n\thisi_zip_master_ooo_ctrl(qm, false);\n}\n\nstatic inline struct hisi_qm *file_to_qm(struct ctrl_debug_file *file)\n{\n\tstruct hisi_zip *hisi_zip = file->ctrl->hisi_zip;\n\n\treturn &hisi_zip->qm;\n}\n\nstatic u32 clear_enable_read(struct hisi_qm *qm)\n{\n\treturn readl(qm->io_base + HZIP_SOFT_CTRL_CNT_CLR_CE) &\n\t\t     HZIP_SOFT_CTRL_CNT_CLR_CE_BIT;\n}\n\nstatic int clear_enable_write(struct hisi_qm *qm, u32 val)\n{\n\tu32 tmp;\n\n\tif (val != 1 && val != 0)\n\t\treturn -EINVAL;\n\n\ttmp = (readl(qm->io_base + HZIP_SOFT_CTRL_CNT_CLR_CE) &\n\t       ~HZIP_SOFT_CTRL_CNT_CLR_CE_BIT) | val;\n\twritel(tmp, qm->io_base + HZIP_SOFT_CTRL_CNT_CLR_CE);\n\n\treturn  0;\n}\n\nstatic ssize_t hisi_zip_ctrl_debug_read(struct file *filp, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *pos)\n{\n\tstruct ctrl_debug_file *file = filp->private_data;\n\tstruct hisi_qm *qm = file_to_qm(file);\n\tchar tbuf[HZIP_BUF_SIZE];\n\tu32 val;\n\tint ret;\n\n\tret = hisi_qm_get_dfx_access(qm);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irq(&file->lock);\n\tswitch (file->index) {\n\tcase HZIP_CLEAR_ENABLE:\n\t\tval = clear_enable_read(qm);\n\t\tbreak;\n\tdefault:\n\t\tgoto err_input;\n\t}\n\tspin_unlock_irq(&file->lock);\n\n\thisi_qm_put_dfx_access(qm);\n\tret = scnprintf(tbuf, sizeof(tbuf), \"%u\\n\", val);\n\treturn simple_read_from_buffer(buf, count, pos, tbuf, ret);\n\nerr_input:\n\tspin_unlock_irq(&file->lock);\n\thisi_qm_put_dfx_access(qm);\n\treturn -EINVAL;\n}\n\nstatic ssize_t hisi_zip_ctrl_debug_write(struct file *filp,\n\t\t\t\t\t const char __user *buf,\n\t\t\t\t\t size_t count, loff_t *pos)\n{\n\tstruct ctrl_debug_file *file = filp->private_data;\n\tstruct hisi_qm *qm = file_to_qm(file);\n\tchar tbuf[HZIP_BUF_SIZE];\n\tunsigned long val;\n\tint len, ret;\n\n\tif (*pos != 0)\n\t\treturn 0;\n\n\tif (count >= HZIP_BUF_SIZE)\n\t\treturn -ENOSPC;\n\n\tlen = simple_write_to_buffer(tbuf, HZIP_BUF_SIZE - 1, pos, buf, count);\n\tif (len < 0)\n\t\treturn len;\n\n\ttbuf[len] = '\\0';\n\tret = kstrtoul(tbuf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_qm_get_dfx_access(qm);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irq(&file->lock);\n\tswitch (file->index) {\n\tcase HZIP_CLEAR_ENABLE:\n\t\tret = clear_enable_write(qm, val);\n\t\tif (ret)\n\t\t\tgoto err_input;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_input;\n\t}\n\n\tret = count;\n\nerr_input:\n\tspin_unlock_irq(&file->lock);\n\thisi_qm_put_dfx_access(qm);\n\treturn ret;\n}\n\nstatic const struct file_operations ctrl_debug_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = hisi_zip_ctrl_debug_read,\n\t.write = hisi_zip_ctrl_debug_write,\n};\n\nstatic int zip_debugfs_atomic64_set(void *data, u64 val)\n{\n\tif (val)\n\t\treturn -EINVAL;\n\n\tatomic64_set((atomic64_t *)data, 0);\n\n\treturn 0;\n}\n\nstatic int zip_debugfs_atomic64_get(void *data, u64 *val)\n{\n\t*val = atomic64_read((atomic64_t *)data);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(zip_atomic64_ops, zip_debugfs_atomic64_get,\n\t\t\t zip_debugfs_atomic64_set, \"%llu\\n\");\n\nstatic int hisi_zip_regs_show(struct seq_file *s, void *unused)\n{\n\thisi_qm_regs_dump(s, s->private);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(hisi_zip_regs);\n\nstatic int hisi_zip_core_debug_init(struct hisi_qm *qm)\n{\n\tu32 zip_core_num, zip_comp_core_num;\n\tstruct device *dev = &qm->pdev->dev;\n\tstruct debugfs_regset32 *regset;\n\tstruct dentry *tmp_d;\n\tchar buf[HZIP_BUF_SIZE];\n\tint i;\n\n\tzip_core_num = qm->cap_tables.dev_cap_table[ZIP_CORE_NUM_CAP_IDX].cap_val;\n\tzip_comp_core_num = qm->cap_tables.dev_cap_table[ZIP_CLUSTER_COMP_NUM_CAP_IDX].cap_val;\n\n\tfor (i = 0; i < zip_core_num; i++) {\n\t\tif (i < zip_comp_core_num)\n\t\t\tscnprintf(buf, sizeof(buf), \"comp_core%d\", i);\n\t\telse\n\t\t\tscnprintf(buf, sizeof(buf), \"decomp_core%d\",\n\t\t\t\t  i - zip_comp_core_num);\n\n\t\tregset = devm_kzalloc(dev, sizeof(*regset), GFP_KERNEL);\n\t\tif (!regset)\n\t\t\treturn -ENOENT;\n\n\t\tregset->regs = hzip_dfx_regs;\n\t\tregset->nregs = ARRAY_SIZE(hzip_dfx_regs);\n\t\tregset->base = qm->io_base + core_offsets[i];\n\t\tregset->dev = dev;\n\n\t\ttmp_d = debugfs_create_dir(buf, qm->debug.debug_root);\n\t\tdebugfs_create_file(\"regs\", 0444, tmp_d, regset,\n\t\t\t\t    &hisi_zip_regs_fops);\n\t}\n\n\treturn 0;\n}\n\nstatic void hisi_zip_dfx_debug_init(struct hisi_qm *qm)\n{\n\tstruct dfx_diff_registers *hzip_regs = qm->debug.acc_diff_regs;\n\tstruct hisi_zip *zip = container_of(qm, struct hisi_zip, qm);\n\tstruct hisi_zip_dfx *dfx = &zip->dfx;\n\tstruct dentry *tmp_dir;\n\tvoid *data;\n\tint i;\n\n\ttmp_dir = debugfs_create_dir(\"zip_dfx\", qm->debug.debug_root);\n\tfor (i = 0; i < ARRAY_SIZE(zip_dfx_files); i++) {\n\t\tdata = (atomic64_t *)((uintptr_t)dfx + zip_dfx_files[i].offset);\n\t\tdebugfs_create_file(zip_dfx_files[i].name,\n\t\t\t\t    0644, tmp_dir, data,\n\t\t\t\t    &zip_atomic64_ops);\n\t}\n\n\tif (qm->fun_type == QM_HW_PF && hzip_regs)\n\t\tdebugfs_create_file(\"diff_regs\", 0444, tmp_dir,\n\t\t\t\t      qm, &hzip_diff_regs_fops);\n}\n\nstatic int hisi_zip_ctrl_debug_init(struct hisi_qm *qm)\n{\n\tstruct hisi_zip *zip = container_of(qm, struct hisi_zip, qm);\n\tint i;\n\n\tfor (i = HZIP_CLEAR_ENABLE; i < HZIP_DEBUG_FILE_NUM; i++) {\n\t\tspin_lock_init(&zip->ctrl->files[i].lock);\n\t\tzip->ctrl->files[i].ctrl = zip->ctrl;\n\t\tzip->ctrl->files[i].index = i;\n\n\t\tdebugfs_create_file(ctrl_debug_file_name[i], 0600,\n\t\t\t\t    qm->debug.debug_root,\n\t\t\t\t    zip->ctrl->files + i,\n\t\t\t\t    &ctrl_debug_fops);\n\t}\n\n\treturn hisi_zip_core_debug_init(qm);\n}\n\nstatic int hisi_zip_debugfs_init(struct hisi_qm *qm)\n{\n\tstruct device *dev = &qm->pdev->dev;\n\tstruct dentry *dev_d;\n\tint ret;\n\n\tdev_d = debugfs_create_dir(dev_name(dev), hzip_debugfs_root);\n\n\tqm->debug.sqe_mask_offset = HZIP_SQE_MASK_OFFSET;\n\tqm->debug.sqe_mask_len = HZIP_SQE_MASK_LEN;\n\tqm->debug.debug_root = dev_d;\n\tret = hisi_qm_regs_debugfs_init(qm, hzip_diff_regs, ARRAY_SIZE(hzip_diff_regs));\n\tif (ret) {\n\t\tdev_warn(dev, \"Failed to init ZIP diff regs!\\n\");\n\t\tgoto debugfs_remove;\n\t}\n\n\thisi_qm_debug_init(qm);\n\n\tif (qm->fun_type == QM_HW_PF) {\n\t\tret = hisi_zip_ctrl_debug_init(qm);\n\t\tif (ret)\n\t\t\tgoto failed_to_create;\n\t}\n\n\thisi_zip_dfx_debug_init(qm);\n\n\treturn 0;\n\nfailed_to_create:\n\thisi_qm_regs_debugfs_uninit(qm, ARRAY_SIZE(hzip_diff_regs));\ndebugfs_remove:\n\tdebugfs_remove_recursive(hzip_debugfs_root);\n\treturn ret;\n}\n\n \nstatic void hisi_zip_debug_regs_clear(struct hisi_qm *qm)\n{\n\tint i, j;\n\n\t \n\twritel(HZIP_RD_CNT_CLR_CE_EN, qm->io_base + HZIP_SOFT_CTRL_CNT_CLR_CE);\n\tfor (i = 0; i < ARRAY_SIZE(core_offsets); i++)\n\t\tfor (j = 0; j < ARRAY_SIZE(hzip_dfx_regs); j++)\n\t\t\treadl(qm->io_base + core_offsets[i] +\n\t\t\t      hzip_dfx_regs[j].offset);\n\n\t \n\twritel(0x0, qm->io_base + HZIP_SOFT_CTRL_CNT_CLR_CE);\n\n\thisi_qm_debug_regs_clear(qm);\n}\n\nstatic void hisi_zip_debugfs_exit(struct hisi_qm *qm)\n{\n\thisi_qm_regs_debugfs_uninit(qm, ARRAY_SIZE(hzip_diff_regs));\n\n\tdebugfs_remove_recursive(qm->debug.debug_root);\n\n\tif (qm->fun_type == QM_HW_PF) {\n\t\thisi_zip_debug_regs_clear(qm);\n\t\tqm->debug.curr_qm_qp_num = 0;\n\t}\n}\n\nstatic int hisi_zip_show_last_regs_init(struct hisi_qm *qm)\n{\n\tint core_dfx_regs_num =  ARRAY_SIZE(hzip_dump_dfx_regs);\n\tint com_dfx_regs_num = ARRAY_SIZE(hzip_com_dfx_regs);\n\tstruct qm_debug *debug = &qm->debug;\n\tvoid __iomem *io_base;\n\tu32 zip_core_num;\n\tint i, j, idx;\n\n\tzip_core_num = qm->cap_tables.dev_cap_table[ZIP_CORE_NUM_CAP_IDX].cap_val;\n\n\tdebug->last_words = kcalloc(core_dfx_regs_num * zip_core_num + com_dfx_regs_num,\n\t\t\t\t    sizeof(unsigned int), GFP_KERNEL);\n\tif (!debug->last_words)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < com_dfx_regs_num; i++) {\n\t\tio_base = qm->io_base + hzip_com_dfx_regs[i].offset;\n\t\tdebug->last_words[i] = readl_relaxed(io_base);\n\t}\n\n\tfor (i = 0; i < zip_core_num; i++) {\n\t\tio_base = qm->io_base + core_offsets[i];\n\t\tfor (j = 0; j < core_dfx_regs_num; j++) {\n\t\t\tidx = com_dfx_regs_num + i * core_dfx_regs_num + j;\n\t\t\tdebug->last_words[idx] = readl_relaxed(\n\t\t\t\tio_base + hzip_dump_dfx_regs[j].offset);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void hisi_zip_show_last_regs_uninit(struct hisi_qm *qm)\n{\n\tstruct qm_debug *debug = &qm->debug;\n\n\tif (qm->fun_type == QM_HW_VF || !debug->last_words)\n\t\treturn;\n\n\tkfree(debug->last_words);\n\tdebug->last_words = NULL;\n}\n\nstatic void hisi_zip_show_last_dfx_regs(struct hisi_qm *qm)\n{\n\tint core_dfx_regs_num =  ARRAY_SIZE(hzip_dump_dfx_regs);\n\tint com_dfx_regs_num = ARRAY_SIZE(hzip_com_dfx_regs);\n\tu32 zip_core_num, zip_comp_core_num;\n\tstruct qm_debug *debug = &qm->debug;\n\tchar buf[HZIP_BUF_SIZE];\n\tvoid __iomem *base;\n\tint i, j, idx;\n\tu32 val;\n\n\tif (qm->fun_type == QM_HW_VF || !debug->last_words)\n\t\treturn;\n\n\tfor (i = 0; i < com_dfx_regs_num; i++) {\n\t\tval = readl_relaxed(qm->io_base + hzip_com_dfx_regs[i].offset);\n\t\tif (debug->last_words[i] != val)\n\t\t\tpci_info(qm->pdev, \"com_dfx: %s \\t= 0x%08x => 0x%08x\\n\",\n\t\t\t\t hzip_com_dfx_regs[i].name, debug->last_words[i], val);\n\t}\n\n\tzip_core_num = qm->cap_tables.dev_cap_table[ZIP_CORE_NUM_CAP_IDX].cap_val;\n\tzip_comp_core_num = qm->cap_tables.dev_cap_table[ZIP_CLUSTER_COMP_NUM_CAP_IDX].cap_val;\n\n\tfor (i = 0; i < zip_core_num; i++) {\n\t\tif (i < zip_comp_core_num)\n\t\t\tscnprintf(buf, sizeof(buf), \"Comp_core-%d\", i);\n\t\telse\n\t\t\tscnprintf(buf, sizeof(buf), \"Decomp_core-%d\",\n\t\t\t\t  i - zip_comp_core_num);\n\t\tbase = qm->io_base + core_offsets[i];\n\n\t\tpci_info(qm->pdev, \"==>%s:\\n\", buf);\n\t\t \n\t\tfor (j = 0; j < core_dfx_regs_num; j++) {\n\t\t\tidx = com_dfx_regs_num + i * core_dfx_regs_num + j;\n\t\t\tval = readl_relaxed(base + hzip_dump_dfx_regs[j].offset);\n\t\t\tif (debug->last_words[idx] != val)\n\t\t\t\tpci_info(qm->pdev, \"%s \\t= 0x%08x => 0x%08x\\n\",\n\t\t\t\t\t hzip_dump_dfx_regs[j].name,\n\t\t\t\t\t debug->last_words[idx], val);\n\t\t}\n\t}\n}\n\nstatic void hisi_zip_log_hw_error(struct hisi_qm *qm, u32 err_sts)\n{\n\tconst struct hisi_zip_hw_error *err = zip_hw_error;\n\tstruct device *dev = &qm->pdev->dev;\n\tu32 err_val;\n\n\twhile (err->msg) {\n\t\tif (err->int_msk & err_sts) {\n\t\t\tdev_err(dev, \"%s [error status=0x%x] found\\n\",\n\t\t\t\terr->msg, err->int_msk);\n\n\t\t\tif (err->int_msk & HZIP_CORE_INT_STATUS_M_ECC) {\n\t\t\t\terr_val = readl(qm->io_base +\n\t\t\t\t\t\tHZIP_CORE_SRAM_ECC_ERR_INFO);\n\t\t\t\tdev_err(dev, \"hisi-zip multi ecc sram num=0x%x\\n\",\n\t\t\t\t\t((err_val >>\n\t\t\t\t\tHZIP_SRAM_ECC_ERR_NUM_SHIFT) & 0xFF));\n\t\t\t}\n\t\t}\n\t\terr++;\n\t}\n}\n\nstatic u32 hisi_zip_get_hw_err_status(struct hisi_qm *qm)\n{\n\treturn readl(qm->io_base + HZIP_CORE_INT_STATUS);\n}\n\nstatic void hisi_zip_clear_hw_err_status(struct hisi_qm *qm, u32 err_sts)\n{\n\tu32 nfe;\n\n\twritel(err_sts, qm->io_base + HZIP_CORE_INT_SOURCE);\n\tnfe = hisi_qm_get_hw_info(qm, zip_basic_cap_info, ZIP_NFE_MASK_CAP, qm->cap_ver);\n\twritel(nfe, qm->io_base + HZIP_CORE_INT_RAS_NFE_ENB);\n}\n\nstatic void hisi_zip_open_axi_master_ooo(struct hisi_qm *qm)\n{\n\tu32 val;\n\n\tval = readl(qm->io_base + HZIP_SOFT_CTRL_ZIP_CONTROL);\n\n\twritel(val & ~HZIP_AXI_SHUTDOWN_ENABLE,\n\t       qm->io_base + HZIP_SOFT_CTRL_ZIP_CONTROL);\n\n\twritel(val | HZIP_AXI_SHUTDOWN_ENABLE,\n\t       qm->io_base + HZIP_SOFT_CTRL_ZIP_CONTROL);\n}\n\nstatic void hisi_zip_close_axi_master_ooo(struct hisi_qm *qm)\n{\n\tu32 nfe_enb;\n\n\t \n\tnfe_enb = readl(qm->io_base + HZIP_CORE_INT_RAS_NFE_ENB);\n\twritel(nfe_enb & ~HZIP_CORE_INT_STATUS_M_ECC,\n\t       qm->io_base + HZIP_CORE_INT_RAS_NFE_ENB);\n\n\t \n\twritel(HZIP_CORE_INT_STATUS_M_ECC,\n\t       qm->io_base + HZIP_CORE_INT_SET);\n}\n\nstatic void hisi_zip_err_info_init(struct hisi_qm *qm)\n{\n\tstruct hisi_qm_err_info *err_info = &qm->err_info;\n\n\terr_info->fe = HZIP_CORE_INT_RAS_FE_ENB_MASK;\n\terr_info->ce = hisi_qm_get_hw_info(qm, zip_basic_cap_info, ZIP_QM_CE_MASK_CAP, qm->cap_ver);\n\terr_info->nfe = hisi_qm_get_hw_info(qm, zip_basic_cap_info,\n\t\t\t\t\t    ZIP_QM_NFE_MASK_CAP, qm->cap_ver);\n\terr_info->ecc_2bits_mask = HZIP_CORE_INT_STATUS_M_ECC;\n\terr_info->qm_shutdown_mask = hisi_qm_get_hw_info(qm, zip_basic_cap_info,\n\t\t\t\t\t\t\t ZIP_QM_OOO_SHUTDOWN_MASK_CAP, qm->cap_ver);\n\terr_info->dev_shutdown_mask = hisi_qm_get_hw_info(qm, zip_basic_cap_info,\n\t\t\t\t\t\t\t  ZIP_OOO_SHUTDOWN_MASK_CAP, qm->cap_ver);\n\terr_info->qm_reset_mask = hisi_qm_get_hw_info(qm, zip_basic_cap_info,\n\t\t\t\t\t\t      ZIP_QM_RESET_MASK_CAP, qm->cap_ver);\n\terr_info->dev_reset_mask = hisi_qm_get_hw_info(qm, zip_basic_cap_info,\n\t\t\t\t\t\t       ZIP_RESET_MASK_CAP, qm->cap_ver);\n\terr_info->msi_wr_port = HZIP_WR_PORT;\n\terr_info->acpi_rst = \"ZRST\";\n}\n\nstatic const struct hisi_qm_err_ini hisi_zip_err_ini = {\n\t.hw_init\t\t= hisi_zip_set_user_domain_and_cache,\n\t.hw_err_enable\t\t= hisi_zip_hw_error_enable,\n\t.hw_err_disable\t\t= hisi_zip_hw_error_disable,\n\t.get_dev_hw_err_status\t= hisi_zip_get_hw_err_status,\n\t.clear_dev_hw_err_status = hisi_zip_clear_hw_err_status,\n\t.log_dev_hw_err\t\t= hisi_zip_log_hw_error,\n\t.open_axi_master_ooo\t= hisi_zip_open_axi_master_ooo,\n\t.close_axi_master_ooo\t= hisi_zip_close_axi_master_ooo,\n\t.open_sva_prefetch\t= hisi_zip_open_sva_prefetch,\n\t.close_sva_prefetch\t= hisi_zip_close_sva_prefetch,\n\t.show_last_dfx_regs\t= hisi_zip_show_last_dfx_regs,\n\t.err_info_init\t\t= hisi_zip_err_info_init,\n};\n\nstatic int hisi_zip_pf_probe_init(struct hisi_zip *hisi_zip)\n{\n\tstruct hisi_qm *qm = &hisi_zip->qm;\n\tstruct hisi_zip_ctrl *ctrl;\n\tint ret;\n\n\tctrl = devm_kzalloc(&qm->pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\thisi_zip->ctrl = ctrl;\n\tctrl->hisi_zip = hisi_zip;\n\tqm->err_ini = &hisi_zip_err_ini;\n\tqm->err_ini->err_info_init(qm);\n\n\tret = hisi_zip_set_user_domain_and_cache(qm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_zip_set_high_perf(qm);\n\tif (ret)\n\t\treturn ret;\n\n\thisi_zip_open_sva_prefetch(qm);\n\thisi_qm_dev_err_init(qm);\n\thisi_zip_debug_regs_clear(qm);\n\n\tret = hisi_zip_show_last_regs_init(qm);\n\tif (ret)\n\t\tpci_err(qm->pdev, \"Failed to init last word regs!\\n\");\n\n\treturn ret;\n}\n\nstatic int zip_pre_store_cap_reg(struct hisi_qm *qm)\n{\n\tstruct hisi_qm_cap_record *zip_cap;\n\tstruct pci_dev *pdev = qm->pdev;\n\tsize_t i, size;\n\n\tsize = ARRAY_SIZE(zip_pre_store_caps);\n\tzip_cap = devm_kzalloc(&pdev->dev, sizeof(*zip_cap) * size, GFP_KERNEL);\n\tif (!zip_cap)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < size; i++) {\n\t\tzip_cap[i].type = zip_pre_store_caps[i];\n\t\tzip_cap[i].cap_val = hisi_qm_get_hw_info(qm, zip_basic_cap_info,\n\t\t\t\t     zip_pre_store_caps[i], qm->cap_ver);\n\t}\n\n\tqm->cap_tables.dev_cap_table = zip_cap;\n\n\treturn 0;\n}\n\nstatic int hisi_zip_qm_init(struct hisi_qm *qm, struct pci_dev *pdev)\n{\n\tu64 alg_msk;\n\tint ret;\n\n\tqm->pdev = pdev;\n\tqm->ver = pdev->revision;\n\tqm->mode = uacce_mode;\n\tqm->sqe_size = HZIP_SQE_SIZE;\n\tqm->dev_name = hisi_zip_name;\n\n\tqm->fun_type = (pdev->device == PCI_DEVICE_ID_HUAWEI_ZIP_PF) ?\n\t\t\tQM_HW_PF : QM_HW_VF;\n\tif (qm->fun_type == QM_HW_PF) {\n\t\tqm->qp_base = HZIP_PF_DEF_Q_BASE;\n\t\tqm->qp_num = pf_q_num;\n\t\tqm->debug.curr_qm_qp_num = pf_q_num;\n\t\tqm->qm_list = &zip_devices;\n\t\tif (pf_q_num_flag)\n\t\t\tset_bit(QM_MODULE_PARAM, &qm->misc_ctl);\n\t} else if (qm->fun_type == QM_HW_VF && qm->ver == QM_HW_V1) {\n\t\t \n\t\tqm->qp_base = HZIP_PF_DEF_Q_NUM;\n\t\tqm->qp_num = HZIP_QUEUE_NUM_V1 - HZIP_PF_DEF_Q_NUM;\n\t}\n\n\tret = hisi_qm_init(qm);\n\tif (ret) {\n\t\tpci_err(qm->pdev, \"Failed to init zip qm configures!\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = zip_pre_store_cap_reg(qm);\n\tif (ret) {\n\t\tpci_err(qm->pdev, \"Failed to pre-store capability registers!\\n\");\n\t\thisi_qm_uninit(qm);\n\t\treturn ret;\n\t}\n\n\talg_msk = qm->cap_tables.dev_cap_table[ZIP_DEV_ALG_BITMAP_IDX].cap_val;\n\tret = hisi_qm_set_algs(qm, alg_msk, zip_dev_algs, ARRAY_SIZE(zip_dev_algs));\n\tif (ret) {\n\t\tpci_err(qm->pdev, \"Failed to set zip algs!\\n\");\n\t\thisi_qm_uninit(qm);\n\t}\n\n\treturn ret;\n}\n\nstatic void hisi_zip_qm_uninit(struct hisi_qm *qm)\n{\n\thisi_qm_uninit(qm);\n}\n\nstatic int hisi_zip_probe_init(struct hisi_zip *hisi_zip)\n{\n\tu32 type_rate = HZIP_SHAPER_RATE_COMPRESS;\n\tstruct hisi_qm *qm = &hisi_zip->qm;\n\tint ret;\n\n\tif (qm->fun_type == QM_HW_PF) {\n\t\tret = hisi_zip_pf_probe_init(hisi_zip);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tif (qm->ver >= QM_HW_V3) {\n\t\t\ttype_rate |= QM_SHAPER_ENABLE;\n\n\t\t\t \n\t\t\ttype_rate |= HZIP_SHAPER_RATE_DECOMPRESS << QM_SHAPER_TYPE1_OFFSET;\n\t\t\tqm->type_rate = type_rate;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hisi_zip_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct hisi_zip *hisi_zip;\n\tstruct hisi_qm *qm;\n\tint ret;\n\n\thisi_zip = devm_kzalloc(&pdev->dev, sizeof(*hisi_zip), GFP_KERNEL);\n\tif (!hisi_zip)\n\t\treturn -ENOMEM;\n\n\tqm = &hisi_zip->qm;\n\n\tret = hisi_zip_qm_init(qm, pdev);\n\tif (ret) {\n\t\tpci_err(pdev, \"Failed to init ZIP QM (%d)!\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hisi_zip_probe_init(hisi_zip);\n\tif (ret) {\n\t\tpci_err(pdev, \"Failed to probe (%d)!\\n\", ret);\n\t\tgoto err_qm_uninit;\n\t}\n\n\tret = hisi_qm_start(qm);\n\tif (ret)\n\t\tgoto err_dev_err_uninit;\n\n\tret = hisi_zip_debugfs_init(qm);\n\tif (ret)\n\t\tpci_err(pdev, \"failed to init debugfs (%d)!\\n\", ret);\n\n\tret = hisi_qm_alg_register(qm, &zip_devices);\n\tif (ret < 0) {\n\t\tpci_err(pdev, \"failed to register driver to crypto!\\n\");\n\t\tgoto err_qm_stop;\n\t}\n\n\tif (qm->uacce) {\n\t\tret = uacce_register(qm->uacce);\n\t\tif (ret) {\n\t\t\tpci_err(pdev, \"failed to register uacce (%d)!\\n\", ret);\n\t\t\tgoto err_qm_alg_unregister;\n\t\t}\n\t}\n\n\tif (qm->fun_type == QM_HW_PF && vfs_num > 0) {\n\t\tret = hisi_qm_sriov_enable(pdev, vfs_num);\n\t\tif (ret < 0)\n\t\t\tgoto err_qm_alg_unregister;\n\t}\n\n\thisi_qm_pm_init(qm);\n\n\treturn 0;\n\nerr_qm_alg_unregister:\n\thisi_qm_alg_unregister(qm, &zip_devices);\n\nerr_qm_stop:\n\thisi_zip_debugfs_exit(qm);\n\thisi_qm_stop(qm, QM_NORMAL);\n\nerr_dev_err_uninit:\n\thisi_zip_show_last_regs_uninit(qm);\n\thisi_qm_dev_err_uninit(qm);\n\nerr_qm_uninit:\n\thisi_zip_qm_uninit(qm);\n\n\treturn ret;\n}\n\nstatic void hisi_zip_remove(struct pci_dev *pdev)\n{\n\tstruct hisi_qm *qm = pci_get_drvdata(pdev);\n\n\thisi_qm_pm_uninit(qm);\n\thisi_qm_wait_task_finish(qm, &zip_devices);\n\thisi_qm_alg_unregister(qm, &zip_devices);\n\n\tif (qm->fun_type == QM_HW_PF && qm->vfs_num)\n\t\thisi_qm_sriov_disable(pdev, true);\n\n\thisi_zip_debugfs_exit(qm);\n\thisi_qm_stop(qm, QM_NORMAL);\n\thisi_zip_show_last_regs_uninit(qm);\n\thisi_qm_dev_err_uninit(qm);\n\thisi_zip_qm_uninit(qm);\n}\n\nstatic const struct dev_pm_ops hisi_zip_pm_ops = {\n\tSET_RUNTIME_PM_OPS(hisi_qm_suspend, hisi_qm_resume, NULL)\n};\n\nstatic const struct pci_error_handlers hisi_zip_err_handler = {\n\t.error_detected\t= hisi_qm_dev_err_detected,\n\t.slot_reset\t= hisi_qm_dev_slot_reset,\n\t.reset_prepare\t= hisi_qm_reset_prepare,\n\t.reset_done\t= hisi_qm_reset_done,\n};\n\nstatic struct pci_driver hisi_zip_pci_driver = {\n\t.name\t\t\t= \"hisi_zip\",\n\t.id_table\t\t= hisi_zip_dev_ids,\n\t.probe\t\t\t= hisi_zip_probe,\n\t.remove\t\t\t= hisi_zip_remove,\n\t.sriov_configure\t= IS_ENABLED(CONFIG_PCI_IOV) ?\n\t\t\t\t\thisi_qm_sriov_configure : NULL,\n\t.err_handler\t\t= &hisi_zip_err_handler,\n\t.shutdown\t\t= hisi_qm_dev_shutdown,\n\t.driver.pm\t\t= &hisi_zip_pm_ops,\n};\n\nstruct pci_driver *hisi_zip_get_pf_driver(void)\n{\n\treturn &hisi_zip_pci_driver;\n}\nEXPORT_SYMBOL_GPL(hisi_zip_get_pf_driver);\n\nstatic void hisi_zip_register_debugfs(void)\n{\n\tif (!debugfs_initialized())\n\t\treturn;\n\n\thzip_debugfs_root = debugfs_create_dir(\"hisi_zip\", NULL);\n}\n\nstatic void hisi_zip_unregister_debugfs(void)\n{\n\tdebugfs_remove_recursive(hzip_debugfs_root);\n}\n\nstatic int __init hisi_zip_init(void)\n{\n\tint ret;\n\n\thisi_qm_init_list(&zip_devices);\n\thisi_zip_register_debugfs();\n\n\tret = pci_register_driver(&hisi_zip_pci_driver);\n\tif (ret < 0) {\n\t\thisi_zip_unregister_debugfs();\n\t\tpr_err(\"Failed to register pci driver.\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit hisi_zip_exit(void)\n{\n\tpci_unregister_driver(&hisi_zip_pci_driver);\n\thisi_zip_unregister_debugfs();\n}\n\nmodule_init(hisi_zip_init);\nmodule_exit(hisi_zip_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Zhou Wang <wangzhou1@hisilicon.com>\");\nMODULE_DESCRIPTION(\"Driver for HiSilicon ZIP accelerator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}