{
  "module_name": "zip_crypto.c",
  "hash_id": "738f9843c21d1def443f3f448ae5d6ae1d79c9da2b7c19bec25dc1ba18215617",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/hisilicon/zip/zip_crypto.c",
  "human_readable_source": "\n \n#include <crypto/internal/acompress.h>\n#include <linux/bitfield.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include \"zip.h\"\n\n \n#define HZIP_BD_STATUS_M\t\t\tGENMASK(7, 0)\n \n#define HZIP_IN_SGE_DATA_OFFSET_M\t\tGENMASK(23, 0)\n#define HZIP_SQE_TYPE_M\t\t\t\tGENMASK(31, 28)\n \n#define HZIP_OUT_SGE_DATA_OFFSET_M\t\tGENMASK(23, 0)\n \n#define HZIP_REQ_TYPE_M\t\t\t\tGENMASK(7, 0)\n#define HZIP_ALG_TYPE_ZLIB\t\t\t0x02\n#define HZIP_ALG_TYPE_GZIP\t\t\t0x03\n#define HZIP_BUF_TYPE_M\t\t\t\tGENMASK(11, 8)\n#define HZIP_PBUFFER\t\t\t\t0x0\n#define HZIP_SGL\t\t\t\t0x1\n\n#define HZIP_ZLIB_HEAD_SIZE\t\t\t2\n#define HZIP_GZIP_HEAD_SIZE\t\t\t10\n\n#define GZIP_HEAD_FHCRC_BIT\t\t\tBIT(1)\n#define GZIP_HEAD_FEXTRA_BIT\t\t\tBIT(2)\n#define GZIP_HEAD_FNAME_BIT\t\t\tBIT(3)\n#define GZIP_HEAD_FCOMMENT_BIT\t\t\tBIT(4)\n\n#define GZIP_HEAD_FLG_SHIFT\t\t\t3\n#define GZIP_HEAD_FEXTRA_SHIFT\t\t\t10\n#define GZIP_HEAD_FEXTRA_XLEN\t\t\t2UL\n#define GZIP_HEAD_FHCRC_SIZE\t\t\t2\n\n#define HZIP_GZIP_HEAD_BUF\t\t\t256\n#define HZIP_ALG_PRIORITY\t\t\t300\n#define HZIP_SGL_SGE_NR\t\t\t\t10\n\n#define HZIP_ALG_ZLIB\t\t\t\tGENMASK(1, 0)\n#define HZIP_ALG_GZIP\t\t\t\tGENMASK(3, 2)\n\nstatic const u8 zlib_head[HZIP_ZLIB_HEAD_SIZE] = {0x78, 0x9c};\nstatic const u8 gzip_head[HZIP_GZIP_HEAD_SIZE] = {\n\t0x1f, 0x8b, 0x08, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x03\n};\n\nenum hisi_zip_alg_type {\n\tHZIP_ALG_TYPE_COMP = 0,\n\tHZIP_ALG_TYPE_DECOMP = 1,\n};\n\nenum {\n\tHZIP_QPC_COMP,\n\tHZIP_QPC_DECOMP,\n\tHZIP_CTX_Q_NUM\n};\n\n#define COMP_NAME_TO_TYPE(alg_name)\t\t\t\t\t\\\n\t(!strcmp((alg_name), \"zlib-deflate\") ? HZIP_ALG_TYPE_ZLIB :\t\\\n\t !strcmp((alg_name), \"gzip\") ? HZIP_ALG_TYPE_GZIP : 0)\t\t\\\n\n#define TO_HEAD_SIZE(req_type)\t\t\t\t\t\t\\\n\t(((req_type) == HZIP_ALG_TYPE_ZLIB) ? sizeof(zlib_head) :\t\\\n\t ((req_type) == HZIP_ALG_TYPE_GZIP) ? sizeof(gzip_head) : 0)\t\\\n\n#define TO_HEAD(req_type)\t\t\t\t\t\t\\\n\t(((req_type) == HZIP_ALG_TYPE_ZLIB) ? zlib_head :\t\t\\\n\t ((req_type) == HZIP_ALG_TYPE_GZIP) ? gzip_head : NULL)\t\t\\\n\nstruct hisi_zip_req {\n\tstruct acomp_req *req;\n\tu32 sskip;\n\tu32 dskip;\n\tstruct hisi_acc_hw_sgl *hw_src;\n\tstruct hisi_acc_hw_sgl *hw_dst;\n\tdma_addr_t dma_src;\n\tdma_addr_t dma_dst;\n\tu16 req_id;\n};\n\nstruct hisi_zip_req_q {\n\tstruct hisi_zip_req *q;\n\tunsigned long *req_bitmap;\n\trwlock_t req_lock;\n\tu16 size;\n};\n\nstruct hisi_zip_qp_ctx {\n\tstruct hisi_qp *qp;\n\tstruct hisi_zip_req_q req_q;\n\tstruct hisi_acc_sgl_pool *sgl_pool;\n\tstruct hisi_zip *zip_dev;\n\tstruct hisi_zip_ctx *ctx;\n};\n\nstruct hisi_zip_sqe_ops {\n\tu8 sqe_type;\n\tvoid (*fill_addr)(struct hisi_zip_sqe *sqe, struct hisi_zip_req *req);\n\tvoid (*fill_buf_size)(struct hisi_zip_sqe *sqe, struct hisi_zip_req *req);\n\tvoid (*fill_buf_type)(struct hisi_zip_sqe *sqe, u8 buf_type);\n\tvoid (*fill_req_type)(struct hisi_zip_sqe *sqe, u8 req_type);\n\tvoid (*fill_tag)(struct hisi_zip_sqe *sqe, struct hisi_zip_req *req);\n\tvoid (*fill_sqe_type)(struct hisi_zip_sqe *sqe, u8 sqe_type);\n\tu32 (*get_tag)(struct hisi_zip_sqe *sqe);\n\tu32 (*get_status)(struct hisi_zip_sqe *sqe);\n\tu32 (*get_dstlen)(struct hisi_zip_sqe *sqe);\n};\n\nstruct hisi_zip_ctx {\n\tstruct hisi_zip_qp_ctx qp_ctx[HZIP_CTX_Q_NUM];\n\tconst struct hisi_zip_sqe_ops *ops;\n};\n\nstatic int sgl_sge_nr_set(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tu16 n;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tret = kstrtou16(val, 10, &n);\n\tif (ret || n == 0 || n > HISI_ACC_SGL_SGE_NR_MAX)\n\t\treturn -EINVAL;\n\n\treturn param_set_ushort(val, kp);\n}\n\nstatic const struct kernel_param_ops sgl_sge_nr_ops = {\n\t.set = sgl_sge_nr_set,\n\t.get = param_get_ushort,\n};\n\nstatic u16 sgl_sge_nr = HZIP_SGL_SGE_NR;\nmodule_param_cb(sgl_sge_nr, &sgl_sge_nr_ops, &sgl_sge_nr, 0444);\nMODULE_PARM_DESC(sgl_sge_nr, \"Number of sge in sgl(1-255)\");\n\nstatic u32 get_extra_field_size(const u8 *start)\n{\n\treturn *((u16 *)start) + GZIP_HEAD_FEXTRA_XLEN;\n}\n\nstatic u32 get_name_field_size(const u8 *start)\n{\n\treturn strlen(start) + 1;\n}\n\nstatic u32 get_comment_field_size(const u8 *start)\n{\n\treturn strlen(start) + 1;\n}\n\nstatic u32 __get_gzip_head_size(const u8 *src)\n{\n\tu8 head_flg = *(src + GZIP_HEAD_FLG_SHIFT);\n\tu32 size = GZIP_HEAD_FEXTRA_SHIFT;\n\n\tif (head_flg & GZIP_HEAD_FEXTRA_BIT)\n\t\tsize += get_extra_field_size(src + size);\n\tif (head_flg & GZIP_HEAD_FNAME_BIT)\n\t\tsize += get_name_field_size(src + size);\n\tif (head_flg & GZIP_HEAD_FCOMMENT_BIT)\n\t\tsize += get_comment_field_size(src + size);\n\tif (head_flg & GZIP_HEAD_FHCRC_BIT)\n\t\tsize += GZIP_HEAD_FHCRC_SIZE;\n\n\treturn size;\n}\n\nstatic u32 __maybe_unused get_gzip_head_size(struct scatterlist *sgl)\n{\n\tchar buf[HZIP_GZIP_HEAD_BUF];\n\n\tsg_copy_to_buffer(sgl, sg_nents(sgl), buf, sizeof(buf));\n\n\treturn __get_gzip_head_size(buf);\n}\n\nstatic int add_comp_head(struct scatterlist *dst, u8 req_type)\n{\n\tint head_size = TO_HEAD_SIZE(req_type);\n\tconst u8 *head = TO_HEAD(req_type);\n\tint ret;\n\n\tret = sg_copy_from_buffer(dst, sg_nents(dst), head, head_size);\n\tif (unlikely(ret != head_size)) {\n\t\tpr_err(\"the head size of buffer is wrong (%d)!\\n\", ret);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn head_size;\n}\n\nstatic int get_comp_head_size(struct acomp_req *acomp_req, u8 req_type)\n{\n\tif (unlikely(!acomp_req->src || !acomp_req->slen))\n\t\treturn -EINVAL;\n\n\tif (unlikely(req_type == HZIP_ALG_TYPE_GZIP &&\n\t\t     acomp_req->slen < GZIP_HEAD_FEXTRA_SHIFT))\n\t\treturn -EINVAL;\n\n\tswitch (req_type) {\n\tcase HZIP_ALG_TYPE_ZLIB:\n\t\treturn TO_HEAD_SIZE(HZIP_ALG_TYPE_ZLIB);\n\tcase HZIP_ALG_TYPE_GZIP:\n\t\treturn TO_HEAD_SIZE(HZIP_ALG_TYPE_GZIP);\n\tdefault:\n\t\tpr_err(\"request type does not support!\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic struct hisi_zip_req *hisi_zip_create_req(struct acomp_req *req,\n\t\t\t\t\t\tstruct hisi_zip_qp_ctx *qp_ctx,\n\t\t\t\t\t\tsize_t head_size, bool is_comp)\n{\n\tstruct hisi_zip_req_q *req_q = &qp_ctx->req_q;\n\tstruct hisi_zip_req *q = req_q->q;\n\tstruct hisi_zip_req *req_cache;\n\tint req_id;\n\n\twrite_lock(&req_q->req_lock);\n\n\treq_id = find_first_zero_bit(req_q->req_bitmap, req_q->size);\n\tif (req_id >= req_q->size) {\n\t\twrite_unlock(&req_q->req_lock);\n\t\tdev_dbg(&qp_ctx->qp->qm->pdev->dev, \"req cache is full!\\n\");\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tset_bit(req_id, req_q->req_bitmap);\n\n\twrite_unlock(&req_q->req_lock);\n\n\treq_cache = q + req_id;\n\treq_cache->req_id = req_id;\n\treq_cache->req = req;\n\n\tif (is_comp) {\n\t\treq_cache->sskip = 0;\n\t\treq_cache->dskip = head_size;\n\t} else {\n\t\treq_cache->sskip = head_size;\n\t\treq_cache->dskip = 0;\n\t}\n\n\treturn req_cache;\n}\n\nstatic void hisi_zip_remove_req(struct hisi_zip_qp_ctx *qp_ctx,\n\t\t\t\tstruct hisi_zip_req *req)\n{\n\tstruct hisi_zip_req_q *req_q = &qp_ctx->req_q;\n\n\twrite_lock(&req_q->req_lock);\n\tclear_bit(req->req_id, req_q->req_bitmap);\n\twrite_unlock(&req_q->req_lock);\n}\n\nstatic void hisi_zip_fill_addr(struct hisi_zip_sqe *sqe, struct hisi_zip_req *req)\n{\n\tsqe->source_addr_l = lower_32_bits(req->dma_src);\n\tsqe->source_addr_h = upper_32_bits(req->dma_src);\n\tsqe->dest_addr_l = lower_32_bits(req->dma_dst);\n\tsqe->dest_addr_h = upper_32_bits(req->dma_dst);\n}\n\nstatic void hisi_zip_fill_buf_size(struct hisi_zip_sqe *sqe, struct hisi_zip_req *req)\n{\n\tstruct acomp_req *a_req = req->req;\n\n\tsqe->input_data_length = a_req->slen - req->sskip;\n\tsqe->dest_avail_out = a_req->dlen - req->dskip;\n\tsqe->dw7 = FIELD_PREP(HZIP_IN_SGE_DATA_OFFSET_M, req->sskip);\n\tsqe->dw8 = FIELD_PREP(HZIP_OUT_SGE_DATA_OFFSET_M, req->dskip);\n}\n\nstatic void hisi_zip_fill_buf_type(struct hisi_zip_sqe *sqe, u8 buf_type)\n{\n\tu32 val;\n\n\tval = sqe->dw9 & ~HZIP_BUF_TYPE_M;\n\tval |= FIELD_PREP(HZIP_BUF_TYPE_M, buf_type);\n\tsqe->dw9 = val;\n}\n\nstatic void hisi_zip_fill_req_type(struct hisi_zip_sqe *sqe, u8 req_type)\n{\n\tu32 val;\n\n\tval = sqe->dw9 & ~HZIP_REQ_TYPE_M;\n\tval |= FIELD_PREP(HZIP_REQ_TYPE_M, req_type);\n\tsqe->dw9 = val;\n}\n\nstatic void hisi_zip_fill_tag_v1(struct hisi_zip_sqe *sqe, struct hisi_zip_req *req)\n{\n\tsqe->dw13 = req->req_id;\n}\n\nstatic void hisi_zip_fill_tag_v2(struct hisi_zip_sqe *sqe, struct hisi_zip_req *req)\n{\n\tsqe->dw26 = req->req_id;\n}\n\nstatic void hisi_zip_fill_sqe_type(struct hisi_zip_sqe *sqe, u8 sqe_type)\n{\n\tu32 val;\n\n\tval = sqe->dw7 & ~HZIP_SQE_TYPE_M;\n\tval |= FIELD_PREP(HZIP_SQE_TYPE_M, sqe_type);\n\tsqe->dw7 = val;\n}\n\nstatic void hisi_zip_fill_sqe(struct hisi_zip_ctx *ctx, struct hisi_zip_sqe *sqe,\n\t\t\t      u8 req_type, struct hisi_zip_req *req)\n{\n\tconst struct hisi_zip_sqe_ops *ops = ctx->ops;\n\n\tmemset(sqe, 0, sizeof(struct hisi_zip_sqe));\n\n\tops->fill_addr(sqe, req);\n\tops->fill_buf_size(sqe, req);\n\tops->fill_buf_type(sqe, HZIP_SGL);\n\tops->fill_req_type(sqe, req_type);\n\tops->fill_tag(sqe, req);\n\tops->fill_sqe_type(sqe, ops->sqe_type);\n}\n\nstatic int hisi_zip_do_work(struct hisi_zip_req *req,\n\t\t\t    struct hisi_zip_qp_ctx *qp_ctx)\n{\n\tstruct hisi_acc_sgl_pool *pool = qp_ctx->sgl_pool;\n\tstruct hisi_zip_dfx *dfx = &qp_ctx->zip_dev->dfx;\n\tstruct acomp_req *a_req = req->req;\n\tstruct hisi_qp *qp = qp_ctx->qp;\n\tstruct device *dev = &qp->qm->pdev->dev;\n\tstruct hisi_zip_sqe zip_sqe;\n\tint ret;\n\n\tif (unlikely(!a_req->src || !a_req->slen || !a_req->dst || !a_req->dlen))\n\t\treturn -EINVAL;\n\n\treq->hw_src = hisi_acc_sg_buf_map_to_hw_sgl(dev, a_req->src, pool,\n\t\t\t\t\t\t    req->req_id << 1, &req->dma_src);\n\tif (IS_ERR(req->hw_src)) {\n\t\tdev_err(dev, \"failed to map the src buffer to hw sgl (%ld)!\\n\",\n\t\t\tPTR_ERR(req->hw_src));\n\t\treturn PTR_ERR(req->hw_src);\n\t}\n\n\treq->hw_dst = hisi_acc_sg_buf_map_to_hw_sgl(dev, a_req->dst, pool,\n\t\t\t\t\t\t    (req->req_id << 1) + 1,\n\t\t\t\t\t\t    &req->dma_dst);\n\tif (IS_ERR(req->hw_dst)) {\n\t\tret = PTR_ERR(req->hw_dst);\n\t\tdev_err(dev, \"failed to map the dst buffer to hw slg (%d)!\\n\",\n\t\t\tret);\n\t\tgoto err_unmap_input;\n\t}\n\n\thisi_zip_fill_sqe(qp_ctx->ctx, &zip_sqe, qp->req_type, req);\n\n\t \n\tatomic64_inc(&dfx->send_cnt);\n\tret = hisi_qp_send(qp, &zip_sqe);\n\tif (unlikely(ret < 0)) {\n\t\tatomic64_inc(&dfx->send_busy_cnt);\n\t\tret = -EAGAIN;\n\t\tdev_dbg_ratelimited(dev, \"failed to send request!\\n\");\n\t\tgoto err_unmap_output;\n\t}\n\n\treturn -EINPROGRESS;\n\nerr_unmap_output:\n\thisi_acc_sg_buf_unmap(dev, a_req->dst, req->hw_dst);\nerr_unmap_input:\n\thisi_acc_sg_buf_unmap(dev, a_req->src, req->hw_src);\n\treturn ret;\n}\n\nstatic u32 hisi_zip_get_tag_v1(struct hisi_zip_sqe *sqe)\n{\n\treturn sqe->dw13;\n}\n\nstatic u32 hisi_zip_get_tag_v2(struct hisi_zip_sqe *sqe)\n{\n\treturn sqe->dw26;\n}\n\nstatic u32 hisi_zip_get_status(struct hisi_zip_sqe *sqe)\n{\n\treturn sqe->dw3 & HZIP_BD_STATUS_M;\n}\n\nstatic u32 hisi_zip_get_dstlen(struct hisi_zip_sqe *sqe)\n{\n\treturn sqe->produced;\n}\n\nstatic void hisi_zip_acomp_cb(struct hisi_qp *qp, void *data)\n{\n\tstruct hisi_zip_qp_ctx *qp_ctx = qp->qp_ctx;\n\tconst struct hisi_zip_sqe_ops *ops = qp_ctx->ctx->ops;\n\tstruct hisi_zip_dfx *dfx = &qp_ctx->zip_dev->dfx;\n\tstruct hisi_zip_req_q *req_q = &qp_ctx->req_q;\n\tstruct device *dev = &qp->qm->pdev->dev;\n\tstruct hisi_zip_sqe *sqe = data;\n\tu32 tag = ops->get_tag(sqe);\n\tstruct hisi_zip_req *req = req_q->q + tag;\n\tstruct acomp_req *acomp_req = req->req;\n\tu32 status, dlen, head_size;\n\tint err = 0;\n\n\tatomic64_inc(&dfx->recv_cnt);\n\tstatus = ops->get_status(sqe);\n\tif (unlikely(status != 0 && status != HZIP_NC_ERR)) {\n\t\tdev_err(dev, \"%scompress fail in qp%u: %u, output: %u\\n\",\n\t\t\t(qp->alg_type == 0) ? \"\" : \"de\", qp->qp_id, status,\n\t\t\tsqe->produced);\n\t\tatomic64_inc(&dfx->err_bd_cnt);\n\t\terr = -EIO;\n\t}\n\n\tdlen = ops->get_dstlen(sqe);\n\n\thisi_acc_sg_buf_unmap(dev, acomp_req->src, req->hw_src);\n\thisi_acc_sg_buf_unmap(dev, acomp_req->dst, req->hw_dst);\n\n\thead_size = (qp->alg_type == 0) ? TO_HEAD_SIZE(qp->req_type) : 0;\n\tacomp_req->dlen = dlen + head_size;\n\n\tif (acomp_req->base.complete)\n\t\tacomp_request_complete(acomp_req, err);\n\n\thisi_zip_remove_req(qp_ctx, req);\n}\n\nstatic int hisi_zip_acompress(struct acomp_req *acomp_req)\n{\n\tstruct hisi_zip_ctx *ctx = crypto_tfm_ctx(acomp_req->base.tfm);\n\tstruct hisi_zip_qp_ctx *qp_ctx = &ctx->qp_ctx[HZIP_QPC_COMP];\n\tstruct device *dev = &qp_ctx->qp->qm->pdev->dev;\n\tstruct hisi_zip_req *req;\n\tint head_size;\n\tint ret;\n\n\t \n\thead_size = add_comp_head(acomp_req->dst, qp_ctx->qp->req_type);\n\tif (unlikely(head_size < 0)) {\n\t\tdev_err_ratelimited(dev, \"failed to add comp head (%d)!\\n\",\n\t\t\t\t    head_size);\n\t\treturn head_size;\n\t}\n\n\treq = hisi_zip_create_req(acomp_req, qp_ctx, head_size, true);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tret = hisi_zip_do_work(req, qp_ctx);\n\tif (unlikely(ret != -EINPROGRESS)) {\n\t\tdev_info_ratelimited(dev, \"failed to do compress (%d)!\\n\", ret);\n\t\thisi_zip_remove_req(qp_ctx, req);\n\t}\n\n\treturn ret;\n}\n\nstatic int hisi_zip_adecompress(struct acomp_req *acomp_req)\n{\n\tstruct hisi_zip_ctx *ctx = crypto_tfm_ctx(acomp_req->base.tfm);\n\tstruct hisi_zip_qp_ctx *qp_ctx = &ctx->qp_ctx[HZIP_QPC_DECOMP];\n\tstruct device *dev = &qp_ctx->qp->qm->pdev->dev;\n\tstruct hisi_zip_req *req;\n\tint head_size, ret;\n\n\thead_size = get_comp_head_size(acomp_req, qp_ctx->qp->req_type);\n\tif (unlikely(head_size < 0)) {\n\t\tdev_err_ratelimited(dev, \"failed to get comp head size (%d)!\\n\",\n\t\t\t\t    head_size);\n\t\treturn head_size;\n\t}\n\n\treq = hisi_zip_create_req(acomp_req, qp_ctx, head_size, false);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tret = hisi_zip_do_work(req, qp_ctx);\n\tif (unlikely(ret != -EINPROGRESS)) {\n\t\tdev_info_ratelimited(dev, \"failed to do decompress (%d)!\\n\",\n\t\t\t\t     ret);\n\t\thisi_zip_remove_req(qp_ctx, req);\n\t}\n\n\treturn ret;\n}\n\nstatic int hisi_zip_start_qp(struct hisi_qp *qp, struct hisi_zip_qp_ctx *qp_ctx,\n\t\t\t     int alg_type, int req_type)\n{\n\tstruct device *dev = &qp->qm->pdev->dev;\n\tint ret;\n\n\tqp->req_type = req_type;\n\tqp->alg_type = alg_type;\n\tqp->qp_ctx = qp_ctx;\n\n\tret = hisi_qm_start_qp(qp, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to start qp (%d)!\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tqp_ctx->qp = qp;\n\n\treturn 0;\n}\n\nstatic void hisi_zip_release_qp(struct hisi_zip_qp_ctx *qp_ctx)\n{\n\thisi_qm_stop_qp(qp_ctx->qp);\n\thisi_qm_free_qps(&qp_ctx->qp, 1);\n}\n\nstatic const struct hisi_zip_sqe_ops hisi_zip_ops_v1 = {\n\t.sqe_type\t\t= 0,\n\t.fill_addr\t\t= hisi_zip_fill_addr,\n\t.fill_buf_size\t\t= hisi_zip_fill_buf_size,\n\t.fill_buf_type\t\t= hisi_zip_fill_buf_type,\n\t.fill_req_type\t\t= hisi_zip_fill_req_type,\n\t.fill_tag\t\t= hisi_zip_fill_tag_v1,\n\t.fill_sqe_type\t\t= hisi_zip_fill_sqe_type,\n\t.get_tag\t\t= hisi_zip_get_tag_v1,\n\t.get_status\t\t= hisi_zip_get_status,\n\t.get_dstlen\t\t= hisi_zip_get_dstlen,\n};\n\nstatic const struct hisi_zip_sqe_ops hisi_zip_ops_v2 = {\n\t.sqe_type\t\t= 0x3,\n\t.fill_addr\t\t= hisi_zip_fill_addr,\n\t.fill_buf_size\t\t= hisi_zip_fill_buf_size,\n\t.fill_buf_type\t\t= hisi_zip_fill_buf_type,\n\t.fill_req_type\t\t= hisi_zip_fill_req_type,\n\t.fill_tag\t\t= hisi_zip_fill_tag_v2,\n\t.fill_sqe_type\t\t= hisi_zip_fill_sqe_type,\n\t.get_tag\t\t= hisi_zip_get_tag_v2,\n\t.get_status\t\t= hisi_zip_get_status,\n\t.get_dstlen\t\t= hisi_zip_get_dstlen,\n};\n\nstatic int hisi_zip_ctx_init(struct hisi_zip_ctx *hisi_zip_ctx, u8 req_type, int node)\n{\n\tstruct hisi_qp *qps[HZIP_CTX_Q_NUM] = { NULL };\n\tstruct hisi_zip_qp_ctx *qp_ctx;\n\tstruct hisi_zip *hisi_zip;\n\tint ret, i, j;\n\n\tret = zip_create_qps(qps, HZIP_CTX_Q_NUM, node);\n\tif (ret) {\n\t\tpr_err(\"failed to create zip qps (%d)!\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\thisi_zip = container_of(qps[0]->qm, struct hisi_zip, qm);\n\n\tfor (i = 0; i < HZIP_CTX_Q_NUM; i++) {\n\t\t \n\t\tqp_ctx = &hisi_zip_ctx->qp_ctx[i];\n\t\tqp_ctx->ctx = hisi_zip_ctx;\n\t\tret = hisi_zip_start_qp(qps[i], qp_ctx, i, req_type);\n\t\tif (ret) {\n\t\t\tfor (j = i - 1; j >= 0; j--)\n\t\t\t\thisi_qm_stop_qp(hisi_zip_ctx->qp_ctx[j].qp);\n\n\t\t\thisi_qm_free_qps(qps, HZIP_CTX_Q_NUM);\n\t\t\treturn ret;\n\t\t}\n\n\t\tqp_ctx->zip_dev = hisi_zip;\n\t}\n\n\tif (hisi_zip->qm.ver < QM_HW_V3)\n\t\thisi_zip_ctx->ops = &hisi_zip_ops_v1;\n\telse\n\t\thisi_zip_ctx->ops = &hisi_zip_ops_v2;\n\n\treturn 0;\n}\n\nstatic void hisi_zip_ctx_exit(struct hisi_zip_ctx *hisi_zip_ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < HZIP_CTX_Q_NUM; i++)\n\t\thisi_zip_release_qp(&hisi_zip_ctx->qp_ctx[i]);\n}\n\nstatic int hisi_zip_create_req_q(struct hisi_zip_ctx *ctx)\n{\n\tu16 q_depth = ctx->qp_ctx[0].qp->sq_depth;\n\tstruct hisi_zip_req_q *req_q;\n\tint i, ret;\n\n\tfor (i = 0; i < HZIP_CTX_Q_NUM; i++) {\n\t\treq_q = &ctx->qp_ctx[i].req_q;\n\t\treq_q->size = q_depth;\n\n\t\treq_q->req_bitmap = bitmap_zalloc(req_q->size, GFP_KERNEL);\n\t\tif (!req_q->req_bitmap) {\n\t\t\tret = -ENOMEM;\n\t\t\tif (i == 0)\n\t\t\t\treturn ret;\n\n\t\t\tgoto err_free_comp_q;\n\t\t}\n\t\trwlock_init(&req_q->req_lock);\n\n\t\treq_q->q = kcalloc(req_q->size, sizeof(struct hisi_zip_req),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!req_q->q) {\n\t\t\tret = -ENOMEM;\n\t\t\tif (i == 0)\n\t\t\t\tgoto err_free_comp_bitmap;\n\t\t\telse\n\t\t\t\tgoto err_free_decomp_bitmap;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_free_decomp_bitmap:\n\tbitmap_free(ctx->qp_ctx[HZIP_QPC_DECOMP].req_q.req_bitmap);\nerr_free_comp_q:\n\tkfree(ctx->qp_ctx[HZIP_QPC_COMP].req_q.q);\nerr_free_comp_bitmap:\n\tbitmap_free(ctx->qp_ctx[HZIP_QPC_COMP].req_q.req_bitmap);\n\treturn ret;\n}\n\nstatic void hisi_zip_release_req_q(struct hisi_zip_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < HZIP_CTX_Q_NUM; i++) {\n\t\tkfree(ctx->qp_ctx[i].req_q.q);\n\t\tbitmap_free(ctx->qp_ctx[i].req_q.req_bitmap);\n\t}\n}\n\nstatic int hisi_zip_create_sgl_pool(struct hisi_zip_ctx *ctx)\n{\n\tu16 q_depth = ctx->qp_ctx[0].qp->sq_depth;\n\tstruct hisi_zip_qp_ctx *tmp;\n\tstruct device *dev;\n\tint i;\n\n\tfor (i = 0; i < HZIP_CTX_Q_NUM; i++) {\n\t\ttmp = &ctx->qp_ctx[i];\n\t\tdev = &tmp->qp->qm->pdev->dev;\n\t\ttmp->sgl_pool = hisi_acc_create_sgl_pool(dev, q_depth << 1,\n\t\t\t\t\t\t\t sgl_sge_nr);\n\t\tif (IS_ERR(tmp->sgl_pool)) {\n\t\t\tif (i == 1)\n\t\t\t\tgoto err_free_sgl_pool0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_free_sgl_pool0:\n\thisi_acc_free_sgl_pool(&ctx->qp_ctx[HZIP_QPC_COMP].qp->qm->pdev->dev,\n\t\t\t       ctx->qp_ctx[HZIP_QPC_COMP].sgl_pool);\n\treturn -ENOMEM;\n}\n\nstatic void hisi_zip_release_sgl_pool(struct hisi_zip_ctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < HZIP_CTX_Q_NUM; i++)\n\t\thisi_acc_free_sgl_pool(&ctx->qp_ctx[i].qp->qm->pdev->dev,\n\t\t\t\t       ctx->qp_ctx[i].sgl_pool);\n}\n\nstatic void hisi_zip_set_acomp_cb(struct hisi_zip_ctx *ctx,\n\t\t\t\t  void (*fn)(struct hisi_qp *, void *))\n{\n\tint i;\n\n\tfor (i = 0; i < HZIP_CTX_Q_NUM; i++)\n\t\tctx->qp_ctx[i].qp->req_cb = fn;\n}\n\nstatic int hisi_zip_acomp_init(struct crypto_acomp *tfm)\n{\n\tconst char *alg_name = crypto_tfm_alg_name(&tfm->base);\n\tstruct hisi_zip_ctx *ctx = crypto_tfm_ctx(&tfm->base);\n\tstruct device *dev;\n\tint ret;\n\n\tret = hisi_zip_ctx_init(ctx, COMP_NAME_TO_TYPE(alg_name), tfm->base.node);\n\tif (ret) {\n\t\tpr_err(\"failed to init ctx (%d)!\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev = &ctx->qp_ctx[0].qp->qm->pdev->dev;\n\n\tret = hisi_zip_create_req_q(ctx);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to create request queue (%d)!\\n\", ret);\n\t\tgoto err_ctx_exit;\n\t}\n\n\tret = hisi_zip_create_sgl_pool(ctx);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to create sgl pool (%d)!\\n\", ret);\n\t\tgoto err_release_req_q;\n\t}\n\n\thisi_zip_set_acomp_cb(ctx, hisi_zip_acomp_cb);\n\n\treturn 0;\n\nerr_release_req_q:\n\thisi_zip_release_req_q(ctx);\nerr_ctx_exit:\n\thisi_zip_ctx_exit(ctx);\n\treturn ret;\n}\n\nstatic void hisi_zip_acomp_exit(struct crypto_acomp *tfm)\n{\n\tstruct hisi_zip_ctx *ctx = crypto_tfm_ctx(&tfm->base);\n\n\thisi_zip_set_acomp_cb(ctx, NULL);\n\thisi_zip_release_sgl_pool(ctx);\n\thisi_zip_release_req_q(ctx);\n\thisi_zip_ctx_exit(ctx);\n}\n\nstatic struct acomp_alg hisi_zip_acomp_zlib = {\n\t.init\t\t\t= hisi_zip_acomp_init,\n\t.exit\t\t\t= hisi_zip_acomp_exit,\n\t.compress\t\t= hisi_zip_acompress,\n\t.decompress\t\t= hisi_zip_adecompress,\n\t.base\t\t\t= {\n\t\t.cra_name\t\t= \"zlib-deflate\",\n\t\t.cra_driver_name\t= \"hisi-zlib-acomp\",\n\t\t.cra_module\t\t= THIS_MODULE,\n\t\t.cra_priority           = HZIP_ALG_PRIORITY,\n\t\t.cra_ctxsize\t\t= sizeof(struct hisi_zip_ctx),\n\t}\n};\n\nstatic int hisi_zip_register_zlib(struct hisi_qm *qm)\n{\n\tint ret;\n\n\tif (!hisi_zip_alg_support(qm, HZIP_ALG_ZLIB))\n\t\treturn 0;\n\n\tret = crypto_register_acomp(&hisi_zip_acomp_zlib);\n\tif (ret)\n\t\tdev_err(&qm->pdev->dev, \"failed to register to zlib (%d)!\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void hisi_zip_unregister_zlib(struct hisi_qm *qm)\n{\n\tif (!hisi_zip_alg_support(qm, HZIP_ALG_ZLIB))\n\t\treturn;\n\n\tcrypto_unregister_acomp(&hisi_zip_acomp_zlib);\n}\n\nstatic struct acomp_alg hisi_zip_acomp_gzip = {\n\t.init\t\t\t= hisi_zip_acomp_init,\n\t.exit\t\t\t= hisi_zip_acomp_exit,\n\t.compress\t\t= hisi_zip_acompress,\n\t.decompress\t\t= hisi_zip_adecompress,\n\t.base\t\t\t= {\n\t\t.cra_name\t\t= \"gzip\",\n\t\t.cra_driver_name\t= \"hisi-gzip-acomp\",\n\t\t.cra_module\t\t= THIS_MODULE,\n\t\t.cra_priority           = HZIP_ALG_PRIORITY,\n\t\t.cra_ctxsize\t\t= sizeof(struct hisi_zip_ctx),\n\t}\n};\n\nstatic int hisi_zip_register_gzip(struct hisi_qm *qm)\n{\n\tint ret;\n\n\tif (!hisi_zip_alg_support(qm, HZIP_ALG_GZIP))\n\t\treturn 0;\n\n\tret = crypto_register_acomp(&hisi_zip_acomp_gzip);\n\tif (ret)\n\t\tdev_err(&qm->pdev->dev, \"failed to register to gzip (%d)!\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void hisi_zip_unregister_gzip(struct hisi_qm *qm)\n{\n\tif (!hisi_zip_alg_support(qm, HZIP_ALG_GZIP))\n\t\treturn;\n\n\tcrypto_unregister_acomp(&hisi_zip_acomp_gzip);\n}\n\nint hisi_zip_register_to_crypto(struct hisi_qm *qm)\n{\n\tint ret = 0;\n\n\tret = hisi_zip_register_zlib(qm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hisi_zip_register_gzip(qm);\n\tif (ret)\n\t\thisi_zip_unregister_zlib(qm);\n\n\treturn ret;\n}\n\nvoid hisi_zip_unregister_from_crypto(struct hisi_qm *qm)\n{\n\thisi_zip_unregister_zlib(qm);\n\thisi_zip_unregister_gzip(qm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}