{
  "module_name": "core.c",
  "hash_id": "8311984f9f7c8d88f3bf1aa2665e40b90a5a16ea191c0a91e813ef8c36ee875a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/qce/core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/interconnect.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <crypto/algapi.h>\n#include <crypto/internal/hash.h>\n\n#include \"core.h\"\n#include \"cipher.h\"\n#include \"sha.h\"\n#include \"aead.h\"\n\n#define QCE_MAJOR_VERSION5\t0x05\n#define QCE_QUEUE_LENGTH\t1\n\n#define QCE_DEFAULT_MEM_BANDWIDTH\t393600\n\nstatic const struct qce_algo_ops *qce_ops[] = {\n#ifdef CONFIG_CRYPTO_DEV_QCE_SKCIPHER\n\t&skcipher_ops,\n#endif\n#ifdef CONFIG_CRYPTO_DEV_QCE_SHA\n\t&ahash_ops,\n#endif\n#ifdef CONFIG_CRYPTO_DEV_QCE_AEAD\n\t&aead_ops,\n#endif\n};\n\nstatic void qce_unregister_algs(struct qce_device *qce)\n{\n\tconst struct qce_algo_ops *ops;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(qce_ops); i++) {\n\t\tops = qce_ops[i];\n\t\tops->unregister_algs(qce);\n\t}\n}\n\nstatic int qce_register_algs(struct qce_device *qce)\n{\n\tconst struct qce_algo_ops *ops;\n\tint i, ret = -ENODEV;\n\n\tfor (i = 0; i < ARRAY_SIZE(qce_ops); i++) {\n\t\tops = qce_ops[i];\n\t\tret = ops->register_algs(qce);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int qce_handle_request(struct crypto_async_request *async_req)\n{\n\tint ret = -EINVAL, i;\n\tconst struct qce_algo_ops *ops;\n\tu32 type = crypto_tfm_alg_type(async_req->tfm);\n\n\tfor (i = 0; i < ARRAY_SIZE(qce_ops); i++) {\n\t\tops = qce_ops[i];\n\t\tif (type != ops->type)\n\t\t\tcontinue;\n\t\tret = ops->async_req_handle(async_req);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int qce_handle_queue(struct qce_device *qce,\n\t\t\t    struct crypto_async_request *req)\n{\n\tstruct crypto_async_request *async_req, *backlog;\n\tunsigned long flags;\n\tint ret = 0, err;\n\n\tspin_lock_irqsave(&qce->lock, flags);\n\n\tif (req)\n\t\tret = crypto_enqueue_request(&qce->queue, req);\n\n\t \n\tif (qce->req) {\n\t\tspin_unlock_irqrestore(&qce->lock, flags);\n\t\treturn ret;\n\t}\n\n\tbacklog = crypto_get_backlog(&qce->queue);\n\tasync_req = crypto_dequeue_request(&qce->queue);\n\tif (async_req)\n\t\tqce->req = async_req;\n\n\tspin_unlock_irqrestore(&qce->lock, flags);\n\n\tif (!async_req)\n\t\treturn ret;\n\n\tif (backlog) {\n\t\tspin_lock_bh(&qce->lock);\n\t\tcrypto_request_complete(backlog, -EINPROGRESS);\n\t\tspin_unlock_bh(&qce->lock);\n\t}\n\n\terr = qce_handle_request(async_req);\n\tif (err) {\n\t\tqce->result = err;\n\t\ttasklet_schedule(&qce->done_tasklet);\n\t}\n\n\treturn ret;\n}\n\nstatic void qce_tasklet_req_done(unsigned long data)\n{\n\tstruct qce_device *qce = (struct qce_device *)data;\n\tstruct crypto_async_request *req;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qce->lock, flags);\n\treq = qce->req;\n\tqce->req = NULL;\n\tspin_unlock_irqrestore(&qce->lock, flags);\n\n\tif (req)\n\t\tcrypto_request_complete(req, qce->result);\n\n\tqce_handle_queue(qce, NULL);\n}\n\nstatic int qce_async_request_enqueue(struct qce_device *qce,\n\t\t\t\t     struct crypto_async_request *req)\n{\n\treturn qce_handle_queue(qce, req);\n}\n\nstatic void qce_async_request_done(struct qce_device *qce, int ret)\n{\n\tqce->result = ret;\n\ttasklet_schedule(&qce->done_tasklet);\n}\n\nstatic int qce_check_version(struct qce_device *qce)\n{\n\tu32 major, minor, step;\n\n\tqce_get_version(qce, &major, &minor, &step);\n\n\t \n\tif (major != QCE_MAJOR_VERSION5 || minor == 0)\n\t\treturn -ENODEV;\n\n\tqce->burst_size = QCE_BAM_BURST_SIZE;\n\n\t \n\tqce->pipe_pair_id = qce->dma.rxchan->chan_id >> 1;\n\n\tdev_dbg(qce->dev, \"Crypto device found, version %d.%d.%d\\n\",\n\t\tmajor, minor, step);\n\n\treturn 0;\n}\n\nstatic int qce_crypto_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct qce_device *qce;\n\tint ret;\n\n\tqce = devm_kzalloc(dev, sizeof(*qce), GFP_KERNEL);\n\tif (!qce)\n\t\treturn -ENOMEM;\n\n\tqce->dev = dev;\n\tplatform_set_drvdata(pdev, qce);\n\n\tqce->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(qce->base))\n\t\treturn PTR_ERR(qce->base);\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tqce->core = devm_clk_get_optional(qce->dev, \"core\");\n\tif (IS_ERR(qce->core))\n\t\treturn PTR_ERR(qce->core);\n\n\tqce->iface = devm_clk_get_optional(qce->dev, \"iface\");\n\tif (IS_ERR(qce->iface))\n\t\treturn PTR_ERR(qce->iface);\n\n\tqce->bus = devm_clk_get_optional(qce->dev, \"bus\");\n\tif (IS_ERR(qce->bus))\n\t\treturn PTR_ERR(qce->bus);\n\n\tqce->mem_path = devm_of_icc_get(qce->dev, \"memory\");\n\tif (IS_ERR(qce->mem_path))\n\t\treturn PTR_ERR(qce->mem_path);\n\n\tret = icc_set_bw(qce->mem_path, QCE_DEFAULT_MEM_BANDWIDTH, QCE_DEFAULT_MEM_BANDWIDTH);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(qce->core);\n\tif (ret)\n\t\tgoto err_mem_path_disable;\n\n\tret = clk_prepare_enable(qce->iface);\n\tif (ret)\n\t\tgoto err_clks_core;\n\n\tret = clk_prepare_enable(qce->bus);\n\tif (ret)\n\t\tgoto err_clks_iface;\n\n\tret = qce_dma_request(qce->dev, &qce->dma);\n\tif (ret)\n\t\tgoto err_clks;\n\n\tret = qce_check_version(qce);\n\tif (ret)\n\t\tgoto err_clks;\n\n\tspin_lock_init(&qce->lock);\n\ttasklet_init(&qce->done_tasklet, qce_tasklet_req_done,\n\t\t     (unsigned long)qce);\n\tcrypto_init_queue(&qce->queue, QCE_QUEUE_LENGTH);\n\n\tqce->async_req_enqueue = qce_async_request_enqueue;\n\tqce->async_req_done = qce_async_request_done;\n\n\tret = qce_register_algs(qce);\n\tif (ret)\n\t\tgoto err_dma;\n\n\treturn 0;\n\nerr_dma:\n\tqce_dma_release(&qce->dma);\nerr_clks:\n\tclk_disable_unprepare(qce->bus);\nerr_clks_iface:\n\tclk_disable_unprepare(qce->iface);\nerr_clks_core:\n\tclk_disable_unprepare(qce->core);\nerr_mem_path_disable:\n\ticc_set_bw(qce->mem_path, 0, 0);\n\n\treturn ret;\n}\n\nstatic int qce_crypto_remove(struct platform_device *pdev)\n{\n\tstruct qce_device *qce = platform_get_drvdata(pdev);\n\n\ttasklet_kill(&qce->done_tasklet);\n\tqce_unregister_algs(qce);\n\tqce_dma_release(&qce->dma);\n\tclk_disable_unprepare(qce->bus);\n\tclk_disable_unprepare(qce->iface);\n\tclk_disable_unprepare(qce->core);\n\treturn 0;\n}\n\nstatic const struct of_device_id qce_crypto_of_match[] = {\n\t{ .compatible = \"qcom,crypto-v5.1\", },\n\t{ .compatible = \"qcom,crypto-v5.4\", },\n\t{ .compatible = \"qcom,qce\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qce_crypto_of_match);\n\nstatic struct platform_driver qce_crypto_driver = {\n\t.probe = qce_crypto_probe,\n\t.remove = qce_crypto_remove,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = qce_crypto_of_match,\n\t},\n};\nmodule_platform_driver(qce_crypto_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Qualcomm crypto engine driver\");\nMODULE_ALIAS(\"platform:\" KBUILD_MODNAME);\nMODULE_AUTHOR(\"The Linux Foundation\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}