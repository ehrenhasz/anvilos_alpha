{
  "module_name": "common.c",
  "hash_id": "9e6a0ad0a1444c7a9b6806c3f3f54840fe0a2ea322a99782e5ff0b0d194a33cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/qce/common.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/hash.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/types.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/sha1.h>\n#include <crypto/sha2.h>\n\n#include \"cipher.h\"\n#include \"common.h\"\n#include \"core.h\"\n#include \"regs-v5.h\"\n#include \"sha.h\"\n#include \"aead.h\"\n\nstatic inline u32 qce_read(struct qce_device *qce, u32 offset)\n{\n\treturn readl(qce->base + offset);\n}\n\nstatic inline void qce_write(struct qce_device *qce, u32 offset, u32 val)\n{\n\twritel(val, qce->base + offset);\n}\n\nstatic inline void qce_write_array(struct qce_device *qce, u32 offset,\n\t\t\t\t   const u32 *val, unsigned int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tqce_write(qce, offset + i * sizeof(u32), val[i]);\n}\n\nstatic inline void\nqce_clear_array(struct qce_device *qce, u32 offset, unsigned int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tqce_write(qce, offset + i * sizeof(u32), 0);\n}\n\nstatic u32 qce_config_reg(struct qce_device *qce, int little)\n{\n\tu32 beats = (qce->burst_size >> 3) - 1;\n\tu32 pipe_pair = qce->pipe_pair_id;\n\tu32 config;\n\n\tconfig = (beats << REQ_SIZE_SHIFT) & REQ_SIZE_MASK;\n\tconfig |= BIT(MASK_DOUT_INTR_SHIFT) | BIT(MASK_DIN_INTR_SHIFT) |\n\t\t  BIT(MASK_OP_DONE_INTR_SHIFT) | BIT(MASK_ERR_INTR_SHIFT);\n\tconfig |= (pipe_pair << PIPE_SET_SELECT_SHIFT) & PIPE_SET_SELECT_MASK;\n\tconfig &= ~HIGH_SPD_EN_N_SHIFT;\n\n\tif (little)\n\t\tconfig |= BIT(LITTLE_ENDIAN_MODE_SHIFT);\n\n\treturn config;\n}\n\nvoid qce_cpu_to_be32p_array(__be32 *dst, const u8 *src, unsigned int len)\n{\n\t__be32 *d = dst;\n\tconst u8 *s = src;\n\tunsigned int n;\n\n\tn = len / sizeof(u32);\n\tfor (; n > 0; n--) {\n\t\t*d = cpu_to_be32p((const __u32 *) s);\n\t\ts += sizeof(__u32);\n\t\td++;\n\t}\n}\n\nstatic void qce_setup_config(struct qce_device *qce)\n{\n\tu32 config;\n\n\t \n\tconfig = qce_config_reg(qce, 0);\n\n\t \n\tqce_write(qce, REG_STATUS, 0);\n\tqce_write(qce, REG_CONFIG, config);\n}\n\nstatic inline void qce_crypto_go(struct qce_device *qce, bool result_dump)\n{\n\tif (result_dump)\n\t\tqce_write(qce, REG_GOPROC, BIT(GO_SHIFT) | BIT(RESULTS_DUMP_SHIFT));\n\telse\n\t\tqce_write(qce, REG_GOPROC, BIT(GO_SHIFT));\n}\n\n#if defined(CONFIG_CRYPTO_DEV_QCE_SHA) || defined(CONFIG_CRYPTO_DEV_QCE_AEAD)\nstatic u32 qce_auth_cfg(unsigned long flags, u32 key_size, u32 auth_size)\n{\n\tu32 cfg = 0;\n\n\tif (IS_CCM(flags) || IS_CMAC(flags))\n\t\tcfg |= AUTH_ALG_AES << AUTH_ALG_SHIFT;\n\telse\n\t\tcfg |= AUTH_ALG_SHA << AUTH_ALG_SHIFT;\n\n\tif (IS_CCM(flags) || IS_CMAC(flags)) {\n\t\tif (key_size == AES_KEYSIZE_128)\n\t\t\tcfg |= AUTH_KEY_SZ_AES128 << AUTH_KEY_SIZE_SHIFT;\n\t\telse if (key_size == AES_KEYSIZE_256)\n\t\t\tcfg |= AUTH_KEY_SZ_AES256 << AUTH_KEY_SIZE_SHIFT;\n\t}\n\n\tif (IS_SHA1(flags) || IS_SHA1_HMAC(flags))\n\t\tcfg |= AUTH_SIZE_SHA1 << AUTH_SIZE_SHIFT;\n\telse if (IS_SHA256(flags) || IS_SHA256_HMAC(flags))\n\t\tcfg |= AUTH_SIZE_SHA256 << AUTH_SIZE_SHIFT;\n\telse if (IS_CMAC(flags))\n\t\tcfg |= AUTH_SIZE_ENUM_16_BYTES << AUTH_SIZE_SHIFT;\n\telse if (IS_CCM(flags))\n\t\tcfg |= (auth_size - 1) << AUTH_SIZE_SHIFT;\n\n\tif (IS_SHA1(flags) || IS_SHA256(flags))\n\t\tcfg |= AUTH_MODE_HASH << AUTH_MODE_SHIFT;\n\telse if (IS_SHA1_HMAC(flags) || IS_SHA256_HMAC(flags))\n\t\tcfg |= AUTH_MODE_HMAC << AUTH_MODE_SHIFT;\n\telse if (IS_CCM(flags))\n\t\tcfg |= AUTH_MODE_CCM << AUTH_MODE_SHIFT;\n\telse if (IS_CMAC(flags))\n\t\tcfg |= AUTH_MODE_CMAC << AUTH_MODE_SHIFT;\n\n\tif (IS_SHA(flags) || IS_SHA_HMAC(flags))\n\t\tcfg |= AUTH_POS_BEFORE << AUTH_POS_SHIFT;\n\n\tif (IS_CCM(flags))\n\t\tcfg |= QCE_MAX_NONCE_WORDS << AUTH_NONCE_NUM_WORDS_SHIFT;\n\n\treturn cfg;\n}\n#endif\n\n#ifdef CONFIG_CRYPTO_DEV_QCE_SHA\nstatic int qce_setup_regs_ahash(struct crypto_async_request *async_req)\n{\n\tstruct ahash_request *req = ahash_request_cast(async_req);\n\tstruct crypto_ahash *ahash = __crypto_ahash_cast(async_req->tfm);\n\tstruct qce_sha_reqctx *rctx = ahash_request_ctx_dma(req);\n\tstruct qce_alg_template *tmpl = to_ahash_tmpl(async_req->tfm);\n\tstruct qce_device *qce = tmpl->qce;\n\tunsigned int digestsize = crypto_ahash_digestsize(ahash);\n\tunsigned int blocksize = crypto_tfm_alg_blocksize(async_req->tfm);\n\t__be32 auth[SHA256_DIGEST_SIZE / sizeof(__be32)] = {0};\n\t__be32 mackey[QCE_SHA_HMAC_KEY_SIZE / sizeof(__be32)] = {0};\n\tu32 auth_cfg = 0, config;\n\tunsigned int iv_words;\n\n\t \n\tif (!rctx->last_blk && req->nbytes % blocksize)\n\t\treturn -EINVAL;\n\n\tqce_setup_config(qce);\n\n\tif (IS_CMAC(rctx->flags)) {\n\t\tqce_write(qce, REG_AUTH_SEG_CFG, 0);\n\t\tqce_write(qce, REG_ENCR_SEG_CFG, 0);\n\t\tqce_write(qce, REG_ENCR_SEG_SIZE, 0);\n\t\tqce_clear_array(qce, REG_AUTH_IV0, 16);\n\t\tqce_clear_array(qce, REG_AUTH_KEY0, 16);\n\t\tqce_clear_array(qce, REG_AUTH_BYTECNT0, 4);\n\n\t\tauth_cfg = qce_auth_cfg(rctx->flags, rctx->authklen, digestsize);\n\t}\n\n\tif (IS_SHA_HMAC(rctx->flags) || IS_CMAC(rctx->flags)) {\n\t\tu32 authkey_words = rctx->authklen / sizeof(u32);\n\n\t\tqce_cpu_to_be32p_array(mackey, rctx->authkey, rctx->authklen);\n\t\tqce_write_array(qce, REG_AUTH_KEY0, (u32 *)mackey,\n\t\t\t\tauthkey_words);\n\t}\n\n\tif (IS_CMAC(rctx->flags))\n\t\tgoto go_proc;\n\n\tif (rctx->first_blk)\n\t\tmemcpy(auth, rctx->digest, digestsize);\n\telse\n\t\tqce_cpu_to_be32p_array(auth, rctx->digest, digestsize);\n\n\tiv_words = (IS_SHA1(rctx->flags) || IS_SHA1_HMAC(rctx->flags)) ? 5 : 8;\n\tqce_write_array(qce, REG_AUTH_IV0, (u32 *)auth, iv_words);\n\n\tif (rctx->first_blk)\n\t\tqce_clear_array(qce, REG_AUTH_BYTECNT0, 4);\n\telse\n\t\tqce_write_array(qce, REG_AUTH_BYTECNT0,\n\t\t\t\t(u32 *)rctx->byte_count, 2);\n\n\tauth_cfg = qce_auth_cfg(rctx->flags, 0, digestsize);\n\n\tif (rctx->last_blk)\n\t\tauth_cfg |= BIT(AUTH_LAST_SHIFT);\n\telse\n\t\tauth_cfg &= ~BIT(AUTH_LAST_SHIFT);\n\n\tif (rctx->first_blk)\n\t\tauth_cfg |= BIT(AUTH_FIRST_SHIFT);\n\telse\n\t\tauth_cfg &= ~BIT(AUTH_FIRST_SHIFT);\n\ngo_proc:\n\tqce_write(qce, REG_AUTH_SEG_CFG, auth_cfg);\n\tqce_write(qce, REG_AUTH_SEG_SIZE, req->nbytes);\n\tqce_write(qce, REG_AUTH_SEG_START, 0);\n\tqce_write(qce, REG_ENCR_SEG_CFG, 0);\n\tqce_write(qce, REG_SEG_SIZE, req->nbytes);\n\n\t \n\tconfig = qce_config_reg(qce, 1);\n\tqce_write(qce, REG_CONFIG, config);\n\n\tqce_crypto_go(qce, true);\n\n\treturn 0;\n}\n#endif\n\n#if defined(CONFIG_CRYPTO_DEV_QCE_SKCIPHER) || defined(CONFIG_CRYPTO_DEV_QCE_AEAD)\nstatic u32 qce_encr_cfg(unsigned long flags, u32 aes_key_size)\n{\n\tu32 cfg = 0;\n\n\tif (IS_AES(flags)) {\n\t\tif (aes_key_size == AES_KEYSIZE_128)\n\t\t\tcfg |= ENCR_KEY_SZ_AES128 << ENCR_KEY_SZ_SHIFT;\n\t\telse if (aes_key_size == AES_KEYSIZE_256)\n\t\t\tcfg |= ENCR_KEY_SZ_AES256 << ENCR_KEY_SZ_SHIFT;\n\t}\n\n\tif (IS_AES(flags))\n\t\tcfg |= ENCR_ALG_AES << ENCR_ALG_SHIFT;\n\telse if (IS_DES(flags) || IS_3DES(flags))\n\t\tcfg |= ENCR_ALG_DES << ENCR_ALG_SHIFT;\n\n\tif (IS_DES(flags))\n\t\tcfg |= ENCR_KEY_SZ_DES << ENCR_KEY_SZ_SHIFT;\n\n\tif (IS_3DES(flags))\n\t\tcfg |= ENCR_KEY_SZ_3DES << ENCR_KEY_SZ_SHIFT;\n\n\tswitch (flags & QCE_MODE_MASK) {\n\tcase QCE_MODE_ECB:\n\t\tcfg |= ENCR_MODE_ECB << ENCR_MODE_SHIFT;\n\t\tbreak;\n\tcase QCE_MODE_CBC:\n\t\tcfg |= ENCR_MODE_CBC << ENCR_MODE_SHIFT;\n\t\tbreak;\n\tcase QCE_MODE_CTR:\n\t\tcfg |= ENCR_MODE_CTR << ENCR_MODE_SHIFT;\n\t\tbreak;\n\tcase QCE_MODE_XTS:\n\t\tcfg |= ENCR_MODE_XTS << ENCR_MODE_SHIFT;\n\t\tbreak;\n\tcase QCE_MODE_CCM:\n\t\tcfg |= ENCR_MODE_CCM << ENCR_MODE_SHIFT;\n\t\tcfg |= LAST_CCM_XFR << LAST_CCM_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn ~0;\n\t}\n\n\treturn cfg;\n}\n#endif\n\n#ifdef CONFIG_CRYPTO_DEV_QCE_SKCIPHER\nstatic void qce_xts_swapiv(__be32 *dst, const u8 *src, unsigned int ivsize)\n{\n\tu8 swap[QCE_AES_IV_LENGTH];\n\tu32 i, j;\n\n\tif (ivsize > QCE_AES_IV_LENGTH)\n\t\treturn;\n\n\tmemset(swap, 0, QCE_AES_IV_LENGTH);\n\n\tfor (i = (QCE_AES_IV_LENGTH - ivsize), j = ivsize - 1;\n\t     i < QCE_AES_IV_LENGTH; i++, j--)\n\t\tswap[i] = src[j];\n\n\tqce_cpu_to_be32p_array(dst, swap, QCE_AES_IV_LENGTH);\n}\n\nstatic void qce_xtskey(struct qce_device *qce, const u8 *enckey,\n\t\t       unsigned int enckeylen, unsigned int cryptlen)\n{\n\tu32 xtskey[QCE_MAX_CIPHER_KEY_SIZE / sizeof(u32)] = {0};\n\tunsigned int xtsklen = enckeylen / (2 * sizeof(u32));\n\n\tqce_cpu_to_be32p_array((__be32 *)xtskey, enckey + enckeylen / 2,\n\t\t\t       enckeylen / 2);\n\tqce_write_array(qce, REG_ENCR_XTS_KEY0, xtskey, xtsklen);\n\n\t \n\tqce_write(qce, REG_ENCR_XTS_DU_SIZE, cryptlen);\n}\n\nstatic int qce_setup_regs_skcipher(struct crypto_async_request *async_req)\n{\n\tstruct skcipher_request *req = skcipher_request_cast(async_req);\n\tstruct qce_cipher_reqctx *rctx = skcipher_request_ctx(req);\n\tstruct qce_cipher_ctx *ctx = crypto_tfm_ctx(async_req->tfm);\n\tstruct qce_alg_template *tmpl = to_cipher_tmpl(crypto_skcipher_reqtfm(req));\n\tstruct qce_device *qce = tmpl->qce;\n\t__be32 enckey[QCE_MAX_CIPHER_KEY_SIZE / sizeof(__be32)] = {0};\n\t__be32 enciv[QCE_MAX_IV_SIZE / sizeof(__be32)] = {0};\n\tunsigned int enckey_words, enciv_words;\n\tunsigned int keylen;\n\tu32 encr_cfg = 0, auth_cfg = 0, config;\n\tunsigned int ivsize = rctx->ivsize;\n\tunsigned long flags = rctx->flags;\n\n\tqce_setup_config(qce);\n\n\tif (IS_XTS(flags))\n\t\tkeylen = ctx->enc_keylen / 2;\n\telse\n\t\tkeylen = ctx->enc_keylen;\n\n\tqce_cpu_to_be32p_array(enckey, ctx->enc_key, keylen);\n\tenckey_words = keylen / sizeof(u32);\n\n\tqce_write(qce, REG_AUTH_SEG_CFG, auth_cfg);\n\n\tencr_cfg = qce_encr_cfg(flags, keylen);\n\n\tif (IS_DES(flags)) {\n\t\tenciv_words = 2;\n\t\tenckey_words = 2;\n\t} else if (IS_3DES(flags)) {\n\t\tenciv_words = 2;\n\t\tenckey_words = 6;\n\t} else if (IS_AES(flags)) {\n\t\tif (IS_XTS(flags))\n\t\t\tqce_xtskey(qce, ctx->enc_key, ctx->enc_keylen,\n\t\t\t\t   rctx->cryptlen);\n\t\tenciv_words = 4;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tqce_write_array(qce, REG_ENCR_KEY0, (u32 *)enckey, enckey_words);\n\n\tif (!IS_ECB(flags)) {\n\t\tif (IS_XTS(flags))\n\t\t\tqce_xts_swapiv(enciv, rctx->iv, ivsize);\n\t\telse\n\t\t\tqce_cpu_to_be32p_array(enciv, rctx->iv, ivsize);\n\n\t\tqce_write_array(qce, REG_CNTR0_IV0, (u32 *)enciv, enciv_words);\n\t}\n\n\tif (IS_ENCRYPT(flags))\n\t\tencr_cfg |= BIT(ENCODE_SHIFT);\n\n\tqce_write(qce, REG_ENCR_SEG_CFG, encr_cfg);\n\tqce_write(qce, REG_ENCR_SEG_SIZE, rctx->cryptlen);\n\tqce_write(qce, REG_ENCR_SEG_START, 0);\n\n\tif (IS_CTR(flags)) {\n\t\tqce_write(qce, REG_CNTR_MASK, ~0);\n\t\tqce_write(qce, REG_CNTR_MASK0, ~0);\n\t\tqce_write(qce, REG_CNTR_MASK1, ~0);\n\t\tqce_write(qce, REG_CNTR_MASK2, ~0);\n\t}\n\n\tqce_write(qce, REG_SEG_SIZE, rctx->cryptlen);\n\n\t \n\tconfig = qce_config_reg(qce, 1);\n\tqce_write(qce, REG_CONFIG, config);\n\n\tqce_crypto_go(qce, true);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_CRYPTO_DEV_QCE_AEAD\nstatic const u32 std_iv_sha1[SHA256_DIGEST_SIZE / sizeof(u32)] = {\n\tSHA1_H0, SHA1_H1, SHA1_H2, SHA1_H3, SHA1_H4, 0, 0, 0\n};\n\nstatic const u32 std_iv_sha256[SHA256_DIGEST_SIZE / sizeof(u32)] = {\n\tSHA256_H0, SHA256_H1, SHA256_H2, SHA256_H3,\n\tSHA256_H4, SHA256_H5, SHA256_H6, SHA256_H7\n};\n\nstatic unsigned int qce_be32_to_cpu_array(u32 *dst, const u8 *src, unsigned int len)\n{\n\tu32 *d = dst;\n\tconst u8 *s = src;\n\tunsigned int n;\n\n\tn = len / sizeof(u32);\n\tfor (; n > 0; n--) {\n\t\t*d = be32_to_cpup((const __be32 *)s);\n\t\ts += sizeof(u32);\n\t\td++;\n\t}\n\treturn DIV_ROUND_UP(len, sizeof(u32));\n}\n\nstatic int qce_setup_regs_aead(struct crypto_async_request *async_req)\n{\n\tstruct aead_request *req = aead_request_cast(async_req);\n\tstruct qce_aead_reqctx *rctx = aead_request_ctx_dma(req);\n\tstruct qce_aead_ctx *ctx = crypto_tfm_ctx(async_req->tfm);\n\tstruct qce_alg_template *tmpl = to_aead_tmpl(crypto_aead_reqtfm(req));\n\tstruct qce_device *qce = tmpl->qce;\n\tu32 enckey[QCE_MAX_CIPHER_KEY_SIZE / sizeof(u32)] = {0};\n\tu32 enciv[QCE_MAX_IV_SIZE / sizeof(u32)] = {0};\n\tu32 authkey[QCE_SHA_HMAC_KEY_SIZE / sizeof(u32)] = {0};\n\tu32 authiv[SHA256_DIGEST_SIZE / sizeof(u32)] = {0};\n\tu32 authnonce[QCE_MAX_NONCE / sizeof(u32)] = {0};\n\tunsigned int enc_keylen = ctx->enc_keylen;\n\tunsigned int auth_keylen = ctx->auth_keylen;\n\tunsigned int enc_ivsize = rctx->ivsize;\n\tunsigned int auth_ivsize = 0;\n\tunsigned int enckey_words, enciv_words;\n\tunsigned int authkey_words, authiv_words, authnonce_words;\n\tunsigned long flags = rctx->flags;\n\tu32 encr_cfg, auth_cfg, config, totallen;\n\tu32 iv_last_word;\n\n\tqce_setup_config(qce);\n\n\t \n\tenckey_words = qce_be32_to_cpu_array(enckey, ctx->enc_key, enc_keylen);\n\tqce_write_array(qce, REG_ENCR_KEY0, enckey, enckey_words);\n\n\t \n\tenciv_words = qce_be32_to_cpu_array(enciv, rctx->iv, enc_ivsize);\n\tqce_write_array(qce, REG_CNTR0_IV0, enciv, enciv_words);\n\n\tif (IS_CCM(rctx->flags)) {\n\t\tiv_last_word = enciv[enciv_words - 1];\n\t\tqce_write(qce, REG_CNTR3_IV3, iv_last_word + 1);\n\t\tqce_write_array(qce, REG_ENCR_CCM_INT_CNTR0, (u32 *)enciv, enciv_words);\n\t\tqce_write(qce, REG_CNTR_MASK, ~0);\n\t\tqce_write(qce, REG_CNTR_MASK0, ~0);\n\t\tqce_write(qce, REG_CNTR_MASK1, ~0);\n\t\tqce_write(qce, REG_CNTR_MASK2, ~0);\n\t}\n\n\t \n\tqce_clear_array(qce, REG_AUTH_IV0, 16);\n\tqce_clear_array(qce, REG_AUTH_KEY0, 16);\n\n\t \n\tqce_clear_array(qce, REG_AUTH_BYTECNT0, 4);\n\n\t \n\tauthkey_words = qce_be32_to_cpu_array(authkey, ctx->auth_key, auth_keylen);\n\tqce_write_array(qce, REG_AUTH_KEY0, (u32 *)authkey, authkey_words);\n\n\t \n\tif (IS_SHA_HMAC(rctx->flags)) {\n\t\t \n\t\tif (IS_SHA1_HMAC(rctx->flags)) {\n\t\t\tauth_ivsize = SHA1_DIGEST_SIZE;\n\t\t\tmemcpy(authiv, std_iv_sha1, auth_ivsize);\n\t\t} else if (IS_SHA256_HMAC(rctx->flags)) {\n\t\t\tauth_ivsize = SHA256_DIGEST_SIZE;\n\t\t\tmemcpy(authiv, std_iv_sha256, auth_ivsize);\n\t\t}\n\t\tauthiv_words = auth_ivsize / sizeof(u32);\n\t\tqce_write_array(qce, REG_AUTH_IV0, (u32 *)authiv, authiv_words);\n\t} else if (IS_CCM(rctx->flags)) {\n\t\t \n\t\tauthnonce_words = qce_be32_to_cpu_array(authnonce, rctx->ccm_nonce, QCE_MAX_NONCE);\n\t\tqce_write_array(qce, REG_AUTH_INFO_NONCE0, authnonce, authnonce_words);\n\t}\n\n\t \n\tencr_cfg = qce_encr_cfg(flags, enc_keylen);\n\tif (IS_ENCRYPT(flags))\n\t\tencr_cfg |= BIT(ENCODE_SHIFT);\n\tqce_write(qce, REG_ENCR_SEG_CFG, encr_cfg);\n\n\t \n\tauth_cfg = qce_auth_cfg(rctx->flags, auth_keylen, ctx->authsize);\n\tauth_cfg |= BIT(AUTH_LAST_SHIFT);\n\tauth_cfg |= BIT(AUTH_FIRST_SHIFT);\n\tif (IS_ENCRYPT(flags)) {\n\t\tif (IS_CCM(rctx->flags))\n\t\t\tauth_cfg |= AUTH_POS_BEFORE << AUTH_POS_SHIFT;\n\t\telse\n\t\t\tauth_cfg |= AUTH_POS_AFTER << AUTH_POS_SHIFT;\n\t} else {\n\t\tif (IS_CCM(rctx->flags))\n\t\t\tauth_cfg |= AUTH_POS_AFTER << AUTH_POS_SHIFT;\n\t\telse\n\t\t\tauth_cfg |= AUTH_POS_BEFORE << AUTH_POS_SHIFT;\n\t}\n\tqce_write(qce, REG_AUTH_SEG_CFG, auth_cfg);\n\n\ttotallen = rctx->cryptlen + rctx->assoclen;\n\n\t \n\tif (IS_CCM(rctx->flags) && IS_DECRYPT(rctx->flags))\n\t\tqce_write(qce, REG_ENCR_SEG_SIZE, rctx->cryptlen + ctx->authsize);\n\telse\n\t\tqce_write(qce, REG_ENCR_SEG_SIZE, rctx->cryptlen);\n\tqce_write(qce, REG_ENCR_SEG_START, rctx->assoclen & 0xffff);\n\n\t \n\tqce_write(qce, REG_AUTH_SEG_SIZE, totallen);\n\tqce_write(qce, REG_AUTH_SEG_START, 0);\n\n\t \n\tif (IS_CCM(rctx->flags) && IS_DECRYPT(rctx->flags))\n\t\tqce_write(qce, REG_SEG_SIZE, totallen + ctx->authsize);\n\telse\n\t\tqce_write(qce, REG_SEG_SIZE, totallen);\n\n\t \n\tconfig = qce_config_reg(qce, 1);\n\tqce_write(qce, REG_CONFIG, config);\n\n\t \n\tqce_crypto_go(qce, !IS_CCM(flags));\n\n\treturn 0;\n}\n#endif\n\nint qce_start(struct crypto_async_request *async_req, u32 type)\n{\n\tswitch (type) {\n#ifdef CONFIG_CRYPTO_DEV_QCE_SKCIPHER\n\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\treturn qce_setup_regs_skcipher(async_req);\n#endif\n#ifdef CONFIG_CRYPTO_DEV_QCE_SHA\n\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\treturn qce_setup_regs_ahash(async_req);\n#endif\n#ifdef CONFIG_CRYPTO_DEV_QCE_AEAD\n\tcase CRYPTO_ALG_TYPE_AEAD:\n\t\treturn qce_setup_regs_aead(async_req);\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#define STATUS_ERRORS\t\\\n\t\t(BIT(SW_ERR_SHIFT) | BIT(AXI_ERR_SHIFT) | BIT(HSD_ERR_SHIFT))\n\nint qce_check_status(struct qce_device *qce, u32 *status)\n{\n\tint ret = 0;\n\n\t*status = qce_read(qce, REG_STATUS);\n\n\t \n\tif (*status & STATUS_ERRORS || !(*status & BIT(OPERATION_DONE_SHIFT)))\n\t\tret = -ENXIO;\n\telse if (*status & BIT(MAC_FAILED_SHIFT))\n\t\tret = -EBADMSG;\n\n\treturn ret;\n}\n\nvoid qce_get_version(struct qce_device *qce, u32 *major, u32 *minor, u32 *step)\n{\n\tu32 val;\n\n\tval = qce_read(qce, REG_VERSION);\n\t*major = (val & CORE_MAJOR_REV_MASK) >> CORE_MAJOR_REV_SHIFT;\n\t*minor = (val & CORE_MINOR_REV_MASK) >> CORE_MINOR_REV_SHIFT;\n\t*step = (val & CORE_STEP_REV_MASK) >> CORE_STEP_REV_SHIFT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}