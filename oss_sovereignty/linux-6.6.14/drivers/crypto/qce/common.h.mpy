{
  "module_name": "common.h",
  "hash_id": "f6be285163ba0b8254002fbf7bd6fecc19d46fd67eecb21edc0b8748d0458c50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/qce/common.h",
  "human_readable_source": " \n \n\n#ifndef _COMMON_H_\n#define _COMMON_H_\n\n#include <linux/crypto.h>\n#include <linux/types.h>\n#include <crypto/aes.h>\n#include <crypto/hash.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/internal/aead.h>\n\n \n#define QCE_SECTOR_SIZE\t\t\t512\n\n \n#define QCE_SHA_HMAC_KEY_SIZE\t\t64\n#define QCE_MAX_CIPHER_KEY_SIZE\t\tAES_KEYSIZE_256\n\n \n#define QCE_AES_IV_LENGTH\t\tAES_BLOCK_SIZE\n \n#define QCE_MAX_IV_SIZE\t\t\tAES_BLOCK_SIZE\n\n \n#define QCE_MAX_NONCE\t\t\t16\n#define QCE_MAX_NONCE_WORDS\t\t(QCE_MAX_NONCE / sizeof(u32))\n\n \n#define QCE_MAX_ALIGN_SIZE\t\t64\n\n \n#define QCE_ALG_DES\t\t\tBIT(0)\n#define QCE_ALG_3DES\t\t\tBIT(1)\n#define QCE_ALG_AES\t\t\tBIT(2)\n\n \n#define QCE_HASH_SHA1\t\t\tBIT(3)\n#define QCE_HASH_SHA256\t\t\tBIT(4)\n#define QCE_HASH_SHA1_HMAC\t\tBIT(5)\n#define QCE_HASH_SHA256_HMAC\t\tBIT(6)\n#define QCE_HASH_AES_CMAC\t\tBIT(7)\n\n \n#define QCE_MODE_CBC\t\t\tBIT(8)\n#define QCE_MODE_ECB\t\t\tBIT(9)\n#define QCE_MODE_CTR\t\t\tBIT(10)\n#define QCE_MODE_XTS\t\t\tBIT(11)\n#define QCE_MODE_CCM\t\t\tBIT(12)\n#define QCE_MODE_MASK\t\t\tGENMASK(12, 8)\n\n#define QCE_MODE_CCM_RFC4309\t\tBIT(13)\n\n \n#define QCE_ENCRYPT\t\t\tBIT(30)\n#define QCE_DECRYPT\t\t\tBIT(31)\n\n#define IS_DES(flags)\t\t\t(flags & QCE_ALG_DES)\n#define IS_3DES(flags)\t\t\t(flags & QCE_ALG_3DES)\n#define IS_AES(flags)\t\t\t(flags & QCE_ALG_AES)\n\n#define IS_SHA1(flags)\t\t\t(flags & QCE_HASH_SHA1)\n#define IS_SHA256(flags)\t\t(flags & QCE_HASH_SHA256)\n#define IS_SHA1_HMAC(flags)\t\t(flags & QCE_HASH_SHA1_HMAC)\n#define IS_SHA256_HMAC(flags)\t\t(flags & QCE_HASH_SHA256_HMAC)\n#define IS_CMAC(flags)\t\t\t(flags & QCE_HASH_AES_CMAC)\n#define IS_SHA(flags)\t\t\t(IS_SHA1(flags) || IS_SHA256(flags))\n#define IS_SHA_HMAC(flags)\t\t\\\n\t\t(IS_SHA1_HMAC(flags) || IS_SHA256_HMAC(flags))\n\n#define IS_CBC(mode)\t\t\t(mode & QCE_MODE_CBC)\n#define IS_ECB(mode)\t\t\t(mode & QCE_MODE_ECB)\n#define IS_CTR(mode)\t\t\t(mode & QCE_MODE_CTR)\n#define IS_XTS(mode)\t\t\t(mode & QCE_MODE_XTS)\n#define IS_CCM(mode)\t\t\t(mode & QCE_MODE_CCM)\n#define IS_CCM_RFC4309(mode)\t\t((mode) & QCE_MODE_CCM_RFC4309)\n\n#define IS_ENCRYPT(dir)\t\t\t(dir & QCE_ENCRYPT)\n#define IS_DECRYPT(dir)\t\t\t(dir & QCE_DECRYPT)\n\nstruct qce_alg_template {\n\tstruct list_head entry;\n\tu32 crypto_alg_type;\n\tunsigned long alg_flags;\n\tconst u32 *std_iv;\n\tunion {\n\t\tstruct skcipher_alg skcipher;\n\t\tstruct ahash_alg ahash;\n\t\tstruct aead_alg aead;\n\t} alg;\n\tstruct qce_device *qce;\n\tconst u8 *hash_zero;\n\tconst u32 digest_size;\n};\n\nvoid qce_cpu_to_be32p_array(__be32 *dst, const u8 *src, unsigned int len);\nint qce_check_status(struct qce_device *qce, u32 *status);\nvoid qce_get_version(struct qce_device *qce, u32 *major, u32 *minor, u32 *step);\nint qce_start(struct crypto_async_request *async_req, u32 type);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}