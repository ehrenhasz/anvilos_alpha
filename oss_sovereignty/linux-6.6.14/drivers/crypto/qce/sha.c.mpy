{
  "module_name": "sha.c",
  "hash_id": "35d5762f99251bce9f8655b4047fc3b8e49a67f35f78fc3384982c36d81c0583",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/qce/sha.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <crypto/internal/hash.h>\n\n#include \"common.h\"\n#include \"core.h\"\n#include \"sha.h\"\n\nstruct qce_sha_saved_state {\n\tu8 pending_buf[QCE_SHA_MAX_BLOCKSIZE];\n\tu8 partial_digest[QCE_SHA_MAX_DIGESTSIZE];\n\t__be32 byte_count[2];\n\tunsigned int pending_buflen;\n\tunsigned int flags;\n\tu64 count;\n\tbool first_blk;\n};\n\nstatic LIST_HEAD(ahash_algs);\n\nstatic const u32 std_iv_sha1[SHA256_DIGEST_SIZE / sizeof(u32)] = {\n\tSHA1_H0, SHA1_H1, SHA1_H2, SHA1_H3, SHA1_H4, 0, 0, 0\n};\n\nstatic const u32 std_iv_sha256[SHA256_DIGEST_SIZE / sizeof(u32)] = {\n\tSHA256_H0, SHA256_H1, SHA256_H2, SHA256_H3,\n\tSHA256_H4, SHA256_H5, SHA256_H6, SHA256_H7\n};\n\nstatic void qce_ahash_done(void *data)\n{\n\tstruct crypto_async_request *async_req = data;\n\tstruct ahash_request *req = ahash_request_cast(async_req);\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct qce_sha_reqctx *rctx = ahash_request_ctx_dma(req);\n\tstruct qce_alg_template *tmpl = to_ahash_tmpl(async_req->tfm);\n\tstruct qce_device *qce = tmpl->qce;\n\tstruct qce_result_dump *result = qce->dma.result_buf;\n\tunsigned int digestsize = crypto_ahash_digestsize(ahash);\n\tint error;\n\tu32 status;\n\n\terror = qce_dma_terminate_all(&qce->dma);\n\tif (error)\n\t\tdev_dbg(qce->dev, \"ahash dma termination error (%d)\\n\", error);\n\n\tdma_unmap_sg(qce->dev, req->src, rctx->src_nents, DMA_TO_DEVICE);\n\tdma_unmap_sg(qce->dev, &rctx->result_sg, 1, DMA_FROM_DEVICE);\n\n\tmemcpy(rctx->digest, result->auth_iv, digestsize);\n\tif (req->result && rctx->last_blk)\n\t\tmemcpy(req->result, result->auth_iv, digestsize);\n\n\trctx->byte_count[0] = cpu_to_be32(result->auth_byte_count[0]);\n\trctx->byte_count[1] = cpu_to_be32(result->auth_byte_count[1]);\n\n\terror = qce_check_status(qce, &status);\n\tif (error < 0)\n\t\tdev_dbg(qce->dev, \"ahash operation error (%x)\\n\", status);\n\n\treq->src = rctx->src_orig;\n\treq->nbytes = rctx->nbytes_orig;\n\trctx->last_blk = false;\n\trctx->first_blk = false;\n\n\tqce->async_req_done(tmpl->qce, error);\n}\n\nstatic int qce_ahash_async_req_handle(struct crypto_async_request *async_req)\n{\n\tstruct ahash_request *req = ahash_request_cast(async_req);\n\tstruct qce_sha_reqctx *rctx = ahash_request_ctx_dma(req);\n\tstruct qce_sha_ctx *ctx = crypto_tfm_ctx(async_req->tfm);\n\tstruct qce_alg_template *tmpl = to_ahash_tmpl(async_req->tfm);\n\tstruct qce_device *qce = tmpl->qce;\n\tunsigned long flags = rctx->flags;\n\tint ret;\n\n\tif (IS_SHA_HMAC(flags)) {\n\t\trctx->authkey = ctx->authkey;\n\t\trctx->authklen = QCE_SHA_HMAC_KEY_SIZE;\n\t} else if (IS_CMAC(flags)) {\n\t\trctx->authkey = ctx->authkey;\n\t\trctx->authklen = AES_KEYSIZE_128;\n\t}\n\n\trctx->src_nents = sg_nents_for_len(req->src, req->nbytes);\n\tif (rctx->src_nents < 0) {\n\t\tdev_err(qce->dev, \"Invalid numbers of src SG.\\n\");\n\t\treturn rctx->src_nents;\n\t}\n\n\tret = dma_map_sg(qce->dev, req->src, rctx->src_nents, DMA_TO_DEVICE);\n\tif (!ret)\n\t\treturn -EIO;\n\n\tsg_init_one(&rctx->result_sg, qce->dma.result_buf, QCE_RESULT_BUF_SZ);\n\n\tret = dma_map_sg(qce->dev, &rctx->result_sg, 1, DMA_FROM_DEVICE);\n\tif (!ret) {\n\t\tret = -EIO;\n\t\tgoto error_unmap_src;\n\t}\n\n\tret = qce_dma_prep_sgs(&qce->dma, req->src, rctx->src_nents,\n\t\t\t       &rctx->result_sg, 1, qce_ahash_done, async_req);\n\tif (ret)\n\t\tgoto error_unmap_dst;\n\n\tqce_dma_issue_pending(&qce->dma);\n\n\tret = qce_start(async_req, tmpl->crypto_alg_type);\n\tif (ret)\n\t\tgoto error_terminate;\n\n\treturn 0;\n\nerror_terminate:\n\tqce_dma_terminate_all(&qce->dma);\nerror_unmap_dst:\n\tdma_unmap_sg(qce->dev, &rctx->result_sg, 1, DMA_FROM_DEVICE);\nerror_unmap_src:\n\tdma_unmap_sg(qce->dev, req->src, rctx->src_nents, DMA_TO_DEVICE);\n\treturn ret;\n}\n\nstatic int qce_ahash_init(struct ahash_request *req)\n{\n\tstruct qce_sha_reqctx *rctx = ahash_request_ctx_dma(req);\n\tstruct qce_alg_template *tmpl = to_ahash_tmpl(req->base.tfm);\n\tconst u32 *std_iv = tmpl->std_iv;\n\n\tmemset(rctx, 0, sizeof(*rctx));\n\trctx->first_blk = true;\n\trctx->last_blk = false;\n\trctx->flags = tmpl->alg_flags;\n\tmemcpy(rctx->digest, std_iv, sizeof(rctx->digest));\n\n\treturn 0;\n}\n\nstatic int qce_ahash_export(struct ahash_request *req, void *out)\n{\n\tstruct qce_sha_reqctx *rctx = ahash_request_ctx_dma(req);\n\tstruct qce_sha_saved_state *export_state = out;\n\n\tmemcpy(export_state->pending_buf, rctx->buf, rctx->buflen);\n\tmemcpy(export_state->partial_digest, rctx->digest, sizeof(rctx->digest));\n\texport_state->byte_count[0] = rctx->byte_count[0];\n\texport_state->byte_count[1] = rctx->byte_count[1];\n\texport_state->pending_buflen = rctx->buflen;\n\texport_state->count = rctx->count;\n\texport_state->first_blk = rctx->first_blk;\n\texport_state->flags = rctx->flags;\n\n\treturn 0;\n}\n\nstatic int qce_ahash_import(struct ahash_request *req, const void *in)\n{\n\tstruct qce_sha_reqctx *rctx = ahash_request_ctx_dma(req);\n\tconst struct qce_sha_saved_state *import_state = in;\n\n\tmemset(rctx, 0, sizeof(*rctx));\n\trctx->count = import_state->count;\n\trctx->buflen = import_state->pending_buflen;\n\trctx->first_blk = import_state->first_blk;\n\trctx->flags = import_state->flags;\n\trctx->byte_count[0] = import_state->byte_count[0];\n\trctx->byte_count[1] = import_state->byte_count[1];\n\tmemcpy(rctx->buf, import_state->pending_buf, rctx->buflen);\n\tmemcpy(rctx->digest, import_state->partial_digest, sizeof(rctx->digest));\n\n\treturn 0;\n}\n\nstatic int qce_ahash_update(struct ahash_request *req)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct qce_sha_reqctx *rctx = ahash_request_ctx_dma(req);\n\tstruct qce_alg_template *tmpl = to_ahash_tmpl(req->base.tfm);\n\tstruct qce_device *qce = tmpl->qce;\n\tstruct scatterlist *sg_last, *sg;\n\tunsigned int total, len;\n\tunsigned int hash_later;\n\tunsigned int nbytes;\n\tunsigned int blocksize;\n\n\tblocksize = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));\n\trctx->count += req->nbytes;\n\n\t \n\ttotal = req->nbytes + rctx->buflen;\n\n\tif (total <= blocksize) {\n\t\tscatterwalk_map_and_copy(rctx->buf + rctx->buflen, req->src,\n\t\t\t\t\t 0, req->nbytes, 0);\n\t\trctx->buflen += req->nbytes;\n\t\treturn 0;\n\t}\n\n\t \n\trctx->src_orig = req->src;\n\trctx->nbytes_orig = req->nbytes;\n\n\t \n\tif (rctx->buflen)\n\t\tmemcpy(rctx->tmpbuf, rctx->buf, rctx->buflen);\n\n\t \n\thash_later = total % blocksize;\n\n\t \n\tif (!hash_later)\n\t\thash_later = blocksize;\n\n\tif (hash_later) {\n\t\tunsigned int src_offset = req->nbytes - hash_later;\n\t\tscatterwalk_map_and_copy(rctx->buf, req->src, src_offset,\n\t\t\t\t\t hash_later, 0);\n\t}\n\n\t \n\tnbytes = total - hash_later;\n\n\tlen = rctx->buflen;\n\tsg = sg_last = req->src;\n\n\twhile (len < nbytes && sg) {\n\t\tif (len + sg_dma_len(sg) > nbytes)\n\t\t\tbreak;\n\t\tlen += sg_dma_len(sg);\n\t\tsg_last = sg;\n\t\tsg = sg_next(sg);\n\t}\n\n\tif (!sg_last)\n\t\treturn -EINVAL;\n\n\tif (rctx->buflen) {\n\t\tsg_init_table(rctx->sg, 2);\n\t\tsg_set_buf(rctx->sg, rctx->tmpbuf, rctx->buflen);\n\t\tsg_chain(rctx->sg, 2, req->src);\n\t\treq->src = rctx->sg;\n\t}\n\n\treq->nbytes = nbytes;\n\trctx->buflen = hash_later;\n\n\treturn qce->async_req_enqueue(tmpl->qce, &req->base);\n}\n\nstatic int qce_ahash_final(struct ahash_request *req)\n{\n\tstruct qce_sha_reqctx *rctx = ahash_request_ctx_dma(req);\n\tstruct qce_alg_template *tmpl = to_ahash_tmpl(req->base.tfm);\n\tstruct qce_device *qce = tmpl->qce;\n\n\tif (!rctx->buflen) {\n\t\tif (tmpl->hash_zero)\n\t\t\tmemcpy(req->result, tmpl->hash_zero,\n\t\t\t\t\ttmpl->alg.ahash.halg.digestsize);\n\t\treturn 0;\n\t}\n\n\trctx->last_blk = true;\n\n\trctx->src_orig = req->src;\n\trctx->nbytes_orig = req->nbytes;\n\n\tmemcpy(rctx->tmpbuf, rctx->buf, rctx->buflen);\n\tsg_init_one(rctx->sg, rctx->tmpbuf, rctx->buflen);\n\n\treq->src = rctx->sg;\n\treq->nbytes = rctx->buflen;\n\n\treturn qce->async_req_enqueue(tmpl->qce, &req->base);\n}\n\nstatic int qce_ahash_digest(struct ahash_request *req)\n{\n\tstruct qce_sha_reqctx *rctx = ahash_request_ctx_dma(req);\n\tstruct qce_alg_template *tmpl = to_ahash_tmpl(req->base.tfm);\n\tstruct qce_device *qce = tmpl->qce;\n\tint ret;\n\n\tret = qce_ahash_init(req);\n\tif (ret)\n\t\treturn ret;\n\n\trctx->src_orig = req->src;\n\trctx->nbytes_orig = req->nbytes;\n\trctx->first_blk = true;\n\trctx->last_blk = true;\n\n\tif (!rctx->nbytes_orig) {\n\t\tif (tmpl->hash_zero)\n\t\t\tmemcpy(req->result, tmpl->hash_zero,\n\t\t\t\t\ttmpl->alg.ahash.halg.digestsize);\n\t\treturn 0;\n\t}\n\n\treturn qce->async_req_enqueue(tmpl->qce, &req->base);\n}\n\nstatic int qce_ahash_hmac_setkey(struct crypto_ahash *tfm, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\tunsigned int digestsize = crypto_ahash_digestsize(tfm);\n\tstruct qce_sha_ctx *ctx = crypto_tfm_ctx(&tfm->base);\n\tstruct crypto_wait wait;\n\tstruct ahash_request *req;\n\tstruct scatterlist sg;\n\tunsigned int blocksize;\n\tstruct crypto_ahash *ahash_tfm;\n\tu8 *buf;\n\tint ret;\n\tconst char *alg_name;\n\n\tblocksize = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));\n\tmemset(ctx->authkey, 0, sizeof(ctx->authkey));\n\n\tif (keylen <= blocksize) {\n\t\tmemcpy(ctx->authkey, key, keylen);\n\t\treturn 0;\n\t}\n\n\tif (digestsize == SHA1_DIGEST_SIZE)\n\t\talg_name = \"sha1-qce\";\n\telse if (digestsize == SHA256_DIGEST_SIZE)\n\t\talg_name = \"sha256-qce\";\n\telse\n\t\treturn -EINVAL;\n\n\tahash_tfm = crypto_alloc_ahash(alg_name, 0, 0);\n\tif (IS_ERR(ahash_tfm))\n\t\treturn PTR_ERR(ahash_tfm);\n\n\treq = ahash_request_alloc(ahash_tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_ahash;\n\t}\n\n\tcrypto_init_wait(&wait);\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t   crypto_req_done, &wait);\n\tcrypto_ahash_clear_flags(ahash_tfm, ~0);\n\n\tbuf = kzalloc(keylen + QCE_MAX_ALIGN_SIZE, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_req;\n\t}\n\n\tmemcpy(buf, key, keylen);\n\tsg_init_one(&sg, buf, keylen);\n\tahash_request_set_crypt(req, &sg, ctx->authkey, keylen);\n\n\tret = crypto_wait_req(crypto_ahash_digest(req), &wait);\n\n\tkfree(buf);\nerr_free_req:\n\tahash_request_free(req);\nerr_free_ahash:\n\tcrypto_free_ahash(ahash_tfm);\n\treturn ret;\n}\n\nstatic int qce_ahash_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct crypto_ahash *ahash = __crypto_ahash_cast(tfm);\n\tstruct qce_sha_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tcrypto_ahash_set_reqsize_dma(ahash, sizeof(struct qce_sha_reqctx));\n\tmemset(ctx, 0, sizeof(*ctx));\n\treturn 0;\n}\n\nstruct qce_ahash_def {\n\tunsigned long flags;\n\tconst char *name;\n\tconst char *drv_name;\n\tunsigned int digestsize;\n\tunsigned int blocksize;\n\tunsigned int statesize;\n\tconst u32 *std_iv;\n};\n\nstatic const struct qce_ahash_def ahash_def[] = {\n\t{\n\t\t.flags\t\t= QCE_HASH_SHA1,\n\t\t.name\t\t= \"sha1\",\n\t\t.drv_name\t= \"sha1-qce\",\n\t\t.digestsize\t= SHA1_DIGEST_SIZE,\n\t\t.blocksize\t= SHA1_BLOCK_SIZE,\n\t\t.statesize\t= sizeof(struct qce_sha_saved_state),\n\t\t.std_iv\t\t= std_iv_sha1,\n\t},\n\t{\n\t\t.flags\t\t= QCE_HASH_SHA256,\n\t\t.name\t\t= \"sha256\",\n\t\t.drv_name\t= \"sha256-qce\",\n\t\t.digestsize\t= SHA256_DIGEST_SIZE,\n\t\t.blocksize\t= SHA256_BLOCK_SIZE,\n\t\t.statesize\t= sizeof(struct qce_sha_saved_state),\n\t\t.std_iv\t\t= std_iv_sha256,\n\t},\n\t{\n\t\t.flags\t\t= QCE_HASH_SHA1_HMAC,\n\t\t.name\t\t= \"hmac(sha1)\",\n\t\t.drv_name\t= \"hmac-sha1-qce\",\n\t\t.digestsize\t= SHA1_DIGEST_SIZE,\n\t\t.blocksize\t= SHA1_BLOCK_SIZE,\n\t\t.statesize\t= sizeof(struct qce_sha_saved_state),\n\t\t.std_iv\t\t= std_iv_sha1,\n\t},\n\t{\n\t\t.flags\t\t= QCE_HASH_SHA256_HMAC,\n\t\t.name\t\t= \"hmac(sha256)\",\n\t\t.drv_name\t= \"hmac-sha256-qce\",\n\t\t.digestsize\t= SHA256_DIGEST_SIZE,\n\t\t.blocksize\t= SHA256_BLOCK_SIZE,\n\t\t.statesize\t= sizeof(struct qce_sha_saved_state),\n\t\t.std_iv\t\t= std_iv_sha256,\n\t},\n};\n\nstatic int qce_ahash_register_one(const struct qce_ahash_def *def,\n\t\t\t\t  struct qce_device *qce)\n{\n\tstruct qce_alg_template *tmpl;\n\tstruct ahash_alg *alg;\n\tstruct crypto_alg *base;\n\tint ret;\n\n\ttmpl = kzalloc(sizeof(*tmpl), GFP_KERNEL);\n\tif (!tmpl)\n\t\treturn -ENOMEM;\n\n\ttmpl->std_iv = def->std_iv;\n\n\talg = &tmpl->alg.ahash;\n\talg->init = qce_ahash_init;\n\talg->update = qce_ahash_update;\n\talg->final = qce_ahash_final;\n\talg->digest = qce_ahash_digest;\n\talg->export = qce_ahash_export;\n\talg->import = qce_ahash_import;\n\tif (IS_SHA_HMAC(def->flags))\n\t\talg->setkey = qce_ahash_hmac_setkey;\n\talg->halg.digestsize = def->digestsize;\n\talg->halg.statesize = def->statesize;\n\n\tif (IS_SHA1(def->flags))\n\t\ttmpl->hash_zero = sha1_zero_message_hash;\n\telse if (IS_SHA256(def->flags))\n\t\ttmpl->hash_zero = sha256_zero_message_hash;\n\n\tbase = &alg->halg.base;\n\tbase->cra_blocksize = def->blocksize;\n\tbase->cra_priority = 300;\n\tbase->cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_KERN_DRIVER_ONLY;\n\tbase->cra_ctxsize = sizeof(struct qce_sha_ctx);\n\tbase->cra_alignmask = 0;\n\tbase->cra_module = THIS_MODULE;\n\tbase->cra_init = qce_ahash_cra_init;\n\n\tsnprintf(base->cra_name, CRYPTO_MAX_ALG_NAME, \"%s\", def->name);\n\tsnprintf(base->cra_driver_name, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t def->drv_name);\n\n\tINIT_LIST_HEAD(&tmpl->entry);\n\ttmpl->crypto_alg_type = CRYPTO_ALG_TYPE_AHASH;\n\ttmpl->alg_flags = def->flags;\n\ttmpl->qce = qce;\n\n\tret = crypto_register_ahash(alg);\n\tif (ret) {\n\t\tdev_err(qce->dev, \"%s registration failed\\n\", base->cra_name);\n\t\tkfree(tmpl);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&tmpl->entry, &ahash_algs);\n\tdev_dbg(qce->dev, \"%s is registered\\n\", base->cra_name);\n\treturn 0;\n}\n\nstatic void qce_ahash_unregister(struct qce_device *qce)\n{\n\tstruct qce_alg_template *tmpl, *n;\n\n\tlist_for_each_entry_safe(tmpl, n, &ahash_algs, entry) {\n\t\tcrypto_unregister_ahash(&tmpl->alg.ahash);\n\t\tlist_del(&tmpl->entry);\n\t\tkfree(tmpl);\n\t}\n}\n\nstatic int qce_ahash_register(struct qce_device *qce)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ahash_def); i++) {\n\t\tret = qce_ahash_register_one(&ahash_def[i], qce);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tqce_ahash_unregister(qce);\n\treturn ret;\n}\n\nconst struct qce_algo_ops ahash_ops = {\n\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t.register_algs = qce_ahash_register,\n\t.unregister_algs = qce_ahash_unregister,\n\t.async_req_handle = qce_ahash_async_req_handle,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}