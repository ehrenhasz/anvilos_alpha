{
  "module_name": "cc_aead.c",
  "hash_id": "8ddbf0ddadddd84ca4a813e076599f999b554c406ae172e6c5df68f1107be270",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccree/cc_aead.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <crypto/algapi.h>\n#include <crypto/internal/aead.h>\n#include <crypto/authenc.h>\n#include <crypto/gcm.h>\n#include <linux/rtnetlink.h>\n#include <crypto/internal/des.h>\n#include \"cc_driver.h\"\n#include \"cc_buffer_mgr.h\"\n#include \"cc_aead.h\"\n#include \"cc_request_mgr.h\"\n#include \"cc_hash.h\"\n#include \"cc_sram_mgr.h\"\n\n#define template_aead\ttemplate_u.aead\n\n#define MAX_AEAD_SETKEY_SEQ 12\n#define MAX_AEAD_PROCESS_SEQ 23\n\n#define MAX_HMAC_DIGEST_SIZE (SHA256_DIGEST_SIZE)\n#define MAX_HMAC_BLOCK_SIZE (SHA256_BLOCK_SIZE)\n\n#define MAX_NONCE_SIZE CTR_RFC3686_NONCE_SIZE\n\nstruct cc_aead_handle {\n\tu32 sram_workspace_addr;\n\tstruct list_head aead_list;\n};\n\nstruct cc_hmac_s {\n\tu8 *padded_authkey;\n\tu8 *ipad_opad;  \n\tdma_addr_t padded_authkey_dma_addr;\n\tdma_addr_t ipad_opad_dma_addr;\n};\n\nstruct cc_xcbc_s {\n\tu8 *xcbc_keys;  \n\tdma_addr_t xcbc_keys_dma_addr;\n};\n\nstruct cc_aead_ctx {\n\tstruct cc_drvdata *drvdata;\n\tu8 ctr_nonce[MAX_NONCE_SIZE];  \n\tu8 *enckey;\n\tdma_addr_t enckey_dma_addr;\n\tunion {\n\t\tstruct cc_hmac_s hmac;\n\t\tstruct cc_xcbc_s xcbc;\n\t} auth_state;\n\tunsigned int enc_keylen;\n\tunsigned int auth_keylen;\n\tunsigned int authsize;  \n\tunsigned int hash_len;\n\tenum drv_cipher_mode cipher_mode;\n\tenum cc_flow_mode flow_mode;\n\tenum drv_hash_mode auth_mode;\n};\n\nstatic void cc_aead_exit(struct crypto_aead *tfm)\n{\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\n\tdev_dbg(dev, \"Clearing context @%p for %s\\n\", crypto_aead_ctx(tfm),\n\t\tcrypto_tfm_alg_name(&tfm->base));\n\n\t \n\tif (ctx->enckey) {\n\t\tdma_free_coherent(dev, AES_MAX_KEY_SIZE, ctx->enckey,\n\t\t\t\t  ctx->enckey_dma_addr);\n\t\tdev_dbg(dev, \"Freed enckey DMA buffer enckey_dma_addr=%pad\\n\",\n\t\t\t&ctx->enckey_dma_addr);\n\t\tctx->enckey_dma_addr = 0;\n\t\tctx->enckey = NULL;\n\t}\n\n\tif (ctx->auth_mode == DRV_HASH_XCBC_MAC) {  \n\t\tstruct cc_xcbc_s *xcbc = &ctx->auth_state.xcbc;\n\n\t\tif (xcbc->xcbc_keys) {\n\t\t\tdma_free_coherent(dev, CC_AES_128_BIT_KEY_SIZE * 3,\n\t\t\t\t\t  xcbc->xcbc_keys,\n\t\t\t\t\t  xcbc->xcbc_keys_dma_addr);\n\t\t}\n\t\tdev_dbg(dev, \"Freed xcbc_keys DMA buffer xcbc_keys_dma_addr=%pad\\n\",\n\t\t\t&xcbc->xcbc_keys_dma_addr);\n\t\txcbc->xcbc_keys_dma_addr = 0;\n\t\txcbc->xcbc_keys = NULL;\n\t} else if (ctx->auth_mode != DRV_HASH_NULL) {  \n\t\tstruct cc_hmac_s *hmac = &ctx->auth_state.hmac;\n\n\t\tif (hmac->ipad_opad) {\n\t\t\tdma_free_coherent(dev, 2 * MAX_HMAC_DIGEST_SIZE,\n\t\t\t\t\t  hmac->ipad_opad,\n\t\t\t\t\t  hmac->ipad_opad_dma_addr);\n\t\t\tdev_dbg(dev, \"Freed ipad_opad DMA buffer ipad_opad_dma_addr=%pad\\n\",\n\t\t\t\t&hmac->ipad_opad_dma_addr);\n\t\t\thmac->ipad_opad_dma_addr = 0;\n\t\t\thmac->ipad_opad = NULL;\n\t\t}\n\t\tif (hmac->padded_authkey) {\n\t\t\tdma_free_coherent(dev, MAX_HMAC_BLOCK_SIZE,\n\t\t\t\t\t  hmac->padded_authkey,\n\t\t\t\t\t  hmac->padded_authkey_dma_addr);\n\t\t\tdev_dbg(dev, \"Freed padded_authkey DMA buffer padded_authkey_dma_addr=%pad\\n\",\n\t\t\t\t&hmac->padded_authkey_dma_addr);\n\t\t\thmac->padded_authkey_dma_addr = 0;\n\t\t\thmac->padded_authkey = NULL;\n\t\t}\n\t}\n}\n\nstatic unsigned int cc_get_aead_hash_len(struct crypto_aead *tfm)\n{\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\n\treturn cc_get_default_hash_len(ctx->drvdata);\n}\n\nstatic int cc_aead_init(struct crypto_aead *tfm)\n{\n\tstruct aead_alg *alg = crypto_aead_alg(tfm);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct cc_crypto_alg *cc_alg =\n\t\t\tcontainer_of(alg, struct cc_crypto_alg, aead_alg);\n\tstruct device *dev = drvdata_to_dev(cc_alg->drvdata);\n\n\tdev_dbg(dev, \"Initializing context @%p for %s\\n\", ctx,\n\t\tcrypto_tfm_alg_name(&tfm->base));\n\n\t \n\tctx->cipher_mode = cc_alg->cipher_mode;\n\tctx->flow_mode = cc_alg->flow_mode;\n\tctx->auth_mode = cc_alg->auth_mode;\n\tctx->drvdata = cc_alg->drvdata;\n\tcrypto_aead_set_reqsize_dma(tfm, sizeof(struct aead_req_ctx));\n\n\t \n\tctx->enckey = dma_alloc_coherent(dev, AES_MAX_KEY_SIZE,\n\t\t\t\t\t &ctx->enckey_dma_addr, GFP_KERNEL);\n\tif (!ctx->enckey) {\n\t\tdev_err(dev, \"Failed allocating key buffer\\n\");\n\t\tgoto init_failed;\n\t}\n\tdev_dbg(dev, \"Allocated enckey buffer in context ctx->enckey=@%p\\n\",\n\t\tctx->enckey);\n\n\t \n\n\tif (ctx->auth_mode == DRV_HASH_XCBC_MAC) {  \n\t\tstruct cc_xcbc_s *xcbc = &ctx->auth_state.xcbc;\n\t\tconst unsigned int key_size = CC_AES_128_BIT_KEY_SIZE * 3;\n\n\t\t \n\t\t \n\t\txcbc->xcbc_keys = dma_alloc_coherent(dev, key_size,\n\t\t\t\t\t\t     &xcbc->xcbc_keys_dma_addr,\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!xcbc->xcbc_keys) {\n\t\t\tdev_err(dev, \"Failed allocating buffer for XCBC keys\\n\");\n\t\t\tgoto init_failed;\n\t\t}\n\t} else if (ctx->auth_mode != DRV_HASH_NULL) {  \n\t\tstruct cc_hmac_s *hmac = &ctx->auth_state.hmac;\n\t\tconst unsigned int digest_size = 2 * MAX_HMAC_DIGEST_SIZE;\n\t\tdma_addr_t *pkey_dma = &hmac->padded_authkey_dma_addr;\n\n\t\t \n\t\thmac->ipad_opad = dma_alloc_coherent(dev, digest_size,\n\t\t\t\t\t\t     &hmac->ipad_opad_dma_addr,\n\t\t\t\t\t\t     GFP_KERNEL);\n\n\t\tif (!hmac->ipad_opad) {\n\t\t\tdev_err(dev, \"Failed allocating IPAD/OPAD buffer\\n\");\n\t\t\tgoto init_failed;\n\t\t}\n\n\t\tdev_dbg(dev, \"Allocated authkey buffer in context ctx->authkey=@%p\\n\",\n\t\t\thmac->ipad_opad);\n\n\t\thmac->padded_authkey = dma_alloc_coherent(dev,\n\t\t\t\t\t\t\t  MAX_HMAC_BLOCK_SIZE,\n\t\t\t\t\t\t\t  pkey_dma,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\n\t\tif (!hmac->padded_authkey) {\n\t\t\tdev_err(dev, \"failed to allocate padded_authkey\\n\");\n\t\t\tgoto init_failed;\n\t\t}\n\t} else {\n\t\tctx->auth_state.hmac.ipad_opad = NULL;\n\t\tctx->auth_state.hmac.padded_authkey = NULL;\n\t}\n\tctx->hash_len = cc_get_aead_hash_len(tfm);\n\n\treturn 0;\n\ninit_failed:\n\tcc_aead_exit(tfm);\n\treturn -ENOMEM;\n}\n\nstatic void cc_aead_complete(struct device *dev, void *cc_req, int err)\n{\n\tstruct aead_request *areq = (struct aead_request *)cc_req;\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(areq);\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(cc_req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\n\t \n\tif (err == -EINPROGRESS)\n\t\tgoto done;\n\n\tcc_unmap_aead_request(dev, areq);\n\n\t \n\tareq->iv = areq_ctx->backup_iv;\n\n\tif (err)\n\t\tgoto done;\n\n\tif (areq_ctx->gen_ctx.op_type == DRV_CRYPTO_DIRECTION_DECRYPT) {\n\t\tif (memcmp(areq_ctx->mac_buf, areq_ctx->icv_virt_addr,\n\t\t\t   ctx->authsize) != 0) {\n\t\t\tdev_dbg(dev, \"Payload authentication failure, (auth-size=%d, cipher=%d)\\n\",\n\t\t\t\tctx->authsize, ctx->cipher_mode);\n\t\t\t \n\t\t\tsg_zero_buffer(areq->dst, sg_nents(areq->dst),\n\t\t\t\t       areq->cryptlen, areq->assoclen);\n\t\t\terr = -EBADMSG;\n\t\t}\n\t \n\t} else if (areq_ctx->is_icv_fragmented) {\n\t\tu32 skip = areq->cryptlen + areq_ctx->dst_offset;\n\n\t\tcc_copy_sg_portion(dev, areq_ctx->mac_buf, areq_ctx->dst_sgl,\n\t\t\t\t   skip, (skip + ctx->authsize),\n\t\t\t\t   CC_SG_FROM_BUF);\n\t}\ndone:\n\taead_request_complete(areq, err);\n}\n\nstatic unsigned int xcbc_setkey(struct cc_hw_desc *desc,\n\t\t\t\tstruct cc_aead_ctx *ctx)\n{\n\t \n\thw_desc_init(&desc[0]);\n\t \n\tset_din_type(&desc[0], DMA_DLLI,\n\t\t     ctx->auth_state.xcbc.xcbc_keys_dma_addr, ctx->auth_keylen,\n\t\t     NS_BIT);\n\tset_cipher_mode(&desc[0], DRV_CIPHER_ECB);\n\tset_cipher_config0(&desc[0], DRV_CRYPTO_DIRECTION_ENCRYPT);\n\tset_key_size_aes(&desc[0], ctx->auth_keylen);\n\tset_flow_mode(&desc[0], S_DIN_to_AES);\n\tset_setup_mode(&desc[0], SETUP_LOAD_KEY0);\n\n\thw_desc_init(&desc[1]);\n\tset_din_const(&desc[1], 0x01010101, CC_AES_128_BIT_KEY_SIZE);\n\tset_flow_mode(&desc[1], DIN_AES_DOUT);\n\tset_dout_dlli(&desc[1], ctx->auth_state.xcbc.xcbc_keys_dma_addr,\n\t\t      AES_KEYSIZE_128, NS_BIT, 0);\n\n\thw_desc_init(&desc[2]);\n\tset_din_const(&desc[2], 0x02020202, CC_AES_128_BIT_KEY_SIZE);\n\tset_flow_mode(&desc[2], DIN_AES_DOUT);\n\tset_dout_dlli(&desc[2], (ctx->auth_state.xcbc.xcbc_keys_dma_addr\n\t\t\t\t\t + AES_KEYSIZE_128),\n\t\t\t      AES_KEYSIZE_128, NS_BIT, 0);\n\n\thw_desc_init(&desc[3]);\n\tset_din_const(&desc[3], 0x03030303, CC_AES_128_BIT_KEY_SIZE);\n\tset_flow_mode(&desc[3], DIN_AES_DOUT);\n\tset_dout_dlli(&desc[3], (ctx->auth_state.xcbc.xcbc_keys_dma_addr\n\t\t\t\t\t  + 2 * AES_KEYSIZE_128),\n\t\t\t      AES_KEYSIZE_128, NS_BIT, 0);\n\n\treturn 4;\n}\n\nstatic unsigned int hmac_setkey(struct cc_hw_desc *desc,\n\t\t\t\tstruct cc_aead_ctx *ctx)\n{\n\tunsigned int hmac_pad_const[2] = { HMAC_IPAD_CONST, HMAC_OPAD_CONST };\n\tunsigned int digest_ofs = 0;\n\tunsigned int hash_mode = (ctx->auth_mode == DRV_HASH_SHA1) ?\n\t\t\tDRV_HASH_HW_SHA1 : DRV_HASH_HW_SHA256;\n\tunsigned int digest_size = (ctx->auth_mode == DRV_HASH_SHA1) ?\n\t\t\tCC_SHA1_DIGEST_SIZE : CC_SHA256_DIGEST_SIZE;\n\tstruct cc_hmac_s *hmac = &ctx->auth_state.hmac;\n\n\tunsigned int idx = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\t \n\t\thw_desc_init(&desc[idx]);\n\t\tset_cipher_mode(&desc[idx], hash_mode);\n\t\tset_din_sram(&desc[idx],\n\t\t\t     cc_larval_digest_addr(ctx->drvdata,\n\t\t\t\t\t\t   ctx->auth_mode),\n\t\t\t     digest_size);\n\t\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\t\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE0);\n\t\tidx++;\n\n\t\t \n\t\thw_desc_init(&desc[idx]);\n\t\tset_cipher_mode(&desc[idx], hash_mode);\n\t\tset_din_const(&desc[idx], 0, ctx->hash_len);\n\t\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\t\tset_setup_mode(&desc[idx], SETUP_LOAD_KEY0);\n\t\tidx++;\n\n\t\t \n\t\thw_desc_init(&desc[idx]);\n\t\tset_xor_val(&desc[idx], hmac_pad_const[i]);\n\t\tset_cipher_mode(&desc[idx], hash_mode);\n\t\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\t\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE1);\n\t\tidx++;\n\n\t\t \n\t\thw_desc_init(&desc[idx]);\n\t\tset_din_type(&desc[idx], DMA_DLLI,\n\t\t\t     hmac->padded_authkey_dma_addr,\n\t\t\t     SHA256_BLOCK_SIZE, NS_BIT);\n\t\tset_cipher_mode(&desc[idx], hash_mode);\n\t\tset_xor_active(&desc[idx]);\n\t\tset_flow_mode(&desc[idx], DIN_HASH);\n\t\tidx++;\n\n\t\t \n\t\thw_desc_init(&desc[idx]);\n\t\tset_cipher_mode(&desc[idx], hash_mode);\n\t\tset_dout_dlli(&desc[idx],\n\t\t\t      (hmac->ipad_opad_dma_addr + digest_ofs),\n\t\t\t      digest_size, NS_BIT, 0);\n\t\tset_flow_mode(&desc[idx], S_HASH_to_DOUT);\n\t\tset_setup_mode(&desc[idx], SETUP_WRITE_STATE0);\n\t\tset_cipher_config1(&desc[idx], HASH_PADDING_DISABLED);\n\t\tidx++;\n\n\t\tdigest_ofs += digest_size;\n\t}\n\n\treturn idx;\n}\n\nstatic int validate_keys_sizes(struct cc_aead_ctx *ctx)\n{\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\n\tdev_dbg(dev, \"enc_keylen=%u  authkeylen=%u\\n\",\n\t\tctx->enc_keylen, ctx->auth_keylen);\n\n\tswitch (ctx->auth_mode) {\n\tcase DRV_HASH_SHA1:\n\tcase DRV_HASH_SHA256:\n\t\tbreak;\n\tcase DRV_HASH_XCBC_MAC:\n\t\tif (ctx->auth_keylen != AES_KEYSIZE_128 &&\n\t\t    ctx->auth_keylen != AES_KEYSIZE_192 &&\n\t\t    ctx->auth_keylen != AES_KEYSIZE_256)\n\t\t\treturn -ENOTSUPP;\n\t\tbreak;\n\tcase DRV_HASH_NULL:  \n\t\tif (ctx->auth_keylen > 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Invalid auth_mode=%d\\n\", ctx->auth_mode);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (ctx->flow_mode == S_DIN_to_DES) {\n\t\tif (ctx->enc_keylen != DES3_EDE_KEY_SIZE) {\n\t\t\tdev_dbg(dev, \"Invalid cipher(3DES) key size: %u\\n\",\n\t\t\t\tctx->enc_keylen);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {  \n\t\tif (ctx->enc_keylen != AES_KEYSIZE_128 &&\n\t\t    ctx->enc_keylen != AES_KEYSIZE_192 &&\n\t\t    ctx->enc_keylen != AES_KEYSIZE_256) {\n\t\t\tdev_dbg(dev, \"Invalid cipher(AES) key size: %u\\n\",\n\t\t\t\tctx->enc_keylen);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;  \n}\n\n \nstatic int cc_get_plain_hmac_key(struct crypto_aead *tfm, const u8 *authkey,\n\t\t\t\t unsigned int keylen)\n{\n\tdma_addr_t key_dma_addr = 0;\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\tu32 larval_addr;\n\tstruct cc_crypto_req cc_req = {};\n\tunsigned int blocksize;\n\tunsigned int digestsize;\n\tunsigned int hashmode;\n\tunsigned int idx = 0;\n\tint rc = 0;\n\tu8 *key = NULL;\n\tstruct cc_hw_desc desc[MAX_AEAD_SETKEY_SEQ];\n\tdma_addr_t padded_authkey_dma_addr =\n\t\tctx->auth_state.hmac.padded_authkey_dma_addr;\n\n\tswitch (ctx->auth_mode) {  \n\tcase DRV_HASH_SHA1:\n\t\tblocksize = SHA1_BLOCK_SIZE;\n\t\tdigestsize = SHA1_DIGEST_SIZE;\n\t\thashmode = DRV_HASH_HW_SHA1;\n\t\tbreak;\n\tcase DRV_HASH_SHA256:\n\tdefault:\n\t\tblocksize = SHA256_BLOCK_SIZE;\n\t\tdigestsize = SHA256_DIGEST_SIZE;\n\t\thashmode = DRV_HASH_HW_SHA256;\n\t}\n\n\tif (keylen != 0) {\n\n\t\tkey = kmemdup(authkey, keylen, GFP_KERNEL);\n\t\tif (!key)\n\t\t\treturn -ENOMEM;\n\n\t\tkey_dma_addr = dma_map_single(dev, key, keylen, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, key_dma_addr)) {\n\t\t\tdev_err(dev, \"Mapping key va=0x%p len=%u for DMA failed\\n\",\n\t\t\t\tkey, keylen);\n\t\t\tkfree_sensitive(key);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (keylen > blocksize) {\n\t\t\t \n\t\t\thw_desc_init(&desc[idx]);\n\t\t\tset_cipher_mode(&desc[idx], hashmode);\n\t\t\tlarval_addr = cc_larval_digest_addr(ctx->drvdata,\n\t\t\t\t\t\t\t    ctx->auth_mode);\n\t\t\tset_din_sram(&desc[idx], larval_addr, digestsize);\n\t\t\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\t\t\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE0);\n\t\t\tidx++;\n\n\t\t\t \n\t\t\thw_desc_init(&desc[idx]);\n\t\t\tset_cipher_mode(&desc[idx], hashmode);\n\t\t\tset_din_const(&desc[idx], 0, ctx->hash_len);\n\t\t\tset_cipher_config1(&desc[idx], HASH_PADDING_ENABLED);\n\t\t\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\t\t\tset_setup_mode(&desc[idx], SETUP_LOAD_KEY0);\n\t\t\tidx++;\n\n\t\t\thw_desc_init(&desc[idx]);\n\t\t\tset_din_type(&desc[idx], DMA_DLLI,\n\t\t\t\t     key_dma_addr, keylen, NS_BIT);\n\t\t\tset_flow_mode(&desc[idx], DIN_HASH);\n\t\t\tidx++;\n\n\t\t\t \n\t\t\thw_desc_init(&desc[idx]);\n\t\t\tset_cipher_mode(&desc[idx], hashmode);\n\t\t\tset_dout_dlli(&desc[idx], padded_authkey_dma_addr,\n\t\t\t\t      digestsize, NS_BIT, 0);\n\t\t\tset_flow_mode(&desc[idx], S_HASH_to_DOUT);\n\t\t\tset_setup_mode(&desc[idx], SETUP_WRITE_STATE0);\n\t\t\tset_cipher_config1(&desc[idx], HASH_PADDING_DISABLED);\n\t\t\tset_cipher_config0(&desc[idx],\n\t\t\t\t\t   HASH_DIGEST_RESULT_LITTLE_ENDIAN);\n\t\t\tidx++;\n\n\t\t\thw_desc_init(&desc[idx]);\n\t\t\tset_din_const(&desc[idx], 0, (blocksize - digestsize));\n\t\t\tset_flow_mode(&desc[idx], BYPASS);\n\t\t\tset_dout_dlli(&desc[idx], (padded_authkey_dma_addr +\n\t\t\t\t      digestsize), (blocksize - digestsize),\n\t\t\t\t      NS_BIT, 0);\n\t\t\tidx++;\n\t\t} else {\n\t\t\thw_desc_init(&desc[idx]);\n\t\t\tset_din_type(&desc[idx], DMA_DLLI, key_dma_addr,\n\t\t\t\t     keylen, NS_BIT);\n\t\t\tset_flow_mode(&desc[idx], BYPASS);\n\t\t\tset_dout_dlli(&desc[idx], padded_authkey_dma_addr,\n\t\t\t\t      keylen, NS_BIT, 0);\n\t\t\tidx++;\n\n\t\t\tif ((blocksize - keylen) != 0) {\n\t\t\t\thw_desc_init(&desc[idx]);\n\t\t\t\tset_din_const(&desc[idx], 0,\n\t\t\t\t\t      (blocksize - keylen));\n\t\t\t\tset_flow_mode(&desc[idx], BYPASS);\n\t\t\t\tset_dout_dlli(&desc[idx],\n\t\t\t\t\t      (padded_authkey_dma_addr +\n\t\t\t\t\t       keylen),\n\t\t\t\t\t      (blocksize - keylen), NS_BIT, 0);\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\thw_desc_init(&desc[idx]);\n\t\tset_din_const(&desc[idx], 0, (blocksize - keylen));\n\t\tset_flow_mode(&desc[idx], BYPASS);\n\t\tset_dout_dlli(&desc[idx], padded_authkey_dma_addr,\n\t\t\t      blocksize, NS_BIT, 0);\n\t\tidx++;\n\t}\n\n\trc = cc_send_sync_request(ctx->drvdata, &cc_req, desc, idx);\n\tif (rc)\n\t\tdev_err(dev, \"send_request() failed (rc=%d)\\n\", rc);\n\n\tif (key_dma_addr)\n\t\tdma_unmap_single(dev, key_dma_addr, keylen, DMA_TO_DEVICE);\n\n\tkfree_sensitive(key);\n\n\treturn rc;\n}\n\nstatic int cc_aead_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t  unsigned int keylen)\n{\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct cc_crypto_req cc_req = {};\n\tstruct cc_hw_desc desc[MAX_AEAD_SETKEY_SEQ];\n\tunsigned int seq_len = 0;\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\tconst u8 *enckey, *authkey;\n\tint rc;\n\n\tdev_dbg(dev, \"Setting key in context @%p for %s. key=%p keylen=%u\\n\",\n\t\tctx, crypto_tfm_alg_name(crypto_aead_tfm(tfm)), key, keylen);\n\n\t \n\n\tif (ctx->auth_mode != DRV_HASH_NULL) {  \n\t\tstruct crypto_authenc_keys keys;\n\n\t\trc = crypto_authenc_extractkeys(&keys, key, keylen);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tenckey = keys.enckey;\n\t\tauthkey = keys.authkey;\n\t\tctx->enc_keylen = keys.enckeylen;\n\t\tctx->auth_keylen = keys.authkeylen;\n\n\t\tif (ctx->cipher_mode == DRV_CIPHER_CTR) {\n\t\t\t \n\t\t\tif (ctx->enc_keylen <\n\t\t\t    (AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE))\n\t\t\t\treturn -EINVAL;\n\t\t\t \n\t\t\tmemcpy(ctx->ctr_nonce, enckey + ctx->enc_keylen -\n\t\t\t       CTR_RFC3686_NONCE_SIZE, CTR_RFC3686_NONCE_SIZE);\n\t\t\t \n\t\t\tctx->enc_keylen -= CTR_RFC3686_NONCE_SIZE;\n\t\t}\n\t} else {  \n\t\tenckey = key;\n\t\tauthkey = NULL;\n\t\tctx->enc_keylen = keylen;\n\t\tctx->auth_keylen = 0;\n\t}\n\n\trc = validate_keys_sizes(ctx);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\n\t \n\tmemcpy(ctx->enckey, enckey, ctx->enc_keylen);\n\tif (ctx->enc_keylen == 24)\n\t\tmemset(ctx->enckey + 24, 0, CC_AES_KEY_SIZE_MAX - 24);\n\tif (ctx->auth_mode == DRV_HASH_XCBC_MAC) {\n\t\tmemcpy(ctx->auth_state.xcbc.xcbc_keys, authkey,\n\t\t       ctx->auth_keylen);\n\t} else if (ctx->auth_mode != DRV_HASH_NULL) {  \n\t\trc = cc_get_plain_hmac_key(tfm, authkey, ctx->auth_keylen);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\n\tswitch (ctx->auth_mode) {\n\tcase DRV_HASH_SHA1:\n\tcase DRV_HASH_SHA256:\n\t\tseq_len = hmac_setkey(desc, ctx);\n\t\tbreak;\n\tcase DRV_HASH_XCBC_MAC:\n\t\tseq_len = xcbc_setkey(desc, ctx);\n\t\tbreak;\n\tcase DRV_HASH_NULL:  \n\t\tbreak;  \n\tdefault:\n\t\tdev_err(dev, \"Unsupported authenc (%d)\\n\", ctx->auth_mode);\n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\n\tif (seq_len > 0) {  \n\t\trc = cc_send_sync_request(ctx->drvdata, &cc_req, desc, seq_len);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"send_request() failed (rc=%d)\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t \n\treturn rc;\n}\n\nstatic int cc_des3_aead_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t\t       unsigned int keylen)\n{\n\tstruct crypto_authenc_keys keys;\n\tint err;\n\n\terr = crypto_authenc_extractkeys(&keys, key, keylen);\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = verify_aead_des3_key(aead, keys.enckey, keys.enckeylen) ?:\n\t      cc_aead_setkey(aead, key, keylen);\n\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn err;\n}\n\nstatic int cc_rfc4309_ccm_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tif (keylen < 3)\n\t\treturn -EINVAL;\n\n\tkeylen -= 3;\n\tmemcpy(ctx->ctr_nonce, key + keylen, 3);\n\n\treturn cc_aead_setkey(tfm, key, keylen);\n}\n\nstatic int cc_aead_setauthsize(struct crypto_aead *authenc,\n\t\t\t       unsigned int authsize)\n{\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\n\t \n\tif (authsize == 0 ||\n\t    authsize > crypto_aead_maxauthsize(authenc)) {\n\t\treturn -ENOTSUPP;\n\t}\n\n\tctx->authsize = authsize;\n\tdev_dbg(dev, \"authlen=%d\\n\", ctx->authsize);\n\n\treturn 0;\n}\n\nstatic int cc_rfc4309_ccm_setauthsize(struct crypto_aead *authenc,\n\t\t\t\t      unsigned int authsize)\n{\n\tswitch (authsize) {\n\tcase 8:\n\tcase 12:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn cc_aead_setauthsize(authenc, authsize);\n}\n\nstatic int cc_ccm_setauthsize(struct crypto_aead *authenc,\n\t\t\t      unsigned int authsize)\n{\n\tswitch (authsize) {\n\tcase 4:\n\tcase 6:\n\tcase 8:\n\tcase 10:\n\tcase 12:\n\tcase 14:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn cc_aead_setauthsize(authenc, authsize);\n}\n\nstatic void cc_set_assoc_desc(struct aead_request *areq, unsigned int flow_mode,\n\t\t\t      struct cc_hw_desc desc[], unsigned int *seq_size)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(areq);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(areq);\n\tenum cc_req_dma_buf_type assoc_dma_type = areq_ctx->assoc_buff_type;\n\tunsigned int idx = *seq_size;\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\n\tswitch (assoc_dma_type) {\n\tcase CC_DMA_BUF_DLLI:\n\t\tdev_dbg(dev, \"ASSOC buffer type DLLI\\n\");\n\t\thw_desc_init(&desc[idx]);\n\t\tset_din_type(&desc[idx], DMA_DLLI, sg_dma_address(areq->src),\n\t\t\t     areq_ctx->assoclen, NS_BIT);\n\t\tset_flow_mode(&desc[idx], flow_mode);\n\t\tif (ctx->auth_mode == DRV_HASH_XCBC_MAC &&\n\t\t    areq_ctx->cryptlen > 0)\n\t\t\tset_din_not_last_indication(&desc[idx]);\n\t\tbreak;\n\tcase CC_DMA_BUF_MLLI:\n\t\tdev_dbg(dev, \"ASSOC buffer type MLLI\\n\");\n\t\thw_desc_init(&desc[idx]);\n\t\tset_din_type(&desc[idx], DMA_MLLI, areq_ctx->assoc.sram_addr,\n\t\t\t     areq_ctx->assoc.mlli_nents, NS_BIT);\n\t\tset_flow_mode(&desc[idx], flow_mode);\n\t\tif (ctx->auth_mode == DRV_HASH_XCBC_MAC &&\n\t\t    areq_ctx->cryptlen > 0)\n\t\t\tset_din_not_last_indication(&desc[idx]);\n\t\tbreak;\n\tcase CC_DMA_BUF_NULL:\n\tdefault:\n\t\tdev_err(dev, \"Invalid ASSOC buffer type\\n\");\n\t}\n\n\t*seq_size = (++idx);\n}\n\nstatic void cc_proc_authen_desc(struct aead_request *areq,\n\t\t\t\tunsigned int flow_mode,\n\t\t\t\tstruct cc_hw_desc desc[],\n\t\t\t\tunsigned int *seq_size, int direct)\n{\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(areq);\n\tenum cc_req_dma_buf_type data_dma_type = areq_ctx->data_buff_type;\n\tunsigned int idx = *seq_size;\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(areq);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\n\tswitch (data_dma_type) {\n\tcase CC_DMA_BUF_DLLI:\n\t{\n\t\tstruct scatterlist *cipher =\n\t\t\t(direct == DRV_CRYPTO_DIRECTION_ENCRYPT) ?\n\t\t\tareq_ctx->dst_sgl : areq_ctx->src_sgl;\n\n\t\tunsigned int offset =\n\t\t\t(direct == DRV_CRYPTO_DIRECTION_ENCRYPT) ?\n\t\t\tareq_ctx->dst_offset : areq_ctx->src_offset;\n\t\tdev_dbg(dev, \"AUTHENC: SRC/DST buffer type DLLI\\n\");\n\t\thw_desc_init(&desc[idx]);\n\t\tset_din_type(&desc[idx], DMA_DLLI,\n\t\t\t     (sg_dma_address(cipher) + offset),\n\t\t\t     areq_ctx->cryptlen, NS_BIT);\n\t\tset_flow_mode(&desc[idx], flow_mode);\n\t\tbreak;\n\t}\n\tcase CC_DMA_BUF_MLLI:\n\t{\n\t\t \n\t\tu32 mlli_addr = areq_ctx->assoc.sram_addr;\n\t\tu32 mlli_nents = areq_ctx->assoc.mlli_nents;\n\n\t\tif (areq_ctx->is_single_pass) {\n\t\t\tif (direct == DRV_CRYPTO_DIRECTION_ENCRYPT) {\n\t\t\t\tmlli_addr = areq_ctx->dst.sram_addr;\n\t\t\t\tmlli_nents = areq_ctx->dst.mlli_nents;\n\t\t\t} else {\n\t\t\t\tmlli_addr = areq_ctx->src.sram_addr;\n\t\t\t\tmlli_nents = areq_ctx->src.mlli_nents;\n\t\t\t}\n\t\t}\n\n\t\tdev_dbg(dev, \"AUTHENC: SRC/DST buffer type MLLI\\n\");\n\t\thw_desc_init(&desc[idx]);\n\t\tset_din_type(&desc[idx], DMA_MLLI, mlli_addr, mlli_nents,\n\t\t\t     NS_BIT);\n\t\tset_flow_mode(&desc[idx], flow_mode);\n\t\tbreak;\n\t}\n\tcase CC_DMA_BUF_NULL:\n\tdefault:\n\t\tdev_err(dev, \"AUTHENC: Invalid SRC/DST buffer type\\n\");\n\t}\n\n\t*seq_size = (++idx);\n}\n\nstatic void cc_proc_cipher_desc(struct aead_request *areq,\n\t\t\t\tunsigned int flow_mode,\n\t\t\t\tstruct cc_hw_desc desc[],\n\t\t\t\tunsigned int *seq_size)\n{\n\tunsigned int idx = *seq_size;\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(areq);\n\tenum cc_req_dma_buf_type data_dma_type = areq_ctx->data_buff_type;\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(areq);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\n\tif (areq_ctx->cryptlen == 0)\n\t\treturn;  \n\n\tswitch (data_dma_type) {\n\tcase CC_DMA_BUF_DLLI:\n\t\tdev_dbg(dev, \"CIPHER: SRC/DST buffer type DLLI\\n\");\n\t\thw_desc_init(&desc[idx]);\n\t\tset_din_type(&desc[idx], DMA_DLLI,\n\t\t\t     (sg_dma_address(areq_ctx->src_sgl) +\n\t\t\t      areq_ctx->src_offset), areq_ctx->cryptlen,\n\t\t\t      NS_BIT);\n\t\tset_dout_dlli(&desc[idx],\n\t\t\t      (sg_dma_address(areq_ctx->dst_sgl) +\n\t\t\t       areq_ctx->dst_offset),\n\t\t\t      areq_ctx->cryptlen, NS_BIT, 0);\n\t\tset_flow_mode(&desc[idx], flow_mode);\n\t\tbreak;\n\tcase CC_DMA_BUF_MLLI:\n\t\tdev_dbg(dev, \"CIPHER: SRC/DST buffer type MLLI\\n\");\n\t\thw_desc_init(&desc[idx]);\n\t\tset_din_type(&desc[idx], DMA_MLLI, areq_ctx->src.sram_addr,\n\t\t\t     areq_ctx->src.mlli_nents, NS_BIT);\n\t\tset_dout_mlli(&desc[idx], areq_ctx->dst.sram_addr,\n\t\t\t      areq_ctx->dst.mlli_nents, NS_BIT, 0);\n\t\tset_flow_mode(&desc[idx], flow_mode);\n\t\tbreak;\n\tcase CC_DMA_BUF_NULL:\n\tdefault:\n\t\tdev_err(dev, \"CIPHER: Invalid SRC/DST buffer type\\n\");\n\t}\n\n\t*seq_size = (++idx);\n}\n\nstatic void cc_proc_digest_desc(struct aead_request *req,\n\t\t\t\tstruct cc_hw_desc desc[],\n\t\t\t\tunsigned int *seq_size)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_req_ctx *req_ctx = aead_request_ctx_dma(req);\n\tunsigned int idx = *seq_size;\n\tunsigned int hash_mode = (ctx->auth_mode == DRV_HASH_SHA1) ?\n\t\t\t\tDRV_HASH_HW_SHA1 : DRV_HASH_HW_SHA256;\n\tint direct = req_ctx->gen_ctx.op_type;\n\n\t \n\tif (direct == DRV_CRYPTO_DIRECTION_ENCRYPT) {\n\t\thw_desc_init(&desc[idx]);\n\t\tset_flow_mode(&desc[idx], S_HASH_to_DOUT);\n\t\tset_setup_mode(&desc[idx], SETUP_WRITE_STATE0);\n\t\tset_dout_dlli(&desc[idx], req_ctx->icv_dma_addr, ctx->authsize,\n\t\t\t      NS_BIT, 1);\n\t\tset_queue_last_ind(ctx->drvdata, &desc[idx]);\n\t\tif (ctx->auth_mode == DRV_HASH_XCBC_MAC) {\n\t\t\tset_aes_not_hash_mode(&desc[idx]);\n\t\t\tset_cipher_mode(&desc[idx], DRV_CIPHER_XCBC_MAC);\n\t\t} else {\n\t\t\tset_cipher_config0(&desc[idx],\n\t\t\t\t\t   HASH_DIGEST_RESULT_LITTLE_ENDIAN);\n\t\t\tset_cipher_mode(&desc[idx], hash_mode);\n\t\t}\n\t} else {  \n\t\t \n\t\thw_desc_init(&desc[idx]);\n\t\tset_setup_mode(&desc[idx], SETUP_WRITE_STATE0);\n\t\tset_flow_mode(&desc[idx], S_HASH_to_DOUT);\n\t\tset_dout_dlli(&desc[idx], req_ctx->mac_buf_dma_addr,\n\t\t\t      ctx->authsize, NS_BIT, 1);\n\t\tset_queue_last_ind(ctx->drvdata, &desc[idx]);\n\t\tset_cipher_config0(&desc[idx],\n\t\t\t\t   HASH_DIGEST_RESULT_LITTLE_ENDIAN);\n\t\tset_cipher_config1(&desc[idx], HASH_PADDING_DISABLED);\n\t\tif (ctx->auth_mode == DRV_HASH_XCBC_MAC) {\n\t\t\tset_cipher_mode(&desc[idx], DRV_CIPHER_XCBC_MAC);\n\t\t\tset_aes_not_hash_mode(&desc[idx]);\n\t\t} else {\n\t\t\tset_cipher_mode(&desc[idx], hash_mode);\n\t\t}\n\t}\n\n\t*seq_size = (++idx);\n}\n\nstatic void cc_set_cipher_desc(struct aead_request *req,\n\t\t\t       struct cc_hw_desc desc[],\n\t\t\t       unsigned int *seq_size)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_req_ctx *req_ctx = aead_request_ctx_dma(req);\n\tunsigned int hw_iv_size = req_ctx->hw_iv_size;\n\tunsigned int idx = *seq_size;\n\tint direct = req_ctx->gen_ctx.op_type;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_config0(&desc[idx], direct);\n\tset_flow_mode(&desc[idx], ctx->flow_mode);\n\tset_din_type(&desc[idx], DMA_DLLI, req_ctx->gen_ctx.iv_dma_addr,\n\t\t     hw_iv_size, NS_BIT);\n\tif (ctx->cipher_mode == DRV_CIPHER_CTR)\n\t\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE1);\n\telse\n\t\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE0);\n\tset_cipher_mode(&desc[idx], ctx->cipher_mode);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_config0(&desc[idx], direct);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_KEY0);\n\tset_flow_mode(&desc[idx], ctx->flow_mode);\n\tif (ctx->flow_mode == S_DIN_to_AES) {\n\t\tset_din_type(&desc[idx], DMA_DLLI, ctx->enckey_dma_addr,\n\t\t\t     ((ctx->enc_keylen == 24) ? CC_AES_KEY_SIZE_MAX :\n\t\t\t      ctx->enc_keylen), NS_BIT);\n\t\tset_key_size_aes(&desc[idx], ctx->enc_keylen);\n\t} else {\n\t\tset_din_type(&desc[idx], DMA_DLLI, ctx->enckey_dma_addr,\n\t\t\t     ctx->enc_keylen, NS_BIT);\n\t\tset_key_size_des(&desc[idx], ctx->enc_keylen);\n\t}\n\tset_cipher_mode(&desc[idx], ctx->cipher_mode);\n\tidx++;\n\n\t*seq_size = idx;\n}\n\nstatic void cc_proc_cipher(struct aead_request *req, struct cc_hw_desc desc[],\n\t\t\t   unsigned int *seq_size, unsigned int data_flow_mode)\n{\n\tstruct aead_req_ctx *req_ctx = aead_request_ctx_dma(req);\n\tint direct = req_ctx->gen_ctx.op_type;\n\tunsigned int idx = *seq_size;\n\n\tif (req_ctx->cryptlen == 0)\n\t\treturn;  \n\n\tcc_set_cipher_desc(req, desc, &idx);\n\tcc_proc_cipher_desc(req, data_flow_mode, desc, &idx);\n\tif (direct == DRV_CRYPTO_DIRECTION_ENCRYPT) {\n\t\t \n\t\thw_desc_init(&desc[idx]);\n\t\tset_din_no_dma(&desc[idx], 0, 0xfffff0);\n\t\tset_dout_no_dma(&desc[idx], 0, 0, 1);\n\t\tidx++;\n\t}\n\n\t*seq_size = idx;\n}\n\nstatic void cc_set_hmac_desc(struct aead_request *req, struct cc_hw_desc desc[],\n\t\t\t     unsigned int *seq_size)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tunsigned int hash_mode = (ctx->auth_mode == DRV_HASH_SHA1) ?\n\t\t\t\tDRV_HASH_HW_SHA1 : DRV_HASH_HW_SHA256;\n\tunsigned int digest_size = (ctx->auth_mode == DRV_HASH_SHA1) ?\n\t\t\t\tCC_SHA1_DIGEST_SIZE : CC_SHA256_DIGEST_SIZE;\n\tunsigned int idx = *seq_size;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], hash_mode);\n\tset_din_type(&desc[idx], DMA_DLLI,\n\t\t     ctx->auth_state.hmac.ipad_opad_dma_addr, digest_size,\n\t\t     NS_BIT);\n\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE0);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], hash_mode);\n\tset_din_sram(&desc[idx], cc_digest_len_addr(ctx->drvdata, hash_mode),\n\t\t     ctx->hash_len);\n\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_KEY0);\n\tidx++;\n\n\t*seq_size = idx;\n}\n\nstatic void cc_set_xcbc_desc(struct aead_request *req, struct cc_hw_desc desc[],\n\t\t\t     unsigned int *seq_size)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tunsigned int idx = *seq_size;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_din_const(&desc[idx], 0, CC_AES_BLOCK_SIZE);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE0);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_XCBC_MAC);\n\tset_cipher_config0(&desc[idx], DESC_DIRECTION_ENCRYPT_ENCRYPT);\n\tset_key_size_aes(&desc[idx], CC_AES_128_BIT_KEY_SIZE);\n\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\tset_aes_not_hash_mode(&desc[idx]);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_din_type(&desc[idx], DMA_DLLI,\n\t\t     ctx->auth_state.xcbc.xcbc_keys_dma_addr,\n\t\t     AES_KEYSIZE_128, NS_BIT);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_KEY0);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_XCBC_MAC);\n\tset_cipher_config0(&desc[idx], DESC_DIRECTION_ENCRYPT_ENCRYPT);\n\tset_key_size_aes(&desc[idx], CC_AES_128_BIT_KEY_SIZE);\n\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\tset_aes_not_hash_mode(&desc[idx]);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_din_type(&desc[idx], DMA_DLLI,\n\t\t     (ctx->auth_state.xcbc.xcbc_keys_dma_addr +\n\t\t      AES_KEYSIZE_128), AES_KEYSIZE_128, NS_BIT);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE1);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_XCBC_MAC);\n\tset_cipher_config0(&desc[idx], DESC_DIRECTION_ENCRYPT_ENCRYPT);\n\tset_key_size_aes(&desc[idx], CC_AES_128_BIT_KEY_SIZE);\n\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\tset_aes_not_hash_mode(&desc[idx]);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_din_type(&desc[idx], DMA_DLLI,\n\t\t     (ctx->auth_state.xcbc.xcbc_keys_dma_addr +\n\t\t      2 * AES_KEYSIZE_128), AES_KEYSIZE_128, NS_BIT);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE2);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_XCBC_MAC);\n\tset_cipher_config0(&desc[idx], DESC_DIRECTION_ENCRYPT_ENCRYPT);\n\tset_key_size_aes(&desc[idx], CC_AES_128_BIT_KEY_SIZE);\n\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\tset_aes_not_hash_mode(&desc[idx]);\n\tidx++;\n\n\t*seq_size = idx;\n}\n\nstatic void cc_proc_header_desc(struct aead_request *req,\n\t\t\t\tstruct cc_hw_desc desc[],\n\t\t\t\tunsigned int *seq_size)\n{\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(req);\n\tunsigned int idx = *seq_size;\n\n\t \n\tif (areq_ctx->assoclen > 0)\n\t\tcc_set_assoc_desc(req, DIN_HASH, desc, &idx);\n\n\t \n\t*seq_size = idx;\n}\n\nstatic void cc_proc_scheme_desc(struct aead_request *req,\n\t\t\t\tstruct cc_hw_desc desc[],\n\t\t\t\tunsigned int *seq_size)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct cc_aead_handle *aead_handle = ctx->drvdata->aead_handle;\n\tunsigned int hash_mode = (ctx->auth_mode == DRV_HASH_SHA1) ?\n\t\t\t\tDRV_HASH_HW_SHA1 : DRV_HASH_HW_SHA256;\n\tunsigned int digest_size = (ctx->auth_mode == DRV_HASH_SHA1) ?\n\t\t\t\tCC_SHA1_DIGEST_SIZE : CC_SHA256_DIGEST_SIZE;\n\tunsigned int idx = *seq_size;\n\n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], hash_mode);\n\tset_dout_sram(&desc[idx], aead_handle->sram_workspace_addr,\n\t\t      ctx->hash_len);\n\tset_flow_mode(&desc[idx], S_HASH_to_DOUT);\n\tset_setup_mode(&desc[idx], SETUP_WRITE_STATE1);\n\tset_cipher_do(&desc[idx], DO_PAD);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_dout_sram(&desc[idx], aead_handle->sram_workspace_addr,\n\t\t      digest_size);\n\tset_flow_mode(&desc[idx], S_HASH_to_DOUT);\n\tset_setup_mode(&desc[idx], SETUP_WRITE_STATE0);\n\tset_cipher_config0(&desc[idx], HASH_DIGEST_RESULT_LITTLE_ENDIAN);\n\tset_cipher_mode(&desc[idx], hash_mode);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], hash_mode);\n\tset_din_type(&desc[idx], DMA_DLLI,\n\t\t     (ctx->auth_state.hmac.ipad_opad_dma_addr + digest_size),\n\t\t     digest_size, NS_BIT);\n\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE0);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], hash_mode);\n\tset_din_sram(&desc[idx], cc_digest_len_addr(ctx->drvdata, hash_mode),\n\t\t     ctx->hash_len);\n\tset_cipher_config1(&desc[idx], HASH_PADDING_ENABLED);\n\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_KEY0);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_din_sram(&desc[idx], aead_handle->sram_workspace_addr,\n\t\t     digest_size);\n\tset_flow_mode(&desc[idx], DIN_HASH);\n\tidx++;\n\n\t*seq_size = idx;\n}\n\nstatic void cc_mlli_to_sram(struct aead_request *req,\n\t\t\t    struct cc_hw_desc desc[], unsigned int *seq_size)\n{\n\tstruct aead_req_ctx *req_ctx = aead_request_ctx_dma(req);\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\n\tif ((req_ctx->assoc_buff_type == CC_DMA_BUF_MLLI ||\n\t    req_ctx->data_buff_type == CC_DMA_BUF_MLLI ||\n\t    !req_ctx->is_single_pass) && req_ctx->mlli_params.mlli_len) {\n\t\tdev_dbg(dev, \"Copy-to-sram: mlli_dma=%08x, mlli_size=%u\\n\",\n\t\t\tctx->drvdata->mlli_sram_addr,\n\t\t\treq_ctx->mlli_params.mlli_len);\n\t\t \n\t\thw_desc_init(&desc[*seq_size]);\n\t\tset_din_type(&desc[*seq_size], DMA_DLLI,\n\t\t\t     req_ctx->mlli_params.mlli_dma_addr,\n\t\t\t     req_ctx->mlli_params.mlli_len, NS_BIT);\n\t\tset_dout_sram(&desc[*seq_size],\n\t\t\t      ctx->drvdata->mlli_sram_addr,\n\t\t\t      req_ctx->mlli_params.mlli_len);\n\t\tset_flow_mode(&desc[*seq_size], BYPASS);\n\t\t(*seq_size)++;\n\t}\n}\n\nstatic enum cc_flow_mode cc_get_data_flow(enum drv_crypto_direction direct,\n\t\t\t\t\t  enum cc_flow_mode setup_flow_mode,\n\t\t\t\t\t  bool is_single_pass)\n{\n\tenum cc_flow_mode data_flow_mode;\n\n\tif (direct == DRV_CRYPTO_DIRECTION_ENCRYPT) {\n\t\tif (setup_flow_mode == S_DIN_to_AES)\n\t\t\tdata_flow_mode = is_single_pass ?\n\t\t\t\tAES_to_HASH_and_DOUT : DIN_AES_DOUT;\n\t\telse\n\t\t\tdata_flow_mode = is_single_pass ?\n\t\t\t\tDES_to_HASH_and_DOUT : DIN_DES_DOUT;\n\t} else {  \n\t\tif (setup_flow_mode == S_DIN_to_AES)\n\t\t\tdata_flow_mode = is_single_pass ?\n\t\t\t\tAES_and_HASH : DIN_AES_DOUT;\n\t\telse\n\t\t\tdata_flow_mode = is_single_pass ?\n\t\t\t\tDES_and_HASH : DIN_DES_DOUT;\n\t}\n\n\treturn data_flow_mode;\n}\n\nstatic void cc_hmac_authenc(struct aead_request *req, struct cc_hw_desc desc[],\n\t\t\t    unsigned int *seq_size)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_req_ctx *req_ctx = aead_request_ctx_dma(req);\n\tint direct = req_ctx->gen_ctx.op_type;\n\tunsigned int data_flow_mode =\n\t\tcc_get_data_flow(direct, ctx->flow_mode,\n\t\t\t\t req_ctx->is_single_pass);\n\n\tif (req_ctx->is_single_pass) {\n\t\t \n\t\tcc_set_hmac_desc(req, desc, seq_size);\n\t\tcc_set_cipher_desc(req, desc, seq_size);\n\t\tcc_proc_header_desc(req, desc, seq_size);\n\t\tcc_proc_cipher_desc(req, data_flow_mode, desc, seq_size);\n\t\tcc_proc_scheme_desc(req, desc, seq_size);\n\t\tcc_proc_digest_desc(req, desc, seq_size);\n\t\treturn;\n\t}\n\n\t \n\tif (direct == DRV_CRYPTO_DIRECTION_ENCRYPT) {\n\t\t \n\t\tcc_proc_cipher(req, desc, seq_size, data_flow_mode);\n\t\t \n\t\tcc_set_hmac_desc(req, desc, seq_size);\n\t\tcc_proc_authen_desc(req, DIN_HASH, desc, seq_size, direct);\n\t\tcc_proc_scheme_desc(req, desc, seq_size);\n\t\tcc_proc_digest_desc(req, desc, seq_size);\n\n\t} else {  \n\t\t \n\t\tcc_set_hmac_desc(req, desc, seq_size);\n\t\tcc_proc_authen_desc(req, DIN_HASH, desc, seq_size, direct);\n\t\tcc_proc_scheme_desc(req, desc, seq_size);\n\t\t \n\t\tcc_proc_cipher(req, desc, seq_size, data_flow_mode);\n\t\t \n\t\tcc_proc_digest_desc(req, desc, seq_size);\n\t}\n}\n\nstatic void\ncc_xcbc_authenc(struct aead_request *req, struct cc_hw_desc desc[],\n\t\tunsigned int *seq_size)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_req_ctx *req_ctx = aead_request_ctx_dma(req);\n\tint direct = req_ctx->gen_ctx.op_type;\n\tunsigned int data_flow_mode =\n\t\tcc_get_data_flow(direct, ctx->flow_mode,\n\t\t\t\t req_ctx->is_single_pass);\n\n\tif (req_ctx->is_single_pass) {\n\t\t \n\t\tcc_set_xcbc_desc(req, desc, seq_size);\n\t\tcc_set_cipher_desc(req, desc, seq_size);\n\t\tcc_proc_header_desc(req, desc, seq_size);\n\t\tcc_proc_cipher_desc(req, data_flow_mode, desc, seq_size);\n\t\tcc_proc_digest_desc(req, desc, seq_size);\n\t\treturn;\n\t}\n\n\t \n\tif (direct == DRV_CRYPTO_DIRECTION_ENCRYPT) {\n\t\t \n\t\tcc_proc_cipher(req, desc, seq_size, data_flow_mode);\n\t\t \n\t\tcc_set_xcbc_desc(req, desc, seq_size);\n\t\tcc_proc_authen_desc(req, DIN_HASH, desc, seq_size, direct);\n\t\tcc_proc_digest_desc(req, desc, seq_size);\n\t} else {  \n\t\t \n\t\tcc_set_xcbc_desc(req, desc, seq_size);\n\t\tcc_proc_authen_desc(req, DIN_HASH, desc, seq_size, direct);\n\t\t \n\t\tcc_proc_cipher(req, desc, seq_size, data_flow_mode);\n\t\t \n\t\tcc_proc_digest_desc(req, desc, seq_size);\n\t}\n}\n\nstatic int validate_data_size(struct cc_aead_ctx *ctx,\n\t\t\t      enum drv_crypto_direction direct,\n\t\t\t      struct aead_request *req)\n{\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(req);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\tunsigned int assoclen = areq_ctx->assoclen;\n\tunsigned int cipherlen = (direct == DRV_CRYPTO_DIRECTION_DECRYPT) ?\n\t\t\t(req->cryptlen - ctx->authsize) : req->cryptlen;\n\n\tif (direct == DRV_CRYPTO_DIRECTION_DECRYPT &&\n\t    req->cryptlen < ctx->authsize)\n\t\tgoto data_size_err;\n\n\tareq_ctx->is_single_pass = true;  \n\n\tswitch (ctx->flow_mode) {\n\tcase S_DIN_to_AES:\n\t\tif (ctx->cipher_mode == DRV_CIPHER_CBC &&\n\t\t    !IS_ALIGNED(cipherlen, AES_BLOCK_SIZE))\n\t\t\tgoto data_size_err;\n\t\tif (ctx->cipher_mode == DRV_CIPHER_CCM)\n\t\t\tbreak;\n\t\tif (ctx->cipher_mode == DRV_CIPHER_GCTR) {\n\t\t\tif (areq_ctx->plaintext_authenticate_only)\n\t\t\t\tareq_ctx->is_single_pass = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!IS_ALIGNED(assoclen, sizeof(u32)))\n\t\t\tareq_ctx->is_single_pass = false;\n\n\t\tif (ctx->cipher_mode == DRV_CIPHER_CTR &&\n\t\t    !IS_ALIGNED(cipherlen, sizeof(u32)))\n\t\t\tareq_ctx->is_single_pass = false;\n\n\t\tbreak;\n\tcase S_DIN_to_DES:\n\t\tif (!IS_ALIGNED(cipherlen, DES_BLOCK_SIZE))\n\t\t\tgoto data_size_err;\n\t\tif (!IS_ALIGNED(assoclen, DES_BLOCK_SIZE))\n\t\t\tareq_ctx->is_single_pass = false;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unexpected flow mode (%d)\\n\", ctx->flow_mode);\n\t\tgoto data_size_err;\n\t}\n\n\treturn 0;\n\ndata_size_err:\n\treturn -EINVAL;\n}\n\nstatic unsigned int format_ccm_a0(u8 *pa0_buff, u32 header_size)\n{\n\tunsigned int len = 0;\n\n\tif (header_size == 0)\n\t\treturn 0;\n\n\tif (header_size < ((1UL << 16) - (1UL << 8))) {\n\t\tlen = 2;\n\n\t\tpa0_buff[0] = (header_size >> 8) & 0xFF;\n\t\tpa0_buff[1] = header_size & 0xFF;\n\t} else {\n\t\tlen = 6;\n\n\t\tpa0_buff[0] = 0xFF;\n\t\tpa0_buff[1] = 0xFE;\n\t\tpa0_buff[2] = (header_size >> 24) & 0xFF;\n\t\tpa0_buff[3] = (header_size >> 16) & 0xFF;\n\t\tpa0_buff[4] = (header_size >> 8) & 0xFF;\n\t\tpa0_buff[5] = header_size & 0xFF;\n\t}\n\n\treturn len;\n}\n\nstatic int set_msg_len(u8 *block, unsigned int msglen, unsigned int csize)\n{\n\t__be32 data;\n\n\tmemset(block, 0, csize);\n\tblock += csize;\n\n\tif (csize >= 4)\n\t\tcsize = 4;\n\telse if (msglen > (1 << (8 * csize)))\n\t\treturn -EOVERFLOW;\n\n\tdata = cpu_to_be32(msglen);\n\tmemcpy(block - csize, (u8 *)&data + 4 - csize, csize);\n\n\treturn 0;\n}\n\nstatic int cc_ccm(struct aead_request *req, struct cc_hw_desc desc[],\n\t\t  unsigned int *seq_size)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_req_ctx *req_ctx = aead_request_ctx_dma(req);\n\tunsigned int idx = *seq_size;\n\tunsigned int cipher_flow_mode;\n\tdma_addr_t mac_result;\n\n\tif (req_ctx->gen_ctx.op_type == DRV_CRYPTO_DIRECTION_DECRYPT) {\n\t\tcipher_flow_mode = AES_to_HASH_and_DOUT;\n\t\tmac_result = req_ctx->mac_buf_dma_addr;\n\t} else {  \n\t\tcipher_flow_mode = AES_and_HASH;\n\t\tmac_result = req_ctx->icv_dma_addr;\n\t}\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_CTR);\n\tset_din_type(&desc[idx], DMA_DLLI, ctx->enckey_dma_addr,\n\t\t     ((ctx->enc_keylen == 24) ?  CC_AES_KEY_SIZE_MAX :\n\t\t      ctx->enc_keylen), NS_BIT);\n\tset_key_size_aes(&desc[idx], ctx->enc_keylen);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_KEY0);\n\tset_cipher_config0(&desc[idx], DESC_DIRECTION_ENCRYPT_ENCRYPT);\n\tset_flow_mode(&desc[idx], S_DIN_to_AES);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_CTR);\n\tset_key_size_aes(&desc[idx], ctx->enc_keylen);\n\tset_din_type(&desc[idx], DMA_DLLI,\n\t\t     req_ctx->gen_ctx.iv_dma_addr, AES_BLOCK_SIZE, NS_BIT);\n\tset_cipher_config0(&desc[idx], DESC_DIRECTION_ENCRYPT_ENCRYPT);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE1);\n\tset_flow_mode(&desc[idx], S_DIN_to_AES);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_CBC_MAC);\n\tset_din_type(&desc[idx], DMA_DLLI, ctx->enckey_dma_addr,\n\t\t     ((ctx->enc_keylen == 24) ?  CC_AES_KEY_SIZE_MAX :\n\t\t      ctx->enc_keylen), NS_BIT);\n\tset_key_size_aes(&desc[idx], ctx->enc_keylen);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_KEY0);\n\tset_cipher_config0(&desc[idx], DESC_DIRECTION_ENCRYPT_ENCRYPT);\n\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\tset_aes_not_hash_mode(&desc[idx]);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_CBC_MAC);\n\tset_key_size_aes(&desc[idx], ctx->enc_keylen);\n\tset_din_type(&desc[idx], DMA_DLLI, req_ctx->mac_buf_dma_addr,\n\t\t     AES_BLOCK_SIZE, NS_BIT);\n\tset_cipher_config0(&desc[idx], DESC_DIRECTION_ENCRYPT_ENCRYPT);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE0);\n\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\tset_aes_not_hash_mode(&desc[idx]);\n\tidx++;\n\n\t \n\tif (req_ctx->assoclen > 0) {\n\t\tcc_set_assoc_desc(req, DIN_HASH, desc, &idx);\n\t} else {\n\t\thw_desc_init(&desc[idx]);\n\t\tset_din_type(&desc[idx], DMA_DLLI,\n\t\t\t     sg_dma_address(&req_ctx->ccm_adata_sg),\n\t\t\t     AES_BLOCK_SIZE + req_ctx->ccm_hdr_size, NS_BIT);\n\t\tset_flow_mode(&desc[idx], DIN_HASH);\n\t\tidx++;\n\t}\n\n\t \n\tif (req_ctx->cryptlen)\n\t\tcc_proc_cipher_desc(req, cipher_flow_mode, desc, &idx);\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_CBC_MAC);\n\tset_dout_dlli(&desc[idx], req_ctx->mac_buf_dma_addr, ctx->authsize,\n\t\t      NS_BIT, 0);\n\tset_setup_mode(&desc[idx], SETUP_WRITE_STATE0);\n\tset_cipher_config0(&desc[idx], HASH_DIGEST_RESULT_LITTLE_ENDIAN);\n\tset_flow_mode(&desc[idx], S_HASH_to_DOUT);\n\tset_aes_not_hash_mode(&desc[idx]);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_CTR);\n\tset_cipher_config0(&desc[idx], DRV_CRYPTO_DIRECTION_ENCRYPT);\n\tset_din_type(&desc[idx], DMA_DLLI, req_ctx->ccm_iv0_dma_addr,\n\t\t     AES_BLOCK_SIZE, NS_BIT);\n\tset_key_size_aes(&desc[idx], ctx->enc_keylen);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE1);\n\tset_flow_mode(&desc[idx], S_DIN_to_AES);\n\tidx++;\n\n\thw_desc_init(&desc[idx]);\n\tset_din_no_dma(&desc[idx], 0, 0xfffff0);\n\tset_dout_no_dma(&desc[idx], 0, 0, 1);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_din_type(&desc[idx], DMA_DLLI, req_ctx->mac_buf_dma_addr,\n\t\t     ctx->authsize, NS_BIT);\n\tset_dout_dlli(&desc[idx], mac_result, ctx->authsize, NS_BIT, 1);\n\tset_queue_last_ind(ctx->drvdata, &desc[idx]);\n\tset_flow_mode(&desc[idx], DIN_AES_DOUT);\n\tidx++;\n\n\t*seq_size = idx;\n\treturn 0;\n}\n\nstatic int config_ccm_adata(struct aead_request *req)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\tstruct aead_req_ctx *req_ctx = aead_request_ctx_dma(req);\n\t \n\tunsigned int lp = req->iv[0];\n\t \n\tunsigned int l = lp + 1;   \n\tunsigned int m = ctx->authsize;   \n\tu8 *b0 = req_ctx->ccm_config + CCM_B0_OFFSET;\n\tu8 *a0 = req_ctx->ccm_config + CCM_A0_OFFSET;\n\tu8 *ctr_count_0 = req_ctx->ccm_config + CCM_CTR_COUNT_0_OFFSET;\n\tunsigned int cryptlen = (req_ctx->gen_ctx.op_type ==\n\t\t\t\t DRV_CRYPTO_DIRECTION_ENCRYPT) ?\n\t\t\t\treq->cryptlen :\n\t\t\t\t(req->cryptlen - ctx->authsize);\n\tint rc;\n\n\tmemset(req_ctx->mac_buf, 0, AES_BLOCK_SIZE);\n\tmemset(req_ctx->ccm_config, 0, AES_BLOCK_SIZE * 3);\n\n\t \n\t \n\tif (l < 2 || l > 8) {\n\t\tdev_dbg(dev, \"illegal iv value %X\\n\", req->iv[0]);\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(b0, req->iv, AES_BLOCK_SIZE);\n\n\t \n\t*b0 |= (8 * ((m - 2) / 2));\n\tif (req_ctx->assoclen > 0)\n\t\t*b0 |= 64;   \n\n\trc = set_msg_len(b0 + 16 - l, cryptlen, l);   \n\tif (rc) {\n\t\tdev_err(dev, \"message len overflow detected\");\n\t\treturn rc;\n\t}\n\t  \n\n\t \n\treq_ctx->ccm_hdr_size = format_ccm_a0(a0, req_ctx->assoclen);\n\n\tmemset(req->iv + 15 - req->iv[0], 0, req->iv[0] + 1);\n\treq->iv[15] = 1;\n\n\tmemcpy(ctr_count_0, req->iv, AES_BLOCK_SIZE);\n\tctr_count_0[15] = 0;\n\n\treturn 0;\n}\n\nstatic void cc_proc_rfc4309_ccm(struct aead_request *req)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(req);\n\n\t \n\tmemset(areq_ctx->ctr_iv, 0, AES_BLOCK_SIZE);\n\t \n\tareq_ctx->ctr_iv[0] = 3;\n\n\t \n\tmemcpy(areq_ctx->ctr_iv + CCM_BLOCK_NONCE_OFFSET, ctx->ctr_nonce,\n\t       CCM_BLOCK_NONCE_SIZE);\n\tmemcpy(areq_ctx->ctr_iv + CCM_BLOCK_IV_OFFSET, req->iv,\n\t       CCM_BLOCK_IV_SIZE);\n\treq->iv = areq_ctx->ctr_iv;\n}\n\nstatic void cc_set_ghash_desc(struct aead_request *req,\n\t\t\t      struct cc_hw_desc desc[], unsigned int *seq_size)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_req_ctx *req_ctx = aead_request_ctx_dma(req);\n\tunsigned int idx = *seq_size;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_ECB);\n\tset_cipher_config0(&desc[idx], DRV_CRYPTO_DIRECTION_ENCRYPT);\n\tset_din_type(&desc[idx], DMA_DLLI, ctx->enckey_dma_addr,\n\t\t     ctx->enc_keylen, NS_BIT);\n\tset_key_size_aes(&desc[idx], ctx->enc_keylen);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_KEY0);\n\tset_flow_mode(&desc[idx], S_DIN_to_AES);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_din_const(&desc[idx], 0x0, AES_BLOCK_SIZE);\n\tset_dout_dlli(&desc[idx], req_ctx->hkey_dma_addr, AES_BLOCK_SIZE,\n\t\t      NS_BIT, 0);\n\tset_flow_mode(&desc[idx], DIN_AES_DOUT);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_din_no_dma(&desc[idx], 0, 0xfffff0);\n\tset_dout_no_dma(&desc[idx], 0, 0, 1);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_din_type(&desc[idx], DMA_DLLI, req_ctx->hkey_dma_addr,\n\t\t     AES_BLOCK_SIZE, NS_BIT);\n\tset_dout_no_dma(&desc[idx], 0, 0, 1);\n\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\tset_aes_not_hash_mode(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_HASH_HW_GHASH);\n\tset_cipher_config1(&desc[idx], HASH_PADDING_ENABLED);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_KEY0);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_din_no_dma(&desc[idx], 0, 0xfffff0);\n\tset_dout_no_dma(&desc[idx], 0, 0, 1);\n\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\tset_aes_not_hash_mode(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_HASH_HW_GHASH);\n\tset_cipher_do(&desc[idx], 1); \n\tset_cipher_config0(&desc[idx], DRV_CRYPTO_DIRECTION_ENCRYPT);\n\tset_cipher_config1(&desc[idx], HASH_PADDING_ENABLED);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_KEY0);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_din_const(&desc[idx], 0x0, AES_BLOCK_SIZE);\n\tset_dout_no_dma(&desc[idx], 0, 0, 1);\n\tset_flow_mode(&desc[idx], S_DIN_to_HASH);\n\tset_aes_not_hash_mode(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_HASH_HW_GHASH);\n\tset_cipher_config1(&desc[idx], HASH_PADDING_ENABLED);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE0);\n\tidx++;\n\n\t*seq_size = idx;\n}\n\nstatic void cc_set_gctr_desc(struct aead_request *req, struct cc_hw_desc desc[],\n\t\t\t     unsigned int *seq_size)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_req_ctx *req_ctx = aead_request_ctx_dma(req);\n\tunsigned int idx = *seq_size;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_GCTR);\n\tset_cipher_config0(&desc[idx], DRV_CRYPTO_DIRECTION_ENCRYPT);\n\tset_din_type(&desc[idx], DMA_DLLI, ctx->enckey_dma_addr,\n\t\t     ctx->enc_keylen, NS_BIT);\n\tset_key_size_aes(&desc[idx], ctx->enc_keylen);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_KEY0);\n\tset_flow_mode(&desc[idx], S_DIN_to_AES);\n\tidx++;\n\n\tif (req_ctx->cryptlen && !req_ctx->plaintext_authenticate_only) {\n\t\t \n\t\thw_desc_init(&desc[idx]);\n\t\tset_cipher_mode(&desc[idx], DRV_CIPHER_GCTR);\n\t\tset_key_size_aes(&desc[idx], ctx->enc_keylen);\n\t\tset_din_type(&desc[idx], DMA_DLLI,\n\t\t\t     req_ctx->gcm_iv_inc2_dma_addr, AES_BLOCK_SIZE,\n\t\t\t     NS_BIT);\n\t\tset_cipher_config0(&desc[idx], DRV_CRYPTO_DIRECTION_ENCRYPT);\n\t\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE1);\n\t\tset_flow_mode(&desc[idx], S_DIN_to_AES);\n\t\tidx++;\n\t}\n\n\t*seq_size = idx;\n}\n\nstatic void cc_proc_gcm_result(struct aead_request *req,\n\t\t\t       struct cc_hw_desc desc[],\n\t\t\t       unsigned int *seq_size)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_req_ctx *req_ctx = aead_request_ctx_dma(req);\n\tdma_addr_t mac_result;\n\tunsigned int idx = *seq_size;\n\n\tif (req_ctx->gen_ctx.op_type == DRV_CRYPTO_DIRECTION_DECRYPT) {\n\t\tmac_result = req_ctx->mac_buf_dma_addr;\n\t} else {  \n\t\tmac_result = req_ctx->icv_dma_addr;\n\t}\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_din_type(&desc[idx], DMA_DLLI, req_ctx->gcm_block_len_dma_addr,\n\t\t     AES_BLOCK_SIZE, NS_BIT);\n\tset_flow_mode(&desc[idx], DIN_HASH);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_HASH_HW_GHASH);\n\tset_din_no_dma(&desc[idx], 0, 0xfffff0);\n\tset_dout_dlli(&desc[idx], req_ctx->mac_buf_dma_addr, AES_BLOCK_SIZE,\n\t\t      NS_BIT, 0);\n\tset_setup_mode(&desc[idx], SETUP_WRITE_STATE0);\n\tset_flow_mode(&desc[idx], S_HASH_to_DOUT);\n\tset_aes_not_hash_mode(&desc[idx]);\n\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_GCTR);\n\tset_key_size_aes(&desc[idx], ctx->enc_keylen);\n\tset_din_type(&desc[idx], DMA_DLLI, req_ctx->gcm_iv_inc1_dma_addr,\n\t\t     AES_BLOCK_SIZE, NS_BIT);\n\tset_cipher_config0(&desc[idx], DRV_CRYPTO_DIRECTION_ENCRYPT);\n\tset_setup_mode(&desc[idx], SETUP_LOAD_STATE1);\n\tset_flow_mode(&desc[idx], S_DIN_to_AES);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_din_no_dma(&desc[idx], 0, 0xfffff0);\n\tset_dout_no_dma(&desc[idx], 0, 0, 1);\n\tidx++;\n\n\t \n\thw_desc_init(&desc[idx]);\n\tset_cipher_mode(&desc[idx], DRV_CIPHER_GCTR);\n\tset_din_type(&desc[idx], DMA_DLLI, req_ctx->mac_buf_dma_addr,\n\t\t     AES_BLOCK_SIZE, NS_BIT);\n\tset_dout_dlli(&desc[idx], mac_result, ctx->authsize, NS_BIT, 1);\n\tset_queue_last_ind(ctx->drvdata, &desc[idx]);\n\tset_flow_mode(&desc[idx], DIN_AES_DOUT);\n\tidx++;\n\n\t*seq_size = idx;\n}\n\nstatic int cc_gcm(struct aead_request *req, struct cc_hw_desc desc[],\n\t\t  unsigned int *seq_size)\n{\n\tstruct aead_req_ctx *req_ctx = aead_request_ctx_dma(req);\n\tunsigned int cipher_flow_mode;\n\n\t\n\tif (req_ctx->plaintext_authenticate_only) {\n\t\tcc_proc_cipher_desc(req, BYPASS, desc, seq_size);\n\t\tcc_set_ghash_desc(req, desc, seq_size);\n\t\t \n\t\tcc_set_assoc_desc(req, DIN_HASH, desc, seq_size);\n\t\tcc_set_gctr_desc(req, desc, seq_size);\n\t\tcc_proc_gcm_result(req, desc, seq_size);\n\t\treturn 0;\n\t}\n\n\tif (req_ctx->gen_ctx.op_type == DRV_CRYPTO_DIRECTION_DECRYPT) {\n\t\tcipher_flow_mode = AES_and_HASH;\n\t} else {  \n\t\tcipher_flow_mode = AES_to_HASH_and_DOUT;\n\t}\n\n\t\n\tcc_set_ghash_desc(req, desc, seq_size);\n\t \n\tif (req_ctx->assoclen > 0)\n\t\tcc_set_assoc_desc(req, DIN_HASH, desc, seq_size);\n\tcc_set_gctr_desc(req, desc, seq_size);\n\t \n\tif (req_ctx->cryptlen)\n\t\tcc_proc_cipher_desc(req, cipher_flow_mode, desc, seq_size);\n\tcc_proc_gcm_result(req, desc, seq_size);\n\n\treturn 0;\n}\n\nstatic int config_gcm_context(struct aead_request *req)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_req_ctx *req_ctx = aead_request_ctx_dma(req);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\n\tunsigned int cryptlen = (req_ctx->gen_ctx.op_type ==\n\t\t\t\t DRV_CRYPTO_DIRECTION_ENCRYPT) ?\n\t\t\t\treq->cryptlen :\n\t\t\t\t(req->cryptlen - ctx->authsize);\n\t__be32 counter = cpu_to_be32(2);\n\n\tdev_dbg(dev, \"%s() cryptlen = %d, req_ctx->assoclen = %d ctx->authsize = %d\\n\",\n\t\t__func__, cryptlen, req_ctx->assoclen, ctx->authsize);\n\n\tmemset(req_ctx->hkey, 0, AES_BLOCK_SIZE);\n\n\tmemset(req_ctx->mac_buf, 0, AES_BLOCK_SIZE);\n\n\tmemcpy(req->iv + 12, &counter, 4);\n\tmemcpy(req_ctx->gcm_iv_inc2, req->iv, 16);\n\n\tcounter = cpu_to_be32(1);\n\tmemcpy(req->iv + 12, &counter, 4);\n\tmemcpy(req_ctx->gcm_iv_inc1, req->iv, 16);\n\n\tif (!req_ctx->plaintext_authenticate_only) {\n\t\t__be64 temp64;\n\n\t\ttemp64 = cpu_to_be64(req_ctx->assoclen * 8);\n\t\tmemcpy(&req_ctx->gcm_len_block.len_a, &temp64, sizeof(temp64));\n\t\ttemp64 = cpu_to_be64(cryptlen * 8);\n\t\tmemcpy(&req_ctx->gcm_len_block.len_c, &temp64, 8);\n\t} else {\n\t\t \n\t\t__be64 temp64;\n\n\t\ttemp64 = cpu_to_be64((req_ctx->assoclen + cryptlen) * 8);\n\t\tmemcpy(&req_ctx->gcm_len_block.len_a, &temp64, sizeof(temp64));\n\t\ttemp64 = 0;\n\t\tmemcpy(&req_ctx->gcm_len_block.len_c, &temp64, 8);\n\t}\n\n\treturn 0;\n}\n\nstatic void cc_proc_rfc4_gcm(struct aead_request *req)\n{\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(req);\n\n\tmemcpy(areq_ctx->ctr_iv + GCM_BLOCK_RFC4_NONCE_OFFSET,\n\t       ctx->ctr_nonce, GCM_BLOCK_RFC4_NONCE_SIZE);\n\tmemcpy(areq_ctx->ctr_iv + GCM_BLOCK_RFC4_IV_OFFSET, req->iv,\n\t       GCM_BLOCK_RFC4_IV_SIZE);\n\treq->iv = areq_ctx->ctr_iv;\n}\n\nstatic int cc_proc_aead(struct aead_request *req,\n\t\t\tenum drv_crypto_direction direct)\n{\n\tint rc = 0;\n\tint seq_len = 0;\n\tstruct cc_hw_desc desc[MAX_AEAD_PROCESS_SEQ];\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(req);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\tstruct cc_crypto_req cc_req = {};\n\n\tdev_dbg(dev, \"%s context=%p req=%p iv=%p src=%p src_ofs=%d dst=%p dst_ofs=%d cryptolen=%d\\n\",\n\t\t((direct == DRV_CRYPTO_DIRECTION_ENCRYPT) ? \"Enc\" : \"Dec\"),\n\t\tctx, req, req->iv, sg_virt(req->src), req->src->offset,\n\t\tsg_virt(req->dst), req->dst->offset, req->cryptlen);\n\n\t \n\n\t \n\tif (validate_data_size(ctx, direct, req)) {\n\t\tdev_err(dev, \"Unsupported crypt/assoc len %d/%d.\\n\",\n\t\t\treq->cryptlen, areq_ctx->assoclen);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcc_req.user_cb = cc_aead_complete;\n\tcc_req.user_arg = req;\n\n\t \n\tareq_ctx->gen_ctx.op_type = direct;\n\tareq_ctx->req_authsize = ctx->authsize;\n\tareq_ctx->cipher_mode = ctx->cipher_mode;\n\n\t \n\n\tif (ctx->cipher_mode == DRV_CIPHER_CTR) {\n\t\t \n\t\tmemcpy(areq_ctx->ctr_iv, ctx->ctr_nonce,\n\t\t       CTR_RFC3686_NONCE_SIZE);\n\t\tmemcpy(areq_ctx->ctr_iv + CTR_RFC3686_NONCE_SIZE, req->iv,\n\t\t       CTR_RFC3686_IV_SIZE);\n\t\t \n\t\t*(__be32 *)(areq_ctx->ctr_iv + CTR_RFC3686_NONCE_SIZE +\n\t\t\t    CTR_RFC3686_IV_SIZE) = cpu_to_be32(1);\n\n\t\t \n\t\treq->iv = areq_ctx->ctr_iv;\n\t\tareq_ctx->hw_iv_size = CTR_RFC3686_BLOCK_SIZE;\n\t} else if ((ctx->cipher_mode == DRV_CIPHER_CCM) ||\n\t\t   (ctx->cipher_mode == DRV_CIPHER_GCTR)) {\n\t\tareq_ctx->hw_iv_size = AES_BLOCK_SIZE;\n\t\tif (areq_ctx->ctr_iv != req->iv) {\n\t\t\tmemcpy(areq_ctx->ctr_iv, req->iv,\n\t\t\t       crypto_aead_ivsize(tfm));\n\t\t\treq->iv = areq_ctx->ctr_iv;\n\t\t}\n\t}  else {\n\t\tareq_ctx->hw_iv_size = crypto_aead_ivsize(tfm);\n\t}\n\n\tif (ctx->cipher_mode == DRV_CIPHER_CCM) {\n\t\trc = config_ccm_adata(req);\n\t\tif (rc) {\n\t\t\tdev_dbg(dev, \"config_ccm_adata() returned with a failure %d!\",\n\t\t\t\trc);\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tareq_ctx->ccm_hdr_size = ccm_header_size_null;\n\t}\n\n\tif (ctx->cipher_mode == DRV_CIPHER_GCTR) {\n\t\trc = config_gcm_context(req);\n\t\tif (rc) {\n\t\t\tdev_dbg(dev, \"config_gcm_context() returned with a failure %d!\",\n\t\t\t\trc);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\trc = cc_map_aead_request(ctx->drvdata, req);\n\tif (rc) {\n\t\tdev_err(dev, \"map_request() failed\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\n\t \n\tcc_mlli_to_sram(req, desc, &seq_len);\n\n\tswitch (ctx->auth_mode) {\n\tcase DRV_HASH_SHA1:\n\tcase DRV_HASH_SHA256:\n\t\tcc_hmac_authenc(req, desc, &seq_len);\n\t\tbreak;\n\tcase DRV_HASH_XCBC_MAC:\n\t\tcc_xcbc_authenc(req, desc, &seq_len);\n\t\tbreak;\n\tcase DRV_HASH_NULL:\n\t\tif (ctx->cipher_mode == DRV_CIPHER_CCM)\n\t\t\tcc_ccm(req, desc, &seq_len);\n\t\tif (ctx->cipher_mode == DRV_CIPHER_GCTR)\n\t\t\tcc_gcm(req, desc, &seq_len);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported authenc (%d)\\n\", ctx->auth_mode);\n\t\tcc_unmap_aead_request(dev, req);\n\t\trc = -ENOTSUPP;\n\t\tgoto exit;\n\t}\n\n\t \n\n\trc = cc_send_request(ctx->drvdata, &cc_req, desc, seq_len, &req->base);\n\n\tif (rc != -EINPROGRESS && rc != -EBUSY) {\n\t\tdev_err(dev, \"send_request() failed (rc=%d)\\n\", rc);\n\t\tcc_unmap_aead_request(dev, req);\n\t}\n\nexit:\n\treturn rc;\n}\n\nstatic int cc_aead_encrypt(struct aead_request *req)\n{\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(req);\n\tint rc;\n\n\tmemset(areq_ctx, 0, sizeof(*areq_ctx));\n\n\t \n\tareq_ctx->backup_iv = req->iv;\n\tareq_ctx->assoclen = req->assoclen;\n\n\trc = cc_proc_aead(req, DRV_CRYPTO_DIRECTION_ENCRYPT);\n\tif (rc != -EINPROGRESS && rc != -EBUSY)\n\t\treq->iv = areq_ctx->backup_iv;\n\n\treturn rc;\n}\n\nstatic int cc_rfc4309_ccm_encrypt(struct aead_request *req)\n{\n\t \n\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(req);\n\tint rc;\n\n\trc = crypto_ipsec_check_assoclen(req->assoclen);\n\tif (rc)\n\t\tgoto out;\n\n\tmemset(areq_ctx, 0, sizeof(*areq_ctx));\n\n\t \n\tareq_ctx->backup_iv = req->iv;\n\tareq_ctx->assoclen = req->assoclen - CCM_BLOCK_IV_SIZE;\n\n\tcc_proc_rfc4309_ccm(req);\n\n\trc = cc_proc_aead(req, DRV_CRYPTO_DIRECTION_ENCRYPT);\n\tif (rc != -EINPROGRESS && rc != -EBUSY)\n\t\treq->iv = areq_ctx->backup_iv;\nout:\n\treturn rc;\n}\n\nstatic int cc_aead_decrypt(struct aead_request *req)\n{\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(req);\n\tint rc;\n\n\tmemset(areq_ctx, 0, sizeof(*areq_ctx));\n\n\t \n\tareq_ctx->backup_iv = req->iv;\n\tareq_ctx->assoclen = req->assoclen;\n\n\trc = cc_proc_aead(req, DRV_CRYPTO_DIRECTION_DECRYPT);\n\tif (rc != -EINPROGRESS && rc != -EBUSY)\n\t\treq->iv = areq_ctx->backup_iv;\n\n\treturn rc;\n}\n\nstatic int cc_rfc4309_ccm_decrypt(struct aead_request *req)\n{\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(req);\n\tint rc;\n\n\trc = crypto_ipsec_check_assoclen(req->assoclen);\n\tif (rc)\n\t\tgoto out;\n\n\tmemset(areq_ctx, 0, sizeof(*areq_ctx));\n\n\t \n\tareq_ctx->backup_iv = req->iv;\n\tareq_ctx->assoclen = req->assoclen - CCM_BLOCK_IV_SIZE;\n\n\tcc_proc_rfc4309_ccm(req);\n\n\trc = cc_proc_aead(req, DRV_CRYPTO_DIRECTION_DECRYPT);\n\tif (rc != -EINPROGRESS && rc != -EBUSY)\n\t\treq->iv = areq_ctx->backup_iv;\n\nout:\n\treturn rc;\n}\n\nstatic int cc_rfc4106_gcm_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\n\tdev_dbg(dev, \"%s()  keylen %d, key %p\\n\", __func__, keylen, key);\n\n\tif (keylen < 4)\n\t\treturn -EINVAL;\n\n\tkeylen -= 4;\n\tmemcpy(ctx->ctr_nonce, key + keylen, 4);\n\n\treturn cc_aead_setkey(tfm, key, keylen);\n}\n\nstatic int cc_rfc4543_gcm_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\n\tdev_dbg(dev, \"%s()  keylen %d, key %p\\n\", __func__, keylen, key);\n\n\tif (keylen < 4)\n\t\treturn -EINVAL;\n\n\tkeylen -= 4;\n\tmemcpy(ctx->ctr_nonce, key + keylen, 4);\n\n\treturn cc_aead_setkey(tfm, key, keylen);\n}\n\nstatic int cc_gcm_setauthsize(struct crypto_aead *authenc,\n\t\t\t      unsigned int authsize)\n{\n\tswitch (authsize) {\n\tcase 4:\n\tcase 8:\n\tcase 12:\n\tcase 13:\n\tcase 14:\n\tcase 15:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn cc_aead_setauthsize(authenc, authsize);\n}\n\nstatic int cc_rfc4106_gcm_setauthsize(struct crypto_aead *authenc,\n\t\t\t\t      unsigned int authsize)\n{\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\n\tdev_dbg(dev, \"authsize %d\\n\", authsize);\n\n\tswitch (authsize) {\n\tcase 8:\n\tcase 12:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn cc_aead_setauthsize(authenc, authsize);\n}\n\nstatic int cc_rfc4543_gcm_setauthsize(struct crypto_aead *authenc,\n\t\t\t\t      unsigned int authsize)\n{\n\tstruct cc_aead_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct device *dev = drvdata_to_dev(ctx->drvdata);\n\n\tdev_dbg(dev, \"authsize %d\\n\", authsize);\n\n\tif (authsize != 16)\n\t\treturn -EINVAL;\n\n\treturn cc_aead_setauthsize(authenc, authsize);\n}\n\nstatic int cc_rfc4106_gcm_encrypt(struct aead_request *req)\n{\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(req);\n\tint rc;\n\n\trc = crypto_ipsec_check_assoclen(req->assoclen);\n\tif (rc)\n\t\tgoto out;\n\n\tmemset(areq_ctx, 0, sizeof(*areq_ctx));\n\n\t \n\tareq_ctx->backup_iv = req->iv;\n\tareq_ctx->assoclen = req->assoclen - GCM_BLOCK_RFC4_IV_SIZE;\n\n\tcc_proc_rfc4_gcm(req);\n\n\trc = cc_proc_aead(req, DRV_CRYPTO_DIRECTION_ENCRYPT);\n\tif (rc != -EINPROGRESS && rc != -EBUSY)\n\t\treq->iv = areq_ctx->backup_iv;\nout:\n\treturn rc;\n}\n\nstatic int cc_rfc4543_gcm_encrypt(struct aead_request *req)\n{\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(req);\n\tint rc;\n\n\trc = crypto_ipsec_check_assoclen(req->assoclen);\n\tif (rc)\n\t\tgoto out;\n\n\tmemset(areq_ctx, 0, sizeof(*areq_ctx));\n\n\t\n\tareq_ctx->plaintext_authenticate_only = true;\n\n\t \n\tareq_ctx->backup_iv = req->iv;\n\tareq_ctx->assoclen = req->assoclen;\n\n\tcc_proc_rfc4_gcm(req);\n\n\trc = cc_proc_aead(req, DRV_CRYPTO_DIRECTION_ENCRYPT);\n\tif (rc != -EINPROGRESS && rc != -EBUSY)\n\t\treq->iv = areq_ctx->backup_iv;\nout:\n\treturn rc;\n}\n\nstatic int cc_rfc4106_gcm_decrypt(struct aead_request *req)\n{\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(req);\n\tint rc;\n\n\trc = crypto_ipsec_check_assoclen(req->assoclen);\n\tif (rc)\n\t\tgoto out;\n\n\tmemset(areq_ctx, 0, sizeof(*areq_ctx));\n\n\t \n\tareq_ctx->backup_iv = req->iv;\n\tareq_ctx->assoclen = req->assoclen - GCM_BLOCK_RFC4_IV_SIZE;\n\n\tcc_proc_rfc4_gcm(req);\n\n\trc = cc_proc_aead(req, DRV_CRYPTO_DIRECTION_DECRYPT);\n\tif (rc != -EINPROGRESS && rc != -EBUSY)\n\t\treq->iv = areq_ctx->backup_iv;\nout:\n\treturn rc;\n}\n\nstatic int cc_rfc4543_gcm_decrypt(struct aead_request *req)\n{\n\tstruct aead_req_ctx *areq_ctx = aead_request_ctx_dma(req);\n\tint rc;\n\n\trc = crypto_ipsec_check_assoclen(req->assoclen);\n\tif (rc)\n\t\tgoto out;\n\n\tmemset(areq_ctx, 0, sizeof(*areq_ctx));\n\n\t\n\tareq_ctx->plaintext_authenticate_only = true;\n\n\t \n\tareq_ctx->backup_iv = req->iv;\n\tareq_ctx->assoclen = req->assoclen;\n\n\tcc_proc_rfc4_gcm(req);\n\n\trc = cc_proc_aead(req, DRV_CRYPTO_DIRECTION_DECRYPT);\n\tif (rc != -EINPROGRESS && rc != -EBUSY)\n\t\treq->iv = areq_ctx->backup_iv;\nout:\n\treturn rc;\n}\n\n \nstatic struct cc_alg_template aead_algs[] = {\n\t{\n\t\t.name = \"authenc(hmac(sha1),cbc(aes))\",\n\t\t.driver_name = \"authenc-hmac-sha1-cbc-aes-ccree\",\n\t\t.blocksize = AES_BLOCK_SIZE,\n\t\t.template_aead = {\n\t\t\t.setkey = cc_aead_setkey,\n\t\t\t.setauthsize = cc_aead_setauthsize,\n\t\t\t.encrypt = cc_aead_encrypt,\n\t\t\t.decrypt = cc_aead_decrypt,\n\t\t\t.init = cc_aead_init,\n\t\t\t.exit = cc_aead_exit,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.cipher_mode = DRV_CIPHER_CBC,\n\t\t.flow_mode = S_DIN_to_AES,\n\t\t.auth_mode = DRV_HASH_SHA1,\n\t\t.min_hw_rev = CC_HW_REV_630,\n\t\t.std_body = CC_STD_NIST,\n\t},\n\t{\n\t\t.name = \"authenc(hmac(sha1),cbc(des3_ede))\",\n\t\t.driver_name = \"authenc-hmac-sha1-cbc-des3-ccree\",\n\t\t.blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t.template_aead = {\n\t\t\t.setkey = cc_des3_aead_setkey,\n\t\t\t.setauthsize = cc_aead_setauthsize,\n\t\t\t.encrypt = cc_aead_encrypt,\n\t\t\t.decrypt = cc_aead_decrypt,\n\t\t\t.init = cc_aead_init,\n\t\t\t.exit = cc_aead_exit,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.cipher_mode = DRV_CIPHER_CBC,\n\t\t.flow_mode = S_DIN_to_DES,\n\t\t.auth_mode = DRV_HASH_SHA1,\n\t\t.min_hw_rev = CC_HW_REV_630,\n\t\t.std_body = CC_STD_NIST,\n\t},\n\t{\n\t\t.name = \"authenc(hmac(sha256),cbc(aes))\",\n\t\t.driver_name = \"authenc-hmac-sha256-cbc-aes-ccree\",\n\t\t.blocksize = AES_BLOCK_SIZE,\n\t\t.template_aead = {\n\t\t\t.setkey = cc_aead_setkey,\n\t\t\t.setauthsize = cc_aead_setauthsize,\n\t\t\t.encrypt = cc_aead_encrypt,\n\t\t\t.decrypt = cc_aead_decrypt,\n\t\t\t.init = cc_aead_init,\n\t\t\t.exit = cc_aead_exit,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.cipher_mode = DRV_CIPHER_CBC,\n\t\t.flow_mode = S_DIN_to_AES,\n\t\t.auth_mode = DRV_HASH_SHA256,\n\t\t.min_hw_rev = CC_HW_REV_630,\n\t\t.std_body = CC_STD_NIST,\n\t},\n\t{\n\t\t.name = \"authenc(hmac(sha256),cbc(des3_ede))\",\n\t\t.driver_name = \"authenc-hmac-sha256-cbc-des3-ccree\",\n\t\t.blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t.template_aead = {\n\t\t\t.setkey = cc_des3_aead_setkey,\n\t\t\t.setauthsize = cc_aead_setauthsize,\n\t\t\t.encrypt = cc_aead_encrypt,\n\t\t\t.decrypt = cc_aead_decrypt,\n\t\t\t.init = cc_aead_init,\n\t\t\t.exit = cc_aead_exit,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.cipher_mode = DRV_CIPHER_CBC,\n\t\t.flow_mode = S_DIN_to_DES,\n\t\t.auth_mode = DRV_HASH_SHA256,\n\t\t.min_hw_rev = CC_HW_REV_630,\n\t\t.std_body = CC_STD_NIST,\n\t},\n\t{\n\t\t.name = \"authenc(xcbc(aes),cbc(aes))\",\n\t\t.driver_name = \"authenc-xcbc-aes-cbc-aes-ccree\",\n\t\t.blocksize = AES_BLOCK_SIZE,\n\t\t.template_aead = {\n\t\t\t.setkey = cc_aead_setkey,\n\t\t\t.setauthsize = cc_aead_setauthsize,\n\t\t\t.encrypt = cc_aead_encrypt,\n\t\t\t.decrypt = cc_aead_decrypt,\n\t\t\t.init = cc_aead_init,\n\t\t\t.exit = cc_aead_exit,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.cipher_mode = DRV_CIPHER_CBC,\n\t\t.flow_mode = S_DIN_to_AES,\n\t\t.auth_mode = DRV_HASH_XCBC_MAC,\n\t\t.min_hw_rev = CC_HW_REV_630,\n\t\t.std_body = CC_STD_NIST,\n\t},\n\t{\n\t\t.name = \"authenc(hmac(sha1),rfc3686(ctr(aes)))\",\n\t\t.driver_name = \"authenc-hmac-sha1-rfc3686-ctr-aes-ccree\",\n\t\t.blocksize = 1,\n\t\t.template_aead = {\n\t\t\t.setkey = cc_aead_setkey,\n\t\t\t.setauthsize = cc_aead_setauthsize,\n\t\t\t.encrypt = cc_aead_encrypt,\n\t\t\t.decrypt = cc_aead_decrypt,\n\t\t\t.init = cc_aead_init,\n\t\t\t.exit = cc_aead_exit,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.cipher_mode = DRV_CIPHER_CTR,\n\t\t.flow_mode = S_DIN_to_AES,\n\t\t.auth_mode = DRV_HASH_SHA1,\n\t\t.min_hw_rev = CC_HW_REV_630,\n\t\t.std_body = CC_STD_NIST,\n\t},\n\t{\n\t\t.name = \"authenc(hmac(sha256),rfc3686(ctr(aes)))\",\n\t\t.driver_name = \"authenc-hmac-sha256-rfc3686-ctr-aes-ccree\",\n\t\t.blocksize = 1,\n\t\t.template_aead = {\n\t\t\t.setkey = cc_aead_setkey,\n\t\t\t.setauthsize = cc_aead_setauthsize,\n\t\t\t.encrypt = cc_aead_encrypt,\n\t\t\t.decrypt = cc_aead_decrypt,\n\t\t\t.init = cc_aead_init,\n\t\t\t.exit = cc_aead_exit,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.cipher_mode = DRV_CIPHER_CTR,\n\t\t.flow_mode = S_DIN_to_AES,\n\t\t.auth_mode = DRV_HASH_SHA256,\n\t\t.min_hw_rev = CC_HW_REV_630,\n\t\t.std_body = CC_STD_NIST,\n\t},\n\t{\n\t\t.name = \"authenc(xcbc(aes),rfc3686(ctr(aes)))\",\n\t\t.driver_name = \"authenc-xcbc-aes-rfc3686-ctr-aes-ccree\",\n\t\t.blocksize = 1,\n\t\t.template_aead = {\n\t\t\t.setkey = cc_aead_setkey,\n\t\t\t.setauthsize = cc_aead_setauthsize,\n\t\t\t.encrypt = cc_aead_encrypt,\n\t\t\t.decrypt = cc_aead_decrypt,\n\t\t\t.init = cc_aead_init,\n\t\t\t.exit = cc_aead_exit,\n\t\t\t.ivsize = CTR_RFC3686_IV_SIZE,\n\t\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.cipher_mode = DRV_CIPHER_CTR,\n\t\t.flow_mode = S_DIN_to_AES,\n\t\t.auth_mode = DRV_HASH_XCBC_MAC,\n\t\t.min_hw_rev = CC_HW_REV_630,\n\t\t.std_body = CC_STD_NIST,\n\t},\n\t{\n\t\t.name = \"ccm(aes)\",\n\t\t.driver_name = \"ccm-aes-ccree\",\n\t\t.blocksize = 1,\n\t\t.template_aead = {\n\t\t\t.setkey = cc_aead_setkey,\n\t\t\t.setauthsize = cc_ccm_setauthsize,\n\t\t\t.encrypt = cc_aead_encrypt,\n\t\t\t.decrypt = cc_aead_decrypt,\n\t\t\t.init = cc_aead_init,\n\t\t\t.exit = cc_aead_exit,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.cipher_mode = DRV_CIPHER_CCM,\n\t\t.flow_mode = S_DIN_to_AES,\n\t\t.auth_mode = DRV_HASH_NULL,\n\t\t.min_hw_rev = CC_HW_REV_630,\n\t\t.std_body = CC_STD_NIST,\n\t},\n\t{\n\t\t.name = \"rfc4309(ccm(aes))\",\n\t\t.driver_name = \"rfc4309-ccm-aes-ccree\",\n\t\t.blocksize = 1,\n\t\t.template_aead = {\n\t\t\t.setkey = cc_rfc4309_ccm_setkey,\n\t\t\t.setauthsize = cc_rfc4309_ccm_setauthsize,\n\t\t\t.encrypt = cc_rfc4309_ccm_encrypt,\n\t\t\t.decrypt = cc_rfc4309_ccm_decrypt,\n\t\t\t.init = cc_aead_init,\n\t\t\t.exit = cc_aead_exit,\n\t\t\t.ivsize = CCM_BLOCK_IV_SIZE,\n\t\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.cipher_mode = DRV_CIPHER_CCM,\n\t\t.flow_mode = S_DIN_to_AES,\n\t\t.auth_mode = DRV_HASH_NULL,\n\t\t.min_hw_rev = CC_HW_REV_630,\n\t\t.std_body = CC_STD_NIST,\n\t},\n\t{\n\t\t.name = \"gcm(aes)\",\n\t\t.driver_name = \"gcm-aes-ccree\",\n\t\t.blocksize = 1,\n\t\t.template_aead = {\n\t\t\t.setkey = cc_aead_setkey,\n\t\t\t.setauthsize = cc_gcm_setauthsize,\n\t\t\t.encrypt = cc_aead_encrypt,\n\t\t\t.decrypt = cc_aead_decrypt,\n\t\t\t.init = cc_aead_init,\n\t\t\t.exit = cc_aead_exit,\n\t\t\t.ivsize = 12,\n\t\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.cipher_mode = DRV_CIPHER_GCTR,\n\t\t.flow_mode = S_DIN_to_AES,\n\t\t.auth_mode = DRV_HASH_NULL,\n\t\t.min_hw_rev = CC_HW_REV_630,\n\t\t.std_body = CC_STD_NIST,\n\t},\n\t{\n\t\t.name = \"rfc4106(gcm(aes))\",\n\t\t.driver_name = \"rfc4106-gcm-aes-ccree\",\n\t\t.blocksize = 1,\n\t\t.template_aead = {\n\t\t\t.setkey = cc_rfc4106_gcm_setkey,\n\t\t\t.setauthsize = cc_rfc4106_gcm_setauthsize,\n\t\t\t.encrypt = cc_rfc4106_gcm_encrypt,\n\t\t\t.decrypt = cc_rfc4106_gcm_decrypt,\n\t\t\t.init = cc_aead_init,\n\t\t\t.exit = cc_aead_exit,\n\t\t\t.ivsize = GCM_BLOCK_RFC4_IV_SIZE,\n\t\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.cipher_mode = DRV_CIPHER_GCTR,\n\t\t.flow_mode = S_DIN_to_AES,\n\t\t.auth_mode = DRV_HASH_NULL,\n\t\t.min_hw_rev = CC_HW_REV_630,\n\t\t.std_body = CC_STD_NIST,\n\t},\n\t{\n\t\t.name = \"rfc4543(gcm(aes))\",\n\t\t.driver_name = \"rfc4543-gcm-aes-ccree\",\n\t\t.blocksize = 1,\n\t\t.template_aead = {\n\t\t\t.setkey = cc_rfc4543_gcm_setkey,\n\t\t\t.setauthsize = cc_rfc4543_gcm_setauthsize,\n\t\t\t.encrypt = cc_rfc4543_gcm_encrypt,\n\t\t\t.decrypt = cc_rfc4543_gcm_decrypt,\n\t\t\t.init = cc_aead_init,\n\t\t\t.exit = cc_aead_exit,\n\t\t\t.ivsize = GCM_BLOCK_RFC4_IV_SIZE,\n\t\t\t.maxauthsize = AES_BLOCK_SIZE,\n\t\t},\n\t\t.cipher_mode = DRV_CIPHER_GCTR,\n\t\t.flow_mode = S_DIN_to_AES,\n\t\t.auth_mode = DRV_HASH_NULL,\n\t\t.min_hw_rev = CC_HW_REV_630,\n\t\t.std_body = CC_STD_NIST,\n\t},\n};\n\nstatic struct cc_crypto_alg *cc_create_aead_alg(struct cc_alg_template *tmpl,\n\t\t\t\t\t\tstruct device *dev)\n{\n\tstruct cc_crypto_alg *t_alg;\n\tstruct aead_alg *alg;\n\n\tt_alg = devm_kzalloc(dev, sizeof(*t_alg), GFP_KERNEL);\n\tif (!t_alg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\talg = &tmpl->template_aead;\n\n\tsnprintf(alg->base.cra_name, CRYPTO_MAX_ALG_NAME, \"%s\", tmpl->name);\n\tsnprintf(alg->base.cra_driver_name, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t tmpl->driver_name);\n\talg->base.cra_module = THIS_MODULE;\n\talg->base.cra_priority = CC_CRA_PRIO;\n\n\talg->base.cra_ctxsize = sizeof(struct cc_aead_ctx);\n\talg->base.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_KERN_DRIVER_ONLY;\n\talg->base.cra_blocksize = tmpl->blocksize;\n\talg->init = cc_aead_init;\n\talg->exit = cc_aead_exit;\n\n\tt_alg->aead_alg = *alg;\n\n\tt_alg->cipher_mode = tmpl->cipher_mode;\n\tt_alg->flow_mode = tmpl->flow_mode;\n\tt_alg->auth_mode = tmpl->auth_mode;\n\n\treturn t_alg;\n}\n\nint cc_aead_free(struct cc_drvdata *drvdata)\n{\n\tstruct cc_crypto_alg *t_alg, *n;\n\tstruct cc_aead_handle *aead_handle = drvdata->aead_handle;\n\n\t \n\tlist_for_each_entry_safe(t_alg, n, &aead_handle->aead_list, entry) {\n\t\tcrypto_unregister_aead(&t_alg->aead_alg);\n\t\tlist_del(&t_alg->entry);\n\t}\n\n\treturn 0;\n}\n\nint cc_aead_alloc(struct cc_drvdata *drvdata)\n{\n\tstruct cc_aead_handle *aead_handle;\n\tstruct cc_crypto_alg *t_alg;\n\tint rc = -ENOMEM;\n\tint alg;\n\tstruct device *dev = drvdata_to_dev(drvdata);\n\n\taead_handle = devm_kmalloc(dev, sizeof(*aead_handle), GFP_KERNEL);\n\tif (!aead_handle) {\n\t\trc = -ENOMEM;\n\t\tgoto fail0;\n\t}\n\n\tINIT_LIST_HEAD(&aead_handle->aead_list);\n\tdrvdata->aead_handle = aead_handle;\n\n\taead_handle->sram_workspace_addr = cc_sram_alloc(drvdata,\n\t\t\t\t\t\t\t MAX_HMAC_DIGEST_SIZE);\n\n\tif (aead_handle->sram_workspace_addr == NULL_SRAM_ADDR) {\n\t\trc = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\t \n\tfor (alg = 0; alg < ARRAY_SIZE(aead_algs); alg++) {\n\t\tif ((aead_algs[alg].min_hw_rev > drvdata->hw_rev) ||\n\t\t    !(drvdata->std_bodies & aead_algs[alg].std_body))\n\t\t\tcontinue;\n\n\t\tt_alg = cc_create_aead_alg(&aead_algs[alg], dev);\n\t\tif (IS_ERR(t_alg)) {\n\t\t\trc = PTR_ERR(t_alg);\n\t\t\tdev_err(dev, \"%s alg allocation failed\\n\",\n\t\t\t\taead_algs[alg].driver_name);\n\t\t\tgoto fail1;\n\t\t}\n\t\tt_alg->drvdata = drvdata;\n\t\trc = crypto_register_aead(&t_alg->aead_alg);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"%s alg registration failed\\n\",\n\t\t\t\tt_alg->aead_alg.base.cra_driver_name);\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tlist_add_tail(&t_alg->entry, &aead_handle->aead_list);\n\t\tdev_dbg(dev, \"Registered %s\\n\",\n\t\t\tt_alg->aead_alg.base.cra_driver_name);\n\t}\n\n\treturn 0;\n\nfail1:\n\tcc_aead_free(drvdata);\nfail0:\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}