{
  "module_name": "cc_driver.c",
  "hash_id": "100d18f9d0e8015a8a3ee00245a87c767108abb72f01fcfcf814c62e467376a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccree/cc_driver.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include <linux/crypto.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/of_address.h>\n#include <linux/pm_runtime.h>\n\n#include \"cc_driver.h\"\n#include \"cc_request_mgr.h\"\n#include \"cc_buffer_mgr.h\"\n#include \"cc_debugfs.h\"\n#include \"cc_cipher.h\"\n#include \"cc_aead.h\"\n#include \"cc_hash.h\"\n#include \"cc_sram_mgr.h\"\n#include \"cc_pm.h\"\n#include \"cc_fips.h\"\n\nbool cc_dump_desc;\nmodule_param_named(dump_desc, cc_dump_desc, bool, 0600);\nMODULE_PARM_DESC(cc_dump_desc, \"Dump descriptors to kernel log as debugging aid\");\nbool cc_dump_bytes;\nmodule_param_named(dump_bytes, cc_dump_bytes, bool, 0600);\nMODULE_PARM_DESC(cc_dump_bytes, \"Dump buffers to kernel log as debugging aid\");\n\nstatic bool cc_sec_disable;\nmodule_param_named(sec_disable, cc_sec_disable, bool, 0600);\nMODULE_PARM_DESC(cc_sec_disable, \"Disable security functions\");\n\nstruct cc_hw_data {\n\tchar *name;\n\tenum cc_hw_rev rev;\n\tu32 sig;\n\tu32 cidr_0123;\n\tu32 pidr_0124;\n\tint std_bodies;\n};\n\n#define CC_NUM_IDRS 4\n#define CC_HW_RESET_LOOP_COUNT 10\n\n \nstatic const u32 pidr_0124_offsets[CC_NUM_IDRS] = {\n\tCC_REG(PERIPHERAL_ID_0), CC_REG(PERIPHERAL_ID_1),\n\tCC_REG(PERIPHERAL_ID_2), CC_REG(PERIPHERAL_ID_4)\n};\n\nstatic const u32 cidr_0123_offsets[CC_NUM_IDRS] = {\n\tCC_REG(COMPONENT_ID_0), CC_REG(COMPONENT_ID_1),\n\tCC_REG(COMPONENT_ID_2), CC_REG(COMPONENT_ID_3)\n};\n\n \n\n \nstatic const struct cc_hw_data cc703_hw = {\n\t.name = \"703\", .rev = CC_HW_REV_713, .cidr_0123 = 0xB105F00DU,\n\t.pidr_0124 = 0x040BB0D0U, .std_bodies = CC_STD_OSCCA\n};\n\nstatic const struct cc_hw_data cc713_hw = {\n\t.name = \"713\", .rev = CC_HW_REV_713, .cidr_0123 = 0xB105F00DU,\n\t.pidr_0124 = 0x040BB0D0U, .std_bodies = CC_STD_ALL\n};\n\nstatic const struct cc_hw_data cc712_hw = {\n\t.name = \"712\", .rev = CC_HW_REV_712, .sig =  0xDCC71200U,\n\t.std_bodies = CC_STD_ALL\n};\n\nstatic const struct cc_hw_data cc710_hw = {\n\t.name = \"710\", .rev = CC_HW_REV_710, .sig =  0xDCC63200U,\n\t.std_bodies = CC_STD_ALL\n};\n\nstatic const struct cc_hw_data cc630p_hw = {\n\t.name = \"630P\", .rev = CC_HW_REV_630, .sig = 0xDCC63000U,\n\t.std_bodies = CC_STD_ALL\n};\n\nstatic const struct of_device_id arm_ccree_dev_of_match[] = {\n\t{ .compatible = \"arm,cryptocell-703-ree\", .data = &cc703_hw },\n\t{ .compatible = \"arm,cryptocell-713-ree\", .data = &cc713_hw },\n\t{ .compatible = \"arm,cryptocell-712-ree\", .data = &cc712_hw },\n\t{ .compatible = \"arm,cryptocell-710-ree\", .data = &cc710_hw },\n\t{ .compatible = \"arm,cryptocell-630p-ree\", .data = &cc630p_hw },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, arm_ccree_dev_of_match);\n\nstatic void init_cc_cache_params(struct cc_drvdata *drvdata)\n{\n\tstruct device *dev = drvdata_to_dev(drvdata);\n\tu32 cache_params, ace_const, val;\n\tu64 mask;\n\n\t \n\tcache_params = cc_ioread(drvdata, CC_REG(AXIM_CACHE_PARAMS));\n\tdev_dbg(dev, \"Cache params previous: 0x%08X\\n\", cache_params);\n\n\t \n\tval = drvdata->coherent ? 0xb : 0x2;\n\n\tmask = CC_GENMASK(CC_AXIM_CACHE_PARAMS_AWCACHE);\n\tcache_params &= ~mask;\n\tcache_params |= FIELD_PREP(mask, val);\n\n\tmask = CC_GENMASK(CC_AXIM_CACHE_PARAMS_AWCACHE_LAST);\n\tcache_params &= ~mask;\n\tcache_params |= FIELD_PREP(mask, val);\n\n\tmask = CC_GENMASK(CC_AXIM_CACHE_PARAMS_ARCACHE);\n\tcache_params &= ~mask;\n\tcache_params |= FIELD_PREP(mask, val);\n\n\tdrvdata->cache_params = cache_params;\n\n\tdev_dbg(dev, \"Cache params current: 0x%08X\\n\", cache_params);\n\n\tif (drvdata->hw_rev <= CC_HW_REV_710)\n\t\treturn;\n\n\t \n\tace_const = cc_ioread(drvdata, CC_REG(AXIM_ACE_CONST));\n\tdev_dbg(dev, \"ACE-const previous: 0x%08X\\n\", ace_const);\n\n\t \n\tval = drvdata->coherent ? 0x2 : 0x3;\n\n\tmask = CC_GENMASK(CC_AXIM_ACE_CONST_ARDOMAIN);\n\tace_const &= ~mask;\n\tace_const |= FIELD_PREP(mask, val);\n\n\tmask = CC_GENMASK(CC_AXIM_ACE_CONST_AWDOMAIN);\n\tace_const &= ~mask;\n\tace_const |= FIELD_PREP(mask, val);\n\n\tdev_dbg(dev, \"ACE-const current: 0x%08X\\n\", ace_const);\n\n\tdrvdata->ace_const = ace_const;\n}\n\nstatic u32 cc_read_idr(struct cc_drvdata *drvdata, const u32 *idr_offsets)\n{\n\tint i;\n\tunion {\n\t\tu8 regs[CC_NUM_IDRS];\n\t\t__le32 val;\n\t} idr;\n\n\tfor (i = 0; i < CC_NUM_IDRS; ++i)\n\t\tidr.regs[i] = cc_ioread(drvdata, idr_offsets[i]);\n\n\treturn le32_to_cpu(idr.val);\n}\n\nvoid __dump_byte_array(const char *name, const u8 *buf, size_t len)\n{\n\tchar prefix[64];\n\n\tif (!buf)\n\t\treturn;\n\n\tsnprintf(prefix, sizeof(prefix), \"%s[%zu]: \", name, len);\n\n\tprint_hex_dump(KERN_DEBUG, prefix, DUMP_PREFIX_ADDRESS, 16, 1, buf,\n\t\t       len, false);\n}\n\nstatic irqreturn_t cc_isr(int irq, void *dev_id)\n{\n\tstruct cc_drvdata *drvdata = (struct cc_drvdata *)dev_id;\n\tstruct device *dev = drvdata_to_dev(drvdata);\n\tu32 irr;\n\tu32 imr;\n\n\t \n\t \n\tif (pm_runtime_suspended(dev))\n\t\treturn IRQ_NONE;\n\n\t \n\tirr = cc_ioread(drvdata, CC_REG(HOST_IRR));\n\tdev_dbg(dev, \"Got IRR=0x%08X\\n\", irr);\n\n\tif (irr == 0)  \n\t\treturn IRQ_NONE;\n\n\timr = cc_ioread(drvdata, CC_REG(HOST_IMR));\n\n\t \n\tcc_iowrite(drvdata, CC_REG(HOST_ICR), irr);\n\n\tdrvdata->irq = irr;\n\t \n\tif (irr & drvdata->comp_mask) {\n\t\t \n\t\tcc_iowrite(drvdata, CC_REG(HOST_IMR), imr | drvdata->comp_mask);\n\t\tirr &= ~drvdata->comp_mask;\n\t\tcomplete_request(drvdata);\n\t}\n#ifdef CONFIG_CRYPTO_FIPS\n\t \n\tif (irr & CC_GPR0_IRQ_MASK) {\n\t\t \n\t\tcc_iowrite(drvdata, CC_REG(HOST_IMR), imr | CC_GPR0_IRQ_MASK);\n\t\tirr &= ~CC_GPR0_IRQ_MASK;\n\t\tfips_handler(drvdata);\n\t}\n#endif\n\t \n\tif (irr & CC_AXI_ERR_IRQ_MASK) {\n\t\tu32 axi_err;\n\n\t\t \n\t\taxi_err = cc_ioread(drvdata, CC_REG(AXIM_MON_ERR));\n\t\tdev_dbg(dev, \"AXI completion error: axim_mon_err=0x%08X\\n\",\n\t\t\taxi_err);\n\n\t\tirr &= ~CC_AXI_ERR_IRQ_MASK;\n\t}\n\n\tif (irr) {\n\t\tdev_dbg_ratelimited(dev, \"IRR includes unknown cause bits (0x%08X)\\n\",\n\t\t\t\t    irr);\n\t\t \n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nbool cc_wait_for_reset_completion(struct cc_drvdata *drvdata)\n{\n\tunsigned int val;\n\tunsigned int i;\n\n\t \n\tif (drvdata->hw_rev <= CC_HW_REV_712)\n\t\treturn true;\n\n\tfor (i = 0; i < CC_HW_RESET_LOOP_COUNT; i++) {\n\t\t \n\t\tval = cc_ioread(drvdata, CC_REG(NVM_IS_IDLE));\n\t\tif (val & CC_NVM_IS_IDLE_MASK) {\n\t\t\t \n\t\t\treturn true;\n\t\t}\n\t\t \n\t\tschedule();\n\t}\n\t \n\treturn false;\n}\n\nint init_cc_regs(struct cc_drvdata *drvdata)\n{\n\tunsigned int val;\n\tstruct device *dev = drvdata_to_dev(drvdata);\n\n\t \n\t \n\tif (drvdata->hw_rev <= CC_HW_REV_712) {\n\t\tval = cc_ioread(drvdata, CC_REG(AXIM_CFG));\n\t\tcc_iowrite(drvdata, CC_REG(AXIM_CFG), val & ~CC_AXI_IRQ_MASK);\n\t\tdev_dbg(dev, \"AXIM_CFG=0x%08X\\n\",\n\t\t\tcc_ioread(drvdata, CC_REG(AXIM_CFG)));\n\t}\n\n\t \n\tval = cc_ioread(drvdata, CC_REG(HOST_IRR));\n\tdev_dbg(dev, \"IRR=0x%08X\\n\", val);\n\tcc_iowrite(drvdata, CC_REG(HOST_ICR), val);\n\n\t \n\tval = drvdata->comp_mask | CC_AXI_ERR_IRQ_MASK;\n\n\tif (drvdata->hw_rev >= CC_HW_REV_712)\n\t\tval |= CC_GPR0_IRQ_MASK;\n\n\tcc_iowrite(drvdata, CC_REG(HOST_IMR), ~val);\n\n\tcc_iowrite(drvdata, CC_REG(AXIM_CACHE_PARAMS), drvdata->cache_params);\n\tif (drvdata->hw_rev >= CC_HW_REV_712)\n\t\tcc_iowrite(drvdata, CC_REG(AXIM_ACE_CONST), drvdata->ace_const);\n\n\treturn 0;\n}\n\nstatic int init_cc_resources(struct platform_device *plat_dev)\n{\n\tstruct resource *req_mem_cc_regs = NULL;\n\tstruct cc_drvdata *new_drvdata;\n\tstruct device *dev = &plat_dev->dev;\n\tstruct device_node *np = dev->of_node;\n\tu32 val, hw_rev_pidr, sig_cidr;\n\tu64 dma_mask;\n\tconst struct cc_hw_data *hw_rev;\n\tstruct clk *clk;\n\tint irq;\n\tint rc = 0;\n\n\tnew_drvdata = devm_kzalloc(dev, sizeof(*new_drvdata), GFP_KERNEL);\n\tif (!new_drvdata)\n\t\treturn -ENOMEM;\n\n\thw_rev = of_device_get_match_data(dev);\n\tnew_drvdata->hw_rev_name = hw_rev->name;\n\tnew_drvdata->hw_rev = hw_rev->rev;\n\tnew_drvdata->std_bodies = hw_rev->std_bodies;\n\n\tif (hw_rev->rev >= CC_HW_REV_712) {\n\t\tnew_drvdata->axim_mon_offset = CC_REG(AXIM_MON_COMP);\n\t\tnew_drvdata->sig_offset = CC_REG(HOST_SIGNATURE_712);\n\t\tnew_drvdata->ver_offset = CC_REG(HOST_VERSION_712);\n\t} else {\n\t\tnew_drvdata->axim_mon_offset = CC_REG(AXIM_MON_COMP8);\n\t\tnew_drvdata->sig_offset = CC_REG(HOST_SIGNATURE_630);\n\t\tnew_drvdata->ver_offset = CC_REG(HOST_VERSION_630);\n\t}\n\n\tnew_drvdata->comp_mask = CC_COMP_IRQ_MASK;\n\n\tplatform_set_drvdata(plat_dev, new_drvdata);\n\tnew_drvdata->plat_dev = plat_dev;\n\n\tclk = devm_clk_get_optional(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(clk), \"Error getting clock\\n\");\n\tnew_drvdata->clk = clk;\n\n\tnew_drvdata->coherent = of_dma_is_coherent(np);\n\n\t \n\t \n\t \n\tnew_drvdata->cc_base = devm_platform_get_and_ioremap_resource(plat_dev,\n\t\t\t\t\t\t\t\t      0, &req_mem_cc_regs);\n\tif (IS_ERR(new_drvdata->cc_base))\n\t\treturn PTR_ERR(new_drvdata->cc_base);\n\n\tdev_dbg(dev, \"Got MEM resource (%s): %pR\\n\", req_mem_cc_regs->name,\n\t\treq_mem_cc_regs);\n\tdev_dbg(dev, \"CC registers mapped from %pa to 0x%p\\n\",\n\t\t&req_mem_cc_regs->start, new_drvdata->cc_base);\n\n\t \n\tirq = platform_get_irq(plat_dev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tinit_completion(&new_drvdata->hw_queue_avail);\n\n\tif (!dev->dma_mask)\n\t\tdev->dma_mask = &dev->coherent_dma_mask;\n\n\tdma_mask = DMA_BIT_MASK(DMA_BIT_MASK_LEN);\n\trc = dma_set_coherent_mask(dev, dma_mask);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed in dma_set_coherent_mask, mask=%llx\\n\",\n\t\t\tdma_mask);\n\t\treturn rc;\n\t}\n\n\trc = clk_prepare_enable(new_drvdata->clk);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to enable clock\");\n\t\treturn rc;\n\t}\n\n\tnew_drvdata->sec_disabled = cc_sec_disable;\n\n\tpm_runtime_set_autosuspend_delay(dev, CC_SUSPEND_TIMEOUT);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\trc = pm_runtime_get_sync(dev);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"pm_runtime_get_sync() failed: %d\\n\", rc);\n\t\tgoto post_pm_err;\n\t}\n\n\t \n\tif (!cc_wait_for_reset_completion(new_drvdata)) {\n\t\tdev_err(dev, \"Cryptocell reset not completed\");\n\t}\n\n\tif (hw_rev->rev <= CC_HW_REV_712) {\n\t\t \n\t\tval = cc_ioread(new_drvdata, new_drvdata->sig_offset);\n\t\tif (val != hw_rev->sig) {\n\t\t\tdev_err(dev, \"Invalid CC signature: SIGNATURE=0x%08X != expected=0x%08X\\n\",\n\t\t\t\tval, hw_rev->sig);\n\t\t\trc = -EINVAL;\n\t\t\tgoto post_pm_err;\n\t\t}\n\t\tsig_cidr = val;\n\t\thw_rev_pidr = cc_ioread(new_drvdata, new_drvdata->ver_offset);\n\t} else {\n\t\t \n\t\tval = cc_read_idr(new_drvdata, pidr_0124_offsets);\n\t\tif (val != hw_rev->pidr_0124) {\n\t\t\tdev_err(dev, \"Invalid CC PIDR: PIDR0124=0x%08X != expected=0x%08X\\n\",\n\t\t\t\tval,  hw_rev->pidr_0124);\n\t\t\trc = -EINVAL;\n\t\t\tgoto post_pm_err;\n\t\t}\n\t\thw_rev_pidr = val;\n\n\t\tval = cc_read_idr(new_drvdata, cidr_0123_offsets);\n\t\tif (val != hw_rev->cidr_0123) {\n\t\t\tdev_err(dev, \"Invalid CC CIDR: CIDR0123=0x%08X != expected=0x%08X\\n\",\n\t\t\tval,  hw_rev->cidr_0123);\n\t\t\trc = -EINVAL;\n\t\t\tgoto post_pm_err;\n\t\t}\n\t\tsig_cidr = val;\n\n\t\t \n\t\tval = cc_ioread(new_drvdata, CC_REG(HOST_REMOVE_INPUT_PINS));\n\t\tswitch (val) {\n\t\tcase CC_PINS_FULL:\n\t\t\t \n\t\t\tbreak;\n\t\tcase CC_PINS_SLIM:\n\t\t\tif (new_drvdata->std_bodies & CC_STD_NIST) {\n\t\t\t\tdev_warn(dev, \"703 mode forced due to HW configuration.\\n\");\n\t\t\t\tnew_drvdata->std_bodies = CC_STD_OSCCA;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Unsupported engines configuration.\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto post_pm_err;\n\t\t}\n\n\t\t \n\t\tval = cc_ioread(new_drvdata, CC_REG(SECURITY_DISABLED));\n\t\tval &= CC_SECURITY_DISABLED_MASK;\n\t\tnew_drvdata->sec_disabled |= !!val;\n\n\t\tif (!new_drvdata->sec_disabled) {\n\t\t\tnew_drvdata->comp_mask |= CC_CPP_SM4_ABORT_MASK;\n\t\t\tif (new_drvdata->std_bodies & CC_STD_NIST)\n\t\t\t\tnew_drvdata->comp_mask |= CC_CPP_AES_ABORT_MASK;\n\t\t}\n\t}\n\n\tif (new_drvdata->sec_disabled)\n\t\tdev_info(dev, \"Security Disabled mode is in effect. Security functions disabled.\\n\");\n\n\t \n\tdev_info(dev, \"ARM CryptoCell %s Driver: HW version 0x%08X/0x%8X, Driver version %s\\n\",\n\t\t hw_rev->name, hw_rev_pidr, sig_cidr, DRV_MODULE_VERSION);\n\t \n\trc = devm_request_irq(dev, irq, cc_isr, IRQF_SHARED, \"ccree\",\n\t\t\t      new_drvdata);\n\tif (rc) {\n\t\tdev_err(dev, \"Could not register to interrupt %d\\n\", irq);\n\t\tgoto post_pm_err;\n\t}\n\tdev_dbg(dev, \"Registered to IRQ: %d\\n\", irq);\n\n\tinit_cc_cache_params(new_drvdata);\n\n\trc = init_cc_regs(new_drvdata);\n\tif (rc) {\n\t\tdev_err(dev, \"init_cc_regs failed\\n\");\n\t\tgoto post_pm_err;\n\t}\n\n\trc = cc_debugfs_init(new_drvdata);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed registering debugfs interface\\n\");\n\t\tgoto post_regs_err;\n\t}\n\n\trc = cc_fips_init(new_drvdata);\n\tif (rc) {\n\t\tdev_err(dev, \"cc_fips_init failed 0x%x\\n\", rc);\n\t\tgoto post_debugfs_err;\n\t}\n\trc = cc_sram_mgr_init(new_drvdata);\n\tif (rc) {\n\t\tdev_err(dev, \"cc_sram_mgr_init failed\\n\");\n\t\tgoto post_fips_init_err;\n\t}\n\n\tnew_drvdata->mlli_sram_addr =\n\t\tcc_sram_alloc(new_drvdata, MAX_MLLI_BUFF_SIZE);\n\tif (new_drvdata->mlli_sram_addr == NULL_SRAM_ADDR) {\n\t\trc = -ENOMEM;\n\t\tgoto post_fips_init_err;\n\t}\n\n\trc = cc_req_mgr_init(new_drvdata);\n\tif (rc) {\n\t\tdev_err(dev, \"cc_req_mgr_init failed\\n\");\n\t\tgoto post_fips_init_err;\n\t}\n\n\trc = cc_buffer_mgr_init(new_drvdata);\n\tif (rc) {\n\t\tdev_err(dev, \"cc_buffer_mgr_init failed\\n\");\n\t\tgoto post_req_mgr_err;\n\t}\n\n\t \n\trc = cc_hash_alloc(new_drvdata);\n\tif (rc) {\n\t\tdev_err(dev, \"cc_hash_alloc failed\\n\");\n\t\tgoto post_buf_mgr_err;\n\t}\n\n\t \n\trc = cc_cipher_alloc(new_drvdata);\n\tif (rc) {\n\t\tdev_err(dev, \"cc_cipher_alloc failed\\n\");\n\t\tgoto post_hash_err;\n\t}\n\n\trc = cc_aead_alloc(new_drvdata);\n\tif (rc) {\n\t\tdev_err(dev, \"cc_aead_alloc failed\\n\");\n\t\tgoto post_cipher_err;\n\t}\n\n\t \n\tcc_set_ree_fips_status(new_drvdata, true);\n\n\tpm_runtime_put(dev);\n\treturn 0;\n\npost_cipher_err:\n\tcc_cipher_free(new_drvdata);\npost_hash_err:\n\tcc_hash_free(new_drvdata);\npost_buf_mgr_err:\n\t cc_buffer_mgr_fini(new_drvdata);\npost_req_mgr_err:\n\tcc_req_mgr_fini(new_drvdata);\npost_fips_init_err:\n\tcc_fips_fini(new_drvdata);\npost_debugfs_err:\n\tcc_debugfs_fini(new_drvdata);\npost_regs_err:\n\tfini_cc_regs(new_drvdata);\npost_pm_err:\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tclk_disable_unprepare(new_drvdata->clk);\n\treturn rc;\n}\n\nvoid fini_cc_regs(struct cc_drvdata *drvdata)\n{\n\t \n\tcc_iowrite(drvdata, CC_REG(HOST_IMR), 0xFFFFFFFF);\n}\n\nstatic void cleanup_cc_resources(struct platform_device *plat_dev)\n{\n\tstruct device *dev = &plat_dev->dev;\n\tstruct cc_drvdata *drvdata =\n\t\t(struct cc_drvdata *)platform_get_drvdata(plat_dev);\n\n\tcc_aead_free(drvdata);\n\tcc_cipher_free(drvdata);\n\tcc_hash_free(drvdata);\n\tcc_buffer_mgr_fini(drvdata);\n\tcc_req_mgr_fini(drvdata);\n\tcc_fips_fini(drvdata);\n\tcc_debugfs_fini(drvdata);\n\tfini_cc_regs(drvdata);\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tclk_disable_unprepare(drvdata->clk);\n}\n\nunsigned int cc_get_default_hash_len(struct cc_drvdata *drvdata)\n{\n\tif (drvdata->hw_rev >= CC_HW_REV_712)\n\t\treturn HASH_LEN_SIZE_712;\n\telse\n\t\treturn HASH_LEN_SIZE_630;\n}\n\nstatic int ccree_probe(struct platform_device *plat_dev)\n{\n\tint rc;\n\tstruct device *dev = &plat_dev->dev;\n\n\t \n\trc = init_cc_resources(plat_dev);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_info(dev, \"ARM ccree device initialized\\n\");\n\n\treturn 0;\n}\n\nstatic int ccree_remove(struct platform_device *plat_dev)\n{\n\tstruct device *dev = &plat_dev->dev;\n\n\tdev_dbg(dev, \"Releasing ccree resources...\\n\");\n\n\tcleanup_cc_resources(plat_dev);\n\n\tdev_info(dev, \"ARM ccree device terminated\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver ccree_driver = {\n\t.driver = {\n\t\t   .name = \"ccree\",\n\t\t   .of_match_table = arm_ccree_dev_of_match,\n#ifdef CONFIG_PM\n\t\t   .pm = &ccree_pm,\n#endif\n\t},\n\t.probe = ccree_probe,\n\t.remove = ccree_remove,\n};\n\nstatic int __init ccree_init(void)\n{\n\tint rc;\n\n\tcc_debugfs_global_init();\n\n\trc = platform_driver_register(&ccree_driver);\n\tif (rc) {\n\t\tcc_debugfs_global_fini();\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\nmodule_init(ccree_init);\n\nstatic void __exit ccree_exit(void)\n{\n\tplatform_driver_unregister(&ccree_driver);\n\tcc_debugfs_global_fini();\n}\nmodule_exit(ccree_exit);\n\n \nMODULE_DESCRIPTION(\"ARM TrustZone CryptoCell REE Driver\");\nMODULE_VERSION(DRV_MODULE_VERSION);\nMODULE_AUTHOR(\"ARM\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}