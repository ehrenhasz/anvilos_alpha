{
  "module_name": "cc_driver.h",
  "hash_id": "52bdee70c9817c2eb6ace855264fd514364adc5b39a2a87b478243e98c6367c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/ccree/cc_driver.h",
  "human_readable_source": " \n \n\n \n\n#ifndef __CC_DRIVER_H__\n#define __CC_DRIVER_H__\n\n#ifdef COMP_IN_WQ\n#include <linux/workqueue.h>\n#else\n#include <linux/interrupt.h>\n#endif\n#include <linux/dma-mapping.h>\n#include <crypto/algapi.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/aes.h>\n#include <crypto/sha1.h>\n#include <crypto/sha2.h>\n#include <crypto/aead.h>\n#include <crypto/authenc.h>\n#include <crypto/hash.h>\n#include <crypto/skcipher.h>\n#include <linux/clk.h>\n#include <linux/platform_device.h>\n\n#include \"cc_host_regs.h\"\n#include \"cc_crypto_ctx.h\"\n#include \"cc_hw_queue_defs.h\"\n#include \"cc_sram_mgr.h\"\n\nextern bool cc_dump_desc;\nextern bool cc_dump_bytes;\n\n#define DRV_MODULE_VERSION \"5.0\"\n\nenum cc_hw_rev {\n\tCC_HW_REV_630 = 630,\n\tCC_HW_REV_710 = 710,\n\tCC_HW_REV_712 = 712,\n\tCC_HW_REV_713 = 713\n};\n\nenum cc_std_body {\n\tCC_STD_NIST = 0x1,\n\tCC_STD_OSCCA = 0x2,\n\tCC_STD_ALL = 0x3\n};\n\n#define CC_PINS_FULL\t0x0\n#define CC_PINS_SLIM\t0x9F\n\n \n#define DMA_BIT_MASK_LEN 48\n\n#define CC_AXI_IRQ_MASK ((1 << CC_AXIM_CFG_BRESPMASK_BIT_SHIFT) | \\\n\t\t\t  (1 << CC_AXIM_CFG_RRESPMASK_BIT_SHIFT) | \\\n\t\t\t  (1 << CC_AXIM_CFG_INFLTMASK_BIT_SHIFT) | \\\n\t\t\t  (1 << CC_AXIM_CFG_COMPMASK_BIT_SHIFT))\n\n#define CC_AXI_ERR_IRQ_MASK BIT(CC_HOST_IRR_AXI_ERR_INT_BIT_SHIFT)\n\n#define CC_COMP_IRQ_MASK BIT(CC_HOST_IRR_AXIM_COMP_INT_BIT_SHIFT)\n\n#define CC_SECURITY_DISABLED_MASK BIT(CC_SECURITY_DISABLED_VALUE_BIT_SHIFT)\n\n#define CC_NVM_IS_IDLE_MASK BIT(CC_NVM_IS_IDLE_VALUE_BIT_SHIFT)\n\n#define AXIM_MON_COMP_VALUE CC_GENMASK(CC_AXIM_MON_COMP_VALUE)\n\n#define CC_CPP_AES_ABORT_MASK ( \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_AES_0_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_AES_1_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_AES_2_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_AES_3_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_AES_4_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_AES_5_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_AES_6_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_AES_7_MASK_BIT_SHIFT))\n\n#define CC_CPP_SM4_ABORT_MASK ( \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_SM_0_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_SM_1_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_SM_2_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_SM_3_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_SM_4_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_SM_5_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_SM_6_MASK_BIT_SHIFT) | \\\n\tBIT(CC_HOST_IMR_REE_OP_ABORTED_SM_7_MASK_BIT_SHIFT))\n\n \n#define CC_REG(reg_name) CC_ ## reg_name ## _REG_OFFSET\n\n \n#define CC_GPR0_IRQ_MASK BIT(CC_HOST_IRR_GPR0_BIT_SHIFT)\n\n#define CC_CRA_PRIO 400\n\n#define MIN_HW_QUEUE_SIZE 50  \n\n#define MAX_REQUEST_QUEUE_SIZE 4096\n#define MAX_MLLI_BUFF_SIZE 2080\n\n \n#define NS_BIT 1\n#define AXI_ID 0\n \n\nstruct cc_cpp_req {\n\tbool is_cpp;\n\tenum cc_cpp_alg alg;\n\tu8 slot;\n};\n\n#define CC_MAX_IVGEN_DMA_ADDRESSES\t3\nstruct cc_crypto_req {\n\tvoid (*user_cb)(struct device *dev, void *req, int err);\n\tvoid *user_arg;\n\tstruct completion seq_compl;  \n\tstruct cc_cpp_req cpp;\n};\n\n \nstruct cc_drvdata {\n\tvoid __iomem *cc_base;\n\tint irq;\n\tstruct completion hw_queue_avail;  \n\tstruct platform_device *plat_dev;\n\tu32 mlli_sram_addr;\n\tstruct dma_pool *mlli_buffs_pool;\n\tstruct list_head alg_list;\n\tvoid *hash_handle;\n\tvoid *aead_handle;\n\tvoid *request_mgr_handle;\n\tvoid *fips_handle;\n\tu32 sram_free_offset;\t \n\tstruct dentry *dir;\t \n\tstruct clk *clk;\n\tbool coherent;\n\tchar *hw_rev_name;\n\tenum cc_hw_rev hw_rev;\n\tu32 axim_mon_offset;\n\tu32 sig_offset;\n\tu32 ver_offset;\n\tint std_bodies;\n\tbool sec_disabled;\n\tu32 comp_mask;\n\tu32 cache_params;\n\tu32 ace_const;\n};\n\nstruct cc_crypto_alg {\n\tstruct list_head entry;\n\tint cipher_mode;\n\tint flow_mode;  \n\tint auth_mode;\n\tstruct cc_drvdata *drvdata;\n\tstruct skcipher_alg skcipher_alg;\n\tstruct aead_alg aead_alg;\n};\n\nstruct cc_alg_template {\n\tchar name[CRYPTO_MAX_ALG_NAME];\n\tchar driver_name[CRYPTO_MAX_ALG_NAME];\n\tunsigned int blocksize;\n\tunion {\n\t\tstruct skcipher_alg skcipher;\n\t\tstruct aead_alg aead;\n\t} template_u;\n\tint cipher_mode;\n\tint flow_mode;  \n\tint auth_mode;\n\tu32 min_hw_rev;\n\tenum cc_std_body std_body;\n\tbool sec_func;\n\tunsigned int data_unit;\n\tstruct cc_drvdata *drvdata;\n};\n\nstruct async_gen_req_ctx {\n\tdma_addr_t iv_dma_addr;\n\tu8 *iv;\n\tenum drv_crypto_direction op_type;\n};\n\nstatic inline struct device *drvdata_to_dev(struct cc_drvdata *drvdata)\n{\n\treturn &drvdata->plat_dev->dev;\n}\n\nvoid __dump_byte_array(const char *name, const u8 *buf, size_t len);\nstatic inline void dump_byte_array(const char *name, const u8 *the_array,\n\t\t\t\t   size_t size)\n{\n\tif (cc_dump_bytes)\n\t\t__dump_byte_array(name, the_array, size);\n}\n\nbool cc_wait_for_reset_completion(struct cc_drvdata *drvdata);\nint init_cc_regs(struct cc_drvdata *drvdata);\nvoid fini_cc_regs(struct cc_drvdata *drvdata);\nunsigned int cc_get_default_hash_len(struct cc_drvdata *drvdata);\n\nstatic inline void cc_iowrite(struct cc_drvdata *drvdata, u32 reg, u32 val)\n{\n\tiowrite32(val, (drvdata->cc_base + reg));\n}\n\nstatic inline u32 cc_ioread(struct cc_drvdata *drvdata, u32 reg)\n{\n\treturn ioread32(drvdata->cc_base + reg);\n}\n\nstatic inline gfp_t cc_gfp_flags(struct crypto_async_request *req)\n{\n\treturn (req->flags & CRYPTO_TFM_REQ_MAY_SLEEP) ?\n\t\t\tGFP_KERNEL : GFP_ATOMIC;\n}\n\nstatic inline void set_queue_last_ind(struct cc_drvdata *drvdata,\n\t\t\t\t      struct cc_hw_desc *pdesc)\n{\n\tif (drvdata->hw_rev >= CC_HW_REV_712)\n\t\tset_queue_last_ind_bit(pdesc);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}