{
  "module_name": "atmel-sha204a.c",
  "hash_id": "1c4512dd4fc566f4c6c8fb96b9c1694a3fd4a1a1ac13d2ce5693d3f5eb0cd9e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/atmel-sha204a.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include \"atmel-i2c.h\"\n\nstatic void atmel_sha204a_rng_done(struct atmel_i2c_work_data *work_data,\n\t\t\t\t   void *areq, int status)\n{\n\tstruct atmel_i2c_client_priv *i2c_priv = work_data->ctx;\n\tstruct hwrng *rng = areq;\n\n\tif (status)\n\t\tdev_warn_ratelimited(&i2c_priv->client->dev,\n\t\t\t\t     \"i2c transaction failed (%d)\\n\",\n\t\t\t\t     status);\n\n\trng->priv = (unsigned long)work_data;\n\tatomic_dec(&i2c_priv->tfm_count);\n}\n\nstatic int atmel_sha204a_rng_read_nonblocking(struct hwrng *rng, void *data,\n\t\t\t\t\t      size_t max)\n{\n\tstruct atmel_i2c_client_priv *i2c_priv;\n\tstruct atmel_i2c_work_data *work_data;\n\n\ti2c_priv = container_of(rng, struct atmel_i2c_client_priv, hwrng);\n\n\t \n\tif (!atomic_add_unless(&i2c_priv->tfm_count, 1, 1))\n\t\treturn 0;\n\n\tif (rng->priv) {\n\t\twork_data = (struct atmel_i2c_work_data *)rng->priv;\n\t\tmax = min(sizeof(work_data->cmd.data), max);\n\t\tmemcpy(data, &work_data->cmd.data, max);\n\t\trng->priv = 0;\n\t} else {\n\t\twork_data = kmalloc(sizeof(*work_data), GFP_ATOMIC);\n\t\tif (!work_data)\n\t\t\treturn -ENOMEM;\n\n\t\twork_data->ctx = i2c_priv;\n\t\twork_data->client = i2c_priv->client;\n\n\t\tmax = 0;\n\t}\n\n\tatmel_i2c_init_random_cmd(&work_data->cmd);\n\tatmel_i2c_enqueue(work_data, atmel_sha204a_rng_done, rng);\n\n\treturn max;\n}\n\nstatic int atmel_sha204a_rng_read(struct hwrng *rng, void *data, size_t max,\n\t\t\t\t  bool wait)\n{\n\tstruct atmel_i2c_client_priv *i2c_priv;\n\tstruct atmel_i2c_cmd cmd;\n\tint ret;\n\n\tif (!wait)\n\t\treturn atmel_sha204a_rng_read_nonblocking(rng, data, max);\n\n\ti2c_priv = container_of(rng, struct atmel_i2c_client_priv, hwrng);\n\n\tatmel_i2c_init_random_cmd(&cmd);\n\n\tret = atmel_i2c_send_receive(i2c_priv->client, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tmax = min(sizeof(cmd.data), max);\n\tmemcpy(data, cmd.data, max);\n\n\treturn max;\n}\n\nstatic int atmel_sha204a_probe(struct i2c_client *client)\n{\n\tstruct atmel_i2c_client_priv *i2c_priv;\n\tint ret;\n\n\tret = atmel_i2c_probe(client);\n\tif (ret)\n\t\treturn ret;\n\n\ti2c_priv = i2c_get_clientdata(client);\n\n\tmemset(&i2c_priv->hwrng, 0, sizeof(i2c_priv->hwrng));\n\n\ti2c_priv->hwrng.name = dev_name(&client->dev);\n\ti2c_priv->hwrng.read = atmel_sha204a_rng_read;\n\n\tret = devm_hwrng_register(&client->dev, &i2c_priv->hwrng);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"failed to register RNG (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void atmel_sha204a_remove(struct i2c_client *client)\n{\n\tstruct atmel_i2c_client_priv *i2c_priv = i2c_get_clientdata(client);\n\n\tif (atomic_read(&i2c_priv->tfm_count)) {\n\t\tdev_emerg(&client->dev, \"Device is busy, will remove it anyhow\\n\");\n\t\treturn;\n\t}\n\n\tkfree((void *)i2c_priv->hwrng.priv);\n}\n\nstatic const struct of_device_id atmel_sha204a_dt_ids[] __maybe_unused = {\n\t{ .compatible = \"atmel,atsha204\", },\n\t{ .compatible = \"atmel,atsha204a\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, atmel_sha204a_dt_ids);\n\nstatic const struct i2c_device_id atmel_sha204a_id[] = {\n\t{ \"atsha204\", 0 },\n\t{ \"atsha204a\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, atmel_sha204a_id);\n\nstatic struct i2c_driver atmel_sha204a_driver = {\n\t.probe\t\t\t= atmel_sha204a_probe,\n\t.remove\t\t\t= atmel_sha204a_remove,\n\t.id_table\t\t= atmel_sha204a_id,\n\n\t.driver.name\t\t= \"atmel-sha204a\",\n\t.driver.of_match_table\t= of_match_ptr(atmel_sha204a_dt_ids),\n};\n\nstatic int __init atmel_sha204a_init(void)\n{\n\treturn i2c_add_driver(&atmel_sha204a_driver);\n}\n\nstatic void __exit atmel_sha204a_exit(void)\n{\n\tatmel_i2c_flush_queue();\n\ti2c_del_driver(&atmel_sha204a_driver);\n}\n\nmodule_init(atmel_sha204a_init);\nmodule_exit(atmel_sha204a_exit);\n\nMODULE_AUTHOR(\"Ard Biesheuvel <ard.biesheuvel@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}