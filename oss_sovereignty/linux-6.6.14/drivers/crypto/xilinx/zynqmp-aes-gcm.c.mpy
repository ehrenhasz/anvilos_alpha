{
  "module_name": "zynqmp-aes-gcm.c",
  "hash_id": "6b1217f44c2e61a80f33b73c2f87848f025d4f6e2bf0934a83b44e9342ec5ac0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/xilinx/zynqmp-aes-gcm.c",
  "human_readable_source": "\n \n\n#include <crypto/aes.h>\n#include <crypto/engine.h>\n#include <crypto/gcm.h>\n#include <crypto/internal/aead.h>\n#include <crypto/scatterwalk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/firmware/xlnx-zynqmp.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n\n#define ZYNQMP_DMA_BIT_MASK\t32U\n\n#define ZYNQMP_AES_KEY_SIZE\t\tAES_KEYSIZE_256\n#define ZYNQMP_AES_AUTH_SIZE\t\t16U\n#define ZYNQMP_KEY_SRC_SEL_KEY_LEN\t1U\n#define ZYNQMP_AES_BLK_SIZE\t\t1U\n#define ZYNQMP_AES_MIN_INPUT_BLK_SIZE\t4U\n#define ZYNQMP_AES_WORD_LEN\t\t4U\n\n#define ZYNQMP_AES_GCM_TAG_MISMATCH_ERR\t\t0x01\n#define ZYNQMP_AES_WRONG_KEY_SRC_ERR\t\t0x13\n#define ZYNQMP_AES_PUF_NOT_PROGRAMMED\t\t0xE300\n\nenum zynqmp_aead_op {\n\tZYNQMP_AES_DECRYPT = 0,\n\tZYNQMP_AES_ENCRYPT\n};\n\nenum zynqmp_aead_keysrc {\n\tZYNQMP_AES_KUP_KEY = 0,\n\tZYNQMP_AES_DEV_KEY,\n\tZYNQMP_AES_PUF_KEY\n};\n\nstruct zynqmp_aead_drv_ctx {\n\tunion {\n\t\tstruct aead_engine_alg aead;\n\t} alg;\n\tstruct device *dev;\n\tstruct crypto_engine *engine;\n};\n\nstruct zynqmp_aead_hw_req {\n\tu64 src;\n\tu64 iv;\n\tu64 key;\n\tu64 dst;\n\tu64 size;\n\tu64 op;\n\tu64 keysrc;\n};\n\nstruct zynqmp_aead_tfm_ctx {\n\tstruct device *dev;\n\tu8 key[ZYNQMP_AES_KEY_SIZE];\n\tu8 *iv;\n\tu32 keylen;\n\tu32 authsize;\n\tenum zynqmp_aead_keysrc keysrc;\n\tstruct crypto_aead *fbk_cipher;\n};\n\nstruct zynqmp_aead_req_ctx {\n\tenum zynqmp_aead_op op;\n};\n\nstatic int zynqmp_aes_aead_cipher(struct aead_request *req)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct zynqmp_aead_tfm_ctx *tfm_ctx = crypto_aead_ctx(aead);\n\tstruct zynqmp_aead_req_ctx *rq_ctx = aead_request_ctx(req);\n\tstruct device *dev = tfm_ctx->dev;\n\tstruct zynqmp_aead_hw_req *hwreq;\n\tdma_addr_t dma_addr_data, dma_addr_hw_req;\n\tunsigned int data_size;\n\tunsigned int status;\n\tint ret;\n\tsize_t dma_size;\n\tchar *kbuf;\n\tint err;\n\n\tif (tfm_ctx->keysrc == ZYNQMP_AES_KUP_KEY)\n\t\tdma_size = req->cryptlen + ZYNQMP_AES_KEY_SIZE\n\t\t\t   + GCM_AES_IV_SIZE;\n\telse\n\t\tdma_size = req->cryptlen + GCM_AES_IV_SIZE;\n\n\tkbuf = dma_alloc_coherent(dev, dma_size, &dma_addr_data, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\thwreq = dma_alloc_coherent(dev, sizeof(struct zynqmp_aead_hw_req),\n\t\t\t\t   &dma_addr_hw_req, GFP_KERNEL);\n\tif (!hwreq) {\n\t\tdma_free_coherent(dev, dma_size, kbuf, dma_addr_data);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata_size = req->cryptlen;\n\tscatterwalk_map_and_copy(kbuf, req->src, 0, req->cryptlen, 0);\n\tmemcpy(kbuf + data_size, req->iv, GCM_AES_IV_SIZE);\n\n\thwreq->src = dma_addr_data;\n\thwreq->dst = dma_addr_data;\n\thwreq->iv = hwreq->src + data_size;\n\thwreq->keysrc = tfm_ctx->keysrc;\n\thwreq->op = rq_ctx->op;\n\n\tif (hwreq->op == ZYNQMP_AES_ENCRYPT)\n\t\thwreq->size = data_size;\n\telse\n\t\thwreq->size = data_size - ZYNQMP_AES_AUTH_SIZE;\n\n\tif (hwreq->keysrc == ZYNQMP_AES_KUP_KEY) {\n\t\tmemcpy(kbuf + data_size + GCM_AES_IV_SIZE,\n\t\t       tfm_ctx->key, ZYNQMP_AES_KEY_SIZE);\n\n\t\thwreq->key = hwreq->src + data_size + GCM_AES_IV_SIZE;\n\t} else {\n\t\thwreq->key = 0;\n\t}\n\n\tret = zynqmp_pm_aes_engine(dma_addr_hw_req, &status);\n\n\tif (ret) {\n\t\tdev_err(dev, \"ERROR: AES PM API failed\\n\");\n\t\terr = ret;\n\t} else if (status) {\n\t\tswitch (status) {\n\t\tcase ZYNQMP_AES_GCM_TAG_MISMATCH_ERR:\n\t\t\tdev_err(dev, \"ERROR: Gcm Tag mismatch\\n\");\n\t\t\tbreak;\n\t\tcase ZYNQMP_AES_WRONG_KEY_SRC_ERR:\n\t\t\tdev_err(dev, \"ERROR: Wrong KeySrc, enable secure mode\\n\");\n\t\t\tbreak;\n\t\tcase ZYNQMP_AES_PUF_NOT_PROGRAMMED:\n\t\t\tdev_err(dev, \"ERROR: PUF is not registered\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"ERROR: Unknown error\\n\");\n\t\t\tbreak;\n\t\t}\n\t\terr = -status;\n\t} else {\n\t\tif (hwreq->op == ZYNQMP_AES_ENCRYPT)\n\t\t\tdata_size = data_size + ZYNQMP_AES_AUTH_SIZE;\n\t\telse\n\t\t\tdata_size = data_size - ZYNQMP_AES_AUTH_SIZE;\n\n\t\tsg_copy_from_buffer(req->dst, sg_nents(req->dst),\n\t\t\t\t    kbuf, data_size);\n\t\terr = 0;\n\t}\n\n\tif (kbuf) {\n\t\tmemzero_explicit(kbuf, dma_size);\n\t\tdma_free_coherent(dev, dma_size, kbuf, dma_addr_data);\n\t}\n\tif (hwreq) {\n\t\tmemzero_explicit(hwreq, sizeof(struct zynqmp_aead_hw_req));\n\t\tdma_free_coherent(dev, sizeof(struct zynqmp_aead_hw_req),\n\t\t\t\t  hwreq, dma_addr_hw_req);\n\t}\n\treturn err;\n}\n\nstatic int zynqmp_fallback_check(struct zynqmp_aead_tfm_ctx *tfm_ctx,\n\t\t\t\t struct aead_request *req)\n{\n\tint need_fallback = 0;\n\tstruct zynqmp_aead_req_ctx *rq_ctx = aead_request_ctx(req);\n\n\tif (tfm_ctx->authsize != ZYNQMP_AES_AUTH_SIZE)\n\t\tneed_fallback = 1;\n\n\tif (tfm_ctx->keysrc == ZYNQMP_AES_KUP_KEY &&\n\t    tfm_ctx->keylen != ZYNQMP_AES_KEY_SIZE) {\n\t\tneed_fallback = 1;\n\t}\n\tif (req->assoclen != 0 ||\n\t    req->cryptlen < ZYNQMP_AES_MIN_INPUT_BLK_SIZE) {\n\t\tneed_fallback = 1;\n\t}\n\tif ((req->cryptlen % ZYNQMP_AES_WORD_LEN) != 0)\n\t\tneed_fallback = 1;\n\n\tif (rq_ctx->op == ZYNQMP_AES_DECRYPT &&\n\t    req->cryptlen <= ZYNQMP_AES_AUTH_SIZE) {\n\t\tneed_fallback = 1;\n\t}\n\treturn need_fallback;\n}\n\nstatic int zynqmp_handle_aes_req(struct crypto_engine *engine,\n\t\t\t\t void *req)\n{\n\tstruct aead_request *areq =\n\t\t\t\tcontainer_of(req, struct aead_request, base);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct zynqmp_aead_tfm_ctx *tfm_ctx = crypto_aead_ctx(aead);\n\tstruct zynqmp_aead_req_ctx *rq_ctx = aead_request_ctx(areq);\n\tstruct aead_request *subreq = aead_request_ctx(req);\n\tint need_fallback;\n\tint err;\n\n\tneed_fallback = zynqmp_fallback_check(tfm_ctx, areq);\n\n\tif (need_fallback) {\n\t\taead_request_set_tfm(subreq, tfm_ctx->fbk_cipher);\n\n\t\taead_request_set_callback(subreq, areq->base.flags,\n\t\t\t\t\t  NULL, NULL);\n\t\taead_request_set_crypt(subreq, areq->src, areq->dst,\n\t\t\t\t       areq->cryptlen, areq->iv);\n\t\taead_request_set_ad(subreq, areq->assoclen);\n\t\tif (rq_ctx->op == ZYNQMP_AES_ENCRYPT)\n\t\t\terr = crypto_aead_encrypt(subreq);\n\t\telse\n\t\t\terr = crypto_aead_decrypt(subreq);\n\t} else {\n\t\terr = zynqmp_aes_aead_cipher(areq);\n\t}\n\n\tcrypto_finalize_aead_request(engine, areq, err);\n\treturn 0;\n}\n\nstatic int zynqmp_aes_aead_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t\t\t  unsigned int keylen)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(aead);\n\tstruct zynqmp_aead_tfm_ctx *tfm_ctx =\n\t\t\t(struct zynqmp_aead_tfm_ctx *)crypto_tfm_ctx(tfm);\n\tunsigned char keysrc;\n\n\tif (keylen == ZYNQMP_KEY_SRC_SEL_KEY_LEN) {\n\t\tkeysrc = *key;\n\t\tif (keysrc == ZYNQMP_AES_KUP_KEY ||\n\t\t    keysrc == ZYNQMP_AES_DEV_KEY ||\n\t\t    keysrc == ZYNQMP_AES_PUF_KEY) {\n\t\t\ttfm_ctx->keysrc = (enum zynqmp_aead_keysrc)keysrc;\n\t\t} else {\n\t\t\ttfm_ctx->keylen = keylen;\n\t\t}\n\t} else {\n\t\ttfm_ctx->keylen = keylen;\n\t\tif (keylen == ZYNQMP_AES_KEY_SIZE) {\n\t\t\ttfm_ctx->keysrc = ZYNQMP_AES_KUP_KEY;\n\t\t\tmemcpy(tfm_ctx->key, key, keylen);\n\t\t}\n\t}\n\n\ttfm_ctx->fbk_cipher->base.crt_flags &= ~CRYPTO_TFM_REQ_MASK;\n\ttfm_ctx->fbk_cipher->base.crt_flags |= (aead->base.crt_flags &\n\t\t\t\t\tCRYPTO_TFM_REQ_MASK);\n\n\treturn crypto_aead_setkey(tfm_ctx->fbk_cipher, key, keylen);\n}\n\nstatic int zynqmp_aes_aead_setauthsize(struct crypto_aead *aead,\n\t\t\t\t       unsigned int authsize)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(aead);\n\tstruct zynqmp_aead_tfm_ctx *tfm_ctx =\n\t\t\t(struct zynqmp_aead_tfm_ctx *)crypto_tfm_ctx(tfm);\n\n\ttfm_ctx->authsize = authsize;\n\treturn crypto_aead_setauthsize(tfm_ctx->fbk_cipher, authsize);\n}\n\nstatic int zynqmp_aes_aead_encrypt(struct aead_request *req)\n{\n\tstruct zynqmp_aead_drv_ctx *drv_ctx;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct aead_alg *alg = crypto_aead_alg(aead);\n\tstruct zynqmp_aead_req_ctx *rq_ctx = aead_request_ctx(req);\n\n\trq_ctx->op = ZYNQMP_AES_ENCRYPT;\n\tdrv_ctx = container_of(alg, struct zynqmp_aead_drv_ctx, alg.aead.base);\n\n\treturn crypto_transfer_aead_request_to_engine(drv_ctx->engine, req);\n}\n\nstatic int zynqmp_aes_aead_decrypt(struct aead_request *req)\n{\n\tstruct zynqmp_aead_drv_ctx *drv_ctx;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct aead_alg *alg = crypto_aead_alg(aead);\n\tstruct zynqmp_aead_req_ctx *rq_ctx = aead_request_ctx(req);\n\n\trq_ctx->op = ZYNQMP_AES_DECRYPT;\n\tdrv_ctx = container_of(alg, struct zynqmp_aead_drv_ctx, alg.aead.base);\n\n\treturn crypto_transfer_aead_request_to_engine(drv_ctx->engine, req);\n}\n\nstatic int zynqmp_aes_aead_init(struct crypto_aead *aead)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(aead);\n\tstruct zynqmp_aead_tfm_ctx *tfm_ctx =\n\t\t(struct zynqmp_aead_tfm_ctx *)crypto_tfm_ctx(tfm);\n\tstruct zynqmp_aead_drv_ctx *drv_ctx;\n\tstruct aead_alg *alg = crypto_aead_alg(aead);\n\n\tdrv_ctx = container_of(alg, struct zynqmp_aead_drv_ctx, alg.aead.base);\n\ttfm_ctx->dev = drv_ctx->dev;\n\n\ttfm_ctx->fbk_cipher = crypto_alloc_aead(drv_ctx->alg.aead.base.base.cra_name,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK);\n\n\tif (IS_ERR(tfm_ctx->fbk_cipher)) {\n\t\tpr_err(\"%s() Error: failed to allocate fallback for %s\\n\",\n\t\t       __func__, drv_ctx->alg.aead.base.base.cra_name);\n\t\treturn PTR_ERR(tfm_ctx->fbk_cipher);\n\t}\n\n\tcrypto_aead_set_reqsize(aead,\n\t\t\t\tmax(sizeof(struct zynqmp_aead_req_ctx),\n\t\t\t\t    sizeof(struct aead_request) +\n\t\t\t\t    crypto_aead_reqsize(tfm_ctx->fbk_cipher)));\n\treturn 0;\n}\n\nstatic void zynqmp_aes_aead_exit(struct crypto_aead *aead)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(aead);\n\tstruct zynqmp_aead_tfm_ctx *tfm_ctx =\n\t\t\t(struct zynqmp_aead_tfm_ctx *)crypto_tfm_ctx(tfm);\n\n\tif (tfm_ctx->fbk_cipher) {\n\t\tcrypto_free_aead(tfm_ctx->fbk_cipher);\n\t\ttfm_ctx->fbk_cipher = NULL;\n\t}\n\tmemzero_explicit(tfm_ctx, sizeof(struct zynqmp_aead_tfm_ctx));\n}\n\nstatic struct zynqmp_aead_drv_ctx aes_drv_ctx = {\n\t.alg.aead.base = {\n\t\t.setkey\t\t= zynqmp_aes_aead_setkey,\n\t\t.setauthsize\t= zynqmp_aes_aead_setauthsize,\n\t\t.encrypt\t= zynqmp_aes_aead_encrypt,\n\t\t.decrypt\t= zynqmp_aes_aead_decrypt,\n\t\t.init\t\t= zynqmp_aes_aead_init,\n\t\t.exit\t\t= zynqmp_aes_aead_exit,\n\t\t.ivsize\t\t= GCM_AES_IV_SIZE,\n\t\t.maxauthsize\t= ZYNQMP_AES_AUTH_SIZE,\n\t\t.base = {\n\t\t.cra_name\t\t= \"gcm(aes)\",\n\t\t.cra_driver_name\t= \"xilinx-zynqmp-aes-gcm\",\n\t\t.cra_priority\t\t= 200,\n\t\t.cra_flags\t\t= CRYPTO_ALG_TYPE_AEAD |\n\t\t\t\t\t  CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK,\n\t\t.cra_blocksize\t\t= ZYNQMP_AES_BLK_SIZE,\n\t\t.cra_ctxsize\t\t= sizeof(struct zynqmp_aead_tfm_ctx),\n\t\t.cra_module\t\t= THIS_MODULE,\n\t\t}\n\t},\n\t.alg.aead.op = {\n\t\t.do_one_request = zynqmp_handle_aes_req,\n\t},\n};\n\nstatic int zynqmp_aes_aead_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint err;\n\n\t \n\tif (!aes_drv_ctx.dev)\n\t\taes_drv_ctx.dev = dev;\n\telse\n\t\treturn -ENODEV;\n\n\terr = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(ZYNQMP_DMA_BIT_MASK));\n\tif (err < 0) {\n\t\tdev_err(dev, \"No usable DMA configuration\\n\");\n\t\treturn err;\n\t}\n\n\taes_drv_ctx.engine = crypto_engine_alloc_init(dev, 1);\n\tif (!aes_drv_ctx.engine) {\n\t\tdev_err(dev, \"Cannot alloc AES engine\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_engine;\n\t}\n\n\terr = crypto_engine_start(aes_drv_ctx.engine);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot start AES engine\\n\");\n\t\tgoto err_engine;\n\t}\n\n\terr = crypto_engine_register_aead(&aes_drv_ctx.alg.aead);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Failed to register AEAD alg.\\n\");\n\t\tgoto err_aead;\n\t}\n\treturn 0;\n\nerr_aead:\n\tcrypto_engine_unregister_aead(&aes_drv_ctx.alg.aead);\n\nerr_engine:\n\tif (aes_drv_ctx.engine)\n\t\tcrypto_engine_exit(aes_drv_ctx.engine);\n\n\treturn err;\n}\n\nstatic int zynqmp_aes_aead_remove(struct platform_device *pdev)\n{\n\tcrypto_engine_exit(aes_drv_ctx.engine);\n\tcrypto_engine_unregister_aead(&aes_drv_ctx.alg.aead);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id zynqmp_aes_dt_ids[] = {\n\t{ .compatible = \"xlnx,zynqmp-aes\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, zynqmp_aes_dt_ids);\n\nstatic struct platform_driver zynqmp_aes_driver = {\n\t.probe\t= zynqmp_aes_aead_probe,\n\t.remove = zynqmp_aes_aead_remove,\n\t.driver = {\n\t\t.name\t\t= \"zynqmp-aes\",\n\t\t.of_match_table = zynqmp_aes_dt_ids,\n\t},\n};\n\nmodule_platform_driver(zynqmp_aes_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}