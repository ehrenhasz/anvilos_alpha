{
  "module_name": "zynqmp-sha.c",
  "hash_id": "8722e8386abc89ac9eefbb8dadda58676b19ff74f9c3df16910cc3480c1822bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/xilinx/zynqmp-sha.c",
  "human_readable_source": "\n \n#include <linux/cacheflush.h>\n#include <crypto/hash.h>\n#include <crypto/internal/hash.h>\n#include <crypto/sha3.h>\n#include <linux/crypto.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware/xlnx-zynqmp.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#define ZYNQMP_DMA_BIT_MASK\t\t32U\n#define ZYNQMP_DMA_ALLOC_FIXED_SIZE\t0x1000U\n\nenum zynqmp_sha_op {\n\tZYNQMP_SHA3_INIT = 1,\n\tZYNQMP_SHA3_UPDATE = 2,\n\tZYNQMP_SHA3_FINAL = 4,\n};\n\nstruct zynqmp_sha_drv_ctx {\n\tstruct shash_alg sha3_384;\n\tstruct device *dev;\n};\n\nstruct zynqmp_sha_tfm_ctx {\n\tstruct device *dev;\n\tstruct crypto_shash *fbk_tfm;\n};\n\nstruct zynqmp_sha_desc_ctx {\n\tstruct shash_desc fbk_req;\n};\n\nstatic dma_addr_t update_dma_addr, final_dma_addr;\nstatic char *ubuf, *fbuf;\n\nstatic int zynqmp_sha_init_tfm(struct crypto_shash *hash)\n{\n\tconst char *fallback_driver_name = crypto_shash_alg_name(hash);\n\tstruct zynqmp_sha_tfm_ctx *tfm_ctx = crypto_shash_ctx(hash);\n\tstruct shash_alg *alg = crypto_shash_alg(hash);\n\tstruct crypto_shash *fallback_tfm;\n\tstruct zynqmp_sha_drv_ctx *drv_ctx;\n\n\tdrv_ctx = container_of(alg, struct zynqmp_sha_drv_ctx, sha3_384);\n\ttfm_ctx->dev = drv_ctx->dev;\n\n\t \n\tfallback_tfm = crypto_alloc_shash(fallback_driver_name, 0,\n\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(fallback_tfm))\n\t\treturn PTR_ERR(fallback_tfm);\n\n\ttfm_ctx->fbk_tfm = fallback_tfm;\n\thash->descsize += crypto_shash_descsize(tfm_ctx->fbk_tfm);\n\n\treturn 0;\n}\n\nstatic void zynqmp_sha_exit_tfm(struct crypto_shash *hash)\n{\n\tstruct zynqmp_sha_tfm_ctx *tfm_ctx = crypto_shash_ctx(hash);\n\n\tif (tfm_ctx->fbk_tfm) {\n\t\tcrypto_free_shash(tfm_ctx->fbk_tfm);\n\t\ttfm_ctx->fbk_tfm = NULL;\n\t}\n\n\tmemzero_explicit(tfm_ctx, sizeof(struct zynqmp_sha_tfm_ctx));\n}\n\nstatic int zynqmp_sha_init(struct shash_desc *desc)\n{\n\tstruct zynqmp_sha_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct zynqmp_sha_tfm_ctx *tctx = crypto_shash_ctx(desc->tfm);\n\n\tdctx->fbk_req.tfm = tctx->fbk_tfm;\n\treturn crypto_shash_init(&dctx->fbk_req);\n}\n\nstatic int zynqmp_sha_update(struct shash_desc *desc, const u8 *data, unsigned int length)\n{\n\tstruct zynqmp_sha_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\treturn crypto_shash_update(&dctx->fbk_req, data, length);\n}\n\nstatic int zynqmp_sha_final(struct shash_desc *desc, u8 *out)\n{\n\tstruct zynqmp_sha_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\treturn crypto_shash_final(&dctx->fbk_req, out);\n}\n\nstatic int zynqmp_sha_finup(struct shash_desc *desc, const u8 *data, unsigned int length, u8 *out)\n{\n\tstruct zynqmp_sha_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\treturn crypto_shash_finup(&dctx->fbk_req, data, length, out);\n}\n\nstatic int zynqmp_sha_import(struct shash_desc *desc, const void *in)\n{\n\tstruct zynqmp_sha_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct zynqmp_sha_tfm_ctx *tctx = crypto_shash_ctx(desc->tfm);\n\n\tdctx->fbk_req.tfm = tctx->fbk_tfm;\n\treturn crypto_shash_import(&dctx->fbk_req, in);\n}\n\nstatic int zynqmp_sha_export(struct shash_desc *desc, void *out)\n{\n\tstruct zynqmp_sha_desc_ctx *dctx = shash_desc_ctx(desc);\n\n\treturn crypto_shash_export(&dctx->fbk_req, out);\n}\n\nstatic int zynqmp_sha_digest(struct shash_desc *desc, const u8 *data, unsigned int len, u8 *out)\n{\n\tunsigned int remaining_len = len;\n\tint update_size;\n\tint ret;\n\n\tret = zynqmp_pm_sha_hash(0, 0, ZYNQMP_SHA3_INIT);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (remaining_len != 0) {\n\t\tmemzero_explicit(ubuf, ZYNQMP_DMA_ALLOC_FIXED_SIZE);\n\t\tif (remaining_len >= ZYNQMP_DMA_ALLOC_FIXED_SIZE) {\n\t\t\tupdate_size = ZYNQMP_DMA_ALLOC_FIXED_SIZE;\n\t\t\tremaining_len -= ZYNQMP_DMA_ALLOC_FIXED_SIZE;\n\t\t} else {\n\t\t\tupdate_size = remaining_len;\n\t\t\tremaining_len = 0;\n\t\t}\n\t\tmemcpy(ubuf, data, update_size);\n\t\tflush_icache_range((unsigned long)ubuf, (unsigned long)ubuf + update_size);\n\t\tret = zynqmp_pm_sha_hash(update_dma_addr, update_size, ZYNQMP_SHA3_UPDATE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata += update_size;\n\t}\n\n\tret = zynqmp_pm_sha_hash(final_dma_addr, SHA3_384_DIGEST_SIZE, ZYNQMP_SHA3_FINAL);\n\tmemcpy(out, fbuf, SHA3_384_DIGEST_SIZE);\n\tmemzero_explicit(fbuf, SHA3_384_DIGEST_SIZE);\n\n\treturn ret;\n}\n\nstatic struct zynqmp_sha_drv_ctx sha3_drv_ctx = {\n\t.sha3_384 = {\n\t\t.init = zynqmp_sha_init,\n\t\t.update = zynqmp_sha_update,\n\t\t.final = zynqmp_sha_final,\n\t\t.finup = zynqmp_sha_finup,\n\t\t.digest = zynqmp_sha_digest,\n\t\t.export = zynqmp_sha_export,\n\t\t.import = zynqmp_sha_import,\n\t\t.init_tfm = zynqmp_sha_init_tfm,\n\t\t.exit_tfm = zynqmp_sha_exit_tfm,\n\t\t.descsize = sizeof(struct zynqmp_sha_desc_ctx),\n\t\t.statesize = sizeof(struct sha3_state),\n\t\t.digestsize = SHA3_384_DIGEST_SIZE,\n\t\t.base = {\n\t\t\t.cra_name = \"sha3-384\",\n\t\t\t.cra_driver_name = \"zynqmp-sha3-384\",\n\t\t\t.cra_priority = 300,\n\t\t\t.cra_flags = CRYPTO_ALG_KERN_DRIVER_ONLY |\n\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY |\n\t\t\t\t     CRYPTO_ALG_NEED_FALLBACK,\n\t\t\t.cra_blocksize = SHA3_384_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct zynqmp_sha_tfm_ctx),\n\t\t\t.cra_alignmask = 3,\n\t\t\t.cra_module = THIS_MODULE,\n\t\t}\n\t}\n};\n\nstatic int zynqmp_sha_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint err;\n\tu32 v;\n\n\t \n\terr = zynqmp_pm_get_api_version(&v);\n\tif (err)\n\t\treturn err;\n\n\n\terr = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(ZYNQMP_DMA_BIT_MASK));\n\tif (err < 0) {\n\t\tdev_err(dev, \"No usable DMA configuration\\n\");\n\t\treturn err;\n\t}\n\n\terr = crypto_register_shash(&sha3_drv_ctx.sha3_384);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Failed to register shash alg.\\n\");\n\t\treturn err;\n\t}\n\n\tsha3_drv_ctx.dev = dev;\n\tplatform_set_drvdata(pdev, &sha3_drv_ctx);\n\n\tubuf = dma_alloc_coherent(dev, ZYNQMP_DMA_ALLOC_FIXED_SIZE, &update_dma_addr, GFP_KERNEL);\n\tif (!ubuf) {\n\t\terr = -ENOMEM;\n\t\tgoto err_shash;\n\t}\n\n\tfbuf = dma_alloc_coherent(dev, SHA3_384_DIGEST_SIZE, &final_dma_addr, GFP_KERNEL);\n\tif (!fbuf) {\n\t\terr = -ENOMEM;\n\t\tgoto err_mem;\n\t}\n\n\treturn 0;\n\nerr_mem:\n\tdma_free_coherent(sha3_drv_ctx.dev, ZYNQMP_DMA_ALLOC_FIXED_SIZE, ubuf, update_dma_addr);\n\nerr_shash:\n\tcrypto_unregister_shash(&sha3_drv_ctx.sha3_384);\n\n\treturn err;\n}\n\nstatic int zynqmp_sha_remove(struct platform_device *pdev)\n{\n\tsha3_drv_ctx.dev = platform_get_drvdata(pdev);\n\n\tdma_free_coherent(sha3_drv_ctx.dev, ZYNQMP_DMA_ALLOC_FIXED_SIZE, ubuf, update_dma_addr);\n\tdma_free_coherent(sha3_drv_ctx.dev, SHA3_384_DIGEST_SIZE, fbuf, final_dma_addr);\n\tcrypto_unregister_shash(&sha3_drv_ctx.sha3_384);\n\n\treturn 0;\n}\n\nstatic struct platform_driver zynqmp_sha_driver = {\n\t.probe = zynqmp_sha_probe,\n\t.remove = zynqmp_sha_remove,\n\t.driver = {\n\t\t.name = \"zynqmp-sha3-384\",\n\t},\n};\n\nmodule_platform_driver(zynqmp_sha_driver);\nMODULE_DESCRIPTION(\"ZynqMP SHA3 hardware acceleration support.\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Harsha <harsha.harsha@xilinx.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}