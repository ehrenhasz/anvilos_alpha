{
  "module_name": "qcom-rng.c",
  "hash_id": "58222218332561f77651234643b68cf18ef78fa1ac55953d488934c07b7fdd15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/qcom-rng.c",
  "human_readable_source": "\n\n\n\n\n#include <crypto/internal/rng.h>\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/crypto.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n \n#define PRNG_DATA_OUT\t\t0x0000\n#define PRNG_STATUS\t\t0x0004\n#define PRNG_LFSR_CFG\t\t0x0100\n#define PRNG_CONFIG\t\t0x0104\n\n \n#define PRNG_LFSR_CFG_MASK\t0x0000ffff\n#define PRNG_LFSR_CFG_CLOCKS\t0x0000dddd\n#define PRNG_CONFIG_HW_ENABLE\tBIT(1)\n#define PRNG_STATUS_DATA_AVAIL\tBIT(0)\n\n#define WORD_SZ\t\t\t4\n\nstruct qcom_rng {\n\tstruct mutex lock;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tunsigned int skip_init;\n};\n\nstruct qcom_rng_ctx {\n\tstruct qcom_rng *rng;\n};\n\nstatic struct qcom_rng *qcom_rng_dev;\n\nstatic int qcom_rng_read(struct qcom_rng *rng, u8 *data, unsigned int max)\n{\n\tunsigned int currsize = 0;\n\tu32 val;\n\tint ret;\n\n\t \n\tdo {\n\t\tret = readl_poll_timeout(rng->base + PRNG_STATUS, val,\n\t\t\t\t\t val & PRNG_STATUS_DATA_AVAIL,\n\t\t\t\t\t 200, 10000);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = readl_relaxed(rng->base + PRNG_DATA_OUT);\n\t\tif (!val)\n\t\t\treturn -EINVAL;\n\n\t\tif ((max - currsize) >= WORD_SZ) {\n\t\t\tmemcpy(data, &val, WORD_SZ);\n\t\t\tdata += WORD_SZ;\n\t\t\tcurrsize += WORD_SZ;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(data, &val, max - currsize);\n\t\t\tbreak;\n\t\t}\n\t} while (currsize < max);\n\n\treturn 0;\n}\n\nstatic int qcom_rng_generate(struct crypto_rng *tfm,\n\t\t\t     const u8 *src, unsigned int slen,\n\t\t\t     u8 *dstn, unsigned int dlen)\n{\n\tstruct qcom_rng_ctx *ctx = crypto_rng_ctx(tfm);\n\tstruct qcom_rng *rng = ctx->rng;\n\tint ret;\n\n\tret = clk_prepare_enable(rng->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&rng->lock);\n\n\tret = qcom_rng_read(rng, dstn, dlen);\n\n\tmutex_unlock(&rng->lock);\n\tclk_disable_unprepare(rng->clk);\n\n\treturn ret;\n}\n\nstatic int qcom_rng_seed(struct crypto_rng *tfm, const u8 *seed,\n\t\t\t unsigned int slen)\n{\n\treturn 0;\n}\n\nstatic int qcom_rng_enable(struct qcom_rng *rng)\n{\n\tu32 val;\n\tint ret;\n\n\tret = clk_prepare_enable(rng->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = readl_relaxed(rng->base + PRNG_CONFIG);\n\tif (val & PRNG_CONFIG_HW_ENABLE)\n\t\tgoto already_enabled;\n\n\tval = readl_relaxed(rng->base + PRNG_LFSR_CFG);\n\tval &= ~PRNG_LFSR_CFG_MASK;\n\tval |= PRNG_LFSR_CFG_CLOCKS;\n\twritel(val, rng->base + PRNG_LFSR_CFG);\n\n\tval = readl_relaxed(rng->base + PRNG_CONFIG);\n\tval |= PRNG_CONFIG_HW_ENABLE;\n\twritel(val, rng->base + PRNG_CONFIG);\n\nalready_enabled:\n\tclk_disable_unprepare(rng->clk);\n\n\treturn 0;\n}\n\nstatic int qcom_rng_init(struct crypto_tfm *tfm)\n{\n\tstruct qcom_rng_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tctx->rng = qcom_rng_dev;\n\n\tif (!ctx->rng->skip_init)\n\t\treturn qcom_rng_enable(ctx->rng);\n\n\treturn 0;\n}\n\nstatic struct rng_alg qcom_rng_alg = {\n\t.generate\t= qcom_rng_generate,\n\t.seed\t\t= qcom_rng_seed,\n\t.seedsize\t= 0,\n\t.base\t\t= {\n\t\t.cra_name\t\t= \"stdrng\",\n\t\t.cra_driver_name\t= \"qcom-rng\",\n\t\t.cra_flags\t\t= CRYPTO_ALG_TYPE_RNG,\n\t\t.cra_priority\t\t= 300,\n\t\t.cra_ctxsize\t\t= sizeof(struct qcom_rng_ctx),\n\t\t.cra_module\t\t= THIS_MODULE,\n\t\t.cra_init\t\t= qcom_rng_init,\n\t}\n};\n\nstatic int qcom_rng_probe(struct platform_device *pdev)\n{\n\tstruct qcom_rng *rng;\n\tint ret;\n\n\trng = devm_kzalloc(&pdev->dev, sizeof(*rng), GFP_KERNEL);\n\tif (!rng)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, rng);\n\tmutex_init(&rng->lock);\n\n\trng->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rng->base))\n\t\treturn PTR_ERR(rng->base);\n\n\trng->clk = devm_clk_get_optional(&pdev->dev, \"core\");\n\tif (IS_ERR(rng->clk))\n\t\treturn PTR_ERR(rng->clk);\n\n\trng->skip_init = (unsigned long)device_get_match_data(&pdev->dev);\n\n\tqcom_rng_dev = rng;\n\tret = crypto_register_rng(&qcom_rng_alg);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Register crypto rng failed: %d\\n\", ret);\n\t\tqcom_rng_dev = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int qcom_rng_remove(struct platform_device *pdev)\n{\n\tcrypto_unregister_rng(&qcom_rng_alg);\n\n\tqcom_rng_dev = NULL;\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id __maybe_unused qcom_rng_acpi_match[] = {\n\t{ .id = \"QCOM8160\", .driver_data = 1 },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, qcom_rng_acpi_match);\n\nstatic const struct of_device_id __maybe_unused qcom_rng_of_match[] = {\n\t{ .compatible = \"qcom,prng\", .data = (void *)0},\n\t{ .compatible = \"qcom,prng-ee\", .data = (void *)1},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qcom_rng_of_match);\n\nstatic struct platform_driver qcom_rng_driver = {\n\t.probe = qcom_rng_probe,\n\t.remove =  qcom_rng_remove,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = of_match_ptr(qcom_rng_of_match),\n\t\t.acpi_match_table = ACPI_PTR(qcom_rng_acpi_match),\n\t}\n};\nmodule_platform_driver(qcom_rng_driver);\n\nMODULE_ALIAS(\"platform:\" KBUILD_MODNAME);\nMODULE_DESCRIPTION(\"Qualcomm random number generator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}