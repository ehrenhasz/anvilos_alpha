{
  "module_name": "virtio_crypto_core.c",
  "hash_id": "e663e1d60a99e299e1d66735fa83d4ebb10e516f1245bd03e70dbfd09a8013a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/virtio/virtio_crypto_core.c",
  "human_readable_source": "\n  \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/virtio_config.h>\n#include <linux/cpu.h>\n\n#include <uapi/linux/virtio_crypto.h>\n#include \"virtio_crypto_common.h\"\n\n\nvoid\nvirtcrypto_clear_request(struct virtio_crypto_request *vc_req)\n{\n\tif (vc_req) {\n\t\tkfree_sensitive(vc_req->req_data);\n\t\tkfree(vc_req->sgs);\n\t}\n}\n\nstatic void virtio_crypto_ctrlq_callback(struct virtio_crypto_ctrl_request *vc_ctrl_req)\n{\n\tcomplete(&vc_ctrl_req->compl);\n}\n\nstatic void virtcrypto_ctrlq_callback(struct virtqueue *vq)\n{\n\tstruct virtio_crypto *vcrypto = vq->vdev->priv;\n\tstruct virtio_crypto_ctrl_request *vc_ctrl_req;\n\tunsigned long flags;\n\tunsigned int len;\n\n\tspin_lock_irqsave(&vcrypto->ctrl_lock, flags);\n\tdo {\n\t\tvirtqueue_disable_cb(vq);\n\t\twhile ((vc_ctrl_req = virtqueue_get_buf(vq, &len)) != NULL) {\n\t\t\tspin_unlock_irqrestore(&vcrypto->ctrl_lock, flags);\n\t\t\tvirtio_crypto_ctrlq_callback(vc_ctrl_req);\n\t\t\tspin_lock_irqsave(&vcrypto->ctrl_lock, flags);\n\t\t}\n\t\tif (unlikely(virtqueue_is_broken(vq)))\n\t\t\tbreak;\n\t} while (!virtqueue_enable_cb(vq));\n\tspin_unlock_irqrestore(&vcrypto->ctrl_lock, flags);\n}\n\nint virtio_crypto_ctrl_vq_request(struct virtio_crypto *vcrypto, struct scatterlist *sgs[],\n\t\tunsigned int out_sgs, unsigned int in_sgs,\n\t\tstruct virtio_crypto_ctrl_request *vc_ctrl_req)\n{\n\tint err;\n\tunsigned long flags;\n\n\tinit_completion(&vc_ctrl_req->compl);\n\n\tspin_lock_irqsave(&vcrypto->ctrl_lock, flags);\n\terr = virtqueue_add_sgs(vcrypto->ctrl_vq, sgs, out_sgs, in_sgs, vc_ctrl_req, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tspin_unlock_irqrestore(&vcrypto->ctrl_lock, flags);\n\t\treturn err;\n\t}\n\n\tvirtqueue_kick(vcrypto->ctrl_vq);\n\tspin_unlock_irqrestore(&vcrypto->ctrl_lock, flags);\n\n\twait_for_completion(&vc_ctrl_req->compl);\n\n\treturn 0;\n}\n\nstatic void virtcrypto_done_task(unsigned long data)\n{\n\tstruct data_queue *data_vq = (struct data_queue *)data;\n\tstruct virtqueue *vq = data_vq->vq;\n\tstruct virtio_crypto_request *vc_req;\n\tunsigned int len;\n\n\tdo {\n\t\tvirtqueue_disable_cb(vq);\n\t\twhile ((vc_req = virtqueue_get_buf(vq, &len)) != NULL) {\n\t\t\tif (vc_req->alg_cb)\n\t\t\t\tvc_req->alg_cb(vc_req, len);\n\t\t}\n\t} while (!virtqueue_enable_cb(vq));\n}\n\nstatic void virtcrypto_dataq_callback(struct virtqueue *vq)\n{\n\tstruct virtio_crypto *vcrypto = vq->vdev->priv;\n\tstruct data_queue *dq = &vcrypto->data_vq[vq->index];\n\n\ttasklet_schedule(&dq->done_task);\n}\n\nstatic int virtcrypto_find_vqs(struct virtio_crypto *vi)\n{\n\tvq_callback_t **callbacks;\n\tstruct virtqueue **vqs;\n\tint ret = -ENOMEM;\n\tint i, total_vqs;\n\tconst char **names;\n\tstruct device *dev = &vi->vdev->dev;\n\n\t \n\ttotal_vqs = vi->max_data_queues + 1;\n\n\t \n\tvqs = kcalloc(total_vqs, sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs)\n\t\tgoto err_vq;\n\tcallbacks = kcalloc(total_vqs, sizeof(*callbacks), GFP_KERNEL);\n\tif (!callbacks)\n\t\tgoto err_callback;\n\tnames = kcalloc(total_vqs, sizeof(*names), GFP_KERNEL);\n\tif (!names)\n\t\tgoto err_names;\n\n\t \n\tcallbacks[total_vqs - 1] = virtcrypto_ctrlq_callback;\n\tnames[total_vqs - 1] = \"controlq\";\n\n\t \n\tfor (i = 0; i < vi->max_data_queues; i++) {\n\t\tcallbacks[i] = virtcrypto_dataq_callback;\n\t\tsnprintf(vi->data_vq[i].name, sizeof(vi->data_vq[i].name),\n\t\t\t\t\"dataq.%d\", i);\n\t\tnames[i] = vi->data_vq[i].name;\n\t}\n\n\tret = virtio_find_vqs(vi->vdev, total_vqs, vqs, callbacks, names, NULL);\n\tif (ret)\n\t\tgoto err_find;\n\n\tvi->ctrl_vq = vqs[total_vqs - 1];\n\n\tfor (i = 0; i < vi->max_data_queues; i++) {\n\t\tspin_lock_init(&vi->data_vq[i].lock);\n\t\tvi->data_vq[i].vq = vqs[i];\n\t\t \n\t\tvi->data_vq[i].engine = crypto_engine_alloc_init_and_set(dev, true, NULL, true,\n\t\t\t\t\t\tvirtqueue_get_vring_size(vqs[i]));\n\t\tif (!vi->data_vq[i].engine) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_engine;\n\t\t}\n\t\ttasklet_init(&vi->data_vq[i].done_task, virtcrypto_done_task,\n\t\t\t\t(unsigned long)&vi->data_vq[i]);\n\t}\n\n\tkfree(names);\n\tkfree(callbacks);\n\tkfree(vqs);\n\n\treturn 0;\n\nerr_engine:\nerr_find:\n\tkfree(names);\nerr_names:\n\tkfree(callbacks);\nerr_callback:\n\tkfree(vqs);\nerr_vq:\n\treturn ret;\n}\n\nstatic int virtcrypto_alloc_queues(struct virtio_crypto *vi)\n{\n\tvi->data_vq = kcalloc(vi->max_data_queues, sizeof(*vi->data_vq),\n\t\t\t\tGFP_KERNEL);\n\tif (!vi->data_vq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void virtcrypto_clean_affinity(struct virtio_crypto *vi, long hcpu)\n{\n\tint i;\n\n\tif (vi->affinity_hint_set) {\n\t\tfor (i = 0; i < vi->max_data_queues; i++)\n\t\t\tvirtqueue_set_affinity(vi->data_vq[i].vq, NULL);\n\n\t\tvi->affinity_hint_set = false;\n\t}\n}\n\nstatic void virtcrypto_set_affinity(struct virtio_crypto *vcrypto)\n{\n\tint i = 0;\n\tint cpu;\n\n\t \n\tif (vcrypto->curr_queue == 1 || vcrypto->max_data_queues == 1) {\n\t\tvirtcrypto_clean_affinity(vcrypto, -1);\n\t\treturn;\n\t}\n\n\t \n\tfor_each_online_cpu(cpu) {\n\t\tvirtqueue_set_affinity(vcrypto->data_vq[i].vq, cpumask_of(cpu));\n\t\tif (++i >= vcrypto->max_data_queues)\n\t\t\tbreak;\n\t}\n\n\tvcrypto->affinity_hint_set = true;\n}\n\nstatic void virtcrypto_free_queues(struct virtio_crypto *vi)\n{\n\tkfree(vi->data_vq);\n}\n\nstatic int virtcrypto_init_vqs(struct virtio_crypto *vi)\n{\n\tint ret;\n\n\t \n\tret = virtcrypto_alloc_queues(vi);\n\tif (ret)\n\t\tgoto err;\n\n\tret = virtcrypto_find_vqs(vi);\n\tif (ret)\n\t\tgoto err_free;\n\n\tcpus_read_lock();\n\tvirtcrypto_set_affinity(vi);\n\tcpus_read_unlock();\n\n\treturn 0;\n\nerr_free:\n\tvirtcrypto_free_queues(vi);\nerr:\n\treturn ret;\n}\n\nstatic int virtcrypto_update_status(struct virtio_crypto *vcrypto)\n{\n\tu32 status;\n\tint err;\n\n\tvirtio_cread_le(vcrypto->vdev,\n\t\t\tstruct virtio_crypto_config, status, &status);\n\n\t \n\tif (status & (~VIRTIO_CRYPTO_S_HW_READY)) {\n\t\tdev_warn(&vcrypto->vdev->dev,\n\t\t\t\t\"Unknown status bits: 0x%x\\n\", status);\n\n\t\tvirtio_break_device(vcrypto->vdev);\n\t\treturn -EPERM;\n\t}\n\n\tif (vcrypto->status == status)\n\t\treturn 0;\n\n\tvcrypto->status = status;\n\n\tif (vcrypto->status & VIRTIO_CRYPTO_S_HW_READY) {\n\t\terr = virtcrypto_dev_start(vcrypto);\n\t\tif (err) {\n\t\t\tdev_err(&vcrypto->vdev->dev,\n\t\t\t\t\"Failed to start virtio crypto device.\\n\");\n\n\t\t\treturn -EPERM;\n\t\t}\n\t\tdev_info(&vcrypto->vdev->dev, \"Accelerator device is ready\\n\");\n\t} else {\n\t\tvirtcrypto_dev_stop(vcrypto);\n\t\tdev_info(&vcrypto->vdev->dev, \"Accelerator is not ready\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int virtcrypto_start_crypto_engines(struct virtio_crypto *vcrypto)\n{\n\tint32_t i;\n\tint ret;\n\n\tfor (i = 0; i < vcrypto->max_data_queues; i++) {\n\t\tif (vcrypto->data_vq[i].engine) {\n\t\t\tret = crypto_engine_start(vcrypto->data_vq[i].engine);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0)\n\t\tif (vcrypto->data_vq[i].engine)\n\t\t\tcrypto_engine_exit(vcrypto->data_vq[i].engine);\n\n\treturn ret;\n}\n\nstatic void virtcrypto_clear_crypto_engines(struct virtio_crypto *vcrypto)\n{\n\tu32 i;\n\n\tfor (i = 0; i < vcrypto->max_data_queues; i++)\n\t\tif (vcrypto->data_vq[i].engine)\n\t\t\tcrypto_engine_exit(vcrypto->data_vq[i].engine);\n}\n\nstatic void virtcrypto_del_vqs(struct virtio_crypto *vcrypto)\n{\n\tstruct virtio_device *vdev = vcrypto->vdev;\n\n\tvirtcrypto_clean_affinity(vcrypto, -1);\n\n\tvdev->config->del_vqs(vdev);\n\n\tvirtcrypto_free_queues(vcrypto);\n}\n\nstatic void vcrypto_config_changed_work(struct work_struct *work)\n{\n\tstruct virtio_crypto *vcrypto =\n\t\tcontainer_of(work, struct virtio_crypto, config_work);\n\n\tvirtcrypto_update_status(vcrypto);\n}\n\nstatic int virtcrypto_probe(struct virtio_device *vdev)\n{\n\tint err = -EFAULT;\n\tstruct virtio_crypto *vcrypto;\n\tu32 max_data_queues = 0, max_cipher_key_len = 0;\n\tu32 max_auth_key_len = 0;\n\tu64 max_size = 0;\n\tu32 cipher_algo_l = 0;\n\tu32 cipher_algo_h = 0;\n\tu32 hash_algo = 0;\n\tu32 mac_algo_l = 0;\n\tu32 mac_algo_h = 0;\n\tu32 aead_algo = 0;\n\tu32 akcipher_algo = 0;\n\tu32 crypto_services = 0;\n\n\tif (!virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\treturn -ENODEV;\n\n\tif (!vdev->config->get) {\n\t\tdev_err(&vdev->dev, \"%s failure: config access disabled\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_possible_nodes() > 1 && dev_to_node(&vdev->dev) < 0) {\n\t\t \n\t\tdev_err(&vdev->dev, \"Invalid NUMA configuration.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvcrypto = kzalloc_node(sizeof(*vcrypto), GFP_KERNEL,\n\t\t\t\t\tdev_to_node(&vdev->dev));\n\tif (!vcrypto)\n\t\treturn -ENOMEM;\n\n\tvirtio_cread_le(vdev, struct virtio_crypto_config,\n\t\t\tmax_dataqueues, &max_data_queues);\n\tif (max_data_queues < 1)\n\t\tmax_data_queues = 1;\n\n\tvirtio_cread_le(vdev, struct virtio_crypto_config,\n\t\t\tmax_cipher_key_len, &max_cipher_key_len);\n\tvirtio_cread_le(vdev, struct virtio_crypto_config,\n\t\t\tmax_auth_key_len, &max_auth_key_len);\n\tvirtio_cread_le(vdev, struct virtio_crypto_config,\n\t\t\tmax_size, &max_size);\n\tvirtio_cread_le(vdev, struct virtio_crypto_config,\n\t\t\tcrypto_services, &crypto_services);\n\tvirtio_cread_le(vdev, struct virtio_crypto_config,\n\t\t\tcipher_algo_l, &cipher_algo_l);\n\tvirtio_cread_le(vdev, struct virtio_crypto_config,\n\t\t\tcipher_algo_h, &cipher_algo_h);\n\tvirtio_cread_le(vdev, struct virtio_crypto_config,\n\t\t\thash_algo, &hash_algo);\n\tvirtio_cread_le(vdev, struct virtio_crypto_config,\n\t\t\tmac_algo_l, &mac_algo_l);\n\tvirtio_cread_le(vdev, struct virtio_crypto_config,\n\t\t\tmac_algo_h, &mac_algo_h);\n\tvirtio_cread_le(vdev, struct virtio_crypto_config,\n\t\t\taead_algo, &aead_algo);\n\tif (crypto_services & (1 << VIRTIO_CRYPTO_SERVICE_AKCIPHER))\n\t\tvirtio_cread_le(vdev, struct virtio_crypto_config,\n\t\t\t\takcipher_algo, &akcipher_algo);\n\n\t \n\terr = virtcrypto_devmgr_add_dev(vcrypto);\n\tif (err) {\n\t\tdev_err(&vdev->dev, \"Failed to add new virtio crypto device.\\n\");\n\t\tgoto free;\n\t}\n\tvcrypto->owner = THIS_MODULE;\n\tvcrypto = vdev->priv = vcrypto;\n\tvcrypto->vdev = vdev;\n\n\tspin_lock_init(&vcrypto->ctrl_lock);\n\n\t \n\tvcrypto->curr_queue = 1;\n\tvcrypto->max_data_queues = max_data_queues;\n\tvcrypto->max_cipher_key_len = max_cipher_key_len;\n\tvcrypto->max_auth_key_len = max_auth_key_len;\n\tvcrypto->max_size = max_size;\n\tvcrypto->crypto_services = crypto_services;\n\tvcrypto->cipher_algo_l = cipher_algo_l;\n\tvcrypto->cipher_algo_h = cipher_algo_h;\n\tvcrypto->mac_algo_l = mac_algo_l;\n\tvcrypto->mac_algo_h = mac_algo_h;\n\tvcrypto->hash_algo = hash_algo;\n\tvcrypto->aead_algo = aead_algo;\n\tvcrypto->akcipher_algo = akcipher_algo;\n\n\tdev_info(&vdev->dev,\n\t\t\"max_queues: %u, max_cipher_key_len: %u, max_auth_key_len: %u, max_size 0x%llx\\n\",\n\t\tvcrypto->max_data_queues,\n\t\tvcrypto->max_cipher_key_len,\n\t\tvcrypto->max_auth_key_len,\n\t\tvcrypto->max_size);\n\n\terr = virtcrypto_init_vqs(vcrypto);\n\tif (err) {\n\t\tdev_err(&vdev->dev, \"Failed to initialize vqs.\\n\");\n\t\tgoto free_dev;\n\t}\n\n\terr = virtcrypto_start_crypto_engines(vcrypto);\n\tif (err)\n\t\tgoto free_vqs;\n\n\tvirtio_device_ready(vdev);\n\n\terr = virtcrypto_update_status(vcrypto);\n\tif (err)\n\t\tgoto free_engines;\n\n\tINIT_WORK(&vcrypto->config_work, vcrypto_config_changed_work);\n\n\treturn 0;\n\nfree_engines:\n\tvirtcrypto_clear_crypto_engines(vcrypto);\nfree_vqs:\n\tvirtio_reset_device(vdev);\n\tvirtcrypto_del_vqs(vcrypto);\nfree_dev:\n\tvirtcrypto_devmgr_rm_dev(vcrypto);\nfree:\n\tkfree(vcrypto);\n\treturn err;\n}\n\nstatic void virtcrypto_free_unused_reqs(struct virtio_crypto *vcrypto)\n{\n\tstruct virtio_crypto_request *vc_req;\n\tint i;\n\tstruct virtqueue *vq;\n\n\tfor (i = 0; i < vcrypto->max_data_queues; i++) {\n\t\tvq = vcrypto->data_vq[i].vq;\n\t\twhile ((vc_req = virtqueue_detach_unused_buf(vq)) != NULL) {\n\t\t\tkfree(vc_req->req_data);\n\t\t\tkfree(vc_req->sgs);\n\t\t}\n\t\tcond_resched();\n\t}\n}\n\nstatic void virtcrypto_remove(struct virtio_device *vdev)\n{\n\tstruct virtio_crypto *vcrypto = vdev->priv;\n\tint i;\n\n\tdev_info(&vdev->dev, \"Start virtcrypto_remove.\\n\");\n\n\tflush_work(&vcrypto->config_work);\n\tif (virtcrypto_dev_started(vcrypto))\n\t\tvirtcrypto_dev_stop(vcrypto);\n\tfor (i = 0; i < vcrypto->max_data_queues; i++)\n\t\ttasklet_kill(&vcrypto->data_vq[i].done_task);\n\tvirtio_reset_device(vdev);\n\tvirtcrypto_free_unused_reqs(vcrypto);\n\tvirtcrypto_clear_crypto_engines(vcrypto);\n\tvirtcrypto_del_vqs(vcrypto);\n\tvirtcrypto_devmgr_rm_dev(vcrypto);\n\tkfree(vcrypto);\n}\n\nstatic void virtcrypto_config_changed(struct virtio_device *vdev)\n{\n\tstruct virtio_crypto *vcrypto = vdev->priv;\n\n\tschedule_work(&vcrypto->config_work);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int virtcrypto_freeze(struct virtio_device *vdev)\n{\n\tstruct virtio_crypto *vcrypto = vdev->priv;\n\n\tflush_work(&vcrypto->config_work);\n\tvirtio_reset_device(vdev);\n\tvirtcrypto_free_unused_reqs(vcrypto);\n\tif (virtcrypto_dev_started(vcrypto))\n\t\tvirtcrypto_dev_stop(vcrypto);\n\n\tvirtcrypto_clear_crypto_engines(vcrypto);\n\tvirtcrypto_del_vqs(vcrypto);\n\treturn 0;\n}\n\nstatic int virtcrypto_restore(struct virtio_device *vdev)\n{\n\tstruct virtio_crypto *vcrypto = vdev->priv;\n\tint err;\n\n\terr = virtcrypto_init_vqs(vcrypto);\n\tif (err)\n\t\treturn err;\n\n\terr = virtcrypto_start_crypto_engines(vcrypto);\n\tif (err)\n\t\tgoto free_vqs;\n\n\tvirtio_device_ready(vdev);\n\n\terr = virtcrypto_dev_start(vcrypto);\n\tif (err) {\n\t\tdev_err(&vdev->dev, \"Failed to start virtio crypto device.\\n\");\n\t\tgoto free_engines;\n\t}\n\n\treturn 0;\n\nfree_engines:\n\tvirtcrypto_clear_crypto_engines(vcrypto);\nfree_vqs:\n\tvirtio_reset_device(vdev);\n\tvirtcrypto_del_vqs(vcrypto);\n\treturn err;\n}\n#endif\n\nstatic const unsigned int features[] = {\n\t \n};\n\nstatic const struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_CRYPTO, VIRTIO_DEV_ANY_ID },\n\t{ 0 },\n};\n\nstatic struct virtio_driver virtio_crypto_driver = {\n\t.driver.name         = KBUILD_MODNAME,\n\t.driver.owner        = THIS_MODULE,\n\t.feature_table       = features,\n\t.feature_table_size  = ARRAY_SIZE(features),\n\t.id_table            = id_table,\n\t.probe               = virtcrypto_probe,\n\t.remove              = virtcrypto_remove,\n\t.config_changed = virtcrypto_config_changed,\n#ifdef CONFIG_PM_SLEEP\n\t.freeze = virtcrypto_freeze,\n\t.restore = virtcrypto_restore,\n#endif\n};\n\nmodule_virtio_driver(virtio_crypto_driver);\n\nMODULE_DEVICE_TABLE(virtio, id_table);\nMODULE_DESCRIPTION(\"virtio crypto device driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Gonglei <arei.gonglei@huawei.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}