{
  "module_name": "virtio_crypto_skcipher_algs.c",
  "hash_id": "7df02618cef8f11de4426376bc356e66a1fb2a46221226503642de31a72457ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/virtio/virtio_crypto_skcipher_algs.c",
  "human_readable_source": "\n  \n\n#include <crypto/engine.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <uapi/linux/virtio_crypto.h>\n#include \"virtio_crypto_common.h\"\n\n\nstruct virtio_crypto_skcipher_ctx {\n\tstruct virtio_crypto *vcrypto;\n\tstruct crypto_skcipher *tfm;\n\n\tstruct virtio_crypto_sym_session_info enc_sess_info;\n\tstruct virtio_crypto_sym_session_info dec_sess_info;\n};\n\nstruct virtio_crypto_sym_request {\n\tstruct virtio_crypto_request base;\n\n\t \n\tuint32_t type;\n\tstruct virtio_crypto_skcipher_ctx *skcipher_ctx;\n\tstruct skcipher_request *skcipher_req;\n\tuint8_t *iv;\n\t \n\tbool encrypt;\n};\n\nstruct virtio_crypto_algo {\n\tuint32_t algonum;\n\tuint32_t service;\n\tunsigned int active_devs;\n\tstruct skcipher_engine_alg algo;\n};\n\n \nstatic DEFINE_MUTEX(algs_lock);\nstatic void virtio_crypto_skcipher_finalize_req(\n\tstruct virtio_crypto_sym_request *vc_sym_req,\n\tstruct skcipher_request *req,\n\tint err);\n\nstatic void virtio_crypto_dataq_sym_callback\n\t\t(struct virtio_crypto_request *vc_req, int len)\n{\n\tstruct virtio_crypto_sym_request *vc_sym_req =\n\t\tcontainer_of(vc_req, struct virtio_crypto_sym_request, base);\n\tstruct skcipher_request *ablk_req;\n\tint error;\n\n\t \n\tif (vc_sym_req->type == VIRTIO_CRYPTO_SYM_OP_CIPHER) {\n\t\tswitch (vc_req->status) {\n\t\tcase VIRTIO_CRYPTO_OK:\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\tcase VIRTIO_CRYPTO_INVSESS:\n\t\tcase VIRTIO_CRYPTO_ERR:\n\t\t\terror = -EINVAL;\n\t\t\tbreak;\n\t\tcase VIRTIO_CRYPTO_BADMSG:\n\t\t\terror = -EBADMSG;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tablk_req = vc_sym_req->skcipher_req;\n\t\tvirtio_crypto_skcipher_finalize_req(vc_sym_req,\n\t\t\t\t\t\t\tablk_req, error);\n\t}\n}\n\nstatic u64 virtio_crypto_alg_sg_nents_length(struct scatterlist *sg)\n{\n\tu64 total = 0;\n\n\tfor (total = 0; sg; sg = sg_next(sg))\n\t\ttotal += sg->length;\n\n\treturn total;\n}\n\nstatic int\nvirtio_crypto_alg_validate_key(int key_len, uint32_t *alg)\n{\n\tswitch (key_len) {\n\tcase AES_KEYSIZE_128:\n\tcase AES_KEYSIZE_192:\n\tcase AES_KEYSIZE_256:\n\t\t*alg = VIRTIO_CRYPTO_CIPHER_AES_CBC;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int virtio_crypto_alg_skcipher_init_session(\n\t\tstruct virtio_crypto_skcipher_ctx *ctx,\n\t\tuint32_t alg, const uint8_t *key,\n\t\tunsigned int keylen,\n\t\tint encrypt)\n{\n\tstruct scatterlist outhdr, key_sg, inhdr, *sgs[3];\n\tstruct virtio_crypto *vcrypto = ctx->vcrypto;\n\tint op = encrypt ? VIRTIO_CRYPTO_OP_ENCRYPT : VIRTIO_CRYPTO_OP_DECRYPT;\n\tint err;\n\tunsigned int num_out = 0, num_in = 0;\n\tstruct virtio_crypto_op_ctrl_req *ctrl;\n\tstruct virtio_crypto_session_input *input;\n\tstruct virtio_crypto_sym_create_session_req *sym_create_session;\n\tstruct virtio_crypto_ctrl_request *vc_ctrl_req;\n\n\t \n\tuint8_t *cipher_key = kmemdup(key, keylen, GFP_ATOMIC);\n\n\tif (!cipher_key)\n\t\treturn -ENOMEM;\n\n\tvc_ctrl_req = kzalloc(sizeof(*vc_ctrl_req), GFP_KERNEL);\n\tif (!vc_ctrl_req) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tctrl = &vc_ctrl_req->ctrl;\n\tctrl->header.opcode = cpu_to_le32(VIRTIO_CRYPTO_CIPHER_CREATE_SESSION);\n\tctrl->header.algo = cpu_to_le32(alg);\n\t \n\tctrl->header.queue_id = 0;\n\n\tinput = &vc_ctrl_req->input;\n\tinput->status = cpu_to_le32(VIRTIO_CRYPTO_ERR);\n\t \n\tsym_create_session = &ctrl->u.sym_create_session;\n\tsym_create_session->op_type = cpu_to_le32(VIRTIO_CRYPTO_SYM_OP_CIPHER);\n\tsym_create_session->u.cipher.para.algo = ctrl->header.algo;\n\tsym_create_session->u.cipher.para.keylen = cpu_to_le32(keylen);\n\tsym_create_session->u.cipher.para.op = cpu_to_le32(op);\n\n\tsg_init_one(&outhdr, ctrl, sizeof(*ctrl));\n\tsgs[num_out++] = &outhdr;\n\n\t \n\tsg_init_one(&key_sg, cipher_key, keylen);\n\tsgs[num_out++] = &key_sg;\n\n\t \n\tsg_init_one(&inhdr, input, sizeof(*input));\n\tsgs[num_out + num_in++] = &inhdr;\n\n\terr = virtio_crypto_ctrl_vq_request(vcrypto, sgs, num_out, num_in, vc_ctrl_req);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (le32_to_cpu(input->status) != VIRTIO_CRYPTO_OK) {\n\t\tpr_err(\"virtio_crypto: Create session failed status: %u\\n\",\n\t\t\tle32_to_cpu(input->status));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (encrypt)\n\t\tctx->enc_sess_info.session_id = le64_to_cpu(input->session_id);\n\telse\n\t\tctx->dec_sess_info.session_id = le64_to_cpu(input->session_id);\n\n\terr = 0;\nout:\n\tkfree(vc_ctrl_req);\n\tkfree_sensitive(cipher_key);\n\treturn err;\n}\n\nstatic int virtio_crypto_alg_skcipher_close_session(\n\t\tstruct virtio_crypto_skcipher_ctx *ctx,\n\t\tint encrypt)\n{\n\tstruct scatterlist outhdr, status_sg, *sgs[2];\n\tstruct virtio_crypto_destroy_session_req *destroy_session;\n\tstruct virtio_crypto *vcrypto = ctx->vcrypto;\n\tint err;\n\tunsigned int num_out = 0, num_in = 0;\n\tstruct virtio_crypto_op_ctrl_req *ctrl;\n\tstruct virtio_crypto_inhdr *ctrl_status;\n\tstruct virtio_crypto_ctrl_request *vc_ctrl_req;\n\n\tvc_ctrl_req = kzalloc(sizeof(*vc_ctrl_req), GFP_KERNEL);\n\tif (!vc_ctrl_req)\n\t\treturn -ENOMEM;\n\n\tctrl_status = &vc_ctrl_req->ctrl_status;\n\tctrl_status->status = VIRTIO_CRYPTO_ERR;\n\t \n\tctrl = &vc_ctrl_req->ctrl;\n\tctrl->header.opcode = cpu_to_le32(VIRTIO_CRYPTO_CIPHER_DESTROY_SESSION);\n\t \n\tctrl->header.queue_id = 0;\n\n\tdestroy_session = &ctrl->u.destroy_session;\n\n\tif (encrypt)\n\t\tdestroy_session->session_id = cpu_to_le64(ctx->enc_sess_info.session_id);\n\telse\n\t\tdestroy_session->session_id = cpu_to_le64(ctx->dec_sess_info.session_id);\n\n\tsg_init_one(&outhdr, ctrl, sizeof(*ctrl));\n\tsgs[num_out++] = &outhdr;\n\n\t \n\tsg_init_one(&status_sg, &ctrl_status->status, sizeof(ctrl_status->status));\n\tsgs[num_out + num_in++] = &status_sg;\n\n\terr = virtio_crypto_ctrl_vq_request(vcrypto, sgs, num_out, num_in, vc_ctrl_req);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (ctrl_status->status != VIRTIO_CRYPTO_OK) {\n\t\tpr_err(\"virtio_crypto: Close session failed status: %u, session_id: 0x%llx\\n\",\n\t\t\tctrl_status->status, destroy_session->session_id);\n\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\tkfree(vc_ctrl_req);\n\treturn err;\n}\n\nstatic int virtio_crypto_alg_skcipher_init_sessions(\n\t\tstruct virtio_crypto_skcipher_ctx *ctx,\n\t\tconst uint8_t *key, unsigned int keylen)\n{\n\tuint32_t alg;\n\tint ret;\n\tstruct virtio_crypto *vcrypto = ctx->vcrypto;\n\n\tif (keylen > vcrypto->max_cipher_key_len) {\n\t\tpr_err(\"virtio_crypto: the key is too long\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (virtio_crypto_alg_validate_key(keylen, &alg))\n\t\treturn -EINVAL;\n\n\t \n\tret = virtio_crypto_alg_skcipher_init_session(ctx,\n\t\t\talg, key, keylen, 1);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = virtio_crypto_alg_skcipher_init_session(ctx,\n\t\t\talg, key, keylen, 0);\n\tif (ret) {\n\t\tvirtio_crypto_alg_skcipher_close_session(ctx, 1);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int virtio_crypto_skcipher_setkey(struct crypto_skcipher *tfm,\n\t\t\t\t\t const uint8_t *key,\n\t\t\t\t\t unsigned int keylen)\n{\n\tstruct virtio_crypto_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);\n\tuint32_t alg;\n\tint ret;\n\n\tret = virtio_crypto_alg_validate_key(keylen, &alg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ctx->vcrypto) {\n\t\t \n\t\tint node = virtio_crypto_get_current_node();\n\t\tstruct virtio_crypto *vcrypto =\n\t\t\t\t      virtcrypto_get_dev_node(node,\n\t\t\t\t      VIRTIO_CRYPTO_SERVICE_CIPHER, alg);\n\t\tif (!vcrypto) {\n\t\t\tpr_err(\"virtio_crypto: Could not find a virtio device in the system or unsupported algo\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tctx->vcrypto = vcrypto;\n\t} else {\n\t\t \n\t\tvirtio_crypto_alg_skcipher_close_session(ctx, 1);\n\t\tvirtio_crypto_alg_skcipher_close_session(ctx, 0);\n\t}\n\n\tret = virtio_crypto_alg_skcipher_init_sessions(ctx, key, keylen);\n\tif (ret) {\n\t\tvirtcrypto_dev_put(ctx->vcrypto);\n\t\tctx->vcrypto = NULL;\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\n__virtio_crypto_skcipher_do_req(struct virtio_crypto_sym_request *vc_sym_req,\n\t\tstruct skcipher_request *req,\n\t\tstruct data_queue *data_vq)\n{\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\n\tstruct virtio_crypto_skcipher_ctx *ctx = vc_sym_req->skcipher_ctx;\n\tstruct virtio_crypto_request *vc_req = &vc_sym_req->base;\n\tunsigned int ivsize = crypto_skcipher_ivsize(tfm);\n\tstruct virtio_crypto *vcrypto = ctx->vcrypto;\n\tstruct virtio_crypto_op_data_req *req_data;\n\tint src_nents, dst_nents;\n\tint err;\n\tunsigned long flags;\n\tstruct scatterlist outhdr, iv_sg, status_sg, **sgs;\n\tu64 dst_len;\n\tunsigned int num_out = 0, num_in = 0;\n\tint sg_total;\n\tuint8_t *iv;\n\tstruct scatterlist *sg;\n\n\tsrc_nents = sg_nents_for_len(req->src, req->cryptlen);\n\tif (src_nents < 0) {\n\t\tpr_err(\"Invalid number of src SG.\\n\");\n\t\treturn src_nents;\n\t}\n\n\tdst_nents = sg_nents(req->dst);\n\n\tpr_debug(\"virtio_crypto: Number of sgs (src_nents: %d, dst_nents: %d)\\n\",\n\t\t\tsrc_nents, dst_nents);\n\n\t \n\tsg_total = src_nents + dst_nents + 3;\n\tsgs = kcalloc_node(sg_total, sizeof(*sgs), GFP_KERNEL,\n\t\t\t\tdev_to_node(&vcrypto->vdev->dev));\n\tif (!sgs)\n\t\treturn -ENOMEM;\n\n\treq_data = kzalloc_node(sizeof(*req_data), GFP_KERNEL,\n\t\t\t\tdev_to_node(&vcrypto->vdev->dev));\n\tif (!req_data) {\n\t\tkfree(sgs);\n\t\treturn -ENOMEM;\n\t}\n\n\tvc_req->req_data = req_data;\n\tvc_sym_req->type = VIRTIO_CRYPTO_SYM_OP_CIPHER;\n\t \n\tif (vc_sym_req->encrypt) {\n\t\treq_data->header.session_id =\n\t\t\tcpu_to_le64(ctx->enc_sess_info.session_id);\n\t\treq_data->header.opcode =\n\t\t\tcpu_to_le32(VIRTIO_CRYPTO_CIPHER_ENCRYPT);\n\t} else {\n\t\treq_data->header.session_id =\n\t\t\tcpu_to_le64(ctx->dec_sess_info.session_id);\n\t\treq_data->header.opcode =\n\t\t\tcpu_to_le32(VIRTIO_CRYPTO_CIPHER_DECRYPT);\n\t}\n\treq_data->u.sym_req.op_type = cpu_to_le32(VIRTIO_CRYPTO_SYM_OP_CIPHER);\n\treq_data->u.sym_req.u.cipher.para.iv_len = cpu_to_le32(ivsize);\n\treq_data->u.sym_req.u.cipher.para.src_data_len =\n\t\t\tcpu_to_le32(req->cryptlen);\n\n\tdst_len = virtio_crypto_alg_sg_nents_length(req->dst);\n\tif (unlikely(dst_len > U32_MAX)) {\n\t\tpr_err(\"virtio_crypto: The dst_len is beyond U32_MAX\\n\");\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tdst_len = min_t(unsigned int, req->cryptlen, dst_len);\n\tpr_debug(\"virtio_crypto: src_len: %u, dst_len: %llu\\n\",\n\t\t\treq->cryptlen, dst_len);\n\n\tif (unlikely(req->cryptlen + dst_len + ivsize +\n\t\tsizeof(vc_req->status) > vcrypto->max_size)) {\n\t\tpr_err(\"virtio_crypto: The length is too big\\n\");\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\treq_data->u.sym_req.u.cipher.para.dst_data_len =\n\t\t\tcpu_to_le32((uint32_t)dst_len);\n\n\t \n\tsg_init_one(&outhdr, req_data, sizeof(*req_data));\n\tsgs[num_out++] = &outhdr;\n\n\t \n\n\t \n\tiv = kzalloc_node(ivsize, GFP_ATOMIC,\n\t\t\t\tdev_to_node(&vcrypto->vdev->dev));\n\tif (!iv) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\tmemcpy(iv, req->iv, ivsize);\n\tif (!vc_sym_req->encrypt)\n\t\tscatterwalk_map_and_copy(req->iv, req->src,\n\t\t\t\t\t req->cryptlen - AES_BLOCK_SIZE,\n\t\t\t\t\t AES_BLOCK_SIZE, 0);\n\n\tsg_init_one(&iv_sg, iv, ivsize);\n\tsgs[num_out++] = &iv_sg;\n\tvc_sym_req->iv = iv;\n\n\t \n\tfor (sg = req->src; src_nents; sg = sg_next(sg), src_nents--)\n\t\tsgs[num_out++] = sg;\n\n\t \n\tfor (sg = req->dst; sg; sg = sg_next(sg))\n\t\tsgs[num_out + num_in++] = sg;\n\n\t \n\tsg_init_one(&status_sg, &vc_req->status, sizeof(vc_req->status));\n\tsgs[num_out + num_in++] = &status_sg;\n\n\tvc_req->sgs = sgs;\n\n\tspin_lock_irqsave(&data_vq->lock, flags);\n\terr = virtqueue_add_sgs(data_vq->vq, sgs, num_out,\n\t\t\t\tnum_in, vc_req, GFP_ATOMIC);\n\tvirtqueue_kick(data_vq->vq);\n\tspin_unlock_irqrestore(&data_vq->lock, flags);\n\tif (unlikely(err < 0))\n\t\tgoto free_iv;\n\n\treturn 0;\n\nfree_iv:\n\tkfree_sensitive(iv);\nfree:\n\tkfree_sensitive(req_data);\n\tkfree(sgs);\n\treturn err;\n}\n\nstatic int virtio_crypto_skcipher_encrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *atfm = crypto_skcipher_reqtfm(req);\n\tstruct virtio_crypto_skcipher_ctx *ctx = crypto_skcipher_ctx(atfm);\n\tstruct virtio_crypto_sym_request *vc_sym_req =\n\t\t\t\tskcipher_request_ctx(req);\n\tstruct virtio_crypto_request *vc_req = &vc_sym_req->base;\n\tstruct virtio_crypto *vcrypto = ctx->vcrypto;\n\t \n\tstruct data_queue *data_vq = &vcrypto->data_vq[0];\n\n\tif (!req->cryptlen)\n\t\treturn 0;\n\tif (req->cryptlen % AES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tvc_req->dataq = data_vq;\n\tvc_req->alg_cb = virtio_crypto_dataq_sym_callback;\n\tvc_sym_req->skcipher_ctx = ctx;\n\tvc_sym_req->skcipher_req = req;\n\tvc_sym_req->encrypt = true;\n\n\treturn crypto_transfer_skcipher_request_to_engine(data_vq->engine, req);\n}\n\nstatic int virtio_crypto_skcipher_decrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *atfm = crypto_skcipher_reqtfm(req);\n\tstruct virtio_crypto_skcipher_ctx *ctx = crypto_skcipher_ctx(atfm);\n\tstruct virtio_crypto_sym_request *vc_sym_req =\n\t\t\t\tskcipher_request_ctx(req);\n\tstruct virtio_crypto_request *vc_req = &vc_sym_req->base;\n\tstruct virtio_crypto *vcrypto = ctx->vcrypto;\n\t \n\tstruct data_queue *data_vq = &vcrypto->data_vq[0];\n\n\tif (!req->cryptlen)\n\t\treturn 0;\n\tif (req->cryptlen % AES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tvc_req->dataq = data_vq;\n\tvc_req->alg_cb = virtio_crypto_dataq_sym_callback;\n\tvc_sym_req->skcipher_ctx = ctx;\n\tvc_sym_req->skcipher_req = req;\n\tvc_sym_req->encrypt = false;\n\n\treturn crypto_transfer_skcipher_request_to_engine(data_vq->engine, req);\n}\n\nstatic int virtio_crypto_skcipher_init(struct crypto_skcipher *tfm)\n{\n\tstruct virtio_crypto_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\tcrypto_skcipher_set_reqsize(tfm, sizeof(struct virtio_crypto_sym_request));\n\tctx->tfm = tfm;\n\n\treturn 0;\n}\n\nstatic void virtio_crypto_skcipher_exit(struct crypto_skcipher *tfm)\n{\n\tstruct virtio_crypto_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\tif (!ctx->vcrypto)\n\t\treturn;\n\n\tvirtio_crypto_alg_skcipher_close_session(ctx, 1);\n\tvirtio_crypto_alg_skcipher_close_session(ctx, 0);\n\tvirtcrypto_dev_put(ctx->vcrypto);\n\tctx->vcrypto = NULL;\n}\n\nint virtio_crypto_skcipher_crypt_req(\n\tstruct crypto_engine *engine, void *vreq)\n{\n\tstruct skcipher_request *req = container_of(vreq, struct skcipher_request, base);\n\tstruct virtio_crypto_sym_request *vc_sym_req =\n\t\t\t\tskcipher_request_ctx(req);\n\tstruct virtio_crypto_request *vc_req = &vc_sym_req->base;\n\tstruct data_queue *data_vq = vc_req->dataq;\n\tint ret;\n\n\tret = __virtio_crypto_skcipher_do_req(vc_sym_req, req, data_vq);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvirtqueue_kick(data_vq->vq);\n\n\treturn 0;\n}\n\nstatic void virtio_crypto_skcipher_finalize_req(\n\tstruct virtio_crypto_sym_request *vc_sym_req,\n\tstruct skcipher_request *req,\n\tint err)\n{\n\tif (vc_sym_req->encrypt)\n\t\tscatterwalk_map_and_copy(req->iv, req->dst,\n\t\t\t\t\t req->cryptlen - AES_BLOCK_SIZE,\n\t\t\t\t\t AES_BLOCK_SIZE, 0);\n\tkfree_sensitive(vc_sym_req->iv);\n\tvirtcrypto_clear_request(&vc_sym_req->base);\n\n\tcrypto_finalize_skcipher_request(vc_sym_req->base.dataq->engine,\n\t\t\t\t\t   req, err);\n}\n\nstatic struct virtio_crypto_algo virtio_crypto_algs[] = { {\n\t.algonum = VIRTIO_CRYPTO_CIPHER_AES_CBC,\n\t.service = VIRTIO_CRYPTO_SERVICE_CIPHER,\n\t.algo.base = {\n\t\t.base.cra_name\t\t= \"cbc(aes)\",\n\t\t.base.cra_driver_name\t= \"virtio_crypto_aes_cbc\",\n\t\t.base.cra_priority\t= 150,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct virtio_crypto_skcipher_ctx),\n\t\t.base.cra_module\t= THIS_MODULE,\n\t\t.init\t\t\t= virtio_crypto_skcipher_init,\n\t\t.exit\t\t\t= virtio_crypto_skcipher_exit,\n\t\t.setkey\t\t\t= virtio_crypto_skcipher_setkey,\n\t\t.decrypt\t\t= virtio_crypto_skcipher_decrypt,\n\t\t.encrypt\t\t= virtio_crypto_skcipher_encrypt,\n\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t},\n\t.algo.op = {\n\t\t.do_one_request = virtio_crypto_skcipher_crypt_req,\n\t},\n} };\n\nint virtio_crypto_skcipher_algs_register(struct virtio_crypto *vcrypto)\n{\n\tint ret = 0;\n\tint i = 0;\n\n\tmutex_lock(&algs_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(virtio_crypto_algs); i++) {\n\n\t\tuint32_t service = virtio_crypto_algs[i].service;\n\t\tuint32_t algonum = virtio_crypto_algs[i].algonum;\n\n\t\tif (!virtcrypto_algo_is_supported(vcrypto, service, algonum))\n\t\t\tcontinue;\n\n\t\tif (virtio_crypto_algs[i].active_devs == 0) {\n\t\t\tret = crypto_engine_register_skcipher(&virtio_crypto_algs[i].algo);\n\t\t\tif (ret)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tvirtio_crypto_algs[i].active_devs++;\n\t\tdev_info(&vcrypto->vdev->dev, \"Registered algo %s\\n\",\n\t\t\t virtio_crypto_algs[i].algo.base.base.cra_name);\n\t}\n\nunlock:\n\tmutex_unlock(&algs_lock);\n\treturn ret;\n}\n\nvoid virtio_crypto_skcipher_algs_unregister(struct virtio_crypto *vcrypto)\n{\n\tint i = 0;\n\n\tmutex_lock(&algs_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(virtio_crypto_algs); i++) {\n\n\t\tuint32_t service = virtio_crypto_algs[i].service;\n\t\tuint32_t algonum = virtio_crypto_algs[i].algonum;\n\n\t\tif (virtio_crypto_algs[i].active_devs == 0 ||\n\t\t    !virtcrypto_algo_is_supported(vcrypto, service, algonum))\n\t\t\tcontinue;\n\n\t\tif (virtio_crypto_algs[i].active_devs == 1)\n\t\t\tcrypto_engine_unregister_skcipher(&virtio_crypto_algs[i].algo);\n\n\t\tvirtio_crypto_algs[i].active_devs--;\n\t}\n\n\tmutex_unlock(&algs_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}