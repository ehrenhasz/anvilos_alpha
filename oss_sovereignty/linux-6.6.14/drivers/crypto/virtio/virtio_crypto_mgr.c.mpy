{
  "module_name": "virtio_crypto_mgr.c",
  "hash_id": "026799759c590c8c20a539d80d69ce8476978364d96c10208f874c3959307d24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/virtio/virtio_crypto_mgr.c",
  "human_readable_source": "\n  \n\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#include <uapi/linux/virtio_crypto.h>\n#include \"virtio_crypto_common.h\"\n\nstatic LIST_HEAD(virtio_crypto_table);\nstatic uint32_t num_devices;\n\n \nstatic DEFINE_MUTEX(table_lock);\n\n#define VIRTIO_CRYPTO_MAX_DEVICES 32\n\n\n \nint virtcrypto_devmgr_add_dev(struct virtio_crypto *vcrypto_dev)\n{\n\tstruct list_head *itr;\n\n\tmutex_lock(&table_lock);\n\tif (num_devices == VIRTIO_CRYPTO_MAX_DEVICES) {\n\t\tpr_info(\"virtio_crypto: only support up to %d devices\\n\",\n\t\t\t    VIRTIO_CRYPTO_MAX_DEVICES);\n\t\tmutex_unlock(&table_lock);\n\t\treturn -EFAULT;\n\t}\n\n\tlist_for_each(itr, &virtio_crypto_table) {\n\t\tstruct virtio_crypto *ptr =\n\t\t\t\tlist_entry(itr, struct virtio_crypto, list);\n\n\t\tif (ptr == vcrypto_dev) {\n\t\t\tmutex_unlock(&table_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tatomic_set(&vcrypto_dev->ref_count, 0);\n\tlist_add_tail(&vcrypto_dev->list, &virtio_crypto_table);\n\tvcrypto_dev->dev_id = num_devices++;\n\tmutex_unlock(&table_lock);\n\treturn 0;\n}\n\nstruct list_head *virtcrypto_devmgr_get_head(void)\n{\n\treturn &virtio_crypto_table;\n}\n\n \nvoid virtcrypto_devmgr_rm_dev(struct virtio_crypto *vcrypto_dev)\n{\n\tmutex_lock(&table_lock);\n\tlist_del(&vcrypto_dev->list);\n\tnum_devices--;\n\tmutex_unlock(&table_lock);\n}\n\n \nstruct virtio_crypto *virtcrypto_devmgr_get_first(void)\n{\n\tstruct virtio_crypto *dev = NULL;\n\n\tmutex_lock(&table_lock);\n\tif (!list_empty(&virtio_crypto_table))\n\t\tdev = list_first_entry(&virtio_crypto_table,\n\t\t\t\t\tstruct virtio_crypto,\n\t\t\t\t    list);\n\tmutex_unlock(&table_lock);\n\treturn dev;\n}\n\n \nint virtcrypto_dev_in_use(struct virtio_crypto *vcrypto_dev)\n{\n\treturn atomic_read(&vcrypto_dev->ref_count) != 0;\n}\n\n \nint virtcrypto_dev_get(struct virtio_crypto *vcrypto_dev)\n{\n\tif (atomic_add_return(1, &vcrypto_dev->ref_count) == 1)\n\t\tif (!try_module_get(vcrypto_dev->owner))\n\t\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nvoid virtcrypto_dev_put(struct virtio_crypto *vcrypto_dev)\n{\n\tif (atomic_sub_return(1, &vcrypto_dev->ref_count) == 0)\n\t\tmodule_put(vcrypto_dev->owner);\n}\n\n \nint virtcrypto_dev_started(struct virtio_crypto *vcrypto_dev)\n{\n\treturn (vcrypto_dev->status & VIRTIO_CRYPTO_S_HW_READY);\n}\n\n \nstruct virtio_crypto *virtcrypto_get_dev_node(int node, uint32_t service,\n\t\t\t\t\t      uint32_t algo)\n{\n\tstruct virtio_crypto *vcrypto_dev = NULL, *tmp_dev;\n\tunsigned long best = ~0;\n\tunsigned long ctr;\n\n\tmutex_lock(&table_lock);\n\tlist_for_each_entry(tmp_dev, virtcrypto_devmgr_get_head(), list) {\n\n\t\tif ((node == dev_to_node(&tmp_dev->vdev->dev) ||\n\t\t     dev_to_node(&tmp_dev->vdev->dev) < 0) &&\n\t\t    virtcrypto_dev_started(tmp_dev) &&\n\t\t    virtcrypto_algo_is_supported(tmp_dev, service, algo)) {\n\t\t\tctr = atomic_read(&tmp_dev->ref_count);\n\t\t\tif (best > ctr) {\n\t\t\t\tvcrypto_dev = tmp_dev;\n\t\t\t\tbest = ctr;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!vcrypto_dev) {\n\t\tpr_info(\"virtio_crypto: Could not find a device on node %d\\n\",\n\t\t\t\tnode);\n\t\t \n\t\tlist_for_each_entry(tmp_dev,\n\t\t\t\tvirtcrypto_devmgr_get_head(), list) {\n\t\t\tif (virtcrypto_dev_started(tmp_dev) &&\n\t\t\t    virtcrypto_algo_is_supported(tmp_dev,\n\t\t\t    service, algo)) {\n\t\t\t\tvcrypto_dev = tmp_dev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&table_lock);\n\tif (!vcrypto_dev)\n\t\treturn NULL;\n\n\tvirtcrypto_dev_get(vcrypto_dev);\n\treturn vcrypto_dev;\n}\n\n \nint virtcrypto_dev_start(struct virtio_crypto *vcrypto)\n{\n\tif (virtio_crypto_skcipher_algs_register(vcrypto)) {\n\t\tpr_err(\"virtio_crypto: Failed to register crypto skcipher algs\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (virtio_crypto_akcipher_algs_register(vcrypto)) {\n\t\tpr_err(\"virtio_crypto: Failed to register crypto akcipher algs\\n\");\n\t\tvirtio_crypto_skcipher_algs_unregister(vcrypto);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nvoid virtcrypto_dev_stop(struct virtio_crypto *vcrypto)\n{\n\tvirtio_crypto_skcipher_algs_unregister(vcrypto);\n\tvirtio_crypto_akcipher_algs_unregister(vcrypto);\n}\n\n \n\nbool virtcrypto_algo_is_supported(struct virtio_crypto *vcrypto,\n\t\t\t\t  uint32_t service,\n\t\t\t\t  uint32_t algo)\n{\n\tuint32_t service_mask = 1u << service;\n\tuint32_t algo_mask = 0;\n\tbool low = true;\n\n\tif (algo > 31) {\n\t\talgo -= 32;\n\t\tlow = false;\n\t}\n\n\tif (!(vcrypto->crypto_services & service_mask))\n\t\treturn false;\n\n\tswitch (service) {\n\tcase VIRTIO_CRYPTO_SERVICE_CIPHER:\n\t\tif (low)\n\t\t\talgo_mask = vcrypto->cipher_algo_l;\n\t\telse\n\t\t\talgo_mask = vcrypto->cipher_algo_h;\n\t\tbreak;\n\n\tcase VIRTIO_CRYPTO_SERVICE_HASH:\n\t\talgo_mask = vcrypto->hash_algo;\n\t\tbreak;\n\n\tcase VIRTIO_CRYPTO_SERVICE_MAC:\n\t\tif (low)\n\t\t\talgo_mask = vcrypto->mac_algo_l;\n\t\telse\n\t\t\talgo_mask = vcrypto->mac_algo_h;\n\t\tbreak;\n\n\tcase VIRTIO_CRYPTO_SERVICE_AEAD:\n\t\talgo_mask = vcrypto->aead_algo;\n\t\tbreak;\n\n\tcase VIRTIO_CRYPTO_SERVICE_AKCIPHER:\n\t\talgo_mask = vcrypto->akcipher_algo;\n\t\tbreak;\n\t}\n\n\tif (!(algo_mask & (1u << algo)))\n\t\treturn false;\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}