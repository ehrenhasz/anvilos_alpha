{
  "module_name": "virtio_crypto_akcipher_algs.c",
  "hash_id": "941b57049478a3a73d49662118ad8c8a2de762ec54e83de91919ced7b4ff23e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/virtio/virtio_crypto_akcipher_algs.c",
  "human_readable_source": "\n  \n\n#include <crypto/engine.h>\n#include <crypto/internal/akcipher.h>\n#include <crypto/internal/rsa.h>\n#include <crypto/scatterwalk.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/mpi.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <uapi/linux/virtio_crypto.h>\n#include \"virtio_crypto_common.h\"\n\nstruct virtio_crypto_rsa_ctx {\n\tMPI n;\n};\n\nstruct virtio_crypto_akcipher_ctx {\n\tstruct virtio_crypto *vcrypto;\n\tstruct crypto_akcipher *tfm;\n\tbool session_valid;\n\t__u64 session_id;\n\tunion {\n\t\tstruct virtio_crypto_rsa_ctx rsa_ctx;\n\t};\n};\n\nstruct virtio_crypto_akcipher_request {\n\tstruct virtio_crypto_request base;\n\tstruct virtio_crypto_akcipher_ctx *akcipher_ctx;\n\tstruct akcipher_request *akcipher_req;\n\tvoid *src_buf;\n\tvoid *dst_buf;\n\tuint32_t opcode;\n};\n\nstruct virtio_crypto_akcipher_algo {\n\tuint32_t algonum;\n\tuint32_t service;\n\tunsigned int active_devs;\n\tstruct akcipher_engine_alg algo;\n};\n\nstatic DEFINE_MUTEX(algs_lock);\n\nstatic void virtio_crypto_akcipher_finalize_req(\n\tstruct virtio_crypto_akcipher_request *vc_akcipher_req,\n\tstruct akcipher_request *req, int err)\n{\n\tkfree(vc_akcipher_req->src_buf);\n\tkfree(vc_akcipher_req->dst_buf);\n\tvc_akcipher_req->src_buf = NULL;\n\tvc_akcipher_req->dst_buf = NULL;\n\tvirtcrypto_clear_request(&vc_akcipher_req->base);\n\n\tcrypto_finalize_akcipher_request(vc_akcipher_req->base.dataq->engine, req, err);\n}\n\nstatic void virtio_crypto_dataq_akcipher_callback(struct virtio_crypto_request *vc_req, int len)\n{\n\tstruct virtio_crypto_akcipher_request *vc_akcipher_req =\n\t\tcontainer_of(vc_req, struct virtio_crypto_akcipher_request, base);\n\tstruct akcipher_request *akcipher_req;\n\tint error;\n\n\tswitch (vc_req->status) {\n\tcase VIRTIO_CRYPTO_OK:\n\t\terror = 0;\n\t\tbreak;\n\tcase VIRTIO_CRYPTO_INVSESS:\n\tcase VIRTIO_CRYPTO_ERR:\n\t\terror = -EINVAL;\n\t\tbreak;\n\tcase VIRTIO_CRYPTO_BADMSG:\n\t\terror = -EBADMSG;\n\t\tbreak;\n\n\tcase VIRTIO_CRYPTO_KEY_REJECTED:\n\t\terror = -EKEYREJECTED;\n\t\tbreak;\n\n\tdefault:\n\t\terror = -EIO;\n\t\tbreak;\n\t}\n\n\takcipher_req = vc_akcipher_req->akcipher_req;\n\tif (vc_akcipher_req->opcode != VIRTIO_CRYPTO_AKCIPHER_VERIFY) {\n\t\t \n\t\takcipher_req->dst_len = len - sizeof(vc_req->status);\n\t\tsg_copy_from_buffer(akcipher_req->dst, sg_nents(akcipher_req->dst),\n\t\t\t\t    vc_akcipher_req->dst_buf, akcipher_req->dst_len);\n\t}\n\tvirtio_crypto_akcipher_finalize_req(vc_akcipher_req, akcipher_req, error);\n}\n\nstatic int virtio_crypto_alg_akcipher_init_session(struct virtio_crypto_akcipher_ctx *ctx,\n\t\tstruct virtio_crypto_ctrl_header *header, void *para,\n\t\tconst uint8_t *key, unsigned int keylen)\n{\n\tstruct scatterlist outhdr_sg, key_sg, inhdr_sg, *sgs[3];\n\tstruct virtio_crypto *vcrypto = ctx->vcrypto;\n\tuint8_t *pkey;\n\tint err;\n\tunsigned int num_out = 0, num_in = 0;\n\tstruct virtio_crypto_op_ctrl_req *ctrl;\n\tstruct virtio_crypto_session_input *input;\n\tstruct virtio_crypto_ctrl_request *vc_ctrl_req;\n\n\tpkey = kmemdup(key, keylen, GFP_KERNEL);\n\tif (!pkey)\n\t\treturn -ENOMEM;\n\n\tvc_ctrl_req = kzalloc(sizeof(*vc_ctrl_req), GFP_KERNEL);\n\tif (!vc_ctrl_req) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tctrl = &vc_ctrl_req->ctrl;\n\tmemcpy(&ctrl->header, header, sizeof(ctrl->header));\n\tmemcpy(&ctrl->u, para, sizeof(ctrl->u));\n\tinput = &vc_ctrl_req->input;\n\tinput->status = cpu_to_le32(VIRTIO_CRYPTO_ERR);\n\n\tsg_init_one(&outhdr_sg, ctrl, sizeof(*ctrl));\n\tsgs[num_out++] = &outhdr_sg;\n\n\tsg_init_one(&key_sg, pkey, keylen);\n\tsgs[num_out++] = &key_sg;\n\n\tsg_init_one(&inhdr_sg, input, sizeof(*input));\n\tsgs[num_out + num_in++] = &inhdr_sg;\n\n\terr = virtio_crypto_ctrl_vq_request(vcrypto, sgs, num_out, num_in, vc_ctrl_req);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (le32_to_cpu(input->status) != VIRTIO_CRYPTO_OK) {\n\t\tpr_err(\"virtio_crypto: Create session failed status: %u\\n\",\n\t\t\tle32_to_cpu(input->status));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tctx->session_id = le64_to_cpu(input->session_id);\n\tctx->session_valid = true;\n\terr = 0;\n\nout:\n\tkfree(vc_ctrl_req);\n\tkfree_sensitive(pkey);\n\n\treturn err;\n}\n\nstatic int virtio_crypto_alg_akcipher_close_session(struct virtio_crypto_akcipher_ctx *ctx)\n{\n\tstruct scatterlist outhdr_sg, inhdr_sg, *sgs[2];\n\tstruct virtio_crypto_destroy_session_req *destroy_session;\n\tstruct virtio_crypto *vcrypto = ctx->vcrypto;\n\tunsigned int num_out = 0, num_in = 0;\n\tint err;\n\tstruct virtio_crypto_op_ctrl_req *ctrl;\n\tstruct virtio_crypto_inhdr *ctrl_status;\n\tstruct virtio_crypto_ctrl_request *vc_ctrl_req;\n\n\tif (!ctx->session_valid)\n\t\treturn 0;\n\n\tvc_ctrl_req = kzalloc(sizeof(*vc_ctrl_req), GFP_KERNEL);\n\tif (!vc_ctrl_req)\n\t\treturn -ENOMEM;\n\n\tctrl_status = &vc_ctrl_req->ctrl_status;\n\tctrl_status->status = VIRTIO_CRYPTO_ERR;\n\tctrl = &vc_ctrl_req->ctrl;\n\tctrl->header.opcode = cpu_to_le32(VIRTIO_CRYPTO_AKCIPHER_DESTROY_SESSION);\n\tctrl->header.queue_id = 0;\n\n\tdestroy_session = &ctrl->u.destroy_session;\n\tdestroy_session->session_id = cpu_to_le64(ctx->session_id);\n\n\tsg_init_one(&outhdr_sg, ctrl, sizeof(*ctrl));\n\tsgs[num_out++] = &outhdr_sg;\n\n\tsg_init_one(&inhdr_sg, &ctrl_status->status, sizeof(ctrl_status->status));\n\tsgs[num_out + num_in++] = &inhdr_sg;\n\n\terr = virtio_crypto_ctrl_vq_request(vcrypto, sgs, num_out, num_in, vc_ctrl_req);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (ctrl_status->status != VIRTIO_CRYPTO_OK) {\n\t\tpr_err(\"virtio_crypto: Close session failed status: %u, session_id: 0x%llx\\n\",\n\t\t\tctrl_status->status, destroy_session->session_id);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\tctx->session_valid = false;\n\nout:\n\tkfree(vc_ctrl_req);\n\n\treturn err;\n}\n\nstatic int __virtio_crypto_akcipher_do_req(struct virtio_crypto_akcipher_request *vc_akcipher_req,\n\t\tstruct akcipher_request *req, struct data_queue *data_vq)\n{\n\tstruct virtio_crypto_akcipher_ctx *ctx = vc_akcipher_req->akcipher_ctx;\n\tstruct virtio_crypto_request *vc_req = &vc_akcipher_req->base;\n\tstruct virtio_crypto *vcrypto = ctx->vcrypto;\n\tstruct virtio_crypto_op_data_req *req_data = vc_req->req_data;\n\tstruct scatterlist *sgs[4], outhdr_sg, inhdr_sg, srcdata_sg, dstdata_sg;\n\tvoid *src_buf = NULL, *dst_buf = NULL;\n\tunsigned int num_out = 0, num_in = 0;\n\tint node = dev_to_node(&vcrypto->vdev->dev);\n\tunsigned long flags;\n\tint ret = -ENOMEM;\n\tbool verify = vc_akcipher_req->opcode == VIRTIO_CRYPTO_AKCIPHER_VERIFY;\n\tunsigned int src_len = verify ? req->src_len + req->dst_len : req->src_len;\n\n\t \n\tsg_init_one(&outhdr_sg, req_data, sizeof(*req_data));\n\tsgs[num_out++] = &outhdr_sg;\n\n\t \n\tsrc_buf = kcalloc_node(src_len, 1, GFP_KERNEL, node);\n\tif (!src_buf)\n\t\tgoto err;\n\n\tif (verify) {\n\t\t \n\t\tsg_copy_to_buffer(req->src, sg_nents(req->src), src_buf, src_len);\n\t\tsg_init_one(&srcdata_sg, src_buf, src_len);\n\t\tsgs[num_out++] = &srcdata_sg;\n\t} else {\n\t\tsg_copy_to_buffer(req->src, sg_nents(req->src), src_buf, src_len);\n\t\tsg_init_one(&srcdata_sg, src_buf, src_len);\n\t\tsgs[num_out++] = &srcdata_sg;\n\n\t\t \n\t\tdst_buf = kcalloc_node(req->dst_len, 1, GFP_KERNEL, node);\n\t\tif (!dst_buf)\n\t\t\tgoto err;\n\n\t\tsg_init_one(&dstdata_sg, dst_buf, req->dst_len);\n\t\tsgs[num_out + num_in++] = &dstdata_sg;\n\t}\n\n\tvc_akcipher_req->src_buf = src_buf;\n\tvc_akcipher_req->dst_buf = dst_buf;\n\n\t \n\tsg_init_one(&inhdr_sg, &vc_req->status, sizeof(vc_req->status));\n\tsgs[num_out + num_in++] = &inhdr_sg;\n\n\tspin_lock_irqsave(&data_vq->lock, flags);\n\tret = virtqueue_add_sgs(data_vq->vq, sgs, num_out, num_in, vc_req, GFP_ATOMIC);\n\tvirtqueue_kick(data_vq->vq);\n\tspin_unlock_irqrestore(&data_vq->lock, flags);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tkfree(src_buf);\n\tkfree(dst_buf);\n\n\treturn -ENOMEM;\n}\n\nstatic int virtio_crypto_rsa_do_req(struct crypto_engine *engine, void *vreq)\n{\n\tstruct akcipher_request *req = container_of(vreq, struct akcipher_request, base);\n\tstruct virtio_crypto_akcipher_request *vc_akcipher_req = akcipher_request_ctx(req);\n\tstruct virtio_crypto_request *vc_req = &vc_akcipher_req->base;\n\tstruct virtio_crypto_akcipher_ctx *ctx = vc_akcipher_req->akcipher_ctx;\n\tstruct virtio_crypto *vcrypto = ctx->vcrypto;\n\tstruct data_queue *data_vq = vc_req->dataq;\n\tstruct virtio_crypto_op_header *header;\n\tstruct virtio_crypto_akcipher_data_req *akcipher_req;\n\tint ret;\n\n\tvc_req->sgs = NULL;\n\tvc_req->req_data = kzalloc_node(sizeof(*vc_req->req_data),\n\t\tGFP_KERNEL, dev_to_node(&vcrypto->vdev->dev));\n\tif (!vc_req->req_data)\n\t\treturn -ENOMEM;\n\n\t \n\theader = &vc_req->req_data->header;\n\theader->opcode = cpu_to_le32(vc_akcipher_req->opcode);\n\theader->algo = cpu_to_le32(VIRTIO_CRYPTO_AKCIPHER_RSA);\n\theader->session_id = cpu_to_le64(ctx->session_id);\n\n\t \n\takcipher_req = &vc_req->req_data->u.akcipher_req;\n\takcipher_req->para.src_data_len = cpu_to_le32(req->src_len);\n\takcipher_req->para.dst_data_len = cpu_to_le32(req->dst_len);\n\n\tret = __virtio_crypto_akcipher_do_req(vc_akcipher_req, req, data_vq);\n\tif (ret < 0) {\n\t\tkfree_sensitive(vc_req->req_data);\n\t\tvc_req->req_data = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int virtio_crypto_rsa_req(struct akcipher_request *req, uint32_t opcode)\n{\n\tstruct crypto_akcipher *atfm = crypto_akcipher_reqtfm(req);\n\tstruct virtio_crypto_akcipher_ctx *ctx = akcipher_tfm_ctx(atfm);\n\tstruct virtio_crypto_akcipher_request *vc_akcipher_req = akcipher_request_ctx(req);\n\tstruct virtio_crypto_request *vc_req = &vc_akcipher_req->base;\n\tstruct virtio_crypto *vcrypto = ctx->vcrypto;\n\t \n\tstruct data_queue *data_vq = &vcrypto->data_vq[0];\n\n\tvc_req->dataq = data_vq;\n\tvc_req->alg_cb = virtio_crypto_dataq_akcipher_callback;\n\tvc_akcipher_req->akcipher_ctx = ctx;\n\tvc_akcipher_req->akcipher_req = req;\n\tvc_akcipher_req->opcode = opcode;\n\n\treturn crypto_transfer_akcipher_request_to_engine(data_vq->engine, req);\n}\n\nstatic int virtio_crypto_rsa_encrypt(struct akcipher_request *req)\n{\n\treturn virtio_crypto_rsa_req(req, VIRTIO_CRYPTO_AKCIPHER_ENCRYPT);\n}\n\nstatic int virtio_crypto_rsa_decrypt(struct akcipher_request *req)\n{\n\treturn virtio_crypto_rsa_req(req, VIRTIO_CRYPTO_AKCIPHER_DECRYPT);\n}\n\nstatic int virtio_crypto_rsa_sign(struct akcipher_request *req)\n{\n\treturn virtio_crypto_rsa_req(req, VIRTIO_CRYPTO_AKCIPHER_SIGN);\n}\n\nstatic int virtio_crypto_rsa_verify(struct akcipher_request *req)\n{\n\treturn virtio_crypto_rsa_req(req, VIRTIO_CRYPTO_AKCIPHER_VERIFY);\n}\n\nstatic int virtio_crypto_rsa_set_key(struct crypto_akcipher *tfm,\n\t\t\t\t     const void *key,\n\t\t\t\t     unsigned int keylen,\n\t\t\t\t     bool private,\n\t\t\t\t     int padding_algo,\n\t\t\t\t     int hash_algo)\n{\n\tstruct virtio_crypto_akcipher_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct virtio_crypto_rsa_ctx *rsa_ctx = &ctx->rsa_ctx;\n\tstruct virtio_crypto *vcrypto;\n\tstruct virtio_crypto_ctrl_header header;\n\tstruct virtio_crypto_akcipher_session_para para;\n\tstruct rsa_key rsa_key = {0};\n\tint node = virtio_crypto_get_current_node();\n\tuint32_t keytype;\n\tint ret;\n\n\t \n\tmpi_free(rsa_ctx->n);\n\trsa_ctx->n = NULL;\n\n\tif (private) {\n\t\tkeytype = VIRTIO_CRYPTO_AKCIPHER_KEY_TYPE_PRIVATE;\n\t\tret = rsa_parse_priv_key(&rsa_key, key, keylen);\n\t} else {\n\t\tkeytype = VIRTIO_CRYPTO_AKCIPHER_KEY_TYPE_PUBLIC;\n\t\tret = rsa_parse_pub_key(&rsa_key, key, keylen);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\trsa_ctx->n = mpi_read_raw_data(rsa_key.n, rsa_key.n_sz);\n\tif (!rsa_ctx->n)\n\t\treturn -ENOMEM;\n\n\tif (!ctx->vcrypto) {\n\t\tvcrypto = virtcrypto_get_dev_node(node, VIRTIO_CRYPTO_SERVICE_AKCIPHER,\n\t\t\t\t\t\tVIRTIO_CRYPTO_AKCIPHER_RSA);\n\t\tif (!vcrypto) {\n\t\t\tpr_err(\"virtio_crypto: Could not find a virtio device in the system or unsupported algo\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tctx->vcrypto = vcrypto;\n\t} else {\n\t\tvirtio_crypto_alg_akcipher_close_session(ctx);\n\t}\n\n\t \n\theader.opcode =\tcpu_to_le32(VIRTIO_CRYPTO_AKCIPHER_CREATE_SESSION);\n\theader.algo = cpu_to_le32(VIRTIO_CRYPTO_AKCIPHER_RSA);\n\theader.queue_id = 0;\n\n\t \n\tpara.algo = cpu_to_le32(VIRTIO_CRYPTO_AKCIPHER_RSA);\n\tpara.keytype = cpu_to_le32(keytype);\n\tpara.keylen = cpu_to_le32(keylen);\n\tpara.u.rsa.padding_algo = cpu_to_le32(padding_algo);\n\tpara.u.rsa.hash_algo = cpu_to_le32(hash_algo);\n\n\treturn virtio_crypto_alg_akcipher_init_session(ctx, &header, &para, key, keylen);\n}\n\nstatic int virtio_crypto_rsa_raw_set_priv_key(struct crypto_akcipher *tfm,\n\t\t\t\t\t      const void *key,\n\t\t\t\t\t      unsigned int keylen)\n{\n\treturn virtio_crypto_rsa_set_key(tfm, key, keylen, 1,\n\t\t\t\t\t VIRTIO_CRYPTO_RSA_RAW_PADDING,\n\t\t\t\t\t VIRTIO_CRYPTO_RSA_NO_HASH);\n}\n\n\nstatic int virtio_crypto_p1pad_rsa_sha1_set_priv_key(struct crypto_akcipher *tfm,\n\t\t\t\t\t\t     const void *key,\n\t\t\t\t\t\t     unsigned int keylen)\n{\n\treturn virtio_crypto_rsa_set_key(tfm, key, keylen, 1,\n\t\t\t\t\t VIRTIO_CRYPTO_RSA_PKCS1_PADDING,\n\t\t\t\t\t VIRTIO_CRYPTO_RSA_SHA1);\n}\n\nstatic int virtio_crypto_rsa_raw_set_pub_key(struct crypto_akcipher *tfm,\n\t\t\t\t\t     const void *key,\n\t\t\t\t\t     unsigned int keylen)\n{\n\treturn virtio_crypto_rsa_set_key(tfm, key, keylen, 0,\n\t\t\t\t\t VIRTIO_CRYPTO_RSA_RAW_PADDING,\n\t\t\t\t\t VIRTIO_CRYPTO_RSA_NO_HASH);\n}\n\nstatic int virtio_crypto_p1pad_rsa_sha1_set_pub_key(struct crypto_akcipher *tfm,\n\t\t\t\t\t\t    const void *key,\n\t\t\t\t\t\t    unsigned int keylen)\n{\n\treturn virtio_crypto_rsa_set_key(tfm, key, keylen, 0,\n\t\t\t\t\t VIRTIO_CRYPTO_RSA_PKCS1_PADDING,\n\t\t\t\t\t VIRTIO_CRYPTO_RSA_SHA1);\n}\n\nstatic unsigned int virtio_crypto_rsa_max_size(struct crypto_akcipher *tfm)\n{\n\tstruct virtio_crypto_akcipher_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct virtio_crypto_rsa_ctx *rsa_ctx = &ctx->rsa_ctx;\n\n\treturn mpi_get_size(rsa_ctx->n);\n}\n\nstatic int virtio_crypto_rsa_init_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct virtio_crypto_akcipher_ctx *ctx = akcipher_tfm_ctx(tfm);\n\n\tctx->tfm = tfm;\n\n\takcipher_set_reqsize(tfm,\n\t\t\t     sizeof(struct virtio_crypto_akcipher_request));\n\n\treturn 0;\n}\n\nstatic void virtio_crypto_rsa_exit_tfm(struct crypto_akcipher *tfm)\n{\n\tstruct virtio_crypto_akcipher_ctx *ctx = akcipher_tfm_ctx(tfm);\n\tstruct virtio_crypto_rsa_ctx *rsa_ctx = &ctx->rsa_ctx;\n\n\tvirtio_crypto_alg_akcipher_close_session(ctx);\n\tvirtcrypto_dev_put(ctx->vcrypto);\n\tmpi_free(rsa_ctx->n);\n\trsa_ctx->n = NULL;\n}\n\nstatic struct virtio_crypto_akcipher_algo virtio_crypto_akcipher_algs[] = {\n\t{\n\t\t.algonum = VIRTIO_CRYPTO_AKCIPHER_RSA,\n\t\t.service = VIRTIO_CRYPTO_SERVICE_AKCIPHER,\n\t\t.algo.base = {\n\t\t\t.encrypt = virtio_crypto_rsa_encrypt,\n\t\t\t.decrypt = virtio_crypto_rsa_decrypt,\n\t\t\t.set_pub_key = virtio_crypto_rsa_raw_set_pub_key,\n\t\t\t.set_priv_key = virtio_crypto_rsa_raw_set_priv_key,\n\t\t\t.max_size = virtio_crypto_rsa_max_size,\n\t\t\t.init = virtio_crypto_rsa_init_tfm,\n\t\t\t.exit = virtio_crypto_rsa_exit_tfm,\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"rsa\",\n\t\t\t\t.cra_driver_name = \"virtio-crypto-rsa\",\n\t\t\t\t.cra_priority = 150,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t\t.cra_ctxsize = sizeof(struct virtio_crypto_akcipher_ctx),\n\t\t\t},\n\t\t},\n\t\t.algo.op = {\n\t\t\t.do_one_request = virtio_crypto_rsa_do_req,\n\t\t},\n\t},\n\t{\n\t\t.algonum = VIRTIO_CRYPTO_AKCIPHER_RSA,\n\t\t.service = VIRTIO_CRYPTO_SERVICE_AKCIPHER,\n\t\t.algo.base = {\n\t\t\t.encrypt = virtio_crypto_rsa_encrypt,\n\t\t\t.decrypt = virtio_crypto_rsa_decrypt,\n\t\t\t.sign = virtio_crypto_rsa_sign,\n\t\t\t.verify = virtio_crypto_rsa_verify,\n\t\t\t.set_pub_key = virtio_crypto_p1pad_rsa_sha1_set_pub_key,\n\t\t\t.set_priv_key = virtio_crypto_p1pad_rsa_sha1_set_priv_key,\n\t\t\t.max_size = virtio_crypto_rsa_max_size,\n\t\t\t.init = virtio_crypto_rsa_init_tfm,\n\t\t\t.exit = virtio_crypto_rsa_exit_tfm,\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"pkcs1pad(rsa,sha1)\",\n\t\t\t\t.cra_driver_name = \"virtio-pkcs1-rsa-with-sha1\",\n\t\t\t\t.cra_priority = 150,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t\t.cra_ctxsize = sizeof(struct virtio_crypto_akcipher_ctx),\n\t\t\t},\n\t\t},\n\t\t.algo.op = {\n\t\t\t.do_one_request = virtio_crypto_rsa_do_req,\n\t\t},\n\t},\n};\n\nint virtio_crypto_akcipher_algs_register(struct virtio_crypto *vcrypto)\n{\n\tint ret = 0;\n\tint i = 0;\n\n\tmutex_lock(&algs_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(virtio_crypto_akcipher_algs); i++) {\n\t\tuint32_t service = virtio_crypto_akcipher_algs[i].service;\n\t\tuint32_t algonum = virtio_crypto_akcipher_algs[i].algonum;\n\n\t\tif (!virtcrypto_algo_is_supported(vcrypto, service, algonum))\n\t\t\tcontinue;\n\n\t\tif (virtio_crypto_akcipher_algs[i].active_devs == 0) {\n\t\t\tret = crypto_engine_register_akcipher(&virtio_crypto_akcipher_algs[i].algo);\n\t\t\tif (ret)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tvirtio_crypto_akcipher_algs[i].active_devs++;\n\t\tdev_info(&vcrypto->vdev->dev, \"Registered akcipher algo %s\\n\",\n\t\t\t virtio_crypto_akcipher_algs[i].algo.base.base.cra_name);\n\t}\n\nunlock:\n\tmutex_unlock(&algs_lock);\n\treturn ret;\n}\n\nvoid virtio_crypto_akcipher_algs_unregister(struct virtio_crypto *vcrypto)\n{\n\tint i = 0;\n\n\tmutex_lock(&algs_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(virtio_crypto_akcipher_algs); i++) {\n\t\tuint32_t service = virtio_crypto_akcipher_algs[i].service;\n\t\tuint32_t algonum = virtio_crypto_akcipher_algs[i].algonum;\n\n\t\tif (virtio_crypto_akcipher_algs[i].active_devs == 0 ||\n\t\t    !virtcrypto_algo_is_supported(vcrypto, service, algonum))\n\t\t\tcontinue;\n\n\t\tif (virtio_crypto_akcipher_algs[i].active_devs == 1)\n\t\t\tcrypto_engine_unregister_akcipher(&virtio_crypto_akcipher_algs[i].algo);\n\n\t\tvirtio_crypto_akcipher_algs[i].active_devs--;\n\t}\n\n\tmutex_unlock(&algs_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}