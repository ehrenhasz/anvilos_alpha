{
  "module_name": "atmel-ecc.c",
  "hash_id": "c2811424d61be43272f662f43a4e61030478d7f1bdb9b5a62d675515b3ef4921",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/atmel-ecc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <crypto/internal/kpp.h>\n#include <crypto/ecdh.h>\n#include <crypto/kpp.h>\n#include \"atmel-i2c.h\"\n\nstatic struct atmel_ecc_driver_data driver_data;\n\n \nstruct atmel_ecdh_ctx {\n\tstruct i2c_client *client;\n\tstruct crypto_kpp *fallback;\n\tconst u8 *public_key;\n\tunsigned int curve_id;\n\tbool do_fallback;\n};\n\nstatic void atmel_ecdh_done(struct atmel_i2c_work_data *work_data, void *areq,\n\t\t\t    int status)\n{\n\tstruct kpp_request *req = areq;\n\tstruct atmel_i2c_cmd *cmd = &work_data->cmd;\n\tsize_t copied, n_sz;\n\n\tif (status)\n\t\tgoto free_work_data;\n\n\t \n\tn_sz = min_t(size_t, ATMEL_ECC_NIST_P256_N_SIZE, req->dst_len);\n\n\t \n\tcopied = sg_copy_from_buffer(req->dst, sg_nents_for_len(req->dst, n_sz),\n\t\t\t\t     &cmd->data[RSP_DATA_IDX], n_sz);\n\tif (copied != n_sz)\n\t\tstatus = -EINVAL;\n\n\t \nfree_work_data:\n\tkfree_sensitive(work_data);\n\tkpp_request_complete(req, status);\n}\n\n \nstatic int atmel_ecdh_set_secret(struct crypto_kpp *tfm, const void *buf,\n\t\t\t\t unsigned int len)\n{\n\tstruct atmel_ecdh_ctx *ctx = kpp_tfm_ctx(tfm);\n\tstruct atmel_i2c_cmd *cmd;\n\tvoid *public_key;\n\tstruct ecdh params;\n\tint ret = -ENOMEM;\n\n\t \n\tkfree(ctx->public_key);\n\t \n\tctx->public_key = NULL;\n\n\tif (crypto_ecdh_decode_key(buf, len, &params) < 0) {\n\t\tdev_err(&ctx->client->dev, \"crypto_ecdh_decode_key failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (params.key_size) {\n\t\t \n\t\tctx->do_fallback = true;\n\t\treturn crypto_kpp_set_secret(ctx->fallback, buf, len);\n\t}\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\t \n\tpublic_key = kmalloc(ATMEL_ECC_PUBKEY_SIZE, GFP_KERNEL);\n\tif (!public_key)\n\t\tgoto free_cmd;\n\n\tctx->do_fallback = false;\n\n\tatmel_i2c_init_genkey_cmd(cmd, DATA_SLOT_2);\n\n\tret = atmel_i2c_send_receive(ctx->client, cmd);\n\tif (ret)\n\t\tgoto free_public_key;\n\n\t \n\tmemcpy(public_key, &cmd->data[RSP_DATA_IDX], ATMEL_ECC_PUBKEY_SIZE);\n\tctx->public_key = public_key;\n\n\tkfree(cmd);\n\treturn 0;\n\nfree_public_key:\n\tkfree(public_key);\nfree_cmd:\n\tkfree(cmd);\n\treturn ret;\n}\n\nstatic int atmel_ecdh_generate_public_key(struct kpp_request *req)\n{\n\tstruct crypto_kpp *tfm = crypto_kpp_reqtfm(req);\n\tstruct atmel_ecdh_ctx *ctx = kpp_tfm_ctx(tfm);\n\tsize_t copied, nbytes;\n\tint ret = 0;\n\n\tif (ctx->do_fallback) {\n\t\tkpp_request_set_tfm(req, ctx->fallback);\n\t\treturn crypto_kpp_generate_public_key(req);\n\t}\n\n\tif (!ctx->public_key)\n\t\treturn -EINVAL;\n\n\t \n\tnbytes = min_t(size_t, ATMEL_ECC_PUBKEY_SIZE, req->dst_len);\n\n\t \n\tcopied = sg_copy_from_buffer(req->dst,\n\t\t\t\t     sg_nents_for_len(req->dst, nbytes),\n\t\t\t\t     ctx->public_key, nbytes);\n\tif (copied != nbytes)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic int atmel_ecdh_compute_shared_secret(struct kpp_request *req)\n{\n\tstruct crypto_kpp *tfm = crypto_kpp_reqtfm(req);\n\tstruct atmel_ecdh_ctx *ctx = kpp_tfm_ctx(tfm);\n\tstruct atmel_i2c_work_data *work_data;\n\tgfp_t gfp;\n\tint ret;\n\n\tif (ctx->do_fallback) {\n\t\tkpp_request_set_tfm(req, ctx->fallback);\n\t\treturn crypto_kpp_compute_shared_secret(req);\n\t}\n\n\t \n\tif (req->src_len != ATMEL_ECC_PUBKEY_SIZE)\n\t\treturn -EINVAL;\n\n\tgfp = (req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP) ? GFP_KERNEL :\n\t\t\t\t\t\t\t     GFP_ATOMIC;\n\n\twork_data = kmalloc(sizeof(*work_data), gfp);\n\tif (!work_data)\n\t\treturn -ENOMEM;\n\n\twork_data->ctx = ctx;\n\twork_data->client = ctx->client;\n\n\tret = atmel_i2c_init_ecdh_cmd(&work_data->cmd, req->src);\n\tif (ret)\n\t\tgoto free_work_data;\n\n\tatmel_i2c_enqueue(work_data, atmel_ecdh_done, req);\n\n\treturn -EINPROGRESS;\n\nfree_work_data:\n\tkfree(work_data);\n\treturn ret;\n}\n\nstatic struct i2c_client *atmel_ecc_i2c_client_alloc(void)\n{\n\tstruct atmel_i2c_client_priv *i2c_priv, *min_i2c_priv = NULL;\n\tstruct i2c_client *client = ERR_PTR(-ENODEV);\n\tint min_tfm_cnt = INT_MAX;\n\tint tfm_cnt;\n\n\tspin_lock(&driver_data.i2c_list_lock);\n\n\tif (list_empty(&driver_data.i2c_client_list)) {\n\t\tspin_unlock(&driver_data.i2c_list_lock);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tlist_for_each_entry(i2c_priv, &driver_data.i2c_client_list,\n\t\t\t    i2c_client_list_node) {\n\t\ttfm_cnt = atomic_read(&i2c_priv->tfm_count);\n\t\tif (tfm_cnt < min_tfm_cnt) {\n\t\t\tmin_tfm_cnt = tfm_cnt;\n\t\t\tmin_i2c_priv = i2c_priv;\n\t\t}\n\t\tif (!min_tfm_cnt)\n\t\t\tbreak;\n\t}\n\n\tif (min_i2c_priv) {\n\t\tatomic_inc(&min_i2c_priv->tfm_count);\n\t\tclient = min_i2c_priv->client;\n\t}\n\n\tspin_unlock(&driver_data.i2c_list_lock);\n\n\treturn client;\n}\n\nstatic void atmel_ecc_i2c_client_free(struct i2c_client *client)\n{\n\tstruct atmel_i2c_client_priv *i2c_priv = i2c_get_clientdata(client);\n\n\tatomic_dec(&i2c_priv->tfm_count);\n}\n\nstatic int atmel_ecdh_init_tfm(struct crypto_kpp *tfm)\n{\n\tconst char *alg = kpp_alg_name(tfm);\n\tstruct crypto_kpp *fallback;\n\tstruct atmel_ecdh_ctx *ctx = kpp_tfm_ctx(tfm);\n\n\tctx->curve_id = ECC_CURVE_NIST_P256;\n\tctx->client = atmel_ecc_i2c_client_alloc();\n\tif (IS_ERR(ctx->client)) {\n\t\tpr_err(\"tfm - i2c_client binding failed\\n\");\n\t\treturn PTR_ERR(ctx->client);\n\t}\n\n\tfallback = crypto_alloc_kpp(alg, 0, CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(fallback)) {\n\t\tdev_err(&ctx->client->dev, \"Failed to allocate transformation for '%s': %ld\\n\",\n\t\t\talg, PTR_ERR(fallback));\n\t\treturn PTR_ERR(fallback);\n\t}\n\n\tcrypto_kpp_set_flags(fallback, crypto_kpp_get_flags(tfm));\n\tctx->fallback = fallback;\n\n\treturn 0;\n}\n\nstatic void atmel_ecdh_exit_tfm(struct crypto_kpp *tfm)\n{\n\tstruct atmel_ecdh_ctx *ctx = kpp_tfm_ctx(tfm);\n\n\tkfree(ctx->public_key);\n\tcrypto_free_kpp(ctx->fallback);\n\tatmel_ecc_i2c_client_free(ctx->client);\n}\n\nstatic unsigned int atmel_ecdh_max_size(struct crypto_kpp *tfm)\n{\n\tstruct atmel_ecdh_ctx *ctx = kpp_tfm_ctx(tfm);\n\n\tif (ctx->fallback)\n\t\treturn crypto_kpp_maxsize(ctx->fallback);\n\n\t \n\treturn ATMEL_ECC_PUBKEY_SIZE;\n}\n\nstatic struct kpp_alg atmel_ecdh_nist_p256 = {\n\t.set_secret = atmel_ecdh_set_secret,\n\t.generate_public_key = atmel_ecdh_generate_public_key,\n\t.compute_shared_secret = atmel_ecdh_compute_shared_secret,\n\t.init = atmel_ecdh_init_tfm,\n\t.exit = atmel_ecdh_exit_tfm,\n\t.max_size = atmel_ecdh_max_size,\n\t.base = {\n\t\t.cra_flags = CRYPTO_ALG_NEED_FALLBACK,\n\t\t.cra_name = \"ecdh-nist-p256\",\n\t\t.cra_driver_name = \"atmel-ecdh\",\n\t\t.cra_priority = ATMEL_ECC_PRIORITY,\n\t\t.cra_module = THIS_MODULE,\n\t\t.cra_ctxsize = sizeof(struct atmel_ecdh_ctx),\n\t},\n};\n\nstatic int atmel_ecc_probe(struct i2c_client *client)\n{\n\tstruct atmel_i2c_client_priv *i2c_priv;\n\tint ret;\n\n\tret = atmel_i2c_probe(client);\n\tif (ret)\n\t\treturn ret;\n\n\ti2c_priv = i2c_get_clientdata(client);\n\n\tspin_lock(&driver_data.i2c_list_lock);\n\tlist_add_tail(&i2c_priv->i2c_client_list_node,\n\t\t      &driver_data.i2c_client_list);\n\tspin_unlock(&driver_data.i2c_list_lock);\n\n\tret = crypto_register_kpp(&atmel_ecdh_nist_p256);\n\tif (ret) {\n\t\tspin_lock(&driver_data.i2c_list_lock);\n\t\tlist_del(&i2c_priv->i2c_client_list_node);\n\t\tspin_unlock(&driver_data.i2c_list_lock);\n\n\t\tdev_err(&client->dev, \"%s alg registration failed\\n\",\n\t\t\tatmel_ecdh_nist_p256.base.cra_driver_name);\n\t} else {\n\t\tdev_info(&client->dev, \"atmel ecc algorithms registered in /proc/crypto\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic void atmel_ecc_remove(struct i2c_client *client)\n{\n\tstruct atmel_i2c_client_priv *i2c_priv = i2c_get_clientdata(client);\n\n\t \n\tif (atomic_read(&i2c_priv->tfm_count)) {\n\t\t \n\t\tdev_emerg(&client->dev, \"Device is busy, expect memory corruption.\\n\");\n\t\treturn;\n\t}\n\n\tcrypto_unregister_kpp(&atmel_ecdh_nist_p256);\n\n\tspin_lock(&driver_data.i2c_list_lock);\n\tlist_del(&i2c_priv->i2c_client_list_node);\n\tspin_unlock(&driver_data.i2c_list_lock);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id atmel_ecc_dt_ids[] = {\n\t{\n\t\t.compatible = \"atmel,atecc508a\",\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, atmel_ecc_dt_ids);\n#endif\n\nstatic const struct i2c_device_id atmel_ecc_id[] = {\n\t{ \"atecc508a\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, atmel_ecc_id);\n\nstatic struct i2c_driver atmel_ecc_driver = {\n\t.driver = {\n\t\t.name\t= \"atmel-ecc\",\n\t\t.of_match_table = of_match_ptr(atmel_ecc_dt_ids),\n\t},\n\t.probe\t\t= atmel_ecc_probe,\n\t.remove\t\t= atmel_ecc_remove,\n\t.id_table\t= atmel_ecc_id,\n};\n\nstatic int __init atmel_ecc_init(void)\n{\n\tspin_lock_init(&driver_data.i2c_list_lock);\n\tINIT_LIST_HEAD(&driver_data.i2c_client_list);\n\treturn i2c_add_driver(&atmel_ecc_driver);\n}\n\nstatic void __exit atmel_ecc_exit(void)\n{\n\tatmel_i2c_flush_queue();\n\ti2c_del_driver(&atmel_ecc_driver);\n}\n\nmodule_init(atmel_ecc_init);\nmodule_exit(atmel_ecc_exit);\n\nMODULE_AUTHOR(\"Tudor Ambarus\");\nMODULE_DESCRIPTION(\"Microchip / Atmel ECC (I2C) driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}