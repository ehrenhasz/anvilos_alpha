{
  "module_name": "stm32-hash.c",
  "hash_id": "bd3dc6b5eac7fd603c68b44dc8ca0c79edc5eafc9d22985eecbc52349a80e506",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/stm32/stm32-hash.c",
  "human_readable_source": "\n \n\n#include <crypto/engine.h>\n#include <crypto/internal/hash.h>\n#include <crypto/md5.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/sha1.h>\n#include <crypto/sha2.h>\n#include <crypto/sha3.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/string.h>\n\n#define HASH_CR\t\t\t\t0x00\n#define HASH_DIN\t\t\t0x04\n#define HASH_STR\t\t\t0x08\n#define HASH_UX500_HREG(x)\t\t(0x0c + ((x) * 0x04))\n#define HASH_IMR\t\t\t0x20\n#define HASH_SR\t\t\t\t0x24\n#define HASH_CSR(x)\t\t\t(0x0F8 + ((x) * 0x04))\n#define HASH_HREG(x)\t\t\t(0x310 + ((x) * 0x04))\n#define HASH_HWCFGR\t\t\t0x3F0\n#define HASH_VER\t\t\t0x3F4\n#define HASH_ID\t\t\t\t0x3F8\n\n \n#define HASH_CR_INIT\t\t\tBIT(2)\n#define HASH_CR_DMAE\t\t\tBIT(3)\n#define HASH_CR_DATATYPE_POS\t\t4\n#define HASH_CR_MODE\t\t\tBIT(6)\n#define HASH_CR_ALGO_POS\t\t7\n#define HASH_CR_MDMAT\t\t\tBIT(13)\n#define HASH_CR_DMAA\t\t\tBIT(14)\n#define HASH_CR_LKEY\t\t\tBIT(16)\n\n \n#define HASH_DINIE\t\t\tBIT(0)\n#define HASH_DCIE\t\t\tBIT(1)\n\n \n#define HASH_MASK_CALC_COMPLETION\tBIT(0)\n#define HASH_MASK_DATA_INPUT\t\tBIT(1)\n\n \n#define HASH_SR_DATA_INPUT_READY\tBIT(0)\n#define HASH_SR_OUTPUT_READY\t\tBIT(1)\n#define HASH_SR_DMA_ACTIVE\t\tBIT(2)\n#define HASH_SR_BUSY\t\t\tBIT(3)\n\n \n#define HASH_STR_NBLW_MASK\t\tGENMASK(4, 0)\n#define HASH_STR_DCAL\t\t\tBIT(8)\n\n \n#define HASH_HWCFG_DMA_MASK\t\tGENMASK(3, 0)\n\n \n#define HASH_CSR_NB_SHA256_HMAC\t\t54\n#define HASH_CSR_NB_SHA256\t\t38\n#define HASH_CSR_NB_SHA512_HMAC\t\t103\n#define HASH_CSR_NB_SHA512\t\t91\n#define HASH_CSR_NB_SHA3_HMAC\t\t88\n#define HASH_CSR_NB_SHA3\t\t72\n#define HASH_CSR_NB_MAX\t\t\tHASH_CSR_NB_SHA512_HMAC\n\n#define HASH_FLAGS_INIT\t\t\tBIT(0)\n#define HASH_FLAGS_OUTPUT_READY\t\tBIT(1)\n#define HASH_FLAGS_CPU\t\t\tBIT(2)\n#define HASH_FLAGS_DMA_ACTIVE\t\tBIT(3)\n#define HASH_FLAGS_HMAC_INIT\t\tBIT(4)\n#define HASH_FLAGS_HMAC_FINAL\t\tBIT(5)\n#define HASH_FLAGS_HMAC_KEY\t\tBIT(6)\n#define HASH_FLAGS_SHA3_MODE\t\tBIT(7)\n#define HASH_FLAGS_FINAL\t\tBIT(15)\n#define HASH_FLAGS_FINUP\t\tBIT(16)\n#define HASH_FLAGS_ALGO_MASK\t\tGENMASK(20, 17)\n#define HASH_FLAGS_ALGO_SHIFT\t\t17\n#define HASH_FLAGS_ERRORS\t\tBIT(21)\n#define HASH_FLAGS_EMPTY\t\tBIT(22)\n#define HASH_FLAGS_HMAC\t\t\tBIT(23)\n\n#define HASH_OP_UPDATE\t\t\t1\n#define HASH_OP_FINAL\t\t\t2\n\n#define HASH_BURST_LEVEL\t\t4\n\nenum stm32_hash_data_format {\n\tHASH_DATA_32_BITS\t\t= 0x0,\n\tHASH_DATA_16_BITS\t\t= 0x1,\n\tHASH_DATA_8_BITS\t\t= 0x2,\n\tHASH_DATA_1_BIT\t\t\t= 0x3\n};\n\n#define HASH_BUFLEN\t\t\t(SHA3_224_BLOCK_SIZE + 4)\n#define HASH_MAX_KEY_SIZE\t\t(SHA512_BLOCK_SIZE * 8)\n\nenum stm32_hash_algo {\n\tHASH_SHA1\t\t\t= 0,\n\tHASH_MD5\t\t\t= 1,\n\tHASH_SHA224\t\t\t= 2,\n\tHASH_SHA256\t\t\t= 3,\n\tHASH_SHA3_224\t\t\t= 4,\n\tHASH_SHA3_256\t\t\t= 5,\n\tHASH_SHA3_384\t\t\t= 6,\n\tHASH_SHA3_512\t\t\t= 7,\n\tHASH_SHA384\t\t\t= 12,\n\tHASH_SHA512\t\t\t= 15,\n};\n\nenum ux500_hash_algo {\n\tHASH_SHA256_UX500\t\t= 0,\n\tHASH_SHA1_UX500\t\t\t= 1,\n};\n\n#define HASH_AUTOSUSPEND_DELAY\t\t50\n\nstruct stm32_hash_ctx {\n\tstruct stm32_hash_dev\t*hdev;\n\tstruct crypto_shash\t*xtfm;\n\tunsigned long\t\tflags;\n\n\tu8\t\t\tkey[HASH_MAX_KEY_SIZE];\n\tint\t\t\tkeylen;\n};\n\nstruct stm32_hash_state {\n\tu32\t\t\tflags;\n\n\tu16\t\t\tbufcnt;\n\tu16\t\t\tblocklen;\n\n\tu8 buffer[HASH_BUFLEN] __aligned(4);\n\n\t \n\tu32\t\t\thw_context[3 + HASH_CSR_NB_MAX];\n};\n\nstruct stm32_hash_request_ctx {\n\tstruct stm32_hash_dev\t*hdev;\n\tunsigned long\t\top;\n\n\tu8 digest[SHA512_DIGEST_SIZE] __aligned(sizeof(u32));\n\tsize_t\t\t\tdigcnt;\n\n\t \n\tstruct scatterlist\t*sg;\n\tunsigned int\t\toffset;\n\tunsigned int\t\ttotal;\n\tstruct scatterlist\tsg_key;\n\n\tdma_addr_t\t\tdma_addr;\n\tsize_t\t\t\tdma_ct;\n\tint\t\t\tnents;\n\n\tu8\t\t\tdata_type;\n\n\tstruct stm32_hash_state state;\n};\n\nstruct stm32_hash_algs_info {\n\tstruct ahash_engine_alg\t*algs_list;\n\tsize_t\t\t\tsize;\n};\n\nstruct stm32_hash_pdata {\n\tconst int\t\t\t\talg_shift;\n\tconst struct stm32_hash_algs_info\t*algs_info;\n\tsize_t\t\t\t\t\talgs_info_size;\n\tbool\t\t\t\t\thas_sr;\n\tbool\t\t\t\t\thas_mdmat;\n\tbool\t\t\t\t\tbroken_emptymsg;\n\tbool\t\t\t\t\tux500;\n};\n\nstruct stm32_hash_dev {\n\tstruct list_head\tlist;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*clk;\n\tstruct reset_control\t*rst;\n\tvoid __iomem\t\t*io_base;\n\tphys_addr_t\t\tphys_base;\n\tu32\t\t\tdma_mode;\n\tbool\t\t\tpolled;\n\n\tstruct ahash_request\t*req;\n\tstruct crypto_engine\t*engine;\n\n\tunsigned long\t\tflags;\n\n\tstruct dma_chan\t\t*dma_lch;\n\tstruct completion\tdma_completion;\n\n\tconst struct stm32_hash_pdata\t*pdata;\n};\n\nstruct stm32_hash_drv {\n\tstruct list_head\tdev_list;\n\tspinlock_t\t\tlock;  \n};\n\nstatic struct stm32_hash_drv stm32_hash = {\n\t.dev_list = LIST_HEAD_INIT(stm32_hash.dev_list),\n\t.lock = __SPIN_LOCK_UNLOCKED(stm32_hash.lock),\n};\n\nstatic void stm32_hash_dma_callback(void *param);\n\nstatic inline u32 stm32_hash_read(struct stm32_hash_dev *hdev, u32 offset)\n{\n\treturn readl_relaxed(hdev->io_base + offset);\n}\n\nstatic inline void stm32_hash_write(struct stm32_hash_dev *hdev,\n\t\t\t\t    u32 offset, u32 value)\n{\n\twritel_relaxed(value, hdev->io_base + offset);\n}\n\nstatic inline int stm32_hash_wait_busy(struct stm32_hash_dev *hdev)\n{\n\tu32 status;\n\n\t \n\tif (!hdev->pdata->has_sr)\n\t\treturn readl_relaxed_poll_timeout(hdev->io_base + HASH_STR, status,\n\t\t\t\t\t\t  !(status & HASH_STR_DCAL), 10, 10000);\n\n\treturn readl_relaxed_poll_timeout(hdev->io_base + HASH_SR, status,\n\t\t\t\t   !(status & HASH_SR_BUSY), 10, 10000);\n}\n\nstatic void stm32_hash_set_nblw(struct stm32_hash_dev *hdev, int length)\n{\n\tu32 reg;\n\n\treg = stm32_hash_read(hdev, HASH_STR);\n\treg &= ~(HASH_STR_NBLW_MASK);\n\treg |= (8U * ((length) % 4U));\n\tstm32_hash_write(hdev, HASH_STR, reg);\n}\n\nstatic int stm32_hash_write_key(struct stm32_hash_dev *hdev)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(hdev->req);\n\tstruct stm32_hash_ctx *ctx = crypto_ahash_ctx(tfm);\n\tu32 reg;\n\tint keylen = ctx->keylen;\n\tvoid *key = ctx->key;\n\n\tif (keylen) {\n\t\tstm32_hash_set_nblw(hdev, keylen);\n\n\t\twhile (keylen > 0) {\n\t\t\tstm32_hash_write(hdev, HASH_DIN, *(u32 *)key);\n\t\t\tkeylen -= 4;\n\t\t\tkey += 4;\n\t\t}\n\n\t\treg = stm32_hash_read(hdev, HASH_STR);\n\t\treg |= HASH_STR_DCAL;\n\t\tstm32_hash_write(hdev, HASH_STR, reg);\n\n\t\treturn -EINPROGRESS;\n\t}\n\n\treturn 0;\n}\n\nstatic void stm32_hash_write_ctrl(struct stm32_hash_dev *hdev)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(hdev->req);\n\tstruct stm32_hash_ctx *ctx = crypto_ahash_ctx(tfm);\n\tstruct stm32_hash_state *state = &rctx->state;\n\tu32 alg = (state->flags & HASH_FLAGS_ALGO_MASK) >> HASH_FLAGS_ALGO_SHIFT;\n\n\tu32 reg = HASH_CR_INIT;\n\n\tif (!(hdev->flags & HASH_FLAGS_INIT)) {\n\t\tif (hdev->pdata->ux500) {\n\t\t\treg |= ((alg & BIT(0)) << HASH_CR_ALGO_POS);\n\t\t} else {\n\t\t\tif (hdev->pdata->alg_shift == HASH_CR_ALGO_POS)\n\t\t\t\treg |= ((alg & BIT(1)) << 17) |\n\t\t\t\t       ((alg & BIT(0)) << HASH_CR_ALGO_POS);\n\t\t\telse\n\t\t\t\treg |= alg << hdev->pdata->alg_shift;\n\t\t}\n\n\t\treg |= (rctx->data_type << HASH_CR_DATATYPE_POS);\n\n\t\tif (state->flags & HASH_FLAGS_HMAC) {\n\t\t\thdev->flags |= HASH_FLAGS_HMAC;\n\t\t\treg |= HASH_CR_MODE;\n\t\t\tif (ctx->keylen > crypto_ahash_blocksize(tfm))\n\t\t\t\treg |= HASH_CR_LKEY;\n\t\t}\n\n\t\tif (!hdev->polled)\n\t\t\tstm32_hash_write(hdev, HASH_IMR, HASH_DCIE);\n\n\t\tstm32_hash_write(hdev, HASH_CR, reg);\n\n\t\thdev->flags |= HASH_FLAGS_INIT;\n\n\t\t \n\t\trctx->state.blocklen -= sizeof(u32);\n\n\t\tdev_dbg(hdev->dev, \"Write Control %x\\n\", reg);\n\t}\n}\n\nstatic void stm32_hash_append_sg(struct stm32_hash_request_ctx *rctx)\n{\n\tstruct stm32_hash_state *state = &rctx->state;\n\tsize_t count;\n\n\twhile ((state->bufcnt < state->blocklen) && rctx->total) {\n\t\tcount = min(rctx->sg->length - rctx->offset, rctx->total);\n\t\tcount = min_t(size_t, count, state->blocklen - state->bufcnt);\n\n\t\tif (count <= 0) {\n\t\t\tif ((rctx->sg->length == 0) && !sg_is_last(rctx->sg)) {\n\t\t\t\trctx->sg = sg_next(rctx->sg);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tscatterwalk_map_and_copy(state->buffer + state->bufcnt,\n\t\t\t\t\t rctx->sg, rctx->offset, count, 0);\n\n\t\tstate->bufcnt += count;\n\t\trctx->offset += count;\n\t\trctx->total -= count;\n\n\t\tif (rctx->offset == rctx->sg->length) {\n\t\t\trctx->sg = sg_next(rctx->sg);\n\t\t\tif (rctx->sg)\n\t\t\t\trctx->offset = 0;\n\t\t\telse\n\t\t\t\trctx->total = 0;\n\t\t}\n\t}\n}\n\nstatic int stm32_hash_xmit_cpu(struct stm32_hash_dev *hdev,\n\t\t\t       const u8 *buf, size_t length, int final)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);\n\tstruct stm32_hash_state *state = &rctx->state;\n\tunsigned int count, len32;\n\tconst u32 *buffer = (const u32 *)buf;\n\tu32 reg;\n\n\tif (final) {\n\t\thdev->flags |= HASH_FLAGS_FINAL;\n\n\t\t \n\t\tif (!(hdev->flags & HASH_FLAGS_INIT) && !length &&\n\t\t    hdev->pdata->broken_emptymsg) {\n\t\t\tstate->flags |= HASH_FLAGS_EMPTY;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tlen32 = DIV_ROUND_UP(length, sizeof(u32));\n\n\tdev_dbg(hdev->dev, \"%s: length: %zd, final: %x len32 %i\\n\",\n\t\t__func__, length, final, len32);\n\n\thdev->flags |= HASH_FLAGS_CPU;\n\n\tstm32_hash_write_ctrl(hdev);\n\n\tif (stm32_hash_wait_busy(hdev))\n\t\treturn -ETIMEDOUT;\n\n\tif ((hdev->flags & HASH_FLAGS_HMAC) &&\n\t    (!(hdev->flags & HASH_FLAGS_HMAC_KEY))) {\n\t\thdev->flags |= HASH_FLAGS_HMAC_KEY;\n\t\tstm32_hash_write_key(hdev);\n\t\tif (stm32_hash_wait_busy(hdev))\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\tfor (count = 0; count < len32; count++)\n\t\tstm32_hash_write(hdev, HASH_DIN, buffer[count]);\n\n\tif (final) {\n\t\tif (stm32_hash_wait_busy(hdev))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tstm32_hash_set_nblw(hdev, length);\n\t\treg = stm32_hash_read(hdev, HASH_STR);\n\t\treg |= HASH_STR_DCAL;\n\t\tstm32_hash_write(hdev, HASH_STR, reg);\n\t\tif (hdev->flags & HASH_FLAGS_HMAC) {\n\t\t\tif (stm32_hash_wait_busy(hdev))\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\tstm32_hash_write_key(hdev);\n\t\t}\n\t\treturn -EINPROGRESS;\n\t}\n\n\treturn 0;\n}\n\nstatic int hash_swap_reg(struct stm32_hash_request_ctx *rctx)\n{\n\tstruct stm32_hash_state *state = &rctx->state;\n\n\tswitch ((state->flags & HASH_FLAGS_ALGO_MASK) >>\n\t\tHASH_FLAGS_ALGO_SHIFT) {\n\tcase HASH_MD5:\n\tcase HASH_SHA1:\n\tcase HASH_SHA224:\n\tcase HASH_SHA256:\n\t\tif (state->flags & HASH_FLAGS_HMAC)\n\t\t\treturn HASH_CSR_NB_SHA256_HMAC;\n\t\telse\n\t\t\treturn HASH_CSR_NB_SHA256;\n\t\tbreak;\n\n\tcase HASH_SHA384:\n\tcase HASH_SHA512:\n\t\tif (state->flags & HASH_FLAGS_HMAC)\n\t\t\treturn HASH_CSR_NB_SHA512_HMAC;\n\t\telse\n\t\t\treturn HASH_CSR_NB_SHA512;\n\t\tbreak;\n\n\tcase HASH_SHA3_224:\n\tcase HASH_SHA3_256:\n\tcase HASH_SHA3_384:\n\tcase HASH_SHA3_512:\n\t\tif (state->flags & HASH_FLAGS_HMAC)\n\t\t\treturn HASH_CSR_NB_SHA3_HMAC;\n\t\telse\n\t\t\treturn HASH_CSR_NB_SHA3;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int stm32_hash_update_cpu(struct stm32_hash_dev *hdev)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);\n\tstruct stm32_hash_state *state = &rctx->state;\n\tu32 *preg = state->hw_context;\n\tint bufcnt, err = 0, final;\n\tint i, swap_reg;\n\n\tdev_dbg(hdev->dev, \"%s flags %x\\n\", __func__, state->flags);\n\n\tfinal = state->flags & HASH_FLAGS_FINAL;\n\n\twhile ((rctx->total >= state->blocklen) ||\n\t       (state->bufcnt + rctx->total >= state->blocklen)) {\n\t\tstm32_hash_append_sg(rctx);\n\t\tbufcnt = state->bufcnt;\n\t\tstate->bufcnt = 0;\n\t\terr = stm32_hash_xmit_cpu(hdev, state->buffer, bufcnt, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tstm32_hash_append_sg(rctx);\n\n\tif (final) {\n\t\tbufcnt = state->bufcnt;\n\t\tstate->bufcnt = 0;\n\t\treturn stm32_hash_xmit_cpu(hdev, state->buffer, bufcnt, 1);\n\t}\n\n\tif (!(hdev->flags & HASH_FLAGS_INIT))\n\t\treturn 0;\n\n\tif (stm32_hash_wait_busy(hdev))\n\t\treturn -ETIMEDOUT;\n\n\tswap_reg = hash_swap_reg(rctx);\n\n\tif (!hdev->pdata->ux500)\n\t\t*preg++ = stm32_hash_read(hdev, HASH_IMR);\n\t*preg++ = stm32_hash_read(hdev, HASH_STR);\n\t*preg++ = stm32_hash_read(hdev, HASH_CR);\n\tfor (i = 0; i < swap_reg; i++)\n\t\t*preg++ = stm32_hash_read(hdev, HASH_CSR(i));\n\n\tstate->flags |= HASH_FLAGS_INIT;\n\n\treturn err;\n}\n\nstatic int stm32_hash_xmit_dma(struct stm32_hash_dev *hdev,\n\t\t\t       struct scatterlist *sg, int length, int mdma)\n{\n\tstruct dma_async_tx_descriptor *in_desc;\n\tdma_cookie_t cookie;\n\tu32 reg;\n\tint err;\n\n\tin_desc = dmaengine_prep_slave_sg(hdev->dma_lch, sg, 1,\n\t\t\t\t\t  DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT |\n\t\t\t\t\t  DMA_CTRL_ACK);\n\tif (!in_desc) {\n\t\tdev_err(hdev->dev, \"dmaengine_prep_slave error\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treinit_completion(&hdev->dma_completion);\n\tin_desc->callback = stm32_hash_dma_callback;\n\tin_desc->callback_param = hdev;\n\n\thdev->flags |= HASH_FLAGS_FINAL;\n\thdev->flags |= HASH_FLAGS_DMA_ACTIVE;\n\n\treg = stm32_hash_read(hdev, HASH_CR);\n\n\tif (hdev->pdata->has_mdmat) {\n\t\tif (mdma)\n\t\t\treg |= HASH_CR_MDMAT;\n\t\telse\n\t\t\treg &= ~HASH_CR_MDMAT;\n\t}\n\treg |= HASH_CR_DMAE;\n\n\tstm32_hash_write(hdev, HASH_CR, reg);\n\n\tstm32_hash_set_nblw(hdev, length);\n\n\tcookie = dmaengine_submit(in_desc);\n\terr = dma_submit_error(cookie);\n\tif (err)\n\t\treturn -ENOMEM;\n\n\tdma_async_issue_pending(hdev->dma_lch);\n\n\tif (!wait_for_completion_timeout(&hdev->dma_completion,\n\t\t\t\t\t msecs_to_jiffies(100)))\n\t\terr = -ETIMEDOUT;\n\n\tif (dma_async_is_tx_complete(hdev->dma_lch, cookie,\n\t\t\t\t     NULL, NULL) != DMA_COMPLETE)\n\t\terr = -ETIMEDOUT;\n\n\tif (err) {\n\t\tdev_err(hdev->dev, \"DMA Error %i\\n\", err);\n\t\tdmaengine_terminate_all(hdev->dma_lch);\n\t\treturn err;\n\t}\n\n\treturn -EINPROGRESS;\n}\n\nstatic void stm32_hash_dma_callback(void *param)\n{\n\tstruct stm32_hash_dev *hdev = param;\n\n\tcomplete(&hdev->dma_completion);\n}\n\nstatic int stm32_hash_hmac_dma_send(struct stm32_hash_dev *hdev)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(hdev->req);\n\tstruct stm32_hash_ctx *ctx = crypto_ahash_ctx(tfm);\n\tint err;\n\n\tif (ctx->keylen < rctx->state.blocklen || hdev->dma_mode == 1) {\n\t\terr = stm32_hash_write_key(hdev);\n\t\tif (stm32_hash_wait_busy(hdev))\n\t\t\treturn -ETIMEDOUT;\n\t} else {\n\t\tif (!(hdev->flags & HASH_FLAGS_HMAC_KEY))\n\t\t\tsg_init_one(&rctx->sg_key, ctx->key,\n\t\t\t\t    ALIGN(ctx->keylen, sizeof(u32)));\n\n\t\trctx->dma_ct = dma_map_sg(hdev->dev, &rctx->sg_key, 1,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\t\tif (rctx->dma_ct == 0) {\n\t\t\tdev_err(hdev->dev, \"dma_map_sg error\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terr = stm32_hash_xmit_dma(hdev, &rctx->sg_key, ctx->keylen, 0);\n\n\t\tdma_unmap_sg(hdev->dev, &rctx->sg_key, 1, DMA_TO_DEVICE);\n\t}\n\n\treturn err;\n}\n\nstatic int stm32_hash_dma_init(struct stm32_hash_dev *hdev)\n{\n\tstruct dma_slave_config dma_conf;\n\tstruct dma_chan *chan;\n\tint err;\n\n\tmemset(&dma_conf, 0, sizeof(dma_conf));\n\n\tdma_conf.direction = DMA_MEM_TO_DEV;\n\tdma_conf.dst_addr = hdev->phys_base + HASH_DIN;\n\tdma_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tdma_conf.src_maxburst = HASH_BURST_LEVEL;\n\tdma_conf.dst_maxburst = HASH_BURST_LEVEL;\n\tdma_conf.device_fc = false;\n\n\tchan = dma_request_chan(hdev->dev, \"in\");\n\tif (IS_ERR(chan))\n\t\treturn PTR_ERR(chan);\n\n\thdev->dma_lch = chan;\n\n\terr = dmaengine_slave_config(hdev->dma_lch, &dma_conf);\n\tif (err) {\n\t\tdma_release_channel(hdev->dma_lch);\n\t\thdev->dma_lch = NULL;\n\t\tdev_err(hdev->dev, \"Couldn't configure DMA slave.\\n\");\n\t\treturn err;\n\t}\n\n\tinit_completion(&hdev->dma_completion);\n\n\treturn 0;\n}\n\nstatic int stm32_hash_dma_send(struct stm32_hash_dev *hdev)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);\n\tu32 *buffer = (void *)rctx->state.buffer;\n\tstruct scatterlist sg[1], *tsg;\n\tint err = 0, reg, ncp = 0;\n\tunsigned int i, len = 0, bufcnt = 0;\n\tbool is_last = false;\n\n\trctx->sg = hdev->req->src;\n\trctx->total = hdev->req->nbytes;\n\n\trctx->nents = sg_nents(rctx->sg);\n\tif (rctx->nents < 0)\n\t\treturn -EINVAL;\n\n\tstm32_hash_write_ctrl(hdev);\n\n\tif (hdev->flags & HASH_FLAGS_HMAC) {\n\t\terr = stm32_hash_hmac_dma_send(hdev);\n\t\tif (err != -EINPROGRESS)\n\t\t\treturn err;\n\t}\n\n\tfor_each_sg(rctx->sg, tsg, rctx->nents, i) {\n\t\tsg[0] = *tsg;\n\t\tlen = sg->length;\n\n\t\tif (sg_is_last(sg) || (bufcnt + sg[0].length) >= rctx->total) {\n\t\t\tsg->length = rctx->total - bufcnt;\n\t\t\tis_last = true;\n\t\t\tif (hdev->dma_mode == 1) {\n\t\t\t\tlen = (ALIGN(sg->length, 16) - 16);\n\n\t\t\t\tncp = sg_pcopy_to_buffer(\n\t\t\t\t\trctx->sg, rctx->nents,\n\t\t\t\t\trctx->state.buffer, sg->length - len,\n\t\t\t\t\trctx->total - sg->length + len);\n\n\t\t\t\tsg->length = len;\n\t\t\t} else {\n\t\t\t\tif (!(IS_ALIGNED(sg->length, sizeof(u32)))) {\n\t\t\t\t\tlen = sg->length;\n\t\t\t\t\tsg->length = ALIGN(sg->length,\n\t\t\t\t\t\t\t   sizeof(u32));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trctx->dma_ct = dma_map_sg(hdev->dev, sg, 1,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\t\tif (rctx->dma_ct == 0) {\n\t\t\tdev_err(hdev->dev, \"dma_map_sg error\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terr = stm32_hash_xmit_dma(hdev, sg, len, !is_last);\n\n\t\tbufcnt += sg[0].length;\n\t\tdma_unmap_sg(hdev->dev, sg, 1, DMA_TO_DEVICE);\n\n\t\tif (err == -ENOMEM)\n\t\t\treturn err;\n\t\tif (is_last)\n\t\t\tbreak;\n\t}\n\n\tif (hdev->dma_mode == 1) {\n\t\tif (stm32_hash_wait_busy(hdev))\n\t\t\treturn -ETIMEDOUT;\n\t\treg = stm32_hash_read(hdev, HASH_CR);\n\t\treg &= ~HASH_CR_DMAE;\n\t\treg |= HASH_CR_DMAA;\n\t\tstm32_hash_write(hdev, HASH_CR, reg);\n\n\t\tif (ncp) {\n\t\t\tmemset(buffer + ncp, 0,\n\t\t\t       DIV_ROUND_UP(ncp, sizeof(u32)) - ncp);\n\t\t\twritesl(hdev->io_base + HASH_DIN, buffer,\n\t\t\t\tDIV_ROUND_UP(ncp, sizeof(u32)));\n\t\t}\n\t\tstm32_hash_set_nblw(hdev, ncp);\n\t\treg = stm32_hash_read(hdev, HASH_STR);\n\t\treg |= HASH_STR_DCAL;\n\t\tstm32_hash_write(hdev, HASH_STR, reg);\n\t\terr = -EINPROGRESS;\n\t}\n\n\tif (hdev->flags & HASH_FLAGS_HMAC) {\n\t\tif (stm32_hash_wait_busy(hdev))\n\t\t\treturn -ETIMEDOUT;\n\t\terr = stm32_hash_hmac_dma_send(hdev);\n\t}\n\n\treturn err;\n}\n\nstatic struct stm32_hash_dev *stm32_hash_find_dev(struct stm32_hash_ctx *ctx)\n{\n\tstruct stm32_hash_dev *hdev = NULL, *tmp;\n\n\tspin_lock_bh(&stm32_hash.lock);\n\tif (!ctx->hdev) {\n\t\tlist_for_each_entry(tmp, &stm32_hash.dev_list, list) {\n\t\t\thdev = tmp;\n\t\t\tbreak;\n\t\t}\n\t\tctx->hdev = hdev;\n\t} else {\n\t\thdev = ctx->hdev;\n\t}\n\n\tspin_unlock_bh(&stm32_hash.lock);\n\n\treturn hdev;\n}\n\nstatic bool stm32_hash_dma_aligned_data(struct ahash_request *req)\n{\n\tstruct scatterlist *sg;\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));\n\tstruct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);\n\tint i;\n\n\tif (!hdev->dma_lch || req->nbytes <= rctx->state.blocklen)\n\t\treturn false;\n\n\tif (sg_nents(req->src) > 1) {\n\t\tif (hdev->dma_mode == 1)\n\t\t\treturn false;\n\t\tfor_each_sg(req->src, sg, sg_nents(req->src), i) {\n\t\t\tif ((!IS_ALIGNED(sg->length, sizeof(u32))) &&\n\t\t\t    (!sg_is_last(sg)))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (req->src->offset % 4)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int stm32_hash_init(struct ahash_request *req)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct stm32_hash_ctx *ctx = crypto_ahash_ctx(tfm);\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);\n\tstruct stm32_hash_state *state = &rctx->state;\n\tbool sha3_mode = ctx->flags & HASH_FLAGS_SHA3_MODE;\n\n\trctx->hdev = hdev;\n\n\tstate->flags = HASH_FLAGS_CPU;\n\n\tif (sha3_mode)\n\t\tstate->flags |= HASH_FLAGS_SHA3_MODE;\n\n\trctx->digcnt = crypto_ahash_digestsize(tfm);\n\tswitch (rctx->digcnt) {\n\tcase MD5_DIGEST_SIZE:\n\t\tstate->flags |= HASH_MD5 << HASH_FLAGS_ALGO_SHIFT;\n\t\tbreak;\n\tcase SHA1_DIGEST_SIZE:\n\t\tif (hdev->pdata->ux500)\n\t\t\tstate->flags |= HASH_SHA1_UX500 << HASH_FLAGS_ALGO_SHIFT;\n\t\telse\n\t\t\tstate->flags |= HASH_SHA1 << HASH_FLAGS_ALGO_SHIFT;\n\t\tbreak;\n\tcase SHA224_DIGEST_SIZE:\n\t\tif (sha3_mode)\n\t\t\tstate->flags |= HASH_SHA3_224 << HASH_FLAGS_ALGO_SHIFT;\n\t\telse\n\t\t\tstate->flags |= HASH_SHA224 << HASH_FLAGS_ALGO_SHIFT;\n\t\tbreak;\n\tcase SHA256_DIGEST_SIZE:\n\t\tif (sha3_mode) {\n\t\t\tstate->flags |= HASH_SHA3_256 << HASH_FLAGS_ALGO_SHIFT;\n\t\t} else {\n\t\t\tif (hdev->pdata->ux500)\n\t\t\t\tstate->flags |= HASH_SHA256_UX500 << HASH_FLAGS_ALGO_SHIFT;\n\t\t\telse\n\t\t\t\tstate->flags |= HASH_SHA256 << HASH_FLAGS_ALGO_SHIFT;\n\t\t}\n\t\tbreak;\n\tcase SHA384_DIGEST_SIZE:\n\t\tif (sha3_mode)\n\t\t\tstate->flags |= HASH_SHA3_384 << HASH_FLAGS_ALGO_SHIFT;\n\t\telse\n\t\t\tstate->flags |= HASH_SHA384 << HASH_FLAGS_ALGO_SHIFT;\n\t\tbreak;\n\tcase SHA512_DIGEST_SIZE:\n\t\tif (sha3_mode)\n\t\t\tstate->flags |= HASH_SHA3_512 << HASH_FLAGS_ALGO_SHIFT;\n\t\telse\n\t\t\tstate->flags |= HASH_SHA512 << HASH_FLAGS_ALGO_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trctx->state.bufcnt = 0;\n\trctx->state.blocklen = crypto_ahash_blocksize(tfm) + sizeof(u32);\n\tif (rctx->state.blocklen > HASH_BUFLEN) {\n\t\tdev_err(hdev->dev, \"Error, block too large\");\n\t\treturn -EINVAL;\n\t}\n\trctx->total = 0;\n\trctx->offset = 0;\n\trctx->data_type = HASH_DATA_8_BITS;\n\n\tif (ctx->flags & HASH_FLAGS_HMAC)\n\t\tstate->flags |= HASH_FLAGS_HMAC;\n\n\tdev_dbg(hdev->dev, \"%s Flags %x\\n\", __func__, state->flags);\n\n\treturn 0;\n}\n\nstatic int stm32_hash_update_req(struct stm32_hash_dev *hdev)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);\n\tstruct stm32_hash_state *state = &rctx->state;\n\n\tif (!(state->flags & HASH_FLAGS_CPU))\n\t\treturn stm32_hash_dma_send(hdev);\n\n\treturn stm32_hash_update_cpu(hdev);\n}\n\nstatic int stm32_hash_final_req(struct stm32_hash_dev *hdev)\n{\n\tstruct ahash_request *req = hdev->req;\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct stm32_hash_state *state = &rctx->state;\n\tint buflen = state->bufcnt;\n\n\tif (state->flags & HASH_FLAGS_FINUP)\n\t\treturn stm32_hash_update_req(hdev);\n\n\tstate->bufcnt = 0;\n\n\treturn stm32_hash_xmit_cpu(hdev, state->buffer, buflen, 1);\n}\n\nstatic void stm32_hash_emptymsg_fallback(struct ahash_request *req)\n{\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct stm32_hash_ctx *ctx = crypto_ahash_ctx(ahash);\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct stm32_hash_dev *hdev = rctx->hdev;\n\tint ret;\n\n\tdev_dbg(hdev->dev, \"use fallback message size 0 key size %d\\n\",\n\t\tctx->keylen);\n\n\tif (!ctx->xtfm) {\n\t\tdev_err(hdev->dev, \"no fallback engine\\n\");\n\t\treturn;\n\t}\n\n\tif (ctx->keylen) {\n\t\tret = crypto_shash_setkey(ctx->xtfm, ctx->key, ctx->keylen);\n\t\tif (ret) {\n\t\t\tdev_err(hdev->dev, \"failed to set key ret=%d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tret = crypto_shash_tfm_digest(ctx->xtfm, NULL, 0, rctx->digest);\n\tif (ret)\n\t\tdev_err(hdev->dev, \"shash digest error\\n\");\n}\n\nstatic void stm32_hash_copy_hash(struct ahash_request *req)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct stm32_hash_state *state = &rctx->state;\n\tstruct stm32_hash_dev *hdev = rctx->hdev;\n\t__be32 *hash = (void *)rctx->digest;\n\tunsigned int i, hashsize;\n\n\tif (hdev->pdata->broken_emptymsg && (state->flags & HASH_FLAGS_EMPTY))\n\t\treturn stm32_hash_emptymsg_fallback(req);\n\n\thashsize = crypto_ahash_digestsize(tfm);\n\n\tfor (i = 0; i < hashsize / sizeof(u32); i++) {\n\t\tif (hdev->pdata->ux500)\n\t\t\thash[i] = cpu_to_be32(stm32_hash_read(hdev,\n\t\t\t\t\t      HASH_UX500_HREG(i)));\n\t\telse\n\t\t\thash[i] = cpu_to_be32(stm32_hash_read(hdev,\n\t\t\t\t\t      HASH_HREG(i)));\n\t}\n}\n\nstatic int stm32_hash_finish(struct ahash_request *req)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\tu32 reg;\n\n\treg = stm32_hash_read(rctx->hdev, HASH_SR);\n\treg &= ~HASH_SR_OUTPUT_READY;\n\tstm32_hash_write(rctx->hdev, HASH_SR, reg);\n\n\tif (!req->result)\n\t\treturn -EINVAL;\n\n\tmemcpy(req->result, rctx->digest, rctx->digcnt);\n\n\treturn 0;\n}\n\nstatic void stm32_hash_finish_req(struct ahash_request *req, int err)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct stm32_hash_dev *hdev = rctx->hdev;\n\n\tif (!err && (HASH_FLAGS_FINAL & hdev->flags)) {\n\t\tstm32_hash_copy_hash(req);\n\t\terr = stm32_hash_finish(req);\n\t}\n\n\tpm_runtime_mark_last_busy(hdev->dev);\n\tpm_runtime_put_autosuspend(hdev->dev);\n\n\tcrypto_finalize_hash_request(hdev->engine, req, err);\n}\n\nstatic int stm32_hash_handle_queue(struct stm32_hash_dev *hdev,\n\t\t\t\t   struct ahash_request *req)\n{\n\treturn crypto_transfer_hash_request_to_engine(hdev->engine, req);\n}\n\nstatic int stm32_hash_one_request(struct crypto_engine *engine, void *areq)\n{\n\tstruct ahash_request *req = container_of(areq, struct ahash_request,\n\t\t\t\t\t\t base);\n\tstruct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);\n\tstruct stm32_hash_state *state = &rctx->state;\n\tint swap_reg;\n\tint err = 0;\n\n\tif (!hdev)\n\t\treturn -ENODEV;\n\n\tdev_dbg(hdev->dev, \"processing new req, op: %lu, nbytes %d\\n\",\n\t\trctx->op, req->nbytes);\n\n\tpm_runtime_get_sync(hdev->dev);\n\n\thdev->req = req;\n\thdev->flags = 0;\n\tswap_reg = hash_swap_reg(rctx);\n\n\tif (state->flags & HASH_FLAGS_INIT) {\n\t\tu32 *preg = rctx->state.hw_context;\n\t\tu32 reg;\n\t\tint i;\n\n\t\tif (!hdev->pdata->ux500)\n\t\t\tstm32_hash_write(hdev, HASH_IMR, *preg++);\n\t\tstm32_hash_write(hdev, HASH_STR, *preg++);\n\t\tstm32_hash_write(hdev, HASH_CR, *preg);\n\t\treg = *preg++ | HASH_CR_INIT;\n\t\tstm32_hash_write(hdev, HASH_CR, reg);\n\n\t\tfor (i = 0; i < swap_reg; i++)\n\t\t\tstm32_hash_write(hdev, HASH_CSR(i), *preg++);\n\n\t\thdev->flags |= HASH_FLAGS_INIT;\n\n\t\tif (state->flags & HASH_FLAGS_HMAC)\n\t\t\thdev->flags |= HASH_FLAGS_HMAC |\n\t\t\t\t       HASH_FLAGS_HMAC_KEY;\n\t}\n\n\tif (rctx->op == HASH_OP_UPDATE)\n\t\terr = stm32_hash_update_req(hdev);\n\telse if (rctx->op == HASH_OP_FINAL)\n\t\terr = stm32_hash_final_req(hdev);\n\n\t \n\tif (err == -EINPROGRESS && hdev->polled) {\n\t\tif (stm32_hash_wait_busy(hdev))\n\t\t\terr = -ETIMEDOUT;\n\t\telse {\n\t\t\thdev->flags |= HASH_FLAGS_OUTPUT_READY;\n\t\t\terr = 0;\n\t\t}\n\t}\n\n\tif (err != -EINPROGRESS)\n\t \n\t\tstm32_hash_finish_req(req, err);\n\n\treturn 0;\n}\n\nstatic int stm32_hash_enqueue(struct ahash_request *req, unsigned int op)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct stm32_hash_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\n\tstruct stm32_hash_dev *hdev = ctx->hdev;\n\n\trctx->op = op;\n\n\treturn stm32_hash_handle_queue(hdev, req);\n}\n\nstatic int stm32_hash_update(struct ahash_request *req)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct stm32_hash_state *state = &rctx->state;\n\n\tif (!req->nbytes || !(state->flags & HASH_FLAGS_CPU))\n\t\treturn 0;\n\n\trctx->total = req->nbytes;\n\trctx->sg = req->src;\n\trctx->offset = 0;\n\n\tif ((state->bufcnt + rctx->total < state->blocklen)) {\n\t\tstm32_hash_append_sg(rctx);\n\t\treturn 0;\n\t}\n\n\treturn stm32_hash_enqueue(req, HASH_OP_UPDATE);\n}\n\nstatic int stm32_hash_final(struct ahash_request *req)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct stm32_hash_state *state = &rctx->state;\n\n\tstate->flags |= HASH_FLAGS_FINAL;\n\n\treturn stm32_hash_enqueue(req, HASH_OP_FINAL);\n}\n\nstatic int stm32_hash_finup(struct ahash_request *req)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\tstruct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));\n\tstruct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);\n\tstruct stm32_hash_state *state = &rctx->state;\n\n\tif (!req->nbytes)\n\t\tgoto out;\n\n\tstate->flags |= HASH_FLAGS_FINUP;\n\trctx->total = req->nbytes;\n\trctx->sg = req->src;\n\trctx->offset = 0;\n\n\tif (hdev->dma_lch && stm32_hash_dma_aligned_data(req))\n\t\tstate->flags &= ~HASH_FLAGS_CPU;\n\nout:\n\treturn stm32_hash_final(req);\n}\n\nstatic int stm32_hash_digest(struct ahash_request *req)\n{\n\treturn stm32_hash_init(req) ?: stm32_hash_finup(req);\n}\n\nstatic int stm32_hash_export(struct ahash_request *req, void *out)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\n\tmemcpy(out, &rctx->state, sizeof(rctx->state));\n\n\treturn 0;\n}\n\nstatic int stm32_hash_import(struct ahash_request *req, const void *in)\n{\n\tstruct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);\n\n\tstm32_hash_init(req);\n\tmemcpy(&rctx->state, in, sizeof(rctx->state));\n\n\treturn 0;\n}\n\nstatic int stm32_hash_setkey(struct crypto_ahash *tfm,\n\t\t\t     const u8 *key, unsigned int keylen)\n{\n\tstruct stm32_hash_ctx *ctx = crypto_ahash_ctx(tfm);\n\n\tif (keylen <= HASH_MAX_KEY_SIZE) {\n\t\tmemcpy(ctx->key, key, keylen);\n\t\tctx->keylen = keylen;\n\t} else {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_hash_init_fallback(struct crypto_tfm *tfm)\n{\n\tstruct stm32_hash_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);\n\tconst char *name = crypto_tfm_alg_name(tfm);\n\tstruct crypto_shash *xtfm;\n\n\t \n\tif (!hdev->pdata->ux500)\n\t\treturn 0;\n\n\txtfm = crypto_alloc_shash(name, 0, CRYPTO_ALG_NEED_FALLBACK);\n\tif (IS_ERR(xtfm)) {\n\t\tdev_err(hdev->dev, \"failed to allocate %s fallback\\n\",\n\t\t\tname);\n\t\treturn PTR_ERR(xtfm);\n\t}\n\tdev_info(hdev->dev, \"allocated %s fallback\\n\", name);\n\tctx->xtfm = xtfm;\n\n\treturn 0;\n}\n\nstatic int stm32_hash_cra_init_algs(struct crypto_tfm *tfm, u32 algs_flags)\n{\n\tstruct stm32_hash_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tcrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\n\t\t\t\t sizeof(struct stm32_hash_request_ctx));\n\n\tctx->keylen = 0;\n\n\tif (algs_flags)\n\t\tctx->flags |= algs_flags;\n\n\treturn stm32_hash_init_fallback(tfm);\n}\n\nstatic int stm32_hash_cra_init(struct crypto_tfm *tfm)\n{\n\treturn stm32_hash_cra_init_algs(tfm, 0);\n}\n\nstatic int stm32_hash_cra_hmac_init(struct crypto_tfm *tfm)\n{\n\treturn stm32_hash_cra_init_algs(tfm, HASH_FLAGS_HMAC);\n}\n\nstatic int stm32_hash_cra_sha3_init(struct crypto_tfm *tfm)\n{\n\treturn stm32_hash_cra_init_algs(tfm, HASH_FLAGS_SHA3_MODE);\n}\n\nstatic int stm32_hash_cra_sha3_hmac_init(struct crypto_tfm *tfm)\n{\n\treturn stm32_hash_cra_init_algs(tfm, HASH_FLAGS_SHA3_MODE |\n\t\t\t\t\tHASH_FLAGS_HMAC);\n}\n\n\nstatic void stm32_hash_cra_exit(struct crypto_tfm *tfm)\n{\n\tstruct stm32_hash_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tif (ctx->xtfm)\n\t\tcrypto_free_shash(ctx->xtfm);\n}\n\nstatic irqreturn_t stm32_hash_irq_thread(int irq, void *dev_id)\n{\n\tstruct stm32_hash_dev *hdev = dev_id;\n\n\tif (HASH_FLAGS_CPU & hdev->flags) {\n\t\tif (HASH_FLAGS_OUTPUT_READY & hdev->flags) {\n\t\t\thdev->flags &= ~HASH_FLAGS_OUTPUT_READY;\n\t\t\tgoto finish;\n\t\t}\n\t} else if (HASH_FLAGS_DMA_ACTIVE & hdev->flags) {\n\t\thdev->flags &= ~HASH_FLAGS_DMA_ACTIVE;\n\t\t\tgoto finish;\n\t}\n\n\treturn IRQ_HANDLED;\n\nfinish:\n\t \n\tstm32_hash_finish_req(hdev->req, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t stm32_hash_irq_handler(int irq, void *dev_id)\n{\n\tstruct stm32_hash_dev *hdev = dev_id;\n\tu32 reg;\n\n\treg = stm32_hash_read(hdev, HASH_SR);\n\tif (reg & HASH_SR_OUTPUT_READY) {\n\t\thdev->flags |= HASH_FLAGS_OUTPUT_READY;\n\t\t \n\t\tstm32_hash_write(hdev, HASH_IMR, 0);\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic struct ahash_engine_alg algs_md5[] = {\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.halg = {\n\t\t\t.digestsize = MD5_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"md5\",\n\t\t\t\t.cra_driver_name = \"stm32-md5\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = MD5_HMAC_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.setkey = stm32_hash_setkey,\n\t\t.base.halg = {\n\t\t\t.digestsize = MD5_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"hmac(md5)\",\n\t\t\t\t.cra_driver_name = \"stm32-hmac-md5\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = MD5_HMAC_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_hmac_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t}\n};\n\nstatic struct ahash_engine_alg algs_sha1[] = {\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA1_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha1\",\n\t\t\t\t.cra_driver_name = \"stm32-sha1\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA1_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.setkey = stm32_hash_setkey,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA1_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"hmac(sha1)\",\n\t\t\t\t.cra_driver_name = \"stm32-hmac-sha1\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA1_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_hmac_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n};\n\nstatic struct ahash_engine_alg algs_sha224[] = {\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA224_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha224\",\n\t\t\t\t.cra_driver_name = \"stm32-sha224\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA224_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.setkey = stm32_hash_setkey,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA224_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"hmac(sha224)\",\n\t\t\t\t.cra_driver_name = \"stm32-hmac-sha224\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA224_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_hmac_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n};\n\nstatic struct ahash_engine_alg algs_sha256[] = {\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA256_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha256\",\n\t\t\t\t.cra_driver_name = \"stm32-sha256\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA256_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.setkey = stm32_hash_setkey,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA256_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"hmac(sha256)\",\n\t\t\t\t.cra_driver_name = \"stm32-hmac-sha256\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA256_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_hmac_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n};\n\nstatic struct ahash_engine_alg algs_sha384_sha512[] = {\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA384_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha384\",\n\t\t\t\t.cra_driver_name = \"stm32-sha384\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA384_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.setkey = stm32_hash_setkey,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA384_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"hmac(sha384)\",\n\t\t\t\t.cra_driver_name = \"stm32-hmac-sha384\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA384_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_hmac_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA512_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha512\",\n\t\t\t\t.cra_driver_name = \"stm32-sha512\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA512_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.setkey = stm32_hash_setkey,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA512_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"hmac(sha512)\",\n\t\t\t\t.cra_driver_name = \"stm32-hmac-sha512\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA512_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_hmac_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n};\n\nstatic struct ahash_engine_alg algs_sha3[] = {\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA3_224_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha3-224\",\n\t\t\t\t.cra_driver_name = \"stm32-sha3-224\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA3_224_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_sha3_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.setkey = stm32_hash_setkey,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA3_224_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"hmac(sha3-224)\",\n\t\t\t\t.cra_driver_name = \"stm32-hmac-sha3-224\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA3_224_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_sha3_hmac_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA3_256_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha3-256\",\n\t\t\t\t.cra_driver_name = \"stm32-sha3-256\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA3_256_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_sha3_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.setkey = stm32_hash_setkey,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA3_256_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"hmac(sha3-256)\",\n\t\t\t\t.cra_driver_name = \"stm32-hmac-sha3-256\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA3_256_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_sha3_hmac_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA3_384_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha3-384\",\n\t\t\t\t.cra_driver_name = \"stm32-sha3-384\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA3_384_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_sha3_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.setkey = stm32_hash_setkey,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA3_384_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"hmac(sha3-384)\",\n\t\t\t\t.cra_driver_name = \"stm32-hmac-sha3-384\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA3_384_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_sha3_hmac_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA3_512_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"sha3-512\",\n\t\t\t\t.cra_driver_name = \"stm32-sha3-512\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA3_512_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_sha3_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t},\n\t{\n\t\t.base.init = stm32_hash_init,\n\t\t.base.update = stm32_hash_update,\n\t\t.base.final = stm32_hash_final,\n\t\t.base.finup = stm32_hash_finup,\n\t\t.base.digest = stm32_hash_digest,\n\t\t.base.export = stm32_hash_export,\n\t\t.base.import = stm32_hash_import,\n\t\t.base.setkey = stm32_hash_setkey,\n\t\t.base.halg = {\n\t\t\t.digestsize = SHA3_512_DIGEST_SIZE,\n\t\t\t.statesize = sizeof(struct stm32_hash_state),\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"hmac(sha3-512)\",\n\t\t\t\t.cra_driver_name = \"stm32-hmac-sha3-512\",\n\t\t\t\t.cra_priority = 200,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t\t.cra_blocksize = SHA3_512_BLOCK_SIZE,\n\t\t\t\t.cra_ctxsize = sizeof(struct stm32_hash_ctx),\n\t\t\t\t.cra_alignmask = 3,\n\t\t\t\t.cra_init = stm32_hash_cra_sha3_hmac_init,\n\t\t\t\t.cra_exit = stm32_hash_cra_exit,\n\t\t\t\t.cra_module = THIS_MODULE,\n\t\t\t}\n\t\t},\n\t\t.op = {\n\t\t\t.do_one_request = stm32_hash_one_request,\n\t\t},\n\t}\n};\n\nstatic int stm32_hash_register_algs(struct stm32_hash_dev *hdev)\n{\n\tunsigned int i, j;\n\tint err;\n\n\tfor (i = 0; i < hdev->pdata->algs_info_size; i++) {\n\t\tfor (j = 0; j < hdev->pdata->algs_info[i].size; j++) {\n\t\t\terr = crypto_engine_register_ahash(\n\t\t\t\t&hdev->pdata->algs_info[i].algs_list[j]);\n\t\t\tif (err)\n\t\t\t\tgoto err_algs;\n\t\t}\n\t}\n\n\treturn 0;\nerr_algs:\n\tdev_err(hdev->dev, \"Algo %d : %d failed\\n\", i, j);\n\tfor (; i--; ) {\n\t\tfor (; j--;)\n\t\t\tcrypto_engine_unregister_ahash(\n\t\t\t\t&hdev->pdata->algs_info[i].algs_list[j]);\n\t}\n\n\treturn err;\n}\n\nstatic int stm32_hash_unregister_algs(struct stm32_hash_dev *hdev)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0; i < hdev->pdata->algs_info_size; i++) {\n\t\tfor (j = 0; j < hdev->pdata->algs_info[i].size; j++)\n\t\t\tcrypto_engine_unregister_ahash(\n\t\t\t\t&hdev->pdata->algs_info[i].algs_list[j]);\n\t}\n\n\treturn 0;\n}\n\nstatic struct stm32_hash_algs_info stm32_hash_algs_info_ux500[] = {\n\t{\n\t\t.algs_list\t= algs_sha1,\n\t\t.size\t\t= ARRAY_SIZE(algs_sha1),\n\t},\n\t{\n\t\t.algs_list\t= algs_sha256,\n\t\t.size\t\t= ARRAY_SIZE(algs_sha256),\n\t},\n};\n\nstatic const struct stm32_hash_pdata stm32_hash_pdata_ux500 = {\n\t.alg_shift\t= 7,\n\t.algs_info\t= stm32_hash_algs_info_ux500,\n\t.algs_info_size\t= ARRAY_SIZE(stm32_hash_algs_info_ux500),\n\t.broken_emptymsg = true,\n\t.ux500\t\t= true,\n};\n\nstatic struct stm32_hash_algs_info stm32_hash_algs_info_stm32f4[] = {\n\t{\n\t\t.algs_list\t= algs_md5,\n\t\t.size\t\t= ARRAY_SIZE(algs_md5),\n\t},\n\t{\n\t\t.algs_list\t= algs_sha1,\n\t\t.size\t\t= ARRAY_SIZE(algs_sha1),\n\t},\n};\n\nstatic const struct stm32_hash_pdata stm32_hash_pdata_stm32f4 = {\n\t.alg_shift\t= 7,\n\t.algs_info\t= stm32_hash_algs_info_stm32f4,\n\t.algs_info_size\t= ARRAY_SIZE(stm32_hash_algs_info_stm32f4),\n\t.has_sr\t\t= true,\n\t.has_mdmat\t= true,\n};\n\nstatic struct stm32_hash_algs_info stm32_hash_algs_info_stm32f7[] = {\n\t{\n\t\t.algs_list\t= algs_md5,\n\t\t.size\t\t= ARRAY_SIZE(algs_md5),\n\t},\n\t{\n\t\t.algs_list\t= algs_sha1,\n\t\t.size\t\t= ARRAY_SIZE(algs_sha1),\n\t},\n\t{\n\t\t.algs_list\t= algs_sha224,\n\t\t.size\t\t= ARRAY_SIZE(algs_sha224),\n\t},\n\t{\n\t\t.algs_list\t= algs_sha256,\n\t\t.size\t\t= ARRAY_SIZE(algs_sha256),\n\t},\n};\n\nstatic const struct stm32_hash_pdata stm32_hash_pdata_stm32f7 = {\n\t.alg_shift\t= 7,\n\t.algs_info\t= stm32_hash_algs_info_stm32f7,\n\t.algs_info_size\t= ARRAY_SIZE(stm32_hash_algs_info_stm32f7),\n\t.has_sr\t\t= true,\n\t.has_mdmat\t= true,\n};\n\nstatic struct stm32_hash_algs_info stm32_hash_algs_info_stm32mp13[] = {\n\t{\n\t\t.algs_list\t= algs_sha1,\n\t\t.size\t\t= ARRAY_SIZE(algs_sha1),\n\t},\n\t{\n\t\t.algs_list\t= algs_sha224,\n\t\t.size\t\t= ARRAY_SIZE(algs_sha224),\n\t},\n\t{\n\t\t.algs_list\t= algs_sha256,\n\t\t.size\t\t= ARRAY_SIZE(algs_sha256),\n\t},\n\t{\n\t\t.algs_list\t= algs_sha384_sha512,\n\t\t.size\t\t= ARRAY_SIZE(algs_sha384_sha512),\n\t},\n\t{\n\t\t.algs_list\t= algs_sha3,\n\t\t.size\t\t= ARRAY_SIZE(algs_sha3),\n\t},\n};\n\nstatic const struct stm32_hash_pdata stm32_hash_pdata_stm32mp13 = {\n\t.alg_shift\t= 17,\n\t.algs_info\t= stm32_hash_algs_info_stm32mp13,\n\t.algs_info_size\t= ARRAY_SIZE(stm32_hash_algs_info_stm32mp13),\n\t.has_sr\t\t= true,\n\t.has_mdmat\t= true,\n};\n\nstatic const struct of_device_id stm32_hash_of_match[] = {\n\t{ .compatible = \"stericsson,ux500-hash\", .data = &stm32_hash_pdata_ux500 },\n\t{ .compatible = \"st,stm32f456-hash\", .data = &stm32_hash_pdata_stm32f4 },\n\t{ .compatible = \"st,stm32f756-hash\", .data = &stm32_hash_pdata_stm32f7 },\n\t{ .compatible = \"st,stm32mp13-hash\", .data = &stm32_hash_pdata_stm32mp13 },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, stm32_hash_of_match);\n\nstatic int stm32_hash_get_of_match(struct stm32_hash_dev *hdev,\n\t\t\t\t   struct device *dev)\n{\n\thdev->pdata = of_device_get_match_data(dev);\n\tif (!hdev->pdata) {\n\t\tdev_err(dev, \"no compatible OF match\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_hash_probe(struct platform_device *pdev)\n{\n\tstruct stm32_hash_dev *hdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tint ret, irq;\n\n\thdev = devm_kzalloc(dev, sizeof(*hdev), GFP_KERNEL);\n\tif (!hdev)\n\t\treturn -ENOMEM;\n\n\thdev->io_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(hdev->io_base))\n\t\treturn PTR_ERR(hdev->io_base);\n\n\thdev->phys_base = res->start;\n\n\tret = stm32_hash_get_of_match(hdev, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq < 0 && irq != -ENXIO)\n\t\treturn irq;\n\n\tif (irq > 0) {\n\t\tret = devm_request_threaded_irq(dev, irq,\n\t\t\t\t\t\tstm32_hash_irq_handler,\n\t\t\t\t\t\tstm32_hash_irq_thread,\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(dev), hdev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Cannot grab IRQ\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tdev_info(dev, \"No IRQ, use polling mode\\n\");\n\t\thdev->polled = true;\n\t}\n\n\thdev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(hdev->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(hdev->clk),\n\t\t\t\t     \"failed to get clock for hash\\n\");\n\n\tret = clk_prepare_enable(hdev->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable hash clock (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(dev, HASH_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(dev);\n\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\thdev->rst = devm_reset_control_get(&pdev->dev, NULL);\n\tif (IS_ERR(hdev->rst)) {\n\t\tif (PTR_ERR(hdev->rst) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto err_reset;\n\t\t}\n\t} else {\n\t\treset_control_assert(hdev->rst);\n\t\tudelay(2);\n\t\treset_control_deassert(hdev->rst);\n\t}\n\n\thdev->dev = dev;\n\n\tplatform_set_drvdata(pdev, hdev);\n\n\tret = stm32_hash_dma_init(hdev);\n\tswitch (ret) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ENODEV:\n\t\tdev_info(dev, \"DMA mode not available\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"DMA init error %d\\n\", ret);\n\t\tgoto err_dma;\n\t}\n\n\tspin_lock(&stm32_hash.lock);\n\tlist_add_tail(&hdev->list, &stm32_hash.dev_list);\n\tspin_unlock(&stm32_hash.lock);\n\n\t \n\thdev->engine = crypto_engine_alloc_init(dev, 1);\n\tif (!hdev->engine) {\n\t\tret = -ENOMEM;\n\t\tgoto err_engine;\n\t}\n\n\tret = crypto_engine_start(hdev->engine);\n\tif (ret)\n\t\tgoto err_engine_start;\n\n\tif (hdev->pdata->ux500)\n\t\t \n\t\thdev->dma_mode = 0;\n\telse\n\t\thdev->dma_mode = stm32_hash_read(hdev, HASH_HWCFGR) & HASH_HWCFG_DMA_MASK;\n\n\t \n\tret = stm32_hash_register_algs(hdev);\n\tif (ret)\n\t\tgoto err_algs;\n\n\tdev_info(dev, \"Init HASH done HW ver %x DMA mode %u\\n\",\n\t\t stm32_hash_read(hdev, HASH_VER), hdev->dma_mode);\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n\nerr_algs:\nerr_engine_start:\n\tcrypto_engine_exit(hdev->engine);\nerr_engine:\n\tspin_lock(&stm32_hash.lock);\n\tlist_del(&hdev->list);\n\tspin_unlock(&stm32_hash.lock);\nerr_dma:\n\tif (hdev->dma_lch)\n\t\tdma_release_channel(hdev->dma_lch);\nerr_reset:\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\n\n\tclk_disable_unprepare(hdev->clk);\n\n\treturn ret;\n}\n\nstatic void stm32_hash_remove(struct platform_device *pdev)\n{\n\tstruct stm32_hash_dev *hdev = platform_get_drvdata(pdev);\n\tint ret;\n\n\tret = pm_runtime_get_sync(hdev->dev);\n\n\tstm32_hash_unregister_algs(hdev);\n\n\tcrypto_engine_exit(hdev->engine);\n\n\tspin_lock(&stm32_hash.lock);\n\tlist_del(&hdev->list);\n\tspin_unlock(&stm32_hash.lock);\n\n\tif (hdev->dma_lch)\n\t\tdma_release_channel(hdev->dma_lch);\n\n\tpm_runtime_disable(hdev->dev);\n\tpm_runtime_put_noidle(hdev->dev);\n\n\tif (ret >= 0)\n\t\tclk_disable_unprepare(hdev->clk);\n}\n\n#ifdef CONFIG_PM\nstatic int stm32_hash_runtime_suspend(struct device *dev)\n{\n\tstruct stm32_hash_dev *hdev = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(hdev->clk);\n\n\treturn 0;\n}\n\nstatic int stm32_hash_runtime_resume(struct device *dev)\n{\n\tstruct stm32_hash_dev *hdev = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(hdev->clk);\n\tif (ret) {\n\t\tdev_err(hdev->dev, \"Failed to prepare_enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops stm32_hash_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(stm32_hash_runtime_suspend,\n\t\t\t   stm32_hash_runtime_resume, NULL)\n};\n\nstatic struct platform_driver stm32_hash_driver = {\n\t.probe\t\t= stm32_hash_probe,\n\t.remove_new\t= stm32_hash_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"stm32-hash\",\n\t\t.pm = &stm32_hash_pm_ops,\n\t\t.of_match_table\t= stm32_hash_of_match,\n\t}\n};\n\nmodule_platform_driver(stm32_hash_driver);\n\nMODULE_DESCRIPTION(\"STM32 SHA1/SHA2/SHA3 & MD5 (HMAC) hw accelerator driver\");\nMODULE_AUTHOR(\"Lionel Debieve <lionel.debieve@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}