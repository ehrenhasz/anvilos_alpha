{
  "module_name": "stm32-cryp.c",
  "hash_id": "45c9aac6ffd80ab66b0fe483fc17c3001e9bfd6ddbbdc01cee2e34ca982327bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/stm32/stm32-cryp.c",
  "human_readable_source": "\n \n\n#include <crypto/aes.h>\n#include <crypto/engine.h>\n#include <crypto/internal/aead.h>\n#include <crypto/internal/des.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/iopoll.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/string.h>\n\n#define DRIVER_NAME             \"stm32-cryp\"\n\n \n#define FLG_ENCRYPT             BIT(0)\n \n#define FLG_AES                 BIT(1)\n#define FLG_DES                 BIT(2)\n#define FLG_TDES                BIT(3)\n#define FLG_ECB                 BIT(4)\n#define FLG_CBC                 BIT(5)\n#define FLG_CTR                 BIT(6)\n#define FLG_GCM                 BIT(7)\n#define FLG_CCM                 BIT(8)\n \n#define FLG_MODE_MASK           GENMASK(15, 0)\n \n\n \n#define CRYP_CR                 0x00000000\n#define CRYP_SR                 0x00000004\n#define CRYP_DIN                0x00000008\n#define CRYP_DOUT               0x0000000C\n#define CRYP_DMACR              0x00000010\n#define CRYP_IMSCR              0x00000014\n#define CRYP_RISR               0x00000018\n#define CRYP_MISR               0x0000001C\n#define CRYP_K0LR               0x00000020\n#define CRYP_K0RR               0x00000024\n#define CRYP_K1LR               0x00000028\n#define CRYP_K1RR               0x0000002C\n#define CRYP_K2LR               0x00000030\n#define CRYP_K2RR               0x00000034\n#define CRYP_K3LR               0x00000038\n#define CRYP_K3RR               0x0000003C\n#define CRYP_IV0LR              0x00000040\n#define CRYP_IV0RR              0x00000044\n#define CRYP_IV1LR              0x00000048\n#define CRYP_IV1RR              0x0000004C\n#define CRYP_CSGCMCCM0R         0x00000050\n#define CRYP_CSGCM0R            0x00000070\n\n#define UX500_CRYP_CR\t\t0x00000000\n#define UX500_CRYP_SR\t\t0x00000004\n#define UX500_CRYP_DIN\t\t0x00000008\n#define UX500_CRYP_DINSIZE\t0x0000000C\n#define UX500_CRYP_DOUT\t\t0x00000010\n#define UX500_CRYP_DOUSIZE\t0x00000014\n#define UX500_CRYP_DMACR\t0x00000018\n#define UX500_CRYP_IMSC\t\t0x0000001C\n#define UX500_CRYP_RIS\t\t0x00000020\n#define UX500_CRYP_MIS\t\t0x00000024\n#define UX500_CRYP_K1L\t\t0x00000028\n#define UX500_CRYP_K1R\t\t0x0000002C\n#define UX500_CRYP_K2L\t\t0x00000030\n#define UX500_CRYP_K2R\t\t0x00000034\n#define UX500_CRYP_K3L\t\t0x00000038\n#define UX500_CRYP_K3R\t\t0x0000003C\n#define UX500_CRYP_K4L\t\t0x00000040\n#define UX500_CRYP_K4R\t\t0x00000044\n#define UX500_CRYP_IV0L\t\t0x00000048\n#define UX500_CRYP_IV0R\t\t0x0000004C\n#define UX500_CRYP_IV1L\t\t0x00000050\n#define UX500_CRYP_IV1R\t\t0x00000054\n\n \n#define CR_DEC_NOT_ENC          0x00000004\n#define CR_TDES_ECB             0x00000000\n#define CR_TDES_CBC             0x00000008\n#define CR_DES_ECB              0x00000010\n#define CR_DES_CBC              0x00000018\n#define CR_AES_ECB              0x00000020\n#define CR_AES_CBC              0x00000028\n#define CR_AES_CTR              0x00000030\n#define CR_AES_KP               0x00000038  \n#define CR_AES_XTS              0x00000038  \n#define CR_AES_GCM              0x00080000\n#define CR_AES_CCM              0x00080008\n#define CR_AES_UNKNOWN          0xFFFFFFFF\n#define CR_ALGO_MASK            0x00080038\n#define CR_DATA32               0x00000000\n#define CR_DATA16               0x00000040\n#define CR_DATA8                0x00000080\n#define CR_DATA1                0x000000C0\n#define CR_KEY128               0x00000000\n#define CR_KEY192               0x00000100\n#define CR_KEY256               0x00000200\n#define CR_KEYRDEN              0x00000400  \n#define CR_KSE                  0x00000800  \n#define CR_FFLUSH               0x00004000\n#define CR_CRYPEN               0x00008000\n#define CR_PH_INIT              0x00000000\n#define CR_PH_HEADER            0x00010000\n#define CR_PH_PAYLOAD           0x00020000\n#define CR_PH_FINAL             0x00030000\n#define CR_PH_MASK              0x00030000\n#define CR_NBPBL_SHIFT          20\n\n#define SR_BUSY                 0x00000010\n#define SR_OFNE                 0x00000004\n\n#define IMSCR_IN                BIT(0)\n#define IMSCR_OUT               BIT(1)\n\n#define MISR_IN                 BIT(0)\n#define MISR_OUT                BIT(1)\n\n \n#define AES_BLOCK_32            (AES_BLOCK_SIZE / sizeof(u32))\n#define GCM_CTR_INIT            2\n#define CRYP_AUTOSUSPEND_DELAY\t50\n\nstruct stm32_cryp_caps {\n\tbool\t\t\taeads_support;\n\tbool\t\t\tlinear_aes_key;\n\tbool\t\t\tkp_mode;\n\tbool\t\t\tiv_protection;\n\tbool\t\t\tswap_final;\n\tbool\t\t\tpadding_wa;\n\tu32\t\t\tcr;\n\tu32\t\t\tsr;\n\tu32\t\t\tdin;\n\tu32\t\t\tdout;\n\tu32\t\t\timsc;\n\tu32\t\t\tmis;\n\tu32\t\t\tk1l;\n\tu32\t\t\tk1r;\n\tu32\t\t\tk3r;\n\tu32\t\t\tiv0l;\n\tu32\t\t\tiv0r;\n\tu32\t\t\tiv1l;\n\tu32\t\t\tiv1r;\n};\n\nstruct stm32_cryp_ctx {\n\tstruct stm32_cryp       *cryp;\n\tint                     keylen;\n\t__be32                  key[AES_KEYSIZE_256 / sizeof(u32)];\n\tunsigned long           flags;\n};\n\nstruct stm32_cryp_reqctx {\n\tunsigned long mode;\n};\n\nstruct stm32_cryp {\n\tstruct list_head        list;\n\tstruct device           *dev;\n\tvoid __iomem            *regs;\n\tstruct clk              *clk;\n\tunsigned long           flags;\n\tu32                     irq_status;\n\tconst struct stm32_cryp_caps *caps;\n\tstruct stm32_cryp_ctx   *ctx;\n\n\tstruct crypto_engine    *engine;\n\n\tstruct skcipher_request *req;\n\tstruct aead_request     *areq;\n\n\tsize_t                  authsize;\n\tsize_t                  hw_blocksize;\n\n\tsize_t                  payload_in;\n\tsize_t                  header_in;\n\tsize_t                  payload_out;\n\n\tstruct scatterlist      *out_sg;\n\n\tstruct scatter_walk     in_walk;\n\tstruct scatter_walk     out_walk;\n\n\t__be32                  last_ctr[4];\n\tu32                     gcm_ctr;\n};\n\nstruct stm32_cryp_list {\n\tstruct list_head        dev_list;\n\tspinlock_t              lock;  \n};\n\nstatic struct stm32_cryp_list cryp_list = {\n\t.dev_list = LIST_HEAD_INIT(cryp_list.dev_list),\n\t.lock     = __SPIN_LOCK_UNLOCKED(cryp_list.lock),\n};\n\nstatic inline bool is_aes(struct stm32_cryp *cryp)\n{\n\treturn cryp->flags & FLG_AES;\n}\n\nstatic inline bool is_des(struct stm32_cryp *cryp)\n{\n\treturn cryp->flags & FLG_DES;\n}\n\nstatic inline bool is_tdes(struct stm32_cryp *cryp)\n{\n\treturn cryp->flags & FLG_TDES;\n}\n\nstatic inline bool is_ecb(struct stm32_cryp *cryp)\n{\n\treturn cryp->flags & FLG_ECB;\n}\n\nstatic inline bool is_cbc(struct stm32_cryp *cryp)\n{\n\treturn cryp->flags & FLG_CBC;\n}\n\nstatic inline bool is_ctr(struct stm32_cryp *cryp)\n{\n\treturn cryp->flags & FLG_CTR;\n}\n\nstatic inline bool is_gcm(struct stm32_cryp *cryp)\n{\n\treturn cryp->flags & FLG_GCM;\n}\n\nstatic inline bool is_ccm(struct stm32_cryp *cryp)\n{\n\treturn cryp->flags & FLG_CCM;\n}\n\nstatic inline bool is_encrypt(struct stm32_cryp *cryp)\n{\n\treturn cryp->flags & FLG_ENCRYPT;\n}\n\nstatic inline bool is_decrypt(struct stm32_cryp *cryp)\n{\n\treturn !is_encrypt(cryp);\n}\n\nstatic inline u32 stm32_cryp_read(struct stm32_cryp *cryp, u32 ofst)\n{\n\treturn readl_relaxed(cryp->regs + ofst);\n}\n\nstatic inline void stm32_cryp_write(struct stm32_cryp *cryp, u32 ofst, u32 val)\n{\n\twritel_relaxed(val, cryp->regs + ofst);\n}\n\nstatic inline int stm32_cryp_wait_busy(struct stm32_cryp *cryp)\n{\n\tu32 status;\n\n\treturn readl_relaxed_poll_timeout(cryp->regs + cryp->caps->sr, status,\n\t\t\t!(status & SR_BUSY), 10, 100000);\n}\n\nstatic inline void stm32_cryp_enable(struct stm32_cryp *cryp)\n{\n\twritel_relaxed(readl_relaxed(cryp->regs + cryp->caps->cr) | CR_CRYPEN,\n\t\t       cryp->regs + cryp->caps->cr);\n}\n\nstatic inline int stm32_cryp_wait_enable(struct stm32_cryp *cryp)\n{\n\tu32 status;\n\n\treturn readl_relaxed_poll_timeout(cryp->regs + cryp->caps->cr, status,\n\t\t\t!(status & CR_CRYPEN), 10, 100000);\n}\n\nstatic inline int stm32_cryp_wait_output(struct stm32_cryp *cryp)\n{\n\tu32 status;\n\n\treturn readl_relaxed_poll_timeout(cryp->regs + cryp->caps->sr, status,\n\t\t\tstatus & SR_OFNE, 10, 100000);\n}\n\nstatic inline void stm32_cryp_key_read_enable(struct stm32_cryp *cryp)\n{\n\twritel_relaxed(readl_relaxed(cryp->regs + cryp->caps->cr) | CR_KEYRDEN,\n\t\t       cryp->regs + cryp->caps->cr);\n}\n\nstatic inline void stm32_cryp_key_read_disable(struct stm32_cryp *cryp)\n{\n\twritel_relaxed(readl_relaxed(cryp->regs + cryp->caps->cr) & ~CR_KEYRDEN,\n\t\t       cryp->regs + cryp->caps->cr);\n}\n\nstatic int stm32_cryp_read_auth_tag(struct stm32_cryp *cryp);\nstatic void stm32_cryp_finish_req(struct stm32_cryp *cryp, int err);\n\nstatic struct stm32_cryp *stm32_cryp_find_dev(struct stm32_cryp_ctx *ctx)\n{\n\tstruct stm32_cryp *tmp, *cryp = NULL;\n\n\tspin_lock_bh(&cryp_list.lock);\n\tif (!ctx->cryp) {\n\t\tlist_for_each_entry(tmp, &cryp_list.dev_list, list) {\n\t\t\tcryp = tmp;\n\t\t\tbreak;\n\t\t}\n\t\tctx->cryp = cryp;\n\t} else {\n\t\tcryp = ctx->cryp;\n\t}\n\n\tspin_unlock_bh(&cryp_list.lock);\n\n\treturn cryp;\n}\n\nstatic void stm32_cryp_hw_write_iv(struct stm32_cryp *cryp, __be32 *iv)\n{\n\tif (!iv)\n\t\treturn;\n\n\tstm32_cryp_write(cryp, cryp->caps->iv0l, be32_to_cpu(*iv++));\n\tstm32_cryp_write(cryp, cryp->caps->iv0r, be32_to_cpu(*iv++));\n\n\tif (is_aes(cryp)) {\n\t\tstm32_cryp_write(cryp, cryp->caps->iv1l, be32_to_cpu(*iv++));\n\t\tstm32_cryp_write(cryp, cryp->caps->iv1r, be32_to_cpu(*iv++));\n\t}\n}\n\nstatic void stm32_cryp_get_iv(struct stm32_cryp *cryp)\n{\n\tstruct skcipher_request *req = cryp->req;\n\t__be32 *tmp = (void *)req->iv;\n\n\tif (!tmp)\n\t\treturn;\n\n\tif (cryp->caps->iv_protection)\n\t\tstm32_cryp_key_read_enable(cryp);\n\n\t*tmp++ = cpu_to_be32(stm32_cryp_read(cryp, cryp->caps->iv0l));\n\t*tmp++ = cpu_to_be32(stm32_cryp_read(cryp, cryp->caps->iv0r));\n\n\tif (is_aes(cryp)) {\n\t\t*tmp++ = cpu_to_be32(stm32_cryp_read(cryp, cryp->caps->iv1l));\n\t\t*tmp++ = cpu_to_be32(stm32_cryp_read(cryp, cryp->caps->iv1r));\n\t}\n\n\tif (cryp->caps->iv_protection)\n\t\tstm32_cryp_key_read_disable(cryp);\n}\n\n \nstatic inline u8 ux500_swap_bits_in_byte(u8 b)\n{\n#define R_SHIFT_4_MASK  0xc0  \n#define R_SHIFT_2_MASK  0x28  \n#define R_SHIFT_1_MASK  0x1e  \n#define L_SHIFT_4_MASK  0x03  \n#define L_SHIFT_2_MASK  0x14  \n#define L_SHIFT_1_MASK  0x78  \n\n\tu8 n1;\n\tu8 n2;\n\n\t \n\t \n\tn1 = ((b  & R_SHIFT_4_MASK) >> 4) | (b  & ~(R_SHIFT_4_MASK >> 4));\n\t \n\tn1 = ((n1 & R_SHIFT_2_MASK) >> 2) | (n1 & ~(R_SHIFT_2_MASK >> 2));\n\t \n\tn1 = (n1  & R_SHIFT_1_MASK) >> 1;\n\n\t \n\t \n\tn2 = ((b  & L_SHIFT_4_MASK) << 4) | (b  & ~(L_SHIFT_4_MASK << 4));\n\t \n\tn2 = ((n2 & L_SHIFT_2_MASK) << 2) | (n2 & ~(L_SHIFT_2_MASK << 2));\n\t \n\tn2 = (n2  & L_SHIFT_1_MASK) << 1;\n\n\treturn n1 | n2;\n}\n\n \nstatic inline void ux500_swizzle_key(const u8 *in, u8 *out, u32 len)\n{\n\tint i = 0;\n\tint bpw = sizeof(u32);\n\tint j;\n\tint index = 0;\n\n\tj = len - bpw;\n\twhile (j >= 0) {\n\t\tfor (i = 0; i < bpw; i++) {\n\t\t\tindex = len - j - bpw + i;\n\t\t\tout[j + i] =\n\t\t\t\tux500_swap_bits_in_byte(in[index]);\n\t\t}\n\t\tj -= bpw;\n\t}\n}\n\nstatic void stm32_cryp_hw_write_key(struct stm32_cryp *c)\n{\n\tunsigned int i;\n\tint r_id;\n\n\tif (is_des(c)) {\n\t\tstm32_cryp_write(c, c->caps->k1l, be32_to_cpu(c->ctx->key[0]));\n\t\tstm32_cryp_write(c, c->caps->k1r, be32_to_cpu(c->ctx->key[1]));\n\t\treturn;\n\t}\n\n\t \n\tif (is_aes(c) && c->caps->linear_aes_key) {\n\t\tu32 tmpkey[8];\n\n\t\tux500_swizzle_key((u8 *)c->ctx->key,\n\t\t\t\t  (u8 *)tmpkey, c->ctx->keylen);\n\n\t\tr_id = c->caps->k1l;\n\t\tfor (i = 0; i < c->ctx->keylen / sizeof(u32); i++, r_id += 4)\n\t\t\tstm32_cryp_write(c, r_id, tmpkey[i]);\n\n\t\treturn;\n\t}\n\n\tr_id = c->caps->k3r;\n\tfor (i = c->ctx->keylen / sizeof(u32); i > 0; i--, r_id -= 4)\n\t\tstm32_cryp_write(c, r_id, be32_to_cpu(c->ctx->key[i - 1]));\n}\n\nstatic u32 stm32_cryp_get_hw_mode(struct stm32_cryp *cryp)\n{\n\tif (is_aes(cryp) && is_ecb(cryp))\n\t\treturn CR_AES_ECB;\n\n\tif (is_aes(cryp) && is_cbc(cryp))\n\t\treturn CR_AES_CBC;\n\n\tif (is_aes(cryp) && is_ctr(cryp))\n\t\treturn CR_AES_CTR;\n\n\tif (is_aes(cryp) && is_gcm(cryp))\n\t\treturn CR_AES_GCM;\n\n\tif (is_aes(cryp) && is_ccm(cryp))\n\t\treturn CR_AES_CCM;\n\n\tif (is_des(cryp) && is_ecb(cryp))\n\t\treturn CR_DES_ECB;\n\n\tif (is_des(cryp) && is_cbc(cryp))\n\t\treturn CR_DES_CBC;\n\n\tif (is_tdes(cryp) && is_ecb(cryp))\n\t\treturn CR_TDES_ECB;\n\n\tif (is_tdes(cryp) && is_cbc(cryp))\n\t\treturn CR_TDES_CBC;\n\n\tdev_err(cryp->dev, \"Unknown mode\\n\");\n\treturn CR_AES_UNKNOWN;\n}\n\nstatic unsigned int stm32_cryp_get_input_text_len(struct stm32_cryp *cryp)\n{\n\treturn is_encrypt(cryp) ? cryp->areq->cryptlen :\n\t\t\t\t  cryp->areq->cryptlen - cryp->authsize;\n}\n\nstatic int stm32_cryp_gcm_init(struct stm32_cryp *cryp, u32 cfg)\n{\n\tint ret;\n\t__be32 iv[4];\n\n\t \n\tmemcpy(iv, cryp->areq->iv, 12);\n\tiv[3] = cpu_to_be32(GCM_CTR_INIT);\n\tcryp->gcm_ctr = GCM_CTR_INIT;\n\tstm32_cryp_hw_write_iv(cryp, iv);\n\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg | CR_PH_INIT | CR_CRYPEN);\n\n\t \n\tret = stm32_cryp_wait_enable(cryp);\n\tif (ret) {\n\t\tdev_err(cryp->dev, \"Timeout (gcm init)\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (cryp->areq->assoclen) {\n\t\tcfg |= CR_PH_HEADER;\n\t\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\t} else if (stm32_cryp_get_input_text_len(cryp)) {\n\t\tcfg |= CR_PH_PAYLOAD;\n\t\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\t}\n\n\treturn 0;\n}\n\nstatic void stm32_crypt_gcmccm_end_header(struct stm32_cryp *cryp)\n{\n\tu32 cfg;\n\tint err;\n\n\t \n\tif (!cryp->header_in) {\n\t\t \n\t\terr = stm32_cryp_wait_busy(cryp);\n\t\tif (err) {\n\t\t\tdev_err(cryp->dev, \"Timeout (gcm/ccm header)\\n\");\n\t\t\tstm32_cryp_write(cryp, cryp->caps->imsc, 0);\n\t\t\tstm32_cryp_finish_req(cryp, err);\n\t\t\treturn;\n\t\t}\n\n\t\tif (stm32_cryp_get_input_text_len(cryp)) {\n\t\t\t \n\t\t\tcfg = stm32_cryp_read(cryp, cryp->caps->cr);\n\t\t\tcfg &= ~CR_CRYPEN;\n\t\t\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\t\t\tcfg &= ~CR_PH_MASK;\n\t\t\tcfg |= CR_PH_PAYLOAD | CR_CRYPEN;\n\t\t\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\t\t} else {\n\t\t\t \n\t\t}\n\t}\n}\n\nstatic void stm32_cryp_write_ccm_first_header(struct stm32_cryp *cryp)\n{\n\tsize_t written;\n\tsize_t len;\n\tu32 alen = cryp->areq->assoclen;\n\tu32 block[AES_BLOCK_32] = {0};\n\tu8 *b8 = (u8 *)block;\n\n\tif (alen <= 65280) {\n\t\t \n\t\tb8[0] = (alen >> 8) & 0xFF;\n\t\tb8[1] = alen & 0xFF;\n\t\tlen = 2;\n\t} else {\n\t\t \n\t\tb8[0] = 0xFF;\n\t\tb8[1] = 0xFE;\n\t\tb8[2] = (alen & 0xFF000000) >> 24;\n\t\tb8[3] = (alen & 0x00FF0000) >> 16;\n\t\tb8[4] = (alen & 0x0000FF00) >> 8;\n\t\tb8[5] = alen & 0x000000FF;\n\t\tlen = 6;\n\t}\n\n\twritten = min_t(size_t, AES_BLOCK_SIZE - len, alen);\n\n\tscatterwalk_copychunks((char *)block + len, &cryp->in_walk, written, 0);\n\n\twritesl(cryp->regs + cryp->caps->din, block, AES_BLOCK_32);\n\n\tcryp->header_in -= written;\n\n\tstm32_crypt_gcmccm_end_header(cryp);\n}\n\nstatic int stm32_cryp_ccm_init(struct stm32_cryp *cryp, u32 cfg)\n{\n\tint ret;\n\tu32 iv_32[AES_BLOCK_32], b0_32[AES_BLOCK_32];\n\tu8 *iv = (u8 *)iv_32, *b0 = (u8 *)b0_32;\n\t__be32 *bd;\n\tu32 *d;\n\tunsigned int i, textlen;\n\n\t \n\tmemcpy(iv, cryp->areq->iv, AES_BLOCK_SIZE);\n\tmemset(iv + AES_BLOCK_SIZE - 1 - iv[0], 0, iv[0] + 1);\n\tiv[AES_BLOCK_SIZE - 1] = 1;\n\tstm32_cryp_hw_write_iv(cryp, (__be32 *)iv);\n\n\t \n\tmemcpy(b0, iv, AES_BLOCK_SIZE);\n\n\tb0[0] |= (8 * ((cryp->authsize - 2) / 2));\n\n\tif (cryp->areq->assoclen)\n\t\tb0[0] |= 0x40;\n\n\ttextlen = stm32_cryp_get_input_text_len(cryp);\n\n\tb0[AES_BLOCK_SIZE - 2] = textlen >> 8;\n\tb0[AES_BLOCK_SIZE - 1] = textlen & 0xFF;\n\n\t \n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg | CR_PH_INIT | CR_CRYPEN);\n\n\t \n\td = (u32 *)b0;\n\tbd = (__be32 *)b0;\n\n\tfor (i = 0; i < AES_BLOCK_32; i++) {\n\t\tu32 xd = d[i];\n\n\t\tif (!cryp->caps->padding_wa)\n\t\t\txd = be32_to_cpu(bd[i]);\n\t\tstm32_cryp_write(cryp, cryp->caps->din, xd);\n\t}\n\n\t \n\tret = stm32_cryp_wait_enable(cryp);\n\tif (ret) {\n\t\tdev_err(cryp->dev, \"Timeout (ccm init)\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (cryp->areq->assoclen) {\n\t\tcfg |= CR_PH_HEADER | CR_CRYPEN;\n\t\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\t\t \n\t\tstm32_cryp_write_ccm_first_header(cryp);\n\t} else if (stm32_cryp_get_input_text_len(cryp)) {\n\t\tcfg |= CR_PH_PAYLOAD;\n\t\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_cryp_hw_init(struct stm32_cryp *cryp)\n{\n\tint ret;\n\tu32 cfg, hw_mode;\n\n\tpm_runtime_get_sync(cryp->dev);\n\n\t \n\tstm32_cryp_write(cryp, cryp->caps->imsc, 0);\n\n\t \n\tcfg = CR_DATA8 | CR_FFLUSH;\n\n\tswitch (cryp->ctx->keylen) {\n\tcase AES_KEYSIZE_128:\n\t\tcfg |= CR_KEY128;\n\t\tbreak;\n\n\tcase AES_KEYSIZE_192:\n\t\tcfg |= CR_KEY192;\n\t\tbreak;\n\n\tdefault:\n\tcase AES_KEYSIZE_256:\n\t\tcfg |= CR_KEY256;\n\t\tbreak;\n\t}\n\n\thw_mode = stm32_cryp_get_hw_mode(cryp);\n\tif (hw_mode == CR_AES_UNKNOWN)\n\t\treturn -EINVAL;\n\n\t \n\tif (is_decrypt(cryp) &&\n\t    ((hw_mode == CR_AES_ECB) || (hw_mode == CR_AES_CBC))) {\n\t\t \n\t\tif (cryp->caps->kp_mode)\n\t\t\tstm32_cryp_write(cryp, cryp->caps->cr,\n\t\t\t\tcfg | CR_AES_KP);\n\t\telse\n\t\t\tstm32_cryp_write(cryp,\n\t\t\t\tcryp->caps->cr, cfg | CR_AES_ECB | CR_KSE);\n\n\t\t \n\t\tstm32_cryp_hw_write_key(cryp);\n\n\t\t \n\t\tstm32_cryp_enable(cryp);\n\t\t \n\t\tret = stm32_cryp_wait_busy(cryp);\n\t\tif (ret) {\n\t\t\tdev_err(cryp->dev, \"Timeout (key preparation)\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tcfg |= hw_mode | CR_DEC_NOT_ENC;\n\n\t\t \n\t\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\t} else {\n\t\tcfg |= hw_mode;\n\t\tif (is_decrypt(cryp))\n\t\t\tcfg |= CR_DEC_NOT_ENC;\n\n\t\t \n\t\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\t\t \n\t\tstm32_cryp_hw_write_key(cryp);\n\t}\n\n\tswitch (hw_mode) {\n\tcase CR_AES_GCM:\n\tcase CR_AES_CCM:\n\t\t \n\t\tif (hw_mode == CR_AES_CCM)\n\t\t\tret = stm32_cryp_ccm_init(cryp, cfg);\n\t\telse\n\t\t\tret = stm32_cryp_gcm_init(cryp, cfg);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbreak;\n\n\tcase CR_DES_CBC:\n\tcase CR_TDES_CBC:\n\tcase CR_AES_CBC:\n\tcase CR_AES_CTR:\n\t\tstm32_cryp_hw_write_iv(cryp, (__be32 *)cryp->req->iv);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tstm32_cryp_enable(cryp);\n\n\treturn 0;\n}\n\nstatic void stm32_cryp_finish_req(struct stm32_cryp *cryp, int err)\n{\n\tif (!err && (is_gcm(cryp) || is_ccm(cryp)))\n\t\t \n\t\terr = stm32_cryp_read_auth_tag(cryp);\n\n\tif (!err && (!(is_gcm(cryp) || is_ccm(cryp) || is_ecb(cryp))))\n\t\tstm32_cryp_get_iv(cryp);\n\n\tpm_runtime_mark_last_busy(cryp->dev);\n\tpm_runtime_put_autosuspend(cryp->dev);\n\n\tif (is_gcm(cryp) || is_ccm(cryp))\n\t\tcrypto_finalize_aead_request(cryp->engine, cryp->areq, err);\n\telse\n\t\tcrypto_finalize_skcipher_request(cryp->engine, cryp->req,\n\t\t\t\t\t\t   err);\n}\n\nstatic int stm32_cryp_cpu_start(struct stm32_cryp *cryp)\n{\n\t \n\tstm32_cryp_write(cryp, cryp->caps->imsc, IMSCR_IN | IMSCR_OUT);\n\n\treturn 0;\n}\n\nstatic int stm32_cryp_cipher_one_req(struct crypto_engine *engine, void *areq);\n\nstatic int stm32_cryp_init_tfm(struct crypto_skcipher *tfm)\n{\n\tcrypto_skcipher_set_reqsize(tfm, sizeof(struct stm32_cryp_reqctx));\n\n\treturn 0;\n}\n\nstatic int stm32_cryp_aead_one_req(struct crypto_engine *engine, void *areq);\n\nstatic int stm32_cryp_aes_aead_init(struct crypto_aead *tfm)\n{\n\ttfm->reqsize = sizeof(struct stm32_cryp_reqctx);\n\n\treturn 0;\n}\n\nstatic int stm32_cryp_crypt(struct skcipher_request *req, unsigned long mode)\n{\n\tstruct stm32_cryp_ctx *ctx = crypto_skcipher_ctx(\n\t\t\tcrypto_skcipher_reqtfm(req));\n\tstruct stm32_cryp_reqctx *rctx = skcipher_request_ctx(req);\n\tstruct stm32_cryp *cryp = stm32_cryp_find_dev(ctx);\n\n\tif (!cryp)\n\t\treturn -ENODEV;\n\n\trctx->mode = mode;\n\n\treturn crypto_transfer_skcipher_request_to_engine(cryp->engine, req);\n}\n\nstatic int stm32_cryp_aead_crypt(struct aead_request *req, unsigned long mode)\n{\n\tstruct stm32_cryp_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct stm32_cryp_reqctx *rctx = aead_request_ctx(req);\n\tstruct stm32_cryp *cryp = stm32_cryp_find_dev(ctx);\n\n\tif (!cryp)\n\t\treturn -ENODEV;\n\n\trctx->mode = mode;\n\n\treturn crypto_transfer_aead_request_to_engine(cryp->engine, req);\n}\n\nstatic int stm32_cryp_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t     unsigned int keylen)\n{\n\tstruct stm32_cryp_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\tmemcpy(ctx->key, key, keylen);\n\tctx->keylen = keylen;\n\n\treturn 0;\n}\n\nstatic int stm32_cryp_aes_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\tif (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&\n\t    keylen != AES_KEYSIZE_256)\n\t\treturn -EINVAL;\n\telse\n\t\treturn stm32_cryp_setkey(tfm, key, keylen);\n}\n\nstatic int stm32_cryp_des_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\treturn verify_skcipher_des_key(tfm, key) ?:\n\t       stm32_cryp_setkey(tfm, key, keylen);\n}\n\nstatic int stm32_cryp_tdes_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t\t  unsigned int keylen)\n{\n\treturn verify_skcipher_des3_key(tfm, key) ?:\n\t       stm32_cryp_setkey(tfm, key, keylen);\n}\n\nstatic int stm32_cryp_aes_aead_setkey(struct crypto_aead *tfm, const u8 *key,\n\t\t\t\t      unsigned int keylen)\n{\n\tstruct stm32_cryp_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tif (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&\n\t    keylen != AES_KEYSIZE_256)\n\t\treturn -EINVAL;\n\n\tmemcpy(ctx->key, key, keylen);\n\tctx->keylen = keylen;\n\n\treturn 0;\n}\n\nstatic int stm32_cryp_aes_gcm_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t\t  unsigned int authsize)\n{\n\tswitch (authsize) {\n\tcase 4:\n\tcase 8:\n\tcase 12:\n\tcase 13:\n\tcase 14:\n\tcase 15:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_cryp_aes_ccm_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t\t  unsigned int authsize)\n{\n\tswitch (authsize) {\n\tcase 4:\n\tcase 6:\n\tcase 8:\n\tcase 10:\n\tcase 12:\n\tcase 14:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_cryp_aes_ecb_encrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen % AES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_AES | FLG_ECB | FLG_ENCRYPT);\n}\n\nstatic int stm32_cryp_aes_ecb_decrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen % AES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_AES | FLG_ECB);\n}\n\nstatic int stm32_cryp_aes_cbc_encrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen % AES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_AES | FLG_CBC | FLG_ENCRYPT);\n}\n\nstatic int stm32_cryp_aes_cbc_decrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen % AES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_AES | FLG_CBC);\n}\n\nstatic int stm32_cryp_aes_ctr_encrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_AES | FLG_CTR | FLG_ENCRYPT);\n}\n\nstatic int stm32_cryp_aes_ctr_decrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_AES | FLG_CTR);\n}\n\nstatic int stm32_cryp_aes_gcm_encrypt(struct aead_request *req)\n{\n\treturn stm32_cryp_aead_crypt(req, FLG_AES | FLG_GCM | FLG_ENCRYPT);\n}\n\nstatic int stm32_cryp_aes_gcm_decrypt(struct aead_request *req)\n{\n\treturn stm32_cryp_aead_crypt(req, FLG_AES | FLG_GCM);\n}\n\nstatic inline int crypto_ccm_check_iv(const u8 *iv)\n{\n\t \n\tif (iv[0] < 1 || iv[0] > 7)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int stm32_cryp_aes_ccm_encrypt(struct aead_request *req)\n{\n\tint err;\n\n\terr = crypto_ccm_check_iv(req->iv);\n\tif (err)\n\t\treturn err;\n\n\treturn stm32_cryp_aead_crypt(req, FLG_AES | FLG_CCM | FLG_ENCRYPT);\n}\n\nstatic int stm32_cryp_aes_ccm_decrypt(struct aead_request *req)\n{\n\tint err;\n\n\terr = crypto_ccm_check_iv(req->iv);\n\tif (err)\n\t\treturn err;\n\n\treturn stm32_cryp_aead_crypt(req, FLG_AES | FLG_CCM);\n}\n\nstatic int stm32_cryp_des_ecb_encrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen % DES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_DES | FLG_ECB | FLG_ENCRYPT);\n}\n\nstatic int stm32_cryp_des_ecb_decrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen % DES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_DES | FLG_ECB);\n}\n\nstatic int stm32_cryp_des_cbc_encrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen % DES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_DES | FLG_CBC | FLG_ENCRYPT);\n}\n\nstatic int stm32_cryp_des_cbc_decrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen % DES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_DES | FLG_CBC);\n}\n\nstatic int stm32_cryp_tdes_ecb_encrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen % DES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_TDES | FLG_ECB | FLG_ENCRYPT);\n}\n\nstatic int stm32_cryp_tdes_ecb_decrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen % DES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_TDES | FLG_ECB);\n}\n\nstatic int stm32_cryp_tdes_cbc_encrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen % DES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_TDES | FLG_CBC | FLG_ENCRYPT);\n}\n\nstatic int stm32_cryp_tdes_cbc_decrypt(struct skcipher_request *req)\n{\n\tif (req->cryptlen % DES_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (req->cryptlen == 0)\n\t\treturn 0;\n\n\treturn stm32_cryp_crypt(req, FLG_TDES | FLG_CBC);\n}\n\nstatic int stm32_cryp_prepare_req(struct skcipher_request *req,\n\t\t\t\t  struct aead_request *areq)\n{\n\tstruct stm32_cryp_ctx *ctx;\n\tstruct stm32_cryp *cryp;\n\tstruct stm32_cryp_reqctx *rctx;\n\tstruct scatterlist *in_sg;\n\tint ret;\n\n\tif (!req && !areq)\n\t\treturn -EINVAL;\n\n\tctx = req ? crypto_skcipher_ctx(crypto_skcipher_reqtfm(req)) :\n\t\t    crypto_aead_ctx(crypto_aead_reqtfm(areq));\n\n\tcryp = ctx->cryp;\n\n\trctx = req ? skcipher_request_ctx(req) : aead_request_ctx(areq);\n\trctx->mode &= FLG_MODE_MASK;\n\n\tctx->cryp = cryp;\n\n\tcryp->flags = (cryp->flags & ~FLG_MODE_MASK) | rctx->mode;\n\tcryp->hw_blocksize = is_aes(cryp) ? AES_BLOCK_SIZE : DES_BLOCK_SIZE;\n\tcryp->ctx = ctx;\n\n\tif (req) {\n\t\tcryp->req = req;\n\t\tcryp->areq = NULL;\n\t\tcryp->header_in = 0;\n\t\tcryp->payload_in = req->cryptlen;\n\t\tcryp->payload_out = req->cryptlen;\n\t\tcryp->authsize = 0;\n\t} else {\n\t\t \n\t\tcryp->areq = areq;\n\t\tcryp->req = NULL;\n\t\tcryp->authsize = crypto_aead_authsize(crypto_aead_reqtfm(areq));\n\t\tif (is_encrypt(cryp)) {\n\t\t\tcryp->payload_in = areq->cryptlen;\n\t\t\tcryp->header_in = areq->assoclen;\n\t\t\tcryp->payload_out = areq->cryptlen;\n\t\t} else {\n\t\t\tcryp->payload_in = areq->cryptlen - cryp->authsize;\n\t\t\tcryp->header_in = areq->assoclen;\n\t\t\tcryp->payload_out = cryp->payload_in;\n\t\t}\n\t}\n\n\tin_sg = req ? req->src : areq->src;\n\tscatterwalk_start(&cryp->in_walk, in_sg);\n\n\tcryp->out_sg = req ? req->dst : areq->dst;\n\tscatterwalk_start(&cryp->out_walk, cryp->out_sg);\n\n\tif (is_gcm(cryp) || is_ccm(cryp)) {\n\t\t \n\t\tscatterwalk_copychunks(NULL, &cryp->out_walk, cryp->areq->assoclen, 2);\n\t}\n\n\tif (is_ctr(cryp))\n\t\tmemset(cryp->last_ctr, 0, sizeof(cryp->last_ctr));\n\n\tret = stm32_cryp_hw_init(cryp);\n\treturn ret;\n}\n\nstatic int stm32_cryp_cipher_one_req(struct crypto_engine *engine, void *areq)\n{\n\tstruct skcipher_request *req = container_of(areq,\n\t\t\t\t\t\t      struct skcipher_request,\n\t\t\t\t\t\t      base);\n\tstruct stm32_cryp_ctx *ctx = crypto_skcipher_ctx(\n\t\t\tcrypto_skcipher_reqtfm(req));\n\tstruct stm32_cryp *cryp = ctx->cryp;\n\n\tif (!cryp)\n\t\treturn -ENODEV;\n\n\treturn stm32_cryp_prepare_req(req, NULL) ?:\n\t       stm32_cryp_cpu_start(cryp);\n}\n\nstatic int stm32_cryp_aead_one_req(struct crypto_engine *engine, void *areq)\n{\n\tstruct aead_request *req = container_of(areq, struct aead_request,\n\t\t\t\t\t\tbase);\n\tstruct stm32_cryp_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));\n\tstruct stm32_cryp *cryp = ctx->cryp;\n\tint err;\n\n\tif (!cryp)\n\t\treturn -ENODEV;\n\n\terr = stm32_cryp_prepare_req(NULL, req);\n\tif (err)\n\t\treturn err;\n\n\tif (unlikely(!cryp->payload_in && !cryp->header_in)) {\n\t\t \n\t\tstm32_cryp_finish_req(cryp, 0);\n\t\treturn 0;\n\t}\n\n\treturn stm32_cryp_cpu_start(cryp);\n}\n\nstatic int stm32_cryp_read_auth_tag(struct stm32_cryp *cryp)\n{\n\tu32 cfg, size_bit;\n\tunsigned int i;\n\tint ret = 0;\n\n\t \n\tcfg = stm32_cryp_read(cryp, cryp->caps->cr);\n\n\tcfg &= ~CR_PH_MASK;\n\tcfg |= CR_PH_FINAL;\n\tcfg &= ~CR_DEC_NOT_ENC;\n\tcfg |= CR_CRYPEN;\n\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\tif (is_gcm(cryp)) {\n\t\t \n\t\tsize_bit = cryp->areq->assoclen * 8;\n\t\tif (cryp->caps->swap_final)\n\t\t\tsize_bit = (__force u32)cpu_to_be32(size_bit);\n\n\t\tstm32_cryp_write(cryp, cryp->caps->din, 0);\n\t\tstm32_cryp_write(cryp, cryp->caps->din, size_bit);\n\n\t\tsize_bit = is_encrypt(cryp) ? cryp->areq->cryptlen :\n\t\t\t\tcryp->areq->cryptlen - cryp->authsize;\n\t\tsize_bit *= 8;\n\t\tif (cryp->caps->swap_final)\n\t\t\tsize_bit = (__force u32)cpu_to_be32(size_bit);\n\n\t\tstm32_cryp_write(cryp, cryp->caps->din, 0);\n\t\tstm32_cryp_write(cryp, cryp->caps->din, size_bit);\n\t} else {\n\t\t \n\t\tu32 iv32[AES_BLOCK_32];\n\t\tu8 *iv = (u8 *)iv32;\n\t\t__be32 *biv = (__be32 *)iv32;\n\n\t\tmemcpy(iv, cryp->areq->iv, AES_BLOCK_SIZE);\n\t\tmemset(iv + AES_BLOCK_SIZE - 1 - iv[0], 0, iv[0] + 1);\n\n\t\tfor (i = 0; i < AES_BLOCK_32; i++) {\n\t\t\tu32 xiv = iv32[i];\n\n\t\t\tif (!cryp->caps->padding_wa)\n\t\t\t\txiv = be32_to_cpu(biv[i]);\n\t\t\tstm32_cryp_write(cryp, cryp->caps->din, xiv);\n\t\t}\n\t}\n\n\t \n\tret = stm32_cryp_wait_output(cryp);\n\tif (ret) {\n\t\tdev_err(cryp->dev, \"Timeout (read tag)\\n\");\n\t\treturn ret;\n\t}\n\n\tif (is_encrypt(cryp)) {\n\t\tu32 out_tag[AES_BLOCK_32];\n\n\t\t \n\t\treadsl(cryp->regs + cryp->caps->dout, out_tag, AES_BLOCK_32);\n\t\tscatterwalk_copychunks(out_tag, &cryp->out_walk, cryp->authsize, 1);\n\t} else {\n\t\t \n\t\tu32 in_tag[AES_BLOCK_32], out_tag[AES_BLOCK_32];\n\n\t\tscatterwalk_copychunks(in_tag, &cryp->in_walk, cryp->authsize, 0);\n\t\treadsl(cryp->regs + cryp->caps->dout, out_tag, AES_BLOCK_32);\n\n\t\tif (crypto_memneq(in_tag, out_tag, cryp->authsize))\n\t\t\tret = -EBADMSG;\n\t}\n\n\t \n\tcfg &= ~CR_CRYPEN;\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\treturn ret;\n}\n\nstatic void stm32_cryp_check_ctr_counter(struct stm32_cryp *cryp)\n{\n\tu32 cr;\n\n\tif (unlikely(cryp->last_ctr[3] == cpu_to_be32(0xFFFFFFFF))) {\n\t\t \n\t\tcrypto_inc((u8 *)cryp->last_ctr, sizeof(cryp->last_ctr));\n\n\t\tcr = stm32_cryp_read(cryp, cryp->caps->cr);\n\t\tstm32_cryp_write(cryp, cryp->caps->cr, cr & ~CR_CRYPEN);\n\n\t\tstm32_cryp_hw_write_iv(cryp, cryp->last_ctr);\n\n\t\tstm32_cryp_write(cryp, cryp->caps->cr, cr);\n\t}\n\n\t \n\tcryp->last_ctr[0] = cpu_to_be32(stm32_cryp_read(cryp, cryp->caps->iv0l));\n\tcryp->last_ctr[1] = cpu_to_be32(stm32_cryp_read(cryp, cryp->caps->iv0r));\n\tcryp->last_ctr[2] = cpu_to_be32(stm32_cryp_read(cryp, cryp->caps->iv1l));\n\tcryp->last_ctr[3] = cpu_to_be32(stm32_cryp_read(cryp, cryp->caps->iv1r));\n}\n\nstatic void stm32_cryp_irq_read_data(struct stm32_cryp *cryp)\n{\n\tu32 block[AES_BLOCK_32];\n\n\treadsl(cryp->regs + cryp->caps->dout, block, cryp->hw_blocksize / sizeof(u32));\n\tscatterwalk_copychunks(block, &cryp->out_walk, min_t(size_t, cryp->hw_blocksize,\n\t\t\t\t\t\t\t     cryp->payload_out), 1);\n\tcryp->payload_out -= min_t(size_t, cryp->hw_blocksize,\n\t\t\t\t   cryp->payload_out);\n}\n\nstatic void stm32_cryp_irq_write_block(struct stm32_cryp *cryp)\n{\n\tu32 block[AES_BLOCK_32] = {0};\n\n\tscatterwalk_copychunks(block, &cryp->in_walk, min_t(size_t, cryp->hw_blocksize,\n\t\t\t\t\t\t\t    cryp->payload_in), 0);\n\twritesl(cryp->regs + cryp->caps->din, block, cryp->hw_blocksize / sizeof(u32));\n\tcryp->payload_in -= min_t(size_t, cryp->hw_blocksize, cryp->payload_in);\n}\n\nstatic void stm32_cryp_irq_write_gcm_padded_data(struct stm32_cryp *cryp)\n{\n\tint err;\n\tu32 cfg, block[AES_BLOCK_32] = {0};\n\tunsigned int i;\n\n\t \n\n\t \n\tstm32_cryp_write(cryp, cryp->caps->imsc, 0);\n\tcfg = stm32_cryp_read(cryp, cryp->caps->cr);\n\tcfg &= ~CR_CRYPEN;\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\t \n\tstm32_cryp_write(cryp, cryp->caps->iv1r, cryp->gcm_ctr - 2);\n\n\t \n\tcfg &= ~CR_ALGO_MASK;\n\tcfg |= CR_AES_CTR;\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\t \n\tcfg |= CR_CRYPEN;\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\t \n\tstm32_cryp_irq_write_block(cryp);\n\t \n\terr = stm32_cryp_wait_output(cryp);\n\tif (err) {\n\t\tdev_err(cryp->dev, \"Timeout (write gcm last data)\\n\");\n\t\treturn stm32_cryp_finish_req(cryp, err);\n\t}\n\n\t \n\t \n\treadsl(cryp->regs + cryp->caps->dout, block, cryp->hw_blocksize / sizeof(u32));\n\n\tscatterwalk_copychunks(block, &cryp->out_walk, min_t(size_t, cryp->hw_blocksize,\n\t\t\t\t\t\t\t     cryp->payload_out), 1);\n\tcryp->payload_out -= min_t(size_t, cryp->hw_blocksize,\n\t\t\t\t   cryp->payload_out);\n\n\t \n\tcfg &= ~CR_ALGO_MASK;\n\tcfg |= CR_AES_GCM;\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\t \n\tcfg &= ~CR_PH_MASK;\n\tcfg |= CR_PH_FINAL;\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\t \n\twritesl(cryp->regs + cryp->caps->din, block, AES_BLOCK_32);\n\n\t \n\terr = stm32_cryp_wait_output(cryp);\n\tif (err) {\n\t\tdev_err(cryp->dev, \"Timeout (write gcm padded data)\\n\");\n\t\treturn stm32_cryp_finish_req(cryp, err);\n\t}\n\n\tfor (i = 0; i < AES_BLOCK_32; i++)\n\t\tstm32_cryp_read(cryp, cryp->caps->dout);\n\n\t \n\tstm32_cryp_finish_req(cryp, 0);\n}\n\nstatic void stm32_cryp_irq_set_npblb(struct stm32_cryp *cryp)\n{\n\tu32 cfg;\n\n\t \n\tcfg = stm32_cryp_read(cryp, cryp->caps->cr);\n\tcfg &= ~CR_CRYPEN;\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\tcfg |= (cryp->hw_blocksize - cryp->payload_in) << CR_NBPBL_SHIFT;\n\tcfg |= CR_CRYPEN;\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n}\n\nstatic void stm32_cryp_irq_write_ccm_padded_data(struct stm32_cryp *cryp)\n{\n\tint err = 0;\n\tu32 cfg, iv1tmp;\n\tu32 cstmp1[AES_BLOCK_32], cstmp2[AES_BLOCK_32];\n\tu32 block[AES_BLOCK_32] = {0};\n\tunsigned int i;\n\n\t \n\n\t \n\tstm32_cryp_write(cryp, cryp->caps->imsc, 0);\n\n\tcfg = stm32_cryp_read(cryp, cryp->caps->cr);\n\tcfg &= ~CR_CRYPEN;\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\t \n\tiv1tmp = stm32_cryp_read(cryp, CRYP_CSGCMCCM0R + 7 * 4);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cstmp1); i++)\n\t\tcstmp1[i] = stm32_cryp_read(cryp, CRYP_CSGCMCCM0R + i * 4);\n\n\t \n\tstm32_cryp_write(cryp, cryp->caps->iv1r, iv1tmp);\n\n\t \n\tcfg &= ~CR_ALGO_MASK;\n\tcfg |= CR_AES_CTR;\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\t \n\tcfg |= CR_CRYPEN;\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\t \n\tstm32_cryp_irq_write_block(cryp);\n\t \n\terr = stm32_cryp_wait_output(cryp);\n\tif (err) {\n\t\tdev_err(cryp->dev, \"Timeout (write ccm padded data)\\n\");\n\t\treturn stm32_cryp_finish_req(cryp, err);\n\t}\n\n\t \n\t \n\treadsl(cryp->regs + cryp->caps->dout, block, cryp->hw_blocksize / sizeof(u32));\n\n\tscatterwalk_copychunks(block, &cryp->out_walk, min_t(size_t, cryp->hw_blocksize,\n\t\t\t\t\t\t\t     cryp->payload_out), 1);\n\tcryp->payload_out -= min_t(size_t, cryp->hw_blocksize, cryp->payload_out);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cstmp2); i++)\n\t\tcstmp2[i] = stm32_cryp_read(cryp, CRYP_CSGCMCCM0R + i * 4);\n\n\t \n\tcfg &= ~CR_ALGO_MASK;\n\tcfg |= CR_AES_CCM;\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\t \n\tcfg &= ~CR_PH_MASK;\n\tcfg |= CR_PH_HEADER;\n\tstm32_cryp_write(cryp, cryp->caps->cr, cfg);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(block); i++) {\n\t\tblock[i] ^= cstmp1[i];\n\t\tblock[i] ^= cstmp2[i];\n\t\tstm32_cryp_write(cryp, cryp->caps->din, block[i]);\n\t}\n\n\t \n\terr = stm32_cryp_wait_busy(cryp);\n\tif (err)\n\t\tdev_err(cryp->dev, \"Timeout (write ccm padded data)\\n\");\n\n\t \n\tstm32_cryp_finish_req(cryp, err);\n}\n\nstatic void stm32_cryp_irq_write_data(struct stm32_cryp *cryp)\n{\n\tif (unlikely(!cryp->payload_in)) {\n\t\tdev_warn(cryp->dev, \"No more data to process\\n\");\n\t\treturn;\n\t}\n\n\tif (unlikely(cryp->payload_in < AES_BLOCK_SIZE &&\n\t\t     (stm32_cryp_get_hw_mode(cryp) == CR_AES_GCM) &&\n\t\t     is_encrypt(cryp))) {\n\t\t \n\t\tif (cryp->caps->padding_wa) {\n\t\t\t \n\t\t\tstm32_cryp_irq_write_gcm_padded_data(cryp);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tstm32_cryp_irq_set_npblb(cryp);\n\t}\n\n\tif (unlikely((cryp->payload_in < AES_BLOCK_SIZE) &&\n\t\t     (stm32_cryp_get_hw_mode(cryp) == CR_AES_CCM) &&\n\t\t     is_decrypt(cryp))) {\n\t\t \n\t\tif (cryp->caps->padding_wa) {\n\t\t\t \n\t\t\tstm32_cryp_irq_write_ccm_padded_data(cryp);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tstm32_cryp_irq_set_npblb(cryp);\n\t}\n\n\tif (is_aes(cryp) && is_ctr(cryp))\n\t\tstm32_cryp_check_ctr_counter(cryp);\n\n\tstm32_cryp_irq_write_block(cryp);\n}\n\nstatic void stm32_cryp_irq_write_gcmccm_header(struct stm32_cryp *cryp)\n{\n\tu32 block[AES_BLOCK_32] = {0};\n\tsize_t written;\n\n\twritten = min_t(size_t, AES_BLOCK_SIZE, cryp->header_in);\n\n\tscatterwalk_copychunks(block, &cryp->in_walk, written, 0);\n\n\twritesl(cryp->regs + cryp->caps->din, block, AES_BLOCK_32);\n\n\tcryp->header_in -= written;\n\n\tstm32_crypt_gcmccm_end_header(cryp);\n}\n\nstatic irqreturn_t stm32_cryp_irq_thread(int irq, void *arg)\n{\n\tstruct stm32_cryp *cryp = arg;\n\tu32 ph;\n\tu32 it_mask = stm32_cryp_read(cryp, cryp->caps->imsc);\n\n\tif (cryp->irq_status & MISR_OUT)\n\t\t \n\t\tstm32_cryp_irq_read_data(cryp);\n\n\tif (cryp->irq_status & MISR_IN) {\n\t\tif (is_gcm(cryp) || is_ccm(cryp)) {\n\t\t\tph = stm32_cryp_read(cryp, cryp->caps->cr) & CR_PH_MASK;\n\t\t\tif (unlikely(ph == CR_PH_HEADER))\n\t\t\t\t \n\t\t\t\tstm32_cryp_irq_write_gcmccm_header(cryp);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tstm32_cryp_irq_write_data(cryp);\n\t\t\tif (is_gcm(cryp))\n\t\t\t\tcryp->gcm_ctr++;\n\t\t} else {\n\t\t\t \n\t\t\tstm32_cryp_irq_write_data(cryp);\n\t\t}\n\t}\n\n\t \n\tif (!cryp->payload_in && !cryp->header_in)\n\t\tit_mask &= ~IMSCR_IN;\n\tif (!cryp->payload_out)\n\t\tit_mask &= ~IMSCR_OUT;\n\tstm32_cryp_write(cryp, cryp->caps->imsc, it_mask);\n\n\tif (!cryp->payload_in && !cryp->header_in && !cryp->payload_out)\n\t\tstm32_cryp_finish_req(cryp, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t stm32_cryp_irq(int irq, void *arg)\n{\n\tstruct stm32_cryp *cryp = arg;\n\n\tcryp->irq_status = stm32_cryp_read(cryp, cryp->caps->mis);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic struct skcipher_engine_alg crypto_algs[] = {\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"ecb(aes)\",\n\t\t.base.cra_driver_name\t= \"stm32-ecb-aes\",\n\t\t.base.cra_priority\t= 200,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct stm32_cryp_ctx),\n\t\t.base.cra_alignmask\t= 0,\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.init\t\t\t= stm32_cryp_init_tfm,\n\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t.setkey\t\t\t= stm32_cryp_aes_setkey,\n\t\t.encrypt\t\t= stm32_cryp_aes_ecb_encrypt,\n\t\t.decrypt\t\t= stm32_cryp_aes_ecb_decrypt,\n\t},\n\t.op = {\n\t\t.do_one_request = stm32_cryp_cipher_one_req,\n\t},\n},\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"cbc(aes)\",\n\t\t.base.cra_driver_name\t= \"stm32-cbc-aes\",\n\t\t.base.cra_priority\t= 200,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.base.cra_blocksize\t= AES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct stm32_cryp_ctx),\n\t\t.base.cra_alignmask\t= 0,\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.init\t\t\t= stm32_cryp_init_tfm,\n\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t\t.setkey\t\t\t= stm32_cryp_aes_setkey,\n\t\t.encrypt\t\t= stm32_cryp_aes_cbc_encrypt,\n\t\t.decrypt\t\t= stm32_cryp_aes_cbc_decrypt,\n\t},\n\t.op = {\n\t\t.do_one_request = stm32_cryp_cipher_one_req,\n\t},\n},\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"ctr(aes)\",\n\t\t.base.cra_driver_name\t= \"stm32-ctr-aes\",\n\t\t.base.cra_priority\t= 200,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.base.cra_blocksize\t= 1,\n\t\t.base.cra_ctxsize\t= sizeof(struct stm32_cryp_ctx),\n\t\t.base.cra_alignmask\t= 0,\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.init\t\t\t= stm32_cryp_init_tfm,\n\t\t.min_keysize\t\t= AES_MIN_KEY_SIZE,\n\t\t.max_keysize\t\t= AES_MAX_KEY_SIZE,\n\t\t.ivsize\t\t\t= AES_BLOCK_SIZE,\n\t\t.setkey\t\t\t= stm32_cryp_aes_setkey,\n\t\t.encrypt\t\t= stm32_cryp_aes_ctr_encrypt,\n\t\t.decrypt\t\t= stm32_cryp_aes_ctr_decrypt,\n\t},\n\t.op = {\n\t\t.do_one_request = stm32_cryp_cipher_one_req,\n\t},\n},\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"ecb(des)\",\n\t\t.base.cra_driver_name\t= \"stm32-ecb-des\",\n\t\t.base.cra_priority\t= 200,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct stm32_cryp_ctx),\n\t\t.base.cra_alignmask\t= 0,\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.init\t\t\t= stm32_cryp_init_tfm,\n\t\t.min_keysize\t\t= DES_BLOCK_SIZE,\n\t\t.max_keysize\t\t= DES_BLOCK_SIZE,\n\t\t.setkey\t\t\t= stm32_cryp_des_setkey,\n\t\t.encrypt\t\t= stm32_cryp_des_ecb_encrypt,\n\t\t.decrypt\t\t= stm32_cryp_des_ecb_decrypt,\n\t},\n\t.op = {\n\t\t.do_one_request = stm32_cryp_cipher_one_req,\n\t},\n},\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"cbc(des)\",\n\t\t.base.cra_driver_name\t= \"stm32-cbc-des\",\n\t\t.base.cra_priority\t= 200,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct stm32_cryp_ctx),\n\t\t.base.cra_alignmask\t= 0,\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.init\t\t\t= stm32_cryp_init_tfm,\n\t\t.min_keysize\t\t= DES_BLOCK_SIZE,\n\t\t.max_keysize\t\t= DES_BLOCK_SIZE,\n\t\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t\t.setkey\t\t\t= stm32_cryp_des_setkey,\n\t\t.encrypt\t\t= stm32_cryp_des_cbc_encrypt,\n\t\t.decrypt\t\t= stm32_cryp_des_cbc_decrypt,\n\t},\n\t.op = {\n\t\t.do_one_request = stm32_cryp_cipher_one_req,\n\t},\n},\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"ecb(des3_ede)\",\n\t\t.base.cra_driver_name\t= \"stm32-ecb-des3\",\n\t\t.base.cra_priority\t= 200,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct stm32_cryp_ctx),\n\t\t.base.cra_alignmask\t= 0,\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.init\t\t\t= stm32_cryp_init_tfm,\n\t\t.min_keysize\t\t= 3 * DES_BLOCK_SIZE,\n\t\t.max_keysize\t\t= 3 * DES_BLOCK_SIZE,\n\t\t.setkey\t\t\t= stm32_cryp_tdes_setkey,\n\t\t.encrypt\t\t= stm32_cryp_tdes_ecb_encrypt,\n\t\t.decrypt\t\t= stm32_cryp_tdes_ecb_decrypt,\n\t},\n\t.op = {\n\t\t.do_one_request = stm32_cryp_cipher_one_req,\n\t},\n},\n{\n\t.base = {\n\t\t.base.cra_name\t\t= \"cbc(des3_ede)\",\n\t\t.base.cra_driver_name\t= \"stm32-cbc-des3\",\n\t\t.base.cra_priority\t= 200,\n\t\t.base.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.base.cra_blocksize\t= DES_BLOCK_SIZE,\n\t\t.base.cra_ctxsize\t= sizeof(struct stm32_cryp_ctx),\n\t\t.base.cra_alignmask\t= 0,\n\t\t.base.cra_module\t= THIS_MODULE,\n\n\t\t.init\t\t\t= stm32_cryp_init_tfm,\n\t\t.min_keysize\t\t= 3 * DES_BLOCK_SIZE,\n\t\t.max_keysize\t\t= 3 * DES_BLOCK_SIZE,\n\t\t.ivsize\t\t\t= DES_BLOCK_SIZE,\n\t\t.setkey\t\t\t= stm32_cryp_tdes_setkey,\n\t\t.encrypt\t\t= stm32_cryp_tdes_cbc_encrypt,\n\t\t.decrypt\t\t= stm32_cryp_tdes_cbc_decrypt,\n\t},\n\t.op = {\n\t\t.do_one_request = stm32_cryp_cipher_one_req,\n\t},\n},\n};\n\nstatic struct aead_engine_alg aead_algs[] = {\n{\n\t.base.setkey\t\t= stm32_cryp_aes_aead_setkey,\n\t.base.setauthsize\t= stm32_cryp_aes_gcm_setauthsize,\n\t.base.encrypt\t\t= stm32_cryp_aes_gcm_encrypt,\n\t.base.decrypt\t\t= stm32_cryp_aes_gcm_decrypt,\n\t.base.init\t\t= stm32_cryp_aes_aead_init,\n\t.base.ivsize\t\t= 12,\n\t.base.maxauthsize\t= AES_BLOCK_SIZE,\n\n\t.base.base = {\n\t\t.cra_name\t\t= \"gcm(aes)\",\n\t\t.cra_driver_name\t= \"stm32-gcm-aes\",\n\t\t.cra_priority\t\t= 200,\n\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.cra_blocksize\t\t= 1,\n\t\t.cra_ctxsize\t\t= sizeof(struct stm32_cryp_ctx),\n\t\t.cra_alignmask\t\t= 0,\n\t\t.cra_module\t\t= THIS_MODULE,\n\t},\n\t.op = {\n\t\t.do_one_request = stm32_cryp_aead_one_req,\n\t},\n},\n{\n\t.base.setkey\t\t= stm32_cryp_aes_aead_setkey,\n\t.base.setauthsize\t= stm32_cryp_aes_ccm_setauthsize,\n\t.base.encrypt\t\t= stm32_cryp_aes_ccm_encrypt,\n\t.base.decrypt\t\t= stm32_cryp_aes_ccm_decrypt,\n\t.base.init\t\t= stm32_cryp_aes_aead_init,\n\t.base.ivsize\t\t= AES_BLOCK_SIZE,\n\t.base.maxauthsize\t= AES_BLOCK_SIZE,\n\n\t.base.base = {\n\t\t.cra_name\t\t= \"ccm(aes)\",\n\t\t.cra_driver_name\t= \"stm32-ccm-aes\",\n\t\t.cra_priority\t\t= 200,\n\t\t.cra_flags\t\t= CRYPTO_ALG_ASYNC,\n\t\t.cra_blocksize\t\t= 1,\n\t\t.cra_ctxsize\t\t= sizeof(struct stm32_cryp_ctx),\n\t\t.cra_alignmask\t\t= 0,\n\t\t.cra_module\t\t= THIS_MODULE,\n\t},\n\t.op = {\n\t\t.do_one_request = stm32_cryp_aead_one_req,\n\t},\n},\n};\n\nstatic const struct stm32_cryp_caps ux500_data = {\n\t.aeads_support = false,\n\t.linear_aes_key = true,\n\t.kp_mode = false,\n\t.iv_protection = true,\n\t.swap_final = true,\n\t.padding_wa = true,\n\t.cr = UX500_CRYP_CR,\n\t.sr = UX500_CRYP_SR,\n\t.din = UX500_CRYP_DIN,\n\t.dout = UX500_CRYP_DOUT,\n\t.imsc = UX500_CRYP_IMSC,\n\t.mis = UX500_CRYP_MIS,\n\t.k1l = UX500_CRYP_K1L,\n\t.k1r = UX500_CRYP_K1R,\n\t.k3r = UX500_CRYP_K3R,\n\t.iv0l = UX500_CRYP_IV0L,\n\t.iv0r = UX500_CRYP_IV0R,\n\t.iv1l = UX500_CRYP_IV1L,\n\t.iv1r = UX500_CRYP_IV1R,\n};\n\nstatic const struct stm32_cryp_caps f7_data = {\n\t.aeads_support = true,\n\t.linear_aes_key = false,\n\t.kp_mode = true,\n\t.iv_protection = false,\n\t.swap_final = true,\n\t.padding_wa = true,\n\t.cr = CRYP_CR,\n\t.sr = CRYP_SR,\n\t.din = CRYP_DIN,\n\t.dout = CRYP_DOUT,\n\t.imsc = CRYP_IMSCR,\n\t.mis = CRYP_MISR,\n\t.k1l = CRYP_K1LR,\n\t.k1r = CRYP_K1RR,\n\t.k3r = CRYP_K3RR,\n\t.iv0l = CRYP_IV0LR,\n\t.iv0r = CRYP_IV0RR,\n\t.iv1l = CRYP_IV1LR,\n\t.iv1r = CRYP_IV1RR,\n};\n\nstatic const struct stm32_cryp_caps mp1_data = {\n\t.aeads_support = true,\n\t.linear_aes_key = false,\n\t.kp_mode = true,\n\t.iv_protection = false,\n\t.swap_final = false,\n\t.padding_wa = false,\n\t.cr = CRYP_CR,\n\t.sr = CRYP_SR,\n\t.din = CRYP_DIN,\n\t.dout = CRYP_DOUT,\n\t.imsc = CRYP_IMSCR,\n\t.mis = CRYP_MISR,\n\t.k1l = CRYP_K1LR,\n\t.k1r = CRYP_K1RR,\n\t.k3r = CRYP_K3RR,\n\t.iv0l = CRYP_IV0LR,\n\t.iv0r = CRYP_IV0RR,\n\t.iv1l = CRYP_IV1LR,\n\t.iv1r = CRYP_IV1RR,\n};\n\nstatic const struct of_device_id stm32_dt_ids[] = {\n\t{ .compatible = \"stericsson,ux500-cryp\", .data = &ux500_data},\n\t{ .compatible = \"st,stm32f756-cryp\", .data = &f7_data},\n\t{ .compatible = \"st,stm32mp1-cryp\", .data = &mp1_data},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_dt_ids);\n\nstatic int stm32_cryp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct stm32_cryp *cryp;\n\tstruct reset_control *rst;\n\tint irq, ret;\n\n\tcryp = devm_kzalloc(dev, sizeof(*cryp), GFP_KERNEL);\n\tif (!cryp)\n\t\treturn -ENOMEM;\n\n\tcryp->caps = of_device_get_match_data(dev);\n\tif (!cryp->caps)\n\t\treturn -ENODEV;\n\n\tcryp->dev = dev;\n\n\tcryp->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(cryp->regs))\n\t\treturn PTR_ERR(cryp->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(dev, irq, stm32_cryp_irq,\n\t\t\t\t\tstm32_cryp_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), cryp);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot grab IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tcryp->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(cryp->clk)) {\n\t\tdev_err_probe(dev, PTR_ERR(cryp->clk), \"Could not get clock\\n\");\n\n\t\treturn PTR_ERR(cryp->clk);\n\t}\n\n\tret = clk_prepare_enable(cryp->clk);\n\tif (ret) {\n\t\tdev_err(cryp->dev, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(dev, CRYP_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(dev);\n\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\trst = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(rst)) {\n\t\tret = PTR_ERR(rst);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto err_rst;\n\t} else {\n\t\treset_control_assert(rst);\n\t\tudelay(2);\n\t\treset_control_deassert(rst);\n\t}\n\n\tplatform_set_drvdata(pdev, cryp);\n\n\tspin_lock(&cryp_list.lock);\n\tlist_add(&cryp->list, &cryp_list.dev_list);\n\tspin_unlock(&cryp_list.lock);\n\n\t \n\tcryp->engine = crypto_engine_alloc_init(dev, 1);\n\tif (!cryp->engine) {\n\t\tdev_err(dev, \"Could not init crypto engine\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_engine1;\n\t}\n\n\tret = crypto_engine_start(cryp->engine);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not start crypto engine\\n\");\n\t\tgoto err_engine2;\n\t}\n\n\tret = crypto_engine_register_skciphers(crypto_algs, ARRAY_SIZE(crypto_algs));\n\tif (ret) {\n\t\tdev_err(dev, \"Could not register algs\\n\");\n\t\tgoto err_algs;\n\t}\n\n\tif (cryp->caps->aeads_support) {\n\t\tret = crypto_engine_register_aeads(aead_algs, ARRAY_SIZE(aead_algs));\n\t\tif (ret)\n\t\t\tgoto err_aead_algs;\n\t}\n\n\tdev_info(dev, \"Initialized\\n\");\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n\nerr_aead_algs:\n\tcrypto_engine_unregister_skciphers(crypto_algs, ARRAY_SIZE(crypto_algs));\nerr_algs:\nerr_engine2:\n\tcrypto_engine_exit(cryp->engine);\nerr_engine1:\n\tspin_lock(&cryp_list.lock);\n\tlist_del(&cryp->list);\n\tspin_unlock(&cryp_list.lock);\nerr_rst:\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\n\n\tclk_disable_unprepare(cryp->clk);\n\n\treturn ret;\n}\n\nstatic int stm32_cryp_remove(struct platform_device *pdev)\n{\n\tstruct stm32_cryp *cryp = platform_get_drvdata(pdev);\n\tint ret;\n\n\tif (!cryp)\n\t\treturn -ENODEV;\n\n\tret = pm_runtime_resume_and_get(cryp->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cryp->caps->aeads_support)\n\t\tcrypto_engine_unregister_aeads(aead_algs, ARRAY_SIZE(aead_algs));\n\tcrypto_engine_unregister_skciphers(crypto_algs, ARRAY_SIZE(crypto_algs));\n\n\tcrypto_engine_exit(cryp->engine);\n\n\tspin_lock(&cryp_list.lock);\n\tlist_del(&cryp->list);\n\tspin_unlock(&cryp_list.lock);\n\n\tpm_runtime_disable(cryp->dev);\n\tpm_runtime_put_noidle(cryp->dev);\n\n\tclk_disable_unprepare(cryp->clk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int stm32_cryp_runtime_suspend(struct device *dev)\n{\n\tstruct stm32_cryp *cryp = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(cryp->clk);\n\n\treturn 0;\n}\n\nstatic int stm32_cryp_runtime_resume(struct device *dev)\n{\n\tstruct stm32_cryp *cryp = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(cryp->clk);\n\tif (ret) {\n\t\tdev_err(cryp->dev, \"Failed to prepare_enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops stm32_cryp_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(stm32_cryp_runtime_suspend,\n\t\t\t   stm32_cryp_runtime_resume, NULL)\n};\n\nstatic struct platform_driver stm32_cryp_driver = {\n\t.probe  = stm32_cryp_probe,\n\t.remove = stm32_cryp_remove,\n\t.driver = {\n\t\t.name           = DRIVER_NAME,\n\t\t.pm\t\t= &stm32_cryp_pm_ops,\n\t\t.of_match_table = stm32_dt_ids,\n\t},\n};\n\nmodule_platform_driver(stm32_cryp_driver);\n\nMODULE_AUTHOR(\"Fabien Dessenne <fabien.dessenne@st.com>\");\nMODULE_DESCRIPTION(\"STMicrolectronics STM32 CRYP hardware driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}