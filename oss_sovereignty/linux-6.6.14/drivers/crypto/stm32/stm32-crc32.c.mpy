{
  "module_name": "stm32-crc32.c",
  "hash_id": "0f139cb8df2c7c558db1ff85f098ee9d299fb9ad948b48dc6507164625a86d11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/stm32/stm32-crc32.c",
  "human_readable_source": "\n \n\n#include <linux/bitrev.h>\n#include <linux/clk.h>\n#include <linux/crc32.h>\n#include <linux/crc32poly.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <crypto/internal/hash.h>\n\n#include <asm/unaligned.h>\n\n#define DRIVER_NAME             \"stm32-crc32\"\n#define CHKSUM_DIGEST_SIZE      4\n#define CHKSUM_BLOCK_SIZE       1\n\n \n#define CRC_DR                  0x00000000\n#define CRC_CR                  0x00000008\n#define CRC_INIT                0x00000010\n#define CRC_POL                 0x00000014\n\n \n#define CRC_CR_RESET            BIT(0)\n#define CRC_CR_REV_IN_WORD      (BIT(6) | BIT(5))\n#define CRC_CR_REV_IN_BYTE      BIT(5)\n#define CRC_CR_REV_OUT          BIT(7)\n#define CRC32C_INIT_DEFAULT     0xFFFFFFFF\n\n#define CRC_AUTOSUSPEND_DELAY\t50\n\nstatic unsigned int burst_size;\nmodule_param(burst_size, uint, 0644);\nMODULE_PARM_DESC(burst_size, \"Select burst byte size (0 unlimited)\");\n\nstruct stm32_crc {\n\tstruct list_head list;\n\tstruct device    *dev;\n\tvoid __iomem     *regs;\n\tstruct clk       *clk;\n\tspinlock_t       lock;\n};\n\nstruct stm32_crc_list {\n\tstruct list_head dev_list;\n\tspinlock_t       lock;  \n};\n\nstatic struct stm32_crc_list crc_list = {\n\t.dev_list = LIST_HEAD_INIT(crc_list.dev_list),\n\t.lock     = __SPIN_LOCK_UNLOCKED(crc_list.lock),\n};\n\nstruct stm32_crc_ctx {\n\tu32 key;\n\tu32 poly;\n};\n\nstruct stm32_crc_desc_ctx {\n\tu32    partial;  \n};\n\nstatic int stm32_crc32_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct stm32_crc_ctx *mctx = crypto_tfm_ctx(tfm);\n\n\tmctx->key = 0;\n\tmctx->poly = CRC32_POLY_LE;\n\treturn 0;\n}\n\nstatic int stm32_crc32c_cra_init(struct crypto_tfm *tfm)\n{\n\tstruct stm32_crc_ctx *mctx = crypto_tfm_ctx(tfm);\n\n\tmctx->key = CRC32C_INIT_DEFAULT;\n\tmctx->poly = CRC32C_POLY_LE;\n\treturn 0;\n}\n\nstatic int stm32_crc_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t\t    unsigned int keylen)\n{\n\tstruct stm32_crc_ctx *mctx = crypto_shash_ctx(tfm);\n\n\tif (keylen != sizeof(u32))\n\t\treturn -EINVAL;\n\n\tmctx->key = get_unaligned_le32(key);\n\treturn 0;\n}\n\nstatic struct stm32_crc *stm32_crc_get_next_crc(void)\n{\n\tstruct stm32_crc *crc;\n\n\tspin_lock_bh(&crc_list.lock);\n\tcrc = list_first_entry(&crc_list.dev_list, struct stm32_crc, list);\n\tif (crc)\n\t\tlist_move_tail(&crc->list, &crc_list.dev_list);\n\tspin_unlock_bh(&crc_list.lock);\n\n\treturn crc;\n}\n\nstatic int stm32_crc_init(struct shash_desc *desc)\n{\n\tstruct stm32_crc_desc_ctx *ctx = shash_desc_ctx(desc);\n\tstruct stm32_crc_ctx *mctx = crypto_shash_ctx(desc->tfm);\n\tstruct stm32_crc *crc;\n\tunsigned long flags;\n\n\tcrc = stm32_crc_get_next_crc();\n\tif (!crc)\n\t\treturn -ENODEV;\n\n\tpm_runtime_get_sync(crc->dev);\n\n\tspin_lock_irqsave(&crc->lock, flags);\n\n\t \n\twritel_relaxed(bitrev32(mctx->key), crc->regs + CRC_INIT);\n\twritel_relaxed(bitrev32(mctx->poly), crc->regs + CRC_POL);\n\twritel_relaxed(CRC_CR_RESET | CRC_CR_REV_IN_WORD | CRC_CR_REV_OUT,\n\t\t       crc->regs + CRC_CR);\n\n\t \n\tctx->partial = readl_relaxed(crc->regs + CRC_DR);\n\n\tspin_unlock_irqrestore(&crc->lock, flags);\n\n\tpm_runtime_mark_last_busy(crc->dev);\n\tpm_runtime_put_autosuspend(crc->dev);\n\n\treturn 0;\n}\n\nstatic int burst_update(struct shash_desc *desc, const u8 *d8,\n\t\t\tsize_t length)\n{\n\tstruct stm32_crc_desc_ctx *ctx = shash_desc_ctx(desc);\n\tstruct stm32_crc_ctx *mctx = crypto_shash_ctx(desc->tfm);\n\tstruct stm32_crc *crc;\n\n\tcrc = stm32_crc_get_next_crc();\n\tif (!crc)\n\t\treturn -ENODEV;\n\n\tpm_runtime_get_sync(crc->dev);\n\n\tif (!spin_trylock(&crc->lock)) {\n\t\t \n\t\tif (mctx->poly == CRC32_POLY_LE)\n\t\t\tctx->partial = crc32_le(ctx->partial, d8, length);\n\t\telse\n\t\t\tctx->partial = __crc32c_le(ctx->partial, d8, length);\n\n\t\tgoto pm_out;\n\t}\n\n\t \n\twritel_relaxed(bitrev32(ctx->partial), crc->regs + CRC_INIT);\n\twritel_relaxed(bitrev32(mctx->poly), crc->regs + CRC_POL);\n\twritel_relaxed(CRC_CR_RESET | CRC_CR_REV_IN_WORD | CRC_CR_REV_OUT,\n\t\t       crc->regs + CRC_CR);\n\n\tif (d8 != PTR_ALIGN(d8, sizeof(u32))) {\n\t\t \n\t\twritel_relaxed(CRC_CR_REV_IN_BYTE | CRC_CR_REV_OUT,\n\t\t\t       crc->regs + CRC_CR);\n\t\twhile (d8 != PTR_ALIGN(d8, sizeof(u32)) && length) {\n\t\t\twriteb_relaxed(*d8++, crc->regs + CRC_DR);\n\t\t\tlength--;\n\t\t}\n\t\t \n\t\twritel_relaxed(CRC_CR_REV_IN_WORD | CRC_CR_REV_OUT,\n\t\t\t       crc->regs + CRC_CR);\n\t}\n\n\tfor (; length >= sizeof(u32); d8 += sizeof(u32), length -= sizeof(u32))\n\t\twritel_relaxed(*((u32 *)d8), crc->regs + CRC_DR);\n\n\tif (length) {\n\t\t \n\t\twritel_relaxed(CRC_CR_REV_IN_BYTE | CRC_CR_REV_OUT,\n\t\t\t       crc->regs + CRC_CR);\n\t\twhile (length--)\n\t\t\twriteb_relaxed(*d8++, crc->regs + CRC_DR);\n\t}\n\n\t \n\tctx->partial = readl_relaxed(crc->regs + CRC_DR);\n\n\tspin_unlock(&crc->lock);\n\npm_out:\n\tpm_runtime_mark_last_busy(crc->dev);\n\tpm_runtime_put_autosuspend(crc->dev);\n\n\treturn 0;\n}\n\nstatic int stm32_crc_update(struct shash_desc *desc, const u8 *d8,\n\t\t\t    unsigned int length)\n{\n\tconst unsigned int burst_sz = burst_size;\n\tunsigned int rem_sz;\n\tconst u8 *cur;\n\tsize_t size;\n\tint ret;\n\n\tif (!burst_sz)\n\t\treturn burst_update(desc, d8, length);\n\n\t \n\tsize = min_t(size_t, length, burst_sz + (size_t)d8 -\n\t\t\t\t     ALIGN_DOWN((size_t)d8, sizeof(u32)));\n\tfor (rem_sz = length, cur = d8; rem_sz;\n\t     rem_sz -= size, cur += size, size = min(rem_sz, burst_sz)) {\n\t\tret = burst_update(desc, cur, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_crc_final(struct shash_desc *desc, u8 *out)\n{\n\tstruct stm32_crc_desc_ctx *ctx = shash_desc_ctx(desc);\n\tstruct stm32_crc_ctx *mctx = crypto_shash_ctx(desc->tfm);\n\n\t \n\tput_unaligned_le32(mctx->poly == CRC32C_POLY_LE ?\n\t\t\t   ~ctx->partial : ctx->partial, out);\n\n\treturn 0;\n}\n\nstatic int stm32_crc_finup(struct shash_desc *desc, const u8 *data,\n\t\t\t   unsigned int length, u8 *out)\n{\n\treturn stm32_crc_update(desc, data, length) ?:\n\t       stm32_crc_final(desc, out);\n}\n\nstatic int stm32_crc_digest(struct shash_desc *desc, const u8 *data,\n\t\t\t    unsigned int length, u8 *out)\n{\n\treturn stm32_crc_init(desc) ?: stm32_crc_finup(desc, data, length, out);\n}\n\nstatic unsigned int refcnt;\nstatic DEFINE_MUTEX(refcnt_lock);\nstatic struct shash_alg algs[] = {\n\t \n\t{\n\t\t.setkey         = stm32_crc_setkey,\n\t\t.init           = stm32_crc_init,\n\t\t.update         = stm32_crc_update,\n\t\t.final          = stm32_crc_final,\n\t\t.finup          = stm32_crc_finup,\n\t\t.digest         = stm32_crc_digest,\n\t\t.descsize       = sizeof(struct stm32_crc_desc_ctx),\n\t\t.digestsize     = CHKSUM_DIGEST_SIZE,\n\t\t.base           = {\n\t\t\t.cra_name               = \"crc32\",\n\t\t\t.cra_driver_name        = \"stm32-crc32-crc32\",\n\t\t\t.cra_priority           = 200,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_OPTIONAL_KEY,\n\t\t\t.cra_blocksize          = CHKSUM_BLOCK_SIZE,\n\t\t\t.cra_alignmask          = 3,\n\t\t\t.cra_ctxsize            = sizeof(struct stm32_crc_ctx),\n\t\t\t.cra_module             = THIS_MODULE,\n\t\t\t.cra_init               = stm32_crc32_cra_init,\n\t\t}\n\t},\n\t \n\t{\n\t\t.setkey         = stm32_crc_setkey,\n\t\t.init           = stm32_crc_init,\n\t\t.update         = stm32_crc_update,\n\t\t.final          = stm32_crc_final,\n\t\t.finup          = stm32_crc_finup,\n\t\t.digest         = stm32_crc_digest,\n\t\t.descsize       = sizeof(struct stm32_crc_desc_ctx),\n\t\t.digestsize     = CHKSUM_DIGEST_SIZE,\n\t\t.base           = {\n\t\t\t.cra_name               = \"crc32c\",\n\t\t\t.cra_driver_name        = \"stm32-crc32-crc32c\",\n\t\t\t.cra_priority           = 200,\n\t\t\t.cra_flags\t\t= CRYPTO_ALG_OPTIONAL_KEY,\n\t\t\t.cra_blocksize          = CHKSUM_BLOCK_SIZE,\n\t\t\t.cra_alignmask          = 3,\n\t\t\t.cra_ctxsize            = sizeof(struct stm32_crc_ctx),\n\t\t\t.cra_module             = THIS_MODULE,\n\t\t\t.cra_init               = stm32_crc32c_cra_init,\n\t\t}\n\t}\n};\n\nstatic int stm32_crc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct stm32_crc *crc;\n\tint ret;\n\n\tcrc = devm_kzalloc(dev, sizeof(*crc), GFP_KERNEL);\n\tif (!crc)\n\t\treturn -ENOMEM;\n\n\tcrc->dev = dev;\n\n\tcrc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(crc->regs)) {\n\t\tdev_err(dev, \"Cannot map CRC IO\\n\");\n\t\treturn PTR_ERR(crc->regs);\n\t}\n\n\tcrc->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(crc->clk)) {\n\t\tdev_err(dev, \"Could not get clock\\n\");\n\t\treturn PTR_ERR(crc->clk);\n\t}\n\n\tret = clk_prepare_enable(crc->clk);\n\tif (ret) {\n\t\tdev_err(crc->dev, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(dev, CRC_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(dev);\n\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_irq_safe(dev);\n\tpm_runtime_enable(dev);\n\n\tspin_lock_init(&crc->lock);\n\n\tplatform_set_drvdata(pdev, crc);\n\n\tspin_lock(&crc_list.lock);\n\tlist_add(&crc->list, &crc_list.dev_list);\n\tspin_unlock(&crc_list.lock);\n\n\tmutex_lock(&refcnt_lock);\n\tif (!refcnt) {\n\t\tret = crypto_register_shashes(algs, ARRAY_SIZE(algs));\n\t\tif (ret) {\n\t\t\tmutex_unlock(&refcnt_lock);\n\t\t\tdev_err(dev, \"Failed to register\\n\");\n\t\t\tclk_disable_unprepare(crc->clk);\n\t\t\treturn ret;\n\t\t}\n\t}\n\trefcnt++;\n\tmutex_unlock(&refcnt_lock);\n\n\tdev_info(dev, \"Initialized\\n\");\n\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int stm32_crc_remove(struct platform_device *pdev)\n{\n\tstruct stm32_crc *crc = platform_get_drvdata(pdev);\n\tint ret = pm_runtime_get_sync(crc->dev);\n\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(crc->dev);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&crc_list.lock);\n\tlist_del(&crc->list);\n\tspin_unlock(&crc_list.lock);\n\n\tmutex_lock(&refcnt_lock);\n\tif (!--refcnt)\n\t\tcrypto_unregister_shashes(algs, ARRAY_SIZE(algs));\n\tmutex_unlock(&refcnt_lock);\n\n\tpm_runtime_disable(crc->dev);\n\tpm_runtime_put_noidle(crc->dev);\n\n\tclk_disable_unprepare(crc->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_crc_suspend(struct device *dev)\n{\n\tstruct stm32_crc *crc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_force_suspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_unprepare(crc->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_crc_resume(struct device *dev)\n{\n\tstruct stm32_crc *crc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare(crc->clk);\n\tif (ret) {\n\t\tdev_err(crc->dev, \"Failed to prepare clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn pm_runtime_force_resume(dev);\n}\n\nstatic int __maybe_unused stm32_crc_runtime_suspend(struct device *dev)\n{\n\tstruct stm32_crc *crc = dev_get_drvdata(dev);\n\n\tclk_disable(crc->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_crc_runtime_resume(struct device *dev)\n{\n\tstruct stm32_crc *crc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_enable(crc->clk);\n\tif (ret) {\n\t\tdev_err(crc->dev, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops stm32_crc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(stm32_crc_suspend,\n\t\t\t\tstm32_crc_resume)\n\tSET_RUNTIME_PM_OPS(stm32_crc_runtime_suspend,\n\t\t\t   stm32_crc_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id stm32_dt_ids[] = {\n\t{ .compatible = \"st,stm32f7-crc\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_dt_ids);\n\nstatic struct platform_driver stm32_crc_driver = {\n\t.probe  = stm32_crc_probe,\n\t.remove = stm32_crc_remove,\n\t.driver = {\n\t\t.name           = DRIVER_NAME,\n\t\t.pm\t\t= &stm32_crc_pm_ops,\n\t\t.of_match_table = stm32_dt_ids,\n\t},\n};\n\nmodule_platform_driver(stm32_crc_driver);\n\nMODULE_AUTHOR(\"Fabien Dessenne <fabien.dessenne@st.com>\");\nMODULE_DESCRIPTION(\"STMicrolectronics STM32 CRC32 hardware driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}