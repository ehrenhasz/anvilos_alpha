{
  "module_name": "crypto4xx_core.c",
  "hash_id": "5ae83d2c5b9f02cbf87fae35c7bb94b6228cf35104ca4c088a8de3cf39531dbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/amcc/crypto4xx_core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock_types.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/slab.h>\n#include <asm/dcr.h>\n#include <asm/dcr-regs.h>\n#include <asm/cacheflush.h>\n#include <crypto/aead.h>\n#include <crypto/aes.h>\n#include <crypto/ctr.h>\n#include <crypto/gcm.h>\n#include <crypto/sha1.h>\n#include <crypto/rng.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/skcipher.h>\n#include <crypto/internal/aead.h>\n#include <crypto/internal/rng.h>\n#include <crypto/internal/skcipher.h>\n#include \"crypto4xx_reg_def.h\"\n#include \"crypto4xx_core.h\"\n#include \"crypto4xx_sa.h\"\n#include \"crypto4xx_trng.h\"\n\n#define PPC4XX_SEC_VERSION_STR\t\t\t\"0.5\"\n\n \nstatic void crypto4xx_hw_init(struct crypto4xx_device *dev)\n{\n\tunion ce_ring_size ring_size;\n\tunion ce_ring_control ring_ctrl;\n\tunion ce_part_ring_size part_ring_size;\n\tunion ce_io_threshold io_threshold;\n\tu32 rand_num;\n\tunion ce_pe_dma_cfg pe_dma_cfg;\n\tu32 device_ctrl;\n\n\twritel(PPC4XX_BYTE_ORDER, dev->ce_base + CRYPTO4XX_BYTE_ORDER_CFG);\n\t \n\tpe_dma_cfg.w = 0;\n\tpe_dma_cfg.bf.bo_sgpd_en = 1;\n\tpe_dma_cfg.bf.bo_data_en = 0;\n\tpe_dma_cfg.bf.bo_sa_en = 1;\n\tpe_dma_cfg.bf.bo_pd_en = 1;\n\tpe_dma_cfg.bf.dynamic_sa_en = 1;\n\tpe_dma_cfg.bf.reset_sg = 1;\n\tpe_dma_cfg.bf.reset_pdr = 1;\n\tpe_dma_cfg.bf.reset_pe = 1;\n\twritel(pe_dma_cfg.w, dev->ce_base + CRYPTO4XX_PE_DMA_CFG);\n\t \n\tpe_dma_cfg.bf.pe_mode = 0;\n\tpe_dma_cfg.bf.reset_sg = 0;\n\tpe_dma_cfg.bf.reset_pdr = 0;\n\tpe_dma_cfg.bf.reset_pe = 0;\n\tpe_dma_cfg.bf.bo_td_en = 0;\n\twritel(pe_dma_cfg.w, dev->ce_base + CRYPTO4XX_PE_DMA_CFG);\n\twritel(dev->pdr_pa, dev->ce_base + CRYPTO4XX_PDR_BASE);\n\twritel(dev->pdr_pa, dev->ce_base + CRYPTO4XX_RDR_BASE);\n\twritel(PPC4XX_PRNG_CTRL_AUTO_EN, dev->ce_base + CRYPTO4XX_PRNG_CTRL);\n\tget_random_bytes(&rand_num, sizeof(rand_num));\n\twritel(rand_num, dev->ce_base + CRYPTO4XX_PRNG_SEED_L);\n\tget_random_bytes(&rand_num, sizeof(rand_num));\n\twritel(rand_num, dev->ce_base + CRYPTO4XX_PRNG_SEED_H);\n\tring_size.w = 0;\n\tring_size.bf.ring_offset = PPC4XX_PD_SIZE;\n\tring_size.bf.ring_size   = PPC4XX_NUM_PD;\n\twritel(ring_size.w, dev->ce_base + CRYPTO4XX_RING_SIZE);\n\tring_ctrl.w = 0;\n\twritel(ring_ctrl.w, dev->ce_base + CRYPTO4XX_RING_CTRL);\n\tdevice_ctrl = readl(dev->ce_base + CRYPTO4XX_DEVICE_CTRL);\n\tdevice_ctrl |= PPC4XX_DC_3DES_EN;\n\twritel(device_ctrl, dev->ce_base + CRYPTO4XX_DEVICE_CTRL);\n\twritel(dev->gdr_pa, dev->ce_base + CRYPTO4XX_GATH_RING_BASE);\n\twritel(dev->sdr_pa, dev->ce_base + CRYPTO4XX_SCAT_RING_BASE);\n\tpart_ring_size.w = 0;\n\tpart_ring_size.bf.sdr_size = PPC4XX_SDR_SIZE;\n\tpart_ring_size.bf.gdr_size = PPC4XX_GDR_SIZE;\n\twritel(part_ring_size.w, dev->ce_base + CRYPTO4XX_PART_RING_SIZE);\n\twritel(PPC4XX_SD_BUFFER_SIZE, dev->ce_base + CRYPTO4XX_PART_RING_CFG);\n\tio_threshold.w = 0;\n\tio_threshold.bf.output_threshold = PPC4XX_OUTPUT_THRESHOLD;\n\tio_threshold.bf.input_threshold  = PPC4XX_INPUT_THRESHOLD;\n\twritel(io_threshold.w, dev->ce_base + CRYPTO4XX_IO_THRESHOLD);\n\twritel(0, dev->ce_base + CRYPTO4XX_PDR_BASE_UADDR);\n\twritel(0, dev->ce_base + CRYPTO4XX_RDR_BASE_UADDR);\n\twritel(0, dev->ce_base + CRYPTO4XX_PKT_SRC_UADDR);\n\twritel(0, dev->ce_base + CRYPTO4XX_PKT_DEST_UADDR);\n\twritel(0, dev->ce_base + CRYPTO4XX_SA_UADDR);\n\twritel(0, dev->ce_base + CRYPTO4XX_GATH_RING_BASE_UADDR);\n\twritel(0, dev->ce_base + CRYPTO4XX_SCAT_RING_BASE_UADDR);\n\t \n\tpe_dma_cfg.bf.pe_mode = 1;\n\tpe_dma_cfg.bf.reset_sg = 0;\n\tpe_dma_cfg.bf.reset_pdr = 0;\n\tpe_dma_cfg.bf.reset_pe = 0;\n\tpe_dma_cfg.bf.bo_td_en = 0;\n\twritel(pe_dma_cfg.w, dev->ce_base + CRYPTO4XX_PE_DMA_CFG);\n\t \n\twritel(PPC4XX_INTERRUPT_CLR, dev->ce_base + CRYPTO4XX_INT_CLR);\n\twritel(PPC4XX_INT_DESCR_CNT, dev->ce_base + CRYPTO4XX_INT_DESCR_CNT);\n\twritel(PPC4XX_INT_DESCR_CNT, dev->ce_base + CRYPTO4XX_INT_DESCR_CNT);\n\twritel(PPC4XX_INT_CFG, dev->ce_base + CRYPTO4XX_INT_CFG);\n\tif (dev->is_revb) {\n\t\twritel(PPC4XX_INT_TIMEOUT_CNT_REVB << 10,\n\t\t       dev->ce_base + CRYPTO4XX_INT_TIMEOUT_CNT);\n\t\twritel(PPC4XX_PD_DONE_INT | PPC4XX_TMO_ERR_INT,\n\t\t       dev->ce_base + CRYPTO4XX_INT_EN);\n\t} else {\n\t\twritel(PPC4XX_PD_DONE_INT, dev->ce_base + CRYPTO4XX_INT_EN);\n\t}\n}\n\nint crypto4xx_alloc_sa(struct crypto4xx_ctx *ctx, u32 size)\n{\n\tctx->sa_in = kcalloc(size, 4, GFP_ATOMIC);\n\tif (ctx->sa_in == NULL)\n\t\treturn -ENOMEM;\n\n\tctx->sa_out = kcalloc(size, 4, GFP_ATOMIC);\n\tif (ctx->sa_out == NULL) {\n\t\tkfree(ctx->sa_in);\n\t\tctx->sa_in = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->sa_len = size;\n\n\treturn 0;\n}\n\nvoid crypto4xx_free_sa(struct crypto4xx_ctx *ctx)\n{\n\tkfree(ctx->sa_in);\n\tctx->sa_in = NULL;\n\tkfree(ctx->sa_out);\n\tctx->sa_out = NULL;\n\tctx->sa_len = 0;\n}\n\n \nstatic u32 crypto4xx_build_pdr(struct crypto4xx_device *dev)\n{\n\tint i;\n\tdev->pdr = dma_alloc_coherent(dev->core_dev->device,\n\t\t\t\t      sizeof(struct ce_pd) * PPC4XX_NUM_PD,\n\t\t\t\t      &dev->pdr_pa, GFP_KERNEL);\n\tif (!dev->pdr)\n\t\treturn -ENOMEM;\n\n\tdev->pdr_uinfo = kcalloc(PPC4XX_NUM_PD, sizeof(struct pd_uinfo),\n\t\t\t\t GFP_KERNEL);\n\tif (!dev->pdr_uinfo) {\n\t\tdma_free_coherent(dev->core_dev->device,\n\t\t\t\t  sizeof(struct ce_pd) * PPC4XX_NUM_PD,\n\t\t\t\t  dev->pdr,\n\t\t\t\t  dev->pdr_pa);\n\t\treturn -ENOMEM;\n\t}\n\tdev->shadow_sa_pool = dma_alloc_coherent(dev->core_dev->device,\n\t\t\t\t   sizeof(union shadow_sa_buf) * PPC4XX_NUM_PD,\n\t\t\t\t   &dev->shadow_sa_pool_pa,\n\t\t\t\t   GFP_KERNEL);\n\tif (!dev->shadow_sa_pool)\n\t\treturn -ENOMEM;\n\n\tdev->shadow_sr_pool = dma_alloc_coherent(dev->core_dev->device,\n\t\t\t sizeof(struct sa_state_record) * PPC4XX_NUM_PD,\n\t\t\t &dev->shadow_sr_pool_pa, GFP_KERNEL);\n\tif (!dev->shadow_sr_pool)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < PPC4XX_NUM_PD; i++) {\n\t\tstruct ce_pd *pd = &dev->pdr[i];\n\t\tstruct pd_uinfo *pd_uinfo = &dev->pdr_uinfo[i];\n\n\t\tpd->sa = dev->shadow_sa_pool_pa +\n\t\t\tsizeof(union shadow_sa_buf) * i;\n\n\t\t \n\t\tpd_uinfo->sa_va = &dev->shadow_sa_pool[i].sa;\n\n\t\t \n\t\tpd_uinfo->sr_va = &dev->shadow_sr_pool[i];\n\t\tpd_uinfo->sr_pa = dev->shadow_sr_pool_pa +\n\t\t    sizeof(struct sa_state_record) * i;\n\t}\n\n\treturn 0;\n}\n\nstatic void crypto4xx_destroy_pdr(struct crypto4xx_device *dev)\n{\n\tif (dev->pdr)\n\t\tdma_free_coherent(dev->core_dev->device,\n\t\t\t\t  sizeof(struct ce_pd) * PPC4XX_NUM_PD,\n\t\t\t\t  dev->pdr, dev->pdr_pa);\n\n\tif (dev->shadow_sa_pool)\n\t\tdma_free_coherent(dev->core_dev->device,\n\t\t\tsizeof(union shadow_sa_buf) * PPC4XX_NUM_PD,\n\t\t\tdev->shadow_sa_pool, dev->shadow_sa_pool_pa);\n\n\tif (dev->shadow_sr_pool)\n\t\tdma_free_coherent(dev->core_dev->device,\n\t\t\tsizeof(struct sa_state_record) * PPC4XX_NUM_PD,\n\t\t\tdev->shadow_sr_pool, dev->shadow_sr_pool_pa);\n\n\tkfree(dev->pdr_uinfo);\n}\n\nstatic u32 crypto4xx_get_pd_from_pdr_nolock(struct crypto4xx_device *dev)\n{\n\tu32 retval;\n\tu32 tmp;\n\n\tretval = dev->pdr_head;\n\ttmp = (dev->pdr_head + 1) % PPC4XX_NUM_PD;\n\n\tif (tmp == dev->pdr_tail)\n\t\treturn ERING_WAS_FULL;\n\n\tdev->pdr_head = tmp;\n\n\treturn retval;\n}\n\nstatic u32 crypto4xx_put_pd_to_pdr(struct crypto4xx_device *dev, u32 idx)\n{\n\tstruct pd_uinfo *pd_uinfo = &dev->pdr_uinfo[idx];\n\tu32 tail;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->core_dev->lock, flags);\n\tpd_uinfo->state = PD_ENTRY_FREE;\n\n\tif (dev->pdr_tail != PPC4XX_LAST_PD)\n\t\tdev->pdr_tail++;\n\telse\n\t\tdev->pdr_tail = 0;\n\ttail = dev->pdr_tail;\n\tspin_unlock_irqrestore(&dev->core_dev->lock, flags);\n\n\treturn tail;\n}\n\n \nstatic u32 crypto4xx_build_gdr(struct crypto4xx_device *dev)\n{\n\tdev->gdr = dma_alloc_coherent(dev->core_dev->device,\n\t\t\t\t      sizeof(struct ce_gd) * PPC4XX_NUM_GD,\n\t\t\t\t      &dev->gdr_pa, GFP_KERNEL);\n\tif (!dev->gdr)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic inline void crypto4xx_destroy_gdr(struct crypto4xx_device *dev)\n{\n\tif (dev->gdr)\n\t\tdma_free_coherent(dev->core_dev->device,\n\t\t\t  sizeof(struct ce_gd) * PPC4XX_NUM_GD,\n\t\t\t  dev->gdr, dev->gdr_pa);\n}\n\n \nstatic u32 crypto4xx_get_n_gd(struct crypto4xx_device *dev, int n)\n{\n\tu32 retval;\n\tu32 tmp;\n\n\tif (n >= PPC4XX_NUM_GD)\n\t\treturn ERING_WAS_FULL;\n\n\tretval = dev->gdr_head;\n\ttmp = (dev->gdr_head + n) % PPC4XX_NUM_GD;\n\tif (dev->gdr_head > dev->gdr_tail) {\n\t\tif (tmp < dev->gdr_head && tmp >= dev->gdr_tail)\n\t\t\treturn ERING_WAS_FULL;\n\t} else if (dev->gdr_head < dev->gdr_tail) {\n\t\tif (tmp < dev->gdr_head || tmp >= dev->gdr_tail)\n\t\t\treturn ERING_WAS_FULL;\n\t}\n\tdev->gdr_head = tmp;\n\n\treturn retval;\n}\n\nstatic u32 crypto4xx_put_gd_to_gdr(struct crypto4xx_device *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->core_dev->lock, flags);\n\tif (dev->gdr_tail == dev->gdr_head) {\n\t\tspin_unlock_irqrestore(&dev->core_dev->lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (dev->gdr_tail != PPC4XX_LAST_GD)\n\t\tdev->gdr_tail++;\n\telse\n\t\tdev->gdr_tail = 0;\n\n\tspin_unlock_irqrestore(&dev->core_dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic inline struct ce_gd *crypto4xx_get_gdp(struct crypto4xx_device *dev,\n\t\t\t\t\t      dma_addr_t *gd_dma, u32 idx)\n{\n\t*gd_dma = dev->gdr_pa + sizeof(struct ce_gd) * idx;\n\n\treturn &dev->gdr[idx];\n}\n\n \nstatic u32 crypto4xx_build_sdr(struct crypto4xx_device *dev)\n{\n\tint i;\n\n\tdev->scatter_buffer_va =\n\t\tdma_alloc_coherent(dev->core_dev->device,\n\t\t\tPPC4XX_SD_BUFFER_SIZE * PPC4XX_NUM_SD,\n\t\t\t&dev->scatter_buffer_pa, GFP_KERNEL);\n\tif (!dev->scatter_buffer_va)\n\t\treturn -ENOMEM;\n\n\t \n\tdev->sdr = dma_alloc_coherent(dev->core_dev->device,\n\t\t\t\t      sizeof(struct ce_sd) * PPC4XX_NUM_SD,\n\t\t\t\t      &dev->sdr_pa, GFP_KERNEL);\n\tif (!dev->sdr)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < PPC4XX_NUM_SD; i++) {\n\t\tdev->sdr[i].ptr = dev->scatter_buffer_pa +\n\t\t\t\t  PPC4XX_SD_BUFFER_SIZE * i;\n\t}\n\n\treturn 0;\n}\n\nstatic void crypto4xx_destroy_sdr(struct crypto4xx_device *dev)\n{\n\tif (dev->sdr)\n\t\tdma_free_coherent(dev->core_dev->device,\n\t\t\t\t  sizeof(struct ce_sd) * PPC4XX_NUM_SD,\n\t\t\t\t  dev->sdr, dev->sdr_pa);\n\n\tif (dev->scatter_buffer_va)\n\t\tdma_free_coherent(dev->core_dev->device,\n\t\t\t\t  PPC4XX_SD_BUFFER_SIZE * PPC4XX_NUM_SD,\n\t\t\t\t  dev->scatter_buffer_va,\n\t\t\t\t  dev->scatter_buffer_pa);\n}\n\n \nstatic u32 crypto4xx_get_n_sd(struct crypto4xx_device *dev, int n)\n{\n\tu32 retval;\n\tu32 tmp;\n\n\tif (n >= PPC4XX_NUM_SD)\n\t\treturn ERING_WAS_FULL;\n\n\tretval = dev->sdr_head;\n\ttmp = (dev->sdr_head + n) % PPC4XX_NUM_SD;\n\tif (dev->sdr_head > dev->gdr_tail) {\n\t\tif (tmp < dev->sdr_head && tmp >= dev->sdr_tail)\n\t\t\treturn ERING_WAS_FULL;\n\t} else if (dev->sdr_head < dev->sdr_tail) {\n\t\tif (tmp < dev->sdr_head || tmp >= dev->sdr_tail)\n\t\t\treturn ERING_WAS_FULL;\n\t}  \n\tdev->sdr_head = tmp;\n\n\treturn retval;\n}\n\nstatic u32 crypto4xx_put_sd_to_sdr(struct crypto4xx_device *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->core_dev->lock, flags);\n\tif (dev->sdr_tail == dev->sdr_head) {\n\t\tspin_unlock_irqrestore(&dev->core_dev->lock, flags);\n\t\treturn 0;\n\t}\n\tif (dev->sdr_tail != PPC4XX_LAST_SD)\n\t\tdev->sdr_tail++;\n\telse\n\t\tdev->sdr_tail = 0;\n\tspin_unlock_irqrestore(&dev->core_dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic inline struct ce_sd *crypto4xx_get_sdp(struct crypto4xx_device *dev,\n\t\t\t\t\t      dma_addr_t *sd_dma, u32 idx)\n{\n\t*sd_dma = dev->sdr_pa + sizeof(struct ce_sd) * idx;\n\n\treturn &dev->sdr[idx];\n}\n\nstatic void crypto4xx_copy_pkt_to_dst(struct crypto4xx_device *dev,\n\t\t\t\t      struct ce_pd *pd,\n\t\t\t\t      struct pd_uinfo *pd_uinfo,\n\t\t\t\t      u32 nbytes,\n\t\t\t\t      struct scatterlist *dst)\n{\n\tunsigned int first_sd = pd_uinfo->first_sd;\n\tunsigned int last_sd;\n\tunsigned int overflow = 0;\n\tunsigned int to_copy;\n\tunsigned int dst_start = 0;\n\n\t \n\n\tlast_sd = (first_sd + pd_uinfo->num_sd);\n\tif (last_sd > PPC4XX_LAST_SD) {\n\t\tlast_sd = PPC4XX_LAST_SD;\n\t\toverflow = last_sd % PPC4XX_NUM_SD;\n\t}\n\n\twhile (nbytes) {\n\t\tvoid *buf = dev->scatter_buffer_va +\n\t\t\tfirst_sd * PPC4XX_SD_BUFFER_SIZE;\n\n\t\tto_copy = min(nbytes, PPC4XX_SD_BUFFER_SIZE *\n\t\t\t\t      (1 + last_sd - first_sd));\n\t\tscatterwalk_map_and_copy(buf, dst, dst_start, to_copy, 1);\n\t\tnbytes -= to_copy;\n\n\t\tif (overflow) {\n\t\t\tfirst_sd = 0;\n\t\t\tlast_sd = overflow;\n\t\t\tdst_start += to_copy;\n\t\t\toverflow = 0;\n\t\t}\n\t}\n}\n\nstatic void crypto4xx_copy_digest_to_dst(void *dst,\n\t\t\t\t\tstruct pd_uinfo *pd_uinfo,\n\t\t\t\t\tstruct crypto4xx_ctx *ctx)\n{\n\tstruct dynamic_sa_ctl *sa = (struct dynamic_sa_ctl *) ctx->sa_in;\n\n\tif (sa->sa_command_0.bf.hash_alg == SA_HASH_ALG_SHA1) {\n\t\tmemcpy(dst, pd_uinfo->sr_va->save_digest,\n\t\t       SA_HASH_ALG_SHA1_DIGEST_SIZE);\n\t}\n}\n\nstatic void crypto4xx_ret_sg_desc(struct crypto4xx_device *dev,\n\t\t\t\t  struct pd_uinfo *pd_uinfo)\n{\n\tint i;\n\tif (pd_uinfo->num_gd) {\n\t\tfor (i = 0; i < pd_uinfo->num_gd; i++)\n\t\t\tcrypto4xx_put_gd_to_gdr(dev);\n\t\tpd_uinfo->first_gd = 0xffffffff;\n\t\tpd_uinfo->num_gd = 0;\n\t}\n\tif (pd_uinfo->num_sd) {\n\t\tfor (i = 0; i < pd_uinfo->num_sd; i++)\n\t\t\tcrypto4xx_put_sd_to_sdr(dev);\n\n\t\tpd_uinfo->first_sd = 0xffffffff;\n\t\tpd_uinfo->num_sd = 0;\n\t}\n}\n\nstatic void crypto4xx_cipher_done(struct crypto4xx_device *dev,\n\t\t\t\t     struct pd_uinfo *pd_uinfo,\n\t\t\t\t     struct ce_pd *pd)\n{\n\tstruct skcipher_request *req;\n\tstruct scatterlist *dst;\n\n\treq = skcipher_request_cast(pd_uinfo->async_req);\n\n\tif (pd_uinfo->sa_va->sa_command_0.bf.scatter) {\n\t\tcrypto4xx_copy_pkt_to_dst(dev, pd, pd_uinfo,\n\t\t\t\t\t  req->cryptlen, req->dst);\n\t} else {\n\t\tdst = pd_uinfo->dest_va;\n\t\tdma_unmap_page(dev->core_dev->device, pd->dest, dst->length,\n\t\t\t       DMA_FROM_DEVICE);\n\t}\n\n\tif (pd_uinfo->sa_va->sa_command_0.bf.save_iv == SA_SAVE_IV) {\n\t\tstruct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);\n\n\t\tcrypto4xx_memcpy_from_le32((u32 *)req->iv,\n\t\t\tpd_uinfo->sr_va->save_iv,\n\t\t\tcrypto_skcipher_ivsize(skcipher));\n\t}\n\n\tcrypto4xx_ret_sg_desc(dev, pd_uinfo);\n\n\tif (pd_uinfo->state & PD_ENTRY_BUSY)\n\t\tskcipher_request_complete(req, -EINPROGRESS);\n\tskcipher_request_complete(req, 0);\n}\n\nstatic void crypto4xx_ahash_done(struct crypto4xx_device *dev,\n\t\t\t\tstruct pd_uinfo *pd_uinfo)\n{\n\tstruct crypto4xx_ctx *ctx;\n\tstruct ahash_request *ahash_req;\n\n\tahash_req = ahash_request_cast(pd_uinfo->async_req);\n\tctx = crypto_ahash_ctx(crypto_ahash_reqtfm(ahash_req));\n\n\tcrypto4xx_copy_digest_to_dst(ahash_req->result, pd_uinfo, ctx);\n\tcrypto4xx_ret_sg_desc(dev, pd_uinfo);\n\n\tif (pd_uinfo->state & PD_ENTRY_BUSY)\n\t\tahash_request_complete(ahash_req, -EINPROGRESS);\n\tahash_request_complete(ahash_req, 0);\n}\n\nstatic void crypto4xx_aead_done(struct crypto4xx_device *dev,\n\t\t\t\tstruct pd_uinfo *pd_uinfo,\n\t\t\t\tstruct ce_pd *pd)\n{\n\tstruct aead_request *aead_req = container_of(pd_uinfo->async_req,\n\t\tstruct aead_request, base);\n\tstruct scatterlist *dst = pd_uinfo->dest_va;\n\tsize_t cp_len = crypto_aead_authsize(\n\t\tcrypto_aead_reqtfm(aead_req));\n\tu32 icv[AES_BLOCK_SIZE];\n\tint err = 0;\n\n\tif (pd_uinfo->sa_va->sa_command_0.bf.scatter) {\n\t\tcrypto4xx_copy_pkt_to_dst(dev, pd, pd_uinfo,\n\t\t\t\t\t  pd->pd_ctl_len.bf.pkt_len,\n\t\t\t\t\t  dst);\n\t} else {\n\t\tdma_unmap_page(dev->core_dev->device, pd->dest, dst->length,\n\t\t\t\tDMA_FROM_DEVICE);\n\t}\n\n\tif (pd_uinfo->sa_va->sa_command_0.bf.dir == DIR_OUTBOUND) {\n\t\t \n\t\tcrypto4xx_memcpy_from_le32(icv, pd_uinfo->sr_va->save_digest,\n\t\t\t\t\t   sizeof(icv));\n\n\t\tscatterwalk_map_and_copy(icv, dst, aead_req->cryptlen,\n\t\t\t\t\t cp_len, 1);\n\t} else {\n\t\t \n\t\tscatterwalk_map_and_copy(icv, aead_req->src,\n\t\t\taead_req->assoclen + aead_req->cryptlen -\n\t\t\tcp_len, cp_len, 0);\n\n\t\tcrypto4xx_memcpy_from_le32(icv, icv, sizeof(icv));\n\n\t\tif (crypto_memneq(icv, pd_uinfo->sr_va->save_digest, cp_len))\n\t\t\terr = -EBADMSG;\n\t}\n\n\tcrypto4xx_ret_sg_desc(dev, pd_uinfo);\n\n\tif (pd->pd_ctl.bf.status & 0xff) {\n\t\tif (!__ratelimit(&dev->aead_ratelimit)) {\n\t\t\tif (pd->pd_ctl.bf.status & 2)\n\t\t\t\tpr_err(\"pad fail error\\n\");\n\t\t\tif (pd->pd_ctl.bf.status & 4)\n\t\t\t\tpr_err(\"seqnum fail\\n\");\n\t\t\tif (pd->pd_ctl.bf.status & 8)\n\t\t\t\tpr_err(\"error _notify\\n\");\n\t\t\tpr_err(\"aead return err status = 0x%02x\\n\",\n\t\t\t\tpd->pd_ctl.bf.status & 0xff);\n\t\t\tpr_err(\"pd pad_ctl = 0x%08x\\n\",\n\t\t\t\tpd->pd_ctl.bf.pd_pad_ctl);\n\t\t}\n\t\terr = -EINVAL;\n\t}\n\n\tif (pd_uinfo->state & PD_ENTRY_BUSY)\n\t\taead_request_complete(aead_req, -EINPROGRESS);\n\n\taead_request_complete(aead_req, err);\n}\n\nstatic void crypto4xx_pd_done(struct crypto4xx_device *dev, u32 idx)\n{\n\tstruct ce_pd *pd = &dev->pdr[idx];\n\tstruct pd_uinfo *pd_uinfo = &dev->pdr_uinfo[idx];\n\n\tswitch (crypto_tfm_alg_type(pd_uinfo->async_req->tfm)) {\n\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\tcrypto4xx_cipher_done(dev, pd_uinfo, pd);\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AEAD:\n\t\tcrypto4xx_aead_done(dev, pd_uinfo, pd);\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\tcrypto4xx_ahash_done(dev, pd_uinfo);\n\t\tbreak;\n\t}\n}\n\nstatic void crypto4xx_stop_all(struct crypto4xx_core_device *core_dev)\n{\n\tcrypto4xx_destroy_pdr(core_dev->dev);\n\tcrypto4xx_destroy_gdr(core_dev->dev);\n\tcrypto4xx_destroy_sdr(core_dev->dev);\n\tiounmap(core_dev->dev->ce_base);\n\tkfree(core_dev->dev);\n\tkfree(core_dev);\n}\n\nstatic u32 get_next_gd(u32 current)\n{\n\tif (current != PPC4XX_LAST_GD)\n\t\treturn current + 1;\n\telse\n\t\treturn 0;\n}\n\nstatic u32 get_next_sd(u32 current)\n{\n\tif (current != PPC4XX_LAST_SD)\n\t\treturn current + 1;\n\telse\n\t\treturn 0;\n}\n\nint crypto4xx_build_pd(struct crypto_async_request *req,\n\t\t       struct crypto4xx_ctx *ctx,\n\t\t       struct scatterlist *src,\n\t\t       struct scatterlist *dst,\n\t\t       const unsigned int datalen,\n\t\t       const __le32 *iv, const u32 iv_len,\n\t\t       const struct dynamic_sa_ctl *req_sa,\n\t\t       const unsigned int sa_len,\n\t\t       const unsigned int assoclen,\n\t\t       struct scatterlist *_dst)\n{\n\tstruct crypto4xx_device *dev = ctx->dev;\n\tstruct dynamic_sa_ctl *sa;\n\tstruct ce_gd *gd;\n\tstruct ce_pd *pd;\n\tu32 num_gd, num_sd;\n\tu32 fst_gd = 0xffffffff;\n\tu32 fst_sd = 0xffffffff;\n\tu32 pd_entry;\n\tunsigned long flags;\n\tstruct pd_uinfo *pd_uinfo;\n\tunsigned int nbytes = datalen;\n\tsize_t offset_to_sr_ptr;\n\tu32 gd_idx = 0;\n\tint tmp;\n\tbool is_busy, force_sd;\n\n\t \n\tforce_sd = (req_sa->sa_command_1.bf.crypto_mode9_8 == CRYPTO_MODE_CFB\n\t\t|| req_sa->sa_command_1.bf.crypto_mode9_8 == CRYPTO_MODE_OFB)\n\t\t&& (datalen % AES_BLOCK_SIZE);\n\n\t \n\ttmp = sg_nents_for_len(src, assoclen + datalen);\n\tif (tmp < 0) {\n\t\tdev_err(dev->core_dev->device, \"Invalid number of src SG.\\n\");\n\t\treturn tmp;\n\t}\n\tif (tmp == 1)\n\t\ttmp = 0;\n\tnum_gd = tmp;\n\n\tif (assoclen) {\n\t\tnbytes += assoclen;\n\t\tdst = scatterwalk_ffwd(_dst, dst, assoclen);\n\t}\n\n\t \n\tif (sg_is_last(dst) && force_sd == false) {\n\t\tnum_sd = 0;\n\t} else {\n\t\tif (datalen > PPC4XX_SD_BUFFER_SIZE) {\n\t\t\tnum_sd = datalen / PPC4XX_SD_BUFFER_SIZE;\n\t\t\tif (datalen % PPC4XX_SD_BUFFER_SIZE)\n\t\t\t\tnum_sd++;\n\t\t} else {\n\t\t\tnum_sd = 1;\n\t\t}\n\t}\n\n\t \n\tspin_lock_irqsave(&dev->core_dev->lock, flags);\n\t \n\tif (req->flags & CRYPTO_TFM_REQ_MAY_BACKLOG) {\n\t\tis_busy = ((dev->pdr_head - dev->pdr_tail) % PPC4XX_NUM_PD) >=\n\t\t\t((PPC4XX_NUM_PD * 13) / 16);\n\t} else {\n\t\t \n\t\tis_busy = ((dev->pdr_head - dev->pdr_tail) % PPC4XX_NUM_PD) >=\n\t\t\t((PPC4XX_NUM_PD * 15) / 16);\n\n\t\tif (is_busy) {\n\t\t\tspin_unlock_irqrestore(&dev->core_dev->lock, flags);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (num_gd) {\n\t\tfst_gd = crypto4xx_get_n_gd(dev, num_gd);\n\t\tif (fst_gd == ERING_WAS_FULL) {\n\t\t\tspin_unlock_irqrestore(&dev->core_dev->lock, flags);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tif (num_sd) {\n\t\tfst_sd = crypto4xx_get_n_sd(dev, num_sd);\n\t\tif (fst_sd == ERING_WAS_FULL) {\n\t\t\tif (num_gd)\n\t\t\t\tdev->gdr_head = fst_gd;\n\t\t\tspin_unlock_irqrestore(&dev->core_dev->lock, flags);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tpd_entry = crypto4xx_get_pd_from_pdr_nolock(dev);\n\tif (pd_entry == ERING_WAS_FULL) {\n\t\tif (num_gd)\n\t\t\tdev->gdr_head = fst_gd;\n\t\tif (num_sd)\n\t\t\tdev->sdr_head = fst_sd;\n\t\tspin_unlock_irqrestore(&dev->core_dev->lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\tspin_unlock_irqrestore(&dev->core_dev->lock, flags);\n\n\tpd = &dev->pdr[pd_entry];\n\tpd->sa_len = sa_len;\n\n\tpd_uinfo = &dev->pdr_uinfo[pd_entry];\n\tpd_uinfo->num_gd = num_gd;\n\tpd_uinfo->num_sd = num_sd;\n\tpd_uinfo->dest_va = dst;\n\tpd_uinfo->async_req = req;\n\n\tif (iv_len)\n\t\tmemcpy(pd_uinfo->sr_va->save_iv, iv, iv_len);\n\n\tsa = pd_uinfo->sa_va;\n\tmemcpy(sa, req_sa, sa_len * 4);\n\n\tsa->sa_command_1.bf.hash_crypto_offset = (assoclen >> 2);\n\toffset_to_sr_ptr = get_dynamic_sa_offset_state_ptr_field(sa);\n\t*(u32 *)((unsigned long)sa + offset_to_sr_ptr) = pd_uinfo->sr_pa;\n\n\tif (num_gd) {\n\t\tdma_addr_t gd_dma;\n\t\tstruct scatterlist *sg;\n\n\t\t \n\t\tgd_idx = fst_gd;\n\t\tpd_uinfo->first_gd = fst_gd;\n\t\tgd = crypto4xx_get_gdp(dev, &gd_dma, gd_idx);\n\t\tpd->src = gd_dma;\n\t\t \n\t\tsa->sa_command_0.bf.gather = 1;\n\t\t \n\n\t\tsg = src;\n\t\twhile (nbytes) {\n\t\t\tsize_t len;\n\n\t\t\tlen = min(sg->length, nbytes);\n\t\t\tgd->ptr = dma_map_page(dev->core_dev->device,\n\t\t\t\tsg_page(sg), sg->offset, len, DMA_TO_DEVICE);\n\t\t\tgd->ctl_len.len = len;\n\t\t\tgd->ctl_len.done = 0;\n\t\t\tgd->ctl_len.ready = 1;\n\t\t\tif (len >= nbytes)\n\t\t\t\tbreak;\n\n\t\t\tnbytes -= sg->length;\n\t\t\tgd_idx = get_next_gd(gd_idx);\n\t\t\tgd = crypto4xx_get_gdp(dev, &gd_dma, gd_idx);\n\t\t\tsg = sg_next(sg);\n\t\t}\n\t} else {\n\t\tpd->src = (u32)dma_map_page(dev->core_dev->device, sg_page(src),\n\t\t\t\tsrc->offset, min(nbytes, src->length),\n\t\t\t\tDMA_TO_DEVICE);\n\t\t \n\t\tsa->sa_command_0.bf.gather = 0;\n\t\t \n\t\tpd_uinfo->first_gd = 0xffffffff;\n\t}\n\tif (!num_sd) {\n\t\t \n\t\tpd_uinfo->first_sd = 0xffffffff;\n\t\tsa->sa_command_0.bf.scatter = 0;\n\t\tpd->dest = (u32)dma_map_page(dev->core_dev->device,\n\t\t\t\t\t     sg_page(dst), dst->offset,\n\t\t\t\t\t     min(datalen, dst->length),\n\t\t\t\t\t     DMA_TO_DEVICE);\n\t} else {\n\t\tdma_addr_t sd_dma;\n\t\tstruct ce_sd *sd = NULL;\n\n\t\tu32 sd_idx = fst_sd;\n\t\tnbytes = datalen;\n\t\tsa->sa_command_0.bf.scatter = 1;\n\t\tpd_uinfo->first_sd = fst_sd;\n\t\tsd = crypto4xx_get_sdp(dev, &sd_dma, sd_idx);\n\t\tpd->dest = sd_dma;\n\t\t \n\t\tsd->ctl.done = 0;\n\t\tsd->ctl.rdy = 1;\n\t\t \n\t\tif (nbytes >= PPC4XX_SD_BUFFER_SIZE)\n\t\t\tnbytes -= PPC4XX_SD_BUFFER_SIZE;\n\t\telse\n\t\t\tnbytes = 0;\n\t\twhile (nbytes) {\n\t\t\tsd_idx = get_next_sd(sd_idx);\n\t\t\tsd = crypto4xx_get_sdp(dev, &sd_dma, sd_idx);\n\t\t\t \n\t\t\tsd->ctl.done = 0;\n\t\t\tsd->ctl.rdy = 1;\n\t\t\tif (nbytes >= PPC4XX_SD_BUFFER_SIZE) {\n\t\t\t\tnbytes -= PPC4XX_SD_BUFFER_SIZE;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tnbytes = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpd->pd_ctl.w = PD_CTL_HOST_READY |\n\t\t((crypto_tfm_alg_type(req->tfm) == CRYPTO_ALG_TYPE_AHASH) ||\n\t\t (crypto_tfm_alg_type(req->tfm) == CRYPTO_ALG_TYPE_AEAD) ?\n\t\t\tPD_CTL_HASH_FINAL : 0);\n\tpd->pd_ctl_len.w = 0x00400000 | (assoclen + datalen);\n\tpd_uinfo->state = PD_ENTRY_INUSE | (is_busy ? PD_ENTRY_BUSY : 0);\n\n\twmb();\n\t \n\twritel(0, dev->ce_base + CRYPTO4XX_INT_DESCR_RD);\n\twritel(1, dev->ce_base + CRYPTO4XX_INT_DESCR_RD);\n\treturn is_busy ? -EBUSY : -EINPROGRESS;\n}\n\n \nstatic void crypto4xx_ctx_init(struct crypto4xx_alg *amcc_alg,\n\t\t\t       struct crypto4xx_ctx *ctx)\n{\n\tctx->dev = amcc_alg->dev;\n\tctx->sa_in = NULL;\n\tctx->sa_out = NULL;\n\tctx->sa_len = 0;\n}\n\nstatic int crypto4xx_sk_init(struct crypto_skcipher *sk)\n{\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(sk);\n\tstruct crypto4xx_alg *amcc_alg;\n\tstruct crypto4xx_ctx *ctx =  crypto_skcipher_ctx(sk);\n\n\tif (alg->base.cra_flags & CRYPTO_ALG_NEED_FALLBACK) {\n\t\tctx->sw_cipher.cipher =\n\t\t\tcrypto_alloc_sync_skcipher(alg->base.cra_name, 0,\n\t\t\t\t\t      CRYPTO_ALG_NEED_FALLBACK);\n\t\tif (IS_ERR(ctx->sw_cipher.cipher))\n\t\t\treturn PTR_ERR(ctx->sw_cipher.cipher);\n\t}\n\n\tamcc_alg = container_of(alg, struct crypto4xx_alg, alg.u.cipher);\n\tcrypto4xx_ctx_init(amcc_alg, ctx);\n\treturn 0;\n}\n\nstatic void crypto4xx_common_exit(struct crypto4xx_ctx *ctx)\n{\n\tcrypto4xx_free_sa(ctx);\n}\n\nstatic void crypto4xx_sk_exit(struct crypto_skcipher *sk)\n{\n\tstruct crypto4xx_ctx *ctx =  crypto_skcipher_ctx(sk);\n\n\tcrypto4xx_common_exit(ctx);\n\tif (ctx->sw_cipher.cipher)\n\t\tcrypto_free_sync_skcipher(ctx->sw_cipher.cipher);\n}\n\nstatic int crypto4xx_aead_init(struct crypto_aead *tfm)\n{\n\tstruct aead_alg *alg = crypto_aead_alg(tfm);\n\tstruct crypto4xx_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto4xx_alg *amcc_alg;\n\n\tctx->sw_cipher.aead = crypto_alloc_aead(alg->base.cra_name, 0,\n\t\t\t\t\t\tCRYPTO_ALG_NEED_FALLBACK |\n\t\t\t\t\t\tCRYPTO_ALG_ASYNC);\n\tif (IS_ERR(ctx->sw_cipher.aead))\n\t\treturn PTR_ERR(ctx->sw_cipher.aead);\n\n\tamcc_alg = container_of(alg, struct crypto4xx_alg, alg.u.aead);\n\tcrypto4xx_ctx_init(amcc_alg, ctx);\n\tcrypto_aead_set_reqsize(tfm, max(sizeof(struct aead_request) + 32 +\n\t\t\t\tcrypto_aead_reqsize(ctx->sw_cipher.aead),\n\t\t\t\tsizeof(struct crypto4xx_aead_reqctx)));\n\treturn 0;\n}\n\nstatic void crypto4xx_aead_exit(struct crypto_aead *tfm)\n{\n\tstruct crypto4xx_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tcrypto4xx_common_exit(ctx);\n\tcrypto_free_aead(ctx->sw_cipher.aead);\n}\n\nstatic int crypto4xx_register_alg(struct crypto4xx_device *sec_dev,\n\t\t\t\t  struct crypto4xx_alg_common *crypto_alg,\n\t\t\t\t  int array_size)\n{\n\tstruct crypto4xx_alg *alg;\n\tint i;\n\tint rc = 0;\n\n\tfor (i = 0; i < array_size; i++) {\n\t\talg = kzalloc(sizeof(struct crypto4xx_alg), GFP_KERNEL);\n\t\tif (!alg)\n\t\t\treturn -ENOMEM;\n\n\t\talg->alg = crypto_alg[i];\n\t\talg->dev = sec_dev;\n\n\t\tswitch (alg->alg.type) {\n\t\tcase CRYPTO_ALG_TYPE_AEAD:\n\t\t\trc = crypto_register_aead(&alg->alg.u.aead);\n\t\t\tbreak;\n\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\trc = crypto_register_ahash(&alg->alg.u.hash);\n\t\t\tbreak;\n\n\t\tcase CRYPTO_ALG_TYPE_RNG:\n\t\t\trc = crypto_register_rng(&alg->alg.u.rng);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trc = crypto_register_skcipher(&alg->alg.u.cipher);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc)\n\t\t\tkfree(alg);\n\t\telse\n\t\t\tlist_add_tail(&alg->entry, &sec_dev->alg_list);\n\t}\n\n\treturn 0;\n}\n\nstatic void crypto4xx_unregister_alg(struct crypto4xx_device *sec_dev)\n{\n\tstruct crypto4xx_alg *alg, *tmp;\n\n\tlist_for_each_entry_safe(alg, tmp, &sec_dev->alg_list, entry) {\n\t\tlist_del(&alg->entry);\n\t\tswitch (alg->alg.type) {\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\tcrypto_unregister_ahash(&alg->alg.u.hash);\n\t\t\tbreak;\n\n\t\tcase CRYPTO_ALG_TYPE_AEAD:\n\t\t\tcrypto_unregister_aead(&alg->alg.u.aead);\n\t\t\tbreak;\n\n\t\tcase CRYPTO_ALG_TYPE_RNG:\n\t\t\tcrypto_unregister_rng(&alg->alg.u.rng);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcrypto_unregister_skcipher(&alg->alg.u.cipher);\n\t\t}\n\t\tkfree(alg);\n\t}\n}\n\nstatic void crypto4xx_bh_tasklet_cb(unsigned long data)\n{\n\tstruct device *dev = (struct device *)data;\n\tstruct crypto4xx_core_device *core_dev = dev_get_drvdata(dev);\n\tstruct pd_uinfo *pd_uinfo;\n\tstruct ce_pd *pd;\n\tu32 tail = core_dev->dev->pdr_tail;\n\tu32 head = core_dev->dev->pdr_head;\n\n\tdo {\n\t\tpd_uinfo = &core_dev->dev->pdr_uinfo[tail];\n\t\tpd = &core_dev->dev->pdr[tail];\n\t\tif ((pd_uinfo->state & PD_ENTRY_INUSE) &&\n\t\t     ((READ_ONCE(pd->pd_ctl.w) &\n\t\t       (PD_CTL_PE_DONE | PD_CTL_HOST_READY)) ==\n\t\t       PD_CTL_PE_DONE)) {\n\t\t\tcrypto4xx_pd_done(core_dev->dev, tail);\n\t\t\ttail = crypto4xx_put_pd_to_pdr(core_dev->dev, tail);\n\t\t} else {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t} while (head != tail);\n}\n\n \nstatic inline irqreturn_t crypto4xx_interrupt_handler(int irq, void *data,\n\t\t\t\t\t\t      u32 clr_val)\n{\n\tstruct device *dev = data;\n\tstruct crypto4xx_core_device *core_dev = dev_get_drvdata(dev);\n\n\twritel(clr_val, core_dev->dev->ce_base + CRYPTO4XX_INT_CLR);\n\ttasklet_schedule(&core_dev->tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t crypto4xx_ce_interrupt_handler(int irq, void *data)\n{\n\treturn crypto4xx_interrupt_handler(irq, data, PPC4XX_INTERRUPT_CLR);\n}\n\nstatic irqreturn_t crypto4xx_ce_interrupt_handler_revb(int irq, void *data)\n{\n\treturn crypto4xx_interrupt_handler(irq, data, PPC4XX_INTERRUPT_CLR |\n\t\tPPC4XX_TMO_ERR_INT);\n}\n\nstatic int ppc4xx_prng_data_read(struct crypto4xx_device *dev,\n\t\t\t\t u8 *data, unsigned int max)\n{\n\tunsigned int i, curr = 0;\n\tu32 val[2];\n\n\tdo {\n\t\t \n\t\twritel(PPC4XX_PRNG_CTRL_AUTO_EN,\n\t\t       dev->ce_base + CRYPTO4XX_PRNG_CTRL);\n\n\t\tfor (i = 0; i < 1024; i++) {\n\t\t\t \n\t\t\tif ((readl(dev->ce_base + CRYPTO4XX_PRNG_STAT) &\n\t\t\t     CRYPTO4XX_PRNG_STAT_BUSY))\n\t\t\t\tcontinue;\n\n\t\t\tval[0] = readl_be(dev->ce_base + CRYPTO4XX_PRNG_RES_0);\n\t\t\tval[1] = readl_be(dev->ce_base + CRYPTO4XX_PRNG_RES_1);\n\t\t\tbreak;\n\t\t}\n\t\tif (i == 1024)\n\t\t\treturn -ETIMEDOUT;\n\n\t\tif ((max - curr) >= 8) {\n\t\t\tmemcpy(data, &val, 8);\n\t\t\tdata += 8;\n\t\t\tcurr += 8;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(data, &val, max - curr);\n\t\t\tbreak;\n\t\t}\n\t} while (curr < max);\n\n\treturn curr;\n}\n\nstatic int crypto4xx_prng_generate(struct crypto_rng *tfm,\n\t\t\t\t   const u8 *src, unsigned int slen,\n\t\t\t\t   u8 *dstn, unsigned int dlen)\n{\n\tstruct rng_alg *alg = crypto_rng_alg(tfm);\n\tstruct crypto4xx_alg *amcc_alg;\n\tstruct crypto4xx_device *dev;\n\tint ret;\n\n\tamcc_alg = container_of(alg, struct crypto4xx_alg, alg.u.rng);\n\tdev = amcc_alg->dev;\n\n\tmutex_lock(&dev->core_dev->rng_lock);\n\tret = ppc4xx_prng_data_read(dev, dstn, dlen);\n\tmutex_unlock(&dev->core_dev->rng_lock);\n\treturn ret;\n}\n\n\nstatic int crypto4xx_prng_seed(struct crypto_rng *tfm, const u8 *seed,\n\t\t\tunsigned int slen)\n{\n\treturn 0;\n}\n\n \nstatic struct crypto4xx_alg_common crypto4xx_alg[] = {\n\t \n\t{ .type = CRYPTO_ALG_TYPE_SKCIPHER, .u.cipher = {\n\t\t.base = {\n\t\t\t.cra_name = \"cbc(aes)\",\n\t\t\t.cra_driver_name = \"cbc-aes-ppc4xx\",\n\t\t\t.cra_priority = CRYPTO4XX_CRYPTO_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct crypto4xx_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t.ivsize\t= AES_IV_SIZE,\n\t\t.setkey = crypto4xx_setkey_aes_cbc,\n\t\t.encrypt = crypto4xx_encrypt_iv_block,\n\t\t.decrypt = crypto4xx_decrypt_iv_block,\n\t\t.init = crypto4xx_sk_init,\n\t\t.exit = crypto4xx_sk_exit,\n\t} },\n\t{ .type = CRYPTO_ALG_TYPE_SKCIPHER, .u.cipher = {\n\t\t.base = {\n\t\t\t.cra_name = \"cfb(aes)\",\n\t\t\t.cra_driver_name = \"cfb-aes-ppc4xx\",\n\t\t\t.cra_priority = CRYPTO4XX_CRYPTO_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct crypto4xx_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t.ivsize\t= AES_IV_SIZE,\n\t\t.setkey\t= crypto4xx_setkey_aes_cfb,\n\t\t.encrypt = crypto4xx_encrypt_iv_stream,\n\t\t.decrypt = crypto4xx_decrypt_iv_stream,\n\t\t.init = crypto4xx_sk_init,\n\t\t.exit = crypto4xx_sk_exit,\n\t} },\n\t{ .type = CRYPTO_ALG_TYPE_SKCIPHER, .u.cipher = {\n\t\t.base = {\n\t\t\t.cra_name = \"ctr(aes)\",\n\t\t\t.cra_driver_name = \"ctr-aes-ppc4xx\",\n\t\t\t.cra_priority = CRYPTO4XX_CRYPTO_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_NEED_FALLBACK |\n\t\t\t\tCRYPTO_ALG_ASYNC |\n\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct crypto4xx_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t.ivsize\t= AES_IV_SIZE,\n\t\t.setkey\t= crypto4xx_setkey_aes_ctr,\n\t\t.encrypt = crypto4xx_encrypt_ctr,\n\t\t.decrypt = crypto4xx_decrypt_ctr,\n\t\t.init = crypto4xx_sk_init,\n\t\t.exit = crypto4xx_sk_exit,\n\t} },\n\t{ .type = CRYPTO_ALG_TYPE_SKCIPHER, .u.cipher = {\n\t\t.base = {\n\t\t\t.cra_name = \"rfc3686(ctr(aes))\",\n\t\t\t.cra_driver_name = \"rfc3686-ctr-aes-ppc4xx\",\n\t\t\t.cra_priority = CRYPTO4XX_CRYPTO_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct crypto4xx_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t\t.min_keysize = AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,\n\t\t.max_keysize = AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,\n\t\t.ivsize\t= CTR_RFC3686_IV_SIZE,\n\t\t.setkey = crypto4xx_setkey_rfc3686,\n\t\t.encrypt = crypto4xx_rfc3686_encrypt,\n\t\t.decrypt = crypto4xx_rfc3686_decrypt,\n\t\t.init = crypto4xx_sk_init,\n\t\t.exit = crypto4xx_sk_exit,\n\t} },\n\t{ .type = CRYPTO_ALG_TYPE_SKCIPHER, .u.cipher = {\n\t\t.base = {\n\t\t\t.cra_name = \"ecb(aes)\",\n\t\t\t.cra_driver_name = \"ecb-aes-ppc4xx\",\n\t\t\t.cra_priority = CRYPTO4XX_CRYPTO_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.cra_ctxsize = sizeof(struct crypto4xx_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t.setkey\t= crypto4xx_setkey_aes_ecb,\n\t\t.encrypt = crypto4xx_encrypt_noiv_block,\n\t\t.decrypt = crypto4xx_decrypt_noiv_block,\n\t\t.init = crypto4xx_sk_init,\n\t\t.exit = crypto4xx_sk_exit,\n\t} },\n\t{ .type = CRYPTO_ALG_TYPE_SKCIPHER, .u.cipher = {\n\t\t.base = {\n\t\t\t.cra_name = \"ofb(aes)\",\n\t\t\t.cra_driver_name = \"ofb-aes-ppc4xx\",\n\t\t\t.cra_priority = CRYPTO4XX_CRYPTO_PRIORITY,\n\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\tCRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize = 1,\n\t\t\t.cra_ctxsize = sizeof(struct crypto4xx_ctx),\n\t\t\t.cra_module = THIS_MODULE,\n\t\t},\n\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t.ivsize\t= AES_IV_SIZE,\n\t\t.setkey\t= crypto4xx_setkey_aes_ofb,\n\t\t.encrypt = crypto4xx_encrypt_iv_stream,\n\t\t.decrypt = crypto4xx_decrypt_iv_stream,\n\t\t.init = crypto4xx_sk_init,\n\t\t.exit = crypto4xx_sk_exit,\n\t} },\n\n\t \n\t{ .type = CRYPTO_ALG_TYPE_AEAD, .u.aead = {\n\t\t.setkey\t\t= crypto4xx_setkey_aes_ccm,\n\t\t.setauthsize\t= crypto4xx_setauthsize_aead,\n\t\t.encrypt\t= crypto4xx_encrypt_aes_ccm,\n\t\t.decrypt\t= crypto4xx_decrypt_aes_ccm,\n\t\t.init\t\t= crypto4xx_aead_init,\n\t\t.exit\t\t= crypto4xx_aead_exit,\n\t\t.ivsize\t\t= AES_BLOCK_SIZE,\n\t\t.maxauthsize    = 16,\n\t\t.base = {\n\t\t\t.cra_name\t= \"ccm(aes)\",\n\t\t\t.cra_driver_name = \"ccm-aes-ppc4xx\",\n\t\t\t.cra_priority\t= CRYPTO4XX_CRYPTO_PRIORITY,\n\t\t\t.cra_flags\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK |\n\t\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize\t= 1,\n\t\t\t.cra_ctxsize\t= sizeof(struct crypto4xx_ctx),\n\t\t\t.cra_module\t= THIS_MODULE,\n\t\t},\n\t} },\n\t{ .type = CRYPTO_ALG_TYPE_AEAD, .u.aead = {\n\t\t.setkey\t\t= crypto4xx_setkey_aes_gcm,\n\t\t.setauthsize\t= crypto4xx_setauthsize_aead,\n\t\t.encrypt\t= crypto4xx_encrypt_aes_gcm,\n\t\t.decrypt\t= crypto4xx_decrypt_aes_gcm,\n\t\t.init\t\t= crypto4xx_aead_init,\n\t\t.exit\t\t= crypto4xx_aead_exit,\n\t\t.ivsize\t\t= GCM_AES_IV_SIZE,\n\t\t.maxauthsize\t= 16,\n\t\t.base = {\n\t\t\t.cra_name\t= \"gcm(aes)\",\n\t\t\t.cra_driver_name = \"gcm-aes-ppc4xx\",\n\t\t\t.cra_priority\t= CRYPTO4XX_CRYPTO_PRIORITY,\n\t\t\t.cra_flags\t= CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_NEED_FALLBACK |\n\t\t\t\t\t  CRYPTO_ALG_KERN_DRIVER_ONLY,\n\t\t\t.cra_blocksize\t= 1,\n\t\t\t.cra_ctxsize\t= sizeof(struct crypto4xx_ctx),\n\t\t\t.cra_module\t= THIS_MODULE,\n\t\t},\n\t} },\n\t{ .type = CRYPTO_ALG_TYPE_RNG, .u.rng = {\n\t\t.base = {\n\t\t\t.cra_name\t\t= \"stdrng\",\n\t\t\t.cra_driver_name        = \"crypto4xx_rng\",\n\t\t\t.cra_priority\t\t= 300,\n\t\t\t.cra_ctxsize\t\t= 0,\n\t\t\t.cra_module\t\t= THIS_MODULE,\n\t\t},\n\t\t.generate               = crypto4xx_prng_generate,\n\t\t.seed                   = crypto4xx_prng_seed,\n\t\t.seedsize               = 0,\n\t} },\n};\n\n \nstatic int crypto4xx_probe(struct platform_device *ofdev)\n{\n\tint rc;\n\tstruct resource res;\n\tstruct device *dev = &ofdev->dev;\n\tstruct crypto4xx_core_device *core_dev;\n\tstruct device_node *np;\n\tu32 pvr;\n\tbool is_revb = true;\n\n\trc = of_address_to_resource(ofdev->dev.of_node, 0, &res);\n\tif (rc)\n\t\treturn -ENODEV;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"amcc,ppc460ex-crypto\");\n\tif (np) {\n\t\tmtdcri(SDR0, PPC460EX_SDR0_SRST,\n\t\t       mfdcri(SDR0, PPC460EX_SDR0_SRST) | PPC460EX_CE_RESET);\n\t\tmtdcri(SDR0, PPC460EX_SDR0_SRST,\n\t\t       mfdcri(SDR0, PPC460EX_SDR0_SRST) & ~PPC460EX_CE_RESET);\n\t} else {\n\t\tnp = of_find_compatible_node(NULL, NULL, \"amcc,ppc405ex-crypto\");\n\t\tif (np) {\n\t\t\tmtdcri(SDR0, PPC405EX_SDR0_SRST,\n\t\t\t\t   mfdcri(SDR0, PPC405EX_SDR0_SRST) | PPC405EX_CE_RESET);\n\t\t\tmtdcri(SDR0, PPC405EX_SDR0_SRST,\n\t\t\t\t   mfdcri(SDR0, PPC405EX_SDR0_SRST) & ~PPC405EX_CE_RESET);\n\t\t\tis_revb = false;\n\t\t} else {\n\t\t\tnp = of_find_compatible_node(NULL, NULL, \"amcc,ppc460sx-crypto\");\n\t\t\tif (np) {\n\t\t\t\tmtdcri(SDR0, PPC460SX_SDR0_SRST,\n\t\t\t\t\tmfdcri(SDR0, PPC460SX_SDR0_SRST) | PPC460SX_CE_RESET);\n\t\t\t\tmtdcri(SDR0, PPC460SX_SDR0_SRST,\n\t\t\t\t\tmfdcri(SDR0, PPC460SX_SDR0_SRST) & ~PPC460SX_CE_RESET);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_ERR \"Crypto Function Not supported!\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tof_node_put(np);\n\n\tcore_dev = kzalloc(sizeof(struct crypto4xx_core_device), GFP_KERNEL);\n\tif (!core_dev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, core_dev);\n\tcore_dev->ofdev = ofdev;\n\tcore_dev->dev = kzalloc(sizeof(struct crypto4xx_device), GFP_KERNEL);\n\trc = -ENOMEM;\n\tif (!core_dev->dev)\n\t\tgoto err_alloc_dev;\n\n\t \n\tpvr = mfspr(SPRN_PVR);\n\tif (is_revb && ((pvr >> 4) == 0x130218A)) {\n\t\tu32 min = PVR_MIN(pvr);\n\n\t\tif (min < 4) {\n\t\t\tdev_info(dev, \"RevA detected - disable interrupt coalescing\\n\");\n\t\t\tis_revb = false;\n\t\t}\n\t}\n\n\tcore_dev->dev->core_dev = core_dev;\n\tcore_dev->dev->is_revb = is_revb;\n\tcore_dev->device = dev;\n\tmutex_init(&core_dev->rng_lock);\n\tspin_lock_init(&core_dev->lock);\n\tINIT_LIST_HEAD(&core_dev->dev->alg_list);\n\tratelimit_default_init(&core_dev->dev->aead_ratelimit);\n\trc = crypto4xx_build_sdr(core_dev->dev);\n\tif (rc)\n\t\tgoto err_build_sdr;\n\trc = crypto4xx_build_pdr(core_dev->dev);\n\tif (rc)\n\t\tgoto err_build_sdr;\n\n\trc = crypto4xx_build_gdr(core_dev->dev);\n\tif (rc)\n\t\tgoto err_build_sdr;\n\n\t \n\ttasklet_init(&core_dev->tasklet, crypto4xx_bh_tasklet_cb,\n\t\t     (unsigned long) dev);\n\n\tcore_dev->dev->ce_base = of_iomap(ofdev->dev.of_node, 0);\n\tif (!core_dev->dev->ce_base) {\n\t\tdev_err(dev, \"failed to of_iomap\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_iomap;\n\t}\n\n\t \n\tcore_dev->irq = irq_of_parse_and_map(ofdev->dev.of_node, 0);\n\trc = request_irq(core_dev->irq, is_revb ?\n\t\t\t crypto4xx_ce_interrupt_handler_revb :\n\t\t\t crypto4xx_ce_interrupt_handler, 0,\n\t\t\t KBUILD_MODNAME, dev);\n\tif (rc)\n\t\tgoto err_request_irq;\n\n\t \n\tcrypto4xx_hw_init(core_dev->dev);\n\n\t \n\trc = crypto4xx_register_alg(core_dev->dev, crypto4xx_alg,\n\t\t\t       ARRAY_SIZE(crypto4xx_alg));\n\tif (rc)\n\t\tgoto err_start_dev;\n\n\tppc4xx_trng_probe(core_dev);\n\treturn 0;\n\nerr_start_dev:\n\tfree_irq(core_dev->irq, dev);\nerr_request_irq:\n\tirq_dispose_mapping(core_dev->irq);\n\tiounmap(core_dev->dev->ce_base);\nerr_iomap:\n\ttasklet_kill(&core_dev->tasklet);\nerr_build_sdr:\n\tcrypto4xx_destroy_sdr(core_dev->dev);\n\tcrypto4xx_destroy_gdr(core_dev->dev);\n\tcrypto4xx_destroy_pdr(core_dev->dev);\n\tkfree(core_dev->dev);\nerr_alloc_dev:\n\tkfree(core_dev);\n\n\treturn rc;\n}\n\nstatic int crypto4xx_remove(struct platform_device *ofdev)\n{\n\tstruct device *dev = &ofdev->dev;\n\tstruct crypto4xx_core_device *core_dev = dev_get_drvdata(dev);\n\n\tppc4xx_trng_remove(core_dev);\n\n\tfree_irq(core_dev->irq, dev);\n\tirq_dispose_mapping(core_dev->irq);\n\n\ttasklet_kill(&core_dev->tasklet);\n\t \n\tcrypto4xx_unregister_alg(core_dev->dev);\n\tmutex_destroy(&core_dev->rng_lock);\n\t \n\tcrypto4xx_stop_all(core_dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id crypto4xx_match[] = {\n\t{ .compatible      = \"amcc,ppc4xx-crypto\",},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, crypto4xx_match);\n\nstatic struct platform_driver crypto4xx_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = crypto4xx_match,\n\t},\n\t.probe\t\t= crypto4xx_probe,\n\t.remove\t\t= crypto4xx_remove,\n};\n\nmodule_platform_driver(crypto4xx_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Hsiao <jhsiao@amcc.com>\");\nMODULE_DESCRIPTION(\"Driver for AMCC PPC4xx crypto accelerator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}