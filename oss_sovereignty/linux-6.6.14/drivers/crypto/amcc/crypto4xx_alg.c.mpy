{
  "module_name": "crypto4xx_alg.c",
  "hash_id": "4e6aec54f2ca2762c520741c8a259c916594e2cdd1f66fc35d15aa591316f538",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/amcc/crypto4xx_alg.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock_types.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/hash.h>\n#include <crypto/internal/hash.h>\n#include <linux/dma-mapping.h>\n#include <crypto/algapi.h>\n#include <crypto/aead.h>\n#include <crypto/aes.h>\n#include <crypto/gcm.h>\n#include <crypto/sha1.h>\n#include <crypto/ctr.h>\n#include <crypto/skcipher.h>\n#include \"crypto4xx_reg_def.h\"\n#include \"crypto4xx_core.h\"\n#include \"crypto4xx_sa.h\"\n\nstatic void set_dynamic_sa_command_0(struct dynamic_sa_ctl *sa, u32 save_h,\n\t\t\t\t     u32 save_iv, u32 ld_h, u32 ld_iv,\n\t\t\t\t     u32 hdr_proc, u32 h, u32 c, u32 pad_type,\n\t\t\t\t     u32 op_grp, u32 op, u32 dir)\n{\n\tsa->sa_command_0.w = 0;\n\tsa->sa_command_0.bf.save_hash_state = save_h;\n\tsa->sa_command_0.bf.save_iv = save_iv;\n\tsa->sa_command_0.bf.load_hash_state = ld_h;\n\tsa->sa_command_0.bf.load_iv = ld_iv;\n\tsa->sa_command_0.bf.hdr_proc = hdr_proc;\n\tsa->sa_command_0.bf.hash_alg = h;\n\tsa->sa_command_0.bf.cipher_alg = c;\n\tsa->sa_command_0.bf.pad_type = pad_type & 3;\n\tsa->sa_command_0.bf.extend_pad = pad_type >> 2;\n\tsa->sa_command_0.bf.op_group = op_grp;\n\tsa->sa_command_0.bf.opcode = op;\n\tsa->sa_command_0.bf.dir = dir;\n}\n\nstatic void set_dynamic_sa_command_1(struct dynamic_sa_ctl *sa, u32 cm,\n\t\t\t\t     u32 hmac_mc, u32 cfb, u32 esn,\n\t\t\t\t     u32 sn_mask, u32 mute, u32 cp_pad,\n\t\t\t\t     u32 cp_pay, u32 cp_hdr)\n{\n\tsa->sa_command_1.w = 0;\n\tsa->sa_command_1.bf.crypto_mode31 = (cm & 4) >> 2;\n\tsa->sa_command_1.bf.crypto_mode9_8 = cm & 3;\n\tsa->sa_command_1.bf.feedback_mode = cfb;\n\tsa->sa_command_1.bf.sa_rev = 1;\n\tsa->sa_command_1.bf.hmac_muting = hmac_mc;\n\tsa->sa_command_1.bf.extended_seq_num = esn;\n\tsa->sa_command_1.bf.seq_num_mask = sn_mask;\n\tsa->sa_command_1.bf.mutable_bit_proc = mute;\n\tsa->sa_command_1.bf.copy_pad = cp_pad;\n\tsa->sa_command_1.bf.copy_payload = cp_pay;\n\tsa->sa_command_1.bf.copy_hdr = cp_hdr;\n}\n\nstatic inline int crypto4xx_crypt(struct skcipher_request *req,\n\t\t\t\t  const unsigned int ivlen, bool decrypt,\n\t\t\t\t  bool check_blocksize)\n{\n\tstruct crypto_skcipher *cipher = crypto_skcipher_reqtfm(req);\n\tstruct crypto4xx_ctx *ctx = crypto_skcipher_ctx(cipher);\n\t__le32 iv[AES_IV_SIZE];\n\n\tif (check_blocksize && !IS_ALIGNED(req->cryptlen, AES_BLOCK_SIZE))\n\t\treturn -EINVAL;\n\n\tif (ivlen)\n\t\tcrypto4xx_memcpy_to_le32(iv, req->iv, ivlen);\n\n\treturn crypto4xx_build_pd(&req->base, ctx, req->src, req->dst,\n\t\treq->cryptlen, iv, ivlen, decrypt ? ctx->sa_in : ctx->sa_out,\n\t\tctx->sa_len, 0, NULL);\n}\n\nint crypto4xx_encrypt_noiv_block(struct skcipher_request *req)\n{\n\treturn crypto4xx_crypt(req, 0, false, true);\n}\n\nint crypto4xx_encrypt_iv_stream(struct skcipher_request *req)\n{\n\treturn crypto4xx_crypt(req, AES_IV_SIZE, false, false);\n}\n\nint crypto4xx_decrypt_noiv_block(struct skcipher_request *req)\n{\n\treturn crypto4xx_crypt(req, 0, true, true);\n}\n\nint crypto4xx_decrypt_iv_stream(struct skcipher_request *req)\n{\n\treturn crypto4xx_crypt(req, AES_IV_SIZE, true, false);\n}\n\nint crypto4xx_encrypt_iv_block(struct skcipher_request *req)\n{\n\treturn crypto4xx_crypt(req, AES_IV_SIZE, false, true);\n}\n\nint crypto4xx_decrypt_iv_block(struct skcipher_request *req)\n{\n\treturn crypto4xx_crypt(req, AES_IV_SIZE, true, true);\n}\n\n \nstatic int crypto4xx_setkey_aes(struct crypto_skcipher *cipher,\n\t\t\t\tconst u8 *key,\n\t\t\t\tunsigned int keylen,\n\t\t\t\tunsigned char cm,\n\t\t\t\tu8 fb)\n{\n\tstruct crypto4xx_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tstruct dynamic_sa_ctl *sa;\n\tint    rc;\n\n\tif (keylen != AES_KEYSIZE_256 && keylen != AES_KEYSIZE_192 &&\n\t    keylen != AES_KEYSIZE_128)\n\t\treturn -EINVAL;\n\n\t \n\tif (ctx->sa_in || ctx->sa_out)\n\t\tcrypto4xx_free_sa(ctx);\n\n\trc = crypto4xx_alloc_sa(ctx, SA_AES128_LEN + (keylen-16) / 4);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tsa = ctx->sa_in;\n\n\tset_dynamic_sa_command_0(sa, SA_NOT_SAVE_HASH, (cm == CRYPTO_MODE_ECB ?\n\t\t\t\t SA_NOT_SAVE_IV : SA_SAVE_IV),\n\t\t\t\t SA_NOT_LOAD_HASH, (cm == CRYPTO_MODE_ECB ?\n\t\t\t\t SA_LOAD_IV_FROM_SA : SA_LOAD_IV_FROM_STATE),\n\t\t\t\t SA_NO_HEADER_PROC, SA_HASH_ALG_NULL,\n\t\t\t\t SA_CIPHER_ALG_AES, SA_PAD_TYPE_ZERO,\n\t\t\t\t SA_OP_GROUP_BASIC, SA_OPCODE_DECRYPT,\n\t\t\t\t DIR_INBOUND);\n\n\tset_dynamic_sa_command_1(sa, cm, SA_HASH_MODE_HASH,\n\t\t\t\t fb, SA_EXTENDED_SN_OFF,\n\t\t\t\t SA_SEQ_MASK_OFF, SA_MC_ENABLE,\n\t\t\t\t SA_NOT_COPY_PAD, SA_NOT_COPY_PAYLOAD,\n\t\t\t\t SA_NOT_COPY_HDR);\n\tcrypto4xx_memcpy_to_le32(get_dynamic_sa_key_field(sa),\n\t\t\t\t key, keylen);\n\tsa->sa_contents.w = SA_AES_CONTENTS | (keylen << 2);\n\tsa->sa_command_1.bf.key_len = keylen >> 3;\n\n\tmemcpy(ctx->sa_out, ctx->sa_in, ctx->sa_len * 4);\n\tsa = ctx->sa_out;\n\tsa->sa_command_0.bf.dir = DIR_OUTBOUND;\n\t \n\tsa->sa_command_0.bf.opcode = SA_OPCODE_ENCRYPT;\n\n\treturn 0;\n}\n\nint crypto4xx_setkey_aes_cbc(struct crypto_skcipher *cipher,\n\t\t\t     const u8 *key, unsigned int keylen)\n{\n\treturn crypto4xx_setkey_aes(cipher, key, keylen, CRYPTO_MODE_CBC,\n\t\t\t\t    CRYPTO_FEEDBACK_MODE_NO_FB);\n}\n\nint crypto4xx_setkey_aes_cfb(struct crypto_skcipher *cipher,\n\t\t\t     const u8 *key, unsigned int keylen)\n{\n\treturn crypto4xx_setkey_aes(cipher, key, keylen, CRYPTO_MODE_CFB,\n\t\t\t\t    CRYPTO_FEEDBACK_MODE_128BIT_CFB);\n}\n\nint crypto4xx_setkey_aes_ecb(struct crypto_skcipher *cipher,\n\t\t\t     const u8 *key, unsigned int keylen)\n{\n\treturn crypto4xx_setkey_aes(cipher, key, keylen, CRYPTO_MODE_ECB,\n\t\t\t\t    CRYPTO_FEEDBACK_MODE_NO_FB);\n}\n\nint crypto4xx_setkey_aes_ofb(struct crypto_skcipher *cipher,\n\t\t\t     const u8 *key, unsigned int keylen)\n{\n\treturn crypto4xx_setkey_aes(cipher, key, keylen, CRYPTO_MODE_OFB,\n\t\t\t\t    CRYPTO_FEEDBACK_MODE_64BIT_OFB);\n}\n\nint crypto4xx_setkey_rfc3686(struct crypto_skcipher *cipher,\n\t\t\t     const u8 *key, unsigned int keylen)\n{\n\tstruct crypto4xx_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tint rc;\n\n\trc = crypto4xx_setkey_aes(cipher, key, keylen - CTR_RFC3686_NONCE_SIZE,\n\t\tCRYPTO_MODE_CTR, CRYPTO_FEEDBACK_MODE_NO_FB);\n\tif (rc)\n\t\treturn rc;\n\n\tctx->iv_nonce = cpu_to_le32p((u32 *)&key[keylen -\n\t\t\t\t\t\t CTR_RFC3686_NONCE_SIZE]);\n\n\treturn 0;\n}\n\nint crypto4xx_rfc3686_encrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *cipher = crypto_skcipher_reqtfm(req);\n\tstruct crypto4xx_ctx *ctx = crypto_skcipher_ctx(cipher);\n\t__le32 iv[AES_IV_SIZE / 4] = {\n\t\tctx->iv_nonce,\n\t\tcpu_to_le32p((u32 *) req->iv),\n\t\tcpu_to_le32p((u32 *) (req->iv + 4)),\n\t\tcpu_to_le32(1) };\n\n\treturn crypto4xx_build_pd(&req->base, ctx, req->src, req->dst,\n\t\t\t\t  req->cryptlen, iv, AES_IV_SIZE,\n\t\t\t\t  ctx->sa_out, ctx->sa_len, 0, NULL);\n}\n\nint crypto4xx_rfc3686_decrypt(struct skcipher_request *req)\n{\n\tstruct crypto_skcipher *cipher = crypto_skcipher_reqtfm(req);\n\tstruct crypto4xx_ctx *ctx = crypto_skcipher_ctx(cipher);\n\t__le32 iv[AES_IV_SIZE / 4] = {\n\t\tctx->iv_nonce,\n\t\tcpu_to_le32p((u32 *) req->iv),\n\t\tcpu_to_le32p((u32 *) (req->iv + 4)),\n\t\tcpu_to_le32(1) };\n\n\treturn crypto4xx_build_pd(&req->base, ctx, req->src, req->dst,\n\t\t\t\t  req->cryptlen, iv, AES_IV_SIZE,\n\t\t\t\t  ctx->sa_out, ctx->sa_len, 0, NULL);\n}\n\nstatic int\ncrypto4xx_ctr_crypt(struct skcipher_request *req, bool encrypt)\n{\n\tstruct crypto_skcipher *cipher = crypto_skcipher_reqtfm(req);\n\tstruct crypto4xx_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tsize_t iv_len = crypto_skcipher_ivsize(cipher);\n\tunsigned int counter = be32_to_cpup((__be32 *)(req->iv + iv_len - 4));\n\tunsigned int nblks = ALIGN(req->cryptlen, AES_BLOCK_SIZE) /\n\t\t\tAES_BLOCK_SIZE;\n\n\t \n\tif (counter + nblks < counter) {\n\t\tSYNC_SKCIPHER_REQUEST_ON_STACK(subreq, ctx->sw_cipher.cipher);\n\t\tint ret;\n\n\t\tskcipher_request_set_sync_tfm(subreq, ctx->sw_cipher.cipher);\n\t\tskcipher_request_set_callback(subreq, req->base.flags,\n\t\t\tNULL, NULL);\n\t\tskcipher_request_set_crypt(subreq, req->src, req->dst,\n\t\t\treq->cryptlen, req->iv);\n\t\tret = encrypt ? crypto_skcipher_encrypt(subreq)\n\t\t\t: crypto_skcipher_decrypt(subreq);\n\t\tskcipher_request_zero(subreq);\n\t\treturn ret;\n\t}\n\n\treturn encrypt ? crypto4xx_encrypt_iv_stream(req)\n\t\t       : crypto4xx_decrypt_iv_stream(req);\n}\n\nstatic int crypto4xx_sk_setup_fallback(struct crypto4xx_ctx *ctx,\n\t\t\t\t       struct crypto_skcipher *cipher,\n\t\t\t\t       const u8 *key,\n\t\t\t\t       unsigned int keylen)\n{\n\tcrypto_sync_skcipher_clear_flags(ctx->sw_cipher.cipher,\n\t\t\t\t    CRYPTO_TFM_REQ_MASK);\n\tcrypto_sync_skcipher_set_flags(ctx->sw_cipher.cipher,\n\t\tcrypto_skcipher_get_flags(cipher) & CRYPTO_TFM_REQ_MASK);\n\treturn crypto_sync_skcipher_setkey(ctx->sw_cipher.cipher, key, keylen);\n}\n\nint crypto4xx_setkey_aes_ctr(struct crypto_skcipher *cipher,\n\t\t\t     const u8 *key, unsigned int keylen)\n{\n\tstruct crypto4xx_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tint rc;\n\n\trc = crypto4xx_sk_setup_fallback(ctx, cipher, key, keylen);\n\tif (rc)\n\t\treturn rc;\n\n\treturn crypto4xx_setkey_aes(cipher, key, keylen,\n\t\tCRYPTO_MODE_CTR, CRYPTO_FEEDBACK_MODE_NO_FB);\n}\n\nint crypto4xx_encrypt_ctr(struct skcipher_request *req)\n{\n\treturn crypto4xx_ctr_crypt(req, true);\n}\n\nint crypto4xx_decrypt_ctr(struct skcipher_request *req)\n{\n\treturn crypto4xx_ctr_crypt(req, false);\n}\n\nstatic inline bool crypto4xx_aead_need_fallback(struct aead_request *req,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tbool is_ccm, bool decrypt)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\n\t \n\tif (aead->authsize & 3)\n\t\treturn true;\n\n\t \n\tif (len < AES_BLOCK_SIZE)\n\t\treturn true;\n\n\t \n\tif (req->assoclen & 0x3 || req->assoclen > 1020)\n\t\treturn true;\n\n\t \n\tif (is_ccm && !(req->iv[0] == 1 || req->iv[0] == 3))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int crypto4xx_aead_fallback(struct aead_request *req,\n\tstruct crypto4xx_ctx *ctx, bool do_decrypt)\n{\n\tstruct aead_request *subreq = aead_request_ctx(req);\n\n\taead_request_set_tfm(subreq, ctx->sw_cipher.aead);\n\taead_request_set_callback(subreq, req->base.flags,\n\t\t\t\t  req->base.complete, req->base.data);\n\taead_request_set_crypt(subreq, req->src, req->dst, req->cryptlen,\n\t\t\t       req->iv);\n\taead_request_set_ad(subreq, req->assoclen);\n\treturn do_decrypt ? crypto_aead_decrypt(subreq) :\n\t\t\t    crypto_aead_encrypt(subreq);\n}\n\nstatic int crypto4xx_aead_setup_fallback(struct crypto4xx_ctx *ctx,\n\t\t\t\t\t struct crypto_aead *cipher,\n\t\t\t\t\t const u8 *key,\n\t\t\t\t\t unsigned int keylen)\n{\n\tcrypto_aead_clear_flags(ctx->sw_cipher.aead, CRYPTO_TFM_REQ_MASK);\n\tcrypto_aead_set_flags(ctx->sw_cipher.aead,\n\t\tcrypto_aead_get_flags(cipher) & CRYPTO_TFM_REQ_MASK);\n\treturn crypto_aead_setkey(ctx->sw_cipher.aead, key, keylen);\n}\n\n \n\nint crypto4xx_setkey_aes_ccm(struct crypto_aead *cipher, const u8 *key,\n\t\t\t     unsigned int keylen)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(cipher);\n\tstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct dynamic_sa_ctl *sa;\n\tint rc = 0;\n\n\trc = crypto4xx_aead_setup_fallback(ctx, cipher, key, keylen);\n\tif (rc)\n\t\treturn rc;\n\n\tif (ctx->sa_in || ctx->sa_out)\n\t\tcrypto4xx_free_sa(ctx);\n\n\trc = crypto4xx_alloc_sa(ctx, SA_AES128_CCM_LEN + (keylen - 16) / 4);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tsa = (struct dynamic_sa_ctl *) ctx->sa_in;\n\tsa->sa_contents.w = SA_AES_CCM_CONTENTS | (keylen << 2);\n\n\tset_dynamic_sa_command_0(sa, SA_SAVE_HASH, SA_NOT_SAVE_IV,\n\t\t\t\t SA_LOAD_HASH_FROM_SA, SA_LOAD_IV_FROM_STATE,\n\t\t\t\t SA_NO_HEADER_PROC, SA_HASH_ALG_CBC_MAC,\n\t\t\t\t SA_CIPHER_ALG_AES,\n\t\t\t\t SA_PAD_TYPE_ZERO, SA_OP_GROUP_BASIC,\n\t\t\t\t SA_OPCODE_HASH_DECRYPT, DIR_INBOUND);\n\n\tset_dynamic_sa_command_1(sa, CRYPTO_MODE_CTR, SA_HASH_MODE_HASH,\n\t\t\t\t CRYPTO_FEEDBACK_MODE_NO_FB, SA_EXTENDED_SN_OFF,\n\t\t\t\t SA_SEQ_MASK_OFF, SA_MC_ENABLE,\n\t\t\t\t SA_NOT_COPY_PAD, SA_COPY_PAYLOAD,\n\t\t\t\t SA_NOT_COPY_HDR);\n\n\tsa->sa_command_1.bf.key_len = keylen >> 3;\n\n\tcrypto4xx_memcpy_to_le32(get_dynamic_sa_key_field(sa), key, keylen);\n\n\tmemcpy(ctx->sa_out, ctx->sa_in, ctx->sa_len * 4);\n\tsa = (struct dynamic_sa_ctl *) ctx->sa_out;\n\n\tset_dynamic_sa_command_0(sa, SA_SAVE_HASH, SA_NOT_SAVE_IV,\n\t\t\t\t SA_LOAD_HASH_FROM_SA, SA_LOAD_IV_FROM_STATE,\n\t\t\t\t SA_NO_HEADER_PROC, SA_HASH_ALG_CBC_MAC,\n\t\t\t\t SA_CIPHER_ALG_AES,\n\t\t\t\t SA_PAD_TYPE_ZERO, SA_OP_GROUP_BASIC,\n\t\t\t\t SA_OPCODE_ENCRYPT_HASH, DIR_OUTBOUND);\n\n\tset_dynamic_sa_command_1(sa, CRYPTO_MODE_CTR, SA_HASH_MODE_HASH,\n\t\t\t\t CRYPTO_FEEDBACK_MODE_NO_FB, SA_EXTENDED_SN_OFF,\n\t\t\t\t SA_SEQ_MASK_OFF, SA_MC_ENABLE,\n\t\t\t\t SA_COPY_PAD, SA_COPY_PAYLOAD,\n\t\t\t\t SA_NOT_COPY_HDR);\n\n\tsa->sa_command_1.bf.key_len = keylen >> 3;\n\treturn 0;\n}\n\nstatic int crypto4xx_crypt_aes_ccm(struct aead_request *req, bool decrypt)\n{\n\tstruct crypto4xx_ctx *ctx  = crypto_tfm_ctx(req->base.tfm);\n\tstruct crypto4xx_aead_reqctx *rctx = aead_request_ctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\t__le32 iv[16];\n\tu32 tmp_sa[SA_AES128_CCM_LEN + 4];\n\tstruct dynamic_sa_ctl *sa = (struct dynamic_sa_ctl *)tmp_sa;\n\tunsigned int len = req->cryptlen;\n\n\tif (decrypt)\n\t\tlen -= crypto_aead_authsize(aead);\n\n\tif (crypto4xx_aead_need_fallback(req, len, true, decrypt))\n\t\treturn crypto4xx_aead_fallback(req, ctx, decrypt);\n\n\tmemcpy(tmp_sa, decrypt ? ctx->sa_in : ctx->sa_out, ctx->sa_len * 4);\n\tsa->sa_command_0.bf.digest_len = crypto_aead_authsize(aead) >> 2;\n\n\tif (req->iv[0] == 1) {\n\t\t \n\t\tsa->sa_command_1.bf.crypto_mode9_8 = 1;\n\t}\n\n\tiv[3] = cpu_to_le32(0);\n\tcrypto4xx_memcpy_to_le32(iv, req->iv, 16 - (req->iv[0] + 1));\n\n\treturn crypto4xx_build_pd(&req->base, ctx, req->src, req->dst,\n\t\t\t\t  len, iv, sizeof(iv),\n\t\t\t\t  sa, ctx->sa_len, req->assoclen, rctx->dst);\n}\n\nint crypto4xx_encrypt_aes_ccm(struct aead_request *req)\n{\n\treturn crypto4xx_crypt_aes_ccm(req, false);\n}\n\nint crypto4xx_decrypt_aes_ccm(struct aead_request *req)\n{\n\treturn crypto4xx_crypt_aes_ccm(req, true);\n}\n\nint crypto4xx_setauthsize_aead(struct crypto_aead *cipher,\n\t\t\t       unsigned int authsize)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(cipher);\n\tstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\treturn crypto_aead_setauthsize(ctx->sw_cipher.aead, authsize);\n}\n\n \n\nstatic int crypto4xx_aes_gcm_validate_keylen(unsigned int keylen)\n{\n\tswitch (keylen) {\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int crypto4xx_compute_gcm_hash_key_sw(__le32 *hash_start, const u8 *key,\n\t\t\t\t\t     unsigned int keylen)\n{\n\tstruct crypto_aes_ctx ctx;\n\tuint8_t src[16] = { 0 };\n\tint rc;\n\n\trc = aes_expandkey(&ctx, key, keylen);\n\tif (rc) {\n\t\tpr_err(\"aes_expandkey() failed: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\taes_encrypt(&ctx, src, src);\n\tcrypto4xx_memcpy_to_le32(hash_start, src, 16);\n\tmemzero_explicit(&ctx, sizeof(ctx));\n\treturn 0;\n}\n\nint crypto4xx_setkey_aes_gcm(struct crypto_aead *cipher,\n\t\t\t     const u8 *key, unsigned int keylen)\n{\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(cipher);\n\tstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct dynamic_sa_ctl *sa;\n\tint    rc = 0;\n\n\tif (crypto4xx_aes_gcm_validate_keylen(keylen) != 0)\n\t\treturn -EINVAL;\n\n\trc = crypto4xx_aead_setup_fallback(ctx, cipher, key, keylen);\n\tif (rc)\n\t\treturn rc;\n\n\tif (ctx->sa_in || ctx->sa_out)\n\t\tcrypto4xx_free_sa(ctx);\n\n\trc = crypto4xx_alloc_sa(ctx, SA_AES128_GCM_LEN + (keylen - 16) / 4);\n\tif (rc)\n\t\treturn rc;\n\n\tsa  = (struct dynamic_sa_ctl *) ctx->sa_in;\n\n\tsa->sa_contents.w = SA_AES_GCM_CONTENTS | (keylen << 2);\n\tset_dynamic_sa_command_0(sa, SA_SAVE_HASH, SA_NOT_SAVE_IV,\n\t\t\t\t SA_LOAD_HASH_FROM_SA, SA_LOAD_IV_FROM_STATE,\n\t\t\t\t SA_NO_HEADER_PROC, SA_HASH_ALG_GHASH,\n\t\t\t\t SA_CIPHER_ALG_AES, SA_PAD_TYPE_ZERO,\n\t\t\t\t SA_OP_GROUP_BASIC, SA_OPCODE_HASH_DECRYPT,\n\t\t\t\t DIR_INBOUND);\n\tset_dynamic_sa_command_1(sa, CRYPTO_MODE_CTR, SA_HASH_MODE_HASH,\n\t\t\t\t CRYPTO_FEEDBACK_MODE_NO_FB, SA_EXTENDED_SN_OFF,\n\t\t\t\t SA_SEQ_MASK_ON, SA_MC_DISABLE,\n\t\t\t\t SA_NOT_COPY_PAD, SA_COPY_PAYLOAD,\n\t\t\t\t SA_NOT_COPY_HDR);\n\n\tsa->sa_command_1.bf.key_len = keylen >> 3;\n\n\tcrypto4xx_memcpy_to_le32(get_dynamic_sa_key_field(sa),\n\t\t\t\t key, keylen);\n\n\trc = crypto4xx_compute_gcm_hash_key_sw(get_dynamic_sa_inner_digest(sa),\n\t\tkey, keylen);\n\tif (rc) {\n\t\tpr_err(\"GCM hash key setting failed = %d\\n\", rc);\n\t\tgoto err;\n\t}\n\n\tmemcpy(ctx->sa_out, ctx->sa_in, ctx->sa_len * 4);\n\tsa = (struct dynamic_sa_ctl *) ctx->sa_out;\n\tsa->sa_command_0.bf.dir = DIR_OUTBOUND;\n\tsa->sa_command_0.bf.opcode = SA_OPCODE_ENCRYPT_HASH;\n\n\treturn 0;\nerr:\n\tcrypto4xx_free_sa(ctx);\n\treturn rc;\n}\n\nstatic inline int crypto4xx_crypt_aes_gcm(struct aead_request *req,\n\t\t\t\t\t  bool decrypt)\n{\n\tstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\n\tstruct crypto4xx_aead_reqctx *rctx = aead_request_ctx(req);\n\t__le32 iv[4];\n\tunsigned int len = req->cryptlen;\n\n\tif (decrypt)\n\t\tlen -= crypto_aead_authsize(crypto_aead_reqtfm(req));\n\n\tif (crypto4xx_aead_need_fallback(req, len, false, decrypt))\n\t\treturn crypto4xx_aead_fallback(req, ctx, decrypt);\n\n\tcrypto4xx_memcpy_to_le32(iv, req->iv, GCM_AES_IV_SIZE);\n\tiv[3] = cpu_to_le32(1);\n\n\treturn crypto4xx_build_pd(&req->base, ctx, req->src, req->dst,\n\t\t\t\t  len, iv, sizeof(iv),\n\t\t\t\t  decrypt ? ctx->sa_in : ctx->sa_out,\n\t\t\t\t  ctx->sa_len, req->assoclen, rctx->dst);\n}\n\nint crypto4xx_encrypt_aes_gcm(struct aead_request *req)\n{\n\treturn crypto4xx_crypt_aes_gcm(req, false);\n}\n\nint crypto4xx_decrypt_aes_gcm(struct aead_request *req)\n{\n\treturn crypto4xx_crypt_aes_gcm(req, true);\n}\n\n \nstatic int crypto4xx_hash_alg_init(struct crypto_tfm *tfm,\n\t\t\t\t   unsigned int sa_len,\n\t\t\t\t   unsigned char ha,\n\t\t\t\t   unsigned char hm)\n{\n\tstruct crypto_alg *alg = tfm->__crt_alg;\n\tstruct crypto4xx_alg *my_alg;\n\tstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct dynamic_sa_hash160 *sa;\n\tint rc;\n\n\tmy_alg = container_of(__crypto_ahash_alg(alg), struct crypto4xx_alg,\n\t\t\t      alg.u.hash);\n\tctx->dev   = my_alg->dev;\n\n\t \n\tif (ctx->sa_in || ctx->sa_out)\n\t\tcrypto4xx_free_sa(ctx);\n\n\trc = crypto4xx_alloc_sa(ctx, sa_len);\n\tif (rc)\n\t\treturn rc;\n\n\tcrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\n\t\t\t\t sizeof(struct crypto4xx_ctx));\n\tsa = (struct dynamic_sa_hash160 *)ctx->sa_in;\n\tset_dynamic_sa_command_0(&sa->ctrl, SA_SAVE_HASH, SA_NOT_SAVE_IV,\n\t\t\t\t SA_NOT_LOAD_HASH, SA_LOAD_IV_FROM_SA,\n\t\t\t\t SA_NO_HEADER_PROC, ha, SA_CIPHER_ALG_NULL,\n\t\t\t\t SA_PAD_TYPE_ZERO, SA_OP_GROUP_BASIC,\n\t\t\t\t SA_OPCODE_HASH, DIR_INBOUND);\n\tset_dynamic_sa_command_1(&sa->ctrl, 0, SA_HASH_MODE_HASH,\n\t\t\t\t CRYPTO_FEEDBACK_MODE_NO_FB, SA_EXTENDED_SN_OFF,\n\t\t\t\t SA_SEQ_MASK_OFF, SA_MC_ENABLE,\n\t\t\t\t SA_NOT_COPY_PAD, SA_NOT_COPY_PAYLOAD,\n\t\t\t\t SA_NOT_COPY_HDR);\n\t \n\tmemset(sa->inner_digest, 0, sizeof(sa->inner_digest));\n\tmemset(sa->outer_digest, 0, sizeof(sa->outer_digest));\n\n\treturn 0;\n}\n\nint crypto4xx_hash_init(struct ahash_request *req)\n{\n\tstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\n\tint ds;\n\tstruct dynamic_sa_ctl *sa;\n\n\tsa = ctx->sa_in;\n\tds = crypto_ahash_digestsize(\n\t\t\t__crypto_ahash_cast(req->base.tfm));\n\tsa->sa_command_0.bf.digest_len = ds >> 2;\n\tsa->sa_command_0.bf.load_hash_state = SA_LOAD_HASH_FROM_SA;\n\n\treturn 0;\n}\n\nint crypto4xx_hash_update(struct ahash_request *req)\n{\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\n\tstruct scatterlist dst;\n\tunsigned int ds = crypto_ahash_digestsize(ahash);\n\n\tsg_init_one(&dst, req->result, ds);\n\n\treturn crypto4xx_build_pd(&req->base, ctx, req->src, &dst,\n\t\t\t\t  req->nbytes, NULL, 0, ctx->sa_in,\n\t\t\t\t  ctx->sa_len, 0, NULL);\n}\n\nint crypto4xx_hash_final(struct ahash_request *req)\n{\n\treturn 0;\n}\n\nint crypto4xx_hash_digest(struct ahash_request *req)\n{\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(req);\n\tstruct crypto4xx_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\n\tstruct scatterlist dst;\n\tunsigned int ds = crypto_ahash_digestsize(ahash);\n\n\tsg_init_one(&dst, req->result, ds);\n\n\treturn crypto4xx_build_pd(&req->base, ctx, req->src, &dst,\n\t\t\t\t  req->nbytes, NULL, 0, ctx->sa_in,\n\t\t\t\t  ctx->sa_len, 0, NULL);\n}\n\n \nint crypto4xx_sha1_alg_init(struct crypto_tfm *tfm)\n{\n\treturn crypto4xx_hash_alg_init(tfm, SA_HASH160_LEN, SA_HASH_ALG_SHA1,\n\t\t\t\t       SA_HASH_MODE_HASH);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}