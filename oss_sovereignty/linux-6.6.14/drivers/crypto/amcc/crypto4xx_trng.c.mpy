{
  "module_name": "crypto4xx_trng.c",
  "hash_id": "4b2aba7d22bfb88af6e514f516941e540151c4028ced4f71152ead5c2b575f21",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/amcc/crypto4xx_trng.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/hw_random.h>\n#include <linux/delay.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/io.h>\n\n#include \"crypto4xx_core.h\"\n#include \"crypto4xx_trng.h\"\n#include \"crypto4xx_reg_def.h\"\n\n#define PPC4XX_TRNG_CTRL\t0x0008\n#define PPC4XX_TRNG_CTRL_DALM\t0x20\n#define PPC4XX_TRNG_STAT\t0x0004\n#define PPC4XX_TRNG_STAT_B\t0x1\n#define PPC4XX_TRNG_DATA\t0x0000\n\nstatic int ppc4xx_trng_data_present(struct hwrng *rng, int wait)\n{\n\tstruct crypto4xx_device *dev = (void *)rng->priv;\n\tint busy, i, present = 0;\n\n\tfor (i = 0; i < 20; i++) {\n\t\tbusy = (in_le32(dev->trng_base + PPC4XX_TRNG_STAT) &\n\t\t\tPPC4XX_TRNG_STAT_B);\n\t\tif (!busy || !wait) {\n\t\t\tpresent = 1;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t}\n\treturn present;\n}\n\nstatic int ppc4xx_trng_data_read(struct hwrng *rng, u32 *data)\n{\n\tstruct crypto4xx_device *dev = (void *)rng->priv;\n\t*data = in_le32(dev->trng_base + PPC4XX_TRNG_DATA);\n\treturn 4;\n}\n\nstatic void ppc4xx_trng_enable(struct crypto4xx_device *dev, bool enable)\n{\n\tu32 device_ctrl;\n\n\tdevice_ctrl = readl(dev->ce_base + CRYPTO4XX_DEVICE_CTRL);\n\tif (enable)\n\t\tdevice_ctrl |= PPC4XX_TRNG_EN;\n\telse\n\t\tdevice_ctrl &= ~PPC4XX_TRNG_EN;\n\twritel(device_ctrl, dev->ce_base + CRYPTO4XX_DEVICE_CTRL);\n}\n\nstatic const struct of_device_id ppc4xx_trng_match[] = {\n\t{ .compatible = \"ppc4xx-rng\", },\n\t{ .compatible = \"amcc,ppc460ex-rng\", },\n\t{ .compatible = \"amcc,ppc440epx-rng\", },\n\t{},\n};\n\nvoid ppc4xx_trng_probe(struct crypto4xx_core_device *core_dev)\n{\n\tstruct crypto4xx_device *dev = core_dev->dev;\n\tstruct device_node *trng = NULL;\n\tstruct hwrng *rng = NULL;\n\tint err;\n\n\t \n\ttrng = of_find_matching_node(NULL, ppc4xx_trng_match);\n\tif (!trng || !of_device_is_available(trng)) {\n\t\tof_node_put(trng);\n\t\treturn;\n\t}\n\n\tdev->trng_base = of_iomap(trng, 0);\n\tof_node_put(trng);\n\tif (!dev->trng_base)\n\t\tgoto err_out;\n\n\trng = kzalloc(sizeof(*rng), GFP_KERNEL);\n\tif (!rng)\n\t\tgoto err_out;\n\n\trng->name = KBUILD_MODNAME;\n\trng->data_present = ppc4xx_trng_data_present;\n\trng->data_read = ppc4xx_trng_data_read;\n\trng->priv = (unsigned long) dev;\n\tcore_dev->trng = rng;\n\tppc4xx_trng_enable(dev, true);\n\tout_le32(dev->trng_base + PPC4XX_TRNG_CTRL, PPC4XX_TRNG_CTRL_DALM);\n\terr = devm_hwrng_register(core_dev->device, core_dev->trng);\n\tif (err) {\n\t\tppc4xx_trng_enable(dev, false);\n\t\tdev_err(core_dev->device, \"failed to register hwrng (%d).\\n\",\n\t\t\terr);\n\t\tgoto err_out;\n\t}\n\treturn;\n\nerr_out:\n\tiounmap(dev->trng_base);\n\tkfree(rng);\n\tdev->trng_base = NULL;\n\tcore_dev->trng = NULL;\n}\n\nvoid ppc4xx_trng_remove(struct crypto4xx_core_device *core_dev)\n{\n\tif (core_dev && core_dev->trng) {\n\t\tstruct crypto4xx_device *dev = core_dev->dev;\n\n\t\tdevm_hwrng_unregister(core_dev->device, core_dev->trng);\n\t\tppc4xx_trng_enable(dev, false);\n\t\tiounmap(dev->trng_base);\n\t\tkfree(core_dev->trng);\n\t}\n}\n\nMODULE_ALIAS(\"ppc4xx_rng\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}