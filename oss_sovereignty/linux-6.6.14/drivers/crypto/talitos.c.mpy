{
  "module_name": "talitos.c",
  "hash_id": "c5b8d03287a5b25fb199fe54ba09f3a3be938a50a256407a537fed56176b6fe1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/talitos.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/crypto.h>\n#include <linux/hw_random.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/spinlock.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <crypto/internal/des.h>\n#include <crypto/sha1.h>\n#include <crypto/sha2.h>\n#include <crypto/md5.h>\n#include <crypto/internal/aead.h>\n#include <crypto/authenc.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/hash.h>\n#include <crypto/internal/hash.h>\n#include <crypto/scatterwalk.h>\n\n#include \"talitos.h\"\n\nstatic void to_talitos_ptr(struct talitos_ptr *ptr, dma_addr_t dma_addr,\n\t\t\t   unsigned int len, bool is_sec1)\n{\n\tptr->ptr = cpu_to_be32(lower_32_bits(dma_addr));\n\tif (is_sec1) {\n\t\tptr->len1 = cpu_to_be16(len);\n\t} else {\n\t\tptr->len = cpu_to_be16(len);\n\t\tptr->eptr = upper_32_bits(dma_addr);\n\t}\n}\n\nstatic void copy_talitos_ptr(struct talitos_ptr *dst_ptr,\n\t\t\t     struct talitos_ptr *src_ptr, bool is_sec1)\n{\n\tdst_ptr->ptr = src_ptr->ptr;\n\tif (is_sec1) {\n\t\tdst_ptr->len1 = src_ptr->len1;\n\t} else {\n\t\tdst_ptr->len = src_ptr->len;\n\t\tdst_ptr->eptr = src_ptr->eptr;\n\t}\n}\n\nstatic unsigned short from_talitos_ptr_len(struct talitos_ptr *ptr,\n\t\t\t\t\t   bool is_sec1)\n{\n\tif (is_sec1)\n\t\treturn be16_to_cpu(ptr->len1);\n\telse\n\t\treturn be16_to_cpu(ptr->len);\n}\n\nstatic void to_talitos_ptr_ext_set(struct talitos_ptr *ptr, u8 val,\n\t\t\t\t   bool is_sec1)\n{\n\tif (!is_sec1)\n\t\tptr->j_extent = val;\n}\n\nstatic void to_talitos_ptr_ext_or(struct talitos_ptr *ptr, u8 val, bool is_sec1)\n{\n\tif (!is_sec1)\n\t\tptr->j_extent |= val;\n}\n\n \nstatic void __map_single_talitos_ptr(struct device *dev,\n\t\t\t\t     struct talitos_ptr *ptr,\n\t\t\t\t     unsigned int len, void *data,\n\t\t\t\t     enum dma_data_direction dir,\n\t\t\t\t     unsigned long attrs)\n{\n\tdma_addr_t dma_addr = dma_map_single_attrs(dev, data, len, dir, attrs);\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tbool is_sec1 = has_ftr_sec1(priv);\n\n\tto_talitos_ptr(ptr, dma_addr, len, is_sec1);\n}\n\nstatic void map_single_talitos_ptr(struct device *dev,\n\t\t\t\t   struct talitos_ptr *ptr,\n\t\t\t\t   unsigned int len, void *data,\n\t\t\t\t   enum dma_data_direction dir)\n{\n\t__map_single_talitos_ptr(dev, ptr, len, data, dir, 0);\n}\n\nstatic void map_single_talitos_ptr_nosync(struct device *dev,\n\t\t\t\t\t  struct talitos_ptr *ptr,\n\t\t\t\t\t  unsigned int len, void *data,\n\t\t\t\t\t  enum dma_data_direction dir)\n{\n\t__map_single_talitos_ptr(dev, ptr, len, data, dir,\n\t\t\t\t DMA_ATTR_SKIP_CPU_SYNC);\n}\n\n \nstatic void unmap_single_talitos_ptr(struct device *dev,\n\t\t\t\t     struct talitos_ptr *ptr,\n\t\t\t\t     enum dma_data_direction dir)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tbool is_sec1 = has_ftr_sec1(priv);\n\n\tdma_unmap_single(dev, be32_to_cpu(ptr->ptr),\n\t\t\t from_talitos_ptr_len(ptr, is_sec1), dir);\n}\n\nstatic int reset_channel(struct device *dev, int ch)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tunsigned int timeout = TALITOS_TIMEOUT;\n\tbool is_sec1 = has_ftr_sec1(priv);\n\n\tif (is_sec1) {\n\t\tsetbits32(priv->chan[ch].reg + TALITOS_CCCR_LO,\n\t\t\t  TALITOS1_CCCR_LO_RESET);\n\n\t\twhile ((in_be32(priv->chan[ch].reg + TALITOS_CCCR_LO) &\n\t\t\tTALITOS1_CCCR_LO_RESET) && --timeout)\n\t\t\tcpu_relax();\n\t} else {\n\t\tsetbits32(priv->chan[ch].reg + TALITOS_CCCR,\n\t\t\t  TALITOS2_CCCR_RESET);\n\n\t\twhile ((in_be32(priv->chan[ch].reg + TALITOS_CCCR) &\n\t\t\tTALITOS2_CCCR_RESET) && --timeout)\n\t\t\tcpu_relax();\n\t}\n\n\tif (timeout == 0) {\n\t\tdev_err(dev, \"failed to reset channel %d\\n\", ch);\n\t\treturn -EIO;\n\t}\n\n\t \n\tsetbits32(priv->chan[ch].reg + TALITOS_CCCR_LO, TALITOS_CCCR_LO_EAE |\n\t\t  TALITOS_CCCR_LO_CDWE | TALITOS_CCCR_LO_CDIE);\n\t \n\tif (is_sec1)\n\t\tsetbits32(priv->chan[ch].reg + TALITOS_CCCR_LO,\n\t\t\t  TALITOS_CCCR_LO_NE);\n\n\t \n\tif (priv->features & TALITOS_FTR_HW_AUTH_CHECK)\n\t\tsetbits32(priv->chan[ch].reg + TALITOS_CCCR_LO,\n\t\t          TALITOS_CCCR_LO_IWSE);\n\n\treturn 0;\n}\n\nstatic int reset_device(struct device *dev)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tunsigned int timeout = TALITOS_TIMEOUT;\n\tbool is_sec1 = has_ftr_sec1(priv);\n\tu32 mcr = is_sec1 ? TALITOS1_MCR_SWR : TALITOS2_MCR_SWR;\n\n\tsetbits32(priv->reg + TALITOS_MCR, mcr);\n\n\twhile ((in_be32(priv->reg + TALITOS_MCR) & mcr)\n\t       && --timeout)\n\t\tcpu_relax();\n\n\tif (priv->irq[1]) {\n\t\tmcr = TALITOS_MCR_RCA1 | TALITOS_MCR_RCA3;\n\t\tsetbits32(priv->reg + TALITOS_MCR, mcr);\n\t}\n\n\tif (timeout == 0) {\n\t\tdev_err(dev, \"failed to reset device\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int init_device(struct device *dev)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tint ch, err;\n\tbool is_sec1 = has_ftr_sec1(priv);\n\n\t \n\terr = reset_device(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = reset_device(dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (ch = 0; ch < priv->num_channels; ch++) {\n\t\terr = reset_channel(dev, ch);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (is_sec1) {\n\t\tclrbits32(priv->reg + TALITOS_IMR, TALITOS1_IMR_INIT);\n\t\tclrbits32(priv->reg + TALITOS_IMR_LO, TALITOS1_IMR_LO_INIT);\n\t\t \n\t\tsetbits32(priv->reg_deu + TALITOS_EUICR, TALITOS1_DEUICR_KPE);\n\t} else {\n\t\tsetbits32(priv->reg + TALITOS_IMR, TALITOS2_IMR_INIT);\n\t\tsetbits32(priv->reg + TALITOS_IMR_LO, TALITOS2_IMR_LO_INIT);\n\t}\n\n\t \n\tif (priv->features & TALITOS_FTR_HW_AUTH_CHECK)\n\t\tsetbits32(priv->reg_mdeu + TALITOS_EUICR_LO,\n\t\t          TALITOS_MDEUICR_LO_ICE);\n\n\treturn 0;\n}\n\n \nstatic int talitos_submit(struct device *dev, int ch, struct talitos_desc *desc,\n\t\t\t  void (*callback)(struct device *dev,\n\t\t\t\t\t   struct talitos_desc *desc,\n\t\t\t\t\t   void *context, int error),\n\t\t\t  void *context)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tstruct talitos_request *request;\n\tunsigned long flags;\n\tint head;\n\tbool is_sec1 = has_ftr_sec1(priv);\n\n\tspin_lock_irqsave(&priv->chan[ch].head_lock, flags);\n\n\tif (!atomic_inc_not_zero(&priv->chan[ch].submit_count)) {\n\t\t \n\t\tspin_unlock_irqrestore(&priv->chan[ch].head_lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\n\thead = priv->chan[ch].head;\n\trequest = &priv->chan[ch].fifo[head];\n\n\t \n\tif (is_sec1) {\n\t\tdesc->hdr1 = desc->hdr;\n\t\trequest->dma_desc = dma_map_single(dev, &desc->hdr1,\n\t\t\t\t\t\t   TALITOS_DESC_SIZE,\n\t\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\t} else {\n\t\trequest->dma_desc = dma_map_single(dev, desc,\n\t\t\t\t\t\t   TALITOS_DESC_SIZE,\n\t\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\t}\n\trequest->callback = callback;\n\trequest->context = context;\n\n\t \n\tpriv->chan[ch].head = (priv->chan[ch].head + 1) & (priv->fifo_len - 1);\n\n\tsmp_wmb();\n\trequest->desc = desc;\n\n\t \n\twmb();\n\tout_be32(priv->chan[ch].reg + TALITOS_FF,\n\t\t upper_32_bits(request->dma_desc));\n\tout_be32(priv->chan[ch].reg + TALITOS_FF_LO,\n\t\t lower_32_bits(request->dma_desc));\n\n\tspin_unlock_irqrestore(&priv->chan[ch].head_lock, flags);\n\n\treturn -EINPROGRESS;\n}\n\nstatic __be32 get_request_hdr(struct talitos_request *request, bool is_sec1)\n{\n\tstruct talitos_edesc *edesc;\n\n\tif (!is_sec1)\n\t\treturn request->desc->hdr;\n\n\tif (!request->desc->next_desc)\n\t\treturn request->desc->hdr1;\n\n\tedesc = container_of(request->desc, struct talitos_edesc, desc);\n\n\treturn ((struct talitos_desc *)(edesc->buf + edesc->dma_len))->hdr1;\n}\n\n \nstatic void flush_channel(struct device *dev, int ch, int error, int reset_ch)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tstruct talitos_request *request, saved_req;\n\tunsigned long flags;\n\tint tail, status;\n\tbool is_sec1 = has_ftr_sec1(priv);\n\n\tspin_lock_irqsave(&priv->chan[ch].tail_lock, flags);\n\n\ttail = priv->chan[ch].tail;\n\twhile (priv->chan[ch].fifo[tail].desc) {\n\t\t__be32 hdr;\n\n\t\trequest = &priv->chan[ch].fifo[tail];\n\n\t\t \n\t\trmb();\n\t\thdr = get_request_hdr(request, is_sec1);\n\n\t\tif ((hdr & DESC_HDR_DONE) == DESC_HDR_DONE)\n\t\t\tstatus = 0;\n\t\telse\n\t\t\tif (!error)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tstatus = error;\n\n\t\tdma_unmap_single(dev, request->dma_desc,\n\t\t\t\t TALITOS_DESC_SIZE,\n\t\t\t\t DMA_BIDIRECTIONAL);\n\n\t\t \n\t\tsaved_req.desc = request->desc;\n\t\tsaved_req.callback = request->callback;\n\t\tsaved_req.context = request->context;\n\n\t\t \n\t\tsmp_wmb();\n\t\trequest->desc = NULL;\n\n\t\t \n\t\tpriv->chan[ch].tail = (tail + 1) & (priv->fifo_len - 1);\n\n\t\tspin_unlock_irqrestore(&priv->chan[ch].tail_lock, flags);\n\n\t\tatomic_dec(&priv->chan[ch].submit_count);\n\n\t\tsaved_req.callback(dev, saved_req.desc, saved_req.context,\n\t\t\t\t   status);\n\t\t \n\t\tif (error && !reset_ch && status == error)\n\t\t\treturn;\n\t\tspin_lock_irqsave(&priv->chan[ch].tail_lock, flags);\n\t\ttail = priv->chan[ch].tail;\n\t}\n\n\tspin_unlock_irqrestore(&priv->chan[ch].tail_lock, flags);\n}\n\n \n#define DEF_TALITOS1_DONE(name, ch_done_mask)\t\t\t\t\\\nstatic void talitos1_done_##name(unsigned long data)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct device *dev = (struct device *)data;\t\t\t\\\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\t\t\\\n\tunsigned long flags;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (ch_done_mask & 0x10000000)\t\t\t\t\t\\\n\t\tflush_channel(dev, 0, 0, 0);\t\t\t\\\n\tif (ch_done_mask & 0x40000000)\t\t\t\t\t\\\n\t\tflush_channel(dev, 1, 0, 0);\t\t\t\\\n\tif (ch_done_mask & 0x00010000)\t\t\t\t\t\\\n\t\tflush_channel(dev, 2, 0, 0);\t\t\t\\\n\tif (ch_done_mask & 0x00040000)\t\t\t\t\t\\\n\t\tflush_channel(dev, 3, 0, 0);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\\\n\t \t\\\n\tspin_lock_irqsave(&priv->reg_lock, flags);\t\t\t\\\n\tclrbits32(priv->reg + TALITOS_IMR, ch_done_mask);\t\t\\\n\tclrbits32(priv->reg + TALITOS_IMR_LO, TALITOS1_IMR_LO_INIT);\t\\\n\tspin_unlock_irqrestore(&priv->reg_lock, flags);\t\t\t\\\n}\n\nDEF_TALITOS1_DONE(4ch, TALITOS1_ISR_4CHDONE)\nDEF_TALITOS1_DONE(ch0, TALITOS1_ISR_CH_0_DONE)\n\n#define DEF_TALITOS2_DONE(name, ch_done_mask)\t\t\t\t\\\nstatic void talitos2_done_##name(unsigned long data)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct device *dev = (struct device *)data;\t\t\t\\\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\t\t\\\n\tunsigned long flags;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (ch_done_mask & 1)\t\t\t\t\t\t\\\n\t\tflush_channel(dev, 0, 0, 0);\t\t\t\t\\\n\tif (ch_done_mask & (1 << 2))\t\t\t\t\t\\\n\t\tflush_channel(dev, 1, 0, 0);\t\t\t\t\\\n\tif (ch_done_mask & (1 << 4))\t\t\t\t\t\\\n\t\tflush_channel(dev, 2, 0, 0);\t\t\t\t\\\n\tif (ch_done_mask & (1 << 6))\t\t\t\t\t\\\n\t\tflush_channel(dev, 3, 0, 0);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\\\n\t \t\\\n\tspin_lock_irqsave(&priv->reg_lock, flags);\t\t\t\\\n\tsetbits32(priv->reg + TALITOS_IMR, ch_done_mask);\t\t\\\n\tsetbits32(priv->reg + TALITOS_IMR_LO, TALITOS2_IMR_LO_INIT);\t\\\n\tspin_unlock_irqrestore(&priv->reg_lock, flags);\t\t\t\\\n}\n\nDEF_TALITOS2_DONE(4ch, TALITOS2_ISR_4CHDONE)\nDEF_TALITOS2_DONE(ch0, TALITOS2_ISR_CH_0_DONE)\nDEF_TALITOS2_DONE(ch0_2, TALITOS2_ISR_CH_0_2_DONE)\nDEF_TALITOS2_DONE(ch1_3, TALITOS2_ISR_CH_1_3_DONE)\n\n \nstatic __be32 current_desc_hdr(struct device *dev, int ch)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tint tail, iter;\n\tdma_addr_t cur_desc;\n\n\tcur_desc = ((u64)in_be32(priv->chan[ch].reg + TALITOS_CDPR)) << 32;\n\tcur_desc |= in_be32(priv->chan[ch].reg + TALITOS_CDPR_LO);\n\n\tif (!cur_desc) {\n\t\tdev_err(dev, \"CDPR is NULL, giving up search for offending descriptor\\n\");\n\t\treturn 0;\n\t}\n\n\ttail = priv->chan[ch].tail;\n\n\titer = tail;\n\twhile (priv->chan[ch].fifo[iter].dma_desc != cur_desc &&\n\t       priv->chan[ch].fifo[iter].desc->next_desc != cpu_to_be32(cur_desc)) {\n\t\titer = (iter + 1) & (priv->fifo_len - 1);\n\t\tif (iter == tail) {\n\t\t\tdev_err(dev, \"couldn't locate current descriptor\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (priv->chan[ch].fifo[iter].desc->next_desc == cpu_to_be32(cur_desc)) {\n\t\tstruct talitos_edesc *edesc;\n\n\t\tedesc = container_of(priv->chan[ch].fifo[iter].desc,\n\t\t\t\t     struct talitos_edesc, desc);\n\t\treturn ((struct talitos_desc *)\n\t\t\t(edesc->buf + edesc->dma_len))->hdr;\n\t}\n\n\treturn priv->chan[ch].fifo[iter].desc->hdr;\n}\n\n \nstatic void report_eu_error(struct device *dev, int ch, __be32 desc_hdr)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tint i;\n\n\tif (!desc_hdr)\n\t\tdesc_hdr = cpu_to_be32(in_be32(priv->chan[ch].reg + TALITOS_DESCBUF));\n\n\tswitch (desc_hdr & DESC_HDR_SEL0_MASK) {\n\tcase DESC_HDR_SEL0_AFEU:\n\t\tdev_err(dev, \"AFEUISR 0x%08x_%08x\\n\",\n\t\t\tin_be32(priv->reg_afeu + TALITOS_EUISR),\n\t\t\tin_be32(priv->reg_afeu + TALITOS_EUISR_LO));\n\t\tbreak;\n\tcase DESC_HDR_SEL0_DEU:\n\t\tdev_err(dev, \"DEUISR 0x%08x_%08x\\n\",\n\t\t\tin_be32(priv->reg_deu + TALITOS_EUISR),\n\t\t\tin_be32(priv->reg_deu + TALITOS_EUISR_LO));\n\t\tbreak;\n\tcase DESC_HDR_SEL0_MDEUA:\n\tcase DESC_HDR_SEL0_MDEUB:\n\t\tdev_err(dev, \"MDEUISR 0x%08x_%08x\\n\",\n\t\t\tin_be32(priv->reg_mdeu + TALITOS_EUISR),\n\t\t\tin_be32(priv->reg_mdeu + TALITOS_EUISR_LO));\n\t\tbreak;\n\tcase DESC_HDR_SEL0_RNG:\n\t\tdev_err(dev, \"RNGUISR 0x%08x_%08x\\n\",\n\t\t\tin_be32(priv->reg_rngu + TALITOS_ISR),\n\t\t\tin_be32(priv->reg_rngu + TALITOS_ISR_LO));\n\t\tbreak;\n\tcase DESC_HDR_SEL0_PKEU:\n\t\tdev_err(dev, \"PKEUISR 0x%08x_%08x\\n\",\n\t\t\tin_be32(priv->reg_pkeu + TALITOS_EUISR),\n\t\t\tin_be32(priv->reg_pkeu + TALITOS_EUISR_LO));\n\t\tbreak;\n\tcase DESC_HDR_SEL0_AESU:\n\t\tdev_err(dev, \"AESUISR 0x%08x_%08x\\n\",\n\t\t\tin_be32(priv->reg_aesu + TALITOS_EUISR),\n\t\t\tin_be32(priv->reg_aesu + TALITOS_EUISR_LO));\n\t\tbreak;\n\tcase DESC_HDR_SEL0_CRCU:\n\t\tdev_err(dev, \"CRCUISR 0x%08x_%08x\\n\",\n\t\t\tin_be32(priv->reg_crcu + TALITOS_EUISR),\n\t\t\tin_be32(priv->reg_crcu + TALITOS_EUISR_LO));\n\t\tbreak;\n\tcase DESC_HDR_SEL0_KEU:\n\t\tdev_err(dev, \"KEUISR 0x%08x_%08x\\n\",\n\t\t\tin_be32(priv->reg_pkeu + TALITOS_EUISR),\n\t\t\tin_be32(priv->reg_pkeu + TALITOS_EUISR_LO));\n\t\tbreak;\n\t}\n\n\tswitch (desc_hdr & DESC_HDR_SEL1_MASK) {\n\tcase DESC_HDR_SEL1_MDEUA:\n\tcase DESC_HDR_SEL1_MDEUB:\n\t\tdev_err(dev, \"MDEUISR 0x%08x_%08x\\n\",\n\t\t\tin_be32(priv->reg_mdeu + TALITOS_EUISR),\n\t\t\tin_be32(priv->reg_mdeu + TALITOS_EUISR_LO));\n\t\tbreak;\n\tcase DESC_HDR_SEL1_CRCU:\n\t\tdev_err(dev, \"CRCUISR 0x%08x_%08x\\n\",\n\t\t\tin_be32(priv->reg_crcu + TALITOS_EUISR),\n\t\t\tin_be32(priv->reg_crcu + TALITOS_EUISR_LO));\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 8; i++)\n\t\tdev_err(dev, \"DESCBUF 0x%08x_%08x\\n\",\n\t\t\tin_be32(priv->chan[ch].reg + TALITOS_DESCBUF + 8*i),\n\t\t\tin_be32(priv->chan[ch].reg + TALITOS_DESCBUF_LO + 8*i));\n}\n\n \nstatic void talitos_error(struct device *dev, u32 isr, u32 isr_lo)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tunsigned int timeout = TALITOS_TIMEOUT;\n\tint ch, error, reset_dev = 0;\n\tu32 v_lo;\n\tbool is_sec1 = has_ftr_sec1(priv);\n\tint reset_ch = is_sec1 ? 1 : 0;  \n\n\tfor (ch = 0; ch < priv->num_channels; ch++) {\n\t\t \n\t\tif (is_sec1) {\n\t\t\t \n\t\t\tif (!(isr & (1 << (29 + (ch & 1) * 2 - (ch & 2) * 6))))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (!(isr & (1 << (ch * 2 + 1))))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terror = -EINVAL;\n\n\t\tv_lo = in_be32(priv->chan[ch].reg + TALITOS_CCPSR_LO);\n\n\t\tif (v_lo & TALITOS_CCPSR_LO_DOF) {\n\t\t\tdev_err(dev, \"double fetch fifo overflow error\\n\");\n\t\t\terror = -EAGAIN;\n\t\t\treset_ch = 1;\n\t\t}\n\t\tif (v_lo & TALITOS_CCPSR_LO_SOF) {\n\t\t\t \n\t\t\tdev_err(dev, \"single fetch fifo overflow error\\n\");\n\t\t\terror = -EAGAIN;\n\t\t}\n\t\tif (v_lo & TALITOS_CCPSR_LO_MDTE)\n\t\t\tdev_err(dev, \"master data transfer error\\n\");\n\t\tif (v_lo & TALITOS_CCPSR_LO_SGDLZ)\n\t\t\tdev_err(dev, is_sec1 ? \"pointer not complete error\\n\"\n\t\t\t\t\t     : \"s/g data length zero error\\n\");\n\t\tif (v_lo & TALITOS_CCPSR_LO_FPZ)\n\t\t\tdev_err(dev, is_sec1 ? \"parity error\\n\"\n\t\t\t\t\t     : \"fetch pointer zero error\\n\");\n\t\tif (v_lo & TALITOS_CCPSR_LO_IDH)\n\t\t\tdev_err(dev, \"illegal descriptor header error\\n\");\n\t\tif (v_lo & TALITOS_CCPSR_LO_IEU)\n\t\t\tdev_err(dev, is_sec1 ? \"static assignment error\\n\"\n\t\t\t\t\t     : \"invalid exec unit error\\n\");\n\t\tif (v_lo & TALITOS_CCPSR_LO_EU)\n\t\t\treport_eu_error(dev, ch, current_desc_hdr(dev, ch));\n\t\tif (!is_sec1) {\n\t\t\tif (v_lo & TALITOS_CCPSR_LO_GB)\n\t\t\t\tdev_err(dev, \"gather boundary error\\n\");\n\t\t\tif (v_lo & TALITOS_CCPSR_LO_GRL)\n\t\t\t\tdev_err(dev, \"gather return/length error\\n\");\n\t\t\tif (v_lo & TALITOS_CCPSR_LO_SB)\n\t\t\t\tdev_err(dev, \"scatter boundary error\\n\");\n\t\t\tif (v_lo & TALITOS_CCPSR_LO_SRL)\n\t\t\t\tdev_err(dev, \"scatter return/length error\\n\");\n\t\t}\n\n\t\tflush_channel(dev, ch, error, reset_ch);\n\n\t\tif (reset_ch) {\n\t\t\treset_channel(dev, ch);\n\t\t} else {\n\t\t\tsetbits32(priv->chan[ch].reg + TALITOS_CCCR,\n\t\t\t\t  TALITOS2_CCCR_CONT);\n\t\t\tsetbits32(priv->chan[ch].reg + TALITOS_CCCR_LO, 0);\n\t\t\twhile ((in_be32(priv->chan[ch].reg + TALITOS_CCCR) &\n\t\t\t       TALITOS2_CCCR_CONT) && --timeout)\n\t\t\t\tcpu_relax();\n\t\t\tif (timeout == 0) {\n\t\t\t\tdev_err(dev, \"failed to restart channel %d\\n\",\n\t\t\t\t\tch);\n\t\t\t\treset_dev = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (reset_dev || (is_sec1 && isr & ~TALITOS1_ISR_4CHERR) ||\n\t    (!is_sec1 && isr & ~TALITOS2_ISR_4CHERR) || isr_lo) {\n\t\tif (is_sec1 && (isr_lo & TALITOS1_ISR_TEA_ERR))\n\t\t\tdev_err(dev, \"TEA error: ISR 0x%08x_%08x\\n\",\n\t\t\t\tisr, isr_lo);\n\t\telse\n\t\t\tdev_err(dev, \"done overflow, internal time out, or \"\n\t\t\t\t\"rngu error: ISR 0x%08x_%08x\\n\", isr, isr_lo);\n\n\t\t \n\t\tfor (ch = 0; ch < priv->num_channels; ch++)\n\t\t\tflush_channel(dev, ch, -EIO, 1);\n\n\t\t \n\t\tinit_device(dev);\n\t}\n}\n\n#define DEF_TALITOS1_INTERRUPT(name, ch_done_mask, ch_err_mask, tlet)\t       \\\nstatic irqreturn_t talitos1_interrupt_##name(int irq, void *data)\t       \\\n{\t\t\t\t\t\t\t\t\t       \\\n\tstruct device *dev = data;\t\t\t\t\t       \\\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\t\t       \\\n\tu32 isr, isr_lo;\t\t\t\t\t\t       \\\n\tunsigned long flags;\t\t\t\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\tspin_lock_irqsave(&priv->reg_lock, flags);\t\t\t       \\\n\tisr = in_be32(priv->reg + TALITOS_ISR);\t\t\t\t       \\\n\tisr_lo = in_be32(priv->reg + TALITOS_ISR_LO);\t\t\t       \\\n\t \t\t\t\t\t       \\\n\tout_be32(priv->reg + TALITOS_ICR, isr & (ch_done_mask | ch_err_mask)); \\\n\tout_be32(priv->reg + TALITOS_ICR_LO, isr_lo);\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\tif (unlikely(isr & ch_err_mask || isr_lo & TALITOS1_IMR_LO_INIT)) {    \\\n\t\tspin_unlock_irqrestore(&priv->reg_lock, flags);\t\t       \\\n\t\ttalitos_error(dev, isr & ch_err_mask, isr_lo);\t\t       \\\n\t}\t\t\t\t\t\t\t\t       \\\n\telse {\t\t\t\t\t\t\t\t       \\\n\t\tif (likely(isr & ch_done_mask)) {\t\t\t       \\\n\t\t\t \t\t       \\\n\t\t\tsetbits32(priv->reg + TALITOS_IMR, ch_done_mask);      \\\n\t\t\t     \\\n\t\t\ttasklet_schedule(&priv->done_task[tlet]);\t       \\\n\t\t}\t\t\t\t\t\t\t       \\\n\t\tspin_unlock_irqrestore(&priv->reg_lock, flags);\t\t       \\\n\t}\t\t\t\t\t\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\treturn (isr & (ch_done_mask | ch_err_mask) || isr_lo) ? IRQ_HANDLED :  \\\n\t\t\t\t\t\t\t\tIRQ_NONE;      \\\n}\n\nDEF_TALITOS1_INTERRUPT(4ch, TALITOS1_ISR_4CHDONE, TALITOS1_ISR_4CHERR, 0)\n\n#define DEF_TALITOS2_INTERRUPT(name, ch_done_mask, ch_err_mask, tlet)\t       \\\nstatic irqreturn_t talitos2_interrupt_##name(int irq, void *data)\t       \\\n{\t\t\t\t\t\t\t\t\t       \\\n\tstruct device *dev = data;\t\t\t\t\t       \\\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\t\t       \\\n\tu32 isr, isr_lo;\t\t\t\t\t\t       \\\n\tunsigned long flags;\t\t\t\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\tspin_lock_irqsave(&priv->reg_lock, flags);\t\t\t       \\\n\tisr = in_be32(priv->reg + TALITOS_ISR);\t\t\t\t       \\\n\tisr_lo = in_be32(priv->reg + TALITOS_ISR_LO);\t\t\t       \\\n\t \t\t\t\t\t       \\\n\tout_be32(priv->reg + TALITOS_ICR, isr & (ch_done_mask | ch_err_mask)); \\\n\tout_be32(priv->reg + TALITOS_ICR_LO, isr_lo);\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\tif (unlikely(isr & ch_err_mask || isr_lo)) {\t\t\t       \\\n\t\tspin_unlock_irqrestore(&priv->reg_lock, flags);\t\t       \\\n\t\ttalitos_error(dev, isr & ch_err_mask, isr_lo);\t\t       \\\n\t}\t\t\t\t\t\t\t\t       \\\n\telse {\t\t\t\t\t\t\t\t       \\\n\t\tif (likely(isr & ch_done_mask)) {\t\t\t       \\\n\t\t\t \t\t       \\\n\t\t\tclrbits32(priv->reg + TALITOS_IMR, ch_done_mask);      \\\n\t\t\t     \\\n\t\t\ttasklet_schedule(&priv->done_task[tlet]);\t       \\\n\t\t}\t\t\t\t\t\t\t       \\\n\t\tspin_unlock_irqrestore(&priv->reg_lock, flags);\t\t       \\\n\t}\t\t\t\t\t\t\t\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\treturn (isr & (ch_done_mask | ch_err_mask) || isr_lo) ? IRQ_HANDLED :  \\\n\t\t\t\t\t\t\t\tIRQ_NONE;      \\\n}\n\nDEF_TALITOS2_INTERRUPT(4ch, TALITOS2_ISR_4CHDONE, TALITOS2_ISR_4CHERR, 0)\nDEF_TALITOS2_INTERRUPT(ch0_2, TALITOS2_ISR_CH_0_2_DONE, TALITOS2_ISR_CH_0_2_ERR,\n\t\t       0)\nDEF_TALITOS2_INTERRUPT(ch1_3, TALITOS2_ISR_CH_1_3_DONE, TALITOS2_ISR_CH_1_3_ERR,\n\t\t       1)\n\n \nstatic int talitos_rng_data_present(struct hwrng *rng, int wait)\n{\n\tstruct device *dev = (struct device *)rng->priv;\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tu32 ofl;\n\tint i;\n\n\tfor (i = 0; i < 20; i++) {\n\t\tofl = in_be32(priv->reg_rngu + TALITOS_EUSR_LO) &\n\t\t      TALITOS_RNGUSR_LO_OFL;\n\t\tif (ofl || !wait)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\treturn !!ofl;\n}\n\nstatic int talitos_rng_data_read(struct hwrng *rng, u32 *data)\n{\n\tstruct device *dev = (struct device *)rng->priv;\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\n\t \n\t*data = in_be32(priv->reg_rngu + TALITOS_EU_FIFO);\n\t*data = in_be32(priv->reg_rngu + TALITOS_EU_FIFO_LO);\n\n\treturn sizeof(u32);\n}\n\nstatic int talitos_rng_init(struct hwrng *rng)\n{\n\tstruct device *dev = (struct device *)rng->priv;\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tunsigned int timeout = TALITOS_TIMEOUT;\n\n\tsetbits32(priv->reg_rngu + TALITOS_EURCR_LO, TALITOS_RNGURCR_LO_SR);\n\twhile (!(in_be32(priv->reg_rngu + TALITOS_EUSR_LO)\n\t\t & TALITOS_RNGUSR_LO_RD)\n\t       && --timeout)\n\t\tcpu_relax();\n\tif (timeout == 0) {\n\t\tdev_err(dev, \"failed to reset rng hw\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsetbits32(priv->reg_rngu + TALITOS_EUDSR_LO, 0);\n\n\treturn 0;\n}\n\nstatic int talitos_register_rng(struct device *dev)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tint err;\n\n\tpriv->rng.name\t\t= dev_driver_string(dev);\n\tpriv->rng.init\t\t= talitos_rng_init;\n\tpriv->rng.data_present\t= talitos_rng_data_present;\n\tpriv->rng.data_read\t= talitos_rng_data_read;\n\tpriv->rng.priv\t\t= (unsigned long)dev;\n\n\terr = hwrng_register(&priv->rng);\n\tif (!err)\n\t\tpriv->rng_registered = true;\n\n\treturn err;\n}\n\nstatic void talitos_unregister_rng(struct device *dev)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\n\tif (!priv->rng_registered)\n\t\treturn;\n\n\thwrng_unregister(&priv->rng);\n\tpriv->rng_registered = false;\n}\n\n \n#define TALITOS_CRA_PRIORITY\t\t3000\n \n#define TALITOS_CRA_PRIORITY_AEAD_HSNA\t(TALITOS_CRA_PRIORITY - 1)\n#ifdef CONFIG_CRYPTO_DEV_TALITOS2\n#define TALITOS_MAX_KEY_SIZE\t\t(AES_MAX_KEY_SIZE + SHA512_BLOCK_SIZE)\n#else\n#define TALITOS_MAX_KEY_SIZE\t\t(AES_MAX_KEY_SIZE + SHA256_BLOCK_SIZE)\n#endif\n#define TALITOS_MAX_IV_LENGTH\t\t16  \n\nstruct talitos_ctx {\n\tstruct device *dev;\n\tint ch;\n\t__be32 desc_hdr_template;\n\tu8 key[TALITOS_MAX_KEY_SIZE];\n\tu8 iv[TALITOS_MAX_IV_LENGTH];\n\tdma_addr_t dma_key;\n\tunsigned int keylen;\n\tunsigned int enckeylen;\n\tunsigned int authkeylen;\n};\n\n#define HASH_MAX_BLOCK_SIZE\t\tSHA512_BLOCK_SIZE\n#define TALITOS_MDEU_MAX_CONTEXT_SIZE\tTALITOS_MDEU_CONTEXT_SIZE_SHA384_SHA512\n\nstruct talitos_ahash_req_ctx {\n\tu32 hw_context[TALITOS_MDEU_MAX_CONTEXT_SIZE / sizeof(u32)];\n\tunsigned int hw_context_size;\n\tu8 buf[2][HASH_MAX_BLOCK_SIZE];\n\tint buf_idx;\n\tunsigned int swinit;\n\tunsigned int first;\n\tunsigned int last;\n\tunsigned int to_hash_later;\n\tunsigned int nbuf;\n\tstruct scatterlist bufsl[2];\n\tstruct scatterlist *psrc;\n};\n\nstruct talitos_export_state {\n\tu32 hw_context[TALITOS_MDEU_MAX_CONTEXT_SIZE / sizeof(u32)];\n\tu8 buf[HASH_MAX_BLOCK_SIZE];\n\tunsigned int swinit;\n\tunsigned int first;\n\tunsigned int last;\n\tunsigned int to_hash_later;\n\tunsigned int nbuf;\n};\n\nstatic int aead_setkey(struct crypto_aead *authenc,\n\t\t       const u8 *key, unsigned int keylen)\n{\n\tstruct talitos_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct device *dev = ctx->dev;\n\tstruct crypto_authenc_keys keys;\n\n\tif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\n\t\tgoto badkey;\n\n\tif (keys.authkeylen + keys.enckeylen > TALITOS_MAX_KEY_SIZE)\n\t\tgoto badkey;\n\n\tif (ctx->keylen)\n\t\tdma_unmap_single(dev, ctx->dma_key, ctx->keylen, DMA_TO_DEVICE);\n\n\tmemcpy(ctx->key, keys.authkey, keys.authkeylen);\n\tmemcpy(&ctx->key[keys.authkeylen], keys.enckey, keys.enckeylen);\n\n\tctx->keylen = keys.authkeylen + keys.enckeylen;\n\tctx->enckeylen = keys.enckeylen;\n\tctx->authkeylen = keys.authkeylen;\n\tctx->dma_key = dma_map_single(dev, ctx->key, ctx->keylen,\n\t\t\t\t      DMA_TO_DEVICE);\n\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn 0;\n\nbadkey:\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn -EINVAL;\n}\n\nstatic int aead_des3_setkey(struct crypto_aead *authenc,\n\t\t\t    const u8 *key, unsigned int keylen)\n{\n\tstruct talitos_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct device *dev = ctx->dev;\n\tstruct crypto_authenc_keys keys;\n\tint err;\n\n\terr = crypto_authenc_extractkeys(&keys, key, keylen);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (keys.authkeylen + keys.enckeylen > TALITOS_MAX_KEY_SIZE)\n\t\tgoto out;\n\n\terr = verify_aead_des3_key(authenc, keys.enckey, keys.enckeylen);\n\tif (err)\n\t\tgoto out;\n\n\tif (ctx->keylen)\n\t\tdma_unmap_single(dev, ctx->dma_key, ctx->keylen, DMA_TO_DEVICE);\n\n\tmemcpy(ctx->key, keys.authkey, keys.authkeylen);\n\tmemcpy(&ctx->key[keys.authkeylen], keys.enckey, keys.enckeylen);\n\n\tctx->keylen = keys.authkeylen + keys.enckeylen;\n\tctx->enckeylen = keys.enckeylen;\n\tctx->authkeylen = keys.authkeylen;\n\tctx->dma_key = dma_map_single(dev, ctx->key, ctx->keylen,\n\t\t\t\t      DMA_TO_DEVICE);\n\nout:\n\tmemzero_explicit(&keys, sizeof(keys));\n\treturn err;\n}\n\nstatic void talitos_sg_unmap(struct device *dev,\n\t\t\t     struct talitos_edesc *edesc,\n\t\t\t     struct scatterlist *src,\n\t\t\t     struct scatterlist *dst,\n\t\t\t     unsigned int len, unsigned int offset)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tbool is_sec1 = has_ftr_sec1(priv);\n\tunsigned int src_nents = edesc->src_nents ? : 1;\n\tunsigned int dst_nents = edesc->dst_nents ? : 1;\n\n\tif (is_sec1 && dst && dst_nents > 1) {\n\t\tdma_sync_single_for_device(dev, edesc->dma_link_tbl + offset,\n\t\t\t\t\t   len, DMA_FROM_DEVICE);\n\t\tsg_pcopy_from_buffer(dst, dst_nents, edesc->buf + offset, len,\n\t\t\t\t     offset);\n\t}\n\tif (src != dst) {\n\t\tif (src_nents == 1 || !is_sec1)\n\t\t\tdma_unmap_sg(dev, src, src_nents, DMA_TO_DEVICE);\n\n\t\tif (dst && (dst_nents == 1 || !is_sec1))\n\t\t\tdma_unmap_sg(dev, dst, dst_nents, DMA_FROM_DEVICE);\n\t} else if (src_nents == 1 || !is_sec1) {\n\t\tdma_unmap_sg(dev, src, src_nents, DMA_BIDIRECTIONAL);\n\t}\n}\n\nstatic void ipsec_esp_unmap(struct device *dev,\n\t\t\t    struct talitos_edesc *edesc,\n\t\t\t    struct aead_request *areq, bool encrypt)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(areq);\n\tstruct talitos_ctx *ctx = crypto_aead_ctx(aead);\n\tunsigned int ivsize = crypto_aead_ivsize(aead);\n\tunsigned int authsize = crypto_aead_authsize(aead);\n\tunsigned int cryptlen = areq->cryptlen - (encrypt ? 0 : authsize);\n\tbool is_ipsec_esp = edesc->desc.hdr & DESC_HDR_TYPE_IPSEC_ESP;\n\tstruct talitos_ptr *civ_ptr = &edesc->desc.ptr[is_ipsec_esp ? 2 : 3];\n\n\tif (is_ipsec_esp)\n\t\tunmap_single_talitos_ptr(dev, &edesc->desc.ptr[6],\n\t\t\t\t\t DMA_FROM_DEVICE);\n\tunmap_single_talitos_ptr(dev, civ_ptr, DMA_TO_DEVICE);\n\n\ttalitos_sg_unmap(dev, edesc, areq->src, areq->dst,\n\t\t\t cryptlen + authsize, areq->assoclen);\n\n\tif (edesc->dma_len)\n\t\tdma_unmap_single(dev, edesc->dma_link_tbl, edesc->dma_len,\n\t\t\t\t DMA_BIDIRECTIONAL);\n\n\tif (!is_ipsec_esp) {\n\t\tunsigned int dst_nents = edesc->dst_nents ? : 1;\n\n\t\tsg_pcopy_to_buffer(areq->dst, dst_nents, ctx->iv, ivsize,\n\t\t\t\t   areq->assoclen + cryptlen - ivsize);\n\t}\n}\n\n \nstatic void ipsec_esp_encrypt_done(struct device *dev,\n\t\t\t\t   struct talitos_desc *desc, void *context,\n\t\t\t\t   int err)\n{\n\tstruct aead_request *areq = context;\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(areq);\n\tunsigned int ivsize = crypto_aead_ivsize(authenc);\n\tstruct talitos_edesc *edesc;\n\n\tedesc = container_of(desc, struct talitos_edesc, desc);\n\n\tipsec_esp_unmap(dev, edesc, areq, true);\n\n\tdma_unmap_single(dev, edesc->iv_dma, ivsize, DMA_TO_DEVICE);\n\n\tkfree(edesc);\n\n\taead_request_complete(areq, err);\n}\n\nstatic void ipsec_esp_decrypt_swauth_done(struct device *dev,\n\t\t\t\t\t  struct talitos_desc *desc,\n\t\t\t\t\t  void *context, int err)\n{\n\tstruct aead_request *req = context;\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\n\tunsigned int authsize = crypto_aead_authsize(authenc);\n\tstruct talitos_edesc *edesc;\n\tchar *oicv, *icv;\n\n\tedesc = container_of(desc, struct talitos_edesc, desc);\n\n\tipsec_esp_unmap(dev, edesc, req, false);\n\n\tif (!err) {\n\t\t \n\t\toicv = edesc->buf + edesc->dma_len;\n\t\ticv = oicv - authsize;\n\n\t\terr = crypto_memneq(oicv, icv, authsize) ? -EBADMSG : 0;\n\t}\n\n\tkfree(edesc);\n\n\taead_request_complete(req, err);\n}\n\nstatic void ipsec_esp_decrypt_hwauth_done(struct device *dev,\n\t\t\t\t\t  struct talitos_desc *desc,\n\t\t\t\t\t  void *context, int err)\n{\n\tstruct aead_request *req = context;\n\tstruct talitos_edesc *edesc;\n\n\tedesc = container_of(desc, struct talitos_edesc, desc);\n\n\tipsec_esp_unmap(dev, edesc, req, false);\n\n\t \n\tif (!err && ((desc->hdr_lo & DESC_HDR_LO_ICCR1_MASK) !=\n\t\t     DESC_HDR_LO_ICCR1_PASS))\n\t\terr = -EBADMSG;\n\n\tkfree(edesc);\n\n\taead_request_complete(req, err);\n}\n\n \nstatic int sg_to_link_tbl_offset(struct scatterlist *sg, int sg_count,\n\t\t\t\t unsigned int offset, int datalen, int elen,\n\t\t\t\t struct talitos_ptr *link_tbl_ptr, int align)\n{\n\tint n_sg = elen ? sg_count + 1 : sg_count;\n\tint count = 0;\n\tint cryptlen = datalen + elen;\n\tint padding = ALIGN(cryptlen, align) - cryptlen;\n\n\twhile (cryptlen && sg && n_sg--) {\n\t\tunsigned int len = sg_dma_len(sg);\n\n\t\tif (offset >= len) {\n\t\t\toffset -= len;\n\t\t\tgoto next;\n\t\t}\n\n\t\tlen -= offset;\n\n\t\tif (len > cryptlen)\n\t\t\tlen = cryptlen;\n\n\t\tif (datalen > 0 && len > datalen) {\n\t\t\tto_talitos_ptr(link_tbl_ptr + count,\n\t\t\t\t       sg_dma_address(sg) + offset, datalen, 0);\n\t\t\tto_talitos_ptr_ext_set(link_tbl_ptr + count, 0, 0);\n\t\t\tcount++;\n\t\t\tlen -= datalen;\n\t\t\toffset += datalen;\n\t\t}\n\t\tto_talitos_ptr(link_tbl_ptr + count,\n\t\t\t       sg_dma_address(sg) + offset, sg_next(sg) ? len : len + padding, 0);\n\t\tto_talitos_ptr_ext_set(link_tbl_ptr + count, 0, 0);\n\t\tcount++;\n\t\tcryptlen -= len;\n\t\tdatalen -= len;\n\t\toffset = 0;\n\nnext:\n\t\tsg = sg_next(sg);\n\t}\n\n\t \n\tif (count > 0)\n\t\tto_talitos_ptr_ext_set(link_tbl_ptr + count - 1,\n\t\t\t\t       DESC_PTR_LNKTBL_RET, 0);\n\n\treturn count;\n}\n\nstatic int talitos_sg_map_ext(struct device *dev, struct scatterlist *src,\n\t\t\t      unsigned int len, struct talitos_edesc *edesc,\n\t\t\t      struct talitos_ptr *ptr, int sg_count,\n\t\t\t      unsigned int offset, int tbl_off, int elen,\n\t\t\t      bool force, int align)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tbool is_sec1 = has_ftr_sec1(priv);\n\tint aligned_len = ALIGN(len, align);\n\n\tif (!src) {\n\t\tto_talitos_ptr(ptr, 0, 0, is_sec1);\n\t\treturn 1;\n\t}\n\tto_talitos_ptr_ext_set(ptr, elen, is_sec1);\n\tif (sg_count == 1 && !force) {\n\t\tto_talitos_ptr(ptr, sg_dma_address(src) + offset, aligned_len, is_sec1);\n\t\treturn sg_count;\n\t}\n\tif (is_sec1) {\n\t\tto_talitos_ptr(ptr, edesc->dma_link_tbl + offset, aligned_len, is_sec1);\n\t\treturn sg_count;\n\t}\n\tsg_count = sg_to_link_tbl_offset(src, sg_count, offset, len, elen,\n\t\t\t\t\t &edesc->link_tbl[tbl_off], align);\n\tif (sg_count == 1 && !force) {\n\t\t \n\t\tcopy_talitos_ptr(ptr, &edesc->link_tbl[tbl_off], is_sec1);\n\t\treturn sg_count;\n\t}\n\tto_talitos_ptr(ptr, edesc->dma_link_tbl +\n\t\t\t    tbl_off * sizeof(struct talitos_ptr), aligned_len, is_sec1);\n\tto_talitos_ptr_ext_or(ptr, DESC_PTR_LNKTBL_JUMP, is_sec1);\n\n\treturn sg_count;\n}\n\nstatic int talitos_sg_map(struct device *dev, struct scatterlist *src,\n\t\t\t  unsigned int len, struct talitos_edesc *edesc,\n\t\t\t  struct talitos_ptr *ptr, int sg_count,\n\t\t\t  unsigned int offset, int tbl_off)\n{\n\treturn talitos_sg_map_ext(dev, src, len, edesc, ptr, sg_count, offset,\n\t\t\t\t  tbl_off, 0, false, 1);\n}\n\n \nstatic int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,\n\t\t     bool encrypt,\n\t\t     void (*callback)(struct device *dev,\n\t\t\t\t      struct talitos_desc *desc,\n\t\t\t\t      void *context, int error))\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(areq);\n\tunsigned int authsize = crypto_aead_authsize(aead);\n\tstruct talitos_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct device *dev = ctx->dev;\n\tstruct talitos_desc *desc = &edesc->desc;\n\tunsigned int cryptlen = areq->cryptlen - (encrypt ? 0 : authsize);\n\tunsigned int ivsize = crypto_aead_ivsize(aead);\n\tint tbl_off = 0;\n\tint sg_count, ret;\n\tint elen = 0;\n\tbool sync_needed = false;\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tbool is_sec1 = has_ftr_sec1(priv);\n\tbool is_ipsec_esp = desc->hdr & DESC_HDR_TYPE_IPSEC_ESP;\n\tstruct talitos_ptr *civ_ptr = &desc->ptr[is_ipsec_esp ? 2 : 3];\n\tstruct talitos_ptr *ckey_ptr = &desc->ptr[is_ipsec_esp ? 3 : 2];\n\tdma_addr_t dma_icv = edesc->dma_link_tbl + edesc->dma_len - authsize;\n\n\t \n\tto_talitos_ptr(&desc->ptr[0], ctx->dma_key, ctx->authkeylen, is_sec1);\n\n\tsg_count = edesc->src_nents ?: 1;\n\tif (is_sec1 && sg_count > 1)\n\t\tsg_copy_to_buffer(areq->src, sg_count, edesc->buf,\n\t\t\t\t  areq->assoclen + cryptlen);\n\telse\n\t\tsg_count = dma_map_sg(dev, areq->src, sg_count,\n\t\t\t\t      (areq->src == areq->dst) ?\n\t\t\t\t      DMA_BIDIRECTIONAL : DMA_TO_DEVICE);\n\n\t \n\tret = talitos_sg_map(dev, areq->src, areq->assoclen, edesc,\n\t\t\t     &desc->ptr[1], sg_count, 0, tbl_off);\n\n\tif (ret > 1) {\n\t\ttbl_off += ret;\n\t\tsync_needed = true;\n\t}\n\n\t \n\tto_talitos_ptr(civ_ptr, edesc->iv_dma, ivsize, is_sec1);\n\n\t \n\tto_talitos_ptr(ckey_ptr, ctx->dma_key  + ctx->authkeylen,\n\t\t       ctx->enckeylen, is_sec1);\n\n\t \n\tif (is_ipsec_esp && (desc->hdr & DESC_HDR_MODE1_MDEU_CICV))\n\t\telen = authsize;\n\n\tret = talitos_sg_map_ext(dev, areq->src, cryptlen, edesc, &desc->ptr[4],\n\t\t\t\t sg_count, areq->assoclen, tbl_off, elen,\n\t\t\t\t false, 1);\n\n\tif (ret > 1) {\n\t\ttbl_off += ret;\n\t\tsync_needed = true;\n\t}\n\n\t \n\tif (areq->src != areq->dst) {\n\t\tsg_count = edesc->dst_nents ? : 1;\n\t\tif (!is_sec1 || sg_count == 1)\n\t\t\tdma_map_sg(dev, areq->dst, sg_count, DMA_FROM_DEVICE);\n\t}\n\n\tif (is_ipsec_esp && encrypt)\n\t\telen = authsize;\n\telse\n\t\telen = 0;\n\tret = talitos_sg_map_ext(dev, areq->dst, cryptlen, edesc, &desc->ptr[5],\n\t\t\t\t sg_count, areq->assoclen, tbl_off, elen,\n\t\t\t\t is_ipsec_esp && !encrypt, 1);\n\ttbl_off += ret;\n\n\tif (!encrypt && is_ipsec_esp) {\n\t\tstruct talitos_ptr *tbl_ptr = &edesc->link_tbl[tbl_off];\n\n\t\t \n\t\tto_talitos_ptr_ext_set(tbl_ptr - 1, 0, is_sec1);\n\t\tto_talitos_ptr_ext_set(tbl_ptr, DESC_PTR_LNKTBL_RET, is_sec1);\n\n\t\t \n\t\tto_talitos_ptr(tbl_ptr, dma_icv, authsize, is_sec1);\n\t\tto_talitos_ptr_ext_or(&desc->ptr[5], authsize, is_sec1);\n\t\tsync_needed = true;\n\t} else if (!encrypt) {\n\t\tto_talitos_ptr(&desc->ptr[6], dma_icv, authsize, is_sec1);\n\t\tsync_needed = true;\n\t} else if (!is_ipsec_esp) {\n\t\ttalitos_sg_map(dev, areq->dst, authsize, edesc, &desc->ptr[6],\n\t\t\t       sg_count, areq->assoclen + cryptlen, tbl_off);\n\t}\n\n\t \n\tif (is_ipsec_esp)\n\t\tmap_single_talitos_ptr(dev, &desc->ptr[6], ivsize, ctx->iv,\n\t\t\t\t       DMA_FROM_DEVICE);\n\n\tif (sync_needed)\n\t\tdma_sync_single_for_device(dev, edesc->dma_link_tbl,\n\t\t\t\t\t   edesc->dma_len,\n\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\n\tret = talitos_submit(dev, ctx->ch, desc, callback, areq);\n\tif (ret != -EINPROGRESS) {\n\t\tipsec_esp_unmap(dev, edesc, areq, encrypt);\n\t\tkfree(edesc);\n\t}\n\treturn ret;\n}\n\n \nstatic struct talitos_edesc *talitos_edesc_alloc(struct device *dev,\n\t\t\t\t\t\t struct scatterlist *src,\n\t\t\t\t\t\t struct scatterlist *dst,\n\t\t\t\t\t\t u8 *iv,\n\t\t\t\t\t\t unsigned int assoclen,\n\t\t\t\t\t\t unsigned int cryptlen,\n\t\t\t\t\t\t unsigned int authsize,\n\t\t\t\t\t\t unsigned int ivsize,\n\t\t\t\t\t\t int icv_stashing,\n\t\t\t\t\t\t u32 cryptoflags,\n\t\t\t\t\t\t bool encrypt)\n{\n\tstruct talitos_edesc *edesc;\n\tint src_nents, dst_nents, alloc_len, dma_len, src_len, dst_len;\n\tdma_addr_t iv_dma = 0;\n\tgfp_t flags = cryptoflags & CRYPTO_TFM_REQ_MAY_SLEEP ? GFP_KERNEL :\n\t\t      GFP_ATOMIC;\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tbool is_sec1 = has_ftr_sec1(priv);\n\tint max_len = is_sec1 ? TALITOS1_MAX_DATA_LEN : TALITOS2_MAX_DATA_LEN;\n\n\tif (cryptlen + authsize > max_len) {\n\t\tdev_err(dev, \"length exceeds h/w max limit\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!dst || dst == src) {\n\t\tsrc_len = assoclen + cryptlen + authsize;\n\t\tsrc_nents = sg_nents_for_len(src, src_len);\n\t\tif (src_nents < 0) {\n\t\t\tdev_err(dev, \"Invalid number of src SG.\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tsrc_nents = (src_nents == 1) ? 0 : src_nents;\n\t\tdst_nents = dst ? src_nents : 0;\n\t\tdst_len = 0;\n\t} else {  \n\t\tsrc_len = assoclen + cryptlen + (encrypt ? 0 : authsize);\n\t\tsrc_nents = sg_nents_for_len(src, src_len);\n\t\tif (src_nents < 0) {\n\t\t\tdev_err(dev, \"Invalid number of src SG.\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tsrc_nents = (src_nents == 1) ? 0 : src_nents;\n\t\tdst_len = assoclen + cryptlen + (encrypt ? authsize : 0);\n\t\tdst_nents = sg_nents_for_len(dst, dst_len);\n\t\tif (dst_nents < 0) {\n\t\t\tdev_err(dev, \"Invalid number of dst SG.\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdst_nents = (dst_nents == 1) ? 0 : dst_nents;\n\t}\n\n\t \n\talloc_len = sizeof(struct talitos_edesc);\n\tif (src_nents || dst_nents || !encrypt) {\n\t\tif (is_sec1)\n\t\t\tdma_len = (src_nents ? src_len : 0) +\n\t\t\t\t  (dst_nents ? dst_len : 0) + authsize;\n\t\telse\n\t\t\tdma_len = (src_nents + dst_nents + 2) *\n\t\t\t\t  sizeof(struct talitos_ptr) + authsize;\n\t\talloc_len += dma_len;\n\t} else {\n\t\tdma_len = 0;\n\t}\n\talloc_len += icv_stashing ? authsize : 0;\n\n\t \n\tif (is_sec1 && !dst)\n\t\talloc_len += sizeof(struct talitos_desc);\n\talloc_len += ivsize;\n\n\tedesc = kmalloc(ALIGN(alloc_len, dma_get_cache_alignment()), flags);\n\tif (!edesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (ivsize) {\n\t\tiv = memcpy(((u8 *)edesc) + alloc_len - ivsize, iv, ivsize);\n\t\tiv_dma = dma_map_single(dev, iv, ivsize, DMA_TO_DEVICE);\n\t}\n\tmemset(&edesc->desc, 0, sizeof(edesc->desc));\n\n\tedesc->src_nents = src_nents;\n\tedesc->dst_nents = dst_nents;\n\tedesc->iv_dma = iv_dma;\n\tedesc->dma_len = dma_len;\n\tif (dma_len)\n\t\tedesc->dma_link_tbl = dma_map_single(dev, &edesc->link_tbl[0],\n\t\t\t\t\t\t     edesc->dma_len,\n\t\t\t\t\t\t     DMA_BIDIRECTIONAL);\n\n\treturn edesc;\n}\n\nstatic struct talitos_edesc *aead_edesc_alloc(struct aead_request *areq, u8 *iv,\n\t\t\t\t\t      int icv_stashing, bool encrypt)\n{\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(areq);\n\tunsigned int authsize = crypto_aead_authsize(authenc);\n\tstruct talitos_ctx *ctx = crypto_aead_ctx(authenc);\n\tunsigned int ivsize = crypto_aead_ivsize(authenc);\n\tunsigned int cryptlen = areq->cryptlen - (encrypt ? 0 : authsize);\n\n\treturn talitos_edesc_alloc(ctx->dev, areq->src, areq->dst,\n\t\t\t\t   iv, areq->assoclen, cryptlen,\n\t\t\t\t   authsize, ivsize, icv_stashing,\n\t\t\t\t   areq->base.flags, encrypt);\n}\n\nstatic int aead_encrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\n\tstruct talitos_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct talitos_edesc *edesc;\n\n\t \n\tedesc = aead_edesc_alloc(req, req->iv, 0, true);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\t \n\tedesc->desc.hdr = ctx->desc_hdr_template | DESC_HDR_MODE0_ENCRYPT;\n\n\treturn ipsec_esp(edesc, req, true, ipsec_esp_encrypt_done);\n}\n\nstatic int aead_decrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\n\tunsigned int authsize = crypto_aead_authsize(authenc);\n\tstruct talitos_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct talitos_private *priv = dev_get_drvdata(ctx->dev);\n\tstruct talitos_edesc *edesc;\n\tvoid *icvdata;\n\n\t \n\tedesc = aead_edesc_alloc(req, req->iv, 1, false);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\tif ((edesc->desc.hdr & DESC_HDR_TYPE_IPSEC_ESP) &&\n\t    (priv->features & TALITOS_FTR_HW_AUTH_CHECK) &&\n\t    ((!edesc->src_nents && !edesc->dst_nents) ||\n\t     priv->features & TALITOS_FTR_SRC_LINK_TBL_LEN_INCLUDES_EXTENT)) {\n\n\t\t \n\t\tedesc->desc.hdr = ctx->desc_hdr_template |\n\t\t\t\t  DESC_HDR_DIR_INBOUND |\n\t\t\t\t  DESC_HDR_MODE1_MDEU_CICV;\n\n\t\t \n\n\t\treturn ipsec_esp(edesc, req, false,\n\t\t\t\t ipsec_esp_decrypt_hwauth_done);\n\t}\n\n\t \n\tedesc->desc.hdr = ctx->desc_hdr_template | DESC_HDR_DIR_INBOUND;\n\n\t \n\ticvdata = edesc->buf + edesc->dma_len;\n\n\tsg_pcopy_to_buffer(req->src, edesc->src_nents ? : 1, icvdata, authsize,\n\t\t\t   req->assoclen + req->cryptlen - authsize);\n\n\treturn ipsec_esp(edesc, req, false, ipsec_esp_decrypt_swauth_done);\n}\n\nstatic int skcipher_setkey(struct crypto_skcipher *cipher,\n\t\t\t     const u8 *key, unsigned int keylen)\n{\n\tstruct talitos_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tstruct device *dev = ctx->dev;\n\n\tif (ctx->keylen)\n\t\tdma_unmap_single(dev, ctx->dma_key, ctx->keylen, DMA_TO_DEVICE);\n\n\tmemcpy(&ctx->key, key, keylen);\n\tctx->keylen = keylen;\n\n\tctx->dma_key = dma_map_single(dev, ctx->key, keylen, DMA_TO_DEVICE);\n\n\treturn 0;\n}\n\nstatic int skcipher_des_setkey(struct crypto_skcipher *cipher,\n\t\t\t\t const u8 *key, unsigned int keylen)\n{\n\treturn verify_skcipher_des_key(cipher, key) ?:\n\t       skcipher_setkey(cipher, key, keylen);\n}\n\nstatic int skcipher_des3_setkey(struct crypto_skcipher *cipher,\n\t\t\t\t  const u8 *key, unsigned int keylen)\n{\n\treturn verify_skcipher_des3_key(cipher, key) ?:\n\t       skcipher_setkey(cipher, key, keylen);\n}\n\nstatic int skcipher_aes_setkey(struct crypto_skcipher *cipher,\n\t\t\t\t  const u8 *key, unsigned int keylen)\n{\n\tif (keylen == AES_KEYSIZE_128 || keylen == AES_KEYSIZE_192 ||\n\t    keylen == AES_KEYSIZE_256)\n\t\treturn skcipher_setkey(cipher, key, keylen);\n\n\treturn -EINVAL;\n}\n\nstatic void common_nonsnoop_unmap(struct device *dev,\n\t\t\t\t  struct talitos_edesc *edesc,\n\t\t\t\t  struct skcipher_request *areq)\n{\n\tunmap_single_talitos_ptr(dev, &edesc->desc.ptr[5], DMA_FROM_DEVICE);\n\n\ttalitos_sg_unmap(dev, edesc, areq->src, areq->dst, areq->cryptlen, 0);\n\tunmap_single_talitos_ptr(dev, &edesc->desc.ptr[1], DMA_TO_DEVICE);\n\n\tif (edesc->dma_len)\n\t\tdma_unmap_single(dev, edesc->dma_link_tbl, edesc->dma_len,\n\t\t\t\t DMA_BIDIRECTIONAL);\n}\n\nstatic void skcipher_done(struct device *dev,\n\t\t\t    struct talitos_desc *desc, void *context,\n\t\t\t    int err)\n{\n\tstruct skcipher_request *areq = context;\n\tstruct crypto_skcipher *cipher = crypto_skcipher_reqtfm(areq);\n\tstruct talitos_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tunsigned int ivsize = crypto_skcipher_ivsize(cipher);\n\tstruct talitos_edesc *edesc;\n\n\tedesc = container_of(desc, struct talitos_edesc, desc);\n\n\tcommon_nonsnoop_unmap(dev, edesc, areq);\n\tmemcpy(areq->iv, ctx->iv, ivsize);\n\n\tkfree(edesc);\n\n\tskcipher_request_complete(areq, err);\n}\n\nstatic int common_nonsnoop(struct talitos_edesc *edesc,\n\t\t\t   struct skcipher_request *areq,\n\t\t\t   void (*callback) (struct device *dev,\n\t\t\t\t\t     struct talitos_desc *desc,\n\t\t\t\t\t     void *context, int error))\n{\n\tstruct crypto_skcipher *cipher = crypto_skcipher_reqtfm(areq);\n\tstruct talitos_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tstruct device *dev = ctx->dev;\n\tstruct talitos_desc *desc = &edesc->desc;\n\tunsigned int cryptlen = areq->cryptlen;\n\tunsigned int ivsize = crypto_skcipher_ivsize(cipher);\n\tint sg_count, ret;\n\tbool sync_needed = false;\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tbool is_sec1 = has_ftr_sec1(priv);\n\tbool is_ctr = (desc->hdr & DESC_HDR_SEL0_MASK) == DESC_HDR_SEL0_AESU &&\n\t\t      (desc->hdr & DESC_HDR_MODE0_AESU_MASK) == DESC_HDR_MODE0_AESU_CTR;\n\n\t \n\n\t \n\tto_talitos_ptr(&desc->ptr[1], edesc->iv_dma, ivsize, is_sec1);\n\n\t \n\tto_talitos_ptr(&desc->ptr[2], ctx->dma_key, ctx->keylen, is_sec1);\n\n\tsg_count = edesc->src_nents ?: 1;\n\tif (is_sec1 && sg_count > 1)\n\t\tsg_copy_to_buffer(areq->src, sg_count, edesc->buf,\n\t\t\t\t  cryptlen);\n\telse\n\t\tsg_count = dma_map_sg(dev, areq->src, sg_count,\n\t\t\t\t      (areq->src == areq->dst) ?\n\t\t\t\t      DMA_BIDIRECTIONAL : DMA_TO_DEVICE);\n\t \n\tsg_count = talitos_sg_map_ext(dev, areq->src, cryptlen, edesc, &desc->ptr[3],\n\t\t\t\t      sg_count, 0, 0, 0, false, is_ctr ? 16 : 1);\n\tif (sg_count > 1)\n\t\tsync_needed = true;\n\n\t \n\tif (areq->src != areq->dst) {\n\t\tsg_count = edesc->dst_nents ? : 1;\n\t\tif (!is_sec1 || sg_count == 1)\n\t\t\tdma_map_sg(dev, areq->dst, sg_count, DMA_FROM_DEVICE);\n\t}\n\n\tret = talitos_sg_map(dev, areq->dst, cryptlen, edesc, &desc->ptr[4],\n\t\t\t     sg_count, 0, (edesc->src_nents + 1));\n\tif (ret > 1)\n\t\tsync_needed = true;\n\n\t \n\tmap_single_talitos_ptr(dev, &desc->ptr[5], ivsize, ctx->iv,\n\t\t\t       DMA_FROM_DEVICE);\n\n\t \n\n\tif (sync_needed)\n\t\tdma_sync_single_for_device(dev, edesc->dma_link_tbl,\n\t\t\t\t\t   edesc->dma_len, DMA_BIDIRECTIONAL);\n\n\tret = talitos_submit(dev, ctx->ch, desc, callback, areq);\n\tif (ret != -EINPROGRESS) {\n\t\tcommon_nonsnoop_unmap(dev, edesc, areq);\n\t\tkfree(edesc);\n\t}\n\treturn ret;\n}\n\nstatic struct talitos_edesc *skcipher_edesc_alloc(struct skcipher_request *\n\t\t\t\t\t\t    areq, bool encrypt)\n{\n\tstruct crypto_skcipher *cipher = crypto_skcipher_reqtfm(areq);\n\tstruct talitos_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tunsigned int ivsize = crypto_skcipher_ivsize(cipher);\n\n\treturn talitos_edesc_alloc(ctx->dev, areq->src, areq->dst,\n\t\t\t\t   areq->iv, 0, areq->cryptlen, 0, ivsize, 0,\n\t\t\t\t   areq->base.flags, encrypt);\n}\n\nstatic int skcipher_encrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *cipher = crypto_skcipher_reqtfm(areq);\n\tstruct talitos_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tstruct talitos_edesc *edesc;\n\tunsigned int blocksize =\n\t\t\tcrypto_tfm_alg_blocksize(crypto_skcipher_tfm(cipher));\n\n\tif (!areq->cryptlen)\n\t\treturn 0;\n\n\tif (areq->cryptlen % blocksize)\n\t\treturn -EINVAL;\n\n\t \n\tedesc = skcipher_edesc_alloc(areq, true);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\t \n\tedesc->desc.hdr = ctx->desc_hdr_template | DESC_HDR_MODE0_ENCRYPT;\n\n\treturn common_nonsnoop(edesc, areq, skcipher_done);\n}\n\nstatic int skcipher_decrypt(struct skcipher_request *areq)\n{\n\tstruct crypto_skcipher *cipher = crypto_skcipher_reqtfm(areq);\n\tstruct talitos_ctx *ctx = crypto_skcipher_ctx(cipher);\n\tstruct talitos_edesc *edesc;\n\tunsigned int blocksize =\n\t\t\tcrypto_tfm_alg_blocksize(crypto_skcipher_tfm(cipher));\n\n\tif (!areq->cryptlen)\n\t\treturn 0;\n\n\tif (areq->cryptlen % blocksize)\n\t\treturn -EINVAL;\n\n\t \n\tedesc = skcipher_edesc_alloc(areq, false);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\tedesc->desc.hdr = ctx->desc_hdr_template | DESC_HDR_DIR_INBOUND;\n\n\treturn common_nonsnoop(edesc, areq, skcipher_done);\n}\n\nstatic void common_nonsnoop_hash_unmap(struct device *dev,\n\t\t\t\t       struct talitos_edesc *edesc,\n\t\t\t\t       struct ahash_request *areq)\n{\n\tstruct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tbool is_sec1 = has_ftr_sec1(priv);\n\tstruct talitos_desc *desc = &edesc->desc;\n\tstruct talitos_desc *desc2 = (struct talitos_desc *)\n\t\t\t\t     (edesc->buf + edesc->dma_len);\n\n\tunmap_single_talitos_ptr(dev, &desc->ptr[5], DMA_FROM_DEVICE);\n\tif (desc->next_desc &&\n\t    desc->ptr[5].ptr != desc2->ptr[5].ptr)\n\t\tunmap_single_talitos_ptr(dev, &desc2->ptr[5], DMA_FROM_DEVICE);\n\tif (req_ctx->last)\n\t\tmemcpy(areq->result, req_ctx->hw_context,\n\t\t       crypto_ahash_digestsize(tfm));\n\n\tif (req_ctx->psrc)\n\t\ttalitos_sg_unmap(dev, edesc, req_ctx->psrc, NULL, 0, 0);\n\n\t \n\tif (from_talitos_ptr_len(&desc->ptr[1], is_sec1))\n\t\tunmap_single_talitos_ptr(dev, &desc->ptr[1],\n\t\t\t\t\t DMA_TO_DEVICE);\n\telse if (desc->next_desc)\n\t\tunmap_single_talitos_ptr(dev, &desc2->ptr[1],\n\t\t\t\t\t DMA_TO_DEVICE);\n\n\tif (is_sec1 && req_ctx->nbuf)\n\t\tunmap_single_talitos_ptr(dev, &desc->ptr[3],\n\t\t\t\t\t DMA_TO_DEVICE);\n\n\tif (edesc->dma_len)\n\t\tdma_unmap_single(dev, edesc->dma_link_tbl, edesc->dma_len,\n\t\t\t\t DMA_BIDIRECTIONAL);\n\n\tif (desc->next_desc)\n\t\tdma_unmap_single(dev, be32_to_cpu(desc->next_desc),\n\t\t\t\t TALITOS_DESC_SIZE, DMA_BIDIRECTIONAL);\n}\n\nstatic void ahash_done(struct device *dev,\n\t\t       struct talitos_desc *desc, void *context,\n\t\t       int err)\n{\n\tstruct ahash_request *areq = context;\n\tstruct talitos_edesc *edesc =\n\t\t container_of(desc, struct talitos_edesc, desc);\n\tstruct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);\n\n\tif (!req_ctx->last && req_ctx->to_hash_later) {\n\t\t \n\t\treq_ctx->buf_idx = (req_ctx->buf_idx + 1) & 1;\n\t\treq_ctx->nbuf = req_ctx->to_hash_later;\n\t}\n\tcommon_nonsnoop_hash_unmap(dev, edesc, areq);\n\n\tkfree(edesc);\n\n\tahash_request_complete(areq, err);\n}\n\n \nstatic void talitos_handle_buggy_hash(struct talitos_ctx *ctx,\n\t\t\t       struct talitos_edesc *edesc,\n\t\t\t       struct talitos_ptr *ptr)\n{\n\tstatic u8 padded_hash[64] = {\n\t\t0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t};\n\n\tpr_err_once(\"Bug in SEC1, padding ourself\\n\");\n\tedesc->desc.hdr &= ~DESC_HDR_MODE0_MDEU_PAD;\n\tmap_single_talitos_ptr(ctx->dev, ptr, sizeof(padded_hash),\n\t\t\t       (char *)padded_hash, DMA_TO_DEVICE);\n}\n\nstatic int common_nonsnoop_hash(struct talitos_edesc *edesc,\n\t\t\t\tstruct ahash_request *areq, unsigned int length,\n\t\t\t\tvoid (*callback) (struct device *dev,\n\t\t\t\t\t\t  struct talitos_desc *desc,\n\t\t\t\t\t\t  void *context, int error))\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct talitos_ctx *ctx = crypto_ahash_ctx(tfm);\n\tstruct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);\n\tstruct device *dev = ctx->dev;\n\tstruct talitos_desc *desc = &edesc->desc;\n\tint ret;\n\tbool sync_needed = false;\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tbool is_sec1 = has_ftr_sec1(priv);\n\tint sg_count;\n\n\t \n\n\t \n\tif (!req_ctx->first || req_ctx->swinit) {\n\t\tmap_single_talitos_ptr_nosync(dev, &desc->ptr[1],\n\t\t\t\t\t      req_ctx->hw_context_size,\n\t\t\t\t\t      req_ctx->hw_context,\n\t\t\t\t\t      DMA_TO_DEVICE);\n\t\treq_ctx->swinit = 0;\n\t}\n\t \n\treq_ctx->first = 0;\n\n\t \n\tif (ctx->keylen)\n\t\tto_talitos_ptr(&desc->ptr[2], ctx->dma_key, ctx->keylen,\n\t\t\t       is_sec1);\n\n\tif (is_sec1 && req_ctx->nbuf)\n\t\tlength -= req_ctx->nbuf;\n\n\tsg_count = edesc->src_nents ?: 1;\n\tif (is_sec1 && sg_count > 1)\n\t\tsg_copy_to_buffer(req_ctx->psrc, sg_count, edesc->buf, length);\n\telse if (length)\n\t\tsg_count = dma_map_sg(dev, req_ctx->psrc, sg_count,\n\t\t\t\t      DMA_TO_DEVICE);\n\t \n\tif (is_sec1 && req_ctx->nbuf) {\n\t\tmap_single_talitos_ptr(dev, &desc->ptr[3], req_ctx->nbuf,\n\t\t\t\t       req_ctx->buf[req_ctx->buf_idx],\n\t\t\t\t       DMA_TO_DEVICE);\n\t} else {\n\t\tsg_count = talitos_sg_map(dev, req_ctx->psrc, length, edesc,\n\t\t\t\t\t  &desc->ptr[3], sg_count, 0, 0);\n\t\tif (sg_count > 1)\n\t\t\tsync_needed = true;\n\t}\n\n\t \n\n\t \n\tif (req_ctx->last)\n\t\tmap_single_talitos_ptr(dev, &desc->ptr[5],\n\t\t\t\t       crypto_ahash_digestsize(tfm),\n\t\t\t\t       req_ctx->hw_context, DMA_FROM_DEVICE);\n\telse\n\t\tmap_single_talitos_ptr_nosync(dev, &desc->ptr[5],\n\t\t\t\t\t      req_ctx->hw_context_size,\n\t\t\t\t\t      req_ctx->hw_context,\n\t\t\t\t\t      DMA_FROM_DEVICE);\n\n\t \n\n\tif (is_sec1 && from_talitos_ptr_len(&desc->ptr[3], true) == 0)\n\t\ttalitos_handle_buggy_hash(ctx, edesc, &desc->ptr[3]);\n\n\tif (is_sec1 && req_ctx->nbuf && length) {\n\t\tstruct talitos_desc *desc2 = (struct talitos_desc *)\n\t\t\t\t\t     (edesc->buf + edesc->dma_len);\n\t\tdma_addr_t next_desc;\n\n\t\tmemset(desc2, 0, sizeof(*desc2));\n\t\tdesc2->hdr = desc->hdr;\n\t\tdesc2->hdr &= ~DESC_HDR_MODE0_MDEU_INIT;\n\t\tdesc2->hdr1 = desc2->hdr;\n\t\tdesc->hdr &= ~DESC_HDR_MODE0_MDEU_PAD;\n\t\tdesc->hdr |= DESC_HDR_MODE0_MDEU_CONT;\n\t\tdesc->hdr &= ~DESC_HDR_DONE_NOTIFY;\n\n\t\tif (desc->ptr[1].ptr)\n\t\t\tcopy_talitos_ptr(&desc2->ptr[1], &desc->ptr[1],\n\t\t\t\t\t is_sec1);\n\t\telse\n\t\t\tmap_single_talitos_ptr_nosync(dev, &desc2->ptr[1],\n\t\t\t\t\t\t      req_ctx->hw_context_size,\n\t\t\t\t\t\t      req_ctx->hw_context,\n\t\t\t\t\t\t      DMA_TO_DEVICE);\n\t\tcopy_talitos_ptr(&desc2->ptr[2], &desc->ptr[2], is_sec1);\n\t\tsg_count = talitos_sg_map(dev, req_ctx->psrc, length, edesc,\n\t\t\t\t\t  &desc2->ptr[3], sg_count, 0, 0);\n\t\tif (sg_count > 1)\n\t\t\tsync_needed = true;\n\t\tcopy_talitos_ptr(&desc2->ptr[5], &desc->ptr[5], is_sec1);\n\t\tif (req_ctx->last)\n\t\t\tmap_single_talitos_ptr_nosync(dev, &desc->ptr[5],\n\t\t\t\t\t\t      req_ctx->hw_context_size,\n\t\t\t\t\t\t      req_ctx->hw_context,\n\t\t\t\t\t\t      DMA_FROM_DEVICE);\n\n\t\tnext_desc = dma_map_single(dev, &desc2->hdr1, TALITOS_DESC_SIZE,\n\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\t\tdesc->next_desc = cpu_to_be32(next_desc);\n\t}\n\n\tif (sync_needed)\n\t\tdma_sync_single_for_device(dev, edesc->dma_link_tbl,\n\t\t\t\t\t   edesc->dma_len, DMA_BIDIRECTIONAL);\n\n\tret = talitos_submit(dev, ctx->ch, desc, callback, areq);\n\tif (ret != -EINPROGRESS) {\n\t\tcommon_nonsnoop_hash_unmap(dev, edesc, areq);\n\t\tkfree(edesc);\n\t}\n\treturn ret;\n}\n\nstatic struct talitos_edesc *ahash_edesc_alloc(struct ahash_request *areq,\n\t\t\t\t\t       unsigned int nbytes)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct talitos_ctx *ctx = crypto_ahash_ctx(tfm);\n\tstruct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);\n\tstruct talitos_private *priv = dev_get_drvdata(ctx->dev);\n\tbool is_sec1 = has_ftr_sec1(priv);\n\n\tif (is_sec1)\n\t\tnbytes -= req_ctx->nbuf;\n\n\treturn talitos_edesc_alloc(ctx->dev, req_ctx->psrc, NULL, NULL, 0,\n\t\t\t\t   nbytes, 0, 0, 0, areq->base.flags, false);\n}\n\nstatic int ahash_init(struct ahash_request *areq)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct talitos_ctx *ctx = crypto_ahash_ctx(tfm);\n\tstruct device *dev = ctx->dev;\n\tstruct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);\n\tunsigned int size;\n\tdma_addr_t dma;\n\n\t \n\treq_ctx->buf_idx = 0;\n\treq_ctx->nbuf = 0;\n\treq_ctx->first = 1;  \n\treq_ctx->swinit = 0;  \n\tsize =\t(crypto_ahash_digestsize(tfm) <= SHA256_DIGEST_SIZE)\n\t\t\t? TALITOS_MDEU_CONTEXT_SIZE_MD5_SHA1_SHA256\n\t\t\t: TALITOS_MDEU_CONTEXT_SIZE_SHA384_SHA512;\n\treq_ctx->hw_context_size = size;\n\n\tdma = dma_map_single(dev, req_ctx->hw_context, req_ctx->hw_context_size,\n\t\t\t     DMA_TO_DEVICE);\n\tdma_unmap_single(dev, dma, req_ctx->hw_context_size, DMA_TO_DEVICE);\n\n\treturn 0;\n}\n\n \nstatic int ahash_init_sha224_swinit(struct ahash_request *areq)\n{\n\tstruct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);\n\n\treq_ctx->hw_context[0] = SHA224_H0;\n\treq_ctx->hw_context[1] = SHA224_H1;\n\treq_ctx->hw_context[2] = SHA224_H2;\n\treq_ctx->hw_context[3] = SHA224_H3;\n\treq_ctx->hw_context[4] = SHA224_H4;\n\treq_ctx->hw_context[5] = SHA224_H5;\n\treq_ctx->hw_context[6] = SHA224_H6;\n\treq_ctx->hw_context[7] = SHA224_H7;\n\n\t \n\treq_ctx->hw_context[8] = 0;\n\treq_ctx->hw_context[9] = 0;\n\n\tahash_init(areq);\n\treq_ctx->swinit = 1; \n\n\treturn 0;\n}\n\nstatic int ahash_process_req(struct ahash_request *areq, unsigned int nbytes)\n{\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct talitos_ctx *ctx = crypto_ahash_ctx(tfm);\n\tstruct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);\n\tstruct talitos_edesc *edesc;\n\tunsigned int blocksize =\n\t\t\tcrypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));\n\tunsigned int nbytes_to_hash;\n\tunsigned int to_hash_later;\n\tunsigned int nsg;\n\tint nents;\n\tstruct device *dev = ctx->dev;\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tbool is_sec1 = has_ftr_sec1(priv);\n\tu8 *ctx_buf = req_ctx->buf[req_ctx->buf_idx];\n\n\tif (!req_ctx->last && (nbytes + req_ctx->nbuf <= blocksize)) {\n\t\t \n\t\tnents = sg_nents_for_len(areq->src, nbytes);\n\t\tif (nents < 0) {\n\t\t\tdev_err(dev, \"Invalid number of src SG.\\n\");\n\t\t\treturn nents;\n\t\t}\n\t\tsg_copy_to_buffer(areq->src, nents,\n\t\t\t\t  ctx_buf + req_ctx->nbuf, nbytes);\n\t\treq_ctx->nbuf += nbytes;\n\t\treturn 0;\n\t}\n\n\t \n\tnbytes_to_hash = nbytes + req_ctx->nbuf;\n\tto_hash_later = nbytes_to_hash & (blocksize - 1);\n\n\tif (req_ctx->last)\n\t\tto_hash_later = 0;\n\telse if (to_hash_later)\n\t\t \n\t\tnbytes_to_hash -= to_hash_later;\n\telse {\n\t\t \n\t\tnbytes_to_hash -= blocksize;\n\t\tto_hash_later = blocksize;\n\t}\n\n\t \n\tif (!is_sec1 && req_ctx->nbuf) {\n\t\tnsg = (req_ctx->nbuf < nbytes_to_hash) ? 2 : 1;\n\t\tsg_init_table(req_ctx->bufsl, nsg);\n\t\tsg_set_buf(req_ctx->bufsl, ctx_buf, req_ctx->nbuf);\n\t\tif (nsg > 1)\n\t\t\tsg_chain(req_ctx->bufsl, 2, areq->src);\n\t\treq_ctx->psrc = req_ctx->bufsl;\n\t} else if (is_sec1 && req_ctx->nbuf && req_ctx->nbuf < blocksize) {\n\t\tint offset;\n\n\t\tif (nbytes_to_hash > blocksize)\n\t\t\toffset = blocksize - req_ctx->nbuf;\n\t\telse\n\t\t\toffset = nbytes_to_hash - req_ctx->nbuf;\n\t\tnents = sg_nents_for_len(areq->src, offset);\n\t\tif (nents < 0) {\n\t\t\tdev_err(dev, \"Invalid number of src SG.\\n\");\n\t\t\treturn nents;\n\t\t}\n\t\tsg_copy_to_buffer(areq->src, nents,\n\t\t\t\t  ctx_buf + req_ctx->nbuf, offset);\n\t\treq_ctx->nbuf += offset;\n\t\treq_ctx->psrc = scatterwalk_ffwd(req_ctx->bufsl, areq->src,\n\t\t\t\t\t\t offset);\n\t} else\n\t\treq_ctx->psrc = areq->src;\n\n\tif (to_hash_later) {\n\t\tnents = sg_nents_for_len(areq->src, nbytes);\n\t\tif (nents < 0) {\n\t\t\tdev_err(dev, \"Invalid number of src SG.\\n\");\n\t\t\treturn nents;\n\t\t}\n\t\tsg_pcopy_to_buffer(areq->src, nents,\n\t\t\t\t   req_ctx->buf[(req_ctx->buf_idx + 1) & 1],\n\t\t\t\t      to_hash_later,\n\t\t\t\t      nbytes - to_hash_later);\n\t}\n\treq_ctx->to_hash_later = to_hash_later;\n\n\t \n\tedesc = ahash_edesc_alloc(areq, nbytes_to_hash);\n\tif (IS_ERR(edesc))\n\t\treturn PTR_ERR(edesc);\n\n\tedesc->desc.hdr = ctx->desc_hdr_template;\n\n\t \n\tif (req_ctx->last)\n\t\tedesc->desc.hdr |= DESC_HDR_MODE0_MDEU_PAD;\n\telse\n\t\tedesc->desc.hdr |= DESC_HDR_MODE0_MDEU_CONT;\n\n\t \n\tif (req_ctx->first && !req_ctx->swinit)\n\t\tedesc->desc.hdr |= DESC_HDR_MODE0_MDEU_INIT;\n\n\t \n\tif (ctx->keylen && (req_ctx->first || req_ctx->last))\n\t\tedesc->desc.hdr |= DESC_HDR_MODE0_MDEU_HMAC;\n\n\treturn common_nonsnoop_hash(edesc, areq, nbytes_to_hash, ahash_done);\n}\n\nstatic int ahash_update(struct ahash_request *areq)\n{\n\tstruct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);\n\n\treq_ctx->last = 0;\n\n\treturn ahash_process_req(areq, areq->nbytes);\n}\n\nstatic int ahash_final(struct ahash_request *areq)\n{\n\tstruct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);\n\n\treq_ctx->last = 1;\n\n\treturn ahash_process_req(areq, 0);\n}\n\nstatic int ahash_finup(struct ahash_request *areq)\n{\n\tstruct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);\n\n\treq_ctx->last = 1;\n\n\treturn ahash_process_req(areq, areq->nbytes);\n}\n\nstatic int ahash_digest(struct ahash_request *areq)\n{\n\tstruct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *ahash = crypto_ahash_reqtfm(areq);\n\n\tahash->init(areq);\n\treq_ctx->last = 1;\n\n\treturn ahash_process_req(areq, areq->nbytes);\n}\n\nstatic int ahash_export(struct ahash_request *areq, void *out)\n{\n\tstruct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);\n\tstruct talitos_export_state *export = out;\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct talitos_ctx *ctx = crypto_ahash_ctx(tfm);\n\tstruct device *dev = ctx->dev;\n\tdma_addr_t dma;\n\n\tdma = dma_map_single(dev, req_ctx->hw_context, req_ctx->hw_context_size,\n\t\t\t     DMA_FROM_DEVICE);\n\tdma_unmap_single(dev, dma, req_ctx->hw_context_size, DMA_FROM_DEVICE);\n\n\tmemcpy(export->hw_context, req_ctx->hw_context,\n\t       req_ctx->hw_context_size);\n\tmemcpy(export->buf, req_ctx->buf[req_ctx->buf_idx], req_ctx->nbuf);\n\texport->swinit = req_ctx->swinit;\n\texport->first = req_ctx->first;\n\texport->last = req_ctx->last;\n\texport->to_hash_later = req_ctx->to_hash_later;\n\texport->nbuf = req_ctx->nbuf;\n\n\treturn 0;\n}\n\nstatic int ahash_import(struct ahash_request *areq, const void *in)\n{\n\tstruct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);\n\tstruct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);\n\tstruct talitos_ctx *ctx = crypto_ahash_ctx(tfm);\n\tstruct device *dev = ctx->dev;\n\tconst struct talitos_export_state *export = in;\n\tunsigned int size;\n\tdma_addr_t dma;\n\n\tmemset(req_ctx, 0, sizeof(*req_ctx));\n\tsize = (crypto_ahash_digestsize(tfm) <= SHA256_DIGEST_SIZE)\n\t\t\t? TALITOS_MDEU_CONTEXT_SIZE_MD5_SHA1_SHA256\n\t\t\t: TALITOS_MDEU_CONTEXT_SIZE_SHA384_SHA512;\n\treq_ctx->hw_context_size = size;\n\tmemcpy(req_ctx->hw_context, export->hw_context, size);\n\tmemcpy(req_ctx->buf[0], export->buf, export->nbuf);\n\treq_ctx->swinit = export->swinit;\n\treq_ctx->first = export->first;\n\treq_ctx->last = export->last;\n\treq_ctx->to_hash_later = export->to_hash_later;\n\treq_ctx->nbuf = export->nbuf;\n\n\tdma = dma_map_single(dev, req_ctx->hw_context, req_ctx->hw_context_size,\n\t\t\t     DMA_TO_DEVICE);\n\tdma_unmap_single(dev, dma, req_ctx->hw_context_size, DMA_TO_DEVICE);\n\n\treturn 0;\n}\n\nstatic int keyhash(struct crypto_ahash *tfm, const u8 *key, unsigned int keylen,\n\t\t   u8 *hash)\n{\n\tstruct talitos_ctx *ctx = crypto_tfm_ctx(crypto_ahash_tfm(tfm));\n\n\tstruct scatterlist sg[1];\n\tstruct ahash_request *req;\n\tstruct crypto_wait wait;\n\tint ret;\n\n\tcrypto_init_wait(&wait);\n\n\treq = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\t \n\tctx->keylen = 0;\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t   crypto_req_done, &wait);\n\n\tsg_init_one(&sg[0], key, keylen);\n\n\tahash_request_set_crypt(req, sg, hash, keylen);\n\tret = crypto_wait_req(crypto_ahash_digest(req), &wait);\n\n\tahash_request_free(req);\n\n\treturn ret;\n}\n\nstatic int ahash_setkey(struct crypto_ahash *tfm, const u8 *key,\n\t\t\tunsigned int keylen)\n{\n\tstruct talitos_ctx *ctx = crypto_tfm_ctx(crypto_ahash_tfm(tfm));\n\tstruct device *dev = ctx->dev;\n\tunsigned int blocksize =\n\t\t\tcrypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));\n\tunsigned int digestsize = crypto_ahash_digestsize(tfm);\n\tunsigned int keysize = keylen;\n\tu8 hash[SHA512_DIGEST_SIZE];\n\tint ret;\n\n\tif (keylen <= blocksize)\n\t\tmemcpy(ctx->key, key, keysize);\n\telse {\n\t\t \n\t\tret = keyhash(tfm, key, keylen, hash);\n\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\tkeysize = digestsize;\n\t\tmemcpy(ctx->key, hash, digestsize);\n\t}\n\n\tif (ctx->keylen)\n\t\tdma_unmap_single(dev, ctx->dma_key, ctx->keylen, DMA_TO_DEVICE);\n\n\tctx->keylen = keysize;\n\tctx->dma_key = dma_map_single(dev, ctx->key, keysize, DMA_TO_DEVICE);\n\n\treturn 0;\n}\n\n\nstruct talitos_alg_template {\n\tu32 type;\n\tu32 priority;\n\tunion {\n\t\tstruct skcipher_alg skcipher;\n\t\tstruct ahash_alg hash;\n\t\tstruct aead_alg aead;\n\t} alg;\n\t__be32 desc_hdr_template;\n};\n\nstatic struct talitos_alg_template driver_algs[] = {\n\t \n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha1),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha1-\"\n\t\t\t\t\t\t   \"cbc-aes-talitos\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_IPSEC_ESP |\n\t\t\t             DESC_HDR_SEL0_AESU |\n\t\t                     DESC_HDR_MODE0_AESU_CBC |\n\t\t                     DESC_HDR_SEL1_MDEUA |\n\t\t                     DESC_HDR_MODE1_MDEU_INIT |\n\t\t                     DESC_HDR_MODE1_MDEU_PAD |\n\t\t                     DESC_HDR_MODE1_MDEU_SHA1_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.priority = TALITOS_CRA_PRIORITY_AEAD_HSNA,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha1),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha1-\"\n\t\t\t\t\t\t   \"cbc-aes-talitos-hsna\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_HMAC_SNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_AESU |\n\t\t\t\t     DESC_HDR_MODE0_AESU_CBC |\n\t\t\t\t     DESC_HDR_SEL1_MDEUA |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_INIT |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_PAD |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_SHA1_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha1),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha1-\"\n\t\t\t\t\t\t   \"cbc-3des-talitos\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t\t.setkey = aead_des3_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_IPSEC_ESP |\n\t\t\t             DESC_HDR_SEL0_DEU |\n\t\t                     DESC_HDR_MODE0_DEU_CBC |\n\t\t                     DESC_HDR_MODE0_DEU_3DES |\n\t\t                     DESC_HDR_SEL1_MDEUA |\n\t\t                     DESC_HDR_MODE1_MDEU_INIT |\n\t\t                     DESC_HDR_MODE1_MDEU_PAD |\n\t\t                     DESC_HDR_MODE1_MDEU_SHA1_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.priority = TALITOS_CRA_PRIORITY_AEAD_HSNA,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha1),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha1-\"\n\t\t\t\t\t\t   \"cbc-3des-talitos-hsna\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA1_DIGEST_SIZE,\n\t\t\t.setkey = aead_des3_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_HMAC_SNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_DEU |\n\t\t\t\t     DESC_HDR_MODE0_DEU_CBC |\n\t\t\t\t     DESC_HDR_MODE0_DEU_3DES |\n\t\t\t\t     DESC_HDR_SEL1_MDEUA |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_INIT |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_PAD |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_SHA1_HMAC,\n\t},\n\t{       .type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha224),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha224-\"\n\t\t\t\t\t\t   \"cbc-aes-talitos\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_IPSEC_ESP |\n\t\t\t\t     DESC_HDR_SEL0_AESU |\n\t\t\t\t     DESC_HDR_MODE0_AESU_CBC |\n\t\t\t\t     DESC_HDR_SEL1_MDEUA |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_INIT |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_PAD |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_SHA224_HMAC,\n\t},\n\t{       .type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.priority = TALITOS_CRA_PRIORITY_AEAD_HSNA,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha224),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha224-\"\n\t\t\t\t\t\t   \"cbc-aes-talitos-hsna\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_HMAC_SNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_AESU |\n\t\t\t\t     DESC_HDR_MODE0_AESU_CBC |\n\t\t\t\t     DESC_HDR_SEL1_MDEUA |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_INIT |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_PAD |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_SHA224_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha224),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha224-\"\n\t\t\t\t\t\t   \"cbc-3des-talitos\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t\t.setkey = aead_des3_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_IPSEC_ESP |\n\t\t\t             DESC_HDR_SEL0_DEU |\n\t\t                     DESC_HDR_MODE0_DEU_CBC |\n\t\t                     DESC_HDR_MODE0_DEU_3DES |\n\t\t                     DESC_HDR_SEL1_MDEUA |\n\t\t                     DESC_HDR_MODE1_MDEU_INIT |\n\t\t                     DESC_HDR_MODE1_MDEU_PAD |\n\t\t                     DESC_HDR_MODE1_MDEU_SHA224_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.priority = TALITOS_CRA_PRIORITY_AEAD_HSNA,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha224),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha224-\"\n\t\t\t\t\t\t   \"cbc-3des-talitos-hsna\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA224_DIGEST_SIZE,\n\t\t\t.setkey = aead_des3_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_HMAC_SNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_DEU |\n\t\t\t\t     DESC_HDR_MODE0_DEU_CBC |\n\t\t\t\t     DESC_HDR_MODE0_DEU_3DES |\n\t\t\t\t     DESC_HDR_SEL1_MDEUA |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_INIT |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_PAD |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_SHA224_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha256),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha256-\"\n\t\t\t\t\t\t   \"cbc-aes-talitos\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_IPSEC_ESP |\n\t\t\t             DESC_HDR_SEL0_AESU |\n\t\t                     DESC_HDR_MODE0_AESU_CBC |\n\t\t                     DESC_HDR_SEL1_MDEUA |\n\t\t                     DESC_HDR_MODE1_MDEU_INIT |\n\t\t                     DESC_HDR_MODE1_MDEU_PAD |\n\t\t                     DESC_HDR_MODE1_MDEU_SHA256_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.priority = TALITOS_CRA_PRIORITY_AEAD_HSNA,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha256),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha256-\"\n\t\t\t\t\t\t   \"cbc-aes-talitos-hsna\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_HMAC_SNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_AESU |\n\t\t\t\t     DESC_HDR_MODE0_AESU_CBC |\n\t\t\t\t     DESC_HDR_SEL1_MDEUA |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_INIT |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_PAD |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_SHA256_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha256),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha256-\"\n\t\t\t\t\t\t   \"cbc-3des-talitos\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t\t.setkey = aead_des3_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_IPSEC_ESP |\n\t\t\t             DESC_HDR_SEL0_DEU |\n\t\t                     DESC_HDR_MODE0_DEU_CBC |\n\t\t                     DESC_HDR_MODE0_DEU_3DES |\n\t\t                     DESC_HDR_SEL1_MDEUA |\n\t\t                     DESC_HDR_MODE1_MDEU_INIT |\n\t\t                     DESC_HDR_MODE1_MDEU_PAD |\n\t\t                     DESC_HDR_MODE1_MDEU_SHA256_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.priority = TALITOS_CRA_PRIORITY_AEAD_HSNA,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha256),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha256-\"\n\t\t\t\t\t\t   \"cbc-3des-talitos-hsna\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA256_DIGEST_SIZE,\n\t\t\t.setkey = aead_des3_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_HMAC_SNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_DEU |\n\t\t\t\t     DESC_HDR_MODE0_DEU_CBC |\n\t\t\t\t     DESC_HDR_MODE0_DEU_3DES |\n\t\t\t\t     DESC_HDR_SEL1_MDEUA |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_INIT |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_PAD |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_SHA256_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha384),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha384-\"\n\t\t\t\t\t\t   \"cbc-aes-talitos\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_IPSEC_ESP |\n\t\t\t             DESC_HDR_SEL0_AESU |\n\t\t                     DESC_HDR_MODE0_AESU_CBC |\n\t\t                     DESC_HDR_SEL1_MDEUB |\n\t\t                     DESC_HDR_MODE1_MDEU_INIT |\n\t\t                     DESC_HDR_MODE1_MDEU_PAD |\n\t\t                     DESC_HDR_MODE1_MDEUB_SHA384_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha384),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha384-\"\n\t\t\t\t\t\t   \"cbc-3des-talitos\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA384_DIGEST_SIZE,\n\t\t\t.setkey = aead_des3_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_IPSEC_ESP |\n\t\t\t             DESC_HDR_SEL0_DEU |\n\t\t                     DESC_HDR_MODE0_DEU_CBC |\n\t\t                     DESC_HDR_MODE0_DEU_3DES |\n\t\t                     DESC_HDR_SEL1_MDEUB |\n\t\t                     DESC_HDR_MODE1_MDEU_INIT |\n\t\t                     DESC_HDR_MODE1_MDEU_PAD |\n\t\t                     DESC_HDR_MODE1_MDEUB_SHA384_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha512),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha512-\"\n\t\t\t\t\t\t   \"cbc-aes-talitos\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_IPSEC_ESP |\n\t\t\t             DESC_HDR_SEL0_AESU |\n\t\t                     DESC_HDR_MODE0_AESU_CBC |\n\t\t                     DESC_HDR_SEL1_MDEUB |\n\t\t                     DESC_HDR_MODE1_MDEU_INIT |\n\t\t                     DESC_HDR_MODE1_MDEU_PAD |\n\t\t                     DESC_HDR_MODE1_MDEUB_SHA512_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(sha512),\"\n\t\t\t\t\t    \"cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-sha512-\"\n\t\t\t\t\t\t   \"cbc-3des-talitos\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = SHA512_DIGEST_SIZE,\n\t\t\t.setkey = aead_des3_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_IPSEC_ESP |\n\t\t\t             DESC_HDR_SEL0_DEU |\n\t\t                     DESC_HDR_MODE0_DEU_CBC |\n\t\t                     DESC_HDR_MODE0_DEU_3DES |\n\t\t                     DESC_HDR_SEL1_MDEUB |\n\t\t                     DESC_HDR_MODE1_MDEU_INIT |\n\t\t                     DESC_HDR_MODE1_MDEU_PAD |\n\t\t                     DESC_HDR_MODE1_MDEUB_SHA512_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(md5),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-aes-talitos\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_IPSEC_ESP |\n\t\t\t             DESC_HDR_SEL0_AESU |\n\t\t                     DESC_HDR_MODE0_AESU_CBC |\n\t\t                     DESC_HDR_SEL1_MDEUA |\n\t\t                     DESC_HDR_MODE1_MDEU_INIT |\n\t\t                     DESC_HDR_MODE1_MDEU_PAD |\n\t\t                     DESC_HDR_MODE1_MDEU_MD5_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.priority = TALITOS_CRA_PRIORITY_AEAD_HSNA,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(md5),cbc(aes))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-aes-talitos-hsna\",\n\t\t\t\t.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_HMAC_SNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_AESU |\n\t\t\t\t     DESC_HDR_MODE0_AESU_CBC |\n\t\t\t\t     DESC_HDR_SEL1_MDEUA |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_INIT |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_PAD |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_MD5_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(md5),cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-3des-talitos\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t\t.setkey = aead_des3_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_IPSEC_ESP |\n\t\t\t             DESC_HDR_SEL0_DEU |\n\t\t                     DESC_HDR_MODE0_DEU_CBC |\n\t\t                     DESC_HDR_MODE0_DEU_3DES |\n\t\t                     DESC_HDR_SEL1_MDEUA |\n\t\t                     DESC_HDR_MODE1_MDEU_INIT |\n\t\t                     DESC_HDR_MODE1_MDEU_PAD |\n\t\t                     DESC_HDR_MODE1_MDEU_MD5_HMAC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t\t.priority = TALITOS_CRA_PRIORITY_AEAD_HSNA,\n\t\t.alg.aead = {\n\t\t\t.base = {\n\t\t\t\t.cra_name = \"authenc(hmac(md5),cbc(des3_ede))\",\n\t\t\t\t.cra_driver_name = \"authenc-hmac-md5-\"\n\t\t\t\t\t\t   \"cbc-3des-talitos-hsna\",\n\t\t\t\t.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t},\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.maxauthsize = MD5_DIGEST_SIZE,\n\t\t\t.setkey = aead_des3_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_HMAC_SNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_DEU |\n\t\t\t\t     DESC_HDR_MODE0_DEU_CBC |\n\t\t\t\t     DESC_HDR_MODE0_DEU_3DES |\n\t\t\t\t     DESC_HDR_SEL1_MDEUA |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_INIT |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_PAD |\n\t\t\t\t     DESC_HDR_MODE1_MDEU_MD5_HMAC,\n\t},\n\t \n\t{\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t\t.alg.skcipher = {\n\t\t\t.base.cra_name = \"ecb(aes)\",\n\t\t\t.base.cra_driver_name = \"ecb-aes-talitos\",\n\t\t\t.base.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.base.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t\t.setkey = skcipher_aes_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_AESU,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t\t.alg.skcipher = {\n\t\t\t.base.cra_name = \"cbc(aes)\",\n\t\t\t.base.cra_driver_name = \"cbc-aes-talitos\",\n\t\t\t.base.cra_blocksize = AES_BLOCK_SIZE,\n\t\t\t.base.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.setkey = skcipher_aes_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_AESU |\n\t\t\t\t     DESC_HDR_MODE0_AESU_CBC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t\t.alg.skcipher = {\n\t\t\t.base.cra_name = \"ctr(aes)\",\n\t\t\t.base.cra_driver_name = \"ctr-aes-talitos\",\n\t\t\t.base.cra_blocksize = 1,\n\t\t\t.base.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.setkey = skcipher_aes_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_AESU_CTR_NONSNOOP |\n\t\t\t\t     DESC_HDR_SEL0_AESU |\n\t\t\t\t     DESC_HDR_MODE0_AESU_CTR,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t\t.alg.skcipher = {\n\t\t\t.base.cra_name = \"ctr(aes)\",\n\t\t\t.base.cra_driver_name = \"ctr-aes-talitos\",\n\t\t\t.base.cra_blocksize = 1,\n\t\t\t.base.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t.min_keysize = AES_MIN_KEY_SIZE,\n\t\t\t.max_keysize = AES_MAX_KEY_SIZE,\n\t\t\t.ivsize = AES_BLOCK_SIZE,\n\t\t\t.setkey = skcipher_aes_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_AESU |\n\t\t\t\t     DESC_HDR_MODE0_AESU_CTR,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t\t.alg.skcipher = {\n\t\t\t.base.cra_name = \"ecb(des)\",\n\t\t\t.base.cra_driver_name = \"ecb-des-talitos\",\n\t\t\t.base.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t.base.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t.min_keysize = DES_KEY_SIZE,\n\t\t\t.max_keysize = DES_KEY_SIZE,\n\t\t\t.setkey = skcipher_des_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_DEU,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t\t.alg.skcipher = {\n\t\t\t.base.cra_name = \"cbc(des)\",\n\t\t\t.base.cra_driver_name = \"cbc-des-talitos\",\n\t\t\t.base.cra_blocksize = DES_BLOCK_SIZE,\n\t\t\t.base.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t.min_keysize = DES_KEY_SIZE,\n\t\t\t.max_keysize = DES_KEY_SIZE,\n\t\t\t.ivsize = DES_BLOCK_SIZE,\n\t\t\t.setkey = skcipher_des_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_DEU |\n\t\t\t\t     DESC_HDR_MODE0_DEU_CBC,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t\t.alg.skcipher = {\n\t\t\t.base.cra_name = \"ecb(des3_ede)\",\n\t\t\t.base.cra_driver_name = \"ecb-3des-talitos\",\n\t\t\t.base.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.base.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t.min_keysize = DES3_EDE_KEY_SIZE,\n\t\t\t.max_keysize = DES3_EDE_KEY_SIZE,\n\t\t\t.setkey = skcipher_des3_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_DEU |\n\t\t\t\t     DESC_HDR_MODE0_DEU_3DES,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t\t.alg.skcipher = {\n\t\t\t.base.cra_name = \"cbc(des3_ede)\",\n\t\t\t.base.cra_driver_name = \"cbc-3des-talitos\",\n\t\t\t.base.cra_blocksize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.base.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t  CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t.min_keysize = DES3_EDE_KEY_SIZE,\n\t\t\t.max_keysize = DES3_EDE_KEY_SIZE,\n\t\t\t.ivsize = DES3_EDE_BLOCK_SIZE,\n\t\t\t.setkey = skcipher_des3_setkey,\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t             DESC_HDR_SEL0_DEU |\n\t\t                     DESC_HDR_MODE0_DEU_CBC |\n\t\t                     DESC_HDR_MODE0_DEU_3DES,\n\t},\n\t \n\t{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.hash = {\n\t\t\t.halg.digestsize = MD5_DIGEST_SIZE,\n\t\t\t.halg.statesize = sizeof(struct talitos_export_state),\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name = \"md5\",\n\t\t\t\t.cra_driver_name = \"md5-talitos\",\n\t\t\t\t.cra_blocksize = MD5_HMAC_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t}\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_MDEUA |\n\t\t\t\t     DESC_HDR_MODE0_MDEU_MD5,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.hash = {\n\t\t\t.halg.digestsize = SHA1_DIGEST_SIZE,\n\t\t\t.halg.statesize = sizeof(struct talitos_export_state),\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name = \"sha1\",\n\t\t\t\t.cra_driver_name = \"sha1-talitos\",\n\t\t\t\t.cra_blocksize = SHA1_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t}\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_MDEUA |\n\t\t\t\t     DESC_HDR_MODE0_MDEU_SHA1,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.hash = {\n\t\t\t.halg.digestsize = SHA224_DIGEST_SIZE,\n\t\t\t.halg.statesize = sizeof(struct talitos_export_state),\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name = \"sha224\",\n\t\t\t\t.cra_driver_name = \"sha224-talitos\",\n\t\t\t\t.cra_blocksize = SHA224_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t}\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_MDEUA |\n\t\t\t\t     DESC_HDR_MODE0_MDEU_SHA224,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.hash = {\n\t\t\t.halg.digestsize = SHA256_DIGEST_SIZE,\n\t\t\t.halg.statesize = sizeof(struct talitos_export_state),\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name = \"sha256\",\n\t\t\t\t.cra_driver_name = \"sha256-talitos\",\n\t\t\t\t.cra_blocksize = SHA256_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t}\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_MDEUA |\n\t\t\t\t     DESC_HDR_MODE0_MDEU_SHA256,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.hash = {\n\t\t\t.halg.digestsize = SHA384_DIGEST_SIZE,\n\t\t\t.halg.statesize = sizeof(struct talitos_export_state),\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name = \"sha384\",\n\t\t\t\t.cra_driver_name = \"sha384-talitos\",\n\t\t\t\t.cra_blocksize = SHA384_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t}\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_MDEUB |\n\t\t\t\t     DESC_HDR_MODE0_MDEUB_SHA384,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.hash = {\n\t\t\t.halg.digestsize = SHA512_DIGEST_SIZE,\n\t\t\t.halg.statesize = sizeof(struct talitos_export_state),\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name = \"sha512\",\n\t\t\t\t.cra_driver_name = \"sha512-talitos\",\n\t\t\t\t.cra_blocksize = SHA512_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t}\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_MDEUB |\n\t\t\t\t     DESC_HDR_MODE0_MDEUB_SHA512,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.hash = {\n\t\t\t.halg.digestsize = MD5_DIGEST_SIZE,\n\t\t\t.halg.statesize = sizeof(struct talitos_export_state),\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name = \"hmac(md5)\",\n\t\t\t\t.cra_driver_name = \"hmac-md5-talitos\",\n\t\t\t\t.cra_blocksize = MD5_HMAC_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t}\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_MDEUA |\n\t\t\t\t     DESC_HDR_MODE0_MDEU_MD5,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.hash = {\n\t\t\t.halg.digestsize = SHA1_DIGEST_SIZE,\n\t\t\t.halg.statesize = sizeof(struct talitos_export_state),\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name = \"hmac(sha1)\",\n\t\t\t\t.cra_driver_name = \"hmac-sha1-talitos\",\n\t\t\t\t.cra_blocksize = SHA1_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t}\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_MDEUA |\n\t\t\t\t     DESC_HDR_MODE0_MDEU_SHA1,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.hash = {\n\t\t\t.halg.digestsize = SHA224_DIGEST_SIZE,\n\t\t\t.halg.statesize = sizeof(struct talitos_export_state),\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name = \"hmac(sha224)\",\n\t\t\t\t.cra_driver_name = \"hmac-sha224-talitos\",\n\t\t\t\t.cra_blocksize = SHA224_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t}\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_MDEUA |\n\t\t\t\t     DESC_HDR_MODE0_MDEU_SHA224,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.hash = {\n\t\t\t.halg.digestsize = SHA256_DIGEST_SIZE,\n\t\t\t.halg.statesize = sizeof(struct talitos_export_state),\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name = \"hmac(sha256)\",\n\t\t\t\t.cra_driver_name = \"hmac-sha256-talitos\",\n\t\t\t\t.cra_blocksize = SHA256_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t}\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_MDEUA |\n\t\t\t\t     DESC_HDR_MODE0_MDEU_SHA256,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.hash = {\n\t\t\t.halg.digestsize = SHA384_DIGEST_SIZE,\n\t\t\t.halg.statesize = sizeof(struct talitos_export_state),\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name = \"hmac(sha384)\",\n\t\t\t\t.cra_driver_name = \"hmac-sha384-talitos\",\n\t\t\t\t.cra_blocksize = SHA384_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t}\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_MDEUB |\n\t\t\t\t     DESC_HDR_MODE0_MDEUB_SHA384,\n\t},\n\t{\t.type = CRYPTO_ALG_TYPE_AHASH,\n\t\t.alg.hash = {\n\t\t\t.halg.digestsize = SHA512_DIGEST_SIZE,\n\t\t\t.halg.statesize = sizeof(struct talitos_export_state),\n\t\t\t.halg.base = {\n\t\t\t\t.cra_name = \"hmac(sha512)\",\n\t\t\t\t.cra_driver_name = \"hmac-sha512-talitos\",\n\t\t\t\t.cra_blocksize = SHA512_BLOCK_SIZE,\n\t\t\t\t.cra_flags = CRYPTO_ALG_ASYNC |\n\t\t\t\t\t     CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t\t}\n\t\t},\n\t\t.desc_hdr_template = DESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t     DESC_HDR_SEL0_MDEUB |\n\t\t\t\t     DESC_HDR_MODE0_MDEUB_SHA512,\n\t}\n};\n\nstruct talitos_crypto_alg {\n\tstruct list_head entry;\n\tstruct device *dev;\n\tstruct talitos_alg_template algt;\n};\n\nstatic int talitos_init_common(struct talitos_ctx *ctx,\n\t\t\t       struct talitos_crypto_alg *talitos_alg)\n{\n\tstruct talitos_private *priv;\n\n\t \n\tctx->dev = talitos_alg->dev;\n\n\t \n\tpriv = dev_get_drvdata(ctx->dev);\n\tctx->ch = atomic_inc_return(&priv->last_chan) &\n\t\t  (priv->num_channels - 1);\n\n\t \n\tctx->desc_hdr_template = talitos_alg->algt.desc_hdr_template;\n\n\t \n\tctx->desc_hdr_template |= DESC_HDR_DONE_NOTIFY;\n\n\treturn 0;\n}\n\nstatic int talitos_cra_init_aead(struct crypto_aead *tfm)\n{\n\tstruct aead_alg *alg = crypto_aead_alg(tfm);\n\tstruct talitos_crypto_alg *talitos_alg;\n\tstruct talitos_ctx *ctx = crypto_aead_ctx(tfm);\n\n\ttalitos_alg = container_of(alg, struct talitos_crypto_alg,\n\t\t\t\t   algt.alg.aead);\n\n\treturn talitos_init_common(ctx, talitos_alg);\n}\n\nstatic int talitos_cra_init_skcipher(struct crypto_skcipher *tfm)\n{\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(tfm);\n\tstruct talitos_crypto_alg *talitos_alg;\n\tstruct talitos_ctx *ctx = crypto_skcipher_ctx(tfm);\n\n\ttalitos_alg = container_of(alg, struct talitos_crypto_alg,\n\t\t\t\t   algt.alg.skcipher);\n\n\treturn talitos_init_common(ctx, talitos_alg);\n}\n\nstatic int talitos_cra_init_ahash(struct crypto_tfm *tfm)\n{\n\tstruct crypto_alg *alg = tfm->__crt_alg;\n\tstruct talitos_crypto_alg *talitos_alg;\n\tstruct talitos_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\ttalitos_alg = container_of(__crypto_ahash_alg(alg),\n\t\t\t\t   struct talitos_crypto_alg,\n\t\t\t\t   algt.alg.hash);\n\n\tctx->keylen = 0;\n\tcrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\n\t\t\t\t sizeof(struct talitos_ahash_req_ctx));\n\n\treturn talitos_init_common(ctx, talitos_alg);\n}\n\nstatic void talitos_cra_exit(struct crypto_tfm *tfm)\n{\n\tstruct talitos_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct device *dev = ctx->dev;\n\n\tif (ctx->keylen)\n\t\tdma_unmap_single(dev, ctx->dma_key, ctx->keylen, DMA_TO_DEVICE);\n}\n\n \nstatic int hw_supports(struct device *dev, __be32 desc_hdr_template)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = (1 << DESC_TYPE(desc_hdr_template) & priv->desc_types) &&\n\t      (1 << PRIMARY_EU(desc_hdr_template) & priv->exec_units);\n\n\tif (SECONDARY_EU(desc_hdr_template))\n\t\tret = ret && (1 << SECONDARY_EU(desc_hdr_template)\n\t\t              & priv->exec_units);\n\n\treturn ret;\n}\n\nstatic int talitos_remove(struct platform_device *ofdev)\n{\n\tstruct device *dev = &ofdev->dev;\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tstruct talitos_crypto_alg *t_alg, *n;\n\tint i;\n\n\tlist_for_each_entry_safe(t_alg, n, &priv->alg_list, entry) {\n\t\tswitch (t_alg->algt.type) {\n\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\tcrypto_unregister_skcipher(&t_alg->algt.alg.skcipher);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AEAD:\n\t\t\tcrypto_unregister_aead(&t_alg->algt.alg.aead);\n\t\t\tbreak;\n\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\tcrypto_unregister_ahash(&t_alg->algt.alg.hash);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del(&t_alg->entry);\n\t}\n\n\tif (hw_supports(dev, DESC_HDR_SEL0_RNG))\n\t\ttalitos_unregister_rng(dev);\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (priv->irq[i]) {\n\t\t\tfree_irq(priv->irq[i], dev);\n\t\t\tirq_dispose_mapping(priv->irq[i]);\n\t\t}\n\n\ttasklet_kill(&priv->done_task[0]);\n\tif (priv->irq[1])\n\t\ttasklet_kill(&priv->done_task[1]);\n\n\treturn 0;\n}\n\nstatic struct talitos_crypto_alg *talitos_alg_alloc(struct device *dev,\n\t\t\t\t\t\t    struct talitos_alg_template\n\t\t\t\t\t\t           *template)\n{\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tstruct talitos_crypto_alg *t_alg;\n\tstruct crypto_alg *alg;\n\n\tt_alg = devm_kzalloc(dev, sizeof(struct talitos_crypto_alg),\n\t\t\t     GFP_KERNEL);\n\tif (!t_alg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tt_alg->algt = *template;\n\n\tswitch (t_alg->algt.type) {\n\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\talg = &t_alg->algt.alg.skcipher.base;\n\t\talg->cra_exit = talitos_cra_exit;\n\t\tt_alg->algt.alg.skcipher.init = talitos_cra_init_skcipher;\n\t\tt_alg->algt.alg.skcipher.setkey =\n\t\t\tt_alg->algt.alg.skcipher.setkey ?: skcipher_setkey;\n\t\tt_alg->algt.alg.skcipher.encrypt = skcipher_encrypt;\n\t\tt_alg->algt.alg.skcipher.decrypt = skcipher_decrypt;\n\t\tif (!strcmp(alg->cra_name, \"ctr(aes)\") && !has_ftr_sec1(priv) &&\n\t\t    DESC_TYPE(t_alg->algt.desc_hdr_template) !=\n\t\t    DESC_TYPE(DESC_HDR_TYPE_AESU_CTR_NONSNOOP)) {\n\t\t\tdevm_kfree(dev, t_alg);\n\t\t\treturn ERR_PTR(-ENOTSUPP);\n\t\t}\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AEAD:\n\t\talg = &t_alg->algt.alg.aead.base;\n\t\talg->cra_exit = talitos_cra_exit;\n\t\tt_alg->algt.alg.aead.init = talitos_cra_init_aead;\n\t\tt_alg->algt.alg.aead.setkey = t_alg->algt.alg.aead.setkey ?:\n\t\t\t\t\t      aead_setkey;\n\t\tt_alg->algt.alg.aead.encrypt = aead_encrypt;\n\t\tt_alg->algt.alg.aead.decrypt = aead_decrypt;\n\t\tif (!(priv->features & TALITOS_FTR_SHA224_HWINIT) &&\n\t\t    !strncmp(alg->cra_name, \"authenc(hmac(sha224)\", 20)) {\n\t\t\tdevm_kfree(dev, t_alg);\n\t\t\treturn ERR_PTR(-ENOTSUPP);\n\t\t}\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\talg = &t_alg->algt.alg.hash.halg.base;\n\t\talg->cra_init = talitos_cra_init_ahash;\n\t\talg->cra_exit = talitos_cra_exit;\n\t\tt_alg->algt.alg.hash.init = ahash_init;\n\t\tt_alg->algt.alg.hash.update = ahash_update;\n\t\tt_alg->algt.alg.hash.final = ahash_final;\n\t\tt_alg->algt.alg.hash.finup = ahash_finup;\n\t\tt_alg->algt.alg.hash.digest = ahash_digest;\n\t\tif (!strncmp(alg->cra_name, \"hmac\", 4))\n\t\t\tt_alg->algt.alg.hash.setkey = ahash_setkey;\n\t\tt_alg->algt.alg.hash.import = ahash_import;\n\t\tt_alg->algt.alg.hash.export = ahash_export;\n\n\t\tif (!(priv->features & TALITOS_FTR_HMAC_OK) &&\n\t\t    !strncmp(alg->cra_name, \"hmac\", 4)) {\n\t\t\tdevm_kfree(dev, t_alg);\n\t\t\treturn ERR_PTR(-ENOTSUPP);\n\t\t}\n\t\tif (!(priv->features & TALITOS_FTR_SHA224_HWINIT) &&\n\t\t    (!strcmp(alg->cra_name, \"sha224\") ||\n\t\t     !strcmp(alg->cra_name, \"hmac(sha224)\"))) {\n\t\t\tt_alg->algt.alg.hash.init = ahash_init_sha224_swinit;\n\t\t\tt_alg->algt.desc_hdr_template =\n\t\t\t\t\tDESC_HDR_TYPE_COMMON_NONSNOOP_NO_AFEU |\n\t\t\t\t\tDESC_HDR_SEL0_MDEUA |\n\t\t\t\t\tDESC_HDR_MODE0_MDEU_SHA256;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unknown algorithm type %d\\n\", t_alg->algt.type);\n\t\tdevm_kfree(dev, t_alg);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\talg->cra_module = THIS_MODULE;\n\tif (t_alg->algt.priority)\n\t\talg->cra_priority = t_alg->algt.priority;\n\telse\n\t\talg->cra_priority = TALITOS_CRA_PRIORITY;\n\tif (has_ftr_sec1(priv))\n\t\talg->cra_alignmask = 3;\n\telse\n\t\talg->cra_alignmask = 0;\n\talg->cra_ctxsize = sizeof(struct talitos_ctx);\n\talg->cra_flags |= CRYPTO_ALG_KERN_DRIVER_ONLY;\n\n\tt_alg->dev = dev;\n\n\treturn t_alg;\n}\n\nstatic int talitos_probe_irq(struct platform_device *ofdev)\n{\n\tstruct device *dev = &ofdev->dev;\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct talitos_private *priv = dev_get_drvdata(dev);\n\tint err;\n\tbool is_sec1 = has_ftr_sec1(priv);\n\n\tpriv->irq[0] = irq_of_parse_and_map(np, 0);\n\tif (!priv->irq[0]) {\n\t\tdev_err(dev, \"failed to map irq\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (is_sec1) {\n\t\terr = request_irq(priv->irq[0], talitos1_interrupt_4ch, 0,\n\t\t\t\t  dev_driver_string(dev), dev);\n\t\tgoto primary_out;\n\t}\n\n\tpriv->irq[1] = irq_of_parse_and_map(np, 1);\n\n\t \n\tif (!priv->irq[1]) {\n\t\terr = request_irq(priv->irq[0], talitos2_interrupt_4ch, 0,\n\t\t\t\t  dev_driver_string(dev), dev);\n\t\tgoto primary_out;\n\t}\n\n\terr = request_irq(priv->irq[0], talitos2_interrupt_ch0_2, 0,\n\t\t\t  dev_driver_string(dev), dev);\n\tif (err)\n\t\tgoto primary_out;\n\n\t \n\terr = request_irq(priv->irq[1], talitos2_interrupt_ch1_3, 0,\n\t\t\t  dev_driver_string(dev), dev);\n\tif (err) {\n\t\tdev_err(dev, \"failed to request secondary irq\\n\");\n\t\tirq_dispose_mapping(priv->irq[1]);\n\t\tpriv->irq[1] = 0;\n\t}\n\n\treturn err;\n\nprimary_out:\n\tif (err) {\n\t\tdev_err(dev, \"failed to request primary irq\\n\");\n\t\tirq_dispose_mapping(priv->irq[0]);\n\t\tpriv->irq[0] = 0;\n\t}\n\n\treturn err;\n}\n\nstatic int talitos_probe(struct platform_device *ofdev)\n{\n\tstruct device *dev = &ofdev->dev;\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct talitos_private *priv;\n\tint i, err;\n\tint stride;\n\tstruct resource *res;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct talitos_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&priv->alg_list);\n\n\tdev_set_drvdata(dev, priv);\n\n\tpriv->ofdev = ofdev;\n\n\tspin_lock_init(&priv->reg_lock);\n\n\tres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENXIO;\n\tpriv->reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!priv->reg) {\n\t\tdev_err(dev, \"failed to of_iomap\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t \n\tof_property_read_u32(np, \"fsl,num-channels\", &priv->num_channels);\n\tof_property_read_u32(np, \"fsl,channel-fifo-len\", &priv->chfifo_len);\n\tof_property_read_u32(np, \"fsl,exec-units-mask\", &priv->exec_units);\n\tof_property_read_u32(np, \"fsl,descriptor-types-mask\",\n\t\t\t     &priv->desc_types);\n\n\tif (!is_power_of_2(priv->num_channels) || !priv->chfifo_len ||\n\t    !priv->exec_units || !priv->desc_types) {\n\t\tdev_err(dev, \"invalid property data in device tree node\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (of_device_is_compatible(np, \"fsl,sec3.0\"))\n\t\tpriv->features |= TALITOS_FTR_SRC_LINK_TBL_LEN_INCLUDES_EXTENT;\n\n\tif (of_device_is_compatible(np, \"fsl,sec2.1\"))\n\t\tpriv->features |= TALITOS_FTR_HW_AUTH_CHECK |\n\t\t\t\t  TALITOS_FTR_SHA224_HWINIT |\n\t\t\t\t  TALITOS_FTR_HMAC_OK;\n\n\tif (of_device_is_compatible(np, \"fsl,sec1.0\"))\n\t\tpriv->features |= TALITOS_FTR_SEC1;\n\n\tif (of_device_is_compatible(np, \"fsl,sec1.2\")) {\n\t\tpriv->reg_deu = priv->reg + TALITOS12_DEU;\n\t\tpriv->reg_aesu = priv->reg + TALITOS12_AESU;\n\t\tpriv->reg_mdeu = priv->reg + TALITOS12_MDEU;\n\t\tstride = TALITOS1_CH_STRIDE;\n\t} else if (of_device_is_compatible(np, \"fsl,sec1.0\")) {\n\t\tpriv->reg_deu = priv->reg + TALITOS10_DEU;\n\t\tpriv->reg_aesu = priv->reg + TALITOS10_AESU;\n\t\tpriv->reg_mdeu = priv->reg + TALITOS10_MDEU;\n\t\tpriv->reg_afeu = priv->reg + TALITOS10_AFEU;\n\t\tpriv->reg_rngu = priv->reg + TALITOS10_RNGU;\n\t\tpriv->reg_pkeu = priv->reg + TALITOS10_PKEU;\n\t\tstride = TALITOS1_CH_STRIDE;\n\t} else {\n\t\tpriv->reg_deu = priv->reg + TALITOS2_DEU;\n\t\tpriv->reg_aesu = priv->reg + TALITOS2_AESU;\n\t\tpriv->reg_mdeu = priv->reg + TALITOS2_MDEU;\n\t\tpriv->reg_afeu = priv->reg + TALITOS2_AFEU;\n\t\tpriv->reg_rngu = priv->reg + TALITOS2_RNGU;\n\t\tpriv->reg_pkeu = priv->reg + TALITOS2_PKEU;\n\t\tpriv->reg_keu = priv->reg + TALITOS2_KEU;\n\t\tpriv->reg_crcu = priv->reg + TALITOS2_CRCU;\n\t\tstride = TALITOS2_CH_STRIDE;\n\t}\n\n\terr = talitos_probe_irq(ofdev);\n\tif (err)\n\t\tgoto err_out;\n\n\tif (has_ftr_sec1(priv)) {\n\t\tif (priv->num_channels == 1)\n\t\t\ttasklet_init(&priv->done_task[0], talitos1_done_ch0,\n\t\t\t\t     (unsigned long)dev);\n\t\telse\n\t\t\ttasklet_init(&priv->done_task[0], talitos1_done_4ch,\n\t\t\t\t     (unsigned long)dev);\n\t} else {\n\t\tif (priv->irq[1]) {\n\t\t\ttasklet_init(&priv->done_task[0], talitos2_done_ch0_2,\n\t\t\t\t     (unsigned long)dev);\n\t\t\ttasklet_init(&priv->done_task[1], talitos2_done_ch1_3,\n\t\t\t\t     (unsigned long)dev);\n\t\t} else if (priv->num_channels == 1) {\n\t\t\ttasklet_init(&priv->done_task[0], talitos2_done_ch0,\n\t\t\t\t     (unsigned long)dev);\n\t\t} else {\n\t\t\ttasklet_init(&priv->done_task[0], talitos2_done_4ch,\n\t\t\t\t     (unsigned long)dev);\n\t\t}\n\t}\n\n\tpriv->chan = devm_kcalloc(dev,\n\t\t\t\t  priv->num_channels,\n\t\t\t\t  sizeof(struct talitos_channel),\n\t\t\t\t  GFP_KERNEL);\n\tif (!priv->chan) {\n\t\tdev_err(dev, \"failed to allocate channel management space\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tpriv->fifo_len = roundup_pow_of_two(priv->chfifo_len);\n\n\tfor (i = 0; i < priv->num_channels; i++) {\n\t\tpriv->chan[i].reg = priv->reg + stride * (i + 1);\n\t\tif (!priv->irq[1] || !(i & 1))\n\t\t\tpriv->chan[i].reg += TALITOS_CH_BASE_OFFSET;\n\n\t\tspin_lock_init(&priv->chan[i].head_lock);\n\t\tspin_lock_init(&priv->chan[i].tail_lock);\n\n\t\tpriv->chan[i].fifo = devm_kcalloc(dev,\n\t\t\t\t\t\tpriv->fifo_len,\n\t\t\t\t\t\tsizeof(struct talitos_request),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!priv->chan[i].fifo) {\n\t\t\tdev_err(dev, \"failed to allocate request fifo %d\\n\", i);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tatomic_set(&priv->chan[i].submit_count,\n\t\t\t   -(priv->chfifo_len - 1));\n\t}\n\n\tdma_set_mask(dev, DMA_BIT_MASK(36));\n\n\t \n\terr = init_device(dev);\n\tif (err) {\n\t\tdev_err(dev, \"failed to initialize device\\n\");\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (hw_supports(dev, DESC_HDR_SEL0_RNG)) {\n\t\terr = talitos_register_rng(dev);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to register hwrng: %d\\n\", err);\n\t\t\tgoto err_out;\n\t\t} else\n\t\t\tdev_info(dev, \"hwrng\\n\");\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(driver_algs); i++) {\n\t\tif (hw_supports(dev, driver_algs[i].desc_hdr_template)) {\n\t\t\tstruct talitos_crypto_alg *t_alg;\n\t\t\tstruct crypto_alg *alg = NULL;\n\n\t\t\tt_alg = talitos_alg_alloc(dev, &driver_algs[i]);\n\t\t\tif (IS_ERR(t_alg)) {\n\t\t\t\terr = PTR_ERR(t_alg);\n\t\t\t\tif (err == -ENOTSUPP)\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tswitch (t_alg->algt.type) {\n\t\t\tcase CRYPTO_ALG_TYPE_SKCIPHER:\n\t\t\t\terr = crypto_register_skcipher(\n\t\t\t\t\t\t&t_alg->algt.alg.skcipher);\n\t\t\t\talg = &t_alg->algt.alg.skcipher.base;\n\t\t\t\tbreak;\n\n\t\t\tcase CRYPTO_ALG_TYPE_AEAD:\n\t\t\t\terr = crypto_register_aead(\n\t\t\t\t\t&t_alg->algt.alg.aead);\n\t\t\t\talg = &t_alg->algt.alg.aead.base;\n\t\t\t\tbreak;\n\n\t\t\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\t\t\terr = crypto_register_ahash(\n\t\t\t\t\t\t&t_alg->algt.alg.hash);\n\t\t\t\talg = &t_alg->algt.alg.hash.halg.base;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (err) {\n\t\t\t\tdev_err(dev, \"%s alg registration failed\\n\",\n\t\t\t\t\talg->cra_driver_name);\n\t\t\t\tdevm_kfree(dev, t_alg);\n\t\t\t} else\n\t\t\t\tlist_add_tail(&t_alg->entry, &priv->alg_list);\n\t\t}\n\t}\n\tif (!list_empty(&priv->alg_list))\n\t\tdev_info(dev, \"%s algorithms registered in /proc/crypto\\n\",\n\t\t\t (char *)of_get_property(np, \"compatible\", NULL));\n\n\treturn 0;\n\nerr_out:\n\ttalitos_remove(ofdev);\n\n\treturn err;\n}\n\nstatic const struct of_device_id talitos_match[] = {\n#ifdef CONFIG_CRYPTO_DEV_TALITOS1\n\t{\n\t\t.compatible = \"fsl,sec1.0\",\n\t},\n#endif\n#ifdef CONFIG_CRYPTO_DEV_TALITOS2\n\t{\n\t\t.compatible = \"fsl,sec2.0\",\n\t},\n#endif\n\t{},\n};\nMODULE_DEVICE_TABLE(of, talitos_match);\n\nstatic struct platform_driver talitos_driver = {\n\t.driver = {\n\t\t.name = \"talitos\",\n\t\t.of_match_table = talitos_match,\n\t},\n\t.probe = talitos_probe,\n\t.remove = talitos_remove,\n};\n\nmodule_platform_driver(talitos_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kim Phillips <kim.phillips@freescale.com>\");\nMODULE_DESCRIPTION(\"Freescale integrated security engine (SEC) driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}