{
  "module_name": "adf_dh895xcc_hw_data.c",
  "hash_id": "cf1adbf393af91e0b84303660de059a1d4f734362111e0f2ca51051781fdfb9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_dh895xcc/adf_dh895xcc_hw_data.c",
  "human_readable_source": "\n \n#include <adf_accel_devices.h>\n#include <adf_common_drv.h>\n#include <adf_gen2_config.h>\n#include <adf_gen2_dc.h>\n#include <adf_gen2_hw_data.h>\n#include <adf_gen2_pfvf.h>\n#include \"adf_dh895xcc_hw_data.h\"\n#include \"adf_heartbeat.h\"\n#include \"icp_qat_hw.h\"\n\n#define ADF_DH895XCC_VF_MSK\t0xFFFFFFFF\n\n \nstatic const u32 thrd_to_arb_map[ADF_DH895XCC_MAX_ACCELENGINES] = {\n\t0x12222AAA, 0x11666666, 0x12222AAA, 0x11666666,\n\t0x12222AAA, 0x11222222, 0x12222AAA, 0x11222222,\n\t0x12222AAA, 0x11222222, 0x12222AAA, 0x11222222\n};\n\nstatic struct adf_hw_device_class dh895xcc_class = {\n\t.name = ADF_DH895XCC_DEVICE_NAME,\n\t.type = DEV_DH895XCC,\n\t.instances = 0\n};\n\nstatic u32 get_accel_mask(struct adf_hw_device_data *self)\n{\n\tu32 fuses = self->fuses;\n\n\treturn ~fuses >> ADF_DH895XCC_ACCELERATORS_REG_OFFSET &\n\t\t\t ADF_DH895XCC_ACCELERATORS_MASK;\n}\n\nstatic u32 get_ae_mask(struct adf_hw_device_data *self)\n{\n\tu32 fuses = self->fuses;\n\n\treturn ~fuses & ADF_DH895XCC_ACCELENGINES_MASK;\n}\n\nstatic u32 get_misc_bar_id(struct adf_hw_device_data *self)\n{\n\treturn ADF_DH895XCC_PMISC_BAR;\n}\n\nstatic u32 get_ts_clock(struct adf_hw_device_data *self)\n{\n\t \n\treturn self->clock_frequency / 16;\n}\n\nstatic u32 get_etr_bar_id(struct adf_hw_device_data *self)\n{\n\treturn ADF_DH895XCC_ETR_BAR;\n}\n\nstatic u32 get_sram_bar_id(struct adf_hw_device_data *self)\n{\n\treturn ADF_DH895XCC_SRAM_BAR;\n}\n\nstatic u32 get_accel_cap(struct adf_accel_dev *accel_dev)\n{\n\tstruct pci_dev *pdev = accel_dev->accel_pci_dev.pci_dev;\n\tu32 capabilities;\n\tu32 legfuses;\n\n\tcapabilities = ICP_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC |\n\t\t       ICP_ACCEL_CAPABILITIES_CRYPTO_ASYMMETRIC |\n\t\t       ICP_ACCEL_CAPABILITIES_AUTHENTICATION |\n\t\t       ICP_ACCEL_CAPABILITIES_CIPHER |\n\t\t       ICP_ACCEL_CAPABILITIES_COMPRESSION;\n\n\t \n\tpci_read_config_dword(pdev, ADF_DEVICE_LEGFUSE_OFFSET, &legfuses);\n\n\t \n\tif (legfuses & ICP_ACCEL_MASK_CIPHER_SLICE) {\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC;\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_CIPHER;\n\t}\n\tif (legfuses & ICP_ACCEL_MASK_PKE_SLICE)\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_CRYPTO_ASYMMETRIC;\n\tif (legfuses & ICP_ACCEL_MASK_AUTH_SLICE) {\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_AUTHENTICATION;\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_CIPHER;\n\t}\n\tif (legfuses & ICP_ACCEL_MASK_COMPRESS_SLICE)\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_COMPRESSION;\n\n\treturn capabilities;\n}\n\nstatic enum dev_sku_info get_sku(struct adf_hw_device_data *self)\n{\n\tint sku = (self->fuses & ADF_DH895XCC_FUSECTL_SKU_MASK)\n\t    >> ADF_DH895XCC_FUSECTL_SKU_SHIFT;\n\n\tswitch (sku) {\n\tcase ADF_DH895XCC_FUSECTL_SKU_1:\n\t\treturn DEV_SKU_1;\n\tcase ADF_DH895XCC_FUSECTL_SKU_2:\n\t\treturn DEV_SKU_2;\n\tcase ADF_DH895XCC_FUSECTL_SKU_3:\n\t\treturn DEV_SKU_3;\n\tcase ADF_DH895XCC_FUSECTL_SKU_4:\n\t\treturn DEV_SKU_4;\n\tdefault:\n\t\treturn DEV_SKU_UNKNOWN;\n\t}\n\treturn DEV_SKU_UNKNOWN;\n}\n\nstatic const u32 *adf_get_arbiter_mapping(struct adf_accel_dev *accel_dev)\n{\n\treturn thrd_to_arb_map;\n}\n\nstatic void enable_vf2pf_interrupts(void __iomem *pmisc_addr, u32 vf_mask)\n{\n\t \n\tif (vf_mask & 0xFFFF) {\n\t\tu32 val = ADF_CSR_RD(pmisc_addr, ADF_GEN2_ERRMSK3)\n\t\t\t  & ~ADF_DH895XCC_ERR_MSK_VF2PF_L(vf_mask);\n\t\tADF_CSR_WR(pmisc_addr, ADF_GEN2_ERRMSK3, val);\n\t}\n\n\t \n\tif (vf_mask >> 16) {\n\t\tu32 val = ADF_CSR_RD(pmisc_addr, ADF_GEN2_ERRMSK5)\n\t\t\t  & ~ADF_DH895XCC_ERR_MSK_VF2PF_U(vf_mask);\n\t\tADF_CSR_WR(pmisc_addr, ADF_GEN2_ERRMSK5, val);\n\t}\n}\n\nstatic void disable_all_vf2pf_interrupts(void __iomem *pmisc_addr)\n{\n\tu32 val;\n\n\t \n\tval = ADF_CSR_RD(pmisc_addr, ADF_GEN2_ERRMSK3)\n\t      | ADF_DH895XCC_ERR_MSK_VF2PF_L(ADF_DH895XCC_VF_MSK);\n\tADF_CSR_WR(pmisc_addr, ADF_GEN2_ERRMSK3, val);\n\n\t \n\tval = ADF_CSR_RD(pmisc_addr, ADF_GEN2_ERRMSK5)\n\t      | ADF_DH895XCC_ERR_MSK_VF2PF_U(ADF_DH895XCC_VF_MSK);\n\tADF_CSR_WR(pmisc_addr, ADF_GEN2_ERRMSK5, val);\n}\n\nstatic u32 disable_pending_vf2pf_interrupts(void __iomem *pmisc_addr)\n{\n\tu32 sources, pending, disabled;\n\tu32 errsou3, errmsk3;\n\tu32 errsou5, errmsk5;\n\n\t \n\terrsou3 = ADF_CSR_RD(pmisc_addr, ADF_GEN2_ERRSOU3);\n\terrsou5 = ADF_CSR_RD(pmisc_addr, ADF_GEN2_ERRSOU5);\n\tsources = ADF_DH895XCC_ERR_REG_VF2PF_L(errsou3)\n\t\t  | ADF_DH895XCC_ERR_REG_VF2PF_U(errsou5);\n\n\tif (!sources)\n\t\treturn 0;\n\n\t \n\terrmsk3 = ADF_CSR_RD(pmisc_addr, ADF_GEN2_ERRMSK3);\n\terrmsk5 = ADF_CSR_RD(pmisc_addr, ADF_GEN2_ERRMSK5);\n\tdisabled = ADF_DH895XCC_ERR_REG_VF2PF_L(errmsk3)\n\t\t   | ADF_DH895XCC_ERR_REG_VF2PF_U(errmsk5);\n\n\tpending = sources & ~disabled;\n\tif (!pending)\n\t\treturn 0;\n\n\t \n\terrmsk3 |= ADF_DH895XCC_ERR_MSK_VF2PF_L(ADF_DH895XCC_VF_MSK);\n\terrmsk5 |= ADF_DH895XCC_ERR_MSK_VF2PF_U(ADF_DH895XCC_VF_MSK);\n\tADF_CSR_WR(pmisc_addr, ADF_GEN2_ERRMSK3, errmsk3);\n\tADF_CSR_WR(pmisc_addr, ADF_GEN2_ERRMSK5, errmsk5);\n\n\terrmsk3 &= ADF_DH895XCC_ERR_MSK_VF2PF_L(sources | disabled);\n\terrmsk5 &= ADF_DH895XCC_ERR_MSK_VF2PF_U(sources | disabled);\n\tADF_CSR_WR(pmisc_addr, ADF_GEN2_ERRMSK3, errmsk3);\n\tADF_CSR_WR(pmisc_addr, ADF_GEN2_ERRMSK5, errmsk5);\n\n\t \n\treturn pending;\n}\n\nstatic void configure_iov_threads(struct adf_accel_dev *accel_dev, bool enable)\n{\n\tadf_gen2_cfg_iov_thds(accel_dev, enable,\n\t\t\t      ADF_DH895XCC_AE2FUNC_MAP_GRP_A_NUM_REGS,\n\t\t\t      ADF_DH895XCC_AE2FUNC_MAP_GRP_B_NUM_REGS);\n}\n\nvoid adf_init_hw_data_dh895xcc(struct adf_hw_device_data *hw_data)\n{\n\thw_data->dev_class = &dh895xcc_class;\n\thw_data->instance_id = dh895xcc_class.instances++;\n\thw_data->num_banks = ADF_DH895XCC_ETR_MAX_BANKS;\n\thw_data->num_rings_per_bank = ADF_ETR_MAX_RINGS_PER_BANK;\n\thw_data->num_accel = ADF_DH895XCC_MAX_ACCELERATORS;\n\thw_data->num_logical_accel = 1;\n\thw_data->num_engines = ADF_DH895XCC_MAX_ACCELENGINES;\n\thw_data->tx_rx_gap = ADF_GEN2_RX_RINGS_OFFSET;\n\thw_data->tx_rings_mask = ADF_GEN2_TX_RINGS_MASK;\n\thw_data->ring_to_svc_map = ADF_GEN2_DEFAULT_RING_TO_SRV_MAP;\n\thw_data->alloc_irq = adf_isr_resource_alloc;\n\thw_data->free_irq = adf_isr_resource_free;\n\thw_data->enable_error_correction = adf_gen2_enable_error_correction;\n\thw_data->get_accel_mask = get_accel_mask;\n\thw_data->get_ae_mask = get_ae_mask;\n\thw_data->get_accel_cap = get_accel_cap;\n\thw_data->get_num_accels = adf_gen2_get_num_accels;\n\thw_data->get_num_aes = adf_gen2_get_num_aes;\n\thw_data->get_etr_bar_id = get_etr_bar_id;\n\thw_data->get_misc_bar_id = get_misc_bar_id;\n\thw_data->get_admin_info = adf_gen2_get_admin_info;\n\thw_data->get_arb_info = adf_gen2_get_arb_info;\n\thw_data->get_sram_bar_id = get_sram_bar_id;\n\thw_data->get_sku = get_sku;\n\thw_data->fw_name = ADF_DH895XCC_FW;\n\thw_data->fw_mmp_name = ADF_DH895XCC_MMP;\n\thw_data->init_admin_comms = adf_init_admin_comms;\n\thw_data->exit_admin_comms = adf_exit_admin_comms;\n\thw_data->configure_iov_threads = configure_iov_threads;\n\thw_data->send_admin_init = adf_send_admin_init;\n\thw_data->init_arb = adf_init_arb;\n\thw_data->exit_arb = adf_exit_arb;\n\thw_data->get_arb_mapping = adf_get_arbiter_mapping;\n\thw_data->enable_ints = adf_gen2_enable_ints;\n\thw_data->reset_device = adf_reset_sbr;\n\thw_data->disable_iov = adf_disable_sriov;\n\thw_data->dev_config = adf_gen2_dev_config;\n\thw_data->clock_frequency = ADF_DH895X_AE_FREQ;\n\thw_data->get_hb_clock = get_ts_clock;\n\thw_data->num_hb_ctrs = ADF_NUM_HB_CNT_PER_AE;\n\thw_data->check_hb_ctrs = adf_heartbeat_check_ctrs;\n\n\tadf_gen2_init_pf_pfvf_ops(&hw_data->pfvf_ops);\n\thw_data->pfvf_ops.enable_vf2pf_interrupts = enable_vf2pf_interrupts;\n\thw_data->pfvf_ops.disable_all_vf2pf_interrupts = disable_all_vf2pf_interrupts;\n\thw_data->pfvf_ops.disable_pending_vf2pf_interrupts = disable_pending_vf2pf_interrupts;\n\tadf_gen2_init_hw_csr_ops(&hw_data->csr_ops);\n\tadf_gen2_init_dc_ops(&hw_data->dc_ops);\n}\n\nvoid adf_clean_hw_data_dh895xcc(struct adf_hw_device_data *hw_data)\n{\n\thw_data->dev_class->instances--;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}