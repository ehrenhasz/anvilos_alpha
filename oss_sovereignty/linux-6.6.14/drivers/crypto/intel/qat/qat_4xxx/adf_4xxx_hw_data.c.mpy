{
  "module_name": "adf_4xxx_hw_data.c",
  "hash_id": "11036bc51cd01d51b75fe1900b22cb4332c0875c6c8e0e1bfb3489b269048590",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_4xxx/adf_4xxx_hw_data.c",
  "human_readable_source": "\n \n#include <linux/iopoll.h>\n#include <adf_accel_devices.h>\n#include <adf_cfg.h>\n#include <adf_clock.h>\n#include <adf_common_drv.h>\n#include <adf_gen4_dc.h>\n#include <adf_gen4_hw_data.h>\n#include <adf_gen4_pfvf.h>\n#include <adf_gen4_pm.h>\n#include <adf_gen4_timer.h>\n#include \"adf_4xxx_hw_data.h\"\n#include \"adf_cfg_services.h\"\n#include \"icp_qat_hw.h\"\n\n#define ADF_AE_GROUP_0\t\tGENMASK(3, 0)\n#define ADF_AE_GROUP_1\t\tGENMASK(7, 4)\n#define ADF_AE_GROUP_2\t\tBIT(8)\n\nenum adf_fw_objs {\n\tADF_FW_SYM_OBJ,\n\tADF_FW_ASYM_OBJ,\n\tADF_FW_DC_OBJ,\n\tADF_FW_ADMIN_OBJ,\n};\n\nstatic const char * const adf_4xxx_fw_objs[] = {\n\t[ADF_FW_SYM_OBJ] =  ADF_4XXX_SYM_OBJ,\n\t[ADF_FW_ASYM_OBJ] =  ADF_4XXX_ASYM_OBJ,\n\t[ADF_FW_DC_OBJ] =  ADF_4XXX_DC_OBJ,\n\t[ADF_FW_ADMIN_OBJ] = ADF_4XXX_ADMIN_OBJ,\n};\n\nstatic const char * const adf_402xx_fw_objs[] = {\n\t[ADF_FW_SYM_OBJ] =  ADF_402XX_SYM_OBJ,\n\t[ADF_FW_ASYM_OBJ] =  ADF_402XX_ASYM_OBJ,\n\t[ADF_FW_DC_OBJ] =  ADF_402XX_DC_OBJ,\n\t[ADF_FW_ADMIN_OBJ] = ADF_402XX_ADMIN_OBJ,\n};\n\nstruct adf_fw_config {\n\tu32 ae_mask;\n\tenum adf_fw_objs obj;\n};\n\nstatic const struct adf_fw_config adf_fw_cy_config[] = {\n\t{ADF_AE_GROUP_1, ADF_FW_SYM_OBJ},\n\t{ADF_AE_GROUP_0, ADF_FW_ASYM_OBJ},\n\t{ADF_AE_GROUP_2, ADF_FW_ADMIN_OBJ},\n};\n\nstatic const struct adf_fw_config adf_fw_dc_config[] = {\n\t{ADF_AE_GROUP_1, ADF_FW_DC_OBJ},\n\t{ADF_AE_GROUP_0, ADF_FW_DC_OBJ},\n\t{ADF_AE_GROUP_2, ADF_FW_ADMIN_OBJ},\n};\n\nstatic const struct adf_fw_config adf_fw_sym_config[] = {\n\t{ADF_AE_GROUP_1, ADF_FW_SYM_OBJ},\n\t{ADF_AE_GROUP_0, ADF_FW_SYM_OBJ},\n\t{ADF_AE_GROUP_2, ADF_FW_ADMIN_OBJ},\n};\n\nstatic const struct adf_fw_config adf_fw_asym_config[] = {\n\t{ADF_AE_GROUP_1, ADF_FW_ASYM_OBJ},\n\t{ADF_AE_GROUP_0, ADF_FW_ASYM_OBJ},\n\t{ADF_AE_GROUP_2, ADF_FW_ADMIN_OBJ},\n};\n\nstatic const struct adf_fw_config adf_fw_asym_dc_config[] = {\n\t{ADF_AE_GROUP_1, ADF_FW_ASYM_OBJ},\n\t{ADF_AE_GROUP_0, ADF_FW_DC_OBJ},\n\t{ADF_AE_GROUP_2, ADF_FW_ADMIN_OBJ},\n};\n\nstatic const struct adf_fw_config adf_fw_sym_dc_config[] = {\n\t{ADF_AE_GROUP_1, ADF_FW_SYM_OBJ},\n\t{ADF_AE_GROUP_0, ADF_FW_DC_OBJ},\n\t{ADF_AE_GROUP_2, ADF_FW_ADMIN_OBJ},\n};\n\nstatic const struct adf_fw_config adf_fw_dcc_config[] = {\n\t{ADF_AE_GROUP_1, ADF_FW_DC_OBJ},\n\t{ADF_AE_GROUP_0, ADF_FW_SYM_OBJ},\n\t{ADF_AE_GROUP_2, ADF_FW_ADMIN_OBJ},\n};\n\nstatic_assert(ARRAY_SIZE(adf_fw_cy_config) == ARRAY_SIZE(adf_fw_dc_config));\nstatic_assert(ARRAY_SIZE(adf_fw_cy_config) == ARRAY_SIZE(adf_fw_sym_config));\nstatic_assert(ARRAY_SIZE(adf_fw_cy_config) == ARRAY_SIZE(adf_fw_asym_config));\nstatic_assert(ARRAY_SIZE(adf_fw_cy_config) == ARRAY_SIZE(adf_fw_asym_dc_config));\nstatic_assert(ARRAY_SIZE(adf_fw_cy_config) == ARRAY_SIZE(adf_fw_sym_dc_config));\nstatic_assert(ARRAY_SIZE(adf_fw_cy_config) == ARRAY_SIZE(adf_fw_dcc_config));\n\n \nstatic const u32 default_thrd_to_arb_map[ADF_4XXX_MAX_ACCELENGINES] = {\n\t0x5555555, 0x5555555, 0x5555555, 0x5555555,\n\t0xAAAAAAA, 0xAAAAAAA, 0xAAAAAAA, 0xAAAAAAA,\n\t0x0\n};\n\nstatic const u32 thrd_to_arb_map_dc[ADF_4XXX_MAX_ACCELENGINES] = {\n\t0x000000FF, 0x000000FF, 0x000000FF, 0x000000FF,\n\t0x000000FF, 0x000000FF, 0x000000FF, 0x000000FF,\n\t0x0\n};\n\nstatic const u32 thrd_to_arb_map_dcc[ADF_4XXX_MAX_ACCELENGINES] = {\n\t0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t0x0000FFFF, 0x0000FFFF, 0x0000FFFF, 0x0000FFFF,\n\t0x0\n};\n\nstatic struct adf_hw_device_class adf_4xxx_class = {\n\t.name = ADF_4XXX_DEVICE_NAME,\n\t.type = DEV_4XXX,\n\t.instances = 0,\n};\n\nstatic int get_service_enabled(struct adf_accel_dev *accel_dev)\n{\n\tchar services[ADF_CFG_MAX_VAL_LEN_IN_BYTES] = {0};\n\tint ret;\n\n\tret = adf_cfg_get_param_value(accel_dev, ADF_GENERAL_SEC,\n\t\t\t\t      ADF_SERVICES_ENABLED, services);\n\tif (ret) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\tADF_SERVICES_ENABLED \" param not found\\n\");\n\t\treturn ret;\n\t}\n\n\tret = match_string(adf_cfg_services, ARRAY_SIZE(adf_cfg_services),\n\t\t\t   services);\n\tif (ret < 0)\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Invalid value of \" ADF_SERVICES_ENABLED \" param: %s\\n\",\n\t\t\tservices);\n\n\treturn ret;\n}\n\nstatic u32 get_accel_mask(struct adf_hw_device_data *self)\n{\n\treturn ADF_4XXX_ACCELERATORS_MASK;\n}\n\nstatic u32 get_ae_mask(struct adf_hw_device_data *self)\n{\n\tu32 me_disable = self->fuses;\n\n\treturn ~me_disable & ADF_4XXX_ACCELENGINES_MASK;\n}\n\nstatic u32 get_num_accels(struct adf_hw_device_data *self)\n{\n\treturn ADF_4XXX_MAX_ACCELERATORS;\n}\n\nstatic u32 get_num_aes(struct adf_hw_device_data *self)\n{\n\tif (!self || !self->ae_mask)\n\t\treturn 0;\n\n\treturn hweight32(self->ae_mask);\n}\n\nstatic u32 get_misc_bar_id(struct adf_hw_device_data *self)\n{\n\treturn ADF_4XXX_PMISC_BAR;\n}\n\nstatic u32 get_etr_bar_id(struct adf_hw_device_data *self)\n{\n\treturn ADF_4XXX_ETR_BAR;\n}\n\nstatic u32 get_sram_bar_id(struct adf_hw_device_data *self)\n{\n\treturn ADF_4XXX_SRAM_BAR;\n}\n\n \nstatic void set_msix_default_rttable(struct adf_accel_dev *accel_dev)\n{\n\tvoid __iomem *csr;\n\tint i;\n\n\tcsr = (&GET_BARS(accel_dev)[ADF_4XXX_PMISC_BAR])->virt_addr;\n\tfor (i = 0; i <= ADF_4XXX_ETR_MAX_BANKS; i++)\n\t\tADF_CSR_WR(csr, ADF_4XXX_MSIX_RTTABLE_OFFSET(i), i);\n}\n\nstatic u32 get_accel_cap(struct adf_accel_dev *accel_dev)\n{\n\tstruct pci_dev *pdev = accel_dev->accel_pci_dev.pci_dev;\n\tu32 capabilities_sym, capabilities_asym, capabilities_dc;\n\tu32 capabilities_dcc;\n\tu32 fusectl1;\n\n\t \n\tpci_read_config_dword(pdev, ADF_4XXX_FUSECTL1_OFFSET, &fusectl1);\n\n\tcapabilities_sym = ICP_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC |\n\t\t\t  ICP_ACCEL_CAPABILITIES_CIPHER |\n\t\t\t  ICP_ACCEL_CAPABILITIES_AUTHENTICATION |\n\t\t\t  ICP_ACCEL_CAPABILITIES_SHA3 |\n\t\t\t  ICP_ACCEL_CAPABILITIES_SHA3_EXT |\n\t\t\t  ICP_ACCEL_CAPABILITIES_HKDF |\n\t\t\t  ICP_ACCEL_CAPABILITIES_CHACHA_POLY |\n\t\t\t  ICP_ACCEL_CAPABILITIES_AESGCM_SPC |\n\t\t\t  ICP_ACCEL_CAPABILITIES_SM3 |\n\t\t\t  ICP_ACCEL_CAPABILITIES_SM4 |\n\t\t\t  ICP_ACCEL_CAPABILITIES_AES_V2;\n\n\t \n\tif (fusectl1 & ICP_ACCEL_4XXX_MASK_CIPHER_SLICE) {\n\t\tcapabilities_sym &= ~ICP_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC;\n\t\tcapabilities_sym &= ~ICP_ACCEL_CAPABILITIES_HKDF;\n\t\tcapabilities_sym &= ~ICP_ACCEL_CAPABILITIES_CIPHER;\n\t}\n\n\tif (fusectl1 & ICP_ACCEL_4XXX_MASK_UCS_SLICE) {\n\t\tcapabilities_sym &= ~ICP_ACCEL_CAPABILITIES_CHACHA_POLY;\n\t\tcapabilities_sym &= ~ICP_ACCEL_CAPABILITIES_AESGCM_SPC;\n\t\tcapabilities_sym &= ~ICP_ACCEL_CAPABILITIES_AES_V2;\n\t\tcapabilities_sym &= ~ICP_ACCEL_CAPABILITIES_CIPHER;\n\t}\n\n\tif (fusectl1 & ICP_ACCEL_4XXX_MASK_AUTH_SLICE) {\n\t\tcapabilities_sym &= ~ICP_ACCEL_CAPABILITIES_AUTHENTICATION;\n\t\tcapabilities_sym &= ~ICP_ACCEL_CAPABILITIES_SHA3;\n\t\tcapabilities_sym &= ~ICP_ACCEL_CAPABILITIES_SHA3_EXT;\n\t\tcapabilities_sym &= ~ICP_ACCEL_CAPABILITIES_CIPHER;\n\t}\n\n\tif (fusectl1 & ICP_ACCEL_4XXX_MASK_SMX_SLICE) {\n\t\tcapabilities_sym &= ~ICP_ACCEL_CAPABILITIES_SM3;\n\t\tcapabilities_sym &= ~ICP_ACCEL_CAPABILITIES_SM4;\n\t}\n\n\tcapabilities_asym = ICP_ACCEL_CAPABILITIES_CRYPTO_ASYMMETRIC |\n\t\t\t  ICP_ACCEL_CAPABILITIES_CIPHER |\n\t\t\t  ICP_ACCEL_CAPABILITIES_SM2 |\n\t\t\t  ICP_ACCEL_CAPABILITIES_ECEDMONT;\n\n\tif (fusectl1 & ICP_ACCEL_4XXX_MASK_PKE_SLICE) {\n\t\tcapabilities_asym &= ~ICP_ACCEL_CAPABILITIES_CRYPTO_ASYMMETRIC;\n\t\tcapabilities_asym &= ~ICP_ACCEL_CAPABILITIES_SM2;\n\t\tcapabilities_asym &= ~ICP_ACCEL_CAPABILITIES_ECEDMONT;\n\t}\n\n\tcapabilities_dc = ICP_ACCEL_CAPABILITIES_COMPRESSION |\n\t\t\t  ICP_ACCEL_CAPABILITIES_LZ4_COMPRESSION |\n\t\t\t  ICP_ACCEL_CAPABILITIES_LZ4S_COMPRESSION |\n\t\t\t  ICP_ACCEL_CAPABILITIES_CNV_INTEGRITY64;\n\n\tif (fusectl1 & ICP_ACCEL_4XXX_MASK_COMPRESS_SLICE) {\n\t\tcapabilities_dc &= ~ICP_ACCEL_CAPABILITIES_COMPRESSION;\n\t\tcapabilities_dc &= ~ICP_ACCEL_CAPABILITIES_LZ4_COMPRESSION;\n\t\tcapabilities_dc &= ~ICP_ACCEL_CAPABILITIES_LZ4S_COMPRESSION;\n\t\tcapabilities_dc &= ~ICP_ACCEL_CAPABILITIES_CNV_INTEGRITY64;\n\t}\n\n\tswitch (get_service_enabled(accel_dev)) {\n\tcase SVC_CY:\n\tcase SVC_CY2:\n\t\treturn capabilities_sym | capabilities_asym;\n\tcase SVC_DC:\n\t\treturn capabilities_dc;\n\tcase SVC_DCC:\n\t\t \n\t\tcapabilities_dcc = capabilities_dc | capabilities_sym;\n\t\tcapabilities_dcc &= ~ICP_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC;\n\t\treturn capabilities_dcc;\n\tcase SVC_SYM:\n\t\treturn capabilities_sym;\n\tcase SVC_ASYM:\n\t\treturn capabilities_asym;\n\tcase SVC_ASYM_DC:\n\tcase SVC_DC_ASYM:\n\t\treturn capabilities_asym | capabilities_dc;\n\tcase SVC_SYM_DC:\n\tcase SVC_DC_SYM:\n\t\treturn capabilities_sym | capabilities_dc;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic enum dev_sku_info get_sku(struct adf_hw_device_data *self)\n{\n\treturn DEV_SKU_1;\n}\n\nstatic const u32 *adf_get_arbiter_mapping(struct adf_accel_dev *accel_dev)\n{\n\tswitch (get_service_enabled(accel_dev)) {\n\tcase SVC_DC:\n\t\treturn thrd_to_arb_map_dc;\n\tcase SVC_DCC:\n\t\treturn thrd_to_arb_map_dcc;\n\tdefault:\n\t\treturn default_thrd_to_arb_map;\n\t}\n}\n\nstatic void get_arb_info(struct arb_info *arb_info)\n{\n\tarb_info->arb_cfg = ADF_4XXX_ARB_CONFIG;\n\tarb_info->arb_offset = ADF_4XXX_ARB_OFFSET;\n\tarb_info->wt2sam_offset = ADF_4XXX_ARB_WRK_2_SER_MAP_OFFSET;\n}\n\nstatic void get_admin_info(struct admin_info *admin_csrs_info)\n{\n\tadmin_csrs_info->mailbox_offset = ADF_4XXX_MAILBOX_BASE_OFFSET;\n\tadmin_csrs_info->admin_msg_ur = ADF_4XXX_ADMINMSGUR_OFFSET;\n\tadmin_csrs_info->admin_msg_lr = ADF_4XXX_ADMINMSGLR_OFFSET;\n}\n\nstatic u32 get_heartbeat_clock(struct adf_hw_device_data *self)\n{\n\t \n\treturn ADF_4XXX_KPT_COUNTER_FREQ;\n}\n\nstatic void adf_enable_error_correction(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_bar *misc_bar = &GET_BARS(accel_dev)[ADF_4XXX_PMISC_BAR];\n\tvoid __iomem *csr = misc_bar->virt_addr;\n\n\t \n\tADF_CSR_WR(csr, ADF_GEN4_ERRMSK3, ADF_GEN4_VFLNOTIFY);\n}\n\nstatic void adf_enable_ints(struct adf_accel_dev *accel_dev)\n{\n\tvoid __iomem *addr;\n\n\taddr = (&GET_BARS(accel_dev)[ADF_4XXX_PMISC_BAR])->virt_addr;\n\n\t \n\tADF_CSR_WR(addr, ADF_4XXX_SMIAPF_RP_X0_MASK_OFFSET, 0);\n\tADF_CSR_WR(addr, ADF_4XXX_SMIAPF_RP_X1_MASK_OFFSET, 0);\n\n\t \n\tADF_CSR_WR(addr, ADF_4XXX_SMIAPF_MASK_OFFSET, 0);\n}\n\nstatic int adf_init_device(struct adf_accel_dev *accel_dev)\n{\n\tvoid __iomem *addr;\n\tu32 status;\n\tu32 csr;\n\tint ret;\n\n\taddr = (&GET_BARS(accel_dev)[ADF_4XXX_PMISC_BAR])->virt_addr;\n\n\t \n\tcsr = ADF_CSR_RD(addr, ADF_GEN4_ERRMSK2);\n\tcsr |= ADF_GEN4_PM_SOU;\n\tADF_CSR_WR(addr, ADF_GEN4_ERRMSK2, csr);\n\n\t \n\tADF_CSR_WR(addr, ADF_GEN4_PM_INTERRUPT, ADF_GEN4_PM_DRV_ACTIVE);\n\n\t \n\tret = read_poll_timeout(ADF_CSR_RD, status,\n\t\t\t\tstatus & ADF_GEN4_PM_INIT_STATE,\n\t\t\t\tADF_GEN4_PM_POLL_DELAY_US,\n\t\t\t\tADF_GEN4_PM_POLL_TIMEOUT_US, true, addr,\n\t\t\t\tADF_GEN4_PM_STATUS);\n\tif (ret)\n\t\tdev_err(&GET_DEV(accel_dev), \"Failed to power up the device\\n\");\n\n\treturn ret;\n}\n\nstatic u32 uof_get_num_objs(void)\n{\n\treturn ARRAY_SIZE(adf_fw_cy_config);\n}\n\nstatic const struct adf_fw_config *get_fw_config(struct adf_accel_dev *accel_dev)\n{\n\tswitch (get_service_enabled(accel_dev)) {\n\tcase SVC_CY:\n\tcase SVC_CY2:\n\t\treturn adf_fw_cy_config;\n\tcase SVC_DC:\n\t\treturn adf_fw_dc_config;\n\tcase SVC_DCC:\n\t\treturn adf_fw_dcc_config;\n\tcase SVC_SYM:\n\t\treturn adf_fw_sym_config;\n\tcase SVC_ASYM:\n\t\treturn adf_fw_asym_config;\n\tcase SVC_ASYM_DC:\n\tcase SVC_DC_ASYM:\n\t\treturn adf_fw_asym_dc_config;\n\tcase SVC_SYM_DC:\n\tcase SVC_DC_SYM:\n\t\treturn adf_fw_sym_dc_config;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nenum adf_rp_groups {\n\tRP_GROUP_0 = 0,\n\tRP_GROUP_1,\n\tRP_GROUP_COUNT\n};\n\nstatic u16 get_ring_to_svc_map(struct adf_accel_dev *accel_dev)\n{\n\tenum adf_cfg_service_type rps[RP_GROUP_COUNT];\n\tconst struct adf_fw_config *fw_config;\n\tu16 ring_to_svc_map;\n\tint i, j;\n\n\tfw_config = get_fw_config(accel_dev);\n\tif (!fw_config)\n\t\treturn 0;\n\n\tfor (i = 0; i < RP_GROUP_COUNT; i++) {\n\t\tswitch (fw_config[i].ae_mask) {\n\t\tcase ADF_AE_GROUP_0:\n\t\t\tj = RP_GROUP_0;\n\t\t\tbreak;\n\t\tcase ADF_AE_GROUP_1:\n\t\t\tj = RP_GROUP_1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\n\t\tswitch (fw_config[i].obj) {\n\t\tcase ADF_FW_SYM_OBJ:\n\t\t\trps[j] = SYM;\n\t\t\tbreak;\n\t\tcase ADF_FW_ASYM_OBJ:\n\t\t\trps[j] = ASYM;\n\t\t\tbreak;\n\t\tcase ADF_FW_DC_OBJ:\n\t\t\trps[j] = COMP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trps[j] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tring_to_svc_map = rps[RP_GROUP_0] << ADF_CFG_SERV_RING_PAIR_0_SHIFT |\n\t\t\t  rps[RP_GROUP_1] << ADF_CFG_SERV_RING_PAIR_1_SHIFT |\n\t\t\t  rps[RP_GROUP_0] << ADF_CFG_SERV_RING_PAIR_2_SHIFT |\n\t\t\t  rps[RP_GROUP_1] << ADF_CFG_SERV_RING_PAIR_3_SHIFT;\n\n\treturn ring_to_svc_map;\n}\n\nstatic const char *uof_get_name(struct adf_accel_dev *accel_dev, u32 obj_num,\n\t\t\t\tconst char * const fw_objs[], int num_objs)\n{\n\tconst struct adf_fw_config *fw_config;\n\tint id;\n\n\tfw_config = get_fw_config(accel_dev);\n\tif (fw_config)\n\t\tid = fw_config[obj_num].obj;\n\telse\n\t\tid = -EINVAL;\n\n\tif (id < 0 || id > num_objs)\n\t\treturn NULL;\n\n\treturn fw_objs[id];\n}\n\nstatic const char *uof_get_name_4xxx(struct adf_accel_dev *accel_dev, u32 obj_num)\n{\n\tint num_fw_objs = ARRAY_SIZE(adf_4xxx_fw_objs);\n\n\treturn uof_get_name(accel_dev, obj_num, adf_4xxx_fw_objs, num_fw_objs);\n}\n\nstatic const char *uof_get_name_402xx(struct adf_accel_dev *accel_dev, u32 obj_num)\n{\n\tint num_fw_objs = ARRAY_SIZE(adf_402xx_fw_objs);\n\n\treturn uof_get_name(accel_dev, obj_num, adf_402xx_fw_objs, num_fw_objs);\n}\n\nstatic u32 uof_get_ae_mask(struct adf_accel_dev *accel_dev, u32 obj_num)\n{\n\tconst struct adf_fw_config *fw_config;\n\n\tfw_config = get_fw_config(accel_dev);\n\tif (!fw_config)\n\t\treturn 0;\n\n\treturn fw_config[obj_num].ae_mask;\n}\n\nvoid adf_init_hw_data_4xxx(struct adf_hw_device_data *hw_data, u32 dev_id)\n{\n\thw_data->dev_class = &adf_4xxx_class;\n\thw_data->instance_id = adf_4xxx_class.instances++;\n\thw_data->num_banks = ADF_4XXX_ETR_MAX_BANKS;\n\thw_data->num_banks_per_vf = ADF_4XXX_NUM_BANKS_PER_VF;\n\thw_data->num_rings_per_bank = ADF_4XXX_NUM_RINGS_PER_BANK;\n\thw_data->num_accel = ADF_4XXX_MAX_ACCELERATORS;\n\thw_data->num_engines = ADF_4XXX_MAX_ACCELENGINES;\n\thw_data->num_logical_accel = 1;\n\thw_data->tx_rx_gap = ADF_4XXX_RX_RINGS_OFFSET;\n\thw_data->tx_rings_mask = ADF_4XXX_TX_RINGS_MASK;\n\thw_data->ring_to_svc_map = ADF_GEN4_DEFAULT_RING_TO_SRV_MAP;\n\thw_data->alloc_irq = adf_isr_resource_alloc;\n\thw_data->free_irq = adf_isr_resource_free;\n\thw_data->enable_error_correction = adf_enable_error_correction;\n\thw_data->get_accel_mask = get_accel_mask;\n\thw_data->get_ae_mask = get_ae_mask;\n\thw_data->get_num_accels = get_num_accels;\n\thw_data->get_num_aes = get_num_aes;\n\thw_data->get_sram_bar_id = get_sram_bar_id;\n\thw_data->get_etr_bar_id = get_etr_bar_id;\n\thw_data->get_misc_bar_id = get_misc_bar_id;\n\thw_data->get_arb_info = get_arb_info;\n\thw_data->get_admin_info = get_admin_info;\n\thw_data->get_accel_cap = get_accel_cap;\n\thw_data->get_sku = get_sku;\n\thw_data->init_admin_comms = adf_init_admin_comms;\n\thw_data->exit_admin_comms = adf_exit_admin_comms;\n\thw_data->send_admin_init = adf_send_admin_init;\n\thw_data->init_arb = adf_init_arb;\n\thw_data->exit_arb = adf_exit_arb;\n\thw_data->get_arb_mapping = adf_get_arbiter_mapping;\n\thw_data->enable_ints = adf_enable_ints;\n\thw_data->init_device = adf_init_device;\n\thw_data->reset_device = adf_reset_flr;\n\thw_data->admin_ae_mask = ADF_4XXX_ADMIN_AE_MASK;\n\tswitch (dev_id) {\n\tcase ADF_402XX_PCI_DEVICE_ID:\n\t\thw_data->fw_name = ADF_402XX_FW;\n\t\thw_data->fw_mmp_name = ADF_402XX_MMP;\n\t\thw_data->uof_get_name = uof_get_name_402xx;\n\t\tbreak;\n\n\tdefault:\n\t\thw_data->fw_name = ADF_4XXX_FW;\n\t\thw_data->fw_mmp_name = ADF_4XXX_MMP;\n\t\thw_data->uof_get_name = uof_get_name_4xxx;\n\t}\n\thw_data->uof_get_num_objs = uof_get_num_objs;\n\thw_data->uof_get_ae_mask = uof_get_ae_mask;\n\thw_data->set_msix_rttable = set_msix_default_rttable;\n\thw_data->set_ssm_wdtimer = adf_gen4_set_ssm_wdtimer;\n\thw_data->get_ring_to_svc_map = get_ring_to_svc_map;\n\thw_data->disable_iov = adf_disable_sriov;\n\thw_data->ring_pair_reset = adf_gen4_ring_pair_reset;\n\thw_data->enable_pm = adf_gen4_enable_pm;\n\thw_data->handle_pm_interrupt = adf_gen4_handle_pm_interrupt;\n\thw_data->dev_config = adf_gen4_dev_config;\n\thw_data->start_timer = adf_gen4_timer_start;\n\thw_data->stop_timer = adf_gen4_timer_stop;\n\thw_data->get_hb_clock = get_heartbeat_clock;\n\thw_data->num_hb_ctrs = ADF_NUM_HB_CNT_PER_AE;\n\n\tadf_gen4_init_hw_csr_ops(&hw_data->csr_ops);\n\tadf_gen4_init_pf_pfvf_ops(&hw_data->pfvf_ops);\n\tadf_gen4_init_dc_ops(&hw_data->dc_ops);\n}\n\nvoid adf_clean_hw_data_4xxx(struct adf_hw_device_data *hw_data)\n{\n\thw_data->dev_class->instances--;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}