{
  "module_name": "adf_drv.c",
  "hash_id": "04152edd313485167c990923da7f577e602eba6c56fa0f3eef2ff198a0653661",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_4xxx/adf_drv.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include <adf_accel_devices.h>\n#include <adf_cfg.h>\n#include <adf_common_drv.h>\n#include <adf_dbgfs.h>\n#include <adf_heartbeat.h>\n\n#include \"adf_4xxx_hw_data.h\"\n#include \"adf_cfg_services.h\"\n#include \"qat_compression.h\"\n#include \"qat_crypto.h\"\n#include \"adf_transport_access_macros.h\"\n\nstatic const struct pci_device_id adf_pci_tbl[] = {\n\t{ PCI_VDEVICE(INTEL, ADF_4XXX_PCI_DEVICE_ID), },\n\t{ PCI_VDEVICE(INTEL, ADF_401XX_PCI_DEVICE_ID), },\n\t{ PCI_VDEVICE(INTEL, ADF_402XX_PCI_DEVICE_ID), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, adf_pci_tbl);\n\nstatic void adf_cleanup_accel(struct adf_accel_dev *accel_dev)\n{\n\tif (accel_dev->hw_device) {\n\t\tadf_clean_hw_data_4xxx(accel_dev->hw_device);\n\t\taccel_dev->hw_device = NULL;\n\t}\n\tadf_dbgfs_exit(accel_dev);\n\tadf_cfg_dev_remove(accel_dev);\n\tadf_devmgr_rm_dev(accel_dev, NULL);\n}\n\nstatic int adf_cfg_dev_init(struct adf_accel_dev *accel_dev)\n{\n\tconst char *config;\n\tint ret;\n\n\tconfig = accel_dev->accel_id % 2 ? ADF_CFG_DC : ADF_CFG_CY;\n\n\tret = adf_cfg_section_add(accel_dev, ADF_GENERAL_SEC);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = adf_cfg_add_key_value_param(accel_dev, ADF_GENERAL_SEC,\n\t\t\t\t\t  ADF_SERVICES_ENABLED, config,\n\t\t\t\t\t  ADF_STR);\n\tif (ret)\n\t\treturn ret;\n\n\tadf_heartbeat_save_cfg_param(accel_dev, ADF_CFG_HB_TIMER_MIN_MS);\n\n\treturn 0;\n}\n\nstatic int adf_crypto_dev_config(struct adf_accel_dev *accel_dev)\n{\n\tchar key[ADF_CFG_MAX_KEY_LEN_IN_BYTES];\n\tint banks = GET_MAX_BANKS(accel_dev);\n\tint cpus = num_online_cpus();\n\tunsigned long bank, val;\n\tint instances;\n\tint ret;\n\tint i;\n\n\tif (adf_hw_dev_has_crypto(accel_dev))\n\t\tinstances = min(cpus, banks / 2);\n\telse\n\t\tinstances = 0;\n\n\tfor (i = 0; i < instances; i++) {\n\t\tval = i;\n\t\tbank = i * 2;\n\t\tsnprintf(key, sizeof(key), ADF_CY \"%d\" ADF_RING_ASYM_BANK_NUM, i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\t\t  key, &bank, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tbank += 1;\n\t\tsnprintf(key, sizeof(key), ADF_CY \"%d\" ADF_RING_SYM_BANK_NUM, i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\t\t  key, &bank, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tsnprintf(key, sizeof(key), ADF_CY \"%d\" ADF_ETRMGR_CORE_AFFINITY,\n\t\t\t i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\t\t  key, &val, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tsnprintf(key, sizeof(key), ADF_CY \"%d\" ADF_RING_ASYM_SIZE, i);\n\t\tval = 128;\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\t\t  key, &val, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tval = 512;\n\t\tsnprintf(key, sizeof(key), ADF_CY \"%d\" ADF_RING_SYM_SIZE, i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\t\t  key, &val, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tval = 0;\n\t\tsnprintf(key, sizeof(key), ADF_CY \"%d\" ADF_RING_ASYM_TX, i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\t\t  key, &val, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tval = 0;\n\t\tsnprintf(key, sizeof(key), ADF_CY \"%d\" ADF_RING_SYM_TX, i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\t\t  key, &val, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tval = 1;\n\t\tsnprintf(key, sizeof(key), ADF_CY \"%d\" ADF_RING_ASYM_RX, i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\t\t  key, &val, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tval = 1;\n\t\tsnprintf(key, sizeof(key), ADF_CY \"%d\" ADF_RING_SYM_RX, i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\t\t  key, &val, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tval = ADF_COALESCING_DEF_TIME;\n\t\tsnprintf(key, sizeof(key), ADF_ETRMGR_COALESCE_TIMER_FORMAT, i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, \"Accelerator0\",\n\t\t\t\t\t\t  key, &val, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tval = i;\n\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC, ADF_NUM_CY,\n\t\t\t\t\t  &val, ADF_DEC);\n\tif (ret)\n\t\tgoto err;\n\n\tval = 0;\n\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC, ADF_NUM_DC,\n\t\t\t\t\t  &val, ADF_DEC);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_err(&GET_DEV(accel_dev), \"Failed to add configuration for crypto\\n\");\n\treturn ret;\n}\n\nstatic int adf_comp_dev_config(struct adf_accel_dev *accel_dev)\n{\n\tchar key[ADF_CFG_MAX_KEY_LEN_IN_BYTES];\n\tint banks = GET_MAX_BANKS(accel_dev);\n\tint cpus = num_online_cpus();\n\tunsigned long val;\n\tint instances;\n\tint ret;\n\tint i;\n\n\tif (adf_hw_dev_has_compression(accel_dev))\n\t\tinstances = min(cpus, banks);\n\telse\n\t\tinstances = 0;\n\n\tfor (i = 0; i < instances; i++) {\n\t\tval = i;\n\t\tsnprintf(key, sizeof(key), ADF_DC \"%d\" ADF_RING_DC_BANK_NUM, i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\t\t  key, &val, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tval = 512;\n\t\tsnprintf(key, sizeof(key), ADF_DC \"%d\" ADF_RING_DC_SIZE, i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\t\t  key, &val, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tval = 0;\n\t\tsnprintf(key, sizeof(key), ADF_DC \"%d\" ADF_RING_DC_TX, i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\t\t  key, &val, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tval = 1;\n\t\tsnprintf(key, sizeof(key), ADF_DC \"%d\" ADF_RING_DC_RX, i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\t\t  key, &val, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tval = ADF_COALESCING_DEF_TIME;\n\t\tsnprintf(key, sizeof(key), ADF_ETRMGR_COALESCE_TIMER_FORMAT, i);\n\t\tret = adf_cfg_add_key_value_param(accel_dev, \"Accelerator0\",\n\t\t\t\t\t\t  key, &val, ADF_DEC);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tval = i;\n\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC, ADF_NUM_DC,\n\t\t\t\t\t  &val, ADF_DEC);\n\tif (ret)\n\t\tgoto err;\n\n\tval = 0;\n\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC, ADF_NUM_CY,\n\t\t\t\t\t  &val, ADF_DEC);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tdev_err(&GET_DEV(accel_dev), \"Failed to add configuration for compression\\n\");\n\treturn ret;\n}\n\nstatic int adf_no_dev_config(struct adf_accel_dev *accel_dev)\n{\n\tunsigned long val;\n\tint ret;\n\n\tval = 0;\n\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC, ADF_NUM_DC,\n\t\t\t\t\t  &val, ADF_DEC);\n\tif (ret)\n\t\treturn ret;\n\n\treturn adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC, ADF_NUM_CY,\n\t\t\t\t\t  &val, ADF_DEC);\n}\n\nint adf_gen4_dev_config(struct adf_accel_dev *accel_dev)\n{\n\tchar services[ADF_CFG_MAX_VAL_LEN_IN_BYTES] = {0};\n\tint ret;\n\n\tret = adf_cfg_section_add(accel_dev, ADF_KERNEL_SEC);\n\tif (ret)\n\t\tgoto err;\n\n\tret = adf_cfg_section_add(accel_dev, \"Accelerator0\");\n\tif (ret)\n\t\tgoto err;\n\n\tret = adf_cfg_get_param_value(accel_dev, ADF_GENERAL_SEC,\n\t\t\t\t      ADF_SERVICES_ENABLED, services);\n\tif (ret)\n\t\tgoto err;\n\n\tret = sysfs_match_string(adf_cfg_services, services);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tswitch (ret) {\n\tcase SVC_CY:\n\tcase SVC_CY2:\n\t\tret = adf_crypto_dev_config(accel_dev);\n\t\tbreak;\n\tcase SVC_DC:\n\tcase SVC_DCC:\n\t\tret = adf_comp_dev_config(accel_dev);\n\t\tbreak;\n\tdefault:\n\t\tret = adf_no_dev_config(accel_dev);\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tgoto err;\n\n\tset_bit(ADF_STATUS_CONFIGURED, &accel_dev->status);\n\n\treturn ret;\n\nerr:\n\tdev_err(&GET_DEV(accel_dev), \"Failed to configure QAT driver\\n\");\n\treturn ret;\n}\n\nstatic int adf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct adf_accel_dev *accel_dev;\n\tstruct adf_accel_pci *accel_pci_dev;\n\tstruct adf_hw_device_data *hw_data;\n\tunsigned int i, bar_nr;\n\tunsigned long bar_mask;\n\tstruct adf_bar *bar;\n\tint ret;\n\n\tif (num_possible_nodes() > 1 && dev_to_node(&pdev->dev) < 0) {\n\t\t \n\t\tdev_err(&pdev->dev, \"Invalid NUMA configuration.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taccel_dev = devm_kzalloc(&pdev->dev, sizeof(*accel_dev), GFP_KERNEL);\n\tif (!accel_dev)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&accel_dev->crypto_list);\n\taccel_pci_dev = &accel_dev->accel_pci_dev;\n\taccel_pci_dev->pci_dev = pdev;\n\n\t \n\tif (adf_devmgr_add_dev(accel_dev, NULL)) {\n\t\tdev_err(&pdev->dev, \"Failed to add new accelerator device.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\taccel_dev->owner = THIS_MODULE;\n\t \n\thw_data = devm_kzalloc(&pdev->dev, sizeof(*hw_data), GFP_KERNEL);\n\tif (!hw_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\taccel_dev->hw_device = hw_data;\n\tadf_init_hw_data_4xxx(accel_dev->hw_device, ent->device);\n\n\tpci_read_config_byte(pdev, PCI_REVISION_ID, &accel_pci_dev->revid);\n\tpci_read_config_dword(pdev, ADF_4XXX_FUSECTL4_OFFSET, &hw_data->fuses);\n\n\t \n\thw_data->accel_mask = hw_data->get_accel_mask(hw_data);\n\thw_data->ae_mask = hw_data->get_ae_mask(hw_data);\n\taccel_pci_dev->sku = hw_data->get_sku(hw_data);\n\t \n\tif (!hw_data->accel_mask || !hw_data->ae_mask ||\n\t    (~hw_data->ae_mask & 0x01)) {\n\t\tdev_err(&pdev->dev, \"No acceleration units found.\\n\");\n\t\tret = -EFAULT;\n\t\tgoto out_err;\n\t}\n\n\t \n\tret = adf_cfg_dev_add(accel_dev);\n\tif (ret)\n\t\tgoto out_err;\n\n\t \n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't enable PCI device.\\n\");\n\t\tgoto out_err;\n\t}\n\n\t \n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"No usable DMA configuration.\\n\");\n\t\tgoto out_err;\n\t}\n\n\tret = adf_cfg_dev_init(accel_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize configuration.\\n\");\n\t\tgoto out_err;\n\t}\n\n\t \n\thw_data->accel_capabilities_mask = hw_data->get_accel_cap(accel_dev);\n\tif (!hw_data->accel_capabilities_mask) {\n\t\tdev_err(&pdev->dev, \"Failed to get capabilities mask.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\t \n\tbar_mask = pci_select_bars(pdev, IORESOURCE_MEM) & ADF_4XXX_BAR_MASK;\n\n\tret = pcim_iomap_regions_request_all(pdev, bar_mask, pci_name(pdev));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to map pci regions.\\n\");\n\t\tgoto out_err;\n\t}\n\n\ti = 0;\n\tfor_each_set_bit(bar_nr, &bar_mask, PCI_STD_NUM_BARS) {\n\t\tbar = &accel_pci_dev->pci_bars[i++];\n\t\tbar->virt_addr = pcim_iomap_table(pdev)[bar_nr];\n\t}\n\n\tpci_set_master(pdev);\n\n\tif (pci_save_state(pdev)) {\n\t\tdev_err(&pdev->dev, \"Failed to save pci state.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tadf_dbgfs_init(accel_dev);\n\n\tret = adf_dev_up(accel_dev, true);\n\tif (ret)\n\t\tgoto out_err_dev_stop;\n\n\tret = adf_sysfs_init(accel_dev);\n\tif (ret)\n\t\tgoto out_err_dev_stop;\n\n\treturn ret;\n\nout_err_dev_stop:\n\tadf_dev_down(accel_dev, false);\nout_err:\n\tadf_cleanup_accel(accel_dev);\n\treturn ret;\n}\n\nstatic void adf_remove(struct pci_dev *pdev)\n{\n\tstruct adf_accel_dev *accel_dev = adf_devmgr_pci_to_accel_dev(pdev);\n\n\tif (!accel_dev) {\n\t\tpr_err(\"QAT: Driver removal failed\\n\");\n\t\treturn;\n\t}\n\tadf_dev_down(accel_dev, false);\n\tadf_cleanup_accel(accel_dev);\n}\n\nstatic struct pci_driver adf_driver = {\n\t.id_table = adf_pci_tbl,\n\t.name = ADF_4XXX_DEVICE_NAME,\n\t.probe = adf_probe,\n\t.remove = adf_remove,\n\t.sriov_configure = adf_sriov_configure,\n\t.err_handler = &adf_err_handler,\n};\n\nmodule_pci_driver(adf_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Intel\");\nMODULE_FIRMWARE(ADF_4XXX_FW);\nMODULE_FIRMWARE(ADF_4XXX_MMP);\nMODULE_DESCRIPTION(\"Intel(R) QuickAssist Technology\");\nMODULE_VERSION(ADF_DRV_VERSION);\nMODULE_SOFTDEP(\"pre: crypto-intel_qat\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}