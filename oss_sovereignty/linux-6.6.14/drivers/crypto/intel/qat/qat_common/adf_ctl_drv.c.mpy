{
  "module_name": "adf_ctl_drv.c",
  "hash_id": "610a1d54fbb14179d990539490e858dc57055e9c4cc81483d7a73fd1420fe268",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_ctl_drv.c",
  "human_readable_source": "\n \n\n#include <crypto/algapi.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/bitops.h>\n#include <linux/pci.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n\n#include \"adf_accel_devices.h\"\n#include \"adf_common_drv.h\"\n#include \"adf_cfg.h\"\n#include \"adf_cfg_common.h\"\n#include \"adf_cfg_user.h\"\n\n#define ADF_CFG_MAX_SECTION 512\n#define ADF_CFG_MAX_KEY_VAL 256\n\n#define DEVICE_NAME \"qat_adf_ctl\"\n\nstatic DEFINE_MUTEX(adf_ctl_lock);\nstatic long adf_ctl_ioctl(struct file *fp, unsigned int cmd, unsigned long arg);\n\nstatic const struct file_operations adf_ctl_ops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = adf_ctl_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n\nstruct adf_ctl_drv_info {\n\tunsigned int major;\n\tstruct cdev drv_cdev;\n\tstruct class *drv_class;\n};\n\nstatic struct adf_ctl_drv_info adf_ctl_drv;\n\nstatic void adf_chr_drv_destroy(void)\n{\n\tdevice_destroy(adf_ctl_drv.drv_class, MKDEV(adf_ctl_drv.major, 0));\n\tcdev_del(&adf_ctl_drv.drv_cdev);\n\tclass_destroy(adf_ctl_drv.drv_class);\n\tunregister_chrdev_region(MKDEV(adf_ctl_drv.major, 0), 1);\n}\n\nstatic int adf_chr_drv_create(void)\n{\n\tdev_t dev_id;\n\tstruct device *drv_device;\n\n\tif (alloc_chrdev_region(&dev_id, 0, 1, DEVICE_NAME)) {\n\t\tpr_err(\"QAT: unable to allocate chrdev region\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tadf_ctl_drv.drv_class = class_create(DEVICE_NAME);\n\tif (IS_ERR(adf_ctl_drv.drv_class)) {\n\t\tpr_err(\"QAT: class_create failed for adf_ctl\\n\");\n\t\tgoto err_chrdev_unreg;\n\t}\n\tadf_ctl_drv.major = MAJOR(dev_id);\n\tcdev_init(&adf_ctl_drv.drv_cdev, &adf_ctl_ops);\n\tif (cdev_add(&adf_ctl_drv.drv_cdev, dev_id, 1)) {\n\t\tpr_err(\"QAT: cdev add failed\\n\");\n\t\tgoto err_class_destr;\n\t}\n\n\tdrv_device = device_create(adf_ctl_drv.drv_class, NULL,\n\t\t\t\t   MKDEV(adf_ctl_drv.major, 0),\n\t\t\t\t   NULL, DEVICE_NAME);\n\tif (IS_ERR(drv_device)) {\n\t\tpr_err(\"QAT: failed to create device\\n\");\n\t\tgoto err_cdev_del;\n\t}\n\treturn 0;\nerr_cdev_del:\n\tcdev_del(&adf_ctl_drv.drv_cdev);\nerr_class_destr:\n\tclass_destroy(adf_ctl_drv.drv_class);\nerr_chrdev_unreg:\n\tunregister_chrdev_region(dev_id, 1);\n\treturn -EFAULT;\n}\n\nstatic int adf_ctl_alloc_resources(struct adf_user_cfg_ctl_data **ctl_data,\n\t\t\t\t   unsigned long arg)\n{\n\tstruct adf_user_cfg_ctl_data *cfg_data;\n\n\tcfg_data = kzalloc(sizeof(*cfg_data), GFP_KERNEL);\n\tif (!cfg_data)\n\t\treturn -ENOMEM;\n\n\t \n\tcfg_data->device_id = ADF_CFG_NO_DEVICE;\n\n\tif (copy_from_user(cfg_data, (void __user *)arg, sizeof(*cfg_data))) {\n\t\tpr_err(\"QAT: failed to copy from user cfg_data.\\n\");\n\t\tkfree(cfg_data);\n\t\treturn -EIO;\n\t}\n\n\t*ctl_data = cfg_data;\n\treturn 0;\n}\n\nstatic int adf_add_key_value_data(struct adf_accel_dev *accel_dev,\n\t\t\t\t  const char *section,\n\t\t\t\t  const struct adf_user_cfg_key_val *key_val)\n{\n\tif (key_val->type == ADF_HEX) {\n\t\tlong *ptr = (long *)key_val->val;\n\t\tlong val = *ptr;\n\n\t\tif (adf_cfg_add_key_value_param(accel_dev, section,\n\t\t\t\t\t\tkey_val->key, (void *)val,\n\t\t\t\t\t\tkey_val->type)) {\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"failed to add hex keyvalue.\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else {\n\t\tif (adf_cfg_add_key_value_param(accel_dev, section,\n\t\t\t\t\t\tkey_val->key, key_val->val,\n\t\t\t\t\t\tkey_val->type)) {\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"failed to add keyvalue.\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int adf_copy_key_value_data(struct adf_accel_dev *accel_dev,\n\t\t\t\t   struct adf_user_cfg_ctl_data *ctl_data)\n{\n\tstruct adf_user_cfg_key_val key_val;\n\tstruct adf_user_cfg_key_val *params_head;\n\tstruct adf_user_cfg_section section, *section_head;\n\tint i, j;\n\n\tsection_head = ctl_data->config_section;\n\n\tfor (i = 0; section_head && i < ADF_CFG_MAX_SECTION; i++) {\n\t\tif (copy_from_user(&section, (void __user *)section_head,\n\t\t\t\t   sizeof(*section_head))) {\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"failed to copy section info\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (adf_cfg_section_add(accel_dev, section.name)) {\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"failed to add section.\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tparams_head = section.params;\n\n\t\tfor (j = 0; params_head && j < ADF_CFG_MAX_KEY_VAL; j++) {\n\t\t\tif (copy_from_user(&key_val, (void __user *)params_head,\n\t\t\t\t\t   sizeof(key_val))) {\n\t\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\t\"Failed to copy keyvalue.\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tif (adf_add_key_value_data(accel_dev, section.name,\n\t\t\t\t\t\t   &key_val)) {\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tparams_head = key_val.next;\n\t\t}\n\t\tsection_head = section.next;\n\t}\n\treturn 0;\nout_err:\n\tadf_cfg_del_all(accel_dev);\n\treturn -EFAULT;\n}\n\nstatic int adf_ctl_ioctl_dev_config(struct file *fp, unsigned int cmd,\n\t\t\t\t    unsigned long arg)\n{\n\tint ret;\n\tstruct adf_user_cfg_ctl_data *ctl_data;\n\tstruct adf_accel_dev *accel_dev;\n\n\tret = adf_ctl_alloc_resources(&ctl_data, arg);\n\tif (ret)\n\t\treturn ret;\n\n\taccel_dev = adf_devmgr_get_dev_by_id(ctl_data->device_id);\n\tif (!accel_dev) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (adf_dev_started(accel_dev)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (adf_copy_key_value_data(accel_dev, ctl_data)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tset_bit(ADF_STATUS_CONFIGURED, &accel_dev->status);\nout:\n\tkfree(ctl_data);\n\treturn ret;\n}\n\nstatic int adf_ctl_is_device_in_use(int id)\n{\n\tstruct adf_accel_dev *dev;\n\n\tlist_for_each_entry(dev, adf_devmgr_get_head(), list) {\n\t\tif (id == dev->accel_id || id == ADF_CFG_ALL_DEVICES) {\n\t\t\tif (adf_devmgr_in_reset(dev) || adf_dev_in_use(dev)) {\n\t\t\t\tdev_info(&GET_DEV(dev),\n\t\t\t\t\t \"device qat_dev%d is busy\\n\",\n\t\t\t\t\t dev->accel_id);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void adf_ctl_stop_devices(u32 id)\n{\n\tstruct adf_accel_dev *accel_dev;\n\n\tlist_for_each_entry(accel_dev, adf_devmgr_get_head(), list) {\n\t\tif (id == accel_dev->accel_id || id == ADF_CFG_ALL_DEVICES) {\n\t\t\tif (!adf_dev_started(accel_dev))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!accel_dev->is_vf)\n\t\t\t\tcontinue;\n\n\t\t\tadf_dev_down(accel_dev, false);\n\t\t}\n\t}\n\n\tlist_for_each_entry(accel_dev, adf_devmgr_get_head(), list) {\n\t\tif (id == accel_dev->accel_id || id == ADF_CFG_ALL_DEVICES) {\n\t\t\tif (!adf_dev_started(accel_dev))\n\t\t\t\tcontinue;\n\n\t\t\tadf_dev_down(accel_dev, false);\n\t\t}\n\t}\n}\n\nstatic int adf_ctl_ioctl_dev_stop(struct file *fp, unsigned int cmd,\n\t\t\t\t  unsigned long arg)\n{\n\tint ret;\n\tstruct adf_user_cfg_ctl_data *ctl_data;\n\n\tret = adf_ctl_alloc_resources(&ctl_data, arg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adf_devmgr_verify_id(ctl_data->device_id)) {\n\t\tpr_err(\"QAT: Device %d not found\\n\", ctl_data->device_id);\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tret = adf_ctl_is_device_in_use(ctl_data->device_id);\n\tif (ret)\n\t\tgoto out;\n\n\tif (ctl_data->device_id == ADF_CFG_ALL_DEVICES)\n\t\tpr_info(\"QAT: Stopping all acceleration devices.\\n\");\n\telse\n\t\tpr_info(\"QAT: Stopping acceleration device qat_dev%d.\\n\",\n\t\t\tctl_data->device_id);\n\n\tadf_ctl_stop_devices(ctl_data->device_id);\n\nout:\n\tkfree(ctl_data);\n\treturn ret;\n}\n\nstatic int adf_ctl_ioctl_dev_start(struct file *fp, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\tint ret;\n\tstruct adf_user_cfg_ctl_data *ctl_data;\n\tstruct adf_accel_dev *accel_dev;\n\n\tret = adf_ctl_alloc_resources(&ctl_data, arg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -ENODEV;\n\taccel_dev = adf_devmgr_get_dev_by_id(ctl_data->device_id);\n\tif (!accel_dev)\n\t\tgoto out;\n\n\tdev_info(&GET_DEV(accel_dev),\n\t\t \"Starting acceleration device qat_dev%d.\\n\",\n\t\t ctl_data->device_id);\n\n\tret = adf_dev_up(accel_dev, false);\n\n\tif (ret) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Failed to start qat_dev%d\\n\",\n\t\t\tctl_data->device_id);\n\t\tadf_dev_down(accel_dev, false);\n\t}\nout:\n\tkfree(ctl_data);\n\treturn ret;\n}\n\nstatic int adf_ctl_ioctl_get_num_devices(struct file *fp, unsigned int cmd,\n\t\t\t\t\t unsigned long arg)\n{\n\tu32 num_devices = 0;\n\n\tadf_devmgr_get_num_dev(&num_devices);\n\tif (copy_to_user((void __user *)arg, &num_devices, sizeof(num_devices)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int adf_ctl_ioctl_get_status(struct file *fp, unsigned int cmd,\n\t\t\t\t    unsigned long arg)\n{\n\tstruct adf_hw_device_data *hw_data;\n\tstruct adf_dev_status_info dev_info;\n\tstruct adf_accel_dev *accel_dev;\n\n\tif (copy_from_user(&dev_info, (void __user *)arg,\n\t\t\t   sizeof(struct adf_dev_status_info))) {\n\t\tpr_err(\"QAT: failed to copy from user.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\taccel_dev = adf_devmgr_get_dev_by_id(dev_info.accel_id);\n\tif (!accel_dev)\n\t\treturn -ENODEV;\n\n\thw_data = accel_dev->hw_device;\n\tdev_info.state = adf_dev_started(accel_dev) ? DEV_UP : DEV_DOWN;\n\tdev_info.num_ae = hw_data->get_num_aes(hw_data);\n\tdev_info.num_accel = hw_data->get_num_accels(hw_data);\n\tdev_info.num_logical_accel = hw_data->num_logical_accel;\n\tdev_info.banks_per_accel = hw_data->num_banks\n\t\t\t\t\t/ hw_data->num_logical_accel;\n\tstrscpy(dev_info.name, hw_data->dev_class->name, sizeof(dev_info.name));\n\tdev_info.instance_id = hw_data->instance_id;\n\tdev_info.type = hw_data->dev_class->type;\n\tdev_info.bus = accel_to_pci_dev(accel_dev)->bus->number;\n\tdev_info.dev = PCI_SLOT(accel_to_pci_dev(accel_dev)->devfn);\n\tdev_info.fun = PCI_FUNC(accel_to_pci_dev(accel_dev)->devfn);\n\n\tif (copy_to_user((void __user *)arg, &dev_info,\n\t\t\t sizeof(struct adf_dev_status_info))) {\n\t\tdev_err(&GET_DEV(accel_dev), \"failed to copy status.\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic long adf_ctl_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)\n{\n\tint ret;\n\n\tif (mutex_lock_interruptible(&adf_ctl_lock))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase IOCTL_CONFIG_SYS_RESOURCE_PARAMETERS:\n\t\tret = adf_ctl_ioctl_dev_config(fp, cmd, arg);\n\t\tbreak;\n\n\tcase IOCTL_STOP_ACCEL_DEV:\n\t\tret = adf_ctl_ioctl_dev_stop(fp, cmd, arg);\n\t\tbreak;\n\n\tcase IOCTL_START_ACCEL_DEV:\n\t\tret = adf_ctl_ioctl_dev_start(fp, cmd, arg);\n\t\tbreak;\n\n\tcase IOCTL_GET_NUM_DEVICES:\n\t\tret = adf_ctl_ioctl_get_num_devices(fp, cmd, arg);\n\t\tbreak;\n\n\tcase IOCTL_STATUS_ACCEL_DEV:\n\t\tret = adf_ctl_ioctl_get_status(fp, cmd, arg);\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited(\"QAT: Invalid ioctl %d\\n\", cmd);\n\t\tret = -EFAULT;\n\t\tbreak;\n\t}\n\tmutex_unlock(&adf_ctl_lock);\n\treturn ret;\n}\n\nstatic int __init adf_register_ctl_device_driver(void)\n{\n\tif (adf_chr_drv_create())\n\t\tgoto err_chr_dev;\n\n\tif (adf_init_misc_wq())\n\t\tgoto err_misc_wq;\n\n\tif (adf_init_aer())\n\t\tgoto err_aer;\n\n\tif (adf_init_pf_wq())\n\t\tgoto err_pf_wq;\n\n\tif (adf_init_vf_wq())\n\t\tgoto err_vf_wq;\n\n\tif (qat_crypto_register())\n\t\tgoto err_crypto_register;\n\n\tif (qat_compression_register())\n\t\tgoto err_compression_register;\n\n\treturn 0;\n\nerr_compression_register:\n\tqat_crypto_unregister();\nerr_crypto_register:\n\tadf_exit_vf_wq();\nerr_vf_wq:\n\tadf_exit_pf_wq();\nerr_pf_wq:\n\tadf_exit_aer();\nerr_aer:\n\tadf_exit_misc_wq();\nerr_misc_wq:\n\tadf_chr_drv_destroy();\nerr_chr_dev:\n\tmutex_destroy(&adf_ctl_lock);\n\treturn -EFAULT;\n}\n\nstatic void __exit adf_unregister_ctl_device_driver(void)\n{\n\tadf_chr_drv_destroy();\n\tadf_exit_misc_wq();\n\tadf_exit_aer();\n\tadf_exit_vf_wq();\n\tadf_exit_pf_wq();\n\tqat_crypto_unregister();\n\tqat_compression_unregister();\n\tadf_clean_vf_map(false);\n\tmutex_destroy(&adf_ctl_lock);\n}\n\nmodule_init(adf_register_ctl_device_driver);\nmodule_exit(adf_unregister_ctl_device_driver);\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Intel\");\nMODULE_DESCRIPTION(\"Intel(R) QuickAssist Technology\");\nMODULE_ALIAS_CRYPTO(\"intel_qat\");\nMODULE_VERSION(ADF_DRV_VERSION);\nMODULE_IMPORT_NS(CRYPTO_INTERNAL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}