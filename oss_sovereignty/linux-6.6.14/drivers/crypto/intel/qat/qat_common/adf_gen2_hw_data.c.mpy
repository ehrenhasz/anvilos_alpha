{
  "module_name": "adf_gen2_hw_data.c",
  "hash_id": "c64412b4589d66f4924ab0ffaaade9750f0b339b047f32b9bbc8fc51dcc8da09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_gen2_hw_data.c",
  "human_readable_source": "\n \n#include \"adf_common_drv.h\"\n#include \"adf_gen2_hw_data.h\"\n#include \"icp_qat_hw.h\"\n#include <linux/pci.h>\n\nu32 adf_gen2_get_num_accels(struct adf_hw_device_data *self)\n{\n\tif (!self || !self->accel_mask)\n\t\treturn 0;\n\n\treturn hweight16(self->accel_mask);\n}\nEXPORT_SYMBOL_GPL(adf_gen2_get_num_accels);\n\nu32 adf_gen2_get_num_aes(struct adf_hw_device_data *self)\n{\n\tif (!self || !self->ae_mask)\n\t\treturn 0;\n\n\treturn hweight32(self->ae_mask);\n}\nEXPORT_SYMBOL_GPL(adf_gen2_get_num_aes);\n\nvoid adf_gen2_enable_error_correction(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tvoid __iomem *pmisc_addr = adf_get_pmisc_base(accel_dev);\n\tunsigned long accel_mask = hw_data->accel_mask;\n\tunsigned long ae_mask = hw_data->ae_mask;\n\tunsigned int val, i;\n\n\t \n\tfor_each_set_bit(i, &ae_mask, hw_data->num_engines) {\n\t\tval = ADF_CSR_RD(pmisc_addr, ADF_GEN2_AE_CTX_ENABLES(i));\n\t\tval |= ADF_GEN2_ENABLE_AE_ECC_ERR;\n\t\tADF_CSR_WR(pmisc_addr, ADF_GEN2_AE_CTX_ENABLES(i), val);\n\t\tval = ADF_CSR_RD(pmisc_addr, ADF_GEN2_AE_MISC_CONTROL(i));\n\t\tval |= ADF_GEN2_ENABLE_AE_ECC_PARITY_CORR;\n\t\tADF_CSR_WR(pmisc_addr, ADF_GEN2_AE_MISC_CONTROL(i), val);\n\t}\n\n\t \n\tfor_each_set_bit(i, &accel_mask, hw_data->num_accel) {\n\t\tval = ADF_CSR_RD(pmisc_addr, ADF_GEN2_UERRSSMSH(i));\n\t\tval |= ADF_GEN2_ERRSSMSH_EN;\n\t\tADF_CSR_WR(pmisc_addr, ADF_GEN2_UERRSSMSH(i), val);\n\t\tval = ADF_CSR_RD(pmisc_addr, ADF_GEN2_CERRSSMSH(i));\n\t\tval |= ADF_GEN2_ERRSSMSH_EN;\n\t\tADF_CSR_WR(pmisc_addr, ADF_GEN2_CERRSSMSH(i), val);\n\t}\n}\nEXPORT_SYMBOL_GPL(adf_gen2_enable_error_correction);\n\nvoid adf_gen2_cfg_iov_thds(struct adf_accel_dev *accel_dev, bool enable,\n\t\t\t   int num_a_regs, int num_b_regs)\n{\n\tvoid __iomem *pmisc_addr = adf_get_pmisc_base(accel_dev);\n\tu32 reg;\n\tint i;\n\n\t \n\tfor (i = 0; i < num_a_regs; i++) {\n\t\treg = READ_CSR_AE2FUNCTION_MAP_A(pmisc_addr, i);\n\t\tif (enable)\n\t\t\treg |= AE2FUNCTION_MAP_VALID;\n\t\telse\n\t\t\treg &= ~AE2FUNCTION_MAP_VALID;\n\t\tWRITE_CSR_AE2FUNCTION_MAP_A(pmisc_addr, i, reg);\n\t}\n\n\t \n\tfor (i = 0; i < num_b_regs; i++) {\n\t\treg = READ_CSR_AE2FUNCTION_MAP_B(pmisc_addr, i);\n\t\tif (enable)\n\t\t\treg |= AE2FUNCTION_MAP_VALID;\n\t\telse\n\t\t\treg &= ~AE2FUNCTION_MAP_VALID;\n\t\tWRITE_CSR_AE2FUNCTION_MAP_B(pmisc_addr, i, reg);\n\t}\n}\nEXPORT_SYMBOL_GPL(adf_gen2_cfg_iov_thds);\n\nvoid adf_gen2_get_admin_info(struct admin_info *admin_csrs_info)\n{\n\tadmin_csrs_info->mailbox_offset = ADF_MAILBOX_BASE_OFFSET;\n\tadmin_csrs_info->admin_msg_ur = ADF_ADMINMSGUR_OFFSET;\n\tadmin_csrs_info->admin_msg_lr = ADF_ADMINMSGLR_OFFSET;\n}\nEXPORT_SYMBOL_GPL(adf_gen2_get_admin_info);\n\nvoid adf_gen2_get_arb_info(struct arb_info *arb_info)\n{\n\tarb_info->arb_cfg = ADF_ARB_CONFIG;\n\tarb_info->arb_offset = ADF_ARB_OFFSET;\n\tarb_info->wt2sam_offset = ADF_ARB_WRK_2_SER_MAP_OFFSET;\n}\nEXPORT_SYMBOL_GPL(adf_gen2_get_arb_info);\n\nvoid adf_gen2_enable_ints(struct adf_accel_dev *accel_dev)\n{\n\tvoid __iomem *addr = adf_get_pmisc_base(accel_dev);\n\tu32 val;\n\n\tval = accel_dev->pf.vf_info ? 0 : BIT_ULL(GET_MAX_BANKS(accel_dev)) - 1;\n\n\t \n\tADF_CSR_WR(addr, ADF_GEN2_SMIAPF0_MASK_OFFSET, val);\n\tADF_CSR_WR(addr, ADF_GEN2_SMIAPF1_MASK_OFFSET, ADF_GEN2_SMIA1_MASK);\n}\nEXPORT_SYMBOL_GPL(adf_gen2_enable_ints);\n\nstatic u64 build_csr_ring_base_addr(dma_addr_t addr, u32 size)\n{\n\treturn BUILD_RING_BASE_ADDR(addr, size);\n}\n\nstatic u32 read_csr_ring_head(void __iomem *csr_base_addr, u32 bank, u32 ring)\n{\n\treturn READ_CSR_RING_HEAD(csr_base_addr, bank, ring);\n}\n\nstatic void write_csr_ring_head(void __iomem *csr_base_addr, u32 bank, u32 ring,\n\t\t\t\tu32 value)\n{\n\tWRITE_CSR_RING_HEAD(csr_base_addr, bank, ring, value);\n}\n\nstatic u32 read_csr_ring_tail(void __iomem *csr_base_addr, u32 bank, u32 ring)\n{\n\treturn READ_CSR_RING_TAIL(csr_base_addr, bank, ring);\n}\n\nstatic void write_csr_ring_tail(void __iomem *csr_base_addr, u32 bank, u32 ring,\n\t\t\t\tu32 value)\n{\n\tWRITE_CSR_RING_TAIL(csr_base_addr, bank, ring, value);\n}\n\nstatic u32 read_csr_e_stat(void __iomem *csr_base_addr, u32 bank)\n{\n\treturn READ_CSR_E_STAT(csr_base_addr, bank);\n}\n\nstatic void write_csr_ring_config(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t  u32 ring, u32 value)\n{\n\tWRITE_CSR_RING_CONFIG(csr_base_addr, bank, ring, value);\n}\n\nstatic void write_csr_ring_base(void __iomem *csr_base_addr, u32 bank, u32 ring,\n\t\t\t\tdma_addr_t addr)\n{\n\tWRITE_CSR_RING_BASE(csr_base_addr, bank, ring, addr);\n}\n\nstatic void write_csr_int_flag(void __iomem *csr_base_addr, u32 bank, u32 value)\n{\n\tWRITE_CSR_INT_FLAG(csr_base_addr, bank, value);\n}\n\nstatic void write_csr_int_srcsel(void __iomem *csr_base_addr, u32 bank)\n{\n\tWRITE_CSR_INT_SRCSEL(csr_base_addr, bank);\n}\n\nstatic void write_csr_int_col_en(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t u32 value)\n{\n\tWRITE_CSR_INT_COL_EN(csr_base_addr, bank, value);\n}\n\nstatic void write_csr_int_col_ctl(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t  u32 value)\n{\n\tWRITE_CSR_INT_COL_CTL(csr_base_addr, bank, value);\n}\n\nstatic void write_csr_int_flag_and_col(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t       u32 value)\n{\n\tWRITE_CSR_INT_FLAG_AND_COL(csr_base_addr, bank, value);\n}\n\nstatic void write_csr_ring_srv_arb_en(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t      u32 value)\n{\n\tWRITE_CSR_RING_SRV_ARB_EN(csr_base_addr, bank, value);\n}\n\nvoid adf_gen2_init_hw_csr_ops(struct adf_hw_csr_ops *csr_ops)\n{\n\tcsr_ops->build_csr_ring_base_addr = build_csr_ring_base_addr;\n\tcsr_ops->read_csr_ring_head = read_csr_ring_head;\n\tcsr_ops->write_csr_ring_head = write_csr_ring_head;\n\tcsr_ops->read_csr_ring_tail = read_csr_ring_tail;\n\tcsr_ops->write_csr_ring_tail = write_csr_ring_tail;\n\tcsr_ops->read_csr_e_stat = read_csr_e_stat;\n\tcsr_ops->write_csr_ring_config = write_csr_ring_config;\n\tcsr_ops->write_csr_ring_base = write_csr_ring_base;\n\tcsr_ops->write_csr_int_flag = write_csr_int_flag;\n\tcsr_ops->write_csr_int_srcsel = write_csr_int_srcsel;\n\tcsr_ops->write_csr_int_col_en = write_csr_int_col_en;\n\tcsr_ops->write_csr_int_col_ctl = write_csr_int_col_ctl;\n\tcsr_ops->write_csr_int_flag_and_col = write_csr_int_flag_and_col;\n\tcsr_ops->write_csr_ring_srv_arb_en = write_csr_ring_srv_arb_en;\n}\nEXPORT_SYMBOL_GPL(adf_gen2_init_hw_csr_ops);\n\nu32 adf_gen2_get_accel_cap(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tstruct pci_dev *pdev = accel_dev->accel_pci_dev.pci_dev;\n\tu32 straps = hw_data->straps;\n\tu32 fuses = hw_data->fuses;\n\tu32 legfuses;\n\tu32 capabilities = ICP_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC |\n\t\t\t   ICP_ACCEL_CAPABILITIES_CRYPTO_ASYMMETRIC |\n\t\t\t   ICP_ACCEL_CAPABILITIES_AUTHENTICATION |\n\t\t\t   ICP_ACCEL_CAPABILITIES_CIPHER |\n\t\t\t   ICP_ACCEL_CAPABILITIES_COMPRESSION;\n\n\t \n\tpci_read_config_dword(pdev, ADF_DEVICE_LEGFUSE_OFFSET, &legfuses);\n\n\t \n\tif (legfuses & ICP_ACCEL_MASK_CIPHER_SLICE) {\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC;\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_CIPHER;\n\t}\n\tif (legfuses & ICP_ACCEL_MASK_PKE_SLICE)\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_CRYPTO_ASYMMETRIC;\n\tif (legfuses & ICP_ACCEL_MASK_AUTH_SLICE) {\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_AUTHENTICATION;\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_CIPHER;\n\t}\n\tif (legfuses & ICP_ACCEL_MASK_COMPRESS_SLICE)\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_COMPRESSION;\n\n\tif ((straps | fuses) & ADF_POWERGATE_PKE)\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_CRYPTO_ASYMMETRIC;\n\n\tif ((straps | fuses) & ADF_POWERGATE_DC)\n\t\tcapabilities &= ~ICP_ACCEL_CAPABILITIES_COMPRESSION;\n\n\treturn capabilities;\n}\nEXPORT_SYMBOL_GPL(adf_gen2_get_accel_cap);\n\nvoid adf_gen2_set_ssm_wdtimer(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tvoid __iomem *pmisc_addr = adf_get_pmisc_base(accel_dev);\n\tu32 timer_val_pke = ADF_SSM_WDT_PKE_DEFAULT_VALUE;\n\tu32 timer_val = ADF_SSM_WDT_DEFAULT_VALUE;\n\tunsigned long accel_mask = hw_data->accel_mask;\n\tu32 i = 0;\n\n\t \n\tfor_each_set_bit(i, &accel_mask, hw_data->num_accel) {\n\t\t \n\t\tADF_CSR_WR(pmisc_addr, ADF_SSMWDT(i), timer_val);\n\t\t \n\t\tADF_CSR_WR(pmisc_addr, ADF_SSMWDTPKE(i), timer_val_pke);\n\t}\n}\nEXPORT_SYMBOL_GPL(adf_gen2_set_ssm_wdtimer);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}