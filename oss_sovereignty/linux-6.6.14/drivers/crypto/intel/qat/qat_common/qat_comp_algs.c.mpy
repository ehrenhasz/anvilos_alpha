{
  "module_name": "qat_comp_algs.c",
  "hash_id": "49e91055b7a9e1ff76546046fc23f7480e35902281c2a3b869106994d81f674e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/qat_comp_algs.c",
  "human_readable_source": "\n \n#include <linux/crypto.h>\n#include <crypto/acompress.h>\n#include <crypto/internal/acompress.h>\n#include <crypto/scatterwalk.h>\n#include <linux/dma-mapping.h>\n#include <linux/workqueue.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_common_drv.h\"\n#include \"qat_bl.h\"\n#include \"qat_comp_req.h\"\n#include \"qat_compression.h\"\n#include \"qat_algs_send.h\"\n\n#define QAT_RFC_1950_HDR_SIZE 2\n#define QAT_RFC_1950_FOOTER_SIZE 4\n#define QAT_RFC_1950_CM_DEFLATE 8\n#define QAT_RFC_1950_CM_DEFLATE_CINFO_32K 7\n#define QAT_RFC_1950_CM_MASK 0x0f\n#define QAT_RFC_1950_CM_OFFSET 4\n#define QAT_RFC_1950_DICT_MASK 0x20\n#define QAT_RFC_1950_COMP_HDR 0x785e\n\nstatic DEFINE_MUTEX(algs_lock);\nstatic unsigned int active_devs;\n\nenum direction {\n\tDECOMPRESSION = 0,\n\tCOMPRESSION = 1,\n};\n\nstruct qat_compression_req;\n\nstruct qat_compression_ctx {\n\tu8 comp_ctx[QAT_COMP_CTX_SIZE];\n\tstruct qat_compression_instance *inst;\n\tint (*qat_comp_callback)(struct qat_compression_req *qat_req, void *resp);\n};\n\nstruct qat_dst {\n\tbool is_null;\n\tint resubmitted;\n};\n\nstruct qat_compression_req {\n\tu8 req[QAT_COMP_REQ_SIZE];\n\tstruct qat_compression_ctx *qat_compression_ctx;\n\tstruct acomp_req *acompress_req;\n\tstruct qat_request_buffs buf;\n\tenum direction dir;\n\tint actual_dlen;\n\tstruct qat_alg_req alg_req;\n\tstruct work_struct resubmit;\n\tstruct qat_dst dst;\n};\n\nstatic int qat_alg_send_dc_message(struct qat_compression_req *qat_req,\n\t\t\t\t   struct qat_compression_instance *inst,\n\t\t\t\t   struct crypto_async_request *base)\n{\n\tstruct qat_alg_req *alg_req = &qat_req->alg_req;\n\n\talg_req->fw_req = (u32 *)&qat_req->req;\n\talg_req->tx_ring = inst->dc_tx;\n\talg_req->base = base;\n\talg_req->backlog = &inst->backlog;\n\n\treturn qat_alg_send_message(alg_req);\n}\n\nstatic void qat_comp_resubmit(struct work_struct *work)\n{\n\tstruct qat_compression_req *qat_req =\n\t\tcontainer_of(work, struct qat_compression_req, resubmit);\n\tstruct qat_compression_ctx *ctx = qat_req->qat_compression_ctx;\n\tstruct adf_accel_dev *accel_dev = ctx->inst->accel_dev;\n\tstruct qat_request_buffs *qat_bufs = &qat_req->buf;\n\tstruct qat_compression_instance *inst = ctx->inst;\n\tstruct acomp_req *areq = qat_req->acompress_req;\n\tstruct crypto_acomp *tfm = crypto_acomp_reqtfm(areq);\n\tunsigned int dlen = CRYPTO_ACOMP_DST_MAX;\n\tu8 *req = qat_req->req;\n\tdma_addr_t dfbuf;\n\tint ret;\n\n\tareq->dlen = dlen;\n\n\tdev_dbg(&GET_DEV(accel_dev), \"[%s][%s] retry NULL dst request - dlen = %d\\n\",\n\t\tcrypto_tfm_alg_driver_name(crypto_acomp_tfm(tfm)),\n\t\tqat_req->dir == COMPRESSION ? \"comp\" : \"decomp\", dlen);\n\n\tret = qat_bl_realloc_map_new_dst(accel_dev, &areq->dst, dlen, qat_bufs,\n\t\t\t\t\t qat_algs_alloc_flags(&areq->base));\n\tif (ret)\n\t\tgoto err;\n\n\tqat_req->dst.resubmitted = true;\n\n\tdfbuf = qat_req->buf.bloutp;\n\tqat_comp_override_dst(req, dfbuf, dlen);\n\n\tret = qat_alg_send_dc_message(qat_req, inst, &areq->base);\n\tif (ret != -ENOSPC)\n\t\treturn;\n\nerr:\n\tqat_bl_free_bufl(accel_dev, qat_bufs);\n\tacomp_request_complete(areq, ret);\n}\n\nstatic int parse_zlib_header(u16 zlib_h)\n{\n\tint ret = -EINVAL;\n\t__be16 header;\n\tu8 *header_p;\n\tu8 cmf, flg;\n\n\theader = cpu_to_be16(zlib_h);\n\theader_p = (u8 *)&header;\n\n\tflg = header_p[0];\n\tcmf = header_p[1];\n\n\tif (cmf >> QAT_RFC_1950_CM_OFFSET > QAT_RFC_1950_CM_DEFLATE_CINFO_32K)\n\t\treturn ret;\n\n\tif ((cmf & QAT_RFC_1950_CM_MASK) != QAT_RFC_1950_CM_DEFLATE)\n\t\treturn ret;\n\n\tif (flg & QAT_RFC_1950_DICT_MASK)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int qat_comp_rfc1950_callback(struct qat_compression_req *qat_req,\n\t\t\t\t     void *resp)\n{\n\tstruct acomp_req *areq = qat_req->acompress_req;\n\tenum direction dir = qat_req->dir;\n\t__be32 qat_produced_adler;\n\n\tqat_produced_adler = cpu_to_be32(qat_comp_get_produced_adler32(resp));\n\n\tif (dir == COMPRESSION) {\n\t\t__be16 zlib_header;\n\n\t\tzlib_header = cpu_to_be16(QAT_RFC_1950_COMP_HDR);\n\t\tscatterwalk_map_and_copy(&zlib_header, areq->dst, 0, QAT_RFC_1950_HDR_SIZE, 1);\n\t\tareq->dlen += QAT_RFC_1950_HDR_SIZE;\n\n\t\tscatterwalk_map_and_copy(&qat_produced_adler, areq->dst, areq->dlen,\n\t\t\t\t\t QAT_RFC_1950_FOOTER_SIZE, 1);\n\t\tareq->dlen += QAT_RFC_1950_FOOTER_SIZE;\n\t} else {\n\t\t__be32 decomp_adler;\n\t\tint footer_offset;\n\t\tint consumed;\n\n\t\tconsumed = qat_comp_get_consumed_ctr(resp);\n\t\tfooter_offset = consumed + QAT_RFC_1950_HDR_SIZE;\n\t\tif (footer_offset + QAT_RFC_1950_FOOTER_SIZE > areq->slen)\n\t\t\treturn -EBADMSG;\n\n\t\tscatterwalk_map_and_copy(&decomp_adler, areq->src, footer_offset,\n\t\t\t\t\t QAT_RFC_1950_FOOTER_SIZE, 0);\n\n\t\tif (qat_produced_adler != decomp_adler)\n\t\t\treturn -EBADMSG;\n\t}\n\treturn 0;\n}\n\nstatic void qat_comp_generic_callback(struct qat_compression_req *qat_req,\n\t\t\t\t      void *resp)\n{\n\tstruct acomp_req *areq = qat_req->acompress_req;\n\tstruct qat_compression_ctx *ctx = qat_req->qat_compression_ctx;\n\tstruct adf_accel_dev *accel_dev = ctx->inst->accel_dev;\n\tstruct crypto_acomp *tfm = crypto_acomp_reqtfm(areq);\n\tstruct qat_compression_instance *inst = ctx->inst;\n\tint consumed, produced;\n\ts8 cmp_err, xlt_err;\n\tint res = -EBADMSG;\n\tint status;\n\tu8 cnv;\n\n\tstatus = qat_comp_get_cmp_status(resp);\n\tstatus |= qat_comp_get_xlt_status(resp);\n\tcmp_err = qat_comp_get_cmp_err(resp);\n\txlt_err = qat_comp_get_xlt_err(resp);\n\n\tconsumed = qat_comp_get_consumed_ctr(resp);\n\tproduced = qat_comp_get_produced_ctr(resp);\n\n\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\"[%s][%s][%s] slen = %8d dlen = %8d consumed = %8d produced = %8d cmp_err = %3d xlt_err = %3d\",\n\t\tcrypto_tfm_alg_driver_name(crypto_acomp_tfm(tfm)),\n\t\tqat_req->dir == COMPRESSION ? \"comp  \" : \"decomp\",\n\t\tstatus ? \"ERR\" : \"OK \",\n\t\tareq->slen, areq->dlen, consumed, produced, cmp_err, xlt_err);\n\n\tareq->dlen = 0;\n\n\tif (qat_req->dir == DECOMPRESSION && qat_req->dst.is_null) {\n\t\tif (cmp_err == ERR_CODE_OVERFLOW_ERROR) {\n\t\t\tif (qat_req->dst.resubmitted) {\n\t\t\t\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\t\t\t\"Output does not fit destination buffer\\n\");\n\t\t\t\tres = -EOVERFLOW;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tINIT_WORK(&qat_req->resubmit, qat_comp_resubmit);\n\t\t\tadf_misc_wq_queue_work(&qat_req->resubmit);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (unlikely(status != ICP_QAT_FW_COMN_STATUS_FLAG_OK))\n\t\tgoto end;\n\n\tif (qat_req->dir == COMPRESSION) {\n\t\tcnv = qat_comp_get_cmp_cnv_flag(resp);\n\t\tif (unlikely(!cnv)) {\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"Verified compression not supported\\n\");\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (unlikely(produced > qat_req->actual_dlen)) {\n\t\t\tmemset(inst->dc_data->ovf_buff, 0,\n\t\t\t       inst->dc_data->ovf_buff_sz);\n\t\t\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\t\t\"Actual buffer overflow: produced=%d, dlen=%d\\n\",\n\t\t\t\tproduced, qat_req->actual_dlen);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tres = 0;\n\tareq->dlen = produced;\n\n\tif (ctx->qat_comp_callback)\n\t\tres = ctx->qat_comp_callback(qat_req, resp);\n\nend:\n\tqat_bl_free_bufl(accel_dev, &qat_req->buf);\n\tacomp_request_complete(areq, res);\n}\n\nvoid qat_comp_alg_callback(void *resp)\n{\n\tstruct qat_compression_req *qat_req =\n\t\t\t(void *)(__force long)qat_comp_get_opaque(resp);\n\tstruct qat_instance_backlog *backlog = qat_req->alg_req.backlog;\n\n\tqat_comp_generic_callback(qat_req, resp);\n\n\tqat_alg_send_backlog(backlog);\n}\n\nstatic int qat_comp_alg_init_tfm(struct crypto_acomp *acomp_tfm)\n{\n\tstruct crypto_tfm *tfm = crypto_acomp_tfm(acomp_tfm);\n\tstruct qat_compression_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct qat_compression_instance *inst;\n\tint node;\n\n\tif (tfm->node == NUMA_NO_NODE)\n\t\tnode = numa_node_id();\n\telse\n\t\tnode = tfm->node;\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\tinst = qat_compression_get_instance_node(node);\n\tif (!inst)\n\t\treturn -EINVAL;\n\tctx->inst = inst;\n\n\tctx->inst->build_deflate_ctx(ctx->comp_ctx);\n\n\treturn 0;\n}\n\nstatic void qat_comp_alg_exit_tfm(struct crypto_acomp *acomp_tfm)\n{\n\tstruct crypto_tfm *tfm = crypto_acomp_tfm(acomp_tfm);\n\tstruct qat_compression_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tqat_compression_put_instance(ctx->inst);\n\tmemset(ctx, 0, sizeof(*ctx));\n}\n\nstatic int qat_comp_alg_rfc1950_init_tfm(struct crypto_acomp *acomp_tfm)\n{\n\tstruct crypto_tfm *tfm = crypto_acomp_tfm(acomp_tfm);\n\tstruct qat_compression_ctx *ctx = crypto_tfm_ctx(tfm);\n\tint ret;\n\n\tret = qat_comp_alg_init_tfm(acomp_tfm);\n\tctx->qat_comp_callback = &qat_comp_rfc1950_callback;\n\n\treturn ret;\n}\n\nstatic int qat_comp_alg_compress_decompress(struct acomp_req *areq, enum direction dir,\n\t\t\t\t\t    unsigned int shdr, unsigned int sftr,\n\t\t\t\t\t    unsigned int dhdr, unsigned int dftr)\n{\n\tstruct qat_compression_req *qat_req = acomp_request_ctx(areq);\n\tstruct crypto_acomp *acomp_tfm = crypto_acomp_reqtfm(areq);\n\tstruct crypto_tfm *tfm = crypto_acomp_tfm(acomp_tfm);\n\tstruct qat_compression_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct qat_compression_instance *inst = ctx->inst;\n\tgfp_t f = qat_algs_alloc_flags(&areq->base);\n\tstruct qat_sgl_to_bufl_params params = {0};\n\tint slen = areq->slen - shdr - sftr;\n\tint dlen = areq->dlen - dhdr - dftr;\n\tdma_addr_t sfbuf, dfbuf;\n\tu8 *req = qat_req->req;\n\tsize_t ovf_buff_sz;\n\tint ret;\n\n\tparams.sskip = shdr;\n\tparams.dskip = dhdr;\n\n\tif (!areq->src || !slen)\n\t\treturn -EINVAL;\n\n\tif (areq->dst && !dlen)\n\t\treturn -EINVAL;\n\n\tqat_req->dst.is_null = false;\n\n\t \n\tif (!areq->dst) {\n\t\tqat_req->dst.is_null = true;\n\n\t\tdlen = round_up(2 * slen, PAGE_SIZE);\n\t\tareq->dst = sgl_alloc(dlen, f, NULL);\n\t\tif (!areq->dst)\n\t\t\treturn -ENOMEM;\n\n\t\tdlen -= dhdr + dftr;\n\t\tareq->dlen = dlen;\n\t\tqat_req->dst.resubmitted = false;\n\t}\n\n\tif (dir == COMPRESSION) {\n\t\tparams.extra_dst_buff = inst->dc_data->ovf_buff_p;\n\t\tovf_buff_sz = inst->dc_data->ovf_buff_sz;\n\t\tparams.sz_extra_dst_buff = ovf_buff_sz;\n\t}\n\n\tret = qat_bl_sgl_to_bufl(ctx->inst->accel_dev, areq->src, areq->dst,\n\t\t\t\t &qat_req->buf, &params, f);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tsfbuf = qat_req->buf.blp;\n\tdfbuf = qat_req->buf.bloutp;\n\tqat_req->qat_compression_ctx = ctx;\n\tqat_req->acompress_req = areq;\n\tqat_req->dir = dir;\n\n\tif (dir == COMPRESSION) {\n\t\tqat_req->actual_dlen = dlen;\n\t\tdlen += ovf_buff_sz;\n\t\tqat_comp_create_compression_req(ctx->comp_ctx, req,\n\t\t\t\t\t\t(u64)(__force long)sfbuf, slen,\n\t\t\t\t\t\t(u64)(__force long)dfbuf, dlen,\n\t\t\t\t\t\t(u64)(__force long)qat_req);\n\t} else {\n\t\tqat_comp_create_decompression_req(ctx->comp_ctx, req,\n\t\t\t\t\t\t  (u64)(__force long)sfbuf, slen,\n\t\t\t\t\t\t  (u64)(__force long)dfbuf, dlen,\n\t\t\t\t\t\t  (u64)(__force long)qat_req);\n\t}\n\n\tret = qat_alg_send_dc_message(qat_req, inst, &areq->base);\n\tif (ret == -ENOSPC)\n\t\tqat_bl_free_bufl(inst->accel_dev, &qat_req->buf);\n\n\treturn ret;\n}\n\nstatic int qat_comp_alg_compress(struct acomp_req *req)\n{\n\treturn qat_comp_alg_compress_decompress(req, COMPRESSION, 0, 0, 0, 0);\n}\n\nstatic int qat_comp_alg_decompress(struct acomp_req *req)\n{\n\treturn qat_comp_alg_compress_decompress(req, DECOMPRESSION, 0, 0, 0, 0);\n}\n\nstatic int qat_comp_alg_rfc1950_compress(struct acomp_req *req)\n{\n\tif (!req->dst && req->dlen != 0)\n\t\treturn -EINVAL;\n\n\tif (req->dst && req->dlen <= QAT_RFC_1950_HDR_SIZE + QAT_RFC_1950_FOOTER_SIZE)\n\t\treturn -EINVAL;\n\n\treturn qat_comp_alg_compress_decompress(req, COMPRESSION, 0, 0,\n\t\t\t\t\t\tQAT_RFC_1950_HDR_SIZE,\n\t\t\t\t\t\tQAT_RFC_1950_FOOTER_SIZE);\n}\n\nstatic int qat_comp_alg_rfc1950_decompress(struct acomp_req *req)\n{\n\tstruct crypto_acomp *acomp_tfm = crypto_acomp_reqtfm(req);\n\tstruct crypto_tfm *tfm = crypto_acomp_tfm(acomp_tfm);\n\tstruct qat_compression_ctx *ctx = crypto_tfm_ctx(tfm);\n\tstruct adf_accel_dev *accel_dev = ctx->inst->accel_dev;\n\tu16 zlib_header;\n\tint ret;\n\n\tif (req->slen <= QAT_RFC_1950_HDR_SIZE + QAT_RFC_1950_FOOTER_SIZE)\n\t\treturn -EBADMSG;\n\n\tscatterwalk_map_and_copy(&zlib_header, req->src, 0, QAT_RFC_1950_HDR_SIZE, 0);\n\n\tret = parse_zlib_header(zlib_header);\n\tif (ret) {\n\t\tdev_dbg(&GET_DEV(accel_dev), \"Error parsing zlib header\\n\");\n\t\treturn ret;\n\t}\n\n\treturn qat_comp_alg_compress_decompress(req, DECOMPRESSION, QAT_RFC_1950_HDR_SIZE,\n\t\t\t\t\t\tQAT_RFC_1950_FOOTER_SIZE, 0, 0);\n}\n\nstatic struct acomp_alg qat_acomp[] = { {\n\t.base = {\n\t\t.cra_name = \"deflate\",\n\t\t.cra_driver_name = \"qat_deflate\",\n\t\t.cra_priority = 4001,\n\t\t.cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_ALLOCATES_MEMORY,\n\t\t.cra_ctxsize = sizeof(struct qat_compression_ctx),\n\t\t.cra_module = THIS_MODULE,\n\t},\n\t.init = qat_comp_alg_init_tfm,\n\t.exit = qat_comp_alg_exit_tfm,\n\t.compress = qat_comp_alg_compress,\n\t.decompress = qat_comp_alg_decompress,\n\t.dst_free = sgl_free,\n\t.reqsize = sizeof(struct qat_compression_req),\n}, {\n\t.base = {\n\t\t.cra_name = \"zlib-deflate\",\n\t\t.cra_driver_name = \"qat_zlib_deflate\",\n\t\t.cra_priority = 4001,\n\t\t.cra_flags = CRYPTO_ALG_ASYNC,\n\t\t.cra_ctxsize = sizeof(struct qat_compression_ctx),\n\t\t.cra_module = THIS_MODULE,\n\t},\n\t.init = qat_comp_alg_rfc1950_init_tfm,\n\t.exit = qat_comp_alg_exit_tfm,\n\t.compress = qat_comp_alg_rfc1950_compress,\n\t.decompress = qat_comp_alg_rfc1950_decompress,\n\t.dst_free = sgl_free,\n\t.reqsize = sizeof(struct qat_compression_req),\n} };\n\nint qat_comp_algs_register(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&algs_lock);\n\tif (++active_devs == 1)\n\t\tret = crypto_register_acomps(qat_acomp, ARRAY_SIZE(qat_acomp));\n\tmutex_unlock(&algs_lock);\n\treturn ret;\n}\n\nvoid qat_comp_algs_unregister(void)\n{\n\tmutex_lock(&algs_lock);\n\tif (--active_devs == 0)\n\t\tcrypto_unregister_acomps(qat_acomp, ARRAY_SIZE(qat_acomp));\n\tmutex_unlock(&algs_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}