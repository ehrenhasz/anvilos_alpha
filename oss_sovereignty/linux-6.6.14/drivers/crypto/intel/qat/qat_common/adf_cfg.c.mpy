{
  "module_name": "adf_cfg.c",
  "hash_id": "047f5bba912df14ca9a17426aa59f94364830e5e4fd936b27ff69194c04ff814",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_cfg.c",
  "human_readable_source": "\n \n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/seq_file.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_cfg.h\"\n#include \"adf_common_drv.h\"\n\nstatic DEFINE_MUTEX(qat_cfg_read_lock);\n\nstatic void *qat_dev_cfg_start(struct seq_file *sfile, loff_t *pos)\n{\n\tstruct adf_cfg_device_data *dev_cfg = sfile->private;\n\n\tmutex_lock(&qat_cfg_read_lock);\n\treturn seq_list_start(&dev_cfg->sec_list, *pos);\n}\n\nstatic int qat_dev_cfg_show(struct seq_file *sfile, void *v)\n{\n\tstruct list_head *list;\n\tstruct adf_cfg_section *sec =\n\t\t\t\tlist_entry(v, struct adf_cfg_section, list);\n\n\tseq_printf(sfile, \"[%s]\\n\", sec->name);\n\tlist_for_each(list, &sec->param_head) {\n\t\tstruct adf_cfg_key_val *ptr =\n\t\t\tlist_entry(list, struct adf_cfg_key_val, list);\n\t\tseq_printf(sfile, \"%s = %s\\n\", ptr->key, ptr->val);\n\t}\n\treturn 0;\n}\n\nstatic void *qat_dev_cfg_next(struct seq_file *sfile, void *v, loff_t *pos)\n{\n\tstruct adf_cfg_device_data *dev_cfg = sfile->private;\n\n\treturn seq_list_next(v, &dev_cfg->sec_list, pos);\n}\n\nstatic void qat_dev_cfg_stop(struct seq_file *sfile, void *v)\n{\n\tmutex_unlock(&qat_cfg_read_lock);\n}\n\nstatic const struct seq_operations qat_dev_cfg_sops = {\n\t.start = qat_dev_cfg_start,\n\t.next = qat_dev_cfg_next,\n\t.stop = qat_dev_cfg_stop,\n\t.show = qat_dev_cfg_show\n};\n\nDEFINE_SEQ_ATTRIBUTE(qat_dev_cfg);\n\n \nint adf_cfg_dev_add(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_cfg_device_data *dev_cfg_data;\n\n\tdev_cfg_data = kzalloc(sizeof(*dev_cfg_data), GFP_KERNEL);\n\tif (!dev_cfg_data)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&dev_cfg_data->sec_list);\n\tinit_rwsem(&dev_cfg_data->lock);\n\taccel_dev->cfg = dev_cfg_data;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(adf_cfg_dev_add);\n\nvoid adf_cfg_dev_dbgfs_add(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_cfg_device_data *dev_cfg_data = accel_dev->cfg;\n\n\tdev_cfg_data->debug = debugfs_create_file(\"dev_cfg\", 0400,\n\t\t\t\t\t\t  accel_dev->debugfs_dir,\n\t\t\t\t\t\t  dev_cfg_data,\n\t\t\t\t\t\t  &qat_dev_cfg_fops);\n}\n\nvoid adf_cfg_dev_dbgfs_rm(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_cfg_device_data *dev_cfg_data = accel_dev->cfg;\n\n\tif (!dev_cfg_data)\n\t\treturn;\n\n\tdebugfs_remove(dev_cfg_data->debug);\n\tdev_cfg_data->debug = NULL;\n}\n\nstatic void adf_cfg_section_del_all(struct list_head *head);\n\nvoid adf_cfg_del_all(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_cfg_device_data *dev_cfg_data = accel_dev->cfg;\n\n\tdown_write(&dev_cfg_data->lock);\n\tadf_cfg_section_del_all(&dev_cfg_data->sec_list);\n\tup_write(&dev_cfg_data->lock);\n\tclear_bit(ADF_STATUS_CONFIGURED, &accel_dev->status);\n}\n\n \nvoid adf_cfg_dev_remove(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_cfg_device_data *dev_cfg_data = accel_dev->cfg;\n\n\tif (!dev_cfg_data)\n\t\treturn;\n\n\tdown_write(&dev_cfg_data->lock);\n\tadf_cfg_section_del_all(&dev_cfg_data->sec_list);\n\tup_write(&dev_cfg_data->lock);\n\tkfree(dev_cfg_data);\n\taccel_dev->cfg = NULL;\n}\nEXPORT_SYMBOL_GPL(adf_cfg_dev_remove);\n\nstatic void adf_cfg_keyval_add(struct adf_cfg_key_val *new,\n\t\t\t       struct adf_cfg_section *sec)\n{\n\tlist_add_tail(&new->list, &sec->param_head);\n}\n\nstatic void adf_cfg_keyval_remove(const char *key, struct adf_cfg_section *sec)\n{\n\tstruct list_head *head = &sec->param_head;\n\tstruct list_head *list_ptr, *tmp;\n\n\tlist_for_each_prev_safe(list_ptr, tmp, head) {\n\t\tstruct adf_cfg_key_val *ptr =\n\t\t\tlist_entry(list_ptr, struct adf_cfg_key_val, list);\n\n\t\tif (strncmp(ptr->key, key, sizeof(ptr->key)))\n\t\t\tcontinue;\n\n\t\tlist_del(list_ptr);\n\t\tkfree(ptr);\n\t\tbreak;\n\t}\n}\n\nstatic void adf_cfg_keyval_del_all(struct list_head *head)\n{\n\tstruct list_head *list_ptr, *tmp;\n\n\tlist_for_each_prev_safe(list_ptr, tmp, head) {\n\t\tstruct adf_cfg_key_val *ptr =\n\t\t\tlist_entry(list_ptr, struct adf_cfg_key_val, list);\n\t\tlist_del(list_ptr);\n\t\tkfree(ptr);\n\t}\n}\n\nstatic void adf_cfg_section_del_all(struct list_head *head)\n{\n\tstruct adf_cfg_section *ptr;\n\tstruct list_head *list, *tmp;\n\n\tlist_for_each_prev_safe(list, tmp, head) {\n\t\tptr = list_entry(list, struct adf_cfg_section, list);\n\t\tadf_cfg_keyval_del_all(&ptr->param_head);\n\t\tlist_del(list);\n\t\tkfree(ptr);\n\t}\n}\n\nstatic struct adf_cfg_key_val *adf_cfg_key_value_find(struct adf_cfg_section *s,\n\t\t\t\t\t\t      const char *key)\n{\n\tstruct list_head *list;\n\n\tlist_for_each(list, &s->param_head) {\n\t\tstruct adf_cfg_key_val *ptr =\n\t\t\tlist_entry(list, struct adf_cfg_key_val, list);\n\t\tif (!strcmp(ptr->key, key))\n\t\t\treturn ptr;\n\t}\n\treturn NULL;\n}\n\nstatic struct adf_cfg_section *adf_cfg_sec_find(struct adf_accel_dev *accel_dev,\n\t\t\t\t\t\tconst char *sec_name)\n{\n\tstruct adf_cfg_device_data *cfg = accel_dev->cfg;\n\tstruct list_head *list;\n\n\tlist_for_each(list, &cfg->sec_list) {\n\t\tstruct adf_cfg_section *ptr =\n\t\t\tlist_entry(list, struct adf_cfg_section, list);\n\t\tif (!strcmp(ptr->name, sec_name))\n\t\t\treturn ptr;\n\t}\n\treturn NULL;\n}\n\nstatic int adf_cfg_key_val_get(struct adf_accel_dev *accel_dev,\n\t\t\t       const char *sec_name,\n\t\t\t       const char *key_name,\n\t\t\t       char *val)\n{\n\tstruct adf_cfg_section *sec = adf_cfg_sec_find(accel_dev, sec_name);\n\tstruct adf_cfg_key_val *keyval = NULL;\n\n\tif (sec)\n\t\tkeyval = adf_cfg_key_value_find(sec, key_name);\n\tif (keyval) {\n\t\tmemcpy(val, keyval->val, ADF_CFG_MAX_VAL_LEN_IN_BYTES);\n\t\treturn 0;\n\t}\n\treturn -ENODATA;\n}\n\n \nint adf_cfg_add_key_value_param(struct adf_accel_dev *accel_dev,\n\t\t\t\tconst char *section_name,\n\t\t\t\tconst char *key, const void *val,\n\t\t\t\tenum adf_cfg_val_type type)\n{\n\tstruct adf_cfg_device_data *cfg = accel_dev->cfg;\n\tstruct adf_cfg_key_val *key_val;\n\tstruct adf_cfg_section *section = adf_cfg_sec_find(accel_dev,\n\t\t\t\t\t\t\t   section_name);\n\tchar temp_val[ADF_CFG_MAX_VAL_LEN_IN_BYTES];\n\n\tif (!section)\n\t\treturn -EFAULT;\n\n\tkey_val = kzalloc(sizeof(*key_val), GFP_KERNEL);\n\tif (!key_val)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&key_val->list);\n\tstrscpy(key_val->key, key, sizeof(key_val->key));\n\n\tif (type == ADF_DEC) {\n\t\tsnprintf(key_val->val, ADF_CFG_MAX_VAL_LEN_IN_BYTES,\n\t\t\t \"%ld\", (*((long *)val)));\n\t} else if (type == ADF_STR) {\n\t\tstrscpy(key_val->val, (char *)val, sizeof(key_val->val));\n\t} else if (type == ADF_HEX) {\n\t\tsnprintf(key_val->val, ADF_CFG_MAX_VAL_LEN_IN_BYTES,\n\t\t\t \"0x%lx\", (unsigned long)val);\n\t} else {\n\t\tdev_err(&GET_DEV(accel_dev), \"Unknown type given.\\n\");\n\t\tkfree(key_val);\n\t\treturn -EINVAL;\n\t}\n\tkey_val->type = type;\n\n\t \n\tif (!adf_cfg_key_val_get(accel_dev, section_name, key, temp_val)) {\n\t\tif (strncmp(temp_val, key_val->val, sizeof(temp_val))) {\n\t\t\tadf_cfg_keyval_remove(key, section);\n\t\t} else {\n\t\t\tkfree(key_val);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdown_write(&cfg->lock);\n\tadf_cfg_keyval_add(key_val, section);\n\tup_write(&cfg->lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(adf_cfg_add_key_value_param);\n\n \nint adf_cfg_section_add(struct adf_accel_dev *accel_dev, const char *name)\n{\n\tstruct adf_cfg_device_data *cfg = accel_dev->cfg;\n\tstruct adf_cfg_section *sec = adf_cfg_sec_find(accel_dev, name);\n\n\tif (sec)\n\t\treturn 0;\n\n\tsec = kzalloc(sizeof(*sec), GFP_KERNEL);\n\tif (!sec)\n\t\treturn -ENOMEM;\n\n\tstrscpy(sec->name, name, sizeof(sec->name));\n\tINIT_LIST_HEAD(&sec->param_head);\n\tdown_write(&cfg->lock);\n\tlist_add_tail(&sec->list, &cfg->sec_list);\n\tup_write(&cfg->lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(adf_cfg_section_add);\n\nint adf_cfg_get_param_value(struct adf_accel_dev *accel_dev,\n\t\t\t    const char *section, const char *name,\n\t\t\t    char *value)\n{\n\tstruct adf_cfg_device_data *cfg = accel_dev->cfg;\n\tint ret;\n\n\tdown_read(&cfg->lock);\n\tret = adf_cfg_key_val_get(accel_dev, section, name, value);\n\tup_read(&cfg->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(adf_cfg_get_param_value);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}