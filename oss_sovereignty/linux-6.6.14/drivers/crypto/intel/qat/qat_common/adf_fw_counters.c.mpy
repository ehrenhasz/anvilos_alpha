{
  "module_name": "adf_fw_counters.c",
  "hash_id": "f6e0527344ce7b1e4ca00b630a30a26fbc5e3e930b9a729af7db1175a4e015dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_fw_counters.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n\n#include \"adf_accel_devices.h\"\n#include \"adf_common_drv.h\"\n#include \"adf_fw_counters.h\"\n\n#define ADF_FW_COUNTERS_MAX_PADDING 16\n\nenum adf_fw_counters_types {\n\tADF_FW_REQUESTS,\n\tADF_FW_RESPONSES,\n\tADF_FW_COUNTERS_COUNT\n};\n\nstatic const char * const adf_fw_counter_names[] = {\n\t[ADF_FW_REQUESTS] = \"Requests\",\n\t[ADF_FW_RESPONSES] = \"Responses\",\n};\n\nstatic_assert(ARRAY_SIZE(adf_fw_counter_names) == ADF_FW_COUNTERS_COUNT);\n\nstruct adf_ae_counters {\n\tu16 ae;\n\tu64 values[ADF_FW_COUNTERS_COUNT];\n};\n\nstruct adf_fw_counters {\n\tu16 ae_count;\n\tstruct adf_ae_counters ae_counters[];\n};\n\nstatic void adf_fw_counters_parse_ae_values(struct adf_ae_counters *ae_counters, u32 ae,\n\t\t\t\t\t    u64 req_count, u64 resp_count)\n{\n\tae_counters->ae = ae;\n\tae_counters->values[ADF_FW_REQUESTS] = req_count;\n\tae_counters->values[ADF_FW_RESPONSES] = resp_count;\n}\n\nstatic int adf_fw_counters_load_from_device(struct adf_accel_dev *accel_dev,\n\t\t\t\t\t    struct adf_fw_counters *fw_counters)\n{\n\tstruct adf_hw_device_data *hw_data = GET_HW_DATA(accel_dev);\n\tunsigned long ae_mask;\n\tunsigned int i;\n\tunsigned long ae;\n\n\t \n\tae_mask = hw_data->ae_mask & ~hw_data->admin_ae_mask;\n\n\tif (hweight_long(ae_mask) > fw_counters->ae_count)\n\t\treturn -EINVAL;\n\n\ti = 0;\n\tfor_each_set_bit(ae, &ae_mask, GET_MAX_ACCELENGINES(accel_dev)) {\n\t\tu64 req_count, resp_count;\n\t\tint ret;\n\n\t\tret = adf_get_ae_fw_counters(accel_dev, ae, &req_count, &resp_count);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tadf_fw_counters_parse_ae_values(&fw_counters->ae_counters[i++], ae,\n\t\t\t\t\t\treq_count, resp_count);\n\t}\n\n\treturn 0;\n}\n\nstatic struct adf_fw_counters *adf_fw_counters_allocate(unsigned long ae_count)\n{\n\tstruct adf_fw_counters *fw_counters;\n\n\tif (unlikely(!ae_count))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfw_counters = kmalloc(struct_size(fw_counters, ae_counters, ae_count), GFP_KERNEL);\n\tif (!fw_counters)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfw_counters->ae_count = ae_count;\n\n\treturn fw_counters;\n}\n\n \nstatic struct adf_fw_counters *adf_fw_counters_get(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_data = GET_HW_DATA(accel_dev);\n\tstruct adf_fw_counters *fw_counters;\n\tunsigned long ae_count;\n\tint ret;\n\n\tif (!adf_dev_started(accel_dev)) {\n\t\tdev_err(&GET_DEV(accel_dev), \"QAT Device not started\\n\");\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\t \n\tae_count = hweight_long(hw_data->ae_mask & ~hw_data->admin_ae_mask);\n\n\tfw_counters = adf_fw_counters_allocate(ae_count);\n\tif (IS_ERR(fw_counters))\n\t\treturn fw_counters;\n\n\tret = adf_fw_counters_load_from_device(accel_dev, fw_counters);\n\tif (ret) {\n\t\tkfree(fw_counters);\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Failed to create QAT fw_counters file table [%d].\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn fw_counters;\n}\n\nstatic void *qat_fw_counters_seq_start(struct seq_file *sfile, loff_t *pos)\n{\n\tstruct adf_fw_counters *fw_counters = sfile->private;\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tif (*pos > fw_counters->ae_count)\n\t\treturn NULL;\n\n\treturn &fw_counters->ae_counters[*pos - 1];\n}\n\nstatic void *qat_fw_counters_seq_next(struct seq_file *sfile, void *v, loff_t *pos)\n{\n\tstruct adf_fw_counters *fw_counters = sfile->private;\n\n\t(*pos)++;\n\n\tif (*pos > fw_counters->ae_count)\n\t\treturn NULL;\n\n\treturn &fw_counters->ae_counters[*pos - 1];\n}\n\nstatic void qat_fw_counters_seq_stop(struct seq_file *sfile, void *v) {}\n\nstatic int qat_fw_counters_seq_show(struct seq_file *sfile, void *v)\n{\n\tint i;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(sfile, \"AE \");\n\t\tfor (i = 0; i < ADF_FW_COUNTERS_COUNT; ++i)\n\t\t\tseq_printf(sfile, \" %*s\", ADF_FW_COUNTERS_MAX_PADDING,\n\t\t\t\t   adf_fw_counter_names[i]);\n\t} else {\n\t\tstruct adf_ae_counters *ae_counters = (struct adf_ae_counters *)v;\n\n\t\tseq_printf(sfile, \"%2d:\", ae_counters->ae);\n\t\tfor (i = 0; i < ADF_FW_COUNTERS_COUNT; ++i)\n\t\t\tseq_printf(sfile, \" %*llu\", ADF_FW_COUNTERS_MAX_PADDING,\n\t\t\t\t   ae_counters->values[i]);\n\t}\n\tseq_putc(sfile, '\\n');\n\n\treturn 0;\n}\n\nstatic const struct seq_operations qat_fw_counters_sops = {\n\t.start = qat_fw_counters_seq_start,\n\t.next = qat_fw_counters_seq_next,\n\t.stop = qat_fw_counters_seq_stop,\n\t.show = qat_fw_counters_seq_show,\n};\n\nstatic int qat_fw_counters_file_open(struct inode *inode, struct file *file)\n{\n\tstruct adf_accel_dev *accel_dev = inode->i_private;\n\tstruct seq_file *fw_counters_seq_file;\n\tstruct adf_fw_counters *fw_counters;\n\tint ret;\n\n\tfw_counters = adf_fw_counters_get(accel_dev);\n\tif (IS_ERR(fw_counters))\n\t\treturn PTR_ERR(fw_counters);\n\n\tret = seq_open(file, &qat_fw_counters_sops);\n\tif (unlikely(ret)) {\n\t\tkfree(fw_counters);\n\t\treturn ret;\n\t}\n\n\tfw_counters_seq_file = file->private_data;\n\tfw_counters_seq_file->private = fw_counters;\n\treturn ret;\n}\n\nstatic int qat_fw_counters_file_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\n\treturn seq_release(inode, file); }\n\nstatic const struct file_operations qat_fw_counters_fops = {\n\t.owner = THIS_MODULE,\n\t.open = qat_fw_counters_file_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = qat_fw_counters_file_release,\n};\n\n \nvoid adf_fw_counters_dbgfs_add(struct adf_accel_dev *accel_dev)\n{\n\taccel_dev->fw_cntr_dbgfile = debugfs_create_file(\"fw_counters\", 0400,\n\t\t\t\t\t\t\t accel_dev->debugfs_dir,\n\t\t\t\t\t\t\t accel_dev,\n\t\t\t\t\t\t\t &qat_fw_counters_fops);\n}\n\n \nvoid adf_fw_counters_dbgfs_rm(struct adf_accel_dev *accel_dev)\n{\n\tdebugfs_remove(accel_dev->fw_cntr_dbgfile);\n\taccel_dev->fw_cntr_dbgfile = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}