{
  "module_name": "adf_init.c",
  "hash_id": "6bc03eb7984718abe99cdb38039d56829375363b1eb819bceaef4fd12a9df8b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_init.c",
  "human_readable_source": "\n \n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_cfg.h\"\n#include \"adf_common_drv.h\"\n#include \"adf_dbgfs.h\"\n#include \"adf_heartbeat.h\"\n\nstatic LIST_HEAD(service_table);\nstatic DEFINE_MUTEX(service_lock);\n\nstatic void adf_service_add(struct service_hndl *service)\n{\n\tmutex_lock(&service_lock);\n\tlist_add(&service->list, &service_table);\n\tmutex_unlock(&service_lock);\n}\n\nint adf_service_register(struct service_hndl *service)\n{\n\tmemset(service->init_status, 0, sizeof(service->init_status));\n\tmemset(service->start_status, 0, sizeof(service->start_status));\n\tadf_service_add(service);\n\treturn 0;\n}\n\nstatic void adf_service_remove(struct service_hndl *service)\n{\n\tmutex_lock(&service_lock);\n\tlist_del(&service->list);\n\tmutex_unlock(&service_lock);\n}\n\nint adf_service_unregister(struct service_hndl *service)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(service->init_status); i++) {\n\t\tif (service->init_status[i] || service->start_status[i]) {\n\t\t\tpr_err(\"QAT: Could not remove active service\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tadf_service_remove(service);\n\treturn 0;\n}\n\n \nstatic int adf_dev_init(struct adf_accel_dev *accel_dev)\n{\n\tstruct service_hndl *service;\n\tstruct list_head *list_itr;\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tint ret;\n\n\tif (!hw_data) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Failed to init device - hw_data not set\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (!test_bit(ADF_STATUS_CONFIGURED, &accel_dev->status) &&\n\t    !accel_dev->is_vf) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Device not configured\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (adf_init_etr_data(accel_dev)) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Failed initialize etr\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (hw_data->init_device && hw_data->init_device(accel_dev)) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Failed to initialize device\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (hw_data->init_admin_comms && hw_data->init_admin_comms(accel_dev)) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Failed initialize admin comms\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (hw_data->init_arb && hw_data->init_arb(accel_dev)) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Failed initialize hw arbiter\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (hw_data->get_ring_to_svc_map)\n\t\thw_data->ring_to_svc_map = hw_data->get_ring_to_svc_map(accel_dev);\n\n\tif (adf_ae_init(accel_dev)) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Failed to initialise Acceleration Engine\\n\");\n\t\treturn -EFAULT;\n\t}\n\tset_bit(ADF_STATUS_AE_INITIALISED, &accel_dev->status);\n\n\tif (adf_ae_fw_load(accel_dev)) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Failed to load acceleration FW\\n\");\n\t\treturn -EFAULT;\n\t}\n\tset_bit(ADF_STATUS_AE_UCODE_LOADED, &accel_dev->status);\n\n\tif (hw_data->alloc_irq(accel_dev)) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Failed to allocate interrupts\\n\");\n\t\treturn -EFAULT;\n\t}\n\tset_bit(ADF_STATUS_IRQ_ALLOCATED, &accel_dev->status);\n\n\thw_data->enable_ints(accel_dev);\n\thw_data->enable_error_correction(accel_dev);\n\n\tret = hw_data->pfvf_ops.enable_comms(accel_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!test_bit(ADF_STATUS_CONFIGURED, &accel_dev->status) &&\n\t    accel_dev->is_vf) {\n\t\tif (qat_crypto_vf_dev_config(accel_dev))\n\t\t\treturn -EFAULT;\n\t}\n\n\tadf_heartbeat_init(accel_dev);\n\n\t \n\tlist_for_each(list_itr, &service_table) {\n\t\tservice = list_entry(list_itr, struct service_hndl, list);\n\t\tif (service->event_hld(accel_dev, ADF_EVENT_INIT)) {\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"Failed to initialise service %s\\n\",\n\t\t\t\tservice->name);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tset_bit(accel_dev->accel_id, service->init_status);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int adf_dev_start(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tstruct service_hndl *service;\n\tstruct list_head *list_itr;\n\tint ret;\n\n\tset_bit(ADF_STATUS_STARTING, &accel_dev->status);\n\n\tif (adf_ae_start(accel_dev)) {\n\t\tdev_err(&GET_DEV(accel_dev), \"AE Start Failed\\n\");\n\t\treturn -EFAULT;\n\t}\n\tset_bit(ADF_STATUS_AE_STARTED, &accel_dev->status);\n\n\tif (hw_data->send_admin_init(accel_dev)) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Failed to send init message\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (hw_data->measure_clock) {\n\t\tret = hw_data->measure_clock(accel_dev);\n\t\tif (ret) {\n\t\t\tdev_err(&GET_DEV(accel_dev), \"Failed measure device clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (hw_data->set_ssm_wdtimer)\n\t\thw_data->set_ssm_wdtimer(accel_dev);\n\n\t \n\tif (hw_data->enable_pm && hw_data->enable_pm(accel_dev)) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Failed to configure Power Management\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (hw_data->start_timer) {\n\t\tret = hw_data->start_timer(accel_dev);\n\t\tif (ret) {\n\t\t\tdev_err(&GET_DEV(accel_dev), \"Failed to start internal sync timer\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tadf_heartbeat_start(accel_dev);\n\n\tlist_for_each(list_itr, &service_table) {\n\t\tservice = list_entry(list_itr, struct service_hndl, list);\n\t\tif (service->event_hld(accel_dev, ADF_EVENT_START)) {\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"Failed to start service %s\\n\",\n\t\t\t\tservice->name);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tset_bit(accel_dev->accel_id, service->start_status);\n\t}\n\n\tclear_bit(ADF_STATUS_STARTING, &accel_dev->status);\n\tset_bit(ADF_STATUS_STARTED, &accel_dev->status);\n\n\tif (!list_empty(&accel_dev->crypto_list) &&\n\t    (qat_algs_register() || qat_asym_algs_register())) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Failed to register crypto algs\\n\");\n\t\tset_bit(ADF_STATUS_STARTING, &accel_dev->status);\n\t\tclear_bit(ADF_STATUS_STARTED, &accel_dev->status);\n\t\treturn -EFAULT;\n\t}\n\tset_bit(ADF_STATUS_CRYPTO_ALGS_REGISTERED, &accel_dev->status);\n\n\tif (!list_empty(&accel_dev->compression_list) && qat_comp_algs_register()) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Failed to register compression algs\\n\");\n\t\tset_bit(ADF_STATUS_STARTING, &accel_dev->status);\n\t\tclear_bit(ADF_STATUS_STARTED, &accel_dev->status);\n\t\treturn -EFAULT;\n\t}\n\tset_bit(ADF_STATUS_COMP_ALGS_REGISTERED, &accel_dev->status);\n\n\tadf_dbgfs_add(accel_dev);\n\n\treturn 0;\n}\n\n \nstatic void adf_dev_stop(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tstruct service_hndl *service;\n\tstruct list_head *list_itr;\n\tbool wait = false;\n\tint ret;\n\n\tif (!adf_dev_started(accel_dev) &&\n\t    !test_bit(ADF_STATUS_STARTING, &accel_dev->status))\n\t\treturn;\n\n\tadf_dbgfs_rm(accel_dev);\n\n\tclear_bit(ADF_STATUS_STARTING, &accel_dev->status);\n\tclear_bit(ADF_STATUS_STARTED, &accel_dev->status);\n\n\tif (!list_empty(&accel_dev->crypto_list) &&\n\t    test_bit(ADF_STATUS_CRYPTO_ALGS_REGISTERED, &accel_dev->status)) {\n\t\tqat_algs_unregister();\n\t\tqat_asym_algs_unregister();\n\t}\n\tclear_bit(ADF_STATUS_CRYPTO_ALGS_REGISTERED, &accel_dev->status);\n\n\tif (!list_empty(&accel_dev->compression_list) &&\n\t    test_bit(ADF_STATUS_COMP_ALGS_REGISTERED, &accel_dev->status))\n\t\tqat_comp_algs_unregister();\n\tclear_bit(ADF_STATUS_COMP_ALGS_REGISTERED, &accel_dev->status);\n\n\tlist_for_each(list_itr, &service_table) {\n\t\tservice = list_entry(list_itr, struct service_hndl, list);\n\t\tif (!test_bit(accel_dev->accel_id, service->start_status))\n\t\t\tcontinue;\n\t\tret = service->event_hld(accel_dev, ADF_EVENT_STOP);\n\t\tif (!ret) {\n\t\t\tclear_bit(accel_dev->accel_id, service->start_status);\n\t\t} else if (ret == -EAGAIN) {\n\t\t\twait = true;\n\t\t\tclear_bit(accel_dev->accel_id, service->start_status);\n\t\t}\n\t}\n\n\tif (hw_data->stop_timer)\n\t\thw_data->stop_timer(accel_dev);\n\n\tif (wait)\n\t\tmsleep(100);\n\n\tif (test_bit(ADF_STATUS_AE_STARTED, &accel_dev->status)) {\n\t\tif (adf_ae_stop(accel_dev))\n\t\t\tdev_err(&GET_DEV(accel_dev), \"failed to stop AE\\n\");\n\t\telse\n\t\t\tclear_bit(ADF_STATUS_AE_STARTED, &accel_dev->status);\n\t}\n}\n\n \nstatic void adf_dev_shutdown(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tstruct service_hndl *service;\n\tstruct list_head *list_itr;\n\n\tif (!hw_data) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"QAT: Failed to shutdown device - hw_data not set\\n\");\n\t\treturn;\n\t}\n\n\tif (test_bit(ADF_STATUS_AE_UCODE_LOADED, &accel_dev->status)) {\n\t\tadf_ae_fw_release(accel_dev);\n\t\tclear_bit(ADF_STATUS_AE_UCODE_LOADED, &accel_dev->status);\n\t}\n\n\tif (test_bit(ADF_STATUS_AE_INITIALISED, &accel_dev->status)) {\n\t\tif (adf_ae_shutdown(accel_dev))\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"Failed to shutdown Accel Engine\\n\");\n\t\telse\n\t\t\tclear_bit(ADF_STATUS_AE_INITIALISED,\n\t\t\t\t  &accel_dev->status);\n\t}\n\n\tlist_for_each(list_itr, &service_table) {\n\t\tservice = list_entry(list_itr, struct service_hndl, list);\n\t\tif (!test_bit(accel_dev->accel_id, service->init_status))\n\t\t\tcontinue;\n\t\tif (service->event_hld(accel_dev, ADF_EVENT_SHUTDOWN))\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"Failed to shutdown service %s\\n\",\n\t\t\t\tservice->name);\n\t\telse\n\t\t\tclear_bit(accel_dev->accel_id, service->init_status);\n\t}\n\n\tadf_heartbeat_shutdown(accel_dev);\n\n\thw_data->disable_iov(accel_dev);\n\n\tif (test_bit(ADF_STATUS_IRQ_ALLOCATED, &accel_dev->status)) {\n\t\thw_data->free_irq(accel_dev);\n\t\tclear_bit(ADF_STATUS_IRQ_ALLOCATED, &accel_dev->status);\n\t}\n\n\t \n\tif (!test_bit(ADF_STATUS_RESTARTING, &accel_dev->status))\n\t\tadf_cfg_del_all(accel_dev);\n\n\tif (hw_data->exit_arb)\n\t\thw_data->exit_arb(accel_dev);\n\n\tif (hw_data->exit_admin_comms)\n\t\thw_data->exit_admin_comms(accel_dev);\n\n\tadf_cleanup_etr_data(accel_dev);\n\tadf_dev_restore(accel_dev);\n}\n\nint adf_dev_restarting_notify(struct adf_accel_dev *accel_dev)\n{\n\tstruct service_hndl *service;\n\tstruct list_head *list_itr;\n\n\tlist_for_each(list_itr, &service_table) {\n\t\tservice = list_entry(list_itr, struct service_hndl, list);\n\t\tif (service->event_hld(accel_dev, ADF_EVENT_RESTARTING))\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"Failed to restart service %s.\\n\",\n\t\t\t\tservice->name);\n\t}\n\treturn 0;\n}\n\nint adf_dev_restarted_notify(struct adf_accel_dev *accel_dev)\n{\n\tstruct service_hndl *service;\n\tstruct list_head *list_itr;\n\n\tlist_for_each(list_itr, &service_table) {\n\t\tservice = list_entry(list_itr, struct service_hndl, list);\n\t\tif (service->event_hld(accel_dev, ADF_EVENT_RESTARTED))\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"Failed to restart service %s.\\n\",\n\t\t\t\tservice->name);\n\t}\n\treturn 0;\n}\n\nstatic int adf_dev_shutdown_cache_cfg(struct adf_accel_dev *accel_dev)\n{\n\tchar services[ADF_CFG_MAX_VAL_LEN_IN_BYTES] = {0};\n\tint ret;\n\n\tret = adf_cfg_get_param_value(accel_dev, ADF_GENERAL_SEC,\n\t\t\t\t      ADF_SERVICES_ENABLED, services);\n\n\tadf_dev_stop(accel_dev);\n\tadf_dev_shutdown(accel_dev);\n\n\tif (!ret) {\n\t\tret = adf_cfg_section_add(accel_dev, ADF_GENERAL_SEC);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = adf_cfg_add_key_value_param(accel_dev, ADF_GENERAL_SEC,\n\t\t\t\t\t\t  ADF_SERVICES_ENABLED,\n\t\t\t\t\t\t  services, ADF_STR);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint adf_dev_down(struct adf_accel_dev *accel_dev, bool reconfig)\n{\n\tint ret = 0;\n\n\tif (!accel_dev)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&accel_dev->state_lock);\n\n\tif (reconfig) {\n\t\tret = adf_dev_shutdown_cache_cfg(accel_dev);\n\t\tgoto out;\n\t}\n\n\tadf_dev_stop(accel_dev);\n\tadf_dev_shutdown(accel_dev);\n\nout:\n\tmutex_unlock(&accel_dev->state_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(adf_dev_down);\n\nint adf_dev_up(struct adf_accel_dev *accel_dev, bool config)\n{\n\tint ret = 0;\n\n\tif (!accel_dev)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&accel_dev->state_lock);\n\n\tif (adf_dev_started(accel_dev)) {\n\t\tdev_info(&GET_DEV(accel_dev), \"Device qat_dev%d already up\\n\",\n\t\t\t accel_dev->accel_id);\n\t\tret = -EALREADY;\n\t\tgoto out;\n\t}\n\n\tif (config && GET_HW_DATA(accel_dev)->dev_config) {\n\t\tret = GET_HW_DATA(accel_dev)->dev_config(accel_dev);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t}\n\n\tret = adf_dev_init(accel_dev);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = adf_dev_start(accel_dev);\n\nout:\n\tmutex_unlock(&accel_dev->state_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(adf_dev_up);\n\nint adf_dev_restart(struct adf_accel_dev *accel_dev)\n{\n\tint ret = 0;\n\n\tif (!accel_dev)\n\t\treturn -EFAULT;\n\n\tadf_dev_down(accel_dev, false);\n\n\tret = adf_dev_up(accel_dev, false);\n\t \n\tif (ret == -EALREADY)\n\t\treturn 0;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(adf_dev_restart);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}