{
  "module_name": "qat_hal.c",
  "hash_id": "13e4ab66c85bae07ab7086c29f83c7702f2f73050c81b6d41f6df73f9f5bf7ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/qat_hal.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/pci_ids.h>\n\n#include \"adf_accel_devices.h\"\n#include \"adf_common_drv.h\"\n#include \"icp_qat_hal.h\"\n#include \"icp_qat_uclo.h\"\n\n#define BAD_REGADDR\t       0xffff\n#define MAX_RETRY_TIMES\t   10000\n#define INIT_CTX_ARB_VALUE\t0x0\n#define INIT_CTX_ENABLE_VALUE     0x0\n#define INIT_PC_VALUE\t     0x0\n#define INIT_WAKEUP_EVENTS_VALUE  0x1\n#define INIT_SIG_EVENTS_VALUE     0x1\n#define INIT_CCENABLE_VALUE       0x2000\n#define RST_CSR_QAT_LSB\t   20\n#define RST_CSR_AE_LSB\t\t  0\n#define MC_TIMESTAMP_ENABLE       (0x1 << 7)\n\n#define IGNORE_W1C_MASK ((~(1 << CE_BREAKPOINT_BITPOS)) & \\\n\t(~(1 << CE_CNTL_STORE_PARITY_ERROR_BITPOS)) & \\\n\t(~(1 << CE_REG_PAR_ERR_BITPOS)))\n#define INSERT_IMMED_GPRA_CONST(inst, const_val) \\\n\t(inst = ((inst & 0xFFFF00C03FFull) | \\\n\t\t((((const_val) << 12) & 0x0FF00000ull) | \\\n\t\t(((const_val) << 10) & 0x0003FC00ull))))\n#define INSERT_IMMED_GPRB_CONST(inst, const_val) \\\n\t(inst = ((inst & 0xFFFF00FFF00ull) | \\\n\t\t((((const_val) << 12) & 0x0FF00000ull) | \\\n\t\t(((const_val) <<  0) & 0x000000FFull))))\n\n#define AE(handle, ae) ((handle)->hal_handle->aes[ae])\n\nstatic const u64 inst_4b[] = {\n\t0x0F0400C0000ull, 0x0F4400C0000ull, 0x0F040000300ull, 0x0F440000300ull,\n\t0x0FC066C0000ull, 0x0F0000C0300ull, 0x0F0000C0300ull, 0x0F0000C0300ull,\n\t0x0A021000000ull\n};\n\nstatic const u64 inst[] = {\n\t0x0F0000C0000ull, 0x0F000000380ull, 0x0D805000011ull, 0x0FC082C0300ull,\n\t0x0F0000C0300ull, 0x0F0000C0300ull, 0x0F0000C0300ull, 0x0F0000C0300ull,\n\t0x0A0643C0000ull, 0x0BAC0000301ull, 0x0D802000101ull, 0x0F0000C0001ull,\n\t0x0FC066C0001ull, 0x0F0000C0300ull, 0x0F0000C0300ull, 0x0F0000C0300ull,\n\t0x0F000400300ull, 0x0A0610C0000ull, 0x0BAC0000301ull, 0x0D804400101ull,\n\t0x0A0580C0000ull, 0x0A0581C0000ull, 0x0A0582C0000ull, 0x0A0583C0000ull,\n\t0x0A0584C0000ull, 0x0A0585C0000ull, 0x0A0586C0000ull, 0x0A0587C0000ull,\n\t0x0A0588C0000ull, 0x0A0589C0000ull, 0x0A058AC0000ull, 0x0A058BC0000ull,\n\t0x0A058CC0000ull, 0x0A058DC0000ull, 0x0A058EC0000ull, 0x0A058FC0000ull,\n\t0x0A05C0C0000ull, 0x0A05C1C0000ull, 0x0A05C2C0000ull, 0x0A05C3C0000ull,\n\t0x0A05C4C0000ull, 0x0A05C5C0000ull, 0x0A05C6C0000ull, 0x0A05C7C0000ull,\n\t0x0A05C8C0000ull, 0x0A05C9C0000ull, 0x0A05CAC0000ull, 0x0A05CBC0000ull,\n\t0x0A05CCC0000ull, 0x0A05CDC0000ull, 0x0A05CEC0000ull, 0x0A05CFC0000ull,\n\t0x0A0400C0000ull, 0x0B0400C0000ull, 0x0A0401C0000ull, 0x0B0401C0000ull,\n\t0x0A0402C0000ull, 0x0B0402C0000ull, 0x0A0403C0000ull, 0x0B0403C0000ull,\n\t0x0A0404C0000ull, 0x0B0404C0000ull, 0x0A0405C0000ull, 0x0B0405C0000ull,\n\t0x0A0406C0000ull, 0x0B0406C0000ull, 0x0A0407C0000ull, 0x0B0407C0000ull,\n\t0x0A0408C0000ull, 0x0B0408C0000ull, 0x0A0409C0000ull, 0x0B0409C0000ull,\n\t0x0A040AC0000ull, 0x0B040AC0000ull, 0x0A040BC0000ull, 0x0B040BC0000ull,\n\t0x0A040CC0000ull, 0x0B040CC0000ull, 0x0A040DC0000ull, 0x0B040DC0000ull,\n\t0x0A040EC0000ull, 0x0B040EC0000ull, 0x0A040FC0000ull, 0x0B040FC0000ull,\n\t0x0D81581C010ull, 0x0E000010000ull, 0x0E000010000ull,\n};\n\nvoid qat_hal_set_live_ctx(struct icp_qat_fw_loader_handle *handle,\n\t\t\t  unsigned char ae, unsigned int ctx_mask)\n{\n\tAE(handle, ae).live_ctx_mask = ctx_mask;\n}\n\n#define CSR_RETRY_TIMES 500\nstatic int qat_hal_rd_ae_csr(struct icp_qat_fw_loader_handle *handle,\n\t\t\t     unsigned char ae, unsigned int csr)\n{\n\tunsigned int iterations = CSR_RETRY_TIMES;\n\tint value;\n\n\tdo {\n\t\tvalue = GET_AE_CSR(handle, ae, csr);\n\t\tif (!(GET_AE_CSR(handle, ae, LOCAL_CSR_STATUS) & LCS_STATUS))\n\t\t\treturn value;\n\t} while (iterations--);\n\n\tpr_err(\"QAT: Read CSR timeout\\n\");\n\treturn 0;\n}\n\nstatic int qat_hal_wr_ae_csr(struct icp_qat_fw_loader_handle *handle,\n\t\t\t     unsigned char ae, unsigned int csr,\n\t\t\t     unsigned int value)\n{\n\tunsigned int iterations = CSR_RETRY_TIMES;\n\n\tdo {\n\t\tSET_AE_CSR(handle, ae, csr, value);\n\t\tif (!(GET_AE_CSR(handle, ae, LOCAL_CSR_STATUS) & LCS_STATUS))\n\t\t\treturn 0;\n\t} while (iterations--);\n\n\tpr_err(\"QAT: Write CSR Timeout\\n\");\n\treturn -EFAULT;\n}\n\nstatic void qat_hal_get_wakeup_event(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t     unsigned char ae, unsigned char ctx,\n\t\t\t\t     unsigned int *events)\n{\n\tunsigned int cur_ctx;\n\n\tcur_ctx = qat_hal_rd_ae_csr(handle, ae, CSR_CTX_POINTER);\n\tqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, ctx);\n\t*events = qat_hal_rd_ae_csr(handle, ae, CTX_WAKEUP_EVENTS_INDIRECT);\n\tqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, cur_ctx);\n}\n\nstatic int qat_hal_wait_cycles(struct icp_qat_fw_loader_handle *handle,\n\t\t\t       unsigned char ae, unsigned int cycles,\n\t\t\t       int chk_inactive)\n{\n\tunsigned int base_cnt = 0, cur_cnt = 0;\n\tunsigned int csr = (1 << ACS_ABO_BITPOS);\n\tint times = MAX_RETRY_TIMES;\n\tint elapsed_cycles = 0;\n\n\tbase_cnt = qat_hal_rd_ae_csr(handle, ae, PROFILE_COUNT);\n\tbase_cnt &= 0xffff;\n\twhile ((int)cycles > elapsed_cycles && times--) {\n\t\tif (chk_inactive)\n\t\t\tcsr = qat_hal_rd_ae_csr(handle, ae, ACTIVE_CTX_STATUS);\n\n\t\tcur_cnt = qat_hal_rd_ae_csr(handle, ae, PROFILE_COUNT);\n\t\tcur_cnt &= 0xffff;\n\t\telapsed_cycles = cur_cnt - base_cnt;\n\n\t\tif (elapsed_cycles < 0)\n\t\t\telapsed_cycles += 0x10000;\n\n\t\t \n\t\tif (elapsed_cycles >= 8 && !(csr & (1 << ACS_ABO_BITPOS)))\n\t\t\treturn 0;\n\t}\n\tif (times < 0) {\n\t\tpr_err(\"QAT: wait_num_cycles time out\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n#define CLR_BIT(wrd, bit) ((wrd) & ~(1 << (bit)))\n#define SET_BIT(wrd, bit) ((wrd) | 1 << (bit))\n\nint qat_hal_set_ae_ctx_mode(struct icp_qat_fw_loader_handle *handle,\n\t\t\t    unsigned char ae, unsigned char mode)\n{\n\tunsigned int csr, new_csr;\n\n\tif (mode != 4 && mode != 8) {\n\t\tpr_err(\"QAT: bad ctx mode=%d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcsr = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\tcsr = IGNORE_W1C_MASK & csr;\n\tnew_csr = (mode == 4) ?\n\t\tSET_BIT(csr, CE_INUSE_CONTEXTS_BITPOS) :\n\t\tCLR_BIT(csr, CE_INUSE_CONTEXTS_BITPOS);\n\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, new_csr);\n\treturn 0;\n}\n\nint qat_hal_set_ae_nn_mode(struct icp_qat_fw_loader_handle *handle,\n\t\t\t   unsigned char ae, unsigned char mode)\n{\n\tunsigned int csr, new_csr;\n\n\tcsr = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\tcsr &= IGNORE_W1C_MASK;\n\n\tnew_csr = (mode) ?\n\t\tSET_BIT(csr, CE_NN_MODE_BITPOS) :\n\t\tCLR_BIT(csr, CE_NN_MODE_BITPOS);\n\n\tif (new_csr != csr)\n\t\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, new_csr);\n\n\treturn 0;\n}\n\nint qat_hal_set_ae_lm_mode(struct icp_qat_fw_loader_handle *handle,\n\t\t\t   unsigned char ae, enum icp_qat_uof_regtype lm_type,\n\t\t\t   unsigned char mode)\n{\n\tunsigned int csr, new_csr;\n\n\tcsr = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\tcsr &= IGNORE_W1C_MASK;\n\tswitch (lm_type) {\n\tcase ICP_LMEM0:\n\t\tnew_csr = (mode) ?\n\t\t\tSET_BIT(csr, CE_LMADDR_0_GLOBAL_BITPOS) :\n\t\t\tCLR_BIT(csr, CE_LMADDR_0_GLOBAL_BITPOS);\n\t\tbreak;\n\tcase ICP_LMEM1:\n\t\tnew_csr = (mode) ?\n\t\t\tSET_BIT(csr, CE_LMADDR_1_GLOBAL_BITPOS) :\n\t\t\tCLR_BIT(csr, CE_LMADDR_1_GLOBAL_BITPOS);\n\t\tbreak;\n\tcase ICP_LMEM2:\n\t\tnew_csr = (mode) ?\n\t\t\tSET_BIT(csr, CE_LMADDR_2_GLOBAL_BITPOS) :\n\t\t\tCLR_BIT(csr, CE_LMADDR_2_GLOBAL_BITPOS);\n\t\tbreak;\n\tcase ICP_LMEM3:\n\t\tnew_csr = (mode) ?\n\t\t\tSET_BIT(csr, CE_LMADDR_3_GLOBAL_BITPOS) :\n\t\t\tCLR_BIT(csr, CE_LMADDR_3_GLOBAL_BITPOS);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"QAT: lmType = 0x%x\\n\", lm_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_csr != csr)\n\t\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, new_csr);\n\treturn 0;\n}\n\nvoid qat_hal_set_ae_tindex_mode(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\tunsigned char ae, unsigned char mode)\n{\n\tunsigned int csr, new_csr;\n\n\tcsr = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\tcsr &= IGNORE_W1C_MASK;\n\tnew_csr = (mode) ?\n\t\t  SET_BIT(csr, CE_T_INDEX_GLOBAL_BITPOS) :\n\t\t  CLR_BIT(csr, CE_T_INDEX_GLOBAL_BITPOS);\n\tif (new_csr != csr)\n\t\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, new_csr);\n}\n\nstatic unsigned short qat_hal_get_reg_addr(unsigned int type,\n\t\t\t\t\t   unsigned short reg_num)\n{\n\tunsigned short reg_addr;\n\n\tswitch (type) {\n\tcase ICP_GPA_ABS:\n\tcase ICP_GPB_ABS:\n\t\treg_addr = 0x80 | (reg_num & 0x7f);\n\t\tbreak;\n\tcase ICP_GPA_REL:\n\tcase ICP_GPB_REL:\n\t\treg_addr = reg_num & 0x1f;\n\t\tbreak;\n\tcase ICP_SR_RD_REL:\n\tcase ICP_SR_WR_REL:\n\tcase ICP_SR_REL:\n\t\treg_addr = 0x180 | (reg_num & 0x1f);\n\t\tbreak;\n\tcase ICP_SR_ABS:\n\t\treg_addr = 0x140 | ((reg_num & 0x3) << 1);\n\t\tbreak;\n\tcase ICP_DR_RD_REL:\n\tcase ICP_DR_WR_REL:\n\tcase ICP_DR_REL:\n\t\treg_addr = 0x1c0 | (reg_num & 0x1f);\n\t\tbreak;\n\tcase ICP_DR_ABS:\n\t\treg_addr = 0x100 | ((reg_num & 0x3) << 1);\n\t\tbreak;\n\tcase ICP_NEIGH_REL:\n\t\treg_addr = 0x280 | (reg_num & 0x1f);\n\t\tbreak;\n\tcase ICP_LMEM0:\n\t\treg_addr = 0x200;\n\t\tbreak;\n\tcase ICP_LMEM1:\n\t\treg_addr = 0x220;\n\t\tbreak;\n\tcase ICP_LMEM2:\n\t\treg_addr = 0x2c0;\n\t\tbreak;\n\tcase ICP_LMEM3:\n\t\treg_addr = 0x2e0;\n\t\tbreak;\n\tcase ICP_NO_DEST:\n\t\treg_addr = 0x300 | (reg_num & 0xff);\n\t\tbreak;\n\tdefault:\n\t\treg_addr = BAD_REGADDR;\n\t\tbreak;\n\t}\n\treturn reg_addr;\n}\n\nvoid qat_hal_reset(struct icp_qat_fw_loader_handle *handle)\n{\n\tunsigned int reset_mask = handle->chip_info->icp_rst_mask;\n\tunsigned int reset_csr = handle->chip_info->icp_rst_csr;\n\tunsigned int csr_val;\n\n\tcsr_val = GET_CAP_CSR(handle, reset_csr);\n\tcsr_val |= reset_mask;\n\tSET_CAP_CSR(handle, reset_csr, csr_val);\n}\n\nstatic void qat_hal_wr_indr_csr(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\tunsigned char ae, unsigned int ctx_mask,\n\t\t\t\tunsigned int ae_csr, unsigned int csr_val)\n{\n\tunsigned int ctx, cur_ctx;\n\n\tcur_ctx = qat_hal_rd_ae_csr(handle, ae, CSR_CTX_POINTER);\n\n\tfor (ctx = 0; ctx < ICP_QAT_UCLO_MAX_CTX; ctx++) {\n\t\tif (!(ctx_mask & (1 << ctx)))\n\t\t\tcontinue;\n\t\tqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, ctx);\n\t\tqat_hal_wr_ae_csr(handle, ae, ae_csr, csr_val);\n\t}\n\n\tqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, cur_ctx);\n}\n\nstatic unsigned int qat_hal_rd_indr_csr(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\tunsigned char ae, unsigned char ctx,\n\t\t\t\tunsigned int ae_csr)\n{\n\tunsigned int cur_ctx, csr_val;\n\n\tcur_ctx = qat_hal_rd_ae_csr(handle, ae, CSR_CTX_POINTER);\n\tqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, ctx);\n\tcsr_val = qat_hal_rd_ae_csr(handle, ae, ae_csr);\n\tqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, cur_ctx);\n\n\treturn csr_val;\n}\n\nstatic void qat_hal_put_sig_event(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t  unsigned char ae, unsigned int ctx_mask,\n\t\t\t\t  unsigned int events)\n{\n\tunsigned int ctx, cur_ctx;\n\n\tcur_ctx = qat_hal_rd_ae_csr(handle, ae, CSR_CTX_POINTER);\n\tfor (ctx = 0; ctx < ICP_QAT_UCLO_MAX_CTX; ctx++) {\n\t\tif (!(ctx_mask & (1 << ctx)))\n\t\t\tcontinue;\n\t\tqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, ctx);\n\t\tqat_hal_wr_ae_csr(handle, ae, CTX_SIG_EVENTS_INDIRECT, events);\n\t}\n\tqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, cur_ctx);\n}\n\nstatic void qat_hal_put_wakeup_event(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t     unsigned char ae, unsigned int ctx_mask,\n\t\t\t\t     unsigned int events)\n{\n\tunsigned int ctx, cur_ctx;\n\n\tcur_ctx = qat_hal_rd_ae_csr(handle, ae, CSR_CTX_POINTER);\n\tfor (ctx = 0; ctx < ICP_QAT_UCLO_MAX_CTX; ctx++) {\n\t\tif (!(ctx_mask & (1 << ctx)))\n\t\t\tcontinue;\n\t\tqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, ctx);\n\t\tqat_hal_wr_ae_csr(handle, ae, CTX_WAKEUP_EVENTS_INDIRECT,\n\t\t\t\t  events);\n\t}\n\tqat_hal_wr_ae_csr(handle, ae, CSR_CTX_POINTER, cur_ctx);\n}\n\nstatic int qat_hal_check_ae_alive(struct icp_qat_fw_loader_handle *handle)\n{\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\tunsigned int base_cnt, cur_cnt;\n\tunsigned char ae;\n\tint times = MAX_RETRY_TIMES;\n\n\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\tbase_cnt = qat_hal_rd_ae_csr(handle, ae, PROFILE_COUNT);\n\t\tbase_cnt &= 0xffff;\n\n\t\tdo {\n\t\t\tcur_cnt = qat_hal_rd_ae_csr(handle, ae, PROFILE_COUNT);\n\t\t\tcur_cnt &= 0xffff;\n\t\t} while (times-- && (cur_cnt == base_cnt));\n\n\t\tif (times < 0) {\n\t\t\tpr_err(\"QAT: AE%d is inactive!!\\n\", ae);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint qat_hal_check_ae_active(struct icp_qat_fw_loader_handle *handle,\n\t\t\t    unsigned int ae)\n{\n\tunsigned int enable = 0, active = 0;\n\n\tenable = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\tactive = qat_hal_rd_ae_csr(handle, ae, ACTIVE_CTX_STATUS);\n\tif ((enable & (0xff << CE_ENABLE_BITPOS)) ||\n\t    (active & (1 << ACS_ABO_BITPOS)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void qat_hal_reset_timestamp(struct icp_qat_fw_loader_handle *handle)\n{\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\tunsigned int misc_ctl_csr, misc_ctl;\n\tunsigned char ae;\n\n\tmisc_ctl_csr = handle->chip_info->misc_ctl_csr;\n\t \n\tmisc_ctl = GET_CAP_CSR(handle, misc_ctl_csr);\n\tif (misc_ctl & MC_TIMESTAMP_ENABLE)\n\t\tSET_CAP_CSR(handle, misc_ctl_csr, misc_ctl &\n\t\t\t    (~MC_TIMESTAMP_ENABLE));\n\n\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\tqat_hal_wr_ae_csr(handle, ae, TIMESTAMP_LOW, 0);\n\t\tqat_hal_wr_ae_csr(handle, ae, TIMESTAMP_HIGH, 0);\n\t}\n\t \n\tSET_CAP_CSR(handle, misc_ctl_csr, misc_ctl | MC_TIMESTAMP_ENABLE);\n}\n\n#define ESRAM_AUTO_TINIT\tBIT(2)\n#define ESRAM_AUTO_TINIT_DONE\tBIT(3)\n#define ESRAM_AUTO_INIT_USED_CYCLES (1640)\n#define ESRAM_AUTO_INIT_CSR_OFFSET 0xC1C\nstatic int qat_hal_init_esram(struct icp_qat_fw_loader_handle *handle)\n{\n\tvoid __iomem *csr_addr =\n\t\t\t(void __iomem *)((uintptr_t)handle->hal_ep_csr_addr_v +\n\t\t\tESRAM_AUTO_INIT_CSR_OFFSET);\n\tunsigned int csr_val;\n\tint times = 30;\n\n\tif (handle->pci_dev->device != PCI_DEVICE_ID_INTEL_QAT_DH895XCC)\n\t\treturn 0;\n\n\tcsr_val = ADF_CSR_RD(csr_addr, 0);\n\tif ((csr_val & ESRAM_AUTO_TINIT) && (csr_val & ESRAM_AUTO_TINIT_DONE))\n\t\treturn 0;\n\n\tcsr_val = ADF_CSR_RD(csr_addr, 0);\n\tcsr_val |= ESRAM_AUTO_TINIT;\n\tADF_CSR_WR(csr_addr, 0, csr_val);\n\n\tdo {\n\t\tqat_hal_wait_cycles(handle, 0, ESRAM_AUTO_INIT_USED_CYCLES, 0);\n\t\tcsr_val = ADF_CSR_RD(csr_addr, 0);\n\t} while (!(csr_val & ESRAM_AUTO_TINIT_DONE) && times--);\n\tif (times < 0) {\n\t\tpr_err(\"QAT: Fail to init eSram!\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n#define SHRAM_INIT_CYCLES 2060\nint qat_hal_clr_reset(struct icp_qat_fw_loader_handle *handle)\n{\n\tunsigned int clk_csr = handle->chip_info->glb_clk_enable_csr;\n\tunsigned int reset_mask = handle->chip_info->icp_rst_mask;\n\tunsigned int reset_csr = handle->chip_info->icp_rst_csr;\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\tunsigned char ae = 0;\n\tunsigned int times = 100;\n\tunsigned int csr_val;\n\n\t \n\tcsr_val = GET_CAP_CSR(handle, reset_csr);\n\tcsr_val &= ~reset_mask;\n\tdo {\n\t\tSET_CAP_CSR(handle, reset_csr, csr_val);\n\t\tif (!(times--))\n\t\t\tgoto out_err;\n\t\tcsr_val = GET_CAP_CSR(handle, reset_csr);\n\t\tcsr_val &= reset_mask;\n\t} while (csr_val);\n\t \n\tcsr_val = GET_CAP_CSR(handle, clk_csr);\n\tcsr_val |= reset_mask;\n\tSET_CAP_CSR(handle, clk_csr, csr_val);\n\tif (qat_hal_check_ae_alive(handle))\n\t\tgoto out_err;\n\n\t \n\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES,\n\t\t\t\t  INIT_CTX_ENABLE_VALUE);\n\t\tqat_hal_wr_indr_csr(handle, ae, ICP_QAT_UCLO_AE_ALL_CTX,\n\t\t\t\t    CTX_STS_INDIRECT,\n\t\t\t\t    handle->hal_handle->upc_mask &\n\t\t\t\t    INIT_PC_VALUE);\n\t\tqat_hal_wr_ae_csr(handle, ae, CTX_ARB_CNTL, INIT_CTX_ARB_VALUE);\n\t\tqat_hal_wr_ae_csr(handle, ae, CC_ENABLE, INIT_CCENABLE_VALUE);\n\t\tqat_hal_put_wakeup_event(handle, ae,\n\t\t\t\t\t ICP_QAT_UCLO_AE_ALL_CTX,\n\t\t\t\t\t INIT_WAKEUP_EVENTS_VALUE);\n\t\tqat_hal_put_sig_event(handle, ae,\n\t\t\t\t      ICP_QAT_UCLO_AE_ALL_CTX,\n\t\t\t\t      INIT_SIG_EVENTS_VALUE);\n\t}\n\tif (qat_hal_init_esram(handle))\n\t\tgoto out_err;\n\tif (qat_hal_wait_cycles(handle, 0, SHRAM_INIT_CYCLES, 0))\n\t\tgoto out_err;\n\tqat_hal_reset_timestamp(handle);\n\n\treturn 0;\nout_err:\n\tpr_err(\"QAT: failed to get device out of reset\\n\");\n\treturn -EFAULT;\n}\n\nstatic void qat_hal_disable_ctx(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\tunsigned char ae, unsigned int ctx_mask)\n{\n\tunsigned int ctx;\n\n\tctx = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\tctx &= IGNORE_W1C_MASK &\n\t\t(~((ctx_mask & ICP_QAT_UCLO_AE_ALL_CTX) << CE_ENABLE_BITPOS));\n\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx);\n}\n\nstatic u64 qat_hal_parity_64bit(u64 word)\n{\n\tword ^= word >> 1;\n\tword ^= word >> 2;\n\tword ^= word >> 4;\n\tword ^= word >> 8;\n\tword ^= word >> 16;\n\tword ^= word >> 32;\n\treturn word & 1;\n}\n\nstatic u64 qat_hal_set_uword_ecc(u64 uword)\n{\n\tu64 bit0_mask = 0xff800007fffULL, bit1_mask = 0x1f801ff801fULL,\n\t\tbit2_mask = 0xe387e0781e1ULL, bit3_mask = 0x7cb8e388e22ULL,\n\t\tbit4_mask = 0xaf5b2c93244ULL, bit5_mask = 0xf56d5525488ULL,\n\t\tbit6_mask = 0xdaf69a46910ULL;\n\n\t \n\tuword &= ~(0x7fULL << 0x2C);\n\tuword |= qat_hal_parity_64bit(bit0_mask & uword) << 0x2C;\n\tuword |= qat_hal_parity_64bit(bit1_mask & uword) << 0x2D;\n\tuword |= qat_hal_parity_64bit(bit2_mask & uword) << 0x2E;\n\tuword |= qat_hal_parity_64bit(bit3_mask & uword) << 0x2F;\n\tuword |= qat_hal_parity_64bit(bit4_mask & uword) << 0x30;\n\tuword |= qat_hal_parity_64bit(bit5_mask & uword) << 0x31;\n\tuword |= qat_hal_parity_64bit(bit6_mask & uword) << 0x32;\n\treturn uword;\n}\n\nvoid qat_hal_wr_uwords(struct icp_qat_fw_loader_handle *handle,\n\t\t       unsigned char ae, unsigned int uaddr,\n\t\t       unsigned int words_num, u64 *uword)\n{\n\tunsigned int ustore_addr;\n\tunsigned int i;\n\n\tustore_addr = qat_hal_rd_ae_csr(handle, ae, USTORE_ADDRESS);\n\tuaddr |= UA_ECS;\n\tqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, uaddr);\n\tfor (i = 0; i < words_num; i++) {\n\t\tunsigned int uwrd_lo, uwrd_hi;\n\t\tu64 tmp;\n\n\t\ttmp = qat_hal_set_uword_ecc(uword[i]);\n\t\tuwrd_lo = (unsigned int)(tmp & 0xffffffff);\n\t\tuwrd_hi = (unsigned int)(tmp >> 0x20);\n\t\tqat_hal_wr_ae_csr(handle, ae, USTORE_DATA_LOWER, uwrd_lo);\n\t\tqat_hal_wr_ae_csr(handle, ae, USTORE_DATA_UPPER, uwrd_hi);\n\t}\n\tqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, ustore_addr);\n}\n\nstatic void qat_hal_enable_ctx(struct icp_qat_fw_loader_handle *handle,\n\t\t\t       unsigned char ae, unsigned int ctx_mask)\n{\n\tunsigned int ctx;\n\n\tctx = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\tctx &= IGNORE_W1C_MASK;\n\tctx_mask &= (ctx & CE_INUSE_CONTEXTS) ? 0x55 : 0xFF;\n\tctx |= (ctx_mask << CE_ENABLE_BITPOS);\n\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx);\n}\n\nstatic void qat_hal_clear_xfer(struct icp_qat_fw_loader_handle *handle)\n{\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\tunsigned char ae;\n\tunsigned short reg;\n\n\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\tfor (reg = 0; reg < ICP_QAT_UCLO_MAX_GPR_REG; reg++) {\n\t\t\tqat_hal_init_rd_xfer(handle, ae, 0, ICP_SR_RD_ABS,\n\t\t\t\t\t     reg, 0);\n\t\t\tqat_hal_init_rd_xfer(handle, ae, 0, ICP_DR_RD_ABS,\n\t\t\t\t\t     reg, 0);\n\t\t}\n\t}\n}\n\nstatic int qat_hal_clear_gpr(struct icp_qat_fw_loader_handle *handle)\n{\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\tunsigned char ae;\n\tunsigned int ctx_mask = ICP_QAT_UCLO_AE_ALL_CTX;\n\tint times = MAX_RETRY_TIMES;\n\tunsigned int csr_val = 0;\n\tunsigned int savctx = 0;\n\tint ret = 0;\n\n\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\tcsr_val = qat_hal_rd_ae_csr(handle, ae, AE_MISC_CONTROL);\n\t\tcsr_val &= ~(1 << MMC_SHARE_CS_BITPOS);\n\t\tqat_hal_wr_ae_csr(handle, ae, AE_MISC_CONTROL, csr_val);\n\t\tcsr_val = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\t\tcsr_val &= IGNORE_W1C_MASK;\n\t\tif (handle->chip_info->nn)\n\t\t\tcsr_val |= CE_NN_MODE;\n\n\t\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, csr_val);\n\t\tqat_hal_wr_uwords(handle, ae, 0, ARRAY_SIZE(inst),\n\t\t\t\t  (u64 *)inst);\n\t\tqat_hal_wr_indr_csr(handle, ae, ctx_mask, CTX_STS_INDIRECT,\n\t\t\t\t    handle->hal_handle->upc_mask &\n\t\t\t\t    INIT_PC_VALUE);\n\t\tsavctx = qat_hal_rd_ae_csr(handle, ae, ACTIVE_CTX_STATUS);\n\t\tqat_hal_wr_ae_csr(handle, ae, ACTIVE_CTX_STATUS, 0);\n\t\tqat_hal_put_wakeup_event(handle, ae, ctx_mask, XCWE_VOLUNTARY);\n\t\tqat_hal_wr_indr_csr(handle, ae, ctx_mask,\n\t\t\t\t    CTX_SIG_EVENTS_INDIRECT, 0);\n\t\tqat_hal_wr_ae_csr(handle, ae, CTX_SIG_EVENTS_ACTIVE, 0);\n\t\tqat_hal_enable_ctx(handle, ae, ctx_mask);\n\t}\n\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\t \n\t\tdo {\n\t\t\tret = qat_hal_wait_cycles(handle, ae, 20, 1);\n\t\t} while (ret && times--);\n\n\t\tif (times < 0) {\n\t\t\tpr_err(\"QAT: clear GPR of AE %d failed\", ae);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tqat_hal_disable_ctx(handle, ae, ctx_mask);\n\t\tqat_hal_wr_ae_csr(handle, ae, ACTIVE_CTX_STATUS,\n\t\t\t\t  savctx & ACS_ACNO);\n\t\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES,\n\t\t\t\t  INIT_CTX_ENABLE_VALUE);\n\t\tqat_hal_wr_indr_csr(handle, ae, ctx_mask, CTX_STS_INDIRECT,\n\t\t\t\t    handle->hal_handle->upc_mask &\n\t\t\t\t    INIT_PC_VALUE);\n\t\tqat_hal_wr_ae_csr(handle, ae, CTX_ARB_CNTL, INIT_CTX_ARB_VALUE);\n\t\tqat_hal_wr_ae_csr(handle, ae, CC_ENABLE, INIT_CCENABLE_VALUE);\n\t\tqat_hal_put_wakeup_event(handle, ae, ctx_mask,\n\t\t\t\t\t INIT_WAKEUP_EVENTS_VALUE);\n\t\tqat_hal_put_sig_event(handle, ae, ctx_mask,\n\t\t\t\t      INIT_SIG_EVENTS_VALUE);\n\t}\n\treturn 0;\n}\n\nstatic int qat_hal_chip_init(struct icp_qat_fw_loader_handle *handle,\n\t\t\t     struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_accel_pci *pci_info = &accel_dev->accel_pci_dev;\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tvoid __iomem *pmisc_addr = adf_get_pmisc_base(accel_dev);\n\tunsigned int max_en_ae_id = 0;\n\tstruct adf_bar *sram_bar;\n\tunsigned int csr_val = 0;\n\tunsigned long ae_mask;\n\tunsigned char ae = 0;\n\tint ret = 0;\n\n\thandle->pci_dev = pci_info->pci_dev;\n\tswitch (handle->pci_dev->device) {\n\tcase ADF_4XXX_PCI_DEVICE_ID:\n\tcase ADF_401XX_PCI_DEVICE_ID:\n\tcase ADF_402XX_PCI_DEVICE_ID:\n\t\thandle->chip_info->mmp_sram_size = 0;\n\t\thandle->chip_info->nn = false;\n\t\thandle->chip_info->lm2lm3 = true;\n\t\thandle->chip_info->lm_size = ICP_QAT_UCLO_MAX_LMEM_REG_2X;\n\t\thandle->chip_info->icp_rst_csr = ICP_RESET_CPP0;\n\t\thandle->chip_info->icp_rst_mask = 0x100015;\n\t\thandle->chip_info->glb_clk_enable_csr = ICP_GLOBAL_CLK_ENABLE_CPP0;\n\t\thandle->chip_info->misc_ctl_csr = MISC_CONTROL_C4XXX;\n\t\thandle->chip_info->wakeup_event_val = 0x80000000;\n\t\thandle->chip_info->fw_auth = true;\n\t\thandle->chip_info->css_3k = true;\n\t\thandle->chip_info->tgroup_share_ustore = true;\n\t\thandle->chip_info->fcu_ctl_csr = FCU_CONTROL_4XXX;\n\t\thandle->chip_info->fcu_sts_csr = FCU_STATUS_4XXX;\n\t\thandle->chip_info->fcu_dram_addr_hi = FCU_DRAM_ADDR_HI_4XXX;\n\t\thandle->chip_info->fcu_dram_addr_lo = FCU_DRAM_ADDR_LO_4XXX;\n\t\thandle->chip_info->fcu_loaded_ae_csr = FCU_AE_LOADED_4XXX;\n\t\thandle->chip_info->fcu_loaded_ae_pos = 0;\n\n\t\thandle->hal_cap_g_ctl_csr_addr_v = pmisc_addr + ICP_QAT_CAP_OFFSET_4XXX;\n\t\thandle->hal_cap_ae_xfer_csr_addr_v = pmisc_addr + ICP_QAT_AE_OFFSET_4XXX;\n\t\thandle->hal_ep_csr_addr_v = pmisc_addr + ICP_QAT_EP_OFFSET_4XXX;\n\t\thandle->hal_cap_ae_local_csr_addr_v =\n\t\t\t(void __iomem *)((uintptr_t)handle->hal_cap_ae_xfer_csr_addr_v\n\t\t\t+ LOCAL_TO_XFER_REG_OFFSET);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_INTEL_QAT_C62X:\n\tcase PCI_DEVICE_ID_INTEL_QAT_C3XXX:\n\t\thandle->chip_info->mmp_sram_size = 0;\n\t\thandle->chip_info->nn = true;\n\t\thandle->chip_info->lm2lm3 = false;\n\t\thandle->chip_info->lm_size = ICP_QAT_UCLO_MAX_LMEM_REG;\n\t\thandle->chip_info->icp_rst_csr = ICP_RESET;\n\t\thandle->chip_info->icp_rst_mask = (hw_data->ae_mask << RST_CSR_AE_LSB) |\n\t\t\t\t\t\t  (hw_data->accel_mask << RST_CSR_QAT_LSB);\n\t\thandle->chip_info->glb_clk_enable_csr = ICP_GLOBAL_CLK_ENABLE;\n\t\thandle->chip_info->misc_ctl_csr = MISC_CONTROL;\n\t\thandle->chip_info->wakeup_event_val = WAKEUP_EVENT;\n\t\thandle->chip_info->fw_auth = true;\n\t\thandle->chip_info->css_3k = false;\n\t\thandle->chip_info->tgroup_share_ustore = false;\n\t\thandle->chip_info->fcu_ctl_csr = FCU_CONTROL;\n\t\thandle->chip_info->fcu_sts_csr = FCU_STATUS;\n\t\thandle->chip_info->fcu_dram_addr_hi = FCU_DRAM_ADDR_HI;\n\t\thandle->chip_info->fcu_dram_addr_lo = FCU_DRAM_ADDR_LO;\n\t\thandle->chip_info->fcu_loaded_ae_csr = FCU_STATUS;\n\t\thandle->chip_info->fcu_loaded_ae_pos = FCU_LOADED_AE_POS;\n\t\thandle->hal_cap_g_ctl_csr_addr_v = pmisc_addr + ICP_QAT_CAP_OFFSET;\n\t\thandle->hal_cap_ae_xfer_csr_addr_v = pmisc_addr + ICP_QAT_AE_OFFSET;\n\t\thandle->hal_ep_csr_addr_v = pmisc_addr + ICP_QAT_EP_OFFSET;\n\t\thandle->hal_cap_ae_local_csr_addr_v =\n\t\t\t(void __iomem *)((uintptr_t)handle->hal_cap_ae_xfer_csr_addr_v\n\t\t\t+ LOCAL_TO_XFER_REG_OFFSET);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_INTEL_QAT_DH895XCC:\n\t\thandle->chip_info->mmp_sram_size = 0x40000;\n\t\thandle->chip_info->nn = true;\n\t\thandle->chip_info->lm2lm3 = false;\n\t\thandle->chip_info->lm_size = ICP_QAT_UCLO_MAX_LMEM_REG;\n\t\thandle->chip_info->icp_rst_csr = ICP_RESET;\n\t\thandle->chip_info->icp_rst_mask = (hw_data->ae_mask << RST_CSR_AE_LSB) |\n\t\t\t\t\t\t  (hw_data->accel_mask << RST_CSR_QAT_LSB);\n\t\thandle->chip_info->glb_clk_enable_csr = ICP_GLOBAL_CLK_ENABLE;\n\t\thandle->chip_info->misc_ctl_csr = MISC_CONTROL;\n\t\thandle->chip_info->wakeup_event_val = WAKEUP_EVENT;\n\t\thandle->chip_info->fw_auth = false;\n\t\thandle->chip_info->css_3k = false;\n\t\thandle->chip_info->tgroup_share_ustore = false;\n\t\thandle->chip_info->fcu_ctl_csr = 0;\n\t\thandle->chip_info->fcu_sts_csr = 0;\n\t\thandle->chip_info->fcu_dram_addr_hi = 0;\n\t\thandle->chip_info->fcu_dram_addr_lo = 0;\n\t\thandle->chip_info->fcu_loaded_ae_csr = 0;\n\t\thandle->chip_info->fcu_loaded_ae_pos = 0;\n\t\thandle->hal_cap_g_ctl_csr_addr_v = pmisc_addr + ICP_QAT_CAP_OFFSET;\n\t\thandle->hal_cap_ae_xfer_csr_addr_v = pmisc_addr + ICP_QAT_AE_OFFSET;\n\t\thandle->hal_ep_csr_addr_v = pmisc_addr + ICP_QAT_EP_OFFSET;\n\t\thandle->hal_cap_ae_local_csr_addr_v =\n\t\t\t(void __iomem *)((uintptr_t)handle->hal_cap_ae_xfer_csr_addr_v\n\t\t\t+ LOCAL_TO_XFER_REG_OFFSET);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (handle->chip_info->mmp_sram_size > 0) {\n\t\tsram_bar =\n\t\t\t&pci_info->pci_bars[hw_data->get_sram_bar_id(hw_data)];\n\t\thandle->hal_sram_addr_v = sram_bar->virt_addr;\n\t}\n\thandle->hal_handle->revision_id = accel_dev->accel_pci_dev.revid;\n\thandle->hal_handle->ae_mask = hw_data->ae_mask;\n\thandle->hal_handle->admin_ae_mask = hw_data->admin_ae_mask;\n\thandle->hal_handle->slice_mask = hw_data->accel_mask;\n\thandle->cfg_ae_mask = ALL_AE_MASK;\n\t \n\thandle->hal_handle->upc_mask = 0x1ffff;\n\thandle->hal_handle->max_ustore = 0x4000;\n\n\tae_mask = handle->hal_handle->ae_mask;\n\tfor_each_set_bit(ae, &ae_mask, ICP_QAT_UCLO_MAX_AE) {\n\t\thandle->hal_handle->aes[ae].free_addr = 0;\n\t\thandle->hal_handle->aes[ae].free_size =\n\t\t    handle->hal_handle->max_ustore;\n\t\thandle->hal_handle->aes[ae].ustore_size =\n\t\t    handle->hal_handle->max_ustore;\n\t\thandle->hal_handle->aes[ae].live_ctx_mask =\n\t\t\t\t\t\tICP_QAT_UCLO_AE_ALL_CTX;\n\t\tmax_en_ae_id = ae;\n\t}\n\thandle->hal_handle->ae_max_num = max_en_ae_id + 1;\n\n\t \n\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\tcsr_val = qat_hal_rd_ae_csr(handle, ae, SIGNATURE_ENABLE);\n\t\tcsr_val |= 0x1;\n\t\tqat_hal_wr_ae_csr(handle, ae, SIGNATURE_ENABLE, csr_val);\n\t}\nout_err:\n\treturn ret;\n}\n\nint qat_hal_init(struct adf_accel_dev *accel_dev)\n{\n\tstruct icp_qat_fw_loader_handle *handle;\n\tint ret = 0;\n\n\thandle = kzalloc(sizeof(*handle), GFP_KERNEL);\n\tif (!handle)\n\t\treturn -ENOMEM;\n\n\thandle->hal_handle = kzalloc(sizeof(*handle->hal_handle), GFP_KERNEL);\n\tif (!handle->hal_handle) {\n\t\tret = -ENOMEM;\n\t\tgoto out_hal_handle;\n\t}\n\n\thandle->chip_info = kzalloc(sizeof(*handle->chip_info), GFP_KERNEL);\n\tif (!handle->chip_info) {\n\t\tret = -ENOMEM;\n\t\tgoto out_chip_info;\n\t}\n\n\tret = qat_hal_chip_init(handle, accel_dev);\n\tif (ret) {\n\t\tdev_err(&GET_DEV(accel_dev), \"qat_hal_chip_init error\\n\");\n\t\tgoto out_err;\n\t}\n\n\t \n\tret = qat_hal_clr_reset(handle);\n\tif (ret) {\n\t\tdev_err(&GET_DEV(accel_dev), \"qat_hal_clr_reset error\\n\");\n\t\tgoto out_err;\n\t}\n\n\tqat_hal_clear_xfer(handle);\n\tif (!handle->chip_info->fw_auth) {\n\t\tret = qat_hal_clear_gpr(handle);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\n\taccel_dev->fw_loader->fw_loader = handle;\n\treturn 0;\n\nout_err:\n\tkfree(handle->chip_info);\nout_chip_info:\n\tkfree(handle->hal_handle);\nout_hal_handle:\n\tkfree(handle);\n\treturn ret;\n}\n\nvoid qat_hal_deinit(struct icp_qat_fw_loader_handle *handle)\n{\n\tif (!handle)\n\t\treturn;\n\tkfree(handle->chip_info);\n\tkfree(handle->hal_handle);\n\tkfree(handle);\n}\n\nint qat_hal_start(struct icp_qat_fw_loader_handle *handle)\n{\n\tunsigned long ae_mask = handle->hal_handle->ae_mask;\n\tu32 wakeup_val = handle->chip_info->wakeup_event_val;\n\tu32 fcu_ctl_csr, fcu_sts_csr;\n\tunsigned int fcu_sts;\n\tunsigned char ae;\n\tu32 ae_ctr = 0;\n\tint retry = 0;\n\n\tif (handle->chip_info->fw_auth) {\n\t\tfcu_ctl_csr = handle->chip_info->fcu_ctl_csr;\n\t\tfcu_sts_csr = handle->chip_info->fcu_sts_csr;\n\t\tae_ctr = hweight32(ae_mask);\n\t\tSET_CAP_CSR(handle, fcu_ctl_csr, FCU_CTRL_CMD_START);\n\t\tdo {\n\t\t\tmsleep(FW_AUTH_WAIT_PERIOD);\n\t\t\tfcu_sts = GET_CAP_CSR(handle, fcu_sts_csr);\n\t\t\tif (((fcu_sts >> FCU_STS_DONE_POS) & 0x1))\n\t\t\t\treturn ae_ctr;\n\t\t} while (retry++ < FW_AUTH_MAX_RETRY);\n\t\tpr_err(\"QAT: start error (FCU_STS = 0x%x)\\n\", fcu_sts);\n\t\treturn 0;\n\t} else {\n\t\tfor_each_set_bit(ae, &ae_mask, handle->hal_handle->ae_max_num) {\n\t\t\tqat_hal_put_wakeup_event(handle, ae, 0, wakeup_val);\n\t\t\tqat_hal_enable_ctx(handle, ae, ICP_QAT_UCLO_AE_ALL_CTX);\n\t\t\tae_ctr++;\n\t\t}\n\t\treturn ae_ctr;\n\t}\n}\n\nvoid qat_hal_stop(struct icp_qat_fw_loader_handle *handle, unsigned char ae,\n\t\t  unsigned int ctx_mask)\n{\n\tif (!handle->chip_info->fw_auth)\n\t\tqat_hal_disable_ctx(handle, ae, ctx_mask);\n}\n\nvoid qat_hal_set_pc(struct icp_qat_fw_loader_handle *handle,\n\t\t    unsigned char ae, unsigned int ctx_mask, unsigned int upc)\n{\n\tqat_hal_wr_indr_csr(handle, ae, ctx_mask, CTX_STS_INDIRECT,\n\t\t\t    handle->hal_handle->upc_mask & upc);\n}\n\nstatic void qat_hal_get_uwords(struct icp_qat_fw_loader_handle *handle,\n\t\t\t       unsigned char ae, unsigned int uaddr,\n\t\t\t       unsigned int words_num, u64 *uword)\n{\n\tunsigned int i, uwrd_lo, uwrd_hi;\n\tunsigned int ustore_addr, misc_control;\n\n\tmisc_control = qat_hal_rd_ae_csr(handle, ae, AE_MISC_CONTROL);\n\tqat_hal_wr_ae_csr(handle, ae, AE_MISC_CONTROL,\n\t\t\t  misc_control & 0xfffffffb);\n\tustore_addr = qat_hal_rd_ae_csr(handle, ae, USTORE_ADDRESS);\n\tuaddr |= UA_ECS;\n\tfor (i = 0; i < words_num; i++) {\n\t\tqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, uaddr);\n\t\tuaddr++;\n\t\tuwrd_lo = qat_hal_rd_ae_csr(handle, ae, USTORE_DATA_LOWER);\n\t\tuwrd_hi = qat_hal_rd_ae_csr(handle, ae, USTORE_DATA_UPPER);\n\t\tuword[i] = uwrd_hi;\n\t\tuword[i] = (uword[i] << 0x20) | uwrd_lo;\n\t}\n\tqat_hal_wr_ae_csr(handle, ae, AE_MISC_CONTROL, misc_control);\n\tqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, ustore_addr);\n}\n\nvoid qat_hal_wr_umem(struct icp_qat_fw_loader_handle *handle,\n\t\t     unsigned char ae, unsigned int uaddr,\n\t\t     unsigned int words_num, unsigned int *data)\n{\n\tunsigned int i, ustore_addr;\n\n\tustore_addr = qat_hal_rd_ae_csr(handle, ae, USTORE_ADDRESS);\n\tuaddr |= UA_ECS;\n\tqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, uaddr);\n\tfor (i = 0; i < words_num; i++) {\n\t\tunsigned int uwrd_lo, uwrd_hi, tmp;\n\n\t\tuwrd_lo = ((data[i] & 0xfff0000) << 4) | (0x3 << 18) |\n\t\t\t  ((data[i] & 0xff00) << 2) |\n\t\t\t  (0x3 << 8) | (data[i] & 0xff);\n\t\tuwrd_hi = (0xf << 4) | ((data[i] & 0xf0000000) >> 28);\n\t\tuwrd_hi |= (hweight32(data[i] & 0xffff) & 0x1) << 8;\n\t\ttmp = ((data[i] >> 0x10) & 0xffff);\n\t\tuwrd_hi |= (hweight32(tmp) & 0x1) << 9;\n\t\tqat_hal_wr_ae_csr(handle, ae, USTORE_DATA_LOWER, uwrd_lo);\n\t\tqat_hal_wr_ae_csr(handle, ae, USTORE_DATA_UPPER, uwrd_hi);\n\t}\n\tqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, ustore_addr);\n}\n\n#define MAX_EXEC_INST 100\nstatic int qat_hal_exec_micro_inst(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t   unsigned char ae, unsigned char ctx,\n\t\t\t\t   u64 *micro_inst, unsigned int inst_num,\n\t\t\t\t   int code_off, unsigned int max_cycle,\n\t\t\t\t   unsigned int *endpc)\n{\n\tunsigned int ind_lm_addr_byte0 = 0, ind_lm_addr_byte1 = 0;\n\tunsigned int ind_lm_addr_byte2 = 0, ind_lm_addr_byte3 = 0;\n\tunsigned int ind_t_index = 0, ind_t_index_byte = 0;\n\tunsigned int ind_lm_addr0 = 0, ind_lm_addr1 = 0;\n\tunsigned int ind_lm_addr2 = 0, ind_lm_addr3 = 0;\n\tu64 savuwords[MAX_EXEC_INST];\n\tunsigned int ind_cnt_sig;\n\tunsigned int ind_sig, act_sig;\n\tunsigned int csr_val = 0, newcsr_val;\n\tunsigned int savctx;\n\tunsigned int savcc, wakeup_events, savpc;\n\tunsigned int ctxarb_ctl, ctx_enables;\n\n\tif ((inst_num > handle->hal_handle->max_ustore) || !micro_inst) {\n\t\tpr_err(\"QAT: invalid instruction num %d\\n\", inst_num);\n\t\treturn -EINVAL;\n\t}\n\t \n\tind_lm_addr0 = qat_hal_rd_indr_csr(handle, ae, ctx, LM_ADDR_0_INDIRECT);\n\tind_lm_addr1 = qat_hal_rd_indr_csr(handle, ae, ctx, LM_ADDR_1_INDIRECT);\n\tind_lm_addr_byte0 = qat_hal_rd_indr_csr(handle, ae, ctx,\n\t\t\t\t\t\tINDIRECT_LM_ADDR_0_BYTE_INDEX);\n\tind_lm_addr_byte1 = qat_hal_rd_indr_csr(handle, ae, ctx,\n\t\t\t\t\t\tINDIRECT_LM_ADDR_1_BYTE_INDEX);\n\tif (handle->chip_info->lm2lm3) {\n\t\tind_lm_addr2 = qat_hal_rd_indr_csr(handle, ae, ctx,\n\t\t\t\t\t\t   LM_ADDR_2_INDIRECT);\n\t\tind_lm_addr3 = qat_hal_rd_indr_csr(handle, ae, ctx,\n\t\t\t\t\t\t   LM_ADDR_3_INDIRECT);\n\t\tind_lm_addr_byte2 = qat_hal_rd_indr_csr(handle, ae, ctx,\n\t\t\t\t\t\t\tINDIRECT_LM_ADDR_2_BYTE_INDEX);\n\t\tind_lm_addr_byte3 = qat_hal_rd_indr_csr(handle, ae, ctx,\n\t\t\t\t\t\t\tINDIRECT_LM_ADDR_3_BYTE_INDEX);\n\t\tind_t_index = qat_hal_rd_indr_csr(handle, ae, ctx,\n\t\t\t\t\t\t  INDIRECT_T_INDEX);\n\t\tind_t_index_byte = qat_hal_rd_indr_csr(handle, ae, ctx,\n\t\t\t\t\t\t       INDIRECT_T_INDEX_BYTE_INDEX);\n\t}\n\tif (inst_num <= MAX_EXEC_INST)\n\t\tqat_hal_get_uwords(handle, ae, 0, inst_num, savuwords);\n\tqat_hal_get_wakeup_event(handle, ae, ctx, &wakeup_events);\n\tsavpc = qat_hal_rd_indr_csr(handle, ae, ctx, CTX_STS_INDIRECT);\n\tsavpc = (savpc & handle->hal_handle->upc_mask) >> 0;\n\tctx_enables = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\tctx_enables &= IGNORE_W1C_MASK;\n\tsavcc = qat_hal_rd_ae_csr(handle, ae, CC_ENABLE);\n\tsavctx = qat_hal_rd_ae_csr(handle, ae, ACTIVE_CTX_STATUS);\n\tctxarb_ctl = qat_hal_rd_ae_csr(handle, ae, CTX_ARB_CNTL);\n\tind_cnt_sig = qat_hal_rd_indr_csr(handle, ae, ctx,\n\t\t\t\t\t  FUTURE_COUNT_SIGNAL_INDIRECT);\n\tind_sig = qat_hal_rd_indr_csr(handle, ae, ctx,\n\t\t\t\t      CTX_SIG_EVENTS_INDIRECT);\n\tact_sig = qat_hal_rd_ae_csr(handle, ae, CTX_SIG_EVENTS_ACTIVE);\n\t \n\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx_enables);\n\tqat_hal_wr_uwords(handle, ae, 0, inst_num, micro_inst);\n\tqat_hal_wr_indr_csr(handle, ae, (1 << ctx), CTX_STS_INDIRECT, 0);\n\tqat_hal_wr_ae_csr(handle, ae, ACTIVE_CTX_STATUS, ctx & ACS_ACNO);\n\tif (code_off)\n\t\tqat_hal_wr_ae_csr(handle, ae, CC_ENABLE, savcc & 0xffffdfff);\n\tqat_hal_put_wakeup_event(handle, ae, (1 << ctx), XCWE_VOLUNTARY);\n\tqat_hal_wr_indr_csr(handle, ae, (1 << ctx), CTX_SIG_EVENTS_INDIRECT, 0);\n\tqat_hal_wr_ae_csr(handle, ae, CTX_SIG_EVENTS_ACTIVE, 0);\n\tqat_hal_enable_ctx(handle, ae, (1 << ctx));\n\t \n\tif (qat_hal_wait_cycles(handle, ae, max_cycle, 1) != 0)\n\t\treturn -EFAULT;\n\tif (endpc) {\n\t\tunsigned int ctx_status;\n\n\t\tctx_status = qat_hal_rd_indr_csr(handle, ae, ctx,\n\t\t\t\t\t\t CTX_STS_INDIRECT);\n\t\t*endpc = ctx_status & handle->hal_handle->upc_mask;\n\t}\n\t \n\tqat_hal_disable_ctx(handle, ae, (1 << ctx));\n\tif (inst_num <= MAX_EXEC_INST)\n\t\tqat_hal_wr_uwords(handle, ae, 0, inst_num, savuwords);\n\tqat_hal_put_wakeup_event(handle, ae, (1 << ctx), wakeup_events);\n\tqat_hal_wr_indr_csr(handle, ae, (1 << ctx), CTX_STS_INDIRECT,\n\t\t\t    handle->hal_handle->upc_mask & savpc);\n\tcsr_val = qat_hal_rd_ae_csr(handle, ae, AE_MISC_CONTROL);\n\tnewcsr_val = CLR_BIT(csr_val, MMC_SHARE_CS_BITPOS);\n\tqat_hal_wr_ae_csr(handle, ae, AE_MISC_CONTROL, newcsr_val);\n\tqat_hal_wr_ae_csr(handle, ae, CC_ENABLE, savcc);\n\tqat_hal_wr_ae_csr(handle, ae, ACTIVE_CTX_STATUS, savctx & ACS_ACNO);\n\tqat_hal_wr_ae_csr(handle, ae, CTX_ARB_CNTL, ctxarb_ctl);\n\tqat_hal_wr_indr_csr(handle, ae, (1 << ctx),\n\t\t\t    LM_ADDR_0_INDIRECT, ind_lm_addr0);\n\tqat_hal_wr_indr_csr(handle, ae, (1 << ctx),\n\t\t\t    LM_ADDR_1_INDIRECT, ind_lm_addr1);\n\tqat_hal_wr_indr_csr(handle, ae, (1 << ctx),\n\t\t\t    INDIRECT_LM_ADDR_0_BYTE_INDEX, ind_lm_addr_byte0);\n\tqat_hal_wr_indr_csr(handle, ae, (1 << ctx),\n\t\t\t    INDIRECT_LM_ADDR_1_BYTE_INDEX, ind_lm_addr_byte1);\n\tif (handle->chip_info->lm2lm3) {\n\t\tqat_hal_wr_indr_csr(handle, ae, BIT(ctx), LM_ADDR_2_INDIRECT,\n\t\t\t\t    ind_lm_addr2);\n\t\tqat_hal_wr_indr_csr(handle, ae, BIT(ctx), LM_ADDR_3_INDIRECT,\n\t\t\t\t    ind_lm_addr3);\n\t\tqat_hal_wr_indr_csr(handle, ae, BIT(ctx),\n\t\t\t\t    INDIRECT_LM_ADDR_2_BYTE_INDEX,\n\t\t\t\t    ind_lm_addr_byte2);\n\t\tqat_hal_wr_indr_csr(handle, ae, BIT(ctx),\n\t\t\t\t    INDIRECT_LM_ADDR_3_BYTE_INDEX,\n\t\t\t\t    ind_lm_addr_byte3);\n\t\tqat_hal_wr_indr_csr(handle, ae, BIT(ctx),\n\t\t\t\t    INDIRECT_T_INDEX, ind_t_index);\n\t\tqat_hal_wr_indr_csr(handle, ae, BIT(ctx),\n\t\t\t\t    INDIRECT_T_INDEX_BYTE_INDEX,\n\t\t\t\t    ind_t_index_byte);\n\t}\n\tqat_hal_wr_indr_csr(handle, ae, (1 << ctx),\n\t\t\t    FUTURE_COUNT_SIGNAL_INDIRECT, ind_cnt_sig);\n\tqat_hal_wr_indr_csr(handle, ae, (1 << ctx),\n\t\t\t    CTX_SIG_EVENTS_INDIRECT, ind_sig);\n\tqat_hal_wr_ae_csr(handle, ae, CTX_SIG_EVENTS_ACTIVE, act_sig);\n\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx_enables);\n\n\treturn 0;\n}\n\nstatic int qat_hal_rd_rel_reg(struct icp_qat_fw_loader_handle *handle,\n\t\t\t      unsigned char ae, unsigned char ctx,\n\t\t\t      enum icp_qat_uof_regtype reg_type,\n\t\t\t      unsigned short reg_num, unsigned int *data)\n{\n\tunsigned int savctx, uaddr, uwrd_lo, uwrd_hi;\n\tunsigned int ctxarb_cntl, ustore_addr, ctx_enables;\n\tunsigned short reg_addr;\n\tint status = 0;\n\tu64 insts, savuword;\n\n\treg_addr = qat_hal_get_reg_addr(reg_type, reg_num);\n\tif (reg_addr == BAD_REGADDR) {\n\t\tpr_err(\"QAT: bad regaddr=0x%x\\n\", reg_addr);\n\t\treturn -EINVAL;\n\t}\n\tswitch (reg_type) {\n\tcase ICP_GPA_REL:\n\t\tinsts = 0xA070000000ull | (reg_addr & 0x3ff);\n\t\tbreak;\n\tdefault:\n\t\tinsts = (u64)0xA030000000ull | ((reg_addr & 0x3ff) << 10);\n\t\tbreak;\n\t}\n\tsavctx = qat_hal_rd_ae_csr(handle, ae, ACTIVE_CTX_STATUS);\n\tctxarb_cntl = qat_hal_rd_ae_csr(handle, ae, CTX_ARB_CNTL);\n\tctx_enables = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\tctx_enables &= IGNORE_W1C_MASK;\n\tif (ctx != (savctx & ACS_ACNO))\n\t\tqat_hal_wr_ae_csr(handle, ae, ACTIVE_CTX_STATUS,\n\t\t\t\t  ctx & ACS_ACNO);\n\tqat_hal_get_uwords(handle, ae, 0, 1, &savuword);\n\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx_enables);\n\tustore_addr = qat_hal_rd_ae_csr(handle, ae, USTORE_ADDRESS);\n\tuaddr = UA_ECS;\n\tqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, uaddr);\n\tinsts = qat_hal_set_uword_ecc(insts);\n\tuwrd_lo = (unsigned int)(insts & 0xffffffff);\n\tuwrd_hi = (unsigned int)(insts >> 0x20);\n\tqat_hal_wr_ae_csr(handle, ae, USTORE_DATA_LOWER, uwrd_lo);\n\tqat_hal_wr_ae_csr(handle, ae, USTORE_DATA_UPPER, uwrd_hi);\n\tqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, uaddr);\n\t \n\tqat_hal_wait_cycles(handle, ae, 0x8, 0);\n\t \n\t*data = qat_hal_rd_ae_csr(handle, ae, ALU_OUT);\n\tqat_hal_wr_ae_csr(handle, ae, USTORE_ADDRESS, ustore_addr);\n\tqat_hal_wr_uwords(handle, ae, 0, 1, &savuword);\n\tif (ctx != (savctx & ACS_ACNO))\n\t\tqat_hal_wr_ae_csr(handle, ae, ACTIVE_CTX_STATUS,\n\t\t\t\t  savctx & ACS_ACNO);\n\tqat_hal_wr_ae_csr(handle, ae, CTX_ARB_CNTL, ctxarb_cntl);\n\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx_enables);\n\n\treturn status;\n}\n\nstatic int qat_hal_wr_rel_reg(struct icp_qat_fw_loader_handle *handle,\n\t\t\t      unsigned char ae, unsigned char ctx,\n\t\t\t      enum icp_qat_uof_regtype reg_type,\n\t\t\t      unsigned short reg_num, unsigned int data)\n{\n\tunsigned short src_hiaddr, src_lowaddr, dest_addr, data16hi, data16lo;\n\tu64 insts[] = {\n\t\t0x0F440000000ull,\n\t\t0x0F040000000ull,\n\t\t0x0F0000C0300ull,\n\t\t0x0E000010000ull\n\t};\n\tconst int num_inst = ARRAY_SIZE(insts), code_off = 1;\n\tconst int imm_w1 = 0, imm_w0 = 1;\n\n\tdest_addr = qat_hal_get_reg_addr(reg_type, reg_num);\n\tif (dest_addr == BAD_REGADDR) {\n\t\tpr_err(\"QAT: bad destAddr=0x%x\\n\", dest_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tdata16lo = 0xffff & data;\n\tdata16hi = 0xffff & (data >> 0x10);\n\tsrc_hiaddr = qat_hal_get_reg_addr(ICP_NO_DEST, (unsigned short)\n\t\t\t\t\t  (0xff & data16hi));\n\tsrc_lowaddr = qat_hal_get_reg_addr(ICP_NO_DEST, (unsigned short)\n\t\t\t\t\t   (0xff & data16lo));\n\tswitch (reg_type) {\n\tcase ICP_GPA_REL:\n\t\tinsts[imm_w1] = insts[imm_w1] | ((data16hi >> 8) << 20) |\n\t\t    ((src_hiaddr & 0x3ff) << 10) | (dest_addr & 0x3ff);\n\t\tinsts[imm_w0] = insts[imm_w0] | ((data16lo >> 8) << 20) |\n\t\t    ((src_lowaddr & 0x3ff) << 10) | (dest_addr & 0x3ff);\n\t\tbreak;\n\tdefault:\n\t\tinsts[imm_w1] = insts[imm_w1] | ((data16hi >> 8) << 20) |\n\t\t    ((dest_addr & 0x3ff) << 10) | (src_hiaddr & 0x3ff);\n\n\t\tinsts[imm_w0] = insts[imm_w0] | ((data16lo >> 8) << 20) |\n\t\t    ((dest_addr & 0x3ff) << 10) | (src_lowaddr & 0x3ff);\n\t\tbreak;\n\t}\n\n\treturn qat_hal_exec_micro_inst(handle, ae, ctx, insts, num_inst,\n\t\t\t\t       code_off, num_inst * 0x5, NULL);\n}\n\nint qat_hal_get_ins_num(void)\n{\n\treturn ARRAY_SIZE(inst_4b);\n}\n\nstatic int qat_hal_concat_micro_code(u64 *micro_inst,\n\t\t\t\t     unsigned int inst_num, unsigned int size,\n\t\t\t\t     unsigned int addr, unsigned int *value)\n{\n\tint i;\n\tunsigned int cur_value;\n\tconst u64 *inst_arr;\n\tint fixup_offset;\n\tint usize = 0;\n\tint orig_num;\n\n\torig_num = inst_num;\n\tcur_value = value[0];\n\tinst_arr = inst_4b;\n\tusize = ARRAY_SIZE(inst_4b);\n\tfixup_offset = inst_num;\n\tfor (i = 0; i < usize; i++)\n\t\tmicro_inst[inst_num++] = inst_arr[i];\n\tINSERT_IMMED_GPRA_CONST(micro_inst[fixup_offset], (addr));\n\tfixup_offset++;\n\tINSERT_IMMED_GPRA_CONST(micro_inst[fixup_offset], 0);\n\tfixup_offset++;\n\tINSERT_IMMED_GPRB_CONST(micro_inst[fixup_offset], (cur_value >> 0));\n\tfixup_offset++;\n\tINSERT_IMMED_GPRB_CONST(micro_inst[fixup_offset], (cur_value >> 0x10));\n\n\treturn inst_num - orig_num;\n}\n\nstatic int qat_hal_exec_micro_init_lm(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t      unsigned char ae, unsigned char ctx,\n\t\t\t\t      int *pfirst_exec, u64 *micro_inst,\n\t\t\t\t      unsigned int inst_num)\n{\n\tint stat = 0;\n\tunsigned int gpra0 = 0, gpra1 = 0, gpra2 = 0;\n\tunsigned int gprb0 = 0, gprb1 = 0;\n\n\tif (*pfirst_exec) {\n\t\tqat_hal_rd_rel_reg(handle, ae, ctx, ICP_GPA_REL, 0, &gpra0);\n\t\tqat_hal_rd_rel_reg(handle, ae, ctx, ICP_GPA_REL, 0x1, &gpra1);\n\t\tqat_hal_rd_rel_reg(handle, ae, ctx, ICP_GPA_REL, 0x2, &gpra2);\n\t\tqat_hal_rd_rel_reg(handle, ae, ctx, ICP_GPB_REL, 0, &gprb0);\n\t\tqat_hal_rd_rel_reg(handle, ae, ctx, ICP_GPB_REL, 0x1, &gprb1);\n\t\t*pfirst_exec = 0;\n\t}\n\tstat = qat_hal_exec_micro_inst(handle, ae, ctx, micro_inst, inst_num, 1,\n\t\t\t\t       inst_num * 0x5, NULL);\n\tif (stat != 0)\n\t\treturn -EFAULT;\n\tqat_hal_wr_rel_reg(handle, ae, ctx, ICP_GPA_REL, 0, gpra0);\n\tqat_hal_wr_rel_reg(handle, ae, ctx, ICP_GPA_REL, 0x1, gpra1);\n\tqat_hal_wr_rel_reg(handle, ae, ctx, ICP_GPA_REL, 0x2, gpra2);\n\tqat_hal_wr_rel_reg(handle, ae, ctx, ICP_GPB_REL, 0, gprb0);\n\tqat_hal_wr_rel_reg(handle, ae, ctx, ICP_GPB_REL, 0x1, gprb1);\n\n\treturn 0;\n}\n\nint qat_hal_batch_wr_lm(struct icp_qat_fw_loader_handle *handle,\n\t\t\tunsigned char ae,\n\t\t\tstruct icp_qat_uof_batch_init *lm_init_header)\n{\n\tstruct icp_qat_uof_batch_init *plm_init;\n\tu64 *micro_inst_arry;\n\tint micro_inst_num;\n\tint alloc_inst_size;\n\tint first_exec = 1;\n\tint stat = 0;\n\n\tplm_init = lm_init_header->next;\n\talloc_inst_size = lm_init_header->size;\n\tif ((unsigned int)alloc_inst_size > handle->hal_handle->max_ustore)\n\t\talloc_inst_size = handle->hal_handle->max_ustore;\n\tmicro_inst_arry = kmalloc_array(alloc_inst_size, sizeof(u64),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!micro_inst_arry)\n\t\treturn -ENOMEM;\n\tmicro_inst_num = 0;\n\twhile (plm_init) {\n\t\tunsigned int addr, *value, size;\n\n\t\tae = plm_init->ae;\n\t\taddr = plm_init->addr;\n\t\tvalue = plm_init->value;\n\t\tsize = plm_init->size;\n\t\tmicro_inst_num += qat_hal_concat_micro_code(micro_inst_arry,\n\t\t\t\t\t\t\t    micro_inst_num,\n\t\t\t\t\t\t\t    size, addr, value);\n\t\tplm_init = plm_init->next;\n\t}\n\t \n\tif (micro_inst_arry && micro_inst_num > 0) {\n\t\tmicro_inst_arry[micro_inst_num++] = 0x0E000010000ull;\n\t\tstat = qat_hal_exec_micro_init_lm(handle, ae, 0, &first_exec,\n\t\t\t\t\t\t  micro_inst_arry,\n\t\t\t\t\t\t  micro_inst_num);\n\t}\n\tkfree(micro_inst_arry);\n\treturn stat;\n}\n\nstatic int qat_hal_put_rel_rd_xfer(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t   unsigned char ae, unsigned char ctx,\n\t\t\t\t   enum icp_qat_uof_regtype reg_type,\n\t\t\t\t   unsigned short reg_num, unsigned int val)\n{\n\tint status = 0;\n\tunsigned int reg_addr;\n\tunsigned int ctx_enables;\n\tunsigned short mask;\n\tunsigned short dr_offset = 0x10;\n\n\tctx_enables = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\tif (CE_INUSE_CONTEXTS & ctx_enables) {\n\t\tif (ctx & 0x1) {\n\t\t\tpr_err(\"QAT: bad 4-ctx mode,ctx=0x%x\\n\", ctx);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmask = 0x1f;\n\t\tdr_offset = 0x20;\n\t} else {\n\t\tmask = 0x0f;\n\t}\n\tif (reg_num & ~mask)\n\t\treturn -EINVAL;\n\treg_addr = reg_num + (ctx << 0x5);\n\tswitch (reg_type) {\n\tcase ICP_SR_RD_REL:\n\tcase ICP_SR_REL:\n\t\tSET_AE_XFER(handle, ae, reg_addr, val);\n\t\tbreak;\n\tcase ICP_DR_RD_REL:\n\tcase ICP_DR_REL:\n\t\tSET_AE_XFER(handle, ae, (reg_addr + dr_offset), val);\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tbreak;\n\t}\n\treturn status;\n}\n\nstatic int qat_hal_put_rel_wr_xfer(struct icp_qat_fw_loader_handle *handle,\n\t\t\t\t   unsigned char ae, unsigned char ctx,\n\t\t\t\t   enum icp_qat_uof_regtype reg_type,\n\t\t\t\t   unsigned short reg_num, unsigned int data)\n{\n\tunsigned int gprval, ctx_enables;\n\tunsigned short src_hiaddr, src_lowaddr, gpr_addr, xfr_addr, data16hi,\n\t    data16low;\n\tunsigned short reg_mask;\n\tint status = 0;\n\tu64 micro_inst[] = {\n\t\t0x0F440000000ull,\n\t\t0x0F040000000ull,\n\t\t0x0A000000000ull,\n\t\t0x0F0000C0300ull,\n\t\t0x0E000010000ull\n\t};\n\tconst int num_inst = ARRAY_SIZE(micro_inst), code_off = 1;\n\tconst unsigned short gprnum = 0, dly = num_inst * 0x5;\n\n\tctx_enables = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\tif (CE_INUSE_CONTEXTS & ctx_enables) {\n\t\tif (ctx & 0x1) {\n\t\t\tpr_err(\"QAT: 4-ctx mode,ctx=0x%x\\n\", ctx);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treg_mask = (unsigned short)~0x1f;\n\t} else {\n\t\treg_mask = (unsigned short)~0xf;\n\t}\n\tif (reg_num & reg_mask)\n\t\treturn -EINVAL;\n\txfr_addr = qat_hal_get_reg_addr(reg_type, reg_num);\n\tif (xfr_addr == BAD_REGADDR) {\n\t\tpr_err(\"QAT: bad xfrAddr=0x%x\\n\", xfr_addr);\n\t\treturn -EINVAL;\n\t}\n\tstatus = qat_hal_rd_rel_reg(handle, ae, ctx, ICP_GPB_REL, gprnum, &gprval);\n\tif (status) {\n\t\tpr_err(\"QAT: failed to read register\");\n\t\treturn status;\n\t}\n\tgpr_addr = qat_hal_get_reg_addr(ICP_GPB_REL, gprnum);\n\tdata16low = 0xffff & data;\n\tdata16hi = 0xffff & (data >> 0x10);\n\tsrc_hiaddr = qat_hal_get_reg_addr(ICP_NO_DEST,\n\t\t\t\t\t  (unsigned short)(0xff & data16hi));\n\tsrc_lowaddr = qat_hal_get_reg_addr(ICP_NO_DEST,\n\t\t\t\t\t   (unsigned short)(0xff & data16low));\n\tmicro_inst[0] = micro_inst[0x0] | ((data16hi >> 8) << 20) |\n\t    ((gpr_addr & 0x3ff) << 10) | (src_hiaddr & 0x3ff);\n\tmicro_inst[1] = micro_inst[0x1] | ((data16low >> 8) << 20) |\n\t    ((gpr_addr & 0x3ff) << 10) | (src_lowaddr & 0x3ff);\n\tmicro_inst[0x2] = micro_inst[0x2] |\n\t    ((xfr_addr & 0x3ff) << 20) | ((gpr_addr & 0x3ff) << 10);\n\tstatus = qat_hal_exec_micro_inst(handle, ae, ctx, micro_inst, num_inst,\n\t\t\t\t\t code_off, dly, NULL);\n\tqat_hal_wr_rel_reg(handle, ae, ctx, ICP_GPB_REL, gprnum, gprval);\n\treturn status;\n}\n\nstatic int qat_hal_put_rel_nn(struct icp_qat_fw_loader_handle *handle,\n\t\t\t      unsigned char ae, unsigned char ctx,\n\t\t\t      unsigned short nn, unsigned int val)\n{\n\tunsigned int ctx_enables;\n\tint stat = 0;\n\n\tctx_enables = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\tctx_enables &= IGNORE_W1C_MASK;\n\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx_enables | CE_NN_MODE);\n\n\tstat = qat_hal_put_rel_wr_xfer(handle, ae, ctx, ICP_NEIGH_REL, nn, val);\n\tqat_hal_wr_ae_csr(handle, ae, CTX_ENABLES, ctx_enables);\n\treturn stat;\n}\n\nstatic int qat_hal_convert_abs_to_rel(struct icp_qat_fw_loader_handle\n\t\t\t\t      *handle, unsigned char ae,\n\t\t\t\t      unsigned short absreg_num,\n\t\t\t\t      unsigned short *relreg,\n\t\t\t\t      unsigned char *ctx)\n{\n\tunsigned int ctx_enables;\n\n\tctx_enables = qat_hal_rd_ae_csr(handle, ae, CTX_ENABLES);\n\tif (ctx_enables & CE_INUSE_CONTEXTS) {\n\t\t \n\t\t*relreg = absreg_num & 0x1F;\n\t\t*ctx = (absreg_num >> 0x4) & 0x6;\n\t} else {\n\t\t \n\t\t*relreg = absreg_num & 0x0F;\n\t\t*ctx = (absreg_num >> 0x4) & 0x7;\n\t}\n\treturn 0;\n}\n\nint qat_hal_init_gpr(struct icp_qat_fw_loader_handle *handle,\n\t\t     unsigned char ae, unsigned long ctx_mask,\n\t\t     enum icp_qat_uof_regtype reg_type,\n\t\t     unsigned short reg_num, unsigned int regdata)\n{\n\tint stat = 0;\n\tunsigned short reg;\n\tunsigned char ctx = 0;\n\tenum icp_qat_uof_regtype type;\n\n\tif (reg_num >= ICP_QAT_UCLO_MAX_GPR_REG)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tif (ctx_mask == 0) {\n\t\t\tqat_hal_convert_abs_to_rel(handle, ae, reg_num, &reg,\n\t\t\t\t\t\t   &ctx);\n\t\t\ttype = reg_type - 1;\n\t\t} else {\n\t\t\treg = reg_num;\n\t\t\ttype = reg_type;\n\t\t\tif (!test_bit(ctx, &ctx_mask))\n\t\t\t\tcontinue;\n\t\t}\n\t\tstat = qat_hal_wr_rel_reg(handle, ae, ctx, type, reg, regdata);\n\t\tif (stat) {\n\t\t\tpr_err(\"QAT: write gpr fail\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} while (ctx_mask && (ctx++ < ICP_QAT_UCLO_MAX_CTX));\n\n\treturn 0;\n}\n\nint qat_hal_init_wr_xfer(struct icp_qat_fw_loader_handle *handle,\n\t\t\t unsigned char ae, unsigned long ctx_mask,\n\t\t\t enum icp_qat_uof_regtype reg_type,\n\t\t\t unsigned short reg_num, unsigned int regdata)\n{\n\tint stat = 0;\n\tunsigned short reg;\n\tunsigned char ctx = 0;\n\tenum icp_qat_uof_regtype type;\n\n\tif (reg_num >= ICP_QAT_UCLO_MAX_XFER_REG)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tif (ctx_mask == 0) {\n\t\t\tqat_hal_convert_abs_to_rel(handle, ae, reg_num, &reg,\n\t\t\t\t\t\t   &ctx);\n\t\t\ttype = reg_type - 3;\n\t\t} else {\n\t\t\treg = reg_num;\n\t\t\ttype = reg_type;\n\t\t\tif (!test_bit(ctx, &ctx_mask))\n\t\t\t\tcontinue;\n\t\t}\n\t\tstat = qat_hal_put_rel_wr_xfer(handle, ae, ctx, type, reg,\n\t\t\t\t\t       regdata);\n\t\tif (stat) {\n\t\t\tpr_err(\"QAT: write wr xfer fail\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} while (ctx_mask && (ctx++ < ICP_QAT_UCLO_MAX_CTX));\n\n\treturn 0;\n}\n\nint qat_hal_init_rd_xfer(struct icp_qat_fw_loader_handle *handle,\n\t\t\t unsigned char ae, unsigned long ctx_mask,\n\t\t\t enum icp_qat_uof_regtype reg_type,\n\t\t\t unsigned short reg_num, unsigned int regdata)\n{\n\tint stat = 0;\n\tunsigned short reg;\n\tunsigned char ctx = 0;\n\tenum icp_qat_uof_regtype type;\n\n\tif (reg_num >= ICP_QAT_UCLO_MAX_XFER_REG)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tif (ctx_mask == 0) {\n\t\t\tqat_hal_convert_abs_to_rel(handle, ae, reg_num, &reg,\n\t\t\t\t\t\t   &ctx);\n\t\t\ttype = reg_type - 3;\n\t\t} else {\n\t\t\treg = reg_num;\n\t\t\ttype = reg_type;\n\t\t\tif (!test_bit(ctx, &ctx_mask))\n\t\t\t\tcontinue;\n\t\t}\n\t\tstat = qat_hal_put_rel_rd_xfer(handle, ae, ctx, type, reg,\n\t\t\t\t\t       regdata);\n\t\tif (stat) {\n\t\t\tpr_err(\"QAT: write rd xfer fail\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} while (ctx_mask && (ctx++ < ICP_QAT_UCLO_MAX_CTX));\n\n\treturn 0;\n}\n\nint qat_hal_init_nn(struct icp_qat_fw_loader_handle *handle,\n\t\t    unsigned char ae, unsigned long ctx_mask,\n\t\t    unsigned short reg_num, unsigned int regdata)\n{\n\tint stat = 0;\n\tunsigned char ctx;\n\tif (!handle->chip_info->nn) {\n\t\tdev_err(&handle->pci_dev->dev, \"QAT: No next neigh in 0x%x\\n\",\n\t\t\thandle->pci_dev->device);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx_mask == 0)\n\t\treturn -EINVAL;\n\n\tfor (ctx = 0; ctx < ICP_QAT_UCLO_MAX_CTX; ctx++) {\n\t\tif (!test_bit(ctx, &ctx_mask))\n\t\t\tcontinue;\n\t\tstat = qat_hal_put_rel_nn(handle, ae, ctx, reg_num, regdata);\n\t\tif (stat) {\n\t\t\tpr_err(\"QAT: write neigh error\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}