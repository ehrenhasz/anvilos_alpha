{
  "module_name": "adf_pfvf_vf_proto.c",
  "hash_id": "5f1bb496ffe7e517a64d53dc486416670545a4ed74660fa3ccf16f2452c183e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_pfvf_vf_proto.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/completion.h>\n#include <linux/minmax.h>\n#include <linux/types.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_common_drv.h\"\n#include \"adf_pfvf_msg.h\"\n#include \"adf_pfvf_utils.h\"\n#include \"adf_pfvf_vf_msg.h\"\n#include \"adf_pfvf_vf_proto.h\"\n\n#define ADF_PFVF_MSG_COLLISION_DETECT_DELAY\t10\n#define ADF_PFVF_MSG_ACK_DELAY\t\t\t2\n#define ADF_PFVF_MSG_ACK_MAX_RETRY\t\t100\n\n \n#define ADF_PFVF_MSG_RESP_RETRIES\t5\n#define ADF_PFVF_MSG_RESP_TIMEOUT\t(ADF_PFVF_MSG_ACK_DELAY * \\\n\t\t\t\t\t ADF_PFVF_MSG_ACK_MAX_RETRY + \\\n\t\t\t\t\t ADF_PFVF_MSG_COLLISION_DETECT_DELAY)\n\n \nint adf_send_vf2pf_msg(struct adf_accel_dev *accel_dev, struct pfvf_message msg)\n{\n\tstruct adf_pfvf_ops *pfvf_ops = GET_PFVF_OPS(accel_dev);\n\tu32 pfvf_offset = pfvf_ops->get_vf2pf_offset(0);\n\n\treturn pfvf_ops->send_msg(accel_dev, msg, pfvf_offset,\n\t\t\t\t  &accel_dev->vf.vf2pf_lock);\n}\n\n \nstatic struct pfvf_message adf_recv_pf2vf_msg(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_pfvf_ops *pfvf_ops = GET_PFVF_OPS(accel_dev);\n\tu32 pfvf_offset = pfvf_ops->get_pf2vf_offset(0);\n\n\treturn pfvf_ops->recv_msg(accel_dev, pfvf_offset, accel_dev->vf.pf_compat_ver);\n}\n\n \nint adf_send_vf2pf_req(struct adf_accel_dev *accel_dev, struct pfvf_message msg,\n\t\t       struct pfvf_message *resp)\n{\n\tunsigned long timeout = msecs_to_jiffies(ADF_PFVF_MSG_RESP_TIMEOUT);\n\tunsigned int retries = ADF_PFVF_MSG_RESP_RETRIES;\n\tint ret;\n\n\treinit_completion(&accel_dev->vf.msg_received);\n\n\t \n\tdo {\n\t\tret = adf_send_vf2pf_msg(accel_dev, msg);\n\t\tif (ret) {\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"Failed to send request msg to PF\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = wait_for_completion_timeout(&accel_dev->vf.msg_received,\n\t\t\t\t\t\t  timeout);\n\t\tif (ret) {\n\t\t\tif (likely(resp))\n\t\t\t\t*resp = accel_dev->vf.response;\n\n\t\t\t \n\t\t\taccel_dev->vf.response.type = 0;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tdev_err(&GET_DEV(accel_dev), \"PFVF response message timeout\\n\");\n\t} while (--retries);\n\n\treturn -EIO;\n}\n\nstatic int adf_vf2pf_blkmsg_data_req(struct adf_accel_dev *accel_dev, bool crc,\n\t\t\t\t     u8 *type, u8 *data)\n{\n\tstruct pfvf_message req = { 0 };\n\tstruct pfvf_message resp = { 0 };\n\tu8 blk_type;\n\tu8 blk_byte;\n\tu8 msg_type;\n\tu8 max_data;\n\tint err;\n\n\t \n\tif (*type <= ADF_VF2PF_SMALL_BLOCK_TYPE_MAX) {\n\t\tmsg_type = ADF_VF2PF_MSGTYPE_SMALL_BLOCK_REQ;\n\t\tblk_type = FIELD_PREP(ADF_VF2PF_SMALL_BLOCK_TYPE_MASK, *type);\n\t\tblk_byte = FIELD_PREP(ADF_VF2PF_SMALL_BLOCK_BYTE_MASK, *data);\n\t\tmax_data = ADF_VF2PF_SMALL_BLOCK_BYTE_MAX;\n\t} else if (*type <= ADF_VF2PF_MEDIUM_BLOCK_TYPE_MAX) {\n\t\tmsg_type = ADF_VF2PF_MSGTYPE_MEDIUM_BLOCK_REQ;\n\t\tblk_type = FIELD_PREP(ADF_VF2PF_MEDIUM_BLOCK_TYPE_MASK,\n\t\t\t\t      *type - ADF_VF2PF_SMALL_BLOCK_TYPE_MAX);\n\t\tblk_byte = FIELD_PREP(ADF_VF2PF_MEDIUM_BLOCK_BYTE_MASK, *data);\n\t\tmax_data = ADF_VF2PF_MEDIUM_BLOCK_BYTE_MAX;\n\t} else if (*type <= ADF_VF2PF_LARGE_BLOCK_TYPE_MAX) {\n\t\tmsg_type = ADF_VF2PF_MSGTYPE_LARGE_BLOCK_REQ;\n\t\tblk_type = FIELD_PREP(ADF_VF2PF_LARGE_BLOCK_TYPE_MASK,\n\t\t\t\t      *type - ADF_VF2PF_MEDIUM_BLOCK_TYPE_MAX);\n\t\tblk_byte = FIELD_PREP(ADF_VF2PF_LARGE_BLOCK_BYTE_MASK, *data);\n\t\tmax_data = ADF_VF2PF_LARGE_BLOCK_BYTE_MAX;\n\t} else {\n\t\tdev_err(&GET_DEV(accel_dev), \"Invalid message type %u\\n\", *type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (*data > max_data) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Invalid byte %s %u for message type %u\\n\",\n\t\t\tcrc ? \"count\" : \"index\", *data, *type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treq.type = msg_type;\n\treq.data = blk_type | blk_byte | FIELD_PREP(ADF_VF2PF_BLOCK_CRC_REQ_MASK, crc);\n\n\terr = adf_send_vf2pf_req(accel_dev, req, &resp);\n\tif (err)\n\t\treturn err;\n\n\t*type = FIELD_GET(ADF_PF2VF_BLKMSG_RESP_TYPE_MASK, resp.data);\n\t*data = FIELD_GET(ADF_PF2VF_BLKMSG_RESP_DATA_MASK, resp.data);\n\n\treturn 0;\n}\n\nstatic int adf_vf2pf_blkmsg_get_byte(struct adf_accel_dev *accel_dev, u8 type,\n\t\t\t\t     u8 index, u8 *data)\n{\n\tint ret;\n\n\tret = adf_vf2pf_blkmsg_data_req(accel_dev, false, &type, &index);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (unlikely(type != ADF_PF2VF_BLKMSG_RESP_TYPE_DATA)) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Unexpected BLKMSG response type %u, byte 0x%x\\n\",\n\t\t\ttype, index);\n\t\treturn -EFAULT;\n\t}\n\n\t*data = index;\n\treturn 0;\n}\n\nstatic int adf_vf2pf_blkmsg_get_crc(struct adf_accel_dev *accel_dev, u8 type,\n\t\t\t\t    u8 bytes, u8 *crc)\n{\n\tint ret;\n\n\t \n\t--bytes;\n\n\tret = adf_vf2pf_blkmsg_data_req(accel_dev, true, &type, &bytes);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (unlikely(type != ADF_PF2VF_BLKMSG_RESP_TYPE_CRC)) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Unexpected CRC BLKMSG response type %u, crc 0x%x\\n\",\n\t\t\ttype, bytes);\n\t\treturn  -EFAULT;\n\t}\n\n\t*crc = bytes;\n\treturn 0;\n}\n\n \nint adf_send_vf2pf_blkmsg_req(struct adf_accel_dev *accel_dev, u8 type,\n\t\t\t      u8 *buffer, unsigned int *buffer_len)\n{\n\tunsigned int index;\n\tunsigned int msg_len;\n\tint ret;\n\tu8 remote_crc;\n\tu8 local_crc;\n\n\tif (unlikely(type > ADF_VF2PF_LARGE_BLOCK_TYPE_MAX)) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Invalid block message type %d\\n\",\n\t\t\ttype);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(*buffer_len < ADF_PFVF_BLKMSG_HEADER_SIZE)) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Buffer size too small for a block message\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adf_vf2pf_blkmsg_get_byte(accel_dev, type,\n\t\t\t\t\tADF_PFVF_BLKMSG_VER_BYTE,\n\t\t\t\t\t&buffer[ADF_PFVF_BLKMSG_VER_BYTE]);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tif (unlikely(!buffer[ADF_PFVF_BLKMSG_VER_BYTE])) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Invalid version 0 received for block request %u\", type);\n\t\treturn -EFAULT;\n\t}\n\n\tret = adf_vf2pf_blkmsg_get_byte(accel_dev, type,\n\t\t\t\t\tADF_PFVF_BLKMSG_LEN_BYTE,\n\t\t\t\t\t&buffer[ADF_PFVF_BLKMSG_LEN_BYTE]);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tif (unlikely(!buffer[ADF_PFVF_BLKMSG_LEN_BYTE])) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Invalid size 0 received for block request %u\", type);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tmsg_len = ADF_PFVF_BLKMSG_HEADER_SIZE + buffer[ADF_PFVF_BLKMSG_LEN_BYTE];\n\tmsg_len = min(*buffer_len, msg_len);\n\n\t \n\tfor (index = ADF_PFVF_BLKMSG_HEADER_SIZE; index < msg_len; index++) {\n\t\tret = adf_vf2pf_blkmsg_get_byte(accel_dev, type, index,\n\t\t\t\t\t\t&buffer[index]);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = adf_vf2pf_blkmsg_get_crc(accel_dev, type, msg_len, &remote_crc);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tlocal_crc = adf_pfvf_calc_blkmsg_crc(buffer, msg_len);\n\tif (unlikely(local_crc != remote_crc)) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"CRC error on msg type %d. Local %02X, remote %02X\\n\",\n\t\t\ttype, local_crc, remote_crc);\n\t\treturn -EIO;\n\t}\n\n\t*buffer_len = msg_len;\n\treturn 0;\n}\n\nstatic bool adf_handle_pf2vf_msg(struct adf_accel_dev *accel_dev,\n\t\t\t\t struct pfvf_message msg)\n{\n\tswitch (msg.type) {\n\tcase ADF_PF2VF_MSGTYPE_RESTARTING:\n\t\tdev_dbg(&GET_DEV(accel_dev), \"Restarting message received from PF\\n\");\n\n\t\tadf_pf2vf_handle_pf_restarting(accel_dev);\n\t\treturn false;\n\tcase ADF_PF2VF_MSGTYPE_VERSION_RESP:\n\tcase ADF_PF2VF_MSGTYPE_BLKMSG_RESP:\n\tcase ADF_PF2VF_MSGTYPE_RP_RESET_RESP:\n\t\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\t\"Response Message received from PF (type 0x%.4x, data 0x%.4x)\\n\",\n\t\t\tmsg.type, msg.data);\n\t\taccel_dev->vf.response = msg;\n\t\tcomplete(&accel_dev->vf.msg_received);\n\t\treturn true;\n\tdefault:\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Unknown message from PF (type 0x%.4x, data: 0x%.4x)\\n\",\n\t\t\tmsg.type, msg.data);\n\t}\n\n\treturn false;\n}\n\nbool adf_recv_and_handle_pf2vf_msg(struct adf_accel_dev *accel_dev)\n{\n\tstruct pfvf_message msg;\n\n\tmsg = adf_recv_pf2vf_msg(accel_dev);\n\tif (msg.type)   \n\t\treturn adf_handle_pf2vf_msg(accel_dev, msg);\n\n\t \n\n\treturn true;\n}\n\n \nint adf_enable_vf2pf_comms(struct adf_accel_dev *accel_dev)\n{\n\tint ret;\n\n\tadf_pfvf_crc_init();\n\tadf_enable_pf2vf_interrupts(accel_dev);\n\n\tret = adf_vf2pf_request_version(accel_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adf_vf2pf_get_capabilities(accel_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adf_vf2pf_get_ring_to_svc(accel_dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(adf_enable_vf2pf_comms);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}