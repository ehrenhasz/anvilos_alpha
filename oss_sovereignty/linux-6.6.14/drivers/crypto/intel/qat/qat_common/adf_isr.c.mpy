{
  "module_name": "adf_isr.c",
  "hash_id": "517fb230984186aa9297a29e8e4550b268ccb0787c20c9be69977ef60dd85292",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_isr.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_common_drv.h\"\n#include \"adf_cfg.h\"\n#include \"adf_cfg_strings.h\"\n#include \"adf_cfg_common.h\"\n#include \"adf_transport_access_macros.h\"\n#include \"adf_transport_internal.h\"\n\n#define ADF_MAX_NUM_VFS\t32\nstatic struct workqueue_struct *adf_misc_wq;\n\nstatic int adf_enable_msix(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_accel_pci *pci_dev_info = &accel_dev->accel_pci_dev;\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tu32 msix_num_entries = hw_data->num_banks + 1;\n\tint ret;\n\n\tif (hw_data->set_msix_rttable)\n\t\thw_data->set_msix_rttable(accel_dev);\n\n\tret = pci_alloc_irq_vectors(pci_dev_info->pci_dev, msix_num_entries,\n\t\t\t\t    msix_num_entries, PCI_IRQ_MSIX);\n\tif (unlikely(ret < 0)) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Failed to allocate %d MSI-X vectors\\n\",\n\t\t\tmsix_num_entries);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void adf_disable_msix(struct adf_accel_pci *pci_dev_info)\n{\n\tpci_free_irq_vectors(pci_dev_info->pci_dev);\n}\n\nstatic irqreturn_t adf_msix_isr_bundle(int irq, void *bank_ptr)\n{\n\tstruct adf_etr_bank_data *bank = bank_ptr;\n\tstruct adf_hw_csr_ops *csr_ops = GET_CSR_OPS(bank->accel_dev);\n\n\tcsr_ops->write_csr_int_flag_and_col(bank->csr_addr, bank->bank_number,\n\t\t\t\t\t    0);\n\ttasklet_hi_schedule(&bank->resp_handler);\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_PCI_IOV\nvoid adf_enable_vf2pf_interrupts(struct adf_accel_dev *accel_dev, u32 vf_mask)\n{\n\tvoid __iomem *pmisc_addr = adf_get_pmisc_base(accel_dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&accel_dev->pf.vf2pf_ints_lock, flags);\n\tGET_PFVF_OPS(accel_dev)->enable_vf2pf_interrupts(pmisc_addr, vf_mask);\n\tspin_unlock_irqrestore(&accel_dev->pf.vf2pf_ints_lock, flags);\n}\n\nvoid adf_disable_all_vf2pf_interrupts(struct adf_accel_dev *accel_dev)\n{\n\tvoid __iomem *pmisc_addr = adf_get_pmisc_base(accel_dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&accel_dev->pf.vf2pf_ints_lock, flags);\n\tGET_PFVF_OPS(accel_dev)->disable_all_vf2pf_interrupts(pmisc_addr);\n\tspin_unlock_irqrestore(&accel_dev->pf.vf2pf_ints_lock, flags);\n}\n\nstatic u32 adf_disable_pending_vf2pf_interrupts(struct adf_accel_dev *accel_dev)\n{\n\tvoid __iomem *pmisc_addr = adf_get_pmisc_base(accel_dev);\n\tu32 pending;\n\n\tspin_lock(&accel_dev->pf.vf2pf_ints_lock);\n\tpending = GET_PFVF_OPS(accel_dev)->disable_pending_vf2pf_interrupts(pmisc_addr);\n\tspin_unlock(&accel_dev->pf.vf2pf_ints_lock);\n\n\treturn pending;\n}\n\nstatic bool adf_handle_vf2pf_int(struct adf_accel_dev *accel_dev)\n{\n\tbool irq_handled = false;\n\tunsigned long vf_mask;\n\n\t \n\tvf_mask = adf_disable_pending_vf2pf_interrupts(accel_dev);\n\tif (vf_mask) {\n\t\tstruct adf_accel_vf_info *vf_info;\n\t\tint i;\n\n\t\t \n\t\tfor_each_set_bit(i, &vf_mask, ADF_MAX_NUM_VFS) {\n\t\t\tvf_info = accel_dev->pf.vf_info + i;\n\n\t\t\tif (!__ratelimit(&vf_info->vf2pf_ratelimit)) {\n\t\t\t\tdev_info(&GET_DEV(accel_dev),\n\t\t\t\t\t \"Too many ints from VF%d\\n\",\n\t\t\t\t\t  vf_info->vf_nr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tadf_schedule_vf2pf_handler(vf_info);\n\t\t\tirq_handled = true;\n\t\t}\n\t}\n\treturn irq_handled;\n}\n#endif  \n\nstatic bool adf_handle_pm_int(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\n\tif (hw_data->handle_pm_interrupt &&\n\t    hw_data->handle_pm_interrupt(accel_dev))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic irqreturn_t adf_msix_isr_ae(int irq, void *dev_ptr)\n{\n\tstruct adf_accel_dev *accel_dev = dev_ptr;\n\n#ifdef CONFIG_PCI_IOV\n\t \n\tif (accel_dev->pf.vf_info && adf_handle_vf2pf_int(accel_dev))\n\t\treturn IRQ_HANDLED;\n#endif  \n\n\tif (adf_handle_pm_int(accel_dev))\n\t\treturn IRQ_HANDLED;\n\n\tdev_dbg(&GET_DEV(accel_dev), \"qat_dev%d spurious AE interrupt\\n\",\n\t\taccel_dev->accel_id);\n\n\treturn IRQ_NONE;\n}\n\nstatic void adf_free_irqs(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_accel_pci *pci_dev_info = &accel_dev->accel_pci_dev;\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tstruct adf_irq *irqs = pci_dev_info->msix_entries.irqs;\n\tstruct adf_etr_data *etr_data = accel_dev->transport;\n\tint clust_irq = hw_data->num_banks;\n\tint irq, i = 0;\n\n\tif (pci_dev_info->msix_entries.num_entries > 1) {\n\t\tfor (i = 0; i < hw_data->num_banks; i++) {\n\t\t\tif (irqs[i].enabled) {\n\t\t\t\tirq = pci_irq_vector(pci_dev_info->pci_dev, i);\n\t\t\t\tirq_set_affinity_hint(irq, NULL);\n\t\t\t\tfree_irq(irq, &etr_data->banks[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (irqs[i].enabled) {\n\t\tirq = pci_irq_vector(pci_dev_info->pci_dev, clust_irq);\n\t\tfree_irq(irq, accel_dev);\n\t}\n}\n\nstatic int adf_request_irqs(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_accel_pci *pci_dev_info = &accel_dev->accel_pci_dev;\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tstruct adf_irq *irqs = pci_dev_info->msix_entries.irqs;\n\tstruct adf_etr_data *etr_data = accel_dev->transport;\n\tint clust_irq = hw_data->num_banks;\n\tint ret, irq, i = 0;\n\tchar *name;\n\n\t \n\tif (!accel_dev->pf.vf_info) {\n\t\tfor (i = 0; i < hw_data->num_banks; i++) {\n\t\t\tstruct adf_etr_bank_data *bank = &etr_data->banks[i];\n\t\t\tunsigned int cpu, cpus = num_online_cpus();\n\n\t\t\tname = irqs[i].name;\n\t\t\tsnprintf(name, ADF_MAX_MSIX_VECTOR_NAME,\n\t\t\t\t \"qat%d-bundle%d\", accel_dev->accel_id, i);\n\t\t\tirq = pci_irq_vector(pci_dev_info->pci_dev, i);\n\t\t\tif (unlikely(irq < 0)) {\n\t\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\t\"Failed to get IRQ number of device vector %d - %s\\n\",\n\t\t\t\t\ti, name);\n\t\t\t\tret = irq;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tret = request_irq(irq, adf_msix_isr_bundle, 0,\n\t\t\t\t\t  &name[0], bank);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\t\"Failed to allocate IRQ %d for %s\\n\",\n\t\t\t\t\tirq, name);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tcpu = ((accel_dev->accel_id * hw_data->num_banks) +\n\t\t\t       i) % cpus;\n\t\t\tirq_set_affinity_hint(irq, get_cpu_mask(cpu));\n\t\t\tirqs[i].enabled = true;\n\t\t}\n\t}\n\n\t \n\tname = irqs[i].name;\n\tsnprintf(name, ADF_MAX_MSIX_VECTOR_NAME,\n\t\t \"qat%d-ae-cluster\", accel_dev->accel_id);\n\tirq = pci_irq_vector(pci_dev_info->pci_dev, clust_irq);\n\tif (unlikely(irq < 0)) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Failed to get IRQ number of device vector %d - %s\\n\",\n\t\t\ti, name);\n\t\tret = irq;\n\t\tgoto err;\n\t}\n\tret = request_irq(irq, adf_msix_isr_ae, 0, &name[0], accel_dev);\n\tif (ret) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Failed to allocate IRQ %d for %s\\n\", irq, name);\n\t\tgoto err;\n\t}\n\tirqs[i].enabled = true;\n\treturn ret;\nerr:\n\tadf_free_irqs(accel_dev);\n\treturn ret;\n}\n\nstatic int adf_isr_alloc_msix_vectors_data(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tu32 msix_num_entries = 1;\n\tstruct adf_irq *irqs;\n\n\t \n\tif (!accel_dev->pf.vf_info)\n\t\tmsix_num_entries += hw_data->num_banks;\n\n\tirqs = kzalloc_node(msix_num_entries * sizeof(*irqs),\n\t\t\t    GFP_KERNEL, dev_to_node(&GET_DEV(accel_dev)));\n\tif (!irqs)\n\t\treturn -ENOMEM;\n\n\taccel_dev->accel_pci_dev.msix_entries.num_entries = msix_num_entries;\n\taccel_dev->accel_pci_dev.msix_entries.irqs = irqs;\n\treturn 0;\n}\n\nstatic void adf_isr_free_msix_vectors_data(struct adf_accel_dev *accel_dev)\n{\n\tkfree(accel_dev->accel_pci_dev.msix_entries.irqs);\n\taccel_dev->accel_pci_dev.msix_entries.irqs = NULL;\n}\n\nstatic int adf_setup_bh(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_etr_data *priv_data = accel_dev->transport;\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tint i;\n\n\tfor (i = 0; i < hw_data->num_banks; i++)\n\t\ttasklet_init(&priv_data->banks[i].resp_handler,\n\t\t\t     adf_response_handler,\n\t\t\t     (unsigned long)&priv_data->banks[i]);\n\treturn 0;\n}\n\nstatic void adf_cleanup_bh(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_etr_data *priv_data = accel_dev->transport;\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tint i;\n\n\tfor (i = 0; i < hw_data->num_banks; i++) {\n\t\ttasklet_disable(&priv_data->banks[i].resp_handler);\n\t\ttasklet_kill(&priv_data->banks[i].resp_handler);\n\t}\n}\n\n \nvoid adf_isr_resource_free(struct adf_accel_dev *accel_dev)\n{\n\tadf_free_irqs(accel_dev);\n\tadf_cleanup_bh(accel_dev);\n\tadf_disable_msix(&accel_dev->accel_pci_dev);\n\tadf_isr_free_msix_vectors_data(accel_dev);\n}\nEXPORT_SYMBOL_GPL(adf_isr_resource_free);\n\n \nint adf_isr_resource_alloc(struct adf_accel_dev *accel_dev)\n{\n\tint ret;\n\n\tret = adf_isr_alloc_msix_vectors_data(accel_dev);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = adf_enable_msix(accel_dev);\n\tif (ret)\n\t\tgoto err_free_msix_table;\n\n\tret = adf_setup_bh(accel_dev);\n\tif (ret)\n\t\tgoto err_disable_msix;\n\n\tret = adf_request_irqs(accel_dev);\n\tif (ret)\n\t\tgoto err_cleanup_bh;\n\n\treturn 0;\n\nerr_cleanup_bh:\n\tadf_cleanup_bh(accel_dev);\n\nerr_disable_msix:\n\tadf_disable_msix(&accel_dev->accel_pci_dev);\n\nerr_free_msix_table:\n\tadf_isr_free_msix_vectors_data(accel_dev);\n\nerr_out:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(adf_isr_resource_alloc);\n\n \nint __init adf_init_misc_wq(void)\n{\n\tadf_misc_wq = alloc_workqueue(\"qat_misc_wq\", WQ_MEM_RECLAIM, 0);\n\n\treturn !adf_misc_wq ? -ENOMEM : 0;\n}\n\nvoid adf_exit_misc_wq(void)\n{\n\tif (adf_misc_wq)\n\t\tdestroy_workqueue(adf_misc_wq);\n\n\tadf_misc_wq = NULL;\n}\n\nbool adf_misc_wq_queue_work(struct work_struct *work)\n{\n\treturn queue_work(adf_misc_wq, work);\n}\n\nbool adf_misc_wq_queue_delayed_work(struct delayed_work *work,\n\t\t\t\t    unsigned long delay)\n{\n\treturn queue_delayed_work(adf_misc_wq, work, delay);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}