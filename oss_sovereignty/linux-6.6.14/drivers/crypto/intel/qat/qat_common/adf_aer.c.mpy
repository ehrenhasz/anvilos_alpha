{
  "module_name": "adf_aer.c",
  "hash_id": "3ab857513d4ec8e519df3899461eed5dc7edb55a95d96bd29b81b55eb405e0c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_aer.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/completion.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_common_drv.h\"\n\nstatic struct workqueue_struct *device_reset_wq;\n\nstatic pci_ers_result_t adf_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t   pci_channel_state_t state)\n{\n\tstruct adf_accel_dev *accel_dev = adf_devmgr_pci_to_accel_dev(pdev);\n\n\tdev_info(&pdev->dev, \"Acceleration driver hardware error detected.\\n\");\n\tif (!accel_dev) {\n\t\tdev_err(&pdev->dev, \"Can't find acceleration device\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\tif (state == pci_channel_io_perm_failure) {\n\t\tdev_err(&pdev->dev, \"Can't recover from device error\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstruct adf_reset_dev_data {\n\tint mode;\n\tstruct adf_accel_dev *accel_dev;\n\tstruct completion compl;\n\tstruct work_struct reset_work;\n};\n\nvoid adf_reset_sbr(struct adf_accel_dev *accel_dev)\n{\n\tstruct pci_dev *pdev = accel_to_pci_dev(accel_dev);\n\tstruct pci_dev *parent = pdev->bus->self;\n\tu16 bridge_ctl = 0;\n\n\tif (!parent)\n\t\tparent = pdev;\n\n\tif (!pci_wait_for_pending_transaction(pdev))\n\t\tdev_info(&GET_DEV(accel_dev),\n\t\t\t \"Transaction still in progress. Proceeding\\n\");\n\n\tdev_info(&GET_DEV(accel_dev), \"Secondary bus reset\\n\");\n\n\tpci_read_config_word(parent, PCI_BRIDGE_CONTROL, &bridge_ctl);\n\tbridge_ctl |= PCI_BRIDGE_CTL_BUS_RESET;\n\tpci_write_config_word(parent, PCI_BRIDGE_CONTROL, bridge_ctl);\n\tmsleep(100);\n\tbridge_ctl &= ~PCI_BRIDGE_CTL_BUS_RESET;\n\tpci_write_config_word(parent, PCI_BRIDGE_CONTROL, bridge_ctl);\n\tmsleep(100);\n}\nEXPORT_SYMBOL_GPL(adf_reset_sbr);\n\nvoid adf_reset_flr(struct adf_accel_dev *accel_dev)\n{\n\tpcie_flr(accel_to_pci_dev(accel_dev));\n}\nEXPORT_SYMBOL_GPL(adf_reset_flr);\n\nvoid adf_dev_restore(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_device = accel_dev->hw_device;\n\tstruct pci_dev *pdev = accel_to_pci_dev(accel_dev);\n\n\tif (hw_device->reset_device) {\n\t\tdev_info(&GET_DEV(accel_dev), \"Resetting device qat_dev%d\\n\",\n\t\t\t accel_dev->accel_id);\n\t\thw_device->reset_device(accel_dev);\n\t\tpci_restore_state(pdev);\n\t\tpci_save_state(pdev);\n\t}\n}\n\nstatic void adf_device_reset_worker(struct work_struct *work)\n{\n\tstruct adf_reset_dev_data *reset_data =\n\t\t  container_of(work, struct adf_reset_dev_data, reset_work);\n\tstruct adf_accel_dev *accel_dev = reset_data->accel_dev;\n\n\tadf_dev_restarting_notify(accel_dev);\n\tif (adf_dev_restart(accel_dev)) {\n\t\t \n\t\tdev_err(&GET_DEV(accel_dev), \"Restart device failed\\n\");\n\t\tif (reset_data->mode == ADF_DEV_RESET_ASYNC)\n\t\t\tkfree(reset_data);\n\t\tWARN(1, \"QAT: device restart failed. Device is unusable\\n\");\n\t\treturn;\n\t}\n\tadf_dev_restarted_notify(accel_dev);\n\tclear_bit(ADF_STATUS_RESTARTING, &accel_dev->status);\n\n\t \n\tif (reset_data->mode == ADF_DEV_RESET_SYNC)\n\t\tcomplete(&reset_data->compl);\n\telse\n\t\tkfree(reset_data);\n}\n\nstatic int adf_dev_aer_schedule_reset(struct adf_accel_dev *accel_dev,\n\t\t\t\t      enum adf_dev_reset_mode mode)\n{\n\tstruct adf_reset_dev_data *reset_data;\n\n\tif (!adf_dev_started(accel_dev) ||\n\t    test_bit(ADF_STATUS_RESTARTING, &accel_dev->status))\n\t\treturn 0;\n\n\tset_bit(ADF_STATUS_RESTARTING, &accel_dev->status);\n\treset_data = kzalloc(sizeof(*reset_data), GFP_KERNEL);\n\tif (!reset_data)\n\t\treturn -ENOMEM;\n\treset_data->accel_dev = accel_dev;\n\tinit_completion(&reset_data->compl);\n\treset_data->mode = mode;\n\tINIT_WORK(&reset_data->reset_work, adf_device_reset_worker);\n\tqueue_work(device_reset_wq, &reset_data->reset_work);\n\n\t \n\tif (mode == ADF_DEV_RESET_SYNC) {\n\t\tint ret = 0;\n\t\t \n\t\tunsigned long wait_jiffies = msecs_to_jiffies(10000);\n\t\tunsigned long timeout = wait_for_completion_timeout(\n\t\t\t\t   &reset_data->compl, wait_jiffies);\n\t\tif (!timeout) {\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"Reset device timeout expired\\n\");\n\t\t\tret = -EFAULT;\n\t\t}\n\t\tkfree(reset_data);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic pci_ers_result_t adf_slot_reset(struct pci_dev *pdev)\n{\n\tstruct adf_accel_dev *accel_dev = adf_devmgr_pci_to_accel_dev(pdev);\n\n\tif (!accel_dev) {\n\t\tpr_err(\"QAT: Can't find acceleration device\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\tif (adf_dev_aer_schedule_reset(accel_dev, ADF_DEV_RESET_SYNC))\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic void adf_resume(struct pci_dev *pdev)\n{\n\tdev_info(&pdev->dev, \"Acceleration driver reset completed\\n\");\n\tdev_info(&pdev->dev, \"Device is up and running\\n\");\n}\n\nconst struct pci_error_handlers adf_err_handler = {\n\t.error_detected = adf_error_detected,\n\t.slot_reset = adf_slot_reset,\n\t.resume = adf_resume,\n};\nEXPORT_SYMBOL_GPL(adf_err_handler);\n\nint adf_init_aer(void)\n{\n\tdevice_reset_wq = alloc_workqueue(\"qat_device_reset_wq\",\n\t\t\t\t\t  WQ_MEM_RECLAIM, 0);\n\treturn !device_reset_wq ? -EFAULT : 0;\n}\n\nvoid adf_exit_aer(void)\n{\n\tif (device_reset_wq)\n\t\tdestroy_workqueue(device_reset_wq);\n\tdevice_reset_wq = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}