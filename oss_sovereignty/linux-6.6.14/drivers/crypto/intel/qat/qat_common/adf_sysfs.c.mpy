{
  "module_name": "adf_sysfs.c",
  "hash_id": "2ce27505ededf62c635d8d01e8b9e0a6a4e9d4601a3946ab21c9b41fe3322ba0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_sysfs.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_cfg.h\"\n#include \"adf_cfg_services.h\"\n#include \"adf_common_drv.h\"\n\nstatic const char * const state_operations[] = {\n\t[DEV_DOWN] = \"down\",\n\t[DEV_UP] = \"up\",\n};\n\nstatic ssize_t state_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct adf_accel_dev *accel_dev;\n\tchar *state;\n\n\taccel_dev = adf_devmgr_pci_to_accel_dev(to_pci_dev(dev));\n\tif (!accel_dev)\n\t\treturn -EINVAL;\n\n\tstate = adf_dev_started(accel_dev) ? \"up\" : \"down\";\n\treturn sysfs_emit(buf, \"%s\\n\", state);\n}\n\nstatic ssize_t state_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct adf_accel_dev *accel_dev;\n\tu32 accel_id;\n\tint ret;\n\n\taccel_dev = adf_devmgr_pci_to_accel_dev(to_pci_dev(dev));\n\tif (!accel_dev)\n\t\treturn -EINVAL;\n\n\taccel_id = accel_dev->accel_id;\n\n\tif (adf_devmgr_in_reset(accel_dev) || adf_dev_in_use(accel_dev)) {\n\t\tdev_info(dev, \"Device qat_dev%d is busy\\n\", accel_id);\n\t\treturn -EBUSY;\n\t}\n\n\tret = sysfs_match_string(state_operations, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret) {\n\tcase DEV_DOWN:\n\t\tdev_info(dev, \"Stopping device qat_dev%d\\n\", accel_id);\n\n\t\tif (!adf_dev_started(accel_dev)) {\n\t\t\tdev_info(&GET_DEV(accel_dev), \"Device qat_dev%d already down\\n\",\n\t\t\t\t accel_id);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tret = adf_dev_down(accel_dev, true);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\tcase DEV_UP:\n\t\tdev_info(dev, \"Starting device qat_dev%d\\n\", accel_id);\n\n\t\tret = adf_dev_up(accel_dev, true);\n\t\tif (ret == -EALREADY) {\n\t\t\tbreak;\n\t\t} else if (ret) {\n\t\t\tdev_err(dev, \"Failed to start device qat_dev%d\\n\",\n\t\t\t\taccel_id);\n\t\t\tadf_dev_down(accel_dev, true);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t cfg_services_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tchar services[ADF_CFG_MAX_VAL_LEN_IN_BYTES] = {0};\n\tstruct adf_accel_dev *accel_dev;\n\tint ret;\n\n\taccel_dev = adf_devmgr_pci_to_accel_dev(to_pci_dev(dev));\n\tif (!accel_dev)\n\t\treturn -EINVAL;\n\n\tret = adf_cfg_get_param_value(accel_dev, ADF_GENERAL_SEC,\n\t\t\t\t      ADF_SERVICES_ENABLED, services);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%s\\n\", services);\n}\n\nstatic int adf_sysfs_update_dev_config(struct adf_accel_dev *accel_dev,\n\t\t\t\t       const char *services)\n{\n\treturn adf_cfg_add_key_value_param(accel_dev, ADF_GENERAL_SEC,\n\t\t\t\t\t   ADF_SERVICES_ENABLED, services,\n\t\t\t\t\t   ADF_STR);\n}\n\nstatic ssize_t cfg_services_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct adf_hw_device_data *hw_data;\n\tstruct adf_accel_dev *accel_dev;\n\tint ret;\n\n\tret = sysfs_match_string(adf_cfg_services, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\taccel_dev = adf_devmgr_pci_to_accel_dev(to_pci_dev(dev));\n\tif (!accel_dev)\n\t\treturn -EINVAL;\n\n\tif (adf_dev_started(accel_dev)) {\n\t\tdev_info(dev, \"Device qat_dev%d must be down to reconfigure the service.\\n\",\n\t\t\t accel_dev->accel_id);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adf_sysfs_update_dev_config(accel_dev, adf_cfg_services[ret]);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thw_data = GET_HW_DATA(accel_dev);\n\n\t \n\thw_data->accel_capabilities_mask = hw_data->get_accel_cap(accel_dev);\n\tif (!hw_data->accel_capabilities_mask)\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic ssize_t pm_idle_enabled_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tchar pm_idle_enabled[ADF_CFG_MAX_VAL_LEN_IN_BYTES] = {};\n\tstruct adf_accel_dev *accel_dev;\n\tint ret;\n\n\taccel_dev = adf_devmgr_pci_to_accel_dev(to_pci_dev(dev));\n\tif (!accel_dev)\n\t\treturn -EINVAL;\n\n\tret = adf_cfg_get_param_value(accel_dev, ADF_GENERAL_SEC,\n\t\t\t\t      ADF_PM_IDLE_SUPPORT, pm_idle_enabled);\n\tif (ret)\n\t\treturn sysfs_emit(buf, \"1\\n\");\n\n\treturn sysfs_emit(buf, \"%s\\n\", pm_idle_enabled);\n}\n\nstatic ssize_t pm_idle_enabled_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tunsigned long pm_idle_enabled_cfg_val;\n\tstruct adf_accel_dev *accel_dev;\n\tbool pm_idle_enabled;\n\tint ret;\n\n\tret = kstrtobool(buf, &pm_idle_enabled);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_idle_enabled_cfg_val = pm_idle_enabled;\n\taccel_dev = adf_devmgr_pci_to_accel_dev(to_pci_dev(dev));\n\tif (!accel_dev)\n\t\treturn -EINVAL;\n\n\tif (adf_dev_started(accel_dev)) {\n\t\tdev_info(dev, \"Device qat_dev%d must be down to set pm_idle_enabled.\\n\",\n\t\t\t accel_dev->accel_id);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adf_cfg_add_key_value_param(accel_dev, ADF_GENERAL_SEC,\n\t\t\t\t\t  ADF_PM_IDLE_SUPPORT, &pm_idle_enabled_cfg_val,\n\t\t\t\t\t  ADF_DEC);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(pm_idle_enabled);\n\nstatic DEVICE_ATTR_RW(state);\nstatic DEVICE_ATTR_RW(cfg_services);\n\nstatic struct attribute *qat_attrs[] = {\n\t&dev_attr_state.attr,\n\t&dev_attr_cfg_services.attr,\n\t&dev_attr_pm_idle_enabled.attr,\n\tNULL,\n};\n\nstatic struct attribute_group qat_group = {\n\t.attrs = qat_attrs,\n\t.name = \"qat\",\n};\n\nint adf_sysfs_init(struct adf_accel_dev *accel_dev)\n{\n\tint ret;\n\n\tret = devm_device_add_group(&GET_DEV(accel_dev), &qat_group);\n\tif (ret) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Failed to create qat attribute group: %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(adf_sysfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}