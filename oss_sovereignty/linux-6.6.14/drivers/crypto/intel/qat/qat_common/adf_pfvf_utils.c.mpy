{
  "module_name": "adf_pfvf_utils.c",
  "hash_id": "4bb3f07cca739398ba59b6c15500dc450fe38e207fdd5d24fa072f6dc2fcfcf7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_pfvf_utils.c",
  "human_readable_source": "\n \n#include <linux/crc8.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_pfvf_msg.h\"\n#include \"adf_pfvf_utils.h\"\n\n \nDECLARE_CRC8_TABLE(pfvf_crc8_table);\n#define ADF_PFVF_CRC8_POLYNOMIAL 0x97\n\nvoid adf_pfvf_crc_init(void)\n{\n\tcrc8_populate_msb(pfvf_crc8_table, ADF_PFVF_CRC8_POLYNOMIAL);\n}\n\nu8 adf_pfvf_calc_blkmsg_crc(u8 const *buf, u8 buf_len)\n{\n\treturn crc8(pfvf_crc8_table, buf, buf_len, CRC8_INIT_VALUE);\n}\n\nstatic bool set_value_on_csr_msg(struct adf_accel_dev *accel_dev, u32 *csr_msg,\n\t\t\t\t u32 value, const struct pfvf_field_format *fmt)\n{\n\tif (unlikely((value & fmt->mask) != value)) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"PFVF message value 0x%X out of range, %u max allowed\\n\",\n\t\t\tvalue, fmt->mask);\n\t\treturn false;\n\t}\n\n\t*csr_msg |= value << fmt->offset;\n\n\treturn true;\n}\n\nu32 adf_pfvf_csr_msg_of(struct adf_accel_dev *accel_dev,\n\t\t\tstruct pfvf_message msg,\n\t\t\tconst struct pfvf_csr_format *fmt)\n{\n\tu32 csr_msg = 0;\n\n\tif (!set_value_on_csr_msg(accel_dev, &csr_msg, msg.type, &fmt->type) ||\n\t    !set_value_on_csr_msg(accel_dev, &csr_msg, msg.data, &fmt->data))\n\t\treturn 0;\n\n\treturn csr_msg | ADF_PFVF_MSGORIGIN_SYSTEM;\n}\n\nstruct pfvf_message adf_pfvf_message_of(struct adf_accel_dev *accel_dev, u32 csr_msg,\n\t\t\t\t\tconst struct pfvf_csr_format *fmt)\n{\n\tstruct pfvf_message msg = { 0 };\n\n\tmsg.type = (csr_msg >> fmt->type.offset) & fmt->type.mask;\n\tmsg.data = (csr_msg >> fmt->data.offset) & fmt->data.mask;\n\n\tif (unlikely(!msg.type))\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Invalid PFVF msg with no type received\\n\");\n\n\treturn msg;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}