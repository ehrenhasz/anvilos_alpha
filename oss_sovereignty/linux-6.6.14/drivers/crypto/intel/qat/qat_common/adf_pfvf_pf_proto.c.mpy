{
  "module_name": "adf_pfvf_pf_proto.c",
  "hash_id": "f2bfb86cc81263a3a73efac2cdfc4e562cf60bbe597bc1219c689cf6eda44089",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_pfvf_pf_proto.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_common_drv.h\"\n#include \"adf_pfvf_msg.h\"\n#include \"adf_pfvf_pf_msg.h\"\n#include \"adf_pfvf_pf_proto.h\"\n#include \"adf_pfvf_utils.h\"\n\ntypedef u8 (*pf2vf_blkmsg_data_getter_fn)(u8 const *blkmsg, u8 byte);\n\nstatic const adf_pf2vf_blkmsg_provider pf2vf_blkmsg_providers[] = {\n\tNULL,\t\t\t\t   \n\tNULL,\t\t\t\t   \n\tadf_pf_capabilities_msg_provider,  \n\tadf_pf_ring_to_svc_msg_provider,   \n};\n\n \nint adf_send_pf2vf_msg(struct adf_accel_dev *accel_dev, u8 vf_nr, struct pfvf_message msg)\n{\n\tstruct adf_pfvf_ops *pfvf_ops = GET_PFVF_OPS(accel_dev);\n\tu32 pfvf_offset = pfvf_ops->get_pf2vf_offset(vf_nr);\n\n\treturn pfvf_ops->send_msg(accel_dev, msg, pfvf_offset,\n\t\t\t\t  &accel_dev->pf.vf_info[vf_nr].pf2vf_lock);\n}\n\n \nstatic struct pfvf_message adf_recv_vf2pf_msg(struct adf_accel_dev *accel_dev, u8 vf_nr)\n{\n\tstruct adf_accel_vf_info *vf_info = &accel_dev->pf.vf_info[vf_nr];\n\tstruct adf_pfvf_ops *pfvf_ops = GET_PFVF_OPS(accel_dev);\n\tu32 pfvf_offset = pfvf_ops->get_vf2pf_offset(vf_nr);\n\n\treturn pfvf_ops->recv_msg(accel_dev, pfvf_offset, vf_info->vf_compat_ver);\n}\n\nstatic adf_pf2vf_blkmsg_provider get_blkmsg_response_provider(u8 type)\n{\n\tif (type >= ARRAY_SIZE(pf2vf_blkmsg_providers))\n\t\treturn NULL;\n\n\treturn pf2vf_blkmsg_providers[type];\n}\n\n \nstatic u8 adf_pf2vf_blkmsg_get_byte(u8 const *blkmsg, u8 index)\n{\n\treturn blkmsg[index];\n}\n\n \nstatic u8 adf_pf2vf_blkmsg_get_crc(u8 const *blkmsg, u8 count)\n{\n\t \n\treturn adf_pfvf_calc_blkmsg_crc(blkmsg, count + 1);\n}\n\nstatic int adf_pf2vf_blkmsg_get_data(struct adf_accel_vf_info *vf_info,\n\t\t\t\t     u8 type, u8 byte, u8 max_size, u8 *data,\n\t\t\t\t     pf2vf_blkmsg_data_getter_fn data_getter)\n{\n\tu8 blkmsg[ADF_PFVF_BLKMSG_MSG_MAX_SIZE] = { 0 };\n\tstruct adf_accel_dev *accel_dev = vf_info->accel_dev;\n\tadf_pf2vf_blkmsg_provider provider;\n\tu8 msg_size;\n\n\tprovider = get_blkmsg_response_provider(type);\n\n\tif (unlikely(!provider)) {\n\t\tpr_err(\"QAT: No registered provider for message %d\\n\", type);\n\t\t*data = ADF_PF2VF_INVALID_BLOCK_TYPE;\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely((*provider)(accel_dev, blkmsg, vf_info->vf_compat_ver))) {\n\t\tpr_err(\"QAT: unknown error from provider for message %d\\n\", type);\n\t\t*data = ADF_PF2VF_UNSPECIFIED_ERROR;\n\t\treturn -EINVAL;\n\t}\n\n\tmsg_size = ADF_PFVF_BLKMSG_HEADER_SIZE + blkmsg[ADF_PFVF_BLKMSG_LEN_BYTE];\n\n\tif (unlikely(msg_size >= max_size)) {\n\t\tpr_err(\"QAT: Invalid size %d provided for message type %d\\n\",\n\t\t       msg_size, type);\n\t\t*data = ADF_PF2VF_PAYLOAD_TRUNCATED;\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(byte >= msg_size)) {\n\t\tpr_err(\"QAT: Out-of-bound byte number %d (msg size %d)\\n\",\n\t\t       byte, msg_size);\n\t\t*data = ADF_PF2VF_INVALID_BYTE_NUM_REQ;\n\t\treturn -EINVAL;\n\t}\n\n\t*data = data_getter(blkmsg, byte);\n\treturn 0;\n}\n\nstatic struct pfvf_message handle_blkmsg_req(struct adf_accel_vf_info *vf_info,\n\t\t\t\t\t     struct pfvf_message req)\n{\n\tu8 resp_type = ADF_PF2VF_BLKMSG_RESP_TYPE_ERROR;\n\tstruct pfvf_message resp = { 0 };\n\tu8 resp_data = 0;\n\tu8 blk_type;\n\tu8 blk_byte;\n\tu8 byte_max;\n\n\tswitch (req.type) {\n\tcase ADF_VF2PF_MSGTYPE_LARGE_BLOCK_REQ:\n\t\tblk_type = FIELD_GET(ADF_VF2PF_LARGE_BLOCK_TYPE_MASK, req.data)\n\t\t\t   + ADF_VF2PF_MEDIUM_BLOCK_TYPE_MAX + 1;\n\t\tblk_byte = FIELD_GET(ADF_VF2PF_LARGE_BLOCK_BYTE_MASK, req.data);\n\t\tbyte_max = ADF_VF2PF_LARGE_BLOCK_BYTE_MAX;\n\t\tbreak;\n\tcase ADF_VF2PF_MSGTYPE_MEDIUM_BLOCK_REQ:\n\t\tblk_type = FIELD_GET(ADF_VF2PF_MEDIUM_BLOCK_TYPE_MASK, req.data)\n\t\t\t   + ADF_VF2PF_SMALL_BLOCK_TYPE_MAX + 1;\n\t\tblk_byte = FIELD_GET(ADF_VF2PF_MEDIUM_BLOCK_BYTE_MASK, req.data);\n\t\tbyte_max = ADF_VF2PF_MEDIUM_BLOCK_BYTE_MAX;\n\t\tbreak;\n\tcase ADF_VF2PF_MSGTYPE_SMALL_BLOCK_REQ:\n\t\tblk_type = FIELD_GET(ADF_VF2PF_SMALL_BLOCK_TYPE_MASK, req.data);\n\t\tblk_byte = FIELD_GET(ADF_VF2PF_SMALL_BLOCK_BYTE_MASK, req.data);\n\t\tbyte_max = ADF_VF2PF_SMALL_BLOCK_BYTE_MAX;\n\t\tbreak;\n\t}\n\n\t \n\tif (FIELD_GET(ADF_VF2PF_BLOCK_CRC_REQ_MASK, req.data)) {\n\t\tdev_dbg(&GET_DEV(vf_info->accel_dev),\n\t\t\t\"BlockMsg of type %d for CRC over %d bytes received from VF%d\\n\",\n\t\t\tblk_type, blk_byte + 1, vf_info->vf_nr);\n\n\t\tif (!adf_pf2vf_blkmsg_get_data(vf_info, blk_type, blk_byte,\n\t\t\t\t\t       byte_max, &resp_data,\n\t\t\t\t\t       adf_pf2vf_blkmsg_get_crc))\n\t\t\tresp_type = ADF_PF2VF_BLKMSG_RESP_TYPE_CRC;\n\t} else {\n\t\tdev_dbg(&GET_DEV(vf_info->accel_dev),\n\t\t\t\"BlockMsg of type %d for data byte %d received from VF%d\\n\",\n\t\t\tblk_type, blk_byte, vf_info->vf_nr);\n\n\t\tif (!adf_pf2vf_blkmsg_get_data(vf_info, blk_type, blk_byte,\n\t\t\t\t\t       byte_max, &resp_data,\n\t\t\t\t\t       adf_pf2vf_blkmsg_get_byte))\n\t\t\tresp_type = ADF_PF2VF_BLKMSG_RESP_TYPE_DATA;\n\t}\n\n\tresp.type = ADF_PF2VF_MSGTYPE_BLKMSG_RESP;\n\tresp.data = FIELD_PREP(ADF_PF2VF_BLKMSG_RESP_TYPE_MASK, resp_type) |\n\t\t    FIELD_PREP(ADF_PF2VF_BLKMSG_RESP_DATA_MASK, resp_data);\n\n\treturn resp;\n}\n\nstatic struct pfvf_message handle_rp_reset_req(struct adf_accel_dev *accel_dev, u8 vf_nr,\n\t\t\t\t\t       struct pfvf_message req)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tstruct pfvf_message resp = {\n\t\t.type = ADF_PF2VF_MSGTYPE_RP_RESET_RESP,\n\t\t.data = RPRESET_SUCCESS\n\t};\n\tu32 bank_number;\n\tu32 rsvd_field;\n\n\tbank_number = FIELD_GET(ADF_VF2PF_RNG_RESET_RP_MASK, req.data);\n\trsvd_field = FIELD_GET(ADF_VF2PF_RNG_RESET_RSVD_MASK, req.data);\n\n\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\"Ring Pair Reset Message received from VF%d for bank 0x%x\\n\",\n\t\tvf_nr, bank_number);\n\n\tif (!hw_data->ring_pair_reset || rsvd_field) {\n\t\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\t\"Ring Pair Reset for VF%d is not supported\\n\", vf_nr);\n\t\tresp.data = RPRESET_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tif (bank_number >= hw_data->num_banks_per_vf) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Invalid bank number (0x%x) from VF%d for Ring Reset\\n\",\n\t\t\tbank_number, vf_nr);\n\t\tresp.data = RPRESET_INVAL_BANK;\n\t\tgoto out;\n\t}\n\n\t \n\tbank_number = vf_nr * hw_data->num_banks_per_vf + bank_number;\n\tif (hw_data->ring_pair_reset(accel_dev, bank_number)) {\n\t\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\t\"Ring pair reset for VF%d failure\\n\", vf_nr);\n\t\tresp.data = RPRESET_TIMEOUT;\n\t\tgoto out;\n\t}\n\n\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\"Ring pair reset for VF%d successfully\\n\", vf_nr);\n\nout:\n\treturn resp;\n}\n\nstatic int adf_handle_vf2pf_msg(struct adf_accel_dev *accel_dev, u8 vf_nr,\n\t\t\t\tstruct pfvf_message msg, struct pfvf_message *resp)\n{\n\tstruct adf_accel_vf_info *vf_info = &accel_dev->pf.vf_info[vf_nr];\n\n\tswitch (msg.type) {\n\tcase ADF_VF2PF_MSGTYPE_COMPAT_VER_REQ:\n\t\t{\n\t\tu8 vf_compat_ver = msg.data;\n\t\tu8 compat;\n\n\t\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\t\"VersionRequest received from VF%d (vers %d) to PF (vers %d)\\n\",\n\t\t\tvf_nr, vf_compat_ver, ADF_PFVF_COMPAT_THIS_VERSION);\n\n\t\tif (vf_compat_ver == 0)\n\t\t\tcompat = ADF_PF2VF_VF_INCOMPATIBLE;\n\t\telse if (vf_compat_ver <= ADF_PFVF_COMPAT_THIS_VERSION)\n\t\t\tcompat = ADF_PF2VF_VF_COMPATIBLE;\n\t\telse\n\t\t\tcompat = ADF_PF2VF_VF_COMPAT_UNKNOWN;\n\n\t\tvf_info->vf_compat_ver = vf_compat_ver;\n\n\t\tresp->type = ADF_PF2VF_MSGTYPE_VERSION_RESP;\n\t\tresp->data = FIELD_PREP(ADF_PF2VF_VERSION_RESP_VERS_MASK,\n\t\t\t\t\tADF_PFVF_COMPAT_THIS_VERSION) |\n\t\t\t     FIELD_PREP(ADF_PF2VF_VERSION_RESP_RESULT_MASK, compat);\n\t\t}\n\t\tbreak;\n\tcase ADF_VF2PF_MSGTYPE_VERSION_REQ:\n\t\t{\n\t\tu8 compat;\n\n\t\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\t\"Legacy VersionRequest received from VF%d to PF (vers 1.1)\\n\",\n\t\t\tvf_nr);\n\n\t\t \n\t\tvf_info->vf_compat_ver = 0;\n\n\t\t \n\t\tcompat = ADF_PF2VF_VF_COMPATIBLE;\n\n\t\t \n\t\tresp->type = ADF_PF2VF_MSGTYPE_VERSION_RESP;\n\t\tresp->data = FIELD_PREP(ADF_PF2VF_VERSION_RESP_VERS_MASK, 0x11) |\n\t\t\t     FIELD_PREP(ADF_PF2VF_VERSION_RESP_RESULT_MASK, compat);\n\t\t}\n\t\tbreak;\n\tcase ADF_VF2PF_MSGTYPE_INIT:\n\t\t{\n\t\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\t\"Init message received from VF%d\\n\", vf_nr);\n\t\tvf_info->init = true;\n\t\t}\n\t\tbreak;\n\tcase ADF_VF2PF_MSGTYPE_SHUTDOWN:\n\t\t{\n\t\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\t\"Shutdown message received from VF%d\\n\", vf_nr);\n\t\tvf_info->init = false;\n\t\t}\n\t\tbreak;\n\tcase ADF_VF2PF_MSGTYPE_LARGE_BLOCK_REQ:\n\tcase ADF_VF2PF_MSGTYPE_MEDIUM_BLOCK_REQ:\n\tcase ADF_VF2PF_MSGTYPE_SMALL_BLOCK_REQ:\n\t\t*resp = handle_blkmsg_req(vf_info, msg);\n\t\tbreak;\n\tcase ADF_VF2PF_MSGTYPE_RP_RESET:\n\t\t*resp = handle_rp_reset_req(accel_dev, vf_nr, msg);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\t\"Unknown message from VF%d (type 0x%.4x, data: 0x%.4x)\\n\",\n\t\t\tvf_nr, msg.type, msg.data);\n\t\treturn -ENOMSG;\n\t}\n\n\treturn 0;\n}\n\nbool adf_recv_and_handle_vf2pf_msg(struct adf_accel_dev *accel_dev, u32 vf_nr)\n{\n\tstruct pfvf_message req;\n\tstruct pfvf_message resp = {0};\n\n\treq = adf_recv_vf2pf_msg(accel_dev, vf_nr);\n\tif (!req.type)   \n\t\treturn true;\n\n\tif (adf_handle_vf2pf_msg(accel_dev, vf_nr, req, &resp))\n\t\treturn false;\n\n\tif (resp.type && adf_send_pf2vf_msg(accel_dev, vf_nr, resp))\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Failed to send response to VF%d\\n\", vf_nr);\n\n\treturn true;\n}\n\n \nint adf_enable_pf2vf_comms(struct adf_accel_dev *accel_dev)\n{\n\tadf_pfvf_crc_init();\n\tspin_lock_init(&accel_dev->pf.vf2pf_ints_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(adf_enable_pf2vf_comms);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}