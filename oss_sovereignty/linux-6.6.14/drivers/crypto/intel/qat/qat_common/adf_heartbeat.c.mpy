{
  "module_name": "adf_heartbeat.c",
  "hash_id": "9ff939d5b4d8f6824ea818ea1883a4c3a8a0fc444df21fdba45271acbcc9a57d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_heartbeat.c",
  "human_readable_source": "\n \n\n#include <linux/dev_printk.h>\n#include <linux/dma-mapping.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/kstrtox.h>\n#include <linux/overflow.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <asm/errno.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_cfg.h\"\n#include \"adf_cfg_strings.h\"\n#include \"adf_clock.h\"\n#include \"adf_common_drv.h\"\n#include \"adf_heartbeat.h\"\n#include \"adf_transport_internal.h\"\n#include \"icp_qat_fw_init_admin.h\"\n\n#define ADF_HB_EMPTY_SIG 0xA5A5A5A5\n\n \nstruct hb_cnt_pair {\n\t__u16 resp_heartbeat_cnt;\n\t__u16 req_heartbeat_cnt;\n};\n\nstatic int adf_hb_check_polling_freq(struct adf_accel_dev *accel_dev)\n{\n\tu64 curr_time = adf_clock_get_current_time();\n\tu64 polling_time = curr_time - accel_dev->heartbeat->last_hb_check_time;\n\n\tif (polling_time < accel_dev->heartbeat->hb_timer) {\n\t\tdev_warn(&GET_DEV(accel_dev),\n\t\t\t \"HB polling too frequent. Configured HB timer %d ms\\n\",\n\t\t\t accel_dev->heartbeat->hb_timer);\n\t\treturn -EINVAL;\n\t}\n\n\taccel_dev->heartbeat->last_hb_check_time = curr_time;\n\treturn 0;\n}\n\n \nstatic bool validate_hb_ctrs_cnt(struct adf_accel_dev *accel_dev)\n{\n\tconst size_t hb_ctrs = accel_dev->hw_device->num_hb_ctrs;\n\tconst size_t max_aes = accel_dev->hw_device->num_engines;\n\tconst size_t hb_struct_size = sizeof(struct hb_cnt_pair);\n\tconst size_t exp_diff_size = array3_size(ADF_NUM_PKE_STRAND, max_aes,\n\t\t\t\t\t\t hb_struct_size);\n\tconst size_t dev_ctrs = size_mul(max_aes, hb_ctrs);\n\tconst size_t stats_size = size_mul(dev_ctrs, hb_struct_size);\n\tconst u32 exp_diff_cnt = exp_diff_size / sizeof(u32);\n\tconst u32 stats_el_cnt = stats_size / sizeof(u32);\n\tstruct hb_cnt_pair *hb_stats = accel_dev->heartbeat->dma.virt_addr;\n\tconst u32 *mem_to_chk = (u32 *)(hb_stats + dev_ctrs);\n\tu32 el_diff_cnt = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < stats_el_cnt; i++) {\n\t\tif (mem_to_chk[i] == ADF_HB_EMPTY_SIG)\n\t\t\tbreak;\n\n\t\tel_diff_cnt++;\n\t}\n\n\treturn el_diff_cnt && el_diff_cnt == exp_diff_cnt;\n}\n\nvoid adf_heartbeat_check_ctrs(struct adf_accel_dev *accel_dev)\n{\n\tstruct hb_cnt_pair *hb_stats = accel_dev->heartbeat->dma.virt_addr;\n\tconst size_t hb_ctrs = accel_dev->hw_device->num_hb_ctrs;\n\tconst size_t max_aes = accel_dev->hw_device->num_engines;\n\tconst size_t dev_ctrs = size_mul(max_aes, hb_ctrs);\n\tconst size_t stats_size = size_mul(dev_ctrs, sizeof(struct hb_cnt_pair));\n\tconst size_t mem_items_to_fill = size_mul(stats_size, 2) / sizeof(u32);\n\n\t \n\tmemset32((uint32_t *)hb_stats, ADF_HB_EMPTY_SIG, mem_items_to_fill);\n\taccel_dev->heartbeat->ctrs_cnt_checked = false;\n}\nEXPORT_SYMBOL_GPL(adf_heartbeat_check_ctrs);\n\nstatic int get_timer_ticks(struct adf_accel_dev *accel_dev, unsigned int *value)\n{\n\tchar timer_str[ADF_CFG_MAX_VAL_LEN_IN_BYTES] = { };\n\tu32 timer_ms = ADF_CFG_HB_TIMER_DEFAULT_MS;\n\tint cfg_read_status;\n\tu32 ticks;\n\tint ret;\n\n\tcfg_read_status = adf_cfg_get_param_value(accel_dev, ADF_GENERAL_SEC,\n\t\t\t\t\t\t  ADF_HEARTBEAT_TIMER, timer_str);\n\tif (cfg_read_status == 0) {\n\t\tif (kstrtouint(timer_str, 10, &timer_ms))\n\t\t\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\t\t\"kstrtouint failed to parse the %s, param value\",\n\t\t\t\tADF_HEARTBEAT_TIMER);\n\t}\n\n\tif (timer_ms < ADF_CFG_HB_TIMER_MIN_MS) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Timer cannot be less than %u\\n\",\n\t\t\tADF_CFG_HB_TIMER_MIN_MS);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (accel_dev->timer)\n\t\ttimer_ms = ADF_CFG_HB_TIMER_MIN_MS;\n\n\tret = adf_heartbeat_ms_to_ticks(accel_dev, timer_ms, &ticks);\n\tif (ret)\n\t\treturn ret;\n\n\tadf_heartbeat_save_cfg_param(accel_dev, timer_ms);\n\n\taccel_dev->heartbeat->hb_timer = timer_ms;\n\t*value = ticks;\n\n\treturn 0;\n}\n\nstatic int check_ae(struct hb_cnt_pair *curr, struct hb_cnt_pair *prev,\n\t\t    u16 *count, const size_t hb_ctrs)\n{\n\tsize_t thr;\n\n\t \n\tfor (thr = 0; thr < hb_ctrs; thr++) {\n\t\tu16 req = curr[thr].req_heartbeat_cnt;\n\t\tu16 resp = curr[thr].resp_heartbeat_cnt;\n\t\tu16 last = prev[thr].resp_heartbeat_cnt;\n\n\t\tif ((thr == ADF_AE_ADMIN_THREAD || req != resp) && resp == last) {\n\t\t\tu16 retry = ++count[thr];\n\n\t\t\tif (retry >= ADF_CFG_HB_COUNT_THRESHOLD)\n\t\t\t\treturn -EIO;\n\n\t\t} else {\n\t\t\tcount[thr] = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int adf_hb_get_status(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_device = accel_dev->hw_device;\n\tstruct hb_cnt_pair *live_stats, *last_stats, *curr_stats;\n\tconst size_t hb_ctrs = hw_device->num_hb_ctrs;\n\tconst unsigned long ae_mask = hw_device->ae_mask;\n\tconst size_t max_aes = hw_device->num_engines;\n\tconst size_t dev_ctrs = size_mul(max_aes, hb_ctrs);\n\tconst size_t stats_size = size_mul(dev_ctrs, sizeof(*curr_stats));\n\tstruct hb_cnt_pair *ae_curr_p, *ae_prev_p;\n\tu16 *count_fails, *ae_count_p;\n\tsize_t ae_offset;\n\tsize_t ae = 0;\n\tint ret = 0;\n\n\tif (!accel_dev->heartbeat->ctrs_cnt_checked) {\n\t\tif (validate_hb_ctrs_cnt(accel_dev))\n\t\t\thw_device->num_hb_ctrs += ADF_NUM_PKE_STRAND;\n\n\t\taccel_dev->heartbeat->ctrs_cnt_checked = true;\n\t}\n\n\tlive_stats = accel_dev->heartbeat->dma.virt_addr;\n\tlast_stats = live_stats + dev_ctrs;\n\tcount_fails = (u16 *)(last_stats + dev_ctrs);\n\n\tcurr_stats = kmemdup(live_stats, stats_size, GFP_KERNEL);\n\tif (!curr_stats)\n\t\treturn -ENOMEM;\n\n\t \n\tfor_each_set_bit(ae, &ae_mask, max_aes) {\n\t\tae_offset = size_mul(ae, hb_ctrs);\n\t\tae_curr_p = curr_stats + ae_offset;\n\t\tae_prev_p = last_stats + ae_offset;\n\t\tae_count_p = count_fails + ae_offset;\n\n\t\tret = check_ae(ae_curr_p, ae_prev_p, ae_count_p, hb_ctrs);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\t \n\tmemcpy(last_stats, curr_stats, stats_size);\n\tkfree(curr_stats);\n\n\treturn ret;\n}\n\nvoid adf_heartbeat_status(struct adf_accel_dev *accel_dev,\n\t\t\t  enum adf_device_heartbeat_status *hb_status)\n{\n\tstruct adf_heartbeat *hb;\n\n\tif (!adf_dev_started(accel_dev) ||\n\t    test_bit(ADF_STATUS_RESTARTING, &accel_dev->status)) {\n\t\t*hb_status = HB_DEV_UNRESPONSIVE;\n\t\treturn;\n\t}\n\n\tif (adf_hb_check_polling_freq(accel_dev) == -EINVAL) {\n\t\t*hb_status = HB_DEV_UNSUPPORTED;\n\t\treturn;\n\t}\n\n\thb = accel_dev->heartbeat;\n\thb->hb_sent_counter++;\n\n\tif (adf_hb_get_status(accel_dev)) {\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Heartbeat ERROR: QAT is not responding.\\n\");\n\t\t*hb_status = HB_DEV_UNRESPONSIVE;\n\t\thb->hb_failed_counter++;\n\t\treturn;\n\t}\n\n\t*hb_status = HB_DEV_ALIVE;\n}\n\nint adf_heartbeat_ms_to_ticks(struct adf_accel_dev *accel_dev, unsigned int time_ms,\n\t\t\t      u32 *value)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tu32 clk_per_sec;\n\n\t \n\tif (!hw_data->get_hb_clock)\n\t\treturn -EINVAL;\n\n\tclk_per_sec = hw_data->get_hb_clock(hw_data);\n\t*value = time_ms * (clk_per_sec / MSEC_PER_SEC);\n\n\treturn 0;\n}\n\nint adf_heartbeat_save_cfg_param(struct adf_accel_dev *accel_dev,\n\t\t\t\t unsigned int timer_ms)\n{\n\tchar timer_str[ADF_CFG_MAX_VAL_LEN_IN_BYTES];\n\n\tsnprintf(timer_str, sizeof(timer_str), \"%u\", timer_ms);\n\treturn adf_cfg_add_key_value_param(accel_dev, ADF_GENERAL_SEC,\n\t\t\t\t\t  ADF_HEARTBEAT_TIMER, timer_str,\n\t\t\t\t\t  ADF_STR);\n}\nEXPORT_SYMBOL_GPL(adf_heartbeat_save_cfg_param);\n\nint adf_heartbeat_init(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_heartbeat *hb;\n\n\thb = kzalloc(sizeof(*hb), GFP_KERNEL);\n\tif (!hb)\n\t\tgoto err_ret;\n\n\thb->dma.virt_addr = dma_alloc_coherent(&GET_DEV(accel_dev), PAGE_SIZE,\n\t\t\t\t\t       &hb->dma.phy_addr, GFP_KERNEL);\n\tif (!hb->dma.virt_addr)\n\t\tgoto err_free;\n\n\t \n\thb->ctrs_cnt_checked = true;\n\taccel_dev->heartbeat = hb;\n\n\treturn 0;\n\nerr_free:\n\tkfree(hb);\nerr_ret:\n\treturn -ENOMEM;\n}\n\nint adf_heartbeat_start(struct adf_accel_dev *accel_dev)\n{\n\tunsigned int timer_ticks;\n\tint ret;\n\n\tif (!accel_dev->heartbeat) {\n\t\tdev_warn(&GET_DEV(accel_dev), \"Heartbeat instance not found!\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (accel_dev->hw_device->check_hb_ctrs)\n\t\taccel_dev->hw_device->check_hb_ctrs(accel_dev);\n\n\tret = get_timer_ticks(accel_dev, &timer_ticks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adf_send_admin_hb_timer(accel_dev, timer_ticks);\n\tif (ret)\n\t\tdev_warn(&GET_DEV(accel_dev), \"Heartbeat not supported!\");\n\n\treturn ret;\n}\n\nvoid adf_heartbeat_shutdown(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_heartbeat *hb = accel_dev->heartbeat;\n\n\tif (!hb)\n\t\treturn;\n\n\tif (hb->dma.virt_addr)\n\t\tdma_free_coherent(&GET_DEV(accel_dev), PAGE_SIZE,\n\t\t\t\t  hb->dma.virt_addr, hb->dma.phy_addr);\n\n\tkfree(hb);\n\taccel_dev->heartbeat = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}