{
  "module_name": "adf_clock.c",
  "hash_id": "336a2bae928b579c15e61ba415f32f2d9369039ae608b5dd1cd0bf0ceb85c9b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_clock.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dev_printk.h>\n#include <linux/export.h>\n#include <linux/math.h>\n#include <linux/minmax.h>\n#include <linux/time64.h>\n#include <linux/types.h>\n#include <linux/units.h>\n#include <asm/errno.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_clock.h\"\n#include \"adf_common_drv.h\"\n\n#define MEASURE_CLOCK_RETRIES 10\n#define MEASURE_CLOCK_DELAY_US 10000\n#define ME_CLK_DIVIDER 16\n#define MEASURE_CLOCK_DELTA_THRESHOLD_US 100\n\nstatic inline u64 timespec_to_us(const struct timespec64 *ts)\n{\n\treturn (u64)DIV_ROUND_CLOSEST_ULL(timespec64_to_ns(ts), NSEC_PER_USEC);\n}\n\nstatic inline u64 timespec_to_ms(const struct timespec64 *ts)\n{\n\treturn (u64)DIV_ROUND_CLOSEST_ULL(timespec64_to_ns(ts), NSEC_PER_MSEC);\n}\n\nu64 adf_clock_get_current_time(void)\n{\n\tstruct timespec64 ts;\n\n\tktime_get_real_ts64(&ts);\n\treturn timespec_to_ms(&ts);\n}\n\nstatic int measure_clock(struct adf_accel_dev *accel_dev, u32 *frequency)\n{\n\tstruct timespec64 ts1, ts2, ts3, ts4;\n\tu64 timestamp1, timestamp2, temp;\n\tu32 delta_us, tries;\n\tint ret;\n\n\ttries = MEASURE_CLOCK_RETRIES;\n\tdo {\n\t\tktime_get_real_ts64(&ts1);\n\t\tret = adf_get_fw_timestamp(accel_dev, &timestamp1);\n\t\tif (ret) {\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"Failed to get fw timestamp\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tktime_get_real_ts64(&ts2);\n\t\tdelta_us = timespec_to_us(&ts2) - timespec_to_us(&ts1);\n\t} while (delta_us > MEASURE_CLOCK_DELTA_THRESHOLD_US && --tries);\n\n\tif (!tries) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Excessive clock measure delay\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tfsleep(MEASURE_CLOCK_DELAY_US);\n\n\ttries = MEASURE_CLOCK_RETRIES;\n\tdo {\n\t\tktime_get_real_ts64(&ts3);\n\t\tif (adf_get_fw_timestamp(accel_dev, &timestamp2)) {\n\t\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\t\"Failed to get fw timestamp\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tktime_get_real_ts64(&ts4);\n\t\tdelta_us = timespec_to_us(&ts4) - timespec_to_us(&ts3);\n\t} while (delta_us > MEASURE_CLOCK_DELTA_THRESHOLD_US && --tries);\n\n\tif (!tries) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Excessive clock measure delay\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdelta_us = timespec_to_us(&ts3) - timespec_to_us(&ts1);\n\ttemp = (timestamp2 - timestamp1) * ME_CLK_DIVIDER * 10;\n\ttemp = DIV_ROUND_CLOSEST_ULL(temp, delta_us);\n\t \n\t*frequency = temp * (HZ_PER_MHZ / 10);\n\n\treturn 0;\n}\n\n \nint adf_dev_measure_clock(struct adf_accel_dev *accel_dev,\n\t\t\t  u32 *frequency, u32 min, u32 max)\n{\n\tint ret;\n\tu32 freq;\n\n\tret = measure_clock(accel_dev, &freq);\n\tif (ret)\n\t\treturn ret;\n\n\t*frequency = clamp(freq, min, max);\n\n\tif (*frequency != freq)\n\t\tdev_warn(&GET_DEV(accel_dev),\n\t\t\t \"Measured clock %d Hz is out of range, assuming %d\\n\",\n\t\t\t freq, *frequency);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(adf_dev_measure_clock);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}