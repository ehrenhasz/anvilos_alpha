{
  "module_name": "adf_gen2_pfvf.c",
  "hash_id": "12e567a3d011219f8caa2cc90026ab4d8df251ff5b5bc2745ebb843eb3746b4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_gen2_pfvf.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_common_drv.h\"\n#include \"adf_gen2_pfvf.h\"\n#include \"adf_pfvf_msg.h\"\n#include \"adf_pfvf_pf_proto.h\"\n#include \"adf_pfvf_vf_proto.h\"\n#include \"adf_pfvf_utils.h\"\n\n  \n#define ADF_GEN2_VF_MSK\t\t\t0xFFFF\n#define ADF_GEN2_ERR_REG_VF2PF(vf_src)\t(((vf_src) & 0x01FFFE00) >> 9)\n#define ADF_GEN2_ERR_MSK_VF2PF(vf_mask)\t(((vf_mask) & ADF_GEN2_VF_MSK) << 9)\n\n#define ADF_GEN2_PF_PF2VF_OFFSET(i)\t(0x3A000 + 0x280 + ((i) * 0x04))\n#define ADF_GEN2_VF_PF2VF_OFFSET\t0x200\n\n#define ADF_GEN2_CSR_IN_USE\t\t0x6AC2\n#define ADF_GEN2_CSR_IN_USE_MASK\t0xFFFE\n\nenum gen2_csr_pos {\n\tADF_GEN2_CSR_PF2VF_OFFSET\t=  0,\n\tADF_GEN2_CSR_VF2PF_OFFSET\t= 16,\n};\n\n#define ADF_PFVF_GEN2_MSGTYPE_SHIFT\t2\n#define ADF_PFVF_GEN2_MSGTYPE_MASK\t0x0F\n#define ADF_PFVF_GEN2_MSGDATA_SHIFT\t6\n#define ADF_PFVF_GEN2_MSGDATA_MASK\t0x3FF\n\nstatic const struct pfvf_csr_format csr_gen2_fmt = {\n\t{ ADF_PFVF_GEN2_MSGTYPE_SHIFT, ADF_PFVF_GEN2_MSGTYPE_MASK },\n\t{ ADF_PFVF_GEN2_MSGDATA_SHIFT, ADF_PFVF_GEN2_MSGDATA_MASK },\n};\n\n#define ADF_PFVF_MSG_RETRY_DELAY\t5\n#define ADF_PFVF_MSG_MAX_RETRIES\t3\n\nstatic u32 adf_gen2_pf_get_pfvf_offset(u32 i)\n{\n\treturn ADF_GEN2_PF_PF2VF_OFFSET(i);\n}\n\nstatic u32 adf_gen2_vf_get_pfvf_offset(u32 i)\n{\n\treturn ADF_GEN2_VF_PF2VF_OFFSET;\n}\n\nstatic void adf_gen2_enable_vf2pf_interrupts(void __iomem *pmisc_addr, u32 vf_mask)\n{\n\t \n\tif (vf_mask & ADF_GEN2_VF_MSK) {\n\t\tu32 val = ADF_CSR_RD(pmisc_addr, ADF_GEN2_ERRMSK3)\n\t\t\t  & ~ADF_GEN2_ERR_MSK_VF2PF(vf_mask);\n\t\tADF_CSR_WR(pmisc_addr, ADF_GEN2_ERRMSK3, val);\n\t}\n}\n\nstatic void adf_gen2_disable_all_vf2pf_interrupts(void __iomem *pmisc_addr)\n{\n\t \n\tu32 val = ADF_CSR_RD(pmisc_addr, ADF_GEN2_ERRMSK3)\n\t\t  | ADF_GEN2_ERR_MSK_VF2PF(ADF_GEN2_VF_MSK);\n\tADF_CSR_WR(pmisc_addr, ADF_GEN2_ERRMSK3, val);\n}\n\nstatic u32 adf_gen2_disable_pending_vf2pf_interrupts(void __iomem *pmisc_addr)\n{\n\tu32 sources, disabled, pending;\n\tu32 errsou3, errmsk3;\n\n\t \n\terrsou3 = ADF_CSR_RD(pmisc_addr, ADF_GEN2_ERRSOU3);\n\tsources = ADF_GEN2_ERR_REG_VF2PF(errsou3);\n\n\tif (!sources)\n\t\treturn 0;\n\n\t \n\terrmsk3 = ADF_CSR_RD(pmisc_addr, ADF_GEN2_ERRMSK3);\n\tdisabled = ADF_GEN2_ERR_REG_VF2PF(errmsk3);\n\n\tpending = sources & ~disabled;\n\tif (!pending)\n\t\treturn 0;\n\n\t \n\terrmsk3 |= ADF_GEN2_ERR_MSK_VF2PF(ADF_GEN2_VF_MSK);\n\tADF_CSR_WR(pmisc_addr, ADF_GEN2_ERRMSK3, errmsk3);\n\n\terrmsk3 &= ADF_GEN2_ERR_MSK_VF2PF(sources | disabled);\n\tADF_CSR_WR(pmisc_addr, ADF_GEN2_ERRMSK3, errmsk3);\n\n\t \n\treturn pending;\n}\n\nstatic u32 gen2_csr_get_int_bit(enum gen2_csr_pos offset)\n{\n\treturn ADF_PFVF_INT << offset;\n}\n\nstatic u32 gen2_csr_msg_to_position(u32 csr_msg, enum gen2_csr_pos offset)\n{\n\treturn (csr_msg & 0xFFFF) << offset;\n}\n\nstatic u32 gen2_csr_msg_from_position(u32 csr_val, enum gen2_csr_pos offset)\n{\n\treturn (csr_val >> offset) & 0xFFFF;\n}\n\nstatic bool gen2_csr_is_in_use(u32 msg, enum gen2_csr_pos offset)\n{\n\treturn ((msg >> offset) & ADF_GEN2_CSR_IN_USE_MASK) == ADF_GEN2_CSR_IN_USE;\n}\n\nstatic void gen2_csr_clear_in_use(u32 *msg, enum gen2_csr_pos offset)\n{\n\t*msg &= ~(ADF_GEN2_CSR_IN_USE_MASK << offset);\n}\n\nstatic void gen2_csr_set_in_use(u32 *msg, enum gen2_csr_pos offset)\n{\n\t*msg |= (ADF_GEN2_CSR_IN_USE << offset);\n}\n\nstatic bool is_legacy_user_pfvf_message(u32 msg)\n{\n\treturn !(msg & ADF_PFVF_MSGORIGIN_SYSTEM);\n}\n\nstatic bool is_pf2vf_notification(u8 msg_type)\n{\n\tswitch (msg_type) {\n\tcase ADF_PF2VF_MSGTYPE_RESTARTING:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool is_vf2pf_notification(u8 msg_type)\n{\n\tswitch (msg_type) {\n\tcase ADF_VF2PF_MSGTYPE_INIT:\n\tcase ADF_VF2PF_MSGTYPE_SHUTDOWN:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstruct pfvf_gen2_params {\n\tu32 pfvf_offset;\n\tstruct mutex *csr_lock;  \n\tenum gen2_csr_pos local_offset;\n\tenum gen2_csr_pos remote_offset;\n\tbool (*is_notification_message)(u8 msg_type);\n\tu8 compat_ver;\n};\n\nstatic int adf_gen2_pfvf_send(struct adf_accel_dev *accel_dev,\n\t\t\t      struct pfvf_message msg,\n\t\t\t      struct pfvf_gen2_params *params)\n{\n\tvoid __iomem *pmisc_addr = adf_get_pmisc_base(accel_dev);\n\tenum gen2_csr_pos remote_offset = params->remote_offset;\n\tenum gen2_csr_pos local_offset = params->local_offset;\n\tunsigned int retries = ADF_PFVF_MSG_MAX_RETRIES;\n\tstruct mutex *lock = params->csr_lock;\n\tu32 pfvf_offset = params->pfvf_offset;\n\tu32 int_bit;\n\tu32 csr_val;\n\tu32 csr_msg;\n\tint ret;\n\n\t \n\n\tint_bit = gen2_csr_get_int_bit(local_offset);\n\n\tcsr_msg = adf_pfvf_csr_msg_of(accel_dev, msg, &csr_gen2_fmt);\n\tif (unlikely(!csr_msg))\n\t\treturn -EINVAL;\n\n\t \n\tcsr_msg = gen2_csr_msg_to_position(csr_msg, local_offset);\n\tgen2_csr_set_in_use(&csr_msg, remote_offset);\n\n\tmutex_lock(lock);\n\nstart:\n\t \n\tcsr_val = ADF_CSR_RD(pmisc_addr, pfvf_offset);\n\tif (gen2_csr_is_in_use(csr_val, local_offset)) {\n\t\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\t\"PFVF CSR in use by remote function\\n\");\n\t\tgoto retry;\n\t}\n\n\t \n\tADF_CSR_WR(pmisc_addr, pfvf_offset, csr_msg | int_bit);\n\n\t \n\tret = read_poll_timeout(ADF_CSR_RD, csr_val, !(csr_val & int_bit),\n\t\t\t\tADF_PFVF_MSG_ACK_DELAY_US,\n\t\t\t\tADF_PFVF_MSG_ACK_MAX_DELAY_US,\n\t\t\t\ttrue, pmisc_addr, pfvf_offset);\n\tif (unlikely(ret < 0)) {\n\t\tdev_dbg(&GET_DEV(accel_dev), \"ACK not received from remote\\n\");\n\t\tcsr_val &= ~int_bit;\n\t}\n\n\t \n\tif (params->is_notification_message(msg.type) && csr_val != csr_msg) {\n\t\t \n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"Collision on notification - PFVF CSR overwritten by remote function\\n\");\n\t\tgoto retry;\n\t}\n\n\t \n\tif (gen2_csr_is_in_use(csr_val, remote_offset)) {\n\t\tgen2_csr_clear_in_use(&csr_val, remote_offset);\n\t\tADF_CSR_WR(pmisc_addr, pfvf_offset, csr_val);\n\t}\n\nout:\n\tmutex_unlock(lock);\n\treturn ret;\n\nretry:\n\tif (--retries) {\n\t\tmsleep(ADF_PFVF_MSG_RETRY_DELAY);\n\t\tgoto start;\n\t} else {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n}\n\nstatic struct pfvf_message adf_gen2_pfvf_recv(struct adf_accel_dev *accel_dev,\n\t\t\t\t\t      struct pfvf_gen2_params *params)\n{\n\tvoid __iomem *pmisc_addr = adf_get_pmisc_base(accel_dev);\n\tenum gen2_csr_pos remote_offset = params->remote_offset;\n\tenum gen2_csr_pos local_offset = params->local_offset;\n\tu32 pfvf_offset = params->pfvf_offset;\n\tstruct pfvf_message msg = { 0 };\n\tu32 int_bit;\n\tu32 csr_val;\n\tu16 csr_msg;\n\n\tint_bit = gen2_csr_get_int_bit(local_offset);\n\n\t \n\tcsr_val = ADF_CSR_RD(pmisc_addr, pfvf_offset);\n\tif (!(csr_val & int_bit)) {\n\t\tdev_info(&GET_DEV(accel_dev),\n\t\t\t \"Spurious PFVF interrupt, msg 0x%.8x. Ignored\\n\", csr_val);\n\t\treturn msg;\n\t}\n\n\t \n\tcsr_msg = gen2_csr_msg_from_position(csr_val, local_offset);\n\n\t \n\tif (unlikely(is_legacy_user_pfvf_message(csr_msg))) {\n\t\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\t\"Ignored non-system message (0x%.8x);\\n\", csr_val);\n\t\t \n\t\treturn msg;\n\t}\n\n\t \n\tmsg = adf_pfvf_message_of(accel_dev, csr_msg, &csr_gen2_fmt);\n\n\t \n\tif (params->compat_ver >= ADF_PFVF_COMPAT_FAST_ACK &&\n\t    !params->is_notification_message(msg.type))\n\t\tgen2_csr_clear_in_use(&csr_val, remote_offset);\n\n\t \n\tcsr_val &= ~int_bit;\n\tADF_CSR_WR(pmisc_addr, pfvf_offset, csr_val);\n\n\treturn msg;\n}\n\nstatic int adf_gen2_pf2vf_send(struct adf_accel_dev *accel_dev, struct pfvf_message msg,\n\t\t\t       u32 pfvf_offset, struct mutex *csr_lock)\n{\n\tstruct pfvf_gen2_params params = {\n\t\t.csr_lock = csr_lock,\n\t\t.pfvf_offset = pfvf_offset,\n\t\t.local_offset = ADF_GEN2_CSR_PF2VF_OFFSET,\n\t\t.remote_offset = ADF_GEN2_CSR_VF2PF_OFFSET,\n\t\t.is_notification_message = is_pf2vf_notification,\n\t};\n\n\treturn adf_gen2_pfvf_send(accel_dev, msg, &params);\n}\n\nstatic int adf_gen2_vf2pf_send(struct adf_accel_dev *accel_dev, struct pfvf_message msg,\n\t\t\t       u32 pfvf_offset, struct mutex *csr_lock)\n{\n\tstruct pfvf_gen2_params params = {\n\t\t.csr_lock = csr_lock,\n\t\t.pfvf_offset = pfvf_offset,\n\t\t.local_offset = ADF_GEN2_CSR_VF2PF_OFFSET,\n\t\t.remote_offset = ADF_GEN2_CSR_PF2VF_OFFSET,\n\t\t.is_notification_message = is_vf2pf_notification,\n\t};\n\n\treturn adf_gen2_pfvf_send(accel_dev, msg, &params);\n}\n\nstatic struct pfvf_message adf_gen2_pf2vf_recv(struct adf_accel_dev *accel_dev,\n\t\t\t\t\t       u32 pfvf_offset, u8 compat_ver)\n{\n\tstruct pfvf_gen2_params params = {\n\t\t.pfvf_offset = pfvf_offset,\n\t\t.local_offset = ADF_GEN2_CSR_PF2VF_OFFSET,\n\t\t.remote_offset = ADF_GEN2_CSR_VF2PF_OFFSET,\n\t\t.is_notification_message = is_pf2vf_notification,\n\t\t.compat_ver = compat_ver,\n\t};\n\n\treturn adf_gen2_pfvf_recv(accel_dev, &params);\n}\n\nstatic struct pfvf_message adf_gen2_vf2pf_recv(struct adf_accel_dev *accel_dev,\n\t\t\t\t\t       u32 pfvf_offset, u8 compat_ver)\n{\n\tstruct pfvf_gen2_params params = {\n\t\t.pfvf_offset = pfvf_offset,\n\t\t.local_offset = ADF_GEN2_CSR_VF2PF_OFFSET,\n\t\t.remote_offset = ADF_GEN2_CSR_PF2VF_OFFSET,\n\t\t.is_notification_message = is_vf2pf_notification,\n\t\t.compat_ver = compat_ver,\n\t};\n\n\treturn adf_gen2_pfvf_recv(accel_dev, &params);\n}\n\nvoid adf_gen2_init_pf_pfvf_ops(struct adf_pfvf_ops *pfvf_ops)\n{\n\tpfvf_ops->enable_comms = adf_enable_pf2vf_comms;\n\tpfvf_ops->get_pf2vf_offset = adf_gen2_pf_get_pfvf_offset;\n\tpfvf_ops->get_vf2pf_offset = adf_gen2_pf_get_pfvf_offset;\n\tpfvf_ops->enable_vf2pf_interrupts = adf_gen2_enable_vf2pf_interrupts;\n\tpfvf_ops->disable_all_vf2pf_interrupts = adf_gen2_disable_all_vf2pf_interrupts;\n\tpfvf_ops->disable_pending_vf2pf_interrupts = adf_gen2_disable_pending_vf2pf_interrupts;\n\tpfvf_ops->send_msg = adf_gen2_pf2vf_send;\n\tpfvf_ops->recv_msg = adf_gen2_vf2pf_recv;\n}\nEXPORT_SYMBOL_GPL(adf_gen2_init_pf_pfvf_ops);\n\nvoid adf_gen2_init_vf_pfvf_ops(struct adf_pfvf_ops *pfvf_ops)\n{\n\tpfvf_ops->enable_comms = adf_enable_vf2pf_comms;\n\tpfvf_ops->get_pf2vf_offset = adf_gen2_vf_get_pfvf_offset;\n\tpfvf_ops->get_vf2pf_offset = adf_gen2_vf_get_pfvf_offset;\n\tpfvf_ops->send_msg = adf_gen2_vf2pf_send;\n\tpfvf_ops->recv_msg = adf_gen2_pf2vf_recv;\n}\nEXPORT_SYMBOL_GPL(adf_gen2_init_vf_pfvf_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}