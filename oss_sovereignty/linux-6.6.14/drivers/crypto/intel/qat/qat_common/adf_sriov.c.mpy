{
  "module_name": "adf_sriov.c",
  "hash_id": "146952c9d38dd34d853741cd4fb5d0d986581ca8fa7b0c2a3ac2c0021865c0ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_sriov.c",
  "human_readable_source": "\n \n#include <linux/workqueue.h>\n#include <linux/pci.h>\n#include <linux/device.h>\n#include \"adf_common_drv.h\"\n#include \"adf_cfg.h\"\n#include \"adf_pfvf_pf_msg.h\"\n\n#define ADF_VF2PF_RATELIMIT_INTERVAL\t8\n#define ADF_VF2PF_RATELIMIT_BURST\t130\n\nstatic struct workqueue_struct *pf2vf_resp_wq;\n\nstruct adf_pf2vf_resp {\n\tstruct work_struct pf2vf_resp_work;\n\tstruct adf_accel_vf_info *vf_info;\n};\n\nstatic void adf_iov_send_resp(struct work_struct *work)\n{\n\tstruct adf_pf2vf_resp *pf2vf_resp =\n\t\tcontainer_of(work, struct adf_pf2vf_resp, pf2vf_resp_work);\n\tstruct adf_accel_vf_info *vf_info = pf2vf_resp->vf_info;\n\tstruct adf_accel_dev *accel_dev = vf_info->accel_dev;\n\tu32 vf_nr = vf_info->vf_nr;\n\tbool ret;\n\n\tret = adf_recv_and_handle_vf2pf_msg(accel_dev, vf_nr);\n\tif (ret)\n\t\t \n\t\tadf_enable_vf2pf_interrupts(accel_dev, 1 << vf_nr);\n\n\tkfree(pf2vf_resp);\n}\n\nvoid adf_schedule_vf2pf_handler(struct adf_accel_vf_info *vf_info)\n{\n\tstruct adf_pf2vf_resp *pf2vf_resp;\n\n\tpf2vf_resp = kzalloc(sizeof(*pf2vf_resp), GFP_ATOMIC);\n\tif (!pf2vf_resp)\n\t\treturn;\n\n\tpf2vf_resp->vf_info = vf_info;\n\tINIT_WORK(&pf2vf_resp->pf2vf_resp_work, adf_iov_send_resp);\n\tqueue_work(pf2vf_resp_wq, &pf2vf_resp->pf2vf_resp_work);\n}\n\nstatic int adf_enable_sriov(struct adf_accel_dev *accel_dev)\n{\n\tstruct pci_dev *pdev = accel_to_pci_dev(accel_dev);\n\tint totalvfs = pci_sriov_get_totalvfs(pdev);\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tstruct adf_accel_vf_info *vf_info;\n\tint i;\n\n\tfor (i = 0, vf_info = accel_dev->pf.vf_info; i < totalvfs;\n\t     i++, vf_info++) {\n\t\t \n\t\tvf_info->accel_dev = accel_dev;\n\t\tvf_info->vf_nr = i;\n\t\tvf_info->vf_compat_ver = 0;\n\n\t\tmutex_init(&vf_info->pf2vf_lock);\n\t\tratelimit_state_init(&vf_info->vf2pf_ratelimit,\n\t\t\t\t     ADF_VF2PF_RATELIMIT_INTERVAL,\n\t\t\t\t     ADF_VF2PF_RATELIMIT_BURST);\n\t}\n\n\t \n\tif (hw_data->configure_iov_threads)\n\t\thw_data->configure_iov_threads(accel_dev, true);\n\n\t \n\tadf_enable_vf2pf_interrupts(accel_dev, BIT_ULL(totalvfs) - 1);\n\n\t \n\treturn pci_enable_sriov(pdev, totalvfs);\n}\n\n \nvoid adf_disable_sriov(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tint totalvfs = pci_sriov_get_totalvfs(accel_to_pci_dev(accel_dev));\n\tstruct adf_accel_vf_info *vf;\n\tint i;\n\n\tif (!accel_dev->pf.vf_info)\n\t\treturn;\n\n\tadf_pf2vf_notify_restarting(accel_dev);\n\tpci_disable_sriov(accel_to_pci_dev(accel_dev));\n\n\t \n\tadf_disable_all_vf2pf_interrupts(accel_dev);\n\n\t \n\tif (hw_data->configure_iov_threads)\n\t\thw_data->configure_iov_threads(accel_dev, false);\n\n\tfor (i = 0, vf = accel_dev->pf.vf_info; i < totalvfs; i++, vf++)\n\t\tmutex_destroy(&vf->pf2vf_lock);\n\n\tkfree(accel_dev->pf.vf_info);\n\taccel_dev->pf.vf_info = NULL;\n}\nEXPORT_SYMBOL_GPL(adf_disable_sriov);\n\n \nint adf_sriov_configure(struct pci_dev *pdev, int numvfs)\n{\n\tstruct adf_accel_dev *accel_dev = adf_devmgr_pci_to_accel_dev(pdev);\n\tint totalvfs = pci_sriov_get_totalvfs(pdev);\n\tunsigned long val;\n\tint ret;\n\n\tif (!accel_dev) {\n\t\tdev_err(&pdev->dev, \"Failed to find accel_dev\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (!device_iommu_mapped(&pdev->dev))\n\t\tdev_warn(&pdev->dev, \"IOMMU should be enabled for SR-IOV to work correctly\\n\");\n\n\tif (accel_dev->pf.vf_info) {\n\t\tdev_info(&pdev->dev, \"Already enabled for this device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (adf_dev_started(accel_dev)) {\n\t\tif (adf_devmgr_in_reset(accel_dev) ||\n\t\t    adf_dev_in_use(accel_dev)) {\n\t\t\tdev_err(&GET_DEV(accel_dev), \"Device busy\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tret = adf_dev_down(accel_dev, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (adf_cfg_section_add(accel_dev, ADF_KERNEL_SEC))\n\t\treturn -EFAULT;\n\tval = 0;\n\tif (adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC,\n\t\t\t\t\tADF_NUM_CY, (void *)&val, ADF_DEC))\n\t\treturn -EFAULT;\n\tret = adf_cfg_add_key_value_param(accel_dev, ADF_KERNEL_SEC, ADF_NUM_DC,\n\t\t\t\t\t  &val, ADF_DEC);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(ADF_STATUS_CONFIGURED, &accel_dev->status);\n\n\t \n\taccel_dev->pf.vf_info = kcalloc(totalvfs,\n\t\t\t\t\tsizeof(struct adf_accel_vf_info),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!accel_dev->pf.vf_info)\n\t\treturn -ENOMEM;\n\n\tif (adf_dev_up(accel_dev, false)) {\n\t\tdev_err(&GET_DEV(accel_dev), \"Failed to start qat_dev%d\\n\",\n\t\t\taccel_dev->accel_id);\n\t\treturn -EFAULT;\n\t}\n\n\tret = adf_enable_sriov(accel_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn numvfs;\n}\nEXPORT_SYMBOL_GPL(adf_sriov_configure);\n\nint __init adf_init_pf_wq(void)\n{\n\t \n\tpf2vf_resp_wq = alloc_workqueue(\"qat_pf2vf_resp_wq\", WQ_MEM_RECLAIM, 0);\n\n\treturn !pf2vf_resp_wq ? -ENOMEM : 0;\n}\n\nvoid adf_exit_pf_wq(void)\n{\n\tif (pf2vf_resp_wq) {\n\t\tdestroy_workqueue(pf2vf_resp_wq);\n\t\tpf2vf_resp_wq = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}