{
  "module_name": "adf_accel_devices.h",
  "hash_id": "4e792c036d4b6caeceb53231fdae6733cee6de7cb7ac17cb91fed1208ee28df5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_accel_devices.h",
  "human_readable_source": " \n \n#ifndef ADF_ACCEL_DEVICES_H_\n#define ADF_ACCEL_DEVICES_H_\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/ratelimit.h>\n#include \"adf_cfg_common.h\"\n#include \"adf_pfvf_msg.h\"\n\n#define ADF_DH895XCC_DEVICE_NAME \"dh895xcc\"\n#define ADF_DH895XCCVF_DEVICE_NAME \"dh895xccvf\"\n#define ADF_C62X_DEVICE_NAME \"c6xx\"\n#define ADF_C62XVF_DEVICE_NAME \"c6xxvf\"\n#define ADF_C3XXX_DEVICE_NAME \"c3xxx\"\n#define ADF_C3XXXVF_DEVICE_NAME \"c3xxxvf\"\n#define ADF_4XXX_DEVICE_NAME \"4xxx\"\n#define ADF_4XXX_PCI_DEVICE_ID 0x4940\n#define ADF_4XXXIOV_PCI_DEVICE_ID 0x4941\n#define ADF_401XX_PCI_DEVICE_ID 0x4942\n#define ADF_401XXIOV_PCI_DEVICE_ID 0x4943\n#define ADF_402XX_PCI_DEVICE_ID 0x4944\n#define ADF_402XXIOV_PCI_DEVICE_ID 0x4945\n#define ADF_DEVICE_FUSECTL_OFFSET 0x40\n#define ADF_DEVICE_LEGFUSE_OFFSET 0x4C\n#define ADF_DEVICE_FUSECTL_MASK 0x80000000\n#define ADF_PCI_MAX_BARS 3\n#define ADF_DEVICE_NAME_LENGTH 32\n#define ADF_ETR_MAX_RINGS_PER_BANK 16\n#define ADF_MAX_MSIX_VECTOR_NAME 48\n#define ADF_DEVICE_NAME_PREFIX \"qat_\"\n\nenum adf_accel_capabilities {\n\tADF_ACCEL_CAPABILITIES_NULL = 0,\n\tADF_ACCEL_CAPABILITIES_CRYPTO_SYMMETRIC = 1,\n\tADF_ACCEL_CAPABILITIES_CRYPTO_ASYMMETRIC = 2,\n\tADF_ACCEL_CAPABILITIES_CIPHER = 4,\n\tADF_ACCEL_CAPABILITIES_AUTHENTICATION = 8,\n\tADF_ACCEL_CAPABILITIES_COMPRESSION = 32,\n\tADF_ACCEL_CAPABILITIES_LZS_COMPRESSION = 64,\n\tADF_ACCEL_CAPABILITIES_RANDOM_NUMBER = 128\n};\n\nstruct adf_bar {\n\tresource_size_t base_addr;\n\tvoid __iomem *virt_addr;\n\tresource_size_t size;\n};\n\nstruct adf_irq {\n\tbool enabled;\n\tchar name[ADF_MAX_MSIX_VECTOR_NAME];\n};\n\nstruct adf_accel_msix {\n\tstruct adf_irq *irqs;\n\tu32 num_entries;\n};\n\nstruct adf_accel_pci {\n\tstruct pci_dev *pci_dev;\n\tstruct adf_accel_msix msix_entries;\n\tstruct adf_bar pci_bars[ADF_PCI_MAX_BARS];\n\tu8 revid;\n\tu8 sku;\n};\n\nenum dev_state {\n\tDEV_DOWN = 0,\n\tDEV_UP\n};\n\nenum dev_sku_info {\n\tDEV_SKU_1 = 0,\n\tDEV_SKU_2,\n\tDEV_SKU_3,\n\tDEV_SKU_4,\n\tDEV_SKU_VF,\n\tDEV_SKU_UNKNOWN,\n};\n\nstatic inline const char *get_sku_info(enum dev_sku_info info)\n{\n\tswitch (info) {\n\tcase DEV_SKU_1:\n\t\treturn \"SKU1\";\n\tcase DEV_SKU_2:\n\t\treturn \"SKU2\";\n\tcase DEV_SKU_3:\n\t\treturn \"SKU3\";\n\tcase DEV_SKU_4:\n\t\treturn \"SKU4\";\n\tcase DEV_SKU_VF:\n\t\treturn \"SKUVF\";\n\tcase DEV_SKU_UNKNOWN:\n\tdefault:\n\t\tbreak;\n\t}\n\treturn \"Unknown SKU\";\n}\n\nstruct adf_hw_device_class {\n\tconst char *name;\n\tconst enum adf_device_type type;\n\tu32 instances;\n};\n\nstruct arb_info {\n\tu32 arb_cfg;\n\tu32 arb_offset;\n\tu32 wt2sam_offset;\n};\n\nstruct admin_info {\n\tu32 admin_msg_ur;\n\tu32 admin_msg_lr;\n\tu32 mailbox_offset;\n};\n\nstruct adf_hw_csr_ops {\n\tu64 (*build_csr_ring_base_addr)(dma_addr_t addr, u32 size);\n\tu32 (*read_csr_ring_head)(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t  u32 ring);\n\tvoid (*write_csr_ring_head)(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t    u32 ring, u32 value);\n\tu32 (*read_csr_ring_tail)(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t  u32 ring);\n\tvoid (*write_csr_ring_tail)(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t    u32 ring, u32 value);\n\tu32 (*read_csr_e_stat)(void __iomem *csr_base_addr, u32 bank);\n\tvoid (*write_csr_ring_config)(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t      u32 ring, u32 value);\n\tvoid (*write_csr_ring_base)(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t    u32 ring, dma_addr_t addr);\n\tvoid (*write_csr_int_flag)(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t   u32 value);\n\tvoid (*write_csr_int_srcsel)(void __iomem *csr_base_addr, u32 bank);\n\tvoid (*write_csr_int_col_en)(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t     u32 value);\n\tvoid (*write_csr_int_col_ctl)(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t      u32 value);\n\tvoid (*write_csr_int_flag_and_col)(void __iomem *csr_base_addr,\n\t\t\t\t\t   u32 bank, u32 value);\n\tvoid (*write_csr_ring_srv_arb_en)(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t\t  u32 value);\n};\n\nstruct adf_cfg_device_data;\nstruct adf_accel_dev;\nstruct adf_etr_data;\nstruct adf_etr_ring_data;\n\nstruct adf_pfvf_ops {\n\tint (*enable_comms)(struct adf_accel_dev *accel_dev);\n\tu32 (*get_pf2vf_offset)(u32 i);\n\tu32 (*get_vf2pf_offset)(u32 i);\n\tvoid (*enable_vf2pf_interrupts)(void __iomem *pmisc_addr, u32 vf_mask);\n\tvoid (*disable_all_vf2pf_interrupts)(void __iomem *pmisc_addr);\n\tu32 (*disable_pending_vf2pf_interrupts)(void __iomem *pmisc_addr);\n\tint (*send_msg)(struct adf_accel_dev *accel_dev, struct pfvf_message msg,\n\t\t\tu32 pfvf_offset, struct mutex *csr_lock);\n\tstruct pfvf_message (*recv_msg)(struct adf_accel_dev *accel_dev,\n\t\t\t\t\tu32 pfvf_offset, u8 compat_ver);\n};\n\nstruct adf_dc_ops {\n\tvoid (*build_deflate_ctx)(void *ctx);\n};\n\nstruct adf_hw_device_data {\n\tstruct adf_hw_device_class *dev_class;\n\tu32 (*get_accel_mask)(struct adf_hw_device_data *self);\n\tu32 (*get_ae_mask)(struct adf_hw_device_data *self);\n\tu32 (*get_accel_cap)(struct adf_accel_dev *accel_dev);\n\tu32 (*get_sram_bar_id)(struct adf_hw_device_data *self);\n\tu32 (*get_misc_bar_id)(struct adf_hw_device_data *self);\n\tu32 (*get_etr_bar_id)(struct adf_hw_device_data *self);\n\tu32 (*get_num_aes)(struct adf_hw_device_data *self);\n\tu32 (*get_num_accels)(struct adf_hw_device_data *self);\n\tvoid (*get_arb_info)(struct arb_info *arb_csrs_info);\n\tvoid (*get_admin_info)(struct admin_info *admin_csrs_info);\n\tenum dev_sku_info (*get_sku)(struct adf_hw_device_data *self);\n\tu16 (*get_ring_to_svc_map)(struct adf_accel_dev *accel_dev);\n\tint (*alloc_irq)(struct adf_accel_dev *accel_dev);\n\tvoid (*free_irq)(struct adf_accel_dev *accel_dev);\n\tvoid (*enable_error_correction)(struct adf_accel_dev *accel_dev);\n\tint (*init_admin_comms)(struct adf_accel_dev *accel_dev);\n\tvoid (*exit_admin_comms)(struct adf_accel_dev *accel_dev);\n\tint (*send_admin_init)(struct adf_accel_dev *accel_dev);\n\tint (*start_timer)(struct adf_accel_dev *accel_dev);\n\tvoid (*stop_timer)(struct adf_accel_dev *accel_dev);\n\tvoid (*check_hb_ctrs)(struct adf_accel_dev *accel_dev);\n\tuint32_t (*get_hb_clock)(struct adf_hw_device_data *self);\n\tint (*measure_clock)(struct adf_accel_dev *accel_dev);\n\tint (*init_arb)(struct adf_accel_dev *accel_dev);\n\tvoid (*exit_arb)(struct adf_accel_dev *accel_dev);\n\tconst u32 *(*get_arb_mapping)(struct adf_accel_dev *accel_dev);\n\tint (*init_device)(struct adf_accel_dev *accel_dev);\n\tint (*enable_pm)(struct adf_accel_dev *accel_dev);\n\tbool (*handle_pm_interrupt)(struct adf_accel_dev *accel_dev);\n\tvoid (*disable_iov)(struct adf_accel_dev *accel_dev);\n\tvoid (*configure_iov_threads)(struct adf_accel_dev *accel_dev,\n\t\t\t\t      bool enable);\n\tvoid (*enable_ints)(struct adf_accel_dev *accel_dev);\n\tvoid (*set_ssm_wdtimer)(struct adf_accel_dev *accel_dev);\n\tint (*ring_pair_reset)(struct adf_accel_dev *accel_dev, u32 bank_nr);\n\tvoid (*reset_device)(struct adf_accel_dev *accel_dev);\n\tvoid (*set_msix_rttable)(struct adf_accel_dev *accel_dev);\n\tconst char *(*uof_get_name)(struct adf_accel_dev *accel_dev, u32 obj_num);\n\tu32 (*uof_get_num_objs)(void);\n\tu32 (*uof_get_ae_mask)(struct adf_accel_dev *accel_dev, u32 obj_num);\n\tint (*dev_config)(struct adf_accel_dev *accel_dev);\n\tstruct adf_pfvf_ops pfvf_ops;\n\tstruct adf_hw_csr_ops csr_ops;\n\tstruct adf_dc_ops dc_ops;\n\tconst char *fw_name;\n\tconst char *fw_mmp_name;\n\tu32 fuses;\n\tu32 straps;\n\tu32 accel_capabilities_mask;\n\tu32 extended_dc_capabilities;\n\tu32 clock_frequency;\n\tu32 instance_id;\n\tu16 accel_mask;\n\tu32 ae_mask;\n\tu32 admin_ae_mask;\n\tu16 tx_rings_mask;\n\tu16 ring_to_svc_map;\n\tu8 tx_rx_gap;\n\tu8 num_banks;\n\tu16 num_banks_per_vf;\n\tu8 num_rings_per_bank;\n\tu8 num_accel;\n\tu8 num_logical_accel;\n\tu8 num_engines;\n\tu32 num_hb_ctrs;\n};\n\n \n#define ADF_CSR_WR(csr_base, csr_offset, val) \\\n\t__raw_writel(val, csr_base + csr_offset)\n\n \n#define ADF_CSR_RD(csr_base, csr_offset) __raw_readl(csr_base + csr_offset)\n\n#define ADF_CFG_NUM_SERVICES\t4\n#define ADF_SRV_TYPE_BIT_LEN\t3\n#define ADF_SRV_TYPE_MASK\t0x7\n#define ADF_AE_ADMIN_THREAD\t7\n#define ADF_NUM_THREADS_PER_AE\t8\n#define ADF_NUM_PKE_STRAND\t2\n#define ADF_AE_STRAND0_THREAD\t8\n#define ADF_AE_STRAND1_THREAD\t9\n\n#define GET_DEV(accel_dev) ((accel_dev)->accel_pci_dev.pci_dev->dev)\n#define GET_BARS(accel_dev) ((accel_dev)->accel_pci_dev.pci_bars)\n#define GET_HW_DATA(accel_dev) (accel_dev->hw_device)\n#define GET_MAX_BANKS(accel_dev) (GET_HW_DATA(accel_dev)->num_banks)\n#define GET_NUM_RINGS_PER_BANK(accel_dev) \\\n\tGET_HW_DATA(accel_dev)->num_rings_per_bank\n#define GET_SRV_TYPE(accel_dev, idx) \\\n\t(((GET_HW_DATA(accel_dev)->ring_to_svc_map) >> (ADF_SRV_TYPE_BIT_LEN * (idx))) \\\n\t& ADF_SRV_TYPE_MASK)\n#define GET_MAX_ACCELENGINES(accel_dev) (GET_HW_DATA(accel_dev)->num_engines)\n#define GET_CSR_OPS(accel_dev) (&(accel_dev)->hw_device->csr_ops)\n#define GET_PFVF_OPS(accel_dev) (&(accel_dev)->hw_device->pfvf_ops)\n#define GET_DC_OPS(accel_dev) (&(accel_dev)->hw_device->dc_ops)\n#define accel_to_pci_dev(accel_ptr) accel_ptr->accel_pci_dev.pci_dev\n\nstruct adf_admin_comms;\nstruct icp_qat_fw_loader_handle;\nstruct adf_fw_loader_data {\n\tstruct icp_qat_fw_loader_handle *fw_loader;\n\tconst struct firmware *uof_fw;\n\tconst struct firmware *mmp_fw;\n};\n\nstruct adf_accel_vf_info {\n\tstruct adf_accel_dev *accel_dev;\n\tstruct mutex pf2vf_lock;  \n\tstruct ratelimit_state vf2pf_ratelimit;\n\tu32 vf_nr;\n\tbool init;\n\tu8 vf_compat_ver;\n};\n\nstruct adf_dc_data {\n\tu8 *ovf_buff;\n\tsize_t ovf_buff_sz;\n\tdma_addr_t ovf_buff_p;\n};\n\nstruct adf_accel_dev {\n\tstruct adf_etr_data *transport;\n\tstruct adf_hw_device_data *hw_device;\n\tstruct adf_cfg_device_data *cfg;\n\tstruct adf_fw_loader_data *fw_loader;\n\tstruct adf_admin_comms *admin;\n\tstruct adf_dc_data *dc_data;\n\tstruct list_head crypto_list;\n\tstruct list_head compression_list;\n\tunsigned long status;\n\tatomic_t ref_count;\n\tstruct dentry *debugfs_dir;\n\tstruct dentry *fw_cntr_dbgfile;\n\tstruct list_head list;\n\tstruct module *owner;\n\tstruct adf_accel_pci accel_pci_dev;\n\tstruct adf_timer *timer;\n\tstruct adf_heartbeat *heartbeat;\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\tspinlock_t vf2pf_ints_lock;\n\t\t\t \n\t\t\tstruct adf_accel_vf_info *vf_info;\n\t\t} pf;\n\t\tstruct {\n\t\t\tbool irq_enabled;\n\t\t\tchar irq_name[ADF_MAX_MSIX_VECTOR_NAME];\n\t\t\tstruct tasklet_struct pf2vf_bh_tasklet;\n\t\t\tstruct mutex vf2pf_lock;  \n\t\t\tstruct completion msg_received;\n\t\t\tstruct pfvf_message response;  \n\t\t\tu8 pf_compat_ver;\n\t\t} vf;\n\t};\n\tstruct mutex state_lock;  \n\tbool is_vf;\n\tu32 accel_id;\n};\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}