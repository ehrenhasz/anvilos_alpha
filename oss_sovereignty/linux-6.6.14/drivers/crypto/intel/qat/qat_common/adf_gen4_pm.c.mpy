{
  "module_name": "adf_gen4_pm.c",
  "hash_id": "e9e08f2a83d230c73e1c0d308996b8045fef2f1545cb5624f5d4e5468c6f3f29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_gen4_pm.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/iopoll.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_common_drv.h\"\n#include \"adf_gen4_pm.h\"\n#include \"adf_cfg_strings.h\"\n#include \"icp_qat_fw_init_admin.h\"\n#include \"adf_gen4_hw_data.h\"\n#include \"adf_cfg.h\"\n\nenum qat_pm_host_msg {\n\tPM_NO_CHANGE = 0,\n\tPM_SET_MIN,\n};\n\nstruct adf_gen4_pm_data {\n\tstruct work_struct pm_irq_work;\n\tstruct adf_accel_dev *accel_dev;\n\tu32 pm_int_sts;\n};\n\nstatic int send_host_msg(struct adf_accel_dev *accel_dev)\n{\n\tchar pm_idle_support_cfg[ADF_CFG_MAX_VAL_LEN_IN_BYTES] = {};\n\tvoid __iomem *pmisc = adf_get_pmisc_base(accel_dev);\n\tbool pm_idle_support;\n\tu32 msg;\n\tint ret;\n\n\tmsg = ADF_CSR_RD(pmisc, ADF_GEN4_PM_HOST_MSG);\n\tif (msg & ADF_GEN4_PM_MSG_PENDING)\n\t\treturn -EBUSY;\n\n\tadf_cfg_get_param_value(accel_dev, ADF_GENERAL_SEC,\n\t\t\t\tADF_PM_IDLE_SUPPORT, pm_idle_support_cfg);\n\tret = kstrtobool(pm_idle_support_cfg, &pm_idle_support);\n\tif (ret)\n\t\tpm_idle_support = true;\n\n\t \n\tmsg = FIELD_PREP(ADF_GEN4_PM_MSG_PAYLOAD_BIT_MASK,\n\t\t\t pm_idle_support ? PM_SET_MIN : PM_NO_CHANGE);\n\tmsg |= ADF_GEN4_PM_MSG_PENDING;\n\tADF_CSR_WR(pmisc, ADF_GEN4_PM_HOST_MSG, msg);\n\n\t \n\treturn read_poll_timeout(ADF_CSR_RD, msg,\n\t\t\t\t!(msg & ADF_GEN4_PM_MSG_PENDING),\n\t\t\t\tADF_GEN4_PM_MSG_POLL_DELAY_US,\n\t\t\t\tADF_GEN4_PM_POLL_TIMEOUT_US, true, pmisc,\n\t\t\t\tADF_GEN4_PM_HOST_MSG);\n}\n\nstatic void pm_bh_handler(struct work_struct *work)\n{\n\tstruct adf_gen4_pm_data *pm_data =\n\t\tcontainer_of(work, struct adf_gen4_pm_data, pm_irq_work);\n\tstruct adf_accel_dev *accel_dev = pm_data->accel_dev;\n\tvoid __iomem *pmisc = adf_get_pmisc_base(accel_dev);\n\tu32 pm_int_sts = pm_data->pm_int_sts;\n\tu32 val;\n\n\t \n\tif (pm_int_sts & ADF_GEN4_PM_IDLE_STS) {\n\t\t \n\t\tif (send_host_msg(accel_dev))\n\t\t\tdev_warn_ratelimited(&GET_DEV(accel_dev),\n\t\t\t\t\t     \"Failed to send host msg to FW\\n\");\n\t}\n\n\t \n\tADF_CSR_WR(pmisc, ADF_GEN4_PM_INTERRUPT, pm_int_sts);\n\n\t \n\tval = ADF_CSR_RD(pmisc, ADF_GEN4_ERRMSK2);\n\tval &= ~ADF_GEN4_PM_SOU;\n\tADF_CSR_WR(pmisc, ADF_GEN4_ERRMSK2, val);\n\n\tkfree(pm_data);\n}\n\nbool adf_gen4_handle_pm_interrupt(struct adf_accel_dev *accel_dev)\n{\n\tvoid __iomem *pmisc = adf_get_pmisc_base(accel_dev);\n\tstruct adf_gen4_pm_data *pm_data = NULL;\n\tu32 errsou2;\n\tu32 errmsk2;\n\tu32 val;\n\n\t \n\terrmsk2 = ADF_CSR_RD(pmisc, ADF_GEN4_ERRMSK2);\n\tif (errmsk2 & ADF_GEN4_PM_SOU)\n\t\treturn false;\n\n\terrsou2 = ADF_CSR_RD(pmisc, ADF_GEN4_ERRSOU2);\n\tif (!(errsou2 & ADF_GEN4_PM_SOU))\n\t\treturn false;\n\n\t \n\tval = ADF_CSR_RD(pmisc, ADF_GEN4_ERRMSK2);\n\tval |= ADF_GEN4_PM_SOU;\n\tADF_CSR_WR(pmisc, ADF_GEN4_ERRMSK2, val);\n\n\tval = ADF_CSR_RD(pmisc, ADF_GEN4_PM_INTERRUPT);\n\n\tpm_data = kzalloc(sizeof(*pm_data), GFP_ATOMIC);\n\tif (!pm_data)\n\t\treturn false;\n\n\tpm_data->pm_int_sts = val;\n\tpm_data->accel_dev = accel_dev;\n\n\tINIT_WORK(&pm_data->pm_irq_work, pm_bh_handler);\n\tadf_misc_wq_queue_work(&pm_data->pm_irq_work);\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(adf_gen4_handle_pm_interrupt);\n\nint adf_gen4_enable_pm(struct adf_accel_dev *accel_dev)\n{\n\tvoid __iomem *pmisc = adf_get_pmisc_base(accel_dev);\n\tint ret;\n\tu32 val;\n\n\tret = adf_init_admin_pm(accel_dev, ADF_GEN4_PM_DEFAULT_IDLE_FILTER);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = ADF_CSR_RD(pmisc, ADF_GEN4_PM_INTERRUPT);\n\tval |= ADF_GEN4_PM_INT_EN_DEFAULT;\n\n\t \n\tval |= ADF_GEN4_PM_INT_STS_MASK;\n\tADF_CSR_WR(pmisc, ADF_GEN4_PM_INTERRUPT, val);\n\n\t \n\tval = ADF_CSR_RD(pmisc, ADF_GEN4_ERRMSK2);\n\tval &= ~ADF_GEN4_PM_SOU;\n\tADF_CSR_WR(pmisc, ADF_GEN4_ERRMSK2, val);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(adf_gen4_enable_pm);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}