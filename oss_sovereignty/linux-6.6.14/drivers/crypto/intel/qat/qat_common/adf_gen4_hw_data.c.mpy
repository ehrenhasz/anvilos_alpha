{
  "module_name": "adf_gen4_hw_data.c",
  "hash_id": "64da1cdf6d831e841667fc5cd28ad77b4354b2712969dcf7033b5d279dc39bd1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_gen4_hw_data.c",
  "human_readable_source": "\n \n#include <linux/iopoll.h>\n#include \"adf_accel_devices.h\"\n#include \"adf_common_drv.h\"\n#include \"adf_gen4_hw_data.h\"\n\nstatic u64 build_csr_ring_base_addr(dma_addr_t addr, u32 size)\n{\n\treturn BUILD_RING_BASE_ADDR(addr, size);\n}\n\nstatic u32 read_csr_ring_head(void __iomem *csr_base_addr, u32 bank, u32 ring)\n{\n\treturn READ_CSR_RING_HEAD(csr_base_addr, bank, ring);\n}\n\nstatic void write_csr_ring_head(void __iomem *csr_base_addr, u32 bank, u32 ring,\n\t\t\t\tu32 value)\n{\n\tWRITE_CSR_RING_HEAD(csr_base_addr, bank, ring, value);\n}\n\nstatic u32 read_csr_ring_tail(void __iomem *csr_base_addr, u32 bank, u32 ring)\n{\n\treturn READ_CSR_RING_TAIL(csr_base_addr, bank, ring);\n}\n\nstatic void write_csr_ring_tail(void __iomem *csr_base_addr, u32 bank, u32 ring,\n\t\t\t\tu32 value)\n{\n\tWRITE_CSR_RING_TAIL(csr_base_addr, bank, ring, value);\n}\n\nstatic u32 read_csr_e_stat(void __iomem *csr_base_addr, u32 bank)\n{\n\treturn READ_CSR_E_STAT(csr_base_addr, bank);\n}\n\nstatic void write_csr_ring_config(void __iomem *csr_base_addr, u32 bank, u32 ring,\n\t\t\t\t  u32 value)\n{\n\tWRITE_CSR_RING_CONFIG(csr_base_addr, bank, ring, value);\n}\n\nstatic void write_csr_ring_base(void __iomem *csr_base_addr, u32 bank, u32 ring,\n\t\t\t\tdma_addr_t addr)\n{\n\tWRITE_CSR_RING_BASE(csr_base_addr, bank, ring, addr);\n}\n\nstatic void write_csr_int_flag(void __iomem *csr_base_addr, u32 bank,\n\t\t\t       u32 value)\n{\n\tWRITE_CSR_INT_FLAG(csr_base_addr, bank, value);\n}\n\nstatic void write_csr_int_srcsel(void __iomem *csr_base_addr, u32 bank)\n{\n\tWRITE_CSR_INT_SRCSEL(csr_base_addr, bank);\n}\n\nstatic void write_csr_int_col_en(void __iomem *csr_base_addr, u32 bank, u32 value)\n{\n\tWRITE_CSR_INT_COL_EN(csr_base_addr, bank, value);\n}\n\nstatic void write_csr_int_col_ctl(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t  u32 value)\n{\n\tWRITE_CSR_INT_COL_CTL(csr_base_addr, bank, value);\n}\n\nstatic void write_csr_int_flag_and_col(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t       u32 value)\n{\n\tWRITE_CSR_INT_FLAG_AND_COL(csr_base_addr, bank, value);\n}\n\nstatic void write_csr_ring_srv_arb_en(void __iomem *csr_base_addr, u32 bank,\n\t\t\t\t      u32 value)\n{\n\tWRITE_CSR_RING_SRV_ARB_EN(csr_base_addr, bank, value);\n}\n\nvoid adf_gen4_init_hw_csr_ops(struct adf_hw_csr_ops *csr_ops)\n{\n\tcsr_ops->build_csr_ring_base_addr = build_csr_ring_base_addr;\n\tcsr_ops->read_csr_ring_head = read_csr_ring_head;\n\tcsr_ops->write_csr_ring_head = write_csr_ring_head;\n\tcsr_ops->read_csr_ring_tail = read_csr_ring_tail;\n\tcsr_ops->write_csr_ring_tail = write_csr_ring_tail;\n\tcsr_ops->read_csr_e_stat = read_csr_e_stat;\n\tcsr_ops->write_csr_ring_config = write_csr_ring_config;\n\tcsr_ops->write_csr_ring_base = write_csr_ring_base;\n\tcsr_ops->write_csr_int_flag = write_csr_int_flag;\n\tcsr_ops->write_csr_int_srcsel = write_csr_int_srcsel;\n\tcsr_ops->write_csr_int_col_en = write_csr_int_col_en;\n\tcsr_ops->write_csr_int_col_ctl = write_csr_int_col_ctl;\n\tcsr_ops->write_csr_int_flag_and_col = write_csr_int_flag_and_col;\n\tcsr_ops->write_csr_ring_srv_arb_en = write_csr_ring_srv_arb_en;\n}\nEXPORT_SYMBOL_GPL(adf_gen4_init_hw_csr_ops);\n\nstatic inline void adf_gen4_unpack_ssm_wdtimer(u64 value, u32 *upper,\n\t\t\t\t\t       u32 *lower)\n{\n\t*lower = lower_32_bits(value);\n\t*upper = upper_32_bits(value);\n}\n\nvoid adf_gen4_set_ssm_wdtimer(struct adf_accel_dev *accel_dev)\n{\n\tvoid __iomem *pmisc_addr = adf_get_pmisc_base(accel_dev);\n\tu64 timer_val_pke = ADF_SSM_WDT_PKE_DEFAULT_VALUE;\n\tu64 timer_val = ADF_SSM_WDT_DEFAULT_VALUE;\n\tu32 ssm_wdt_pke_high = 0;\n\tu32 ssm_wdt_pke_low = 0;\n\tu32 ssm_wdt_high = 0;\n\tu32 ssm_wdt_low = 0;\n\n\t \n\tadf_gen4_unpack_ssm_wdtimer(timer_val, &ssm_wdt_high, &ssm_wdt_low);\n\tadf_gen4_unpack_ssm_wdtimer(timer_val_pke, &ssm_wdt_pke_high,\n\t\t\t\t    &ssm_wdt_pke_low);\n\n\t \n\tADF_CSR_WR(pmisc_addr, ADF_SSMWDTL_OFFSET, ssm_wdt_low);\n\tADF_CSR_WR(pmisc_addr, ADF_SSMWDTH_OFFSET, ssm_wdt_high);\n\t \n\tADF_CSR_WR(pmisc_addr, ADF_SSMWDTPKEL_OFFSET, ssm_wdt_pke_low);\n\tADF_CSR_WR(pmisc_addr, ADF_SSMWDTPKEH_OFFSET, ssm_wdt_pke_high);\n}\nEXPORT_SYMBOL_GPL(adf_gen4_set_ssm_wdtimer);\n\nint adf_pfvf_comms_disabled(struct adf_accel_dev *accel_dev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(adf_pfvf_comms_disabled);\n\nstatic int reset_ring_pair(void __iomem *csr, u32 bank_number)\n{\n\tu32 status;\n\tint ret;\n\n\t \n\tADF_CSR_WR(csr, ADF_WQM_CSR_RPRESETCTL(bank_number),\n\t\t   ADF_WQM_CSR_RPRESETCTL_RESET);\n\n\t \n\tret = read_poll_timeout(ADF_CSR_RD, status,\n\t\t\t\tstatus & ADF_WQM_CSR_RPRESETSTS_STATUS,\n\t\t\t\tADF_RPRESET_POLL_DELAY_US,\n\t\t\t\tADF_RPRESET_POLL_TIMEOUT_US, true,\n\t\t\t\tcsr, ADF_WQM_CSR_RPRESETSTS(bank_number));\n\tif (!ret) {\n\t\t \n\t\tADF_CSR_WR(csr, ADF_WQM_CSR_RPRESETSTS(bank_number),\n\t\t\t   ADF_WQM_CSR_RPRESETSTS_STATUS);\n\t}\n\n\treturn ret;\n}\n\nint adf_gen4_ring_pair_reset(struct adf_accel_dev *accel_dev, u32 bank_number)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tu32 etr_bar_id = hw_data->get_etr_bar_id(hw_data);\n\tvoid __iomem *csr;\n\tint ret;\n\n\tif (bank_number >= hw_data->num_banks)\n\t\treturn -EINVAL;\n\n\tdev_dbg(&GET_DEV(accel_dev),\n\t\t\"ring pair reset for bank:%d\\n\", bank_number);\n\n\tcsr = (&GET_BARS(accel_dev)[etr_bar_id])->virt_addr;\n\tret = reset_ring_pair(csr, bank_number);\n\tif (ret)\n\t\tdev_err(&GET_DEV(accel_dev),\n\t\t\t\"ring pair reset failed (timeout)\\n\");\n\telse\n\t\tdev_dbg(&GET_DEV(accel_dev), \"ring pair reset successful\\n\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(adf_gen4_ring_pair_reset);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}