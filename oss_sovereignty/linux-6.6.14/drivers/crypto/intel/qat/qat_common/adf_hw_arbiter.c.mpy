{
  "module_name": "adf_hw_arbiter.c",
  "hash_id": "816f81e2f1148bce72b64eae989b8a3de5eee015e4d0b8bff52993415180bee1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/crypto/intel/qat/qat_common/adf_hw_arbiter.c",
  "human_readable_source": "\n \n#include \"adf_accel_devices.h\"\n#include \"adf_common_drv.h\"\n#include \"adf_transport_internal.h\"\n\n#define ADF_ARB_NUM 4\n#define ADF_ARB_REG_SIZE 0x4\n\n#define WRITE_CSR_ARB_SARCONFIG(csr_addr, arb_offset, index, value) \\\n\tADF_CSR_WR(csr_addr, (arb_offset) + \\\n\t(ADF_ARB_REG_SIZE * (index)), value)\n\n#define WRITE_CSR_ARB_WT2SAM(csr_addr, arb_offset, wt_offset, index, value) \\\n\tADF_CSR_WR(csr_addr, ((arb_offset) + (wt_offset)) + \\\n\t(ADF_ARB_REG_SIZE * (index)), value)\n\nint adf_init_arb(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tvoid __iomem *csr = accel_dev->transport->banks[0].csr_addr;\n\tunsigned long ae_mask = hw_data->ae_mask;\n\tu32 arb_off, wt_off, arb_cfg;\n\tconst u32 *thd_2_arb_cfg;\n\tstruct arb_info info;\n\tint arb, i;\n\n\thw_data->get_arb_info(&info);\n\tarb_cfg = info.arb_cfg;\n\tarb_off = info.arb_offset;\n\twt_off = info.wt2sam_offset;\n\n\t \n\tfor (arb = 0; arb < ADF_ARB_NUM; arb++)\n\t\tWRITE_CSR_ARB_SARCONFIG(csr, arb_off, arb, arb_cfg);\n\n\t \n\tthd_2_arb_cfg = hw_data->get_arb_mapping(accel_dev);\n\n\tfor_each_set_bit(i, &ae_mask, hw_data->num_engines)\n\t\tWRITE_CSR_ARB_WT2SAM(csr, arb_off, wt_off, i, thd_2_arb_cfg[i]);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(adf_init_arb);\n\nvoid adf_update_ring_arb(struct adf_etr_ring_data *ring)\n{\n\tstruct adf_accel_dev *accel_dev = ring->bank->accel_dev;\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tstruct adf_hw_csr_ops *csr_ops = GET_CSR_OPS(accel_dev);\n\tu32 tx_ring_mask = hw_data->tx_rings_mask;\n\tu32 shift = hw_data->tx_rx_gap;\n\tu32 arben, arben_tx, arben_rx;\n\tu32 rx_ring_mask;\n\n\t \n\trx_ring_mask = tx_ring_mask << shift;\n\tarben_tx = (ring->bank->ring_mask & tx_ring_mask) >> 0;\n\tarben_rx = (ring->bank->ring_mask & rx_ring_mask) >> shift;\n\tarben = arben_tx & arben_rx;\n\n\tcsr_ops->write_csr_ring_srv_arb_en(ring->bank->csr_addr,\n\t\t\t\t\t   ring->bank->bank_number, arben);\n}\n\nvoid adf_exit_arb(struct adf_accel_dev *accel_dev)\n{\n\tstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\n\tstruct adf_hw_csr_ops *csr_ops = GET_CSR_OPS(accel_dev);\n\tu32 arb_off, wt_off;\n\tstruct arb_info info;\n\tvoid __iomem *csr;\n\tunsigned int i;\n\n\thw_data->get_arb_info(&info);\n\tarb_off = info.arb_offset;\n\twt_off = info.wt2sam_offset;\n\n\tif (!accel_dev->transport)\n\t\treturn;\n\n\tcsr = accel_dev->transport->banks[0].csr_addr;\n\n\thw_data->get_arb_info(&info);\n\n\t \n\tfor (i = 0; i < ADF_ARB_NUM; i++)\n\t\tWRITE_CSR_ARB_SARCONFIG(csr, arb_off, i, 0);\n\n\t \n\tfor (i = 0; i < hw_data->num_engines; i++)\n\t\tWRITE_CSR_ARB_WT2SAM(csr, arb_off, wt_off, i, 0);\n\n\t \n\tfor (i = 0; i < GET_MAX_BANKS(accel_dev); i++)\n\t\tcsr_ops->write_csr_ring_srv_arb_en(csr, i, 0);\n}\nEXPORT_SYMBOL_GPL(adf_exit_arb);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}